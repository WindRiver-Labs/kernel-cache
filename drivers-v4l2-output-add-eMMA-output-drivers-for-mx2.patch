From 9ebaa7873b9c95e02bcedbc9dc41ced542b47bc2 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Thu, 4 Feb 2010 19:11:23 +0800
Subject: [PATCH] drivers/v4l2/output: add eMMA output drivers for mx27 platoforms

The multimedia accelerator on mx27 is eMMA rather IPU. So add
eMMA output drivers.

Original reference source code taken from Freescale internal use
version:Linux2.6.28_4.1.0_MX51TO2_FC_ER8.tar.gz

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
---
 drivers/media/video/Kconfig                        |    9 +
 drivers/media/video/Makefile                       |    2 +
 drivers/media/video/mxc/opl/Makefile               |    5 +
 .../media/video/mxc/opl/hmirror_rotate180_u16.c    |  258 ++++
 drivers/media/video/mxc/opl/opl.h                  |  162 +++
 drivers/media/video/mxc/opl/opl_mod.c              |   30 +
 drivers/media/video/mxc/opl/rotate270_u16.c        |  284 ++++
 drivers/media/video/mxc/opl/rotate270_u16_qcif.S   |   70 +
 drivers/media/video/mxc/opl/rotate90_u16.c         |  219 +++
 drivers/media/video/mxc/opl/rotate90_u16_qcif.S    |   71 +
 drivers/media/video/mxc/opl/vmirror_u16.c          |   45 +
 drivers/media/video/mxc/output/Kconfig             |    7 +
 drivers/media/video/mxc/output/Makefile            |    5 +
 drivers/media/video/mxc/output/mx27_pp.c           |  904 +++++++++++++
 drivers/media/video/mxc/output/mx27_pp.h           |  180 +++
 drivers/media/video/mxc/output/mx27_v4l2_output.c  | 1423 ++++++++++++++++++++
 16 files changed, 3674 insertions(+), 0 deletions(-)
 create mode 100644 drivers/media/video/mxc/opl/Makefile
 create mode 100644 drivers/media/video/mxc/opl/hmirror_rotate180_u16.c
 create mode 100644 drivers/media/video/mxc/opl/opl.h
 create mode 100644 drivers/media/video/mxc/opl/opl_mod.c
 create mode 100644 drivers/media/video/mxc/opl/rotate270_u16.c
 create mode 100644 drivers/media/video/mxc/opl/rotate270_u16_qcif.S
 create mode 100644 drivers/media/video/mxc/opl/rotate90_u16.c
 create mode 100644 drivers/media/video/mxc/opl/rotate90_u16_qcif.S
 create mode 100644 drivers/media/video/mxc/opl/vmirror_u16.c
 create mode 100644 drivers/media/video/mxc/output/mx27_pp.c
 create mode 100644 drivers/media/video/mxc/output/mx27_pp.h
 create mode 100644 drivers/media/video/mxc/output/mx27_v4l2_output.c

diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 380451e..26dd09d 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -547,6 +547,15 @@ config VIDEO_MXC_OUTPUT
 
 source "drivers/media/video/mxc/output/Kconfig"
 
+config VIDEO_MXC_OPL
+	tristate
+	depends on VIDEO_DEV && ARCH_MXC
+	default n
+	---help---
+	  This is the ARM9-optimized OPL (Open Primitives Library) software
+	  rotation/mirroring implementation. It may be used by eMMA video
+	  capture or output device.
+
 config VIDEO_CPIA
 	tristate "CPiA Video For Linux"
 	depends on VIDEO_V4L1
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index d8ec1f9..cceb971 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -67,6 +67,8 @@ obj-$(CONFIG_VIDEO_CPIA) += cpia.o
 obj-$(CONFIG_VIDEO_CPIA_PP) += cpia_pp.o
 obj-$(CONFIG_VIDEO_CPIA_USB) += cpia_usb.o
 obj-$(CONFIG_VIDEO_MXC_EMMA_CAMERA) += mxc/capture/
+obj-$(CONFIG_VIDEO_MXC_EMMA_OUTPUT) += mxc/output/
+obj-$(CONFIG_VIDEO_MXC_OPL) += mxc/opl/
 obj-$(CONFIG_VIDEO_MEYE) += meye.o
 obj-$(CONFIG_VIDEO_SAA7134) += saa7134/
 obj-$(CONFIG_VIDEO_CX88) += cx88/
diff --git a/drivers/media/video/mxc/opl/Makefile b/drivers/media/video/mxc/opl/Makefile
new file mode 100644
index 0000000..092a62c
--- /dev/null
+++ b/drivers/media/video/mxc/opl/Makefile
@@ -0,0 +1,5 @@
+opl-objs	:= opl_mod.o rotate90_u16.o rotate270_u16.o	\
+		   rotate90_u16_qcif.o rotate270_u16_qcif.o	\
+		   vmirror_u16.o hmirror_rotate180_u16.o
+
+obj-$(CONFIG_VIDEO_MXC_OPL)	+= opl.o
diff --git a/drivers/media/video/mxc/opl/hmirror_rotate180_u16.c b/drivers/media/video/mxc/opl/hmirror_rotate180_u16.c
new file mode 100644
index 0000000..3bd430d
--- /dev/null
+++ b/drivers/media/video/mxc/opl/hmirror_rotate180_u16.c
@@ -0,0 +1,258 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include "opl.h"
+
+static inline u32 rot_left_u16(u16 x, unsigned int n)
+{
+	return (x << n) | (x >> (16 - n));
+}
+
+static inline u32 rot_left_u32(u32 x, unsigned int n)
+{
+	return (x << n) | (x >> (32 - n));
+}
+
+static inline u32 byte_swap_u32(u32 x)
+{
+	u32 t1, t2, t3;
+
+	t1 = x ^ ((x << 16) | x >> 16);
+	t2 = t1 & 0xff00ffff;
+	t3 = (x >> 8) | (x << 24);
+	return t3 ^ (t2 >> 8);
+}
+
+static int opl_hmirror_u16_by1(const u8 *src, int src_line_stride, int width,
+			       int height, u8 *dst, int dst_line_stride,
+			       int vmirror);
+static int opl_hmirror_u16_by2(const u8 *src, int src_line_stride, int width,
+			       int height, u8 *dst, int dst_line_stride,
+			       int vmirror);
+static int opl_hmirror_u16_by4(const u8 *src, int src_line_stride, int width,
+			       int height, u8 *dst, int dst_line_stride,
+			       int vmirror);
+static int opl_hmirror_u16_by8(const u8 *src, int src_line_stride, int width,
+			       int height, u8 *dst, int dst_line_stride,
+			       int vmirror);
+
+int opl_hmirror_u16(const u8 *src, int src_line_stride, int width, int height,
+		    u8 *dst, int dst_line_stride)
+{
+	if (!src || !dst)
+		return OPLERR_NULL_PTR;
+
+	if (width == 0 || height == 0 || src_line_stride == 0
+	    || dst_line_stride == 0)
+		return OPLERR_BAD_ARG;
+
+	if (width % 8 == 0)
+		return opl_hmirror_u16_by8(src, src_line_stride, width, height,
+					   dst, dst_line_stride, 0);
+	else if (width % 4 == 0)
+		return opl_hmirror_u16_by4(src, src_line_stride, width, height,
+					   dst, dst_line_stride, 0);
+	else if (width % 2 == 0)
+		return opl_hmirror_u16_by2(src, src_line_stride, width, height,
+					   dst, dst_line_stride, 0);
+	else			/* (width % 1) */
+		return opl_hmirror_u16_by1(src, src_line_stride, width, height,
+					   dst, dst_line_stride, 0);
+}
+EXPORT_SYMBOL(opl_hmirror_u16);
+
+int opl_rotate180_u16(const u8 *src, int src_line_stride, int width,
+		      int height, u8 *dst, int dst_line_stride)
+{
+	if (!src || !dst)
+		return OPLERR_NULL_PTR;
+
+	if (width == 0 || height == 0 || src_line_stride == 0
+	    || dst_line_stride == 0)
+		return OPLERR_BAD_ARG;
+
+	if (width % 8 == 0)
+		return opl_hmirror_u16_by8(src, src_line_stride, width, height,
+					   dst, dst_line_stride, 1);
+	else if (width % 4 == 0)
+		return opl_hmirror_u16_by4(src, src_line_stride, width, height,
+					   dst, dst_line_stride, 1);
+	else if (width % 2 == 0)
+		return opl_hmirror_u16_by2(src, src_line_stride, width, height,
+					   dst, dst_line_stride, 1);
+	else			/* (width % 1) */
+		return opl_hmirror_u16_by1(src, src_line_stride, width, height,
+					   dst, dst_line_stride, 1);
+}
+EXPORT_SYMBOL(opl_rotate180_u16);
+
+static int opl_hmirror_u16_by1(const u8 *src, int src_line_stride, int width,
+			       int height, u8 *dst, int dst_line_stride,
+			       int vmirror)
+{
+	const u8 *src_row_addr;
+	const u8 *psrc;
+	u8 *dst_row_addr, *pdst;
+	int i, j;
+	u16 pixel;
+
+	src_row_addr = src;
+	if (vmirror) {
+		dst_row_addr = dst + dst_line_stride * (height - 1);
+		dst_line_stride = -dst_line_stride;
+	} else
+		dst_row_addr = dst;
+
+	/* Loop over all rows */
+	for (i = 0; i < height; i++) {
+		/* Loop over each pixel */
+		psrc = src_row_addr;
+		pdst = dst_row_addr + (width - 1) * BYTES_PER_PIXEL
+		    - (BYTES_PER_PIXEL - BYTES_PER_PIXEL);
+		for (j = 0; j < width; j++) {
+			pixel = *(u16 *) psrc;
+			*(u16 *) pdst = pixel;
+			psrc += BYTES_PER_PIXEL;
+			pdst -= BYTES_PER_PIXEL;
+		}
+		src_row_addr += src_line_stride;
+		dst_row_addr += dst_line_stride;
+	}
+
+	return OPLERR_SUCCESS;
+}
+
+static int opl_hmirror_u16_by2(const u8 *src, int src_line_stride, int width,
+			       int height, u8 *dst, int dst_line_stride,
+			       int vmirror)
+{
+	const u8 *src_row_addr;
+	const u8 *psrc;
+	u8 *dst_row_addr, *pdst;
+	int i, j;
+	u32 pixelsin, pixelsout;
+
+	src_row_addr = src;
+	if (vmirror) {
+		dst_row_addr = dst + dst_line_stride * (height - 1);
+		dst_line_stride = -dst_line_stride;
+	} else
+		dst_row_addr = dst;
+
+	/* Loop over all rows */
+	for (i = 0; i < height; i++) {
+		/* Loop over each pixel */
+		psrc = src_row_addr;
+		pdst = dst_row_addr + (width - 2) * BYTES_PER_PIXEL;
+		for (j = 0; j < (width >> 1); j++) {
+			pixelsin = *(u32 *) psrc;
+			pixelsout = rot_left_u32(pixelsin, 16);
+			*(u32 *) pdst = pixelsout;
+			psrc += BYTES_PER_2PIXEL;
+			pdst -= BYTES_PER_2PIXEL;
+		}
+		src_row_addr += src_line_stride;
+		dst_row_addr += dst_line_stride;
+	}
+
+	return OPLERR_SUCCESS;
+}
+
+static int opl_hmirror_u16_by4(const u8 *src, int src_line_stride, int width,
+			       int height, u8 *dst, int dst_line_stride,
+			       int vmirror)
+{
+	const u8 *src_row_addr;
+	const u8 *psrc;
+	u8 *dst_row_addr, *pdst;
+	int i, j;
+
+	union doubleword {
+		u64 dw;
+		u32 w[2];
+	};
+
+	union doubleword inbuf;
+	union doubleword outbuf;
+
+	src_row_addr = src;
+	if (vmirror) {
+		dst_row_addr = dst + dst_line_stride * (height - 1);
+		dst_line_stride = -dst_line_stride;
+	} else
+		dst_row_addr = dst;
+
+	/* Loop over all rows */
+	for (i = 0; i < height; i++) {
+		/* Loop over each pixel */
+		psrc = src_row_addr;
+		pdst = dst_row_addr + (width - 4) * BYTES_PER_PIXEL;
+		for (j = 0; j < (width >> 2); j++) {
+			inbuf.dw = *(u64 *) psrc;
+			outbuf.w[0] = rot_left_u32(inbuf.w[1], 16);
+			outbuf.w[1] = rot_left_u32(inbuf.w[0], 16);
+			*(u64 *) pdst = outbuf.dw;
+			psrc += BYTES_PER_4PIXEL;
+			pdst -= BYTES_PER_4PIXEL;
+		}
+		src_row_addr += src_line_stride;
+		dst_row_addr += dst_line_stride;
+	}
+	return OPLERR_SUCCESS;
+}
+
+static int opl_hmirror_u16_by8(const u8 *src, int src_line_stride, int width,
+			       int height, u8 *dst, int dst_line_stride,
+			       int vmirror)
+{
+	const u8 *src_row_addr;
+	const u8 *psrc;
+	u8 *dst_row_addr, *pdst;
+	int i, j;
+
+	src_row_addr = src;
+	if (vmirror) {
+		dst_row_addr = dst + dst_line_stride * (height - 1);
+		dst_line_stride = -dst_line_stride;
+	} else
+		dst_row_addr = dst;
+
+	/* Loop over all rows */
+	for (i = 0; i < height; i++) {
+		/* Loop over each pixel */
+		psrc = src_row_addr;
+		pdst = dst_row_addr + (width - 1) * BYTES_PER_PIXEL - 2;
+		for (j = (width >> 3); j > 0; j--) {
+			__asm__ volatile (
+				"ldmia	%0!,{r2-r5}\n\t"
+				"mov	r6, r2\n\t"
+				"mov	r7, r3\n\t"
+				"mov	r2, r5, ROR #16\n\t"
+				"mov	r3, r4, ROR #16\n\t"
+				"mov	r4, r7, ROR #16\n\t"
+				"mov	r5, r6, ROR #16\n\t"
+				"stmda	%1!,{r2-r5}\n\t"
+
+				:"+r"(psrc), "+r"(pdst)
+				:"0"(psrc), "1"(pdst)
+				:"r2", "r3", "r4", "r5", "r6", "r7",
+				"memory"
+			);
+		}
+		src_row_addr += src_line_stride;
+		dst_row_addr += dst_line_stride;
+	}
+
+	return OPLERR_SUCCESS;
+}
diff --git a/drivers/media/video/mxc/opl/opl.h b/drivers/media/video/mxc/opl/opl.h
new file mode 100644
index 0000000..71b7638
--- /dev/null
+++ b/drivers/media/video/mxc/opl/opl.h
@@ -0,0 +1,162 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup OPLIP OPL Image Processing
+ */
+/*!
+ * @file opl.h
+ *
+ * @brief The OPL (Open Primitives Library) Image Processing library defines
+ * efficient functions for rotation and mirroring.
+ *
+ * It includes ARM9-optimized rotation and mirroring functions. It is derived
+ * from the original OPL project which is found at sourceforge.freescale.net.
+ *
+ * @ingroup OPLIP
+ */
+#ifndef __OPL_H__
+#define __OPL_H__
+
+#include <linux/types.h>
+
+#define BYTES_PER_PIXEL			2
+#define CACHE_LINE_WORDS		8
+#define BYTES_PER_WORD			4
+
+#define BYTES_PER_2PIXEL		(BYTES_PER_PIXEL * 2)
+#define BYTES_PER_4PIXEL		(BYTES_PER_PIXEL * 4)
+#define BYTES_PER_8PIXEL		(BYTES_PER_PIXEL * 8)
+
+#define QCIF_Y_WIDTH			176
+#define QCIF_Y_HEIGHT			144
+
+/*! Enumerations of opl error code */
+enum opl_error {
+	OPLERR_SUCCESS = 0,
+	OPLERR_NULL_PTR,
+	OPLERR_BAD_ARG,
+	OPLERR_DIV_BY_ZERO,
+	OPLERR_OVER_FLOW,
+	OPLERR_UNDER_FLOW,
+	OPLERR_MISALIGNED,
+};
+
+/*!
+ * @brief Rotate a 16bbp buffer 90 degrees clockwise.
+ *
+ * @param src             Pointer to the input buffer
+ * @param src_line_stride Length in bytes of a raster line of the input buffer
+ * @param width           Width in pixels of the region in the input buffer
+ * @param height          Height in pixels of the region in the input buffer
+ * @param dst             Pointer to the output buffer
+ * @param dst_line_stride Length in bytes of a raster line of the output buffer
+ *
+ * @return Standard OPL error code. See enumeration for possible result codes.
+ */
+int opl_rotate90_u16(const u8 *src, int src_line_stride, int width, int height,
+		     u8 *dst, int dst_line_stride);
+
+/*!
+ * @brief Rotate a 16bbp buffer 180 degrees clockwise.
+ *
+ * @param src             Pointer to the input buffer
+ * @param src_line_stride Length in bytes of a raster line of the input buffer
+ * @param width           Width in pixels of the region in the input buffer
+ * @param height          Height in pixels of the region in the input buffer
+ * @param dst             Pointer to the output buffer
+ * @param dst_line_stride Length in bytes of a raster line of the output buffer
+ *
+ * @return Standard OPL error code. See enumeration for possible result codes.
+ */
+int opl_rotate180_u16(const u8 *src, int src_line_stride, int width,
+		      int height, u8 *dst, int dst_line_stride);
+
+/*!
+ * @brief Rotate a 16bbp buffer 270 degrees clockwise
+ *
+ * @param src             Pointer to the input buffer
+ * @param src_line_stride Length in bytes of a raster line of the input buffer
+ * @param width           Width in pixels of the region in the input buffer
+ * @param height          Height in pixels of the region in the input buffer
+ * @param dst             Pointer to the output buffer
+ * @param dst_line_stride Length in bytes of a raster line of the output buffer
+ *
+ * @return Standard OPL error code. See enumeration for possible result codes.
+ */
+int opl_rotate270_u16(const u8 *src, int src_line_stride, int width,
+		      int height, u8 *dst, int dst_line_stride);
+
+/*!
+ * @brief Mirror a 16bpp buffer horizontally
+ *
+ * @param src             Pointer to the input buffer
+ * @param src_line_stride Length in bytes of a raster line of the input buffer
+ * @param width           Width in pixels of the region in the input buffer
+ * @param height          Height in pixels of the region in the input buffer
+ * @param dst             Pointer to the output buffer
+ * @param dst_line_stride Length in bytes of a raster line of the output buffer
+ *
+ * @return Standard OPL error code. See enumeration for possible result codes.
+ */
+int opl_hmirror_u16(const u8 *src, int src_line_stride, int width, int height,
+		    u8 *dst, int dst_line_stride);
+
+/*!
+ * @brief Mirror a 16bpp buffer vertically
+ *
+ * @param src             Pointer to the input buffer
+ * @param src_line_stride Length in bytes of a raster line of the input buffer
+ * @param width           Width in pixels of the region in the input buffer
+ * @param height          Height in pixels of the region in the input buffer
+ * @param dst             Pointer to the output buffer
+ * @param dst_line_stride Length in bytes of a raster line of the output buffer
+ *
+ * @return Standard OPL error code. See enumeration for possible result codes.
+ */
+int opl_vmirror_u16(const u8 *src, int src_line_stride, int width, int height,
+		    u8 *dst, int dst_line_stride);
+
+/*!
+ * @brief Rotate a 16bbp buffer 90 degrees clockwise and mirror vertically
+ *	  It is equivalent to rotate 270 degree and mirror horizontally
+ *
+ * @param src             Pointer to the input buffer
+ * @param src_line_stride Length in bytes of a raster line of the input buffer
+ * @param width           Width in pixels of the region in the input buffer
+ * @param height          Height in pixels of the region in the input buffer
+ * @param dst             Pointer to the output buffer
+ * @param dst_line_stride Length in bytes of a raster line of the output buffer
+ *
+ * @return Standard OPL error code. See enumeration for possible result codes.
+ */
+int opl_rotate90_vmirror_u16(const u8 *src, int src_line_stride, int width,
+			     int height, u8 *dst, int dst_line_stride);
+
+/*!
+ * @brief Rotate a 16bbp buffer 270 degrees clockwise and mirror vertically
+ *	  It is equivalent to rotate 90 degree and mirror horizontally
+ *
+ * @param src             Pointer to the input buffer
+ * @param src_line_stride Length in bytes of a raster line of the input buffer
+ * @param width           Width in pixels of the region in the input buffer
+ * @param height          Height in pixels of the region in the input buffer
+ * @param dst             Pointer to the output buffer
+ * @param dst_line_stride Length in bytes of a raster line of the output buffer
+ *
+ * @return Standard OPL error code. See enumeration for possible result codes.
+ */
+int opl_rotate270_vmirror_u16(const u8 *src, int src_line_stride, int width,
+			      int height, u8 *dst, int dst_line_stride);
+
+#endif				/* __OPL_H__ */
diff --git a/drivers/media/video/mxc/opl/opl_mod.c b/drivers/media/video/mxc/opl/opl_mod.c
new file mode 100644
index 0000000..a581aad
--- /dev/null
+++ b/drivers/media/video/mxc/opl/opl_mod.c
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+
+static __init int opl_init(void)
+{
+	return 0;
+}
+
+static void __exit opl_exit(void)
+{
+}
+
+module_init(opl_init);
+module_exit(opl_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("OPL Software Rotation/Mirroring");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/mxc/opl/rotate270_u16.c b/drivers/media/video/mxc/opl/rotate270_u16.c
new file mode 100644
index 0000000..dab23b1
--- /dev/null
+++ b/drivers/media/video/mxc/opl/rotate270_u16.c
@@ -0,0 +1,284 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include "opl.h"
+
+static int opl_rotate270_u16_by16(const u8 *src, int src_line_stride,
+				  int width, int height, u8 *dst,
+				  int dst_line_stride, int vmirror);
+static int opl_rotate270_u16_by4(const u8 *src, int src_line_stride, int width,
+				 int height, u8 *dst, int dst_line_stride,
+				 int vmirror);
+static int opl_rotate270_vmirror_u16_both(const u8 *src, int src_line_stride,
+					  int width, int height, u8 *dst,
+					  int dst_line_stride, int vmirror);
+int opl_rotate270_u16_qcif(const u8 *src, u8 *dst);
+
+int opl_rotate270_u16(const u8 *src, int src_line_stride, int width,
+		      int height, u8 *dst, int dst_line_stride)
+{
+	return opl_rotate270_vmirror_u16_both(src, src_line_stride, width,
+					      height, dst, dst_line_stride, 0);
+}
+EXPORT_SYMBOL(opl_rotate270_u16);
+
+int opl_rotate270_vmirror_u16(const u8 *src, int src_line_stride, int width,
+			      int height, u8 *dst, int dst_line_stride)
+{
+	return opl_rotate270_vmirror_u16_both(src, src_line_stride, width,
+					      height, dst, dst_line_stride, 1);
+}
+EXPORT_SYMBOL(opl_rotate270_vmirror_u16);
+
+static int opl_rotate270_vmirror_u16_both(const u8 *src, int src_line_stride,
+					  int width, int height, u8 *dst,
+					  int dst_line_stride, int vmirror)
+{
+	const int BLOCK_SIZE_PIXELS = CACHE_LINE_WORDS * BYTES_PER_WORD
+	    / BYTES_PER_PIXEL;
+	const int BLOCK_SIZE_PIXELS_BY4 = CACHE_LINE_WORDS * BYTES_PER_WORD
+	    / BYTES_PER_PIXEL / 4;
+
+	if (!src || !dst)
+		return OPLERR_NULL_PTR;
+
+	if (width == 0 || height == 0 || src_line_stride == 0
+	    || dst_line_stride == 0)
+		return OPLERR_BAD_ARG;
+
+	/* The QCIF algorithm doesn't support vertical mirroring */
+	if (vmirror == 0 && width == QCIF_Y_WIDTH && height == QCIF_Y_HEIGHT
+	    && src_line_stride == QCIF_Y_WIDTH * 2
+	    && src_line_stride == QCIF_Y_HEIGHT * 2)
+		return opl_rotate270_u16_qcif(src, dst);
+	else if (width % BLOCK_SIZE_PIXELS == 0
+		 && height % BLOCK_SIZE_PIXELS == 0)
+		return opl_rotate270_u16_by16(src, src_line_stride, width,
+					      height, dst, dst_line_stride,
+					      vmirror);
+	else if (width % BLOCK_SIZE_PIXELS_BY4 == 0
+		 && height % BLOCK_SIZE_PIXELS_BY4 == 0)
+		return opl_rotate270_u16_by4(src, src_line_stride, width,
+					     height, dst, dst_line_stride,
+					     vmirror);
+	else
+		return OPLERR_BAD_ARG;
+}
+
+/*
+ * Rotate Counter Clockwise, divide RGB component into 16 row strips, read
+ * non sequentially and write sequentially. This is done in 16 line strips
+ * so that the cache is used better. Cachelines are 8 words = 32 bytes. Pixels
+ * are 2 bytes. The 16 reads will be cache misses, but the next 240 should
+ * be from cache. The writes to the output buffer will be sequential for 16
+ * writes.
+ *
+ * Example:
+ * Input data matrix:	    output matrix
+ *
+ * 0 | 1 | 2 | 3 | 4 |      4 | 0 | 0 | 3 |
+ * 4 | 3 | 2 | 1 | 0 |      3 | 1 | 9 | 6 |
+ * 6 | 7 | 8 | 9 | 0 |      2 | 2 | 8 | 2 |
+ * 5 | 3 | 2 | 6 | 3 |      1 | 3 | 7 | 3 |
+ * ^			    0 | 4 | 6 | 5 | < Write the input data sequentially
+ * Read first column
+ * Start at the bottom
+ * Move to next column and repeat
+ *
+ * Loop over k decreasing (blocks)
+ * in_block_ptr = src + (((RGB_HEIGHT_PIXELS / BLOCK_SIZE_PIXELS) - k)
+ *                * BLOCK_SIZE_PIXELS) * (RGB_WIDTH_BYTES)
+ * out_block_ptr = dst + (((RGB_HEIGHT_PIXELS / BLOCK_SIZE_PIXELS) - k)
+ *                * BLOCK_SIZE_BYTES) + (RGB_WIDTH_PIXELS - 1)
+ *                * RGB_HEIGHT_PIXELS * BYTES_PER_PIXEL
+ *
+ * Loop over i decreasing (width)
+ * Each pix:
+ * in_block_ptr += RGB_WIDTH_BYTES
+ * out_block_ptr += 4
+ *
+ * Each row of block:
+ * in_block_ptr -= RGB_WIDTH_BYTES * BLOCK_SIZE_PIXELS - 2
+ * out_block_ptr -= RGB_HEIGHT_PIXELS * BYTES_PER_PIXEL + 2 * BLOCK_SIZE_PIXELS;
+ *
+ * It may perform vertical mirroring too depending on the vmirror flag.
+ */
+static int opl_rotate270_u16_by16(const u8 *src, int src_line_stride,
+				  int width, int height, u8 *dst,
+				  int dst_line_stride, int vmirror)
+{
+	const int BLOCK_SIZE_PIXELS = CACHE_LINE_WORDS * BYTES_PER_WORD
+	    / BYTES_PER_PIXEL;
+	const int IN_INDEX = src_line_stride * BLOCK_SIZE_PIXELS
+	    - BYTES_PER_PIXEL;
+	const int OUT_INDEX = vmirror ?
+	    -dst_line_stride + BYTES_PER_PIXEL * BLOCK_SIZE_PIXELS
+	    : dst_line_stride + BYTES_PER_PIXEL * BLOCK_SIZE_PIXELS;
+	const u8 *in_block_ptr;
+	u8 *out_block_ptr;
+	int i, k;
+
+	for (k = height / BLOCK_SIZE_PIXELS; k > 0; k--) {
+		in_block_ptr = src + (((height / BLOCK_SIZE_PIXELS) - k)
+				      * BLOCK_SIZE_PIXELS) * src_line_stride;
+		out_block_ptr = dst + (((height / BLOCK_SIZE_PIXELS) - k)
+				       * BLOCK_SIZE_PIXELS * BYTES_PER_PIXEL) +
+		    (width - 1) * dst_line_stride;
+
+		/*
+		* For vertical mirroring the writing starts from the
+		* first line
+		*/
+		if (vmirror)
+			out_block_ptr -= dst_line_stride * (width - 1);
+
+		for (i = width; i > 0; i--) {
+			__asm__ volatile (
+				"ldrh	r2, [%0], %4\n\t"
+				"ldrh	r3, [%0], %4\n\t"
+				"ldrh	r4, [%0], %4\n\t"
+				"ldrh	r5, [%0], %4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				"ldrh	r2, [%0], %4\n\t"
+				"ldrh	r3, [%0], %4\n\t"
+				"ldrh	r4, [%0], %4\n\t"
+				"ldrh	r5, [%0], %4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				"ldrh	r2, [%0], %4\n\t"
+				"ldrh	r3, [%0], %4\n\t"
+				"ldrh	r4, [%0], %4\n\t"
+				"ldrh	r5, [%0], %4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				"ldrh	r2, [%0], %4\n\t"
+				"ldrh	r3, [%0], %4\n\t"
+				"ldrh	r4, [%0], %4\n\t"
+				"ldrh	r5, [%0], %4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				:"+r" (in_block_ptr), "+r"(out_block_ptr)	/* output */
+				:"0"(in_block_ptr), "1"(out_block_ptr), "r"(src_line_stride)	/* input  */
+				:"r2", "r3", "r4", "r5", "memory"	/* modify */
+			);
+			in_block_ptr -= IN_INDEX;
+			out_block_ptr -= OUT_INDEX;
+		}
+	}
+
+	return OPLERR_SUCCESS;
+}
+
+/*
+ * Rotate Counter Clockwise, divide RGB component into 4 row strips, read
+ * non sequentially and write sequentially. This is done in 4 line strips
+ * so that the cache is used better. Cachelines are 8 words = 32 bytes. Pixels
+ * are 2 bytes. The 4 reads will be cache misses, but the next 60 should
+ * be from cache. The writes to the output buffer will be sequential for 4
+ * writes.
+ *
+ * Example:
+ * Input data matrix:	    output matrix
+ *
+ * 0 | 1 | 2 | 3 | 4 |      4 | 0 | 0 | 3 |
+ * 4 | 3 | 2 | 1 | 0 |      3 | 1 | 9 | 6 |
+ * 6 | 7 | 8 | 9 | 0 |      2 | 2 | 8 | 2 |
+ * 5 | 3 | 2 | 6 | 3 |      1 | 3 | 7 | 3 |
+ * ^			    0 | 4 | 6 | 5 | < Write the input data sequentially
+ * Read first column
+ * Start at the bottom
+ * Move to next column and repeat
+ *
+ * Loop over k decreasing (blocks)
+ * in_block_ptr = src + (((RGB_HEIGHT_PIXELS / BLOCK_SIZE_PIXELS) - k)
+ *                * BLOCK_SIZE_PIXELS) * (RGB_WIDTH_BYTES)
+ * out_block_ptr = dst + (((RGB_HEIGHT_PIXELS / BLOCK_SIZE_PIXELS) - k)
+ *                * BLOCK_SIZE_BYTES) + (RGB_WIDTH_PIXELS - 1)
+ *                * RGB_HEIGHT_PIXELS * BYTES_PER_PIXEL
+ *
+ * Loop over i decreasing (width)
+ * Each pix:
+ * in_block_ptr += RGB_WIDTH_BYTES
+ * out_block_ptr += 4
+ *
+ * Each row of block:
+ * in_block_ptr -= RGB_WIDTH_BYTES * BLOCK_SIZE_PIXELS - 2
+ * out_block_ptr -= RGB_HEIGHT_PIXELS * BYTES_PER_PIXEL + 2 * BLOCK_SIZE_PIXELS;
+ *
+ * It may perform vertical mirroring too depending on the vmirror flag.
+ */
+static int opl_rotate270_u16_by4(const u8 *src, int src_line_stride, int width,
+				 int height, u8 *dst, int dst_line_stride,
+				 int vmirror)
+{
+	const int BLOCK_SIZE_PIXELS = CACHE_LINE_WORDS * BYTES_PER_WORD
+	    / BYTES_PER_PIXEL / 4;
+	const int IN_INDEX = src_line_stride * BLOCK_SIZE_PIXELS
+	    - BYTES_PER_PIXEL;
+	const int OUT_INDEX = vmirror ?
+	    -dst_line_stride + BYTES_PER_PIXEL * BLOCK_SIZE_PIXELS
+	    : dst_line_stride + BYTES_PER_PIXEL * BLOCK_SIZE_PIXELS;
+	const u8 *in_block_ptr;
+	u8 *out_block_ptr;
+	int i, k;
+
+	for (k = height / BLOCK_SIZE_PIXELS; k > 0; k--) {
+		in_block_ptr = src + (((height / BLOCK_SIZE_PIXELS) - k)
+				      * BLOCK_SIZE_PIXELS) * src_line_stride;
+		out_block_ptr = dst + (((height / BLOCK_SIZE_PIXELS) - k)
+				       * BLOCK_SIZE_PIXELS * BYTES_PER_PIXEL)
+		    + (width - 1) * dst_line_stride;
+
+		/*
+		* For vertical mirroring the writing starts from the
+		* first line
+		*/
+		if (vmirror)
+			out_block_ptr -= dst_line_stride * (width - 1);
+
+		for (i = width; i > 0; i--) {
+			__asm__ volatile (
+				"ldrh	r2, [%0], %4\n\t"
+				"ldrh	r3, [%0], %4\n\t"
+				"ldrh	r4, [%0], %4\n\t"
+				"ldrh	r5, [%0], %4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				:"+r" (in_block_ptr), "+r"(out_block_ptr)	/* output */
+				:"0"(in_block_ptr), "1"(out_block_ptr), "r"(src_line_stride)	/* input  */
+				:"r2", "r3", "r4", "r5", "memory"	/* modify */
+			);
+			in_block_ptr -= IN_INDEX;
+			out_block_ptr -= OUT_INDEX;
+		}
+	}
+
+	return OPLERR_SUCCESS;
+}
diff --git a/drivers/media/video/mxc/opl/rotate270_u16_qcif.S b/drivers/media/video/mxc/opl/rotate270_u16_qcif.S
new file mode 100644
index 0000000..4101eaa
--- /dev/null
+++ b/drivers/media/video/mxc/opl/rotate270_u16_qcif.S
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/linkage.h>
+
+	.text
+	.align	2
+ENTRY(opl_rotate270_u16_qcif)
+	STMFD    sp!,{r4-r10}
+        MOV      r12,#0x160
+        MOV      r10,#0x90
+        MOV      r3,r10,LSR #4
+.L1.16:
+        RSB      r2,r3,r10,LSR #4
+        MOV      r5,r2,LSL #5
+        MOV      r4,r12,LSR #1
+        SMULBB   r4,r5,r4
+        ADD      r2,r1,r2,LSL #5
+        ADD      r5,r2,#0xc000
+        ADD      r5,r5,#0x4e0
+        MOV      r2,r12,LSR #1
+        ADD      r4,r0,r4
+.L1.52:
+        LDRH     r6,[r4],r12
+        LDRH     r7,[r4],r12
+        LDRH     r8,[r4],r12
+        LDRH     r9,[r4],r12
+        ORR      r6,r6,r7,LSL #16
+        ORR      r7,r8,r9,LSL #16
+        STMIA    r5!,{r6,r7}
+        SUBS     r2,r2,#1
+        LDRH     r6,[r4],r12
+        LDRH     r7,[r4],r12
+        LDRH     r8,[r4],r12
+        LDRH     r9,[r4],r12
+        ORR      r6,r6,r7,LSL #16
+        ORR      r7,r8,r9,LSL #16
+        STMIA    r5!,{r6,r7}
+        LDRH     r6,[r4],r12
+        LDRH     r7,[r4],r12
+        LDRH     r8,[r4],r12
+        LDRH     r9,[r4],r12
+        ORR      r6,r6,r7,LSL #16
+        ORR      r7,r8,r9,LSL #16
+        STMIA    r5!,{r6,r7}
+        LDRH     r6,[r4],r12
+        LDRH     r7,[r4],r12
+        LDRH     r8,[r4],r12
+        LDRH     r9,[r4],r12
+        ORR      r6,r6,r7,LSL #16
+        ORR      r7,r8,r9,LSL #16
+        SUB      r4,r4,#0x1500
+        STMIA    r5,{r6,r7}
+        SUB      r5,r5,#0x138
+        SUB      r4,r4,#0xfe
+        BGT      .L1.52
+        SUBS     r3,r3,#1
+        BGT      .L1.16
+        LDMFD    sp!,{r4-r10}
+        BX       lr
+	.size	opl_rotate270_u16_qcif, . - opl_rotate270_u16_qcif
diff --git a/drivers/media/video/mxc/opl/rotate90_u16.c b/drivers/media/video/mxc/opl/rotate90_u16.c
new file mode 100644
index 0000000..e66ff9a
--- /dev/null
+++ b/drivers/media/video/mxc/opl/rotate90_u16.c
@@ -0,0 +1,219 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include "opl.h"
+
+static int opl_rotate90_u16_by16(const u8 *src, int src_line_stride, int width,
+				 int height, u8 *dst, int dst_line_stride,
+				 int vmirror);
+static int opl_rotate90_u16_by4(const u8 *src, int src_line_stride, int width,
+				int height, u8 *dst, int dst_line_stride,
+				int vmirror);
+static int opl_rotate90_vmirror_u16_both(const u8 *src, int src_line_stride,
+					 int width, int height, u8 *dst,
+					 int dst_line_stride, int vmirror);
+int opl_rotate90_u16_qcif(const u8 *src, u8 *dst);
+
+int opl_rotate90_u16(const u8 *src, int src_line_stride, int width, int height,
+		     u8 *dst, int dst_line_stride)
+{
+	return opl_rotate90_vmirror_u16_both(src, src_line_stride, width,
+					    height, dst, dst_line_stride, 0);
+}
+EXPORT_SYMBOL(opl_rotate90_u16);
+
+int opl_rotate90_vmirror_u16(const u8 *src, int src_line_stride, int width,
+			    int height, u8 *dst, int dst_line_stride)
+{
+	return opl_rotate90_vmirror_u16_both(src, src_line_stride, width,
+					    height, dst, dst_line_stride, 1);
+}
+EXPORT_SYMBOL(opl_rotate90_vmirror_u16);
+
+static int opl_rotate90_vmirror_u16_both(const u8 *src, int src_line_stride,
+					 int width, int height, u8 *dst,
+					 int dst_line_stride, int vmirror)
+{
+	const int BLOCK_SIZE_PIXELS = CACHE_LINE_WORDS * BYTES_PER_WORD
+	    / BYTES_PER_PIXEL;
+	const int BLOCK_SIZE_PIXELS_BY4 = CACHE_LINE_WORDS * BYTES_PER_WORD
+	    / BYTES_PER_PIXEL / 4;
+
+	if (!src || !dst)
+		return OPLERR_NULL_PTR;
+
+	if (width == 0 || height == 0 || src_line_stride == 0
+	    || dst_line_stride == 0)
+		return OPLERR_BAD_ARG;
+
+	/* The QCIF algorithm doesn't support vertical mirroring */
+	if (vmirror == 0 && width == QCIF_Y_WIDTH && height == QCIF_Y_HEIGHT
+	    && src_line_stride == QCIF_Y_WIDTH * 2
+	    && src_line_stride == QCIF_Y_HEIGHT * 2)
+		return opl_rotate90_u16_qcif(src, dst);
+	else if (width % BLOCK_SIZE_PIXELS == 0
+		 && height % BLOCK_SIZE_PIXELS == 0)
+		return opl_rotate90_u16_by16(src, src_line_stride, width,
+					     height, dst, dst_line_stride,
+					     vmirror);
+	else if (width % BLOCK_SIZE_PIXELS_BY4 == 0
+		 && height % BLOCK_SIZE_PIXELS_BY4 == 0)
+		return opl_rotate90_u16_by4(src, src_line_stride, width, height,
+					    dst, dst_line_stride, vmirror);
+	else
+		return OPLERR_BAD_ARG;
+}
+
+/*
+ * Performs clockwise rotation (and possibly vertical mirroring depending
+ * on the vmirror flag) using block sizes of 16x16
+ * The algorithm is similar to 270 degree clockwise rotation algorithm
+ */
+static int opl_rotate90_u16_by16(const u8 *src, int src_line_stride, int width,
+				 int height, u8 *dst, int dst_line_stride,
+				 int vmirror)
+{
+	const int BLOCK_SIZE_PIXELS = CACHE_LINE_WORDS * BYTES_PER_WORD
+	    / BYTES_PER_PIXEL;
+	const int BLOCK_SIZE_BYTES = BYTES_PER_PIXEL * BLOCK_SIZE_PIXELS;
+	const int IN_INDEX = src_line_stride * BLOCK_SIZE_PIXELS
+	    + BYTES_PER_PIXEL;
+	const int OUT_INDEX = vmirror ?
+	    -dst_line_stride - BLOCK_SIZE_BYTES
+	    : dst_line_stride - BLOCK_SIZE_BYTES;
+	const u8 *in_block_ptr;
+	u8 *out_block_ptr;
+	int i, k;
+
+	for (k = height / BLOCK_SIZE_PIXELS; k > 0; k--) {
+		in_block_ptr = src + src_line_stride * (height - 1)
+		    - (src_line_stride * BLOCK_SIZE_PIXELS *
+		       (height / BLOCK_SIZE_PIXELS - k));
+		out_block_ptr = dst + BYTES_PER_PIXEL * BLOCK_SIZE_PIXELS *
+		    ((height / BLOCK_SIZE_PIXELS) - k);
+
+		/*
+		 * For vertical mirroring the writing starts from the
+		 * bottom line
+		 */
+		if (vmirror)
+			out_block_ptr += dst_line_stride * (width - 1);
+
+		for (i = width; i > 0; i--) {
+			__asm__ volatile (
+				"ldrh	r2, [%0], -%4\n\t"
+				"ldrh	r3, [%0], -%4\n\t"
+				"ldrh	r4, [%0], -%4\n\t"
+				"ldrh	r5, [%0], -%4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				"ldrh	r2, [%0], -%4\n\t"
+				"ldrh	r3, [%0], -%4\n\t"
+				"ldrh	r4, [%0], -%4\n\t"
+				"ldrh	r5, [%0], -%4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				"ldrh	r2, [%0], -%4\n\t"
+				"ldrh	r3, [%0], -%4\n\t"
+				"ldrh	r4, [%0], -%4\n\t"
+				"ldrh	r5, [%0], -%4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				"ldrh	r2, [%0], -%4\n\t"
+				"ldrh	r3, [%0], -%4\n\t"
+				"ldrh	r4, [%0], -%4\n\t"
+				"ldrh	r5, [%0], -%4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				:"+r" (in_block_ptr), "+r"(out_block_ptr)	/* output */
+				:"0"(in_block_ptr), "1"(out_block_ptr), "r"(src_line_stride)	/* input  */
+				:"r2", "r3", "r4", "r5", "memory"	/* modify */
+			);
+			in_block_ptr += IN_INDEX;
+			out_block_ptr += OUT_INDEX;
+		}
+	}
+
+	return OPLERR_SUCCESS;
+}
+
+/*
+ * Performs clockwise rotation (and possibly vertical mirroring depending
+ * on the vmirror flag) using block sizes of 4x4
+ * The algorithm is similar to 270 degree clockwise rotation algorithm
+ */
+static int opl_rotate90_u16_by4(const u8 *src, int src_line_stride, int width,
+				int height, u8 *dst, int dst_line_stride,
+				int vmirror)
+{
+	const int BLOCK_SIZE_PIXELS = CACHE_LINE_WORDS * BYTES_PER_WORD
+	    / BYTES_PER_PIXEL / 4;
+	const int BLOCK_SIZE_BYTES = BYTES_PER_PIXEL * BLOCK_SIZE_PIXELS;
+	const int IN_INDEX = src_line_stride * BLOCK_SIZE_PIXELS
+	    + BYTES_PER_PIXEL;
+	const int OUT_INDEX = vmirror ?
+	    -dst_line_stride - BLOCK_SIZE_BYTES
+	    : dst_line_stride - BLOCK_SIZE_BYTES;
+	const u8 *in_block_ptr;
+	u8 *out_block_ptr;
+	int i, k;
+
+	for (k = height / BLOCK_SIZE_PIXELS; k > 0; k--) {
+		in_block_ptr = src + src_line_stride * (height - 1)
+		    - (src_line_stride * BLOCK_SIZE_PIXELS *
+		       (height / BLOCK_SIZE_PIXELS - k));
+		out_block_ptr = dst + BYTES_PER_PIXEL * BLOCK_SIZE_PIXELS
+		    * ((height / BLOCK_SIZE_PIXELS) - k);
+
+		/*
+		 * For horizontal mirroring the writing starts from the
+		 * bottom line
+		 */
+		if (vmirror)
+			out_block_ptr += dst_line_stride * (width - 1);
+
+		for (i = width; i > 0; i--) {
+			__asm__ volatile (
+				"ldrh	r2, [%0], -%4\n\t"
+				"ldrh	r3, [%0], -%4\n\t"
+				"ldrh	r4, [%0], -%4\n\t"
+				"ldrh	r5, [%0], -%4\n\t"
+				"orr	r2, r2, r3, lsl #16\n\t"
+				"orr	r4, r4, r5, lsl #16\n\t"
+				"str	r2, [%1], #4\n\t"
+				"str	r4, [%1], #4\n\t"
+
+				:"+r" (in_block_ptr), "+r"(out_block_ptr)	/* output */
+				:"0"(in_block_ptr), "1"(out_block_ptr), "r"(src_line_stride)	/* input  */
+				:"r2", "r3", "r4", "r5", "memory"	/* modify */
+			);
+			in_block_ptr += IN_INDEX;
+			out_block_ptr += OUT_INDEX;
+		}
+	}
+
+	return OPLERR_SUCCESS;
+}
diff --git a/drivers/media/video/mxc/opl/rotate90_u16_qcif.S b/drivers/media/video/mxc/opl/rotate90_u16_qcif.S
new file mode 100644
index 0000000..8568a9e
--- /dev/null
+++ b/drivers/media/video/mxc/opl/rotate90_u16_qcif.S
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/linkage.h>
+
+	.text
+	.align	2
+ENTRY(opl_rotate90_u16_qcif)
+        STMFD    sp!,{r4-r10}
+        MOV      r12,#0x160
+        MOV      r10,#0x90
+        MOV      r3,r10,LSR #4
+.L1.216:
+        RSB      r2,r3,r10,LSR #4
+        MOV      r4,#0x20
+        SMULBB   r5,r4,r2
+        MOV      r4,#0x1600
+        SMULBB   r2,r4,r2
+        ADD      r4,r0,#0xc000
+        ADD      r4,r4,#0x4a0
+        SUB      r4,r4,r2
+        MOV      r2,r12,LSR #1
+        ADD      r5,r1,r5
+.L1.256:
+        LDRH     r6,[r4],-r12
+        LDRH     r7,[r4],-r12
+        LDRH     r8,[r4],-r12
+        LDRH     r9,[r4],-r12
+        ORR      r6,r6,r7,LSL #16
+        ORR      r7,r8,r9,LSL #16
+        STMIA    r5!,{r6,r7}
+        SUBS     r2,r2,#1
+        LDRH     r6,[r4],-r12
+        LDRH     r7,[r4],-r12
+        LDRH     r8,[r4],-r12
+        LDRH     r9,[r4],-r12
+        ORR      r6,r6,r7,LSL #16
+        ORR      r7,r8,r9,LSL #16
+        STMIA    r5!,{r6,r7}
+        LDRH     r6,[r4],-r12
+        LDRH     r7,[r4],-r12
+        LDRH     r8,[r4],-r12
+        LDRH     r9,[r4],-r12
+        ORR      r6,r6,r7,LSL #16
+        ORR      r7,r8,r9,LSL #16
+        STMIA    r5!,{r6,r7}
+        LDRH     r6,[r4],-r12
+        LDRH     r7,[r4],-r12
+        LDRH     r8,[r4],-r12
+        LDRH     r9,[r4],-r12
+        ORR      r6,r6,r7,LSL #16
+        ORR      r7,r8,r9,LSL #16
+        ADD      r4,r4,#0x1600
+        STMIA    r5!,{r6,r7}
+        ADD      r5,r5,#0x100
+        ADD      r4,r4,#2
+        BGT      .L1.256
+        SUBS     r3,r3,#1
+        BGT      .L1.216
+        LDMFD    sp!,{r4-r10}
+        BX       lr
+	.size	opl_rotate90_u16_qcif, . - opl_rotate90_u16_qcif
diff --git a/drivers/media/video/mxc/opl/vmirror_u16.c b/drivers/media/video/mxc/opl/vmirror_u16.c
new file mode 100644
index 0000000..c4237dd
--- /dev/null
+++ b/drivers/media/video/mxc/opl/vmirror_u16.c
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/string.h>
+#include "opl.h"
+
+int opl_vmirror_u16(const u8 *src, int src_line_stride, int width, int height,
+		    u8 *dst, int dst_line_stride)
+{
+	const u8 *src_row_addr;
+	u8 *dst_row_addr;
+	int i;
+
+	if (!src || !dst)
+		return OPLERR_NULL_PTR;
+
+	if (width == 0 || height == 0 || src_line_stride == 0
+	    || dst_line_stride == 0)
+		return OPLERR_BAD_ARG;
+
+	src_row_addr = src;
+	dst_row_addr = dst + (height - 1) * dst_line_stride;
+
+	/* Loop over all rows */
+	for (i = 0; i < height; i++) {
+		/* memcpy each row */
+		memcpy(dst_row_addr, src_row_addr, BYTES_PER_PIXEL * width);
+		src_row_addr += src_line_stride;
+		dst_row_addr -= dst_line_stride;
+	}
+
+	return OPLERR_SUCCESS;
+}
+EXPORT_SYMBOL(opl_vmirror_u16);
diff --git a/drivers/media/video/mxc/output/Kconfig b/drivers/media/video/mxc/output/Kconfig
index f623267..ee8a40e 100644
--- a/drivers/media/video/mxc/output/Kconfig
+++ b/drivers/media/video/mxc/output/Kconfig
@@ -4,3 +4,10 @@ config VIDEO_MXC_IPU_OUTPUT
 	default y
 	---help---
 	  This is the video4linux2 driver for IPU post processing video output.
+
+config VIDEO_MXC_EMMA_OUTPUT
+	bool
+	depends on VIDEO_MXC_OUTPUT && MACH_MX27
+	default y
+	---help---
+	  This is the video4linux2 driver for EMMA post processing video output.
diff --git a/drivers/media/video/mxc/output/Makefile b/drivers/media/video/mxc/output/Makefile
index c0d165a..0e502ae 100644
--- a/drivers/media/video/mxc/output/Makefile
+++ b/drivers/media/video/mxc/output/Makefile
@@ -1,3 +1,8 @@
 ifeq ($(CONFIG_VIDEO_MXC_IPU_OUTPUT),y)
 	obj-$(CONFIG_VIDEO_MXC_OUTPUT)	+= mxc_v4l2_output.o
 endif
+
+ifeq ($(CONFIG_VIDEO_MXC_EMMA_OUTPUT),y)
+	mx27_output-objs := mx27_v4l2_output.o mx27_pp.o
+	obj-$(CONFIG_VIDEO_MXC_OUTPUT) += mx27_output.o
+endif
diff --git a/drivers/media/video/mxc/output/mx27_pp.c b/drivers/media/video/mxc/output/mx27_pp.c
new file mode 100644
index 0000000..d830d41
--- /dev/null
+++ b/drivers/media/video/mxc/output/mx27_pp.c
@@ -0,0 +1,904 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx27_pp.c
+ *
+ * @brief MX27 V4L2 Video Output Driver
+ *
+ * Video4Linux2 Output Device using MX27 eMMA Post-processing functionality.
+ *
+ * @ingroup MXC_V4L2_OUTPUT
+ */
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/module.h>
+#include <linux/fb.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+
+#include "mx27_pp.h"
+#include "mxc_v4l2_output.h"
+
+#define SCALE_RETRY	32	/* to be more relax, less precise */
+#define PP_SKIP		1
+#define PP_TBL_MAX	40
+
+static unsigned short scale_tbl[PP_TBL_MAX];
+static int g_hlen, g_vlen;
+
+static emma_pp_cfg g_pp_cfg;
+static int g_disp_num;
+static char pp_dev[] = "emma_pp";
+
+/*!
+ * @brief PP resizing routines
+ */
+static int gcd(int x, int y);
+static int ratio(int x, int y, int *den);
+static int scale_0d(int k, int coeff, int base, int nxt);
+static int scale_1d(int inv, int outv, int k);
+static int scale_1d_smart(int *inv, int *outv, int index);
+static int scale_2d(emma_pp_scale *sz);
+
+static irqreturn_t pp_isr(int irq, void *dev_id);
+static int set_output_addr(emma_pp_cfg *cfg, vout_data *vout);
+static int pphw_reset(void);
+static int pphw_enable(int flag);
+static int pphw_ptr(emma_pp_cfg *cfg);
+static int pphw_outptr(emma_pp_cfg *cfg);
+static int pphw_cfg(emma_pp_cfg *cfg);
+static int pphw_isr(void);
+static void pphw_init(void);
+static void pphw_exit(void);
+
+#define PP_DUMP(reg)	pr_debug("%s\t = 0x%08X\n", #reg, __raw_readl(reg))
+void pp_dump(void)
+{
+	PP_DUMP(PP_CNTL);
+	PP_DUMP(PP_INTRCNTL);
+	PP_DUMP(PP_INTRSTATUS);
+	PP_DUMP(PP_SOURCE_Y_PTR);
+	PP_DUMP(PP_SOURCE_CB_PTR);
+	PP_DUMP(PP_SOURCE_CR_PTR);
+	PP_DUMP(PP_DEST_RGB_PTR);
+	PP_DUMP(PP_QUANTIZER_PTR);
+	PP_DUMP(PP_PROCESS_FRAME_PARA);
+	PP_DUMP(PP_SOURCE_FRAME_WIDTH);
+	PP_DUMP(PP_DEST_DISPLAY_WIDTH);
+	PP_DUMP(PP_DEST_IMAGE_SIZE);
+	PP_DUMP(PP_DEST_FRAME_FMT_CNTL);
+	PP_DUMP(PP_RESIZE_INDEX);
+	PP_DUMP(PP_CSC_COEF_0123);
+	PP_DUMP(PP_CSC_COEF_4);
+}
+
+/*!
+ * @brief Set PP input address.
+ * @param ptr	The pointer to the Y value of input
+ * @return	Zero on success, others on failure
+ */
+int pp_ptr(unsigned long ptr)
+{
+	g_pp_cfg.ptr.y = ptr;
+	g_pp_cfg.ptr.u = g_pp_cfg.ptr.v = g_pp_cfg.ptr.qp = 0;
+
+	return pphw_ptr(&g_pp_cfg);
+}
+
+/*!
+ * @brief Enable or disable PP.
+ * @param flag	Zero to disable PP, others to enable PP
+ * @return	Zero on success, others on failure
+ */
+int pp_enable(int flag)
+{
+	return pphw_enable(flag);
+}
+
+/*!
+ * @brief Get the display No. of last completed PP frame.
+ * @return	The display No. of last completed PP frame.
+ */
+int pp_num_last(void)
+{
+	return g_disp_num ? 0 : 1;
+}
+
+/*!
+ * @brief Initialize PP.
+ * @param vout	Pointer to _vout_data structure
+ * @return	Zero on success, others on failure
+ */
+int pp_init(vout_data *vout)
+{
+	pphw_init();
+	pphw_enable(0);
+	enable_irq(MXC_INT_EMMAPP);
+	return request_irq(MXC_INT_EMMAPP, pp_isr, 0, pp_dev, vout);
+}
+
+/*!
+ * @brief Deinitialize PP.
+ * @param vout	Pointer to _vout_data structure
+ */
+void pp_exit(vout_data *vout)
+{
+	disable_irq(MXC_INT_EMMAPP);
+	free_irq(MXC_INT_EMMAPP, vout);
+	pphw_enable(0);
+	pphw_exit();
+}
+
+/*!
+ * @brief Configure PP.
+ * @param vout	Pointer to _vout_data structure
+ * @return	Zero on success, others on failure
+ */
+int pp_cfg(vout_data *vout)
+{
+	if (!vout)
+		return -1;
+
+	/* PP accepts YUV420 input only */
+	if (vout->v2f.fmt.pix.pixelformat != V4L2_PIX_FMT_YUV420) {
+		pr_debug("unsupported pixel format.\n");
+		return -1;
+	}
+
+	g_pp_cfg.operation = 0;
+
+	memset(g_pp_cfg.csc_table, 0, sizeof(g_pp_cfg.csc_table));
+
+	/* Convert output pixel format to PP required format */
+	switch (vout->v4l2_fb.fmt.pixelformat) {
+	case V4L2_PIX_FMT_BGR32:
+		g_pp_cfg.red_width = 8;
+		g_pp_cfg.green_width = 8;
+		g_pp_cfg.blue_width = 8;
+		g_pp_cfg.red_offset = 8;
+		g_pp_cfg.green_offset = 16;
+		g_pp_cfg.blue_offset = 24;
+		g_pp_cfg.rgb_resolution = 32;
+		break;
+	case V4L2_PIX_FMT_RGB32:
+		g_pp_cfg.red_width = 8;
+		g_pp_cfg.green_width = 8;
+		g_pp_cfg.blue_width = 8;
+		g_pp_cfg.red_offset = 24;
+		g_pp_cfg.green_offset = 16;
+		g_pp_cfg.blue_offset = 8;
+		g_pp_cfg.rgb_resolution = 32;
+		break;
+	case V4L2_PIX_FMT_YUYV:
+		g_pp_cfg.red_width = 0;
+		g_pp_cfg.green_width = 0;
+		g_pp_cfg.blue_width = 0;
+		g_pp_cfg.red_offset = 0;
+		g_pp_cfg.green_offset = 0;
+		g_pp_cfg.blue_offset = PP_PIX_YUYV;
+		g_pp_cfg.rgb_resolution = 16;
+		break;
+	case V4L2_PIX_FMT_UYVY:
+		g_pp_cfg.red_width = 0;
+		g_pp_cfg.green_width = 0;
+		g_pp_cfg.blue_width = 0;
+		g_pp_cfg.red_offset = 0;
+		g_pp_cfg.green_offset = 0;
+		g_pp_cfg.blue_offset = PP_PIX_UYVY;
+		g_pp_cfg.rgb_resolution = 16;
+		break;
+	case V4L2_PIX_FMT_RGB565:
+	default:
+		g_pp_cfg.red_width = 5;
+		g_pp_cfg.green_width = 6;
+		g_pp_cfg.blue_width = 5;
+		g_pp_cfg.red_offset = 11;
+		g_pp_cfg.green_offset = 5;
+		g_pp_cfg.blue_offset = 0;
+		g_pp_cfg.rgb_resolution = 16;
+		break;
+	}
+
+	if (vout->ipu_buf[0] != -1)
+		g_pp_cfg.ptr.y =
+		    (unsigned int)vout->queue_buf_paddr[vout->ipu_buf[0]];
+	else
+		g_pp_cfg.ptr.y = 0;
+
+	g_pp_cfg.ptr.u = g_pp_cfg.ptr.v = g_pp_cfg.ptr.qp = 0;
+
+	g_pp_cfg.dim.in.width = vout->v2f.fmt.pix.width;
+	g_pp_cfg.dim.in.height = vout->v2f.fmt.pix.height;
+	g_pp_cfg.dim.out.width = vout->crop_current.width;
+	g_pp_cfg.dim.out.height = vout->crop_current.height;
+	g_pp_cfg.dim.num.width = 0;
+	g_pp_cfg.dim.num.height = 0;
+	g_pp_cfg.dim.den.width = 0;
+	g_pp_cfg.dim.den.height = 0;
+
+	if (scale_2d(&g_pp_cfg.dim)) {
+		pr_debug("unsupported resize ratio.\n");
+		return -1;
+	}
+
+	g_pp_cfg.dim.out.width = vout->crop_current.width;
+	g_pp_cfg.dim.out.height = vout->crop_current.height;
+
+	g_pp_cfg.in_y_stride = 0;
+	if (set_output_addr(&g_pp_cfg, vout)) {
+		pr_debug("failed to set pp output address.\n");
+		return -1;
+	}
+
+	return pphw_cfg(&g_pp_cfg);
+}
+
+irqreturn_t mxc_v4l2out_pp_in_irq_handler(int irq, void *dev_id);
+
+/*!
+ * @brief PP IRQ handler.
+ */
+static irqreturn_t pp_isr(int irq, void *dev_id)
+{
+	int status;
+	vout_data *vout = dev_id;
+
+	status = pphw_isr();
+	if ((status & 0x1) == 0) {	/* Not frame complete interrupt */
+		pr_debug("not pp frame complete interrupt\n");
+		return IRQ_HANDLED;
+	}
+
+	if (vout->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
+		g_disp_num = g_disp_num ? 0 : 1;
+		g_pp_cfg.outptr = (unsigned int)vout->display_bufs[g_disp_num];
+		pphw_outptr(&g_pp_cfg);
+	}
+
+	return mxc_v4l2out_pp_in_irq_handler(irq, dev_id);
+}
+
+/*!
+ * @brief Set PP output address.
+ * @param cfg	Pointer to emma_pp_cfg structure
+ * @param vout	Pointer to _vout_data structure
+ * @return	Zero on success, others on failure
+ */
+static int set_output_addr(emma_pp_cfg *cfg, vout_data *vout)
+{
+	if (vout->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
+		g_disp_num = 0;
+		cfg->outptr = (unsigned int)vout->display_bufs[g_disp_num];
+		cfg->out_stride = vout->crop_current.width;
+		return 0;
+	} else {
+		struct fb_info *fb;
+
+		fb = registered_fb[vout->output_fb_num[vout->cur_disp_output]];
+		if (!fb)
+			return -1;
+
+		cfg->outptr = fb->fix.smem_start;
+		cfg->outptr += vout->crop_current.top * fb->var.xres_virtual
+		    * (fb->var.bits_per_pixel >> 3)
+		    + vout->crop_current.left * (fb->var.bits_per_pixel >> 3);
+		cfg->out_stride = fb->var.xres_virtual;
+
+		return 0;
+	}
+}
+
+/*!
+ * @brief Get maximum common divisor.
+ * @param x	First input value
+ * @param y	Second input value
+ * @return	Maximum common divisor of x and y
+ */
+static int gcd(int x, int y)
+{
+	int k;
+
+	if (x < y) {
+		k = x;
+		x = y;
+		y = k;
+	}
+
+	while ((k = x % y)) {
+		x = y;
+		y = k;
+	}
+
+	return y;
+}
+
+/*!
+ * @brief Get ratio.
+ * @param x	First input value
+ * @param y	Second input value
+ * @param den	Denominator of the ratio (corresponding to y)
+ * @return	Numerator of the ratio (corresponding to x)
+ */
+static int ratio(int x, int y, int *den)
+{
+	int g;
+
+	if (!x || !y)
+		return 0;
+
+	g = gcd(x, y);
+	*den = y / g;
+
+	return x / g;
+}
+
+/*!
+ * @brief Build PP coefficient entry
+ * Build one or more coefficient entries for PP coefficient table based
+ * on given coefficient.
+ *
+ * @param k	The index of the coefficient in coefficient table
+ * @param coeff	The weighting coefficient
+ * @param base	The base of the coefficient
+ * @param nxt	Number of pixels to be read
+ *
+ * @return	The index of the next coefficient entry on success
+ *		-1 on failure
+ */
+static int scale_0d(int k, int coeff, int base, int nxt)
+{
+	if (k >= PP_TBL_MAX) {
+		/* no more space in table */
+		pr_debug("no space in scale table, k = %d\n", k);
+		return -1;
+	}
+
+	coeff = ((coeff << BC_COEF) + (base >> 1)) / base;
+
+	/*
+	 * Valid values for weighting coefficient are 0, 2 to 30, and 31.
+	 * A value of 31 is treated as 32 and therefore 31 is an
+	 * invalid co-efficient.
+	 */
+	if (coeff >= SZ_COEF - 1)
+		coeff--;
+	else if (coeff == 1)
+		coeff++;
+	coeff = coeff << BC_NXT;
+
+	if (nxt < SZ_NXT) {
+		coeff |= nxt;
+		coeff <<= 1;
+		coeff |= 1;
+	} else {
+		/*
+		 * src inc field is 2 bit wide, for 4+, use special
+		 * code 0:0:1 to prevent dest inc
+		 */
+		coeff |= PP_SKIP;
+		coeff <<= 1;
+		coeff |= 1;
+		nxt -= PP_SKIP;
+		do {
+			pr_debug("tbl = %03X\n", coeff);
+			scale_tbl[k++] = coeff;
+			coeff = (nxt > PP_SKIP) ? PP_SKIP : nxt;
+			coeff <<= 1;
+		} while ((nxt -= PP_SKIP) > 0);
+	}
+	pr_debug("tbl = %03X\n", coeff);
+	scale_tbl[k++] = coeff;
+
+	return k;
+}
+
+/*
+ * @brief Build PP coefficient table
+ * Build PP coefficient table for one dimension (width or height)
+ * based on given input and output resolution
+ *
+ * @param inv	input resolution
+ * @param outv	output resolution
+ * @param k	index of free table entry
+ *
+ * @return	The index of the next free coefficient entry on success
+ *		-1 on failure
+ */
+static int scale_1d(int inv, int outv, int k)
+{
+	int v;			/* overflow counter */
+	int coeff, nxt;		/* table output */
+
+	if (inv == outv)
+		return scale_0d(k, 1, 1, 1);	/* force scaling */
+
+	if (inv * 4 < outv) {
+		pr_debug("upscale err: ratio should be in range 1:1 to 1:4\n");
+		return -1;
+	}
+
+	v = 0;
+	if (inv < outv) {
+		/* upscale: mix <= 2 input pixels per output pixel */
+		do {
+			coeff = outv - v;
+			v += inv;
+			if (v >= outv) {
+				v -= outv;
+				nxt = 1;
+			} else
+				nxt = 0;
+			pr_debug("upscale: coeff = %d/%d nxt = %d\n", coeff,
+				 outv, nxt);
+			k = scale_0d(k, coeff, outv, nxt);
+			if (k < 0)
+				return -1;
+		} while (v);
+	} else if (inv >= 2 * outv) {
+		/* PP doesn't support resize ratio > 2:1 except 4:1. */
+		if ((inv != 2 * outv) && (inv != 4 * outv))
+			return -1;
+		/* downscale: >=2:1 bilinear approximation */
+		coeff = inv - 2 * outv;
+		v = 0;
+		nxt = 0;
+		do {
+			v += coeff;
+			nxt = 2;
+			while (v >= outv) {
+				v -= outv;
+				nxt++;
+			}
+			pr_debug("downscale: coeff = 1/2 nxt = %d\n", nxt);
+			k = scale_0d(k, 1, 2, nxt);
+			if (k < 0)
+				return -1;
+		} while (v);
+	} else {
+		/* downscale: bilinear */
+		int in_pos_inc = 2 * outv;
+		int out_pos = inv;
+		int out_pos_inc = 2 * inv;
+		int init_carry = inv - outv;
+		int carry = init_carry;
+
+		v = outv + in_pos_inc;
+		do {
+			coeff = v - out_pos;
+			out_pos += out_pos_inc;
+			carry += out_pos_inc;
+			for (nxt = 0; v < out_pos; nxt++) {
+				v += in_pos_inc;
+				carry -= in_pos_inc;
+			}
+			pr_debug("downscale: coeff = %d/%d nxt = %d\n", coeff,
+				 in_pos_inc, nxt);
+			k = scale_0d(k, coeff, in_pos_inc, nxt);
+			if (k < 0)
+				return -1;
+		} while (carry != init_carry);
+	}
+	return k;
+}
+
+/*
+ * @brief Build PP coefficient table
+ * Build PP coefficient table for one dimension (width or height)
+ * based on given input and output resolution. The given input
+ * and output resolution might be not supported due to hardware
+ * limits. In this case this functin rounds the input and output
+ * to closest possible values and return them to caller.
+ *
+ * @param inv	input resolution, might be modified after the call
+ * @param outv	output resolution, might be modified after the call
+ * @param k	index of free table entry
+ *
+ * @return	The index of the next free coefficient entry on success
+ *		-1 on failure
+ */
+static int scale_1d_smart(int *inv, int *outv, int index)
+{
+	int len, num, den, retry;
+	static int num1, den1;
+
+	if (!inv || !outv)
+		return -1;
+
+	/* Both should be non-zero */
+	if (!(*inv) || !(*outv))
+		return -1;
+
+	retry = SCALE_RETRY;
+
+	do {
+		num = ratio(*inv, *outv, &den);
+		pr_debug("num = %d, den = %d\n", num, den);
+		if (!num)
+			continue;
+
+		if (index != 0) {
+			/*
+			 * We are now resizing height. Check to see if the
+			 * resize ratio for width can be reused by height
+			 */
+			if ((num == num1) && (den == den1))
+				return index;
+		}
+		len = scale_1d(num, den, index);
+		if (len < 0)
+			/* increase output dimension to try another ratio */
+			(*outv)++;
+		else {
+			if (index == 0) {
+				/*
+				 * We are now resizing width. The same resize
+				 * ratio may be reused by height, so save the
+				 * ratio.
+				 */
+				num1 = num;
+				den1 = den;
+			}
+			return len;
+		}
+	} while (retry--);
+
+	pr_debug("pp scale err\n");
+	return -1;
+}
+
+/*
+ * @brief Build PP coefficient table for both width and height
+ * Build PP coefficient table for both width and height based on
+ * given resizing ratios.
+ *
+ * @param sz	Structure contains resizing ratio informations
+ *
+ * @return	0 on success, others on failure
+ */
+static int scale_2d(emma_pp_scale *sz)
+{
+	int inv, outv;
+
+	/* horizontal resizing. parameter check - must provide in size */
+	if (!sz->in.width)
+		return -1;
+
+	/* Resizing based on num:den */
+	inv = sz->num.width;
+	outv = sz->den.width;
+	g_hlen = scale_1d_smart(&inv, &outv, 0);
+	if (g_hlen > 0) {
+		/* Resizing succeeded */
+		sz->den.width = outv;
+		sz->out.width = (sz->in.width * outv) / inv;
+	} else {
+		/* Resizing based on in:out */
+		inv = sz->in.width;
+		outv = sz->out.width;
+		g_hlen = scale_1d_smart(&inv, &outv, 0);
+		if (g_hlen > 0) {
+			/* Resizing succeeded */
+			sz->out.width = outv;
+			sz->num.width = ratio(sz->in.width, sz->out.width,
+					      &sz->den.width);
+		} else
+			return -1;
+	}
+
+	sz->out.width &= ~1;
+
+	/* vertical resizing. parameter check - must provide in size */
+	if (!sz->in.height)
+		return -1;
+
+	/* Resizing based on num:den */
+	inv = sz->num.height;
+	outv = sz->den.height;
+	g_vlen = scale_1d_smart(&inv, &outv, g_hlen);
+	if (g_vlen > 0) {
+		/* Resizing succeeded */
+		sz->den.height = outv;
+		sz->out.height = (sz->in.height * outv) / inv;
+	} else {
+		/* Resizing based on in:out */
+		inv = sz->in.height;
+		outv = sz->out.height;
+		g_vlen = scale_1d_smart(&inv, &outv, g_hlen);
+		if (g_vlen > 0) {
+			/* Resizing succeeded */
+			sz->out.height = outv;
+			sz->num.height = ratio(sz->in.height, sz->out.height,
+					       &sz->den.height);
+		} else
+			return -1;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Set PP resizing registers.
+ * @param sz	Pointer to pp scaling structure
+ * @return	Zero on success, others on failure
+ */
+static int pphw_scale(emma_pp_scale *sz)
+{
+	__raw_writel((sz->out.width << 16) | sz->out.height,
+		     PP_DEST_IMAGE_SIZE);
+	__raw_writel(((g_hlen - 1) << 16) | (g_vlen ==
+					     g_hlen ? 0 : (g_hlen << 8)) |
+		     (g_vlen - 1), PP_RESIZE_INDEX);
+	for (g_hlen = 0; g_hlen < g_vlen; g_hlen++)
+		__raw_writel(scale_tbl[g_hlen],
+			     PP_RESIZE_COEF_TBL + g_hlen * 4);
+
+	return 0;
+}
+
+/*!
+ * @brief Reset PP.
+ * @return	Zero on success, others on failure
+ */
+static int pphw_reset(void)
+{
+	int i;
+
+	__raw_writel(0x100, PP_CNTL);
+
+	/* timeout */
+	for (i = 0; i < 1000; i++) {
+		if (!(__raw_readl(PP_CNTL) & 0x100)) {
+			pr_debug("pp reset over\n");
+			break;
+		}
+	}
+
+	/* check reset value */
+	if (__raw_readl(PP_CNTL) != 0x876) {
+		pr_debug("pp reset value err = 0x%08X\n", __raw_readl(PP_CNTL));
+		return -1;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Enable or disable PP.
+ * @param flag	Zero to disable PP, others to enable PP
+ * @return	Zero on success, others on failure
+ */
+static int pphw_enable(int flag)
+{
+	int ret = 0;
+
+	if (flag)
+		__raw_writel(__raw_readl(PP_CNTL) | 1, PP_CNTL);
+	else
+		ret = pphw_reset();
+
+	return ret;
+}
+
+/*!
+ * @brief Set PP input address.
+ * @param cfg	The pointer to PP configuration parameter
+ * @return	Zero on success, others on failure
+ */
+static int pphw_ptr(emma_pp_cfg *cfg)
+{
+	if (!cfg->ptr.u) {
+		int size;
+
+		/* yuv - packed */
+		size = PP_CALC_Y_SIZE(cfg);
+		cfg->ptr.u = cfg->ptr.y + size;
+		cfg->ptr.v = cfg->ptr.u + (size >> 2);
+
+		/* yuv packed with qp appended */
+		if (!cfg->ptr.qp)
+			cfg->ptr.qp = cfg->ptr.v + (size >> 2);
+	}
+	__raw_writel(cfg->ptr.y, PP_SOURCE_Y_PTR);
+	__raw_writel(cfg->ptr.u, PP_SOURCE_CB_PTR);
+	__raw_writel(cfg->ptr.v, PP_SOURCE_CR_PTR);
+	__raw_writel(cfg->ptr.qp, PP_QUANTIZER_PTR);
+
+	return 0;
+}
+
+/*!
+ * @brief Set PP output address.
+ * @param cfg	The pointer to PP configuration parameter
+ * @return	Zero on success, others on failure
+ */
+static int pphw_outptr(emma_pp_cfg *cfg)
+{
+	__raw_writel(cfg->outptr, PP_DEST_RGB_PTR);
+	return 0;
+}
+
+/*!
+ * @brief Configuration PP.
+ * @param cfg	The pointer to PP configuration parameter
+ * @return	Zero on success, others on failure
+ */
+static int pphw_cfg(emma_pp_cfg *cfg)
+{
+	int rt;
+	register int r;
+
+	pphw_scale(&cfg->dim);
+
+	if (!cfg->in_y_stride)
+		cfg->in_y_stride = cfg->dim.in.width;
+
+	if (!cfg->out_stride)
+		cfg->out_stride = cfg->dim.out.width;
+
+	r = __raw_readl(PP_CNTL) & ~EN_MASK;
+
+	/* config parms */
+	r |= cfg->operation & EN_MASK;
+	if (cfg->operation & EN_MACROBLOCK) {
+		/* Macroblock Mode */
+		r |= 0x0200;
+		__raw_writel(0x06, PP_INTRCNTL);
+	} else {
+		/* Frame mode */
+		__raw_writel(0x05, PP_INTRCNTL);
+	}
+
+	if (cfg->red_width | cfg->green_width | cfg->blue_width) {
+		/* color conversion to be performed */
+		r |= EN_CSC;
+		if (!(cfg->red_offset | cfg->green_offset)) {
+			/* auto offset B:G:R LSb to Msb */
+			cfg->green_offset = cfg->blue_offset + cfg->blue_width;
+			cfg->red_offset = cfg->green_offset + cfg->green_width;
+		}
+		if (!cfg->rgb_resolution) {
+			/* derive minimum resolution required */
+			int w, w2;
+
+			w = cfg->red_offset + cfg->red_width;
+			w2 = cfg->blue_offset + cfg->blue_width;
+			if (w < w2)
+				w = w2;
+			w2 = cfg->green_offset + cfg->green_width;
+			if (w < w2)
+				w = w2;
+			if (w > 16)
+				w = 24;
+			else if (w > 8)
+				w = 16;
+			else
+				w = 8;
+			cfg->rgb_resolution = w;
+		}
+		/* 00,11 - 32 bpp, 10 - 16 bpp, 01 - 8 bpp */
+		r &= ~0xC00;
+		if (cfg->rgb_resolution < 32)
+			r |= (cfg->rgb_resolution << 7);
+		__raw_writel((cfg->red_offset << 26) |
+			     (cfg->green_offset << 21) |
+			     (cfg->blue_offset << 16) |
+			     (cfg->red_width << 8) |
+			     (cfg->green_width << 4) |
+			     cfg->blue_width, PP_DEST_FRAME_FMT_CNTL);
+	} else {
+		/* add YUV422 formatting */
+		static const unsigned int _422[] = {
+			0x62000888,
+			0x60100888,
+			0x43080888,
+			0x41180888
+		};
+
+		__raw_writel(_422[(cfg->blue_offset >> 3) & 3],
+			     PP_DEST_FRAME_FMT_CNTL);
+		cfg->rgb_resolution = 16;
+		r &= ~0xC00;
+		r |= (cfg->rgb_resolution << 7);
+	}
+
+	/* add csc formatting */
+	if (!cfg->csc_table[1]) {
+		static const unsigned short _csc[][6] = {
+			{0x80, 0xb4, 0x2c, 0x5b, 0x0e4, 0},
+			{0x95, 0xcc, 0x32, 0x68, 0x104, 1},
+			{0x80, 0xca, 0x18, 0x3c, 0x0ec, 0},
+			{0x95, 0xe5, 0x1b, 0x44, 0x10e, 1},
+		};
+		memcpy(cfg->csc_table, _csc[cfg->csc_table[0]],
+		       sizeof(_csc[0]));
+	}
+	__raw_writel((cfg->csc_table[0] << 24) |
+		     (cfg->csc_table[1] << 16) |
+		     (cfg->csc_table[2] << 8) |
+		     cfg->csc_table[3], PP_CSC_COEF_0123);
+	__raw_writel((cfg->csc_table[5] ? (1 << 9) : 0) | cfg->csc_table[4],
+		     PP_CSC_COEF_4);
+
+	__raw_writel(r, PP_CNTL);
+
+	pphw_ptr(cfg);
+	pphw_outptr(cfg);
+
+	/*
+	 * #MB in a row = input_width / 16pix
+	 * 1 byte per QP per MB
+	 * QP must be formatted to be 4-byte aligned
+	 * YUV lines are to be 4-byte aligned as well
+	 * So Y is 8 byte aligned, as U = V = Y/2 for 420
+	 * MPEG MBs are 16x16 anyway
+	 */
+	__raw_writel((cfg->dim.in.width << 16) | cfg->dim.in.height,
+		     PP_PROCESS_FRAME_PARA);
+	__raw_writel(cfg->in_y_stride | (PP_CALC_QP_WIDTH(cfg) << 16),
+		     PP_SOURCE_FRAME_WIDTH);
+
+	/* in bytes */
+	rt = cfg->rgb_resolution >> 3;
+	if (rt == 3)
+		rt = 4;
+	__raw_writel(cfg->out_stride * rt, PP_DEST_DISPLAY_WIDTH);
+
+	pp_dump();
+	return 0;
+}
+
+/*!
+ * @brief Check PP interrupt status.
+ * @return	PP interrupt status
+ */
+static int pphw_isr(void)
+{
+	unsigned long status;
+
+	pr_debug("pp: in isr.\n");
+	status = __raw_readl(PP_INTRSTATUS) & 7;
+	if (!status) {
+		pr_debug("pp: not my isr err.\n");
+		return status;
+	}
+
+	if (status & 4)
+		pr_debug("pp: isr state error.\n");
+
+	/* clear interrupt status */
+	__raw_writel(status, PP_INTRSTATUS);
+
+	return status;
+}
+
+static struct clk *emma_clk;
+
+/*!
+ * @brief PP module clock enable
+ */
+static void pphw_init(void)
+{
+	emma_clk = clk_get(NULL, "emma_clk");
+	clk_enable(emma_clk);
+}
+
+/*!
+ * @brief PP module clock disable
+ */
+static void pphw_exit(void)
+{
+	clk_disable(emma_clk);
+	clk_put(emma_clk);
+}
diff --git a/drivers/media/video/mxc/output/mx27_pp.h b/drivers/media/video/mxc/output/mx27_pp.h
new file mode 100644
index 0000000..201e5cc
--- /dev/null
+++ b/drivers/media/video/mxc/output/mx27_pp.h
@@ -0,0 +1,180 @@
+/*
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx27_pp.h
+ *
+ * @brief Header file for MX27 V4L2 Video Output Driver
+ *
+ * @ingroup MXC_V4L2_OUTPUT
+ */
+#ifndef __MX27_PP_H__
+#define __MX27_PP_H__
+
+#include "mxc_v4l2_output.h"
+
+/* PP register definitions */
+#define PP_REG(ofs)    (IO_ADDRESS(EMMA_PRP_BASE_ADDR) - 0x400 + ofs)
+
+/* Register offsets */
+#define PP_CNTL			PP_REG(0x00)
+#define PP_INTRCNTL	 	PP_REG(0x04)
+#define PP_INTRSTATUS		PP_REG(0x08)
+#define PP_SOURCE_Y_PTR		PP_REG(0x0C)
+#define PP_SOURCE_CB_PTR	PP_REG(0x10)
+#define PP_SOURCE_CR_PTR	PP_REG(0x14)
+#define PP_DEST_RGB_PTR 	PP_REG(0x18)
+#define PP_QUANTIZER_PTR	PP_REG(0x1C)
+#define PP_PROCESS_FRAME_PARA	PP_REG(0x20)
+#define PP_SOURCE_FRAME_WIDTH	PP_REG(0x24)
+#define PP_DEST_DISPLAY_WIDTH	PP_REG(0x28)
+#define PP_DEST_IMAGE_SIZE	PP_REG(0x2C)
+#define PP_DEST_FRAME_FMT_CNTL	PP_REG(0x30)
+#define PP_RESIZE_INDEX		PP_REG(0x34)
+#define	PP_CSC_COEF_0123	PP_REG(0x38)
+#define	PP_CSC_COEF_4		PP_REG(0x3C)
+#define PP_RESIZE_COEF_TBL	PP_REG(0x100)
+
+/* resize table dimensions
+    dest pixel index    left/32    right/32    #src pixels to read
+    0                   [BC_COEF]  [BC_COEF]   [BC_NXT]
+    :
+    pp_tbl_max-1
+*/
+#define BC_NXT		2
+#define BC_COEF		5
+#define SZ_COEF		(1 << BC_COEF)
+#define SZ_NXT		(1 << BC_NXT)
+
+/* PP operations */
+#define EN_DEBLOCK 	0x02
+#define EN_DERING	0x04
+#define EN_CSC		0x10
+#define EN_MACROBLOCK	0x20
+#define EN_DEF		0x16
+#define EN_MASK		0x36
+#define EN_BIGDATA	0x1000
+#define EN_BIGQP	0x2000
+
+/* PP CSC tables */
+#define CSC_TBL_NONE	0x80
+#define CSC_TBL_REUSE	0x81
+#define CSC_TBL_A1	0x00
+#define CSC_TBL_A0	0x20
+#define CSC_TBL_B1	0x40
+#define CSC_TBL_B0	0x60
+/* converts from 4 decimal fixed point to hw setting & vice versa */
+#define PP_CSC_FP4_2_HW(coeff)	((((coeff) << 7) + 5000) / 10000)
+#define PP_CSC_HW_2_FP4(coeff)	((((coeff) * 10000) + 64) >> 7)
+
+#define PP_PIX_YUYV	0
+#define PP_PIX_YVYU	8
+#define PP_PIX_UYVY	16
+#define PP_PIX_VYUY	24
+
+/* PP size & width calculation macros */
+#define PP_CALC_QP_WIDTH(cfg)	\
+	(!((cfg)->operation & (EN_DEBLOCK | EN_DERING)) ? 0 : \
+		(((((cfg)->dim.in.width + 15) >> 4) + 3) & ~3))
+#define PP_CALC_Y_SIZE(cfg)		\
+	((cfg)->in_y_stride * (cfg)->dim.in.height)
+#define PP_CALC_CH_SIZE(cfg)		(PP_CALC_Y_SIZE(cfg) >> 2)
+#define PP_CALC_BPP(cfg) 		\
+	((cfg)->rgb_resolution > 16 ?  4 : ((cfg)->rgb_resolution >> 3))
+#define PP_CALC_YUV_SIZE(cfg)		\
+	((PP_CALC_Y_SIZE(cfg) * 3) >> 1)
+#define PP_CALC_QP_SIZE(cfg)		\
+	(PP_CALC_QP_WIDTH(cfg) * (((cfg)->dim.in.height + 15) >> 4))
+#define PP_CALC_DEST_WIDTH(cfg)	\
+	(((cfg)->out_stride & ~1) * PP_CALC_BPP(cfg))
+#define PP_CALC_DEST_SIZE(cfg)	\
+	((cfg)->dim.out.height * PP_CALC_DEST_WIDTH(cfg))
+
+/*
+ * physical addresses for bus mastering
+ * v=0 -> yuv packed
+ * v=0 & qp=0 -> yuv packed with qp appended
+ */
+typedef struct _emma_pp_ptr {
+	unsigned int y;		/* Y data (line align8) */
+	unsigned int u;		/* U data (line align4) */
+	unsigned int v;		/* V data (line align4) */
+	unsigned int qp;	/* Quantization (line align4) */
+} emma_pp_ptr;
+
+typedef struct _emma_pp_size {
+	int width;
+	int height;
+} emma_pp_size;
+
+/*
+ * if num.width != 0
+ * 	resize ratio = num.width : den.width
+ * else
+ * 	resize ratio = in.width : out.width
+ * same for height
+ */
+typedef struct _emma_pp_scale {
+	emma_pp_size num;
+	emma_pp_size den;
+	emma_pp_size in;	/* clip */
+	emma_pp_size out;	/* 0 -> same as in */
+} emma_pp_scale;
+
+typedef struct _emma_pp_cfg {
+	unsigned char operation;	/* OR of EN_xx defines */
+
+	/*
+	 * input color coeff
+	 * fixed pt 8 bits, steps of 1/128
+	 * csc[5] is 1 or 0 to indicate Y + 16
+	 * csc[0] is matrix id 0-3 while csc[1-5]=0
+	 */
+	unsigned short csc_table[6];
+
+	/*
+	 * Output color (shade width, shade offset, pixel resolution)
+	 * Eg. 16bpp RGB565 resolution, the values could be:
+	 * red_width = 5, green_width = 6, blue_width = 6
+	 * red_offset = 11, green_offset = 5, blue_offset = 0 (defaults)
+	 * rgb_resolution = 16 (default)
+	 * For YUV422: xxx_width=0, blue_offset=PP_PIX_xxx
+	 */
+	unsigned short red_width;
+	unsigned short green_width;
+	unsigned short blue_width;
+	/* if offsets are 0, the offsets are by width LSb to MSb B:G:R */
+	unsigned short red_offset;
+	unsigned short blue_offset;
+	unsigned short green_offset;
+	/* if resolution is 0, the minimum for the sum of widths is chosen */
+	short rgb_resolution;	/* 8,16,24 bpp only */
+
+	emma_pp_ptr ptr;	/* dma buffer pointers */
+	unsigned int outptr;	/* RGB/YUV output */
+	emma_pp_scale dim;	/* in/out dimensions */
+
+	/* pixels between two adjacent input Y rows */
+	unsigned short in_y_stride;	/* 0 = in_width */
+	/* PIXELS between two adjacent output rows */
+	unsigned short out_stride;	/* 0 = out_width */
+} emma_pp_cfg;
+
+int pp_ptr(unsigned long ptr);
+int pp_enable(int flag);
+int pp_cfg(vout_data *vout);
+int pp_init(vout_data *vout);
+int pp_num_last(void);
+void pp_exit(vout_data *vout);
+
+#endif				/* __MX27_PP_H__ */
diff --git a/drivers/media/video/mxc/output/mx27_v4l2_output.c b/drivers/media/video/mxc/output/mx27_v4l2_output.c
new file mode 100644
index 0000000..5f09af6
--- /dev/null
+++ b/drivers/media/video/mxc/output/mx27_v4l2_output.c
@@ -0,0 +1,1423 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx27_v4l2_output.c
+ *
+ * @brief MX27 V4L2 Video Output Driver
+ *
+ * Video4Linux2 Output Device using MX27 eMMA Post-processing functionality.
+ *
+ * @ingroup MXC_V4L2_OUTPUT
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/semaphore.h>
+#include <linux/poll.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-ioctl.h>
+
+#include "mxc_v4l2_output.h"
+#include "mx27_pp.h"
+
+#define SDC_FG_FB_FORMAT	V4L2_PIX_FMT_RGB565
+
+struct v4l2_output mxc_outputs[1] = {
+	{
+	 .index = 0,
+	 .name = "DISP0 Video Out",
+	 .type = V4L2_OUTPUT_TYPE_ANALOG,	/* not really correct,
+						   but no other choice */
+	 .audioset = 0,
+	 .modulator = 0,
+	 .std = V4L2_STD_UNKNOWN},
+};
+
+static int video_nr = 16;
+static DEFINE_SPINLOCK(g_lock);
+vout_data *g_vout;
+
+/* debug counters */
+uint32_t g_irq_cnt;
+uint32_t g_buf_output_cnt;
+uint32_t g_buf_q_cnt;
+uint32_t g_buf_dq_cnt;
+
+#ifdef CONFIG_VIDEO_MXC_OUTPUT_FBSYNC
+static uint32_t g_output_fb = -1;
+static uint32_t g_fb_enabled;
+static uint32_t g_pp_ready;
+
+static int fb_event_notify(struct notifier_block *self,
+			   unsigned long action, void *data)
+{
+	struct fb_event *event = data;
+	struct fb_info *info = event->info;
+	unsigned long lock_flags;
+	int blank, i;
+
+	for (i = 0; i < num_registered_fb; i++)
+		if (registered_fb[i] == info)
+			break;
+
+	/*
+	 * Check if the event is sent by the framebuffer in which
+	 * the video is displayed.
+	 */
+	if (i != g_output_fb)
+		return 0;
+
+	switch (action) {
+	case FB_EVENT_BLANK:
+		blank = *(int *)event->data;
+		spin_lock_irqsave(&g_lock, lock_flags);
+		g_fb_enabled = !blank;
+		if (blank && g_pp_ready) {
+			if (pp_enable(1))
+				pr_debug("unable to enable PP\n");
+			g_pp_ready = 0;
+		}
+		spin_unlock_irqrestore(&g_lock, lock_flags);
+		break;
+	case FB_EVENT_MXC_EOF:
+		spin_lock_irqsave(&g_lock, lock_flags);
+		g_fb_enabled = 1;
+		if (g_pp_ready) {
+			if (pp_enable(1))
+				pr_debug("unable to enable PP\n");
+			g_pp_ready = 0;
+		}
+		spin_unlock_irqrestore(&g_lock, lock_flags);
+		break;
+	}
+
+	return 0;
+}
+
+static struct notifier_block fb_event_notifier = {
+	.notifier_call = fb_event_notify,
+};
+
+static struct notifier_block mx2fb_event_notifier = {
+	.notifier_call = fb_event_notify,
+};
+#endif
+
+#define QUEUE_SIZE (MAX_FRAME_NUM + 1)
+static inline int queue_size(v4l_queue *q)
+{
+	if (q->tail >= q->head)
+		return q->tail - q->head;
+	else
+		return (q->tail + QUEUE_SIZE) - q->head;
+}
+
+static inline int queue_buf(v4l_queue *q, int idx)
+{
+	if (((q->tail + 1) % QUEUE_SIZE) == q->head)
+		return -1;	/* queue full */
+	q->list[q->tail] = idx;
+	q->tail = (q->tail + 1) % QUEUE_SIZE;
+	return 0;
+}
+
+static inline int dequeue_buf(v4l_queue *q)
+{
+	int ret;
+	if (q->tail == q->head)
+		return -1;	/* queue empty */
+	ret = q->list[q->head];
+	q->head = (q->head + 1) % QUEUE_SIZE;
+	return ret;
+}
+
+static inline int peek_next_buf(v4l_queue *q)
+{
+	if (q->tail == q->head)
+		return -1;	/* queue empty */
+	return q->list[q->head];
+}
+
+static inline unsigned long get_jiffies(struct timeval *t)
+{
+	struct timeval cur;
+
+	if (t->tv_usec >= 1000000) {
+		t->tv_sec += t->tv_usec / 1000000;
+		t->tv_usec = t->tv_usec % 1000000;
+	}
+
+	do_gettimeofday(&cur);
+	if ((t->tv_sec < cur.tv_sec)
+	    || ((t->tv_sec == cur.tv_sec) && (t->tv_usec < cur.tv_usec)))
+		return jiffies;
+
+	if (t->tv_usec < cur.tv_usec) {
+		cur.tv_sec = t->tv_sec - cur.tv_sec - 1;
+		cur.tv_usec = t->tv_usec + 1000000 - cur.tv_usec;
+	} else {
+		cur.tv_sec = t->tv_sec - cur.tv_sec;
+		cur.tv_usec = t->tv_usec - cur.tv_usec;
+	}
+
+	return jiffies + timeval_to_jiffies(&cur);
+}
+
+/*!
+ * Private function to free buffers
+ *
+ * @param bufs_paddr	Array of physical address of buffers to be freed
+ *
+ * @param bufs_vaddr	Array of virtual address of buffers to be freed
+ *
+ * @param num_buf	Number of buffers to be freed
+ *
+ * @param size		Size for each buffer to be free
+ *
+ * @return status  0 success.
+ */
+static int mxc_free_buffers(dma_addr_t bufs_paddr[], void *bufs_vaddr[],
+			    int num_buf, int size)
+{
+	int i;
+
+	for (i = 0; i < num_buf; i++) {
+		if (bufs_vaddr[i] != 0) {
+			dma_free_coherent(0, size, bufs_vaddr[i],
+					  bufs_paddr[i]);
+			pr_debug("freed @ paddr=0x%08X\n", (u32) bufs_paddr[i]);
+			bufs_paddr[i] = 0;
+			bufs_vaddr[i] = NULL;
+		}
+	}
+	return 0;
+}
+
+/*!
+ * Private function to allocate buffers
+ *
+ * @param bufs_paddr	Output array of physical address of buffers allocated
+ *
+ * @param bufs_vaddr	Output array of virtual address of buffers allocated
+ *
+ * @param num_buf	Input number of buffers to allocate
+ *
+ * @param size		Input size for each buffer to allocate
+ *
+ * @return status	-0 Successfully allocated a buffer, -ENOBUFS failed.
+ */
+static int mxc_allocate_buffers(dma_addr_t bufs_paddr[], void *bufs_vaddr[],
+				int num_buf, int size)
+{
+	int i;
+
+	for (i = 0; i < num_buf; i++) {
+		bufs_vaddr[i] = dma_alloc_coherent(0, size,
+						   &bufs_paddr[i],
+						   GFP_DMA | GFP_KERNEL);
+
+		if (bufs_vaddr[i] == 0) {
+			mxc_free_buffers(bufs_paddr, bufs_vaddr, i, size);
+			pr_debug("dma_alloc_coherent failed.\n");
+			return -ENOBUFS;
+		}
+		pr_debug("allocated @ paddr=0x%08X, size=%d.\n",
+			 (u32) bufs_paddr[i], size);
+	}
+
+	return 0;
+}
+
+static void mxc_v4l2out_timer_handler(unsigned long arg)
+{
+	int index;
+	unsigned long timeout;
+	unsigned long lock_flags;
+	vout_data *vout = (vout_data *) arg;
+
+	pr_debug("timer handler: %lu\n", jiffies);
+
+	spin_lock_irqsave(&g_lock, lock_flags);
+
+	if ((vout->state == STATE_STREAM_OFF)
+	    || (vout->state == STATE_STREAM_STOPPING)) {
+		pr_debug("stream has stopped\n");
+		goto exit0;
+	}
+
+	/*
+	 * If timer occurs before PP h/w is ready, then set the state to
+	 * paused and the timer will be set again when next buffer is queued
+	 * or PP completes.
+	 */
+	if (vout->ipu_buf[0] != -1) {
+		pr_debug("buffer is busy\n");
+		vout->state = STATE_STREAM_PAUSED;
+		goto exit0;
+	}
+
+	/* Dequeue buffer and pass to PP */
+	index = dequeue_buf(&vout->ready_q);
+	if (index == -1) {	/* no buffers ready, should never occur */
+		pr_debug("mxc_v4l2out: timer - no queued buffers ready\n");
+		goto exit0;
+	}
+
+	g_buf_dq_cnt++;
+	vout->frame_count++;
+	vout->ipu_buf[0] = index;
+
+	if (pp_ptr((unsigned int)vout->queue_buf_paddr[index])) {
+		pr_debug("unable to update buffer\n");
+		goto exit0;
+	}
+#ifdef CONFIG_VIDEO_MXC_OUTPUT_FBSYNC
+	if (g_fb_enabled && (vout->v4l2_fb.flags != V4L2_FBUF_FLAG_OVERLAY))
+		g_pp_ready = 1;
+	else if (pp_enable(1)) {
+		pr_debug("unable to enable PP\n");
+		goto exit0;
+	}
+#else
+	if (pp_enable(1)) {
+		pr_debug("unable to enable PP\n");
+		goto exit0;
+	}
+#endif
+	pr_debug("enabled index %d\n", index);
+
+	/* Setup timer for next buffer */
+	index = peek_next_buf(&vout->ready_q);
+	pr_debug("next index %d\n", index);
+	if (index != -1) {
+		/* if timestamp is 0, then default to 30fps */
+		if ((vout->v4l2_bufs[index].timestamp.tv_sec == 0)
+		    && (vout->v4l2_bufs[index].timestamp.tv_usec == 0))
+			timeout =
+			    vout->start_jiffies + vout->frame_count * HZ / 30;
+		else
+			timeout =
+			    get_jiffies(&vout->v4l2_bufs[index].timestamp);
+
+		if (jiffies >= timeout)
+			pr_debug("warning: timer timeout already expired.\n");
+
+		if (mod_timer(&vout->output_timer, timeout))
+			pr_debug("warning: timer was already set\n");
+
+		pr_debug("timer handler next schedule: %lu\n", timeout);
+	} else {
+		vout->state = STATE_STREAM_PAUSED;
+		pr_debug("timer handler paused\n");
+	}
+
+exit0:
+	spin_unlock_irqrestore(&g_lock, lock_flags);
+}
+
+irqreturn_t mxc_v4l2out_pp_in_irq_handler(int irq, void *dev_id)
+{
+	int last_buf;
+	int index;
+	unsigned long timeout;
+	unsigned long lock_flags;
+	vout_data *vout = dev_id;
+
+	spin_lock_irqsave(&g_lock, lock_flags);
+
+	g_irq_cnt++;
+
+	if ((vout->state == STATE_STREAM_OFF)
+	    || (vout->state == STATE_STREAM_STOPPING)) {
+		spin_unlock_irqrestore(&g_lock, lock_flags);
+		return IRQ_HANDLED;
+	}
+
+	if (vout->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
+		/*
+		  TODO: add set graphic window in future.
+		 */
+	}
+
+	/* Process previous buffer */
+	last_buf = vout->ipu_buf[0];
+	pr_debug("last_buf %d g_irq_cnt %d\n", last_buf, g_irq_cnt);
+	if (last_buf != -1) {
+		g_buf_output_cnt++;
+		vout->v4l2_bufs[last_buf].flags = V4L2_BUF_FLAG_DONE;
+		queue_buf(&vout->done_q, last_buf);
+		vout->ipu_buf[0] = -1;
+		wake_up_interruptible(&vout->v4l_bufq);
+	}
+
+	/* Setup timer for next buffer, when stream has been paused */
+	if ((vout->state == STATE_STREAM_PAUSED)
+	    && ((index = peek_next_buf(&vout->ready_q)) != -1)) {
+		pr_debug("next index %d\n", index);
+		/* if timestamp is 0, then default to 30fps */
+		if ((vout->v4l2_bufs[index].timestamp.tv_sec == 0)
+		    && (vout->v4l2_bufs[index].timestamp.tv_usec == 0))
+			timeout =
+			    vout->start_jiffies + vout->frame_count * HZ / 30;
+		else
+			timeout =
+			    get_jiffies(&vout->v4l2_bufs[index].timestamp);
+
+		if (jiffies >= timeout)
+			pr_debug("warning: timer timeout already expired.\n");
+
+		vout->state = STATE_STREAM_ON;
+
+		if (mod_timer(&vout->output_timer, timeout))
+			pr_debug("warning: timer was already set\n");
+
+		pr_debug("timer handler next schedule: %lu\n", timeout);
+	}
+
+	spin_unlock_irqrestore(&g_lock, lock_flags);
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * Start the output stream
+ *
+ * @param vout      structure vout_data *
+ *
+ * @return status  0 Success
+ */
+static int mxc_v4l2out_streamon(vout_data *vout)
+{
+	unsigned long timeout;
+	int index;
+
+	if (!vout)
+		return -EINVAL;
+
+	if (vout->state != STATE_STREAM_OFF)
+		return -EBUSY;
+
+	if (queue_size(&vout->ready_q) < 1) {
+		pr_debug("no buffers queued yet!\n");
+		return -EINVAL;
+	}
+
+	vout->ipu_buf[0] = -1;
+
+	if (vout->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
+		/* Free previously allocated buffer */
+		mxc_free_buffers(vout->display_bufs, vout->display_bufs_vaddr,
+				 2, vout->display_buf_size);
+		/* Allocate buffers for foreground */
+		if (mxc_allocate_buffers(vout->display_bufs,
+					 vout->display_bufs_vaddr, 2,
+					 vout->display_buf_size) < 0) {
+			pr_debug("unable to allocate SDC FG buffers\n");
+			return -ENOMEM;
+		}
+	}
+
+	/* Configure PP */
+	if (pp_cfg(vout)) {
+		/* Free previously allocated buffer */
+		mxc_free_buffers(vout->display_bufs, vout->display_bufs_vaddr,
+				 2, vout->display_buf_size);
+		pr_debug("failed to config PP.\n");
+		return -EINVAL;
+	}
+#ifdef CONFIG_VIDEO_MXC_OUTPUT_FBSYNC
+	g_output_fb = vout->output_fb_num[vout->cur_disp_output];
+	g_fb_enabled = 0;
+	g_pp_ready = 0;
+	fb_register_client(&fb_event_notifier);
+	mx2fb_register_client(&mx2fb_event_notifier);
+#endif
+	vout->frame_count = 0;
+	vout->state = STATE_STREAM_ON;
+	index = peek_next_buf(&vout->ready_q);
+
+	/* if timestamp is 0, then default to 30fps */
+	if ((vout->v4l2_bufs[index].timestamp.tv_sec == 0)
+	    && (vout->v4l2_bufs[index].timestamp.tv_usec == 0))
+		timeout = jiffies;
+	else
+		timeout = get_jiffies(&vout->v4l2_bufs[index].timestamp);
+
+	if (jiffies >= timeout)
+		pr_debug("warning: timer timeout already expired.\n");
+
+	vout->start_jiffies = vout->output_timer.expires = timeout;
+	pr_debug("STREAMON:Add timer %d timeout @ %lu jiffies, current = %lu\n",
+		 index, timeout, jiffies);
+	add_timer(&vout->output_timer);
+
+	return 0;
+}
+
+/*!
+ * Shut down the voutera
+ *
+ * @param vout      structure vout_data *
+ *
+ * @return status  0 Success
+ */
+static int mxc_v4l2out_streamoff(vout_data *vout)
+{
+	int i, retval = 0;
+	unsigned long lock_flag = 0;
+
+	if (!vout)
+		return -EINVAL;
+
+	if (vout->state == STATE_STREAM_OFF)
+		return 0;
+
+	spin_lock_irqsave(&g_lock, lock_flag);
+
+	del_timer(&vout->output_timer);
+	pp_enable(0);		/* Disable PP */
+
+	if (vout->state == STATE_STREAM_ON)
+		vout->state = STATE_STREAM_STOPPING;
+
+	spin_unlock_irqrestore(&g_lock, lock_flag);
+
+	vout->ready_q.head = vout->ready_q.tail = 0;
+	vout->done_q.head = vout->done_q.tail = 0;
+	for (i = 0; i < vout->buffer_cnt; i++) {
+		vout->v4l2_bufs[i].flags = 0;
+		vout->v4l2_bufs[i].timestamp.tv_sec = 0;
+		vout->v4l2_bufs[i].timestamp.tv_usec = 0;
+	}
+
+	vout->state = STATE_STREAM_OFF;
+
+	if (vout->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
+		/*
+		  TODO: add disable graphic window in future.
+		 */
+	}
+#ifdef CONFIG_VIDEO_MXC_OUTPUT_FBSYNC
+	g_output_fb = -1;
+	g_fb_enabled = 0;
+	g_pp_ready = 0;
+	fb_unregister_client(&fb_event_notifier);
+	mx2fb_unregister_client(&mx2fb_event_notifier);
+#endif
+
+	mxc_free_buffers(vout->display_bufs, vout->display_bufs_vaddr,
+			 2, vout->display_buf_size);
+
+	return retval;
+}
+
+/*
+ * Valid whether the palette is supported
+ *
+ * @param palette  V4L2_PIX_FMT_RGB565, V4L2_PIX_FMT_BGR24 or V4L2_PIX_FMT_BGR32
+ *
+ * @return 1 if supported, 0 if failed
+ */
+static inline int valid_mode(u32 palette)
+{
+	return palette == V4L2_PIX_FMT_YUV420;
+}
+
+/*
+ * Returns bits per pixel for given pixel format
+ *
+ * @param pixelformat  V4L2_PIX_FMT_RGB565, V4L2_PIX_FMT_BGR24 or V4L2_PIX_FMT_BGR32
+ *
+ * @return bits per pixel of pixelformat
+ */
+static u32 fmt_to_bpp(u32 pixelformat)
+{
+	u32 bpp;
+
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_RGB565:
+		bpp = 16;
+		break;
+	case V4L2_PIX_FMT_BGR24:
+	case V4L2_PIX_FMT_RGB24:
+		bpp = 24;
+		break;
+	case V4L2_PIX_FMT_BGR32:
+	case V4L2_PIX_FMT_RGB32:
+		bpp = 32;
+		break;
+	default:
+		bpp = 8;
+		break;
+	}
+	return bpp;
+}
+
+/*
+ * V4L2 - Handles VIDIOC_G_FMT Ioctl
+ *
+ * @param vout         structure vout_data *
+ *
+ * @param v4l2_format structure v4l2_format *
+ *
+ * @return  status    0 success, EINVAL failed
+ */
+static int mxc_v4l2out_g_fmt(vout_data *vout, struct v4l2_format *f)
+{
+	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return -EINVAL;
+
+	*f = vout->v2f;
+	return 0;
+}
+
+/*
+ * V4L2 - Handles VIDIOC_S_FMT Ioctl
+ *
+ * @param vout         structure vout_data *
+ *
+ * @param v4l2_format structure v4l2_format *
+ *
+ * @return  status    0 success, EINVAL failed
+ */
+static int mxc_v4l2out_s_fmt(vout_data *vout, struct v4l2_format *f)
+{
+	int retval = 0;
+	u32 size = 0;
+	u32 bytesperline;
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		retval = -EINVAL;
+		goto err0;
+	}
+	if (!valid_mode(f->fmt.pix.pixelformat)) {
+		pr_debug("pixel format not supported\n");
+		retval = -EINVAL;
+		goto err0;
+	}
+
+	bytesperline = (f->fmt.pix.width * fmt_to_bpp(f->fmt.pix.pixelformat)) /
+	    8;
+	if (f->fmt.pix.bytesperline < bytesperline)
+		f->fmt.pix.bytesperline = bytesperline;
+	else
+		bytesperline = f->fmt.pix.bytesperline;
+
+	switch (f->fmt.pix.pixelformat) {
+	case V4L2_PIX_FMT_YUV422P:
+		/* byteperline for YUV planar formats is for
+		   Y plane only */
+		size = bytesperline * f->fmt.pix.height * 2;
+		break;
+	case V4L2_PIX_FMT_YUV420:
+		size = (bytesperline * f->fmt.pix.height * 3) / 2;
+		break;
+	default:
+		size = bytesperline * f->fmt.pix.height;
+		break;
+	}
+
+	/* Return the actual size of the image to the app */
+	f->fmt.pix.sizeimage = size;
+
+	vout->v2f.fmt.pix.sizeimage = size;
+	vout->v2f.fmt.pix.width = f->fmt.pix.width;
+	vout->v2f.fmt.pix.height = f->fmt.pix.height;
+	vout->v2f.fmt.pix.pixelformat = f->fmt.pix.pixelformat;
+	vout->v2f.fmt.pix.bytesperline = f->fmt.pix.bytesperline;
+
+	retval = 0;
+err0:
+	return retval;
+}
+
+/*
+ * V4L2 - Handles VIDIOC_G_CTRL Ioctl
+ *
+ * @param vout         structure vout_data *
+ *
+ * @param c           structure v4l2_control *
+ *
+ * @return  status    0 success, EINVAL failed
+ */
+static int mxc_get_v42lout_control(vout_data *vout, struct v4l2_control *c)
+{
+	switch (c->id) {
+	case V4L2_CID_HFLIP:
+		return (vout->rotate & IPU_ROTATE_HORIZ_FLIP) ? 1 : 0;
+	case V4L2_CID_VFLIP:
+		return (vout->rotate & IPU_ROTATE_VERT_FLIP) ? 1 : 0;
+	case (V4L2_CID_PRIVATE_BASE + 1):
+		return vout->rotate;
+	default:
+		return -EINVAL;
+	}
+}
+
+/*
+ * V4L2 - Handles VIDIOC_S_CTRL Ioctl
+ *
+ * @param vout         structure vout_data *
+ *
+ * @param c           structure v4l2_control *
+ *
+ * @return  status    0 success, EINVAL failed
+ */
+static int mxc_set_v42lout_control(vout_data *vout, struct v4l2_control *c)
+{
+	switch (c->id) {
+	case V4L2_CID_HFLIP:
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_MXC_ROT:
+		return 0;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*!
+ * V4L2 interface - open function
+ *
+ * @param inode        structure inode *
+ *
+ * @param file         structure file *
+ *
+ * @return  status    0 success, ENODEV invalid device instance,
+ *                    ENODEV timeout, ERESTARTSYS interrupted by user
+ */
+static int mxc_v4l2out_open(struct inode *inode, struct file *file)
+{
+	struct video_device *dev = video_devdata(file);
+	vout_data *vout = video_get_drvdata(dev);
+	int err;
+
+	if (!vout) {
+		pr_info("Internal error, vout_data not found!\n");
+		return -ENODEV;
+	}
+
+	down(&vout->busy_lock);
+
+	err = -EINTR;
+	if (signal_pending(current))
+		goto oops;
+
+	if (vout->open_count++ == 0) {
+		pp_init(vout);
+
+		init_waitqueue_head(&vout->v4l_bufq);
+
+		init_timer(&vout->output_timer);
+		vout->output_timer.function = mxc_v4l2out_timer_handler;
+		vout->output_timer.data = (unsigned long)vout;
+
+		vout->state = STATE_STREAM_OFF;
+		g_irq_cnt = g_buf_output_cnt = g_buf_q_cnt = g_buf_dq_cnt = 0;
+
+	}
+
+	file->private_data = dev;
+	up(&vout->busy_lock);
+	return 0;
+
+oops:
+	up(&vout->busy_lock);
+	return err;
+}
+
+/*!
+ * V4L2 interface - close function
+ *
+ * @param inode    struct inode *
+ *
+ * @param file     struct file *
+ *
+ * @return         0 success
+ */
+static int mxc_v4l2out_close(struct inode *inode, struct file *file)
+{
+	struct video_device *dev = file->private_data;
+	vout_data *vout = video_get_drvdata(dev);
+
+	if (--vout->open_count == 0) {
+		pr_debug("release resource\n");
+
+		pp_exit(vout);
+		if (vout->state != STATE_STREAM_OFF)
+			mxc_v4l2out_streamoff(vout);
+
+		file->private_data = NULL;
+
+		mxc_free_buffers(vout->queue_buf_paddr,
+				 vout->queue_buf_vaddr,
+				 vout->buffer_cnt, vout->queue_buf_size);
+		vout->buffer_cnt = 0;
+		mxc_free_buffers(vout->display_bufs,
+				 vout->display_bufs_vaddr,
+				 2, vout->display_buf_size);
+
+		/* capture off */
+		wake_up_interruptible(&vout->v4l_bufq);
+	}
+
+	return 0;
+}
+
+/*!
+ * V4L2 interface - ioctl function
+ *
+ * @param inode      struct inode *
+ *
+ * @param file       struct file *
+ *
+ * @param ioctlnr    unsigned int
+ *
+ * @param arg        void *
+ *
+ * @return           0 success, ENODEV for invalid device instance,
+ *                   -1 for other errors.
+ */
+static int
+mxc_v4l2out_do_ioctl(struct inode *inode, struct file *file,
+		     unsigned int ioctlnr, void *arg)
+{
+	struct video_device *dev = file->private_data;
+	vout_data *vout = video_get_drvdata(dev);
+	int retval = 0;
+	int i = 0;
+
+	if (!vout)
+		return -EBADF;
+
+	/* make this _really_ smp-safe */
+	if (down_interruptible(&vout->busy_lock))
+		return -EBUSY;
+
+	switch (ioctlnr) {
+	case VIDIOC_QUERYCAP:
+		{
+			struct v4l2_capability *cap = arg;
+			strcpy(cap->driver, "mxc_v4l2_output");
+			cap->version = 0;
+			cap->capabilities =
+			    V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;
+			cap->card[0] = '\0';
+			cap->bus_info[0] = '\0';
+			retval = 0;
+			break;
+		}
+	case VIDIOC_G_FMT:
+		{
+			struct v4l2_format *gf = arg;
+			retval = mxc_v4l2out_g_fmt(vout, gf);
+			break;
+		}
+	case VIDIOC_S_FMT:
+		{
+			struct v4l2_format *sf = arg;
+			if (vout->state != STATE_STREAM_OFF) {
+				retval = -EBUSY;
+				break;
+			}
+			retval = mxc_v4l2out_s_fmt(vout, sf);
+			break;
+		}
+	case VIDIOC_REQBUFS:
+		{
+			struct v4l2_requestbuffers *req = arg;
+			if ((req->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) ||
+			    (req->memory != V4L2_MEMORY_MMAP)) {
+				pr_debug
+				    ("VIDIOC_REQBUFS: incorrect buffer type\n");
+				retval = -EINVAL;
+				break;
+			}
+
+			if (req->count == 0)
+				mxc_v4l2out_streamoff(vout);
+
+			if (vout->state == STATE_STREAM_OFF) {
+				if (vout->queue_buf_paddr[0] != 0) {
+					mxc_free_buffers(vout->queue_buf_paddr,
+							 vout->queue_buf_vaddr,
+							 vout->buffer_cnt,
+							 vout->queue_buf_size);
+					pr_debug
+					    ("VIDIOC_REQBUFS: freed buffers\n");
+				}
+				vout->buffer_cnt = 0;
+			} else {
+				pr_debug("VIDIOC_REQBUFS: Buffer is in use\n");
+				retval = -EBUSY;
+				break;
+			}
+
+			if (req->count == 0)
+				break;
+
+			if (req->count < MIN_FRAME_NUM)
+				req->count = MIN_FRAME_NUM;
+			else if (req->count > MAX_FRAME_NUM)
+				req->count = MAX_FRAME_NUM;
+
+			vout->buffer_cnt = req->count;
+			vout->queue_buf_size =
+			    PAGE_ALIGN(vout->v2f.fmt.pix.sizeimage);
+
+			retval = mxc_allocate_buffers(vout->queue_buf_paddr,
+						      vout->queue_buf_vaddr,
+						      vout->buffer_cnt,
+						      vout->queue_buf_size);
+			if (retval < 0)
+				break;
+
+			/* Init buffer queues */
+			vout->done_q.head = 0;
+			vout->done_q.tail = 0;
+			vout->ready_q.head = 0;
+			vout->ready_q.tail = 0;
+
+			for (i = 0; i < vout->buffer_cnt; i++) {
+				memset(&(vout->v4l2_bufs[i]), 0,
+				       sizeof(vout->v4l2_bufs[i]));
+				vout->v4l2_bufs[i].flags = 0;
+				vout->v4l2_bufs[i].memory = V4L2_MEMORY_MMAP;
+				vout->v4l2_bufs[i].index = i;
+				vout->v4l2_bufs[i].type =
+				    V4L2_BUF_TYPE_VIDEO_OUTPUT;
+				vout->v4l2_bufs[i].length =
+				    PAGE_ALIGN(vout->v2f.fmt.pix.sizeimage);
+				vout->v4l2_bufs[i].m.offset =
+				    (unsigned long)vout->queue_buf_paddr[i];
+				vout->v4l2_bufs[i].timestamp.tv_sec = 0;
+				vout->v4l2_bufs[i].timestamp.tv_usec = 0;
+			}
+			break;
+		}
+	case VIDIOC_QUERYBUF:
+		{
+			struct v4l2_buffer *buf = arg;
+			u32 type = buf->type;
+			int index = buf->index;
+
+			if ((type != V4L2_BUF_TYPE_VIDEO_OUTPUT) ||
+			    (index >= vout->buffer_cnt)) {
+				pr_debug
+				    ("VIDIOC_QUERYBUFS: incorrect buffer type\n");
+				retval = -EINVAL;
+				break;
+			}
+			down(&vout->param_lock);
+			memcpy(buf, &(vout->v4l2_bufs[index]), sizeof(*buf));
+			up(&vout->param_lock);
+			break;
+		}
+	case VIDIOC_QBUF:
+		{
+			struct v4l2_buffer *buf = arg;
+			int index = buf->index;
+			unsigned long lock_flags;
+			unsigned long timeout;
+
+			if ((buf->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) ||
+			    (index >= vout->buffer_cnt) || (buf->flags != 0)) {
+				retval = -EINVAL;
+				break;
+			}
+
+			pr_debug("VIDIOC_QBUF: %d\n", buf->index);
+
+			spin_lock_irqsave(&g_lock, lock_flags);
+
+			memcpy(&(vout->v4l2_bufs[index]), buf, sizeof(*buf));
+			vout->v4l2_bufs[index].flags |= V4L2_BUF_FLAG_QUEUED;
+
+			g_buf_q_cnt++;
+			queue_buf(&vout->ready_q, index);
+
+			if (vout->state == STATE_STREAM_PAUSED) {
+				index = peek_next_buf(&vout->ready_q);
+
+				/* if timestamp is 0, then default to 30fps */
+				if ((vout->v4l2_bufs[index].timestamp.tv_sec ==
+				     0)
+				    && (vout->v4l2_bufs[index].timestamp.
+					tv_usec == 0))
+					timeout =
+					    vout->start_jiffies +
+					    vout->frame_count * HZ / 30;
+				else
+					timeout =
+					    get_jiffies(&vout->v4l2_bufs[index].
+							timestamp);
+
+				if (jiffies >= timeout) {
+					pr_debug
+					    ("warning: timer timeout already expired.\n");
+				}
+
+				vout->output_timer.expires = timeout;
+				pr_debug
+				    ("QBUF:Add timer %d timeout @ %lu jiffies, "
+				     "current = %lu\n", index, timeout,
+				     jiffies);
+				add_timer(&vout->output_timer);
+				vout->state = STATE_STREAM_ON;
+			}
+
+			spin_unlock_irqrestore(&g_lock, lock_flags);
+			break;
+		}
+	case VIDIOC_DQBUF:
+		{
+			struct v4l2_buffer *buf = arg;
+			int idx;
+
+			pr_debug("VIDIOC_DQBUF: q size = %d\n",
+				 queue_size(&vout->done_q));
+
+			if ((queue_size(&vout->done_q) == 0) &&
+			    (file->f_flags & O_NONBLOCK)) {
+				retval = -EAGAIN;
+				break;
+			}
+
+			if (!wait_event_interruptible_timeout(vout->v4l_bufq,
+							      queue_size(&vout->
+									 done_q)
+							      != 0, 10 * HZ)) {
+				pr_debug("VIDIOC_DQBUF: timeout\n");
+				retval = -ETIME;
+				break;
+			} else if (signal_pending(current)) {
+				pr_debug("VIDIOC_DQBUF: interrupt received\n");
+				retval = -ERESTARTSYS;
+				break;
+			}
+			idx = dequeue_buf(&vout->done_q);
+			if (idx == -1) {	/* No frame free */
+				pr_debug
+				    ("VIDIOC_DQBUF: no free buffers, returning\n");
+				retval = -EAGAIN;
+				break;
+			}
+			if ((vout->v4l2_bufs[idx].flags & V4L2_BUF_FLAG_DONE) ==
+			    0)
+				pr_debug
+				    ("VIDIOC_DQBUF: buffer in done q, but not "
+				     "flagged as done\n");
+
+			vout->v4l2_bufs[idx].flags = 0;
+			memcpy(buf, &(vout->v4l2_bufs[idx]), sizeof(*buf));
+			pr_debug("VIDIOC_DQBUF: %d\n", buf->index);
+			break;
+		}
+	case VIDIOC_STREAMON:
+		{
+			retval = mxc_v4l2out_streamon(vout);
+			break;
+		}
+	case VIDIOC_STREAMOFF:
+		{
+			retval = mxc_v4l2out_streamoff(vout);
+			break;
+		}
+	case VIDIOC_G_CTRL:
+		{
+			retval = mxc_get_v42lout_control(vout, arg);
+			break;
+		}
+	case VIDIOC_S_CTRL:
+		{
+			retval = mxc_set_v42lout_control(vout, arg);
+			break;
+		}
+	case VIDIOC_CROPCAP:
+		{
+			struct v4l2_cropcap *cap = arg;
+
+			if (cap->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+				retval = -EINVAL;
+				break;
+			}
+			cap->bounds = vout->crop_bounds[vout->cur_disp_output];
+			cap->defrect = vout->crop_bounds[vout->cur_disp_output];
+			retval = 0;
+			break;
+		}
+	case VIDIOC_G_CROP:
+		{
+			struct v4l2_crop *crop = arg;
+
+			if (crop->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+				retval = -EINVAL;
+				break;
+			}
+			crop->c = vout->crop_current;
+			break;
+		}
+	case VIDIOC_S_CROP:
+		{
+			struct v4l2_crop *crop = arg;
+			struct v4l2_rect *b =
+			    &(vout->crop_bounds[vout->cur_disp_output]);
+
+			if (crop->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+				retval = -EINVAL;
+				break;
+			}
+			if (crop->c.height < 0) {
+				retval = -EINVAL;
+				break;
+			}
+			if (crop->c.width < 0) {
+				retval = -EINVAL;
+				break;
+			}
+
+			if (crop->c.top < b->top)
+				crop->c.top = b->top;
+			if (crop->c.top > b->top + b->height)
+				crop->c.top = b->top + b->height;
+			if (crop->c.height > b->top - crop->c.top + b->height)
+				crop->c.height =
+				    b->top - crop->c.top + b->height;
+
+			if (crop->c.left < b->left)
+				crop->c.top = b->left;
+			if (crop->c.left > b->left + b->width)
+				crop->c.top = b->left + b->width;
+			if (crop->c.width > b->left - crop->c.left + b->width)
+				crop->c.width =
+				    b->left - crop->c.left + b->width;
+
+			/* stride line limitation */
+			crop->c.height -= crop->c.height % 8;
+			crop->c.width -= crop->c.width % 8;
+
+			vout->crop_current = crop->c;
+
+			vout->display_buf_size = vout->crop_current.width *
+			    vout->crop_current.height;
+			vout->display_buf_size *=
+			    fmt_to_bpp(SDC_FG_FB_FORMAT) / 8;
+			break;
+		}
+	case VIDIOC_ENUMOUTPUT:
+		{
+			struct v4l2_output *output = arg;
+
+			if ((output->index >= 2) ||
+			    (vout->output_enabled[output->index] == false)) {
+				retval = -EINVAL;
+				break;
+			}
+
+			*output = mxc_outputs[0];
+			output->name[4] = '0' + output->index;
+			break;
+		}
+	case VIDIOC_G_OUTPUT:
+		{
+			int *p_output_num = arg;
+
+			*p_output_num = vout->cur_disp_output;
+			break;
+		}
+	case VIDIOC_S_OUTPUT:
+		{
+			int *p_output_num = arg;
+
+			if ((*p_output_num >= 2) ||
+			    (vout->output_enabled[*p_output_num] == false)) {
+				retval = -EINVAL;
+				break;
+			}
+
+			if (vout->state != STATE_STREAM_OFF) {
+				retval = -EBUSY;
+				break;
+			}
+
+			vout->cur_disp_output = *p_output_num;
+			break;
+		}
+	case VIDIOC_G_FBUF:
+		{
+			struct v4l2_framebuffer *fb = arg;
+			*fb = vout->v4l2_fb;
+			break;
+		}
+	case VIDIOC_S_FBUF:
+		{
+			struct v4l2_framebuffer *fb = arg;
+			vout->v4l2_fb = *fb;
+			vout->v4l2_fb.capability = V4L2_FBUF_CAP_EXTERNOVERLAY;
+			break;
+		}
+	case VIDIOC_ENUM_FMT:
+	case VIDIOC_TRY_FMT:
+	case VIDIOC_QUERYCTRL:
+	case VIDIOC_G_PARM:
+	case VIDIOC_ENUMSTD:
+	case VIDIOC_G_STD:
+	case VIDIOC_S_STD:
+	case VIDIOC_G_TUNER:
+	case VIDIOC_S_TUNER:
+	case VIDIOC_G_FREQUENCY:
+	case VIDIOC_S_FREQUENCY:
+	default:
+		retval = -EINVAL;
+		break;
+	}
+
+	up(&vout->busy_lock);
+	return retval;
+}
+
+/*
+ * V4L2 interface - ioctl function
+ *
+ * @return  None
+ */
+static int
+mxc_v4l2out_ioctl(struct inode *inode, struct file *file,
+		  unsigned int cmd, unsigned long arg)
+{
+	return video_usercopy(inode, file, cmd, arg, mxc_v4l2out_do_ioctl);
+}
+
+/*!
+ * V4L2 interface - mmap function
+ *
+ * @param file          structure file *
+ *
+ * @param vma           structure vm_area_struct *
+ *
+ * @return status       0 Success, EINTR busy lock error,
+ *                      ENOBUFS remap_page error
+ */
+static int mxc_v4l2out_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct video_device *dev = file->private_data;
+	unsigned long start = vma->vm_start;
+	unsigned long size = vma->vm_end - vma->vm_start;
+	int res = 0;
+	vout_data *vout = video_get_drvdata(dev);
+
+	/* make this _really_ smp-safe */
+	if (down_interruptible(&vout->busy_lock))
+		return -EINTR;
+
+	/* make buffers write-thru cacheable */
+	vma->vm_page_prot = __pgprot(pgprot_val(vma->vm_page_prot) &
+				     ~L_PTE_BUFFERABLE);
+
+	if (remap_pfn_range(vma, start, vma->vm_pgoff, size, vma->vm_page_prot)) {
+		pr_debug("mxc_mmap(V4L)i - remap_pfn_range failed\n");
+		res = -ENOBUFS;
+		goto mxc_mmap_exit;
+	}
+
+mxc_mmap_exit:
+	up(&vout->busy_lock);
+	return res;
+}
+
+/*!
+ * V4L2 interface - poll function
+ *
+ * @param file       structure file *
+ *
+ * @param wait       structure poll_table *
+ *
+ * @return  status   POLLIN | POLLRDNORM
+ */
+static unsigned int mxc_v4l2out_poll(struct file *file, poll_table *wait)
+{
+	struct video_device *dev = file->private_data;
+	vout_data *vout = video_get_drvdata(dev);
+
+	wait_queue_head_t *queue = NULL;
+	int res = POLLIN | POLLRDNORM;
+
+	if (down_interruptible(&vout->busy_lock))
+		return -EINTR;
+
+	queue = &vout->v4l_bufq;
+	poll_wait(file, queue, wait);
+
+	up(&vout->busy_lock);
+	return res;
+}
+
+static struct file_operations mxc_v4l2out_fops = {
+	.owner = THIS_MODULE,
+	.open = mxc_v4l2out_open,
+	.release = mxc_v4l2out_close,
+	.ioctl = mxc_v4l2out_ioctl,
+	.mmap = mxc_v4l2out_mmap,
+	.poll = mxc_v4l2out_poll,
+};
+
+static struct video_device mxc_v4l2out_template = {
+	.name = "MXC Video Output",
+	.vfl_type = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING,
+	.fops = &mxc_v4l2out_fops,
+	.release = video_device_release,
+};
+
+/*!
+ * Probe routine for the framebuffer driver. It is called during the
+ * driver binding process.      The following functions are performed in
+ * this routine: Framebuffer initialization, Memory allocation and
+ * mapping, Framebuffer registration, IPU initialization.
+ *
+ * @return      Appropriate error code to the kernel common code
+ */
+static int mxc_v4l2out_probe(struct platform_device *pdev)
+{
+	int i;
+	vout_data *vout;
+
+	/*
+	 * Allocate sufficient memory for the fb structure
+	 */
+	g_vout = vout = kmalloc(sizeof(vout_data), GFP_KERNEL);
+
+	if (!vout)
+		return 0;
+
+	memset(vout, 0, sizeof(vout_data));
+
+	vout->video_dev = video_device_alloc();
+	if (vout->video_dev == NULL)
+		return -1;
+	vout->video_dev->minor = -1;
+
+	*(vout->video_dev) = mxc_v4l2out_template;
+
+	/* register v4l device */
+	if (video_register_device(vout->video_dev,
+				  VFL_TYPE_GRABBER, video_nr) == -1) {
+		pr_debug("video_register_device failed\n");
+		return 0;
+	}
+	pr_debug("mxc_v4l2out: registered device video%d\n",
+		 vout->video_dev->minor & 0x1f);
+
+	video_set_drvdata(vout->video_dev, vout);
+
+	init_MUTEX(&vout->param_lock);
+	init_MUTEX(&vout->busy_lock);
+
+	/* setup outputs and cropping */
+	vout->cur_disp_output = -1;
+	for (i = 0; i < num_registered_fb; i++) {
+		char *idstr = registered_fb[i]->fix.id;
+		if (strncmp(idstr, "DISP", 4) == 0 ||
+				strncmp(idstr, "IMX", 3) == 0) {
+			int disp_num = i;
+			vout->crop_bounds[disp_num].left = 0;
+			vout->crop_bounds[disp_num].top = 0;
+			vout->crop_bounds[disp_num].width =
+			    registered_fb[i]->var.xres;
+			vout->crop_bounds[disp_num].height =
+			    registered_fb[i]->var.yres;
+			vout->output_enabled[disp_num] = true;
+			vout->output_fb_num[disp_num] = i;
+			if (vout->cur_disp_output == -1)
+				vout->cur_disp_output = disp_num;
+		}
+
+	}
+	vout->crop_current = vout->crop_bounds[vout->cur_disp_output];
+
+	/* Setup framebuffer parameters */
+	vout->v4l2_fb.capability = V4L2_FBUF_CAP_EXTERNOVERLAY;
+	vout->v4l2_fb.flags = V4L2_FBUF_FLAG_PRIMARY;
+
+	return 0;
+}
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxc_v4l2out_driver = {
+	.driver = {
+		   .name = "MXC Video Output",
+		   .owner = THIS_MODULE,
+		   .bus = &platform_bus_type,
+		   },
+	.probe = mxc_v4l2out_probe,
+	.remove = NULL,
+};
+
+static void camera_platform_release(struct device *device)
+{
+}
+
+static struct platform_device mxc_v4l2out_device = {
+	.name = "MXC Video Output",
+	.dev = {
+		.release = camera_platform_release,
+		},
+	.id = 0,
+};
+
+/*!
+ * mxc v4l2 init function
+ *
+ */
+static int mxc_v4l2out_init(void)
+{
+	u8 err = 0;
+
+	err = platform_driver_register(&mxc_v4l2out_driver);
+	if (err == 0)
+		platform_device_register(&mxc_v4l2out_device);
+
+	return err;
+}
+
+/*!
+ * mxc v4l2 cleanup function
+ *
+ */
+static void mxc_v4l2out_clean(void)
+{
+	pr_debug("unregistering video\n");
+
+	video_unregister_device(g_vout->video_dev);
+
+	platform_driver_unregister(&mxc_v4l2out_driver);
+	platform_device_unregister(&mxc_v4l2out_device);
+	kfree(g_vout);
+	g_vout = NULL;
+}
+
+module_init(mxc_v4l2out_init);
+module_exit(mxc_v4l2out_clean);
+
+module_param(video_nr, int, 0444);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("V4L2-driver for MXC video output");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("video");
-- 
1.6.0.4

