From 44cfee2710e47abd5e3de25f94db14616a53b790 Mon Sep 17 00:00:00 2001
From: Andrew Gabbasov <andrew_gabbasov@mentor.com>
Date: Mon, 10 Dec 2012 11:12:14 -0500
Subject: [PATCH 459/757] Update kernel probes to more detailed match to kernel
 versions

Some ifdef's are added to kernel probes instrumentation to make them
more close to original tracepoints in different kernel versions.
Supported kernel version are from 2.6.32 to 3.7.

Signed-off-by: Andrew Gabbasov <andrew_gabbasov@mentor.com>
Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
---
 .../instrumentation/events/lttng-module/asoc.h     |   82 ++
 .../instrumentation/events/lttng-module/block.h    |  110 +-
 .../instrumentation/events/lttng-module/ext3.h     |    6 +
 .../instrumentation/events/lttng-module/jbd.h      |   22 +
 .../instrumentation/events/lttng-module/jbd2.h     |   42 +
 .../instrumentation/events/lttng-module/kmem.h     |   25 +-
 .../instrumentation/events/lttng-module/kvm.h      |   19 +
 .../instrumentation/events/lttng-module/lock.h     |  121 ++
 .../instrumentation/events/lttng-module/module.h   |   23 +
 .../instrumentation/events/lttng-module/power.h    |   99 +-
 .../instrumentation/events/lttng-module/sched.h    |   84 ++
 .../instrumentation/events/lttng-module/scsi.h     |   37 +
 .../instrumentation/events/lttng-module/signal.h   |    2 +
 .../instrumentation/events/lttng-module/skb.h      |    5 +
 .../instrumentation/events/lttng-module/vmscan.h   |  123 +-
 .../lttng/instrumentation/events/mainline/asoc.h   |   80 ++
 .../lttng/instrumentation/events/mainline/block.h  |   20 +-
 .../lttng/instrumentation/events/mainline/ext3.h   |    4 +-
 .../instrumentation/events/mainline/fs_ext3.h      | 1323 --------------------
 .../lttng/instrumentation/events/mainline/jbd.h    |   39 +-
 .../lttng/instrumentation/events/mainline/jbd2.h   |   29 +-
 .../lttng/instrumentation/events/mainline/kmem.h   |    8 +-
 .../lttng/instrumentation/events/mainline/power.h  |   37 +-
 .../lttng/instrumentation/events/mainline/sched.h  |   17 +-
 .../lttng/instrumentation/events/mainline/signal.h |   85 +-
 .../lttng/instrumentation/events/mainline/vmscan.h |  136 +-
 drivers/staging/lttng/probes/Makefile              |   43 +-
 drivers/staging/lttng/probes/lttng-probe-asoc.c    |    4 +-
 drivers/staging/lttng/probes/lttng-probe-block.c   |    2 +
 drivers/staging/lttng/probes/lttng-probe-ext3.c    |   10 +-
 drivers/staging/lttng/probes/lttng-probe-irq.c     |    3 +-
 drivers/staging/lttng/probes/lttng-probe-jbd.c     |    3 +-
 drivers/staging/lttng/probes/lttng-probe-jbd2.c    |    4 +-
 drivers/staging/lttng/probes/lttng-probe-kmem.c    |    4 +-
 drivers/staging/lttng/probes/lttng-probe-kvm.c     |    2 +
 drivers/staging/lttng/probes/lttng-probe-lock.c    |    9 +-
 drivers/staging/lttng/probes/lttng-probe-module.c  |    4 +-
 drivers/staging/lttng/probes/lttng-probe-napi.c    |    2 +
 drivers/staging/lttng/probes/lttng-probe-power.c   |    4 +-
 drivers/staging/lttng/probes/lttng-probe-sched.c   |    3 +-
 drivers/staging/lttng/probes/lttng-probe-scsi.c    |    2 +-
 drivers/staging/lttng/probes/lttng-probe-skb.c     |    4 +-
 drivers/staging/lttng/probes/lttng-probe-timer.c   |    3 +-
 drivers/staging/lttng/probes/lttng-probe-vmscan.c  |    8 +-
 44 files changed, 1074 insertions(+), 1618 deletions(-)
 delete mode 100644 drivers/staging/lttng/instrumentation/events/mainline/fs_ext3.h

diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/asoc.h b/drivers/staging/lttng/instrumentation/events/lttng-module/asoc.h
index 6ffc923..672bea4 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/asoc.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/asoc.h
@@ -8,6 +8,8 @@
 #include <linux/tracepoint.h>
 #include <linux/version.h>
 
+#define DAPM_DIRECT "(direct)"
+
 #ifndef _TRACE_ASOC_DEF
 #define _TRACE_ASOC_DEF
 struct snd_soc_jack;
@@ -251,6 +253,86 @@ TRACE_EVENT(snd_soc_dapm_walk_done,
 )
 #endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0))
+TRACE_EVENT(snd_soc_dapm_output_path,
+
+	TP_PROTO(struct snd_soc_dapm_widget *widget,
+		struct snd_soc_dapm_path *path),
+
+	TP_ARGS(widget, path),
+
+	TP_STRUCT__entry(
+		__string(	wname,	widget->name		)
+		__string(	pname,	path->name ? path->name : DAPM_DIRECT)
+		__string(	psname,	path->sink->name	)
+		__field(	int,	path_sink		)
+		__field(	int,	path_connect		)
+	),
+
+	TP_fast_assign(
+		tp_strcpy(wname, widget->name)
+		tp_strcpy(pname, path->name ? path->name : DAPM_DIRECT)
+		tp_strcpy(psname, path->sink->name)
+		tp_assign(path_connect, path->connect)
+		tp_assign(path_sink, (long)path->sink)
+	),
+
+	TP_printk("%c%s -> %s -> %s\n",
+		(int) __entry->path_sink &&
+		(int) __entry->path_connect ? '*' : ' ',
+		__get_str(wname), __get_str(pname), __get_str(psname))
+)
+
+TRACE_EVENT(snd_soc_dapm_input_path,
+
+	TP_PROTO(struct snd_soc_dapm_widget *widget,
+		struct snd_soc_dapm_path *path),
+
+	TP_ARGS(widget, path),
+
+	TP_STRUCT__entry(
+		__string(	wname,	widget->name		)
+		__string(	pname,	path->name ? path->name : DAPM_DIRECT)
+		__string(	psname,	path->source->name	)
+		__field(	int,	path_source		)
+		__field(	int,	path_connect		)
+	),
+
+	TP_fast_assign(
+		tp_strcpy(wname, widget->name)
+		tp_strcpy(pname, path->name ? path->name : DAPM_DIRECT)
+		tp_strcpy(psname, path->source->name)
+		tp_assign(path_connect, path->connect)
+		tp_assign(path_source, (long)path->source)
+	),
+
+	TP_printk("%c%s <- %s <- %s\n",
+		(int) __entry->path_source &&
+		(int) __entry->path_connect ? '*' : ' ',
+		__get_str(wname), __get_str(pname), __get_str(psname))
+)
+
+TRACE_EVENT(snd_soc_dapm_connected,
+
+	TP_PROTO(int paths, int stream),
+
+	TP_ARGS(paths, stream),
+
+	TP_STRUCT__entry(
+		__field(	int,	paths		)
+		__field(	int,	stream		)
+	),
+
+	TP_fast_assign(
+		tp_assign(paths, paths)
+		tp_assign(stream, stream)
+	),
+
+	TP_printk("%s: found %d paths\n",
+		__entry->stream ? "capture" : "playback", __entry->paths)
+)
+#endif
+
 TRACE_EVENT(snd_soc_jack_irq,
 
 	TP_PROTO(const char *name),
diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/block.h b/drivers/staging/lttng/instrumentation/events/lttng-module/block.h
index 42184f3..d42ebd4 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/block.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/block.h
@@ -8,6 +8,9 @@
 #include <linux/blkdev.h>
 #include <linux/tracepoint.h>
 #include <linux/trace_seq.h>
+#include <linux/version.h>
+
+#define RWBS_LEN	8
 
 #ifndef _TRACE_BLOCK_DEF_
 #define _TRACE_BLOCK_DEF_
@@ -19,23 +22,45 @@ enum {
 	RWBS_FLAG_DISCARD	= (1 << 1),
 	RWBS_FLAG_READ		= (1 << 2),
 	RWBS_FLAG_RAHEAD	= (1 << 3),
-	RWBS_FLAG_SYNC		= (1 << 4),
-	RWBS_FLAG_META		= (1 << 5),
-	RWBS_FLAG_SECURE	= (1 << 6),
+	RWBS_FLAG_BARRIER	= (1 << 4),
+	RWBS_FLAG_SYNC		= (1 << 5),
+	RWBS_FLAG_META		= (1 << 6),
+	RWBS_FLAG_SECURE	= (1 << 7),
+	RWBS_FLAG_FLUSH		= (1 << 8),
+	RWBS_FLAG_FUA		= (1 << 9),
 };
 
 #endif /* _TRACE_BLOCK_DEF_ */
 
 #define __print_rwbs_flags(rwbs)		\
 	__print_flags(rwbs, "",			\
+		{ RWBS_FLAG_FLUSH, "F" },	\
 		{ RWBS_FLAG_WRITE, "W" },	\
 		{ RWBS_FLAG_DISCARD, "D" },	\
 		{ RWBS_FLAG_READ, "R" },	\
+		{ RWBS_FLAG_FUA, "F" },		\
 		{ RWBS_FLAG_RAHEAD, "A" },	\
+		{ RWBS_FLAG_BARRIER, "B" },	\
 		{ RWBS_FLAG_SYNC, "S" },	\
 		{ RWBS_FLAG_META, "M" },	\
 		{ RWBS_FLAG_SECURE, "E" })
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,1,0))
+
+#define blk_fill_rwbs(rwbs, rw, bytes)					      \
+		tp_assign(rwbs, ((rw) & WRITE ? RWBS_FLAG_WRITE :	      \
+			( (rw) & REQ_DISCARD ? RWBS_FLAG_DISCARD :	      \
+			( (bytes) ? RWBS_FLAG_READ :			      \
+			( 0 ))))					      \
+			| ((rw) & REQ_RAHEAD ? RWBS_FLAG_RAHEAD : 0)	      \
+			| ((rw) & REQ_SYNC ? RWBS_FLAG_SYNC : 0)	      \
+			| ((rw) & REQ_META ? RWBS_FLAG_META : 0)	      \
+			| ((rw) & REQ_SECURE ? RWBS_FLAG_SECURE : 0)	      \
+			| ((rw) & REQ_FLUSH ? RWBS_FLAG_FLUSH : 0)	      \
+			| ((rw) & REQ_FUA ? RWBS_FLAG_FUA : 0))
+
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+
 #define blk_fill_rwbs(rwbs, rw, bytes)					      \
 		tp_assign(rwbs, ((rw) & WRITE ? RWBS_FLAG_WRITE :	      \
 			( (rw) & REQ_DISCARD ? RWBS_FLAG_DISCARD :	      \
@@ -46,6 +71,33 @@ enum {
 			| ((rw) & REQ_META ? RWBS_FLAG_META : 0)	      \
 			| ((rw) & REQ_SECURE ? RWBS_FLAG_SECURE : 0))
 
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
+
+#define blk_fill_rwbs(rwbs, rw, bytes)					      \
+		tp_assign(rwbs, ((rw) & WRITE ? RWBS_FLAG_WRITE :	      \
+			( (rw) & REQ_DISCARD ? RWBS_FLAG_DISCARD :	      \
+			( (bytes) ? RWBS_FLAG_READ :			      \
+			( 0 ))))					      \
+			| ((rw) & REQ_RAHEAD ? RWBS_FLAG_RAHEAD : 0)	      \
+			| ((rw) & REQ_HARDBARRIER ? RWBS_FLAG_BARRIER : 0)    \
+			| ((rw) & REQ_SYNC ? RWBS_FLAG_SYNC : 0)	      \
+			| ((rw) & REQ_META ? RWBS_FLAG_META : 0)	      \
+			| ((rw) & REQ_SECURE ? RWBS_FLAG_SECURE : 0))
+
+#else
+
+#define blk_fill_rwbs(rwbs, rw, bytes)					      \
+		tp_assign(rwbs, ((rw) & WRITE ? RWBS_FLAG_WRITE :	      \
+			( (rw) & (1 << BIO_RW_DISCARD) ? RWBS_FLAG_DISCARD :  \
+			( (bytes) ? RWBS_FLAG_READ :			      \
+			( 0 ))))					      \
+			| ((rw) & (1 << BIO_RW_AHEAD) ? RWBS_FLAG_RAHEAD : 0) \
+			| ((rw) & (1 << BIO_RW_SYNCIO) ? RWBS_FLAG_SYNC : 0)  \
+			| ((rw) & (1 << BIO_RW_META) ? RWBS_FLAG_META : 0)    \
+			| ((rw) & (1 << BIO_RW_BARRIER) ? RWBS_FLAG_BARRIER : 0))
+
+#endif
+
 DECLARE_EVENT_CLASS(block_rq_with_error,
 
 	TP_PROTO(struct request_queue *q, struct request *rq),
@@ -261,9 +313,15 @@ TRACE_EVENT(block_bio_bounce,
  */
 TRACE_EVENT(block_bio_complete,
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
 	TP_PROTO(struct request_queue *q, struct bio *bio, int error),
 
 	TP_ARGS(q, bio, error),
+#else
+	TP_PROTO(struct request_queue *q, struct bio *bio),
+
+	TP_ARGS(q, bio),
+#endif
 
 	TP_STRUCT__entry(
 		__field( dev_t,		dev		)
@@ -277,7 +335,11 @@ TRACE_EVENT(block_bio_complete,
 		tp_assign(dev, bio->bi_bdev->bd_dev)
 		tp_assign(sector, bio->bi_sector)
 		tp_assign(nr_sector, bio->bi_size >> 9)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
 		tp_assign(error, error)
+#else
+		tp_assign(error, 0)
+#endif
 		blk_fill_rwbs(rwbs, bio->bi_rw, bio->bi_size)
 	),
 
@@ -452,9 +514,15 @@ TRACE_EVENT(block_plug,
 
 DECLARE_EVENT_CLASS(block_unplug,
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 	TP_PROTO(struct request_queue *q, unsigned int depth, bool explicit),
 
 	TP_ARGS(q, depth, explicit),
+#else
+	TP_PROTO(struct request_queue *q),
+
+	TP_ARGS(q),
+#endif
 
 	TP_STRUCT__entry(
 		__field( int,		nr_rq			)
@@ -462,13 +530,33 @@ DECLARE_EVENT_CLASS(block_unplug,
 	),
 
 	TP_fast_assign(
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 		tp_assign(nr_rq, depth)
+#else
+		tp_assign(nr_rq, q->rq.count[READ] + q->rq.count[WRITE])
+#endif
 		tp_memcpy(comm, current->comm, TASK_COMM_LEN)
 	),
 
 	TP_printk("[%s] %d", __entry->comm, __entry->nr_rq)
 )
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39))
+/**
+ * block_unplug_timer - timed release of operations requests in queue to device driver
+ * @q: request queue to unplug
+ *
+ * Unplug the request queue @q because a timer expired and allow block
+ * operation requests to be sent to the device driver.
+ */
+DEFINE_EVENT(block_unplug, block_unplug_timer,
+
+	TP_PROTO(struct request_queue *q),
+
+	TP_ARGS(q)
+)
+#endif
+
 /**
  * block_unplug - release of operations requests in request queue
  * @q: request queue to unplug
@@ -478,11 +566,21 @@ DECLARE_EVENT_CLASS(block_unplug,
  * Unplug request queue @q because device driver is scheduled to work
  * on elements in the request queue.
  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 DEFINE_EVENT(block_unplug, block_unplug,
+#else
+DEFINE_EVENT(block_unplug, block_unplug_io,
+#endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 	TP_PROTO(struct request_queue *q, unsigned int depth, bool explicit),
 
 	TP_ARGS(q, depth, explicit)
+#else
+	TP_PROTO(struct request_queue *q),
+
+	TP_ARGS(q)
+#endif
 )
 
 /**
@@ -537,7 +635,11 @@ TRACE_EVENT(block_split,
  * An operation for a logical device has been mapped to the
  * raw block device.
  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
 TRACE_EVENT(block_bio_remap,
+#else
+TRACE_EVENT(block_remap,
+#endif
 
 	TP_PROTO(struct request_queue *q, struct bio *bio, dev_t dev,
 		 sector_t from),
@@ -571,6 +673,7 @@ TRACE_EVENT(block_bio_remap,
 		  (unsigned long long)__entry->old_sector)
 )
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32))
 /**
  * block_rq_remap - map request for a block operation request
  * @q: queue holding the operation
@@ -615,6 +718,7 @@ TRACE_EVENT(block_rq_remap,
 		  MAJOR(__entry->old_dev), MINOR(__entry->old_dev),
 		  (unsigned long long)__entry->old_sector)
 )
+#endif
 
 #undef __print_rwbs_flags
 #undef blk_fill_rwbs
diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/ext3.h b/drivers/staging/lttng/instrumentation/events/lttng-module/ext3.h
index f1b4aa9..32917fb 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/ext3.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/ext3.h
@@ -5,6 +5,7 @@
 #define _TRACE_EXT3_H
 
 #include <linux/tracepoint.h>
+#include <linux/version.h>
 
 TRACE_EVENT(ext3_free_inode,
 	TP_PROTO(struct inode *inode),
@@ -24,8 +25,13 @@ TRACE_EVENT(ext3_free_inode,
 		tp_assign(dev, inode->i_sb->s_dev)
 		tp_assign(ino, inode->i_ino)
 		tp_assign(mode, inode->i_mode)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0))
+		tp_assign(uid, i_uid_read(inode))
+		tp_assign(gid, i_gid_read(inode))
+#else
 		tp_assign(uid, inode->i_uid)
 		tp_assign(gid, inode->i_gid)
+#endif
 		tp_assign(blocks, inode->i_blocks)
 	),
 
diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/jbd.h b/drivers/staging/lttng/instrumentation/events/lttng-module/jbd.h
index b6bd64a..570bdac 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/jbd.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/jbd.h
@@ -6,6 +6,7 @@
 
 #include <linux/jbd.h>
 #include <linux/tracepoint.h>
+#include <linux/version.h>
 
 TRACE_EVENT(jbd_checkpoint,
 
@@ -217,6 +218,26 @@ TRACE_EVENT(jbd_cleanup_journal_tail,
 		  __entry->block_nr, __entry->freed)
 )
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0))
+TRACE_EVENT(journal_write_superblock,
+	TP_PROTO(journal_t *journal, int write_op),
+
+	TP_ARGS(journal, write_op),
+
+	TP_STRUCT__entry(
+		__field(	dev_t,	dev			)
+		__field(	int,	write_op		)
+	),
+
+	TP_fast_assign(
+		tp_assign(dev, journal->j_fs_dev->bd_dev)
+		tp_assign(write_op, write_op)
+	),
+
+	TP_printk("dev %d,%d write_op %x", MAJOR(__entry->dev),
+		  MINOR(__entry->dev), __entry->write_op)
+)
+#else
 TRACE_EVENT(jbd_update_superblock_end,
 	TP_PROTO(journal_t *journal, int wait),
 
@@ -236,6 +257,7 @@ TRACE_EVENT(jbd_update_superblock_end,
 		  MAJOR(__entry->dev), MINOR(__entry->dev),
 		   __entry->wait)
 )
+#endif
 
 #endif /* _TRACE_JBD_H */
 
diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/jbd2.h b/drivers/staging/lttng/instrumentation/events/lttng-module/jbd2.h
index c7992c0..872cf9e 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/jbd2.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/jbd2.h
@@ -6,12 +6,15 @@
 
 #include <linux/jbd2.h>
 #include <linux/tracepoint.h>
+#include <linux/version.h>
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32))
 #ifndef _TRACE_JBD2_DEF
 #define _TRACE_JBD2_DEF
 struct transaction_chp_stats_s;
 struct transaction_run_stats_s;
 #endif
+#endif
 
 TRACE_EVENT(jbd2_checkpoint,
 
@@ -84,6 +87,15 @@ DEFINE_EVENT(jbd2_commit, jbd2_commit_logging,
 	TP_ARGS(journal, commit_transaction)
 )
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
+DEFINE_EVENT(jbd2_commit, jbd2_drop_transaction,
+
+	TP_PROTO(journal_t *journal, transaction_t *commit_transaction),
+
+	TP_ARGS(journal, commit_transaction)
+)
+#endif
+
 TRACE_EVENT(jbd2_end_commit,
 	TP_PROTO(journal_t *journal, transaction_t *commit_transaction),
 
@@ -128,6 +140,7 @@ TRACE_EVENT(jbd2_submit_inode_data,
 		  (unsigned long) __entry->ino)
 )
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32))
 TRACE_EVENT(jbd2_run_stats,
 	TP_PROTO(dev_t dev, unsigned long tid,
 		 struct transaction_run_stats_s *stats),
@@ -202,8 +215,14 @@ TRACE_EVENT(jbd2_checkpoint_stats,
 		  jiffies_to_msecs(__entry->chp_time),
 		  __entry->forced_to_close, __entry->written, __entry->dropped)
 )
+#endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
+TRACE_EVENT(jbd2_update_log_tail,
+#else
 TRACE_EVENT(jbd2_cleanup_journal_tail,
+#endif
 
 	TP_PROTO(journal_t *journal, tid_t first_tid,
 		 unsigned long block_nr, unsigned long freed),
@@ -231,6 +250,29 @@ TRACE_EVENT(jbd2_cleanup_journal_tail,
 		  __entry->tail_sequence, __entry->first_tid,
 		  __entry->block_nr, __entry->freed)
 )
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
+TRACE_EVENT(jbd2_write_superblock,
+
+	TP_PROTO(journal_t *journal, int write_op),
+
+	TP_ARGS(journal, write_op),
+
+	TP_STRUCT__entry(
+		__field(	dev_t,  dev			)
+		__field(	  int,  write_op		)
+	),
+
+	TP_fast_assign(
+		tp_assign(dev, journal->j_fs_dev->bd_dev)
+		tp_assign(write_op, write_op)
+	),
+
+	TP_printk("dev %d,%d write_op %x", MAJOR(__entry->dev),
+		  MINOR(__entry->dev), __entry->write_op)
+)
+#endif
 
 #endif /* _TRACE_JBD2_H */
 
diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/kmem.h b/drivers/staging/lttng/instrumentation/events/lttng-module/kmem.h
index dab8989..baf4176 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/kmem.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/kmem.h
@@ -4,6 +4,13 @@
 #if !defined(_TRACE_KMEM_H) || defined(TRACE_HEADER_MULTI_READ)
 #define _TRACE_KMEM_H
 
+#include <linux/types.h>
+#include <linux/tracepoint.h>
+#include <linux/version.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
+#include <trace/events/gfpflags.h>
+#endif
+
 DECLARE_EVENT_CLASS(kmem_alloc,
 
 	TP_PROTO(unsigned long call_site,
@@ -143,7 +150,12 @@ DEFINE_EVENT(kmem_free, kmem_cache_free,
 	TP_ARGS(call_site, ptr)
 )
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
+TRACE_EVENT(mm_page_free,
+#else
 TRACE_EVENT(mm_page_free_direct,
+#endif
 
 	TP_PROTO(struct page *page, unsigned int order),
 
@@ -165,7 +177,11 @@ TRACE_EVENT(mm_page_free_direct,
 			__entry->order)
 )
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
+TRACE_EVENT(mm_page_free_batched,
+#else
 TRACE_EVENT(mm_pagevec_free,
+#endif
 
 	TP_PROTO(struct page *page, int cold),
 
@@ -210,7 +226,7 @@ TRACE_EVENT(mm_page_alloc,
 
 	TP_printk("page=%p pfn=%lu order=%d migratetype=%d gfp_flags=%s",
 		__entry->page,
-		page_to_pfn(__entry->page),
+		__entry->page ? page_to_pfn(__entry->page) : 0,
 		__entry->order,
 		__entry->migratetype,
 		show_gfp_flags(__entry->gfp_flags))
@@ -236,7 +252,7 @@ DECLARE_EVENT_CLASS(mm_page,
 
 	TP_printk("page=%p pfn=%lu order=%u migratetype=%d percpu_refill=%d",
 		__entry->page,
-		page_to_pfn(__entry->page),
+		__entry->page ? page_to_pfn(__entry->page) : 0,
 		__entry->order,
 		__entry->migratetype,
 		__entry->order == 0)
@@ -251,7 +267,11 @@ DEFINE_EVENT(mm_page, mm_page_alloc_zone_locked,
 
 DEFINE_EVENT_PRINT(mm_page, mm_page_pcpu_drain,
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
 	TP_PROTO(struct page *page, unsigned int order, int migratetype),
+#else
+	TP_PROTO(struct page *page, int order, int migratetype),
+#endif
 
 	TP_ARGS(page, order, migratetype),
 
@@ -297,6 +317,7 @@ TRACE_EVENT(mm_page_alloc_extfrag,
 		__entry->fallback_order < pageblock_order,
 		__entry->alloc_migratetype == __entry->fallback_migratetype)
 )
+#endif
 
 #endif /* _TRACE_KMEM_H */
 
diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/kvm.h b/drivers/staging/lttng/instrumentation/events/lttng-module/kvm.h
index ffdc2a6..cda3cfc 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/kvm.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/kvm.h
@@ -7,6 +7,8 @@
 #undef TRACE_SYSTEM
 #define TRACE_SYSTEM kvm
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
+
 #define ERSN(x) { KVM_EXIT_##x, "KVM_EXIT_" #x }
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
@@ -50,8 +52,16 @@ TRACE_EVENT(kvm_userspace_exit,
 		  __print_symbolic(__entry->reason, kvm_trace_exit_reason),
 		  __entry->errno < 0 ? -__entry->errno : __entry->reason)
 )
+#endif
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0))
 #if defined(__KVM_HAVE_IOAPIC)
+#undef __KVM_HAVE_IRQ_LINE
+#define __KVM_HAVE_IRQ_LINE
+#endif
+#endif
+
+#if defined(__KVM_HAVE_IRQ_LINE)
 TRACE_EVENT(kvm_set_irq,
 	TP_PROTO(unsigned int gsi, int level, int irq_source_id),
 	TP_ARGS(gsi, level, irq_source_id),
@@ -71,7 +81,9 @@ TRACE_EVENT(kvm_set_irq,
 	TP_printk("gsi %u level %d source %d",
 		  __entry->gsi, __entry->level, __entry->irq_source_id)
 )
+#endif
 
+#if defined(__KVM_HAVE_IOAPIC)
 #define kvm_deliver_mode		\
 	{0x0, "Fixed"},			\
 	{0x1, "LowPrio"},		\
@@ -189,6 +201,8 @@ TRACE_EVENT(kvm_mmio,
 		  __entry->len, __entry->gpa, __entry->val)
 )
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+
 #define kvm_fpu_load_symbol	\
 	{0, "unload"},		\
 	{1, "load"}
@@ -229,6 +243,9 @@ TRACE_EVENT(kvm_age_page,
 		  __entry->hva, __entry->gfn,
 		  __entry->referenced ? "YOUNG" : "OLD")
 )
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
 
 #ifdef CONFIG_KVM_ASYNC_PF
 DECLARE_EVENT_CLASS(kvm_async_get_page_class,
@@ -321,6 +338,8 @@ TRACE_EVENT(
 
 #endif
 
+#endif
+
 #endif /* _TRACE_KVM_MAIN_H */
 
 /* This part must be outside protection */
diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/lock.h b/drivers/staging/lttng/instrumentation/events/lttng-module/lock.h
index e2c1c7a..8c1389d 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/lock.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/lock.h
@@ -1,5 +1,15 @@
+#include <linux/version.h>
+
 #undef TRACE_SYSTEM
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
 #define TRACE_SYSTEM lock
+#else
+#define TRACE_SYSTEM lockdep
+#define TRACE_INCLUDE_FILE lock
+#if defined(_TRACE_LOCKDEP_H)
+#define _TRACE_LOCK_H
+#endif
+#endif
 
 #if !defined(_TRACE_LOCK_H) || defined(TRACE_HEADER_MULTI_READ)
 #define _TRACE_LOCK_H
@@ -20,21 +30,31 @@ TRACE_EVENT(lock_acquire,
 	TP_STRUCT__entry(
 		__field(unsigned int, flags)
 		__string(name, lock->name)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
 		__field(void *, lockdep_addr)
+#endif
 	),
 
 	TP_fast_assign(
 		tp_assign(flags, (trylock ? 1 : 0) | (read ? 2 : 0))
 		tp_strcpy(name, lock->name)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
 		tp_assign(lockdep_addr, lock)
+#endif
 	),
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
 	TP_printk("%p %s%s%s", __entry->lockdep_addr,
+#else
+	TP_printk("%s%s%s",
+#endif
 		  (__entry->flags & 1) ? "try " : "",
 		  (__entry->flags & 2) ? "read " : "",
 		  __get_str(name))
 )
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+
 DECLARE_EVENT_CLASS(lock,
 
 	TP_PROTO(struct lockdep_map *lock, unsigned long ip),
@@ -78,6 +98,107 @@ DEFINE_EVENT(lock, lock_acquired,
 )
 
 #endif
+
+#else /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)) */
+
+TRACE_EVENT(lock_release,
+
+	TP_PROTO(struct lockdep_map *lock, int nested, unsigned long ip),
+
+	TP_ARGS(lock, nested, ip),
+
+	TP_STRUCT__entry(
+		__string(	name, 	lock->name	)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+		__field(	void *, lockdep_addr	)
+#endif
+	),
+
+	TP_fast_assign(
+		tp_strcpy(name, lock->name)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+		tp_assign(lockdep_addr, lock)
+#endif
+	),
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+	TP_printk("%p %s",  __entry->lockdep_addr, __get_str(name))
+#else
+	TP_printk("%s",  __get_str(name))
+#endif
+)
+
+#ifdef CONFIG_LOCK_STAT
+
+TRACE_EVENT(lock_contended,
+
+	TP_PROTO(struct lockdep_map *lock, unsigned long ip),
+
+	TP_ARGS(lock, ip),
+
+	TP_STRUCT__entry(
+		__string(	name, 	lock->name	)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+		__field(	void *, lockdep_addr	)
+#endif
+	),
+
+	TP_fast_assign(
+		tp_strcpy(name, lock->name)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+		tp_assign(lockdep_addr, lock)
+#endif
+	),
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+	TP_printk("%p %s",  __entry->lockdep_addr, __get_str(name))
+#else
+	TP_printk("%s",  __get_str(name))
+#endif
+)
+
+TRACE_EVENT(lock_acquired,
+
+	TP_PROTO(struct lockdep_map *lock, unsigned long ip, s64 waittime),
+
+	TP_ARGS(lock, ip, waittime),
+
+	TP_STRUCT__entry(
+		__string(	name, 	lock->name	)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+		__field(	s64,    wait_nsec	)
+		__field(	void *, lockdep_addr	)
+#else
+		__field(unsigned long, wait_usec)
+		__field(unsigned long, wait_nsec_rem)
+#endif
+	),
+
+	TP_fast_assign(
+		tp_strcpy(name, lock->name)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+		tp_assign(wait_nsec, waittime)
+		tp_assign(lockdep_addr, lock)
+#else
+		tp_assign(wait_usec, (unsigned long)waittime)
+		tp_assign(wait_nsec_rem, do_div(waittime, NSEC_PER_USEC))
+#endif
+	),
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+	TP_printk("%p %s (%llu ns)",  __entry->lockdep_addr,
+		  __get_str(name), __entry->wait_nsec)
+#else
+	TP_printk("%s (%lu.%03lu us)",
+		  __get_str(name),
+		  __entry->wait_usec, __entry->wait_nsec_rem)
+#endif
+)
+
+#endif
+
+#endif /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)) */
+
 #endif
 
 #endif /* _TRACE_LOCK_H */
diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/module.h b/drivers/staging/lttng/instrumentation/events/lttng-module/module.h
index 65a8135..c63f866 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/module.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/module.h
@@ -15,6 +15,7 @@
 #define _TRACE_MODULE_H
 
 #include <linux/tracepoint.h>
+#include <linux/version.h>
 
 #ifdef CONFIG_MODULES
 
@@ -69,9 +70,15 @@ TRACE_EVENT(module_free,
 
 DECLARE_EVENT_CLASS(module_refcnt,
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	TP_PROTO(struct module *mod, unsigned long ip),
 
 	TP_ARGS(mod, ip),
+#else
+	TP_PROTO(struct module *mod, unsigned long ip, int refcnt),
+
+	TP_ARGS(mod, ip, refcnt),
+#endif
 
 	TP_STRUCT__entry(
 		__field(	unsigned long,	ip		)
@@ -81,7 +88,11 @@ DECLARE_EVENT_CLASS(module_refcnt,
 
 	TP_fast_assign(
 		tp_assign(ip, ip)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 		tp_assign(refcnt, __this_cpu_read(mod->refptr->incs) + __this_cpu_read(mod->refptr->decs))
+#else
+		tp_assign(refcnt, refcnt)
+#endif
 		tp_strcpy(name, mod->name)
 	),
 
@@ -91,16 +102,28 @@ DECLARE_EVENT_CLASS(module_refcnt,
 
 DEFINE_EVENT(module_refcnt, module_get,
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	TP_PROTO(struct module *mod, unsigned long ip),
 
 	TP_ARGS(mod, ip)
+#else
+	TP_PROTO(struct module *mod, unsigned long ip, int refcnt),
+
+	TP_ARGS(mod, ip, refcnt)
+#endif
 )
 
 DEFINE_EVENT(module_refcnt, module_put,
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	TP_PROTO(struct module *mod, unsigned long ip),
 
 	TP_ARGS(mod, ip)
+#else
+	TP_PROTO(struct module *mod, unsigned long ip, int refcnt),
+
+	TP_ARGS(mod, ip, refcnt)
+#endif
 )
 #endif /* CONFIG_MODULE_UNLOAD */
 
diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/power.h b/drivers/staging/lttng/instrumentation/events/lttng-module/power.h
index f2e3f54..7eeb87c 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/power.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/power.h
@@ -6,7 +6,9 @@
 
 #include <linux/ktime.h>
 #include <linux/tracepoint.h>
+#include <linux/version.h>
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
 DECLARE_EVENT_CLASS(cpu,
 
 	TP_PROTO(unsigned int state, unsigned int cpu_id),
@@ -64,8 +66,50 @@ TRACE_EVENT(machine_suspend,
 
 	TP_printk("state=%lu", (unsigned long)__entry->state)
 )
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0))
+DECLARE_EVENT_CLASS(wakeup_source,
+
+	TP_PROTO(const char *name, unsigned int state),
+
+	TP_ARGS(name, state),
+
+	TP_STRUCT__entry(
+		__string(       name,           name            )
+		__field(        u64,            state           )
+	),
+
+	TP_fast_assign(
+		tp_strcpy(name, name)
+		tp_assign(state, state)
+	),
+
+	TP_printk("%s state=0x%lx", __get_str(name),
+		(unsigned long)__entry->state)
+)
+
+DEFINE_EVENT(wakeup_source, wakeup_source_activate,
+
+	TP_PROTO(const char *name, unsigned int state),
+
+	TP_ARGS(name, state)
+)
+
+DEFINE_EVENT(wakeup_source, wakeup_source_deactivate,
+
+	TP_PROTO(const char *name, unsigned int state),
+
+	TP_ARGS(name, state)
+)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38))
+#undef CONFIG_EVENT_POWER_TRACING_DEPRECATED
+#define CONFIG_EVENT_POWER_TRACING_DEPRECATED
+#define _PWR_EVENT_AVOID_DOUBLE_DEFINING_DEPRECATED
+#endif
 
-/* This code will be removed after deprecation time exceeded (2.6.41) */
 #ifdef CONFIG_EVENT_POWER_TRACING_DEPRECATED
 
 /*
@@ -74,56 +118,100 @@ TRACE_EVENT(machine_suspend,
  */
 DECLARE_EVENT_CLASS(power,
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	TP_PROTO(unsigned int type, unsigned int state, unsigned int cpu_id),
 
 	TP_ARGS(type, state, cpu_id),
+#else
+	TP_PROTO(unsigned int type, unsigned int state),
+
+	TP_ARGS(type, state),
+#endif
 
 	TP_STRUCT__entry(
 		__field(	u64,		type		)
 		__field(	u64,		state		)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 		__field(	u64,		cpu_id		)
+#endif
 	),
 
 	TP_fast_assign(
 		tp_assign(type, type)
 		tp_assign(state, state)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 		tp_assign(cpu_id, cpu_id)
+#endif
 	),
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	TP_printk("type=%lu state=%lu cpu_id=%lu", (unsigned long)__entry->type,
 		(unsigned long)__entry->state, (unsigned long)__entry->cpu_id)
+#else
+	TP_printk("type=%lu state=%lu", (unsigned long)__entry->type,
+		(unsigned long)__entry->state)
+#endif
 )
 
 DEFINE_EVENT(power, power_start,
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	TP_PROTO(unsigned int type, unsigned int state, unsigned int cpu_id),
 
 	TP_ARGS(type, state, cpu_id)
+#else
+	TP_PROTO(unsigned int type, unsigned int state),
+
+	TP_ARGS(type, state)
+#endif
 )
 
 DEFINE_EVENT(power, power_frequency,
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	TP_PROTO(unsigned int type, unsigned int state, unsigned int cpu_id),
 
 	TP_ARGS(type, state, cpu_id)
+#else
+	TP_PROTO(unsigned int type, unsigned int state),
+
+	TP_ARGS(type, state)
+#endif
 )
 
 TRACE_EVENT(power_end,
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	TP_PROTO(unsigned int cpu_id),
 
 	TP_ARGS(cpu_id),
+#else
+	TP_PROTO(int dummy),
+
+	TP_ARGS(dummy),
+#endif
 
 	TP_STRUCT__entry(
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 		__field(	u64,		cpu_id		)
+#else
+		__field(	u64,		dummy		)
+#endif
 	),
 
 	TP_fast_assign(
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 		tp_assign(cpu_id, cpu_id)
+#else
+		tp_assign(dummy, 0xffff)
+#endif
 	),
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	TP_printk("cpu_id=%lu", (unsigned long)__entry->cpu_id)
-
+#else
+	TP_printk("dummy=%lu", (unsigned long)__entry->dummy)
+#endif
 )
 
 /* Deprecated dummy functions must be protected against multi-declartion */
@@ -151,11 +239,16 @@ enum {
    events get removed */
 static inline void trace_power_start(u64 type, u64 state, u64 cpuid) {};
 static inline void trace_power_end(u64 cpuid) {};
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
+static inline void trace_power_start_rcuidle(u64 type, u64 state, u64 cpuid) {};
+static inline void trace_power_end_rcuidle(u64 cpuid) {};
+#endif
 static inline void trace_power_frequency(u64 type, u64 state, u64 cpuid) {};
 #endif /* _PWR_EVENT_AVOID_DOUBLE_DEFINING_DEPRECATED */
 
 #endif /* CONFIG_EVENT_POWER_TRACING_DEPRECATED */
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
 /*
  * The clock events are used for clock enable/disable and for
  *  clock rate change
@@ -234,6 +327,8 @@ DEFINE_EVENT(power_domain, power_domain_target,
 
 	TP_ARGS(name, state, cpu_id)
 )
+#endif
+
 #endif /* _TRACE_POWER_H */
 
 /* This part must be outside protection */
diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/sched.h b/drivers/staging/lttng/instrumentation/events/lttng-module/sched.h
index 005f3d1..4d30fe3 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/sched.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/sched.h
@@ -6,10 +6,14 @@
 
 #include <linux/sched.h>
 #include <linux/tracepoint.h>
+#include <linux/binfmts.h>
+#include <linux/version.h>
 
 #ifndef _TRACE_SCHED_DEF_
 #define _TRACE_SCHED_DEF_
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+
 static inline long __trace_sched_switch_state(struct task_struct *p)
 {
 	long state = p->state;
@@ -19,12 +23,18 @@ static inline long __trace_sched_switch_state(struct task_struct *p)
 	 * For all intents and purposes a preempted task is a running task.
 	 */
 	if (task_thread_info(p)->preempt_count & PREEMPT_ACTIVE)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
+		state = TASK_RUNNING | TASK_STATE_MAX;
+#else
 		state = TASK_RUNNING;
 #endif
+#endif
 
 	return state;
 }
 
+#endif
+
 #endif /* _TRACE_SCHED_DEF_ */
 
 /*
@@ -89,7 +99,9 @@ DECLARE_EVENT_CLASS(sched_wakeup_template,
 		__field(	pid_t,	tid			)
 		__field(	int,	prio			)
 		__field(	int,	success			)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32))
 		__field(	int,	target_cpu		)
+#endif
 	),
 
 	TP_fast_assign(
@@ -97,12 +109,25 @@ DECLARE_EVENT_CLASS(sched_wakeup_template,
 		tp_assign(tid, p->pid)
 		tp_assign(prio, p->prio)
 		tp_assign(success, success)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32))
 		tp_assign(target_cpu, task_cpu(p))
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	)
+	TP_perf_assign(
+		__perf_task(p)
+#endif
 	),
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32))
 	TP_printk("comm=%s tid=%d prio=%d success=%d target_cpu=%03d",
 		  __entry->comm, __entry->tid, __entry->prio,
 		  __entry->success, __entry->target_cpu)
+#else
+	TP_printk("comm=%s tid=%d prio=%d success=%d",
+		  __entry->comm, __entry->tid, __entry->prio,
+		  __entry->success)
+#endif
 )
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
@@ -164,12 +189,27 @@ TRACE_EVENT(sched_switch,
 		tp_memcpy(next_comm, next->comm, TASK_COMM_LEN)
 		tp_assign(prev_tid, prev->pid)
 		tp_assign(prev_prio, prev->prio - MAX_RT_PRIO)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 		tp_assign(prev_state, __trace_sched_switch_state(prev))
+#else
+		tp_assign(prev_state, prev->state)
+#endif
 		tp_memcpy(prev_comm, prev->comm, TASK_COMM_LEN)
 		tp_assign(next_tid, next->pid)
 		tp_assign(next_prio, next->prio - MAX_RT_PRIO)
 	),
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
+	TP_printk("prev_comm=%s prev_tid=%d prev_prio=%d prev_state=%s%s ==> next_comm=%s next_tid=%d next_prio=%d",
+		__entry->prev_comm, __entry->prev_tid, __entry->prev_prio,
+		__entry->prev_state & (TASK_STATE_MAX-1) ?
+		  __print_flags(__entry->prev_state & (TASK_STATE_MAX-1), "|",
+				{ 1, "S"} , { 2, "D" }, { 4, "T" }, { 8, "t" },
+				{ 16, "Z" }, { 32, "X" }, { 64, "x" },
+				{ 128, "W" }) : "R",
+		__entry->prev_state & TASK_STATE_MAX ? "+" : "",
+		__entry->next_comm, __entry->next_tid, __entry->next_prio)
+#else
 	TP_printk("prev_comm=%s prev_tid=%d prev_prio=%d prev_state=%s ==> next_comm=%s next_tid=%d next_prio=%d",
 		__entry->prev_comm, __entry->prev_tid, __entry->prev_prio,
 		__entry->prev_state ?
@@ -178,6 +218,7 @@ TRACE_EVENT(sched_switch,
 				{ 16, "Z" }, { 32, "X" }, { 64, "x" },
 				{ 128, "W" }) : "R",
 		__entry->next_comm, __entry->next_tid, __entry->next_prio)
+#endif
 )
 
 /*
@@ -313,6 +354,33 @@ TRACE_EVENT(sched_process_fork,
 		__entry->child_comm, __entry->child_tid)
 )
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33))
+/*
+ * Tracepoint for sending a signal:
+ */
+TRACE_EVENT(sched_signal_send,
+
+	TP_PROTO(int sig, struct task_struct *p),
+
+	TP_ARGS(sig, p),
+
+	TP_STRUCT__entry(
+		__field(	int,	sig			)
+		__array(	char,	comm,	TASK_COMM_LEN	)
+		__field(	pid_t,	pid			)
+	),
+
+	TP_fast_assign(
+		tp_memcpy(comm, p->comm, TASK_COMM_LEN)
+		tp_assign(pid, p->pid)
+		tp_assign(sig, sig)
+	),
+
+	TP_printk("sig=%d comm=%s pid=%d",
+		__entry->sig, __entry->comm, __entry->pid)
+)
+#endif
+
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
 /*
  * Tracepoint for exec:
@@ -341,6 +409,7 @@ TRACE_EVENT(sched_process_exec,
 )
 #endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32))
 /*
  * XXX the below sched_stat tracepoints only apply to SCHED_OTHER/BATCH/IDLE
  *     adding sched_stat support to SCHED_FIFO/RR would be welcome.
@@ -396,6 +465,15 @@ DEFINE_EVENT(sched_stat_template, sched_stat_iowait,
 	     TP_PROTO(struct task_struct *tsk, u64 delay),
 	     TP_ARGS(tsk, delay))
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
+/*
+ * Tracepoint for accounting blocked time (time the task is in uninterruptible).
+ */
+DEFINE_EVENT(sched_stat_template, sched_stat_blocked,
+	     TP_PROTO(struct task_struct *tsk, u64 delay),
+	     TP_ARGS(tsk, delay))
+#endif
+
 /*
  * Tracepoint for accounting runtime (time the task is executing
  * on a CPU).
@@ -421,6 +499,9 @@ TRACE_EVENT(sched_stat_runtime,
 	)
 	TP_perf_assign(
 		__perf_count(runtime)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+		__perf_task(tsk)
+#endif
 	),
 
 	TP_printk("comm=%s tid=%d runtime=%Lu [ns] vruntime=%Lu [ns]",
@@ -428,7 +509,9 @@ TRACE_EVENT(sched_stat_runtime,
 			(unsigned long long)__entry->runtime,
 			(unsigned long long)__entry->vruntime)
 )
+#endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
 /*
  * Tracepoint for showing priority inheritance modifying a tasks
  * priority.
@@ -457,6 +540,7 @@ TRACE_EVENT(sched_pi_setprio,
 			__entry->comm, __entry->tid,
 			__entry->oldprio, __entry->newprio)
 )
+#endif
 
 #endif /* _TRACE_SCHED_H */
 
diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/scsi.h b/drivers/staging/lttng/instrumentation/events/lttng-module/scsi.h
index 18d2b02..15f0c70 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/scsi.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/scsi.h
@@ -8,6 +8,7 @@
 #include <scsi/scsi_host.h>
 #include <linux/tracepoint.h>
 #include <linux/trace_seq.h>
+#include <linux/version.h>
 
 #ifndef _TRACE_SCSI_DEF
 #define _TRACE_SCSI_DEF
@@ -187,6 +188,7 @@
 		scsi_statusbyte_name(SAM_STAT_ACA_ACTIVE),	\
 		scsi_statusbyte_name(SAM_STAT_TASK_ABORTED))
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 #define scsi_prot_op_name(result)	{ result, #result }
 #define show_prot_op_name(val)					\
 	__print_symbolic(val,					\
@@ -197,6 +199,7 @@
 		scsi_prot_op_name(SCSI_PROT_WRITE_INSERT),	\
 		scsi_prot_op_name(SCSI_PROT_READ_PASS),		\
 		scsi_prot_op_name(SCSI_PROT_WRITE_PASS))
+#endif
 
 const char *scsi_trace_parse_cdb(struct trace_seq*, unsigned char*, int);
 #define __parse_cdb(cdb, len) scsi_trace_parse_cdb(p, cdb, len)
@@ -217,7 +220,9 @@ TRACE_EVENT(scsi_dispatch_cmd_start,
 		__field( unsigned int,	cmd_len )
 		__field( unsigned int,	data_sglen )
 		__field( unsigned int,	prot_sglen )
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 		__field( unsigned char,	prot_op )
+#endif
 		__dynamic_array_hex(unsigned char,	cmnd, cmd->cmd_len)
 	),
 
@@ -230,15 +235,24 @@ TRACE_EVENT(scsi_dispatch_cmd_start,
 		tp_assign(cmd_len, cmd->cmd_len)
 		tp_assign(data_sglen, scsi_sg_count(cmd))
 		tp_assign(prot_sglen, scsi_prot_sg_count(cmd))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 		tp_assign(prot_op, scsi_get_prot_op(cmd))
+#endif
 		tp_memcpy_dyn(cmnd, cmd->cmnd)
 	),
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 	TP_printk("host_no=%u channel=%u id=%u lun=%u data_sgl=%u prot_sgl=%u" \
 		  " prot_op=%s cmnd=(%s %s raw=%s)",
+#else
+	TP_printk("host_no=%u channel=%u id=%u lun=%u data_sgl=%u prot_sgl=%u" \
+		  " cmnd=(%s %s raw=%s)",
+#endif
 		  __entry->host_no, __entry->channel, __entry->id,
 		  __entry->lun, __entry->data_sglen, __entry->prot_sglen,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 		  show_prot_op_name(__entry->prot_op),
+#endif
 		  show_opcode_name(__entry->opcode),
 		  __parse_cdb(__get_dynamic_array(cmnd), __entry->cmd_len),
 		  __print_hex(__get_dynamic_array(cmnd), __entry->cmd_len))
@@ -260,7 +274,9 @@ TRACE_EVENT(scsi_dispatch_cmd_error,
 		__field( unsigned int,	cmd_len )
 		__field( unsigned int,	data_sglen )
 		__field( unsigned int,	prot_sglen )
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 		__field( unsigned char,	prot_op )
+#endif
 		__dynamic_array_hex(unsigned char,	cmnd, cmd->cmd_len)
 	),
 
@@ -274,15 +290,24 @@ TRACE_EVENT(scsi_dispatch_cmd_error,
 		tp_assign(cmd_len, cmd->cmd_len)
 		tp_assign(data_sglen, scsi_sg_count(cmd))
 		tp_assign(prot_sglen, scsi_prot_sg_count(cmd))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 		tp_assign(prot_op, scsi_get_prot_op(cmd))
+#endif
 		tp_memcpy_dyn(cmnd, cmd->cmnd)
 	),
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 	TP_printk("host_no=%u channel=%u id=%u lun=%u data_sgl=%u prot_sgl=%u" \
 		  " prot_op=%s cmnd=(%s %s raw=%s) rtn=%d",
+#else
+	TP_printk("host_no=%u channel=%u id=%u lun=%u data_sgl=%u prot_sgl=%u" \
+		  " cmnd=(%s %s raw=%s) rtn=%d",
+#endif
 		  __entry->host_no, __entry->channel, __entry->id,
 		  __entry->lun, __entry->data_sglen, __entry->prot_sglen,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 		  show_prot_op_name(__entry->prot_op),
+#endif
 		  show_opcode_name(__entry->opcode),
 		  __parse_cdb(__get_dynamic_array(cmnd), __entry->cmd_len),
 		  __print_hex(__get_dynamic_array(cmnd), __entry->cmd_len),
@@ -305,7 +330,9 @@ DECLARE_EVENT_CLASS(scsi_cmd_done_timeout_template,
 		__field( unsigned int,	cmd_len )
 		__field( unsigned int,	data_sglen )
 		__field( unsigned int,	prot_sglen )
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 		__field( unsigned char,	prot_op )
+#endif
 		__dynamic_array_hex(unsigned char,	cmnd, cmd->cmd_len)
 	),
 
@@ -319,16 +346,26 @@ DECLARE_EVENT_CLASS(scsi_cmd_done_timeout_template,
 		tp_assign(cmd_len, cmd->cmd_len)
 		tp_assign(data_sglen, scsi_sg_count(cmd))
 		tp_assign(prot_sglen, scsi_prot_sg_count(cmd))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 		tp_assign(prot_op, scsi_get_prot_op(cmd))
+#endif
 		tp_memcpy_dyn(cmnd, cmd->cmnd)
 	),
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 	TP_printk("host_no=%u channel=%u id=%u lun=%u data_sgl=%u " \
 		  "prot_sgl=%u prot_op=%s cmnd=(%s %s raw=%s) result=(driver=" \
 		  "%s host=%s message=%s status=%s)",
+#else
+	TP_printk("host_no=%u channel=%u id=%u lun=%u data_sgl=%u " \
+		  "prot_sgl=%u cmnd=(%s %s raw=%s) result=(driver=%s host=%s " \
+		  "message=%s status=%s)",
+#endif
 		  __entry->host_no, __entry->channel, __entry->id,
 		  __entry->lun, __entry->data_sglen, __entry->prot_sglen,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 		  show_prot_op_name(__entry->prot_op),
+#endif
 		  show_opcode_name(__entry->opcode),
 		  __parse_cdb(__get_dynamic_array(cmnd), __entry->cmd_len),
 		  __print_hex(__get_dynamic_array(cmnd), __entry->cmd_len),
diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/signal.h b/drivers/staging/lttng/instrumentation/events/lttng-module/signal.h
index 945747f..a1c904b 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/signal.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/signal.h
@@ -135,6 +135,7 @@ TRACE_EVENT(signal_deliver,
 		  __entry->sa_handler, __entry->sa_flags)
 )
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0))
 DECLARE_EVENT_CLASS(signal_queue_overflow,
 
 	TP_PROTO(int sig, int group, struct siginfo *info),
@@ -193,6 +194,7 @@ DEFINE_EVENT(signal_queue_overflow, signal_lose_info,
 
 	TP_ARGS(sig, group, info)
 )
+#endif
 
 #endif /* _TRACE_SIGNAL_H */
 
diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/skb.h b/drivers/staging/lttng/instrumentation/events/lttng-module/skb.h
index 3163356..c8a6160 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/skb.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/skb.h
@@ -7,6 +7,7 @@
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
 #include <linux/tracepoint.h>
+#include <linux/version.h>
 
 /*
  * Tracepoint for free an sk_buff:
@@ -33,6 +34,7 @@ TRACE_EVENT(kfree_skb,
 		__entry->skbaddr, __entry->protocol, __entry->location)
 )
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
 TRACE_EVENT(consume_skb,
 
 	TP_PROTO(struct sk_buff *skb),
@@ -49,7 +51,9 @@ TRACE_EVENT(consume_skb,
 
 	TP_printk("skbaddr=%p", __entry->skbaddr)
 )
+#endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32))
 TRACE_EVENT(skb_copy_datagram_iovec,
 
 	TP_PROTO(const struct sk_buff *skb, int len),
@@ -68,6 +72,7 @@ TRACE_EVENT(skb_copy_datagram_iovec,
 
 	TP_printk("skbaddr=%p len=%d", __entry->skbaddr, __entry->len)
 )
+#endif
 
 #endif /* _TRACE_SKB_H */
 
diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/vmscan.h b/drivers/staging/lttng/instrumentation/events/lttng-module/vmscan.h
index d6ab952..c137310 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/vmscan.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/vmscan.h
@@ -4,6 +4,47 @@
 #if !defined(_TRACE_VMSCAN_H) || defined(TRACE_HEADER_MULTI_READ)
 #define _TRACE_VMSCAN_H
 
+#include <linux/types.h>
+#include <linux/tracepoint.h>
+#include <linux/mm.h>
+#include <linux/memcontrol.h>
+#include <trace/events/gfpflags.h>
+#include <linux/version.h>
+
+#ifndef _TRACE_VMSCAN_DEF
+#define _TRACE_VMSCAN_DEF
+#define RECLAIM_WB_ANON		0x0001u
+#define RECLAIM_WB_FILE		0x0002u
+#define RECLAIM_WB_MIXED	0x0010u
+#define RECLAIM_WB_SYNC		0x0004u /* Unused, all reclaim async */
+#define RECLAIM_WB_ASYNC	0x0008u
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+#define show_reclaim_flags(flags)				\
+	(flags) ? __print_flags(flags, "|",			\
+		{RECLAIM_WB_ANON,	"RECLAIM_WB_ANON"},	\
+		{RECLAIM_WB_FILE,	"RECLAIM_WB_FILE"},	\
+		{RECLAIM_WB_MIXED,	"RECLAIM_WB_MIXED"},	\
+		{RECLAIM_WB_SYNC,	"RECLAIM_WB_SYNC"},	\
+		{RECLAIM_WB_ASYNC,	"RECLAIM_WB_ASYNC"}	\
+		) : "RECLAIM_WB_NONE"
+#else
+#define show_reclaim_flags(flags)				\
+	(flags) ? __print_flags(flags, "|",			\
+		{RECLAIM_WB_ANON,	"RECLAIM_WB_ANON"},	\
+		{RECLAIM_WB_FILE,	"RECLAIM_WB_FILE"},	\
+		{RECLAIM_WB_SYNC,	"RECLAIM_WB_SYNC"},	\
+		{RECLAIM_WB_ASYNC,	"RECLAIM_WB_ASYNC"}	\
+		) : "RECLAIM_WB_NONE"
+#endif
+
+#if ((LINUX_VERSION_CODE <= KERNEL_VERSION(3,0,38)) || \
+	LTTNG_KERNEL_RANGE(3,1,0, 3,2,0))
+typedef int isolate_mode_t;
+#endif
+
+#endif
+
 TRACE_EVENT(mm_vmscan_kswapd_sleep,
 
 	TP_PROTO(int nid),
@@ -147,6 +188,7 @@ DEFINE_EVENT(mm_vmscan_direct_reclaim_end_template, mm_vmscan_memcg_softlimit_re
 	TP_ARGS(nr_reclaimed)
 )
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,1,0))
 TRACE_EVENT(mm_shrink_slab_start,
 	TP_PROTO(struct shrinker *shr, struct shrink_control *sc,
 		long nr_objects_to_shrink, unsigned long pgs_scanned,
@@ -224,6 +266,7 @@ TRACE_EVENT(mm_shrink_slab_end,
 		__entry->total_scan,
 		__entry->retval)
 )
+#endif
 
 DECLARE_EVENT_CLASS(mm_vmscan_lru_isolate_template,
 
@@ -231,30 +274,41 @@ DECLARE_EVENT_CLASS(mm_vmscan_lru_isolate_template,
 		unsigned long nr_requested,
 		unsigned long nr_scanned,
 		unsigned long nr_taken,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0))
 		unsigned long nr_lumpy_taken,
 		unsigned long nr_lumpy_dirty,
 		unsigned long nr_lumpy_failed,
+#endif
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0))
-		isolate_mode_t isolate_mode),
+		isolate_mode_t isolate_mode
 #else
 		isolate_mode_t isolate_mode,
-		int file),
+		int file
 #endif
+	),
 
+	TP_ARGS(order, nr_requested, nr_scanned, nr_taken,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0))
+		nr_lumpy_taken, nr_lumpy_dirty, nr_lumpy_failed,
+#endif
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0))
-	TP_ARGS(order, nr_requested, nr_scanned, nr_taken, nr_lumpy_taken, nr_lumpy_dirty, nr_lumpy_failed, isolate_mode),
+		isolate_mode
 #else
-	TP_ARGS(order, nr_requested, nr_scanned, nr_taken, nr_lumpy_taken, nr_lumpy_dirty, nr_lumpy_failed, isolate_mode, file),
+		isolate_mode, file
 #endif
+	),
+
 
 	TP_STRUCT__entry(
 		__field(int, order)
 		__field(unsigned long, nr_requested)
 		__field(unsigned long, nr_scanned)
 		__field(unsigned long, nr_taken)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0))
 		__field(unsigned long, nr_lumpy_taken)
 		__field(unsigned long, nr_lumpy_dirty)
 		__field(unsigned long, nr_lumpy_failed)
+#endif
 		__field(isolate_mode_t, isolate_mode)
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
 		__field(int, file)
@@ -266,9 +320,11 @@ DECLARE_EVENT_CLASS(mm_vmscan_lru_isolate_template,
 		tp_assign(nr_requested, nr_requested)
 		tp_assign(nr_scanned, nr_scanned)
 		tp_assign(nr_taken, nr_taken)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0))
 		tp_assign(nr_lumpy_taken, nr_lumpy_taken)
 		tp_assign(nr_lumpy_dirty, nr_lumpy_dirty)
 		tp_assign(nr_lumpy_failed, nr_lumpy_failed)
+#endif
 		tp_assign(isolate_mode, isolate_mode)
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
 		tp_assign(file, file)
@@ -277,9 +333,6 @@ DECLARE_EVENT_CLASS(mm_vmscan_lru_isolate_template,
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0))
 	TP_printk("isolate_mode=%d order=%d nr_requested=%lu nr_scanned=%lu nr_taken=%lu contig_taken=%lu contig_dirty=%lu contig_failed=%lu",
-#else
-	TP_printk("isolate_mode=%d order=%d nr_requested=%lu nr_scanned=%lu nr_taken=%lu contig_taken=%lu contig_dirty=%lu contig_failed=%lu file=%d",
-#endif
 		__entry->isolate_mode,
 		__entry->order,
 		__entry->nr_requested,
@@ -287,11 +340,26 @@ DECLARE_EVENT_CLASS(mm_vmscan_lru_isolate_template,
 		__entry->nr_taken,
 		__entry->nr_lumpy_taken,
 		__entry->nr_lumpy_dirty,
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0))
 		__entry->nr_lumpy_failed)
-#else
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0))
+	TP_printk("isolate_mode=%d order=%d nr_requested=%lu nr_scanned=%lu nr_taken=%lu contig_taken=%lu contig_dirty=%lu contig_failed=%lu file=%d",
+		__entry->isolate_mode,
+		__entry->order,
+		__entry->nr_requested,
+		__entry->nr_scanned,
+		__entry->nr_taken,
+		__entry->nr_lumpy_taken,
+		__entry->nr_lumpy_dirty,
 		__entry->nr_lumpy_failed,
 		__entry->file)
+#else
+	TP_printk("isolate_mode=%d order=%d nr_requested=%lu nr_scanned=%lu nr_taken=%lu file=%d",
+		__entry->isolate_mode,
+		__entry->order,
+		__entry->nr_requested,
+		__entry->nr_scanned,
+		__entry->nr_taken,
+		__entry->file)
 #endif
 )
 
@@ -307,19 +375,23 @@ DEFINE_EVENT(mm_vmscan_lru_isolate_template, mm_vmscan_lru_isolate,
 		unsigned long nr_lumpy_failed,
 #endif
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0))
-		isolate_mode_t isolate_mode),
+		isolate_mode_t isolate_mode
 #else
 		isolate_mode_t isolate_mode,
-		int file),
+		int file
 #endif
+	),
 
+	TP_ARGS(order, nr_requested, nr_scanned, nr_taken,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0))
+		nr_lumpy_taken, nr_lumpy_dirty, nr_lumpy_failed,
+#endif
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0))
-	TP_ARGS(order, nr_requested, nr_scanned, nr_taken, nr_lumpy_taken, nr_lumpy_dirty, nr_lumpy_failed, isolate_mode)
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0))
-	TP_ARGS(order, nr_requested, nr_scanned, nr_taken, nr_lumpy_taken, nr_lumpy_dirty, nr_lumpy_failed, isolate_mode, file)
+		isolate_mode
 #else
-	TP_ARGS(order, nr_requested, nr_scanned, nr_taken, isolate_mode, file)
+		isolate_mode, file
 #endif
+	)
 
 )
 
@@ -335,20 +407,23 @@ DEFINE_EVENT(mm_vmscan_lru_isolate_template, mm_vmscan_memcg_isolate,
 		unsigned long nr_lumpy_failed,
 #endif
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0))
-		isolate_mode_t isolate_mode),
+		isolate_mode_t isolate_mode
 #else
 		isolate_mode_t isolate_mode,
-		int file),
+		int file
 #endif
+	),
 
+	TP_ARGS(order, nr_requested, nr_scanned, nr_taken,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0))
+		nr_lumpy_taken, nr_lumpy_dirty, nr_lumpy_failed,
+#endif
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0))
-	TP_ARGS(order, nr_requested, nr_scanned, nr_taken, nr_lumpy_taken, nr_lumpy_dirty, nr_lumpy_failed, isolate_mode)
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0))
-	TP_ARGS(order, nr_requested, nr_scanned, nr_taken, nr_lumpy_taken, nr_lumpy_dirty, nr_lumpy_failed, isolate_mode, file)
+		isolate_mode
 #else
-	TP_ARGS(order, nr_requested, nr_scanned, nr_taken, isolate_mode, file)
+		isolate_mode, file
 #endif
-
+	)
 )
 
 TRACE_EVENT(mm_vmscan_writepage,
@@ -374,6 +449,7 @@ TRACE_EVENT(mm_vmscan_writepage,
 		show_reclaim_flags(__entry->reclaim_flags))
 )
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
 TRACE_EVENT(mm_vmscan_lru_shrink_inactive,
 
 	TP_PROTO(int nid, int zid,
@@ -406,9 +482,9 @@ TRACE_EVENT(mm_vmscan_lru_shrink_inactive,
 		__entry->priority,
 		show_reclaim_flags(__entry->reclaim_flags))
 )
+#endif
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0))
-
 TRACE_EVENT(replace_swap_token,
 	TP_PROTO(struct mm_struct *old_mm,
 		 struct mm_struct *new_mm),
@@ -490,7 +566,6 @@ TRACE_EVENT_CONDITION(update_swap_token_priority,
 		  __entry->mm, __entry->old_prio, __entry->new_prio,
 		  __entry->swap_token_mm, __entry->swap_token_prio)
 )
-
 #endif
 
 #endif /* _TRACE_VMSCAN_H */
diff --git a/drivers/staging/lttng/instrumentation/events/mainline/asoc.h b/drivers/staging/lttng/instrumentation/events/mainline/asoc.h
index ab26f8a..5fc2dcd 100644
--- a/drivers/staging/lttng/instrumentation/events/mainline/asoc.h
+++ b/drivers/staging/lttng/instrumentation/events/mainline/asoc.h
@@ -7,6 +7,8 @@
 #include <linux/ktime.h>
 #include <linux/tracepoint.h>
 
+#define DAPM_DIRECT "(direct)"
+
 struct snd_soc_jack;
 struct snd_soc_codec;
 struct snd_soc_platform;
@@ -241,6 +243,84 @@ TRACE_EVENT(snd_soc_dapm_walk_done,
 		  (int)__entry->path_checks, (int)__entry->neighbour_checks)
 );
 
+TRACE_EVENT(snd_soc_dapm_output_path,
+
+	TP_PROTO(struct snd_soc_dapm_widget *widget,
+		struct snd_soc_dapm_path *path),
+
+	TP_ARGS(widget, path),
+
+	TP_STRUCT__entry(
+		__string(	wname,	widget->name		)
+		__string(	pname,	path->name ? path->name : DAPM_DIRECT)
+		__string(	psname,	path->sink->name	)
+		__field(	int,	path_sink		)
+		__field(	int,	path_connect		)
+	),
+
+	TP_fast_assign(
+		__assign_str(wname, widget->name);
+		__assign_str(pname, path->name ? path->name : DAPM_DIRECT);
+		__assign_str(psname, path->sink->name);
+		__entry->path_connect = path->connect;
+		__entry->path_sink = (long)path->sink;
+	),
+
+	TP_printk("%c%s -> %s -> %s\n",
+		(int) __entry->path_sink &&
+		(int) __entry->path_connect ? '*' : ' ',
+		__get_str(wname), __get_str(pname), __get_str(psname))
+);
+
+TRACE_EVENT(snd_soc_dapm_input_path,
+
+	TP_PROTO(struct snd_soc_dapm_widget *widget,
+		struct snd_soc_dapm_path *path),
+
+	TP_ARGS(widget, path),
+
+	TP_STRUCT__entry(
+		__string(	wname,	widget->name		)
+		__string(	pname,	path->name ? path->name : DAPM_DIRECT)
+		__string(	psname,	path->source->name	)
+		__field(	int,	path_source		)
+		__field(	int,	path_connect		)
+	),
+
+	TP_fast_assign(
+		__assign_str(wname, widget->name);
+		__assign_str(pname, path->name ? path->name : DAPM_DIRECT);
+		__assign_str(psname, path->source->name);
+		__entry->path_connect = path->connect;
+		__entry->path_source = (long)path->source;
+	),
+
+	TP_printk("%c%s <- %s <- %s\n",
+		(int) __entry->path_source &&
+		(int) __entry->path_connect ? '*' : ' ',
+		__get_str(wname), __get_str(pname), __get_str(psname))
+);
+
+TRACE_EVENT(snd_soc_dapm_connected,
+
+	TP_PROTO(int paths, int stream),
+
+	TP_ARGS(paths, stream),
+
+	TP_STRUCT__entry(
+		__field(	int,	paths		)
+		__field(	int,	stream		)
+	),
+
+	TP_fast_assign(
+		__entry->paths = paths;
+		__entry->stream = stream;
+	),
+
+	TP_printk("%s: found %d paths\n",
+		__entry->stream ? "capture" : "playback", __entry->paths)
+);
+
 TRACE_EVENT(snd_soc_jack_irq,
 
 	TP_PROTO(const char *name),
diff --git a/drivers/staging/lttng/instrumentation/events/mainline/block.h b/drivers/staging/lttng/instrumentation/events/mainline/block.h
index bf36654..05c5e61 100644
--- a/drivers/staging/lttng/instrumentation/events/mainline/block.h
+++ b/drivers/staging/lttng/instrumentation/events/mainline/block.h
@@ -8,6 +8,8 @@
 #include <linux/blkdev.h>
 #include <linux/tracepoint.h>
 
+#define RWBS_LEN	8
+
 DECLARE_EVENT_CLASS(block_rq_with_error,
 
 	TP_PROTO(struct request_queue *q, struct request *rq),
@@ -19,7 +21,7 @@ DECLARE_EVENT_CLASS(block_rq_with_error,
 		__field(  sector_t,	sector			)
 		__field(  unsigned int,	nr_sector		)
 		__field(  int,		errors			)
-		__array(  char,		rwbs,	6		)
+		__array(  char,		rwbs,	RWBS_LEN	)
 		__dynamic_array( char,	cmd,	blk_cmd_buf_len(rq)	)
 	),
 
@@ -104,7 +106,7 @@ DECLARE_EVENT_CLASS(block_rq,
 		__field(  sector_t,	sector			)
 		__field(  unsigned int,	nr_sector		)
 		__field(  unsigned int,	bytes			)
-		__array(  char,		rwbs,	6		)
+		__array(  char,		rwbs,	RWBS_LEN	)
 		__array(  char,         comm,   TASK_COMM_LEN   )
 		__dynamic_array( char,	cmd,	blk_cmd_buf_len(rq)	)
 	),
@@ -183,7 +185,7 @@ TRACE_EVENT(block_bio_bounce,
 		__field( dev_t,		dev			)
 		__field( sector_t,	sector			)
 		__field( unsigned int,	nr_sector		)
-		__array( char,		rwbs,	6		)
+		__array( char,		rwbs,	RWBS_LEN	)
 		__array( char,		comm,	TASK_COMM_LEN	)
 	),
 
@@ -222,7 +224,7 @@ TRACE_EVENT(block_bio_complete,
 		__field( sector_t,	sector		)
 		__field( unsigned,	nr_sector	)
 		__field( int,		error		)
-		__array( char,		rwbs,	6	)
+		__array( char,		rwbs,	RWBS_LEN)
 	),
 
 	TP_fast_assign(
@@ -249,7 +251,7 @@ DECLARE_EVENT_CLASS(block_bio,
 		__field( dev_t,		dev			)
 		__field( sector_t,	sector			)
 		__field( unsigned int,	nr_sector		)
-		__array( char,		rwbs,	6		)
+		__array( char,		rwbs,	RWBS_LEN	)
 		__array( char,		comm,	TASK_COMM_LEN	)
 	),
 
@@ -321,7 +323,7 @@ DECLARE_EVENT_CLASS(block_get_rq,
 		__field( dev_t,		dev			)
 		__field( sector_t,	sector			)
 		__field( unsigned int,	nr_sector		)
-		__array( char,		rwbs,	6		)
+		__array( char,		rwbs,	RWBS_LEN	)
 		__array( char,		comm,	TASK_COMM_LEN	)
         ),
 
@@ -456,7 +458,7 @@ TRACE_EVENT(block_split,
 		__field( dev_t,		dev				)
 		__field( sector_t,	sector				)
 		__field( sector_t,	new_sector			)
-		__array( char,		rwbs,		6		)
+		__array( char,		rwbs,		RWBS_LEN	)
 		__array( char,		comm,		TASK_COMM_LEN	)
 	),
 
@@ -498,7 +500,7 @@ TRACE_EVENT(block_bio_remap,
 		__field( unsigned int,	nr_sector	)
 		__field( dev_t,		old_dev		)
 		__field( sector_t,	old_sector	)
-		__array( char,		rwbs,	6	)
+		__array( char,		rwbs,	RWBS_LEN)
 	),
 
 	TP_fast_assign(
@@ -542,7 +544,7 @@ TRACE_EVENT(block_rq_remap,
 		__field( unsigned int,	nr_sector	)
 		__field( dev_t,		old_dev		)
 		__field( sector_t,	old_sector	)
-		__array( char,		rwbs,	6	)
+		__array( char,		rwbs,	RWBS_LEN)
 	),
 
 	TP_fast_assign(
diff --git a/drivers/staging/lttng/instrumentation/events/mainline/ext3.h b/drivers/staging/lttng/instrumentation/events/mainline/ext3.h
index 7b53c05..15d11a3 100644
--- a/drivers/staging/lttng/instrumentation/events/mainline/ext3.h
+++ b/drivers/staging/lttng/instrumentation/events/mainline/ext3.h
@@ -24,8 +24,8 @@ TRACE_EVENT(ext3_free_inode,
 		__entry->dev	= inode->i_sb->s_dev;
 		__entry->ino	= inode->i_ino;
 		__entry->mode	= inode->i_mode;
-		__entry->uid	= inode->i_uid;
-		__entry->gid	= inode->i_gid;
+		__entry->uid	= i_uid_read(inode);
+		__entry->gid	= i_gid_read(inode);
 		__entry->blocks	= inode->i_blocks;
 	),
 
diff --git a/drivers/staging/lttng/instrumentation/events/mainline/fs_ext3.h b/drivers/staging/lttng/instrumentation/events/mainline/fs_ext3.h
deleted file mode 100644
index 76353e4..0000000
--- a/drivers/staging/lttng/instrumentation/events/mainline/fs_ext3.h
+++ /dev/null
@@ -1,1323 +0,0 @@
-/*
- * Written by Stephen C. Tweedie <sct@redhat.com>, 1999
- *
- * Copyright 1998--1999 Red Hat corp --- All Rights Reserved
- *
- * This file is part of the Linux kernel and is made available under
- * the terms of the GNU General Public License, version 2, or at your
- * option, any later version, incorporated herein by reference.
- *
- * Copyright (C) 1992, 1993, 1994, 1995
- * Remy Card (card@masi.ibp.fr)
- * Laboratoire MASI - Institut Blaise Pascal
- * Universite Pierre et Marie Curie (Paris VI)
- *
- *  from
- *
- *  linux/include/linux/minix_fs.h
- *
- *  Copyright (C) 1991, 1992  Linus Torvalds
- */
-
-#include <linux/fs.h>
-#include <linux/jbd.h>
-#include <linux/magic.h>
-#include <linux/bug.h>
-#include <linux/blockgroup_lock.h>
-
-/*
- * The second extended filesystem constants/structures
- */
-
-/*
- * Define EXT3FS_DEBUG to produce debug messages
- */
-#undef EXT3FS_DEBUG
-
-/*
- * Define EXT3_RESERVATION to reserve data blocks for expanding files
- */
-#define EXT3_DEFAULT_RESERVE_BLOCKS     8
-/*max window size: 1024(direct blocks) + 3([t,d]indirect blocks) */
-#define EXT3_MAX_RESERVE_BLOCKS         1027
-#define EXT3_RESERVE_WINDOW_NOT_ALLOCATED 0
-
-/*
- * Debug code
- */
-#ifdef EXT3FS_DEBUG
-#define ext3_debug(f, a...)						\
-	do {								\
-		printk (KERN_DEBUG "EXT3-fs DEBUG (%s, %d): %s:",	\
-			__FILE__, __LINE__, __func__);		\
-		printk (KERN_DEBUG f, ## a);				\
-	} while (0)
-#else
-#define ext3_debug(f, a...)	do {} while (0)
-#endif
-
-/*
- * Special inodes numbers
- */
-#define	EXT3_BAD_INO		 1	/* Bad blocks inode */
-#define EXT3_ROOT_INO		 2	/* Root inode */
-#define EXT3_BOOT_LOADER_INO	 5	/* Boot loader inode */
-#define EXT3_UNDEL_DIR_INO	 6	/* Undelete directory inode */
-#define EXT3_RESIZE_INO		 7	/* Reserved group descriptors inode */
-#define EXT3_JOURNAL_INO	 8	/* Journal inode */
-
-/* First non-reserved inode for old ext3 filesystems */
-#define EXT3_GOOD_OLD_FIRST_INO	11
-
-/*
- * Maximal count of links to a file
- */
-#define EXT3_LINK_MAX		32000
-
-/*
- * Macro-instructions used to manage several block sizes
- */
-#define EXT3_MIN_BLOCK_SIZE		1024
-#define	EXT3_MAX_BLOCK_SIZE		65536
-#define EXT3_MIN_BLOCK_LOG_SIZE		10
-#define EXT3_BLOCK_SIZE(s)		((s)->s_blocksize)
-#define	EXT3_ADDR_PER_BLOCK(s)		(EXT3_BLOCK_SIZE(s) / sizeof (__u32))
-#define EXT3_BLOCK_SIZE_BITS(s)	((s)->s_blocksize_bits)
-#define	EXT3_ADDR_PER_BLOCK_BITS(s)	(EXT3_SB(s)->s_addr_per_block_bits)
-#define EXT3_INODE_SIZE(s)		(EXT3_SB(s)->s_inode_size)
-#define EXT3_FIRST_INO(s)		(EXT3_SB(s)->s_first_ino)
-
-/*
- * Macro-instructions used to manage fragments
- */
-#define EXT3_MIN_FRAG_SIZE		1024
-#define	EXT3_MAX_FRAG_SIZE		4096
-#define EXT3_MIN_FRAG_LOG_SIZE		  10
-#define EXT3_FRAG_SIZE(s)		(EXT3_SB(s)->s_frag_size)
-#define EXT3_FRAGS_PER_BLOCK(s)		(EXT3_SB(s)->s_frags_per_block)
-
-/*
- * Structure of a blocks group descriptor
- */
-struct ext3_group_desc
-{
-	__le32	bg_block_bitmap;		/* Blocks bitmap block */
-	__le32	bg_inode_bitmap;		/* Inodes bitmap block */
-	__le32	bg_inode_table;		/* Inodes table block */
-	__le16	bg_free_blocks_count;	/* Free blocks count */
-	__le16	bg_free_inodes_count;	/* Free inodes count */
-	__le16	bg_used_dirs_count;	/* Directories count */
-	__u16	bg_pad;
-	__le32	bg_reserved[3];
-};
-
-/*
- * Macro-instructions used to manage group descriptors
- */
-#define EXT3_BLOCKS_PER_GROUP(s)	(EXT3_SB(s)->s_blocks_per_group)
-#define EXT3_DESC_PER_BLOCK(s)		(EXT3_SB(s)->s_desc_per_block)
-#define EXT3_INODES_PER_GROUP(s)	(EXT3_SB(s)->s_inodes_per_group)
-#define EXT3_DESC_PER_BLOCK_BITS(s)	(EXT3_SB(s)->s_desc_per_block_bits)
-
-/*
- * Constants relative to the data blocks
- */
-#define	EXT3_NDIR_BLOCKS		12
-#define	EXT3_IND_BLOCK			EXT3_NDIR_BLOCKS
-#define	EXT3_DIND_BLOCK			(EXT3_IND_BLOCK + 1)
-#define	EXT3_TIND_BLOCK			(EXT3_DIND_BLOCK + 1)
-#define	EXT3_N_BLOCKS			(EXT3_TIND_BLOCK + 1)
-
-/*
- * Inode flags
- */
-#define	EXT3_SECRM_FL			0x00000001 /* Secure deletion */
-#define	EXT3_UNRM_FL			0x00000002 /* Undelete */
-#define	EXT3_COMPR_FL			0x00000004 /* Compress file */
-#define EXT3_SYNC_FL			0x00000008 /* Synchronous updates */
-#define EXT3_IMMUTABLE_FL		0x00000010 /* Immutable file */
-#define EXT3_APPEND_FL			0x00000020 /* writes to file may only append */
-#define EXT3_NODUMP_FL			0x00000040 /* do not dump file */
-#define EXT3_NOATIME_FL			0x00000080 /* do not update atime */
-/* Reserved for compression usage... */
-#define EXT3_DIRTY_FL			0x00000100
-#define EXT3_COMPRBLK_FL		0x00000200 /* One or more compressed clusters */
-#define EXT3_NOCOMPR_FL			0x00000400 /* Don't compress */
-#define EXT3_ECOMPR_FL			0x00000800 /* Compression error */
-/* End compression flags --- maybe not all used */
-#define EXT3_INDEX_FL			0x00001000 /* hash-indexed directory */
-#define EXT3_IMAGIC_FL			0x00002000 /* AFS directory */
-#define EXT3_JOURNAL_DATA_FL		0x00004000 /* file data should be journaled */
-#define EXT3_NOTAIL_FL			0x00008000 /* file tail should not be merged */
-#define EXT3_DIRSYNC_FL			0x00010000 /* dirsync behaviour (directories only) */
-#define EXT3_TOPDIR_FL			0x00020000 /* Top of directory hierarchies*/
-#define EXT3_RESERVED_FL		0x80000000 /* reserved for ext3 lib */
-
-#define EXT3_FL_USER_VISIBLE		0x0003DFFF /* User visible flags */
-#define EXT3_FL_USER_MODIFIABLE		0x000380FF /* User modifiable flags */
-
-/* Flags that should be inherited by new inodes from their parent. */
-#define EXT3_FL_INHERITED (EXT3_SECRM_FL | EXT3_UNRM_FL | EXT3_COMPR_FL |\
-			   EXT3_SYNC_FL | EXT3_NODUMP_FL |\
-			   EXT3_NOATIME_FL | EXT3_COMPRBLK_FL |\
-			   EXT3_NOCOMPR_FL | EXT3_JOURNAL_DATA_FL |\
-			   EXT3_NOTAIL_FL | EXT3_DIRSYNC_FL)
-
-/* Flags that are appropriate for regular files (all but dir-specific ones). */
-#define EXT3_REG_FLMASK (~(EXT3_DIRSYNC_FL | EXT3_TOPDIR_FL))
-
-/* Flags that are appropriate for non-directories/regular files. */
-#define EXT3_OTHER_FLMASK (EXT3_NODUMP_FL | EXT3_NOATIME_FL)
-
-/* Mask out flags that are inappropriate for the given type of inode. */
-static inline __u32 ext3_mask_flags(umode_t mode, __u32 flags)
-{
-	if (S_ISDIR(mode))
-		return flags;
-	else if (S_ISREG(mode))
-		return flags & EXT3_REG_FLMASK;
-	else
-		return flags & EXT3_OTHER_FLMASK;
-}
-
-/* Used to pass group descriptor data when online resize is done */
-struct ext3_new_group_input {
-	__u32 group;            /* Group number for this data */
-	__u32 block_bitmap;     /* Absolute block number of block bitmap */
-	__u32 inode_bitmap;     /* Absolute block number of inode bitmap */
-	__u32 inode_table;      /* Absolute block number of inode table start */
-	__u32 blocks_count;     /* Total number of blocks in this group */
-	__u16 reserved_blocks;  /* Number of reserved blocks in this group */
-	__u16 unused;
-};
-
-/* The struct ext3_new_group_input in kernel space, with free_blocks_count */
-struct ext3_new_group_data {
-	__u32 group;
-	__u32 block_bitmap;
-	__u32 inode_bitmap;
-	__u32 inode_table;
-	__u32 blocks_count;
-	__u16 reserved_blocks;
-	__u16 unused;
-	__u32 free_blocks_count;
-};
-
-
-/*
- * ioctl commands
- */
-#define	EXT3_IOC_GETFLAGS		FS_IOC_GETFLAGS
-#define	EXT3_IOC_SETFLAGS		FS_IOC_SETFLAGS
-#define	EXT3_IOC_GETVERSION		_IOR('f', 3, long)
-#define	EXT3_IOC_SETVERSION		_IOW('f', 4, long)
-#define EXT3_IOC_GROUP_EXTEND		_IOW('f', 7, unsigned long)
-#define EXT3_IOC_GROUP_ADD		_IOW('f', 8,struct ext3_new_group_input)
-#define	EXT3_IOC_GETVERSION_OLD		FS_IOC_GETVERSION
-#define	EXT3_IOC_SETVERSION_OLD		FS_IOC_SETVERSION
-#ifdef CONFIG_JBD_DEBUG
-#define EXT3_IOC_WAIT_FOR_READONLY	_IOR('f', 99, long)
-#endif
-#define EXT3_IOC_GETRSVSZ		_IOR('f', 5, long)
-#define EXT3_IOC_SETRSVSZ		_IOW('f', 6, long)
-
-/*
- * ioctl commands in 32 bit emulation
- */
-#define EXT3_IOC32_GETFLAGS		FS_IOC32_GETFLAGS
-#define EXT3_IOC32_SETFLAGS		FS_IOC32_SETFLAGS
-#define EXT3_IOC32_GETVERSION		_IOR('f', 3, int)
-#define EXT3_IOC32_SETVERSION		_IOW('f', 4, int)
-#define EXT3_IOC32_GETRSVSZ		_IOR('f', 5, int)
-#define EXT3_IOC32_SETRSVSZ		_IOW('f', 6, int)
-#define EXT3_IOC32_GROUP_EXTEND		_IOW('f', 7, unsigned int)
-#ifdef CONFIG_JBD_DEBUG
-#define EXT3_IOC32_WAIT_FOR_READONLY	_IOR('f', 99, int)
-#endif
-#define EXT3_IOC32_GETVERSION_OLD	FS_IOC32_GETVERSION
-#define EXT3_IOC32_SETVERSION_OLD	FS_IOC32_SETVERSION
-
-
-/*
- *  Mount options
- */
-struct ext3_mount_options {
-	unsigned long s_mount_opt;
-	uid_t s_resuid;
-	gid_t s_resgid;
-	unsigned long s_commit_interval;
-#ifdef CONFIG_QUOTA
-	int s_jquota_fmt;
-	char *s_qf_names[MAXQUOTAS];
-#endif
-};
-
-/*
- * Structure of an inode on the disk
- */
-struct ext3_inode {
-	__le16	i_mode;		/* File mode */
-	__le16	i_uid;		/* Low 16 bits of Owner Uid */
-	__le32	i_size;		/* Size in bytes */
-	__le32	i_atime;	/* Access time */
-	__le32	i_ctime;	/* Creation time */
-	__le32	i_mtime;	/* Modification time */
-	__le32	i_dtime;	/* Deletion Time */
-	__le16	i_gid;		/* Low 16 bits of Group Id */
-	__le16	i_links_count;	/* Links count */
-	__le32	i_blocks;	/* Blocks count */
-	__le32	i_flags;	/* File flags */
-	union {
-		struct {
-			__u32  l_i_reserved1;
-		} linux1;
-		struct {
-			__u32  h_i_translator;
-		} hurd1;
-		struct {
-			__u32  m_i_reserved1;
-		} masix1;
-	} osd1;				/* OS dependent 1 */
-	__le32	i_block[EXT3_N_BLOCKS];/* Pointers to blocks */
-	__le32	i_generation;	/* File version (for NFS) */
-	__le32	i_file_acl;	/* File ACL */
-	__le32	i_dir_acl;	/* Directory ACL */
-	__le32	i_faddr;	/* Fragment address */
-	union {
-		struct {
-			__u8	l_i_frag;	/* Fragment number */
-			__u8	l_i_fsize;	/* Fragment size */
-			__u16	i_pad1;
-			__le16	l_i_uid_high;	/* these 2 fields    */
-			__le16	l_i_gid_high;	/* were reserved2[0] */
-			__u32	l_i_reserved2;
-		} linux2;
-		struct {
-			__u8	h_i_frag;	/* Fragment number */
-			__u8	h_i_fsize;	/* Fragment size */
-			__u16	h_i_mode_high;
-			__u16	h_i_uid_high;
-			__u16	h_i_gid_high;
-			__u32	h_i_author;
-		} hurd2;
-		struct {
-			__u8	m_i_frag;	/* Fragment number */
-			__u8	m_i_fsize;	/* Fragment size */
-			__u16	m_pad1;
-			__u32	m_i_reserved2[2];
-		} masix2;
-	} osd2;				/* OS dependent 2 */
-	__le16	i_extra_isize;
-	__le16	i_pad1;
-};
-
-#define i_size_high	i_dir_acl
-
-#define i_reserved1	osd1.linux1.l_i_reserved1
-#define i_frag		osd2.linux2.l_i_frag
-#define i_fsize		osd2.linux2.l_i_fsize
-#define i_uid_low	i_uid
-#define i_gid_low	i_gid
-#define i_uid_high	osd2.linux2.l_i_uid_high
-#define i_gid_high	osd2.linux2.l_i_gid_high
-#define i_reserved2	osd2.linux2.l_i_reserved2
-
-/*
- * File system states
- */
-#define	EXT3_VALID_FS			0x0001	/* Unmounted cleanly */
-#define	EXT3_ERROR_FS			0x0002	/* Errors detected */
-#define	EXT3_ORPHAN_FS			0x0004	/* Orphans being recovered */
-
-/*
- * Misc. filesystem flags
- */
-#define EXT2_FLAGS_SIGNED_HASH		0x0001  /* Signed dirhash in use */
-#define EXT2_FLAGS_UNSIGNED_HASH	0x0002  /* Unsigned dirhash in use */
-#define EXT2_FLAGS_TEST_FILESYS		0x0004	/* to test development code */
-
-/*
- * Mount flags
- */
-#define EXT3_MOUNT_CHECK		0x00001	/* Do mount-time checks */
-/* EXT3_MOUNT_OLDALLOC was there */
-#define EXT3_MOUNT_GRPID		0x00004	/* Create files with directory's group */
-#define EXT3_MOUNT_DEBUG		0x00008	/* Some debugging messages */
-#define EXT3_MOUNT_ERRORS_CONT		0x00010	/* Continue on errors */
-#define EXT3_MOUNT_ERRORS_RO		0x00020	/* Remount fs ro on errors */
-#define EXT3_MOUNT_ERRORS_PANIC		0x00040	/* Panic on errors */
-#define EXT3_MOUNT_MINIX_DF		0x00080	/* Mimics the Minix statfs */
-#define EXT3_MOUNT_NOLOAD		0x00100	/* Don't use existing journal*/
-#define EXT3_MOUNT_ABORT		0x00200	/* Fatal error detected */
-#define EXT3_MOUNT_DATA_FLAGS		0x00C00	/* Mode for data writes: */
-#define EXT3_MOUNT_JOURNAL_DATA		0x00400	/* Write data to journal */
-#define EXT3_MOUNT_ORDERED_DATA		0x00800	/* Flush data before commit */
-#define EXT3_MOUNT_WRITEBACK_DATA	0x00C00	/* No data ordering */
-#define EXT3_MOUNT_UPDATE_JOURNAL	0x01000	/* Update the journal format */
-#define EXT3_MOUNT_NO_UID32		0x02000  /* Disable 32-bit UIDs */
-#define EXT3_MOUNT_XATTR_USER		0x04000	/* Extended user attributes */
-#define EXT3_MOUNT_POSIX_ACL		0x08000	/* POSIX Access Control Lists */
-#define EXT3_MOUNT_RESERVATION		0x10000	/* Preallocation */
-#define EXT3_MOUNT_BARRIER		0x20000 /* Use block barriers */
-#define EXT3_MOUNT_QUOTA		0x80000 /* Some quota option set */
-#define EXT3_MOUNT_USRQUOTA		0x100000 /* "old" user quota */
-#define EXT3_MOUNT_GRPQUOTA		0x200000 /* "old" group quota */
-#define EXT3_MOUNT_DATA_ERR_ABORT	0x400000 /* Abort on file data write
-						  * error in ordered mode */
-
-/* Compatibility, for having both ext2_fs.h and ext3_fs.h included at once */
-#ifndef _LINUX_EXT2_FS_H
-#define clear_opt(o, opt)		o &= ~EXT3_MOUNT_##opt
-#define set_opt(o, opt)			o |= EXT3_MOUNT_##opt
-#define test_opt(sb, opt)		(EXT3_SB(sb)->s_mount_opt & \
-					 EXT3_MOUNT_##opt)
-#else
-#define EXT2_MOUNT_NOLOAD		EXT3_MOUNT_NOLOAD
-#define EXT2_MOUNT_ABORT		EXT3_MOUNT_ABORT
-#define EXT2_MOUNT_DATA_FLAGS		EXT3_MOUNT_DATA_FLAGS
-#endif
-
-#define ext3_set_bit			__set_bit_le
-#define ext3_set_bit_atomic		ext2_set_bit_atomic
-#define ext3_clear_bit			__clear_bit_le
-#define ext3_clear_bit_atomic		ext2_clear_bit_atomic
-#define ext3_test_bit			test_bit_le
-#define ext3_find_next_zero_bit		find_next_zero_bit_le
-
-/*
- * Maximal mount counts between two filesystem checks
- */
-#define EXT3_DFL_MAX_MNT_COUNT		20	/* Allow 20 mounts */
-#define EXT3_DFL_CHECKINTERVAL		0	/* Don't use interval check */
-
-/*
- * Behaviour when detecting errors
- */
-#define EXT3_ERRORS_CONTINUE		1	/* Continue execution */
-#define EXT3_ERRORS_RO			2	/* Remount fs read-only */
-#define EXT3_ERRORS_PANIC		3	/* Panic */
-#define EXT3_ERRORS_DEFAULT		EXT3_ERRORS_CONTINUE
-
-/*
- * Structure of the super block
- */
-struct ext3_super_block {
-/*00*/	__le32	s_inodes_count;		/* Inodes count */
-	__le32	s_blocks_count;		/* Blocks count */
-	__le32	s_r_blocks_count;	/* Reserved blocks count */
-	__le32	s_free_blocks_count;	/* Free blocks count */
-/*10*/	__le32	s_free_inodes_count;	/* Free inodes count */
-	__le32	s_first_data_block;	/* First Data Block */
-	__le32	s_log_block_size;	/* Block size */
-	__le32	s_log_frag_size;	/* Fragment size */
-/*20*/	__le32	s_blocks_per_group;	/* # Blocks per group */
-	__le32	s_frags_per_group;	/* # Fragments per group */
-	__le32	s_inodes_per_group;	/* # Inodes per group */
-	__le32	s_mtime;		/* Mount time */
-/*30*/	__le32	s_wtime;		/* Write time */
-	__le16	s_mnt_count;		/* Mount count */
-	__le16	s_max_mnt_count;	/* Maximal mount count */
-	__le16	s_magic;		/* Magic signature */
-	__le16	s_state;		/* File system state */
-	__le16	s_errors;		/* Behaviour when detecting errors */
-	__le16	s_minor_rev_level;	/* minor revision level */
-/*40*/	__le32	s_lastcheck;		/* time of last check */
-	__le32	s_checkinterval;	/* max. time between checks */
-	__le32	s_creator_os;		/* OS */
-	__le32	s_rev_level;		/* Revision level */
-/*50*/	__le16	s_def_resuid;		/* Default uid for reserved blocks */
-	__le16	s_def_resgid;		/* Default gid for reserved blocks */
-	/*
-	 * These fields are for EXT3_DYNAMIC_REV superblocks only.
-	 *
-	 * Note: the difference between the compatible feature set and
-	 * the incompatible feature set is that if there is a bit set
-	 * in the incompatible feature set that the kernel doesn't
-	 * know about, it should refuse to mount the filesystem.
-	 *
-	 * e2fsck's requirements are more strict; if it doesn't know
-	 * about a feature in either the compatible or incompatible
-	 * feature set, it must abort and not try to meddle with
-	 * things it doesn't understand...
-	 */
-	__le32	s_first_ino;		/* First non-reserved inode */
-	__le16   s_inode_size;		/* size of inode structure */
-	__le16	s_block_group_nr;	/* block group # of this superblock */
-	__le32	s_feature_compat;	/* compatible feature set */
-/*60*/	__le32	s_feature_incompat;	/* incompatible feature set */
-	__le32	s_feature_ro_compat;	/* readonly-compatible feature set */
-/*68*/	__u8	s_uuid[16];		/* 128-bit uuid for volume */
-/*78*/	char	s_volume_name[16];	/* volume name */
-/*88*/	char	s_last_mounted[64];	/* directory where last mounted */
-/*C8*/	__le32	s_algorithm_usage_bitmap; /* For compression */
-	/*
-	 * Performance hints.  Directory preallocation should only
-	 * happen if the EXT3_FEATURE_COMPAT_DIR_PREALLOC flag is on.
-	 */
-	__u8	s_prealloc_blocks;	/* Nr of blocks to try to preallocate*/
-	__u8	s_prealloc_dir_blocks;	/* Nr to preallocate for dirs */
-	__le16	s_reserved_gdt_blocks;	/* Per group desc for online growth */
-	/*
-	 * Journaling support valid if EXT3_FEATURE_COMPAT_HAS_JOURNAL set.
-	 */
-/*D0*/	__u8	s_journal_uuid[16];	/* uuid of journal superblock */
-/*E0*/	__le32	s_journal_inum;		/* inode number of journal file */
-	__le32	s_journal_dev;		/* device number of journal file */
-	__le32	s_last_orphan;		/* start of list of inodes to delete */
-	__le32	s_hash_seed[4];		/* HTREE hash seed */
-	__u8	s_def_hash_version;	/* Default hash version to use */
-	__u8	s_reserved_char_pad;
-	__u16	s_reserved_word_pad;
-	__le32	s_default_mount_opts;
-	__le32	s_first_meta_bg;	/* First metablock block group */
-	__le32	s_mkfs_time;		/* When the filesystem was created */
-	__le32	s_jnl_blocks[17];	/* Backup of the journal inode */
-	/* 64bit support valid if EXT4_FEATURE_COMPAT_64BIT */
-/*150*/	__le32	s_blocks_count_hi;	/* Blocks count */
-	__le32	s_r_blocks_count_hi;	/* Reserved blocks count */
-	__le32	s_free_blocks_count_hi;	/* Free blocks count */
-	__le16	s_min_extra_isize;	/* All inodes have at least # bytes */
-	__le16	s_want_extra_isize; 	/* New inodes should reserve # bytes */
-	__le32	s_flags;		/* Miscellaneous flags */
-	__le16  s_raid_stride;		/* RAID stride */
-	__le16  s_mmp_interval;         /* # seconds to wait in MMP checking */
-	__le64  s_mmp_block;            /* Block for multi-mount protection */
-	__le32  s_raid_stripe_width;    /* blocks on all data disks (N*stride)*/
-	__u8	s_log_groups_per_flex;  /* FLEX_BG group size */
-	__u8	s_reserved_char_pad2;
-	__le16  s_reserved_pad;
-	__u32   s_reserved[162];        /* Padding to the end of the block */
-};
-
-/* data type for block offset of block group */
-typedef int ext3_grpblk_t;
-
-/* data type for filesystem-wide blocks number */
-typedef unsigned long ext3_fsblk_t;
-
-#define E3FSBLK "%lu"
-
-struct ext3_reserve_window {
-	ext3_fsblk_t	_rsv_start;	/* First byte reserved */
-	ext3_fsblk_t	_rsv_end;	/* Last byte reserved or 0 */
-};
-
-struct ext3_reserve_window_node {
-	struct rb_node		rsv_node;
-	__u32			rsv_goal_size;
-	__u32			rsv_alloc_hit;
-	struct ext3_reserve_window	rsv_window;
-};
-
-struct ext3_block_alloc_info {
-	/* information about reservation window */
-	struct ext3_reserve_window_node	rsv_window_node;
-	/*
-	 * was i_next_alloc_block in ext3_inode_info
-	 * is the logical (file-relative) number of the
-	 * most-recently-allocated block in this file.
-	 * We use this for detecting linearly ascending allocation requests.
-	 */
-	__u32                   last_alloc_logical_block;
-	/*
-	 * Was i_next_alloc_goal in ext3_inode_info
-	 * is the *physical* companion to i_next_alloc_block.
-	 * it the physical block number of the block which was most-recentl
-	 * allocated to this file.  This give us the goal (target) for the next
-	 * allocation when we detect linearly ascending requests.
-	 */
-	ext3_fsblk_t		last_alloc_physical_block;
-};
-
-#define rsv_start rsv_window._rsv_start
-#define rsv_end rsv_window._rsv_end
-
-/*
- * third extended file system inode data in memory
- */
-struct ext3_inode_info {
-	__le32	i_data[15];	/* unconverted */
-	__u32	i_flags;
-#ifdef EXT3_FRAGMENTS
-	__u32	i_faddr;
-	__u8	i_frag_no;
-	__u8	i_frag_size;
-#endif
-	ext3_fsblk_t	i_file_acl;
-	__u32	i_dir_acl;
-	__u32	i_dtime;
-
-	/*
-	 * i_block_group is the number of the block group which contains
-	 * this file's inode.  Constant across the lifetime of the inode,
-	 * it is ued for making block allocation decisions - we try to
-	 * place a file's data blocks near its inode block, and new inodes
-	 * near to their parent directory's inode.
-	 */
-	__u32	i_block_group;
-	unsigned long	i_state_flags;	/* Dynamic state flags for ext3 */
-
-	/* block reservation info */
-	struct ext3_block_alloc_info *i_block_alloc_info;
-
-	__u32	i_dir_start_lookup;
-#ifdef CONFIG_EXT3_FS_XATTR
-	/*
-	 * Extended attributes can be read independently of the main file
-	 * data. Taking i_mutex even when reading would cause contention
-	 * between readers of EAs and writers of regular file data, so
-	 * instead we synchronize on xattr_sem when reading or changing
-	 * EAs.
-	 */
-	struct rw_semaphore xattr_sem;
-#endif
-
-	struct list_head i_orphan;	/* unlinked but open inodes */
-
-	/*
-	 * i_disksize keeps track of what the inode size is ON DISK, not
-	 * in memory.  During truncate, i_size is set to the new size by
-	 * the VFS prior to calling ext3_truncate(), but the filesystem won't
-	 * set i_disksize to 0 until the truncate is actually under way.
-	 *
-	 * The intent is that i_disksize always represents the blocks which
-	 * are used by this file.  This allows recovery to restart truncate
-	 * on orphans if we crash during truncate.  We actually write i_disksize
-	 * into the on-disk inode when writing inodes out, instead of i_size.
-	 *
-	 * The only time when i_disksize and i_size may be different is when
-	 * a truncate is in progress.  The only things which change i_disksize
-	 * are ext3_get_block (growth) and ext3_truncate (shrinkth).
-	 */
-	loff_t	i_disksize;
-
-	/* on-disk additional length */
-	__u16 i_extra_isize;
-
-	/*
-	 * truncate_mutex is for serialising ext3_truncate() against
-	 * ext3_getblock().  In the 2.4 ext2 design, great chunks of inode's
-	 * data tree are chopped off during truncate. We can't do that in
-	 * ext3 because whenever we perform intermediate commits during
-	 * truncate, the inode and all the metadata blocks *must* be in a
-	 * consistent state which allows truncation of the orphans to restart
-	 * during recovery.  Hence we must fix the get_block-vs-truncate race
-	 * by other means, so we have truncate_mutex.
-	 */
-	struct mutex truncate_mutex;
-
-	/*
-	 * Transactions that contain inode's metadata needed to complete
-	 * fsync and fdatasync, respectively.
-	 */
-	atomic_t i_sync_tid;
-	atomic_t i_datasync_tid;
-
-	struct inode vfs_inode;
-};
-
-/*
- * third extended-fs super-block data in memory
- */
-struct ext3_sb_info {
-	unsigned long s_frag_size;	/* Size of a fragment in bytes */
-	unsigned long s_frags_per_block;/* Number of fragments per block */
-	unsigned long s_inodes_per_block;/* Number of inodes per block */
-	unsigned long s_frags_per_group;/* Number of fragments in a group */
-	unsigned long s_blocks_per_group;/* Number of blocks in a group */
-	unsigned long s_inodes_per_group;/* Number of inodes in a group */
-	unsigned long s_itb_per_group;	/* Number of inode table blocks per group */
-	unsigned long s_gdb_count;	/* Number of group descriptor blocks */
-	unsigned long s_desc_per_block;	/* Number of group descriptors per block */
-	unsigned long s_groups_count;	/* Number of groups in the fs */
-	unsigned long s_overhead_last;  /* Last calculated overhead */
-	unsigned long s_blocks_last;    /* Last seen block count */
-	struct buffer_head * s_sbh;	/* Buffer containing the super block */
-	struct ext3_super_block * s_es;	/* Pointer to the super block in the buffer */
-	struct buffer_head ** s_group_desc;
-	unsigned long  s_mount_opt;
-	ext3_fsblk_t s_sb_block;
-	uid_t s_resuid;
-	gid_t s_resgid;
-	unsigned short s_mount_state;
-	unsigned short s_pad;
-	int s_addr_per_block_bits;
-	int s_desc_per_block_bits;
-	int s_inode_size;
-	int s_first_ino;
-	spinlock_t s_next_gen_lock;
-	u32 s_next_generation;
-	u32 s_hash_seed[4];
-	int s_def_hash_version;
-	int s_hash_unsigned;	/* 3 if hash should be signed, 0 if not */
-	struct percpu_counter s_freeblocks_counter;
-	struct percpu_counter s_freeinodes_counter;
-	struct percpu_counter s_dirs_counter;
-	struct blockgroup_lock *s_blockgroup_lock;
-
-	/* root of the per fs reservation window tree */
-	spinlock_t s_rsv_window_lock;
-	struct rb_root s_rsv_window_root;
-	struct ext3_reserve_window_node s_rsv_window_head;
-
-	/* Journaling */
-	struct inode * s_journal_inode;
-	struct journal_s * s_journal;
-	struct list_head s_orphan;
-	struct mutex s_orphan_lock;
-	struct mutex s_resize_lock;
-	unsigned long s_commit_interval;
-	struct block_device *journal_bdev;
-#ifdef CONFIG_QUOTA
-	char *s_qf_names[MAXQUOTAS];		/* Names of quota files with journalled quota */
-	int s_jquota_fmt;			/* Format of quota to use */
-#endif
-};
-
-static inline spinlock_t *
-sb_bgl_lock(struct ext3_sb_info *sbi, unsigned int block_group)
-{
-	return bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);
-}
-
-static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)
-{
-	return sb->s_fs_info;
-}
-static inline struct ext3_inode_info *EXT3_I(struct inode *inode)
-{
-	return container_of(inode, struct ext3_inode_info, vfs_inode);
-}
-
-static inline int ext3_valid_inum(struct super_block *sb, unsigned long ino)
-{
-	return ino == EXT3_ROOT_INO ||
-		ino == EXT3_JOURNAL_INO ||
-		ino == EXT3_RESIZE_INO ||
-		(ino >= EXT3_FIRST_INO(sb) &&
-		 ino <= le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count));
-}
-
-/*
- * Inode dynamic state flags
- */
-enum {
-	EXT3_STATE_JDATA,		/* journaled data exists */
-	EXT3_STATE_NEW,			/* inode is newly created */
-	EXT3_STATE_XATTR,		/* has in-inode xattrs */
-	EXT3_STATE_FLUSH_ON_CLOSE,	/* flush dirty pages on close */
-};
-
-static inline int ext3_test_inode_state(struct inode *inode, int bit)
-{
-	return test_bit(bit, &EXT3_I(inode)->i_state_flags);
-}
-
-static inline void ext3_set_inode_state(struct inode *inode, int bit)
-{
-	set_bit(bit, &EXT3_I(inode)->i_state_flags);
-}
-
-static inline void ext3_clear_inode_state(struct inode *inode, int bit)
-{
-	clear_bit(bit, &EXT3_I(inode)->i_state_flags);
-}
-
-#define NEXT_ORPHAN(inode) EXT3_I(inode)->i_dtime
-
-/*
- * Codes for operating systems
- */
-#define EXT3_OS_LINUX		0
-#define EXT3_OS_HURD		1
-#define EXT3_OS_MASIX		2
-#define EXT3_OS_FREEBSD		3
-#define EXT3_OS_LITES		4
-
-/*
- * Revision levels
- */
-#define EXT3_GOOD_OLD_REV	0	/* The good old (original) format */
-#define EXT3_DYNAMIC_REV	1	/* V2 format w/ dynamic inode sizes */
-
-#define EXT3_CURRENT_REV	EXT3_GOOD_OLD_REV
-#define EXT3_MAX_SUPP_REV	EXT3_DYNAMIC_REV
-
-#define EXT3_GOOD_OLD_INODE_SIZE 128
-
-/*
- * Feature set definitions
- */
-
-#define EXT3_HAS_COMPAT_FEATURE(sb,mask)			\
-	( EXT3_SB(sb)->s_es->s_feature_compat & cpu_to_le32(mask) )
-#define EXT3_HAS_RO_COMPAT_FEATURE(sb,mask)			\
-	( EXT3_SB(sb)->s_es->s_feature_ro_compat & cpu_to_le32(mask) )
-#define EXT3_HAS_INCOMPAT_FEATURE(sb,mask)			\
-	( EXT3_SB(sb)->s_es->s_feature_incompat & cpu_to_le32(mask) )
-#define EXT3_SET_COMPAT_FEATURE(sb,mask)			\
-	EXT3_SB(sb)->s_es->s_feature_compat |= cpu_to_le32(mask)
-#define EXT3_SET_RO_COMPAT_FEATURE(sb,mask)			\
-	EXT3_SB(sb)->s_es->s_feature_ro_compat |= cpu_to_le32(mask)
-#define EXT3_SET_INCOMPAT_FEATURE(sb,mask)			\
-	EXT3_SB(sb)->s_es->s_feature_incompat |= cpu_to_le32(mask)
-#define EXT3_CLEAR_COMPAT_FEATURE(sb,mask)			\
-	EXT3_SB(sb)->s_es->s_feature_compat &= ~cpu_to_le32(mask)
-#define EXT3_CLEAR_RO_COMPAT_FEATURE(sb,mask)			\
-	EXT3_SB(sb)->s_es->s_feature_ro_compat &= ~cpu_to_le32(mask)
-#define EXT3_CLEAR_INCOMPAT_FEATURE(sb,mask)			\
-	EXT3_SB(sb)->s_es->s_feature_incompat &= ~cpu_to_le32(mask)
-
-#define EXT3_FEATURE_COMPAT_DIR_PREALLOC	0x0001
-#define EXT3_FEATURE_COMPAT_IMAGIC_INODES	0x0002
-#define EXT3_FEATURE_COMPAT_HAS_JOURNAL		0x0004
-#define EXT3_FEATURE_COMPAT_EXT_ATTR		0x0008
-#define EXT3_FEATURE_COMPAT_RESIZE_INODE	0x0010
-#define EXT3_FEATURE_COMPAT_DIR_INDEX		0x0020
-
-#define EXT3_FEATURE_RO_COMPAT_SPARSE_SUPER	0x0001
-#define EXT3_FEATURE_RO_COMPAT_LARGE_FILE	0x0002
-#define EXT3_FEATURE_RO_COMPAT_BTREE_DIR	0x0004
-
-#define EXT3_FEATURE_INCOMPAT_COMPRESSION	0x0001
-#define EXT3_FEATURE_INCOMPAT_FILETYPE		0x0002
-#define EXT3_FEATURE_INCOMPAT_RECOVER		0x0004 /* Needs recovery */
-#define EXT3_FEATURE_INCOMPAT_JOURNAL_DEV	0x0008 /* Journal device */
-#define EXT3_FEATURE_INCOMPAT_META_BG		0x0010
-
-#define EXT3_FEATURE_COMPAT_SUPP	EXT2_FEATURE_COMPAT_EXT_ATTR
-#define EXT3_FEATURE_INCOMPAT_SUPP	(EXT3_FEATURE_INCOMPAT_FILETYPE| \
-					 EXT3_FEATURE_INCOMPAT_RECOVER| \
-					 EXT3_FEATURE_INCOMPAT_META_BG)
-#define EXT3_FEATURE_RO_COMPAT_SUPP	(EXT3_FEATURE_RO_COMPAT_SPARSE_SUPER| \
-					 EXT3_FEATURE_RO_COMPAT_LARGE_FILE| \
-					 EXT3_FEATURE_RO_COMPAT_BTREE_DIR)
-
-/*
- * Default values for user and/or group using reserved blocks
- */
-#define	EXT3_DEF_RESUID		0
-#define	EXT3_DEF_RESGID		0
-
-/*
- * Default mount options
- */
-#define EXT3_DEFM_DEBUG		0x0001
-#define EXT3_DEFM_BSDGROUPS	0x0002
-#define EXT3_DEFM_XATTR_USER	0x0004
-#define EXT3_DEFM_ACL		0x0008
-#define EXT3_DEFM_UID16		0x0010
-#define EXT3_DEFM_JMODE		0x0060
-#define EXT3_DEFM_JMODE_DATA	0x0020
-#define EXT3_DEFM_JMODE_ORDERED	0x0040
-#define EXT3_DEFM_JMODE_WBACK	0x0060
-
-/*
- * Structure of a directory entry
- */
-#define EXT3_NAME_LEN 255
-
-struct ext3_dir_entry {
-	__le32	inode;			/* Inode number */
-	__le16	rec_len;		/* Directory entry length */
-	__le16	name_len;		/* Name length */
-	char	name[EXT3_NAME_LEN];	/* File name */
-};
-
-/*
- * The new version of the directory entry.  Since EXT3 structures are
- * stored in intel byte order, and the name_len field could never be
- * bigger than 255 chars, it's safe to reclaim the extra byte for the
- * file_type field.
- */
-struct ext3_dir_entry_2 {
-	__le32	inode;			/* Inode number */
-	__le16	rec_len;		/* Directory entry length */
-	__u8	name_len;		/* Name length */
-	__u8	file_type;
-	char	name[EXT3_NAME_LEN];	/* File name */
-};
-
-/*
- * Ext3 directory file types.  Only the low 3 bits are used.  The
- * other bits are reserved for now.
- */
-#define EXT3_FT_UNKNOWN		0
-#define EXT3_FT_REG_FILE	1
-#define EXT3_FT_DIR		2
-#define EXT3_FT_CHRDEV		3
-#define EXT3_FT_BLKDEV		4
-#define EXT3_FT_FIFO		5
-#define EXT3_FT_SOCK		6
-#define EXT3_FT_SYMLINK		7
-
-#define EXT3_FT_MAX		8
-
-/*
- * EXT3_DIR_PAD defines the directory entries boundaries
- *
- * NOTE: It must be a multiple of 4
- */
-#define EXT3_DIR_PAD			4
-#define EXT3_DIR_ROUND			(EXT3_DIR_PAD - 1)
-#define EXT3_DIR_REC_LEN(name_len)	(((name_len) + 8 + EXT3_DIR_ROUND) & \
-					 ~EXT3_DIR_ROUND)
-#define EXT3_MAX_REC_LEN		((1<<16)-1)
-
-/*
- * Tests against MAX_REC_LEN etc were put in place for 64k block
- * sizes; if that is not possible on this arch, we can skip
- * those tests and speed things up.
- */
-static inline unsigned ext3_rec_len_from_disk(__le16 dlen)
-{
-	unsigned len = le16_to_cpu(dlen);
-
-#if (PAGE_CACHE_SIZE >= 65536)
-	if (len == EXT3_MAX_REC_LEN)
-		return 1 << 16;
-#endif
-	return len;
-}
-
-static inline __le16 ext3_rec_len_to_disk(unsigned len)
-{
-#if (PAGE_CACHE_SIZE >= 65536)
-	if (len == (1 << 16))
-		return cpu_to_le16(EXT3_MAX_REC_LEN);
-	else if (len > (1 << 16))
-		BUG();
-#endif
-	return cpu_to_le16(len);
-}
-
-/*
- * Hash Tree Directory indexing
- * (c) Daniel Phillips, 2001
- */
-
-#define is_dx(dir) (EXT3_HAS_COMPAT_FEATURE(dir->i_sb, \
-				      EXT3_FEATURE_COMPAT_DIR_INDEX) && \
-		      (EXT3_I(dir)->i_flags & EXT3_INDEX_FL))
-#define EXT3_DIR_LINK_MAX(dir) (!is_dx(dir) && (dir)->i_nlink >= EXT3_LINK_MAX)
-#define EXT3_DIR_LINK_EMPTY(dir) ((dir)->i_nlink == 2 || (dir)->i_nlink == 1)
-
-/* Legal values for the dx_root hash_version field: */
-
-#define DX_HASH_LEGACY		0
-#define DX_HASH_HALF_MD4	1
-#define DX_HASH_TEA		2
-#define DX_HASH_LEGACY_UNSIGNED	3
-#define DX_HASH_HALF_MD4_UNSIGNED	4
-#define DX_HASH_TEA_UNSIGNED		5
-
-/* hash info structure used by the directory hash */
-struct dx_hash_info
-{
-	u32		hash;
-	u32		minor_hash;
-	int		hash_version;
-	u32		*seed;
-};
-
-#define EXT3_HTREE_EOF	0x7fffffff
-
-/*
- * Control parameters used by ext3_htree_next_block
- */
-#define HASH_NB_ALWAYS		1
-
-
-/*
- * Describe an inode's exact location on disk and in memory
- */
-struct ext3_iloc
-{
-	struct buffer_head *bh;
-	unsigned long offset;
-	unsigned long block_group;
-};
-
-static inline struct ext3_inode *ext3_raw_inode(struct ext3_iloc *iloc)
-{
-	return (struct ext3_inode *) (iloc->bh->b_data + iloc->offset);
-}
-
-/*
- * This structure is stuffed into the struct file's private_data field
- * for directories.  It is where we put information so that we can do
- * readdir operations in hash tree order.
- */
-struct dir_private_info {
-	struct rb_root	root;
-	struct rb_node	*curr_node;
-	struct fname	*extra_fname;
-	loff_t		last_pos;
-	__u32		curr_hash;
-	__u32		curr_minor_hash;
-	__u32		next_hash;
-};
-
-/* calculate the first block number of the group */
-static inline ext3_fsblk_t
-ext3_group_first_block_no(struct super_block *sb, unsigned long group_no)
-{
-	return group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +
-		le32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);
-}
-
-/*
- * Special error return code only used by dx_probe() and its callers.
- */
-#define ERR_BAD_DX_DIR	-75000
-
-/*
- * Function prototypes
- */
-
-/*
- * Ok, these declarations are also in <linux/kernel.h> but none of the
- * ext3 source programs needs to include it so they are duplicated here.
- */
-# define NORET_TYPE    /**/
-# define ATTRIB_NORET  __attribute__((noreturn))
-# define NORET_AND     noreturn,
-
-/* balloc.c */
-extern int ext3_bg_has_super(struct super_block *sb, int group);
-extern unsigned long ext3_bg_num_gdb(struct super_block *sb, int group);
-extern ext3_fsblk_t ext3_new_block (handle_t *handle, struct inode *inode,
-			ext3_fsblk_t goal, int *errp);
-extern ext3_fsblk_t ext3_new_blocks (handle_t *handle, struct inode *inode,
-			ext3_fsblk_t goal, unsigned long *count, int *errp);
-extern void ext3_free_blocks (handle_t *handle, struct inode *inode,
-			ext3_fsblk_t block, unsigned long count);
-extern void ext3_free_blocks_sb (handle_t *handle, struct super_block *sb,
-				 ext3_fsblk_t block, unsigned long count,
-				unsigned long *pdquot_freed_blocks);
-extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);
-extern void ext3_check_blocks_bitmap (struct super_block *);
-extern struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,
-						    unsigned int block_group,
-						    struct buffer_head ** bh);
-extern int ext3_should_retry_alloc(struct super_block *sb, int *retries);
-extern void ext3_init_block_alloc_info(struct inode *);
-extern void ext3_rsv_window_add(struct super_block *sb, struct ext3_reserve_window_node *rsv);
-extern int ext3_trim_fs(struct super_block *sb, struct fstrim_range *range);
-
-/* dir.c */
-extern int ext3_check_dir_entry(const char *, struct inode *,
-				struct ext3_dir_entry_2 *,
-				struct buffer_head *, unsigned long);
-extern int ext3_htree_store_dirent(struct file *dir_file, __u32 hash,
-				    __u32 minor_hash,
-				    struct ext3_dir_entry_2 *dirent);
-extern void ext3_htree_free_dir_info(struct dir_private_info *p);
-
-/* fsync.c */
-extern int ext3_sync_file(struct file *, loff_t, loff_t, int);
-
-/* hash.c */
-extern int ext3fs_dirhash(const char *name, int len, struct
-			  dx_hash_info *hinfo);
-
-/* ialloc.c */
-extern struct inode * ext3_new_inode (handle_t *, struct inode *,
-				      const struct qstr *, umode_t);
-extern void ext3_free_inode (handle_t *, struct inode *);
-extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);
-extern unsigned long ext3_count_free_inodes (struct super_block *);
-extern unsigned long ext3_count_dirs (struct super_block *);
-extern void ext3_check_inodes_bitmap (struct super_block *);
-extern unsigned long ext3_count_free (struct buffer_head *, unsigned);
-
-
-/* inode.c */
-int ext3_forget(handle_t *handle, int is_metadata, struct inode *inode,
-		struct buffer_head *bh, ext3_fsblk_t blocknr);
-struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);
-struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);
-int ext3_get_blocks_handle(handle_t *handle, struct inode *inode,
-	sector_t iblock, unsigned long maxblocks, struct buffer_head *bh_result,
-	int create);
-
-extern struct inode *ext3_iget(struct super_block *, unsigned long);
-extern int  ext3_write_inode (struct inode *, struct writeback_control *);
-extern int  ext3_setattr (struct dentry *, struct iattr *);
-extern void ext3_evict_inode (struct inode *);
-extern int  ext3_sync_inode (handle_t *, struct inode *);
-extern void ext3_discard_reservation (struct inode *);
-extern void ext3_dirty_inode(struct inode *, int);
-extern int ext3_change_inode_journal_flag(struct inode *, int);
-extern int ext3_get_inode_loc(struct inode *, struct ext3_iloc *);
-extern int ext3_can_truncate(struct inode *inode);
-extern void ext3_truncate(struct inode *inode);
-extern void ext3_set_inode_flags(struct inode *);
-extern void ext3_get_inode_flags(struct ext3_inode_info *);
-extern void ext3_set_aops(struct inode *inode);
-extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
-		       u64 start, u64 len);
-
-/* ioctl.c */
-extern long ext3_ioctl(struct file *, unsigned int, unsigned long);
-extern long ext3_compat_ioctl(struct file *, unsigned int, unsigned long);
-
-/* namei.c */
-extern int ext3_orphan_add(handle_t *, struct inode *);
-extern int ext3_orphan_del(handle_t *, struct inode *);
-extern int ext3_htree_fill_tree(struct file *dir_file, __u32 start_hash,
-				__u32 start_minor_hash, __u32 *next_hash);
-
-/* resize.c */
-extern int ext3_group_add(struct super_block *sb,
-				struct ext3_new_group_data *input);
-extern int ext3_group_extend(struct super_block *sb,
-				struct ext3_super_block *es,
-				ext3_fsblk_t n_blocks_count);
-
-/* super.c */
-extern __printf(3, 4)
-void ext3_error(struct super_block *, const char *, const char *, ...);
-extern void __ext3_std_error (struct super_block *, const char *, int);
-extern __printf(3, 4)
-void ext3_abort(struct super_block *, const char *, const char *, ...);
-extern __printf(3, 4)
-void ext3_warning(struct super_block *, const char *, const char *, ...);
-extern __printf(3, 4)
-void ext3_msg(struct super_block *, const char *, const char *, ...);
-extern void ext3_update_dynamic_rev (struct super_block *sb);
-
-#define ext3_std_error(sb, errno)				\
-do {								\
-	if ((errno))						\
-		__ext3_std_error((sb), __func__, (errno));	\
-} while (0)
-
-/*
- * Inodes and files operations
- */
-
-/* dir.c */
-extern const struct file_operations ext3_dir_operations;
-
-/* file.c */
-extern const struct inode_operations ext3_file_inode_operations;
-extern const struct file_operations ext3_file_operations;
-
-/* namei.c */
-extern const struct inode_operations ext3_dir_inode_operations;
-extern const struct inode_operations ext3_special_inode_operations;
-
-/* symlink.c */
-extern const struct inode_operations ext3_symlink_inode_operations;
-extern const struct inode_operations ext3_fast_symlink_inode_operations;
-
-#define EXT3_JOURNAL(inode)	(EXT3_SB((inode)->i_sb)->s_journal)
-
-/* Define the number of blocks we need to account to a transaction to
- * modify one block of data.
- *
- * We may have to touch one inode, one bitmap buffer, up to three
- * indirection blocks, the group and superblock summaries, and the data
- * block to complete the transaction.  */
-
-#define EXT3_SINGLEDATA_TRANS_BLOCKS	8U
-
-/* Extended attribute operations touch at most two data buffers,
- * two bitmap buffers, and two group summaries, in addition to the inode
- * and the superblock, which are already accounted for. */
-
-#define EXT3_XATTR_TRANS_BLOCKS		6U
-
-/* Define the minimum size for a transaction which modifies data.  This
- * needs to take into account the fact that we may end up modifying two
- * quota files too (one for the group, one for the user quota).  The
- * superblock only gets updated once, of course, so don't bother
- * counting that again for the quota updates. */
-
-#define EXT3_DATA_TRANS_BLOCKS(sb)	(EXT3_SINGLEDATA_TRANS_BLOCKS + \
-					 EXT3_XATTR_TRANS_BLOCKS - 2 + \
-					 EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))
-
-/* Delete operations potentially hit one directory's namespace plus an
- * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be
- * generous.  We can grow the delete transaction later if necessary. */
-
-#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)
-
-/* Define an arbitrary limit for the amount of data we will anticipate
- * writing to any given transaction.  For unbounded transactions such as
- * write(2) and truncate(2) we can write more than this, but we always
- * start off at the maximum transaction size and grow the transaction
- * optimistically as we go. */
-
-#define EXT3_MAX_TRANS_DATA		64U
-
-/* We break up a large truncate or write transaction once the handle's
- * buffer credits gets this low, we need either to extend the
- * transaction or to start a new one.  Reserve enough space here for
- * inode, bitmap, superblock, group and indirection updates for at least
- * one block, plus two quota updates.  Quota allocations are not
- * needed. */
-
-#define EXT3_RESERVE_TRANS_BLOCKS	12U
-
-#define EXT3_INDEX_EXTRA_TRANS_BLOCKS	8
-
-#ifdef CONFIG_QUOTA
-/* Amount of blocks needed for quota update - we know that the structure was
- * allocated so we need to update only inode+data */
-#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)
-/* Amount of blocks needed for quota insert/delete - we do some block writes
- * but inode, sb and group updates are done only once */
-#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\
-		(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)
-#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\
-		(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)
-#else
-#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0
-#define EXT3_QUOTA_INIT_BLOCKS(sb) 0
-#define EXT3_QUOTA_DEL_BLOCKS(sb) 0
-#endif
-#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))
-#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))
-#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))
-
-int
-ext3_mark_iloc_dirty(handle_t *handle,
-		     struct inode *inode,
-		     struct ext3_iloc *iloc);
-
-/*
- * On success, We end up with an outstanding reference count against
- * iloc->bh.  This _must_ be cleaned up later.
- */
-
-int ext3_reserve_inode_write(handle_t *handle, struct inode *inode,
-			struct ext3_iloc *iloc);
-
-int ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);
-
-/*
- * Wrapper functions with which ext3 calls into JBD.  The intent here is
- * to allow these to be turned into appropriate stubs so ext3 can control
- * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn't
- * been done yet.
- */
-
-static inline void ext3_journal_release_buffer(handle_t *handle,
-						struct buffer_head *bh)
-{
-	journal_release_buffer(handle, bh);
-}
-
-void ext3_journal_abort_handle(const char *caller, const char *err_fn,
-		struct buffer_head *bh, handle_t *handle, int err);
-
-int __ext3_journal_get_undo_access(const char *where, handle_t *handle,
-				struct buffer_head *bh);
-
-int __ext3_journal_get_write_access(const char *where, handle_t *handle,
-				struct buffer_head *bh);
-
-int __ext3_journal_forget(const char *where, handle_t *handle,
-				struct buffer_head *bh);
-
-int __ext3_journal_revoke(const char *where, handle_t *handle,
-				unsigned long blocknr, struct buffer_head *bh);
-
-int __ext3_journal_get_create_access(const char *where,
-				handle_t *handle, struct buffer_head *bh);
-
-int __ext3_journal_dirty_metadata(const char *where,
-				handle_t *handle, struct buffer_head *bh);
-
-#define ext3_journal_get_undo_access(handle, bh) \
-	__ext3_journal_get_undo_access(__func__, (handle), (bh))
-#define ext3_journal_get_write_access(handle, bh) \
-	__ext3_journal_get_write_access(__func__, (handle), (bh))
-#define ext3_journal_revoke(handle, blocknr, bh) \
-	__ext3_journal_revoke(__func__, (handle), (blocknr), (bh))
-#define ext3_journal_get_create_access(handle, bh) \
-	__ext3_journal_get_create_access(__func__, (handle), (bh))
-#define ext3_journal_dirty_metadata(handle, bh) \
-	__ext3_journal_dirty_metadata(__func__, (handle), (bh))
-#define ext3_journal_forget(handle, bh) \
-	__ext3_journal_forget(__func__, (handle), (bh))
-
-int ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);
-
-handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);
-int __ext3_journal_stop(const char *where, handle_t *handle);
-
-static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)
-{
-	return ext3_journal_start_sb(inode->i_sb, nblocks);
-}
-
-#define ext3_journal_stop(handle) \
-	__ext3_journal_stop(__func__, (handle))
-
-static inline handle_t *ext3_journal_current_handle(void)
-{
-	return journal_current_handle();
-}
-
-static inline int ext3_journal_extend(handle_t *handle, int nblocks)
-{
-	return journal_extend(handle, nblocks);
-}
-
-static inline int ext3_journal_restart(handle_t *handle, int nblocks)
-{
-	return journal_restart(handle, nblocks);
-}
-
-static inline int ext3_journal_blocks_per_page(struct inode *inode)
-{
-	return journal_blocks_per_page(inode);
-}
-
-static inline int ext3_journal_force_commit(journal_t *journal)
-{
-	return journal_force_commit(journal);
-}
-
-/* super.c */
-int ext3_force_commit(struct super_block *sb);
-
-static inline int ext3_should_journal_data(struct inode *inode)
-{
-	if (!S_ISREG(inode->i_mode))
-		return 1;
-	if (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)
-		return 1;
-	if (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)
-		return 1;
-	return 0;
-}
-
-static inline int ext3_should_order_data(struct inode *inode)
-{
-	if (!S_ISREG(inode->i_mode))
-		return 0;
-	if (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)
-		return 0;
-	if (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_ORDERED_DATA)
-		return 1;
-	return 0;
-}
-
-static inline int ext3_should_writeback_data(struct inode *inode)
-{
-	if (!S_ISREG(inode->i_mode))
-		return 0;
-	if (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)
-		return 0;
-	if (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_WRITEBACK_DATA)
-		return 1;
-	return 0;
-}
-
-#include <trace/events/ext3.h>
-
diff --git a/drivers/staging/lttng/instrumentation/events/mainline/jbd.h b/drivers/staging/lttng/instrumentation/events/mainline/jbd.h
index aff64d8..da6f259 100644
--- a/drivers/staging/lttng/instrumentation/events/mainline/jbd.h
+++ b/drivers/staging/lttng/instrumentation/events/mainline/jbd.h
@@ -36,19 +36,17 @@ DECLARE_EVENT_CLASS(jbd_commit,
 
 	TP_STRUCT__entry(
 		__field(	dev_t,	dev			)
-		__field(	char,	sync_commit		)
 		__field(	int,	transaction		)
 	),
 
 	TP_fast_assign(
 		__entry->dev		= journal->j_fs_dev->bd_dev;
-		__entry->sync_commit = commit_transaction->t_synchronous_commit;
 		__entry->transaction	= commit_transaction->t_tid;
 	),
 
-	TP_printk("dev %d,%d transaction %d sync %d",
+	TP_printk("dev %d,%d transaction %d",
 		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  __entry->transaction, __entry->sync_commit)
+		  __entry->transaction)
 );
 
 DEFINE_EVENT(jbd_commit, jbd_start_commit,
@@ -87,19 +85,17 @@ TRACE_EVENT(jbd_drop_transaction,
 
 	TP_STRUCT__entry(
 		__field(	dev_t,	dev			)
-		__field(	char,	sync_commit		)
 		__field(	int,	transaction		)
 	),
 
 	TP_fast_assign(
 		__entry->dev		= journal->j_fs_dev->bd_dev;
-		__entry->sync_commit = commit_transaction->t_synchronous_commit;
 		__entry->transaction	= commit_transaction->t_tid;
 	),
 
-	TP_printk("dev %d,%d transaction %d sync %d",
+	TP_printk("dev %d,%d transaction %d",
 		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  __entry->transaction, __entry->sync_commit)
+		  __entry->transaction)
 );
 
 TRACE_EVENT(jbd_end_commit,
@@ -109,21 +105,19 @@ TRACE_EVENT(jbd_end_commit,
 
 	TP_STRUCT__entry(
 		__field(	dev_t,	dev			)
-		__field(	char,	sync_commit		)
 		__field(	int,	transaction		)
 		__field(	int,	head			)
 	),
 
 	TP_fast_assign(
 		__entry->dev		= journal->j_fs_dev->bd_dev;
-		__entry->sync_commit = commit_transaction->t_synchronous_commit;
 		__entry->transaction	= commit_transaction->t_tid;
 		__entry->head		= journal->j_tail_sequence;
 	),
 
-	TP_printk("dev %d,%d transaction %d sync %d head %d",
+	TP_printk("dev %d,%d transaction %d head %d",
 		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		  __entry->transaction, __entry->sync_commit, __entry->head)
+		  __entry->transaction, __entry->head)
 );
 
 TRACE_EVENT(jbd_do_submit_data,
@@ -133,19 +127,17 @@ TRACE_EVENT(jbd_do_submit_data,
 
 	TP_STRUCT__entry(
 		__field(	dev_t,	dev			)
-		__field(	char,	sync_commit		)
 		__field(	int,	transaction		)
 	),
 
 	TP_fast_assign(
 		__entry->dev		= journal->j_fs_dev->bd_dev;
-		__entry->sync_commit = commit_transaction->t_synchronous_commit;
 		__entry->transaction	= commit_transaction->t_tid;
 	),
 
-	TP_printk("dev %d,%d transaction %d sync %d",
+	TP_printk("dev %d,%d transaction %d",
 		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		   __entry->transaction, __entry->sync_commit)
+		   __entry->transaction)
 );
 
 TRACE_EVENT(jbd_cleanup_journal_tail,
@@ -177,24 +169,23 @@ TRACE_EVENT(jbd_cleanup_journal_tail,
 		  __entry->block_nr, __entry->freed)
 );
 
-TRACE_EVENT(jbd_update_superblock_end,
-	TP_PROTO(journal_t *journal, int wait),
+TRACE_EVENT(journal_write_superblock,
+	TP_PROTO(journal_t *journal, int write_op),
 
-	TP_ARGS(journal, wait),
+	TP_ARGS(journal, write_op),
 
 	TP_STRUCT__entry(
 		__field(	dev_t,	dev			)
-		__field(	int,	wait			)
+		__field(	int,	write_op		)
 	),
 
 	TP_fast_assign(
 		__entry->dev		= journal->j_fs_dev->bd_dev;
-		__entry->wait		= wait;
+		__entry->write_op	= write_op;
 	),
 
-	TP_printk("dev %d,%d wait %d",
-		  MAJOR(__entry->dev), MINOR(__entry->dev),
-		   __entry->wait)
+	TP_printk("dev %d,%d write_op %x", MAJOR(__entry->dev),
+		  MINOR(__entry->dev), __entry->write_op)
 );
 
 #endif /* _TRACE_JBD_H */
diff --git a/drivers/staging/lttng/instrumentation/events/mainline/jbd2.h b/drivers/staging/lttng/instrumentation/events/mainline/jbd2.h
index 7596441..127993d 100644
--- a/drivers/staging/lttng/instrumentation/events/mainline/jbd2.h
+++ b/drivers/staging/lttng/instrumentation/events/mainline/jbd2.h
@@ -81,6 +81,13 @@ DEFINE_EVENT(jbd2_commit, jbd2_commit_logging,
 	TP_ARGS(journal, commit_transaction)
 );
 
+DEFINE_EVENT(jbd2_commit, jbd2_drop_transaction,
+
+	TP_PROTO(journal_t *journal, transaction_t *commit_transaction),
+
+	TP_ARGS(journal, commit_transaction)
+);
+
 TRACE_EVENT(jbd2_end_commit,
 	TP_PROTO(journal_t *journal, transaction_t *commit_transaction),
 
@@ -200,7 +207,7 @@ TRACE_EVENT(jbd2_checkpoint_stats,
 		  __entry->forced_to_close, __entry->written, __entry->dropped)
 );
 
-TRACE_EVENT(jbd2_cleanup_journal_tail,
+TRACE_EVENT(jbd2_update_log_tail,
 
 	TP_PROTO(journal_t *journal, tid_t first_tid,
 		 unsigned long block_nr, unsigned long freed),
@@ -229,6 +236,26 @@ TRACE_EVENT(jbd2_cleanup_journal_tail,
 		  __entry->block_nr, __entry->freed)
 );
 
+TRACE_EVENT(jbd2_write_superblock,
+
+	TP_PROTO(journal_t *journal, int write_op),
+
+	TP_ARGS(journal, write_op),
+
+	TP_STRUCT__entry(
+		__field(	dev_t,  dev			)
+		__field(	  int,  write_op		)
+	),
+
+	TP_fast_assign(
+		__entry->dev		= journal->j_fs_dev->bd_dev;
+		__entry->write_op	= write_op;
+	),
+
+	TP_printk("dev %d,%d write_op %x", MAJOR(__entry->dev),
+		  MINOR(__entry->dev), __entry->write_op)
+);
+
 #endif /* _TRACE_JBD2_H */
 
 /* This part must be outside protection */
diff --git a/drivers/staging/lttng/instrumentation/events/mainline/kmem.h b/drivers/staging/lttng/instrumentation/events/mainline/kmem.h
index a9c87ad..08fa272 100644
--- a/drivers/staging/lttng/instrumentation/events/mainline/kmem.h
+++ b/drivers/staging/lttng/instrumentation/events/mainline/kmem.h
@@ -147,7 +147,7 @@ DEFINE_EVENT(kmem_free, kmem_cache_free,
 	TP_ARGS(call_site, ptr)
 );
 
-TRACE_EVENT(mm_page_free_direct,
+TRACE_EVENT(mm_page_free,
 
 	TP_PROTO(struct page *page, unsigned int order),
 
@@ -169,7 +169,7 @@ TRACE_EVENT(mm_page_free_direct,
 			__entry->order)
 );
 
-TRACE_EVENT(mm_pagevec_free,
+TRACE_EVENT(mm_page_free_batched,
 
 	TP_PROTO(struct page *page, int cold),
 
@@ -214,7 +214,7 @@ TRACE_EVENT(mm_page_alloc,
 
 	TP_printk("page=%p pfn=%lu order=%d migratetype=%d gfp_flags=%s",
 		__entry->page,
-		page_to_pfn(__entry->page),
+		__entry->page ? page_to_pfn(__entry->page) : 0,
 		__entry->order,
 		__entry->migratetype,
 		show_gfp_flags(__entry->gfp_flags))
@@ -240,7 +240,7 @@ DECLARE_EVENT_CLASS(mm_page,
 
 	TP_printk("page=%p pfn=%lu order=%u migratetype=%d percpu_refill=%d",
 		__entry->page,
-		page_to_pfn(__entry->page),
+		__entry->page ? page_to_pfn(__entry->page) : 0,
 		__entry->order,
 		__entry->migratetype,
 		__entry->order == 0)
diff --git a/drivers/staging/lttng/instrumentation/events/mainline/power.h b/drivers/staging/lttng/instrumentation/events/mainline/power.h
index 1bcc2a8..0c97838 100644
--- a/drivers/staging/lttng/instrumentation/events/mainline/power.h
+++ b/drivers/staging/lttng/instrumentation/events/mainline/power.h
@@ -65,7 +65,40 @@ TRACE_EVENT(machine_suspend,
 	TP_printk("state=%lu", (unsigned long)__entry->state)
 );
 
-/* This code will be removed after deprecation time exceeded (2.6.41) */
+DECLARE_EVENT_CLASS(wakeup_source,
+
+	TP_PROTO(const char *name, unsigned int state),
+
+	TP_ARGS(name, state),
+
+	TP_STRUCT__entry(
+		__string(       name,           name            )
+		__field(        u64,            state           )
+	),
+
+	TP_fast_assign(
+		__assign_str(name, name);
+		__entry->state = state;
+	),
+
+	TP_printk("%s state=0x%lx", __get_str(name),
+		(unsigned long)__entry->state)
+);
+
+DEFINE_EVENT(wakeup_source, wakeup_source_activate,
+
+	TP_PROTO(const char *name, unsigned int state),
+
+	TP_ARGS(name, state)
+);
+
+DEFINE_EVENT(wakeup_source, wakeup_source_deactivate,
+
+	TP_PROTO(const char *name, unsigned int state),
+
+	TP_ARGS(name, state)
+);
+
 #ifdef CONFIG_EVENT_POWER_TRACING_DEPRECATED
 
 /*
@@ -151,6 +184,8 @@ enum {
    events get removed */
 static inline void trace_power_start(u64 type, u64 state, u64 cpuid) {};
 static inline void trace_power_end(u64 cpuid) {};
+static inline void trace_power_start_rcuidle(u64 type, u64 state, u64 cpuid) {};
+static inline void trace_power_end_rcuidle(u64 cpuid) {};
 static inline void trace_power_frequency(u64 type, u64 state, u64 cpuid) {};
 #endif /* _PWR_EVENT_AVOID_DOUBLE_DEFINING_DEPRECATED */
 
diff --git a/drivers/staging/lttng/instrumentation/events/mainline/sched.h b/drivers/staging/lttng/instrumentation/events/mainline/sched.h
index 6700ecc..ea7a203 100644
--- a/drivers/staging/lttng/instrumentation/events/mainline/sched.h
+++ b/drivers/staging/lttng/instrumentation/events/mainline/sched.h
@@ -6,6 +6,7 @@
 
 #include <linux/sched.h>
 #include <linux/tracepoint.h>
+#include <linux/binfmts.h>
 
 /*
  * Tracepoint for calling kthread_stop, performed to end a kthread:
@@ -100,7 +101,7 @@ static inline long __trace_sched_switch_state(struct task_struct *p)
 	 * For all intents and purposes a preempted task is a running task.
 	 */
 	if (task_thread_info(p)->preempt_count & PREEMPT_ACTIVE)
-		state = TASK_RUNNING;
+		state = TASK_RUNNING | TASK_STATE_MAX;
 #endif
 
 	return state;
@@ -137,13 +138,14 @@ TRACE_EVENT(sched_switch,
 		__entry->next_prio	= next->prio;
 	),
 
-	TP_printk("prev_comm=%s prev_pid=%d prev_prio=%d prev_state=%s ==> next_comm=%s next_pid=%d next_prio=%d",
+	TP_printk("prev_comm=%s prev_pid=%d prev_prio=%d prev_state=%s%s ==> next_comm=%s next_pid=%d next_prio=%d",
 		__entry->prev_comm, __entry->prev_pid, __entry->prev_prio,
-		__entry->prev_state ?
-		  __print_flags(__entry->prev_state, "|",
+		__entry->prev_state & (TASK_STATE_MAX-1) ?
+		  __print_flags(__entry->prev_state & (TASK_STATE_MAX-1), "|",
 				{ 1, "S"} , { 2, "D" }, { 4, "T" }, { 8, "t" },
 				{ 16, "Z" }, { 32, "X" }, { 64, "x" },
 				{ 128, "W" }) : "R",
+		__entry->prev_state & TASK_STATE_MAX ? "+" : "",
 		__entry->next_comm, __entry->next_pid, __entry->next_prio)
 );
 
@@ -356,6 +358,13 @@ DEFINE_EVENT(sched_stat_template, sched_stat_iowait,
 	     TP_ARGS(tsk, delay));
 
 /*
+ * Tracepoint for accounting blocked time (time the task is in uninterruptible).
+ */
+DEFINE_EVENT(sched_stat_template, sched_stat_blocked,
+	     TP_PROTO(struct task_struct *tsk, u64 delay),
+	     TP_ARGS(tsk, delay));
+
+/*
  * Tracepoint for accounting runtime (time the task is executing
  * on a CPU).
  */
diff --git a/drivers/staging/lttng/instrumentation/events/mainline/signal.h b/drivers/staging/lttng/instrumentation/events/mainline/signal.h
index 17df434..39a8a43 100644
--- a/drivers/staging/lttng/instrumentation/events/mainline/signal.h
+++ b/drivers/staging/lttng/instrumentation/events/mainline/signal.h
@@ -23,11 +23,23 @@
 		}						\
 	} while (0)
 
+#ifndef TRACE_HEADER_MULTI_READ
+enum {
+	TRACE_SIGNAL_DELIVERED,
+	TRACE_SIGNAL_IGNORED,
+	TRACE_SIGNAL_ALREADY_PENDING,
+	TRACE_SIGNAL_OVERFLOW_FAIL,
+	TRACE_SIGNAL_LOSE_INFO,
+};
+#endif
+
 /**
  * signal_generate - called when a signal is generated
  * @sig: signal number
  * @info: pointer to struct siginfo
  * @task: pointer to struct task_struct
+ * @group: shared or private
+ * @result: TRACE_SIGNAL_*
  *
  * Current process sends a 'sig' signal to 'task' process with
  * 'info' siginfo. If 'info' is SEND_SIG_NOINFO or SEND_SIG_PRIV,
@@ -37,9 +49,10 @@
  */
 TRACE_EVENT(signal_generate,
 
-	TP_PROTO(int sig, struct siginfo *info, struct task_struct *task),
+	TP_PROTO(int sig, struct siginfo *info, struct task_struct *task,
+			int group, int result),
 
-	TP_ARGS(sig, info, task),
+	TP_ARGS(sig, info, task, group, result),
 
 	TP_STRUCT__entry(
 		__field(	int,	sig			)
@@ -47,6 +60,8 @@ TRACE_EVENT(signal_generate,
 		__field(	int,	code			)
 		__array(	char,	comm,	TASK_COMM_LEN	)
 		__field(	pid_t,	pid			)
+		__field(	int,	group			)
+		__field(	int,	result			)
 	),
 
 	TP_fast_assign(
@@ -54,11 +69,14 @@ TRACE_EVENT(signal_generate,
 		TP_STORE_SIGINFO(__entry, info);
 		memcpy(__entry->comm, task->comm, TASK_COMM_LEN);
 		__entry->pid	= task->pid;
+		__entry->group	= group;
+		__entry->result	= result;
 	),
 
-	TP_printk("sig=%d errno=%d code=%d comm=%s pid=%d",
+	TP_printk("sig=%d errno=%d code=%d comm=%s pid=%d grp=%d res=%d",
 		  __entry->sig, __entry->errno, __entry->code,
-		  __entry->comm, __entry->pid)
+		  __entry->comm, __entry->pid, __entry->group,
+		  __entry->result)
 );
 
 /**
@@ -101,65 +119,6 @@ TRACE_EVENT(signal_deliver,
 		  __entry->sa_handler, __entry->sa_flags)
 );
 
-DECLARE_EVENT_CLASS(signal_queue_overflow,
-
-	TP_PROTO(int sig, int group, struct siginfo *info),
-
-	TP_ARGS(sig, group, info),
-
-	TP_STRUCT__entry(
-		__field(	int,	sig	)
-		__field(	int,	group	)
-		__field(	int,	errno	)
-		__field(	int,	code	)
-	),
-
-	TP_fast_assign(
-		__entry->sig	= sig;
-		__entry->group	= group;
-		TP_STORE_SIGINFO(__entry, info);
-	),
-
-	TP_printk("sig=%d group=%d errno=%d code=%d",
-		  __entry->sig, __entry->group, __entry->errno, __entry->code)
-);
-
-/**
- * signal_overflow_fail - called when signal queue is overflow
- * @sig: signal number
- * @group: signal to process group or not (bool)
- * @info: pointer to struct siginfo
- *
- * Kernel fails to generate 'sig' signal with 'info' siginfo, because
- * siginfo queue is overflow, and the signal is dropped.
- * 'group' is not 0 if the signal will be sent to a process group.
- * 'sig' is always one of RT signals.
- */
-DEFINE_EVENT(signal_queue_overflow, signal_overflow_fail,
-
-	TP_PROTO(int sig, int group, struct siginfo *info),
-
-	TP_ARGS(sig, group, info)
-);
-
-/**
- * signal_lose_info - called when siginfo is lost
- * @sig: signal number
- * @group: signal to process group or not (bool)
- * @info: pointer to struct siginfo
- *
- * Kernel generates 'sig' signal but loses 'info' siginfo, because siginfo
- * queue is overflow.
- * 'group' is not 0 if the signal will be sent to a process group.
- * 'sig' is always one of non-RT signals.
- */
-DEFINE_EVENT(signal_queue_overflow, signal_lose_info,
-
-	TP_PROTO(int sig, int group, struct siginfo *info),
-
-	TP_ARGS(sig, group, info)
-);
-
 #endif /* _TRACE_SIGNAL_H */
 
 /* This part must be outside protection */
diff --git a/drivers/staging/lttng/instrumentation/events/mainline/vmscan.h b/drivers/staging/lttng/instrumentation/events/mainline/vmscan.h
index 36851f7..bab3b87 100644
--- a/drivers/staging/lttng/instrumentation/events/mainline/vmscan.h
+++ b/drivers/staging/lttng/instrumentation/events/mainline/vmscan.h
@@ -13,7 +13,7 @@
 #define RECLAIM_WB_ANON		0x0001u
 #define RECLAIM_WB_FILE		0x0002u
 #define RECLAIM_WB_MIXED	0x0010u
-#define RECLAIM_WB_SYNC		0x0004u
+#define RECLAIM_WB_SYNC		0x0004u /* Unused, all reclaim async */
 #define RECLAIM_WB_ASYNC	0x0008u
 
 #define show_reclaim_flags(flags)				\
@@ -25,15 +25,15 @@
 		{RECLAIM_WB_ASYNC,	"RECLAIM_WB_ASYNC"}	\
 		) : "RECLAIM_WB_NONE"
 
-#define trace_reclaim_flags(page, sync) ( \
+#define trace_reclaim_flags(page) ( \
 	(page_is_file_cache(page) ? RECLAIM_WB_FILE : RECLAIM_WB_ANON) | \
-	(sync & RECLAIM_MODE_SYNC ? RECLAIM_WB_SYNC : RECLAIM_WB_ASYNC)   \
+	(RECLAIM_WB_ASYNC) \
 	)
 
-#define trace_shrink_flags(file, sync) ( \
-	(sync & RECLAIM_MODE_SYNC ? RECLAIM_WB_MIXED : \
-			(file ? RECLAIM_WB_FILE : RECLAIM_WB_ANON)) |  \
-	(sync & RECLAIM_MODE_SYNC ? RECLAIM_WB_SYNC : RECLAIM_WB_ASYNC) \
+#define trace_shrink_flags(file) \
+	( \
+		(file ? RECLAIM_WB_FILE : RECLAIM_WB_ANON) | \
+		(RECLAIM_WB_ASYNC) \
 	)
 
 TRACE_EVENT(mm_vmscan_kswapd_sleep,
@@ -263,22 +263,18 @@ DECLARE_EVENT_CLASS(mm_vmscan_lru_isolate_template,
 		unsigned long nr_requested,
 		unsigned long nr_scanned,
 		unsigned long nr_taken,
-		unsigned long nr_lumpy_taken,
-		unsigned long nr_lumpy_dirty,
-		unsigned long nr_lumpy_failed,
-		int isolate_mode),
+		isolate_mode_t isolate_mode,
+		int file),
 
-	TP_ARGS(order, nr_requested, nr_scanned, nr_taken, nr_lumpy_taken, nr_lumpy_dirty, nr_lumpy_failed, isolate_mode),
+	TP_ARGS(order, nr_requested, nr_scanned, nr_taken, isolate_mode, file),
 
 	TP_STRUCT__entry(
 		__field(int, order)
 		__field(unsigned long, nr_requested)
 		__field(unsigned long, nr_scanned)
 		__field(unsigned long, nr_taken)
-		__field(unsigned long, nr_lumpy_taken)
-		__field(unsigned long, nr_lumpy_dirty)
-		__field(unsigned long, nr_lumpy_failed)
-		__field(int, isolate_mode)
+		__field(isolate_mode_t, isolate_mode)
+		__field(int, file)
 	),
 
 	TP_fast_assign(
@@ -286,21 +282,17 @@ DECLARE_EVENT_CLASS(mm_vmscan_lru_isolate_template,
 		__entry->nr_requested = nr_requested;
 		__entry->nr_scanned = nr_scanned;
 		__entry->nr_taken = nr_taken;
-		__entry->nr_lumpy_taken = nr_lumpy_taken;
-		__entry->nr_lumpy_dirty = nr_lumpy_dirty;
-		__entry->nr_lumpy_failed = nr_lumpy_failed;
 		__entry->isolate_mode = isolate_mode;
+		__entry->file = file;
 	),
 
-	TP_printk("isolate_mode=%d order=%d nr_requested=%lu nr_scanned=%lu nr_taken=%lu contig_taken=%lu contig_dirty=%lu contig_failed=%lu",
+	TP_printk("isolate_mode=%d order=%d nr_requested=%lu nr_scanned=%lu nr_taken=%lu file=%d",
 		__entry->isolate_mode,
 		__entry->order,
 		__entry->nr_requested,
 		__entry->nr_scanned,
 		__entry->nr_taken,
-		__entry->nr_lumpy_taken,
-		__entry->nr_lumpy_dirty,
-		__entry->nr_lumpy_failed)
+		__entry->file)
 );
 
 DEFINE_EVENT(mm_vmscan_lru_isolate_template, mm_vmscan_lru_isolate,
@@ -309,12 +301,10 @@ DEFINE_EVENT(mm_vmscan_lru_isolate_template, mm_vmscan_lru_isolate,
 		unsigned long nr_requested,
 		unsigned long nr_scanned,
 		unsigned long nr_taken,
-		unsigned long nr_lumpy_taken,
-		unsigned long nr_lumpy_dirty,
-		unsigned long nr_lumpy_failed,
-		int isolate_mode),
+		isolate_mode_t isolate_mode,
+		int file),
 
-	TP_ARGS(order, nr_requested, nr_scanned, nr_taken, nr_lumpy_taken, nr_lumpy_dirty, nr_lumpy_failed, isolate_mode)
+	TP_ARGS(order, nr_requested, nr_scanned, nr_taken, isolate_mode, file)
 
 );
 
@@ -324,12 +314,10 @@ DEFINE_EVENT(mm_vmscan_lru_isolate_template, mm_vmscan_memcg_isolate,
 		unsigned long nr_requested,
 		unsigned long nr_scanned,
 		unsigned long nr_taken,
-		unsigned long nr_lumpy_taken,
-		unsigned long nr_lumpy_dirty,
-		unsigned long nr_lumpy_failed,
-		int isolate_mode),
+		isolate_mode_t isolate_mode,
+		int file),
 
-	TP_ARGS(order, nr_requested, nr_scanned, nr_taken, nr_lumpy_taken, nr_lumpy_dirty, nr_lumpy_failed, isolate_mode)
+	TP_ARGS(order, nr_requested, nr_scanned, nr_taken, isolate_mode, file)
 
 );
 
@@ -389,88 +377,6 @@ TRACE_EVENT(mm_vmscan_lru_shrink_inactive,
 		show_reclaim_flags(__entry->reclaim_flags))
 );
 
-TRACE_EVENT(replace_swap_token,
-	TP_PROTO(struct mm_struct *old_mm,
-		 struct mm_struct *new_mm),
-
-	TP_ARGS(old_mm, new_mm),
-
-	TP_STRUCT__entry(
-		__field(struct mm_struct*,	old_mm)
-		__field(unsigned int,		old_prio)
-		__field(struct mm_struct*,	new_mm)
-		__field(unsigned int,		new_prio)
-	),
-
-	TP_fast_assign(
-		__entry->old_mm   = old_mm;
-		__entry->old_prio = old_mm ? old_mm->token_priority : 0;
-		__entry->new_mm   = new_mm;
-		__entry->new_prio = new_mm->token_priority;
-	),
-
-	TP_printk("old_token_mm=%p old_prio=%u new_token_mm=%p new_prio=%u",
-		  __entry->old_mm, __entry->old_prio,
-		  __entry->new_mm, __entry->new_prio)
-);
-
-DECLARE_EVENT_CLASS(put_swap_token_template,
-	TP_PROTO(struct mm_struct *swap_token_mm),
-
-	TP_ARGS(swap_token_mm),
-
-	TP_STRUCT__entry(
-		__field(struct mm_struct*, swap_token_mm)
-	),
-
-	TP_fast_assign(
-		__entry->swap_token_mm = swap_token_mm;
-	),
-
-	TP_printk("token_mm=%p", __entry->swap_token_mm)
-);
-
-DEFINE_EVENT(put_swap_token_template, put_swap_token,
-	TP_PROTO(struct mm_struct *swap_token_mm),
-	TP_ARGS(swap_token_mm)
-);
-
-DEFINE_EVENT_CONDITION(put_swap_token_template, disable_swap_token,
-	TP_PROTO(struct mm_struct *swap_token_mm),
-	TP_ARGS(swap_token_mm),
-	TP_CONDITION(swap_token_mm != NULL)
-);
-
-TRACE_EVENT_CONDITION(update_swap_token_priority,
-	TP_PROTO(struct mm_struct *mm,
-		 unsigned int old_prio,
-		 struct mm_struct *swap_token_mm),
-
-	TP_ARGS(mm, old_prio, swap_token_mm),
-
-	TP_CONDITION(mm->token_priority != old_prio),
-
-	TP_STRUCT__entry(
-		__field(struct mm_struct*, mm)
-		__field(unsigned int, old_prio)
-		__field(unsigned int, new_prio)
-		__field(struct mm_struct*, swap_token_mm)
-		__field(unsigned int, swap_token_prio)
-	),
-
-	TP_fast_assign(
-		__entry->mm		= mm;
-		__entry->old_prio	= old_prio;
-		__entry->new_prio	= mm->token_priority;
-		__entry->swap_token_mm	= swap_token_mm;
-		__entry->swap_token_prio = swap_token_mm ? swap_token_mm->token_priority : 0;
-	),
-
-	TP_printk("mm=%p old_prio=%u new_prio=%u swap_token_mm=%p token_prio=%u",
-		  __entry->mm, __entry->old_prio, __entry->new_prio,
-		  __entry->swap_token_mm, __entry->swap_token_prio)
-);
-
 #endif /* _TRACE_VMSCAN_H */
 
 /* This part must be outside protection */
diff --git a/drivers/staging/lttng/probes/Makefile b/drivers/staging/lttng/probes/Makefile
index c39a84a..779616d 100644
--- a/drivers/staging/lttng/probes/Makefile
+++ b/drivers/staging/lttng/probes/Makefile
@@ -24,23 +24,23 @@ endif
 
 obj-m +=  $(shell \
 	if [ $(VERSION) -ge 3 \
-		-o \( $(VERSION) -eq 2 -a $(PATCHLEVEL) -ge 6 -a $(SUBLEVEL) -ge 35 \) ] ; then \
+		-o \( $(VERSION) -eq 2 -a $(PATCHLEVEL) -ge 6 -a $(SUBLEVEL) -ge 33 \) ] ; then \
 		echo "lttng-probe-signal.o" ; fi;)
 
 ifneq ($(CONFIG_BLOCK),)
 ifneq ($(CONFIG_EVENT_TRACING),)	# need blk_cmd_buf_len
-obj-m +=  $(shell \
-	if [ $(VERSION) -ge 3 \
-		-o \( $(VERSION) -eq 2 -a $(PATCHLEVEL) -ge 6 -a $(SUBLEVEL) -ge 38 \) ] ; then \
-		echo "lttng-probe-block.o" ; fi;)
+obj-m += lttng-probe-block.o
 endif
 endif
 
 ifneq ($(CONFIG_NET),)
-obj-m += lttng-probe-net.o
 obj-m += lttng-probe-napi.o
 obj-m += lttng-probe-skb.o
 obj-m +=  $(shell \
+	if [ $(VERSION) -ge 3 \
+		-o \( $(VERSION) -eq 2 -a $(PATCHLEVEL) -ge 6 -a $(SUBLEVEL) -ge 37 \) ] ; then \
+		echo "lttng-probe-net.o" ; fi;)
+obj-m +=  $(shell \
 	if [ $(VERSION) -ge 3 -a $(PATCHLEVEL) -ge 1 ] ; then \
 		echo "lttng-probe-sock.o" ; fi;)
 obj-m +=  $(shell \
@@ -56,9 +56,22 @@ obj-m +=  $(shell \
 endif
 
 ifneq ($(CONFIG_EXT3_FS),)
-obj-m +=  $(shell \
+ext3_dep = $(srctree)/fs/ext3/*.h
+ext3_dep_check = $(wildcard $(ext3_dep))
+ext3 = $(shell \
 	if [ $(VERSION) -ge 3 -a $(PATCHLEVEL) -ge 1 ] ; then \
-		echo "lttng-probe-ext3.o" ; fi;)
+		if [ $(VERSION) -ge 3 -a $(PATCHLEVEL) -ge 4 -a \
+			-z "$(ext3_dep_check)" ] ; then \
+			echo "warn" ; \
+			exit ; \
+		fi; \
+		echo "lttng-probe-ext3.o" ; \
+	fi;)
+ifeq ($(ext3),warn)
+$(warning Files $(ext3_dep) not found. Probe "ext3" is disabled. Use full kernel source tree to enable it.)
+ext3 =
+endif
+obj-m += $(ext3)
 endif
 
 ifneq ($(CONFIG_GPIOLIB),)
@@ -86,12 +99,14 @@ endif
 
 ifneq ($(CONFIG_SCSI),)
 obj-m +=  $(shell \
-	if [ $(VERSION) -ge 3 ] ; then \
+	if [ $(VERSION) -ge 3 \
+		-o \( $(VERSION) -eq 2 -a $(PATCHLEVEL) -ge 6 -a $(SUBLEVEL) -ge 35 \) ] ; then \
 		echo "lttng-probe-scsi.o" ; fi;)
 endif
 
 vmscan = $(shell \
-	if [ $(VERSION) -ge 3 ] ; then \
+	if [ $(VERSION) -ge 3 \
+		-o \( $(VERSION) -eq 2 -a $(PATCHLEVEL) -ge 6 -a $(SUBLEVEL) -ge 36 \) ] ; then \
 		echo "lttng-probe-vmscan.o" ; fi;)
 ifneq ($(CONFIG_SWAP),)
 	obj-m += $(vmscan)
@@ -101,9 +116,11 @@ ifneq ($(CONFIG_CGROUP_MEM_RES_CTLR),)
 endif
 endif
 
-ifneq ($(CONFIG_LOCKDEP),)
-obj-m += lttng-probe-lock.o
-endif
+# lock probe does not work, so disabling it for now
+#ifneq ($(CONFIG_LOCKDEP),)
+#obj-m += lttng-probe-lock.o
+#endif
+
 
 ifneq ($(CONFIG_KPROBES),)
 obj-m += lttng-kprobes.o
diff --git a/drivers/staging/lttng/probes/lttng-probe-asoc.c b/drivers/staging/lttng/probes/lttng-probe-asoc.c
index 427639f..ad54a37 100644
--- a/drivers/staging/lttng/probes/lttng-probe-asoc.c
+++ b/drivers/staging/lttng/probes/lttng-probe-asoc.c
@@ -1,5 +1,5 @@
 /*
- * probes/lttng-probe-block.c
+ * probes/lttng-probe-asoc.c
  *
  * LTTng asoc probes.
  *
@@ -41,5 +41,5 @@
 #include "../instrumentation/events/lttng-module/asoc.h"
 
 MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com> and Paul Woegerer <paul_woegerer@mentor.com>");
+MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com>, Paul Woegerer <paul_woegerer@mentor.com>, and Andrew Gabbasov <andrew_gabbasov@mentor.com>");
 MODULE_DESCRIPTION("LTTng asoc probes");
diff --git a/drivers/staging/lttng/probes/lttng-probe-block.c b/drivers/staging/lttng/probes/lttng-probe-block.c
index c0c2702..3eb668f 100644
--- a/drivers/staging/lttng/probes/lttng-probe-block.c
+++ b/drivers/staging/lttng/probes/lttng-probe-block.c
@@ -29,6 +29,8 @@
  */
 #include <trace/events/block.h>
 
+#include "../wrapper/tracepoint.h"
+
 /*
  * Create LTTng tracepoint probes.
  */
diff --git a/drivers/staging/lttng/probes/lttng-probe-ext3.c b/drivers/staging/lttng/probes/lttng-probe-ext3.c
index 0df2b67..87c8cfb 100644
--- a/drivers/staging/lttng/probes/lttng-probe-ext3.c
+++ b/drivers/staging/lttng/probes/lttng-probe-ext3.c
@@ -27,20 +27,16 @@
 #include <linux/version.h>
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
-/*
- * Since 3.4 the is no linux/ext3_fs_i.h anymore. Instead we have to use
- * ext3.h from fs/ext3/ext3.h (which also includes trace/events/ext3.h)
- */
-#include "../instrumentation/events/mainline/fs_ext3.h"
+#include <../fs/ext3/ext3.h>
 #else
 #include <linux/ext3_fs_i.h>
+#endif
 
 /*
  * Create the tracepoint static inlines from the kernel to validate that our
  * trace event macros match the kernel we run on.
  */
 #include <trace/events/ext3.h>
-#endif
 
 /*
  * Create LTTng tracepoint probes.
@@ -52,5 +48,5 @@
 #include "../instrumentation/events/lttng-module/ext3.h"
 
 MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com> and Paul Woegerer <paul_woegerer@mentor.com>");
+MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com>, Paul Woegerer <paul_woegerer@mentor.com>, and Andrew Gabbasov <andrew_gabbasov@mentor.com>");
 MODULE_DESCRIPTION("LTTng ext3 probes");
diff --git a/drivers/staging/lttng/probes/lttng-probe-irq.c b/drivers/staging/lttng/probes/lttng-probe-irq.c
index afcd1d2..bdd78fb3 100644
--- a/drivers/staging/lttng/probes/lttng-probe-irq.c
+++ b/drivers/staging/lttng/probes/lttng-probe-irq.c
@@ -22,7 +22,6 @@
 
 #include <linux/module.h>
 #include <linux/interrupt.h>
-#include "../wrapper/tracepoint.h"
 
 /*
  * Create the tracepoint static inlines from the kernel to validate that our
@@ -30,6 +29,8 @@
  */
 #include <trace/events/irq.h>
 
+#include "../wrapper/tracepoint.h"
+
 /*
  * Create LTTng tracepoint probes.
  */
diff --git a/drivers/staging/lttng/probes/lttng-probe-jbd.c b/drivers/staging/lttng/probes/lttng-probe-jbd.c
index 46911cc..dc94894 100644
--- a/drivers/staging/lttng/probes/lttng-probe-jbd.c
+++ b/drivers/staging/lttng/probes/lttng-probe-jbd.c
@@ -22,7 +22,6 @@
  */
 
 #include <linux/module.h>
-#include <linux/version.h>
 
 /*
  * Create the tracepoint static inlines from the kernel to validate that our
@@ -40,5 +39,5 @@
 #include "../instrumentation/events/lttng-module/jbd.h"
 
 MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com> and Paul Woegerer <paul_woegerer@mentor.com>");
+MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com>, Paul Woegerer <paul_woegerer@mentor.com>, and Andrew Gabbasov <andrew_gabbasov@mentor.com>");
 MODULE_DESCRIPTION("LTTng jbd probes");
diff --git a/drivers/staging/lttng/probes/lttng-probe-jbd2.c b/drivers/staging/lttng/probes/lttng-probe-jbd2.c
index eea0a66..30ccf3f 100644
--- a/drivers/staging/lttng/probes/lttng-probe-jbd2.c
+++ b/drivers/staging/lttng/probes/lttng-probe-jbd2.c
@@ -29,6 +29,8 @@
  */
 #include <trace/events/jbd2.h>
 
+#include "../wrapper/tracepoint.h"
+
 /*
  * Create LTTng tracepoint probes.
  */
@@ -39,5 +41,5 @@
 #include "../instrumentation/events/lttng-module/jbd2.h"
 
 MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com>");
+MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com> and Andrew Gabbasov <andrew_gabbasov@mentor.com>");
 MODULE_DESCRIPTION("LTTng jbd2 probes");
diff --git a/drivers/staging/lttng/probes/lttng-probe-kmem.c b/drivers/staging/lttng/probes/lttng-probe-kmem.c
index af67759..441df75 100644
--- a/drivers/staging/lttng/probes/lttng-probe-kmem.c
+++ b/drivers/staging/lttng/probes/lttng-probe-kmem.c
@@ -29,6 +29,8 @@
  */
 #include <trace/events/kmem.h>
 
+#include "../wrapper/tracepoint.h"
+
 /*
  * Create LTTng tracepoint probes.
  */
@@ -39,5 +41,5 @@
 #include "../instrumentation/events/lttng-module/kmem.h"
 
 MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com>");
+MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com> and Andrew Gabbasov <andrew_gabbasov@mentor.com>");
 MODULE_DESCRIPTION("LTTng kmem probes");
diff --git a/drivers/staging/lttng/probes/lttng-probe-kvm.c b/drivers/staging/lttng/probes/lttng-probe-kvm.c
index 3b59fa1..bdec187 100644
--- a/drivers/staging/lttng/probes/lttng-probe-kvm.c
+++ b/drivers/staging/lttng/probes/lttng-probe-kvm.c
@@ -29,6 +29,8 @@
  */
 #include <trace/events/kvm.h>
 
+#include "../wrapper/tracepoint.h"
+
 /*
  * Create LTTng tracepoint probes.
  */
diff --git a/drivers/staging/lttng/probes/lttng-probe-lock.c b/drivers/staging/lttng/probes/lttng-probe-lock.c
index 16ac0e7..b95e0c5 100644
--- a/drivers/staging/lttng/probes/lttng-probe-lock.c
+++ b/drivers/staging/lttng/probes/lttng-probe-lock.c
@@ -22,12 +22,19 @@
  */
 
 #include <linux/module.h>
+#include <linux/version.h>
 
 /*
  * Create the tracepoint static inlines from the kernel to validate that our
  * trace event macros match the kernel we run on.
  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
 #include <trace/events/lock.h>
+#else
+#include <trace/events/lockdep.h>
+#endif
+
+#include "../wrapper/tracepoint.h"
 
 /*
  * Create LTTng tracepoint probes.
@@ -39,5 +46,5 @@
 #include "../instrumentation/events/lttng-module/lock.h"
 
 MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com>");
+MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com> and Andrew Gabbasov <andrew_gabbasov@mentor.com>");
 MODULE_DESCRIPTION("LTTng lock probes");
diff --git a/drivers/staging/lttng/probes/lttng-probe-module.c b/drivers/staging/lttng/probes/lttng-probe-module.c
index 1a3c255..3594001 100644
--- a/drivers/staging/lttng/probes/lttng-probe-module.c
+++ b/drivers/staging/lttng/probes/lttng-probe-module.c
@@ -29,6 +29,8 @@
  */
 #include <trace/events/module.h>
 
+#include "../wrapper/tracepoint.h"
+
 /*
  * Create LTTng tracepoint probes.
  */
@@ -39,5 +41,5 @@
 #include "../instrumentation/events/lttng-module/module.h"
 
 MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com>");
+MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com> and Andrew Gabbasov <andrew_gabbasov@mentor.com>");
 MODULE_DESCRIPTION("LTTng module probes");
diff --git a/drivers/staging/lttng/probes/lttng-probe-napi.c b/drivers/staging/lttng/probes/lttng-probe-napi.c
index cae8504..47371a8 100644
--- a/drivers/staging/lttng/probes/lttng-probe-napi.c
+++ b/drivers/staging/lttng/probes/lttng-probe-napi.c
@@ -29,6 +29,8 @@
  */
 #include <trace/events/napi.h>
 
+#include "../wrapper/tracepoint.h"
+
 /*
  * Create LTTng tracepoint probes.
  */
diff --git a/drivers/staging/lttng/probes/lttng-probe-power.c b/drivers/staging/lttng/probes/lttng-probe-power.c
index 5dcb93f..ff25a8a 100644
--- a/drivers/staging/lttng/probes/lttng-probe-power.c
+++ b/drivers/staging/lttng/probes/lttng-probe-power.c
@@ -29,6 +29,8 @@
  */
 #include <trace/events/power.h>
 
+#include "../wrapper/tracepoint.h"
+
 /*
  * Create LTTng tracepoint probes.
  */
@@ -39,5 +41,5 @@
 #include "../instrumentation/events/lttng-module/power.h"
 
 MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com>");
+MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com> and Andrew Gabbasov <andrew_gabbasov@mentor.com>");
 MODULE_DESCRIPTION("LTTng power probes");
diff --git a/drivers/staging/lttng/probes/lttng-probe-sched.c b/drivers/staging/lttng/probes/lttng-probe-sched.c
index caef6f7..8a72e14 100644
--- a/drivers/staging/lttng/probes/lttng-probe-sched.c
+++ b/drivers/staging/lttng/probes/lttng-probe-sched.c
@@ -21,7 +21,6 @@
  */
 
 #include <linux/module.h>
-#include "../wrapper/tracepoint.h"
 
 /*
  * Create the tracepoint static inlines from the kernel to validate that our
@@ -29,6 +28,8 @@
  */
 #include <trace/events/sched.h>
 
+#include "../wrapper/tracepoint.h"
+
 /*
  * Create LTTng tracepoint probes.
  */
diff --git a/drivers/staging/lttng/probes/lttng-probe-scsi.c b/drivers/staging/lttng/probes/lttng-probe-scsi.c
index 51702c3..57677c6 100644
--- a/drivers/staging/lttng/probes/lttng-probe-scsi.c
+++ b/drivers/staging/lttng/probes/lttng-probe-scsi.c
@@ -40,5 +40,5 @@
 #include "../instrumentation/events/lttng-module/scsi.h"
 
 MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com>");
+MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com> and Andrew Gabbasov <andrew_gabbasov@mentor.com>");
 MODULE_DESCRIPTION("LTTng scsi probes");
diff --git a/drivers/staging/lttng/probes/lttng-probe-skb.c b/drivers/staging/lttng/probes/lttng-probe-skb.c
index 52edf88..71e890d 100644
--- a/drivers/staging/lttng/probes/lttng-probe-skb.c
+++ b/drivers/staging/lttng/probes/lttng-probe-skb.c
@@ -29,6 +29,8 @@
  */
 #include <trace/events/skb.h>
 
+#include "../wrapper/tracepoint.h"
+
 /*
  * Create LTTng tracepoint probes.
  */
@@ -39,5 +41,5 @@
 #include "../instrumentation/events/lttng-module/skb.h"
 
 MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com>");
+MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com> and Andrew Gabbasov <andrew_gabbasov@mentor.com>");
 MODULE_DESCRIPTION("LTTng skb probes");
diff --git a/drivers/staging/lttng/probes/lttng-probe-timer.c b/drivers/staging/lttng/probes/lttng-probe-timer.c
index 9cf7492..299f630 100644
--- a/drivers/staging/lttng/probes/lttng-probe-timer.c
+++ b/drivers/staging/lttng/probes/lttng-probe-timer.c
@@ -21,7 +21,6 @@
  */
 
 #include <linux/module.h>
-#include "../wrapper/tracepoint.h"
 
 /*
  * Create the tracepoint static inlines from the kernel to validate that our
@@ -31,6 +30,8 @@
 #include <linux/sched.h>
 #include <trace/events/timer.h>
 
+#include "../wrapper/tracepoint.h"
+
 /*
  * Create LTTng tracepoint probes.
  */
diff --git a/drivers/staging/lttng/probes/lttng-probe-vmscan.c b/drivers/staging/lttng/probes/lttng-probe-vmscan.c
index 4f5739c..d5892a4 100644
--- a/drivers/staging/lttng/probes/lttng-probe-vmscan.c
+++ b/drivers/staging/lttng/probes/lttng-probe-vmscan.c
@@ -22,7 +22,6 @@
  */
 
 #include <linux/module.h>
-#include <linux/version.h>
 
 /*
  * Create the tracepoint static inlines from the kernel to validate that our
@@ -39,13 +38,8 @@
 #define CREATE_TRACE_POINTS
 #define TRACE_INCLUDE_PATH ../instrumentation/events/lttng-module
 
-#if ((LINUX_VERSION_CODE <= KERNEL_VERSION(3,0,38)) || \
-	LTTNG_KERNEL_RANGE(3,1,0, 3,2,0))
-typedef int isolate_mode_t;
-#endif
-
 #include "../instrumentation/events/lttng-module/vmscan.h"
 
 MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com> and Paul Woegerer <paul_woegerer@mentor.com>");
+MODULE_AUTHOR("Wade Farnsworth <wade_farnsworth@mentor.com>, Paul Woegerer <paul_woegerer@mentor.com>, and Andrew Gabbasov <andrew_gabbasov@mentor.com>");
 MODULE_DESCRIPTION("LTTng vmscan probes");
-- 
2.0.2

