From 65ed95869b19a662f5fce3308072cc971188676d Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Thu, 9 Dec 2010 15:54:13 -0500
Subject: [PATCH 031/757] Move old probes to discard/

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
---
 drivers/staging/lttng/discard/probes/Makefile      |  47 ++
 drivers/staging/lttng/discard/probes/block-trace.c | 309 +++++++++++
 drivers/staging/lttng/discard/probes/ext4-trace.c  | 611 +++++++++++++++++++++
 drivers/staging/lttng/discard/probes/fs-trace.c    | 158 ++++++
 drivers/staging/lttng/discard/probes/ipc-trace.c   |  39 ++
 drivers/staging/lttng/discard/probes/jbd2-trace.c  | 208 +++++++
 .../staging/lttng/discard/probes/kernel-trace.c    | 581 ++++++++++++++++++++
 .../staging/lttng/discard/probes/lockdep-trace.c   |  60 ++
 drivers/staging/lttng/discard/probes/mm-trace.c    | 146 +++++
 .../lttng/discard/probes/net-extended-trace.c      | 146 +++++
 drivers/staging/lttng/discard/probes/net-trace.c   | 406 ++++++++++++++
 drivers/staging/lttng/discard/probes/pm-trace.c    |  43 ++
 drivers/staging/lttng/discard/probes/rcu-trace.c   |  36 ++
 .../staging/lttng/discard/probes/syscall-trace.c   |  54 ++
 drivers/staging/lttng/discard/probes/trap-trace.c  |  56 ++
 drivers/staging/lttng/probes/Makefile              |  47 --
 drivers/staging/lttng/probes/block-trace.c         | 309 -----------
 drivers/staging/lttng/probes/ext4-trace.c          | 611 ---------------------
 drivers/staging/lttng/probes/fs-trace.c            | 158 ------
 drivers/staging/lttng/probes/ipc-trace.c           |  39 --
 drivers/staging/lttng/probes/jbd2-trace.c          | 208 -------
 drivers/staging/lttng/probes/kernel-trace.c        | 581 --------------------
 drivers/staging/lttng/probes/lockdep-trace.c       |  60 --
 drivers/staging/lttng/probes/mm-trace.c            | 146 -----
 drivers/staging/lttng/probes/net-extended-trace.c  | 146 -----
 drivers/staging/lttng/probes/net-trace.c           | 406 --------------
 drivers/staging/lttng/probes/pm-trace.c            |  43 --
 drivers/staging/lttng/probes/rcu-trace.c           |  36 --
 drivers/staging/lttng/probes/syscall-trace.c       |  54 --
 drivers/staging/lttng/probes/trap-trace.c          |  56 --
 30 files changed, 2900 insertions(+), 2900 deletions(-)
 create mode 100644 drivers/staging/lttng/discard/probes/Makefile
 create mode 100644 drivers/staging/lttng/discard/probes/block-trace.c
 create mode 100644 drivers/staging/lttng/discard/probes/ext4-trace.c
 create mode 100644 drivers/staging/lttng/discard/probes/fs-trace.c
 create mode 100644 drivers/staging/lttng/discard/probes/ipc-trace.c
 create mode 100644 drivers/staging/lttng/discard/probes/jbd2-trace.c
 create mode 100644 drivers/staging/lttng/discard/probes/kernel-trace.c
 create mode 100644 drivers/staging/lttng/discard/probes/lockdep-trace.c
 create mode 100644 drivers/staging/lttng/discard/probes/mm-trace.c
 create mode 100644 drivers/staging/lttng/discard/probes/net-extended-trace.c
 create mode 100644 drivers/staging/lttng/discard/probes/net-trace.c
 create mode 100644 drivers/staging/lttng/discard/probes/pm-trace.c
 create mode 100644 drivers/staging/lttng/discard/probes/rcu-trace.c
 create mode 100644 drivers/staging/lttng/discard/probes/syscall-trace.c
 create mode 100644 drivers/staging/lttng/discard/probes/trap-trace.c
 delete mode 100644 drivers/staging/lttng/probes/Makefile
 delete mode 100644 drivers/staging/lttng/probes/block-trace.c
 delete mode 100644 drivers/staging/lttng/probes/ext4-trace.c
 delete mode 100644 drivers/staging/lttng/probes/fs-trace.c
 delete mode 100644 drivers/staging/lttng/probes/ipc-trace.c
 delete mode 100644 drivers/staging/lttng/probes/jbd2-trace.c
 delete mode 100644 drivers/staging/lttng/probes/kernel-trace.c
 delete mode 100644 drivers/staging/lttng/probes/lockdep-trace.c
 delete mode 100644 drivers/staging/lttng/probes/mm-trace.c
 delete mode 100644 drivers/staging/lttng/probes/net-extended-trace.c
 delete mode 100644 drivers/staging/lttng/probes/net-trace.c
 delete mode 100644 drivers/staging/lttng/probes/pm-trace.c
 delete mode 100644 drivers/staging/lttng/probes/rcu-trace.c
 delete mode 100644 drivers/staging/lttng/probes/syscall-trace.c
 delete mode 100644 drivers/staging/lttng/probes/trap-trace.c

diff --git a/drivers/staging/lttng/discard/probes/Makefile b/drivers/staging/lttng/discard/probes/Makefile
new file mode 100644
index 0000000..d8f1c40
--- /dev/null
+++ b/drivers/staging/lttng/discard/probes/Makefile
@@ -0,0 +1,47 @@
+# LTTng tracing probes
+
+ifdef CONFIG_FTRACE
+CFLAGS_REMOVE_kernel-trace.o = -pg
+CFLAGS_REMOVE_mm-trace.o = -pg
+CFLAGS_REMOVE_fs-trace.o = -pg
+CFLAGS_REMOVE_ipc-trace.o = -pg
+CFLAGS_REMOVE_lockdep-trace.o = -pg
+CFLAGS_REMOVE_rcu-trace.o = -pg
+CFLAGS_REMOVE_syscall-trace.o = -pg
+CFLAGS_REMOVE_trap-trace.o = -pg
+CFLAGS_REMOVE_pm-trace.o = -pg
+endif
+
+obj-m += kernel-trace.o mm-trace.o fs-trace.o ipc-trace.o lockdep-trace.o \
+	 rcu-trace.o syscall-trace.o trap-trace.o pm-trace.o
+
+ifeq ($(CONFIG_NET),y)
+ifdef CONFIG_FTRACE
+CFLAGS_REMOVE_net-trace.o = -pg
+CFLAGS_REMOVE_net-extended-trace.o = -pg
+endif
+obj-m += net-trace.o net-extended-trace.o
+endif
+
+ifdef CONFIG_JBD2
+ifdef CONFIG_FTRACE
+CFLAGS_REMOVE_jbd2-trace.o = -pg
+endif
+obj-m += jbd2-trace.o
+endif
+
+#ifdef CONFIG_EXT4_FS
+#ifdef CONFIG_FTRACE
+#CFLAGS_REMOVE_ext4-trace.o = -pg
+#endif
+#obj-$(CONFIG_LTT_TRACEPROBES)	+= ext4-trace.o
+#endif
+
+ifdef CONFIG_BLOCK
+ifdef CONFIG_FTRACE
+CFLAGS_REMOVE_block-trace.o = -pg
+endif
+obj-m += block-trace.o
+endif
+
+
diff --git a/drivers/staging/lttng/discard/probes/block-trace.c b/drivers/staging/lttng/discard/probes/block-trace.c
new file mode 100644
index 0000000..51ae2cd
--- /dev/null
+++ b/drivers/staging/lttng/discard/probes/block-trace.c
@@ -0,0 +1,309 @@
+/*
+ * ltt/probes/block-trace.c
+ *
+ * block layer tracepoint probes.
+ *
+ * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+
+#include <trace/events/block.h>
+
+/*
+ * Add rq cmd as a sequence. Needs new type. (size + binary blob)
+ */
+
+void probe_block_rq_abort(void *data, struct request_queue *q, struct request *rq)
+{
+	int rw = rq->cmd_flags & 0x03;
+
+	if (blk_discard_rq(rq))
+		rw |= (1 << BIO_RW_DISCARD);
+
+	if (blk_pc_request(rq)) {
+		trace_mark_tp(block, rq_abort_pc, block_rq_abort,
+			probe_block_rq_abort,
+			"data_len %u rw %d errors %d",
+			blk_rq_bytes(rq), rw, rq->errors);
+	} else {
+		/*
+		 * FIXME Using a simple trace_mark for the second event
+		 * possibility because tracepoints do not support multiple
+		 * connections to the same probe yet. They should have some
+		 * refcounting. Need to enable both rq_abort_pc and rq_abort_fs
+		 * markers to have the rq_abort_fs marker enabled.
+		 */
+		trace_mark(block, rq_abort_fs,
+			"hard_sector %llu "
+			"rw %d errors %d", (unsigned long long)blk_rq_pos(rq),
+			rw, rq->errors);
+	}
+}
+
+void probe_block_rq_insert(void *data, struct request_queue *q, struct request *rq)
+{
+	int rw = rq->cmd_flags & 0x03;
+
+	if (blk_discard_rq(rq))
+		rw |= (1 << BIO_RW_DISCARD);
+
+	if (blk_pc_request(rq)) {
+		trace_mark_tp(block, rq_insert_pc, block_rq_insert,
+			probe_block_rq_insert,
+			"data_len %u rw %d errors %d",
+			blk_rq_bytes(rq), rw, rq->errors);
+	} else {
+		/*
+		 * FIXME Using a simple trace_mark for the second event
+		 * possibility because tracepoints do not support multiple
+		 * connections to the same probe yet. They should have some
+		 * refcounting. Need to enable both rq_insert_pc and
+		 * rq_insert_fs markers to have the rq_insert_fs marker enabled.
+		 */
+		trace_mark(block, rq_insert_fs,
+			"hard_sector %llu "
+			"rw %d errors %d", (unsigned long long)blk_rq_pos(rq),
+			rw, rq->errors);
+	}
+}
+
+void probe_block_rq_issue(void *data, struct request_queue *q, struct request *rq)
+{
+	int rw = rq->cmd_flags & 0x03;
+
+	if (blk_discard_rq(rq))
+		rw |= (1 << BIO_RW_DISCARD);
+
+	if (blk_pc_request(rq)) {
+		trace_mark_tp(block, rq_issue_pc, block_rq_issue,
+			probe_block_rq_issue,
+			"data_len %u rw %d errors %d",
+			blk_rq_bytes(rq), rw, rq->errors);
+	} else {
+		/*
+		 * FIXME Using a simple trace_mark for the second event
+		 * possibility because tracepoints do not support multiple
+		 * connections to the same probe yet. They should have some
+		 * refcounting. Need to enable both rq_issue_pc and rq_issue_fs
+		 * markers to have the rq_issue_fs marker enabled.
+		 */
+		trace_mark(block, rq_issue_fs,
+			"hard_sector %llu "
+			"rw %d errors %d", (unsigned long long)blk_rq_pos(rq),
+			rw, rq->errors);
+	}
+}
+
+void probe_block_rq_requeue(void *data, struct request_queue *q, struct request *rq)
+{
+	int rw = rq->cmd_flags & 0x03;
+
+	if (blk_discard_rq(rq))
+		rw |= (1 << BIO_RW_DISCARD);
+
+	if (blk_pc_request(rq)) {
+		trace_mark_tp(block, rq_requeue_pc, block_rq_requeue,
+			probe_block_rq_requeue,
+			"data_len %u rw %d errors %d",
+			blk_rq_bytes(rq), rw, rq->errors);
+	} else {
+		/*
+		 * FIXME Using a simple trace_mark for the second event
+		 * possibility because tracepoints do not support multiple
+		 * connections to the same probe yet. They should have some
+		 * refcounting. Need to enable both rq_requeue_pc and
+		 * rq_requeue_fs markers to have the rq_requeue_fs marker
+		 * enabled.
+		 */
+		trace_mark(block, rq_requeue_fs,
+			"hard_sector %llu "
+			"rw %d errors %d", (unsigned long long)blk_rq_pos(rq),
+			rw, rq->errors);
+	}
+}
+
+void probe_block_rq_complete(void *data, struct request_queue *q, struct request *rq)
+{
+	int rw = rq->cmd_flags & 0x03;
+
+	if (blk_discard_rq(rq))
+		rw |= (1 << BIO_RW_DISCARD);
+
+	if (blk_pc_request(rq)) {
+		trace_mark_tp(block, rq_complete_pc, block_rq_complete,
+			probe_block_rq_complete,
+			"data_len %u rw %d errors %d",
+			blk_rq_bytes(rq), rw, rq->errors);
+	} else {
+		/*
+		 * FIXME Using a simple trace_mark for the second event
+		 * possibility because tracepoints do not support multiple
+		 * connections to the same probe yet. They should have some
+		 * refcounting. Need to enable both rq_complete_pc and
+		 * rq_complete_fs markers to have the rq_complete_fs marker
+		 * enabled.
+		 */
+		trace_mark(block, rq_complete_fs,
+			"hard_sector %llu "
+			"rw %d errors %d", (unsigned long long)blk_rq_pos(rq),
+			rw, rq->errors);
+	}
+}
+
+void probe_block_bio_bounce(void *data, struct request_queue *q, struct bio *bio)
+{
+	trace_mark_tp(block, bio_bounce, block_bio_bounce,
+		probe_block_bio_bounce,
+		"sector %llu size %u rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
+		"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
+		"not_uptodate #1u%d",
+		(unsigned long long)bio->bi_sector, bio->bi_size,
+		bio->bi_rw, !bio_flagged(bio, BIO_UPTODATE));
+}
+
+void probe_block_bio_complete(void *data, struct request_queue *q, struct bio *bio)
+{
+	trace_mark_tp(block, bio_complete, block_bio_complete,
+		probe_block_bio_complete,
+		"sector %llu size %u rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
+		"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
+		"not_uptodate #1u%d",
+		(unsigned long long)bio->bi_sector, bio->bi_size,
+		bio->bi_rw, !bio_flagged(bio, BIO_UPTODATE));
+}
+
+void probe_block_bio_backmerge(void *data, struct request_queue *q, struct bio *bio)
+{
+	trace_mark_tp(block, bio_backmerge, block_bio_backmerge,
+		probe_block_bio_backmerge,
+		"sector %llu size %u rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
+		"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
+		"not_uptodate #1u%d",
+		(unsigned long long)bio->bi_sector, bio->bi_size,
+		bio->bi_rw, !bio_flagged(bio, BIO_UPTODATE));
+}
+
+void probe_block_bio_frontmerge(void *data, struct request_queue *q, struct bio *bio)
+{
+	trace_mark_tp(block, bio_frontmerge, block_bio_frontmerge,
+		probe_block_bio_frontmerge,
+		"sector %llu size %u rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
+		"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
+		"not_uptodate #1u%d",
+		(unsigned long long)bio->bi_sector, bio->bi_size,
+		bio->bi_rw, !bio_flagged(bio, BIO_UPTODATE));
+}
+
+void probe_block_bio_queue(void *data, struct request_queue *q, struct bio *bio)
+{
+	trace_mark_tp(block, bio_queue, block_bio_queue,
+		probe_block_bio_queue,
+		"sector %llu size %u rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
+		"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
+		"not_uptodate #1u%d",
+		(unsigned long long)bio->bi_sector, bio->bi_size,
+		bio->bi_rw, !bio_flagged(bio, BIO_UPTODATE));
+}
+
+void probe_block_getrq(void *data, struct request_queue *q, struct bio *bio, int rw)
+{
+	if (bio) {
+		trace_mark_tp(block, getrq_bio, block_getrq,
+			probe_block_getrq,
+			"sector %llu size %u "
+			"rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
+			"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
+			"not_uptodate #1u%d",
+			(unsigned long long)bio->bi_sector, bio->bi_size,
+			bio->bi_rw, !bio_flagged(bio, BIO_UPTODATE));
+	} else {
+		/*
+		 * FIXME Using a simple trace_mark for the second event
+		 * possibility because tracepoints do not support multiple
+		 * connections to the same probe yet. They should have some
+		 * refcounting. Need to enable both getrq_bio and getrq markers
+		 * to have the getrq marker enabled.
+		 */
+		trace_mark(block, getrq, "rw %d", rw);
+	}
+}
+
+void probe_block_sleeprq(void *data, struct request_queue *q, struct bio *bio, int rw)
+{
+	if (bio) {
+		trace_mark_tp(block, sleeprq_bio, block_sleeprq,
+			probe_block_sleeprq,
+			"sector %llu size %u "
+			"rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
+			"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
+			"not_uptodate #1u%d",
+			(unsigned long long)bio->bi_sector, bio->bi_size,
+			bio->bi_rw, !bio_flagged(bio, BIO_UPTODATE));
+	} else {
+		/*
+		 * FIXME Using a simple trace_mark for the second event
+		 * possibility because tracepoints do not support multiple
+		 * connections to the same probe yet. They should have some
+		 * refcounting. Need to enable both sleeprq_bio and sleeprq
+		 * markers to have the sleeprq marker enabled.
+		 */
+		trace_mark(block, sleeprq, "rw %d", rw);
+	}
+}
+
+void probe_block_plug(void *data, struct request_queue *q)
+{
+	trace_mark_tp(block, plug, block_plug, probe_block_plug,
+			 MARK_NOARGS);
+}
+
+void probe_block_unplug_io(void *data, struct request_queue *q)
+{
+	unsigned int pdu = q->rq.count[READ] + q->rq.count[WRITE];
+
+	trace_mark_tp(block, unplug_io, block_unplug_io, probe_block_unplug_io,
+			"pdu %u", pdu);
+}
+
+void probe_block_unplug_timer(void *data, struct request_queue *q)
+{
+	unsigned int pdu = q->rq.count[READ] + q->rq.count[WRITE];
+
+	trace_mark_tp(block, unplug_timer, block_unplug_timer,
+			probe_block_unplug_timer,
+			"pdu %u", pdu);
+}
+
+void probe_block_split(void *data, struct request_queue *q, struct bio *bio,
+		       unsigned int pdu)
+{
+	trace_mark_tp(block, split, block_split,
+		probe_block_split,
+		"sector %llu size %u rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
+		"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
+		"not_uptodate #1u%d pdu %u",
+		(unsigned long long)bio->bi_sector, bio->bi_size,
+		bio->bi_rw, !bio_flagged(bio, BIO_UPTODATE), pdu);
+}
+
+void probe_block_remap(void *data, struct request_queue *q, struct bio *bio,
+		       dev_t dev, sector_t from)
+{
+	trace_mark_tp(block, remap, block_remap,
+		probe_block_remap,
+		"device_from %lu sector_from %llu device_to %lu "
+		"size %u rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
+		"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
+		"not_uptodate #1u%d",
+		(unsigned long)bio->bi_bdev->bd_dev,
+		(unsigned long long)from,
+		(unsigned long)dev,
+		bio->bi_size, bio->bi_rw,
+		!bio_flagged(bio, BIO_UPTODATE));
+}
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("Block Tracepoint Probes");
diff --git a/drivers/staging/lttng/discard/probes/ext4-trace.c b/drivers/staging/lttng/discard/probes/ext4-trace.c
new file mode 100644
index 0000000..83683e7
--- /dev/null
+++ b/drivers/staging/lttng/discard/probes/ext4-trace.c
@@ -0,0 +1,611 @@
+/*
+ * ltt/probes/ext4-trace.c
+ *
+ * ext4 tracepoint probes.
+ *
+ * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+#include <linux/writeback.h>
+#include <linux/debugfs.h>
+#include <linux/mutex.h>
+#include <linux/rcupdate.h>
+#include <trace/events/ext4.h>
+
+#include "../ltt-tracer.h"
+#include "../../fs/ext4/mballoc.h"
+
+static struct dentry *ext4_filter_dentry, *ext4_filter_dev_dentry,
+	*ext4_filter_inode_dentry;
+static DEFINE_MUTEX(ext4_filter_mutex);
+/* Make sure we don't race between module exit and file write */
+static int module_exits;
+
+struct rcu_dev_filter {
+	struct rcu_head rcu;
+	char devname[NAME_MAX];
+};
+
+static struct rcu_dev_filter *dev_filter;
+/* ~0UL inode_filter enables all inodes */
+static unsigned long inode_filter = ~0UL;
+
+/*
+ * Probes are executed in rcu_sched read-side critical section.
+ */
+
+static int do_dev_filter(const char *dev)
+{
+	struct rcu_dev_filter *ldev_filter = rcu_dereference(dev_filter);
+
+	if (unlikely(ldev_filter))
+		if (unlikely(strcmp(ldev_filter->devname, dev)))
+			return 0;
+	return 1;
+}
+
+static int do_inode_filter(unsigned long ino)
+{
+	if (unlikely(inode_filter != ~0UL))
+		if (unlikely(inode_filter != ino))
+			return 0;
+	return 1;
+}
+
+/*
+ * Logical AND between dev and inode filter.
+ */
+static int do_filter(const char *dev, unsigned long ino)
+{
+	if (unlikely(!do_dev_filter(dev)))
+		return 0;
+	if (unlikely(!do_inode_filter(ino)))
+		return 0;
+	return 1;
+}
+
+
+void probe_ext4_free_inode(void *data, struct inode *inode)
+{
+	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
+		return;
+	trace_mark_tp(ext4, free_inode, ext4_free_inode,
+		probe_ext4_free_inode,
+		"dev %s ino %lu mode %d uid %lu gid %lu blocks %llu",
+		inode->i_sb->s_id, inode->i_ino, inode->i_mode,
+		(unsigned long) inode->i_uid, (unsigned long) inode->i_gid,
+		(unsigned long long) inode->i_blocks);
+}
+
+void probe_ext4_request_inode(void *data, struct inode *dir, int mode)
+{
+	if (unlikely(!do_filter(dir->i_sb->s_id, dir->i_ino)))
+		return;
+	trace_mark_tp(ext4, request_inode, ext4_request_inode,
+		probe_ext4_request_inode,
+		"dev %s dir %lu mode %d",
+		dir->i_sb->s_id, dir->i_ino, mode);
+}
+
+void probe_ext4_allocate_inode(void *data, struct inode *inode, struct inode *dir, int mode)
+{
+	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)
+		     && !do_filter(dir->i_sb->s_id, dir->i_ino)))
+		return;
+	trace_mark_tp(ext4, allocate_inode, ext4_allocate_inode,
+		probe_ext4_allocate_inode,
+		"dev %s ino %lu dir %lu mode %d",
+		dir->i_sb->s_id, inode->i_ino, dir->i_ino, mode);
+}
+
+void probe_ext4_write_begin(void *data, struct inode *inode, loff_t pos, unsigned int len,
+			    unsigned int flags)
+{
+	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
+		return;
+	trace_mark_tp(ext4, write_begin, ext4_write_begin,
+		probe_ext4_write_begin,
+		"dev %s ino %lu pos %llu len %u flags %u",
+		inode->i_sb->s_id, inode->i_ino,
+		(unsigned long long) pos, len, flags);
+}
+
+void probe_ext4_ordered_write_end(void *data, struct inode *inode, loff_t pos,
+			    unsigned int len, unsigned int copied)
+{
+	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
+		return;
+	trace_mark_tp(ext4, ordered_write_end, ext4_ordered_write_end,
+		probe_ext4_ordered_write_end,
+		"dev %s ino %lu pos %llu len %u copied %u",
+		inode->i_sb->s_id, inode->i_ino,
+		(unsigned long long) pos, len, copied);
+}
+
+void probe_ext4_writeback_write_end(void *data, struct inode *inode, loff_t pos,
+			    unsigned int len, unsigned int copied)
+{
+	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
+		return;
+	trace_mark_tp(ext4, writeback_write_end, ext4_writeback_write_end,
+		probe_ext4_writeback_write_end,
+		"dev %s ino %lu pos %llu len %u copied %u",
+		inode->i_sb->s_id, inode->i_ino,
+		(unsigned long long) pos, len, copied);
+}
+
+void probe_ext4_journalled_write_end(void *data, struct inode *inode, loff_t pos,
+			    unsigned int len, unsigned int copied)
+{
+	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
+		return;
+	trace_mark_tp(ext4, journalled_write_end, ext4_journalled_write_end,
+		probe_ext4_journalled_write_end,
+		"dev %s ino %lu pos %llu len %u copied %u",
+		inode->i_sb->s_id, inode->i_ino,
+		(unsigned long long) pos, len, copied);
+}
+
+/*
+ * note : wbc_flags will have to be decoded by userspace.
+ * #1x uses a single byte in the trace. Limits to 8 bits.
+ */
+void probe_ext4_da_writepages(void *data, struct inode *inode,
+			      struct writeback_control *wbc)
+{
+	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
+		return;
+	trace_mark_tp(ext4, da_writepages, ext4_da_writepages,
+		probe_ext4_da_writepages,
+		"dev %s ino %lu nr_to_write %ld "
+		"pages_skipped %ld range_start %llu range_end %llu "
+		"wbc_flags(nonblocking,for_kupdate,"
+		"for_reclaim,range_cyclic) #1x%u",
+		inode->i_sb->s_id, inode->i_ino, wbc->nr_to_write,
+		wbc->pages_skipped,
+		(unsigned long long) wbc->range_start,
+		(unsigned long long) wbc->range_end,
+		  (wbc->nonblocking << 3)
+		| (wbc->for_kupdate << 2)
+		| (wbc->for_reclaim << 1)
+		| wbc->range_cyclic);
+}
+
+/*
+ * note : wbc_flags will have to be decoded by userspace.
+ * #1x uses a single byte in the trace. Limits to 8 bits.
+ */
+void probe_ext4_da_writepages_result(void *data, struct inode *inode,
+				     struct writeback_control *wbc,
+				     int ret, int pages_written)
+{
+	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
+		return;
+	trace_mark_tp(ext4, da_writepages_result, ext4_da_writepages_result,
+		probe_ext4_da_writepages_result,
+		"dev %s ino %lu ret %d pages_written %d "
+		"pages_skipped %ld "
+		"wbc_flags(encountered_congestion,"
+		"more_io,no_nrwrite_index_update) #1x%u",
+		inode->i_sb->s_id, inode->i_ino, ret, pages_written,
+		wbc->pages_skipped,
+		  (wbc->encountered_congestion << 2)
+		| (wbc->more_io << 1)
+		| wbc->no_nrwrite_index_update);
+}
+
+void probe_ext4_da_write_begin(void *data, struct inode *inode, loff_t pos,
+			    unsigned int len, unsigned int flags)
+{
+	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
+		return;
+	trace_mark_tp(ext4, da_write_begin, ext4_da_write_begin,
+		probe_ext4_da_write_begin,
+		"dev %s ino %lu pos %llu len %u flags %u",
+		inode->i_sb->s_id, inode->i_ino,
+		(unsigned long long) pos, len, flags);
+}
+
+void probe_ext4_da_write_end(void *data, struct inode *inode, loff_t pos,
+			    unsigned int len, unsigned int copied)
+{
+	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
+		return;
+	trace_mark_tp(ext4, da_write_end, ext4_da_write_end,
+		probe_ext4_da_write_end,
+		"dev %s ino %lu pos %llu len %u copied %u",
+		inode->i_sb->s_id, inode->i_ino,
+		(unsigned long long) pos, len, copied);
+}
+
+void probe_ext4_discard_blocks(void *data, struct super_block *sb, unsigned long long blk,
+			       unsigned long long count)
+{
+	if (unlikely(!do_dev_filter(sb->s_id)))
+		return;
+	trace_mark_tp(ext4, discard_blocks, ext4_discard_blocks,
+		probe_ext4_discard_blocks,
+		"dev %s blk %llu count %llu",
+		sb->s_id, blk, count);
+}
+
+void probe_ext4_mb_new_inode_pa(void *data, struct ext4_allocation_context *ac,
+			        struct ext4_prealloc_space *pa)
+{
+	if (unlikely(!do_filter(ac->ac_sb->s_id, ac->ac_inode->i_ino)))
+		return;
+	trace_mark_tp(ext4, mb_new_inode_pa, ext4_mb_new_inode_pa,
+		probe_ext4_mb_new_inode_pa,
+		"dev %s ino %lu pstart %llu len %u lstart %u",
+		ac->ac_sb->s_id, ac->ac_inode->i_ino, pa->pa_pstart,
+		pa->pa_len, pa->pa_lstart);
+}
+
+void probe_ext4_mb_new_group_pa(void *data, struct ext4_allocation_context *ac,
+			        struct ext4_prealloc_space *pa)
+{
+	if (unlikely(!do_dev_filter(ac->ac_sb->s_id)))
+		return;
+	trace_mark_tp(ext4, mb_new_group_pa, ext4_mb_new_group_pa,
+		probe_ext4_mb_new_group_pa,
+		"dev %s pstart %llu len %u lstart %u",
+		ac->ac_sb->s_id, pa->pa_pstart,
+		pa->pa_len, pa->pa_lstart);
+}
+
+void probe_ext4_mb_release_inode_pa(void *data, struct ext4_allocation_context *ac,
+				    struct ext4_prealloc_space *pa,
+				    unsigned long long block,
+				    unsigned int count)
+{
+	if (unlikely(!do_filter(ac->ac_sb->s_id, ac->ac_inode->i_ino)))
+		return;
+	trace_mark_tp(ext4, mb_release_inode_pa, ext4_mb_release_inode_pa,
+		probe_ext4_mb_release_inode_pa,
+		"dev %s ino %lu block %llu count %u",
+		ac->ac_sb->s_id, pa->pa_inode->i_ino, block, count);
+}
+
+void probe_ext4_mb_release_group_pa(void *data, struct ext4_allocation_context *ac,
+				    struct ext4_prealloc_space *pa)
+{
+	if (unlikely(!do_dev_filter(ac->ac_sb->s_id)))
+		return;
+	trace_mark_tp(ext4, mb_release_group_pa, ext4_mb_release_group_pa,
+		probe_ext4_mb_release_group_pa,
+		"dev %s pstart %llu len %d",
+		ac->ac_sb->s_id, pa->pa_pstart, pa->pa_len);
+}
+
+void probe_ext4_discard_preallocations(void *data, struct inode *inode)
+{
+	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
+		return;
+	trace_mark_tp(ext4, discard_preallocations,
+		ext4_discard_preallocations,
+		probe_ext4_discard_preallocations,
+		"dev %s ino %lu",
+		inode->i_sb->s_id, inode->i_ino);
+}
+
+void probe_ext4_mb_discard_preallocations(void *data, struct super_block *sb, int needed)
+{
+	if (unlikely(!do_dev_filter(sb->s_id)))
+		return;
+	trace_mark_tp(ext4, mb_discard_preallocations,
+		ext4_mb_discard_preallocations,
+		probe_ext4_mb_discard_preallocations,
+		"dev %s needed %d",
+		sb->s_id, needed);
+}
+
+void probe_ext4_request_blocks(void *data, struct ext4_allocation_request *ar)
+{
+	if (ar->inode) {
+		if (unlikely(!do_filter(ar->inode->i_sb->s_id,
+					ar->inode->i_ino)))
+			return;
+	} else {
+		if (unlikely(!do_dev_filter(ar->inode->i_sb->s_id)))
+			return;
+	}
+	trace_mark_tp(ext4, request_blocks, ext4_request_blocks,
+		probe_ext4_request_blocks,
+		"dev %s flags %u len %u ino %lu "
+		"lblk %llu goal %llu lleft %llu lright %llu "
+		"pleft %llu pright %llu",
+		ar->inode->i_sb->s_id, ar->flags, ar->len,
+		ar->inode ? ar->inode->i_ino : 0,
+		(unsigned long long) ar->logical,
+		(unsigned long long) ar->goal,
+		(unsigned long long) ar->lleft,
+		(unsigned long long) ar->lright,
+		(unsigned long long) ar->pleft,
+		(unsigned long long) ar->pright);
+}
+
+void probe_ext4_allocate_blocks(void *data, struct ext4_allocation_request *ar,
+				unsigned long long block)
+{
+	if (ar->inode) {
+		if (unlikely(!do_filter(ar->inode->i_sb->s_id,
+					ar->inode->i_ino)))
+			return;
+	} else {
+		if (unlikely(!do_dev_filter(ar->inode->i_sb->s_id)))
+			return;
+	}
+	trace_mark_tp(ext4, allocate_blocks, ext4_allocate_blocks,
+		probe_ext4_allocate_blocks,
+		"dev %s block %llu flags %u len %u ino %lu "
+		"logical %llu goal %llu lleft %llu lright %llu "
+		"pleft %llu pright %llu",
+		ar->inode->i_sb->s_id, (unsigned long long) block,
+		ar->flags, ar->len, ar->inode ? ar->inode->i_ino : 0,
+		(unsigned long long) ar->logical,
+		(unsigned long long) ar->goal,
+		(unsigned long long) ar->lleft,
+		(unsigned long long) ar->lright,
+		(unsigned long long) ar->pleft,
+		(unsigned long long) ar->pright);
+}
+
+void probe_ext4_free_blocks(void *data, struct inode *inode, __u64 block,
+			    unsigned long count, int metadata)
+{
+	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
+		return;
+	trace_mark_tp(ext4, free_blocks, ext4_free_blocks,
+		probe_ext4_free_blocks,
+		"dev %s block %llu count %lu metadata %d ino %lu",
+		inode->i_sb->s_id, (unsigned long long)block,
+		count, metadata, inode->i_ino);
+}
+
+void probe_ext4_sync_file(void *data, struct file *file, struct dentry *dentry,
+			  int datasync)
+{
+	if (unlikely(!do_dev_filter(dentry->d_inode->i_sb->s_id)))
+		return;
+	if (unlikely(!do_inode_filter(dentry->d_inode->i_ino)
+			&& !do_inode_filter(dentry->d_parent->d_inode->i_ino)))
+		return;
+	trace_mark_tp(ext4, sync_file, ext4_sync_file,
+		probe_ext4_sync_file,
+		"dev %s datasync %d ino %ld parent %ld",
+		dentry->d_inode->i_sb->s_id, datasync, dentry->d_inode->i_ino,
+		dentry->d_parent->d_inode->i_ino);
+}
+
+void probe_ext4_sync_fs(void *data, struct super_block *sb, int wait)
+{
+	if (unlikely(!do_dev_filter(sb->s_id)))
+		return;
+	trace_mark_tp(ext4, sync_fs, ext4_sync_fs,
+		probe_ext4_sync_fs,
+		"dev %s wait %d",
+		sb->s_id, wait);
+}
+
+static void free_dev_filter(struct rcu_head *head)
+{
+	kfree(container_of(head, struct rcu_dev_filter, rcu));
+}
+
+static ssize_t dev_filter_op_write(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	int err = 0;
+	char buf[NAME_MAX];
+	int buf_size;
+	char name[NAME_MAX];
+	struct rcu_dev_filter *new, *old;
+
+	mutex_lock(&ext4_filter_mutex);
+	if (module_exits) {
+		err = -EPERM;
+		goto error;
+	}
+	buf_size = min(count, sizeof(buf) - 1);
+	err = copy_from_user(buf, user_buf, buf_size);
+	if (err)
+		goto error;
+	buf[buf_size] = 0;
+
+	if (sscanf(buf, "%s", name) != 1) {
+		err = -EPERM;
+		goto error;
+	}
+
+	old = dev_filter;
+
+	/* Empty string or * means all active */
+	if (name[0] == '\0' || (name[0] == '*' && name[1] == '\0')) {
+		new = NULL;
+	} else {
+		new = kmalloc(sizeof(*new), GFP_KERNEL);
+		strcpy(new->devname, name);
+	}
+
+	rcu_assign_pointer(dev_filter, new);
+	if (old)
+		call_rcu_sched(&old->rcu, free_dev_filter);
+
+	mutex_unlock(&ext4_filter_mutex);
+	return count;
+
+error:
+	mutex_unlock(&ext4_filter_mutex);
+	return err;
+}
+
+static ssize_t dev_filter_op_read(struct file *filp, char __user *buffer,
+	size_t count, loff_t *ppos)
+{
+	ssize_t bcount;
+	const char *devname;
+
+	mutex_lock(&ext4_filter_mutex);
+	if (!dev_filter)
+		devname = "*";
+	else
+		devname = dev_filter->devname;
+	bcount = simple_read_from_buffer(buffer, count, ppos,
+			devname, strlen(devname));
+	mutex_unlock(&ext4_filter_mutex);
+	return bcount;
+}
+
+static struct file_operations ext4_dev_file_operations = {
+	.write = dev_filter_op_write,
+	.read = dev_filter_op_read,
+};
+
+static ssize_t inode_filter_op_write(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	int err = 0;
+	char buf[NAME_MAX];
+	int buf_size;
+	char name[NAME_MAX];
+	unsigned long inode_num;
+
+	mutex_lock(&ext4_filter_mutex);
+	if (module_exits) {
+		err = -EPERM;
+		goto error;
+	}
+	buf_size = min(count, sizeof(buf) - 1);
+	err = copy_from_user(buf, user_buf, buf_size);
+	if (err)
+		goto error;
+	buf[buf_size] = 0;
+
+	if (sscanf(buf, "%s", name) != 1) {
+		err = -EPERM;
+		goto error;
+	}
+
+	/* Empty string or * means all active */
+	if (name[0] == '\0' || (name[0] == '*' && name[1] == '\0')) {
+		inode_filter = ~0UL;
+	} else {
+		if (sscanf(buf, "%lu", &inode_num) != 1) {
+			err = -EPERM;
+			goto error;
+		}
+		inode_filter = inode_num;
+	}
+
+	mutex_unlock(&ext4_filter_mutex);
+	return count;
+
+error:
+	mutex_unlock(&ext4_filter_mutex);
+	return err;
+}
+
+static ssize_t inode_filter_op_read(struct file *filp, char __user *buffer,
+	size_t count, loff_t *ppos)
+{
+	ssize_t bcount;
+	char inode_str[NAME_MAX];
+
+	mutex_lock(&ext4_filter_mutex);
+	if (inode_filter == ~0UL)
+		strcpy(inode_str, "*");
+	else {
+		bcount = snprintf(inode_str, sizeof(inode_str), "%lu",
+			       inode_filter);
+		if (bcount == sizeof(inode_str))
+			bcount = -ENOSPC;
+		if (bcount < 0)
+			goto end;
+	}
+	bcount = simple_read_from_buffer(buffer, count, ppos,
+			inode_str, strlen(inode_str));
+end:
+	mutex_unlock(&ext4_filter_mutex);
+	return bcount;
+}
+
+static struct file_operations ext4_inode_file_operations = {
+	.write = inode_filter_op_write,
+	.read = inode_filter_op_read,
+};
+
+static void release_filter_dev(void)
+{
+	struct rcu_dev_filter *old;
+
+	mutex_lock(&ext4_filter_mutex);
+	module_exits = 1;
+	old = dev_filter;
+	rcu_assign_pointer(dev_filter, NULL);
+	if (old)
+		call_rcu_sched(&old->rcu, free_dev_filter);
+	mutex_unlock(&ext4_filter_mutex);
+}
+
+static int __init filter_init(void)
+{
+	struct dentry *filter_root_dentry;
+	int err = 0;
+
+	filter_root_dentry = get_filter_root();
+	if (!filter_root_dentry) {
+		err = -ENOENT;
+		goto end;
+	}
+
+	ext4_filter_dentry = debugfs_create_dir("ext4", filter_root_dentry);
+
+	if (IS_ERR(ext4_filter_dentry) || !ext4_filter_dentry) {
+		printk(KERN_ERR "Failed to create ext4 filter file\n");
+		err = -ENOMEM;
+		goto end;
+	}
+
+	ext4_filter_dev_dentry = debugfs_create_file("dev", S_IWUSR,
+			ext4_filter_dentry, NULL, &ext4_dev_file_operations);
+	if (IS_ERR(ext4_filter_dev_dentry) || !ext4_filter_dev_dentry) {
+		printk(KERN_ERR "Failed to create ext4 dev filter file\n");
+		err = -ENOMEM;
+		goto release_filter_dentry;
+	}
+
+	ext4_filter_inode_dentry = debugfs_create_file("inode", S_IWUSR,
+			ext4_filter_dentry, NULL, &ext4_inode_file_operations);
+	if (IS_ERR(ext4_filter_inode_dentry) || !ext4_filter_inode_dentry) {
+		printk(KERN_ERR "Failed to create ext4 inode filter file\n");
+		err = -ENOMEM;
+		goto release_filter_dev_dentry;
+	}
+
+	goto end;
+
+release_filter_dev_dentry:
+	debugfs_remove(ext4_filter_dev_dentry);
+release_filter_dentry:
+	debugfs_remove(ext4_filter_dentry);
+	release_filter_dev();
+end:
+	return err;
+}
+
+static void __exit filter_exit(void)
+{
+	debugfs_remove(ext4_filter_dev_dentry);
+	debugfs_remove(ext4_filter_inode_dentry);
+	debugfs_remove(ext4_filter_dentry);
+	release_filter_dev();
+}
+
+module_init(filter_init);
+module_exit(filter_exit);
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("ext4 Tracepoint Probes");
diff --git a/drivers/staging/lttng/discard/probes/fs-trace.c b/drivers/staging/lttng/discard/probes/fs-trace.c
new file mode 100644
index 0000000..bca2827
--- /dev/null
+++ b/drivers/staging/lttng/discard/probes/fs-trace.c
@@ -0,0 +1,158 @@
+/*
+ * ltt/probes/fs-trace.c
+ *
+ * FS tracepoint probes.
+ *
+ * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+#include <linux/buffer_head.h>
+#include <trace/fs.h>
+
+#include "../ltt-type-serializer.h"
+
+void probe_fs_buffer_wait_start(void *_data, struct buffer_head *bh)
+{
+	trace_mark_tp(fs, buffer_wait_start, fs_buffer_wait_start,
+		probe_fs_buffer_wait_start, "bh %p", bh);
+}
+
+void probe_fs_buffer_wait_end(void *_data, struct buffer_head *bh)
+{
+	trace_mark_tp(fs, buffer_wait_end, fs_buffer_wait_end,
+		probe_fs_buffer_wait_end, "bh %p", bh);
+}
+
+void probe_fs_exec(void *_data, char *filename)
+{
+	trace_mark_tp(fs, exec, fs_exec, probe_fs_exec, "filename %s",
+		filename);
+}
+
+void probe_fs_ioctl(void *_data, unsigned int fd, unsigned int cmd, unsigned long arg)
+{
+	trace_mark_tp(fs, ioctl, fs_ioctl, probe_fs_ioctl,
+		"fd %u cmd %u arg %lu", fd, cmd, arg);
+}
+
+void probe_fs_open(void *_data, int fd, char *filename)
+{
+	trace_mark_tp(fs, open, fs_open, probe_fs_open,
+		"fd %d filename %s", fd, filename);
+}
+
+void probe_fs_close(void *_data, unsigned int fd)
+{
+	trace_mark_tp(fs, close, fs_close, probe_fs_close, "fd %u", fd);
+}
+
+void probe_fs_lseek(void *_data, unsigned int fd, long offset, unsigned int origin)
+{
+	trace_mark_tp(fs, lseek, fs_lseek, probe_fs_lseek,
+		"fd %u offset %ld origin %u", fd, offset, origin);
+}
+
+void probe_fs_llseek(void *_data, unsigned int fd, loff_t offset, unsigned int origin)
+{
+	trace_mark_tp(fs, llseek, fs_llseek, probe_fs_llseek,
+		"fd %u offset %lld origin %u", fd,
+		(long long)offset, origin);
+}
+
+void probe_fs_read(void *_data, unsigned int fd, char __user *buf, size_t count,
+		ssize_t ret);
+
+DEFINE_MARKER_TP(fs, read, fs_read, probe_fs_read,
+	"count %zu fd %u");
+
+notrace void probe_fs_read(void *_data, unsigned int fd, char __user *buf, size_t count,
+		ssize_t ret)
+{
+	struct marker *marker;
+	struct serialize_sizet_int data;
+
+	data.f1 = count;
+	data.f2 = fd;
+
+	marker = &GET_MARKER(fs, read);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(size_t));
+}
+
+void probe_fs_write(void *_data, unsigned int fd, char __user *buf, size_t count,
+		ssize_t ret);
+
+DEFINE_MARKER_TP(fs, write, fs_write, probe_fs_write,
+	"count %zu fd %u");
+
+notrace void probe_fs_write(void *_data, unsigned int fd, char __user *buf, size_t count,
+		ssize_t ret)
+{
+	struct marker *marker;
+	struct serialize_sizet_int data;
+
+	data.f1 = count;
+	data.f2 = fd;
+
+	marker = &GET_MARKER(fs, write);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(size_t));
+}
+
+void probe_fs_pread64(void *_data, unsigned int fd, char __user *buf, size_t count,
+		loff_t pos, ssize_t ret)
+{
+	trace_mark_tp(fs, pread64, fs_pread64, probe_fs_pread64,
+		"fd %u count %zu pos %llu",
+		fd, count, (unsigned long long)pos);
+}
+
+void probe_fs_pwrite64(void *_data, unsigned int fd, const char __user *buf,
+		size_t count, loff_t pos, ssize_t ret)
+{
+	trace_mark_tp(fs, pwrite64, fs_pwrite64, probe_fs_pwrite64,
+		"fd %u count %zu pos %llu",
+		fd, count, (unsigned long long)pos);
+}
+
+void probe_fs_readv(void *_data, unsigned long fd, const struct iovec __user *vec,
+		unsigned long vlen, ssize_t ret)
+{
+	trace_mark_tp(fs, readv, fs_readv, probe_fs_readv,
+		"fd %lu vlen %lu", fd, vlen);
+}
+
+void probe_fs_writev(void *_data, unsigned long fd, const struct iovec __user *vec,
+		unsigned long vlen, ssize_t ret)
+{
+	trace_mark_tp(fs, writev, fs_writev, probe_fs_writev,
+		"fd %lu vlen %lu", fd, vlen);
+}
+
+void probe_fs_select(void *_data, int fd, struct timespec *end_time)
+{
+	struct timespec tmptime;
+
+	if (end_time) {
+		tmptime = *end_time;
+	} else {
+		tmptime.tv_sec = -1L;
+		tmptime.tv_nsec = -1L;
+	}
+
+	trace_mark_tp(fs, select, fs_select, probe_fs_select,
+		"fd %d end_time_sec %ld end_time_nsec %ld", fd,
+			tmptime.tv_sec, tmptime.tv_nsec);
+}
+
+void probe_fs_poll(void *_data, int fd)
+{
+	trace_mark_tp(fs, pollfd, fs_poll, probe_fs_poll,
+		"fd %d", fd);
+}
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("FS Tracepoint Probes");
diff --git a/drivers/staging/lttng/discard/probes/ipc-trace.c b/drivers/staging/lttng/discard/probes/ipc-trace.c
new file mode 100644
index 0000000..3a09525
--- /dev/null
+++ b/drivers/staging/lttng/discard/probes/ipc-trace.c
@@ -0,0 +1,39 @@
+/*
+ * ltt/probes/ipc-trace.c
+ *
+ * IPC tracepoint probes.
+ *
+ * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+#include <trace/ipc.h>
+
+void probe_ipc_msg_create(void *data, long id, int flags)
+{
+	trace_mark_tp(ipc, msg_create, ipc_msg_create, probe_ipc_msg_create,
+		"id %ld flags %d", id, flags);
+}
+
+void probe_ipc_sem_create(void *data, long id, int flags)
+{
+	trace_mark_tp(ipc, sem_create, ipc_sem_create, probe_ipc_sem_create,
+		"id %ld flags %d", id, flags);
+}
+
+void probe_ipc_shm_create(void *data, long id, int flags)
+{
+	trace_mark_tp(ipc, shm_create, ipc_shm_create, probe_ipc_shm_create,
+		"id %ld flags %d", id, flags);
+}
+
+void probe_ipc_call(void *data, unsigned int call, unsigned int first)
+{
+	trace_mark_tp(ipc, call, ipc_call, probe_ipc_call,
+		"call %u first %d", call, first);
+}
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("IPC Tracepoint Probes");
diff --git a/drivers/staging/lttng/discard/probes/jbd2-trace.c b/drivers/staging/lttng/discard/probes/jbd2-trace.c
new file mode 100644
index 0000000..3da32cd
--- /dev/null
+++ b/drivers/staging/lttng/discard/probes/jbd2-trace.c
@@ -0,0 +1,208 @@
+/*
+ * ltt/probes/jbd2-trace.c
+ *
+ * JBD2 tracepoint probes.
+ *
+ * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <linux/mutex.h>
+#include <linux/rcupdate.h>
+#include <trace/events/jbd2.h>
+
+#include "../ltt-tracer.h"
+
+static struct dentry *jbd2_filter_dentry, *jbd2_filter_dev_dentry;
+static DEFINE_MUTEX(jbd2_filter_mutex);
+/* Make sure we don't race between module exit and file write */
+static int module_exits;
+
+struct rcu_dev_filter {
+	struct rcu_head rcu;
+	char devname[NAME_MAX];
+};
+
+static struct rcu_dev_filter *dev_filter;
+
+/*
+ * Probes are executed in rcu_sched read-side critical section.
+ */
+static int do_filter(const char *dev)
+{
+	struct rcu_dev_filter *ldev_filter = rcu_dereference(dev_filter);
+
+	if (unlikely(ldev_filter))
+		if (unlikely(strcmp(ldev_filter->devname, dev)))
+			return 0;
+	return 1;
+}
+
+void probe_jbd2_checkpoint(void *data, journal_t *journal, int result)
+{
+	if (unlikely(!do_filter(journal->j_devname)))
+		return;
+	trace_mark_tp(jbd2, checkpoint, jbd2_checkpoint,
+		probe_jbd2_checkpoint, "dev %s need_checkpoint %d",
+		journal->j_devname, result);
+}
+
+void probe_jbd2_start_commit(void *data, journal_t *journal,
+			     transaction_t *commit_transaction)
+{
+	if (unlikely(!do_filter(journal->j_devname)))
+		return;
+	trace_mark_tp(jbd2, start_commit, jbd2_start_commit,
+		probe_jbd2_start_commit, "dev %s transaction %d",
+		journal->j_devname, commit_transaction->t_tid);
+}
+
+void probe_jbd2_end_commit(void *data, journal_t *journal,
+			   transaction_t *commit_transaction)
+{
+	if (unlikely(!do_filter(journal->j_devname)))
+		return;
+	trace_mark_tp(jbd2, end_commit, jbd2_end_commit,
+		probe_jbd2_end_commit, "dev %s transaction %d head %d",
+		journal->j_devname, commit_transaction->t_tid,
+		journal->j_tail_sequence);
+}
+
+static void free_dev_filter(struct rcu_head *head)
+{
+	kfree(container_of(head, struct rcu_dev_filter, rcu));
+}
+
+static ssize_t filter_op_write(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	int err = 0;
+	char buf[NAME_MAX];
+	int buf_size;
+	char name[NAME_MAX];
+	struct rcu_dev_filter *new, *old;
+
+	mutex_lock(&jbd2_filter_mutex);
+	if (module_exits) {
+		err = -EPERM;
+		goto error;
+	}
+	buf_size = min(count, sizeof(buf) - 1);
+	err = copy_from_user(buf, user_buf, buf_size);
+	if (err)
+		goto error;
+	buf[buf_size] = 0;
+
+	if (sscanf(buf, "%s", name) != 1) {
+		err = -EPERM;
+		goto error;
+	}
+
+	old = dev_filter;
+
+	/* Empty string or * means all active */
+	if (name[0] == '\0' || (name[0] == '*' && name[1] == '\0')) {
+		new = NULL;
+	} else {
+		new = kmalloc(sizeof(*new), GFP_KERNEL);
+		strcpy(new->devname, name);
+	}
+
+	rcu_assign_pointer(dev_filter, new);
+	if (old)
+		call_rcu_sched(&old->rcu, free_dev_filter);
+
+	mutex_unlock(&jbd2_filter_mutex);
+	return count;
+
+error:
+	mutex_unlock(&jbd2_filter_mutex);
+	return err;
+}
+
+static ssize_t filter_op_read(struct file *filp, char __user *buffer,
+	size_t count, loff_t *ppos)
+{
+	ssize_t bcount;
+	const char *devname;
+
+	mutex_lock(&jbd2_filter_mutex);
+	if (!dev_filter)
+		devname = "*";
+	else
+		devname = dev_filter->devname;
+	bcount = simple_read_from_buffer(buffer, count, ppos,
+			devname, strlen(devname));
+	mutex_unlock(&jbd2_filter_mutex);
+	return bcount;
+}
+
+static struct file_operations jbd2_file_operations = {
+	.write = filter_op_write,
+	.read = filter_op_read,
+};
+
+static void release_filter_dev(void)
+{
+	struct rcu_dev_filter *old;
+
+	mutex_lock(&jbd2_filter_mutex);
+	module_exits = 1;
+	old = dev_filter;
+	rcu_assign_pointer(dev_filter, NULL);
+	if (old)
+		call_rcu_sched(&old->rcu, free_dev_filter);
+	mutex_unlock(&jbd2_filter_mutex);
+}
+
+static int __init filter_init(void)
+{
+	struct dentry *filter_root_dentry;
+	int err = 0;
+
+	filter_root_dentry = get_filter_root();
+	if (!filter_root_dentry) {
+		err = -ENOENT;
+		goto end;
+	}
+
+	jbd2_filter_dentry = debugfs_create_dir("jbd2", filter_root_dentry);
+
+	if (IS_ERR(jbd2_filter_dentry) || !jbd2_filter_dentry) {
+		printk(KERN_ERR "Failed to create jbd2 filter file\n");
+		err = -ENOMEM;
+		goto end;
+	}
+
+	jbd2_filter_dev_dentry = debugfs_create_file("dev", S_IWUSR,
+			jbd2_filter_dentry, NULL, &jbd2_file_operations);
+	if (IS_ERR(jbd2_filter_dentry) || !jbd2_filter_dentry) {
+		printk(KERN_ERR "Failed to create jbd2 filter file\n");
+		err = -ENOMEM;
+		goto release_filter_dentry;
+	}
+
+	goto end;
+
+release_filter_dentry:
+	debugfs_remove(jbd2_filter_dentry);
+	release_filter_dev();
+end:
+	return err;
+}
+
+static void __exit filter_exit(void)
+{
+	debugfs_remove(jbd2_filter_dev_dentry);
+	debugfs_remove(jbd2_filter_dentry);
+	release_filter_dev();
+}
+
+module_init(filter_init);
+module_exit(filter_exit);
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("JBD2 Tracepoint Probes");
diff --git a/drivers/staging/lttng/discard/probes/kernel-trace.c b/drivers/staging/lttng/discard/probes/kernel-trace.c
new file mode 100644
index 0000000..cabe60e
--- /dev/null
+++ b/drivers/staging/lttng/discard/probes/kernel-trace.c
@@ -0,0 +1,581 @@
+/*
+ * ltt/probes/kernel-trace.c
+ *
+ * kernel tracepoint probes.
+ *
+ * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <trace/events/signal.h>
+#include <trace/irq.h>
+#include <trace/sched.h>
+#include <trace/timer.h>
+#include <trace/kernel.h>
+#include <trace/fault.h>
+#include <trace/events/sched.h>
+
+#include "../ltt-tracer.h"
+#include "../ltt-type-serializer.h"
+
+/*
+ * This should probably be added to s390.
+ */
+#ifdef CONFIG_S390
+static struct pt_regs *get_irq_regs(void)
+{
+	return task_pt_regs(current);
+}
+#endif
+
+/*
+ * FIXME :
+ * currently, the specialized tracepoint probes cannot call into other marker
+ * probes, such as ftrace enable/disable. Given we want them to be as fast as
+ * possible, it might not be so bad to lose this flexibility. But that means
+ * such probes would have to connect to tracepoints on their own.
+ */
+
+/* kernel_irq_entry specialized tracepoint probe */
+
+void probe_irq_entry(void *_data, unsigned int id, struct pt_regs *regs,
+	struct irqaction *action);
+
+DEFINE_MARKER_TP(kernel, irq_entry, irq_entry, probe_irq_entry,
+	"ip %lu handler %p irq_id #2u%u kernel_mode #1u%u");
+
+notrace void probe_irq_entry(void *_data, unsigned int id, struct pt_regs *regs,
+	struct irqaction *action)
+{
+	struct marker *marker;
+	struct serialize_long_long_short_char data;
+
+	if (unlikely(!regs))
+		regs = get_irq_regs();
+	if (likely(regs)) {
+		data.f1 = instruction_pointer(regs);
+		data.f4 = !user_mode(regs);
+	} else {
+		data.f1 = 0UL;
+		data.f4 = 1;
+	}
+	data.f2 = (unsigned long) (action ? action->handler : NULL);
+	data.f3 = id;
+
+	marker = &GET_MARKER(kernel, irq_entry);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
+}
+
+void probe_irq_next_handler(void *_data, unsigned int id, struct irqaction *action,
+		irqreturn_t prev_ret);
+
+DEFINE_MARKER_TP(kernel, irq_next_handler, irq_next_handler,
+	probe_irq_next_handler,
+	"handler %p prev_ret #1u%u");
+
+notrace void probe_irq_next_handler(void *_data, unsigned int id, struct irqaction *action,
+		irqreturn_t prev_ret)
+{
+	struct marker *marker;
+	struct serialize_long_char data;
+
+	data.f1 = (unsigned long) (action ? action->handler : NULL);
+	data.f2 = prev_ret;
+
+	marker = &GET_MARKER(kernel, irq_next_handler);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
+}
+
+/* kernel_irq_exit specialized tracepoint probe */
+
+void probe_irq_exit(void *_data, irqreturn_t retval);
+
+DEFINE_MARKER_TP(kernel, irq_exit, irq_exit, probe_irq_exit,
+	"handled #1u%u");
+
+notrace void probe_irq_exit(void *_data, irqreturn_t retval)
+{
+	struct marker *marker;
+	unsigned char data;
+
+	data = IRQ_RETVAL(retval);
+
+	marker = &GET_MARKER(kernel, irq_exit);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, sizeof(data), sizeof(data));
+}
+
+/* kernel_softirq_entry specialized tracepoint probe */
+
+void probe_softirq_entry(void *_data, struct softirq_action *h,
+	struct softirq_action *softirq_vec);
+
+DEFINE_MARKER_TP(kernel, softirq_entry, softirq_entry,
+	probe_softirq_entry, "softirq_id #1u%lu");
+
+notrace void probe_softirq_entry(void *_data, struct softirq_action *h,
+	struct softirq_action *softirq_vec)
+{
+	struct marker *marker;
+	unsigned char data;
+
+	data = ((unsigned long)h - (unsigned long)softirq_vec) / sizeof(*h);
+
+	marker = &GET_MARKER(kernel, softirq_entry);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, sizeof(data), sizeof(data));
+}
+
+/* kernel_softirq_exit specialized tracepoint probe */
+
+void probe_softirq_exit(void *_data, struct softirq_action *h,
+	struct softirq_action *softirq_vec);
+
+DEFINE_MARKER_TP(kernel, softirq_exit, softirq_exit,
+	probe_softirq_exit, "softirq_id #1u%lu");
+
+notrace void probe_softirq_exit(void *_data, struct softirq_action *h,
+	struct softirq_action *softirq_vec)
+{
+	struct marker *marker;
+	unsigned char data;
+
+	data = ((unsigned long)h - (unsigned long)softirq_vec) / sizeof(*h);
+
+	marker = &GET_MARKER(kernel, softirq_exit);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, sizeof(data), sizeof(data));
+}
+
+/* kernel_softirq_raise specialized tracepoint probe */
+
+void probe_softirq_raise(void *_data, unsigned int nr);
+
+DEFINE_MARKER_TP(kernel, softirq_raise, softirq_raise,
+	probe_softirq_raise, "softirq_id #1u%u");
+
+notrace void probe_softirq_raise(void *_data, unsigned int nr)
+{
+	struct marker *marker;
+	unsigned char data;
+
+	data = nr;
+
+	marker = &GET_MARKER(kernel, softirq_raise);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, sizeof(data), sizeof(data));
+}
+
+/* Standard probes */
+void probe_irq_tasklet_low_entry(void *_data, struct tasklet_struct *t)
+{
+	trace_mark_tp(kernel, tasklet_low_entry, irq_tasklet_low_entry,
+		probe_irq_tasklet_low_entry, "func %p data %lu",
+		t->func, t->data);
+}
+
+void probe_irq_tasklet_low_exit(void *_data, struct tasklet_struct *t)
+{
+	trace_mark_tp(kernel, tasklet_low_exit, irq_tasklet_low_exit,
+		probe_irq_tasklet_low_exit, "func %p data %lu",
+		t->func, t->data);
+}
+
+void probe_irq_tasklet_high_entry(void *_data, struct tasklet_struct *t)
+{
+	trace_mark_tp(kernel, tasklet_high_entry, irq_tasklet_high_entry,
+		probe_irq_tasklet_high_entry, "func %p data %lu",
+		t->func, t->data);
+}
+
+void probe_irq_tasklet_high_exit(void *_data, struct tasklet_struct *t)
+{
+	trace_mark_tp(kernel, tasklet_high_exit, irq_tasklet_high_exit,
+		probe_irq_tasklet_high_exit, "func %p data %lu",
+		t->func, t->data);
+}
+
+void probe_sched_kthread_stop(void *_data, struct task_struct *t)
+{
+	trace_mark_tp(kernel, kthread_stop, sched_kthread_stop,
+		probe_sched_kthread_stop, "pid %d", t->pid);
+}
+
+void probe_sched_kthread_stop_ret(void *_data, int ret)
+{
+	trace_mark_tp(kernel, kthread_stop_ret, sched_kthread_stop_ret,
+		probe_sched_kthread_stop_ret, "ret %d", ret);
+}
+
+void probe_sched_wait_task(void *_data, struct task_struct *p)
+{
+	trace_mark_tp(kernel, sched_wait_task, sched_wait_task,
+		probe_sched_wait_task, "pid %d state #2d%ld",
+		p->pid, p->state);
+}
+
+/* kernel_sched_try_wakeup specialized tracepoint probe */
+
+void probe_sched_wakeup(void *_data, struct task_struct *p, int success);
+
+DEFINE_MARKER_TP(kernel, sched_try_wakeup, sched_wakeup,
+	probe_sched_wakeup, "pid %d cpu_id %u state #2d%ld");
+
+notrace void probe_sched_wakeup(void *_data, struct task_struct *p, int success)
+{
+	struct marker *marker;
+	struct serialize_int_int_short data;
+
+	data.f1 = p->pid;
+	data.f2 = task_cpu(p);
+	data.f3 = p->state;
+
+	marker = &GET_MARKER(kernel, sched_try_wakeup);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(int));
+}
+
+void probe_sched_wakeup_new(void *_data, struct task_struct *p, int success)
+{
+	trace_mark_tp(kernel, sched_wakeup_new_task, sched_wakeup_new,
+		probe_sched_wakeup_new, "pid %d state #2d%ld cpu_id %u",
+		p->pid, p->state, task_cpu(p));
+}
+
+/* kernel_sched_schedule specialized tracepoint probe */
+
+void probe_sched_switch(void *_data, struct task_struct *prev,
+		struct task_struct *next);
+
+DEFINE_MARKER_TP(kernel, sched_schedule, sched_switch, probe_sched_switch,
+	"prev_pid %d next_pid %d prev_state #2d%ld");
+
+notrace void probe_sched_switch(void *_data, struct task_struct *prev,
+		struct task_struct *next)
+{
+	struct marker *marker;
+	struct serialize_int_int_short data;
+
+	data.f1 = prev->pid;
+	data.f2 = next->pid;
+	data.f3 = prev->state;
+
+	marker = &GET_MARKER(kernel, sched_schedule);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(int));
+}
+
+void probe_sched_migrate_task(void *_data, struct task_struct *p, int dest_cpu)
+{
+	trace_mark_tp(kernel, sched_migrate_task, sched_migrate_task,
+		probe_sched_migrate_task, "pid %d state #2d%ld dest_cpu %d",
+		p->pid, p->state, dest_cpu);
+}
+
+void probe_sched_signal_send(void *_data, int sig, struct siginfo *info, struct task_struct *t)
+{
+	trace_mark_tp(kernel, send_signal, signal_generate,
+		probe_sched_signal_send, "pid %d signal %d", t->pid, sig);
+}
+
+void probe_sched_process_free(void *_data, struct task_struct *p)
+{
+	trace_mark_tp(kernel, process_free, sched_process_free,
+		probe_sched_process_free, "pid %d", p->pid);
+}
+
+void probe_sched_process_exit(void *_data, struct task_struct *p)
+{
+	trace_mark_tp(kernel, process_exit, sched_process_exit,
+		probe_sched_process_exit, "pid %d", p->pid);
+}
+
+void probe_sched_process_wait(void *_data, struct pid *pid)
+{
+	trace_mark_tp(kernel, process_wait, sched_process_wait,
+		probe_sched_process_wait, "pid %d", pid_nr(pid));
+}
+
+void probe_sched_process_fork(void *_data, struct task_struct *parent,
+		struct task_struct *child)
+{
+	trace_mark_tp(kernel, process_fork, sched_process_fork,
+		probe_sched_process_fork,
+		"parent_pid %d child_pid %d child_tgid %d",
+		parent->pid, child->pid, child->tgid);
+}
+
+void probe_sched_kthread_create(void *_data, void *fn, int pid)
+{
+	trace_mark_tp(kernel, kthread_create, sched_kthread_create,
+		probe_sched_kthread_create,
+		"fn %p pid %d", fn, pid);
+}
+
+void probe_timer_itimer_expired(void *_data, struct signal_struct *sig)
+{
+	trace_mark_tp(kernel, timer_itimer_expired, timer_itimer_expired,
+		probe_timer_itimer_expired, "pid %d",
+		pid_nr(sig->leader_pid));
+}
+
+void probe_timer_itimer_set(void *_data, int which, struct itimerval *value)
+{
+	trace_mark_tp(kernel, timer_itimer_set,
+		timer_itimer_set, probe_timer_itimer_set,
+		"which %d interval_sec %ld interval_usec %ld "
+		"value_sec %ld value_usec %ld",
+		which,
+		value->it_interval.tv_sec,
+		value->it_interval.tv_usec,
+		value->it_value.tv_sec,
+		value->it_value.tv_usec);
+}
+
+/* kernel_timer_set specialized tracepoint probe */
+
+void probe_timer_set(void *_data, struct timer_list *timer);
+
+DEFINE_MARKER_TP(kernel, timer_set, timer_set, probe_timer_set,
+	"expires %lu function %p data %lu");
+
+notrace void probe_timer_set(void *_data, struct timer_list *timer)
+{
+	struct marker *marker;
+	struct serialize_long_long_long data;
+
+	data.f1 = timer->expires;
+	data.f2 = (unsigned long)timer->function;
+	data.f3 = timer->data;
+
+	marker = &GET_MARKER(kernel, timer_set);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
+}
+
+void probe_timer_update_time(void *_data, struct timespec *_xtime,
+		struct timespec *_wall_to_monotonic)
+{
+	trace_mark_tp(kernel, timer_update_time, timer_update_time,
+		probe_timer_update_time,
+		"jiffies #8u%llu xtime_sec %ld xtime_nsec %ld "
+		"walltomonotonic_sec %ld walltomonotonic_nsec %ld",
+		(unsigned long long)jiffies_64, _xtime->tv_sec, _xtime->tv_nsec,
+		_wall_to_monotonic->tv_sec, _wall_to_monotonic->tv_nsec);
+}
+
+void probe_timer_timeout(void *_data, struct task_struct *p)
+{
+	trace_mark_tp(kernel, timer_timeout, timer_timeout,
+		probe_timer_timeout, "pid %d", p->pid);
+}
+
+void probe_kernel_printk(void *_data, unsigned long retaddr)
+{
+	trace_mark_tp(kernel, printk, kernel_printk,
+		probe_kernel_printk, "ip 0x%lX", retaddr);
+}
+
+void probe_kernel_vprintk(void *_data, unsigned long retaddr, char *buf, int len)
+{
+	if (len > 0) {
+		unsigned int loglevel;
+		int mark_len;
+		char *mark_buf;
+		char saved_char;
+
+		if (buf[0] == '<' && buf[1] >= '0' &&
+		   buf[1] <= '7' && buf[2] == '>') {
+			loglevel = buf[1] - '0';
+			mark_buf = &buf[3];
+			mark_len = len - 3;
+		} else {
+			loglevel = default_message_loglevel;
+			mark_buf = buf;
+			mark_len = len;
+		}
+		if (mark_buf[mark_len - 1] == '\n')
+			mark_len--;
+		saved_char = mark_buf[mark_len];
+		mark_buf[mark_len] = '\0';
+		trace_mark_tp(kernel, vprintk, kernel_vprintk,
+			probe_kernel_vprintk,
+			"loglevel #1u%u string %s ip 0x%lX",
+			loglevel, mark_buf, retaddr);
+		mark_buf[mark_len] = saved_char;
+	}
+}
+
+#ifdef CONFIG_MODULES
+void probe_kernel_module_free(void *_data, struct module *mod)
+{
+	trace_mark_tp(kernel, module_free, kernel_module_free,
+		probe_kernel_module_free, "name %s", mod->name);
+}
+
+void probe_kernel_module_load(void *_data, struct module *mod)
+{
+	trace_mark_tp(kernel, module_load, kernel_module_load,
+		probe_kernel_module_load, "name %s", mod->name);
+}
+#endif
+
+void probe_kernel_panic(void *_data, const char *fmt, va_list args)
+{
+	char info[64];
+	vsnprintf(info, sizeof(info), fmt, args);
+	trace_mark_tp(kernel, panic, kernel_panic, probe_kernel_panic,
+		"info %s", info);
+}
+
+void probe_kernel_kernel_kexec(void *_data, struct kimage *image)
+{
+	trace_mark_tp(kernel, kernel_kexec, kernel_kernel_kexec,
+		probe_kernel_kernel_kexec, "image %p", image);
+}
+
+void probe_kernel_crash_kexec(void *_data, struct kimage *image, struct pt_regs *regs)
+{
+	trace_mark_tp(kernel, crash_kexec, kernel_crash_kexec,
+		probe_kernel_crash_kexec, "image %p ip %p", image,
+		regs ? (void *)instruction_pointer(regs) : NULL);
+}
+
+/* kernel_page_fault_entry specialized tracepoint probe */
+
+void probe_kernel_page_fault_entry(void *_data, struct pt_regs *regs, int trapnr,
+	struct mm_struct *mm, struct vm_area_struct *vma,
+	unsigned long address, int write_access);
+
+DEFINE_MARKER_TP(kernel, page_fault_entry, page_fault_entry,
+	probe_kernel_page_fault_entry,
+	"ip #p%lu address #p%lu trap_id #2u%u write_access #1u%u");
+
+notrace void probe_kernel_page_fault_entry(void *_data, struct pt_regs *regs, int trapnr,
+	struct mm_struct *mm, struct vm_area_struct *vma,
+	unsigned long address, int write_access)
+{
+	struct marker *marker;
+	struct serialize_long_long_short_char data;
+
+	if (likely(regs))
+		data.f1 = instruction_pointer(regs);
+	else
+		data.f1 = 0UL;
+	data.f2 = address;
+	data.f3 = (unsigned short)trapnr;
+	data.f4 = (unsigned char)!!write_access;
+
+	marker = &GET_MARKER(kernel, page_fault_entry);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
+}
+
+/* kernel_page_fault_exit specialized tracepoint probe */
+
+void probe_kernel_page_fault_exit(void *_data, int res);
+
+DEFINE_MARKER_TP(kernel, page_fault_exit, page_fault_exit,
+	probe_kernel_page_fault_exit,
+	"res %d");
+
+notrace void probe_kernel_page_fault_exit(void *_data, int res)
+{
+	struct marker *marker;
+
+	marker = &GET_MARKER(kernel, page_fault_exit);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&res, sizeof(res), sizeof(res));
+}
+
+/* kernel_page_fault_nosem_entry specialized tracepoint probe */
+
+void probe_kernel_page_fault_nosem_entry(void *_data, struct pt_regs *regs,
+	int trapnr, unsigned long address);
+
+DEFINE_MARKER_TP(kernel, page_fault_nosem_entry, page_fault_nosem_entry,
+	probe_kernel_page_fault_nosem_entry,
+	"ip #p%lu address #p%lu trap_id #2u%u");
+
+notrace void probe_kernel_page_fault_nosem_entry(void *_data, struct pt_regs *regs,
+	int trapnr, unsigned long address)
+{
+	struct marker *marker;
+	struct serialize_long_long_short data;
+
+	if (likely(regs))
+		data.f1 = instruction_pointer(regs);
+	else
+		data.f1 = 0UL;
+	data.f2 = address;
+	data.f3 = (unsigned short)trapnr;
+
+	marker = &GET_MARKER(kernel, page_fault_nosem_entry);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
+}
+
+/* kernel_page_fault_nosem_exit specialized tracepoint probe */
+
+void probe_kernel_page_fault_nosem_exit(void *_data, int res);
+
+DEFINE_MARKER_TP(kernel, page_fault_nosem_exit, page_fault_nosem_exit,
+	probe_kernel_page_fault_nosem_exit,
+	MARK_NOARGS);
+
+notrace void probe_kernel_page_fault_nosem_exit(void *_data, int res)
+{
+	struct marker *marker;
+
+	marker = &GET_MARKER(kernel, page_fault_nosem_exit);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		NULL, 0, 0);
+}
+
+/* kernel_page_fault_get_user_entry specialized tracepoint probe */
+
+void probe_kernel_page_fault_get_user_entry(void *_data, struct mm_struct *mm,
+	struct vm_area_struct *vma, unsigned long address, int write_access);
+
+DEFINE_MARKER_TP(kernel, page_fault_get_user_entry, page_fault_get_user_entry,
+	probe_kernel_page_fault_get_user_entry,
+	"address #p%lu write_access #1u%u");
+
+notrace void probe_kernel_page_fault_get_user_entry(void *_data, struct mm_struct *mm,
+	struct vm_area_struct *vma, unsigned long address, int write_access)
+{
+	struct marker *marker;
+	struct serialize_long_char data;
+
+	data.f1 = address;
+	data.f2 = (unsigned char)!!write_access;
+
+	marker = &GET_MARKER(kernel, page_fault_get_user_entry);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
+}
+
+/* kernel_page_fault_get_user_exit specialized tracepoint probe */
+
+void probe_kernel_page_fault_get_user_exit(void *_data, int res);
+
+DEFINE_MARKER_TP(kernel, page_fault_get_user_exit, page_fault_get_user_exit,
+	probe_kernel_page_fault_get_user_exit,
+	"res %d");
+
+notrace void probe_kernel_page_fault_get_user_exit(void *_data, int res)
+{
+	struct marker *marker;
+
+	marker = &GET_MARKER(kernel, page_fault_get_user_exit);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&res, sizeof(res), sizeof(res));
+}
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("kernel Tracepoint Probes");
diff --git a/drivers/staging/lttng/discard/probes/lockdep-trace.c b/drivers/staging/lttng/discard/probes/lockdep-trace.c
new file mode 100644
index 0000000..a9a7734
--- /dev/null
+++ b/drivers/staging/lttng/discard/probes/lockdep-trace.c
@@ -0,0 +1,60 @@
+/*
+ * ltt/probes/lockdep-trace.c
+ *
+ * lockdep tracepoint probes.
+ *
+ * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+#include <linux/lockdep.h>
+#include <trace/lockdep.h>
+
+void probe_lockdep_hardirqs_on(void *data, unsigned long retaddr)
+{
+	trace_mark_tp(lockdep, hardirqs_on, lockdep_hardirqs_on,
+		probe_lockdep_hardirqs_on, "retaddr 0x%lX", retaddr);
+}
+
+void probe_lockdep_hardirqs_off(void *data, unsigned long retaddr)
+{
+	trace_mark_tp(lockdep, hardirqs_off, lockdep_hardirqs_off,
+		probe_lockdep_hardirqs_off, "retaddr 0x%lX", retaddr);
+}
+
+void probe_lockdep_softirqs_on(void *data, unsigned long retaddr)
+{
+	trace_mark_tp(lockdep, softirqs_on, lockdep_softirqs_on,
+		probe_lockdep_softirqs_on, "retaddr 0x%lX", retaddr);
+}
+
+void probe_lockdep_softirqs_off(void *data, unsigned long retaddr)
+{
+	trace_mark_tp(lockdep, softirqs_off, lockdep_softirqs_off,
+		probe_lockdep_softirqs_off, "retaddr 0x%lX", retaddr);
+}
+
+void probe_lockdep_lock_acquire(void *data, unsigned long retaddr,
+		unsigned int subclass, struct lockdep_map *lock, int trylock,
+		int read, int hardirqs_off)
+{
+	trace_mark_tp(lockdep, lock_acquire, lockdep_lock_acquire,
+		probe_lockdep_lock_acquire,
+		"retaddr 0x%lX subclass %u lock %p trylock %d read %d "
+		"hardirqs_off %d",
+		retaddr, subclass, lock, trylock, read, hardirqs_off);
+}
+
+void probe_lockdep_lock_release(void *data, unsigned long retaddr,
+		struct lockdep_map *lock, int nested)
+{
+	trace_mark_tp(lockdep, lock_release, lockdep_lock_release,
+		probe_lockdep_lock_release,
+		"retaddr 0x%lX lock %p nested %d",
+		retaddr, lock, nested);
+}
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("lockdep Tracepoint Probes");
diff --git a/drivers/staging/lttng/discard/probes/mm-trace.c b/drivers/staging/lttng/discard/probes/mm-trace.c
new file mode 100644
index 0000000..935e366
--- /dev/null
+++ b/drivers/staging/lttng/discard/probes/mm-trace.c
@@ -0,0 +1,146 @@
+/*
+ * ltt/probes/mm-trace.c
+ *
+ * MM tracepoint probes.
+ *
+ * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/swap.h>
+
+#include <asm/pgtable.h>
+#include <asm/tlbflush.h>
+#include <linux/swapops.h>
+#include <trace/page_alloc.h>
+#include <trace/filemap.h>
+#include <trace/swap.h>
+#include <trace/hugetlb.h>
+
+#include "../ltt-type-serializer.h"
+
+void probe_wait_on_page_start(void *_data, struct page *page, int bit_nr)
+{
+	trace_mark_tp(mm, wait_on_page_start, wait_on_page_start,
+		probe_wait_on_page_start, "pfn %lu bit_nr %d",
+		page_to_pfn(page), bit_nr);
+}
+
+void probe_wait_on_page_end(void *_data, struct page *page, int bit_nr)
+{
+	trace_mark_tp(mm, wait_on_page_end, wait_on_page_end,
+		probe_wait_on_page_end, "pfn %lu bit_nr %d",
+		page_to_pfn(page), bit_nr);
+}
+
+void probe_hugetlb_page_free(void *_data, struct page *page)
+{
+	trace_mark_tp(mm, huge_page_free, hugetlb_page_free,
+		probe_hugetlb_page_free, "pfn %lu", page_to_pfn(page));
+}
+
+void probe_hugetlb_page_alloc(void *_data, struct page *page)
+{
+	if (page)
+		trace_mark_tp(mm, huge_page_alloc, hugetlb_page_alloc,
+			probe_hugetlb_page_alloc, "pfn %lu", page_to_pfn(page));
+}
+
+/* mm_page_free specialized tracepoint probe */
+
+void probe_page_free(void *_data, struct page *page, unsigned int order);
+
+DEFINE_MARKER_TP(mm, page_free, page_free, probe_page_free,
+	"pfn %lu order %u");
+
+notrace void probe_page_free(void *_data, struct page *page, unsigned int order)
+{
+	struct marker *marker;
+	struct serialize_long_int data;
+
+	data.f1 = page_to_pfn(page);
+	data.f2 = order;
+
+	marker = &GET_MARKER(mm, page_free);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
+}
+
+/* mm_page_alloc specialized tracepoint probe */
+
+void probe_page_alloc(void *_data, struct page *page, unsigned int order);
+
+DEFINE_MARKER_TP(mm, page_alloc, page_alloc, probe_page_alloc,
+	"pfn %lu order %u");
+
+notrace void probe_page_alloc(void *_data, struct page *page, unsigned int order)
+{
+	struct marker *marker;
+	struct serialize_long_int data;
+
+	if (unlikely(!page))
+		return;
+
+	data.f1 = page_to_pfn(page);
+	data.f2 = order;
+
+	marker = &GET_MARKER(mm, page_alloc);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
+}
+
+#ifdef CONFIG_SWAP
+void probe_swap_in(void *_data, struct page *page, swp_entry_t entry)
+{
+	trace_mark_tp(mm, swap_in, swap_in, probe_swap_in,
+		"pfn %lu filp %p offset %lu",
+		page_to_pfn(page),
+		get_swap_info_struct(swp_type(entry))->swap_file,
+		swp_offset(entry));
+}
+
+void probe_swap_out(void *_data, struct page *page)
+{
+	trace_mark_tp(mm, swap_out, swap_out, probe_swap_out,
+		"pfn %lu filp %p offset %lu",
+		page_to_pfn(page),
+		get_swap_info_struct(swp_type(
+			page_swp_entry(page)))->swap_file,
+		swp_offset(page_swp_entry(page)));
+}
+
+void probe_swap_file_close(void *_data, struct file *file)
+{
+	trace_mark_tp(mm, swap_file_close, swap_file_close,
+		probe_swap_file_close, "filp %p", file);
+}
+
+void probe_swap_file_open(void *_data, struct file *file, char *filename)
+{
+	trace_mark_tp(mm, swap_file_open, swap_file_open,
+		probe_swap_file_open, "filp %p filename %s",
+		file, filename);
+}
+#endif
+
+void probe_add_to_page_cache(void *_data, struct address_space *mapping, pgoff_t offset)
+{
+	trace_mark_tp(mm, add_to_page_cache, add_to_page_cache,
+		probe_add_to_page_cache,
+		"inode %lu sdev %u",
+		mapping->host->i_ino, mapping->host->i_sb->s_dev);
+}
+
+void probe_remove_from_page_cache(void *_data, struct address_space *mapping)
+{
+	trace_mark_tp(mm, remove_from_page_cache, remove_from_page_cache,
+		probe_remove_from_page_cache,
+		"inode %lu sdev %u",
+		mapping->host->i_ino, mapping->host->i_sb->s_dev);
+}
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("MM Tracepoint Probes");
diff --git a/drivers/staging/lttng/discard/probes/net-extended-trace.c b/drivers/staging/lttng/discard/probes/net-extended-trace.c
new file mode 100644
index 0000000..15fc810
--- /dev/null
+++ b/drivers/staging/lttng/discard/probes/net-extended-trace.c
@@ -0,0 +1,146 @@
+/*
+ * ltt/probes/net-extended-trace.c
+ *
+ * Net tracepoint extended probes.
+ *
+ * These probes record many header fields from TCP and UDP messages. Here are
+ * the consequences of this:
+ * 1) it allows analyzing network traffic to provide some pcap-like
+ *    functionality within LTTng
+ * 2) it allows offline synchronization of a group of concurrent traces
+ *    recorded on different nodes
+ * 3) it increases tracing overhead
+ *
+ * You can leave out these probes or not activate them if you are not
+ * especially interested in the details of network traffic and do not wish to
+ * synchronize distributed traces.
+ *
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/in_route.h>
+#include <linux/ip.h>
+#include <linux/module.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <net/route.h>
+#include <trace/net.h>
+
+#include "../ltt-type-serializer.h"
+
+void probe_net_dev_xmit_extended(void *_data, struct sk_buff *skb);
+
+DEFINE_MARKER_TP(net, dev_xmit_extended, net_dev_xmit,
+	probe_net_dev_xmit_extended, "skb 0x%lX network_protocol #n2u%hu "
+	"transport_protocol #1u%u saddr #n4u%lu daddr #n4u%lu "
+	"tot_len #n2u%hu ihl #1u%u source #n2u%hu dest #n2u%hu seq #n4u%lu "
+	"ack_seq #n4u%lu doff #1u%u ack #1u%u rst #1u%u syn #1u%u fin #1u%u");
+
+notrace void probe_net_dev_xmit_extended(void *_data, struct sk_buff *skb)
+{
+	struct marker *marker;
+	struct serialize_l214421224411111 data;
+	struct iphdr *iph = ip_hdr(skb);
+	struct tcphdr *th = tcp_hdr(skb);
+
+	data.f1 = (unsigned long)skb;
+	data.f2 = skb->protocol;
+
+	if (ntohs(skb->protocol) == ETH_P_IP) {
+		data.f3 = ip_hdr(skb)->protocol;
+		data.f4 = iph->saddr;
+		data.f5 = iph->daddr;
+		data.f6 = iph->tot_len;
+		data.f7 = iph->ihl;
+
+		if (data.f3 == IPPROTO_TCP) {
+			data.f8 = th->source;
+			data.f9 = th->dest;
+			data.f10 = th->seq;
+			data.f11 = th->ack_seq;
+			data.f12 = th->doff;
+			data.f13 = th->ack;
+			data.f14 = th->rst;
+			data.f15 = th->syn;
+			data.f16 = th->fin;
+		}
+	}
+
+	marker = &GET_MARKER(net, dev_xmit_extended);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
+}
+
+void probe_tcpv4_rcv_extended(void *_data, struct sk_buff *skb);
+
+DEFINE_MARKER_TP(net, tcpv4_rcv_extended, net_tcpv4_rcv,
+	probe_tcpv4_rcv_extended, "skb 0x%lX saddr #n4u%lu daddr #n4u%lu "
+	"tot_len #n2u%hu ihl #1u%u source #n2u%hu dest #n2u%hu seq #n4u%lu "
+	"ack_seq #n4u%lu doff #1u%u ack #1u%u rst #1u%u syn #1u%u fin #1u%u");
+
+notrace void probe_tcpv4_rcv_extended(void *_data, struct sk_buff *skb)
+{
+	struct marker *marker;
+	struct serialize_l4421224411111 data;
+	struct iphdr *iph = ip_hdr(skb);
+	struct tcphdr *th = tcp_hdr(skb);
+
+	data.f1 = (unsigned long)skb;
+	data.f2 = iph->saddr;
+	data.f3 = iph->daddr;
+	data.f4 = iph->tot_len;
+	data.f5 = iph->ihl;
+	data.f6 = th->source;
+	data.f7 = th->dest;
+	data.f8 = th->seq;
+	data.f9 = th->ack_seq;
+	data.f10 = th->doff;
+	data.f11 = th->ack;
+	data.f12 = th->rst;
+	data.f13 = th->syn;
+	data.f14 = th->fin;
+
+	marker = &GET_MARKER(net, tcpv4_rcv_extended);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
+}
+
+void probe_udpv4_rcv_extended(void *_data, struct sk_buff *skb);
+
+DEFINE_MARKER_TP(net, udpv4_rcv_extended, net_udpv4_rcv,
+	probe_udpv4_rcv_extended, "skb 0x%lX saddr #n4u%lu daddr #n4u%lu "
+	"unicast #1u%u ulen #n2u%hu source #n2u%hu dest #n2u%hu "
+	"data_start #8u%lx");
+
+notrace void probe_udpv4_rcv_extended(void *_data, struct sk_buff *skb)
+{
+	struct marker *marker;
+	struct serialize_l4412228 data;
+	struct iphdr *iph = ip_hdr(skb);
+	struct rtable *rt = skb_rtable(skb);
+	struct udphdr *uh = udp_hdr(skb);
+
+	data.f1 = (unsigned long)skb;
+	data.f2 = iph->saddr;
+	data.f3 = iph->daddr;
+	data.f4 = rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST) ? 0 : 1;
+	data.f5 = uh->len;
+	data.f6 = uh->source;
+	data.f7 = uh->dest;
+	/* UDP header has not been pulled from skb->data, read the first 8
+	 * bytes of UDP data if they are not in a fragment*/
+	data.f8 = 0;
+	if (skb_headlen(skb) >= sizeof(struct udphdr) + 8)
+		data.f8 = *(unsigned long long *)(skb->data + sizeof(*uh));
+	else if (skb_headlen(skb) >= sizeof(struct udphdr))
+		memcpy(&data.f8, skb->data + sizeof(struct udphdr),
+			skb_headlen(skb) - sizeof(struct udphdr));
+
+	marker = &GET_MARKER(net, udpv4_rcv_extended);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(unsigned long long));
+}
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Benjamin Poirier");
+MODULE_DESCRIPTION("Net Tracepoint Extended Probes");
diff --git a/drivers/staging/lttng/discard/probes/net-trace.c b/drivers/staging/lttng/discard/probes/net-trace.c
new file mode 100644
index 0000000..3124125
--- /dev/null
+++ b/drivers/staging/lttng/discard/probes/net-trace.c
@@ -0,0 +1,406 @@
+/*
+ * ltt/probes/net-trace.c
+ *
+ * Net tracepoint probes.
+ *
+ * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/string.h>
+#include <trace/net.h>
+#include <trace/ipv4.h>
+#include <trace/ipv6.h>
+#include <trace/socket.h>
+
+#include "../ltt-type-serializer.h"
+
+void probe_net_dev_xmit(void *_data, struct sk_buff *skb);
+
+DEFINE_MARKER_TP(net, dev_xmit, net_dev_xmit, probe_net_dev_xmit,
+	"skb %p protocol #n2u%hu");
+
+notrace void probe_net_dev_xmit(void *_data, struct sk_buff *skb)
+{
+	struct marker *marker;
+	struct serialize_long_short data;
+
+	data.f1 = (unsigned long)skb;
+	data.f2 = skb->protocol;
+
+	marker = &GET_MARKER(net, dev_xmit);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
+}
+
+void probe_net_dev_receive(void *_data, struct sk_buff *skb);
+
+DEFINE_MARKER_TP(net, dev_receive, net_dev_receive, probe_net_dev_receive,
+	"skb %p protocol #n2u%hu");
+
+notrace void probe_net_dev_receive(void *_data, struct sk_buff *skb)
+{
+	struct marker *marker;
+	struct serialize_long_short data;
+
+	data.f1 = (unsigned long)skb;
+	data.f2 = skb->protocol;
+
+	marker = &GET_MARKER(net, dev_receive);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
+}
+
+void probe_ipv4_addr_add(void *_data, struct in_ifaddr *ifa)
+{
+	trace_mark_tp(netif_state, insert_ifa_ipv4, ipv4_addr_add,
+		probe_ipv4_addr_add, "label %s address #4u%u",
+		ifa->ifa_label, (unsigned int)ifa->ifa_address);
+}
+
+void probe_ipv4_addr_del(void *_data, struct in_ifaddr *ifa)
+{
+	trace_mark_tp(netif_state, del_ifa_ipv4, ipv4_addr_del,
+		probe_ipv4_addr_del, "label %s address #4u%u",
+		ifa->ifa_label, (unsigned int)ifa->ifa_address);
+}
+
+void probe_ipv6_addr_add(void *_data, struct inet6_ifaddr *ifa)
+{
+	__u8 *addr = ifa->addr.s6_addr;
+
+	trace_mark_tp(netif_state, insert_ifa_ipv6, ipv6_addr_add,
+		probe_ipv6_addr_add,
+		"label %s "
+		"a15 #1x%c a14 #1x%c a13 #1x%c a12 #1x%c "
+		"a11 #1x%c a10 #1x%c a9 #1x%c a8 #1x%c "
+		"a7 #1x%c a6 #1x%c a5 #1x%c a4 #1x%c "
+		"a3 #1x%c a2 #1x%c a1 #1x%c a0 #1x%c",
+		ifa->idev->dev->name,
+		addr[15], addr[14], addr[13], addr[12],
+		addr[11], addr[10], addr[9], addr[8],
+		addr[7], addr[6], addr[5], addr[4],
+		addr[3], addr[2], addr[1], addr[0]);
+}
+
+void probe_ipv6_addr_del(void *_data, struct inet6_ifaddr *ifa)
+{
+	__u8 *addr = ifa->addr.s6_addr;
+
+	trace_mark_tp(netif_state, insert_ifa_ipv6, ipv6_addr_del,
+		probe_ipv6_addr_del,
+		"label %s "
+		"a15 #1x%c a14 #1x%c a13 #1x%c a12 #1x%c "
+		"a11 #1x%c a10 #1x%c a9 #1x%c a8 #1x%c "
+		"a7 #1x%c a6 #1x%c a5 #1x%c a4 #1x%c "
+		"a3 #1x%c a2 #1x%c a1 #1x%c a0 #1x%c",
+		ifa->idev->dev->name,
+		addr[15], addr[14], addr[13], addr[12],
+		addr[11], addr[10], addr[9], addr[8],
+		addr[7], addr[6], addr[5], addr[4],
+		addr[3], addr[2], addr[1], addr[0]);
+}
+
+void probe_socket_create(void *_data, int family, int type, int protocol,
+	struct socket *sock, int ret)
+{
+	trace_mark_tp(net, socket_create, socket_create, probe_socket_create,
+		"family %d type %d protocol %d sock %p ret %d",
+		family, type, protocol, sock, ret);
+}
+
+void probe_socket_bind(void *_data, int fd, struct sockaddr __user *umyaddr, int addrlen,
+	int ret)
+{
+	trace_mark_tp(net, socket_bind, socket_bind, probe_socket_bind,
+		"fd %d umyaddr %p addrlen %d ret %d",
+		fd, umyaddr, addrlen, ret);
+}
+
+void probe_socket_connect(void *_data, int fd, struct sockaddr __user *uservaddr,
+	int addrlen, int ret)
+{
+	trace_mark_tp(net, socket_connect, socket_connect, probe_socket_connect,
+		"fd %d uservaddr %p addrlen %d ret %d",
+		fd, uservaddr, addrlen, ret);
+}
+
+void probe_socket_listen(void *_data, int fd, int backlog, int ret)
+{
+	trace_mark_tp(net, socket_listen, socket_listen, probe_socket_listen,
+		"fd %d backlog %d ret %d",
+		fd, backlog, ret);
+}
+
+void probe_socket_accept(void *_data, int fd, struct sockaddr __user *upeer_sockaddr,
+	int __user *upeer_addrlen, int flags, int ret)
+{
+	trace_mark_tp(net, socket_accept, socket_accept, probe_socket_accept,
+		"fd %d upeer_sockaddr %p upeer_addrlen %p flags %d ret %d",
+		fd, upeer_sockaddr, upeer_addrlen, flags, ret);
+}
+
+void probe_socket_getsockname(void *_data, int fd, struct sockaddr __user *usockaddr,
+	int __user *usockaddr_len, int ret)
+{
+	trace_mark_tp(net, socket_getsockname, socket_getsockname,
+		probe_socket_getsockname,
+		"fd %d usockaddr %p usockaddr_len %p ret %d",
+		fd, usockaddr, usockaddr_len, ret);
+}
+
+void probe_socket_getpeername(void *_data, int fd, struct sockaddr __user *usockaddr,
+	int __user *usockaddr_len, int ret)
+{
+	trace_mark_tp(net, socket_getpeername, socket_getpeername,
+		probe_socket_getpeername,
+		"fd %d usockaddr %p usockaddr_len %p ret %d",
+		fd, usockaddr, usockaddr_len, ret);
+}
+
+void probe_socket_socketpair(void *_data, int family, int type, int protocol,
+	int __user *usockvec, int ret)
+{
+	trace_mark_tp(net, socket_socketpair, socket_socketpair,
+		probe_socket_socketpair,
+		"family %d type %d protocol %d usockvec %p ret %d",
+		family, type, protocol, usockvec, ret);
+}
+
+void probe_socket_sendmsg(void *_data, struct socket *sock, struct msghdr *msg, size_t size,
+	int ret);
+
+DEFINE_MARKER_TP(net, socket_sendmsg, net_socket_sendmsg,
+	probe_socket_sendmsg,
+	"sock %p msg %p size %zu ret %d");
+
+notrace void probe_socket_sendmsg(void *_data, struct socket *sock, struct msghdr *msg,
+	size_t size, int ret)
+{
+	struct marker *marker;
+	struct serialize_long_long_sizet_int data;
+
+	data.f1 = (unsigned long)sock;
+	data.f2 = (unsigned long)msg;
+	data.f3 = size;
+	data.f4 = ret;
+
+	marker = &GET_MARKER(net, socket_sendmsg);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(size_t));
+}
+
+void probe_socket_recvmsg(void *_data, struct socket *sock, struct msghdr *msg, size_t size,
+	int flags, int ret);
+
+DEFINE_MARKER_TP(net, socket_recvmsg, net_socket_recvmsg,
+	probe_socket_recvmsg,
+	"sock %p msg %p size %zu flags %d ret %d");
+
+notrace void probe_socket_recvmsg(void *_data, struct socket *sock, struct msghdr *msg,
+	size_t size, int flags, int ret)
+{
+	struct marker *marker;
+	struct serialize_long_long_sizet_int_int data;
+
+	data.f1 = (unsigned long)sock;
+	data.f2 = (unsigned long)msg;
+	data.f3 = size;
+	data.f4 = flags;
+	data.f5 = ret;
+
+	marker = &GET_MARKER(net, socket_recvmsg);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(size_t));
+}
+
+void probe_socket_setsockopt(void *_data, int fd, int level, int optname,
+	char __user *optval, int optlen, int ret)
+{
+	trace_mark_tp(net, socket_setsockopt, socket_setsockopt,
+		probe_socket_setsockopt,
+		"fd %d level %d optname %d optval %p optlen %d ret %d",
+		fd, level, optname, optval, optlen, ret);
+}
+
+void probe_socket_getsockopt(void *_data, int fd, int level, int optname,
+	char __user *optval, int __user *optlen, int ret)
+{
+	trace_mark_tp(net, socket_getsockopt, socket_getsockopt,
+		probe_socket_getsockopt,
+		"fd %d level %d optname %d optval %p optlen %p ret %d",
+		fd, level, optname, optval, optlen, ret);
+}
+
+void probe_socket_shutdown(void *_data, int fd, int how, int ret)
+{
+	trace_mark_tp(net, socket_shutdown, socket_shutdown,
+		probe_socket_shutdown,
+		"fd %d how %d ret %d",
+		fd, how, ret);
+}
+
+void probe_socket_call(void *_data, int call, unsigned long a0)
+{
+	trace_mark_tp(net, socket_call, socket_call, probe_socket_call,
+		"call %d a0 %lu", call, a0);
+}
+
+void probe_tcpv4_rcv(void *_data, struct sk_buff *skb);
+
+DEFINE_MARKER_TP(net, tcpv4_rcv, net_tcpv4_rcv, probe_tcpv4_rcv,
+	"skb %p");
+
+notrace void probe_tcpv4_rcv(void *_data, struct sk_buff *skb)
+{
+	struct marker *marker;
+
+	marker = &GET_MARKER(net, tcpv4_rcv);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&skb, sizeof(skb), sizeof(skb));
+}
+
+void probe_udpv4_rcv(void *_data, struct sk_buff *skb);
+
+DEFINE_MARKER_TP(net, udpv4_rcv, net_udpv4_rcv, probe_udpv4_rcv,
+	"skb %p");
+
+notrace void probe_udpv4_rcv(void *_data, struct sk_buff *skb)
+{
+	struct marker *marker;
+
+	marker = &GET_MARKER(net, udpv4_rcv);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&skb, sizeof(skb), sizeof(skb));
+}
+
+#ifdef CONFIG_NETPOLL
+void probe_net_napi_schedule(void *_data, struct napi_struct *n);
+
+DEFINE_MARKER_TP(net, napi_schedule, net_napi_schedule,
+	probe_net_napi_schedule,
+	"napi_struct %p name %s");
+
+notrace void probe_net_napi_schedule(void *_data, struct napi_struct *n)
+{
+	struct marker *marker;
+	struct serialize_long_ifname data;
+	size_t data_len = 0;
+
+	data.f1 = (unsigned long)n;
+	data_len += sizeof(data.f1);
+	/* No need to align for strings */
+	strcpy(data.f2, n->dev ? n->dev->name : "<unk>");
+	data_len += strlen(data.f2) + 1;
+
+	marker = &GET_MARKER(net, napi_schedule);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, data_len, sizeof(long));
+}
+
+void probe_net_napi_poll(void *_data, struct napi_struct *n);
+
+DEFINE_MARKER_TP(net, napi_poll, net_napi_poll,
+	probe_net_napi_poll,
+	"napi_struct %p name %s");
+
+notrace void probe_net_napi_poll(void *_data, struct napi_struct *n)
+{
+	struct marker *marker;
+	struct serialize_long_ifname data;
+	size_t data_len = 0;
+
+	data.f1 = (unsigned long)n;
+	data_len += sizeof(data.f1);
+	/* No need to align for strings */
+	strcpy(data.f2, n->dev ? n->dev->name : "<unk>");
+	data_len += strlen(data.f2) + 1;
+
+	marker = &GET_MARKER(net, napi_poll);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, data_len, sizeof(long));
+}
+
+void probe_net_napi_complete(void *_data, struct napi_struct *n);
+
+DEFINE_MARKER_TP(net, napi_complete, net_napi_complete,
+	probe_net_napi_complete,
+	"napi_struct %p name %s");
+
+notrace void probe_net_napi_complete(void *_data, struct napi_struct *n)
+{
+	struct marker *marker;
+	struct serialize_long_ifname data;
+	size_t data_len = 0;
+
+	data.f1 = (unsigned long)n;
+	data_len += sizeof(data.f1);
+	/* No need to align for strings */
+	strcpy(data.f2, n->dev ? n->dev->name : "<unk>");
+	data_len += strlen(data.f2) + 1;
+
+	marker = &GET_MARKER(net, napi_complete);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, data_len, sizeof(long));
+}
+#else /* !CONFIG_NETPOLL */
+void probe_net_napi_schedule(void *_data, struct napi_struct *n);
+
+DEFINE_MARKER_TP(net, napi_schedule, net_napi_schedule,
+	probe_net_napi_schedule,
+	"napi_struct %p");
+
+notrace void probe_net_napi_schedule(void *_data, struct napi_struct *n)
+{
+	struct marker *marker;
+	unsigned long data;
+
+	data = (unsigned long)n;
+
+	marker = &GET_MARKER(net, napi_schedule);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, sizeof(data), sizeof(data));
+}
+
+void probe_net_napi_poll(void *_data, struct napi_struct *n);
+
+DEFINE_MARKER_TP(net, napi_poll, net_napi_poll,
+	probe_net_napi_poll,
+	"napi_struct %p");
+
+notrace void probe_net_napi_poll(void *_data, struct napi_struct *n)
+{
+	struct marker *marker;
+	unsigned long data;
+
+	data = (unsigned long)n;
+
+	marker = &GET_MARKER(net, napi_poll);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, sizeof(data), sizeof(data));
+}
+
+void probe_net_napi_complete(void *_data, struct napi_struct *n);
+
+DEFINE_MARKER_TP(net, napi_complete, net_napi_complete,
+	probe_net_napi_complete,
+	"napi_struct %p");
+
+notrace void probe_net_napi_complete(void *_data, struct napi_struct *n)
+{
+	struct marker *marker;
+	unsigned long data;
+
+	data = (unsigned long)n;
+
+	marker = &GET_MARKER(net, napi_complete);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, sizeof(data), sizeof(data));
+}
+#endif
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("Net Tracepoint Probes");
diff --git a/drivers/staging/lttng/discard/probes/pm-trace.c b/drivers/staging/lttng/discard/probes/pm-trace.c
new file mode 100644
index 0000000..7abe8e3
--- /dev/null
+++ b/drivers/staging/lttng/discard/probes/pm-trace.c
@@ -0,0 +1,43 @@
+/*
+ * ltt/probes/pm-trace.c
+ *
+ * Power Management tracepoint probes.
+ *
+ * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+#include <trace/pm.h>
+
+void probe_pm_idle_entry(void *_data)
+{
+	trace_mark_tp(pm, idle_entry, pm_idle_entry,
+		probe_pm_idle_entry, "irqstate #1%d",
+		irqs_disabled());
+}
+
+void probe_pm_idle_exit(void *_data)
+{
+	trace_mark_tp(pm, idle_exit, pm_idle_exit,
+		probe_pm_idle_exit, "irqstate #1%d",
+		irqs_disabled());
+}
+
+void probe_pm_suspend_entry(void *_data)
+{
+	trace_mark_tp(pm, suspend_entry, pm_suspend_entry,
+		probe_pm_suspend_entry, "irqstate #1%d",
+		irqs_disabled());
+}
+
+void probe_pm_suspend_exit(void *_data)
+{
+	trace_mark_tp(pm, suspend_exit, pm_suspend_exit,
+		probe_pm_suspend_exit, "irqstate #1%d",
+		irqs_disabled());
+}
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("Power Management Tracepoint Probes");
diff --git a/drivers/staging/lttng/discard/probes/rcu-trace.c b/drivers/staging/lttng/discard/probes/rcu-trace.c
new file mode 100644
index 0000000..cc16454
--- /dev/null
+++ b/drivers/staging/lttng/discard/probes/rcu-trace.c
@@ -0,0 +1,36 @@
+/*
+ * ltt/probes/rcu-trace.c
+ *
+ * RCU tracepoint probes.
+ *
+ * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+#include <trace/rcu.h>
+
+#ifdef CONFIG_TREE_RCU
+void probe_rcu_tree_callback(void *data, struct rcu_head *head)
+{
+	trace_mark_tp(rcu, tree_callback, rcu_tree_callback,
+		probe_rcu_tree_callback, "func %p", head->func);
+}
+
+void probe_rcu_tree_call_rcu(void *data, struct rcu_head *head, unsigned long ip)
+{
+	trace_mark_tp(rcu, tree_call_rcu, rcu_tree_call_rcu,
+		probe_rcu_tree_call_rcu, "func %p ip 0x%lX", head->func, ip);
+}
+
+void probe_rcu_tree_call_rcu_bh(void *data, struct rcu_head *head, unsigned long ip)
+{
+	trace_mark_tp(rcu, tree_call_rcu_bh, rcu_tree_call_rcu_bh,
+		probe_rcu_tree_call_rcu_bh, "func %p ip 0x%lX",
+		head->func, ip);
+}
+#endif
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("RCU Tracepoint Probes");
diff --git a/drivers/staging/lttng/discard/probes/syscall-trace.c b/drivers/staging/lttng/discard/probes/syscall-trace.c
new file mode 100644
index 0000000..9ae419f
--- /dev/null
+++ b/drivers/staging/lttng/discard/probes/syscall-trace.c
@@ -0,0 +1,54 @@
+/*
+ * ltt/probes/syscall-trace.c
+ *
+ * System call tracepoint probes.
+ *
+ * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+#include <trace/syscall.h>
+
+#include "../ltt-type-serializer.h"
+
+
+/* kernel_syscall_entry specialized tracepoint probe */
+
+void probe_syscall_entry(void *_data, struct pt_regs *regs, long id);
+
+DEFINE_MARKER_TP(kernel, syscall_entry, syscall_entry,
+	probe_syscall_entry, "ip #p%ld syscall_id #2u%u");
+
+notrace void probe_syscall_entry(void *_data, struct pt_regs *regs, long id)
+{
+	struct marker *marker;
+	struct serialize_long_short data;
+
+	data.f1 = instruction_pointer(regs);
+	data.f2 = (unsigned short)id;
+
+	marker = &GET_MARKER(kernel, syscall_entry);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
+}
+
+/* kernel_syscall_exit specialized tracepoint probe */
+
+void probe_syscall_exit(void *_data, long ret);
+
+DEFINE_MARKER_TP(kernel, syscall_exit, syscall_exit,
+	probe_syscall_exit, "ret %ld");
+
+notrace void probe_syscall_exit(void *_data, long ret)
+{
+	struct marker *marker;
+
+	marker = &GET_MARKER(kernel, syscall_exit);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&ret, sizeof(ret), sizeof(ret));
+}
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("syscall Tracepoint Probes");
diff --git a/drivers/staging/lttng/discard/probes/trap-trace.c b/drivers/staging/lttng/discard/probes/trap-trace.c
new file mode 100644
index 0000000..397254c
--- /dev/null
+++ b/drivers/staging/lttng/discard/probes/trap-trace.c
@@ -0,0 +1,56 @@
+/*
+ * ltt/probes/trap-trace.c
+ *
+ * Trap tracepoint probes.
+ *
+ * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+#include <trace/trap.h>
+
+#include "../ltt-type-serializer.h"
+
+/* kernel_trap_entry specialized tracepoint probe */
+
+void probe_trap_entry(void *_data, struct pt_regs *regs, long id);
+
+DEFINE_MARKER_TP(kernel, trap_entry, trap_entry,
+	probe_trap_entry, "ip #p%ld trap_id #2u%u");
+
+notrace void probe_trap_entry(void *_data, struct pt_regs *regs, long id)
+{
+	struct marker *marker;
+	struct serialize_long_short data;
+
+	if (likely(regs))
+		data.f1 = instruction_pointer(regs);
+	else
+		data.f1 = 0UL;
+	data.f2 = (unsigned short)id;
+
+	marker = &GET_MARKER(kernel, trap_entry);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
+}
+
+/* kernel_syscall_exit specialized tracepoint probe */
+
+void probe_trap_exit(void *_data);
+
+DEFINE_MARKER_TP(kernel, trap_exit, trap_exit,
+	probe_trap_exit, MARK_NOARGS);
+
+notrace void probe_trap_exit(void *_data)
+{
+	struct marker *marker;
+
+	marker = &GET_MARKER(kernel, trap_exit);
+	ltt_specialized_trace(marker, marker->single.probe_private,
+		NULL, 0, 0);
+}
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("Trap Tracepoint Probes");
diff --git a/drivers/staging/lttng/probes/Makefile b/drivers/staging/lttng/probes/Makefile
deleted file mode 100644
index d8f1c40..0000000
--- a/drivers/staging/lttng/probes/Makefile
+++ /dev/null
@@ -1,47 +0,0 @@
-# LTTng tracing probes
-
-ifdef CONFIG_FTRACE
-CFLAGS_REMOVE_kernel-trace.o = -pg
-CFLAGS_REMOVE_mm-trace.o = -pg
-CFLAGS_REMOVE_fs-trace.o = -pg
-CFLAGS_REMOVE_ipc-trace.o = -pg
-CFLAGS_REMOVE_lockdep-trace.o = -pg
-CFLAGS_REMOVE_rcu-trace.o = -pg
-CFLAGS_REMOVE_syscall-trace.o = -pg
-CFLAGS_REMOVE_trap-trace.o = -pg
-CFLAGS_REMOVE_pm-trace.o = -pg
-endif
-
-obj-m += kernel-trace.o mm-trace.o fs-trace.o ipc-trace.o lockdep-trace.o \
-	 rcu-trace.o syscall-trace.o trap-trace.o pm-trace.o
-
-ifeq ($(CONFIG_NET),y)
-ifdef CONFIG_FTRACE
-CFLAGS_REMOVE_net-trace.o = -pg
-CFLAGS_REMOVE_net-extended-trace.o = -pg
-endif
-obj-m += net-trace.o net-extended-trace.o
-endif
-
-ifdef CONFIG_JBD2
-ifdef CONFIG_FTRACE
-CFLAGS_REMOVE_jbd2-trace.o = -pg
-endif
-obj-m += jbd2-trace.o
-endif
-
-#ifdef CONFIG_EXT4_FS
-#ifdef CONFIG_FTRACE
-#CFLAGS_REMOVE_ext4-trace.o = -pg
-#endif
-#obj-$(CONFIG_LTT_TRACEPROBES)	+= ext4-trace.o
-#endif
-
-ifdef CONFIG_BLOCK
-ifdef CONFIG_FTRACE
-CFLAGS_REMOVE_block-trace.o = -pg
-endif
-obj-m += block-trace.o
-endif
-
-
diff --git a/drivers/staging/lttng/probes/block-trace.c b/drivers/staging/lttng/probes/block-trace.c
deleted file mode 100644
index 51ae2cd..0000000
--- a/drivers/staging/lttng/probes/block-trace.c
+++ /dev/null
@@ -1,309 +0,0 @@
-/*
- * ltt/probes/block-trace.c
- *
- * block layer tracepoint probes.
- *
- * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
- * Dual LGPL v2.1/GPL v2 license.
- */
-
-#include <linux/module.h>
-
-#include <trace/events/block.h>
-
-/*
- * Add rq cmd as a sequence. Needs new type. (size + binary blob)
- */
-
-void probe_block_rq_abort(void *data, struct request_queue *q, struct request *rq)
-{
-	int rw = rq->cmd_flags & 0x03;
-
-	if (blk_discard_rq(rq))
-		rw |= (1 << BIO_RW_DISCARD);
-
-	if (blk_pc_request(rq)) {
-		trace_mark_tp(block, rq_abort_pc, block_rq_abort,
-			probe_block_rq_abort,
-			"data_len %u rw %d errors %d",
-			blk_rq_bytes(rq), rw, rq->errors);
-	} else {
-		/*
-		 * FIXME Using a simple trace_mark for the second event
-		 * possibility because tracepoints do not support multiple
-		 * connections to the same probe yet. They should have some
-		 * refcounting. Need to enable both rq_abort_pc and rq_abort_fs
-		 * markers to have the rq_abort_fs marker enabled.
-		 */
-		trace_mark(block, rq_abort_fs,
-			"hard_sector %llu "
-			"rw %d errors %d", (unsigned long long)blk_rq_pos(rq),
-			rw, rq->errors);
-	}
-}
-
-void probe_block_rq_insert(void *data, struct request_queue *q, struct request *rq)
-{
-	int rw = rq->cmd_flags & 0x03;
-
-	if (blk_discard_rq(rq))
-		rw |= (1 << BIO_RW_DISCARD);
-
-	if (blk_pc_request(rq)) {
-		trace_mark_tp(block, rq_insert_pc, block_rq_insert,
-			probe_block_rq_insert,
-			"data_len %u rw %d errors %d",
-			blk_rq_bytes(rq), rw, rq->errors);
-	} else {
-		/*
-		 * FIXME Using a simple trace_mark for the second event
-		 * possibility because tracepoints do not support multiple
-		 * connections to the same probe yet. They should have some
-		 * refcounting. Need to enable both rq_insert_pc and
-		 * rq_insert_fs markers to have the rq_insert_fs marker enabled.
-		 */
-		trace_mark(block, rq_insert_fs,
-			"hard_sector %llu "
-			"rw %d errors %d", (unsigned long long)blk_rq_pos(rq),
-			rw, rq->errors);
-	}
-}
-
-void probe_block_rq_issue(void *data, struct request_queue *q, struct request *rq)
-{
-	int rw = rq->cmd_flags & 0x03;
-
-	if (blk_discard_rq(rq))
-		rw |= (1 << BIO_RW_DISCARD);
-
-	if (blk_pc_request(rq)) {
-		trace_mark_tp(block, rq_issue_pc, block_rq_issue,
-			probe_block_rq_issue,
-			"data_len %u rw %d errors %d",
-			blk_rq_bytes(rq), rw, rq->errors);
-	} else {
-		/*
-		 * FIXME Using a simple trace_mark for the second event
-		 * possibility because tracepoints do not support multiple
-		 * connections to the same probe yet. They should have some
-		 * refcounting. Need to enable both rq_issue_pc and rq_issue_fs
-		 * markers to have the rq_issue_fs marker enabled.
-		 */
-		trace_mark(block, rq_issue_fs,
-			"hard_sector %llu "
-			"rw %d errors %d", (unsigned long long)blk_rq_pos(rq),
-			rw, rq->errors);
-	}
-}
-
-void probe_block_rq_requeue(void *data, struct request_queue *q, struct request *rq)
-{
-	int rw = rq->cmd_flags & 0x03;
-
-	if (blk_discard_rq(rq))
-		rw |= (1 << BIO_RW_DISCARD);
-
-	if (blk_pc_request(rq)) {
-		trace_mark_tp(block, rq_requeue_pc, block_rq_requeue,
-			probe_block_rq_requeue,
-			"data_len %u rw %d errors %d",
-			blk_rq_bytes(rq), rw, rq->errors);
-	} else {
-		/*
-		 * FIXME Using a simple trace_mark for the second event
-		 * possibility because tracepoints do not support multiple
-		 * connections to the same probe yet. They should have some
-		 * refcounting. Need to enable both rq_requeue_pc and
-		 * rq_requeue_fs markers to have the rq_requeue_fs marker
-		 * enabled.
-		 */
-		trace_mark(block, rq_requeue_fs,
-			"hard_sector %llu "
-			"rw %d errors %d", (unsigned long long)blk_rq_pos(rq),
-			rw, rq->errors);
-	}
-}
-
-void probe_block_rq_complete(void *data, struct request_queue *q, struct request *rq)
-{
-	int rw = rq->cmd_flags & 0x03;
-
-	if (blk_discard_rq(rq))
-		rw |= (1 << BIO_RW_DISCARD);
-
-	if (blk_pc_request(rq)) {
-		trace_mark_tp(block, rq_complete_pc, block_rq_complete,
-			probe_block_rq_complete,
-			"data_len %u rw %d errors %d",
-			blk_rq_bytes(rq), rw, rq->errors);
-	} else {
-		/*
-		 * FIXME Using a simple trace_mark for the second event
-		 * possibility because tracepoints do not support multiple
-		 * connections to the same probe yet. They should have some
-		 * refcounting. Need to enable both rq_complete_pc and
-		 * rq_complete_fs markers to have the rq_complete_fs marker
-		 * enabled.
-		 */
-		trace_mark(block, rq_complete_fs,
-			"hard_sector %llu "
-			"rw %d errors %d", (unsigned long long)blk_rq_pos(rq),
-			rw, rq->errors);
-	}
-}
-
-void probe_block_bio_bounce(void *data, struct request_queue *q, struct bio *bio)
-{
-	trace_mark_tp(block, bio_bounce, block_bio_bounce,
-		probe_block_bio_bounce,
-		"sector %llu size %u rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
-		"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
-		"not_uptodate #1u%d",
-		(unsigned long long)bio->bi_sector, bio->bi_size,
-		bio->bi_rw, !bio_flagged(bio, BIO_UPTODATE));
-}
-
-void probe_block_bio_complete(void *data, struct request_queue *q, struct bio *bio)
-{
-	trace_mark_tp(block, bio_complete, block_bio_complete,
-		probe_block_bio_complete,
-		"sector %llu size %u rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
-		"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
-		"not_uptodate #1u%d",
-		(unsigned long long)bio->bi_sector, bio->bi_size,
-		bio->bi_rw, !bio_flagged(bio, BIO_UPTODATE));
-}
-
-void probe_block_bio_backmerge(void *data, struct request_queue *q, struct bio *bio)
-{
-	trace_mark_tp(block, bio_backmerge, block_bio_backmerge,
-		probe_block_bio_backmerge,
-		"sector %llu size %u rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
-		"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
-		"not_uptodate #1u%d",
-		(unsigned long long)bio->bi_sector, bio->bi_size,
-		bio->bi_rw, !bio_flagged(bio, BIO_UPTODATE));
-}
-
-void probe_block_bio_frontmerge(void *data, struct request_queue *q, struct bio *bio)
-{
-	trace_mark_tp(block, bio_frontmerge, block_bio_frontmerge,
-		probe_block_bio_frontmerge,
-		"sector %llu size %u rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
-		"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
-		"not_uptodate #1u%d",
-		(unsigned long long)bio->bi_sector, bio->bi_size,
-		bio->bi_rw, !bio_flagged(bio, BIO_UPTODATE));
-}
-
-void probe_block_bio_queue(void *data, struct request_queue *q, struct bio *bio)
-{
-	trace_mark_tp(block, bio_queue, block_bio_queue,
-		probe_block_bio_queue,
-		"sector %llu size %u rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
-		"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
-		"not_uptodate #1u%d",
-		(unsigned long long)bio->bi_sector, bio->bi_size,
-		bio->bi_rw, !bio_flagged(bio, BIO_UPTODATE));
-}
-
-void probe_block_getrq(void *data, struct request_queue *q, struct bio *bio, int rw)
-{
-	if (bio) {
-		trace_mark_tp(block, getrq_bio, block_getrq,
-			probe_block_getrq,
-			"sector %llu size %u "
-			"rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
-			"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
-			"not_uptodate #1u%d",
-			(unsigned long long)bio->bi_sector, bio->bi_size,
-			bio->bi_rw, !bio_flagged(bio, BIO_UPTODATE));
-	} else {
-		/*
-		 * FIXME Using a simple trace_mark for the second event
-		 * possibility because tracepoints do not support multiple
-		 * connections to the same probe yet. They should have some
-		 * refcounting. Need to enable both getrq_bio and getrq markers
-		 * to have the getrq marker enabled.
-		 */
-		trace_mark(block, getrq, "rw %d", rw);
-	}
-}
-
-void probe_block_sleeprq(void *data, struct request_queue *q, struct bio *bio, int rw)
-{
-	if (bio) {
-		trace_mark_tp(block, sleeprq_bio, block_sleeprq,
-			probe_block_sleeprq,
-			"sector %llu size %u "
-			"rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
-			"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
-			"not_uptodate #1u%d",
-			(unsigned long long)bio->bi_sector, bio->bi_size,
-			bio->bi_rw, !bio_flagged(bio, BIO_UPTODATE));
-	} else {
-		/*
-		 * FIXME Using a simple trace_mark for the second event
-		 * possibility because tracepoints do not support multiple
-		 * connections to the same probe yet. They should have some
-		 * refcounting. Need to enable both sleeprq_bio and sleeprq
-		 * markers to have the sleeprq marker enabled.
-		 */
-		trace_mark(block, sleeprq, "rw %d", rw);
-	}
-}
-
-void probe_block_plug(void *data, struct request_queue *q)
-{
-	trace_mark_tp(block, plug, block_plug, probe_block_plug,
-			 MARK_NOARGS);
-}
-
-void probe_block_unplug_io(void *data, struct request_queue *q)
-{
-	unsigned int pdu = q->rq.count[READ] + q->rq.count[WRITE];
-
-	trace_mark_tp(block, unplug_io, block_unplug_io, probe_block_unplug_io,
-			"pdu %u", pdu);
-}
-
-void probe_block_unplug_timer(void *data, struct request_queue *q)
-{
-	unsigned int pdu = q->rq.count[READ] + q->rq.count[WRITE];
-
-	trace_mark_tp(block, unplug_timer, block_unplug_timer,
-			probe_block_unplug_timer,
-			"pdu %u", pdu);
-}
-
-void probe_block_split(void *data, struct request_queue *q, struct bio *bio,
-		       unsigned int pdu)
-{
-	trace_mark_tp(block, split, block_split,
-		probe_block_split,
-		"sector %llu size %u rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
-		"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
-		"not_uptodate #1u%d pdu %u",
-		(unsigned long long)bio->bi_sector, bio->bi_size,
-		bio->bi_rw, !bio_flagged(bio, BIO_UPTODATE), pdu);
-}
-
-void probe_block_remap(void *data, struct request_queue *q, struct bio *bio,
-		       dev_t dev, sector_t from)
-{
-	trace_mark_tp(block, remap, block_remap,
-		probe_block_remap,
-		"device_from %lu sector_from %llu device_to %lu "
-		"size %u rw(FAILFAST_DRIVER,FAILFAST_TRANSPORT,"
-		"FAILFAST_DEV,DISCARD,META,SYNC,BARRIER,AHEAD,RW) %lX "
-		"not_uptodate #1u%d",
-		(unsigned long)bio->bi_bdev->bd_dev,
-		(unsigned long long)from,
-		(unsigned long)dev,
-		bio->bi_size, bio->bi_rw,
-		!bio_flagged(bio, BIO_UPTODATE));
-}
-
-MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Mathieu Desnoyers");
-MODULE_DESCRIPTION("Block Tracepoint Probes");
diff --git a/drivers/staging/lttng/probes/ext4-trace.c b/drivers/staging/lttng/probes/ext4-trace.c
deleted file mode 100644
index 83683e7..0000000
--- a/drivers/staging/lttng/probes/ext4-trace.c
+++ /dev/null
@@ -1,611 +0,0 @@
-/*
- * ltt/probes/ext4-trace.c
- *
- * ext4 tracepoint probes.
- *
- * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
- * Dual LGPL v2.1/GPL v2 license.
- */
-
-#include <linux/module.h>
-#include <linux/writeback.h>
-#include <linux/debugfs.h>
-#include <linux/mutex.h>
-#include <linux/rcupdate.h>
-#include <trace/events/ext4.h>
-
-#include "../ltt-tracer.h"
-#include "../../fs/ext4/mballoc.h"
-
-static struct dentry *ext4_filter_dentry, *ext4_filter_dev_dentry,
-	*ext4_filter_inode_dentry;
-static DEFINE_MUTEX(ext4_filter_mutex);
-/* Make sure we don't race between module exit and file write */
-static int module_exits;
-
-struct rcu_dev_filter {
-	struct rcu_head rcu;
-	char devname[NAME_MAX];
-};
-
-static struct rcu_dev_filter *dev_filter;
-/* ~0UL inode_filter enables all inodes */
-static unsigned long inode_filter = ~0UL;
-
-/*
- * Probes are executed in rcu_sched read-side critical section.
- */
-
-static int do_dev_filter(const char *dev)
-{
-	struct rcu_dev_filter *ldev_filter = rcu_dereference(dev_filter);
-
-	if (unlikely(ldev_filter))
-		if (unlikely(strcmp(ldev_filter->devname, dev)))
-			return 0;
-	return 1;
-}
-
-static int do_inode_filter(unsigned long ino)
-{
-	if (unlikely(inode_filter != ~0UL))
-		if (unlikely(inode_filter != ino))
-			return 0;
-	return 1;
-}
-
-/*
- * Logical AND between dev and inode filter.
- */
-static int do_filter(const char *dev, unsigned long ino)
-{
-	if (unlikely(!do_dev_filter(dev)))
-		return 0;
-	if (unlikely(!do_inode_filter(ino)))
-		return 0;
-	return 1;
-}
-
-
-void probe_ext4_free_inode(void *data, struct inode *inode)
-{
-	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
-		return;
-	trace_mark_tp(ext4, free_inode, ext4_free_inode,
-		probe_ext4_free_inode,
-		"dev %s ino %lu mode %d uid %lu gid %lu blocks %llu",
-		inode->i_sb->s_id, inode->i_ino, inode->i_mode,
-		(unsigned long) inode->i_uid, (unsigned long) inode->i_gid,
-		(unsigned long long) inode->i_blocks);
-}
-
-void probe_ext4_request_inode(void *data, struct inode *dir, int mode)
-{
-	if (unlikely(!do_filter(dir->i_sb->s_id, dir->i_ino)))
-		return;
-	trace_mark_tp(ext4, request_inode, ext4_request_inode,
-		probe_ext4_request_inode,
-		"dev %s dir %lu mode %d",
-		dir->i_sb->s_id, dir->i_ino, mode);
-}
-
-void probe_ext4_allocate_inode(void *data, struct inode *inode, struct inode *dir, int mode)
-{
-	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)
-		     && !do_filter(dir->i_sb->s_id, dir->i_ino)))
-		return;
-	trace_mark_tp(ext4, allocate_inode, ext4_allocate_inode,
-		probe_ext4_allocate_inode,
-		"dev %s ino %lu dir %lu mode %d",
-		dir->i_sb->s_id, inode->i_ino, dir->i_ino, mode);
-}
-
-void probe_ext4_write_begin(void *data, struct inode *inode, loff_t pos, unsigned int len,
-			    unsigned int flags)
-{
-	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
-		return;
-	trace_mark_tp(ext4, write_begin, ext4_write_begin,
-		probe_ext4_write_begin,
-		"dev %s ino %lu pos %llu len %u flags %u",
-		inode->i_sb->s_id, inode->i_ino,
-		(unsigned long long) pos, len, flags);
-}
-
-void probe_ext4_ordered_write_end(void *data, struct inode *inode, loff_t pos,
-			    unsigned int len, unsigned int copied)
-{
-	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
-		return;
-	trace_mark_tp(ext4, ordered_write_end, ext4_ordered_write_end,
-		probe_ext4_ordered_write_end,
-		"dev %s ino %lu pos %llu len %u copied %u",
-		inode->i_sb->s_id, inode->i_ino,
-		(unsigned long long) pos, len, copied);
-}
-
-void probe_ext4_writeback_write_end(void *data, struct inode *inode, loff_t pos,
-			    unsigned int len, unsigned int copied)
-{
-	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
-		return;
-	trace_mark_tp(ext4, writeback_write_end, ext4_writeback_write_end,
-		probe_ext4_writeback_write_end,
-		"dev %s ino %lu pos %llu len %u copied %u",
-		inode->i_sb->s_id, inode->i_ino,
-		(unsigned long long) pos, len, copied);
-}
-
-void probe_ext4_journalled_write_end(void *data, struct inode *inode, loff_t pos,
-			    unsigned int len, unsigned int copied)
-{
-	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
-		return;
-	trace_mark_tp(ext4, journalled_write_end, ext4_journalled_write_end,
-		probe_ext4_journalled_write_end,
-		"dev %s ino %lu pos %llu len %u copied %u",
-		inode->i_sb->s_id, inode->i_ino,
-		(unsigned long long) pos, len, copied);
-}
-
-/*
- * note : wbc_flags will have to be decoded by userspace.
- * #1x uses a single byte in the trace. Limits to 8 bits.
- */
-void probe_ext4_da_writepages(void *data, struct inode *inode,
-			      struct writeback_control *wbc)
-{
-	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
-		return;
-	trace_mark_tp(ext4, da_writepages, ext4_da_writepages,
-		probe_ext4_da_writepages,
-		"dev %s ino %lu nr_to_write %ld "
-		"pages_skipped %ld range_start %llu range_end %llu "
-		"wbc_flags(nonblocking,for_kupdate,"
-		"for_reclaim,range_cyclic) #1x%u",
-		inode->i_sb->s_id, inode->i_ino, wbc->nr_to_write,
-		wbc->pages_skipped,
-		(unsigned long long) wbc->range_start,
-		(unsigned long long) wbc->range_end,
-		  (wbc->nonblocking << 3)
-		| (wbc->for_kupdate << 2)
-		| (wbc->for_reclaim << 1)
-		| wbc->range_cyclic);
-}
-
-/*
- * note : wbc_flags will have to be decoded by userspace.
- * #1x uses a single byte in the trace. Limits to 8 bits.
- */
-void probe_ext4_da_writepages_result(void *data, struct inode *inode,
-				     struct writeback_control *wbc,
-				     int ret, int pages_written)
-{
-	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
-		return;
-	trace_mark_tp(ext4, da_writepages_result, ext4_da_writepages_result,
-		probe_ext4_da_writepages_result,
-		"dev %s ino %lu ret %d pages_written %d "
-		"pages_skipped %ld "
-		"wbc_flags(encountered_congestion,"
-		"more_io,no_nrwrite_index_update) #1x%u",
-		inode->i_sb->s_id, inode->i_ino, ret, pages_written,
-		wbc->pages_skipped,
-		  (wbc->encountered_congestion << 2)
-		| (wbc->more_io << 1)
-		| wbc->no_nrwrite_index_update);
-}
-
-void probe_ext4_da_write_begin(void *data, struct inode *inode, loff_t pos,
-			    unsigned int len, unsigned int flags)
-{
-	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
-		return;
-	trace_mark_tp(ext4, da_write_begin, ext4_da_write_begin,
-		probe_ext4_da_write_begin,
-		"dev %s ino %lu pos %llu len %u flags %u",
-		inode->i_sb->s_id, inode->i_ino,
-		(unsigned long long) pos, len, flags);
-}
-
-void probe_ext4_da_write_end(void *data, struct inode *inode, loff_t pos,
-			    unsigned int len, unsigned int copied)
-{
-	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
-		return;
-	trace_mark_tp(ext4, da_write_end, ext4_da_write_end,
-		probe_ext4_da_write_end,
-		"dev %s ino %lu pos %llu len %u copied %u",
-		inode->i_sb->s_id, inode->i_ino,
-		(unsigned long long) pos, len, copied);
-}
-
-void probe_ext4_discard_blocks(void *data, struct super_block *sb, unsigned long long blk,
-			       unsigned long long count)
-{
-	if (unlikely(!do_dev_filter(sb->s_id)))
-		return;
-	trace_mark_tp(ext4, discard_blocks, ext4_discard_blocks,
-		probe_ext4_discard_blocks,
-		"dev %s blk %llu count %llu",
-		sb->s_id, blk, count);
-}
-
-void probe_ext4_mb_new_inode_pa(void *data, struct ext4_allocation_context *ac,
-			        struct ext4_prealloc_space *pa)
-{
-	if (unlikely(!do_filter(ac->ac_sb->s_id, ac->ac_inode->i_ino)))
-		return;
-	trace_mark_tp(ext4, mb_new_inode_pa, ext4_mb_new_inode_pa,
-		probe_ext4_mb_new_inode_pa,
-		"dev %s ino %lu pstart %llu len %u lstart %u",
-		ac->ac_sb->s_id, ac->ac_inode->i_ino, pa->pa_pstart,
-		pa->pa_len, pa->pa_lstart);
-}
-
-void probe_ext4_mb_new_group_pa(void *data, struct ext4_allocation_context *ac,
-			        struct ext4_prealloc_space *pa)
-{
-	if (unlikely(!do_dev_filter(ac->ac_sb->s_id)))
-		return;
-	trace_mark_tp(ext4, mb_new_group_pa, ext4_mb_new_group_pa,
-		probe_ext4_mb_new_group_pa,
-		"dev %s pstart %llu len %u lstart %u",
-		ac->ac_sb->s_id, pa->pa_pstart,
-		pa->pa_len, pa->pa_lstart);
-}
-
-void probe_ext4_mb_release_inode_pa(void *data, struct ext4_allocation_context *ac,
-				    struct ext4_prealloc_space *pa,
-				    unsigned long long block,
-				    unsigned int count)
-{
-	if (unlikely(!do_filter(ac->ac_sb->s_id, ac->ac_inode->i_ino)))
-		return;
-	trace_mark_tp(ext4, mb_release_inode_pa, ext4_mb_release_inode_pa,
-		probe_ext4_mb_release_inode_pa,
-		"dev %s ino %lu block %llu count %u",
-		ac->ac_sb->s_id, pa->pa_inode->i_ino, block, count);
-}
-
-void probe_ext4_mb_release_group_pa(void *data, struct ext4_allocation_context *ac,
-				    struct ext4_prealloc_space *pa)
-{
-	if (unlikely(!do_dev_filter(ac->ac_sb->s_id)))
-		return;
-	trace_mark_tp(ext4, mb_release_group_pa, ext4_mb_release_group_pa,
-		probe_ext4_mb_release_group_pa,
-		"dev %s pstart %llu len %d",
-		ac->ac_sb->s_id, pa->pa_pstart, pa->pa_len);
-}
-
-void probe_ext4_discard_preallocations(void *data, struct inode *inode)
-{
-	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
-		return;
-	trace_mark_tp(ext4, discard_preallocations,
-		ext4_discard_preallocations,
-		probe_ext4_discard_preallocations,
-		"dev %s ino %lu",
-		inode->i_sb->s_id, inode->i_ino);
-}
-
-void probe_ext4_mb_discard_preallocations(void *data, struct super_block *sb, int needed)
-{
-	if (unlikely(!do_dev_filter(sb->s_id)))
-		return;
-	trace_mark_tp(ext4, mb_discard_preallocations,
-		ext4_mb_discard_preallocations,
-		probe_ext4_mb_discard_preallocations,
-		"dev %s needed %d",
-		sb->s_id, needed);
-}
-
-void probe_ext4_request_blocks(void *data, struct ext4_allocation_request *ar)
-{
-	if (ar->inode) {
-		if (unlikely(!do_filter(ar->inode->i_sb->s_id,
-					ar->inode->i_ino)))
-			return;
-	} else {
-		if (unlikely(!do_dev_filter(ar->inode->i_sb->s_id)))
-			return;
-	}
-	trace_mark_tp(ext4, request_blocks, ext4_request_blocks,
-		probe_ext4_request_blocks,
-		"dev %s flags %u len %u ino %lu "
-		"lblk %llu goal %llu lleft %llu lright %llu "
-		"pleft %llu pright %llu",
-		ar->inode->i_sb->s_id, ar->flags, ar->len,
-		ar->inode ? ar->inode->i_ino : 0,
-		(unsigned long long) ar->logical,
-		(unsigned long long) ar->goal,
-		(unsigned long long) ar->lleft,
-		(unsigned long long) ar->lright,
-		(unsigned long long) ar->pleft,
-		(unsigned long long) ar->pright);
-}
-
-void probe_ext4_allocate_blocks(void *data, struct ext4_allocation_request *ar,
-				unsigned long long block)
-{
-	if (ar->inode) {
-		if (unlikely(!do_filter(ar->inode->i_sb->s_id,
-					ar->inode->i_ino)))
-			return;
-	} else {
-		if (unlikely(!do_dev_filter(ar->inode->i_sb->s_id)))
-			return;
-	}
-	trace_mark_tp(ext4, allocate_blocks, ext4_allocate_blocks,
-		probe_ext4_allocate_blocks,
-		"dev %s block %llu flags %u len %u ino %lu "
-		"logical %llu goal %llu lleft %llu lright %llu "
-		"pleft %llu pright %llu",
-		ar->inode->i_sb->s_id, (unsigned long long) block,
-		ar->flags, ar->len, ar->inode ? ar->inode->i_ino : 0,
-		(unsigned long long) ar->logical,
-		(unsigned long long) ar->goal,
-		(unsigned long long) ar->lleft,
-		(unsigned long long) ar->lright,
-		(unsigned long long) ar->pleft,
-		(unsigned long long) ar->pright);
-}
-
-void probe_ext4_free_blocks(void *data, struct inode *inode, __u64 block,
-			    unsigned long count, int metadata)
-{
-	if (unlikely(!do_filter(inode->i_sb->s_id, inode->i_ino)))
-		return;
-	trace_mark_tp(ext4, free_blocks, ext4_free_blocks,
-		probe_ext4_free_blocks,
-		"dev %s block %llu count %lu metadata %d ino %lu",
-		inode->i_sb->s_id, (unsigned long long)block,
-		count, metadata, inode->i_ino);
-}
-
-void probe_ext4_sync_file(void *data, struct file *file, struct dentry *dentry,
-			  int datasync)
-{
-	if (unlikely(!do_dev_filter(dentry->d_inode->i_sb->s_id)))
-		return;
-	if (unlikely(!do_inode_filter(dentry->d_inode->i_ino)
-			&& !do_inode_filter(dentry->d_parent->d_inode->i_ino)))
-		return;
-	trace_mark_tp(ext4, sync_file, ext4_sync_file,
-		probe_ext4_sync_file,
-		"dev %s datasync %d ino %ld parent %ld",
-		dentry->d_inode->i_sb->s_id, datasync, dentry->d_inode->i_ino,
-		dentry->d_parent->d_inode->i_ino);
-}
-
-void probe_ext4_sync_fs(void *data, struct super_block *sb, int wait)
-{
-	if (unlikely(!do_dev_filter(sb->s_id)))
-		return;
-	trace_mark_tp(ext4, sync_fs, ext4_sync_fs,
-		probe_ext4_sync_fs,
-		"dev %s wait %d",
-		sb->s_id, wait);
-}
-
-static void free_dev_filter(struct rcu_head *head)
-{
-	kfree(container_of(head, struct rcu_dev_filter, rcu));
-}
-
-static ssize_t dev_filter_op_write(struct file *file,
-	const char __user *user_buf, size_t count, loff_t *ppos)
-{
-	int err = 0;
-	char buf[NAME_MAX];
-	int buf_size;
-	char name[NAME_MAX];
-	struct rcu_dev_filter *new, *old;
-
-	mutex_lock(&ext4_filter_mutex);
-	if (module_exits) {
-		err = -EPERM;
-		goto error;
-	}
-	buf_size = min(count, sizeof(buf) - 1);
-	err = copy_from_user(buf, user_buf, buf_size);
-	if (err)
-		goto error;
-	buf[buf_size] = 0;
-
-	if (sscanf(buf, "%s", name) != 1) {
-		err = -EPERM;
-		goto error;
-	}
-
-	old = dev_filter;
-
-	/* Empty string or * means all active */
-	if (name[0] == '\0' || (name[0] == '*' && name[1] == '\0')) {
-		new = NULL;
-	} else {
-		new = kmalloc(sizeof(*new), GFP_KERNEL);
-		strcpy(new->devname, name);
-	}
-
-	rcu_assign_pointer(dev_filter, new);
-	if (old)
-		call_rcu_sched(&old->rcu, free_dev_filter);
-
-	mutex_unlock(&ext4_filter_mutex);
-	return count;
-
-error:
-	mutex_unlock(&ext4_filter_mutex);
-	return err;
-}
-
-static ssize_t dev_filter_op_read(struct file *filp, char __user *buffer,
-	size_t count, loff_t *ppos)
-{
-	ssize_t bcount;
-	const char *devname;
-
-	mutex_lock(&ext4_filter_mutex);
-	if (!dev_filter)
-		devname = "*";
-	else
-		devname = dev_filter->devname;
-	bcount = simple_read_from_buffer(buffer, count, ppos,
-			devname, strlen(devname));
-	mutex_unlock(&ext4_filter_mutex);
-	return bcount;
-}
-
-static struct file_operations ext4_dev_file_operations = {
-	.write = dev_filter_op_write,
-	.read = dev_filter_op_read,
-};
-
-static ssize_t inode_filter_op_write(struct file *file,
-	const char __user *user_buf, size_t count, loff_t *ppos)
-{
-	int err = 0;
-	char buf[NAME_MAX];
-	int buf_size;
-	char name[NAME_MAX];
-	unsigned long inode_num;
-
-	mutex_lock(&ext4_filter_mutex);
-	if (module_exits) {
-		err = -EPERM;
-		goto error;
-	}
-	buf_size = min(count, sizeof(buf) - 1);
-	err = copy_from_user(buf, user_buf, buf_size);
-	if (err)
-		goto error;
-	buf[buf_size] = 0;
-
-	if (sscanf(buf, "%s", name) != 1) {
-		err = -EPERM;
-		goto error;
-	}
-
-	/* Empty string or * means all active */
-	if (name[0] == '\0' || (name[0] == '*' && name[1] == '\0')) {
-		inode_filter = ~0UL;
-	} else {
-		if (sscanf(buf, "%lu", &inode_num) != 1) {
-			err = -EPERM;
-			goto error;
-		}
-		inode_filter = inode_num;
-	}
-
-	mutex_unlock(&ext4_filter_mutex);
-	return count;
-
-error:
-	mutex_unlock(&ext4_filter_mutex);
-	return err;
-}
-
-static ssize_t inode_filter_op_read(struct file *filp, char __user *buffer,
-	size_t count, loff_t *ppos)
-{
-	ssize_t bcount;
-	char inode_str[NAME_MAX];
-
-	mutex_lock(&ext4_filter_mutex);
-	if (inode_filter == ~0UL)
-		strcpy(inode_str, "*");
-	else {
-		bcount = snprintf(inode_str, sizeof(inode_str), "%lu",
-			       inode_filter);
-		if (bcount == sizeof(inode_str))
-			bcount = -ENOSPC;
-		if (bcount < 0)
-			goto end;
-	}
-	bcount = simple_read_from_buffer(buffer, count, ppos,
-			inode_str, strlen(inode_str));
-end:
-	mutex_unlock(&ext4_filter_mutex);
-	return bcount;
-}
-
-static struct file_operations ext4_inode_file_operations = {
-	.write = inode_filter_op_write,
-	.read = inode_filter_op_read,
-};
-
-static void release_filter_dev(void)
-{
-	struct rcu_dev_filter *old;
-
-	mutex_lock(&ext4_filter_mutex);
-	module_exits = 1;
-	old = dev_filter;
-	rcu_assign_pointer(dev_filter, NULL);
-	if (old)
-		call_rcu_sched(&old->rcu, free_dev_filter);
-	mutex_unlock(&ext4_filter_mutex);
-}
-
-static int __init filter_init(void)
-{
-	struct dentry *filter_root_dentry;
-	int err = 0;
-
-	filter_root_dentry = get_filter_root();
-	if (!filter_root_dentry) {
-		err = -ENOENT;
-		goto end;
-	}
-
-	ext4_filter_dentry = debugfs_create_dir("ext4", filter_root_dentry);
-
-	if (IS_ERR(ext4_filter_dentry) || !ext4_filter_dentry) {
-		printk(KERN_ERR "Failed to create ext4 filter file\n");
-		err = -ENOMEM;
-		goto end;
-	}
-
-	ext4_filter_dev_dentry = debugfs_create_file("dev", S_IWUSR,
-			ext4_filter_dentry, NULL, &ext4_dev_file_operations);
-	if (IS_ERR(ext4_filter_dev_dentry) || !ext4_filter_dev_dentry) {
-		printk(KERN_ERR "Failed to create ext4 dev filter file\n");
-		err = -ENOMEM;
-		goto release_filter_dentry;
-	}
-
-	ext4_filter_inode_dentry = debugfs_create_file("inode", S_IWUSR,
-			ext4_filter_dentry, NULL, &ext4_inode_file_operations);
-	if (IS_ERR(ext4_filter_inode_dentry) || !ext4_filter_inode_dentry) {
-		printk(KERN_ERR "Failed to create ext4 inode filter file\n");
-		err = -ENOMEM;
-		goto release_filter_dev_dentry;
-	}
-
-	goto end;
-
-release_filter_dev_dentry:
-	debugfs_remove(ext4_filter_dev_dentry);
-release_filter_dentry:
-	debugfs_remove(ext4_filter_dentry);
-	release_filter_dev();
-end:
-	return err;
-}
-
-static void __exit filter_exit(void)
-{
-	debugfs_remove(ext4_filter_dev_dentry);
-	debugfs_remove(ext4_filter_inode_dentry);
-	debugfs_remove(ext4_filter_dentry);
-	release_filter_dev();
-}
-
-module_init(filter_init);
-module_exit(filter_exit);
-
-MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Mathieu Desnoyers");
-MODULE_DESCRIPTION("ext4 Tracepoint Probes");
diff --git a/drivers/staging/lttng/probes/fs-trace.c b/drivers/staging/lttng/probes/fs-trace.c
deleted file mode 100644
index bca2827..0000000
--- a/drivers/staging/lttng/probes/fs-trace.c
+++ /dev/null
@@ -1,158 +0,0 @@
-/*
- * ltt/probes/fs-trace.c
- *
- * FS tracepoint probes.
- *
- * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
- * Dual LGPL v2.1/GPL v2 license.
- */
-
-#include <linux/module.h>
-#include <linux/buffer_head.h>
-#include <trace/fs.h>
-
-#include "../ltt-type-serializer.h"
-
-void probe_fs_buffer_wait_start(void *_data, struct buffer_head *bh)
-{
-	trace_mark_tp(fs, buffer_wait_start, fs_buffer_wait_start,
-		probe_fs_buffer_wait_start, "bh %p", bh);
-}
-
-void probe_fs_buffer_wait_end(void *_data, struct buffer_head *bh)
-{
-	trace_mark_tp(fs, buffer_wait_end, fs_buffer_wait_end,
-		probe_fs_buffer_wait_end, "bh %p", bh);
-}
-
-void probe_fs_exec(void *_data, char *filename)
-{
-	trace_mark_tp(fs, exec, fs_exec, probe_fs_exec, "filename %s",
-		filename);
-}
-
-void probe_fs_ioctl(void *_data, unsigned int fd, unsigned int cmd, unsigned long arg)
-{
-	trace_mark_tp(fs, ioctl, fs_ioctl, probe_fs_ioctl,
-		"fd %u cmd %u arg %lu", fd, cmd, arg);
-}
-
-void probe_fs_open(void *_data, int fd, char *filename)
-{
-	trace_mark_tp(fs, open, fs_open, probe_fs_open,
-		"fd %d filename %s", fd, filename);
-}
-
-void probe_fs_close(void *_data, unsigned int fd)
-{
-	trace_mark_tp(fs, close, fs_close, probe_fs_close, "fd %u", fd);
-}
-
-void probe_fs_lseek(void *_data, unsigned int fd, long offset, unsigned int origin)
-{
-	trace_mark_tp(fs, lseek, fs_lseek, probe_fs_lseek,
-		"fd %u offset %ld origin %u", fd, offset, origin);
-}
-
-void probe_fs_llseek(void *_data, unsigned int fd, loff_t offset, unsigned int origin)
-{
-	trace_mark_tp(fs, llseek, fs_llseek, probe_fs_llseek,
-		"fd %u offset %lld origin %u", fd,
-		(long long)offset, origin);
-}
-
-void probe_fs_read(void *_data, unsigned int fd, char __user *buf, size_t count,
-		ssize_t ret);
-
-DEFINE_MARKER_TP(fs, read, fs_read, probe_fs_read,
-	"count %zu fd %u");
-
-notrace void probe_fs_read(void *_data, unsigned int fd, char __user *buf, size_t count,
-		ssize_t ret)
-{
-	struct marker *marker;
-	struct serialize_sizet_int data;
-
-	data.f1 = count;
-	data.f2 = fd;
-
-	marker = &GET_MARKER(fs, read);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(size_t));
-}
-
-void probe_fs_write(void *_data, unsigned int fd, char __user *buf, size_t count,
-		ssize_t ret);
-
-DEFINE_MARKER_TP(fs, write, fs_write, probe_fs_write,
-	"count %zu fd %u");
-
-notrace void probe_fs_write(void *_data, unsigned int fd, char __user *buf, size_t count,
-		ssize_t ret)
-{
-	struct marker *marker;
-	struct serialize_sizet_int data;
-
-	data.f1 = count;
-	data.f2 = fd;
-
-	marker = &GET_MARKER(fs, write);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(size_t));
-}
-
-void probe_fs_pread64(void *_data, unsigned int fd, char __user *buf, size_t count,
-		loff_t pos, ssize_t ret)
-{
-	trace_mark_tp(fs, pread64, fs_pread64, probe_fs_pread64,
-		"fd %u count %zu pos %llu",
-		fd, count, (unsigned long long)pos);
-}
-
-void probe_fs_pwrite64(void *_data, unsigned int fd, const char __user *buf,
-		size_t count, loff_t pos, ssize_t ret)
-{
-	trace_mark_tp(fs, pwrite64, fs_pwrite64, probe_fs_pwrite64,
-		"fd %u count %zu pos %llu",
-		fd, count, (unsigned long long)pos);
-}
-
-void probe_fs_readv(void *_data, unsigned long fd, const struct iovec __user *vec,
-		unsigned long vlen, ssize_t ret)
-{
-	trace_mark_tp(fs, readv, fs_readv, probe_fs_readv,
-		"fd %lu vlen %lu", fd, vlen);
-}
-
-void probe_fs_writev(void *_data, unsigned long fd, const struct iovec __user *vec,
-		unsigned long vlen, ssize_t ret)
-{
-	trace_mark_tp(fs, writev, fs_writev, probe_fs_writev,
-		"fd %lu vlen %lu", fd, vlen);
-}
-
-void probe_fs_select(void *_data, int fd, struct timespec *end_time)
-{
-	struct timespec tmptime;
-
-	if (end_time) {
-		tmptime = *end_time;
-	} else {
-		tmptime.tv_sec = -1L;
-		tmptime.tv_nsec = -1L;
-	}
-
-	trace_mark_tp(fs, select, fs_select, probe_fs_select,
-		"fd %d end_time_sec %ld end_time_nsec %ld", fd,
-			tmptime.tv_sec, tmptime.tv_nsec);
-}
-
-void probe_fs_poll(void *_data, int fd)
-{
-	trace_mark_tp(fs, pollfd, fs_poll, probe_fs_poll,
-		"fd %d", fd);
-}
-
-MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Mathieu Desnoyers");
-MODULE_DESCRIPTION("FS Tracepoint Probes");
diff --git a/drivers/staging/lttng/probes/ipc-trace.c b/drivers/staging/lttng/probes/ipc-trace.c
deleted file mode 100644
index 3a09525..0000000
--- a/drivers/staging/lttng/probes/ipc-trace.c
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * ltt/probes/ipc-trace.c
- *
- * IPC tracepoint probes.
- *
- * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
- * Dual LGPL v2.1/GPL v2 license.
- */
-
-#include <linux/module.h>
-#include <trace/ipc.h>
-
-void probe_ipc_msg_create(void *data, long id, int flags)
-{
-	trace_mark_tp(ipc, msg_create, ipc_msg_create, probe_ipc_msg_create,
-		"id %ld flags %d", id, flags);
-}
-
-void probe_ipc_sem_create(void *data, long id, int flags)
-{
-	trace_mark_tp(ipc, sem_create, ipc_sem_create, probe_ipc_sem_create,
-		"id %ld flags %d", id, flags);
-}
-
-void probe_ipc_shm_create(void *data, long id, int flags)
-{
-	trace_mark_tp(ipc, shm_create, ipc_shm_create, probe_ipc_shm_create,
-		"id %ld flags %d", id, flags);
-}
-
-void probe_ipc_call(void *data, unsigned int call, unsigned int first)
-{
-	trace_mark_tp(ipc, call, ipc_call, probe_ipc_call,
-		"call %u first %d", call, first);
-}
-
-MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Mathieu Desnoyers");
-MODULE_DESCRIPTION("IPC Tracepoint Probes");
diff --git a/drivers/staging/lttng/probes/jbd2-trace.c b/drivers/staging/lttng/probes/jbd2-trace.c
deleted file mode 100644
index 3da32cd..0000000
--- a/drivers/staging/lttng/probes/jbd2-trace.c
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
- * ltt/probes/jbd2-trace.c
- *
- * JBD2 tracepoint probes.
- *
- * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
- * Dual LGPL v2.1/GPL v2 license.
- */
-
-#include <linux/module.h>
-#include <linux/debugfs.h>
-#include <linux/mutex.h>
-#include <linux/rcupdate.h>
-#include <trace/events/jbd2.h>
-
-#include "../ltt-tracer.h"
-
-static struct dentry *jbd2_filter_dentry, *jbd2_filter_dev_dentry;
-static DEFINE_MUTEX(jbd2_filter_mutex);
-/* Make sure we don't race between module exit and file write */
-static int module_exits;
-
-struct rcu_dev_filter {
-	struct rcu_head rcu;
-	char devname[NAME_MAX];
-};
-
-static struct rcu_dev_filter *dev_filter;
-
-/*
- * Probes are executed in rcu_sched read-side critical section.
- */
-static int do_filter(const char *dev)
-{
-	struct rcu_dev_filter *ldev_filter = rcu_dereference(dev_filter);
-
-	if (unlikely(ldev_filter))
-		if (unlikely(strcmp(ldev_filter->devname, dev)))
-			return 0;
-	return 1;
-}
-
-void probe_jbd2_checkpoint(void *data, journal_t *journal, int result)
-{
-	if (unlikely(!do_filter(journal->j_devname)))
-		return;
-	trace_mark_tp(jbd2, checkpoint, jbd2_checkpoint,
-		probe_jbd2_checkpoint, "dev %s need_checkpoint %d",
-		journal->j_devname, result);
-}
-
-void probe_jbd2_start_commit(void *data, journal_t *journal,
-			     transaction_t *commit_transaction)
-{
-	if (unlikely(!do_filter(journal->j_devname)))
-		return;
-	trace_mark_tp(jbd2, start_commit, jbd2_start_commit,
-		probe_jbd2_start_commit, "dev %s transaction %d",
-		journal->j_devname, commit_transaction->t_tid);
-}
-
-void probe_jbd2_end_commit(void *data, journal_t *journal,
-			   transaction_t *commit_transaction)
-{
-	if (unlikely(!do_filter(journal->j_devname)))
-		return;
-	trace_mark_tp(jbd2, end_commit, jbd2_end_commit,
-		probe_jbd2_end_commit, "dev %s transaction %d head %d",
-		journal->j_devname, commit_transaction->t_tid,
-		journal->j_tail_sequence);
-}
-
-static void free_dev_filter(struct rcu_head *head)
-{
-	kfree(container_of(head, struct rcu_dev_filter, rcu));
-}
-
-static ssize_t filter_op_write(struct file *file,
-	const char __user *user_buf, size_t count, loff_t *ppos)
-{
-	int err = 0;
-	char buf[NAME_MAX];
-	int buf_size;
-	char name[NAME_MAX];
-	struct rcu_dev_filter *new, *old;
-
-	mutex_lock(&jbd2_filter_mutex);
-	if (module_exits) {
-		err = -EPERM;
-		goto error;
-	}
-	buf_size = min(count, sizeof(buf) - 1);
-	err = copy_from_user(buf, user_buf, buf_size);
-	if (err)
-		goto error;
-	buf[buf_size] = 0;
-
-	if (sscanf(buf, "%s", name) != 1) {
-		err = -EPERM;
-		goto error;
-	}
-
-	old = dev_filter;
-
-	/* Empty string or * means all active */
-	if (name[0] == '\0' || (name[0] == '*' && name[1] == '\0')) {
-		new = NULL;
-	} else {
-		new = kmalloc(sizeof(*new), GFP_KERNEL);
-		strcpy(new->devname, name);
-	}
-
-	rcu_assign_pointer(dev_filter, new);
-	if (old)
-		call_rcu_sched(&old->rcu, free_dev_filter);
-
-	mutex_unlock(&jbd2_filter_mutex);
-	return count;
-
-error:
-	mutex_unlock(&jbd2_filter_mutex);
-	return err;
-}
-
-static ssize_t filter_op_read(struct file *filp, char __user *buffer,
-	size_t count, loff_t *ppos)
-{
-	ssize_t bcount;
-	const char *devname;
-
-	mutex_lock(&jbd2_filter_mutex);
-	if (!dev_filter)
-		devname = "*";
-	else
-		devname = dev_filter->devname;
-	bcount = simple_read_from_buffer(buffer, count, ppos,
-			devname, strlen(devname));
-	mutex_unlock(&jbd2_filter_mutex);
-	return bcount;
-}
-
-static struct file_operations jbd2_file_operations = {
-	.write = filter_op_write,
-	.read = filter_op_read,
-};
-
-static void release_filter_dev(void)
-{
-	struct rcu_dev_filter *old;
-
-	mutex_lock(&jbd2_filter_mutex);
-	module_exits = 1;
-	old = dev_filter;
-	rcu_assign_pointer(dev_filter, NULL);
-	if (old)
-		call_rcu_sched(&old->rcu, free_dev_filter);
-	mutex_unlock(&jbd2_filter_mutex);
-}
-
-static int __init filter_init(void)
-{
-	struct dentry *filter_root_dentry;
-	int err = 0;
-
-	filter_root_dentry = get_filter_root();
-	if (!filter_root_dentry) {
-		err = -ENOENT;
-		goto end;
-	}
-
-	jbd2_filter_dentry = debugfs_create_dir("jbd2", filter_root_dentry);
-
-	if (IS_ERR(jbd2_filter_dentry) || !jbd2_filter_dentry) {
-		printk(KERN_ERR "Failed to create jbd2 filter file\n");
-		err = -ENOMEM;
-		goto end;
-	}
-
-	jbd2_filter_dev_dentry = debugfs_create_file("dev", S_IWUSR,
-			jbd2_filter_dentry, NULL, &jbd2_file_operations);
-	if (IS_ERR(jbd2_filter_dentry) || !jbd2_filter_dentry) {
-		printk(KERN_ERR "Failed to create jbd2 filter file\n");
-		err = -ENOMEM;
-		goto release_filter_dentry;
-	}
-
-	goto end;
-
-release_filter_dentry:
-	debugfs_remove(jbd2_filter_dentry);
-	release_filter_dev();
-end:
-	return err;
-}
-
-static void __exit filter_exit(void)
-{
-	debugfs_remove(jbd2_filter_dev_dentry);
-	debugfs_remove(jbd2_filter_dentry);
-	release_filter_dev();
-}
-
-module_init(filter_init);
-module_exit(filter_exit);
-
-MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Mathieu Desnoyers");
-MODULE_DESCRIPTION("JBD2 Tracepoint Probes");
diff --git a/drivers/staging/lttng/probes/kernel-trace.c b/drivers/staging/lttng/probes/kernel-trace.c
deleted file mode 100644
index cabe60e..0000000
--- a/drivers/staging/lttng/probes/kernel-trace.c
+++ /dev/null
@@ -1,581 +0,0 @@
-/*
- * ltt/probes/kernel-trace.c
- *
- * kernel tracepoint probes.
- *
- * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
- * Dual LGPL v2.1/GPL v2 license.
- */
-
-#include <linux/module.h>
-#include <linux/irq.h>
-#include <trace/events/signal.h>
-#include <trace/irq.h>
-#include <trace/sched.h>
-#include <trace/timer.h>
-#include <trace/kernel.h>
-#include <trace/fault.h>
-#include <trace/events/sched.h>
-
-#include "../ltt-tracer.h"
-#include "../ltt-type-serializer.h"
-
-/*
- * This should probably be added to s390.
- */
-#ifdef CONFIG_S390
-static struct pt_regs *get_irq_regs(void)
-{
-	return task_pt_regs(current);
-}
-#endif
-
-/*
- * FIXME :
- * currently, the specialized tracepoint probes cannot call into other marker
- * probes, such as ftrace enable/disable. Given we want them to be as fast as
- * possible, it might not be so bad to lose this flexibility. But that means
- * such probes would have to connect to tracepoints on their own.
- */
-
-/* kernel_irq_entry specialized tracepoint probe */
-
-void probe_irq_entry(void *_data, unsigned int id, struct pt_regs *regs,
-	struct irqaction *action);
-
-DEFINE_MARKER_TP(kernel, irq_entry, irq_entry, probe_irq_entry,
-	"ip %lu handler %p irq_id #2u%u kernel_mode #1u%u");
-
-notrace void probe_irq_entry(void *_data, unsigned int id, struct pt_regs *regs,
-	struct irqaction *action)
-{
-	struct marker *marker;
-	struct serialize_long_long_short_char data;
-
-	if (unlikely(!regs))
-		regs = get_irq_regs();
-	if (likely(regs)) {
-		data.f1 = instruction_pointer(regs);
-		data.f4 = !user_mode(regs);
-	} else {
-		data.f1 = 0UL;
-		data.f4 = 1;
-	}
-	data.f2 = (unsigned long) (action ? action->handler : NULL);
-	data.f3 = id;
-
-	marker = &GET_MARKER(kernel, irq_entry);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(long));
-}
-
-void probe_irq_next_handler(void *_data, unsigned int id, struct irqaction *action,
-		irqreturn_t prev_ret);
-
-DEFINE_MARKER_TP(kernel, irq_next_handler, irq_next_handler,
-	probe_irq_next_handler,
-	"handler %p prev_ret #1u%u");
-
-notrace void probe_irq_next_handler(void *_data, unsigned int id, struct irqaction *action,
-		irqreturn_t prev_ret)
-{
-	struct marker *marker;
-	struct serialize_long_char data;
-
-	data.f1 = (unsigned long) (action ? action->handler : NULL);
-	data.f2 = prev_ret;
-
-	marker = &GET_MARKER(kernel, irq_next_handler);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(long));
-}
-
-/* kernel_irq_exit specialized tracepoint probe */
-
-void probe_irq_exit(void *_data, irqreturn_t retval);
-
-DEFINE_MARKER_TP(kernel, irq_exit, irq_exit, probe_irq_exit,
-	"handled #1u%u");
-
-notrace void probe_irq_exit(void *_data, irqreturn_t retval)
-{
-	struct marker *marker;
-	unsigned char data;
-
-	data = IRQ_RETVAL(retval);
-
-	marker = &GET_MARKER(kernel, irq_exit);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, sizeof(data), sizeof(data));
-}
-
-/* kernel_softirq_entry specialized tracepoint probe */
-
-void probe_softirq_entry(void *_data, struct softirq_action *h,
-	struct softirq_action *softirq_vec);
-
-DEFINE_MARKER_TP(kernel, softirq_entry, softirq_entry,
-	probe_softirq_entry, "softirq_id #1u%lu");
-
-notrace void probe_softirq_entry(void *_data, struct softirq_action *h,
-	struct softirq_action *softirq_vec)
-{
-	struct marker *marker;
-	unsigned char data;
-
-	data = ((unsigned long)h - (unsigned long)softirq_vec) / sizeof(*h);
-
-	marker = &GET_MARKER(kernel, softirq_entry);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, sizeof(data), sizeof(data));
-}
-
-/* kernel_softirq_exit specialized tracepoint probe */
-
-void probe_softirq_exit(void *_data, struct softirq_action *h,
-	struct softirq_action *softirq_vec);
-
-DEFINE_MARKER_TP(kernel, softirq_exit, softirq_exit,
-	probe_softirq_exit, "softirq_id #1u%lu");
-
-notrace void probe_softirq_exit(void *_data, struct softirq_action *h,
-	struct softirq_action *softirq_vec)
-{
-	struct marker *marker;
-	unsigned char data;
-
-	data = ((unsigned long)h - (unsigned long)softirq_vec) / sizeof(*h);
-
-	marker = &GET_MARKER(kernel, softirq_exit);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, sizeof(data), sizeof(data));
-}
-
-/* kernel_softirq_raise specialized tracepoint probe */
-
-void probe_softirq_raise(void *_data, unsigned int nr);
-
-DEFINE_MARKER_TP(kernel, softirq_raise, softirq_raise,
-	probe_softirq_raise, "softirq_id #1u%u");
-
-notrace void probe_softirq_raise(void *_data, unsigned int nr)
-{
-	struct marker *marker;
-	unsigned char data;
-
-	data = nr;
-
-	marker = &GET_MARKER(kernel, softirq_raise);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, sizeof(data), sizeof(data));
-}
-
-/* Standard probes */
-void probe_irq_tasklet_low_entry(void *_data, struct tasklet_struct *t)
-{
-	trace_mark_tp(kernel, tasklet_low_entry, irq_tasklet_low_entry,
-		probe_irq_tasklet_low_entry, "func %p data %lu",
-		t->func, t->data);
-}
-
-void probe_irq_tasklet_low_exit(void *_data, struct tasklet_struct *t)
-{
-	trace_mark_tp(kernel, tasklet_low_exit, irq_tasklet_low_exit,
-		probe_irq_tasklet_low_exit, "func %p data %lu",
-		t->func, t->data);
-}
-
-void probe_irq_tasklet_high_entry(void *_data, struct tasklet_struct *t)
-{
-	trace_mark_tp(kernel, tasklet_high_entry, irq_tasklet_high_entry,
-		probe_irq_tasklet_high_entry, "func %p data %lu",
-		t->func, t->data);
-}
-
-void probe_irq_tasklet_high_exit(void *_data, struct tasklet_struct *t)
-{
-	trace_mark_tp(kernel, tasklet_high_exit, irq_tasklet_high_exit,
-		probe_irq_tasklet_high_exit, "func %p data %lu",
-		t->func, t->data);
-}
-
-void probe_sched_kthread_stop(void *_data, struct task_struct *t)
-{
-	trace_mark_tp(kernel, kthread_stop, sched_kthread_stop,
-		probe_sched_kthread_stop, "pid %d", t->pid);
-}
-
-void probe_sched_kthread_stop_ret(void *_data, int ret)
-{
-	trace_mark_tp(kernel, kthread_stop_ret, sched_kthread_stop_ret,
-		probe_sched_kthread_stop_ret, "ret %d", ret);
-}
-
-void probe_sched_wait_task(void *_data, struct task_struct *p)
-{
-	trace_mark_tp(kernel, sched_wait_task, sched_wait_task,
-		probe_sched_wait_task, "pid %d state #2d%ld",
-		p->pid, p->state);
-}
-
-/* kernel_sched_try_wakeup specialized tracepoint probe */
-
-void probe_sched_wakeup(void *_data, struct task_struct *p, int success);
-
-DEFINE_MARKER_TP(kernel, sched_try_wakeup, sched_wakeup,
-	probe_sched_wakeup, "pid %d cpu_id %u state #2d%ld");
-
-notrace void probe_sched_wakeup(void *_data, struct task_struct *p, int success)
-{
-	struct marker *marker;
-	struct serialize_int_int_short data;
-
-	data.f1 = p->pid;
-	data.f2 = task_cpu(p);
-	data.f3 = p->state;
-
-	marker = &GET_MARKER(kernel, sched_try_wakeup);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(int));
-}
-
-void probe_sched_wakeup_new(void *_data, struct task_struct *p, int success)
-{
-	trace_mark_tp(kernel, sched_wakeup_new_task, sched_wakeup_new,
-		probe_sched_wakeup_new, "pid %d state #2d%ld cpu_id %u",
-		p->pid, p->state, task_cpu(p));
-}
-
-/* kernel_sched_schedule specialized tracepoint probe */
-
-void probe_sched_switch(void *_data, struct task_struct *prev,
-		struct task_struct *next);
-
-DEFINE_MARKER_TP(kernel, sched_schedule, sched_switch, probe_sched_switch,
-	"prev_pid %d next_pid %d prev_state #2d%ld");
-
-notrace void probe_sched_switch(void *_data, struct task_struct *prev,
-		struct task_struct *next)
-{
-	struct marker *marker;
-	struct serialize_int_int_short data;
-
-	data.f1 = prev->pid;
-	data.f2 = next->pid;
-	data.f3 = prev->state;
-
-	marker = &GET_MARKER(kernel, sched_schedule);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(int));
-}
-
-void probe_sched_migrate_task(void *_data, struct task_struct *p, int dest_cpu)
-{
-	trace_mark_tp(kernel, sched_migrate_task, sched_migrate_task,
-		probe_sched_migrate_task, "pid %d state #2d%ld dest_cpu %d",
-		p->pid, p->state, dest_cpu);
-}
-
-void probe_sched_signal_send(void *_data, int sig, struct siginfo *info, struct task_struct *t)
-{
-	trace_mark_tp(kernel, send_signal, signal_generate,
-		probe_sched_signal_send, "pid %d signal %d", t->pid, sig);
-}
-
-void probe_sched_process_free(void *_data, struct task_struct *p)
-{
-	trace_mark_tp(kernel, process_free, sched_process_free,
-		probe_sched_process_free, "pid %d", p->pid);
-}
-
-void probe_sched_process_exit(void *_data, struct task_struct *p)
-{
-	trace_mark_tp(kernel, process_exit, sched_process_exit,
-		probe_sched_process_exit, "pid %d", p->pid);
-}
-
-void probe_sched_process_wait(void *_data, struct pid *pid)
-{
-	trace_mark_tp(kernel, process_wait, sched_process_wait,
-		probe_sched_process_wait, "pid %d", pid_nr(pid));
-}
-
-void probe_sched_process_fork(void *_data, struct task_struct *parent,
-		struct task_struct *child)
-{
-	trace_mark_tp(kernel, process_fork, sched_process_fork,
-		probe_sched_process_fork,
-		"parent_pid %d child_pid %d child_tgid %d",
-		parent->pid, child->pid, child->tgid);
-}
-
-void probe_sched_kthread_create(void *_data, void *fn, int pid)
-{
-	trace_mark_tp(kernel, kthread_create, sched_kthread_create,
-		probe_sched_kthread_create,
-		"fn %p pid %d", fn, pid);
-}
-
-void probe_timer_itimer_expired(void *_data, struct signal_struct *sig)
-{
-	trace_mark_tp(kernel, timer_itimer_expired, timer_itimer_expired,
-		probe_timer_itimer_expired, "pid %d",
-		pid_nr(sig->leader_pid));
-}
-
-void probe_timer_itimer_set(void *_data, int which, struct itimerval *value)
-{
-	trace_mark_tp(kernel, timer_itimer_set,
-		timer_itimer_set, probe_timer_itimer_set,
-		"which %d interval_sec %ld interval_usec %ld "
-		"value_sec %ld value_usec %ld",
-		which,
-		value->it_interval.tv_sec,
-		value->it_interval.tv_usec,
-		value->it_value.tv_sec,
-		value->it_value.tv_usec);
-}
-
-/* kernel_timer_set specialized tracepoint probe */
-
-void probe_timer_set(void *_data, struct timer_list *timer);
-
-DEFINE_MARKER_TP(kernel, timer_set, timer_set, probe_timer_set,
-	"expires %lu function %p data %lu");
-
-notrace void probe_timer_set(void *_data, struct timer_list *timer)
-{
-	struct marker *marker;
-	struct serialize_long_long_long data;
-
-	data.f1 = timer->expires;
-	data.f2 = (unsigned long)timer->function;
-	data.f3 = timer->data;
-
-	marker = &GET_MARKER(kernel, timer_set);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(long));
-}
-
-void probe_timer_update_time(void *_data, struct timespec *_xtime,
-		struct timespec *_wall_to_monotonic)
-{
-	trace_mark_tp(kernel, timer_update_time, timer_update_time,
-		probe_timer_update_time,
-		"jiffies #8u%llu xtime_sec %ld xtime_nsec %ld "
-		"walltomonotonic_sec %ld walltomonotonic_nsec %ld",
-		(unsigned long long)jiffies_64, _xtime->tv_sec, _xtime->tv_nsec,
-		_wall_to_monotonic->tv_sec, _wall_to_monotonic->tv_nsec);
-}
-
-void probe_timer_timeout(void *_data, struct task_struct *p)
-{
-	trace_mark_tp(kernel, timer_timeout, timer_timeout,
-		probe_timer_timeout, "pid %d", p->pid);
-}
-
-void probe_kernel_printk(void *_data, unsigned long retaddr)
-{
-	trace_mark_tp(kernel, printk, kernel_printk,
-		probe_kernel_printk, "ip 0x%lX", retaddr);
-}
-
-void probe_kernel_vprintk(void *_data, unsigned long retaddr, char *buf, int len)
-{
-	if (len > 0) {
-		unsigned int loglevel;
-		int mark_len;
-		char *mark_buf;
-		char saved_char;
-
-		if (buf[0] == '<' && buf[1] >= '0' &&
-		   buf[1] <= '7' && buf[2] == '>') {
-			loglevel = buf[1] - '0';
-			mark_buf = &buf[3];
-			mark_len = len - 3;
-		} else {
-			loglevel = default_message_loglevel;
-			mark_buf = buf;
-			mark_len = len;
-		}
-		if (mark_buf[mark_len - 1] == '\n')
-			mark_len--;
-		saved_char = mark_buf[mark_len];
-		mark_buf[mark_len] = '\0';
-		trace_mark_tp(kernel, vprintk, kernel_vprintk,
-			probe_kernel_vprintk,
-			"loglevel #1u%u string %s ip 0x%lX",
-			loglevel, mark_buf, retaddr);
-		mark_buf[mark_len] = saved_char;
-	}
-}
-
-#ifdef CONFIG_MODULES
-void probe_kernel_module_free(void *_data, struct module *mod)
-{
-	trace_mark_tp(kernel, module_free, kernel_module_free,
-		probe_kernel_module_free, "name %s", mod->name);
-}
-
-void probe_kernel_module_load(void *_data, struct module *mod)
-{
-	trace_mark_tp(kernel, module_load, kernel_module_load,
-		probe_kernel_module_load, "name %s", mod->name);
-}
-#endif
-
-void probe_kernel_panic(void *_data, const char *fmt, va_list args)
-{
-	char info[64];
-	vsnprintf(info, sizeof(info), fmt, args);
-	trace_mark_tp(kernel, panic, kernel_panic, probe_kernel_panic,
-		"info %s", info);
-}
-
-void probe_kernel_kernel_kexec(void *_data, struct kimage *image)
-{
-	trace_mark_tp(kernel, kernel_kexec, kernel_kernel_kexec,
-		probe_kernel_kernel_kexec, "image %p", image);
-}
-
-void probe_kernel_crash_kexec(void *_data, struct kimage *image, struct pt_regs *regs)
-{
-	trace_mark_tp(kernel, crash_kexec, kernel_crash_kexec,
-		probe_kernel_crash_kexec, "image %p ip %p", image,
-		regs ? (void *)instruction_pointer(regs) : NULL);
-}
-
-/* kernel_page_fault_entry specialized tracepoint probe */
-
-void probe_kernel_page_fault_entry(void *_data, struct pt_regs *regs, int trapnr,
-	struct mm_struct *mm, struct vm_area_struct *vma,
-	unsigned long address, int write_access);
-
-DEFINE_MARKER_TP(kernel, page_fault_entry, page_fault_entry,
-	probe_kernel_page_fault_entry,
-	"ip #p%lu address #p%lu trap_id #2u%u write_access #1u%u");
-
-notrace void probe_kernel_page_fault_entry(void *_data, struct pt_regs *regs, int trapnr,
-	struct mm_struct *mm, struct vm_area_struct *vma,
-	unsigned long address, int write_access)
-{
-	struct marker *marker;
-	struct serialize_long_long_short_char data;
-
-	if (likely(regs))
-		data.f1 = instruction_pointer(regs);
-	else
-		data.f1 = 0UL;
-	data.f2 = address;
-	data.f3 = (unsigned short)trapnr;
-	data.f4 = (unsigned char)!!write_access;
-
-	marker = &GET_MARKER(kernel, page_fault_entry);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(long));
-}
-
-/* kernel_page_fault_exit specialized tracepoint probe */
-
-void probe_kernel_page_fault_exit(void *_data, int res);
-
-DEFINE_MARKER_TP(kernel, page_fault_exit, page_fault_exit,
-	probe_kernel_page_fault_exit,
-	"res %d");
-
-notrace void probe_kernel_page_fault_exit(void *_data, int res)
-{
-	struct marker *marker;
-
-	marker = &GET_MARKER(kernel, page_fault_exit);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&res, sizeof(res), sizeof(res));
-}
-
-/* kernel_page_fault_nosem_entry specialized tracepoint probe */
-
-void probe_kernel_page_fault_nosem_entry(void *_data, struct pt_regs *regs,
-	int trapnr, unsigned long address);
-
-DEFINE_MARKER_TP(kernel, page_fault_nosem_entry, page_fault_nosem_entry,
-	probe_kernel_page_fault_nosem_entry,
-	"ip #p%lu address #p%lu trap_id #2u%u");
-
-notrace void probe_kernel_page_fault_nosem_entry(void *_data, struct pt_regs *regs,
-	int trapnr, unsigned long address)
-{
-	struct marker *marker;
-	struct serialize_long_long_short data;
-
-	if (likely(regs))
-		data.f1 = instruction_pointer(regs);
-	else
-		data.f1 = 0UL;
-	data.f2 = address;
-	data.f3 = (unsigned short)trapnr;
-
-	marker = &GET_MARKER(kernel, page_fault_nosem_entry);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(long));
-}
-
-/* kernel_page_fault_nosem_exit specialized tracepoint probe */
-
-void probe_kernel_page_fault_nosem_exit(void *_data, int res);
-
-DEFINE_MARKER_TP(kernel, page_fault_nosem_exit, page_fault_nosem_exit,
-	probe_kernel_page_fault_nosem_exit,
-	MARK_NOARGS);
-
-notrace void probe_kernel_page_fault_nosem_exit(void *_data, int res)
-{
-	struct marker *marker;
-
-	marker = &GET_MARKER(kernel, page_fault_nosem_exit);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		NULL, 0, 0);
-}
-
-/* kernel_page_fault_get_user_entry specialized tracepoint probe */
-
-void probe_kernel_page_fault_get_user_entry(void *_data, struct mm_struct *mm,
-	struct vm_area_struct *vma, unsigned long address, int write_access);
-
-DEFINE_MARKER_TP(kernel, page_fault_get_user_entry, page_fault_get_user_entry,
-	probe_kernel_page_fault_get_user_entry,
-	"address #p%lu write_access #1u%u");
-
-notrace void probe_kernel_page_fault_get_user_entry(void *_data, struct mm_struct *mm,
-	struct vm_area_struct *vma, unsigned long address, int write_access)
-{
-	struct marker *marker;
-	struct serialize_long_char data;
-
-	data.f1 = address;
-	data.f2 = (unsigned char)!!write_access;
-
-	marker = &GET_MARKER(kernel, page_fault_get_user_entry);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(long));
-}
-
-/* kernel_page_fault_get_user_exit specialized tracepoint probe */
-
-void probe_kernel_page_fault_get_user_exit(void *_data, int res);
-
-DEFINE_MARKER_TP(kernel, page_fault_get_user_exit, page_fault_get_user_exit,
-	probe_kernel_page_fault_get_user_exit,
-	"res %d");
-
-notrace void probe_kernel_page_fault_get_user_exit(void *_data, int res)
-{
-	struct marker *marker;
-
-	marker = &GET_MARKER(kernel, page_fault_get_user_exit);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&res, sizeof(res), sizeof(res));
-}
-
-MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Mathieu Desnoyers");
-MODULE_DESCRIPTION("kernel Tracepoint Probes");
diff --git a/drivers/staging/lttng/probes/lockdep-trace.c b/drivers/staging/lttng/probes/lockdep-trace.c
deleted file mode 100644
index a9a7734..0000000
--- a/drivers/staging/lttng/probes/lockdep-trace.c
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * ltt/probes/lockdep-trace.c
- *
- * lockdep tracepoint probes.
- *
- * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
- * Dual LGPL v2.1/GPL v2 license.
- */
-
-#include <linux/module.h>
-#include <linux/lockdep.h>
-#include <trace/lockdep.h>
-
-void probe_lockdep_hardirqs_on(void *data, unsigned long retaddr)
-{
-	trace_mark_tp(lockdep, hardirqs_on, lockdep_hardirqs_on,
-		probe_lockdep_hardirqs_on, "retaddr 0x%lX", retaddr);
-}
-
-void probe_lockdep_hardirqs_off(void *data, unsigned long retaddr)
-{
-	trace_mark_tp(lockdep, hardirqs_off, lockdep_hardirqs_off,
-		probe_lockdep_hardirqs_off, "retaddr 0x%lX", retaddr);
-}
-
-void probe_lockdep_softirqs_on(void *data, unsigned long retaddr)
-{
-	trace_mark_tp(lockdep, softirqs_on, lockdep_softirqs_on,
-		probe_lockdep_softirqs_on, "retaddr 0x%lX", retaddr);
-}
-
-void probe_lockdep_softirqs_off(void *data, unsigned long retaddr)
-{
-	trace_mark_tp(lockdep, softirqs_off, lockdep_softirqs_off,
-		probe_lockdep_softirqs_off, "retaddr 0x%lX", retaddr);
-}
-
-void probe_lockdep_lock_acquire(void *data, unsigned long retaddr,
-		unsigned int subclass, struct lockdep_map *lock, int trylock,
-		int read, int hardirqs_off)
-{
-	trace_mark_tp(lockdep, lock_acquire, lockdep_lock_acquire,
-		probe_lockdep_lock_acquire,
-		"retaddr 0x%lX subclass %u lock %p trylock %d read %d "
-		"hardirqs_off %d",
-		retaddr, subclass, lock, trylock, read, hardirqs_off);
-}
-
-void probe_lockdep_lock_release(void *data, unsigned long retaddr,
-		struct lockdep_map *lock, int nested)
-{
-	trace_mark_tp(lockdep, lock_release, lockdep_lock_release,
-		probe_lockdep_lock_release,
-		"retaddr 0x%lX lock %p nested %d",
-		retaddr, lock, nested);
-}
-
-MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Mathieu Desnoyers");
-MODULE_DESCRIPTION("lockdep Tracepoint Probes");
diff --git a/drivers/staging/lttng/probes/mm-trace.c b/drivers/staging/lttng/probes/mm-trace.c
deleted file mode 100644
index 935e366..0000000
--- a/drivers/staging/lttng/probes/mm-trace.c
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * ltt/probes/mm-trace.c
- *
- * MM tracepoint probes.
- *
- * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
- * Dual LGPL v2.1/GPL v2 license.
- */
-
-#include <linux/module.h>
-#include <linux/mm.h>
-#include <linux/swap.h>
-
-#include <asm/pgtable.h>
-#include <asm/tlbflush.h>
-#include <linux/swapops.h>
-#include <trace/page_alloc.h>
-#include <trace/filemap.h>
-#include <trace/swap.h>
-#include <trace/hugetlb.h>
-
-#include "../ltt-type-serializer.h"
-
-void probe_wait_on_page_start(void *_data, struct page *page, int bit_nr)
-{
-	trace_mark_tp(mm, wait_on_page_start, wait_on_page_start,
-		probe_wait_on_page_start, "pfn %lu bit_nr %d",
-		page_to_pfn(page), bit_nr);
-}
-
-void probe_wait_on_page_end(void *_data, struct page *page, int bit_nr)
-{
-	trace_mark_tp(mm, wait_on_page_end, wait_on_page_end,
-		probe_wait_on_page_end, "pfn %lu bit_nr %d",
-		page_to_pfn(page), bit_nr);
-}
-
-void probe_hugetlb_page_free(void *_data, struct page *page)
-{
-	trace_mark_tp(mm, huge_page_free, hugetlb_page_free,
-		probe_hugetlb_page_free, "pfn %lu", page_to_pfn(page));
-}
-
-void probe_hugetlb_page_alloc(void *_data, struct page *page)
-{
-	if (page)
-		trace_mark_tp(mm, huge_page_alloc, hugetlb_page_alloc,
-			probe_hugetlb_page_alloc, "pfn %lu", page_to_pfn(page));
-}
-
-/* mm_page_free specialized tracepoint probe */
-
-void probe_page_free(void *_data, struct page *page, unsigned int order);
-
-DEFINE_MARKER_TP(mm, page_free, page_free, probe_page_free,
-	"pfn %lu order %u");
-
-notrace void probe_page_free(void *_data, struct page *page, unsigned int order)
-{
-	struct marker *marker;
-	struct serialize_long_int data;
-
-	data.f1 = page_to_pfn(page);
-	data.f2 = order;
-
-	marker = &GET_MARKER(mm, page_free);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(long));
-}
-
-/* mm_page_alloc specialized tracepoint probe */
-
-void probe_page_alloc(void *_data, struct page *page, unsigned int order);
-
-DEFINE_MARKER_TP(mm, page_alloc, page_alloc, probe_page_alloc,
-	"pfn %lu order %u");
-
-notrace void probe_page_alloc(void *_data, struct page *page, unsigned int order)
-{
-	struct marker *marker;
-	struct serialize_long_int data;
-
-	if (unlikely(!page))
-		return;
-
-	data.f1 = page_to_pfn(page);
-	data.f2 = order;
-
-	marker = &GET_MARKER(mm, page_alloc);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(long));
-}
-
-#ifdef CONFIG_SWAP
-void probe_swap_in(void *_data, struct page *page, swp_entry_t entry)
-{
-	trace_mark_tp(mm, swap_in, swap_in, probe_swap_in,
-		"pfn %lu filp %p offset %lu",
-		page_to_pfn(page),
-		get_swap_info_struct(swp_type(entry))->swap_file,
-		swp_offset(entry));
-}
-
-void probe_swap_out(void *_data, struct page *page)
-{
-	trace_mark_tp(mm, swap_out, swap_out, probe_swap_out,
-		"pfn %lu filp %p offset %lu",
-		page_to_pfn(page),
-		get_swap_info_struct(swp_type(
-			page_swp_entry(page)))->swap_file,
-		swp_offset(page_swp_entry(page)));
-}
-
-void probe_swap_file_close(void *_data, struct file *file)
-{
-	trace_mark_tp(mm, swap_file_close, swap_file_close,
-		probe_swap_file_close, "filp %p", file);
-}
-
-void probe_swap_file_open(void *_data, struct file *file, char *filename)
-{
-	trace_mark_tp(mm, swap_file_open, swap_file_open,
-		probe_swap_file_open, "filp %p filename %s",
-		file, filename);
-}
-#endif
-
-void probe_add_to_page_cache(void *_data, struct address_space *mapping, pgoff_t offset)
-{
-	trace_mark_tp(mm, add_to_page_cache, add_to_page_cache,
-		probe_add_to_page_cache,
-		"inode %lu sdev %u",
-		mapping->host->i_ino, mapping->host->i_sb->s_dev);
-}
-
-void probe_remove_from_page_cache(void *_data, struct address_space *mapping)
-{
-	trace_mark_tp(mm, remove_from_page_cache, remove_from_page_cache,
-		probe_remove_from_page_cache,
-		"inode %lu sdev %u",
-		mapping->host->i_ino, mapping->host->i_sb->s_dev);
-}
-
-MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Mathieu Desnoyers");
-MODULE_DESCRIPTION("MM Tracepoint Probes");
diff --git a/drivers/staging/lttng/probes/net-extended-trace.c b/drivers/staging/lttng/probes/net-extended-trace.c
deleted file mode 100644
index 15fc810..0000000
--- a/drivers/staging/lttng/probes/net-extended-trace.c
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * ltt/probes/net-extended-trace.c
- *
- * Net tracepoint extended probes.
- *
- * These probes record many header fields from TCP and UDP messages. Here are
- * the consequences of this:
- * 1) it allows analyzing network traffic to provide some pcap-like
- *    functionality within LTTng
- * 2) it allows offline synchronization of a group of concurrent traces
- *    recorded on different nodes
- * 3) it increases tracing overhead
- *
- * You can leave out these probes or not activate them if you are not
- * especially interested in the details of network traffic and do not wish to
- * synchronize distributed traces.
- *
- * Dual LGPL v2.1/GPL v2 license.
- */
-
-#include <linux/in_route.h>
-#include <linux/ip.h>
-#include <linux/module.h>
-#include <linux/tcp.h>
-#include <linux/udp.h>
-#include <net/route.h>
-#include <trace/net.h>
-
-#include "../ltt-type-serializer.h"
-
-void probe_net_dev_xmit_extended(void *_data, struct sk_buff *skb);
-
-DEFINE_MARKER_TP(net, dev_xmit_extended, net_dev_xmit,
-	probe_net_dev_xmit_extended, "skb 0x%lX network_protocol #n2u%hu "
-	"transport_protocol #1u%u saddr #n4u%lu daddr #n4u%lu "
-	"tot_len #n2u%hu ihl #1u%u source #n2u%hu dest #n2u%hu seq #n4u%lu "
-	"ack_seq #n4u%lu doff #1u%u ack #1u%u rst #1u%u syn #1u%u fin #1u%u");
-
-notrace void probe_net_dev_xmit_extended(void *_data, struct sk_buff *skb)
-{
-	struct marker *marker;
-	struct serialize_l214421224411111 data;
-	struct iphdr *iph = ip_hdr(skb);
-	struct tcphdr *th = tcp_hdr(skb);
-
-	data.f1 = (unsigned long)skb;
-	data.f2 = skb->protocol;
-
-	if (ntohs(skb->protocol) == ETH_P_IP) {
-		data.f3 = ip_hdr(skb)->protocol;
-		data.f4 = iph->saddr;
-		data.f5 = iph->daddr;
-		data.f6 = iph->tot_len;
-		data.f7 = iph->ihl;
-
-		if (data.f3 == IPPROTO_TCP) {
-			data.f8 = th->source;
-			data.f9 = th->dest;
-			data.f10 = th->seq;
-			data.f11 = th->ack_seq;
-			data.f12 = th->doff;
-			data.f13 = th->ack;
-			data.f14 = th->rst;
-			data.f15 = th->syn;
-			data.f16 = th->fin;
-		}
-	}
-
-	marker = &GET_MARKER(net, dev_xmit_extended);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(long));
-}
-
-void probe_tcpv4_rcv_extended(void *_data, struct sk_buff *skb);
-
-DEFINE_MARKER_TP(net, tcpv4_rcv_extended, net_tcpv4_rcv,
-	probe_tcpv4_rcv_extended, "skb 0x%lX saddr #n4u%lu daddr #n4u%lu "
-	"tot_len #n2u%hu ihl #1u%u source #n2u%hu dest #n2u%hu seq #n4u%lu "
-	"ack_seq #n4u%lu doff #1u%u ack #1u%u rst #1u%u syn #1u%u fin #1u%u");
-
-notrace void probe_tcpv4_rcv_extended(void *_data, struct sk_buff *skb)
-{
-	struct marker *marker;
-	struct serialize_l4421224411111 data;
-	struct iphdr *iph = ip_hdr(skb);
-	struct tcphdr *th = tcp_hdr(skb);
-
-	data.f1 = (unsigned long)skb;
-	data.f2 = iph->saddr;
-	data.f3 = iph->daddr;
-	data.f4 = iph->tot_len;
-	data.f5 = iph->ihl;
-	data.f6 = th->source;
-	data.f7 = th->dest;
-	data.f8 = th->seq;
-	data.f9 = th->ack_seq;
-	data.f10 = th->doff;
-	data.f11 = th->ack;
-	data.f12 = th->rst;
-	data.f13 = th->syn;
-	data.f14 = th->fin;
-
-	marker = &GET_MARKER(net, tcpv4_rcv_extended);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(long));
-}
-
-void probe_udpv4_rcv_extended(void *_data, struct sk_buff *skb);
-
-DEFINE_MARKER_TP(net, udpv4_rcv_extended, net_udpv4_rcv,
-	probe_udpv4_rcv_extended, "skb 0x%lX saddr #n4u%lu daddr #n4u%lu "
-	"unicast #1u%u ulen #n2u%hu source #n2u%hu dest #n2u%hu "
-	"data_start #8u%lx");
-
-notrace void probe_udpv4_rcv_extended(void *_data, struct sk_buff *skb)
-{
-	struct marker *marker;
-	struct serialize_l4412228 data;
-	struct iphdr *iph = ip_hdr(skb);
-	struct rtable *rt = skb_rtable(skb);
-	struct udphdr *uh = udp_hdr(skb);
-
-	data.f1 = (unsigned long)skb;
-	data.f2 = iph->saddr;
-	data.f3 = iph->daddr;
-	data.f4 = rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST) ? 0 : 1;
-	data.f5 = uh->len;
-	data.f6 = uh->source;
-	data.f7 = uh->dest;
-	/* UDP header has not been pulled from skb->data, read the first 8
-	 * bytes of UDP data if they are not in a fragment*/
-	data.f8 = 0;
-	if (skb_headlen(skb) >= sizeof(struct udphdr) + 8)
-		data.f8 = *(unsigned long long *)(skb->data + sizeof(*uh));
-	else if (skb_headlen(skb) >= sizeof(struct udphdr))
-		memcpy(&data.f8, skb->data + sizeof(struct udphdr),
-			skb_headlen(skb) - sizeof(struct udphdr));
-
-	marker = &GET_MARKER(net, udpv4_rcv_extended);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(unsigned long long));
-}
-
-MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Benjamin Poirier");
-MODULE_DESCRIPTION("Net Tracepoint Extended Probes");
diff --git a/drivers/staging/lttng/probes/net-trace.c b/drivers/staging/lttng/probes/net-trace.c
deleted file mode 100644
index 3124125..0000000
--- a/drivers/staging/lttng/probes/net-trace.c
+++ /dev/null
@@ -1,406 +0,0 @@
-/*
- * ltt/probes/net-trace.c
- *
- * Net tracepoint probes.
- *
- * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
- * Dual LGPL v2.1/GPL v2 license.
- */
-
-#include <linux/module.h>
-#include <linux/netdevice.h>
-#include <linux/string.h>
-#include <trace/net.h>
-#include <trace/ipv4.h>
-#include <trace/ipv6.h>
-#include <trace/socket.h>
-
-#include "../ltt-type-serializer.h"
-
-void probe_net_dev_xmit(void *_data, struct sk_buff *skb);
-
-DEFINE_MARKER_TP(net, dev_xmit, net_dev_xmit, probe_net_dev_xmit,
-	"skb %p protocol #n2u%hu");
-
-notrace void probe_net_dev_xmit(void *_data, struct sk_buff *skb)
-{
-	struct marker *marker;
-	struct serialize_long_short data;
-
-	data.f1 = (unsigned long)skb;
-	data.f2 = skb->protocol;
-
-	marker = &GET_MARKER(net, dev_xmit);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(long));
-}
-
-void probe_net_dev_receive(void *_data, struct sk_buff *skb);
-
-DEFINE_MARKER_TP(net, dev_receive, net_dev_receive, probe_net_dev_receive,
-	"skb %p protocol #n2u%hu");
-
-notrace void probe_net_dev_receive(void *_data, struct sk_buff *skb)
-{
-	struct marker *marker;
-	struct serialize_long_short data;
-
-	data.f1 = (unsigned long)skb;
-	data.f2 = skb->protocol;
-
-	marker = &GET_MARKER(net, dev_receive);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(long));
-}
-
-void probe_ipv4_addr_add(void *_data, struct in_ifaddr *ifa)
-{
-	trace_mark_tp(netif_state, insert_ifa_ipv4, ipv4_addr_add,
-		probe_ipv4_addr_add, "label %s address #4u%u",
-		ifa->ifa_label, (unsigned int)ifa->ifa_address);
-}
-
-void probe_ipv4_addr_del(void *_data, struct in_ifaddr *ifa)
-{
-	trace_mark_tp(netif_state, del_ifa_ipv4, ipv4_addr_del,
-		probe_ipv4_addr_del, "label %s address #4u%u",
-		ifa->ifa_label, (unsigned int)ifa->ifa_address);
-}
-
-void probe_ipv6_addr_add(void *_data, struct inet6_ifaddr *ifa)
-{
-	__u8 *addr = ifa->addr.s6_addr;
-
-	trace_mark_tp(netif_state, insert_ifa_ipv6, ipv6_addr_add,
-		probe_ipv6_addr_add,
-		"label %s "
-		"a15 #1x%c a14 #1x%c a13 #1x%c a12 #1x%c "
-		"a11 #1x%c a10 #1x%c a9 #1x%c a8 #1x%c "
-		"a7 #1x%c a6 #1x%c a5 #1x%c a4 #1x%c "
-		"a3 #1x%c a2 #1x%c a1 #1x%c a0 #1x%c",
-		ifa->idev->dev->name,
-		addr[15], addr[14], addr[13], addr[12],
-		addr[11], addr[10], addr[9], addr[8],
-		addr[7], addr[6], addr[5], addr[4],
-		addr[3], addr[2], addr[1], addr[0]);
-}
-
-void probe_ipv6_addr_del(void *_data, struct inet6_ifaddr *ifa)
-{
-	__u8 *addr = ifa->addr.s6_addr;
-
-	trace_mark_tp(netif_state, insert_ifa_ipv6, ipv6_addr_del,
-		probe_ipv6_addr_del,
-		"label %s "
-		"a15 #1x%c a14 #1x%c a13 #1x%c a12 #1x%c "
-		"a11 #1x%c a10 #1x%c a9 #1x%c a8 #1x%c "
-		"a7 #1x%c a6 #1x%c a5 #1x%c a4 #1x%c "
-		"a3 #1x%c a2 #1x%c a1 #1x%c a0 #1x%c",
-		ifa->idev->dev->name,
-		addr[15], addr[14], addr[13], addr[12],
-		addr[11], addr[10], addr[9], addr[8],
-		addr[7], addr[6], addr[5], addr[4],
-		addr[3], addr[2], addr[1], addr[0]);
-}
-
-void probe_socket_create(void *_data, int family, int type, int protocol,
-	struct socket *sock, int ret)
-{
-	trace_mark_tp(net, socket_create, socket_create, probe_socket_create,
-		"family %d type %d protocol %d sock %p ret %d",
-		family, type, protocol, sock, ret);
-}
-
-void probe_socket_bind(void *_data, int fd, struct sockaddr __user *umyaddr, int addrlen,
-	int ret)
-{
-	trace_mark_tp(net, socket_bind, socket_bind, probe_socket_bind,
-		"fd %d umyaddr %p addrlen %d ret %d",
-		fd, umyaddr, addrlen, ret);
-}
-
-void probe_socket_connect(void *_data, int fd, struct sockaddr __user *uservaddr,
-	int addrlen, int ret)
-{
-	trace_mark_tp(net, socket_connect, socket_connect, probe_socket_connect,
-		"fd %d uservaddr %p addrlen %d ret %d",
-		fd, uservaddr, addrlen, ret);
-}
-
-void probe_socket_listen(void *_data, int fd, int backlog, int ret)
-{
-	trace_mark_tp(net, socket_listen, socket_listen, probe_socket_listen,
-		"fd %d backlog %d ret %d",
-		fd, backlog, ret);
-}
-
-void probe_socket_accept(void *_data, int fd, struct sockaddr __user *upeer_sockaddr,
-	int __user *upeer_addrlen, int flags, int ret)
-{
-	trace_mark_tp(net, socket_accept, socket_accept, probe_socket_accept,
-		"fd %d upeer_sockaddr %p upeer_addrlen %p flags %d ret %d",
-		fd, upeer_sockaddr, upeer_addrlen, flags, ret);
-}
-
-void probe_socket_getsockname(void *_data, int fd, struct sockaddr __user *usockaddr,
-	int __user *usockaddr_len, int ret)
-{
-	trace_mark_tp(net, socket_getsockname, socket_getsockname,
-		probe_socket_getsockname,
-		"fd %d usockaddr %p usockaddr_len %p ret %d",
-		fd, usockaddr, usockaddr_len, ret);
-}
-
-void probe_socket_getpeername(void *_data, int fd, struct sockaddr __user *usockaddr,
-	int __user *usockaddr_len, int ret)
-{
-	trace_mark_tp(net, socket_getpeername, socket_getpeername,
-		probe_socket_getpeername,
-		"fd %d usockaddr %p usockaddr_len %p ret %d",
-		fd, usockaddr, usockaddr_len, ret);
-}
-
-void probe_socket_socketpair(void *_data, int family, int type, int protocol,
-	int __user *usockvec, int ret)
-{
-	trace_mark_tp(net, socket_socketpair, socket_socketpair,
-		probe_socket_socketpair,
-		"family %d type %d protocol %d usockvec %p ret %d",
-		family, type, protocol, usockvec, ret);
-}
-
-void probe_socket_sendmsg(void *_data, struct socket *sock, struct msghdr *msg, size_t size,
-	int ret);
-
-DEFINE_MARKER_TP(net, socket_sendmsg, net_socket_sendmsg,
-	probe_socket_sendmsg,
-	"sock %p msg %p size %zu ret %d");
-
-notrace void probe_socket_sendmsg(void *_data, struct socket *sock, struct msghdr *msg,
-	size_t size, int ret)
-{
-	struct marker *marker;
-	struct serialize_long_long_sizet_int data;
-
-	data.f1 = (unsigned long)sock;
-	data.f2 = (unsigned long)msg;
-	data.f3 = size;
-	data.f4 = ret;
-
-	marker = &GET_MARKER(net, socket_sendmsg);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(size_t));
-}
-
-void probe_socket_recvmsg(void *_data, struct socket *sock, struct msghdr *msg, size_t size,
-	int flags, int ret);
-
-DEFINE_MARKER_TP(net, socket_recvmsg, net_socket_recvmsg,
-	probe_socket_recvmsg,
-	"sock %p msg %p size %zu flags %d ret %d");
-
-notrace void probe_socket_recvmsg(void *_data, struct socket *sock, struct msghdr *msg,
-	size_t size, int flags, int ret)
-{
-	struct marker *marker;
-	struct serialize_long_long_sizet_int_int data;
-
-	data.f1 = (unsigned long)sock;
-	data.f2 = (unsigned long)msg;
-	data.f3 = size;
-	data.f4 = flags;
-	data.f5 = ret;
-
-	marker = &GET_MARKER(net, socket_recvmsg);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(size_t));
-}
-
-void probe_socket_setsockopt(void *_data, int fd, int level, int optname,
-	char __user *optval, int optlen, int ret)
-{
-	trace_mark_tp(net, socket_setsockopt, socket_setsockopt,
-		probe_socket_setsockopt,
-		"fd %d level %d optname %d optval %p optlen %d ret %d",
-		fd, level, optname, optval, optlen, ret);
-}
-
-void probe_socket_getsockopt(void *_data, int fd, int level, int optname,
-	char __user *optval, int __user *optlen, int ret)
-{
-	trace_mark_tp(net, socket_getsockopt, socket_getsockopt,
-		probe_socket_getsockopt,
-		"fd %d level %d optname %d optval %p optlen %p ret %d",
-		fd, level, optname, optval, optlen, ret);
-}
-
-void probe_socket_shutdown(void *_data, int fd, int how, int ret)
-{
-	trace_mark_tp(net, socket_shutdown, socket_shutdown,
-		probe_socket_shutdown,
-		"fd %d how %d ret %d",
-		fd, how, ret);
-}
-
-void probe_socket_call(void *_data, int call, unsigned long a0)
-{
-	trace_mark_tp(net, socket_call, socket_call, probe_socket_call,
-		"call %d a0 %lu", call, a0);
-}
-
-void probe_tcpv4_rcv(void *_data, struct sk_buff *skb);
-
-DEFINE_MARKER_TP(net, tcpv4_rcv, net_tcpv4_rcv, probe_tcpv4_rcv,
-	"skb %p");
-
-notrace void probe_tcpv4_rcv(void *_data, struct sk_buff *skb)
-{
-	struct marker *marker;
-
-	marker = &GET_MARKER(net, tcpv4_rcv);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&skb, sizeof(skb), sizeof(skb));
-}
-
-void probe_udpv4_rcv(void *_data, struct sk_buff *skb);
-
-DEFINE_MARKER_TP(net, udpv4_rcv, net_udpv4_rcv, probe_udpv4_rcv,
-	"skb %p");
-
-notrace void probe_udpv4_rcv(void *_data, struct sk_buff *skb)
-{
-	struct marker *marker;
-
-	marker = &GET_MARKER(net, udpv4_rcv);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&skb, sizeof(skb), sizeof(skb));
-}
-
-#ifdef CONFIG_NETPOLL
-void probe_net_napi_schedule(void *_data, struct napi_struct *n);
-
-DEFINE_MARKER_TP(net, napi_schedule, net_napi_schedule,
-	probe_net_napi_schedule,
-	"napi_struct %p name %s");
-
-notrace void probe_net_napi_schedule(void *_data, struct napi_struct *n)
-{
-	struct marker *marker;
-	struct serialize_long_ifname data;
-	size_t data_len = 0;
-
-	data.f1 = (unsigned long)n;
-	data_len += sizeof(data.f1);
-	/* No need to align for strings */
-	strcpy(data.f2, n->dev ? n->dev->name : "<unk>");
-	data_len += strlen(data.f2) + 1;
-
-	marker = &GET_MARKER(net, napi_schedule);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, data_len, sizeof(long));
-}
-
-void probe_net_napi_poll(void *_data, struct napi_struct *n);
-
-DEFINE_MARKER_TP(net, napi_poll, net_napi_poll,
-	probe_net_napi_poll,
-	"napi_struct %p name %s");
-
-notrace void probe_net_napi_poll(void *_data, struct napi_struct *n)
-{
-	struct marker *marker;
-	struct serialize_long_ifname data;
-	size_t data_len = 0;
-
-	data.f1 = (unsigned long)n;
-	data_len += sizeof(data.f1);
-	/* No need to align for strings */
-	strcpy(data.f2, n->dev ? n->dev->name : "<unk>");
-	data_len += strlen(data.f2) + 1;
-
-	marker = &GET_MARKER(net, napi_poll);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, data_len, sizeof(long));
-}
-
-void probe_net_napi_complete(void *_data, struct napi_struct *n);
-
-DEFINE_MARKER_TP(net, napi_complete, net_napi_complete,
-	probe_net_napi_complete,
-	"napi_struct %p name %s");
-
-notrace void probe_net_napi_complete(void *_data, struct napi_struct *n)
-{
-	struct marker *marker;
-	struct serialize_long_ifname data;
-	size_t data_len = 0;
-
-	data.f1 = (unsigned long)n;
-	data_len += sizeof(data.f1);
-	/* No need to align for strings */
-	strcpy(data.f2, n->dev ? n->dev->name : "<unk>");
-	data_len += strlen(data.f2) + 1;
-
-	marker = &GET_MARKER(net, napi_complete);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, data_len, sizeof(long));
-}
-#else /* !CONFIG_NETPOLL */
-void probe_net_napi_schedule(void *_data, struct napi_struct *n);
-
-DEFINE_MARKER_TP(net, napi_schedule, net_napi_schedule,
-	probe_net_napi_schedule,
-	"napi_struct %p");
-
-notrace void probe_net_napi_schedule(void *_data, struct napi_struct *n)
-{
-	struct marker *marker;
-	unsigned long data;
-
-	data = (unsigned long)n;
-
-	marker = &GET_MARKER(net, napi_schedule);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, sizeof(data), sizeof(data));
-}
-
-void probe_net_napi_poll(void *_data, struct napi_struct *n);
-
-DEFINE_MARKER_TP(net, napi_poll, net_napi_poll,
-	probe_net_napi_poll,
-	"napi_struct %p");
-
-notrace void probe_net_napi_poll(void *_data, struct napi_struct *n)
-{
-	struct marker *marker;
-	unsigned long data;
-
-	data = (unsigned long)n;
-
-	marker = &GET_MARKER(net, napi_poll);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, sizeof(data), sizeof(data));
-}
-
-void probe_net_napi_complete(void *_data, struct napi_struct *n);
-
-DEFINE_MARKER_TP(net, napi_complete, net_napi_complete,
-	probe_net_napi_complete,
-	"napi_struct %p");
-
-notrace void probe_net_napi_complete(void *_data, struct napi_struct *n)
-{
-	struct marker *marker;
-	unsigned long data;
-
-	data = (unsigned long)n;
-
-	marker = &GET_MARKER(net, napi_complete);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, sizeof(data), sizeof(data));
-}
-#endif
-
-MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Mathieu Desnoyers");
-MODULE_DESCRIPTION("Net Tracepoint Probes");
diff --git a/drivers/staging/lttng/probes/pm-trace.c b/drivers/staging/lttng/probes/pm-trace.c
deleted file mode 100644
index 7abe8e3..0000000
--- a/drivers/staging/lttng/probes/pm-trace.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * ltt/probes/pm-trace.c
- *
- * Power Management tracepoint probes.
- *
- * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
- * Dual LGPL v2.1/GPL v2 license.
- */
-
-#include <linux/module.h>
-#include <trace/pm.h>
-
-void probe_pm_idle_entry(void *_data)
-{
-	trace_mark_tp(pm, idle_entry, pm_idle_entry,
-		probe_pm_idle_entry, "irqstate #1%d",
-		irqs_disabled());
-}
-
-void probe_pm_idle_exit(void *_data)
-{
-	trace_mark_tp(pm, idle_exit, pm_idle_exit,
-		probe_pm_idle_exit, "irqstate #1%d",
-		irqs_disabled());
-}
-
-void probe_pm_suspend_entry(void *_data)
-{
-	trace_mark_tp(pm, suspend_entry, pm_suspend_entry,
-		probe_pm_suspend_entry, "irqstate #1%d",
-		irqs_disabled());
-}
-
-void probe_pm_suspend_exit(void *_data)
-{
-	trace_mark_tp(pm, suspend_exit, pm_suspend_exit,
-		probe_pm_suspend_exit, "irqstate #1%d",
-		irqs_disabled());
-}
-
-MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Mathieu Desnoyers");
-MODULE_DESCRIPTION("Power Management Tracepoint Probes");
diff --git a/drivers/staging/lttng/probes/rcu-trace.c b/drivers/staging/lttng/probes/rcu-trace.c
deleted file mode 100644
index cc16454..0000000
--- a/drivers/staging/lttng/probes/rcu-trace.c
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * ltt/probes/rcu-trace.c
- *
- * RCU tracepoint probes.
- *
- * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
- * Dual LGPL v2.1/GPL v2 license.
- */
-
-#include <linux/module.h>
-#include <trace/rcu.h>
-
-#ifdef CONFIG_TREE_RCU
-void probe_rcu_tree_callback(void *data, struct rcu_head *head)
-{
-	trace_mark_tp(rcu, tree_callback, rcu_tree_callback,
-		probe_rcu_tree_callback, "func %p", head->func);
-}
-
-void probe_rcu_tree_call_rcu(void *data, struct rcu_head *head, unsigned long ip)
-{
-	trace_mark_tp(rcu, tree_call_rcu, rcu_tree_call_rcu,
-		probe_rcu_tree_call_rcu, "func %p ip 0x%lX", head->func, ip);
-}
-
-void probe_rcu_tree_call_rcu_bh(void *data, struct rcu_head *head, unsigned long ip)
-{
-	trace_mark_tp(rcu, tree_call_rcu_bh, rcu_tree_call_rcu_bh,
-		probe_rcu_tree_call_rcu_bh, "func %p ip 0x%lX",
-		head->func, ip);
-}
-#endif
-
-MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Mathieu Desnoyers");
-MODULE_DESCRIPTION("RCU Tracepoint Probes");
diff --git a/drivers/staging/lttng/probes/syscall-trace.c b/drivers/staging/lttng/probes/syscall-trace.c
deleted file mode 100644
index 9ae419f..0000000
--- a/drivers/staging/lttng/probes/syscall-trace.c
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * ltt/probes/syscall-trace.c
- *
- * System call tracepoint probes.
- *
- * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
- * Dual LGPL v2.1/GPL v2 license.
- */
-
-#include <linux/module.h>
-#include <trace/syscall.h>
-
-#include "../ltt-type-serializer.h"
-
-
-/* kernel_syscall_entry specialized tracepoint probe */
-
-void probe_syscall_entry(void *_data, struct pt_regs *regs, long id);
-
-DEFINE_MARKER_TP(kernel, syscall_entry, syscall_entry,
-	probe_syscall_entry, "ip #p%ld syscall_id #2u%u");
-
-notrace void probe_syscall_entry(void *_data, struct pt_regs *regs, long id)
-{
-	struct marker *marker;
-	struct serialize_long_short data;
-
-	data.f1 = instruction_pointer(regs);
-	data.f2 = (unsigned short)id;
-
-	marker = &GET_MARKER(kernel, syscall_entry);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(long));
-}
-
-/* kernel_syscall_exit specialized tracepoint probe */
-
-void probe_syscall_exit(void *_data, long ret);
-
-DEFINE_MARKER_TP(kernel, syscall_exit, syscall_exit,
-	probe_syscall_exit, "ret %ld");
-
-notrace void probe_syscall_exit(void *_data, long ret)
-{
-	struct marker *marker;
-
-	marker = &GET_MARKER(kernel, syscall_exit);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&ret, sizeof(ret), sizeof(ret));
-}
-
-MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Mathieu Desnoyers");
-MODULE_DESCRIPTION("syscall Tracepoint Probes");
diff --git a/drivers/staging/lttng/probes/trap-trace.c b/drivers/staging/lttng/probes/trap-trace.c
deleted file mode 100644
index 397254c..0000000
--- a/drivers/staging/lttng/probes/trap-trace.c
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * ltt/probes/trap-trace.c
- *
- * Trap tracepoint probes.
- *
- * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
- * Dual LGPL v2.1/GPL v2 license.
- */
-
-#include <linux/module.h>
-#include <trace/trap.h>
-
-#include "../ltt-type-serializer.h"
-
-/* kernel_trap_entry specialized tracepoint probe */
-
-void probe_trap_entry(void *_data, struct pt_regs *regs, long id);
-
-DEFINE_MARKER_TP(kernel, trap_entry, trap_entry,
-	probe_trap_entry, "ip #p%ld trap_id #2u%u");
-
-notrace void probe_trap_entry(void *_data, struct pt_regs *regs, long id)
-{
-	struct marker *marker;
-	struct serialize_long_short data;
-
-	if (likely(regs))
-		data.f1 = instruction_pointer(regs);
-	else
-		data.f1 = 0UL;
-	data.f2 = (unsigned short)id;
-
-	marker = &GET_MARKER(kernel, trap_entry);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		&data, serialize_sizeof(data), sizeof(long));
-}
-
-/* kernel_syscall_exit specialized tracepoint probe */
-
-void probe_trap_exit(void *_data);
-
-DEFINE_MARKER_TP(kernel, trap_exit, trap_exit,
-	probe_trap_exit, MARK_NOARGS);
-
-notrace void probe_trap_exit(void *_data)
-{
-	struct marker *marker;
-
-	marker = &GET_MARKER(kernel, trap_exit);
-	ltt_specialized_trace(marker, marker->single.probe_private,
-		NULL, 0, 0);
-}
-
-MODULE_LICENSE("GPL and additional rights");
-MODULE_AUTHOR("Mathieu Desnoyers");
-MODULE_DESCRIPTION("Trap Tracepoint Probes");
-- 
2.0.2

