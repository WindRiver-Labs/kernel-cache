From 0a66dee3712401202ac244fe32c2df6965004826 Mon Sep 17 00:00:00 2001
From: Shan Hai <shan.hai@windriver.com>
Date: Tue, 5 Jan 2016 09:52:26 +0800
Subject: [PATCH] drm/emgd: update the emgd kernel driver for
 Lin_IEMGD_1_18_Hotfix_4024.tgz

The update is based on the LIN_IEMGD_1_18_GOLD_3398.tgz, includes
"Fix for EMGD glDrawArrays() size argument limitation".

Signed-off-by: Shan Hai <shan.hai@windriver.com>
---
 .../gpu/drm/emgd/emgd/display/mode/cmn/igd_mode.c  |   26 +-
 .../drm/emgd/emgd/display/mode/plb/clocks_plb.c    |   10 +-
 .../gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c  |    4 +
 .../emgd/emgd/display/mode/tnc/micro_mode_tnc.c    |   83 ++
 .../emgd/emgd/display/mode/tnc/micro_mode_tnc.h    |   52 +
 .../gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.c  |    4 +
 drivers/gpu/drm/emgd/emgd/display/pi/cmn/pi.c      |   68 ++-
 .../drm/emgd/emgd/display/pi/tnc/i2c_bitbash_tnc.c |  194 ++++
 .../drm/emgd/emgd/display/pi/tnc/i2c_bitbash_tnc.h |   53 ++
 .../drm/emgd/emgd/display/pi/tnc/i2c_gmbus_tnc.c   |  175 ++++-
 drivers/gpu/drm/emgd/emgd/drm/emgd_drv.c           |   18 +-
 drivers/gpu/drm/emgd/emgd/drm/emgd_drv.h           |    1 +
 drivers/gpu/drm/emgd/emgd/drm/emgd_fbcon.c         |   59 +--
 drivers/gpu/drm/emgd/emgd/drm/emgd_interface.c     |   26 +
 drivers/gpu/drm/emgd/emgd/drm/emgd_proc.c          |  972 ++++++++++++++++++++
 drivers/gpu/drm/emgd/emgd/drm/emgd_proc.h          |   39 +
 drivers/gpu/drm/emgd/emgd/include/sched.h          |    2 +-
 drivers/gpu/drm/emgd/emgd/include/tnc/igd_tnc_wa.h |    1 +
 .../gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc.c  |   45 +-
 drivers/gpu/drm/emgd/include/emgd_drm.h            |    3 +
 drivers/gpu/drm/emgd/include/igd_mode.h            |    5 +
 drivers/gpu/drm/emgd/include/igd_ovl.h             |    3 +
 drivers/gpu/drm/emgd/include/igd_version.h         |    2 +-
 .../pvr/services4/srvkm/devices/sgx/sgxutils.c     |    8 +
 24 files changed, 1747 insertions(+), 106 deletions(-)
 create mode 100644 drivers/gpu/drm/emgd/emgd/display/mode/tnc/micro_mode_tnc.h
 create mode 100644 drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_bitbash_tnc.h
 create mode 100755 drivers/gpu/drm/emgd/emgd/drm/emgd_proc.c
 create mode 100755 drivers/gpu/drm/emgd/emgd/drm/emgd_proc.h

diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/igd_mode.c b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/igd_mode.c
index 827645d..2ad64c1 100755
--- a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/igd_mode.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/igd_mode.c
@@ -1038,13 +1038,27 @@ long igd_pan_display(igd_display_h hDisplay,
 	 * TODO:
 	 * "ideally the FB 720 height should center on LVDS 768 height and pan across horizontally that is 1280 FB width pans on LVDS 1024 width."
 	 */
-	if (fb_info->height >= pt_info->height) {
-		if (pt_info->width + x_offset > fb_info->width ||
-			pt_info->height + y_offset > fb_info->height) {
+	/*
+	 * We have not a flag to know which strategy (panel fit or panning) is selected.
+	 * Now, in port and lvds, the logic is upscale or panning.
+	 * So assume fb width/height > pt width/height, panning selected, otherwise panel fit selected.
+	 * This assumption must always be consistent with logic in other modules, like port, lvds.
+	 *
+	 * Radio of width/height may be different between sdvo and lvds, so there is conditon panning vertically and panel fit horizontally,
+	 * and vice versa. So we check width/height separately.
+	 */
+ 	if ((fb_info->height <= pt_info->height) &&
+ 		(fb_info->width <= pt_info->width)) {
+ 		/* no panning */
+		return -IGD_ERROR_INVAL;
+	}
+	if (fb_info->height > pt_info->height) { /* panning vertically */
+		if (pt_info->height + y_offset > fb_info->height) {
 			EMGD_ERROR_EXIT("invalid offsets are passing frame buffer.");
 			return -IGD_ERROR_INVAL;
 		}
-	} else {
+	}
+	if (fb_info->width > pt_info->width) { /* panning horizontally */
 		if (pt_info->width + x_offset > fb_info->width ) {
 			EMGD_ERROR_EXIT("invalid offsets are passing frame buffer.");
 			return -IGD_ERROR_INVAL;
@@ -1071,14 +1085,14 @@ long igd_pan_display(igd_display_h hDisplay,
 	*/
 	ovl_context->ovl_display_swapped = 1;
 
-	/* FIXME:
+	/* FIXME: FIXED
 	 *   This could be negative, and thus conflict with the error codes
 	 *   returned above.  However, this is needed for Whitney to compensate
 	 *   for the framebuffer offset alignment requirements and should only
 	 *   be positive.
 	 */
 	EMGD_TRACE_EXIT;
-	return (x_offset - x_old);
+	return IGD_SUCCESS;
 
 } /* end igd_pan_display() */
 
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/plb/clocks_plb.c b/drivers/gpu/drm/emgd/emgd/display/mode/plb/clocks_plb.c
index f39e9d2..db41fd0 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/plb/clocks_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/plb/clocks_plb.c
@@ -605,10 +605,12 @@ int program_clock_plb(igd_display_context_t *display,
 		/* If SSC is enabled, then the reference frequency needs to be
 		 * 100000 instead of 96000.
 		 */
-		for(index = 0; index < port->attr_list->num_attrs; index++) {
-			if(port->attr_list->attr[index].id == PD_ATTR_ID_SSC) {
-				ref_freq = 100000;
-				break;
+		if(port->attr_list) {
+			for(index = 0; index < port->attr_list->num_attrs; index++) {
+				if(port->attr_list->attr[index].id == PD_ATTR_ID_SSC) {
+					ref_freq = 100000;
+					break;
+				}
 			}
 		}
 	}
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c b/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c
index 55a90cc..13581a4 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c
@@ -781,6 +781,10 @@ static int igd_set_surface_plb(igd_display_h display_handle,
 	if(!surface) {
 		return -IGD_ERROR_INVAL;
 	}
+	
+	if(!display_handle) {
+		return -IGD_ERROR_INVAL;
+	}	
 
 	switch(type) {
 	case IGD_BUFFER_DISPLAY:
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/micro_mode_tnc.c b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/micro_mode_tnc.c
index 2a313ec..8d34f52 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/micro_mode_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/micro_mode_tnc.c
@@ -64,6 +64,7 @@
 #include "../cmn/match.h"
 #include "../cmn/mode_dispatch.h"
 #include "mode_tnc.h"
+#include "micro_mode_tnc.h"
 
 /*
 	Turning on FIB part workaround for all IALs, for vBIOS this will limit
@@ -133,6 +134,19 @@ tnc_wa_timing_t tune = {0, 0, 0, 0, 0, 0, 0,};
 /* Temporary frame buffer */
 static igd_framebuffer_info_t fb_info_tmp = {0,0,0,0,0,0,0};
 
+#ifdef USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES
+/* Flag to indicate the GPIO/RGEN Enable value is already read or not.
+ * This is to avoid multiple read/check of RGEN value
+ */
+bool flag_read_rgen_gpio = FALSE;
+
+/* Flag to indicate RGEN - Resume Well GPIO pin is Enabled or not */
+bool flag_lvds_ctrl_gpio_enabled = FALSE;
+
+/* First read RGEN Value */
+unsigned long gpio_rgen_init_value = 0;
+#endif
+
 /* VPhase variable */
 int vphase = 0;	/* The current value to enable  vphase is 5 */
 
@@ -1658,6 +1672,15 @@ void program_pipe_tnc(igd_display_context_t *display,
 			*/
 			WRITE_MMIO_REG_TNC(IGD_PORT_LVDS, PFIT_CONTROL, 0xA2000000);
 		}
+#else
+		/*
+		 * The root cause of HSD 206200 is the enabling of panel fit.
+		 * As a matter of fact, SDVO port doesn't need panel fit to scale
+		 * in kernel. So disable it here!
+		 */
+		if (pt == IGD_PORT_SDVO) {
+			WRITE_MMIO_REG_TNC(IGD_PORT_LVDS, PFIT_CONTROL, 0x0);
+		}
 #endif
 
 		WRITE_MMIO_REG_TNC(ports_tnc[i], PIPE(display)->pipe_reg, pipe_conf);
@@ -2594,6 +2617,22 @@ unsigned char *get_mmio_tnc(unsigned long port_type)
 }
 #endif
 
+#ifdef USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES
+/* Function to read and store the rgen register value */
+void read_store_gpio_rgen_register(void)
+{
+EMGD_TRACE_ENTER;
+	gpio_rgen_init_value = EMGD_READ_PORT32(io_base_lpc + RGEN);
+	if((gpio_rgen_init_value & 0x1F) != 0x00)
+	{
+		flag_lvds_ctrl_gpio_enabled = TRUE;
+	}
+
+	flag_read_rgen_gpio = TRUE;
+EMGD_TRACE_EXIT;
+}
+#endif
+
 /* Function to read Atom E6xx 0:2:0, 0:3:0 and 0:31:0 mmio registers */
 unsigned long read_mmio_reg_tnc(unsigned long port_type, unsigned long reg)
 {
@@ -2601,6 +2640,7 @@ unsigned long read_mmio_reg_tnc(unsigned long port_type, unsigned long reg)
 #ifndef CONFIG_MICRO
 	unsigned char *mmio;
 #endif
+EMGD_TRACE_ENTER;
 
 	/* to avoid updating or having another set of read/write macros for
 	 * vbios, overwrite io_base to properly read from 0:2:0/0:3:0/0:31:0
@@ -2611,6 +2651,26 @@ unsigned long read_mmio_reg_tnc(unsigned long port_type, unsigned long reg)
 		io_base = io_base_sdvo;
 	} else if (port_type == IGD_PORT_LPC) {
 		io_base = io_base_lpc;
+
+#ifdef USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES
+	EMGD_DEBUG("Using USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES");
+		/* FIX: Minnow Board GPIO Overload issue
+		 * Enable and proceed with I2C operations for LVDS EDID read only when RGEN[4:0] = 0x00,
+		 * other values indicates that it is configured for GPIO.
+		 */
+		if(flag_read_rgen_gpio == FALSE)
+		{
+			read_store_gpio_rgen_register();
+		}
+
+		if(flag_lvds_ctrl_gpio_enabled == 1)
+		{
+			io_base = io_base_lvds;
+	EMGD_DEBUG("Error!!! GPIO Pins are already in use. Not available for I2C operation for LVDS EDID read");
+EMGD_TRACE_EXIT;
+			return 0;
+		}
+#endif
 	} else if (port_type == IGD_PORT_SDVO_ST) {
 		io_base = io_base_sdvo_st;
 	}
@@ -2622,6 +2682,7 @@ unsigned long read_mmio_reg_tnc(unsigned long port_type, unsigned long reg)
 	}
 
 	io_base = io_base_lvds;
+EMGD_TRACE_EXIT;
 	return value;
 }
 
@@ -2632,6 +2693,7 @@ void write_mmio_reg_tnc(unsigned long port_type, unsigned long reg,
 #ifndef CONFIG_MICRO
 	unsigned char *mmio;
 #endif
+EMGD_TRACE_ENTER;
 
 	/* to avoid updating or having another set of read/write macros for
 	 * vbios, overwrite io_base to properly read from 0:2:0/0:3:0 io_base
@@ -2642,6 +2704,26 @@ void write_mmio_reg_tnc(unsigned long port_type, unsigned long reg,
 		io_base = io_base_sdvo;
 	} else if (port_type == IGD_PORT_LPC) {
 		io_base = io_base_lpc;
+
+#ifdef USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES
+	EMGD_DEBUG("Using USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES");
+		/* FIX: Minnow Board GPIO issue
+		 * Enable and proceed with I2C operations for LVDS EDID read only when RGEN[4:0] = 0x00,
+		 * other values indicates that it is configured for GPIO.
+		 */
+		if(flag_read_rgen_gpio == FALSE)
+		{
+			read_store_gpio_rgen_register();
+		}
+
+		if(flag_lvds_ctrl_gpio_enabled == TRUE)
+		{
+			io_base = io_base_lvds;
+	EMGD_DEBUG("Error!!! GPIO Pins are already in use. Not available for I2C operation for LVDS EDID read");
+EMGD_TRACE_EXIT;
+			return;
+		}
+#endif
 	} else if (port_type == IGD_PORT_SDVO_ST) {
 		io_base = io_base_sdvo_st;
 	}
@@ -2653,6 +2735,7 @@ void write_mmio_reg_tnc(unsigned long port_type, unsigned long reg,
 		EMGD_WRITE32(value, EMGD_MMIO(mmio) + reg);
 	}
 	io_base = io_base_lvds;
+EMGD_TRACE_EXIT;
 	return;
 }
 
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/micro_mode_tnc.h b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/micro_mode_tnc.h
new file mode 100644
index 0000000..75208ec
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/micro_mode_tnc.h
@@ -0,0 +1,52 @@
+/*
+ *-----------------------------------------------------------------------------
+ * Filename: micro_mode_tnc.h
+ * $Revision: 1.0 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2011, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+#ifndef _MICRO_MODE_TNC_H
+#define _MICRO_MODE_TNC_H
+
+#ifdef USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES
+
+/* Flag to indicate the GPIO/RGEN Enable value is already read or not.
+ * This is to avoid multiple read/check of RGEN value
+ */
+extern bool flag_read_rgen_gpio;
+
+/* Flag to indicate RGEN - Resume Well GPIO pin is Enabled or not */
+extern bool flag_lvds_ctrl_gpio_enabled;
+
+/* First read RGEN Value */
+extern unsigned long gpio_rgen_init_value;
+
+/* Function to read and store the RGEN register value */
+void read_store_gpio_rgen_register(void);
+
+#endif
+
+#endif
+
+
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.c b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.c
index 13f8613..0269042 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.c
@@ -837,6 +837,10 @@ static int igd_set_surface_tnc(igd_display_h display_handle,
 	if(!surface) {
 		return -IGD_ERROR_INVAL;
 	}
+	
+	if(!display_handle) {
+		return -IGD_ERROR_INVAL;
+	}
 
 	switch(type) {
 	case IGD_BUFFER_DISPLAY:
diff --git a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/pi.c b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/pi.c
index 3f8aeab2..1439a44 100755
--- a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/pi.c
+++ b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/pi.c
@@ -701,6 +701,7 @@ int pi_pd_init(igd_display_port_t *port,
 	pd_timing_t        *firmware_timings = NULL;
 	pd_timing_t        *final_timings = NULL;
 	pd_timing_t        *pd_timing_table = NULL;
+	pd_timing_t 	   *got_firmware_timings = NULL;
 	mode_state_t       *mstate;
 	int                i, ret = PD_SUCCESS;
 	unsigned long      edid_flags;
@@ -815,23 +816,64 @@ int pi_pd_init(igd_display_port_t *port,
 		}
 	}
 
+	firmware_timings = NULL;
+
 	/* Include EDID timings and filter modes */
 	if (edid_flags & IGD_DISPLAY_USE_EDID) {
+
 		EMGD_DEBUG("Using EDID-DTDs ");
+
 		ret = get_firmware_timings(port, firmware_data, final_timings);
-		if (port->firmware_type == PI_FIRMWARE_EDID) {
-			firmware_timings = port->edid->timings;
-			num_firmware_timings = port->edid->num_timings;
-		} else if (port->firmware_type == PI_FIRMWARE_DISPLAYID) {
-			firmware_timings = port->displayid->timings;
-			num_firmware_timings = port->displayid->num_timings;
-		}
-		if (ret == 0 && num_firmware_timings) {
-			/* Add EDID DTDs at the begining of the final timings */
-			firmware_timings[num_firmware_timings].extn_ptr =
-				(void *)final_timings;
-			final_timings = firmware_timings;
-		}
+
+		if (ret == 0) {
+                        if (port->firmware_type == PI_FIRMWARE_EDID) {
+                                got_firmware_timings = port->edid->timings;
+                                num_firmware_timings = port->edid->num_timings;
+                        } else if (port->firmware_type == PI_FIRMWARE_DISPLAYID) {
+                                got_firmware_timings = port->displayid->timings;
+                                num_firmware_timings = port->displayid->num_timings;
+                        }
+                }
+
+		if (got_firmware_timings && num_firmware_timings) {
+                        /* Add EDID DTDs at the begining of the final timings */
+                        firmware_timings = got_firmware_timings;
+                        firmware_timings[num_firmware_timings].extn_ptr =
+                                (void *)final_timings;
+                        final_timings = firmware_timings;
+		} else {
+
+			EMGD_DEBUG("Invalid EDID-DTDs");
+
+                        if (display_params && display_params->edid_not_avail) {
+                                edid_flags = display_params->edid_not_avail;
+                                edid_flags &= ~IGD_DISPLAY_USE_EDID;
+                        } else {
+                                /* Default to standard timings */
+                                edid_flags = IGD_DISPLAY_USE_STD_TIMINGS;
+                        }
+
+                        EMGD_DEBUG("Falling back to EDID flags: 0x%lx", edid_flags);
+
+                        final_timings = NULL;
+
+                        if (edid_flags & IGD_DISPLAY_USE_STD_TIMINGS) {
+                                EMGD_DEBUG("Using STD TIMINGS ");
+                                final_timings = std_timings;
+                        }
+                        if (edid_flags & IGD_DISPLAY_USE_USERDTDS) {
+				EMGD_DEBUG("Using USER-DTDs ");
+				user_timings = get_user_timings(port->dtd_list);
+
+				if (user_timings) {
+					user_timings[port->dtd_list->num_dtds].extn_ptr = final_timings;
+					final_timings = user_timings;
+				} else {
+					EMGD_DEBUG("Empty USER-DTDs, so Using STD TIMINGS ");
+                             		final_timings = std_timings;
+				}
+                        }
+                }
 	}
 
 	/* Replace any common timings */
diff --git a/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_bitbash_tnc.c b/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_bitbash_tnc.c
index 427aa29..6591f3a 100644
--- a/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_bitbash_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_bitbash_tnc.c
@@ -54,8 +54,13 @@
 
 #include <intelpci.h>
 
+#include "i2c_bitbash_tnc.h"
+
 #include "../cmn/i2c_dispatch.h"
 
+#include <linux/gpio.h>
+#include "../../mode/tnc/micro_mode_tnc.h"
+
 /*!
  * @addtogroup display_group
  * @{
@@ -123,6 +128,40 @@ static void enable_gpio_tnc(igd_context_t *context)
 }
 #endif
 
+#ifdef USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES
+
+/* Flag to indicate the GPIO access is claimed or not */
+bool global_flag_gpio_claimed = FALSE;
+
+/* Function to disable GPIO data and clock in RGEN register */
+void disable_gpio_rgen_data_clock_tnc(void)
+{
+EMGD_TRACE_ENTER;
+	unsigned long temp;
+
+	temp = READ_MMIO_REG_TNC(IGD_PORT_LPC, RGEN);
+	temp &= ~(GPIO_DATA | GPIO_CLOCK);
+	WRITE_MMIO_REG_TNC(IGD_PORT_LPC, RGEN, temp);
+
+EMGD_TRACE_EXIT;
+	return;
+}
+
+/* Function to enable GPIO data and clock in RGEN register */
+void enable_gpio_rgen_data_clock_tnc(void)
+{
+EMGD_TRACE_ENTER;
+	unsigned long temp;
+
+	temp = READ_MMIO_REG_TNC(IGD_PORT_LPC, RGEN);
+	temp |= (GPIO_DATA | GPIO_CLOCK);
+	WRITE_MMIO_REG_TNC(IGD_PORT_LPC, RGEN, temp);
+
+EMGD_TRACE_EXIT;
+	return;
+}
+#endif
+
 /*!
  *
  * @param clock
@@ -133,6 +172,59 @@ static void enable_gpio_tnc(igd_context_t *context)
 static void i2c_get(unsigned long *clock,
 	unsigned long *data)
 {
+#ifdef USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES
+	EMGD_DEBUG("Using USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES");
+	/* Minnow-Circuitco GPIO overloading Issue Fix
+	 * The inl/outl read/modify/write process is not atomic and so have the risk of
+	 * overwriting (or having the bits overwritten) between the inl and outl.
+	 * This GPIOLIB set/get value operations provides safe way (mutex kind) for
+	 * read/modify/write operation.
+	 */
+	/* Check whether the RGEN value is already read. If not read and store the value */
+	if(flag_read_rgen_gpio == FALSE)
+	{
+		read_store_gpio_rgen_register();
+	}
+
+	/* Check whether the GPIO is available for read/write operation */
+	if(flag_lvds_ctrl_gpio_enabled == FALSE)
+	{
+		/* Perform read/write operation only when the GPIO is claimed and it is valid */
+		if(global_flag_gpio_claimed && gpio_is_valid(GPIO_LVDS3) && gpio_is_valid(GPIO_LVDS4))
+		{
+			int ret_dir, ret_pin_val;
+
+			/* Set the GPIO direction as Input and read the clock value */
+			ret_dir = gpio_direction_input(GPIO_LVDS3);
+			if(ret_dir == 0)
+			{
+				*clock = gpio_get_value(GPIO_LVDS3);
+			}
+			else
+			{
+				EMGD_DEBUG("Error !!! GPIO library direction set as input failed");
+				*clock = 0;
+			}
+
+			/* Set the GPIO direction as Input and read the data value */
+			ret_dir = gpio_direction_input(GPIO_LVDS4);
+			if(ret_dir == 0)
+			{
+				*data = gpio_get_value(GPIO_LVDS4);
+			}
+			else
+			{
+				EMGD_DEBUG("Error !!! GPIO library direction set as input failed");
+				*data = 0;
+			}
+		}
+		else
+			EMGD_DEBUG("Error !!! GPIO library is not available or Pins are not valid");
+	}
+	else
+		EMGD_DEBUG("Error !!! GPIO pins are not available for use");
+
+#else
 	unsigned long temp;
 	/* Set Data as Input */
 	temp = READ_MMIO_REG_TNC(IGD_PORT_LPC, RGIO);
@@ -148,6 +240,7 @@ static void i2c_get(unsigned long *clock,
 	*data = (c>>8) & 1;
 	*clock &= 1;
 #endif
+#endif
 }
 
 /*!
@@ -160,6 +253,40 @@ static void i2c_get(unsigned long *clock,
 static void i2c_set_data(int data,
 	unsigned long hold_time)
 {
+#ifdef USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES
+
+	EMGD_DEBUG("Using USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES");
+	/* Check whether the RGEN value is already read. If not read and store the value */
+	if(flag_read_rgen_gpio == FALSE)
+	{
+		read_store_gpio_rgen_register();
+	}
+
+	/* Check whether the GPIO is available for read/write operation */
+	if(flag_lvds_ctrl_gpio_enabled == FALSE)
+	{
+		/* Perform read/write operation only when the GPIO is claimed and it is valid */
+		if(global_flag_gpio_claimed && gpio_is_valid(GPIO_LVDS4))
+		{
+			int ret_dir;
+
+			/* Set the GPIO direction as output and set the data value */
+			ret_dir = gpio_direction_output(GPIO_LVDS4,0);
+			if(ret_dir == 0)
+			{
+				gpio_set_value(GPIO_LVDS4,data);
+			}
+			else
+				EMGD_DEBUG("Error !!! GPIO library direction set as output failed");
+		}
+		else
+			EMGD_DEBUG("Error !!! GPIO library is not available or Pins are not valid");
+
+		OS_DELAY(hold_time);
+	}
+	else
+		EMGD_DEBUG("Error !!! GPIO Pins are not available for use");
+#else
 	unsigned long temp;
 	/* The LVDS GPIO data lines are GPIOSUS[4] */
 	/* Set as Output */
@@ -195,6 +322,7 @@ static void i2c_set_data(int data,
 	EMGD_WRITE32(data ? 0x400 : 0x600, EMGD_MMIO(mmio) + i2c_bus);
 	OS_DELAY(hold_time);
 #endif
+#endif
 }
 
 /*!
@@ -207,6 +335,39 @@ static void i2c_set_data(int data,
 static void i2c_set_clock(int clock,
 	unsigned long hold_time)
 {
+#ifdef USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES
+	EMGD_DEBUG("Using USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES");
+	/* Check whether the RGEN value is already read. If not read and store the value */
+	if(flag_read_rgen_gpio == FALSE)
+	{
+		read_store_gpio_rgen_register();
+	}
+
+	/* Check whether the GPIO is available for read/write operation */
+	if(flag_lvds_ctrl_gpio_enabled == FALSE)
+	{
+		/* Perform read/write operation only when the GPIO is claimed and it is valid */
+		if(global_flag_gpio_claimed && gpio_is_valid(GPIO_LVDS3))
+		{
+			int ret_dir;
+
+			/* Set the GPIO direction as output and set the clock value */
+			ret_dir = gpio_direction_output(GPIO_LVDS3,0);
+			if(ret_dir == 0)
+			{
+				gpio_set_value(GPIO_LVDS3,clock);
+			}
+			else
+				EMGD_DEBUG("Error !!! GPIO library direction set as output failed");
+		}
+		else
+			EMGD_DEBUG("Error !!! GPIO library is not available or pins are not valid");
+
+		OS_DELAY(hold_time);
+	}
+	else
+		EMGD_DEBUG("Error !!! GPIO Pins are not available for use");
+#else
 	unsigned long temp;
 	/* The LVDS GPIO clock lines are GPIOSUS[3] */
 	/* Set as Output */
@@ -241,6 +402,7 @@ static void i2c_set_clock(int clock,
 	EMGD_WRITE32(clock ? 0x4 : 0x6, EMGD_MMIO(mmio) + i2c_bus);
 	OS_DELAY(hold_time);
 #endif
+#endif
 }
 
 /*!
@@ -409,9 +571,41 @@ static int i2c_read_byte_tnc(unsigned char *value,
 
 	if (ack) {
 		/* Set data as input as we continue to read */
+#ifdef USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES
+	EMGD_DEBUG("Using USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES");
+		/* Check whether the RGEN value is already read. If not read and store the value */
+		if(flag_read_rgen_gpio == FALSE)
+		{
+			read_store_gpio_rgen_register();
+		}
+
+		/* Check whether the GPIO is available for read/write operation */
+		if(flag_lvds_ctrl_gpio_enabled == FALSE)
+		{
+			/* Perform read/write operation only when the GPIO is claimed and it is valid */
+			if(global_flag_gpio_claimed && gpio_is_valid(GPIO_LVDS4))
+			{
+				int ret_dir;
+
+				/* Set the GPIO data direction as Input */
+				ret_dir = gpio_direction_input(GPIO_LVDS4);
+				if(ret_dir != 0)
+				{
+					EMGD_DEBUG("Error !!! GPIO library set data direction as input failed.");
+				}				
+			}
+			else
+				EMGD_DEBUG("Error !!! GPIO library is not available or pins are not valid");
+
+			OS_DELAY(hold_time);
+		}
+		else
+			EMGD_DEBUG("Error !!! GPIO Pins are not available for use");
+#else
 		temp = READ_MMIO_REG_TNC(IGD_PORT_LPC, RGIO);
 		temp |= GPIO_DATA;
 		WRITE_MMIO_REG_TNC(IGD_PORT_LPC, RGIO, temp);
+#endif
 	}
 
 	return 0;
diff --git a/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_bitbash_tnc.h b/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_bitbash_tnc.h
new file mode 100644
index 0000000..a1f0aeb
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_bitbash_tnc.h
@@ -0,0 +1,53 @@
+/*
+ *-----------------------------------------------------------------------------
+ * Filename: i2c_bitbash_tnc.h
+ * $Revision: 1.0 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2010, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ * Description:
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+#ifndef _I2C_BITBASH_TNC_H
+#define _I2C_BITBASH_TNC_H
+
+#ifdef USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES
+
+#define GPIO_LVDS0 5
+#define GPIO_LVDS1 6
+#define GPIO_LVDS2 7
+#define GPIO_LVDS3 8
+#define GPIO_LVDS4 9
+
+/* Flag to indicate the GPIO access is claimed or not */
+extern bool global_flag_gpio_claimed;
+
+/* Function to enable GPIO data and clock in RGEN register */
+void enable_gpio_rgen_data_clock_tnc(void);
+
+/* Function to disable GPIO data and clock in RGEN register */
+void disable_gpio_rgen_data_clock_tnc(void);
+#endif
+
+#endif
diff --git a/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_gmbus_tnc.c b/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_gmbus_tnc.c
index ed8cbb9..e7c0dd6 100644
--- a/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_gmbus_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_gmbus_tnc.c
@@ -44,6 +44,11 @@
 
 #include <tnc/regs.h>
 
+#include <linux/gpio.h>
+
+#include "i2c_bitbash_tnc.h"
+#include "../../mode/tnc/micro_mode_tnc.h"
+
 #include "../cmn/i2c_dispatch.h"
 
 /*!
@@ -118,6 +123,26 @@ typedef enum {
 
 } i2c_bus_dir_t;
 
+#ifdef USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES
+
+static struct gpio emgd_lvds_gpios_dir_in[] = {
+/*	{ GPIO_LVDS0, GPIOF_DIR_IN, "emgd_lvds0_in" },
+	{ GPIO_LVDS1, GPIOF_DIR_IN, "emgd_lvds1_in" },
+	{ GPIO_LVDS2, GPIOF_DIR_IN, "emgd_lvds2_in" },
+*/	{ GPIO_LVDS3, GPIOF_DIR_IN, "emgd_lvds3_in" },
+	{ GPIO_LVDS4, GPIOF_DIR_IN, "emgd_lvds4_in" },
+};
+
+static struct gpio emgd_lvds_gpios_dir_out[] = {
+/*	{ GPIO_LVDS0, GPIOF_DIR_OUT, "emgd_lvds0_out" },
+	{ GPIO_LVDS1, GPIOF_DIR_OUT, "emgd_lvds1_out" },
+	{ GPIO_LVDS2, GPIOF_DIR_OUT, "emgd_lvds2_out" },
+*/	{ GPIO_LVDS3, GPIOF_DIR_OUT, "emgd_lvds3_out" },
+	{ GPIO_LVDS4, GPIOF_DIR_OUT, "emgd_lvds4_out" },
+};
+
+#endif
+
 /*.......................................................................... */
 typedef enum {
 
@@ -173,6 +198,7 @@ static int gmbus_wait_event_zero(unsigned long bit);
 static int gmbus_error_handler(void);
 
 /*.......................................................................... */
+
 extern int i2c_read_regs_gpio(
 	igd_context_t *context,
 	unsigned long i2c_bus,
@@ -216,6 +242,7 @@ static int i2c_read_regs_tnc(igd_context_t *context,
 	unsigned long flags)
 {
 	unsigned long slave_addr = 0;
+EMGD_TRACE_ENTER;
 
 	if(i2c_bus == I2C_INT_LVDS_DDC){
 		/*
@@ -223,8 +250,80 @@ static int i2c_read_regs_tnc(igd_context_t *context,
 		 * The i2c_speed is necessary to calculate the hold time. But i2c_bus is not needed.
 		 */
 
-		EMGD_DEBUG("i2c_read_regs_tnc : Using GPIO to read DDC");
-		return i2c_read_regs_gpio(context, i2c_bus, i2c_speed,	dab, reg, buffer, num_bytes, flags);
+		EMGD_DEBUG("Using GPIO to read DDC");
+		int iretval;
+
+#ifdef USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES
+
+		EMGD_DEBUG("Using USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES");
+
+		/* Check whether the RGEN value is already read. If not read and store the value */
+		if(flag_read_rgen_gpio == FALSE)
+		{
+			read_store_gpio_rgen_register();
+		}
+
+		if(flag_lvds_ctrl_gpio_enabled == FALSE)
+		{
+			/* if GPIO is not enabled for LVDS i.e RGEN bits 3 and 4 are not enabled,
+			 * enable them manually, perform the i2c read and then restore back the actual value
+			 */
+
+			/* Enable/Set bit 3(DDC_CLK) & 4(DDC_DATA) of RGEN register to perform I2C */
+			enable_gpio_rgen_data_clock_tnc();
+
+			 /* Claim LVDS GPIO access only if it was not claimed already
+			  * NOTE: don’t free GPIO – After discussion we decided to hold until
+			  * end of OS life. no one should touch this pin
+			  */
+
+			 if(global_flag_gpio_claimed == FALSE)
+			 {
+				 /* check whether the LVDS GPIO pins are valid */
+				 if(gpio_is_valid(GPIO_LVDS0) && gpio_is_valid(GPIO_LVDS1) & gpio_is_valid(GPIO_LVDS2)
+						 && gpio_is_valid(GPIO_LVDS3) && gpio_is_valid(GPIO_LVDS4))
+				 {
+					 EMGD_DEBUG("GPIO pins RGEN4:0 are valid");
+
+					 /* Request for LVDS GPIO lines */
+					 int igpio_retval = gpio_request_array(emgd_lvds_gpios_dir_in, ARRAY_SIZE(emgd_lvds_gpios_dir_in));
+					 if(0 != igpio_retval)
+					 {
+						 EMGD_DEBUG("Error !!! gpio_request_array() failed");
+						 EMGD_DEBUG("Error !!! GPIO library may not be available or enabled");
+
+						 /* Disable bit 3(DDC_CLK) & 4(DDC_DATA) of RGEN register */
+						 disable_gpio_rgen_data_clock_tnc();
+EMGD_TRACE_EXIT
+						 return 1;
+					 }
+					 else
+					 {
+						 EMGD_DEBUG("gpio_request_array() successful");
+						 global_flag_gpio_claimed = TRUE;
+					 }
+				 }
+				 else
+					 EMGD_DEBUG("GPIO pins RGEN4:0 are not valid");
+			 }
+
+			iretval = i2c_read_regs_gpio(context, i2c_bus, i2c_speed,	dab, reg, buffer, num_bytes, flags);
+
+			/* Disable bit 3(DDC_CLK) & 4(DDC_DATA) of RGEN register */
+			disable_gpio_rgen_data_clock_tnc();
+
+			/* Free the requested LVDS GPIO lines */
+			//gpio_free_array(emgd_lvds_gpios_dir_in, ARRAY_SIZE(emgd_lvds_gpios_dir_in));
+		}
+		else
+		{
+#endif
+			iretval = i2c_read_regs_gpio(context, i2c_bus, i2c_speed,	dab, reg, buffer, num_bytes, flags);
+#ifdef USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES
+		}
+#endif
+
+		return iretval;
 
 	} else {
 
@@ -288,6 +387,7 @@ static int i2c_write_reg_list_tnc(igd_context_t *context,
 	unsigned long flags)
 {
 	unsigned long reg_num = 0, ddc_addr = 0, slave_addr = 0;
+EMGD_TRACE_ENTER;
 
 	if(i2c_bus == I2C_INT_LVDS_DDC){
 		/* There are no GMBUS pins for internal LVDS on Atom E6xx.
@@ -296,8 +396,77 @@ static int i2c_write_reg_list_tnc(igd_context_t *context,
 		 *		i2c_bus is not defined
 		 */
 		EMGD_DEBUG("i2c_write_reg_list_tnc : Using GPIO to write DDC");
-		return i2c_write_reg_list_gpio(context, i2c_bus, i2c_speed, dab, reg_list, flags);
 
+		int iretval;
+
+#ifdef USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES
+
+		EMGD_DEBUG("Using USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES");
+
+		/* Check whether the RGEN value is already read. If not read and store the value */
+		if(flag_read_rgen_gpio == FALSE)
+		{
+			read_store_gpio_rgen_register();
+		}
+
+		if(flag_lvds_ctrl_gpio_enabled == FALSE)
+		{
+			/* if GPIO is not enabled for LVDS i.e RGEN bits 3 and 4 are not enabled,
+			 * enable them manually, perform the i2c read and then restore back the actual value
+			 */
+
+			/* Enable/Set bit 3(DDC_CLK) & 4(DDC_DATA) of RGEN register to perform I2C */
+			enable_gpio_rgen_data_clock_tnc();
+
+			/* Claim LVDS GPIO access only if it was not claimed already.
+			 * NOTE: don’t free GPIO – After discussion we decided to hold until
+			 * end of OS life. no one should touch this pin
+			 */
+			if(global_flag_gpio_claimed == FALSE)
+			{
+				/* check whether the LVDS GPIO pins are valid */
+				if(gpio_is_valid(GPIO_LVDS0) && gpio_is_valid(GPIO_LVDS1) & gpio_is_valid(GPIO_LVDS2)
+						&& gpio_is_valid(GPIO_LVDS3) && gpio_is_valid(GPIO_LVDS4))
+				{
+					 EMGD_DEBUG("GPIO pins RGEN4:0 are valid");
+					/* Request for LVDS GPIO lines */
+					if(0 != gpio_request_array(emgd_lvds_gpios_dir_out, ARRAY_SIZE(emgd_lvds_gpios_dir_out)))
+					{
+						EMGD_DEBUG("Error !!! gpio_request_array() failed");
+						EMGD_DEBUG("Error !!! GPIO library may not be available or enabled");
+
+						/* Disable bit 3(DDC_CLK) & 4(DDC_DATA) of RGEN register */
+						disable_gpio_rgen_data_clock_tnc();
+
+						return 1;
+					}
+					else
+					{
+						 EMGD_DEBUG("gpio_request_array() successful");
+						global_flag_gpio_claimed = TRUE;
+					}
+				}
+				else
+					EMGD_DEBUG("GPIO pins RGEN4:0 are not valid");
+			}
+
+			iretval = i2c_write_reg_list_gpio(context, i2c_bus, i2c_speed, dab, reg_list, flags);
+
+			/* Disable bit 3(DDC_CLK) & 4(DDC_DATA) of RGEN register */
+			disable_gpio_rgen_data_clock_tnc();
+
+			/* Free the requested LVDS GPIO lines */
+			//gpio_free_array(emgd_lvds_gpios_dir_out, ARRAY_SIZE(emgd_lvds_gpios_dir_out));
+		}
+		else
+		{
+#endif
+			iretval = i2c_write_reg_list_gpio(context, i2c_bus, i2c_speed, dab, reg_list, flags);
+#ifdef USE_CORRECTED_LVDS_GPIO_OVERLOAD_RULES
+		}
+#endif
+
+		return iretval;
 	} else {
 
 		if (! gmbus_init(i2c_bus, i2c_speed)) {
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.c
index 58927c6..2523414 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.c
@@ -50,6 +50,10 @@
 #include "igd_debug.h"
 #include "splash_screen.h"
 #include "msvdx.h"
+#ifdef DEBUG
+#include "emgd_proc.h"
+#endif
+
 /*
  * Imagination includes.
  */
@@ -81,7 +85,9 @@ extern void emgd_modeset_destroy(struct drm_device *dev);
 extern int  msvdx_pre_init_plb(struct drm_device *dev);
 extern int msvdx_shutdown_plb(igd_context_t *context);
 extern int topaz_shutdown_tnc(igd_context_t *context);
-
+#ifdef DEBUG
+extern int  init_emgd_procfs(void);
+#endif
 extern emgd_drm_config_t config_drm;
 extern int context_count;
 #ifdef SUPPORT_V2G_CAMERA
@@ -336,6 +342,8 @@ static struct drm_ioctl_desc emgd_ioctl[] = {
 		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GMM_FLUSH_CACHE, emgd_gmm_flush_cache,
 		DRM_MASTER|DRM_UNLOCKED),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_SCANLINE, emgd_drm_driver_get_scanline,DRM_UNLOCKED),
+
 	/*
 	 * Externally handled IOCTL's. These are routed to the Imagination Tech
 	 * kernel services.
@@ -1456,6 +1464,10 @@ int emgd_driver_load(struct drm_device *dev, unsigned long flags)
 
 		/* Per the user's request, initialize the display: */
 		emgd_init_display(TRUE, priv);
+
+#ifdef DEBUG
+		init_emgd_procfs();
+#endif
 	}
 
 
@@ -1510,6 +1522,10 @@ int emgd_driver_unload(struct drm_device *dev)
 
 	mutex_lock(&dev->struct_mutex);
 
+#ifdef DEBUG
+	cleanup_emgd_procfs();
+#endif
+
 	/* Unload Buffer Class Module*/
 	emgd_bc_ts_uninit();
 
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.h b/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.h
index 15c88b2..cfc05b0 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.h
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.h
@@ -208,4 +208,5 @@ int emgd_bc_ts_cmd_release_buffers(struct drm_device *dev, void *arg, struct drm
 int emgd_bc_ts_set_buffer_info(struct drm_device *dev, void *arg, struct drm_file *file_priv);
 int emgd_bc_ts_get_buffers_count(struct drm_device *dev, void *arg, struct drm_file *file_priv);
 int emgd_bc_ts_get_buffer_index(struct drm_device *dev, void *arg, struct drm_file *file_priv);
+int emgd_drm_driver_get_scanline(struct drm_device *dev, void *arg, struct drm_file *file_priv);
 #endif
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_fbcon.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_fbcon.c
index 552e39b..f267fcf 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_fbcon.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_fbcon.c
@@ -714,17 +714,12 @@ static int emgd_fbcon_blank(int blank, struct fb_info *info)
  */
 int emgd_fbcon_initial_config(emgd_fbdev_t *emgd_fbdev)
 {
-	int                    i, j, err;
+	int                    err;
 	unsigned long         *dc_assigned;
 	igd_context_t         *context;
 	unsigned short         port_number;
 	emgd_crtc_t           *emgd_crtc;
 	struct drm_crtc       *crtc         = NULL;
-	igd_param_t           *params = NULL;
-	igd_display_params_t  *display_params = NULL;
-	igd_display_info_t    *dtd = NULL;
-	int port_num          = 0;
-	int dot_clock         = -1;
 	igd_display_context_t *primary      = NULL, *secondary = NULL;
 	bool                   mode_set_ret = FALSE;
 	struct drm_device     *dev          = emgd_fbdev->priv->ddev;
@@ -812,53 +807,7 @@ int emgd_fbcon_initial_config(emgd_fbdev_t *emgd_fbdev)
 			emgd_fbdev->priv->fbdev->fix.id);
 	}
 
-	/* Consider module parameter configid when selecting the hal params */
-	if (drm_emgd_configid < 0) {
-                params = config_drm.hal_params[0];
-        } else {
-                params = config_drm.hal_params[drm_emgd_configid-1];
-        }
-
-	/* Select the dot clock from the display port order list.
-	 * The port_order array has default values which can be overriden
-	 * by the module parameter. Use the dot-clock value from the first
-	 * port number specified in the port_order array.
-	 */
-	display_params = params->display_params;
-	for (i = 0; i < IGD_MAX_PORTS; i++) {
-		port_num = params->port_order[i];
-		if (!(port_num >= 0 && port_num < IGD_MAX_PORTS)) {
-			EMGD_ERROR("Display port number %d out of scope,"
-				"fail to set dot-clock for CRTC!\n", port_num);
-			dot_clock = -1;
-			goto set_mode;
-		}
-		for (j = 0; j < IGD_MAX_PORTS; j++) {
-			if (port_num == display_params[j].port_number) {
-				if ((dtd = display_params[j].dtd_list.dtd)) {
-					/* We have got a valid dot-clock from
-					 * the spcified port number, use it.
-					 * Depends on the fact that the display
-					 * ports are not used at the same time.
-					 */
-					dot_clock = dtd->dclk;
-					goto set_mode;
-				} else {
-					EMGD_ERROR("Display port %d "
-					 "has no valid DTD entry\n", port_num);
-					dot_clock = -1;
-					goto set_mode;
-				}
-			}
-		}
-	}
-
-	/* Warn loudly when there is no dot-clock available for use */
-	if (dot_clock < 0) {
-		EMGD_ERROR("No valid dot-clock available for CRTC!\n");
-	}
 
-set_mode:
 	/*******************************************************
 	 * Set Mode for Primary
 	 ******************************************************/
@@ -872,9 +821,6 @@ set_mode:
 			primary_mode.crtc_vdisplay = config_drm.height;
 			primary_mode.vrefresh      = config_drm.refresh;
 
-			if (dot_clock > 0)
-				primary_mode.clock = dot_clock;
-
 			mode_set_ret = drm_crtc_helper_set_mode(crtc,
 								&primary_mode,
 								0, 0,
@@ -904,9 +850,6 @@ set_mode:
 				secondary_mode.crtc_vdisplay = config_drm.height;
 				secondary_mode.vrefresh      = config_drm.refresh;
 
-				if (dot_clock > 0)
-					secondary_mode.clock = dot_clock;
-
 				mode_set_ret = drm_crtc_helper_set_mode(crtc,
 								&secondary_mode,
 								0, 0,
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_interface.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_interface.c
index 5625442..0130ff5 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_interface.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_interface.c
@@ -63,6 +63,9 @@
 
 #include "pvrversion.h"
 
+#include <context.h>
+#include <utils.h>
+
 /* Turn on tracing for this file only */
 /*
 #undef EMGD_TRACE_ENTER
@@ -196,6 +199,29 @@ int do_wait_vblank(void *display, int headline, int footline)
 }
 
 /*!
+ * IOCTL to read current scanline from pipe register.
+ */
+int emgd_drm_driver_get_scanline(struct drm_device *dev, void *arg,
+	struct drm_file *file_priv)
+{
+	unsigned long reg;
+	emgd_drm_driver_get_scanline_t *get_scanline = (emgd_drm_driver_get_scanline_t *)arg;
+	igd_display_h display;
+	igd_context_t *context = (igd_context_t *) handle;
+
+	get_scanline->rtn = 0;
+	get_scanline->scanline = 0;
+
+	// customer care lvds only	
+	context->mod_dispatch.dsp_get_display(IGD_PORT_TYPE_LVDS, (igd_display_context_t **)&display, NULL, 0);
+
+	reg = PIPE(display)->pipe_reg - 0x8;
+	get_scanline->scanline = READ_MMIO_REG_TNC(PORT_TYPE_DH(display), reg) & 0xfff;
+
+	return 0;
+} /* emgd_drm_driver_get_scanline() */
+
+/*!
  * IOCTL to bridge the IAL to the HAL's wait_vblank() procedure.
  */
 int emgd_wait_vblank(struct drm_device *dev, void *arg,
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_proc.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_proc.c
new file mode 100755
index 0000000..f243e38
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_proc.c
@@ -0,0 +1,972 @@
+/*
+ *-----------------------------------------------------------------------------
+ * Filename: emgd_proc.c
+ * $Revision: 1.147 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2010, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ * Description:
+ *  The main part of the kernel module.  This part gets everything going and
+ *  connected, and then the rest can function.
+ *-----------------------------------------------------------------------------
+ */
+
+
+
+#include <igd_debug.h>
+#include <drmP.h>
+#include <memlist.h>
+#include <io.h>
+#include <memory.h>
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <asm/agp.h>
+#include "igd_gmm.h"
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+
+#if 1 /* chenm */
+#include "drmP.h"
+#include "drm.h"
+
+#include "drm_emgd_private.h"
+#include "emgd_drm.h"
+#include "emgd_drv.h"
+#include "memory.h"
+
+#include "module_init.h"
+#include "mode_dispatch.h"
+#include "ovl_dispatch.h"
+#include "ovl_virt.h"
+#include "msvdx.h"
+#include "topaz.h"
+
+#include "memmap.h"
+#include "sched.h"
+
+#include "services.h"
+#include "perproc.h"
+#include "pvr_bridge_km.h"
+#include "syscommon.h"
+#include "pvr_drm.h"
+
+#include <linkage.h>
+
+#include "pvrversion.h"
+
+ #include <io.h>
+
+ #include <igd.h>
+ #include <igd_pwr.h>
+
+ #include <context.h>
+ #include <mode.h>
+ #include <utils.h>
+ #include <dsp.h>
+ #include <intelpci.h>
+ #include <mode_access.h>
+ #include <rb.h>
+ #include <pi.h>
+ #include <math_fix.h>
+
+ #include <tnc/regs.h>
+ #include <tnc/context.h>
+ #include <tnc/mi.h>
+ #include <tnc/instr.h>
+ #include <tnc/cmd.h>
+
+ #include "drm_emgd_private.h"
+ #include "../cmn/match.h"
+ #include "../cmn/mode_dispatch.h"
+
+ #include "emgd_shared.h"
+ #include <linux/interrupt.h>
+ #include <linux/spinlock.h>
+ #include <drm/drmP.h>
+
+ #include <emgd_drm.h>
+
+ #include "pvr_bridge_km.h"
+ #endif
+
+#define PROC_NAME "emgd"
+
+static struct proc_dir_entry *emgd_dir, *surface_file, *dump_surface_file, *list_surface_file, *symlink;
+static struct proc_dir_entry *displayinfo_file;
+
+extern gmm_context_t gmm_context;
+
+static unsigned int AtoI(char *szIn);
+static int whitespace(unsigned char * currChar);
+static int parse_arg(unsigned char * arg, int * argcount, unsigned char ** argvector);
+static void free_arg(int argcount, unsigned char ** argvector);
+static void fillcolor(void * addr, size_t length, unsigned int color);
+static void fillRect(void * addr, unsigned int x, unsigned int y, unsigned int w, unsigned int h, unsigned int sizeX, unsigned int sizeY, unsigned int color);
+static void print_string(char *str);
+
+unsigned char bmpheader[54];
+#define BMHEADER (0)
+#define BMHEADER_BYTES (2)
+#define FILESIZE (BMHEADER + BMHEADER_BYTES)
+#define FILESIZE_BYTES (4)
+#define RESERVED0_1 (FILESIZE + FILESIZE_BYTES)
+#define RESERVED0_1_BYTES (2)
+#define RESERVED0_2 (RESERVED0_1 + RESERVED0_1_BYTES)
+#define RESERVED0_2_BYTES (2)
+#define DATAOFFSET (RESERVED0_2 + RESERVED0_2_BYTES)
+#define DATAOFFSET_BYTES (4)
+#define HEADERSIZE (DATAOFFSET + DATAOFFSET_BYTES)
+#define HEADERSIZE_BYTES (4)
+#define BMPWIDTH (HEADERSIZE + HEADERSIZE_BYTES)
+#define BMPWIDTH_BYTES (4)
+#define BMPHEIGHT (BMPWIDTH + BMPWIDTH_BYTES)
+#define BMPHEIGHT_BYTES (4)
+#define BMPPLANE (BMPHEIGHT + BMPHEIGHT_BYTES)
+#define BMPPLANE_BYTES (2)
+#define BITSPIXEL (BMPPLANE + BMPPLANE_BYTES)
+#define BITSPIXEL_BYTES (2)
+#define COMPRESSED (BITSPIXEL + BITSPIXEL_BYTES)
+#define COMPRESSED_BYTES (4)
+#define DATASIZE (COMPRESSED + COMPRESSED_BYTES)
+#define DATASIZE_BYTES (4)
+#define HRESOLUTION (DATASIZE + DATASIZE_BYTES)
+#define HRESOLUTION_BYTES (4)
+#define VRESOLUTION (HRESOLUTION + HRESOLUTION_BYTES)
+#define VRESOLUTION_BYTES (4)
+#define INDEXS (VRESOLUTION + VRESOLUTION_BYTES)
+#define INDEXS_BYTES (4)
+#define IMPORTANT_INDEXS (INDEXS + INDEXS_BYTES)
+#define IMPORTANT_INDEXS_BYTES (4)
+
+
+#define MAX_PARAMS (10)
+
+typedef enum {
+	CMD_PARSE_START,
+	CMD_PARSE_WHITESPACE,
+	CMD_PARSE_CMDCHAR,
+	CMD_PARSE_END
+} cmd_parse;
+
+int
+surface_proc_show(struct seq_file *m, void *v)
+{
+	int ret;
+	int len = 0;
+	int count = 1;
+	gmm_chunk_t *chunk = NULL;
+	char buf[512];
+	char usage[64];
+
+
+
+
+
+
+		sprintf(buf ," Surface list:\n No.  Offset         Size             Pages    Phys St. \n ==================================================================================\n");
+		seq_puts(m, buf);
+
+		chunk = gmm_context.head_chunk;
+
+		while (chunk){
+
+			if (chunk->usage == INUSE_ALLOCATED)
+							sprintf(usage, "INUSE_ALLOCATED");
+							else
+							if (chunk->usage  == FREE_ALLOCATED)
+								sprintf(usage,"FREE_ALLOCATED");
+							else
+							if (chunk->usage  == INUSE_IMPORTED)
+								sprintf(usage,"INUSE_IMPORTED");
+							else
+							if (chunk->usage  == FREE_IMPORTED)
+								sprintf(usage,"FREE_IMPORTED");
+							else
+								sprintf(usage,"UNKNOWN");
+
+			sprintf(buf,"%3d - 0x%-10x %8d(%4d KB)  %-4d     0x%-8x    %s    %s\n",count,  chunk->offset,  chunk->size, chunk->size/1024, chunk->pages, chunk->gtt_mem != NULL ? chunk->gtt_mem->physical: 0, usage, chunk->type==AGP_NORMAL_MEMORY? "AGP_NORMAL_MEMORY": "AGP_PHY_MEMORY");
+			seq_puts(m, buf);
+
+
+				/*seq_puts(m, buf);
+				 sprintf(buf, "    %s\n", 1==1? "AGP_NORMAL_MEMORY": "AGP_PHY_MEMORY");
+				 seq_puts(m, buf);*/
+
+			chunk = chunk->next;
+			count = count + 1;
+		}
+
+	//sprintf(buffer, "*** %d,  %d  %d %d*** \n", len, buffer_length, offset, *eof);
+	return len;
+}
+
+static int surface_seq_open (struct inode *inode, struct file *file)
+{
+  return single_open (file, surface_proc_show, NULL);
+}
+
+static struct file_operations surface_seq_fops = {
+		  .open = surface_seq_open,
+		  .read = seq_read,
+		   .llseek = seq_lseek,
+		  .release = single_release,
+		};
+
+ssize_t surface_dump_procfile_write( struct file *filp, const char __user *buff,
+                        unsigned long len, void *data )
+{
+	int w_dump;
+	int h_dump;
+	int row;
+	int col;
+	unsigned int length;
+	unsigned char * pBase;	
+	unsigned char * pPixel;
+	mm_segment_t old_fs;
+	struct file *dump_file = NULL;
+	char tmp_inbuf[512];
+	char tmp_outbuf[512];
+	struct timeval log_time;
+	unsigned long surface_offset;
+
+	gmm_chunk_t *chunk = gmm_context.head_chunk;
+
+	int argcount;
+	unsigned char * argvector[MAX_PARAMS];
+	int i;
+	unsigned char printbuf[512];
+
+	if (len >= 512) {
+		printk(KERN_INFO "more than 1000 input\n");
+		return -ENOSPC;
+	}
+
+	if (len == 0) {
+		printk(KERN_INFO "no input\n");
+		return -ENOSPC;
+	}
+
+	if (copy_from_user(tmp_inbuf, buff, len )) {
+		return -EFAULT;
+	}
+
+	tmp_inbuf[len] = NULL;
+
+	printk("tmp_inbuf : %s\n", tmp_inbuf);
+
+	parse_arg(tmp_inbuf, &argcount, argvector);
+
+#if 0
+	for (i = 0; i < argcount; i++) {
+		sprintf(printbuf, "i = %d, arg = \"%s\"", i, argvector[i]);
+		print_string(printbuf);
+	}
+#endif
+
+	if (strcmp(argvector[0], "rawdump") == 0) {
+		surface_offset = (unsigned long)AtoI(argvector[1]);
+		printk("dump_surface_procfile_write offset = 0x%07x\n", surface_offset);
+		w_dump = AtoI(argvector[2]);
+		h_dump = AtoI(argvector[3]);
+
+		/* dump raw *//* ARGB_8888 */
+		while (chunk){
+
+			if (surface_offset != chunk->offset) {
+				chunk = chunk->next;
+				continue;
+			}
+
+			old_fs = get_fs();
+			set_fs(KERNEL_DS);
+
+			pBase = chunk->addr;
+
+			sprintf(tmp_outbuf, argvector[4], surface_offset, log_time.tv_sec, log_time.tv_usec, w_dump, h_dump);
+			dump_file = filp_open(tmp_outbuf, O_CREAT | O_RDWR, 0);
+			if(dump_file == NULL){
+				printk("create dump file failed\n");
+			}
+
+			for (row = 0; row <  h_dump; row++) {
+				for (col = 0; col <  w_dump; col++)
+				{
+
+					pPixel = pBase + row * (w_dump) * 4 + col * 4;
+					vfs_write(dump_file, pPixel, 4, &dump_file->f_pos);
+				}
+			}
+
+			filp_close(dump_file, NULL);
+			set_fs(old_fs);
+
+			/* it seems chunks form a ring, so must break to avoid endless loop */
+			break;
+
+		}
+	} else if (strcmp(argvector[0], "rawwrite") == 0) {
+		surface_offset = (unsigned long)AtoI(argvector[1]);
+		printk("dump_surface_procfile_write offset = 0x%07x\n", surface_offset);
+		w_dump = AtoI(argvector[2]);
+		h_dump = AtoI(argvector[3]);
+		length = w_dump * h_dump * 4;
+
+		while (chunk){
+
+			if (surface_offset != chunk->offset) {
+				chunk = chunk->next;
+				continue;
+			}
+
+			old_fs = get_fs();
+			set_fs(KERNEL_DS);
+
+			pBase = chunk->addr;
+
+			sprintf(tmp_outbuf, argvector[4], surface_offset, log_time.tv_sec, log_time.tv_usec, w_dump, h_dump);
+			dump_file = filp_open(tmp_outbuf, O_CREAT | O_RDWR, 0);
+			if(dump_file == NULL){
+				printk("create dump file failed\n");
+			}
+
+			for (row = 0; row <  h_dump; row++) {
+				for (col = 0; col <  w_dump; col++)
+				{
+
+					pPixel = pBase + row * (w_dump) * 4 + col * 4;
+					vfs_read(dump_file, pPixel, 4, &dump_file->f_pos);
+				}
+			}
+
+			filp_close(dump_file, NULL);
+			set_fs(old_fs);
+
+			break;
+
+		}
+
+	} else if (strcmp(argvector[0], "colorfill") == 0) {
+		int red =  (0xFF << 24) | (0xFF << 16);
+		int green =  (0xFF << 24) | (0xFF << 8);
+		int blue =  (0xFF << 24) | (0xFF);
+
+		int x;
+		int y;
+		int w;
+		int h;
+		int sizeX;
+		int sizeY;
+
+		/* echo "colorfill 0x4000000 0 0 1280 720 1280 720 red" > /proc/emgd/surfacesdump */
+
+		surface_offset = (unsigned long)AtoI(argvector[1]);
+		
+		x = AtoI(argvector[2]);
+		y = AtoI(argvector[3]);
+		w = AtoI(argvector[4]);
+		h = AtoI(argvector[5]);
+		sizeX = AtoI(argvector[6]);
+		sizeY = AtoI(argvector[7]);
+
+		while (chunk){
+
+			if (surface_offset != chunk->offset) {
+				chunk = chunk->next;
+				continue;
+			}
+
+			pBase = chunk->addr;
+			if (strcmp(argvector[8], "red") == 0) {
+				//fillcolor(pBase, length, red);
+				fillRect(pBase, x, y, w, h, sizeX, sizeY, red);
+			} else if (strcmp(argvector[8], "green") == 0) {
+				//fillcolor(pBase, length, green);
+				fillRect(pBase, x, y, w, h, sizeX, sizeY, green);
+			} else { // if (strcmp(argv[8], "blue") == 0) {
+				fillcolor(pBase, length, blue);
+				fillRect(pBase, x, y, w, h, sizeX, sizeY, blue);
+			}
+
+			break;
+		}
+
+	} else if (strcmp(argvector[0], "ppmdump") == 0) {
+
+		surface_offset = (unsigned long)AtoI(argvector[1]);
+		printk("dump_surface_procfile_write offset = 0x%07x\n", surface_offset);
+		w_dump = AtoI(argvector[2]);
+		h_dump = AtoI(argvector[3]);
+		length = w_dump * h_dump * 4;
+
+		while (chunk){
+
+			if (surface_offset != chunk->offset) {
+				printk("next chunk !\n");
+				chunk = chunk->next;
+				continue;
+			}
+
+			old_fs = get_fs();
+			set_fs(KERNEL_DS);
+
+			pBase = chunk->addr;
+
+			sprintf(tmp_outbuf, argvector[4], surface_offset, log_time.tv_sec, log_time.tv_usec, w_dump, h_dump);
+			dump_file = filp_open(tmp_outbuf, O_CREAT | O_RDWR, 0);
+			if(dump_file == NULL){
+				printk("create dump file failed\n");
+			}
+
+			vfs_write(dump_file, "P6\n", strlen("P6\n"), &dump_file->f_pos);
+			sprintf(tmp_outbuf, "%d %d\n", w_dump, h_dump);
+			vfs_write(dump_file, tmp_outbuf, strlen(tmp_outbuf), &dump_file->f_pos);
+			vfs_write(dump_file, "255\n", strlen("255\n"), &dump_file->f_pos);
+
+			for (row = 0; row <  h_dump; row++) {
+				for (col = 0; col <  w_dump; col++)
+				{
+					pPixel = pBase + row * (w_dump) * 4 + col * 4;
+					vfs_write(dump_file, pPixel + 1, 3, &dump_file->f_pos);
+				}
+			}
+
+			filp_close(dump_file, NULL);
+			set_fs(old_fs);
+
+			print_string("file dumped!");
+			break;
+
+		}
+
+	} else if (strcmp(argvector[0], "bmpdump") == 0) {
+		surface_offset = (unsigned long)AtoI(argvector[1]);
+		printk("dump_surface_procfile_write offset = 0x%07x\n", surface_offset);
+		w_dump = AtoI(argvector[2]);
+		h_dump = AtoI(argvector[3]);
+		length = w_dump * h_dump * 4;
+
+		while (chunk){
+
+			if (surface_offset != chunk->offset) {
+				chunk = chunk->next;
+				continue;
+			}
+
+			old_fs = get_fs();
+			set_fs(KERNEL_DS);
+
+			pBase = chunk->addr;
+
+			sprintf(tmp_outbuf, argvector[4], surface_offset, log_time.tv_sec, log_time.tv_usec, w_dump, h_dump);
+			dump_file = filp_open(tmp_outbuf, O_CREAT | O_RDWR, 0);
+			if(dump_file == NULL){
+				printk("create dump file failed\n");
+			}
+
+			unsigned long filesize;
+			unsigned long dataoffset;
+			unsigned long headersize;
+			unsigned long bmpwidth;
+			unsigned long bmpheight;
+			unsigned short plane;
+			unsigned short bitspixel;
+			unsigned long datasize;
+			int row_size; 
+
+			/* assume little endian */
+			memset(bmpheader, 0, sizeof(bmpheader));
+			memcpy(&bmpheader[BMHEADER], "BM", BMHEADER_BYTES);
+			filesize = sizeof(bmpheader) + w_dump * h_dump * 3;
+			memcpy(&bmpheader[FILESIZE], &filesize, FILESIZE_BYTES);
+			dataoffset = sizeof(bmpheader);
+			memcpy(&bmpheader[DATAOFFSET], &dataoffset, DATAOFFSET_BYTES);
+			headersize = 40;
+			memcpy(&bmpheader[HEADERSIZE], &headersize, HEADERSIZE_BYTES);
+			bmpwidth = w_dump;
+			memcpy(&bmpheader[BMPWIDTH], &bmpwidth, BMPWIDTH_BYTES);
+			bmpheight = 0 - h_dump;
+			memcpy(&bmpheader[BMPHEIGHT], &bmpheight, BMPHEIGHT_BYTES);
+			plane = 1;
+			memcpy(&bmpheader[BMPPLANE], &plane, BMPPLANE_BYTES);
+			bitspixel = 24; /* RGB 3 bytes, 24 bits */
+			memcpy(&bmpheader[BITSPIXEL], &bitspixel, BITSPIXEL_BYTES);
+			/* no compressed */
+
+			row_size = w_dump * 3;
+			/* (row need to be  Multiples of 4) * h_dump */
+			datasize = ((row_size % 4) ? (row_size + 4 - (row_size % 4)) : row_size) * h_dump;
+			memcpy(&bmpheader[DATASIZE], &datasize, DATASIZE_BYTES);
+
+			/* write header */
+			vfs_write(dump_file, bmpheader, sizeof(bmpheader), &dump_file->f_pos);
+
+			for (row = 0; row <  h_dump; row++) {
+				for (col = 0; col <  w_dump; col++)
+				{
+
+					pPixel = pBase + row * (w_dump) * 4 + col * 4;
+					vfs_write(dump_file, pPixel + 3, 1, &dump_file->f_pos);
+					vfs_write(dump_file, pPixel + 2, 1, &dump_file->f_pos);
+					vfs_write(dump_file, pPixel + 1, 1, &dump_file->f_pos);
+				}
+				/* fill bytes for mutiples of 4 */
+				if (row_size % 4) {
+					vfs_write(dump_file, "000", 4 - (row_size % 4), &dump_file->f_pos);
+				}
+			}
+
+			filp_close(dump_file, NULL);
+			set_fs(old_fs);
+
+			break;
+
+		}
+	} else {
+		// test branch
+		print_string("this is test branch!");
+
+	}
+
+	free_arg(argcount, argvector);
+
+	return len;
+}
+
+static void print_string(char *str)
+{
+    struct tty_struct *my_tty;
+    my_tty = current->signal->tty;
+    if (my_tty != NULL)
+    {
+        my_tty->driver->ops->write(my_tty, str, strlen(str));
+        my_tty->driver->ops->write(my_tty, "\015\013", 2);
+    }
+}
+
+
+
+ssize_t list_surface_procfile_write( struct file *filp, const char __user *buff,
+                        unsigned long len, void *data )
+{
+	unsigned char tmp[128];
+	unsigned long surface_offset;
+	gmm_chunk_t *chunk = gmm_context.head_chunk;
+	unsigned long last_phys;
+	unsigned long curr_phys;
+	unsigned int pages_count;
+
+	if (len > 10) {
+		printk(KERN_INFO "too many args!\n");
+		return -ENOSPC;
+	}
+	if (copy_from_user( tmp	, buff, len )) {
+		return -EFAULT;
+	}
+
+	sscanf(tmp, "0x%7x", &surface_offset);
+	sprintf(tmp, "offset 0x%08x", surface_offset);
+	print_string(tmp);
+
+	while (chunk){
+		int i;
+
+		if (surface_offset != chunk->offset) {
+			chunk = chunk->next;
+			continue;
+		}
+
+		sprintf(tmp, "page_count %d", chunk->gtt_mem->page_count);
+		print_string(tmp);
+		for (i = 0; i < chunk->gtt_mem->page_count; i++) {
+			curr_phys = page_to_phys(chunk->gtt_mem->pages[i]);
+			if (i == 0) {
+				last_phys = curr_phys;
+				sprintf(tmp, "start 0x%08x", last_phys);
+				print_string(tmp);
+				pages_count = 1;
+			} else if (0 < i && i < chunk->gtt_mem->page_count - 1) {
+				if (last_phys + PAGE_SIZE == curr_phys) {
+					last_phys = curr_phys;
+					pages_count++;
+				} else {
+					sprintf(tmp, "end 0x%08x, pages %d", last_phys, pages_count);
+					print_string(tmp);
+					last_phys = curr_phys;
+					sprintf(tmp, "start 0x%08x", last_phys);
+					print_string(tmp);
+					pages_count = 1;
+				}
+			} else {
+				// i == chunk->gtt_mem->page_count
+				if (last_phys + PAGE_SIZE == curr_phys) {
+					last_phys = curr_phys;
+					pages_count++;
+					sprintf(tmp, "end 0x%08x, pages %d", last_phys, pages_count);
+					print_string(tmp);
+				} else {
+					last_phys = curr_phys;
+					sprintf(tmp, "start 0x%08x", last_phys);
+					print_string(tmp);
+					sprintf(tmp, "end 0x%08x, pages %d", last_phys, 1);
+					print_string(tmp);
+				}	
+			}
+		}	
+
+		break;
+	}
+
+	//print_string("hello");
+
+	return len;
+}
+
+ssize_t list_surface_procfile_read( char *page, char **start, off_t off,
+              int count, int *eof, void *data )
+{
+	int len;
+
+	len = sprintf(page, "%02X\n", 0xFE);
+	return len;
+}
+
+ssize_t displayinfo_procfile_read( char *page, char **start, off_t off,
+              int count, int *eof, void *data )
+{
+	int len = 0;
+	igd_display_context_t * display;
+	igd_display_pipe_t * pipe;
+	unsigned long plane_reg;
+	int i;
+
+	*page = NULL;
+
+	for (i = 0; i < OVL_MAX_HW; i++) {
+		display = ovl_context->ovl_display_km[i];
+		pipe = PIPE(display);
+		plane_reg = PLANE(display)->plane_reg;
+
+		len += sprintf(page + len, "display handle : 0x%08x\n", display);
+		len += sprintf(page + len, "display->context : 0x%08x\n", display->context);
+		len += sprintf(page + len, "display->plane : 0x%08x\n", display->plane);
+		len += sprintf(page + len, "display->pipe : 0x%08x\n", display->pipe);
+		len += sprintf(page + len, "display->port : 0x%08x\n", display->port);
+		len += sprintf(page + len, "display->port_number : 0x%08x\n", display->port_number);
+
+		len += sprintf(page + len, "pipe->pipe_num : 0x%08x\n", pipe->pipe_num);
+		len += sprintf(page + len, "pipe->pipe_reg : 0x%08x\n", pipe->pipe_reg);
+		len += sprintf(page + len, "pipe->timing_reg : 0x%08x\n", pipe->timing_reg);
+		len += sprintf(page + len, "pipe->palette_reg : 0x%08x\n", pipe->palette_reg);
+		len += sprintf(page + len, "pipe->plane : 0x%08x\n", pipe->plane);
+		len += sprintf(page + len, "pipe->owner : 0x%08x\n", pipe->owner);
+
+		len += sprintf(page + len, "PLANE(display)->fb_info->fb_base_offset : 0x%08x\n", PLANE(display)->fb_info->fb_base_offset);
+		len += sprintf(page + len, "PLANE(display)->fb_info->visible_offset : 0x%08x\n", PLANE(display)->fb_info->visible_offset);
+		len += sprintf(page + len, "visible_offset reg : 0x%08x\n", EMGD_READ32(MMIO(display) + plane_reg + DSP_LINEAR_OFFSET));
+		len += sprintf(page + len, "offset reg : 0x%08x\n", EMGD_READ32(MMIO(display) + plane_reg + DSP_START_OFFSET));
+	}
+
+	len += sprintf(page + len, "=======print port order====\n");
+	extern emgd_drm_config_t config_drm;
+	igd_param_t *params;
+	if (drm_emgd_configid < 0) {
+		params = config_drm.hal_params[0];
+	} else {
+		params = config_drm.hal_params[drm_emgd_configid-1];
+	}
+
+	for (i = 0 ; i < IGD_MAX_PORTS ; i++) {
+		len += sprintf(page + len, "params->port_order[%d] : 0x%08x\n", i, params->port_order[i]);
+		len += sprintf(page + len, "params->display_params[%d].port_number : 0x%08x\n", i,  params->display_params[i].port_number);
+	}
+
+	return len;
+}
+
+ int  init_emgd_procfs(void)
+{
+        int rv = 0;
+
+        /* create directory */
+        emgd_dir = proc_mkdir(PROC_NAME, NULL);
+        if(emgd_dir == NULL) {
+                rv = -ENOMEM;
+                goto out;
+        }
+
+     //   emgd_dir->owner = THIS_MODULE;
+
+        /* create jiffies using convenience function */
+        surface_file = create_proc_entry("surfaces",
+                                              0444, emgd_dir);
+
+        if(surface_file == NULL) {
+                rv  = -ENOMEM;
+                goto no_surface;
+        }
+
+       // surface_file->owner = THIS_MODULE;
+
+        surface_file->proc_fops = &surface_seq_fops;
+        //surface_file->read_proc = surface_procfile_read;
+
+
+	dump_surface_file = create_proc_entry("surfacesdump",
+                                              0222, emgd_dir);
+	dump_surface_file->write_proc = surface_dump_procfile_write;
+	dump_surface_file->read_proc = NULL;
+
+	list_surface_file = create_proc_entry("listsurface",
+                                              0622, emgd_dir);
+	list_surface_file->write_proc = list_surface_procfile_write;
+	list_surface_file->read_proc = list_surface_procfile_read;
+
+	displayinfo_file = create_proc_entry("displayinfo",
+                                              0222, emgd_dir);
+	displayinfo_file->read_proc = displayinfo_procfile_read;
+
+        /* everything OK */
+        printk(KERN_INFO "%s initialized\n",
+        		PROC_NAME);
+        return 0;
+
+no_surface:
+        remove_proc_entry(PROC_NAME, NULL);
+out:
+        return rv;
+}
+
+
+ void  cleanup_emgd_procfs(void)
+ {
+ 
+         remove_proc_entry("dump_surfaces", emgd_dir);
+         remove_proc_entry("surfaces", emgd_dir);
+         remove_proc_entry(PROC_NAME, NULL);
+
+ }
+
+/* parse parameters */
+unsigned int AtoI(char *szIn)
+{
+	int		iLen = 0;
+	unsigned int	ui32Value = 0;
+	unsigned int	ui32Digit=1;
+	unsigned int	ui32Base=10;
+	int		iPos;
+	char	bc;
+
+
+	while (szIn[iLen] > 0)
+	{
+		iLen ++;
+	}
+
+
+	if (iLen == 0)
+	{
+		return (0);
+	}
+
+
+	iPos=0;
+	while (szIn[iPos] == '0')
+	{
+		iPos++;
+	}
+	if (szIn[iPos] == '\0')
+	{
+		return 0;
+	}
+	if (szIn[iPos] == 'x' || szIn[iPos] == 'X')
+	{
+		ui32Base=16;
+		szIn[iPos]='0';
+	}
+
+
+	for (iPos = iLen - 1; iPos >= 0; iPos --)
+	{
+		bc = szIn[iPos];
+
+		if ( (bc >= 'a') && (bc <= 'f') && ui32Base == 16)
+		{
+			bc -= 'a' - 0xa;
+		}
+		else
+		if ( (bc >= 'A') && (bc <= 'F') && ui32Base == 16)
+		{
+			bc -= 'A' - 0xa;
+		}
+		else
+		if ((bc >= '0') && (bc <= '9'))
+		{
+			bc -= '0';
+		}
+		else
+			return (0);
+
+		ui32Value += (unsigned int)bc  * ui32Digit;
+
+		ui32Digit = ui32Digit * ui32Base;
+	}
+	return (ui32Value);
+}
+
+static int whitespace(unsigned char * currChar)
+{
+	int ret = 0;
+	if (' ' == *currChar) ret = 1;
+	if ('\t' == *currChar) ret = 1;
+	if ('\n' == *currChar) ret = 1;
+
+	return ret;
+}
+
+static int parse_arg(unsigned char * arg, int * argcount, unsigned char ** argvector)
+{
+
+	unsigned int len = strlen(arg);
+	unsigned char * pCurrChar = arg;
+
+	unsigned int left_len = len;
+	cmd_parse parse = CMD_PARSE_START;
+	int cmd_len = 0;
+	unsigned char * cmd_char = NULL;
+
+	int i;
+
+	/* 0 < len < 1000 */
+
+	*argcount = 0;
+
+	while(parse != CMD_PARSE_END)
+	{
+		switch (parse) {
+			case CMD_PARSE_START:
+				parse = CMD_PARSE_WHITESPACE;
+				continue;
+			case CMD_PARSE_WHITESPACE:
+				if (left_len == 0) {
+					parse = CMD_PARSE_END;
+					break;
+				}
+				if (whitespace(pCurrChar)) {
+					//parse = CMD_PARSE_WHITESPACE;
+					pCurrChar++;
+					left_len--;
+				} else {
+					*argcount = *argcount + 1;
+					cmd_len = 1;
+					cmd_char = pCurrChar;
+
+					parse = CMD_PARSE_CMDCHAR;
+					pCurrChar++;
+					left_len--;
+				}
+				continue;
+			case CMD_PARSE_CMDCHAR:
+				if (left_len == 0) {
+					argvector[*argcount - 1] = kmalloc(cmd_len + 1, GFP_KERNEL);
+					memset(argvector[*argcount - 1], 0, cmd_len + 1);
+					memcpy(argvector[*argcount - 1], cmd_char, cmd_len);
+
+					parse = CMD_PARSE_END;
+					break;
+				}
+
+				if (whitespace(pCurrChar)) {
+					argvector[*argcount - 1] = kmalloc(cmd_len + 1, GFP_KERNEL);
+					memset(argvector[*argcount - 1], 0, cmd_len + 1);
+					memcpy(argvector[*argcount - 1], cmd_char, cmd_len);
+					cmd_len = 0;
+					cmd_char = NULL;
+
+					parse = CMD_PARSE_WHITESPACE;
+					pCurrChar++;
+					left_len--;
+				} else {
+					//parse = CMD_PARSE_CMDCHAR;
+					pCurrChar++;
+					left_len--;
+					cmd_len++;
+				}
+				continue;
+			default:
+				break;
+		}
+	}
+
+	return 0;
+
+}
+
+static void free_arg(int argcount, unsigned char ** argvector)
+{
+	int i;
+
+	for (i = 0; i < argcount; i++)
+	{
+		kfree(argvector[i]);
+	}
+}
+
+static void fillcolor(void * addr, size_t length, unsigned int color)
+{
+	size_t offset = 0;
+
+	if (0 != length % 4) {
+		return;
+	}
+
+	while (offset < length) {
+		*(unsigned int *)(addr + offset) = color;
+		offset += 4;
+	}
+
+	return;
+}
+
+static void fillRect(void * addr, unsigned int x, unsigned int y, unsigned int w, unsigned int h, unsigned int sizeX, unsigned int sizeY, unsigned int color)
+{
+	unsigned int row;
+	unsigned int col;
+	void * pPixel;
+
+	if (addr == NULL) return;
+	if ((w > sizeX) || (h > sizeY)) return;
+
+	for (row = y; row <  y + h; row++) {
+		for (col = x; col < x + w; col++)
+		{
+			pPixel = addr + row * (sizeX) * 4 + col * 4;
+			*(unsigned int *)(pPixel) = color;
+		}
+	}
+
+	return;
+}
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_proc.h b/drivers/gpu/drm/emgd/emgd/drm/emgd_proc.h
new file mode 100755
index 0000000..ac6d73a
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_proc.h
@@ -0,0 +1,39 @@
+/*
+ *-----------------------------------------------------------------------------
+ * Filename: emgd_proc.h
+ * $Revision: 1.6 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2010, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ * Description:
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+#ifndef EMGD_PROC_H_
+#define EMGD_PROC_H_
+
+ int  init_emgd_procfs(void);
+ void cleanup_emgd_procfs(void);
+
+
+#endif /* EMGD_PROC_H_ */
diff --git a/drivers/gpu/drm/emgd/emgd/include/sched.h b/drivers/gpu/drm/emgd/emgd/include/sched.h
index 9b33a1a..6d9579e 100644
--- a/drivers/gpu/drm/emgd/emgd/include/sched.h
+++ b/drivers/gpu/drm/emgd/emgd/include/sched.h
@@ -47,7 +47,7 @@ static __inline os_alarm_t _linux_kernel_set_alarm(unsigned long t)
 
 static __inline int _linux_kernel_test_alarm(os_alarm_t t)
 {
-	return (jiffies >= t) ? 1 : 0;
+	return (time_is_before_jiffies(t))? 1:0;
 }
 
 #define OS_SET_ALARM(t) _linux_kernel_set_alarm(t)
diff --git a/drivers/gpu/drm/emgd/emgd/include/tnc/igd_tnc_wa.h b/drivers/gpu/drm/emgd/emgd/include/tnc/igd_tnc_wa.h
index 7cd4aa7..02577f13 100644
--- a/drivers/gpu/drm/emgd/emgd/include/tnc/igd_tnc_wa.h
+++ b/drivers/gpu/drm/emgd/emgd/include/tnc/igd_tnc_wa.h
@@ -46,6 +46,7 @@
 /* Graphic core Revision ID for Atom E6xx stepping */
 #define TNC_A0_RID			0x2
 #define TNC_B0_RID			0x3
+#define TNC_B1_RID			0x5
 #define TNC_B0_DEV3_RID		0x1
 #define TNC_B1_DEV3_RID		0x2
 #define SDVO_CRC_CTRL_REG	0x61050
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc.c b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc.c
index 2565f48..5cc7543 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc.c
@@ -37,6 +37,7 @@
 
 #define MODULE_NAME hal.overlay
 
+#include <tnc/igd_tnc_wa.h>
 #include <math_fix.h>
 #include <tnc/cmd.h>
 #include "ovl_tnc_cache.h"
@@ -1716,11 +1717,14 @@ static unsigned int ovl_update_regs_tnc(
 		return IGD_SUCCESS;
 	}
 
-	/* Force value of y1 to even due hardware expects even number */
-	dest_rect->y1 &= ~1;
-	dest_rect->y2 = (dest_rect->y2 + 1) & ~1;
-	dest_rect->x1 &= ~1;
-	dest_rect->x2 = (dest_rect->x2 + 1) & ~1;
+	if( display->context->device_context.rid != TNC_B1_RID )
+	{
+		/* Force value of y1 to even due hardware expects even number */
+		dest_rect->y1 &= ~1;
+		dest_rect->y2 = (dest_rect->y2 + 1) & ~1;
+		dest_rect->x1 &= ~1;
+		dest_rect->x2 = (dest_rect->x2 + 1) & ~1;
+	}
 
 	/* Init the cache if necessary */
 	if (ovl_cache_needs_init) {
@@ -1777,25 +1781,26 @@ static unsigned int ovl_update_regs_tnc(
 			ovl_cache_regs->command |= OVL_CMD_FIELD_MODE;
 			/* enable FIELD SYNC OVERLAY FLIP in field mode. */
 			ovl_cache_regs->command |= OVL_CMD_FIELD_SYNC_FLIP;
-			/* HSD# 203821 Mplayer outputs single buffer including both even and odd fields. */
-			if (flags & IGD_OVL_ALTER_FLIP_ODD) {
-				ovl_cache_regs->command |= OVL_CMD_ACT_FLD1;
-				/* HSD: 203821 To display odd field, starts from first odd field. */
-				if (0 == (src_rect->y1 & 1)) {
-					src_rect->y1 += 1;
-				}
-			} else {
-				ovl_cache_regs->command |= OVL_CMD_ACT_FLD0;
-				/* HSD: 203821 To display even field, starts from first even field. */
-				if (0 != (src_rect->y1 & 1)) {
-					src_rect->y1 += 1;
-				}
-			}
 		} else {
 			ovl_cache_regs->command |= OVL_CMD_FRAME_MODE;
 		}
 	}
 
+	/* HSD# 203821 Mplayer outputs single buffer including both even and odd fields. */
+	if (flags & IGD_OVL_ALTER_FLIP_ODD) {			
+		ovl_cache_regs->command |= OVL_CMD_ACT_FLD1;
+		/* HSD: 203821 To display odd field, starts from first odd field. */
+		if (0 == (src_rect->y1 & 1)) {
+			src_rect->y1 += 1;
+		}
+	} else {			
+		ovl_cache_regs->command |= OVL_CMD_ACT_FLD0;
+		/* HSD: 203821 To display even field, starts from first even field. */
+		if (0 != (src_rect->y1 & 1)) {
+			src_rect->y1 += 1;
+		}
+	}
+	
 	/* Has our destination rectangle changed? */
 	if (cache_changed & IGD_OVL_TNC_UPDATE_DEST) {
 		ovl_cache_regs->dest_pos_x_left  =
@@ -2375,6 +2380,8 @@ int disable_direct_display_tnc(void *arg, int usage)
 		/* Mark the Sprite C direct display context as invalid */
 		dd_context_ovl2 = NULL;
 	}
+	query_ovl_tnc(display, IGD_OVL_QUERY_WAIT_LAST_FLIP_DONE);
+	
 	/* Deallocate the DD context block for the direct display plane */
 	OS_FREE(dd_context_ptr);
 
diff --git a/drivers/gpu/drm/emgd/include/emgd_drm.h b/drivers/gpu/drm/emgd/include/emgd_drm.h
index a1d946d..244abd7 100644
--- a/drivers/gpu/drm/emgd/include/emgd_drm.h
+++ b/drivers/gpu/drm/emgd/include/emgd_drm.h
@@ -714,6 +714,7 @@ typedef struct _kdrm_unlock_planes {
 #define DRM_IGD_QUERY_2D_CAPS_HWHINT 0x35
 #define DRM_IGD_DIHCLONE_SET_SURFACE 0x36
 #define DRM_IGD_SET_OVERLAY_DISPLAY  0x37
+#define DRM_IGD_GET_SCANLINE		 0x50
 #define DRM_IGD_WAIT_VBLANK			 0x40
 
 /*
@@ -890,6 +891,8 @@ typedef struct _kdrm_unlock_planes {
 #define DRM_IOCTL_IGD_WAIT_VBLANK			DRM_IOWR(DRM_IGD_WAIT_VBLANK + BASE,\
 		emgd_drm_driver_set_sync_refresh_t)
 
+#define DRM_IOCTL_IGD_GET_SCANLINE			DRM_IOWR(DRM_IGD_GET_SCANLINE + BASE,\
+		emgd_drm_driver_get_scanline_t)
 
 /* From pvr_bridge.h */
 #define DRM_IOCTL_IGD_RESERVED_1       DRM_IOW(DRM_IGD_RESERVED_1 + BASE, \
diff --git a/drivers/gpu/drm/emgd/include/igd_mode.h b/drivers/gpu/drm/emgd/include/igd_mode.h
index 3eb9c11..b02bdb1 100644
--- a/drivers/gpu/drm/emgd/include/igd_mode.h
+++ b/drivers/gpu/drm/emgd/include/igd_mode.h
@@ -909,6 +909,11 @@ typedef struct _kdrm_driver_set_sync_refresh {
         unsigned int    bottom_line;
 } emgd_drm_driver_set_sync_refresh_t;
 
+typedef struct _kdrm_driver_get_scanline {
+        igd_display_h   display_handle;
+        unsigned int    scanline;
+        int rtn;
+} emgd_drm_driver_get_scanline_t;
 
 
 /*!
diff --git a/drivers/gpu/drm/emgd/include/igd_ovl.h b/drivers/gpu/drm/emgd/include/igd_ovl.h
index 67ffa85..5e65d61 100644
--- a/drivers/gpu/drm/emgd/include/igd_ovl.h
+++ b/drivers/gpu/drm/emgd/include/igd_ovl.h
@@ -317,6 +317,9 @@ typedef struct _ovl_um_context {
 	igd_display_h ovl_display_um[OVL_MAX_HW];
 	igd_ovl_info_t ovl_info_um[OVL_MAX_HW];
 	igd_display_h active_single_ovl;
+
+	int blend_surface_preallocation;
+	unsigned int v4l2_buffering;
 } ovl_um_context_t;
 
 
diff --git a/drivers/gpu/drm/emgd/include/igd_version.h b/drivers/gpu/drm/emgd/include/igd_version.h
index 0b192a9..f34fd74 100644
--- a/drivers/gpu/drm/emgd/include/igd_version.h
+++ b/drivers/gpu/drm/emgd/include/igd_version.h
@@ -35,7 +35,7 @@
 
 #define IGD_MAJOR_NUM  1
 #define IGD_MINOR_NUM  18
-#define IGD_BUILD_NUM  3398
+#define IGD_BUILD_NUM  4024
 
 #define IGD_PCF_VERSION   0x00000400
 #endif
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/devices/sgx/sgxutils.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/devices/sgx/sgxutils.c
index 8ffa3fa..1d43da1 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/devices/sgx/sgxutils.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/devices/sgx/sgxutils.c
@@ -603,6 +603,14 @@ IMG_VOID SGXCleanupRequest(PVRSRV_DEVICE_NODE	*psDeviceNode,
 			PVR_DBG_BREAK;
 		}
 
+		/* 
+		 * POTENTIAL WORKAROUND (JD Workaround):
+		 * 		If an IERR or a hard CPU hang is seen when shutting down, a
+		 * delay of around 10 mili-seconds might be required at this point, when
+		 * the ui32CleanupType is PVRSRV_CLEANUPCMD_TC. This delay seems to give
+		 * the SGX enough time to properly cleanup. For the previously seen
+		 * issue, refer to HSD 205489.
+		 */
 
 		#if !defined(NO_HARDWARE)
 		if(PollForValueKM(&psSGXHostCtl->ui32CleanupStatus,
-- 
1.7.5.4

