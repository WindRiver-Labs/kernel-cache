From b3dcb38ce50c8827b5aca88b50686a880201a5ea Mon Sep 17 00:00:00 2001
From: Yue Tao <yue.tao@windriver.com>
Date: Thu, 9 Oct 2014 07:10:44 -0700
Subject: [PATCH] emgd: upgrade 1.18

Signed-off-by: Yue Tao <yue.tao@windriver.com>
---
 drivers/gpu/drm/emgd/Makefile                      |    5 +-
 .../drm/emgd/emgd/core/init/tnc/micro_init_tnc.c   |   29 ++-
 drivers/gpu/drm/emgd/emgd/display/dsp/cmn/dsp.c    |    6 +-
 .../gpu/drm/emgd/emgd/display/dsp/plb/dsp_plb.c    |    4 +-
 .../gpu/drm/emgd/emgd/display/dsp/tnc/dsp_tnc.c    |    8 +-
 .../gpu/drm/emgd/emgd/display/mode/cmn/igd_mode.c  |   38 ++-
 .../drm/emgd/emgd/display/mode/cmn/micro_mode.c    |   11 +-
 .../drm/emgd/emgd/display/mode/cmn/mode_dispatch.h |    3 +
 .../emgd/emgd/display/mode/plb/micro_mode_plb.c    |   15 +-
 .../gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c  |   17 +
 .../drm/emgd/emgd/display/mode/tnc/kms_mode_tnc.c  |    2 +-
 .../emgd/emgd/display/mode/tnc/micro_mode_tnc.c    |   17 +-
 .../gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.c  |  207 +++++++--
 drivers/gpu/drm/emgd/emgd/display/pd/cmn/pd.c      |   24 +-
 drivers/gpu/drm/emgd/emgd/display/pi/cmn/pi.c      |    2 +
 drivers/gpu/drm/emgd/emgd/drm/emgd_connector.c     |    8 +-
 drivers/gpu/drm/emgd/emgd/drm/emgd_crtc.c          |  114 +++--
 drivers/gpu/drm/emgd/emgd/drm/emgd_drv.c           |  275 ++++++++---
 drivers/gpu/drm/emgd/emgd/drm/emgd_drv.h           |    2 +
 drivers/gpu/drm/emgd/emgd/drm/emgd_encoder.c       |   75 ++--
 drivers/gpu/drm/emgd/emgd/drm/emgd_fb.c            |   49 ++-
 drivers/gpu/drm/emgd/emgd/drm/emgd_fbcon.c         |   88 +++-
 drivers/gpu/drm/emgd/emgd/drm/emgd_interface.c     |   65 ++-
 drivers/gpu/drm/emgd/emgd/drm/user_config.c        |  509 ++++++++++----------
 drivers/gpu/drm/emgd/emgd/drm/user_config.h        |    6 +
 drivers/gpu/drm/emgd/emgd/gmm/gmm.c                |  171 ++++---
 drivers/gpu/drm/emgd/emgd/include/context.h        |    1 +
 drivers/gpu/drm/emgd/emgd/include/memlist.h        |    3 +-
 drivers/gpu/drm/emgd/emgd/include/msvdx.h          |   14 +-
 drivers/gpu/drm/emgd/emgd/include/pd.h             |    1 +
 drivers/gpu/drm/emgd/emgd/include/plb/context.h    |    2 +
 drivers/gpu/drm/emgd/emgd/include/topaz.h          |    7 +-
 drivers/gpu/drm/emgd/emgd/pal/ch7036/Makefile.gnu  |   41 +-
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_pm.c   |    6 +-
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.c |   23 +-
 drivers/gpu/drm/emgd/emgd/pal/lvds/lvds.c          |    5 +-
 drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_attr.c     |    4 +-
 drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.c     |   29 +-
 drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.h     |    4 +-
 drivers/gpu/drm/emgd/emgd/state/reg/plb/reg_plb.c  |   67 ++-
 drivers/gpu/drm/emgd/emgd/state/reg/tnc/reg_tnc.c  |  119 +++---
 drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx.c      |   25 +-
 drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_init.c |  302 ++++++++++--
 drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_pvr.c  |    4 +-
 .../gpu/drm/emgd/emgd/video/overlay/cmn/igd_ovl.c  |   36 +-
 .../gpu/drm/emgd/emgd/video/overlay/cmn/ovl_virt.h |    2 +-
 .../emgd/emgd/video/overlay/plb/ovl_plb_cache.c    |    4 +-
 .../emgd/emgd/video/overlay/tnc/micro_ovl_tnc.c    |  112 ++++-
 .../gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_tnc.c |   26 +-
 .../gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc.c  |  357 ++++++++++++++-
 .../emgd/emgd/video/overlay/tnc/ovl_tnc_cache.c    |    4 +-
 drivers/gpu/drm/emgd/emgd/video/topaz/topaz.c      |   60 ++-
 drivers/gpu/drm/emgd/emgd/video/topaz/topaz_init.c |  258 +++++++++-
 drivers/gpu/drm/emgd/include/emgd_drm.h            |   32 +-
 drivers/gpu/drm/emgd/include/igd.h                 |    5 +
 drivers/gpu/drm/emgd/include/igd_gmm.h             |    9 +-
 drivers/gpu/drm/emgd/include/igd_mode.h            |    3 +-
 drivers/gpu/drm/emgd/include/igd_ovl.h             |    3 +-
 drivers/gpu/drm/emgd/include/igd_render.h          |   41 ++
 drivers/gpu/drm/emgd/include/igd_version.h         |    6 +-
 .../services4/3rdparty/emgd_bufferclass/emgd_bc.c  |   10 +-
 .../services4/3rdparty/emgd_bufferclass/emgd_bc.h  |    3 +-
 .../3rdparty/emgd_bufferclass/emgd_bc_linux.c      |   83 +++-
 .../services4/3rdparty/emgd_displayclass/emgd_dc.c |   15 +-
 .../drm/emgd/pvr/services4/srvkm/env/linux/event.c |    9 +-
 .../emgd/pvr/services4/srvkm/env/linux/osfunc.c    |    9 +-
 .../drm/emgd/pvr/services4/srvkm/env/linux/proc.h  |    7 +-
 .../emgd/pvr/services4/srvkm/env/linux/pvr_drm.c   |   21 +-
 68 files changed, 2649 insertions(+), 873 deletions(-)

diff --git a/drivers/gpu/drm/emgd/Makefile b/drivers/gpu/drm/emgd/Makefile
index a254d3c..6c08ff7 100755
--- a/drivers/gpu/drm/emgd/Makefile
+++ b/drivers/gpu/drm/emgd/Makefile
@@ -1,6 +1,6 @@
 #----------------------------------------------------------------------------
 # Filename: Makefile.gnu
-# $Revision: 1.58 $
+# $Revision: 1.59 $
 #----------------------------------------------------------------------------
 # Copyright (c) 2002-2010, Intel Corporation.
 #
@@ -95,7 +95,6 @@ PROJECT_INCLUDES = \
 	   -DUSE_PTHREADS \
 	   -DSUPPORT_SGX_EVENT_OBJECT \
 	   -DSUPPORT_SGX_HWPERF \
-	   -DSUPPORT_SGX_LOW_LATENCY_SCHEDULING \
 	   -DSUPPORT_LINUX_X86_PAT \
 	   -DSUPPORT_SGX535 \
 	   -DSUPPORT_CACHE_LINE_FLUSH \
@@ -118,8 +117,6 @@ ifeq ($(PDUMP),1)
 	EXTRA_CFLAGS += -DPDUMP=1
 endif
 
-ccflags-y += $(EXTRA_CFLAGS)
-
 EMGD_OBJS := \
 	emgd/drm/emgd_fb.o \
 	emgd/drm/emgd_fbcon.o \
diff --git a/drivers/gpu/drm/emgd/emgd/core/init/tnc/micro_init_tnc.c b/drivers/gpu/drm/emgd/emgd/core/init/tnc/micro_init_tnc.c
index dd2d1d0..005a00d 100644
--- a/drivers/gpu/drm/emgd/emgd/core/init/tnc/micro_init_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/core/init/tnc/micro_init_tnc.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: micro_init_tnc.c
- * $Revision: 1.25 $
+ * $Revision: 1.26 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -674,6 +674,8 @@ static int config_tnc(igd_context_t *context,
 	init_dispatch_t *dispatch)
 {
 	unsigned long freq[2];
+	platform_context_tnc_t *platform_context = &platform_context_tnc;
+	unsigned long lbb;
 #ifndef CONFIG_MICRO
 	unsigned int lp_ctrl_reg;
 	unsigned int hp_ctrl_reg;
@@ -737,6 +739,31 @@ static int config_tnc(igd_context_t *context,
 
 	gtt_init_tnc(context);
 
+       /* 
+	 * Setting the LBB to 0xFF if it is 0. 
+	 * This register is used to dynamic LVDS backlight control. By default, 
+	 * the register will reset to 0x0, this will cause the LVDS to be "off" when 
+	 * PD_ATTR_ID_BLM_LEGACY_MODE attribute is set. Customers could write 
+	 * application to set this register. 
+	 *
+	 * TODO: The right way to fix this is to check for the attribute in lvds.c
+	 * then set the register through pd. But this will add more code to VBIOS
+	 * (as we need to add dispatch functions in pd)
+	 */
+
+	if(OS_PCI_READ_CONFIG_32(platform_context->pcidev0, 0xF4, &lbb)) {
+		EMGD_DEBUG("Reading Legacy Backlight Brightness");
+		return -IGD_ERROR_NODEV;
+	} 
+	if(!(lbb & 0xFF)){
+		if(OS_PCI_WRITE_CONFIG_32(platform_context->pcidev0,
+			0xF4, (lbb | 0xFF))){
+			EMGD_DEBUG("Writing into Legacy Backlight Brightness");
+			return -IGD_ERROR_INVAL;
+		}
+	}
+
+
 	EMGD_TRACE_EXIT;
 	return 0;
 }
diff --git a/drivers/gpu/drm/emgd/emgd/display/dsp/cmn/dsp.c b/drivers/gpu/drm/emgd/emgd/display/dsp/cmn/dsp.c
index d4abefb..38641fc 100755
--- a/drivers/gpu/drm/emgd/emgd/display/dsp/cmn/dsp.c
+++ b/drivers/gpu/drm/emgd/emgd/display/dsp/cmn/dsp.c
@@ -179,14 +179,14 @@ static unsigned long dsp_get_fw_dc(igd_context_t *context)
 	int port_allocated = 0;
 	unsigned long port_value;
 	unsigned long fw_dc = 0;
-	unsigned char *mmio = EMGD_MMIO(context->device_context.virt_mmadr);
 
 	EMGD_TRACE_ENTER;
 
 	/* Go through the port table */
 	while ((p = dsp_get_next_port(context, p, 0)) != NULL) {
 
-		port_value = EMGD_READ32(mmio + p->port_reg);
+		port_value = dsp_context.context->mod_dispatch.get_port_control(p->port_number, p->port_reg);
+		EMGD_DEBUG("port number = %lx, port reg = %lx, value = %lx", p->port_number, p->port_reg, port_value);
 		if(port_value & BIT(31)) { /* is the port ON? */
 
 			if(port1) {
@@ -1892,6 +1892,8 @@ int dsp_init(igd_context_t *context)
 			 */
 			(*(igd_display_plane_t **)plane)->fb_info->fb_base_offset = 0;
 			(*(igd_display_plane_t **)plane)->fb_info->visible_offset = 0;
+			(*(igd_display_plane_t **)plane)->fb_info->saved_offset = 0;
+			(*(igd_display_plane_t **)plane)->fb_info->lock = FALSE;
 			dsp_context.num_dsp_planes++;
 		}
 		plane++;
diff --git a/drivers/gpu/drm/emgd/emgd/display/dsp/plb/dsp_plb.c b/drivers/gpu/drm/emgd/emgd/display/dsp/plb/dsp_plb.c
index 9330537..62e6582 100644
--- a/drivers/gpu/drm/emgd/emgd/display/dsp/plb/dsp_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/display/dsp/plb/dsp_plb.c
@@ -301,14 +301,14 @@ static igd_clock_t clock_b_plb = {
 static igd_display_pipe_t pipea_plb = {
 	0, PIPEA_CONF, PIPEA_TIMINGS, DPALETTE_A, &clock_a_plb,
 	(IGD_PIPE_IS_PIPEA | IGD_PORT_SHARE_DIGITAL),
-	0, 0,{NULL, NULL, NULL}, NULL, NULL, NULL,
+	0, 0,{NULL, NULL, NULL}, &planea_plb, NULL, NULL, NULL,
 	NULL, NULL
 };
 
 static igd_display_pipe_t pipeb_plb = {
 	1, PIPEB_CONF, PIPEB_TIMINGS, DPALETTE_B, &clock_b_plb,
 	(IGD_PIPE_IS_PIPEB | IGD_PORT_SHARE_LVDS),
-	0, 0,{NULL, NULL, NULL}, NULL, NULL, NULL,
+	0, 0,{NULL, NULL, NULL}, &planeb_plb, NULL, NULL, NULL,
 	NULL, NULL
 };
 
diff --git a/drivers/gpu/drm/emgd/emgd/display/dsp/tnc/dsp_tnc.c b/drivers/gpu/drm/emgd/emgd/display/dsp/tnc/dsp_tnc.c
index 0697657..9d5072d 100644
--- a/drivers/gpu/drm/emgd/emgd/display/dsp/tnc/dsp_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/display/dsp/tnc/dsp_tnc.c
@@ -301,15 +301,15 @@ static igd_clock_t clock_b_tnc = {
 static igd_display_pipe_t pipea_tnc = {
 	0, PIPEA_CONF, PIPEA_TIMINGS, DPALETTE_A, &clock_a_tnc,
 	(IGD_PIPE_IS_PIPEA | IGD_PORT_SHARE_LVDS),
-	0, 0,{NULL, NULL, NULL}, NULL, NULL, NULL,
-	NULL, NULL
+	0, 0,{NULL, NULL, NULL}, &planea_tnc, NULL, NULL,
+	NULL, NULL, NULL
 };
 
 static igd_display_pipe_t pipeb_tnc = {
 	1, PIPEB_CONF, PIPEB_TIMINGS, DPALETTE_B, &clock_b_tnc,
 	(IGD_PIPE_IS_PIPEB | IGD_PORT_SHARE_DIGITAL),
-	0, 0,{NULL, NULL, NULL}, NULL, NULL, NULL,
-	NULL, NULL
+	0, 0,{NULL, NULL, NULL}, &planeb_tnc, NULL, NULL,
+	NULL, NULL, NULL
 };
 
 static igd_display_pipe_t *pipe_table_tnc[] = {
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/igd_mode.c b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/igd_mode.c
index 70de834..827645d 100755
--- a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/igd_mode.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/igd_mode.c
@@ -66,6 +66,9 @@
 #include "match.h"
 #include "mode_dispatch.h"
 
+#include "ovl_dispatch.h"
+#include "ovl_virt.h"
+
 /*!
  * @addtogroup display_group
  * @{
@@ -1062,6 +1065,12 @@ long igd_pan_display(igd_display_h hDisplay,
 	pt_info->x_offset = (unsigned short)x_offset;
 	pt_info->y_offset = (unsigned short)y_offset;
 
+	/* igd_ovl_set_display also set this flag, this flag include:
+	 * 1) ovl/sprite C swap, by igd_ovl_set_display
+	 * 2) swap display, or only change 1 display,  by pan display
+	*/
+	ovl_context->ovl_display_swapped = 1;
+
 	/* FIXME:
 	 *   This could be negative, and thus conflict with the error codes
 	 *   returned above.  However, this is needed for Whitney to compensate
@@ -1864,6 +1873,8 @@ int full_mode_init(igd_context_t *context,
 		mode_context->dispatch->check_port_supported;
 	context->mod_dispatch.get_refresh_in_border =
 		mode_context->dispatch->get_refresh_in_border;
+	context->mod_dispatch.get_port_control =
+		mode_context->dispatch->full->get_port_control;
 
 
 	/* Hook up Core specific IGD dispatch table entries */
@@ -1883,6 +1894,7 @@ int full_mode_init(igd_context_t *context,
 	dispatch->disable_vblank_callback =
 		mode_context->dispatch->full->disable_vblank_callback;
 
+	dispatch->unlock_planes = mode_context->dispatch->full->unlock_planes;
 	/* Assign the fw_info structure and Zero-out the contents */
 	mode_context->fw_info = &global_fw_info;
 	OS_MEMSET(mode_context->fw_info, 0, sizeof(fw_info_t));
@@ -2113,6 +2125,7 @@ int query_seamless(unsigned long dc,
 	int ret = FALSE;
 	igd_display_info_t *timing;
 	igd_framebuffer_info_t *fb_info;
+	unsigned long in_pitch;
 
 	EMGD_TRACE_ENTER;
 	EMGD_DEBUG("Incoming dc = 0x%08lx", dc);
@@ -2123,9 +2136,15 @@ int query_seamless(unsigned long dc,
 	mode_context->fw_info->fw_dc =
 				 mode_context->context->mod_dispatch.dsp_fw_dc;
 
+	EMGD_DEBUG("firmware dc = 0x%08lx",mode_context->fw_info->fw_dc );
 	if(dc != mode_context->fw_info->fw_dc) {
-		/* DC doesn't match */
-		return FALSE;
+		/*special case when seamless transition from fw clone to vext */
+		if(!(IGD_DC_VEXT(dc) && IGD_DC_CLONE(mode_context->fw_info->fw_dc)))
+		{
+			/* DC doesn't match */
+			return FALSE;
+		}
+		EMGD_DEBUG("past dc check");
 	}
 
 	/* Note: this test both overcomes a compiler warning, as well as a
@@ -2148,7 +2167,7 @@ int query_seamless(unsigned long dc,
 
 			/* Have to build in some tolerance here because the fresh rate may
 			 * not match exactly */
-			if (abs(timing->refresh - pt->refresh) <= 1) {
+			if (abs(timing->refresh - pt->refresh) <= 2) {
 
 			ret = TRUE;
 		}
@@ -2175,11 +2194,15 @@ int query_seamless(unsigned long dc,
 	/* Check Plane information */
 	if(pf != NULL) {
 		fb_info = &mode_context->fw_info->fb_info[index];
-		ret = FALSE;
+		ret = TRUE;
+		/* the incoming pitch=0, since it won't be filled until FB is allocated, calculating it now, so that
+		 * it can be compared with the fw pitch */
+		in_pitch = (IGD_PF_DEPTH(pf->pixel_format) * pf->width) >> 3;
+
+		/* Pitch for both PLB and TNC requires 64-byte alignment */
+		in_pitch = ALIGN(in_pitch, 64);
 
-		if( (fb_info->screen_pitch != pf->screen_pitch) ||
-			(fb_info->width != pf->width) ||
-			(fb_info->height != pf->height) ) {
+		if(fb_info->screen_pitch != in_pitch) {
 
 			/* If width, height or pitch is different
 			 * Don't have to turn-off pipe, just update
@@ -2188,7 +2211,6 @@ int query_seamless(unsigned long dc,
 			 * the registers.
 			 */
 			mode_context->fw_info->program_plane = 1;
-			ret = TRUE;
 		}
 
 	}
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/micro_mode.c b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/micro_mode.c
index 5d615aa..c642572 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/micro_mode.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/micro_mode.c
@@ -197,7 +197,7 @@ static int timing_changed(igd_display_context_t *display,
 			if ((cfb->width != fb_info->width) ||
 				(cfb->height != fb_info->height) ||
 				(cfb->pixel_format != fb_info->pixel_format) ||
-				(cfb->flags != fb_info->flags)) {
+				((fb_info->flags^fb_info->flags) &~ IGD_SURFACE_RENDER)){
 				/* Timing ok buf fb_info doesn't match */
 				return 1;
 			}
@@ -292,7 +292,7 @@ static int mode_update_plane_pipe_ports(
 		if((fb_info->width == plane_fb_info->width) &&
 			(fb_info->height == plane_fb_info->height) &&
 			(fb_info->pixel_format == plane_fb_info->pixel_format) &&
-			(fb_info->flags == plane_fb_info->flags)) {
+			((fb_info->flags^plane_fb_info->flags) & ~IGD_SURFACE_RENDER) == 0) {
 			alloc_fb = 0;
 		}
 
@@ -724,7 +724,8 @@ static int configure_display(
 				0));
 
 			EMGD_DEBUG(":Seamless = %s", seamless ?"ON" : "OFF");
-			mode_context->seamless = FALSE;
+			/* moved this to alter_displays to handle the case for CLONE */
+			/*mode_context->seamless = FALSE;*/
 			/* FIXME: For clone you get called twice. Need to
 			 * Fix that corner case
 			 */
@@ -853,6 +854,10 @@ static int configure_display(
 		 */
 
 		EMGD_DEBUG(" Seamless is TRUE");
+		/* special handling for fw clone to vext seamless */
+		if((IGD_DC_VEXT(config_drm.dc) && IGD_DC_CLONE(mode_context->fw_info->fw_dc))){
+			mode_context->dispatch->full->lock_planes(display);
+		}
 		if(mode_context->fw_info->program_plane == 1) {
 
 			/* This means we have to update the plane registers
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/mode_dispatch.h b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/mode_dispatch.h
index b2ae62e..221e4d2 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/mode_dispatch.h
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/mode_dispatch.h
@@ -139,6 +139,9 @@ typedef struct _mode_full_dispatch {
 	 * @return Non-zero if the requested VBlank occured, zero if not.
 	 */
 	int (*vblank_occured)(unsigned long request_for);
+	unsigned long (*get_port_control)(unsigned long port_num, unsigned long port_reg);
+	void (*lock_planes)(igd_display_h display_handle);
+	int (*unlock_planes)(igd_display_h display_handle, unsigned int scrn_num);
 } mode_full_dispatch_t;
 
 typedef struct _mode_dispatch {
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/plb/micro_mode_plb.c b/drivers/gpu/drm/emgd/emgd/display/mode/plb/micro_mode_plb.c
index 9fbb378..9d69f8d 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/plb/micro_mode_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/plb/micro_mode_plb.c
@@ -901,7 +901,20 @@ static void reset_plane_pipe_ports_plb(igd_context_t *context)
 			if(port->pd_type == PD_DISPLAY_TVOUT) {
 				tv_port = port;
 			}else {
-				port->pd_driver->set_power(port->pd_context, IGD_POWERSTATE_D3);
+								
+				/* for CH7036: Code fix Meego hang after killall X 
+				 * Basicall, when X enters ACPI D1 state, we want to pass that info to port device (Ch7036)
+				 * from reset_plane_pipe_ports_xxx(). 
+				 */
+				if(context->device_context.power_state == IGD_POWERSTATE_D1) { 
+				   /* D1 power state for graphics is requested 
+					* Then the power_state status will pass to pd
+					*/
+					 port->pd_driver->set_power(port->pd_context,context->device_context.power_state); 			
+				}
+				else {
+					port->pd_driver->set_power(port->pd_context, IGD_POWERSTATE_D3); 
+				}
 			}
 #endif
 		}
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c b/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c
index ac6ea5d..55a90cc 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c
@@ -87,6 +87,7 @@ DEFINE_SPINLOCK(vblank_lock_plb);
 int set_flip_pending_plb(unsigned char *mmio, unsigned long pipe_status_reg);
 int check_flip_pending_plb(unsigned char *mmio, unsigned long pipe_status_reg);
 
+unsigned long get_port_control_plb(unsigned long port_num, unsigned long port_reg);
 /*!
  * @addtogroup display_group
  * @{
@@ -1917,6 +1918,21 @@ void disable_vblank_callback_plb(emgd_vblank_callback_h callback_h)
 	EMGD_TRACE_EXIT;
 }
 
+/*!
+ *  checks if the port is enabled
+ */
+unsigned long get_port_control_plb(unsigned long port_num, unsigned long port_reg)
+{
+	unsigned long port_value=0;
+	unsigned char* mmio = NULL;
+
+	EMGD_TRACE_ENTER;
+	mmio = EMGD_MMIO(mode_context->context->device_context.virt_mmadr);
+	port_value = EMGD_READ32(mmio+port_reg);
+
+	EMGD_TRACE_EXIT;
+	return port_value;
+}
 
 mode_full_dispatch_t mode_full_dispatch_plb = {
 	igd_alter_cursor_pos_plb,
@@ -1942,5 +1958,6 @@ mode_full_dispatch_t mode_full_dispatch_plb = {
 	request_vblanks_plb,
 	end_request_plb,
 	vblank_occured_plb,
+	get_port_control_plb,
 };
 
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/kms_mode_tnc.c b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/kms_mode_tnc.c
index 30696ac..4f3e672 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/kms_mode_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/kms_mode_tnc.c
@@ -1665,7 +1665,7 @@ static int kms_post_program_port_tnc(emgd_encoder_t * emgd_encoder,
 	if (port->pd_driver->post_set_mode) {
 		if (port->port_type == IGD_PORT_SDVO){
 			ret = port->pd_driver->post_set_mode(port->pd_context, timings,
-				status); /*Needed for OKI*/
+				status); /*Needed for LAPIS*/
 		} else {
 			ret = port->pd_driver->post_set_mode(port->pd_context, timings,
 				1<<pipe->pipe_num);
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/micro_mode_tnc.c b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/micro_mode_tnc.c
index f96b710..2a313ec 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/micro_mode_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/micro_mode_tnc.c
@@ -1755,7 +1755,20 @@ void reset_plane_pipe_ports_tnc(igd_context_t *context)
 			if(port->pd_type == PD_DISPLAY_TVOUT) {
 				tv_port = port;
 			}else {
-				port->pd_driver->set_power(port->pd_context, IGD_POWERSTATE_D3);
+				
+				/* for CH7036: Code fix Meego hang after killall X 
+				 * Basicall, when X enters ACPI D1 state, we want to pass that info to port device (Ch7036)
+				 * from reset_plane_pipe_ports_xxx(). 
+				 */
+				if(context->device_context.power_state == IGD_POWERSTATE_D1) { 
+				   /* D1 power state for graphics is requested 
+					* Then the power_state status will pass to pd
+					*/
+					 port->pd_driver->set_power(port->pd_context,context->device_context.power_state);			
+				}
+				else {
+					port->pd_driver->set_power(port->pd_context, IGD_POWERSTATE_D3); 
+				}
 			}
 		}
 
@@ -2131,7 +2144,7 @@ int post_program_port_tnc(igd_display_context_t *display,
 		#ifndef CONFIG_MICRO
 		if (pt == IGD_PORT_SDVO){
 			ret = port->pd_driver->post_set_mode(port->pd_context, timings,
-				status); /*Needed for OKI*/
+				status); /*Needed for LAPIS*/
 		} else {
 			ret = port->pd_driver->post_set_mode(port->pd_context, timings,
 				1<<PIPE(display)->pipe_num);
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.c b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.c
index 2f22ef6..13f8613 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: mode_tnc.c
- * $Revision: 1.35 $
+ * $Revision: 1.36 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -15,6 +15,7 @@
  * The above copyright notice and this permission notice shall be included in
  * all copies or substantial portions of the Software.
  *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
@@ -60,6 +61,7 @@
 #include <linux/spinlock.h>
 #include <drm/drmP.h>
 
+#include <emgd_drm.h>
 
 /* Get this table from clocks_tnc.c, use this in get_pipe_info */
 extern unsigned long lvds_m_converts[];
@@ -96,6 +98,7 @@ DEFINE_SPINLOCK(vblank_lock_tnc);
 
 int set_flip_pending_tnc(unsigned char *mmio, unsigned long pipe_status_reg);
 int check_flip_pending_tnc(unsigned char *mmio, unsigned long pipe_status_reg);
+unsigned long get_port_control_tnc(unsigned long port_num, unsigned long port_reg);
 
 /* KMS callback from emgd_crtc.c */
 int crtc_pageflip_handler(struct drm_device *dev, int port);
@@ -382,6 +385,8 @@ static int set_color_correct_tnc(igd_display_context_t *display)
 static int set_display_base_tnc(igd_display_context_t *display,
 	igd_framebuffer_info_t *fb, unsigned long *x, unsigned long *y)
 {
+	unsigned long reg;
+	unsigned long temp;
 	EMGD_TRACE_ENTER;
 
 	EMGD_DEBUG ("Pan linear to (%lu,%lu)", *x, *y);
@@ -390,10 +395,21 @@ static int set_display_base_tnc(igd_display_context_t *display,
 	PLANE(display)->fb_info->visible_offset =
 		((*y * fb->screen_pitch) + (*x * IGD_PF_BYPP(fb->pixel_format)));
 
-	/* Plane registers are always on 0:2:0 */
-	WRITE_MMIO_REG(display, PLANE(display)->plane_reg + DSP_LINEAR_OFFSET,
-		PLANE(display)->fb_info->visible_offset);
+	temp = PLANE(display)->fb_info->visible_offset;
+	EMGD_DEBUG ("visible offset = %lx",temp );
+	if(PLANE(display)->fb_info->lock) {
 
+		EMGD_DEBUG ("Plane is locked");
+		reg = (unsigned long)READ_MMIO_REG(display, PLANE(display)->plane_reg- 4);
+		EMGD_DEBUG("Plane B start addr = %lx", reg);
+		reg = (unsigned long)READ_MMIO_REG(display,PLANE(display)->plane_reg + 4);
+		EMGD_DEBUG("Plane B start offset = %lx", reg);
+	
+	} else {
+		/* Plane registers are always on 0:2:0 */
+		WRITE_MMIO_REG(display, PLANE(display)->plane_reg + DSP_LINEAR_OFFSET,
+				PLANE(display)->fb_info->visible_offset);
+	}
 	EMGD_TRACE_EXIT;
 	return 0;
 }
@@ -887,13 +903,15 @@ static int igd_set_surface_tnc(igd_display_h display_handle,
 		 *     1) the plane_reg - 4  if async
 		 *     2) plane_reg + DSP_START_OFFSET (+0x1C) if not async
 		 */
-		EMGD_WRITE32(plane_control, MMIO(display) + plane_reg);
-		EMGD_WRITE32(surface->pitch,
-				MMIO(display) + plane_reg + DSP_STRIDE_OFFSET);
-		EMGD_WRITE32(visible_offset,
-			MMIO(display) + plane_reg + DSP_LINEAR_OFFSET);
-		EMGD_WRITE32(surface->offset,
-			MMIO(display) + plane_reg + DSP_START_OFFSET);
+		if(!PLANE(display)->fb_info->lock){
+			EMGD_WRITE32(plane_control, MMIO(display) + plane_reg);
+			EMGD_WRITE32(surface->pitch,
+					MMIO(display) + plane_reg + DSP_STRIDE_OFFSET);
+			EMGD_WRITE32(visible_offset,
+				MMIO(display) + plane_reg + DSP_LINEAR_OFFSET);
+			EMGD_WRITE32(surface->offset,
+				MMIO(display) + plane_reg + DSP_START_OFFSET);
+		}
 
 		EMGD_TRACE_EXIT;
 		return 0;
@@ -1057,6 +1075,21 @@ static int get_plane_info_tnc(void)
 		/* Following are NOT offset by 1 in fb info */
 		buffer_info[0].width++;
 		buffer_info[0].height++;
+		if((plane_control & (BIT27 | BIT30)) == (BIT27 | BIT30)){
+			buffer_info[0].pixel_format = PF_DEPTH_8;
+		}
+		if((plane_control & (BIT28 | BIT26)) == (BIT28 | BIT26)){
+			buffer_info[0].pixel_format = PF_DEPTH_16;
+		}
+		if((plane_control & (BIT28 | BIT27)) == (BIT28 | BIT27)){
+			buffer_info[0].pixel_format = PF_DEPTH_32;
+		}
+		
+		EMGD_DEBUG("Plane A info height==%d, width=%d, pitch=%d", buffer_info[0].height, buffer_info[0].width, buffer_info[0].screen_pitch);
+		reg = (unsigned long)EMGD_READ32(mmio + DSPACNTR - 4);
+		EMGD_DEBUG("Plane A start addr = %lx", reg);
+		reg = (unsigned long)EMGD_READ32(mmio + DSPACNTR + 4);
+		EMGD_DEBUG("Plane A start offset = %lx", reg);
 	}
 
 	/* Check that plane B is active and process it */
@@ -1076,7 +1109,22 @@ static int get_plane_info_tnc(void)
 		/* Following are NOT offset by 1 in fb info */
 		buffer_info[1].width++;
 		buffer_info[1].height++;
-	}
+		if((plane_control & (BIT27 | BIT30)) == (BIT27 | BIT30)){
+			buffer_info[1].pixel_format = PF_DEPTH_8;
+		}
+		if((plane_control & (BIT28 | BIT26)) == (BIT28 | BIT26)){
+			buffer_info[1].pixel_format = PF_DEPTH_16;
+		}
+		if((plane_control & (BIT28 | BIT27)) == (BIT28 | BIT27)){
+			buffer_info[1].pixel_format = PF_DEPTH_32;
+		}
+	
+		EMGD_DEBUG("Plane B info height==%d, width=%d, pitch=%d", buffer_info[1].height, buffer_info[1].width, buffer_info[1].screen_pitch);
+		reg = (unsigned long)EMGD_READ32(mmio + DSPBCNTR - 4);
+		EMGD_DEBUG("Plane B start addr = %lx", reg);
+		reg = (unsigned long)EMGD_READ32(mmio + DSPBCNTR + 4);
+		EMGD_DEBUG("Plane B start offset = %lx", reg);
+}
 
 	EMGD_TRACE_EXIT;
 	return 0;
@@ -1284,32 +1332,32 @@ static int get_pipe_info_tnc(igd_display_h *display)
 	/* For 2nd display pipe, pipe b registers in both 0:2:0 and 0:3:0
 	 * supposed to be programmed to same values. So these values can be
 	 * read from either devices */
-	pipe_conf = EMGD_READ32(mmio_sdvo + PIPEB_CONF);
+	pipe_conf = READ_MMIO_REG_TNC(IGD_PORT_SDVO, PIPEB_CONF);
 
 	if(pipe_conf & BIT(31)) { /* pipe B is active */
 		timing = &mode_context->fw_info->timing_arr[0];
 
-		reg = EMGD_READ32(mmio_sdvo + HTOTAL_B);
+		reg = READ_MMIO_REG_TNC(IGD_PORT_SDVO, HTOTAL_B);
 		timing[1].htotal = (unsigned short)(reg >> 16) & 0x1FFF;
 		timing[1].width = (unsigned short)reg & 0xFFF;
 
-		reg = EMGD_READ32(mmio + HBLANK_B);
+		reg = READ_MMIO_REG_TNC(IGD_PORT_SDVO, HBLANK_B);
 		timing[1].hblank_start = (unsigned short)reg & 0x1FFF;
 		timing[1].hblank_end = (unsigned short)(reg >> 16) & 0x1FFF;
 
-		reg = EMGD_READ32(mmio + HSYNC_B);
+		reg = READ_MMIO_REG_TNC(IGD_PORT_SDVO, HSYNC_B);
 		timing[1].hsync_start = (unsigned short)reg & 0x1FFF;
 		timing[1].hsync_end = (unsigned short)(reg >> 16) & 0x1FFF;
 
-		reg = EMGD_READ32(mmio + VTOTAL_B);
+		reg = READ_MMIO_REG_TNC(IGD_PORT_SDVO, VTOTAL_B);
 		timing[1].vtotal = (unsigned short)(reg >> 16) & 0x1FFF;
 		timing[1].height = (unsigned short)reg & 0xFFF;
 
-		reg = EMGD_READ32(mmio + VBLANK_B);
+		reg = READ_MMIO_REG_TNC(IGD_PORT_SDVO, VBLANK_B);
 		timing[1].vblank_start = (unsigned short)reg & 0x1FFF;
 		timing[1].vblank_end = (unsigned short)(reg >> 16) & 0x1FFF;
 
-		EMGD_READ32(mmio + VSYNC_B);
+		READ_MMIO_REG_TNC(IGD_PORT_SDVO, VSYNC_B);
 		timing[1].vsync_start = (unsigned short)reg & 0x1FFF;
 		timing[1].vsync_end = (unsigned short)(reg >> 16) & 0x1FFF;
 
@@ -1322,20 +1370,22 @@ static int get_pipe_info_tnc(igd_display_h *display)
 			unsigned long dpllb, fpb0, fpb1;
 			unsigned long mb1, mb2, nb, pb1, pb2, pllb_select;
 			unsigned long ref_freq = 0, dclk;
+			unsigned long port_mult = 1;
 			unsigned long temp; /* To store intermediate values b4 dclk */
 			int j;
 
-			dpllb = EMGD_READ32(mmio_sdvo + DPLLBCNTR);
-			fpb0  = EMGD_READ32(mmio_sdvo + FPB0);
-			fpb1  = EMGD_READ32(mmio_sdvo + FPB1);
+			dpllb = READ_MMIO_REG_TNC(IGD_PORT_SDVO, DPLLBCNTR);
+			fpb0  = READ_MMIO_REG_TNC(IGD_PORT_SDVO, FPB0);
+			fpb1  = READ_MMIO_REG_TNC(IGD_PORT_SDVO, FPB1);
 
 			if(dpllb & BIT(31)) {
 
 				mb1 = (fpb0 >> 8) & 0x3F;    /* M1 is bits 13:8 */
-				mb2 = (fpb0) & 0x1F;         /* M1 is bits 5:0 */
-				nb = (fpb0 >> 16) & 0x3F;    /* N is bits 21:16 */
+				mb2 = (fpb0) & 0xFF;         /* M1 is bits 7:0 */
+				nb = (fpb0 >> 16) & 0xFF;    /* N is bits 23:16 */
 				pb1 = (dpllb >> 16) & 0xFF; /* P1 is bits 23:16 */
 
+				port_mult = (((dpllb >> 4) & 0x0F) + 1);
 				/* Check for illegal values of P1
 				 * The bit representation MUST be power of 2
 				 * All other values are illegal including zero.
@@ -1349,6 +1399,12 @@ static int get_pipe_info_tnc(igd_display_h *display)
 				for(j = 0; j < 8; j++) {
 					if(pb1 & BIT(j)) {  /* P1 is divide by 1 to 8 */
 						pb1 = j+1;
+						break;					}
+				}
+
+				for(j = 0; j < 8; j++) {
+					if(nb & BIT(j)) {
+						nb = j+1;
 						break;
 					}
 				}
@@ -1399,11 +1455,11 @@ static int get_pipe_info_tnc(igd_display_h *display)
 				 * integer division
 				 */
 				temp = 1000 * 1000;
-				temp = temp * (5 * (mb1+2) + (mb2+2));
-				temp = temp /(nb+2);
-				dclk = temp/(pb1*pb2);
-
-				dclk = temp * ref_freq;
+				temp = temp * (mb2+2);
+                temp = temp / nb;
+				temp = temp/(pb1*pb2);
+                dclk = temp * ref_freq;
+                dclk = dclk / port_mult;
 
 				if( (dclk == 0) || (ref_freq == 0) ) {
 					EMGD_ERROR_EXIT("Dot Clock/Ref Frequency is Zero!!!");
@@ -1723,7 +1779,7 @@ int request_vblanks_tnc(unsigned long request_for, unsigned char *mmio)
 			EMGD_WRITE32((tmp | BIT7), EMGD_MMIO(mmio) + IER);
 		}
 		vblank_interrupt_state |= request_for;
-		vblank_interrupt_ref_cnt_port4++;
+		vblank_interrupt_ref_cnt_port4 = 1;
 	}
 
 
@@ -1839,7 +1895,7 @@ int end_request_tnc(unsigned long request_for, unsigned char *mmio)
 
 	if (request_for & VBLANK_INT4_PORT4) {
 		/* Decrement reference count */
-		vblank_interrupt_ref_cnt_port4--;
+		vblank_interrupt_ref_cnt_port4 = 0;
 		if (0 > vblank_interrupt_ref_cnt_port4) {
 			EMGD_DEBUG("WARNING:  Disabled vblank INT too many times.");
 			vblank_interrupt_ref_cnt_port4 = 0;
@@ -2044,6 +2100,92 @@ void disable_vblank_callback_tnc(emgd_vblank_callback_h callback_h)
 
 	EMGD_TRACE_EXIT;
 }
+/*!
+ *  checks if the port is enabled
+ */
+unsigned long get_port_control_tnc(unsigned long port_num, unsigned long port_reg)
+{
+	unsigned long port_value=0;
+
+	EMGD_TRACE_ENTER;
+	if( port_num == IGD_PORT_TYPE_SDVOB) {
+		port_value = READ_MMIO_REG_TNC(IGD_PORT_SDVO,port_reg);
+	} else {
+		port_value = READ_MMIO_REG_TNC(IGD_PORT_LVDS,port_reg);
+	}
+
+	EMGD_TRACE_EXIT;
+	return port_value;
+}
+
+
+/*!
+ * locks the plane 
+ * set_surface() and set_display_base_tnc() will not update the registers
+ * when the planes are locked.
+ */
+void lock_planes(igd_display_h display_handle)
+{
+	igd_display_context_t *display = (igd_display_context_t *)display_handle;
+	
+	EMGD_TRACE_ENTER;
+	if(!display){
+		EMGD_ERROR_EXIT("Display is NULL");
+		return;
+	}
+	PLANE(display)->fb_info->lock = TRUE;
+	EMGD_TRACE_EXIT;
+}
+
+
+/*!
+ * unlocks the plane 
+ * resets the lock flag and writes to plane registers
+ * 
+ */
+int unlock_planes(igd_display_h display_handle, unsigned int scrn_num)
+{
+	igd_display_context_t *display = (igd_display_context_t *)display_handle;
+	unsigned long plane_reg;
+	unsigned long plane_control;
+	unsigned long visible_offset;
+
+	EMGD_TRACE_ENTER;
+	if(!display){
+		EMGD_ERROR_EXIT("Display is NULL");
+		return FALSE;
+	}
+
+	/* plane registers are always on 0:2:0, so no need to use _TNC macros */
+	plane_reg = PLANE(display)->plane_reg;
+	plane_control = EMGD_READ32(MMIO(display) + plane_reg);
+
+	/*
+	 *   Write the current plane_control value to the plane_reg
+	 *   Write the surface stride to DSP_STRIDE_OFFSET
+	 *   Write the visible from start of plane to DSP_LINEAR_OFFSET
+	 *   Write the base surface offset to either:
+	 */
+	PLANE(display)->fb_info->lock = FALSE;
+
+	if(scrn_num == PRIMARY_DISPLAY){
+		visible_offset = 0;
+	}else {
+		visible_offset = PLANE(display)->fb_info->visible_offset;
+	}
+
+	EMGD_DEBUG("visible offset= %lx", visible_offset);
+
+	EMGD_WRITE32(plane_control, MMIO(display) + plane_reg);
+	EMGD_WRITE32(PLANE(display)->fb_info->screen_pitch,
+			MMIO(display) + plane_reg + DSP_STRIDE_OFFSET);
+	EMGD_WRITE32(visible_offset,
+			MMIO(display) + plane_reg + DSP_LINEAR_OFFSET);
+	EMGD_WRITE32(PLANE(display)->fb_info->fb_base_offset,
+			MMIO(display) + plane_reg + DSP_START_OFFSET);
+	EMGD_TRACE_EXIT;
+	return TRUE;
+}
 
 
 mode_full_dispatch_t mode_full_dispatch_tnc = {
@@ -2070,5 +2212,8 @@ mode_full_dispatch_t mode_full_dispatch_tnc = {
 	request_vblanks_tnc,
 	end_request_tnc,
 	vblank_occured_tnc,
+	get_port_control_tnc,
+	lock_planes,
+	unlock_planes,
 };
 
diff --git a/drivers/gpu/drm/emgd/emgd/display/pd/cmn/pd.c b/drivers/gpu/drm/emgd/emgd/display/pd/cmn/pd.c
index 0ac0e9c..31e7fd2 100755
--- a/drivers/gpu/drm/emgd/emgd/display/pd/cmn/pd.c
+++ b/drivers/gpu/drm/emgd/emgd/display/pd/cmn/pd.c
@@ -454,13 +454,25 @@ int pd_filter_timings(
 					(!dvo_info->downscale_max_height ||
 						timing->height >= dvo_info->downscale_max_height))
 #endif
-					))) {
+					))){
 
-					if(!i){
-						count++;
-					} else {
-						/* copy timing */
-						olist[j] = *timing;
+ 					if((port->pd_driver->type & (PD_DISPLAY_CRT_EXT |PD_DISPLAY_CRT)) &&
+                                                  (timing->width % 8 != 0) &&
+                                                        !(timing->mode_info_flags&PD_MODE_DTD_USER||timing->mode_info_flags&PD_MODE_DTD)){
+
+							/*Filter non-standard build-in timing at vga display, 
+							Do NOT filter User timing and EDID timing*/
+							EMGD_DEBUG("pd_filter_timings**********: NON_CRT_TIMING: %ux%u@%u",
+							timing->width,
+							timing->height,
+							timing->refresh);
+
+						} else if(!i){
+							count++;
+						} else {
+
+							/* copy timing */
+							olist[j] = *timing;
 
 						/* save the native_dtd timing */
 						if ((timing->width   == display_info->width) &&
diff --git a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/pi.c b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/pi.c
index 8eca6c7..3f8aeab2 100755
--- a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/pi.c
+++ b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/pi.c
@@ -459,6 +459,8 @@ int pi_pd_register(pd_driver_t *pd_driver)
 		/*	SDVO port driver needs the port number */
 		port->callback->port_num = port->port_number;
 
+        /*  SDVO port driver should not reset for seamless mode */
+        port->callback->reset = (init_params->qb_seamless == 1) ? 0 : 1;
 		/* now save the pd_driver in port entry */
 		port->pd_driver = pd_driver;
 
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_connector.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_connector.c
index 280f839..b62c2ca 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_connector.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_connector.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: emgd_connector.c
- * $Revision: 1.2 $
+ * $Revision: 1.3 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2011, Intel Corporation.
  *
@@ -103,7 +103,7 @@ static void emgd_mode_to_kms(igd_display_info_t *emgd_mode,
 	drm_mode->vsync_start = emgd_mode->vsync_start;
 	drm_mode->vsync_end   = emgd_mode->vsync_end;
 	drm_mode->vtotal      = emgd_mode->vtotal;
-	drm_mode->flags       = 0;
+	drm_mode->flags       = emgd_mode->flags;
 	drm_mode->vrefresh    = emgd_mode->refresh;
 
 	drm_mode_set_name(drm_mode);
@@ -473,6 +473,10 @@ static int emgd_connector_mode_valid(struct drm_connector *connector,
                 return MODE_V_ILLEGAL;
         }
 
+		/* We should reject modes that are already rejected by the Port driver */
+		if (!(mode->flags & IGD_MODE_SUPPORTED)) {
+			return MODE_BAD;
+		}
 
         /* We can do some basic checks here, but it is better to call
      * match_mode() in the display/mode module because that function does
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_crtc.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_crtc.c
index 12633d9..4576b6a 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_crtc.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_crtc.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: emgd_crtc.c
- * $Revision: 1.4 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2011, Intel Corporation.
  *
@@ -37,6 +37,7 @@
 
 
 #include "drm_emgd_private.h"
+#include "emgd_drm.h"
 
 #include <memory.h>
 #include <mode_dispatch.h>
@@ -157,42 +158,55 @@ static void emgd_crtc_dpms(struct drm_crtc *crtc, int mode)
 	EMGD_DEBUG("pipe=%d, mode=%d", emgd_crtc->crtc_id, mode);
 	pipe = emgd_crtc->igd_pipe;
 
-
-	switch(mode) {
-	case DRM_MODE_DPMS_ON:
-		EMGD_DEBUG("Checking if we have pipe timings");
-		if (!pipe->timing) {
-			/* If there is no pipe timing, we cannot enable */
-			EMGD_ERROR("No pipe timing, can't enable pipe");
-		} else {
-			EMGD_DEBUG("Calling program pipe");
-			mode_context->kms_dispatch->kms_program_pipe(emgd_crtc);
-
-			EMGD_DEBUG("Calling program plane");
-			mode_context->kms_dispatch->kms_set_plane_pwr(emgd_crtc, TRUE);
-
-			crtc->enabled = true;
-		}
-		break;
-
-	case DRM_MODE_DPMS_STANDBY:
-	case DRM_MODE_DPMS_SUSPEND:
-	case DRM_MODE_DPMS_OFF:
-		if (emgd_crtc->igd_pipe->inuse && crtc->enabled) {
-			EMGD_DEBUG("Calling program plane");
-			mode_context->kms_dispatch->kms_set_plane_pwr(emgd_crtc, FALSE);
-
-			EMGD_DEBUG("Calling program pipe");
-			mode_context->kms_dispatch->kms_set_pipe_pwr(emgd_crtc, FALSE);
-			crtc->enabled = false;
-		} else {
-			EMGD_ERROR("pipe is already off");
+	/* The following check is a work around.KMS tries to program
+	 * both the crtcs and ports (LVDS and SDVO) even if it is in
+	 * single mode. It results in a SIGSEGV.
+	 * By putting this check we ensure that it moves forward
+	 * only if there is a valid context associated  with the
+	 * crtc. We check it by checking the owner of the pipe which
+	 * should not be null.
+	 */
+	if (pipe->owner){
+
+		switch(mode) {
+
+			case DRM_MODE_DPMS_ON:
+				EMGD_DEBUG("Checking if we have pipe timings");
+				if (!pipe->timing) {
+					/* If there is no pipe timing, we cannot enable */
+					EMGD_ERROR("No pipe timing, can't enable pipe=%d, mode=%d",
+							emgd_crtc->crtc_id, DRM_MODE_DPMS_ON );
+				} else {
+					EMGD_DEBUG("Calling program pipe");
+					mode_context->kms_dispatch->kms_program_pipe(emgd_crtc);
+					EMGD_DEBUG("Calling program plane");
+					mode_context->kms_dispatch->
+						kms_set_plane_pwr(emgd_crtc, TRUE);
+
+					crtc->enabled = true;
+				}
+				break;
+
+			case DRM_MODE_DPMS_STANDBY:
+			case DRM_MODE_DPMS_SUSPEND:
+			case DRM_MODE_DPMS_OFF:
+				if (emgd_crtc->igd_pipe->inuse && crtc->enabled) {
+					EMGD_DEBUG("Calling program plane");
+					mode_context->kms_dispatch->
+						kms_set_plane_pwr(emgd_crtc, FALSE);
+
+					EMGD_DEBUG("Calling program pipe");
+					mode_context->kms_dispatch->
+						kms_set_pipe_pwr(emgd_crtc, FALSE);
+					crtc->enabled = false;
+				}else {
+					EMGD_ERROR("pipe is already off");
+				}
+				break;
+			default:
+				break;
 		}
-		break;
-	default:
-		break;
 	}
-
 	EMGD_TRACE_EXIT;
 }
 
@@ -343,11 +357,11 @@ static int emgd_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
 
 	plane_fb_info->width          = fb->width;
 	plane_fb_info->height         = fb->height;
-	plane_fb_info->screen_pitch   = fb->pitches[0];
+	plane_fb_info->screen_pitch   = fb->DRMFB_PITCH;
 	plane_fb_info->flags          = 0;
 	plane_fb_info->allocated      = 1;
 	plane_fb_info->fb_base_offset = emgd_fb->gtt_offset;
-	plane_fb_info->visible_offset = (y * fb->pitches[0]) +
+	plane_fb_info->visible_offset = (y * fb->DRMFB_PITCH) +
 		(x * (fb->bits_per_pixel / 8));
 
 
@@ -645,7 +659,7 @@ static void emgd_crtc_load_lut(struct drm_crtc *crtc)
  *  * flip_work_queued is FALSE
  *  * vblank_expected is FALSE
  */
-int crtc_pageflip_handler(struct drm_device *dev, int port)
+int crtc_pageflip_handler(struct drm_device *dev, int port_num)
 {
 	drm_emgd_priv_t *devpriv = dev->dev_private;
 	emgd_crtc_t *emgd_crtc;
@@ -669,14 +683,26 @@ int crtc_pageflip_handler(struct drm_device *dev, int port)
 	context = devpriv->context;
 
 	/* Look up which CRTC that this flip is for. */
-	if (port == devpriv->primary_port_number) {
-		crtcnum = 0;
-	} else if (port == devpriv->secondary_port_number) {
-		crtcnum = 1;
+	/* If the DC=1, only one of the CRTCs would have a non-NULL owner (display context), 
+ 	 * so we determine the CRTC by looking at the owner field. If the DC is not 1  
+ 	 * (which means both the CRTCs have valid owner fields), we look at the port number to 
+ 	 * determine the right CRTC.
+	 */
+	if (devpriv->crtcs[0]->igd_pipe->owner && devpriv->crtcs[1]->igd_pipe->owner) {
+		if (port_num == devpriv->crtcs[0]->igd_pipe->owner->port_number) {
+			crtcnum = 0;
+		} else {
+			crtcnum = 1;
+		}		
 	} else {
-		return 1;
+		if (devpriv->crtcs[0]->igd_pipe->owner) {
+			crtcnum = 0;
+		} else {
+			crtcnum = 1;
+		}
 	}
 
+
 	emgd_crtc = devpriv->crtcs[crtcnum];
 
 	/* Protect access to CRTC */
@@ -828,7 +854,7 @@ void emgd_flip_worker(struct work_struct *w)
 		/* Rendering complete; program the plane registers */
 		igd_surface.flags        = IGD_SURFACE_DISPLAY;
 		igd_surface.offset       = crtc->newfb->gtt_offset;
-		igd_surface.pitch        = crtc->newfb->base.pitches[0];
+		igd_surface.pitch        = crtc->newfb->base.DRMFB_PITCH;
 		igd_surface.width        = crtc->newfb->base.width;
 		igd_surface.height       = crtc->newfb->base.height;
 		igd_surface.pixel_format = IGD_PF_ARGB32;
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.c
index 4bf32d8..58927c6 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: emgd_drv.c
- * $Revision: 1.145 $
+ * $Revision: 1.147 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -38,8 +38,6 @@
 #include <drm/drm_crtc_helper.h>
 #include <linux/version.h>
 #include <linux/device.h>
-#include <linux/export.h>
-#include <linux/module.h>
 #include <drm/drm_pciids.h>
 #include <intelpci.h>
 #include "drm_emgd_private.h"
@@ -51,6 +49,7 @@
 #include "mode_dispatch.h"
 #include "igd_debug.h"
 #include "splash_screen.h"
+#include "msvdx.h"
 /*
  * Imagination includes.
  */
@@ -61,6 +60,11 @@
 #include <linkage.h>
 #include <sysconfig.h>
 
+#include <linux/version.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
+#include <linux/module.h>
+#include <linux/export.h>
+#endif
 /* For Buffer Class of Texture Stream*/
 /* pvr/services4/3rdparty/emgd_bufferclass/emgd_bc_linux.c */
 extern int emgd_bc_ts_init(void);
@@ -76,8 +80,14 @@ extern void emgd_modeset_init(struct drm_device *dev);
 extern void emgd_modeset_destroy(struct drm_device *dev);
 extern int  msvdx_pre_init_plb(struct drm_device *dev);
 extern int msvdx_shutdown_plb(igd_context_t *context);
+extern int topaz_shutdown_tnc(igd_context_t *context);
+
 extern emgd_drm_config_t config_drm;
 extern int context_count;
+#ifdef SUPPORT_V2G_CAMERA
+/* V2G Camera Module Exported API */
+extern int v2g_start_camera();
+#endif
 
 /* This must be defined whether debug or release build */
 igd_debug_t emgd_debug_flag = {
@@ -165,20 +175,6 @@ MODULE_PARM_DESC(debug_bc_ts, "Debug: Texture Stream");
 module_param_named(debug_bc_ts, emgd_debug_flag.hal.buf_class, short, 0600);
 #endif
 
-static const struct file_operations emgd_driver_fops = {
-	.owner   = THIS_MODULE,
-	.open    = drm_open,
-	.release = drm_release,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
-	.unlocked_ioctl   = drm_ioctl,
-#else
-	.ioctl   = drm_ioctl,
-#endif
-	.mmap    = emgd_mmap,
-	.poll    = drm_poll,
-	.fasync  = drm_fasync,
-	.read    = drm_read,
-};
 
 static struct drm_driver driver;  /* TODO: what? */
 
@@ -289,84 +285,88 @@ static struct drm_ioctl_desc emgd_ioctl[] = {
 	 * clients will get the DRM master to authenticate them, after which
 	 * they'll be able to call the ioctl's.  Random programs that haven't
 	 * authenticated with the DRM master won't be able to call them.
+	 *
+	 * For all private EMGD ioctl's added declaration DRM_UNLOCKED,
+	 * now ioctl's can run in parallel. Before it, without declaration
+	 * DRM_UNLOCKED private EMGD ioctl's can run/work in serial mode only,
+	 * one by one.
 	 */
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ALTER_CURSOR, emgd_alter_cursor,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ALTER_CURSOR_POS, emgd_alter_cursor_pos,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ALTER_DISPLAYS, emgd_alter_displays,
-		DRM_MASTER),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ALTER_OVL, emgd_alter_ovl, DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ALTER_OVL, emgd_alter_ovl, DRM_MASTER|DRM_UNLOCKED),
 	/* Making DRM_IOCTL_IGD_ALTER_OVL2 DRM_AUTH so that libva wayland can 
 	 * call alter_ovl without going through X server.
 	 */
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ALTER_OVL2, emgd_alter_ovl2, DRM_AUTH),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ALTER_OVL2, emgd_alter_ovl2, DRM_AUTH|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_APPCTX_ALLOC, emgd_appcontext_alloc,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_APPCTX_FREE, emgd_appcontext_free,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_DRIVER_SAVE_RESTORE, emgd_driver_save_restore,
-		DRM_MASTER),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ENABLE_PORT, emgd_enable_port, DRM_MASTER),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_ATTRS, emgd_get_attrs, DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ENABLE_PORT, emgd_enable_port, DRM_MASTER|DRM_UNLOCKED),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_ATTRS, emgd_get_attrs, DRM_MASTER|DRM_UNLOCKED),
 	/* Making DRM_IOCTL_IGD_GET_DISPLAY DRM_AUTH so that libva wayland can
 	 * obtain the display handle without going through x server.
 	 */ 
-    EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_DISPLAY, emgd_get_display, DRM_AUTH),
+    EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_DISPLAY, emgd_get_display, DRM_AUTH|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_DRM_CONFIG, emgd_get_drm_config,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_EDID_BLOCK, emgd_get_EDID_block,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_EDID_INFO, emgd_get_EDID_info,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_PIXELFORMATS, emgd_get_pixelformats,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_PORT_INFO, emgd_get_port_info,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GMM_ALLOC_REGION, emgd_gmm_alloc_region,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GMM_ALLOC_SURFACE, emgd_gmm_alloc_surface,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GMM_GET_NUM_SURFACE, emgd_gmm_get_num_surface,
-		DRM_MASTER),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GMM_GET_SURFACE_LIST,
-		emgd_gmm_get_surface_list,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GMM_GET_SURFACE_LIST,emgd_gmm_get_surface_list,
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GMM_FREE, emgd_gmm_free,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GMM_FLUSH_CACHE, emgd_gmm_flush_cache,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	/*
 	 * Externally handled IOCTL's. These are routed to the Imagination Tech
 	 * kernel services.
 	 *   function prototypes in services4/srvkm/env/linux/pvr_drm.h
 	 */
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_RESERVED_1, PVRSRV_BridgeDispatchKM, 0),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_RESERVED_2, PVRDRM_Dummy_ioctl, 0),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_RESERVED_3, PVRDRM_Dummy_ioctl, 0),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_RESERVED_4, PVRDRMIsMaster, DRM_MASTER),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_RESERVED_5, PVRDRMUnprivCmd, 0),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_RESERVED_1, PVRSRV_BridgeDispatchKM, DRM_UNLOCKED),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_RESERVED_2, PVRDRM_Dummy_ioctl, DRM_UNLOCKED),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_RESERVED_3, PVRDRM_Dummy_ioctl, DRM_UNLOCKED),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_RESERVED_4, PVRDRMIsMaster, DRM_MASTER|DRM_UNLOCKED),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_RESERVED_5, PVRDRMUnprivCmd, DRM_UNLOCKED),
 
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_PAN_DISPLAY, emgd_pan_display,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_POWER_DISPLAY, emgd_power_display,
-		DRM_MASTER),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_PWR_ALTER, emgd_pwr_alter, DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_PWR_ALTER, emgd_pwr_alter, DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_QUERY_DC, emgd_query_dc,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_QUERY_MAX_SIZE_OVL, emgd_query_max_size_ovl,
-		DRM_MASTER),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_QUERY_OVL, emgd_query_ovl, DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_QUERY_OVL, emgd_query_ovl, DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_QUERY_MODE_LIST, emgd_query_mode_list,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_GOLDEN_HTOTAL, emgd_get_golden_htotal,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_CONTROL_PLANE_FORMAT, emgd_control_plane_format,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_SET_OVERLAY_DISPLAY, emgd_set_overlay_display,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_QUERY_2D_CAPS_HWHINT, emgd_query_2d_caps_hwhint,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	/*
 	 * For PDUMP
 	 */
@@ -375,41 +375,42 @@ static struct drm_ioctl_desc emgd_ioctl[] = {
 #else
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_RESERVED_6, NULL, 0),
 #endif
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_SET_ATTRS, emgd_set_attrs, DRM_MASTER),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_SET_ATTRS, emgd_set_attrs, DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_SET_PALETTE_ENTRY, emgd_set_palette_entry,
-		DRM_MASTER),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_SET_SURFACE, emgd_set_surface, DRM_MASTER),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_SYNC, emgd_sync, DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_SET_SURFACE, emgd_set_surface, DRM_MASTER|DRM_UNLOCKED),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_SYNC, emgd_sync, DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_DRIVER_PRE_INIT, emgd_driver_pre_init,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_DRIVER_GET_PORTS, emgd_driver_get_ports,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_OVL_INIT_PARAMS, emgd_get_ovl_init_params,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_PAGE_LIST, emgd_get_page_list,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_START_PVRSRV, emgd_start_pvrsrv,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_TEST_PVRSRV, emgd_test_pvrsrv,
-		DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_CHIPSET_INFO, emgd_get_chipset_info,
-		DRM_MASTER),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_DIHCLONE_SET_SURFACE, emgd_dihclone_set_surface, DRM_MASTER),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_PREINIT_MMU, emgd_preinit_mmu, DRM_MASTER),
+		DRM_MASTER|DRM_UNLOCKED),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_DIHCLONE_SET_SURFACE, emgd_dihclone_set_surface, DRM_MASTER|DRM_UNLOCKED),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_PREINIT_MMU, emgd_preinit_mmu, DRM_MASTER|DRM_UNLOCKED),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_UNLOCK_PLANES, emgd_unlock_planes, DRM_MASTER|DRM_UNLOCKED),
 
 	/*
 	 * For VIDEO (MSVDX/TOPAZ
 	 */
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_VIDEO_CMD_BUF, emgd_video_cmd_buf,
-		DRM_AUTH),
+			DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_INIT_VIDEO, emgd_init_video,
-		DRM_AUTH),
+			DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_DEVICE_INFO, emgd_get_device_info,
-		DRM_AUTH),
+			DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_VIDEO_GET_INFO, emgd_video_get_info,
-		DRM_AUTH),
+			DRM_UNLOCKED),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_VIDEO_FLUSH_TLB, emgd_video_flush_tlb,
-		DRM_AUTH),
+			DRM_UNLOCKED),
 
 	/* For Buffer Class of Texture Stream */
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_BC_TS_INIT, emgd_bc_ts_cmd_init,
@@ -464,7 +465,75 @@ static igd_context_t *drm_HAL_context = NULL;
 static igd_dispatch_t *drm_HAL_dispatch = NULL;
 
 
+int emgd_get_display_handle(void **display_handle, int screen_number)
+{
+	emgd_drm_get_display_t drm_data;
+	struct drm_file file_priv;
+	int ret;
+	drm_emgd_priv_t *priv = NULL; 
+	igd_display_pipe_t *primary_pipe = NULL;
+	igd_display_pipe_t *secondary_pipe = NULL;
+	igd_plane_t *primary_plane = NULL;
+	igd_plane_t *secondary_plane = NULL;
+	unsigned long pipe_num = 0;
+	unsigned long port_num = 0;
+
+	EMGD_TRACE_ENTER;
+
+	memset(&drm_data, 0, sizeof(emgd_drm_get_display_t));
+	memset(&file_priv, 0, sizeof(struct drm_file));
 
+	drm_HAL_context->mod_dispatch.dsp_get_planes_pipes(&primary_plane, &secondary_plane, &primary_pipe, &secondary_pipe);
+
+	priv = (drm_emgd_priv_t *)((struct drm_device *)drm_HAL_context->drm_dev)->dev_private;
+	
+	if (0 == screen_number) {
+		if (NULL == priv->primary || NULL == primary_pipe) {
+			EMGD_ERROR("Primary Display & Pipe does not exist!");
+			return 1;
+		}	
+		port_num = priv->primary_port_number;
+		pipe_num = primary_pipe->pipe_num;
+	} else {
+		if (NULL == priv->secondary || NULL == secondary_pipe ) {
+			EMGD_ERROR("Secondary Display does not exist!");
+			return 1;
+		}
+		port_num = priv->secondary_port_number;
+		pipe_num = secondary_pipe->pipe_num;
+	}
+
+	drm_data.port_number = port_num;
+	
+	ret = emgd_get_display(drm_HAL_context->drm_dev, (void *)&drm_data, &file_priv);
+
+	/* set the requested display handle for the caller */
+	*display_handle = ret ? NULL : (void *)drm_data.display_handle;
+	if (NULL != *display_handle) {
+		PIPE(*display_handle)->pipe_num = pipe_num;
+		EMGD_DEBUG("port_num: %lu, pipe_number: %lu", port_num, pipe_num);
+	}
+
+	EMGD_TRACE_EXIT;
+	return ret;
+}
+EXPORT_SYMBOL(emgd_get_display_handle);
+
+int emgd_get_screen_size(int screen_num, unsigned short *width, unsigned short *height)
+{
+	EMGD_TRACE_ENTER;
+
+	if (NULL == width || NULL == height) {
+		return 1;
+	}
+	
+	*width = (unsigned short)config_drm.width;
+	*height = (unsigned short)config_drm.height;
+
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+EXPORT_SYMBOL(emgd_get_screen_size);
 /*!
  * get_pre_driver_info
  *
@@ -1020,7 +1089,10 @@ void emgd_init_display(int merge_mod_params, drm_emgd_priv_t *priv)
 		 *************************************/
 		temp_bg_color = mode_context->display_color;
 		mode_context->display_color = config_drm.ss_data->bg_color;
-		full_clear_fb(mode_context, primary_fb_info, fb);
+		if(mode_context->seamless == FALSE)
+		{
+            full_clear_fb(mode_context, primary_fb_info, fb);
+		}
 		mode_context->display_color = temp_bg_color;
 
 		/*************************************
@@ -1052,6 +1124,7 @@ void emgd_init_display(int merge_mod_params, drm_emgd_priv_t *priv)
 	} else {
 		EMGD_ERROR("framebuffer base address is 0");
 	}
+	mode_context->seamless = FALSE;
 
 	if (!config_drm.kms) {
 		mode_context->context->dispatch.gmm_unmap(fb);
@@ -1125,6 +1198,9 @@ int disp_splash_video(emgd_drm_splash_video_t *sv_data)
 	ovl_info.video_quality.saturation =
 		config_drm.ovl_saturation ?
 		config_drm.ovl_saturation : 0x8000;
+	ovl_info.video_quality.hue =
+		config_drm.ovl_hue ?
+		config_drm.ovl_hue : 0x8000;
 
 	/*
 	 * If any values are set for gamma, turn on the gamma flags
@@ -1393,6 +1469,17 @@ int emgd_driver_load(struct drm_device *dev, unsigned long flags)
 	}
 #endif
 
+#ifdef SUPPORT_V2G_CAMERA
+	/* to start v2g camera module */
+	if (1 == config_drm.v2g) {
+		EMGD_DEBUG("V2G Camera Enabled.");
+		if (0 == v2g_start_camera()) {
+			EMGD_DEBUG("v2g camera started successfully!");
+		} else {
+			EMGD_ERROR("Fail to start v2g camera!");
+		}
+	}
+#endif	
 	/* can not work out how to start PVRSRV */
 	/* Load Buffer Class Module*/
 	emgd_bc_ts_init();
@@ -1644,6 +1731,8 @@ void emgd_driver_lastclose(struct drm_device *dev)
 				priv->saved_registers = CONSOLE_STATE_SAVED;
 			}
 			msvdx_shutdown_plb(drm_HAL_handle);
+			topaz_shutdown_tnc(drm_HAL_handle);
+			
 			igd_driver_shutdown_hal(drm_HAL_handle);
 			igd_driver_shutdown(drm_HAL_handle);
 
@@ -1797,10 +1886,17 @@ void emgd_driver_preclose(struct drm_device *dev, struct drm_file *priv)
 void emgd_driver_postclose(struct drm_device *dev, struct drm_file *priv)
 {
 	int ret = 0;
+	drm_emgd_priv_t *dev_priv = dev->dev_private;
+	igd_context_t *context = dev_priv->context;
 
 	EMGD_TRACE_ENTER;
 	mutex_lock(&dev->struct_mutex);
 
+	/* Calling the msvdx_postclose_check before PVRSRVRelease */
+	if (priv) {
+		msvdx_postclose_check(context, (void *) priv);
+	}
+
 	ret = PVRSRVRelease(dev, priv);
 
 	mutex_unlock(&dev->struct_mutex);
@@ -2366,6 +2462,26 @@ static const struct dev_pm_ops emgd_pm_ops = {
 static struct pci_driver emgd_pci_driver = EMGD_PCI_DRIVER;
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+#define IOCTL unlocked_ioctl
+#else
+#define IOCTL ioctl
+#endif
+
+#define EMGD_FOPS { \
+    .owner   = THIS_MODULE,        \
+    .open    = drm_open,           \
+    .release = drm_release,        \
+	.IOCTL   = drm_ioctl,		   \
+    .mmap    = emgd_mmap,          \
+    .poll    = drm_poll,           \
+    .fasync  = drm_fasync,         \
+    .read    = drm_read,           \
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
+static const struct file_operations emgd_driver_fops = EMGD_FOPS;
+#endif
 /**
  * DRM Sub driver entry points
  */
@@ -2393,7 +2509,12 @@ static struct drm_driver driver = {
 	.get_reg_ofs        = drm_core_get_reg_ofs,
 #endif
 	.ioctls             = emgd_ioctl,
-	.fops = &emgd_driver_fops,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
+    .fops                = &emgd_driver_fops,
+#else
+    .fops                = EMGD_FOPS,
+#endif
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
 	.pci_driver          = EMGD_PCI_DRIVER,
 #endif
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.h b/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.h
index c7e334a..15c88b2 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.h
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.h
@@ -198,6 +198,8 @@ int emgd_set_overlay_display(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv);
 int emgd_query_2d_caps_hwhint(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv);
+int emgd_unlock_planes(struct drm_device *dev, void *arg,
+    struct drm_file *file_priv);
 /* For Buffer Class of Texture Stream */
 int emgd_bc_ts_cmd_init(struct drm_device *dev, void *arg, struct drm_file *file_priv);
 int emgd_bc_ts_cmd_uninit(struct drm_device *dev, void *arg, struct drm_file *file_priv);
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_encoder.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_encoder.c
index 72b3d3e..478863d 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_encoder.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_encoder.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: emgd_encoder.c
- * $Revision: 1.3 $
+ * $Revision: 1.4 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2011, Intel Corporation.
  *
@@ -88,46 +88,46 @@ const struct drm_encoder_helper_funcs emgd_encoder_helper_funcs = {
  */
 static void emgd_encoder_dpms(struct drm_encoder *encoder, int mode)
 {
+	emgd_crtc_t *emgd_crtc = container_of(encoder->crtc, emgd_crtc_t, base);
 	emgd_encoder_t *emgd_encoder = container_of(encoder, emgd_encoder_t, base);
 	igd_display_port_t *igd_port = emgd_encoder->igd_port;
-	unsigned long       new_port_state;
 
 	EMGD_TRACE_ENTER;
 
-
-	switch(mode) {
-		case DRM_MODE_DPMS_ON:
-			new_port_state = IGD_POWERSTATE_D0;
-			break;
-
-		case DRM_MODE_DPMS_STANDBY:
-		case DRM_MODE_DPMS_SUSPEND:
-		case DRM_MODE_DPMS_OFF:
-			new_port_state = IGD_POWERSTATE_D3;
-			break;
-
-		default:
+	/* The following check is a work around for KMS tries to
+	 * program both the crtcs and ports (LVDS and SDVO)
+	 * even if it is in single mode. It results in a SIGSEGV.
+	 * By putting this check we ensure that it moves forward
+	 * only if there is a valid context associated  with the
+	 * port.
+	 */
+	if(emgd_crtc->igd_pipe->owner) {
+
+		EMGD_DEBUG("Setting port %lx power to %d",
+					igd_port->port_number, mode);
+
+		switch(mode) {
+
+			case DRM_MODE_DPMS_ON:
+				mode_context->kms_dispatch->kms_program_port(emgd_encoder,
+						IGD_DISPLAY_ENABLE);
+				mode_context->kms_dispatch->kms_post_program_port(emgd_encoder,
+						TRUE);
+				break;
+
+			case DRM_MODE_DPMS_STANDBY:
+			case DRM_MODE_DPMS_SUSPEND:
+			case DRM_MODE_DPMS_OFF:
+				mode_context->kms_dispatch->kms_program_port(emgd_encoder,
+						IGD_DISPLAY_DISABLE);
+				break;
+
+			default:
 			EMGD_ERROR_EXIT("Unsupported DPMS mode");
 			return;
-	}
-
-
-	if (new_port_state == IGD_POWERSTATE_D3 &&
-		emgd_encoder->flags & ENCODER_FLAG_FIRST_DPMS) {
-
-		EMGD_DEBUG("Not setting initial port %lx power to %lx",
-			igd_port->port_number, new_port_state);
-		emgd_encoder->flags &= ~ENCODER_FLAG_FIRST_DPMS;
-	} else {
-		EMGD_DEBUG("Setting port %lx power to %lx",
-			igd_port->port_number, new_port_state);
-		igd_port->pd_driver->set_power(igd_port->pd_context,
-			new_port_state);
-
-		if (new_port_state == IGD_POWERSTATE_D0) {
-			mode_context->kms_dispatch->kms_post_program_port(emgd_encoder,
-				TRUE);
 		}
+	}else {
+		EMGD_DEBUG("Owner is null for this pipe");
 	}
 
 	EMGD_TRACE_EXIT;
@@ -349,12 +349,13 @@ static void emgd_encoder_commit(struct drm_encoder *encoder)
 		emgd_crtc = container_of(encoder->crtc, emgd_crtc_t, base);
 		pipe      = emgd_crtc->igd_pipe;
 
-		mode_context->kms_dispatch->kms_program_port(emgd_encoder,
-	    		IGD_DISPLAY_ENABLE);
+/*		mode_context->kms_dispatch->kms_program_port(emgd_encoder,
+	    		IGD_DISPLAY_ENABLE);*/
 /*
 		port->pd_driver->set_mode(port->pd_context, pipe->timing,
-								1<<pipe->pipe_num);
-*/
+								1<<pipe->pipe_num);*/
+		
+
 		encoder_funcs = encoder->helper_private;
 		encoder_funcs->dpms(encoder, DRM_MODE_DPMS_ON);
 
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_fb.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_fb.c
index d75fe81..8683477 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_fb.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_fb.c
@@ -34,6 +34,12 @@
 #include <linux/kernel.h>
 #include <linux/device.h>
 #include <linux/fb.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0)
+#include <linux/export.h>
+#else
+#include <linux/module.h>
+#endif
 #include <drmP.h>
 #include <drm.h>
 #include <drm_crtc.h>
@@ -110,12 +116,12 @@ static void emgd_fbdev_destroy(drm_emgd_priv_t *priv);
  */
 int emgd_framebuffer_init(struct drm_device *dev,
 			emgd_framebuffer_t *emgd_fb,
-			struct drm_mode_fb_cmd2 *mode_cmd,
+			struct DRM_MODE_FB_CMD_TYPE *mode_cmd,
 			unsigned long offset);
 static struct drm_framebuffer *emgd_user_framebuffer_create(
 								struct drm_device *dev,
 								struct drm_file *filp,
-								struct drm_mode_fb_cmd2 *r);
+								struct DRM_MODE_FB_CMD_TYPE *r);
 RETURN_PROBE_TYPE  emgd_fb_probe(struct drm_device *dev);
 static int emgd_fb_panic(struct notifier_block *n,
 			unsigned long res,
@@ -144,6 +150,37 @@ static const struct drm_framebuffer_funcs emgd_fb_funcs = {
 };
 
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0)
+int convert_bpp_depth_to_drm_pixel_formal(unsigned int bpp, unsigned int depth)
+{
+	switch(bpp){
+		case 8:
+			if(depth == 8)
+				return DRM_FORMAT_RGB332;
+
+		case 16:
+			if(depth == 15)
+				return DRM_FORMAT_XRGB1555;
+			else
+				return DRM_FORMAT_RGB565;
+
+		case 24:
+			return DRM_FORMAT_RGB888;
+
+		case 32:
+            if(depth == 24)
+                    return DRM_FORMAT_XRGB8888;
+            else if (depth == 30)
+                    return DRM_FORMAT_XRGB2101010;
+            else
+                    return DRM_FORMAT_ARGB8888;
+
+		default:
+            EMGD_ERROR("bad bpp %d, assuming x8r8g8b8 pixel format", bpp);
+            return DRM_FORMAT_XRGB8888;
+	}
+}
+#endif
 
 /*
  * Called if something fails while trying to set up framebuffer based
@@ -815,7 +852,7 @@ EXPORT_SYMBOL(emgd_fb_probe);
 static struct drm_framebuffer *emgd_user_framebuffer_create(
 								struct drm_device *dev,
 								struct drm_file *filp,
-								struct drm_mode_fb_cmd2 *mode_cmd)
+								struct DRM_MODE_FB_CMD_TYPE *mode_cmd)
 {
 	emgd_framebuffer_t *emgd_fb;
 	int                 ret;
@@ -830,7 +867,7 @@ static struct drm_framebuffer *emgd_user_framebuffer_create(
 
 	/* Create a framebuffer instance */
 	ret = emgd_framebuffer_init(dev, emgd_fb, mode_cmd,
-			(unsigned long)mode_cmd->handles[0]);
+			(unsigned long)mode_cmd->DRMMODE_HANDLE);
 	if (ret) {
 		EMGD_ERROR("Failed to create framebuffer instance.");
 		/* TODO: Free the allocation at mode_cmd->handle */
@@ -869,7 +906,7 @@ static struct drm_framebuffer *emgd_user_framebuffer_create(
  */
 int emgd_framebuffer_init(struct drm_device *dev,
 		emgd_framebuffer_t *emgd_fb,
-		struct drm_mode_fb_cmd2 *mode_cmd,
+		struct DRM_MODE_FB_CMD_TYPE *mode_cmd,
 		unsigned long handle)
 {
 	drm_emgd_priv_t *dev_priv = NULL;
@@ -1165,7 +1202,7 @@ static int emgd_fb_create(emgd_fbdev_t *emgd_fbdev,
 	drm_emgd_priv_t        *priv    = emgd_fbdev->priv;
 	struct drm_device      *dev     = priv->ddev;
 	struct fb_info         *info    = NULL;
-	struct drm_mode_fb_cmd2  mode_cmd;
+	struct drm_mode_fb_cmd  mode_cmd;
 	struct drm_framebuffer *fb       = NULL;
 	igd_context_t          *context  = NULL;
 	int                     ret;
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_fbcon.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_fbcon.c
index 9a075e3..f267fcf 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_fbcon.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_fbcon.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: emgd_fbcon.c
- * $Revision: 1.4 $
+ * $Revision: 1.5 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2011, Intel Corporation.
  *
@@ -36,12 +36,16 @@
 #include <drmP.h>
 #include <drm_crtc_helper.h>
 #include <linux/vga_switcheroo.h>
-#include <linux/export.h>
 
 
 #include "user_config.h"
 #include "drm_emgd_private.h"
 #include "mode_dispatch.h"
+#include "emgd_drm.h"
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0)
+#include <linux/export.h>
+#endif
 
 
 /*------------------------------------------------------------------------------
@@ -58,8 +62,10 @@ extern emgd_drm_config_t config_drm;
  */
 extern int emgd_framebuffer_init(struct drm_device *dev,
 			emgd_framebuffer_t *emgd_fb,
-			struct drm_mode_fb_cmd2 *mode_cmd,
+			struct DRM_MODE_FB_CMD_TYPE *mode_cmd,
 			unsigned long handle);
+extern int convert_bpp_depth_to_drm_pixel_formal(unsigned int bpp,
+        unsigned int depth);
 
 
 /* Sets up initial display configuration */
@@ -125,7 +131,7 @@ static void fill_fix(emgd_fbdev_t *emgd_fbdev, struct fb_info *info)
 	info->fix.ywrapstep   = 0;
 	info->fix.accel       = FB_ACCEL_NONE;
 	info->fix.type_aux    = 0;
-	info->fix.line_length = fb->pitches[0];
+	info->fix.line_length = fb->DRMFB_PITCH;
 }
 
 
@@ -247,7 +253,8 @@ static int alloc_initial_fb(emgd_fbdev_t *emgd_fbdev)
 	igd_context_t          *context;
 	int                     ret;
 	unsigned long           size;
-	struct drm_mode_fb_cmd2  mode_cmd;
+	struct DRM_MODE_FB_CMD_TYPE mode_cmd;
+	unsigned int bpp, depth;
 
 	EMGD_TRACE_ENTER;
 
@@ -258,6 +265,8 @@ static int alloc_initial_fb(emgd_fbdev_t *emgd_fbdev)
    	priv->initfb_info.width        = config_drm.width;
 	priv->initfb_info.height       = config_drm.height;
 	priv->initfb_info.pixel_format = IGD_PF_ARGB32;
+	bpp = IGD_PF_BPP(priv->initfb_info.pixel_format);
+	depth = bpp;
 
 	/* The initial framebuffer is a displayable surface. */
 	priv->initfb_info.flags = (priv->initfb_info.flags & IGD_FB_FLAGS_MASK) |
@@ -292,14 +301,16 @@ static int alloc_initial_fb(emgd_fbdev_t *emgd_fbdev)
 
 
 	/* Initialize emgd_framebuffer_t */
-	mode_cmd.handles[0] = EMGD_INITIAL_FRAMEBUFFER;
-	mode_cmd.pitches[0]  = priv->initfb_info.screen_pitch;
+	mode_cmd.DRMMODE_HANDLE = EMGD_INITIAL_FRAMEBUFFER;
+	mode_cmd.DRMFB_PITCH  = priv->initfb_info.screen_pitch;
 	mode_cmd.width  = priv->initfb_info.width;
 	mode_cmd.height = priv->initfb_info.height;
-	mode_cmd.pixel_format = drm_mode_legacy_fb_format(
-					IGD_PF_BPP(priv->initfb_info.pixel_format),
-					IGD_PF_BPP(priv->initfb_info.pixel_format)  /* Ok for 32bpp, may not work for 16bpp */
-					);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0)
+    mode_cmd.pixel_format = convert_bpp_depth_to_drm_pixel_formal(bpp, depth);
+#else
+	mode_cmd.bpp    = bpp;
+    mode_cmd.depth  = depth;
+#endif
 
 	ret = emgd_framebuffer_init(dev, emgd_fbdev->emgd_fb, &mode_cmd,
 			EMGD_INITIAL_FRAMEBUFFER);
@@ -523,12 +534,67 @@ static int emgd_fbcon_check_var(struct fb_var_screeninfo *var,
 
 
 
+/*
+ * FIXME: Should this fbcon function be implemented this way?
+ * The logic in this function needs to be there in some fbcon function;
+ * through debugging, it was noticed that this particular function and
+ * fb_pan_display are called whenever we do a VT switch (away from Weston).
+ * This function was chosen arbitrarily to flip to the initial framebuffer.
+ */
 static int emgd_fbcon_set_par(struct fb_info *info)
 {
 	int ret = 0;
+	struct drm_device *dev;
+	emgd_fbdev_t *emgd_fbdev;
+	emgd_crtc_t *emgd_crtc;
+	igd_context_t *context;
+	drm_emgd_priv_t *priv;
+	igd_display_pipe_t *pipe;
+	igd_surface_t surface = {0};
 
 	EMGD_TRACE_ENTER;
 
+	emgd_fbdev = info->par;
+	priv	   = emgd_fbdev->priv;
+	dev		   = priv->ddev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+
+	/* Determine the active crtc by looking for a non-NULL display context.
+	 * We might have to modify this logic if DC is not 1 (that is for single
+	 * and extended modes, which we do not fully support at the kms level at
+	 * this moment)
+	 */
+	if (priv->crtcs[0]->igd_pipe->owner) {
+		emgd_crtc = priv->crtcs[0];
+	} else {
+		emgd_crtc = priv->crtcs[1];
+	}
+
+	pipe = emgd_crtc->igd_pipe;
+
+	/* During the initial modeset, when this function is called, it was observed
+	 * the pipe timing and plane were NULL; therefore, this guard here is necesary.
+     */
+	if(!pipe->timing || !pipe->plane) {
+		return ret;
+	}
+
+	/* This logic is very similar to what is done in the flip worker; all that
+     * we are doing here is re-attaching the initial framebuffer to the crtc
+     * and flipping it onto the screen using set_surface.
+     * FIXME: Should we also do a modeset to be safe?
+     */
+	emgd_crtc->newfb = emgd_fbdev->emgd_fb;
+
+	surface.flags        = IGD_SURFACE_DISPLAY;
+    surface.offset       = emgd_crtc->newfb->gtt_offset;
+    surface.pitch        = emgd_crtc->newfb->base.DRMFB_PITCH;
+    surface.width        = emgd_crtc->newfb->base.width;
+    surface.height       = emgd_crtc->newfb->base.height;
+    surface.pixel_format = IGD_PF_ARGB32;
+
+    ret = context->dispatch.set_surface(pipe->owner, IGD_PRIORITY_NORMAL,
+						IGD_BUFFER_DISPLAY, &surface, NULL, 0);
 	// set mode here:  crtc->set_config
     // look at drm_fb_helper_set_par for reference
 
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_interface.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_interface.c
index 9a5a4bc..5625442 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_interface.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_interface.c
@@ -1,6 +1,6 @@
 /*-----------------------------------------------------------------------------
  * Filename: emgd_interface.c
- * $Revision: 1.190 $
+ * $Revision: 1.191 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -1262,6 +1262,7 @@ int emgd_pan_display(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv)
 {
 	emgd_drm_pan_display_t *drm_data = arg;
+	igd_context_t *context = (igd_context_t *) handle;
 
 	EMGD_TRACE_ENTER;
 
@@ -1272,6 +1273,10 @@ int emgd_pan_display(struct drm_device *dev, void *arg,
 		drm_data->x_offset,
 		drm_data->y_offset);
 
+	/* after call this func, we are not in clone mode, is it? */
+	if (drm_data->rtn == 0) {
+		context->mod_dispatch.in_dih_clone_mode = false;
+	}
 
 	EMGD_DEBUG("drm_data->rtn = %ld", drm_data->rtn);
 	EMGD_TRACE_EXIT;
@@ -1600,7 +1605,8 @@ int emgd_dihclone_set_surface(struct drm_device *dev, void *arg,
 	igd_surface_t surf;
 	unsigned long dc ;
 	unsigned long x_offset, y_offset;
-
+	drm_emgd_priv_t *priv = dev->dev_private;	
+		
 	EMGD_TRACE_ENTER;
 
 	memset(&surf, 0, sizeof(igd_surface_t));
@@ -1652,7 +1658,10 @@ int emgd_dihclone_set_surface(struct drm_device *dev, void *arg,
 			if(context->mod_dispatch.dih_clone_display == CLONE_PRIMARY) {
 
 				EMGD_DEBUG(" emgd_dihclone_set_surface: setting DIH1");
-				surf.offset = pipe1->plane->fb_info->fb_base_offset;
+				if (pipe1->owner->port_number == priv->primary_port_number)
+					surf.offset = pipe1->plane->fb_info->fb_base_offset;
+				else
+					surf.offset = pipe2->plane->fb_info->fb_base_offset;
 				/* Call the HAL: */
 				drm_data->rtn = dispatch->set_surface(display,
 						IGD_PRIORITY_NORMAL,
@@ -1692,7 +1701,10 @@ int emgd_dihclone_set_surface(struct drm_device *dev, void *arg,
 						NULL,
 						0);
 				display = context->mod_dispatch.dsp_display_list[IGD_DC_SECONDARY(dc)];
-				surf.offset = pipe2->plane->fb_info->fb_base_offset;
+				if (pipe1->owner->port_number == priv->secondary_port_number)
+					surf.offset = pipe1->plane->fb_info->fb_base_offset;
+				else
+					surf.offset = pipe2->plane->fb_info->fb_base_offset;
 				/* Call the HAL: */
 				drm_data->rtn = dispatch->set_surface(display,
 						IGD_PRIORITY_NORMAL,
@@ -1714,13 +1726,14 @@ int emgd_dihclone_set_surface(struct drm_device *dev, void *arg,
 
 			if( drm_data->dih_clone_display == CLONE_PRIMARY){
 				y_offset = 0;
-				display = context->mod_dispatch.dsp_display_list[IGD_DC_SECONDARY(dc)];
 			} else {
 				y_offset = (pipe1->plane->fb_info->height / 2);
-				display = context->mod_dispatch.dsp_display_list[IGD_DC_PRIMARY(dc)];
 			}
 
 			/* Call Pan display to affect pt_info offsets */
+			display = context->mod_dispatch.dsp_display_list[IGD_DC_PRIMARY(dc)];
+			drm_data->rtn = dispatch->pan_display(display, x_offset, y_offset);
+			display = context->mod_dispatch.dsp_display_list[IGD_DC_SECONDARY(dc)];
 			drm_data->rtn = dispatch->pan_display(display, x_offset, y_offset);
 		} else { /* in DIH mode */
 
@@ -1745,9 +1758,15 @@ int emgd_dihclone_set_surface(struct drm_device *dev, void *arg,
 
 			/* primary display */
 			if( drm_data->dih_clone_display == CLONE_PRIMARY){
-				surf.offset = pipe1->plane->fb_info->fb_base_offset;
+				if (pipe1->owner->port_number == priv->primary_port_number)
+					surf.offset = pipe1->plane->fb_info->fb_base_offset;
+				else
+					surf.offset = pipe2->plane->fb_info->fb_base_offset;
 			} else {
-				surf.offset = pipe2->plane->fb_info->fb_base_offset;
+				if (pipe1->owner->port_number == priv->secondary_port_number)
+					surf.offset = pipe1->plane->fb_info->fb_base_offset;
+				else
+					surf.offset = pipe2->plane->fb_info->fb_base_offset;
 			}
 
 			display = context->mod_dispatch.dsp_display_list[IGD_DC_PRIMARY(dc)];
@@ -2360,12 +2379,12 @@ int emgd_video_cmd_buf(struct drm_device *dev, void *arg,
 	switch (drm_data->engine) {
 		case PSB_ENGINE_VIDEO:
 			drm_data->rtn = process_video_decode_plb(context, drm_data->offset,
-								drm_data->kernel_virt_addr,
+								drm_data->mem_handle,
 								&(drm_data->fence_id));
 			break;
 		case TNC_ENGINE_ENCODE:
 			drm_data->rtn = process_video_encode_tnc(context, drm_data->offset,
-								drm_data->kernel_virt_addr,
+								drm_data->mem_handle,
 								&(drm_data->fence_id));
 			break;
 		default:
@@ -2430,10 +2449,12 @@ int emgd_init_video(struct drm_device *dev, void *arg,
 			break;
 		case PSB_ENGINE_VIDEO:
 			drm_data->rtn = msvdx_init_plb(drm_data->base0, drm_data->base1,
-						       drm_data->fw_priv, drm_data->fw_size, 0);
+						       drm_data->mem_handle_fw,0);
 			break;
 		case TNC_ENGINE_ENCODE:
-			drm_data->rtn = topaz_init_tnc(drm_data->wb_offset, drm_data->wb_addr, drm_data->firm_addr);
+			drm_data->rtn = topaz_init_tnc(drm_data->wb_offset,
+					                       drm_data->mem_handle_writeback,
+					                       drm_data->mem_handle_enc_fw);
 			break;
 		default:
 			break;
@@ -2451,7 +2472,7 @@ int emgd_init_video(struct drm_device *dev, void *arg,
 	case CMD_VIDEO_CLOSE_CONTEXT :
 		switch (drm_data->engine) {
 		case PSB_ENGINE_VIDEO:
-			drm_data->rtn = msvdx_close_context(context);
+			drm_data->rtn = msvdx_close_context(context, drm_data->context_id);
 			break;
 		default:
 			break;
@@ -2460,7 +2481,7 @@ int emgd_init_video(struct drm_device *dev, void *arg,
 	case CMD_VIDEO_CREATE_CONTEXT:
 		switch (drm_data->engine) {
 		case PSB_ENGINE_VIDEO:
-			drm_data->rtn = msvdx_create_context(context);
+			drm_data->rtn = msvdx_create_context(context, (void *) file_priv, drm_data->context_id);
 			break;
 		default:
 			break;
@@ -2471,6 +2492,9 @@ int emgd_init_video(struct drm_device *dev, void *arg,
 		case PSB_ENGINE_VIDEO:
 			drm_data->rtn = msvdx_shutdown_plb(context);
 			break;
+		case TNC_ENGINE_ENCODE:
+			drm_data->rtn = topaz_shutdown_tnc(context);
+			break;
 		default:
 			break;
 		}
@@ -2542,7 +2566,7 @@ int emgd_video_flush_tlb(struct drm_device *dev, void *arg,
 
 	switch(drm_data->engine) {
 		case PSB_ENGINE_VIDEO:
-			drm_data->rtn = msvdx_flush_tlb(context);
+			drm_data->rtn = 0;
 			break;
 		case TNC_ENGINE_ENCODE:
 			drm_data->rtn = topaz_flush_tnc(context);
@@ -2728,3 +2752,14 @@ int emgd_query_2d_caps_hwhint(struct drm_device *dev, void *arg,
 
     return 0;
 }
+
+int emgd_unlock_planes(struct drm_device *dev, void *arg,
+			struct drm_file *file_priv)
+{
+    emgd_drm_unlock_planes_t *drm_data;
+    drm_data = arg;
+
+    /* do plane unlocking */
+	drm_data->rtn = dispatch->unlock_planes(drm_data->display_handle, drm_data->screen_num);
+    return 0;
+}
diff --git a/drivers/gpu/drm/emgd/emgd/drm/user_config.c b/drivers/gpu/drm/emgd/emgd/drm/user_config.c
index cea78e1..be7c70b 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/user_config.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/user_config.c
@@ -1,252 +1,257 @@
-/*
- *-----------------------------------------------------------------------------
- * Filename: user_config.c
- * $Revision: 1.24 $
- *-----------------------------------------------------------------------------
- * Copyright (c) 2002-2010, Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- *
- *-----------------------------------------------------------------------------
- * Description:
- *  A file that contains the initial display configuration information of the
- *  EMGD kernel module.  A user can edit this file in order to affect the way
- *  that the kernel initially configures the displays.  This file is compiled
- *  into the EMGD kernel module.
- *-----------------------------------------------------------------------------
- */
-#include "user_config.h"
-
-#warning ****
-#warning **** This driver has NOT been configured for your system.  You are
-#warning **** building with a sample user_config.c configuration that may or
-#warning **** may not meet your needs.  It is recommended that you run CED to
-#warning **** generate an appropriate configuration or see the User Guide
-#warning **** for more information about driver configuration.
-#warning ****
-
-
-/*
- * One array of igd_display_info_t structures should exist for each port that
- * needs to provide a DTD list.  Each igd_display_info_t contains the DTD
- * information for a given resolution/refresh-rate.  This is especially needed
- * for analog/VGA ports.
- */
-
-#define TUNNELCREEK 1
-#define POULSBO 0
-
-#if TUNNELCREEK
-static igd_display_info_t dtd_config1_port4_dtdlist[] = {
-	{
-		1366,   /* Width */
-		768,    /* Height */
-		60,     /* Refresh Rate */
-		72300,  /* Dot Clock */
-		1525,   /* Horizontal Total (horizontal synch end) */
-		1365,   /* Horizontal Blank Start (h_active-1) */
-		1525,   /* Horizontal Blank End (start + h_blank) */
-		1413,   /* Horizontal Sync Start (h_active+h_synch-1) */
-		1445,   /* Horizontal Sync End (start + h_syncp) */
-		789,    /* Vertical Total (Vertical synch end) */
-		767,    /* Vertical Blank Start (v_active-1) */
-		789,    /* Vertical Blank End (start + v_blank) */
-		770,    /* Vertical Sync Start (v_active+v_synch-1) */
-		775,    /* Vertical Sync End (start + v_synchp) */
-		0,  /* Mode Number */
-		0x20000,    /* Flags */
-		0,  /* X Offset */
-		0,  /* Y Offset */
-		NULL,   /* pd extension pointer */
-		0, 0   /* mode extension pointer */
-	},
-};
-#endif
-
-#if POULSBO
-static igd_display_info_t dtd_config1_port4_dtdlist[] = {
-	{
-		1024,			/* Width */
-		768,				/* Height */
-		60,				/* Refresh Rate */
-		65000,			/* Dot Clock (in KHz) */
-		1343,			/* Horizontal Total (horizontal synch end) */
-		1023,			/* Horizontal Blank Start (h_active-1) */
-		1343,			/* Horizontal Blank End (start + h_blank) */
-		1047,			/* Horizontal Sync Start (h_active+h_synch-1) */
-		1183,			/* Horizontal Sync End (start + h_syncp) */
-		805,				/* Vertical Total (Vertical synch end) */
-		767,				/* Vertical Blank Start (v_active-1) */
-		805,				/* Vertical Blank End (start + v_blank) */
-		770,				/* Vertical Sync Start (v_active+v_synch-1) */
-		776,				/* Vertical Sync End (start + v_synchp) */
-		0,				/* Mode Number */
-		0x20000,			/* Flags */
-		0,				/* X Offset */
-		0,				/* Y Offset */
-		NULL,			/* pd extension pointer */
-		0, 0				/* mode extension pointer */
-	},
-};
-#endif
-
-static igd_param_attr_t attrs_config1_port4[] = {
-	{0x46, 100},
-#if POULSBO
-	{0x1a, 24},
-#endif
-#if TUNNELCREEK
-	{0x47, 20300},
-#endif
-};
-
-static emgd_drm_splash_screen_t splash_screen_data = {
-	0x000000,		/* bg_color */
-	0,			/* x */
-	0,			/* y */
-	0,			/* width */
-	0,			/* height */
-};
-
-static emgd_drm_splash_video_t splash_video_data = {
-	0,			/* offset */
-	0,			/* pixel_format */
-	0,			/* src_width */
-	0,			/* src_height */
-	0,			/* src_pitch */
-	0,			/* dst_x */
-	0,			/* dst_y */
-	0,			/* dst_width */
-	0,			/* dst_height */
-};
-
-static igd_param_t config_params_config1 = {
-	1*256*1024,		/* Page request */
-	0,		/* Max frame buffer size */
-	1,		/* Preserve registers */
-	0x6,		/* Display flags */
-	{ 4, 2, 0, 0, 0 },		/* Display port order */
-	{		/* Display Params */
-		{		/* Port */
-			4,		/* Display port number */
-			0x180,		/* Parameters present */
-			0x0,		/* EDID flag */
-			0x5,		/* Flags when EDID is available */
-			0x5,		/* Flags when EDID is not available */
-			0,		/* DDC GPIO pins */
-			0,		/* DDC speed */
-			0,		/* DDC DAB */
-			0,		/* I2C GPIO pins */
-			0,		/* I2C speed */
-			0,		/* I2C DAB */
-			{		/* Flat Panel Info */
-				0,		/* Flat Panel width */
-				0,		/* Flat Panel height */
-				0,		/* Flat Panel power method */
-				0,		/* VDD active & DVO clock/data active */
-				0,		/* DVO clock/data active & backlight enable */
-				0,		/* backlight disable & DVO clock/data inactive */
-				0,		/* DVO clock/data inactive & VDD inactive */
-				0			/* VDD inactive & VDD active */
-			},
-			{		/* DTD Info */
-				sizeof(dtd_config1_port4_dtdlist)/sizeof(igd_display_info_t),		/* Number of DTDs */
-				dtd_config1_port4_dtdlist		/* DTD name */
-			},
-			{		/* Attribute Info */
-				sizeof(attrs_config1_port4)/sizeof(igd_param_attr_t),		/* Number of attributes */
-				attrs_config1_port4		/* Attr name */
-			}
-		},
-		{		/* Port */
-			2,		/* Display port number */
-			0x0,		/* Parameters present */
-			0x0,		/* EDID flag */
-			0x5,		/* Flags when EDID is available */
-			0x5,		/* Flags when EDID is not available */
-			0,		/* DDC GPIO pins */
-			0,		/* DDC speed */
-			0,		/* DDC DAB */
-			0,		/* I2C GPIO pins */
-			0,		/* I2C speed */
-			0,		/* I2C DAB */
-			{		/* Flat Panel Info */
-				0,		/* Flat Panel width */
-				0,		/* Flat Panel height */
-				0,		/* Flat Panel power method */
-				0,		/* VDD active & DVO clock/data active */
-				0,		/* DVO clock/data active & backlight enable */
-				0,		/* backlight disable & DVO clock/data inactive */
-				0,		/* DVO clock/data inactive & VDD inactive */
-				0			/* VDD inactive & VDD active */
-			},
-			{		/* DTD Info */
-			0, NULL
-			},
-			{		/* Attribute Info */
-			0, NULL
-			}
-		},
-	},
-	0,			/* 24-bit RGB color that framebuffer is cleared to */
-	1,			/* Quickboot (1 = enabled) */
-	0,			/* Quickboot seamless (1 = enabled) */
-	0,			/* Quickboot video input (1 = enabled) */
-	0			/* Polling (1 = override interrupt support and use polling) */
-};
-
-igd_param_t *config_params = {&config_params_config1};
-
-/*
- * The emgd_drm_config_t structure is the main configuration structure
- * for the EMGD kernel module.
- */
-emgd_drm_config_t config_drm = {
-	0,	/* Whether to initialize the display at EMGD module startup time
-		 * (corresponds to the "init" module parameter)
-		 */
-	1,	/* The display configuration to use if initializing the display
-		 * (corresponds to the "init" module parameter), where:
-		 * - 1 = Single port/display
-		 * - 2 = Cloned port/display (e.g. LVDS + CRT with different timings)
-		 * - 4 = Twin ports/displays (e.g. LVDS + CRT with same timings)
-		 *       Note: Twin is NOT CURRENTLY SUPPORTED
-		 * - 8 = Extended displays (e.g. LVDS + CRT displaying different images)
-		 */
-	1366,/* Display width to use if initializing the display
-		 * (corresponds to the "width" module parameter)
-		 */
-	768,/* Display height to use if initializing the display
-		 * (corresponds to the "height" module parameter)
-		 */
-	60,	/* Display refresh rate to use if initializing the display
-		 * (corresponds to the "refresh" module parameter)
-		 */
-	0,  /* KMS */
-	0,	/* ovl_brightness */
-	0,	/* ovl_contrast */
-	0,	/* ovl_saturation */
-	0,	/* ovl_gamma_red */
-	0,	/* ovl_gamma_green */
-	0,	/* ovl_gamma_blue */
-	&splash_screen_data,
-	&splash_video_data,
-	&config_params	/* driver parameters from above */
-};
-
+/*
+ *-----------------------------------------------------------------------------
+ * Filename: user_config.c
+ * $Revision: 1.24 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2010, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ * Description:
+ *  A file that contains the initial display configuration information of the
+ *  EMGD kernel module.  A user can edit this file in order to affect the way
+ *  that the kernel initially configures the displays.  This file is compiled
+ *  into the EMGD kernel module.
+ *-----------------------------------------------------------------------------
+ */
+#include "user_config.h"
+
+#warning ****
+#warning **** This driver has NOT been configured for your system.  You are
+#warning **** building with a sample user_config.c configuration that may or
+#warning **** may not meet your needs.  It is recommended that you run CED to
+#warning **** generate an appropriate configuration or see the User Guide
+#warning **** for more information about driver configuration.
+#warning ****
+
+
+/*
+ * One array of igd_display_info_t structures should exist for each port that
+ * needs to provide a DTD list.  Each igd_display_info_t contains the DTD
+ * information for a given resolution/refresh-rate.  This is especially needed
+ * for analog/VGA ports.
+ */
+
+#define TUNNELCREEK 1
+#define POULSBO 0
+
+#if TUNNELCREEK
+static igd_display_info_t dtd_config1_port4_dtdlist[] = {
+	{
+		1366,   /* Width */
+		768,    /* Height */
+		60,     /* Refresh Rate */
+		72300,  /* Dot Clock */
+		1525,   /* Horizontal Total (horizontal synch end) */
+		1365,   /* Horizontal Blank Start (h_active-1) */
+		1525,   /* Horizontal Blank End (start + h_blank) */
+		1413,   /* Horizontal Sync Start (h_active+h_synch-1) */
+		1445,   /* Horizontal Sync End (start + h_syncp) */
+		789,    /* Vertical Total (Vertical synch end) */
+		767,    /* Vertical Blank Start (v_active-1) */
+		789,    /* Vertical Blank End (start + v_blank) */
+		770,    /* Vertical Sync Start (v_active+v_synch-1) */
+		775,    /* Vertical Sync End (start + v_synchp) */
+		0,  /* Mode Number */
+		0x20000,    /* Flags */
+		0,  /* X Offset */
+		0,  /* Y Offset */
+		NULL,   /* pd extension pointer */
+		0, 0   /* mode extension pointer */
+	},
+};
+#endif
+
+#if POULSBO
+static igd_display_info_t dtd_config1_port4_dtdlist[] = {
+	{
+		1024,			/* Width */
+		768,				/* Height */
+		60,				/* Refresh Rate */
+		65000,			/* Dot Clock (in KHz) */
+		1343,			/* Horizontal Total (horizontal synch end) */
+		1023,			/* Horizontal Blank Start (h_active-1) */
+		1343,			/* Horizontal Blank End (start + h_blank) */
+		1047,			/* Horizontal Sync Start (h_active+h_synch-1) */
+		1183,			/* Horizontal Sync End (start + h_syncp) */
+		805,				/* Vertical Total (Vertical synch end) */
+		767,				/* Vertical Blank Start (v_active-1) */
+		805,				/* Vertical Blank End (start + v_blank) */
+		770,				/* Vertical Sync Start (v_active+v_synch-1) */
+		776,				/* Vertical Sync End (start + v_synchp) */
+		0,				/* Mode Number */
+		0x20000,			/* Flags */
+		0,				/* X Offset */
+		0,				/* Y Offset */
+		NULL,			/* pd extension pointer */
+		0, 0				/* mode extension pointer */
+	},
+};
+#endif
+
+static igd_param_attr_t attrs_config1_port4[] = {
+	{0x46, 100},
+#if POULSBO
+	{0x1a, 24},
+#endif
+#if TUNNELCREEK
+	{0x47, 20300},
+#endif
+};
+
+static emgd_drm_splash_screen_t splash_screen_data = {
+	0x000000,		/* bg_color */
+	0,			/* x */
+	0,			/* y */
+	0,			/* width */
+	0,			/* height */
+};
+
+static emgd_drm_splash_video_t splash_video_data = {
+	0,			/* offset */
+	0,			/* pixel_format */
+	0,			/* src_width */
+	0,			/* src_height */
+	0,			/* src_pitch */
+	0,			/* dst_x */
+	0,			/* dst_y */
+	0,			/* dst_width */
+	0,			/* dst_height */
+};
+
+static igd_param_t config_params_config1 = {
+	1*256*1024,		/* Page request */
+	0,		/* Max frame buffer size */
+	1,		/* Preserve registers */
+	0x6,		/* Display flags */
+	{ 4, 2, 0, 0, 0 },		/* Display port order */
+	{		/* Display Params */
+		{		/* Port */
+			4,		/* Display port number */
+			0x180,		/* Parameters present */
+			0x0,		/* EDID flag */
+			0x5,		/* Flags when EDID is available */
+			0x5,		/* Flags when EDID is not available */
+			0,		/* DDC GPIO pins */
+			0,		/* DDC speed */
+			0,		/* DDC DAB */
+			0,		/* I2C GPIO pins */
+			0,		/* I2C speed */
+			0,		/* I2C DAB */
+			{		/* Flat Panel Info */
+				0,		/* Flat Panel width */
+				0,		/* Flat Panel height */
+				0,		/* Flat Panel power method */
+				0,		/* VDD active & DVO clock/data active */
+				0,		/* DVO clock/data active & backlight enable */
+				0,		/* backlight disable & DVO clock/data inactive */
+				0,		/* DVO clock/data inactive & VDD inactive */
+				0			/* VDD inactive & VDD active */
+			},
+			{		/* DTD Info */
+				sizeof(dtd_config1_port4_dtdlist)/sizeof(igd_display_info_t),		/* Number of DTDs */
+				dtd_config1_port4_dtdlist		/* DTD name */
+			},
+			{		/* Attribute Info */
+				sizeof(attrs_config1_port4)/sizeof(igd_param_attr_t),		/* Number of attributes */
+				attrs_config1_port4		/* Attr name */
+			}
+		},
+		{		/* Port */
+			2,		/* Display port number */
+			0x0,		/* Parameters present */
+			0x0,		/* EDID flag */
+			0x5,		/* Flags when EDID is available */
+			0x5,		/* Flags when EDID is not available */
+			0,		/* DDC GPIO pins */
+			0,		/* DDC speed */
+			0,		/* DDC DAB */
+			0,		/* I2C GPIO pins */
+			0,		/* I2C speed */
+			0,		/* I2C DAB */
+			{		/* Flat Panel Info */
+				0,		/* Flat Panel width */
+				0,		/* Flat Panel height */
+				0,		/* Flat Panel power method */
+				0,		/* VDD active & DVO clock/data active */
+				0,		/* DVO clock/data active & backlight enable */
+				0,		/* backlight disable & DVO clock/data inactive */
+				0,		/* DVO clock/data inactive & VDD inactive */
+				0			/* VDD inactive & VDD active */
+			},
+			{		/* DTD Info */
+			0, NULL
+			},
+			{		/* Attribute Info */
+			0, NULL
+			}
+		},
+	},
+	0,			/* 24-bit RGB color that framebuffer is cleared to */
+	1,			/* Quickboot (1 = enabled) */
+	0,			/* Quickboot seamless (1 = enabled) */
+	0,			/* Quickboot video input (1 = enabled) */
+	0			/* Polling (1 = override interrupt support and use polling) */
+};
+
+igd_param_t *config_params = {&config_params_config1};
+
+/*
+ * The emgd_drm_config_t structure is the main configuration structure
+ * for the EMGD kernel module.
+ */
+emgd_drm_config_t config_drm = {
+	0,	/* Whether to initialize the display at EMGD module startup time
+		 * (corresponds to the "init" module parameter)
+		 */
+	1,	/* The display configuration to use if initializing the display
+		 * (corresponds to the "init" module parameter), where:
+		 * - 1 = Single port/display
+		 * - 2 = Cloned port/display (e.g. LVDS + CRT with different timings)
+		 * - 4 = Twin ports/displays (e.g. LVDS + CRT with same timings)
+		 *       Note: Twin is NOT CURRENTLY SUPPORTED
+		 * - 8 = Extended displays (e.g. LVDS + CRT displaying different images)
+		 */
+	1366,/* Display width to use if initializing the display
+		 * (corresponds to the "width" module parameter)
+		 */
+	768,/* Display height to use if initializing the display
+		 * (corresponds to the "height" module parameter)
+		 */
+	60,	/* Display refresh rate to use if initializing the display
+		 * (corresponds to the "refresh" module parameter)
+		 */
+	0,  /* KMS */
+	0,	/* ovl_brightness */
+	0,	/* ovl_contrast */
+	0,	/* ovl_saturation */
+	0,	/* ovl_hue */
+	0,	/* ovl_gamma_red */
+	0,	/* ovl_gamma_green */
+	0,	/* ovl_gamma_blue */
+	&splash_screen_data,
+	&splash_video_data,
+	&config_params	/* driver parameters from above */
+#ifdef SUPPORT_V2G_CAMERA
+	,
+	0	/* 1 - Enable v2g camera. 0 - Disable v2g camera*/
+#endif
+};
+
diff --git a/drivers/gpu/drm/emgd/emgd/drm/user_config.h b/drivers/gpu/drm/emgd/emgd/drm/user_config.h
index 5aca4d8..3ab48bf 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/user_config.h
+++ b/drivers/gpu/drm/emgd/emgd/drm/user_config.h
@@ -94,6 +94,8 @@ typedef struct _emgd_drm_config {
 	unsigned long ovl_contrast;
 	/** Overlay Saturation */
 	unsigned long ovl_saturation;
+	/** Overlay Hue */
+	unsigned long ovl_hue;
 	/** Overlay Gamma Correction - Red */
 	unsigned long ovl_gamma_red;
 	/** Overlay Gamma Correction - Green */
@@ -108,6 +110,10 @@ typedef struct _emgd_drm_config {
 	 * abstraction layer code.
 	 */
 	igd_param_t **hal_params;
+	/** Enable V2G Camera Module **/
+#ifdef SUPPORT_V2G_CAMERA	
+	int v2g;
+#endif	
 } emgd_drm_config_t;
 
 #endif
diff --git a/drivers/gpu/drm/emgd/emgd/gmm/gmm.c b/drivers/gpu/drm/emgd/emgd/gmm/gmm.c
index cb51f93..04e4ed1 100644
--- a/drivers/gpu/drm/emgd/emgd/gmm/gmm.c
+++ b/drivers/gpu/drm/emgd/emgd/gmm/gmm.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: gmm.c
- * $Revision: 1.52 $
+ * $Revision: 1.53 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -41,6 +41,7 @@
 #include <linux/init.h>
 
 #include <asm/agp.h>
+#include "igd_gmm.h"
 
 #define AGP_PHYS_MEMORY 2 /* Physical contigous memory */
 struct emgd_ci_surface_t{
@@ -49,8 +50,9 @@ struct emgd_ci_surface_t{
 	unsigned int virt;
 	unsigned long size;
 	unsigned long gtt_offset;
+	unsigned long vbufqueue_handle;
 	};
-#define MAX_CI_LIST_SIZE 14
+#define MAX_CI_LIST_SIZE 25
 struct emgd_ci_surface_t ci_surfaces[MAX_CI_LIST_SIZE];
 
 
@@ -758,18 +760,70 @@ static int gmm_map_contig_buffer(gmm_context_t *gmm_context,
 
 	/* Check for a free contiguous chunk of sufficent size */
 	chunk = gmm_context->head_chunk;
-
+	while (chunk) {
+		if ((chunk->usage== FREE_ALLOCATED) && (chunk->size >= size)
+		&& (chunk->type == AGP_PHYS_MEMORY)) {
+			/* Re-use this chunk */
+			chunk->usage = INUSE_ALLOCATED; 		
+			EMGD_DEBUG("Re-using old chunk with offset=0x%lx", 
+				chunk->offset);
+			EMGD_DEBUG("EXIT  Returning %d", 0);
+			break;
+		}
+		chunk = chunk->next;
+	}
 	/* Allocate a new chunk list element */
-	chunk = (gmm_chunk_t *)OS_ALLOC(sizeof(gmm_chunk_t));
-	if (!chunk) {
-		printk(KERN_ERR "[EMGD] Cannot allocate gmm_chunk_t element");
-		EMGD_ERROR_EXIT("Returning %d", -IGD_ERROR_NOMEM);
-		return -IGD_ERROR_NOMEM;
+	if(chunk == NULL){
+		chunk = (gmm_chunk_t *)OS_ALLOC(sizeof(gmm_chunk_t));
+		if (!chunk) {
+			printk(KERN_ERR "[EMGD] Cannot allocate gmm_chunk_t element");
+			EMGD_ERROR_EXIT("Returning %d", -IGD_ERROR_NOMEM);
+			return -IGD_ERROR_NOMEM;
+		}
+
+		/*if want to reuse the chunk, no need memset it here. 
+		  * we need the previous gtt offset of chunk.
+		  */ 
+		OS_MEMSET(chunk, 0, sizeof(gmm_chunk_t));
+
+		chunk->size = size;
+
+		/* Determine the offset value for this chunk 
+		  * if this chunk is new allocated, then we set tailk_chunk->offset+size to chunk->offset
+		  * if this chunk is reused, then no need to assign the chunk->offset again.
+		  * also no need to insert this chunk into list again, because this chunk is already in the list.
+		  */
+	
+	
+		if (gmm_context->tail_chunk == NULL) {
+			
+			chunk->offset = 0;
+			
+		} else {
+			chunk->offset = gmm_context->tail_chunk->offset +
+				gmm_context->tail_chunk->size;
+			
+			
+		}
+		/* Adjust the offset since display surfaces require 256KB alignment */
+		chunk->offset = (chunk->offset + 0x3ffff) & ~0x3ffff;
+		
+		/* Insert this chunk in the list */
+		chunk->next = NULL;
+		if (gmm_context->head_chunk == NULL) {
+			
+			gmm_context->head_chunk = chunk;
+		} else {
+			gmm_context->tail_chunk->next = chunk;
+		}
+		gmm_context->tail_chunk = chunk;
+		chunk->usage = INUSE_ALLOCATED;	
 	}
-	OS_MEMSET(chunk, 0, sizeof(gmm_chunk_t));
+	
+	
 
 	/* Contiguous memory is needed, so set the type to AGP_PHYS_MEMORY */
-	chunk->size = size;
+	
 	chunk->pages = (size + PAGE_SIZE - 1) / PAGE_SIZE;
 	chunk->type = AGP_PHYS_MEMORY;
 
@@ -781,36 +835,12 @@ static int gmm_map_contig_buffer(gmm_context_t *gmm_context,
 		return -IGD_ERROR_NOMEM;
 	}
 
-	/* Assign the specified memory block to this chunk */
-	chunk->used = 1;
+	/* Assign the specified memory block to this chunk */	
 	chunk->ref_cnt = 0;
 	chunk->page_addresses = NULL;
 
-	/* Determine the offset value for this chunk */
-	if (gmm_context->tail_chunk == NULL) {
-		
-		chunk->offset = 0;
-		
-	} else {
-		chunk->offset = gmm_context->tail_chunk->offset +
-			gmm_context->tail_chunk->size;
-		
-		
-	}
-
-
-	/* Adjust the offset since display surfaces require 256KB alignment */
-	chunk->offset = (chunk->offset + 0x3ffff) & ~0x3ffff;
 	
-	/* Insert this chunk in the list */
-	chunk->next = NULL;
-	if (gmm_context->head_chunk == NULL) {
-		
-		gmm_context->head_chunk = chunk;
-	} else {
-		gmm_context->tail_chunk->next = chunk;
-	}
-	gmm_context->tail_chunk = chunk;
+	
 
 	/* Now update the GTT so the display HW can access this memory */
 	emgd_gtt_insert(gmm_context->context, chunk->gtt_mem, chunk->offset);
@@ -857,13 +887,17 @@ int gmm_map_to_graphics(unsigned long phys_addr,
 	EMGD_TRACE_EXIT;
 	return ret;
 }
+EXPORT_SYMBOL(gmm_map_to_graphics);
+
+
+
 
 /*
  * find gtt_offset and virtual address from ci_surface list according to the same v4l2_offset
  */
 
 static int gmm_map_ci(unsigned long *gtt_offset,
-			unsigned long ci_param,	/* virtaddr or v4l2_offset */
+			unsigned long ci_param,	/* cast to  (struct emgd_ci_meminfo_t *) */
 			unsigned long *virt_addr,
 			unsigned int map_method,
 			unsigned long size)
@@ -871,9 +905,14 @@ static int gmm_map_ci(unsigned long *gtt_offset,
 {
 	unsigned char i;
 	int ret;
+	struct emgd_ci_meminfo_t * ci_meminfo;
+	unsigned long virt;
+
+	ci_meminfo = (struct emgd_ci_meminfo_t *)ci_param;
+	virt = ci_meminfo->virt;
 
-	if(map_method){		
-		ret = gmm_map_to_graphics(virt_to_phys((unsigned long *)ci_param),size,gtt_offset);
+	if(map_method){
+		ret = gmm_map_to_graphics(virt_to_phys((unsigned long *)virt),size,gtt_offset);
 		if(ret)
 			return ret;
 		else{
@@ -882,10 +921,10 @@ static int gmm_map_ci(unsigned long *gtt_offset,
 				if(!ci_surfaces[i].used){
 					
 					ci_surfaces[i].used = 1;
-					ci_surfaces[i].virt = ci_param;
+					ci_surfaces[i].virt = virt;
 					ci_surfaces[i].size = size;
 					ci_surfaces[i].gtt_offset = *gtt_offset;
-					*virt_addr = ci_param;				
+					*virt_addr = virt;				
 					break;
 				}		
 			}
@@ -894,7 +933,8 @@ static int gmm_map_ci(unsigned long *gtt_offset,
 	else{
 		
 		for(i=0;i<MAX_CI_LIST_SIZE;i++){
-			if(ci_surfaces[i].used && (ci_surfaces[i].v4l2_offset ==ci_param)){
+			if(ci_surfaces[i].used && (ci_surfaces[i].vbufqueue_handle == ci_meminfo->vbufqueue_handle)
+				&& (ci_surfaces[i].v4l2_offset ==ci_meminfo->v4l2_offset)){
 				
 				*gtt_offset = ci_surfaces[i].gtt_offset;
 				*virt_addr = ci_surfaces[i].virt;			
@@ -917,38 +957,32 @@ static int gmm_unmap_contig_buffer(gmm_context_t *gmm_context,
 {
 	
 	gmm_chunk_t *chunk;
-#ifdef GMM_CI_CLEANUP
- 	gmm_chunk_t *del;
-#endif
 	EMGD_TRACE_ENTER;
 
 	/* Locate the specified chunk and mark it as unused */
 	chunk = gmm_context->head_chunk;
 	while (chunk) {
-		if ((chunk->used == 1) && (chunk->size >= size) &&
+		if ((chunk->usage == INUSE_ALLOCATED) && (chunk->size >= size) &&
 			(chunk->type == AGP_PHYS_MEMORY) &&
 			chunk->offset == offset) {			
 
 			emgd_gtt_remove(gmm_context->context, chunk->gtt_mem, chunk->offset);
 
-			chunk->used =0;	
-#ifdef GMM_CI_CLEANUP			
-			kfree(chunk->gtt_mem);
+			chunk->usage = FREE_ALLOCATED;			
+
+			/* no need release the chunk from chunk list.
+			  * Because need reuse the offset in gtt table of this chunk
+			  */
+			if(chunk->gtt_mem !=NULL)
+				kfree(chunk->gtt_mem);
 
 			/* Free the array of page address, if applicable: */
 			if (chunk->page_addresses != NULL) {
 				EMGD_DEBUG("About to free chunk->page_addresses = 0x%p",
 					chunk->page_addresses);
 				OS_FREE(chunk->page_addresses);
-			}
-
-			/* Free the chunk */
-			del = chunk;
-			chunk = chunk->next;
-			OS_FREE(del);
-#endif				
+			}	
 			
-			EMGD_DEBUG("EXIT  Returning %d", 0);
 			return 0;
 		}
 		chunk = chunk->next;
@@ -1090,7 +1124,12 @@ static int gmm_alloc_chunk_space(gmm_context_t *gmm_context,
 	 *
 	 */
 	if (gmm_context->tail_chunk == NULL) {
-		chunk->offset = 0;
+		/* 1st ever chunk */
+		if(gmm_context->context->mod_dispatch.init_params->qb_seamless) {
+			chunk->offset = (gmm_context->context->device_context.stolen_pages) * PAGE_SIZE;
+		} else {
+			chunk->offset = 0;
+		}
 	} else {
 		chunk->offset = gmm_context->tail_chunk->offset +
 			gmm_context->tail_chunk->size;
@@ -1211,7 +1250,11 @@ static int gmm_import_pages(void **pagelist,
 		if (gmm_context.tail_chunk == NULL) {
 			/* First chunk ever! */
 			gmm_context.head_chunk = chunk;
-			chunk->offset = 0;
+			if(gmm_context.context->mod_dispatch.init_params->qb_seamless) {
+				chunk->offset = (gmm_context.context->device_context.stolen_pages) * PAGE_SIZE;
+			} else {
+				chunk->offset = 0;
+			}
 		} else {
 			chunk->offset = gmm_context.tail_chunk->offset +
 				gmm_context.tail_chunk->size;
@@ -1321,12 +1364,6 @@ static int gmm_get_page_list(unsigned long offset,
 	return 0;
 }
 
-struct emgd_ci_meminfo_t {
-	unsigned long v4l2_offset;
-	unsigned long virt;
-	unsigned long  size;
-	};
-
 int emgd_map_ci_buf(struct emgd_ci_meminfo_t * ci_meminfo)
 {
 	int ret;
@@ -1341,9 +1378,11 @@ int emgd_map_ci_buf(struct emgd_ci_meminfo_t * ci_meminfo)
 	for(i=0;i<MAX_CI_LIST_SIZE;i++){
 		if(!ci_surfaces[i].used){
 			ci_surfaces[i].used = 1;			
-			ci_surfaces[i].virt = virt_to_phys((unsigned long *)ci_meminfo->virt);
+			ci_surfaces[i].virt = ci_meminfo->virt;
 			ci_surfaces[i].size =  ci_meminfo->size;
 			ci_surfaces[i].gtt_offset =  gtt_offset;
+			ci_surfaces[i].vbufqueue_handle =  ci_meminfo->vbufqueue_handle;
+			ci_surfaces[i].v4l2_offset = ci_meminfo->v4l2_offset;
 			return 0;
 		}
 	}
diff --git a/drivers/gpu/drm/emgd/emgd/include/context.h b/drivers/gpu/drm/emgd/emgd/include/context.h
index 9d54e6d..254aa32 100644
--- a/drivers/gpu/drm/emgd/emgd/include/context.h
+++ b/drivers/gpu/drm/emgd/emgd/include/context.h
@@ -77,6 +77,7 @@ typedef struct _inter_module_dispatch {
 		struct _igd_display_port *port,
 		struct _pd_timing *in_list);
 
+	unsigned long (*get_port_control)(unsigned long port_num, unsigned long port_reg);
 	/* FIXME: This should be a dsp function */
 	unsigned long (*mode_get_gpio_sets)(unsigned long **gpio);
 
diff --git a/drivers/gpu/drm/emgd/emgd/include/memlist.h b/drivers/gpu/drm/emgd/emgd/include/memlist.h
index 7d9fa22..5801fef 100644
--- a/drivers/gpu/drm/emgd/emgd/include/memlist.h
+++ b/drivers/gpu/drm/emgd/emgd/include/memlist.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: memlist.h
- * $Revision: 1.17 $
+ * $Revision: 1.18 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -126,7 +126,6 @@ typedef struct _gmm_chunk {
 	} usage;
 	/* The offset of the allocated memory, after alignment */
 	unsigned long offset;
-	unsigned long used;
 	/* The number of bytes of memory requested/allocated for this chunk */
 	unsigned long size;
 	/* The number of pages of memory required for "size" bytes */
diff --git a/drivers/gpu/drm/emgd/emgd/include/msvdx.h b/drivers/gpu/drm/emgd/emgd/include/msvdx.h
index 19ec924..76f33e9 100644
--- a/drivers/gpu/drm/emgd/emgd/include/msvdx.h
+++ b/drivers/gpu/drm/emgd/emgd/include/msvdx.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: msvdx.h
- * $Revision: 1.20 $
+ * $Revision: 1.21 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -191,6 +191,7 @@ struct msvdx_cmd_queue {
 	struct list_head head;
 	void *cmd;
 	unsigned long cmd_size;
+	unsigned long context_id;
 };
 
 /* TODO:  From UMG, temporary put here first, may need to use this
@@ -240,18 +241,19 @@ typedef struct msvdx_fw_ {
 } msvdx_fw_t;
 
 
-int process_video_decode_plb(igd_context_t *context, unsigned long offset, void *virt_addr, unsigned long *fence_id);
+int process_video_decode_plb(igd_context_t *context, unsigned long offset,
+		void *mem_handle, unsigned long *fence_id);
 int msvdx_query_plb(igd_context_t *context, unsigned long *status);
 int msvdx_preinit_mmu(unsigned long hmemcxt);
 int msvdx_init_plb(unsigned long base0, unsigned long base1,
-           void *msvdx_fw, unsigned long msvdx_fw_size, int reset_flag);
+					void* mem_handle_fw,int reset_flag);
 int msvdx_init_compositor_mmu(unsigned long mmu_base);
 int msvdx_uninit_plb(igd_context_t *context);
-int msvdx_close_context(igd_context_t *context);
-int msvdx_create_context(igd_context_t *context);
+int msvdx_close_context(igd_context_t *context, unsigned long context_id);
+int msvdx_create_context(igd_context_t *context, void *drm_file_priv, unsigned long ctx_id);
 int msvdx_shutdown_plb(igd_context_t *context);
 int msvdx_get_fence_id(igd_context_t *context, unsigned long *fence_id);
 int msvdx_flush_tlb(igd_context_t *context);
-
+void msvdx_postclose_check(igd_context_t *context, void *drm_file_priv);
 
 #endif
diff --git a/drivers/gpu/drm/emgd/emgd/include/pd.h b/drivers/gpu/drm/emgd/emgd/include/pd.h
index 388a2af..a12cac5 100644
--- a/drivers/gpu/drm/emgd/emgd/include/pd.h
+++ b/drivers/gpu/drm/emgd/emgd/include/pd.h
@@ -372,6 +372,7 @@ typedef struct _pd_callback {
 	pd_write_regs_p write_regs;
 	unsigned long port_num;			/*	Added for SDVO port driver */
 	cea_extension_t	**eld;			/* EDID like Data */
+	unsigned char reset;
 }pd_callback_t;
 
 /* IMP NOTE: All below structures should be with same size.
diff --git a/drivers/gpu/drm/emgd/emgd/include/plb/context.h b/drivers/gpu/drm/emgd/emgd/include/plb/context.h
index 563c232..b9ef5038f 100644
--- a/drivers/gpu/drm/emgd/emgd/include/plb/context.h
+++ b/drivers/gpu/drm/emgd/emgd/include/plb/context.h
@@ -156,6 +156,7 @@ typedef struct _tnc_topaz_priv {
 	 * Offset in gmm space for write back memory.
 	 */
 	unsigned long wb_offset;
+	int selected_codec;
 } tnc_topaz_priv_t;
 
 struct msvdx_pvr_info;
@@ -180,6 +181,7 @@ typedef struct _platform_context_plb {
 	int msvdx_needs_reset;
     spinlock_t msvdx_lock;
     spinlock_t msvdx_init_plb;
+	spinlock_t topaz_init_tnc;
     unsigned long msvdx_status;
     int msvdx_busy;
     struct list_head msvdx_queue;
diff --git a/drivers/gpu/drm/emgd/emgd/include/topaz.h b/drivers/gpu/drm/emgd/emgd/include/topaz.h
index e14b46c..b4057f4 100755
--- a/drivers/gpu/drm/emgd/emgd/include/topaz.h
+++ b/drivers/gpu/drm/emgd/emgd/include/topaz.h
@@ -200,10 +200,13 @@ enum drm_lnc_topaz_cmd {
 };
 
 extern int topaz_setup_fw(igd_context_t *context, enum tnc_topaz_encode_fw codec);
-int process_video_encode_tnc(igd_context_t *context, unsigned long offset, void *virt_addr, unsigned long *fence_id);
-int topaz_init_tnc(unsigned long wb_offset, void *wb_addr, void *firm_addr);
+int process_video_encode_tnc(igd_context_t *context, unsigned long offset,
+		void *mem_handle, unsigned long *fence_id);
+int topaz_init_tnc(unsigned long wb_offset, void* mem_handle_writeback,
+		void *mem_handle_enc_fw);
 int topaz_get_fence_id(igd_context_t *context, unsigned long *fence_id);
 int topaz_flush_tnc(igd_context_t *context);
 int topaz_get_frame_skip(igd_context_t *context, unsigned long *frame_skip);
+int topaz_shutdown_tnc(igd_context_t *context);
 
 #endif
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/Makefile.gnu b/drivers/gpu/drm/emgd/emgd/pal/ch7036/Makefile.gnu
index cb82fd6..adc8199 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/Makefile.gnu
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/Makefile.gnu
@@ -1,26 +1,25 @@
 #----------------------------------------------------------------------------
-# Filename: Makefile.gnu
-# $Revision: 1.1.2.1 $
-#----------------------------------------------------------------------------
-# INTEL CONFIDENTIAL
-# Copyright (2002-2008) Intel Corporation All Rights Reserved.
-# The source code contained or described herein and all documents related to
-# the source code ("Material") are owned by Intel Corporation or its suppliers
-# or licensors. Title to the Material remains with Intel Corporation or its
-# suppliers and licensors. The Material contains trade secrets and proprietary
-# and confidential information of Intel or its suppliers and licensors. The
-# Material is protected by worldwide copyright and trade secret laws and
-# treaty provisions. No part of the Material may be used, copied, reproduced,
-# modified, published, uploaded, posted, transmitted, distributed, or
-# disclosed in any way without Intel's prior express written permission.
-# 
-# No license under any patent, copyright, trade secret or other intellectual
-# property right is granted to or conferred upon you by disclosure or
-# delivery of the Materials, either expressly, by implication, inducement,
-# estoppel or otherwise. Any license under such intellectual property rights
-# must be express and approved by Intel in writing.
-# 
+# Copyright (c) 2002-2010, Intel Corporation.
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+# THE SOFTWARE.
 #----------------------------------------------------------------------------
+
 DRV     = ch7036
 SOURCES = \
             ch7036_port.c \
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_pm.c b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_pm.c
index d9f51bb..1922bda 100755
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_pm.c
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_pm.c
@@ -79,9 +79,9 @@ void ch7036_set_power_lvds(DEV_CONTEXT* p_ch7xxx_context)
 		reg = reg & 0xF7;                   
         I2CWrite(p_ch7xxx_context,0x0A, reg);		
 
-		
+		/*Fix backlight blinking during mode switching in and out of lvds*/
 		I2CWrite(p_ch7xxx_context,0x4E, I2CRead(p_ch7xxx_context,0x4E) | 0x80 );
-
+		I2CWrite(p_ch7xxx_context,0x4D,0x80);/*need to use PWM to control backlight-6/4/12*/
 		
 		if((pOutput_Info->channel & CHANNEL_HDMI) == 0x00 && (pOutput_Info->channel & CHANNEL_VGA) == 0x00){
 
@@ -116,7 +116,9 @@ void ch7036_set_power_lvds(DEV_CONTEXT* p_ch7xxx_context)
 
         I2CWrite(p_ch7xxx_context,0x03, 0x00);   
 
+		/*Fix backlight blinking during mode switching in and out of lvds*/
 		I2CWrite(p_ch7xxx_context,0x4E, I2CRead(p_ch7xxx_context,0x4E) & 0x7F );
+		I2CWrite(p_ch7xxx_context,0x4D,0x0);/*need to use PWM to control backlight-6/4/12*/
 
 		reg = I2CRead(p_ch7xxx_context,0x0A);
 		reg = reg | 0x08;                   
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.c b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.c
index 7d4e496..d909c64 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.c
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.c
@@ -577,7 +577,14 @@ int ch7036_post_set_mode(void *p_context, pd_timing_t *p_mode,
 
 #endif
 
-	
+	/* Fix backlight blinking during mode switching 
+	 * in and out of lvds.
+	 */		
+	I2CWrite(p_ch7xxx_context,0x03,0x00);
+	I2CWrite(p_ch7xxx_context,0x4E, I2CRead(p_ch7xxx_context,0x4E) & 0x7F); 
+
+	I2CWrite(p_ch7xxx_context,0x4D,0x0);/*need to use PWM to control backlight-6/4/12*/
+
 	ret = PD_INTERNAL_LVDS_MODULE_POST_SET_MODE(ch7036_lvds_post_set_mode,(p_ctx->internal_lvds,p_mode,flags));
 
 #ifndef LVDS_ONLY	
@@ -597,7 +604,8 @@ int ch7036_post_set_mode(void *p_context, pd_timing_t *p_mode,
 
 #endif
 
-	return PD_SUCCESS;
+	/* for CH7036: Code fix Meego hang after killall X */	
+	return p_ctx->pwr_state = PD_POWER_MODE_D0;
 }
 
 
@@ -1339,6 +1347,13 @@ int ch7036_restore(void *p_context, void *state, unsigned long flags)
 	return PD_INTERNAL_LVDS_MODULE_RESTORE(ch7036_restore,(p_ctx->internal_lvds, state, flags));
 #endif
 
+	/* for CH7036: Code fix Meego hang after killall X 
+	*/
+#ifdef T_LINUX
+	if(p_ctx->pwr_state != PD_POWER_MODE_D1)
+		return PD_SUCCESS;
+#endif
+
 	
 	if (ch7036_load_firmware(p_ctx) != SS_SUCCESS)   { 
 		PD_DEBUG("ch7036: ch7036_restore()-  load fw is NOT a SUCCESS\n");
@@ -1504,8 +1519,10 @@ int ch7036_initialize_device(ch7036_device_context_t *p_ctx)
 		reg = reg & 0x70; 
 		I2CWrite(p_ch7xxx_context,0x07, reg);
 
+		/*Fix backlight blinking during mode switching in and out of lvds*/
 		I2CWrite(p_ch7xxx_context,0x4E, I2CRead(p_ch7xxx_context,0x4E) & 0x7F); 
-		
+		I2CWrite(p_ch7xxx_context,0x4D,0x0);/*need to use PWM to control backlight-6/4/12*/
+
 		I2CWrite(p_ch7xxx_context,0x03, 0x01);
 		reg = I2CRead(p_ch7xxx_context,0x0F); 
 		reg = reg & 0x7F; 
diff --git a/drivers/gpu/drm/emgd/emgd/pal/lvds/lvds.c b/drivers/gpu/drm/emgd/emgd/pal/lvds/lvds.c
index a9dc56f..fff6756 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/lvds/lvds.c
+++ b/drivers/gpu/drm/emgd/emgd/pal/lvds/lvds.c
@@ -31,8 +31,11 @@
  *-----------------------------------------------------------------------------
  */
 #include <linux/kernel.h>
-#include <linux/bug.h>
 
+#include <linux/version.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
+#include <linux/bug.h>
+#endif
 #include <config.h>
 #include <igd_pd.h>
 #include <pd.h>
diff --git a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_attr.c b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_attr.c
index 6d2d3c8..81f458a 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_attr.c
+++ b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_attr.c
@@ -1085,7 +1085,7 @@ unsigned long sdvo_get_bool_attrs(sdvo_device_context_t *p_ctx,
 		num_attrs = 0;
 
 		for (i = 0; i < ARRAY_SIZE(g_bool_data); i++) {
-			if((p_ctx->dev_cap.vendor_id == VENDOR_ID_OKI) &&
+			if((p_ctx->dev_cap.vendor_id == VENDOR_ID_LAPIS) &&
 				(p_ctx->dev_cap.device_id == 0x1) &&
 	            ((g_bool_data[i].id == PD_ATTR_ID_PANEL_PROTECT_HSYNC) ||
 	            (g_bool_data[i].id == PD_ATTR_ID_PANEL_PROTECT_VSYNC))) {
@@ -1117,7 +1117,7 @@ unsigned long sdvo_get_bool_attrs(sdvo_device_context_t *p_ctx,
 		p_attr_cur->type = PD_ATTR_TYPE_BOOL;
 		p_attr_cur->flags |= PD_ATTR_FLAG_DYNAMIC;
 
-		if((p_ctx->dev_cap.vendor_id == VENDOR_ID_OKI) &&
+		if((p_ctx->dev_cap.vendor_id == VENDOR_ID_LAPIS) &&
 			(p_ctx->dev_cap.device_id == 0x1) &&
 	        ((g_bool_data[i].id == PD_ATTR_ID_PANEL_PROTECT_HSYNC) ||
 	        (g_bool_data[i].id == PD_ATTR_ID_PANEL_PROTECT_VSYNC))) {
diff --git a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.c b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.c
index 7651199..d8c848e 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.c
+++ b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.c
@@ -1842,8 +1842,9 @@ int sdvo_open(pd_callback_t *p_callback, void **pp_context)
 
 #ifndef CONFIG_MICRO
 	/* reset context to avoid wrong timing list */
-	if ((p_ctx->dev_cap.vendor_id != VENDOR_ID_OKI)
-		&& (p_ctx->dev_cap.device_id != 0x1)){
+	if ((p_ctx->dev_cap.vendor_id != VENDOR_ID_LAPIS)
+		&& (p_ctx->dev_cap.device_id != 0x1) && p_callback->reset ){
+		PD_DEBUG("Resetting encoder\n");
 		sdvo_reset_encoder(p_ctx);
 	}
 #endif
@@ -1916,7 +1917,7 @@ int sdvo_open(pd_callback_t *p_callback, void **pp_context)
 #ifndef CONFIG_MICRO
 	/*We want this in (Windows XP driver) AND
 	(in VBIOS when LVDS is not linked.)*/
-	if ((p_ctx->dev_cap.vendor_id == VENDOR_ID_OKI)
+	if ((p_ctx->dev_cap.vendor_id == VENDOR_ID_LAPIS)
 		&& (p_ctx->dev_cap.device_id == 0x1)){
 		status = sdvo_set_target_input(p_ctx, p_ctx->inp_dev);
 		if (status != SS_SUCCESS) {
@@ -2417,13 +2418,13 @@ int sdvo_set_mode(void *p_context, pd_timing_t *p_mode, unsigned long flags)
 #ifndef CONFIG_MICRO
 	/*We want this in (Windows XP driver) AND
 	(in VBIOS when LVDS is not linked.)*/
-	/* This workaround needed for OKI solution only.
+	/* This workaround needed for LAPIS solution only.
 	It would probably give problem if the SDVO is connected to
-	analog display, but that is not the usage model for OKI.
+	analog display, but that is not the usage model for LAPIS.
 	*/
-	if ((p_ctx->dev_cap.vendor_id == VENDOR_ID_OKI)
+	if ((p_ctx->dev_cap.vendor_id == VENDOR_ID_LAPIS)
 		&& (p_ctx->dev_cap.device_id == 0x1)){
-		/* The OKI SDVO receiver to return Invalid Argument when:
+		/* The LAPIS SDVO receiver to return Invalid Argument when:
 		(1) Horizontal Active   < 600
 		(2) Horizontal Blanking < 16
 		(3) HSync pulse width  < 2
@@ -2528,8 +2529,8 @@ int sdvo_post_set_mode(void *p_context, pd_timing_t *p_mode,
 	PD_DEBUG("sdvo: sdvo_post_set_mode()");
 
 #ifndef CONFIG_MICRO
-	/* This is a workaround specific to OKI */
-	if((p_ctx->dev_cap.vendor_id == VENDOR_ID_OKI)
+	/* This is a workaround specific to LAPIS */
+	if((p_ctx->dev_cap.vendor_id == VENDOR_ID_LAPIS)
 		&& (p_ctx->dev_cap.device_id == 0x1)){
 
 		pd_timing_t local_p_mode;
@@ -2538,7 +2539,7 @@ int sdvo_post_set_mode(void *p_context, pd_timing_t *p_mode,
 		local_p_mode = *p_mode;
 
 		sdvo_reset_encoder(p_context);
-		/* sdvo_reset(p_context);*/ /* THIS is workaround for OKI SDVO flashing issue.*/
+		/* sdvo_reset(p_context);*/ /* THIS is workaround for LAPIS SDVO flashing issue.*/
 		sdvo_set_power(p_context, 0);
 		if (p_ctx->display_pwr_state == 0x0)
 		{
@@ -2695,11 +2696,11 @@ int sdvo_get_attributes(void *p_context, unsigned long *p_num_attr,
 		return 0;
 	}
 #ifndef CONFIG_MICRO
-	/* This is a workaround specific to OKI */
-	if(p_ctx->dev_cap.vendor_id == VENDOR_ID_OKI
+	/* This is a workaround specific to LAPIS */
+	if(p_ctx->dev_cap.vendor_id == VENDOR_ID_LAPIS
 		&& p_ctx->dev_cap.device_id == 0x1){
 		/* 	TODO: sdvo_set_target_output return pending when the power state is D3 on
-		* 	ML7213 A0. other sdvo cards don't have this problem and OKI don't see
+		* 	ML7213 A0. other sdvo cards don't have this problem and LAPIS don't see
 		* 	this problem on their site. verify this on A1 and remove the code if
 		* 	it return success */
 		sdvo_set_power(p_ctx, PD_POWER_MODE_D0);
@@ -3868,7 +3869,7 @@ int sdvo_is_multi_display_device(sdvo_device_context_t *p_ctx)
 static sdvo_status_t sdvo_reset_encoder(sdvo_device_context_t *p_ctx)
 {
 	sdvo_status_t ret_stat;
-	if ((p_ctx->dev_cap.vendor_id == VENDOR_ID_OKI)
+	if ((p_ctx->dev_cap.vendor_id == VENDOR_ID_LAPIS)
 		&& (p_ctx->dev_cap.device_id == 0x1)){
 
 		pd_attr_t *p_attr_temp =
diff --git a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.h b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.h
index b06fc73b..17a004f 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.h
+++ b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.h
@@ -64,8 +64,8 @@ unsigned char sdvo_read_i2c_reg(sdvo_device_context_t *p_Ctx, unsigned char offs
 
 int sdvo_is_multi_display_device(sdvo_device_context_t *p_ctx);
 
-/*OKI Workaround*/
-#define	VENDOR_ID_OKI 0x81
+/*LAPIS Workaround*/
+#define	VENDOR_ID_LAPIS 0x81
 
 
 #endif  /*  _SDVO_PORT_H_ */
diff --git a/drivers/gpu/drm/emgd/emgd/state/reg/plb/reg_plb.c b/drivers/gpu/drm/emgd/emgd/state/reg/plb/reg_plb.c
index d262ad6..c865c36 100644
--- a/drivers/gpu/drm/emgd/emgd/state/reg/plb/reg_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/state/reg/plb/reg_plb.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: reg_plb.c
- * $Revision: 1.14 $
+ * $Revision: 1.15 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -35,6 +35,7 @@
 #include <io.h>
 #include <memory.h>
 #include <sched.h>
+#include <pci.h>
 
 #include <igd_init.h>
 #include <igd_mode.h>
@@ -270,6 +271,7 @@ typedef struct _reg_buffer_plb {
 	d3d_state_plb_t d3d_state;
 	void *rb_state;
 	unsigned long clk_gating_ctl;
+	unsigned long pci_lbb;
 } reg_buffer_plb_t;
 
 static reg_platform_context_plb_t reg_platform_context_plb = {
@@ -854,10 +856,13 @@ static int reg_save_plb(igd_context_t *context,
 {
 	reg_buffer_plb_t           *reg_args;
 	unsigned long              *buffer;
-	reg_platform_context_plb_t *platform_context =
+	reg_platform_context_plb_t *reg_platform_context =
 		(reg_platform_context_plb_t *)_platform_context;
 	int                        i;
 	unsigned char              *mmio;
+	platform_context_plb_t *platform_context; 
+    platform_context = (platform_context_plb_t *)context->platform_context; 
+
 
 	EMGD_TRACE_ENTER;
 
@@ -880,8 +885,8 @@ static int reg_save_plb(igd_context_t *context,
 	if (reg_buffer->flags & IGD_REG_SAVE_VGA) {
 		EMGD_DEBUG("Saving VGA registers");
 		reg_save_vga_plb(context, &reg_args->vga_state,
-			platform_context->ar, platform_context->cr, platform_context->sr,
-			platform_context->gr);
+			reg_platform_context->ar, reg_platform_context->cr, reg_platform_context->sr,
+			reg_platform_context->gr);
 	}
 
 	/* Save VGA memory */
@@ -907,8 +912,8 @@ static int reg_save_plb(igd_context_t *context,
 	if (reg_buffer->flags & IGD_REG_SAVE_MMIO) {
 		EMGD_DEBUG("Saving MMIO registers");
 		buffer = reg_args->mmio_state;
-		for (i=0; platform_context->mmio_regs[i] != 0xffffffff; i++) {
-			*buffer++ = EMGD_READ32(mmio + platform_context->mmio_regs[i]);
+		for (i=0; reg_platform_context->mmio_regs[i] != 0xffffffff; i++) {
+			*buffer++ = EMGD_READ32(mmio + reg_platform_context->mmio_regs[i]);
 		}
 
 		if (reg_buffer->flags & IGD_REG_SAVE_GTT) {
@@ -919,7 +924,7 @@ static int reg_save_plb(igd_context_t *context,
 	/* Save DAC registers */
 	if (reg_buffer->flags & IGD_REG_SAVE_DAC) {
 		EMGD_DEBUG("Saving DAC registers");
-		reg_save_dac_plb(context, &reg_args->dac_state, platform_context);
+		reg_save_dac_plb(context, &reg_args->dac_state, reg_platform_context);
 	}
 
 	/* Save Mode state */
@@ -941,6 +946,12 @@ static int reg_save_plb(igd_context_t *context,
 	/* Save the SGX clock gating settings */
 	reg_args->clk_gating_ctl = EMGD_READ32(mmio + PSB_CR_CLKGATECTL);
 
+	/* Save the PCI Config Legacy Backlight Brightness Register */ 
+     if(OS_PCI_READ_CONFIG_32( 
+		platform_context->pcidev0, 0xF4, &reg_args->pci_lbb)) { 
+        EMGD_DEBUG("Reading Legacy Backlight Brightness"); 
+     } 
+
 	return 0;
 } /* reg_save */
 
@@ -959,11 +970,14 @@ int reg_restore_plb(igd_context_t *context,
 	void *_platform_context)
 {
 	reg_buffer_plb_t* reg_args;
-	reg_platform_context_plb_t *platform_context =
+	reg_platform_context_plb_t *reg_platform_context =
 		(reg_platform_context_plb_t *)_platform_context;
 	unsigned char *mmio;
 	unsigned long *buffer;
 	int i;
+	unsigned long lbb; 
+    platform_context_plb_t *platform_context; 
+    platform_context = (platform_context_plb_t *)context->platform_context; 
 
 	EMGD_DEBUG("Entry - reg_restore");
 
@@ -995,20 +1009,20 @@ int reg_restore_plb(igd_context_t *context,
 	if (reg_buffer->flags & IGD_REG_SAVE_MMIO) {
 		EMGD_DEBUG("Restoring MMIO registers");
 		buffer = reg_args->mmio_state;
-		for (i=0; platform_context->mmio_regs[i] != 0xffffffff; i++) {
-			if (platform_context->mmio_regs[i] == MI_ARB_STATE) {
+		for (i=0; reg_platform_context->mmio_regs[i] != 0xffffffff; i++) {
+			if (reg_platform_context->mmio_regs[i] == MI_ARB_STATE) {
 				EMGD_DEBUG("Handle special masked register case");
 				EMGD_WRITE32(0x04100000 | *buffer++, mmio +
-					platform_context->mmio_regs[i]);
-			} else if (platform_context->mmio_regs[i] == DPLLACNTR ||
-				platform_context->mmio_regs[i] == DPLLBCNTR) {
+					reg_platform_context->mmio_regs[i]);
+			} else if (reg_platform_context->mmio_regs[i] == DPLLACNTR ||
+				reg_platform_context->mmio_regs[i] == DPLLBCNTR) {
 
 					EMGD_DEBUG("Handle special DPLL settling");
 					EMGD_WRITE32(*buffer++,
-						mmio + platform_context->mmio_regs[i]);
+						mmio + reg_platform_context->mmio_regs[i]);
 					OS_SLEEP(150);
 			} else {
-				EMGD_WRITE32(*buffer++, mmio + platform_context->mmio_regs[i]);
+				EMGD_WRITE32(*buffer++, mmio + reg_platform_context->mmio_regs[i]);
 			}
 		}
 
@@ -1031,19 +1045,36 @@ int reg_restore_plb(igd_context_t *context,
 
 	/* Restore DAC registers */
 	if (reg_buffer->flags & IGD_REG_SAVE_DAC) {
-		reg_restore_dac_plb(context, &reg_args->dac_state, platform_context);
+		reg_restore_dac_plb(context, &reg_args->dac_state, reg_platform_context);
 	}
 
 	/* Restore VGA registers */
 	if (reg_buffer->flags & IGD_REG_SAVE_VGA) {
 		reg_restore_vga_plb(context, &reg_args->vga_state,
-			platform_context->ar, platform_context->cr, platform_context->sr,
-			platform_context->gr);
+			reg_platform_context->ar, reg_platform_context->cr, reg_platform_context->sr,
+			reg_platform_context->gr);
 	}
 
 	/* Restore the SGX clock gating settings */
 	EMGD_WRITE32(reg_args->clk_gating_ctl, mmio + PSB_CR_CLKGATECTL);
 
+	/* restore the Legacy Backlight Brightness register. This register 
+            * will be 0 when returning from power management causing backlight to be 
+            * off if the register is not saved and restored during power management 
+            */ 
+           if(OS_PCI_READ_CONFIG_32(platform_context->pcidev0, 0xF4, &lbb)) { 
+                   EMGD_ERROR("Reading Legacy Backlight Brightness"); 
+           } 
+    
+           /* only of the LBB has no value, causing the backlight to be off, we restore 
+            * the saved LBB value. This is just in case there are user applications 
+            * or firmware setting this register before the driver restores */ 
+           if(!(lbb & 0xFF)){ 
+                   if(OS_PCI_WRITE_CONFIG_32(platform_context->pcidev0, 
+                           0xF4, (lbb | reg_args->pci_lbb))){ 
+                           EMGD_ERROR("Writing into Legacy Backlight Brightness"); 
+                   } 
+           } 
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/emgd/emgd/state/reg/tnc/reg_tnc.c b/drivers/gpu/drm/emgd/emgd/state/reg/tnc/reg_tnc.c
index 969155e..10028ed 100644
--- a/drivers/gpu/drm/emgd/emgd/state/reg/tnc/reg_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/state/reg/tnc/reg_tnc.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: reg_tnc.c
- * $Revision: 1.18 $
+ * $Revision: 1.19 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -35,6 +35,7 @@
 #include <io.h>
 #include <memory.h>
 #include <sched.h>
+#include <pci.h>
 
 #include <igd_init.h>
 #include <igd_mode.h>
@@ -301,13 +302,12 @@ typedef struct _reg_buffer_tnc {
 	//unsigned long mem_mode; /* Reg 0x20CC */
 	//unsigned long instpm;   /* Reg 0x20C0 */
 	unsigned long gtt[128*1024]; /* PLB is 128 */
-	unsigned long sgx_phyaddr;
 	void *vga_mem;
 	vga_state_tnc_t vga_state;
 	dac_state_tnc_t dac_state;
 	d3d_state_tnc_t d3d_state;
 	void *rb_state;
-	unsigned long clk_gating_ctl;
+	unsigned long pci_lbb;
 } reg_buffer_tnc_t;
 
 static reg_platform_context_tnc_t reg_platform_context_tnc = {
@@ -901,10 +901,13 @@ static int reg_save_tnc(igd_context_t *context,
 {
 	reg_buffer_tnc_t           *reg_args;
 	unsigned long              *buffer, *buffer_sdvo;
-	reg_platform_context_tnc_t *platform_context =
+	reg_platform_context_tnc_t *reg_platform_context =
 		(reg_platform_context_tnc_t *)_platform_context;
 	int                        i;
 	unsigned char              *mmio, *mmio_sdvo, *mmio_sdvo_st, *mmio_sdvo_st_gpio;
+	platform_context_tnc_t *platform_context;
+	platform_context = (platform_context_tnc_t *)context->platform_context;
+
 
 	EMGD_TRACE_ENTER;
 
@@ -930,8 +933,8 @@ static int reg_save_tnc(igd_context_t *context,
 	if (reg_buffer->flags & IGD_REG_SAVE_VGA) {
 		EMGD_DEBUG("Saving VGA registers");
 		reg_save_vga_tnc(context, &reg_args->vga_state,
-			platform_context->ar, platform_context->cr, platform_context->sr,
-			platform_context->gr);
+			reg_platform_context->ar, reg_platform_context->cr, reg_platform_context->sr,
+			reg_platform_context->gr);
 	}
 
 	/* Save VGA memory */
@@ -957,13 +960,13 @@ static int reg_save_tnc(igd_context_t *context,
 	if (reg_buffer->flags & IGD_REG_SAVE_MMIO) {
 		EMGD_DEBUG("Saving MMIO registers");
 		buffer = reg_args->mmio_state;
-		for (i=0; platform_context->mmio_regs[i] != 0xffffffff; i++) {
-			*buffer++ = EMGD_READ32(mmio + platform_context->mmio_regs[i]);
+		for (i=0; reg_platform_context->mmio_regs[i] != 0xffffffff; i++) {
+			*buffer++ = EMGD_READ32(mmio + reg_platform_context->mmio_regs[i]);
 		}
 
 		buffer_sdvo = reg_args->mmio_state_sdvo;
-		for (i=0; platform_context->mmio_regs_sdvo[i] != 0xffffffff; i++) {
-			*buffer_sdvo++ = EMGD_READ32(mmio_sdvo + platform_context->mmio_regs_sdvo[i]);
+		for (i=0; reg_platform_context->mmio_regs_sdvo[i] != 0xffffffff; i++) {
+			*buffer_sdvo++ = EMGD_READ32(mmio_sdvo + reg_platform_context->mmio_regs_sdvo[i]);
 		}
 
 		if (reg_buffer->flags & IGD_REG_SAVE_GTT) {
@@ -974,7 +977,7 @@ static int reg_save_tnc(igd_context_t *context,
 	/* Save DAC registers */
 	if (reg_buffer->flags & IGD_REG_SAVE_DAC) {
 		EMGD_DEBUG("Saving DAC registers");
-		reg_save_dac_tnc(context, &reg_args->dac_state, platform_context);
+		reg_save_dac_tnc(context, &reg_args->dac_state, reg_platform_context);
 	}
 
 	/* Save Mode state */
@@ -993,8 +996,12 @@ static int reg_save_tnc(igd_context_t *context,
 		}
 	}
 
-	/* Save the SGX clock gating settings */
-	reg_args->clk_gating_ctl = EMGD_READ32(mmio + PSB_CR_CLKGATECTL);
+
+	/* Save the PCI Config Legacy Backlight Brightness Register */
+	if(OS_PCI_READ_CONFIG_32(platform_context->pcidev0,
+				0xF4, &reg_args->pci_lbb)) {
+		EMGD_DEBUG("Reading Legacy Backlight Brightness");
+	}
 
 	return 0;
 } /* reg_save */
@@ -1014,12 +1021,16 @@ int reg_restore_tnc(igd_context_t *context,
 	void *_platform_context)
 {
 	reg_buffer_tnc_t* reg_args;
-	reg_platform_context_tnc_t *platform_context =
+	reg_platform_context_tnc_t *reg_platform_context =
 		(reg_platform_context_tnc_t *)_platform_context;
 	unsigned char *mmio, *mmio_sdvo, *mmio_sdvo_st, *mmio_sdvo_st_gpio;
 	unsigned long *buffer, *buffer_sdvo;
+	unsigned long lbb;
 	int i;
 
+	platform_context_tnc_t *platform_context;
+	platform_context = (platform_context_tnc_t *)context->platform_context;
+
 	EMGD_DEBUG("Entry - reg_restore");
 
 	if (reg_buffer == NULL) {
@@ -1053,39 +1064,39 @@ int reg_restore_tnc(igd_context_t *context,
 	if (reg_buffer->flags & IGD_REG_SAVE_MMIO) {
 		EMGD_DEBUG("Restoring MMIO registers");
 		buffer = reg_args->mmio_state;
-		for (i=0; platform_context->mmio_regs[i] != 0xffffffff; i++) {
-			if (platform_context->mmio_regs[i] == MI_ARB_STATE) {
+		for (i=0; reg_platform_context->mmio_regs[i] != 0xffffffff; i++) {
+			if (reg_platform_context->mmio_regs[i] == MI_ARB_STATE) {
 				EMGD_DEBUG("Handle special masked register case");
 				EMGD_WRITE32(0x04100000 | *buffer++, mmio +
-					platform_context->mmio_regs[i]);
-			} else if (platform_context->mmio_regs[i] == DPLLACNTR ||
-				platform_context->mmio_regs[i] == DPLLBCNTR) {
+					reg_platform_context->mmio_regs[i]);
+			} else if (reg_platform_context->mmio_regs[i] == DPLLACNTR ||
+				reg_platform_context->mmio_regs[i] == DPLLBCNTR) {
 
 					EMGD_DEBUG("Handle special DPLL settling");
 					EMGD_WRITE32(*buffer++,
-						mmio + platform_context->mmio_regs[i]);
+						mmio + reg_platform_context->mmio_regs[i]);
 					OS_SLEEP(150);
 			} else {
-				EMGD_WRITE32(*buffer++, mmio + platform_context->mmio_regs[i]);
+				EMGD_WRITE32(*buffer++, mmio + reg_platform_context->mmio_regs[i]);
 			}
 		}
 //		reg_restore_gtt_tnc(context, reg_args);
 
 		buffer_sdvo = reg_args->mmio_state_sdvo;
-		for (i=0; platform_context->mmio_regs_sdvo[i] != 0xffffffff; i++) {
-			if (platform_context->mmio_regs_sdvo[i] == MI_ARB_STATE) {
+		for (i=0; reg_platform_context->mmio_regs_sdvo[i] != 0xffffffff; i++) {
+			if (reg_platform_context->mmio_regs_sdvo[i] == MI_ARB_STATE) {
 				EMGD_DEBUG("Handle special masked register case");
 				EMGD_WRITE32(0x04100000 | *buffer_sdvo++, mmio_sdvo +
-					platform_context->mmio_regs_sdvo[i]);
-			} else if (platform_context->mmio_regs_sdvo[i] == DPLLACNTR ||
-				platform_context->mmio_regs_sdvo[i] == DPLLBCNTR) {
+					reg_platform_context->mmio_regs_sdvo[i]);
+			} else if (reg_platform_context->mmio_regs_sdvo[i] == DPLLACNTR ||
+				reg_platform_context->mmio_regs_sdvo[i] == DPLLBCNTR) {
 
 					EMGD_DEBUG("Handle special DPLL settling");
 					EMGD_WRITE32(*buffer_sdvo++,
-						mmio_sdvo + platform_context->mmio_regs_sdvo[i]);
+						mmio_sdvo + reg_platform_context->mmio_regs_sdvo[i]);
 					OS_SLEEP(150);
 			} else {
-				EMGD_WRITE32(*buffer_sdvo++, mmio_sdvo + platform_context->mmio_regs_sdvo[i]);
+				EMGD_WRITE32(*buffer_sdvo++, mmio_sdvo + reg_platform_context->mmio_regs_sdvo[i]);
 			}
 		}
 
@@ -1108,18 +1119,34 @@ int reg_restore_tnc(igd_context_t *context,
 
 	/* Restore DAC registers */
 	if (reg_buffer->flags & IGD_REG_SAVE_DAC) {
-		reg_restore_dac_tnc(context, &reg_args->dac_state, platform_context);
+		reg_restore_dac_tnc(context, &reg_args->dac_state, reg_platform_context);
 	}
 
 	/* Restore VGA registers */
 	if (reg_buffer->flags & IGD_REG_SAVE_VGA) {
 		reg_restore_vga_tnc(context, &reg_args->vga_state,
-			platform_context->ar, platform_context->cr, platform_context->sr,
-			platform_context->gr);
+			reg_platform_context->ar, reg_platform_context->cr, reg_platform_context->sr,
+			reg_platform_context->gr);
 	}
 
-	/* Restore the SGX clock gating settings */
-	EMGD_WRITE32(reg_args->clk_gating_ctl, mmio + PSB_CR_CLKGATECTL);
+	/* restore the Legacy Backlight Brightness register. This register
+	 * will be 0 when returning from power management causing backlight to be
+	 * off if the register is not saved and restored during power management
+	 */
+	if(OS_PCI_READ_CONFIG_32(platform_context->pcidev0, 0xF4, &lbb)) {
+		EMGD_DEBUG("Reading Legacy Backlight Brightness");
+
+	}
+
+	/* only of the LBB has no value, causing the backlight to be off, we restore
+	 * the saved LBB value. This is just in case there are user applications
+	 * or firmware setting this register before the driver restores */
+	if(!(lbb & 0xFF)){
+		if(OS_PCI_WRITE_CONFIG_32(platform_context->pcidev0,
+										0xF4, (lbb | reg_args->pci_lbb))){
+			EMGD_DEBUG("Writing into Legacy Backlight Brightness");
+		}
+	}
 
 	return 0;
 }
@@ -1147,9 +1174,6 @@ static int reg_save_gtt_tnc(igd_context_t *context, unsigned char *mmio,
 			context->device_context.virt_gttadr + i);
 	}
 
-	/* Save the address of the SGX MMU */
-	reg_args->sgx_phyaddr = EMGD_READ32(mmio + PSB_CR_BIF_DIR_LIST_BASE0);
-
 	return 0;
 }
 
@@ -1166,8 +1190,6 @@ static int reg_restore_gtt_tnc(igd_context_t *context,
 	reg_buffer_tnc_t *reg_args)
 {
 	unsigned int i;
-	unsigned char *mmio;
-	unsigned long sgx_mmu;
 
 	/* If the first element is 0, then nothing was saved */
 	if (0 == reg_args->gtt[0]) {
@@ -1180,26 +1202,5 @@ static int reg_restore_gtt_tnc(igd_context_t *context,
 			context->device_context.virt_gttadr + i);
 	}
 
-	mmio = context->device_context.virt_mmadr;
-
-	/*
-	 * FIXME: The following code restore the SGX MMU. This
-	 * is probably not necessary and may be incorrect.
-	 */
-	/* Invalidate directory cache */
-	sgx_mmu = EMGD_READ32(mmio + PSB_CR_BIF_CTRL);
-	sgx_mmu |= 0x1E;
-	EMGD_WRITE32(sgx_mmu, mmio + PSB_CR_BIF_CTRL);
-	EMGD_READ32(mmio + PSB_CR_BIF_CTRL);
-
-	EMGD_WRITE32(reg_args->sgx_phyaddr, mmio + PSB_CR_BIF_DIR_LIST_BASE0);
-	EMGD_READ32(mmio + PSB_CR_BIF_DIR_LIST_BASE0);
-
-	/* Turn on host access to aperture via the MMU */
-	sgx_mmu = EMGD_READ32(mmio + PSB_CR_BIF_CTRL);
-	sgx_mmu &= 0xFFFF0000;
-	EMGD_WRITE32(sgx_mmu, mmio + PSB_CR_BIF_CTRL);
-	EMGD_READ32(mmio + PSB_CR_BIF_CTRL);
-
 	return 0;
 }
diff --git a/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx.c b/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx.c
index 644c3cc..c8db86c 100644
--- a/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx.c
+++ b/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: msvdx.c
- * $Revision: 1.27 $
+ * $Revision: 1.28 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -67,7 +67,7 @@ extern void msvdx_reset_plb(igd_context_t *context);
 int send_to_mtx(igd_context_t *context, unsigned long *msg);
 int msvdx_poll_mtx_irq(igd_context_t *context);
 void msvdx_mtx_interrupt_plb(igd_context_t *context);
-void populate_fence_id(igd_context_t *context, unsigned long *mtx_msgs,
+unsigned long populate_fence_id(igd_context_t *context, unsigned long *mtx_msgs,
 		unsigned long mtx_msg_cnt);
 int process_mtx_messages(igd_context_t *context,
 		unsigned long *mtx_msgs, unsigned long mtx_msg_cnt,
@@ -142,12 +142,13 @@ int msvdx_dequeue_send(igd_context_t *context)
     return ret;
 }
 
-void populate_fence_id(igd_context_t *context, unsigned long *mtx_msgs,
+unsigned long populate_fence_id(igd_context_t *context, unsigned long *mtx_msgs,
 		unsigned long mtx_msg_cnt)
 {
 	platform_context_plb_t *platform;
-	unsigned long submit_size;
-	unsigned long submit_id;
+	unsigned long submit_size = 0;
+	unsigned long submit_id = 0;
+	unsigned long context_id = 0;
 	unsigned int msg;
 
 	platform = (platform_context_plb_t *)context->platform_context;
@@ -161,8 +162,11 @@ void populate_fence_id(igd_context_t *context, unsigned long *mtx_msgs,
 			//printk(KERN_INFO "Update fence id %lx\n", mtx_msgs[4]);
 		}
 
+		context_id = mtx_msgs[3];
 		mtx_msgs += (submit_size / sizeof(unsigned long));
 	}
+
+	return context_id;
 }
 
 /*
@@ -210,6 +214,12 @@ int process_mtx_messages(igd_context_t *context,
 	skipped_msg_cnt = 0;
 
 	for (msg = 0; msg < mtx_msg_cnt; msg++) {
+
+		if(!mtx_msgs) {
+			printk(KERN_ERR "Invalid message");
+			return -IGD_ERROR_INVAL;
+		}
+
 		submit_size = (mtx_msgs[0] & 0x000000ff);
 		submit_id = (mtx_msgs[0] & 0x0000ff00) >> 8;
 
@@ -220,6 +230,11 @@ int process_mtx_messages(igd_context_t *context,
 			continue;
 		}
 
+		if(!(mtx_msgs + sizeof(unsigned long))) {
+			printk(KERN_ERR "Invalid message");
+			return -IGD_ERROR_INVAL;
+		}
+
 		/* reuse the sgx phy PD */
 		mtx_msgs[1] = platform->psb_cr_bif_dir_list_base1 | 1;
 
diff --git a/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_init.c b/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_init.c
index 6f83bd9..39932ca 100644
--- a/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_init.c
+++ b/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_init.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: msvdx_init.c
- * $Revision: 1.31 $
+ * $Revision: 1.32 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -58,9 +58,6 @@
 #include <general.h>
 #include <utils.h>
 #include <msvdx.h>
-#include <linux/export.h>
-#include <linux/module.h>
-
 
 #include <plb/regs.h>
 #include <plb/context.h>
@@ -70,6 +67,11 @@
 #include <osfunc.h>  /* for OSFlushCPUCacheKM() */
 #include "msvdx_pvr.h"
 
+#include <linux/version.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
+#include <linux/module.h>
+#include <linux/export.h>
+#endif
 struct drm_device *gpDrmDevice = NULL;
 static int init_msvdx_first_time = 1;
 static unsigned long msvdx_compositor_mmu_base = 0;
@@ -78,7 +80,7 @@ extern int process_mtx_messages(igd_context_t *context,
 		unsigned long *mtx_msgs, unsigned long mtx_msg_cnt,
 		unsigned long fence);
 
-extern void populate_fence_id(igd_context_t *context, unsigned long *mtx_msgs,
+extern unsigned long populate_fence_id(igd_context_t *context, unsigned long *mtx_msgs,
 		unsigned long mtx_msg_cnt);
 extern int msvdx_dequeue_send(igd_context_t *context);
 extern int alloc_ramdec_region(unsigned long *base_addr0, unsigned long *base_addr1,
@@ -260,6 +262,9 @@ unsigned long LastClockState;
 #define MSVDX_CORE_CR_BE_MSVDX_WDT_COMPAREMATCH_BE_WDT_CM0_SHIFT		(0)
 /*watch dog end*/
 
+#define FW_SIZE 16128
+#define MAX_FW_SIZE 16 * 1024
+
 enum {
 	MSVDX_DMAC_BSWAP_NO_SWAP = 0x0, /* No byte swapping will be performed */
 	MSVDX_DMAC_BSWAP_REVERSE = 0x1, /* Byte order will be reversed */
@@ -341,6 +346,14 @@ enum {
 #define MSVDX_CORE_CR_MSVDX_MAN_CLK_ENABLE_CR_MTX_MAN_CLK_ENABLE_MASK	\
 	(0x00000040)
 
+typedef struct _msvdx_context {
+	unsigned long context_id;
+	void *drm_file_priv;
+} msvdx_context_t;
+
+#define MSVDX_MAXIMUM_CONTEXT     8
+
+static msvdx_context_t msvdx_contexts[MSVDX_MAXIMUM_CONTEXT];
 
 
 int msvdx_init_compositor_mmu(unsigned long mmu_base) {
@@ -368,6 +381,24 @@ static int msvdx_map_fw(uint32_t size)
 	/* Round up as DMA's can overrun a page */
 	alloc_size = (size + 8192) & ~0x0fff;
 
+	/* Verify there is enough memory for the firmware text */
+	if( ((priv_fw->fw_text_size * 4) <= 0) ||
+		((priv_fw->fw_text_size * 4) > size) ) {
+		return -EINVAL;
+	}
+
+	if( ((priv_fw->fw_data_location - MTX_DATA_BASE) <=0) ||
+		((priv_fw->fw_data_location - MTX_DATA_BASE) > size) ) {
+		return -EINVAL;
+	}
+
+	/* Verify there is enough memory for the firmware data */
+	if( ((priv_fw->fw_data_size * 4) <= 0) ||
+		((priv_fw->fw_data_size * 4) > (size -
+				(priv_fw->fw_data_location - MTX_DATA_BASE))) ) {
+		return -EINVAL;
+	}
+
 	mem_info = platform->msvdx_pvr->fw_mem_info;
 	if (!mem_info) {
 		mem_info = msvdx_pvr_alloc_devmem(alloc_size, "MSVDX firmware");
@@ -611,7 +642,6 @@ static int msvdx_upload_fw(void)
 	/*
 	 * Get the ram bank size
 	 * The banks size seems to be a 4 bit value in the MTX debug register.
-	 * Where this is documented other than the UMG code is not clear.
 	 */
 	ram_bank = EMGD_READ32(mmio + PSB_MSVDX_MTX_RAM_BANK);
 	bank_size = (ram_bank & 0x000f0000) >> 16;
@@ -787,7 +817,7 @@ int msvdx_pre_init_plb(struct drm_device *dev)
 }
 
 int msvdx_init_plb(unsigned long base0, unsigned long base1,
-           void *msvdx_fw, unsigned long msvdx_fw_size, int reset_flag)
+           void *mem_handle_fw, int reset_flag)
 {
     drm_emgd_priv_t *priv;
     igd_context_t *context;
@@ -798,10 +828,34 @@ int msvdx_init_plb(unsigned long base0, unsigned long base1,
 	int tmp;
 	unsigned long fw_size;
 	unsigned long reg_val;
+	unsigned long irq_flags;
 	msvdx_fw_t *fw = NULL;
 	platform_context_plb_t *platform = NULL;
 	int ret =0;
 	int msvdx_status;
+	PVRSRV_ERROR err;
+	PVRSRV_PER_PROCESS_DATA *ps_data = NULL;
+	IMG_UINT32 pid = 0;
+	PVRSRV_KERNEL_MEM_INFO *mem_info_fw = NULL;
+
+	if(mem_handle_fw) {
+
+		pid = OSGetCurrentProcessIDKM();
+		ps_data = PVRSRVPerProcessData(pid);
+		if (!ps_data) {
+			printk(KERN_ERR "MSVDX: Cannot get process data information");
+			return -1;
+		}
+
+		err = PVRSRVLookupHandle(ps_data->psHandleBase, (void **)&mem_info_fw,
+				(IMG_HANDLE)mem_handle_fw, PVRSRV_HANDLE_TYPE_MEM_INFO);
+
+		if(err != PVRSRV_OK) {
+			printk(KERN_ERR "MSVDX: Cannot get memory context from process data");
+			return -1;
+		}
+
+	}
 
     priv = gpDrmDevice->dev_private;
 	context = priv->context;
@@ -810,9 +864,15 @@ int msvdx_init_plb(unsigned long base0, unsigned long base1,
 
     // return back if firmware is already loaded
     if (init_msvdx_first_time) {
-	spin_lock_init(&platform->msvdx_init_plb);
+		spin_lock_init(&platform->msvdx_init_plb);
     } else if(!reset_flag){
-	return ret;
+		if (context_count == 0) {
+			spin_lock_irqsave(&platform->msvdx_lock, irq_flags);
+			INIT_LIST_HEAD(&platform->msvdx_queue);  // empty the list.
+			spin_unlock_irqrestore(&platform->msvdx_lock, irq_flags);
+		}
+
+		return ret;
     }
 
     // Set the status for firmware loading
@@ -830,9 +890,43 @@ int msvdx_init_plb(unsigned long base0, unsigned long base1,
     }
     while((msvdx_status & 2));
 
-	if (!priv_fw && msvdx_fw) {
-		fw = (msvdx_fw_t *) msvdx_fw;
+	if (!priv_fw && mem_handle_fw) {
+		if(!mem_info_fw) {
+			ret = -1;
+			goto cleanup;
+		}
+
+		if(mem_info_fw->ui32AllocSize < FW_SIZE) {
+			ret = -1;
+			goto cleanup;
+		}
+
+		fw = (msvdx_fw_t *)mem_info_fw->pvLinAddrKM;
+
+		if((fw->fw_version_size <= 0) || (fw->fw_version_size > 64 )) {
+			ret = -1;
+			goto cleanup;
+		}
+
+		fw_size = sizeof(unsigned long) * fw->fw_text_size;
+		if((fw_size == 0) || (fw_size > MAX_FW_SIZE)) {
+			ret = -1;
+			goto cleanup;
+		}
+
+		fw_size = sizeof(unsigned long) * fw->fw_data_size;
+		if((fw_size == 0) || (fw_size > MAX_FW_SIZE)) {
+			ret = -1;
+			goto cleanup;
+		}
+
 		priv_fw = kzalloc(sizeof(msvdx_fw_t), GFP_KERNEL);
+		if (priv_fw == NULL) {
+			printk(KERN_ERR "MSVDX: Out of memory\n");
+			ret = -ENOMEM;
+			goto cleanup;
+		}
+
 		priv_fw->fw_text_size = fw->fw_text_size;
 		priv_fw->fw_data_size = fw->fw_data_size;
 		priv_fw->fw_version_size = fw->fw_version_size;
@@ -840,23 +934,52 @@ int msvdx_init_plb(unsigned long base0, unsigned long base1,
 
 		fw_size = sizeof(unsigned long) * fw->fw_text_size;
 		priv_fw->fw_text = kmalloc(fw_size, GFP_KERNEL);
-		memcpy(priv_fw->fw_text, (void *) ((unsigned long) msvdx_fw) +
+		if (priv_fw->fw_text == NULL) {
+			kfree (priv_fw);
+			priv_fw = NULL;
+			printk(KERN_ERR "MSVDX: Out of memory\n");
+			ret = -ENOMEM;
+			goto cleanup;
+		}
+		memcpy(priv_fw->fw_text, (void *) ((unsigned long)mem_info_fw->pvLinAddrKM) +
 				((unsigned long) fw->fw_text), fw_size);
 
 		fw_size = sizeof(unsigned long) * fw->fw_data_size;
 		priv_fw->fw_data = kmalloc(fw_size, GFP_KERNEL);
-		memcpy(priv_fw->fw_data, (void *) ((unsigned long) msvdx_fw) +
+		if (priv_fw->fw_data == NULL) {
+			kfree (priv_fw->fw_text);
+			priv_fw->fw_text = NULL;
+			kfree (priv_fw);
+			priv_fw = NULL;
+			printk(KERN_ERR "MSVDX: Out of memory\n");
+			ret = -ENOMEM;
+			goto cleanup;
+		}
+		memcpy(priv_fw->fw_data, (void *) ((unsigned long) mem_info_fw->pvLinAddrKM) +
 			((unsigned long) fw->fw_data), fw_size);
 
 		priv_fw->fw_version = kzalloc(priv_fw->fw_version_size, GFP_KERNEL);
-		strcpy(priv_fw->fw_version, (char *) (((unsigned long) msvdx_fw) +
-			((unsigned long) fw->fw_version)));
+		if (priv_fw->fw_version == NULL) {
+			kfree (priv_fw->fw_text);
+			kfree (priv_fw->fw_data);
+			priv_fw->fw_text = NULL;
+			priv_fw->fw_data = NULL;
+			kfree(priv_fw);
+			priv_fw = NULL;
+			printk(KERN_ERR "MSVDX: Out of memory\n");
+			ret = -ENOMEM;
+			goto cleanup;
+		}
+
+		strncpy(priv_fw->fw_version, (char *) (((unsigned long) mem_info_fw->pvLinAddrKM) +
+			((unsigned long) fw->fw_version)), priv_fw->fw_version_size);
+
 	} else if (!priv_fw) {
 		printk(KERN_INFO "Kernel firmware is not loaded");
 		if(init_msvdx_first_time) {
-			printk(KERN_ERR "ALAN!!! !priv_fw at msvdx init 1st");
+			printk(KERN_ERR "!priv_fw at msvdx init 1st");
 		}
-		ret = 1;
+		ret = -1;
 		goto cleanup;
 	}
 
@@ -919,7 +1042,7 @@ int msvdx_init_plb(unsigned long base0, unsigned long base1,
     REGIO_WRITE_FIELD(reg_val, MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL, FE_WDT_ACTION0, 1);
     REGIO_WRITE_FIELD(reg_val, MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL, FE_WDT_CLEAR_SELECT, 1);
     REGIO_WRITE_FIELD(reg_val, MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL, FE_WDT_CLKDIV_SELECT, 7);
-    printk(KERN_INFO "CTL_MSG: WDT Control value = 0x%lx", reg_val);
+    printk(KERN_INFO "CTL_MSG: WDT Control value = 0x%x", reg_val);
     EMGD_WRITE32(0, mmio + MSVDX_CORE_CR_FE_MSVDX_WDT_COMPAREMATCH_OFFSET);
     EMGD_WRITE32(reg_val, mmio + MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_OFFSET);
 
@@ -929,7 +1052,7 @@ int msvdx_init_plb(unsigned long base0, unsigned long base1,
     REGIO_WRITE_FIELD(reg_val, MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL, BE_WDT_ACTION0, 1);
     REGIO_WRITE_FIELD(reg_val, MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL, BE_WDT_CLEAR_SELECT, 0xd);
     REGIO_WRITE_FIELD(reg_val, MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL, BE_WDT_CLKDIV_SELECT, 7);
-    printk(KERN_INFO "CTL_MSG: WDT Control value = 0x%lx", reg_val);
+    printk(KERN_INFO "CTL_MSG: WDT Control value = 0x%x", reg_val);
     EMGD_WRITE32(0, mmio + MSVDX_CORE_CR_BE_MSVDX_WDT_COMPAREMATCH_OFFSET);
     EMGD_WRITE32(reg_val, mmio + MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_OFFSET);
 
@@ -980,6 +1103,7 @@ int msvdx_init_plb(unsigned long base0, unsigned long base1,
         INIT_LIST_HEAD(&platform->msvdx_queue);
 		spin_lock_init(&platform->msvdx_lock);
 
+		memset(msvdx_contexts, 0x00, sizeof(msvdx_context_t) * MSVDX_MAXIMUM_CONTEXT);
     } else {
         /* restore offsets. */
         platform = (platform_context_plb_t *)context->platform_context;
@@ -1182,12 +1306,49 @@ int msvdx_uninit_plb(igd_context_t *context)
 }
 
 
-int msvdx_close_context(igd_context_t *context)
+int msvdx_close_context(igd_context_t *context, unsigned long context_id)
 {
-	EMGD_TRACE_ENTER;
+	unsigned long irq_flags;
+	struct list_head *entry = NULL, *cur = NULL;
+    struct msvdx_cmd_queue *msvdx_cmd = NULL;
+    platform_context_plb_t *platform;
+	int i;
+
+    EMGD_TRACE_ENTER;
+
+    platform = (platform_context_plb_t *)context->platform_context;
+
+	spin_lock_irqsave(&platform->msvdx_lock, irq_flags);
+
+	list_for_each(entry, &platform->msvdx_queue) {
+		msvdx_cmd = (struct msvdx_cmd_queue *) entry;
+		if (msvdx_cmd->context_id == context_id) {
+			cur = entry;
+			entry = entry->prev;
+			list_del(cur);
+			msvdx_cmd->cmd = NULL;
+			kfree(msvdx_cmd);
+		}
+	}
+
+	for (i = 0; i <  MSVDX_MAXIMUM_CONTEXT; ++i) {
+		if (msvdx_contexts[i].context_id == context_id) {
+			msvdx_contexts[i].drm_file_priv = NULL;
+			msvdx_contexts[i].context_id = 0;
+		}
+	}
+
+	spin_unlock_irqrestore(&platform->msvdx_lock, irq_flags);
 
 	if(context_count) {
 		context_count -= 1;
+
+		if (context_count == 0 && !list_empty(&platform->msvdx_queue)) {
+            printk(KERN_ERR "MSVDX!!!  Closing final context but the list is still not empty");
+			spin_lock_irqsave(&platform->msvdx_lock, irq_flags);
+			INIT_LIST_HEAD(&platform->msvdx_queue);  // empty the list.
+			spin_unlock_irqrestore(&platform->msvdx_lock, irq_flags);
+		}
 	} else {
 		EMGD_TRACE_EXIT;
 		return 1;
@@ -1197,17 +1358,52 @@ int msvdx_close_context(igd_context_t *context)
 	return 0;
 }
 
-int msvdx_create_context(igd_context_t *context)
+int msvdx_create_context(igd_context_t *context, void * drm_file_priv, unsigned long ctx_id)
 {
+	int i = 0, ret = 0;
 	EMGD_TRACE_ENTER;
 
-	context_count +=1;
+	if(!drm_file_priv) {
+		return -EINVAL;
+	}
+
+	for (i = 0; i <  MSVDX_MAXIMUM_CONTEXT; ++i) {
+		if (msvdx_contexts[i].drm_file_priv == NULL) {
+			msvdx_contexts[i].drm_file_priv = drm_file_priv;
+			msvdx_contexts[i].context_id = ctx_id;
+			break;
+		}
+	}
+
+	if (i < MSVDX_MAXIMUM_CONTEXT) {
+		context_count += 1;
+	} else {
+		ret = -1;
+	}
 
 	EMGD_TRACE_EXIT;
-	return 0;
+	return ret;
 }
 
-int process_video_decode_plb(igd_context_t *context, unsigned long offset, void *virt_addr, unsigned long *fence_id)
+void msvdx_postclose_check(igd_context_t *context, void *drm_file_priv)
+{
+	int i;
+	EMGD_TRACE_ENTER;
+
+	for (i = 0; i <  MSVDX_MAXIMUM_CONTEXT; ++i) {
+		if (msvdx_contexts[i].drm_file_priv == drm_file_priv) {
+			printk(KERN_ERR "MSVDX!!! User mode does not call video closing ioctl.");
+			msvdx_close_context(context, msvdx_contexts[i].context_id);
+			msvdx_contexts[i].drm_file_priv = NULL;
+			msvdx_contexts[i].context_id = 0;
+		}
+	}
+
+	EMGD_TRACE_EXIT;
+}
+
+int process_video_decode_plb(igd_context_t *context, unsigned long offset,
+		void* mem_handle, unsigned long *fence_id)
 {
 	unsigned long *mtx_buf;
     unsigned long *mtx_msgs;
@@ -1216,21 +1412,55 @@ int process_video_decode_plb(igd_context_t *context, unsigned long offset, void
     unsigned long irq_flags;
 	int ret = 0;
     platform_context_plb_t *platform;
+	PVRSRV_ERROR err;
+	PVRSRV_PER_PROCESS_DATA *ps_data = NULL;
+	IMG_UINT32 pid = 0;
+	PVRSRV_KERNEL_MEM_INFO *mem_info_mtx_buf = NULL;
+
     EMGD_TRACE_ENTER;
 
+	if(!mem_handle || !fence_id) {
+		printk(KERN_ERR "Invalid message");
+		return -EINVAL;
+	}
 
     platform = (platform_context_plb_t *)context->platform_context;
 
-	mtx_buf = (unsigned long *) virt_addr;
+	pid = OSGetCurrentProcessIDKM();
+	ps_data = PVRSRVPerProcessData(pid);
+	if (!ps_data) {
+		printk(KERN_ERR "MSVDX: Cannot get process data information");
+		return -1;
+	}
+
+	err = PVRSRVLookupHandle(ps_data->psHandleBase, (void **)&mem_info_mtx_buf,
+			(IMG_HANDLE)mem_handle, PVRSRV_HANDLE_TYPE_MEM_INFO);
+
+	if(err != PVRSRV_OK) {
+		printk(KERN_ERR "MSVDX: Cannot get mtx buf memory context from process data");
+		return -1;
+	}
+
+	if(!mem_info_mtx_buf) {
+		printk(KERN_ERR "MSVDX: invalid mtx buf memory context from process data");
+		return -1;
+	}
+
+	mtx_buf = (unsigned long *) mem_info_mtx_buf->pvLinAddrKM;
     mtx_offset = mtx_buf[0];
     mtx_msg_cnt = mtx_buf[1];
 
-    if (mtx_msg_cnt > 0x20) {
-        printk(KERN_ERR "Message count too big at %ld\n", mtx_msg_cnt);
-        return -EINVAL;
-    }
+	if (mtx_msg_cnt > 0x20) {
+		printk(KERN_ERR "Message count too big at %ld\n", mtx_msg_cnt);
+		return -EINVAL;
+	}
+
+	mtx_msgs = mtx_buf + (mtx_offset / sizeof (unsigned long));
+	if(!mtx_msgs) {
+		printk(KERN_ERR "Invalid message");
+		return -EINVAL;
+	}
 
-    mtx_msgs = mtx_buf + (mtx_offset / sizeof (unsigned long));
 	if (mtx_msg_cnt > 0) {
 	//if ((mtx_buf[0] != 0x8) || (mtx_buf[2] != 0x8504)) {
 
@@ -1244,7 +1474,7 @@ int process_video_decode_plb(igd_context_t *context, unsigned long offset, void
 
 			if (platform->msvdx_needs_reset) {
 				msvdx_reset_plb(context);
-				msvdx_init_plb(0, 0, NULL, 0, 1);
+				msvdx_init_plb(0, 0, NULL, 1);
 				jiffies_at_last_dequeue = 0;
 			}
 			// Send message buffer to MSVDX Firmware
@@ -1267,7 +1497,7 @@ int process_video_decode_plb(igd_context_t *context, unsigned long offset, void
 				return -ENOMEM;
 			}
 
-			populate_fence_id(context, mtx_msgs, mtx_msg_cnt);
+			msvdx_cmd->context_id = populate_fence_id(context, mtx_msgs, mtx_msg_cnt);
 			msvdx_cmd->cmd = mtx_msgs;
 			msvdx_cmd->cmd_size = mtx_msg_cnt;
 			/* If more than 1000 msec (1 second or 1000 jiffies) passes since
@@ -1282,7 +1512,7 @@ int process_video_decode_plb(igd_context_t *context, unsigned long offset, void
 			}
 			if (platform->msvdx_needs_reset) {
 				msvdx_reset_plb(context);
-				msvdx_init_plb(0, 0, NULL, 0, 1);
+				msvdx_init_plb(0, 0, NULL, 1);
 				platform->msvdx_busy = 0;
 				jiffies_at_last_dequeue = 0;
 			}
@@ -1313,6 +1543,10 @@ int msvdx_get_fence_id(igd_context_t *context, unsigned long *fence_id)
 	int ret = 0;
     platform_context_plb_t *platform;
 
+    if(!fence_id) {
+    	return -EINVAL;
+    }
+
     platform = (platform_context_plb_t *)context->platform_context;
 
 	*fence_id = platform->mtx_completed;
diff --git a/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_pvr.c b/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_pvr.c
index 1e36594..d26ddcc 100644
--- a/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_pvr.c
+++ b/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_pvr.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: msvdx_pvr.c
- * $Revision: 1.10 $
+ * $Revision: 1.11 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -341,7 +341,7 @@ int msvdx_pvr_init(void)
 
 	for (i = 0; i < pvr->heap_count; i++) {
 		if (HEAP_IDX(pvr->heap_info[i].ui32HeapID) ==
-			SGX_GENERAL_MAPPING_HEAP_ID) {
+			SGX_VIDEO_HEAP_ID) {
 			pvr->mapping_heap_index = i;
 			break;
 		}
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/igd_ovl.c b/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/igd_ovl.c
index adf31a6..c5ee729 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/igd_ovl.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/igd_ovl.c
@@ -272,17 +272,31 @@ static int igd_query_ovl(igd_display_h display_h,
 		}
 	}
 
-	for (cur_ovl = 0; cur_ovl < OVL_MAX_HW; cur_ovl++) {
-		if (ovl_displays[cur_ovl] != NULL) {
-			ret = ovl_dispatch[cur_ovl].query_ovl(
-				(igd_display_h)(ovl_displays[cur_ovl]),
-				(flags & IGD_OVL_QUERY_MASK));
-			if (ret == FALSE) {
-				/* Can only return TRUE (event has occured and capability
-				 * is available) if it is TRUE for all displays */
-				return FALSE;
-			}
-		}
+	/* NOTE: As with alter_ovl2, user mode driver should decide which ovl
+	 * to flip. Instead of having a duplicate logic here to check for clone,
+	 * just flip the ovl bound to the display handle. This prevents a condition
+	 * in clone mode, where the user mode driver does 2 query_ovl calls for 
+	 * each ovl plane, that translates into 4 query_ovl calls in kernel.
+	 */
+
+	/* Determine which display this overlay belongs to */
+	if(display == ovl_displays[OVL_PRIMARY]) {
+		cur_ovl = 0;
+	} else if (display == ovl_displays[OVL_SECONDARY]) {
+		cur_ovl = 1;
+	} else {
+		/* shouldn't get here. */
+		EMGD_TRACE_EXIT;
+		return  -IGD_ERROR_INVAL;
+	}
+
+	ret = ovl_dispatch[cur_ovl].query_ovl(
+		(igd_display_h)(ovl_displays[cur_ovl]),
+		(flags & IGD_OVL_QUERY_MASK));
+	if (ret == FALSE) {
+		/* Can only return TRUE (event has occured and capability
+		 * is available) if it is TRUE for all displays */
+		return FALSE;
 	}
 
 	return ret;
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_virt.h b/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_virt.h
index 7b0a998..daadbe6 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_virt.h
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_virt.h
@@ -79,7 +79,7 @@ enum {
 #define OVL_MAX_HW    2  /* Maximum number of overlays */
 
 /* Define the maximum number of blend surfaces which can be used */
-#define MAX_BLEND_SURF 2
+#define MAX_BLEND_SURF 3
 
 typedef struct _ovl_context{
 	ovl_dispatch_t (*dispatch)[];  /* Pointer to an array */
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_plb_cache.c b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_plb_cache.c
index d05c475..8258de9 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_plb_cache.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_plb_cache.c
@@ -92,7 +92,9 @@ int is_changed_vq(
 		 (old_info->video_quality.brightness !=
 		  new_info->video_quality.brightness)      ||
 		 (old_info->video_quality.saturation !=
-		  new_info->video_quality.saturation)       );
+		  new_info->video_quality.saturation)       ||
+		   (old_info->video_quality.hue !=
+		  new_info->video_quality.hue)  );
 
 }
 
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/micro_ovl_tnc.c b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/micro_ovl_tnc.c
index 1bcbf29..c13a791 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/micro_ovl_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/micro_ovl_tnc.c
@@ -189,7 +189,9 @@ static int micro_spritec_update_video_quality_tnc(
 	unsigned int                 calc_contrast       = 0;
 	unsigned int                 calc_saturation_tmp = 0;
 	unsigned int                 calc_saturation     = 0;
-
+	unsigned int                 calc_hue_tmp = 0;
+	unsigned int                 calc_hue     = 0;
+	
 	EMGD_TRACE_ENTER;
 
 	/* If the src_surf pixel format is RGB, then brightness, contrast,
@@ -204,7 +206,9 @@ static int micro_spritec_update_video_quality_tnc(
 		if (video_quality->saturation != 0x8000) {
 			EMGD_DEBUG("RGB surfaces must set saturation to default");
 		}
-
+		if (video_quality->hue != 0x8000) {
+			EMGD_DEBUG("RGB surfaces must set saturation to default");
+		}
 		EMGD_WRITE32(OVL2_RGB_COLOR_DEF_CONT_BRGHT,
 			MMIO(display) + 0x721D0);
 		EMGD_WRITE32(OVL2_RGB_COLOR_DEF_SATN_HUE,
@@ -350,15 +354,53 @@ static int micro_spritec_update_video_quality_tnc(
 		(calc_saturation & 0x3FF),
 		MMIO(display) + 0x721D4);
 
-
 	/*************************************************************************
-	 * Hue
+	 * hue
 	 *************************************************************************/
-	/* Hue is always set to the default value.  It is based on the saturation
-	 * value, and having a separate hue is of minimal value. */
-	EMGD_WRITE32(EMGD_READ32(MMIO(display) + 0x721D4) & 0xF800FFFF,
+	if (video_quality->hue == 0x8000) {
+		calc_hue = 0;
+		} else if (video_quality->hue < 0x8000) {
+				/* we have here a hue that is less than the middle value
+				 * get 2's complement value decrease from 0x3ff to 0 */
+
+				calc_hue_tmp = 0x8000 - video_quality->hue;
+				calc_hue_tmp <<= 12;
+				calc_hue_tmp /= 0x8000;
+				calc_hue     = 0x3FF;
+				calc_hue     *= calc_hue_tmp;
+				calc_hue     += BIT11;
+				calc_hue     >>= 12;
+				
+				if (calc_hue > 0x3FF) {
+					calc_hue = 0x3FF;
+				}
+				/*  2's complement negative value equal the corresponding
+				 *  positive value reverse every bits then plus 1 
+				 * and add signed bit, then the calc_hue is from -0x3ff to 0 */
+
+				calc_hue = (~calc_hue + 1) & 0x7ff;
+		} else {
+			/* we have here a saturation that is more than the middle value
+			 * get 2's complement value increase from 0 to 0x3ff */
+
+			calc_hue_tmp = video_quality->hue - 0x8000;
+			calc_hue_tmp <<= 12;
+			calc_hue_tmp /= 0x8000;
+				calc_hue     = 0x3FF;
+				calc_hue     *= calc_hue_tmp;
+				calc_hue     += BIT11;
+				calc_hue     >>= 12;
+
+				if (calc_hue > 0x3FF) {
+					calc_hue = 0x3FF;
+				}
+		}
+	/* set 11bits hue value to register */
+	EMGD_WRITE32((EMGD_READ32(MMIO(display) + 0x721D4) & 0xF800FFFF) |
+		(calc_hue & 0x7FF) << 16,
 		MMIO(display) + 0x721D4);
 
+
 	EMGD_TRACE_EXIT;
 	return IGD_SUCCESS;
 }
@@ -859,7 +901,8 @@ static int micro_spritec_update_video_quality_tnc(
 	unsigned int                 calc_contrast       = 0;
 	unsigned int                 calc_saturation_tmp = 0;
 	unsigned int                 calc_saturation     = 0;
-
+	unsigned int                 calc_hue_tmp = 0;
+	unsigned int                 calc_hue     = 0;
 	EMGD_TRACE_ENTER;
 
 	/* If the src_surf pixel format is RGB, then brightness, contrast,
@@ -874,7 +917,9 @@ static int micro_spritec_update_video_quality_tnc(
 		if (video_quality->saturation != 0x8000) {
 			EMGD_DEBUG("RGB surfaces must set saturation to default");
 		}
-
+		if (video_quality->hue != 0x8000) {
+			EMGD_DEBUG("RGB surfaces must set saturation to default");
+		}
 		ovl_cache.ovl2_regs.cont_bright = OVL2_RGB_COLOR_DEF_CONT_BRGHT;
 		ovl_cache.ovl2_regs.satn_hue =  OVL2_RGB_COLOR_DEF_SATN_HUE;
 
@@ -1014,18 +1059,57 @@ static int micro_spritec_update_video_quality_tnc(
 			calc_saturation = 0x3FF;
 		}
 	}
-
+	
 	ovl_cache.ovl2_regs.satn_hue =
 		(ovl_cache.ovl2_regs.satn_hue & 0xFFFFFC00 ) |
 		(calc_saturation & 0x3FF);
 
 	/*************************************************************************
-	 * Hue
+	 * hue
 	 *************************************************************************/
-	/* Hue is always set to the default value.  It is based on the saturation
-	 * value, and having a separate hue is of minimal value. */
+	if (video_quality->hue == 0x8000) {
+		calc_hue = 0;
+		} else if (video_quality->hue < 0x8000) {
+				/* we have here a hue that is less than the middle value
+				 * get 2's complement value decrease from 0x3ff to 0 */
+
+				calc_hue_tmp = 0x8000 - video_quality->hue;
+				calc_hue_tmp <<= 12;
+				calc_hue_tmp /= 0x8000;
+				calc_hue     = 0x3FF;
+				calc_hue     *= calc_hue_tmp;
+				calc_hue     += BIT11;
+				calc_hue     >>= 12;
+				
+				if (calc_hue > 0x3FF) {
+					calc_hue = 0x3FF;
+				}
+				/*  2's complement negative value equal the corresponding
+				 *  positive value reverse every bits then plus 1 
+				 * and add signed bit, then the calc_hue is from -0x3ff to 0 */
+
+				calc_hue = (~calc_hue + 1) & 0x7ff;
+		} else {
+			/* we have here a saturation that is more than the middle value
+			 * get 2's complement value increase from 0 to 0x3ff */
+
+			calc_hue_tmp = video_quality->hue - 0x8000;
+			calc_hue_tmp <<= 12;
+			calc_hue_tmp /= 0x8000;
+				calc_hue     = 0x3FF;
+				calc_hue     *= calc_hue_tmp;
+				calc_hue     += BIT11;
+				calc_hue     >>= 12;
+
+				if (calc_hue > 0x3FF) {
+					calc_hue = 0x3FF;
+				}
+		}
+		
+	/* set 11bits hue value to register */	
 	ovl_cache.ovl2_regs.satn_hue =
-		(ovl_cache.ovl2_regs.satn_hue & 0xF800FFFF);
+		(ovl_cache.ovl2_regs.satn_hue & 0xF800FFFF ) |
+		((calc_hue & 0x7FF) << 16);
 
 	EMGD_TRACE_EXIT;
 	return IGD_SUCCESS;
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_tnc.c b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_tnc.c
index 1c577c4..563dcda 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_tnc.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: ovl2_tnc.c
- * $Revision: 1.21 $
+ * $Revision: 1.23 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -265,7 +265,7 @@ unsigned int ovl2_send_instr_tnc(
 	unsigned int      flags)
 {
 	unsigned char *mmio = MMIO(display);
-	unsigned long tmp;
+	 unsigned long tmp, pipe_reg, pipe_num;
 	inter_module_dispatch_t *md;
 	platform_context_tnc_t * platform;
 
@@ -324,9 +324,18 @@ unsigned int ovl2_send_instr_tnc(
 	md = &display->context->mod_dispatch;
 	platform = (platform_context_tnc_t *)display->context->
 					platform_context;
+
+	pipe_num = PIPE(display)->pipe_num; 
+    
+	if(pipe_num){ 
+		pipe_reg = PIPEB_STAT; 
+	} else { 
+		pipe_reg = PIPEA_STAT; 
+	} 
+
 	if(md && md->set_flip_pending){
 		OS_PTHREAD_MUTEX_LOCK(&platform->flip_mutex);
-		md->set_flip_pending(MMIO(display), 0x71024);
+		md->set_flip_pending(MMIO(display), pipe_reg);
 		OS_PTHREAD_MUTEX_UNLOCK(&platform->flip_mutex);
 	}
 
@@ -371,6 +380,7 @@ int query_ovl2_tnc(igd_display_h display_h,
 	platform_context_tnc_t * platform;
 	os_alarm_t timeout;
 	int ret;
+	unsigned long pipe_reg, pipe_num;
 
 	EMGD_TRACE_ENTER;
 
@@ -400,9 +410,17 @@ int query_ovl2_tnc(igd_display_h display_h,
 		md = &display->context->mod_dispatch;
 		platform = (platform_context_tnc_t *)display->context->
 						platform_context;
+
+		pipe_num = PIPE(display)->pipe_num; 
+		if(pipe_num){ 
+			pipe_reg = PIPEB_STAT; 
+		} else { 
+			pipe_reg = PIPEA_STAT; 
+		} 
+
 		if(md && md->check_flip_pending){
 			ret = OS_PTHREAD_MUTEX_LOCK(&platform->flip_mutex);
-			if(md->check_flip_pending(MMIO(display), 0x71024)){
+			if(md->check_flip_pending(MMIO(display), pipe_reg)){
 				OS_PTHREAD_MUTEX_UNLOCK(&platform->flip_mutex);
 				EMGD_DEBUG("Overlay2 Sync done but Flip not done");
 				return FALSE;
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc.c b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc.c
index 116489c..2565f48 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc.c
@@ -45,6 +45,7 @@
 #include "../cmn/ovl_coeff.h"
 #include "ovl2_tnc.h"
 
+#define OVL_DOWNSCALE_X_WORKAROUND
 
 /*-----------------------------------------------------------------------------
  * Common dispatch functions
@@ -100,6 +101,16 @@ static ovl_chipset_tnc_t ovl_chipset_tnc[] = {
 		(PF_DEPTH_8 | PF_TYPE_YUV_PLANAR), 1920, 1088},
 	{OVL_CONFIG_NO_LINE_BUFF, 0, 0, 0}
 };
+/* for Direct Display */
+typedef struct _dd_context_tnc {
+	igd_dd_context_t    bridge;
+	igd_surface_t       surf;
+	igd_ovl_info_t      ovl;
+} dd_context_tnc_t;
+
+/* Pointers to allocated memory for the Direct Display context info */
+static dd_context_tnc_t *dd_context_ovl;
+static dd_context_tnc_t *dd_context_ovl2;
 
 #ifdef DEBUG_BUILD_TYPE
 static void ovl_dump_regs_tnc(
@@ -970,6 +981,8 @@ static int ovl_update_video_quality_tnc(
 	unsigned int                 calc_contrast       = 0;
 	unsigned int                 calc_saturation_tmp = 0;
 	unsigned int                 calc_saturation     = 0;
+	unsigned int                 calc_hue_tmp = 0;
+	unsigned int                 calc_hue     = 0;
 
 	EMGD_TRACE_ENTER;
 
@@ -985,7 +998,9 @@ static int ovl_update_video_quality_tnc(
 		if (video_quality->saturation != 0x8000) {
 			EMGD_DEBUG("RGB surfaces must set saturation to default");
 		}
-
+		if (video_quality->hue != 0x8000) {
+					EMGD_DEBUG("RGB surfaces must set hue to default");
+		}
 		ovl_regs_tnc->col_ctl_brt_con = OVL_RGB_COLOR_DEF_CONT_BRGHT;
 		ovl_regs_tnc->col_ctl_sat_hue = OVL_RGB_COLOR_DEF_SATN_HUE;
 
@@ -1125,16 +1140,54 @@ static int ovl_update_video_quality_tnc(
 	}
 
 	ovl_regs_tnc->col_ctl_sat_hue =
-		(ovl_regs_tnc->col_ctl_sat_hue & 0xFFFFFC00) |
-		(calc_saturation & 0x3FF);
+			(ovl_regs_tnc->col_ctl_sat_hue & 0xFFFFFC00) |
+			(calc_saturation & 0x3FF);				// add 10bits saturation value
 
 	/*************************************************************************
-	 * Hue
+	 * hue
 	 *************************************************************************/
-	/* Hue is always set to the default value.  It is based on the saturation
-	 * value, and having a separate hue is of minimal value. */
-	ovl_regs_tnc->col_ctl_sat_hue =
-		(ovl_regs_tnc->col_ctl_sat_hue & 0xF800FFFF);
+	if (video_quality->hue == 0x8000) {
+		calc_hue = 0;
+		} else if (video_quality->hue < 0x8000) {
+				/* we have here a hue that is less than the middle value
+				 * get 2's complement value decrease from 0x3ff to 0 */
+
+				calc_hue_tmp = 0x8000 - video_quality->hue;
+				calc_hue_tmp <<= 12;
+				calc_hue_tmp /= 0x8000;
+				calc_hue     = 0x3FF;
+				calc_hue     *= calc_hue_tmp;
+				calc_hue     += BIT11;
+				calc_hue     >>= 12;
+				
+				if (calc_hue > 0x3FF) {
+					calc_hue = 0x3FF;
+				}
+				/*  2's complement negative value equal the corresponding
+				 *  positive value reverse every bits then plus 1 
+				 * and add signed bit, then the calc_hue is from -0x3ff to 0 */
+
+				calc_hue = (~calc_hue + 1) & 0x7ff;
+		} else {
+			/* we have here a saturation that is more than the middle value
+			 * get 2's complement value increase from 0 to 0x3ff */
+
+			calc_hue_tmp = video_quality->hue - 0x8000;
+			calc_hue_tmp <<= 12;
+			calc_hue_tmp /= 0x8000;
+				calc_hue     = 0x3FF;
+				calc_hue     *= calc_hue_tmp;
+				calc_hue     += BIT11;
+				calc_hue     >>= 12;
+
+				if (calc_hue > 0x3FF) {
+					calc_hue = 0x3FF;
+				}
+		}
+		/* add 11bits hue value to register */
+		ovl_regs_tnc->col_ctl_sat_hue = 
+			(ovl_regs_tnc->col_ctl_sat_hue & 0xF800FFFF)  |
+			((calc_hue & 0x7FF) << 16); 
 
 	EMGD_TRACE_EXIT;
 	return IGD_SUCCESS;
@@ -2126,3 +2179,291 @@ static int query_max_size_ovl_tnc(
 	EMGD_TRACE_EXIT;
 	return IGD_SUCCESS;
 }
+
+/*
+ * enable_direct_display_tnc(): Enables direct display of video DMA input
+ * buffers on the Overlay or Sprite C plane of the specified screen.
+ */
+int enable_direct_display_tnc(void *arg, igd_dd_context_t dd_context)
+{
+	igd_display_context_t *display = (igd_display_context_t *)arg;
+	dd_context_tnc_t *dd_context_ptr;
+#ifdef OVL_DOWNSCALE_X_WORKAROUND
+	int src_w, dest_w, scale, rem, fix_needed;
+#endif
+
+	EMGD_TRACE_ENTER;
+
+	/* Ensure the display context has been set */
+	if (display == NULL) {
+		printk(KERN_ERR "display context (arg) cannot be NULL !\n");
+		return -EINVAL;
+	}
+	/* Ensure the igd context has been set */
+	if (display->context == NULL) {
+		printk(KERN_INFO "igd context cannot be NULL !\n");
+		return -EINVAL;
+	}
+	switch (dd_context.usage) {
+	case IGD_PLANE_OVERLAY_VIDEO:
+		/* Check to see if direct display on Overlay plane is available */
+		if (dd_context_ovl) {
+			printk(KERN_ERR "Overlay direct display already enabled !\n");
+			return -EBUSY;
+		}
+		break;
+	case IGD_PLANE_SPRITE_VIDEO:
+		/* Check to see if direct display on Sprite C plane is available */
+		if (dd_context_ovl2) {
+			printk(KERN_ERR "Overlay direct display already enabled !\n");
+			return -EBUSY;
+		}
+		break;
+	default:
+		printk(KERN_ERR "Invalid direct display usage type (%d) !\n",
+				dd_context.usage);
+		return -EINVAL;
+	}
+	/* Attempt to allocate the direct display context block */
+	dd_context_ptr = OS_ALLOC(sizeof(dd_context_tnc_t));
+	if (dd_context_ptr == NULL) {
+		printk(KERN_ERR "Unable to allocate DD context block !\n");
+		return -ENOMEM;
+	}
+	/* Clear the DD context block and then copy the bridge data into it */
+	OS_MEMSET(dd_context_ptr, 0, sizeof(dd_context_tnc_t));
+	dd_context_ptr->bridge = dd_context;
+
+	/* Initialize color keying, video quality, and gamma */
+	dd_context_ptr->ovl.color_key.src_lo = 0x00000000;
+	dd_context_ptr->ovl.color_key.src_hi = 0x00000000;
+	dd_context_ptr->ovl.color_key.dest = 0xFF00FF; /* customer specified */
+	dd_context_ptr->ovl.color_key.flags = IGD_OVL_DST_COLOR_KEY_DISABLE;
+	dd_context_ptr->ovl.video_quality.contrast = 0x8000;
+	dd_context_ptr->ovl.video_quality.brightness = 0x8000;
+	dd_context_ptr->ovl.video_quality.saturation = 0x8000;
+	dd_context_ptr->ovl.video_quality.hue = 0x8000;
+	dd_context_ptr->ovl.gamma.red = 0x100;
+	dd_context_ptr->ovl.gamma.green = 0x100;
+	dd_context_ptr->ovl.gamma.blue = 0x100;
+	dd_context_ptr->ovl.gamma.flags = IGD_OVL_GAMMA_DISABLE;
+
+	/* Ensure source rectangle starts on even coordinates */
+	dd_context_ptr->bridge.src.x1 = (dd_context_ptr->bridge.src.x1 + 1) & ~1;
+	dd_context_ptr->bridge.src.y1 = (dd_context_ptr->bridge.src.y1 + 1) & ~1;
+
+	/* Ensure destination rectangle starts on even coordinates */
+	dd_context_ptr->bridge.dest.x1 = (dd_context_ptr->bridge.dest.x1 + 1) & ~1;
+	dd_context_ptr->bridge.dest.y1 = (dd_context_ptr->bridge.dest.y1 + 1) & ~1;
+
+	/* Initialize the generic rendering surface attributes */
+	dd_context_ptr->surf.width = dd_context_ptr->bridge.src.x2 -
+		dd_context_ptr->bridge.src.x1 + 1;
+	dd_context_ptr->surf.height = dd_context_ptr->bridge.src.y2 -
+		dd_context_ptr->bridge.src.y1 + 1;
+	dd_context_ptr->surf.flags = IGD_OVL_ALTER_ON;
+	dd_context_ptr->surf.pitch = dd_context.video_pitch;
+
+#ifdef OVL_DOWNSCALE_X_WORKAROUND
+	src_w = dd_context_ptr->surf.width;
+	dest_w = dd_context_ptr->bridge.dest.x2 - dd_context_ptr->bridge.dest.x1 + 1;
+	scale = src_w / dest_w;
+	rem = src_w % dest_w;
+	fix_needed = 0;
+
+	/*
+	 * If downscaling along the X dimension we need to avoid scale factors
+	 * that are greater than 4 and less than 9, and greater than 12.  The
+	 * issue is with the destination rectangle, so we leave the source
+	 * rectangle as specified, and expand the destination rectangle to be
+	 * exactly 4 or 12 times smaller.  We have to adjust the start and/or
+	 * end position accordingly, so that it fits within the screen bounds.
+	 */
+	if (src_w > dest_w) {
+		if ((scale > 4 && scale < 9) || (scale == 4 && rem)) {
+			/* Force a scale factor of 4 here */
+			dest_w = src_w / 4;
+			fix_needed = 1;
+		} else if ((scale > 12) || (scale == 12 && rem)) {
+			/* Force a scale factor of 12 here */
+			dest_w = src_w / 12;
+			fix_needed = 1;
+		}
+		if (fix_needed) {
+			/* Adjust the destination X endpoint */
+			dd_context_ptr->bridge.dest.x2 =
+				dd_context_ptr->bridge.dest.x1 + dest_w - 1;
+
+			/* Ensure rectangle X coordinates fit on screen */
+			if (dd_context_ptr->bridge.dest.x2 >= 
+				dd_context_ptr->bridge.screen_w) {
+				/* Adjust X end position to screen edge */
+				dd_context_ptr->bridge.dest.x2 =
+					dd_context_ptr->bridge.screen_w - 1;
+				/* Adjust X start position according to width */
+				dd_context_ptr->bridge.dest.x1 =
+					dd_context_ptr->bridge.dest.x2 - dest_w + 1;
+			}
+		}
+	}
+#endif
+	if (dd_context.usage == IGD_PLANE_OVERLAY_VIDEO) {
+		/* Initialize the YUV422-specific surface attributes */
+		dd_context_ptr->surf.pixel_format = IGD_PF_YUV422_PACKED_UYVY;
+
+		/* Save this pointer as our Overlay context */
+		dd_context_ovl = dd_context_ptr;
+	} else {
+		/* Initialize the RGB565-specific surface attributes */
+		dd_context_ptr->surf.pixel_format = IGD_PF_RGB16_565;
+		dd_context_ptr->surf.pitch *= 2; /* RGB565 = 2 Bpp */
+
+		/* Save this pointer as our Overlay 2 (Sprite C) context */
+		dd_context_ovl2 = dd_context_ptr;
+	}
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+EXPORT_SYMBOL(enable_direct_display_tnc);
+
+
+/*
+ * disable_direct_display_tnc(): Disables direct display of video on the
+ * Overlay plane or Sprite C plane.
+ */
+int disable_direct_display_tnc(void *arg, int usage)
+{
+	igd_display_context_t *display = (igd_display_context_t *)arg;
+	dd_context_tnc_t *dd_context_ptr;
+	int ret;
+
+	EMGD_TRACE_ENTER;
+
+	/* Ensure the display context has been set */
+	if (display == NULL) {
+		printk(KERN_ERR "Display context (arg) cannot be NULL !\n");
+		return -EINVAL;
+	}
+	/* Set the direct display context pointer according to the usage arg */
+	dd_context_ptr =
+		(usage == IGD_PLANE_OVERLAY_VIDEO) ? dd_context_ovl : dd_context_ovl2;
+
+	/* Ensure this direct display context pointer is set */
+	if (dd_context_ptr == NULL) {
+		printk(KERN_ERR "%s direct display not currently enabled !\n",
+				(usage == IGD_PLANE_OVERLAY_VIDEO) ? "Overlay" : "Sprite C");
+		return -EINVAL;
+	}
+	/* Set the flag to turn Overlay/Sprite C off */
+	dd_context_ptr->surf.flags = IGD_OVL_ALTER_OFF;
+
+	/* Check the DD context being referenced */
+	if (usage == IGD_PLANE_OVERLAY_VIDEO) {
+		/* Disable the display of the Overlay plane */
+		ret = alter_ovl_tnc(display, &dd_context_ovl->surf,
+				&dd_context_ovl->bridge.src, &dd_context_ovl->bridge.dest,
+				&dd_context_ovl->ovl, dd_context_ovl->surf.flags);
+
+		/* Mark the Overlay direct display context as invalid */
+		dd_context_ovl = NULL;
+	} else {
+		/* Disable the display of the Sprite C plane */
+		ret = alter_ovl2_tnc(display, &dd_context_ovl2->surf,
+				&dd_context_ovl2->bridge.src, &dd_context_ovl2->bridge.dest,
+				&dd_context_ovl2->ovl, dd_context_ovl2->surf.flags);
+
+		/* Mark the Sprite C direct display context as invalid */
+		dd_context_ovl2 = NULL;
+	}
+	/* Deallocate the DD context block for the direct display plane */
+	OS_FREE(dd_context_ptr);
+
+	EMGD_TRACE_EXIT;
+	return ret;
+}
+EXPORT_SYMBOL(disable_direct_display_tnc);
+
+
+/*
+ * direct_display_frame_tnc(): Performs the direct display of the new frame
+ * of video data on the Overlay plane or Sprite C plane.
+ */
+int direct_display_frame_tnc(void *arg, int usage, unsigned long offset)
+{
+	igd_display_context_t *display = (igd_display_context_t *)arg;
+	dd_context_tnc_t *dd_context_ptr;
+	int ret;
+
+	EMGD_TRACE_ENTER;
+
+	/* Ensure the display context is set */
+	if (display == NULL) {
+		printk(KERN_ERR "display context cannot be NULL !!!\n");
+		return -EINVAL;
+	}
+	/* Set the direct display context pointer according to the usage arg */
+	dd_context_ptr =
+		(usage == IGD_PLANE_OVERLAY_VIDEO) ? dd_context_ovl : dd_context_ovl2;
+
+	/* Ensure this direct display context pointer is set */
+	if (dd_context_ptr == NULL) {
+		printk(KERN_ERR "%s direct display context not set !\n",
+				(usage == IGD_PLANE_OVERLAY_VIDEO) ? "Overlay" : "Sprite C");
+		return -EINVAL;
+	}
+
+	/* Update the surface offset corresponding to this new frame */
+		dd_context_ptr->surf.offset = offset;
+	
+	if (usage == IGD_PLANE_OVERLAY_VIDEO) {
+		/* display the new video frame on the Overlay plane */
+		ret = alter_ovl_tnc(display, &dd_context_ovl->surf,
+				&dd_context_ovl->bridge.src, &dd_context_ovl->bridge.dest,
+				&dd_context_ovl->ovl, dd_context_ovl->surf.flags);
+	} else {
+		/* display the new video frame on the Sprite C plane */
+		ret = alter_ovl2_tnc(display, &dd_context_ovl2->surf,
+				&dd_context_ovl2->bridge.src, &dd_context_ovl2->bridge.dest,
+				&dd_context_ovl2->ovl, dd_context_ovl2->surf.flags);
+	}
+	EMGD_TRACE_EXIT;
+	return ret;
+}
+EXPORT_SYMBOL(direct_display_frame_tnc);
+/*
+ * ovl_set_dest_colorkey_tnc(): Performs the enable or disable colorkey on the Overlay plane.
+ */
+int ovl_set_dest_colorkey_tnc(igd_dd_context_t dd_context, igd_ovl_color_key_info_t *color_key)
+{
+	EMGD_TRACE_ENTER;
+	switch (dd_context.usage) {
+	case IGD_PLANE_OVERLAY_VIDEO:
+		/* Check to see if direct display on Overlay plane is available */
+		if (!dd_context_ovl) {
+			printk(KERN_ERR "Overlay direct display = NULL !\n");
+			return -EINVAL;
+		}
+
+		dd_context_ovl->ovl.color_key.dest = color_key->dest;
+		dd_context_ovl->ovl.color_key.flags = color_key->flags;
+		break;
+	case IGD_PLANE_SPRITE_VIDEO:
+		/* Check to see if direct display on Sprite C plane is available */
+		if (!dd_context_ovl2) {
+			printk(KERN_ERR "Overlay direct display2 = NULL !\n");
+			return -EINVAL;
+		}
+
+		dd_context_ovl2->ovl.color_key.dest = color_key->dest;
+		dd_context_ovl2->ovl.color_key.flags = color_key->flags;
+		break;
+	default:
+		printk(KERN_ERR "Invalid direct display usage type (%d) !\n",
+				dd_context.usage);
+		return -EINVAL;
+	}	
+	
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+EXPORT_SYMBOL(ovl_set_dest_colorkey_tnc);
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc_cache.c b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc_cache.c
index 734e0d6..f3d162e 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc_cache.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc_cache.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: ovl_tnc_cache.c
- * $Revision: 1.5 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -136,8 +136,6 @@ unsigned int get_cache_changes_tnc(
 {
 	unsigned int cache_changed = 0;
 
-	ovl_cache->ovl2_regs.control = 0;
-
 	/* Have the flags changed? */
 	if (ovl_cache->flags != flags) {
 
diff --git a/drivers/gpu/drm/emgd/emgd/video/topaz/topaz.c b/drivers/gpu/drm/emgd/emgd/video/topaz/topaz.c
index f710ff2..89b8fcf 100644
--- a/drivers/gpu/drm/emgd/emgd/video/topaz/topaz.c
+++ b/drivers/gpu/drm/emgd/emgd/video/topaz/topaz.c
@@ -48,6 +48,9 @@
 #include <plb/regs.h>
 #include <plb/context.h>
 
+#define MAX_CURRENT_TOPAZ_CMD_SIZE 5
+#define MAX_TOPAZ_CMD_SIZE 0x20
+
 void write_mtx_mem_multiple_setup(igd_context_t *context,
 		unsigned long addr)
 {
@@ -131,7 +134,7 @@ int mtx_send_tnc(igd_context_t *context, unsigned long *msg)
 		if (ret == 0) {
 			topaz_priv->topaz_cmd_windex = 0;
 		} else {
-			EMGD_ERROR("TOPAZ: poll rindex timeout\n");
+			printk(KERN_ERR "TOPAZ: poll rindex timeout\n");
 			return ret; /* HW may hang, need reset */
 		}
 		EMGD_DEBUG("TOPAZ: -------wrap CCB was done.\n");
@@ -229,7 +232,7 @@ int process_encode_mtx_messages(igd_context_t *context,
 			unsigned long size)
 {
 	unsigned long *command = (unsigned long *) mtx_buf;
-	unsigned long cmd_size = size;
+	unsigned long cmd_size = 0;
 	int ret = 0;
 	struct topaz_cmd_header *cur_cmd_header;
 	unsigned long cur_cmd_size, cur_cmd_id;
@@ -241,9 +244,21 @@ int process_encode_mtx_messages(igd_context_t *context,
 	topaz_priv = &platform->tpz_private_data;
 
 	cur_cmd_header = (struct topaz_cmd_header *) command;
+
+	if(!cur_cmd_header) {
+		printk(KERN_ERR "TOPAZ: Invalid Command\n");
+		return -IGD_ERROR_INVAL;
+	}
+
 	cur_cmd_size = cur_cmd_header->size;
 	cur_cmd_id = cur_cmd_header->id;
 
+	/* Verify the incoming current command size */
+	if((cur_cmd_size == 0) || (cur_cmd_size > MAX_CURRENT_TOPAZ_CMD_SIZE)) {
+		printk(KERN_ERR "TOPAZ: Invalid Command Size\n");
+		return -IGD_ERROR_INVAL;
+	}
+
 	while (cur_cmd_id != MTX_CMDID_NULL) {
 
 		switch (cur_cmd_id) {
@@ -251,7 +266,7 @@ int process_encode_mtx_messages(igd_context_t *context,
 				codec = *((unsigned long *) mtx_buf + 1);
 				EMGD_DEBUG("TOPAZ: setup new codec %ld\n", codec);
 				if (topaz_setup_fw(context, codec)) {
-					EMGD_ERROR("TOPAZ: upload FW to HW failed\n");
+					printk(KERN_ERR "TOPAZ: upload FW to HW failed\n");
 					return -IGD_ERROR_INVAL;
 				}
 				topaz_priv->topaz_cur_codec = codec;
@@ -271,28 +286,55 @@ int process_encode_mtx_messages(igd_context_t *context,
 					*(command + cur_cmd_size - 1));
 				/* strip the QP parameter (it's software arg) */
 				cur_cmd_header->size--;
-			default:
+			case MTX_CMDID_DO_HEADER:
+			case MTX_CMDID_ENCODE_SLICE:
+			case MTX_CMDID_END_PIC:
+			case MTX_CMDID_SYNC:
+			case MTX_CMDID_ENCODE_ONE_ROW:
+			case MTX_CMDID_FLUSH:
+
 				cur_cmd_header->seq = 0x7fff &
 					topaz_priv->topaz_cmd_seq++;
 				EMGD_DEBUG("TOPAZ: %ld: size(%ld), seq (0x%04x)\n",
 					cur_cmd_id, cur_cmd_size, cur_cmd_header->seq);
 				ret = mtx_send_tnc(context, command);
 				if (ret) {
-					EMGD_ERROR("TOPAZ: error -- ret(%d)\n", ret);
+					printk(KERN_ERR "TOPAZ: error -- ret(%d)\n", ret);
 					return -IGD_ERROR_INVAL;
 				}
 				break;
+			default:
+				printk(KERN_ERR "TOPAZ: Invalid Command\n");
+				return -IGD_ERROR_INVAL;
 			}
-        /* save frame skip flag for query */
-        /*topaz_priv->topaz_frame_skip = 0; CCB_CTRL_FRAMESKIP(context);*/
-        /* current command done */
+
+		/* current command done */
 		command += cur_cmd_size;
-		cmd_size -= cur_cmd_size;
+		cmd_size += cur_cmd_size;
+
+		/* Verify that the incoming commands are of reasonable size */
+		if((cmd_size >= MAX_TOPAZ_CMD_SIZE)) {
+			printk(KERN_ERR "TOPAZ: Invalid Command Size\n");
+			return -IGD_ERROR_INVAL;
+		}
 
 		/* Get next command */
 		cur_cmd_header = (struct topaz_cmd_header *) command;
+
+		if(!cur_cmd_header) {
+			printk(KERN_ERR "TOPAZ: Invalid Command\n");
+			return -IGD_ERROR_INVAL;
+		}
+
 		cur_cmd_size = cur_cmd_header->size;
 		cur_cmd_id = cur_cmd_header->id;
+
+		/* Verify the incoming current command size */
+		if((cur_cmd_size == 0) || (cur_cmd_size > MAX_CURRENT_TOPAZ_CMD_SIZE)) {
+			printk(KERN_ERR "TOPAZ: Invalid Command Size\n");
+			return -IGD_ERROR_INVAL;
+		}
+
 	}
 	topaz_sync_tnc(context); 
 
diff --git a/drivers/gpu/drm/emgd/emgd/video/topaz/topaz_init.c b/drivers/gpu/drm/emgd/emgd/video/topaz/topaz_init.c
index 4401b69..a89ceb2 100644
--- a/drivers/gpu/drm/emgd/emgd/video/topaz/topaz_init.c
+++ b/drivers/gpu/drm/emgd/emgd/video/topaz/topaz_init.c
@@ -54,7 +54,19 @@
 
 #include <drm/drm.h>
 #include <drm_emgd_private.h>
-
+#include "services_headers.h"
+
+#include "pvr_bridge_km.h"
+#include "msvdx_pvr.h"
+#include <linux/version.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15))
+#include <linux/mutex.h>
+#else
+#include <asm/semaphore.h>
+#endif
+static PVRSRV_KERNEL_MEM_INFO   *g_wb_mem_info = NULL;
+static int g_topaz_initialized = 0;
+static IMG_VOID *g_pMutex = IMG_NULL;
 /* DDK specific DRM device */
 extern struct drm_device *gpDrmDevice;
 
@@ -89,8 +101,8 @@ void get_mtx_control_from_dash(igd_context_t *context);
 
 void release_mtx_control_from_dash(igd_context_t *context);
 
-/* According to UMG code this define is important */
 #define RAM_SIZE (1024 * 24)
+#define ENC_FW_SIZE (512 * 1024)
 
 /* register default values */
 static unsigned long topaz_def_regs[184][3] = {
@@ -392,8 +404,63 @@ static enc_fw_info_t firmware[10] = {
 	}
 };
 
+IMG_VOID * HostCreateMutex(IMG_VOID)
+{
+	struct semaphore *psSem;
+
+	psSem = kmalloc(sizeof(*psSem), GFP_KERNEL);
+	if (psSem)
+	{
+		sema_init(psSem, 1);
+	}
+
+	return psSem;
+}
+
+IMG_VOID HostAquireMutex(IMG_VOID * pvMutex)
+{
+	BUG_ON(in_interrupt());
+
+#if defined(PVR_DEBUG_DBGDRV_DETECT_HOST_MUTEX_COLLISIONS)
+	if (down_trylock((struct semaphore *)pvMutex))
+	{
+		printk(KERN_INFO "HostAquireMutex: Waiting for mutex\n");
+		down((struct semaphore *)pvMutex);
+	}
+#else
+	down((struct semaphore *)pvMutex);
+#endif
+}
+
+IMG_VOID HostReleaseMutex(IMG_VOID * pvMutex)
+{
+	up((struct semaphore *)pvMutex);
+}
+
+IMG_VOID HostDestroyMutex(IMG_VOID * pvMutex)
+{
+	if (pvMutex)
+	{
+		kfree(pvMutex);
+	}
+}
+int topaz_shutdown_tnc(igd_context_t *context)
+{
+	EMGD_TRACE_ENTER;
+	
+	
+	g_topaz_initialized = 0;
+	g_wb_mem_info = NULL;
 
-int topaz_init_tnc(unsigned long wb_offset, void *wb_addr, void *firmware_addr)
+	HostDestroyMutex(g_pMutex);
+	g_pMutex = IMG_NULL;
+	
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+int topaz_init_tnc (unsigned long wb_offset,
+					void* mem_handle_writeback,
+		            void *mem_handle_enc_fw)
 {
 	drm_emgd_priv_t *priv;
 	igd_context_t *context;
@@ -404,11 +471,60 @@ int topaz_init_tnc(unsigned long wb_offset, void *wb_addr, void *firmware_addr)
 	tnc_topaz_priv_t *topaz_priv;
 	unsigned long *km_firm_addr = NULL;
 	unsigned long *firm_offset_values = NULL;
+	PVRSRV_ERROR err;
+	PVRSRV_PER_PROCESS_DATA *ps_data = NULL;
+	IMG_UINT32 pid = 0;
+	PVRSRV_KERNEL_MEM_INFO *mem_info_fw = NULL;
+	PVRSRV_KERNEL_MEM_INFO *mem_info_wb = NULL;
+	struct msvdx_pvr_info   *pvr;
 
 	priv = gpDrmDevice->dev_private;
 	context = priv->context;
 	mmio = context->device_context.virt_mmadr;
+#if 0
+	if(!mem_handle_writeback || !mem_handle_enc_fw) {
+		return -EINVAL;
+	}
+#else
+	if (!mem_handle_enc_fw) {
+		return -EINVAL;
+	}
+#endif
+	pid = OSGetCurrentProcessIDKM();
+	ps_data = PVRSRVPerProcessData(pid);
+	if (!ps_data) {
+		printk(KERN_ERR "TOPAZ: Cannot get process data information");
+		return -1;
+	}
+
+	err = PVRSRVLookupHandle(ps_data->psHandleBase, (void **)&mem_info_fw,
+			(IMG_HANDLE)mem_handle_enc_fw, PVRSRV_HANDLE_TYPE_MEM_INFO);
 
+	if(err != PVRSRV_OK) {
+		printk(KERN_ERR "TOPAZ: Cannot get fw memory context from process data");
+		return -1;
+	}
+#if 0
+	err = PVRSRVLookupHandle(ps_data->psHandleBase, (void **)&mem_info_wb,
+			(IMG_HANDLE)mem_handle_writeback, PVRSRV_HANDLE_TYPE_MEM_INFO);
+
+	if(err != PVRSRV_OK) {
+		printk(KERN_ERR "TOPAZ: Cannot get wb memory context from process data");
+		return -1;
+	}
+#endif
+
+	if(!mem_info_fw || mem_info_fw->ui32AllocSize < ENC_FW_SIZE) {
+		printk(KERN_ERR "TOPAZ: invalid fw memory context from process data");
+		return -1;
+	}
+
+#if 0
+	if(!mem_info_wb || mem_info_wb->ui32AllocSize < (4 * 1024)) {
+		printk(KERN_ERR "TOPAZ: Invalid wb memory context from process data");
+		return -1;
+	}
+#endif
 	/* Only support Atom E6xx */
 	if ((PCI_DEVICE_ID_VGA_TNC != context->device_context.did)||
 	   (context->device_context.bid == PCI_DEVICE_ID_BRIDGE_TNC_ULP)) {
@@ -418,36 +534,83 @@ int topaz_init_tnc(unsigned long wb_offset, void *wb_addr, void *firmware_addr)
 	platform = (platform_context_tnc_t *)context->platform_context;
 	topaz_priv = &platform->tpz_private_data;
 
+	if (g_topaz_initialized != 1)
+	{
+		spin_lock_init(&platform->topaz_init_tnc);		
+
+		spin_lock(&platform->topaz_init_tnc);
+		
+		size = WRITEBACK_MEM_SIZE;
+		GMM_SET_DEBUG_NAME("TOPAZ Writeback Memory");
+		
+		pvr = platform->msvdx_pvr;
+		if (!g_wb_mem_info) {
+			err = PVRSRVAllocDeviceMemKM(pvr->sgx_cookie, pvr->per_proc,
+				pvr->heap_info[pvr->mapping_heap_index].hDevMemHeap,
+				PVRSRV_MEM_READ | PVRSRV_MEM_WRITE,
+				size, 0, &g_wb_mem_info, "TOPAZ writeback");
+				
+			if (!g_wb_mem_info) {
+				printk(KERN_ERR "[EMGD] TOPAZ: Failed to allocate %u "
+					"bytes from SGX heap\n",
+					(unsigned int)size);
+				
+				spin_unlock(&platform->topaz_init_tnc);
+				return -ENOMEM;
+			}
+		}
+
+		platform->topaz_busy = 0;
+		
+		spin_unlock(&platform->topaz_init_tnc);
+	}
+	
+	spin_lock(&platform->topaz_init_tnc);
+	
 	topaz_priv->topaz_busy = 0;
 	topaz_priv->topaz_cmd_seq = 0;
 	topaz_priv->topaz_fw_loaded = 0;
 	topaz_priv->topaz_cur_codec = 0;
 	topaz_priv->cur_mtx_data_size = 0;
 
-	size = WRITEBACK_MEM_SIZE;
-
-	GMM_SET_DEBUG_NAME("TOPAZ Writeback Memory");
-
-	topaz_priv->topaz_wb_offset = wb_offset;
-	topaz_priv->topaz_ccb_wb = (unsigned char *)wb_addr;
-
-	/* Sync location will be half of the writeback memory. */
-	topaz_priv->topaz_sync_addr = (unsigned long *)(topaz_priv->topaz_ccb_wb + 2048);
-	topaz_priv->topaz_sync_offset = topaz_priv->topaz_wb_offset + 2048;
 	/*
 	printk(KERN_INFO "Topaz write back memory = %p", topaz_priv->topaz_ccb_wb);
 	printk(KERN_INFO "Topaz write back offset = %lx", topaz_priv->topaz_wb_offset);
 	printk(KERN_INFO "Topaz write back sync memory = %p", topaz_priv->topaz_sync_addr);
 	printk(KERN_INFO "Topaz write back sync offset = %lx", topaz_priv->topaz_sync_offset);
-	*/	
+	*/
+	
+	if (g_topaz_initialized == 1)
+	{
+		spin_unlock(&platform->topaz_init_tnc);
+		return 0;
+	}	
+
+	topaz_priv->topaz_wb_offset = g_wb_mem_info->sDevVAddr.uiAddr; //wb_offset;
+	topaz_priv->topaz_ccb_wb = g_wb_mem_info->pvLinAddrKM; //(unsigned char *)mem_info_wb->pvLinAddrKM;
+
+	/* Sync location will be half of the writeback memory. */
+	topaz_priv->topaz_sync_addr = (unsigned long *)(topaz_priv->topaz_ccb_wb + 2048);
+	topaz_priv->topaz_sync_offset = topaz_priv->topaz_wb_offset + 2048;
 	
 	*(topaz_priv->topaz_sync_addr) = 0; /*reset sync seq */
 	topaz_priv->topaz_sync_id = 0; /*reset sync id */
 
+	g_topaz_initialized = 1;
+	
+	spin_unlock(&platform->topaz_init_tnc);
+
+	if ((g_pMutex = HostCreateMutex()) == IMG_NULL)
+	{
+		return 0;
+	}
+		
+	topaz_priv->selected_codec = -1;
+	
 	/* firmware part */
 	/* allocate memory for all firmwares */
 	/* to check, is allocate or not */
-	if ( !firmware[1].text && firmware_addr) {
+	if ( !firmware[1].text && mem_info_fw->pvLinAddrKM) {
 		base_firmware_address = kmalloc( 512 * 1024, GFP_KERNEL);
 		if ( NULL == base_firmware_address){
 			printk (KERN_INFO "Kernel memory allocation failed\n");
@@ -457,7 +620,7 @@ int topaz_init_tnc(unsigned long wb_offset, void *wb_addr, void *firmware_addr)
 		/* copy all firmware to kernel memory */
 		km_firm_addr = (unsigned long *) base_firmware_address;
 		firm_offset_values = km_firm_addr;
-		memcpy(km_firm_addr, firmware_addr, 512*1024);
+		memcpy(km_firm_addr, mem_info_fw->pvLinAddrKM, 512*1024);
 		/* printk(KERN_INFO "Topaz km_firm_addr = %p", km_firm_addr); */
 		/* to set firmwares */
 		/* NB! all offsets in bytes */
@@ -490,6 +653,12 @@ int topaz_setup_fw(igd_context_t *context, enum tnc_topaz_encode_fw codec)
 	platform = (platform_context_tnc_t *)context->platform_context;
 	topaz_priv = &platform->tpz_private_data;
 
+	// do no reload firmware
+	if (codec == topaz_priv->selected_codec)
+	{
+		return 0;
+	}
+	topaz_priv->selected_codec = codec;	
 	EMGD_WRITE32(0x00000000, mmio + TNC_TOPAZ_MMU_CONTROL0);
 
 	/* Reset MVEA
@@ -513,6 +682,9 @@ int topaz_setup_fw(igd_context_t *context, enum tnc_topaz_encode_fw codec)
 
 	/* topaz_upload_fw */
 	/* Point to request firmware */
+	if((codec < 1) || (codec > 9)) {
+		return 1;
+	}
 	curr_fw = &firmware[codec];
 
 	upload_firmware(context, curr_fw);
@@ -894,32 +1066,68 @@ void release_mtx_control_from_dash(igd_context_t *context)
 	EMGD_WRITE32(reg, mmio + TNC_TOPAZ_MTX_DEBUG);
 }
 
-int process_video_encode_tnc(igd_context_t *context, unsigned long offset, void *virt_addr, unsigned long *fence_id)
+int process_video_encode_tnc(igd_context_t *context, unsigned long offset,
+		void *mem_handle, unsigned long *fence_id)
 {
     unsigned long *mtx_buf;
 	unsigned long size=0;
 	int ret = 0;
 	platform_context_plb_t *platform;
 	tnc_topaz_priv_t *topaz_priv;
+	PVRSRV_ERROR err;
+	PVRSRV_PER_PROCESS_DATA *ps_data = NULL;
+	IMG_UINT32 pid = 0;
+	PVRSRV_KERNEL_MEM_INFO *mem_info_mtx_buf = NULL;
 
 	EMGD_TRACE_ENTER;
 
+	if(!mem_handle || !fence_id) {
+		return -EINVAL;
+	}
+
+	pid = OSGetCurrentProcessIDKM();
+	ps_data = PVRSRVPerProcessData(pid);
+	if (!ps_data) {
+		printk(KERN_ERR "TOPAZ: Cannot get process data information");
+		return -1;
+	}
+
+	err = PVRSRVLookupHandle(ps_data->psHandleBase, (void **)&mem_info_mtx_buf,
+			(IMG_HANDLE)mem_handle, PVRSRV_HANDLE_TYPE_MEM_INFO);
+
+	if(err != PVRSRV_OK) {
+		printk(KERN_ERR "TOPAZ: Cannot get mtx buf memory context from process data");
+		return -1;
+	}
+
+	if(!mem_info_mtx_buf ||  mem_info_mtx_buf->ui32AllocSize < 0x3000) {
+		printk(KERN_ERR "TOPAZ: invalid mtx buf memory context from process data");
+		return -1;
+	}
+
 	platform = (platform_context_plb_t *)context->platform_context;
 	topaz_priv = &platform->tpz_private_data;
-	mtx_buf = (unsigned long *) virt_addr;
+	HostAquireMutex(g_pMutex);
+	mtx_buf = (unsigned long *) mem_info_mtx_buf->pvLinAddrKM;
 
 	EMGD_DEBUG("process_video_encode_tnc where buf=%p, offset=%lx\n",
 		mtx_buf, offset);
 
+	if (!platform->topaz_busy)
+	{
 	platform->topaz_busy = 1;
 	ret = process_encode_mtx_messages(context, mtx_buf, size);
 	if (ret){
 		printk(KERN_INFO "Invalid topaz encode cmd");
-	ret = -EINVAL;
-        }
+		ret = -EINVAL;
+    }
+		platform->topaz_busy = 0;
+	}
+
 
 	*fence_id = topaz_priv->topaz_sync_id;
-	platform->topaz_busy = 0;
+
+	HostReleaseMutex(g_pMutex);
 	return ret;
 }
 
@@ -961,6 +1169,10 @@ int topaz_get_frame_skip(igd_context_t *context, unsigned long *frame_skip)
 	tnc_topaz_priv_t *topaz_priv;
 	platform_context_tnc_t *platform;
 
+	if(!frame_skip) {
+		return -EINVAL;
+	}
+
 	platform = (platform_context_tnc_t *)context->platform_context;
 	topaz_priv = &platform->tpz_private_data;
 	*frame_skip = topaz_priv->topaz_frame_skip;
@@ -975,6 +1187,10 @@ int topaz_get_fence_id(igd_context_t *context, unsigned long *fence_id)
 	unsigned long *sync_p;
 	platform_context_tnc_t *platform;
 
+	if(!fence_id) {
+		return -EINVAL;
+	}
+
 	platform = (platform_context_tnc_t *)context->platform_context;
 	topaz_priv = &platform->tpz_private_data;
 	sync_p = (unsigned long *)topaz_priv->topaz_sync_addr;
diff --git a/drivers/gpu/drm/emgd/include/emgd_drm.h b/drivers/gpu/drm/emgd/include/emgd_drm.h
index c2b871a..a1d946d 100644
--- a/drivers/gpu/drm/emgd/include/emgd_drm.h
+++ b/drivers/gpu/drm/emgd/include/emgd_drm.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: emgd_drm.h
- * $Revision: 1.63 $
+ * $Revision: 1.64 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -31,6 +31,7 @@
 #ifndef _EMGD_DRM_H_
 #define _EMGD_DRM_H_
 
+#include <linux/version.h>
 #include <drm/drm.h>
 #include <igd.h>
 #include <igd_appcontext.h>
@@ -365,7 +366,7 @@ typedef struct _kdrm_video_cmd_buf {
 	int rtn;
 	int engine;
 	unsigned long offset;
-	void *kernel_virt_addr;
+	void *mem_handle;
 	unsigned long fence_id;
 } emgd_drm_video_cmd_buf_t;
 
@@ -385,15 +386,16 @@ typedef struct _kdrm_init_video {
 		struct {
 			unsigned long base0;
 			unsigned long base1;
-			void *fw_priv;
+			void *mem_handle_fw;
 			unsigned long fw_size;
 		};
 		struct {
 			unsigned long wb_offset;
-			void *wb_addr;
-			void *firm_addr;
+			void *mem_handle_writeback;
+			void *mem_handle_enc_fw;
 		};
 		unsigned long status;
+		unsigned long context_id;
 	};
 } emgd_drm_init_video_t;
 
@@ -664,8 +666,15 @@ typedef struct _kdrm_bc_ts {
 	unsigned long pixel_format;
 	unsigned long phyaddr;
 	unsigned long virtaddr;
+	unsigned int mapped;
 } emgd_drm_bc_ts_t;
 
+typedef struct _kdrm_unlock_planes {
+	int rtn;					/* (UP) - return value of HAL procedure */
+	igd_display_h display_handle; /* (DOWN) - an "opaque handle" */
+	unsigned int screen_num; /*primary=0, secondary=1 */
+} emgd_drm_unlock_planes_t;
+
 /*
  * This is where all the IOCTL's used by the egd DRM interface are
  * defined.  This information is shared between the user space code and
@@ -751,6 +760,8 @@ typedef struct _kdrm_bc_ts {
 #define DRM_IGD_GET_CHIPSET_INFO    0x30
 #define DRM_IGD_GET_DISPLAY_INFO    0x38
 #define DRM_IGD_PREINIT_MMU         0x39
+#define  DRM_IGD_UNLOCK_PLANES       0x47
+
 /* For Buffer Class of Texture Stream */
 #define DRM_IGD_BC_TS_INIT			0x40
 #define DRM_IGD_BC_TS_UNINIT		0x41
@@ -759,6 +770,15 @@ typedef struct _kdrm_bc_ts {
 #define DRM_IGD_BC_TS_SET_BUFFER_INFO	0x44
 #define DRM_IGD_BC_TS_GET_BUFFERS_COUNT	0x45
 #define DRM_IGD_BC_TS_GET_BUFFER_INDEX	0x46
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0)
+#define DRMFB_PITCH pitches[0]
+#define DRMMODE_HANDLE handles[0]
+#define DRM_MODE_FB_CMD_TYPE drm_mode_fb_cmd2
+#else
+#define DRMFB_PITCH pitch
+#define DRMMODE_HANDLE handle
+#define DRM_MODE_FB_CMD_TYPE drm_mode_fb_cmd
+#endif
 
 /*
  * egd IOCTLs.
@@ -896,6 +916,8 @@ typedef struct _kdrm_bc_ts {
 		emgd_drm_video_flush_tlb_t)
 #define DRM_IOCTL_IGD_PREINIT_MMU  DRM_IOR(DRM_IGD_PREINIT_MMU + BASE,\
 		emgd_drm_preinit_mmu_t)
+#define DRM_IOCTL_IGD_UNLOCK_PLANES  DRM_IOR(DRM_IGD_UNLOCK_PLANES + BASE,\
+		emgd_drm_unlock_planes_t)
 #define DRM_IOCTL_IGD_GET_DISPLAY_INFO  DRM_IOR(DRM_IGD_GET_DISPLAY_INFO + BASE,\
 		emgd_drm_get_display_info_t)
 /* For Buffer Class of Texture Stream */
diff --git a/drivers/gpu/drm/emgd/include/igd.h b/drivers/gpu/drm/emgd/include/igd.h
index f153eaf..701bab8 100644
--- a/drivers/gpu/drm/emgd/include/igd.h
+++ b/drivers/gpu/drm/emgd/include/igd.h
@@ -1442,6 +1442,9 @@ typedef struct _igd_dispatch {
 	int (*query_ovl)(igd_display_h display_h,
 		unsigned int flags);
 
+	/* User mode only query_ovl */
+	int (*query_ovl2)(igd_display_h display_h,
+		unsigned int flags);
 	/*!
 	 * Query the overlay for the maximum width and height given the input
 	 * src video pixel format.
@@ -1620,6 +1623,8 @@ typedef struct _igd_dispatch {
 	 * Get MSVDX status.
 	 */ 
 	int (*msvdx_status)(igd_driver_h driver_handle, unsigned long *queue_status, unsigned long *mtx_msg_status);
+	/* show_desktop calls this function so, the planes now show the desktop instead of the splas screen */
+	int (*unlock_planes)(igd_display_h display_handle , unsigned int scrn_num);
 } igd_dispatch_t;
 
 #endif
diff --git a/drivers/gpu/drm/emgd/include/igd_gmm.h b/drivers/gpu/drm/emgd/include/igd_gmm.h
index e28a809..7bd1a89 100644
--- a/drivers/gpu/drm/emgd/include/igd_gmm.h
+++ b/drivers/gpu/drm/emgd/include/igd_gmm.h
@@ -106,6 +106,7 @@
 #define IGD_SURFACE_PHYS_PTR  0x00010000
 #define IGD_SURFACE_CI		0x00020000
 #define IGD_SURFACE_CI_V4L2_MAP	0x00040000		/*will be set when map_method=0 without WA*/
+#define IGD_SURFACE_CI_TEXTSTREAM		0x00080000
 /*
  * Mipmap flags are only valid on mipmap surfaces.
  * Planes flags are only valid on volume surfaces.
@@ -249,7 +250,13 @@ typedef struct _igd_memstat {
 } igd_memstat_t;
 
 
-
+struct emgd_ci_meminfo_t{
+	unsigned long v4l2_offset;
+	unsigned long virt;
+	unsigned long size;
+	unsigned int used;
+	unsigned long vbufqueue_handle;
+};
 /*!
  * @name GMM Alloc Cached Flags
  * @anchor gmm_alloc_cached_flags
diff --git a/drivers/gpu/drm/emgd/include/igd_mode.h b/drivers/gpu/drm/emgd/include/igd_mode.h
index a3e6da2..3eb9c11 100644
--- a/drivers/gpu/drm/emgd/include/igd_mode.h
+++ b/drivers/gpu/drm/emgd/include/igd_mode.h
@@ -564,10 +564,11 @@ typedef struct _igd_framebuffer_info {
 	unsigned long visible_offset;
 	
 	/* this is the offset that will be restored when swithcing back to dih mode from
-	 * dihclone mode
+	 * dihclone mode and also when unlock_plane is called.
 	 */
 
 	unsigned long saved_offset;
+	unsigned int lock;
 	/*!
 	 * @brief pixel format of the fb. See @ref pixel_formats
 	 *
diff --git a/drivers/gpu/drm/emgd/include/igd_ovl.h b/drivers/gpu/drm/emgd/include/igd_ovl.h
index 06e826e..67ffa85 100644
--- a/drivers/gpu/drm/emgd/include/igd_ovl.h
+++ b/drivers/gpu/drm/emgd/include/igd_ovl.h
@@ -213,6 +213,7 @@ typedef struct _igd_ovl_video_quality_info{
 	unsigned short		contrast;
 	unsigned short		brightness;
 	unsigned short		saturation;
+	unsigned short		hue;
 } igd_ovl_video_quality_info_t;
 
 
@@ -290,7 +291,7 @@ typedef struct _video_surface_data {
 #define OVL_MAX_HW    2  /* Maximum number of overlays */
 
 /* Define the maximum number of blend surfaces which can be used */
-#define MAX_BLEND_SURF 2
+#define MAX_BLEND_SURF 3
 
 /* User mode overlay context */
 typedef struct _ovl_um_context {
diff --git a/drivers/gpu/drm/emgd/include/igd_render.h b/drivers/gpu/drm/emgd/include/igd_render.h
index c492918..1d89ed4 100644
--- a/drivers/gpu/drm/emgd/include/igd_render.h
+++ b/drivers/gpu/drm/emgd/include/igd_render.h
@@ -112,6 +112,47 @@ typedef struct _igd_rect {
 	unsigned int y2;
 } igd_rect_t, *pigd_rect_t;
 
+/*
+ * Direct Display context for video-to-graphics bridge.
+ * (Added here for compatibility between User & Kernel space)
+ * Note: This structure must match EMGDHmiVideoContext.
+ */
+typedef struct _igd_dd_context {
+	unsigned int    usage;		/* requested display plane */
+	unsigned int    screen;		/* screen index for video output */
+	unsigned int    screen_w;	/* width of display screen */
+	unsigned int    screen_h;	/* height of display screen */
+	unsigned int    video_w;	/* width of IOH video frame */
+	unsigned int    video_h;	/* height of IOH video frame */
+	unsigned int	video_pitch; /* pitch of IOH video frame */
+	igd_rect_t      src;		/* video input source rectangle */
+	igd_rect_t      dest;		/* display output dest rectangle */
+} igd_dd_context_t, *pigd_dd_context_t;
+
+/* planes where reconfiguration and Z-ordering is supported */
+typedef enum _igd_plane_usage {
+	IGD_PLANE_NONE,
+	IGD_PLANE_HMI,
+	IGD_PLANE_X11,
+	IGD_PLANE_OVERLAY_VIDEO,
+	IGD_PLANE_OVERLAY_POPUP,
+	IGD_PLANE_SPRITE_VIDEO,
+	IGD_PLANE_SPRITE_POPUP,
+} igd_plane_usage_t;
+
+typedef struct _igd_buffer_config {
+	igd_plane_usage_t plane;	/* usage/ownership of this plane */
+	unsigned long     offset;	/* surface's GTT offset */
+	int               stride;	/* surface's stride (in bytes) */
+	igd_rect_t        src;		/* input source rectangle */
+	igd_rect_t        dest;		/* display destination rectangle */
+	int               extended_screen;
+	int               alpha_ena;	/* enables/disables constant alpha */
+	int               alpha_val;	/* constant alpha opacity value */
+	int               ckey_ena;	/* enables/disables color keying */
+	int               ckey_val;	/* source color key value */
+} igd_buffer_config_t, *pigd_buffer_config_t;
+
 typedef struct _igd_surface {
 	unsigned long offset;
 	unsigned int pitch;
diff --git a/drivers/gpu/drm/emgd/include/igd_version.h b/drivers/gpu/drm/emgd/include/igd_version.h
index a0482a5..0b192a9 100644
--- a/drivers/gpu/drm/emgd/include/igd_version.h
+++ b/drivers/gpu/drm/emgd/include/igd_version.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: igd_version.h
- * $Revision: 1.217 $
+ * $Revision: 1.237 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -34,8 +34,8 @@
 #define _IGD_VERSION_H
 
 #define IGD_MAJOR_NUM  1
-#define IGD_MINOR_NUM  14
-#define IGD_BUILD_NUM  2443
+#define IGD_MINOR_NUM  18
+#define IGD_BUILD_NUM  3398
 
 #define IGD_PCF_VERSION   0x00000400
 #endif
diff --git a/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.c b/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.c
index b6fc6d6..80fac89 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.c
@@ -189,10 +189,16 @@ GetBCBufferAddr (IMG_HANDLE hDevice,
     if (NULL == hDevice || NULL == hBuffer){
         return (PVRSRV_ERROR_INVALID_PARAMS);
     }
+        psBuffer = (BC_BUFFER *)hBuffer;
+        
 	if (IMG_NULL != pbMapped) {
-		*pbMapped = IMG_TRUE;
+
+		if(psBuffer->mapped)
+			*pbMapped = IMG_TRUE;
+		else
+			*pbMapped = IMG_FALSE;
 	}	
-    psBuffer = (BC_BUFFER *)hBuffer;
+
     
 	EMGD_DEBUG("Buffer 0x%lx", (IMG_UINT32)psBuffer);
 	if (NULL != ppsSysAddr) {
diff --git a/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.h b/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.h
index 7728631..9fad016 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.h
+++ b/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.h
@@ -1,6 +1,6 @@
 /**********************************************************************
  *
- * Copyright 2010 Intel Corporation
+ * Copyright  2010 Intel Corporation
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -99,6 +99,7 @@ extern "C"
         IMG_UINT32 sBufferHandle;
         IMG_BOOL is_conti_addr;
 		IMG_UINT32 tag; /* Buffer Tag. -- Surface ID*/
+		IMG_BOOL mapped;
     } BC_BUFFER;
 
     typedef struct BC_DEVINFO_TAG
diff --git a/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc_linux.c b/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc_linux.c
index 983b768..65a5162 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc_linux.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc_linux.c
@@ -44,7 +44,7 @@
 #include "io.h"
 #include "pvrmodule.h"
 #include "emgd_drm.h"
-
+#include "igd_gmm.h"
 #include "emgd_bc.h"
 #if 0
 #define DEVNAME    "bc_video"
@@ -57,6 +57,9 @@
 #define BC_PIX_FMT_UYVY     BC_FOURCC('U', 'Y', 'V', 'Y')    /*YUV 4:2:2 */
 #define BC_PIX_FMT_YUYV     BC_FOURCC('Y', 'U', 'Y', 'V')    /*YUV 4:2:2 */
 #define BC_PIX_FMT_RGB565   BC_FOURCC('R', 'G', 'B', 'P')    /*RGB 5:6:5 */
+#define BC_PIX_FMT_ARGB   BC_FOURCC('A','R', 'G', 'B')    /*ARGB*/
+#define BC_PIX_FMT_xRGB   BC_FOURCC('x','R', 'G', 'B')    /*xRGB*/
+#define BC_PIX_FMT_RGB4	BC_FOURCC('R', 'G', 'B', '4') /*RGB4*/
 #if 0
 #if defined(BCE_USE_SET_MEMORY)
 #undef BCE_USE_SET_MEMORY
@@ -340,6 +343,9 @@ BCE_ERROR BCAllocContigMemory (unsigned long ulSize,
     int iError;
 
     pvLinAddr = kmalloc(ulAlignedSize, GFP_KERNEL);
+    if(!pvLinAddr) {
+        return (BCE_ERROR_OUT_OF_MEMORY);
+    }
     BUG_ON (((unsigned long) pvLinAddr) & ~PAGE_MASK);
 
     iError = set_memory_wc((unsigned long) pvLinAddr, iPages);
@@ -426,7 +432,7 @@ emgd_error_t BCGetLibFuncAddr (BCE_HANDLE unref__ hExtDrv, char *szFunctionName,
 }
 
 int BC_CreateBuffers(BC_DEVINFO *psDevInfo, bc_buf_params_t *p, IMG_BOOL is_conti_addr) {
-    IMG_UINT32 i = 0;
+    IMG_UINT32 i = 0, j = 0;
 	IMG_UINT32 stride = 0;
 	IMG_UINT32 size = 0;
     PVRSRV_PIXEL_FORMAT pixel_fmt = 0;
@@ -438,7 +444,15 @@ int BC_CreateBuffers(BC_DEVINFO *psDevInfo, bc_buf_params_t *p, IMG_BOOL is_cont
   		return -1;
   	}    
 
-    if (p->width <= 1 || p->height <= 1) {
+	if (p->count > BUFCLASS_BUFFER_MAX) {
+  		return -1;
+  	}
+
+	if (p->width <= 1 || p->height <= 1 || p->stride <=1 ) {
+        return -1;
+    }
+
+	if (p->width > 2048 || p->height > 1536 || p->stride >2048*4) {
         return -1;
     }
 
@@ -456,6 +470,13 @@ int BC_CreateBuffers(BC_DEVINFO *psDevInfo, bc_buf_params_t *p, IMG_BOOL is_cont
         case BC_PIX_FMT_YUYV:
             pixel_fmt = PVRSRV_PIXEL_FORMAT_FOURCC_ORG_YUYV;
             break;
+	case BC_PIX_FMT_ARGB:
+	case BC_PIX_FMT_RGB4:
+            pixel_fmt = PVRSRV_PIXEL_FORMAT_ARGB8888;
+            break;
+ 	case BC_PIX_FMT_xRGB:
+            pixel_fmt = PVRSRV_PIXEL_FORMAT_XRGB8888;
+            break;
         default:
             return -1;
             break;
@@ -475,7 +496,8 @@ int BC_CreateBuffers(BC_DEVINFO *psDevInfo, bc_buf_params_t *p, IMG_BOOL is_cont
 			return -1;
 		}
 	} else {
-		if ((psDevInfo->sBufferInfo.ui32BufferCount + p->count) >= BUFCLASS_BUFFER_MAX) {
+		
+		if ((psDevInfo->sBufferInfo.ui32BufferCount + p->count) > BUFCLASS_BUFFER_MAX) {
 			EMGD_ERROR("No avaiable Buffers");
 			return -1;
 		}
@@ -519,8 +541,14 @@ int BC_CreateBuffers(BC_DEVINFO *psDevInfo, bc_buf_params_t *p, IMG_BOOL is_cont
 		if (is_conti_addr){
         	bufnode->psSysAddr = (IMG_SYS_PHYADDR *)BCAllocKernelMem (sizeof(IMG_SYS_PHYADDR));
             if (NULL == bufnode->psSysAddr) {
-            	return EMGD_ERROR_OUT_OF_MEMORY;
-            }
+				/* Free the previously successfully allocated memeory */
+				for(j=0;j<i;j++) {
+					bufnode = 
+						&(psDevInfo->psSystemBuffer[psDevInfo->sBufferInfo.ui32BufferCount + j]);
+					bc_ts_free_bcbuffer(bufnode);	
+				}
+				return EMGD_ERROR_OUT_OF_MEMORY;
+			}
             memset(bufnode->psSysAddr, 0, sizeof(IMG_SYS_PHYADDR));
         } else {
             return EMGD_ERROR_INVALID_PARAMS;
@@ -556,10 +584,16 @@ int BC_DestroyBuffers(void *psDevInfo) {
 
 	DevInfo = (BC_DEVINFO *)psDevInfo;
     EMGD_DEBUG("To Free %lu buffers", DevInfo->sBufferInfo.ui32BufferCount);
-   
+
+	if (DevInfo->sBufferInfo.ui32BufferCount > BUFCLASS_BUFFER_MAX) {
+		EMGD_ERROR("Wrong number of buffers");
+	}
+
 	for (i = 0; i < DevInfo->sBufferInfo.ui32BufferCount; i++) {
-		bufnode = &(DevInfo->psSystemBuffer[i]);
-		bc_ts_free_bcbuffer(bufnode);
+		if(i < BUFCLASS_BUFFER_MAX) {
+			bufnode = &(DevInfo->psSystemBuffer[i]);
+			bc_ts_free_bcbuffer(bufnode);
+		}
 	}
 	BCFreeKernelMem(DevInfo->psSystemBuffer);
 	DevInfo->psSystemBuffer = NULL;
@@ -627,8 +661,8 @@ static __inline int emgd_bc_ts_bridge_init(struct drm_device *drv, void* arg, st
     	}
  	}
    	  
- 	if (BUFCLASS_DEVICE_MAX_ID == i) {
-    	EMGD_ERROR("Do you really need to run more than 5 video simulateously.");
+ 	if (BUFCLASS_DEVICE_MAX_ID == i) { 
+    	EMGD_ERROR("Do you really need to run more than 6 video simulateously.");
  	}
  	
 	EMGD_TRACE_EXIT;
@@ -651,6 +685,10 @@ static __inline int emgd_bc_ts_bridge_uninit(struct drm_device *drv, void* arg,
 	}
 
 	psDevInfo = (BC_DEVINFO *)GetAnchorPtr(psBridge->dev_id);
+	if (NULL == psDevInfo) {
+		EMGD_ERROR("System Error");
+		return err;
+	}
 
 	/* To disable buffer class device*/
 	emgd_bc_ts_set_state(psDevInfo, 0);	
@@ -755,7 +793,7 @@ static __inline int emgd_bc_ts_bridge_set_buffer_info(struct drm_device *drv, vo
 	emgd_drm_bc_ts_t *psBridge = (emgd_drm_bc_ts_t *) arg;
 	BC_DEVINFO *devinfo = IMG_NULL;	
 	BC_BUFFER *bcBuf = NULL;
-	
+	unsigned long virt=0;
 	EMGD_TRACE_ENTER;
 	
 	if (NULL == psBridge) {
@@ -811,9 +849,26 @@ static __inline int emgd_bc_ts_bridge_set_buffer_info(struct drm_device *drv, vo
 	if (IMG_FALSE == bcBuf->is_conti_addr) {
 		EMGD_ERROR("Only support conti. memory!");
 	} else {
-		bcBuf->psSysAddr[0].uiAddr = psBridge->phyaddr;
+		if(!psBridge->mapped){	
+
+			if(!psBridge->virtaddr) {
+		        EMGD_ERROR("Invalid bridge address");
+		        return err;
+			}
+			/*The CPU device will be registerd into PVR later*/
+			virt=((struct emgd_ci_meminfo_t *)(psBridge->virtaddr))->virt;
+			if(!virt) {
+		        EMGD_ERROR("Invalid CPU address");	
+				return err;		
+			}
+			bcBuf->sCPUVAddr = virt;
+			bcBuf->psSysAddr[0].uiAddr = virt_to_phys(virt);
+			
+		}else{
+			bcBuf->psSysAddr[0].uiAddr = psBridge->phyaddr;
+		}
 	}
-	
+	bcBuf->mapped = psBridge->mapped;
 SUCCESS_OK:    
 	psBridge->rtn = 0;
 	
diff --git a/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.c b/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.c
index b7a879a2..3204ce6 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.c
@@ -663,9 +663,9 @@ static void free_swap_chain(emgddc_swapchain_t *swap_chain,
 	 */
 	if (swap_chain->devinfo->priv->hal_running) {
 		buffers = swap_chain->buffers;
-
-		if(!buffers[i].is_contiguous){		
-			for (i = 0 ; i < swap_chain->buffer_count ; i++) {
+			
+		for (i = 0 ; i < swap_chain->buffer_count ; i++) {
+			if(!buffers[i].is_contiguous){	
 				if (!buffers[i].is_fb) {	
 					if (buffers[i].virt_addr) {
 						context->dispatch.gmm_unmap(buffers[i].virt_addr);
@@ -673,11 +673,12 @@ static void free_swap_chain(emgddc_swapchain_t *swap_chain,
 					if (buffers[i].offset) {
 						context->dispatch.gmm_free(buffers[i].offset);
 					}
-				}
+				}				
 			}
-		}
-		else{
-			context->dispatch.gmm_unmap_ci((unsigned long)buffers[0].virt_addr);
+			else{
+				context->dispatch.gmm_unmap_ci((unsigned long)buffers[i].virt_addr);
+			}
+				
 		}
 	}
 
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/event.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/event.c
index b3e01a3..1a928d1 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/event.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/event.c
@@ -23,11 +23,14 @@
 #include <linux/version.h>
 #include <asm/io.h>
 #include <asm/page.h>
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22))
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+#include <asm/exec.h>
+#include <asm/cmpxchg.h>
+#include <asm/auxvec.h>
+#include <asm/switch_to.h>
+#else
 #include <asm/system.h>
 #endif
-#endif
 #include <linux/mm.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/osfunc.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/osfunc.c
index dca185c..ba666a9 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/osfunc.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/osfunc.c
@@ -23,11 +23,14 @@
 #include <linux/version.h>
 #include <asm/io.h>
 #include <asm/page.h>
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22))
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+#include <asm/exec.h>
+#include <asm/cmpxchg.h>
+#include <asm/auxvec.h>
+#include <asm/switch_to.h>
+#else
 #include <asm/system.h>
 #endif
-#endif
 #if defined(SUPPORT_CPU_CACHED_BUFFERS)
 #include <asm/cacheflush.h>
 #endif
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/proc.h b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/proc.h
index 07db3d7..37849c2 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/proc.h
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/proc.h
@@ -24,7 +24,12 @@
 #define __SERVICES_PROC_H__
 
 #include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+#include <asm/exec.h>
+#include <asm/cmpxchg.h>
+#include <asm/auxvec.h>
+#include <asm/switch_to.h>
+#else
 #include <asm/system.h>
 #endif
 #include <linux/proc_fs.h>
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/pvr_drm.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/pvr_drm.c
index be619af..f31f989 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/pvr_drm.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/pvr_drm.c
@@ -238,16 +238,6 @@ struct drm_ioctl_desc sPVRDrmIoctls[] = {
 
 static IMG_INT pvr_max_ioctl = DRM_ARRAY_SIZE(sPVRDrmIoctls);
 
-static const struct file_operations pvr_driver_fops = {
-	.owner = THIS_MODULE,
-	.open = drm_open,
-	.release = drm_release,
-	.ioctl = drm_ioctl,
-	.mmap = PVRMMap,
-	.poll = drm_poll,
-	.fasync = drm_fasync,
-};
-
 static struct drm_driver sPVRDrmDriver =
 {
 	.driver_features = 0,
@@ -261,7 +251,16 @@ static struct drm_driver sPVRDrmDriver =
 	.get_map_ofs = drm_core_get_map_ofs,
 	.get_reg_ofs = drm_core_get_reg_ofs,
 	.ioctls = sPVRDrmIoctls,
-	.fops = &pvr_driver_fops,
+	.fops =
+	{
+		.owner = THIS_MODULE,
+		.open = drm_open,
+		.release = drm_release,
+		.ioctl = drm_ioctl,
+		.mmap = PVRMMap,
+		.poll = drm_poll,
+		.fasync = drm_fasync,
+	},
 	.pci_driver =
 	{
 		.name = PVR_DRM_NAME,
-- 
1.7.5.4

