From bcbd017ff4d9821b077eb2841bf921bb42f4394f Mon Sep 17 00:00:00 2001
From: Allan Stephens <allan.stephens@windriver.com>
Date: Wed, 10 Nov 2010 22:22:27 -0800
Subject: [PATCH 21/22] tipc: Fix sk_buff leaks when link congestion is detected

commit f40a80abbced092ca92b9572cf73da9b3ca3b52d
http://tipc.cslab.ericsson.net/cgi-bin/gitweb.cgi?p=people/allan/tipc.git;a=shortlog;h=tipc1.7

Ensures that tipc_link_send_buf() discards the sk_buff being sent
if it cannot be transmitted because of link congestion, thereby making
it consistent with TIPC's behavior if a buffer can't be sent for other
reasons and eliminating the risk of buffer leakage by the numerous
callers who did not attempt to discard the unsent buffer. Removes code
from the two routines that did discard the unsent buffer, since they
no longer need to do this clean up.

Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
Integrated-by: Howard Xu <Hao.Xu@windriver.com>
---
 net/tipc/tipc_bcast.c |   14 ++++++--------
 net/tipc/tipc_link.c  |    7 +++----
 2 files changed, 9 insertions(+), 12 deletions(-)

diff --git a/net/tipc/tipc_bcast.c b/net/tipc/tipc_bcast.c
index 2d8e061..b13973e 100644
--- a/net/tipc/tipc_bcast.c
+++ b/net/tipc/tipc_bcast.c
@@ -356,15 +356,13 @@ int tipc_bclink_send_msg(struct sk_buff *buf)
 	}
 
 	res = tipc_link_send_buf(bcl, buf);
-	if (unlikely(res == -ELINKCONG))
-		buf_discard(buf);
-	else
+	if (likely(res >= 0)) {
 		bclink_set_last_sent();
-
-	if (bcl->out_queue_size > bcl->stats.max_queue_sz)
-		bcl->stats.max_queue_sz = bcl->out_queue_size;
-	bcl->stats.queue_sz_counts++;
-	bcl->stats.accu_queue_sz += bcl->out_queue_size;
+		if (bcl->out_queue_size > bcl->stats.max_queue_sz)
+			bcl->stats.max_queue_sz = bcl->out_queue_size;
+		bcl->stats.queue_sz_counts++;
+		bcl->stats.accu_queue_sz += bcl->out_queue_size;
+	}
 exit:
 	spin_unlock_bh(&bc_lock);
 	return res;
diff --git a/net/tipc/tipc_link.c b/net/tipc/tipc_link.c
index ba1ee7d..c5f5eb5 100644
--- a/net/tipc/tipc_link.c
+++ b/net/tipc/tipc_link.c
@@ -1009,8 +1009,9 @@ int tipc_link_send_buf(struct link *l_ptr, struct sk_buff *buf)
 
 	if (unlikely(queue_size >= queue_limit)) {
 		if (imp <= TIPC_CRITICAL_IMPORTANCE) {
-			return link_schedule_port(l_ptr, msg_origport(msg),
-						  size);
+			link_schedule_port(l_ptr, msg_origport(msg), size);
+			buf_discard(buf);
+			return -ELINKCONG;
 		}
 		msg_dbg(msg, "TIPC: Congestion, throwing away\n");
 		buf_discard(buf);
@@ -1230,8 +1231,6 @@ again:
 			if (likely(buf)) {
 				res = link_send_buf_fast(l_ptr, buf,
 							 &sender->publ.max_pkt);
-				if (unlikely(res < 0))
-					buf_discard(buf);
 exit:
 				tipc_node_unlock(node);
 				read_unlock_bh(&tipc_net_lock);
-- 
1.6.5.2

