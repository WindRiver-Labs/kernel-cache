From ee01c311c228caba23e258cca9128f5dcf13c6d9 Mon Sep 17 00:00:00 2001
From: Allan Stephens <allan.stephens@windriver.com>
Date: Wed, 10 Nov 2010 22:22:19 -0800
Subject: [PATCH 13/22] tipc: Prevent unnecessary link reset during re-discovery of a failed node

commit f4a97ad5936c3bead4a1b14956bb68c8b59c7d1a from
http://tipc.cslab.ericsson.net/cgi-bin/gitweb.cgi?p=people/allan/tipc.git;a=shortlog;h=tipc1.7

Revises the handling of neighbor discovery messages to prevent TIPC
from resetting a working link to a newly rebooted node if the discovery
message arrives after the link endpoint has already started communicating
with its peer. Previously, the arrival of a discovery message with the
rebooted node's new signature would cause TIPC to reset its link endpoint;
now, TIPC simply updates its record of the node's signature as long as
the link endpoint is working and is communicating with its peer using
the media address specified in the discovery message.

Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
Integrated-by: Howard Xu <Hao.Xu@windriver.com>
---
 net/tipc/tipc_discover.c |   88 ++++++++++++++++++++++++++--------------------
 1 files changed, 50 insertions(+), 38 deletions(-)

diff --git a/net/tipc/tipc_discover.c b/net/tipc/tipc_discover.c
index 29c88bb..0abb898 100644
--- a/net/tipc/tipc_discover.c
+++ b/net/tipc/tipc_discover.c
@@ -240,6 +240,7 @@ void tipc_disc_recv_msg(struct sk_buff *buf, struct bearer *b_ptr)
 	u32 node_flags = msg_node_flags(msg);
 	struct tipc_node *n_ptr;
         struct discoverer *d_ptr;
+	int addr_mismatch;
         int link_fully_up;
 	int found_disc;
 
@@ -310,61 +311,52 @@ void tipc_disc_recv_msg(struct sk_buff *buf, struct bearer *b_ptr)
 		return;
 	}
 
+	/* Prepare to validate requesting node's signature and media address */
+
+	link = n_ptr->links[b_ptr->identity];
+	addr_mismatch = (link != NULL) &&
+		memcmp(&link->media_addr, &media_addr, sizeof(media_addr));
+
 	/*
 	 * Ensure discovery message's signature is correct
 	 *
-	 * If signature is incorrect and there is at least one working link
-	 * to the node, reject the request (must be from a duplicate node).
-	 *
 	 * If signature is incorrect and there is no working link to the node,
-	 * accept the new signature but "invalidate" all existing links to the
+	 * accept the new signature but invalidate all existing links to the
 	 * node so they won't re-activate without a new discovery message.
-	 * (Note: It might be better to delete these "stale" link endpoints,
-	 * but this could be tricky [see tipc_link_delete()].)
+	 *
+	 * If signature is incorrect and the requested link to the node is
+	 * working, accept the new signature. (This is an instance of delayed
+	 * rediscovery, where a link endpoint was able to re-establish contact
+	 * with its peer endpoint on a node that rebooted before receiving a
+	 * discovery message from that node.)
+	 *
+	 * If signature is incorrect and there is a working link to the node
+	 * that is not the requested link, reject the request (must be from
+	 * a duplicate node).
 	 */
 
 	if (signature != n_ptr->signature) {
-		if (n_ptr->working_links > 0) {
-			disc_dupl_alert(b_ptr, orig, &media_addr);
-			tipc_node_unlock(n_ptr);                
-			return;
-		} else {
+		if (n_ptr->working_links == 0) {
 			struct link *curr_link;
 			int i;
 
 			for (i = 0; i < TIPC_MAX_BEARERS; i++) {
-				if ((curr_link = n_ptr->links[i]) != NULL) {
+				curr_link = n_ptr->links[i];
+				if (curr_link) {
 					memset(&curr_link->media_addr, 0, 
 					       sizeof(media_addr));
 					tipc_link_reset(curr_link);
 				}
 			}
-		}
-	}
-
-	/* Create a link endpoint for this bearer if none currently exists */
-
-	link = n_ptr->links[b_ptr->identity];
-
-	if (link == NULL) {
-#ifndef CONFIG_TIPC_MULTIPLE_LINKS
-		if (n_ptr->link_cnt > 0) {
-			char node_addr_str[16];
-
-			tipc_addr_string_fill(node_addr_str, orig);
-			warn("Ignoring request for second link to node %s\n",
-			     node_addr_str);
-			tipc_node_unlock(n_ptr);
-			return;
-		}
-#endif
-		link = tipc_link_create(b_ptr, orig, &media_addr);
-		if (link == NULL) {
-			warn("Memory squeeze; Failed to create link\n");
+			addr_mismatch = (link != NULL);
+		} else if (tipc_link_is_up(link) && !addr_mismatch) {
+			/* delayed rediscovery */
+		} else {
+			disc_dupl_alert(b_ptr, orig, &media_addr);
 			tipc_node_unlock(n_ptr);                
 			return;
 		}
-		goto link_ok;
+		n_ptr->signature = signature;
 	}
 
 	/*
@@ -378,7 +370,7 @@ void tipc_disc_recv_msg(struct sk_buff *buf, struct bearer *b_ptr)
 	 * cleanly.
 	 */
 
-	if (memcmp(&link->media_addr, &media_addr, sizeof(media_addr))) {
+	if (addr_mismatch) {
 		if (tipc_link_is_up(link)) {
 			disc_dupl_alert(b_ptr, orig, &media_addr);
 			tipc_node_unlock(n_ptr);
@@ -390,10 +382,30 @@ void tipc_disc_recv_msg(struct sk_buff *buf, struct bearer *b_ptr)
 		}
 	}
 
+	/* Create a link endpoint for this bearer, if necessary */
+
+	if (link == NULL) {
+#ifndef CONFIG_TIPC_MULTIPLE_LINKS
+		if (n_ptr->link_cnt > 0) {
+			char node_addr_str[16];
+
+			tipc_addr_string_fill(node_addr_str, orig);
+			warn("Ignoring request for second link to node %s\n",
+			     node_addr_str);
+			tipc_node_unlock(n_ptr);
+			return;
+		}
+#endif
+		link = tipc_link_create(b_ptr, orig, &media_addr);
+		if (link == NULL) {
+			warn("Memory squeeze; Failed to create link\n");
+			tipc_node_unlock(n_ptr);
+			return;
+		}
+	}
+
 	/* Accept node info in discovery message */
 
-link_ok:
-	n_ptr->signature = signature;
 	n_ptr->flags = node_flags;
         link_fully_up = link_working_working(link);
         tipc_node_unlock(n_ptr);
-- 
1.6.5.2

