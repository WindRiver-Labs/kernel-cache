From a552df6d75262df1934ff6397b1dd8793a086d44 Mon Sep 17 00:00:00 2001
From: Ying Xue <ying.xue@windriver.com>
Date: Wed, 10 Nov 2010 22:22:18 -0800
Subject: [PATCH 12/22] tipc: Flush unsent broadcast messages when contact with last node is lost

commit 9626024a352f5cfe0a01ea8ae10d5e6bd18a4b6e from
http://tipc.cslab.ericsson.net/cgi-bin/gitweb.cgi?p=people/allan/tipc.git;a=shortlog;h=tipc1.7

Adds code to release any unsent broadcast messages in the broadcast link
transmit queue if TIPC loses contact with its only neighboring node.
(Previously, a broadcast link that was in the congested state would hold
on to the unsent messages, even though the messages were now undelierable.)

Signed-off-by: Ying Xue <ying.xue@windriver.com>
Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
Integrated-by: Howard Xu <Hao.Xu@windriver.com>
---
 net/tipc/tipc_bcast.c |   12 +++++++++++-
 1 files changed, 11 insertions(+), 1 deletions(-)

diff --git a/net/tipc/tipc_bcast.c b/net/tipc/tipc_bcast.c
index 2cef236..f603cb1 100644
--- a/net/tipc/tipc_bcast.c
+++ b/net/tipc/tipc_bcast.c
@@ -219,7 +219,17 @@ void tipc_bclink_acknowledge(struct tipc_node *n_ptr, u32 acked)
 
 	while (crs && less_eq(buf_seqno(crs), acked)) {
 		next = crs->next;
-		bcbuf_decr_acks(crs);
+
+		if (crs != bcl->next_out)
+			bcbuf_decr_acks(crs);
+		else if (bclink->bcast_nodes.count)
+			break;
+		else {
+			bcbuf_set_acks(crs, 0);
+			bcl->next_out = next;
+			bclink_set_last_sent();
+		}
+
 		if (bcbuf_acks(crs) == 0) {
 			bcl->first_out = next;
 			bcl->out_queue_size--;
-- 
1.6.5.2

