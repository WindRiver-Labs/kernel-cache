From f519c666f88bcc5b76a00b8cab33325cc07c0944 Mon Sep 17 00:00:00 2001
From: Allan Stephens <allan.stephens@windriver.com>
Date: Tue, 9 Nov 2010 16:38:24 -0500
Subject: [PATCH 14/32] tipc: Clean out unused prototype for multiple discovery objects

commit 2574f9825b598a391a81f52aaa17d1d594a1a79a from
git://tipc.cslab.ericsson.net/pub/git/people/allan/tipc.git

Removes prototype code that was intended to allow a TIPC bearer
to have multiple discovery objects. This capability would have
allowed the bearer to have greater control over the nodes it
established links to, by allowing it to specify a subset specific
subset of nodes within a cluster (or clusters within a zone, or
zones within a network). If the prototype is needed in the future
it can recovered out of history, but there is no need for it to
clutter up the current code base.

Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
Integrated-by: Howard Xu <hao.xu@windriver.com>
---
 net/tipc/tipc_cfgsrv.c   |    8 ---
 net/tipc/tipc_discover.c |  116 ----------------------------------------------
 net/tipc/tipc_link.c     |   97 --------------------------------------
 3 files changed, 0 insertions(+), 221 deletions(-)

diff --git a/net/tipc/tipc_cfgsrv.c b/net/tipc/tipc_cfgsrv.c
index 2b5daa3..e65ea39 100644
--- a/net/tipc/tipc_cfgsrv.c
+++ b/net/tipc/tipc_cfgsrv.c
@@ -438,14 +438,6 @@ struct sk_buff *tipc_cfg_do_cmd(u32 orig_node, u16 cmd, const void *request_area
 	case TIPC_CMD_SET_LINK_WINDOW:
 		rep_tlv_buf = tipc_link_cmd_config(req_tlv_area, req_tlv_space, cmd);
 		break;
-#ifdef PROTO_MULTI_DISCOVERY_OBJECT
-	case TIPC_CMD_CREATE_LINK:
-		rep_tlv_buf = tipc_disc_cmd_create_link(req_tlv_area, req_tlv_space);
-		break;
-	case TIPC_CMD_DELETE_LINK:
-		rep_tlv_buf = tipc_link_cmd_delete(req_tlv_area, req_tlv_space);
-		break;
-#endif
 	case TIPC_CMD_ENABLE_BEARER:
 		rep_tlv_buf = cfg_enable_bearer();
 		break;
diff --git a/net/tipc/tipc_discover.c b/net/tipc/tipc_discover.c
index c3bc9e1..ccb64e9 100644
--- a/net/tipc/tipc_discover.c
+++ b/net/tipc/tipc_discover.c
@@ -49,122 +49,6 @@
 #define TIPC_DISC_INACTIVE 0xffffffff	/* There is no timer */
 
 
-#ifdef CONFIG_TIPC_CONFIG_SERVICE
-#ifdef PROTO_MULTI_DISCOVERY_OBJECT
-
-/**
- * disc_addr_match - determine if node discovery addresses overlap
- * 
- * See if address pair [ma2,ta2] matches address pair [ma1,ta1] 
- * (i.e. the contents of [ma1,ta1] can be overridden by [ma2,ta2]) 
- *
- * The following rules apply:
- *
- * - Broadcast matches broadcast if ta1 is within scope of ta2 or vice versa
- * - Unicast matches unicast if ma1 is equal to ma2.
- * - Always match if ta1 and ta2 are complete and equal.
- */
- 
-static int disc_addr_match(struct tipc_media_addr *ma1, u32 ta1,
-                           struct tipc_media_addr *ma2, u32 ta2)
-{
-        if (ma2->broadcast && ma1->broadcast) {
-                if (tipc_in_scope(ta1,ta2) || tipc_in_scope(ta1,ta2))
-                        return 1;
-        } 
-        
-        if (!ma2->broadcast && !ma1->broadcast) {
-                if (!memcmp(ma1,ma2,sizeof(struct tipc_media_addr)))
-                        return 1;
-        }
-
-        if (tipc_node(ta1) && (ta1 == ta2))
-                return 1;
-
-        return 0;
-}
-
-struct sk_buff *tipc_disc_cmd_create_link(const void *disc_tlv_area, 
-					  u32 disc_tlv_space) 
-{
-        char *cmd_str;
-	char cmd[TIPC_MAX_BEARER_NAME + TIPC_MAX_MEDIA_ADDR + TIPC_MAX_ADDR + 1];
-	char *if_name;
-        char *addr_string;
-        struct bearer *b_ptr;
-	struct discoverer *d_ptr;
-	struct discoverer *temp_d_ptr;
-        struct tipc_media_addr media_addr;
-        u32 domain = 0;
-	u32 zone = 0;
-	u32 cluster = 0;
-	u32 node = 0;
-
-	if (!TLV_CHECK(disc_tlv_area, disc_tlv_space, TIPC_TLV_CREATE_LINK))
-                return tipc_cfg_reply_error_string(TIPC_CFG_TLV_ERROR);
-
-        cmd_str = (char *)TLV_DATA(disc_tlv_area);
-        strncpy(cmd, cmd_str, sizeof(cmd));
-
-        /* Find TIPC or media address, second parameter */
-
-        addr_string = strchr(cmd, ',');
-        if (addr_string == NULL)
-                return tipc_cfg_reply_error_string(TIPC_CFG_TLV_ERROR);
-        *addr_string = '\0';
-        addr_string++;
-
-        /* Find bearer, first parameter */
-
-        if_name = cmd;
-        write_lock_bh(&tipc_net_lock);
-        b_ptr = tipc_bearer_find(if_name);
-        if (b_ptr == NULL) 
-                goto error;
-
-        /* If translation to media address fails, try if TIPC address */
-
-        if (b_ptr->media->str2addr(&media_addr, addr_string)) {
-
-                if (sscanf(addr_string,"%u.%u.%u", &zone, &cluster, &node) != 3)
-                        goto error;
-
-                domain = tipc_addr(zone, cluster, node);
-
-                if (!tipc_addr_domain_valid(domain))
-                        goto error;
-
-                memcpy(&media_addr, &b_ptr->media->bcast_addr, sizeof(media_addr));
-        } 
-
-
-        if (in_own_cluster(domain) && !is_slave(domain) && !is_slave(tipc_own_addr))
-                goto error;
-
-        /* 
-         * Check if corresponding discoverers already exist, and remove.
-         */
-
-	list_for_each_entry_safe(d_ptr, temp_d_ptr, &b_ptr->disc_list, disc_list) {
-                if (disc_addr_match(&d_ptr->dest, d_ptr->domain,
-				    &media_addr, domain)) {
-                        tipc_disc_deactivate(d_ptr);
-                        tipc_disc_delete(d_ptr);
-                }
-	}
-
-        if (tipc_disc_create(b_ptr, &media_addr, domain)) {
-                write_unlock_bh(&tipc_net_lock);
-                return tipc_cfg_reply_none();		
-        }
-error:
-        write_unlock_bh(&tipc_net_lock);
-        return tipc_cfg_reply_error_string(TIPC_CFG_TLV_ERROR);
-}
-
-#endif
-#endif
-
 /** 
  * disc_init_msg - initialize a link setup message
  * @type: message type (request or response)
diff --git a/net/tipc/tipc_link.c b/net/tipc/tipc_link.c
index bad6403..44c1868 100644
--- a/net/tipc/tipc_link.c
+++ b/net/tipc/tipc_link.c
@@ -3193,103 +3193,6 @@ struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area, u32 req_tlv_
 	return tipc_cfg_reply_none();
 }
 
-#ifdef PROTO_MULTI_DISCOVERY_OBJECT
-struct sk_buff *tipc_link_cmd_delete(const void *req_tlv_area, u32 req_tlv_space)
-{
-        char *cmd_str;
-	char *link_name;
-	struct link *l_ptr,*temp_l_ptr;
-	struct tipc_node *n_ptr;
-        struct bearer *b_ptr;
-	char *if_name,*domain_str;
-	char  cmd[TIPC_MAX_LINK_NAME + 1];
-        u32 domain,zone,cluster,node;
-
-	if (!TLV_CHECK(req_tlv_area, req_tlv_space, TIPC_TLV_LINK_NAME))
-		return tipc_cfg_reply_error_string(TIPC_CFG_TLV_ERROR);
-
-        cmd_str = (char*) TLV_DATA(req_tlv_area);
-        strncpy(cmd,cmd_str,sizeof(cmd));
-
-	link_name = cmd_str;
-	if (!strcmp(link_name, tipc_bclink_name)) {
-		if (tipc_bclink_reset_stats())
-			return tipc_cfg_reply_error_string("link not found");
-		return tipc_cfg_reply_none();
-	}
-
-        write_lock_bh(&tipc_net_lock);
-
-        /* Scope comprising several links ? */
-
-        if (strchr(link_name,'/') != NULL)
-                goto error;
-
-        if (strchr(link_name,'-') == NULL) {
-
-                if_name = cmd_str;
-
-                domain_str = strchr(if_name,',');
-                if (domain_str == NULL)
-                        goto error;
-                *domain_str = 0;
-                domain_str++;
-
-                if (sscanf(domain_str,"%u.%u.%u",&zone,&cluster,&node) != 3)
-                        goto error;
-
-                domain = tipc_addr(zone,cluster,node);
-
-                if (!tipc_addr_domain_valid(domain))
-                        goto error;
-
-                b_ptr = tipc_bearer_find(if_name);
-
-                if (b_ptr == NULL) 
-                        goto error;
-        } else {
-                l_ptr = link_find_link(link_name, &n_ptr); 
-                if (!l_ptr) 
-                        goto error;
-                domain = l_ptr->addr;
-                b_ptr = l_ptr->b_ptr;
-        }
-
-        if (in_own_cluster(domain))
-                goto error;
-
-	spin_lock_bh(&b_ptr->publ.lock);
-
-        tipc_bearer_remove_discoverer(b_ptr,domain);
-
-	list_for_each_entry_safe(l_ptr, temp_l_ptr, &b_ptr->links, link_list) {
-
-                if (tipc_in_scope(domain,l_ptr->addr)) {
-                        if (in_own_cluster(l_ptr->addr))
-                                continue;
-                        n_ptr = l_ptr->owner;
-                        tipc_node_lock(n_ptr);
-                        tipc_link_reset(l_ptr);
-
-                        /* Tell other end to not re-establish */
-
-                        tipc_link_send_proto_msg(l_ptr,RESET_MSG, 
-                                                 0, 0, 0, 0, 0, 1);
-                        l_ptr->blocked = 1;
-                        tipc_node_unlock(n_ptr);
-                        tipc_link_delete(l_ptr);
-                }
-	}
-	spin_unlock_bh(&b_ptr->publ.lock);
-	write_unlock_bh(&tipc_net_lock);
-	return tipc_cfg_reply_none();
-
- error:
-	write_unlock_bh(&tipc_net_lock);
-        return tipc_cfg_reply_error_string(TIPC_CFG_TLV_ERROR);
-}
-#endif
-
 /**
  * percent - convert count to a percentage of total (rounding up or down)
  */
-- 
1.7.0

