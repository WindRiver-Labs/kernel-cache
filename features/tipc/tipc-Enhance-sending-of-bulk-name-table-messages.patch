From 13a16c6c1a6fed92cb28758ac8722969aa830e8c Mon Sep 17 00:00:00 2001
From: Allan Stephens <allan.stephens@windriver.com>
Date: Tue, 23 Nov 2010 16:10:40 -0500
Subject: [PATCH 29/32] tipc: Enhance sending of bulk name table messages

commit c7574ac33c7ad717cd381e0e9c1efed28980e0d3 from
git://tipc.cslab.ericsson.net/pub/git/people/allan/tipc.git

Modifies the bulk transfer of name table entries to a new neighboring
node so that the messages are simply enqueued onto an active link
and then sent over the bearer. This eliminates unnecessary checks for
link congestion, fragmentation, and bundling that are not required
when sending these messages. It also eliminates the (highly unlikely)
risk that messages are not sent due to link congestion.

Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
Integrated-by: Howard Xu <hao.xu@windriver.com>
---
 net/tipc/tipc_link.c       |   44 ++++++++++++++++++++++++++++++++++++++++++++
 net/tipc/tipc_link.h       |    1 +
 net/tipc/tipc_name_distr.c |   18 ++----------------
 3 files changed, 47 insertions(+), 16 deletions(-)

diff --git a/net/tipc/tipc_link.c b/net/tipc/tipc_link.c
index 31d81ac..b3e44cf 100644
--- a/net/tipc/tipc_link.c
+++ b/net/tipc/tipc_link.c
@@ -1128,6 +1128,50 @@ int tipc_link_send(struct sk_buff *buf, u32 dest, u32 selector)
 }
 
 /*
+ * tipc_link_send_names - send name table entries to new neighbor
+ *
+ * Send routine used for delivering bulk name table entries when contact
+ * with a new neighbor occurs. No link congestion checking is performed
+ * because name table entries *must* be delivered. No MTU checking is
+ * performed because messages are known to be small enough not to require
+ * fragmentation and large enough not to need bundling.
+ * Called without any locks held.
+ */
+
+void tipc_link_send_names(struct list_head *message_list, u32 dest)
+{
+	struct tipc_node *n_ptr;
+	struct link *l_ptr;
+	struct sk_buff *buf;
+	struct sk_buff *temp_buf;
+
+	read_lock_bh(&tipc_net_lock);
+	n_ptr = tipc_net_select_node(dest);
+	if (n_ptr) {
+		tipc_node_lock(n_ptr);
+		l_ptr = n_ptr->active_links[0];
+		if (l_ptr) {
+			if (!list_empty(message_list)) {
+				/* convert circular list to linear list */
+				((struct sk_buff *)message_list->prev)->next =
+					NULL;
+				link_add_chain_to_outqueue(l_ptr,
+					(struct sk_buff *)message_list->next);
+				tipc_link_push_queue(l_ptr);
+				INIT_LIST_HEAD(message_list);
+			}
+		}
+		tipc_node_unlock(n_ptr);
+	}
+
+	list_for_each_safe(buf, temp_buf, ((struct sk_buff *)message_list)) {
+		list_del((struct list_head *)buf);
+		buf_discard(buf);
+	}
+	read_unlock_bh(&tipc_net_lock);
+}
+
+/*
  * link_send_buf_fast: Entry for data messages where the
  * destination link is known and the header is complete,
  * inclusive total message length. Very time critical.
diff --git a/net/tipc/tipc_link.h b/net/tipc/tipc_link.h
index 95c99d0..17a522a 100644
--- a/net/tipc/tipc_link.h
+++ b/net/tipc/tipc_link.h
@@ -227,6 +227,7 @@ struct sk_buff *tipc_link_cmd_show_stats(const void *req_tlv_area, u32 req_tlv_s
 struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area, u32 req_tlv_space);
 void tipc_link_reset(struct link *l_ptr);
 int tipc_link_send(struct sk_buff *buf, u32 dest, u32 selector);
+void tipc_link_send_names(struct list_head *message_list, u32 dest);
 int tipc_link_send_buf(struct link *l_ptr, struct sk_buff *buf);
 u32 tipc_link_get_max_pkt(u32 dest,u32 selector);
 int tipc_link_send_sections_fast(struct port* sender,
diff --git a/net/tipc/tipc_name_distr.c b/net/tipc/tipc_name_distr.c
index a7614ca..1810313 100644
--- a/net/tipc/tipc_name_distr.c
+++ b/net/tipc/tipc_name_distr.c
@@ -302,8 +302,6 @@ static void named_distribute(struct list_head *delivery_list, u32 dest_node,
 void tipc_named_node_up(unsigned long node_arg)
 {
 	u32 node = (u32)node_arg;
-	struct sk_buff *buf;
-	struct sk_buff *temp_buf;
 	struct list_head delivery_list;
 
 	INIT_LIST_HEAD(&delivery_list);
@@ -353,12 +351,7 @@ void tipc_named_node_up(unsigned long node_arg)
 
 	read_unlock_bh(&tipc_nametbl_lock); 
 
-	list_for_each_safe(buf, temp_buf, ((struct sk_buff *)&delivery_list)) {
-		list_del((struct list_head *)buf);
-		if (tipc_link_send(buf, node, node) < 0) {
-			warn("Bulk publication not sent\n");
-		}
-	}
+	tipc_link_send_names(&delivery_list, node);
 }
 
 /**
@@ -369,8 +362,6 @@ void tipc_named_node_up_uni(unsigned long node_arg)
 {
 #ifdef CONFIG_TIPC_UNICLUSTER_FRIENDLY
 	u32 node = (u32)node_arg;
-	struct sk_buff *buf;
-	struct sk_buff *temp_buf;
 	struct list_head delivery_list;
 
 	INIT_LIST_HEAD(&delivery_list);
@@ -386,12 +377,7 @@ void tipc_named_node_up_uni(unsigned long node_arg)
 
 	read_unlock_bh(&tipc_nametbl_lock); 
 
-	list_for_each_safe(buf, temp_buf, ((struct sk_buff *)&delivery_list)) {
-		list_del((struct list_head *)buf);
-		if (tipc_link_send(buf, node, node) < 0) {
-			warn("Bulk publication not sent\n");
-		}
-	}
+	tipc_link_send_names(&delivery_list, node);
 #endif
 }
 
-- 
1.7.0

