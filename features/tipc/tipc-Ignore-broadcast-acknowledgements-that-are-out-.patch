From 2d89f4f5cec9f5a280f9e09ff169d38009cf01b3 Mon Sep 17 00:00:00 2001
From: Allan Stephens <allan.stephens@windriver.com>
Date: Thu, 17 Feb 2011 16:22:29 -0500
Subject: [PATCH 1/6] tipc: Ignore broadcast acknowledgements that are out-of-range

Adds checks to TIPC's broadcast link so that it ignores any
acknowledgement message containing a sequence number that does not
correspond to an unacknowledged message currently in the broadcast
link's transmit queue.

This change prevents the broadcast link from becoming stalled if a
newly booted node receives stale broadcast link acknowledgement
information from another node that has not yet fully synchronized
its end of the broadcast link to reflect the current state of the
new node's end.

Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
---
 net/tipc/tipc_bcast.c |   33 +++++++++++++++++++++++++++++----
 net/tipc/tipc_link.c  |    4 +---
 net/tipc/tipc_link.h  |    6 ++++++
 net/tipc/tipc_node.c  |    2 +-
 4 files changed, 37 insertions(+), 8 deletions(-)

diff --git a/net/tipc/tipc_bcast.c b/net/tipc/tipc_bcast.c
index c24d565..b439656 100644
--- a/net/tipc/tipc_bcast.c
+++ b/net/tipc/tipc_bcast.c
@@ -216,14 +216,38 @@ void tipc_bclink_acknowledge(struct tipc_node *n_ptr, u32 acked)
 	struct sk_buff *next;
 	unsigned int released = 0;
 
-	if (less_eq(acked, n_ptr->bclink.acked))
-		return;
-
 	spin_lock_bh(&bc_lock);
 
-	/* Skip over packets that node has previously acknowledged */
+	/*
+	 * Invalid number indicates that all queued messages are acknowledged
+	 * (used when contact with specified node has been lost)
+	 */
+
+	if (acked == INVALID_LINK_SEQ)
+		acked = bcl->fsm_msg_cnt;
+
+	/*
+	 * Bail out if no unacknowledged messages in queue
+	 * (either the node is acknowledging messages it has previously ack'd
+	 * or the ack value is invalid and should be ignored)
+	 */
 
 	crs = bcl->first_out;
+	if (!crs)
+		goto exit;
+
+	/*
+	 * Validate sequence number to ensure it corresponds to a message
+	 * that has been sent and not yet acknowledged
+	 */
+
+	if (less(acked, buf_seqno(crs)) || less(bcl->fsm_msg_cnt, acked) ||
+	    less_eq(acked, n_ptr->bclink.acked)) {
+		goto exit;
+	}
+
+	/* Skip over packets that node has previously acknowledged */
+
 	while (crs && less_eq(buf_seqno(crs), n_ptr->bclink.acked)) {
 		crs = crs->next;
 	}
@@ -261,6 +285,7 @@ void tipc_bclink_acknowledge(struct tipc_node *n_ptr, u32 acked)
 	}
 	if (unlikely(released && !list_empty(&bcl->waiting_ports)))
 		tipc_link_wakeup_ports(bcl, 0);
+exit:
 	spin_unlock_bh(&bc_lock);
 }
 
diff --git a/net/tipc/tipc_link.c b/net/tipc/tipc_link.c
index b28b900..4dc0cb1 100644
--- a/net/tipc/tipc_link.c
+++ b/net/tipc/tipc_link.c
@@ -1932,10 +1932,8 @@ void tipc_recv_msg(struct sk_buff *head, struct tipc_bearer *tb_ptr)
 
 		/* Release acked messages */
 
-		if (less(n_ptr->bclink.acked, msg_bcast_ack(msg)) &&
-		    n_ptr->bclink.supported) {
+		if (n_ptr->bclink.supported)
 			tipc_bclink_acknowledge(n_ptr, msg_bcast_ack(msg));
-		}
 
 		released = 0;
 		crs = l_ptr->first_out;
diff --git a/net/tipc/tipc_link.h b/net/tipc/tipc_link.h
index de0cc57..19277cd 100644
--- a/net/tipc/tipc_link.h
+++ b/net/tipc/tipc_link.h
@@ -46,6 +46,12 @@
 #define PUSH_FINISHED 2
 
 /*
+ * Out-of-range value for link sequence numbers
+ */
+
+#define INVALID_LINK_SEQ 0x10000
+
+/*
  * Link states
  */
 
diff --git a/net/tipc/tipc_node.c b/net/tipc/tipc_node.c
index f031591..badff8d 100644
--- a/net/tipc/tipc_node.c
+++ b/net/tipc/tipc_node.c
@@ -344,7 +344,7 @@ static void node_lost_contact(struct tipc_node *n_ptr)
 		}
 
 		tipc_bclink_remove_node(n_ptr->elm.addr);
-		tipc_bclink_acknowledge(n_ptr, mod(n_ptr->bclink.acked + 10000));
+		tipc_bclink_acknowledge(n_ptr, INVALID_LINK_SEQ);
 
 		n_ptr->bclink.supported = 0;
 	}
-- 
1.7.0.4

