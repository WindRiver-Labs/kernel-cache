From 618469e31dd246e65a434975043fb6a45a345d28 Mon Sep 17 00:00:00 2001
From: Allan Stephens <allan.stephens@windriver.com>
Date: Wed, 10 Nov 2010 09:34:55 -0500
Subject: [PATCH 16/32] tipc: Enhance handling of discovery object creation errors

commit b5f751575d831afcd108c3b6f06f674f682d6bf2 from
git://tipc.cslab.ericsson.net/pub/git/people/allan/tipc.git

Modifies TIPC's bearer code to better handle errors that can occur
when a new bearer is enabled. Changes include:

1) Now rejects attempts to enable a bearer whose discovery domain
   is its own node. (Such a bearer would be useless, since there
   is no way to change or extend the discovery domain.)

2) Now handles cases where the new bearer's discovery object can't
   be created. (Previously the bearer would be enabled, but would
   be unable to establish any links; now the bearer isn't enabled
   at all.)

The above changes allow some additional simplications to be made
to the bearer code that do not affect its existing operation.
This includes the removal of an unused return value when a bearer
is disabled, and the consolidation of two related routines that are
always called in tandem from a single location.

Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
Integrated-by: Howard Xu <hao.xu@windriver.com>
---
 net/tipc/tipc_bearer.c   |   46 ++++++++++++++++++++++++++--------------------
 net/tipc/tipc_discover.c |   21 +++++----------------
 net/tipc/tipc_discover.h |    1 -
 3 files changed, 31 insertions(+), 37 deletions(-)

diff --git a/net/tipc/tipc_bearer.c b/net/tipc/tipc_bearer.c
index 6e50620..91110cd 100644
--- a/net/tipc/tipc_bearer.c
+++ b/net/tipc/tipc_bearer.c
@@ -52,6 +52,8 @@ static u32 media_count = 0;
 
 struct bearer *tipc_bearers = NULL;
 
+static void bearer_disable(struct bearer *b_ptr);
+
 /**
  * media_name_valid - validate media name
  *
@@ -509,7 +511,8 @@ int tipc_enable_bearer(const char *name, u32 disc_domain, u32 priority)
 		warn("Bearer <%s> rejected, illegal name\n", name);
 		return -EINVAL;
 	}
-	if (!tipc_addr_domain_valid(disc_domain)) {
+	if (!tipc_addr_domain_valid(disc_domain) ||
+	    (disc_domain == tipc_own_addr)) {
 		warn("Bearer <%s> rejected, illegal discovery domain\n", name);
 		return -EINVAL;
 	}
@@ -526,7 +529,7 @@ int tipc_enable_bearer(const char *name, u32 disc_domain, u32 priority)
 	if (!m_ptr) {
 		warn("Bearer <%s> rejected, media <%s> not registered\n", name,
 		     b_name.media_name);
-		goto failed;
+		goto exit;
 	}
 	if (priority == TIPC_MEDIA_LINK_PRI)
 		priority = m_ptr->priority;
@@ -541,14 +544,14 @@ restart:
 		}
 		if (!strcmp(name, tipc_bearers[i].publ.name)) {
 			warn("Bearer <%s> rejected, already enabled\n", name);
-			goto failed;
+			goto exit;
 		}
 		if ((tipc_bearers[i].priority == priority) &&
 		    (++with_this_prio > 2)) {
 			if (priority-- == 0) {
 				warn("Bearer <%s> rejected, duplicate priority\n",
 				     name);
-				goto failed;
+				goto exit;
 			}
 			warn("Bearer <%s> priority adjustment required %u->%u\n",
 			     name, priority + 1, priority);
@@ -558,7 +561,7 @@ restart:
 	if (bearer_id >= TIPC_MAX_BEARERS) {
 		warn("Bearer <%s> rejected, bearer limit reached (%u)\n", 
 		     name, TIPC_MAX_BEARERS);
-		goto failed;
+		goto exit;
 	}
 
 	b_ptr = &tipc_bearers[bearer_id];
@@ -583,19 +586,21 @@ restart:
 
 	INIT_LIST_HEAD(&b_ptr->cong_links);
 	INIT_LIST_HEAD(&b_ptr->links);
-	if (disc_domain != tipc_own_addr) {
-		tipc_disc_create(b_ptr, &m_ptr->bcast_addr, disc_domain);
-	}
 	spin_lock_init(&b_ptr->publ.lock);
 	b_ptr->active = 1;
 
-	write_unlock_bh(&tipc_net_lock);
+	res = tipc_disc_create(b_ptr, &m_ptr->bcast_addr, disc_domain);
+	if (res) {
+		bearer_disable(b_ptr);
+		warn("Bearer <%s> rejected, discovery object creation failed\n", 
+		     name);
+		goto exit;
+	}
 
 	tipc_addr_string_fill(addr_string, disc_domain);
 	info("Enabled bearer <%s>, discovery domain %s, priority %u\n",
 	     name, addr_string, priority);
-	return 0;
-failed:
+exit:
 	write_unlock_bh(&tipc_net_lock);
 	return res;
 }
@@ -640,12 +645,11 @@ int tipc_block_bearer(const char *name)
  * Note: This routine assumes caller holds tipc_net_lock.
  */
 
-static int bearer_disable(struct bearer *b_ptr)
+static void bearer_disable(struct bearer *b_ptr)
 {
 	struct link *l_ptr;
 	struct link *temp_l_ptr;
 
-	info("Disabling bearer <%s>\n", b_ptr->publ.name);
 	spin_lock_bh(&b_ptr->publ.lock);
 	b_ptr->publ.blocked = 1;
 	b_ptr->media->disable_bearer(&b_ptr->publ);
@@ -654,14 +658,10 @@ static int bearer_disable(struct bearer *b_ptr)
 	}
 	spin_unlock_bh(&b_ptr->publ.lock);
 
-	/* Safe to delete discovery struct here. Bearer is inactive now */
-
-	tipc_disc_deactivate(b_ptr->disc_obj);
 	tipc_disc_delete(b_ptr->disc_obj);
 
 	spin_lock_term(&b_ptr->publ.lock); 
 	memset(b_ptr, 0, sizeof(struct bearer));
-	return 0;
 }
 
 int tipc_disable_bearer(const char *name)
@@ -676,7 +676,9 @@ int tipc_disable_bearer(const char *name)
 		res = -EINVAL;
 	}
 	else {
-		res = bearer_disable(b_ptr);
+		info("Disabling bearer <%s>\n", b_ptr->publ.name);
+		bearer_disable(b_ptr);
+		res = 0;
 	}
 	write_unlock_bh(&tipc_net_lock);
 	return res;
@@ -702,14 +704,18 @@ int tipc_bearer_init(void)
 
 void tipc_bearer_stop(void)
 {
+	struct bearer *b_ptr;
 	u32 i;
 
 	if (!tipc_bearers)
 		return;
 
 	for (i = 0; i < TIPC_MAX_BEARERS; i++) {
-		if (tipc_bearers[i].active)
-			bearer_disable(&tipc_bearers[i]);
+		b_ptr = &tipc_bearers[i];
+		if (b_ptr->active) {
+			info("Disabling bearer <%s>\n", b_ptr->publ.name);
+			bearer_disable(b_ptr);
+		}
 	}
 	kfree(tipc_bearers);
 	tipc_bearers = NULL;
diff --git a/net/tipc/tipc_discover.c b/net/tipc/tipc_discover.c
index c78dc9c..7111854 100644
--- a/net/tipc/tipc_discover.c
+++ b/net/tipc/tipc_discover.c
@@ -287,17 +287,6 @@ void tipc_disc_recv_msg(struct sk_buff *buf, struct bearer *b_ptr)
 }
 
 /**
- * tipc_disc_deactivate - deactivate discoverer searching
- * @d_ptr: ptr to discoverer structure
- */
-
-void tipc_disc_deactivate(struct discoverer *d_ptr)
-{
-        k_cancel_timer(&d_ptr->timer);
-        d_ptr->timer_intv = TIPC_DISC_INACTIVE;
-} 
-
-/**
  * tipc_disc_update - update frequency of periodic link setup requests
  * @d_ptr: ptr to discovery structure
  * 
@@ -376,7 +365,7 @@ exit:
  * @dest: destination address for discovery message
  * @domain: network domain of node(s) to be discovered
  * 
- * Returns 1 if successful, otherwise 0.
+ * Returns 0 if successful, otherwise -errno.
  *
  * 'tipc_net_lock' must be write-locked by caller on entry
  */
@@ -388,12 +377,12 @@ int tipc_disc_create(struct bearer *b_ptr, struct tipc_media_addr *dest,
 
 	d_ptr = kmalloc(sizeof(*d_ptr), GFP_ATOMIC);
 	if (!d_ptr)
-		return 0;
+		return -ENOMEM;
 
 	d_ptr->buf = disc_init_msg(DSC_REQ_MSG, domain, b_ptr);
 	if (!d_ptr->buf) {
 		kfree(d_ptr);
-		return 0;
+		return -ENOMSG;
 	}
 
 	b_ptr->disc_obj = d_ptr;
@@ -405,13 +394,12 @@ int tipc_disc_create(struct bearer *b_ptr, struct tipc_media_addr *dest,
 	k_init_timer(&d_ptr->timer, (Handler)disc_timeout, (unsigned long)d_ptr);
         k_start_timer(&d_ptr->timer, d_ptr->timer_intv);
 	tipc_disc_send_msg(d_ptr);
-	return 1;
+	return 0;
 } 
 
 /**
  * tipc_disc_delete - stop sending periodic link setup requests
  * @disc: ptr to link request structure
- * Timer must be cancelled or expired before doing this call
  */
 
 void tipc_disc_delete(struct discoverer *d_ptr) 
@@ -419,6 +407,7 @@ void tipc_disc_delete(struct discoverer *d_ptr)
 	if (!d_ptr)
 		return;
 
+	k_cancel_timer(&d_ptr->timer);
 	k_term_timer(&d_ptr->timer);
 	buf_discard(d_ptr->buf);
 	kfree(d_ptr);
diff --git a/net/tipc/tipc_discover.h b/net/tipc/tipc_discover.h
index a4916b1..832d737 100644
--- a/net/tipc/tipc_discover.h
+++ b/net/tipc/tipc_discover.h
@@ -64,7 +64,6 @@ int tipc_disc_create(struct bearer *b_ptr, struct tipc_media_addr *dest,
 		     u32 domain);
 void tipc_disc_update(struct discoverer *d_ptr);
 void tipc_disc_delete(struct discoverer *d_ptr);
-void tipc_disc_deactivate(struct discoverer *d_ptr);
 void tipc_disc_recv_msg(struct sk_buff *buf, struct bearer *b_ptr);
 void tipc_disc_send_msg(struct discoverer *d_ptr);
 struct sk_buff *tipc_disc_cmd_create_link(const void *disc_tlv_area, 
-- 
1.7.0

