From df56eb5f75cac7c2a237107ad9b2e1e095cc2705 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Wed, 27 Feb 2013 13:29:21 +0800
Subject: [PATCH 1/5] tipc: uprev to TIPC 1.7.7

Update tipc version from TIPC 1.7.6 to 1.7.7.

Reference:
http://sourceforge.net/projects/tipc/files/tipc-linux/tipc-linux-1.7.7

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 include/linux/tipc.h           |   10 +-
 include/linux/tipc_config.h    |   55 +---
 include/net/tipc/tipc.h        |   10 +-
 include/net/tipc/tipc_bearer.h |  138 ---------
 include/net/tipc/tipc_msg.h    |  207 -------------
 include/net/tipc/tipc_port.h   |  103 -------
 net/tipc/Kconfig               |   70 +++---
 net/tipc/tipc_bcast.c          |  163 ++++++++---
 net/tipc/tipc_bcast.h          |    7 +-
 net/tipc/tipc_bearer.c         |  169 +++++-------
 net/tipc/tipc_bearer.h         |   19 +-
 net/tipc/tipc_cfgsrv.c         |  183 +-----------
 net/tipc/tipc_cfgsrv.h         |    8 +-
 net/tipc/tipc_core.c           |    8 +-
 net/tipc/tipc_core.h           |    5 +-
 net/tipc/tipc_dbg.c            |   32 +-
 net/tipc/tipc_dbg.h            |   14 +-
 net/tipc/tipc_discover.c       |  289 +++++--------------
 net/tipc/tipc_discover.h       |    7 +-
 net/tipc/tipc_eth_media.c      |   10 +-
 net/tipc/tipc_link.c           |  626 ++++++++++++++++++----------------------
 net/tipc/tipc_link.h           |   43 ++--
 net/tipc/tipc_msg.c            |   15 +-
 net/tipc/tipc_msg.h            |    6 +-
 net/tipc/tipc_name_distr.c     |   95 +++----
 net/tipc/tipc_name_distr.h     |    2 +-
 net/tipc/tipc_name_table.c     |  262 +++++++++++++----
 net/tipc/tipc_name_table.h     |   16 +-
 net/tipc/tipc_net.c            |   14 +-
 net/tipc/tipc_netlink.c        |   46 ++--
 net/tipc/tipc_node.c           |  116 +++-----
 net/tipc/tipc_node.h           |   30 ++-
 net/tipc/tipc_port.c           |  225 +++++++--------
 net/tipc/tipc_port.h           |    8 +-
 net/tipc/tipc_ref.c            |   24 +-
 net/tipc/tipc_socket.c         |  168 ++++++++----
 net/tipc/tipc_topsrv.c         |   15 +-
 37 files changed, 1283 insertions(+), 1935 deletions(-)
 delete mode 100644 include/net/tipc/tipc_bearer.h
 delete mode 100644 include/net/tipc/tipc_msg.h
 delete mode 100644 include/net/tipc/tipc_port.h

diff --git a/include/linux/tipc.h b/include/linux/tipc.h
index 48d6847..cfb6f88 100644
--- a/include/linux/tipc.h
+++ b/include/linux/tipc.h
@@ -2,7 +2,7 @@
  * include/linux/tipc.h: Include file for TIPC socket interface
  * 
  * Copyright (c) 2003-2006, Ericsson AB
- * Copyright (c) 2005-2008, Wind River Systems
+ * Copyright (c) 2005-2008, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -131,12 +131,6 @@ static inline unsigned int tipc_node(__u32 addr)
 #define TIPC_SUB_PORTS     	0x01  	/* filter for port availability */
 #define TIPC_SUB_SERVICE     	0x02  	/* filter for service availability */
 #define TIPC_SUB_CANCEL         0x04    /* cancel a subscription */
-#if 0
-/* The following filter options are not currently implemented */
-#define TIPC_SUB_NO_BIND_EVTS	0x04	/* filter out "publish" events */
-#define TIPC_SUB_NO_UNBIND_EVTS	0x08	/* filter out "withdraw" events */
-#define TIPC_SUB_SINGLE_EVT	0x10	/* expire after first event */
-#endif
 
 #define TIPC_WAIT_FOREVER	~0	/* timeout for permanent subscription */
 
@@ -210,5 +204,7 @@ struct sockaddr_tipc {
 #define TIPC_SRC_DROPPABLE	128	/* Default: based on socket type */
 #define TIPC_DEST_DROPPABLE	129	/* Default: based on socket type */
 #define TIPC_CONN_TIMEOUT	130	/* Default: 8000 (ms)  */
+#define TIPC_NODE_RECVQ_DEPTH	131
+#define TIPC_SOCK_RECVQ_DEPTH	132
 
 #endif
diff --git a/include/linux/tipc_config.h b/include/linux/tipc_config.h
index d7eee77..29d2a42 100644
--- a/include/linux/tipc_config.h
+++ b/include/linux/tipc_config.h
@@ -2,7 +2,7 @@
  * include/linux/tipc_config.h: Include file for TIPC configuration interface
  * 
  * Copyright (c) 2003-2006, Ericsson AB
- * Copyright (c) 2005-2007, Wind River Systems
+ * Copyright (c) 2005-2007, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -81,12 +81,6 @@
 #define  TIPC_CMD_SHOW_LINK_STATS   0x000B    /* tx link_name, rx ultra_string */
 #define  TIPC_CMD_SHOW_STATS        0x000F    /* tx unsigned, rx ultra_string */
 
-#if 0
-#define  TIPC_CMD_SHOW_PORT_STATS   0x0008    /* tx port_ref, rx ultra_string */
-#define  TIPC_CMD_RESET_PORT_STATS  0x0009    /* tx port_ref, rx none */
-#define  TIPC_CMD_GET_LINK_PEER     0x000D    /* tx link_name, rx ? */
-#endif
-
 /* 
  * Protected commands:
  * May only be issued by "network administration capable" process.
@@ -101,9 +95,6 @@
 #define  TIPC_CMD_GET_MAX_ZONES     0x4007    /* tx none, rx unsigned */
 #define  TIPC_CMD_GET_MAX_CLUSTERS  0x4008    /* tx none, rx unsigned */
 #define  TIPC_CMD_GET_MAX_NODES     0x4009    /* tx none, rx unsigned */
-#if 0
-#define  TIPC_CMD_GET_MAX_SLAVES    0x400A    /* tx none, rx unsigned */
-#endif
 #define  TIPC_CMD_GET_NETID         0x400B    /* tx none, rx unsigned */
 #define  TIPC_CMD_GET_MAX_REMOTES   0x400C    /* tx none, rx unsigned */
 
@@ -117,10 +108,6 @@
 #define  TIPC_CMD_RESET_LINK_STATS  0x410C    /* tx link_name, rx none */
 #define  TIPC_CMD_CREATE_LINK       0x4103    /* tx link_create, rx none */
 #define  TIPC_CMD_DELETE_LINK       0x4104    /* tx link_name, rx none */
-#if 0
-#define  TIPC_CMD_BLOCK_LINK        0x4105    /* tx link_name, rx none */
-#define  TIPC_CMD_UNBLOCK_LINK      0x4106    /* tx link_name, rx none */
-#endif
 
 /* 
  * Private commands:
@@ -129,9 +116,6 @@
  */
 
 #define  TIPC_CMD_SET_NODE_ADDR     0x8001    /* tx net_addr, rx none */
-#if 0
-#define  TIPC_CMD_SET_ZONE_MASTER   0x8002    /* tx none, rx none */
-#endif
 #define  TIPC_CMD_SET_REMOTE_MNG    0x8003    /* tx unsigned, rx none */
 #define  TIPC_CMD_SET_MAX_PORTS     0x8004    /* tx unsigned, rx none */
 #define  TIPC_CMD_SET_MAX_PUBL      0x8005    /* tx unsigned, rx none */
@@ -139,9 +123,6 @@
 #define  TIPC_CMD_SET_MAX_ZONES     0x8007    /* tx unsigned, rx none */
 #define  TIPC_CMD_SET_MAX_CLUSTERS  0x8008    /* tx unsigned, rx none */
 #define  TIPC_CMD_SET_MAX_NODES     0x8009    /* tx unsigned, rx none */
-#if 0
-#define  TIPC_CMD_SET_MAX_SLAVES    0x800A    /* tx unsigned, rx none */
-#endif
 #define  TIPC_CMD_SET_NETID         0x800B    /* tx unsigned, rx none */
 #define  TIPC_CMD_SET_MAX_REMOTES   0x800C    /* tx unsigned, rx none */
 
@@ -266,15 +247,6 @@ struct tipc_name_table_query {
 #define TIPC_CFG_NOT_SUPPORTED  "\x84"	/* request is not supported by TIPC */
 #define TIPC_CFG_INVALID_VALUE  "\x85"  /* request has invalid argument value */
 
-#if 0
-/* prototypes TLV structures for proposed commands */
-struct tipc_link_create {
-	__be32   domain;
-	struct tipc_media_addr peer_addr;
-	char bearer_name[TIPC_MAX_BEARER_NAME];
-};
-#endif
-
 /*
  * A TLV consists of a descriptor, followed by the TLV value.
  * TLV descriptor fields are stored in network byte order; 
@@ -289,14 +261,15 @@ struct tlv_desc {
 	__be16 tlv_type;	/* TLV identifier */
 };
 
-#define TLV_ALIGNTO 4
+#define TLV_ALIGNTO 4u
 
-#define TLV_ALIGN(datalen) (((datalen)+(TLV_ALIGNTO-1)) & ~(TLV_ALIGNTO-1))
-#define TLV_LENGTH(datalen) (sizeof(struct tlv_desc) + (datalen))
+#define TLV_ALIGN(datalen) \
+		((__u16)(((datalen)+(TLV_ALIGNTO-1)) & ~(TLV_ALIGNTO-1)))
+#define TLV_LENGTH(datalen) ((__u16)(sizeof(struct tlv_desc) + (datalen)))
 #define TLV_SPACE(datalen) (TLV_ALIGN(TLV_LENGTH(datalen)))
 #define TLV_DATA(tlv) ((void *)((char *)(tlv) + TLV_LENGTH(0)))
 
-static inline int TLV_OK(const void *tlv, __u16 space)
+static inline int TLV_OK(const void *tlv, __u32 space)
 {
 	/*
 	 * Would also like to check that "tlv" is a multiple of 4,
@@ -311,16 +284,16 @@ static inline int TLV_OK(const void *tlv, __u16 space)
 		(ntohs(((struct tlv_desc *)tlv)->tlv_len) <= space);
 }
 
-static inline int TLV_CHECK(const void *tlv, __u16 space, __u16 exp_type)
+static inline int TLV_CHECK(const void *tlv, __u32 space, __u16 exp_type)
 {
 	return TLV_OK(tlv, space) && 
 		(ntohs(((struct tlv_desc *)tlv)->tlv_type) == exp_type);
 }
 
-static inline int TLV_SET(void *tlv, __u16 type, void *data, __u16 len)
+static inline __u16 TLV_SET(void *tlv, __u16 type, void *data, size_t len)
 {
 	struct tlv_desc *tlv_ptr;
-	int tlv_len;
+	__u16 tlv_len;
 
 	tlv_len = TLV_LENGTH(len);
 	tlv_ptr = (struct tlv_desc *)tlv;
@@ -409,16 +382,16 @@ struct tipc_cfg_msg_hdr
 #define TCM_F_REQUEST	0x1	/* Flag: Request message */
 #define TCM_F_MORE	0x2	/* Flag: Message to be continued */
 
-#define TCM_ALIGN(datalen)  (((datalen)+3) & ~3)
-#define TCM_LENGTH(datalen) (sizeof(struct tipc_cfg_msg_hdr) + datalen)
+#define TCM_ALIGN(datalen)  ((__u32)(((datalen)+3) & ~3))
+#define TCM_LENGTH(datalen) ((__u32)(sizeof(struct tipc_cfg_msg_hdr) + datalen))
 #define TCM_SPACE(datalen)  (TCM_ALIGN(TCM_LENGTH(datalen)))
 #define TCM_DATA(tcm_hdr)   ((void *)((char *)(tcm_hdr) + TCM_LENGTH(0)))
 
-static inline int TCM_SET(void *msg, __u16 cmd, __u16 flags,
-			  void *data, __u16 data_len)
+static inline __u32 TCM_SET(void *msg, __u16 cmd, __u16 flags,
+			    void *data, __u32 data_len)
 {
 	struct tipc_cfg_msg_hdr *tcm_hdr;
-	int msg_len;
+	__u32 msg_len;
 
 	msg_len = TCM_LENGTH(data_len);
 	tcm_hdr = (struct tipc_cfg_msg_hdr *)msg;
diff --git a/include/net/tipc/tipc.h b/include/net/tipc/tipc.h
index d1f5902..56e2f11 100644
--- a/include/net/tipc/tipc.h
+++ b/include/net/tipc/tipc.h
@@ -2,7 +2,7 @@
  * include/net/tipc/tipc.h: Main include file for TIPC users
  * 
  * Copyright (c) 2003-2006, Ericsson AB
- * Copyright (c) 2005,2008 Wind River Systems
+ * Copyright (c) 2005, 2008, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -232,14 +232,6 @@ int tipc_multicast(u32 portref,
 		   unsigned int section_count,
 		   struct iovec const *msg);
 
-#if 0
-int tipc_multicast_buf(u32 portref, 
-		       struct tipc_name_seq const *seq, 
-		       u32 domain,
-		       void *buf,
-		       unsigned int size);
-#endif
-
 /*
  * TIPC subscription routines
  */
diff --git a/include/net/tipc/tipc_bearer.h b/include/net/tipc/tipc_bearer.h
deleted file mode 100644
index ee2f304..0000000
--- a/include/net/tipc/tipc_bearer.h
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * include/net/tipc/tipc_bearer.h: Include file for privileged access to TIPC bearers
- * 
- * Copyright (c) 2003-2006, Ericsson AB
- * Copyright (c) 2005, Wind River Systems
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the names of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _NET_TIPC_BEARER_H_
-#define _NET_TIPC_BEARER_H_
-
-#ifdef __KERNEL__
-
-#include <linux/tipc_config.h>
-#include <linux/skbuff.h>
-#include <linux/spinlock.h>
-
-/*
- * Identifiers of supported TIPC media types
- */
-
-#define TIPC_MEDIA_TYPE_ETH	1
-
-/* 
- * Destination address structure used by TIPC bearers when sending messages
- * 
- * IMPORTANT: The fields of this structure MUST be stored using the specified
- * byte order indicated below, as the structure is exchanged between nodes
- * as part of a link setup process.
- */
-
-struct tipc_media_addr {
-	__be32  type;			/* bearer type (network byte order) */
-	union {
-		__u8   eth_addr[6];	/* 48 bit Ethernet addr (byte array) */ 
-#if 0
-		/* Prototypes for other possible bearer types */
-
-		struct {
-			__u16 sin_family;
-			__u16 sin_port;
-			struct {
-				__u32 s_addr;
-			} sin_addr;
-			char pad[4];
-		} addr_in;		/* IP-based bearer */
-		__u16  sock_descr;	/* generic socket bearer */
-#endif
-	} dev_addr;
-};
-
-/**
- * struct tipc_bearer - TIPC bearer info available to privileged users
- * @usr_handle: pointer to additional user-defined information about bearer
- * @mtu: max packet size bearer can support
- * @blocked: non-zero if bearer is blocked
- * @lock: spinlock for controlling access to bearer
- * @addr: media-specific address associated with bearer
- * @name: bearer name (format = media:interface)
- * 
- * Note: TIPC initializes "name" and "lock" fields; user is responsible for
- * initialization all other fields when a bearer is enabled.
- */
-
-struct tipc_bearer {
-	void *usr_handle;
-	u32 mtu;
-	int blocked;
-	spinlock_t lock;
-	struct tipc_media_addr addr;
-	char name[TIPC_MAX_BEARER_NAME];
-};
-
-/*
- * TIPC routines available to supported media types
- */
-
-int  tipc_register_media(u32 media_type,
-			 char *media_name, 
-			 int (*enable)(struct tipc_bearer *), 
-			 void (*disable)(struct tipc_bearer *), 
-			 int (*send_msg)(struct sk_buff *, 
-					 struct tipc_bearer *,
-					 struct tipc_media_addr *), 
-			 char *(*addr2str)(struct tipc_media_addr *a,
-					   char *str_buf,
-					   int str_size),
-			 struct tipc_media_addr *bcast_addr,
-			 const u32 bearer_priority,
-			 const u32 link_tolerance,  /* [ms] */
-			 const u32 send_window_limit); 
-
-void tipc_recv_msg(struct sk_buff *buf, struct tipc_bearer *tb_ptr);
-
-int  tipc_block_bearer(const char *name);
-void tipc_continue(struct tipc_bearer *tb_ptr); 
-
-int tipc_enable_bearer(const char *bearer_name, u32 bcast_scope, u32 priority);
-int tipc_disable_bearer(const char *name);
-
-/*
- * Routines made available to TIPC by supported media types
- */
-
-int  tipc_eth_media_start(void);
-void tipc_eth_media_stop(void);
-
-#endif
-
-#endif
diff --git a/include/net/tipc/tipc_msg.h b/include/net/tipc/tipc_msg.h
deleted file mode 100644
index 2e159a8..0000000
--- a/include/net/tipc/tipc_msg.h
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * include/net/tipc/tipc_msg.h: Include file for privileged access to TIPC message headers
- * 
- * Copyright (c) 2003-2006, Ericsson AB
- * Copyright (c) 2005, Wind River Systems
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the names of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _NET_TIPC_MSG_H_
-#define _NET_TIPC_MSG_H_
-
-#ifdef __KERNEL__
-
-struct tipc_msg {
-	__be32 hdr[15];
-};
-
-
-/*
-		TIPC user data message header format, version 2:
-
-
-       1 0 9 8 7 6 5 4|3 2 1 0 9 8 7 6|5 4 3 2 1 0 9 8|7 6 5 4 3 2 1 0 
-      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   w0:|vers | user  |hdr sz |n|d|s|-|          message size           |
-      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   w1:|mstyp| error |rer cnt|lsc|opt p|      broadcast ack no         |
-      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   w2:|        link level ack no      |   broadcast/link level seq no |
-      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   w3:|                       previous node                           |
-      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   w4:|                      originating port                         |
-      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   w5:|                      destination port                         |
-      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    
-   w6:|                      originating node                         |
-      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   w7:|                      destination node                         |
-      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   w8:|            name type / transport sequence number              |
-      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-   w9:|              name instance/multicast lower bound              |
-      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    
-   wA:|                    multicast upper bound                      |
-      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    
-      /                                                               /
-      \                           options                             \
-      /                                                               /
-      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-
-*/
-
-#define TIPC_CONN_MSG	0
-#define TIPC_MCAST_MSG	1
-#define TIPC_NAMED_MSG	2
-#define TIPC_DIRECT_MSG	3
-
-
-static inline u32 msg_word(struct tipc_msg *m, u32 pos)
-{
-	return ntohl(m->hdr[pos]);
-}
-
-static inline u32 msg_bits(struct tipc_msg *m, u32 w, u32 pos, u32 mask)
-{
-	return (msg_word(m, w) >> pos) & mask;
-}
-
-static inline u32 msg_importance(struct tipc_msg *m)
-{
-	return msg_bits(m, 0, 25, 0xf);
-}
-
-static inline u32 msg_hdr_sz(struct tipc_msg *m)
-{
-	return msg_bits(m, 0, 21, 0xf) << 2;
-}
-
-static inline int msg_short(struct tipc_msg *m)
-{
-	return (msg_hdr_sz(m) == 24);
-}
-
-static inline u32 msg_size(struct tipc_msg *m)
-{
-	return msg_bits(m, 0, 0, 0x1ffff);
-}
-
-static inline u32 msg_data_sz(struct tipc_msg *m)
-{
-	return (msg_size(m) - msg_hdr_sz(m));
-}
-
-static inline unchar *msg_data(struct tipc_msg *m)
-{
-	return ((unchar *)m) + msg_hdr_sz(m);
-}
-
-static inline u32 msg_type(struct tipc_msg *m)
-{
-	return msg_bits(m, 1, 29, 0x7);
-}
-
-static inline u32 msg_named(struct tipc_msg *m)
-{
-	return (msg_type(m) == TIPC_NAMED_MSG);
-}
-
-static inline u32 msg_mcast(struct tipc_msg *m)
-{
-	return (msg_type(m) == TIPC_MCAST_MSG);
-}
-
-static inline u32 msg_connected(struct tipc_msg *m)
-{
-	return (msg_type(m) == TIPC_CONN_MSG);
-}
-
-static inline u32 msg_errcode(struct tipc_msg *m)
-{
-	return msg_bits(m, 1, 25, 0xf);
-}
-
-static inline u32 msg_prevnode(struct tipc_msg *m)
-{
-	return msg_word(m, 3);
-}
-
-static inline u32 msg_origport(struct tipc_msg *m)
-{
-	return msg_word(m, 4);
-}
-
-static inline u32 msg_destport(struct tipc_msg *m)
-{
-	return msg_word(m, 5);
-}
-
-static inline u32 msg_mc_netid(struct tipc_msg *m)
-{
-	return msg_word(m, 5);
-}
-
-static inline u32 msg_orignode(struct tipc_msg *m)
-{
-	if (likely(msg_short(m)))
-		return msg_prevnode(m);
-	return msg_word(m, 6);
-}
-
-static inline u32 msg_destnode(struct tipc_msg *m)
-{
-	return msg_word(m, 7);
-}
-
-static inline u32 msg_nametype(struct tipc_msg *m)
-{
-	return msg_word(m, 8);
-}
-
-static inline u32 msg_nameinst(struct tipc_msg *m)
-{
-	return msg_word(m, 9);
-}
-
-static inline u32 msg_namelower(struct tipc_msg *m)
-{
-	return msg_nameinst(m);
-}
-
-static inline u32 msg_nameupper(struct tipc_msg *m)
-{
-	return msg_word(m, 10);
-}
-
-#endif
-
-#endif
diff --git a/include/net/tipc/tipc_port.h b/include/net/tipc/tipc_port.h
deleted file mode 100644
index c54917c..0000000
--- a/include/net/tipc/tipc_port.h
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * include/net/tipc/tipc_port.h: Include file for privileged access to TIPC ports
- * 
- * Copyright (c) 1994-2007, Ericsson AB
- * Copyright (c) 2005-2008, Wind River Systems
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the names of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _NET_TIPC_PORT_H_
-#define _NET_TIPC_PORT_H_
-
-#ifdef __KERNEL__
-
-#include <linux/tipc.h>
-#include <linux/skbuff.h>
-#include <net/tipc/tipc_msg.h>
-
-#define TIPC_FLOW_CONTROL_WIN 512
-
-/**
- * struct tipc_port - native TIPC port info available to privileged users
- * @usr_handle: pointer to additional user-defined information about port
- * @lock: pointer to spinlock for controlling access to port
- * @connected: non-zero if port is currently connected to a peer port
- * @conn_type: TIPC type used when connection was established
- * @conn_instance: TIPC instance used when connection was established
- * @conn_unacked: number of unacknowledged messages received from peer port
- * @published: non-zero if port has one or more associated names
- * @congested: non-zero if cannot send because of link or port congestion
- * @max_pkt: maximum packet size "hint" used when building messages sent by port
- * @ref: unique reference to port in TIPC object registry
- * @phdr: preformatted message header used when sending messages
- */
-
-struct tipc_port {
-        void *usr_handle;
-        spinlock_t *lock;
-	int connected;
-        u32 conn_type;
-        u32 conn_instance;
-	u32 conn_unacked;
-	int published;
-	u32 congested;
-	u32 max_pkt;
-	u32 ref;
-	struct tipc_msg phdr;
-};
-
-
-struct tipc_port *tipc_createport_raw(void *usr_handle,
-			u32 (*dispatcher)(struct tipc_port *, struct sk_buff *),
-			void (*wakeup)(struct tipc_port *),
-			const u32 importance);
-
-int tipc_reject_msg(struct sk_buff *buf, u32 err);
-
-int tipc_send_buf_fast(struct sk_buff *buf, u32 destnode);
-
-void tipc_acknowledge(u32 port_ref,u32 ack);
-
-struct tipc_port *tipc_get_port(const u32 ref);
-
-void *tipc_get_handle(const u32 ref);
-
-/*
- * The following routines require that the port be locked on entry
- */
-
-int tipc_disconnect_port(struct tipc_port *tp_ptr);
-
-
-#endif
-
-#endif
-
diff --git a/net/tipc/Kconfig b/net/tipc/Kconfig
index 21711c5..3221c99 100644
--- a/net/tipc/Kconfig
+++ b/net/tipc/Kconfig
@@ -24,23 +24,23 @@ if TIPC
 
 config TIPC_ADVANCED
 	bool "Advanced TIPC configuration"
-	depends on TIPC
 	default n
 	help
-	  Saying Y here will open some advanced configuration for TIPC. 
+	  Saying Y here will open some advanced configuration for TIPC.
 	  Most users do not need to bother; if unsure, just say N.
 
 config TIPC_NETID
 	int "Network identifier"
-	depends on TIPC && TIPC_ADVANCED
+	depends on TIPC_ADVANCED
+	range 1 9999
 	default "4711"
 	help
-	  Specifies which TIPC network this node belongs to. 
+	  Specifies which TIPC network this node belongs to.
 	  Can range from 1 to 9999; default is 4711.
 	  
 config TIPC_REMOTE_MNG
 	bool "Enable remote management"
-	depends on TIPC && TIPC_ADVANCED
+	depends on TIPC_ADVANCED
 	default y
 	help
  	  Specifies if this node can be remotely managed from another node
@@ -48,84 +48,92 @@ config TIPC_REMOTE_MNG
 
 config TIPC_PORTS
 	int "Maximum number of ports in own node"
-	depends on TIPC && TIPC_ADVANCED
+	depends on TIPC_ADVANCED
+	range 127 65535
 	default "8191"
 	help
-	  Specifies how many ports can be supported by this node. 
-	  Can range from 127 to 65536; default is 8191. 
+	  Specifies how many ports can be supported by this node.
+	  Can range from 127 to 65535; default is 8191.
 
-	  Setting this to a smaller value saves some memory; 
+	  Setting this to a smaller value saves some memory;
 	  setting it to a higher value allows more ports.
 
 config TIPC_NODES
 	int "Maximum number of nodes in own cluster"
-	depends on TIPC && TIPC_ADVANCED
+	depends on TIPC_ADVANCED
+	range 8 4095
 	default "255"
 	help
-	  Specifies how many nodes can be supported in own TIPC cluster. 
-	  Can range from 8 to 4095 nodes; default is 255. 
+	  Specifies how many nodes can be supported in own TIPC cluster.
+	  Can range from 8 to 4095 nodes; default is 255.
 
-	  Setting this to a smaller value saves some memory; 
+	  Setting this to a smaller value saves some memory;
 	  setting it to a higher value allows more nodes.
 
 config TIPC_CLUSTERS
 	int "Maximum number of clusters in own zone"
-	depends on TIPC && TIPC_ADVANCED
+	depends on TIPC_ADVANCED
+	range 1 4095
 	default "8"
 	help
-	  Specifies how many clusters can be supported in own TIPC zone. 
-	  Can range from 1 to 4095 clusters; default is 8. 
+	  Specifies how many clusters can be supported in own TIPC zone.
+	  Can range from 1 to 4095 clusters; default is 8.
 
 	  Setting this to a smaller value saves some memory; 
 	  setting it to a higher value allows for more clusters.
 
 config TIPC_ZONES
 	int "Maximum number of zones in own network"
-	depends on TIPC && TIPC_ADVANCED
+	depends on TIPC_ADVANCED
+	range 1 255
 	default "4"
 	help
-	  Specifies how many zones can be supported in own TIPC network. 
-	  Can range from 1 to 255 zones; default is 4. 
+	  Specifies how many zones can be supported in own TIPC network.
+	  Can range from 1 to 255 zones; default is 4.
 
-	  Setting this to a smaller value saves some memory; 
+	  Setting this to a smaller value saves some memory;
 	  setting it to a higher value allows for more zones.
 
 config TIPC_REMOTES
 	int "Maximum number of neighbor nodes in other clusters"
-	depends on TIPC && TIPC_ADVANCED
+	depends on TIPC_ADVANCED
+	range 0 255
 	default "8"
 	help
 	  Specifies how many nodes in other clusters this node can establish
-	  links to.  Can range from 0 to 255 nodes; default is 8. 
+	  links to.  Can range from 0 to 255 nodes; default is 8.
 
 	  Setting this to a smaller value saves some memory; 
 	  setting it to a higher value allows more inter-cluster links.
 
 config TIPC_PUBL
 	int "Maximum number of name publications by own node"
-	depends on TIPC && TIPC_ADVANCED
+	depends on TIPC_ADVANCED
+	range 1 65535
 	default "10000"
 	help
 	  Specifies how many concurrent name publications this node can issue.
-	  Can range from 1 to 65535 publications; default is 10000. 
+	  Can range from 1 to 65535 publications; default is 10000.
 
-	  Setting this to a smaller value saves some memory; 
+	  Setting this to a smaller value saves some memory;
 	  setting it to a higher value allows more name publications.
 
 config TIPC_SUBSCR
 	int "Maximum number of name subscriptions by own node"
-	depends on TIPC && TIPC_ADVANCED
+	depends on TIPC_ADVANCED
+	range 1 65535
 	default "2000"
 	help
 	  Specifies how many concurrent name subscriptions this node can handle.
-	  Can range from 1 to 65535 subscriptions; default is 2000. 
+	  Can range from 1 to 65535 subscriptions; default is 2000.
 
 	  Setting this to a smaller value saves some memory; 
 	  setting it to a higher value allows more name subscriptions.
 
 config TIPC_LOG
 	int "Size of log buffer"
-	depends on TIPC && TIPC_ADVANCED
+	depends on TIPC_ADVANCED
+	range 0 32768
 	default 0
 	help
  	  Size (in bytes) of TIPC's internal log buffer, which records the
@@ -137,7 +145,6 @@ config TIPC_LOG
 
 config TIPC_UNICLUSTER_FRIENDLY
 	bool "Inter-operate with uni-cluster nodes"
-	depends on TIPC
 	default y
 	help
  	  This allows TIPC to communicate with nodes in its cluster that
@@ -146,7 +153,6 @@ config TIPC_UNICLUSTER_FRIENDLY
 
 config TIPC_MULTIPLE_LINKS
 	bool "Enable redundant link support"
-	depends on TIPC
 	default y
 	help
  	  This allows TIPC to establish multiple links to neighboring nodes
@@ -155,7 +161,6 @@ config TIPC_MULTIPLE_LINKS
 
 config TIPC_CONFIG_SERVICE
 	bool "Enable configuration service"
-	depends on TIPC
 	default y
 	help
  	  This allows TIPC to be dynamically configured and monitored
@@ -163,14 +168,12 @@ config TIPC_CONFIG_SERVICE
 
 config TIPC_SOCKET_API
 	bool "Enable socket support"
-	depends on TIPC
 	default y
 	help
  	  This allows TIPC to support sockets of the AF_TIPC address family.
 
 config TIPC_SYSTEM_MSGS
 	bool "Enable system messages"
-	depends on TIPC
 	default y
 	help
  	  This allows TIPC to record the occurrence of significant events
@@ -181,7 +184,6 @@ config TIPC_SYSTEM_MSGS
 
 config TIPC_DEBUG
 	bool "Enable debug messages"
-	depends on TIPC
 	default n
 	help
  	  This enables debugging of TIPC.
diff --git a/net/tipc/tipc_bcast.c b/net/tipc/tipc_bcast.c
index 45e5683..c53dcfb 100644
--- a/net/tipc/tipc_bcast.c
+++ b/net/tipc/tipc_bcast.c
@@ -3,7 +3,7 @@
  *
  * Copyright (c) 2004-2006, Ericsson AB
  * Copyright (c) 2004, Intel Corporation.
- * Copyright (c) 2005-2008, Wind River Systems
+ * Copyright (c) 2005-2008, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -104,6 +104,7 @@ struct bcbearer {
  * @link: (non-standard) broadcast link structure
  * @node: (non-standard) node structure representing b'cast link's peer node
  * @bcast_nodes: map of b'cast capable nodes in cluster
+ * @retransmit_to: node that most recently requested a retransmit
  * 
  * Handles sequence numbering, fragmentation, bundling, etc.
  */
@@ -112,6 +113,7 @@ struct bclink {
 	struct link link;
 	struct tipc_node node;
 	struct tipc_node_map bcast_nodes;
+	struct tipc_node *retransmit_to;
 };
 
 
@@ -120,12 +122,12 @@ static struct bclink *bclink = NULL;
 static struct link *bcl = NULL;
 static DEFINE_SPINLOCK(bc_lock);
 
-char tipc_bclink_name[] = "broadcast-link";
+const char tipc_bclink_name[] = "broadcast-link";
 
 
 static u32 bcbuf_acks(struct sk_buff *buf)
 {
-	return (u32)(unsigned long)buf_handle(buf);
+	return (u32)(unsigned long)(char *)buf_handle(buf);
 }
 
 static void bcbuf_set_acks(struct sk_buff *buf, u32 acks)
@@ -171,6 +173,17 @@ static void bclink_update_last_sent(struct tipc_node *node, u32 seqno)
 }
 
 /**
+ * tipc_bclink_retransmit_to - get most recent node to request retransmission
+ *
+ * Called with bc_lock locked
+ */
+
+struct tipc_node *tipc_bclink_retransmit_to(void)
+{
+	return bclink->retransmit_to;
+}
+
+ /**
  * bclink_retransmit_pkt - retransmit broadcast packets
  * @after: sequence number of last packet to *not* retransmit
  * @to: sequence number of last packet to retransmit
@@ -203,14 +216,43 @@ void tipc_bclink_acknowledge(struct tipc_node *n_ptr, u32 acked)
 	struct sk_buff *next;
 	unsigned int released = 0;
 
-	if (less_eq(acked, n_ptr->bclink.acked))
-		return;
-
 	spin_lock_bh(&bc_lock);
 
-	/* Skip over packets that node has previously acknowledged */
+	/* Bail out if tx queue is empty (no clean up is required) */
 
 	crs = bcl->first_out;
+	if (!crs)
+		goto exit;
+
+	/* Determine which messages need to be acknowledged */
+
+	if (acked == INVALID_LINK_SEQ) {
+
+		/*
+		 * Contact with specified node has been lost, so need to
+		 * acknowledge sent messages only (if other nodes still exist)
+		 * or both sent and unsent messages (otherwise)
+		 */
+
+		if (bclink->bcast_nodes.count)
+			acked = bcl->fsm_msg_cnt;
+		else
+			acked = bcl->next_out_no;
+	} else {
+
+		/*
+		 * Bail out if specified sequence number does not correspond
+		 * to a message that has been sent and not yet acknowledged
+		 */
+
+		if (less(acked, buf_seqno(crs)) ||
+		    less(bcl->fsm_msg_cnt, acked) ||
+		    less_eq(acked, n_ptr->bclink.acked))
+			goto exit;
+	}
+
+	/* Skip over packets that node has previously acknowledged */
+
 	while (crs && less_eq(buf_seqno(crs), n_ptr->bclink.acked)) {
 		crs = crs->next;
 	}
@@ -219,7 +261,15 @@ void tipc_bclink_acknowledge(struct tipc_node *n_ptr, u32 acked)
 
 	while (crs && less_eq(buf_seqno(crs), acked)) {
 		next = crs->next;
-		bcbuf_decr_acks(crs);
+
+		if (crs != bcl->next_out)
+			bcbuf_decr_acks(crs);
+		else {
+			bcbuf_set_acks(crs, 0);
+			bcl->next_out = next;
+			bclink_set_last_sent();
+		}
+
 		if (bcbuf_acks(crs) == 0) {
 			bcl->first_out = next;
 			bcl->out_queue_size--;
@@ -238,6 +288,7 @@ void tipc_bclink_acknowledge(struct tipc_node *n_ptr, u32 acked)
 	}
 	if (unlikely(released && !list_empty(&bcl->waiting_ports)))
 		tipc_link_wakeup_ports(bcl, 0);
+exit:
 	spin_unlock_bh(&bc_lock);
 }
 
@@ -292,12 +343,11 @@ void tipc_bclink_update_link_state(struct tipc_node *n_ptr, u32 last_sent)
 				 ? buf_seqno(n_ptr->bclink.deferred_head) - 1
 				 : n_ptr->bclink.last_sent);
 
-		tipc_bearer_send(&bcbearer->bearer, buf, NULL);
-		buf_discard(buf);
-
 		spin_lock_bh(&bc_lock);
+		tipc_bearer_send(&bcbearer->bearer, buf, NULL);
 		bcl->stats.sent_nacks++;
 		spin_unlock_bh(&bc_lock);
+		buf_discard(buf);
 
 		n_ptr->bclink.oos_state++;
 	}
@@ -322,7 +372,7 @@ static void bclink_peek_nack(struct tipc_msg *msg)
 
 	tipc_node_lock(n_ptr);
 
-	if (tipc_node_is_up(n_ptr) && n_ptr->bclink.supported &&
+	if (n_ptr->bclink.supported &&
 	    (n_ptr->bclink.last_in != n_ptr->bclink.last_sent) &&
 	    (n_ptr->bclink.last_in == msg_bcgap_after(msg)))
 		n_ptr->bclink.oos_state = 2;
@@ -347,21 +397,43 @@ int tipc_bclink_send_msg(struct sk_buff *buf)
 	}
 
 	res = tipc_link_send_buf(bcl, buf);
-	if (unlikely(res == -ELINKCONG))
-		buf_discard(buf);
-	else
+	if (likely(res >= 0)) {
 		bclink_set_last_sent();
-
-	if (bcl->out_queue_size > bcl->stats.max_queue_sz)
-		bcl->stats.max_queue_sz = bcl->out_queue_size;
-	bcl->stats.queue_sz_counts++;
-	bcl->stats.accu_queue_sz += bcl->out_queue_size;
+		bcl->stats.queue_sz_counts++;
+		bcl->stats.accu_queue_sz += bcl->out_queue_size;
+	}
 exit:
 	spin_unlock_bh(&bc_lock);
 	return res;
 }
 
 /**
+ * bclink_accept_pkt - accept an incoming, in-sequence broadcast packet
+ *
+ * Called with both sending node's lock and bc_lock taken.
+ */
+
+static void bclink_accept_pkt(struct tipc_node *node, u32 seqno)
+{
+	bclink_update_last_sent(node, seqno);
+	node->bclink.last_in = seqno;
+	node->bclink.oos_state = 0;
+	bcl->stats.recv_info++;
+	
+	/*
+	 * Unicast an ACK periodically, ensuring that
+	 * all nodes in the cluster don't ACK at the same time
+	 */
+
+	if (((seqno - tipc_own_addr) % TIPC_MIN_LINK_WIN) == 0) {
+	        tipc_link_send_proto_msg(
+	                node->active_links[node->elm.addr & 1],
+			STATE_MSG, 0, 0, 0, 0, 0);
+	        bcl->stats.sent_acks++;
+	}
+}
+
+/**
  * tipc_bclink_recv_pkt - receive a broadcast packet, and deliver upwards
  *
  * tipc_net_lock is read_locked, no other locks set
@@ -374,6 +446,7 @@ void tipc_bclink_recv_pkt(struct sk_buff *buf)
 	u32 seqno;
 	u32 next_in;
 	int deferred;
+	int ret;
 
 #if (TIPC_BCAST_LOSS_RATE)
 	static int rx_count = 0;
@@ -395,7 +468,7 @@ void tipc_bclink_recv_pkt(struct sk_buff *buf)
 		goto exit;
 
 	tipc_node_lock(node);
-	if (unlikely(!tipc_node_is_up(node) || !node->bclink.supported))
+	if (unlikely(!node->bclink.supported))
 		goto unlock;
 
 	/* Handle broadcast protocol message */
@@ -406,9 +479,7 @@ void tipc_bclink_recv_pkt(struct sk_buff *buf)
 			tipc_node_unlock(node);
 			spin_lock_bh(&bc_lock);
 			bcl->stats.recv_nacks++;
-			/* remember retransmit requester */
-			bcl->owner->node_list.next = 
-				(struct list_head *)node;
+			bclink->retransmit_to = node;
 			bclink_retransmit_pkt(msg_bcgap_after(msg),
 					      msg_bcgap_to(msg));
 			spin_unlock_bh(&bc_lock);
@@ -425,42 +496,32 @@ void tipc_bclink_recv_pkt(struct sk_buff *buf)
 	next_in = mod(node->bclink.last_in + 1);
 
 	if (seqno == next_in) {
-		bclink_update_last_sent(node, seqno);
 receive:
-		node->bclink.last_in = seqno;
-		node->bclink.oos_state = 0;
-
-		spin_lock_bh(&bc_lock);
-		bcl->stats.recv_info++;
-
-		/*
-		 * Unicast an ACK periodically, ensuring that
-		 * all nodes in the cluster don't ACK at the same time
-		 */
-
-		if (((seqno - tipc_own_addr) % TIPC_MIN_LINK_WIN) == 0) {
-			tipc_link_send_proto_msg(
-				node->active_links[node->elm.addr & 1],
-				STATE_MSG, 0, 0, 0, 0, 0, 0);
-			bcl->stats.sent_acks++;
-		}
-
 		/* Deliver message to destination */
 
 		if (likely(msg_isdata(msg))) {
+			spin_lock_bh(&bc_lock);
+			bclink_accept_pkt(node, seqno);
 			spin_unlock_bh(&bc_lock);
 			tipc_node_unlock(node);
 			tipc_port_recv_mcast(buf, NULL);
 		} else if (msg_user(msg) == MSG_BUNDLER) {
+			spin_lock_bh(&bc_lock);
+			bclink_accept_pkt(node, seqno);
 			bcl->stats.recv_bundles++;
 			bcl->stats.recv_bundled += msg_msgcnt(msg);
 			spin_unlock_bh(&bc_lock);
 			tipc_node_unlock(node);
 			tipc_link_recv_bundle(buf);
 		} else if (msg_user(msg) == MSG_FRAGMENTER) {
+			ret = tipc_link_recv_fragment(&node->bclink.defragm,
+						      &buf, &msg);
+			if (ret < 0)
+				goto unlock;
+			spin_lock_bh(&bc_lock);
+			bclink_accept_pkt(node, seqno);
 			bcl->stats.recv_fragments++;
-			if (tipc_link_recv_fragment(&node->bclink.defragm,
-						    &buf, &msg)) {
+			if (ret > 0) {
 				bcl->stats.recv_fragmented++;
 				msg_set_destnode_cache(msg, tipc_own_addr);
 			}
@@ -468,14 +529,20 @@ receive:
 			tipc_node_unlock(node);
 			tipc_net_route_msg(buf);
 		} else if (msg_user(msg) == NAME_DISTRIBUTOR) {
+			spin_lock_bh(&bc_lock);
+			bclink_accept_pkt(node, seqno);
 			spin_unlock_bh(&bc_lock);
 			tipc_node_unlock(node);
 			tipc_named_recv(buf);
 		} else if (msg_user(msg) == ROUTE_DISTRIBUTOR) {
+			spin_lock_bh(&bc_lock);
+			bclink_accept_pkt(node, seqno);
 			spin_unlock_bh(&bc_lock);
 			tipc_node_unlock(node);
 			tipc_route_recv(buf);
 		} else {
+			spin_lock_bh(&bc_lock);
+			bclink_accept_pkt(node, seqno);
 			spin_unlock_bh(&bc_lock);
 			tipc_node_unlock(node);
 			tipc_net_route_msg(buf);
@@ -704,7 +771,7 @@ void tipc_bcbearer_push(void)
 
 #ifdef CONFIG_TIPC_CONFIG_SERVICE
 
-int tipc_bclink_stats(char *buf, const u32 buf_size)
+size_t tipc_bclink_stats(char *buf, const size_t buf_size)
 {
 	struct print_buf pb;
 
@@ -804,7 +871,7 @@ int tipc_bclink_init(void)
 	tipc_link_set_queue_limits(bcl, BCLINK_WIN_DEFAULT);
 	bcl->b_ptr = &bcbearer->bearer;
 	bcl->state = WORKING_WORKING;
-	sprintf(bcl->name, tipc_bclink_name);
+	strlcpy(bcl->name, tipc_bclink_name, TIPC_MAX_LINK_NAME);
 
 	if (BCLINK_LOG_BUF_SIZE) {
 		char *pb = kmalloc(BCLINK_LOG_BUF_SIZE, GFP_ATOMIC);
@@ -876,7 +943,7 @@ void tipc_nmap_remove(struct tipc_node_map *nm_ptr, u32 node)
 void tipc_nmap_diff(struct tipc_node_map *nm_a, struct tipc_node_map *nm_b,
 		    struct tipc_node_map *nm_diff)
 {
-	int stop = sizeof(nm_a->map) / sizeof(u32);
+	int stop = ARRAY_SIZE(nm_a->map);
 	int w;
 	int b;
 	u32 map;
diff --git a/net/tipc/tipc_bcast.h b/net/tipc/tipc_bcast.h
index e8b5db3..2e668d1 100644
--- a/net/tipc/tipc_bcast.h
+++ b/net/tipc/tipc_bcast.h
@@ -2,7 +2,7 @@
  * net/tipc/tipc_bcast.h: Include file for TIPC broadcast code
  *
  * Copyright (c) 2003-2006, Ericsson AB
- * Copyright (c) 2005-2008, Wind River Systems
+ * Copyright (c) 2005-2008, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -70,7 +70,7 @@ struct port_list {
 
 struct tipc_node;
 
-extern char tipc_bclink_name[];
+extern const char tipc_bclink_name[];
 
 
 void tipc_nmap_add(struct tipc_node_map *nm_ptr, u32 node);
@@ -91,13 +91,14 @@ int  tipc_bclink_init(void);
 void tipc_bclink_stop(void);
 void tipc_bclink_add_node(u32 addr);
 void tipc_bclink_remove_node(u32 addr);
+struct tipc_node *tipc_bclink_retransmit_to(void);
 void tipc_bclink_acknowledge(struct tipc_node *n_ptr, u32 acked);
 int  tipc_bclink_send_msg(struct sk_buff *buf);
 void tipc_bclink_recv_pkt(struct sk_buff *buf);
 u32  tipc_bclink_get_last_sent(void);
 u32  tipc_bclink_acks_missing(struct tipc_node *n_ptr);
 void tipc_bclink_update_link_state(struct tipc_node *n_ptr, u32 last_sent);
-int  tipc_bclink_stats(char *stats_buf, const u32 buf_size);
+size_t tipc_bclink_stats(char *stats_buf, const size_t buf_size);
 int  tipc_bclink_reset_stats(void);
 int  tipc_bclink_set_queue_limits(u32 limit);
 void tipc_bcbearer_sort(void);
diff --git a/net/tipc/tipc_bearer.c b/net/tipc/tipc_bearer.c
index 9f2b227..bcb29e6 100644
--- a/net/tipc/tipc_bearer.c
+++ b/net/tipc/tipc_bearer.c
@@ -2,7 +2,7 @@
  * net/tipc/tipc_bearer.c: TIPC bearer code
  *
  * Copyright (c) 1996-2006, Ericsson AB
- * Copyright (c) 2004-2008, Wind River Systems
+ * Copyright (c) 2004-2008, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -50,7 +50,9 @@
 static struct tipc_media *media_list[MAX_MEDIA];
 static u32 media_count = 0;
 
-struct bearer tipc_bearers[TIPC_MAX_BEARERS];
+struct bearer *tipc_bearers = NULL;
+
+static void bearer_disable(struct bearer *b_ptr);
 
 /**
  * media_name_valid - validate media name
@@ -60,7 +62,7 @@ struct bearer tipc_bearers[TIPC_MAX_BEARERS];
 
 static int media_name_valid(const char *name)
 {
-	u32 len;
+	size_t len;
 
 	len = strlen(name);
 	if ((len + 1) > TIPC_MAX_MEDIA_NAME)
@@ -111,17 +113,14 @@ int  tipc_register_media(struct tipc_media *m_ptr)
 
 	write_lock_bh(&tipc_net_lock);
 
-	if (tipc_mode != TIPC_NET_MODE) {
-		goto exit;
-	}
 	if (m_ptr->media_id == TIPC_MEDIA_ID_INVALID) {
 		goto exit;
 	}
 	if (!media_name_valid(m_ptr->name)) {
 		goto exit;
 	}
-	if ((m_ptr->priority < TIPC_MIN_LINK_PRI) &&
-	    (m_ptr->priority > TIPC_MAX_LINK_PRI)) {
+	assert(TIPC_MIN_LINK_PRI == 0);
+	if (m_ptr->priority > TIPC_MAX_LINK_PRI) {
 		goto exit;
 	}
 	if ((m_ptr->tolerance < TIPC_MIN_LINK_TOL) || 
@@ -227,8 +226,8 @@ static int bearer_name_validate(const char *name,
 	char name_copy[TIPC_MAX_BEARER_NAME];
 	char *media_name;
 	char *if_name;
-	u32 media_len;
-	u32 if_len;
+	size_t media_len;
+	size_t if_len;
 
 	/* copy bearer name & ensure length is OK */
 
@@ -339,85 +338,33 @@ struct sk_buff *tipc_bearer_get_names(void)
 
 #endif
 
-void tipc_bearer_add_dest(struct bearer *b_ptr, u32 dest,
-			  struct tipc_media_addr *maddr)
+void tipc_bearer_add_dest(struct bearer *b_ptr, u32 dest)
 {
 	struct discoverer *d_ptr;
-	struct discoverer *temp_d_ptr;
 
 	if (in_own_cluster(dest)) {
 		tipc_nmap_add(&b_ptr->nodes, dest);
 		tipc_bcbearer_sort();
 	}
 
-	list_for_each_entry_safe(d_ptr, temp_d_ptr, &b_ptr->disc_list, disc_list) {
-		if (tipc_in_scope(d_ptr->domain, dest)) {
-			d_ptr->num_nodes++;
-			/* tipc_disc_update(d_ptr); */
-		}
-	}
+	d_ptr = b_ptr->disc_obj;
+	if (tipc_in_scope(d_ptr->domain, dest))
+		d_ptr->num_nodes++;
 }
 
-void tipc_bearer_remove_dest(struct bearer *b_ptr, u32 dest,
-			  struct tipc_media_addr *maddr)
+void tipc_bearer_remove_dest(struct bearer *b_ptr, u32 dest)
 {
 	struct discoverer *d_ptr;
-	struct discoverer *temp_d_ptr;
 
 	if (in_own_cluster(dest)) {
 		tipc_nmap_remove(&b_ptr->nodes, dest);
 		tipc_bcbearer_sort();
 	}
 
-	list_for_each_entry_safe(d_ptr, temp_d_ptr, &b_ptr->disc_list, disc_list) {
-		if (tipc_in_scope(d_ptr->domain, dest)) {
-			d_ptr->num_nodes--;
-			tipc_disc_update(d_ptr);
-		}
-	}
-}
-
-
-/*  
- * tipc_bearer_send_discover: 'Individual' discoverer's, i.e. those having a
- * fully specified address, are controlled by the corresponding link's timer,
- * instead of the discovery timer.
- */
-
-void tipc_bearer_send_discover(struct bearer *b_ptr, u32 dest)
-{
-	/* TODO: This needs to be reworked */
-
-	struct discoverer *d_ptr;
-	struct discoverer *temp_d_ptr;
-
-	list_for_each_entry_safe(d_ptr, temp_d_ptr, &b_ptr->disc_list, disc_list) {
-		if (d_ptr->domain == dest) {
-			tipc_disc_send_msg(d_ptr);
-			break;
-		}
-	}
-}
-
-/**
- * tipc_bearer_remove_discoverer(): 
- * Remove the discovery item for 'dest' from bearer's list.
- * Note: bearer item is locked. tipc_net_lock is write_locked.
- */
-
-void tipc_bearer_remove_discoverer(struct bearer *b_ptr, u32 dest)
-{
-	struct discoverer *d_ptr;
-	struct discoverer *temp_d_ptr;
-
-	if (in_own_cluster(dest))
-		return;
-
-	list_for_each_entry_safe(d_ptr, temp_d_ptr, &b_ptr->disc_list, disc_list) {
-		if (tipc_in_scope(dest, d_ptr->domain)) {
-			tipc_disc_deactivate(d_ptr);
-			tipc_disc_delete(d_ptr);
-		}
+	d_ptr = b_ptr->disc_obj;
+	if (tipc_in_scope(d_ptr->domain, dest)) {
+		d_ptr->num_nodes--;
+		tipc_disc_update(d_ptr);
 	}
 }
 
@@ -564,12 +511,13 @@ int tipc_enable_bearer(const char *name, u32 disc_domain, u32 priority)
 		warn("Bearer <%s> rejected, illegal name\n", name);
 		return -EINVAL;
 	}
-	if (!tipc_addr_domain_valid(disc_domain)) {
+	if (!tipc_addr_domain_valid(disc_domain) ||
+	    (disc_domain == tipc_own_addr)) {
 		warn("Bearer <%s> rejected, illegal discovery domain\n", name);
 		return -EINVAL;
 	}
-	if ((priority < TIPC_MIN_LINK_PRI ||
-	     priority > TIPC_MAX_LINK_PRI) &&
+	assert(TIPC_MIN_LINK_PRI == 0);
+	if ((priority > TIPC_MAX_LINK_PRI) &&
 	    (priority != TIPC_MEDIA_LINK_PRI)) {
 		warn("Bearer <%s> rejected, illegal priority\n", name);
 		return -EINVAL;
@@ -581,7 +529,7 @@ int tipc_enable_bearer(const char *name, u32 disc_domain, u32 priority)
 	if (!m_ptr) {
 		warn("Bearer <%s> rejected, media <%s> not registered\n", name,
 		     b_name.media_name);
-		goto failed;
+		goto exit;
 	}
 	if (priority == TIPC_MEDIA_LINK_PRI)
 		priority = m_ptr->priority;
@@ -596,14 +544,14 @@ restart:
 		}
 		if (!strcmp(name, tipc_bearers[i].publ.name)) {
 			warn("Bearer <%s> rejected, already enabled\n", name);
-			goto failed;
+			goto exit;
 		}
 		if ((tipc_bearers[i].priority == priority) &&
 		    (++with_this_prio > 2)) {
 			if (priority-- == 0) {
 				warn("Bearer <%s> rejected, duplicate priority\n",
 				     name);
-				goto failed;
+				goto exit;
 			}
 			warn("Bearer <%s> priority adjustment required %u->%u\n",
 			     name, priority + 1, priority);
@@ -613,7 +561,7 @@ restart:
 	if (bearer_id >= TIPC_MAX_BEARERS) {
 		warn("Bearer <%s> rejected, bearer limit reached (%u)\n", 
 		     name, TIPC_MAX_BEARERS);
-		goto failed;
+		goto exit;
 	}
 
 	b_ptr = &tipc_bearers[bearer_id];
@@ -634,24 +582,25 @@ restart:
 	b_ptr->media = m_ptr;
 	b_ptr->tolerance = m_ptr->tolerance;
 	b_ptr->window = m_ptr->window;
-	b_ptr->net_plane = bearer_id + 'A';
+	b_ptr->net_plane = (unsigned char)(bearer_id + 'A');
 
 	INIT_LIST_HEAD(&b_ptr->cong_links);
 	INIT_LIST_HEAD(&b_ptr->links);
-	INIT_LIST_HEAD(&b_ptr->disc_list);
-	if (disc_domain != tipc_own_addr) {
-		tipc_disc_create(b_ptr, &m_ptr->bcast_addr, disc_domain);
-	}
 	spin_lock_init(&b_ptr->publ.lock);
 	b_ptr->active = 1;
 
-	write_unlock_bh(&tipc_net_lock);
+	res = tipc_disc_create(b_ptr, &m_ptr->bcast_addr, disc_domain);
+	if (res) {
+		bearer_disable(b_ptr);
+		warn("Bearer <%s> rejected, discovery object creation failed\n", 
+		     name);
+		goto exit;
+	}
 
 	tipc_addr_string_fill(addr_string, disc_domain);
 	info("Enabled bearer <%s>, discovery domain %s, priority %u\n",
 	     name, addr_string, priority);
-	return 0;
-failed:
+exit:
 	write_unlock_bh(&tipc_net_lock);
 	return res;
 }
@@ -678,6 +627,7 @@ int tipc_block_bearer(const char *name)
 	info("Blocking bearer <%s>\n", name);
 	spin_lock_bh(&b_ptr->publ.lock);
 	b_ptr->publ.blocked = 1;
+	list_splice_init(&b_ptr->cong_links, &b_ptr->links);
 	list_for_each_entry_safe(l_ptr, temp_l_ptr, &b_ptr->links, link_list) {
 		struct tipc_node *n_ptr = l_ptr->owner;
 
@@ -696,32 +646,24 @@ int tipc_block_bearer(const char *name)
  * Note: This routine assumes caller holds tipc_net_lock.
  */
 
-static int bearer_disable(struct bearer *b_ptr)
+static void bearer_disable(struct bearer *b_ptr)
 {
 	struct link *l_ptr;
 	struct link *temp_l_ptr;
-	struct discoverer *d_ptr;
-	struct discoverer *temp_d_ptr;
 
-	info("Disabling bearer <%s>\n", b_ptr->publ.name);
 	spin_lock_bh(&b_ptr->publ.lock);
 	b_ptr->publ.blocked = 1;
 	b_ptr->media->disable_bearer(&b_ptr->publ);
+	list_splice_init(&b_ptr->cong_links, &b_ptr->links);
 	list_for_each_entry_safe(l_ptr, temp_l_ptr, &b_ptr->links, link_list) {
 		tipc_link_delete(l_ptr);
 	}
 	spin_unlock_bh(&b_ptr->publ.lock);
 
-	/* Safe to delete discovery struct here. Bearer is inactive now */
-
-	list_for_each_entry_safe(d_ptr, temp_d_ptr, &b_ptr->disc_list, disc_list) {
-		tipc_disc_deactivate(d_ptr);
-		tipc_disc_delete(d_ptr);
-	}
+	tipc_disc_delete(b_ptr->disc_obj);
 
 	spin_lock_term(&b_ptr->publ.lock); 
 	memset(b_ptr, 0, sizeof(struct bearer));
-	return 0;
 }
 
 int tipc_disable_bearer(const char *name)
@@ -736,22 +678,49 @@ int tipc_disable_bearer(const char *name)
 		res = -EINVAL;
 	}
 	else {
-		res = bearer_disable(b_ptr);
+		info("Disabling bearer <%s>\n", b_ptr->publ.name);
+		bearer_disable(b_ptr);
+		res = 0;
 	}
 	write_unlock_bh(&tipc_net_lock);
 	return res;
 }
 
 
+int tipc_bearer_init(void)
+{
+	int res;
+
+	write_lock_bh(&tipc_net_lock);
+	tipc_bearers = kcalloc(TIPC_MAX_BEARERS, sizeof(struct bearer), GFP_ATOMIC);
+	if (tipc_bearers) {
+		res = 0;
+	} else {
+		kfree(tipc_bearers);
+		tipc_bearers = NULL;
+		res = -ENOMEM;
+	}
+	write_unlock_bh(&tipc_net_lock);
+	return res;
+}
 
 void tipc_bearer_stop(void)
 {
+	struct bearer *b_ptr;
 	u32 i;
 
+	if (!tipc_bearers)
+		return;
+
 	for (i = 0; i < TIPC_MAX_BEARERS; i++) {
-		if (tipc_bearers[i].active)
-			bearer_disable(&tipc_bearers[i]);
+		b_ptr = &tipc_bearers[i];
+		if (b_ptr->active) {
+			info("Disabling bearer <%s>\n", b_ptr->publ.name);
+			bearer_disable(b_ptr);
+		}
 	}
+	kfree(tipc_bearers);
+	tipc_bearers = NULL;
 	media_count = 0;
 }
 
diff --git a/net/tipc/tipc_bearer.h b/net/tipc/tipc_bearer.h
index e80e408..0fa11a9 100644
--- a/net/tipc/tipc_bearer.h
+++ b/net/tipc/tipc_bearer.h
@@ -2,7 +2,7 @@
  * net/tipc/tipc_bearer.h: Include file for TIPC bearer code
  * 
  * Copyright (c) 1996-2006, Ericsson AB
- * Copyright (c) 2005-2008, Wind River Systems
+ * Copyright (c) 2005-2008, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -49,7 +49,7 @@
  * @window: default window size for bearer
  * @tolerance: default link tolerance for bearer
  * @identity: array index of this bearer within TIPC bearer array
- * @disc_list: list of neighbor discovery objects
+ * @disc_obj: pointer to neighbor discovery object associated with bearer
  * @links: list of non-congested links associated with bearer
  * @cong_links: list of congested links associated with bearer
  * @continue_count: # of times bearer has resumed after congestion or blocking
@@ -66,13 +66,13 @@ struct bearer {
 	u32 window;
 	u32 tolerance;
 	u32 identity;
-	struct list_head disc_list;
+	struct discoverer *disc_obj;
 	struct list_head links;
 	struct list_head cong_links;
 	u32 continue_count;
 	int in_use;
 	int active;
-	char net_plane;
+	unsigned char net_plane;
 	struct tipc_node_map nodes;
 };
 
@@ -83,7 +83,7 @@ struct bearer_name {
 
 struct link;
 
-extern struct bearer tipc_bearers[];
+extern struct bearer *tipc_bearers;
 
 int tipc_media_set_priority(const char *name, u32 new_value);
 int tipc_media_set_window(const char *name, u32 new_value);
@@ -91,19 +91,16 @@ void tipc_media_addr_printf(struct print_buf *pb, struct tipc_media_addr *a);
 struct sk_buff *tipc_media_get_names(void);
 
 struct sk_buff *tipc_bearer_get_names(void);
-void tipc_bearer_add_dest(struct bearer *b_ptr, u32 dest,
-			  struct tipc_media_addr *maddr);
-void tipc_bearer_remove_dest(struct bearer *b_ptr, u32 dest,
-			     struct tipc_media_addr *maddr);
-void tipc_bearer_remove_discoverer(struct bearer *b_ptr, u32 dest);
+void tipc_bearer_add_dest(struct bearer *b_ptr, u32 dest);
+void tipc_bearer_remove_dest(struct bearer *b_ptr, u32 dest);
 void tipc_bearer_schedule(struct bearer *b_ptr, struct link *l_ptr);
 struct bearer *tipc_bearer_find(const char *name);
 struct tipc_media *tipc_media_find_name(const char *name);
 int tipc_bearer_resolve_congestion(struct bearer *b_ptr, struct link *l_ptr);
 int tipc_bearer_congested(struct bearer *b_ptr, struct link *l_ptr);
+int tipc_bearer_init(void);
 void tipc_bearer_stop(void);
 void tipc_bearer_lock_push(struct bearer *b_ptr);
-void tipc_bearer_send_discover(struct bearer *b_ptr, u32 dest);
 
 /**
  * tipc_bearer_send- sends buffer to destination over bearer
diff --git a/net/tipc/tipc_cfgsrv.c b/net/tipc/tipc_cfgsrv.c
index 3308585..5f6f5be 100644
--- a/net/tipc/tipc_cfgsrv.c
+++ b/net/tipc/tipc_cfgsrv.c
@@ -2,7 +2,7 @@
  * net/tipc/tipc_cfgsrv.c: TIPC configuration service code
  *
  * Copyright (c) 2002-2006, Ericsson AB
- * Copyright (c) 2004-2007, Wind River Systems
+ * Copyright (c) 2004-2007, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -58,8 +58,8 @@ static struct manager mng = { 0 };
 static DEFINE_SPINLOCK(config_lock);
 
 static const void *req_tlv_area;	/* request message TLV area */
-static int req_tlv_space;		/* request message TLV area size */
-static int rep_headroom;		/* reply message headroom to use */
+static u32 req_tlv_space;		/* request message TLV area size */
+static u32 rep_headroom;		/* reply message headroom to use */
 
 
 struct sk_buff *tipc_cfg_reply_alloc(int payload_size)
@@ -73,7 +73,7 @@ struct sk_buff *tipc_cfg_reply_alloc(int payload_size)
 }
 
 int tipc_cfg_append_tlv(struct sk_buff *buf, int tlv_type,
-			void *tlv_data, int tlv_data_size)
+			void *tlv_data, size_t tlv_data_size)
 {
 	struct tlv_desc *tlv = (struct tlv_desc *)skb_tail_pointer(buf);
 	int new_tlv_space = TLV_SPACE(tlv_data_size);
@@ -107,7 +107,7 @@ struct sk_buff *tipc_cfg_reply_unsigned_type(u16 tlv_type, u32 value)
 struct sk_buff *tipc_cfg_reply_string_type(u16 tlv_type, char *string)
 {
 	struct sk_buff *buf;
-	int string_len = strlen(string) + 1;
+	size_t string_len = strlen(string) + 1;
 
 	buf = tipc_cfg_reply_alloc(TLV_SPACE(string_len));
 	if (buf)
@@ -116,144 +116,6 @@ struct sk_buff *tipc_cfg_reply_string_type(u16 tlv_type, char *string)
 }
 
 
-#if 0
-
-/* Now obsolete code for handling commands not yet implemented the new way */
-
-/*
- * Some of this code assumed that the manager structure contains two added
- * fields:
- *	u32 link_subscriptions;
- *	struct list_head link_subscribers;
- * which are currently not present.  These fields may need to be re-introduced
- * if and when support for link subscriptions is added.
- */
-
-struct subscr_data {
-	char usr_handle[8];
-	u32 domain;
-	u32 port_ref;
-	struct list_head subd_list;
-};
-
-
-void tipc_cfg_link_event(u32 addr, char *name, int up)
-{
-	/* TIPC DOESN'T HANDLE LINK EVENT SUBSCRIPTIONS AT THE MOMENT */
-}
-
-int tipc_cfg_cmd(const struct tipc_cmd_msg * msg,
-		 char *data,
-		 u32 sz,
-		 u32 *ret_size,
-		 struct tipc_portid *orig)
-{
-	int rv = -EINVAL;
-	u32 cmd = msg->cmd;
-
-	*ret_size = 0;
-	switch (cmd) {
-	case TIPC_REMOVE_LINK:
-	case TIPC_CMD_BLOCK_LINK:
-	case TIPC_CMD_UNBLOCK_LINK:
-		if (!cfg_check_connection(orig))
-			rv = link_control(msg->argv.link_name, msg->cmd, 0);
-		break;
-	case TIPC_ESTABLISH:
-		{
-			int connected;
-
-			tipc_isconnected(mng.conn_port_ref, &connected);
-			if (connected || !orig) {
-				rv = TIPC_FAILURE;
-				break;
-			}
-			rv = tipc_connect2port(mng.conn_port_ref, orig);
-			if (rv == TIPC_OK)
-				orig = 0;
-			break;
-		}
-	case TIPC_GET_PEER_ADDRESS:
-		*ret_size = link_peer_addr(msg->argv.link_name, data, sz);
-		break;
-	default: {}
-	}
-	if (*ret_size)
-		rv = TIPC_OK;
-	return rv;
-}
-
-static void cfg_cmd_event(struct tipc_cmd_msg *msg,
-			  char *data,
-			  u32 sz,
-			  struct tipc_portid const *orig)
-{
-	int rv = -EINVAL;
-	struct tipc_cmd_result_msg rmsg;
-	struct iovec msg_sect[2];
-	int *arg;
-
-	msg->cmd = ntohl(msg->cmd);
-
-	cfg_prepare_res_msg(msg->cmd, msg->usr_handle, rv, &rmsg, msg_sect,
-			    data, 0);
-	if (ntohl(msg->magic) != TIPC_MAGIC)
-		goto exit;
-
-	switch (msg->cmd) {
-	case TIPC_CREATE_LINK:
-		if (!cfg_check_connection(orig))
-			rv = disc_create_link(&msg->argv.create_link);
-		break;
-	case TIPC_LINK_SUBSCRIBE:
-		{
-			struct subscr_data *sub;
-
-			if (mng.link_subscriptions > 64)
-				break;
-			sub = (struct subscr_data *)kmalloc(sizeof(*sub),
-							    GFP_ATOMIC);
-			if (sub == NULL) {
-				warn("Memory squeeze; dropped remote link subscription\n");
-				break;
-			}
-			INIT_LIST_HEAD(&sub->subd_list);
-			tipc_createport(mng.user_ref,
-					(void *)sub,
-					TIPC_HIGH_IMPORTANCE,
-					0,
-					0,
-					(tipc_conn_shutdown_event)cfg_linksubscr_cancel,
-					0,
-					0,
-					(tipc_conn_msg_event)cfg_linksubscr_cancel,
-					0,
-					&sub->port_ref);
-			if (!sub->port_ref) {
-				kfree(sub);
-				break;
-			}
-			memcpy(sub->usr_handle,msg->usr_handle,
-			       sizeof(sub->usr_handle));
-			sub->domain = msg->argv.domain;
-			list_add_tail(&sub->subd_list, &mng.link_subscribers);
-			tipc_connect2port(sub->port_ref, orig);
-			rmsg.retval = TIPC_OK;
-			tipc_send(sub->port_ref, 2u, msg_sect);
-			mng.link_subscriptions++;
-			return;
-		}
-	default:
-		rv = tipc_cfg_cmd(msg, data, sz, (u32 *)&msg_sect[1].iov_len, orig);
-	}
-exit:
-	rmsg.result_len = htonl(msg_sect[1].iov_len);
-	rmsg.retval = htonl(rv);
-	tipc_cfg_respond(msg_sect, 2u, orig);
-}
-
-#endif
-
 #define MAX_STATS_INFO 2000
 
 static struct sk_buff *tipc_show_stats(void)
@@ -261,7 +123,7 @@ static struct sk_buff *tipc_show_stats(void)
 	struct sk_buff *buf;
 	struct tlv_desc *rep_tlv;
 	struct print_buf pb;
-	int str_len;
+	size_t str_len;
 	u32 value;
 
 	if (!TLV_CHECK(req_tlv_area, req_tlv_space, TIPC_TLV_UNSIGNED))
@@ -465,7 +327,7 @@ static struct sk_buff *cfg_set_max_remotes(void)
 	value = ntohl(*(__be32 *)TLV_DATA(req_tlv_area));
 	if (value == tipc_max_remotes)
 		return tipc_cfg_reply_none();
-	if (value != delimit(value, 0, 255))
+	if (value > 255)
 		return tipc_cfg_reply_error_string(TIPC_CFG_INVALID_VALUE
 						   " (max remotes must be 0-255)");
 	if (tipc_mode == TIPC_NET_MODE)
@@ -495,7 +357,7 @@ static struct sk_buff *cfg_set_netid(void)
 }
 
 struct sk_buff *tipc_cfg_do_cmd(u32 orig_node, u16 cmd, const void *request_area,
-				int request_space, int reply_headroom)
+				u32 request_space, u32 reply_headroom)
 {
 	struct sk_buff *rep_tlv_buf;
 
@@ -562,14 +424,6 @@ struct sk_buff *tipc_cfg_do_cmd(u32 orig_node, u16 cmd, const void *request_area
 	case TIPC_CMD_SHOW_PORTS:
 		rep_tlv_buf = tipc_port_get_ports();
 		break;
-#if 0
-	case TIPC_CMD_SHOW_PORT_STATS:
-		rep_tlv_buf = port_show_stats(req_tlv_area, req_tlv_space);
-		break;
-	case TIPC_CMD_RESET_PORT_STATS:
-		rep_tlv_buf = tipc_cfg_reply_error_string(TIPC_CFG_NOT_SUPPORTED);
-		break;
-#endif
 	case TIPC_CMD_SET_LOG_SIZE:
 		rep_tlv_buf = tipc_log_resize_cmd(req_tlv_area, req_tlv_space);
 		break;
@@ -584,14 +438,6 @@ struct sk_buff *tipc_cfg_do_cmd(u32 orig_node, u16 cmd, const void *request_area
 	case TIPC_CMD_SET_LINK_WINDOW:
 		rep_tlv_buf = tipc_link_cmd_config(req_tlv_area, req_tlv_space, cmd);
 		break;
-#ifdef PROTO_MULTI_DISCOVERY_OBJECT
-	case TIPC_CMD_CREATE_LINK:
-		rep_tlv_buf = tipc_disc_cmd_create_link(req_tlv_area, req_tlv_space);
-		break;
-	case TIPC_CMD_DELETE_LINK:
-		rep_tlv_buf = tipc_link_cmd_delete(req_tlv_area, req_tlv_space);
-		break;
-#endif
 	case TIPC_CMD_ENABLE_BEARER:
 		rep_tlv_buf = cfg_enable_bearer();
 		break;
@@ -699,14 +545,14 @@ static void cfg_named_msg_event(void *userdata,
 	rep_buf = tipc_cfg_do_cmd(orig->node,
 				  ntohs(req_hdr->tcm_type),
 				  msg + sizeof(*req_hdr),
-				  size - sizeof(*req_hdr),
+				  (u32)(size - sizeof(*req_hdr)),
 				  BUF_HEADROOM + MAX_H_SIZE + sizeof(*rep_hdr));
 	if (rep_buf) {
 		skb_push(rep_buf, sizeof(*rep_hdr));
 		rep_hdr = (struct tipc_cfg_msg_hdr *)rep_buf->data;
 		memcpy(rep_hdr, req_hdr, sizeof(*rep_hdr));
 		rep_hdr->tcm_len = htonl(rep_buf->len);
-		rep_hdr->tcm_flags &= htons(~TCM_F_REQUEST);
+		rep_hdr->tcm_flags &= htons((short)(~TCM_F_REQUEST));
 	} else {
 		rep_buf = *buf;
 		*buf = NULL;
@@ -760,11 +606,12 @@ static struct publication *mng_publ = NULL;
 
 int tipc_cfg_init(void)
 {
-	mng_publ = tipc_nametbl_publish_rsv(TIPC_CFG_SRV, tipc_own_addr,
-					    tipc_own_addr, TIPC_CLUSTER_SCOPE,
-					    0, tipc_random);
-	if (mng_publ == NULL)
+	if (tipc_nametbl_publish_rsv(TIPC_CFG_SRV, tipc_own_addr,
+				     tipc_own_addr, TIPC_CLUSTER_SCOPE,
+				     0, tipc_random, &mng_publ) < 0) {
 		err("Unable to create configuration service identifier\n");
+		mng_publ = NULL;
+	}
 	return !mng_publ;
 }
 
diff --git a/net/tipc/tipc_cfgsrv.h b/net/tipc/tipc_cfgsrv.h
index 8a397ab..984437c 100644
--- a/net/tipc/tipc_cfgsrv.h
+++ b/net/tipc/tipc_cfgsrv.h
@@ -2,7 +2,7 @@
  * net/tipc/tipc_cfgsrv.h: Include file for TIPC configuration service code
  *
  * Copyright (c) 2003-2006, Ericsson AB
- * Copyright (c) 2005, Wind River Systems
+ * Copyright (c) 2005, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -44,7 +44,7 @@
 
 struct sk_buff *tipc_cfg_reply_alloc(int payload_size);
 int tipc_cfg_append_tlv(struct sk_buff *buf, int tlv_type,
-			void *tlv_data, int tlv_data_size);
+			void *tlv_data, size_t tlv_data_size);
 struct sk_buff *tipc_cfg_reply_unsigned_type(u16 tlv_type, u32 value);
 struct sk_buff *tipc_cfg_reply_string_type(u16 tlv_type, char *string);
 
@@ -69,8 +69,8 @@ static inline struct sk_buff *tipc_cfg_reply_ultra_string(char *string)
 }
 
 struct sk_buff *tipc_cfg_do_cmd(u32 orig_node, u16 cmd,
-				const void *req_tlv_area, int req_tlv_space,
-				int headroom);
+				const void *req_tlv_area, u32 req_tlv_space,
+				u32 headroom);
 
 int  tipc_cfg_init(void);
 void tipc_cfg_stop(void);
diff --git a/net/tipc/tipc_core.c b/net/tipc/tipc_core.c
index 5e5ec7e..3359786 100644
--- a/net/tipc/tipc_core.c
+++ b/net/tipc/tipc_core.c
@@ -206,10 +206,10 @@ static int __init tipc_init(void)
 	tipc_own_addr = 0;
 	tipc_net_id = delimit(CONFIG_TIPC_NETID, 1, 9999);
 	tipc_remote_management = CONFIG_TIPC_REMOTE_MNG;
-	tipc_max_ports = delimit(CONFIG_TIPC_PORTS, 127, 65536);
-	tipc_max_nodes = delimit(CONFIG_TIPC_NODES, 8, 4095);
-	tipc_max_clusters = delimit(CONFIG_TIPC_CLUSTERS, 1, 4095);
-	tipc_max_zones = delimit(CONFIG_TIPC_ZONES, 1, 255);
+	tipc_max_ports = CONFIG_TIPC_PORTS;
+	tipc_max_nodes = CONFIG_TIPC_NODES;
+	tipc_max_clusters = CONFIG_TIPC_CLUSTERS;
+	tipc_max_zones = CONFIG_TIPC_ZONES;
 	tipc_max_remotes = delimit(CONFIG_TIPC_REMOTES, 0, 255);
 	tipc_max_publications = delimit(CONFIG_TIPC_PUBL, 1, 65535);
 	tipc_max_subscriptions = delimit(CONFIG_TIPC_SUBSCR, 1, 65535);
diff --git a/net/tipc/tipc_core.h b/net/tipc/tipc_core.h
index 8b0f3de..4a9b227 100644
--- a/net/tipc/tipc_core.h
+++ b/net/tipc/tipc_core.h
@@ -2,7 +2,7 @@
  * net/tipc/tipc_core.h: Include file for TIPC global declarations
  *
  * Copyright (c) 2005-2006, Ericsson AB
- * Copyright (c) 2005-2008, Wind River Systems
+ * Copyright (c) 2005-2008, 2010-2011, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -56,11 +56,12 @@
 #include <linux/netdevice.h>
 #include <linux/in.h>
 #include <linux/list.h>
+#include <linux/slab.h>
 #include <linux/version.h>
 #include <linux/vmalloc.h>
 
 
-#define TIPC_MOD_VER "1.7.6"
+#define TIPC_MOD_VER "1.7.7"
 
 /*
  * Spinlock wrappers (lets TIPC common files run unchanged on other OS's)
diff --git a/net/tipc/tipc_dbg.c b/net/tipc/tipc_dbg.c
index 999ab02..30f2e4f 100644
--- a/net/tipc/tipc_dbg.c
+++ b/net/tipc/tipc_dbg.c
@@ -2,7 +2,7 @@
  * net/tipc/tipc_dbg.c: TIPC print buffer routines
  *
  * Copyright (c) 1996-2006, Ericsson AB
- * Copyright (c) 2005-2007, Wind River Systems
+ * Copyright (c) 2005-2007, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -100,7 +100,7 @@ static DEFINE_SPINLOCK(print_lock);
  * becomes a null device that discards anything written to it.
  */
 
-void tipc_printbuf_init(struct print_buf *pb, char *raw, u32 size)
+void tipc_printbuf_init(struct print_buf *pb, char *raw, size_t size)
 {
 	pb->buf = raw;
 	pb->crs = raw;
@@ -151,7 +151,7 @@ int tipc_printbuf_empty(struct print_buf *pb)
  * Returns length of print buffer data string (including trailing NUL)
  */
 
-int tipc_printbuf_validate(struct print_buf *pb)
+size_t tipc_printbuf_validate(struct print_buf *pb)
 {
 	char *err = "\n\n*** PRINT BUFFER OVERFLOW ***\n\n";
 	char *cp_buf;
@@ -187,7 +187,7 @@ int tipc_printbuf_validate(struct print_buf *pb)
 
 void tipc_printbuf_move(struct print_buf *pb_to, struct print_buf *pb_from)
 {
-	int len;
+	size_t len;
 
 	/* Handle the cases where contents can't be moved */
 
@@ -232,8 +232,8 @@ void tipc_printbuf_move(struct print_buf *pb_to, struct print_buf *pb_from)
 
 void tipc_printf(struct print_buf *pb, const char *fmt, ...)
 {
-	int chars_to_add;
-	int chars_left;
+	size_t chars_to_add;
+	size_t chars_left;
 	char save_char;
 
 	spin_lock_bh(&print_lock);
@@ -262,7 +262,7 @@ void tipc_printf(struct print_buf *pb, const char *fmt, ...)
 	}
 
 	if (pb->echo)
-		printk(print_string);
+		printk("%s", print_string);
 
 	spin_unlock_bh(&print_lock);
 }
@@ -275,12 +275,12 @@ void tipc_printf(struct print_buf *pb, const char *fmt, ...)
  * print_to_console - write string of bytes to console in multiple chunks
  */
 
-static void print_to_console(char *crs, int len)
+static void print_to_console(char *crs, size_t len)
 {
-	int rest = len;
+	size_t rest = len;
 
 	while (rest > 0) {
-		int sz = rest < TIPC_PB_MAX_STR ? rest : TIPC_PB_MAX_STR;
+		size_t sz = rest < TIPC_PB_MAX_STR ? rest : TIPC_PB_MAX_STR;
 		char c = crs[sz];
 
 		crs[sz] = 0;
@@ -297,7 +297,7 @@ static void print_to_console(char *crs, int len)
 
 static void printbuf_dump_dbg(struct print_buf *pb)
 {
-	int len;
+	size_t len;
 
 	if (!pb->buf) {
 		printk("*** PRINT BUFFER NOT ALLOCATED ***");
@@ -323,7 +323,7 @@ static void printbuf_dump_dbg(struct print_buf *pb)
 
 void tipc_dump_dbg(struct print_buf *pb, const char *fmt, ...)
 {
-	int len;
+	size_t len;
 
 	if (pb == TIPC_CONS)
 		return;
@@ -352,7 +352,7 @@ void tipc_dump_dbg(struct print_buf *pb, const char *fmt, ...)
  * @log_size: print buffer size to use
  */
 
-int tipc_log_resize(int log_size)
+int tipc_log_resize(size_t log_size)
 {
 	int res = 0;
 
@@ -379,7 +379,7 @@ int tipc_log_resize(int log_size)
  * tipc_log_resize_cmd - reconfigure size of TIPC log buffer
  */
 
-struct sk_buff *tipc_log_resize_cmd(const void *req_tlv_area, int req_tlv_space)
+struct sk_buff *tipc_log_resize_cmd(const void *req_tlv_area, u32 req_tlv_space)
 {
 	u32 value;
 
@@ -387,7 +387,7 @@ struct sk_buff *tipc_log_resize_cmd(const void *req_tlv_area, int req_tlv_space)
 		return tipc_cfg_reply_error_string(TIPC_CFG_TLV_ERROR);
 
 	value = ntohl(*(__be32 *)TLV_DATA(req_tlv_area));
-	if (value != delimit(value, 0, 32768))
+	if (value > 32768)
 		return tipc_cfg_reply_error_string(TIPC_CFG_INVALID_VALUE
 						   " (log size must be 0-32768)");
 	if (tipc_log_resize(value))
@@ -415,7 +415,7 @@ struct sk_buff *tipc_log_dump(void)
 	else {
 		struct tlv_desc *rep_tlv;
 		struct print_buf pb;
-		int str_len;
+		size_t str_len;
 
 		str_len = min(TIPC_LOG->size, 32768u);
 		spin_unlock_bh(&print_lock);
diff --git a/net/tipc/tipc_dbg.h b/net/tipc/tipc_dbg.h
index 1e6e989..bc9303f 100644
--- a/net/tipc/tipc_dbg.h
+++ b/net/tipc/tipc_dbg.h
@@ -2,7 +2,7 @@
  * net/tipc/tipc_dbg.h: Include file for TIPC print buffer routines
  *
  * Copyright (c) 1997-2006, Ericsson AB
- * Copyright (c) 2005-2007, Wind River Systems
+ * Copyright (c) 2005-2007, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -47,7 +47,7 @@
 
 struct print_buf {
 	char *buf;
-	u32 size;
+	size_t size;
 	char *crs;
 	int echo;
 };
@@ -55,19 +55,19 @@ struct print_buf {
 #define TIPC_PB_MIN_SIZE 64	/* minimum size for a print buffer's array */
 #define TIPC_PB_MAX_STR 512	/* max printable string (with trailing NUL) */
 
-void tipc_printbuf_init(struct print_buf *pb, char *buf, u32 size);
+void tipc_printbuf_init(struct print_buf *pb, char *buf, size_t size);
 void tipc_printbuf_reset(struct print_buf *pb);
 int  tipc_printbuf_empty(struct print_buf *pb);
-int  tipc_printbuf_validate(struct print_buf *pb);
+size_t tipc_printbuf_validate(struct print_buf *pb);
 void tipc_printbuf_move(struct print_buf *pb_to, struct print_buf *pb_from);
 
 #ifdef CONFIG_TIPC_CONFIG_SERVICE
-int tipc_log_resize(int log_size);
+int tipc_log_resize(size_t log_size);
 #else
-static inline int tipc_log_resize(int log_size) { return 0; }
+static inline int tipc_log_resize(size_t log_size) { return 0; }
 #endif
 struct sk_buff *tipc_log_resize_cmd(const void *req_tlv_area,
-				    int req_tlv_space);
+				    u32 req_tlv_space);
 struct sk_buff *tipc_log_dump(void);
 
 #endif
diff --git a/net/tipc/tipc_discover.c b/net/tipc/tipc_discover.c
index 093d78c..e1cb5a0 100644
--- a/net/tipc/tipc_discover.c
+++ b/net/tipc/tipc_discover.c
@@ -2,7 +2,7 @@
  * net/tipc/tipc_discover.c: TIPC neighbor discovery code
  * 
  * Copyright (c) 2003-2006, Ericsson AB
- * Copyright (c) 2005-2008, Wind River Systems
+ * Copyright (c) 2005-2008, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -49,122 +49,6 @@
 #define TIPC_DISC_INACTIVE 0xffffffff	/* There is no timer */
 
 
-#ifdef CONFIG_TIPC_CONFIG_SERVICE
-#ifdef PROTO_MULTI_DISCOVERY_OBJECT
-
-/**
- * disc_addr_match - determine if node discovery addresses overlap
- * 
- * See if address pair [ma2,ta2] matches address pair [ma1,ta1] 
- * (i.e. the contents of [ma1,ta1] can be overridden by [ma2,ta2]) 
- *
- * The following rules apply:
- *
- * - Broadcast matches broadcast if ta1 is within scope of ta2 or vice versa
- * - Unicast matches unicast if ma1 is equal to ma2.
- * - Always match if ta1 and ta2 are complete and equal.
- */
- 
-static int disc_addr_match(struct tipc_media_addr *ma1, u32 ta1,
-                           struct tipc_media_addr *ma2, u32 ta2)
-{
-        if (ma2->broadcast && ma1->broadcast) {
-                if (tipc_in_scope(ta1,ta2) || tipc_in_scope(ta1,ta2))
-                        return 1;
-        } 
-        
-        if (!ma2->broadcast && !ma1->broadcast) {
-                if (!memcmp(ma1,ma2,sizeof(struct tipc_media_addr)))
-                        return 1;
-        }
-
-        if (tipc_node(ta1) && (ta1 == ta2))
-                return 1;
-
-        return 0;
-}
-
-struct sk_buff *tipc_disc_cmd_create_link(const void *disc_tlv_area, 
-					  int disc_tlv_space) 
-{
-        char *cmd_str;
-	char cmd[TIPC_MAX_BEARER_NAME + TIPC_MAX_MEDIA_ADDR + TIPC_MAX_ADDR + 1];
-	char *if_name;
-        char *addr_string;
-        struct bearer *b_ptr;
-	struct discoverer *d_ptr;
-	struct discoverer *temp_d_ptr;
-        struct tipc_media_addr media_addr;
-        u32 domain = 0;
-	u32 zone = 0;
-	u32 cluster = 0;
-	u32 node = 0;
-
-	if (!TLV_CHECK(disc_tlv_area, disc_tlv_space, TIPC_TLV_CREATE_LINK))
-                return tipc_cfg_reply_error_string(TIPC_CFG_TLV_ERROR);
-
-        cmd_str = (char *)TLV_DATA(disc_tlv_area);
-        strncpy(cmd, cmd_str, sizeof(cmd));
-
-        /* Find TIPC or media address, second parameter */
-
-        addr_string = strchr(cmd, ',');
-        if (addr_string == NULL)
-                return tipc_cfg_reply_error_string(TIPC_CFG_TLV_ERROR);
-        *addr_string = '\0';
-        addr_string++;
-
-        /* Find bearer, first parameter */
-
-        if_name = cmd;
-        write_lock_bh(&tipc_net_lock);
-        b_ptr = tipc_bearer_find(if_name);
-        if (b_ptr == NULL) 
-                goto error;
-
-        /* If translation to media address fails, try if TIPC address */
-
-        if (b_ptr->media->str2addr(&media_addr, addr_string)) {
-
-                if (sscanf(addr_string,"%u.%u.%u", &zone, &cluster, &node) != 3)
-                        goto error;
-
-                domain = tipc_addr(zone, cluster, node);
-
-                if (!tipc_addr_domain_valid(domain))
-                        goto error;
-
-                memcpy(&media_addr, &b_ptr->media->bcast_addr, sizeof(media_addr));
-        } 
-
-
-        if (in_own_cluster(domain) && !is_slave(domain) && !is_slave(tipc_own_addr))
-                goto error;
-
-        /* 
-         * Check if corresponding discoverers already exist, and remove.
-         */
-
-	list_for_each_entry_safe(d_ptr, temp_d_ptr, &b_ptr->disc_list, disc_list) {
-                if (disc_addr_match(&d_ptr->dest, d_ptr->domain,
-				    &media_addr, domain)) {
-                        tipc_disc_deactivate(d_ptr);
-                        tipc_disc_delete(d_ptr);
-                }
-	}
-
-        if (tipc_disc_create(b_ptr, &media_addr, domain)) {
-                write_unlock_bh(&tipc_net_lock);
-                return tipc_cfg_reply_none();		
-        }
-error:
-        write_unlock_bh(&tipc_net_lock);
-        return tipc_cfg_reply_error_string(TIPC_CFG_TLV_ERROR);
-}
-
-#endif
-#endif
-
 /** 
  * disc_init_msg - initialize a link setup message
  * @type: message type (request or response)
@@ -239,9 +123,8 @@ void tipc_disc_recv_msg(struct sk_buff *buf, struct bearer *b_ptr)
 	u32 signature = msg_node_sig(msg);
 	u32 node_flags = msg_node_flags(msg);
 	struct tipc_node *n_ptr;
-        struct discoverer *d_ptr;
+	int addr_mismatch;
         int link_fully_up;
-	int found_disc;
 
 	b_ptr->media->msg2addr(&media_addr, &msg->hdr[5]);
 	msg_dbg(msg, "RECV:");
@@ -273,25 +156,8 @@ void tipc_disc_recv_msg(struct sk_buff *buf, struct bearer *b_ptr)
 
 	if (!tipc_in_scope(dest, tipc_own_addr))
 		return;
-	found_disc = 0;
-	list_for_each_entry(d_ptr, &b_ptr->disc_list, disc_list) {
-#if 0
-		if (disc_addr_match(&d_ptr->dest, d_ptr->domain,
-				    &media_addr, orig))
-#endif
-		if (tipc_in_scope(d_ptr->domain, orig)) {
-			found_disc = 1;
-			break;
-		}
-	}
-	if (!found_disc)
-		return;
-#if 0
-	if (is_slave(tipc_own_addr) && is_slave(orig))
+	if (!tipc_in_scope(b_ptr->disc_obj->domain, orig))
 		return;
-	if (is_slave(orig) && !in_own_cluster(orig))
-		return;
-#endif
 
         /* We can accept discovery messages from requesting node */
 
@@ -303,76 +169,79 @@ void tipc_disc_recv_msg(struct sk_buff *buf, struct bearer *b_ptr)
         }
         tipc_node_lock(n_ptr);
 
-	/* Don't talk to neighbor during cleanup after last session */
-
-	if (n_ptr->cleanup_required) {
-		tipc_node_unlock(n_ptr);                
-		return;
-	}
-
-	/*
-	 * Handle cases where we already have a working link on the bearer
-	 *
-	 * If the discovery message's media address doesn't match the link's,
-	 * the duplicate link request is rejected.
-	 *
-	 * If the discovery message's media address matches the link's,
-	 * the message is just a re-request for something we've already done,
-	 * so we can skip ahead.
-	 */
+	/* Prepare to validate requesting node's signature and media address */
 
 	link = n_ptr->links[b_ptr->identity];
-	if (tipc_link_is_up(link)) {
-		if (memcmp(&link->media_addr, &media_addr, sizeof(media_addr))) {
-			disc_dupl_alert(b_ptr, orig, &media_addr);
-			tipc_node_unlock(n_ptr);                
-			return;
-		}
-		goto link_ok;
-	}
+	addr_mismatch = (link != NULL) &&
+		memcmp(&link->media_addr, &media_addr, sizeof(media_addr));
 
 	/*
-	 * Handles cases where there is no working link on this bearer
+	 * Ensure discovery message's signature is correct
 	 *
-	 * If there is any working link to the node, ensure the discovery
-	 * message's signature is correct -- if it isn't, reject the request.
+	 * If signature is incorrect and there is no working link to the node,
+	 * accept the new signature but invalidate all existing links to the
+	 * node so they won't re-activate without a new discovery message.
 	 *
-	 * If there is no working link to the node, ensure the discovery
-	 * message's signature is correct -- if it isn't, accept the new
-	 * signature but "invalidate" all existing links to the node to
-	 * ensure they can't re-activate without a prior discovery message.
+	 * If signature is incorrect and the requested link to the node is
+	 * working, accept the new signature. (This is an instance of delayed
+	 * rediscovery, where a link endpoint was able to re-establish contact
+	 * with its peer endpoint on a node that rebooted before receiving a
+	 * discovery message from that node.)
 	 *
-	 * TODO: It might be better to delete these "stale" link endpoints,
-	 * but this could be tricky [see tipc_link_delete()].
+	 * If signature is incorrect and there is a working link to the node
+	 * that is not the requested link, reject the request (must be from
+	 * a duplicate node).
 	 */
 
-	if (n_ptr->working_links > 0) {
-		if (signature != n_ptr->signature) {
-			disc_dupl_alert(b_ptr, orig, &media_addr);
-			tipc_node_unlock(n_ptr);                
-			return;
-		}
-	}
-	else {
-		if (signature != n_ptr->signature) {
+	if (signature != n_ptr->signature) {
+		if (n_ptr->working_links == 0) {
 			struct link *curr_link;
 			int i;
 
 			for (i = 0; i < TIPC_MAX_BEARERS; i++) {
-				if ((curr_link = n_ptr->links[i]) != NULL) {
+				curr_link = n_ptr->links[i];
+				if (curr_link) {
 					memset(&curr_link->media_addr, 0, 
 					       sizeof(media_addr));
 					tipc_link_reset(curr_link);
 				}
 			}
+			addr_mismatch = (link != NULL);
+		} else if (tipc_link_is_up(link) && !addr_mismatch) {
+			/* delayed rediscovery */
+		} else {
+			disc_dupl_alert(b_ptr, orig, &media_addr);
+			tipc_node_unlock(n_ptr);                
+			return;
 		}
+		n_ptr->signature = signature;
 	}
 
 	/*
-	 * Create link endpoint for this bearer if none currently exists, 
-	 * otherwise reconfigure link endpoint to use specified media address
+	 * Ensure discovery message's media address is correct
+	 *
+	 * If media address doesn't match and the link is working, reject the
+	 * request (must be from a duplicate node).
+	 *
+	 * If media address doesn't match and the link is not working, accept
+	 * the new media address and reset the link to ensure it starts up
+	 * cleanly.
 	 */
 
+	if (addr_mismatch) {
+		if (tipc_link_is_up(link)) {
+			disc_dupl_alert(b_ptr, orig, &media_addr);
+			tipc_node_unlock(n_ptr);
+			return;
+		} else {
+			memcpy(&link->media_addr, &media_addr,
+			       sizeof(media_addr));
+			tipc_link_reset(link);
+		}
+	}
+
+	/* Create a link endpoint for this bearer, if necessary */
+
 	if (link == NULL) {
 #ifndef CONFIG_TIPC_MULTIPLE_LINKS
 		if (n_ptr->link_cnt > 0) {
@@ -385,49 +254,30 @@ void tipc_disc_recv_msg(struct sk_buff *buf, struct bearer *b_ptr)
 			return;
 		}
 #endif
-		link = tipc_link_create(b_ptr, orig, &media_addr);
+		link = tipc_link_create(n_ptr, b_ptr, &media_addr);
 		if (link == NULL) {
 			warn("Memory squeeze; Failed to create link\n");
 			tipc_node_unlock(n_ptr);                
 			return;
 		}
-	} else {
-		memcpy(&link->media_addr, &media_addr, sizeof(media_addr));
-		tipc_link_reset(link);
 	}
 
-	/* Accept node info in discovery message */
+	/* Accept discovery message & send response, if necessary */
 
-link_ok:
-	n_ptr->signature = signature;
 	n_ptr->flags = node_flags;
         link_fully_up = link_working_working(link);
-        tipc_node_unlock(n_ptr);             
-   
-	/* Send response to discovery message, if necessary */
 
-        if ((type == DSC_RESP_MSG) || link_fully_up)
-                return;
-        if (b_ptr->publ.blocked)
-		return;
-        rbuf = disc_init_msg(DSC_RESP_MSG, orig, b_ptr);
-        if (rbuf != NULL) {
-                msg_dbg(buf_msg(rbuf), "SEND:");
-                tipc_bearer_send(b_ptr, rbuf, &media_addr);
-		buf_discard(rbuf);
+	if ((type == DSC_REQ_MSG) && !link_fully_up && !b_ptr->publ.blocked) {
+		rbuf = disc_init_msg(DSC_RESP_MSG, orig, b_ptr);
+		if (rbuf != NULL) {
+			msg_dbg(buf_msg(rbuf), "SEND:");
+			tipc_bearer_send(b_ptr, rbuf, &media_addr);
+			buf_discard(rbuf);
+		}
 	}
-}
-
-/**
- * tipc_disc_deactivate - deactivate discoverer searching
- * @d_ptr: ptr to discoverer structure
- */
 
-void tipc_disc_deactivate(struct discoverer *d_ptr)
-{
-        k_cancel_timer(&d_ptr->timer);
-        d_ptr->timer_intv = TIPC_DISC_INACTIVE;
-} 
+	tipc_node_unlock(n_ptr);
+}
 
 /**
  * tipc_disc_update - update frequency of periodic link setup requests
@@ -508,7 +358,7 @@ exit:
  * @dest: destination address for discovery message
  * @domain: network domain of node(s) to be discovered
  * 
- * Returns 1 if successful, otherwise 0.
+ * Returns 0 if successful, otherwise -errno.
  *
  * 'tipc_net_lock' must be write-locked by caller on entry
  */
@@ -520,16 +370,16 @@ int tipc_disc_create(struct bearer *b_ptr, struct tipc_media_addr *dest,
 
 	d_ptr = kmalloc(sizeof(*d_ptr), GFP_ATOMIC);
 	if (!d_ptr)
-		return 0;
+		return -ENOMEM;
 
 	d_ptr->buf = disc_init_msg(DSC_REQ_MSG, domain, b_ptr);
 	if (!d_ptr->buf) {
 		kfree(d_ptr);
-		return 0;
+		return -ENOMSG;
 	}
 
+	b_ptr->disc_obj = d_ptr;
 	d_ptr->bearer = b_ptr;
-        list_add(&d_ptr->disc_list, &b_ptr->disc_list);
 	memcpy(&d_ptr->dest, dest, sizeof(*dest));
         d_ptr->domain = domain;
 	d_ptr->num_nodes = 0;
@@ -537,13 +387,12 @@ int tipc_disc_create(struct bearer *b_ptr, struct tipc_media_addr *dest,
 	k_init_timer(&d_ptr->timer, (Handler)disc_timeout, (unsigned long)d_ptr);
         k_start_timer(&d_ptr->timer, d_ptr->timer_intv);
 	tipc_disc_send_msg(d_ptr);
-	return 1;
+	return 0;
 } 
 
 /**
  * tipc_disc_delete - stop sending periodic link setup requests
  * @disc: ptr to link request structure
- * Timer must be cancelled or expired before doing this call
  */
 
 void tipc_disc_delete(struct discoverer *d_ptr) 
@@ -551,9 +400,9 @@ void tipc_disc_delete(struct discoverer *d_ptr)
 	if (!d_ptr)
 		return;
 
+	k_cancel_timer(&d_ptr->timer);
 	k_term_timer(&d_ptr->timer);
 	buf_discard(d_ptr->buf);
-        list_del_init(&d_ptr->disc_list);
 	kfree(d_ptr);
 }
 
diff --git a/net/tipc/tipc_discover.h b/net/tipc/tipc_discover.h
index 7cb6f62..832d737 100644
--- a/net/tipc/tipc_discover.h
+++ b/net/tipc/tipc_discover.h
@@ -2,7 +2,7 @@
  * net/tipc/tipc_discover.h: Include file for TIPC neighbor discovery code
  *
  * Copyright (c) 2003-2006, Ericsson AB
- * Copyright (c) 2005-2007, Wind River Systems
+ * Copyright (c) 2005-2007, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,7 +42,6 @@
 /**
  * struct discoverer - information about an ongoing link setup request
  * @bearer: bearer used for discovery messages
- * @disc_list: adjacent discoverers belonging to the same bearer
  * @dest: destination address for discovery messages
  * @domain: network domain of node(s) which should respond to discovery message
  * @num_nodes: number of nodes currently discovered
@@ -53,7 +52,6 @@
  
 struct discoverer {
 	struct bearer *bearer;
-	struct list_head disc_list;
 	struct tipc_media_addr dest;
         u32 domain;
 	int num_nodes;
@@ -66,10 +64,9 @@ int tipc_disc_create(struct bearer *b_ptr, struct tipc_media_addr *dest,
 		     u32 domain);
 void tipc_disc_update(struct discoverer *d_ptr);
 void tipc_disc_delete(struct discoverer *d_ptr);
-void tipc_disc_deactivate(struct discoverer *d_ptr);
 void tipc_disc_recv_msg(struct sk_buff *buf, struct bearer *b_ptr);
 void tipc_disc_send_msg(struct discoverer *d_ptr);
 struct sk_buff *tipc_disc_cmd_create_link(const void *disc_tlv_area, 
-					  int disc_tlv_space);
+					  u32 disc_tlv_space);
 
 #endif
diff --git a/net/tipc/tipc_eth_media.c b/net/tipc/tipc_eth_media.c
index 7341dad..dc2f011 100644
--- a/net/tipc/tipc_eth_media.c
+++ b/net/tipc/tipc_eth_media.c
@@ -38,6 +38,7 @@
 #include <net/tipc/tipc_plugin_if.h>
 #include <net/tipc/tipc_plugin_msg.h>
 #include <linux/netdevice.h>
+#include <linux/slab.h>
 #include <linux/workqueue.h>
 #include <linux/version.h>
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
@@ -233,8 +234,11 @@ static int enable_bearer(struct tipc_bearer *tb_ptr)
 	tb_ptr->usr_handle = (void *)eb_ptr;
 	tb_ptr->mtu = dev->mtu;
 	tb_ptr->blocked = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31)
+	eth_media_addr_init(&tb_ptr->addr, (char *)dev->dev_addr);
+#else
 	eth_media_addr_init(&tb_ptr->addr, (char *)&dev->dev_addr);
-
+#endif
 	return 0;
 }
 
@@ -366,8 +370,12 @@ static int eth_addr2str(struct tipc_media_addr *a, char *str_buf, int str_size)
 		return 1;
 		
 	mac = (unsigned char *)&a->value[4];
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29)
+	sprintf(str_buf, "%pM", mac);
+#else
 	sprintf(str_buf, "%02x:%02x:%02x:%02x:%02x:%02x",
 		mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+#endif
 	return 0;
 }
 
diff --git a/net/tipc/tipc_link.c b/net/tipc/tipc_link.c
index 9148eb5..9436868 100644
--- a/net/tipc/tipc_link.c
+++ b/net/tipc/tipc_link.c
@@ -2,7 +2,7 @@
  * net/tipc/tipc_link.c: TIPC link code
  *
  * Copyright (c) 1996-2007, Ericsson AB
- * Copyright (c) 2004-2008, Wind River Systems
+ * Copyright (c) 2004-2008, 2010 Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -56,12 +56,6 @@
 #define INVALID_SESSION 0x10000
 
 /*
- * Limit for deferred reception queue:
- */
-
-#define DEF_QUEUE_LIMIT 256u
-
-/*
  * Link state events:
  */
 
@@ -148,15 +142,11 @@ static void link_reset_statistics(struct link *l_ptr);
 /*
  * DBG_OUTPUT_LINK is the destination print buffer chain for per-link debug
  * messages.  It defaults to the the null print buffer, but can be enabled
- * where needed to allow debug messages to be selectively generated.
+ * where needed to allow debug messages to be selectively generated by
+ * replacing TIPC_NULL with (&l_ptr->print_buf), TIPC_LOG, or TIPC_CONS.
  */
 
 #define DBG_OUTPUT_LINK TIPC_NULL
-#if 0
-#define DBG_OUTPUT_LINK (&l_ptr->print_buf)
-#define DBG_OUTPUT_LINK TIPC_LOG
-#define DBG_OUTPUT_LINK TIPC_CONS
-#endif
 
 #ifdef CONFIG_TIPC_DEBUG
 
@@ -261,8 +251,8 @@ static int link_name_validate(const char *name, struct link_name *name_parts)
 	char dummy;
 	u32 z_local, c_local, n_local;
 	u32 z_peer, c_peer, n_peer;
-	u32 if_local_len;
-	u32 if_peer_len;
+	size_t if_local_len;
+	size_t if_peer_len;
 
 	/* copy link name & ensure length is OK */
 
@@ -333,9 +323,6 @@ static void link_timeout(struct link *l_ptr)
 	l_ptr->stats.accu_queue_sz += l_ptr->out_queue_size;
 	l_ptr->stats.queue_sz_counts++;
 
-	if (l_ptr->out_queue_size > l_ptr->stats.max_queue_sz)
-		l_ptr->stats.max_queue_sz = l_ptr->out_queue_size;
-
 	if (l_ptr->first_out) {
 		struct tipc_msg *msg = buf_msg(l_ptr->first_out);
 		u32 length = msg_size(msg);
@@ -383,19 +370,35 @@ static void link_set_timer(struct link *l_ptr, u32 time)
 
 /**
  * tipc_link_create - create a new link
+ * @n_ptr: point to associated node
  * @b_ptr: pointer to associated bearer
- * @peer: network address of node at other end of link
  * @media_addr: media address to use when sending messages over link
  *
  * Returns pointer to link.
  */
 
-struct link *tipc_link_create(struct bearer *b_ptr, const u32 peer,
+struct link *tipc_link_create(struct tipc_node *n_ptr, struct bearer *b_ptr, 
 			      const struct tipc_media_addr *media_addr)
 {
 	struct link *l_ptr;
 	struct tipc_msg *msg;
 	char *if_name;
+	char addr_string[16];
+	u32 peer = n_ptr->elm.addr;
+
+	if (n_ptr->link_cnt >= TIPC_MAX_BEARERS) {
+		tipc_addr_string_fill(addr_string, n_ptr->elm.addr);
+		err("Attempt to establish more than %d links to %s\n",
+		    n_ptr->link_cnt, addr_string);
+		return NULL;
+	}
+
+	if (n_ptr->links[b_ptr->identity]) {
+		tipc_addr_string_fill(addr_string, n_ptr->elm.addr);
+		err("Attempt to establish second link on <%s> to %s \n",
+		    b_ptr->publ.name, addr_string);
+		return NULL;
+	}
 
 	l_ptr = kzalloc(sizeof(*l_ptr), GFP_ATOMIC);
 	if (!l_ptr) {
@@ -416,14 +419,16 @@ struct link *tipc_link_create(struct bearer *b_ptr, const u32 peer,
 
 	l_ptr->addr = peer;
 	if_name = strchr(b_ptr->publ.name, ':') + 1;
-	sprintf(l_ptr->name, "%u.%u.%u:%s-%u.%u.%u:",
+	sprintf(l_ptr->name, "%u.%u.%u:%s-%u.%u.%u:unknown",
 		tipc_zone(tipc_own_addr), tipc_cluster(tipc_own_addr),
 		tipc_node(tipc_own_addr),
 		if_name,
 		tipc_zone(peer), tipc_cluster(peer), tipc_node(peer));
 		/* note: peer i/f is appended to link name by reset/activate */
 	memcpy(&l_ptr->media_addr, media_addr, sizeof(*media_addr));
+	l_ptr->owner = n_ptr;
 	l_ptr->checkpoint = 1;
+	l_ptr->peer_session = INVALID_SESSION;
 	l_ptr->b_ptr = b_ptr;
 	link_set_supervision_props(l_ptr, b_ptr->tolerance);
 	l_ptr->state = RESET_UNKNOWN;
@@ -440,15 +445,7 @@ struct link *tipc_link_create(struct bearer *b_ptr, const u32 peer,
 	l_ptr->next_out_no = 1;
 	INIT_LIST_HEAD(&l_ptr->waiting_ports);
 	link_reset_statistics(l_ptr);
-
-	l_ptr->owner = tipc_node_attach_link(l_ptr);
-	if (!l_ptr->owner) {
-		if (LINK_LOG_BUF_SIZE)
-			kfree(l_ptr->print_buf.buf);
-		kfree(l_ptr);
-		return NULL;
-	}
-
+	tipc_node_attach_link(n_ptr, l_ptr);
 	k_init_timer(&l_ptr->timer, (Handler)link_timeout, (unsigned long)l_ptr);
 	list_add_tail(&l_ptr->link_list, &b_ptr->links);
 
@@ -502,7 +499,6 @@ static void link_remote_delete(struct link *l_ptr)
 
 	write_lock_bh(&tipc_net_lock);
         spin_lock_bh(&b_ptr->publ.lock);
-        tipc_bearer_remove_discoverer(b_ptr,l_ptr->addr);
         tipc_link_delete(l_ptr);
         spin_unlock_bh(&b_ptr->publ.lock);
 	write_unlock_bh(&tipc_net_lock);
@@ -510,8 +506,10 @@ static void link_remote_delete(struct link *l_ptr)
 
 void tipc_link_start(struct link *l_ptr)
 {
-	dbg("tipc_link_start %x\n", l_ptr);
+	tipc_node_lock(l_ptr->owner);
+	dbg("tipc_link_start %p\n", l_ptr);
 	link_state_event(l_ptr, STARTING_EVT);
+	tipc_node_unlock(l_ptr->owner);
 }
 
 /**
@@ -524,7 +522,7 @@ void tipc_link_start(struct link *l_ptr)
  * has abated.
  */
 
-static int link_schedule_port(struct link *l_ptr, u32 origport, u32 sz)
+static void link_schedule_port(struct link *l_ptr, u32 origport, u32 sz)
 {
 	struct port *p_ptr;
 
@@ -543,7 +541,6 @@ exit:
 		tipc_port_unlock(p_ptr);
 	}
 	spin_unlock_bh(&tipc_port_list_lock);
-	return -ELINKCONG;
 }
 
 void tipc_link_wakeup_ports(struct link *l_ptr, int all)
@@ -666,11 +663,7 @@ void tipc_link_reset(struct link *l_ptr)
 		return;
 
 	tipc_node_link_down(l_ptr->owner, l_ptr);
-	tipc_bearer_remove_dest(l_ptr->b_ptr, l_ptr->addr, &l_ptr->media_addr);
-#if 0
-	printk("\nReset link <%s>\n", l_ptr->name);
-	dbg_link_dump("\n\nDumping link <%s>:\n", l_ptr->name);
-#endif
+	tipc_bearer_remove_dest(l_ptr->b_ptr, l_ptr->addr);
 	if (was_active_link && tipc_node_is_up(l_ptr->owner) &&
 	    l_ptr->owner->permit_changeover) {
 		l_ptr->reset_checkpoint = checkpoint;
@@ -712,7 +705,7 @@ static void link_activate(struct link *l_ptr)
 {
 	l_ptr->next_in_no = l_ptr->stats.recv_info = 1;
 	tipc_node_link_up(l_ptr->owner, l_ptr);
-	tipc_bearer_add_dest(l_ptr->b_ptr, l_ptr->addr, &l_ptr->media_addr);
+	tipc_bearer_add_dest(l_ptr->b_ptr, l_ptr->addr);
 }
 
 /**
@@ -752,12 +745,12 @@ static void link_state_event(struct link *l_ptr, unsigned event)
 			if (l_ptr->next_in_no != l_ptr->checkpoint) {
 				l_ptr->checkpoint = l_ptr->next_in_no;
 				if (tipc_bclink_acks_missing(l_ptr->owner)) {
-					tipc_link_send_proto_msg(l_ptr, STATE_MSG,
-							    0, 0, 0, 0, 0, 0);
+					tipc_link_send_proto_msg(l_ptr,
+						STATE_MSG, 0, 0, 0, 0, 0);
 					l_ptr->fsm_msg_cnt++;
 				} else if (l_ptr->max_pkt < l_ptr->max_pkt_target) {
-					tipc_link_send_proto_msg(l_ptr, STATE_MSG,
-							    1, 0, 0, 0, 0, 0);
+					tipc_link_send_proto_msg(l_ptr,
+						STATE_MSG, 1, 0, 0, 0, 0);
 					l_ptr->fsm_msg_cnt++;
 				}
 				link_set_timer(l_ptr, cont_intv);
@@ -766,7 +759,8 @@ static void link_state_event(struct link *l_ptr, unsigned event)
 			dbg_link(" -> WU\n");
 			l_ptr->state = WORKING_UNKNOWN;
 			l_ptr->fsm_msg_cnt = 0;
-			tipc_link_send_proto_msg(l_ptr, STATE_MSG, 1, 0, 0, 0, 0, 0);
+			tipc_link_send_proto_msg(l_ptr,
+						 STATE_MSG, 1, 0, 0, 0, 0);
 			l_ptr->fsm_msg_cnt++;
 			link_set_timer(l_ptr, cont_intv / 4);
 			break;
@@ -777,7 +771,8 @@ static void link_state_event(struct link *l_ptr, unsigned event)
 			tipc_link_reset(l_ptr);
 			l_ptr->state = RESET_RESET;
 			l_ptr->fsm_msg_cnt = 0;
-			tipc_link_send_proto_msg(l_ptr, ACTIVATE_MSG, 0, 0, 0, 0, 0, 0);
+			tipc_link_send_proto_msg(l_ptr,
+						 ACTIVATE_MSG, 0, 0, 0, 0, 0);
 			l_ptr->fsm_msg_cnt++;
 			link_set_timer(l_ptr, cont_intv);
 			break;
@@ -803,7 +798,8 @@ static void link_state_event(struct link *l_ptr, unsigned event)
 			tipc_link_reset(l_ptr);
 			l_ptr->state = RESET_RESET;
 			l_ptr->fsm_msg_cnt = 0;
-			tipc_link_send_proto_msg(l_ptr, ACTIVATE_MSG, 0, 0, 0, 0, 0, 0);
+			tipc_link_send_proto_msg(l_ptr,
+						 ACTIVATE_MSG, 0, 0, 0, 0, 0);
 			l_ptr->fsm_msg_cnt++;
 			link_set_timer(l_ptr, cont_intv);
 			break;
@@ -815,8 +811,8 @@ static void link_state_event(struct link *l_ptr, unsigned event)
 				l_ptr->fsm_msg_cnt = 0;
 				l_ptr->checkpoint = l_ptr->next_in_no;
 				if (tipc_bclink_acks_missing(l_ptr->owner)) {
-					tipc_link_send_proto_msg(l_ptr, STATE_MSG,
-							    0, 0, 0, 0, 0, 0);
+					tipc_link_send_proto_msg(l_ptr,
+						STATE_MSG, 0, 0, 0, 0, 0);
 					l_ptr->fsm_msg_cnt++;
 				}
 				link_set_timer(l_ptr, cont_intv);
@@ -824,8 +820,8 @@ static void link_state_event(struct link *l_ptr, unsigned event)
 				dbg_link("Probing %u/%u,timer = %u ms)\n",
 					 l_ptr->fsm_msg_cnt, l_ptr->abort_limit,
 					 cont_intv / 4);
-				tipc_link_send_proto_msg(l_ptr, STATE_MSG, 
-						    1, 0, 0, 0, 0, 0);
+				tipc_link_send_proto_msg(l_ptr,
+					STATE_MSG, 1, 0, 0, 0, 0);
 				l_ptr->fsm_msg_cnt++;
 				link_set_timer(l_ptr, cont_intv / 4);
 			} else {	/* Link has failed */
@@ -836,8 +832,8 @@ static void link_state_event(struct link *l_ptr, unsigned event)
 				tipc_link_reset(l_ptr);
 				l_ptr->state = RESET_UNKNOWN;
 				l_ptr->fsm_msg_cnt = 0;
-				tipc_link_send_proto_msg(l_ptr, RESET_MSG,
-						    0, 0, 0, 0, 0, 0);
+				tipc_link_send_proto_msg(l_ptr,
+					RESET_MSG, 0, 0, 0, 0, 0);
 				l_ptr->fsm_msg_cnt++;
 				link_set_timer(l_ptr, cont_intv);
 			}
@@ -862,7 +858,8 @@ static void link_state_event(struct link *l_ptr, unsigned event)
 			l_ptr->state = WORKING_WORKING;
 			l_ptr->fsm_msg_cnt = 0;
 			link_activate(l_ptr);
-			tipc_link_send_proto_msg(l_ptr, STATE_MSG, 1, 0, 0, 0, 0, 0);
+			tipc_link_send_proto_msg(l_ptr,
+						 STATE_MSG, 1, 0, 0, 0, 0);
 			l_ptr->fsm_msg_cnt++;
 			link_set_timer(l_ptr, cont_intv);
 			break;
@@ -871,7 +868,8 @@ static void link_state_event(struct link *l_ptr, unsigned event)
 			dbg_link(" -> RR\n");
 			l_ptr->state = RESET_RESET;
 			l_ptr->fsm_msg_cnt = 0;
-			tipc_link_send_proto_msg(l_ptr, ACTIVATE_MSG, 1, 0, 0, 0, 0, 0);
+			tipc_link_send_proto_msg(l_ptr,
+						 ACTIVATE_MSG, 1, 0, 0, 0, 0);
 			l_ptr->fsm_msg_cnt++;
 			link_set_timer(l_ptr, cont_intv);
 			break;
@@ -881,8 +879,8 @@ static void link_state_event(struct link *l_ptr, unsigned event)
 			/* fall through */
 		case TIMEOUT_EVT:
 			dbg_link("TIM \n");
-                        tipc_bearer_send_discover(l_ptr->b_ptr,l_ptr->addr);
-			tipc_link_send_proto_msg(l_ptr, RESET_MSG, 0, 0, 0, 0, 0, 0);
+			tipc_link_send_proto_msg(l_ptr,
+						 RESET_MSG, 0, 0, 0, 0, 0);
 			l_ptr->fsm_msg_cnt++;
 			link_set_timer(l_ptr, cont_intv);
 			break;
@@ -906,7 +904,8 @@ static void link_state_event(struct link *l_ptr, unsigned event)
 			l_ptr->state = WORKING_WORKING;
 			l_ptr->fsm_msg_cnt = 0;
 			link_activate(l_ptr);
-			tipc_link_send_proto_msg(l_ptr, STATE_MSG, 1, 0, 0, 0, 0, 0);
+			tipc_link_send_proto_msg(l_ptr,
+						 STATE_MSG, 1, 0, 0, 0, 0);
 			l_ptr->fsm_msg_cnt++;
 			link_set_timer(l_ptr, cont_intv);
 			break;
@@ -915,7 +914,8 @@ static void link_state_event(struct link *l_ptr, unsigned event)
 			break;
 		case TIMEOUT_EVT:
 			dbg_link("TIM\n");
-			tipc_link_send_proto_msg(l_ptr, ACTIVATE_MSG, 0, 0, 0, 0, 0, 0);
+			tipc_link_send_proto_msg(l_ptr,
+						 ACTIVATE_MSG, 0, 0, 0, 0, 0);
 			l_ptr->fsm_msg_cnt++;
 			link_set_timer(l_ptr, cont_intv);
 			dbg_link("fsm_msg_cnt %u\n", l_ptr->fsm_msg_cnt);
@@ -981,7 +981,22 @@ static void link_add_to_outqueue(struct link *l_ptr,
 		l_ptr->last_out = buf;
 	} else
 		l_ptr->first_out = l_ptr->last_out = buf;
-	l_ptr->out_queue_size++;
+
+	if (++l_ptr->out_queue_size > l_ptr->stats.max_queue_sz)
+		l_ptr->stats.max_queue_sz = l_ptr->out_queue_size;
+}
+
+static void link_add_chain_to_outqueue(struct link *l_ptr,
+				       struct sk_buff *buf_chain)
+{
+	if (!l_ptr->next_out)
+		l_ptr->next_out = buf_chain;
+	while (buf_chain) {
+		struct sk_buff *buf = buf_chain;
+
+		buf_chain = buf_chain->next;
+		link_add_to_outqueue(l_ptr, buf, buf_msg(buf));
+	}
 }
 
 /*
@@ -1006,13 +1021,22 @@ int tipc_link_send_buf(struct link *l_ptr, struct sk_buff *buf)
 
 	if (unlikely(queue_size >= queue_limit)) {
 		if (imp <= TIPC_CRITICAL_IMPORTANCE) {
-			return link_schedule_port(l_ptr, msg_origport(msg),
-						  size);
+			link_schedule_port(l_ptr, msg_origport(msg), size);
+			buf_discard(buf);
+			return -ELINKCONG;
+		}
+
+		if (imp == NAME_DISTRIBUTOR) {
+			link_schedule_port(l_ptr, tipc_nametbl_publ_port(),
+					   size);
+			buf_discard(buf);
+			return -ELINKCONG;
 		}
+
 		msg_dbg(msg, "TIPC: Congestion, throwing away\n");
 		buf_discard(buf);
 		if (imp > CONN_MANAGER) {
-			warn("Resetting link <%s>, send queue full", l_ptr->name);
+			warn("Resetting link <%s>, send queue full!\n", l_ptr->name);
 			tipc_link_reset(l_ptr);
 		}
 		return dsz;
@@ -1025,9 +1049,6 @@ int tipc_link_send_buf(struct link *l_ptr, struct sk_buff *buf)
 
 	/* Packet can be queued or sent: */
 
-	if (queue_size > l_ptr->stats.max_queue_sz)
-		l_ptr->stats.max_queue_sz = queue_size;
-
 	if (likely(!tipc_bearer_congested(l_ptr->b_ptr, l_ptr) &&
 		   !link_congested(l_ptr))) {
 		link_add_to_outqueue(l_ptr, buf, msg);
@@ -1098,7 +1119,7 @@ int tipc_link_send(struct sk_buff *buf, u32 dest, u32 selector)
 		tipc_node_lock(n_ptr);
 		l_ptr = n_ptr->active_links[selector & 1];
 		if (l_ptr) {
-			dbg("tipc_link_send: found link %x for dest %x\n", l_ptr, dest);
+			dbg("tipc_link_send: found link %p for dest %x\n", l_ptr, dest);
 			res = tipc_link_send_buf(l_ptr, buf);
 		} else {
 			dbg("Attempt to send msg to unreachable node:\n");
@@ -1116,6 +1137,50 @@ int tipc_link_send(struct sk_buff *buf, u32 dest, u32 selector)
 }
 
 /*
+ * tipc_link_send_names - send name table entries to new neighbor
+ *
+ * Send routine used for delivering bulk name table entries when contact
+ * with a new neighbor occurs. No link congestion checking is performed
+ * because name table entries *must* be delivered. No MTU checking is
+ * performed because messages are known to be small enough not to require
+ * fragmentation and large enough not to need bundling.
+ * Called without any locks held.
+ */
+
+void tipc_link_send_names(struct list_head *message_list, u32 dest)
+{
+	struct tipc_node *n_ptr;
+	struct link *l_ptr;
+	struct sk_buff *buf;
+	struct sk_buff *temp_buf;
+
+	read_lock_bh(&tipc_net_lock);
+	n_ptr = tipc_net_select_node(dest);
+	if (n_ptr) {
+		tipc_node_lock(n_ptr);
+		l_ptr = n_ptr->active_links[0];
+		if (l_ptr) {
+			if (!list_empty(message_list)) {
+				/* convert circular list to linear list */
+				((struct sk_buff *)message_list->prev)->next =
+					NULL;
+				link_add_chain_to_outqueue(l_ptr,
+					(struct sk_buff *)message_list->next);
+				tipc_link_push_queue(l_ptr);
+				INIT_LIST_HEAD(message_list);
+			}
+		}
+		tipc_node_unlock(n_ptr);
+	}
+
+	list_for_each_safe(buf, temp_buf, ((struct sk_buff *)message_list)) {
+		list_del((struct list_head *)buf);
+		buf_discard(buf);
+	}
+	read_unlock_bh(&tipc_net_lock);
+}
+
+/*
  * link_send_buf_fast: Entry for data messages where the
  * destination link is known and the header is complete,
  * inclusive total message length. Very time critical.
@@ -1173,7 +1238,7 @@ int tipc_send_buf_fast(struct sk_buff *buf, u32 destnode)
 	if (likely(n_ptr)) {
 		tipc_node_lock(n_ptr);
 		l_ptr = n_ptr->active_links[selector];
-		dbg("send_fast: buf %x selected %x, destnode = %x\n",
+		dbg("send_fast: buf %p selected %p, destnode = %x\n",
 		    buf, l_ptr, destnode);
 		if (likely(l_ptr)) {
 			res = link_send_buf_fast(l_ptr, buf, &dummy);
@@ -1227,8 +1292,6 @@ again:
 			if (likely(buf)) {
 				res = link_send_buf_fast(l_ptr, buf,
 							 &sender->publ.max_pkt);
-				if (unlikely(res < 0))
-					buf_discard(buf);
 exit:
 				tipc_node_unlock(node);
 				read_unlock_bh(&tipc_net_lock);
@@ -1244,8 +1307,9 @@ exit:
 
 			if (link_congested(l_ptr) || 
 			    !list_empty(&l_ptr->b_ptr->cong_links)) {
-				res = link_schedule_port(l_ptr,
-							 sender->publ.ref, res);
+				link_schedule_port(l_ptr, sender->publ.ref,
+						   (u32)res);
+				res = -ELINKCONG;
 				goto exit;
 			}
 
@@ -1354,7 +1418,7 @@ again:
 		u32 sz;
 
 		if (!sect_rest) {
-			sect_rest = msg_sect[++curr_sect].iov_len;
+			sect_rest = (u32)msg_sect[++curr_sect].iov_len;
 			sect_crs = (const unchar *)msg_sect[curr_sect].iov_base;
 		}
 
@@ -1440,24 +1504,11 @@ reject:
 						 TIPC_ERR_NO_NODE);
 	}
 
-	/* Append whole chain to send queue: */
+	/* Append chain of fragments to send queue & send them */
 
-	buf = buf_chain;
-	if (!l_ptr->next_out)
-		l_ptr->next_out = buf_chain;
+	link_add_chain_to_outqueue(l_ptr, buf_chain);
+	l_ptr->stats.sent_fragments += fragm_no;
 	l_ptr->stats.sent_fragmented++;
-	while (buf) {
-		struct sk_buff *next = buf->next;
-		struct tipc_msg *msg = buf_msg(buf);
-
-		l_ptr->stats.sent_fragments++;
-		link_add_to_outqueue(l_ptr, buf, msg);
-		msg_dbg(msg, ">ADD>");
-		buf = next;
-	}
-
-	/* Send it, if possible: */
-
 	tipc_link_push_queue(l_ptr);
 	tipc_node_unlock(node);
 	return dsz;
@@ -1588,6 +1639,7 @@ static void link_reset_all(unsigned long addr)
 
 	tipc_addr_string_fill(addr_string, n_ptr->elm.addr);
 	dbg_printf(TIPC_OUTPUT, "Broadcast link info for %s\n", addr_string);
+	dbg_printf(TIPC_OUTPUT, "Supportable: %d,  ", n_ptr->bclink.supportable);
 	dbg_printf(TIPC_OUTPUT, "Supported: %d,  ", n_ptr->bclink.supported);
 	dbg_printf(TIPC_OUTPUT, "Acked: %u\n", n_ptr->bclink.acked);
 	dbg_printf(TIPC_OUTPUT, "Last in: %u,  ", n_ptr->bclink.last_in);
@@ -1628,10 +1680,10 @@ static void link_retransmit_failure(struct link *l_ptr, struct sk_buff *buf)
 		struct tipc_node *n_ptr;
 
 		dbg_printf(TIPC_OUTPUT, "Msg seq number: %u,  ", buf_seqno(buf));
-		dbg_printf(TIPC_OUTPUT, "Outstanding acks: %u\n", (u32)buf_handle(buf));
+		dbg_printf(TIPC_OUTPUT, "Outstanding acks: %u\n",
+			   (u32)(unsigned long)(char *)buf_handle(buf));
 		
-		/* recover retransmit requester */
-		n_ptr = (struct tipc_node *)l_ptr->owner->node_list.next;
+                n_ptr = tipc_bclink_retransmit_to();
 
 		tipc_k_signal((Handler)link_reset_all, (unsigned long)n_ptr->elm.addr);
 
@@ -1649,7 +1701,7 @@ void tipc_link_retransmit(struct link *l_ptr, struct sk_buff *buf,
 
 	msg = buf_msg(buf);
 
-	dbg("Retransmitting %u in link %x\n", retransmits, l_ptr);
+	dbg("Retransmitting %u in link %p\n", retransmits, l_ptr);
 
 	if (tipc_bearer_congested(l_ptr->b_ptr, l_ptr)) {
 		if (l_ptr->retransm_queue_size == 0) {
@@ -1792,6 +1844,7 @@ void tipc_recv_msg(struct sk_buff *head, struct tipc_bearer *tb_ptr)
 		u32 seq_no;
 		u32 ackd;
 		u32 released;
+		int ret;
 
 		buf = head;
 		head = head->next;
@@ -1843,17 +1896,24 @@ void tipc_recv_msg(struct sk_buff *head, struct tipc_bearer *tb_ptr)
 			goto cont;
 		tipc_node_lock(n_ptr);
 
-		/* Don't talk to neighbor during cleanup after last session */
+		/* Locate unicast link endpoint that should handle message */
 
-		if (n_ptr->cleanup_required) {
-			tipc_node_unlock(n_ptr);                
+		l_ptr = n_ptr->links[b_ptr->identity];
+		if (unlikely(!l_ptr)) {
+			tipc_node_unlock(n_ptr);
 			goto cont;
 		}
 
-		/* Locate unicast link endpoint that should handle message */
+		/* Verify that communication with node is currently allowed */
 
-		l_ptr = n_ptr->links[b_ptr->identity];
-		if (unlikely(!l_ptr)) {
+		if ((n_ptr->block_setup & WAIT_PEER_DOWN) &&
+		    (msg_user(msg) == LINK_PROTOCOL) &&
+		    (msg_type(msg) == RESET_MSG ||
+		     msg_type(msg) == ACTIVATE_MSG) &&
+		    !msg_redundant_link(msg))
+		    n_ptr->block_setup &= ~WAIT_PEER_DOWN;
+
+		if (n_ptr->block_setup) {
 			tipc_node_unlock(n_ptr);
 			goto cont;
 		}
@@ -1867,10 +1927,8 @@ void tipc_recv_msg(struct sk_buff *head, struct tipc_bearer *tb_ptr)
 
 		/* Release acked messages */
 
-		if (less(n_ptr->bclink.acked, msg_bcast_ack(msg)) &&
-		    tipc_node_is_up(n_ptr) && n_ptr->bclink.supported) {
+		if (n_ptr->bclink.supported)
 			tipc_bclink_acknowledge(n_ptr, msg_bcast_ack(msg));
-		}
 
 		released = 0;
 		crs = l_ptr->first_out;
@@ -1895,7 +1953,8 @@ void tipc_recv_msg(struct sk_buff *head, struct tipc_bearer *tb_ptr)
 			tipc_link_wakeup_ports(l_ptr, 0);
 		if (unlikely(++l_ptr->unacked_window >= TIPC_MIN_LINK_WIN)) {
 			l_ptr->stats.sent_acks++;
-			tipc_link_send_proto_msg(l_ptr, STATE_MSG, 0, 0, 0, 0, 0, 0);
+			tipc_link_send_proto_msg(l_ptr,
+						 STATE_MSG, 0, 0, 0, 0, 0);
 		}
 
 		/* Now (finally!) process the incoming message */
@@ -1950,11 +2009,15 @@ deliver:
                                         break;
                                 case MSG_FRAGMENTER:
                                         l_ptr->stats.recv_fragments++;
-                                        if (tipc_link_recv_fragment(&l_ptr->defragm_buf, 
-                                                                    &buf, &msg)) {
+                                        ret = tipc_link_recv_fragment(
+						&l_ptr->defragm_buf,
+						&buf, &msg);
+                                        if (ret == 1) {
                                                 l_ptr->stats.recv_fragmented++;
                                                 goto deliver;
                                         }
+                                        if (ret == -1)
+                                            l_ptr->next_in_no--;
                                         break;
 #ifdef CONFIG_TIPC_MULTIPLE_LINKS
                                 case CHANGEOVER_PROTOCOL:
@@ -2096,7 +2159,8 @@ static void link_handle_out_of_seq_msg(struct link *l_ptr,
 		l_ptr->deferred_inqueue_sz++;
 		l_ptr->stats.deferred_recv++;
 		if ((l_ptr->deferred_inqueue_sz % 16) == 1)
-			tipc_link_send_proto_msg(l_ptr, STATE_MSG, 0, 0, 0, 0, 0, 0);
+			tipc_link_send_proto_msg(l_ptr,
+						 STATE_MSG, 0, 0, 0, 0, 0);
 	} else
 		l_ptr->stats.duplicates++;
 }
@@ -2105,15 +2169,31 @@ static void link_handle_out_of_seq_msg(struct link *l_ptr,
  * Send protocol message to the other endpoint.
  */
 void tipc_link_send_proto_msg(struct link *l_ptr, u32 msg_typ, int probe_msg,
-                              u32 gap, u32 tolerance, u32 priority, u32 ack_mtu,
-                              int stop)
+			      u32 gap, u32 tolerance, u32 priority, u32 ack_mtu)
 {
 	struct sk_buff *buf = NULL;
 	struct tipc_msg *msg = l_ptr->pmsg;
 	u32 msg_size = sizeof(l_ptr->proto_msg);
 
+	/* Discard any previous message that was deferred due to congestion */
+
+	if (l_ptr->proto_msg_queue) {
+		buf_discard(l_ptr->proto_msg_queue);
+		l_ptr->proto_msg_queue = NULL;
+	}
+
+	/* Abort send if link is blocked */
+
 	if (link_blocked(l_ptr))
 		return;
+
+	/* Abort non-RESET send if communication with node is prohibited */
+
+	if ((l_ptr->owner->block_setup) && (msg_typ != RESET_MSG))
+		return;
+
+	/* Create protocol message with "out-of-sequence" sequence number */
+
 	msg_set_type(msg, msg_typ);
 	msg_set_net_plane(msg, l_ptr->b_ptr->net_plane);
 	msg_set_bcast_ack(msg, l_ptr->owner->bclink.last_in);
@@ -2124,6 +2204,7 @@ void tipc_link_send_proto_msg(struct link *l_ptr, u32 msg_typ, int probe_msg,
 
 		if (!tipc_link_is_up(l_ptr))
 			return;
+
 		if (l_ptr->next_out)
 			next_sent = buf_seqno(l_ptr->next_out);
 		msg_set_next_sent(msg, next_sent);
@@ -2161,55 +2242,47 @@ void tipc_link_send_proto_msg(struct link *l_ptr, u32 msg_typ, int probe_msg,
 		msg_set_ack(msg, mod(l_ptr->reset_checkpoint - 1));
 		msg_set_seq_gap(msg, 0);
 		msg_set_next_sent(msg, 1);
-		msg_set_stop(msg, stop);
+		msg_set_probe(msg, 0);
 		msg_set_link_tolerance(msg, l_ptr->tolerance);
 		msg_set_linkprio(msg, l_ptr->priority);
 		msg_set_max_pkt(msg, l_ptr->max_pkt_target);
 	}
 
-	msg_set_redundant_link(msg, tipc_node_has_redundant_links(l_ptr->owner));
+	msg_set_stop(msg, 0);
+	msg_set_redundant_link(msg, tipc_node_alt_link_is_up(l_ptr));
 	msg_set_linkprio(msg, l_ptr->priority);
-
-	/* Ensure sequence number will not fit : */
+	msg_set_timestamp(msg, jiffies_to_msecs(jiffies));
+	msg_set_size(msg, msg_size);
 
 	msg_set_seqno(msg, mod(l_ptr->next_out_no + (0xffff/2)));
 
-	/* Congestion? */
-
-	if (tipc_bearer_congested(l_ptr->b_ptr, l_ptr)) {
-		if (!l_ptr->proto_msg_queue) {
-			l_ptr->proto_msg_queue =
-				buf_acquire(sizeof(l_ptr->proto_msg));
-		}
-		buf = l_ptr->proto_msg_queue;
-		if (!buf)
-			return;
-		skb_copy_to_linear_data(buf, msg, sizeof(l_ptr->proto_msg));
+	buf = buf_acquire(msg_size);
+	if (!buf)
 		return;
-	}
-	msg_set_timestamp(msg, jiffies_to_msecs(jiffies));
 
-	/* Message can be sent */
+	skb_copy_to_linear_data(buf, msg, sizeof(l_ptr->proto_msg));
 
-	msg_dbg(msg, ">>");
+	/* Defer message if bearer is already congested */
 
-	buf = buf_acquire(msg_size);
-	if (!buf)
+	if (tipc_bearer_congested(l_ptr->b_ptr, l_ptr)) {
+		l_ptr->proto_msg_queue = buf;
 		return;
+	}
 
-	skb_copy_to_linear_data(buf, msg, sizeof(l_ptr->proto_msg));
-	msg_set_size(buf_msg(buf), msg_size);
+	/* Defer message if attempting to send results in bearer congestion */
 
-	if (tipc_bearer_send(l_ptr->b_ptr, buf, &l_ptr->media_addr)) {
-		l_ptr->unacked_window = 0;
-		buf_discard(buf);
+	if (!tipc_bearer_send(l_ptr->b_ptr, buf, &l_ptr->media_addr)) {
+		tipc_bearer_schedule(l_ptr->b_ptr, l_ptr);
+		l_ptr->proto_msg_queue = buf;
+		l_ptr->stats.bearer_congs++;
 		return;
 	}
 
-	/* New congestion */
-	tipc_bearer_schedule(l_ptr->b_ptr, l_ptr);
-	l_ptr->proto_msg_queue = buf;
-	l_ptr->stats.bearer_congs++;
+	/* Discard message if it was sent successfully */
+
+	msg_dbg(msg, ">>");
+	l_ptr->unacked_window = 0;
+	buf_discard(buf);
 }
 
 /*
@@ -2246,19 +2319,26 @@ static void link_recv_proto_msg(struct link *l_ptr, struct sk_buff *buf)
 	case RESET_MSG:
 		if (!link_working_unknown(l_ptr) &&
 		    (l_ptr->peer_session != INVALID_SESSION)) {
-			if (msg_session(msg) == l_ptr->peer_session) {
-				dbg("Duplicate RESET: %u<->%u\n",
+			if (less_eq(msg_session(msg), l_ptr->peer_session)) {
+				dbg("Duplicate or old RESET: %u<->%u\n",
 				    msg_session(msg), l_ptr->peer_session);
-				break; /* duplicate: ignore */
+				break; /* duplicate or old reset: ignore */
 			}
 		}
+
+		if (!msg_redundant_link(msg) &&
+		    (link_working_working(l_ptr) ||
+		     link_working_unknown(l_ptr)))
+			l_ptr->owner->block_setup = WAIT_NODE_DOWN;
+			/* peer has lost contact -- don't allow peer's links
+			   to reactivate before we recognize loss & clean up */
+
+		link_state_event(l_ptr, RESET_MSG);
                 if (msg_stop(msg)) {
-                        tipc_link_reset(l_ptr);
                         l_ptr->blocked = 1;
                         tipc_k_signal((Handler)link_remote_delete,(unsigned long)l_ptr);
                         break;
                 }
-
 		/* fall thru' */
 	case ACTIVATE_MSG:
 		/* Update link settings according other endpoint's values */
@@ -2281,23 +2361,22 @@ static void link_recv_proto_msg(struct link *l_ptr, struct sk_buff *buf)
 		} else {
 			l_ptr->max_pkt = l_ptr->max_pkt_target;
 		}
-		l_ptr->owner->bclink.supported = 
-			in_own_cluster(l_ptr->owner->elm.addr) &&
-			(max_pkt_info != 0);
-
-		link_state_event(l_ptr, msg_type(msg));
+		l_ptr->owner->bclink.supportable = (char)(max_pkt_info != 0);
 
-		l_ptr->peer_session = msg_session(msg);
-		l_ptr->peer_bearer_id = msg_bearer_id(msg);
+		/* Synchronize broadcast link info, if not done previously */
 
-		/* Synchronize broadcast link information */
-
-		if (!tipc_node_has_redundant_links(l_ptr->owner)) {
+		if (!tipc_node_is_up(l_ptr->owner)) {
 			l_ptr->owner->bclink.last_sent =
 				l_ptr->owner->bclink.last_in =
 				msg_last_bcast(msg);
 			l_ptr->owner->bclink.oos_state = 0;
 		}
+
+		l_ptr->peer_session = msg_session(msg);
+		l_ptr->peer_bearer_id = msg_bearer_id(msg);
+
+		if (msg_type(msg) == ACTIVATE_MSG)
+			link_state_event(l_ptr, ACTIVATE_MSG);
 		break;
 	case STATE_MSG:
 
@@ -2345,8 +2424,8 @@ static void link_recv_proto_msg(struct link *l_ptr, struct sk_buff *buf)
 						      msg_last_bcast(msg));
 
 		if (rec_gap || (msg_probe(msg))) {
-			tipc_link_send_proto_msg(l_ptr, STATE_MSG,
-					    0, rec_gap, 0, 0, max_pkt_ack, 0);
+			tipc_link_send_proto_msg(l_ptr,
+				STATE_MSG, 0, rec_gap, 0, 0, max_pkt_ack);
 		}
 		if (msg_seq_gap(msg)) {
 			msg_dbg(msg, "With Gap:");
@@ -2662,6 +2741,8 @@ void tipc_link_recv_bundle(struct sk_buff *buf)
  */
 int tipc_link_send_long_buf(struct link *l_ptr, struct sk_buff *buf)
 {
+	struct sk_buff *buf_chain = NULL;
+	struct sk_buff *buf_chain_tail = (struct sk_buff *)&buf_chain;
 	struct tipc_msg *inmsg = buf_msg(buf);
 	struct tipc_msg fragm_hdr;
 	u32 insize = msg_size(inmsg);
@@ -2670,7 +2751,7 @@ int tipc_link_send_long_buf(struct link *l_ptr, struct sk_buff *buf)
 	u32 rest = insize;
 	u32 pack_sz = l_ptr->max_pkt;
 	u32 fragm_sz = pack_sz - INT_H_SIZE;
-	u32 fragm_no = 1;
+	u32 fragm_no = 0;
 	u32 destaddr;
 
 	if (msg_short(inmsg))
@@ -2688,8 +2769,6 @@ int tipc_link_send_long_buf(struct link *l_ptr, struct sk_buff *buf)
 	msg_set_link_selector(&fragm_hdr, msg_link_selector(inmsg));
 	msg_set_fragm_msg_no(&fragm_hdr, 
 			     atomic_inc_return(&link_fragm_msg_no) & 0xffff);
-	msg_set_fragm_no(&fragm_hdr, fragm_no);
-	l_ptr->stats.sent_fragmented++;
 
 	/* Chop up message: */
 
@@ -2702,28 +2781,35 @@ int tipc_link_send_long_buf(struct link *l_ptr, struct sk_buff *buf)
 		}
 		fragm = buf_acquire(fragm_sz + INT_H_SIZE);
 		if (fragm == NULL) {
-			warn("Link unable to fragment message\n");
-			dsz = -ENOMEM;
-			goto exit;
+			buf_discard(buf);
+			while (buf_chain) {
+				buf = buf_chain;
+				buf_chain = buf_chain->next;
+				buf_discard(buf);
+			}
+			return -ENOMEM;
 		}
 		msg_set_size(&fragm_hdr, fragm_sz + INT_H_SIZE);
+		msg_set_fragm_no(&fragm_hdr, ++fragm_no);
 		skb_copy_to_linear_data(fragm, &fragm_hdr, INT_H_SIZE);
 		skb_copy_to_linear_data_offset(fragm, INT_H_SIZE, crs,
 					       fragm_sz);
+		buf_chain_tail->next = fragm;
+		buf_chain_tail = fragm;
 
-		/*  Send queued messages first, if any: */
-
-		l_ptr->stats.sent_fragments++;
-		tipc_link_send_buf(l_ptr, fragm);
-		if (!tipc_link_is_up(l_ptr))
-			return dsz;
-		msg_set_fragm_no(&fragm_hdr, ++fragm_no);
 		rest -= fragm_sz;
 		crs += fragm_sz;
 		msg_set_type(&fragm_hdr, FRAGMENT);
 	}
-exit:
 	buf_discard(buf);
+
+	/* Append chain of fragments to send queue & send them */
+
+	link_add_chain_to_outqueue(l_ptr, buf_chain);
+	l_ptr->stats.sent_fragments += fragm_no;
+	l_ptr->stats.sent_fragmented++;
+	tipc_link_push_queue(l_ptr);
+
 	return dsz;
 }
 
@@ -2736,7 +2822,7 @@ exit:
 
 static inline u32 get_long_msg_orig(struct sk_buff *buf)
 {
-	return (u32)(unsigned long)buf_handle(buf);
+	return (u32)(unsigned long)(char *)buf_handle(buf);
 }
 
 static inline void set_long_msg_orig(struct sk_buff *buf, u32 orig)
@@ -2843,7 +2929,9 @@ int tipc_link_recv_fragment(struct sk_buff **pending, struct sk_buff **fb,
 			set_expected_frags(pbuf,exp_fragm_cnt - 1); 
 			reset_timer_cnt(pbuf);
 		} else {
-			warn("Link unable to reassemble fragmented message\n");
+			dbg("Link unable to reassemble fragmented message\n");
+			buf_discard(fbuf);
+			return -1;
 		}
 		buf_discard(fbuf);
 		return 0;
@@ -2871,7 +2959,7 @@ int tipc_link_recv_fragment(struct sk_buff **pending, struct sk_buff **fb,
 		set_expected_frags(pbuf,exp_frags);
 		return 0;
 	}
-	dbg(" Discarding orphan fragment %x\n",fbuf);
+	dbg(" Discarding orphan fragment %p\n",fbuf);
 	msg_dbg(fragm,"ORPHAN:");
 	dbg("Pending long buffers:\n");
 	dbg_print_buf_chain(*pending);
@@ -2921,10 +3009,17 @@ static void link_check_defragm_bufs(struct link *l_ptr)
 
 static void link_set_supervision_props(struct link *l_ptr, u32 tolerance)
 {
+	if ((tolerance < TIPC_MIN_LINK_TOL) || (tolerance > TIPC_MAX_LINK_TOL))
+		return;
+
 	l_ptr->tolerance = tolerance;
 	l_ptr->continuity_interval =
 		((tolerance / 4) > 500) ? 500 : tolerance / 4;
 	l_ptr->abort_limit = tolerance / (l_ptr->continuity_interval / 4);
+
+#if (TIPC_MIN_LINK_TOL < 16)
+	#error "TIPC_MIN_LINK_TOL is too small (abort limit may be NaN)"
+#endif
 }
 
 
@@ -3001,8 +3096,8 @@ static int value_is_valid(u16 cmd, u32 new_value)
 		return (new_value >= TIPC_MIN_LINK_TOL) &&
 			(new_value <= TIPC_MAX_LINK_TOL);
 	case TIPC_CMD_SET_LINK_PRI:
-		return (new_value >= TIPC_MIN_LINK_PRI) &&
-			(new_value <= TIPC_MAX_LINK_PRI);
+		assert(TIPC_MIN_LINK_PRI == 0);
+		return (new_value <= TIPC_MAX_LINK_PRI);
 	case TIPC_CMD_SET_LINK_WINDOW:
 		return (new_value >= TIPC_MIN_LINK_WIN) &&
 			(new_value <= TIPC_MAX_LINK_WIN);
@@ -3038,13 +3133,13 @@ static int cmd_set_link_value(const char *name, u32 new_value, u16 cmd)
 		switch (cmd) {
 		case TIPC_CMD_SET_LINK_TOL:
 			link_set_supervision_props(l_ptr, new_value);
-			tipc_link_send_proto_msg(l_ptr, STATE_MSG,
-				0, 0, new_value, 0, 0, 0);
+			tipc_link_send_proto_msg(l_ptr,
+				STATE_MSG, 0, 0, new_value, 0, 0);
 			break;
 		case TIPC_CMD_SET_LINK_PRI:
 			l_ptr->priority = new_value;
-			tipc_link_send_proto_msg(l_ptr, STATE_MSG,
-				0, 0, 0, new_value, 0, 0);
+			tipc_link_send_proto_msg(l_ptr,
+				STATE_MSG, 0, 0, 0, new_value, 0);
 			break;
 		case TIPC_CMD_SET_LINK_WINDOW:
 			tipc_link_set_queue_limits(l_ptr, new_value);
@@ -3088,7 +3183,7 @@ static int cmd_set_link_value(const char *name, u32 new_value, u16 cmd)
 }
 
 
-struct sk_buff *tipc_link_cmd_config(const void *req_tlv_area, int req_tlv_space,
+struct sk_buff *tipc_link_cmd_config(const void *req_tlv_area, u32 req_tlv_space,
 				     u16 cmd)
 {
 	struct tipc_link_config *args;
@@ -3137,7 +3232,7 @@ static void link_reset_statistics(struct link *l_ptr)
 
 #ifdef CONFIG_TIPC_CONFIG_SERVICE
 
-struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area, int req_tlv_space)
+struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area, u32 req_tlv_space)
 {
 	char *link_name;
 	struct link *l_ptr;
@@ -3167,103 +3262,6 @@ struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area, int req_tlv_
 	return tipc_cfg_reply_none();
 }
 
-#ifdef PROTO_MULTI_DISCOVERY_OBJECT
-struct sk_buff *tipc_link_cmd_delete(const void *req_tlv_area, int req_tlv_space)
-{
-        char *cmd_str;
-	char *link_name;
-	struct link *l_ptr,*temp_l_ptr;
-	struct tipc_node *n_ptr;
-        struct bearer *b_ptr;
-	char *if_name,*domain_str;
-	char  cmd[TIPC_MAX_LINK_NAME + 1];
-        u32 domain,zone,cluster,node;
-
-	if (!TLV_CHECK(req_tlv_area, req_tlv_space, TIPC_TLV_LINK_NAME))
-		return tipc_cfg_reply_error_string(TIPC_CFG_TLV_ERROR);
-
-        cmd_str = (char*) TLV_DATA(req_tlv_area);
-        strncpy(cmd,cmd_str,sizeof(cmd));
-
-	link_name = cmd_str;
-	if (!strcmp(link_name, tipc_bclink_name)) {
-		if (tipc_bclink_reset_stats())
-			return tipc_cfg_reply_error_string("link not found");
-		return tipc_cfg_reply_none();
-	}
-
-        write_lock_bh(&tipc_net_lock);
-
-        /* Scope comprising several links ? */
-
-        if (strchr(link_name,'/') != NULL)
-                goto error;
-
-        if (strchr(link_name,'-') == NULL) {
-
-                if_name = cmd_str;
-
-                domain_str = strchr(if_name,',');
-                if (domain_str == NULL)
-                        goto error;
-                *domain_str = 0;
-                domain_str++;
-
-                if (sscanf(domain_str,"%u.%u.%u",&zone,&cluster,&node) != 3)
-                        goto error;
-
-                domain = tipc_addr(zone,cluster,node);
-
-                if (!tipc_addr_domain_valid(domain))
-                        goto error;
-
-                b_ptr = tipc_bearer_find(if_name);
-
-                if (b_ptr == NULL) 
-                        goto error;
-        } else {
-                l_ptr = link_find_link(link_name, &n_ptr); 
-                if (!l_ptr) 
-                        goto error;
-                domain = l_ptr->addr;
-                b_ptr = l_ptr->b_ptr;
-        }
-
-        if (in_own_cluster(domain))
-                goto error;
-
-	spin_lock_bh(&b_ptr->publ.lock);
-
-        tipc_bearer_remove_discoverer(b_ptr,domain);
-
-	list_for_each_entry_safe(l_ptr, temp_l_ptr, &b_ptr->links, link_list) {
-
-                if (tipc_in_scope(domain,l_ptr->addr)) {
-                        if (in_own_cluster(l_ptr->addr))
-                                continue;
-                        n_ptr = l_ptr->owner;
-                        tipc_node_lock(n_ptr);
-                        tipc_link_reset(l_ptr);
-
-                        /* Tell other end to not re-establish */
-
-                        tipc_link_send_proto_msg(l_ptr,RESET_MSG, 
-                                                 0, 0, 0, 0, 0, 1);
-                        l_ptr->blocked = 1;
-                        tipc_node_unlock(n_ptr);
-                        tipc_link_delete(l_ptr);
-                }
-	}
-	spin_unlock_bh(&b_ptr->publ.lock);
-	write_unlock_bh(&tipc_net_lock);
-	return tipc_cfg_reply_none();
-
- error:
-	write_unlock_bh(&tipc_net_lock);
-        return tipc_cfg_reply_error_string(TIPC_CFG_TLV_ERROR);
-}
-#endif
-
 /**
  * percent - convert count to a percentage of total (rounding up or down)
  */
@@ -3282,7 +3280,8 @@ static u32 percent(u32 count, u32 total)
  * Returns length of print buffer data string (or 0 if error)
  */
 
-static int tipc_link_stats(const char *name, char *buf, const u32 buf_size)
+static size_t tipc_link_stats(const char *name, char *buf,
+			      const size_t buf_size)
 {
 	struct print_buf pb;
 	struct link *l_ptr;
@@ -3368,11 +3367,11 @@ static int tipc_link_stats(const char *name, char *buf, const u32 buf_size)
 
 #define MAX_LINK_STATS_INFO 2000
 
-struct sk_buff *tipc_link_cmd_show_stats(const void *req_tlv_area, int req_tlv_space)
+struct sk_buff *tipc_link_cmd_show_stats(const void *req_tlv_area, u32 req_tlv_space)
 {
 	struct sk_buff *buf;
 	struct tlv_desc *rep_tlv;
-	int str_len;
+	size_t str_len;
 
 	if (!TLV_CHECK(req_tlv_area, req_tlv_space, TIPC_TLV_LINK_NAME))
 		return tipc_cfg_reply_error_string(TIPC_CFG_TLV_ERROR);
@@ -3398,45 +3397,6 @@ struct sk_buff *tipc_link_cmd_show_stats(const void *req_tlv_area, int req_tlv_s
 
 #endif
 
-#if 0
-int link_control(const char *name, u32 op, u32 val)
-{
-	int res = -EINVAL;
-	struct link *l_ptr;
-	u32 bearer_id;
-	struct tipc_node *node;
-	u32 a;
-
-	a = link_name2addr(name, &bearer_id);
-	read_lock_bh(&tipc_net_lock);
-	node = tipc_net_find_node(a);
-
-	if (node) {
-		tipc_node_lock(node);
-		l_ptr = node->links[bearer_id];
-		if (l_ptr) {
-			if (op == TIPC_REMOVE_LINK) {
-				struct bearer *b_ptr = l_ptr->b_ptr;
-				spin_lock_bh(&b_ptr->publ.lock);
-				tipc_link_delete(l_ptr);
-				spin_unlock_bh(&b_ptr->publ.lock);
-			}
-			if (op == TIPC_CMD_BLOCK_LINK) {
-				tipc_link_reset(l_ptr);
-				l_ptr->blocked = 1;
-			}
-			if (op == TIPC_CMD_UNBLOCK_LINK) {
-				l_ptr->blocked = 0;
-			}
-			res = 0;
-		}
-		tipc_node_unlock(node);
-	}
-	read_unlock_bh(&tipc_net_lock);
-	return res;
-}
-#endif
-
 /**
  * tipc_link_get_max_pkt - get maximum packet size to use when sending to destination
  * @dest: network address of destination node
@@ -3467,28 +3427,6 @@ u32 tipc_link_get_max_pkt(u32 dest, u32 selector)
 	return res;
 }
 
-#if 0
-static void link_dump_rec_queue(struct link *l_ptr)
-{
-	struct sk_buff *crs;
-
-	if (!l_ptr->oldest_deferred_in) {
-		info("Reception queue empty\n");
-		return;
-	}
-	info("Contents of Reception queue:\n");
-	crs = l_ptr->oldest_deferred_in;
-	while (crs) {
-		if (crs->data == (void *)0x0000a3a3) {
-			info("buffer %x invalid\n", crs);
-			return;
-		}
-		msg_dbg(buf_msg(crs), "In rec queue: \n");
-		crs = crs->next;
-	}
-}
-#endif
-
 #ifdef CONFIG_TIPC_DEBUG
 
 static void link_dump_send_queue(struct link *l_ptr)
@@ -3525,9 +3463,9 @@ static void dbg_print_link_state(struct print_buf *buf, struct link *l_ptr)
 		     != (l_ptr->out_queue_size - 1))
 		    || (l_ptr->last_out->next != 0)) {
 			tipc_printf(buf, "\nSend queue inconsistency\n");
-			tipc_printf(buf, "first_out= %x ", l_ptr->first_out);
-			tipc_printf(buf, "next_out= %x ", l_ptr->next_out);
-			tipc_printf(buf, "last_out= %x ", l_ptr->last_out);
+			tipc_printf(buf, "first_out= %p ", l_ptr->first_out);
+			tipc_printf(buf, "next_out= %p ", l_ptr->next_out);
+			tipc_printf(buf, "last_out= %p ", l_ptr->last_out);
 			link_dump_send_queue(l_ptr);
 		}
 	} else
diff --git a/net/tipc/tipc_link.h b/net/tipc/tipc_link.h
index c0fefdc..19277cd 100644
--- a/net/tipc/tipc_link.h
+++ b/net/tipc/tipc_link.h
@@ -2,7 +2,7 @@
  * net/tipc/tipc_link.h: Include file for TIPC link code
  *
  * Copyright (c) 1995-2006, Ericsson AB
- * Copyright (c) 2004-2008, Wind River Systems
+ * Copyright (c) 2004-2008, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -46,6 +46,12 @@
 #define PUSH_FINISHED 2
 
 /*
+ * Out-of-range value for link sequence numbers
+ */
+
+#define INVALID_LINK_SEQ 0x10000
+
+/*
  * Link states
  */
 
@@ -197,22 +203,12 @@ struct link {
 		u32 bearer_congs;
 		u32 deferred_recv;
 		u32 duplicates;
-
-		/* for statistical profiling of send queue size */
-
-		u32 max_queue_sz;
-		u32 accu_queue_sz;
-		u32 queue_sz_counts;
-
-		/* for statistical profiling of message lengths */
-
-		u32 msg_length_counts;
-		u32 msg_lengths_total;
-		u32 msg_length_profile[7];
-#if 0
-		u32 sent_tunneled;
-		u32 recv_tunneled;
-#endif
+		u32 max_queue_sz;	/* send queue size high water mark */
+		u32 accu_queue_sz;	/* used for send queue size profiling */
+		u32 queue_sz_counts;	/* used for send queue size profiling */
+		u32 msg_length_counts;	/* used for message length profiling */
+		u32 msg_lengths_total;	/* used for message length profiling */
+		u32 msg_length_profile[7]; /* used for msg. length profiling */
 	} stats;
 
 	struct print_buf print_buf;
@@ -220,7 +216,7 @@ struct link {
 
 struct port;
 
-struct link *tipc_link_create(struct bearer *b_ptr, const u32 peer,
+struct link *tipc_link_create(struct tipc_node *n_ptr, struct bearer *b_ptr,
 			      const struct tipc_media_addr *media_addr);
 void tipc_link_delete(struct link *l_ptr);
 void tipc_link_changeover(struct link *l_ptr);
@@ -231,12 +227,13 @@ int tipc_link_is_active(struct link *l_ptr);
 void tipc_link_start(struct link *l_ptr);
 u32 tipc_link_push_packet(struct link *l_ptr);
 void tipc_link_stop(struct link *l_ptr);
-struct sk_buff *tipc_link_cmd_delete(const void *req_tlv_area, int req_tlv_space);
-struct sk_buff *tipc_link_cmd_config(const void *req_tlv_area, int req_tlv_space, u16 cmd);
-struct sk_buff *tipc_link_cmd_show_stats(const void *req_tlv_area, int req_tlv_space);
-struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area, int req_tlv_space);
+struct sk_buff *tipc_link_cmd_delete(const void *req_tlv_area, u32 req_tlv_space);
+struct sk_buff *tipc_link_cmd_config(const void *req_tlv_area, u32 req_tlv_space, u16 cmd);
+struct sk_buff *tipc_link_cmd_show_stats(const void *req_tlv_area, u32 req_tlv_space);
+struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area, u32 req_tlv_space);
 void tipc_link_reset(struct link *l_ptr);
 int tipc_link_send(struct sk_buff *buf, u32 dest, u32 selector);
+void tipc_link_send_names(struct list_head *message_list, u32 dest);
 int tipc_link_send_buf(struct link *l_ptr, struct sk_buff *buf);
 u32 tipc_link_get_max_pkt(u32 dest,u32 selector);
 int tipc_link_send_sections_fast(struct port* sender,
@@ -249,7 +246,7 @@ int  tipc_link_recv_fragment(struct sk_buff **pending,
 			     struct sk_buff **fb,
 			     struct tipc_msg **msg);
 void tipc_link_send_proto_msg(struct link *l_ptr, u32 msg_typ, int prob, u32 gap,
-			      u32 tolerance, u32 priority, u32 acked_mtu, int stop);
+			      u32 tolerance, u32 priority, u32 acked_mtu);
 void tipc_link_push_queue(struct link *l_ptr);
 u32 tipc_link_defer_pkt(struct sk_buff **head, struct sk_buff **tail,
 			struct sk_buff *buf, u32 buf_seq_no);
diff --git a/net/tipc/tipc_msg.c b/net/tipc/tipc_msg.c
index a4f24b6..cf1c5f6 100644
--- a/net/tipc/tipc_msg.c
+++ b/net/tipc/tipc_msg.c
@@ -2,7 +2,7 @@
  * net/tipc/msg.c: TIPC message header routines
  *
  * Copyright (c) 2000-2006, Ericsson AB
- * Copyright (c) 2005-2007, Wind River Systems
+ * Copyright (c) 2005-2007, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -53,7 +53,8 @@ int tipc_msg_build(struct tipc_msg *hdr,
 		   struct iovec const *msg_sect, u32 num_sect,
 		   int max_size, int usrmem, struct sk_buff** buf)
 {
-	int dsz, sz, hsz, pos, res, cnt;
+	int dsz, sz, hsz, pos, res;
+	u32 cnt;
 
 	dsz = tipc_msg_calc_data_size(msg_sect, num_sect);
 	if (unlikely(dsz > TIPC_MAX_USER_MSG_SIZE)) {
@@ -80,9 +81,9 @@ int tipc_msg_build(struct tipc_msg *hdr,
 					      msg_sect[cnt].iov_len);
 		else
 			skb_copy_to_linear_data_offset(*buf, pos,
-						       msg_sect[cnt].iov_base,
-						       msg_sect[cnt].iov_len);
-		pos += msg_sect[cnt].iov_len;
+					msg_sect[cnt].iov_base,
+					(unsigned int)msg_sect[cnt].iov_len);
+		pos += (int)msg_sect[cnt].iov_len;
 	}
 	if (likely(res))
 		return dsz;
@@ -115,10 +116,10 @@ void tipc_msg_init(struct tipc_msg *m, u32 user, u32 type,
 int tipc_msg_calc_data_size(struct iovec const *msg_sect, u32 num_sect)
 {
 	int dsz = 0;
-	int i;
+	u32 i;
 
 	for (i = 0; i < num_sect; i++)
-		dsz += msg_sect[i].iov_len;
+		dsz += (int)msg_sect[i].iov_len;
 	return dsz;
 }
 
diff --git a/net/tipc/tipc_msg.h b/net/tipc/tipc_msg.h
index d94c614..8698080 100644
--- a/net/tipc/tipc_msg.h
+++ b/net/tipc/tipc_msg.h
@@ -542,12 +542,12 @@ static inline void msg_set_probe(struct tipc_msg *m, u32 val)
 	msg_set_bits(m, 5, 0, 1, (val & 1));
 }
 
-static inline char msg_net_plane(struct tipc_msg *m)
+static inline unsigned char msg_net_plane(struct tipc_msg *m)
 {
-	return msg_bits(m, 5, 1, 7) + 'A';
+	return (unsigned char)(msg_bits(m, 5, 1, 7) + 'A');
 }
 
-static inline void msg_set_net_plane(struct tipc_msg *m, char n)
+static inline void msg_set_net_plane(struct tipc_msg *m, unsigned char n)
 {
 	msg_set_bits(m, 5, 1, 7, (n - 'A'));
 }
diff --git a/net/tipc/tipc_name_distr.c b/net/tipc/tipc_name_distr.c
index dc62a0f..1810313 100644
--- a/net/tipc/tipc_name_distr.c
+++ b/net/tipc/tipc_name_distr.c
@@ -2,7 +2,7 @@
  * net/tipc/tipc_name_distr.c: TIPC name distribution code
  * 
  * Copyright (c) 2000-2006, Ericsson AB
- * Copyright (c) 2005-2008, Wind River Systems
+ * Copyright (c) 2005-2008, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -69,7 +69,7 @@
 typedef struct 
 {
 	struct list_head list;
-	int list_size;
+	u32 list_size;
 } dist_list_t;
  
 
@@ -167,7 +167,7 @@ static dist_list_t dist_name_list[NUM_DIST_LISTS] = {
  */
 
 static void name_to_item(struct publication *publ, int dist_mask,
-			 unchar *item, int item_size)
+			 unchar *item, u32 item_size)
 {
 	struct name_item *i = (struct name_item *)item;
 
@@ -210,10 +210,10 @@ static void item_to_name(struct publication *publ, int *dist_mask,
  * named_prepare_buf - allocate & initialize a name info message
  */
 
-static struct sk_buff *named_prepare_buf(u32 type, u32 num_items, int item_size, 
+static struct sk_buff *named_prepare_buf(u32 type, u32 num_items, u32 item_size, 
 					 u32 dest)
 {
-	u32 size = LONG_H_SIZE + num_items * (item_size * sizeof(u32));
+	u32 size = (u32)(LONG_H_SIZE + num_items * (item_size * sizeof(u32)));
 	struct sk_buff *buf = buf_acquire(size);  
 	struct tipc_msg *msg;
 
@@ -259,14 +259,14 @@ void tipc_named_remove_publ(struct publication *publ)
  */
 
 static void named_distribute(struct list_head *delivery_list, u32 dest_node,
-			     int dist_list_id, int dist_mask, int item_size)
+			     int dist_list_id, int dist_mask, u32 item_size)
 {
 	struct publication *publ;
 	struct sk_buff *buf = NULL;
 	unchar *item = NULL;
 	u32 buf_todo_items = 0;
-	u32 name_items_max = MAX_DIST_MSG_DATA / (item_size * sizeof(u32));
-	int list_cnt;
+	u32 name_items_max = (u32)(MAX_DIST_MSG_DATA/(item_size * sizeof(u32)));
+	u32 list_cnt;
 
 	list_cnt = dist_name_list[dist_list_id].list_size;
 
@@ -299,10 +299,9 @@ static void named_distribute(struct list_head *delivery_list, u32 dest_node,
  * tipc_named_node_up - tell specified node about relevant name info
  */
 
-void tipc_named_node_up(unsigned long node)
+void tipc_named_node_up(unsigned long node_arg)
 {
-	struct sk_buff *buf;
-	struct sk_buff *temp_buf;
+	u32 node = (u32)node_arg;
 	struct list_head delivery_list;
 
 	INIT_LIST_HEAD(&delivery_list);
@@ -352,23 +351,17 @@ void tipc_named_node_up(unsigned long node)
 
 	read_unlock_bh(&tipc_nametbl_lock); 
 
-	list_for_each_safe(buf, temp_buf, ((struct sk_buff *)&delivery_list)) {
-		list_del((struct list_head *)buf);
-		if (tipc_link_send(buf, node, node) < 0) {
-			warn("Bulk publication not sent\n");
-		}
-	}
+	tipc_link_send_names(&delivery_list, node);
 }
 
 /**
  * tipc_named_node_up_uni - tell uni-cluster node about relevant name info
  */
 
-void tipc_named_node_up_uni(unsigned long node)
+void tipc_named_node_up_uni(unsigned long node_arg)
 {
 #ifdef CONFIG_TIPC_UNICLUSTER_FRIENDLY
-	struct sk_buff *buf;
-	struct sk_buff *temp_buf;
+	u32 node = (u32)node_arg;
 	struct list_head delivery_list;
 
 	INIT_LIST_HEAD(&delivery_list);
@@ -384,12 +377,7 @@ void tipc_named_node_up_uni(unsigned long node)
 
 	read_unlock_bh(&tipc_nametbl_lock); 
 
-	list_for_each_safe(buf, temp_buf, ((struct sk_buff *)&delivery_list)) {
-		list_del((struct list_head *)buf);
-		if (tipc_link_send(buf, node, node) < 0) {
-			warn("Bulk publication not sent\n");
-		}
-	}
+	tipc_link_send_names(&delivery_list, node);
 #endif
 }
 
@@ -397,18 +385,17 @@ void tipc_named_node_up_uni(unsigned long node)
  * named_cluster_distribute - send name to all adjacent cluster nodes
  */
 
-static void named_cluster_distribute(struct publication *publ, int msg_type,
-				     int dist_mask)
+static int named_cluster_distribute(struct publication *publ, int msg_type,
+				    int dist_mask)
 {
 	struct sk_buff *buf;
+	int res;
 
 	dist_mask &= ~TIPC_DIST_TO_CLUSTER;
 
 	buf = named_prepare_buf(msg_type, 1, NAME_ITEM_SIZE, tipc_addr(0, 0, 0));
-	if (!buf) {
-		warn("Memory squeeze; failed to distribute publication\n");
-		return;
-	}
+	if (!buf)
+		return -ENOMEM;
 
 	name_to_item(publ, dist_mask, msg_data(buf_msg(buf)), NAME_ITEM_SIZE);
 
@@ -445,7 +432,7 @@ static void named_cluster_distribute(struct publication *publ, int msg_type,
 		}
 
 		buf_discard(buf);
-		return;
+		return 0;
 	}
 #endif
 
@@ -456,9 +443,8 @@ static void named_cluster_distribute(struct publication *publ, int msg_type,
 	 * of the lone name item, so the "new style" form is OK here
 	 */
 
-	if (tipc_bclink_send_msg(buf) < 0) {
-		warn("Publication distribution to cluster failed\n");
-	}
+	res = tipc_bclink_send_msg(buf);
+	return (res < 0) ? res : 0;
 }
 
 /**
@@ -536,14 +522,15 @@ static void named_network_distribute(struct publication *publ, int msg_type,
  * tipc_named_distribute - send name info to relevant nodes
  */
 
-void tipc_named_distribute(struct publication *publ, int msg_type,
-			   int dist_mask)
+int tipc_named_distribute(struct publication *publ, int msg_type,
+			  int dist_mask)
 {
-	if (tipc_mode != TIPC_NET_MODE)
-		return;
+	int res = 0;
 
+	if (tipc_mode != TIPC_NET_MODE)
+		return res;
 	if (dist_mask & TIPC_DIST_TO_CLUSTER) {
-		named_cluster_distribute(publ, msg_type, dist_mask);
+		res = named_cluster_distribute(publ, msg_type, dist_mask);
 	}
 	if (dist_mask & TIPC_DIST_TO_ZONE) {
 		named_zone_distribute(publ, msg_type, dist_mask);
@@ -551,6 +538,7 @@ void tipc_named_distribute(struct publication *publ, int msg_type,
 	if (dist_mask & TIPC_DIST_TO_NETWORK) {
 		named_network_distribute(publ, msg_type, dist_mask);
 	}
+	return res;
 }
 
 /**
@@ -561,9 +549,6 @@ void tipc_named_distribute(struct publication *publ, int msg_type,
  * In rare cases the link may have come back up again when this
  * function is called, and we have two items representing the same
  * publication. Nudge this item's key to distinguish it from the other.
- *
- * Publication's network element subscription is already unsubscribed, 
- * so we don't have to do that here ...
  */
 
 static void named_purge_publ(struct publication *publ)
@@ -574,6 +559,7 @@ static void named_purge_publ(struct publication *publ)
 	publ = tipc_nametbl_remove_publ(publ->type, publ->lower, 
 					publ->node, publ->ref, publ->key);
 	if (publ != NULL) {
+		tipc_netsub_unbind(&publ->subscr);
 		tipc_named_remove_publ(publ);
 	}
 
@@ -593,8 +579,8 @@ void tipc_named_recv(struct sk_buff *buf)
 	struct tipc_msg *msg = buf_msg(buf);
 	u32 type = msg_type(msg);
 	unchar *item = msg_data(msg);
-	int item_size = msg_item_size(msg);
-	int item_size_min = NAME_ITEM_SIZE;
+	u32 item_size = msg_item_size(msg);
+	u32 item_size_min = NAME_ITEM_SIZE;
 	u32 item_count;
 	int dist_mask;
 
@@ -612,7 +598,7 @@ void tipc_named_recv(struct sk_buff *buf)
 		warn("Invalid name table item received\n");
 		item_count = 0;
 	} else {
-		item_count = msg_data_sz(msg) / (item_size * sizeof(u32));
+		item_count = (u32)(msg_data_sz(msg)/(item_size * sizeof(u32)));
 	}
 
 	while (item_count--) {
@@ -739,7 +725,7 @@ struct route_item {
 };
 
 #define ROUTE_ITEM_SIZE     4
-#define ROUTE_ITEM_BYTES    (ROUTE_ITEM_SIZE * sizeof(u32))
+#define ROUTE_ITEM_BYTES    ((u32)(ROUTE_ITEM_SIZE * sizeof(u32)))
 #define ROUTE_ITEMS_MAX     (MAX_DIST_MSG_DATA / ROUTE_ITEM_BYTES)
 
 /*
@@ -803,7 +789,7 @@ static void item_to_route(struct publication *publ, int *dist_mask,
 
 static struct sk_buff *route_prepare_buf(u32 type, u32 num_items, u32 dest)
 {
-	u32 size = LONG_H_SIZE + (num_items * ROUTE_ITEM_BYTES);
+	u32 size = (u32)(LONG_H_SIZE + (num_items * ROUTE_ITEM_BYTES));
 	struct sk_buff *buf = buf_acquire(size);  
 	struct tipc_msg *msg;
 
@@ -856,7 +842,7 @@ static void route_distribute(struct list_head *delivery_list, u32 dest_node,
 	struct sk_buff *buf = NULL;
 	unchar *item = NULL;
 	u32 buf_todo_items = 0;
-	int list_cnt = dist_route_list[dist_list_id].list_size;
+	u32 list_cnt = dist_route_list[dist_list_id].list_size;
 
 	list_for_each_entry(publ, &dist_route_list[dist_list_id].list,
 			    distr_list) {
@@ -887,8 +873,9 @@ static void route_distribute(struct list_head *delivery_list, u32 dest_node,
  * tipc_route_node_up - tell specified node about relevant routes
  */
 
-void tipc_route_node_up(unsigned long node)
+void tipc_route_node_up(unsigned long node_arg)
 {
+	u32 node = (u32)node_arg;
 	struct sk_buff *buf;
 	struct sk_buff *temp_buf;
 	struct list_head delivery_list;
@@ -1045,9 +1032,6 @@ void tipc_route_distribute(struct publication *publ, int msg_type,
  * In rare cases the link may have come back up again when this
  * function is called, and we have two items representing the same
  * publication. Nudge this item's key to distinguish it from the other.
- *
- * Publication's network element subscription is already unsubscribed, 
- * so we don't have to do that here ...
  */
 
 static void route_purge_publ(struct publication *publ)
@@ -1058,6 +1042,7 @@ static void route_purge_publ(struct publication *publ)
 	publ = tipc_nameseq_remove_publ(route_table,publ->lower, 
 					publ->node, publ->ref, publ->key);
 	if (publ != NULL) {
+		tipc_netsub_unbind(&publ->subscr);
 		tipc_all_routes--;
 		tipc_route_remove_publ(publ);
 	}
@@ -1086,7 +1071,7 @@ void tipc_route_recv(struct sk_buff *buf)
 		warn("Invalid routing table item received\n");
 		item_count = 0;
 	} else {
-		item_count = msg_data_sz(msg) / (item_size * sizeof(u32));
+		item_count = (u32)(msg_data_sz(msg)/(item_size * sizeof(u32)));
 	}
 
 	while (item_count--) {
diff --git a/net/tipc/tipc_name_distr.h b/net/tipc/tipc_name_distr.h
index cbaf23e..ce93228 100644
--- a/net/tipc/tipc_name_distr.h
+++ b/net/tipc/tipc_name_distr.h
@@ -47,7 +47,7 @@
 
 void tipc_named_insert_publ(struct publication *publ);
 void tipc_named_remove_publ(struct publication *publ);
-void tipc_named_distribute(struct publication *publ, int msg_type,
+int tipc_named_distribute(struct publication *publ, int msg_type,
 			   int dist_mask);
 void tipc_named_node_up(unsigned long node);
 void tipc_named_node_up_uni(unsigned long node);
diff --git a/net/tipc/tipc_name_table.c b/net/tipc/tipc_name_table.c
index b526cdf..ab38af0 100644
--- a/net/tipc/tipc_name_table.c
+++ b/net/tipc/tipc_name_table.c
@@ -2,7 +2,7 @@
  * net/tipc/tipc_name_table.c: TIPC name table code
  *
  * Copyright (c) 2000-2006, Ericsson AB
- * Copyright (c) 2004-2008, Wind River Systems
+ * Copyright (c) 2004-2008, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -51,6 +51,8 @@
 
 static int tipc_nametbl_size = 1024;		/* must be a power of 2 */
 
+#define WITH_TIMER_ACTIVE     10	/* withdrawl reattempt period (in ms) */
+
 /**
  * struct sub_seq - container for all published instances of a name sequence
  * @lower: name sequence lower bound
@@ -105,13 +107,32 @@ struct name_seq {
  * @types: pointer to fixed-sized array of name sequence lists,
  *         accessed via hashing on 'type'; name sequence lists are *not* sorted
  * @local_publ_count: number of publications issued by this node
+ * @publishing_port_ref: port that is currently publishing a name (0 if none)
  */
 
 struct name_table {
 	struct hlist_head *types;
 	u32 local_publ_count;
+	u32 publishing_port_ref;
+};
+
+/**
+ *  struct withdraw_table - table of withdrawn port name publications
+ *  @publ_list: list of withdrawn publications yet to be publicized
+ *  @port_list: list of ports waiting for publication list to become empty
+ *  @timer: timer used to retrydistribution of withdrawn publications
+ *  @lock: spinlock controlling access to withdraw table fields
+ */
+
+struct withdraw_table {
+	struct list_head publ_list;
+	struct list_head port_list;
+	struct timer_list timer;
+	spinlock_t lock;
 };
 
+static struct withdraw_table with_table;
+
 static struct name_table table = { NULL } ;
 static atomic_t rsv_publ_ok = ATOMIC_INIT(0);
 DEFINE_RWLOCK(tipc_nametbl_lock);
@@ -597,7 +618,7 @@ static struct name_seq *nametbl_find_seq(u32 type)
 	struct name_seq *ns;
 
 	dbg("find_seq %u,(%u,0x%x) table = %p, hash[type] = %u\n",
-	    type, ntohl(type), type, table.types, hash(type));
+	    type, htonl(type), type, table.types, hash(type));
 
 	seq_head = &table.types[hash(type)];
 	hlist_for_each_entry(ns, seq_node, seq_head, ns_list) {
@@ -788,6 +809,15 @@ exit:
 }
 
 /**
+ * tipc_nametbl_publ_port - get port that is currently publishing (0 if none)
+ */
+
+u32 tipc_nametbl_publ_port(void)
+{
+	return table.publishing_port_ref;
+}
+
+/**
  * tipc_publish_rsv - publish port name using a reserved name type
  */
 
@@ -808,15 +838,17 @@ int tipc_publish_rsv(u32 ref, unsigned int scope,
  *                        but first check permissions
  */
 
-struct publication *tipc_nametbl_publish(u32 type, u32 lower, u32 upper, 
-					 u32 scope, u32 port_ref, u32 key)
+int tipc_nametbl_publish(u32 type, u32 lower, u32 upper, u32 scope,
+			 u32 port_ref, u32 key, struct publication **publ)
 {
 	if ((type < TIPC_RESERVED_TYPES) && !atomic_read(&rsv_publ_ok)) {
 		warn("Failed to publish reserved name <%u,%u,%u>\n",
 		     type, lower, upper);
-		return NULL;
+		return -EINVAL;
 	}
-	return tipc_nametbl_publish_rsv(type, lower, upper, scope, port_ref, key);
+
+	return tipc_nametbl_publish_rsv(type, lower, upper, scope, port_ref,
+					key, publ);
 }
 
 /**
@@ -824,31 +856,72 @@ struct publication *tipc_nametbl_publish(u32 type, u32 lower, u32 upper,
  *                            without checking for permissions
  */
 
-struct publication *tipc_nametbl_publish_rsv(u32 type, u32 lower, u32 upper, 
-					     u32 scope, u32 port_ref, u32 key)
+int tipc_nametbl_publish_rsv(u32 type, u32 lower, u32 upper,
+			     u32 scope, u32 port_ref, u32 key,
+			     struct publication **publ)
 {
-	struct publication *publ;
+	struct port *p_ptr;
+	int res = -EINVAL;
 
 	if (table.local_publ_count >= tipc_max_publications) {
 		warn("Publication failed, local publication limit reached (%u)\n", 
 		     tipc_max_publications);
-		return NULL;
+		return res;
+	}
+
+	/*
+	 * schedule port to re-attempt name publication later
+	 * if a backlog of undistributed name publications exists
+	 */
+
+	spin_lock_bh(&with_table.lock);
+	if (!list_empty(&with_table.publ_list)) {
+		spin_lock_bh(&tipc_port_list_lock);
+		p_ptr = tipc_port_lock(port_ref);
+		if (p_ptr->wakeup && list_empty(&p_ptr->wait_list)) {
+			p_ptr->publ.congested = 1;
+			list_add_tail(&p_ptr->wait_list, &with_table.port_list);
+		}
+		tipc_port_unlock(p_ptr);
+		spin_unlock_bh(&tipc_port_list_lock);
+		spin_unlock_bh(&with_table.lock);
+		return -ELINKCONG;
 	}
+	spin_unlock_bh(&with_table.lock);
+
+	/* add publication to name table */
 
 	write_lock_bh(&tipc_nametbl_lock);
-	publ = tipc_nametbl_insert_publ(type, lower, upper, scope,
-					tipc_own_addr, port_ref, key);
-	if (likely(publ)) {
-		table.local_publ_count++;
-		tipc_named_insert_publ(publ);
+	*publ = tipc_nametbl_insert_publ(type, lower, upper, scope,
+					 tipc_own_addr, port_ref, key);
+	if (!*publ) {
+		write_unlock_bh(&tipc_nametbl_lock);
+		return res;
 	}
-	write_unlock_bh(&tipc_nametbl_lock);
+	table.local_publ_count++;
+	tipc_named_insert_publ(*publ);
 
-	if (likely(publ)) {
-		tipc_named_distribute(publ, DIST_PUBLISH,
-				      dist_mask_for_scope[publ->scope]);
+	/*
+	 * try to distribute publication;
+	 * if not OK delete the publication from the name table
+	 *
+	 * note: the publishing port is scheduled to re-attempt name
+	 * publication later if the failure is caused by link congestion
+	 */
+
+	table.publishing_port_ref = port_ref;
+	res = tipc_named_distribute(*publ, DIST_PUBLISH,
+				    dist_mask_for_scope[(*publ)->scope]);
+	if (res < 0) {
+		*publ = tipc_nametbl_remove_publ(type, lower, tipc_own_addr,
+						 port_ref, key);
+		table.local_publ_count--;
+		tipc_named_remove_publ(*publ);
+		kfree(*publ);
 	}
-	return publ;
+	table.publishing_port_ref = 0;
+	write_unlock_bh(&tipc_nametbl_lock);
+	return res;
 }
 
 /**
@@ -859,24 +932,36 @@ void tipc_nametbl_withdraw(u32 type, u32 lower, u32 ref, u32 key)
 {
 	struct publication *publ;
 
+	/* remove publication from name table */
+
 	write_lock_bh(&tipc_nametbl_lock);
 	publ = tipc_nametbl_remove_publ(type, lower, tipc_own_addr, ref, key);
-	if (likely(publ)) {
-		table.local_publ_count--;
-		tipc_named_remove_publ(publ);
-	}
-	write_unlock_bh(&tipc_nametbl_lock);
-
-	if (likely(publ)) {
-		list_del_init(&publ->pport_list);
-		tipc_named_distribute(publ, DIST_WITHDRAW,
-				      dist_mask_for_scope[publ->scope]);
-		kfree(publ);
-	} else {
+	if (!publ) {
 		err("Unable to remove local publication\n"
 		    "(type=%u, lower=%u, ref=%u, key=%u)\n",
 		    type, lower, ref, key);
+		write_unlock_bh(&tipc_nametbl_lock);
+		return;
 	}
+	table.local_publ_count--;
+	tipc_named_remove_publ(publ);
+	write_unlock_bh(&tipc_nametbl_lock);
+
+	/*
+	 * try to distribute withdrawl of published name;
+	 * if not OK add publication to withdraw table's list of withdrawn names
+	 */
+
+	spin_lock_bh(&with_table.lock);
+	if (!list_empty(&with_table.publ_list))
+		list_add_tail(&publ->distr_list, &with_table.publ_list);
+	else if (tipc_named_distribute(publ, DIST_WITHDRAW,
+				       dist_mask_for_scope[publ->scope]) < 0) {
+		list_add_tail(&publ->distr_list, &with_table.publ_list);
+		k_start_timer(&with_table.timer, WITH_TIMER_ACTIVE);
+	} else
+		kfree(publ);
+	spin_unlock_bh(&with_table.lock);
 }
 
 /**
@@ -1071,25 +1156,15 @@ static void nametbl_list(struct print_buf *buf, u32 depth_info,
 	}
 }
 
-#if 0
-void tipc_nametbl_print(struct print_buf *buf, const char *str)
-{
-	tipc_printf(buf, str);
-	read_lock_bh(&tipc_nametbl_lock);
-	nametbl_list(buf, 0, 0, 0, 0);
-	read_unlock_bh(&tipc_nametbl_lock);
-}
-#endif
-
 #define MAX_NAME_TBL_QUERY 32768
 
-struct sk_buff *tipc_nametbl_get(const void *req_tlv_area, int req_tlv_space)
+struct sk_buff *tipc_nametbl_get(const void *req_tlv_area, u32 req_tlv_space)
 {
 	struct sk_buff *buf;
 	struct tipc_name_table_query *argv;
 	struct tlv_desc *rep_tlv;
 	struct print_buf b;
-	int str_len;
+	size_t str_len;
 
 	if (!TLV_CHECK(req_tlv_area, req_tlv_space, TIPC_TLV_NAME_TBL_QUERY))
 		return tipc_cfg_reply_error_string(TIPC_CFG_TLV_ERROR);
@@ -1113,14 +1188,70 @@ struct sk_buff *tipc_nametbl_get(const void *req_tlv_area, int req_tlv_space)
 	return buf;
 }
 
-#if 0
-void tipc_nametbl_dump(void)
+#endif
+
+/**
+ * wakeup_waiting_ports - wake up ports waiting to publish a new name
+ */
+
+static void wakeup_waiting_ports(void)
 {
-	nametbl_list(TIPC_CONS, 0, 0, 0, 0);
+	struct port *p_ptr;
+	struct port *temp_p_ptr;
+
+	spin_lock_bh(&tipc_port_list_lock);
+	list_for_each_entry_safe(p_ptr, temp_p_ptr, &with_table.port_list,
+				 wait_list) {
+		spin_lock_bh(p_ptr->publ.lock);
+		list_del_init(&p_ptr->wait_list);
+		p_ptr->publ.congested = 0;
+		p_ptr->wakeup(&p_ptr->publ);
+		spin_unlock_bh(p_ptr->publ.lock);
+	}
+	spin_unlock_bh(&tipc_port_list_lock);
 }
-#endif
 
-#endif
+/**
+ * deferred_withdrawl_check - re-attempt withdrawn name publication
+ */
+
+static void deferred_withdrawl_check(unsigned long dummy)
+{
+	struct publication *publ;
+	int res;
+
+	spin_lock_bh(&with_table.lock);
+
+	/* try to distribute first publication in the list */
+
+	publ = list_entry((&with_table.publ_list)->next, struct publication,
+			  distr_list);
+	res = tipc_named_distribute(publ, DIST_WITHDRAW,
+				    dist_mask_for_scope[publ->scope]);
+
+	/* try again later if still blocked by link congestion */
+
+	if (unlikely(res < 0)) {
+		k_start_timer(&with_table.timer, WITH_TIMER_ACTIVE);
+		spin_unlock_bh(&with_table.lock);
+		return;
+	}
+
+	/* delete publication, and keep going if there are more to do */
+
+	list_del_init(&publ->distr_list);
+	kfree(publ);
+	if (!list_empty(&with_table.publ_list)) {
+		tipc_k_signal(deferred_withdrawl_check, 0UL);
+		spin_unlock_bh(&with_table.lock);
+		return;
+	}
+
+	/* no publications left, so wake up ports waiting to publish names */
+
+	wakeup_waiting_ports();
+	spin_unlock_bh(&with_table.lock);
+}
 
 int tipc_nametbl_init(void)
 {
@@ -1130,11 +1261,19 @@ int tipc_nametbl_init(void)
 		return -ENOMEM;
 
 	table.local_publ_count = 0;
+
+	INIT_LIST_HEAD(&with_table.publ_list);
+	INIT_LIST_HEAD(&with_table.port_list);
+	k_init_timer(&with_table.timer, deferred_withdrawl_check, 0UL);
+	spin_lock_init(&with_table.lock);
+
 	return 0;
 }
 
 void tipc_nametbl_stop(void)
 {
+	struct publication *publ;
+	struct publication *publ_temp;
 	u32 i;
 
 	if (!table.types)
@@ -1150,8 +1289,20 @@ void tipc_nametbl_stop(void)
 	kfree(table.types);
 	table.types = NULL;
 	write_unlock_bh(&tipc_nametbl_lock);
-}
 
+	/* Clean up withdrawn publication table */
+
+	k_cancel_timer(&with_table.timer);
+	k_term_timer(&with_table.timer);
+	spin_lock_bh(&with_table.lock);
+	list_for_each_entry_safe(publ, publ_temp,
+				 &with_table.publ_list, distr_list) {
+		list_del_init(&publ->distr_list);
+		kfree(publ);
+	}
+	wakeup_waiting_ports();
+	spin_unlock_bh(&with_table.lock);
+}
 
 /*
  * ROUTING TABLE CODE
@@ -1403,8 +1554,9 @@ found:
  * tipc_routetbl_publish - publish route to neighboring node  
  */
 
-void tipc_routetbl_publish(unsigned long node_addr)
+void tipc_routetbl_publish(unsigned long node_addr_arg)
 {
+	u32 node_addr = (u32)node_addr_arg;
 	struct publication *publ;
 	u32 elm_addr;
 	int scope;
@@ -1440,8 +1592,9 @@ void tipc_routetbl_publish(unsigned long node_addr)
  * tipc_routetbl_withdraw - withdraw route to neighboring node  
  */
 
-void tipc_routetbl_withdraw(unsigned long node_addr)
+void tipc_routetbl_withdraw(unsigned long node_addr_arg)
 {
+	u32 node_addr = (u32)node_addr_arg;
 	struct publication *publ;
 	u32 elm_addr;
 	int dist_mask;
@@ -1478,8 +1631,9 @@ void tipc_routetbl_withdraw(unsigned long node_addr)
  * tipc_routetbl_withdraw_node - trigger implied withdrawal
  */
 
-void tipc_routetbl_withdraw_node(unsigned long node_addr)
+void tipc_routetbl_withdraw_node(unsigned long node_addr_arg)
 {
+	u32 node_addr = (u32)node_addr_arg;
 	struct publication publ;
 
 	publ.type = TIPC_ROUTE;
@@ -1526,7 +1680,7 @@ void tipc_routetbl_purge(u32 region_addr)
  */
 
 struct sk_buff *tipc_nametbl_get_routes(const void *req_tlv_area,
-					int req_tlv_space)
+					u32 req_tlv_space)
 {
 	u32 target;
 	u32 payload_size;
diff --git a/net/tipc/tipc_name_table.h b/net/tipc/tipc_name_table.h
index c59b272..cc6b14e 100644
--- a/net/tipc/tipc_name_table.h
+++ b/net/tipc/tipc_name_table.h
@@ -91,19 +91,17 @@ extern struct name_seq *route_table;
 extern int tipc_own_routes;
 extern int tipc_all_routes;
 
-
-struct sk_buff *tipc_nametbl_get(const void *req_tlv_area, int req_tlv_space);
+u32 tipc_nametbl_publ_port(void);
+struct sk_buff *tipc_nametbl_get(const void *req_tlv_area, u32 req_tlv_space);
 u32 tipc_nametbl_translate(u32 type, u32 instance, u32 *node);
 int tipc_nametbl_mc_translate(u32 type, u32 lower, u32 upper, u32 limit,
 			 struct port_list *dports);
 int tipc_publish_rsv(u32 ref, unsigned int scope, 
                      struct tipc_name_seq const *seq);
-struct publication *tipc_nametbl_publish(u32 type, u32 lower, u32 upper,
-					 u32 scope, u32 port_ref, u32 key);
-
-struct publication *tipc_nametbl_publish_rsv(u32 type, u32 lower, u32 upper,
-					     u32 scope, u32 port_ref, u32 key);
-
+int tipc_nametbl_publish(u32 type, u32 lower, u32 upper, u32 scope,
+			 u32 port_ref, u32 key, struct publication **publ);
+int tipc_nametbl_publish_rsv(u32 type, u32 lower, u32 upper, u32 scope,
+			     u32 port_ref, u32 key, struct publication **publ);
 void tipc_nametbl_withdraw(u32 type, u32 lower, u32 ref, u32 key);
 
 struct publication *tipc_nametbl_insert_publ(u32 type, u32 lower, u32 upper,
@@ -129,6 +127,6 @@ void tipc_routetbl_withdraw(unsigned long node_addr);
 void tipc_routetbl_withdraw_node(unsigned long node_addr);
 void tipc_routetbl_purge(u32 region_addr);
 struct sk_buff *tipc_nametbl_get_routes(const void *req_tlv_area,
-					int req_tlv_space);
+					u32 req_tlv_space);
 
 #endif
diff --git a/net/tipc/tipc_net.c b/net/tipc/tipc_net.c
index ef13350..cb65af3 100644
--- a/net/tipc/tipc_net.c
+++ b/net/tipc/tipc_net.c
@@ -171,7 +171,7 @@ static void net_insert_element(struct net_element *e_ptr, net_element_set_t *set
 	for (i = 0; i < set->first_free; i++) {
 		dbg_assert(set->element[i]->addr != e_ptr->addr);
 		if (set->element[i]->addr > e_ptr->addr) {
-			int sz = (set->first_free - i) * sizeof(e_ptr);
+			size_t sz = (set->first_free - i) * sizeof(e_ptr);
 			memmove(&set->element[i+1], &set->element[i], sz);
 			break;
 		}
@@ -378,7 +378,8 @@ int tipc_net_start(u32 addr)
 	tipc_port_reinit();
 	tipc_named_reinit();
 
-	if ((res = net_init()) ||
+	if ((res = tipc_bearer_init()) ||
+	    (res = net_init()) ||
 	    (res = tipc_bclink_init())) {
 		return res;
 	}
@@ -481,14 +482,13 @@ void tipc_netsub_unbind(struct net_subscr *net_sub)
 void tipc_netsub_notify(struct net_element *e_ptr, u32 affected_addr)
 {
 	struct net_subscr *ns;
-	struct net_subscr *tns;
 
-	list_for_each_entry_safe(ns, tns, &e_ptr->nsub, sub_list) {
-		if (tipc_in_scope(affected_addr, ns->addr)) {
-			ns->element = NULL;
-			list_del_init(&ns->sub_list);
+	list_for_each_entry(ns, &e_ptr->nsub, sub_list) {
+		if (ns->handle_element_down &&
+		    tipc_in_scope(affected_addr, ns->addr)) {
 			tipc_k_signal((Handler)ns->handle_element_down,
 				      (unsigned long)ns->usr_handle);
+			ns->handle_element_down = NULL;
 		}
 	}
 }
diff --git a/net/tipc/tipc_netlink.c b/net/tipc/tipc_netlink.c
index 7c9b948..f6d9d54 100644
--- a/net/tipc/tipc_netlink.c
+++ b/net/tipc/tipc_netlink.c
@@ -68,7 +68,9 @@ static int handle_cmd(struct sk_buff *skb, struct genl_info *info)
 #endif
 		memcpy(rep_nlh, req_nlh, hdr_space);
 		rep_nlh->nlmsg_len = rep_buf->len;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+		genlmsg_unicast(&init_net, rep_buf, NETLINK_CB(skb).pid);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22)
 		genlmsg_unicast(rep_buf, NETLINK_CB(skb).pid);
 #else
 		genlmsg_unicast(rep_buf, req_nlh->nlmsg_pid);
@@ -78,7 +80,7 @@ static int handle_cmd(struct sk_buff *skb, struct genl_info *info)
 	return 0;
 }
 
-static struct genl_family family = {
+static struct genl_family tipc_genl_family = {
 	.id		= GENL_ID_GENERATE,
 	.name		= TIPC_GENL_NAME,
 	.version	= TIPC_GENL_VERSION,
@@ -86,41 +88,41 @@ static struct genl_family family = {
 	.maxattr	= 0,
 };
 
-static struct genl_ops ops = {
+static struct genl_ops tipc_genl_ops = {
 	.cmd		= TIPC_GENL_CMD,
 	.doit		= handle_cmd,
 };
 
-static int family_registered = 0;
+static int tipc_genl_family_registered;
 
 int tipc_netlink_start(void)
 {
+	int res;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31)
+	res = genl_register_family_with_ops(&tipc_genl_family,
+					    &tipc_genl_ops, 1);
+#else
+	res = genl_register_family(&tipc_genl_family);
+	if (!res)
+		res = genl_register_ops(&tipc_genl_family, &tipc_genl_ops);
+#endif
 
-	if (genl_register_family(&family))
-		goto err;
-
-	family_registered = 1;
-
-	if (genl_register_ops(&family, &ops))
-		goto err_unregister;
+	if (res) {
+		err("Failed to register netlink interface\n");
+		return res;
+	}
 
+	tipc_genl_family_registered = 1;
 	return 0;
-
- err_unregister:
-	genl_unregister_family(&family);
-	family_registered = 0;
- err:
-	err("Failed to register netlink interface\n");
-	return -EFAULT;
 }
 
 void tipc_netlink_stop(void)
 {
-	if (family_registered) {
-		genl_unregister_family(&family);
-		family_registered = 0;
-	}
+	if (!tipc_genl_family_registered)
+		return;
+	genl_unregister_family(&tipc_genl_family);
+	tipc_genl_family_registered = 0;
 }
 
 #else
diff --git a/net/tipc/tipc_node.c b/net/tipc/tipc_node.c
index bd556a3..badff8d 100644
--- a/net/tipc/tipc_node.c
+++ b/net/tipc/tipc_node.c
@@ -2,7 +2,7 @@
  * net/tipc/tipc_node.c: TIPC node management routines
  *
  * Copyright (c) 2000-2006, Ericsson AB
- * Copyright (c) 2005-2008, Wind River Systems
+ * Copyright (c) 2005-2008, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -50,7 +50,7 @@ static void node_established_contact(struct tipc_node *n_ptr);
 
 static LIST_HEAD(nodes_list);	/* sorted list of neighboring nodes */
 static int node_count = 0;     	/* number of neighboring nodes that exist */
-static int link_count = 0;     	/* number of unicast links node currently has */
+static atomic_t link_count = ATOMIC_INIT(0);  /* # unicast links to neighbors */
 
 static DEFINE_SPINLOCK(node_create_lock);
 
@@ -89,6 +89,7 @@ struct tipc_node *tipc_node_create(u32 addr)
 				break;
 		}
 		list_add_tail(&n_ptr->node_list, &curr_n_ptr->node_list);
+		n_ptr->block_setup = WAIT_PEER_DOWN;
 
 		node_count++;
 	} else {
@@ -222,50 +223,31 @@ int tipc_node_is_up(struct tipc_node *n_ptr)
 	return (n_ptr->active_links[0] != NULL);
 }
 
-int tipc_node_has_redundant_links(struct tipc_node *n_ptr)
+/**
+ * tipc_node_alt_link_is_up - is an alternate link to this one available?
+ */
+
+int tipc_node_alt_link_is_up(struct link *l_ptr)
 {
 #ifdef CONFIG_TIPC_MULTIPLE_LINKS
-	return (n_ptr->working_links > 1);
+	return (l_ptr->owner->working_links > tipc_link_is_up(l_ptr));
 #else
 	return 0;
 #endif
 }
 
-struct tipc_node *tipc_node_attach_link(struct link *l_ptr)
+void tipc_node_attach_link(struct tipc_node *n_ptr, struct link *l_ptr)
 {
-	struct tipc_node *n_ptr = tipc_net_find_node(l_ptr->addr);
-
-	if (!n_ptr)
-		n_ptr = tipc_node_create(l_ptr->addr);
-	if (n_ptr) {
-		u32 bearer_id = l_ptr->b_ptr->identity;
-		char addr_string[16];
-
-		if (n_ptr->link_cnt >= TIPC_MAX_BEARERS) {
-			tipc_addr_string_fill(addr_string, n_ptr->elm.addr);
-			err("Attempt to more than %d links to %s\n",
-			    n_ptr->link_cnt, addr_string);
-			return NULL;
-		}
-
-		if (!n_ptr->links[bearer_id]) {
-			n_ptr->links[bearer_id] = l_ptr;
-			n_ptr->link_cnt++;
-			link_count++;
-			return n_ptr;
-		}
-		tipc_addr_string_fill(addr_string, l_ptr->addr);
-		err("Attempt to establish second link on <%s> to %s \n",
-		    l_ptr->b_ptr->publ.name, addr_string);
-	}
-	return NULL;
+	n_ptr->links[l_ptr->b_ptr->identity] = l_ptr;
+	n_ptr->link_cnt++;
+	atomic_inc(&link_count);
 }
 
 void tipc_node_detach_link(struct tipc_node *n_ptr, struct link *l_ptr)
 {
 	n_ptr->links[l_ptr->b_ptr->identity] = NULL;
 	n_ptr->link_cnt--;
-	link_count--;
+	atomic_dec(&link_count);
 }
 
 static void node_established_contact(struct tipc_node *n_ptr)
@@ -280,8 +262,10 @@ static void node_established_contact(struct tipc_node *n_ptr)
 
 		/* Add to multicast destination map, if applicable */
 
-		if (n_ptr->bclink.supported)
+		if (n_ptr->bclink.supportable) {
 			tipc_bclink_add_node(n_ptr->elm.addr);
+			n_ptr->bclink.supported = 1;
+		}
 	} else {
 
 		/* Publish new inter-cluster (or inter-zone) route */
@@ -321,15 +305,16 @@ static inline void node_abort_link_changeover(struct tipc_node *n_ptr)
 }
 #endif
 
-static void node_cleanup_finished(unsigned long node_addr)
+static void node_name_purge_complete(unsigned long node_addr_arg)
 {
+	u32 node_addr = (u32)node_addr_arg;
 	struct tipc_node *n_ptr;
 	 
 	read_lock_bh(&tipc_net_lock);
 	n_ptr = tipc_net_find_node(node_addr);
 	if (n_ptr) {
 		tipc_node_lock(n_ptr);
-		n_ptr->cleanup_required = 0;
+		n_ptr->block_setup &= ~WAIT_NAMES_GONE;
 		tipc_node_unlock(n_ptr);
 	}
 	read_unlock_bh(&tipc_net_lock);
@@ -342,24 +327,26 @@ static void node_lost_contact(struct tipc_node *n_ptr)
 	tipc_addr_string_fill(addr_string, n_ptr->elm.addr);
 	info("Lost contact with %s\n", addr_string);
 
-	/* Clean up broadcast reception remains */
+	/* Flush broadcast link info associated with lost node */
 
-	while (n_ptr->bclink.deferred_head) {
-		struct sk_buff *buf = n_ptr->bclink.deferred_head;
+	if (n_ptr->bclink.supported) {
+		while (n_ptr->bclink.deferred_head) {
+			struct sk_buff *buf = n_ptr->bclink.deferred_head;
 
-		n_ptr->bclink.deferred_head = buf->next;
-		buf_discard(buf);
-	}
-	n_ptr->bclink.deferred_size = 0;
+			n_ptr->bclink.deferred_head = buf->next;
+			buf_discard(buf);
+		}
+		n_ptr->bclink.deferred_size = 0;
 
-	if (n_ptr->bclink.defragm) {
-		buf_discard(n_ptr->bclink.defragm);
-		n_ptr->bclink.defragm = NULL;
-	}
+		if (n_ptr->bclink.defragm) {
+			buf_discard(n_ptr->bclink.defragm);
+			n_ptr->bclink.defragm = NULL;
+		}
 
-	if (in_own_cluster(n_ptr->elm.addr) && n_ptr->bclink.supported) { 
-		tipc_bclink_acknowledge(n_ptr, mod(n_ptr->bclink.acked + 10000));
 		tipc_bclink_remove_node(n_ptr->elm.addr);
+		tipc_bclink_acknowledge(n_ptr, INVALID_LINK_SEQ);
+
+		n_ptr->bclink.supported = 0;
 	}
 
 #ifdef CONFIG_TIPC_MULTIPLE_LINKS
@@ -383,7 +370,7 @@ static void node_lost_contact(struct tipc_node *n_ptr)
 		   AFTER STUFF THEY DEPEND ON HAS BEEN SHUT DOWN 
 		   
 		   THE CODE NEEDS TO BE CLEANED UP TO DO THIS BETTER, SINCE
-		   FAILING TO RUN THE CLEANUP CODE COULD LEAVE ENTIRES IN THE
+		   FAILING TO RUN THE CLEANUP CODE COULD LEAVE ENTRIES IN THE
 		   ROUTING TABLE AND NAME TABLE ... */
 		return;
 	}
@@ -397,27 +384,11 @@ static void node_lost_contact(struct tipc_node *n_ptr)
 			      n_ptr->elm.addr);
 	}
 
-	/* Prevent re-contact with node until all cleanup is done */
-
-	n_ptr->cleanup_required = 1;
-	tipc_k_signal((Handler)node_cleanup_finished, n_ptr->elm.addr);
-}
-
-#if 0
-void node_print(struct print_buf *buf, struct tipc_node *n_ptr, char *str)
-{
-	u32 i;
+	/* Prevent re-contact with node until cleanup is done */
 
-	tipc_printf(buf, "\n\n%s", str);
-	for (i = 0; i < TIPC_MAX_BEARERS; i++) {
-		if (!n_ptr->links[i])
-			continue;
-		tipc_printf(buf, "Links[%u]: %x, ", i, n_ptr->links[i]);
-	}
-	tipc_printf(buf, "Active links: [%x,%x]\n",
-		    n_ptr->active_links[0], n_ptr->active_links[1]);
+	n_ptr->block_setup = WAIT_PEER_DOWN | WAIT_NAMES_GONE;
+	tipc_k_signal((Handler)node_name_purge_complete, n_ptr->elm.addr);
 }
-#endif
 
 u32 tipc_available_nodes(const u32 domain)
 {
@@ -437,7 +408,7 @@ u32 tipc_available_nodes(const u32 domain)
 
 #ifdef CONFIG_TIPC_CONFIG_SERVICE
 
-struct sk_buff *tipc_node_get_nodes(const void *req_tlv_area, int req_tlv_space)
+struct sk_buff *tipc_node_get_nodes(const void *req_tlv_area, u32 req_tlv_space)
 {
 	u32 domain;
 	struct sk_buff *buf;
@@ -488,7 +459,7 @@ struct sk_buff *tipc_node_get_nodes(const void *req_tlv_area, int req_tlv_space)
 	return buf;
 }
 
-struct sk_buff *tipc_node_get_links(const void *req_tlv_area, int req_tlv_space)
+struct sk_buff *tipc_node_get_links(const void *req_tlv_area, u32 req_tlv_space)
 {
 	u32 domain;
 	struct sk_buff *buf;
@@ -511,7 +482,8 @@ struct sk_buff *tipc_node_get_links(const void *req_tlv_area, int req_tlv_space)
 
 	/* Get space for all unicast links + broadcast link */
 
-	payload_size = TLV_SPACE(sizeof(link_info)) * (link_count + 1);
+	payload_size = TLV_SPACE(sizeof(link_info)) *
+		(atomic_read(&link_count) + 1);
 	if (payload_size > 32768u) {
 		read_unlock_bh(&tipc_net_lock);
 		return tipc_cfg_reply_error_string(TIPC_CFG_NOT_SUPPORTED
@@ -527,7 +499,7 @@ struct sk_buff *tipc_node_get_links(const void *req_tlv_area, int req_tlv_space)
 
 	link_info.dest = htonl(tipc_own_addr & 0xfffff00);
 	link_info.up = htonl(1);
-	sprintf(link_info.str, tipc_bclink_name);
+	strlcpy(link_info.str, tipc_bclink_name, TIPC_MAX_LINK_NAME);
 	tipc_cfg_append_tlv(buf, TIPC_TLV_LINK_INFO, &link_info, sizeof(link_info));
 
 	/* Add TLVs for any other links in scope */
diff --git a/net/tipc/tipc_node.h b/net/tipc/tipc_node.h
index bc901a2..d812b9b 100644
--- a/net/tipc/tipc_node.h
+++ b/net/tipc/tipc_node.h
@@ -2,7 +2,7 @@
  * net/tipc/tipc_node.h: Include file for TIPC node management routines
  * 
  * Copyright (c) 2000-2006, Ericsson AB
- * Copyright (c) 2005-2008, Wind River Systems
+ * Copyright (c) 2005-2008, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,6 +41,12 @@
 #include "tipc_bearer.h"
 #include "tipc_net.h"
 
+/* Flags used to block (re)establishment of contact with a neighboring node */
+
+#define WAIT_PEER_DOWN	0x0001	/* wait to see that peer's links are down */
+#define WAIT_NAMES_GONE	0x0002	/* wait for peer's publications to be purged */
+#define WAIT_NODE_DOWN	0x0004	/* wait until peer node is declared down */
+
 /**
  * struct tipc_node - TIPC node structure
  * @elm: generic network element structure for node
@@ -51,11 +57,12 @@
  * @link_cnt: number of links to node
  * @working_links: number of working links to node (both active and standby)
  * @permit_changeover: non-zero if node has redundant links to this system
- * @cleanup_required: non-zero if cleaning up after a prior loss of contact
+ * @block_setup: bit mask of conditions preventing link establishment to node
  * @signature: random node instance identifier (always 0 for a uni-cluster node)
  * @flags: bit array indicating node's capabilities
  * @bclink: broadcast-related info
- *    @supported: non-zero if node supports TIPC b'cast capability
+ *    @supportable: non-zero if node supports TIPC b'cast link capability
+ *    @supported: non-zero if node is currently part of b'cast link group
  *    @acked: sequence # of last outbound b'cast message acknowledged by node
  *    @last_in: sequence # of last in-sequence b'cast message received from node
  *    @last_sent: sequence # of last b'cast message sent by node
@@ -74,11 +81,12 @@ struct tipc_node {
 	int link_cnt;
 	int working_links;
 	int permit_changeover;
-	int cleanup_required;
-	u16 signature;
-	u16 flags;
+	int block_setup;
+	unsigned int signature;
+	unsigned int flags;
 	struct {
-		int supported;
+		char supportable;
+		char supported;
 		u32 acked;
 		u32 last_in;
 		u32 last_sent;
@@ -94,12 +102,12 @@ struct tipc_node *tipc_node_create(u32 addr);
 void tipc_node_delete(struct tipc_node *n_ptr);
 void tipc_node_link_up(struct tipc_node *n_ptr, struct link *l_ptr);
 void tipc_node_link_down(struct tipc_node *n_ptr, struct link *l_ptr);
-int tipc_node_has_redundant_links(struct tipc_node *n_ptr);
+int tipc_node_alt_link_is_up(struct link *l_ptr);
 int tipc_node_is_up(struct tipc_node *n_ptr);
-struct tipc_node *tipc_node_attach_link(struct link *l_ptr);
+void tipc_node_attach_link(struct tipc_node *n_ptr, struct link *l_ptr);
 void tipc_node_detach_link(struct tipc_node *n_ptr, struct link *l_ptr);
-struct sk_buff *tipc_node_get_nodes(const void *req_tlv_area, int req_tlv_space);
-struct sk_buff *tipc_node_get_links(const void *req_tlv_area, int req_tlv_space);
+struct sk_buff *tipc_node_get_nodes(const void *req_tlv_area, u32 req_tlv_space);
+struct sk_buff *tipc_node_get_links(const void *req_tlv_area, u32 req_tlv_space);
 
 
 static inline void tipc_node_lock(struct tipc_node *n_ptr)
diff --git a/net/tipc/tipc_port.c b/net/tipc/tipc_port.c
index a73bb97..5385230 100644
--- a/net/tipc/tipc_port.c
+++ b/net/tipc/tipc_port.c
@@ -2,7 +2,7 @@
  * net/tipc/tipc_port.c: TIPC port code
  *
  * Copyright (c) 1992-2007, Ericsson AB
- * Copyright (c) 2004-2008, Wind River Systems
+ * Copyright (c) 2004-2008, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -239,7 +239,6 @@ struct tipc_port *tipc_createport_raw(void *usr_handle,
 	p_ptr->publ.usr_handle = usr_handle;
 	p_ptr->publ.max_pkt = MAX_PKT_DEFAULT;
 	p_ptr->publ.ref = ref;
-	p_ptr->sent = 1;
 	INIT_LIST_HEAD(&p_ptr->wait_list);
 	INIT_LIST_HEAD(&p_ptr->subscription.sub_list);
 	p_ptr->dispatcher = dispatcher;
@@ -247,6 +246,7 @@ struct tipc_port *tipc_createport_raw(void *usr_handle,
 	p_ptr->user_port = NULL;
 	k_init_timer(&p_ptr->timer, (Handler)port_timeout, ref);
 	INIT_LIST_HEAD(&p_ptr->publications);
+	INIT_LIST_HEAD(&p_ptr->port_list);
 
 	/*
 	 * Must hold port list lock while initializing message header template
@@ -516,8 +516,9 @@ int tipc_port_reject_sections(struct port *p_ptr, struct tipc_msg *hdr,
 	return tipc_reject_msg(buf, err);
 }
 
-static void port_timeout(unsigned long ref)
+static void port_timeout(unsigned long ref_arg)
 {
+	u32 ref = (u32)ref_arg;
 	struct port *p_ptr = tipc_port_lock(ref);
 	struct sk_buff *buf = NULL;
 
@@ -549,8 +550,9 @@ static void port_timeout(unsigned long ref)
 }
 
 
-static void port_handle_node_down(unsigned long ref)
+static void port_handle_node_down(unsigned long ref_arg)
 {
+	u32 ref = (u32)ref_arg;
 	struct port *p_ptr = tipc_port_lock(ref);
 	struct sk_buff* buf = NULL;
 
@@ -710,7 +712,7 @@ struct sk_buff *tipc_port_get_ports(void)
 	struct tlv_desc *rep_tlv;
 	struct print_buf pb;
 	struct port *p_ptr;
-	int str_len;
+	size_t str_len;
 
 	buf = tipc_cfg_reply_alloc(TLV_SPACE(MAX_PORT_QUERY));
 	if (!buf)
@@ -733,50 +735,6 @@ struct sk_buff *tipc_port_get_ports(void)
 	return buf;
 }
 
-#if 0
-
-#define MAX_PORT_STATS 2000
-
-struct sk_buff *port_show_stats(const void *req_tlv_area, int req_tlv_space)
-{
-	u32 ref;
-	struct port *p_ptr;
-	struct sk_buff *buf;
-	struct tlv_desc *rep_tlv;
-	struct print_buf pb;
-	int str_len;
-
-	if (!TLV_CHECK(req_tlv_area, req_tlv_space, TIPC_TLV_PORT_REF))
-		return cfg_reply_error_string(TIPC_CFG_TLV_ERROR);
-
-	ref = *(u32 *)TLV_DATA(req_tlv_area);
-	ref = ntohl(ref);
-
-	p_ptr = tipc_port_lock(ref);
-	if (!p_ptr)
-		return cfg_reply_error_string("port not found");
-
-	buf = tipc_cfg_reply_alloc(TLV_SPACE(MAX_PORT_STATS));
-	if (!buf) {
-		tipc_port_unlock(p_ptr);
-		return NULL;
-	}
-	rep_tlv = (struct tlv_desc *)buf->data;
-
-	tipc_printbuf_init(&pb, TLV_DATA(rep_tlv), MAX_PORT_STATS);
-	port_print(p_ptr, &pb, 1);
-	/* NEED TO FILL IN ADDITIONAL PORT STATISTICS HERE */
-	tipc_port_unlock(p_ptr);
-	str_len = tipc_printbuf_validate(&pb);
-
-	skb_put(buf, TLV_SPACE(str_len));
-	TLV_SET(rep_tlv, TIPC_TLV_ULTRA_STRING, NULL, str_len);
-
-	return buf;
-}
-
-#endif
-
 #endif
 
 void tipc_port_reinit(void)
@@ -849,6 +807,7 @@ static void port_dispatcher_sigh(void *dummy)
 				tipc_conn_msg_event cb = up_ptr->conn_msg_cb;
 				u32 peer_port = port_peerport(p_ptr);
 				u32 peer_node = port_peernode(p_ptr);
+				u32 dsz;
 
 				tipc_port_unlock(p_ptr);
 				if (unlikely(!cb))
@@ -861,13 +820,14 @@ static void port_dispatcher_sigh(void *dummy)
 					goto reject;
 				/* TODO: Don't access conn_unacked field
 					 while port is unlocked ... */
-				if (unlikely(++p_ptr->publ.conn_unacked >=
-					     TIPC_FLOW_CONTROL_WIN))
+				dsz = msg_data_sz(msg);
+				if (unlikely(dsz &&
+					     (++p_ptr->publ.conn_unacked >=
+					      TIPC_FLOW_CONTROL_WIN)))
 					tipc_acknowledge(dref,
 							 p_ptr->publ.conn_unacked);
 				skb_pull(buf, msg_hdr_sz(msg));
-				cb(usr_handle, dref, &buf, msg_data(msg),
-				   msg_data_sz(msg));
+				cb(usr_handle, dref, &buf, msg_data(msg), dsz);
 				break;
 			}
 		case TIPC_DIRECT_MSG:{
@@ -989,8 +949,9 @@ static u32 port_dispatcher(struct tipc_port *dummy, struct sk_buff *buf)
  *
  */
 
-static void port_wakeup_sh(unsigned long ref)
+static void port_wakeup_sh(unsigned long ref_arg)
 {
+	u32 ref = (u32)ref_arg;
 	struct port *p_ptr;
 	struct user_port *up_ptr;
 	tipc_continue_event cb = NULL;
@@ -1128,30 +1089,36 @@ int tipc_publish(u32 ref, unsigned int scope, struct tipc_name_seq const *seq)
 	struct port *p_ptr;
 	struct publication *publ;
 	u32 key;
-	int res = -EINVAL;
+	int res;
+
+	if (seq->lower > seq->upper)
+		return -EINVAL;
+	if ((scope < TIPC_ZONE_SCOPE) || (scope > TIPC_NODE_SCOPE))
+		return -EINVAL;
 
 	p_ptr = tipc_port_lock(ref);
 	if (!p_ptr)
 		return -EINVAL;
-	if (p_ptr->publ.connected)
-		goto exit;
-	if (seq->lower > seq->upper)
-		goto exit;
-	if ((scope < TIPC_ZONE_SCOPE) || (scope > TIPC_NODE_SCOPE))
+	if (p_ptr->publ.connected) {
+		res = -EINVAL;
 		goto exit;
+	}
 	key = ref + p_ptr->pub_count + 1;
 	if (key == ref) {
 		res = -EADDRINUSE;
 		goto exit;
 	}
-	publ = tipc_nametbl_publish(seq->type, seq->lower, seq->upper,
-				    scope, p_ptr->publ.ref, key);
-	if (publ) {
-		list_add(&publ->pport_list, &p_ptr->publications);
-		p_ptr->pub_count++;
-		p_ptr->publ.published = 1;
-		res = 0;
-	}
+	tipc_port_unlock(p_ptr);
+	
+	res = tipc_nametbl_publish(seq->type, seq->lower, seq->upper,
+				   scope, p_ptr->publ.ref, key, &publ);
+	if (res)
+		return res;
+		
+	spin_lock_bh(p_ptr->publ.lock);
+	list_add(&publ->pport_list, &p_ptr->publications);
+	p_ptr->pub_count++;
+	p_ptr->publ.published = 1;
 exit:
 	tipc_port_unlock(p_ptr);
 	return res;
@@ -1162,21 +1129,16 @@ int tipc_withdraw(u32 ref, unsigned int scope, struct tipc_name_seq const *seq)
 	struct port *p_ptr;
 	struct publication *publ;
 	struct publication *tpubl;
-	int res = -EINVAL;
+	int res;
 
 	p_ptr = tipc_port_lock(ref);
 	if (!p_ptr)
 		return -EINVAL;
-	if (!seq) {
-		list_for_each_entry_safe(publ, tpubl,
-					 &p_ptr->publications, pport_list) {
-			tipc_nametbl_withdraw(publ->type, publ->lower,
-					      publ->ref, publ->key);
-		}
-		res = 0;
-	} else {
-		list_for_each_entry_safe(publ, tpubl,
-					 &p_ptr->publications, pport_list) {
+
+	res = seq ? -EINVAL : 0;
+	list_for_each_entry_safe(publ, tpubl, &p_ptr->publications,
+				 pport_list) {
+		if (seq) {
 			if (publ->scope != scope)
 				continue;
 			if (publ->type != seq->type)
@@ -1185,12 +1147,17 @@ int tipc_withdraw(u32 ref, unsigned int scope, struct tipc_name_seq const *seq)
 				continue;
 			if (publ->upper != seq->upper)
 				break;
-			tipc_nametbl_withdraw(publ->type, publ->lower,
-					      publ->ref, publ->key);
-			res = 0;
-			break;
 		}
+		list_del_init(&publ->pport_list);
+		tipc_port_unlock(p_ptr);
+		tipc_nametbl_withdraw(publ->type, publ->lower,
+				      publ->ref, publ->key);
+		res = 0;
+		spin_lock_bh(p_ptr->publ.lock);
+		if (seq)
+			break;
 	}
+
 	if (list_empty(&p_ptr->publications))
 		p_ptr->publ.published = 0;
 	tipc_port_unlock(p_ptr);
@@ -1440,16 +1407,15 @@ int tipc_send(u32 ref, unsigned int num_sect, struct iovec const *msg_sect)
 		else
 			res = tipc_port_recv_sections(p_ptr, num_sect,
 						      msg_sect);
-
 		if (likely(res != -ELINKCONG)) {
 			p_ptr->publ.congested = 0;
-			p_ptr->sent++;
+			if (res > 0)
+				p_ptr->sent++;
 			return res;
 		}
 	}
 	if (port_unreliable(p_ptr)) {
 		p_ptr->publ.congested = 0;
-		/* Just calculate msg length and return */
 		return tipc_msg_calc_data_size(msg_sect, num_sect);
 	}
 	return -ELINKCONG;
@@ -1466,7 +1432,7 @@ int tipc_send_buf(u32 ref, struct sk_buff *buf, unsigned int dsz)
 	u32 destnode;
 	u32 hsz;
 	u32 sz;
-	u32 res;
+	int res;
 
 	p_ptr = tipc_port_deref(ref);
 	if (!p_ptr || !p_ptr->publ.connected)
@@ -1487,14 +1453,12 @@ int tipc_send_buf(u32 ref, struct sk_buff *buf, unsigned int dsz)
 		destnode = port_peernode(p_ptr);
 		if (!addr_in_node(destnode))
 			res = tipc_send_buf_fast(buf, destnode);
-		else {
-			tipc_port_recv_msg(buf);
-			res = sz;
-		}
-
+		else
+			res = tipc_port_recv_msg(buf);
 		if (likely(res != -ELINKCONG)) {
 			p_ptr->publ.congested = 0;
-			p_ptr->sent++;
+			if (res > 0)
+				p_ptr->sent++;
 			return res;
 		}
 	}
@@ -1542,20 +1506,22 @@ int tipc_forward2name(u32 ref,
 	msg_set_destport(msg, destport);
 
 	if (likely(destport || destnode)) {
-		p_ptr->sent++;
 		if (addr_in_node(destnode))
-			return tipc_port_recv_sections(p_ptr, num_sect,
-						       msg_sect);
-		if (!orig->node)
-			msg_set_orignode(msg, tipc_own_addr);
-		res = tipc_link_send_sections_fast(p_ptr, msg_sect, num_sect,
-						   destnode);
-		if (likely(res != -ELINKCONG))
+			res = tipc_port_recv_sections(p_ptr, num_sect,
+						      msg_sect);
+		else {
+			if (!orig->node)
+				msg_set_orignode(msg, tipc_own_addr);
+			res = tipc_link_send_sections_fast(p_ptr, msg_sect,
+							   num_sect, destnode);
+		}
+		if (likely(res != -ELINKCONG)) {
+			if (res > 0)
+				p_ptr->sent++;
 			return res;
-		if (port_unreliable(p_ptr)) {
-			/* Just calculate msg length and return */
-			return tipc_msg_calc_data_size(msg_sect, num_sect);
 		}
+		if (port_unreliable(p_ptr))
+			return tipc_msg_calc_data_size(msg_sect, num_sect);
 		return -ELINKCONG;
 	}
 	return tipc_port_reject_sections(p_ptr, msg, msg_sect, num_sect,
@@ -1624,14 +1590,18 @@ int tipc_forward_buf2name(u32 ref,
 	skb_copy_to_linear_data(buf, msg, LONG_H_SIZE);
 
 	if (likely(destport || destnode)) {
-		p_ptr->sent++;
 		if (addr_in_node(destnode))
-			return tipc_port_recv_msg(buf);
-		if (!orig->node)
-			msg_set_orignode(msg, tipc_own_addr);
-		res = tipc_send_buf_fast(buf, destnode);
-		if (likely(res != -ELINKCONG))
+			res = tipc_port_recv_msg(buf);
+		else {
+			if (!orig->node)
+				msg_set_orignode(msg, tipc_own_addr);
+			res = tipc_send_buf_fast(buf, destnode);
+		}
+		if (likely(res != -ELINKCONG)) {
+			if (res > 0)
+				p_ptr->sent++;
 			return res;
+		}
 		if (port_unreliable(p_ptr))
 			return dsz;
 		return -ELINKCONG;
@@ -1685,17 +1655,20 @@ int tipc_forward2port(u32 ref,
 	msg_set_destnode(msg, dest->node);
 	msg_set_destport(msg, dest->ref);
 
-	p_ptr->sent++;
 	if (addr_in_node(dest->node))
-		return tipc_port_recv_sections(p_ptr, num_sect, msg_sect);
-	if (!orig->node)
-		msg_set_orignode(msg, tipc_own_addr);
-	res = tipc_link_send_sections_fast(p_ptr, msg_sect, num_sect,
-					   dest->node);
-	if (likely(res != -ELINKCONG))
+		res = tipc_port_recv_sections(p_ptr, num_sect, msg_sect);
+	else {
+		if (!orig->node)
+			msg_set_orignode(msg, tipc_own_addr);
+		res = tipc_link_send_sections_fast(p_ptr, msg_sect, num_sect,
+						   dest->node);
+	}
+	if (likely(res != -ELINKCONG)) {
+		if (res > 0)
+			p_ptr->sent++;
 		return res;
+	}
 	if (port_unreliable(p_ptr)) {
-		/* Just calculate msg length and return */
 		return tipc_msg_calc_data_size(msg_sect, num_sect);
 	}
 	return -ELINKCONG;
@@ -1752,14 +1725,18 @@ int tipc_forward_buf2port(u32 ref,
 	skb_push(buf, DIR_MSG_H_SIZE);
 	skb_copy_to_linear_data(buf, msg, DIR_MSG_H_SIZE);
 
-	p_ptr->sent++;
 	if (addr_in_node(dest->node))
-		return tipc_port_recv_msg(buf);
-	if (!orig->node)
-		msg_set_orignode(msg, tipc_own_addr);
-	res = tipc_send_buf_fast(buf, dest->node);
-	if (likely(res != -ELINKCONG))
+		res = tipc_port_recv_msg(buf);
+	else {
+		if (!orig->node)
+			msg_set_orignode(msg, tipc_own_addr);
+		res = tipc_send_buf_fast(buf, dest->node);
+	}
+	if (likely(res != -ELINKCONG)) {
+		if (res > 0)
+			p_ptr->sent++;
 		return res;
+	}
 	if (port_unreliable(p_ptr))
 		return dsz;
 	return -ELINKCONG;
diff --git a/net/tipc/tipc_port.h b/net/tipc/tipc_port.h
index 539ff43..06b4aa0 100644
--- a/net/tipc/tipc_port.h
+++ b/net/tipc/tipc_port.h
@@ -2,7 +2,7 @@
  * net/tipc/tipc_port.h: Include file for TIPC port code
  *
  * Copyright (c) 1994-2007, Ericsson AB
- * Copyright (c) 2004-2008, Wind River Systems
+ * Copyright (c) 2004-2008, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -75,8 +75,8 @@ struct user_port {
  * @user_port: ptr to user port associated with port (if any)
  * @wait_list: adjacent ports in list of ports waiting on link congestion
  * @waiting_pkts:
- * @sent:
- * @acked:
+ * @sent: # of non-empty messages sent by port
+ * @acked: # of non-empty message acknowledgements from connected port's peer
  * @publications: list of publications for port
  * @pub_count: total # of publications port has made during its lifetime
  * @probing_state:
@@ -115,7 +115,7 @@ int tipc_port_reject_sections(struct port *p_ptr, struct tipc_msg *hdr,
 			      struct iovec const *msg_sect, u32 num_sect,
 			      int err);
 struct sk_buff *tipc_port_get_ports(void);
-struct sk_buff *port_show_stats(const void *req_tlv_area, int req_tlv_space);
+struct sk_buff *port_show_stats(const void *req_tlv_area, u32 req_tlv_space);
 void tipc_port_recv_proto_msg(struct sk_buff *buf);
 void tipc_port_recv_mcast(struct sk_buff *buf, struct port_list *dp);
 void tipc_port_reinit(void);
diff --git a/net/tipc/tipc_ref.c b/net/tipc/tipc_ref.c
index 73c678f..65649a5 100644
--- a/net/tipc/tipc_ref.c
+++ b/net/tipc/tipc_ref.c
@@ -179,30 +179,36 @@ u32 tipc_ref_acquire(void *object, spinlock_t **lock)
 		index = tipc_ref_table.first_free;
 		entry = &(tipc_ref_table.entries[index]);
 		index_mask = tipc_ref_table.index_mask;
-		/* take lock in case a previous user of entry still holds it */
-		spin_lock_bh(&entry->lock);
 		next_plus_upper = entry->ref;
 		tipc_ref_table.first_free = next_plus_upper & index_mask;
 		ref = (next_plus_upper & ~index_mask) + index;
-		entry->ref = ref;
-		entry->object = object;
-		*lock = &entry->lock;
 	}
 	else if (tipc_ref_table.init_point < tipc_ref_table.capacity) {
 		index = tipc_ref_table.init_point++;
 		entry = &(tipc_ref_table.entries[index]);
 		spin_lock_init(&entry->lock);
-		spin_lock_bh(&entry->lock);
 		ref = tipc_ref_table.start_mask + index;
-		entry->ref = ref;
-		entry->object = object;
-		*lock = &entry->lock;
 	}
 	else {
+		entry = NULL;
 		ref = 0;
 	}
 	write_unlock_bh(&ref_table_lock);
 
+	/*
+	 * update ref value & object pointer for chosen entry, but only after
+	 * taking its lock (ensures no one is referencing the current values)
+	 *
+	 * exit with lock still held -- see note at start of routine
+	 */
+
+	if (entry) {
+		spin_lock_bh(&entry->lock);
+		entry->ref = ref;
+		entry->object = object;
+		*lock = &entry->lock;
+	}
+
 	return ref;
 }
 
diff --git a/net/tipc/tipc_socket.c b/net/tipc/tipc_socket.c
index 0aee51c..6f1df38 100644
--- a/net/tipc/tipc_socket.c
+++ b/net/tipc/tipc_socket.c
@@ -40,9 +40,9 @@
 #include <linux/socket.h>
 #include <linux/errno.h>
 #include <linux/mm.h>
-#include <linux/slab.h>
 #include <linux/poll.h>
 #include <linux/fcntl.h>
+#include <linux/gfp.h>
 #include <asm/string.h>
 #include <asm/atomic.h>
 #include <net/sock.h>
@@ -53,6 +53,9 @@
 #include <net/tipc/tipc_plugin_port.h>
 
 #include "tipc_core.h"
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+#include <net/net_namespace.h>
+#endif
 
 #ifdef CONFIG_TIPC_SOCKET_API
 
@@ -72,6 +75,7 @@ struct tipc_sock {
 	struct sock sk;
 	struct tipc_port *p;
 	struct tipc_portid peer_name;
+	unsigned int conn_timeout;
 };
 
 #define tipc_sk(sk) ((struct tipc_sock *)(sk))
@@ -185,6 +189,7 @@ static void reject_rx_queue(struct sock *sk)
  * @net: network namespace (must be default network) -- only for 2.6.24+
  * @sock: pre-allocated socket structure
  * @protocol: protocol indicator (must be 0)
+ * @kern: caused by kernel or by userspace? (unused) -- only for 2.6.33+
  *
  * This routine creates additional data structures used by the TIPC socket,
  * initializes them, and links them together.
@@ -192,7 +197,10 @@ static void reject_rx_queue(struct sock *sk)
  * Returns 0 on success, errno otherwise
  */
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)
+static int tipc_create(struct net *net, struct socket *sock, int protocol,
+		       int kern)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
 static int tipc_create(struct net *net, struct socket *sock, int protocol)
 #else
 static int tipc_create(struct socket *sock, int protocol)
@@ -204,8 +212,10 @@ static int tipc_create(struct socket *sock, int protocol)
 	struct tipc_port *tp_ptr;
 
 	/* Validate arguments */
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+	if (!net_eq(net, &init_net))
+		return -EAFNOSUPPORT;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
 	if (net != &init_net)
 		return -EAFNOSUPPORT;
 #endif
@@ -256,9 +266,9 @@ static int tipc_create(struct socket *sock, int protocol)
 	sock->state = state;
 
 	sock_init_data(sock, sk);
-	sk->sk_rcvtimeo = msecs_to_jiffies(CONN_TIMEOUT_DEFAULT);
 	sk->sk_backlog_rcv = backlog_rcv;
 	tipc_sk(sk)->p = tp_ptr;
+	tipc_sk(sk)->conn_timeout = CONN_TIMEOUT_DEFAULT;
 
 	spin_unlock_bh(tp_ptr->lock);
 
@@ -371,7 +381,10 @@ static int release(struct socket *sock)
 static int bind(struct socket *sock, struct sockaddr *uaddr, int uaddr_len)
 {
 	struct sockaddr_tipc *addr = (struct sockaddr_tipc *)uaddr;
-	u32 portref = tipc_sk_port(sock->sk)->ref;
+	struct sock *sk = sock->sk;
+	struct tipc_port *tport = tipc_sk_port(sk);
+	u32 portref = tport->ref;
+	int res;
 
 	if (unlikely(!uaddr_len))
 		return tipc_withdraw(portref, 0, NULL);
@@ -386,9 +399,22 @@ static int bind(struct socket *sock, struct sockaddr *uaddr, int uaddr_len)
 	else if (addr->addrtype != TIPC_ADDR_NAMESEQ)
 		return -EAFNOSUPPORT;
 
-	return (addr->scope > 0) ?
-		tipc_publish(portref, addr->scope, &addr->addr.nameseq) :
-		tipc_withdraw(portref, -addr->scope, &addr->addr.nameseq);
+	if (addr->scope < 0)
+		return tipc_withdraw(portref, -addr->scope,
+				     &addr->addr.nameseq); 
+		
+	do {
+		res = tipc_publish(portref, addr->scope, &addr->addr.nameseq);
+		if (likely(res != -ELINKCONG))
+			break;
+
+		res = wait_event_interruptible(*sk->sk_sleep,
+					       !tport->congested);
+		if (res)
+			break;
+	} while (1);
+
+	return res;
 }
 
 /**
@@ -445,37 +471,55 @@ static int get_name(struct socket *sock, struct sockaddr *uaddr,
  * to handle any preventable race conditions, so TIPC will do the same ...
  *
  * TIPC sets the returned events as follows:
- * a) POLLRDNORM and POLLIN are set if the socket's receive queue is non-empty
- *    or if a connection-oriented socket is does not have an active connection
- *    (i.e. a read operation will not block).
- * b) POLLOUT is set except if the socket's port is in a congested state
- *    or the socket's connection has been terminated
- *    (i.e. a write operation will not block).
- * c) POLLHUP is set when a socket's connection has been terminated.
- *
- * IMPORTANT: The fact that a read or write operation will not block does NOT
- * imply that the operation will succeed!
+ *
+ * socket state		flags set
+ * ------------ 	---------
+ * unconnected		no read flags
+ *			no write flags
+ *
+ * connecting		POLLIN/POLLRDNORM if ACK/NACK in rx queue
+ *			no write flags
+ *
+ * connected		POLLIN/POLLRDNORM if data in rx queue
+ *			POLLOUT if port is not congested
+ *
+ * disconnecting	POLLIN/POLLRDNORM/POLLHUP
+ *			no write flags
+ *
+ * listening		POLLIN if SYN in rx queue
+ *			no write flags
+ *
+ * ready		POLLIN/POLLRDNORM if data in rx queue
+ * [connectionless]	POLLOUT (since port cannot be congested)
+ *
+ * IMPORTANT: The fact that a read or write operation is indicated does NOT
+ * imply that the operation will succeed, merely that it should be performed
+ * and will not block.
  */
 
 static unsigned int poll(struct file *file, struct socket *sock,
 			 poll_table *wait)
 {
 	struct sock *sk = sock->sk;
-	u32 mask;
+	u32 mask = 0;
 
 	poll_wait(file, sk->sk_sleep, wait);
 
-	if (!skb_queue_empty(&sk->sk_receive_queue) ||
-	    (sock->state == SS_UNCONNECTED) ||
-	    (sock->state == SS_DISCONNECTING))
-		mask = (POLLRDNORM | POLLIN);
-	else
-		mask = 0;
-
-	if (sock->state == SS_DISCONNECTING)
-		mask |= POLLHUP;
-	else if (!tipc_sk_port(sk)->congested)
-		mask |= POLLOUT;
+	switch ((int)sock->state) {
+	case SS_READY:
+	case SS_CONNECTED:
+		if (!tipc_sk_port(sk)->congested)
+			mask |= POLLOUT;
+		/* fall thru' */
+	case SS_CONNECTING:
+	case SS_LISTENING:
+		if (!skb_queue_empty(&sk->sk_receive_queue))
+			mask |= (POLLIN | POLLRDNORM);
+		break;
+	case SS_DISCONNECTING:
+		mask = (POLLIN | POLLRDNORM | POLLHUP);
+		break;
+	}
 
 	return mask;
 }
@@ -502,6 +546,8 @@ static int dest_name_check(struct sockaddr_tipc *dest, struct msghdr *m)
 	if (likely(dest->addr.name.name.type != TIPC_CFG_SRV))
 		return -EACCES;
 
+	if (!m->msg_iovlen || (m->msg_iov[0].iov_len < sizeof(hdr)))
+		return -EMSGSIZE;
 	if (copy_from_user(&hdr, m->msg_iov[0].iov_base, sizeof(hdr)))
 		return -EFAULT;
 	if ((ntohs(hdr.tcm_type) & 0xC000) && (!capable(CAP_NET_ADMIN)))
@@ -915,6 +961,7 @@ static int recv_msg(struct kiocb *iocb, struct socket *sock,
 	struct tipc_port *tport = tipc_sk_port(sk);
 	struct sk_buff *buf;
 	struct tipc_msg *msg;
+	long timeout_val;
 	unsigned int sz;
 	u32 err;
 	int res;
@@ -934,6 +981,7 @@ static int recv_msg(struct kiocb *iocb, struct socket *sock,
 		goto exit;
 	}
 
+	timeout_val = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);
 restart:
 
 	/* Look for a message in receive queue; wait if necessary */
@@ -943,17 +991,16 @@ restart:
 			res = -ENOTCONN;
 			goto exit;
 		}
-		if (flags & MSG_DONTWAIT) {
-			res = -EWOULDBLOCK;
+		if (timeout_val <= 0L) {
+			res = timeout_val ? timeout_val : -EWOULDBLOCK;
 			goto exit;
 		}
 		release_sock(sk);
-		res = wait_event_interruptible(*sk->sk_sleep,
-			(!skb_queue_empty(&sk->sk_receive_queue) ||
-			 (sock->state == SS_DISCONNECTING)));
+		timeout_val = wait_event_interruptible_timeout(*sk->sk_sleep,
+				(!skb_queue_empty(&sk->sk_receive_queue) ||
+				 (sock->state == SS_DISCONNECTING)),
+				timeout_val);
 		lock_sock(sk);
-		if (res)
-			goto exit;
 	}
 
 	/* Look at first message in receive queue */
@@ -1042,10 +1089,10 @@ static int recv_stream(struct kiocb *iocb, struct socket *sock,
 	struct tipc_port *tport = tipc_sk_port(sk);
 	struct sk_buff *buf;
 	struct tipc_msg *msg;
+	long timeout_val;
 	unsigned int sz;
-	int sz_to_copy;
+	int sz_to_copy, target, needed;
 	int sz_copied = 0;
-	int needed;
 	char __user *crs = m->msg_iov->iov_base;
 	unsigned char *buf_crs;
 	u32 err;
@@ -1067,6 +1114,8 @@ static int recv_stream(struct kiocb *iocb, struct socket *sock,
 		goto exit;
 	}
 
+	target = sock_rcvlowat(sk, flags & MSG_WAITALL, buf_len);
+	timeout_val = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);
 restart:
 
 	/* Look for a message in receive queue; wait if necessary */
@@ -1076,17 +1125,16 @@ restart:
 			res = -ENOTCONN;
 			goto exit;
 		}
-		if (flags & MSG_DONTWAIT) {
-			res = -EWOULDBLOCK;
+		if (timeout_val <= 0L) {
+			res = timeout_val ? timeout_val : -EWOULDBLOCK;
 			goto exit;
 		}
 		release_sock(sk);
-		res = wait_event_interruptible(*sk->sk_sleep,
-			(!skb_queue_empty(&sk->sk_receive_queue) ||
-			 (sock->state == SS_DISCONNECTING)));
+		timeout_val = wait_event_interruptible_timeout(*sk->sk_sleep,
+				(!skb_queue_empty(&sk->sk_receive_queue) ||
+				 (sock->state == SS_DISCONNECTING)),
+				timeout_val);
 		lock_sock(sk);
-		if (res)
-			goto exit;
 	}
 
 	/* Look at first message in receive queue */
@@ -1155,7 +1203,7 @@ restart:
 
 	if ((sz_copied < buf_len)    /* didn't get all requested data */
 	    && (!skb_queue_empty(&sk->sk_receive_queue) ||
-		(flags & MSG_WAITALL))
+		(sz_copied < target))
 				     /* ... and more is ready or required */
 	    && (!(flags & MSG_PEEK)) /* ... and aren't just peeking at data */
 	    && (!err)                /* ... and haven't reached a FIN */
@@ -1382,6 +1430,7 @@ static int connect(struct socket *sock, struct sockaddr *dest, int destlen,
 	struct msghdr m = {NULL,};
 	struct sk_buff *buf;
 	struct tipc_msg *msg;
+	unsigned int timeout;
 	int res;
 
 	lock_sock(sk);
@@ -1442,11 +1491,13 @@ static int connect(struct socket *sock, struct sockaddr *dest, int destlen,
 
 	/* Wait until an 'ACK' or 'RST' arrives, or a timeout occurs */
 
+	timeout = tipc_sk(sk)->conn_timeout;
 	release_sock(sk);
 	res = wait_event_interruptible_timeout(*sk->sk_sleep,
 			(!skb_queue_empty(&sk->sk_receive_queue) ||
 			(sock->state != SS_CONNECTING)),
-			sk->sk_rcvtimeo);
+			timeout ? (long)msecs_to_jiffies(timeout)
+				: MAX_SCHEDULE_TIMEOUT);
 	lock_sock(sk);
 
 	if (res > 0) {
@@ -1547,7 +1598,9 @@ static int accept(struct socket *sock, struct socket *new_sock, int flags)
 
 	buf = skb_peek(&sk->sk_receive_queue);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)
+	res = tipc_create(sock_net(sock->sk), new_sock, 0, 0);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
 	res = tipc_create(sock_net(sock->sk), new_sock, 0);
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
 	res = tipc_create(sock->sk->sk_net, new_sock, 0);
@@ -1682,8 +1735,13 @@ restart:
  * Returns 0 on success, errno otherwise
  */
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+static int setsockopt(struct socket *sock,
+		      int lvl, int opt, char __user *ov, unsigned int ol)
+#else
 static int setsockopt(struct socket *sock,
 		      int lvl, int opt, char __user *ov, int ol)
+#endif
 {
 	struct sock *sk = sock->sk;
 	struct tipc_port *tport = tipc_sk_port(sk);
@@ -1715,7 +1773,7 @@ static int setsockopt(struct socket *sock,
 		res = tipc_set_portunreturnable(tport->ref, value);
 		break;
 	case TIPC_CONN_TIMEOUT:
-		sk->sk_rcvtimeo = msecs_to_jiffies(value);
+		tipc_sk(sk)->conn_timeout = value;
 		/* no need to set "res", since already 0 at this point */
 		break;
 	default:
@@ -1770,9 +1828,15 @@ static int getsockopt(struct socket *sock,
 		res = tipc_portunreturnable(tport->ref, &value);
 		break;
 	case TIPC_CONN_TIMEOUT:
-		value = jiffies_to_msecs(sk->sk_rcvtimeo);
+		value = tipc_sk(sk)->conn_timeout;
 		/* no need to set "res", since already 0 at this point */
 		break;
+	case TIPC_NODE_RECVQ_DEPTH:
+		value = (u32)atomic_read(&tipc_queue_size);
+		break;
+	case TIPC_SOCK_RECVQ_DEPTH:
+		value = skb_queue_len(&sk->sk_receive_queue);
+		break;
 	default:
 		res = -EINVAL;
 	}
diff --git a/net/tipc/tipc_topsrv.c b/net/tipc/tipc_topsrv.c
index 341f80d..c907e17 100644
--- a/net/tipc/tipc_topsrv.c
+++ b/net/tipc/tipc_topsrv.c
@@ -2,7 +2,7 @@
  * net/tipc/tipc_topsrv.c: TIPC network topology service
  *
  * Copyright (c) 2000-2006, Ericsson AB
- * Copyright (c) 2005-2008, Wind River Systems
+ * Copyright (c) 2005-2008, 2010, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -252,7 +252,7 @@ static void subscr_terminate(struct subscriber *subscriber)
 			k_cancel_timer(&sub->timer);
 			k_term_timer(&sub->timer);
 		}
-		dbg("Term: Removing sub %u,%u,%u from subscriber %x list\n",
+		dbg("Term: Removing sub %u,%u,%u from subscriber %p list\n",
 		    sub->seq.type, sub->seq.lower, sub->seq.upper, subscriber);
 		subscr_del(sub);
 	}
@@ -310,7 +310,7 @@ static void subscr_cancel(struct tipc_subscr *s,
 		k_term_timer(&sub->timer);
 		spin_lock_bh(subscriber->lock);
 	}
-	dbg("Cancel: removing sub %u,%u,%u from subscriber %x list\n",
+	dbg("Cancel: removing sub %u,%u,%u from subscriber %p list\n",
 	    sub->seq.type, sub->seq.lower, sub->seq.upper, subscriber);
 	subscr_del(sub);
 }
@@ -544,18 +544,15 @@ static void subscr_named_msg_event(void *usr_handle,
 int tipc_subscr_start(void)
 {
 	struct tipc_name_seq seq = {TIPC_TOP_SRV, TIPC_TOP_SRV, TIPC_TOP_SRV};
-	int res = -1;
+	int res;
 
 	memset(&topsrv, 0, sizeof (topsrv));
 	spin_lock_init(&topsrv.lock);
 	INIT_LIST_HEAD(&topsrv.subscriber_list);
 
-	spin_lock_bh(&topsrv.lock);
 	res = tipc_attach(&topsrv.user_ref, NULL, NULL);
-	if (res) {
-		spin_unlock_bh(&topsrv.lock);
+	if (res)
 		return res;
-	}
 
 	res = tipc_createport(topsrv.user_ref,
 			      NULL,
@@ -575,14 +572,12 @@ int tipc_subscr_start(void)
 	if (res)
 		goto failed;
 
-	spin_unlock_bh(&topsrv.lock);
 	return 0;
 
 failed:
 	err("Failed to create subscription service\n");
 	tipc_detach(topsrv.user_ref);
 	topsrv.user_ref = 0;
-	spin_unlock_bh(&topsrv.lock);
 	return res;
 }
 
-- 
1.7.0

