From acdc41260485b1df9565c18aa85d3af74de16b03 Mon Sep 17 00:00:00 2001
From: Allan Stephens <allan.stephens@windriver.com>
Date: Fri, 12 Nov 2010 10:03:58 -0500
Subject: [PATCH 20/32] tipc: Improve accuracy of link transmit queue maximum size statistic

commit c2e017d77efa9c5823fe91deb7cddcb648a9d823 from
git://tipc.cslab.ericsson.net/pub/git/people/allan/tipc.git

Enhances TIPC's unicast and broadcast link code to update the transmit
queue maximum size counter in a single place, namely the routine that
adds messages to the queue. This ensures that the maximum size statistic
reported for unicast links is completely accurate, rather than being
partially based on statistical sampling.

Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
Integrated-by: Howard Xu <hao.xu@windriver.com>
---
 net/tipc/tipc_bcast.c |    2 --
 net/tipc/tipc_link.c  |   10 +++-------
 net/tipc/tipc_link.h  |   18 ++++++------------
 3 files changed, 9 insertions(+), 21 deletions(-)

diff --git a/net/tipc/tipc_bcast.c b/net/tipc/tipc_bcast.c
index eeb5b82..c24d565 100644
--- a/net/tipc/tipc_bcast.c
+++ b/net/tipc/tipc_bcast.c
@@ -371,8 +371,6 @@ int tipc_bclink_send_msg(struct sk_buff *buf)
 	res = tipc_link_send_buf(bcl, buf);
 	if (likely(res >= 0)) {
 		bclink_set_last_sent();
-		if (bcl->out_queue_size > bcl->stats.max_queue_sz)
-			bcl->stats.max_queue_sz = bcl->out_queue_size;
 		bcl->stats.queue_sz_counts++;
 		bcl->stats.accu_queue_sz += bcl->out_queue_size;
 	}
diff --git a/net/tipc/tipc_link.c b/net/tipc/tipc_link.c
index 98a8b92..3a898cf 100644
--- a/net/tipc/tipc_link.c
+++ b/net/tipc/tipc_link.c
@@ -329,9 +329,6 @@ static void link_timeout(struct link *l_ptr)
 	l_ptr->stats.accu_queue_sz += l_ptr->out_queue_size;
 	l_ptr->stats.queue_sz_counts++;
 
-	if (l_ptr->out_queue_size > l_ptr->stats.max_queue_sz)
-		l_ptr->stats.max_queue_sz = l_ptr->out_queue_size;
-
 	if (l_ptr->first_out) {
 		struct tipc_msg *msg = buf_msg(l_ptr->first_out);
 		u32 length = msg_size(msg);
@@ -981,7 +978,9 @@ static void link_add_to_outqueue(struct link *l_ptr,
 		l_ptr->last_out = buf;
 	} else
 		l_ptr->first_out = l_ptr->last_out = buf;
-	l_ptr->out_queue_size++;
+
+	if (++l_ptr->out_queue_size > l_ptr->stats.max_queue_sz)
+		l_ptr->stats.max_queue_sz = l_ptr->out_queue_size;
 }
 
 /*
@@ -1034,9 +1033,6 @@ int tipc_link_send_buf(struct link *l_ptr, struct sk_buff *buf)
 
 	/* Packet can be queued or sent: */
 
-	if (queue_size > l_ptr->stats.max_queue_sz)
-		l_ptr->stats.max_queue_sz = queue_size;
-
 	if (likely(!tipc_bearer_congested(l_ptr->b_ptr, l_ptr) &&
 		   !link_congested(l_ptr))) {
 		link_add_to_outqueue(l_ptr, buf, msg);
diff --git a/net/tipc/tipc_link.h b/net/tipc/tipc_link.h
index df26b82..95c99d0 100644
--- a/net/tipc/tipc_link.h
+++ b/net/tipc/tipc_link.h
@@ -197,18 +197,12 @@ struct link {
 		u32 bearer_congs;
 		u32 deferred_recv;
 		u32 duplicates;
-
-		/* for statistical profiling of send queue size */
-
-		u32 max_queue_sz;
-		u32 accu_queue_sz;
-		u32 queue_sz_counts;
-
-		/* for statistical profiling of message lengths */
-
-		u32 msg_length_counts;
-		u32 msg_lengths_total;
-		u32 msg_length_profile[7];
+		u32 max_queue_sz;	/* send queue size high water mark */
+		u32 accu_queue_sz;	/* used for send queue size profiling */
+		u32 queue_sz_counts;	/* used for send queue size profiling */
+		u32 msg_length_counts;	/* used for message length profiling */
+		u32 msg_lengths_total;	/* used for message length profiling */
+		u32 msg_length_profile[7]; /* used for msg. length profiling */
 	} stats;
 
 	struct print_buf print_buf;
-- 
1.7.0

