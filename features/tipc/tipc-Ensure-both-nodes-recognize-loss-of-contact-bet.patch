From 332eeaa496cfaa8533d8e34fbcf744d405531aab Mon Sep 17 00:00:00 2001
From: Allan Stephens <allan.stephens@windriver.com>
Date: Tue, 9 Nov 2010 15:19:16 -0500
Subject: [PATCH 18/32] tipc: Ensure both nodes recognize loss of contact between them

commit 0e2824ace97f11685ab7869c17f621e0c4d2c5ca from
git://tipc.cslab.ericsson.net/pub/git/people/allan/tipc.git

Enhances TIPC to ensure that a node that loses contact with a
neighboring node does not allow contact to be re-established until
it knows that its peer has also recognized the loss of contact.

Previously, nodes that were connected by two (or more) links could
encounter a situation in which node A would lose contact with node B
on all of its links, purge its name table of names published by B,
and then fail to repopulate those names once contact with B was restored;
this would happen because B was able to re-establish one or more links
so quickly that it never reached a point where it had no links to A --
meaning that B never saw a loss of contact with A, and consequently
didn't re-publish its names to A.

This problem is now prevented by enhancing the clean up done by TIPC
following a loss of contact with a neighboring node to ensure that
node A ignores all messages sent by B until it receives a LINK_PROTOCOL
message that indicates B has lost contact with A, thereby preventing
the (re)establishment of links between the nodes. The loss of contact
is recognized when a RESET or ACTIVATE message is received that has
a "redundant link exists" field of 0, indicating that B's sending link
endpoint is in a reset state and that B has no other working links.

Note: The reworking of the existing clean up code also eliminates a
check that prevents a link endpoint's discovery object from responding
to incoming messages while stale name table entries are being purged.
This check was unnecessary and potentially slowed down re-establishment
of communication between the nodes in some situations.

Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
Integrated-by: Howard Xu <hao.xu@windriver.com>
---
 net/tipc/tipc_discover.c |    7 -------
 net/tipc/tipc_link.c     |   19 +++++++++++++------
 net/tipc/tipc_node.c     |   11 ++++++-----
 net/tipc/tipc_node.h     |    9 +++++++--
 4 files changed, 26 insertions(+), 20 deletions(-)

diff --git a/net/tipc/tipc_discover.c b/net/tipc/tipc_discover.c
index 7111854..cbbca3c 100644
--- a/net/tipc/tipc_discover.c
+++ b/net/tipc/tipc_discover.c
@@ -169,13 +169,6 @@ void tipc_disc_recv_msg(struct sk_buff *buf, struct bearer *b_ptr)
         }
         tipc_node_lock(n_ptr);
 
-	/* Don't talk to neighbor during cleanup after last session */
-
-	if (n_ptr->cleanup_required) {
-		tipc_node_unlock(n_ptr);                
-		return;
-	}
-
 	/* Prepare to validate requesting node's signature and media address */
 
 	link = n_ptr->links[b_ptr->identity];
diff --git a/net/tipc/tipc_link.c b/net/tipc/tipc_link.c
index e8ca862..b4d61af 100644
--- a/net/tipc/tipc_link.c
+++ b/net/tipc/tipc_link.c
@@ -1850,17 +1850,24 @@ void tipc_recv_msg(struct sk_buff *head, struct tipc_bearer *tb_ptr)
 			goto cont;
 		tipc_node_lock(n_ptr);
 
-		/* Don't talk to neighbor during cleanup after last session */
+		/* Locate unicast link endpoint that should handle message */
 
-		if (n_ptr->cleanup_required) {
-			tipc_node_unlock(n_ptr);                
+		l_ptr = n_ptr->links[b_ptr->identity];
+		if (unlikely(!l_ptr)) {
+			tipc_node_unlock(n_ptr);
 			goto cont;
 		}
 
-		/* Locate unicast link endpoint that should handle message */
+		/* Verify that communication with node is currently allowed */
 
-		l_ptr = n_ptr->links[b_ptr->identity];
-		if (unlikely(!l_ptr)) {
+		if ((n_ptr->block_setup & WAIT_PEER_DOWN) &&
+		    (msg_user(msg) == LINK_PROTOCOL) &&
+		    (msg_type(msg) == RESET_MSG ||
+		     msg_type(msg) == ACTIVATE_MSG) &&
+		    !msg_redundant_link(msg))
+		    n_ptr->block_setup &= ~WAIT_PEER_DOWN;
+
+		if (n_ptr->block_setup) {
 			tipc_node_unlock(n_ptr);
 			goto cont;
 		}
diff --git a/net/tipc/tipc_node.c b/net/tipc/tipc_node.c
index b2cb81e..a58f2e5 100644
--- a/net/tipc/tipc_node.c
+++ b/net/tipc/tipc_node.c
@@ -89,6 +89,7 @@ struct tipc_node *tipc_node_create(u32 addr)
 				break;
 		}
 		list_add_tail(&n_ptr->node_list, &curr_n_ptr->node_list);
+		n_ptr->block_setup = WAIT_PEER_DOWN;
 
 		node_count++;
 	} else {
@@ -327,7 +328,7 @@ static inline void node_abort_link_changeover(struct tipc_node *n_ptr)
 }
 #endif
 
-static void node_cleanup_finished(unsigned long node_addr_arg)
+static void node_name_purge_complete(unsigned long node_addr_arg)
 {
 	u32 node_addr = (u32)node_addr_arg;
 	struct tipc_node *n_ptr;
@@ -336,7 +337,7 @@ static void node_cleanup_finished(unsigned long node_addr_arg)
 	n_ptr = tipc_net_find_node(node_addr);
 	if (n_ptr) {
 		tipc_node_lock(n_ptr);
-		n_ptr->cleanup_required = 0;
+		n_ptr->block_setup &= ~WAIT_NAMES_GONE;
 		tipc_node_unlock(n_ptr);
 	}
 	read_unlock_bh(&tipc_net_lock);
@@ -406,10 +407,10 @@ static void node_lost_contact(struct tipc_node *n_ptr)
 			      n_ptr->elm.addr);
 	}
 
-	/* Prevent re-contact with node until all cleanup is done */
+	/* Prevent re-contact with node until cleanup is done */
 
-	n_ptr->cleanup_required = 1;
-	tipc_k_signal((Handler)node_cleanup_finished, n_ptr->elm.addr);
+	n_ptr->block_setup = WAIT_PEER_DOWN | WAIT_NAMES_GONE;
+	tipc_k_signal((Handler)node_name_purge_complete, n_ptr->elm.addr);
 }
 
 u32 tipc_available_nodes(const u32 domain)
diff --git a/net/tipc/tipc_node.h b/net/tipc/tipc_node.h
index 2da2d2d..966dd2c 100644
--- a/net/tipc/tipc_node.h
+++ b/net/tipc/tipc_node.h
@@ -41,6 +41,11 @@
 #include "tipc_bearer.h"
 #include "tipc_net.h"
 
+/* Flags used to block (re)establishment of contact with a neighboring node */
+
+#define WAIT_PEER_DOWN	0x0001	/* wait to see that peer's links are down */
+#define WAIT_NAMES_GONE	0x0002	/* wait for peer's publications to be purged */
+
 /**
  * struct tipc_node - TIPC node structure
  * @elm: generic network element structure for node
@@ -51,7 +56,7 @@
  * @link_cnt: number of links to node
  * @working_links: number of working links to node (both active and standby)
  * @permit_changeover: non-zero if node has redundant links to this system
- * @cleanup_required: non-zero if cleaning up after a prior loss of contact
+ * @block_setup: bit mask of conditions preventing link establishment to node
  * @signature: random node instance identifier (always 0 for a uni-cluster node)
  * @flags: bit array indicating node's capabilities
  * @bclink: broadcast-related info
@@ -75,7 +80,7 @@ struct tipc_node {
 	int link_cnt;
 	int working_links;
 	int permit_changeover;
-	int cleanup_required;
+	int block_setup;
 	unsigned int signature;
 	unsigned int flags;
 	struct {
-- 
1.7.0

