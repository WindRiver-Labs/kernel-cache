From 5355a714c90b69fe434fac923a00acdc292edff2 Mon Sep 17 00:00:00 2001
From: Allan Stephens <allan.stephens@windriver.com>
Date: Wed, 10 Nov 2010 22:22:16 -0800
Subject: [PATCH 10/22] tipc: Fix problem with missing link in "tipc-config -l" output

commit 252d24abc8bf6a7966523c7127da6ccbab467717 from
http://tipc.cslab.ericsson.net/cgi-bin/gitweb.cgi?p=people/allan/tipc.git;a=shortlog;h=tipc1.7

Removes a race condition that could cause TIPC's internal counter
of the number of link it has to neighboring nodes to have the
incorrect value if new links were simultaneously created on different
bearers. This under counting would result in TIPC failing to list
the final link(s) in it's response to a configuration request to
list all of the nodes links. The counter is now updated atomically
to ensure the count is always updated properly.

Thanks for Peter Butler <pbutler@pt.com> for his assistance in
diagnosing and fixing this problem.

Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
Integrated-by: Howard Xu <Hao.Xu@windriver.com>
---
 net/tipc/tipc_node.c |    9 +++++----
 1 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/net/tipc/tipc_node.c b/net/tipc/tipc_node.c
index bf8255e..68480a6 100644
--- a/net/tipc/tipc_node.c
+++ b/net/tipc/tipc_node.c
@@ -50,7 +50,7 @@ static void node_established_contact(struct tipc_node *n_ptr);
 
 static LIST_HEAD(nodes_list);	/* sorted list of neighboring nodes */
 static int node_count = 0;     	/* number of neighboring nodes that exist */
-static int link_count = 0;     	/* number of unicast links node currently has */
+static atomic_t link_count = ATOMIC_INIT(0);  /* # unicast links to neighbors */
 
 static DEFINE_SPINLOCK(node_create_lock);
 
@@ -251,7 +251,7 @@ struct tipc_node *tipc_node_attach_link(struct link *l_ptr)
 		if (!n_ptr->links[bearer_id]) {
 			n_ptr->links[bearer_id] = l_ptr;
 			n_ptr->link_cnt++;
-			link_count++;
+			atomic_inc(&link_count);
 			return n_ptr;
 		}
 		tipc_addr_string_fill(addr_string, l_ptr->addr);
@@ -265,7 +265,7 @@ void tipc_node_detach_link(struct tipc_node *n_ptr, struct link *l_ptr)
 {
 	n_ptr->links[l_ptr->b_ptr->identity] = NULL;
 	n_ptr->link_cnt--;
-	link_count--;
+	atomic_dec(&link_count);
 }
 
 static void node_established_contact(struct tipc_node *n_ptr)
@@ -515,7 +515,8 @@ struct sk_buff *tipc_node_get_links(const void *req_tlv_area, int req_tlv_space)
 
 	/* Get space for all unicast links + broadcast link */
 
-	payload_size = TLV_SPACE(sizeof(link_info)) * (link_count + 1);
+	payload_size = TLV_SPACE(sizeof(link_info)) *
+		(atomic_read(&link_count) + 1);
 	if (payload_size > 32768u) {
 		read_unlock_bh(&tipc_net_lock);
 		return tipc_cfg_reply_error_string(TIPC_CFG_NOT_SUPPORTED
-- 
1.6.5.2

