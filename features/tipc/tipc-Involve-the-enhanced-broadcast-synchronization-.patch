From e7199eaf23d1cc8d802b5073cdf97ff69a2d540c Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Wed, 27 Feb 2013 10:37:03 +0800
Subject: [PATCH 5/5] tipc: Involve the enhanced broadcast synchronization mechanism

Currently there have two major known issues about broadcast link as belows:

1. There has one risk that name table updates sent over the broadcast link
after the neighbor is discovered will arrive before the initial transfer of
name table entries over the unicast link has been completed.

2. There has another risk that the node may send a broadcast message after the
neighbor is discovered without being certain whether the neighbor will
acknowledge it or not.

At present, the sending node cannot assume that the neighbor's link endpoint is
in the WW state just because its own link endpoint is in that state, which
means that is it doesn't know if the neighbor will process the broadcast
message or ignore it. However, once all of the name table messages are
acknowledged the node can be certain that the other end is in WW state and that
broadcast message will be processed.

Therefore, when the neighbor node is added to the sending node's broadcast link
map, the sending node should send all name table entries over the unicast link.
After these name table messages have been sent, it should immediately send one
explicit message that tells the neighbor node to start accepting broadcast
messages, which can resolve the first problem.

Since the explicit message contains the sequence number of the most recent
broadcast message the sending node has sent when it adds the neighbor node to
its broadcast link map, it can tell the neighbor node where to start receiving
and acknowledging broadcast messages, which can resolve the second problem.

Signed-off-by: Ying Xue <ying.xue@windriver.com>
---
 net/tipc/tipc_bcast.c      |   27 +++++++++++++++++++++++++
 net/tipc/tipc_bcast.h      |    1 +
 net/tipc/tipc_link.c       |   46 ++++++++++++++++++++++++++++++++++++++++++++
 net/tipc/tipc_link.h       |    1 +
 net/tipc/tipc_name_distr.c |    1 +
 net/tipc/tipc_node.c       |    2 +-
 6 files changed, 77 insertions(+), 1 deletions(-)

diff --git a/net/tipc/tipc_bcast.c b/net/tipc/tipc_bcast.c
index c53dcfb..f11355c 100644
--- a/net/tipc/tipc_bcast.c
+++ b/net/tipc/tipc_bcast.c
@@ -381,6 +381,33 @@ static void bclink_peek_nack(struct tipc_msg *msg)
 }
 
 /**
+ * tipc_bclink_info_recv - synchronize broadcast link info
+ */
+
+void tipc_bclink_info_recv(struct sk_buff *buf)
+{
+	struct tipc_node *n_ptr;
+	struct tipc_msg *msg = buf_msg(buf);
+
+	n_ptr = tipc_net_find_node(msg_prevnode(msg));
+	if (unlikely(!n_ptr)) {
+		buf_discard(buf);
+		return;
+	}
+
+	tipc_node_lock(n_ptr);
+	if (!n_ptr->bclink.supported && n_ptr->bclink.supportable &&
+	    n_ptr->bclink.sync) {
+		n_ptr->bclink.supported = 1;
+		n_ptr->bclink.last_sent = n_ptr->bclink.last_in =
+					  msg_last_bcast(msg);
+		n_ptr->bclink.oos_state = 0;
+	}
+	tipc_node_unlock(n_ptr);
+	buf_discard(buf);
+}
+
+/**
  * tipc_bclink_send_msg - broadcast a packet to all nodes in cluster
  */
 
diff --git a/net/tipc/tipc_bcast.h b/net/tipc/tipc_bcast.h
index 2e668d1..d948137 100644
--- a/net/tipc/tipc_bcast.h
+++ b/net/tipc/tipc_bcast.h
@@ -93,6 +93,7 @@ void tipc_bclink_add_node(u32 addr);
 void tipc_bclink_remove_node(u32 addr);
 struct tipc_node *tipc_bclink_retransmit_to(void);
 void tipc_bclink_acknowledge(struct tipc_node *n_ptr, u32 acked);
+void tipc_bclink_info_recv(struct sk_buff *buf);
 int  tipc_bclink_send_msg(struct sk_buff *buf);
 void tipc_bclink_recv_pkt(struct sk_buff *buf);
 u32  tipc_bclink_get_last_sent(void);
diff --git a/net/tipc/tipc_link.c b/net/tipc/tipc_link.c
index d8c98e9..0248178 100644
--- a/net/tipc/tipc_link.c
+++ b/net/tipc/tipc_link.c
@@ -1181,6 +1181,48 @@ void tipc_link_send_names(struct list_head *message_list, u32 dest)
 }
 
 /*
+ * tipc_link_send_bclink_info - send broadcast link info to new neighbor
+ *
+ * Send broadcast link info to open up for the new neighbor to accept broadcast
+ * message from the point contained in "last sent broadcast number" field and
+ * onwards. No link congestion checking is performed because the last sent
+ * broadcast number info *must* be delivered.
+ */
+
+void tipc_link_send_bclink_info(u32 dest)
+{
+	struct tipc_node *n_ptr;
+	struct link *l_ptr;
+	struct sk_buff *buf;
+
+	read_lock_bh(&tipc_net_lock);
+	n_ptr = tipc_net_select_node(dest);
+	if (n_ptr) {
+		tipc_node_lock(n_ptr);
+		buf = buf_acquire(INT_H_SIZE);
+		if (buf) {
+			struct tipc_msg *msg = buf_msg(buf);
+
+			tipc_msg_init(msg, BCAST_PROTOCOL, STATE_MSG,
+				      INT_H_SIZE, dest);
+			msg_set_non_seq(msg, 0);
+			msg_set_last_bcast(msg, n_ptr->bclink.acked);
+			msg_set_link_selector(msg, (dest & 1));
+
+			l_ptr = n_ptr->active_links[0];
+			if (l_ptr) {
+				link_add_chain_to_outqueue(l_ptr, buf);
+				tipc_link_push_queue(l_ptr);
+			} else {
+				buf_discard(buf);
+			}
+		}
+		tipc_node_unlock(n_ptr);
+	}
+	read_unlock_bh(&tipc_net_lock);
+}
+
+/*
  * link_send_buf_fast: Entry for data messages where the
  * destination link is known and the header is complete,
  * inclusive total message length. Very time critical.
@@ -2004,6 +2046,10 @@ deliver:
                                         tipc_node_unlock(n_ptr);
 					tipc_route_recv(buf);
                                         continue;
+				case BCAST_PROTOCOL:
+					tipc_node_unlock(n_ptr);
+					tipc_bclink_info_recv(buf);
+					continue;
                                 case CONN_MANAGER:
                                         /* route message normally */
                                         break;
diff --git a/net/tipc/tipc_link.h b/net/tipc/tipc_link.h
index 19277cd..58eeebc 100644
--- a/net/tipc/tipc_link.h
+++ b/net/tipc/tipc_link.h
@@ -234,6 +234,7 @@ struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area, u32 req_tlv_
 void tipc_link_reset(struct link *l_ptr);
 int tipc_link_send(struct sk_buff *buf, u32 dest, u32 selector);
 void tipc_link_send_names(struct list_head *message_list, u32 dest);
+void tipc_link_send_bclink_info(u32 dest);
 int tipc_link_send_buf(struct link *l_ptr, struct sk_buff *buf);
 u32 tipc_link_get_max_pkt(u32 dest,u32 selector);
 int tipc_link_send_sections_fast(struct port* sender,
diff --git a/net/tipc/tipc_name_distr.c b/net/tipc/tipc_name_distr.c
index 1810313..026b761 100644
--- a/net/tipc/tipc_name_distr.c
+++ b/net/tipc/tipc_name_distr.c
@@ -352,6 +352,7 @@ void tipc_named_node_up(unsigned long node_arg)
 	read_unlock_bh(&tipc_nametbl_lock); 
 
 	tipc_link_send_names(&delivery_list, node);
+	tipc_link_send_bclink_info(node);
 }
 
 /**
diff --git a/net/tipc/tipc_node.c b/net/tipc/tipc_node.c
index d182504..d2e3838 100644
--- a/net/tipc/tipc_node.c
+++ b/net/tipc/tipc_node.c
@@ -330,7 +330,7 @@ static void node_lost_contact(struct tipc_node *n_ptr)
 
 	/* Flush broadcast link info associated with lost node */
 
-	if (n_ptr->bclink.supported) {
+	if (n_ptr->bclink.supportable) {
 		while (n_ptr->bclink.deferred_head) {
 			struct sk_buff *buf = n_ptr->bclink.deferred_head;
 
-- 
1.7.0

