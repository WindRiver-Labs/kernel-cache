From 41e85013d4a86e16f8be42b933674d2f24d45077 Mon Sep 17 00:00:00 2001
From: Allan Stephens <allan.stephens@windriver.com>
Date: Wed, 1 Dec 2010 05:58:03 -0500
Subject: [PATCH 30/32] tipc: Optimizations to link creation code

commit 6bb56635981f745b08f22df25d74de46f640a456 from
git://tipc.cslab.ericsson.net/pub/git/people/allan/tipc.git

Enhances link creation code as follows:

1) Detects illegal attempts to add a requested link earlier in the
   link creation process. This prevents TIPC from wasting time
   initializing a link object it then throws away, and also eliminates
   the code needed to do the throwing away.

2) Passes in the node object associated with the requested link.
   This allows TIPC to eliminate a search to locate the node object,
   as well as code that attempted to create the node if it doesn't
   exist.

Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
Integrated-by: Howard Xu <hao.xu@windriver.com>
---
 net/tipc/tipc_discover.c |    2 +-
 net/tipc/tipc_link.c     |   31 ++++++++++++++++++++-----------
 net/tipc/tipc_link.h     |    2 +-
 net/tipc/tipc_node.c     |   31 ++++---------------------------
 net/tipc/tipc_node.h     |    2 +-
 5 files changed, 27 insertions(+), 41 deletions(-)

diff --git a/net/tipc/tipc_discover.c b/net/tipc/tipc_discover.c
index cbbca3c..9fbe20b 100644
--- a/net/tipc/tipc_discover.c
+++ b/net/tipc/tipc_discover.c
@@ -254,7 +254,7 @@ void tipc_disc_recv_msg(struct sk_buff *buf, struct bearer *b_ptr)
 			return;
 		}
 #endif
-		link = tipc_link_create(b_ptr, orig, &media_addr);
+		link = tipc_link_create(n_ptr, b_ptr, &media_addr);
 		if (link == NULL) {
 			warn("Memory squeeze; Failed to create link\n");
 			tipc_node_unlock(n_ptr);
diff --git a/net/tipc/tipc_link.c b/net/tipc/tipc_link.c
index b3e44cf..b28b900 100644
--- a/net/tipc/tipc_link.c
+++ b/net/tipc/tipc_link.c
@@ -370,19 +370,35 @@ static void link_set_timer(struct link *l_ptr, u32 time)
 
 /**
  * tipc_link_create - create a new link
+ * @n_ptr: point to associated node
  * @b_ptr: pointer to associated bearer
- * @peer: network address of node at other end of link
  * @media_addr: media address to use when sending messages over link
  *
  * Returns pointer to link.
  */
 
-struct link *tipc_link_create(struct bearer *b_ptr, const u32 peer,
+struct link *tipc_link_create(struct tipc_node *n_ptr, struct bearer *b_ptr,
 			      const struct tipc_media_addr *media_addr)
 {
 	struct link *l_ptr;
 	struct tipc_msg *msg;
 	char *if_name;
+	char addr_string[16];
+	u32 peer = n_ptr->elm.addr;
+
+	if (n_ptr->link_cnt >= TIPC_MAX_BEARERS) {
+		tipc_addr_string_fill(addr_string, n_ptr->elm.addr);
+		err("Attempt to establish more than %d links to %s\n",
+		    n_ptr->link_cnt, addr_string);
+		return NULL;
+	}
+
+	if (n_ptr->links[b_ptr->identity]) {
+		tipc_addr_string_fill(addr_string, n_ptr->elm.addr);
+		err("Attempt to establish second link on <%s> to %s \n",
+		    b_ptr->publ.name, addr_string);
+		return NULL;
+	}
 
 	l_ptr = kzalloc(sizeof(*l_ptr), GFP_ATOMIC);
 	if (!l_ptr) {
@@ -410,6 +426,7 @@ struct link *tipc_link_create(struct bearer *b_ptr, const u32 peer,
 		tipc_zone(peer), tipc_cluster(peer), tipc_node(peer));
 		/* note: peer i/f is appended to link name by reset/activate */
 	memcpy(&l_ptr->media_addr, media_addr, sizeof(*media_addr));
+	l_ptr->owner = n_ptr;
 	l_ptr->checkpoint = 1;
 	l_ptr->peer_session = INVALID_SESSION;
 	l_ptr->b_ptr = b_ptr;
@@ -428,15 +445,7 @@ struct link *tipc_link_create(struct bearer *b_ptr, const u32 peer,
 	l_ptr->next_out_no = 1;
 	INIT_LIST_HEAD(&l_ptr->waiting_ports);
 	link_reset_statistics(l_ptr);
-
-	l_ptr->owner = tipc_node_attach_link(l_ptr);
-	if (!l_ptr->owner) {
-		if (LINK_LOG_BUF_SIZE)
-			kfree(l_ptr->print_buf.buf);
-		kfree(l_ptr);
-		return NULL;
-	}
-
+	tipc_node_attach_link(n_ptr, l_ptr);
 	k_init_timer(&l_ptr->timer, (Handler)link_timeout, (unsigned long)l_ptr);
 	list_add_tail(&l_ptr->link_list, &b_ptr->links);
 
diff --git a/net/tipc/tipc_link.h b/net/tipc/tipc_link.h
index 17a522a..de0cc57 100644
--- a/net/tipc/tipc_link.h
+++ b/net/tipc/tipc_link.h
@@ -210,7 +210,7 @@ struct link {
 
 struct port;
 
-struct link *tipc_link_create(struct bearer *b_ptr, const u32 peer,
+struct link *tipc_link_create(struct tipc_node *n_ptr, struct bearer *b_ptr,
 			      const struct tipc_media_addr *media_addr);
 void tipc_link_delete(struct link *l_ptr);
 void tipc_link_changeover(struct link *l_ptr);
diff --git a/net/tipc/tipc_node.c b/net/tipc/tipc_node.c
index a58f2e5..f031591 100644
--- a/net/tipc/tipc_node.c
+++ b/net/tipc/tipc_node.c
@@ -236,34 +236,11 @@ int tipc_node_alt_link_is_up(struct link *l_ptr)
 #endif
 }
 
-struct tipc_node *tipc_node_attach_link(struct link *l_ptr)
+void tipc_node_attach_link(struct tipc_node *n_ptr, struct link *l_ptr)
 {
-	struct tipc_node *n_ptr = tipc_net_find_node(l_ptr->addr);
-
-	if (!n_ptr)
-		n_ptr = tipc_node_create(l_ptr->addr);
-	if (n_ptr) {
-		u32 bearer_id = l_ptr->b_ptr->identity;
-		char addr_string[16];
-
-		if (n_ptr->link_cnt >= TIPC_MAX_BEARERS) {
-			tipc_addr_string_fill(addr_string, n_ptr->elm.addr);
-			err("Attempt to more than %d links to %s\n",
-			    n_ptr->link_cnt, addr_string);
-			return NULL;
-		}
-
-		if (!n_ptr->links[bearer_id]) {
-			n_ptr->links[bearer_id] = l_ptr;
-			n_ptr->link_cnt++;
-			atomic_inc(&link_count);
-			return n_ptr;
-		}
-		tipc_addr_string_fill(addr_string, l_ptr->addr);
-		err("Attempt to establish second link on <%s> to %s \n",
-		    l_ptr->b_ptr->publ.name, addr_string);
-	}
-	return NULL;
+	n_ptr->links[l_ptr->b_ptr->identity] = l_ptr;
+	n_ptr->link_cnt++;
+	atomic_inc(&link_count);
 }
 
 void tipc_node_detach_link(struct tipc_node *n_ptr, struct link *l_ptr)
diff --git a/net/tipc/tipc_node.h b/net/tipc/tipc_node.h
index 966dd2c..ce370e2 100644
--- a/net/tipc/tipc_node.h
+++ b/net/tipc/tipc_node.h
@@ -103,7 +103,7 @@ void tipc_node_link_up(struct tipc_node *n_ptr, struct link *l_ptr);
 void tipc_node_link_down(struct tipc_node *n_ptr, struct link *l_ptr);
 int tipc_node_alt_link_is_up(struct link *l_ptr);
 int tipc_node_is_up(struct tipc_node *n_ptr);
-struct tipc_node *tipc_node_attach_link(struct link *l_ptr);
+void tipc_node_attach_link(struct tipc_node *n_ptr, struct link *l_ptr);
 void tipc_node_detach_link(struct tipc_node *n_ptr, struct link *l_ptr);
 struct sk_buff *tipc_node_get_nodes(const void *req_tlv_area, u32 req_tlv_space);
 struct sk_buff *tipc_node_get_links(const void *req_tlv_area, u32 req_tlv_space);
-- 
1.7.0

