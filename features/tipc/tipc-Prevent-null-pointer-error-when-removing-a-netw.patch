From b74763c720f7e77835150189c18bb1101b2b8321 Mon Sep 17 00:00:00 2001
From: Allan Stephens <allan.stephens@windriver.com>
Date: Wed, 10 Nov 2010 22:22:22 -0800
Subject: [PATCH 16/22] tipc: Prevent null pointer error when removing a network subscription

commit 19e02f220375d7f33d2b59b0a4a2512f30773245 from
http://tipc.cslab.ericsson.net/cgi-bin/gitweb.cgi?p=people/allan/tipc.git;a=shortlog;h=tipc1.7

Prevents a null pointer dereference from occurring if a network
element subscription is triggered at the same time that the subscribing
port or publication is terminating the subscription. The problem arises
if the triggering routine asynchronously activates and deregisters the
subscription while deregistration is already underway. To avoid this
race condition the triggering routine now marks the subscription as
defunct (instead of deregistering it) and lets the subscribing port or
publication code terminate the subscription in the normal manner.

Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
Integrated-by: Howard Xu <Hao.Xu@windriver.com>
---
 net/tipc/tipc_name_distr.c |    8 ++------
 net/tipc/tipc_net.c        |    9 ++++-----
 2 files changed, 6 insertions(+), 11 deletions(-)

diff --git a/net/tipc/tipc_name_distr.c b/net/tipc/tipc_name_distr.c
index dc62a0f..d8ab5e7 100644
--- a/net/tipc/tipc_name_distr.c
+++ b/net/tipc/tipc_name_distr.c
@@ -561,9 +561,6 @@ void tipc_named_distribute(struct publication *publ, int msg_type,
  * In rare cases the link may have come back up again when this
  * function is called, and we have two items representing the same
  * publication. Nudge this item's key to distinguish it from the other.
- *
- * Publication's network element subscription is already unsubscribed, 
- * so we don't have to do that here ...
  */
 
 static void named_purge_publ(struct publication *publ)
@@ -574,6 +571,7 @@ static void named_purge_publ(struct publication *publ)
 	publ = tipc_nametbl_remove_publ(publ->type, publ->lower, 
 					publ->node, publ->ref, publ->key);
 	if (publ != NULL) {
+		tipc_netsub_unbind(&publ->subscr);
 		tipc_named_remove_publ(publ);
 	}
 
@@ -1045,9 +1043,6 @@ void tipc_route_distribute(struct publication *publ, int msg_type,
  * In rare cases the link may have come back up again when this
  * function is called, and we have two items representing the same
  * publication. Nudge this item's key to distinguish it from the other.
- *
- * Publication's network element subscription is already unsubscribed, 
- * so we don't have to do that here ...
  */
 
 static void route_purge_publ(struct publication *publ)
@@ -1058,6 +1053,7 @@ static void route_purge_publ(struct publication *publ)
 	publ = tipc_nameseq_remove_publ(route_table,publ->lower, 
 					publ->node, publ->ref, publ->key);
 	if (publ != NULL) {
+		tipc_netsub_unbind(&publ->subscr);
 		tipc_all_routes--;
 		tipc_route_remove_publ(publ);
 	}
diff --git a/net/tipc/tipc_net.c b/net/tipc/tipc_net.c
index 65492e9..965b231 100644
--- a/net/tipc/tipc_net.c
+++ b/net/tipc/tipc_net.c
@@ -482,14 +482,13 @@ void tipc_netsub_unbind(struct net_subscr *net_sub)
 void tipc_netsub_notify(struct net_element *e_ptr, u32 affected_addr)
 {
 	struct net_subscr *ns;
-	struct net_subscr *tns;
 
-	list_for_each_entry_safe(ns, tns, &e_ptr->nsub, sub_list) {
-		if (tipc_in_scope(affected_addr, ns->addr)) {
-			ns->element = NULL;
-			list_del_init(&ns->sub_list);
+	list_for_each_entry(ns, &e_ptr->nsub, sub_list) {
+		if (ns->handle_element_down &&
+		    tipc_in_scope(affected_addr, ns->addr)) {
 			tipc_k_signal((Handler)ns->handle_element_down,
 				      (unsigned long)ns->usr_handle);
+			ns->handle_element_down = NULL;
 		}
 	}
 }
-- 
1.6.5.2

