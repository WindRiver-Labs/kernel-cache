From 7448ed736c0ceacab207bbfdf6dfc5b2489b2265 Mon Sep 17 00:00:00 2001
From: Allan Stephens <allan.stephens@windriver.com>
Date: Wed, 10 Nov 2010 22:22:13 -0800
Subject: [PATCH 07/22] tipc: Ensure broadcast link re-acquires node after link failure

commit fb1fbf4c678b2cf970c411fa9ff55e28102c0e20 from
http://tipc.cslab.ericsson.net/cgi-bin/gitweb.cgi?p=people/allan/tipc.git;a=shortlog;h=tipc1.7

Fixes a bug that can prevent TIPC from sending broadcast messages to a node
if contact with the node is lost and then regained. The problem occurs if
the broadcast link first clears the flag indicating the node is part of the
link's distribution set (when it loses contact with the node), and later
fails to restore the flag (when contact is regained); restoration fails
if contact with the node is regained by implicit unicast link activation
triggered by the arrival of a data message, rather than explicitly by the
arrival of a link activation message.

The broadcast link now uses separate fields to track whether a node is
theoretically capable of receiving broadcast messages versus whether it is
actually part of the link's distribution set. The former member is updated
by the receipt of link protocol messages, which can occur at any time; the
latter member is updated only when contact with the node is gained or lost.
This change also permits the simplification of several conditional
expressions since the broadcast link's "supported" field can now only be
set if there are working links to the associated node.

Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
Integrated-by: Howard Xu <Hao.Xu@windriver.com>
---
 net/tipc/tipc_bcast.c |    4 ++--
 net/tipc/tipc_link.c  |    7 +++----
 net/tipc/tipc_node.c  |    4 +++-
 net/tipc/tipc_node.h  |    6 ++++--
 4 files changed, 12 insertions(+), 9 deletions(-)

diff --git a/net/tipc/tipc_bcast.c b/net/tipc/tipc_bcast.c
index 9c537e8..2cef236 100644
--- a/net/tipc/tipc_bcast.c
+++ b/net/tipc/tipc_bcast.c
@@ -321,7 +321,7 @@ static void bclink_peek_nack(struct tipc_msg *msg)
 
 	tipc_node_lock(n_ptr);
 
-	if (tipc_node_is_up(n_ptr) && n_ptr->bclink.supported &&
+	if (n_ptr->bclink.supported &&
 	    (n_ptr->bclink.last_in != n_ptr->bclink.last_sent) &&
 	    (n_ptr->bclink.last_in == msg_bcgap_after(msg)))
 		n_ptr->bclink.oos_state = 2;
@@ -394,7 +394,7 @@ void tipc_bclink_recv_pkt(struct sk_buff *buf)
 		goto exit;
 
 	tipc_node_lock(node);
-	if (unlikely(!tipc_node_is_up(node) || !node->bclink.supported))
+	if (unlikely(!node->bclink.supported))
 		goto unlock;
 
 	/* Handle broadcast protocol message */
diff --git a/net/tipc/tipc_link.c b/net/tipc/tipc_link.c
index 0b59753..fd664c0 100644
--- a/net/tipc/tipc_link.c
+++ b/net/tipc/tipc_link.c
@@ -1631,6 +1631,7 @@ static void link_retransmit_failure(struct link *l_ptr, struct sk_buff *buf)
 
 		tipc_addr_string_fill(addr_string, n_ptr->elm.addr);
 		dbg_printf(TIPC_OUTPUT, "Broadcast link info for %s\n", addr_string);
+		dbg_printf(TIPC_OUTPUT, "Supportable: %d,  ", n_ptr->bclink.supportable);
 		dbg_printf(TIPC_OUTPUT, "Supported: %d,  ", n_ptr->bclink.supported);
 		dbg_printf(TIPC_OUTPUT, "Acked: %u\n", n_ptr->bclink.acked);
 		dbg_printf(TIPC_OUTPUT, "Last in: %u,  ", n_ptr->bclink.last_in);
@@ -1874,7 +1875,7 @@ void tipc_recv_msg(struct sk_buff *head, struct tipc_bearer *tb_ptr)
 		/* Release acked messages */
 
 		if (less(n_ptr->bclink.acked, msg_bcast_ack(msg)) &&
-		    tipc_node_is_up(n_ptr) && n_ptr->bclink.supported) {
+		    n_ptr->bclink.supported) {
 			tipc_bclink_acknowledge(n_ptr, msg_bcast_ack(msg));
 		}
 
@@ -2291,9 +2292,7 @@ static void link_recv_proto_msg(struct link *l_ptr, struct sk_buff *buf)
 		} else {
 			l_ptr->max_pkt = l_ptr->max_pkt_target;
 		}
-		l_ptr->owner->bclink.supported = 
-			in_own_cluster(l_ptr->owner->elm.addr) &&
-			(max_pkt_info != 0);
+		l_ptr->owner->bclink.supportable = (max_pkt_info != 0);
 
 		/* Synchronize broadcast link info, if not done previously */
 
diff --git a/net/tipc/tipc_node.c b/net/tipc/tipc_node.c
index 4905699..bf8255e 100644
--- a/net/tipc/tipc_node.c
+++ b/net/tipc/tipc_node.c
@@ -280,8 +280,10 @@ static void node_established_contact(struct tipc_node *n_ptr)
 
 		/* Add to multicast destination map, if applicable */
 
-		if (n_ptr->bclink.supported)
+		if (n_ptr->bclink.supportable) {
 			tipc_bclink_add_node(n_ptr->elm.addr);
+			n_ptr->bclink.supported = 1;
+		}
 	} else {
 
 		/* Publish new inter-cluster (or inter-zone) route */
diff --git a/net/tipc/tipc_node.h b/net/tipc/tipc_node.h
index bc901a2..5075254 100644
--- a/net/tipc/tipc_node.h
+++ b/net/tipc/tipc_node.h
@@ -55,7 +55,8 @@
  * @signature: random node instance identifier (always 0 for a uni-cluster node)
  * @flags: bit array indicating node's capabilities
  * @bclink: broadcast-related info
- *    @supported: non-zero if node supports TIPC b'cast capability
+ *    @supportable: non-zero if node supports TIPC b'cast link capability
+ *    @supported: non-zero if node is currently part of b'cast link group
  *    @acked: sequence # of last outbound b'cast message acknowledged by node
  *    @last_in: sequence # of last in-sequence b'cast message received from node
  *    @last_sent: sequence # of last b'cast message sent by node
@@ -78,7 +79,8 @@ struct tipc_node {
 	u16 signature;
 	u16 flags;
 	struct {
-		int supported;
+		char supportable;
+		char supported;
 		u32 acked;
 		u32 last_in;
 		u32 last_sent;
-- 
1.6.5.2

