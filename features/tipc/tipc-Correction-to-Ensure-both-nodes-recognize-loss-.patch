From 26bb3ad0f118815df45f434f1a1fbbade7420712 Mon Sep 17 00:00:00 2001
From: Allan Stephens <allan.stephens@windriver.com>
Date: Wed, 6 Apr 2011 15:41:43 -0400
Subject: [PATCH 4/6] tipc: Correction to "Ensure both nodes recognize loss of contact" patch

Supplements the checks that were added to TIPC's link code by the
patch "Ensure both nodes recognize loss of contact between them" to
prevent problems in re-establishing links at both ends.

1) TIPC now suppresses the sending of (most) link protocol messages
to a neighboring node while it is cleaning up after an earlier loss
of contact with that node; this stops the peer node from prematurely
activating its link endpoint, which would prevent TIPC from later
activating its own end. TIPC still allows outgoing RESET messages to
occur during cleanup, to avoid problems if its own node recognizes
the loss of contact first and tries to notify the peer of the situation.

2) TIPC now recognizes an impending loss of contact with a peer node
as soon as it receives a RESET message on a working link that is the
peer's only link to the node, and ensures that the link protocol
suppression mentioned above goes into effect right away -- that is,
even before its own link endpoints have failed. This is necessary to
ensure correct operation when there are redundant links between the nodes,
since otherwise TIPC would send an ACTIVATE message upon receiving a RESET
on its first link and only begin suppressing when a RESET on its second
link was received, instead of initiating suppression with the first RESET
message as it needs to.

Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
---
 net/tipc/tipc_link.c |   13 +++++++++++++
 net/tipc/tipc_node.h |    1 +
 2 files changed, 14 insertions(+), 0 deletions(-)

diff --git a/net/tipc/tipc_link.c b/net/tipc/tipc_link.c
index 4dc0cb1..2359d8c 100644
--- a/net/tipc/tipc_link.c
+++ b/net/tipc/tipc_link.c
@@ -2192,6 +2192,11 @@ void tipc_link_send_proto_msg(struct link *l_ptr, u32 msg_typ, int probe_msg,
 	if (link_blocked(l_ptr))
 		return;
 
+	/* Abort non-RESET send if communication with node is prohibited */
+
+	if ((l_ptr->owner->block_setup) && (msg_typ != RESET_MSG))
+		return;
+
 	/* Create protocol message with "out-of-sequence" sequence number */
 
 	msg_set_type(msg, msg_typ);
@@ -2325,6 +2330,14 @@ static void link_recv_proto_msg(struct link *l_ptr, struct sk_buff *buf)
 				break; /* duplicate or old reset: ignore */
 			}
 		}
+
+		if (!msg_redundant_link(msg) &&
+		    (link_working_working(l_ptr) ||
+		     link_working_unknown(l_ptr)))
+			l_ptr->owner->block_setup = WAIT_NODE_DOWN;
+			/* peer has lost contact -- don't allow peer's links
+			   to reactivate before we recognize loss & clean up */
+
 		link_state_event(l_ptr, RESET_MSG);
                 if (msg_stop(msg)) {
                         l_ptr->blocked = 1;
diff --git a/net/tipc/tipc_node.h b/net/tipc/tipc_node.h
index ce370e2..d812b9b 100644
--- a/net/tipc/tipc_node.h
+++ b/net/tipc/tipc_node.h
@@ -45,6 +45,7 @@
 
 #define WAIT_PEER_DOWN	0x0001	/* wait to see that peer's links are down */
 #define WAIT_NAMES_GONE	0x0002	/* wait for peer's publications to be purged */
+#define WAIT_NODE_DOWN	0x0004	/* wait until peer node is declared down */
 
 /**
  * struct tipc_node - TIPC node structure
-- 
1.7.0.4

