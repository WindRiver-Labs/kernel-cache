From a516f7a0569029b8d769d78e087113165e21f7ce Mon Sep 17 00:00:00 2001
From: Allan Stephens <allan.stephens@windriver.com>
Date: Wed, 17 Nov 2010 17:26:17 -0500
Subject: [PATCH 25/32] tipc: Fix bugs in port congestion control

commit 2caba72e0722c3f4fab528a71c4d3ea430098aae from
git://tipc.cslab.ericsson.net/pub/git/people/allan/tipc.git

Modifies TIPC's congestion control between a connected port and its
peer so that it works as documented. The following changes have been
made:

1) The counter of the number of messages sent by a port now starts
   at zero, rather than one. This prevents the port from reporting port
   congestion one message earlier than it was supposed to.

2) The counter of the number of messages sent by a port is now
   incremented only if a non-empty message is sent successfully.
   This prevents the port from becoming permanently congested if
   too many send attempts are unsuccessful because of congestion
   (or other reasons). It also removes the risk that empty hand-
   shaking messages used during connection setup might cause the
   port to report congestion earlier than it was supposed to.

3) The counter of the number of unacknowledged messages received by
   a port controlled by an application using TIPC's native API is
   now incremented only if the message is non-empty, in order to be
   consistent with the aforementioned changes.

Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
Integrated-by: Howard Xu <hao.xu@windriver.com>
---
 net/tipc/tipc_port.c |  101 +++++++++++++++++++++++++++----------------------
 net/tipc/tipc_port.h |    4 +-
 2 files changed, 58 insertions(+), 47 deletions(-)

diff --git a/net/tipc/tipc_port.c b/net/tipc/tipc_port.c
index 2f78034..e3485a7 100644
--- a/net/tipc/tipc_port.c
+++ b/net/tipc/tipc_port.c
@@ -239,7 +239,6 @@ struct tipc_port *tipc_createport_raw(void *usr_handle,
 	p_ptr->publ.usr_handle = usr_handle;
 	p_ptr->publ.max_pkt = MAX_PKT_DEFAULT;
 	p_ptr->publ.ref = ref;
-	p_ptr->sent = 1;
 	INIT_LIST_HEAD(&p_ptr->wait_list);
 	INIT_LIST_HEAD(&p_ptr->subscription.sub_list);
 	p_ptr->dispatcher = dispatcher;
@@ -808,6 +807,7 @@ static void port_dispatcher_sigh(void *dummy)
 				tipc_conn_msg_event cb = up_ptr->conn_msg_cb;
 				u32 peer_port = port_peerport(p_ptr);
 				u32 peer_node = port_peernode(p_ptr);
+				u32 dsz;
 
 				tipc_port_unlock(p_ptr);
 				if (unlikely(!cb))
@@ -820,13 +820,14 @@ static void port_dispatcher_sigh(void *dummy)
 					goto reject;
 				/* TODO: Don't access conn_unacked field
 					 while port is unlocked ... */
-				if (unlikely(++p_ptr->publ.conn_unacked >=
-					     TIPC_FLOW_CONTROL_WIN))
+				dsz = msg_data_sz(msg);
+				if (unlikely(dsz &&
+					     (++p_ptr->publ.conn_unacked >=
+					      TIPC_FLOW_CONTROL_WIN)))
 					tipc_acknowledge(dref,
 							 p_ptr->publ.conn_unacked);
 				skb_pull(buf, msg_hdr_sz(msg));
-				cb(usr_handle, dref, &buf, msg_data(msg),
-				   msg_data_sz(msg));
+				cb(usr_handle, dref, &buf, msg_data(msg), dsz);
 				break;
 			}
 		case TIPC_DIRECT_MSG:{
@@ -1406,16 +1407,15 @@ int tipc_send(u32 ref, unsigned int num_sect, struct iovec const *msg_sect)
 		else
 			res = tipc_port_recv_sections(p_ptr, num_sect,
 						      msg_sect);
-
 		if (likely(res != -ELINKCONG)) {
 			p_ptr->publ.congested = 0;
-			p_ptr->sent++;
+			if (res > 0)
+				p_ptr->sent++;
 			return res;
 		}
 	}
 	if (port_unreliable(p_ptr)) {
 		p_ptr->publ.congested = 0;
-		/* Just calculate msg length and return */
 		return tipc_msg_calc_data_size(msg_sect, num_sect);
 	}
 	return -ELINKCONG;
@@ -1453,14 +1453,12 @@ int tipc_send_buf(u32 ref, struct sk_buff *buf, unsigned int dsz)
 		destnode = port_peernode(p_ptr);
 		if (!addr_in_node(destnode))
 			res = tipc_send_buf_fast(buf, destnode);
-		else {
-			tipc_port_recv_msg(buf);
-			res = sz;
-		}
-
+		else
+			res = tipc_port_recv_msg(buf);
 		if (likely(res != -ELINKCONG)) {
 			p_ptr->publ.congested = 0;
-			p_ptr->sent++;
+			if (res > 0)
+				p_ptr->sent++;
 			return res;
 		}
 	}
@@ -1508,20 +1506,22 @@ int tipc_forward2name(u32 ref,
 	msg_set_destport(msg, destport);
 
 	if (likely(destport || destnode)) {
-		p_ptr->sent++;
 		if (addr_in_node(destnode))
-			return tipc_port_recv_sections(p_ptr, num_sect,
-						       msg_sect);
-		if (!orig->node)
-			msg_set_orignode(msg, tipc_own_addr);
-		res = tipc_link_send_sections_fast(p_ptr, msg_sect, num_sect,
-						   destnode);
-		if (likely(res != -ELINKCONG))
+			res = tipc_port_recv_sections(p_ptr, num_sect,
+						      msg_sect);
+		else {
+			if (!orig->node)
+				msg_set_orignode(msg, tipc_own_addr);
+			res = tipc_link_send_sections_fast(p_ptr, msg_sect,
+							   num_sect, destnode);
+		}
+		if (likely(res != -ELINKCONG)) {
+			if (res > 0)
+				p_ptr->sent++;
 			return res;
-		if (port_unreliable(p_ptr)) {
-			/* Just calculate msg length and return */
-			return tipc_msg_calc_data_size(msg_sect, num_sect);
 		}
+		if (port_unreliable(p_ptr))
+			return tipc_msg_calc_data_size(msg_sect, num_sect);
 		return -ELINKCONG;
 	}
 	return tipc_port_reject_sections(p_ptr, msg, msg_sect, num_sect,
@@ -1590,14 +1590,18 @@ int tipc_forward_buf2name(u32 ref,
 	skb_copy_to_linear_data(buf, msg, LONG_H_SIZE);
 
 	if (likely(destport || destnode)) {
-		p_ptr->sent++;
 		if (addr_in_node(destnode))
-			return tipc_port_recv_msg(buf);
-		if (!orig->node)
-			msg_set_orignode(msg, tipc_own_addr);
-		res = tipc_send_buf_fast(buf, destnode);
-		if (likely(res != -ELINKCONG))
+			res = tipc_port_recv_msg(buf);
+		else {
+			if (!orig->node)
+				msg_set_orignode(msg, tipc_own_addr);
+			res = tipc_send_buf_fast(buf, destnode);
+		}
+		if (likely(res != -ELINKCONG)) {
+			if (res > 0)
+				p_ptr->sent++;
 			return res;
+		}
 		if (port_unreliable(p_ptr))
 			return dsz;
 		return -ELINKCONG;
@@ -1651,17 +1655,20 @@ int tipc_forward2port(u32 ref,
 	msg_set_destnode(msg, dest->node);
 	msg_set_destport(msg, dest->ref);
 
-	p_ptr->sent++;
 	if (addr_in_node(dest->node))
-		return tipc_port_recv_sections(p_ptr, num_sect, msg_sect);
-	if (!orig->node)
-		msg_set_orignode(msg, tipc_own_addr);
-	res = tipc_link_send_sections_fast(p_ptr, msg_sect, num_sect,
-					   dest->node);
-	if (likely(res != -ELINKCONG))
+		res = tipc_port_recv_sections(p_ptr, num_sect, msg_sect);
+	else {
+		if (!orig->node)
+			msg_set_orignode(msg, tipc_own_addr);
+		res = tipc_link_send_sections_fast(p_ptr, msg_sect, num_sect,
+						   dest->node);
+	}
+	if (likely(res != -ELINKCONG)) {
+		if (res > 0)
+			p_ptr->sent++;
 		return res;
+	}
 	if (port_unreliable(p_ptr)) {
-		/* Just calculate msg length and return */
 		return tipc_msg_calc_data_size(msg_sect, num_sect);
 	}
 	return -ELINKCONG;
@@ -1718,14 +1725,18 @@ int tipc_forward_buf2port(u32 ref,
 	skb_push(buf, DIR_MSG_H_SIZE);
 	skb_copy_to_linear_data(buf, msg, DIR_MSG_H_SIZE);
 
-	p_ptr->sent++;
 	if (addr_in_node(dest->node))
-		return tipc_port_recv_msg(buf);
-	if (!orig->node)
-		msg_set_orignode(msg, tipc_own_addr);
-	res = tipc_send_buf_fast(buf, dest->node);
-	if (likely(res != -ELINKCONG))
+		res = tipc_port_recv_msg(buf);
+	else {
+		if (!orig->node)
+			msg_set_orignode(msg, tipc_own_addr);
+		res = tipc_send_buf_fast(buf, dest->node);
+	}
+	if (likely(res != -ELINKCONG)) {
+		if (res > 0)
+			p_ptr->sent++;
 		return res;
+	}
 	if (port_unreliable(p_ptr))
 		return dsz;
 	return -ELINKCONG;
diff --git a/net/tipc/tipc_port.h b/net/tipc/tipc_port.h
index 841eca4..06b4aa0 100644
--- a/net/tipc/tipc_port.h
+++ b/net/tipc/tipc_port.h
@@ -75,8 +75,8 @@ struct user_port {
  * @user_port: ptr to user port associated with port (if any)
  * @wait_list: adjacent ports in list of ports waiting on link congestion
  * @waiting_pkts:
- * @sent:
- * @acked:
+ * @sent: # of non-empty messages sent by port
+ * @acked: # of non-empty message acknowledgements from connected port's peer
  * @publications: list of publications for port
  * @pub_count: total # of publications port has made during its lifetime
  * @probing_state:
-- 
1.7.0

