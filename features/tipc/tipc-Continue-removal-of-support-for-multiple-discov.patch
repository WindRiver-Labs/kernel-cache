From b2f8290dd5fba057de444bbf8f90b5119c3289aa Mon Sep 17 00:00:00 2001
From: Allan Stephens <allan.stephens@windriver.com>
Date: Wed, 10 Nov 2010 08:52:23 -0500
Subject: [PATCH 15/32] tipc: Continue removal of support for multiple discovery objects

commit 48e4604006a55253e0f7e7084cb009ef75d17b2c from
git://tipc.cslab.ericsson.net/pub/git/people/allan/tipc.git

Simplifies TIPC's bearer code so that it only has to deal with a
single discovery object, rather than a list of them.

Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
Integrated-by: Howard Xu <hao.xu@windriver.com>
---
 net/tipc/tipc_bearer.c   |   73 ++++++----------------------------------------
 net/tipc/tipc_bearer.h   |    6 +--
 net/tipc/tipc_discover.c |   14 +-------
 net/tipc/tipc_discover.h |    2 -
 net/tipc/tipc_link.c     |    2 -
 5 files changed, 13 insertions(+), 84 deletions(-)

diff --git a/net/tipc/tipc_bearer.c b/net/tipc/tipc_bearer.c
index 561d07f..6e50620 100644
--- a/net/tipc/tipc_bearer.c
+++ b/net/tipc/tipc_bearer.c
@@ -339,80 +339,30 @@ struct sk_buff *tipc_bearer_get_names(void)
 void tipc_bearer_add_dest(struct bearer *b_ptr, u32 dest)
 {
 	struct discoverer *d_ptr;
-	struct discoverer *temp_d_ptr;
 
 	if (in_own_cluster(dest)) {
 		tipc_nmap_add(&b_ptr->nodes, dest);
 		tipc_bcbearer_sort();
 	}
 
-	list_for_each_entry_safe(d_ptr, temp_d_ptr, &b_ptr->disc_list, disc_list) {
-		if (tipc_in_scope(d_ptr->domain, dest)) {
-			d_ptr->num_nodes++;
-			/* tipc_disc_update(d_ptr); */
-		}
-	}
+	d_ptr = b_ptr->disc_obj;
+	if (tipc_in_scope(d_ptr->domain, dest))
+		d_ptr->num_nodes++;
 }
 
 void tipc_bearer_remove_dest(struct bearer *b_ptr, u32 dest)
 {
 	struct discoverer *d_ptr;
-	struct discoverer *temp_d_ptr;
 
 	if (in_own_cluster(dest)) {
 		tipc_nmap_remove(&b_ptr->nodes, dest);
 		tipc_bcbearer_sort();
 	}
 
-	list_for_each_entry_safe(d_ptr, temp_d_ptr, &b_ptr->disc_list, disc_list) {
-		if (tipc_in_scope(d_ptr->domain, dest)) {
-			d_ptr->num_nodes--;
-			tipc_disc_update(d_ptr);
-		}
-	}
-}
-
-
-/*  
- * tipc_bearer_send_discover: 'Individual' discoverer's, i.e. those having a
- * fully specified address, are controlled by the corresponding link's timer,
- * instead of the discovery timer.
- */
-
-void tipc_bearer_send_discover(struct bearer *b_ptr, u32 dest)
-{
-	/* TODO: This needs to be reworked */
-
-	struct discoverer *d_ptr;
-	struct discoverer *temp_d_ptr;
-
-	list_for_each_entry_safe(d_ptr, temp_d_ptr, &b_ptr->disc_list, disc_list) {
-		if (d_ptr->domain == dest) {
-			tipc_disc_send_msg(d_ptr);
-			break;
-		}
-	}
-}
-
-/**
- * tipc_bearer_remove_discoverer(): 
- * Remove the discovery item for 'dest' from bearer's list.
- * Note: bearer item is locked. tipc_net_lock is write_locked.
- */
-
-void tipc_bearer_remove_discoverer(struct bearer *b_ptr, u32 dest)
-{
-	struct discoverer *d_ptr;
-	struct discoverer *temp_d_ptr;
-
-	if (in_own_cluster(dest))
-		return;
-
-	list_for_each_entry_safe(d_ptr, temp_d_ptr, &b_ptr->disc_list, disc_list) {
-		if (tipc_in_scope(dest, d_ptr->domain)) {
-			tipc_disc_deactivate(d_ptr);
-			tipc_disc_delete(d_ptr);
-		}
+	d_ptr = b_ptr->disc_obj;
+	if (tipc_in_scope(d_ptr->domain, dest)) {
+		d_ptr->num_nodes--;
+		tipc_disc_update(d_ptr);
 	}
 }
 
@@ -633,7 +583,6 @@ restart:
 
 	INIT_LIST_HEAD(&b_ptr->cong_links);
 	INIT_LIST_HEAD(&b_ptr->links);
-	INIT_LIST_HEAD(&b_ptr->disc_list);
 	if (disc_domain != tipc_own_addr) {
 		tipc_disc_create(b_ptr, &m_ptr->bcast_addr, disc_domain);
 	}
@@ -695,8 +644,6 @@ static int bearer_disable(struct bearer *b_ptr)
 {
 	struct link *l_ptr;
 	struct link *temp_l_ptr;
-	struct discoverer *d_ptr;
-	struct discoverer *temp_d_ptr;
 
 	info("Disabling bearer <%s>\n", b_ptr->publ.name);
 	spin_lock_bh(&b_ptr->publ.lock);
@@ -709,10 +656,8 @@ static int bearer_disable(struct bearer *b_ptr)
 
 	/* Safe to delete discovery struct here. Bearer is inactive now */
 
-	list_for_each_entry_safe(d_ptr, temp_d_ptr, &b_ptr->disc_list, disc_list) {
-		tipc_disc_deactivate(d_ptr);
-		tipc_disc_delete(d_ptr);
-	}
+	tipc_disc_deactivate(b_ptr->disc_obj);
+	tipc_disc_delete(b_ptr->disc_obj);
 
 	spin_lock_term(&b_ptr->publ.lock); 
 	memset(b_ptr, 0, sizeof(struct bearer));
diff --git a/net/tipc/tipc_bearer.h b/net/tipc/tipc_bearer.h
index 3d77a09..0fa11a9 100644
--- a/net/tipc/tipc_bearer.h
+++ b/net/tipc/tipc_bearer.h
@@ -49,7 +49,7 @@
  * @window: default window size for bearer
  * @tolerance: default link tolerance for bearer
  * @identity: array index of this bearer within TIPC bearer array
- * @disc_list: list of neighbor discovery objects
+ * @disc_obj: pointer to neighbor discovery object associated with bearer
  * @links: list of non-congested links associated with bearer
  * @cong_links: list of congested links associated with bearer
  * @continue_count: # of times bearer has resumed after congestion or blocking
@@ -66,7 +66,7 @@ struct bearer {
 	u32 window;
 	u32 tolerance;
 	u32 identity;
-	struct list_head disc_list;
+	struct discoverer *disc_obj;
 	struct list_head links;
 	struct list_head cong_links;
 	u32 continue_count;
@@ -93,7 +93,6 @@ struct sk_buff *tipc_media_get_names(void);
 struct sk_buff *tipc_bearer_get_names(void);
 void tipc_bearer_add_dest(struct bearer *b_ptr, u32 dest);
 void tipc_bearer_remove_dest(struct bearer *b_ptr, u32 dest);
-void tipc_bearer_remove_discoverer(struct bearer *b_ptr, u32 dest);
 void tipc_bearer_schedule(struct bearer *b_ptr, struct link *l_ptr);
 struct bearer *tipc_bearer_find(const char *name);
 struct tipc_media *tipc_media_find_name(const char *name);
@@ -102,7 +101,6 @@ int tipc_bearer_congested(struct bearer *b_ptr, struct link *l_ptr);
 int tipc_bearer_init(void);
 void tipc_bearer_stop(void);
 void tipc_bearer_lock_push(struct bearer *b_ptr);
-void tipc_bearer_send_discover(struct bearer *b_ptr, u32 dest);
 
 /**
  * tipc_bearer_send- sends buffer to destination over bearer
diff --git a/net/tipc/tipc_discover.c b/net/tipc/tipc_discover.c
index ccb64e9..c78dc9c 100644
--- a/net/tipc/tipc_discover.c
+++ b/net/tipc/tipc_discover.c
@@ -123,10 +123,8 @@ void tipc_disc_recv_msg(struct sk_buff *buf, struct bearer *b_ptr)
 	u32 signature = msg_node_sig(msg);
 	u32 node_flags = msg_node_flags(msg);
 	struct tipc_node *n_ptr;
-        struct discoverer *d_ptr;
 	int addr_mismatch;
         int link_fully_up;
-	int found_disc;
 
 	b_ptr->media->msg2addr(&media_addr, &msg->hdr[5]);
 	msg_dbg(msg, "RECV:");
@@ -158,14 +156,7 @@ void tipc_disc_recv_msg(struct sk_buff *buf, struct bearer *b_ptr)
 
 	if (!tipc_in_scope(dest, tipc_own_addr))
 		return;
-	found_disc = 0;
-	list_for_each_entry(d_ptr, &b_ptr->disc_list, disc_list) {
-		if (tipc_in_scope(d_ptr->domain, orig)) {
-			found_disc = 1;
-			break;
-		}
-	}
-	if (!found_disc)
+	if (!tipc_in_scope(b_ptr->disc_obj->domain, orig))
 		return;
 
         /* We can accept discovery messages from requesting node */
@@ -405,8 +396,8 @@ int tipc_disc_create(struct bearer *b_ptr, struct tipc_media_addr *dest,
 		return 0;
 	}
 
+	b_ptr->disc_obj = d_ptr;
 	d_ptr->bearer = b_ptr;
-        list_add(&d_ptr->disc_list, &b_ptr->disc_list);
 	memcpy(&d_ptr->dest, dest, sizeof(*dest));
         d_ptr->domain = domain;
 	d_ptr->num_nodes = 0;
@@ -430,7 +421,6 @@ void tipc_disc_delete(struct discoverer *d_ptr)
 
 	k_term_timer(&d_ptr->timer);
 	buf_discard(d_ptr->buf);
-        list_del_init(&d_ptr->disc_list);
 	kfree(d_ptr);
 }
 
diff --git a/net/tipc/tipc_discover.h b/net/tipc/tipc_discover.h
index 38b74db..a4916b1 100644
--- a/net/tipc/tipc_discover.h
+++ b/net/tipc/tipc_discover.h
@@ -42,7 +42,6 @@
 /**
  * struct discoverer - information about an ongoing link setup request
  * @bearer: bearer used for discovery messages
- * @disc_list: adjacent discoverers belonging to the same bearer
  * @dest: destination address for discovery messages
  * @domain: network domain of node(s) which should respond to discovery message
  * @num_nodes: number of nodes currently discovered
@@ -53,7 +52,6 @@
  
 struct discoverer {
 	struct bearer *bearer;
-	struct list_head disc_list;
 	struct tipc_media_addr dest;
         u32 domain;
 	int num_nodes;
diff --git a/net/tipc/tipc_link.c b/net/tipc/tipc_link.c
index 44c1868..a98aa9e 100644
--- a/net/tipc/tipc_link.c
+++ b/net/tipc/tipc_link.c
@@ -499,7 +499,6 @@ static void link_remote_delete(struct link *l_ptr)
 
 	write_lock_bh(&tipc_net_lock);
         spin_lock_bh(&b_ptr->publ.lock);
-        tipc_bearer_remove_discoverer(b_ptr,l_ptr->addr);
         tipc_link_delete(l_ptr);
         spin_unlock_bh(&b_ptr->publ.lock);
 	write_unlock_bh(&tipc_net_lock);
@@ -875,7 +874,6 @@ static void link_state_event(struct link *l_ptr, unsigned event)
 			/* fall through */
 		case TIMEOUT_EVT:
 			dbg_link("TIM \n");
-                        tipc_bearer_send_discover(l_ptr->b_ptr,l_ptr->addr);
 			tipc_link_send_proto_msg(l_ptr, RESET_MSG, 0, 0, 0, 0, 0, 0);
 			l_ptr->fsm_msg_cnt++;
 			link_set_timer(l_ptr, cont_intv);
-- 
1.7.0

