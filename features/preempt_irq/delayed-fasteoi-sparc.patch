From ebaad7f6c2261eeac90125ee2d91630c69d6cdcd Mon Sep 17 00:00:00 2001
From: Hong H. Pham <hong.pham@windriver.com>
Date: Sat, 3 Jan 2009 11:43:37 -0500
Subject: [PATCH] preempt irq fix threaded fasteoi

In the threaded case, the EOI was being issued before the fasteoi
interrupt could be serviced.  This could cause lost interrupts or
subsequent interrupts not being retriggered on sparc (i.e. the
interrupt controller gets confused).

If the fasteoi interrupt has been redirected, the EOI is issued in
the threaded handler after the interrupt has been serviced.

This requires one of the existing interrupt disabled checks to be
removed in the process.

Signed-off-by: Hong H. Pham <hong.pham@windriver.com>
---
 kernel/Kconfig.preempt |    3 +++
 kernel/irq/chip.c      |   10 ++++++++++
 kernel/irq/handle.c    |    6 +++++-
 kernel/irq/manage.c    |    3 +++
 4 files changed, 21 insertions(+), 1 deletions(-)

diff --git a/kernel/Kconfig.preempt b/kernel/Kconfig.preempt
index ba94f55..1b6c638 100644
--- a/kernel/Kconfig.preempt
+++ b/kernel/Kconfig.preempt
@@ -113,3 +113,6 @@ config PREEMPT_HARDIRQS
 
 	  Say N if you are unsure.
 
+config PREEMPT_HARDIRQS_DELAY_FASTEOI
+	def_bool y
+	depends on PREEMPT_HARDIRQS && SPARC64
diff --git a/kernel/irq/chip.c b/kernel/irq/chip.c
index fd01509..d4f7818 100644
--- a/kernel/irq/chip.c
+++ b/kernel/irq/chip.c
@@ -439,7 +439,16 @@ handle_fasteoi_irq(unsigned int irq, struct irq_desc *desc)
 	if (redirect_hardirq(desc)) {
 		if (desc->chip->mask)
 			desc->chip->mask(irq);
+#ifdef CONFIG_PREEMPT_HARDIRQS_DELAY_FASTEOI
+		/*
+		 * Some interrupt controllers require that the eoi gets issued
+		 * after the interrupt has been serviced.  The threaded
+		 * fasteoi handler will issue the eoi.
+		 */
+		goto out_no_ack;
+#else
 		goto out;
+#endif
 	}
 
 	desc->status &= ~IRQ_PENDING;
@@ -455,6 +464,7 @@ handle_fasteoi_irq(unsigned int irq, struct irq_desc *desc)
 		desc->chip->unmask(irq);
 out:
 	desc->chip->eoi(irq);
+out_no_ack:
 	spin_unlock(&desc->lock);
 }
 
diff --git a/kernel/irq/handle.c b/kernel/irq/handle.c
index c90bef4..cf11635 100644
--- a/kernel/irq/handle.c
+++ b/kernel/irq/handle.c
@@ -203,7 +203,11 @@ int redirect_hardirq(struct irq_desc *desc)
 		return 0;
 #endif
 
-	BUG_ON(!irqs_disabled());
+#ifdef CONFIG_PREEMPT_HARDIRQS_DELAY_FASTEOI
+	if (!hardirq_preemption)
+#endif
+		BUG_ON(!irqs_disabled());
+
 	if (desc->thread && desc->thread->state != TASK_RUNNING)
 		wake_up_process(desc->thread);
 
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index cff6ce4..dcfc90f 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -755,6 +755,9 @@ static void thread_fasteoi_irq(irq_desc_t *desc)
 	unsigned int irq = desc - irq_desc;
 
 	thread_simple_irq(desc);
+#ifdef CONFIG_PREEMPT_HARDIRQS_DELAY_FASTEOI
+	desc->chip->eoi(irq);
+#endif
 	if (!(desc->status & IRQ_DISABLED) && desc->chip->unmask)
 		desc->chip->unmask(irq);
 }
-- 
1.6.0.4

