From 3924941504a09b1350eaf21bad3a7f9738813685 Mon Sep 17 00:00:00 2001
From: Xiaotian Feng <Xiaotian.Feng@windriver.com>
Date: Tue, 9 Jun 2009 16:58:12 +0800
Subject: [PATCH] pmem: make CONFIG_LHB works for x86/powerpc target

1. fix compile error on ppc when enable CONFIG_LHB
2. fix compile error on x86 when enable CONFIG_LHB
3. fix kernel panic when booting target
4. fix hang powerpc target with flood printk when echo
   values to /proc/lhb/mask
5. fix general protect fault when echo values to
   /proc/lhb/mask

Signed-off-by: Xiaotian Feng <xiaotian.feng@windriver.com>
---
 arch/powerpc/kernel/traps.c |    3 +-
 arch/x86/kernel/entry_32.S  |    4 +-
 arch/x86/kernel/irq_32.c    |    2 +-
 arch/x86/kernel/traps_32.c  |   32 ++++++++++----------
 arch/x86/mm/fault.c         |    3 +-
 drivers/pmem/pmem_init.c    |   22 ++++++++++----
 include/linux/pmem.h        |   68 +++++++++++++++++++++++++++++++++++++++++++
 7 files changed, 106 insertions(+), 28 deletions(-)

diff --git a/arch/powerpc/kernel/traps.c b/arch/powerpc/kernel/traps.c
index 5b4ba5a..113e9f9 100644
--- a/arch/powerpc/kernel/traps.c
+++ b/arch/powerpc/kernel/traps.c
@@ -68,6 +68,7 @@ extern void kcore_logoff(void);
 #ifdef CONFIG_LHB
 #include <linux/pmem.h>
 
+#include <asm/syscall.h>
 
 struct pmem_ptr_block lhb_ptrs = { };
 #endif
@@ -113,7 +114,7 @@ static void lhb_trap(struct pt_regs *regs)
 	lhb_block->hbnip = instruction_pointer(regs);
 	lhb_block->hblink = regs->link;
 	lhb_block->hbtrap = regs->trap;
-	lhb_block->hbsc = current->thread.last_syscall;
+	lhb_block->hbsc = syscall_get_nr(current,regs);
 #ifdef SUPPORT_HRTIME
 	lhb_block->hbtl = (unsigned int)gethrtime();
 #else
diff --git a/arch/x86/kernel/entry_32.S b/arch/x86/kernel/entry_32.S
index a8b0e47..7d2432a 100644
--- a/arch/x86/kernel/entry_32.S
+++ b/arch/x86/kernel/entry_32.S
@@ -414,7 +414,7 @@ sysenter_do_call:
 	pushl %eax                      # pass the stack pointer copy
 	addl $4,%esp                    # return stack to state before pass
 	call lhb_log_syscall
-	movl ORIG_EAX(%esp),%eax        # restore eax to it's original content
+	movl PT_ORIG_EAX(%esp),%eax        # restore eax to it's original content
 #endif
 	call *sys_call_table(,%eax,4)
 	.globl ia32_sysenter_done
@@ -519,7 +519,7 @@ syscall_call:
  	pushl %eax                      # pass the stack pointer copy
  	addl $4,%esp                    # return stack to state before pass
  	call lhb_log_syscall
- 	movl ORIG_EAX(%esp),%eax        # restore eax to it's original content
+ 	movl PT_ORIG_EAX(%esp),%eax        # restore eax to it's original content
 #endif
 	call *sys_call_table(,%eax,4)
 	.globl system_call_done
diff --git a/arch/x86/kernel/irq_32.c b/arch/x86/kernel/irq_32.c
index 3027822..71ffee4 100644
--- a/arch/x86/kernel/irq_32.c
+++ b/arch/x86/kernel/irq_32.c
@@ -17,7 +17,7 @@
 #include <linux/delay.h>
 
 #ifdef CONFIG_LHB
-extern void FASTCALL(lhb_log_irq(struct pt_regs *regs));
+extern void lhb_log_irq(struct pt_regs *regs);
 #else
 #define lhb_log_irq(regs) do { } while(0)
 #endif
diff --git a/arch/x86/kernel/traps_32.c b/arch/x86/kernel/traps_32.c
index 5ebde42..8e49665 100644
--- a/arch/x86/kernel/traps_32.c
+++ b/arch/x86/kernel/traps_32.c
@@ -554,16 +554,16 @@ static inline void lhb_log_entry(struct pt_regs *regs, int trapno, int signo, in
 
 	/* only store regsiter info if given */
 	if (likely(regs)) {
-		lhb_block->eax = regs->eax;
-		lhb_block->ebx = regs->ebx;
-		lhb_block->ecx = regs->ecx;
-		lhb_block->edx = regs->edx;
-		lhb_block->esi = regs->esi;
-		lhb_block->edi = regs->edi;
-		lhb_block->ebp = regs->ebp;
-		lhb_block->eip = regs->eip;
-		if (regs->xcs & 3)
-			lhb_block->esp = regs->esp;
+		lhb_block->eax = regs->ax;
+		lhb_block->ebx = regs->bx;
+		lhb_block->ecx = regs->cx;
+		lhb_block->edx = regs->dx;
+		lhb_block->esi = regs->si;
+		lhb_block->edi = regs->di;
+		lhb_block->ebp = regs->bp;
+		lhb_block->eip = regs->ip;
+		if (regs->cs & 3)
+			lhb_block->esp = regs->sp;
 		else
 			lhb_block->esp = 0;
 	} else {
@@ -590,29 +590,29 @@ static inline void lhb_log_entry(struct pt_regs *regs, int trapno, int signo, in
 }
 
 /* i386 syscall trap - log to LHB buffer */
-void fastcall lhb_log_syscall(struct pt_regs *regs)
+void lhb_log_syscall(struct pt_regs *regs)
 {
 	unsigned int syscall_id;
 
-	syscall_id = (unsigned int)regs->orig_eax;
+	syscall_id = (unsigned int)regs->orig_ax;
 	/* should the trapno or signo be the LHB_SYSCALL define here ? */
 	lhb_log_entry(regs, LHB_SYSCALL, 0, 0, syscall_id, 0);
 }
 
 /* i386 exception trap - log to buffer */
-void fastcall lhb_trap(struct pt_regs *regs, int trapno, int signo, int errcode)
+void lhb_trap(struct pt_regs *regs, int trapno, int signo, int errcode)
 {
 	lhb_log_entry(regs, trapno, signo, errcode, 0, 0);
 }
 
-void fastcall lhb_log_irq(struct pt_regs *regs)
+void lhb_log_irq(struct pt_regs *regs)
 {
-	int irq = regs->orig_eax & 0xff;
+	int irq = regs->orig_ax & 0xff;
 
 	lhb_log_entry(regs, LHB_IRQ, 0, 0, 0, irq);
 }
 
-void fastcall lhb_log_pagefault(struct pt_regs *regs)
+void lhb_log_pagefault(struct pt_regs *regs)
 {
 	lhb_log_entry(regs, LHB_PAGEFAULT, 0, 0, 0, 0);
 }
diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
index 01496a6..24f8d19 100644
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@ -41,7 +41,7 @@
 #include <asm/tlbflush.h>
 
 #ifdef CONFIG_LHB
-extern void FASTCALL(lhb_log_pagefault(struct pt_regs *regs));
+extern void lhb_log_pagefault(struct pt_regs *regs);
 #else
 #define lhb_log_pagefault(regs) do { } while(0)
 #endif
@@ -564,7 +564,6 @@ static int vmalloc_fault(unsigned long address)
 	pte_k = pte_offset_kernel(pmd_k, address);
 	if (!pte_present(*pte_k))
 		return -1;
-	lhb_log_pagefault(regs);
 	return 0;
 #else
 	unsigned long pgd_paddr;
diff --git a/drivers/pmem/pmem_init.c b/drivers/pmem/pmem_init.c
index efb74df..52b0226 100644
--- a/drivers/pmem/pmem_init.c
+++ b/drivers/pmem/pmem_init.c
@@ -51,6 +51,7 @@ int lhb_mask = 7;
 
 #include <linux/proc_fs.h>
 
+#include <linux/uaccess.h>
 static struct proc_dir_entry *lhb_mask_dir, *lhb_mask_file;
 void lhb_mask_init(void);
 #else
@@ -1043,7 +1044,7 @@ static int pmem_reg_users(void)
 			printk(KERN_ERR "ERROR: Linux History Buffer is DISABLED.\n");
 			printk(KERN_ERR "ERROR: *************************************\n");
 		}
-		pmem_release_handle(region_hdl);
+		pmem_release_handle(&region_hdl);
 	}
 #endif
 
@@ -1220,14 +1221,23 @@ static int lhb_mask_write(struct file *file, const char *buffer,
                           unsigned long count, void *data)
 {
 	int val;
+	char debug_string[12] = { '\0' };
+
+	if (count > sizeof(debug_string) - 1)
+		return -EINVAL;
+
+	if (copy_from_user(debug_string, buffer, count))
+		return -EFAULT;
 
-	val = (int)simple_strtoul(buffer, NULL, 0);
-	printk(KERN_ERR "INFO: Seetting LHB Mask to %d\n", val);
-	if ((val >= 0) && (val < 8)) {
+	debug_string[count] = '\0';
+
+	val = (int)simple_strtoul(debug_string, NULL, 0);
+	if ((val < 0) || (val >= 8)) 
+		return -EINVAL;
+	else 
 		lhb_mask = val;
-	}
 
-	return 0;
+	return count;
 }
 
 static int lhb_mask_read(char *page, char **start, off_t off, int count,
diff --git a/include/linux/pmem.h b/include/linux/pmem.h
index d49b245..8ea00fd 100644
--- a/include/linux/pmem.h
+++ b/include/linux/pmem.h
@@ -350,6 +350,74 @@ struct pmem_region_hdr {
 #define PMEM_DPRINT(...)
 #endif
 
+#ifdef CONFIG_LHB
+extern volatile int disable_history_buffer;
+#if defined(CONFIG_PPC)
+/* exception history buffer */
+typedef struct hist_buf_struct
+{
+        unsigned int    hbnip;  /* NIP */
+        unsigned int    hblink; /* LINK */
+        unsigned short  hbtrap; /* TRAP */
+        unsigned short  hbsc;   /* last system call */
+        unsigned int    hbtl;   /* Low order Timebase */
+} hist_buf_struct;
+#elif defined(CONFIG_X86)
+/* 'TrapNo' numbers used for LHB events that dont run through do_trap
+ * Start these at 32 since it appears that all standard signal numbers
+ * are < 31 */
+#define LHB_SYSCALL             32
+#define LHB_VSYSCALL            LHB_SYSCALL
+#define LHB_PAGEFAULT           33
+#define LHB_DEBUG_EXCEPT        34
+#define LHB_NMI_EXCEPT          35
+#define LHB_COPROC_ERROR        36
+#define LHB_DOUBLEFAULT         37
+
+#define LHB_IRQ                 40
+#define LHB_RESTART             99
+/* exception history buffer structure
+ * Designed to hold less, detailed exception info
+ * vs more sparse details. */
+typedef struct hist_buf_struct
+{
+        int trapno;             /* trap type */
+        int signo;              /* signal */
+        int errcode;            /* error code passed to do_trap() */
+        /* potential x86 registers of interest */
+        long eax;
+        long ebx;
+        long ecx;
+        long edx;
+        long esi;
+        long edi;
+        long ebp;
+        long esp;
+        long eip;
+        unsigned int sc;        /* system call id */
+        int irq;                /* irq number */
+
+        __u64 timestamp;        /* High-res timestamp */
+} hist_buf_struct;
+#endif
+
+/* Persistent memory definitions */
+#define PMEM_REG_EXCEPT_DESC "except_hist"
+#define PMEM_REG_EXCEPT_FIXED_SIZE sizeof(struct hist_buf_struct)
+#define PMEM_REG_EXCEPT_LOG_DESC 0
+#define PMEM_REG_EXCEPT_FLAGS PMEM_REGION_FLAG_PERPROC
+#define PMEM_REG_EXCEPT_VERSION 1
+#endif /* CONFIG_LHB */
+
+#ifdef CONFIG_LHB_TESTMODE
+extern int lhb_mask;
+/* define the mask bits for event logging selection.  This allows the
+ * common events to be masked out for testing purposes */
+#define LHB_MASK_PAGEFAULT      4
+#define LHB_MASK_IRQ            2
+#define LHB_MASK_SYSCALL        1
+#endif /* CONFIG_LHB_TESTMODE */
+
 #ifndef CONFIG_SMP
 #define PMEM_NUM_SUPPORT_CPUS 1
 #else
-- 
1.6.3.3

