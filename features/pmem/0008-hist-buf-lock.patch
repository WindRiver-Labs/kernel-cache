From 9d19eddf0f7d691aa6ffde317b00f5d4490d168b Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Thu, 4 Sep 2008 12:55:06 +0800
Subject: [PATCH] hist buf lock

Provide disabler function of  history buffer.

Signed-off-by: Yongli he   <yongli.he@windriver.com>
Signed-off-by: MacDonald, Joe <Joe.MacDonald@windriver.com>
---
 arch/powerpc/kernel/traps.c |    3 +++
 arch/x86/kernel/traps_32.c  |    3 +++
 include/linux/sysctl.h      |    2 ++
 kernel/sched.c              |    7 +++++++
 kernel/sysctl.c             |   14 ++++++++++++++
 5 files changed, 29 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/kernel/traps.c b/arch/powerpc/kernel/traps.c
index 3ddc692..77d4741 100644
--- a/arch/powerpc/kernel/traps.c
+++ b/arch/powerpc/kernel/traps.c
@@ -99,6 +99,9 @@ static void lhb_trap(struct pt_regs *regs)
 	if (!ptrs)
 		return;
 
+	if (disable_history_buffer)
+		return;
+
 	/* Wrap if we've reached the end of the buffer */
 	if (ptrs->curr + sizeof(struct hist_buf_struct) >= ptrs->end)
 		ptrs->curr = ptrs->start;
diff --git a/arch/x86/kernel/traps_32.c b/arch/x86/kernel/traps_32.c
index f376ad2..81f1fcb 100644
--- a/arch/x86/kernel/traps_32.c
+++ b/arch/x86/kernel/traps_32.c
@@ -520,6 +520,9 @@ static inline void lhb_log_entry(struct pt_regs *regs, int trapno, int signo, in
 	if (!ptrs)
 		return;
 
+	if (disable_history_buffer)
+		return;
+
 	/* Wrap if we've reached the end of the buffer */
 	if (ptrs->curr + sizeof(struct hist_buf_struct) >= ptrs->end)
 		ptrs->curr = ptrs->start;
diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h
index f33ac7e..af621f4 100644
--- a/include/linux/sysctl.h
+++ b/include/linux/sysctl.h
@@ -164,6 +164,8 @@ enum
 	KERN_MAX_LOCK_DEPTH=74,
 	KERN_NMI_WATCHDOG=75, /* int: enable/disable nmi watchdog */
 	KERN_PANIC_ON_NMI=76, /* int: whether we will panic on an unrecovered */
+	KERN_DISABLE_HISTORY_BUFFER=77, /* int: disable the logging to exception and scheduler history buffers */
+
 #ifdef CONFIG_GRKERNSEC
 	KERN_GRSECURITY=98,	/* grsecurity */
 #endif
diff --git a/kernel/sched.c b/kernel/sched.c
index fb5c717..1fac2f2 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -118,6 +118,10 @@
  */
 #define RUNTIME_INF	((u64)~0ULL)
 
+#if defined(CONFIG_LHB) || defined(CONFIG_SCHED_HIST_BUF)
+volatile int disable_history_buffer = 0;
+#endif
+
 #ifdef CONFIG_SCHED_HIST_BUF
 #include <linux/pmem.h>
 #include <linux/schedhist.h>
@@ -151,6 +155,9 @@ static inline void sched_hist_addentry(struct task_struct *prev,
 	if ((!ptrs) || (!prev))
 		return;
 
+	if (disable_history_buffer)
+		return;
+
 	/* Check for wrap around. We can assume that the end pointer
 	 * is a multiple of the entry size since the API ensures this. */
 	ptrs->curr += sizeof(struct sched_hist_entry_common);
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index db24dd7..94ea76f 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -156,6 +156,10 @@ extern int no_unaligned_warning;
 extern int max_lock_depth;
 #endif
 
+#if defined(CONFIG_LHB) || defined(CONFIG_SCHED_HIST_BUF)
+extern volatile int disable_history_buffer ;
+#endif
+
 #ifdef CONFIG_PROC_SYSCTL
 static int proc_do_cad_pid(struct ctl_table *table, int write, struct file *filp,
 		  void __user *buffer, size_t *lenp, loff_t *ppos);
@@ -243,6 +247,16 @@ static struct ctl_table root_table[] = {
 		.mode		= 0555,
 		.child		= dev_table,
 	},
+#if defined(CONFIG_LHB) || defined(CONFIG_SCHED_HIST_BUF)
+	{
+		.ctl_name       = KERN_DISABLE_HISTORY_BUFFER,
+		.procname       = "disable_history_buffer",
+		.data           = &disable_history_buffer,
+		.maxlen         = sizeof(int),
+		.mode           = 0644,
+		.proc_handler   = &proc_dointvec,
+	},
+#endif
 /*
  * NOTE: do not add new entries to this table unless you have read
  * Documentation/sysctl/ctl_unnumbered.txt
-- 
1.5.5.1

