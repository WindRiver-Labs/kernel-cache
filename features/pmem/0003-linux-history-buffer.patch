From c8ac9314579f15329109f0faaf2b127eb2dc86a5 Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Thu, 4 Sep 2008 11:38:09 +0800
Subject: [PATCH] linux history buffer

Signed-off-by: Yongli he   <yongli.he@windriver.com>
Signed-off-by: MacDonald, Joe <Joe.MacDonald@windriver.com>
---
 arch/powerpc/Kconfig        |   19 +++++++
 arch/powerpc/kernel/traps.c |   39 +++++++++++++++
 arch/x86/Kconfig            |   19 +++++++
 arch/x86/kernel/entry_32.S  |   14 +++++
 arch/x86/kernel/irq_32.c    |    8 +++
 arch/x86/kernel/reboot.c    |    7 +++
 arch/x86/kernel/traps_32.c  |  111 +++++++++++++++++++++++++++++++++++++++++++
 arch/x86/mm/fault.c         |    8 +++
 drivers/pmem/pmem_init.c    |   98 ++++++++++++++++++++++++++++++++++++++
 9 files changed, 323 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
index 6f4c635..3a35238 100644
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -349,6 +349,25 @@ config PPCBUG_NVRAM
 	bool "Enable reading PPCBUG NVRAM during boot" if PPLUS || LOPEC
 	default y if PPC_PREP
 
+config LHB
+	bool "Linux Exception History Buffer"
+	depends on PMEM && !KGDB && PREEMPT_NONE
+	default n
+	help
+	  When enabled this keeps a history buffer of exception events.
+
+config LHB_SIZE
+	int "Linux Exception History Buffer size"
+	depends on LHB
+	default 262144
+
+config LHB_TESTMODE
+	bool "Linux Exception History Test Mode"
+	default n
+	help
+	  Allows control over logging certain events in LHB through
+	  /proc/lhb_mask
+
 config IRQ_ALL_CPUS
 	bool "Distribute interrupts on all CPUs by default"
 	depends on SMP && !MV64360
diff --git a/arch/powerpc/kernel/traps.c b/arch/powerpc/kernel/traps.c
index 83445ad..3ddc692 100644
--- a/arch/powerpc/kernel/traps.c
+++ b/arch/powerpc/kernel/traps.c
@@ -63,6 +63,12 @@ extern void kcore_logoff(void);
 #define kcore_logoff() do { } while(0)
 #endif /* CONFIG_PANIC_LOGS */
 
+#ifdef CONFIG_LHB
+#include <linux/pmem.h>
+
+
+struct pmem_ptr_block lhb_ptrs = { };
+#endif
 #if defined(CONFIG_DEBUGGER) || defined(CONFIG_KEXEC)
 int (*__debugger)(struct pt_regs *regs);
 int (*__debugger_ipi)(struct pt_regs *regs);
@@ -84,6 +90,38 @@ EXPORT_SYMBOL(__debugger_fault_handler);
 /*
  * Trap & Exception support
  */
+#ifdef CONFIG_LHB
+static void lhb_trap(struct pt_regs *regs)
+{
+	struct hist_buf_struct *lhb_block;
+	struct pmem_cpu_ptrs *ptrs = lhb_ptrs.cpu[smp_processor_id()].ptrs;
+
+	if (!ptrs)
+		return;
+
+	/* Wrap if we've reached the end of the buffer */
+	if (ptrs->curr + sizeof(struct hist_buf_struct) >= ptrs->end)
+		ptrs->curr = ptrs->start;
+
+	lhb_block = (struct hist_buf_struct*)ptrs->curr;
+
+	lhb_block->hbnip = instruction_pointer(regs);
+	lhb_block->hblink = regs->link;
+	lhb_block->hbtrap = regs->trap;
+	lhb_block->hbsc = current->thread.last_syscall;
+#ifdef CONFIG_HIGH_RES_TIMERS
+	lhb_block->hbtl = (unsigned int)gethrtime();
+#else
+	lhb_block->hbtl = (unsigned int)get_cycles();
+#endif
+
+	ptrs->curr += sizeof(hist_buf_struct);
+	return;
+}
+#else
+#define lhb_trap(regs) do { } while(0)
+#endif
+
 
 #ifdef CONFIG_PMAC_BACKLIGHT
 static void pmac_backlight_unblank(void)
@@ -209,6 +247,7 @@ void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)
 		instruction_pointer(regs));
 
 	memset(&info, 0, sizeof(info));
+  	lhb_trap(regs);
 	info.si_signo = signr;
 	info.si_code = code;
 	info.si_addr = (void __user *) addr;
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 6cdcaa6..e6dcb01 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -216,6 +216,25 @@ menu "Processor type and features"
 
 source "kernel/time/Kconfig"
 
+config LHB
+	bool "Linux Exception History Buffer"
+	depends on PMEM && !KGDB && PREEMPT_NONE
+	default n
+	help
+	  When enabled this keeps a history buffer of exception events.
+
+config LHB_SIZE
+	int "Linux Exception History Buffer size"
+	depends on LHB
+	default 262144
+
+config LHB_TESTMODE
+	bool "Linux Exception History Test Mode"
+	default n
+	help
+	  Allows control over logging certain events in LHB through
+	  /proc/lhb_mask
+
 config SMP
 	bool "Symmetric multi-processing support"
 	---help---
diff --git a/arch/x86/kernel/entry_32.S b/arch/x86/kernel/entry_32.S
index 705138f..4029d82 100644
--- a/arch/x86/kernel/entry_32.S
+++ b/arch/x86/kernel/entry_32.S
@@ -409,6 +409,13 @@ sysenter_past_esp:
 sysenter_do_call:
 	cmpl $(nr_syscalls), %eax
 	jae syscall_badsys
+#ifdef CONFIG_LHB
+	movl %esp, %eax                 # copy the stack pointer
+	pushl %eax                      # pass the stack pointer copy
+	addl $4,%esp                    # return stack to state before pass
+	call lhb_log_syscall
+	movl ORIG_EAX(%esp),%eax        # restore eax to it's original content
+#endif
 	call *sys_call_table(,%eax,4)
 	movl %eax,PT_EAX(%esp)
 	LOCKDEP_SYS_EXIT
@@ -505,6 +512,13 @@ ENTRY(system_call)
 	cmpl $(nr_syscalls), %eax
 	jae syscall_badsys
 syscall_call:
+#ifdef CONFIG_LHB
+ 	movl %esp, %eax                 # copy the stack pointer
+ 	pushl %eax                      # pass the stack pointer copy
+ 	addl $4,%esp                    # return stack to state before pass
+ 	call lhb_log_syscall
+ 	movl ORIG_EAX(%esp),%eax        # restore eax to it's original content
+#endif
 	call *sys_call_table(,%eax,4)
 	movl %eax,PT_EAX(%esp)		# store the return value
 syscall_exit:
diff --git a/arch/x86/kernel/irq_32.c b/arch/x86/kernel/irq_32.c
index ca827df..3027822 100644
--- a/arch/x86/kernel/irq_32.c
+++ b/arch/x86/kernel/irq_32.c
@@ -16,6 +16,12 @@
 #include <linux/cpu.h>
 #include <linux/delay.h>
 
+#ifdef CONFIG_LHB
+extern void FASTCALL(lhb_log_irq(struct pt_regs *regs));
+#else
+#define lhb_log_irq(regs) do { } while(0)
+#endif
+
 #include <asm/apic.h>
 #include <asm/uaccess.h>
 
@@ -232,6 +238,8 @@ unsigned int do_IRQ(struct pt_regs *regs)
 		BUG();
 	}
 
+ 	lhb_log_irq(regs);
+
 	old_regs = set_irq_regs(regs);
 	irq_enter();
 
diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c
index c78f073..031016c 100644
--- a/arch/x86/kernel/reboot.c
+++ b/arch/x86/kernel/reboot.c
@@ -13,6 +13,12 @@
 #include <asm/reboot_fixups.h>
 #include <asm/reboot.h>
 
+#ifdef CONFIG_LHB
+extern void lhb_log_restart(void);
+#else
+#define lhb_log_restart() do { } while(0)
+#endif
+
 #ifdef CONFIG_X86_32
 # include <linux/dmi.h>
 # include <linux/ctype.h>
@@ -434,6 +440,7 @@ void native_machine_shutdown(void)
 	smp_send_stop();
 #endif
 
+	lhb_log_restart();
 	lapic_shutdown();
 
 #ifdef CONFIG_X86_IO_APIC
diff --git a/arch/x86/kernel/traps_32.c b/arch/x86/kernel/traps_32.c
index a4fa28d..f376ad2 100644
--- a/arch/x86/kernel/traps_32.c
+++ b/arch/x86/kernel/traps_32.c
@@ -70,6 +70,11 @@ extern void kcore_logoff(void);
 #define kcore_logoff() do { } while(0)
 #endif /* CONFIG_PANIC_LOGS */
 
+#ifdef CONFIG_LHB
+#include <linux/pmem.h>
+struct pmem_ptr_block lhb_ptrs;
+#endif
+
 #include "mach_traps.h"
 
 DECLARE_BITMAP(used_vectors, NR_VECTORS);
@@ -505,6 +510,103 @@ die_if_kernel(const char *str, struct pt_regs *regs, long err)
 		die(str, regs, err);
 }
 
+#ifdef CONFIG_LHB
+/* Add an entry to the linux history buffer for i386 */
+static inline void lhb_log_entry(struct pt_regs *regs, int trapno, int signo, int errcode, unsigned int syscall_id, int irq)
+{
+	struct hist_buf_struct *lhb_block;
+	struct pmem_cpu_ptrs *ptrs = lhb_ptrs.cpu[smp_processor_id()].ptrs;
+
+	if (!ptrs)
+		return;
+
+	/* Wrap if we've reached the end of the buffer */
+	if (ptrs->curr + sizeof(struct hist_buf_struct) >= ptrs->end)
+		ptrs->curr = ptrs->start;
+	lhb_block = (struct hist_buf_struct*)ptrs->curr;
+
+	lhb_block->trapno = trapno;
+	lhb_block->signo = signo;
+	lhb_block->errcode = errcode;
+
+	/* only store regsiter info if given */
+	if (likely(regs)) {
+		lhb_block->eax = regs->eax;
+		lhb_block->ebx = regs->ebx;
+		lhb_block->ecx = regs->ecx;
+		lhb_block->edx = regs->edx;
+		lhb_block->esi = regs->esi;
+		lhb_block->edi = regs->edi;
+		lhb_block->ebp = regs->ebp;
+		lhb_block->eip = regs->eip;
+		if (regs->xcs & 3)
+			lhb_block->esp = regs->esp;
+		else
+			lhb_block->esp = 0;
+	} else {
+		lhb_block->eax = 0;
+		lhb_block->ebx = 0;
+		lhb_block->ecx = 0;
+		lhb_block->edx = 0;
+		lhb_block->esi = 0;
+		lhb_block->edi = 0;
+		lhb_block->ebp = 0;
+		lhb_block->eip = 0;
+		lhb_block->esp = 0;
+	}
+
+	lhb_block->sc = syscall_id;
+	lhb_block->irq = irq;
+#ifdef CONFIG_HIGH_RES_TIMERS
+	lhb_block->timestamp = gethrtime();
+#else
+	lhb_block->timestamp = get_cycles();
+#endif
+
+	ptrs->curr += sizeof(hist_buf_struct);
+}
+
+/* i386 syscall trap - log to LHB buffer */
+void fastcall lhb_log_syscall(struct pt_regs *regs)
+{
+	unsigned int syscall_id;
+
+	syscall_id = (unsigned int)regs->orig_eax;
+	/* should the trapno or signo be the LHB_SYSCALL define here ? */
+	lhb_log_entry(regs, LHB_SYSCALL, 0, 0, syscall_id, 0);
+}
+
+/* i386 exception trap - log to buffer */
+void fastcall lhb_trap(struct pt_regs *regs, int trapno, int signo, int errcode)
+{
+	lhb_log_entry(regs, trapno, signo, errcode, 0, 0);
+}
+
+void fastcall lhb_log_irq(struct pt_regs *regs)
+{
+	int irq = regs->orig_eax & 0xff;
+
+	lhb_log_entry(regs, LHB_IRQ, 0, 0, 0, irq);
+}
+
+void fastcall lhb_log_pagefault(struct pt_regs *regs)
+{
+	lhb_log_entry(regs, LHB_PAGEFAULT, 0, 0, 0, 0);
+}
+
+void lhb_log_restart(void)
+{
+	lhb_log_entry(0, LHB_RESTART, 0, 0, 0, 0);
+}
+
+#else
+/* Empty definitions for LHB related stubs */
+#define lhb_log_entry(regs, trapno, signo, errcode, sc_id, irq) do { } while(0)
+#define LHB_DEBUG_EXCEPT 0
+#define LHB_NMI_EXCEPT 0
+#define lhb_trap(regs, trapno, signo, errcode) do { } while(0)
+#endif
+
 static void __kprobes
 do_trap(int trapnr, int signr, char *str, int vm86, struct pt_regs *regs,
 	long error_code, siginfo_t *info)
@@ -514,6 +616,8 @@ do_trap(int trapnr, int signr, char *str, int vm86, struct pt_regs *regs,
 	trace_mark(kernel_arch_trap_entry, "trap_id %d ip #p%ld", trapnr,
 		instruction_pointer(regs));
 
+	lhb_trap(regs, trapnr, signr, error_code);
+
 	if (v8086_mode(regs)) {
 		if (vm86)
 			goto vm86_trap;
@@ -694,6 +798,7 @@ do_general_protection(struct pt_regs *regs, long error_code)
 
 	tsk->thread.error_code = error_code;
 	tsk->thread.trap_no = 13;
+ 	lhb_log_entry(regs, 13, 0, error_code, 0, 0);
 
 	if (show_unhandled_signals && unhandled_signal(tsk, SIGSEGV) &&
 			printk_ratelimit()) {
@@ -713,6 +818,7 @@ do_general_protection(struct pt_regs *regs, long error_code)
 
 gp_in_vm86:
 	local_irq_enable();
+ 	lhb_log_entry(regs, 13, 0, error_code, 0, 0);
 	handle_vm86_fault((struct kernel_vm86_regs *) regs, error_code);
 	return;
 
@@ -815,6 +921,7 @@ void notrace __kprobes die_nmi(char *str, struct pt_regs *regs, int do_panic)
 		return;
 
 	spin_lock(&nmi_print_lock);
+	lhb_log_entry(regs, LHB_NMI_EXCEPT, 0, 0, 0, 0);
 	/*
 	* We are in trouble anyway, lets at least try
 	* to get a message out:
@@ -1008,6 +1115,8 @@ void __kprobes do_debug(struct pt_regs *regs, long error_code)
 			goto clear_TF_reenable;
 	}
 
+	lhb_log_entry(regs, LHB_DEBUG_EXCEPT, 0, error_code, 0, 0);
+
 	/* Ok, finally something we can handle */
 	trace_mark(kernel_arch_trap_entry, "trap_id %d ip #p%ld",
 			1, instruction_pointer(regs));
@@ -1023,6 +1132,7 @@ clear_dr7:
 	return;
 
 debug_vm86:
+ 	lhb_log_entry(regs, LHB_DEBUG_EXCEPT, 0, error_code, 0, 0);
 	trace_mark(kernel_arch_trap_entry, "trap_id %d ip #p%ld",
 			1, instruction_pointer(regs));
 	handle_vm86_trap((struct kernel_vm86_regs *) regs, error_code, 1);
@@ -1102,6 +1212,7 @@ void math_error(void __user *ip)
 void do_coprocessor_error(struct pt_regs *regs, long error_code)
 {
 	ignore_fpu_irq = 1;
+	lhb_trap(regs, LHB_COPROC_ERROR, 0, error_code);
 	math_error((void __user *)regs->ip);
 }
 
diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
index 7064c19..c47f102 100644
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@ -39,6 +39,12 @@
 #include <asm-generic/sections.h>
 #include <asm/tlbflush.h>
 
+#ifdef CONFIG_LHB
+extern void FASTCALL(lhb_log_pagefault(struct pt_regs *regs));
+#else
+#define lhb_log_pagefault(regs) do { } while(0)
+#endif
+
 /*
  * Page fault error code bits
  *	bit 0 == 0 means no page found, 1 means protection fault
@@ -557,6 +563,7 @@ static int vmalloc_fault(unsigned long address)
 	pte_k = pte_offset_kernel(pmd_k, address);
 	if (!pte_present(*pte_k))
 		return -1;
+	lhb_log_pagefault(regs);
 	return 0;
 #else
 	unsigned long pgd_paddr;
@@ -704,6 +711,7 @@ void __kprobes do_page_fault(struct pt_regs *regs, unsigned long error_code)
 	 */
 	if (in_atomic() || !mm)
 		goto bad_area_nopax;
+	lhb_log_pagefault(regs);
 #else /* CONFIG_X86_64 */
 	if (likely(regs->flags & X86_EFLAGS_IF))
 		local_irq_enable();
diff --git a/drivers/pmem/pmem_init.c b/drivers/pmem/pmem_init.c
index 347b6f4..f768d83 100644
--- a/drivers/pmem/pmem_init.c
+++ b/drivers/pmem/pmem_init.c
@@ -42,6 +42,21 @@ extern pmem_handle_t kcore_part_hdl;
 extern pmem_handle_t kcore_reg_hdl;
 #endif /* CONFIG_PANIC_LOGS */
 
+#ifdef CONFIG_LHB
+extern struct pmem_ptr_block lhb_ptrs;
+#endif	/* CONFIG_LHB */
+
+#ifdef CONFIG_LHB_TESTMODE
+int lhb_mask = 7;
+
+#include <linux/proc_fs.h>
+
+static struct proc_dir_entry *lhb_mask_dir, *lhb_mask_file;
+void lhb_mask_init(void);
+#else
+#define lhb_mask_init() do { } while(0)
+#endif  /* CONFIG_LHB_TESTMODE */
+
 /* Allow the kernel command line to force a pmem format */
 static int __initdata pmem_force_clear = 0;
 
@@ -892,6 +907,9 @@ static int pmem_reg_users(void)
 	kcore_part_hdl = NULL;
 	kcore_reg_hdl = NULL;
 #endif
+#ifdef CONFIG_LHB
+	memset(&lhb_ptrs, '\0', sizeof(struct pmem_ptr_block));
+#endif
 	/* Register the log partition */
 	strncpy(part.desc, PMEM_PART_LOG_DESC, PMEM_DESC_MAX);
 	part.size = CONFIG_PMEM_LOG_PART_SIZE;
@@ -984,6 +1002,34 @@ static int pmem_reg_users(void)
 		pmem_release_handle(region_hdl);
 	}
 #endif /* CONFIG_SCHED_HIST_BUF */
+#ifdef CONFIG_LHB
+	/* Register the exception region and the pointer block and
+	 * release the handles */
+	strncpy(region.desc, PMEM_REG_EXCEPT_DESC, PMEM_DESC_MAX);
+	region.size = CONFIG_LHB_SIZE;
+	region.flags = PMEM_REG_EXCEPT_FLAGS;
+	region.fixed_size = PMEM_REG_EXCEPT_FIXED_SIZE;
+	region.num_log_desc = PMEM_REG_EXCEPT_LOG_DESC;
+	region.version = PMEM_REG_EXCEPT_VERSION;
+	region.block_id = PMEM_ACTIVE_BLOCK;
+
+	if (pmem_region_reg(log_part_hdl, &region, &region_hdl) < 0) {
+		printk(KERN_ERR "ERROR: *************************************\n");
+		printk(KERN_ERR "ERROR: Unable to get exception history region\n");
+		printk(KERN_ERR "ERROR: Linux History Buffer is DISABLED.\n");
+		printk(KERN_ERR "ERROR: *************************************\n");
+
+	}
+	else {
+		if (pmem_register_ptr_block(region_hdl, &lhb_ptrs) < 0) {
+			printk(KERN_ERR "ERROR: *************************************\n");
+			printk(KERN_ERR "ERROR: Unable to get exception history  ptr block\n");
+			printk(KERN_ERR "ERROR: Linux History Buffer is DISABLED.\n");
+			printk(KERN_ERR "ERROR: *************************************\n");
+		}
+		pmem_release_handle(region_hdl);
+	}
+#endif
 
 	pmem_release_handle(log_part_hdl);
 
@@ -1146,10 +1192,62 @@ reinit:
 	/* Now call the function that will setup common kernel areas */
 	rc = pmem_reg_users();
 
+	lhb_mask_init();
+
 	return rc;
 }
 __initcall(pmem_init);
 
+#ifdef CONFIG_LHB_TESTMODE
+static int lhb_mask_write(struct file *file, const char *buffer,
+                          unsigned long count, void *data)
+{
+	int val;
+
+	val = (int)simple_strtoul(buffer, NULL, 0);
+	printk(KERN_ERR "INFO: Seetting LHB Mask to %d\n", val);
+	if ((val >= 0) && (val < 8)) {
+		lhb_mask = val;
+	}
+
+	return 0;
+}
+
+static int lhb_mask_read(char *page, char **start, off_t off, int count,
+                         int *eof, void *data)
+{
+	int len;
+
+	len = sprintf(page, "Current LHB Mask = %d\n", lhb_mask);
+
+	return len;
+}
+
+void lhb_mask_init(void)
+{
+	lhb_mask_dir = proc_mkdir("lhb", NULL);
+	if (!lhb_mask_dir) {
+		printk(KERN_ERR "Failed to create LHB Mask dir in proc\n");
+		return;
+	}
+
+	lhb_mask_dir->owner = THIS_MODULE;
+
+	lhb_mask_file = create_proc_entry("mask", 0600, lhb_mask_dir);
+	if (!lhb_mask_file) {
+		remove_proc_entry("lhb", NULL);
+		printk(KERN_ERR "Failed to create LHB Mask entry in proc\n");
+		return;
+	}
+	lhb_mask_file->data = NULL;
+	lhb_mask_file->read_proc = lhb_mask_read;
+	lhb_mask_file->write_proc = lhb_mask_write;
+	lhb_mask_file->owner = THIS_MODULE;
+
+	printk(KERN_INFO "Loaded LHB Event mask support with value %d\n", lhb_mask);
+}
+
+#endif
 #ifdef CONFIG_PMEM_HARDWARE
 /* Hardware pmem wants to update the CRC on pmem on reboot */
 static int pmem_reboot_handler(struct notifier_block *this,
-- 
1.5.5.1

