From 20123a45e8c123cefc6b168d6033e18843ec2102 Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Thu, 4 Sep 2008 11:38:09 +0800
Subject: [PATCH] linux history buffer

Signed-off-by: Yongli he   <yongli.he@windriver.com>
Signed-off-by: MacDonald, Joe <Joe.MacDonald@windriver.com>
---
 arch/powerpc/Kconfig        |   19 +++++++
 arch/powerpc/kernel/traps.c |   39 +++++++++++++++
 arch/x86/Kconfig            |   19 +++++++
 arch/x86/kernel/entry_32.S  |   14 +++++
 arch/x86/kernel/irq_32.c    |    8 +++
 arch/x86/kernel/reboot.c    |    7 +++
 arch/x86/kernel/traps_32.c  |  111 +++++++++++++++++++++++++++++++++++++++++++
 arch/x86/mm/fault.c         |    8 +++
 drivers/pmem/pmem_init.c    |   98 ++++++++++++++++++++++++++++++++++++++
 kernel/printk.c             |    2 +-
 kernel/sched.c              |    2 +-
 mm/pmem/io.c                |    2 +-
 12 files changed, 326 insertions(+), 3 deletions(-)

diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
index 6c28dab..6c8d2b6 100644
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -351,6 +351,25 @@ config PPCBUG_NVRAM
 	bool "Enable reading PPCBUG NVRAM during boot" if PPLUS || LOPEC
 	default y if PPC_PREP
 
+config LHB
+	bool "Linux Exception History Buffer"
+	depends on PMEM && !KGDB && PREEMPT_NONE
+	default n
+	help
+	  When enabled this keeps a history buffer of exception events.
+
+config LHB_SIZE
+	int "Linux Exception History Buffer size"
+	depends on LHB
+	default 262144
+
+config LHB_TESTMODE
+	bool "Linux Exception History Test Mode"
+	default n
+	help
+	  Allows control over logging certain events in LHB through
+	  /proc/lhb_mask
+
 config IRQ_ALL_CPUS
 	bool "Distribute interrupts on all CPUs by default"
 	depends on SMP && !MV64360
diff --git a/arch/powerpc/kernel/traps.c b/arch/powerpc/kernel/traps.c
index 551008f..4643d6e 100644
--- a/arch/powerpc/kernel/traps.c
+++ b/arch/powerpc/kernel/traps.c
@@ -65,6 +65,12 @@ extern void kcore_logoff(void);
 #define kcore_logoff() do { } while(0)
 #endif /* CONFIG_PANIC_LOGS */
 
+#ifdef CONFIG_LHB
+#include <linux/pmem.h>
+
+
+struct pmem_ptr_block lhb_ptrs = { };
+#endif
 #if defined(CONFIG_DEBUGGER) || defined(CONFIG_KEXEC)
 int (*__debugger)(struct pt_regs *regs);
 int (*__debugger_ipi)(struct pt_regs *regs);
@@ -86,6 +92,38 @@ EXPORT_SYMBOL(__debugger_fault_handler);
 /*
  * Trap & Exception support
  */
+#ifdef CONFIG_LHB
+static void lhb_trap(struct pt_regs *regs)
+{
+	struct hist_buf_struct *lhb_block;
+	struct pmem_cpu_ptrs *ptrs = lhb_ptrs.cpu[smp_processor_id()].ptrs;
+
+	if (!ptrs)
+		return;
+
+	/* Wrap if we've reached the end of the buffer */
+	if (ptrs->curr + sizeof(struct hist_buf_struct) >= ptrs->end)
+		ptrs->curr = ptrs->start;
+
+	lhb_block = (struct hist_buf_struct*)ptrs->curr;
+
+	lhb_block->hbnip = instruction_pointer(regs);
+	lhb_block->hblink = regs->link;
+	lhb_block->hbtrap = regs->trap;
+	lhb_block->hbsc = current->thread.last_syscall;
+#ifdef SUPPORT_HRTIME
+	lhb_block->hbtl = (unsigned int)gethrtime();
+#else
+	lhb_block->hbtl = (unsigned int)get_cycles();
+#endif
+
+	ptrs->curr += sizeof(hist_buf_struct);
+	return;
+}
+#else
+#define lhb_trap(regs) do { } while(0)
+#endif
+
 
 #ifdef CONFIG_PMAC_BACKLIGHT
 static void pmac_backlight_unblank(void)
@@ -210,6 +248,7 @@ void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)
 	trace_trap_entry(regs, regs->trap);
 
 	memset(&info, 0, sizeof(info));
+  	lhb_trap(regs);
 	info.si_signo = signr;
 	info.si_code = code;
 	info.si_addr = (void __user *) addr;
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 899ea6e..9579699 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -217,6 +217,25 @@ menu "Processor type and features"
 
 source "kernel/time/Kconfig"
 
+config LHB
+	bool "Linux Exception History Buffer"
+	depends on PMEM && !KGDB && PREEMPT_NONE
+	default n
+	help
+	  When enabled this keeps a history buffer of exception events.
+
+config LHB_SIZE
+	int "Linux Exception History Buffer size"
+	depends on LHB
+	default 262144
+
+config LHB_TESTMODE
+	bool "Linux Exception History Test Mode"
+	default n
+	help
+	  Allows control over logging certain events in LHB through
+	  /proc/lhb_mask
+
 config SMP
 	bool "Symmetric multi-processing support"
 	---help---
diff --git a/arch/x86/kernel/entry_32.S b/arch/x86/kernel/entry_32.S
index 9afb929..a8b0e47 100644
--- a/arch/x86/kernel/entry_32.S
+++ b/arch/x86/kernel/entry_32.S
@@ -409,6 +409,13 @@ sysenter_past_esp:
 sysenter_do_call:
 	cmpl $(nr_syscalls), %eax
 	jae syscall_badsys
+#ifdef CONFIG_LHB
+	movl %esp, %eax                 # copy the stack pointer
+	pushl %eax                      # pass the stack pointer copy
+	addl $4,%esp                    # return stack to state before pass
+	call lhb_log_syscall
+	movl ORIG_EAX(%esp),%eax        # restore eax to it's original content
+#endif
 	call *sys_call_table(,%eax,4)
 	.globl ia32_sysenter_done
 ia32_sysenter_done:
@@ -507,6 +514,13 @@ ENTRY(system_call)
 	cmpl $(nr_syscalls), %eax
 	jae syscall_badsys
 syscall_call:
+#ifdef CONFIG_LHB
+ 	movl %esp, %eax                 # copy the stack pointer
+ 	pushl %eax                      # pass the stack pointer copy
+ 	addl $4,%esp                    # return stack to state before pass
+ 	call lhb_log_syscall
+ 	movl ORIG_EAX(%esp),%eax        # restore eax to it's original content
+#endif
 	call *sys_call_table(,%eax,4)
 	.globl system_call_done
 system_call_done:
diff --git a/arch/x86/kernel/irq_32.c b/arch/x86/kernel/irq_32.c
index ca827df..3027822 100644
--- a/arch/x86/kernel/irq_32.c
+++ b/arch/x86/kernel/irq_32.c
@@ -16,6 +16,12 @@
 #include <linux/cpu.h>
 #include <linux/delay.h>
 
+#ifdef CONFIG_LHB
+extern void FASTCALL(lhb_log_irq(struct pt_regs *regs));
+#else
+#define lhb_log_irq(regs) do { } while(0)
+#endif
+
 #include <asm/apic.h>
 #include <asm/uaccess.h>
 
@@ -232,6 +238,8 @@ unsigned int do_IRQ(struct pt_regs *regs)
 		BUG();
 	}
 
+ 	lhb_log_irq(regs);
+
 	old_regs = set_irq_regs(regs);
 	irq_enter();
 
diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c
index c78f073..031016c 100644
--- a/arch/x86/kernel/reboot.c
+++ b/arch/x86/kernel/reboot.c
@@ -13,6 +13,12 @@
 #include <asm/reboot_fixups.h>
 #include <asm/reboot.h>
 
+#ifdef CONFIG_LHB
+extern void lhb_log_restart(void);
+#else
+#define lhb_log_restart() do { } while(0)
+#endif
+
 #ifdef CONFIG_X86_32
 # include <linux/dmi.h>
 # include <linux/ctype.h>
@@ -434,6 +440,7 @@ void native_machine_shutdown(void)
 	smp_send_stop();
 #endif
 
+	lhb_log_restart();
 	lapic_shutdown();
 
 #ifdef CONFIG_X86_IO_APIC
diff --git a/arch/x86/kernel/traps_32.c b/arch/x86/kernel/traps_32.c
index 1a91daa..75d31fc 100644
--- a/arch/x86/kernel/traps_32.c
+++ b/arch/x86/kernel/traps_32.c
@@ -71,6 +71,11 @@ extern void kcore_logoff(void);
 #define kcore_logoff() do { } while(0)
 #endif /* CONFIG_PANIC_LOGS */
 
+#ifdef CONFIG_LHB
+#include <linux/pmem.h>
+struct pmem_ptr_block lhb_ptrs;
+#endif
+
 #include "mach_traps.h"
 
 DECLARE_BITMAP(used_vectors, NR_VECTORS);
@@ -525,6 +530,103 @@ die_if_kernel(const char *str, struct pt_regs *regs, long err)
 		die(str, regs, err);
 }
 
+#ifdef CONFIG_LHB
+/* Add an entry to the linux history buffer for i386 */
+static inline void lhb_log_entry(struct pt_regs *regs, int trapno, int signo, int errcode, unsigned int syscall_id, int irq)
+{
+	struct hist_buf_struct *lhb_block;
+	struct pmem_cpu_ptrs *ptrs = lhb_ptrs.cpu[smp_processor_id()].ptrs;
+
+	if (!ptrs)
+		return;
+
+	/* Wrap if we've reached the end of the buffer */
+	if (ptrs->curr + sizeof(struct hist_buf_struct) >= ptrs->end)
+		ptrs->curr = ptrs->start;
+	lhb_block = (struct hist_buf_struct*)ptrs->curr;
+
+	lhb_block->trapno = trapno;
+	lhb_block->signo = signo;
+	lhb_block->errcode = errcode;
+
+	/* only store regsiter info if given */
+	if (likely(regs)) {
+		lhb_block->eax = regs->eax;
+		lhb_block->ebx = regs->ebx;
+		lhb_block->ecx = regs->ecx;
+		lhb_block->edx = regs->edx;
+		lhb_block->esi = regs->esi;
+		lhb_block->edi = regs->edi;
+		lhb_block->ebp = regs->ebp;
+		lhb_block->eip = regs->eip;
+		if (regs->xcs & 3)
+			lhb_block->esp = regs->esp;
+		else
+			lhb_block->esp = 0;
+	} else {
+		lhb_block->eax = 0;
+		lhb_block->ebx = 0;
+		lhb_block->ecx = 0;
+		lhb_block->edx = 0;
+		lhb_block->esi = 0;
+		lhb_block->edi = 0;
+		lhb_block->ebp = 0;
+		lhb_block->eip = 0;
+		lhb_block->esp = 0;
+	}
+
+	lhb_block->sc = syscall_id;
+	lhb_block->irq = irq;
+#ifdef SUPPORT_HRTIME
+	lhb_block->timestamp = gethrtime();
+#else
+	lhb_block->timestamp = get_cycles();
+#endif
+
+	ptrs->curr += sizeof(hist_buf_struct);
+}
+
+/* i386 syscall trap - log to LHB buffer */
+void fastcall lhb_log_syscall(struct pt_regs *regs)
+{
+	unsigned int syscall_id;
+
+	syscall_id = (unsigned int)regs->orig_eax;
+	/* should the trapno or signo be the LHB_SYSCALL define here ? */
+	lhb_log_entry(regs, LHB_SYSCALL, 0, 0, syscall_id, 0);
+}
+
+/* i386 exception trap - log to buffer */
+void fastcall lhb_trap(struct pt_regs *regs, int trapno, int signo, int errcode)
+{
+	lhb_log_entry(regs, trapno, signo, errcode, 0, 0);
+}
+
+void fastcall lhb_log_irq(struct pt_regs *regs)
+{
+	int irq = regs->orig_eax & 0xff;
+
+	lhb_log_entry(regs, LHB_IRQ, 0, 0, 0, irq);
+}
+
+void fastcall lhb_log_pagefault(struct pt_regs *regs)
+{
+	lhb_log_entry(regs, LHB_PAGEFAULT, 0, 0, 0, 0);
+}
+
+void lhb_log_restart(void)
+{
+	lhb_log_entry(0, LHB_RESTART, 0, 0, 0, 0);
+}
+
+#else
+/* Empty definitions for LHB related stubs */
+#define lhb_log_entry(regs, trapno, signo, errcode, sc_id, irq) do { } while(0)
+#define LHB_DEBUG_EXCEPT 0
+#define LHB_NMI_EXCEPT 0
+#define lhb_trap(regs, trapno, signo, errcode) do { } while(0)
+#endif
+
 static void __kprobes
 do_trap(int trapnr, int signr, char *str, int vm86, struct pt_regs *regs,
 	long error_code, siginfo_t *info)
@@ -533,6 +635,8 @@ do_trap(int trapnr, int signr, char *str, int vm86, struct pt_regs *regs,
 
 	trace_trap_entry(regs, trapnr);
 
+	lhb_trap(regs, trapnr, signr, error_code);
+
 	if (v8086_mode(regs)) {
 		if (vm86)
 			goto vm86_trap;
@@ -713,6 +817,7 @@ do_general_protection(struct pt_regs *regs, long error_code)
 
 	tsk->thread.error_code = error_code;
 	tsk->thread.trap_no = 13;
+ 	lhb_log_entry(regs, 13, 0, error_code, 0, 0);
 
 	if (show_unhandled_signals && unhandled_signal(tsk, SIGSEGV) &&
 			printk_ratelimit()) {
@@ -731,6 +836,7 @@ do_general_protection(struct pt_regs *regs, long error_code)
 
 gp_in_vm86:
 	local_irq_enable();
+ 	lhb_log_entry(regs, 13, 0, error_code, 0, 0);
 	handle_vm86_fault((struct kernel_vm86_regs *) regs, error_code);
 	return;
 
@@ -866,6 +972,7 @@ extern void dump_irq_trace(void);
 		return;
 
 	spin_lock(&nmi_print_lock);
+	lhb_log_entry(regs, LHB_NMI_EXCEPT, 0, 0, 0, 0);
 	/*
 	* We are in trouble anyway, lets at least try
 	* to get a message out:
@@ -1058,6 +1165,8 @@ void __kprobes do_debug(struct pt_regs *regs, long error_code)
 			goto clear_TF_reenable;
 	}
 
+	lhb_log_entry(regs, LHB_DEBUG_EXCEPT, 0, error_code, 0, 0);
+
 	/* Ok, finally something we can handle */
 	trace_trap_entry(regs, 1);
 	send_sigtrap(tsk, regs, error_code);
@@ -1072,6 +1181,7 @@ clear_dr7:
 	return;
 
 debug_vm86:
+ 	lhb_log_entry(regs, LHB_DEBUG_EXCEPT, 0, error_code, 0, 0);
 	trace_trap_entry(regs, 1);
 	handle_vm86_trap((struct kernel_vm86_regs *) regs, error_code, 1);
 	trace_trap_exit();
@@ -1150,6 +1260,7 @@ void math_error(void __user *ip)
 void do_coprocessor_error(struct pt_regs *regs, long error_code)
 {
 	ignore_fpu_irq = 1;
+	lhb_trap(regs, LHB_COPROC_ERROR, 0, error_code);
 	math_error((void __user *)regs->ip);
 }
 
diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
index f5b865d..3d298ca 100644
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@ -40,6 +40,12 @@
 #include <asm-generic/sections.h>
 #include <asm/tlbflush.h>
 
+#ifdef CONFIG_LHB
+extern void FASTCALL(lhb_log_pagefault(struct pt_regs *regs));
+#else
+#define lhb_log_pagefault(regs) do { } while(0)
+#endif
+
 /*
  * Page fault error code bits
  *	bit 0 == 0 means no page found, 1 means protection fault
@@ -558,6 +564,7 @@ static int vmalloc_fault(unsigned long address)
 	pte_k = pte_offset_kernel(pmd_k, address);
 	if (!pte_present(*pte_k))
 		return -1;
+	lhb_log_pagefault(regs);
 	return 0;
 #else
 	unsigned long pgd_paddr;
@@ -706,6 +713,7 @@ void __kprobes do_page_fault(struct pt_regs *regs, unsigned long error_code)
 	 */
 	if (in_atomic() || !mm)
 		goto bad_area_nopax;
+	lhb_log_pagefault(regs);
 #else /* CONFIG_X86_64 */
 	if (likely(regs->flags & X86_EFLAGS_IF))
 		local_irq_enable();
diff --git a/drivers/pmem/pmem_init.c b/drivers/pmem/pmem_init.c
index 7d7d6c2..d5b22a8 100644
--- a/drivers/pmem/pmem_init.c
+++ b/drivers/pmem/pmem_init.c
@@ -42,6 +42,21 @@ extern pmem_handle_t kcore_part_hdl;
 extern pmem_handle_t kcore_reg_hdl;
 #endif /* CONFIG_PANIC_LOGS */
 
+#ifdef CONFIG_LHB
+extern struct pmem_ptr_block lhb_ptrs;
+#endif	/* CONFIG_LHB */
+
+#ifdef CONFIG_LHB_TESTMODE
+int lhb_mask = 7;
+
+#include <linux/proc_fs.h>
+
+static struct proc_dir_entry *lhb_mask_dir, *lhb_mask_file;
+void lhb_mask_init(void);
+#else
+#define lhb_mask_init() do { } while(0)
+#endif  /* CONFIG_LHB_TESTMODE */
+
 /* Allow the kernel command line to force a pmem format */
 static int __initdata pmem_force_clear = 0;
 
@@ -894,6 +909,9 @@ static int pmem_reg_users(void)
 	kcore_part_hdl = NULL;
 	kcore_reg_hdl = NULL;
 #endif
+#ifdef CONFIG_LHB
+	memset(&lhb_ptrs, '\0', sizeof(struct pmem_ptr_block));
+#endif
 	/* Register the log partition */
 	strncpy(part.desc, PMEM_PART_LOG_DESC, PMEM_DESC_MAX);
 	part.size = CONFIG_PMEM_LOG_PART_SIZE;
@@ -987,6 +1005,34 @@ static int pmem_reg_users(void)
 	}
 	
 #endif /* CONFIG_SCHED_HIST_BUF */
+#ifdef CONFIG_LHB
+	/* Register the exception region and the pointer block and
+	 * release the handles */
+	strncpy(region.desc, PMEM_REG_EXCEPT_DESC, PMEM_DESC_MAX);
+	region.size = CONFIG_LHB_SIZE;
+	region.flags = PMEM_REG_EXCEPT_FLAGS;
+	region.fixed_size = PMEM_REG_EXCEPT_FIXED_SIZE;
+	region.num_log_desc = PMEM_REG_EXCEPT_LOG_DESC;
+	region.version = PMEM_REG_EXCEPT_VERSION;
+	region.block_id = PMEM_ACTIVE_BLOCK;
+
+	if (pmem_region_reg(log_part_hdl, &region, &region_hdl) < 0) {
+		printk(KERN_ERR "ERROR: *************************************\n");
+		printk(KERN_ERR "ERROR: Unable to get exception history region\n");
+		printk(KERN_ERR "ERROR: Linux History Buffer is DISABLED.\n");
+		printk(KERN_ERR "ERROR: *************************************\n");
+
+	}
+	else {
+		if (pmem_register_ptr_block(region_hdl, &lhb_ptrs) < 0) {
+			printk(KERN_ERR "ERROR: *************************************\n");
+			printk(KERN_ERR "ERROR: Unable to get exception history  ptr block\n");
+			printk(KERN_ERR "ERROR: Linux History Buffer is DISABLED.\n");
+			printk(KERN_ERR "ERROR: *************************************\n");
+		}
+		pmem_release_handle(region_hdl);
+	}
+#endif
 
 	/* Release the log partition */
 	pmem_release_handle(&log_part_hdl);
@@ -1150,10 +1196,62 @@ reinit:
 	/* Now call the function that will setup common kernel areas */
 	rc = pmem_reg_users();
 
+	lhb_mask_init();
+
 	return rc;
 }
 __initcall(pmem_init);
 
+#ifdef CONFIG_LHB_TESTMODE
+static int lhb_mask_write(struct file *file, const char *buffer,
+                          unsigned long count, void *data)
+{
+	int val;
+
+	val = (int)simple_strtoul(buffer, NULL, 0);
+	printk(KERN_ERR "INFO: Seetting LHB Mask to %d\n", val);
+	if ((val >= 0) && (val < 8)) {
+		lhb_mask = val;
+	}
+
+	return 0;
+}
+
+static int lhb_mask_read(char *page, char **start, off_t off, int count,
+                         int *eof, void *data)
+{
+	int len;
+
+	len = sprintf(page, "Current LHB Mask = %d\n", lhb_mask);
+
+	return len;
+}
+
+void lhb_mask_init(void)
+{
+	lhb_mask_dir = proc_mkdir("lhb", NULL);
+	if (!lhb_mask_dir) {
+		printk(KERN_ERR "Failed to create LHB Mask dir in proc\n");
+		return;
+	}
+
+	lhb_mask_dir->owner = THIS_MODULE;
+
+	lhb_mask_file = create_proc_entry("mask", 0600, lhb_mask_dir);
+	if (!lhb_mask_file) {
+		remove_proc_entry("lhb", NULL);
+		printk(KERN_ERR "Failed to create LHB Mask entry in proc\n");
+		return;
+	}
+	lhb_mask_file->data = NULL;
+	lhb_mask_file->read_proc = lhb_mask_read;
+	lhb_mask_file->write_proc = lhb_mask_write;
+	lhb_mask_file->owner = THIS_MODULE;
+
+	printk(KERN_INFO "Loaded LHB Event mask support with value %d\n", lhb_mask);
+}
+
+#endif
 #ifdef CONFIG_PMEM_HARDWARE
 /* Hardware pmem wants to update the CRC on pmem on reboot */
 static int pmem_reboot_handler(struct notifier_block *this,
diff --git a/kernel/printk.c b/kernel/printk.c
index 931d392..a239de7 100644
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -130,7 +130,7 @@ void kcore_logon(int reboot)
 
 	atomic_inc(&log_printks);
 	printk(KERN_INFO "Kcore timestamp : %lu.%06lu\n", xtime.tv_sec, (xtime.tv_nsec/1000));
-#ifdef	CONFIG_HIGH_RES_TIMERS
+#ifdef	SUPPORT_HRTIME
 	printk(KERN_INFO "Kcore HighResolution timestamp : %LX\n", (__u64)gethrtime());
 #else
 	printk(KERN_INFO "Kcore HighResolution timestamp : %LX\n", (__u64)get_cycles());
diff --git a/kernel/sched.c b/kernel/sched.c
index d142262..f630be3 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -162,7 +162,7 @@ static inline void sched_hist_addentry(struct task_struct *prev,
 	/* get timestamp and TBR values */
 	entry->tv.tv_sec = (__u64)xtime.tv_sec;
 	entry->tv.tv_usec = (__u32)xtime.tv_nsec/1000;
-#ifdef CONFIG_HIGH_RES_TIMERS
+#ifdef SUPPORT_HRTIME
 	entry->hrts = (__u64)gethrtime();
 #else
 	entry->hrts = (__u64)get_cycles();
diff --git a/mm/pmem/io.c b/mm/pmem/io.c
index 8d63a56..656b0d1 100644
--- a/mm/pmem/io.c
+++ b/mm/pmem/io.c
@@ -396,7 +396,7 @@ static int pmem_write_log_desc(struct region_handle *hdl, void *region_data,
 
 	/* Update the new descriptor */
 	do_gettimeofday(&tv);
-#ifdef	CONFIG_HIGH_RES_TIMERS
+#ifdef	SUPPORT_HRTIME
 	log_desc->data.hrtime = gethrtime();
 #else
 	log_desc->data.hrtime = get_cycles();
-- 
1.6.0.3

