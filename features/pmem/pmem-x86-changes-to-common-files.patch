From a85e10eee9cebbeba76d75d3a8099cd3d36743d2 Mon Sep 17 00:00:00 2001
From: Jason HU <yongqi.hu@windriver.com>
Date: Fri, 30 Apr 2010 02:45:59 -0700
Subject: [PATCH] pmem: x86 changes to common files

Changes to the x86 arch specific common files for pmem.

Signed-off-by: Jason HU <yongqi.hu@windriver.com>
---
 arch/x86/Kconfig            |   19 +++++++
 arch/x86/kernel/dumpstack.c |   10 ++++
 arch/x86/kernel/entry_32.S  |   14 +++++
 arch/x86/kernel/irq.c       |    8 +++
 arch/x86/kernel/reboot.c    |   23 ++++++++-
 arch/x86/kernel/traps.c     |  120 +++++++++++++++++++++++++++++++++++++++++++
 arch/x86/mm/fault.c         |   10 +++-
 arch/x86/mm/init_32.c       |    8 +++
 arch/x86/pci/i386.c         |    1 +
 9 files changed, 211 insertions(+), 2 deletions(-)

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index b5b6eb7..4ca92b1 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -254,6 +254,25 @@ menu "Processor type and features"
 
 source "kernel/time/Kconfig"
 
+config LHB
+	bool "Exception History Buffer"
+	depends on PMEM && !KGDB && PREEMPT_NONE
+	default n
+	help
+	  When enabled this keeps a history buffer of exception events.
+
+config LHB_SIZE
+	int "Exception History Buffer size"
+	depends on LHB
+	default 262144
+
+config LHB_TESTMODE
+	bool "Exception History Test Mode"
+	default n
+	help
+	  Allows control over logging certain events in LHB through
+	  /proc/lhb_mask
+
 config SMP
 	bool "Symmetric multi-processing support"
 	---help---
diff --git a/arch/x86/kernel/dumpstack.c b/arch/x86/kernel/dumpstack.c
index cbe3b9a..404bd9f 100644
--- a/arch/x86/kernel/dumpstack.c
+++ b/arch/x86/kernel/dumpstack.c
@@ -21,6 +21,14 @@
 
 #include "dumpstack.h"
 
+#ifdef CONFIG_PANIC_LOGS
+extern void kcore_logon(int reboot);
+extern void kcore_logoff(void);
+#else
+#define kcore_logon(reboot) do { } while(0)
+#define kcore_logoff() do { } while(0)
+#endif /* CONFIG_PANIC_LOGS */
+
 int panic_on_unrecovered_nmi;
 int panic_on_io_nmi;
 unsigned int code_bytes = 64;
@@ -296,6 +304,7 @@ int __kprobes __die(const char *str, struct pt_regs *regs, long err)
 #ifdef CONFIG_X86_32
 	unsigned short ss;
 	unsigned long sp;
+	kcore_logon(0);
 #endif
 	printk(KERN_EMERG "%s: %04lx [#%d] ", str, err & 0xffff, ++die_counter);
 #ifdef CONFIG_PREEMPT
@@ -329,6 +338,7 @@ int __kprobes __die(const char *str, struct pt_regs *regs, long err)
 	printk(KERN_EMERG "EIP: [<%08lx>] ", regs->ip);
 	print_symbol("%s", regs->ip);
 	printk(" SS:ESP %04x:%08lx\n", ss, sp);
+	kcore_logoff();
 #else
 	/* Executive summary in case the oops scrolled away */
 	printk(KERN_ALERT "RIP ");
diff --git a/arch/x86/kernel/entry_32.S b/arch/x86/kernel/entry_32.S
index 6511348..486546a 100644
--- a/arch/x86/kernel/entry_32.S
+++ b/arch/x86/kernel/entry_32.S
@@ -566,6 +566,13 @@ sysenter_past_esp:
 sysenter_do_call:
 	cmpl $(nr_syscalls), %eax
 	jae syscall_badsys
+#ifdef CONFIG_LHB
+	movl %esp, %eax                 # copy the stack pointer
+	pushl %eax                      # pass the stack pointer copy
+	addl $4,%esp                    # return stack to state before pass
+	call lhb_log_syscall
+	movl PT_ORIG_EAX(%esp),%eax        # restore eax to it's original content
+#endif
 	call *sys_call_table(,%eax,4)
 	.globl ia32_sysenter_done
 ia32_sysenter_done:
@@ -669,6 +676,13 @@ ENTRY(system_call)
 	cmpl $(nr_syscalls), %eax
 	jae syscall_badsys
 syscall_call:
+#ifdef CONFIG_LHB
+ 	movl %esp, %eax                 # copy the stack pointer
+ 	pushl %eax                      # pass the stack pointer copy
+ 	addl $4,%esp                    # return stack to state before pass
+ 	call lhb_log_syscall
+ 	movl PT_ORIG_EAX(%esp),%eax        # restore eax to it's original content
+#endif
 	call *sys_call_table(,%eax,4)
 	.globl system_call_done
 system_call_done:
diff --git a/arch/x86/kernel/irq.c b/arch/x86/kernel/irq.c
index 91fd0c7..1d2097c 100644
--- a/arch/x86/kernel/irq.c
+++ b/arch/x86/kernel/irq.c
@@ -15,6 +15,12 @@
 #include <asm/mce.h>
 #include <asm/hw_irq.h>
 
+#ifdef CONFIG_LHB
+extern void lhb_log_irq(struct pt_regs *regs);
+#else
+#define lhb_log_irq(regs) do { } while(0)
+#endif
+
 atomic_t irq_err_count;
 
 /* Function pointer for generic interrupt vector handling */
@@ -231,6 +237,8 @@ unsigned int __irq_entry do_IRQ(struct pt_regs *regs)
 	unsigned vector = ~regs->orig_ax;
 	unsigned irq;
 
+ 	lhb_log_irq(regs);
+	
 	exit_idle();
 	irq_enter();
 
diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c
index 2784137..f694044 100644
--- a/arch/x86/kernel/reboot.c
+++ b/arch/x86/kernel/reboot.c
@@ -15,10 +15,21 @@
 #include <asm/proto.h>
 #include <asm/reboot_fixups.h>
 #include <asm/reboot.h>
+
+#ifdef CONFIG_RESET_LOGS
+#include <linux/kernel.h>
+#endif
+
 #include <asm/pci_x86.h>
 #include <asm/virtext.h>
 #include <asm/cpu.h>
 
+#ifdef CONFIG_LHB
+extern void lhb_log_restart(void);
+#else
+#define lhb_log_restart() do { } while(0)
+#endif
+
 #ifdef CONFIG_X86_32
 # include <linux/ctype.h>
 # include <linux/mc146818rtc.h>
@@ -635,6 +646,7 @@ void native_machine_shutdown(void)
 	smp_send_stop();
 #endif
 
+	lhb_log_restart();
 	lapic_shutdown();
 
 #ifdef CONFIG_X86_IO_APIC
@@ -659,7 +671,16 @@ static void __machine_emergency_restart(int emergency)
 static void native_machine_restart(char *__unused)
 {
 	printk("machine restart\n");
-
+#ifdef CONFIG_RESET_LOGS
+	struct timeval tv;
+
+	kcore_logon(1);
+	do_gettimeofday(&tv);
+	printk("Machine Restart at %9d:%06d\n", (int) tv.tv_sec, (int) tv.tv_usec);
+	dump_stack();
+	printk("Current process %d: '%s'\n", current->pid, current->comm);
+	kcore_logoff_quiet();
+#endif
 	if (!reboot_force)
 		machine_shutdown();
 	__machine_emergency_restart(0);
diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c
index ee3b39b..7b61713 100644
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@ -58,6 +58,11 @@
 #include <asm/i387.h>
 #include <asm/mce.h>
 
+#ifdef CONFIG_LHB
+#include <linux/pmem.h>
+struct pmem_ptr_block lhb_ptrs;
+#endif
+
 #include <asm/mach_traps.h>
 
 #ifdef CONFIG_X86_64
@@ -120,6 +125,106 @@ die_if_kernel(const char *str, struct pt_regs *regs, long err)
 }
 #endif
 
+#ifdef CONFIG_LHB
+/* Add an entry to the linux history buffer for i386 */
+static inline void lhb_log_entry(struct pt_regs *regs, int trapno, int signo, int errcode, unsigned int syscall_id, int irq)
+{
+	struct hist_buf_struct *lhb_block;
+	struct pmem_cpu_ptrs *ptrs = lhb_ptrs.cpu[smp_processor_id()].ptrs;
+
+	if (!ptrs)
+		return;
+
+	if (disable_history_buffer)
+		return;
+
+	/* Wrap if we've reached the end of the buffer */
+	if (ptrs->curr + sizeof(struct hist_buf_struct) >= ptrs->end)
+		ptrs->curr = ptrs->start;
+	lhb_block = (struct hist_buf_struct*)ptrs->curr;
+
+	lhb_block->trapno = trapno;
+	lhb_block->signo = signo;
+	lhb_block->errcode = errcode;
+
+	/* only store regsiter info if given */
+	if (likely(regs)) {
+		lhb_block->eax = regs->ax;
+		lhb_block->ebx = regs->bx;
+		lhb_block->ecx = regs->cx;
+		lhb_block->edx = regs->dx;
+		lhb_block->esi = regs->si;
+		lhb_block->edi = regs->di;
+		lhb_block->ebp = regs->bp;
+		lhb_block->eip = regs->ip;
+		if (regs->cs & 3)
+			lhb_block->esp = regs->sp;
+		else
+			lhb_block->esp = 0;
+	} else {
+		lhb_block->eax = 0;
+		lhb_block->ebx = 0;
+		lhb_block->ecx = 0;
+		lhb_block->edx = 0;
+		lhb_block->esi = 0;
+		lhb_block->edi = 0;
+		lhb_block->ebp = 0;
+		lhb_block->eip = 0;
+		lhb_block->esp = 0;
+	}
+
+	lhb_block->sc = syscall_id;
+	lhb_block->irq = irq;
+#ifdef SUPPORT_HRTIME
+	lhb_block->timestamp = gethrtime();
+#else
+	lhb_block->timestamp = get_cycles();
+#endif
+
+	ptrs->curr += sizeof(hist_buf_struct);
+}
+
+/* i386 syscall trap - log to LHB buffer */
+void lhb_log_syscall(struct pt_regs *regs)
+{
+	unsigned int syscall_id;
+
+	syscall_id = (unsigned int)regs->orig_ax;
+	/* should the trapno or signo be the LHB_SYSCALL define here ? */
+	lhb_log_entry(regs, LHB_SYSCALL, 0, 0, syscall_id, 0);
+}
+
+/* i386 exception trap - log to buffer */
+void lhb_trap(struct pt_regs *regs, int trapno, int signo, int errcode)
+{
+	lhb_log_entry(regs, trapno, signo, errcode, 0, 0);
+}
+
+void lhb_log_irq(struct pt_regs *regs)
+{
+	int irq = regs->orig_ax & 0xff;
+
+	lhb_log_entry(regs, LHB_IRQ, 0, 0, 0, irq);
+}
+
+void lhb_log_pagefault(struct pt_regs *regs)
+{
+	lhb_log_entry(regs, LHB_PAGEFAULT, 0, 0, 0, 0);
+}
+
+void lhb_log_restart(void)
+{
+	lhb_log_entry(0, LHB_RESTART, 0, 0, 0, 0);
+}
+
+#else
+/* Empty definitions for LHB related stubs */
+#define lhb_log_entry(regs, trapno, signo, errcode, sc_id, irq) do { } while(0)
+#define LHB_DEBUG_EXCEPT 0
+#define LHB_NMI_EXCEPT 0
+#define lhb_trap(regs, trapno, signo, errcode) do { } while(0)
+#endif
+
 static void __kprobes
 do_trap(int trapnr, int signr, const char *str, struct pt_regs *regs,
 	long error_code, siginfo_t *info)
@@ -129,6 +234,8 @@ do_trap(int trapnr, int signr, const char *str, struct pt_regs *regs,
 	trace_trap_entry(regs, trapnr);
 
 #ifdef CONFIG_X86_32
+	lhb_trap(regs, trapnr, signr, error_code);
+
 	if (v8086_mode(regs)) {
 		/*
 		 * traps 0, 1, 3, 4, and 5 should be forwarded to vm86.
@@ -311,6 +418,10 @@ do_general_protection(struct pt_regs *regs, long error_code)
 	tsk->thread.error_code = error_code;
 	tsk->thread.trap_no = 13;
 
+#ifdef CONFIG_X86_32
+	lhb_log_entry(regs, 13, 0, error_code, 0, 0);
+#endif
+
 	if (show_unhandled_signals && unhandled_signal(tsk, SIGSEGV) &&
 			printk_ratelimit()) {
 		printk(KERN_INFO
@@ -329,6 +440,7 @@ do_general_protection(struct pt_regs *regs, long error_code)
 #ifdef CONFIG_X86_32
 gp_in_vm86:
 	local_irq_enable();
+	lhb_log_entry(regs, 13, 0, error_code, 0, 0);
 	handle_vm86_fault((struct kernel_vm86_regs *) regs, error_code);
 	return;
 #endif
@@ -645,6 +757,9 @@ dotraplinkage void __kprobes do_debug(struct pt_regs *regs, long error_code)
 
 	if (v8086_mode(regs)) {
 		trace_trap_entry(regs, 1);
+#ifdef CONFIG_X86_32
+		lhb_log_entry(regs, LHB_DEBUG_EXCEPT, 0, error_code, 0, 0);
+#endif
 		handle_vm86_trap((struct kernel_vm86_regs *) regs,
 				error_code, 1);
 		trace_trap_exit();
@@ -663,6 +778,10 @@ dotraplinkage void __kprobes do_debug(struct pt_regs *regs, long error_code)
 		set_tsk_thread_flag(tsk, TIF_SINGLESTEP);
 		regs->flags &= ~X86_EFLAGS_TF;
 	}
+#ifdef CONFIG_X86_32
+	lhb_log_entry(regs, LHB_DEBUG_EXCEPT, 0, error_code, 0, 0);
+#endif
+
 	si_code = get_si_code(tsk->thread.debugreg6);
 	if (tsk->thread.debugreg6 & (DR_STEP | DR_TRAP_BITS)) {
 		trace_trap_entry(regs, 1);
@@ -771,6 +890,7 @@ dotraplinkage void do_coprocessor_error(struct pt_regs *regs, long error_code)
 
 #ifdef CONFIG_X86_32
 	ignore_fpu_irq = 1;
+	lhb_trap(regs, LHB_COPROC_ERROR, 0, error_code);
 #else
 	if (!user_mode(regs) &&
 	    kernel_math_error(regs, "kernel x87 math error", 16))
diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
index cf2a862..d559467 100644
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@ -26,6 +26,12 @@
 #include "../kernel/dumpstack.h"
 #endif
 
+#ifdef CONFIG_LHB
+extern void lhb_log_pagefault(struct pt_regs *regs);
+#else
+#define lhb_log_pagefault(regs) do { } while(0)
+#endif
+
 /*
  * Page fault error code bits:
  *
@@ -301,7 +307,6 @@ static noinline __kprobes int vmalloc_fault(unsigned long address)
 	pmd_k = vmalloc_sync_one(__va(pgd_paddr), address);
 	if (!pmd_k)
 		return -1;
-
 	pte_k = pte_offset_kernel(pmd_k, address);
 	if (!pte_present(*pte_k))
 		return -1;
@@ -1287,6 +1292,9 @@ do_page_fault(struct pt_regs *regs, unsigned long error_code)
 	 */
 	if (unlikely(in_atomic() || !mm)) {
 		bad_area_nosemaphore(regs, error_code, address);
+#ifdef CONFIG_X86_32
+		lhb_log_pagefault(regs);
+#endif
 		return;
 	}
 
diff --git a/arch/x86/mm/init_32.c b/arch/x86/mm/init_32.c
index 313e4cb..7edde82 100644
--- a/arch/x86/mm/init_32.c
+++ b/arch/x86/mm/init_32.c
@@ -58,6 +58,14 @@ static noinline int do_test_wp_bit(void);
 
 bool __read_mostly __vmalloc_start_set = false;
 
+#ifdef CONFIG_PMEM
+unsigned long pmem_arch_pgprot_noncached(unsigned long prot)
+{
+	prot |= _PAGE_PCD | _PAGE_PWT;
+	return prot;
+}
+#endif	/* CONFIG_PMEM */
+
 static __init void *alloc_low_page(void)
 {
 	unsigned long pfn = e820_table_end++;
diff --git a/arch/x86/pci/i386.c b/arch/x86/pci/i386.c
index 97da2ba..3b1e381 100644
--- a/arch/x86/pci/i386.c
+++ b/arch/x86/pci/i386.c
@@ -319,3 +319,4 @@ int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,
 
 	return 0;
 }
+EXPORT_SYMBOL(pci_mmap_page_range);
-- 
1.6.0.3

