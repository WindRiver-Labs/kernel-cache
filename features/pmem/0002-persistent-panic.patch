From adea198abb06981817d94470baa6e1eb15c90b0d Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Thu, 4 Sep 2008 10:34:22 +0800
Subject: [PATCH] persistent panic

Signed-off-by: Yongli he   <yongli.he@windriver.com>
Signed-off-by: MacDonald, Joe <Joe.MacDonald@windriver.com>
diff --git a/arch/powerpc/kernel/traps.c b/arch/powerpc/kernel/traps.c
index 69cd954..9e75cd7 100644
--- a/arch/powerpc/kernel/traps.c
+++ b/arch/powerpc/kernel/traps.c
@@ -55,6 +55,14 @@
 #endif
 #include <asm/kexec.h>
 
+#ifdef CONFIG_PANIC_LOGS
+extern void kcore_logon(int reboot);
+extern void kcore_logoff(void);
+#else
+#define kcore_logon(reboot) do { } while(0)
+#define kcore_logoff() do { } while(0)
+#endif /* CONFIG_PANIC_LOGS */
+
 #if defined(CONFIG_DEBUGGER) || defined(CONFIG_KEXEC)
 int (*__debugger)(struct pt_regs *regs);
 int (*__debugger_ipi)(struct pt_regs *regs);
@@ -120,6 +128,7 @@ int die(const char *str, struct pt_regs *regs, long err)
 		die.lock_owner = smp_processor_id();
 		die.lock_owner_depth = 0;
 		bust_spinlocks(1);
+		kcore_logon(0);
 		if (machine_is(powermac))
 			pmac_backlight_unblank();
 	} else {
@@ -127,6 +136,8 @@ int die(const char *str, struct pt_regs *regs, long err)
 	}
 
 	if (++die.lock_owner_depth < 3) {
+		/*Capture Critical information here*/
+ 		kcore_logon(0);
 		printk("Oops: %s, sig: %ld [#%d]\n", str, err, ++die_counter);
 #ifdef CONFIG_PREEMPT
 		printk("PREEMPT ");
@@ -149,6 +160,7 @@ int die(const char *str, struct pt_regs *regs, long err)
 
 		print_modules();
 		show_regs(regs);
+		kcore_logoff();
 	} else {
 		printk("Recursive die() failure, output suppressed\n");
 	}
diff --git a/arch/x86/kernel/traps_32.c b/arch/x86/kernel/traps_32.c
index 09ffc55..ca0d736 100644
--- a/arch/x86/kernel/traps_32.c
+++ b/arch/x86/kernel/traps_32.c
@@ -62,6 +62,14 @@
 #include <asm/traps.h>
 #include <asm/unistd.h>
 
+#ifdef CONFIG_PANIC_LOGS
+extern void kcore_logon(int reboot);
+extern void kcore_logoff(void);
+#else
+#define kcore_logon(reboot) do { } while(0)
+#define kcore_logoff() do { } while(0)
+#endif /* CONFIG_PANIC_LOGS */
+
 #include "mach_traps.h"
 
 DECLARE_BITMAP(used_vectors, NR_VECTORS);
@@ -440,6 +448,7 @@ int __kprobes __die(const char *str, struct pt_regs *regs, long err)
 	unsigned short ss;
 	unsigned long sp;
 
+	kcore_logon(0);
 	printk(KERN_EMERG "%s: %04lx [#%d] ", str, err & 0xffff, ++die_counter);
 #ifdef CONFIG_PREEMPT
 	printk("PREEMPT ");
@@ -471,6 +480,8 @@ int __kprobes __die(const char *str, struct pt_regs *regs, long err)
 	printk(KERN_EMERG "EIP: [<%08lx>] ", regs->ip);
 	print_symbol("%s", regs->ip);
 	printk(" SS:ESP %04x:%08lx\n", ss, sp);
+    	kcore_logoff();
+	
 	return 0;
 }
 
diff --git a/drivers/pmem/pmem_init.c b/drivers/pmem/pmem_init.c
index fb1377c..347b6f4 100644
--- a/drivers/pmem/pmem_init.c
+++ b/drivers/pmem/pmem_init.c
@@ -37,6 +37,11 @@
 extern struct pmem_ptr_block sched_hist_pmem_block;
 #endif /* CONFIG_SCHED_HIST_BUF */
 
+#ifdef CONFIG_PANIC_LOGS
+extern pmem_handle_t kcore_part_hdl;
+extern pmem_handle_t kcore_reg_hdl;
+#endif /* CONFIG_PANIC_LOGS */
+
 /* Allow the kernel command line to force a pmem format */
 static int __initdata pmem_force_clear = 0;
 
@@ -883,6 +888,10 @@ static int pmem_reg_users(void)
 #ifdef CONFIG_SCHED_HIST_BUF
 	memset(&sched_hist_pmem_block, '\0', sizeof(struct pmem_ptr_block));
 #endif
+#ifdef CONFIG_PANIC_LOGS
+	kcore_part_hdl = NULL;
+	kcore_reg_hdl = NULL;
+#endif
 	/* Register the log partition */
 	strncpy(part.desc, PMEM_PART_LOG_DESC, PMEM_DESC_MAX);
 	part.size = CONFIG_PMEM_LOG_PART_SIZE;
@@ -898,6 +907,35 @@ static int pmem_reg_users(void)
 		return rc;
 	}
 
+#ifdef CONFIG_PANIC_LOGS
+	/* Register the printk region and keep the handles */
+	if (pmem_partition_reg(&part, &kcore_part_hdl) < 0) {
+		printk(KERN_ERR "ERROR: **********************************\n");
+		printk(KERN_ERR "ERROR: Unable to get log partition\n");
+		printk(KERN_ERR "ERROR: Persistent panic feature DISABLED\n");
+		printk(KERN_ERR "ERROR: **********************************\n");
+	}
+	else {
+		strncpy(region.desc, "kcore", PMEM_DESC_MAX);
+		region.size = CONFIG_PANIC_LOGS_SIZE;
+		region.flags = PMEM_REGION_FLAG_PERPROC | PMEM_REGION_FLAG_STOPFULL;
+		region.fixed_size = 0;
+		region.num_log_desc = 0;
+		region.version = 1;
+		region.block_id = PMEM_ACTIVE_BLOCK;
+
+		if (pmem_region_reg(kcore_part_hdl, &region, &kcore_reg_hdl) < 0) {
+			printk(KERN_ERR "ERROR: **********************************\n");
+			printk(KERN_ERR "ERROR: Unable to get kcore logs region\n");
+			printk(KERN_ERR "ERROR: Persistent panic feature disabled\n");
+			printk(KERN_ERR "ERROR: **********************************\n");
+			
+			pmem_release_handle(kcore_part_hdl);
+			kcore_part_hdl = NULL;
+		}
+	}
+#endif
+
 #ifdef CONFIG_PMEM_LOG_REG
 	/* Register the log region and release the handle */
 	strncpy(region.desc, PMEM_REG_GENERAL_DESC, PMEM_DESC_MAX);
diff --git a/include/linux/module.h b/include/linux/module.h
index c06fb54..7c9127f 100644
--- a/include/linux/module.h
+++ b/include/linux/module.h
@@ -479,6 +479,11 @@ extern int module_get_iter_markers(struct marker_iter *iter);
 extern void module_update_tracepoints(void);
 extern int module_get_iter_tracepoints(struct tracepoint_iter *iter);
 
+#ifdef CONFIG_PANIC_LOGS
+extern void pmem_dump_module_list(void);
+extern void pmem_dump_ksyms(void);
+#endif /* CONFIG_PANIC_LOGS */
+
 #else /* !CONFIG_MODULES... */
 #define EXPORT_SYMBOL(sym)
 #define EXPORT_SYMBOL_GPL(sym)
diff --git a/init/Kconfig b/init/Kconfig
index 4fd68bf..8bed126 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -580,6 +580,21 @@ config SCHED_HIST_SIZE
 	depends on SCHED_HIST_BUF
 	default 262144
 
+config PANIC_LOGS
+	bool "Panic logging support"
+	depends on PMEM
+	default n
+	help
+	  When enabled this keeps a history buffer of panic events.
+
+config PANIC_LOGS_SIZE
+	int "Panic log size"
+	depends on PANIC_LOGS
+	default 262144
+	help
+	  Specifies the size (in bytes) of the panic history buffer in
+	  persistent memory.
+
 config SYSCTL
 	bool
 
diff --git a/kernel/module.c b/kernel/module.c
index 9bac6d6..60927b6 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -2972,3 +2972,75 @@ int is_imv_cond_end_module(unsigned long addr1, unsigned long addr2)
 		addr1, addr2);
 }
 #endif
+
+#ifdef CONFIG_PANIC_LOGS
+
+#include <linux/pmem.h>
+extern pmem_handle_t kcore_reg_hdl;    /* instantiated in printk.c  */
+
+#define MODLIST_SIZE 4096
+
+/*
+ * Same function as module.c void print_modules(void) EXCEPT that
+ * redirection of printk is used
+ */
+void pmem_dump_module_list(void)
+{
+	struct module *mod;
+	unsigned int pos = 0;
+	char buf[MODLIST_SIZE];
+
+	if (!kcore_reg_hdl)
+		return;
+
+	pos += snprintf(buf+pos, MODLIST_SIZE-pos, "\n");
+	list_for_each_entry(mod, &modules, list)
+		pos += snprintf(buf+pos, MODLIST_SIZE-pos, "%s ", mod->name);
+	pos += snprintf(buf+pos, MODLIST_SIZE-pos-1, "\n");
+
+	pmem_write_data(kcore_reg_hdl, buf, pos);
+}
+
+void pmem_dump_ksyms(void)
+{
+	struct module *mod;
+	const struct kernel_symbol *sym;
+	char buf[512];
+	unsigned int len;
+	unsigned int i;
+	
+	if (!kcore_reg_hdl)
+		return;
+        
+	pmem_write_data(kcore_reg_hdl, "\n", 1);
+
+	list_for_each_entry(mod, &modules, list) {
+		for (i = 0; i < mod->num_syms; i++) {
+			sym = &mod->syms[i];
+			if (mod->name)
+				len = snprintf(buf, 512, "%0*lx %s\t[%s]\n", 
+						(int)(2*sizeof(void*)), sym->value, 
+						sym->name, mod->name);
+			else
+				len = snprintf(buf, 512, "%0*lx %s\n", 
+						(int)(2*sizeof(void*)),
+						sym->value, sym->name);
+			pmem_write_data(kcore_reg_hdl, buf, len);
+		}
+		/* and gpl symbols as well */
+		for (i = 0; i < mod->num_gpl_syms; i++) {
+			sym = &mod->gpl_syms[i];
+			if (mod->name)
+				len = snprintf(buf, 512, "%0*lx %s\t[%s]\n", 
+						(int)(2*sizeof(void*)), sym->value, 
+						sym->name, mod->name);
+			else
+				len = snprintf(buf, 512, "%0*lx %s\n", 
+						(int)(2*sizeof(void*)),
+						sym->value, sym->name);
+			pmem_write_data(kcore_reg_hdl, buf, len);
+		}
+	}
+}
+
+#endif /* CONFIG_PANIC_LOGS */
diff --git a/kernel/panic.c b/kernel/panic.c
index 12c5a0a..0483207 100644
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -28,6 +28,14 @@ static int pause_on_oops;
 static int pause_on_oops_flag;
 static DEFINE_SPINLOCK(pause_on_oops_lock);
 
+#ifdef CONFIG_PANIC_LOGS
+extern void kcore_logon(int reboot);
+extern void kcore_logoff(void);
+#else
+#define kcore_logon(reboot) do { } while(0)
+#define kcore_logoff() do { } while(0)
+#endif /* CONFIG_PANIC_LOGS */
+
 int panic_timeout;
 
 ATOMIC_NOTIFIER_HEAD(panic_notifier_list);
@@ -79,6 +87,7 @@ NORET_TYPE void panic(const char * fmt, ...)
 	va_start(args, fmt);
 	vsnprintf(buf, sizeof(buf), fmt, args);
 	va_end(args);
+	kcore_logon(1);
 	printk(KERN_EMERG "Kernel panic - not syncing: %s\n",buf);
 	bust_spinlocks(0);
 
@@ -109,6 +118,7 @@ NORET_TYPE void panic(const char * fmt, ...)
 		 * We can't use the "normal" timers since we just panicked..
 	 	 */
 		printk(KERN_EMERG "Rebooting in %d seconds..",panic_timeout);
+		kcore_logoff();
 		for (i = 0; i < panic_timeout*1000; ) {
 			touch_nmi_watchdog();
 			i += panic_blink(i);
@@ -132,6 +142,7 @@ NORET_TYPE void panic(const char * fmt, ...)
 #if defined(CONFIG_S390)
 	disabled_wait(caller);
 #endif
+	kcore_logoff();
 	local_irq_enable();
 	for (i = 0;;) {
 		touch_softlockup_watchdog();
diff --git a/kernel/printk.c b/kernel/printk.c
index d1a41be..2b715f0 100644
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -106,6 +106,49 @@ static DEFINE_SPINLOCK(logbuf_lock);
 #define LOG_BUF_MASK (log_buf_len-1)
 #define LOG_BUF(idx) (log_buf[(idx) & LOG_BUF_MASK])
 
+#ifdef CONFIG_PANIC_LOGS
+#include <linux/pmem.h>
+#include <linux/time.h>
+
+pmem_handle_t kcore_part_hdl = 0;
+pmem_handle_t kcore_reg_hdl = 0;
+atomic_t log_printks = ATOMIC_INIT(0);
+
+void kcore_logon(int reboot)
+{
+	if (!kcore_reg_hdl)
+		return;
+
+	/*
+	if (atomic_read(&log_printks))
+		return;
+		*/
+
+	if (reboot)
+		pmem_disable_ptr_blocks(kcore_part_hdl);
+
+	atomic_inc(&log_printks);
+	printk(KERN_INFO "Kcore timestamp : %lu.%06lu\n", xtime.tv_sec, (xtime.tv_nsec/1000));
+#ifdef	CONFIG_HIGH_RES_TIMERS
+	printk(KERN_INFO "Kcore HighResolution timestamp : %LX\n", (__u64)gethrtime());
+#else
+	printk(KERN_INFO "Kcore HighResolution timestamp : %LX\n", (__u64)get_cycles());
+#endif
+}
+
+void kcore_logoff(void)
+{
+	if (!kcore_reg_hdl)
+		return;
+
+	if (!atomic_dec_and_test(&log_printks))
+		return;
+
+	pmem_dump_module_list();
+	pmem_dump_ksyms();
+}
+#endif
+
 /*
  * The indices into log_buf are not constrained to log_buf_len - they
  * must be masked before subscripting
@@ -492,6 +535,17 @@ static void _call_console_drivers(unsigned start,
 			__call_console_drivers(start, end);
 		}
 	}
+#ifdef CONFIG_PANIC_LOGS
+	if ((start != end) && atomic_read(&log_printks)) {/*Dont care about log level*/
+		if ((start & LOG_BUF_MASK) > (end & LOG_BUF_MASK)) {
+			/* wrapped write */
+			pmem_write_data(kcore_reg_hdl, &LOG_BUF(start & LOG_BUF_MASK), __LOG_BUF_LEN-(start & LOG_BUF_MASK));
+			pmem_write_data(kcore_reg_hdl, &LOG_BUF(0), (end & LOG_BUF_MASK) -0);
+		} else {
+			pmem_write_data(kcore_reg_hdl, &LOG_BUF(start), end-start);
+		}
+	}
+#endif
 }
 
 /*
