From be859e8a8a527f8b42aead26c169f802ba0b0118 Mon Sep 17 00:00:00 2001
From: Jason HU <yongqi.hu@windriver.com>
Date: Fri, 30 Apr 2010 02:46:00 -0700
Subject: [PATCH 3/4] pmem: powerpc changes to common files

Changes to the powerpc arch specific common files for pmem.

Signed-off-by: Jason HU <yongqi.hu@windriver.com>
---
 arch/powerpc/Kconfig               |   19 ++++++++++++
 arch/powerpc/include/asm/system.h  |    3 ++
 arch/powerpc/kernel/misc.S         |   56 ++++++++++++++++++++++++++++++++++++
 arch/powerpc/kernel/pci-common.c   |    1 +
 arch/powerpc/kernel/setup-common.c |   16 ++++++++++
 arch/powerpc/kernel/traps.c        |   56 ++++++++++++++++++++++++++++++++++++
 arch/powerpc/mm/init_32.c          |   13 ++++++++
 7 files changed, 164 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
index 2e19500..59ae673 100644
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -388,6 +388,25 @@ config PPCBUG_NVRAM
 	bool "Enable reading PPCBUG NVRAM during boot" if PPLUS || LOPEC
 	default y if PPC_PREP
 
+config LHB
+	bool "Exception History Buffer"
+	depends on PMEM && !KGDB && PREEMPT_NONE
+	default n
+	help
+	  When enabled this keeps a history buffer of exception events.
+
+config LHB_SIZE
+	int "Exception History Buffer size"
+	depends on LHB
+	default 262144
+
+config LHB_TESTMODE
+	bool "Exception History Test Mode"
+	default n
+	help
+	  Allows control over logging certain events in LHB through
+	  /proc/lhb_mask
+
 config IRQ_ALL_CPUS
 	bool "Distribute interrupts on all CPUs by default"
 	depends on SMP && !MV64360
diff --git a/arch/powerpc/include/asm/system.h b/arch/powerpc/include/asm/system.h
index a6297c6..327f05c 100644
--- a/arch/powerpc/include/asm/system.h
+++ b/arch/powerpc/include/asm/system.h
@@ -122,6 +122,9 @@ extern void do_dabr(struct pt_regs *regs, unsigned long address,
 extern void print_backtrace(unsigned long *);
 extern void show_regs(struct pt_regs * regs);
 extern void flush_instruction_cache(void);
+extern void flush_data_cache(void);
+extern void flush_data_cache_soft(void);
+extern void flush_data_cache_hard(void);
 extern void hard_reset_now(void);
 extern void poweroff_now(void);
 
diff --git a/arch/powerpc/kernel/misc.S b/arch/powerpc/kernel/misc.S
index 22e507c..4015d44 100644
--- a/arch/powerpc/kernel/misc.S
+++ b/arch/powerpc/kernel/misc.S
@@ -19,6 +19,7 @@
 #include <asm/unistd.h>
 #include <asm/asm-compat.h>
 #include <asm/asm-offsets.h>
+#include <asm/page.h>
 
 	.text
 
@@ -122,6 +123,61 @@ _GLOBAL(longjmp)
 	mtlr	r0
 	mr	r3,r4
 	blr
+/*
+ * Flush the L1 data cache by reading the first 64kB of RAM
+ * and then flushing the same area with the dcbf instruction.
+ * The L2 cache has already been disabled.
+ */
+_GLOBAL(flush_data_cache)
+	li	r4,0x0800	/* 64kB / 32B */
+	mtctr	r4
+	lis	r4,KERNELBASE@h
+1:
+	lwz	r0,0(r4)
+	addi	r4,r4,0x0020	/* Go to start of next cache line */
+	bdnz	1b
+	sync
+
+	li	r4,0x0800	/* 64k */
+	mtctr	r4
+	lis	r4,KERNELBASE@h
+1:
+	dcbf	r0,r4
+	addi	r4,r4,0x0020	/* Go to start of next cache line */
+	bdnz	1b
+	sync
+10:	blr
+
+#ifdef CONFIG_UCACHE
+/*
+ *	flush_data_cache_soft:
+ *		Flush the L1 data cache by loading the
+ *	first 64Kb from the kernel base, then flushing
+ *	it.
+ */
+
+_GLOBAL(flush_data_cache_soft)
+	b	flush_data_cache
+
+
+/*
+ *	flush_data_cache_hard:
+ *		Flush the L1 data cache using the 7400
+ *	hardware flush parameter in MSSCR0.
+ */
+
+_GLOBAL(flush_data_cache_hard)
+	mfspr	r3,MSSCR0
+	oris	r3,r3,MSSCR0_DL1HWF@h
+
+	sync
+	mtspr	MSSCR0,r3
+
+	sync
+	blr
+
+#endif /* CONFIG_UCACHE */
+
 
 _GLOBAL(__setup_cpu_power7)
 _GLOBAL(__restore_cpu_power7)
diff --git a/arch/powerpc/kernel/pci-common.c b/arch/powerpc/kernel/pci-common.c
index 0c0567e..f2ee351 100644
--- a/arch/powerpc/kernel/pci-common.c
+++ b/arch/powerpc/kernel/pci-common.c
@@ -464,6 +464,7 @@ int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,
 
 	return ret;
 }
+EXPORT_SYMBOL(pci_mmap_page_range);
 
 /* This provides legacy IO read access on a bus */
 int pci_legacy_read(struct pci_bus *bus, loff_t port, u32 *val, size_t size)
diff --git a/arch/powerpc/kernel/setup-common.c b/arch/powerpc/kernel/setup-common.c
index 48f0a00..11f95af 100644
--- a/arch/powerpc/kernel/setup-common.c
+++ b/arch/powerpc/kernel/setup-common.c
@@ -34,6 +34,11 @@
 #include <linux/debugfs.h>
 #include <linux/percpu.h>
 #include <linux/lmb.h>
+
+#ifdef CONFIG_RESET_LOGS
+#include <linux/kernel.h>
+#endif
+
 #include <linux/of_platform.h>
 #include <asm/io.h>
 #include <asm/paca.h>
@@ -109,6 +114,17 @@ void machine_shutdown(void)
 
 void machine_restart(char *cmd)
 {
+#ifdef CONFIG_RESET_LOGS
+	struct timeval tv;
+
+	kcore_logon(1);
+	do_gettimeofday(&tv);
+	printk("Machine Restart at %9d:%06d\n", (int) tv.tv_sec, (int) tv.tv_usec);
+	dump_stack();
+	printk("Current process %d: '%s'\n", current->pid, current->comm);
+	kcore_logoff_quiet();
+#endif
+
 	machine_shutdown();
 	if (ppc_md.restart)
 		ppc_md.restart(cmd);
diff --git a/arch/powerpc/kernel/traps.c b/arch/powerpc/kernel/traps.c
index b6859aa..211b6f1 100644
--- a/arch/powerpc/kernel/traps.c
+++ b/arch/powerpc/kernel/traps.c
@@ -54,10 +54,26 @@
 #endif
 #include <asm/kexec.h>
 #include <asm/ppc-opcode.h>
+
+#ifdef CONFIG_PANIC_LOGS
+extern void kcore_logon(int reboot);
+extern void kcore_logoff(void);
+#else
+#define kcore_logon(reboot) do { } while(0)
+#define kcore_logoff() do { } while(0)
+#endif /* CONFIG_PANIC_LOGS */
+
 #ifdef CONFIG_FSL_BOOKE
 #include <asm/dbell.h>
 #endif
 
+#ifdef CONFIG_LHB
+#include <linux/pmem.h>
+
+#include <asm/syscall.h>
+
+struct pmem_ptr_block lhb_ptrs = { };
+#endif
 #if defined(CONFIG_DEBUGGER) || defined(CONFIG_KEXEC)
 int (*__debugger)(struct pt_regs *regs) __read_mostly;
 int (*__debugger_ipi)(struct pt_regs *regs) __read_mostly;
@@ -79,6 +95,41 @@ EXPORT_SYMBOL(__debugger_fault_handler);
 /*
  * Trap & Exception support
  */
+#ifdef CONFIG_LHB
+static void lhb_trap(struct pt_regs *regs)
+{
+	struct hist_buf_struct *lhb_block;
+	struct pmem_cpu_ptrs *ptrs = lhb_ptrs.cpu[smp_processor_id()].ptrs;
+
+	if (!ptrs)
+		return;
+
+	if (disable_history_buffer)
+		return;
+
+	/* Wrap if we've reached the end of the buffer */
+	if (ptrs->curr + sizeof(struct hist_buf_struct) >= ptrs->end)
+		ptrs->curr = ptrs->start;
+
+	lhb_block = (struct hist_buf_struct*)ptrs->curr;
+
+	lhb_block->hbnip = instruction_pointer(regs);
+	lhb_block->hblink = regs->link;
+	lhb_block->hbtrap = regs->trap;
+	lhb_block->hbsc = syscall_get_nr(current,regs);
+#ifdef SUPPORT_HRTIME
+	lhb_block->hbtl = (unsigned int)gethrtime();
+#else
+	lhb_block->hbtl = (unsigned int)get_cycles();
+#endif
+
+	ptrs->curr += sizeof(hist_buf_struct);
+	return;
+}
+#else
+#define lhb_trap(regs) do { } while(0)
+#endif
+
 
 #ifdef CONFIG_PMAC_BACKLIGHT
 static void pmac_backlight_unblank(void)
@@ -123,6 +174,7 @@ int die(const char *str, struct pt_regs *regs, long err)
 		die.lock_owner = smp_processor_id();
 		die.lock_owner_depth = 0;
 		bust_spinlocks(1);
+		kcore_logon(0);
 		if (machine_is(powermac))
 			pmac_backlight_unblank();
 	} else {
@@ -130,6 +182,8 @@ int die(const char *str, struct pt_regs *regs, long err)
 	}
 
 	if (++die.lock_owner_depth < 3) {
+		/*Capture Critical information here*/
+ 		kcore_logon(0);
 		printk("Oops: %s, sig: %ld [#%d]\n", str, err, ++die_counter);
 #ifdef CONFIG_PREEMPT
 		printk("PREEMPT ");
@@ -152,6 +206,7 @@ int die(const char *str, struct pt_regs *regs, long err)
 
 		print_modules();
 		show_regs(regs);
+		kcore_logoff();
 	} else {
 		printk("Recursive die() failure, output suppressed\n");
 	}
@@ -207,6 +262,7 @@ void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)
 		}
 
 	memset(&info, 0, sizeof(info));
+  	lhb_trap(regs);
 	info.si_signo = signr;
 	info.si_code = code;
 	info.si_addr = (void __user *) addr;
diff --git a/arch/powerpc/mm/init_32.c b/arch/powerpc/mm/init_32.c
index 7673330..a236867 100644
--- a/arch/powerpc/mm/init_32.c
+++ b/arch/powerpc/mm/init_32.c
@@ -45,6 +45,10 @@
 #include <asm/sections.h>
 #include <asm/system.h>
 
+#if defined CONFIG_PMEM
+#include <linux/pmem.h>
+#endif
+
 #include "mmu_decl.h"
 
 #if defined(CONFIG_KERNEL_START_BOOL) || defined(CONFIG_LOWMEM_SIZE_BOOL)
@@ -116,6 +120,15 @@ void MMU_setup(void)
 #endif
 }
 
+ 
+#if defined CONFIG_PMEM
+unsigned long pmem_arch_pgprot_noncached(unsigned long prot)
+{
+ 	prot |= _PAGE_NO_CACHE | _PAGE_GUARDED;
+ 	return prot;
+}
+#endif
+ 
 /*
  * MMU_init sets up the basic memory mappings for the kernel,
  * including both RAM and possibly some I/O regions,
-- 
1.6.5.2

