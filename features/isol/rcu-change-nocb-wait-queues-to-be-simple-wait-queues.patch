From e228a057edb5ac5d1b28df75057f519d811211e1 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Tue, 30 Apr 2013 14:56:38 -0400
Subject: [PATCH] rcu: change nocb wait queues to be simple wait queues

Our cherry pick of upstream commit dae6e64d2bcfd4b06304ab864
upstream (" rcu: Introduce proper blocking to no-CBs kthreads
GP waits") causes the following because we have RT present:

BUG: sleeping function called from invalid kernel/rtmutex.c:659
in_atomic(): 1, irqs_disabled(): 1, pid: 8, name: rcu_preempt
Pid: 8, comm: rcu_preempt Not tainted 3.4.34-rt40-preempt-rt+ #4
Call Trace:
 [<ffffffff8106c8d0>] __might_sleep+0xd0/0xf0
 [<ffffffff817d77b4>] rt_spin_lock+0x24/0x50
 [<ffffffff8106fcf6>] __wake_up+0x36/0x70
 [<ffffffff810c4542>] rcu_gp_kthread+0x4d2/0x680
 [<ffffffff8105f910>] ? __init_waitqueue_head+0x50/0x50
 [<ffffffff810c4070>] ? rcu_gp_fqs+0x80/0x80
 [<ffffffff8105eabb>] kthread+0xdb/0xe0
 [<ffffffff8106b912>] ? finish_task_switch+0x52/0x100
 [<ffffffff817e0754>] kernel_thread_helper+0x4/0x10
 [<ffffffff8105e9e0>] ? __init_kthread_worker+0x60/0x60
 [<ffffffff817e0750>] ? gs_change+0xb/0xb

The simple waitqueues were introduced exactly for this reason,
i.e. when a waitqueue causes a problem that can't be fixed
by turning the head lock into a raw lock, due to callbacks, etc.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/kernel/rcutree.h b/kernel/rcutree.h
index fcb9505..d20188d 100644
--- a/kernel/rcutree.h
+++ b/kernel/rcutree.h
@@ -23,6 +23,7 @@
  */
 
 #include <linux/cache.h>
+#include <linux/wait-simple.h>
 #include <linux/spinlock.h>
 #include <linux/threads.h>
 #include <linux/cpumask.h>
@@ -197,7 +198,7 @@ struct rcu_node {
 				/*  This can happen due to race conditions. */
 #endif /* #ifdef CONFIG_RCU_BOOST */
 #ifdef CONFIG_RCU_NOCB_CPU
-	wait_queue_head_t nocb_gp_wq[2];
+	struct swait_head nocb_gp_wq[2];
 				/* Place for rcu_nocb_kthread() to wait GP. */
 	int n_nocb_gp_requests[2];
 				/* Counts of upcoming no-CB GP requests. */
diff --git a/kernel/rcutree_plugin.h b/kernel/rcutree_plugin.h
index 6b2d3a8..3d06de3 100644
--- a/kernel/rcutree_plugin.h
+++ b/kernel/rcutree_plugin.h
@@ -2210,7 +2210,7 @@ static int rcu_nocb_gp_cleanup(struct rcu_state *rsp, struct rcu_node *rnp)
 	int c = rnp->completed;
 	int needmore;
 
-	wake_up_all(&rnp->nocb_gp_wq[c & 0x1]);
+	swait_wake_all(&rnp->nocb_gp_wq[c & 0x1]);
 	rnp->n_nocb_gp_requests[c & 0x1] = 0;
 	needmore = rnp->n_nocb_gp_requests[(c + 1) & 0x1];
 	return needmore;
@@ -2231,8 +2231,8 @@ static void rcu_nocb_gp_set(struct rcu_node *rnp, int nrq)
 
 static void rcu_init_one_nocb(struct rcu_node *rnp)
 {
-	init_waitqueue_head(&rnp->nocb_gp_wq[0]);
-	init_waitqueue_head(&rnp->nocb_gp_wq[1]);
+	init_swait_head(&rnp->nocb_gp_wq[0]);
+	init_swait_head(&rnp->nocb_gp_wq[1]);
 }
 
 /* Is the specified CPU a no-CPUs CPU? */
@@ -2402,7 +2402,7 @@ static void rcu_nocb_wait_gp(struct rcu_data *rdp)
 	 * up the load average.
 	 */
 	for (;;) {
-		wait_event_interruptible(
+		swait_event_interruptible(
 			rnp->nocb_gp_wq[c & 0x1],
 			(d = ULONG_CMP_GE(ACCESS_ONCE(rnp->completed), c)));
 		if (likely(d))
-- 
1.8.1.2

