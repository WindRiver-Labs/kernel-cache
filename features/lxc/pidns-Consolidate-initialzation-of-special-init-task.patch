From 6870353939b8741c1c48ab27ce40551b4bc188c6 Mon Sep 17 00:00:00 2001
From: "Eric W. Biederman" <ebiederm@xmission.com>
Date: Mon, 12 Jul 2010 17:10:36 -0700
Subject: [PATCH 12/16] pidns: Consolidate initialzation of special init task
 state

Instead of setting child_reaper and SIGNAL_UNKILLABLE one way
for the system init process, and another way for pid namespace
init processes test pid->nr == 1 and use the same code for both.

This is a small cleanup and it paves the way for allowing unshare
of the pid namespace as that path like our global init also will
not set CLONE_NEWPID.

Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

[YS: Original patch taken from http://lxc.sourceforge.net/patches/linux/3.0.0/3.0.0-lxc1/patches/;
Context modified to WR kernel tree]

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 init/main.c   |    3 ---
 kernel/fork.c |   14 +++++++++++---
 2 files changed, 11 insertions(+), 6 deletions(-)

diff --git a/init/main.c b/init/main.c
index 58f2222..c2eb8e3 100644
--- a/init/main.c
+++ b/init/main.c
@@ -804,9 +804,6 @@ static noinline int init_post(void)
 	system_state = SYSTEM_RUNNING;
 	numa_default_policy();
 
-
-	current->signal->flags |= SIGNAL_UNKILLABLE;
-
 	if (ramdisk_execute_command) {
 		run_init_process(ramdisk_execute_command);
 		printk(KERN_WARNING "Failed to execute %s\n",
diff --git a/kernel/fork.c b/kernel/fork.c
index 33750f2..dd2c39c 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1027,8 +1027,6 @@ static int copy_signal(unsigned long clone_flags, struct task_struct *tsk)
 	atomic_set(&sig->live, 1);
 	atomic_set(&sig->sigcnt, 1);
 	init_waitqueue_head(&sig->wait_chldexit);
-	if (clone_flags & CLONE_NEWPID)
-		sig->flags |= SIGNAL_UNKILLABLE;
 	sig->curr_target = tsk;
 	init_sigpending(&sig->shared_pending);
 	INIT_LIST_HEAD(&sig->posix_timers);
@@ -1440,8 +1438,18 @@ static struct task_struct *copy_process(unsigned long clone_flags,
 		ptrace_init_task(p, (clone_flags & CLONE_PTRACE) || trace);
 
 		if (thread_group_leader(p)) {
-			if (is_child_reaper(pid))
+			if (is_child_reaper(pid)) {
+				/*
+				 * Tell the world that we're going to be the grim
+				 * reaper of innocent orphaned children.
+				 *
+				 * We don't want people to have to make incorrect
+				 * assumptions about where in the task array this
+				 * can be found.
+				 */
 				p->nsproxy->pid_ns->child_reaper = p;
+				p->signal->flags |= SIGNAL_UNKILLABLE;
+			}
 
 			p->signal->leader_pid = pid;
 			p->signal->tty = tty_kref_get(current->signal->tty);
-- 
1.7.9.7

