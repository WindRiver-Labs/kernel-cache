From e8f4d63d04d753bcdb1f4a0356298a904b74fc21 Mon Sep 17 00:00:00 2001
From: "Eric W. Biederman" <ebiederm@xmission.com>
Date: Mon, 12 Jul 2010 18:50:25 -0700
Subject: [PATCH 13/16] pidns: Don't allow new processes in a dead pid
 namespace.

By adding a flag to track when a pid namespace is dead, and
by testing that flag just before a process attaches to the
pid namespace, it is possible to guarantee that processes
never enter a dead pid namespace.  Currently sending SIGKILL
to all of the process in a dead pid namespace gives us this
guarantee but we need something a little strong to support
unsharing and joining a pid namespace.

To ensure that this does not slow down the common case I
tested this code with lat_proc from lm_bench and I did
not see any increase in the fork overhead.

Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

[YS: Original patch taken from http://lxc.sourceforge.net/patches/linux/3.0.0/3.0.0-lxc1/patches/;
Context modified to WR kernel tree]

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 include/linux/pid_namespace.h |   18 ++++++++++++++++++
 kernel/fork.c                 |    7 +++++++
 kernel/pid.c                  |    3 +++
 kernel/pid_namespace.c        |    1 +
 4 files changed, 29 insertions(+)

diff --git a/include/linux/pid_namespace.h b/include/linux/pid_namespace.h
index ae5e760..170bf37 100644
--- a/include/linux/pid_namespace.h
+++ b/include/linux/pid_namespace.h
@@ -21,6 +21,7 @@ struct pid_namespace {
 	struct kref kref;
 	struct pidmap pidmap[PIDMAP_ENTRIES];
 	int last_pid;
+	int dead;
 	struct task_struct *child_reaper;
 	struct kmem_cache *pid_cachep;
 	unsigned int level;
@@ -58,6 +59,17 @@ static inline void put_pid_ns(struct pid_namespace *ns)
 		kref_put(&ns->kref, free_pid_ns);
 }
 
+static inline bool pid_ns_dead(struct pid *pid)
+{
+	int i;
+
+	for (i = 0; i <= pid->level; i++) {
+		if (pid->numbers[i].ns->dead)
+			return true;
+	}
+	return false;
+}
+
 #else /* !CONFIG_PID_NS */
 #include <linux/err.h>
 
@@ -87,6 +99,12 @@ static inline int reboot_pid_ns(struct pid_namespace *pid_ns, int cmd)
 {
 	return 0;
 }
+
+static inline bool pid_ns_dead(struct pid *pid)
+{
+	return false;
+}
+
 #endif /* CONFIG_PID_NS */
 
 extern struct pid_namespace *task_active_pid_ns(struct task_struct *tsk);
diff --git a/kernel/fork.c b/kernel/fork.c
index dd2c39c..28f74d3 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1426,6 +1426,13 @@ static struct task_struct *copy_process(unsigned long clone_flags,
 		goto bad_fork_free_pid;
 	}
 
+	if (pid_ns_dead(pid)) {
+		spin_unlock(&current->sighand->siglock);
+		write_unlock_irq(&tasklist_lock);
+		retval = -EPERM;
+		goto bad_fork_free_pid;
+	}
+
 	if (clone_flags & CLONE_THREAD) {
 		current->signal->nr_threads++;
 		atomic_inc(&current->signal->live);
diff --git a/kernel/pid.c b/kernel/pid.c
index 753a1ae..2075865 100644
--- a/kernel/pid.c
+++ b/kernel/pid.c
@@ -76,6 +76,7 @@ struct pid_namespace init_pid_ns = {
 		[ 0 ... PIDMAP_ENTRIES-1] = { ATOMIC_INIT(BITS_PER_PAGE), NULL }
 	},
 	.last_pid = 0,
+	.dead = 0,
 	.level = 0,
 	.child_reaper = &init_task,
 	.proc_inum = PROC_PID_INIT_INO,
@@ -294,6 +295,8 @@ struct pid *alloc_pid(struct pid_namespace *ns)
 
 	tmp = ns;
 	for (i = ns->level; i >= 0; i--) {
+		if (ns->dead)
+			goto out_free;
 		nr = alloc_pidmap(tmp);
 		if (nr < 0)
 			goto out_free;
diff --git a/kernel/pid_namespace.c b/kernel/pid_namespace.c
index e9e0f04..817dc34 100644
--- a/kernel/pid_namespace.c
+++ b/kernel/pid_namespace.c
@@ -176,6 +176,7 @@ void zap_pid_ns_processes(struct pid_namespace *pid_ns)
 	 *
 	 */
 	read_lock(&tasklist_lock);
+	pid_ns->dead = 1;
 	for (nr = next_pidmap(pid_ns, 0); nr > 0; nr = next_pidmap(pid_ns, nr)) {
 		rcu_read_lock();
 		task = pid_task(find_pid_ns(nr, pid_ns), PIDTYPE_PID);
-- 
1.7.9.7

