From d88a7aeb668bc2c239d6512e3aa658485a62b3b2 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Mon, 15 Dec 2008 00:40:27 +0800
Subject: [PATCH] fix null pointer mm->owner

Since mm->owner is not always set, we need to always check
for a NULL pointer.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 mm/memrlimitcgroup.c |   16 ++++++++++++++--
 1 files changed, 14 insertions(+), 2 deletions(-)

diff --git a/mm/memrlimitcgroup.c b/mm/memrlimitcgroup.c
index 21119dd..cc54b31 100644
--- a/mm/memrlimitcgroup.c
+++ b/mm/memrlimitcgroup.c
@@ -61,6 +61,12 @@ int memrlimit_cgroup_charge_as(struct mm_struct *mm, unsigned long nr_pages)
 {
 	struct memrlimit_cgroup *memrcg;
 
+	/*
+	 * Null pointer is not found from callers up to now, BUG_ON
+	 * is added here to report a potential bug; and there is a
+	 * return value required by caller.
+	 */	
+	BUG_ON(!(mm->owner));
 	memrcg = memrlimit_cgroup_from_task(mm->owner);
 	return res_counter_charge(&memrcg->as_res, (nr_pages << PAGE_SHIFT));
 }
@@ -73,8 +79,14 @@ void memrlimit_cgroup_uncharge_as(struct mm_struct *mm, unsigned long nr_pages)
 {
 	struct memrlimit_cgroup *memrcg;
 
-	memrcg = memrlimit_cgroup_from_task(mm->owner);
-	res_counter_uncharge(&memrcg->as_res, (nr_pages << PAGE_SHIFT));
+	/*
+	 * it looks like the caller does not care what happens in
+	 * here, so there is no return since mm->owner is null.
+	 */
+	if(mm->owner){
+		memrcg = memrlimit_cgroup_from_task(mm->owner);
+		res_counter_uncharge(&memrcg->as_res, (nr_pages << PAGE_SHIFT));
+	}
 }
 
 static struct cgroup_subsys_state *
-- 
1.6.0.2.GIT

