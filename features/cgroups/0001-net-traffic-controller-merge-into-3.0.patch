From 174eb3c7747a7e610f2cef6f8197ee0bb156a5d1 Mon Sep 17 00:00:00 2001
From: zumeng chen <zumeng.chen@windriver.com>
Date: Tue, 14 Oct 2008 10:56:46 +0800
Subject: [PATCH] net traffic controller merge into 3.0

This patch provides a simple resource controller (cgroup_tc) based on the
cgroups infrastructure to manage network traffic. The cgroup_tc resource
controller can be used to schedule and shape traffic belonging to the task(s)
in a particular cgroup.

The implementation consists of two parts:

1) A resource controller (cgroup_tc) that is used to associate packets from
   a particular task belonging to a cgroup with a traffic control class id (
   tc_classid). This tc_classid is propagated to all sockets created by tasks
   in the cgroup and will be used for classifying packets at the link layer.

2) A new traffic control classifier (cls_cgroup) that can classify packets
   based on the tc_classid field in the socket to specific destination classes.

An example of the use of this resource controller would be to limit
the traffic from all tasks from a file_server cgroup to 100Mbps. We could
achieve this by doing:

1) Set QoS for cgroup

   tc qdisc add dev eth0 root handle 1: htb
   # For cgroup
   tc class add dev eth0 parent 1: classid 1:10 htb rate 4mbit ceil 4mbit
   # For others
   tc class add dev eth0 parent 1: classid 1:20 htb rate 40mbit ceil 40mbit

   # cls_groups filter for cgroup process
   tc filter add dev eth0 parent 1: handle 800 protocol ip prio 10 cgroup value 0x1234 classid 1:10
   # Basic filter for others
   tc filter add dev eth0 parent 1: protocol ip prio 20 basic classid 1:20

2) In another shell do the following is high recommended
   mkdir -p /cgroups/tc
   mount -t cgroup tc -otc /cgroups/tc
   mkdir /cgroups/tc/file_transfer
   echo 0x1234 > /cgroups/tc/file_transfer/tc.classid
   echo $$ > /cgroups/tc/file_transfer/tasks

3) Then scp document to user@ip_addr,(uplink only)

Signed-off-by: Ranjit Manomohan <ranjitm@google.com>
Integrated-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 include/linux/cgroup_subsys.h |    6 +
 include/linux/cgroup_tc.h     |   20 +++
 include/linux/pkt_cls.h       |   15 ++
 include/net/sock.h            |    3 +
 init/Kconfig                  |   11 ++
 kernel/Makefile               |    1 +
 kernel/tc_cgroup.c            |  105 +++++++++++++
 net/sched/Kconfig             |   10 ++
 net/sched/Makefile            |    1 +
 net/sched/cls_cgroup.c        |  330 +++++++++++++++++++++++++++++++++++++++++
 net/socket.c                  |    6 +-
 11 files changed, 507 insertions(+), 1 deletions(-)
 create mode 100644 include/linux/cgroup_tc.h
 create mode 100644 kernel/tc_cgroup.c
 create mode 100644 net/sched/cls_cgroup.c

diff --git a/include/linux/cgroup_subsys.h b/include/linux/cgroup_subsys.h
index e287745..4b12372 100644
--- a/include/linux/cgroup_subsys.h
+++ b/include/linux/cgroup_subsys.h
@@ -48,3 +48,9 @@ SUBSYS(devices)
 #endif
 
 /* */
+
+#ifdef CONFIG_CGROUP_TC
+SUBSYS(tc)
+#endif
+
+/* */
diff --git a/include/linux/cgroup_tc.h b/include/linux/cgroup_tc.h
new file mode 100644
index 0000000..e4ba6a1
--- /dev/null
+++ b/include/linux/cgroup_tc.h
@@ -0,0 +1,20 @@
+#ifndef __LINUX_CGROUP_TC_H
+#define __LINUX_CGROUP_TC_H
+
+/* Interface to obtain tasks cgroup identifier. */
+
+#include <linux/cgroup.h>
+#include <linux/skbuff.h>
+#include <net/sock.h>
+
+#ifdef CONFIG_CGROUP_TC
+
+void cgroup_tc_set_sock_classid(struct sock *sk);
+
+#else
+
+#define cgroup_tc_set_sock_classid(sk)
+
+#endif /* CONFIG_CGROUP_TC */
+
+#endif /* __LINUX_CGROUP_TC_H */
diff --git a/include/linux/pkt_cls.h b/include/linux/pkt_cls.h
index 7cf7824..1c43d29 100644
--- a/include/linux/pkt_cls.h
+++ b/include/linux/pkt_cls.h
@@ -380,6 +380,21 @@ enum
 
 #define TCA_FLOW_MAX	(__TCA_FLOW_MAX - 1)
 
+/* Cgroups filter */
+
+enum {
+	TCA_CGROUP_UNSPEC,
+	TCA_CGROUP_CLASSID,
+	TCA_CGROUP_MASK,
+	TCA_CGROUP_VALUE,
+	TCA_CGROUP_ACT,
+	TCA_CGROUP_POLICE,
+	TCA_CGROUP_EMATCHES,
+	__TCA_CGROUP_MAX
+};
+
+#define TCA_CGROUP_MAX	(__TCA_CGROUP_MAX - 1)
+
 /* Basic filter */
 
 enum
diff --git a/include/net/sock.h b/include/net/sock.h
index 06c5259..8696af1 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -271,6 +271,9 @@ struct sock {
 	int			sk_write_pending;
 	void			*sk_security;
 	__u32			sk_mark;
+#ifdef CONFIG_CGROUP_TC
+	__u32			sk_cgroup_classid;
+#endif
 	/* XXX 4 bytes hole on 64 bit */
 	void			(*sk_state_change)(struct sock *sk);
 	void			(*sk_data_ready)(struct sock *sk, int bytes);
diff --git a/init/Kconfig b/init/Kconfig
index 60e87b5..35e594d 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -290,6 +290,17 @@ config CGROUP_DEBUG
 
 	  Say N if unsure
 
+config CGROUP_TC
+	bool "Traffic control cgroup subsystem"
+	depends on CGROUPS
+	default n
+	help
+	  This option enables a simple cgroup subsystem that
+	  allows network traffic to be classified based on the
+	  cgroup of the task originating the traffic.
+
+	  Say N if unsure
+
 config CGROUP_NS
         bool "Namespace cgroup subsystem"
         depends on CGROUPS
diff --git a/kernel/Makefile b/kernel/Makefile
index 8b7f733..3d1bb36 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -59,6 +59,7 @@ obj-$(CONFIG_CGROUPS) += cgroup.o
 obj-$(CONFIG_CGROUP_DEBUG) += cgroup_debug.o
 obj-$(CONFIG_CPUSETS) += cpuset.o
 obj-$(CONFIG_CGROUP_NS) += ns_cgroup.o
+obj-$(CONFIG_CGROUP_TC) += tc_cgroup.o
 obj-$(CONFIG_UTS_NS) += utsname.o
 obj-$(CONFIG_USER_NS) += user_namespace.o
 obj-$(CONFIG_PID_NS) += pid_namespace.o
diff --git a/kernel/tc_cgroup.c b/kernel/tc_cgroup.c
new file mode 100644
index 0000000..ea24f84
--- /dev/null
+++ b/kernel/tc_cgroup.c
@@ -0,0 +1,105 @@
+/*
+ * tc_cgroup.c - traffic control cgroup subsystem
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/cgroup.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/cgroup_tc.h>
+
+struct tc_cgroup {
+	struct cgroup_subsys_state css;
+	unsigned int classid;
+};
+
+struct cgroup_subsys tc_subsys;
+
+static inline struct tc_cgroup *cgroup_to_tc(
+		struct cgroup *cgroup)
+{
+	return container_of(cgroup_subsys_state(cgroup, tc_subsys_id),
+			    struct tc_cgroup, css);
+}
+
+static unsigned int cgroup_tc_classid(struct task_struct *tsk)
+{
+	unsigned int tc_classid;
+
+	rcu_read_lock();
+	tc_classid = container_of(task_subsys_state(tsk, tc_subsys_id),
+					 struct tc_cgroup, css)->classid;
+	rcu_read_unlock();
+	return tc_classid;
+}
+
+void cgroup_tc_set_sock_classid(struct sock *sk)
+{
+	if (sk)
+		sk->sk_cgroup_classid = cgroup_tc_classid(current);
+}
+
+static struct cgroup_subsys_state *tc_create(struct cgroup_subsys *ss,
+						struct cgroup *cgroup)
+{
+	struct tc_cgroup *tc_cgroup;
+
+	tc_cgroup = kzalloc(sizeof(*tc_cgroup), GFP_KERNEL);
+
+	if (!tc_cgroup)
+		return ERR_PTR(-ENOMEM);
+
+	/* Copy parent's class id if present */
+	if (cgroup->parent)
+		tc_cgroup->classid = cgroup_to_tc(cgroup->parent)->classid;
+
+	return &tc_cgroup->css;
+}
+
+static void tc_destroy(struct cgroup_subsys *ss,
+			struct cgroup *cgroup)
+{
+	kfree(cgroup_to_tc(cgroup));
+}
+
+static int tc_write_u64(struct cgroup *cgroup, struct cftype *cft, u64 val)
+{
+	struct tc_cgroup *tc = cgroup_to_tc(cgroup);
+
+	if (!cgroup_lock_live_group(cgroup))
+		return -ENODEV;
+
+	tc->classid = (unsigned int) (val & 0xffffffff);
+	cgroup_unlock();
+	return 0;
+}
+
+static u64 tc_read_u64(struct cgroup *cgroup, struct cftype *cft)
+{
+	struct tc_cgroup *tc = cgroup_to_tc(cgroup);
+	return tc->classid;
+}
+
+static struct cftype tc_files[] = {
+	{
+		.name = "classid",
+		.read_u64 = tc_read_u64,
+		.write_u64 = tc_write_u64,
+	}
+};
+
+static int tc_populate(struct cgroup_subsys *ss, struct cgroup *cgroup)
+{
+	int err;
+	err = cgroup_add_files(cgroup, ss, tc_files, ARRAY_SIZE(tc_files));
+	return err;
+}
+
+struct cgroup_subsys tc_subsys = {
+	.name = "tc",
+	.create = tc_create,
+	.destroy  = tc_destroy,
+	.populate = tc_populate,
+	.subsys_id = tc_subsys_id,
+};
diff --git a/net/sched/Kconfig b/net/sched/Kconfig
index 9437b27..9ef0a32 100644
--- a/net/sched/Kconfig
+++ b/net/sched/Kconfig
@@ -307,6 +307,16 @@ config NET_CLS_FLOW
 	  To compile this code as a module, choose M here: the
 	  module will be called cls_flow.
 
+config NET_CLS_CGROUP
+	tristate "Cgroups tc classifier"
+	select NET_CLS
+	---help---
+	  If you say Y here, you will be able to classify packets based on
+	  cgroup membership of the task originating the packet.
+
+	  To compile this code as a module, choose M here: the
+	  module will be called cls_cgroup.
+
 config NET_EMATCH
 	bool "Extended Matches"
 	select NET_CLS
diff --git a/net/sched/Makefile b/net/sched/Makefile
index 1d2b0f7..91e9ee0 100644
--- a/net/sched/Makefile
+++ b/net/sched/Makefile
@@ -36,6 +36,7 @@ obj-$(CONFIG_NET_CLS_TCINDEX)	+= cls_tcindex.o
 obj-$(CONFIG_NET_CLS_RSVP6)	+= cls_rsvp6.o
 obj-$(CONFIG_NET_CLS_BASIC)	+= cls_basic.o
 obj-$(CONFIG_NET_CLS_FLOW)	+= cls_flow.o
+obj-$(CONFIG_NET_CLS_CGROUP)	+= cls_cgroup.o
 obj-$(CONFIG_NET_EMATCH)	+= ematch.o
 obj-$(CONFIG_NET_EMATCH_CMP)	+= em_cmp.o
 obj-$(CONFIG_NET_EMATCH_NBYTE)	+= em_nbyte.o
diff --git a/net/sched/cls_cgroup.c b/net/sched/cls_cgroup.c
new file mode 100644
index 0000000..70a363f
--- /dev/null
+++ b/net/sched/cls_cgroup.c
@@ -0,0 +1,330 @@
+/*
+ * net/sched/cls_cgroup.c	Simple packet classifier which can filter
+ * 				packets based on the cgroups they belong to.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/skbuff.h>
+#include <net/pkt_cls.h>
+#include <net/netlink.h>
+#include <net/sock.h>
+
+struct cgroup_head {
+	struct list_head	flist;		/* Head of filter list */
+};
+
+struct cgroup_filter {
+	u32			handle;		/* Unique filter handle */
+	struct tcf_exts		exts;
+	struct tcf_ematch_tree	ematches;
+	struct tcf_result	res;
+	struct list_head	link;
+	u32			mask;
+	u32			value;
+};
+
+static const struct tcf_ext_map cgroup_ext_map = {
+	.action	= TCA_CGROUP_ACT,
+	.police	= TCA_CGROUP_POLICE,
+};
+
+/* This function is called from the qdisc to classify a particular packet
+ * contained in the skb to the appropriate sub-classes. It returns the
+ * classid of the target class. This filter will match if the cgroup_classid
+ * in the skb matches the value in the filter.
+ */
+static int cgroup_classify(struct sk_buff *skb, struct tcf_proto *tp,
+			  struct tcf_result *res)
+{
+	struct cgroup_head *head = (struct cgroup_head *)tp->root;
+	struct cgroup_filter *f;
+	uint32_t cgroup_classid = 0;
+	int r;
+
+#ifdef CONFIG_CGROUP_TC
+	if (skb->sk)
+		cgroup_classid =  skb->sk->sk_cgroup_classid;
+#endif
+
+	list_for_each_entry(f, &head->flist, link) {
+
+		if (!tcf_em_tree_match(skb, &f->ematches, NULL))
+			continue;
+
+		if ((cgroup_classid & f->mask) == f->value) {
+			*res = f->res;
+			r = tcf_exts_exec(skb, &f->exts, res);
+			if (r < 0)
+				continue;
+			return r;
+		}
+	}
+	return -1;
+}
+
+/* Returns pointer to filter matching the handle passed into the function.*/
+static unsigned long cgroup_get(struct tcf_proto *tp, u32 handle)
+{
+	unsigned long l = 0UL;
+	struct cgroup_head *head = (struct cgroup_head *) tp->root;
+	struct cgroup_filter *f;
+
+	if (head == NULL)
+		return 0UL;
+
+	list_for_each_entry(f, &head->flist, link)
+		if (f->handle == handle)
+			l = (unsigned long) f;
+
+	return l;
+}
+
+/* Does not seem to be used for classifiers. */
+static void cgroup_put(struct tcf_proto *tp, unsigned long f)
+{
+}
+
+/* Initializer function called when tp is created. */
+static int cgroup_init(struct tcf_proto *tp)
+{
+	struct cgroup_head *head = kzalloc(sizeof(*head), GFP_KERNEL);
+	if (head == NULL)
+		return -ENOBUFS;
+
+	INIT_LIST_HEAD(&head->flist);
+	tp->root = head;
+	return 0;
+}
+
+/* Simple delete function called when filter is deleted */
+static inline void cgroup_delete_filter(struct tcf_proto *tp,
+				       struct cgroup_filter *f)
+{
+	tcf_unbind_filter(tp, &f->res);
+	tcf_exts_destroy(tp, &f->exts);
+	tcf_em_tree_destroy(tp, &f->ematches);
+	kfree(f);
+}
+
+/* Destroy the entire tp structure.*/
+static void cgroup_destroy(struct tcf_proto *tp)
+{
+	struct cgroup_head *head = (struct cgroup_head *) xchg(&tp->root, NULL);
+	struct cgroup_filter *f, *n;
+
+	list_for_each_entry_safe(f, n, &head->flist, link) {
+		list_del(&f->link);
+		cgroup_delete_filter(tp, f);
+	}
+	kfree(head);
+}
+
+/* Delete one filter entry */
+static int cgroup_delete(struct tcf_proto *tp, unsigned long arg)
+{
+	struct cgroup_head *head = (struct cgroup_head *) tp->root;
+	struct cgroup_filter *t, *f = (struct cgroup_filter *) arg;
+
+	list_for_each_entry(t, &head->flist, link)
+		if (t == f) {
+			tcf_tree_lock(tp);
+			list_del(&t->link);
+			tcf_tree_unlock(tp);
+			cgroup_delete_filter(tp, t);
+			return 0;
+		}
+
+	return -ENOENT;
+}
+
+/* Set the mask and value parameters in the tp structure. */
+static inline int cgroup_set_parms(struct tcf_proto *tp,
+			unsigned long base,
+			struct cgroup_filter *f, struct nlattr **tb)
+{
+	int err = -EINVAL;
+
+	if (tb[TCA_CGROUP_MASK]) {
+		if (nla_len(tb[TCA_CGROUP_MASK]) < sizeof(u32))
+			return err;
+		f->mask =  nla_get_u32(tb[TCA_CGROUP_MASK]);
+	} else
+		f->mask = UINT_MAX;
+
+	if (tb[TCA_CGROUP_VALUE]) {
+		if (nla_len(tb[TCA_CGROUP_VALUE]) < sizeof(u32))
+			return err;
+		f->value = nla_get_u32(tb[TCA_CGROUP_VALUE]);
+	} else
+		return err;
+
+	if (tb[TCA_CGROUP_CLASSID]) {
+		if (nla_len(tb[TCA_CGROUP_CLASSID]) < sizeof(u32))
+			return err;
+		f->res.classid = nla_get_u32(tb[TCA_CGROUP_CLASSID]);
+		tcf_bind_filter(tp, &f->res, base);
+	} else
+		return err;
+
+	return 0;
+}
+
+/* Change the mask and value parameters in the current settings. */
+static int cgroup_change(struct tcf_proto *tp, unsigned long base, u32 handle,
+				struct nlattr **tca, unsigned long *arg)
+{
+	int err = -EINVAL;
+	struct cgroup_head *head = (struct cgroup_head *) tp->root;
+	struct nlattr *tb[TCA_CGROUP_MAX];
+	struct cgroup_filter *f = (struct cgroup_filter *) *arg;
+	struct tcf_exts e;
+	struct tcf_ematch_tree t;
+
+	if (tca[TCA_OPTIONS] == NULL)
+		return -EINVAL;
+
+	if (nla_parse_nested(tb, TCA_CGROUP_MAX, tca[TCA_OPTIONS], NULL) < 0)
+		return -EINVAL;
+
+	err = tcf_exts_validate(tp, tb, tca[TCA_RATE], &e, &cgroup_ext_map);
+	if (err < 0)
+		return err;
+
+	err = tcf_em_tree_validate(tp, tb[TCA_CGROUP_EMATCHES], &t);
+	if (err < 0)
+		goto error1;
+
+	if (f != NULL) {
+		if (handle && f->handle != handle)
+			goto error2;
+	} else {
+		if (!handle)
+			goto error2;
+		f = kzalloc(sizeof(*f), GFP_KERNEL);
+		if (f == NULL)
+			goto error2;
+		f->handle = handle;
+	}
+
+	err = cgroup_set_parms(tp, base, f, tb);
+	if (err < 0)
+		goto error3;
+
+	tcf_exts_change(tp, &f->exts, &e);
+	tcf_em_tree_change(tp, &f->ematches, &t);
+
+	if (*arg == 0) {
+		tcf_tree_lock(tp);
+		list_add(&f->link, &head->flist);
+		tcf_tree_unlock(tp);
+	}
+
+	*arg = (unsigned long)f;
+	return 0;
+
+error3:
+	if (*arg == 0)
+		kfree(f);
+error2:
+	tcf_em_tree_destroy(tp, &t);
+error1:
+	tcf_exts_destroy(tp, &e);
+
+	return err;
+}
+
+/* Walk the filter list for things like displaying contents.*/
+static void cgroup_walk(struct tcf_proto *tp, struct tcf_walker *arg)
+{
+	struct cgroup_head *head = (struct cgroup_head *) tp->root;
+	struct cgroup_filter *f;
+
+	list_for_each_entry(f, &head->flist, link) {
+		if (arg->count < arg->skip)
+			goto skip;
+
+		if (arg->fn(tp, (unsigned long) f, arg) < 0) {
+			arg->stop = 1;
+			break;
+		}
+skip:
+		arg->count++;
+	}
+}
+
+/* Retreive current settings in the filter */
+static int cgroup_dump(struct tcf_proto *tp, unsigned long fh,
+		      struct sk_buff *skb, struct tcmsg *t)
+{
+	struct cgroup_filter *f = (struct cgroup_filter *) fh;
+	struct nlattr *nest;
+
+	if (f == NULL)
+		return skb->len;
+
+	t->tcm_handle = f->handle;
+
+	nest = nla_nest_start(skb, TCA_OPTIONS);
+	if (nest == NULL)
+		goto nla_put_failure;
+
+	NLA_PUT_U32(skb, TCA_CGROUP_CLASSID, f->res.classid);
+	NLA_PUT_U32(skb, TCA_CGROUP_MASK, f->mask);
+	NLA_PUT_U32(skb, TCA_CGROUP_VALUE, f->value);
+
+	if (tcf_exts_dump(skb, &f->exts, &cgroup_ext_map) < 0)
+		goto nla_put_failure;
+
+#ifdef CONFIG_NET_EMATCH
+	if (f->ematches.hdr.nmatches &&
+	  tcf_em_tree_dump(skb, &f->ematches, TCA_CGROUP_EMATCHES) < 0)
+		goto nla_put_failure;
+#endif
+
+	if (tcf_exts_dump_stats(skb, &f->exts, &cgroup_ext_map) < 0)
+		goto nla_put_failure;
+
+	nla_nest_end(skb, nest);
+	return skb->len;
+
+nla_put_failure:
+	nla_nest_cancel(skb, nest);
+	return -1;
+}
+
+static struct tcf_proto_ops cls_cgroup_ops = {
+	.kind		=	"cgroup",
+	.classify	=	cgroup_classify,
+	.init		=	cgroup_init,
+	.destroy	=	cgroup_destroy,
+	.get		=	cgroup_get,
+	.put		=	cgroup_put,
+	.change		=	cgroup_change,
+	.delete		=	cgroup_delete,
+	.walk		=	cgroup_walk,
+	.dump		=	cgroup_dump,
+	.owner		=	THIS_MODULE,
+};
+
+static int __init init_cgroup(void)
+{
+	return register_tcf_proto_ops(&cls_cgroup_ops);
+}
+
+static void __exit exit_cgroup(void)
+{
+	unregister_tcf_proto_ops(&cls_cgroup_ops);
+}
+
+module_init(init_cgroup)
+module_exit(exit_cgroup)
+MODULE_LICENSE("GPL");
+
diff --git a/net/socket.c b/net/socket.c
index 3e8d4e3..f71f4e7 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -87,7 +87,7 @@
 #include <linux/audit.h>
 #include <linux/wireless.h>
 #include <linux/nsproxy.h>
-
+#include <linux/cgroup_tc.h>
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
@@ -1173,6 +1173,8 @@ static int __sock_create(struct net *net, int family, int type, int protocol,
 	if (err < 0)
 		goto out_module_put;
 
+	cgroup_tc_set_sock_classid(sock->sk);
+
 	/*
 	 * Now to bump the refcnt of the [loadable] module that owns this
 	 * socket at sock_release time we decrement its refcnt.
@@ -1477,6 +1479,8 @@ long do_accept(int fd, struct sockaddr __user *upeer_sockaddr,
 	if (err < 0)
 		goto out_fd;
 
+	cgroup_tc_set_sock_classid(newsock->sk);
+
 	if (upeer_sockaddr) {
 		if (newsock->ops->getname(newsock, (struct sockaddr *)&address,
 					  &len, 2) < 0) {
-- 
1.5.5.1

