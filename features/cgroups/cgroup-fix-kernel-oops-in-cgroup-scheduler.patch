From 57020d67206a74a095fbf3f078f77d96d0966a93 Mon Sep 17 00:00:00 2001
From: Peter Seebach <peter.seebach@windriver.com>
Date: Wed, 18 Feb 2009 15:18:56 -0600
Subject: [PATCH] cgroup: fix kernel oops in cgroup scheduler

Analysis:  There are 37 instances of the string "struct nlattr *tb" in
net/sched.

36 of them have a size of the form [FOO_MAX + 1].

One of them does not.

When you use this one, the kernel sometimes crashes in really weird
ways.  The characteristic behavior is that a local variable which was
living in a register gets zeroed out.  How?  Simple!  The register is
callee-saved.  The callee-saved registers are stored on the stack.
The last register saved is saved lowest on the stack -- immediately
above this array.

nla_parse_nested calls
        memset(tb, 0, sizeof (struct nlattr *) * (maxtype + 1));

Signed-off-by: Peter Seebach <peter.seebach@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 net/sched/cls_cgroup.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/net/sched/cls_cgroup.c b/net/sched/cls_cgroup.c
index 70a363f..bc4e33e 100644
--- a/net/sched/cls_cgroup.c
+++ b/net/sched/cls_cgroup.c
@@ -183,7 +183,7 @@ static int cgroup_change(struct tcf_proto *tp, unsigned long base, u32 handle,
 {
 	int err = -EINVAL;
 	struct cgroup_head *head = (struct cgroup_head *) tp->root;
-	struct nlattr *tb[TCA_CGROUP_MAX];
+	struct nlattr *tb[TCA_CGROUP_MAX + 1];
 	struct cgroup_filter *f = (struct cgroup_filter *) *arg;
 	struct tcf_exts e;
 	struct tcf_ematch_tree t;
-- 
1.6.0.3

