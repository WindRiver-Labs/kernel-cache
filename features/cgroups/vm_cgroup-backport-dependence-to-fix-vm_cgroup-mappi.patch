From 0f459ca8958fa9540a5aaca0f133f811028788b3 Mon Sep 17 00:00:00 2001
From: He Zhe <zhe.he@windriver.com>
Date: Fri, 8 Aug 2014 09:20:36 +0800
Subject: [PATCH 4/7] vm_cgroup: backport dependence to fix vm_cgroup mappings
 accounting compile failure

Backport necessary dependence from v3.16-rc2 on which the original patch is
based on to fix compile failure.
 - Backport css_tryget_online and percpu_ref_tryget_live for
   get_vm_cgroup_from_task
 - Change vm_cgrp_id to vm_subsys_id which is generated by
   include/linux/cgroup.h

Signed-off-by: He Zhe <zhe.he@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 include/linux/cgroup.h          | 17 +++++++++++++++++
 include/linux/percpu-refcount.h | 33 +++++++++++++++++++++++++++++++++
 mm/vm_cgroup.c                  |  2 +-
 3 files changed, 51 insertions(+), 1 deletion(-)

diff --git a/include/linux/cgroup.h b/include/linux/cgroup.h
index 9450f025fe0c..b53d8043e296 100644
--- a/include/linux/cgroup.h
+++ b/include/linux/cgroup.h
@@ -121,6 +121,23 @@ static inline bool css_tryget(struct cgroup_subsys_state *css)
 }
 
 /**
+ * css_tryget_online - try to obtain a reference on the specified css if online
+ * @css: target css
+ *
+ * Obtain a reference on @css if it's online.  The caller naturally needs
+ * to ensure that @css is accessible but doesn't have to be holding a
+ * reference on it - IOW, RCU protected access is good enough for this
+ * function.  Returns %true if a reference count was successfully obtained;
+ * %false otherwise.
+ */
+static inline bool css_tryget_online(struct cgroup_subsys_state *css)
+{
+       if (css->flags & CSS_ROOT)
+               return true;
+       return percpu_ref_tryget_live(&css->refcnt);
+}
+
+/**
  * css_put - put a css reference
  * @css: target css
  *
diff --git a/include/linux/percpu-refcount.h b/include/linux/percpu-refcount.h
index 0afb48fd449d..35a242e24fbc 100644
--- a/include/linux/percpu-refcount.h
+++ b/include/linux/percpu-refcount.h
@@ -149,6 +149,39 @@ static inline bool percpu_ref_tryget(struct percpu_ref *ref)
 }
 
 /**
+ * percpu_ref_tryget_live - try to increment a live percpu refcount
+ * @ref: percpu_ref to try-get
+ *
+ * Increment a percpu refcount unless it has already been killed.  Returns
+ * %true on success; %false on failure.
+ *
+ * Completion of percpu_ref_kill() in itself doesn't guarantee that tryget
+ * will fail.  For such guarantee, percpu_ref_kill_and_confirm() should be
+ * used.  After the confirm_kill callback is invoked, it's guaranteed that
+ * no new reference will be given out by percpu_ref_tryget().
+ *
+ * The caller is responsible for ensuring that @ref stays accessible.
+ */
+static inline bool percpu_ref_tryget_live(struct percpu_ref *ref)
+{
+       unsigned __percpu *pcpu_count;
+       int ret = false;
+
+       rcu_read_lock_sched();
+
+       pcpu_count = ACCESS_ONCE(ref->pcpu_count);
+
+       if (likely(REF_STATUS(pcpu_count) == PCPU_REF_PTR)) {
+               this_cpu_inc(*pcpu_count);
+               ret = true;
+       }
+
+       rcu_read_unlock_sched();
+
+       return ret;
+}
+
+/**
  * percpu_ref_put - decrement a percpu refcount
  * @ref: percpu_ref to put
  *
diff --git a/mm/vm_cgroup.c b/mm/vm_cgroup.c
index 0d34ffcaf92e..10a24da2951a 100644
--- a/mm/vm_cgroup.c
+++ b/mm/vm_cgroup.c
@@ -28,7 +28,7 @@ static struct vm_cgroup *vm_cgroup_from_css(struct cgroup_subsys_state *s)
 
 static struct vm_cgroup *vm_cgroup_from_task(struct task_struct *p)
 {
-	return vm_cgroup_from_css(task_css(p, vm_cgrp_id));
+	return vm_cgroup_from_css(task_css(p, vm_subsys_id));
 }
 
 static struct vm_cgroup *get_vm_cgroup_from_task(struct task_struct *p)
-- 
1.8.1.2

