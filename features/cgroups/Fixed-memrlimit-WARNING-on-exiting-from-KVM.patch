From 7261aba2bde1201034db960019d322b516a68083 Mon Sep 17 00:00:00 2001
From: Shan Hai <shan.hai@windriver.com>
Date: Thu, 21 Oct 2010 21:09:17 -0700
Subject: [PATCH] Fixed memrlimit WARNING on exiting from KVM

This patch fixed a WARNING caused by memrlimit
on failure to charge address space usage on KVM user
space application, because memrlimit charges address
space usage on mmap() system call, but the KVM didn't
utilize mmap() to emulate memory.

Signed-off-by: Shan Hai <shan.hai@windriver.com>
---
 arch/x86/kvm/paging_tmpl.h |    8 ++++++++
 mm/memrlimitcgroup.c       |    2 ++
 2 files changed, 10 insertions(+), 0 deletions(-)

diff --git a/arch/x86/kvm/paging_tmpl.h b/arch/x86/kvm/paging_tmpl.h
index 4a814bf..236d97a 100644
--- a/arch/x86/kvm/paging_tmpl.h
+++ b/arch/x86/kvm/paging_tmpl.h
@@ -17,6 +17,8 @@
  *
  */
 
+#include <linux/memrlimitcgroup.h>
+
 /*
  * We need the mmu code to access both 32-bit and 64-bit guest ptes,
  * so the code in this file is compiled twice, once per pte size.
@@ -401,6 +403,12 @@ static int FNAME(page_fault)(struct kvm_vcpu *vcpu, gva_t addr,
 	 * The page is not mapped by the guest.  Let the guest handle it.
 	 */
 	if (!r) {
+		/* Charge the address space usage for KVM user space
+		 * process, because in KVM the address space usage
+		 * can not be charged on mmap() system call, for the
+		 * reason KVM did not emulate memory by mmap().
+		 */
+		memrlimit_cgroup_charge_as(current->mm, PAGE_SIZE);
 		pgprintk("%s: guest page fault\n", __func__);
 		inject_page_fault(vcpu, addr, walker.error_code);
 		vcpu->arch.last_pt_write_count = 0; /* reset fork detector */
diff --git a/mm/memrlimitcgroup.c b/mm/memrlimitcgroup.c
index ce2edb4..7b1f373 100644
--- a/mm/memrlimitcgroup.c
+++ b/mm/memrlimitcgroup.c
@@ -28,6 +28,7 @@
 #include <linux/fs.h>
 #include <linux/res_counter.h>
 #include <linux/memrlimitcgroup.h>
+#include <linux/module.h>
 
 struct cgroup_subsys memrlimit_cgroup_subsys;
 
@@ -70,6 +71,7 @@ int memrlimit_cgroup_charge_as(struct mm_struct *mm, unsigned long nr_pages)
 	memrcg = memrlimit_cgroup_from_task(mm->owner);
 	return res_counter_charge(&memrcg->as_res, (nr_pages << PAGE_SHIFT));
 }
+EXPORT_SYMBOL(memrlimit_cgroup_charge_as);
 
 /*
  * Uncharge the cgroup, as the address space of one of the tasks is
-- 
1.7.0.4

