From 19e6dc1b325d7ac81a17154bede2cf39657a572f Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Thu, 6 Nov 2014 16:54:34 -0800
Subject: [PATCH] fs: protect files_cgroup_count_fds call with spinlock

In openfiles control cgroup, the below call chain happens:
dup_fd
    -> files_cgroup_count_fds
        -> files_fdtable
But, any call to files_fdtable need to be protected by lock, otherwise the
below warning will be triggered with PROVE_RCU enabled:

===============================
[ INFO: suspicious RCU usage. ]
3.14.22-WR7.0.0.0_standard #5 Not tainted
===============================
linux/fs/filescontrol.c:87 suspicious rcu_dereference_check() usage!

other info that might help us debug this:

rcu_scheduler_active = 1, debug_locks = 1
no locks held by swapper/0/0.

stack backtrace:
CPU: 0 PID: 0 Comm: swapper/0 Not tainted 3.14.22-WR7.0.0.0_standard #5
Call Trace:
[c0000000010cb820] [c00000000000af68] .show_stack+0x168/0x278 (unreliable)
[c0000000010cb910] [c000000000af3970] .dump_stack+0x9c/0xfc
[c0000000010cb990] [c0000000000d641c] .lockdep_rcu_suspicious+0x108/0x168
[c0000000010cba20] [c000000000297df0] .files_cgroup_count_fds+0x114/0x150
[c0000000010cbab0] [c00000000023d4a4] .dup_fd+0x2c8/0x624
[c0000000010cbba0] [c0000000000672fc] .copy_process.part.46+0x780/0x1878
[c0000000010cbcd0] [c000000000068614] .do_fork+0xe8/0x8dc
[c0000000010cbdd0] [c000000000068e50] .kernel_thread+0x48/0x68
[c0000000010cbe60] [c0000000000021fc] .rest_init+0x3c/0x1dc
[c0000000010cbef0] [c000000000e99ba4] .start_kernel+0x544/0x564
[c0000000010cbf90] [c000000000000480] .start_here_common+0x24/0xa4

So, protect files_cgroup_count_fds call with spinlock.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 fs/file.c |    7 ++++++-
 1 files changed, 6 insertions(+), 1 deletions(-)

diff --git a/fs/file.c b/fs/file.c
index e615dc9..fe3c31b 100644
--- a/fs/file.c
+++ b/fs/file.c
@@ -250,6 +250,9 @@ struct files_struct *dup_fd(struct files_struct *oldf, int *errorp)
 	struct file **old_fds, **new_fds;
 	int open_files, size, i;
 	struct fdtable *old_fdt, *new_fdt;
+#ifdef CONFIG_CGROUP_FILES
+	u64 num_files;
+#endif
 
 	*errorp = -ENOMEM;
 	newf = kmem_cache_alloc(files_cachep, GFP_KERNEL);
@@ -345,7 +346,11 @@ struct files_struct *dup_fd(struct files_struct *oldf, int *errorp)
 	rcu_assign_pointer(newf->fdt, new_fdt);
 
 #ifdef CONFIG_CGROUP_FILES
-	if (!files_cgroup_alloc_fd(newf, files_cgroup_count_fds(newf)))
+	spin_lock(&newf->file_lock);
+	num_files = files_cgroup_count_fds(newf);
+	spin_unlock(&newf->file_lock);
+
+	if (!files_cgroup_alloc_fd(newf, num_files))
 		return newf;
 
 /* could not get enough FD resources.  Need to clean up. */
-- 
1.7.5.4

