From 44dae774b55950527c4a27ab51a374e7968d2d07 Mon Sep 17 00:00:00 2001
From: Liming Wang <liming.wang@windriver.com>
Date: Wed, 5 Nov 2008 17:27:42 +0800
Subject: [PATCH] fix cgroup memcontrol bug in preempt_rt

With preempt_rt enabled, bit_spin_lock has been changed.  This fix
makes the memcontrol use of bit_spin_lock to be compatible with
the preempt_rt version.

When calling mem_cgroup_move_lists(), kernel will access pointer
page->page_cgroup.  The page->page_cgroup should point to a struct
page_cgroup, but it doesn't; the value of page->page_cgroup is 1,
which leads to an oops.  

Call path looks like:
	page_assign_page_cgroup()
		->  mem_cgroup_charge_common()
			-> lock_page_cgroup()
				-> bit_spin_lock()

The preempt_rt bit_spin_lock will assign the last bit of
page->page_cgroup to 1. Then page_get_page_cgroup will return 1
(because PAGE_CGROUP_LOCK is 0 here). And then page_assign_page_cgroup
won't be called by mem_cgroup_charge_common.

To resolve this problem, PAGE_CGROUP_LOCK should be 1 with preempt_rt.
---
 include/linux/memcontrol.h |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/include/linux/memcontrol.h b/include/linux/memcontrol.h
index add5c33..3949b4b 100644
--- a/include/linux/memcontrol.h
+++ b/include/linux/memcontrol.h
@@ -39,7 +39,7 @@ struct mm_struct;
  * uniprocessor kernel, we should avoid setting it here too.
  */
 #define PAGE_CGROUP_LOCK_BIT    0x0
-#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)
+#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK) || defined(CONFIG_PREEMPT_RT)
 #define PAGE_CGROUP_LOCK        (1 << PAGE_CGROUP_LOCK_BIT)
 #else
 #define PAGE_CGROUP_LOCK        0x0
-- 
1.5.5.1

