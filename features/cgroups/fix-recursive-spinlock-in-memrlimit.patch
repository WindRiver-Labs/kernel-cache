From 107236a0eb0eb5b8ae7f65b2895bbfa0a76f28cb Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Mon, 15 Dec 2008 00:40:28 +0800
Subject: [PATCH] fix recursive spinlock in memrlimit

This patch is intened to fix recursive spinlock of task_lock involved
between memrlimit_cgroup_mm_owner_changed and mm_update_next_owner as
follows:
  exit_mm
    `--mm_update_next_owner (FIRST task_lock)
	  `--cgroup_mm_owner_callbacks
		`--mm_owner_changed(memrlimit_cgroup_mm_owner_changed)
					^^^^^^^^(SECOND task_lock)
  So the recursive report happens as follows callstack dump:

Process 7-1.test (pid: 8890, threadinfo=a80000000f1a0000, task=a80000000f085fd0,
 tls=000000002aac5480)
Stack : 0000000000000000 0000000000000000 0000000000000000 ffffffff80142adc
        ffffffff805ab068 0000000000000000 0000000000000000 ffffffff801c1804
        ffffffff8047a690 0000000000000000 0000000000000000 ffffffff80179c1c
        ffffffff8052c2e0 a80000000f92d700 a80000000f92d700 a80000000f92d760
        a80000000f086118 ffffffff80147f24 a80000000f086594 a80000000f085fd0
        a80000000f92d700 a80000000f92d760 0000000000000003 0000000000000400
        ffffffffffffffff 0000000000000200 0000000000000000 ffffffff80148108
        a80000000fb3b088 0000000000000400 0000000000000003 0000000000000200
        a80000000f085fd0 a80000000fb3b088 0000000000000400 ffffffff80149fbc
        a80000000f080db0 a80000000f080db0 a80000000fa21f40 0000000000000200
        ...
Call Trace:
[<ffffffff80111c70>] _spin_lock+0x20/0xb8
[<ffffffff80142adc>] get_task_mm+0x24/0xb0
[<ffffffff801c1804>] memrlimit_cgroup_mm_owner_changed+0x24/0x80
[<ffffffff80179c1c>] cgroup_mm_owner_callbacks+0xa4/0xd0
[<ffffffff80147f24>] mm_update_next_owner+0x23c/0x300
[<ffffffff80148108>] exit_mm+0x120/0x188
[<ffffffff80149fbc>] do_exit+0x16c/0x8a0
[<ffffffff8014a740>] do_group_exit+0x50/0xb8
[<ffffffff80102f04>] handle_sysn32+0x44/0x9c

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 mm/memrlimitcgroup.c |   28 +++++++++++++++++++---------
 1 files changed, 19 insertions(+), 9 deletions(-)

diff --git a/mm/memrlimitcgroup.c b/mm/memrlimitcgroup.c
index cc54b31..ce2edb4 100644
--- a/mm/memrlimitcgroup.c
+++ b/mm/memrlimitcgroup.c
@@ -223,17 +223,27 @@ static void memrlimit_cgroup_mm_owner_changed(struct cgroup_subsys *ss,
 						struct task_struct *p)
 {
 	struct memrlimit_cgroup *memrcg, *old_memrcg;
-	struct mm_struct *mm = get_task_mm(p);
+	struct mm_struct *mm = NULL;
 
-	BUG_ON(!mm);
-	memrcg = memrlimit_cgroup_from_cgrp(cgrp);
-	old_memrcg = memrlimit_cgroup_from_cgrp(old_cgrp);
+	if(p == NULL)
+		return;
+	if(p->flags & PF_KTHREAD) /* not user space mm */
+		return;
+	if((mm = p->mm) == NULL) /* insanity test */
+		return;
 
-	if (res_counter_charge(&memrcg->as_res, (mm->total_vm << PAGE_SHIFT)))
-		goto out;
-	res_counter_uncharge(&old_memrcg->as_res, (mm->total_vm << PAGE_SHIFT));
-out:
-	mmput(mm);
+	if(cgrp) {
+		memrcg = memrlimit_cgroup_from_cgrp(cgrp);
+		if (res_counter_charge(&memrcg->as_res, (mm->total_vm << PAGE_SHIFT)))
+			return;
+	}
+
+	if(old_cgrp){
+		old_memrcg = memrlimit_cgroup_from_cgrp(old_cgrp);
+		res_counter_uncharge(&old_memrcg->as_res, (mm->total_vm << PAGE_SHIFT));
+	}
+
+	return ;
 }
 
 struct cgroup_subsys memrlimit_cgroup_subsys = {
-- 
1.6.0.2.GIT

