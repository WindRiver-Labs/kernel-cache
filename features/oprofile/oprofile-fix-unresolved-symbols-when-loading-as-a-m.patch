From 058185236903b3ab95b1f53f0717b09401896e39 Mon Sep 17 00:00:00 2001
From: Dave Lerner <Dave.Lerner@windriver.com>
Date: Mon, 1 Jun 2009 14:16:46 -0700
Subject: [PATCH] oprofile: fix unresolved symbols when loading as a module

Use a structure to hold the system call return addresses
which are used by oprofile backtrace during syscall unwinding.
The structure address values are set by code in the x86/kernel
directory, and this will always be built-in when oprofile is enabled.
When oprofile is built as a module, the syscall return addresses
are available through this structure.  The syscall return
addresses are not simply EXPORT'd for security reasons.

Signed-off-by: Dave Lerner <dave.lerner@windriver.com>
---
 arch/x86/kernel/Makefile                 |    4 +++
 arch/x86/kernel/oprofile_sysret_lookup.c |   31 +++++++++++++++++++++++++
 arch/x86/kernel/oprofile_sysret_lookup.h |   37 ++++++++++++++++++++++++++++++
 arch/x86/oprofile/backtrace.c            |   29 ++++++++++-------------
 4 files changed, 85 insertions(+), 16 deletions(-)
 create mode 100644 arch/x86/kernel/oprofile_sysret_lookup.c
 create mode 100644 arch/x86/kernel/oprofile_sysret_lookup.h

diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index 257478f..f413dc6 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -105,6 +105,10 @@ obj-$(CONFIG_OLPC)		+= olpc.o
 obj-$(CONFIG_HAVE_PSRWLOCK_ASM_CALL)	+= call_64.o
 obj-$(CONFIG_HAVE_PSRWLOCK_ASM_CALL)	+= call_export_64.o
 
+ifdef CONFIG_OPROFILE
+	obj-y	+= oprofile_sysret_lookup.o
+endif
+
 ###
 # 64 bit specific files
 ifeq ($(CONFIG_X86_64),y)
diff --git a/arch/x86/kernel/oprofile_sysret_lookup.c b/arch/x86/kernel/oprofile_sysret_lookup.c
new file mode 100644
index 0000000..edfaff1
--- /dev/null
+++ b/arch/x86/kernel/oprofile_sysret_lookup.c
@@ -0,0 +1,31 @@
+/**
+ * @file oprofile_sysret_lookup.c
+ *
+ * @remark Copyright 2009 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author Dave Lerner
+ */
+
+#include <linux/module.h>
+#include "oprofile_sysret_lookup.h"
+
+static struct oprofile_sysret_lookup osl;
+
+struct oprofile_sysret_lookup *init_oprofile_sysret(void)
+{
+	osl.system_call_done = system_call_done;
+
+#if defined(CONFIG_X86_64)
+	osl.tracesys_done = tracesys_done;
+#elif defined(CONFIG_X86_32)
+	osl.ia32_sysenter_done = ia32_sysenter_done;
+#endif
+#if defined(CONFIG_IA32_EMULATION)
+	osl.ia32_syscall_done = ia32_syscall_done;
+	osl.ia32_cstar_done = ia32_cstar_done;
+	osl.ia32_sysenter_done = ia32_sysenter_done;
+#endif
+	return &osl;
+}
+EXPORT_SYMBOL(init_oprofile_sysret);
diff --git a/arch/x86/kernel/oprofile_sysret_lookup.h b/arch/x86/kernel/oprofile_sysret_lookup.h
new file mode 100644
index 0000000..28d672d
--- /dev/null
+++ b/arch/x86/kernel/oprofile_sysret_lookup.h
@@ -0,0 +1,37 @@
+/**
+ * @file oprofile_sysret_lookup.h
+ *
+ * @remark Copyright 2009 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author Dave Lerner <dave.lerner@windriver.com>
+ */
+
+#ifndef OPROFILE_SYSRET_LOOKUP_H
+#define OPROFILE_SYSRET_LOOKUP_H
+
+/* These are defined in scall_xx.S files and the addresses are
+ * tested against candidate addresses to determine if
+ * a system call frame has been found.
+ */
+extern void system_call_done(void);
+extern void tracesys_done(void);
+extern void ia32_syscall_done(void);
+extern void ia32_sysenter_done(void);
+extern void ia32_cstar_done(void);
+
+
+
+struct oprofile_sysret_lookup{
+	void (*system_call_done)(void);
+	void (*tracesys_done)(void);
+	void (*ia32_syscall_done)(void);
+	void (*ia32_sysenter_done)(void);
+	void (*ia32_cstar_done)(void);
+};
+
+
+/* initialized during first backtrace */
+extern struct oprofile_sysret_lookup *init_oprofile_sysret(void);
+
+#endif /* OPROFILE_SYSRET_LOOKUP_H */
diff --git a/arch/x86/oprofile/backtrace.c b/arch/x86/oprofile/backtrace.c
index 6f3ee44..16bf52e 100644
--- a/arch/x86/oprofile/backtrace.c
+++ b/arch/x86/oprofile/backtrace.c
@@ -15,6 +15,9 @@
 #include <asm/uaccess.h>
 #include <asm/stacktrace.h>
 #include <asm/proto.h>
+#include "../kernel/oprofile_sysret_lookup.h"
+
+static struct oprofile_sysret_lookup *op_sysret;
 
 struct backtrace_data {
 	/* user input to enable kernel-syscall-userland tracing */
@@ -134,24 +137,13 @@ static inline void set_basepointer(unsigned long sp,
 	bt_data->bp = frame_pointer(regs);
 }
 
-#if defined(CONFIG_OPROFILE_MODULE)
-/*
- * This causes system call traversal to fail, but the only other choice 
- * for oprofile as module is to export some dangerous symbols
- */
-void system_call_done(void) {}
-void tracesys_done(void) {} 
-void ia32_syscall_done(void) {}
-void ia32_sysenter_done(void) {}
-void ia32_cstar_done(void) {}
-#endif
-
 #if defined(CONFIG_X86_64)
 static inline void in_x86_64_syscall_frame(
 	void (*addr)(void), unsigned long sp,
 	struct backtrace_data *bt_data)
 {
-	if ((addr == system_call_done) || (addr == tracesys_done))
+	if ((addr == op_sysret->system_call_done)
+	|| (addr == op_sysret->tracesys_done))
 		set_basepointer(sp, bt_data);
 }
 #endif
@@ -161,8 +153,9 @@ static inline void in_ia32_syscall_frame(
 	void (*addr)(void), unsigned long sp,
 	struct backtrace_data *bt_data)
 {
-	if ((addr == ia32_syscall_done) || (addr == ia32_cstar_done)
-		|| (addr == ia32_sysenter_done))
+	if ((addr == op_sysret->ia32_syscall_done)
+	|| (addr == op_sysret->ia32_cstar_done)
+	|| (addr == op_sysret->ia32_sysenter_done))
 		set_basepointer(sp, bt_data);
 }
 #endif
@@ -172,7 +165,8 @@ static inline void in_x86_32_syscall_frame(
 	void (*addr)(void), unsigned long sp,
 	struct backtrace_data *bt_data)
 {
-	if ((addr == system_call_done) || (addr == ia32_sysenter_done))
+	if ((addr == op_sysret->system_call_done)
+	|| (addr == op_sysret->ia32_sysenter_done))
 		set_basepointer(sp, bt_data);
 }
 #endif
@@ -210,6 +204,9 @@ x86_backtrace(struct pt_regs * const regs, unsigned int depth)
 		.bp = 0,
 	};
 
+	if (unlikely(op_sysret == 0))
+		op_sysret = init_oprofile_sysret();
+
 	bt_data.syscall_frame_test = SYSCALL_FRAME_TEST;
 
 	if (!user_mode_vm(regs)) {
-- 
1.6.0.4

