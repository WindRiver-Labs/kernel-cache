From 50e97014f92def039bb2ff6af11f79e5bae17100 Mon Sep 17 00:00:00 2001
From: Dave Lerner <Dave.Lerner@windriver.com>
Date: Sun, 1 Nov 2009 11:08:08 -0800
Subject: [PATCH] oprofile/mips 64: fix oprofile backtrace

Modifications to support n64 oprofile backtrace by
- removing the incorrect assumption that frame pointers
preserve the stack pointer in an n32 or n64 function prolog,
by setting RTITOOLS_CONTEXT_USES_FP to 0 and using that
conditional correctly,

- including n64 daddiu/daddi opcodes as instructions that
indicate an epilog has been found,

- generalizing __will_fault detection so that it can
work for both 32 and 64 bit kernels, 32 and 64 bit user apps,

Signed-off-by: Dave Lerner <dave.lerner@windriver.com>
---
 arch/mips/oprofile/backtrace.c    |    4 ---
 arch/mips/oprofile/mem_validate.h |    2 +-
 arch/mips/oprofile/mips_context.h |   10 ++++---
 arch/mips/oprofile/mips_crawl.c   |   55 +++++++++++++++++--------------------
 4 files changed, 32 insertions(+), 39 deletions(-)

diff --git a/arch/mips/oprofile/backtrace.c b/arch/mips/oprofile/backtrace.c
index 4423f75..5f5314c 100644
--- a/arch/mips/oprofile/backtrace.c
+++ b/arch/mips/oprofile/backtrace.c
@@ -125,9 +125,7 @@ void op_user_backtrace(struct pt_regs *const regs, unsigned int *depth)
 	unsigned long pc_sample;
 	child.pc = (void *)regs->cp0_epc;
 	child.sp = (void *)regs->regs[REG_SP];
-	child.fp = (void *)regs->regs[REG_S8];
 	child.gpregs[BT_REG_SP] = regs->regs[REG_SP];
-	child.gpregs[BT_REG_FP] = regs->regs[REG_S8];
 	child.gpregs[BT_REG_LR] = regs->regs[REG_RA];
 	/*  child could be a leaf, impacting frame_crawl */
 	child.leaf = true;
@@ -150,9 +148,7 @@ void op_user_backtrace(struct pt_regs *const regs, unsigned int *depth)
 		oprofile_add_trace(pc_sample);
 		child.pc = parent.pc;
 		child.sp = parent.sp;
-		child.fp = parent.fp;
 		child.gpregs[BT_REG_SP] = (unsigned long)parent.sp;
-		child.gpregs[BT_REG_FP] = (unsigned long)parent.fp;
 		child.leaf = 0;
 		have_gprs = 0;
 		if (pc_sample == BACKTRACE_ABORTED)
diff --git a/arch/mips/oprofile/mem_validate.h b/arch/mips/oprofile/mem_validate.h
index a307b56..9cae3ba 100644
--- a/arch/mips/oprofile/mem_validate.h
+++ b/arch/mips/oprofile/mem_validate.h
@@ -153,7 +153,7 @@ static inline void *instruction(const void const *pc, struct memory_access_data
   */
 static inline bool SPOk(const void *const sp, crawl_validation *validation)
 {
-	return !__will_fault(sp, sizeof(*sp));
+	return !__will_fault(sp, sizeof(sp));
 }
 
 #endif /* _MEM_VALIDATE_H_ */
diff --git a/arch/mips/oprofile/mips_context.h b/arch/mips/oprofile/mips_context.h
index e172ee2..20ef131 100644
--- a/arch/mips/oprofile/mips_context.h
+++ b/arch/mips/oprofile/mips_context.h
@@ -116,14 +116,16 @@ typedef unsigned long tAddr;	/* Address type */
  */
 #define INST_UNKNOWN       (0xffffffff)
 
-#define INST_ADD_TO_SP     (0x23bd0000)	/* addi/addiu sp,sp,immed */
+#define INST_ADD_TO_SP     (0x23bd0000)	/* (d)addi/(d)addiu sp,sp,immed */
 #define MASK_ADD_OFFSET    (0x0000ffff)	/* Signed 16-bit offset added to SP */
 #define MASK_NEG_OFFSET    (0x00008000)
 #define NEG_SIGN_EXTEND     0xffff0000
-#define MASK_ADD_OPCODE    (0xfbff0000)	/* ignore addi/addiu differences */
+#define MASK_ADD_OPCODE    (0xbbff0000)	/* ignore (d)addi/(d)addiu diffs */
 
 #define MASK_OPCODE         0xfc000000	/* MIPS major op codes are 1st 6 bits */
-#define INST_ADDIU          0x24000000	/* addiu rd,rs,immed */
+#define INST_ADDIU_32       0x24000000	/* addiu rd,rs,immed */
+#define INST_ADDIU_64       0x64000000	/* daddiu rd,rs,immed */
+#define MASK_ADDIU_OPCODE   0xbc000000	/* ignore daddiu/addiu diffs */
 #define INST_LUI            0x3c000000	/* lui   rd,immed    */
 
 #define MASK_BASIC_OPCODE   0xfc0007ff	/* add, sub, mult, div, jr, mov, etc. */
@@ -201,7 +203,7 @@ typedef unsigned long tAddr;	/* Address type */
 #define RTITOOLS_CONTEXT_CHECK_TOP_LAST         (0)
 
 #define RTITOOLS_CONTEXT_USES_SP  (1)	/* Does context package use sp? */
-#define RTITOOLS_CONTEXT_USES_FP  (1)	/* Does context package use fp? */
+#define RTITOOLS_CONTEXT_USES_FP  (0)	/* Does context package use fp? */
 
 /* Register numbers for op_context */
 enum register_name {
diff --git a/arch/mips/oprofile/mips_crawl.c b/arch/mips/oprofile/mips_crawl.c
index 61e38c2..ba03e5e 100644
--- a/arch/mips/oprofile/mips_crawl.c
+++ b/arch/mips/oprofile/mips_crawl.c
@@ -215,7 +215,6 @@ long double     64 (128 in n32)     128
  *-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
 int op_context_debug_output; /* = 0 */
 
-#if defined(CONFIG_64BIT)
 
 /*
  * Make a page fault or else prove we won't.  Tool used by PCOk and SPOk
@@ -237,11 +236,11 @@ int __will_fault(const void *const address, size_t size)
 
 	switch (size) {
 	case 4:
-		if (__get_user_nocheck(t, (unsigned int *)address, 4))
+		if (__get_user_nocheck(t, (uint32_t *)address, 4))
 			goto done;
 		break;
 	case 8:
-		if (__get_user_nocheck(t, (unsigned long *)address, 8))
+		if (__get_user_nocheck(t, (uint64_t *)address, 8))
 			goto done;
 		 break;
 	default:
@@ -252,21 +251,6 @@ int __will_fault(const void *const address, size_t size)
 done:
 	return ret;
 }
-#else
-
-/*
- * Make a page fault or else prove we won't.  Tool used by PCOk and SPOk
- * Return 0 if no page fault, 1 if page fault happened
- */
-int __will_fault(const void *const address, size_t size)
-{
-	long dst;
-	if (probe_kernel_read(&dst, (void *)address, sizeof(long)) != 0)
-		return 1;	/* page fault or address error */
-	return 0;
-}
-
-#endif
 
 
 /**
@@ -326,7 +310,9 @@ bool op_frame_crawl(void *startpc,
 	/* most clauses don't use the frame pointer, so by default we mark it as
 	   untracked for the current frame. */
 
+#if RTITOOLS_CONTEXT_USES_FP
 	res_frame->fpLocation.location = LOCATION_UNUSED;
+#endif
 
 	/*
 	 * walk forward from the vicinity of the PC to determine
@@ -353,8 +339,10 @@ resumeFwdSearch:
 		 * ld    ra,offset(sp)  [64-bit regs]
 		 * ... [restore other registers]
 		 * addiu sp,sp,positiveamount
+		 *    OR
+		 * daddiu sp,sp,positiveamount  [64-bit regs]
 		 * jr    ra
-		 * ... [possibly addiu sp,sp,positiveamount] ...
+		 * ... [possibly [d]addiu sp,sp,positiveamount] ...
 		 */
 
 		/*--- lw  ra,offset(sp)
@@ -374,14 +362,7 @@ resumeFwdSearch:
 			if ((curInst & MASK_SWLW_OPCODE) == INST_RESTORE_RA_32) {
 				d2printf("  %p: lw ra,0x%lx(sp)\n", pcCur,
 					 offset);
-			}
-			/* MIPS64 BE has this -- we need to offset by a 32-bit
-			 * register width to get the least significant 32 bits
-			 * of the address because VxWorks currently supports
-			 * only 32-bit addresses.
-			 */
-			if ((curInst & MASK_SWLW_OPCODE) == INST_RESTORE_RA_64) {
-				res_frame->pcLocation.offset += REGISTER_OFFSET;
+			} else {
 				d2printf("  %p: ld ra,0x%lx(sp)\n", pcCur,
 					 res_frame->pcLocation.offset);
 			}
@@ -411,7 +392,8 @@ resumeFwdSearch:
 			    *(uint32_t *) instruction(pcCur + 2, client_arg);
 
 			if (((nextInst & MASK_JUMP_OPCODE) == INST_J) &&
-			    ((nextNextInst & MASK_OPCODE) == INST_ADDIU)) {
+			    (((nextNextInst & MASK_OPCODE) == INST_ADDIU_32) ||
+			     ((nextNextInst & MASK_OPCODE) == INST_ADDIU_64))) {
 				location_set_reg_off(&res_frame->spLocation,
 						     BT_REG_SP,
 						     nextNextInst &
@@ -426,6 +408,7 @@ resumeFwdSearch:
 			continue;
 		}
 
+#if RTITOOLS_CONTEXT_USES_FP
 		/*--- move sp,fp
 		 * restoring intermediate sp from fp
 		 */
@@ -453,6 +436,7 @@ resumeFwdSearch:
 			}
 			continue;
 		}
+#endif
 
 		/*--- jr ra
 		 * End of routine.
@@ -549,6 +533,7 @@ resumeFwdSearch:
 						break;
 					}
 
+#if RTITOOLS_CONTEXT_USES_FP
 					/*--- lw  fp,+d(sp)
 					 * restoration of stack frame pointer
 					 * register from stack
@@ -572,6 +557,7 @@ resumeFwdSearch:
 						}
 						continue;
 					}
+#endif
 
 					/* find PC if not already known */
 					if ((res_frame->pcLocation.location ==
@@ -749,6 +735,7 @@ resumeFwdSearch:
 					 * the SP will have an absolute location and its offset
 					 * will be adjusted by any addiu value.
 					 */
+#if RTITOOLS_CONTEXT_USES_FP
 					if ((travInst == INST_SP_TO_FP)
 					    && ((i - j) != 0)) {
 						fpBeingUsed = true;
@@ -783,6 +770,7 @@ resumeFwdSearch:
 						}
 						continue;
 					}
+#endif
 
 					if ((travInst & MASK_ADD_OPCODE) ==
 					    INST_ADD_TO_SP) {
@@ -1093,8 +1081,9 @@ resumeFwdSearch:
 
 				if (((localPrevInst[0] & MASK_BASIC_OPCODE) ==
 				     INST_ADDU)
-				    && ((localPrevInst[1] & MASK_OPCODE) ==
-					INST_ADDIU)
+				    && ((localPrevInst[1]
+						& MASK_ADDIU_OPCODE) ==
+							INST_ADDIU_32)
 				    && ((localPrevInst[2] & MASK_OPCODE) ==
 					INST_LUI) && (curInst == INST_NOP)
 				    && ((nextInst[0] & MASK_BRANCH_OPCODE) ==
@@ -1270,7 +1259,9 @@ follow_branch:
 		/* most clauses don't use the frame pointer, so by default we
 		 * mark it as untracked for the current frame.
 		 */
+#if RTITOOLS_CONTEXT_USES_FP
 		res_frame->fpLocation.location = LOCATION_UNUSED;
+#endif
 
 		pcCurStart = startpc;
 		d2printf("< %p: Begin reverse search\n", pcCurStart);
@@ -1300,6 +1291,7 @@ follow_branch:
 			 * ...
 			 */
 
+#if RTITOOLS_CONTEXT_USES_FP
 			/*--- move fp,sp  [move s8,sp]
 			 * This signals that the fp is being used in this
 			 * routine and we must use it also, but only if we
@@ -1338,6 +1330,7 @@ follow_branch:
 				}
 				continue;
 			}
+#endif
 
 			/*--- SW  ra,offset(sp)
 			 *    SD  ra,offset(sp)
@@ -1383,6 +1376,7 @@ follow_branch:
 					travInst =
 					    *(tInst *) instruction(pcCur - j,
 								   client_arg);
+#if RTITOOLS_CONTEXT_USES_FP
 					/*--- sw  fp,+d(sp)
 					 * Storing of stack frame pointer register on stack.
 					 * If we started here, fp is not yet on stack.
@@ -1406,6 +1400,7 @@ follow_branch:
 						}
 						continue;
 					}
+#endif
 
 					if ((travInst & MASK_ADD_OPCODE) ==
 					    INST_ADD_TO_SP) {
-- 
1.6.5.2

