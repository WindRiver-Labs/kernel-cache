From ddf69da287cfc7c085ddf0d5a817d0a874a7e822 Mon Sep 17 00:00:00 2001
From: Dave Lerner <Dave.Lerner@windriver.com>
Date: Wed, 21 Jan 2009 13:21:47 -0600
Subject: [PATCH 11/21] Fix page faults, incorrect syscall traces in oprofile

The patch replaces the system call frame detection logic to correct the
discovery of system call frames when backtracing in the kernel.  The original
algorithm assumed that if the sp was not a valid kernel stack pointer and
the instruction pointer was within bounds of certain system call handlers,
then a valid system call was found.  This did not take account for other
entry methods into the entry_xx.S common syscall code.

The new algorithm that detects the stack frame in kernel_getsp()
replaces the pc test with:
1) a test for a frame marker in the stack (if supported by variant),
2) a test for an expected value of the stack pointer when in the
   system call frame, and
3) a test to make sure that the code is entered via system call instructions
   rather than other exceptions, by testing the saved pt_regs->trap value.

Also included is a fix to capture one additional user space trace previously
lost in the earlier algorithm.

Signed-off-by: Zhenghui(Sam) Liao <zhenghui.liao@windriver.com>
Signed-off-by: Dave.Lerner<Dave.Lerner@windriver.com>
---
 arch/powerpc/oprofile/backtrace.c |   81 +++++++++++++++++++++++-------------
 1 files changed, 52 insertions(+), 29 deletions(-)
 mode change 100644 => 100755 arch/powerpc/oprofile/backtrace.c

diff --git a/arch/powerpc/oprofile/backtrace.c b/arch/powerpc/oprofile/backtrace.c
old mode 100644
new mode 100755
index 2eba5e9..3117ffe
--- a/arch/powerpc/oprofile/backtrace.c
+++ b/arch/powerpc/oprofile/backtrace.c
@@ -25,6 +25,13 @@
 #define STACK_LR(STACK)		STACK_LR32(STACK)
 #endif
 
+#if (defined(CONFIG_PPC_STD_MMU) || defined(CONFIG_PPC64))
+#define HAS_FRAME_MARKER(stack_frame) \
+	(stack_frame[STACK_FRAME_MARKER] == STACK_FRAME_REGS_MARKER)
+#else
+#define HAS_FRAME_MARKER(stack_frame) (1)
+#endif
+
 static unsigned int user_getsp32(unsigned int sp, int is_first)
 {
 	unsigned int stack_frame[2];
@@ -70,39 +77,55 @@ static unsigned long user_getsp64(unsigned long sp, int is_first)
 }
 #endif
 
-static unsigned long kernel_getsp(unsigned long sp, unsigned long child_sp,
-		int is_first, int trace_sys, unsigned long *user_frame_sp)
+/*
+ * If trace_sys is set (set through user command opcontrol
+ * --enhanced-backtrace), then in addition to logging
+ * the kernel trace, the function checks if the next
+ * stack frame up the stack is a system call frame.  If so, then
+ * return variables are set to permit tracing through user space.
+ *
+ * Both for the ppc32 and ppc64, when user apps make a syscall,
+ * the following setup is done
+ *   - current registers pt_regs struct saved at the top of
+ *     process's  kernel stack space,
+ *   - pt_regs trap value set to 0xc00 or 0xc01,
+ *   - CONFIG_PPC64 and  CONFIG_PPC32_STD_MMU markers are set on stack
+ *     distinguish exception handler gap in call trace during
+ *     unwinding
+ *   - sp set to (sizeof(struct pt_regs) + STACK_FRAME_OVERHEAD)
+ *
+ * These conditions are checked and if found, then the user stack frame
+ * and the user instruction pointer are returned to the caller from
+ * the pt_regs pointer, which was saved at the discovered
+ * syscall stack frame.
+ *
+ * Finally the routine returns the next frame to the caller.
+ */
+static unsigned long kernel_getsp(unsigned long sp, int is_first,
+	int trace_sys, unsigned long *user_frame_sp, unsigned long *user_ip)
 {
 	unsigned long *stack_frame = (unsigned long *)sp;
+	struct pt_regs *regs;
 
 	if (!validate_sp(sp, current, STACK_FRAME_OVERHEAD)) {
-		if (trace_sys)
-			return 0;
-
-		if (child_sp) {
-			unsigned long *frame = (unsigned long *)child_sp;
-			/* check if last frame in a syscall */
-			unsigned long pc = STACK_LR(frame);
-#ifdef CONFIG_PPC64
-			if (pc >= (unsigned long)system_call_common
-				&& pc <= (unsigned long)save_nvgprs)
-#else
-			if (pc >= (unsigned long)DoSyscall
-				&& pc <= (unsigned long)handle_page_fault)
-#endif
-			{
-				struct pt_regs *user_regs;
-				user_regs = ((struct pt_regs *) ((unsigned long)
-						task_thread_info(current)
-						+ THREAD_SIZE)) - 1;
-				*user_frame_sp = user_regs->gpr[1];
-				return 1; /* syscall traversal*/
-			}
-		}
 		return 0;
 	}
 	if (!is_first)
 		oprofile_add_trace(STACK_LR(stack_frame));
+
+	/* syscall frame */
+	if (trace_sys && HAS_FRAME_MARKER(stack_frame)) {
+		if (sp == ((unsigned long)task_stack_page(current) + THREAD_SIZE
+			     - STACK_FRAME_OVERHEAD - sizeof(struct pt_regs))) {
+			regs = (struct pt_regs *) (sp + STACK_FRAME_OVERHEAD);
+			if (regs->trap == 0xc01 || regs->trap == 0xc00) {
+				*user_frame_sp = regs->gpr[1];
+				*user_ip = regs->nip;
+				return 1;
+			}
+			return 0;
+		}
+	}
 	/*
 	 * We do not enforce increasing stack addresses here because
 	 * we might be transitioning from an interrupt stack to a kernel
@@ -122,23 +145,23 @@ void op_powerpc_backtrace(struct pt_regs * const regs, unsigned int depth)
 	depth += 1;
 
 	if (!user_mode(regs)) {
-		unsigned long child_sp = 0;
 		unsigned long parent_sp = 0;
 		unsigned long user_frame_sp = 0;
+		unsigned long user_ip = 0;
 		while (depth--) {
-			parent_sp = kernel_getsp(sp, child_sp,
-				first_frame, trace_syscall, &user_frame_sp);
+			parent_sp = kernel_getsp(sp, first_frame,
+				 trace_syscall, &user_frame_sp, &user_ip);
 			if (!parent_sp)
 				return; /* not in syscall*/
 			if (parent_sp == 1) { /* in a syscall boundary*/
 				if (oprofile_syscall_trace_boundary()) {
+					oprofile_add_trace(user_ip);
 					sp = user_frame_sp;
 					break;
 				}
 				return;
 			}
 			first_frame = 0;
-			child_sp = sp;
 			sp = parent_sp;
 		}
 	}
-- 
1.6.5.2

