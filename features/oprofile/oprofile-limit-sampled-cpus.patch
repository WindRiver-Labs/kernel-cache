From b00306527c9289d0c3cc8983ba1cfdc41a2ed944 Mon Sep 17 00:00:00 2001
From: Hong H. Pham <hong.pham@windriver.com>
Date: Thu, 16 Apr 2009 13:56:27 +0800
Subject: [PATCH] oprofile: limit sampled cpus

On systems with lots of processors, oprofile may not able to sample all
processors due to bandwidth limitations.  This patch provides a new
oprofilefs control file, sampled_cpus, to select which CPUs get sampled as
a work around.

Reading from the sampled_cpus control file returns a list of CPUs selected
for sampling.  By default, all online CPUs are sampled (example from
Sun Netra T-5440):

  # mount none /mnt/oprofile -t oprofilefs
  # cd /mnt/oprofile
  # cat sampled_cpus
  0-47,72-119

Writing to the sampled_cpus control file selects the CPUs for oprofile to
sample.  The sampled_cpus control file accepts a comma delimited list of
CPUs or CPU range (which must be specified in ascending order).  For example,
the following are valid values for sampled_cpus:

  # echo 0 > sampled_cpus
  # echo 0,1,2,3,4,5,6,7 > sampled_cpus
  # echo 0-7 > sampled_cpus
  # echo 1,4-7 > sampled_cpus
  # echo 0-2,4-7 > sampled_cpus

Processes of interest for profiling should have their CPU affinity set to
include only CPUs that are in sampled_cpus.  The process's CPU affinity could
be set on the command line with the taskset command (part of util-linux)
or with the kernel's cpuset feature.  A detailed description of cpuset
could be found in linux/Documentation/cpusets.txt.

Signed-off-by: Vu Tran <vu.tran@windriver.com>
Signed-off-by: Hong H. Pham <hong.pham@windriver.com>
---
 drivers/oprofile/cpu_buffer.c     |    7 +++++
 drivers/oprofile/oprof.h          |    1 +
 drivers/oprofile/oprofile_files.c |   35 ++++++++++++++++++++++++++++
 drivers/oprofile/oprofilefs.c     |   46 +++++++++++++++++++++++++++++++++++++
 include/linux/oprofile.h          |   15 ++++++++++++
 5 files changed, 104 insertions(+), 0 deletions(-)

diff --git a/drivers/oprofile/cpu_buffer.c b/drivers/oprofile/cpu_buffer.c
index bd98892..87d40f9 100644
--- a/drivers/oprofile/cpu_buffer.c
+++ b/drivers/oprofile/cpu_buffer.c
@@ -250,8 +250,15 @@ void oprofile_add_sample(struct pt_regs * const regs, unsigned long event)
 {
 	int is_kernel = !user_mode(regs);
 	unsigned long pc = profile_pc(regs);
+	unsigned int this_cpu = get_cpu();
+
+	if (!cpu_isset(this_cpu, fs_sampled_cpus)) {
+		put_cpu();
+		return;
+	}
 
 	oprofile_add_ext_sample(pc, regs, event, is_kernel);
+	put_cpu();
 }
 
 void oprofile_add_pc(unsigned long pc, int is_kernel, unsigned long event)
diff --git a/drivers/oprofile/oprof.h b/drivers/oprofile/oprof.h
index da7dee0..44fe53a 100644
--- a/drivers/oprofile/oprof.h
+++ b/drivers/oprofile/oprof.h
@@ -24,6 +24,7 @@ struct oprofile_operations;
 extern unsigned long fs_buffer_size;
 extern unsigned long fs_cpu_buffer_size;
 extern unsigned long fs_buffer_watershed;
+extern cpumask_t fs_sampled_cpus;
 extern struct oprofile_operations oprofile_ops;
 extern unsigned long oprofile_started;
 extern unsigned long backtrace_depth;
diff --git a/drivers/oprofile/oprofile_files.c b/drivers/oprofile/oprofile_files.c
index 3170159..38da35d 100644
--- a/drivers/oprofile/oprofile_files.c
+++ b/drivers/oprofile/oprofile_files.c
@@ -17,6 +17,7 @@
 unsigned long fs_buffer_size = 131072;
 unsigned long fs_cpu_buffer_size = 8192;
 unsigned long fs_buffer_watershed = 32768; /* FIXME: tune */
+cpumask_t fs_sampled_cpus;
 
 static ssize_t depth_read(struct file * file, char __user * buf, size_t count, loff_t * offset)
 {
@@ -159,6 +160,37 @@ static const struct file_operations enhanced_backtrace_fops = {
 };
 
 
+static ssize_t sampled_cpus_read(struct file *file,
+		char __user *buf, size_t count, loff_t *offset)
+{
+	return oprofilefs_cpulist_to_user(&fs_sampled_cpus, buf, count, offset);
+}
+
+
+static ssize_t sampled_cpus_write(struct file *file,
+		char const __user *buf, size_t count, loff_t *offset)
+{
+	cpumask_t new_value;
+	int retval;
+
+	retval = oprofilefs_cpulist_from_user(&new_value, buf, count);
+	if (retval)
+		return retval;
+
+	if (!cpus_intersects(new_value, cpu_online_map))
+		return -EINVAL;
+
+	cpus_and(fs_sampled_cpus, new_value, cpu_online_map);
+	return count;
+}
+
+
+static const struct file_operations sampled_cpus_fops = {
+	.read       = sampled_cpus_read,
+	.write      = sampled_cpus_write,
+};
+
+
 void oprofile_create_files(struct super_block * sb, struct dentry * root)
 {
 	oprofilefs_create_file(sb, root, "enable", &enable_fops);
@@ -172,7 +204,10 @@ void oprofile_create_files(struct super_block * sb, struct dentry * root)
 	oprofilefs_create_file(sb, root, "pointer_size", &pointer_size_fops);
 	oprofilefs_create_file(sb, root,
 			"enhanced_backtrace", &enhanced_backtrace_fops);
+	oprofilefs_create_file(sb, root, "sampled_cpus", &sampled_cpus_fops);
 	oprofile_create_stats_files(sb, root);
 	if (oprofile_ops.create_files)
 		oprofile_ops.create_files(sb, root);
+
+	fs_sampled_cpus = cpu_online_map;
 }
diff --git a/drivers/oprofile/oprofilefs.c b/drivers/oprofile/oprofilefs.c
index 8543cb2..ffd0971 100644
--- a/drivers/oprofile/oprofilefs.c
+++ b/drivers/oprofile/oprofilefs.c
@@ -15,6 +15,7 @@
 #include <linux/oprofile.h>
 #include <linux/fs.h>
 #include <linux/pagemap.h>
+#include <linux/ctype.h>
 #include <asm/uaccess.h>
 
 #include "oprof.h"
@@ -44,6 +45,51 @@ static struct super_operations s_ops = {
 };
 
 
+ssize_t oprofilefs_cpulist_to_user(const cpumask_t * mask, char __user * buf,
+                                   size_t count, loff_t * offset)
+{
+	char *page;
+	char *s;
+	ssize_t retval;
+
+	if (!(page = (char *)__get_free_page(GFP_TEMPORARY)))
+		return -ENOMEM;
+
+	s = page;
+	s += cpulist_scnprintf(s, PAGE_SIZE-1, *mask);
+	*s++ = '\n';
+
+	retval = simple_read_from_buffer(buf, count, offset, page, s - page);
+	free_page((unsigned long)page);
+	return retval;
+}
+
+
+int oprofilefs_cpulist_from_user(cpumask_t * mask, char const __user * buf,
+                                 size_t count)
+{
+	char *page;
+	int retval;
+
+	if (!(page = (char *)__get_free_page(GFP_TEMPORARY)))
+		return -ENOMEM;
+
+	if (count >= PAGE_SIZE)
+		count = PAGE_SIZE-1;
+
+	if (copy_from_user(page, buf, count)) {
+		retval = -EFAULT;
+		goto out;
+	}
+	page[count] = '\0';
+
+        retval = cpulist_parse(page, *mask);
+out:
+	free_page((unsigned long)page);
+	return retval;
+}
+
+
 ssize_t oprofilefs_str_to_user(char const * str, char __user * buf, size_t count, loff_t * offset)
 {
 	return simple_read_from_buffer(buf, count, offset, str, strlen(str));
diff --git a/include/linux/oprofile.h b/include/linux/oprofile.h
index a32b2e8..e5c0ce1 100644
--- a/include/linux/oprofile.h
+++ b/include/linux/oprofile.h
@@ -14,6 +14,7 @@
 #define OPROFILE_H
 
 #include <linux/types.h>
+#include <linux/cpumask.h>
 #include <linux/spinlock.h>
 #include <asm/atomic.h>
  
@@ -141,6 +142,20 @@ struct dentry * oprofilefs_mkdir(struct super_block * sb, struct dentry * root,
 	char const * name);
 
 /**
+ * Convert a cpumask_t into a cpu list string and copy it to the given user
+ * buffer @buf, updating *offset appropriately. Returns bytes written
+ * or -EFAULT.
+ */
+ssize_t oprofilefs_cpulist_to_user(const cpumask_t * mask, char __user * buf, size_t count, loff_t * offset);
+
+/**
+ * Read an ASCII string which denotes a list of cpus from a userspace buffer
+ * and assign mask on success.
+ * Returns 0 on success, < 0 on error.
+ */
+int oprofilefs_cpulist_from_user(cpumask_t * mask, char const __user * buf, size_t count);
+
+/**
  * Write the given asciz string to the given user buffer @buf, updating *offset
  * appropriately. Returns bytes written or -EFAULT.
  */
-- 
1.6.0.4

