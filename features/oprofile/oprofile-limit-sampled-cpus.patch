From 583e6f9159a361c1a1771775f617765fd8daab4d Mon Sep 17 00:00:00 2001
From: Hong H. Pham <hong.pham@windriver.com>
Date: Thu, 16 Apr 2009 13:56:27 +0800
Subject: [PATCH 02/21] oprofile: limit sampled cpus

On systems with lots of processors, oprofile may not able to sample all
processors due to bandwidth limitations.  This patch provides a new
oprofilefs control file, sampled_cpus, to select which CPUs get sampled as
a work around.

Reading from the sampled_cpus control file returns a list of CPUs selected
for sampling.  By default, all online CPUs are sampled (example from
Sun Netra T-5440):

  # mount none /mnt/oprofile -t oprofilefs
  # cd /mnt/oprofile
  # cat sampled_cpus
  0-47,72-119

Writing to the sampled_cpus control file selects the CPUs for oprofile to
sample.  The sampled_cpus control file accepts a comma delimited list of
CPUs or CPU range (which must be specified in ascending order).  For example,
the following are valid values for sampled_cpus:

  # echo 0 > sampled_cpus
  # echo 0,1,2,3,4,5,6,7 > sampled_cpus
  # echo 0-7 > sampled_cpus
  # echo 1,4-7 > sampled_cpus
  # echo 0-2,4-7 > sampled_cpus

Processes of interest for profiling should have their CPU affinity set to
include only CPUs that are in sampled_cpus.  The process's CPU affinity could
be set on the command line with the taskset command (part of util-linux)
or with the kernel's cpuset feature.  A detailed description of cpuset
could be found in linux/Documentation/cpusets.txt.

Signed-off-by: Vu Tran <vu.tran@windriver.com>
Signed-off-by: Hong H. Pham <hong.pham@windriver.com>
---
 drivers/oprofile/cpu_buffer.c     |    7 +++++
 drivers/oprofile/oprof.h          |    1 +
 drivers/oprofile/oprofile_files.c |   33 ++++++++++++++++++++++++++
 drivers/oprofile/oprofilefs.c     |   47 +++++++++++++++++++++++++++++++++++++
 include/linux/oprofile.h          |   15 +++++++++++
 5 files changed, 103 insertions(+), 0 deletions(-)

diff --git a/drivers/oprofile/cpu_buffer.c b/drivers/oprofile/cpu_buffer.c
index 8668843..8bcafa8 100644
--- a/drivers/oprofile/cpu_buffer.c
+++ b/drivers/oprofile/cpu_buffer.c
@@ -358,8 +358,15 @@ void oprofile_add_sample(struct pt_regs * const regs, unsigned long event)
 {
 	int is_kernel = !user_mode(regs);
 	unsigned long pc = profile_pc(regs);
+	unsigned int this_cpu = get_cpu();
+
+	if (!cpu_isset(this_cpu, fs_sampled_cpus)) {
+		put_cpu();
+		return;
+	}
 
 	__oprofile_add_ext_sample(pc, regs, event, is_kernel);
+	put_cpu();
 }
 
 /*
diff --git a/drivers/oprofile/oprof.h b/drivers/oprofile/oprof.h
index 29e8f3f..967b04c 100644
--- a/drivers/oprofile/oprof.h
+++ b/drivers/oprofile/oprof.h
@@ -24,6 +24,7 @@ struct oprofile_operations;
 extern unsigned long oprofile_buffer_size;
 extern unsigned long oprofile_cpu_buffer_size;
 extern unsigned long oprofile_buffer_watershed;
+extern cpumask_t fs_sampled_cpus;
 extern unsigned long oprofile_time_slice;
 
 extern struct oprofile_operations oprofile_ops;
diff --git a/drivers/oprofile/oprofile_files.c b/drivers/oprofile/oprofile_files.c
index 342693b..8165bf0 100644
--- a/drivers/oprofile/oprofile_files.c
+++ b/drivers/oprofile/oprofile_files.c
@@ -24,6 +24,7 @@ unsigned long oprofile_buffer_size;
 unsigned long oprofile_cpu_buffer_size;
 unsigned long oprofile_buffer_watershed;
 unsigned long oprofile_time_slice;
+cpumask_t fs_sampled_cpus;
 
 #ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
 
@@ -203,6 +204,36 @@ static const struct file_operations enhanced_backtrace_fops = {
 	.write      = enhanced_backtrace_write,
 };
 
+static ssize_t sampled_cpus_read(struct file *file,
+		char __user *buf, size_t count, loff_t *offset)
+{
+	return oprofilefs_cpulist_to_user(&fs_sampled_cpus, buf, count, offset);
+}
+
+
+static ssize_t sampled_cpus_write(struct file *file,
+		char const __user *buf, size_t count, loff_t *offset)
+{
+	cpumask_t new_value;
+	int retval;
+
+	retval = oprofilefs_cpulist_from_user(&new_value, buf, count);
+	if (retval)
+		return retval;
+
+	if (!cpus_intersects(new_value, cpu_online_map))
+		return -EINVAL;
+
+	cpus_and(fs_sampled_cpus, new_value, cpu_online_map);
+	return count;
+}
+
+
+static const struct file_operations sampled_cpus_fops = {
+	.read       = sampled_cpus_read,
+	.write      = sampled_cpus_write,
+};
+
 void oprofile_create_files(struct super_block *sb, struct dentry *root)
 {
 	/* reinitialize default values */
@@ -222,10 +253,12 @@ void oprofile_create_files(struct super_block *sb, struct dentry *root)
 	oprofilefs_create_file(sb, root, "pointer_size", &pointer_size_fops);
 	oprofilefs_create_file(sb, root,
 			"enhanced_backtrace", &enhanced_backtrace_fops);
+	oprofilefs_create_file(sb, root, "sampled_cpus", &sampled_cpus_fops);
 #ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
 	oprofilefs_create_file(sb, root, "time_slice", &timeout_fops);
 #endif
 	oprofile_create_stats_files(sb, root);
 	if (oprofile_ops.create_files)
 		oprofile_ops.create_files(sb, root);
+	fs_sampled_cpus = cpu_online_map;
 }
diff --git a/drivers/oprofile/oprofilefs.c b/drivers/oprofile/oprofilefs.c
index 2766a6d..010d616 100644
--- a/drivers/oprofile/oprofilefs.c
+++ b/drivers/oprofile/oprofilefs.c
@@ -15,6 +15,8 @@
 #include <linux/oprofile.h>
 #include <linux/fs.h>
 #include <linux/pagemap.h>
+#include <linux/ctype.h>
+#include <linux/cpumask.h>
 #include <asm/uaccess.h>
 
 #include "oprof.h"
@@ -40,6 +42,51 @@ static const struct super_operations s_ops = {
 	.drop_inode 	= generic_delete_inode,
 };
 
+ssize_t oprofilefs_cpulist_to_user(const cpumask_t *mask, char __user *buf,
+		size_t count, loff_t *offset)
+{
+	char *page;
+	char *s;
+	ssize_t retval;
+
+	page = (char *)__get_free_page(GFP_TEMPORARY);
+	if (!page)
+		return -ENOMEM;
+
+	s = page;
+	s += cpulist_scnprintf(s, PAGE_SIZE-1, mask);
+	*s++ = '\n';
+
+	retval = simple_read_from_buffer(buf, count, offset, page, s - page);
+	free_page((unsigned long)page);
+	return retval;
+}
+
+
+int oprofilefs_cpulist_from_user(cpumask_t *mask, char const __user *buf,
+		size_t count)
+{
+	char *page;
+	int retval;
+
+	page = (char *)__get_free_page(GFP_TEMPORARY);
+	if (!page)
+		return -ENOMEM;
+
+	if (count >= PAGE_SIZE)
+		count = PAGE_SIZE-1;
+
+	if (copy_from_user(page, buf, count)) {
+		retval = -EFAULT;
+		goto out;
+	}
+	page[count] = '\0';
+
+	retval = cpulist_parse(page, mask);
+out:
+	free_page((unsigned long)page);
+	return retval;
+}
 
 ssize_t oprofilefs_str_to_user(char const *str, char __user *buf, size_t count, loff_t *offset)
 {
diff --git a/include/linux/oprofile.h b/include/linux/oprofile.h
index dd6a02f..c8b8e5d 100644
--- a/include/linux/oprofile.h
+++ b/include/linux/oprofile.h
@@ -14,6 +14,7 @@
 #define OPROFILE_H
 
 #include <linux/types.h>
+#include <linux/cpumask.h>
 #include <linux/spinlock.h>
 #include <asm/atomic.h>
  
@@ -138,6 +139,20 @@ struct dentry * oprofilefs_mkdir(struct super_block * sb, struct dentry * root,
 	char const * name);
 
 /**
+ * Convert a cpumask_t into a cpu list string and copy it to the given user
+ * buffer @buf, updating *offset appropriately. Returns bytes written
+ * or -EFAULT.
+ */
+ssize_t oprofilefs_cpulist_to_user(const cpumask_t *mask, char __user *buf, size_t count, loff_t *offset);
+
+/**
+ * Read an ASCII string which denotes a list of cpus from a userspace buffer
+ * and assign mask on success.
+ * Returns 0 on success, < 0 on error.
+ */
+int oprofilefs_cpulist_from_user(cpumask_t *mask, char const __user *buf, size_t count);
+
+/**
  * Write the given asciz string to the given user buffer @buf, updating *offset
  * appropriately. Returns bytes written or -EFAULT.
  */
-- 
1.6.5.2

