From 73ab46d34c717aab6c4e67898312291e3fc8fca9 Mon Sep 17 00:00:00 2001
From: Zwane Mwaikambo <zwane.mwaikambo@windriver.com>
Date: Tue, 27 Oct 2009 11:15:48 -0700
Subject: [PATCH 20/21] Cavium/oprofile kernel panic

The following issues were found in the oprofile MIPS PMU handler

1) Unaligned copies within the kernel and not recovering from them
2) Traversing invalid exception frames
3) Unrecoverable page faults from accessing user addresses directly

To resolve these;

o Use probe_kernel_* when doing IO from user
o Use extable fixups to handle faults when checking user addresses
  (removes need for do_ade and do_page_fault hooks)

Signed-off-by: Zwane Mwaikambo <zwane.mwaikambo@windriver.com>
Signed-off-by: Dave Lerner <dave.lerner@windriver.com>
---
 arch/mips/kernel/unaligned.c      |   14 -------
 arch/mips/mm/fault.c              |   14 -------
 arch/mips/oprofile/backtrace.c    |    1 +
 arch/mips/oprofile/backtrace.h    |   17 --------
 arch/mips/oprofile/common.c       |    5 --
 arch/mips/oprofile/context.c      |   15 ++++---
 arch/mips/oprofile/mem_validate.h |   22 ++++++----
 arch/mips/oprofile/mips_context.h |    4 --
 arch/mips/oprofile/mips_crawl.c   |   79 ++++++++++++-------------------------
 9 files changed, 48 insertions(+), 123 deletions(-)

diff --git a/arch/mips/kernel/unaligned.c b/arch/mips/kernel/unaligned.c
index 7ba78a1..69b039c 100644
--- a/arch/mips/kernel/unaligned.c
+++ b/arch/mips/kernel/unaligned.c
@@ -452,12 +452,6 @@ static void emulate_load_store_insn(struct pt_regs *regs,
 		 */
 		goto sigbus;
 
-#if defined(CONFIG_64BIT) \
-	&& (defined(CONFIG_OPROFILE_MODULE) || defined(CONFIG_OPROFILE))
-	if (is_oprofile_fault && (*is_oprofile_fault)(regs))
-		return;
-#endif
-
 	/*
 	 * COP2 is available to implementor for application specific use.
 	 * It's up to applications to register a notifier chain and do
@@ -514,14 +508,6 @@ sigill:
 	force_sig(SIGILL, current);
 }
 
-#if defined(CONFIG_64BIT) \
-	&& (defined(CONFIG_OPROFILE_MODULE) || defined(CONFIG_OPROFILE))
-/*
- * For oprofile backtrace code. If oprofile is enabled, this callback is valid
- */
-extern int (*is_oprofile_fault)(struct pt_regs *regs);
-#endif
-
 asmlinkage void do_ade(struct pt_regs *regs)
 {
 	unsigned int __user *pc;
diff --git a/arch/mips/mm/fault.c b/arch/mips/mm/fault.c
index 26b49e5..f2cb157 100644
--- a/arch/mips/mm/fault.c
+++ b/arch/mips/mm/fault.c
@@ -26,12 +26,6 @@
 #include <asm/ptrace.h>
 #include <asm/highmem.h>		/* For VMALLOC_END */
 
-#if defined(CONFIG_64BIT) && \
-		(defined(CONFIG_OPROFILE_MODULE) || defined(CONFIG_OPROFILE))
-int (*is_oprofile_fault)(struct pt_regs *regs) = 0;
-EXPORT_SYMBOL_GPL(is_oprofile_fault);
-#endif
-
 
 /*
  * This routine handles page faults.  It determines the address,
@@ -48,14 +42,6 @@ asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long write,
 	siginfo_t info;
 	int fault;
 
-#if defined(CONFIG_64BIT) && \
-		(defined(CONFIG_OPROFILE_MODULE) || defined(CONFIG_OPROFILE))
-	/* for stack and frame pointer validity checking */
-	if (is_oprofile_fault && (*is_oprofile_fault)(regs)) {
-		return;
-	}
-#endif
-
 #if 0
 	printk("Cpu%d[%s:%d:%0*lx:%ld:%0*lx]\n", raw_smp_processor_id(),
 	       current->comm, current->pid, field, address, write,
diff --git a/arch/mips/oprofile/backtrace.c b/arch/mips/oprofile/backtrace.c
index edd2aaf..efecba4 100644
--- a/arch/mips/oprofile/backtrace.c
+++ b/arch/mips/oprofile/backtrace.c
@@ -20,6 +20,7 @@
 #include <linux/types.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
+#include <linux/uaccess.h>
 #include <linux/oprofile.h>
 #include <asm/uaccess.h>
 #include <asm/stacktrace.h>
diff --git a/arch/mips/oprofile/backtrace.h b/arch/mips/oprofile/backtrace.h
index b105a58..0b49062 100644
--- a/arch/mips/oprofile/backtrace.h
+++ b/arch/mips/oprofile/backtrace.h
@@ -22,21 +22,4 @@
  */
 extern void mips_backtrace(struct pt_regs *const regs, unsigned int depth);
 
-#if defined(CONFIG_64BIT)
-/*
- * Callback from do_page_fault and do_ade to detect if
- * page fault occured during an oprofile_backtrace.
- * returns 1 if caller should not handle the fault
- *   (caused by oprofile backtracing)
- * returns 0 if the caller should handle the fault
- */
-extern unsigned int (*is_oprofile_fault)(struct pt_regs *regs);
-
-/*
- * Callback from do_page_fault and do_ade to set return
- * of oprofile user space address valididator to false
- */
-extern unsigned int op_page_fault_filter(struct pt_regs *regs);
-#endif
-
 #endif /* BACKTRACE_H */
diff --git a/arch/mips/oprofile/common.c b/arch/mips/oprofile/common.c
index 76fcd66..b1f1b24 100644
--- a/arch/mips/oprofile/common.c
+++ b/arch/mips/oprofile/common.c
@@ -112,11 +112,6 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	/* Enable backtrace even if defaulting to timer mode */
 	ops->backtrace		= mips_backtrace;
 
-#if defined(CONFIG_64BIT)
-	/* set do_page_fault and do_ade handler callback */
-	is_oprofile_fault	= op_page_fault_filter;
-#endif
-
 	if (!lmodel) {
 		printk(KERN_WARNING
 			"oprofile: limited support for cpu type %d\n",
diff --git a/arch/mips/oprofile/context.c b/arch/mips/oprofile/context.c
index f1da5b7..d13ef33 100644
--- a/arch/mips/oprofile/context.c
+++ b/arch/mips/oprofile/context.c
@@ -19,6 +19,7 @@
  *
  */
 
+#include <linux/sched.h>
 #include <linux/uaccess.h>
 #include "mips_context.h"
 #include "stack_crawl.h"
@@ -107,13 +108,11 @@ bool apply_delta(const struct new_value_delta *const delta,
 			    (void *)((unsigned long)child->gpregs[delta->reg] +
 				     delta->offset);
 		}
-		if (will_page_fault(target)) {
-			d1printf
-			    ("Invalid address %p picked up from gpregs+%d\n",
-			     target, delta->reg);
+		if (probe_kernel_read(result, target, sizeof(*result))) {
+			d1printf("Invalid address %p picked up from gpregs+%d\n",
+				target, delta->reg);
 			return false;
 		}
-		*result = *target;
 	}
 
 	else if (LOCATION_ABSOLUTE == delta->location) {
@@ -195,7 +194,8 @@ bool apply_context_results(struct op_context *const child,
 			     target);
 			return false;
 		}
-		parent->fp = *target;
+		if (probe_kernel_address(target, parent->fp))
+			return false;
 	}
 #  endif /* RTITOOLS_CONTEXT_USES_SP */
 	else {
@@ -219,7 +219,8 @@ bool apply_context_results(struct op_context *const child,
 			     target);
 			return false;
 		}
-		parent->pc = *target;
+		if (probe_kernel_read(&parent->pc, target, sizeof(parent->pc)))
+			return false;
 	}
 #endif /* USES_SP */
 
diff --git a/arch/mips/oprofile/mem_validate.h b/arch/mips/oprofile/mem_validate.h
index f40b476..a307b56 100644
--- a/arch/mips/oprofile/mem_validate.h
+++ b/arch/mips/oprofile/mem_validate.h
@@ -22,7 +22,12 @@
 /*
  * Return 1 if will  page fault, or 0 if it won't
  */
-extern int will_page_fault(const void *const address);
+extern int __will_fault(const void *const address, size_t size);
+
+
+typedef unsigned int tInst;	/* Instruction type */
+typedef int rOffset;		/* instruction register offset field */
+#define INST_SIZE (4)		/* Size of instr -- avoid sizeof() overhead */
 
 /*
  * Context address types
@@ -69,7 +74,7 @@ typedef struct {
  */
 struct memory_access_data {
 	void *pc_copied;
-	void *data;
+	tInst data;
 };
 
 /*
@@ -84,9 +89,10 @@ struct memory_access_data {
  */
 static inline bool PCOk(const void const *pc, struct memory_access_data *membuf)
 {
-	if (will_page_fault(pc))
+	if (__will_fault(pc, sizeof(tInst)))
 		return false;
-	if (__copy_from_user_inatomic(&membuf->data, pc, sizeof(membuf->data)))
+
+	if (probe_kernel_address(pc, membuf->data))
 		return false;
 	membuf->pc_copied = (void *)pc;
 	return true;
@@ -112,12 +118,10 @@ static inline bool PCOk(const void const *pc, struct memory_access_data *membuf)
  * op_frame_crawl().
  */
 
-static inline
-    void *instruction(const void const *pc, struct memory_access_data *membuf)
+static inline void *instruction(const void const *pc, struct memory_access_data *membuf)
 {
 	if (membuf->pc_copied != pc) {
-		if (__copy_from_user_inatomic
-		    (&membuf->data, pc, sizeof(membuf->data))) {
+		if (probe_kernel_address(pc, membuf->data)) {
 			/* copy failed, stuff bad instruction into the buffer */
 			membuf->data = 0;
 		}
@@ -149,7 +153,7 @@ static inline
   */
 static inline bool SPOk(const void *const sp, crawl_validation *validation)
 {
-	return !will_page_fault(sp);
+	return !__will_fault(sp, sizeof(*sp));
 }
 
 #endif /* _MEM_VALIDATE_H_ */
diff --git a/arch/mips/oprofile/mips_context.h b/arch/mips/oprofile/mips_context.h
index 1848470..e172ee2 100644
--- a/arch/mips/oprofile/mips_context.h
+++ b/arch/mips/oprofile/mips_context.h
@@ -78,10 +78,6 @@ typedef unsigned long tAddr;	/* Address type */
 /* Number of back branches before we stop taking them */
 #define MAX_ARB_BRANCHES         10
 
-typedef unsigned int tInst;	/* Instruction type */
-typedef int rOffset;		/* instruction register offset field */
-#define INST_SIZE (4)		/* Size of instr -- avoid sizeof() overhead */
-
 /*
  *  Parameters - define context parameters here
  */
diff --git a/arch/mips/oprofile/mips_crawl.c b/arch/mips/oprofile/mips_crawl.c
index 0118947..61e38c2 100644
--- a/arch/mips/oprofile/mips_crawl.c
+++ b/arch/mips/oprofile/mips_crawl.c
@@ -201,6 +201,7 @@ double          64                  64
 long double     64 (128 in n32)     128
 */
 
+#include <linux/sched.h>
 #include <linux/types.h>
 #include <linux/uaccess.h>
 #include <linux/ptrace.h>
@@ -223,69 +224,41 @@ int op_context_debug_output; /* = 0 */
  * NOTE: The probe_kernel_read() routine does not catch unaligned
  * exceptions which occur in the upper address space for MIPS64.
  */
-noinline int will_page_fault(const void *const address)
+int __will_fault(const void *const address, size_t size)
 {
-	register long ret asm("$2") = 0;
-
-	asm(".set noreorder");
-	asm("ssnop");
-
-	/* dereference the given address.  If this causes a page fault, our
-	 * installed handlers should intercept this and set the "ret" register
-	 * to 1.
-	 * This instruction has an artificial dependency on the "ret" variable
-	 * as an input parameter, which ensures "ret" is not forcefully set to
-	 * true after our page fault handling mechanism may have set it false.
-	 */
-	asm("lw   $3, %1" ::"X" (ret), "m" (*(long *)address));
-
-	asm("ssnop");
-	asm(".set reorder");
-
-	return ret;
-}
-
-/*
- * Delimit the end of oprofile_address_checker
- */
-noinline int will_page_fault_end(void)
-{
-	return op_context_debug_output;
-}
-
-/*
- * callback for do_page_fault and do_ade
- * return 1 to abort the do_page_fault
- * return 0 if fault not caused by our backtrace
- */
-unsigned int op_page_fault_filter(struct pt_regs *regs)
-{
-	unsigned long pc = regs->cp0_epc;
-
-	if ((pc >= (unsigned long) will_page_fault) &&
-		(pc <= (unsigned long) will_page_fault_end)) {
-		/* page corresponding to pc isn't in memory, set return
-		 * value to true
-		 */
-		regs->regs[REG_V0] = 1;
-
-		/* change pc to right instruction (*/
-		regs->cp0_epc = pc + sizeof(tInst);
-
-		return 1;
+	long t;
+	int ret = 1;
+
+	if ((unsigned long)address & (size - 1))
+		goto done;
+
+	if (!access_ok(VERIFY_READ, address, size))
+		goto done;
+
+	switch (size) {
+	case 4:
+		if (__get_user_nocheck(t, (unsigned int *)address, 4))
+			goto done;
+		break;
+	case 8:
+		if (__get_user_nocheck(t, (unsigned long *)address, 8))
+			goto done;
+		 break;
+	default:
+		goto done;
 	}
 
-	/* return 0, since this isn't our page fault */
-	return 0;
+	ret = 0;
+done:
+	return ret;
 }
-
 #else
 
 /*
  * Make a page fault or else prove we won't.  Tool used by PCOk and SPOk
  * Return 0 if no page fault, 1 if page fault happened
  */
-int will_page_fault(const void *const address)
+int __will_fault(const void *const address, size_t size)
 {
 	long dst;
 	if (probe_kernel_read(&dst, (void *)address, sizeof(long)) != 0)
-- 
1.6.5.2

