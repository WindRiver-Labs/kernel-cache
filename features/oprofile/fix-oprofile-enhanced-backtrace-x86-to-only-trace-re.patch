From 7232accf2222edb7a9dce45ba4577033214d22a9 Mon Sep 17 00:00:00 2001
From: Dave Lerner <Dave.Lerner@windriver.com>
Date: Fri, 19 Dec 2008 14:24:55 -0600
Subject: [PATCH 05/21] fix oprofile enhanced backtrace x86 to only trace reliable stack values

The upstream oprofile backtrace callback for x86 did not
ignore unreliable backtrace addresses provided by
traps_nn print_context_stack.  The new enhanced oprofile
backtrace for x86 incorrectly followed the same logic.

Unreliable is defined in print_context_stack as a stack
entry whose value was a valid kernel text address, but possibly not a
real return address from the stack frame. The address was
tagged reliable when the value was at an expected return
address location based on the frame pointer.

If frame pointers aren't enabled, the address, although in kernel
text space, may not be a real return address. This algorithm works
well for printing oops backtraces if frame pointers weren't used.
But for the enhanced backtrace that enables tools to visualize
statistics for complete callstacks, the unreliable data generates
too many false callstacks, rendering statistics per callstack in the
kernel useless.

The patch fixes print_context_stack() and the x86 oprofile
backtrace_address_with_sp() to throw away data that is not
reliable.

Signed-off-by: Dave Lerner <Dave.Lerner@windriver.com>
---
 arch/x86/include/asm/stacktrace.h |    2 +-
 arch/x86/kernel/dumpstack.c       |    6 +++---
 arch/x86/oprofile/backtrace.c     |    7 +++++--
 3 files changed, 9 insertions(+), 6 deletions(-)

diff --git a/arch/x86/include/asm/stacktrace.h b/arch/x86/include/asm/stacktrace.h
index a036865..389c510 100644
--- a/arch/x86/include/asm/stacktrace.h
+++ b/arch/x86/include/asm/stacktrace.h
@@ -38,7 +38,7 @@ struct stacktrace_ops {
 	void (*address)(void *data, unsigned long address, int reliable);
 	/* returns return address and sp for this address  */
 	void (*address_with_sp)(void *data, unsigned long address,
-		unsigned long sp);
+		unsigned long sp, int reliable);
 	/* On negative return stop dumping */
 	int (*stack)(void *data, char *name);
 	walk_stack_t	walk_stack;
diff --git a/arch/x86/kernel/dumpstack.c b/arch/x86/kernel/dumpstack.c
index 6f56dda..cfa6c48 100644
--- a/arch/x86/kernel/dumpstack.c
+++ b/arch/x86/kernel/dumpstack.c
@@ -100,7 +100,7 @@ print_context_stack(struct thread_info *tinfo,
 			if ((unsigned long) stack == bp + sizeof(long)) {
 				if (with_sp) {
 					ops->address_with_sp(data,
-						addr, (unsigned long)stack);
+						addr, (unsigned long)stack, 1);
 				} else {
 					ops->address(data, addr, 1);
 				}
@@ -109,7 +109,7 @@ print_context_stack(struct thread_info *tinfo,
 			} else {
 				if (with_sp) {
 					ops->address_with_sp(data,
-						addr, (unsigned long)stack);
+						addr, (unsigned long)stack, bp == 0);
 				} else {
 					ops->address(data, addr, 0);
 				}
@@ -139,7 +139,7 @@ print_context_stack_bp(struct thread_info *tinfo,
 			break;
 		if (with_sp) {
 			ops->address_with_sp(data,
-					addr, (unsigned long)stack);
+					addr, (unsigned long)stack, 1);
 		} else {
 			ops->address(data, addr, 1);
 		}
diff --git a/arch/x86/oprofile/backtrace.c b/arch/x86/oprofile/backtrace.c
index 1057fb4..e549930 100644
--- a/arch/x86/oprofile/backtrace.c
+++ b/arch/x86/oprofile/backtrace.c
@@ -59,10 +59,13 @@ static void backtrace_address(void *data, unsigned long addr, int reliable)
 }
 
 static void backtrace_address_with_sp(void *data, unsigned long addr,
-		unsigned long sp)
+		unsigned long sp, int reliable)
 {
 	struct backtrace_data *bt_data = (struct backtrace_data *) data;
 
+	if (!reliable)
+		return;
+
 	/* check if return is from a system call */
 	bt_data->syscall_frame_test((void (*)(void)) addr, sp , bt_data);
 
@@ -221,6 +224,6 @@ x86_backtrace(struct pt_regs * const regs, unsigned int depth)
 			return;
 	}
 
-	while (depth-- && head)
+	while (bt_data.depth-- && head)
 		head = dump_user_backtrace(head);
 }
-- 
1.6.5.2

