From 3d863b6eb42889bccf0b2e45e04ad91019559f78 Mon Sep 17 00:00:00 2001
From: Dave Lerner <Dave.Lerner@windriver.com>
Date: Fri, 19 Dec 2008 14:24:55 -0600
Subject: [PATCH] fix oprofile enhanced backtrace x86 to only trace reliable stack values

The upstream oprofile backtrace callback for x86 did not
ignore unreliable backtrace addresses provided by
traps_nn print_context_stack.  The new enhanced oprofile
backtrace for x86 incorrectly followed the same logic.

Unreliable is defined in print_context_stack as a stack
entry whose value was a valid kernel text address, but possibly not a
real return address from the stack frame. The address was
tagged reliable when the value was at an expected return
address location based on the frame pointer.

If frame pointers aren't enabled, the address, although in kernel
text space, may not be a real return address. This algorithm works
well for printing oops backtraces if frame pointers weren't used.
But for the enhanced backtrace that enables tools to visualize
statistics for complete callstacks, the unreliable data generates
too many false callstacks, rendering statistics per callstack in the
kernel useless.

The patch fixes print_context_stack() and the x86 oprofile
backtrace_address_with_sp() to throw away data that is not
reliable.

Signed-off-by: Dave Lerner <Dave.Lerner@windriver.com>
---
 arch/x86/kernel/traps_32.c    |    6 +++---
 arch/x86/kernel/traps_64.c    |    6 +++---
 arch/x86/oprofile/backtrace.c |    5 ++++-
 include/asm-x86/stacktrace.h  |    2 +-
 4 files changed, 11 insertions(+), 8 deletions(-)

diff --git a/arch/x86/kernel/traps_32.c b/arch/x86/kernel/traps_32.c
index ae51937..83ea97e 100644
--- a/arch/x86/kernel/traps_32.c
+++ b/arch/x86/kernel/traps_32.c
@@ -163,15 +163,15 @@ print_context_stack(struct thread_info *tinfo,
 			if ((unsigned long) stack == bp + 4) {
 				if (with_sp)
 					ops->address_with_sp(data,
-						addr, (unsigned long)stack);
+						addr, (unsigned long)stack, 1);
 				else
 					ops->address(data, addr, 1);
 				frame = frame->next_frame;
 				bp = (unsigned long) frame;
 			} else {
 				if (with_sp)
-					ops->address_with_sp(data,
-						addr, (unsigned long)stack);
+					ops->address_with_sp(data, addr,
+						(unsigned long)stack, bp == 0);
 				else
 					ops->address(data, addr, bp == 0);
 			}
diff --git a/arch/x86/kernel/traps_64.c b/arch/x86/kernel/traps_64.c
index 3372e7e..10353de 100644
--- a/arch/x86/kernel/traps_64.c
+++ b/arch/x86/kernel/traps_64.c
@@ -205,7 +205,7 @@ print_context_stack(struct thread_info *tinfo,
 			if ((unsigned long) stack == bp + 8) {
 				if (with_sp) {
 					ops->address_with_sp(data,
-						addr, (unsigned long)stack);
+						addr, (unsigned long)stack, 1);
 				} else {
 					ops->address(data, addr, 1);
 				}
@@ -213,8 +213,8 @@ print_context_stack(struct thread_info *tinfo,
 				bp = (unsigned long) frame;
 			} else {
 				if (with_sp) {
-					ops->address_with_sp(data,
-						addr, (unsigned long)stack);
+					ops->address_with_sp(data, addr,
+						(unsigned long)stack, bp == 0);
 				} else {
 					ops->address(data, addr, bp == 0);
 				}
diff --git a/arch/x86/oprofile/backtrace.c b/arch/x86/oprofile/backtrace.c
index 8a67050..4c82695 100644
--- a/arch/x86/oprofile/backtrace.c
+++ b/arch/x86/oprofile/backtrace.c
@@ -59,10 +59,13 @@ static void backtrace_address(void *data, unsigned long addr, int reliable)
 }
 
 static void backtrace_address_with_sp(void *data, unsigned long addr,
-		unsigned long sp)
+		unsigned long sp, int reliable)
 {
 	struct backtrace_data *bt_data = (struct backtrace_data *) data;
 
+	if (!reliable)
+		return;
+
 	/* check if return is from a system call */
 	bt_data->syscall_frame_test((void (*)(void)) addr, sp , bt_data);
 
diff --git a/include/asm-x86/stacktrace.h b/include/asm-x86/stacktrace.h
index f81aea4..08e3109 100644
--- a/include/asm-x86/stacktrace.h
+++ b/include/asm-x86/stacktrace.h
@@ -12,7 +12,7 @@ struct stacktrace_ops {
 	void (*address)(void *data, unsigned long address, int reliable);
 	/* returns return address and sp for this address  */
 	void (*address_with_sp)(void *data, unsigned long address,
-		unsigned long sp);
+		unsigned long sp, int reliable);
 	/* On negative return stop dumping */
 	int (*stack)(void *data, char *name);
 };
-- 
1.6.0.3

