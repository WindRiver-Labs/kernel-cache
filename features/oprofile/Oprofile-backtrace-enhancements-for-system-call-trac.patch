From 13a313fb08226a1bc0711f6ad2adfe3e06eb1654 Mon Sep 17 00:00:00 2001
From: Dave Lerner <Dave.Lerner@windriver.com>
Date: Tue, 21 Oct 2008 17:38:08 -0500
Subject: [PATCH 01/21] Oprofile backtrace enhancements for system call tracing - arch independent

Previous versions of the upstream oprofile package rejected traces
that spanned addresses from kernel to user process space.
This patch adds support utilities for the kernel/user backtraces
without impacting the standard (0.9.4) oprofile daemon and post-processing
oprofile tools.

The patch changes oprofile driver to read and write a new oprofile parameter,
/dev/oprofile/enhanced_backtrace.  The parameter is used to switch on or
off logic in arch/*/oprofile/backtrace.c to trace across the system call
boundary (these backtrace.c patches are in development). In this patch,
the changes to read/write the enhanced_backtrace parameter follow the
pattern for other oprofile files.

The patch also adds oprofile_syscall_trace_boundary() for
kernel/user boundary tracing, to flag a transition from kernel space to
user space in the oprofile data stream.
---
 drivers/oprofile/cpu_buffer.c     |   21 +++++++++++++++++++
 drivers/oprofile/oprof.c          |   24 ++++++++++++++++++++++
 drivers/oprofile/oprof.h          |    3 ++
 drivers/oprofile/oprofile_files.c |   40 +++++++++++++++++++++++++++++++++++++
 include/linux/oprofile.h          |   12 +++++++++++
 5 files changed, 100 insertions(+), 0 deletions(-)

diff --git a/drivers/oprofile/cpu_buffer.c b/drivers/oprofile/cpu_buffer.c
index 166b67e..8668843 100644
--- a/drivers/oprofile/cpu_buffer.c
+++ b/drivers/oprofile/cpu_buffer.c
@@ -458,6 +458,27 @@ fail:
 }
 
 /*
+ * This serves to add an escape code to indicate switching into
+ * user space during tracing across the sysetm call boundary
+ */
+int oprofile_syscall_trace_boundary(void)
+{
+	struct oprofile_cpu_buffer *cpu_buf = &__get_cpu_var(op_cpu_buffer);
+
+	if (!cpu_buf || !cpu_buf->tracing)
+		return 0;
+
+	/* Set buffer state to user to prevent traces from being filtered out */
+	cpu_buf->last_is_kernel = 1;
+	if (op_add_code(cpu_buf, 0, 0, current)) {
+		cpu_buf->sample_lost_overflow++;
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
  * This serves to avoid cpu buffer overflow, and makes sure
  * the task mortuary progresses
  *
diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index dc8a042..b5379f9 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -26,6 +26,7 @@ struct oprofile_operations oprofile_ops;
 
 unsigned long oprofile_started;
 unsigned long oprofile_backtrace_depth;
+static unsigned int trace_thru_syscall;
 static unsigned long is_setup;
 static DEFINE_MUTEX(start_mutex);
 
@@ -248,6 +249,29 @@ out:
 	return err;
 }
 
+int oprofile_set_trace_thru_syscall(unsigned int val)
+{
+	int err = 0;
+
+	mutex_lock(&start_mutex);
+
+	if (oprofile_started) {
+		err = -EBUSY;
+		goto out;
+	}
+
+	trace_thru_syscall = val;
+
+out:
+	mutex_unlock(&start_mutex);
+	return err;
+}
+
+unsigned int oprofile_get_trace_thru_syscall(void)
+{
+	return trace_thru_syscall;
+}
+
 static int __init oprofile_init(void)
 {
 	int err;
diff --git a/drivers/oprofile/oprof.h b/drivers/oprofile/oprof.h
index cb92f5c..29e8f3f 100644
--- a/drivers/oprofile/oprof.h
+++ b/drivers/oprofile/oprof.h
@@ -39,4 +39,7 @@ void oprofile_timer_init(struct oprofile_operations *ops);
 int oprofile_set_backtrace(unsigned long depth);
 int oprofile_set_timeout(unsigned long time);
 
+/* custom agent capabilities, currently just one - trace thru system call */
+#define OPROFILE_SYSCALL_TRACE_ENABLE 0x1
+
 #endif /* OPROF_H */
diff --git a/drivers/oprofile/oprofile_files.c b/drivers/oprofile/oprofile_files.c
index bbd7516..342693b 100644
--- a/drivers/oprofile/oprofile_files.c
+++ b/drivers/oprofile/oprofile_files.c
@@ -165,6 +165,44 @@ static const struct file_operations dump_fops = {
 	.write		= dump_write,
 };
 
+static ssize_t enhanced_backtrace_read(struct file *file,
+		char __user *buf, size_t count, loff_t *offset)
+{
+	return oprofilefs_ulong_to_user(oprofile_get_trace_thru_syscall(),
+			buf, count, offset);
+}
+
+
+static ssize_t enhanced_backtrace_write(struct file *file,
+		char const __user *buf, size_t count, loff_t *offset)
+{
+	unsigned long val;
+	int retval = 0;
+
+	if (*offset)
+		return -EINVAL;
+
+	retval = oprofilefs_ulong_from_user(&val, buf, count);
+	if (retval)
+		return retval;
+
+	/* Allow for additional backtracing features, but for now the only
+	 * additional capability is tracing across the system call boundary
+	 */
+	if (val & OPROFILE_SYSCALL_TRACE_ENABLE)
+		retval = oprofile_set_trace_thru_syscall(1);
+
+	if (retval)
+		return retval;
+
+	return count;
+}
+
+static const struct file_operations enhanced_backtrace_fops = {
+	.read       = enhanced_backtrace_read,
+	.write      = enhanced_backtrace_write,
+};
+
 void oprofile_create_files(struct super_block *sb, struct dentry *root)
 {
 	/* reinitialize default values */
@@ -182,6 +220,8 @@ void oprofile_create_files(struct super_block *sb, struct dentry *root)
 	oprofilefs_create_file(sb, root, "cpu_type", &cpu_type_fops);
 	oprofilefs_create_file(sb, root, "backtrace_depth", &depth_fops);
 	oprofilefs_create_file(sb, root, "pointer_size", &pointer_size_fops);
+	oprofilefs_create_file(sb, root,
+			"enhanced_backtrace", &enhanced_backtrace_fops);
 #ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
 	oprofilefs_create_file(sb, root, "time_slice", &timeout_fops);
 #endif
diff --git a/include/linux/oprofile.h b/include/linux/oprofile.h
index 5171639..dd6a02f 100644
--- a/include/linux/oprofile.h
+++ b/include/linux/oprofile.h
@@ -185,4 +185,16 @@ int oprofile_add_data(struct op_entry *entry, unsigned long val);
 int oprofile_add_data64(struct op_entry *entry, u64 val);
 int oprofile_write_commit(struct op_entry *entry);
 
+/* Set and get the flag indicating that the oprofile device reader expects
+ *  backtraces across the system call
+ */
+int oprofile_set_trace_thru_syscall(unsigned int enable);
+unsigned int oprofile_get_trace_thru_syscall(void);
+
+/*
+ * Add an escape code to the cpu buffer indicate switching into
+ * user space during tracing across the system call boundary
+ */
+int oprofile_syscall_trace_boundary(void);
+
 #endif /* OPROFILE_H */
-- 
1.6.5.2

