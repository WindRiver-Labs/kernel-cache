From b46995d4d6fd472918b055a90f9ec830a70e6f9a Mon Sep 17 00:00:00 2001
From: Dave Lerner <Dave.Lerner@windriver.com>
Date: Wed, 5 Nov 2008 17:10:49 -0600
Subject: [PATCH 04/21] oprofile backtrace across system calls 32/64 bit x86 kernels

Adds systemcall backtracing, from kernel into user space.

The system call assembler routines are modified when oprofile
is configured into the kernel, such that a full, rather than partial,
pt_regs structure is pushed onto the stack. This struct includes
the frame pointer prior to the system call.  The new stack layout
allows oprofile backtrace to get to the user space frame pointer.

In dumpstack_32/64.c, dump_trace_extended() uses new stacktrace_ops
callback that returns both pc and sp.  Oprofile x86_backtrace()
implements the new callback to reconstruct the pt_regs, and get to
the user frame pointer.

Signed-off-by: Dave Lerner <dave.lerner@windriver.com>
Signed-off-by: Zwane Mwaikambo <zwane.mwaikambo@windriver.com>
Integrated-by: Liming Wang <liming.wang@windriver.com>
---
 arch/x86/ia32/ia32entry.S         |   65 +++++++++++++++----
 arch/x86/include/asm/proto.h      |    7 ++
 arch/x86/include/asm/stacktrace.h |   18 ++++-
 arch/x86/kernel/dumpstack.c       |   27 ++++++--
 arch/x86/kernel/dumpstack_32.c    |   13 +++-
 arch/x86/kernel/dumpstack_64.c    |   17 ++++-
 arch/x86/kernel/entry_32.S        |    4 +
 arch/x86/kernel/entry_64.S        |   33 +++++++++-
 arch/x86/oprofile/backtrace.c     |  131 ++++++++++++++++++++++++++++++++++---
 9 files changed, 277 insertions(+), 38 deletions(-)

diff --git a/arch/x86/ia32/ia32entry.S b/arch/x86/ia32/ia32entry.S
index e790bc1..9e410e9 100644
--- a/arch/x86/ia32/ia32entry.S
+++ b/arch/x86/ia32/ia32entry.S
@@ -25,6 +25,31 @@
 #define sysretl_audit ia32_ret_from_sys_call
 #endif
 
+#ifdef CONFIG_OPROFILE
+#define OPROF_ARGOFFSET	0
+#else
+#define OPROF_ARGOFFSET ARGOFFSET
+#endif
+
+	.macro OPROF_SAVE_REST reg, tmp, savereg=1
+#ifdef CONFIG_OPROFILE
+	SAVE_REST
+	movq	RBP(%rsp), \tmp
+	.if \savereg
+	movq	\reg, RBP(%rsp)
+	.endif
+#endif
+	.endm
+
+	.macro OPROF_RESTORE_REST tmp, restorereg=1
+#ifdef CONFIG_OPROFILE
+	.if \restorereg
+	movq	\tmp, RBP(%rsp)
+	.endif
+	RESTORE_REST
+#endif
+	.endm
+
 #define IA32_NR_syscalls ((ia32_syscall_end - ia32_sys_call_table)/8)
 
 	.macro IA32_ARG_FIXUP noebp=0
@@ -158,7 +183,11 @@ ENTRY(ia32_sysenter_target)
 sysenter_do_call:
 	IA32_ARG_FIXUP
 sysenter_dispatch:
+	OPROF_SAVE_REST %r9, %r15
 	call	*ia32_sys_call_table(,%rax,8)
+	.globl ia32_sysenter_done
+ia32_sysenter_done:
+	OPROF_RESTORE_REST %r15
 	movq	%rax,RAX-ARGOFFSET(%rsp)
 	GET_THREAD_INFO(%r10)
 	DISABLE_INTERRUPTS(CLBR_NONE)
@@ -319,7 +348,11 @@ ENTRY(ia32_cstar_target)
 cstar_do_call:
 	IA32_ARG_FIXUP 1
 cstar_dispatch:
+	OPROF_SAVE_REST %r9, %r15
 	call *ia32_sys_call_table(,%rax,8)
+	.globl ia32_cstar_done
+ia32_cstar_done:
+	OPROF_RESTORE_REST %r15
 	movq %rax,RAX-ARGOFFSET(%rsp)
 	GET_THREAD_INFO(%r10)
 	DISABLE_INTERRUPTS(CLBR_NONE)
@@ -429,7 +462,11 @@ ENTRY(ia32_syscall)
 	ja ia32_badsys
 ia32_do_call:
 	IA32_ARG_FIXUP
+	OPROF_SAVE_REST %rbp, %r15, 0
 	call *ia32_sys_call_table(,%rax,8) # xxx: rip relative
+	.globl ia32_syscall_done
+ia32_syscall_done:
+	OPROF_RESTORE_REST %r15, 0
 ia32_sysret:
 	movq %rax,RAX-ARGOFFSET(%rsp)
 ia32_ret_from_sys_call:
@@ -463,7 +500,7 @@ quiet_ni_syscall:
 	.globl \label
 \label:
 	leaq \func(%rip),%rax
-	leaq -ARGOFFSET+8(%rsp),\arg	/* 8 for return address */
+	leaq -OPROF_ARGOFFSET+8(%rsp),\arg	/* 8 for return address */
 	jmp  ia32_ptregs_common	
 	.endm
 
@@ -483,18 +520,22 @@ ENTRY(ia32_ptregs_common)
 	CFI_ENDPROC
 	CFI_STARTPROC32	simple
 	CFI_SIGNAL_FRAME
-	CFI_DEF_CFA	rsp,SS+8-ARGOFFSET
-	CFI_REL_OFFSET	rax,RAX-ARGOFFSET
-	CFI_REL_OFFSET	rcx,RCX-ARGOFFSET
-	CFI_REL_OFFSET	rdx,RDX-ARGOFFSET
-	CFI_REL_OFFSET	rsi,RSI-ARGOFFSET
-	CFI_REL_OFFSET	rdi,RDI-ARGOFFSET
-	CFI_REL_OFFSET	rip,RIP-ARGOFFSET
-/*	CFI_REL_OFFSET	cs,CS-ARGOFFSET*/
-/*	CFI_REL_OFFSET	rflags,EFLAGS-ARGOFFSET*/
-	CFI_REL_OFFSET	rsp,RSP-ARGOFFSET
-/*	CFI_REL_OFFSET	ss,SS-ARGOFFSET*/
+	CFI_DEF_CFA	rsp,SS+8-OPROF_ARGOFFSET
+	CFI_REL_OFFSET	rax,RAX-OPROF_ARGOFFSET
+	CFI_REL_OFFSET	rcx,RCX-OPROF_ARGOFFSET
+	CFI_REL_OFFSET	rdx,RDX-OPROF_ARGOFFSET
+	CFI_REL_OFFSET	rsi,RSI-OPROF_ARGOFFSET
+	CFI_REL_OFFSET	rdi,RDI-OPROF_ARGOFFSET
+	CFI_REL_OFFSET	rip,RIP-OPROF_ARGOFFSET
+/*	CFI_REL_OFFSET	cs,CS-OPROF_ARGOFFSET*/
+/*	CFI_REL_OFFSET	rflags,EFLAGS-OPROF_ARGOFFSET*/
+	CFI_REL_OFFSET	rsp,RSP-OPROF_ARGOFFSET
+/*	CFI_REL_OFFSET	ss,SS-OPROF_ARGOFFSET*/
+#ifdef CONFIG_OPROFILE
+	movq	%r15, RBP(%rsp)	/* SAVE_REST at syscall */
+#else
 	SAVE_REST
+#endif
 	call *%rax
 	RESTORE_REST
 	jmp  ia32_sysret	/* misbalances the return cache */
diff --git a/arch/x86/include/asm/proto.h b/arch/x86/include/asm/proto.h
index 6f414ed..9b80f06 100644
--- a/arch/x86/include/asm/proto.h
+++ b/arch/x86/include/asm/proto.h
@@ -14,6 +14,13 @@ void ia32_syscall(void);
 void ia32_cstar_target(void);
 void ia32_sysenter_target(void);
 
+/* for oprofile system call checks */
+extern void system_call_done(void);
+extern void tracesys_done(void);
+extern void ia32_syscall_done(void);
+extern void ia32_cstar_done(void);
+extern void ia32_sysenter_done(void);
+
 void syscall32_cpu_init(void);
 
 void x86_configure_nx(void);
diff --git a/arch/x86/include/asm/stacktrace.h b/arch/x86/include/asm/stacktrace.h
index 4dab78e..a036865 100644
--- a/arch/x86/include/asm/stacktrace.h
+++ b/arch/x86/include/asm/stacktrace.h
@@ -12,19 +12,22 @@ typedef unsigned long (*walk_stack_t)(struct thread_info *tinfo,
 				      const struct stacktrace_ops *ops,
 				      void *data,
 				      unsigned long *end,
-				      int *graph);
+				      int *graph,
+				      int with_sp);
 
 extern unsigned long
 print_context_stack(struct thread_info *tinfo,
 		    unsigned long *stack, unsigned long bp,
 		    const struct stacktrace_ops *ops, void *data,
-		    unsigned long *end, int *graph);
+		    unsigned long *end, int *graph,
+		    int with_sp);
 
 extern unsigned long
 print_context_stack_bp(struct thread_info *tinfo,
 		       unsigned long *stack, unsigned long bp,
 		       const struct stacktrace_ops *ops, void *data,
-		       unsigned long *end, int *graph);
+		       unsigned long *end, int *graph,
+		       int with_sp);
 
 /* Generic stack tracer with callbacks */
 
@@ -33,6 +36,9 @@ struct stacktrace_ops {
 	/* msg must contain %s for the symbol */
 	void (*warning_symbol)(void *data, char *msg, unsigned long symbol);
 	void (*address)(void *data, unsigned long address, int reliable);
+	/* returns return address and sp for this address  */
+	void (*address_with_sp)(void *data, unsigned long address,
+		unsigned long sp);
 	/* On negative return stop dumping */
 	int (*stack)(void *data, char *name);
 	walk_stack_t	walk_stack;
@@ -42,4 +48,10 @@ void dump_trace(struct task_struct *tsk, struct pt_regs *regs,
 		unsigned long *stack, unsigned long bp,
 		const struct stacktrace_ops *ops, void *data);
 
+/* extends the callbacks to include address_with_sp() */
+void dump_trace_extended(struct task_struct *tsk, struct pt_regs *regs,
+		unsigned long *stack, unsigned long bp,
+		const struct stacktrace_ops *ops, void *data,
+		unsigned int with_stack);
+
 #endif /* _ASM_X86_STACKTRACE_H */
diff --git a/arch/x86/kernel/dumpstack.c b/arch/x86/kernel/dumpstack.c
index 6d81755..6f56dda 100644
--- a/arch/x86/kernel/dumpstack.c
+++ b/arch/x86/kernel/dumpstack.c
@@ -87,7 +87,8 @@ unsigned long
 print_context_stack(struct thread_info *tinfo,
 		unsigned long *stack, unsigned long bp,
 		const struct stacktrace_ops *ops, void *data,
-		unsigned long *end, int *graph)
+		unsigned long *end, int *graph,
+		int with_sp)
 {
 	struct stack_frame *frame = (struct stack_frame *)bp;
 
@@ -97,11 +98,21 @@ print_context_stack(struct thread_info *tinfo,
 		addr = *stack;
 		if (__kernel_text_address(addr)) {
 			if ((unsigned long) stack == bp + sizeof(long)) {
-				ops->address(data, addr, 1);
+				if (with_sp) {
+					ops->address_with_sp(data,
+						addr, (unsigned long)stack);
+				} else {
+					ops->address(data, addr, 1);
+				}
 				frame = frame->next_frame;
 				bp = (unsigned long) frame;
 			} else {
-				ops->address(data, addr, 0);
+				if (with_sp) {
+					ops->address_with_sp(data,
+						addr, (unsigned long)stack);
+				} else {
+					ops->address(data, addr, 0);
+				}
 			}
 			print_ftrace_graph_addr(addr, data, ops, tinfo, graph);
 		}
@@ -115,7 +126,8 @@ unsigned long
 print_context_stack_bp(struct thread_info *tinfo,
 		       unsigned long *stack, unsigned long bp,
 		       const struct stacktrace_ops *ops, void *data,
-		       unsigned long *end, int *graph)
+		       unsigned long *end, int *graph,
+			int with_sp)
 {
 	struct stack_frame *frame = (struct stack_frame *)bp;
 	unsigned long *ret_addr = &frame->return_address;
@@ -125,8 +137,13 @@ print_context_stack_bp(struct thread_info *tinfo,
 
 		if (!__kernel_text_address(addr))
 			break;
+		if (with_sp) {
+			ops->address_with_sp(data,
+					addr, (unsigned long)stack);
+		} else {
+			ops->address(data, addr, 1);
+		}
 
-		ops->address(data, addr, 1);
 		frame = frame->next_frame;
 		ret_addr = &frame->return_address;
 		print_ftrace_graph_addr(addr, data, ops, tinfo, graph);
diff --git a/arch/x86/kernel/dumpstack_32.c b/arch/x86/kernel/dumpstack_32.c
index 11540a1..552eee6 100644
--- a/arch/x86/kernel/dumpstack_32.c
+++ b/arch/x86/kernel/dumpstack_32.c
@@ -23,6 +23,15 @@ void dump_trace(struct task_struct *task, struct pt_regs *regs,
 		unsigned long *stack, unsigned long bp,
 		const struct stacktrace_ops *ops, void *data)
 {
+	dump_trace_extended(task, regs, stack, bp, ops, data, 0);
+}
+EXPORT_SYMBOL(dump_trace);
+
+void dump_trace_extended(struct task_struct *task, struct pt_regs *regs,
+		unsigned long *stack, unsigned long bp,
+		const struct stacktrace_ops *ops,
+		void *data, unsigned int with_sp)
+{
 	int graph = 0;
 
 	if (!task)
@@ -53,7 +62,7 @@ void dump_trace(struct task_struct *task, struct pt_regs *regs,
 
 		context = (struct thread_info *)
 			((unsigned long)stack & (~(THREAD_SIZE - 1)));
-		bp = ops->walk_stack(context, stack, bp, ops, data, NULL, &graph);
+		bp = ops->walk_stack(context, stack, bp, ops, data, NULL, &graph, with_sp);
 
 		stack = (unsigned long *)context->previous_esp;
 		if (!stack)
@@ -63,7 +72,7 @@ void dump_trace(struct task_struct *task, struct pt_regs *regs,
 		touch_nmi_watchdog();
 	}
 }
-EXPORT_SYMBOL(dump_trace);
+EXPORT_SYMBOL(dump_trace_extended);
 
 void
 show_stack_log_lvl(struct task_struct *task, struct pt_regs *regs,
diff --git a/arch/x86/kernel/dumpstack_64.c b/arch/x86/kernel/dumpstack_64.c
index 272c9f1..e4e6599 100644
--- a/arch/x86/kernel/dumpstack_64.c
+++ b/arch/x86/kernel/dumpstack_64.c
@@ -144,6 +144,15 @@ void dump_trace(struct task_struct *task, struct pt_regs *regs,
 		unsigned long *stack, unsigned long bp,
 		const struct stacktrace_ops *ops, void *data)
 {
+	dump_trace_extended(task, regs, stack, bp, ops, data, 0);
+}
+EXPORT_SYMBOL(dump_trace);
+
+void dump_trace_extended(struct task_struct *task, struct pt_regs *regs,
+		unsigned long *stack, unsigned long bp,
+		const struct stacktrace_ops *ops,
+		void *data, unsigned int with_sp)
+{
 	const unsigned cpu = get_cpu();
 	unsigned long *irq_stack_end =
 		(unsigned long *)per_cpu(irq_stack_ptr, cpu);
@@ -190,7 +199,7 @@ void dump_trace(struct task_struct *task, struct pt_regs *regs,
 				break;
 
 			bp = ops->walk_stack(tinfo, stack, bp, ops,
-					     data, estack_end, &graph);
+					     data, estack_end, &graph, with_sp);
 			ops->stack(data, "<EOE>");
 			/*
 			 * We link to the next stack via the
@@ -209,7 +218,7 @@ void dump_trace(struct task_struct *task, struct pt_regs *regs,
 				if (ops->stack(data, "IRQ") < 0)
 					break;
 				bp = ops->walk_stack(tinfo, stack, bp,
-					ops, data, irq_stack_end, &graph);
+					ops, data, irq_stack_end, &graph, with_sp);
 				/*
 				 * We link to the next stack (which would be
 				 * the process stack normally) the last
@@ -229,10 +238,10 @@ void dump_trace(struct task_struct *task, struct pt_regs *regs,
 	/*
 	 * This handles the process stack:
 	 */
-	bp = ops->walk_stack(tinfo, stack, bp, ops, data, NULL, &graph);
+	bp = ops->walk_stack(tinfo, stack, bp, ops, data, NULL, &graph, with_sp);
 	put_cpu();
 }
-EXPORT_SYMBOL(dump_trace);
+EXPORT_SYMBOL(dump_trace_extended);
 
 void
 show_stack_log_lvl(struct task_struct *task, struct pt_regs *regs,
diff --git a/arch/x86/kernel/entry_32.S b/arch/x86/kernel/entry_32.S
index 44a8e0d..26e6776 100644
--- a/arch/x86/kernel/entry_32.S
+++ b/arch/x86/kernel/entry_32.S
@@ -455,6 +455,8 @@ sysenter_do_call:
 	cmpl $(nr_syscalls), %eax
 	jae syscall_badsys
 	call *sys_call_table(,%eax,4)
+	.globl ia32_sysenter_done
+ia32_sysenter_done:
 	movl %eax,PT_EAX(%esp)
 	LOCKDEP_SYS_EXIT
 	DISABLE_INTERRUPTS(CLBR_ANY)
@@ -539,6 +541,8 @@ ENTRY(system_call)
 	jae syscall_badsys
 syscall_call:
 	call *sys_call_table(,%eax,4)
+	.globl system_call_done
+system_call_done:
 	movl %eax,PT_EAX(%esp)		# store the return value
 syscall_exit:
 	LOCKDEP_SYS_EXIT
diff --git a/arch/x86/kernel/entry_64.S b/arch/x86/kernel/entry_64.S
index 0697ff1..a4cf012 100644
--- a/arch/x86/kernel/entry_64.S
+++ b/arch/x86/kernel/entry_64.S
@@ -174,6 +174,19 @@ ENTRY(native_usergs_sysret64)
 ENDPROC(native_usergs_sysret64)
 #endif /* CONFIG_PARAVIRT */
 
+#ifdef CONFIG_OPROFILE
+#define OPROF_ARGOFFSET		0
+#define OPROF_SAVE_REST		SAVE_REST
+#define OPROF_RESTORE_REST	RESTORE_REST
+#define	NORM_SAVE_REST
+#define NORM_RESTORE_REST
+#else
+#define OPROF_ARGOFFSET		ARGOFFSET
+#define OPROF_SAVE_REST
+#define OPROF_RESTORE_REST
+#define NORM_SAVE_REST		SAVE_REST
+#define NORM_RESTORE_REST	RESTORE_REST
+#endif
 
 .macro TRACE_IRQS_IRETQ offset=ARGOFFSET
 #ifdef CONFIG_TRACE_IRQFLAGS
@@ -343,6 +356,7 @@ END(save_args)
 
 ENTRY(save_rest)
 	PARTIAL_FRAME 1 REST_SKIP+8
+#ifndef CONFIG_OPROFILE
 	movq 5*8+16(%rsp), %r11	/* save return address */
 	movq_cfi rbx, RBX+16
 	movq_cfi rbp, RBP+16
@@ -351,6 +365,7 @@ ENTRY(save_rest)
 	movq_cfi r14, R14+16
 	movq_cfi r15, R15+16
 	movq %r11, 8(%rsp)	/* return address */
+#endif
 	FIXUP_TOP_OF_STACK %r11, 16
 	ret
 	CFI_ENDPROC
@@ -484,7 +499,11 @@ system_call_fastpath:
 	cmpq $__NR_syscall_max,%rax
 	ja badsys
 	movq %r10,%rcx
+	OPROF_SAVE_REST
 	call *sys_call_table(,%rax,8)  # XXX:	 rip relative
+	.globl system_call_done
+system_call_done:
+	OPROF_RESTORE_REST
 	movq %rax,RAX-ARGOFFSET(%rsp)
 /*
  * Syscall return path ending with SYSRET (fast path)
@@ -602,7 +621,11 @@ tracesys:
 	cmpq $__NR_syscall_max,%rax
 	ja   int_ret_from_sys_call	/* RAX(%rsp) set to -ENOSYS above */
 	movq %r10,%rcx	/* fixup for C */
+	OPROF_SAVE_REST
 	call *sys_call_table(,%rax,8)
+	.globl tracesys_done
+tracesys_done:
+	OPROF_RESTORE_REST
 	movq %rax,RAX-ARGOFFSET(%rsp)
 	/* Use IRET because user could have changed frame */
 
@@ -682,7 +705,9 @@ END(system_call)
 	.macro PTREGSCALL label,func,arg
 ENTRY(\label)
 	PARTIAL_FRAME 1 8		/* offset 8: return address */
+#ifndef CONFIG_OPROFILE
 	subq $REST_SKIP, %rsp
+#endif
 	CFI_ADJUST_CFA_OFFSET REST_SKIP
 	call save_rest
 	DEFAULT_FRAME 0 8		/* offset 8: return address */
@@ -702,6 +727,7 @@ END(\label)
 ENTRY(ptregscall_common)
 	DEFAULT_FRAME 1 8	/* offset 8: return address */
 	RESTORE_TOP_OF_STACK %r11, 8
+#ifndef CONFIG_OPROFILE
 	movq_cfi_restore R15+8, r15
 	movq_cfi_restore R14+8, r14
 	movq_cfi_restore R13+8, r13
@@ -709,6 +735,9 @@ ENTRY(ptregscall_common)
 	movq_cfi_restore RBP+8, rbp
 	movq_cfi_restore RBX+8, rbx
 	ret $REST_SKIP		/* pop extended registers */
+#else
+	ret
+#endif
 	CFI_ENDPROC
 END(ptregscall_common)
 
@@ -717,7 +746,7 @@ ENTRY(stub_execve)
 	popq %r11
 	CFI_ADJUST_CFA_OFFSET -8
 	CFI_REGISTER rip, r11
-	SAVE_REST
+	NORM_SAVE_REST
 	FIXUP_TOP_OF_STACK %r11
 	movq %rsp, %rcx
 	call sys_execve
@@ -736,7 +765,7 @@ ENTRY(stub_rt_sigreturn)
 	CFI_STARTPROC
 	addq $8, %rsp
 	CFI_ADJUST_CFA_OFFSET	-8
-	SAVE_REST
+	NORM_SAVE_REST
 	movq %rsp,%rdi
 	FIXUP_TOP_OF_STACK %r11
 	call sys_rt_sigreturn
diff --git a/arch/x86/oprofile/backtrace.c b/arch/x86/oprofile/backtrace.c
index 25d8b80..1057fb4 100644
--- a/arch/x86/oprofile/backtrace.c
+++ b/arch/x86/oprofile/backtrace.c
@@ -14,6 +14,25 @@
 #include <asm/ptrace.h>
 #include <asm/uaccess.h>
 #include <asm/stacktrace.h>
+#include <asm/proto.h>
+
+struct backtrace_data {
+	/* user input to enable kernel-syscall-userland tracing */
+	unsigned int trace_thru_syscall;
+
+	/* user frame pointer after return from the system call
+	 * frame adjusted by system_call_frame_test */
+	unsigned long bp;
+
+	/* handler to determine if unwind handler is system call frame */
+	void (*syscall_frame_test)(
+		void (*addr)(void),
+		unsigned long sp,
+		struct backtrace_data *backtrace_data);
+
+	/* backtrace depth, 0 implies no callstack tracing */
+	unsigned int depth;
+};
 
 static void backtrace_warning_symbol(void *data, char *msg,
 				     unsigned long symbol)
@@ -28,24 +47,36 @@ static void backtrace_warning(void *data, char *msg)
 
 static int backtrace_stack(void *data, char *name)
 {
-	/* Yes, we want all stacks */
-	return 0;
+	struct backtrace_data *bt_data = (struct backtrace_data *) data;
+	return bt_data->depth;
 }
 
 static void backtrace_address(void *data, unsigned long addr, int reliable)
 {
-	unsigned int *depth = data;
-
-	if ((*depth)--)
+	struct backtrace_data *bt_data = (struct backtrace_data *) data;
+	if (bt_data->depth--)
 		oprofile_add_trace(addr);
 }
 
+static void backtrace_address_with_sp(void *data, unsigned long addr,
+		unsigned long sp)
+{
+	struct backtrace_data *bt_data = (struct backtrace_data *) data;
+
+	/* check if return is from a system call */
+	bt_data->syscall_frame_test((void (*)(void)) addr, sp , bt_data);
+
+	/* log the address */
+	backtrace_address(data, addr, 1);
+}
+
 static struct stacktrace_ops backtrace_ops = {
 	.warning	= backtrace_warning,
 	.warning_symbol	= backtrace_warning_symbol,
 	.stack		= backtrace_stack,
 	.address	= backtrace_address,
 	.walk_stack	= print_context_stack,
+	.address_with_sp = backtrace_address_with_sp,
 };
 
 struct frame_head {
@@ -53,12 +84,24 @@ struct frame_head {
 	unsigned long ret;
 } __attribute__((packed));
 
+/* for 32 bit addresses on a 64 bit kernel */
 struct frame_head32 {
 	unsigned int bp;
 	unsigned int ret;
 } __attribute__((packed));
 
-#if CONFIG_IA32_EMULATION
+
+#if defined(CONFIG_IA32_EMULATION)
+#define SYSCALL_FRAME_TEST (test_thread_flag(TIF_32BIT) ? \
+	in_ia32_syscall_frame : \
+	in_x86_64_syscall_frame);
+#elif defined(CONFIG_X86_64)
+#define SYSCALL_FRAME_TEST in_x86_64_syscall_frame;
+#else /* X86-32 only */
+#define SYSCALL_FRAME_TEST in_x86_32_syscall_frame;
+#endif
+
+#if defined(CONFIG_IA32_EMULATION)
 #define OP_FRAME_SIZE (test_thread_flag(TIF_32BIT) ? \
 	sizeof(struct frame_head32) : \
 	sizeof(struct frame_head))
@@ -76,6 +119,62 @@ struct frame_head32 {
 #define GET_FRAME_BP(frame) (((struct frame_head *)frame)->bp)
 #endif
 
+/*
+ * The system call routines have setup a pt_regs structure
+ * after the return address currently pointed to by sp.
+ */
+static inline void set_basepointer(unsigned long sp,
+	struct backtrace_data *bt_data)
+{
+	struct pt_regs *regs;
+	sp += sizeof(void *);
+	regs = (struct pt_regs *)sp;
+	bt_data->bp = frame_pointer(regs);
+}
+
+#if defined(CONFIG_OPROFILE_MODULE)
+/*
+ * This causes system call traversal to fail, but the only other choice
+ * for oprofile as module is to export some dangerous symbols
+ */
+void system_call_done(void) {}
+void tracesys_done(void) {}
+void ia32_syscall_done(void) {}
+void ia32_sysenter_done(void) {}
+void ia32_cstar_done(void) {}
+#endif
+
+#if defined(CONFIG_X86_64)
+static inline void in_x86_64_syscall_frame(
+	void (*addr)(void), unsigned long sp,
+	struct backtrace_data *bt_data)
+{
+	if ((addr == system_call_done) || (addr == tracesys_done))
+		set_basepointer(sp, bt_data);
+}
+#endif
+
+#if defined(CONFIG_IA32_EMULATION)
+static inline void in_ia32_syscall_frame(
+	void (*addr)(void), unsigned long sp,
+	struct backtrace_data *bt_data)
+{
+	if ((addr == ia32_syscall_done) || (addr == ia32_cstar_done)
+		|| (addr == ia32_sysenter_done))
+		set_basepointer(sp, bt_data);
+}
+#endif
+
+#if defined(CONFIG_X86_32)
+static inline void in_x86_32_syscall_frame(
+	void (*addr)(void), unsigned long sp,
+	struct backtrace_data *bt_data)
+{
+	if ((addr == system_call_done) || (addr == ia32_sysenter_done))
+		set_basepointer(sp, bt_data);
+}
+#endif
+
 static struct frame_head *dump_user_backtrace(struct frame_head *head)
 {
 	/* large enough for both ia32 and x86_64 frames */
@@ -101,13 +200,25 @@ void
 x86_backtrace(struct pt_regs * const regs, unsigned int depth)
 {
 	struct frame_head *head = (struct frame_head *)frame_pointer(regs);
+	int trace_syscall = oprofile_get_trace_thru_syscall();
+	struct backtrace_data bt_data = {
+		.depth = depth,
+		.bp = 0,
+	};
+
+	bt_data.syscall_frame_test = SYSCALL_FRAME_TEST;
 
 	if (!user_mode_vm(regs)) {
 		unsigned long stack = kernel_stack_pointer(regs);
-		if (depth)
-			dump_trace(NULL, regs, (unsigned long *)stack, 0,
-				   &backtrace_ops, &depth);
-		return;
+		unsigned long bp = frame_pointer(regs);
+		/* if trace-syscall set, trace thru syscall
+		 * using callbacks that include sp with pc */
+		dump_trace_extended(NULL, regs, (unsigned long *)stack, bp,
+			   &backtrace_ops, &bt_data, trace_syscall);
+		if (bt_data.bp && oprofile_syscall_trace_boundary())
+			head = (struct frame_head *)bt_data.bp;
+		else
+			return;
 	}
 
 	while (depth-- && head)
-- 
1.6.5.2

