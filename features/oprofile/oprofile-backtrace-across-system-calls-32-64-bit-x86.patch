From e54f02ce1ec939fe5da5dcf7f054e530678da8ee Mon Sep 17 00:00:00 2001
From: Dave Lerner <Dave.Lerner@windriver.com>
Date: Wed, 5 Nov 2008 17:10:49 -0600
Subject: [PATCH] oprofile backtrace across system calls 32/64 bit x86 kernels

Adds systemcall backtracing, from kernel into user space.

The system call assembler routines are modified when oprofile
is configured into the kernel, such that a full, rather than partial,
pt_regs structure is pushed onto the stack. This struct includes
the frame pointer prior to the system call.  The new stack layout
allows oprofile backtrace to get to the user space frame pointer.

In traps_32/64.c, dump_trace_extended() uses new stacktrace_ops
callback that returns both pc and sp.  Oprofile x86_backtrace()
implements the new callback to reconstruct the pt_regs, and get to
the user frame pointer.

Signed-off-by: Dave Lerner <dave.lerner@windriver.com>
Zwane Mwaikambo <zwane.mwaikambo@windriver.com>
---
 arch/x86/ia32/ia32entry.S     |   65 ++++++++++++++++++----
 arch/x86/kernel/entry_32.S    |    4 +
 arch/x86/kernel/entry_64.S    |   33 +++++++++--
 arch/x86/kernel/traps_32.c    |   29 ++++++++--
 arch/x86/kernel/traps_64.c    |   33 +++++++++--
 arch/x86/oprofile/backtrace.c |  122 +++++++++++++++++++++++++++++++++++++----
 include/asm-x86/proto.h       |    7 ++
 include/asm-x86/stacktrace.h  |    9 +++
 8 files changed, 262 insertions(+), 40 deletions(-)

diff --git a/arch/x86/ia32/ia32entry.S b/arch/x86/ia32/ia32entry.S
index 2e246f3..f844c63 100644
--- a/arch/x86/ia32/ia32entry.S
+++ b/arch/x86/ia32/ia32entry.S
@@ -25,6 +25,31 @@
 #define sysretl_audit int_ret_from_sys_call
 #endif
 
+#ifdef CONFIG_OPROFILE
+#define OPROF_ARGOFFSET	0
+#else
+#define OPROF_ARGOFFSET ARGOFFSET
+#endif
+
+	.macro OPROF_SAVE_REST reg, tmp, savereg=1
+#ifdef CONFIG_OPROFILE
+	SAVE_REST
+	movq	RBP(%rsp), \tmp
+	.if \savereg
+	movq	\reg, RBP(%rsp)
+	.endif
+#endif
+	.endm
+
+	.macro OPROF_RESTORE_REST tmp, restorereg=1
+#ifdef CONFIG_OPROFILE
+	.if \restorereg
+	movq	\tmp, RBP(%rsp)
+	.endif
+	RESTORE_REST
+#endif
+	.endm
+
 #define IA32_NR_syscalls ((ia32_syscall_end - ia32_sys_call_table)/8)
 
 	.macro IA32_ARG_FIXUP noebp=0
@@ -159,7 +184,11 @@ ENTRY(ia32_sysenter_target)
 sysenter_do_call:
 	IA32_ARG_FIXUP 1
 sysenter_dispatch:
+	OPROF_SAVE_REST %r9, %r15
 	call	*ia32_sys_call_table(,%rax,8)
+	.globl ia32_sysenter_done
+ia32_sysenter_done:
+	OPROF_RESTORE_REST %r15
 	movq	%rax,RAX-ARGOFFSET(%rsp)
 	GET_THREAD_INFO(%r10)
 	DISABLE_INTERRUPTS(CLBR_NONE)
@@ -319,7 +348,11 @@ cstar_do_call:
 	ja  ia32_badsys
 	IA32_ARG_FIXUP 1
 cstar_dispatch:
+	OPROF_SAVE_REST %r9, %r15
 	call *ia32_sys_call_table(,%rax,8)
+	.globl ia32_cstar_done
+ia32_cstar_done:
+	OPROF_RESTORE_REST %r15
 	movq %rax,RAX-ARGOFFSET(%rsp)
 	GET_THREAD_INFO(%r10)
 	DISABLE_INTERRUPTS(CLBR_NONE)
@@ -428,7 +461,11 @@ ia32_do_syscall:
 	cmpl $(IA32_NR_syscalls-1),%eax
 	ja  int_ret_from_sys_call	/* ia32_tracesys has set RAX(%rsp) */
 	IA32_ARG_FIXUP
+	OPROF_SAVE_REST %rbp, %r15, 0
 	call *ia32_sys_call_table(,%rax,8) # xxx: rip relative
+	.globl ia32_syscall_done
+ia32_syscall_done:
+	OPROF_RESTORE_REST %r15, 0
 ia32_sysret:
 	movq %rax,RAX-ARGOFFSET(%rsp)
 	jmp int_ret_from_sys_call 
@@ -458,7 +495,7 @@ quiet_ni_syscall:
 	.globl \label
 \label:
 	leaq \func(%rip),%rax
-	leaq -ARGOFFSET+8(%rsp),\arg	/* 8 for return address */
+	leaq -OPROF_ARGOFFSET+8(%rsp),\arg	/* 8 for return address */
 	jmp  ia32_ptregs_common	
 	.endm
 
@@ -478,18 +515,22 @@ ENTRY(ia32_ptregs_common)
 	CFI_ENDPROC
 	CFI_STARTPROC32	simple
 	CFI_SIGNAL_FRAME
-	CFI_DEF_CFA	rsp,SS+8-ARGOFFSET
-	CFI_REL_OFFSET	rax,RAX-ARGOFFSET
-	CFI_REL_OFFSET	rcx,RCX-ARGOFFSET
-	CFI_REL_OFFSET	rdx,RDX-ARGOFFSET
-	CFI_REL_OFFSET	rsi,RSI-ARGOFFSET
-	CFI_REL_OFFSET	rdi,RDI-ARGOFFSET
-	CFI_REL_OFFSET	rip,RIP-ARGOFFSET
-/*	CFI_REL_OFFSET	cs,CS-ARGOFFSET*/
-/*	CFI_REL_OFFSET	rflags,EFLAGS-ARGOFFSET*/
-	CFI_REL_OFFSET	rsp,RSP-ARGOFFSET
-/*	CFI_REL_OFFSET	ss,SS-ARGOFFSET*/
+	CFI_DEF_CFA	rsp,SS+8-OPROF_ARGOFFSET
+	CFI_REL_OFFSET	rax,RAX-OPROF_ARGOFFSET
+	CFI_REL_OFFSET	rcx,RCX-OPROF_ARGOFFSET
+	CFI_REL_OFFSET	rdx,RDX-OPROF_ARGOFFSET
+	CFI_REL_OFFSET	rsi,RSI-OPROF_ARGOFFSET
+	CFI_REL_OFFSET	rdi,RDI-OPROF_ARGOFFSET
+	CFI_REL_OFFSET	rip,RIP-OPROF_ARGOFFSET
+/*	CFI_REL_OFFSET	cs,CS-OPROF_ARGOFFSET*/
+/*	CFI_REL_OFFSET	rflags,EFLAGS-OPROF_ARGOFFSET*/
+	CFI_REL_OFFSET	rsp,RSP-OPROF_ARGOFFSET
+/*	CFI_REL_OFFSET	ss,SS-OPROF_ARGOFFSET*/
+#ifdef CONFIG_OPROFILE
+	movq	%r15, RBP(%rsp)	/* SAVE_REST at syscall */
+#else
 	SAVE_REST
+#endif
 	call *%rax
 	RESTORE_REST
 	jmp  ia32_sysret	/* misbalances the return cache */
diff --git a/arch/x86/kernel/entry_32.S b/arch/x86/kernel/entry_32.S
index 2ff467d..fcf8c36 100644
--- a/arch/x86/kernel/entry_32.S
+++ b/arch/x86/kernel/entry_32.S
@@ -374,6 +374,8 @@ sysenter_do_call:
 	cmpl $(nr_syscalls), %eax
 	jae syscall_badsys
 	call *sys_call_table(,%eax,4)
+	.globl ia32_sysenter_done
+ia32_sysenter_done:
 	movl %eax,PT_EAX(%esp)
 	LOCKDEP_SYS_EXIT
 	DISABLE_INTERRUPTS(CLBR_ANY)
@@ -453,6 +455,8 @@ ENTRY(system_call)
 	jae syscall_badsys
 syscall_call:
 	call *sys_call_table(,%eax,4)
+	.globl system_call_done
+system_call_done:
 	movl %eax,PT_EAX(%esp)		# store the return value
 syscall_exit:
 	LOCKDEP_SYS_EXIT
diff --git a/arch/x86/kernel/entry_64.S b/arch/x86/kernel/entry_64.S
index 70a069a..341ae7b 100644
--- a/arch/x86/kernel/entry_64.S
+++ b/arch/x86/kernel/entry_64.S
@@ -178,6 +178,19 @@ ENTRY(native_usergs_sysret64)
 	sysretq
 #endif /* CONFIG_PARAVIRT */
 
+#ifdef CONFIG_OPROFILE
+#define OPROF_ARGOFFSET		0
+#define OPROF_SAVE_REST		SAVE_REST
+#define OPROF_RESTORE_REST	RESTORE_REST
+#define	NORM_SAVE_REST
+#define NORM_RESTORE_REST
+#else
+#define OPROF_ARGOFFSET		ARGOFFSET
+#define OPROF_SAVE_REST
+#define OPROF_RESTORE_REST
+#define NORM_SAVE_REST		SAVE_REST
+#define NORM_RESTORE_REST	RESTORE_REST
+#endif
 
 .macro TRACE_IRQS_IRETQ offset=ARGOFFSET
 #ifdef CONFIG_TRACE_IRQFLAGS
@@ -363,7 +376,11 @@ system_call_fastpath:
 	cmpq $__NR_syscall_max,%rax
 	ja badsys
 	movq %r10,%rcx
+	OPROF_SAVE_REST
 	call *sys_call_table(,%rax,8)  # XXX:	 rip relative
+	.globl system_call_done
+system_call_done:
+	OPROF_RESTORE_REST
 	movq %rax,RAX-ARGOFFSET(%rsp)
 /*
  * Syscall return path ending with SYSRET (fast path)
@@ -431,7 +448,9 @@ sysret_signal:
 	leaq do_notify_resume(%rip),%rax
 	leaq -ARGOFFSET(%rsp),%rdi # &pt_regs -> arg1
 	xorl %esi,%esi # oldset -> arg2
+	OPROF_SAVE_REST
 	call ptregscall_common
+	OPROF_RESTORE_REST
 	movl $_TIF_WORK_MASK,%edi
 	/* Use IRET because user could have changed frame. This
 	   works because ptregscall_common has called FIXUP_TOP_OF_STACK. */
@@ -497,7 +516,11 @@ tracesys:
 	cmpq $__NR_syscall_max,%rax
 	ja   int_ret_from_sys_call	/* RAX(%rsp) set to -ENOSYS above */
 	movq %r10,%rcx	/* fixup for C */
+	OPROF_SAVE_REST
 	call *sys_call_table(,%rax,8)
+	.globl tracesys_done
+tracesys_done:
+	OPROF_RESTORE_REST
 	movq %rax,RAX-ARGOFFSET(%rsp)
 	/* Use IRET because user could have changed frame */
 		
@@ -580,7 +603,7 @@ END(system_call)
 	.globl \label
 \label:
 	leaq	\func(%rip),%rax
-	leaq    -ARGOFFSET+8(%rsp),\arg /* 8 for return address */
+	leaq	-OPROF_ARGOFFSET+8(%rsp),\arg /* 8 for return address */
 	jmp	ptregscall_common
 END(\label)
 	.endm
@@ -597,7 +620,7 @@ ENTRY(ptregscall_common)
 	popq %r11
 	CFI_ADJUST_CFA_OFFSET -8
 	CFI_REGISTER rip, r11
-	SAVE_REST
+	NORM_SAVE_REST
 	movq %r11, %r15
 	CFI_REGISTER rip, r15
 	FIXUP_TOP_OF_STACK %r11
@@ -605,7 +628,7 @@ ENTRY(ptregscall_common)
 	RESTORE_TOP_OF_STACK %r11
 	movq %r15, %r11
 	CFI_REGISTER rip, r11
-	RESTORE_REST
+	NORM_RESTORE_REST
 	pushq %r11
 	CFI_ADJUST_CFA_OFFSET 8
 	CFI_REL_OFFSET rip, 0
@@ -618,7 +641,7 @@ ENTRY(stub_execve)
 	popq %r11
 	CFI_ADJUST_CFA_OFFSET -8
 	CFI_REGISTER rip, r11
-	SAVE_REST
+	NORM_SAVE_REST
 	FIXUP_TOP_OF_STACK %r11
 	movq %rsp, %rcx
 	call sys_execve
@@ -637,7 +660,7 @@ ENTRY(stub_rt_sigreturn)
 	CFI_STARTPROC
 	addq $8, %rsp
 	CFI_ADJUST_CFA_OFFSET	-8
-	SAVE_REST
+	NORM_SAVE_REST
 	movq %rsp,%rdi
 	FIXUP_TOP_OF_STACK %r11
 	call sys_rt_sigreturn
diff --git a/arch/x86/kernel/traps_32.c b/arch/x86/kernel/traps_32.c
index cb58dde..7dc15de 100644
--- a/arch/x86/kernel/traps_32.c
+++ b/arch/x86/kernel/traps_32.c
@@ -149,7 +149,8 @@ struct stack_frame {
 static inline unsigned long
 print_context_stack(struct thread_info *tinfo,
 		unsigned long *stack, unsigned long bp,
-		const struct stacktrace_ops *ops, void *data)
+		const struct stacktrace_ops *ops, void *data,
+		int with_sp)
 {
 	struct stack_frame *frame = (struct stack_frame *)bp;
 
@@ -159,11 +160,19 @@ print_context_stack(struct thread_info *tinfo,
 		addr = *stack;
 		if (__kernel_text_address(addr)) {
 			if ((unsigned long) stack == bp + 4) {
-				ops->address(data, addr, 1);
+				if (with_sp)
+					ops->address_with_sp(data,
+						addr, (unsigned long)stack);
+				else
+					ops->address(data, addr, 1);
 				frame = frame->next_frame;
 				bp = (unsigned long) frame;
 			} else {
-				ops->address(data, addr, bp == 0);
+				if (with_sp)
+					ops->address_with_sp(data,
+						addr, (unsigned long)stack);
+				else
+					ops->address(data, addr, bp == 0);
 			}
 		}
 		stack++;
@@ -175,6 +184,15 @@ void dump_trace(struct task_struct *task, struct pt_regs *regs,
 		unsigned long *stack, unsigned long bp,
 		const struct stacktrace_ops *ops, void *data)
 {
+	dump_trace_extended(task, regs, stack, bp, ops, data, 0);
+}
+EXPORT_SYMBOL(dump_trace);
+
+void dump_trace_extended(struct task_struct *task, struct pt_regs *regs,
+		unsigned long *stack, unsigned long bp,
+		const struct stacktrace_ops *ops,
+		void *data, unsigned int with_sp)
+{
 	if (!task)
 		task = current;
 
@@ -202,7 +220,8 @@ void dump_trace(struct task_struct *task, struct pt_regs *regs,
 
 		context = (struct thread_info *)
 			((unsigned long)stack & (~(THREAD_SIZE - 1)));
-		bp = print_context_stack(context, stack, bp, ops, data);
+		bp = print_context_stack(context, stack, bp, ops,
+			data, with_sp);
 		/*
 		 * Should be after the line below, but somewhere
 		 * in early boot context comes out corrupted and we
@@ -216,7 +235,7 @@ void dump_trace(struct task_struct *task, struct pt_regs *regs,
 		touch_nmi_watchdog();
 	}
 }
-EXPORT_SYMBOL(dump_trace);
+EXPORT_SYMBOL(dump_trace_extended);
 
 static void
 print_trace_warning_symbol(void *data, char *msg, unsigned long symbol)
diff --git a/arch/x86/kernel/traps_64.c b/arch/x86/kernel/traps_64.c
index 82c6520..34df3b5 100644
--- a/arch/x86/kernel/traps_64.c
+++ b/arch/x86/kernel/traps_64.c
@@ -192,7 +192,7 @@ static inline unsigned long
 print_context_stack(struct thread_info *tinfo,
 		unsigned long *stack, unsigned long bp,
 		const struct stacktrace_ops *ops, void *data,
-		unsigned long *end)
+		unsigned long *end, unsigned int with_sp)
 {
 	struct stack_frame *frame = (struct stack_frame *)bp;
 
@@ -202,11 +202,21 @@ print_context_stack(struct thread_info *tinfo,
 		addr = *stack;
 		if (__kernel_text_address(addr)) {
 			if ((unsigned long) stack == bp + 8) {
-				ops->address(data, addr, 1);
+				if (with_sp) {
+					ops->address_with_sp(data,
+						addr, (unsigned long)stack);
+				} else {
+					ops->address(data, addr, 1);
+				}
 				frame = frame->next_frame;
 				bp = (unsigned long) frame;
 			} else {
-				ops->address(data, addr, bp == 0);
+				if (with_sp) {
+					ops->address_with_sp(data,
+						addr, (unsigned long)stack);
+				} else {
+					ops->address(data, addr, bp == 0);
+				}
 			}
 		}
 		stack++;
@@ -218,6 +228,15 @@ void dump_trace(struct task_struct *task, struct pt_regs *regs,
 		unsigned long *stack, unsigned long bp,
 		const struct stacktrace_ops *ops, void *data)
 {
+	dump_trace_extended(task, regs, stack, bp, ops, data, 0);
+}
+EXPORT_SYMBOL(dump_trace);
+
+void dump_trace_extended(struct task_struct *task, struct pt_regs *regs,
+		unsigned long *stack, unsigned long bp,
+		const struct stacktrace_ops *ops, void *data,
+		unsigned int with_sp)
+{
 	const unsigned cpu = get_cpu();
 	unsigned long *irqstack_end = (unsigned long*)cpu_pda(cpu)->irqstackptr;
 	unsigned used = 0;
@@ -262,7 +281,7 @@ void dump_trace(struct task_struct *task, struct pt_regs *regs,
 				break;
 
 			bp = print_context_stack(tinfo, stack, bp, ops,
-							data, estack_end);
+				data, estack_end, with_sp);
 			ops->stack(data, "<EOE>");
 			/*
 			 * We link to the next stack via the
@@ -281,7 +300,7 @@ void dump_trace(struct task_struct *task, struct pt_regs *regs,
 				if (ops->stack(data, "IRQ") < 0)
 					break;
 				bp = print_context_stack(tinfo, stack, bp,
-						ops, data, irqstack_end);
+					ops, data, irqstack_end, with_sp);
 				/*
 				 * We link to the next stack (which would be
 				 * the process stack normally) the last
@@ -299,10 +318,10 @@ void dump_trace(struct task_struct *task, struct pt_regs *regs,
 	/*
 	 * This handles the process stack:
 	 */
-	bp = print_context_stack(tinfo, stack, bp, ops, data, NULL);
+	bp = print_context_stack(tinfo, stack, bp, ops, data, NULL, with_sp);
 	put_cpu();
 }
-EXPORT_SYMBOL(dump_trace);
+EXPORT_SYMBOL(dump_trace_extended);
 
 static void
 print_trace_warning_symbol(void *data, char *msg, unsigned long symbol)
diff --git a/arch/x86/oprofile/backtrace.c b/arch/x86/oprofile/backtrace.c
index 1a29913..8a67050 100644
--- a/arch/x86/oprofile/backtrace.c
+++ b/arch/x86/oprofile/backtrace.c
@@ -14,6 +14,25 @@
 #include <asm/ptrace.h>
 #include <asm/uaccess.h>
 #include <asm/stacktrace.h>
+#include <asm/proto.h>
+
+struct backtrace_data {
+	/* user input to enable kernel-syscall-userland tracing */
+	unsigned int trace_thru_syscall;
+
+	/* user frame pointer after return from the system call
+	 * frame adjusted by system_call_frame_test */
+	unsigned long bp;
+
+	/* handler to determine if unwind handler is system call frame */
+	void (*syscall_frame_test)(
+		void (*addr)(void),
+		unsigned long sp,
+		struct backtrace_data *backtrace_data);
+
+	/* backtrace depth, 0 implies no callstack tracing */
+	unsigned int depth;
+};
 
 static void backtrace_warning_symbol(void *data, char *msg,
 				     unsigned long symbol)
@@ -28,23 +47,35 @@ static void backtrace_warning(void *data, char *msg)
 
 static int backtrace_stack(void *data, char *name)
 {
-	/* Yes, we want all stacks */
-	return 0;
+	struct backtrace_data *bt_data = (struct backtrace_data *) data;
+	return bt_data->depth;
 }
 
 static void backtrace_address(void *data, unsigned long addr, int reliable)
 {
-	unsigned int *depth = data;
-
-	if ((*depth)--)
+	struct backtrace_data *bt_data = (struct backtrace_data *) data;
+	if (bt_data->depth--)
 		oprofile_add_trace(addr);
 }
 
+static void backtrace_address_with_sp(void *data, unsigned long addr,
+		unsigned long sp)
+{
+	struct backtrace_data *bt_data = (struct backtrace_data *) data;
+
+	/* check if return is from a system call */
+	bt_data->syscall_frame_test((void (*)(void)) addr, sp , bt_data);
+
+	/* log the address */
+	backtrace_address(data, addr, 1);
+}
+
 static struct stacktrace_ops backtrace_ops = {
 	.warning = backtrace_warning,
 	.warning_symbol = backtrace_warning_symbol,
 	.stack = backtrace_stack,
 	.address = backtrace_address,
+	.address_with_sp = backtrace_address_with_sp,
 };
 
 struct frame_head {
@@ -52,12 +83,24 @@ struct frame_head {
 	unsigned long ret;
 } __attribute__((packed));
 
+/* for 32 bit addresses on a 64 bit kernel */
 struct frame_head32 {
 	unsigned int bp;
 	unsigned int ret;
 } __attribute__((packed));
 
-#if CONFIG_IA32_EMULATION
+
+#if defined(CONFIG_IA32_EMULATION)
+#define SYSCALL_FRAME_TEST (test_thread_flag(TIF_32BIT) ? \
+	in_ia32_syscall_frame : \
+	in_x86_64_syscall_frame);
+#elif defined(CONFIG_X86_64)
+#define SYSCALL_FRAME_TEST in_x86_64_syscall_frame;
+#else /* X86-32 only */
+#define SYSCALL_FRAME_TEST in_x86_32_syscall_frame;
+#endif
+
+#if defined(CONFIG_IA32_EMULATION)
 #define OP_FRAME_SIZE (test_thread_flag(TIF_32BIT) ? \
 	sizeof(struct frame_head32) : \
 	sizeof(struct frame_head))
@@ -75,6 +118,51 @@ struct frame_head32 {
 #define GET_FRAME_BP(frame) (((struct frame_head *)frame)->bp)
 #endif
 
+/*
+ * The system call routines have setup a pt_regs structure
+ * after the return address currently pointed to by sp.
+ */
+static inline void set_basepointer(unsigned long sp,
+	struct backtrace_data *bt_data)
+{
+	struct pt_regs *regs;
+	sp += sizeof(void *);
+	regs = (struct pt_regs *)sp;
+	bt_data->bp = frame_pointer(regs);
+}
+
+
+#if defined(CONFIG_X86_64)
+static inline void in_x86_64_syscall_frame(
+	void (*addr)(void), unsigned long sp,
+	struct backtrace_data *bt_data)
+{
+	if ((addr == system_call_done) || (addr == tracesys_done))
+		set_basepointer(sp, bt_data);
+}
+#endif
+
+#if defined(CONFIG_IA32_EMULATION)
+static inline void in_ia32_syscall_frame(
+	void (*addr)(void), unsigned long sp,
+	struct backtrace_data *bt_data)
+{
+	if ((addr == ia32_syscall_done) || (addr == ia32_cstar_done)
+		|| (addr == ia32_sysenter_done))
+		set_basepointer(sp, bt_data);
+}
+#endif
+
+#if defined(CONFIG_X86_32)
+static inline void in_x86_32_syscall_frame(
+	void (*addr)(void), unsigned long sp,
+	struct backtrace_data *bt_data)
+{
+	if ((addr == system_call_done) || (addr == ia32_sysenter_done))
+		set_basepointer(sp, bt_data);
+}
+#endif
+
 static struct frame_head *
 dump_user_backtrace(struct frame_head * head)
 {
@@ -102,14 +190,26 @@ x86_backtrace(struct pt_regs * const regs, unsigned int depth)
 {
 	struct frame_head *head = (struct frame_head *)frame_pointer(regs);
 	unsigned long stack = kernel_trap_sp(regs);
+	int trace_syscall = oprofile_get_trace_thru_syscall();
+	struct backtrace_data bt_data = {
+		.depth = depth,
+		.bp = 0,
+	};
+
+	bt_data.syscall_frame_test = SYSCALL_FRAME_TEST;
 
 	if (!user_mode_vm(regs)) {
-		if (depth)
-			dump_trace(NULL, regs, (unsigned long *)stack, 0,
-				   &backtrace_ops, &depth);
-		return;
-	}
+		unsigned long bp = frame_pointer(regs);
+		/* if trace-syscall set, trace thru syscall
+		 * using callbacks that include sp with pc */
+		dump_trace_extended(NULL, regs, (unsigned long *)stack, bp,
+			   &backtrace_ops, &bt_data, trace_syscall);
+		if (bt_data.bp && oprofile_syscall_trace_boundary())
+			head = (struct frame_head *)bt_data.bp;
+		else
+			return;
 
+	}
 	while (depth-- && head)
 		head = dump_user_backtrace(head);
 }
diff --git a/include/asm-x86/proto.h b/include/asm-x86/proto.h
index 3dd458c..2843cff 100644
--- a/include/asm-x86/proto.h
+++ b/include/asm-x86/proto.h
@@ -14,6 +14,13 @@ extern void ia32_syscall(void);
 extern void ia32_cstar_target(void);
 extern void ia32_sysenter_target(void);
 
+/* for oprofile system call checks */
+extern void system_call_done(void);
+extern void tracesys_done(void);
+extern void ia32_syscall_done(void);
+extern void ia32_cstar_done(void);
+extern void ia32_sysenter_done(void);
+
 extern void syscall32_cpu_init(void);
 
 extern void check_efer(void);
diff --git a/include/asm-x86/stacktrace.h b/include/asm-x86/stacktrace.h
index 30f8252..f81aea4 100644
--- a/include/asm-x86/stacktrace.h
+++ b/include/asm-x86/stacktrace.h
@@ -10,6 +10,9 @@ struct stacktrace_ops {
 	/* msg must contain %s for the symbol */
 	void (*warning_symbol)(void *data, char *msg, unsigned long symbol);
 	void (*address)(void *data, unsigned long address, int reliable);
+	/* returns return address and sp for this address  */
+	void (*address_with_sp)(void *data, unsigned long address,
+		unsigned long sp);
 	/* On negative return stop dumping */
 	int (*stack)(void *data, char *name);
 };
@@ -18,4 +21,10 @@ void dump_trace(struct task_struct *tsk, struct pt_regs *regs,
 		unsigned long *stack, unsigned long bp,
 		const struct stacktrace_ops *ops, void *data);
 
+/* extends the callbacks to include address_with_sp() */
+void dump_trace_extended(struct task_struct *tsk, struct pt_regs *regs,
+		unsigned long *stack, unsigned long bp,
+		const struct stacktrace_ops *ops, void *data,
+		unsigned int with_stack);
+
 #endif
-- 
1.6.0.90.g436ed

