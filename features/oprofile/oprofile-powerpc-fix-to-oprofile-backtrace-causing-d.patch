From 6f74b2a8b6d1dd91d3282d128a092a05b456781b Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Fri, 16 Oct 2009 10:26:32 +0800
Subject: [PATCH 12/21] oprofile: powerpc: fix to oprofile backtrace causing deadlock

backtrace into user space may trigger a page fault when an
oprofile event happens in kernel space. This patch guarantees
that kernel gets out of page fault exception along a fast path
instead of trying to hold mmap lock to traverse vma to verify
the address causing page fault exception. In rare situation
mmap lock has been held in advance like brk, which may lead to
a deadlock.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
Signed-off-by: Dave Lerner <dave.lerner@windriver.com>
---
 arch/powerpc/oprofile/backtrace.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/arch/powerpc/oprofile/backtrace.c b/arch/powerpc/oprofile/backtrace.c
index 3117ffe..a9232da 100755
--- a/arch/powerpc/oprofile/backtrace.c
+++ b/arch/powerpc/oprofile/backtrace.c
@@ -9,8 +9,8 @@
 
 #include <linux/oprofile.h>
 #include <linux/sched.h>
+#include <linux/uaccess.h>
 #include <asm/processor.h>
-#include <asm/uaccess.h>
 #include <asm/compat.h>
 #include <asm/syscalls.h>
 
@@ -45,7 +45,7 @@ static unsigned int user_getsp32(unsigned int sp, int is_first)
 	 * which means that we've done all that we can do from
 	 * interrupt context.
 	 */
-	if (__copy_from_user_inatomic(stack_frame, p, sizeof(stack_frame)))
+	if (probe_kernel_read(stack_frame, p, sizeof(stack_frame)))
 		return 0;
 
 	if (!is_first)
@@ -66,7 +66,7 @@ static unsigned long user_getsp64(unsigned long sp, int is_first)
 	if (!access_ok(VERIFY_READ, (void __user *)sp, sizeof(stack_frame)))
 		return 0;
 
-	if (__copy_from_user_inatomic(stack_frame, (void __user *)sp,
+	if (probe_kernel_read(stack_frame, (void __user *)sp,
 					sizeof(stack_frame)))
 		return 0;
 
-- 
1.6.5.2

