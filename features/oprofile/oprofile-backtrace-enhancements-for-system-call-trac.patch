From 05cec0dfff99c26ed529cb9b08d97407052f6a87 Mon Sep 17 00:00:00 2001
From: Dave Lerner <Dave.Lerner@windriver.com>
Date: Tue, 21 Oct 2008 17:38:08 -0500
Subject: [PATCH 1/1] Oprofile backtrace enhancements for system call tracing - arch independent

Previous versions of the upstream oprofile package rejected traces
that spanned addresses from kernel to user process space.
This patch adds support utilities for the kernel/user backtraces
without impacting the standard (0.9.4) oprofile daemon and post-processing
oprofile tools.

The patch changes oprofile driver to read and write a new oprofile parameter,
/dev/oprofile/enhanced_backtrace.  The parameter is used to switch on or
off logic in arch/*/oprofile/backtrace.c to trace across the system call
boundary (these backtrace.c patches are in development). In this patch,
the changes to read/write the enhanced_backtrace parameter follow the
pattern for other oprofile files.

The patch also adds oprofile_syscall_trace_boundary() for
kernel/user boundary tracing, to flag a transition from kernel space to
user space in the oprofile data stream.

---
 drivers/oprofile/cpu_buffer.c     |   23 +++++++++++++++++++
 drivers/oprofile/cpu_buffer.h     |    1 +
 drivers/oprofile/oprof.c          |   25 +++++++++++++++++++++
 drivers/oprofile/oprof.h          |    3 ++
 drivers/oprofile/oprofile_files.c |   43 +++++++++++++++++++++++++++++++++++++
 include/linux/oprofile.h          |   12 ++++++++++
 6 files changed, 107 insertions(+), 0 deletions(-)

diff --git a/drivers/oprofile/cpu_buffer.c b/drivers/oprofile/cpu_buffer.c
index 7ba78e6..bd98892 100644
--- a/drivers/oprofile/cpu_buffer.c
+++ b/drivers/oprofile/cpu_buffer.c
@@ -285,6 +285,29 @@ void oprofile_add_trace(unsigned long pc)
 }
 
 /*
+ * This serves to add an escape code to indicate switching into
+ * user space during tracing across the sysetm call boundary
+ */
+int oprofile_syscall_trace_boundary(void)
+{
+	struct oprofile_cpu_buffer *cpu_buf = &__get_cpu_var(cpu_buffer);
+
+	if (!cpu_buf || !cpu_buf->tracing)
+		return 0;
+
+	if (nr_available_slots(cpu_buf) < 1) {
+		cpu_buf->tracing = 0;
+		cpu_buf->sample_lost_overflow++;
+		return 0;
+	}
+
+	/* Set buffer state to user to prevent traces from being filtered out */
+	cpu_buf->last_is_kernel = 0;
+	add_code(cpu_buf, CPU_IS_USER);
+	return 1;
+}
+
+/*
  * This serves to avoid cpu buffer overflow, and makes sure
  * the task mortuary progresses
  *
diff --git a/drivers/oprofile/cpu_buffer.h b/drivers/oprofile/cpu_buffer.h
index c3e366b..ee50fca 100644
--- a/drivers/oprofile/cpu_buffer.h
+++ b/drivers/oprofile/cpu_buffer.h
@@ -53,6 +53,7 @@ DECLARE_PER_CPU(struct oprofile_cpu_buffer, cpu_buffer);
 void cpu_buffer_reset(struct oprofile_cpu_buffer * cpu_buf);
 
 /* transient events for the CPU buffer -> event buffer */
+#define CPU_IS_USER 0
 #define CPU_IS_KERNEL 1
 #define CPU_TRACE_BEGIN 2
 
diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index 2c64517..8a930a1 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -24,6 +24,7 @@ struct oprofile_operations oprofile_ops;
 
 unsigned long oprofile_started;
 unsigned long backtrace_depth;
+static unsigned int trace_thru_syscall;
 static unsigned long is_setup;
 static DEFINE_MUTEX(start_mutex);
 
@@ -179,6 +180,30 @@ out:
 	return err;
 }
 
+int oprofile_set_trace_thru_syscall(unsigned int val)
+{
+	int err = 0;
+
+	mutex_lock(&start_mutex);
+
+	if (oprofile_started) {
+		err = -EBUSY;
+	goto out;
+	}
+
+	trace_thru_syscall = val;
+
+out:
+	mutex_unlock(&start_mutex);
+	return err;
+}
+
+int oprofile_get_trace_thru_syscall(void)
+{
+	return trace_thru_syscall;
+}
+
+
 static int __init oprofile_init(void)
 {
 	int err;
diff --git a/drivers/oprofile/oprof.h b/drivers/oprofile/oprof.h
index 1832365..da7dee0 100644
--- a/drivers/oprofile/oprof.h
+++ b/drivers/oprofile/oprof.h
@@ -35,5 +35,8 @@ void oprofile_create_files(struct super_block * sb, struct dentry * root);
 void oprofile_timer_init(struct oprofile_operations * ops);
 
 int oprofile_set_backtrace(unsigned long depth);
+
+/* custom agent capabilities, currently just one - trace thru system call */
+#define OPROFILE_SYSCALL_TRACE_ENABLE 0x1
  
 #endif /* OPROF_H */
diff --git a/drivers/oprofile/oprofile_files.c b/drivers/oprofile/oprofile_files.c
index ef953ba..3170159 100644
--- a/drivers/oprofile/oprofile_files.c
+++ b/drivers/oprofile/oprofile_files.c
@@ -118,6 +118,47 @@ static const struct file_operations dump_fops = {
 	.write		= dump_write,
 };
  
+
+static ssize_t enhanced_backtrace_read(struct file *file,
+		char __user *buf, size_t count, loff_t *offset)
+{
+	return oprofilefs_ulong_to_user(oprofile_get_trace_thru_syscall(),
+			buf, count, offset);
+}
+
+
+static ssize_t enhanced_backtrace_write(struct file *file,
+		char const __user *buf, size_t count, loff_t *offset)
+{
+	unsigned long val;
+	int retval = 0;
+
+	if (*offset)
+		return -EINVAL;
+
+	retval = oprofilefs_ulong_from_user(&val, buf, count);
+	if (retval)
+		return retval;
+
+	/* Allow for additional backtracing features, but for now the only
+	 * additional capability is tracing across the system call boundary
+	 */
+	if (val & OPROFILE_SYSCALL_TRACE_ENABLE)
+		retval = oprofile_set_trace_thru_syscall(1);
+
+	if (retval)
+		return retval;
+
+	return count;
+}
+
+
+static const struct file_operations enhanced_backtrace_fops = {
+	.read       = enhanced_backtrace_read,
+	.write      = enhanced_backtrace_write,
+};
+
+
 void oprofile_create_files(struct super_block * sb, struct dentry * root)
 {
 	oprofilefs_create_file(sb, root, "enable", &enable_fops);
@@ -129,6 +170,8 @@ void oprofile_create_files(struct super_block * sb, struct dentry * root)
 	oprofilefs_create_file(sb, root, "cpu_type", &cpu_type_fops); 
 	oprofilefs_create_file(sb, root, "backtrace_depth", &depth_fops);
 	oprofilefs_create_file(sb, root, "pointer_size", &pointer_size_fops);
+	oprofilefs_create_file(sb, root,
+			"enhanced_backtrace", &enhanced_backtrace_fops);
 	oprofile_create_stats_files(sb, root);
 	if (oprofile_ops.create_files)
 		oprofile_ops.create_files(sb, root);
diff --git a/include/linux/oprofile.h b/include/linux/oprofile.h
index 041bb31..a32b2e8 100644
--- a/include/linux/oprofile.h
+++ b/include/linux/oprofile.h
@@ -161,4 +161,16 @@ int oprofilefs_ulong_from_user(unsigned long * val, char const __user * buf, siz
 /** lock for read/write safety */
 extern spinlock_t oprofilefs_lock;
  
+/* Set and get the flag indicating that the oprofile device reader expects
+ *  backtraces across the system call
+ */
+int oprofile_set_trace_thru_syscall(unsigned int enable);
+int oprofile_get_trace_thru_syscall(void);
+
+/*
+ * Add an escape code to the cpu buffer indicate switching into
+ * user space during tracing across the system call boundary
+ */
+int oprofile_syscall_trace_boundary(void);
+
 #endif /* OPROFILE_H */
-- 
1.5.5.1

