From 310aa850840bcfad0f4c77a1744c28ec41a6e1ac Mon Sep 17 00:00:00 2001
From: Dave Lerner <dave.lerner@windriver.com>
Date: Wed, 27 Apr 2011 11:50:35 -0500
Subject: [PATCH] oprofile: Add preempt protection around usage of smp_processor_id()

For multi-core SMP processor configurations, the smp_processor_id()
function and usage of returned value must be protected from switching
cores.  Calls to preempt_disable() and preempt_enable() provide the
barriers for the core switch.

During oprofile NMI initialization for p4 model processors, this
protection was absent resulting in kernel warning messages from each
core of a multi-core model P4 target. The warning messages were
appropriate because NMI register could have been misconfigured as a
result of the missing core switch protections.

Signed-off-by: Dave Lerner <dave.lerner@windriver.com>
---
 arch/x86/oprofile/op_model_p4.c |   24 ++++++++++++++++--------
 1 files changed, 16 insertions(+), 8 deletions(-)

diff --git a/arch/x86/oprofile/op_model_p4.c b/arch/x86/oprofile/op_model_p4.c
index e6a160a..933e6f6 100644
--- a/arch/x86/oprofile/op_model_p4.c
+++ b/arch/x86/oprofile/op_model_p4.c
@@ -368,10 +368,9 @@ static struct p4_event_binding p4_events[NUM_EVENTS] = {
 /* this assigns a "stagger" to the current CPU, which is used throughout
    the code in this module as an extra array offset, to select the "even"
    or "odd" part of all the divided resources. */
-static unsigned int get_stagger(void)
+static unsigned int get_stagger(int cpu)
 {
 #ifdef CONFIG_SMP
-	int cpu = smp_processor_id();
 	return cpu != cpumask_first(__get_cpu_var(cpu_sibling_map));
 #endif
 	return 0;
@@ -392,7 +391,7 @@ static void p4_fill_in_addresses(struct op_msrs * const msrs)
 	unsigned int addr, cccraddr, stag;
 
 	setup_num_counters();
-	stag = get_stagger();
+	stag = get_stagger(get_cpu());
 
 	/* the counter & cccr registers we pay attention to */
 	for (i = 0; i < num_counters; ++i) {
@@ -468,6 +467,7 @@ static void p4_fill_in_addresses(struct op_msrs * const msrs)
 			msrs->controls[i++].addr = MSR_P4_CRU_ESCR5;
 		}
 	}
+	put_cpu();
 }
 
 
@@ -482,7 +482,7 @@ static void pmc_setup_one_p4_counter(unsigned int ctr)
 	struct p4_event_binding *ev = NULL;
 	unsigned int stag;
 
-	stag = get_stagger();
+	stag = get_stagger(get_cpu());
 
 	/* convert from counter *number* to counter *bit* */
 	counter_bit = 1 << VIRT_CTR(stag, ctr);
@@ -492,6 +492,7 @@ static void pmc_setup_one_p4_counter(unsigned int ctr)
 		printk(KERN_ERR
 		       "oprofile: P4 event code 0x%lx out of range\n",
 		       counter_config[ctr].event);
+		put_cpu();
 		return;
 	}
 
@@ -526,10 +527,12 @@ static void pmc_setup_one_p4_counter(unsigned int ctr)
 				CCCR_SET_PMI_OVF_1(cccr);
 			wrmsr(p4_counters[VIRT_CTR(stag, ctr)].cccr_address,
 			      cccr, high);
+			put_cpu();
 			return;
 		}
 	}
 
+	put_cpu();
 	printk(KERN_ERR
 	       "oprofile: P4 event code 0x%lx no binding, stag %d ctr %d\n",
 	       counter_config[ctr].event, stag, ctr);
@@ -543,11 +546,12 @@ static void p4_setup_ctrs(struct op_x86_model_spec const *model,
 	unsigned int low, high;
 	unsigned int stag;
 
-	stag = get_stagger();
+	stag = get_stagger(get_cpu());
 
 	rdmsr(MSR_IA32_MISC_ENABLE, low, high);
 	if (!MISC_PMC_ENABLED_P(low)) {
 		printk(KERN_ERR "oprofile: P4 PMC not available\n");
+		put_cpu();
 		return;
 	}
 
@@ -579,6 +583,7 @@ static void p4_setup_ctrs(struct op_x86_model_spec const *model,
 			reset_value[i] = 0;
 		}
 	}
+	put_cpu();
 }
 
 
@@ -588,7 +593,7 @@ static int p4_check_ctrs(struct pt_regs * const regs,
 	unsigned long ctr, low, high, stag, real;
 	int i;
 
-	stag = get_stagger();
+	stag = get_stagger(get_cpu());
 
 	for (i = 0; i < num_counters; ++i) {
 
@@ -630,6 +635,7 @@ static int p4_check_ctrs(struct pt_regs * const regs,
 	/* P4 quirk: you have to re-unmask the apic vector */
 	apic_write(APIC_LVTPC, apic_read(APIC_LVTPC) & ~APIC_LVT_MASKED);
 
+	put_cpu();
 	/* See op_model_ppro.c */
 	return 1;
 }
@@ -640,7 +646,7 @@ static void p4_start(struct op_msrs const * const msrs)
 	unsigned int low, high, stag;
 	int i;
 
-	stag = get_stagger();
+	stag = get_stagger(get_cpu());
 
 	for (i = 0; i < num_counters; ++i) {
 		if (!reset_value[i])
@@ -649,6 +655,7 @@ static void p4_start(struct op_msrs const * const msrs)
 		CCCR_SET_ENABLE(low);
 		wrmsr(p4_counters[VIRT_CTR(stag, i)].cccr_address, low, high);
 	}
+	put_cpu();
 }
 
 
@@ -657,7 +664,7 @@ static void p4_stop(struct op_msrs const * const msrs)
 	unsigned int low, high, stag;
 	int i;
 
-	stag = get_stagger();
+	stag = get_stagger(get_cpu());
 
 	for (i = 0; i < num_counters; ++i) {
 		if (!reset_value[i])
@@ -666,6 +673,7 @@ static void p4_stop(struct op_msrs const * const msrs)
 		CCCR_SET_DISABLE(low);
 		wrmsr(p4_counters[VIRT_CTR(stag, i)].cccr_address, low, high);
 	}
+	put_cpu();
 }
 
 static void p4_shutdown(struct op_msrs const * const msrs)
-- 
1.6.5.2

