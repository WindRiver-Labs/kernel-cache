From e4a5baf9d625194723ba4a6f714a275355be9a0d Mon Sep 17 00:00:00 2001
From: Wenlin Kang <wenlin.kang@windriver.com>
Date: Fri, 11 Apr 2014 10:20:42 +0800
Subject: [PATCH] powerpc/oprofile: fixed a backtrace error.

When running oprofile with this set of options "--callgraph",
eg, "opcontrol --callgraph=3", kernel will trigger panic.

Oops: Kernel access of bad area, sig: 11 [#1]
PREEMPT LTT NESTING LEVEL : 0
SBC8548
last sysfs file: /sys/kernel/uevent_seqnum
Modules linked in: x_tables ip_tables ipv6 sctp binfmt_misc
NIP: c048ea5c LR: c048ea44 CTR: 00000000
REGS: c06dfc00 TRAP: 0300   Not tainted  (2.6.34.13-grsec-WR4.3.0.0_cgl)
MSR: 00021000 <ME,CE>  CR: 24002022  XER: 20000000
DEAR: 00000188, ESR: 00000000
TASK = c06ac3a0[0] 'swapper' THREAD: c06de000
GPR00: c0011d30 c06dfcb0 c06ac3a0 00000000 c06dfed4 00000000 c06dfcbc cfb2ca48
GPR08: 00000000 00000000 cfa8ff20 00000004 4bb7faa0 f0a1aabc 0ffff900 ffffffff
GPR16: 00000001 00000000 007fff00 00000000 00000000 0fffa180 c06de000 c06d8340
GPR24: c07b83bc c06dfd80 c06e603c c06e6038 c06dfcb8 00000000 ffffffff c06dfed0
NIP [c048ea5c] op_powerpc_backtrace+0xfc/0x1b8
LR [c048ea44] op_powerpc_backtrace+0xe4/0x1b8
Call Trace:
[c06dfcb0] [c048ea44] op_powerpc_backtrace+0xe4/0x1b8 (unreliable)
[c06dfcf0] [c048c324] oprofile_add_ext_sample+0x7c/0x98
[c06dfd10] [c048ecec] fsl_emb_handle_interrupt+0x158/0x1ac
[c06dfd40] [c048e5b4] op_handle_interrupt+0x28/0x38
[c06dfd50] [c000e154] performance_monitor_exception+0x54/0x124
[c06dfd70] [c0011ce4] ret_from_except_full+0x0/0x4c
---
 arch/powerpc/oprofile/backtrace.c |   11 +++++++++--
 1 files changed, 9 insertions(+), 2 deletions(-)

diff --git a/arch/powerpc/oprofile/backtrace.c b/arch/powerpc/oprofile/backtrace.c
index d524dd6..524960a 100755
--- a/arch/powerpc/oprofile/backtrace.c
+++ b/arch/powerpc/oprofile/backtrace.c
@@ -54,7 +54,11 @@ static unsigned int user_getsp32(unsigned int sp, int is_first)
 
 	if (!is_first) {
 		unsigned long stack_lr = STACK_LR32(stack_frame);
-		unsigned long vdso_base = current->mm->context.vdso_base;
+		unsigned long vdso_base = 0;
+		
+		/* Is it from a kernel thread ? */
+		if (current->mm) 
+			vdso_base = current->mm->context.vdso_base;
 
 		if ( vdso_base && 
 		    ((stack_lr == vdso_base + vdso32_sigtramp) ||
@@ -88,7 +92,10 @@ static unsigned long user_getsp64(unsigned long sp, int is_first)
 
 	if (!is_first) {
 		unsigned long stack_lr = STACK_LR64(stack_frame);
-		unsigned long vdso_base = current->mm->context.vdso_base;
+		unsigned long vdso_base = 0;
+
+		if (current->mm)	
+			vdso_base = current->mm->context.vdso_base;
 
 		if ( vdso_base &&
 		    ((stack_lr == vdso_base + vdso32_sigtramp) ||
-- 
1.7.5.4

