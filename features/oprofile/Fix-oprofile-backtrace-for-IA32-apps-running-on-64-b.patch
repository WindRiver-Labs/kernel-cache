From 043d5cb870551420637e99320de9291ad54c5042 Mon Sep 17 00:00:00 2001
From: Dave Lerner <Dave.Lerner@windriver.com>
Date: Thu, 23 Oct 2008 13:57:01 -0500
Subject: [PATCH 1/1] Fix oprofile backtrace for IA32 apps running on 64 bit kernel

In oprofile backtrace on x86_64, test if the current process is a 
32 bit app.  If so, then use a different frame struct, with a 32 
bit bp, to backtrace through user address space.

This patch is adapted from a customer specific patch developed by
Jason Wessel to correctly unwind 32-bit application stacks 
running on an X86_64 target for oprofile.

Signed-off-by: Dave Lerner <Dave.Lerner@windriver.com>
---
 arch/x86/oprofile/backtrace.c |   34 +++++++++++++++++++++++++++++-----
 1 files changed, 29 insertions(+), 5 deletions(-)

diff --git a/arch/x86/oprofile/backtrace.c b/arch/x86/oprofile/backtrace.c
index e2095cb..1a29913 100644
--- a/arch/x86/oprofile/backtrace.c
+++ b/arch/x86/oprofile/backtrace.c
@@ -52,25 +52,49 @@ struct frame_head {
 	unsigned long ret;
 } __attribute__((packed));
 
+struct frame_head32 {
+	unsigned int bp;
+	unsigned int ret;
+} __attribute__((packed));
+
+#if CONFIG_IA32_EMULATION
+#define OP_FRAME_SIZE (test_thread_flag(TIF_32BIT) ? \
+	sizeof(struct frame_head32) : \
+	sizeof(struct frame_head))
+#define GET_FRAME_RET(frame) (test_thread_flag(TIF_32BIT) ? \
+	((struct frame_head32 *)frame)->ret : \
+	((struct frame_head *)frame)->ret)
+#define GET_FRAME_BP(frame) \
+	(test_thread_flag(TIF_32BIT) ? \
+	(struct frame_head *)((unsigned long)\
+		((struct frame_head32 *)frame)->bp):\
+	((struct frame_head *)frame)->bp)
+#else
+#define OP_FRAME_SIZE (sizeof(struct frame_head))
+#define GET_FRAME_RET(frame) (((struct frame_head *)frame)->ret)
+#define GET_FRAME_BP(frame) (((struct frame_head *)frame)->bp)
+#endif
+
 static struct frame_head *
 dump_user_backtrace(struct frame_head * head)
 {
+	/* large enough for both ia32 and x86_64 frames */
 	struct frame_head bufhead[2];
 
 	/* Also check accessibility of one struct frame_head beyond */
-	if (!access_ok(VERIFY_READ, head, sizeof(bufhead)))
+	if (!access_ok(VERIFY_READ, head, OP_FRAME_SIZE))
 		return NULL;
-	if (__copy_from_user_inatomic(bufhead, head, sizeof(bufhead)))
+	if (__copy_from_user_inatomic(bufhead, head, OP_FRAME_SIZE))
 		return NULL;
 
-	oprofile_add_trace(bufhead[0].ret);
+	oprofile_add_trace(GET_FRAME_RET(bufhead));
 
 	/* frame pointers should strictly progress back up the stack
 	 * (towards higher addresses) */
-	if (head >= bufhead[0].bp)
+	if (head >= GET_FRAME_BP(bufhead))
 		return NULL;
 
-	return bufhead[0].bp;
+	return GET_FRAME_BP(bufhead);
 }
 
 void
-- 
1.5.5.1

