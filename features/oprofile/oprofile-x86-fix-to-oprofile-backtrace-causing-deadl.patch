From 85f5f626b08e05673318cec2e8a39844b7df6da8 Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Fri, 16 Oct 2009 10:26:34 +0800
Subject: [PATCH 09/21] oprofile:x86: fix to oprofile backtrace causing deadlock

backtrace into user space may trigger a page fault when an
oprofile event happens in kernel space. This patch guarantees
that kernel gets out of page fault exception along a fast path
instead of trying to hold mmap lock to traverse vma to verify
the address causing page fault exception. In rare situation
mmap lock has been held in advance like brk, which may lead to
a deadlock.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
Signed-off-by: Dave Lerner <dave.lerner@windriver.com>
---
 arch/x86/oprofile/backtrace.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/x86/oprofile/backtrace.c b/arch/x86/oprofile/backtrace.c
index b32fb0e..a80f5d4 100644
--- a/arch/x86/oprofile/backtrace.c
+++ b/arch/x86/oprofile/backtrace.c
@@ -11,10 +11,10 @@
 #include <linux/oprofile.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
+#include <linux/uaccess.h>
 #include <linux/highmem.h>
 
 #include <asm/ptrace.h>
-#include <asm/uaccess.h>
 #include <asm/stacktrace.h>
 #include <asm/proto.h>
 #include "../kernel/oprofile_sysret_lookup.h"
@@ -215,10 +215,8 @@ static struct frame_head *dump_user_backtrace(struct frame_head *head)
 	/* Also check accessibility of one struct frame_head beyond: */
 	/* large enough for both ia32 and x86_64 frames */
 	struct frame_head bufhead[2];
-	unsigned long bytes;
 
-	bytes = copy_from_user_nmi(bufhead, head, OP_FRAME_SIZE);
-	if (bytes != sizeof(bufhead))
+	if (probe_kernel_read(bufhead, head, OP_FRAME_SIZE))
 		return NULL;
 
 	oprofile_add_trace(GET_FRAME_RET(bufhead));
-- 
1.6.5.2

