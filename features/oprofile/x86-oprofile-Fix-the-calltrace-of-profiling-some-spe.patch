From c117ae8937113644f7c15e8ac352fa2f0af05ecc Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Fri, 10 Aug 2012 10:33:19 +0800
Subject: [PATCH] x86/oprofile: Fix the calltrace of profiling some specified
 events

* Upon enabling the call-graph funcationality of oprofile to profile
  some specified event, A few minutes later the following calltrace
  will always occur. Assume a scenario that do_softirq() switchs the
  stack to a soft irq stack, and the soft irq stack is totally empty.
  At this moment, a nmi interrupt occurs. subsequently, the hardware
  will not automatically save SS and SP registers but only save EFLAGS,
  CS and IP. as the CPU is in kernel mode. the current soft irq stack like this:
  +--------------+<-----the top of soft irq
  |   EFLAGS     |
  +--------------+
  |    CS        |
  +--------------+
  |    IP        |
  +--------------+
  |   SAVE_ALL   |
  +--------------+
  but the return value of kernel_stack_pointer() function ,which invoked by
  x86_backtrace function, is '&regs->sp' for X86_32 CPU. the type of
  regs poniter is pt_regs structure. It is obvious that the return value
  is not in the range of soft irq stack, as the SP register is not save
  in the soft irq stack.
  Therefore the fix is working around the issue by detecting whether the
  return value of the kernel_stack_pointer() function is valid or not.
  If not, immediately return and avoid the invalid value is passed to
  backtrace/calltrace code such as dump_trace().

  BUG: unable to handle kernel paging request at 636f7270
  IP: [<c1005229>] print_context_stack+0x69/0x130
  *pde = 00000000
  Oops: 0000 [#1] PREEMPT SMP
  LTT NESTING LEVEL : 0
  Modules linked in:

  Pid: 0, comm: swapper/0 Not tainted
  3.4.6-WR5.0+snapshot-20120801_standard #9 To be filled by O.E.M. To be
  filled by O.E.M./To be filled by O.E.M.
  EIP: 0060:[<c1005229>] EFLAGS: 00010046 CPU: 0
  EIP is at print_context_stack+0x69/0x130
  EAX: 0000002e EBX: 636f7270 ECX: 00000000 EDX: 04010000
  ESI: ffffe000 EDI: 00000000 EBP: f680be98 ESP: f680be68
   DS: 007b ES: 007b FS: 00d8 GS: 0000 SS: 0068
   CR0: 8005003b CR2: 636f7270 CR3: 0192e000 CR4: 000007d0
   DR0: 00000000 DR1: 00000000 DR2: 00000000 DR3: 00000000
   DR6: ffff0ff0 DR7: 00000400
   Process swapper/0 (pid: 0, ti=f680a000 task=c183cfa0
			   task.ti=c1832000)
   Stack:
    c1761c2c 636f7270 636f6000 00000000 636f7ffc 636f6000 c1833ed4 ffffe000
    c1833ed4 636f7270 c18888dc 636f6000 f680bec8 c1004218 c18888dc f680bedc
	00000000 f680beb4 c1833ed4 00000000 f680bec0 c1833ed4 f680bfc4 0000000a
   Call Trace:
	[<c1004218>] dump_trace+0x68/0xf0
	[<c1554682>] x86_backtrace+0xb2/0xc0
	[<c1552682>] oprofile_add_sample+0xa2/0xc0
	[<c10040df>] ? do_softirq+0x6f/0xa0
	[<c15562c9>] ppro_check_ctrs+0x79/0x100
	[<c1556250>] ? ppro_shutdown+0x60/0x60
	[<c15550af>] profile_exceptions_notify+0x8f/0xb0
	[<c1660d78>] nmi_handle.isra.0+0x48/0x70
	[<c1660e9f>] do_nmi+0xff/0x570
	[<c105bd75>] ? run_rebalance_domains+0x155/0x180
	[<c105428b>] ? get_parent_ip+0xb/0x40
	[<c102e379>] ? __local_bh_enable+0x29/0x70
	[<c102ecd0>] ? ftrace_define_fields_irq_handler_entry+0x80/0x80
	[<c16601c9>] nmi_stack_correct+0x28/0x2d
	[<c102ecd0>] ? ftrace_define_fields_irq_handler_entry+0x80/0x80
	[<c10040df>] ? do_softirq+0x6f/0xa0
   <IRQ>
    [<c102f155>] irq_exit+0x65/0x70
	[<c1666441>] do_IRQ+0x51/0xc0
    [<c1666369>] common_interrupt+0x29/0x30
	[<c102007b>] ? amd_get_subcaches+0x4b/0x90
	[<c1330416>] ? intel_idle+0xc6/0x120
	[<c14e4719>] cpuidle_enter+0x19/0x30
	[<c14e4cf0>] cpuidle_idle_call+0xa0/0x320
	[<c1009e8a>] cpu_idle+0x5a/0xc0
	[<c163fa48>] rest_init+0x6c/0x74
	[<c189d703>] start_kernel+0x2fe/0x305
	[<c189d23d>] ?repair_env_string+0x51/0x51
	[<c189d078>] i386_start_kernel+0x78/0x7d
   Code: 00 00 3b 5d dc 72 13 8b 45 f0 8d
         64 24 24 5b 5e 5f 5d c3 8d b4 26
		 00 00 00 00 3b 5d ec 72 e8 81 fb
		 ff ff ff bf 0f 86 a3 00 00 00 <8b>
		 33 89 f0 e8 ae e5 03 00 85 c0 74
		 1e 8b 45 f0 83 c0 04 39 c3
   EIP: [<c1005229>]
   print_context_stack+0x69/0x130 SS:ESP 0068:f680be68 CR2: 00000000636f7270
   ---[ end trace d4af25ee5ff6fd8c ]---

Signed-off-by: Yang Wei <wei.yang@windriver.com>
---
 arch/x86/oprofile/backtrace.c |   17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/arch/x86/oprofile/backtrace.c b/arch/x86/oprofile/backtrace.c
index d6aa6e8..1cb4145 100644
--- a/arch/x86/oprofile/backtrace.c
+++ b/arch/x86/oprofile/backtrace.c
@@ -17,6 +17,18 @@
 #include <asm/ptrace.h>
 #include <asm/stacktrace.h>
 
+static inline int valid_stack_ptr(struct thread_info *tinfo,
+			void *p, unsigned int size, void *end)
+{
+	void *t = tinfo;
+	if (end) {
+		if (p < end && p >= (end-THREAD_SIZE))
+			return 1;
+		else
+			return 0;
+	}
+	return p > t && p < t + THREAD_SIZE - size;
+}
 static int backtrace_stack(void *data, char *name)
 {
 	/* Yes, we want all stacks */
@@ -110,9 +122,14 @@ void
 x86_backtrace(struct pt_regs * const regs, unsigned int depth)
 {
 	struct stack_frame *head = (struct stack_frame *)frame_pointer(regs);
+	struct thread_info *context;
 
 	if (!user_mode_vm(regs)) {
 		unsigned long stack = kernel_stack_pointer(regs);
+		context = (struct thread_info *)
+			(stack & (~(THREAD_SIZE - 1)));
+		if (!valid_stack_ptr(context, (void *)stack, sizeof(stack), NULL))
+			return;
 		if (depth)
 			dump_trace(NULL, regs, (unsigned long *)stack, 0,
 				   &backtrace_ops, &depth);
-- 
1.7.9.7

