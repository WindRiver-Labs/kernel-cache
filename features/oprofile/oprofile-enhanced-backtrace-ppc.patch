From: Dave Lerner <dave.lerner@windriver.com>
Subject: oprofile: statistics per callstack for PPC

Enhances PPC Oprofile to provide statistics per callstack 
that cross the system call boundary. 

Signed-off-by: Zhenghui Liao <Zhenghui.Liao@windriver.com>
Signed-off-by: Dave Lerner <dave.lerner@windriver.com>
Signed-off-by: Zwane Mwaikambo <Zwane Mwaikambo@windriver.com>

 arch/powerpc/include/asm/syscalls.h |   10 ++++
 arch/powerpc/oprofile/backtrace.c   |   79 ++++++++++++++++++++++++++----------
 2 files changed, 68 insertions(+), 21 deletions(-)

diff --git a/arch/powerpc/include/asm/syscalls.h b/arch/powerpc/include/asm/syscalls.h
index eb8eb40..5490ab5 100644
--- a/arch/powerpc/include/asm/syscalls.h
+++ b/arch/powerpc/include/asm/syscalls.h
@@ -48,5 +48,15 @@ asmlinkage long sys_sigaltstack(const stack_t __user *uss,
 		stack_t __user *uoss, unsigned long r5, unsigned long r6,
 		unsigned long r7, unsigned long r8, struct pt_regs *regs);
 
+
+/* for Oprofile tracing across system call */
+#ifdef CONFIG_PPC64
+asmlinkage void system_call_common(void);
+asmlinkage void save_nvgprs(void);
+#else
+asmlinkage void DoSyscall(void);
+asmlinkage void handle_page_fault(void);
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* __ASM_POWERPC_SYSCALLS_H */
diff --git a/arch/powerpc/oprofile/backtrace.c b/arch/powerpc/oprofile/backtrace.c
index b4278cf..2052db0 100644
--- a/arch/powerpc/oprofile/backtrace.c
+++ b/arch/powerpc/oprofile/backtrace.c
@@ -12,6 +12,7 @@
 #include <asm/processor.h>
 #include <asm/uaccess.h>
 #include <asm/compat.h>
+#include <asm/syscalls.h>
 
 #define STACK_SP(STACK)		*(STACK)
 
@@ -69,16 +69,39 @@ static unsigned long user_getsp64(unsigned long sp, int is_first)
 }
 #endif
 
-static unsigned long kernel_getsp(unsigned long sp, int is_first)
+static unsigned long kernel_getsp(unsigned long sp, unsigned long child_sp,
+		int is_first, int trace_sys, unsigned long *user_frame_sp)
 {
 	unsigned long *stack_frame = (unsigned long *)sp;
 
-	if (!validate_sp(sp, current, STACK_FRAME_OVERHEAD))
-		return 0;
+	if (!validate_sp(sp, current, STACK_FRAME_OVERHEAD)) {
+		if (trace_sys)
+			return 0;
 
+		if (child_sp) {
+			unsigned long *frame = (unsigned long *)child_sp;
+			/* check if last frame in a syscall */
+			unsigned long pc = STACK_LR(frame);
+#ifdef CONFIG_PPC64
+			if (pc >= (unsigned long)system_call_common
+				&& pc <= (unsigned long)save_nvgprs)
+#else
+			if (pc >= (unsigned long)DoSyscall
+				&& pc <= (unsigned long)handle_page_fault)
+#endif
+			{
+				struct pt_regs *user_regs;
+				user_regs = ((struct pt_regs *) ((unsigned long)
+						task_thread_info(current)
+						+ THREAD_SIZE)) - 1;
+				*user_frame_sp = user_regs->gpr[1];
+				return 1; /* syscall traversal*/
+			}
+		}
+		return 0;
+	}
 	if (!is_first)
 		oprofile_add_trace(STACK_LR(stack_frame));
-
 	/*
 	 * We do not enforce increasing stack addresses here because
 	 * we might be transitioning from an interrupt stack to a kernel
@@ -90,6 +113,7 @@ static unsigned long kernel_getsp(unsigned long sp, int is_first)
 
 void op_powerpc_backtrace(struct pt_regs * const regs, unsigned int depth)
 {
+	int trace_syscall = oprofile_get_trace_thru_syscall();
 	unsigned long sp = regs->gpr[1];
 	int first_frame = 1;
 
@@ -97,31 +121,43 @@ void op_powerpc_backtrace(struct pt_regs * const regs, unsigned int depth)
 	depth += 1;
 
 	if (!user_mode(regs)) {
+		unsigned long child_sp = 0;
+		unsigned long parent_sp = 0;
+		unsigned long user_frame_sp = 0;
 		while (depth--) {
-			sp = kernel_getsp(sp, first_frame);
-			if (!sp)
-				break;
-			first_frame = 0;
-		}
-	} else {
-#ifdef CONFIG_PPC64
-		if (!test_thread_flag(TIF_32BIT)) {
-			while (depth--) {
-				sp = user_getsp64(sp, first_frame);
-				if (!sp)
+			parent_sp = kernel_getsp(sp, child_sp,
+				first_frame, trace_syscall, &user_frame_sp);
+			if (!parent_sp)
+				return; /* not in syscall*/
+			if (parent_sp == 1) { /* in a syscall boundary*/
+				if (oprofile_syscall_trace_boundary()) {
+					sp = user_frame_sp;
 					break;
-				first_frame = 0;
+				}
+				return;
 			}
-
-			return;
+			first_frame = 0;
+			child_sp = sp;
+			sp = parent_sp;
 		}
-#endif
-
+	}
+#ifdef CONFIG_PPC64
+	if (!test_thread_flag(TIF_32BIT)) {
 		while (depth--) {
-			sp = user_getsp32(sp, first_frame);
+			sp = user_getsp64(sp, first_frame);
 			if (!sp)
 				break;
 			first_frame = 0;
 		}
+
+		return;
+	}
+#endif
+
+	while (depth--) {
+		sp = user_getsp32(sp, first_frame);
+		if (!sp)
+			break;
+		first_frame = 0;
 	}
 }
