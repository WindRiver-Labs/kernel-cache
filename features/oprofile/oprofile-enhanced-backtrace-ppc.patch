From f0328b9147723cfeb8c88132837d98ed10ae5018 Mon Sep 17 00:00:00 2001
From: Dave Lerner <dave.lerner@windriver.com>
Date: Mon, 23 Feb 2009 13:16:01 -0500
Subject: [PATCH] oprofile: statistics per callstack for PPC

Enhances PPC Oprofile to provide statistics per callstack
that cross the system call boundary.

Signed-off-by: Zhenghui Liao <Zhenghui.Liao@windriver.com>
Signed-off-by: Dave Lerner <dave.lerner@windriver.com>
Signed-off-by: Zwane Mwaikambo <Zwane Mwaikambo@windriver.com>
---
 arch/powerpc/include/asm/syscalls.h |   10 ++++
 arch/powerpc/oprofile/backtrace.c   |   79 +++++++++++++++++++++++++---------
 arch/powerpc/oprofile/common.c      |    5 ++-
 3 files changed, 72 insertions(+), 22 deletions(-)

diff --git a/arch/powerpc/include/asm/syscalls.h b/arch/powerpc/include/asm/syscalls.h
index eb8eb40..5490ab5 100644
--- a/arch/powerpc/include/asm/syscalls.h
+++ b/arch/powerpc/include/asm/syscalls.h
@@ -48,5 +48,15 @@ asmlinkage long sys_sigaltstack(const stack_t __user *uss,
 		stack_t __user *uoss, unsigned long r5, unsigned long r6,
 		unsigned long r7, unsigned long r8, struct pt_regs *regs);
 
+
+/* for Oprofile tracing across system call */
+#ifdef CONFIG_PPC64
+asmlinkage void system_call_common(void);
+asmlinkage void save_nvgprs(void);
+#else
+asmlinkage void DoSyscall(void);
+asmlinkage void handle_page_fault(void);
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* __ASM_POWERPC_SYSCALLS_H */
diff --git a/arch/powerpc/oprofile/backtrace.c b/arch/powerpc/oprofile/backtrace.c
index c2bd5ea..f4f2786 100644
--- a/arch/powerpc/oprofile/backtrace.c
+++ b/arch/powerpc/oprofile/backtrace.c
@@ -12,6 +12,7 @@
 #include <asm/processor.h>
 #include <asm/uaccess.h>
 #include <asm/compat.h>
+#include <asm/syscalls.h>
 #include <asm/vdso.h>
 
 #define ROOT_STACK_SP		0
@@ -98,16 +99,39 @@ static unsigned long user_getsp64(unsigned long sp, int is_first)
 }
 #endif
 
-static unsigned long kernel_getsp(unsigned long sp, int is_first)
+static unsigned long kernel_getsp(unsigned long sp, unsigned long child_sp,
+		int is_first, int trace_sys, unsigned long *user_frame_sp)
 {
 	unsigned long *stack_frame = (unsigned long *)sp;
 
-	if (!validate_sp(sp, current, STACK_FRAME_OVERHEAD))
-		return 0;
+	if (!validate_sp(sp, current, STACK_FRAME_OVERHEAD)) {
+		if (trace_sys)
+			return 0;
 
+		if (child_sp) {
+			unsigned long *frame = (unsigned long *)child_sp;
+			/* check if last frame in a syscall */
+			unsigned long pc = STACK_LR(frame);
+#ifdef CONFIG_PPC64
+			if (pc >= (unsigned long)system_call_common
+				&& pc <= (unsigned long)save_nvgprs)
+#else
+			if (pc >= (unsigned long)DoSyscall
+				&& pc <= (unsigned long)handle_page_fault)
+#endif
+			{
+				struct pt_regs *user_regs;
+				user_regs = ((struct pt_regs *) ((unsigned long)
+						task_thread_info(current)
+						+ THREAD_SIZE)) - 1;
+				*user_frame_sp = user_regs->gpr[1];
+				return 1; /* syscall traversal*/
+			}
+		}
+		return 0;
+	}
 	if (!is_first)
 		oprofile_add_trace(STACK_LR(stack_frame));
-
 	/*
 	 * We do not enforce increasing stack addresses here because
 	 * we might be transitioning from an interrupt stack to a kernel
@@ -119,6 +143,7 @@ static unsigned long kernel_getsp(unsigned long sp, int is_first)
 
 void op_powerpc_backtrace(struct pt_regs * const regs, unsigned int depth)
 {
+	int trace_syscall = oprofile_get_trace_thru_syscall();
 	unsigned long sp = regs->gpr[1];
 	int first_frame = 1;
 
@@ -126,31 +151,43 @@ void op_powerpc_backtrace(struct pt_regs * const regs, unsigned int depth)
 	depth += 1;
 
 	if (!user_mode(regs)) {
+		unsigned long child_sp = 0;
+		unsigned long parent_sp = 0;
+		unsigned long user_frame_sp = 0;
 		while (depth--) {
-			sp = kernel_getsp(sp, first_frame);
-			if (!sp)
-				break;
-			first_frame = 0;
-		}
-	} else {
-#ifdef CONFIG_PPC64
-		if (!test_thread_flag(TIF_32BIT)) {
-			while (depth--) {
-				sp = user_getsp64(sp, first_frame);
-				if (!sp)
+			parent_sp = kernel_getsp(sp, child_sp,
+				first_frame, trace_syscall, &user_frame_sp);
+			if (!parent_sp)
+				return; /* not in syscall*/
+			if (parent_sp == 1) { /* in a syscall boundary*/
+				if (oprofile_syscall_trace_boundary()) {
+					sp = user_frame_sp;
 					break;
-				first_frame = 0;
+				}
+				return;
 			}
-
-			return;
+			first_frame = 0;
+			child_sp = sp;
+			sp = parent_sp;
 		}
-#endif
-
+	}
+#ifdef CONFIG_PPC64
+	if (!test_thread_flag(TIF_32BIT)) {
 		while (depth--) {
-			sp = user_getsp32(sp, first_frame);
+			sp = user_getsp64(sp, first_frame);
 			if (!sp)
 				break;
 			first_frame = 0;
 		}
+
+		return;
+	}
+#endif
+
+	while (depth--) {
+		sp = user_getsp32(sp, first_frame);
+		if (!sp)
+			break;
+		first_frame = 0;
 	}
 }
diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 17807ac..b9bd233 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -170,6 +170,10 @@ static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
 
 int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
+    /* set the callback even if there is no device support,
+       since the RTC will provide interrupts in that case.
+     */
+	ops->backtrace = op_powerpc_backtrace;
 	if (!cur_cpu_spec->oprofile_cpu_type)
 		return -ENODEV;
 
@@ -219,7 +223,6 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	ops->shutdown = op_powerpc_shutdown;
 	ops->start = op_powerpc_start;
 	ops->stop = op_powerpc_stop;
-	ops->backtrace = op_powerpc_backtrace;
 
 	printk(KERN_DEBUG "oprofile: using %s performance monitoring.\n",
 	       ops->cpu_type);
-- 
1.7.0.4

