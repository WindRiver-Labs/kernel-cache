From d3ab8407f827fa06f42db08ba48690ac13809669 Mon Sep 17 00:00:00 2001
From: Dave Lerner <dave.lerner@windriver.com>
Date: Wed, 18 Jul 2012 13:24:45 -0400
Subject: [PATCH] Unconditionally enable oprofile backtrace for powerpc
 architectures

Make the assignment of the backtrace callback pointer unconditional.
The assignment was done after checking that the core variant and
PMC information was correctly setup, but backtrace logic for oprofile
doesn't rely on performance monitor registers.

In the original logic, oprofile is not disabled when PMC hardware
is not available.  Instead for the qemuppc target, oprofile sampling
triggers with the jiffy timer interrupt.  Since the original logic
enabled oprofile on a target without PMC hardware, there is no reason
not to enable backtrace when the oprofile sample is taken, the logic
added by this patch.

Signed-off-by: Dave Lerner <dave.lerner@windriver.com>
---
 arch/powerpc/oprofile/common.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 4f51025..0912563 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -191,6 +191,11 @@ static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
 
 int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
+	/*
+	 * Set the call back even if not PMC device support
+	 * since the RTC will provide interrupts in that case.
+	 */
+	ops->backtrace = op_powerpc_backtrace;
 	if (!cur_cpu_spec->oprofile_cpu_type)
 		return -ENODEV;
 
@@ -237,7 +242,6 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	ops->shutdown = op_powerpc_shutdown;
 	ops->start = op_powerpc_start;
 	ops->stop = op_powerpc_stop;
-	ops->backtrace = op_powerpc_backtrace;
 
 	printk(KERN_DEBUG "oprofile: using %s performance monitoring.\n",
 	       ops->cpu_type);
-- 
1.7.9.7

