From 5199454f722ed2bdc92e3f4cb871bad15bbc06c6 Mon Sep 17 00:00:00 2001
From: Roy Li <rongqing.li@windriver.com>
Date: Thu, 29 May 2014 08:32:10 +0800
Subject: [PATCH] x86: Fix access_ok range overflow

This patch is from PaX Team <pageexec@freemail.hu>

The syscall "write" should work when the parameter buf is NULL and count is
Zero, like in the setprocattrcon_raw function of src/procattr.c of libselinux
package:
	write(fd, NULL, 0)

but SELinux and Grsecurity block this syscall, since when read address 0,
the kernel maybe think this address is the extension of stack, and will expand
the stack to cover 0 address, but CONFIG_LSM_MMAP_MIN_ADDR donot allow to mmap
this address

SELinux log:
	type=1400 audit(1400092329.542:3): avc: denied { mmap_zero } for pid=344 comm="udevd"
	scontext=system_u:system_r:udev_t:s0-s15:c0.c1023 tcontext=system_u:system_r:udev_t:s0-s15:c0.c1023 tclass=memprotect

Grsec log:
	grsec: denied resource overstep by requesting 4005206347776 for RLIMIT_STACK
	against limit 8388608 for /lib/udev/udevd[udevd:344] uid/euid:0/0 gid/egid:0/0,
	parent /etc/init.d/udev[S04udev:337] uid/euid:0/0 gid/egid:0/0

The call stack is below:
 [<ffffffff8135c712>] selinux_mmap_addr+0x42/0x70
 [<ffffffff81357dc6>] security_mmap_addr+0x16/0x20
 [<ffffffff81131e98>] expand_downwards+0x38/0x2e0
 [<ffffffff81132164>] expand_stack+0x24/0x40
 [<ffffffff81871694>] __do_page_fault+0x3f4/0x640
 [<ffffffff81160898>] ? path_openat+0x148/0x520
 [<ffffffff81142886>] ? kmem_cache_alloc+0x206/0x230
 [<ffffffff818718ee>] do_page_fault+0xe/0x10
 [<ffffffff8186e828>] page_fault+0x38/0x40
 [<ffffffff813c44a5>] ? __get_user_1+0x25/0x30
 [<ffffffff8115020c>] ? vfs_write+0x21c/0x250
 [<ffffffff81150ac9>] SyS_write+0x49/0xa0
 [<ffffffff81875aae>] system_call_fastpath+0x18/0x1d

The issue is in the access_ok which is called by vfs_write.  the variable of
 __end_ao is becoming the huge value if the address and size are zero.

unsigned long __end_ao = (unsigned long)0 + (unsigned long)0 -1;

then __end_ao is 0xffffffffffffffff, the prefault function in access_ok, which is
from GRsecurity patch, will trigger page fault for 0 address if the stack is lowest
address, but if the size is 0, we do not need to read this buffer, and this
buffer is not a valid address.

So if the size is 0, donot do the page prefault

Signed-off-by: Roy Li <rongqing.li@windriver.com>
---
 arch/x86/include/asm/uaccess.h |   34 ++++++++++++++++++----------------
 1 files changed, 18 insertions(+), 16 deletions(-)

diff --git a/arch/x86/include/asm/uaccess.h b/arch/x86/include/asm/uaccess.h
index 74590b9..88afc48 100644
--- a/arch/x86/include/asm/uaccess.h
+++ b/arch/x86/include/asm/uaccess.h
@@ -86,26 +86,28 @@ void set_fs(mm_segment_t x);
 #define __access_ok(type, addr, size) (likely(__range_not_ok(addr, size, user_addr_max()) == 0))
 #define access_ok(type, addr, size)					\
 ({									\
-	long __size = size;						\
+	unsigned long __size = size;					\
 	unsigned long __addr = (unsigned long)addr;			\
-	unsigned long __addr_ao = __addr & PAGE_MASK;			\
-	unsigned long __end_ao = __addr + __size - 1;			\
 	bool __ret_ao = __range_not_ok(__addr, __size, user_addr_max()) == 0;\
-	if (__ret_ao && unlikely((__end_ao ^ __addr_ao) & PAGE_MASK)) {	\
-		while(__addr_ao <= __end_ao) {				\
-			char __c_ao;					\
-			__addr_ao += PAGE_SIZE;				\
-			if (__size > PAGE_SIZE)				\
-				cond_resched();				\
-			if (__get_user(__c_ao, (char __user *)__addr))	\
-				break;					\
-			if (type != VERIFY_WRITE) {			\
+	if (__ret_ao && __size) {					\
+		unsigned long __addr_ao = __addr & PAGE_MASK;		\
+		unsigned long __end_ao = __addr + __size - 1;		\
+		if (unlikely((__end_ao ^ __addr_ao) & PAGE_MASK)) {	\
+			while(__addr_ao <= __end_ao) {			\
+				char __c_ao;				\
+				__addr_ao += PAGE_SIZE;			\
+				if (__size > PAGE_SIZE)			\
+					cond_resched();			\
+				if (__get_user(__c_ao, (char __user *)__addr))	\
+					break;				\
+				if (type != VERIFY_WRITE) {		\
+					__addr = __addr_ao;		\
+					continue;			\
+				}					\
+				if (__put_user(__c_ao, (char __user *)__addr))	\
+					break;				\
 				__addr = __addr_ao;			\
-				continue;				\
 			}						\
-			if (__put_user(__c_ao, (char __user *)__addr))	\
-				break;					\
-			__addr = __addr_ao;				\
 		}							\
 	}								\
 	__ret_ao;							\
-- 
1.7.1

