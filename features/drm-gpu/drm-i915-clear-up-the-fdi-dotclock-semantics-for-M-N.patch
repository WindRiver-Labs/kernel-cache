From d48033043c732652aa316b43da0297885057d39f Mon Sep 17 00:00:00 2001
From: Daniel Vetter <daniel.vetter@ffwll.ch>
Date: Sat, 1 Jun 2013 17:16:19 +0200
Subject: [PATCH 254/904] drm/i915: clear up the fdi dotclock semantics for M/N
 computation

commit 2bd89a07db684573d2fce0d5148103c3dcfb0873 upstream

We currently mutliply the link_bw of the fdi link with the pixel
multiplier, which is wrong: The FDI link doesn't suddenly grow more
bandwidth. In reality the pixel mutliplication only happens in the PCH,
before the pixels are fed into the port.

But since we our code treats the uses the target clock after pixels
are doubled (tripled, ...) already, we need to correct this.

Semantically it's clearer to divide the target clock to get the fdi
dotclock instead of multiplying the bw, so do that instead.

Note that the target clock is already multiplied by the same factor,
so the division will never loose accuracy for the M/N computation.

The lane computation otoh used the wrong value, we also need to feed
the fdi dotclock to that.

Split out on a request from Paulo Zanoni.

v2: Also fix the lane computation, it used the target clock to compute
the bw requirements, not the fdi dotclock (i.e. adjusted with the
pixel multiplier). Since sdvo only uses the pixel multiplier for
low-res modes (with a dotclock below 100MHz) we wouldn't ever have
rejected a bogus mode, but just used an inefficient fdi config.

v3: Amend the commit message to explain better what the change for the
fdi lane config computation is all about. Requested by Paulo.

Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
---
 drivers/gpu/drm/i915/intel_display.c | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index cfdccde..d04589e 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -3989,7 +3989,7 @@ static int ironlake_fdi_compute_config(struct intel_crtc *intel_crtc,
 {
 	struct drm_device *dev = intel_crtc->base.dev;
 	struct drm_display_mode *adjusted_mode = &pipe_config->adjusted_mode;
-	int target_clock, lane, link_bw;
+	int target_clock, lane, link_bw, fdi_dotclock;
 	bool setup_ok, needs_recompute = false;
 
 retry:
@@ -4007,14 +4007,16 @@ retry:
 	else
 		target_clock = adjusted_mode->clock;
 
-	lane = ironlake_get_lanes_required(target_clock, link_bw,
+	fdi_dotclock = target_clock;
+	if (pipe_config->pixel_multiplier > 1)
+		fdi_dotclock /= pipe_config->pixel_multiplier;
+
+	lane = ironlake_get_lanes_required(fdi_dotclock, link_bw,
 					   pipe_config->pipe_bpp);
 
 	pipe_config->fdi_lanes = lane;
 
-	if (pipe_config->pixel_multiplier > 1)
-		link_bw *= pipe_config->pixel_multiplier;
-	intel_link_compute_m_n(pipe_config->pipe_bpp, lane, target_clock,
+	intel_link_compute_m_n(pipe_config->pipe_bpp, lane, fdi_dotclock,
 			       link_bw, &pipe_config->fdi_m_n);
 
 	setup_ok = ironlake_check_fdi_lanes(intel_crtc->base.dev,
-- 
1.8.4.93.g57e4c17

