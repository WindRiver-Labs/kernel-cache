From faa92031115a0ac15a5bf7ea63b06529df355566 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Thu, 4 Sep 2014 14:53:14 +0300
Subject: [PATCH 1237/1369] drm/i915: Fix edp vdd locking
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

commit e39b999a6f229386ea6c58cb1c10ce9dc912869b upstream.

Introduce a new mutex (pps_mutex) to protect the power sequencer
state. For now this state includes want_panel_vdd as well as the
power sequencer registers.

We need a single mutex (as opposed to per port) because later on we
will need to deal with VLV/CHV which have multiple power sequencer
which can be reassigned to different ports.

v2: Add the locking to intel_dp_encoder_suspend too (Imre)
v3: Take care intel_edp_backlight_power() and
    _intel_edp_backlight_on/off(), deal with reboot notifier
    vlv_power_sequencer_pipe() call (Imre)

Reviewed-by: Imre Deak <imre.deak@intel.com>
Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Signed-off-by: Pengyu Ma <pengyu.ma@windriver.com>
---
 drivers/gpu/drm/i915/i915_drv.h      |    3 +
 drivers/gpu/drm/i915/intel_display.c |    2 +
 drivers/gpu/drm/i915/intel_dp.c      |  112 ++++++++++++++++++++++++++++++----
 3 files changed, 104 insertions(+), 13 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index f104f00..5c04724 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -1528,6 +1528,9 @@ struct drm_i915_private {
 	/* LVDS info */
 	bool no_aux_handshake;
 
+	/* protects panel power sequencer state */
+	struct mutex pps_mutex;
+
 	struct drm_i915_fence_reg fence_regs[I915_MAX_NUM_FENCES]; /* assume 965 */
 	int fence_reg_start; /* 4 if userland hasn't ioctl'd us yet */
 	int num_fence_regs; /* 8 on pre-965, 16 otherwise */
diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index 9acc42f..128a57e 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -12591,6 +12591,8 @@ static void intel_init_display(struct drm_device *dev)
 	}
 
 	intel_panel_init_backlight_funcs(dev);
+
+	mutex_init(&dev_priv->pps_mutex);
 }
 
 /*
diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c
index cb195d9..cf9e500 100644
--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@ -300,6 +300,8 @@ vlv_power_sequencer_pipe(struct intel_dp *intel_dp)
 	enum port port = intel_dig_port->port;
 	enum pipe pipe;
 
+	lockdep_assert_held(&dev_priv->pps_mutex);
+
 	/* modeset should have pipe */
 	if (crtc)
 		return to_intel_crtc(crtc)->pipe;
@@ -347,12 +349,15 @@ static int edp_notify_handler(struct notifier_block *this, unsigned long code,
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	u32 pp_div;
 	u32 pp_ctrl_reg, pp_div_reg;
-	enum pipe pipe = vlv_power_sequencer_pipe(intel_dp);
 
 	if (!is_edp(intel_dp) || code != SYS_RESTART)
 		return 0;
 
+	mutex_lock(&dev_priv->pps_mutex);
+
 	if (IS_VALLEYVIEW(dev)) {
+		enum pipe pipe = vlv_power_sequencer_pipe(intel_dp);
+
 		pp_ctrl_reg = VLV_PIPE_PP_CONTROL(pipe);
 		pp_div_reg  = VLV_PIPE_PP_DIVISOR(pipe);
 		pp_div = I915_READ(pp_div_reg);
@@ -364,6 +369,8 @@ static int edp_notify_handler(struct notifier_block *this, unsigned long code,
 		msleep(intel_dp->panel_power_cycle_delay);
 	}
 
+	mutex_unlock(&dev_priv->pps_mutex);
+
 	return 0;
 }
 
@@ -372,6 +379,8 @@ static bool edp_have_panel_power(struct intel_dp *intel_dp)
 	struct drm_device *dev = intel_dp_to_dev(intel_dp);
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
+	lockdep_assert_held(&dev_priv->pps_mutex);
+
 	return (I915_READ(_pp_stat_reg(intel_dp)) & PP_ON) != 0;
 }
 
@@ -383,6 +392,8 @@ static bool edp_have_panel_vdd(struct intel_dp *intel_dp)
 	struct intel_encoder *intel_encoder = &intel_dig_port->base;
 	enum intel_display_power_domain power_domain;
 
+	lockdep_assert_held(&dev_priv->pps_mutex);
+
 	power_domain = intel_display_port_power_domain(intel_encoder);
 	return intel_display_power_enabled(dev_priv, power_domain) &&
 	       (I915_READ(_pp_ctrl_reg(intel_dp)) & EDP_FORCE_VDD) != 0;
@@ -533,6 +544,8 @@ intel_dp_aux_ch(struct intel_dp *intel_dp,
 	bool has_aux_irq = HAS_AUX_IRQ(dev);
 	bool vdd;
 
+	mutex_lock(&dev_priv->pps_mutex);
+
 	/*
 	 * We will be called with VDD already enabled for dpcd/edid/oui reads.
 	 * In such cases we want to leave VDD enabled and it's up to upper layers
@@ -648,6 +661,8 @@ out:
 	if (vdd)
 		edp_panel_vdd_off(intel_dp, false);
 
+	mutex_unlock(&dev_priv->pps_mutex);
+
 	return ret;
 }
 
@@ -1102,6 +1117,8 @@ static void wait_panel_status(struct intel_dp *intel_dp,
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	u32 pp_stat_reg, pp_ctrl_reg;
 
+	lockdep_assert_held(&dev_priv->pps_mutex);
+
 	pp_stat_reg = _pp_stat_reg(intel_dp);
 	pp_ctrl_reg = _pp_ctrl_reg(intel_dp);
 
@@ -1165,6 +1182,8 @@ static  u32 ironlake_get_pp_control(struct intel_dp *intel_dp)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	u32 control;
 
+	lockdep_assert_held(&dev_priv->pps_mutex);
+
 	control = I915_READ(_pp_ctrl_reg(intel_dp));
 	control &= ~PANEL_UNLOCK_MASK;
 	control |= PANEL_UNLOCK_REGS;
@@ -1182,6 +1201,8 @@ static bool edp_panel_vdd_on(struct intel_dp *intel_dp)
 	u32 pp_stat_reg, pp_ctrl_reg;
 	bool need_to_disable = !intel_dp->want_panel_vdd;
 
+	lockdep_assert_held(&dev_priv->pps_mutex);
+
 	if (!is_edp(intel_dp))
 		return false;
 
@@ -1221,12 +1242,16 @@ static bool edp_panel_vdd_on(struct intel_dp *intel_dp)
 
 void intel_edp_panel_vdd_on(struct intel_dp *intel_dp)
 {
+	struct drm_i915_private *dev_priv =
+		intel_dp_to_dev(intel_dp)->dev_private;
 	bool vdd;
 
 	if (!is_edp(intel_dp))
 		return;
 
+	mutex_lock(&dev_priv->pps_mutex);
 	vdd = edp_panel_vdd_on(intel_dp);
+	mutex_unlock(&dev_priv->pps_mutex);
 
 	WARN(!vdd, "eDP VDD already requested on\n");
 }
@@ -1242,7 +1267,7 @@ static void edp_panel_vdd_off_sync(struct intel_dp *intel_dp)
 	u32 pp;
 	u32 pp_stat_reg, pp_ctrl_reg;
 
-	WARN_ON(!drm_modeset_is_locked(&dev->mode_config.connection_mutex));
+	lockdep_assert_held(&dev_priv->pps_mutex);
 
 	WARN_ON(intel_dp->want_panel_vdd);
 
@@ -1275,12 +1300,13 @@ static void edp_panel_vdd_work(struct work_struct *__work)
 {
 	struct intel_dp *intel_dp = container_of(to_delayed_work(__work),
 						 struct intel_dp, panel_vdd_work);
-	struct drm_device *dev = intel_dp_to_dev(intel_dp);
+	struct drm_i915_private *dev_priv =
+		intel_dp_to_dev(intel_dp)->dev_private;
 
-	drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
+	mutex_lock(&dev_priv->pps_mutex);
 	if (!intel_dp->want_panel_vdd)
 		edp_panel_vdd_off_sync(intel_dp);
-	drm_modeset_unlock(&dev->mode_config.connection_mutex);
+	mutex_unlock(&dev_priv->pps_mutex);
 }
 
 static void edp_panel_vdd_schedule_off(struct intel_dp *intel_dp)
@@ -1298,6 +1324,11 @@ static void edp_panel_vdd_schedule_off(struct intel_dp *intel_dp)
 
 static void edp_panel_vdd_off(struct intel_dp *intel_dp, bool sync)
 {
+	struct drm_i915_private *dev_priv =
+		intel_dp_to_dev(intel_dp)->dev_private;
+
+	lockdep_assert_held(&dev_priv->pps_mutex);
+
 	if (!is_edp(intel_dp))
 		return;
 
@@ -1313,7 +1344,15 @@ static void edp_panel_vdd_off(struct intel_dp *intel_dp, bool sync)
 
 static void intel_edp_panel_vdd_off(struct intel_dp *intel_dp, bool sync)
 {
+	struct drm_i915_private *dev_priv =
+		intel_dp_to_dev(intel_dp)->dev_private;
+
+	if (!is_edp(intel_dp))
+		return;
+
+	mutex_lock(&dev_priv->pps_mutex);
 	edp_panel_vdd_off(intel_dp, sync);
+	mutex_unlock(&dev_priv->pps_mutex);
 }
 
 void intel_edp_panel_on(struct intel_dp *intel_dp)
@@ -1328,9 +1367,11 @@ void intel_edp_panel_on(struct intel_dp *intel_dp)
 
 	DRM_DEBUG_KMS("Turn eDP power on\n");
 
+	mutex_lock(&dev_priv->pps_mutex);
+
 	if (edp_have_panel_power(intel_dp)) {
 		DRM_DEBUG_KMS("eDP power already on\n");
-		return;
+		goto out;
 	}
 
 	wait_panel_power_cycle(intel_dp);
@@ -1359,6 +1400,9 @@ void intel_edp_panel_on(struct intel_dp *intel_dp)
 		I915_WRITE(pp_ctrl_reg, pp);
 		POSTING_READ(pp_ctrl_reg);
 	}
+
+ out:
+	mutex_unlock(&dev_priv->pps_mutex);
 }
 
 void intel_edp_panel_off(struct intel_dp *intel_dp)
@@ -1376,6 +1420,8 @@ void intel_edp_panel_off(struct intel_dp *intel_dp)
 
 	DRM_DEBUG_KMS("Turn eDP power off\n");
 
+	mutex_lock(&dev_priv->pps_mutex);
+
 	WARN(!intel_dp->want_panel_vdd, "Need VDD to turn off panel\n");
 
 	pp = ironlake_get_pp_control(intel_dp);
@@ -1396,6 +1442,8 @@ void intel_edp_panel_off(struct intel_dp *intel_dp)
 	/* We got a reference when we enabled the VDD. */
 	power_domain = intel_display_port_power_domain(intel_encoder);
 	intel_display_power_put(dev_priv, power_domain);
+
+	mutex_unlock(&dev_priv->pps_mutex);
 }
 
 /* Enable backlight in the panel power control. */
@@ -1414,6 +1462,9 @@ static void _intel_edp_backlight_on(struct intel_dp *intel_dp)
 	 * allowing it to appear.
 	 */
 	wait_backlight_on(intel_dp);
+
+	mutex_lock(&dev_priv->pps_mutex);
+
 	pp = ironlake_get_pp_control(intel_dp);
 	pp |= EDP_BLC_ENABLE;
 
@@ -1421,6 +1472,8 @@ static void _intel_edp_backlight_on(struct intel_dp *intel_dp)
 
 	I915_WRITE(pp_ctrl_reg, pp);
 	POSTING_READ(pp_ctrl_reg);
+
+	mutex_unlock(&dev_priv->pps_mutex);
 }
 
 /* Enable backlight PWM and backlight PP control. */
@@ -1443,6 +1496,11 @@ static void _intel_edp_backlight_off(struct intel_dp *intel_dp)
 	u32 pp;
 	u32 pp_ctrl_reg;
 
+	if (!is_edp(intel_dp))
+		return;
+
+	mutex_lock(&dev_priv->pps_mutex);
+
 	pp = ironlake_get_pp_control(intel_dp);
 	pp &= ~EDP_BLC_ENABLE;
 
@@ -1450,8 +1508,10 @@ static void _intel_edp_backlight_off(struct intel_dp *intel_dp)
 
 	I915_WRITE(pp_ctrl_reg, pp);
 	POSTING_READ(pp_ctrl_reg);
-	intel_dp->last_backlight_off = jiffies;
 
+	mutex_unlock(&dev_priv->pps_mutex);
+
+	intel_dp->last_backlight_off = jiffies;
 	edp_wait_backlight_off(intel_dp);
 }
 
@@ -1474,8 +1534,13 @@ void intel_edp_backlight_off(struct intel_dp *intel_dp)
 static void intel_edp_backlight_power(struct intel_connector *connector,
 				      bool enable)
 {
+	struct drm_i915_private *dev_priv = connector->base.dev->dev_private;
 	struct intel_dp *intel_dp = intel_attached_dp(&connector->base);
-	bool is_enabled = ironlake_get_pp_control(intel_dp) & EDP_BLC_ENABLE;
+	bool is_enabled;
+
+	mutex_lock(&dev_priv->pps_mutex);
+	is_enabled = ironlake_get_pp_control(intel_dp) & EDP_BLC_ENABLE;
+	mutex_unlock(&dev_priv->pps_mutex);
 
 	if (is_enabled == enable)
 		return;
@@ -2218,9 +2283,11 @@ static void vlv_pre_enable_dp(struct intel_encoder *encoder)
 
 	if (is_edp(intel_dp)) {
 		/* init power sequencer on this pipe and port */
+		mutex_lock(&dev_priv->pps_mutex);
 		intel_dp_init_panel_power_sequencer(dev, intel_dp, &power_seq);
 		intel_dp_init_panel_power_sequencer_registers(dev, intel_dp,
 							      &power_seq);
+		mutex_unlock(&dev_priv->pps_mutex);
 	}
 
 	intel_enable_dp(encoder);
@@ -2311,9 +2378,11 @@ static void chv_pre_enable_dp(struct intel_encoder *encoder)
 
 	if (is_edp(intel_dp)) {
 		/* init power sequencer on this pipe and port */
+		mutex_lock(&dev_priv->pps_mutex);
 		intel_dp_init_panel_power_sequencer(dev, intel_dp, &power_seq);
 		intel_dp_init_panel_power_sequencer_registers(dev, intel_dp,
 							      &power_seq);
+		mutex_unlock(&dev_priv->pps_mutex);
 	}
 
 	intel_enable_dp(encoder);
@@ -4076,15 +4145,16 @@ void intel_dp_encoder_destroy(struct drm_encoder *encoder)
 	struct intel_digital_port *intel_dig_port = enc_to_dig_port(encoder);
 	struct intel_dp *intel_dp = &intel_dig_port->dp;
 	struct drm_device *dev = intel_dp_to_dev(intel_dp);
+	struct drm_i915_private *dev_priv = dev->dev_private;
 
 	drm_dp_aux_unregister(&intel_dp->aux);
 	intel_dp_mst_encoder_cleanup(intel_dig_port);
 	drm_encoder_cleanup(encoder);
 	if (is_edp(intel_dp)) {
 		cancel_delayed_work_sync(&intel_dp->panel_vdd_work);
-		drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
+		mutex_lock(&dev_priv->pps_mutex);
 		edp_panel_vdd_off_sync(intel_dp);
-		drm_modeset_unlock(&dev->mode_config.connection_mutex);
+		mutex_unlock(&dev_priv->pps_mutex);
 		if (intel_dp->edp_notifier.notifier_call) {
 			unregister_reboot_notifier(&intel_dp->edp_notifier);
 			intel_dp->edp_notifier.notifier_call = NULL;
@@ -4096,11 +4166,15 @@ void intel_dp_encoder_destroy(struct drm_encoder *encoder)
 static void intel_dp_encoder_suspend(struct intel_encoder *intel_encoder)
 {
 	struct intel_dp *intel_dp = enc_to_intel_dp(&intel_encoder->base);
+	struct drm_device *dev = intel_dp_to_dev(intel_dp);
+	struct drm_i915_private *dev_priv = dev->dev_private;
 
 	if (!is_edp(intel_dp))
 		return;
 
+	mutex_lock(&dev_priv->pps_mutex);
 	edp_panel_vdd_off_sync(intel_dp);
+	mutex_unlock(&dev_priv->pps_mutex);
 }
 
 static void intel_dp_encoder_reset(struct drm_encoder *encoder)
@@ -4288,6 +4362,8 @@ intel_dp_init_panel_power_sequencer(struct drm_device *dev,
 	u32 pp_on, pp_off, pp_div, pp;
 	int pp_ctrl_reg, pp_on_reg, pp_off_reg, pp_div_reg;
 
+	lockdep_assert_held(&dev_priv->pps_mutex);
+
 	if (HAS_PCH_SPLIT(dev)) {
 		pp_ctrl_reg = PCH_PP_CONTROL;
 		pp_on_reg = PCH_PP_ON_DELAYS;
@@ -4389,6 +4465,8 @@ intel_dp_init_panel_power_sequencer_registers(struct drm_device *dev,
 	int pp_on_reg, pp_off_reg, pp_div_reg;
 	enum port port = dp_to_dig_port(intel_dp)->port;
 
+	lockdep_assert_held(&dev_priv->pps_mutex);
+
 	if (HAS_PCH_SPLIT(dev)) {
 		pp_on_reg = PCH_PP_ON_DELAYS;
 		pp_off_reg = PCH_PP_OFF_DELAYS;
@@ -4581,9 +4659,11 @@ void intel_edp_panel_vdd_sanitize(struct intel_encoder *intel_encoder)
 	if (intel_encoder->type != INTEL_OUTPUT_EDP)
 		return;
 
+	mutex_lock(&dev_priv->pps_mutex);
+
 	intel_dp = enc_to_intel_dp(&intel_encoder->base);
 	if (!edp_have_panel_vdd(intel_dp))
-		return;
+		goto out;
 	/*
 	 * The VDD bit needs a power domain reference, so if the bit is
 	 * already enabled when we boot or resume, grab this reference and
@@ -4595,6 +4675,8 @@ void intel_edp_panel_vdd_sanitize(struct intel_encoder *intel_encoder)
 	intel_display_power_get(dev_priv, power_domain);
 
 	edp_panel_vdd_schedule_off(intel_dp);
+ out:
+	mutex_unlock(&dev_priv->pps_mutex);
 }
 
 static bool intel_edp_init_connector(struct intel_dp *intel_dp,
@@ -4636,7 +4718,9 @@ static bool intel_edp_init_connector(struct intel_dp *intel_dp,
 	}
 
 	/* We now know it's not a ghost, init power sequence regs. */
+	mutex_lock(&dev_priv->pps_mutex);
 	intel_dp_init_panel_power_sequencer_registers(dev, intel_dp, power_seq);
+	mutex_unlock(&dev_priv->pps_mutex);
 
 	mutex_lock(&dev->mode_config.mutex);
 	edid = drm_get_edid(connector, &intel_dp->aux.ddc);
@@ -4769,8 +4853,10 @@ intel_dp_init_connector(struct intel_digital_port *intel_dig_port,
 	}
 
 	if (is_edp(intel_dp)) {
+		mutex_lock(&dev_priv->pps_mutex);
 		intel_dp_init_panel_power_timestamps(intel_dp);
 		intel_dp_init_panel_power_sequencer(dev, intel_dp, &power_seq);
+		mutex_unlock(&dev_priv->pps_mutex);
 	}
 
 	intel_dp_aux_init(intel_dp, intel_connector);
@@ -4786,9 +4872,9 @@ intel_dp_init_connector(struct intel_digital_port *intel_dig_port,
 		drm_dp_aux_unregister(&intel_dp->aux);
 		if (is_edp(intel_dp)) {
 			cancel_delayed_work_sync(&intel_dp->panel_vdd_work);
-			drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
+			mutex_lock(&dev_priv->pps_mutex);
 			edp_panel_vdd_off_sync(intel_dp);
-			drm_modeset_unlock(&dev->mode_config.connection_mutex);
+			mutex_unlock(&dev_priv->pps_mutex);
 		}
 		drm_connector_unregister(connector);
 		drm_connector_cleanup(connector);
-- 
1.7.5.4

