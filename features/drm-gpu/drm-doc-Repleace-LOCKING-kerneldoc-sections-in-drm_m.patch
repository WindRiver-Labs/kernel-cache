From 209ea84a39eaadc350fe03c81ad6b9d05ce69264 Mon Sep 17 00:00:00 2001
From: Daniel Vetter <daniel.vetter@ffwll.ch>
Date: Thu, 23 Jan 2014 15:14:15 +0100
Subject: [PATCH 0022/1369] drm/doc: Repleace LOCKING kerneldoc sections in
 drm_modes.c

commit 63951385052f7974155fa38f962f0f4e9847f90a upstream.

There's not really any value in stating that no locking is needed. And
even if the comment is useful, a check for the right mutex at the
beginning of the function is better since that can't be ingored as
easily as a bit of documentation.

Note that drm_mode_probed_add in drm_crtc.c is also changed, the next
patch will move this into drm_modes.c

v2: Don't add locking WARN_ONs where it is not strictly required (i.e.
the two functions to validate/prune mode lists).

Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Signed-off-by: Pengyu Ma <pengyu.ma@windriver.com>
---
 drivers/gpu/drm/drm_crtc.c  |    2 +
 drivers/gpu/drm/drm_modes.c |   59 +-----------------------------------------
 2 files changed, 4 insertions(+), 57 deletions(-)

diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c
index 6033c32..313c87a 100644
--- a/drivers/gpu/drm/drm_crtc.c
+++ b/drivers/gpu/drm/drm_crtc.c
@@ -739,6 +739,8 @@ EXPORT_SYMBOL(drm_crtc_index);
 void drm_mode_probed_add(struct drm_connector *connector,
 			 struct drm_display_mode *mode)
 {
+	WARN_ON(!mutex_is_locked(&connector->dev->mode_config.mutex));
+
 	list_add_tail(&mode->head, &connector->probed_modes);
 }
 EXPORT_SYMBOL(drm_mode_probed_add);
diff --git a/drivers/gpu/drm/drm_modes.c b/drivers/gpu/drm/drm_modes.c
index 4892194..be86fed 100644
--- a/drivers/gpu/drm/drm_modes.c
+++ b/drivers/gpu/drm/drm_modes.c
@@ -42,9 +42,6 @@
  * drm_mode_debug_printmodeline - print a mode to dmesg
  * @mode: mode to print
  *
- * LOCKING:
- * none.
- *
  * Describe @mode using DRM_DEBUG.
  */
 void drm_mode_debug_printmodeline(const struct drm_display_mode *mode)
@@ -69,9 +66,6 @@ EXPORT_SYMBOL(drm_mode_debug_printmodeline);
  * @interlaced:Whether the interlace is supported
  * @margins: whether to add margins or not
  *
- * LOCKING:
- * none.
- *
  * return the modeline based on CVT algorithm
  *
  * This function is called to generate the modeline based on CVT algorithm
@@ -294,9 +288,6 @@ EXPORT_SYMBOL(drm_cvt_mode);
  * @GTF_K: extended GTF formula parameters
  * @GTF_2J: extended GTF formula parameters
  *
- * LOCKING.
- * none.
- *
  * return the modeline based on full GTF algorithm.
  *
  * GTF feature blocks specify C and J in multiples of 0.5, so we pass them
@@ -479,9 +470,6 @@ EXPORT_SYMBOL(drm_gtf_mode_complex);
  * @interlaced	:whether the interlace is supported
  * @margins	:whether the margin is supported
  *
- * LOCKING.
- * none.
- *
  * return the modeline based on GTF algorithm
  *
  * This function is to create the modeline based on the GTF algorithm.
@@ -584,9 +572,6 @@ EXPORT_SYMBOL_GPL(of_get_drm_display_mode);
  * drm_mode_set_name - set the name on a mode
  * @mode: name will be set in this mode
  *
- * LOCKING:
- * None.
- *
  * Set the name of @mode to a standard format.
  */
 void drm_mode_set_name(struct drm_display_mode *mode)
@@ -603,9 +588,6 @@ EXPORT_SYMBOL(drm_mode_set_name);
  * drm_mode_width - get the width of a mode
  * @mode: mode
  *
- * LOCKING:
- * None.
- *
  * Return @mode's width (hdisplay) value.
  *
  * FIXME: is this needed?
@@ -624,9 +606,6 @@ EXPORT_SYMBOL(drm_mode_width);
  * drm_mode_height - get the height of a mode
  * @mode: mode
  *
- * LOCKING:
- * None.
- *
  * Return @mode's height (vdisplay) value.
  *
  * FIXME: is this needed?
@@ -643,9 +622,6 @@ EXPORT_SYMBOL(drm_mode_height);
 /** drm_mode_hsync - get the hsync of a mode
  * @mode: mode
  *
- * LOCKING:
- * None.
- *
  * Return @modes's hsync rate in kHz, rounded to the nearest int.
  */
 int drm_mode_hsync(const struct drm_display_mode *mode)
@@ -670,9 +646,6 @@ EXPORT_SYMBOL(drm_mode_hsync);
  * drm_mode_vrefresh - get the vrefresh of a mode
  * @mode: mode
  *
- * LOCKING:
- * None.
- *
  * Return @mode's vrefresh rate in Hz or calculate it if necessary.
  *
  * FIXME: why is this needed?  shouldn't vrefresh be set already?
@@ -713,9 +686,6 @@ EXPORT_SYMBOL(drm_mode_vrefresh);
  * @p: mode
  * @adjust_flags: a combination of adjustment flags
  *
- * LOCKING:
- * None.
- *
  * Setup the CRTC modesetting parameters for @p, adjusting if necessary.
  *
  * - The CRTC_INTERLACE_HALVE_V flag can be used to halve vertical timings of
@@ -790,9 +760,6 @@ EXPORT_SYMBOL(drm_mode_set_crtcinfo);
  * @dst: mode to overwrite
  * @src: mode to copy
  *
- * LOCKING:
- * None.
- *
  * Copy an existing mode into another mode, preserving the object id and
  * list head of the destination mode.
  */
@@ -812,9 +779,6 @@ EXPORT_SYMBOL(drm_mode_copy);
  * @dev: drm_device to allocate the duplicated mode for
  * @mode: mode to duplicate
  *
- * LOCKING:
- * None.
- *
  * Just allocate a new mode, copy the existing mode into it, and return
  * a pointer to it.  Used to create new instances of established modes.
  */
@@ -838,9 +802,6 @@ EXPORT_SYMBOL(drm_mode_duplicate);
  * @mode1: first mode
  * @mode2: second mode
  *
- * LOCKING:
- * None.
- *
  * Check to see if @mode1 and @mode2 are equivalent.
  *
  * RETURNS:
@@ -869,9 +830,6 @@ EXPORT_SYMBOL(drm_mode_equal);
  * @mode1: first mode
  * @mode2: second mode
  *
- * LOCKING:
- * None.
- *
  * Check to see if @mode1 and @mode2 are equivalent, but
  * don't check the pixel clocks nor the stereo layout.
  *
@@ -907,9 +865,6 @@ EXPORT_SYMBOL(drm_mode_equal_no_clocks_no_stereo);
  * @maxY: maximum height
  * @maxPitch: max pitch
  *
- * LOCKING:
- * Caller must hold a lock protecting @mode_list.
- *
  * The DRM device (@dev) has size and pitch limits.  Here we validate the
  * modes we probed for @dev against those limits and set their status as
  * necessary.
@@ -939,9 +894,6 @@ EXPORT_SYMBOL(drm_mode_validate_size);
  * @mode_list: list of modes to check
  * @verbose: be verbose about it
  *
- * LOCKING:
- * Caller must hold a lock protecting @mode_list.
- *
  * Once mode list generation is complete, a caller can use this routine to
  * remove invalid modes from a mode list.  If any of the modes have a
  * status other than %MODE_OK, they are removed from @mode_list and freed.
@@ -971,9 +923,6 @@ EXPORT_SYMBOL(drm_mode_prune_invalid);
  * @lh_a: list_head for first mode
  * @lh_b: list_head for second mode
  *
- * LOCKING:
- * None.
- *
  * Compare two modes, given by @lh_a and @lh_b, returning a value indicating
  * which is better.
  *
@@ -1007,9 +956,6 @@ static int drm_mode_compare(void *priv, struct list_head *lh_a, struct list_head
  * drm_mode_sort - sort mode list
  * @mode_list: list to sort
  *
- * LOCKING:
- * Caller must hold a lock protecting @mode_list.
- *
  * Sort @mode_list by favorability, putting good modes first.
  */
 void drm_mode_sort(struct list_head *mode_list)
@@ -1022,9 +968,6 @@ EXPORT_SYMBOL(drm_mode_sort);
  * drm_mode_connector_list_update - update the mode list for the connector
  * @connector: the connector to update
  *
- * LOCKING:
- * Caller must hold a lock protecting @mode_list.
- *
  * This moves the modes from the @connector probed_modes list
  * to the actual mode list. It compares the probed mode against the current
  * list and only adds different modes. All modes unverified after this point
@@ -1036,6 +979,8 @@ void drm_mode_connector_list_update(struct drm_connector *connector)
 	struct drm_display_mode *pmode, *pt;
 	int found_it;
 
+	WARN_ON(!mutex_is_locked(&connector->dev->mode_config.mutex));
+
 	list_for_each_entry_safe(pmode, pt, &connector->probed_modes,
 				 head) {
 		found_it = 0;
-- 
1.7.5.4

