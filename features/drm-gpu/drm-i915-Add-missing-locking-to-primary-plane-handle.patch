From a8a46c28cc2096a2afcac79da77965b1e475796c Mon Sep 17 00:00:00 2001
From: Matt Roper <matthew.d.roper@intel.com>
Date: Wed, 9 Jul 2014 16:22:10 -0700
Subject: [PATCH 0783/1369] drm/i915: Add missing locking to primary plane
 handlers

commit 4c34574fd9e6f3ed34ebe67fbabb0fef0b0754e3 upstream.

intel_primary_plane_{setplane,disable} were lacking struct_mutex locking
around their GEM operations.

Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
Reported-by: Damien Lespiau <damien.lespiau@intel.com>
Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Signed-off-by: Pengyu Ma <pengyu.ma@windriver.com>
---
 drivers/gpu/drm/i915/intel_display.c |   17 +++++++++++++++--
 1 files changed, 15 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index 250da45..40f398e 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -11398,9 +11398,11 @@ intel_primary_plane_disable(struct drm_plane *plane)
 	intel_disable_primary_hw_plane(dev_priv, intel_plane->plane,
 				       intel_plane->pipe);
 disable_unpin:
+	mutex_lock(&dev->struct_mutex);
 	i915_gem_track_fb(intel_fb_obj(plane->fb), NULL,
 			  INTEL_FRONTBUFFER_PRIMARY(intel_crtc->pipe));
 	intel_unpin_fb_obj(intel_fb_obj(plane->fb));
+	mutex_unlock(&dev->struct_mutex);
 	plane->fb = NULL;
 
 	return 0;
@@ -11457,6 +11459,8 @@ intel_primary_plane_setplane(struct drm_plane *plane, struct drm_crtc *crtc,
 	 * turn on the display with all planes setup as desired.
 	 */
 	if (!crtc->enabled) {
+		mutex_lock(&dev->struct_mutex);
+
 		/*
 		 * If we already called setplane while the crtc was disabled,
 		 * we may have an fb pinned; unpin it.
@@ -11468,7 +11472,10 @@ intel_primary_plane_setplane(struct drm_plane *plane, struct drm_crtc *crtc,
 				  INTEL_FRONTBUFFER_PRIMARY(intel_crtc->pipe));
 
 		/* Pin and return without programming hardware */
-		return intel_pin_and_fence_fb_obj(dev, obj, NULL);
+		ret = intel_pin_and_fence_fb_obj(dev, obj, NULL);
+		mutex_unlock(&dev->struct_mutex);
+
+		return ret;
 	}
 
 	intel_crtc_wait_for_pending_flips(crtc);
@@ -11480,14 +11487,18 @@ intel_primary_plane_setplane(struct drm_plane *plane, struct drm_crtc *crtc,
 	 * because plane->fb still gets set and pinned.
 	 */
 	if (!visible) {
+		mutex_lock(&dev->struct_mutex);
+
 		/*
 		 * Try to pin the new fb first so that we can bail out if we
 		 * fail.
 		 */
 		if (plane->fb != fb) {
 			ret = intel_pin_and_fence_fb_obj(dev, obj, NULL);
-			if (ret)
+			if (ret) {
+				mutex_unlock(&dev->struct_mutex);
 				return ret;
+			}
 		}
 
 		i915_gem_track_fb(old_obj, obj,
@@ -11503,6 +11514,8 @@ intel_primary_plane_setplane(struct drm_plane *plane, struct drm_crtc *crtc,
 			if (plane->fb)
 				intel_unpin_fb_obj(old_obj);
 
+		mutex_unlock(&dev->struct_mutex);
+
 		return 0;
 	}
 
-- 
1.7.5.4

