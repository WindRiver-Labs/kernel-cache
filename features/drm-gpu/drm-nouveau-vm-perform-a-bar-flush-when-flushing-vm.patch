From 5891bf56c65d9266c7e84650316d1da5e4dd9f31 Mon Sep 17 00:00:00 2001
From: Maarten Lankhorst <maarten.lankhorst@canonical.com>
Date: Tue, 11 Jun 2013 14:17:25 +0200
Subject: [PATCH 647/886] drm/nouveau/vm: perform a bar flush when flushing vm

commit 36798b61ed799962e08d49a632fee94b5177d4ac upstream

Appears to fix the regression from "drm/nvc0/vm: handle bar tlb flushes
internally".

nvidia always seems to do this flush after writing values.

Signed-off-by: Maarten Lankhorst <maarten.lankhorst@canonical.com>
Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
---
 drivers/gpu/drm/nouveau/core/subdev/vm/nv50.c |    4 ++++
 drivers/gpu/drm/nouveau/core/subdev/vm/nvc0.c |    4 ++++
 2 files changed, 8 insertions(+)

diff --git a/drivers/gpu/drm/nouveau/core/subdev/vm/nv50.c b/drivers/gpu/drm/nouveau/core/subdev/vm/nv50.c
index 50c6612..486c813 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/vm/nv50.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/vm/nv50.c
@@ -27,6 +27,7 @@
 
 #include <subdev/timer.h>
 #include <subdev/fb.h>
+#include <subdev/bar.h>
 #include <subdev/vm.h>
 
 struct nv50_vmmgr_priv {
@@ -151,9 +152,12 @@ static void
 nv50_vm_flush(struct nouveau_vm *vm)
 {
 	struct nv50_vmmgr_priv *priv = (void *)vm->vmm;
+	struct nouveau_bar *bar = nouveau_bar(priv);
 	struct nouveau_engine *engine;
 	int i, vme;
 
+	bar->flush(bar);
+
 	mutex_lock(&nv_subdev(priv)->mutex);
 	for (i = 0; i < NVDEV_SUBDEV_NR; i++) {
 		if (!atomic_read(&vm->engref[i]))
diff --git a/drivers/gpu/drm/nouveau/core/subdev/vm/nvc0.c b/drivers/gpu/drm/nouveau/core/subdev/vm/nvc0.c
index 6c3aea5..668cf96 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/vm/nvc0.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/vm/nvc0.c
@@ -29,6 +29,7 @@
 #include <subdev/fb.h>
 #include <subdev/vm.h>
 #include <subdev/ltcg.h>
+#include <subdev/bar.h>
 
 struct nvc0_vmmgr_priv {
 	struct nouveau_vmmgr base;
@@ -163,9 +164,12 @@ static void
 nvc0_vm_flush(struct nouveau_vm *vm)
 {
 	struct nvc0_vmmgr_priv *priv = (void *)vm->vmm;
+	struct nouveau_bar *bar = nouveau_bar(priv);
 	struct nouveau_vm_pgd *vpgd;
 	u32 type;
 
+	bar->flush(bar);
+
 	type = 0x00000001; /* PAGE_ALL */
 	if (atomic_read(&vm->engref[NVDEV_SUBDEV_BAR]))
 		type |= 0x00000004; /* HUB_ONLY */
-- 
1.7.9.5

