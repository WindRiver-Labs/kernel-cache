From 35f40bf7684a1d09b64a53695b08d714b29959f3 Mon Sep 17 00:00:00 2001
From: Daniel Vetter <daniel.vetter@ffwll.ch>
Date: Thu, 24 Apr 2014 23:55:05 +0200
Subject: [PATCH 0412/1369] drm/i915: Move fb pinning into __intel_set_mode

commit 4c10794fe1a1afdb00821fc304fe4287f10d5866 upstream.

Our two ->crtc_mode_set callbacks really don't care whether the fb is
pinned and set up already or not - all the state computation and
handling which originally looked at the framebuffer is already using
the indirection through the pipe configuration.

Eventually we want to move this up a bit more, but as long as the crtc
mode_set callback still exists (and as long as we don't need to pin an
entire pile of planes due to atomic modesets) there's not much point
in it. So I'll let this be for now.

v2: Don't forget about haswell ...

Reviewed-by: Akash Goel <akash.goel@intel.com>
Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Signed-off-by: Pengyu Ma <pengyu.ma@windriver.com>
---
 drivers/gpu/drm/i915/intel_display.c |   80 ++++++++-------------------------
 1 files changed, 20 insertions(+), 60 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index 08ff666..764ec34 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -5769,8 +5769,6 @@ static int i9xx_crtc_mode_set(struct drm_crtc *crtc,
 	bool is_lvds = false, is_dsi = false;
 	struct intel_encoder *encoder;
 	const intel_limit_t *limit;
-	struct drm_framebuffer *old_fb;
-	int ret;
 
 	for_each_encoder_on_crtc(dev, crtc, encoder) {
 		switch (encoder->type) {
@@ -5870,26 +5868,8 @@ skip_dpll:
 	I915_WRITE(DSPCNTR(plane), dspcntr);
 	POSTING_READ(DSPCNTR(plane));
 
-	mutex_lock(&dev->struct_mutex);
-	ret = intel_pin_and_fence_fb_obj(dev,
-					 to_intel_framebuffer(fb)->obj,
-					 NULL);
-	if (ret != 0) {
-		DRM_ERROR("pin & fence failed\n");
-		mutex_unlock(&dev->struct_mutex);
-		return ret;
-	}
-	old_fb = crtc->primary->fb;
-	if (old_fb)
-		intel_unpin_fb_obj(to_intel_framebuffer(old_fb)->obj);
-	mutex_unlock(&dev->struct_mutex);
-
 	dev_priv->display.update_primary_plane(crtc, fb, x, y);
 
-	crtc->primary->fb = fb;
-	crtc->x = x;
-	crtc->y = y;
-
 	return 0;
 }
 
@@ -6826,8 +6806,6 @@ static int ironlake_crtc_mode_set(struct drm_crtc *crtc,
 	bool is_lvds = false;
 	struct intel_encoder *encoder;
 	struct intel_shared_dpll *pll;
-	struct drm_framebuffer *old_fb;
-	int ret;
 
 	for_each_encoder_on_crtc(dev, crtc, encoder) {
 		switch (encoder->type) {
@@ -6904,26 +6882,8 @@ static int ironlake_crtc_mode_set(struct drm_crtc *crtc,
 	I915_WRITE(DSPCNTR(plane), DISPPLANE_GAMMA_ENABLE);
 	POSTING_READ(DSPCNTR(plane));
 
-	mutex_lock(&dev->struct_mutex);
-	ret = intel_pin_and_fence_fb_obj(dev,
-					 to_intel_framebuffer(fb)->obj,
-					 NULL);
-	if (ret != 0) {
-		DRM_ERROR("pin & fence failed\n");
-		mutex_unlock(&dev->struct_mutex);
-		return ret;
-	}
-	old_fb = crtc->primary->fb;
-	if (old_fb)
-		intel_unpin_fb_obj(to_intel_framebuffer(old_fb)->obj);
-	mutex_unlock(&dev->struct_mutex);
-
 	dev_priv->display.update_primary_plane(crtc, fb, x, y);
 
-	crtc->primary->fb = fb;
-	crtc->x = x;
-	crtc->y = y;
-
 	return 0;
 }
 
@@ -7394,8 +7354,6 @@ static int haswell_crtc_mode_set(struct drm_crtc *crtc,
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 	int plane = intel_crtc->plane;
-	struct drm_framebuffer *old_fb;
-	int ret;
 
 	if (!intel_ddi_pll_select(intel_crtc))
 		return -EINVAL;
@@ -7421,26 +7379,8 @@ static int haswell_crtc_mode_set(struct drm_crtc *crtc,
 	I915_WRITE(DSPCNTR(plane), DISPPLANE_GAMMA_ENABLE | DISPPLANE_PIPE_CSC_ENABLE);
 	POSTING_READ(DSPCNTR(plane));
 
-	mutex_lock(&dev->struct_mutex);
-	ret = intel_pin_and_fence_fb_obj(dev,
-					 to_intel_framebuffer(fb)->obj,
-					 NULL);
-	if (ret != 0) {
-		DRM_ERROR("pin & fence failed\n");
-		mutex_unlock(&dev->struct_mutex);
-		return ret;
-	}
-	old_fb = crtc->primary->fb;
-	if (old_fb)
-		intel_unpin_fb_obj(to_intel_framebuffer(old_fb)->obj);
-	mutex_unlock(&dev->struct_mutex);
-
 	dev_priv->display.update_primary_plane(crtc, fb, x, y);
 
-	crtc->primary->fb = fb;
-	crtc->x = x;
-	crtc->y = y;
-
 	return 0;
 }
 
@@ -10273,6 +10213,26 @@ static int __intel_set_mode(struct drm_crtc *crtc,
 	 * on the DPLL.
 	 */
 	for_each_intel_crtc_masked(dev, modeset_pipes, intel_crtc) {
+		struct drm_framebuffer *old_fb;
+
+		mutex_lock(&dev->struct_mutex);
+		ret = intel_pin_and_fence_fb_obj(dev,
+						 to_intel_framebuffer(fb)->obj,
+						 NULL);
+		if (ret != 0) {
+			DRM_ERROR("pin & fence failed\n");
+			mutex_unlock(&dev->struct_mutex);
+			goto done;
+		}
+		old_fb = crtc->primary->fb;
+		if (old_fb)
+			intel_unpin_fb_obj(to_intel_framebuffer(old_fb)->obj);
+		mutex_unlock(&dev->struct_mutex);
+
+		crtc->primary->fb = fb;
+		crtc->x = x;
+		crtc->y = y;
+
 		ret = dev_priv->display.crtc_mode_set(&intel_crtc->base,
 						      x, y, fb);
 		if (ret)
-- 
1.7.5.4

