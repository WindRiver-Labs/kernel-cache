From 191329551691ff412a8c5b04cbf793782abebe2a Mon Sep 17 00:00:00 2001
From: David Herrmann <dh.herrmann@gmail.com>
Date: Tue, 22 Jul 2014 17:12:26 +0200
Subject: [PATCH 0920/1369] drm: don't de-authenticate clients on master-close

commit 3cb01a980461506f9ec4e4e1dc2dab6314236fb7 upstream.

If an active DRM-Master closes its device, we deauthenticate all clients
on that master. However, if an inactive DRM-Master closes its device, we
do nothing. This is quite inconsistent and breaks several scenarios:

 1) If this was used as security mechanism, it fails horribly if a master
    closes a device while VT switched away. Furthermore, none of the few
    drivers using ->master_*() callbacks seems to require it, anyway.

 2) If you spawn weston (or any other non-UMS compositor) in background
    while another compositor is active, both will get assigned to the
    same "drm_master" object. If the foreground compositor now exits, all
    clients of both the foreground AND background compositor will be
    de-authenticated leading to unexpected behavior.

Stop this non-sense and keep clients authenticated. We don't do this when
dropping DRM-Master (i.e., switching VTs) so don't do it on active-close
either!

Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
Signed-off-by: Pengyu Ma <pengyu.ma@windriver.com>
---
 drivers/gpu/drm/drm_fops.c |   13 ++-----------
 include/drm/drmP.h         |    1 -
 2 files changed, 2 insertions(+), 12 deletions(-)

diff --git a/drivers/gpu/drm/drm_fops.c b/drivers/gpu/drm/drm_fops.c
index 145960b..e4db23f 100644
--- a/drivers/gpu/drm/drm_fops.c
+++ b/drivers/gpu/drm/drm_fops.c
@@ -199,8 +199,7 @@ static int drm_open_helper(struct file *filp, struct drm_minor *minor)
 	priv->minor = minor;
 
 	/* for compatibility root is always authenticated */
-	priv->always_authenticated = capable(CAP_SYS_ADMIN);
-	priv->authenticated = priv->always_authenticated;
+	priv->authenticated = capable(CAP_SYS_ADMIN);
 	priv->lock_count = 0;
 
 	INIT_LIST_HEAD(&priv->lhead);
@@ -466,20 +465,12 @@ int drm_release(struct inode *inode, struct file *filp)
 
 	if (drm_is_master(file_priv)) {
 		struct drm_master *master = file_priv->master;
-		struct drm_file *temp;
-
-		mutex_lock(&dev->struct_mutex);
-		list_for_each_entry(temp, &dev->filelist, lhead) {
-			if ((temp->master == file_priv->master) &&
-			    (temp != file_priv))
-				temp->authenticated = temp->always_authenticated;
-		}
 
 		/**
 		 * Since the master is disappearing, so is the
 		 * possibility to lock.
 		 */
-
+		mutex_lock(&dev->struct_mutex);
 		if (master->lock.hw_lock) {
 			if (dev->sigdata.lock == master->lock.hw_lock)
 				dev->sigdata.lock = NULL;
diff --git a/include/drm/drmP.h b/include/drm/drmP.h
index a1530c7..e93a0d7 100644
--- a/include/drm/drmP.h
+++ b/include/drm/drmP.h
@@ -385,7 +385,6 @@ struct drm_prime_file_private {
 
 /** File private data */
 struct drm_file {
-	unsigned always_authenticated :1;
 	unsigned authenticated :1;
 	/* true when the client has asked us to expose stereo 3D mode flags */
 	unsigned stereo_allowed :1;
-- 
1.7.5.4

