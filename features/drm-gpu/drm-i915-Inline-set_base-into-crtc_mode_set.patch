From deb9a81dd9008c1e79bf5b2f828eb1393fbb8fcc Mon Sep 17 00:00:00 2001
From: Daniel Vetter <daniel.vetter@ffwll.ch>
Date: Thu, 24 Apr 2014 23:55:04 +0200
Subject: [PATCH 0411/1369] drm/i915: Inline set_base into crtc_mode_set

commit c8f7a0dbd7bfb9719d281407587f78c84f0411e6 upstream.

A lot of the code in set_base is uncessary when the crtc is off, so we
can get rid of it all. Also, we don't need to call the fbc/psr update
functions since the crtc enable/disable hooks do that already.

The only things we really need are:
- Pin the new framebuffer and potentially unpin the old framebuffer
  (if the crtc has been on and we only change the configuration).
- Update the plane registers.

The first step will move out of platform code with the very next
patch.

v2: Don't forget about haswell ...

Reviewed-by: Akash Goel <akash.goel@intel.com>
Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Signed-off-by: Pengyu Ma <pengyu.ma@windriver.com>
---
 drivers/gpu/drm/i915/intel_display.c |   69 +++++++++++++++++++++++++++++++---
 1 files changed, 63 insertions(+), 6 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index 0157653..08ff666 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -5769,6 +5769,7 @@ static int i9xx_crtc_mode_set(struct drm_crtc *crtc,
 	bool is_lvds = false, is_dsi = false;
 	struct intel_encoder *encoder;
 	const intel_limit_t *limit;
+	struct drm_framebuffer *old_fb;
 	int ret;
 
 	for_each_encoder_on_crtc(dev, crtc, encoder) {
@@ -5869,9 +5870,27 @@ skip_dpll:
 	I915_WRITE(DSPCNTR(plane), dspcntr);
 	POSTING_READ(DSPCNTR(plane));
 
-	ret = intel_pipe_set_base(crtc, x, y, fb);
+	mutex_lock(&dev->struct_mutex);
+	ret = intel_pin_and_fence_fb_obj(dev,
+					 to_intel_framebuffer(fb)->obj,
+					 NULL);
+	if (ret != 0) {
+		DRM_ERROR("pin & fence failed\n");
+		mutex_unlock(&dev->struct_mutex);
+		return ret;
+	}
+	old_fb = crtc->primary->fb;
+	if (old_fb)
+		intel_unpin_fb_obj(to_intel_framebuffer(old_fb)->obj);
+	mutex_unlock(&dev->struct_mutex);
+
+	dev_priv->display.update_primary_plane(crtc, fb, x, y);
 
-	return ret;
+	crtc->primary->fb = fb;
+	crtc->x = x;
+	crtc->y = y;
+
+	return 0;
 }
 
 static void i9xx_get_pfit_config(struct intel_crtc *crtc,
@@ -6807,6 +6826,7 @@ static int ironlake_crtc_mode_set(struct drm_crtc *crtc,
 	bool is_lvds = false;
 	struct intel_encoder *encoder;
 	struct intel_shared_dpll *pll;
+	struct drm_framebuffer *old_fb;
 	int ret;
 
 	for_each_encoder_on_crtc(dev, crtc, encoder) {
@@ -6884,9 +6904,27 @@ static int ironlake_crtc_mode_set(struct drm_crtc *crtc,
 	I915_WRITE(DSPCNTR(plane), DISPPLANE_GAMMA_ENABLE);
 	POSTING_READ(DSPCNTR(plane));
 
-	ret = intel_pipe_set_base(crtc, x, y, fb);
+	mutex_lock(&dev->struct_mutex);
+	ret = intel_pin_and_fence_fb_obj(dev,
+					 to_intel_framebuffer(fb)->obj,
+					 NULL);
+	if (ret != 0) {
+		DRM_ERROR("pin & fence failed\n");
+		mutex_unlock(&dev->struct_mutex);
+		return ret;
+	}
+	old_fb = crtc->primary->fb;
+	if (old_fb)
+		intel_unpin_fb_obj(to_intel_framebuffer(old_fb)->obj);
+	mutex_unlock(&dev->struct_mutex);
 
-	return ret;
+	dev_priv->display.update_primary_plane(crtc, fb, x, y);
+
+	crtc->primary->fb = fb;
+	crtc->x = x;
+	crtc->y = y;
+
+	return 0;
 }
 
 static void intel_pch_transcoder_get_m_n(struct intel_crtc *crtc,
@@ -7356,6 +7394,7 @@ static int haswell_crtc_mode_set(struct drm_crtc *crtc,
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 	int plane = intel_crtc->plane;
+	struct drm_framebuffer *old_fb;
 	int ret;
 
 	if (!intel_ddi_pll_select(intel_crtc))
@@ -7382,9 +7421,27 @@ static int haswell_crtc_mode_set(struct drm_crtc *crtc,
 	I915_WRITE(DSPCNTR(plane), DISPPLANE_GAMMA_ENABLE | DISPPLANE_PIPE_CSC_ENABLE);
 	POSTING_READ(DSPCNTR(plane));
 
-	ret = intel_pipe_set_base(crtc, x, y, fb);
+	mutex_lock(&dev->struct_mutex);
+	ret = intel_pin_and_fence_fb_obj(dev,
+					 to_intel_framebuffer(fb)->obj,
+					 NULL);
+	if (ret != 0) {
+		DRM_ERROR("pin & fence failed\n");
+		mutex_unlock(&dev->struct_mutex);
+		return ret;
+	}
+	old_fb = crtc->primary->fb;
+	if (old_fb)
+		intel_unpin_fb_obj(to_intel_framebuffer(old_fb)->obj);
+	mutex_unlock(&dev->struct_mutex);
 
-	return ret;
+	dev_priv->display.update_primary_plane(crtc, fb, x, y);
+
+	crtc->primary->fb = fb;
+	crtc->x = x;
+	crtc->y = y;
+
+	return 0;
 }
 
 static bool haswell_get_pipe_config(struct intel_crtc *crtc,
-- 
1.7.5.4

