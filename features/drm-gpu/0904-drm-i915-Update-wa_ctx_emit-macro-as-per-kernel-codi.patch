From e21556ce9dcfbc764632e985b12994e743600601 Mon Sep 17 00:00:00 2001
From: Arun Siluvery <arun.siluvery@linux.intel.com>
Date: Wed, 8 Jul 2015 10:27:05 +0100
Subject: [PATCH 0904/1077] drm/i915: Update wa_ctx_emit() macro as per kernel
 coding guidelines

commit 83b8a982b101c48fc025066a7b08beaf6fa756f0 upstream.

wa_ctx_emit() depends on the name of a local variable; if the name of that
variable is changed then we get compile errors. In this case it is unlikely
to be changed as this macro is only used in this set of functions but
Kernel coding guidelines doesn't recommend doing this. It was my mistake
as I should have corrected it at the beginning but missed so correct
this before there are more usages of this macro (Bob Beckett).

https://www.kernel.org/doc/Documentation/CodingStyle,
Chapter 12, "Things to avoid when using macros", point 2):

"
2) macros that depend on having a local variable with a magic name:

   #define FOO(val) bar(index, val)

might look like a good thing, but it's confusing as hell when one reads the
code and it's prone to breakage from seemingly innocent changes.
"

v2: Optimization to avoid multiple evaluation of 'index' in the macro.
Since we invoke it multiple times, compiler, if it can, should be able to coalesce
them into a single condition and remove multiple WARN_ON checks (Chris).

Suggested-by: Robert Beckett <robert.beckett@intel.com>
Cc: Robert Beckett <robert.beckett@intel.com>
Cc: Chris Wilson <chris@chris-wilson.co.uk>
Cc: Imre Deak <imre.deak@intel.com>
Signed-off-by: Arun Siluvery <arun.siluvery@linux.intel.com>
Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Signed-off-by: Pengyu Ma <pengyu.ma@windriver.com>
---
 drivers/gpu/drm/i915/intel_lrc.c | 79 ++++++++++++++++++++--------------------
 1 file changed, 40 insertions(+), 39 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_lrc.c b/drivers/gpu/drm/i915/intel_lrc.c
index ae85e22..68ea76a 100644
--- a/drivers/gpu/drm/i915/intel_lrc.c
+++ b/drivers/gpu/drm/i915/intel_lrc.c
@@ -1067,12 +1067,13 @@ static int intel_logical_ring_workarounds_emit(struct drm_i915_gem_request *req)
 	return 0;
 }
 
-#define wa_ctx_emit(batch, cmd)						\
+#define wa_ctx_emit(batch, index, cmd)					\
 	do {								\
-		if (WARN_ON(index >= (PAGE_SIZE / sizeof(uint32_t)))) {	\
+		int __index = (index)++;				\
+		if (WARN_ON(__index >= (PAGE_SIZE / sizeof(uint32_t)))) { \
 			return -ENOSPC;					\
 		}							\
-		batch[index++] = (cmd);					\
+		batch[__index] = (cmd);					\
 	} while (0)
 
 
@@ -1098,29 +1099,29 @@ static inline int gen8_emit_flush_coherentl3_wa(struct intel_engine_cs *ring,
 {
 	uint32_t l3sqc4_flush = (0x40400000 | GEN8_LQSC_FLUSH_COHERENT_LINES);
 
-	wa_ctx_emit(batch, (MI_STORE_REGISTER_MEM_GEN8(1) |
-			    MI_SRM_LRM_GLOBAL_GTT));
-	wa_ctx_emit(batch, GEN8_L3SQCREG4);
-	wa_ctx_emit(batch, ring->scratch.gtt_offset + 256);
-	wa_ctx_emit(batch, 0);
-
-	wa_ctx_emit(batch, MI_LOAD_REGISTER_IMM(1));
-	wa_ctx_emit(batch, GEN8_L3SQCREG4);
-	wa_ctx_emit(batch, l3sqc4_flush);
-
-	wa_ctx_emit(batch, GFX_OP_PIPE_CONTROL(6));
-	wa_ctx_emit(batch, (PIPE_CONTROL_CS_STALL |
-			    PIPE_CONTROL_DC_FLUSH_ENABLE));
-	wa_ctx_emit(batch, 0);
-	wa_ctx_emit(batch, 0);
-	wa_ctx_emit(batch, 0);
-	wa_ctx_emit(batch, 0);
-
-	wa_ctx_emit(batch, (MI_LOAD_REGISTER_MEM_GEN8(1) |
-			    MI_SRM_LRM_GLOBAL_GTT));
-	wa_ctx_emit(batch, GEN8_L3SQCREG4);
-	wa_ctx_emit(batch, ring->scratch.gtt_offset + 256);
-	wa_ctx_emit(batch, 0);
+	wa_ctx_emit(batch, index, (MI_STORE_REGISTER_MEM_GEN8(1) |
+				   MI_SRM_LRM_GLOBAL_GTT));
+	wa_ctx_emit(batch, index, GEN8_L3SQCREG4);
+	wa_ctx_emit(batch, index, ring->scratch.gtt_offset + 256);
+	wa_ctx_emit(batch, index, 0);
+
+	wa_ctx_emit(batch, index, MI_LOAD_REGISTER_IMM(1));
+	wa_ctx_emit(batch, index, GEN8_L3SQCREG4);
+	wa_ctx_emit(batch, index, l3sqc4_flush);
+
+	wa_ctx_emit(batch, index, GFX_OP_PIPE_CONTROL(6));
+	wa_ctx_emit(batch, index, (PIPE_CONTROL_CS_STALL |
+				   PIPE_CONTROL_DC_FLUSH_ENABLE));
+	wa_ctx_emit(batch, index, 0);
+	wa_ctx_emit(batch, index, 0);
+	wa_ctx_emit(batch, index, 0);
+	wa_ctx_emit(batch, index, 0);
+
+	wa_ctx_emit(batch, index, (MI_LOAD_REGISTER_MEM_GEN8(1) |
+				   MI_SRM_LRM_GLOBAL_GTT));
+	wa_ctx_emit(batch, index, GEN8_L3SQCREG4);
+	wa_ctx_emit(batch, index, ring->scratch.gtt_offset + 256);
+	wa_ctx_emit(batch, index, 0);
 
 	return index;
 }
@@ -1181,7 +1182,7 @@ static int gen8_init_indirectctx_bb(struct intel_engine_cs *ring,
 	uint32_t index = wa_ctx_start(wa_ctx, *offset, CACHELINE_DWORDS);
 
 	/* WaDisableCtxRestoreArbitration:bdw,chv */
-	wa_ctx_emit(batch, MI_ARB_ON_OFF | MI_ARB_DISABLE);
+	wa_ctx_emit(batch, index, MI_ARB_ON_OFF | MI_ARB_DISABLE);
 
 	/* WaFlushCoherentL3CacheLinesAtContextSwitch:bdw */
 	if (IS_BROADWELL(ring->dev)) {
@@ -1194,19 +1195,19 @@ static int gen8_init_indirectctx_bb(struct intel_engine_cs *ring,
 	/* Actual scratch location is at 128 bytes offset */
 	scratch_addr = ring->scratch.gtt_offset + 2*CACHELINE_BYTES;
 
-	wa_ctx_emit(batch, GFX_OP_PIPE_CONTROL(6));
-	wa_ctx_emit(batch, (PIPE_CONTROL_FLUSH_L3 |
-			    PIPE_CONTROL_GLOBAL_GTT_IVB |
-			    PIPE_CONTROL_CS_STALL |
-			    PIPE_CONTROL_QW_WRITE));
-	wa_ctx_emit(batch, scratch_addr);
-	wa_ctx_emit(batch, 0);
-	wa_ctx_emit(batch, 0);
-	wa_ctx_emit(batch, 0);
+	wa_ctx_emit(batch, index, GFX_OP_PIPE_CONTROL(6));
+	wa_ctx_emit(batch, index, (PIPE_CONTROL_FLUSH_L3 |
+				   PIPE_CONTROL_GLOBAL_GTT_IVB |
+				   PIPE_CONTROL_CS_STALL |
+				   PIPE_CONTROL_QW_WRITE));
+	wa_ctx_emit(batch, index, scratch_addr);
+	wa_ctx_emit(batch, index, 0);
+	wa_ctx_emit(batch, index, 0);
+	wa_ctx_emit(batch, index, 0);
 
 	/* Pad to end of cacheline */
 	while (index % CACHELINE_DWORDS)
-		wa_ctx_emit(batch, MI_NOOP);
+		wa_ctx_emit(batch, index, MI_NOOP);
 
 	/*
 	 * MI_BATCH_BUFFER_END is not required in Indirect ctx BB because
@@ -1242,9 +1243,9 @@ static int gen8_init_perctx_bb(struct intel_engine_cs *ring,
 	uint32_t index = wa_ctx_start(wa_ctx, *offset, CACHELINE_DWORDS);
 
 	/* WaDisableCtxRestoreArbitration:bdw,chv */
-	wa_ctx_emit(batch, MI_ARB_ON_OFF | MI_ARB_ENABLE);
+	wa_ctx_emit(batch, index, MI_ARB_ON_OFF | MI_ARB_ENABLE);
 
-	wa_ctx_emit(batch, MI_BATCH_BUFFER_END);
+	wa_ctx_emit(batch, index, MI_BATCH_BUFFER_END);
 
 	return wa_ctx_end(wa_ctx, *offset = index, 1);
 }
-- 
2.0.2

