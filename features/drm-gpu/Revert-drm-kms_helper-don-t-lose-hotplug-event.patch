From 928f6f4692373a1c97fa62a45b757caf50629cc5 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Fri, 28 Jun 2013 20:31:34 +1000
Subject: [PATCH 592/904] Revert "drm: kms_helper: don't lose hotplug event"

commit d482e5fa299c2cfbb4700143dd766273730e2357 upstream

This reverts commit 160954b7bca43da7cd3cfbce310e6df919a8216e.

This was rearming the workqueue with a 0 timeout, causing
a WARN_ON, and possible loop.

Daniel writes:
"I've looked a bit into this and I think we need to have a separate
work struct for recovering these lost hotplug events since the
continuous self-rearming case is a real risk (e.g. if a connector
flip-flops all the time). At least I don't see a sane way to block out
re-arming with the current code in a simple way. So reverting the
offender seems like the right thing and I'll go back to the drawing
board for 3.12."

Signed-off-by: Dave Airlie <airlied@redhat.com>
---
 drivers/gpu/drm/drm_crtc_helper.c | 32 +-------------------------------
 include/drm/drm_crtc.h            |  1 -
 2 files changed, 1 insertion(+), 32 deletions(-)

diff --git a/drivers/gpu/drm/drm_crtc_helper.c b/drivers/gpu/drm/drm_crtc_helper.c
index f6829ba..738a429 100644
--- a/drivers/gpu/drm/drm_crtc_helper.c
+++ b/drivers/gpu/drm/drm_crtc_helper.c
@@ -122,7 +122,6 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 	int count = 0;
 	int mode_flags = 0;
 	bool verbose_prune = true;
-	enum drm_connector_status old_status;
 
 	DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n", connector->base.id,
 			drm_get_connector_name(connector));
@@ -138,32 +137,7 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 		if (connector->funcs->force)
 			connector->funcs->force(connector);
 	} else {
-		old_status = connector->status;
-
 		connector->status = connector->funcs->detect(connector, true);
-
-		/*
-		 * Normally either the driver's hpd code or the poll loop should
-		 * pick up any changes and fire the hotplug event. But if
-		 * userspace sneaks in a probe, we might miss a change. Hence
-		 * check here, and if anything changed start the hotplug code.
-		 */
-		if (old_status != connector->status) {
-			DRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %d to %d\n",
-				      connector->base.id,
-				      drm_get_connector_name(connector),
-				      old_status, connector->status);
-
-			/*
-			 * The hotplug event code might call into the fb
-			 * helpers, and so expects that we do not hold any
-			 * locks. Fire up the poll struct instead, it will
-			 * disable itself again.
-			 */
-			dev->mode_config.delayed_event = true;
-			schedule_delayed_work(&dev->mode_config.output_poll_work,
-					      0);
-		}
 	}
 
 	/* Re-enable polling in case the global poll config changed. */
@@ -1011,11 +985,7 @@ static void output_poll_execute(struct work_struct *work)
 	struct drm_device *dev = container_of(delayed_work, struct drm_device, mode_config.output_poll_work);
 	struct drm_connector *connector;
 	enum drm_connector_status old_status;
-	bool repoll = false, changed;
-
-	/* Pick up any changes detected by the probe functions. */
-	changed = dev->mode_config.delayed_event;
-	dev->mode_config.delayed_event = false;
+	bool repoll = false, changed = false;
 
 	if (!drm_kms_helper_poll)
 		return;
diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 663c3ab..fa12a2f 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -811,7 +811,6 @@ struct drm_mode_config {
 	/* output poll support */
 	bool poll_enabled;
 	bool poll_running;
-	bool delayed_event;
 	struct delayed_work output_poll_work;
 
 	/* pointers to standard properties */
-- 
1.8.4.93.g57e4c17

