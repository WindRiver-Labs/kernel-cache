From 310b3239640cc018bf8a564ce4cca0202a2c1ccf Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Thu, 19 Aug 2010 18:11:30 +0800
Subject: [PATCH] wrhv/powerpc: enable wrload on 8572ds GOS

o restrict non-self VB operation in vbi syscalls
o export set_msr_for_ap to enable wrload on 8572 GOS

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 arch/powerpc/kernel/vbi/wrhv.c |    1 +
 kernel/vbi/syscall_vbi.c       |   43 +++++++++++++++++++++++++++------------
 2 files changed, 31 insertions(+), 13 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index bcffc5e..ac388fb 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -1501,6 +1501,7 @@ __weak void wrhv_setup_msr_for_ap(VBI_HREG_SET_CMPLX_QUALIFIED *regs)
 {
 	return;
 }
+EXPORT_SYMBOL(wrhv_setup_msr_for_ap);
 
 DEFINE_PER_CPU(long long, tb_diff);
 
diff --git a/kernel/vbi/syscall_vbi.c b/kernel/vbi/syscall_vbi.c
index 86dbb69..71317c6 100644
--- a/kernel/vbi/syscall_vbi.c
+++ b/kernel/vbi/syscall_vbi.c
@@ -20,6 +20,7 @@
 
 #ifdef CONFIG_WRHV
 #include <vbi/vbi.h>
+#include <asm/wrhv.h>
 #endif
 
 #include <asm/uaccess.h>
@@ -41,6 +42,15 @@ asmlinkage long sys_vbi_activate_vb(uint32_t vb, uint32_t addr)
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
+
+	/*
+	 * The policy should be 'do not operate self VB'
+	 */
+	if (vb == VBI_BOARD_ID_GET()) {
+		printk(KERN_ERR "%s: can not operate self VB.\n", __func__);
+		return -EPERM;
+	}
+
 	/*
 	 * Note, here suspend all cores means if dest VB is configured
 	 * as multi CPUs VB, all vcpus of this VB will be suspended.
@@ -69,7 +79,7 @@ asmlinkage long sys_vbi_activate_vb(uint32_t vb, uint32_t addr)
 #endif
 #ifdef CONFIG_PPC
 	rctl.vbiRegSet.hreg32.pc = addr;
-	rctl.vbiRegSet.hreg32.msr = 0x10000000;
+	wrhv_setup_msr_for_ap(&rctl);
 	/* r3, 1st argument pointer to config page */
 	rctl.vbiRegSet.hreg32.gpr[3] = vb_cfg;
 #endif
@@ -103,6 +113,14 @@ asmlinkage long sys_vbi_mem(uint32_t vb, void *dest, void *src,
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
+	/*
+	 * The policy should be 'do not operate self VB'
+	 */
+	if (vb == VBI_BOARD_ID_GET()) {
+		printk(KERN_ERR "%s: can not operate self VB.\n", __func__);
+		return -EPERM;
+	}
+
 	if (size > VBI_MEM_BUF_LEN)
 		return -ENOMEM;
 
@@ -146,6 +164,14 @@ asmlinkage long sys_vbi_control(uint32_t vb, uint32_t command, uint32_t flags)
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
+	/*
+	 * The policy should be 'do not operate self VB'
+	 */
+	if (vb == VBI_BOARD_ID_GET()) {
+		printk(KERN_ERR "%s: can not reset self.\n", __func__);
+		return -EPERM;
+	}
+
 	reset_opts = VBI_VBMGMT_RESET_DOWNLOAD;
 
 	cores = flags & 0xff;
@@ -166,18 +192,9 @@ asmlinkage long sys_vbi_control(uint32_t vb, uint32_t command, uint32_t flags)
 			printk(KERN_ERR "%s: vb_resume VB%d failed.\n", __func__, vb);
 		break;
 	case SYS_VBI_VB_RESTART:
-		if (vb == VBI_BOARD_ID_GET()) {
-			/*
-			 * The policy 'should not suspend self' may change per
-			 * design
-			 */
-			printk(KERN_ERR "%s: can not reset self.\n", __func__);
-			ret = -EPERM;
-		} else {
-			ret = vbi_vb_reset(vb, cores, reset_opts);
-			if (ret)
-				printk(KERN_ERR "%s: vb_reset VB%d failed.\n", __func__, vb);
-		}
+		ret = vbi_vb_reset(vb, cores, reset_opts);
+		if (ret)
+			printk(KERN_ERR "%s: vb_reset VB%d failed.\n", __func__, vb);
 		break;
 	default:
 		ret = -EINVAL;
-- 
1.6.5.2

