From 1ac2567ca822eb5596acfddf37224b9804ddd258 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Mon, 21 Jun 2010 12:08:17 +0800
Subject: [PATCH] x86: jiffies calibration

Guest os has chance to lose hypervisor provided interrupt,
which will cause linux timer precision decline. Here use
wr_vb_status->tick_count to calibrate it.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/x86/kernel/vbi/wrhv.c |   27 ++++++++++++++++++++++++++-
 1 files changed, 26 insertions(+), 1 deletions(-)

diff --git a/arch/x86/kernel/vbi/wrhv.c b/arch/x86/kernel/vbi/wrhv.c
index 4c27738..588f6b9 100644
--- a/arch/x86/kernel/vbi/wrhv.c
+++ b/arch/x86/kernel/vbi/wrhv.c
@@ -17,6 +17,7 @@
 #include <linux/pci.h>
 #include <linux/wrhv.h>
 #include <linux/kgdb.h>
+#include <linux/kernel_stat.h>
 #include <vbi/vbi.h>
 #include <asm/setup.h>
 #include <asm/paravirt.h>
@@ -209,6 +210,9 @@ irqreturn_t wrhv_dummy_timer_interrupt(int irq, void *dev_id)
 
 irqreturn_t wrhv_timer_interrupt(int irq, void *dev_id)
 {
+	u64 ticks;
+	static DEFINE_PER_CPU(u64, mark_offset);
+	static DEFINE_PER_CPU(int, mark_first_time) = 1;
 	int cpu = smp_processor_id();
 	struct clock_event_device *evt = &per_cpu(wrhv_clock_events, cpu);
 
@@ -218,7 +222,28 @@ irqreturn_t wrhv_timer_interrupt(int irq, void *dev_id)
 		return IRQ_NONE;
 	}
 
-	evt->event_handler(evt);
+	if (__get_cpu_var(mark_first_time) == 0) {
+		ticks = wr_vb_status->tick_count;
+		ticks -= __get_cpu_var(mark_offset);
+		__get_cpu_var(mark_offset) = wr_vb_status->tick_count;
+		if (ticks > (2*HZ)) {
+			printk(KERN_DEBUG "Time falling behind %lld jiffies\n",
+				ticks);
+			ticks = 1;
+		}
+	} else {
+		ticks = 1;
+		__get_cpu_var(mark_first_time) = 0;
+		__get_cpu_var(mark_offset) = wr_vb_status->tick_count;
+	}
+
+	if (ticks > 1)
+		account_steal_time(NULL, jiffies_to_cputime(ticks - 1));
+
+	while (ticks != 0) {
+		evt->event_handler(evt);
+		ticks--;
+	}
 
 	return IRQ_HANDLED;
 }
-- 
1.7.0.4

