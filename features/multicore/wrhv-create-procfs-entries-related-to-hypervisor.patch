From 045c2dae944a3047ecb9e0d9ffeb00a94ca728d0 Mon Sep 17 00:00:00 2001
From: Mark Asselstine <mark.asselstine@windriver.com>
Date: Wed, 16 Feb 2011 16:35:18 -0500
Subject: [PATCH] wrhv: create procfs entries related to hypervisor

This commit creates the /proc/windriver entry which will
allow us to consolidate procfs entries related to the
hypervisor under the same root.

The first of these hypervisor procfs entries is also added
as part of this commit. /proc/windriver/hypinfo accesses
the hypervisor vb_config structs present on the system to
display information about each VB.

A sample of what you might see:

        root@sm:/root> cat /proc/windriver/hypinfo
        board          : 1
        name           : linux1
        type           : 1
        cores          : 3
        phys mem size  : 0x20000000
        bootline       : console=ttyS0,9600 rw noinitrd root=/dev/nfs nfs...
        num devices    : 17
        num interrupts : 21
        boot count     : 0
        core id        : 0
        num shared mem : 1
    ...

A helper function required to access the vb_config structs has
been added to wrhv.c as this function is used by at least one
known out of kernel tree module.

Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>
---
 include/linux/wrhv.h |   12 +++++
 kernel/vbi/Makefile  |    2 +-
 kernel/vbi/procfs.c  |  127 ++++++++++++++++++++++++++++++++++++++++++++++++++
 kernel/vbi/procfs.h  |   29 +++++++++++
 kernel/vbi/wrhv.c    |   41 ++++++++++++++++-
 5 files changed, 209 insertions(+), 2 deletions(-)
 create mode 100644 kernel/vbi/procfs.c
 create mode 100644 kernel/vbi/procfs.h

diff --git a/include/linux/wrhv.h b/include/linux/wrhv.h
index 99d0032..4f4f1f9 100644
--- a/include/linux/wrhv.h
+++ b/include/linux/wrhv.h
@@ -15,10 +15,19 @@
 #ifndef __LINUX_WRHV_H
 #define __LINUX_WRHV_H
 
+
 #ifdef CONFIG_WRHV
+
+#include <linux/proc_fs.h>
+#include <linux/irqreturn.h>
+#include <vbi/vbi.h>
+
 extern irqreturn_t wrhv_timer_interrupt(int irq, void *dev_id);
 extern unsigned long wrhv_calculate_cpu_khz(void);
+extern int wrhv_get_vb_config(const int vb, struct vb_config *config);
+
 extern struct irq_chip wrhv_irq_chip;
+extern struct proc_dir_entry *wrhv_procfs_root;
 
 #ifdef CONFIG_SMP
 extern struct irq_chip wrhv_ipi_irq_chip;
@@ -27,6 +36,9 @@ extern struct irq_chip wrhv_ipi_irq_chip;
 #ifdef CONFIG_HOTPLUG_CPU
 extern void wrhv_fixup_irqs(int);
 #endif
+
+#define WINDRIVER_NAME "windriver"
+
 /* IO APIC register get/set macros */
 /* Accesses are double words using an
  * indirect addressing scheme.
diff --git a/kernel/vbi/Makefile b/kernel/vbi/Makefile
index 280ac86..14124fb 100644
--- a/kernel/vbi/Makefile
+++ b/kernel/vbi/Makefile
@@ -7,5 +7,5 @@
 # Except the user ABI, which is always present, and defined in syscall_vbi
 
 obj-$(CONFIG_WRHV) += shmem.o wrhv.o interrupt.o paddr.o idle.o io_apic.o lib.o \
-                      version.o msg.o ns.o show.o pdc.o device.o
+                      version.o msg.o ns.o show.o pdc.o device.o procfs.o
 obj-y += syscall_vbi.o
diff --git a/kernel/vbi/procfs.c b/kernel/vbi/procfs.c
new file mode 100644
index 0000000..e8ab1d7
--- /dev/null
+++ b/kernel/vbi/procfs.c
@@ -0,0 +1,127 @@
+/*
+ * procfs.c - Wind River hypervisor procfs entries
+ *
+ * Copyright (c) 2011 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+#include <linux/wrhv.h>
+
+#include <vbi/vbi.h>
+
+static char hypinfo_name[] = "hypinfo";
+static const char *wind_name = WINDRIVER_NAME;
+
+struct proc_dir_entry *wrhv_procfs_root;
+EXPORT_SYMBOL(wrhv_procfs_root);
+
+/*
+ * Implement a seq_file to display hypinfo for all VBs
+ */
+static int show_hypinfo(struct seq_file *m, void *v)
+{
+	struct vb_config *config = v;
+
+	seq_printf(m, "board          : %u\n", config->boardID);
+	seq_printf(m, "name           : %s\n", config->board_name);
+	seq_printf(m, "type           : %u\n", config->board_type);
+	seq_printf(m, "cores          : %u\n", config->numCores);
+	seq_printf(m, "phys mem size  : 0x%X\n", config->phys_mem_size);
+	seq_printf(m, "bootline       : %s\n", config->bootLine);
+	seq_printf(m, "num devices    : %u\n", config->numDevices);
+	seq_printf(m, "num interrupts : %u\n", config->num_ints);
+	seq_printf(m, "boot count     : %u\n", config->boot_count);
+	seq_printf(m, "core id        : %u\n", config->coreId);
+	seq_printf(m, "num shared mem : %u\n", config->num_sm);
+	seq_printf(m, "\n");
+
+	return 0;
+}
+
+static void *hyp_start(struct seq_file *m, loff_t *pos)
+{
+	int vb = (*pos) + 1;
+	struct vb_config *config = kmalloc(sizeof(struct vb_config),
+					   GFP_KERNEL);
+	if (!config)
+		return NULL;
+	if (wrhv_get_vb_config(vb, config) < 0)
+		return NULL;
+
+	return config;
+}
+
+static void *hyp_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	int vb;
+	struct vb_config *config = v;
+
+	++(*pos);
+	vb = (*pos) + 1;
+
+	if (wrhv_get_vb_config(vb, config) < 0)
+		return NULL;
+
+	return config;
+}
+
+static void hyp_stop(struct seq_file *m, void *v)
+{
+	kfree(v);
+}
+
+static const struct seq_operations hypinfo_op = {
+	.start  = hyp_start,
+	.next   = hyp_next,
+	.stop   = hyp_stop,
+	.show   = show_hypinfo,
+};
+
+static int hypinfo_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &hypinfo_op);
+}
+
+static const struct file_operations procfs_hypinfo_operations = {
+	.open           = hypinfo_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = seq_release,
+};
+
+void wrhv_init_procfs(void)
+{
+	struct proc_dir_entry *hypinfo_procfs = NULL;
+
+	wrhv_procfs_root = proc_mkdir(wind_name, NULL);
+	if (!wrhv_procfs_root) {
+		printk(KERN_CRIT "ERROR. unable to create /proc/%s", wind_name);
+		return;
+	}
+
+	hypinfo_procfs = proc_create(hypinfo_name, 0,
+				   wrhv_procfs_root,
+				   &procfs_hypinfo_operations);
+	if (!hypinfo_procfs) {
+		printk(KERN_WARNING "Cannot create %s/%s\n",
+		       wind_name,
+		       hypinfo_name);
+	}
+}
diff --git a/kernel/vbi/procfs.h b/kernel/vbi/procfs.h
new file mode 100644
index 0000000..54769d2
--- /dev/null
+++ b/kernel/vbi/procfs.h
@@ -0,0 +1,29 @@
+/*
+ * procfs.h
+ *
+ * Copyright (c) 2011 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#ifndef __KERNEL_VBI_PROCFS_H
+#define __KERNEL_VBI_PROCFS_H
+
+/*
+ * Add Wind River hypervisor procfs entries.
+ */
+void wrhv_init_procfs(void);
+
+#endif
diff --git a/kernel/vbi/wrhv.c b/kernel/vbi/wrhv.c
index f8c5bf3..2dbc700 100644
--- a/kernel/vbi/wrhv.c
+++ b/kernel/vbi/wrhv.c
@@ -29,6 +29,8 @@
 #include <linux/reboot.h>
 #include <linux/pci.h>
 
+#include "procfs.h"
+
 #define VIOAPIC_BASE_ADDR	(&wr_vb_control->vIoapic)
 
 #ifdef CONFIG_SMP
@@ -643,7 +645,6 @@ static void __devinit pci_fixup_wrhv(struct pci_dev *dev)
 DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_wrhv);
 #endif
 
-#define WINDRIVER_NAME "windriver"
 /* sysfs ksets */
 struct kset *windriver_kset;
 EXPORT_SYMBOL(windriver_kset);
@@ -765,10 +766,48 @@ int wrhv_register_reboot_notifier(void)
 	return ret;
 }
 
+
+/*
+ * Query the hypervisor to get the vb_config struct for a VB
+ * return < 0 on failure
+ */
+int wrhv_get_vb_config(const int vb, struct vb_config *config)
+{
+	unsigned long cfg_paddr;
+
+	if (config == NULL)
+		return -EFAULT;
+	if (vb >= VB_MAX_VIRTUAL_BOARDS)
+		return -EINVAL;
+
+	if (vbi_vb_find_board_config(vb, 0, (void *)&cfg_paddr) == 0) {
+		struct vbi_mem_ctl mem_ctl;
+
+		memset(config, 0, sizeof(struct vb_config));
+
+		mem_ctl.pBuffer = (void *)cfg_paddr;
+		mem_ctl.pAddress = (void *)config;
+		mem_ctl.size_in = sizeof(struct vb_config);
+		mem_ctl.size_out = 0;
+		mem_ctl.flags = 0;
+
+		if (vbi_vb_read_mem(&mem_ctl, vb) != 0) {
+			printk(KERN_ERR "offload_manager: failed to read "
+			       "vb_config. (VB #%d)\n", vb);
+			return -EIO;
+		}
+	} else {
+		return -EIO;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(wrhv_get_vb_config);
+
 int __init wrhv_late_init(void)
 {
 	wrhv_arch_late_init();
 	suspend_set_ops(&wrhv_suspend_ops);
+	wrhv_init_procfs();
 	wrhv_init_sysfs();
 	wrhv_init_debugfs();
 	wrhv_hysh_init_sysfs();
-- 
1.6.5.2

