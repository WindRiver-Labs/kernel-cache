From 844e48885c01f158b698a876047136165945cf7f Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Fri, 4 Mar 2011 02:49:33 +0800
Subject: [PATCH 1/2] wrhv/ppc: fix a bug in mapping vb configuration pages

According to the comments previously we don't know the size of the
object we mapped. Then we just assume that it is just use one page.
But things have changed. Now we already got the object size,
and in some cases it is beyond one page size. So we should take
into account the size when mapping.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/kernel/vbi/wrhv.c |   25 ++++++++++++++++---------
 1 files changed, 16 insertions(+), 9 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 4b4441c..ac93256 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -312,16 +312,22 @@ static int __init wrhv_enable_dir_irq(void)
 	return 0;
 }
 
-void wrhv_mapping(void)
+static void wrhv_map_pages(unsigned long addr, size_t size, int flags)
 {
-	/*
-	 * WRHV vb_config should really add a length field for each
-	 * of the objected we mapped.  As the sizes are WRHV
-	 * implementation AND worse, configuration dependent.
-	 *
-	 * For now, we just use 1 page which is fine for the time being.
-	 */
+	unsigned long va, i;
+	int r;
+
+	va = addr & PAGE_MASK;
+	size = PAGE_ALIGN(addr + size) - va;
 
+	for (i = 0; i < size; i += PAGE_SIZE) {
+		r = map_page(va + i, va + i, flags);
+		WARN_ON_ONCE(r);
+	}
+}
+
+void wrhv_mapping(void)
+{
 	struct config_page_map *pConfigPageMap = &wr_config->configPageMap[0];
 	uint32_t index = wr_config->configPageNum, i = 0;
 	for (i = 0;i < index;i++) {
@@ -332,7 +338,8 @@ void wrhv_mapping(void)
 			pConfigPageMap[i].accessPriv,
 			pConfigPageMap[i].size);
 #endif
-		map_page((unsigned long)pConfigPageMap[i].address, (unsigned long)pConfigPageMap[i].address, 
+		wrhv_map_pages((unsigned long)pConfigPageMap[i].address,
+			pConfigPageMap[i].size,
 #ifdef CONFIG_PPC85xx_VT_MODE
 			pConfigPageMap[i].accessPriv ? PAGE_KERNEL : PAGE_KERNEL_RO);
 #else
-- 
1.6.5.2

