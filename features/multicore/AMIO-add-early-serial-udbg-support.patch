From 5a1e7ff31b648d551059ca13a7367f5639a3e493 Mon Sep 17 00:00:00 2001
From: Keith Backensto <keith.backensto@windriver.com>
Date: Fri, 28 May 2010 19:17:15 -0700
Subject: [PATCH] AMIO: add early serial/udbg support.

Hook in the AMIO virtual UART driver in a way similar to the
existing 16550 UART early serial support so that we can
deliver a few more of the early boot lines in the event of
a boot failure before the main serial initialization routine
is run.

Signed-off-by: Keith Backensto <keith.backensto@windriver.com>
---
 arch/powerpc/include/asm/serial.h   |    4 ++
 arch/powerpc/kernel/setup_32.c      |    4 ++
 arch/powerpc/platforms/85xx/Kconfig |    2 +-
 arch/powerpc/platforms/86xx/Kconfig |    2 +-
 arch/powerpc/platforms/chrp/Kconfig |    2 +-
 drivers/serial/Kconfig              |   11 +++--
 drivers/serial/amio_uart.c          |   70 ++++++++++++++++++++++++++--------
 7 files changed, 71 insertions(+), 24 deletions(-)

diff --git a/arch/powerpc/include/asm/serial.h b/arch/powerpc/include/asm/serial.h
index 3e8589b..9a1fed1 100644
--- a/arch/powerpc/include/asm/serial.h
+++ b/arch/powerpc/include/asm/serial.h
@@ -21,4 +21,8 @@ extern void find_legacy_serial_ports(void);
 #define find_legacy_serial_ports()	do { } while (0)
 #endif
 
+#ifdef CONFIG_SERIAL_AMIO_UDBG
+extern int amio_udbg_init(void);
+#endif
+
 #endif /* _PPC64_SERIAL_H */
diff --git a/arch/powerpc/kernel/setup_32.c b/arch/powerpc/kernel/setup_32.c
index 47883cd..413dbb8 100644
--- a/arch/powerpc/kernel/setup_32.c
+++ b/arch/powerpc/kernel/setup_32.c
@@ -312,6 +312,10 @@ void __init setup_arch(char **cmdline_p)
 
 	find_legacy_serial_ports();
 
+#ifdef CONFIG_SERIAL_AMIO_UDBG
+	amio_udbg_init();
+#endif
+
 	smp_setup_cpu_maps();
 
 	/* Register early console */
diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index 05df89b..c6516f6 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -1,7 +1,7 @@
 menuconfig MPC85xx
 	bool "Machine Type"
 	depends on PPC_85xx
-	select PPC_UDBG_16550
+	select PPC_UDBG_16550 if !SERIAL_AMIO_UDBG
 	select MPIC
 	select PPC_PCI_CHOICE
 	select FSL_PCI if PCI
diff --git a/arch/powerpc/platforms/86xx/Kconfig b/arch/powerpc/platforms/86xx/Kconfig
index 0b175a9..2dd7420 100644
--- a/arch/powerpc/platforms/86xx/Kconfig
+++ b/arch/powerpc/platforms/86xx/Kconfig
@@ -42,7 +42,7 @@ config MPC8641
 	bool
 	select PPC_PCI_CHOICE
 	select FSL_PCI if PCI
-	select PPC_UDBG_16550
+	select PPC_UDBG_16550 if !SERIAL_AMIO_UDBG
 	select MPIC
 	default y if MPC8641_HPCN || SBC8641D  || WRHV_8641D
 
diff --git a/arch/powerpc/platforms/chrp/Kconfig b/arch/powerpc/platforms/chrp/Kconfig
index 22b4b4e..62363a3 100644
--- a/arch/powerpc/platforms/chrp/Kconfig
+++ b/arch/powerpc/platforms/chrp/Kconfig
@@ -6,7 +6,7 @@ config PPC_CHRP
 	select PPC_INDIRECT_PCI
 	select PPC_RTAS
 	select PPC_MPC106
-	select PPC_UDBG_16550
+	select PPC_UDBG_16550 if !SERIAL_AMIO_UDBG
 	select PPC_NATIVE
 	select PCI
 	default y
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index 4c1582a..29e27e0 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -1450,15 +1450,18 @@ config SERIAL_AMIO_CONSOLE
 	bool "Console on AMIO serial port"
 	depends on SERIAL_AMIO=y
 	select SERIAL_CORE_CONSOLE
+	select SERIAL_AMIO_UDBG
 	default y
 	help
 	  Say Y here if you want to support a serial AMIO console.
 
-	  Even if you say Y here, the currently visible virtual console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttyAMIO0". (Try "man bootparam" or see the documentation of
+	  You will also need to set "console=ttyAMIO0" as a kernel command
+	  line option. (Try "man bootparam" or see the documentation of
 	  your boot loader (grub or lilo or loadlin) about how to pass options
 	  to the kernel at boot time.)
 
+config SERIAL_AMIO_UDBG
+	bool
+	default n
+
 endmenu
diff --git a/drivers/serial/amio_uart.c b/drivers/serial/amio_uart.c
index 42331bc..0044cb0 100644
--- a/drivers/serial/amio_uart.c
+++ b/drivers/serial/amio_uart.c
@@ -31,6 +31,7 @@
 #include <linux/serial_core.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <asm/udbg.h>
 #include <asm/io.h>
 
 #include <vbi/types.h>
@@ -129,6 +130,21 @@ static int amio_poll_input(struct amio_port *aport, char *pchar)
 	return 0;
 }
 
+static void amio_start_tx(struct uart_port *port)
+{
+	struct amio_port *aport = (struct amio_port*)port;
+	struct circ_buf *xmit = &port->info->xmit;
+
+	while (amio_poll_output(aport, xmit->buf[xmit->tail]) == 0) {
+
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+
+		if (uart_circ_empty(xmit))
+			break;
+	}
+}
+
 /*
  * Check shm region for data from AMIO server VB.
  */
@@ -140,6 +156,7 @@ static irqreturn_t amio_int(int irq, void *dev_id)
 {
 	struct amio_port *aport = dev_id;
 	struct tty_struct *tty = aport->port.info->port.tty;
+	struct circ_buf *xmit = &aport->port.info->xmit;
 	unsigned long flags;
 	char c = 0;
 
@@ -151,27 +168,18 @@ static irqreturn_t amio_int(int irq, void *dev_id)
 		tty_flip_buffer_push(tty);
 	}
 
+	if (!uart_circ_empty(xmit)) {
+		amio_start_tx(&aport->port);
+		if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+			uart_write_wakeup(&aport->port);
+	}
+
 	spin_unlock_irqrestore(&aport->port.lock, flags);
 #ifndef CONFIG_X86
 	return IRQ_HANDLED;
 #endif
 }
 
-static void amio_start_tx(struct uart_port *port)
-{
-	struct amio_port *aport = (struct amio_port*)port;
-	struct circ_buf *xmit = &port->info->xmit;
-
-	while (amio_poll_output(aport, xmit->buf[xmit->tail]) == 0) {
-
-		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
-		port->icount.tx++;
-
-		if (uart_circ_empty(xmit))
-			break;
-	}
-}
-
 static int amio_startup(struct uart_port *port)
 {
 	struct amio_port *aport = (struct amio_port *)port;
@@ -267,13 +275,16 @@ static struct uart_ops amio_ops = {
 	.verify_port	= amio_verify_port,
 };
 
-static int __devinit amio_init_port(int line, int channel_id)
+static int __init amio_init_port(int line, int channel_id)
 {
 	struct amio_port *aport = &amio_ports[line];
 	char shm_name[VB_NAMELEN];
 	unsigned int attr;
 	unsigned int shmsize;
 
+	if (aport->port.membase)
+	    return 0;
+
 	memset(&aport->port, 0, sizeof(struct uart_port));
 
 	sprintf(shm_name, "amioSerialChannel%d", channel_id);
@@ -377,6 +388,31 @@ console_initcall(amio_console_init);
 #define AMIO_CONSOLE	NULL
 #endif /* CONFIG_SERIAL_AMIO_CONSOLE */
 
+#ifdef CONFIG_SERIAL_AMIO_UDBG
+static void amio_udbg_putc(char c)
+{
+	while (amio_poll_output(&amio_ports[0], c) == -EAGAIN)
+		barrier();
+
+	if (c == '\n')
+		amio_udbg_putc('\r');
+}
+
+int __init amio_udbg_init(void)
+{
+	int ret;
+
+	if ((ret = amio_init_port(0, wr_config->boardID)) != 0)
+		return ret;
+
+	udbg_putc = amio_udbg_putc;
+	udbg_getc = NULL;
+	udbg_getc_poll = NULL;
+
+	return 0;
+}
+#endif /* CONFIG_SERIAL_AMIO_UDBG */
+
 static struct uart_driver amio_reg = {
 	.owner		= THIS_MODULE,
 	.driver_name	= AMIO_DRIVER_NAME,
@@ -387,7 +423,7 @@ static struct uart_driver amio_reg = {
 	.cons		= AMIO_CONSOLE,
 };
 
-static int __devinit serial_amio_probe(struct platform_device *pdev)
+static int __init serial_amio_probe(struct platform_device *pdev)
 {
 	struct amio_port *aport = &amio_ports[pdev->id];
 	int ret;
-- 
1.7.1.rc2

