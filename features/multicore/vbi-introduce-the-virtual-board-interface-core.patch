From 2973eee16c92bafcd4862371cbcdb0d3ad2847e5 Mon Sep 17 00:00:00 2001
From: Jim Somerville <Jim.Somerville@windriver.com>
Date: Fri, 10 Dec 2010 14:37:33 -0500
Subject: [PATCH 001/166] vbi: introduce the virtual board interface core

This brings in the VBI core support, consistent with the
Dec 3, 2010 1.2.0.2 release plus with the linux specific
adaptations of those files already present.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
Signed-off-by: Jim Somerville <Jim.Somerville@windriver.com>
---
 arch/powerpc/include/asm/arch_vbi.h    |  721 ++++++++++++
 arch/powerpc/include/asm/ppc85xx_vbi.h |  631 ++++++++++
 arch/powerpc/include/asm/reg_vbi.h     |   58 +
 arch/powerpc/include/asm/vbi.h         |  526 +++++++++
 arch/powerpc/kernel/vbi/Makefile       |    5 +
 arch/powerpc/kernel/vbi/show.c         |   90 ++
 arch/powerpc/kernel/vbi/syscalls.S     |  769 +++++++++++++
 arch/x86/include/asm/arch_vbi.h        |  414 +++++++
 arch/x86/include/asm/reg_vbi.h         | 1875 ++++++++++++++++++++++++++++++
 arch/x86/include/asm/vbi.h             |  143 +++
 arch/x86/kernel/vbi/Makefile           |   13 +
 arch/x86/kernel/vbi/syscalls.S         |  582 ++++++++++
 include/asm-x86/arch_vbi.h             |  152 +++
 include/asm-x86/reg_vbi.h              | 1959 ++++++++++++++++++++++++++++++++
 include/asm-x86/vbi.h                  |  137 +++
 include/vbi/arch.h                     |   34 +
 include/vbi/compat.h                   |  234 ++++
 include/vbi/cpu_types.h                |   76 ++
 include/vbi/device.h                   |   44 +
 include/vbi/errors.h                   |   57 +
 include/vbi/interface.h                |  665 +++++++++++
 include/vbi/interrupt.h                |   33 +
 include/vbi/io_apic.h                  |  105 ++
 include/vbi/pdc.h                      |  115 ++
 include/vbi/private.h                  |   47 +
 include/vbi/shmem.h                    |   41 +
 include/vbi/syscall.h                  |  170 +++
 include/vbi/syscalls.h                 |  340 ++++++
 include/vbi/types.h                    |   35 +
 include/vbi/vbi.h                      |  558 +++++++++
 include/vbi/version.h                  |   44 +
 include/vbi/vmmu.h                     |  286 +++++
 kernel/vbi/Makefile                    |   11 +
 kernel/vbi/device.c                    |  252 ++++
 kernel/vbi/idle.c                      |   44 +
 kernel/vbi/interrupt.c                 |   67 ++
 kernel/vbi/io_apic.c                   |  366 ++++++
 kernel/vbi/lib.c                       |  213 ++++
 kernel/vbi/msg.c                       |   55 +
 kernel/vbi/ns.c                        |   84 ++
 kernel/vbi/paddr.c                     |   59 +
 kernel/vbi/pdc.c                       |  142 +++
 kernel/vbi/shmem.c                     |  132 +++
 kernel/vbi/show.c                      |  294 +++++
 kernel/vbi/version.c                   |   47 +
 45 files changed, 12725 insertions(+), 0 deletions(-)
 create mode 100644 arch/powerpc/include/asm/arch_vbi.h
 create mode 100644 arch/powerpc/include/asm/ppc85xx_vbi.h
 create mode 100644 arch/powerpc/include/asm/reg_vbi.h
 create mode 100644 arch/powerpc/include/asm/vbi.h
 create mode 100644 arch/powerpc/kernel/vbi/Makefile
 create mode 100644 arch/powerpc/kernel/vbi/show.c
 create mode 100644 arch/powerpc/kernel/vbi/syscalls.S
 create mode 100644 arch/x86/include/asm/arch_vbi.h
 create mode 100644 arch/x86/include/asm/reg_vbi.h
 create mode 100644 arch/x86/include/asm/vbi.h
 create mode 100644 arch/x86/kernel/vbi/Makefile
 create mode 100644 arch/x86/kernel/vbi/syscalls.S
 create mode 100644 include/asm-x86/arch_vbi.h
 create mode 100644 include/asm-x86/reg_vbi.h
 create mode 100644 include/asm-x86/vbi.h
 create mode 100644 include/vbi/arch.h
 create mode 100644 include/vbi/compat.h
 create mode 100644 include/vbi/cpu_types.h
 create mode 100644 include/vbi/device.h
 create mode 100644 include/vbi/errors.h
 create mode 100644 include/vbi/interface.h
 create mode 100644 include/vbi/interrupt.h
 create mode 100644 include/vbi/io_apic.h
 create mode 100644 include/vbi/pdc.h
 create mode 100644 include/vbi/private.h
 create mode 100644 include/vbi/shmem.h
 create mode 100644 include/vbi/syscall.h
 create mode 100644 include/vbi/syscalls.h
 create mode 100644 include/vbi/types.h
 create mode 100644 include/vbi/vbi.h
 create mode 100644 include/vbi/version.h
 create mode 100644 include/vbi/vmmu.h
 create mode 100644 kernel/vbi/Makefile
 create mode 100644 kernel/vbi/device.c
 create mode 100644 kernel/vbi/idle.c
 create mode 100644 kernel/vbi/interrupt.c
 create mode 100644 kernel/vbi/io_apic.c
 create mode 100644 kernel/vbi/lib.c
 create mode 100644 kernel/vbi/msg.c
 create mode 100644 kernel/vbi/ns.c
 create mode 100644 kernel/vbi/paddr.c
 create mode 100644 kernel/vbi/pdc.c
 create mode 100644 kernel/vbi/shmem.c
 create mode 100644 kernel/vbi/show.c
 create mode 100644 kernel/vbi/version.c

diff --git a/arch/powerpc/include/asm/arch_vbi.h b/arch/powerpc/include/asm/arch_vbi.h
new file mode 100644
index 0000000..484f277
--- /dev/null
+++ b/arch/powerpc/include/asm/arch_vbi.h
@@ -0,0 +1,721 @@
+/*
+ * arch_vbi.h - PowerPC architecture specific definitions
+ *
+ * Copyright 2009 Wind River Systems, Inc.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef _ASM_ARCH_VBI_H
+#define _ASM_ARCH_VBI_H
+
+/* PPC uses big endian byte ordering */
+
+#define __VBI_BYTE_ORDER __VBI_BIG_ENDIAN
+
+/* exceptions generated by the hypervisor */
+
+#define VBI_EXC_OFF_MACH	0x0200	/* machine check */
+#define VBI_EXC_OFF_DATA	0x0300	/* data storage */
+#define VBI_EXC_OFF_INST	0x0400	/* instruction storage */
+#define VBI_EXC_OFF_INTR	0x0500	/* external interrupt*/
+#define VBI_EXC_OFF_ALIGN	0x0600	/* alignment error */
+#define VBI_EXC_OFF_PROG	0x0700	/* program check */
+#define VBI_EXC_OFF_FPU		0x0800	/* floating point */
+#define VBI_EXC_OFF_SYSCALL	0x0900	/* system call */
+#define VBI_EXC_OFF_DATA_MISS	0x0e00	/* MMU data miss */
+#define VBI_EXC_OFF_INST_MISS	0x0f00	/* MMU instruction miss*/
+#define VBI_EXC_OFF_DECR	0x0b00	/* decrementer */
+#define VBI_CLOCK_TIMER_VECTOR	(VBI_EXC_OFF_DECR >> 8)
+
+#define VBI_MAX_CORES		8	/* maximum number of virtual cores */
+
+/* exception defines */
+
+#define ARCH_MAX_INTERRUPT		36
+#define VBI_ARCH_EXC_TABLE_SIZE		36
+#define VBI_ARCH_IRQ_TABLE_SIZE		256
+
+/* VIOAPIC number of entries */
+
+#define VB_VIOAPIC_ENTRIES_SIZE		64
+
+#define _WRHV_ARCH_HAS_STATUS_REGS	1
+#define _WRHV_ARCH_HAS_CTRL_REGS	1
+
+#define VB_STATUS_REGS_OFFSET_BASE	0
+#define VB_STATUS_SRR0			(4 * (VB_STATUS_REGS_OFFSET_BASE +0))
+#define VB_STATUS_SRR1			(4 * (VB_STATUS_REGS_OFFSET_BASE +1))
+#define VB_STATUS_CR			(4 * (VB_STATUS_REGS_OFFSET_BASE +2))
+#define VB_STATUS_LR			(4 * (VB_STATUS_REGS_OFFSET_BASE +3))
+#define VB_STATUS_R3			(4 * (VB_STATUS_REGS_OFFSET_BASE +4))
+#define VB_STATUS_R4			(4 * (VB_STATUS_REGS_OFFSET_BASE +5))
+#define VB_STATUS_MCSRR0		(4 * (VB_STATUS_REGS_OFFSET_BASE +6))
+#define VB_STATUS_MCSRR1		(4 * (VB_STATUS_REGS_OFFSET_BASE +7))
+#define VB_STATUS_ESR			(4 * (VB_STATUS_REGS_OFFSET_BASE +8))
+#define VB_STATUS_MCSR			(4 * (VB_STATUS_REGS_OFFSET_BASE +9))
+#define VB_STATUS_MCAR			(4 * (VB_STATUS_REGS_OFFSET_BASE +10))
+#define VB_STATUS_DEAR			(4 * (VB_STATUS_REGS_OFFSET_BASE +11))
+#define VB_STATUS_EMSR			(4 * (VB_STATUS_REGS_OFFSET_BASE +12))
+#define VB_STATUS_ESRR0			(4 * (VB_STATUS_REGS_OFFSET_BASE +13))
+#define VB_STATUS_ESRR1			(4 * (VB_STATUS_REGS_OFFSET_BASE +14))
+#define VB_STATUS_SPEFSCR		(4 * (VB_STATUS_REGS_OFFSET_BASE +15))
+#define VB_STATUS_ASID			(4 * (VB_STATUS_REGS_OFFSET_BASE +16))
+#define VB_STATUS_RESERVED1_2		(4 * (VB_STATUS_REGS_OFFSET_BASE +17))
+#define VB_STATUS_RESERVED1_3		(4 * (VB_STATUS_REGS_OFFSET_BASE +18))
+#define VB_STATUS_RESERVED1_4		(4 * (VB_STATUS_REGS_OFFSET_BASE +19))
+#define VB_STATUS_RESERVED1_5		(4 * (VB_STATUS_REGS_OFFSET_BASE +20))
+#define VB_STATUS_RESERVED1_6		(4 * (VB_STATUS_REGS_OFFSET_BASE +21))
+#define VB_STATUS_RESERVED1_7		(4 * (VB_STATUS_REGS_OFFSET_BASE +22))
+#define VB_STATUS_SVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +23))
+#define VB_STATUS_PIR			(4 * (VB_STATUS_REGS_OFFSET_BASE +24))
+#define VB_STATUS_PVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +25))
+#define VB_STATUS_HID0			(4 * (VB_STATUS_REGS_OFFSET_BASE +26))
+#define VB_STATUS_HID1			(4 * (VB_STATUS_REGS_OFFSET_BASE +27))
+#define VB_STATUS_BUSCR			(4 * (VB_STATUS_REGS_OFFSET_BASE +28))
+#define VB_STATUS_L1CSR0		(4 * (VB_STATUS_REGS_OFFSET_BASE +29))
+#define VB_STATUS_L1CSR1		(4 * (VB_STATUS_REGS_OFFSET_BASE +30))
+#define VB_STATUS_RESERVED2_0		(4 * (VB_STATUS_REGS_OFFSET_BASE +31))
+#define VB_STATUS_RESERVED2_1		(4 * (VB_STATUS_REGS_OFFSET_BASE +32))
+#define VB_STATUS_RESERVED2_2		(4 * (VB_STATUS_REGS_OFFSET_BASE +33))
+#define VB_STATUS_RESERVED2_3		(4 * (VB_STATUS_REGS_OFFSET_BASE +34))
+#define VB_STATUS_RESERVED2_4		(4 * (VB_STATUS_REGS_OFFSET_BASE +35))
+#define VB_STATUS_RESERVED2_5		(4 * (VB_STATUS_REGS_OFFSET_BASE +36))
+#define VB_STATUS_RESERVED2_6		(4 * (VB_STATUS_REGS_OFFSET_BASE +37))
+#define VB_STATUS_RESERVED2_7		(4 * (VB_STATUS_REGS_OFFSET_BASE +38))
+#define VB_STATUS_RESERVED2_8		(4 * (VB_STATUS_REGS_OFFSET_BASE +39))
+
+
+#define VB_STATUS_REG_STRUCT_END	(4 * (VB_STATUS_REGS_OFFSET_BASE +40))
+
+/* Bit Mask definitions for VB_STATUS_INT_PENDING */
+
+#define VB_STATUS_INT_PENDING_INT	1	/* Interrupt controller */
+#define VB_STATUS_INT_PENDING_TICK	2	/* Tick interrupt */
+
+
+#define VB_CONTROL_REGS_OFFSET_BASE	0
+#define VB_CONTROL_SRR0			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 0))
+#define VB_CONTROL_SRR1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 1))
+#define VB_CONTROL_CR			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 2))
+#define VB_CONTROL_R0			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 3))
+#define VB_CONTROL_R1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 4))
+#define VB_CONTROL_SP			VB_CONTROL_R1
+#define VB_CONTROL_R2			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 5))
+#define VB_CONTROL_R3			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 6))
+#define VB_CONTROL_R4			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 7))
+#define VB_CONTROL_R5			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 8))
+#define VB_CONTROL_R6			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 9))
+#define VB_CONTROL_R7			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 10))
+#define VB_CONTROL_R8			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 11))
+#define VB_CONTROL_R9			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 12))
+#define VB_CONTROL_R10			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 13))
+#define VB_CONTROL_R11			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 14))
+#define VB_CONTROL_R12			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 15))
+#define VB_CONTROL_R13			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 16))
+#define VB_CONTROL_EMSR			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 17))
+#define VB_CONTROL_DBSR			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 18))
+#define VB_CONTROL_DBCR0		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 19))
+#define VB_CONTROL_DBCR1		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 20))
+#define VB_CONTROL_DBCR2		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 21))
+#define VB_CONTROL_IAC1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 22))
+#define VB_CONTROL_IAC2			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 23))
+#define VB_CONTROL_DAC1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 24))
+#define VB_CONTROL_DAC2			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 25))
+#define VB_CONTROL_SPEFSCR		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 26))
+#define VB_CONTROL_ASID			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 27))
+#define VB_CONTROL_RESERVED2		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 28))
+#define VB_CONTROL_RESERVED3		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 29))
+#define VB_CONTROL_RESERVED4		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 30))
+#define VB_CONTROL_RESERVED5		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 31))
+#define VB_CONTROL_RESERVED6		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 32))
+#define VB_CONTROL_RESERVED7		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 33))
+#define VB_CONTROL_RESERVED8		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 34))
+#define VB_CONTROL_RESERVED9		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 35))
+
+/* status register size for ppc */
+
+#define VB_CONTROL_REG_STRUCT_END	(4 * (VB_CONTROL_REGS_OFFSET_BASE + 36))
+
+/* mdio messages */
+#define MDIO_READ		1
+#define MDIO_WRITE		2
+#define MDIO_INT_ENABLE		3
+#define MDIO_INT_DISABLE	4
+#define BSP_CLK_FREQ		5
+#define BSP_CORE_FREQ		6
+
+#ifndef _ASMLANGUAGE
+
+#define VB_STATUS_REGS_ACCESS(base, field)	\
+	base->vb_status_regs.field
+
+#define VB_CONTROL_REGS_ACCESS(base, field)	\
+	base->vb_control_regs.field
+
+/*
+ * vb_arch_ctrl_regs - Virtual core PPC control structure
+ *
+ * Virtual board emulated control registers. These registers are used
+ * by a guest running on hypervisor to configure the virtual CPU register.
+ *
+ * PPC Control structure graphical illustration
+ *
+ *        _______________
+ *       |       PC      |
+ *       |---------------|
+ *       |       MSR     |
+ *       |---------------|
+ *       |       CR      |
+ *       |---------------|
+ *       |               |
+ *       |general purpose|
+ *       |     r[0:13]   |
+ *       |               |
+ *       |---------------|
+ *       |emulated MSR   |
+ *       |---------------|
+ *       |       dbsr    |
+ *       |---------------|
+ *       | dbcr[0:2]     |
+ *       |---------------|
+ *       |IAC[1:2]       |
+ *       |---------------|
+ *       |DAC[1:2]       |
+ *       |---------------|
+ *       |reserved[0:9]  |
+ *       |---------------|
+ *
+ *
+ */
+
+struct vb_arch_ctrl_regs
+{
+	/* Registers to be restored by the VDK_SYS_ctx_load fast system call */
+
+	uint32_t srr0;		/*  0: PC */
+	uint32_t srr1;		/*  1: MSR */
+	uint32_t cr;		/*  2: condition registers */
+	uint32_t r0;		/*  3: General register R0 */
+	uint32_t sp;		/*  4: General register R1 (stack pointer) */
+	uint32_t r2;		/*  5: General register R2 */
+	uint32_t r3;		/*  6: General register R3 */
+	uint32_t r4;		/*  7: General register R4 */
+	uint32_t r5;		/*  8: General register R5 */
+	uint32_t r6;		/*  9: General register R6 */
+	uint32_t r7;		/* 10: General register R7 */
+	uint32_t r8;		/* 11: General register R8 */
+	uint32_t r9;		/* 12: General register R9 */
+	uint32_t r10;		/* 13: General register R10 */
+	uint32_t r11;		/* 14: General register R11 */
+	uint32_t r12;		/* 15: General register R12 */
+	uint32_t r13;		/* 16: General register R13 */
+
+	uint32_t emsr;		/* 17: emulated MSR register */
+
+	/* Debug control registers */
+
+	uint32_t dbsr;		/* 18 - debug status register */
+
+	/* Debug control registers */
+
+	uint32_t dbcr0;		/* 19 - debug control register 0 */
+	uint32_t dbcr1;		/* 20 - debug control register 1 */
+	uint32_t dbcr2;		/* 21 - debug control register 2 */
+
+	/* instruction address compare registers IAC1-IAC2 */
+
+	uint32_t iac1;		/* 22 - instructions access control 1 */
+	uint32_t iac2;		/* 23 - instructions access control 2 */
+
+	/* data address compare registers DAC1-DAC2. */
+
+	uint32_t dac1;		/* 24 - instructions access control 3 */
+	uint32_t dac2;		/* 25 - instructions access control 4 */
+#if (CPU==PPC85XX)
+	uint32_t spefscr;	/* 26 - SPE float status control */
+	uint32_t asid;		/* 27 - Emulated ASID */
+	/* reserved fields for future use */
+
+	uint32_t reserved[8];	/* 28: Reserved */ 
+#else
+	/* reserved fields for future use */
+
+	uint32_t reserved[10];	/* 26: Reserved */
+#endif
+};
+
+/*
+ *
+ * vb_arch_stat_regs - Virtual core PPC emulated status registers
+ *
+ * Virtual board emulated CPU status registers
+ *
+ * PPC Status structure graphical illustration
+ *
+ *        _______________   ---------------------------
+ *       |    SRR0       |
+ *       |---------------|
+ *       |    SRR1       |   Registers save by WRHV
+ *       |---------------|   before injecting an exception/interrupt
+ *       |    CR         |
+ *       |---------------|
+ *       |    LR         |
+ *       |---------------|
+ *       |    r3         |
+ *       |---------------|
+ *       |    r4         |
+ *       |---------------|   ---------------------------
+ *       |    mcsrr0     |
+ *       |---------------|  Registers saved duing exception handling
+ *       |    mcssr1     |
+ *       |---------------|
+ *       |    esr        |
+ *       |---------------|
+ *       |    mcsr       |
+ *       |---------------|
+ *       |    mcar       |
+ *       |---------------|
+ *       |    dear       |
+ *       |---------------|
+ *       |    emsr       |
+ *       |---------------|
+ *       |    esrr0      |
+ *       |---------------|
+ *       |    esrr1      |
+ *       |---------------|    -------------------------
+ *       | reserved[8]   |      8 x 32bits for future enhancements
+ *       |---------------|    -------------------------
+ *       |    svr        |
+ *       |---------------|
+ *       |    pir        |
+ *       |---------------|
+ *       |    pvr        |    Configuration registers updated
+ *       |---------------|    upon board creation
+ *       |    hid0       |
+ *       |---------------|
+ *       |    hid1       |
+ *       |---------------|
+ *       |    buscr      |
+ *       |---------------|
+ *       |    l1csr0     |
+ *       |---------------|
+ *       |    l1csr1     |
+ *       |---------------|   --------------------------
+ *       | reserved[0:8] | 9x 32bit
+ *       |---------------|
+ *
+ */
+struct vb_arch_stat_regs
+{
+
+	/*
+	 * registers saved by hypervisor for all interrupts exceptions
+	 * before setting the PC in the virtual board to the exception/interrupt
+	 * vector address
+	 */
+
+	uint32_t srr0; /* 0: PC at time of the interrupt */
+	uint32_t srr1; /* 1: MSR at time of the interrupt */
+	uint32_t cr;   /* 2: Condition registers at time of the interrupt */
+	uint32_t lr;   /* 3: Link register at time of the interrupt */
+	uint32_t r3;   /* 4: R3 at time of the interrupt */
+	uint32_t r4;   /* 5: R4 at time of the interrupt */
+
+	/* Registers saved by hypervisor during exception processing only */
+
+	uint32_t mcsrr0; /*  6: */
+	uint32_t mcsrr1; /*  7: */
+	uint32_t esr;    /*  8: */
+	uint32_t mcsr;   /*  9: */
+	uint32_t mcar;   /* 10  */
+	uint32_t dear;   /* 11: */
+	uint32_t emsr;   /* 12: */
+	uint32_t esrr0;  /* 13: */
+	uint32_t esrr1;  /* 14: */
+#if (CPU==PPC85XX)
+	uint32_t spefscr;  /* 15: */
+	uint32_t asid;     /* 16: */
+	/* 
+	 * keep this part in a separate structure in order to keep the offsets
+	 * to remain the same as in VB_STATUS
+	 */
+
+	/* reserved fields for future use */
+
+	uint32_t reserved1[6]; /* 16 - 22  */
+#else
+	/*
+	 * keep this part in a separate structure in order to keep the offsets
+	 * to remain the same as in VB_STATUS
+	 */
+
+	/* reserved fields for future use */
+
+	uint32_t reserved1[8]; /* 15 - 22  */
+#endif
+	/* Configuration registers (only updated upon board creation */
+
+	uint32_t svr;     /* 23 */
+	uint32_t pir;     /* 24 */
+	uint32_t pvr;     /* 25 */
+	uint32_t hid0;    /* 26 */
+	uint32_t hid1;    /* 27 */
+	uint32_t bucsr;   /* 28 */
+	uint32_t l1csr0;  /* 29 */
+	uint32_t l1csr1;  /* 30 */
+
+	/* reserved fields for future use */
+
+	uint32_t reserved2[9]; /* 31 - 39 */
+
+};
+
+
+/*
+ * VBI_HREG_SET - hardware register set, for read/write
+ *
+ * Used by vbi_vb_read_reg/vbi_vb_write_reg to read/write registers in
+ * another VB
+ *
+ */
+
+#define GREG_NUM	32	/* has 32 32/64-bit data registers */
+
+typedef struct
+{
+	uint32_t gpr[GREG_NUM];	/* general purpose registers */
+	uint32_t msr;		/* machine state register */
+	uint32_t lr;		/* link register */
+	uint32_t ctr;		/* count register */
+	uint32_t pc;		/* program counter */
+	uint32_t cr;		/* condition register */
+	uint32_t xer;		/* fixed-point exception register */
+	uint32_t spefscr;	/* SPE floating-point status & ctrl reg */
+	uint32_t casid;		/* PPC405, Book E PID and PPC860 M_CASID */
+} VBI_HREG_SET;
+
+
+/*
+ *
+ * VBI_HREG_SET_64 - hardware register set, for read/write
+ *
+ * Used by vbiVbRegisterComplexRead/vbiVbRegisterComplexWrite to read/write
+ * registers in another VB
+ * 
+ */
+
+typedef struct
+{
+	uint64_t gpr[GREG_NUM];	/* general purpose registers */
+	uint64_t msr;		/* machine state register */
+	uint64_t lr;		/* link register */
+	uint64_t ctr;		/* count register */
+	uint64_t pc;		/* program counter */
+	uint64_t cr;		/* condition register */
+	uint64_t xer;		/* fixed-point exception register */
+	uint64_t spefscr; 	/* SPE floating-point status & ctrl reg */
+	uint64_t casid;		/* PPC405, Book E PID and PPC860 M_CASID */
+} HREG_SET_64;
+
+/* VBI_HREG_SET_64 is same as HREG_SET_64 in ppc */
+typedef HREG_SET_64 VBI_HREG_SET_64;
+
+
+/* complex register set definition */
+
+typedef union
+{
+	VBI_HREG_SET    hreg32;	/* 32 bit register set */
+	VBI_HREG_SET_64 hreg64;	/* 64 bit register set */
+} VBI_HREG_SET_CMPLX;
+
+
+typedef struct
+{
+	uint32_t vbiRegType;
+	VBI_HREG_SET_CMPLX vbiRegSet;
+} VBI_HREG_SET_CMPLX_QUALIFIED;
+
+/* mdio messages */
+#define VBI_MDIO_READ		MDIO_READ
+#define VBI_MDIO_WRITE		MDIO_WRITE
+#define VBI_BSP_CLK_FREQ	BSP_CLK_FREQ
+#define VBI_BSP_CORE_FREQ	BSP_CORE_FREQ
+
+/* This should exceed the number of IVOR registers defined in the hardware
+ * It also defined the size of the excVectorTable size
+ * VBI_ARCH_MAX_EXC_OFFSETS * 256 == 0x4000
+ */
+#define VBI_ARCH_MAX_EXC_OFFSETS	64
+
+typedef struct
+{
+	uint32_t excOffset[VBI_ARCH_MAX_EXC_OFFSETS];
+} VBI_EXC_OFFSETS_TABLE;
+
+extern uint32_t vbi_set_exc_offset(VBI_EXC_OFFSETS_TABLE *excOffsetsTable);
+extern uint32_t vbi_get_exc_offset(VBI_EXC_OFFSETS_TABLE *excOffsetsTable);
+
+/* common system wide message header structure */
+
+typedef struct vbi_msg_header {
+	uint32_t msgId;	/* message type identification */
+	uint32_t msgArg;	/* argument associated with message type */
+} VBI_MSG_HEADER;
+
+/* request message */
+
+typedef struct
+{
+	VBI_MSG_HEADER hdr;			/* message header */
+	uint32_t   request;			/* request type */
+
+	union
+	{
+		struct
+		{
+			uint32_t bus;
+			uint32_t phyAddr;
+			uint32_t regNum;
+			uint32_t page;
+		} mdioRead;
+		struct
+		{
+			uint32_t bus;
+			uint32_t phyAddr;
+			uint32_t regNum;
+			uint32_t page;
+			uint32_t dataVal;
+		} mdioWrite;
+#if 0 /* not supported for now */
+		struct
+		{
+			uint32_t bus;
+			uint32_t vbIntNum;
+			HY_CTX *pCtx;
+		} mdioIntEnable;
+		struct
+		{
+			uint32_t bus;
+			uint32_t vbIntNum;
+			HY_CTX *pCtx;
+		} mdioIntDisable;
+#endif
+	} arg;
+} VBI_BSP_MSG;
+
+typedef struct
+{
+	VBI_MSG_HEADER hdr;			/* message header */
+	uint32_t   status;			/* request completion status */
+	uint32_t   dataVal;
+} VBI_BSP_MSG_REPLY;
+
+#else /*_ASMLANGUAGE */
+
+/*
+ *
+ * VBI_CTX_LOAD - Load a guest context
+ *
+ * This routine is implemented as an assembly macro since it's callers can't
+ * reference C functions. This macro  makes a hypercall to load a context for
+ * a guest * OS. The guest OS running on the core is expected to store a set
+ * of registers that represent the new context to load in the it's control
+ * structure then call VBI_CTX_LOAD() macro to switch to the new context.
+ * The Following are the registers loaded from the control structure:
+ *
+ * VB_CONTROL_SRR0	     ------->  SRR0
+ *
+ * VB_CONTROL_SRR1	     -------> SRR1
+ *
+ * VB_CONTROL_CR	     -------> CR
+ *
+ * VB_CONTROL_R0	     -------> R0
+ *
+ * VB_CONTROL_EMSR	     -------> MSR
+ *
+ * VB_CONTROL_DBCR0	     -------> DBCR0
+ *
+ * VB_CONTROL_NEW_INT_DISABLE -------> VB_CONTROL_INT_DISABLE
+ *
+ * If interrupts are being reenabled then we ensure that any pending
+ * interrupts are delivered before the new context is actived.
+ *
+ * Note that registers that are not saved by Hypervisor must be loaded
+ * by the guest OS.
+ *
+ */
+
+#define VBI_CTX_LOAD(reg)			    \
+	lis reg, HI(VBI_SYS_ctx_load);		    \
+	ori reg, reg, LO(VBI_SYS_ctx_load);	    \
+	sc
+
+/*
+ * VBI_INT_VCORE_LOCK - lock a core's interrupts macro
+ *
+ * This macro disables the currently running core interrupts and returns the
+ * previous interrupts state. The interrupt status field in wr_vb_control
+ * structure at offset VB_CONTROL_INT_DISABLE is set to -1 and the previous
+ * interrupts state is loaded to the register passed in as the first argument to
+ * this macro.
+ * A hypercall is not needed to perform this operation.
+ *
+ *
+ * VBI_INT_VCORE_LOCK (reg0, reg1, reg2)
+ * {
+ *	load -1 to reg1
+ *	load wr_vb_control address to reg2
+ *       read the previous value and store in reg0
+ *	Disable interrupts by loading reg1 to VB_CONTROL_INT_DISABLE(reg2)
+ * }
+ *
+ *
+ * RETURNS: TRUE if interrupts were locked otherwise FALSE
+ *
+ */
+#define VBI_INT_VCORE_LOCK(reg0, reg1, reg2)		\
+	li reg1, -1;					\
+	lis reg2, HIADJ(wr_vb_control);			\
+	lwz reg2, LO(wr_vb_control)(reg2);		\
+	lwz reg0, VB_CONTROL_INT_DISABLE(reg2);		\
+	stw reg1, VB_CONTROL_INT_DISABLE(reg2)
+
+/*
+ * VBI_INT_VCORE_UNLOCK - unlock a core's interrupts
+ *
+ * This macro is implemented in assembly to enable a core's interrupts. It
+ * enables the interrupts by clearing to zero the value in the core's control
+ * structure and and makes a fast hypercall if need be. A hypercall is made only
+ * if found that interrupts are pending. The pending interrupts are checked by
+ * reading the wr_vb_status structure at offset VB_STATUS_INT_PENDING. A
+ * positive integer greater than zero indicates that interrupts are pending
+ * which causes this macro to make a hypercall in order to drain the pending
+ * interrupts. This macro expects two general purpose registers. The first
+ * register is used to load the value to store and the second is used for
+ * holding the destination address of the control or status structure.
+ *
+ *
+ * VBI_INT_VCORE_UNLOCK (reg0, reg1)
+ * {
+ *	load "0" to reg1
+ *	load address of wr_vb_control in reg0
+ *	store reg1 to VB_CONTROL_INT_DISABLE(reg0)
+ *
+ * checkstatus:
+ *	load address of wr_vb_status in reg0
+ *	load VB_STATUS_INT_PENDING(reg0) in reg1
+ *	check if reg1 is equal to zero
+ *	if true return
+ *	otherwise send an hypercall
+ *	go to checkstatus
+ * }
+ *
+ */
+#define VBI_INT_VCORE_UNLOCK(reg0, reg1);			\
+	lis	reg0, HIADJ(wr_vb_control);			\
+	lwz	reg0, LO(wr_vb_control)(reg0);			\
+	li	reg1, 0;					\
+	stw	reg1, VB_CONTROL_INT_DISABLE(reg0);		\
+checkIntVcorePending:						\
+	lis	reg0, HIADJ(wr_vb_status);			\
+	lwz	reg0, LO(wr_vb_status)(reg0);			\
+	lwz	reg1, VB_STATUS_INT_PENDING(reg0);		\
+								\
+	cmplwi  reg1, 0; /* may need to make a hypercall*/	\
+	beq     endIntVcoreLock;				\
+	lis	r0, HI(VBI_SYS_int_enable);			\
+	ori	r0, r0, LO(VBI_SYS_int_enable);			\
+	sc;							\
+	b	checkIntVcorePending;				\
+endIntVcoreLock:
+
+/*
+ * VBI_INT_VCORE_STATE_GET - Get interrupts state
+ *
+ * This macro is implemented in assembly to read the interrupt state of the
+ * currently running core. It relies on a passed in general purpose register
+ * to store the current state of interrupts. The status is -1 if locked
+ * otherwise 0.
+ *
+ *
+ * VBI_INT_VCORE_STATE_GET (reg0)
+ * {
+ *       Load the interrupt status from wr_vb_control to reg0
+ * }
+ *
+ *
+ * RETURNS: TRUE if interrupts are locked otherwise FALSE
+ *
+ */
+
+#define VBI_INT_VCORE_STATE_GET(reg0)		\
+	VBI_CNTRL_ADDR_GET(reg0);		\
+	lwz reg0, VB_CONTROL_INT_DISABLE(reg0);
+
+/*
+ * VBI_CONFIG_ADDR_GET - Get virtual core configuration structure base address
+ *
+ * This macro returns the base address of the configuration structure of the
+ * running core.
+ *
+ * RETURNS: virtual core configuration structure base address
+ *
+ */
+
+#define VBI_CONFIG_ADDR_GET(reg)		\
+	lis reg, HIADJ(wr_vb_config);		\
+	lwz reg, LO(wr_vb_config)(reg)
+
+/*
+ * VBI_CNTRL_ADDR_GET - Get virtual core control structure base address
+ *
+ * This macro returns the base address of the running virtual core's control
+ * structure.
+ *
+ */
+
+#define VBI_CNTRL_ADDR_GET(reg)			\
+	lis reg, HIADJ(wr_vb_control);		\
+	lwz reg, LO(wr_vb_control)(reg)
+
+/*
+ * VBI_STATUS_ADDR_GET - Get virtual core status structure address
+ *
+ * This macro returns the base address of the status structure of currently
+ * running core. This structure is read-only and contains a description of
+ * the running virtual core. Hypervisor uses this data to inform the
+ * virtual board time variant data that may be updated during hypervisor context
+ * Switch. Typical that are available in the status structure are:
+ *
+ *
+ *Timer tick counter
+ *
+ *Pending interrupt state
+ *
+ *The interrupt state before this core was scheduled
+ *
+ *VMMU configuration
+ *
+ *Virtual core registers state
+ *
+ *
+ * RETURNS: virtual core configuration structure base address
+ *
+ */
+
+#define VBI_STATUS_ADDR_GET(reg)		    \
+	lis reg, HIADJ(wr_vb_status);		    \
+	lwz reg, LO(wr_vb_status)(reg)
+
+#endif /*_ASMLANGUAGE */
+
+#endif /* _ASM_ARCH_VBI_H */
diff --git a/arch/powerpc/include/asm/ppc85xx_vbi.h b/arch/powerpc/include/asm/ppc85xx_vbi.h
new file mode 100644
index 0000000..10c33cf
--- /dev/null
+++ b/arch/powerpc/include/asm/ppc85xx_vbi.h
@@ -0,0 +1,631 @@
+/*
+ * ppc85xx.h - PowerPC specific header
+ *
+ * Copyright 2007 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef __INCppc85xxh
+#define __INCppc85xxh
+
+#if (CPU == PPCE500MC)
+#include <sys/ppc/ppcE500mc.h>
+#endif
+
+#if (CPU==PPC85XX)
+#define PPC_e500v2
+#endif
+
+
+/* Maximum cache line size for the cpu */
+#undef	_CPU_CACHE_ALIGN_SIZE
+#if (CPU == PPCE500MC)
+#define	_CPU_CACHE_ALIGN_SHIFT	6	/* cache align size = 32 */
+#define	_CPU_CACHE_ALIGN_SIZE	64	/* cannot use (1<<5) because compiler*/
+#else
+#define	_CPU_CACHE_ALIGN_SHIFT	5	/* cache align size = 32 */
+#define	_CPU_CACHE_ALIGN_SIZE	32	/* cannot use (1<<5) because compiler
+                                         * directive __attribute__ cant hdl */
+#endif
+/* MMU supports software TLB miss handler */
+
+#undef  _WRS_TLB_MISS_CLASS_HW
+#define _WRS_TLB_MISS_CLASS_SW  1
+
+/* MMU uses PID register to extend virtual address tag */
+
+#undef	_WRS_MMU_CLASS_NONE
+#undef	_WRS_MMU_CLASS_SR_REGS
+#define _WRS_MMU_CLASS_PID_REG	1
+
+/* MMU ASID context register name for _WRS_MMU_CLASS_PID_REG */
+
+#define	_PPC_PID_REG		PID0
+
+/* MMU cannot be disabled */
+
+#define	PPC_NO_REAL_MODE
+
+/*
+ * MMU supports the M attribute bit, allowing the coherency-required property
+ * to be configured on a per-page basis.  Therefore, even when snooping is
+ * enabled, cacheDmaMalloc needs to call arch support to set the M bit.
+ */
+#define	_WRS_SNOOP_NEEDS_DMA_MALLOC_SUPPORT
+
+#if  (CPU != PPCE500MC)
+#define _WRS_SPE_SUPPORT	1
+#endif /* (CPU != PPCE500MC) */
+
+#define _WRS_E500_FIXED_POINT_SUPPORT 1
+
+#ifdef _WRS_SPE_SUPPORT
+#undef _PPC_MSR_FP
+#define _PPC_MSR_SPE_U		0x0200
+#define _PPC_MSR_SPE		0x02000000
+#define MSR_SPE_BIT_SHIFT	25
+#endif /* _WRS_SPE_SUPPORT */
+
+/* #define IMMR	638	* bogus hack */
+
+/* Special Purpose Register (SPR) numbers */
+
+#define CSRR0   58      /* Critical SRR0 */
+#define CSRR1   59      /* Critical SRR1 */
+#define DEAR    61      /* Data Exception Address Register */
+#define ESR     62      /* Exception Syndrome Register */
+#define IVPR    63      /* Interrupt Vector Prefix Register */
+#define IVOR0   400     /* IVOR Critical Input */
+#define IVOR1   401     /* IVOR Machine Check */
+#define IVOR2   402     /* IVOR Data Storage */
+#define IVOR3   403     /* IVOR Instruction Storage */
+#define IVOR4   404     /* IVOR External Input */
+#define IVOR5   405     /* IVOR Alignment */
+#define IVOR6   406     /* IVOR Program */
+#define IVOR7   407     /* IVOR Floating Point Unavailable */
+#define IVOR8   408     /* IVOR System Call */
+#define IVOR9   409     /* IVOR Auxiliary Processor Unavailable */
+#define IVOR10  410     /* IVOR Decrementer */
+#define IVOR11  411     /* IVOR Fixed Interval Timer */
+#define IVOR12  412     /* IVOR Watchdog Timer */
+#define IVOR13  413     /* IVOR Data TLB Error */
+#define IVOR14  414     /* IVOR Instruction TLB Error */
+#define IVOR15  415     /* IVOR Debug */
+#if (CPU==PPC85XX)
+#define IVOR32  528     /* IVOR SPE */
+#define IVOR33  529     /* IVOR Vector FP Data */
+#define IVOR34  530     /* IVOR Vector FP Round */
+#endif
+#ifndef PPC_e200
+#define IVOR35  531     /* IVOR Performance Monitor */
+#endif
+
+#ifndef PPC_e200
+#define MCSRR0  570     /* Machine Check SRR0 */
+#define MCSRR1  571     /* Machine Check SRR1 */
+#define MCAR    573     /* Machine Check Address Register */
+#else
+#define MCSRR0  CSRR0     /* Machine Check SRR0 */
+#define MCSRR1  CSRR1     /* Machine Check SRR1 */
+#undef MCAR         /* Machine Check Address Register */
+#endif
+
+#define MCSR    572     /* Machine Check Syndrome Register */
+
+#if (CPU==PPC85XX)
+#define SPEFSCR 512     /* SPE Floating-pt Status and Control Register */
+#endif
+
+/* SPRG0-SPRG3 are defined correctly in asmPpc.h */
+#define SPRG4_R 260     /* Special Purpose Register General 4, read */
+#define SPRG4_W 276     /* Special Purpose Register General 4, write */
+#define SPRG5_R 261     /* Special Purpose Register General 5, read */
+#define SPRG5_W 277     /* Special Purpose Register General 5, write */
+#define SPRG6_R 262     /* Special Purpose Register General 6, read */
+#define SPRG6_W 278     /* Special Purpose Register General 6, write */
+#define SPRG7_R 263     /* Special Purpose Register General 7, read */
+#define SPRG7_W 279     /* Special Purpose Register General 7, write */
+#define TBL_R   268     /* Time Base Lower, read */
+#define TBL_W   284     /* Time Base Lower, write */
+#define TBU_R   269     /* Time Base Upper, read */
+#define TBU_W   285     /* Time Base Upper, write */
+#define TCR     340     /* Timer Control Register */
+#define TSR     336     /* Timer Status Register */
+#define USPRG0  256     /* User Special Purpose Register General 0 */
+#define DBCR0   308     /* Debug Control Register 0 */
+#define DBCR1   309     /* Debug Control Register 1 */
+#define DBCR2   310     /* Debug Control Register 2 */
+#define DBSR    304     /* Debug Status Register */
+#define IAC1    312     /* Instr Address Compare Register 1 */
+#define IAC2    313     /* Instr Address Compare Register 2 */
+#define DAC1    316     /* Data Address Compare Register 1 */
+#define DAC2    317     /* Data Address Compare Register 2 */
+#define L1CFG0  515     /* L1 Config Register 0 */
+#define L1CFG1  516     /* L1 Config Register 1 */
+#define L1CSR0  1010    /* L1 Control Status Register 0 */
+#define L1CSR1  1011    /* L1 Control Status Register 1 */
+#ifdef PPC_e200
+#define L1FINV0 1016
+#endif
+
+#define MAS0    624     /* MMU Assist Register 0 */
+#define MAS1    625     /* MMU Assist Register 1 */
+#define MAS2    626     /* MMU Assist Register 2 */
+#define MAS3    627     /* MMU Assist Register 3 */
+#define MAS4    628     /* MMU Assist Register 4 */
+
+#define MAS6    630     /* MMU Assist Register 6 */
+#if defined(PPC_e500v2) || (CPU == PPCE500MC)
+#define MAS7    944     /* MMU Assist Register 7 */
+#endif /* PPC_e500v2 */
+
+#define TLB0CFG 688     /* TLB 0 Config Register */
+#define TLB1CFG 689     /* TLB 1 Config Register */
+#define MMUCSR0 1012    /* MMU Control Status Register 0 */
+#define MMUCFG  1015    /* MMU Config Register */
+
+
+/*
+ * Machine check exception class is new to PPC in E500.  Although
+ * bit position is same as classic MSR[ME] and is named the same,
+ * the define of _PPC_MSR_MCE signifies the present of this
+ * class of exception.  If present, both _PPC_MSR_MCE and
+ * _PPC_MSR_ME should be defined to the mask of 0x1000.
+ * In addition, Critical Exception Class is also a requirement.
+ * The critical exception code stub does not mask exceptions
+ * and is used for machine check exception class as well.
+ * Therefore, _EXC_OFF_CRTL should be defined.
+ */
+
+#ifndef PPC_e200
+#define _PPC_MSR_MCE    _PPC_MSR_ME	/* machine check enable */
+#else
+#undef _PPC_MSR_MCE
+#endif
+
+#define	_PPC_MSR_BIT_WE		13
+#define	_PPC_MSR_BIT_CE		14
+#define	_PPC_MSR_BIT_DE		22
+#define _PPC_MSR_BIT_IS		26
+#define _PPC_MSR_BIT_DS		27
+
+/* Only allow the following bits to be modified by the guest
+ * Some of these are also forced on by the hypervisor */
+#if (CPU==PPC85XX)
+#define CONTROL_MSR_MASK  (_PPC_MSR_CE | _PPC_MSR_SPE | _PPC_MSR_EE |\
+			   _PPC_MSR_PR | _PPC_MSR_ME | _PPC_MSR_DE |\
+			   _PPC_MSR_IS | _PPC_MSR_DS | _PPC_MSR_RI)
+#endif
+
+#define _PPC_MSR_MMU_EXTRACT(src, dst) \
+	rlwinm	dst, src, 0, _PPC_MSR_BIT_IS, _PPC_MSR_BIT_DS
+
+/* INT_MASK definition (mask EE & CE bits) : overwrite the one in asmPpc.h */
+
+#undef  INT_MASK
+#define INT_MASK(src, des) \
+	rlwinm  des, src, 0, _PPC_MSR_BIT_EE+1, _PPC_MSR_BIT_EE-1; \
+	rlwinm  des, des, 0, _PPC_MSR_BIT_CE+1, _PPC_MSR_BIT_CE-1
+
+
+#define HID0  1008
+#if (CPU != PPCE500MC)
+#define HID1  1009
+#endif
+
+#define DECAR 54
+#define BUCSR 1013
+
+#define _PPC_BUCSR_FI 0x200            /* Invalidate branch cache */
+#define _PPC_BUCSR_E 0x1               /* Enable branch prediction */
+
+/* E500core other than e500mc has no FPU */
+
+#if (CPU==PPCE500MC)
+#define _WRS_HARDWARE_FP
+#endif
+
+#ifndef _WRS_HARDWARE_FP
+#undef  _PPC_MSR_FP             /* floating point not available */
+#undef  _PPC_MSR_FE1            /* floating point not available */
+#undef  _PPC_MSR_FE0            /* floating point not available */
+#undef  _PPC_MSR_BIT_FP         /* MSR Floating Point Aval. bit - FP */
+#undef  _PPC_MSR_BIT_FE0        /* MSR FP exception mode 0 bit - FE0 */
+#undef  _PPC_MSR_BIT_FE1        /* MSR FP exception mode 1 bit - FE1 */
+#undef  _EXC_PROG_SRR1_FPU      /* floating point not available */
+#else	/* _WRS_HARDWARE_FP */
+#define _WRS_FP_CLASS_HW	1
+#define  _PPC_MSR_BIT_FP         18
+#define  _PPC_MSR_BIT_FE0        20
+#define  _PPC_MSR_BIT_FE1        23
+#endif	/* _WRS_HARDWARE_FP */
+
+
+
+/*
+ * Exception syndrome register mask bits:
+ * 0 - error not occured 1 - error occured
+ */
+
+#define _PPC_ESR_PIL_U 0x0800      /* Pgm Interrupt -- Illegal Insn */
+#define _PPC_ESR_PPR_U 0x0400      /* Pgm Interrupt -- Previleged Insn */
+#define _PPC_ESR_PTR_U 0x0200      /* Pgm Interrupt -- Trap */
+#if (CPU == PPCE500MC)
+#define _PPC_ESR_FP_U  0x0100      /* Floating Point Operation */
+#endif /* (CPU == PPCE500MC) */
+#define _PPC_ESR_ST_U  0x0080      /* Store Operation */
+#define _PPC_ESR_DLK_U 0x0020      /* Data Locked -- DSI occured */
+#define _PPC_ESR_ILK_U 0x0010      /* Inst Locked -- DSI occured */
+#define _PPC_ESR_AP_U  0x0008      /* AP Operation */
+#define _PPC_ESR_BO_U  0x0002      /* Byte Ordering Exception */
+#define _PPC_ESR_PIL   0x08000000  /* Pgm Interrupt -- Illegal Insn */
+#define _PPC_ESR_PPR   0x04000000  /* Pgm Interrupt -- Previleged Insn */
+#define _PPC_ESR_PTR   0x02000000  /* Pgm Interrupt -- Trap */
+#if (CPU == PPCE500MC)
+#define _PPC_ESR_FP    0x01000000  /* Floating Point Operation */
+#endif /* (CPU == PPCE500MC) */
+#define _PPC_ESR_ST    0x00800000  /* Store Operation */
+#define _PPC_ESR_DLK   0x00200000  /* Data Storage Interrupt -- Locking */
+#define _PPC_ESR_ILK   0x00100000  /* Inst Locked -- DSI occured */
+#define _PPC_ESR_AP    0x00080000  /* AP Operation */
+#define _PPC_ESR_BO    0x00020000  /* Byte Ordering Exception */
+#define _PPC_ESR_SPE   0x00000080  /* SPE exception */
+#define _PPC_ESR_EPID  0x00000040 /* External PID Access */
+#define _PPC_ESR_VLEMI 0x00000020 /* VLE instruction */
+#define _PPC_ESR_MIF   0x00000002 /* Misaligned Insn Fetch (ITLB, ISI) */
+#define _PPC_ESR_XTE   0x00000001 /* External Transaction Err (ISI, DSI) */
+
+
+#define   _PPC_EPCR_EXTGS      0x80000000 /* Guest gets external ints */
+#define   _PPC_EPCR_DTLBGS     0x40000000 /* Guest gets DTLB errors */
+#define   _PPC_EPCR_ITLBGS     0x20000000 /* Guest gets ITLB errors */
+#define   _PPC_EPCR_DSIGS      0x10000000 /* Guest gets DSIs */
+#define   _PPC_EPCR_ISIGS      0x08000000 /* Guest gets ISIs */
+#define   _PPC_EPCR_DUVD       0x04000000 /* Disable Embedded HV Debug */
+#define   _PPC_EPCR_DGTMI      0x00800000 /* Disable guest TLB management insns*/
+#define   _PPC_EPCR_DMIUH      0x00400000 /* Disable MAS int updates for hypervisor*/
+
+/* Bits in the upper half of TCR */
+
+#define _PPC_TCR_WP_U     0xc000  /* Watchdog Timer Period */
+#define _PPC_TCR_WRC_U    0x3000  /* Watchdog Timer Reset Control */
+#define _PPC_TCR_WIE_U    0x0800  /* Watchdog Timer Interrupt Enable */
+#define _PPC_TCR_DIE_U    0x0400  /* Decrementer Interrupt Enable */
+#define _PPC_TCR_FP_U     0x0300  /* Fixed Interval Timer Period */
+#define _PPC_TCR_FIE_U    0x0080  /* Fixed Interval Timer Interrupt Enable */
+#define _PPC_TCR_ARE_U    0x0040  /* Decrementer Auto-Reload Enable */
+#define _PPC_TCR_WPEXT_U  0x0040  /* Decrementer Auto-Reload Enable */
+#define _PPC_TCR_FPEXT_U  0x0040  /* Decrementer Auto-Reload Enable */
+
+/* Bits in the upper half of TSR */
+
+#define _PPC_TSR_ENW_U  0x8000  /* Enable Next Watchdog Timer Exception */
+#define _PPC_TSR_WIS_U  0x4000  /* Watchdog Timer Interrupt Status */
+#define _PPC_TSR_WRS_U  0x3000  /* Watchdog Timer Reset Status */
+#define _PPC_TSR_DIS_U  0x0800  /* Decrementer Interrupt Status */
+#define _PPC_TSR_FIS_U  0x0400  /* Fixed Interval Timer Interrupt Status */
+
+/* versions of the aligned for 32-bit TCR/TSR register access */
+
+#define _PPC_TCR_DIE (_PPC_TCR_DIE_U << 16)
+#define _PPC_TSR_DIS (_PPC_TSR_DIS_U << 16)
+
+/* hardware dependent register 0 */
+
+#define _PPC_HID0_DOZE  0x00800000      /* DOZE power management mode */
+#define _PPC_HID0_NAP   0x00400000      /* NAP power management mode */
+#define _PPC_HID0_SLEEP 0x00200000      /* SLEEP power management mode */
+#define _PPC_HID0_TBEN	0x00004000	/* time base enable */
+#define _PPC_HID0_MAS7EN  0x00000080    /* Enable use of MAS7 for tlbre */
+#define _PPC_HID0_DCFA    0x00000040    /* Use this bit to flush only valid entries same as 74XX */
+#define _PPC_HID0_BIT_MAS7EN   24
+#define _PPC_HID0_BIT_DCFA     25
+#define _PPC_85XX_USE_DCFA
+
+/* hardware dependent register 1 */
+
+#define _PPC_HID1_ABE   0x00001000      /* Address broadcast enable */
+
+/* Cache Defines */
+
+/* Instruction and Data Cache bit fields are the same */
+
+#ifndef PPC_e200
+#define _PPC_L1CSR_E   0x00000001 /* Enable */
+#define _PPC_L1CSR_FI  0x00000002 /* Flash Invalidate */
+#define _PPC_L1CSR_FLR 0x00000100 /* Lock Bits Flash */
+#define _PPC_L1CSR_LO  0x00000200 /* Lock Overflow */
+#define _PPC_L1CSR_UL  0x00000400 /* Unable to lock   - status bit */
+#define _PPC_L1CSR_UL_V(x)  (x >> 10)
+#define _PPC_L1CSR_SLC 0x00000800 /* Snoop lock clear  - status bit */
+#define _PPC_L1CSR_SLC_V(x) (x >> 11)
+#define _PPC_L1CSR_PIE 0x00008000 /* Parity Injection Enable */
+#define _PPC_L1CSR_CPE 0x00010000 /* Parity Enable */
+
+/* Instruction and Data Cache bit fields are the same */
+
+#define _PPC_L1CFG_SIZE_MASK   0x00000FFF
+#define _PPC_L1CFG_NWAY_MASK   0x000FF000
+#define _PPC_L1CFG_NWAY_V(x)   (x >> 12)
+#define _PPC_L1CFG_PA_MASK     0x00100000
+#define _PPC_L1CFG_PA_V(x)     (x >> 16)
+#define _PPC_L1CFG_LA_MASK     0x00200000
+#define _PPC_L1CFG_LA_V(x)     (x >> 17)
+#define _PPC_L1CFG_REPL_MASK   0x00400000
+#define _PPC_L1CFG_REPL_V(x)   (x >> 18)
+#define _PPC_L1CFG_BSIZE_MASK  0x01800000
+#define _PPC_L1CFG_BSIZE_V(x)  (x >> 19)
+#define _PPC_L1CFG_CARCH_MASK  0xC0000000    /* L1CFG0 only */
+#define _PPC_L1CFG_CARCH_V(x)  (x >> 30)
+
+#else /* PPC_e200 */
+
+#define _PPC_L1CSR_WID_MSK 0xf0000000
+#define _PPC_L1CSR_WID_SHFT 28
+#define _PPC_L1CSR_WDD_MSK 0x0f000000
+#define _PPC_L1CSR_WDD_SHFT 24
+#define _PPC_L1CSR_WID_SET(x)  ((x<<_PPC_L1CSR_WID_SHFT) & _PPC_L1CSR_WID_MSK)
+#define _PPC_L1CSR_WDD_SET(x)  ((x<<_PPC_L1CSR_WDD_SHFT) & _PPC_L1CSR_WDD_MSK)
+#define _PPC_L1CSR_WID_GET(x)  ((x & _PPC_L1CSR_WID_MSK)>>_PPC_L1CSR_WID_SHFT)
+#define _PPC_L1CSR_WDD_GET(x)  ((x & _PPC_L1CSR_WDD_MSK)>>_PPC_L1CSR_WDD_SHFT)
+
+#define _PPC_L1CSR_AWID   0x00800000
+#define _PPC_L1CSR_AWDD   0x00400000
+#define _PPC_L1CSR_CWM    0x00100000
+#define _PPC_L1CSR_DPB    0x00080000
+#define _PPC_L1CSR_DSB    0x00040000
+#define _PPC_L1CSR_DSTRM  0x00020000
+#define _PPC_L1CSR_CPE    0x00010000
+#define _PPC_L1CSR_CUL    0x00000800
+#define _PPC_L1CSR_CLO    0x00000400
+#define _PPC_L1CSR_CLFC   0x00000200
+#define _PPC_L1CSR_CABT   0x00000004
+#define _PPC_L1CSR_CINV   0x00000002
+#define _PPC_L1CSR_CE     0x00000001
+
+#define _PPC_L1CFG_SIZE_MASK   0x000007FF
+#define _PPC_L1CFG_NWAY_MASK   0x007FF100
+#define _PPC_L1CFG_NWAY_V(x)   (x >> 11)
+#define _PPC_L1CFG_PA_MASK     0x00080000
+#define _PPC_L1CFG_PA_V(x)     (x >> 19)
+#define _PPC_L1CFG_LA_MASK     0x00100000
+#define _PPC_L1CFG_LA_V(x)     (x >> 20)
+#define _PPC_L1CFG_REPL_MASK   0x00600000
+#define _PPC_L1CFG_REPL_V(x)   (x >> 21)
+#define _PPC_L1CFG_BSIZE_MASK  0x01800000
+#define _PPC_L1CFG_BSIZE_V(x)  (x >> 23)
+#define _PPC_L1CFG_CFISWA_MASK 0x08000000
+#define _PPC_L1CFG_CFAHA_MASK  0x10000000
+#define _PPC_L1CFG_CWPA_MASK   0x20000000
+#define _PPC_L1CFG_CARCH_MASK  0xC0000000
+#define _PPC_L1CFG_CARCH_V(x)  (x >> 30)
+
+#define _PPC_L1FINV0_CWAY_MSK  0x07000000
+#define _PPC_L1FINV0_CWAY_SET(x) ((x << 24) & _PPC_L1FINV0_CWAY_MSK)
+#define _PPC_L1FINV0_CSET_MSK  0x00000FC0
+#define _PPC_L1FINV0_CSET_SET(x) ((x << 6) & _PPC_L1FINV0_CSET_MSK)
+#define _PPC_L1FINV0_CCMD_MSK  0x00000003
+#define _PPC_L1FINV0_CCMD_SET(x) (x & _PPC_L1FINV0_CCMD_MSK)
+
+#ifndef _ASMLANGUAGE
+typedef union e200_l1cfg0
+    {
+    UINT32 l1Cfg0;
+    struct
+	{
+	uint32_t carch:2;
+	uint32_t cwpa:1;
+	uint32_t cfaha:1;
+	uint32_t cfiswa:1;
+	uint32_t :2;
+	uint32_t cbsize:2;
+	uint32_t crepl:2;
+	uint32_t cla:1;
+	uint32_t cpa:1;
+	uint32_t cnway:8;
+	uint32_t csize:11;
+	} field;
+    } E200_L1CFG0;
+#endif /* _ASMLANGUAGE */
+
+#endif /* PPC_e200 */
+
+/* MMU register defines */
+
+#define PID     48
+#define PID_MASK 0x0FF
+#define PID0    48
+#if (CPU != PPCE500MC)
+#define PID1    633
+#define PID2    634
+#endif /* (CPU != PPCE500MC) */
+
+
+
+#define _PPC_MMUCSR0_L2TLB1_FI  0x00000002
+#define _PPC_MMUCSR0_L2TLB1_FI_V(x) (x >> 1)
+#define _PPC_MMUCSR0_L2TLB0_FI  0x00000004
+#define _PPC_MMUCSR0_L2TLB0_FI_V(x) (x >> 2)
+#define _PPC_MMUCSR0_DL1MMU_FI  0x00000008
+#define _PPC_MMUCSR0_DL1MMU_FI_V(x) (x >> 3)
+#define _PPC_MMUCSR0_IL1MMU_FI  0x00000010
+#define _PPC_MMUCSR0_IL1MMU_FI_V(x) (x >> 4)
+
+#if (CPU==PPCE500MC)
+#define _PPC_MMUCSR0_DYN_INVAL  (_PPC_MMUCSR0_L2TLB0_FI)
+#else
+#define _PPC_MMUCSR0_DYN_INVAL  (_PPC_MMUCSR0_DL1MMU_FI | \
+			       _PPC_MMUCSR0_IL1MMU_FI | \
+			       _PPC_MMUCSR0_L2TLB0_FI)
+#endif
+
+/* Standard PTE registers */
+#define _PPC_MAS0_NV           0x00000000
+#define _PPC_MAS0_ESEL_MASK    0x03ff0000
+#define _PPC_MAS0_ESEL_BIT     16
+#define _PPC_MAS0_ESEL_V(x)    (x >> _PPC_MAS0_ESEL_BIT)
+#define _PPC_MAS0_TLBSEL1      0x10000000
+#define _PPC_MAS0_TLBSEL_MASK  0x30000000
+
+/* Standard PTE registers */
+#define _PPC_MAS1_V            0x80000000
+#define _PPC_MAS1_IPROT        0x40000000
+#define _PPC_MAS1_TID_MASK     0x00ff0000
+#define _PPC_MAS1_TS           0x00001000
+#define _PPC_MAS1_TSIZE_MASK   0x00000f00
+
+/* Standard PTE registers */
+#define _PPC_MAS2_EPN_MASK     0xFFFFF000
+#define _PPC_MAS2_X0           0x00000040
+#define _PPC_MAS2_X1           0x00000020
+#define _PPC_MAS2_W            0x00000010
+#define _PPC_MAS2_I            0x00000008
+#define _PPC_MAS2_M            0x00000004
+#define _PPC_MAS2_G            0x00000002
+#define _PPC_MAS2_E            0x00000001
+
+/* Standard PTE registers */
+#define _PPC_MAS3_RPN_MASK     0xFFFFF000
+#define _PPC_MAS3_U0_U3_MASK   0x000003C0
+#define _PPC_MAS3_UX           0x00000020
+#define _PPC_MAS3_SX           0x00000010
+#define _PPC_MAS3_UW           0x00000008
+#define _PPC_MAS3_SW           0x00000004
+#define _PPC_MAS3_UR           0x00000002
+#define _PPC_MAS3_SR           0x00000001
+
+/* Default value register for MAS0-3 */
+#define _PPC_MAS4_TLBSELD      0x10000000
+#define _PPC_MAS4_TSIZED       0x00000F00
+#define _PPC_MAS4_X0D          0x00000040
+#define _PPC_MAS4_X1D          0x00000020
+#define _PPC_MAS4_WD           0x00000010
+#define _PPC_MAS4_ID           0x00000008
+#define _PPC_MAS4_MD           0x00000004
+#define _PPC_MAS4_GD           0x00000002
+#define _PPC_MAS4_ED           0x00000001
+
+/* used in tlbsx */
+#define _PPC_MAS5_SGS          0x80000000
+#define _PPC_MAS5_SLPID_MASK   0x000000FF
+
+/* used in tlbsx */
+#define _PPC_MAS6_SPID_MASK    0x00FF0000
+#define _PPC_MAS6_SAS          0x00000001
+
+/* e500v2/e500mc */
+#define _PPC_MAS7_ERPN_MASK    0x0000000F
+
+/* Possible Extension to PTE - probably just program based LPI info */
+#define _PPC_MAS8_TGS          0x80000000
+#define _PPC_MAS8_VF           0x40000000
+#define _PPC_MAS8_TLPID_MASK   0x000000FF
+
+/* Range of hardware context numbers (PID register & TLB TID field) */
+
+#define MMU_ASID_MIN            1
+#define MMU_ASID_MAX            255
+#define MMU_ASID_GLOBAL         MMU_ASID_MIN
+
+/* debug control register 0 */
+
+#define _DBCR0_IDM_U    0x4000          /* internal debug mode */
+#define _DBCR0_RST_U    0x3000          /* reset */
+#define _DBCR0_ICMP_U   0x0800          /* instruction completion debug event */
+#define _DBCR0_BRT_U    0x0400          /* branch taken debug event */
+#define _DBCR0_IRPT_U   0x0200          /* interrupt debug event */
+#define _DBCR0_TRAP_U   0x0100          /* trap debug event */
+#define _DBCR0_IAC1_U   0x0080          /* instruction address compare 1 */
+#define _DBCR0_IAC2_U   0x0040          /* instruction address compare 2 */
+#define _DBCR0_DAC1R_U  0x0008          /* data address compare 1 Read */
+#define _DBCR0_DAC1W_U  0x0004          /* data address compare 1 Write */
+#define _DBCR0_DAC2R_U  0x0002          /* data address compare 2 Read */
+#define _DBCR0_DAC2W_U  0x0001          /* data address compare 2 Write */
+#define _DBCR0_IDM      0x40000000      /* internal debug mode */
+#define _DBCR0_RST      0x30000000      /* reset */
+#define _DBCR0_ICMP     0x08000000      /* instruction completion debug event */
+#define _DBCR0_BRT      0x04000000      /* branch taken */
+#define _DBCR0_IRPT     0x02000000      /* exception debug event */
+#define _DBCR0_TRAP     0x01000000      /* trap debug event */
+#define _DBCR0_IAC1     0x00800000      /* instruction address compare 1 */
+#define _DBCR0_IAC2     0x00400000      /* instruction address compare 2 */
+#define _DBCR0_DAC1R    0x00080000      /* data address compare 1 Read */
+#define _DBCR0_DAC1W    0x00040000      /* data address compare 1 Write */
+#define _DBCR0_DAC2R    0x00020000      /* data address compare 2 Read */
+#define _DBCR0_DAC2W    0x00010000      /* data address compare 2 Write */
+#define _DBCR0_RET      0x00008000      /* return debug event */
+#define _DBCR0_FT       0x00000001      /* freeze timers on debug */
+
+/* debug control register 1 */
+
+#define _DBCR1_IAC1US_U   0xc000        /* IAC 1 User/Supervisor */
+#define _DBCR1_IAC1ER_U   0x3000        /* IAC 1 Effective/Real */
+#define _DBCR1_IAC2US_U   0x0c00        /* IAC 2 User/Supervisor */
+#define _DBCR1_IAC2ER_U   0x0300        /* IAC 2 Effective/Real */
+#define _DBCR1_IAC12M_U   0x00c0        /* IAC 1/2 Mode */
+#define _DBCR1_IAC12AT_U  0x0001        /* IAC 1/2 Auto-Toggle Enable */
+#define _DBCR1_IAC1US     0xc0000000    /* IAC 1 User/Supervisor */
+#define _DBCR1_IAC1ER     0x30000000    /* IAC 1 Effective/Real */
+#define _DBCR1_IAC2US     0x0c000000    /* IAC 2 User/Supervisor */
+#define _DBCR1_IAC2ER     0x03000000    /* IAC 2 Effective/Real */
+#define _DBCR1_IAC12M     0x00c00000    /* IAC 1/2 Mode */
+
+/* debug control register 2 */
+
+#define _DBCR2_DAC1US_U   0xc000        /* DAC 1 User/Supervisor */
+#define _DBCR2_DAC1ER_U   0x3000        /* DAC 1 Effective/Real */
+#define _DBCR2_DAC2US_U   0x0c00        /* DAC 2 User/Supervisor */
+#define _DBCR2_DAC2ER_U   0x0300        /* DAC 2 Effective/Real */
+#define _DBCR2_DAC12M_U   0x00c0        /* DAC 1/2 Mode */
+#define _DBCR2_DAC1US     0xc0000000    /* DAC 1 User/Supervisor */
+#define _DBCR2_DAC1ER     0x30000000    /* DAC 1 Effective/Real */
+#define _DBCR2_DAC2US     0x0c000000    /* DAC 2 User/Supervisor */
+#define _DBCR2_DAC2ER     0x03000000    /* DAC 2 Effective/Real */
+#define _DBCR2_DAC12M     0x00c00000    /* DAC 1/2 Mode */
+
+/* debug status register */
+
+#define _DBSR_IDE_U     0x8000          /* Imprecise Debug Event */
+#define _DBSR_UDE_U     0x4000          /* Unconditional Debug Event */
+#define _DBSR_MRR_U     0x3000          /* Most Recent Reset */
+#define _DBSR_ICMP_U    0x0800          /* Instruction Completion Debug Event */
+#define _DBSR_BRT_U     0x0400          /* Branch Taken Debug Event */
+#define _DBSR_IRPT_U    0x0200          /* Interrupt Debug Event */
+#define _DBSR_TRAP_U    0x0100          /* Trap Debug Event */
+#define _DBSR_IAC1_U    0x0080          /* IAC 1 Debug Event */
+#define _DBSR_IAC2_U    0x0040          /* IAC 2 Debug Event */
+#define _DBSR_DAC1R_U   0x0008          /* DAC/DVC 1 Read Debug Event */
+#define _DBSR_DAC1W_U   0x0004          /* DAC/DVC 1 Write Debug Event */
+#define _DBSR_DAC2R_U   0x0002          /* DAC/DVC 2 Read Debug Event */
+#define _DBSR_DAC2W_U   0x0001          /* DAC/DVC 2 Write Debug Event */
+#define _DBSR_IDE       0x80000000      /* Imprecise Debug Event */
+#define _DBSR_UDE       0x40000000      /* Unconditional Debug Event */
+#define _DBSR_MRR       0x30000000      /* Most Recent Reset */
+#define _DBSR_ICMP      0x08000000      /* Instruction Completion Debug Event */
+#define _DBSR_BRT       0x04000000      /* Branch Taken Debug Event */
+#define _DBSR_IRPT      0x02000000      /* Interrupt Debug Event */
+#define _DBSR_TRAP      0x01000000      /* Trap Debug Event */
+#define _DBSR_IAC1      0x00800000      /* IAC 1 Debug Event */
+#define _DBSR_IAC2      0x00400000      /* IAC 2 Debug Event */
+#define _DBSR_DAC1R     0x00080000      /* DAC/DVC 1 Read Debug Event */
+#define _DBSR_DAC1W     0x00040000      /* DAC/DVC 1 Write Debug Event */
+#define _DBSR_DAC2R     0x00020000      /* DAC/DVC 2 Read Debug Event */
+#define _DBSR_DAC2W     0x00010000      /* DAC/DVC 2 Write Debug Event */
+#define _DBSR_RET       0x00008000      /* Return Debug Event */
+
+/* mask for hardware breakpoints */
+
+#define _DBSR_HWBP_MSK  ( _DBSR_IAC1 | _DBSR_IAC2 | \
+                          _DBSR_DAC1R | _DBSR_DAC1W | \
+                          _DBSR_DAC2R | _DBSR_DAC2W )
+
+#endif /* __INCppc85xxh */
diff --git a/arch/powerpc/include/asm/reg_vbi.h b/arch/powerpc/include/asm/reg_vbi.h
new file mode 100644
index 0000000..7d2b156
--- /dev/null
+++ b/arch/powerpc/include/asm/reg_vbi.h
@@ -0,0 +1,58 @@
+/*
+ *  ppc reg_vbi.h - PowerPC cpu registers
+ *
+ * Copyright (c) 2007 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef __INCppcRegsh
+#define __INCppcRegsh
+
+#define GREG_NUM	32	/* has 32 32/64-bit data registers */
+#define	_PPC_HREG_SIZE	4	/* only support 32-bit registers */
+
+#ifndef	_ASMLANGUAGE
+
+/* some common names for registers */
+
+#define spReg	gpr[1]	/* stack pointer */
+#define	fpReg	gpr[31]	/* frame pointer */
+#define reg_pc	pc	/* program counter */
+#define reg_sp	spReg	/* stack pointer */
+#define reg_fp	fpReg	/* frame pointer */
+
+#endif	/* _ASMLANGUAGE */
+
+
+#define HREG_SET_GRBASE	0x00	/* general purpose register base */
+#define HREG_SET_GR(n)		(HREG_SET_GRBASE + _PPC_HREG_SIZE*(n))
+#define HREG_SET_MSR		(HREG_SET_GR(GREG_NUM))
+#define HREG_SET_LR		(HREG_SET_MSR + _PPC_HREG_SIZE)
+#define HREG_SET_CTR		(HREG_SET_LR + _PPC_HREG_SIZE)
+#define HREG_SET_PC		(HREG_SET_CTR + _PPC_HREG_SIZE)
+#define HREG_SET_CR		(HREG_SET_PC + _PPC_HREG_SIZE)
+#define HREG_SET_XER		(HREG_SET_CR + 4)
+#define HREG_SET_SPEFSCR	(HREG_SET_XER + 4)
+#define HREG_SET_CASID		(HREG_SET_SPEFSCR + 4)
+#define HREG_SET_SP		(HREG_SET_GR(1))
+
+/* size of the full REG_SET structure, including spare bytes */
+
+#define _PPC_HREG_SET_SIZE       (_PPC_HREG_SIZE * (GREG_NUM + 7))
+
+/* include any cpu specific register declarations */
+
+#if (CPU == PPC85XX) || (CPU == PPCE500MC)
+# include <sys/ppc/ppc85xx.h>
+#endif
+
+#endif /* __INCppcRegsh */
diff --git a/arch/powerpc/include/asm/vbi.h b/arch/powerpc/include/asm/vbi.h
new file mode 100644
index 0000000..4459cd1
--- /dev/null
+++ b/arch/powerpc/include/asm/vbi.h
@@ -0,0 +1,526 @@
+/*
+ * asm/vbi.h - PowerPC tool dependent headers
+ *
+ * Copyright 2007 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef __INCsysPpcAsmh
+#define __INCsysPpcAsmh
+
+#if	!defined(_DIAB_TOOL) && !defined(_GNU_TOOL)
+#define	_GNU_TOOL
+#endif
+
+/* PowerPC specific settings */
+#if (CPU==PPCE500MC)
+#define	_PPC_HREG_SIZE		4	/* default register size */
+#define _PPC_TEXT_SEG_ALIGN     8       /* 8 byte text segment alignment */
+#else
+#define	_PPC_HREG_SIZE		4	/* default register size */
+#define _PPC_TEXT_SEG_ALIGN     4       /* 4 byte text segment alignment */
+#endif
+
+/* macros for stack frame */
+
+/*
+SVR4 Stack space allocation:
+
+    Before Dynamic stack allocation
+
+    +----------------------------------+
+    |       Back Chain                 |
+    |----------------------------------|
+    |  Register save areas             |
+    |----------------------------------|
+    |  local,non-static variables      |
+    |----------------------------------|
+    |  parameter lists for callees     | (overloaded parameters with #)
+    |----------------------------------|
+    |      LR save word                |
+    |----------------------------------|
+SP=>|      Back chain                  |
+    +----------------------------------+
+
+    After Dynamic stack allocation
+
+    +----------------------------------+
+    |       Back Chain                 |
+    |----------------------------------|
+    |  Register save areas             |
+    |----------------------------------|
+    |  local,non-static variables      |
+    |----------------------------------|
+    |  Dynamic Allocation Area         | 16 byte stack alignment
+    |----------------------------------|
+    |  parameter lists for callees     |
+    |----------------------------------|
+    |      LR save word                |
+    |----------------------------------|
+SP=>|      Back chain                  |
+    +----------------------------------+ 16 bytes stack alignment
+*/
+
+  /* Stack and Allocation alignment */
+
+/*
+ * While it is possible to use different stack alignments for different
+ * PPC processors, current compilers use 16-byte alignment for all.
+ */
+
+#define _CPU_STACK_ALIGN_SIZE	16	/* stack alignment (for all PPC) */
+#define	_CPU_STACK_ALIGN_SHIFT	4
+
+/*
+ * The use of CPU could/should be replaced with existing defines,
+ * like CONFIG_MPC85xx etc.
+ */
+#if ((CPU == PPC604)   || (CPU == PPC85XX) || \
+    (CPU == PPCE500MC) || (CPU == PPC970)) /* Altivec, E500 EABI */
+# define _CPU_ALLOC_ALIGN_SIZE	16	/* allocation alignment */
+#else					/* for others, !defined for generic */
+# define _CPU_ALLOC_ALIGN_SIZE	8	/* allocation alignment */
+#endif	/* PPC604|PPC85XX|PPC970 */
+
+#define	FRAMEBASESZ		16	/* minimum stack frame size */
+
+/*
+ *
+ * _WRS_ARCH_USER_STACK_FRAME_EXTENSION - creating words on the stack for the
+ *                                        back chain word and the LR register.
+ *
+ * This macro is used in creating the initial stack frame for an RTP's initial
+ * task. It performs the extra steps of creating words on the stack for the
+ * back chain word and the LR register. Both these locations are set to 0 to
+ * prevent stack traces and debuggers from looking ahead.
+ *
+ */
+#define _WRS_ARCH_USER_STACK_FRAME_EXTENSION(sp)			     \
+do									     \
+{								     \
+	(sp) -= 2*sizeof(int *);					     \
+	*((int *)(sp)) = (int)0;					     \
+	*((int *)((sp)+4)) = (int)0;					     \
+} while ((0))
+
+
+#ifdef	_ASMLANGUAGE
+
+/* register definition */
+
+/* common SPR registers */
+
+#ifndef XER
+#define XER 1
+#endif
+#ifndef LR
+#define LR 8
+#endif
+#ifndef CTR
+#define CTR 9
+#endif
+
+/* volatile registers that are not saved across subroutine calls */
+
+#define p0	r3	/* argument register, volatile */
+#define p1	r4	/* argument register, volatile */
+#define p2	r5	/* argument register, volatile */
+#define p3	r6	/* argument register, volatile */
+#define p4	r7	/* argument register, volatile */
+#define p5	r8	/* argument register, volatile */
+#define p6	r9	/* argument register, volatile */
+#define p7	r10	/* argument register, volatile */
+#define glr0	r0	/* prologs(PO,EABI), epilogs, glink routines(EABI) /
+			 * language specific purpose(SVR4), volatile */
+#define glr1	r11	/* prologs, epilogs, as Pascal environment pointer(EABI)
+			 * language specific purpose (SVR4)
+			 * calls by pointer, as Pascal environment(PO),
+			 * volatile */
+#define glr2	r12	/* prologs, epilogs, glink routines, calls by
+			 * pointer(EABI), language specific purpose (SVR4),
+			 * glue code, exception handling (PO), volatile */
+#define retval0	r3	/* return register 0, volatile */
+#define retval1	r4	/* return register 1, volatile */
+
+
+/* non-volatile and dedicated registers saved across subroutine calls */
+
+#define	sp	r1	/* stack pointer, dedicated */
+
+#define t0	r14	/* temporary registers, non-volatile */
+#define t1	r15	/* temporary registers, non-volatile */
+#define t2	r16	/* temporary registers, non-volatile */
+#define t3	r17	/* temporary registers, non-volatile */
+#define t4	r18	/* temporary registers, non-volatile */
+#define t5	r19	/* temporary registers, non-volatile */
+#define t6	r20	/* temporary registers, non-volatile */
+#define t7	r21	/* temporary registers, non-volatile */
+#define t8	r22	/* temporary registers, non-volatile */
+#define t9	r23	/* temporary registers, non-volatile */
+#define t10	r24	/* temporary registers, non-volatile */
+#define t11	r25	/* temporary registers, non-volatile */
+#define t12	r26	/* temporary registers, non-volatile */
+#define t13	r27	/* temporary registers, non-volatile */
+#define t14	r28	/* temporary registers, non-volatile */
+#define t15	r29	/* temporary registers, non-volatile */
+#define t16	r30	/* temporary registers, non-volatile */
+#define t17	r31	/* temporary registers, non-volatile */
+
+#ifdef	_GNU_TOOL
+
+/* GP register names */
+
+#define r0	0
+#define r1	1
+#define r2	2
+#define r3	3
+#define r4	4
+#define r5	5
+#define r6	6
+#define r7	7
+#define r8	8
+#define r9	9
+#define r10	10
+#define r11	11
+#define r12	12
+#define r13	13
+#define r14	14
+#define r15	15
+#define r16	16
+#define r17	17
+#define r18	18
+#define r19	19
+#define r20	20
+#define r21	21
+#define r22	22
+#define r23	23
+#define r24	24
+#define r25	25
+#define r26	26
+#define r27	27
+#define r28	28
+#define r29	29
+#define r30	30
+#define r31	31
+
+#ifdef	_PPC_MSR_FP
+/* FP register names */
+
+#define	fp0	0
+#define	fr0	0
+#define	f0	0
+#define	fp1	1
+#define	fr1	1
+#define	f1	1
+#define	fp2	2
+#define	fr2	2
+#define	f2	2
+#define	fp3	3
+#define	fr3	3
+#define	f3	3
+#define	fp4	4
+#define	fr4	4
+#define	f4	4
+#define	fp5	5
+#define	fr5	5
+#define	f5	5
+#define	fp6	6
+#define	fr6	6
+#define	f6	6
+#define	fp7	7
+#define	fr7	7
+#define	f7	7
+#define	fp8	8
+#define	fr8	8
+#define	f8	8
+#define	fp9	9
+#define	fr9	9
+#define	f9	9
+#define	fp10	10
+#define	fr10	10
+#define	f10	10
+#define	fp11	11
+#define	fr11	11
+#define	f11	11
+#define	fp12	12
+#define	fr12	12
+#define	f12	12
+#define	fp13	13
+#define	fr13	13
+#define	f13	13
+#define	fp14	14
+#define	fr14	14
+#define	f14	14
+#define	fp15	15
+#define	fr15	15
+#define	f15	15
+#define	fp16	16
+#define	fr16	16
+#define	f16	16
+#define	fp17	17
+#define	fr17	17
+#define	f17	17
+#define	fp18	18
+#define	fr18	18
+#define	f18	18
+#define	fp19	19
+#define	fr19	19
+#define	f19	19
+#define	fp20	20
+#define	fr20	20
+#define	f20	20
+#define	fp21	21
+#define	fr21	21
+#define	f21	21
+#define	fp22	22
+#define	fr22	22
+#define	f22	22
+#define	fp23	23
+#define	fr23	23
+#define	f23	23
+#define	fp24	24
+#define	fr24	24
+#define	f24	24
+#define	fp25	25
+#define	fr25	25
+#define	f25	25
+#define	fp26	26
+#define	fr26	26
+#define	f26	26
+#define	fp27	27
+#define	fr27	27
+#define	f27	27
+#define	fp28	28
+#define	fr28	28
+#define	f28	28
+#define	fp29	29
+#define	fr29	29
+#define	f29	29
+#define	fp30	30
+#define	fr30	30
+#define	f30	30
+#define	fp31	31
+#define	fr31	31
+#define	f31	31
+#endif	/* _PPC_MSR_FP */
+
+/* Condition register names */
+
+#define cr0	0
+#define cr1	1
+#define cr2	2
+#define cr3	3
+#define cr4	4
+#define cr5	5
+#define cr6	6
+#define cr7	7
+
+/* Macro for hiadjust and lo */
+
+#define HIADJ(arg)	arg@ha
+#define HI(arg)		arg@h
+#define LO(arg)		arg@l
+
+#ifdef _PPC_MSR_VEC
+
+/* ALTIVEC Vector register names */
+
+#define v0      0
+#define v1      1
+#define v2      2
+#define v3      3
+#define v4      4
+#define v5      5
+#define v6      6
+#define v7      7
+#define v8      8
+#define v9      9
+#define v10     10
+#define v11     11
+#define v12     12
+#define v13     13
+#define v14     14
+#define v15     15
+#define v16     16
+#define v17     17
+#define v18     18
+#define v19     19
+#define v20     20
+#define v21     21
+#define v22     22
+#define v23     23
+#define v24     24
+#define v25     25
+#define v26     26
+#define v27     27
+#define v28     28
+#define v29     29
+#define v30     30
+#define v31     31
+
+#endif /* _PPC_MSR_VEC */
+
+#endif	/* _GNU_TOOL */
+
+#ifdef	_DIAB_TOOL
+
+#ifdef	_PPC_MSR_FP
+/* Diab Data FP register names */
+
+#define	fp0	f0
+#define	fr0	f0
+#define	fp1	f1
+#define	fr1	f1
+#define	fp2	f2
+#define	fr2	f2
+#define	fp3	f3
+#define	fr3	f3
+#define	fp4	f4
+#define	fr4	f4
+#define	fp5	f5
+#define	fr5	f5
+#define	fp6	f6
+#define	fr6	f6
+#define	fp7	f7
+#define	fr7	f7
+#define	fp8	f8
+#define	fr8	f8
+#define	fp9	f9
+#define	fr9	f9
+#define	fp10	f10
+#define	fr10	f10
+#define	fp11	f11
+#define	fr11	f11
+#define	fp12	f12
+#define	fr12	f12
+#define	fp13	f13
+#define	fr13	f13
+#define	fp14	f14
+#define	fr14	f14
+#define	fp15	f15
+#define	fr15	f15
+#define	fp16	f16
+#define	fr16	f16
+#define	fp17	f17
+#define	fr17	f17
+#define	fp18	f18
+#define	fr18	f18
+#define	fp19	f19
+#define	fr19	f19
+#define	fp20	f20
+#define	fr20	f20
+#define	fp21	f21
+#define	fr21	f21
+#define	fp22	f22
+#define	fr22	f22
+#define	fp23	f23
+#define	fr23	f23
+#define	fp24	f24
+#define	fr24	f24
+#define	fp25	f25
+#define	fr25	f25
+#define	fp26	f26
+#define	fr26	f26
+#define	fp27	f27
+#define	fr27	f27
+#define	fp28	f28
+#define	fr28	f28
+#define	fp29	f29
+#define	fr29	f29
+#define	fp30	f30
+#define	fr30	f30
+#define	fp31	f31
+#define	fr31	f31
+#endif	/* _PPC_MSR_FP */
+
+/* Macro for hiadjust and lo */
+
+#define HIADJ(arg)      %hiadj(arg)
+#define HI(arg)		%hi(arg)
+#define LO(arg)		%lo(arg)
+
+#endif	/* _DIAB_TOOL */
+
+/*
+ * define r2 as VTOC/GOT(EABI), system use(SVR4)/TOC/GOT(PO),dedicated.
+ * define r13 as CTOC/GOT anchor pointer, dedicated (EABI), non-volatile
+ * register (SVR4, PO)
+ */
+
+#define FUNC(func)	    func
+#define FUNC_LABEL(func)    func:
+
+#define FUNC_DECL(range, func)
+#define VAR_DECL(var)   var
+#define VAR(var)        var(r0)
+
+/*
+ * These macros are used to declare assembly language symbols that need
+ * to be typed properly(func or data) to be visible to the OMF tool.
+ * So that the build tool could mark them as an entry point to be linked
+ * by another PD.
+ */
+
+#define GTEXT(sym) FUNC(sym) ;  .type   FUNC(sym),@function
+#define GDATA(sym) VAR_DECL(sym) ;  .type   VAR_DECL(sym),@object
+
+/* Introduced to abstract assembler idiosyncrasies */
+
+#define	FUNC_EXPORT(func)	.globl	GTEXT(func)
+#define	DATA_EXPORT(var)	.globl	GDATA(var)
+#define	FUNC_IMPORT(func)	.extern	FUNC(func)
+#define	DATA_IMPORT(var)	.extern	VAR_DECL(var)
+#define	FUNC_BEGIN(func)	FUNC_LABEL(func)
+#define	FUNC_END(func)		.size	FUNC(func), . - FUNC(func)
+
+/* Macro for beginning a text segment */
+
+#define _WRS_TEXT_SEG_START \
+        .text ; .balign _PPC_TEXT_SEG_ALIGN
+
+#define	FRAMESZ(nregs)	\
+	  ROUND_UP((FRAMEBASESZ + nregs * _PPC_HREG_SIZE), _STACK_ALIGN_SIZE)
+
+#define	LOADPTR(reg,const32) \
+	  addis reg,r0,HIADJ(const32); addi reg,reg,LO(const32)
+
+#define	LOADVAR(reg,const32) \
+	  addis reg,r0,HIADJ(const32); lwz reg,LO(const32)(reg)
+
+#else	/* _ASMLANGUAGE */
+
+#define _WRS_ASM(x) __asm volatile (x)
+
+/*
+ * Use constant sizes if known (when building for a specific CPU type)
+ * else fetch from a global variable (when building for generic PPC32)
+ */
+
+#ifdef	_CPU_STACK_ALIGN_SIZE
+#define	_STACK_ALIGN_SIZE	_CPU_STACK_ALIGN_SIZE
+#else	/* _CPU_STACK_ALIGN_SIZE */
+#define	_STACK_ALIGN_SIZE	_ppcStackAlignSize
+extern	int	_ppcStackAlignSize;
+#endif	/* _CPU_STACK_ALIGN_SIZE */
+
+#ifdef	_CPU_ALLOC_ALIGN_SIZE
+#define	_ALLOC_ALIGN_SIZE	_CPU_ALLOC_ALIGN_SIZE
+#else	/* _CPU_ALLOC_ALIGN_SIZE */
+#define	_ALLOC_ALIGN_SIZE	_ppcAllocationQuantumSize
+extern	int	_ppcAllocationQuantumSize;
+#endif	/* _CPU_ALLOC_ALIGN_SIZE */
+
+#define	FUNCREF(func)	func
+
+#endif	/* _ASMLANGUAGE */
+
+#endif /* __INCsysPpcAsmh */
diff --git a/arch/powerpc/kernel/vbi/Makefile b/arch/powerpc/kernel/vbi/Makefile
new file mode 100644
index 0000000..daac59f
--- /dev/null
+++ b/arch/powerpc/kernel/vbi/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the vbi ppc.
+#
+
+obj-y		+= syscalls.o util.o wrhv.o vmmu_display.o show.o
diff --git a/arch/powerpc/kernel/vbi/show.c b/arch/powerpc/kernel/vbi/show.c
new file mode 100644
index 0000000..8d48d57
--- /dev/null
+++ b/arch/powerpc/kernel/vbi/show.c
@@ -0,0 +1,90 @@
+/*
+ * show.c - vbi PowerPC show routines
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <vbi/vbi.h>
+
+/*
+ * vbi_disp_status_regs - display registers from a EREG_SET
+ *
+ * This routine display the contents of the PowerPC emulated status registers
+ * structure on the console.
+ *
+ */
+void vbi_disp_status_regs(void)
+{
+    struct vb_status *p = VBI_STATUS_ADDR_GET();
+
+#ifndef CPU
+#error CPU is undefined, needs to be PPC85XX or similar.
+#endif
+
+#if CPU == PPC85XX /* don't know how to handle cpu variant */
+    printk("  srr0/srr1:          0x%08x 0x%08x\n",
+		VB_STATUS_REGS_ACCESS (p, srr0) ,
+		VB_STATUS_REGS_ACCESS (p, srr1));
+
+    printk("  mcsrr0/mcsrr1:      0x%08x 0x%08x\n",
+		VB_STATUS_REGS_ACCESS (p, mcsrr0) ,
+		VB_STATUS_REGS_ACCESS (p, mcsrr1));
+
+    printk("  mcsr/mcar:          0x%08x 0x%08x\n",
+		VB_STATUS_REGS_ACCESS (p, mcsr) ,
+		VB_STATUS_REGS_ACCESS (p, mcar));
+
+    printk("  dear/esr:           0x%08x 0x%08x\n",
+		VB_STATUS_REGS_ACCESS (p, dear) ,
+		VB_STATUS_REGS_ACCESS (p, esr));
+
+    printk("  svr/pvr:            0x%08x 0x%08x\n",
+		VB_STATUS_REGS_ACCESS (p, svr) ,
+		VB_STATUS_REGS_ACCESS (p, pvr));
+
+    printk("  hid0/hid1:          0x%08x 0x%08x\n",
+		VB_STATUS_REGS_ACCESS (p, hid0) ,
+		VB_STATUS_REGS_ACCESS (p, hid1));
+
+    printk("  l1csr0/l1csr1:      0x%08x 0x%08x\n",
+		VB_STATUS_REGS_ACCESS (p, l1csr0) ,
+		VB_STATUS_REGS_ACCESS (p, l1csr1));
+
+    printk("  bucsr:              0x%08x\n",
+		VB_STATUS_REGS_ACCESS (p, bucsr));
+#endif
+}
+
+/*
+ * vbi_disp_ctrl_regs - display registers from a EREG_SET
+ *
+ * This routine display the contents of the PowerPC emulated status registers
+ * structure on the console.
+ *
+ */
+
+void vbi_disp_ctrl_regs(void)
+{
+    struct vb_control *p = VBI_CNTRL_ADDR_GET();
+
+#if CPU == PPC85XX /* don't know how to handle cpu variant */
+    printk("  srr0/srr1:           0x%08x 0x%08x\n",
+		VB_CONTROL_REGS_ACCESS (p, srr0),
+		VB_CONTROL_REGS_ACCESS (p, srr1));
+
+    printk("  cr/r0:               0x%08x 0x%08x\n",
+		VB_CONTROL_REGS_ACCESS (p, cr),
+		VB_CONTROL_REGS_ACCESS (p, r0));
+#endif
+}
diff --git a/arch/powerpc/kernel/vbi/syscalls.S b/arch/powerpc/kernel/vbi/syscalls.S
new file mode 100644
index 0000000..4e06012
--- /dev/null
+++ b/arch/powerpc/kernel/vbi/syscalls.S
@@ -0,0 +1,769 @@
+/*
+ * syscalls.s - hypervisor system calls
+ *
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#define _ASMLANGUAGE
+
+#include <vbi/vbi.h>
+#include <asm/vbi.h>
+
+#ifdef CONFIG_PPC85xx_VT_MODE	/* not currently implemented */
+#define HCALL sc 1
+#else
+#define HCALL sc
+#endif
+
+/* globals */
+
+FUNC_EXPORT(vbi_vcore_irq_redirect)
+FUNC_EXPORT(vbi_shell_start_debug)
+FUNC_EXPORT(vbi_vb_read_mem)
+FUNC_EXPORT(vbi_vb_write_mem)
+FUNC_EXPORT(vbi_vb_read_reg)
+FUNC_EXPORT(vbi_vb_write_reg)
+FUNC_EXPORT(vbi_io_apic_op)
+FUNC_EXPORT(vbi_io_apic_ioctl)
+FUNC_EXPORT(vbi_hy_ioctl)
+FUNC_EXPORT(vbi_ctx_ctl)
+FUNC_EXPORT(vbi_send)
+FUNC_EXPORT(vbi_rx_op)
+FUNC_EXPORT(vbi_reply)
+FUNC_EXPORT(vbi_flush_icache)
+FUNC_EXPORT(vbi_flush_dcache)
+FUNC_EXPORT(vbi_update_text_cache)
+#if (CPU==PPC85XX)
+FUNC_EXPORT(vbi_update_spefscr)
+#endif
+FUNC_EXPORT(vbi_flush_tlb)
+FUNC_EXPORT(vbi_panic)
+FUNC_EXPORT(vbi_ps)
+FUNC_EXPORT(vbi_kputs)
+FUNC_EXPORT(vbi_kputc)
+FUNC_EXPORT(vbi_vcore_irq_unlock)
+FUNC_EXPORT(vbi_vcore_irq_lock)
+FUNC_EXPORT(vbi_vcore_irq_state)
+FUNC_EXPORT(vbi_set_exc_base)
+FUNC_EXPORT(vbi_set_exc_offset)
+FUNC_EXPORT(vbi_get_exc_offset)
+FUNC_EXPORT(vbi_set_mem_attr)
+FUNC_EXPORT(vbi_get_mem_attr)
+FUNC_EXPORT(vbi_config_vmmu)
+FUNC_EXPORT(vbi_enable_vmmu)
+FUNC_EXPORT(vbi_disable_vmmu)
+FUNC_EXPORT(vbi_tlb_load_vmmu)
+FUNC_EXPORT(vbi_tlb_flush_vmmu)
+FUNC_EXPORT(vbi_vb_mgmt)
+FUNC_EXPORT(vbi_ns_op)
+FUNC_EXPORT(vbi_vb_suspend)
+FUNC_EXPORT(vbi_vb_reset)
+FUNC_EXPORT(vbi_vb_restart)
+FUNC_EXPORT(vbi_vb_resume)
+FUNC_EXPORT(vbi_vb_remote)
+FUNC_EXPORT(vbi_direct_IRQ_EOI)
+
+_WRS_TEXT_SEG_START
+
+#define vbi_hcall(name, call)		\
+FUNC_LABEL(name)			\
+	lis r0, HI(VBI_SYS_##call);	\
+	ori r0, r0, LO(VBI_SYS_##call);	\
+	HCALL;				\
+	blr;				\
+FUNC_END(name)
+
+/*
+ * sys_vbMgmt - virtual board management
+ *
+ * This routine executes the specified command on a given virtual board. The
+ * possible commands are:
+ *
+ * VBI_VBMGMT_ATTACH
+ * Attach the requesting Virtual Board to the VB management agent for
+ * operations on the specified VB.
+ *
+ * VBI_VBMGMT_DETACH
+ * Detatch the requesting Virtual Board from the VB management agent for
+ * operations on the specified VB.
+ *
+ * VBI_VBMGMT_SUSPEND
+ * Suspends target Virtual Board from operation.  Fails if Virtual Board
+ * has already been suspended
+ *
+ * VBI_VBMGMT_RESET
+ * Resume a target virtual board.  Fails if a Virtual Board has not been
+ * suspended. Currently no options are supported
+ *
+ * VBI_VBMGMT_RESUME
+ * Restarts a target Virtual Board which has Preload=0 set in the xml file.
+ * Fails if Virtual Board is preloaded (Preload=1)
+ *
+ * The fourth argument to this routine specifies an flag that must be defined
+ * when executing VBI_VBMGMT_RESUME operation. Otherwise the command fails.
+ * The possible flgas are:
+ *   VBI_VTLB_OP_UPDATE_PMD
+ *   VBI_VTLB_OP_UPDATE_PTE
+ *   VBI_VTLB_OP_DELETE_PMD
+ *   VBI_VTLB_OP_SET_PTE_AT
+ *   VBI_VTLB_OP_SET_PTE
+ *   VBI_VTLB_OP_FLUSH_OPS
+ *   VBI_VTLB_OP_INIT
+ *
+ */
+vbi_hcall(vbi_vb_mgmt, vbMgmt)
+
+
+/*
+ * vbi_vb_suspend - Suspend a virtual board's core
+ *
+ * This routine makes a hypercall in order to suspend one or more cores that
+ * exist within the specified virtual board. The target core(s) enter HALT
+ * state until vbi_vb_resume() is called change the state of the core(s). This
+ * function will return only after all victim cores are suspended unless the
+ * opration fails to complete. The second argument passed to this function
+ * specifies one or more target cores. For suspending every core within the
+ * specified VB the second argument must be set to VBI_VB_CORES_ALL. This
+ * implies that the core requesting the suspension may also be included in the
+ * list to be suspended.  To suspend everyone but the recipient then the second
+ * argument passed to this function should be set to VBI_VB_CORES_OTHERS.
+ * Otherwise the second argument should be a valid core number within the VB.
+ * This hypercall sends a message to a given hypervisor manager that provides
+ * virtual board managment service.
+ *
+ */
+vbi_hcall(vbi_vb_suspend, vbSuspend)
+
+/*
+ * vbi_vb_reset - Reset a virtual board's core
+ *
+ * This routine makes a hypercall in order to reset one or more cores that
+ * exist within the specified virtual board. Calling this function puts the
+ * target core(s) program counter to it's ENTRY function. The ENTRY function is
+ * determined based on the loaded binary image. A core does not execute beyond
+ * it's ENTRY function unless vbi_vb_restart() is explitly called.  Except for
+ * core0 within the target VB where VBI_VBMGMT_RESET_AND_START_CORE0 option is
+ * set in the flag passed as the third argument to this routine.  The hypercall
+ * sends a message to a manager that provides VB managment services.  This
+ * function will return only after all victim cores are reset unless the
+ * operation fails to complete. The order of which the victim cores are reset
+ * is not determined. The second argument identifies the cores to perform the
+ * operation on.  The value of the second argument should be set to one of the
+ * following:
+ *
+ * VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
+ *
+ * VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the victim VB
+ *
+ * A valid core number: Reset the specified core that exist within the Virtual
+ * Board.
+ *
+ * The third argument argument passed to this function specifies options that
+ * are applicable only when the second argument is VBI_VB_CORES_ALL. The
+ * options may be one of the following or a combination:
+ *
+ *
+ * VBI_VBMGMT_RESET_CLEAR: Zero out the core's memory, can only be used in
+ * conjunction with VBI_VBMGMT_RESET_DOWNLOAD
+ *
+ * VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images
+ *
+ * VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
+ *
+ * IMPORTANT: If a user chooses to restart core without reloading the
+ * executable image then the data section must be restored to prevent critical
+ * errors. It is the guest OS's responsibility to clear the bss data sections
+ * in such scenario.
+ *
+ */
+vbi_hcall(vbi_vb_reset, vbReset)
+
+/*
+ * vbi_vb_restart - Restart a virtual board's core
+ *
+ * This routine makes a hypercall in order to restart a virtual cores from
+ * reset.  It's called to start running a core or cores that were previously
+ * reset by calling vbi_vb_reset(). The target core(s) start(s) executing from
+ * the ENTRY function retrieved from the corresponding binary image.  This
+ * function will return only after  all cores are out of reset unless the
+ * operation fails to complete.  The second argument represents the cores to
+ * restart.  For restarting every core in reset mode within the specified VB
+ * the second argument is set to VBI_VB_CORES_ALL. To restart a specific core
+ * within the VB then the core number must be passed in the second argument.
+ *
+ * This hypercall sends a message to a manager that provides VB managment
+ * services.
+ *
+ */
+vbi_hcall(vbi_vb_restart, vbRestart)
+
+/*
+ *
+ * vbi_vb_resume - Resume a virtual board's core
+ *
+ * This routine makes a hypercall in order to resume one or cores within the
+ * specified virtual board. It reactivates a cores or cores that were
+ * previously suspended by calling vbi_vb_resume(). This function will return
+ * only after all victim cores are resumed unless the operation fails. The
+ * order of which the cores are resumed is not determined. The second argument
+ * may a magic number instead of a valid core number to indicate that the
+ * operation is intended for more than one core. For resuming every core within
+ * the specified VB then the second argument is set to be equal to
+ * VBI_VB_RESUME_ALL.  This implies to resume every core within the specified
+ * VB. Using this option when some of the cores within the VB are already
+ * running is not considered as programming error.
+ *
+ */
+vbi_hcall(vbi_vb_resume, vbResume)
+
+/*
+ *
+ * vbi_send - Send a message to another context
+ *
+ * This routine makes a hypercall to send a message to the specified context
+ * and waits for a reply.  The caller will block until the sender replies to
+ * the sent message.
+ *
+ */
+vbi_hcall(vbi_send, send)
+
+/*
+ * vbi_rx_op - Receive a message from another context
+ *
+ * This routine makes a hypercall and waits for a message to be received from
+ * another context. It blocks until a message is received.
+ *
+ */
+vbi_hcall(vbi_rx_op, receive)
+
+/*
+ * vbi_reply - Reply to message received from another context
+ *
+ * This routine makes a hypercall in order to reply to a message received from
+ * another context. A message is received from remote context by calling
+ * vbi_receive(). The reply will unblock the recipient which may preempt
+ * the caller.
+ *
+ */
+vbi_hcall(vbi_reply, reply)
+
+/*
+ *
+ * vbi_kputs - print a string on the hypervisor kernel console
+ *
+ * This routine makes a hypercall and prints a string of characters to to
+ * hypervisor console.
+ *
+ */
+vbi_hcall(vbi_kputs, kputs)
+
+/*
+ *
+ * vbi_kputc - print a character on the hypervisor kernel console
+ *
+ * This routine makes a hypercall in order to print the specified character to
+ * hypervisor console.
+ *
+ */
+vbi_hcall(vbi_kputc, kputc)
+
+/*
+ * vbi_panic - halt the system and dump debug info
+ *
+ * This routine makes a hypercall in order to halt the system and display debug
+ * information on hypervisor console. If hypervisor is configured with
+ * WRHV_DISPLAY_ERROR_MSGS this routine prints the specified string to
+ * hypervisor console. If hypervisor is configured with WRHV_DISPLAY_EXC_INFO
+ * component the offending cores registers dump is displayed on hypervisor
+ * console. If hypervisor is configured with WRHV_INCLUDE_DEBUG_MGR a message
+ * is sent to the the debug manager.
+ *
+ */
+vbi_hcall(vbi_panic, panic)
+
+/*
+ * vbi_shell_start_debug - start the hypervisor debug shell
+ *
+ * This routine sends a message to the hypervisor debug shell manager in order
+ * to start the WRHV shell program. The shell program spins therefore does not
+ * share the processor with any other WRHV context. By default a caller of this
+ * routine is detached to allow the caling core to continue executing (as long
+ * as the are not scheduled to run on the same processor). An optional flag
+ * VBI_SHELL_ATTACH can be specified to force the caller virtual board core to
+ * block while the shell program is running.
+ *
+ */
+
+vbi_hcall(vbi_shell_start_debug, dbgShStart)
+
+/*
+ *
+ * vbi_flush_icache - flush the instruction cache
+ *
+ * This routine makes a hypercall to flush the instruction cache of the calling
+ * core for the specified address range.
+ *
+ */
+vbi_hcall(vbi_flush_icache, icache_flush)
+
+/*
+ * vbi_flush_dcache - flush the specified Data cache
+ *
+ * This routine makes a hypercall to flush the data cache of the calling core
+ * for the specified address range.
+ *
+ */
+vbi_hcall(vbi_flush_dcache, dcache_flush)
+
+/*
+ *
+ * vbi_flush_tlb - flush an MMU TLB entry
+ *
+ * This system call flushes the TLB associated with the specified context id
+ *
+ */
+vbi_hcall(vbi_flush_tlb, tlb_flush)
+
+#if (CPU==PPC85XX)
+/*
+ * vbi_update_spefscr(BOOL speEnable, uint32_t spefscr)
+ *
+ *  This fast hypercall uses r0,r3,r4,r5. Although SPE is enabled here it is
+ *  up to the guest to make sure it adds this bit to the control SRR1 reg
+ *  for VBI_SYS_ctx_load. VB_STATUS_SPEFSCR is updated before it returns.
+ */
+
+FUNC_LABEL(vbi_update_spefscr)
+	lis     r0, HI(VBI_SYS_spefscr_update)
+	ori     r0, r0, LO(VBI_SYS_spefscr_update)
+	HCALL
+	blr
+FUNC_END(vbi_update_spefscr)
+#endif 
+
+/*
+ * vbi_vcore_irq_unlock - unlock interrupts for running core
+ *
+ * This routine enables interrupts and makes a fast hypercall if pending
+ * interrupts are detected for the calling core. This is a C wrapper function
+ * for the assembly MACRO VBI_INT_VCORE_UNLOCK().
+ *
+ */
+FUNC_LABEL(vbi_vcore_irq_unlock)
+#ifdef CONFIG_PPC85xx_VT_MODE
+	wrteei	1
+#else
+	lis	p0, HIADJ(wr_vb_control)
+	lwz	p0, LO(wr_vb_control)(p0)
+	li	p1, 0
+	stw	p1, VB_CONTROL_INT_DISABLE(p0)
+#endif
+tryAgain:
+	lis	p0, HIADJ(wr_vb_status)
+	lwz	p0, LO(wr_vb_status)(p0)
+	lwz	p1, VB_STATUS_INT_PENDING(p0)
+
+	/* Perform System Call to re-enable ints if ints pending */
+	cmplwi  p1, 0
+	beq     0f
+
+	lis r0, HI(VBI_SYS_int_enable)
+	ori r0, r0, LO(VBI_SYS_int_enable)
+	HCALL
+	b	tryAgain
+0:
+	blr
+FUNC_END(vbi_vcore_irq_unlock)
+
+/*
+ *
+ * vbi_vcore_irq_lock - lock interrupts
+ *
+ * This routine locks interrupts for the calling core. This is a C wrapper
+ * function for VBI_INT_VCORE_LOCK() assembly macro. It locks interrupts returns
+ * and returns the previous state of interrupts.
+ *
+ */
+FUNC_LABEL(vbi_vcore_irq_lock)
+#ifdef CONFIG_PPC85xx_VT_MODE
+	wrteei	0
+#else
+	li	p1, -1
+	lis	p2, HIADJ(wr_vb_control)
+	lwz	p2, LO(wr_vb_control)(p2)
+	lwz	p0, VB_CONTROL_INT_DISABLE(p2)
+	stw	p1, VB_CONTROL_INT_DISABLE(p2)
+#endif
+	blr
+FUNC_END(vbi_vcore_irq_lock)
+
+/*
+ *
+ * vbi_vcore_irq_state - Get interrupts state for running core
+ *
+ * This routine returns the interrupts state for the calling core. This is C
+ * wrapper function for VBI_INT_VCORE_STATE_GET(). If interrupts are locked it
+ * returns TRUE if interrupts are locked otherwise FALSE.
+ *
+ */
+FUNC_LABEL(vbi_vcore_irq_state)
+#ifdef CONFIG_PPC85xx_VT_MODE
+#define _PPC_MSR_BIT_EE 16
+	mfmsr	r3
+	rlwinm.	r3, r3, 0, _PPC_MSR_BIT_EE, _PPC_MSR_BIT_EE
+	beq	return_disabled
+	li	r3, 0
+	blr
+return_disabled:
+	li	r3, -1
+	blr
+#else
+	lis	p2, HIADJ(wr_vb_control)
+	lwz	p2, LO(wr_vb_control)(p2)
+	lwz	p0, VB_CONTROL_INT_DISABLE(p2)
+	blr
+#endif
+
+FUNC_END(vbi_vcore_irq_state)
+
+/*
+ * vbi_set_exc_base - Set the exceptions vector table base for a virtual core
+ *
+ * This routine changes the exceptions vector table base address for the active
+ * virtual core. By default the base address of the exception table is at
+ * address 0x0.  If the guest OS programmer wishes to move this address then
+ * this function must be called to inform hypervisor. This function must be
+ * called with interrupts disabled to prevent hypervisor to deliver interrupts
+ * to an incorrect table.
+ *
+ */
+FUNC_LABEL(vbi_set_exc_base)
+	/*
+	 * r3 has the base address to set; make sure it is aligned
+	 * align to 32 bytes
+	 */
+	andi. r4, r3, 31
+	cmpwi r4, 0
+	bne- baseAlignError
+
+	/* set command for the ioctl */
+	mr      r4, r3
+	li	r3, VBI_HYIOCTL_EXCBASE
+
+	/* set the hypercall number */
+	lis r0, HI(VBI_SYS_hyIoctl)
+	ori r0, r0, LO(VBI_SYS_hyIoctl)
+	HCALL
+	blr
+baseAlignError:
+	li r3, VBI_EXCBASE_SET_ERROR
+	blr
+
+FUNC_END(vbi_set_exc_base)
+
+/*
+ * vbi_set_exc_offset - Set the exceptions vector offsetcs for a virtual core
+ *
+ * This routine changes the exceptions vector table offset addresses for the
+ * active virtual core. By default they follow the standard PPC exception
+ * offsets. vbi_get_exc_offset will provide the offsets being used for the
+ * virtual board. The offset table uses an index based on IVOR number.
+ * If the guest OS programmer wishes to move these address then this function
+ * must be called to inform hypervisor. This function must be called with
+ * interrupts disabled to prevent hypervisor to deliver interrupts to an
+ * incorrect exception offset. The table is not validated by the hypervisor so
+ * it must be complete and functional otherwize the VB will not behave as
+ * expected.
+ * For SMP systems it is recommended this API be called for each core as it is
+ * started up and before it's added to the scheduler for the guest OS.
+ *
+ */
+FUNC_LABEL(vbi_set_exc_offset)
+	/* set command for the ioctl */
+	mr      r4, r3
+	li	r3, VBI_HYIOCTL_EXCOFFSETS_SET
+
+	/* set the hypercall number */
+	lis r0, HI(VBI_SYS_hyIoctl)
+	ori r0, r0, LO(VBI_SYS_hyIoctl)
+	HCALL
+	blr
+FUNC_END(vbi_set_exc_offset)
+
+/*
+ * vbi_get_exc_offset - Get the exceptions vector offsetcs for a virtual core
+ *
+ * This routine gets the exceptions vector table offset addresses for the
+ * active virtual core. By default they follow the standard PPC exception
+ * offsets. vbi_set_exc_offset will enable the offsets to be changed for the
+ * virtual board. The offset table uses an index based on IVOR number.
+ *
+ */
+FUNC_LABEL(vbi_get_exc_offset)
+	/* set command for the ioctl */
+	mr      r4, r3
+	li	r3, VBI_HYIOCTL_EXCOFFSETS_GET
+
+	/* set the hypercall number */
+	lis r0, HI(VBI_SYS_hyIoctl)
+	ori r0, r0, LO(VBI_SYS_hyIoctl)
+	HCALL
+	blr
+FUNC_END(vbi_get_exc_offset)
+
+/*
+ * vbi_update_text_cache - flush data cache then invalidate instruction cache
+ *
+ * This routine makes a hypercall to flush the data cache then invalidates the
+ * instruction cache of the calling core for the specified address range.
+ *
+ */
+vbi_hcall(vbi_update_text_cache, cache_text_update)
+
+/*
+ * vbi_config_vmmu - configure the hypervisor virtual MMU
+ *
+ * This system call configures the context's virtual MMU within the hypervisor.
+ *
+ */
+vbi_hcall(vbi_config_vmmu, vmmu_config)
+
+/*
+ * vbi_enable_vmmu - enables the virtual MMU
+ *
+ * This system call enables a context's virtual MMU.
+ *
+ */
+vbi_hcall(vbi_enable_vmmu, vmmu_enable)
+
+/*
+ * vbi_disable_vmmu - disable the virtual MMU
+ *
+ * This system call disables a context's virtual MMU.
+ *
+ */
+vbi_hcall(vbi_disable_vmmu, vmmu_disable)
+
+/*
+ *
+ * vbi_tlb_load_vmmu - load a TLB entry into the virtual MMU
+ *
+ * This system call loads the TLB entries for the specified address range into
+ * the virtual MMU.
+ *
+ */
+vbi_hcall(vbi_tlb_load_vmmu, vmmu_tlbload)
+
+
+/*
+ *
+ * vbi_tlb_flush_vmmu - load a TLB entry into the virtual MMU
+ *
+ * This system call flushes the TLB entries for the specified address range
+ * from the virtual MMU.
+ *
+ */
+vbi_hcall(vbi_tlb_flush_vmmu, vmmu_tlbflush)
+
+
+/*
+ *
+ * vbi_hy_ioctl - hypervisor ioctl call
+ *
+ * This system call interfaces to the general purpose hypervisor ioctl
+ * function.
+ *
+ * Possible ioctl commands:
+ *     VBI_HYIOCTL_GETPID
+ *     VBI_HYIOCTL_GETPRIORITY
+ *     VBI_HYIOCTL_PSDISPLAY
+ *     VBI_HYIOCTL_GETSTATS
+ *     VBI_HYIOCTL_EXCBASE
+ *
+ */
+vbi_hcall(vbi_hy_ioctl, hyIoctl)
+
+/*
+ *
+ * vbi_ctx_ctl - hypervisor context control call
+ *
+ * This system call interfaces to the general purpose hypervisor context
+ * control function.
+ *
+ * Possbile operations:
+ *	VBI_CTXCTL_IDLE /@ Make this virtual board go idle @/
+ *
+ */
+vbi_hcall(vbi_ctx_ctl, ctxctl)
+
+/*
+ *
+ * vbi_set_mem_attr - Set protection for a page of memory
+ *
+ * This routine makes a hypercall to set the MMU attribures for the specified
+ * memory range. The possible attributes one or a combinarion of the following:
+ *
+ * VBI_MMU_PROT_READ -  allow supervisor and user read
+ * VBI_MMU_PROT_WRITE -  Allow supervisor and user write
+ * VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
+ *
+ */
+vbi_hcall(vbi_set_mem_attr, mmu_attr_set)
+
+/*
+ * vbi_get_mem_attr - Get MMU page protections
+ *
+ * This routine makes a hypercall to retrieve the MMU attributes associated for
+ * the page where the specified address is mapped. This is not the VMMU
+ * attributes. A guest OS has direct access to the mapping table of its VMMU
+ * therefore a hypercall is not necessary.
+ *
+ */
+vbi_hcall(vbi_get_mem_attr, mmu_attr_get)
+
+/*
+ * vbi_io_apic_ioctl - virtual IO APIC ioctl call
+ *
+ * This system call interfaces to the virtual IO APIC ioctl
+ * function. For PPC this is a nop routine for now.
+ *
+ * Possible ioctl commands:
+ *     VBI_IOAPICIOCTL_UNMASK
+ *     VBI_IOAPICIOCTL_SEND
+ *     VBI_IOAPICIOCTL_MASK
+ *
+ */
+vbi_hcall(vbi_io_apic_ioctl, vIoapicIoctl)
+
+/*
+ *
+ * vbi_ns_op - virtua board name service call
+ *
+ * This system call interfaces to the virtual board
+ *
+ * commands:
+ *	VBI_VBI_NS_REGISTER	   /@ register service	 @/
+ *	VBI_VBI_NS_UNREGISTER	   /@ unregister service @/
+ *	VBI_VBI_NS_LOOKUP	   /@ lookup service	 @/
+ *
+ */
+vbi_hcall(vbi_ns_op, ns_op)
+
+/*
+ * vbi_vb_read_mem - Read a virtual board's memory
+ *
+ * This routine makes a hypercall to read a remote board's memory. The memory
+ * control structure contains information about the target memory to read and
+ * the destination buffer that hypervisor must populate with the data read.
+ * This routine is used to copy data from a remote VB. It is the user's
+ * responsability to ensure that the memory read is accessed orthogonally.  The
+ * size_in parameter specifies the number of bytes desired to be copied.  The
+ * size_out parameter indicates the number of bytes successfully copied.  A user
+ * may set the size_out parameter to zero if the output size is not of interest
+ * otherwise to a value different than zero.
+ *
+ */
+vbi_hcall(vbi_vb_read_mem, memRead_op)
+
+/*
+ * vbi_vb_write_mem - copy data to a remote board's memory
+ *
+ * This routine makes a hypercall to copy to a remote board memory. If the
+ * VBI_DCACHE_FLUSH is set in the control memory control structure then this
+ * routine flushes the data caches lines corresponding to the range of memory
+ * specified. If VBI_ICACHE_INV then this routine ensure that the instruction
+ * cache lines corresponding to the range of address is invalidated after the
+ * memory is copied. Invalidating the instruction is required if data
+ * containing is updated since the instruction cache is not aware of the
+ * content in data cache. Therefore flushing the data cache ensures that memory
+ * contains the updated data and invalidating the instruction cache ensures
+ * that the stale values in the instruction cache is thrown away.  The size_in
+ * parameter specifies the number of bytes desired to be copied.  The size_out
+ * parameter indicates the number of bytes successfully copied.  A user may set
+ * the size_out parameter to zero if the output size is not of interest
+ * otherwise to a value different than zero.
+ *
+ */
+vbi_hcall(vbi_vb_write_mem, memWrite_op)
+
+/*
+ * vbi_io_apic_op - virtual IO APIC operation
+ *
+ * This system call interfaces to the virtual IO APIC ioctl
+ * function.
+ *
+ * Possible ioctl commands:
+ *     VBI_IOAPICIOCTL_UNMASK
+ *     VBI_IOAPICIOCTL_SEND
+ *     VBI_IOAPICIOCTL_MASK
+ *
+ */
+vbi_hcall(vbi_io_apic_op, vIoapicIoctl)
+
+/*
+ * vbi_vb_read_reg - Read a remote core's registers
+ *
+ * This routine makes a hypercall to read a remote core's registers. The
+ * register control structure contains information about the registers to read
+ * and the destination buffers to store them.
+ *
+ */
+vbi_hcall(vbi_vb_read_reg, RegsRead_op)
+
+/*
+ * vbi_vb_write_reg - write to a remote core's registers
+ *
+ * This routine makes a hypercall to write to a remote core's registers. The
+ * register control structure contains the set of registers to write.
+ * The user must ensure to read first the destination core's registers using
+ * vbi_vb_read_reg() then write back the modified set of registers in the
+ * registers control structure.
+ *
+ */
+vbi_hcall(vbi_vb_write_reg, RegsWrite_op)
+
+/*
+ * vbi_vcore_irq_redirect - redirect an irq to another vcore
+ */
+vbi_hcall(vbi_vcore_irq_redirect, intRedirect)
+
+/*
+ * vbi_vb_remote - VB remote operations
+ *
+ * This system call interfaces to the virtual board and requests for
+ * information about a remote VB
+ *
+ * commands:
+ *      VBI_VBREMOTE_BOARDCONFIG         get guest addr of VB_CONFIG
+ *      VBI_VBREMOTE_RAMSIZE             get memory size
+ *
+ */
+vbi_hcall(vbi_vb_remote, vbRemote)
+
+/*
+ * vbi_direct_IRQ_EOI - clear last interrupt 
+ *
+ * This system call interfaces to the virtual board to clear the last PIC 
+ * interrupt enabling another interrupt to be triggered in the hardware.
+ * Should be used only when Virtual board is using direct interrupts.
+ *
+ */
+FUNC_LABEL(vbi_direct_IRQ_EOI)
+#ifdef CONFIG_PPC85xx_VT_MODE
+	lis r0, HI(VBI_SYS_pic_EOI)
+	ori r0, r0, LO(VBI_SYS_pic_EOI)
+	HCALL
+#endif
+	blr
+FUNC_END(vbi_direct_IRQ_EOI)
+
diff --git a/arch/x86/include/asm/arch_vbi.h b/arch/x86/include/asm/arch_vbi.h
new file mode 100644
index 0000000..169b8fe
--- /dev/null
+++ b/arch/x86/include/asm/arch_vbi.h
@@ -0,0 +1,414 @@
+/*
+ * x86 arch_vbi.h - x86 architecture specific definitions
+ *
+ * Copyright 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef _ASM_ARCH_VBI_H
+#define _ASM_ARCH_VBI_H
+
+#ifndef _ASMLANGUAGE
+
+/* struct of system descriptor table registers (VBI_GDTR, VBI_IDTR, VBI_LDTR) */
+
+struct VBI_XDTR
+{
+	uint16_t limit;		/* maximum size of the DT */
+	size_t base;		/* address of DT */
+	uint16_t pad;
+} __attribute__((packed));
+
+struct VBI_XDTR32
+{
+	uint16_t limit;
+	uint32_t base;
+	uint16_t pad;
+} __attribute__((packed));
+
+typedef struct VBI_XDTR vbi_gdtr;
+typedef struct VBI_XDTR vbi_idtr;
+typedef struct VBI_XDTR vbi_ldtr;
+
+typedef struct VBI_XDTR32 vbi_gdtr32;
+typedef struct VBI_XDTR32 vbi_idtr32;
+typedef struct VBI_XDTR32 vbi_ldtr32;
+
+
+/*
+ *
+ * VB_HREG_SET - hardware register set, for read/write
+ *
+ * Used by vbi_vb_read_reg/vbi_vb_write_reg to read/write registers in
+ * another VB
+ *
+ *
+ */
+
+typedef struct			/* VBI_REG_SET - used for sys_regsRead/Write */
+{
+	uint32_t  eax;		/* 00: general register		*/
+	uint32_t  ebx;		/* 04: general register		*/
+	uint32_t  ecx;		/* 08: general register		*/
+	uint32_t  edx;		/* 0C: general register		*/
+	uint32_t  esi;		/* 10: general register		*/
+	uint32_t  edi;		/* 14: general register		*/
+	uint32_t  eip;		/* 18: program counter		*/
+	uint32_t  ebp;		/* 1C: frame pointer register	*/
+	uint32_t  esp;		/* 20: stack pointer register	*/
+	uint32_t  eflags;	/* 24: status register		*/
+	uint32_t  cr0;		/* 28: control register 0	*/
+	uint32_t  cr3;		/* 2C: control register 3	*/
+	uint32_t  cr4;		/* 30: control register 4	*/
+	vbi_idtr32  idtr;	/* 34: IDT task register	*/
+	vbi_gdtr32  gdtr;	/* 3C: GDT task register	*/
+	vbi_ldtr32  ldtr;	/* 44: LDT task register	*/
+	uint32_t  cs;		/* 4C: code segment		*/
+	uint32_t  ss;		/* 50: stack segment		*/
+	uint32_t  ds;		/* 54: data segment		*/
+	uint32_t  es;		/* 58: E segment		*/
+	uint32_t  fs;		/* 5C: F segment		*/
+	uint32_t  gs;		/* 60: G segment		*/
+	uint32_t  tr;		/* 64: task register		*/
+} VBI_HREG_SET;
+
+
+typedef struct			/* REG_SET - x86 register set	*/
+{
+	uint64_t   rax;		/* 00: general register		*/
+	uint64_t   rbx;		/* 08: general register		*/
+	uint64_t   rcx;		/* 10: general register		*/
+	uint64_t   rdx;		/* 18: general register		*/
+	uint64_t   rsp;		/* 20: stack pointer register	*/
+	uint64_t   rbp;		/* 28: frame pointer register	*/
+	uint64_t   rsi;		/* 30: general register		*/
+	uint64_t   rdi;		/* 38: general register		*/
+	uint64_t   r8;	 	/* 40: general register		*/
+	uint64_t   r9;	 	/* 48: general register		*/
+	uint64_t   r10;		/* 50: general register		*/
+	uint64_t   r11;		/* 58: general register		*/
+	uint64_t   r12;		/* 60: general register		*/
+	uint64_t   r13;		/* 68: general register		*/
+	uint64_t   r14;		/* 70: general register		*/
+	uint64_t   r15;		/* 78: general register		*/
+	uint64_t   rip;		/* 80: program counter		*/
+	uint64_t   rflags;		/* 88: status register		*/
+	uint64_t   cr0;		/* 90: control register 0	*/
+	uint64_t   cr2;		/* 98: control register 2	*/
+	uint64_t   cr3;		/* 100: control register 3	*/
+	uint64_t   cr4;		/* 108: control register 4	*/
+	vbi_idtr   idtr;	/* 110: IDT task register	*/
+	vbi_gdtr   gdtr;	/* 11a: GDT task register	*/
+	vbi_ldtr   ldtr;	/* 136: LDT task register	*/
+	uint64_t   cs;		/* 140: code segment		*/
+	uint64_t   ds;		/* 148: data segment		*/
+	uint64_t   ss;		/* 150: stack segment		*/
+	uint64_t   es;		/* 158: E segment		*/
+	uint64_t   fs;		/* 160: F segment		*/
+	uint64_t   gs;		/* 168: G segment		*/
+	uint64_t   tr;		/* 170: Task register		*/
+	/* xxx(gws): excluding FP support */
+} VBI_HREG_SET_64;
+
+
+/* complex register set definition */
+
+typedef union
+{
+	VBI_HREG_SET    hreg32;	/* 32 bit register set */
+	VBI_HREG_SET_64 hreg64;	/* 64 bit register set */
+} VBI_HREG_SET_CMPLX;
+
+
+typedef struct
+{
+	uint32_t vbiRegType;  /* 00: register set to use */
+	uint32_t	    qualifier;   /* 04: optional field, used for alignment */
+
+	VBI_HREG_SET_CMPLX vbiRegSet;
+} VBI_HREG_SET_CMPLX_QUALIFIED;
+
+
+#endif /* _ASMLANGUAGE */
+
+
+/* x86 uses little endian byte ordering */
+
+#define __VBI_BYTE_ORDER __VBI_LITTLE_ENDIAN
+
+#define VBI_X86_MAX_VECTORS         256	/* maximum number of vectors */
+#define VBI_ARCH_EXC_TABLE_SIZE     32
+#define VBI_ARCH_IRQ_TABLE_SIZE     (VBI_X86_MAX_VECTORS - VBI_ARCH_EXC_TABLE_SIZE)
+
+#define VBI_MAX_CORES			 8 /* maximum number of virtual cores */
+
+#define VBI_IN_DIVIDE_ERROR		 0
+#define VBI_IN_DEBUG			 1
+#define VBI_IN_NON_MASKABLE		 2
+#define VBI_IN_BREAKPOINT		 3
+#define VBI_IN_OVERFLOW			 4
+#define VBI_IN_BOUND			 5
+#define VBI_IN_INVALID_OPCODE		 6
+#define VBI_IN_NO_DEVICE		 7
+#define VBI_IN_DOUBLE_FAULT		 8
+#define VBI_IN_CP_OVERRUN		 9
+#define VBI_IN_INVALID_TSS		10
+#define VBI_IN_NO_SEGMENT		11
+#define VBI_IN_STACK_FAULT		12
+#define VBI_IN_PROTECTION_FAULT		13
+#define VBI_IN_PAGE_FAULT		14
+#define VBI_IN_RESERVED			15
+#define VBI_IN_CP_ERROR			16
+#define VBI_IN_ALIGNMENT		17
+#define VBI_IN_MACHINE_CHECK		18
+#define VBI_IN_SIMD			19
+
+/* 19-31 Intel reserved exceptions  */
+
+/* 32-255 user defined exceptions  */
+
+#define VBI_IN_EXT_IRQ_BASE		32	/* local timer interrupt */
+
+#define VBI_IN_EXT_IRQ0			(VBI_IN_EXT_IRQ_BASE + 0)
+#define VBI_IN_EXT_IRQ1			(VBI_IN_EXT_IRQ_BASE + 1)
+#define VBI_IN_EXT_IRQ2			(VBI_IN_EXT_IRQ_BASE + 2)
+#define VBI_IN_EXT_IRQ3			(VBI_IN_EXT_IRQ_BASE + 3)
+#define VBI_IN_EXT_IRQ4			(VBI_IN_EXT_IRQ_BASE + 4)
+#define VBI_IN_EXT_IRQ5			(VBI_IN_EXT_IRQ_BASE + 5)
+#define VBI_IN_EXT_IRQ6			(VBI_IN_EXT_IRQ_BASE + 6)
+#define VBI_IN_EXT_IRQ7			(VBI_IN_EXT_IRQ_BASE + 7)
+#define VBI_IN_EXT_IRQ8			(VBI_IN_EXT_IRQ_BASE + 8)
+#define VBI_IN_EXT_IRQ9			(VBI_IN_EXT_IRQ_BASE + 9)
+#define VBI_IN_EXT_IRQ10		(VBI_IN_EXT_IRQ_BASE + 10)
+#define VBI_IN_EXT_IRQ11		(VBI_IN_EXT_IRQ_BASE + 11)
+#define VBI_IN_EXT_IRQ12		(VBI_IN_EXT_IRQ_BASE + 12)
+#define VBI_IN_EXT_IRQ13		(VBI_IN_EXT_IRQ_BASE + 13)
+#define VBI_IN_EXT_IRQ14		(VBI_IN_EXT_IRQ_BASE + 14)
+#define VBI_IN_EXT_IRQ15		(VBI_IN_EXT_IRQ_BASE + 15)
+#define VBI_IN_EXT_IRQ16		(VBI_IN_EXT_IRQ_BASE + 16)
+#define VBI_IN_EXT_IRQ17		(VBI_IN_EXT_IRQ_BASE + 17)
+#define VBI_IN_EXT_IRQ18		(VBI_IN_EXT_IRQ_BASE + 18)
+#define VBI_IN_EXT_IRQ19		(VBI_IN_EXT_IRQ_BASE + 19)
+#define VBI_IN_EXT_IRQ20		(VBI_IN_EXT_IRQ_BASE + 20)
+#define VBI_IN_EXT_IRQ21		(VBI_IN_EXT_IRQ_BASE + 21)
+#define VBI_IN_EXT_IRQ22		(VBI_IN_EXT_IRQ_BASE + 22)
+#define VBI_IN_EXT_IRQ23		(VBI_IN_EXT_IRQ_BASE + 23)
+#define VBI_IN_EXT_IRQ24		(VBI_IN_EXT_IRQ_BASE + 24)
+#define VBI_IN_EXT_IRQ25		(VBI_IN_EXT_IRQ_BASE + 25)
+#define VBI_IN_EXT_IRQ26		(VBI_IN_EXT_IRQ_BASE + 26)
+#define VBI_IN_EXT_IRQ27		(VBI_IN_EXT_IRQ_BASE + 27)
+#define VBI_IN_EXT_IRQ28		(VBI_IN_EXT_IRQ_BASE + 28)
+#define VBI_IN_EXT_IRQ29		(VBI_IN_EXT_IRQ_BASE + 29)
+#define VBI_IN_EXT_IRQ30		(VBI_IN_EXT_IRQ_BASE + 30)
+#define VBI_IN_EXT_IRQ31		(VBI_IN_EXT_IRQ_BASE + 31)
+#define VBI_IN_EXT_IRQ32		(VBI_IN_EXT_IRQ_BASE + 32)
+#define VBI_IN_EXT_IRQ33		(VBI_IN_EXT_IRQ_BASE + 33)
+#define VBI_IN_EXT_IRQ34		(VBI_IN_EXT_IRQ_BASE + 34)
+#define VBI_IN_EXT_IRQ35		(VBI_IN_EXT_IRQ_BASE + 35)
+#define VBI_IN_EXT_IRQ36		(VBI_IN_EXT_IRQ_BASE + 36)
+#define VBI_IN_EXT_IRQ37		(VBI_IN_EXT_IRQ_BASE + 37)
+#define VBI_IN_EXT_IRQ38		(VBI_IN_EXT_IRQ_BASE + 38)
+#define VBI_IN_EXT_IRQ39		(VBI_IN_EXT_IRQ_BASE + 39)
+#define VBI_IN_EXT_IRQ40		(VBI_IN_EXT_IRQ_BASE + 40)
+#define VBI_IN_EXT_IRQ41		(VBI_IN_EXT_IRQ_BASE + 41)
+#define VBI_IN_EXT_IRQ42		(VBI_IN_EXT_IRQ_BASE + 42)
+#define VBI_IN_EXT_IRQ43		(VBI_IN_EXT_IRQ_BASE + 43)
+#define VBI_IN_EXT_IRQ44		(VBI_IN_EXT_IRQ_BASE + 44)
+#define VBI_IN_EXT_IRQ45		(VBI_IN_EXT_IRQ_BASE + 45)
+#define VBI_IN_EXT_IRQ46		(VBI_IN_EXT_IRQ_BASE + 46)
+#define VBI_IN_EXT_IRQ47		(VBI_IN_EXT_IRQ_BASE + 47)
+#define VBI_IN_EXT_IRQ48		(VBI_IN_EXT_IRQ_BASE + 48)
+#define VBI_IN_EXT_IRQ49		(VBI_IN_EXT_IRQ_BASE + 49)
+#define VBI_IN_EXT_IRQ50		(VBI_IN_EXT_IRQ_BASE + 50)
+#define VBI_IN_EXT_IRQ51		(VBI_IN_EXT_IRQ_BASE + 51)
+#define VBI_IN_EXT_IRQ52		(VBI_IN_EXT_IRQ_BASE + 52)
+#define VBI_IN_EXT_IRQ53		(VBI_IN_EXT_IRQ_BASE + 53)
+#define VBI_IN_EXT_IRQ54		(VBI_IN_EXT_IRQ_BASE + 54)
+#define VBI_IN_EXT_IRQ55		(VBI_IN_EXT_IRQ_BASE + 55)
+#define VBI_IN_EXT_IRQ56		(VBI_IN_EXT_IRQ_BASE + 56)
+#define VBI_IN_EXT_IRQ57		(VBI_IN_EXT_IRQ_BASE + 57)
+#define VBI_IN_EXT_IRQ58		(VBI_IN_EXT_IRQ_BASE + 58)
+#define VBI_IN_EXT_IRQ59		(VBI_IN_EXT_IRQ_BASE + 59)
+#define VBI_IN_EXT_IRQ60		(VBI_IN_EXT_IRQ_BASE + 60)
+#define VBI_IN_EXT_IRQ61		(VBI_IN_EXT_IRQ_BASE + 61)
+#define VBI_IN_EXT_IRQ62		(VBI_IN_EXT_IRQ_BASE + 62)
+#define VBI_IN_EXT_IRQ63		(VBI_IN_EXT_IRQ_BASE + 63)
+#define VBI_IN_EXT_IRQ64		(VBI_IN_EXT_IRQ_BASE + 64)
+#define VBI_IN_EXT_IRQ65		(VBI_IN_EXT_IRQ_BASE + 65)
+#define VBI_IN_EXT_IRQ66		(VBI_IN_EXT_IRQ_BASE + 66)
+#define VBI_IN_EXT_IRQ67		(VBI_IN_EXT_IRQ_BASE + 67)
+#define VBI_IN_EXT_IRQ68		(VBI_IN_EXT_IRQ_BASE + 68)
+#define VBI_IN_EXT_IRQ69		(VBI_IN_EXT_IRQ_BASE + 69)
+#define VBI_IN_EXT_IRQ70		(VBI_IN_EXT_IRQ_BASE + 70)
+#define VBI_IN_EXT_IRQ71		(VBI_IN_EXT_IRQ_BASE + 71)
+#define VBI_IN_EXT_IRQ72		(VBI_IN_EXT_IRQ_BASE + 72)
+#define VBI_IN_EXT_IRQ73		(VBI_IN_EXT_IRQ_BASE + 73)
+#define VBI_IN_EXT_IRQ74		(VBI_IN_EXT_IRQ_BASE + 74)
+#define VBI_IN_EXT_IRQ75		(VBI_IN_EXT_IRQ_BASE + 75)
+#define VBI_IN_EXT_IRQ76		(VBI_IN_EXT_IRQ_BASE + 76)
+#define VBI_IN_EXT_IRQ77		(VBI_IN_EXT_IRQ_BASE + 77)
+#define VBI_IN_EXT_IRQ78		(VBI_IN_EXT_IRQ_BASE + 78)
+#define VBI_IN_EXT_IRQ79		(VBI_IN_EXT_IRQ_BASE + 79)
+#define VBI_IN_EXT_IRQ80		(VBI_IN_EXT_IRQ_BASE + 80)
+#define VBI_IN_EXT_IRQ81		(VBI_IN_EXT_IRQ_BASE + 81)
+#define VBI_IN_EXT_IRQ82		(VBI_IN_EXT_IRQ_BASE + 82)
+#define VBI_IN_EXT_IRQ83		(VBI_IN_EXT_IRQ_BASE + 83)
+#define VBI_IN_EXT_IRQ84		(VBI_IN_EXT_IRQ_BASE + 84)
+#define VBI_IN_EXT_IRQ85		(VBI_IN_EXT_IRQ_BASE + 85)
+#define VBI_IN_EXT_IRQ86		(VBI_IN_EXT_IRQ_BASE + 86)
+#define VBI_IN_EXT_IRQ87		(VBI_IN_EXT_IRQ_BASE + 87)
+#define VBI_IN_EXT_IRQ88		(VBI_IN_EXT_IRQ_BASE + 88)
+#define VBI_IN_EXT_IRQ89		(VBI_IN_EXT_IRQ_BASE + 89)
+#define VBI_IN_EXT_IRQ90		(VBI_IN_EXT_IRQ_BASE + 90)
+#define VBI_IN_EXT_IRQ91		(VBI_IN_EXT_IRQ_BASE + 91)
+#define VBI_IN_EXT_IRQ92		(VBI_IN_EXT_IRQ_BASE + 92)
+#define VBI_IN_EXT_IRQ93		(VBI_IN_EXT_IRQ_BASE + 93)
+#define VBI_IN_EXT_IRQ94		(VBI_IN_EXT_IRQ_BASE + 94)
+#define VBI_IN_EXT_IRQ95		(VBI_IN_EXT_IRQ_BASE + 95)
+#define VBI_IN_EXT_IRQ96		(VBI_IN_EXT_IRQ_BASE + 96)
+#define VBI_IN_EXT_IRQ97		(VBI_IN_EXT_IRQ_BASE + 97)
+#define VBI_IN_EXT_IRQ98		(VBI_IN_EXT_IRQ_BASE + 98)
+#define VBI_IN_EXT_IRQ99		(VBI_IN_EXT_IRQ_BASE + 99)
+#define VBI_IN_EXT_IRQ100		(VBI_IN_EXT_IRQ_BASE + 100)
+#define VBI_IN_EXT_IRQ101		(VBI_IN_EXT_IRQ_BASE + 101)
+#define VBI_IN_EXT_IRQ102		(VBI_IN_EXT_IRQ_BASE + 102)
+#define VBI_IN_EXT_IRQ103		(VBI_IN_EXT_IRQ_BASE + 103)
+#define VBI_IN_EXT_IRQ104		(VBI_IN_EXT_IRQ_BASE + 104)
+#define VBI_IN_EXT_IRQ105		(VBI_IN_EXT_IRQ_BASE + 105)
+#define VBI_IN_EXT_IRQ106		(VBI_IN_EXT_IRQ_BASE + 106)
+#define VBI_IN_EXT_IRQ107		(VBI_IN_EXT_IRQ_BASE + 107)
+#define VBI_IN_EXT_IRQ108		(VBI_IN_EXT_IRQ_BASE + 108)
+#define VBI_IN_EXT_IRQ109		(VBI_IN_EXT_IRQ_BASE + 109)
+#define VBI_IN_EXT_IRQ110		(VBI_IN_EXT_IRQ_BASE + 110)
+#define VBI_IN_EXT_IRQ111		(VBI_IN_EXT_IRQ_BASE + 111)
+#define VBI_IN_EXT_IRQ112		(VBI_IN_EXT_IRQ_BASE + 112)
+#define VBI_IN_EXT_IRQ113		(VBI_IN_EXT_IRQ_BASE + 113)
+#define VBI_IN_EXT_IRQ114		(VBI_IN_EXT_IRQ_BASE + 114)
+#define VBI_IN_EXT_IRQ115		(VBI_IN_EXT_IRQ_BASE + 115)
+#define VBI_IN_EXT_IRQ116		(VBI_IN_EXT_IRQ_BASE + 116)
+#define VBI_IN_EXT_IRQ117		(VBI_IN_EXT_IRQ_BASE + 117)
+#define VBI_IN_EXT_IRQ118		(VBI_IN_EXT_IRQ_BASE + 118)
+#define VBI_IN_EXT_IRQ119		(VBI_IN_EXT_IRQ_BASE + 119)
+#define VBI_IN_EXT_IRQ120		(VBI_IN_EXT_IRQ_BASE + 120)
+#define VBI_IN_EXT_IRQ121		(VBI_IN_EXT_IRQ_BASE + 121)
+#define VBI_IN_EXT_IRQ122		(VBI_IN_EXT_IRQ_BASE + 122)
+#define VBI_IN_EXT_IRQ123		(VBI_IN_EXT_IRQ_BASE + 123)
+#define VBI_IN_EXT_IRQ124		(VBI_IN_EXT_IRQ_BASE + 124)
+#define VBI_IN_EXT_IRQ125		(VBI_IN_EXT_IRQ_BASE + 125)
+#define VBI_IN_EXT_IRQ126		(VBI_IN_EXT_IRQ_BASE + 126)
+#define VBI_IN_EXT_IRQ127		(VBI_IN_EXT_IRQ_BASE + 127)
+#define VBI_IN_EXT_IRQ128		(VBI_IN_EXT_IRQ_BASE + 128)
+#define VBI_IN_EXT_IRQ129		(VBI_IN_EXT_IRQ_BASE + 129)
+#define VBI_IN_EXT_IRQ130		(VBI_IN_EXT_IRQ_BASE + 130)
+#define VBI_IN_EXT_IRQ131		(VBI_IN_EXT_IRQ_BASE + 131)
+#define VBI_IN_EXT_IRQ132		(VBI_IN_EXT_IRQ_BASE + 132)
+#define VBI_IN_EXT_IRQ133		(VBI_IN_EXT_IRQ_BASE + 133)
+#define VBI_IN_EXT_IRQ134		(VBI_IN_EXT_IRQ_BASE + 134)
+#define VBI_IN_EXT_IRQ135		(VBI_IN_EXT_IRQ_BASE + 135)
+#define VBI_IN_EXT_IRQ136		(VBI_IN_EXT_IRQ_BASE + 136)
+#define VBI_IN_EXT_IRQ137		(VBI_IN_EXT_IRQ_BASE + 137)
+#define VBI_IN_EXT_IRQ138		(VBI_IN_EXT_IRQ_BASE + 138)
+#define VBI_IN_EXT_IRQ139		(VBI_IN_EXT_IRQ_BASE + 139)
+#define VBI_IN_EXT_IRQ140		(VBI_IN_EXT_IRQ_BASE + 140)
+#define VBI_IN_EXT_IRQ141		(VBI_IN_EXT_IRQ_BASE + 141)
+#define VBI_IN_EXT_IRQ142		(VBI_IN_EXT_IRQ_BASE + 142)
+#define VBI_IN_EXT_IRQ143		(VBI_IN_EXT_IRQ_BASE + 143)
+#define VBI_IN_EXT_IRQ144		(VBI_IN_EXT_IRQ_BASE + 144)
+#define VBI_IN_EXT_IRQ145		(VBI_IN_EXT_IRQ_BASE + 145)
+#define VBI_IN_EXT_IRQ146		(VBI_IN_EXT_IRQ_BASE + 146)
+#define VBI_IN_EXT_IRQ147		(VBI_IN_EXT_IRQ_BASE + 147)
+#define VBI_IN_EXT_IRQ148		(VBI_IN_EXT_IRQ_BASE + 148)
+#define VBI_IN_EXT_IRQ149		(VBI_IN_EXT_IRQ_BASE + 149)
+#define VBI_IN_EXT_IRQ150		(VBI_IN_EXT_IRQ_BASE + 150)
+#define VBI_IN_EXT_IRQ151		(VBI_IN_EXT_IRQ_BASE + 151)
+#define VBI_IN_EXT_IRQ152		(VBI_IN_EXT_IRQ_BASE + 152)
+#define VBI_IN_EXT_IRQ153		(VBI_IN_EXT_IRQ_BASE + 153)
+#define VBI_IN_EXT_IRQ154		(VBI_IN_EXT_IRQ_BASE + 154)
+#define VBI_IN_EXT_IRQ155		(VBI_IN_EXT_IRQ_BASE + 155)
+#define VBI_IN_EXT_IRQ156		(VBI_IN_EXT_IRQ_BASE + 156)
+#define VBI_IN_EXT_IRQ157		(VBI_IN_EXT_IRQ_BASE + 157)
+#define VBI_IN_EXT_IRQ158		(VBI_IN_EXT_IRQ_BASE + 158)
+#define VBI_IN_EXT_IRQ159		(VBI_IN_EXT_IRQ_BASE + 159)
+#define VBI_IN_EXT_IRQ160		(VBI_IN_EXT_IRQ_BASE + 160)
+#define VBI_IN_EXT_IRQ161		(VBI_IN_EXT_IRQ_BASE + 161)
+#define VBI_IN_EXT_IRQ162		(VBI_IN_EXT_IRQ_BASE + 162)
+#define VBI_IN_EXT_IRQ163		(VBI_IN_EXT_IRQ_BASE + 163)
+#define VBI_IN_EXT_IRQ164		(VBI_IN_EXT_IRQ_BASE + 164)
+#define VBI_IN_EXT_IRQ165		(VBI_IN_EXT_IRQ_BASE + 165)
+#define VBI_IN_EXT_IRQ166		(VBI_IN_EXT_IRQ_BASE + 166)
+#define VBI_IN_EXT_IRQ167		(VBI_IN_EXT_IRQ_BASE + 167)
+#define VBI_IN_EXT_IRQ168		(VBI_IN_EXT_IRQ_BASE + 168)
+#define VBI_IN_EXT_IRQ169		(VBI_IN_EXT_IRQ_BASE + 169)
+#define VBI_IN_EXT_IRQ170		(VBI_IN_EXT_IRQ_BASE + 170)
+#define VBI_IN_EXT_IRQ171		(VBI_IN_EXT_IRQ_BASE + 171)
+#define VBI_IN_EXT_IRQ172		(VBI_IN_EXT_IRQ_BASE + 172)
+#define VBI_IN_EXT_IRQ173		(VBI_IN_EXT_IRQ_BASE + 173)
+#define VBI_IN_EXT_IRQ174		(VBI_IN_EXT_IRQ_BASE + 174)
+#define VBI_IN_EXT_IRQ175		(VBI_IN_EXT_IRQ_BASE + 175)
+#define VBI_IN_EXT_IRQ176		(VBI_IN_EXT_IRQ_BASE + 176)
+#define VBI_IN_EXT_IRQ177		(VBI_IN_EXT_IRQ_BASE + 177)
+#define VBI_IN_EXT_IRQ178		(VBI_IN_EXT_IRQ_BASE + 178)
+#define VBI_IN_EXT_IRQ179		(VBI_IN_EXT_IRQ_BASE + 179)
+#define VBI_IN_EXT_IRQ180		(VBI_IN_EXT_IRQ_BASE + 180)
+#define VBI_IN_EXT_IRQ181		(VBI_IN_EXT_IRQ_BASE + 181)
+#define VBI_IN_EXT_IRQ182		(VBI_IN_EXT_IRQ_BASE + 182)
+#define VBI_IN_EXT_IRQ183		(VBI_IN_EXT_IRQ_BASE + 183)
+#define VBI_IN_EXT_IRQ184		(VBI_IN_EXT_IRQ_BASE + 184)
+#define VBI_IN_EXT_IRQ185		(VBI_IN_EXT_IRQ_BASE + 185)
+#define VBI_IN_EXT_IRQ186		(VBI_IN_EXT_IRQ_BASE + 186)
+#define VBI_IN_EXT_IRQ187		(VBI_IN_EXT_IRQ_BASE + 187)
+#define VBI_IN_EXT_IRQ188		(VBI_IN_EXT_IRQ_BASE + 188)
+#define VBI_IN_EXT_IRQ189		(VBI_IN_EXT_IRQ_BASE + 189)
+#define VBI_IN_EXT_IRQ190		(VBI_IN_EXT_IRQ_BASE + 190)
+#define VBI_IN_EXT_IRQ191		(VBI_IN_EXT_IRQ_BASE + 191)
+#define VBI_IN_EXT_IRQ192		(VBI_IN_EXT_IRQ_BASE + 192)
+#define VBI_IN_EXT_IRQ193		(VBI_IN_EXT_IRQ_BASE + 193)
+#define VBI_IN_EXT_IRQ194		(VBI_IN_EXT_IRQ_BASE + 194)
+#define VBI_IN_EXT_IRQ195		(VBI_IN_EXT_IRQ_BASE + 195)
+#define VBI_IN_EXT_IRQ196		(VBI_IN_EXT_IRQ_BASE + 196)
+#define VBI_IN_EXT_IRQ197		(VBI_IN_EXT_IRQ_BASE + 197)
+#define VBI_IN_EXT_IRQ198		(VBI_IN_EXT_IRQ_BASE + 198)
+#define VBI_IN_EXT_IRQ199		(VBI_IN_EXT_IRQ_BASE + 199)
+#define VBI_IN_EXT_IRQ200		(VBI_IN_EXT_IRQ_BASE + 200)
+#define VBI_IN_EXT_IRQ201		(VBI_IN_EXT_IRQ_BASE + 201)
+#define VBI_IN_EXT_IRQ202		(VBI_IN_EXT_IRQ_BASE + 202)
+#define VBI_IN_EXT_IRQ203		(VBI_IN_EXT_IRQ_BASE + 203)
+#define VBI_IN_EXT_IRQ204		(VBI_IN_EXT_IRQ_BASE + 204)
+#define VBI_IN_EXT_IRQ205		(VBI_IN_EXT_IRQ_BASE + 205)
+#define VBI_IN_EXT_IRQ206		(VBI_IN_EXT_IRQ_BASE + 206)
+#define VBI_IN_EXT_IRQ207		(VBI_IN_EXT_IRQ_BASE + 207)
+#define VBI_IN_EXT_IRQ208		(VBI_IN_EXT_IRQ_BASE + 208)
+#define VBI_IN_EXT_IRQ209		(VBI_IN_EXT_IRQ_BASE + 209)
+#define VBI_IN_EXT_IRQ210		(VBI_IN_EXT_IRQ_BASE + 210)
+#define VBI_IN_EXT_IRQ211		(VBI_IN_EXT_IRQ_BASE + 211)
+#define VBI_IN_EXT_IRQ212		(VBI_IN_EXT_IRQ_BASE + 212)
+#define VBI_IN_EXT_IRQ213		(VBI_IN_EXT_IRQ_BASE + 213)
+#define VBI_IN_EXT_IRQ214		(VBI_IN_EXT_IRQ_BASE + 214)
+#define VBI_IN_EXT_IRQ215		(VBI_IN_EXT_IRQ_BASE + 215)
+#define VBI_IN_EXT_IRQ216		(VBI_IN_EXT_IRQ_BASE + 216)
+#define VBI_IN_EXT_IRQ217		(VBI_IN_EXT_IRQ_BASE + 217)
+#define VBI_IN_EXT_IRQ218		(VBI_IN_EXT_IRQ_BASE + 218)
+#define VBI_IN_EXT_IRQ219		(VBI_IN_EXT_IRQ_BASE + 219)
+#define VBI_IN_EXT_IRQ220		(VBI_IN_EXT_IRQ_BASE + 220)
+#define VBI_IN_EXT_IRQ221		(VBI_IN_EXT_IRQ_BASE + 221)
+#define VBI_IN_EXT_IRQ222		(VBI_IN_EXT_IRQ_BASE + 222)
+#define VBI_IN_EXT_IRQ223		(VBI_IN_EXT_IRQ_BASE + 223)
+
+/* timer vector */
+
+#define VBI_CLOCK_TIMER_VECTOR		0
+#define VBI_IN_APIC_TIMER		(VBI_IN_EXT_IRQ0)
+
+/* XXX this is less than desireable */
+#define IS_GUEST_REG_64(pCtx) (pCtx->arch->
+
+#endif /* _ASM_ARCH_VBI_H */
diff --git a/arch/x86/include/asm/reg_vbi.h b/arch/x86/include/asm/reg_vbi.h
new file mode 100644
index 0000000..4ec4441
--- /dev/null
+++ b/arch/x86/include/asm/reg_vbi.h
@@ -0,0 +1,1875 @@
+/*
+ * x86 regs_vbi.h - x86 cpu registers
+ *
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef __ASM_REG_VBI_H
+#define __ASM_REG_VBI_H
+
+#ifdef CONFIG_64BIT
+#ifndef LP64
+#define LP64
+#endif
+#endif
+
+#define IO_BMAP_SIZE	32	/* IO bitmap for port 0x000 - 0x3ff */
+
+#ifndef _ASMLANGUAGE
+
+#ifdef LP64
+typedef struct			/* REG_SET - x86 register set	*/
+    {
+    _RType   rax;		/* 00: general register		*/
+    _RType   rbx;		/* 08: general register		*/
+    _RType   rcx;		/* 10: general register		*/
+    _RType   rdx;		/* 18: general register		*/
+    _RType   rsp;		/* 20: stack pointer register	*/
+    _RType   rbp;		/* 28: frame pointer register	*/
+    _RType   rsi;		/* 30: general register		*/
+    _RType   rdi;		/* 38: general register		*/
+    _RType   r8;		/* 40: general register		*/
+    _RType   r9;		/* 48: general register		*/
+    _RType   r10;		/* 50: general register		*/
+    _RType   r11;		/* 58: general register		*/
+    _RType   r12;		/* 60: general register		*/
+    _RType   r13;		/* 68: general register		*/
+    _RType   r14;		/* 70: general register		*/
+    _RType   r15;		/* 78: general register		*/
+    INSTR   *pc;		/* 80: program counter		*/
+    _RType   flags;		/* 88: status register		*/
+    _RType   cr0;		/* 90: control register 0	*/
+    _RType   cr2;		/* 98: control register 2	*/
+    _RType   cr3;		/* 100: control register 3	*/
+    _RType   cr4;		/* 108: control register 4	*/
+    uint64_t tsp;		/* 110: transition stack pointer*/
+    uint16_t cs;		/* 118: code segment		*/
+    uint16_t ds;		/* 11A: data segment		*/
+    uint16_t ss;		/* 11C: stack segment		*/
+    uint16_t es;		/* 11E: E segment		*/
+    uint16_t fs;		/* 120: F segment		*/
+    uint16_t gs;		/* 122: G segment		*/
+
+    /* xxx(gws): excluding FP support */
+    } HREG_SET;
+#else
+typedef struct			/* REG_SET - x86 register set	*/
+    {
+    uint32_t  edi;		/* 00: general register		*/
+    uint32_t  esi;		/* 04: general register		*/
+    uint32_t  ebp;		/* 08: frame pointer register	*/
+    uint32_t  esp;		/* 0C: stack pointer register	*/
+    uint32_t  ebx;		/* 10: general register		*/
+    uint32_t  edx;		/* 14: general register		*/
+    uint32_t  ecx;		/* 18: general register		*/
+    uint32_t  eax;		/* 1C: general register		*/
+    uint32_t  flags;		/* 20: status register		*/
+    INSTR    *pc;		/* 24: program counter		*/
+    uint32_t  cr0;		/* 28: control register 0	*/
+    uint32_t  cr2;		/* 2C: control register 2	*/
+    uint32_t  cr3;		/* 30: control register 3	*/
+    uint32_t  cr4;		/* 34: control register 4	*/
+    uint32_t  cs;		/* 28: code segment		*/
+    uint32_t  ds;		/* 3C: data segment		*/
+    uint32_t  ss;		/* 40: stack segment		*/
+    uint32_t  es;		/* 44: E segment		*/
+    uint32_t  fs;		/* 48: F segment		*/
+    uint32_t  gs;		/* 4C: G segment		*/
+    uint32_t  tsp;		/* 50: transition stack pointer	*/
+    } HREG_SET;
+#endif
+
+typedef struct cpuid		/* CPUID - 80x86 cpuid version/feature */
+    {
+    int highestValue;		/* EAX=0: highest integer value */
+    int vendorId[3];		/* EAX=0: vendor identification string */
+    int signature;		/* EAX=1: processor signature */
+    int featuresEbx;		/* EAX=1: feature flags EBX */
+    int featuresEcx;		/* EAX=1: feature flags ECX */
+    int featuresEdx;		/* EAX=1: feature flags EDX */
+    int cacheEax;		/* EAX=2: config parameters EAX */
+    int cacheEbx;		/* EAX=2: config parameters EBX */
+    int cacheEcx;		/* EAX=2: config parameters ECX */
+    int cacheEdx;		/* EAX=2: config parameters EDX */
+    int serialNo64[2];		/* EAX=3: lower 64 of 96 bit serial no */
+    int brandString[12];	/* EAX=0x8000000[234]: brand strings */
+    } CPUID;
+
+
+/* CPUID fields in the EAX register when EAX=1 */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t stepid:4;	/* processor stepping id mask	*/
+	uint32_t model:4;	/* processor model mask		*/
+	uint32_t family:4;	/* processor family mask	*/
+	uint32_t type:2;	/* processor type mask		*/
+	uint32_t reserved1:2;
+	uint32_t modelExt:4;	/* processor extended model mask */
+	uint32_t familyExt:8;	/* processor extended family mask */
+	uint32_t reserved2:4;
+	} field;
+    uint32_t value;
+    } CPUID_VERSION;
+
+#define CPUID_TYPE_ORIG		 0	/* type: original OEM		*/
+#define CPUID_TYPE_OVERD	 1	/* type: overdrive		*/
+#define CPUID_TYPE_DUAL		 2	/* type: dual			*/
+
+#define CPUID_FAMILY_486	 4	/* family: 486			*/
+#define CPUID_FAMILY_PENTIUM	 5	/* family: Pentium		*/
+#define CPUID_FAMILY_PENTIUMPRO  6	/* family: Pentium PRO		*/
+#define CPUID_FAMILY_EXTENDED	15	/* family: Extended		*/
+#define CPUID_FAMILY_PENTIUM4	 0	/* extended family: PENTIUM4	*/
+
+/* Intel family models */
+
+#define CPUID_MODEL_PPRO	 1	/* model: Pentium Pro		*/
+#define CPUID_MODEL_P2_OVER	 2	/* model: Pentium II Overdrive	*/
+#define CPUID_MODEL_P2_03	 3	/* model: Pentium II, model 03	*/
+#define CPUID_MODEL_P2_05	 5	/* model: Pentium II, model 05	*/
+#define CPUID_MODEL_CELERON_06	 6	/* model: Celeron, model 06	*/
+#define CPUID_MODEL_P3_07	 7	/* model: Pentium III, model 07	*/
+#define CPUID_MODEL_P3_08	 8	/* model: Pentium III, model 08	*/
+#define CPUID_MODEL_PENTIUM_M	 9	/* model: Pentium M		*/
+#define CPUID_MODEL_P3_XEON	10	/* model: Pentium III Xeon	*/
+#define CPUID_MODEL_P3_0B	11	/* model: Pentium III, model 0B	*/
+#define CPUID_MODEL_PENTIUMM_0D	13	/* model: Pentium M, model 0D	*/
+#define CPUID_MODEL_CORE	14	/* model: Core Duo/Solo		*/
+#define CPUID_MODEL_CORE2	15	/* model: Core2 Duo/Quad/Xeon	*/
+#define CPUID_MODEL_CORE2_E	23	/* model: Core2 Extreme		*/
+#define CPUID_MODEL_I7		26	/* model: Core i7		*/
+#define CPUID_MODEL_ATOM	28	/* model: Atom			*/
+#define CPUID_MODEL_NEHALEM1	30	/* model: Core Architecture	*/
+#define CPUID_MODEL_NEHALEM2	32	/* model: Core Architecture	*/
+#define CPUID_MODEL_NEHALEM3	46	/* model: Core Architecture	*/
+#define CPUID_MODEL_WESTMERE1	37	/* model: next generation	*/
+#define CPUID_MODEL_WESTMERE2	44	/* model: next generation	*/
+
+
+/* CPUID fields in the EBX register when EAX=1 */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t brand:8;	/* Brand index			*/
+	uint32_t flushSize:8;	/* CLFLUSH line size		*/
+	uint32_t nproc:8;	/* number of local processors	*/
+	uint32_t apicId:8;	/* local APIC id		*/
+	} field;
+    uint32_t value;
+    } CPUID_INFO;
+
+/* CPUID fields in the EDX register when EAX=1 */
+
+/* CPUID: feature bit definitions */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t fpu:1;		/* FPU on chip			*/
+	uint32_t vme:1;		/* virtual 8086 mode enhancement*/
+	uint32_t de:1;		/* debugging extensions		*/
+	uint32_t pse:1;		/* page size extension		*/
+	uint32_t tsc:1;		/* time stamp counter		*/
+	uint32_t msr:1;		/* RDMSR and WRMSR support	*/
+	uint32_t pae:1;		/* physical address extensions	*/
+	uint32_t mce:1;		/* machine check exception	*/
+	uint32_t cx8:1;		/* CMPXCHG8 inst		*/
+	uint32_t apic:1;	/* APIC on chip			*/
+	uint32_t reserved1:1;
+	uint32_t sep:1;		/* SEP, Fast System Call	*/
+	uint32_t mtrr:1;	/* MTRR				*/
+	uint32_t pge:1;		/* PTE global bit		*/
+	uint32_t mca:1;		/* machine check arch.		*/
+	uint32_t cmov:1;	/* cond. move/cmp. inst		*/
+	uint32_t pat:1;		/* page attribute table		*/
+	uint32_t pse36:1;	/* 36 bit page size extension	*/
+	uint32_t psnum:1;	/* processor serial number	*/
+	uint32_t clflush:1;	/* CLFLUSH inst supported	*/
+	uint32_t reserved2:1;
+	uint32_t dts:1;		/* Debug Store			*/
+	uint32_t acpi:1;	/* TM and SCC supported		*/
+	uint32_t mmx:1;		/* MMX technology supported	*/
+	uint32_t fxsr:1;	/* fast FP save and restore	*/
+	uint32_t sse:1;		/* SSE supported		*/
+	uint32_t sse2:1;	/* SSE2 supported		*/
+	uint32_t ss:1;		/* Self Snoop supported		*/
+	uint32_t htt:1;		/* Hyper Threading Technology   */
+	uint32_t tm:1;		/* Thermal Monitor supported	*/
+	uint32_t ia64:1;	/* IA64 Capabilities		*/
+	uint32_t pbe:1;		/* Pend break enable		*/
+	} field;
+    uint32_t value;
+    } CPUID_FEATURES;
+
+
+/* fields in the ECX register when EAX=1 */
+
+/* CPUID: extended feature bit definitions */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t sse3:1;	/* SSE3 Extensions		*/
+	uint32_t reserved1:1;
+	uint32_t dtes64:1;	/* 64-bit Debug Store		*/
+	uint32_t mon:1;		/* Monitor/wait			*/
+	uint32_t ds_cpl:1;	/* CPL qualified Debug Store	*/
+	uint32_t vmx:1;		/* Virtual Machine Technology	*/
+	uint32_t smx:1;		/* Safer Mode Extensions	*/
+	uint32_t est:1;		/* Enhanced Speedstep Technology*/
+	uint32_t tm2:1;		/* Thermal Monitor 2 supported	*/
+	uint32_t ssse3:1;	/* SSSE3 Extensions		*/
+	uint32_t cid:1;		/* L1 context ID		*/
+	uint32_t reserved2:2;
+	uint32_t cx16:1;	/* CMPXCHG16B			*/
+	uint32_t xtpr:1;	/* Update control		*/
+	uint32_t pdcm:1;	/* Performance/Debug capability	*/
+	uint32_t reserved3:2;
+	uint32_t dca:1;		/* Direct Cache Access		*/
+	uint32_t sse41:1;	/* SIMD Extensions 4.1		*/
+	uint32_t sse42:1;	/* SIMD Extensions 4.2		*/
+	uint32_t x2apic:1;	/* x2APIC supported		*/
+	uint32_t movbe:1;	/* MOVBE instruction supported	*/
+	uint32_t popcnt:1;	/* POPCNT instruction supported	*/
+	uint32_t reserved4:1;
+	uint32_t aes:1;		/* AES instruction supported	*/
+	uint32_t xsave:1;	/* XSAVE states supported	*/
+	uint32_t osxsave:1;	/* extended state management	*/
+	uint32_t reserved5:4;
+	} field;
+    uint32_t value;
+    } CPUID_FEATURES_EXT;
+
+/* fields in the EDX register when EAX=0x80000001 */
+typedef union
+    {
+    struct
+	{
+	uint32_t reserved1:11;
+	uint32_t syscall:1;	/* SYSCALL/SYSRET instructions */
+	uint32_t reserved2:7;
+	uint32_t mp:1;		/* Multi-processor capable */
+	uint32_t nx:1;		/* Execute disable */
+	uint32_t reserved3:1;
+	uint32_t amdmmx:1;	/* AMD MMX extensions */
+	uint32_t reserved4:2;
+	uint32_t fxsave_opt:1;	/* FXSAVE/FXRSTOR optimizations */
+	uint32_t gbpage:1;	/* Gigabyte page support */
+	uint32_t rdtscp:1;	/* RDTSCP support */
+	uint32_t reserved5:1;
+	uint32_t lm:1;		/* Long mode em64t */
+	uint32_t amd3dnow2:1;	/* AMD 3DNow! extensions */
+	uint32_t amd3dnow:1;	/* AMD 3DNow! extensions */
+	} field;
+    uint32_t value;
+    } CPUID_80000001_EDX;
+
+/* fields in the EAX/EBX/ECX/EDX register when EAX=4 */
+
+/* CPUID: deterministic cache parameters definitions */
+
+typedef union
+    {
+    struct
+	{
+	/* EAX */
+
+	uint32_t type:5;	/* Cache type			*/
+	uint32_t level:3;	/* Cache level			*/
+	uint32_t self_init:1;	/* Self initialising cache	*/
+	uint32_t associative:1;	/* Fully associate cache	*/
+	uint32_t reserved1:4;
+	uint32_t threads:12;	/* Max threads sharing cache	*/
+	uint32_t proc:6;	/* Max processor cores per pkg	*/
+
+	/* EBX */
+
+	uint32_t cline_size:12;	/* Coherency line size		*/
+	uint32_t pline_size:10;	/* Physical line size		*/
+	uint32_t way:10;	/* Ways of associativity	*/
+
+	/* ECX */
+
+	uint32_t sets:32;	/* Number of sets		*/
+
+	/* EDX */
+
+	uint32_t stride:10;	/* Prefetch stride		*/
+	uint32_t reserved2:22;
+
+	} field;
+    struct
+	{
+	uint32_t eax;
+	uint32_t ebx;
+	uint32_t ecx;
+	uint32_t edx;
+	} value;
+    } CPUID_CACHE;
+
+/* CPUID cache types */
+
+#define CPUID_CACHE_TYPE_NULL		0
+#define CPUID_CACHE_TYPE_DATA		1
+#define CPUID_CACHE_TYPE_INSTR		2
+#define CPUID_CACHE_TYPE_UNIFIED	3
+
+/* fields in the EAX/EBX/ECX/EDX register when EAX=11 */
+
+/* CPUID: x2APIC features / processor topology parameter definitions */
+
+typedef union
+    {
+    struct
+	{
+	/* EAX */
+
+	uint32_t apic_r_shift:5; /* number of bits to shift right */
+	uint32_t reserved1:27;
+
+	/* EBX */
+
+	uint32_t logical_proc:16; /* number of logical processor  */
+	uint32_t reserved2:16;
+
+	/* ECX */
+
+	uint32_t level:8;	 /* level number		   */
+	uint32_t type:8;	 /* level type			   */
+	uint32_t reserved3:16;
+
+	/* EDX */
+
+	uint32_t ext_apic_id;	/* extended APIC id		    */
+
+	} field;
+    struct
+	{
+	uint32_t eax;
+	uint32_t ebx;
+	uint32_t ecx;
+	uint32_t edx;
+	} value;
+    } CPUID_X2APIC;
+
+/* MSR_VMX_EPT_VPID_CAP: EPT and VPID Capabilities MSR */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t rwx_support:3;	/* R W X support	*/
+	uint32_t gaw_support:5;	/* GAW support		*/
+	uint32_t emt_support:8;	/* EMT support		*/
+	uint32_t sp_support:4;	/* SP support		*/
+	uint32_t invept:1;	/* INVEPT supported	*/
+	uint32_t reserved1:3;
+	uint32_t invept_cap:8;	/* INVEPT capabilities	*/
+	uint32_t invpid:1;	/* INVPID supported	*/
+	uint32_t reserved2:7;
+	uint32_t invpid_cap:8;	/* INVPID capabilities	*/
+	uint32_t reserved3:16;
+	} field;
+    uint64_t value;
+    } EPT_VPID_CAP_MSR;
+
+typedef struct mtrr_fix		/* MTRR - fixed range register */
+    {
+    char type[8];
+    } MTRR_FIX;
+
+typedef struct mtrr_var		/* MTRR - variable range register */
+    {
+    long long int base;
+    long long int mask;
+    } MTRR_VAR;
+
+typedef struct mtrr		/* MTRR */
+    {
+    int cap[2];			/* MTRR cap register */
+    int deftype[2];		/* MTRR defType register */
+    MTRR_FIX fix[11];		/* MTRR fixed range registers */
+    MTRR_VAR var[8];		/* MTRR variable range registers */
+    } MTRR;
+
+typedef MTRR *		MTRR_ID;
+
+/* PLATFORM_INFO MSR fields */
+
+typedef union
+    {
+    struct
+	{
+	uint64_t reserved1:8;
+	uint64_t ratio_max:8;	/* maximum non-turbo TSC ratio	*/
+	uint64_t reserved2:24;
+	uint64_t ratio_min:8;	/* minimum non-turbo TSC ratio	*/
+	uint64_t reserved3:16;
+	} field;
+    uint64_t value;
+    } PLATFORM_INFO;
+
+/* MSR_FLEX_RATIO MSR fields */
+
+typedef union
+    {
+    struct
+	{
+	uint64_t reserved1:8;
+	uint64_t ratio:8;	/* current non-turbo TSC ratio	*/
+	uint64_t enabled:1;	/* flex ratio enabled		*/
+	uint64_t reserved2:47;
+	} field;
+    uint64_t value;
+    } FLEX_RATIO;
+
+/*
+ * Structure of a global descriptor table (GDT) entry
+ * (common to 32 & 64 bits)
+ */
+
+typedef struct gdt_entry
+    {
+    uint16_t	limit00;	/* limit: xffff			*/
+    uint16_t	base00;		/* base : xxxx0000		*/
+    uint8_t	base01;		/* base : xx00xxxx		*/
+    uint8_t	type:4;		/* Code e/r,			*/
+    uint8_t	sys:1;		/* 0 = system segment		*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint8_t	limit01:4;	/* limit: fxxxx			*/
+    uint8_t	free:1;		/* free bit			*/
+    uint8_t	l:1;		/* 64-bit code segment		*/
+    uint8_t	d_b:1;		/* access 0=16-bit 1=32-bit	*/
+    uint8_t	g:1;		/* page granularity		*/
+    uint8_t	base02;		/* base : 00xxxxxx		*/
+    } GDT_ENTRY;
+
+/* Structure of global descriptor table call entry in 32-bits mode */
+
+typedef struct gdt32_call_entry
+    {
+    uint16_t	offset00;	/* offset: xxxxffff		*/
+    uint16_t	segment;	/* segment selector		*/
+    uint8_t	nparam:5;	/* number of parameters		*/
+    uint8_t	res1:3;		/* reserved (zeroes)		*/
+    uint8_t	type:4;		/* Code e/r,			*/
+    uint8_t	sys:1;		/* 0 = system segment		*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint16_t	offset01;	/* offset: ffffxxxx		*/
+    } GDT32_CALL_ENTRY;
+
+/* Structure of interrupt descriptor table (IDT) entry in 32-bits mode */
+
+typedef struct idt32_entry
+    {
+    uint16_t	offset00;	/* offset : xxxxffff		*/
+    uint16_t	segment;	/* segment selector		*/
+    uint8_t	res1;		/* reserved (zeroes) */
+    uint8_t	type:5;		/* Code e/r,			*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint16_t	offset01;	/* offset: ffffxxxx		*/
+    } IDT32_ENTRY;
+
+#ifdef	LP64
+/* Structure of global descriptor table call entry in 64-bits mode */
+
+typedef struct gdt64_call_entry
+    {
+    uint16_t	offset00;	/* offset: xxxxxxxxxxxxffff	*/
+    uint16_t	segment;	/* segment selector		*/
+    uint8_t	res1;		/* reserved (zeroes)		*/
+    uint8_t	type:4;		/* Code e/r,			*/
+    uint8_t	sys:1;		/* 0 = system segment		*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint16_t	offset01;	/* offset: xxxxxxxxffffxxxx	*/
+    uint32_t	offset02;	/* offset: ffffffffxxxxxxxx	*/
+    uint32_t	res3;		/* reserved */
+    } GDT64_CALL_ENTRY;
+
+/* Structure of interrupt descriptor table (IDT) entry in 64-bits mode */
+
+typedef struct idt64_entry
+    {
+    uint16_t	offset00;	/* offset: xxxxxxxxxxxxffff	*/
+    uint16_t	segment;	/* segment selector		*/
+    uint8_t	ist:3;		/* interrupt stack table	*/
+    uint8_t	res1:5;		/* reserved (zeroes)		*/
+    uint8_t	type:4;		/* Code e/r,			*/
+    uint8_t	res2:1;		/* reserved (zeroes)		*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint16_t	offset01;	/* offset: xxxxxxxxffffxxxx	*/
+    uint32_t	offset02;	/* offset: ffffffffxxxxxxxx	*/
+    uint32_t	res3;		/* reserved */
+    } IDT64_ENTRY;
+
+#define GDT_CALL_ENTRY		GDT64_CALL_ENTRY
+#define IDT_ENTRY		IDT64_ENTRY
+#else
+#define GDT_CALL_ENTRY		GDT32_CALL_ENTRY
+#define IDT_ENTRY		IDT32_ENTRY
+#endif	/* LP64 */
+
+
+#define GDT_BASE00_SHIFT	00
+#define GDT_BASE01_SHIFT	16
+#define GDT_BASE02_SHIFT	24
+#define GDT_BASE00_MASK		0x0000ffff
+#define GDT_BASE01_MASK		0x00ff0000
+#define GDT_BASE02_MASK		0xff000000
+
+#define GDT_LIMIT00_SHIFT	00
+#define GDT_LIMIT01_SHIFT	16
+#define GDT_LIMIT00_MASK	0x0ffff
+#define GDT_LIMIT01_MASK	0xf0000
+
+#define GDT_BASE(p)	((p->base02 << GDT_BASE02_SHIFT) | \
+			 (p->base01 << GDT_BASE01_SHIFT) | p->base00)
+#define GDT_LIMIT(p)	((p->limit01 << GDT_LIMIT01_SHIFT) | p->limit00)
+
+#define GDT_LIMIT00(v)	(((v) & GDT_LIMIT00_MASK) >> GDT_LIMIT00_SHIFT)
+#define GDT_LIMIT01(v)	(((v) & GDT_LIMIT01_MASK) >> GDT_LIMIT01_SHIFT)
+
+#define GDT_BASE00(v)	(((v) & GDT_BASE00_MASK) >> GDT_BASE00_SHIFT)
+#define GDT_BASE01(v)	(((v) & GDT_BASE01_MASK) >> GDT_BASE01_SHIFT)
+#define GDT_BASE02(v)	(((v) & GDT_BASE02_MASK) >> GDT_BASE02_SHIFT)
+
+/* GDT call entry macros */
+
+#define GDT32_OFFSET00_SHIFT	00
+#define GDT32_OFFSET01_SHIFT	16
+#define GDT32_OFFSET00_MASK	0x0000ffff
+#define GDT32_OFFSET01_MASK	0xffff0000
+
+#define GDT32_OFFSET(p)		((p->offset01 << GDT32_OFFSET01_SHIFT) | \
+				 p->offset00)
+#define GDT32_OFFSET00(v)	(((v) & GDT32_OFFSET00_MASK) >> \
+				 GDT32_OFFSET00_SHIFT)
+#define GDT32_OFFSET01(v)	(((v) & GDT32_OFFSET01_MASK) >> \
+				 GDT32_OFFSET01_SHIFT)
+
+#ifdef	LP64
+#define GDT64_OFFSET00_SHIFT	00
+#define GDT64_OFFSET01_SHIFT	16
+#define GDT64_OFFSET02_SHIFT	32
+#define GDT64_OFFSET00_MASK	0x000000000000ffff
+#define GDT64_OFFSET01_MASK	0x00000000ffff0000
+
+#define GDT64_OFFSET(p)		((((uint64_t) p->offset02) << \
+					GDT64_OFFSET02_SHIFT) | \
+				 (p->offset01 << GDT64_OFFSET01_SHIFT) | \
+				 p->offset00)
+#define GDT64_OFFSET00(v)	((uint16_t)((((v) & GDT64_OFFSET00_MASK) >> \
+					    GDT64_OFFSET00_SHIFT)))
+#define GDT64_OFFSET01(v)	((uint16_t)((((v) & GDT64_OFFSET01_MASK) >> \
+					    GDT64_OFFSET01_SHIFT)))
+#define GDT64_OFFSET02(v)	((uint32_t)(((v) >> GDT64_OFFSET02_SHIFT)))
+
+#define GDT_OFFSET		GDT64_OFFSET
+#define GDT_OFFSET00		GDT64_OFFSET00
+#define GDT_OFFSET01		GDT64_OFFSET01
+#define GDT_OFFSET02		GDT64_OFFSET02
+#else	/* LP64 */
+#define GDT_OFFSET		GDT32_OFFSET
+#define GDT_OFFSET00		GDT32_OFFSET00
+#define GDT_OFFSET01		GDT32_OFFSET01
+#endif
+
+/* IDT aliases */
+
+#define IDT32_OFFSET(x)		GDT32_OFFSET(x)
+#define IDT32_OFFSET00(x)	GDT32_OFFSET00(x)
+#define IDT32_OFFSET01(x)	GDT32_OFFSET01(x)
+
+#ifdef	LP64
+#define IDT64_OFFSET(x)		GDT64_OFFSET(x)
+#define IDT64_OFFSET00(x)	GDT64_OFFSET00(x)
+#define IDT64_OFFSET01(x)	GDT64_OFFSET01(x)
+#define IDT64_OFFSET02(x)	GDT64_OFFSET02(x)
+
+#define IDT_OFFSET		IDT64_OFFSET
+#define IDT_OFFSET00		IDT64_OFFSET00
+#define IDT_OFFSET01		IDT64_OFFSET01
+#define IDT_OFFSET02		IDT64_OFFSET02
+#else	/* LP64 */
+#define IDT_OFFSET		IDT32_OFFSET
+#define IDT_OFFSET00		IDT32_OFFSET00
+#define IDT_OFFSET01		IDT32_OFFSET01
+#define IDT_OFFSET02		IDT32_OFFSET02
+#endif	/* LP64 */
+
+/* GDT data segment types */
+
+#define GDT_TYPE_RO		0	/* read-only			   */
+#define GDT_TYPE_RO_A		1	/* read-only accessed		   */
+#define GDT_TYPE_RW		2	/* read-write			   */
+#define GDT_TYPE_RW_A		3	/* read-write accessed		   */
+#define GDT_TYPE_RO_DOWN	4	/* read-only expand-down	   */
+#define GDT_TYPE_RO_DOWN_A	5	/* read-only expand-down accessed  */
+#define GDT_TYPE_RW_DOWN	6	/* read-write expand-down	   */
+#define GDT_TYPE_RW_DOWN_A	7	/* read-write expand-down accessed */
+#define GDT_TYPE_EX		8	/* execute			   */
+#define GDT_TYPE_EX_A		9	/* execute accessed		   */
+#define GDT_TYPE_EX_RO		10	/* execute read-only		   */
+#define GDT_TYPE_EX_RO_A	11	/* execute read-only accessed	   */
+#define GDT_TYPE_EX_CF		12	/* execute conforming		   */
+#define GDT_TYPE_EX_CF_A	13	/* execute conforming accessed	   */
+#define GDT_TYPE_EX_RO_CF	14	/* execute read-only conforming	   */
+#define GDT_TYPE_EX_RO_CF_A	15	/* execute r/o conforming accessed */
+
+/* GDT system segment types */
+
+#ifndef LP64
+#define GDT_TYPE_SYS_RES0	0	/* reserved			   */
+#define GDT_TYPE_SYS_TSS16_A	1	/* 16-bit TSS (available)	   */
+#define GDT_TYPE_SYS_LDT	2	/* local descriptor table	   */
+#define GDT_TYPE_SYS_TSS16_B	3	/* 16-bit TSS (busy)		   */
+#define GDT_TYPE_SYS_CALL16	4	/* 16-bit call gate		   */
+#define GDT_TYPE_SYS_TGATE	5	/* task gate			   */
+#define GDT_TYPE_SYS_IGATE16	6	/* 16-bit interrupt gate	   */
+#define GDT_TYPE_SYS_TGATE16	7	/* 16-bit trap gate		   */
+#define GDT_TYPE_SYS_RES1	8	/* reserved			   */
+#define GDT_TYPE_SYS_TSS32_A	9	/* 32-bit TSS (available)	   */
+#define GDT_TYPE_SYS_RES2	10	/* reserved			   */
+#define GDT_TYPE_SYS_TSS32_B	11	/* 32-bit TSS (busy)		   */
+#define GDT_TYPE_SYS_CALL32	12	/* 32-bit call gate		   */
+#define GDT_TYPE_SYS_RES3	13	/* reserved			   */
+#define GDT_TYPE_SYS_IGATE32	14	/* 32-bit interrupt gate	   */
+#define GDT_TYPE_SYS_TGATE32	15	/* 32-bit trap gate		   */
+#else	/* !LP64 */
+#define GDT32_TYPE_SYS_TSS16_A	1	/* 16-bit TSS (available)	   */
+#define GDT32_TYPE_SYS_LDT	2	/* local descriptor table	   */
+#define GDT32_TYPE_SYS_TSS16_B	3	/* 16-bit TSS (busy)		   */
+#define GDT32_TYPE_SYS_CALL16	4	/* 16-bit call gate		   */
+#define GDT32_TYPE_SYS_TGATE	5	/* task gate			   */
+#define GDT32_TYPE_SYS_IGATE16	6	/* 16-bit interrupt gate	   */
+#define GDT32_TYPE_SYS_TGATE16	7	/* 16-bit trap gate		   */
+#define GDT32_TYPE_SYS_TSS32_A	9	/* 32-bit TSS (available)	   */
+#define GDT32_TYPE_SYS_TSS32_B	11	/* 32-bit TSS (busy)		   */
+#define GDT32_TYPE_SYS_CALL32	12	/* 32-bit call gate		   */
+#define GDT32_TYPE_SYS_IGATE32	14	/* 32-bit interrupt gate	   */
+#define GDT32_TYPE_SYS_TGATE32	15	/* 32-bit trap gate		   */
+
+#define GDT_TYPE_SYS_LDT	2	/* local descriptor table	   */
+#define GDT_TYPE_SYS_TSS64_A	9	/* 64 bit TSS (available)	   */
+#define GDT_TYPE_SYS_TSS64_B	11	/* 64 bit TSS (busy)	           */
+#define GDT_TYPE_SYS_CALL64	12	/* 64-bit call gate		   */
+#define GDT_TYPE_SYS_IGATE64	14	/* 64-bit interrupt gate	   */
+#define GDT_TYPE_SYS_TGATE63	15	/* 64-bit trap gate		   */
+#endif	/* !LP64 */
+/* GDT segment status */
+
+#define GDT_SEG_INVALID		0	/* segment is not present	   */
+#define GDT_SEG_VALID		1	/* segment is present		   */
+
+/* GDT segment type */
+
+#define GDT_SEG_SYSTEM		0	/* system type segment		   */
+#define GDT_SEG_CODE_DATA	1	/* code/data type segment	   */
+
+/* GDT access types */
+
+#define GDT_ACCESS_16		0	/* 16-bit access to memory	   */
+#define GDT_ACCESS_32		1	/* 32-bit access to memory	   */
+
+/* GDT access types */
+
+#define GDT_GRAN_BYTE		0	/* byte size page granularity	   */
+#define GDT_GRAN_4KB_PAGE	1	/* 4KB size page granularity	   */
+
+/* GDT access types */
+
+#define GDT_64_CODE_SEGMENT	1	/* 64-bit code segment		   */
+#define GDT_COMP_CODE_SEGMENT	0	/* compatible mode code segment	   */
+
+/* GDT privilidge level */
+
+#define GDT_PRIV_RING_0		0	/* ring 0 priv level		   */
+#define GDT_PRIV_RING_1		1	/* ring 1 priv level		   */
+#define GDT_PRIV_RING_2		2	/* ring 2 priv level		   */
+#define GDT_PRIV_RING_3		3	/* ring 3 priv level		   */
+
+/* IDT segment types */
+
+#define IDT_TYPE_RES0		0	/* reserved			   */
+#define IDT_TYPE_RES1		1	/* reserved			   */
+#define IDT_TYPE_RES2		2	/* reserved			   */
+#define IDT_TYPE_RES3		3	/* reserved			   */
+#define IDT_TYPE_RES4		4	/* reserved			   */
+#define IDT_TYPE_TGATE		5	/* task gate			   */
+#define IDT_TYPE_IGATE_16	6	/* 16-bit interrupt gate	   */
+#define IDT_TYPE_TRGATE_16	7	/* 16-bit trap gate		   */
+#define IDT_TYPE_RES8		8	/* reserved			   */
+#define IDT_TYPE_RES9		9	/* reserved			   */
+#define IDT_TYPE_RES10		10	/* reserved			   */
+#define IDT_TYPE_RES11		11	/* reserved			   */
+#define IDT_TYPE_RES12		12	/* reserved			   */
+#define IDT_TYPE_RES13		13	/* reserved			   */
+#define IDT_TYPE_IGATE		14	/* 32-bit interrupt gate	   */
+#define IDT_TYPE_TRGATE		15	/* 32-bit trap gate		   */
+
+/* IDT segment status */
+
+#define IDT_SEG_INVALID		0	/* segment is not present	   */
+#define IDT_SEG_VALID		1	/* segment is present		   */
+
+/* IDT segment type */
+
+#define IDT_SEG_SYSTEM		0	/* system type segment		   */
+#define IDT_SEG_CODE_DATA	1	/* code/data type segment	   */
+
+/* IDT access types */
+
+#define IDT_ACCESS_16		0	/* 16-bit access to memory	   */
+#define IDT_ACCESS_32		1	/* 32-bit access to memory	   */
+
+/* IDT access types */
+
+#define IDT_GRAN_BYTE		0	/* byte size page granularity	   */
+#define IDT_GRAN_4KB_PAGE	1	/* 4KB size page granularity	   */
+
+/* IDT privilidge level */
+
+#define IDT_PRIV_RING_0		0	/* ring 0 priv level		   */
+#define IDT_PRIV_RING_1		1	/* ring 2 priv level		   */
+#define IDT_PRIV_RING_2		2	/* ring 2 priv level		   */
+#define IDT_PRIV_RING_3		3	/* ring 3 priv level		   */
+
+/* structure of the system descriptor table registers (GDTR, IDTR, LDTR) */
+
+struct XDTR
+{
+	uint16_t limit;		/* maximum size of the DT */
+	size_t   base;		/* address of DT */
+	uint16_t pad;
+} __attribute__((packed));
+
+
+struct XDTR32
+{
+	uint16_t limit;
+	uint32_t base;
+	uint16_t pad;
+} __attribute__((packed));
+
+typedef struct XDTR GDTR;
+typedef struct XDTR IDTR;
+typedef struct XDTR LDTR;
+
+typedef struct XDTR32 GDTR32;
+typedef struct XDTR32 IDTR32;
+typedef struct XDTR32 LDTR32;
+
+#define	XDTR_ADDR(reg)	(reg.base)
+#define	XDTR_LIMIT(reg)	(reg.limit)
+
+#define GDTR_ADDR(reg)	XDTR_ADDR(reg)
+#define GDTR_LIMIT(reg)	XDTR_LIMIT(reg)
+#define IDTR_ADDR(reg)	XDTR_ADDR(reg)
+#define IDTR_LIMIT(reg)	XDTR_LIMIT(reg)
+#define LDTR_ADDR(reg)	XDTR_ADDR(reg)
+#define LDTR_LIMIT(reg)	XDTR_LIMIT(reg)
+
+/* x86 Task State Segment (TSS) */
+
+typedef struct tss
+    {
+#ifdef LP64
+    uint32_t  reserved0;	/* reserved */
+    uint64_t  rsp0;		/* privilege level 0 SP */
+    uint64_t  rsp1;		/* privilege level 1 SP */
+    uint64_t  rsp2;		/* privilege level 2 SP */
+    uint64_t  reserved1;	/* reserved */
+    uint64_t  ist1;		/* interrupt stack table ptr */
+    uint64_t  ist2;		/* interrupt stack table ptr */
+    uint64_t  ist3;		/* interrupt stack table ptr */
+    uint64_t  ist4;		/* interrupt stack table ptr */
+    uint64_t  ist5;		/* interrupt stack table ptr */
+    uint64_t  ist6;		/* interrupt stack table ptr */
+    uint64_t  ist7;		/* interrupt stack table ptr */
+    uint64_t  reserved2;	/* reserved */
+    uint16_t  reserved3;	/* reserved */
+    uint16_t  iomapb;		/* IO map base offset */
+    uint32_t  iobmap[IO_BMAP_SIZE + 1];
+#else
+    uint16_t  link;		/* link to previous task */
+    uint16_t  reserved0;	/* reserved */
+    uint32_t  esp0;		/* privilege level 0 SP */
+    uint16_t  ss0;		/*   ''              SS */
+    uint16_t  reserved1;	/* reserved */
+    uint32_t  esp1;		/* privilege level 1 SP */
+    uint16_t  ss1;		/*   ''              SS */
+    uint16_t  reserved3;	/* reserved */
+    uint32_t  esp2;		/* privilege level 2 SP */
+    uint16_t  ss2;		/*   ''              SS */
+    uint16_t  reserved4;	/* reserved */
+    uint32_t  cr3;		/* control register CR3 */
+    INSTR    *eip;		/* program counter  EIP */
+    uint32_t  eflags;		/* status register  EFLAGS */
+    uint32_t  eax;		/* general register EAX */
+    uint32_t  ecx;		/* general register ECX */
+    uint32_t  edx;		/* general register EDX */
+    uint32_t  ebx;		/* general register EBX */
+    uint32_t  esp;		/* stack pointer register ESP */
+    uint32_t  ebp;		/* frame pointer register EBP */
+    uint32_t  esi;		/* general register ESI */
+    uint32_t  edi;		/* general register EDI */
+    uint16_t  es;		/* segment selector ES */
+    uint16_t  reserved5;	/* reserved */
+    uint16_t  cs;		/* segment selector CS */
+    uint16_t  reserved6;	/* reserved */
+    uint16_t  ss;		/* segment selector SS */
+    uint16_t  reserved7;	/* reserved */
+    uint16_t  ds;		/* segment selector DS */
+    uint16_t  reserved8;	/* reserved */
+    uint16_t  fs;		/* segment selector FS */
+    uint16_t  reserved9;	/* reserved */
+    uint16_t  gs;		/* segment selector GS */
+    uint16_t  reserved10;	/* reserved */
+    uint16_t  ldt;		/* segment selector LDT */
+    uint16_t  reserved11;	/* reserved */
+    uint16_t  tflag;		/* debug trap flag T */
+    uint16_t  iomapb;		/* IO map base address */
+    uint32_t  iobmap[IO_BMAP_SIZE + 1];
+    uint32_t  reserved12;	/* TSS selector */
+    uint32_t  reserved13;
+    uint32_t  reserved14;
+    uint32_t  reserved15;
+    uint32_t  reserved16;
+    uint32_t  reserved17;
+    uint32_t  reserved18;
+    uint32_t  reserved19;
+#endif
+    } TSS;
+
+typedef struct segdesc		/* segment descriptor */
+    {
+    uint16_t	limitLW;	/* limit 15:00			*/
+    uint16_t	baseLW;		/* base address 15:00		*/
+    uint8_t	baseMB;		/* base address 23:16		*/
+    uint8_t	type;		/* P, DPL, S, Type		*/
+    uint8_t	limitUB;	/* G, DB, 0, AVL, limit 23:16	*/
+    uint8_t	baseUB;		/* base address 31:24		*/
+    } SEGDESC;
+
+typedef struct taskGate		/* task gate */
+    {
+    uint16_t    reserved1;	/* reserved1 15:00		*/
+    uint16_t    segment;	/* TSS segment selector 31:16	*/
+    uint16_t	reserved2:8;	/* reserved2 07:00		*/
+    uint8_t	type:5;		/* Type 12:08			*/
+    uint8_t	dpl:2;		/* DPL 14:13			*/
+    uint8_t	p:1;		/* present 15:15		*/
+    uint16_t    reserved3;      /* reserved3 31:16		*/
+    } TGATE_DESC;
+
+typedef struct callGate		/* call gate */
+    {
+    uint16_t	offsetLo;
+    uint16_t	selector;
+    uint8_t	params;
+    uint8_t	type;
+    uint16_t	offsetHi;
+   } CGATE_DESC;
+
+typedef struct intGate		/* interrupt gate */
+    {
+    uint16_t    offsetLo;	/* offset 15:00			*/
+    uint16_t    segment;	/* segment selector 31:16	*/
+    uint8_t	reserved:5;	/* reserved2 04:00		*/
+    uint8_t	zero:3;		/* zeros 07:05			*/
+    uint8_t	type:5;		/* type 12:08			*/
+    uint8_t	dpl:2;		/* DPL 14:13			*/
+    uint8_t	p:1;		/* present 15:15		*/
+    uint16_t    offsetHi;	/* offset 31:16			*/
+    } IGATE_DESC;
+
+#define IGATE_OFFSET00_SHIFT	00
+#define IGATE_OFFSET01_SHIFT	16
+#define IGATE_OFFSET(p)	((p->offsetHi << IGATE_OFFSET01_SHIFT) | p->offsetLo)
+
+
+typedef struct trapGate		/* trap gate */
+    {
+    uint16_t    offsetLo;	/* offset 15:00			*/
+    uint16_t    segment;	/* segment selector 31:16	*/
+    uint8_t	reserved:5;	/* reserved2 04:00		*/
+    uint8_t	zero:3;		/* zeros 07:05			*/
+    uint8_t	type:5;		/* type 12:08			*/
+    uint8_t	dpl:2;		/* DPL 14:13			*/
+    uint8_t	p:1;		/* present 15:15		*/
+    uint16_t    offsetHi;	/* offset 31:16			*/
+    } TRGATE_DESC;
+
+#define TRGATE_OFFSET00_SHIFT	00
+#define TRGATE_OFFSET01_SHIFT	16
+#define TRGATE_OFFSET(p) ((p->offsetHi << TRGATE_OFFSET01_SHIFT) | p->offsetLo)
+
+/* convenience structure to access 32-bit fields of a 64-bit MSR */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t low;		/* low 32-bits of value */
+	uint32_t high;		/* high 32-bits of value */
+	} field;
+    uint64_t word;		/* 64-bit MSR value */
+    } MSR_VALUE;
+
+/* some common names for registers */
+
+#define fpReg		ebp	/* frame pointer */
+#define spReg		esp	/* stack pointer */
+#define reg_pc		pc	/* program counter */
+#define reg_sp		spReg	/* stack pointer */
+#define reg_fp		fpReg	/* frame pointer */
+
+#define  G_REG_BASE	0x00	/* data reg's base offset to HREG_SET */
+#define  G_REG_OFFSET(n)	(G_REG_BASE + (n)*sizeof(uint32_t))
+#define  SR_OFFSET		G_REG_OFFSET(GREG_NUM)
+#define  PC_OFFSET		(SR_OFFSET + sizeof(uint32_t))
+
+/* register access functions */
+
+extern _RType	x86CR0Get (void);
+extern void	x86CR0Set (_RType value);
+extern _RType	x86CR2Get (void);
+extern void	x86CR2Set (_RType value);
+extern _RType	x86CR3Get (void);
+extern void	x86CR3Set (_RType value);
+extern _RType	x86CR4Get (void);
+extern void	x86CR4Set (_RType value);
+extern void	x86GdtrGet (GDTR *value);
+extern void	x86GdtrSet (GDTR *value);
+extern void	x86IdtrGet (IDTR *value);
+extern void	x86IdtrSet (IDTR *value);
+extern void	x86LdtrGet (LDTR *value);
+extern void	x86LdtrSet (LDTR *value);
+extern _RType	x86TrGet (void);
+extern void	x86TrSet (_RType value);
+extern void	x86MsrGet (uint32_t addr, uint64_t *value);
+extern void	x86MsrSet (uint32_t addr, uint64_t *value);
+extern _RType	x86FlagsGet (void);
+extern _RType	x86CsGet (void);
+extern _RType	x86SsGet (void);
+extern _RType	x86DsGet (void);
+extern _RType	x86EsGet (void);
+extern _RType	x86FsGet (void);
+extern _RType	x86GsGet (void);
+extern void	x86TscGet (uint64_t *value);
+extern void	x86GetCpuid (uint32_t operation,
+			     uint32_t *eaxValue, uint32_t *ebxValue,
+			     uint32_t *ecxValue, uint32_t *edxValue);
+
+#endif	/* _ASMLANGUAGE */
+
+/* CPU FAMILY & FPU type */
+
+#define X86CPU_386	  0	/* CPU FAMILY: 80386		*/
+#define X86CPU_486	  1	/* CPU FAMILY: 80486		*/
+#define X86CPU_PENTIUM	  2	/* CPU FAMILY: Pentium/P5	*/
+#define X86CPU_NS486	  3	/* CPU FAMILY: NS486		*/
+#define X86CPU_PENTIUMPRO 4	/* CPU FAMILY: Pentiumpro/P6	*/
+#define X86CPU_PENTIUM4   5	/* CPU FAMILY: Pentium4/P7      */
+#define X86FPU_387	  1	/* FPU: 80387			*/
+#define X86FPU_487	  2	/* FPU: 80487			*/
+
+/* offset to registers in HREG_SET */
+
+#ifdef LP64
+#define HREG_RAX		0x00
+#define HREG_RBX		0x08
+#define HREG_RCX		0x10
+#define HREG_RDX		0x18
+#define HREG_RSP		0x20
+#define HREG_RBP		0x28
+#define HREG_RSI		0x30
+#define HREG_RDI		0x38
+#define HREG_R8			0x40
+#define HREG_R9			0x48
+#define HREG_R10		0x50
+#define HREG_R11		0x58
+#define HREG_R12		0x60
+#define HREG_R13		0x68
+#define HREG_R14		0x70
+#define HREG_R15		0x78
+#define HREG_PC			0x80
+#define HREG_RFLAGS		0x88
+#define HREG_CR0		0x90
+#define HREG_CR2		0x98
+#define HREG_CR3		0xa0
+#define HREG_CR4		0xa8
+#define HREG_TSP		0xb0
+#define HREG_CS			0xb8
+#define HREG_DS			0xba
+#define HREG_SS			0xbc
+#define HREG_ES			0xbe
+#define HREG_FS			0xc0
+#define HREG_GS			0xc2
+#else
+#define HREG_EDI		0x00
+#define HREG_ESI		0x04
+#define HREG_EBP		0x08
+#define HREG_ESP		0x0c
+#define HREG_EBX		0x10
+#define HREG_EDX		0x14
+#define HREG_ECX		0x18
+#define HREG_EAX		0x1c
+#define HREG_EFLAGS		0x20
+#define HREG_PC			0x24
+#define HREG_CR0		0x28
+#define HREG_CR2		0x2C
+#define HREG_CR3		0x30
+#define HREG_CR4		0x34
+#define HREG_CS			0x38
+#define HREG_DS			0x3C
+#define HREG_SS			0x40
+#define HREG_ES			0x44
+#define HREG_FS			0x48
+#define HREG_GS			0x4C
+#define HREG_TSP		0x50
+#endif /* LP64 */
+
+/* bits on EFLAGS */
+
+#define EFLAGS_EMPTY	0x00000020	/* empty eflags */
+#define EFLAGS_BRANDNEW	0x00000200	/* brand new EFLAGS */
+#define EFLAGS_N_MASK	0xffffbfff	/* N(nested task flag) bit mask */
+#define EFLAGS_TF_MASK	0xfffffeff	/* TF(trap flag) bit mask */
+
+#define EFLAGS_CF	0x00000001	/* CF(carry flag) bit */
+#define EFLAGS_PF	0x00000004	/* PF(parity flag) bit */
+#define EFLAGS_AF	0x00000010	/* AF(borrow flag) bit */
+#define EFLAGS_ZF	0x00000040	/* ZF(zero flag) bit */
+#define EFLAGS_SF	0x00000080	/* AF(sign flag) bit */
+#define EFLAGS_TF	0x00000100	/* TF(trap flag) bit */
+#define EFLAGS_IF	0x00000200	/* IF(interrupt enable flag) bit */
+#define EFLAGS_IOPL	0x00003000	/* IOPL(IO privilege level) bits */
+#define EFLAGS_NT	0x00004000	/* NT(nested task flag) bit */
+#define EFLAGS_RF	0x00010000	/* RF(resume flag) bit */
+#define EFLAGS_VM	0x00020000	/* VM(virtual 8086 mode) bit */
+#define EFLAGS_AC	0x00040000	/* AC(alignment check) bit */
+#define EFLAGS_VIF	0x00080000	/* VIF(virtual int flag) bit */
+#define EFLAGS_VIP	0x00100000	/* VIP(virtual int pending) bit */
+#define EFLAGS_ID	0x00200000	/* ID(identification flag) bit */
+
+/* control and test registers */
+
+#define CR0		1
+#define CR1		2
+#define CR2		3
+#define CR3		4
+#define TR3		5
+#define TR4		6
+#define TR5		7
+#define TR6		8
+#define TR7		9
+
+/* bits on CR0 */
+
+#define CR0_PE		0x00000001	/* protection enable */
+#define CR0_MP		0x00000002	/* math present */
+#define CR0_EM		0x00000004	/* emulation */
+#define CR0_TS		0x00000008	/* task switch */
+#define CR0_ET		0x00000010	/* extension type */
+#define CR0_NE		0x00000020	/* numeric error */
+#define CR0_WP		0x00010000	/* write protect */
+#define CR0_AM		0x00040000	/* alignment mask */
+#define CR0_NW		0x20000000	/* not write through */
+#define CR0_CD		0x40000000	/* cache disable */
+#define CR0_PG		0x80000000	/* paging */
+#define CR0_NW_NOT	0xdfffffff	/* write through */
+#define CR0_CD_NOT	0xbfffffff	/* cache disable */
+
+/* bits on CR4 */
+
+#define CR4_VME		0x00000001	/* virtual-8086 mode extensions */
+#define CR4_PVI		0x00000002	/* protected-mode virtual interrupts */
+#define CR4_TSD		0x00000004	/* timestamp disable */
+#define CR4_DE		0x00000008	/* debugging extensions */
+#define CR4_PSE		0x00000010	/* page size extensions */
+#define CR4_PAE		0x00000020	/* physical address extension */
+#define CR4_MCE		0x00000040	/* machine check enable */
+#define CR4_PGE		0x00000080	/* page global enable */
+#define CR4_PCE		0x00000100	/* performance-monitoring enable */
+#define CR4_OSFXSR	0x00000200	/* use fxsave/fxrstor instructions */
+#define CR4_OSXMMEXCEPT	0x00000400	/* streaming SIMD exception */
+#define CR4_VMXE	0x00002000	/* virtual machine extensions */
+
+/* CPUID: signature bit definitions */
+
+#define CPUID_STEPID	0x0000000f	/* processor stepping id mask	*/
+#define CPUID_MODEL	0x000000f0	/* processor model mask		*/
+#define CPUID_FAMILY	0x00000f00	/* processor family mask	*/
+#define CPUID_TYPE	0x00003000	/* processor type mask		*/
+#define CPUID_EXT_MODEL	0x000f0000	/* processor extended model mask */
+#define CPUID_EXT_FAMILY 0x0ff00000	/* processor extended family mask */
+#define CPUID_486	0x00000400	/* family: 486			*/
+#define CPUID_PENTIUM	0x00000500	/* family: Pentium		*/
+#define CPUID_PENTIUMPRO 0x00000600	/* family: Pentium PRO		*/
+#define CPUID_EXTENDED	0x00000f00	/* family: Extended		*/
+#define CPUID_PENTIUM4	0x00000000	/* extended family: PENTIUM4	*/
+#define CPUID_ORIG      0x00000000	/* type: original OEM		*/
+#define CPUID_OVERD     0x00001000	/* type: overdrive		*/
+#define CPUID_DUAL      0x00002000	/* type: dual			*/
+#define CPUID_CHUNKS	0x0000ff00	/* bytes flushed by CLFLUSH mask */
+
+/* CPUID: feature bit definitions (EDX) */
+
+#define CPUID_FPU	0x00000001	/* FPU on chip			*/
+#define CPUID_VME	0x00000002	/* virtual 8086 mode enhancement*/
+#define CPUID_DE	0x00000004	/* debugging extensions		*/
+#define CPUID_PSE	0x00000008	/* page size extension		*/
+#define CPUID_TSC	0x00000010	/* time stamp counter		*/
+#define CPUID_MSR	0x00000020	/* RDMSR and WRMSR support	*/
+#define CPUID_PAE	0x00000040	/* physical address extensions	*/
+#define CPUID_MCE	0x00000080	/* machine check exception	*/
+#define CPUID_CXS	0x00000100	/* CMPXCHG8 inst		*/
+#define CPUID_APIC	0x00000200	/* APIC on chip			*/
+#define CPUID_SEP	0x00000800	/* SEP, Fast System Call	*/
+#define CPUID_MTRR	0x00001000	/* MTRR				*/
+#define CPUID_PGE	0x00002000	/* PTE global bit		*/
+#define CPUID_MCA	0x00004000	/* machine check arch.		*/
+#define CPUID_CMOV	0x00008000	/* cond. move/cmp. inst		*/
+#define CPUID_PAT	0x00010000	/* page attribute table		*/
+#define CPUID_PSE36	0x00020000	/* 36 bit page size extension	*/
+#define CPUID_PSNUM	0x00040000	/* processor serial number	*/
+#define CPUID_CLFLUSH	0x00080000	/* CLFLUSH inst supported	*/
+#define CPUID_DTS	0x00200000	/* Debug Store			*/
+#define CPUID_ACPI	0x00400000	/* TM and SCC supported		*/
+#define CPUID_MMX	0x00800000	/* MMX technology supported	*/
+#define CPUID_FXSR	0x01000000	/* fast FP save and restore	*/
+#define CPUID_SSE	0x02000000	/* SSE supported		*/
+#define CPUID_SSE2	0x04000000	/* SSE2 supported		*/
+#define CPUID_SS	0x08000000	/* Self Snoop supported		*/
+#define CPUID_HTT	0x10000000	/* Hyper Threading Technology   */
+#define CPUID_TM	0x20000000	/* Thermal Monitor supported	*/
+#define CPUID_IA64	0x40000000	/* IA64 Capabilities		*/
+#define CPUID_PBE	0x80000000	/* Pending Break Enable		*/
+
+/* CPUID: extended feature bit definitions (ECX) */
+
+#define CPUID_GV3	0x00000080	/* Geyserville 3 supported	*/
+
+#define CPUID_SSE3	0x00000001	/* SSE3 Extensions		*/
+#define CPUID_MULDQ	0x00000002	/* support PCLMULDQ instruction	*/
+#define CPUID_DTES64	0x00000004	/* 64-bit Debug Store		*/
+#define CPUID_MON	0x00000008	/* Monitor/wait			*/
+#define CPUID_DS_CPL	0x00000010	/* CPL qualified Debug Store	*/
+#define CPUID_VMX	0x00000020	/* Virtual Machine Technology	*/
+#define CPUID_SMX	0x00000040	/* Safer Mode Extensions	*/
+#define CPUID_EST	0x00000080	/* Enhanced Speedstep Technology*/
+#define CPUID_TM2	0x00000100	/* Thermal Monitor 2 supported	*/
+#define CPUID_SSSE3	0x00000200	/* SSSE3 Extensions		*/
+#define CPUID_CID	0x00000400	/* L1 context ID		*/
+#define CPUID_CX16	0x00002000	/* CMPXCHG16B			*/
+#define CPUID_XTPR	0x00004000	/* Update control		*/
+#define CPUID_PDCM	0x00008000	/* Performance/Debug capability	*/
+#define CPUID_DCA	0x00040000	/* Direct Cache Access		*/
+#define CPUID_SSE41	0x00080000	/* SIMD Extensions 4.1		*/
+#define CPUID_SSE42	0x00100000	/* SIMD Extensions 4.2		*/
+#define CPUID_x2APIC	0x00200000	/* x2APIC supported		*/
+#define CPUID_MOVBE	0x00400000	/* MOVBE instruction supported	*/
+#define CPUID_POPCNT	0x00800000	/* POPCNT instruction supported	*/
+#define CPUID_AES	0x02000000	/* AES instruction supported	*/
+#define CPUID_XSAVE	0x04000000	/* XSAVE states supported	*/
+#define CPUID_OSXSAVE	0x08000000	/* extended state management	*/
+
+/* CPUID: offset in CPUID structure */
+
+#define CPUID_HIGHVALUE		0	/* offset to highestValue	*/
+#define CPUID_VENDORID		4	/* offset to vendorId		*/
+#define CPUID_SIGNATURE		16	/* offset to signature		*/
+#define CPUID_FEATURES_EBX	20	/* offset to featuresEbx	*/
+#define CPUID_FEATURES_ECX	24	/* offset to featuresEcx	*/
+#define CPUID_FEATURES_EDX	28	/* offset to featuresEdx	*/
+#define CPUID_CACHE_EAX		32	/* offset to cacheEax		*/
+#define CPUID_CACHE_EBX		36	/* offset to cacheEbx		*/
+#define CPUID_CACHE_ECX		40	/* offset to cacheEcx		*/
+#define CPUID_CACHE_EDX		44	/* offset to cacheEdx		*/
+#define CPUID_SERIALNO		48	/* offset to serialNo64		*/
+#define CPUID_BRAND_STR		56	/* offset to brandString[0]	*/
+
+/* MSR_VMX_EPT_VPID_CAP: EOT abd VPID capabilities */
+
+#define EPT_VPID_RWX_X_ONLY	0	/* execute only supported */
+#define EPT_VPID_RWX_W_ONLY	1	/* write only supported */
+#define EPT_VPID_RWX_XW_ONLY	2	/* execute and write supported */
+
+#define EPT_VPID_GAW_21BITS	0x01	/* guest address width: 21-bits */
+#define EPT_VPID_GAW_30BITS	0x02	/* guest address width: 30-bits */
+#define EPT_VPID_GAW_39BITS	0x04	/* guest address width: 39-bits */
+#define EPT_VPID_GAW_48BITS	0x08	/* guest address width: 48-bits */
+#define EPT_VPID_GAW_57BITS	0x10	/* guest address width: 57-bits */
+
+#define EPT_VPID_EMT_UC		0x01	/* EMT memory: uncached memory */
+#define EPT_VPID_EMT_WC		0x02	/* EMT memory: write cache memory */
+#define EPT_VPID_EMT_WT		0x10	/* EMT memory: write through memory */
+#define EPT_VPID_EMT_WP		0x20	/* EMT memory: write protect memory */
+#define EPT_VPID_EMT_WB		0x40	/* EMT memory: write back memory */
+
+#define EPT_VPID_INVEPT_INDV	0x01	/* individual address sync */
+#define EPT_VPID_INVEPT_CTX	0x02	/* context sync */
+#define EPT_VPID_INVEPT_GLOBAL	0x08	/* global sync */
+
+#define EPT_VPID_INVVPID_INDV	0x01	/* individual address sync */
+#define EPT_VPID_INVVPID_CTX_1	0x02	/* single-context sync */
+#define EPT_VPID_INVVPID_CTX_A	0x08	/* all context sync */
+#define EPT_VPID_INVVPID_CTX_G	0x20	/* single context sync, keep global */
+
+#define EPT_VPID_SP_2MB		0x01	/* super page support: 2MB */
+#define EPT_VPID_SP_1GB		0x02	/* super page support: 1GB */
+#define EPT_VPID_SP_512GB	0x04	/* super page support: 512GB */
+#define EPT_VPID_SP_256TB	0x08	/* super page support: 256TB */
+
+/* MSR, Model Specific Registers */
+
+/* MSR, P5 only */
+
+#define MSR_P5_MC_ADDR		0x0000
+#define MSR_P5_MC_TYPE		0x0001
+#define MSR_TSC			0x0010
+#define MSR_CESR                0x0011
+#define MSR_CTR0                0x0012
+#define MSR_CTR1                0x0013
+
+/* MSR, P5 and P6 */
+
+#define MSR_APICBASE		0x001b
+#define MSR_EBL_CR_POWERON	0x002a
+#define MSR_TEST_CTL		0x0033
+#define MSR_BIOS_UPDT_TRIG	0x0079
+#define MSR_BBL_CR_D0		0x0088	/* P6 only */
+#define MSR_BBL_CR_D1		0x0089	/* P6 only */
+#define MSR_BBL_CR_D2		0x008a	/* P6 only */
+#define MSR_BIOS_SIGN		0x008b
+#define MSR_PERFCTR0		0x00c1
+#define MSR_PERFCTR1		0x00c2
+#define MSR_MTRR_CAP		0x00fe
+#define MSR_BBL_CR_ADDR		0x0116	/* P6 only */
+#define MSR_BBL_CR_DECC		0x0118	/* P6 only */
+#define MSR_BBL_CR_CTL		0x0119	/* P6 only */
+#define MSR_BBL_CR_TRIG		0x011a	/* P6 only */
+#define MSR_BBL_CR_BUSY		0x011b	/* P6 only */
+#define MSR_BBL_CR_CTL3		0x011e	/* P6 only */
+#define MSR_SYSENTER_CS		0x0174	/* P6 + SEP only */
+#define MSR_SYSENTER_ESP	0x0175	/* P6 + SEP only */
+#define MSR_SYSENTER_EIP	0x0176	/* P6 + SEP only */
+#define MSR_MCG_CAP		0x0179
+#define MSR_MCG_STATUS		0x017a
+#define MSR_MCG_CTL		0x017b
+#define MSR_EVNTSEL0		0x0186
+#define MSR_EVNTSEL1		0x0187
+#define MSR_DEBUGCTLMSR		0x01d9
+#define MSR_LASTBRANCH_FROMIP	0x01db
+#define MSR_LASTBRANCH_TOIP	0x01dc
+#define MSR_LASTINT_FROMIP	0x01dd
+#define MSR_LASTINT_TOIP	0x01de
+#define MSR_ROB_CR_BKUPTMPDR6	0x01e0
+#define MSR_MTRR_PHYS_BASE0	0x0200
+#define MSR_MTRR_PHYS_MASK0	0x0201
+#define MSR_MTRR_PHYS_BASE1	0x0202
+#define MSR_MTRR_PHYS_MASK1	0x0203
+#define MSR_MTRR_PHYS_BASE2	0x0204
+#define MSR_MTRR_PHYS_MASK2	0x0205
+#define MSR_MTRR_PHYS_BASE3	0x0206
+#define MSR_MTRR_PHYS_MASK3	0x0207
+#define MSR_MTRR_PHYS_BASE4	0x0208
+#define MSR_MTRR_PHYS_MASK4	0x0209
+#define MSR_MTRR_PHYS_BASE5	0x020a
+#define MSR_MTRR_PHYS_MASK5	0x020b
+#define MSR_MTRR_PHYS_BASE6	0x020c
+#define MSR_MTRR_PHYS_MASK6	0x020d
+#define MSR_MTRR_PHYS_BASE7	0x020e
+#define MSR_MTRR_PHYS_MASK7	0x020f
+#define MSR_MTRR_FIX_00000	0x0250
+#define MSR_MTRR_FIX_80000	0x0258
+#define MSR_MTRR_FIX_A0000	0x0259
+#define MSR_MTRR_FIX_C0000	0x0268
+#define MSR_MTRR_FIX_C8000	0x0269
+#define MSR_MTRR_FIX_D0000	0x026a
+#define MSR_MTRR_FIX_D8000	0x026b
+#define MSR_MTRR_FIX_E0000	0x026c
+#define MSR_MTRR_FIX_E8000	0x026d
+#define MSR_MTRR_FIX_F0000	0x026e
+#define MSR_MTRR_FIX_F8000	0x026f
+#define MSR_MTRR_DEFTYPE	0x02ff
+#define MSR_MC0_CTL		0x0400
+#define MSR_MC0_STATUS		0x0401
+#define MSR_MC0_ADDR		0x0402
+#define MSR_MC0_MISC		0x0403
+#define MSR_MC1_CTL		0x0404
+#define MSR_MC1_STATUS		0x0405
+#define MSR_MC1_ADDR		0x0406
+#define MSR_MC1_MISC		0x0407
+#define MSR_MC2_CTL		0x0408
+#define MSR_MC2_STATUS		0x0409
+#define MSR_MC2_ADDR		0x040a
+#define MSR_MC2_MISC		0x040b
+#define MSR_MC4_CTL		0x040c
+#define MSR_MC4_STATUS		0x040d
+#define MSR_MC4_ADDR		0x040e
+#define MSR_MC4_MISC		0x040f
+#define MSR_MC3_CTL		0x0410
+#define MSR_MC3_STATUS		0x0411
+#define MSR_MC3_ADDR		0x0412
+#define MSR_MC3_MISC		0x0413
+
+/* MSR, Core2 */
+
+#define MSR_FSB_FREQ		0x00cd
+
+/* MSR, Nehalem */
+
+#define MSR_PLATFORM_INFO		0x00ce
+#define MSR_FLEX_RATIO			0x0194
+#define MSR_CORE_THREAD_COUNT		0x0035
+#define MSR_CORE_PERF_GLOBAL_STATUS	0x038e
+#define MSR_CORE_PERF_GLOBAL_CTRL	0x038f
+#define MSR_CORE_PERF_GLOBAL_OVF_CTRL	0x0390
+
+/* MSR, VMX specific */
+
+#define MSR_VMX_FEATURE			0x003A
+#define MSR_VMX_BASIC			0x0480
+#define MSR_VMX_PINBASED_CTLS_MSR	0x0481
+#define MSR_VMX_PROCBASED_CTLS_MSR	0x0482
+#define MSR_VMX_EXIT_CTLS_MSR		0x0483
+#define MSR_VMX_ENTRY_CTLS_MSR		0x0484
+#define MSR_VMX_MISC_MSR		0x0485
+#define MSR_VMX_CR0_FIXED0		0x0486
+#define MSR_VMX_CR0_FIXED1		0x0487
+#define MSR_VMX_CR4_FIXED0		0x0488
+#define MSR_VMX_CR4_FIXED1		0x0489
+#define MSR_VMX_VMCS_ENUM		0x048A
+#define MSR_VMX_PROCBASED_CTLS2_MSR	0x048B
+#define MSR_VMX_EPT_VPID_CAP		0x048C
+
+/* MSR, Architectural MSRs (common MSRs in IA32) */
+
+#define IA32_P5_MC_ADDR		MSR_P5_MC_ADDR		/* P5 */
+#define IA32_P5_MC_TYPE		MSR_P5_MC_TYPE		/* P5 */
+#define IA32_TIME_STAMP_COUNTER	MSR_TSC			/* P5 */
+#define IA32_PLATFORM_ID	0x0017			/* P6 */
+#define IA32_APIC_BASE		MSR_APICBASE		/* P6 */
+#define IA32_BIOS_UPDT_TRIG	MSR_BIOS_UPDT_TRIG	/* P6 */
+#define IA32_BIOS_SIGN_ID	MSR_BIOS_SIGN		/* P6 */
+#define IA32_MTRRCAP		MSR_MTRR_CAP		/* P6 */
+#define IA32_MISC_CTL		MSR_BBL_CR_CTL		/* P6 */
+#define IA32_SYSENTER_CS	MSR_SYSENTER_CS		/* P6 */
+#define IA32_SYSENTER_ESP	MSR_SYSENTER_ESP	/* P6 */
+#define IA32_SYSENTER_EIP	MSR_SYSENTER_EIP	/* P6 */
+#define IA32_MCG_CAP		MSR_MCG_CAP		/* P6 */
+#define IA32_MCG_STATUS		MSR_MCG_STATUS		/* P6 */
+#define IA32_MCG_CTL		MSR_MCG_CTL		/* P6 */
+#define IA32_MCG_EAX		0x0180			/* Pentium4 */
+#define IA32_MCG_EBX		0x0181			/* Pentium4 */
+#define IA32_MCG_ECX		0x0182			/* Pentium4 */
+#define IA32_MCG_EDX		0x0183			/* Pentium4 */
+#define IA32_MCG_ESI		0x0184			/* Pentium4 */
+#define IA32_MCG_EDI		0x0185			/* Pentium4 */
+#define IA32_MCG_EBP		0x0186			/* Pentium4 */
+#define IA32_MCG_ESP		0x0187			/* Pentium4 */
+#define IA32_MCG_EFLAGS		0x0188			/* Pentium4 */
+#define IA32_MCG_EIP		0x0189			/* Pentium4 */
+#define IA32_MCG_MISC		0x018a			/* Pentium4 */
+#define IA32_THERM_CONTROL	0x019a			/* Pentium4 */
+#define IA32_THERM_INTERRUPT	0x019b			/* Pentium4 */
+#define IA32_THERM_STATUS	0x019c			/* Pentium4 */
+#define IA32_MISC_ENABLE	0x01a0			/* Pentium4 */
+#define IA32_DEBUGCTL		MSR_DEBUGCTLMSR		/* P6 */
+#define IA32_MTRR_PHYSBASE0	MSR_MTRR_PHYS_BASE0	/* P6 */
+#define IA32_MTRR_PHYSMASK0	MSR_MTRR_PHYS_MASK0	/* P6 */
+#define IA32_MTRR_PHYSBASE1	MSR_MTRR_PHYS_BASE1	/* P6 */
+#define IA32_MTRR_PHYSMASK1	MSR_MTRR_PHYS_MASK1	/* P6 */
+#define IA32_MTRR_PHYSBASE2	MSR_MTRR_PHYS_BASE2	/* P6 */
+#define IA32_MTRR_PHYSMASK2	MSR_MTRR_PHYS_MASK2	/* P6 */
+#define IA32_MTRR_PHYSBASE3	MSR_MTRR_PHYS_BASE3	/* P6 */
+#define IA32_MTRR_PHYSMASK3	MSR_MTRR_PHYS_MASK3	/* P6 */
+#define IA32_MTRR_PHYSBASE4	MSR_MTRR_PHYS_BASE4	/* P6 */
+#define IA32_MTRR_PHYSMASK4	MSR_MTRR_PHYS_MASK4	/* P6 */
+#define IA32_MTRR_PHYSBASE5	MSR_MTRR_PHYS_BASE5	/* P6 */
+#define IA32_MTRR_PHYSMASK5	MSR_MTRR_PHYS_MASK5	/* P6 */
+#define IA32_MTRR_PHYSBASE6	MSR_MTRR_PHYS_BASE6	/* P6 */
+#define IA32_MTRR_PHYSMASK6	MSR_MTRR_PHYS_MASK6	/* P6 */
+#define IA32_MTRR_PHYSBASE7	MSR_MTRR_PHYS_BASE7	/* P6 */
+#define IA32_MTRR_PHYSMASK7	MSR_MTRR_PHYS_MASK7	/* P6 */
+#define IA32_MTRR_FIX64K_00000	MSR_MTRR_FIX_00000	/* P6 */
+#define IA32_MTRR_FIX16K_80000	MSR_MTRR_FIX_80000	/* P6 */
+#define IA32_MTRR_FIX16K_A0000	MSR_MTRR_FIX_A0000	/* P6 */
+#define IA32_MTRR_FIX4K_C0000	MSR_MTRR_FIX_C0000	/* P6 */
+#define IA32_MTRR_FIX4K_C8000	MSR_MTRR_FIX_C8000	/* P6 */
+#define IA32_MTRR_FIX4K_D0000	MSR_MTRR_FIX_D0000	/* P6 */
+#define IA32_MTRR_FIX4K_D8000	MSR_MTRR_FIX_D8000	/* P6 */
+#define IA32_MTRR_FIX4K_E0000	MSR_MTRR_FIX_E0000	/* P6 */
+#define IA32_MTRR_FIX4K_E8000	MSR_MTRR_FIX_E8000	/* P6 */
+#define IA32_MTRR_FIX4K_F0000	MSR_MTRR_FIX_F0000	/* P6 */
+#define IA32_MTRR_FIX4K_F8000	MSR_MTRR_FIX_F8000	/* P6 */
+#define IA32_CR_PAT		0x0277			/* P6 */
+#define IA32_MTRR_DEF_TYPE	MSR_MTRR_DEFTYPE	/* P6 */
+#define IA32_PEBS_ENABLE	0x03f1			/* Pentium4 */
+#define IA32_MC0_CTL		MSR_MC0_CTL		/* P6 */
+#define IA32_MC0_STATUS		MSR_MC0_STATUS		/* P6 */
+#define IA32_MC0_ADDR		MSR_MC0_ADDR		/* P6 */
+#define IA32_MC0_MISC		MSR_MC0_MISC		/* P6 */
+#define IA32_MC1_CTL		MSR_MC1_CTL		/* P6 */
+#define IA32_MC1_STATUS		MSR_MC1_STATUS		/* P6 */
+#define IA32_MC1_ADDR		MSR_MC1_ADDR		/* P6 */
+#define IA32_MC1_MISC		MSR_MC1_MISC		/* P6 */
+#define IA32_MC2_CTL		MSR_MC2_CTL		/* P6 */
+#define IA32_MC2_STATUS		MSR_MC2_STATUS		/* P6 */
+#define IA32_MC2_ADDR		MSR_MC2_ADDR		/* P6 */
+#define IA32_MC2_MISC		MSR_MC2_MISC		/* P6 */
+#define IA32_MC3_CTL		0x040c			/* P6, addr changed */
+#define IA32_MC3_STATUS		0x040d			/* P6, addr changed */
+#define IA32_MC3_ADDR		0x040e			/* P6, addr changed */
+#define IA32_MC3_MISC		0x040f			/* P6, addr changed */
+#define IA32_DS_AREA		0x0600			/* Pentium4 */
+#define IA32_PERF_STAT		0x0198			/* Core2 */
+#define IA32_EFER		0xc0000080		/* Core2 - extended feature */
+#define IA32_STAR		0xc0000081		/* */
+#define IA32_LSTAR		0xc0000082		/* */
+#define IA32_CSTAR		0xc0000083		/* */
+#define IA32_FMASK		0xc0000084		/* */
+#define IA32_FSBASE		0xc0000100		/* */
+
+#define IA32_GSBASE		0xc0000101		/* P4 */
+#define IA32_KERNEL_GSBASE	0xc0000102		/* P4 */
+
+/* MSR, IA32_DEBUGCTL, in Pentium4, bits */
+
+#define DBG_P7_LBR		0x00000001
+#define DBG_P7_BTF		0x00000002
+#define DBG_P7_TR		0x00000004
+#define DBG_P7_BTS		0x00000008
+#define DBG_P7_BTINT		0x00000010
+
+/* MSR, IA32_DEBUGCTL, in P6, bits */
+
+#define DBG_P6_LBR		0x00000001
+#define DBG_P6_BTF		0x00000002
+#define DBG_P6_PB0		0x00000004
+#define DBG_P6_PB1		0x00000008
+#define DBG_P6_PB2		0x00000010
+#define DBG_P6_PB3		0x00000020
+#define DBG_P6_TR		0x00000040
+
+/* MSR, MSR_LASTBRANCH_TOS, in Pentium4, bits */
+
+#define TOS_MASK		0x00000003
+
+/* MSR, IA32_MISC_ENABLE bits */
+
+#define MSC_FAST_STRING_ENABLE	0x00000001
+#define MSC_FOPCODE_ENABLE	0x00000004
+#define MSC_THERMAL_MON_ENABLE	0x00000008
+#define MSC_SPLIT_LOCK_DISABLE	0x00000010
+#define MSC_PMON_AVAILABLE	0x00000080
+#define MSC_BTS_UNAVAILABLE	0x00000800
+#define MSC_PEBS_UNAVAILABLE	0x00001000
+#define MSC_GV1_EN		0x00008000
+#define MSC_GV3_EN		0x00010000
+#define MSC_GV_SEL_LOCK		0x00100000
+#define MSC_LEAF_REPORTING	0x00400000
+
+/* MSR, IA32_PEBS_ENABLE bits */
+
+#define PEBS_METRICS		0x00001fff
+#define PEBS_UOP_TAG		0x01000000
+#define PEBS_ENABLE		0x02000000
+
+/* MSR, IA32_PLATFORM_ID bits (upper 32) */
+
+#define PFM_PLATFORM_ID		0x001c0000
+#define PFM_MOBILE_GV		0x00040000
+
+/* MSR, IA32_PLATFORM_ID bits (lower 32) */
+
+#define PFM_MAX_VID		0x0000003f
+#define PFM_MAX_FREQ		0x00000f80
+#define PFM_RATIO_LOCKED	0x00008000
+#define PFM_GV3_TM_DISABLED	0x00010000
+#define PFM_GV3_DISABLED	0x00020000
+#define PFM_GV1_DISABLED	0x00040000
+#define PFM_TM_DISABLED		0x00080000
+#define PFM_L2_CACHE_SIZE	0x06000000
+#define PFM_SAMPLE		0x08000000
+
+/* MSR, IA32_THERM_CONTROL bits */
+
+#define THERM_DUTY_CYCLE	0x0000000e
+#define THERM_TCC_EN		0x00000010
+
+/* MSR, IA32_THERM_STATUS bits */
+
+#define THERM_HOT_NOW		0x00000001
+#define THERM_HOT_LOG		0x00000002
+
+/* MSR, IA32_THERM_INTERRUPT bits */
+
+#define THERM_HOT_INT_EN	0x00000001
+#define THERM_COLD_INT_EN	0x00000002
+
+/* PMC, Performance Monitoring Event Select MSR bits */
+
+/* P5 specific */
+
+#define P5PMC_PC                0x00000200
+#define P5PMC_CC_DISABLE        0x00000000
+#define P5PMC_CC_EVT_CPL012     0x00000040
+#define P5PMC_CC_EVT_CPL3       0x00000080
+#define P5PMC_CC_EVT            0x000000C0
+#define P5PMC_CC_CLK_CPL012     0x00000140
+#define P5PMC_CC_CLK_CPL3       0x00000180
+#define P5PMC_CC_CLK            0x000001C0
+
+/* P6 specific */
+
+#define PMC_USR               0x00010000
+#define PMC_OS                0x00020000
+#define PMC_E                 0x00040000
+#define PMC_PC                0x00080000
+#define PMC_INT               0x00100000
+#define PMC_EN                0x00400000
+#define PMC_INV               0x00800000
+
+/* MSR, MSR_VMX_ENTRY_CTLS bits */
+
+#define VMX_ENTRY_CTLS_IA32e		0x00000200
+#define VMX_ENTRY_CTLS_SMM		0x00000400
+#define VMX_ENTRY_CTLS_DUAL		0x00000800
+
+/* MSR, MSR_VMX_EXIT_CTLS_MSR bits */
+
+#define VMX_EXIT_CTLS_64BIT		0x00000200
+#define VMX_EXIT_CTLS_IACK		0x00008000
+
+/* MSR, IA32_EFER bits */
+
+#define EFER_SCE	0x00000001	/* SYSCALL/SYSRET (bit 0) */
+#define EFER_LME	0x00000100	/* Long mode enable (bit 8) */
+#define EFER_LMA	0x00000400	/* Long mode active (r/o) 10 */
+#define EFER_NX	0x00000800	/* No execute enable (bit 11) */
+
+/* PMC, Performance Monitoring Events */
+
+/* P5 PMC event list */
+
+#define P5PMC_DATA_RD			0x00
+#define P5PMC_DATA_WR			0x01
+#define P5PMC_DATA_TBL_MISS		0x02
+#define P5PMC_DATA_RD_MISS		0x03
+#define P5PMC_DATA_WR_MISS		0x04
+#define P5PMC_WR_HIT_M_E_STATE_LINE	0x05
+#define P5PMC_DCACHE_WR_BACK		0x06
+#define P5PMC_EXT_SNOOPS		0x07
+#define P5PMC_EXT_DCACHE_SNOOPS_HIT	0x08
+#define P5PMC_MEM_ACCESS_BOTH_PIPES	0x09
+#define P5PMC_BANK_CONFLICT		0x0A
+#define P5PMC_MISC_DMEM_IO_REF		0x0B
+#define P5PMC_CODE_RD			0x0C
+#define P5PMC_CODE_TBL_MISS		0x0D
+#define P5PMC_CODE_CACHE_MISS		0x0E
+#define P5PMC_SEGMENT_REG_LOAD		0x0F
+#define P5PMC_BRANCH			0x12
+#define P5PMC_BTB_HIT			0x13
+#define P5PMC_TAKEN_BRANCH_BTB_HIT	0x14
+#define P5PMC_PIPELINE_FLUSH		0x15
+#define P5PMC_INST_EXECUTED		0x16
+#define P5PMC_INST_EXECUTED_VPIPE	0x17
+#define P5PMC_BUS_CYC_DURATION		0x18
+#define P5PMC_WR_BUF_FULL_STALL_DURATION 0x19
+#define P5PMC_WAIT_MEM_RD_STALL_DURATION 0x1A
+#define P5PMC_STALL_ON_WR_M_E_STATE_LINE 0x1B
+#define P5PMC_LOCKED_BUS_CYC		0x1C
+#define P5PMC_IO_RD_WR_CYC		0x1D
+#define P5PMC_NONCACHE_MEM_RD		0x1E
+#define P5PMC_PIPELINE_AGI_STALL	0x1F
+#define P5PMC_FLOPS			0x22
+#define P5PMC_BK_MATCH_DR0		0x23
+#define P5PMC_BK_MATCH_DR1		0x24
+#define P5PMC_BK_MATCH_DR2		0x25
+#define P5PMC_BK_MATCH_DR3		0x26
+#define P5PMC_HW_INT			0x27
+#define P5PMC_DATA_RD_WR		0x28
+#define P5PMC_DATA_RD_WR_MISS		0x29
+#define P5PMC_BUS_OWNER_LATENCY		0x2A
+#define P5PMC_BUS_OWNER_TRANSFER	0x2A
+#define P5PMC_MMX_INST_UPIPE		0x2B
+#define P5PMC_MMX_INST_VPIPE		0x2B
+#define P5PMC_CACHE_M_LINE_SHARE	0x2C
+#define P5PMC_CACHE_LINE_SHARE		0x2C
+#define P5PMC_EMMS_INTS_EXECUTED	0x2D
+#define P5PMC_TRANS_MMX_FP_INST		0x2D
+#define P5PMC_BUS_UTIL_PROCESSOR_ACT	0x2D
+#define P5PMC_WR_NOCACHEABLE_MEM	0x2E
+#define P5PMC_SATURATING_MMX_INST	0x2F
+#define P5PMC_SATURATION_PERFORMED	0x2F
+#define P5PMC_NUM_CYC_NOT_HALT_STATE	0x30
+#define P5PMC_DCACHE_TLB_MISS_STALL_DUR	0x30
+#define P5PMC_MMX_INST_DATA_RD		0x31
+#define P5PMC_MMX_INST_DATA_RD_MISS	0x31
+#define P5PMC_FP_STALL_DUR		0x32
+#define P5PMC_TAKEN_BRANCH		0x32
+#define P5PMC_D1_STARV_FIFO_EMPTY	0x33
+#define P5PMC_D1_STARV_ONE_INST_FIFO	0x33
+#define P5PMC_MMX_INST_DATA_WR		0x34
+#define P5PMC_MMX_INST_DATA_WR_MISS	0x34
+#define P5PMC_PL_FLUSH_WRONG_BR_PREDIC	0x35
+#define P5PMC_PL_FLUSH_WRONG_BR_PREDIC_WB 0x35
+#define P5PMC_MISALIGN_DMEM_REF_MMX	0x36
+#define P5PMC_PL_STALL_MMX_DMEM_RD	0x36
+#define P5PMC_MISPREDIC_UNPREDIC_RET	0x37
+#define P5PMC_PREDICED_RETURN		0x37
+#define P5PMC_MMX_MUL_UNIT_INTERLOCK	0x38
+#define P5PMC_MOVD_MOVQ_STALL_PREV_MMX	0x38
+#define P5PMC_RETURN			0x39
+#define P5PMC_BTB_FALSE_ENTRY		0x3A
+#define P5PMC_BTB_MISS_PREDIC_NOT_TAKEN_BR 0x3A
+#define P5PMC_FULL_WR_BUF_STALL_MMX	0x3B
+#define P5PMC_STALL_MMX_WR_E_M_STATE_LINE 0x3B
+
+/* P6 PMC event list */
+
+#define PMC_DATA_MEM_REFS		0x43
+#define PMC_DCU_LINES_IN		0x45
+#define PMC_DCU_M_LINES_IN		0x46
+#define PMC_DCU_M_LINES_OUT		0x47
+#define PMC_DCU_MISS_OUTSTANDING	0x48
+#define PMC_IFU_IFETCH			0x80
+#define PMC_IFU_IFETCH_MISS		0x81
+#define PMC_ITLB_MISS			0x85
+#define PMC_IFU_MEM_STALL		0x86
+#define PMC_IDL_STALL			0x87
+#define PMC_L2_IFETCH			0x28
+#define PMC_L2_LD			0x29
+#define PMC_L2_ST			0x2a
+#define PMC_L2_LINES_IN			0x24
+#define PMC_L2_LINES_OUT		0x26
+#define PMC_L2_M_LINES_INM		0x25
+#define PMC_L2_M_LINES_OUTM		0x27
+#define PMC_L2_RQSTS			0x2e
+#define PMC_L2_ADS			0x21
+#define PMC_L2_DBUS_BUSY		0x22
+#define PMC_L2_DBUS_BUSY_RD		0x23
+#define PMC_BUS_DRDY_CLOCKS		0x62
+#define PMC_BUS_LOCK_CLOCKS		0x63
+#define PMC_BUS_REQ_OUTSTANDING		0x60
+#define PMC_BUS_TRAN_BRD		0x65
+#define PMC_BUS_TRAN_RFO		0x66
+#define PMC_BUS_TRANS_WB		0x67
+#define PMC_BUS_TRAN_IFETCH		0x68
+#define PMC_BUS_TRAN_INVAL		0x69
+#define PMC_BUS_TRAN_PWR		0x6a
+#define PMC_BUS_TRANS_P			0x6b
+#define PMC_BUS_TRANS_IO		0x6c
+#define PMC_BUS_TRAN_DEF		0x6d
+#define PMC_BUS_TRAN_BURST		0x6e
+#define PMC_BUS_TRAN_ANY		0x70
+#define PMC_BUS_TRAN_MEM		0x6f
+#define PMC_BUS_DATA_RCV		0x64
+#define PMC_BUS_BNR_DRV			0x61
+#define PMC_BUS_HIT_DRV			0x7a
+#define PMC_BUS_HITM_DRV		0x7b
+#define PMC_BUS_SNOOP_STALL		0x7e
+#define PMC_FLOPS			0xc1
+#define PMC_FP_COMP_OPS_EXE		0x10
+#define PMC_FP_ASSIST			0x11
+#define PMC_MUL				0x12
+#define PMC_DIV				0x13
+#define PMC_CYCLES_DIV_BUSY		0x14
+#define PMC_LD_BLOCKS			0x03
+#define PMC_SB_DRAINS			0x04
+#define PMC_MISALIGN_MEM_REF		0x05
+#define PMC_INST_RETIRED		0xc0
+#define PMC_UOPS_RETIRED		0xc2
+#define PMC_INST_DECODER		0xd0
+#define PMC_HW_INT_RX			0xc8
+#define PMC_CYCLES_INT_MASKED		0xc6
+#define PMC_CYCLES_INT_PENDING_AND_MASKED 0xc7
+#define PMC_BR_INST_RETIRED		0xc4
+#define PMC_BR_MISS_PRED_RETIRED	0xc5
+#define PMC_BR_TAKEN_RETIRED		0xc9
+#define PMC_BR_MISS_PRED_TAKEN_RETIRED	0xca
+#define PMC_BR_INST_DECODED		0xe0
+#define PMC_BTB_MISSES			0xe2
+#define PMC_BR_BOGUS			0xe4
+#define PMC_BACLEARS			0xe6
+#define PMC_RESOURCE_STALLS		0xa2
+#define PMC_PARTIAL_RAT_STALLS		0xd2
+#define PMC_SEGMENT_REG_LOADS		0x06
+#define PMC_CPU_CLK_UNHALTED		0x79
+#define PMC_UMASK_00			0x00
+#define PMC_UMASK_0F			0x0f
+#define PMC_UMASK_SELF			0x00
+#define PMC_UMASK_ANY			0x20
+
+/* MTRR related defines */
+
+#define MTRR_UC				0x00
+#define MTRR_WC				0x01
+#define MTRR_WT				0x04
+#define MTRR_WP				0x05
+#define MTRR_WB				0x06
+#define MTRR_E				0x00000800
+#define MTRR_FE				0x00000400
+#define MTRR_VCNT			0x000000FF
+#define MTRR_FIX_SUPPORT		0x00000100
+#define MTRR_WC_SUPPORT			0x00000400
+
+/* MCA related defines */
+
+#define MCG_CTL_P			0x00000100
+#define MCG_COUNT			0x000000ff
+#define MCG_MCIP			0x00000004
+#define MCG_EIPV			0x00000002
+#define MCG_RIPV			0x00000001
+#define MCI_VAL				0x80000000
+#define MCI_OVER			0x40000000
+#define MCI_UC				0x20000000
+#define MCI_EN				0x10000000
+#define MCI_MISCV			0x08000000
+#define MCI_ADDRV			0x04000000
+#define MCI_PCC				0x02000000
+
+/* segment descriptor: types for application code, data segment */
+
+#define SEG_DATA_RO_U		0x00000000	/* read only */
+#define SEG_DATA_RW_U		0x00000200	/* read write */
+#define SEG_DATA_RO_D		0x00000400	/* read only expand down */
+#define SEG_DATA_RW_D		0x00000600	/* read write expand down */
+#define SEG_CODE_EO		0x00000800	/* exec only */
+#define SEG_CODE_ER		0x00000a00	/* exec read */
+#define SEG_CODE_EO_C		0x00000c00	/* exec only conform. */
+#define SEG_CODE_ERO_C		0x00000e00	/* exec read only conform. */
+
+/* segment descriptor: types for system segment and gate */
+
+#define SEG_LDT			0x00000200	/* LDT */
+#define TASK_GATE		0x00000500	/* Task Gate */
+#define TSS32			0x00000900	/* 32 bit TSS (available) */
+#define CALL_GATE32		0x00000c00	/* 32 bit CALL gate */
+#define INT_GATE32		0x00000e00	/* 32 bit INT  gate */
+#define TRAP_GATE32		0x00000f00	/* 32 bit TRAP gate */
+
+/* segment descriptor: descriptor type */
+
+#define SYS_DESC		0x00000000	/* system descriptors */
+#define APP_DESC		0x00001000	/* application descriptors */
+
+/* segment descriptor: privilege level */
+
+#define DPL0			0x00000000	/* privilege level 0 */
+#define DPL1			0x00002000	/* privilege level 1 */
+#define DPL2			0x00004000	/* privilege level 2 */
+#define DPL3			0x00006000	/* privilege level 3 */
+
+/* segment descriptor: privilege level */
+
+#define SEG_P			0x00008000	/* present */
+
+/* segment descriptor: default operation size */
+
+#define DB_16			0x00000000	/* 16 bit segment */
+#define DB_32			0x00400000	/* 32 bit segment */
+
+/* segment descriptor: granularity */
+
+#define G_BYTE			0x00000000	/* byte granularity */
+#define G_4K			0x00800000	/* 4K byte granularity */
+
+/* segment descriptor: mask bits for attribute */
+
+#define SEG_ATTR_MASK		0x00f0ff00	/* mask bits */
+
+/* segment descriptor: pSegdesc->type: present and busy bit */
+
+#define SEG_PRESENT		0x80		/* present bit */
+#define SEG_BUSY		0x02		/* busy bit */
+
+/* segment register requested privilege levels */
+
+#define SEG_RPL_RING_0		0x0
+#define SEG_RPL_RING_1		0x1
+#define SEG_RPL_RING_2		0x2
+#define SEG_RPL_RING_3		0x3
+#define SEG_RPL_MASK		0x3
+
+/* IDT related macros */
+
+#define IDT_TASK_GATE		0x0000e500	/* task gate: P=1, DPL=3, task id */
+
+#define IDT_TRAP_GATE		0x0000ef00	/* trap gate: P=1, DPL=3, trap id */
+#define IDT_INT_GATE		0x0000ee00	/* int gate: P=1, DPL=3, int id */
+
+/* TSS related macros */
+
+#define TSS_LINK		  0	/* offset: link to previous task */
+#define TSS_ESP0		  4	/* offset: privilege level 0 SP */
+#define TSS_SS0			  8	/* offset:   ''              SS */
+#define TSS_ESP1		 12	/* offset: privilege level 1 SP */
+#define TSS_SS1			 16	/* offset:   ''              SS */
+#define TSS_ESP2		 20	/* offset: privilege level 2 SP */
+#define TSS_SS2			 24	/* offset:   ''              SS */
+#define TSS_CR3			 28	/* offset: control register CR3 */
+#define TSS_EIP			 32	/* offset: program counter  EIP */
+#define TSS_EFLAGS		 36	/* offset: status register  EFLAGS */
+#define TSS_EAX			 40	/* offset: general register EAX */
+#define TSS_ECX			 44	/* offset: general register ECX */
+#define TSS_EDX			 48	/* offset: general register EDX */
+#define TSS_EBX			 52	/* offset: general register EBX */
+#define TSS_ESP			 56	/* offset: stack pointer ESP */
+#define TSS_EBP			 60	/* offset: frame pointer EBP */
+#define TSS_ESI			 64	/* offset: general register ESI */
+#define TSS_EDI			 68	/* offset: general register EDI */
+#define TSS_ES			 72	/* offset: segment selector ES */
+#define TSS_CS			 76	/* offset: segment selector CS */
+#define TSS_SS			 80	/* offset: segment selector SS */
+#define TSS_DS			 84	/* offset: segment selector DS */
+#define TSS_FS			 88	/* offset: segment selector FS */
+#define TSS_GS			 92	/* offset: segment selector GS */
+#define TSS_LDT			 96	/* offset: segment selector LDT */
+#define TSS_TFLAG		100	/* offset: debug trap flag T */
+#define TSS_IOMAPB		102	/* offset: IO map base address */
+#define TSS_IOBMAP		104	/* offset: IO bit map array */
+
+#define TSS_BUSY_MASK	0xfffffdff	/* TSS descriptor BUSY bit mask */
+
+/* VMX realted defines */
+
+#define VMX_MEMORY_TYPE_UC	0	/* Strong uncacheable (UC) */
+#define VMX_MEMORY_TYPE_WB	6	/* Write back (WB) */
+
+/* inline version of intLock()/intUnlock() : used in mmuI86Lib.c */
+
+#define INT_LOCK(oldLevel) \
+    WRS_ASM ("pushf ; popl %0 ; andl $0x00000200, %0 ; cli" \
+    : "=rm" (oldLevel) : /* no input */ : "memory")
+
+#define INT_UNLOCK(oldLevel) \
+    WRS_ASM ("testl $0x00000200, %0 ; jz 0f ; sti ; 0:" \
+    : /* no output */ : "rm" (oldLevel) : "memory")
+
+#endif	/* __ASM_REG_VBI_H */
diff --git a/arch/x86/include/asm/vbi.h b/arch/x86/include/asm/vbi.h
new file mode 100644
index 0000000..ae7b51a
--- /dev/null
+++ b/arch/x86/include/asm/vbi.h
@@ -0,0 +1,143 @@
+/*
+ * x86 vbi.h - x86 tool dependent headers
+ *
+ * Copyright 2007-2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef __ASM_VBI_H
+#define __ASM_VBI_H
+
+#ifdef CONFIG_64BIT
+#ifndef LP64
+#define LP64
+#endif
+#endif
+
+/*
+ * The following definitions are used for symbol name compatibility.
+ *
+ * When #if 1, sources are assembled assuming the compiler
+ * you are using does not generate global symbols prefixed by "_".
+ * (e.g. elf/dwarf)
+ *
+ * When #if 0, sources are assembled assuming the compiler
+ * you are using generates global symbols prefixed by "_".
+ * (e.g. coff/stabs)
+ */
+
+#if	TRUE
+#define FUNC(sym)		sym
+#define FUNC_LABEL(sym)		sym:
+#else
+#define FUNC(sym)		_##sym
+#define FUNC_LABEL(sym)		_##sym:
+#endif
+
+#define VAR(sym)		FUNC(sym)
+
+/*
+ * These macros are used to declare assembly language symbols that need
+ * to be typed properly(func or data) to be visible to the OMF tool.
+ * So that the build tool could mark them as an entry point to be linked
+ * correctly.  This is an elfism. Use #if 0 for a.out.
+ */
+
+#if	TRUE
+#define GTEXT(sym) FUNC(sym) ;  .type   FUNC(sym),@function
+#define GDATA(sym) FUNC(sym) ;  .type   FUNC(sym),@object
+#else
+#define GTEXT(sym) FUNC(sym)
+#define GDATA(sym) FUNC(sym)
+#endif
+
+#ifdef LP64
+/* x86-64 ABI */
+#define INTARG1_64 %rdi
+#define INTARG2_64 %rsi
+#define INTARG3_64 %rdx
+#define INTARG4_64 %rcx
+#define INTARG5_64 %r8
+#define INTARG6_64 %r9
+
+#define INTARG1_32 %edi
+#define INTARG2_32 %esi
+#define INTARG3_32 %edx
+#define INTARG4_32 %ecx
+#define INTARG5_32 %r8d
+#define INTARG6_32 %r9d
+
+#define INTARG1_16 %di
+#define INTARG2_16 %si
+#define INTARG3_16 %dx
+#define INTARG4_16 %cx
+
+#define INTRET1	%rax
+#define INTRET2	%rdx
+
+/* these should not be used by x86-64 ABI-compliant code */
+#define SP_ARG0		0
+#define SP_ARG1		4
+#define SP_ARG2		8
+#define SP_ARG3		12
+
+#else
+/* fp offsets to arguments */
+
+#define ARG1	8
+#define ARG1W	10
+#define ARG2	12
+#define ARG2W	14
+#define ARG3	16
+#define ARG3W	18
+#define ARG4	20
+#define ARG5	24
+#define ARG6	28
+#define ARG7	32
+#define ARG8	36
+#define ARG9	40
+#define ARG10	44
+#define ARG11	48
+#define ARG12	52
+
+#define DARG1	8		/* double arguments */
+#define DARG1L	12
+#define DARG2	16
+#define DARG2L	20
+#define DARG3	24
+#define DARG3L	28
+#define DARG4	32
+#define DARG4L	36
+
+/* sp offsets to arguments */
+
+#define SP_ARG0		0
+#define SP_ARG1		4
+#define SP_ARG1W	6
+#define SP_ARG2		8
+#define SP_ARG2W	10
+#define SP_ARG3		12
+#define SP_ARG3W	14
+#define SP_ARG4		16
+#define SP_ARG5		20
+#define SP_ARG6		24
+#define SP_ARG7		28
+#define SP_ARG8		32
+#define SP_ARG9		36
+#define SP_ARG10	40
+#define SP_ARG11	44
+#define SP_ARG12	48
+#endif
+
+#define _WRS_ASM(x) __asm volatile (x)
+
+#endif /* __ASM_VBI_H */
diff --git a/arch/x86/kernel/vbi/Makefile b/arch/x86/kernel/vbi/Makefile
new file mode 100644
index 0000000..e8bce87
--- /dev/null
+++ b/arch/x86/kernel/vbi/Makefile
@@ -0,0 +1,13 @@
+#
+# Makefile for the x86 vbi.
+#
+
+obj-y		= wrhv.o wrhv_initrd.o syscalls.o
+
+# wrhv embeds an initrd in the vmlinux
+$(obj)/wrhv_initrd.o: FORCE
+	@ $(AS) -$(BITS) $(srctree)/$(src)/wrhv_initrd.S -o $@
+ifneq (X$(INITRD), X)
+	@ $(OBJCOPY) --add-section .initrd=$(INITRD) $@
+	@ $(OBJCOPY) --set-section-flags .initrd=alloc,load $@
+endif
diff --git a/arch/x86/kernel/vbi/syscalls.S b/arch/x86/kernel/vbi/syscalls.S
new file mode 100644
index 0000000..67a9582
--- /dev/null
+++ b/arch/x86/kernel/vbi/syscalls.S
@@ -0,0 +1,582 @@
+/*
+ * syscalls.S - hypervisor system calls
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#define _ASMLANGUAGE
+
+#include <asm/reg_vbi.h>
+#include <asm/vbi.h>
+#include <vbi/syscall.h>
+
+/* globals */
+.globl vbi_flush_tlb
+.text
+.balign 16
+
+#ifdef LP64
+#define VBI_STACK_FRAME_SIZE   8
+
+#define ARG1 %rdi
+#define ARG2 %rsi
+#define ARG3 %rdx
+#define ARG4 %rcx
+#define ARG5 %r8
+#define ARG6 %r9
+#define ARG7(offset) offset(%rsp)
+#define ARG8(offset) 0x8+offset(%rsp)
+
+#define vbi_hcall(name, call, args)			\
+.globl name;						\
+name:							\
+	push $##args;					\
+	mov $(VBI_SYS_##call | HY_SIZE_OVERRIDE),%rax;	\
+	vmcall;						\
+	add $VBI_STACK_FRAME_SIZE, %rsp;		\
+	ret
+
+#else	/* !LP64 */
+#define VBI_STACK_FRAME_SIZE	4
+
+#define vbi_hcall(name, call, args)		\
+.globl name;					\
+name:						\
+	movl $VBI_SYS_##call,%eax;		\
+	push $##args;				\
+	vmcall;					\
+	addl $VBI_STACK_FRAME_SIZE, %esp;	\
+	ret
+
+#endif	/* LP64 */
+
+/*
+ * vbi_send - Send a message to another context
+ *
+ * This routine makes a hypercall to send a message to the specified context
+ * and waits for a reply.  The caller will block until the sender replies to
+ * the sent message.
+ *
+ *
+ */
+#ifdef LP64
+.globl vbi_send;
+vbi_send:
+	mov     %rax,ARG7(VBI_STACK_FRAME_SIZE) /* ctl */
+	push    %r10            /* save the value of r10 */
+	mov     %rax,%r10       /* load r10 with the values of "ctl" */
+	push    $7              /* number of arguments */
+
+	mov     $(VBI_SYS_send + HY_SIZE_OVERRIDE),%rax /* system call number */
+	vmcall
+
+	pop     %r10            /* pop the number of arguments */
+	pop     %r10            /* pop the value of r10 */
+	ret
+#else
+vbi_hcall(vbi_send, send, 7)
+#endif
+
+/*
+ * vbi_rx_op - Receive a message from another context
+ *
+ * This routine makes a hypercall and waits for a message to be received from
+ * another context. It blocks until a message is received.
+ *
+ * RETURNS: sender context Id or an error number in case of failure
+ *
+ */
+vbi_hcall(vbi_rx_op, receive, 4)
+
+/*
+ * vbi_reply - Reply to message received from another context
+ *
+ * This routine makes a hypercall in order to reply to a message received from
+ * another context. A message is received from remote context by calling
+ * vbi_receive(). The reply will unblock the recipient which may preempt
+ * the caller.
+ *
+ * RETURNS: OK or an error number in case of failure
+ *
+ */
+vbi_hcall(vbi_reply, reply, 4)
+
+
+/*
+ * vbi_kputs - print a string on the kernel console
+ *
+ * This system call sends the specified string to the system console.
+ *
+ * Returns: OK or ERROR
+ *
+ */
+vbi_hcall(vbi_kputs, kputs, 1)
+
+
+/*
+ * vbi_kputc - print a character on the kernel console
+ *
+ * This system call sends the specified character to the system console.
+ *
+ * Returns: OK or ERROR
+ *
+ */
+vbi_hcall(vbi_kputc, kputc, 1)
+
+
+/*
+ * vbi_panic - panic the system and halt all activity
+ *
+ * This system call causes the hypervisor to enter a panic state and display
+ * various pieces of information on the system console.  The hypervisor
+ * then enters an idle state and stops all CPU processing.
+ *
+ * Returns: does not return
+ *
+ */
+vbi_hcall(vbi_panic, panic, 1)
+
+
+/*
+ * vbi_ps - display the list of contexts on the console
+ *
+ * This system call sends a "ps" like output of the hypervisor contexts to
+ * the system console.
+ *
+ * Returns: OK or ERROR
+ *
+ */
+vbi_hcall(vbi_ps, ps, 0)
+
+
+/*
+ * vbi_vcore_irq_unlock - Re-enable interrupts in the virtual board
+ *
+ * This call re-enables interrupts in the virtual board, and calls the
+ * hypervisor if interrupts are pending.  The value level is the value returned
+ * by the corresponding
+ *
+ */
+.globl vbi_vcore_irq_unlock
+vbi_vcore_irq_unlock:
+	sti				/* unlock interrupts */
+	ret
+
+/*
+ * vbi_vcore_irq_lock - Disable interrupts in the virtual core
+ *
+ * This call disables interrupts in the virtual board.
+ *
+ * Returns: the old value of the interrupt disable
+ *
+ */
+.globl vbi_vcore_irq_lock
+vbi_vcore_irq_lock:
+    pushf				/* push EFLAGS on stack */
+#ifdef LP64
+    pop		%rax			/* get EFLAGS in EAX */
+    andq	$EFLAGS_IF,%rax
+#else
+    pop		%eax			/* get EFLAGS in EAX */
+    and		$EFLAGS_IF,%eax		/* mask it with IF bit */
+#endif
+    cli					/* lock interrupts */
+    ret
+
+/*
+ * vbi_vb_mgmt - virtual board management
+ *
+ * This routine executes the specified command on a given virtual board. The
+ * possible commands are:
+ *
+ * VBI_VBMGMT_ATTACH
+ * Attach the requesting Virtual Board to the VB management agent for
+ * operations on the specified VB.
+ *
+ * VBI_VBMGMT_DETACH
+ * Detatch the requesting Virtual Board from the VB management agent for
+ * operations on the specified VB.
+ *
+ * VBI_VBMGMT_SUSPEND
+ * Suspends target Virtual Board from operation.  Fails if Virtual Board
+ * has already been suspended
+ *
+ * VBI_VBMGMT_RESET
+ * Resume a target virtual board.  Fails if a Virtual Board has not been
+ * suspended. Currently no options are supported
+ *
+ * VBI_VBMGMT_RESUME
+ * Restarts a target Virtual Board which has Preload=0 set in the xml file.
+ * Fails if Virtual Board is preloaded (Preload=1)
+ *
+ *
+ * The fourth argument to this routine specifies an flag that must be defined
+ * when executing VBI_VBMGMT_RESUME operation. Otherwise the command fails.
+ * The possible flgas are:
+ *   VBI_VTLB_OP_UPDATE_PMD
+ *   VBI_VTLB_OP_UPDATE_PTE
+ *   VBI_VTLB_OP_DELETE_PMD
+ *   VBI_VTLB_OP_SET_PTE_AT
+ *   VBI_VTLB_OP_SET_PTE
+ *   VBI_VTLB_OP_FLUSH_OPS
+ *   VBI_VTLB_OP_INIT
+ *
+ * RETURNS: OK or error in case of failure
+ */
+vbi_hcall(vbi_vb_mgmt, vbMgmt, 5)
+
+/*
+ * vbi_vb_suspend - Suspend a virtual board's core
+ *
+ * This routine makes a hypercall in order to suspend one or more cores
+ * that exist within the specified virtual board. The target core(s)
+ * enter HALT state until vbi_vb_resume() is called change the state of
+ * the core(s). This function will return only after all victim cores
+ * are suspended unless the opration fails to complete. The second
+ * argument passed to this function specifies one or more target cores.
+ * For suspending every core within the specified VB the second argument
+ * must be set to VBI_VB_CORES_ALL. This implies that the core
+ * requesting the suspension may also be included in the list to be
+ * suspended.  To suspend everyone but the recipient then the second
+ * argument passed to this function should be set to
+ * VBI_VB_CORES_OTHERS. Otherwise the second argument should be a valid
+ * core number within the VB. This hypercall sends a message to a given
+ * hypervisor manager that provides virtual board managment service.
+ *
+ * RETURNS: OK or an error number in case of failure
+ *
+ */
+vbi_hcall(vbi_vb_suspend, vbSuspend, 2)
+
+/*
+ * vbi_vb_reset - Reset a virtual board's core
+ *
+ * This routine makes a hypercall in order to reset one or more cores
+ * that exist within the specified virtual board. Calling this function
+ * puts the target core(s) program counter to it's ENTRY function. The
+ * ENTRY function is determined based on the loaded binary image. A core
+ * does not execute beyond it's ENTRY function unless vbi_vb_restart() is
+ * explitly called. Except for core0 within the target VB where
+ * VBI_VBMGMT_RESET_AND_START_CORE0 option is set in the flag passed as
+ * the third argument to this routine.  The hypercall sends a message to
+ * a manager that provides VB managment services.  This function will
+ * return only after all victim cores are reset unless the operation
+ * fails to complete. The order of which the victim cores are reset is
+ * not determined. The second argument identifies the cores to perform
+ * the operation on.  The value of the second argument should be set to
+ * one of the following:
+ *
+ * VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
+ *
+ * VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the
+ * victim VB
+ *
+ * A valid core number: Reset the specified core that exist within the
+ * Virtual Board.
+ *
+ * The third argument argument passed to this function specifies options
+ * that are applicable only when the second argument is
+ * VBI_VB_CORES_ALL. The options may be one of the following or a
+ * combination:
+ *
+ * VBI_VBMGMT_RESET_CLEAR: Zero out the core's memory, can only be used in
+ * conjunction with VBI_VBMGMT_RESET_DOWNLOAD
+ *
+ * VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images
+ *
+ * VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
+ *
+ *
+ * IMPORTANT: If a user chooses to restart core without reloading the
+ * executable image then the data section must be restored to prevent
+ * critical errors. It is the guest OS's responsibility to clear the bss
+ * data sections in such scenario.
+ *
+ * RETURNS: OK or an error number in case of failure
+ *
+ */
+vbi_hcall(vbi_vb_reset, vbReset, 3)
+
+/*
+ * vbi_vb_restart - Restart a virtual board's core
+ *
+ * This routine makes a hypercall in order to restart a virtual cores
+ * from reset.  It's called to start running a core or cores that were
+ * previously reset by calling vbi_vb_reset(). The target core(s) start(s)
+ * executing from the ENTRY function retrieved from the corresponding
+ * binary image.  This function will return only after  all cores are
+ * out of reset unless the operation fails to complete.  The second
+ * argument represents the cores to restart.  For restarting every core
+ * in reset mode within the specified VB the second argument is set to
+ * VBI_VB_CORES_ALL. To restart a specific core within the VB then the
+ * core number must be passed in the second argument.
+
+ * This hypercall sends a message to a manager that provides VB managment
+ * services.
+ *
+ * RETURNS: OK or an error number in case of failure
+ *
+ */
+vbi_hcall(vbi_vb_restart, vbRestart, 3)
+
+/*
+ * vbi_vb_resume - Resume a virtual board's core
+ *
+ * This routine makes a hypercall in order to resume one or cores within
+ * the specified virtual board. It reactivates a cores or cores that
+ * were previously suspended by calling vbi_vb_resume(). This function
+ * will return only after all victim cores are resumed unless the
+ * operation fails. The order of which the cores are resumed is not
+ * determined. The second argument may a magic number instead of a valid
+ * core number to indicate that the operation is intended for more than
+ * one core. For resuming every core within the specified VB then the
+ * second argument is set to be equal to VBI_VB_RESUME_ALL.  This
+ * implies to resume every core within the specified VB. Using this
+ * option when some of the cores within the VB are already running is
+ * not considered as programming error.
+ *
+ * RETURNS: OK or an error number in case of failure
+ *
+ */
+vbi_hcall(vbi_vb_resume, vbResume, 2)
+
+/*
+ * vbi_hy_ioctl - hypervisor ioctl call
+ *
+ * This system call interfaces to the general purpose hypervisor ioctl
+ * function.
+ *
+ * Possible ioctl commands:
+ *     VBI_HYIOCTL_GETPID
+ *     VBI_HYIOCTL_GETPRIORITY
+ *     VBI_HYIOCTL_GETSTATS
+ *     VBI_HYIOCTL_PADDR
+ *
+ * Returns: ioctl specific value
+ *
+ */
+vbi_hcall(vbi_hy_ioctl, hyIoctl, 5)
+
+/*
+ * vbi_io_apic_ioctl - virtual IO APIC ioctl call
+ *
+ * This system call interfaces to the virtual IO APIC ioctl
+ * function.
+ *
+ * Possible ioctl commands:
+ *     VBI_IOAPICIOCTL_UNMASK
+ *     VBI_IOAPICIOCTL_SEND
+ *     VBI_IOAPICIOCTL_MASK
+ *
+ * Returns: ioctl specific value
+ *
+ */
+vbi_hcall(vbi_io_apic_ioctl, vIoapicIoctl, 3)
+
+/*
+ * vbi_io_apic_op - virtual IO APIC ioctl call
+ *
+ * This system call interfaces to the virtual IO APIC.
+ *
+ * function.
+ *
+ * Possible commands:
+ *     VBI_IOAPICIOCTL_UNMASK
+ *     VBI_IOAPICIOCTL_SEND
+ *     VBI_IOAPICIOCTL_MASK
+ *
+ * Returns: ioctl specific value
+ *
+ */
+vbi_hcall(vbi_io_apic_op, vIoapicIoctl, 4)
+
+
+/*
+ * vbi_ctx_ctl - hypervisor context control call
+ *
+ * This system call interfaces to the general purpose hypervisor context
+ * control function.
+ *
+ * Possbile operations:
+ *	VBI_CTXCTL_IDLE /@ Make this virtual board go idle @/
+ *
+ * Returns: ioctl specific value
+ *
+ */
+vbi_hcall(vbi_ctx_ctl, ctxctl, 2)
+
+/*
+ * vbi_set_mem_attr - Set protection for a page of memory
+ *
+ * This routine makes a hypercall to set the MMU attribures for the specified
+ * memory range. The possible attributes one or a combinarion of the following:
+ *
+ * VBI_MMU_PROT_READ -  allow supervisor and user read
+ * VBI_MMU_PROT_WRITE -  Allow supervisor and user write
+ * VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
+ *
+ * RETURNS: OK or error number in case of failure
+ *
+ */
+vbi_hcall(vbi_set_mem_attr, mmu_attr_set, 3)
+
+/*
+ * vbi_get_mem_attr - Get MMU page protections
+ *
+ * This routine makes a hypercall to retrieve the MMU attributes associated for
+ * the page where the specified address is mapped. This is not the VMMU
+ * attributes. A guest OS has direct access to the mapping table of its VMMU
+ * therefore a hypercall is not necessary.
+ *
+ * RETURNS: OK or error number in case of failure
+ *
+ */
+vbi_hcall(vbi_get_mem_attr, mmu_attr_get, 1)
+
+/*
+ * vbi_ns_op - virtua board name service call
+ *
+ * This system call interfaces to the virtual board
+ *
+ * commands:
+ *	VBI_VBI_NS_REGISTER	    register service
+ *	VBI_VBI_NS_UNREGISTER	    unregister service
+ *	VBI_VBI_NS_LOOKUP	    lookup service
+ *
+ * Returns: OK or ERROR in case of failure
+ *
+ */
+vbi_hcall(vbi_ns_op, ns_op, 4)
+
+/*
+ * vbi_vb_write_mem - copy data to a remote board's memory
+ *
+ * This routine makes a hypercall to copy to a remote board memory. If
+ * the VBI_DCACHE_FLUSH is set in the control memory control structure
+ * then this routine flushes the data caches lines corresponding to the
+ * range of memory specified. If VBI_ICACHE_INV then this routine ensure
+ * that the instruction cache lines corresponding to the range of
+ * address is invalidated after the memory is copied. Invalidating the
+ * instruction is required if data containing is updated since the
+ * instruction cache is not aware of the content in data cache.
+ * Therefore flushing the data cache ensures that memory contains the
+ * updated data and invalidating the instruction cache ensures that the
+ * stale values in the instruction cache is thrown away.  The size_in
+ * parameter specifies the number of bytes desired to be copied.  The
+ * size_out parameter indicates the number of bytes successfully copied.
+ * A user may set the size_out parameter to zero if the output size is
+ * not of interest otherwise to a value different than zero.
+ *
+ * RETURNS: returns OK or error number in case of failure
+ *
+ */
+vbi_hcall(vbi_vb_write_mem, memWrite_op, 2)
+
+/*
+ * vbi_vb_read_mem - Read a virtual board's memory
+ *
+ * This routine makes a hypercall to read a remote board's memory. The
+ * memory control structure contains information about the target memory
+ * to read and the destination buffer that hypervisor must populate with
+ * the data read. This routine is used to copy data from a remote VB. It
+ * is the user's responsability to ensure that the memory read is
+ * accessed orthogonally.  The size_in parameter specifies the number of
+ * bytes desired to be copied.  The size_out parameter indicates the
+ * number of bytes successfully copied.  A user may set the size_out
+ * parameter to zero if the output size is not of interest otherwise to
+ * a value different than zero.
+ *
+ * RETURNS: returns OK or an error number in case of failure
+ *
+ */
+vbi_hcall(vbi_vb_read_mem, memRead_op, 2)
+
+/*
+ * vbi_shell_start_debug - start the hypervisor debug shell
+ *
+ * This routine sends a message to the hypervisor debug shell manager in
+ * order to start the WRHV shell program. The shell program spins
+ * therefore does not share the processor with any other WRHV context.
+ * By default a caller of this routine is detached to allow the caling
+ * core to continue executing (as long as the are not scheduled to run
+ * on the same processor). An optional flag VBI_SHELL_ATTACH can be
+ * specified to force the caller virtual board core to block while the
+ * shell program is running.
+ *
+ */
+vbi_hcall(vbi_shell_start_debug, dbgShStart, 1)
+
+
+/*
+ * vbi_vb_read_reg - Read a remote core's registers
+ *
+ * This routine makes a hypercall to read a remote core's registers. The
+ * register control structure contains information about the registers
+ * to read and the destination buffers to store them.
+ *
+ * RETURNS: returns OK or error number in case of failure
+ *
+ */
+vbi_hcall(vbi_vb_read_reg, RegsRead_op, 3)
+
+/*
+ * vbi_vb_write_reg - write to a remote core's registers
+ *
+ * This routine makes a hypercall to write to a remote core's registers. The
+ * register control structure contains the set of registers to write.
+ * The user must ensure to read first the destination core's registers using
+ * vbi_vb_read_reg() then write back the modified set of registers in the
+ * registers control structure.
+ *
+ * RETURNS: returns OK or error number in case of failure
+ *
+ */
+vbi_hcall(vbi_vb_write_reg, RegsWrite_op, 3)
+
+/*
+ * vbi_vcore_irq_redirect - redirect an irq to another vcore
+ *
+ * RETURNS: returns OK or error number in case of failure
+ *
+ */
+vbi_hcall(vbi_vcore_irq_redirect, intRedirect, 2)
+
+/*
+ * vbi_vtlb_op - execute a specified VTLB operation
+ *
+ * This system call executes the specified VTLB operation. The possible VTLB
+ * operations are:
+ *
+ *   VBI_VTLB_OP_UPDATE_PMD
+ *   VBI_VTLB_OP_UPDATE_PTE
+ *   VBI_VTLB_OP_DELETE_PMD
+ *   VBI_VTLB_OP_SET_PTE_AT
+ *   VBI_VTLB_OP_SET_PTE
+ *   VBI_VTLB_OP_FLUSH_OPS
+ *   VBI_VTLB_OP_INIT
+ *
+ * Returns: OK or ERROR if the VTLB operation has failed
+ */
+vbi_hcall(vbi_vtlb_op, vtlb_op, 4)
+
+/*
+ * vbi_vb_remote - execute a specified remote VB operation
+ *
+ * This system call requests for information about a remote VB. The possible
+ * operations are:
+ *
+ *   VBI_VBREMOTE_BOARDCONFIG    returns guest address of VB_CONFIG in out
+ *   VBI_VBREMOTE_RAMSIZE        returns memory size in out
+ *
+ */
+vbi_hcall(vbi_vb_remote, vbRemote, 4)
diff --git a/include/asm-x86/arch_vbi.h b/include/asm-x86/arch_vbi.h
new file mode 100644
index 0000000..978c5fa
--- /dev/null
+++ b/include/asm-x86/arch_vbi.h
@@ -0,0 +1,152 @@
+/*
+ * x86 arch_vbi.h - x86 architecture specific definitions
+ *
+ * Copyright 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef _ASM_ARCH_VBI_H
+#define _ASM_ARCH_VBI_H
+
+#ifndef _ASMLANGUAGE
+
+/*
+ *
+ * VB_HREG_SET - hardware register set, for read/write
+ *
+ * Used by vbi_vb_read_reg/vbi_vb_write_reg to read/write registers in
+ * another VB
+ *
+ *
+ */
+
+typedef struct			/* VBI_REG_SET - used for sys_regsRead/Write */
+{
+	uint32_t  eax;		/* 00: general register		*/
+	uint32_t  ebx;		/* 04: general register		*/
+	uint32_t  ecx;		/* 08: general register		*/
+	uint32_t  edx;		/* 0C: general register		*/
+	uint32_t  esi;		/* 10: general register		*/
+	uint32_t  edi;		/* 14: general register		*/
+	uint32_t  eip;		/* 18: program counter		*/
+	uint32_t  ebp;		/* 1C: frame pointer register	*/
+	uint32_t  esp;		/* 20: stack pointer register	*/
+	uint32_t  eflags;	/* 24: status register		*/
+	uint32_t  cr0;		/* 28: control register 0	*/
+	uint32_t  cr3;		/* 2C: control register 3	*/
+	uint32_t  cr4;		/* 30: control register 4	*/
+	uint32_t  idtr;		/* 34: IDT task register	*/
+	uint32_t  gdtr;		/* 38: GDT task register	*/
+	uint32_t  ldtr;		/* 3C: LDT task register	*/
+	uint32_t  cs;		/* 40: code segment		*/
+	uint32_t  ss;		/* 44: stack segment		*/
+	uint32_t  ds;		/* 48: data segment		*/
+	uint32_t  es;		/* 4C: E segment		*/
+	uint32_t  fs;		/* 50: F segment		*/
+	uint32_t  gs;		/* 54: G segment		*/
+	uint32_t  tr;		/* 58: task register		*/
+} VBI_HREG_SET;
+
+#endif /* _ASMLANGUAGE */
+
+/* x86 uses little endian byte ordering */
+
+#define __VBI_BYTE_ORDER __VBI_LITTLE_ENDIAN
+
+#define	VBI_X86_MAX_VECTORS         256	/* maximum number of vectors */
+#define VBI_ARCH_EXC_TABLE_SIZE     32
+#define VBI_ARCH_IRQ_TABLE_SIZE     (VBI_X86_MAX_VECTORS - VBI_ARCH_EXC_TABLE_SIZE)
+
+#define	VBI_MAX_CORES		    8	/* maximum number of virtual cores */
+
+#define VBI_IN_DIVIDE_ERROR		 0
+#define VBI_IN_DEBUG			 1
+#define VBI_IN_NON_MASKABLE		 2
+#define VBI_IN_BREAKPOINT		 3
+#define VBI_IN_OVERFLOW			 4
+#define VBI_IN_BOUND			 5
+#define VBI_IN_INVALID_OPCODE		 6
+#define VBI_IN_NO_DEVICE		 7
+#define VBI_IN_DOUBLE_FAULT		 8
+#define VBI_IN_CP_OVERRUN		 9
+#define VBI_IN_INVALID_TSS		10
+#define VBI_IN_NO_SEGMENT		11
+#define VBI_IN_STACK_FAULT		12
+#define VBI_IN_PROTECTION_FAULT		13
+#define VBI_IN_PAGE_FAULT		14
+#define VBI_IN_RESERVED			15
+#define VBI_IN_CP_ERROR			16
+#define VBI_IN_ALIGNMENT		17
+#define VBI_IN_MACHINE_CHECK		18
+#define VBI_IN_SIMD			19
+
+/* 19-31 Intel reserved exceptions  */
+
+/* 32-255 user defined exceptions  */
+
+#define VBI_IN_EXT_IRQ_BASE		32	/* local timer interrupt */
+
+#define VBI_IN_EXT_IRQ0			(VBI_IN_EXT_IRQ_BASE + 0)
+#define VBI_IN_EXT_IRQ1			(VBI_IN_EXT_IRQ_BASE + 1)
+#define VBI_IN_EXT_IRQ2			(VBI_IN_EXT_IRQ_BASE + 2)
+#define VBI_IN_EXT_IRQ3			(VBI_IN_EXT_IRQ_BASE + 3)
+#define VBI_IN_EXT_IRQ4			(VBI_IN_EXT_IRQ_BASE + 4)
+#define VBI_IN_EXT_IRQ5			(VBI_IN_EXT_IRQ_BASE + 5)
+#define VBI_IN_EXT_IRQ6			(VBI_IN_EXT_IRQ_BASE + 6)
+#define VBI_IN_EXT_IRQ7			(VBI_IN_EXT_IRQ_BASE + 7)
+#define VBI_IN_EXT_IRQ8			(VBI_IN_EXT_IRQ_BASE + 8)
+#define VBI_IN_EXT_IRQ9			(VBI_IN_EXT_IRQ_BASE + 9)
+#define VBI_IN_EXT_IRQ10		(VBI_IN_EXT_IRQ_BASE + 10)
+#define VBI_IN_EXT_IRQ11		(VBI_IN_EXT_IRQ_BASE + 11)
+#define VBI_IN_EXT_IRQ12		(VBI_IN_EXT_IRQ_BASE + 12)
+#define VBI_IN_EXT_IRQ13		(VBI_IN_EXT_IRQ_BASE + 13)
+#define VBI_IN_EXT_IRQ14		(VBI_IN_EXT_IRQ_BASE + 14)
+#define VBI_IN_EXT_IRQ15		(VBI_IN_EXT_IRQ_BASE + 15)
+#define VBI_IN_EXT_IRQ16		(VBI_IN_EXT_IRQ_BASE + 16)
+#define VBI_IN_EXT_IRQ17		(VBI_IN_EXT_IRQ_BASE + 17)
+#define VBI_IN_EXT_IRQ18		(VBI_IN_EXT_IRQ_BASE + 18)
+#define VBI_IN_EXT_IRQ19		(VBI_IN_EXT_IRQ_BASE + 19)
+#define VBI_IN_EXT_IRQ20		(VBI_IN_EXT_IRQ_BASE + 20)
+#define VBI_IN_EXT_IRQ21		(VBI_IN_EXT_IRQ_BASE + 21)
+#define VBI_IN_EXT_IRQ22		(VBI_IN_EXT_IRQ_BASE + 22)
+#define VBI_IN_EXT_IRQ23		(VBI_IN_EXT_IRQ_BASE + 23)
+#define VBI_IN_EXT_IRQ24		(VBI_IN_EXT_IRQ_BASE + 24)
+#define VBI_IN_EXT_IRQ25		(VBI_IN_EXT_IRQ_BASE + 25)
+#define VBI_IN_EXT_IRQ26		(VBI_IN_EXT_IRQ_BASE + 26)
+#define VBI_IN_EXT_IRQ27		(VBI_IN_EXT_IRQ_BASE + 27)
+#define VBI_IN_EXT_IRQ28		(VBI_IN_EXT_IRQ_BASE + 28)
+#define VBI_IN_EXT_IRQ29		(VBI_IN_EXT_IRQ_BASE + 29)
+#define VBI_IN_EXT_IRQ30		(VBI_IN_EXT_IRQ_BASE + 30)
+#define VBI_IN_EXT_IRQ31		(VBI_IN_EXT_IRQ_BASE + 31)
+#define VBI_IN_EXT_IRQ32		(VBI_IN_EXT_IRQ_BASE + 32)
+#define VBI_IN_EXT_IRQ33		(VBI_IN_EXT_IRQ_BASE + 33)
+#define VBI_IN_EXT_IRQ34		(VBI_IN_EXT_IRQ_BASE + 34)
+#define VBI_IN_EXT_IRQ35		(VBI_IN_EXT_IRQ_BASE + 35)
+#define VBI_IN_EXT_IRQ36		(VBI_IN_EXT_IRQ_BASE + 36)
+#define VBI_IN_EXT_IRQ37		(VBI_IN_EXT_IRQ_BASE + 37)
+#define VBI_IN_EXT_IRQ38		(VBI_IN_EXT_IRQ_BASE + 38)
+#define VBI_IN_EXT_IRQ39		(VBI_IN_EXT_IRQ_BASE + 39)
+#define VBI_IN_EXT_IRQ40		(VBI_IN_EXT_IRQ_BASE + 40)
+#define VBI_IN_EXT_IRQ41		(VBI_IN_EXT_IRQ_BASE + 41)
+#define VBI_IN_EXT_IRQ42		(VBI_IN_EXT_IRQ_BASE + 42)
+#define VBI_IN_EXT_IRQ43		(VBI_IN_EXT_IRQ_BASE + 43)
+#define VBI_IN_EXT_IRQ44		(VBI_IN_EXT_IRQ_BASE + 44)
+#define VBI_IN_EXT_IRQ45		(VBI_IN_EXT_IRQ_BASE + 45)
+#define VBI_IN_EXT_IRQ46		(VBI_IN_EXT_IRQ_BASE + 46)
+#define VBI_IN_EXT_IRQ47		(VBI_IN_EXT_IRQ_BASE + 47)
+
+/* timer vector */
+
+#define VBI_CLOCK_TIMER_VECTOR		0
+#define VBI_IN_APIC_TIMER		(VBI_IN_EXT_IRQ0)
+
+#endif /* _ASM_ARCH_VBI_H */
diff --git a/include/asm-x86/reg_vbi.h b/include/asm-x86/reg_vbi.h
new file mode 100644
index 0000000..ef5c24e
--- /dev/null
+++ b/include/asm-x86/reg_vbi.h
@@ -0,0 +1,1959 @@
+/*
+ * x86 regs_vbi.h - x86 cpu registers
+ *
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef	__INCx86regsh
+#define	__INCx86regsh
+
+#define IO_BMAP_SIZE	32	/* IO bitmap for port 0x000 - 0x3ff */
+
+#ifndef	_ASMLANGUAGE
+
+#ifdef LP64
+typedef struct			/* REG_SET - x86 register set	*/
+    {
+    _RType   rax;		/* 00: general register		*/
+    _RType   rbx;		/* 08: general register		*/
+    _RType   rcx;		/* 10: general register		*/
+    _RType   rdx;		/* 18: general register		*/
+    _RType   rsp;		/* 20: stack pointer register	*/
+    _RType   rbp;		/* 28: frame pointer register	*/
+    _RType   rsi;		/* 30: general register		*/
+    _RType   rdi;		/* 38: general register		*/
+    _RType   r8;		/* 40: general register		*/
+    _RType   r9;		/* 48: general register		*/
+    _RType   r10;		/* 50: general register		*/
+    _RType   r11;		/* 58: general register		*/
+    _RType   r12;		/* 60: general register		*/
+    _RType   r13;		/* 68: general register		*/
+    _RType   r14;		/* 70: general register		*/
+    _RType   r15;		/* 78: general register		*/
+    INSTR   *pc;		/* 80: program counter		*/
+    _RType   flags;		/* 88: status register		*/
+    _RType   cr0;		/* 90: control register 0	*/
+    _RType   cr2;		/* 98: control register 2	*/
+    _RType   cr3;		/* 100: control register 3	*/
+    _RType   cr4;		/* 108: control register 4	*/
+    uint64_t tsp;		/* 110: transition stack pointer*/
+    uint16_t cs;		/* 118: code segment		*/
+    uint16_t ds;		/* 11A: data segment		*/
+    uint16_t ss;		/* 11C: stack segment		*/
+    uint16_t es;		/* 11E: E segment		*/
+    uint16_t fs;		/* 120: F segment		*/
+    uint16_t gs;		/* 122: G segment		*/
+    /* xxx(gws): excluding FP support */
+    } HREG_SET;
+#else
+typedef struct			/* REG_SET - x86 register set	*/
+    {
+    uint32_t  edi;		/* 00: general register		*/
+    uint32_t  esi;		/* 04: general register		*/
+    uint32_t  ebp;		/* 08: frame pointer register	*/
+    uint32_t  esp;		/* 0C: stack pointer register	*/
+    uint32_t  ebx;		/* 10: general register		*/
+    uint32_t  edx;		/* 14: general register		*/
+    uint32_t  ecx;		/* 18: general register		*/
+    uint32_t  eax;		/* 1C: general register		*/
+    uint32_t  flags;		/* 20: status register		*/
+    INSTR    *pc;		/* 24: program counter		*/
+    uint32_t  cr0;		/* 28: control register 0	*/
+    uint32_t  cr2;		/* 2C: control register 2	*/
+    uint32_t  cr3;		/* 30: control register 3	*/
+    uint32_t  cr4;		/* 34: control register 4	*/
+    uint32_t  cs;		/* 28: code segment		*/
+    uint32_t  ds;		/* 3C: data segment		*/
+    uint32_t  ss;		/* 40: stack segment		*/
+    uint32_t  es;		/* 44: E segment		*/
+    uint32_t  fs;		/* 48: F segment		*/
+    uint32_t  gs;		/* 4C: G segment		*/
+    uint32_t  tsp;		/* 50: transition stack pointer	*/
+    } HREG_SET;
+#endif
+
+typedef struct cpuid		/* CPUID - 80x86 cpuid version/feature */
+    {
+    int highestValue;		/* EAX=0: highest integer value */
+    int vendorId[3];		/* EAX=0: vendor identification string */
+    int signature;		/* EAX=1: processor signature */
+    int featuresEbx;		/* EAX=1: feature flags EBX */
+    int featuresEcx;		/* EAX=1: feature flags ECX */
+    int featuresEdx;		/* EAX=1: feature flags EDX */
+    int cacheEax;		/* EAX=2: config parameters EAX */
+    int cacheEbx;		/* EAX=2: config parameters EBX */
+    int cacheEcx;		/* EAX=2: config parameters ECX */
+    int cacheEdx;		/* EAX=2: config parameters EDX */
+    int serialNo64[2];		/* EAX=3: lower 64 of 96 bit serial no */
+    int brandString[12];	/* EAX=0x8000000[234]: brand strings */
+    } CPUID;
+
+
+/* CPUID fields in the EAX register when EAX=1 */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t stepid:4;	/* processor stepping id mask	*/
+	uint32_t model:4;	/* processor model mask		*/
+	uint32_t family:4;	/* processor family mask	*/
+	uint32_t type:2;	/* processor type mask		*/
+	uint32_t reserved1:2;
+	uint32_t modelExt:4;	/* processor extended model mask */
+	uint32_t familyExt:8;	/* processor extended family mask */
+	uint32_t reserved2:4;
+	} field;
+    uint32_t value;
+    } CPUID_VERSION;
+
+#define CPUID_TYPE_ORIG		 0	/* type: original OEM		*/
+#define CPUID_TYPE_OVERD	 1	/* type: overdrive		*/
+#define CPUID_TYPE_DUAL		 2	/* type: dual			*/
+
+#define CPUID_FAMILY_486	 4	/* family: 486			*/
+#define CPUID_FAMILY_PENTIUM	 5	/* family: Pentium		*/
+#define CPUID_FAMILY_PENTIUMPRO  6	/* family: Pentium PRO		*/
+#define CPUID_FAMILY_EXTENDED	15	/* family: Extended		*/
+#define CPUID_FAMILY_PENTIUM4	 0	/* extended family: PENTIUM4	*/
+
+/* Intel family models */
+
+#define CPUID_MODEL_PPRO	 1	/* model: Pentium Pro		*/
+#define CPUID_MODEL_P2_OVER	 2	/* model: Pentium II Overdrive	*/
+#define CPUID_MODEL_P2_03	 3	/* model: Pentium II, model 03	*/
+#define CPUID_MODEL_P2_05	 5	/* model: Pentium II, model 05	*/
+#define CPUID_MODEL_CELERON_06	 6	/* model: Celeron, model 06	*/
+#define CPUID_MODEL_P3_07	 7	/* model: Pentium III, model 07	*/
+#define CPUID_MODEL_P3_08	 8	/* model: Pentium III, model 08	*/
+#define CPUID_MODEL_PENTIUM_M	 9	/* model: Pentium M		*/
+#define CPUID_MODEL_P3_XEON	10	/* model: Pentium III Xeon	*/
+#define CPUID_MODEL_P3_0B	11	/* model: Pentium III, model 0B	*/
+#define CPUID_MODEL_PENTIUMM_0D	13	/* model: Pentium M, model 0D	*/
+#define CPUID_MODEL_CORE	14	/* model: Core Duo/Solo		*/
+#define CPUID_MODEL_CORE2	15	/* model: Core2 Duo/Quad/Xeon	*/
+#define CPUID_MODEL_CORE2_E	23	/* model: Core2 Extreme		*/
+#define CPUID_MODEL_I7		26	/* model: Core i7		*/
+#define CPUID_MODEL_NEHALEM1	30	/* model: Core Architecture	*/
+#define CPUID_MODEL_NEHALEM2	32	/* model: Core Architecture	*/
+#define CPUID_MODEL_NEHALEM3	46	/* model: Core Architecture	*/
+#define CPUID_MODEL_WESTMERE1	37	/* model: next generation	*/
+#define CPUID_MODEL_WESTMERE2	44	/* model: next generation	*/
+
+
+/* CPUID fields in the EBX register when EAX=1 */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t brand:8;	/* Brand index			*/
+	uint32_t flushSize:8;	/* CLFLUSH line size		*/
+	uint32_t nproc:8;	/* number of local processors	*/
+	uint32_t apicId:8;	/* local APIC id		*/
+	} field;
+    uint32_t value;
+    } CPUID_INFO;
+
+/* CPUID fields in the EDX register when EAX=1 */
+
+/* CPUID: feature bit definitions */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t fpu:1;		/* FPU on chip			*/
+	uint32_t vme:1;		/* virtual 8086 mode enhancement*/
+	uint32_t de:1;		/* debugging extensions		*/
+	uint32_t pse:1;		/* page size extension		*/
+	uint32_t tsc:1;		/* time stamp counter		*/
+	uint32_t msr:1;		/* RDMSR and WRMSR support	*/
+	uint32_t pae:1;		/* physical address extensions	*/
+	uint32_t mce:1;		/* machine check exception	*/
+	uint32_t cx8:1;		/* CMPXCHG8 inst		*/
+	uint32_t apic:1;	/* APIC on chip			*/
+	uint32_t reserved1:1;
+	uint32_t sep:1;		/* SEP, Fast System Call	*/
+	uint32_t mtrr:1;	/* MTRR				*/
+	uint32_t pge:1;		/* PTE global bit		*/
+	uint32_t mca:1;		/* machine check arch.		*/
+	uint32_t cmov:1;	/* cond. move/cmp. inst		*/
+	uint32_t pat:1;		/* page attribute table		*/
+	uint32_t pse36:1;	/* 36 bit page size extension	*/
+	uint32_t psnum:1;	/* processor serial number	*/
+	uint32_t clflush:1;	/* CLFLUSH inst supported	*/
+	uint32_t reserved2:1;
+	uint32_t dts:1;		/* Debug Store			*/
+	uint32_t acpi:1;	/* TM and SCC supported		*/
+	uint32_t mmx:1;		/* MMX technology supported	*/
+	uint32_t fxsr:1;	/* fast FP save and restore	*/
+	uint32_t sse:1;		/* SSE supported		*/
+	uint32_t sse2:1;	/* SSE2 supported		*/
+	uint32_t ss:1;		/* Self Snoop supported		*/
+	uint32_t htt:1;		/* Hyper Threading Technology   */
+	uint32_t tm:1;		/* Thermal Monitor supported	*/
+	uint32_t ia64:1;	/* IA64 Capabilities		*/
+	uint32_t pbe:1;		/* Pend break enable		*/
+	} field;
+    uint32_t value;
+    } CPUID_FEATURES;
+
+
+/* fields in the ECX register when EAX=1 */
+
+/* CPUID: extended feature bit definitions */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t sse3:1;	/* SSE3 Extensions		*/
+	uint32_t reserved1:1;
+	uint32_t dtes64:1;	/* 64-bit Debug Store		*/
+	uint32_t mon:1;		/* Monitor/wait			*/
+	uint32_t ds_cpl:1;	/* CPL qualified Debug Store	*/
+	uint32_t vmx:1;		/* Virtual Machine Technology	*/
+	uint32_t smx:1;		/* Safer Mode Extensions	*/
+	uint32_t est:1;		/* Enhanced Speedstep Technology*/
+	uint32_t tm2:1;		/* Thermal Monitor 2 supported	*/
+	uint32_t ssse3:1;	/* SSSE3 Extensions		*/
+	uint32_t cid:1;		/* L1 context ID		*/
+	uint32_t reserved2:2;
+	uint32_t cx16:1;	/* CMPXCHG16B			*/
+	uint32_t xtpr:1;	/* Update control		*/
+	uint32_t pdcm:1;	/* Performance/Debug capability	*/
+	uint32_t reserved3:2;
+	uint32_t dca:1;		/* Direct Cache Access		*/
+	uint32_t sse41:1;	/* SIMD Extensions 4.1		*/
+	uint32_t sse42:1;	/* SIMD Extensions 4.2		*/
+	uint32_t x2apic:1;	/* x2APIC supported		*/
+	uint32_t movbe:1;	/* MOVBE instruction supported	*/
+	uint32_t popcnt:1;	/* POPCNT instruction supported	*/
+	uint32_t reserved4:1;
+	uint32_t aes:1;		/* AES instruction supported	*/
+	uint32_t xsave:1;	/* XSAVE states supported	*/
+	uint32_t osxsave:1;	/* extended state management	*/
+	uint32_t reserved5:4;
+	} field;
+    uint32_t value;
+    } CPUID_FEATURES_EXT;
+
+/* fields in the EAX/EBX/ECX/EDX register when EAX=4 */
+
+/* CPUID: deterministic cache parameters definitions */
+
+typedef union
+    {
+    struct
+	{
+	/* EAX */
+
+	uint32_t type:5;	/* Cache type			*/
+	uint32_t level:3;	/* Cache level			*/
+	uint32_t self_init:1;	/* Self initialising cache	*/
+	uint32_t associative:1;	/* Fully associate cache	*/
+	uint32_t reserved1:4;
+	uint32_t threads:12;	/* Max threads sharing cache	*/
+	uint32_t proc:6;	/* Max processor cores per pkg	*/
+
+	/* EBX */
+
+	uint32_t cline_size:12;	/* Coherency line size		*/
+	uint32_t pline_size:10;	/* Physical line size		*/
+	uint32_t way:10;	/* Ways of associativity	*/
+
+	/* ECX */
+
+	uint32_t sets:32;	/* Number of sets		*/
+
+	/* EDX */
+
+	uint32_t stride:10;	/* Prefetch stride		*/
+	uint32_t reserved2:22;
+
+	} field;
+    struct
+	{
+	uint32_t eax;
+	uint32_t ebx;
+	uint32_t ecx;
+	uint32_t edx;
+	} value;
+    } CPUID_CACHE;
+
+/* fields in the EAX/EBX/ECX/EDX register when EAX=11 */
+
+/* CPUID: x2APIC features / processor topology parameter definitions */
+
+typedef union
+    {
+    struct
+	{
+	/* EAX */
+
+	uint32_t apic_r_shift:5; /* number of bits to shift right */
+	uint32_t reserved1:27;
+
+	/* EBX */
+
+	uint32_t logical_proc:16; /* number of logical processor  */
+	uint32_t reserved2:16;
+
+	/* ECX */
+
+	uint32_t level:8;	 /* level number		   */
+	uint32_t type:8;	 /* level type			   */
+	uint32_t reserved3:16;
+
+	/* EDX */
+
+	uint32_t ext_apic_id;	/* extended APIC id		    */
+
+	} field;
+    struct
+	{
+	uint32_t eax;
+	uint32_t ebx;
+	uint32_t ecx;
+	uint32_t edx;
+	} value;
+    } CPUID_X2APIC;
+
+/* MSR_VMX_EPT_VPID_CAP: EPT and VPID Capabilities MSR */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t rwx_support:3;	/* R W X support	*/
+	uint32_t gaw_support:5;	/* GAW support		*/
+	uint32_t emt_support:8;	/* EMT support		*/
+	uint32_t sp_support:4;	/* SP support		*/
+	uint32_t invept:1;	/* INVEPT supported	*/
+	uint32_t reserved1:3;
+	uint32_t invept_cap:8;	/* INVEPT capabilities	*/
+	uint32_t invpid:1;	/* INVPID supported	*/
+	uint32_t reserved2:7;
+	uint32_t invpid_cap:8;	/* INVPID capabilities	*/
+	uint32_t reserved3:16;
+	} field;
+    uint64_t value;
+    } EPT_VPID_CAP_MSR;
+
+typedef struct mtrr_fix		/* MTRR - fixed range register */
+    {
+    char type[8];
+    } MTRR_FIX;
+
+typedef struct mtrr_var		/* MTRR - variable range register */
+    {
+    long long int base;
+    long long int mask;
+    } MTRR_VAR;
+
+typedef struct mtrr		/* MTRR */
+    {
+    int cap[2];			/* MTRR cap register */
+    int deftype[2];		/* MTRR defType register */
+    MTRR_FIX fix[11];		/* MTRR fixed range registers */
+    MTRR_VAR var[8];		/* MTRR variable range registers */
+    } MTRR;
+
+typedef MTRR *		MTRR_ID;
+
+/* PLATFORM_INFO MSR fields */
+
+typedef union
+    {
+    struct
+	{
+	uint64_t reserved1:8;
+	uint64_t ratio_max:8;	/* maximum non-turbo TSC ratio	*/
+	uint64_t reserved2:24;
+	uint64_t ratio_min:8;	/* minimum non-turbo TSC ratio	*/
+	uint64_t reserved3:16;
+	} field;
+    uint64_t value;
+    } PLATFORM_INFO;
+
+/* MSR_FLEX_RATIO MSR fields */
+
+typedef union
+    {
+    struct
+	{
+	uint64_t reserved1:8;
+	uint64_t ratio:8;	/* current non-turbo TSC ratio	*/
+	uint64_t enabled:1;	/* flex ratio enabled		*/
+	uint64_t reserved2:47;
+	} field;
+    uint64_t value;
+    } FLEX_RATIO;
+
+/*
+ * Structure of a global descriptor table (GDT) entry
+ * (common to 32 & 64 bits)
+ */
+
+typedef struct gdt_entry
+    {
+    uint16_t	limit00;	/* limit: xffff			*/
+    uint16_t	base00;		/* base : xxxx0000		*/
+    uint8_t	base01;		/* base : xx00xxxx		*/
+    uint8_t	type:4;		/* Code e/r,			*/
+    uint8_t	sys:1;		/* 0 = system segment		*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint8_t	limit01:4;	/* limit: fxxxx			*/
+    uint8_t	free:1;		/* free bit			*/
+    uint8_t	l:1;		/* 64-bit code segment		*/
+    uint8_t	d_b:1;		/* access 0=16-bit 1=32-bit	*/
+    uint8_t	g:1;		/* page granularity		*/
+    uint8_t	base02;		/* base : 00xxxxxx		*/
+    } GDT_ENTRY;
+
+/* Structure of global descriptor table call entry in 32-bits mode */
+
+typedef struct gdt32_call_entry
+    {
+    uint16_t	offset00;	/* offset: xxxxffff		*/
+    uint16_t	segment;	/* segment selector		*/
+    uint8_t	nparam:5;	/* number of parameters		*/
+    uint8_t	res1:3;		/* reserved (zeroes)		*/
+    uint8_t	type:4;		/* Code e/r,			*/
+    uint8_t	sys:1;		/* 0 = system segment		*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint16_t	offset01;	/* offset: ffffxxxx		*/
+    } GDT32_CALL_ENTRY;
+
+/* Structure of interrupt descriptor table (IDT) entry in 32-bits mode */
+
+typedef struct idt32_entry
+    {
+    uint16_t	offset00;	/* offset : xxxxffff		*/
+    uint16_t	segment;	/* segment selector		*/
+    uint8_t	res1;		/* reserved (zeroes) */
+    uint8_t	type:5;		/* Code e/r,			*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint16_t	offset01;	/* offset: ffffxxxx		*/
+    } IDT32_ENTRY;
+
+#ifdef	LP64
+/* Structure of global descriptor table call entry in 64-bits mode */
+
+typedef struct gdt64_call_entry
+    {
+    uint16_t	offset00;	/* offset: xxxxxxxxxxxxffff	*/
+    uint16_t	segment;	/* segment selector		*/
+    uint8_t	res1;		/* reserved (zeroes)		*/
+    uint8_t	type:4;		/* Code e/r,			*/
+    uint8_t	sys:1;		/* 0 = system segment		*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint16_t	offset01;	/* offset: xxxxxxxxffffxxxx	*/
+    uint32_t	offset02;	/* offset: ffffffffxxxxxxxx	*/
+    uint32_t	res3;		/* reserved */
+    } GDT64_CALL_ENTRY;
+
+/* Structure of interrupt descriptor table (IDT) entry in 64-bits mode */
+
+typedef struct idt64_entry
+    {
+    uint16_t	offset00;	/* offset: xxxxxxxxxxxxffff	*/
+    uint16_t	segment;	/* segment selector		*/
+    uint8_t	ist:3;		/* interrupt stack table	*/
+    uint8_t	res1:5;		/* reserved (zeroes)		*/
+    uint8_t	type:4;		/* Code e/r,			*/
+    uint8_t	res2:1;		/* reserved (zeroes)		*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint16_t	offset01;	/* offset: xxxxxxxxffffxxxx	*/
+    uint32_t	offset02;	/* offset: ffffffffxxxxxxxx	*/
+    uint32_t	res3;		/* reserved */
+    } IDT64_ENTRY;
+
+#define	GDT_CALL_ENTRY		GDT64_CALL_ENTRY
+#define	IDT_ENTRY		IDT64_ENTRY
+#else
+#define	GDT_CALL_ENTRY		GDT32_CALL_ENTRY
+#define	IDT_ENTRY		IDT32_ENTRY
+#endif	/* LP64 */
+
+
+#define	GDT_BASE00_SHIFT	00
+#define	GDT_BASE01_SHIFT	16
+#define	GDT_BASE02_SHIFT	24
+#define	GDT_BASE00_MASK		0x0000ffff
+#define	GDT_BASE01_MASK		0x00ff0000
+#define	GDT_BASE02_MASK		0xff000000
+
+#define	GDT_LIMIT00_SHIFT	00
+#define	GDT_LIMIT01_SHIFT	16
+#define	GDT_LIMIT00_MASK	0x0ffff
+#define	GDT_LIMIT01_MASK	0xf0000
+
+#define	GDT_BASE(p)	((p->base02 << GDT_BASE02_SHIFT) | \
+			 (p->base01 << GDT_BASE01_SHIFT) | p->base00)
+#define	GDT_LIMIT(p)	((p->limit01 << GDT_LIMIT01_SHIFT) | p->limit00)
+
+#define GDT_LIMIT00(v)	(((v) & GDT_LIMIT00_MASK) >> GDT_LIMIT00_SHIFT)
+#define GDT_LIMIT01(v)	(((v) & GDT_LIMIT01_MASK) >> GDT_LIMIT01_SHIFT)
+
+#define GDT_BASE00(v)	(((v) & GDT_BASE00_MASK) >> GDT_BASE00_SHIFT)
+#define GDT_BASE01(v)	(((v) & GDT_BASE01_MASK) >> GDT_BASE01_SHIFT)
+#define GDT_BASE02(v)	(((v) & GDT_BASE02_MASK) >> GDT_BASE02_SHIFT)
+
+/* GDT call entry macros */
+
+#define	GDT32_OFFSET00_SHIFT	00
+#define	GDT32_OFFSET01_SHIFT	16
+#define	GDT32_OFFSET00_MASK	0x0000ffff
+#define	GDT32_OFFSET01_MASK	0xffff0000
+
+#define	GDT32_OFFSET(p)		((p->offset01 << GDT32_OFFSET01_SHIFT) | \
+				 p->offset00)
+#define GDT32_OFFSET00(v)	(((v) & GDT32_OFFSET00_MASK) >> \
+				 GDT32_OFFSET00_SHIFT)
+#define GDT32_OFFSET01(v)	(((v) & GDT32_OFFSET01_MASK) >> \
+				 GDT32_OFFSET01_SHIFT)
+
+#ifdef	LP64
+#define	GDT64_OFFSET00_SHIFT	00
+#define	GDT64_OFFSET01_SHIFT	16
+#define	GDT64_OFFSET02_SHIFT	32
+#define	GDT64_OFFSET00_MASK	0x000000000000ffff
+#define	GDT64_OFFSET01_MASK	0x00000000ffff0000
+
+#define	GDT64_OFFSET(p)		((((uint64_t) p->offset02) << \
+					GDT64_OFFSET02_SHIFT) | \
+				 (p->offset01 << GDT64_OFFSET01_SHIFT) | \
+				 p->offset00)
+#define GDT64_OFFSET00(v)	((uint16_t)((((v) & GDT64_OFFSET00_MASK) >> \
+					    GDT64_OFFSET00_SHIFT)))
+#define GDT64_OFFSET01(v)	((uint16_t)((((v) & GDT64_OFFSET01_MASK) >> \
+					    GDT64_OFFSET01_SHIFT)))
+#define GDT64_OFFSET02(v)	((uint32_t)(((v) >> GDT64_OFFSET02_SHIFT)))
+
+#define	GDT_OFFSET		GDT64_OFFSET
+#define	GDT_OFFSET00		GDT64_OFFSET00
+#define	GDT_OFFSET01		GDT64_OFFSET01
+#define	GDT_OFFSET02		GDT64_OFFSET02
+#else	/* LP64 */
+#define	GDT_OFFSET		GDT32_OFFSET
+#define	GDT_OFFSET00		GDT32_OFFSET00
+#define	GDT_OFFSET01		GDT32_OFFSET01
+#endif
+
+/* IDT aliases */
+
+#define	IDT32_OFFSET(x)		GDT32_OFFSET(x)
+#define	IDT32_OFFSET00(x)	GDT32_OFFSET00(x)
+#define	IDT32_OFFSET01(x)	GDT32_OFFSET01(x)
+
+#ifdef	LP64
+#define	IDT64_OFFSET(x)		GDT64_OFFSET(x)
+#define	IDT64_OFFSET00(x)	GDT64_OFFSET00(x)
+#define	IDT64_OFFSET01(x)	GDT64_OFFSET01(x)
+#define	IDT64_OFFSET02(x)	GDT64_OFFSET02(x)
+
+#define	IDT_OFFSET		IDT64_OFFSET
+#define	IDT_OFFSET00		IDT64_OFFSET00
+#define	IDT_OFFSET01		IDT64_OFFSET01
+#define	IDT_OFFSET02		IDT64_OFFSET02
+#else	/* LP64 */
+#define	IDT_OFFSET		IDT32_OFFSET
+#define	IDT_OFFSET00		IDT32_OFFSET00
+#define	IDT_OFFSET01		IDT32_OFFSET01
+#define	IDT_OFFSET02		IDT32_OFFSET02
+#endif	/* LP64 */
+
+/* GDT data segment types */
+
+#define	GDT_TYPE_RO		0	/* read-only			   */
+#define	GDT_TYPE_RO_A		1	/* read-only accessed		   */
+#define	GDT_TYPE_RW		2	/* read-write			   */
+#define	GDT_TYPE_RW_A		3	/* read-write accessed		   */
+#define	GDT_TYPE_RO_DOWN	4	/* read-only expand-down	   */
+#define	GDT_TYPE_RO_DOWN_A	5	/* read-only expand-down accessed  */
+#define	GDT_TYPE_RW_DOWN	6	/* read-write expand-down	   */
+#define	GDT_TYPE_RW_DOWN_A	7	/* read-write expand-down accessed */
+#define	GDT_TYPE_EX		8	/* execute			   */
+#define	GDT_TYPE_EX_A		9	/* execute accessed		   */
+#define	GDT_TYPE_EX_RO		10	/* execute read-only		   */
+#define	GDT_TYPE_EX_RO_A	11	/* execute read-only accessed	   */
+#define	GDT_TYPE_EX_CF		12	/* execute conforming		   */
+#define	GDT_TYPE_EX_CF_A	13	/* execute conforming accessed	   */
+#define	GDT_TYPE_EX_RO_CF	14	/* execute read-only conforming	   */
+#define	GDT_TYPE_EX_RO_CF_A	15	/* execute r/o conforming accessed */
+
+/* GDT system segment types */
+
+#ifndef	LP64
+#define	GDT_TYPE_SYS_RES0	0	/* reserved			   */
+#define	GDT_TYPE_SYS_TSS16_A	1	/* 16-bit TSS (available)	   */
+#define	GDT_TYPE_SYS_LDT	2	/* local descriptor table	   */
+#define	GDT_TYPE_SYS_TSS16_B	3	/* 16-bit TSS (busy)		   */
+#define	GDT_TYPE_SYS_CALL16	4	/* 16-bit call gate		   */
+#define	GDT_TYPE_SYS_TGATE	5	/* task gate			   */
+#define	GDT_TYPE_SYS_IGATE16	6	/* 16-bit interrupt gate	   */
+#define	GDT_TYPE_SYS_TGATE16	7	/* 16-bit trap gate		   */
+#define	GDT_TYPE_SYS_RES1	8	/* reserved			   */
+#define	GDT_TYPE_SYS_TSS32_A	9	/* 32-bit TSS (available)	   */
+#define	GDT_TYPE_SYS_RES2	10	/* reserved			   */
+#define	GDT_TYPE_SYS_TSS32_B	11	/* 32-bit TSS (busy)		   */
+#define	GDT_TYPE_SYS_CALL32	12	/* 32-bit call gate		   */
+#define	GDT_TYPE_SYS_RES3	13	/* reserved			   */
+#define	GDT_TYPE_SYS_IGATE32	14	/* 32-bit interrupt gate	   */
+#define	GDT_TYPE_SYS_TGATE32	15	/* 32-bit trap gate		   */
+#else	/* !LP64 */
+#define	GDT32_TYPE_SYS_TSS16_A	1	/* 16-bit TSS (available)	   */
+#define	GDT32_TYPE_SYS_LDT	2	/* local descriptor table	   */
+#define	GDT32_TYPE_SYS_TSS16_B	3	/* 16-bit TSS (busy)		   */
+#define	GDT32_TYPE_SYS_CALL16	4	/* 16-bit call gate		   */
+#define	GDT32_TYPE_SYS_TGATE	5	/* task gate			   */
+#define	GDT32_TYPE_SYS_IGATE16	6	/* 16-bit interrupt gate	   */
+#define	GDT32_TYPE_SYS_TGATE16	7	/* 16-bit trap gate		   */
+#define	GDT32_TYPE_SYS_TSS32_A	9	/* 32-bit TSS (available)	   */
+#define	GDT32_TYPE_SYS_TSS32_B	11	/* 32-bit TSS (busy)		   */
+#define	GDT32_TYPE_SYS_CALL32	12	/* 32-bit call gate		   */
+#define	GDT32_TYPE_SYS_IGATE32	14	/* 32-bit interrupt gate	   */
+#define	GDT32_TYPE_SYS_TGATE32	15	/* 32-bit trap gate		   */
+
+#define GDT_TYPE_SYS_LDT	2	/* local descriptor table	   */
+#define GDT_TYPE_SYS_TSS64_A	9	/* 64 bit TSS (available)	   */
+#define GDT_TYPE_SYS_TSS64_B	11	/* 64 bit TSS (busy)	           */
+#define	GDT_TYPE_SYS_CALL64	12	/* 64-bit call gate		   */
+#define	GDT_TYPE_SYS_IGATE64	14	/* 64-bit interrupt gate	   */
+#define	GDT_TYPE_SYS_TGATE63	15	/* 64-bit trap gate		   */
+#endif	/* !LP64 */
+/* GDT segment status */
+
+#define	GDT_SEG_INVALID		0	/* segment is not present	   */
+#define	GDT_SEG_VALID		1	/* segment is present		   */
+
+/* GDT segment type */
+
+#define	GDT_SEG_SYSTEM		0	/* system type segment		   */
+#define	GDT_SEG_CODE_DATA	1	/* code/data type segment	   */
+
+/* GDT access types */
+
+#define	GDT_ACCESS_16		0	/* 16-bit access to memory	   */
+#define	GDT_ACCESS_32		1	/* 32-bit access to memory	   */
+
+/* GDT access types */
+
+#define	GDT_GRAN_BYTE		0	/* byte size page granularity	   */
+#define	GDT_GRAN_4KB_PAGE	1	/* 4KB size page granularity	   */
+
+/* GDT access types */
+
+#define GDT_64_CODE_SEGMENT	1	/* 64-bit code segment		   */
+#define GDT_COMP_CODE_SEGMENT	0	/* compatible mode code segment	   */
+
+/* GDT privilidge level */
+
+#define	GDT_PRIV_RING_0		0	/* ring 0 priv level		   */
+#define	GDT_PRIV_RING_1		1	/* ring 1 priv level		   */
+#define	GDT_PRIV_RING_2		2	/* ring 2 priv level		   */
+#define	GDT_PRIV_RING_3		3	/* ring 3 priv level		   */
+
+/* IDT segment types */
+
+#define	IDT_TYPE_RES0		0	/* reserved			   */
+#define	IDT_TYPE_RES1		1	/* reserved			   */
+#define	IDT_TYPE_RES2		2	/* reserved			   */
+#define	IDT_TYPE_RES3		3	/* reserved			   */
+#define	IDT_TYPE_RES4		4	/* reserved			   */
+#define	IDT_TYPE_TGATE		5	/* task gate			   */
+#define	IDT_TYPE_IGATE_16	6	/* 16-bit interrupt gate	   */
+#define	IDT_TYPE_TRGATE_16	7	/* 16-bit trap gate		   */
+#define	IDT_TYPE_RES8		8	/* reserved			   */
+#define	IDT_TYPE_RES9		9	/* reserved			   */
+#define	IDT_TYPE_RES10		10	/* reserved			   */
+#define	IDT_TYPE_RES11		11	/* reserved			   */
+#define	IDT_TYPE_RES12		12	/* reserved			   */
+#define	IDT_TYPE_RES13		13	/* reserved			   */
+#define	IDT_TYPE_IGATE		14	/* 32-bit interrupt gate	   */
+#define	IDT_TYPE_TRGATE		15	/* 32-bit trap gate		   */
+
+/* IDT segment status */
+
+#define	IDT_SEG_INVALID		0	/* segment is not present	   */
+#define	IDT_SEG_VALID		1	/* segment is present		   */
+
+/* IDT segment type */
+
+#define	IDT_SEG_SYSTEM		0	/* system type segment		   */
+#define	IDT_SEG_CODE_DATA	1	/* code/data type segment	   */
+
+/* IDT access types */
+
+#define	IDT_ACCESS_16		0	/* 16-bit access to memory	   */
+#define	IDT_ACCESS_32		1	/* 32-bit access to memory	   */
+
+/* IDT access types */
+
+#define	IDT_GRAN_BYTE		0	/* byte size page granularity	   */
+#define	IDT_GRAN_4KB_PAGE	1	/* 4KB size page granularity	   */
+
+/* IDT privilidge level */
+
+#define	IDT_PRIV_RING_0		0	/* ring 0 priv level		   */
+#define	IDT_PRIV_RING_1		1	/* ring 2 priv level		   */
+#define	IDT_PRIV_RING_2		2	/* ring 2 priv level		   */
+#define	IDT_PRIV_RING_3		3	/* ring 3 priv level		   */
+
+/* structure of the global descriptor table register (GDTR) */
+
+typedef union
+    {
+    struct
+	{
+	uint16_t limit;		/* maximum size of the GDT */
+	uint16_t addr0;		/* address of GDT table */
+	uint16_t addr1;
+	uint16_t padding;
+	} field;
+    struct
+	{
+	uint64_t word0;		/* word 0 */
+	} words;
+    } GDTR32;
+
+#define	GDTR32_ADDR00_SHIFT	00
+#define	GDTR32_ADDR01_SHIFT	16
+#define	GDTR32_ADDR00_MASK	0x0000ffff
+#define	GDTR32_ADDR01_MASK	0xffff0000
+
+#define	GDTR32_ADDR(reg)	((reg.field.addr1 << GDTR32_ADDR01_SHIFT) | \
+				 reg.field.addr0)
+#define	GDTR32_LIMIT(reg)	(reg.field.limit)
+
+#ifdef	LP64
+typedef union
+    {
+    struct
+	{
+	uint16_t limit;		/* maximum size of the GDT */
+	uint16_t addr0;		/* address of GDT table */
+	uint16_t addr1;
+	uint16_t addr2;
+	uint16_t addr3;
+	uint16_t padding[3];
+	} field;
+    struct
+	{
+	uint64_t word[2];		/* word 0 */
+	} words;
+    } GDTR64;
+
+#define	GDTR64_ADDR00_SHIFT	00
+#define	GDTR64_ADDR01_SHIFT	16
+#define	GDTR64_ADDR02_SHIFT	32
+#define	GDTR64_ADDR03_SHIFT	48
+#define	GDTR64_ADDR00_MASK	0x000000000000ffff
+#define	GDTR64_ADDR01_MASK	0x00000000ffff0000
+#define	GDTR64_ADDR02_MASK	0x0000ffff00000000
+#define	GDTR64_ADDR03_MASK	0xffff000000000000
+
+#define	GDTR64_ADDR(reg)	(((uint64_t)reg.field.addr1 << \
+					GDTR64_ADDR01_SHIFT) | \
+				 ((uint64_t)reg.field.addr2 << \
+					GDTR64_ADDR02_SHIFT) | \
+				 ((uint64_t)reg.field.addr3 << \
+					GDTR64_ADDR03_SHIFT) | \
+				 reg.field.addr0)
+#define	GDTR64_LIMIT(reg)	(reg.field.limit)
+
+#define	GDTR			GDTR64
+#define	GDTR_ADDR00_SHIFT	GDTR64_ADDR00_SHIFT
+#define	GDTR_ADDR01_SHIFT	GDTR64_ADDR01_SHIFT
+#define	GDTR_ADDR02_SHIFT	GDTR64_ADDR02_SHIFT
+#define	GDTR_ADDR03_SHIFT	GDTR64_ADDR03_SHIFT
+#define	GDTR_ADDR00_MASK	GDTR64_ADDR00_MASK
+#define	GDTR_ADDR01_MASK	GDTR64_ADDR01_MASK
+#define	GDTR_ADDR02_MASK	GDTR64_ADDR02_MASK
+#define	GDTR_ADDR03_MASK	GDTR64_ADDR03_MASK
+#define	GDTR_ADDR		GDTR64_ADDR
+#define	GDTR_LIMIT		GDTR64_LIMIT
+#else	/* LP64 */
+#define	GDTR			GDTR32
+#define	GDTR_ADDR00_SHIFT	GDTR32_ADDR00_SHIFT
+#define	GDTR_ADDR01_SHIFT	GDTR32_ADDR01_SHIFT
+#define	GDTR_ADDR00_MASK	GDTR32_ADDR00_MASK
+#define	GDTR_ADDR01_MASK	GDTR32_ADDR01_MASK
+#define	GDTR_ADDR		GDTR32_ADDR
+#define	GDTR_LIMIT		GDTR32_LIMIT
+#endif	/* LP64 */
+
+/* structure of the interrupt descriptor table register (IDTR) */
+
+typedef union
+    {
+    struct
+	{
+	uint16_t limit;		/* maximum size of the IDT */
+	uint16_t addr0;		/* address of IDT table */
+	uint16_t addr1;
+	uint16_t padding;
+	} field;
+    struct
+	{
+	uint64_t word0;		/* word 0 */
+	} words;
+    } IDTR32;
+
+#define	IDTR32_ADDR00_SHIFT	00
+#define	IDTR32_ADDR01_SHIFT	16
+#define	IDTR32_ADDR00_MASK	0x0000ffff
+#define	IDTR32_ADDR01_MASK	0xffff0000
+
+#define	IDTR32_ADDR(reg)	((reg.field.addr1 << IDTR32_ADDR01_SHIFT) | \
+				 reg.field.addr0)
+#define	IDTR32_LIMIT(reg)	(reg.field.limit)
+
+#ifdef	LP64
+typedef union
+    {
+    struct
+	{
+	uint16_t limit;		/* maximum size of the IDT */
+	uint16_t addr0;		/* address of IDT table */
+	uint16_t addr1;
+	uint16_t addr2;
+	uint16_t addr3;
+	uint16_t padding[3];
+	} field;
+    struct
+	{
+	uint64_t word[2];		/* word 0 */
+	} words;
+    } IDTR64;
+
+#define	IDTR64_ADDR00_SHIFT	00
+#define	IDTR64_ADDR01_SHIFT	16
+#define	IDTR64_ADDR02_SHIFT	32
+#define	IDTR64_ADDR03_SHIFT	48
+#define	IDTR64_ADDR00_MASK	0x000000000000ffff
+#define	IDTR64_ADDR01_MASK	0x00000000ffff0000
+#define	IDTR64_ADDR02_MASK	0x0000ffff00000000
+#define	IDTR64_ADDR03_MASK	0xffff000000000000
+
+#define	IDTR64_ADDR(reg)	(((uint64_t)reg.field.addr1 << \
+					IDTR64_ADDR01_SHIFT) | \
+				 ((uint64_t)reg.field.addr2 << \
+					IDTR64_ADDR02_SHIFT) | \
+				 ((uint64_t)reg.field.addr3 << \
+					IDTR64_ADDR03_SHIFT) | \
+				 reg.field.addr0)
+#define	IDTR64_LIMIT(reg)	(reg.field.limit)
+
+#define	IDTR			IDTR64
+#define	IDTR_ADDR00_SHIFT	IDTR64_ADDR00_SHIFT
+#define	IDTR_ADDR01_SHIFT	IDTR64_ADDR01_SHIFT
+#define	IDTR_ADDR02_SHIFT	IDTR64_ADDR02_SHIFT
+#define	IDTR_ADDR03_SHIFT	IDTR64_ADDR03_SHIFT
+#define	IDTR_ADDR00_MASK	IDTR64_ADDR00_MASK
+#define	IDTR_ADDR01_MASK	IDTR64_ADDR01_MASK
+#define	IDTR_ADDR02_MASK	IDTR64_ADDR02_MASK
+#define	IDTR_ADDR03_MASK	IDTR64_ADDR03_MASK
+#define	IDTR_ADDR		IDTR64_ADDR
+#define	IDTR_LIMIT		IDTR64_LIMIT
+#else	/* LP64 */
+#define	IDTR			IDTR32
+#define	IDTR_ADDR00_SHIFT	IDTR32_ADDR00_SHIFT
+#define	IDTR_ADDR01_SHIFT	IDTR32_ADDR01_SHIFT
+#define	IDTR_ADDR00_MASK	IDTR32_ADDR00_MASK
+#define	IDTR_ADDR01_MASK	IDTR32_ADDR01_MASK
+#define	IDTR_ADDR		IDTR32_ADDR
+#define	IDTR_LIMIT		IDTR32_LIMIT
+#endif	/* LP64 */
+
+/* structure of the local descriptor table register (LDTR) */
+
+typedef uint32_t LDTR;
+
+/* x86 Task State Segment (TSS) */
+
+typedef struct tss
+    {
+#ifdef LP64
+    uint32_t  reserved0;	/* reserved */
+    uint64_t  rsp0;		/* privilege level 0 SP */
+    uint64_t  rsp1;		/* privilege level 1 SP */
+    uint64_t  rsp2;		/* privilege level 2 SP */
+    uint64_t  reserved1;	/* reserved */
+    uint64_t  ist1;		/* interrupt stack table ptr */
+    uint64_t  ist2;		/* interrupt stack table ptr */
+    uint64_t  ist3;		/* interrupt stack table ptr */
+    uint64_t  ist4;		/* interrupt stack table ptr */
+    uint64_t  ist5;		/* interrupt stack table ptr */
+    uint64_t  ist6;		/* interrupt stack table ptr */
+    uint64_t  ist7;		/* interrupt stack table ptr */
+    uint64_t  reserved2;	/* reserved */
+    uint16_t  reserved3;	/* reserved */
+    uint16_t  iomapb;		/* IO map base offset */
+    uint32_t  iobmap[IO_BMAP_SIZE + 1];
+#else
+    uint16_t  link;		/* link to previous task */
+    uint16_t  reserved0;	/* reserved */
+    uint32_t  esp0;		/* privilege level 0 SP */
+    uint16_t  ss0;		/*   ''              SS */
+    uint16_t  reserved1;	/* reserved */
+    uint32_t  esp1;		/* privilege level 1 SP */
+    uint16_t  ss1;		/*   ''              SS */
+    uint16_t  reserved3;	/* reserved */
+    uint32_t  esp2;		/* privilege level 2 SP */
+    uint16_t  ss2;		/*   ''              SS */
+    uint16_t  reserved4;	/* reserved */
+    uint32_t  cr3;		/* control register CR3 */
+    INSTR    *eip;		/* program counter  EIP */
+    uint32_t  eflags;		/* status register  EFLAGS */
+    uint32_t  eax;		/* general register EAX */
+    uint32_t  ecx;		/* general register ECX */
+    uint32_t  edx;		/* general register EDX */
+    uint32_t  ebx;		/* general register EBX */
+    uint32_t  esp;		/* stack pointer register ESP */
+    uint32_t  ebp;		/* frame pointer register EBP */
+    uint32_t  esi;		/* general register ESI */
+    uint32_t  edi;		/* general register EDI */
+    uint16_t  es;		/* segment selector ES */
+    uint16_t  reserved5;	/* reserved */
+    uint16_t  cs;		/* segment selector CS */
+    uint16_t  reserved6;	/* reserved */
+    uint16_t  ss;		/* segment selector SS */
+    uint16_t  reserved7;	/* reserved */
+    uint16_t  ds;		/* segment selector DS */
+    uint16_t  reserved8;	/* reserved */
+    uint16_t  fs;		/* segment selector FS */
+    uint16_t  reserved9;	/* reserved */
+    uint16_t  gs;		/* segment selector GS */
+    uint16_t  reserved10;	/* reserved */
+    uint16_t  ldt;		/* segment selector LDT */
+    uint16_t  reserved11;	/* reserved */
+    uint16_t  tflag;		/* debug trap flag T */
+    uint16_t  iomapb;		/* IO map base address */
+    uint32_t  iobmap[IO_BMAP_SIZE + 1];
+    uint32_t  reserved12;	/* TSS selector */
+    uint32_t  reserved13;
+    uint32_t  reserved14;
+    uint32_t  reserved15;
+    uint32_t  reserved16;
+    uint32_t  reserved17;
+    uint32_t  reserved18;
+    uint32_t  reserved19;
+#endif
+    } TSS;
+
+typedef struct segdesc		/* segment descriptor */
+    {
+    uint16_t	limitLW;	/* limit 15:00			*/
+    uint16_t	baseLW;		/* base address 15:00		*/
+    uint8_t	baseMB;		/* base address 23:16		*/
+    uint8_t	type;		/* P, DPL, S, Type		*/
+    uint8_t	limitUB;	/* G, DB, 0, AVL, limit 23:16	*/
+    uint8_t	baseUB;		/* base address 31:24		*/
+    } SEGDESC;
+
+typedef struct taskGate		/* task gate */
+    {
+    uint16_t    reserved1;	/* reserved1 15:00		*/
+    uint16_t    segment;	/* TSS segment selector 31:16	*/
+    uint16_t	reserved2:8;	/* reserved2 07:00		*/
+    uint8_t	type:5;		/* Type 12:08			*/
+    uint8_t	dpl:2;		/* DPL 14:13			*/
+    uint8_t	p:1;		/* present 15:15		*/
+    uint16_t    reserved3;      /* reserved3 31:16		*/
+    } TGATE_DESC;
+
+typedef struct callGate		/* call gate */
+    {
+    uint16_t	offsetLo;
+    uint16_t	selector;
+    uint8_t	params;
+    uint8_t	type;
+    uint16_t	offsetHi;
+   } CGATE_DESC;
+
+typedef struct intGate		/* interrupt gate */
+    {
+    uint16_t    offsetLo;	/* offset 15:00			*/
+    uint16_t    segment;	/* segment selector 31:16	*/
+    uint8_t	reserved:5;	/* reserved2 04:00		*/
+    uint8_t	zero:3;		/* zeros 07:05			*/
+    uint8_t	type:5;		/* type 12:08			*/
+    uint8_t	dpl:2;		/* DPL 14:13			*/
+    uint8_t	p:1;		/* present 15:15		*/
+    uint16_t    offsetHi;	/* offset 31:16			*/
+    } IGATE_DESC;
+
+#define	IGATE_OFFSET00_SHIFT	00
+#define	IGATE_OFFSET01_SHIFT	16
+#define	IGATE_OFFSET(p)	((p->offsetHi << IGATE_OFFSET01_SHIFT) | p->offsetLo)
+
+
+typedef struct trapGate		/* trap gate */
+    {
+    uint16_t    offsetLo;	/* offset 15:00			*/
+    uint16_t    segment;	/* segment selector 31:16	*/
+    uint8_t	reserved:5;	/* reserved2 04:00		*/
+    uint8_t	zero:3;		/* zeros 07:05			*/
+    uint8_t	type:5;		/* type 12:08			*/
+    uint8_t	dpl:2;		/* DPL 14:13			*/
+    uint8_t	p:1;		/* present 15:15		*/
+    uint16_t    offsetHi;	/* offset 31:16			*/
+    } TRGATE_DESC;
+
+#define	TRGATE_OFFSET00_SHIFT	00
+#define	TRGATE_OFFSET01_SHIFT	16
+#define	TRGATE_OFFSET(p) ((p->offsetHi << TRGATE_OFFSET01_SHIFT) | p->offsetLo)
+
+/* convenience structure to access 32-bit fields of a 64-bit MSR */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t low;		/* low 32-bits of value */
+	uint32_t high;		/* high 32-bits of value */
+	} field;
+    uint64_t word;		/* 64-bit MSR value */
+    } MSR_VALUE;
+
+/* some common names for registers */
+
+#define fpReg		ebp	/* frame pointer */
+#define	spReg		esp	/* stack pointer */
+#define reg_pc		pc	/* program counter */
+#define reg_sp		spReg	/* stack pointer */
+#define reg_fp		fpReg	/* frame pointer */
+
+#define  G_REG_BASE	0x00	/* data reg's base offset to HREG_SET */
+#define  G_REG_OFFSET(n)	(G_REG_BASE + (n)*sizeof(uint32_t))
+#define  SR_OFFSET		G_REG_OFFSET(GREG_NUM)
+#define  PC_OFFSET		(SR_OFFSET + sizeof(uint32_t))
+
+/* register access functions */
+
+extern _RType	x86CR0Get (void);
+extern void	x86CR0Set (_RType value);
+extern _RType	x86CR2Get (void);
+extern void	x86CR2Set (_RType value);
+extern _RType	x86CR3Get (void);
+extern void	x86CR3Set (_RType value);
+extern _RType	x86CR4Get (void);
+extern void	x86CR4Set (_RType value);
+extern void	x86GdtrGet (GDTR *value);
+extern void	x86GdtrSet (GDTR *value);
+extern void	x86IdtrGet (IDTR *value);
+extern void	x86IdtrSet (IDTR *value);
+extern void	x86LdtrGet (LDTR *value);
+extern void	x86LdtrSet (LDTR *value);
+extern _RType	x86TrGet (void);
+extern void	x86TrSet (_RType value);
+extern void	x86MsrGet (uint32_t addr, uint64_t *value);
+extern void	x86MsrSet (uint32_t addr, uint64_t *value);
+extern _RType	x86FlagsGet (void);
+extern _RType	x86CsGet (void);
+extern _RType	x86SsGet (void);
+extern _RType	x86DsGet (void);
+extern _RType	x86EsGet (void);
+extern _RType	x86FsGet (void);
+extern _RType	x86GsGet (void);
+extern void	x86TscGet (uint64_t *value);
+extern void	x86GetCpuid (uint32_t operation,
+			     uint32_t *eaxValue, uint32_t *ebxValue,
+			     uint32_t *ecxValue, uint32_t *edxValue);
+
+#endif	/* _ASMLANGUAGE */
+
+/* CPU FAMILY & FPU type */
+
+#define X86CPU_386	  0	/* CPU FAMILY: 80386		*/
+#define X86CPU_486	  1	/* CPU FAMILY: 80486		*/
+#define X86CPU_PENTIUM	  2	/* CPU FAMILY: Pentium/P5	*/
+#define X86CPU_NS486	  3	/* CPU FAMILY: NS486		*/
+#define X86CPU_PENTIUMPRO 4	/* CPU FAMILY: Pentiumpro/P6	*/
+#define X86CPU_PENTIUM4   5	/* CPU FAMILY: Pentium4/P7      */
+#define X86FPU_387	  1	/* FPU: 80387			*/
+#define X86FPU_487	  2	/* FPU: 80487			*/
+
+/* offset to registers in HREG_SET */
+
+#ifdef LP64
+#define HREG_RAX		0x00
+#define HREG_RBX		0x08
+#define HREG_RCX		0x10
+#define HREG_RDX		0x18
+#define HREG_RSP		0x20
+#define HREG_RBP		0x28
+#define HREG_RSI		0x30
+#define HREG_RDI		0x38
+#define HREG_R8			0x40
+#define HREG_R9			0x48
+#define HREG_R10		0x50
+#define HREG_R11		0x58
+#define HREG_R12		0x60
+#define HREG_R13		0x68
+#define HREG_R14		0x70
+#define HREG_R15		0x78
+#define HREG_PC			0x80
+#define HREG_RFLAGS		0x88
+#define HREG_CR0		0x90
+#define HREG_CR2		0x98
+#define HREG_CR3		0xa0
+#define HREG_CR4		0xa8
+#define HREG_TSP		0xb0
+#define HREG_CS			0xb8
+#define HREG_DS			0xba
+#define HREG_SS			0xbc
+#define HREG_ES			0xbe
+#define HREG_FS			0xc0
+#define HREG_GS			0xc2
+#else
+#define HREG_EDI		0x00
+#define HREG_ESI		0x04
+#define HREG_EBP		0x08
+#define HREG_ESP		0x0c
+#define HREG_EBX		0x10
+#define HREG_EDX		0x14
+#define HREG_ECX		0x18
+#define HREG_EAX		0x1c
+#define HREG_EFLAGS		0x20
+#define HREG_PC			0x24
+#define HREG_CR0		0x28
+#define HREG_CR2		0x2C
+#define HREG_CR3		0x30
+#define HREG_CR4		0x34
+#define HREG_CS			0x38
+#define HREG_DS			0x3C
+#define HREG_SS			0x40
+#define HREG_ES			0x44
+#define HREG_FS			0x48
+#define HREG_GS			0x4C
+#define HREG_TSP		0x50
+#endif /* LP64 */
+
+/* bits on EFLAGS */
+
+#define	EFLAGS_EMPTY	0x00000020	/* empty eflags */
+#define	EFLAGS_BRANDNEW	0x00000200	/* brand new EFLAGS */
+#define	EFLAGS_N_MASK	0xffffbfff	/* N(nested task flag) bit mask */
+#define	EFLAGS_TF_MASK	0xfffffeff	/* TF(trap flag) bit mask */
+
+#define	EFLAGS_CF	0x00000001	/* CF(carry flag) bit */
+#define	EFLAGS_PF	0x00000004	/* PF(parity flag) bit */
+#define	EFLAGS_AF	0x00000010	/* AF(borrow flag) bit */
+#define	EFLAGS_ZF	0x00000040	/* ZF(sero flag) bit */
+#define	EFLAGS_SF	0x00000080	/* AF(sign flag) bit */
+#define	EFLAGS_TF	0x00000100	/* TF(trap flag) bit */
+#define	EFLAGS_IF	0x00000200	/* IF(interrupt enable flag) bit */
+#define	EFLAGS_IOPL	0x00003000	/* IOPL(IO privilege level) bits */
+#define	EFLAGS_NT	0x00004000	/* NT(nested task flag) bit */
+#define	EFLAGS_RF	0x00010000	/* RF(resume flag) bit */
+#define	EFLAGS_VM	0x00020000	/* VM(virtual 8086 mode) bit */
+#define	EFLAGS_AC	0x00040000	/* AC(alignment check) bit */
+#define	EFLAGS_VIF	0x00080000	/* VIF(virtual int flag) bit */
+#define	EFLAGS_VIP	0x00100000	/* VIP(virtual int pending) bit */
+#define	EFLAGS_ID	0x00200000	/* ID(identification flag) bit */
+
+/* control and test registers */
+
+#define CR0		1
+#define CR1		2
+#define CR2		3
+#define CR3		4
+#define TR3		5
+#define TR4		6
+#define TR5		7
+#define TR6		8
+#define TR7		9
+
+/* bits on CR0 */
+
+#define CR0_PE		0x00000001	/* protection enable */
+#define CR0_MP		0x00000002	/* math present */
+#define CR0_EM		0x00000004	/* emulation */
+#define CR0_TS		0x00000008	/* task switch */
+#define CR0_ET		0x00000010	/* extension type */
+#define CR0_NE		0x00000020	/* numeric error */
+#define CR0_WP		0x00010000	/* write protect */
+#define CR0_AM		0x00040000	/* alignment mask */
+#define CR0_NW		0x20000000	/* not write through */
+#define CR0_CD		0x40000000	/* cache disable */
+#define CR0_PG		0x80000000	/* paging */
+#define CR0_NW_NOT	0xdfffffff	/* write through */
+#define CR0_CD_NOT	0xbfffffff	/* cache disable */
+
+/* bits on CR4 */
+
+#define CR4_VME		0x00000001	/* virtual-8086 mode extensions */
+#define CR4_PVI		0x00000002	/* protected-mode virtual interrupts */
+#define CR4_TSD		0x00000004	/* timestamp disable */
+#define CR4_DE		0x00000008	/* debugging extensions */
+#define CR4_PSE		0x00000010	/* page size extensions */
+#define CR4_PAE		0x00000020	/* physical address extension */
+#define CR4_MCE		0x00000040	/* machine check enable */
+#define CR4_PGE		0x00000080	/* page global enable */
+#define CR4_PCE		0x00000100	/* performance-monitoring enable */
+#define CR4_OSFXSR	0x00000200	/* use fxsave/fxrstor instructions */
+#define CR4_OSXMMEXCEPT	0x00000400	/* streaming SIMD exception */
+#define CR4_VMXE	0x00002000	/* virtual machine extensions */
+
+/* CPUID: signature bit definitions */
+
+#define CPUID_STEPID	0x0000000f	/* processor stepping id mask	*/
+#define CPUID_MODEL	0x000000f0	/* processor model mask		*/
+#define CPUID_FAMILY	0x00000f00	/* processor family mask	*/
+#define CPUID_TYPE	0x00003000	/* processor type mask		*/
+#define CPUID_EXT_MODEL	0x000f0000	/* processor extended model mask */
+#define CPUID_EXT_FAMILY 0x0ff00000	/* processor extended family mask */
+#define CPUID_486	0x00000400	/* family: 486			*/
+#define CPUID_PENTIUM	0x00000500	/* family: Pentium		*/
+#define CPUID_PENTIUMPRO 0x00000600	/* family: Pentium PRO		*/
+#define CPUID_EXTENDED	0x00000f00	/* family: Extended		*/
+#define CPUID_PENTIUM4	0x00000000	/* extended family: PENTIUM4	*/
+#define CPUID_ORIG      0x00000000	/* type: original OEM		*/
+#define CPUID_OVERD     0x00001000	/* type: overdrive		*/
+#define CPUID_DUAL      0x00002000	/* type: dual			*/
+#define CPUID_CHUNKS	0x0000ff00	/* bytes flushed by CLFLUSH mask */
+
+/* CPUID: feature bit definitions (EDX) */
+
+#define CPUID_FPU	0x00000001	/* FPU on chip			*/
+#define CPUID_VME	0x00000002	/* virtual 8086 mode enhancement*/
+#define CPUID_DE	0x00000004	/* debugging extensions		*/
+#define CPUID_PSE	0x00000008	/* page size extension		*/
+#define CPUID_TSC	0x00000010	/* time stamp counter		*/
+#define CPUID_MSR	0x00000020	/* RDMSR and WRMSR support	*/
+#define CPUID_PAE	0x00000040	/* physical address extensions	*/
+#define CPUID_MCE	0x00000080	/* machine check exception	*/
+#define CPUID_CXS	0x00000100	/* CMPXCHG8 inst		*/
+#define CPUID_APIC	0x00000200	/* APIC on chip			*/
+#define CPUID_SEP	0x00000800	/* SEP, Fast System Call	*/
+#define CPUID_MTRR	0x00001000	/* MTRR				*/
+#define CPUID_PGE	0x00002000	/* PTE global bit		*/
+#define CPUID_MCA	0x00004000	/* machine check arch.		*/
+#define CPUID_CMOV	0x00008000	/* cond. move/cmp. inst		*/
+#define CPUID_PAT	0x00010000	/* page attribute table		*/
+#define CPUID_PSE36	0x00020000	/* 36 bit page size extension	*/
+#define CPUID_PSNUM	0x00040000	/* processor serial number	*/
+#define CPUID_CLFLUSH	0x00080000	/* CLFLUSH inst supported	*/
+#define CPUID_DTS	0x00200000	/* Debug Store			*/
+#define CPUID_ACPI	0x00400000	/* TM and SCC supported		*/
+#define CPUID_MMX	0x00800000	/* MMX technology supported	*/
+#define CPUID_FXSR	0x01000000	/* fast FP save and restore	*/
+#define CPUID_SSE	0x02000000	/* SSE supported		*/
+#define CPUID_SSE2	0x04000000	/* SSE2 supported		*/
+#define CPUID_SS	0x08000000	/* Self Snoop supported		*/
+#define CPUID_HTT	0x10000000	/* Hyper Threading Technology   */
+#define CPUID_TM	0x20000000	/* Thermal Monitor supported	*/
+#define CPUID_IA64	0x40000000	/* IA64 Capabilities		*/
+#define CPUID_PBE	0x80000000	/* Pending Break Enable		*/
+
+/* CPUID: extended feature bit definitions (ECX) */
+
+#define CPUID_GV3	0x00000080	/* Geyserville 3 supported	*/
+
+#define CPUID_SSE3	0x00000001	/* SSE3 Extensions		*/
+#define CPUID_MULDQ	0x00000002	/* support PCLMULDQ instruction	*/
+#define CPUID_DTES64	0x00000004	/* 64-bit Debug Store		*/
+#define CPUID_MON	0x00000008	/* Monitor/wait			*/
+#define CPUID_DS_CPL	0x00000010	/* CPL qualified Debug Store	*/
+#define CPUID_VMX	0x00000020	/* Virtual Machine Technology	*/
+#define CPUID_SMX	0x00000040	/* Safer Mode Extensions	*/
+#define CPUID_EST	0x00000080	/* Enhanced Speedstep Technology*/
+#define CPUID_TM2	0x00000100	/* Thermal Monitor 2 supported	*/
+#define CPUID_SSSE3	0x00000200	/* SSSE3 Extensions		*/
+#define CPUID_CID	0x00000400	/* L1 context ID		*/
+#define CPUID_CX16	0x00002000	/* CMPXCHG16B			*/
+#define CPUID_XTPR	0x00004000	/* Update control		*/
+#define CPUID_PDCM	0x00008000	/* Performance/Debug capability	*/
+#define CPUID_DCA	0x00040000	/* Direct Cache Access		*/
+#define CPUID_SSE41	0x00080000	/* SIMD Extensions 4.1		*/
+#define CPUID_SSE42	0x00100000	/* SIMD Extensions 4.2		*/
+#define CPUID_x2APIC	0x00200000	/* x2APIC supported		*/
+#define CPUID_MOVBE	0x00400000	/* MOVBE instruction supported	*/
+#define CPUID_POPCNT	0x00800000	/* POPCNT instruction supported	*/
+#define CPUID_AES	0x02000000	/* AES instruction supported	*/
+#define CPUID_XSAVE	0x04000000	/* XSAVE states supported	*/
+#define CPUID_OSXSAVE	0x08000000	/* extended state management	*/
+
+/* CPUID: offset in CPUID structure */
+
+#define CPUID_HIGHVALUE		0	/* offset to highestValue	*/
+#define CPUID_VENDORID		4	/* offset to vendorId		*/
+#define CPUID_SIGNATURE		16	/* offset to signature		*/
+#define CPUID_FEATURES_EBX	20	/* offset to featuresEbx	*/
+#define CPUID_FEATURES_ECX	24	/* offset to featuresEcx	*/
+#define CPUID_FEATURES_EDX	28	/* offset to featuresEdx	*/
+#define CPUID_CACHE_EAX		32	/* offset to cacheEax		*/
+#define CPUID_CACHE_EBX		36	/* offset to cacheEbx		*/
+#define CPUID_CACHE_ECX		40	/* offset to cacheEcx		*/
+#define CPUID_CACHE_EDX		44	/* offset to cacheEdx		*/
+#define CPUID_SERIALNO		48	/* offset to serialNo64		*/
+#define CPUID_BRAND_STR		56	/* offset to brandString[0]	*/
+
+/* MSR_VMX_EPT_VPID_CAP: EOT abd VPID capabilities */
+
+#define	EPT_VPID_RWX_X_ONLY	0	/* execute only supported */
+#define	EPT_VPID_RWX_W_ONLY	1	/* write only supported */
+#define	EPT_VPID_RWX_XW_ONLY	2	/* execute and write supported */
+
+#define	EPT_VPID_GAW_21BITS	0x01	/* guest address width: 21-bits */
+#define	EPT_VPID_GAW_30BITS	0x02	/* guest address width: 30-bits */
+#define	EPT_VPID_GAW_39BITS	0x04	/* guest address width: 39-bits */
+#define	EPT_VPID_GAW_48BITS	0x08	/* guest address width: 48-bits */
+#define	EPT_VPID_GAW_57BITS	0x10	/* guest address width: 57-bits */
+
+#define	EPT_VPID_EMT_UC		0x01	/* EMT memory: uncached memory */
+#define	EPT_VPID_EMT_WC		0x02	/* EMT memory: write cache memory */
+#define	EPT_VPID_EMT_WT		0x10	/* EMT memory: write through memory */
+#define	EPT_VPID_EMT_WP		0x20	/* EMT memory: write protect memory */
+#define	EPT_VPID_EMT_WB		0x40	/* EMT memory: write back memory */
+
+#define	EPT_VPID_INVEPT_INDV	0x01	/* individual address sync */
+#define	EPT_VPID_INVEPT_CTX	0x02	/* context sync */
+#define	EPT_VPID_INVEPT_GLOBAL	0x08	/* global sync */
+
+#define	EPT_VPID_INVVPID_INDV	0x01	/* individual address sync */
+#define	EPT_VPID_INVVPID_CTX_1	0x02	/* single-context sync */
+#define	EPT_VPID_INVVPID_CTX_A	0x08	/* all context sync */
+#define	EPT_VPID_INVVPID_CTX_G	0x20	/* single context sync, keep global */
+
+#define	EPT_VPID_SP_2MB		0x01	/* super page support: 2MB */
+#define	EPT_VPID_SP_1GB		0x02	/* super page support: 1GB */
+#define	EPT_VPID_SP_512GB	0x04	/* super page support: 512GB */
+#define	EPT_VPID_SP_256TB	0x08	/* super page support: 256TB */
+
+/* MSR, Model Specific Registers */
+
+/* MSR, P5 only */
+
+#define MSR_P5_MC_ADDR		0x0000
+#define MSR_P5_MC_TYPE		0x0001
+#define MSR_TSC			0x0010
+#define MSR_CESR                0x0011
+#define MSR_CTR0                0x0012
+#define MSR_CTR1                0x0013
+
+/* MSR, P5 and P6 */
+
+#define MSR_APICBASE		0x001b
+#define MSR_EBL_CR_POWERON	0x002a
+#define MSR_TEST_CTL		0x0033
+#define MSR_BIOS_UPDT_TRIG	0x0079
+#define MSR_BBL_CR_D0		0x0088	/* P6 only */
+#define MSR_BBL_CR_D1		0x0089	/* P6 only */
+#define MSR_BBL_CR_D2		0x008a	/* P6 only */
+#define MSR_BIOS_SIGN		0x008b
+#define MSR_PERFCTR0		0x00c1
+#define MSR_PERFCTR1		0x00c2
+#define MSR_MTRR_CAP		0x00fe
+#define MSR_BBL_CR_ADDR		0x0116	/* P6 only */
+#define MSR_BBL_CR_DECC		0x0118	/* P6 only */
+#define MSR_BBL_CR_CTL		0x0119	/* P6 only */
+#define MSR_BBL_CR_TRIG		0x011a	/* P6 only */
+#define MSR_BBL_CR_BUSY		0x011b	/* P6 only */
+#define MSR_BBL_CR_CTL3		0x011e	/* P6 only */
+#define MSR_SYSENTER_CS		0x0174	/* P6 + SEP only */
+#define MSR_SYSENTER_ESP	0x0175	/* P6 + SEP only */
+#define MSR_SYSENTER_EIP	0x0176	/* P6 + SEP only */
+#define MSR_MCG_CAP		0x0179
+#define MSR_MCG_STATUS		0x017a
+#define MSR_MCG_CTL		0x017b
+#define MSR_EVNTSEL0		0x0186
+#define MSR_EVNTSEL1		0x0187
+#define MSR_DEBUGCTLMSR		0x01d9
+#define MSR_LASTBRANCH_FROMIP	0x01db
+#define MSR_LASTBRANCH_TOIP	0x01dc
+#define MSR_LASTINT_FROMIP	0x01dd
+#define MSR_LASTINT_TOIP	0x01de
+#define MSR_ROB_CR_BKUPTMPDR6	0x01e0
+#define MSR_MTRR_PHYS_BASE0	0x0200
+#define MSR_MTRR_PHYS_MASK0	0x0201
+#define MSR_MTRR_PHYS_BASE1	0x0202
+#define MSR_MTRR_PHYS_MASK1	0x0203
+#define MSR_MTRR_PHYS_BASE2	0x0204
+#define MSR_MTRR_PHYS_MASK2	0x0205
+#define MSR_MTRR_PHYS_BASE3	0x0206
+#define MSR_MTRR_PHYS_MASK3	0x0207
+#define MSR_MTRR_PHYS_BASE4	0x0208
+#define MSR_MTRR_PHYS_MASK4	0x0209
+#define MSR_MTRR_PHYS_BASE5	0x020a
+#define MSR_MTRR_PHYS_MASK5	0x020b
+#define MSR_MTRR_PHYS_BASE6	0x020c
+#define MSR_MTRR_PHYS_MASK6	0x020d
+#define MSR_MTRR_PHYS_BASE7	0x020e
+#define MSR_MTRR_PHYS_MASK7	0x020f
+#define MSR_MTRR_FIX_00000	0x0250
+#define MSR_MTRR_FIX_80000	0x0258
+#define MSR_MTRR_FIX_A0000	0x0259
+#define MSR_MTRR_FIX_C0000	0x0268
+#define MSR_MTRR_FIX_C8000	0x0269
+#define MSR_MTRR_FIX_D0000	0x026a
+#define MSR_MTRR_FIX_D8000	0x026b
+#define MSR_MTRR_FIX_E0000	0x026c
+#define MSR_MTRR_FIX_E8000	0x026d
+#define MSR_MTRR_FIX_F0000	0x026e
+#define MSR_MTRR_FIX_F8000	0x026f
+#define MSR_MTRR_DEFTYPE	0x02ff
+#define MSR_MC0_CTL		0x0400
+#define MSR_MC0_STATUS		0x0401
+#define MSR_MC0_ADDR		0x0402
+#define MSR_MC0_MISC		0x0403
+#define MSR_MC1_CTL		0x0404
+#define MSR_MC1_STATUS		0x0405
+#define MSR_MC1_ADDR		0x0406
+#define MSR_MC1_MISC		0x0407
+#define MSR_MC2_CTL		0x0408
+#define MSR_MC2_STATUS		0x0409
+#define MSR_MC2_ADDR		0x040a
+#define MSR_MC2_MISC		0x040b
+#define MSR_MC4_CTL		0x040c
+#define MSR_MC4_STATUS		0x040d
+#define MSR_MC4_ADDR		0x040e
+#define MSR_MC4_MISC		0x040f
+#define MSR_MC3_CTL		0x0410
+#define MSR_MC3_STATUS		0x0411
+#define MSR_MC3_ADDR		0x0412
+#define MSR_MC3_MISC		0x0413
+
+/* MSR, Core2 */
+
+#define	MSR_FSB_FREQ		0x00cd
+
+/* MSR, Nehalem */
+
+#define	MSR_PLATFORM_INFO	0x00ce
+#define MSR_FLEX_RATIO		0x0194
+#define MSR_CORE_THREAD_COUNT	0x0035
+
+/* MSR, VMX specific */
+
+#define	MSR_VMX_FEATURE			0x003A
+#define	MSR_VMX_BASIC			0x0480
+#define MSR_VMX_PINBASED_CTLS_MSR	0x0481
+#define MSR_VMX_PROCBASED_CTLS_MSR	0x0482
+#define MSR_VMX_EXIT_CTLS_MSR		0x0483
+#define MSR_VMX_ENTRY_CTLS_MSR		0x0484
+#define MSR_VMX_MISC_MSR		0x0485
+#define MSR_VMX_CR0_FIXED0		0x0486
+#define MSR_VMX_CR0_FIXED1		0x0487
+#define MSR_VMX_CR4_FIXED0		0x0488
+#define MSR_VMX_CR4_FIXED1		0x0489
+#define MSR_VMX_PROCBASED_CTLS2_MSR	0x048B
+#define MSR_VMX_EPT_VPID_CAP		0x048C
+
+/* MSR, Architectural MSRs (common MSRs in IA32) */
+
+#define	IA32_P5_MC_ADDR		MSR_P5_MC_ADDR		/* P5 */
+#define	IA32_P5_MC_TYPE		MSR_P5_MC_TYPE		/* P5 */
+#define	IA32_TIME_STAMP_COUNTER	MSR_TSC			/* P5 */
+#define	IA32_PLATFORM_ID	0x0017			/* P6 */
+#define	IA32_APIC_BASE		MSR_APICBASE		/* P6 */
+#define	IA32_BIOS_UPDT_TRIG	MSR_BIOS_UPDT_TRIG	/* P6 */
+#define	IA32_BIOS_SIGN_ID	MSR_BIOS_SIGN		/* P6 */
+#define	IA32_MTRRCAP		MSR_MTRR_CAP		/* P6 */
+#define	IA32_MISC_CTL		MSR_BBL_CR_CTL		/* P6 */
+#define	IA32_SYSENTER_CS	MSR_SYSENTER_CS		/* P6 */
+#define	IA32_SYSENTER_ESP	MSR_SYSENTER_ESP	/* P6 */
+#define	IA32_SYSENTER_EIP	MSR_SYSENTER_EIP	/* P6 */
+#define	IA32_MCG_CAP		MSR_MCG_CAP		/* P6 */
+#define	IA32_MCG_STATUS		MSR_MCG_STATUS		/* P6 */
+#define	IA32_MCG_CTL		MSR_MCG_CTL		/* P6 */
+#define	IA32_MCG_EAX		0x0180			/* Pentium4 */
+#define	IA32_MCG_EBX		0x0181			/* Pentium4 */
+#define	IA32_MCG_ECX		0x0182			/* Pentium4 */
+#define	IA32_MCG_EDX		0x0183			/* Pentium4 */
+#define	IA32_MCG_ESI		0x0184			/* Pentium4 */
+#define	IA32_MCG_EDI		0x0185			/* Pentium4 */
+#define	IA32_MCG_EBP		0x0186			/* Pentium4 */
+#define	IA32_MCG_ESP		0x0187			/* Pentium4 */
+#define	IA32_MCG_EFLAGS		0x0188			/* Pentium4 */
+#define	IA32_MCG_EIP		0x0189			/* Pentium4 */
+#define	IA32_MCG_MISC		0x018a			/* Pentium4 */
+#define	IA32_THERM_CONTROL	0x019a			/* Pentium4 */
+#define	IA32_THERM_INTERRUPT	0x019b			/* Pentium4 */
+#define	IA32_THERM_STATUS	0x019c			/* Pentium4 */
+#define	IA32_MISC_ENABLE	0x01a0			/* Pentium4 */
+#define	IA32_DEBUGCTL		MSR_DEBUGCTLMSR		/* P6 */
+#define	IA32_MTRR_PHYSBASE0	MSR_MTRR_PHYS_BASE0	/* P6 */
+#define	IA32_MTRR_PHYSMASK0	MSR_MTRR_PHYS_MASK0	/* P6 */
+#define	IA32_MTRR_PHYSBASE1	MSR_MTRR_PHYS_BASE1	/* P6 */
+#define	IA32_MTRR_PHYSMASK1	MSR_MTRR_PHYS_MASK1	/* P6 */
+#define	IA32_MTRR_PHYSBASE2	MSR_MTRR_PHYS_BASE2	/* P6 */
+#define	IA32_MTRR_PHYSMASK2	MSR_MTRR_PHYS_MASK2	/* P6 */
+#define	IA32_MTRR_PHYSBASE3	MSR_MTRR_PHYS_BASE3	/* P6 */
+#define	IA32_MTRR_PHYSMASK3	MSR_MTRR_PHYS_MASK3	/* P6 */
+#define	IA32_MTRR_PHYSBASE4	MSR_MTRR_PHYS_BASE4	/* P6 */
+#define	IA32_MTRR_PHYSMASK4	MSR_MTRR_PHYS_MASK4	/* P6 */
+#define	IA32_MTRR_PHYSBASE5	MSR_MTRR_PHYS_BASE5	/* P6 */
+#define	IA32_MTRR_PHYSMASK5	MSR_MTRR_PHYS_MASK5	/* P6 */
+#define	IA32_MTRR_PHYSBASE6	MSR_MTRR_PHYS_BASE6	/* P6 */
+#define	IA32_MTRR_PHYSMASK6	MSR_MTRR_PHYS_MASK6	/* P6 */
+#define	IA32_MTRR_PHYSBASE7	MSR_MTRR_PHYS_BASE7	/* P6 */
+#define	IA32_MTRR_PHYSMASK7	MSR_MTRR_PHYS_MASK7	/* P6 */
+#define	IA32_MTRR_FIX64K_00000	MSR_MTRR_FIX_00000	/* P6 */
+#define	IA32_MTRR_FIX16K_80000	MSR_MTRR_FIX_80000	/* P6 */
+#define	IA32_MTRR_FIX16K_A0000	MSR_MTRR_FIX_A0000	/* P6 */
+#define	IA32_MTRR_FIX4K_C0000	MSR_MTRR_FIX_C0000	/* P6 */
+#define	IA32_MTRR_FIX4K_C8000	MSR_MTRR_FIX_C8000	/* P6 */
+#define	IA32_MTRR_FIX4K_D0000	MSR_MTRR_FIX_D0000	/* P6 */
+#define	IA32_MTRR_FIX4K_D8000	MSR_MTRR_FIX_D8000	/* P6 */
+#define	IA32_MTRR_FIX4K_E0000	MSR_MTRR_FIX_E0000	/* P6 */
+#define	IA32_MTRR_FIX4K_E8000	MSR_MTRR_FIX_E8000	/* P6 */
+#define	IA32_MTRR_FIX4K_F0000	MSR_MTRR_FIX_F0000	/* P6 */
+#define	IA32_MTRR_FIX4K_F8000	MSR_MTRR_FIX_F8000	/* P6 */
+#define	IA32_CR_PAT		0x0277			/* P6 */
+#define	IA32_MTRR_DEF_TYPE	MSR_MTRR_DEFTYPE	/* P6 */
+#define	IA32_PEBS_ENABLE	0x03f1			/* Pentium4 */
+#define	IA32_MC0_CTL		MSR_MC0_CTL		/* P6 */
+#define	IA32_MC0_STATUS		MSR_MC0_STATUS		/* P6 */
+#define	IA32_MC0_ADDR		MSR_MC0_ADDR		/* P6 */
+#define	IA32_MC0_MISC		MSR_MC0_MISC		/* P6 */
+#define	IA32_MC1_CTL		MSR_MC1_CTL		/* P6 */
+#define	IA32_MC1_STATUS		MSR_MC1_STATUS		/* P6 */
+#define	IA32_MC1_ADDR		MSR_MC1_ADDR		/* P6 */
+#define	IA32_MC1_MISC		MSR_MC1_MISC		/* P6 */
+#define	IA32_MC2_CTL		MSR_MC2_CTL		/* P6 */
+#define	IA32_MC2_STATUS		MSR_MC2_STATUS		/* P6 */
+#define	IA32_MC2_ADDR		MSR_MC2_ADDR		/* P6 */
+#define	IA32_MC2_MISC		MSR_MC2_MISC		/* P6 */
+#define	IA32_MC3_CTL		0x040c			/* P6, addr changed */
+#define	IA32_MC3_STATUS		0x040d			/* P6, addr changed */
+#define	IA32_MC3_ADDR		0x040e			/* P6, addr changed */
+#define	IA32_MC3_MISC		0x040f			/* P6, addr changed */
+#define	IA32_DS_AREA		0x0600			/* Pentium4 */
+#define	IA32_PERF_STAT		0x0198			/* Core2 */
+#define	IA32_EFER		0xc0000080		/* Core2 - extended feature */
+
+/* MSR, IA32_DEBUGCTL, in Pentium4, bits */
+
+#define	DBG_P7_LBR		0x00000001
+#define	DBG_P7_BTF		0x00000002
+#define	DBG_P7_TR		0x00000004
+#define	DBG_P7_BTS		0x00000008
+#define	DBG_P7_BTINT		0x00000010
+
+/* MSR, IA32_DEBUGCTL, in P6, bits */
+
+#define	DBG_P6_LBR		0x00000001
+#define	DBG_P6_BTF		0x00000002
+#define	DBG_P6_PB0		0x00000004
+#define	DBG_P6_PB1		0x00000008
+#define	DBG_P6_PB2		0x00000010
+#define	DBG_P6_PB3		0x00000020
+#define	DBG_P6_TR		0x00000040
+
+/* MSR, MSR_LASTBRANCH_TOS, in Pentium4, bits */
+
+#define	TOS_MASK		0x00000003
+
+/* MSR, IA32_MISC_ENABLE bits */
+
+#define	MSC_FAST_STRING_ENABLE	0x00000001
+#define	MSC_FOPCODE_ENABLE	0x00000004
+#define	MSC_THERMAL_MON_ENABLE	0x00000008
+#define	MSC_SPLIT_LOCK_DISABLE	0x00000010
+#define	MSC_PMON_AVAILABLE	0x00000080
+#define	MSC_BTS_UNAVAILABLE	0x00000800
+#define	MSC_PEBS_UNAVAILABLE	0x00001000
+#define	MSC_GV1_EN		0x00008000
+#define	MSC_GV3_EN		0x00010000
+#define	MSC_GV_SEL_LOCK		0x00100000
+#define	MSC_LEAF_REPORTING	0x00400000
+
+/* MSR, IA32_PEBS_ENABLE bits */
+
+#define	PEBS_METRICS		0x00001fff
+#define	PEBS_UOP_TAG		0x01000000
+#define	PEBS_ENABLE		0x02000000
+
+/* MSR, IA32_PLATFORM_ID bits (upper 32) */
+
+#define	PFM_PLATFORM_ID		0x001c0000
+#define	PFM_MOBILE_GV		0x00040000
+
+/* MSR, IA32_PLATFORM_ID bits (lower 32) */
+
+#define	PFM_MAX_VID		0x0000003f
+#define	PFM_MAX_FREQ		0x00000f80
+#define	PFM_RATIO_LOCKED	0x00008000
+#define	PFM_GV3_TM_DISABLED	0x00010000
+#define	PFM_GV3_DISABLED	0x00020000
+#define	PFM_GV1_DISABLED	0x00040000
+#define	PFM_TM_DISABLED		0x00080000
+#define	PFM_L2_CACHE_SIZE	0x06000000
+#define	PFM_SAMPLE		0x08000000
+
+/* MSR, IA32_THERM_CONTROL bits */
+
+#define	THERM_DUTY_CYCLE	0x0000000e
+#define	THERM_TCC_EN		0x00000010
+
+/* MSR, IA32_THERM_STATUS bits */
+
+#define	THERM_HOT_NOW		0x00000001
+#define	THERM_HOT_LOG		0x00000002
+
+/* MSR, IA32_THERM_INTERRUPT bits */
+
+#define	THERM_HOT_INT_EN	0x00000001
+#define	THERM_COLD_INT_EN	0x00000002
+
+/* PMC, Performance Monitoring Event Select MSR bits */
+
+/* P5 specific */
+
+#define P5PMC_PC                0x00000200
+#define P5PMC_CC_DISABLE        0x00000000
+#define P5PMC_CC_EVT_CPL012     0x00000040
+#define P5PMC_CC_EVT_CPL3       0x00000080
+#define P5PMC_CC_EVT            0x000000C0
+#define P5PMC_CC_CLK_CPL012     0x00000140
+#define P5PMC_CC_CLK_CPL3       0x00000180
+#define P5PMC_CC_CLK            0x000001C0
+
+/* P6 specific */
+
+#define PMC_USR               0x00010000
+#define PMC_OS                0x00020000
+#define PMC_E                 0x00040000
+#define PMC_PC                0x00080000
+#define PMC_INT               0x00100000
+#define PMC_EN                0x00400000
+#define PMC_INV               0x00800000
+
+/* MSR, MSR_VMX_ENTRY_CTLS bits */
+
+#define VMX_ENTRY_CTLS_IA32e		0x00000200
+#define VMX_ENTRY_CTLS_SMM		0x00000400
+#define VMX_ENTRY_CTLS_DUAL		0x00000800
+
+/* MSR, MSR_VMX_EXIT_CTLS_MSR bits */
+
+#define VMX_EXIT_CTLS_64BIT		0x00000200
+#define VMX_EXIT_CTLS_IACK		0x00008000
+
+/* MSR, IA32_EFER bits */
+
+#define EFER_SCE	0x00000001	/* SYSCALL/SYSRET (bit 0) */
+#define EFER_LME	0x00000100	/* Long mode enable (bit 8) */
+#define EFER_LMA	0x00000400	/* Long mode active (r/o) 10 */
+#define EFER_NX	0x00000800	/* No execute enable (bit 11) */
+
+/* PMC, Performance Monitoring Events */
+
+/* P5 PMC event list */
+
+#define P5PMC_DATA_RD			0x00
+#define P5PMC_DATA_WR			0x01
+#define P5PMC_DATA_TBL_MISS		0x02
+#define P5PMC_DATA_RD_MISS		0x03
+#define P5PMC_DATA_WR_MISS		0x04
+#define P5PMC_WR_HIT_M_E_STATE_LINE	0x05
+#define P5PMC_DCACHE_WR_BACK		0x06
+#define P5PMC_EXT_SNOOPS		0x07
+#define P5PMC_EXT_DCACHE_SNOOPS_HIT	0x08
+#define P5PMC_MEM_ACCESS_BOTH_PIPES	0x09
+#define P5PMC_BANK_CONFLICT		0x0A
+#define P5PMC_MISC_DMEM_IO_REF		0x0B
+#define P5PMC_CODE_RD			0x0C
+#define P5PMC_CODE_TBL_MISS		0x0D
+#define P5PMC_CODE_CACHE_MISS		0x0E
+#define P5PMC_SEGMENT_REG_LOAD		0x0F
+#define P5PMC_BRANCH			0x12
+#define P5PMC_BTB_HIT			0x13
+#define P5PMC_TAKEN_BRANCH_BTB_HIT	0x14
+#define P5PMC_PIPELINE_FLUSH		0x15
+#define P5PMC_INST_EXECUTED		0x16
+#define P5PMC_INST_EXECUTED_VPIPE	0x17
+#define P5PMC_BUS_CYC_DURATION		0x18
+#define P5PMC_WR_BUF_FULL_STALL_DURATION 0x19
+#define P5PMC_WAIT_MEM_RD_STALL_DURATION 0x1A
+#define P5PMC_STALL_ON_WR_M_E_STATE_LINE 0x1B
+#define P5PMC_LOCKED_BUS_CYC		0x1C
+#define P5PMC_IO_RD_WR_CYC		0x1D
+#define P5PMC_NONCACHE_MEM_RD		0x1E
+#define P5PMC_PIPELINE_AGI_STALL	0x1F
+#define P5PMC_FLOPS			0x22
+#define P5PMC_BK_MATCH_DR0		0x23
+#define P5PMC_BK_MATCH_DR1		0x24
+#define P5PMC_BK_MATCH_DR2		0x25
+#define P5PMC_BK_MATCH_DR3		0x26
+#define P5PMC_HW_INT			0x27
+#define P5PMC_DATA_RD_WR		0x28
+#define P5PMC_DATA_RD_WR_MISS		0x29
+#define P5PMC_BUS_OWNER_LATENCY		0x2A
+#define P5PMC_BUS_OWNER_TRANSFER	0x2A
+#define P5PMC_MMX_INST_UPIPE		0x2B
+#define P5PMC_MMX_INST_VPIPE		0x2B
+#define P5PMC_CACHE_M_LINE_SHARE	0x2C
+#define P5PMC_CACHE_LINE_SHARE		0x2C
+#define P5PMC_EMMS_INTS_EXECUTED	0x2D
+#define P5PMC_TRANS_MMX_FP_INST		0x2D
+#define P5PMC_BUS_UTIL_PROCESSOR_ACT	0x2D
+#define P5PMC_WR_NOCACHEABLE_MEM	0x2E
+#define P5PMC_SATURATING_MMX_INST	0x2F
+#define P5PMC_SATURATION_PERFORMED	0x2F
+#define P5PMC_NUM_CYC_NOT_HALT_STATE	0x30
+#define P5PMC_DCACHE_TLB_MISS_STALL_DUR	0x30
+#define P5PMC_MMX_INST_DATA_RD		0x31
+#define P5PMC_MMX_INST_DATA_RD_MISS	0x31
+#define P5PMC_FP_STALL_DUR		0x32
+#define P5PMC_TAKEN_BRANCH		0x32
+#define P5PMC_D1_STARV_FIFO_EMPTY	0x33
+#define P5PMC_D1_STARV_ONE_INST_FIFO	0x33
+#define P5PMC_MMX_INST_DATA_WR		0x34
+#define P5PMC_MMX_INST_DATA_WR_MISS	0x34
+#define P5PMC_PL_FLUSH_WRONG_BR_PREDIC	0x35
+#define P5PMC_PL_FLUSH_WRONG_BR_PREDIC_WB 0x35
+#define P5PMC_MISALIGN_DMEM_REF_MMX	0x36
+#define P5PMC_PL_STALL_MMX_DMEM_RD	0x36
+#define P5PMC_MISPREDIC_UNPREDIC_RET	0x37
+#define P5PMC_PREDICED_RETURN		0x37
+#define P5PMC_MMX_MUL_UNIT_INTERLOCK	0x38
+#define P5PMC_MOVD_MOVQ_STALL_PREV_MMX	0x38
+#define P5PMC_RETURN			0x39
+#define P5PMC_BTB_FALSE_ENTRY		0x3A
+#define P5PMC_BTB_MISS_PREDIC_NOT_TAKEN_BR 0x3A
+#define P5PMC_FULL_WR_BUF_STALL_MMX	0x3B
+#define P5PMC_STALL_MMX_WR_E_M_STATE_LINE 0x3B
+
+/* P6 PMC event list */
+
+#define	PMC_DATA_MEM_REFS		0x43
+#define	PMC_DCU_LINES_IN		0x45
+#define	PMC_DCU_M_LINES_IN		0x46
+#define	PMC_DCU_M_LINES_OUT		0x47
+#define	PMC_DCU_MISS_OUTSTANDING	0x48
+#define	PMC_IFU_IFETCH			0x80
+#define	PMC_IFU_IFETCH_MISS		0x81
+#define	PMC_ITLB_MISS			0x85
+#define	PMC_IFU_MEM_STALL		0x86
+#define	PMC_IDL_STALL			0x87
+#define	PMC_L2_IFETCH			0x28
+#define	PMC_L2_LD			0x29
+#define	PMC_L2_ST			0x2a
+#define	PMC_L2_LINES_IN			0x24
+#define	PMC_L2_LINES_OUT		0x26
+#define	PMC_L2_M_LINES_INM		0x25
+#define	PMC_L2_M_LINES_OUTM		0x27
+#define	PMC_L2_RQSTS			0x2e
+#define	PMC_L2_ADS			0x21
+#define	PMC_L2_DBUS_BUSY		0x22
+#define	PMC_L2_DBUS_BUSY_RD		0x23
+#define	PMC_BUS_DRDY_CLOCKS		0x62
+#define	PMC_BUS_LOCK_CLOCKS		0x63
+#define	PMC_BUS_REQ_OUTSTANDING		0x60
+#define	PMC_BUS_TRAN_BRD		0x65
+#define	PMC_BUS_TRAN_RFO		0x66
+#define	PMC_BUS_TRANS_WB		0x67
+#define	PMC_BUS_TRAN_IFETCH		0x68
+#define	PMC_BUS_TRAN_INVAL		0x69
+#define	PMC_BUS_TRAN_PWR		0x6a
+#define	PMC_BUS_TRANS_P			0x6b
+#define	PMC_BUS_TRANS_IO		0x6c
+#define	PMC_BUS_TRAN_DEF		0x6d
+#define	PMC_BUS_TRAN_BURST		0x6e
+#define	PMC_BUS_TRAN_ANY		0x70
+#define	PMC_BUS_TRAN_MEM		0x6f
+#define	PMC_BUS_DATA_RCV		0x64
+#define	PMC_BUS_BNR_DRV			0x61
+#define	PMC_BUS_HIT_DRV			0x7a
+#define	PMC_BUS_HITM_DRV		0x7b
+#define	PMC_BUS_SNOOP_STALL		0x7e
+#define	PMC_FLOPS			0xc1
+#define	PMC_FP_COMP_OPS_EXE		0x10
+#define	PMC_FP_ASSIST			0x11
+#define	PMC_MUL				0x12
+#define	PMC_DIV				0x13
+#define	PMC_CYCLES_DIV_BUSY		0x14
+#define	PMC_LD_BLOCKS			0x03
+#define	PMC_SB_DRAINS			0x04
+#define	PMC_MISALIGN_MEM_REF		0x05
+#define	PMC_INST_RETIRED		0xc0
+#define	PMC_UOPS_RETIRED		0xc2
+#define	PMC_INST_DECODER		0xd0
+#define	PMC_HW_INT_RX			0xc8
+#define	PMC_CYCLES_INT_MASKED		0xc6
+#define	PMC_CYCLES_INT_PENDING_AND_MASKED 0xc7
+#define	PMC_BR_INST_RETIRED		0xc4
+#define	PMC_BR_MISS_PRED_RETIRED	0xc5
+#define	PMC_BR_TAKEN_RETIRED		0xc9
+#define	PMC_BR_MISS_PRED_TAKEN_RETIRED	0xca
+#define	PMC_BR_INST_DECODED		0xe0
+#define	PMC_BTB_MISSES			0xe2
+#define	PMC_BR_BOGUS			0xe4
+#define	PMC_BACLEARS			0xe6
+#define	PMC_RESOURCE_STALLS		0xa2
+#define	PMC_PARTIAL_RAT_STALLS		0xd2
+#define	PMC_SEGMENT_REG_LOADS		0x06
+#define	PMC_CPU_CLK_UNHALTED		0x79
+#define	PMC_UMASK_00			0x00
+#define	PMC_UMASK_0F			0x0f
+#define	PMC_UMASK_SELF			0x00
+#define	PMC_UMASK_ANY			0x20
+
+/* MTRR related defines */
+
+#define MTRR_UC				0x00
+#define MTRR_WC				0x01
+#define MTRR_WT				0x04
+#define MTRR_WP				0x05
+#define MTRR_WB				0x06
+#define MTRR_E				0x00000800
+#define MTRR_FE				0x00000400
+#define MTRR_VCNT			0x000000FF
+#define MTRR_FIX_SUPPORT		0x00000100
+#define MTRR_WC_SUPPORT			0x00000400
+
+/* MCA related defines */
+
+#define	MCG_CTL_P			0x00000100
+#define	MCG_COUNT			0x000000ff
+#define	MCG_MCIP			0x00000004
+#define	MCG_EIPV			0x00000002
+#define	MCG_RIPV			0x00000001
+#define	MCI_VAL				0x80000000
+#define	MCI_OVER			0x40000000
+#define	MCI_UC				0x20000000
+#define	MCI_EN				0x10000000
+#define	MCI_MISCV			0x08000000
+#define	MCI_ADDRV			0x04000000
+#define	MCI_PCC				0x02000000
+
+/* segment descriptor: types for application code, data segment */
+
+#define	SEG_DATA_RO_U		0x00000000	/* read only */
+#define	SEG_DATA_RW_U		0x00000200	/* read write */
+#define	SEG_DATA_RO_D		0x00000400	/* read only expand down */
+#define	SEG_DATA_RW_D		0x00000600	/* read write expand down */
+#define	SEG_CODE_EO		0x00000800	/* exec only */
+#define	SEG_CODE_ER		0x00000a00	/* exec read */
+#define	SEG_CODE_EO_C		0x00000c00	/* exec only conform. */
+#define	SEG_CODE_ERO_C		0x00000e00	/* exec read only conform. */
+
+/* segment descriptor: types for system segment and gate */
+
+#define SEG_LDT			0x00000200	/* LDT */
+#define TASK_GATE		0x00000500	/* Task Gate */
+#define TSS32			0x00000900	/* 32 bit TSS (available) */
+#define CALL_GATE32		0x00000c00	/* 32 bit CALL gate */
+#define INT_GATE32		0x00000e00	/* 32 bit INT  gate */
+#define TRAP_GATE32		0x00000f00	/* 32 bit TRAP gate */
+
+/* segment descriptor: descriptor type */
+
+#define SYS_DESC		0x00000000	/* system descriptors */
+#define APP_DESC		0x00001000	/* application descriptors */
+
+/* segment descriptor: privilege level */
+
+#define DPL0			0x00000000	/* privilege level 0 */
+#define DPL1			0x00002000	/* privilege level 1 */
+#define DPL2			0x00004000	/* privilege level 2 */
+#define DPL3			0x00006000	/* privilege level 3 */
+
+/* segment descriptor: privilege level */
+
+#define SEG_P			0x00008000	/* present */
+
+/* segment descriptor: default operation size */
+
+#define DB_16			0x00000000	/* 16 bit segment */
+#define DB_32			0x00400000	/* 32 bit segment */
+
+/* segment descriptor: granularity */
+
+#define G_BYTE			0x00000000	/* byte granularity */
+#define G_4K			0x00800000	/* 4K byte granularity */
+
+/* segment descriptor: mask bits for attribute */
+
+#define SEG_ATTR_MASK		0x00f0ff00	/* mask bits */
+
+/* segment descriptor: pSegdesc->type: present and busy bit */
+
+#define SEG_PRESENT		0x80		/* present bit */
+#define SEG_BUSY		0x02		/* busy bit */
+
+/* segment register requested privilege levels */
+
+#define	SEG_RPL_RING_0		0x0
+#define	SEG_RPL_RING_1		0x1
+#define	SEG_RPL_RING_2		0x2
+#define	SEG_RPL_RING_3		0x3
+#define	SEG_RPL_MASK		0x3
+
+/* IDT related macros */
+
+#define IDT_TASK_GATE		0x0000e500	/* task gate: P=1, DPL=3, task id */
+
+#define IDT_TRAP_GATE		0x0000ef00	/* trap gate: P=1, DPL=3, trap id */
+#define IDT_INT_GATE		0x0000ee00	/* int gate: P=1, DPL=3, int id */
+
+/* TSS related macros */
+
+#define TSS_LINK		  0	/* offset: link to previous task */
+#define TSS_ESP0		  4	/* offset: privilege level 0 SP */
+#define TSS_SS0			  8	/* offset:   ''              SS */
+#define TSS_ESP1		 12	/* offset: privilege level 1 SP */
+#define TSS_SS1			 16	/* offset:   ''              SS */
+#define TSS_ESP2		 20	/* offset: privilege level 2 SP */
+#define TSS_SS2			 24	/* offset:   ''              SS */
+#define TSS_CR3			 28	/* offset: control register CR3 */
+#define TSS_EIP			 32	/* offset: program counter  EIP */
+#define TSS_EFLAGS		 36	/* offset: status register  EFLAGS */
+#define TSS_EAX			 40	/* offset: general register EAX */
+#define TSS_ECX			 44	/* offset: general register ECX */
+#define TSS_EDX			 48	/* offset: general register EDX */
+#define TSS_EBX			 52	/* offset: general register EBX */
+#define TSS_ESP			 56	/* offset: stack pointer ESP */
+#define TSS_EBP			 60	/* offset: frame pointer EBP */
+#define TSS_ESI			 64	/* offset: general register ESI */
+#define TSS_EDI			 68	/* offset: general register EDI */
+#define TSS_ES			 72	/* offset: segment selector ES */
+#define TSS_CS			 76	/* offset: segment selector CS */
+#define TSS_SS			 80	/* offset: segment selector SS */
+#define TSS_DS			 84	/* offset: segment selector DS */
+#define TSS_FS			 88	/* offset: segment selector FS */
+#define TSS_GS			 92	/* offset: segment selector GS */
+#define TSS_LDT			 96	/* offset: segment selector LDT */
+#define TSS_TFLAG		100	/* offset: debug trap flag T */
+#define TSS_IOMAPB		102	/* offset: IO map base address */
+#define TSS_IOBMAP		104	/* offset: IO bit map array */
+
+#define TSS_BUSY_MASK	0xfffffdff	/* TSS descriptor BUSY bit mask */
+
+/* VMX realted defines */
+
+#define	VMX_MEMORY_TYPE_UC	0	/* Strong uncacheable (UC) */
+#define	VMX_MEMORY_TYPE_WB	6	/* Write back (WB) */
+
+/* inline version of intLock()/intUnlock() : used in mmuI86Lib.c */
+
+#define INT_LOCK(oldLevel) \
+    WRS_ASM ("pushf ; popl %0 ; andl $0x00000200, %0 ; cli" \
+    : "=rm" (oldLevel) : /* no input */ : "memory")
+
+#define INT_UNLOCK(oldLevel) \
+    WRS_ASM ("testl $0x00000200, %0 ; jz 0f ; sti ; 0:" \
+    : /* no output */ : "rm" (oldLevel) : "memory")
+
+#endif	/* __INCx86regsh */
diff --git a/include/asm-x86/vbi.h b/include/asm-x86/vbi.h
new file mode 100644
index 0000000..97e2f47
--- /dev/null
+++ b/include/asm-x86/vbi.h
@@ -0,0 +1,137 @@
+/*
+ * x86 vbi.h - x86 tool dependent headers
+ *
+ * Copyright 2007-2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef __INCsysX86Asmh
+#define __INCsysX86Asmh
+
+/*
+ * The following definitions are used for symbol name compatibility.
+ *
+ * When #if 1, sources are assembled assuming the compiler
+ * you are using does not generate global symbols prefixed by "_".
+ * (e.g. elf/dwarf)
+ *
+ * When #if 0, sources are assembled assuming the compiler
+ * you are using generates global symbols prefixed by "_".
+ * (e.g. coff/stabs)
+ */
+
+#if	TRUE
+#define FUNC(sym)		sym
+#define FUNC_LABEL(sym)		sym:
+#else
+#define FUNC(sym)		_##sym
+#define FUNC_LABEL(sym)		_##sym:
+#endif
+
+#define VAR(sym)		FUNC(sym)
+
+/*
+ * These macros are used to declare assembly language symbols that need
+ * to be typed properly(func or data) to be visible to the OMF tool.
+ * So that the build tool could mark them as an entry point to be linked
+ * correctly.  This is an elfism. Use #if 0 for a.out.
+ */
+
+#if	TRUE
+#define GTEXT(sym) FUNC(sym) ;  .type   FUNC(sym),@function
+#define GDATA(sym) FUNC(sym) ;  .type   FUNC(sym),@object
+#else
+#define GTEXT(sym) FUNC(sym)
+#define GDATA(sym) FUNC(sym)
+#endif
+
+#ifdef LP64
+/* x86-64 ABI */
+#define INTARG1_64 %rdi
+#define INTARG2_64 %rsi
+#define INTARG3_64 %rdx
+#define INTARG4_64 %rcx
+#define INTARG5_64 %r8
+#define INTARG6_64 %r9
+
+#define INTARG1_32 %edi
+#define INTARG2_32 %esi
+#define INTARG3_32 %edx
+#define INTARG4_32 %ecx
+#define INTARG5_32 %r8d
+#define INTARG6_32 %r9d
+
+#define INTARG1_16 %di
+#define INTARG2_16 %si
+#define INTARG3_16 %dx
+#define INTARG4_16 %cx
+
+#define INTRET1	%rax
+#define INTRET2	%rdx
+
+/* these should not be used by x86-64 ABI-compliant code */
+#define SP_ARG0		0
+#define SP_ARG1		4
+#define SP_ARG2		8
+#define SP_ARG3		12
+
+#else
+/* fp offsets to arguments */
+
+#define ARG1	8
+#define ARG1W	10
+#define ARG2	12
+#define ARG2W	14
+#define ARG3	16
+#define ARG3W	18
+#define ARG4	20
+#define ARG5	24
+#define ARG6	28
+#define ARG7	32
+#define ARG8	36
+#define ARG9	40
+#define ARG10	44
+#define ARG11	48
+#define ARG12	52
+
+#define DARG1	8		/* double arguments */
+#define	DARG1L	12
+#define DARG2	16
+#define DARG2L	20
+#define DARG3	24
+#define DARG3L	28
+#define DARG4	32
+#define DARG4L	36
+
+/* sp offsets to arguments */
+
+#define SP_ARG0		0
+#define SP_ARG1		4
+#define SP_ARG1W	6
+#define SP_ARG2		8
+#define SP_ARG2W	10
+#define SP_ARG3		12
+#define SP_ARG3W	14
+#define SP_ARG4		16
+#define SP_ARG5		20
+#define SP_ARG6		24
+#define SP_ARG7		28
+#define SP_ARG8		32
+#define SP_ARG9		36
+#define SP_ARG10	40
+#define SP_ARG11	44
+#define SP_ARG12	48
+#endif
+
+#define _WRS_ASM(x) __asm volatile (x)
+
+#endif /* __INCsysX86Asmh */
diff --git a/include/vbi/arch.h b/include/vbi/arch.h
new file mode 100644
index 0000000..a21a675
--- /dev/null
+++ b/include/vbi/arch.h
@@ -0,0 +1,34 @@
+/*
+ * arch.h - vbi architecture specific definitions
+ *
+ * Copyright 2008 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef _VBI_ARCH_H
+#define _VBI_ARCH_H
+
+/* endian types selectable by the arch specific header files */
+
+#define __VBI_LITTLE_ENDIAN 1234  /* least-significant byte first         */
+#define __VBI_BIG_ENDIAN    4321  /* most-significant byte first          */
+#define __VBI_PDP_ENDIAN    3412  /* LSB first in word, MSW first in long */
+
+/* include the appropriate arch specific header file */
+#include <asm/arch_vbi.h>
+
+/* ensure the arch has specified a byte ordering */
+#if !defined(__VBI_BYTE_ORDER)
+# error: Architecture has not defined a byte order!
+#endif
+
+#endif /* _VBI_ARCH_H */
diff --git a/include/vbi/compat.h b/include/vbi/compat.h
new file mode 100644
index 0000000..a9d587b
--- /dev/null
+++ b/include/vbi/compat.h
@@ -0,0 +1,234 @@
+/*
+ * compat.h - virtual board compatibility support definitions
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+/*
+ * This introduces some of the non-linux like things into scope for
+ * those VBI users who have an expectation that they will be present.
+ * None of the default linux VBI code needs to include this file.
+ * Only those source files which expect default/legacy VBI API
+ * content need to include this file.
+ */
+
+
+#ifndef _VBI_COMPAT_H
+#define _VBI_COMPAT_H
+
+/*
+ * These were particularly confusing, since there are similarly named
+ * macros used to map the bits within these structs.  Eeech.
+ */
+#define VB_CONTROL	struct vb_control
+#define VB_CONFIG	struct vb_config
+#define VB_STATUS	struct vb_status
+
+#define VB_INT_INFO		struct vb_int_info
+#define VB_MEM_INFO		struct vb_mem_info
+#define VB_SM_INFO		struct vb_sm_info
+#define VB_DEV_INFO		struct vb_dev_info
+#define VB_DEV_INT_INFO		struct vb_dev_int_info
+#define VB_DEV_REGSET_INFO	struct vb_dev_regset_info
+
+#define VBI_MSG_INFO		struct vbi_msg_info
+#define VBI_MSG_CTL		struct vbi_msg_ctl
+#define VBI_MEM_CTL		struct vbi_mem_ctl
+
+#define VBI_CTX_STATS		struct vbi_ctx_stats
+#define VBI_VTLB_OP		struct vbi_vtlb_op
+#define VBI_VTLB_CONTROL	struct vbi_vtlb_control
+#define VBI_VTLB_CR3_CACHE	struct vbi_vtlb_cr3_cache
+
+#define VBI_CLK_HOOK_INFO	struct vbi_clk_hook
+#define VBI_CLK_HOOK_INFO_PTR	struct vbi_clk_hook *
+
+#define VB_ARCH_CONTROL_REGS	struct vb_arch_ctrl_regs
+#define VB_ARCH_STATUS_REGS	struct vb_arch_stat_regs
+
+#define VIOAPIC_ENTRY		struct vioapic_entry
+#define VIOAPIC_ID		union vioapic_id
+#define VIOAPIC_VERSION		union vioapic_version
+#define VIOAPIC_REDIR_LOW	union vioapic_redir_low
+#define VIOAPIC_REDIR_HIGH	union vioapic_redir_high
+
+#define VBI_MSG_HDR		struct vbi_msg_hdr
+#define MSG_PDC			struct msg_pdc
+#define MSG_PDC_REPLY		struct msg_pdc_reply
+
+#define VB_TIMESTAMP		uint64_t
+#define vbiStatus_t		int32_t
+#define vbiIrq_t		uint32_t
+#define vbiVb_t			uint32_t
+#define vbiCore_t		int32_t
+#define vbiCtx_t		int32_t
+#define vbiPhysAddr_t		uint64_t
+#define vbiGuestPhysAddr_t	void *
+#define vbiIntState_t		int32_t
+#define vbiMemAttr_t		int32_t
+#define vbiVector_t		int32_t
+#define vbiCoreSet_t		uint32_t
+#define vbiRegSet_t		uint32_t
+
+/*
+ * struct fields and similar
+ */
+#define vbControlRegs		vb_control_regs
+#define vbStatusRegs		vb_status_regs
+#define vbStatus		vb_status
+#define vbControl		vb_control
+
+#define vioapicLow		vioapic_low
+#define vioapicHigh		vioapic_high
+
+#define wrhvControl		wr_control
+#define wrhvConfig		wr_config
+#define wrhvStatus		wr_status
+#define wrhvVbStatus		wr_vb_status
+#define wrhvVbControl		wr_vb_control
+#define wrhvVbConfig		wr_vb_config
+
+#define memoryAliasSize		mem_alias_size
+#define memoryAliasAddress	mem_alias_addr
+#define physicalMemorySize	phys_mem_size
+
+#define numInt			num_int
+#define numSm			num_sm
+#define numMem			num_mem
+#define sizeIn			size_in
+#define sizeOut			size_out
+
+#define resetPC			reset_pc
+#define bootCount		boot_count
+#define boardName		board_name
+#define boardType		board_type
+
+#define tickTimerFrequency	tick_freq
+#define tickCount		tick_count
+#define timeStampFrequency	stamp_freq
+
+#define intDisable		irq_disable
+#define newIntDisable		next_irq_disable
+#define oldIntDisable		prev_irq_disable
+#define intLevelDisable		level_irq_disable
+#define intName			irq_name
+#define intNumber		irq_num
+#define intDirection		irq_dir
+#define intPending		irq_pend
+#define intPendingType		irq_pend_type
+
+/*
+ * function calls, etc.
+ */
+#define vbiVbSuspend		vbi_vb_suspend
+#define vbiVbResume		vbi_vb_resume
+#define vbiVbRestart		vbi_vb_restart
+#define vbiVbReset		vbi_vb_reset
+#define vbiVbRemote		vbi_vb_remote
+
+#define vbiVbRegisterRead	vbi_vb_read_reg
+#define vbiVbRegisterWrite	vbi_vb_write_reg
+#define vbiVbMemoryRead		vbi_vb_read_mem
+#define vbiVbMemoryWrite	vbi_vb_write_mem
+#define vbiVbBoardConfigFind	vbi_vb_find_board_config
+
+#define vbiVcoreIntRed_op	vbi_vcore_irq_redirect
+#define vbiDebugShellStart	vbi_shell_start_debug
+#define vbiIoapicOp		vbi_io_apic_op
+#define vbiIoapicIoctl		vbi_io_apic_ioctl
+#define vbiHyIoctl		vbi_hy_ioctl
+#define vbiCtxctl		vbi_ctx_ctl
+#define vbiVbMgmt		vbi_vb_mgmt
+
+#define vbiSend			vbi_send
+#define vbiReceive		vbi_receive
+#define vbiReply		vbi_reply
+#define vbiPanic		vbi_panic
+#define vbiPs			vbi_ps
+#define vbiKputs		vbi_kputs
+#define vbiKputc		vbi_kputc
+
+#define vbiIcacheFlush		vbi_flush_icache
+#define vbiDcacheFlush		vbi_flush_dcache
+#define vbiCacheTextUpdate	vbi_update_text_cache
+#define vbiTlbFlush		vbi_flush_tlb
+#define vbiVtlbOp		vbi_vtlb_op
+
+#define vbiDirectInterruptEOI	vbi_direct_IRQ_EOI
+#define vbiIntVCoreUnlock	vbi_vcore_irq_unlock
+#define vbiIntVCoreLock		vbi_vcore_irq_lock
+#define vbiIntVCoreStateGet	vbi_vcore_irq_state
+#define vbiExcBaseSet		vbi_set_exc_base
+#define vbiExcOffsetsSet	vbi_set_exc_offset
+#define vbiExcOffsetsGet	vbi_get_exc_offset
+#define vbiMemAttrSet		vbi_set_mem_attr
+#define vbiMemAttrGet		vbi_get_mem_attr
+
+#define vbiVmmuConfig		vbi_config_vmmu
+#define vbiVmmuEnable		vbi_enable_vmmu
+#define vbiVmmuDisable		vbi_disable_vmmu
+#define vbiVmmuTlbLoad		vbi_tlb_load_vmmu
+#define vbiVmmuTlbFlush		vbi_tlb_flush_vmmu
+
+#define vbiNsOp			vbi_ns_op
+#define vbiNsLookup		vbi_ns_lookup
+#define vbiNsRegister		vbi_ns_register
+#define vbiNsUnregister		vbi_ns_unregister
+
+#define vbiConfigShow		vbi_show_cfg
+#define vbiControlShow		vbi_show_ctrl
+#define vbiCtrlRegsDisplay	vbi_disp_ctrl_regs
+#define vbiInterruptsShow	vbi_show_irq
+#define vbiMemoryShow		vbi_show_mem
+#define vbiSharedMemoryShow	vbi_show_shmem
+#define vbiStatusShow		vbi_show_stat
+#define vbiStsRegsDisplay	vbi_disp_status_regs
+
+#define vbiVersionMajor		vbi_version_major
+#define vbiVersionMinor		vbi_version_minor
+#define vbiVersionMaint		vbi_version_maint
+#define vbiCreationDate		vbi_creation_date
+#define vbiRuntimeVersion	vbi_runtime_version
+#define vbiRuntimeName		vbi_runtime_name
+#define vbiVersion		vbi_version
+
+#define vbiExcStub		vbi_exc_stub
+#define vbiGuestDmaAddrGet	vbi_get_guest_dma_addr
+#define vbiGuestPhysToPhysAddr	vbi_guest_phys_to_phys
+#define vbiIdle			vbi_idle
+#define vbiInit			vbi_init
+#define vbiMmuAttrSet		vbi_set_mmu_attr
+
+#define vbiCorePrvMemFind	vbi_find_core_prv_mem
+#define vbiIntVecFind		vbi_find_irq
+#define vbiMemRegionFind	vbi_find_mem
+#define vbiShmemRegionFind	vbi_find_shmem
+
+#define vbiVioapicAddrGet	vbi_get_vioapic_addr
+#define vbiVioapicDisplay	vbi_disp_vioapic
+#define vbiVioapicIntAck	vbi_ack_vioapic_irq
+#define vbiVioapicIntMask	vbi_mask_vioapic_irq
+#define vbiVioapicIntRedirect	vbi_redir_vioapic_irq
+#define vbiVioapicIntPending	vbi_get_pending_vioapic_irq
+#define vbiVioapicIntSend	vbi_send_vioapic_irq
+#define vbiVioapicIntUnmask	vbi_unmask_vioapic_irq
+#define vbiVioapicVcoreIntSend	vbi_send_vcore_vioapic_irq
+#define vbiVioapicVectorGet	vbi_get_vioapic_vec
+#define vbiVioapicVectorSet	vbi_set_vioapic_vec
+
+#define vbiDeviceCount		vbi_dev_count
+#define vbiDeviceGet		vbi_get_dev
+#define vbiDeviceInterruptGet	vbi_get_dev_interrupt
+#define vbiDeviceRegisterSetGet	vbi_get_dev_registers
+
+#endif  /* _VBI_COMPAT_H */
diff --git a/include/vbi/cpu_types.h b/include/vbi/cpu_types.h
new file mode 100644
index 0000000..dbceb30
--- /dev/null
+++ b/include/vbi/cpu_types.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2007-2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef _VBI_CPU_TYPES_H
+#define _VBI_CPU_TYPES_H
+
+/* define the cpu types that we currently support */
+#define PPC85XX		1
+#define PENTIUM		2
+#define ARM1136		3
+#define MIPSI64R2	4
+#define PPCE500MC	5
+
+#ifndef _ASMLANGUAGE
+
+/* MIPS64R2 specific types */
+#if (CPU == MIPSI64R2)
+
+#define CPU_MIPS_32BIT ((CPU==_VX_MIPS32) || \
+			    (CPU==MIPSI2) || \
+			    (CPU==MIPSI32) || \
+			    (CPU==MIPSI32R2))
+
+#define CPU_MIPS_64BIT ((CPU==MIPS64) || \
+			    (CPU==MIPSI3) || \
+			    (CPU==MIPSI64) || \
+			    (CPU==MIPSI64R2))
+
+typedef unsigned long	INSTR;		/* 32 bit word-aligned instructions */
+
+#if (CPU_MIPS_32BIT)
+typedef unsigned int	_RType;		/* registers are 32 bits */
+#elif (CPU_MIPS_64BIT)
+typedef unsigned long	_RType;		/* registers are 64 bits */
+#else /* CPU_MIPSxxBIT */
+#error "Invalid CPU value"
+#endif
+
+#endif /* CPU == MIPSI64R2 */
+
+/* PowerPC specific types */
+#if (CPU == PPC85XX) || (CPU == PPCE500MC)
+typedef unsigned long	INSTR;		/* 32 bit word-aligned instructions */
+typedef unsigned int	_RType;		/* register type */
+#endif
+
+/* Pentium specific types */
+#if (CPU == PENTIUM)
+typedef unsigned char	INSTR;		/* char instructions */
+					/* register type */
+#if defined (LP64)
+typedef unsigned long	_RType;
+#else
+typedef unsigned int	_RType;
+#endif
+#endif /* CPU == PENTIUM */
+
+#if (CPU == ARM1136)
+typedef unsigned long	INSTR;		/* 32 bit word-aligned instructions */
+typedef unsigned int	_RType;		/* register type */
+#endif
+
+#endif /* _ASMLANGUAGE */
+
+#endif /* _VBI_CPU_TYPES_H */
diff --git a/include/vbi/device.h b/include/vbi/device.h
new file mode 100644
index 0000000..f4486b5
--- /dev/null
+++ b/include/vbi/device.h
@@ -0,0 +1,44 @@
+/* device.h - Device Configuration VBI */
+
+/* Copyright 2007-2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+
+/* DESCRIPTION
+ *
+ * VBI calls used by Guest OSs to discover Guest Devices
+ *
+ */
+
+#ifndef _VBI_DEVICE_H
+#define _VBI_DEVICE_H
+
+
+#ifndef _ASMLANGUAGE
+
+extern uint32_t vbi_dev_count(void);
+extern uint32_t vbi_get_dev(uint32_t deviceIndex,
+				struct vb_dev_info **vbiDevInfo);
+extern uint32_t vbi_get_dev_interrupt(uint32_t deviceIndex, uint32_t intIndex,
+					struct vb_dev_int_info **vbiIntDetails);
+extern uint32_t vbi_get_dev_registers(uint32_t deviceIndex,
+					uint32_t regSetIndex,
+					struct vb_dev_regset_info
+						**vbiRegSetDetails);
+extern uint32_t vbi_get_dev_device_tree_source(uint32_t deviceIndex,
+					uint32_t deviceTreeSourceIndex,
+					struct vb_dev_device_tree_source_info
+						**vbiDeviceTreeSourceDetails);
+#endif
+
+#endif  /* _VBI_DEVICE_H */
diff --git a/include/vbi/errors.h b/include/vbi/errors.h
new file mode 100644
index 0000000..e091625
--- /dev/null
+++ b/include/vbi/errors.h
@@ -0,0 +1,57 @@
+/*
+ * errors.h - vbi errors
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef _VBI_ERRORS_H
+#define _VBI_ERRORS_H
+
+#define VBI_ERRORS_START		0
+
+/* generic vbi errors */
+
+#define VBI_INVALID_VERSION		(VBI_ERRORS_START + (-1))
+#define VBI_INVALID_IRQ			(VBI_ERRORS_START + (-2))
+#define VBI_INVALID_SHMEM		(VBI_ERRORS_START + (-3))
+#define VBI_INVALID_MEM			(VBI_ERRORS_START + (-4))
+
+/* vbi Exceptions error */
+
+#define VBI_EXC_ERROR_START		(VBI_ERRORS_START + (-1000))
+#define VBI_EXCBASE_SET_ERROR		(VBI_EXC_ERROR_START + (-1))
+
+/* VIOAPIC errors   */
+#define VBI_VIOAPIC_ERROR_START		(VBI_EXC_ERROR_START + (-100))
+#define VBI_VIOAPIC_NULL		(VBI_VIOAPIC_ERROR_START + (-1))
+#define VBI_VIOAPIC_IRQ_OUTBOUND	(VBI_VIOAPIC_ERROR_START + (-2))
+#define VBI_VIOAPIC_IRQ_INVALID_DIR	(VBI_VIOAPIC_ERROR_START + (-3))
+#define VBI_VIOAPIC_UNAVAIL		(VBI_VIOAPIC_ERROR_START + (-4))
+
+
+/* VB MANAGEMENT errors */
+
+#define VBI_VBMGMT_ERROR_START		(VBI_VIOAPIC_ERROR_START +  (-100))
+#define VBI_ERR_VBMGMT_VB_INVALID	VBI_VBMGMT_ERROR_START +    (-1)
+#define VBI_ERR_VBMGMT_INVALID_ARG	VBI_VBMGMT_ERROR_START +    (-2)
+#define VBI_ERR_VBGMT_RESET_FAILED	VBI_VBMGMT_ERROR_START +    (-3)
+#define VBI_ERR_VBMGMT_CTX_INVALID	VBI_VBMGMT_ERROR_START +    (-4)
+
+/* VB Device Driver errors */
+
+#define VBI_DEVDRV_ERROR_START		(VBI_VBMGMT_ERROR_START +  (-100))
+#define VBI_ERR_ADD_RETRY		(VBI_DEVDRV_ERROR_START +  (-1))
+#define VBI_ERR_DEVDRV_NULL_NAME	(VBI_DEVDRV_ERROR_START +  (-2))
+#define VBI_ERR_DEVDRV_NULL_HANDLE	(VBI_DEVDRV_ERROR_START +  (-3))
+
+#endif /* _VBI_ERRORS_H */
diff --git a/include/vbi/interface.h b/include/vbi/interface.h
new file mode 100644
index 0000000..4923d8e
--- /dev/null
+++ b/include/vbi/interface.h
@@ -0,0 +1,665 @@
+/*
+ * interface.h - virtual board interface header file
+ *
+ * Copyright (c) 2007-2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+/*
+DESCRIPTION
+This module defines the data structures used for information flow between the
+Wind River Hypervisor and a virtual board. There are three structures employed
+for this purpose:
+
+		configuration status control
+
+The configuration structure is the first data exchanged between a given
+virtual board and Hypervisor kernel. The pointers to the status and
+control structures are derived from the configuration structure. It
+contains pointers to the status, control and other information about
+resources assigned to a virtual board.  The configuration data is shared
+accross the cores in the same virtual board unlike the data in the
+control and status structure which may be different for each core.  The
+information in the configuration structure is static in the sense that
+the data it contains remain unmodified at least during the life of a
+boot cycle.
+
+The status structure is used to inform a virtual core at runtime about
+the state it is excecuting (interrupts, vmmu, elapsed time etc...).
+
+The control structure is put in place as a fast method to pass
+information from the VB to Hypervisor or vis-versa. For examples during
+a virtual board context switch the control structure allows to store the
+incoming virtual board context setting before the virtual board sends a
+Hypercall using VBI_CTX_LOAD().
+
+Hypervisor passes (as parameter) a pointer of the configuration
+structure to the entry function of the virtual core and a boot option
+flag.
+
+The VBI library provides a initialization function vbi_init() to ensures
+that Hypervisor version number is compatible with the VBI library in
+use. If the versions match then the configuration, status and control
+pointers are stored respectively to wr_vb_config, wr_status and
+wr_vb_control.
+
+Therefore a virtual board must always call vbi_init() before accessing
+any data provided by Hypervisor nor send a hypercall to it. Refer to to
+vbi_init() description in the VBI API description document for more
+information.
+
+Once the VBI library is initialized the virtual board should employ the
+provided macros in order to access the fieds in wr_vb_config,
+wr_vb_status and wr_vb_control data structures. Accessing these
+structures via the VBI function guaranties source level compatibily
+between VBI versions.
+
+A guest OS should port vbi_init(), the access macros along with the
+necessary header files where the data structrures layout is defined.
+
+To be aware: Changing the order of the field this structure may have
+serious impact on the integrity of the system. It exists hand crafted
+macros to match the C structures offset. Therefore any change should be
+reflected in the macros
+
+When a virtual core boots the VMMU is not enbled but a programmer may
+choose to turn-on the VMMU. In that scenario proper care must be taken
+to ensure that the address where the control, status or configureation
+structure is reflected in the VMMU mapping. Technically these area
+should be treated as I/O region therefore it is encouraged that they are
+identity mapped.
+
+*/
+
+#ifndef _VBI_INTERFACE_H
+#define _VBI_INTERFACE_H
+
+#include <vbi/types.h>
+#include <vbi/arch.h>
+
+/* VB versioning information */
+#define	VBI_VERSION_MAJOR	2	/* major version */
+#define	VBI_VERSION_MINOR	1	/* minor version */
+#define	VBI_VERSION_MAINT	0	/* maintenance version */
+
+/* macro to align guest fields for a 64-bit hypervisor */
+#if defined(LP64)
+#define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+			   __attribute__(( aligned(8) )) \
+			   decl_var
+#else
+#if (__VBI_BYTE_ORDER == __VBI_LITTLE_ENDIAN)
+#define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+			    __attribute__(( aligned(8) )) \
+			    decl_var; \
+			    uint32_t pad_var
+#else
+#define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+			    __attribute__(( aligned(8) )) \
+			    uint32_t pad_var; \
+			    decl_var
+#endif
+#endif
+
+#undef VB_DEBUG  /* define it to turn on debugging */
+#ifdef VB_DEBUG
+#define VB_DEBUG_MSG(fmt, args...)    printk(fmt, ##args)
+#else
+#define VB_DEBUG_MSG(fmt, args...)
+#endif
+
+/* Hard limits for now */
+#define VB_MAX_VIRTUAL_BOARDS		1024
+#define VB_MAX_BUSES			1024
+
+#define VB_MAX_CORES			8
+
+/* Type definitions for all name identifer strings in the hypervisor */
+#define VB_NAMELEN		64
+
+#ifndef	_ASMLANGUAGE
+
+#define VB_MAX_BOOTLINE_LENGTH		256
+
+#endif
+
+/* Virtual Interrupt Controller definitions */
+
+/*
+ * The maximum number of interrupt sources allowed is defined by
+ * VB_MAX_INTERRUTS. Care must be taken if this is changed, since some
+ * algorithms and data structures will require modifications and become
+ * more complex
+ */
+#define VB_MAX_INTERRUPTS		256
+
+/*
+ * The maximum number of associated data stored with each interrupt.
+ * This can be modified without any impacts, tho it should not be
+ * set to 0
+ */
+#define VB_MAX_INTERRUPT_DATA		16
+
+/* Structure offsets for assembler */
+#if !defined(_WRHV_ARCH_HAS_CTRL_REGS)
+#define VB_CONTROL_REG_STRUCT_END	0
+#endif
+
+#define VB_CONTROL_INT_DISABLE		((4*0) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_NEW_INT_DISABLE	((4*1) + VB_CONTROL_REG_STRUCT_END)
+#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
+#define VB_CONTROL_VMMU0_HIGH		((4*2) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU0		((4*3) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU1_HIGH		((4*4) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU1		((4*5) + VB_CONTROL_REG_STRUCT_END)
+#else
+#define VB_CONTROL_VMMU0		((4*2) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU0_HIGH		((4*3) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU1		((4*4) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU1_HIGH		((4*5) + VB_CONTROL_REG_STRUCT_END)
+#endif /* __VBI_BYTE_ORDER */
+
+/* Bit Mask definitions for VB_STATUS_INT_PENDING */
+#define VB_STATUS_INT_PENDING_INT	1	/* Virtual Interrupt */
+#define VB_STATUS_INT_PENDING_TICK	2	/* Tick interrupt */
+#define VB_STATUS_INT_PENDING_DIRECT_INT	4   /* Direct Interrupt */
+
+/* Assembler offsets for vb_status */
+#if !defined(_WRHV_ARCH_HAS_STATUS_REGS)
+#define VB_STATUS_REG_STRUCT_END	0
+#endif
+
+#define VB_STATUS_INT_PENDING		((4*0) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_RESERVED1		((4*1) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_TIMESTAMP_HIGH	((4*2) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_TIMESTAMP_LOW		((4*3) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_OLD_INT_DISABLE	((4*4) + VB_STATUS_REG_STRUCT_END)
+#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
+#define VB_STATUS_VMMU0_HIGH		((4*5) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU0		((4*6) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU1_HIGH		((4*7) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU1		((4*8) + VB_STATUS_REG_STRUCT_END)
+#else
+#define VB_STATUS_VMMU0		((4*5) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU0_HIGH		((4*6) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU1		((4*7) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU1_HIGH		((4*8) + VB_STATUS_REG_STRUCT_END)
+#endif /* __VBI_BYTE_ORDER */
+
+/* Assembler offsets for vb_config */
+#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
+#define VB_CONFIG_VBSTATUS		(((2+0) * 8) + 4)
+#define VB_CONFIG_VBCONTROL		(((2+1) * 8) + 4)
+#define VB_CONFIG_SMINFO		(((2+2) * 8) + 4)
+#define VB_CONFIG_MEMINFO		(((2+3) * 8) + 4)
+#define VB_CONFIG_INTINFO		(((2+4) * 8) + 4)
+#else
+#define VB_CONFIG_VBSTATUS		((2+0) * 8)
+#define VB_CONFIG_VBCONTROL		((2+1) * 8)
+#define VB_CONFIG_SMINFO		((2+2) * 8)
+#define VB_CONFIG_MEMINFO		((2+3) * 8)
+#define VB_CONFIG_INTINFO		((2+4) * 8)
+#endif /* __VBI_BYTE_ORDER */
+
+/* Defines for vbIntInfo irq_dir field */
+#define VB_INPUT_INT	1
+#define VB_OUTPUT_INT	2
+
+/*
+ * Defines for the second parameter passed to the startup program
+ * in a virtual board by the hypervisor.
+ */
+#define VB_BOOT_COLD	1
+#define VB_BOOT_WARM	2
+#define VB_BOOT_RESTART	3
+
+/* define 128 entries for all platforms */
+#define VIOAPIC_MAX_REDTABLE_ENTRIES	VB_MAX_INTERRUPTS
+
+/* define valid guest to guest register operations */
+
+#define VBI_REG_SET_32BIT	0
+#define VBI_REG_SET_64BIT	1
+
+#ifndef	_ASMLANGUAGE
+
+/*
+ * vb_control - Virtual board cores control structure
+ *
+ * vb_control is a data type that defines a virtual core's control structure.
+ * This is called the control structure because a core uses to modify it's
+ * state. The code running in the context of a virtual core puts the desired
+ * setting in this control and passes to Hypervisor via Hypercall mechanism.
+ * It is suggested to use the provided APIs for manipulating the virtual core
+ * control structure instead of directly accessing it's members.
+ * Typically use cases for this structure are for following:
+ *
+ *
+ * During context switch for setting the incoming context's register state.
+ * For more information about this refer to VBI_CTX_LOAD() description in the
+ * architecture supplement API documentation.
+ *
+ * Locking/unlocking the virtual core interrupts.
+ *
+ * Loading the VMMU configuration data.
+ *
+ * VIOAPIC configuration registers.
+ *
+ * The control structure definition is generic accross the various architecture
+ * flavours supported by Hypervisor with the exception of the emulated
+ * registers.
+ *
+ * There is an architecture specific extention available via a pointer of type
+ * vb_arch_stat_regs to accomodate the registers unique for a given hardware
+ * platform.
+ *
+ * However that does imply that other fields defined in this structure are used
+ * in every architecture. A field is considered generic if it is usefull at
+ * least to two CPU families but not necessary to all CPUs.
+ *
+ * The VIOAPIC is the only field that is meaningful accross all architectures.
+ * Note that some architectures like Intel with VT technology don't require
+ * emulated registers. The pointer of emulated registers is included only if
+ * _WRHV_ARCH_HAS_CTRL_REGS flag is defined. The control structure is mapped
+ * with read/write access attribute for the purpose of serving as duplex
+ * communication channel between Hypervisor and a virtual core. This mechanism
+ * is fall back when it is not possible to use registers for transmitting data
+ * from the virtual core to Hypervisor or vis-versa. More information about
+ * vb_arch_ctrl_regs may be found in the architecture supplement document.
+ *
+ *
+ * Control structure graphical illustration
+ *
+ *    ______________
+ *   |              |
+ *   |              |<------- 64bits - pointer to arch specific registers
+ *   |              |          (See architecture supplement documentation)
+ *   |--------------|
+ *   |              |<------- 32bits -  interrupt state flag
+ *   |--------------|
+ *   |              |<------- 32bits - virtual core to be loaded context's
+ *   |--------------|                  interrupt state
+ *   |              |
+ *   |              |<------- 64bits - pointer to VMMU configuration
+ *   |--------------|
+ *   |              |<------- 64bits - pointer to additional VMMU
+ *   |              |                  configuration (reserved for enhancement)
+ *   |--------------|
+ *   |              | <------ 64bits - VIOAPIC information header
+ *   |              |                  (internal use only)
+ *   |              |
+ *   |--------------|<------- 32bits - Pending interrupt vector number
+ *   |______________|
+ *
+ *
+ */
+
+struct vb_control
+{
+
+#ifdef  _WRHV_ARCH_HAS_CTRL_REGS
+	struct vb_arch_ctrl_regs vb_control_regs;
+#endif
+
+	uint32_t irq_disable;		/*  0: -1 => Disable all interrupts */
+	uint32_t next_irq_disable;		/*  1: New value for ->irq_disable */
+
+					/*  2: VMMU 0 table for ctxt switch */
+	VB_ALIGN_FIELD_64 (void *vmmu0, pad1);
+
+					/*  3: VMMU 1 table for ctxt switch */
+	VB_ALIGN_FIELD_64 (void *vmmu1, pad2);
+
+	uint32_t level_irq_disable;	/* interrupt level enabling */
+
+					/* Virtual I/O APIC */
+	VB_ALIGN_FIELD_64 (void *vIoapic, pad3);
+
+	uint32_t irq_pend;		/* actual virtual interrupt pending */
+
+};
+
+
+/*
+ * vb_status - Virtual board's core status structure
+ *
+ * vb_status is a C data type structure that provides the definition of an area
+ * where the state of a given core is posted by Hypervisor before a virtual
+ * core is scheduled to run. The fields of this structure are architecture
+ * agnostic.
+ *
+ * A pointer is provided to accomodate anything that is specific to the
+ * underlying hardware. The architecture specific structure is included only
+ * if _WRHV_ARCH_HAS_STATUS_REGS flag is defined. The data type
+ * VB_STATUS_ARCH_REGS holding the architecture dependent registers is defined
+ * by a file pulled vbi/arch.h at compile type according to CPU value.
+ *
+ * The definition of vb_arch_stat_regs can be found in the architecture
+ * supplement documentation.
+ *
+ * The purpose of this structure is to inform a virtual core at runtime the
+ * status of a core's time variant data such as:
+ *
+ * Interrupts state
+ *
+ * current interrupt state
+ *
+ * previous interrupt state if the core is in an ISR context
+ *
+ * The pending vector number if any
+ *
+ * A free running clock timestamp
+ *
+ * Virtual core elapsed timer ticks
+ *
+ * Current VMMU configuration
+ *
+ *
+ * Control structure graphical illustration
+ *
+ *        ______________
+ *       |		|
+ *       |		|<-------64bits - VB_ARCH_STATUS_REGS; arch dependent
+ *       |		|		structure pointer
+ *       |--------------|
+ *       |		|<-------32bits - irq_pend; pending vector number
+ *       |--------------|
+ *       |//////////////|<-------32bits - Reserved for future enhencements
+ *       |--------------|
+ *       |		|<-------64bits - timeStamp; free running clock ticks
+ *       |		|
+ *       |--------------|
+ *       |		|<-------32bits - prev_irq_disable; interrupt state before
+ *       |--------------|		   an interrupt was injected
+ *       |		|<-------32bits -
+ *       |--------------|
+ *       |		|
+ *       |		|<-------64bits - vmmu0; current VMMU configuration
+ *       |--------------|
+ *       |		|<-------64bits - vmmu1; reserved for future use
+ *       |		|
+ *       |--------------|
+ *       |		|<-------64bits - tick_count; elapsed virtual core ticks
+ *       |		|
+ *       |--------------|
+ *
+ */
+
+struct vb_status {
+
+#ifdef _WRHV_ARCH_HAS_STATUS_REGS
+	struct vb_arch_stat_regs vb_status_regs;
+#endif
+
+	/* Bits indicating which interrupts are pending */
+	uint32_t irq_pend_type;
+
+	/* reserved field for future use, required for timeStamp alignment */
+	uint32_t reserved1;
+
+	/* Timestamp when last interrupt was delivered */
+	uint64_t timeStamp;
+
+	/*
+	 * Interrupt registers
+	 * When the hypervisor interrupts a VB, it saves the following
+	 * information here for use by the virtual board.
+	 *
+	 * value of control->irq_disable at time of the interrupt.
+	 * control->irq_disable is set to -1 by WRHV at the time of delivery of
+	 * the interrupt
+	 */
+	uint32_t prev_irq_disable;
+
+	/* VMMU tables which were active when an MMU exception occurred */
+	VB_ALIGN_FIELD_64 (void *vmmu0, pad1);
+	VB_ALIGN_FIELD_64 (void *vmmu1, pad2);
+
+	/* Virtual Board clock tick count */
+	uint64_t tick_count;
+
+	/* number of times this core has booted */
+	uint32_t boot_count;
+
+	/* initial program load flag */
+	uint32_t ipl;
+
+	/* The simulatror flag  */
+	uint32_t sim;
+
+};
+
+#define ALIGN_DEV_INFO_SIZE	8	/* vb_dev_info, vb_dev_int_info,
+					 * vb_dev_regset_info, etc, will
+					 * all start at an 8-byte alignment */
+
+/* Configuration information for devices */
+struct vb_dev_info {
+	char deviceName[VB_NAMELEN];	/* the name of the GI Thread */
+	char deviceTemplate[VB_NAMELEN];/* the name of the template */
+	uint16_t deviceClass;		/* class: serial, net, block */
+	uint32_t deviceType;		/* ADD or Emulated or Passthrough */
+	uint32_t numInterrupts;		/* Number of Interrupts */
+	uint32_t numRegSets;		/* Number of Register Sets */
+	uint32_t numDeviceTreeSources;	/* Number of Device Tree Sources */
+	uint32_t intInfoOffset;		/* offset to Interrupt Info */
+	uint32_t regSetInfoOffset;	/* offset to Register Set Info */
+	uint32_t deviceTreeSourceInfoOffset;
+};
+
+/* Configuration information for devices - Interrupts */
+
+struct vb_dev_int_info
+{
+	uint32_t indexDevice;		/* which device does this belong to */
+	char intName[VB_NAMELEN];	/* Interrupt Name */
+	char intType[VB_NAMELEN];	/* Interrupt Type */
+	int32_t intNum;			/* Interrupt Number */
+	uint32_t intSense;		/* level or edge */
+	uint32_t intPolarity;		/* active high or low */
+};
+
+/* Configuration information for devices - Register Sets */
+
+struct vb_dev_regset_info
+{
+	uint32_t indexDevice;		/* which device does this belong to */
+	char regSetName[VB_NAMELEN];	/* RegSet Name */
+	uint64_t regSetAddress;		/* Guest Physical Address */
+	uint64_t regSetLength;		/* Length */
+	uint64_t regSetAlignment;	/* Alignment of Physical Address */
+	uint64_t regSetType;		/* IO, MEM, PCI memory */
+};
+
+/* Configuration information for devices - DeviceTreeSource */
+
+struct vb_dev_device_tree_source_info
+{
+	uint32_t indexDevice;		/* which device does this belong to */
+	char deviceTreeSourceName[VB_NAMELEN];	/* DTS Name */
+};
+
+/* Configuration information for interrupts */
+struct vb_int_info
+{
+	char irq_name[VB_NAMELEN];	/* the name of this interrupt */
+	uint16_t irq_dir;	/* interrupt direction: INPUT_INT, OUTPUT_INT */
+	uint16_t irq_num;	/* the local VB interrupt number */
+	uint32_t irq_core;	/* the receiving core for this incomming int */
+};
+
+/* Information about a shared memory region */
+struct vb_sm_info
+{
+	char name[VB_NAMELEN];	/* the name of the shared memory region */
+				/* the vbphysical address of the region */
+	VB_ALIGN_FIELD_64 (void *addr, pad1);
+	uint32_t length;	/* the length in bytes of the region */
+	uint32_t attr;		/* the MMU attributes of the region */
+	uint32_t type;		/* shared memory type field */
+				/* id's of connected boards */
+	VB_ALIGN_FIELD_64 (void *boardIds, pad2);
+};
+
+/* Information for the memory map info */
+struct vb_mem_info
+{
+	char name[VB_NAMELEN];	/* the name of the memory region */
+				/* the vbphysical address of the region */
+	VB_ALIGN_FIELD_64 (void *addr, pad1);
+	uint32_t length;	/* the length in bytes of the region */
+	uint32_t attr;		/* the MMU attributes of the region */
+	char type[VB_NAMELEN];	/* the type of the region */
+};
+
+
+/*
+ * Fixed information about the configuration of a Virtual Board as seen by
+ * the Virtual Board itself.  The address of this structure is passed as the
+ * first parameter to the virtual board when it is started at its entry point.
+ */
+#define ACCESS_PRIV_READ_ONLY		0
+#define ACCESS_PRIV_READ_WRITE		1
+#define MAX_VB_CONFIG_REGIONS		16
+
+struct config_page_map
+{
+	void *address;
+	size_t size;
+	uint32_t accessPriv;
+};
+
+struct vb_config
+{
+
+	/*
+	 *  structure versioning information
+	 */
+
+	uint32_t major;	/* major revision number */
+	uint32_t minor;	/* minor revision number */
+	uint32_t maint;	/* maintenance revision number */
+	uint32_t pad;
+
+	/*
+	 *  pointers to secondary configuration structures
+	 */
+
+	/* read-only status information */
+	VB_ALIGN_FIELD_64 (struct vb_status *vb_status, pad1);
+
+	/* read-write control information */
+	VB_ALIGN_FIELD_64 (struct vb_control *vb_control, pad2);
+
+	/* shared memory information (memory map) */
+	VB_ALIGN_FIELD_64 (struct vb_sm_info *sharedMemoryRegionsConfigAddress, pad3);
+
+	/* memory regions information (memory map) */
+	VB_ALIGN_FIELD_64 (struct vb_mem_info *memoryRegionsConfigAddress, pad4);
+
+	/* information about incoming and outgoing interrupt connections */
+	VB_ALIGN_FIELD_64 (struct vb_int_info *interruptConfiguration, pad5);
+
+	/*
+	 *  general board specific configuration information
+	 */
+
+	uint32_t pid;		/* hypervisor context id */
+	uint32_t boardID;	/* board ID from the XML configuration */
+
+	int32_t supervisoryMode;/* board is running in privileged mode */
+
+	char board_name[VB_NAMELEN];/* the name of this board */
+	uint32_t board_type;	/* the type of this board */
+	uint32_t boot_count;	/* number of times this core has booted */
+
+				/* entry point for this VB */
+	VB_ALIGN_FIELD_64 (void *reset_pc, pad6);
+
+	/*
+	 *  virtual core specific information
+	 */
+
+	uint32_t coreId;	/* virtual core cpu id */
+	uint32_t numCores;	/* number of virtual cores */
+	uint32_t corePrivateSize;/* size of core private memory */
+				/* pointer to core private memory */
+	VB_ALIGN_FIELD_64 (void *corePrivate, pad8);
+
+	/*
+	 *  main memory configuration settings
+	 */
+
+	uint32_t phys_mem_size;	/* the vbPhysical size of RAM */
+	uint32_t mem_alias_addr;	/* address to which memory is aliased */
+	uint32_t mem_alias_size;	/* size of aliases memory */
+	uint32_t num_mem;		/* number of memory regions */
+
+	/*
+	 *  shared memory configuration settings
+	 */
+
+	/* number of shared memory regions */
+	uint32_t num_sm;
+
+	/* shared memory state information */
+	VB_ALIGN_FIELD_64 (void *sharedMemoryRegionsStateAddress, pad7);
+
+	/*
+	 *  clock and interrupt configuration
+	 */
+
+	/* the frequency of the periodic tick interrupt */
+	uint32_t tick_freq;	/* ticks per second */
+
+	/* the frequency of the timestamp */
+	uint32_t stamp_freq;	/* ticks per second */
+
+	/* number of interrupts connected to this board */
+	uint32_t num_ints;
+
+	/*
+	 *  misc settings
+	 */
+
+	/* OS specific boot line */
+	char bootLine[VB_MAX_BOOTLINE_LENGTH];
+
+	/* spare 32-bit fields for future use */
+	uint32_t spare32[16];
+
+	/* spare 64-bit fields for future use */
+	uint64_t spare64[16];
+
+	/* direct function call interface table */
+
+#if defined (_WRHV_ARCH_HAS_VB_SYSTBL)
+	VB_ALIGN_FIELD_64 (struct vb_syscall *vbSyscallTable, pad9);
+	VB_ALIGN_FIELD_64 (struct vb_syscall_stub2 *vbSyscallStub2, pad10);
+#endif
+
+	/* information about devices */
+
+	VB_ALIGN_FIELD_64 (struct vb_dev_info *deviceConfiguration, pad11);
+
+	/* number of devices connected to this board */
+
+	uint32_t numDevices;
+
+	/* provide mappings for all configuration pages */
+	struct config_page_map configPageMap[MAX_VB_CONFIG_REGIONS];
+	uint32_t configPageNum;
+
+};
+
+#endif /*_ASMLANGUAGE */
+#endif  /* _VBI_INTERFACE_H */
diff --git a/include/vbi/interrupt.h b/include/vbi/interrupt.h
new file mode 100644
index 0000000..b5c5fc0
--- /dev/null
+++ b/include/vbi/interrupt.h
@@ -0,0 +1,33 @@
+/*
+ * interrupt.h - utility functions to read interrupt configuration data
+ *
+ * Copyright 2007 Wind River Systems, Inc.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+/*
+DESCRIPTION
+
+This header file declares the vbi API for utility functions for reading the
+interrupts configuration data.
+
+*/
+
+#ifndef _VBI_INTERRUPT_H
+#define _VBI_INTERRUPT_H
+
+#ifndef	_ASMLANGUAGE
+
+extern uint32_t vbi_find_irq(char *irq_name, int32_t irq_dir);
+
+#endif /* _ASMLANGUAGE */
+
+#endif  /* _VBI_INTERRUPT_H */
diff --git a/include/vbi/io_apic.h b/include/vbi/io_apic.h
new file mode 100644
index 0000000..6315db0
--- /dev/null
+++ b/include/vbi/io_apic.h
@@ -0,0 +1,105 @@
+/*
+ * io_apic.h - virtual IO APIC definitions
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef	_VBI_IO_APIC_H
+#define	_VBI_IO_APIC_H
+
+#ifndef	_ASMLANGUAGE
+
+/* data structures */
+
+/* IO APIC ID register */
+union vioapic_id
+{
+	struct
+	{
+		uint32_t reserved1:24;	/* reserved bits */
+		uint32_t IOAPIC_id:4;	/* apic id */
+		uint32_t reserved2:4;	/* reserved bits */
+	} field;
+	uint32_t value;
+};
+
+
+/* IO APIC Version Register */
+
+union vioapic_version
+{
+	struct
+	{
+		uint32_t version:8;		/* version identifier */
+		uint32_t reserved1:8;		/* reserved bits */
+		uint32_t maxRedirEntry:8;	/* max # of entries - 1, or
+						 * number of IRQ pins - 1 */
+		uint32_t reserved2:8;		/* reserved bits */
+	} field;
+
+	uint32_t value;
+};
+
+/* Virtual IO APIC redirection table entry. Split into high/low 32 */
+
+union vioapic_redir_high
+{
+	struct
+	{
+		uint32_t reserved:24;	/* reserved bits */
+		uint32_t destination:8;	/* destination field */
+	} field;
+	uint32_t value;
+};
+
+union vioapic_redir_low
+{
+	struct
+	{
+		uint32_t vector:8;	/* vector number */
+		uint32_t deliveryMode:3;/* delivery mode:
+					 * fixed, lowest, SMI, reserved, NMI,
+					 * INIT, reserved, extInt */
+		uint32_t destMode:1;	/* dest mode: 0=physical, 1=logical */
+		uint32_t delivStatus:1;	/* delivery status: 0=idle, 1=pending*/
+		uint32_t polarity:1;	/* polarity: 0=high active */
+		uint32_t irr:1;		/* rem. IRR (lvl only): 1 before LAPIC
+					 * accepts level, 0 after EOI */
+		uint32_t trigger:1;	/* 0=edge, 1=level */
+		uint32_t mask:1;	/* 1=masked */
+		uint32_t reserved:15;	/* reserved bits */
+	} field;
+	uint32_t value;
+};
+
+struct vioapic_entry
+{
+	union vioapic_redir_low vioapic_low;
+	union vioapic_redir_high vioapic_high;
+};
+
+typedef struct vioapic
+{
+	union vioapic_id id;
+	union vioapic_version version;
+	uint32_t arb;
+	uint32_t boot;
+	uint32_t reserved[6];
+	struct vioapic_entry entry[VIOAPIC_MAX_REDTABLE_ENTRIES];
+} VIOAPIC;
+
+#endif /* _ASMLANGUAGE */
+
+#endif	/* _VBI_IO_APIC_H */
+
+
diff --git a/include/vbi/pdc.h b/include/vbi/pdc.h
new file mode 100644
index 0000000..b1f0f2c
--- /dev/null
+++ b/include/vbi/pdc.h
@@ -0,0 +1,115 @@
+/* pdc.h - Process Data Channel definitions */
+
+/* Copyright 2009-2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+
+/* DESCRIPTION
+ *
+ * Message format for Process Data Channel (PDC)
+ * from Stub Device Driver (SDD)
+ * to Actual Device Driver Guest Interface (ADD-GI)
+ */
+
+#ifndef _VBI_PDC_H
+#define _VBI_PDC_H
+
+
+#ifndef _ASMLANGUAGE
+
+
+typedef VBI_NS_HANDLE vbi_pdc_handle;
+
+struct vbi_msg_hdr
+{
+	uint32_t msgId;
+	uint32_t msgArg;
+};
+
+struct msg_pdc
+{
+	struct vbi_msg_hdr hdr;
+	VB_ALIGN_FIELD_64 (void *buf, pad1);
+	VB_ALIGN_FIELD_64 (size_t buflen, pad2);
+	uint16_t request;
+	uint16_t op;
+#ifdef DEV_ASYNC_IOCTL
+	VB_ALIGN_FIELD_64 (uint64_t token, pad3); /* token */
+#endif
+};
+
+struct msg_pdc_reply
+{
+	struct vbi_msg_hdr hdr;
+	uint32_t   status;
+	uint32_t   dataVal;
+};
+
+#ifdef DEV_ASYNC_IOCTL
+struct ioctlOp
+{
+	void *buf;
+	uint64_t token;
+	VB_ALIGN_FIELD_64 (uint32_t op, pad7);
+}
+#endif /* DEV_ASYNC_IOCTL */
+
+struct intrDeviceChannelBuffer
+{
+	VB_ALIGN_FIELD_64 (void *rxBuf, pad1);
+	VB_ALIGN_FIELD_64 (size_t rxBufLen, pad2);
+	VB_ALIGN_FIELD_64 (void *txBuf, pad3);
+	VB_ALIGN_FIELD_64 (size_t txBufLen, pad4);
+	uint64_t rxBufRdPtr;
+	uint64_t rxBufWrPtr;
+	uint64_t txBufRdPtr;
+	uint64_t txBufWrPtr;
+#ifdef DEV_ASYNC_IOCTL
+	VB_ALIGN_FIELD_64 (struct ioctlOp *ioctlBuf, pad5);
+	VB_ALIGN_FIELD_64 (size_t ioctlBufLen, pad6);
+	uint64_t ioctlBufRdPtr;
+	uint64_t ioctlBufWrPtr;
+#endif
+};
+
+#define SYS_PDC_REQUEST_OK		0
+#define SYS_PDC_REQUEST_FAILED		-1
+
+#define PDC_IOCTL_SIO_BAUD_SET		1
+#define PDC_IOCTL_SIO_MODE_SET		2
+#define PDC_IOCTL_SIO_HW_OPTS_SET	3
+#define PDC_IOCTL_SIO_HUP		4
+#define PDC_IOCTL_SIO_OPEN		5
+
+#define PDC_IOCTL_SIO_REQUEST_RESPONSE  0x8000
+#define PDC_IOCTL_SIO_GET_IER		(PDC_IOCTL_SIO_REQUEST_RESPONSE | 2)
+
+typedef enum {
+	PDC_REQUEST_MIN		= 1,
+	PDC_REQUEST_IOCTL	= 1,
+	PDC_REQUEST_READ	= 2,
+	PDC_REQUEST_WRITE	= 3,
+	PDC_REQUEST_INIT	= 4,
+	PDC_REQUEST_MAX		= 4
+} vbi_pdc_request;
+
+extern int32_t vbi_pdc_op(vbi_pdc_handle pdcHandle, vbi_pdc_request requestType,
+			 uint32_t ioctlOp, void *bufferPtr, size_t bufferLen,
+			 uint64_t token);
+
+extern int32_t vbiPdcInit(const char *instanceName, vbi_pdc_handle *pPdcHandle);
+
+
+#endif
+
+#endif  /* _VBI_PDC_H */
diff --git a/include/vbi/private.h b/include/vbi/private.h
new file mode 100644
index 0000000..f1206b7
--- /dev/null
+++ b/include/vbi/private.h
@@ -0,0 +1,47 @@
+/*
+ * private.h - virtual board interface private definitions
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef _VBI_PRIVATE_H
+#define _VBI_PRIVATE_H
+
+#include <linux/types.h>
+#include <linux/linkage.h>
+#include <vbi/syscalls.h>
+#include <vbi/syscall.h>
+#include <vbi/types.h>
+
+#ifndef _ASMLANGUAGE
+
+/* private ioapic operator */
+extern asmlinkage int32_t vbi_io_apic_op(uint32_t ioctl, uint32_t irq, uint32_t filter, uint32_t vbId);
+
+/* private interrupt redirection operator */
+extern asmlinkage int32_t vbi_vcore_irq_redirect(uint32_t irq, int32_t CoreId);
+
+/* Name service private operator */
+extern asmlinkage int32_t vbi_ns_op(uint32_t op, char* name, uint32_t rev,
+			VBI_NS_HANDLE *handle);
+
+/* Message receive private operator */
+extern asmlinkage int32_t vbi_rx_op(void *rmsg, uint32_t rlen,
+			struct vbi_msg_info *info, struct vbi_msg_ctl *ctl);
+
+extern asmlinkage int32_t vbi_vb_remote(uint32_t op, uint32_t board_id,
+			int32_t core_id,  void *out);
+
+#endif
+
+#endif  /* _VBI_PRIVATE_H */
diff --git a/include/vbi/shmem.h b/include/vbi/shmem.h
new file mode 100644
index 0000000..8722b68
--- /dev/null
+++ b/include/vbi/shmem.h
@@ -0,0 +1,41 @@
+/*
+ * shmem.h - Virtual Interface memory utility functions
+ *
+ * Copyright 2008 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+
+/*
+DESCRIPTION
+This header file declares the vbi API for managing memory regions
+*/
+
+#ifndef _VBI_SHMEM_H
+#define _VBI_SHMEM_H
+
+#ifndef	_ASMLANGUAGE
+
+extern int32_t vbi_find_shmem(int8_t *smName, void **addr,
+		uint32_t *length, uint32_t *attr);
+
+extern int32_t vbi_find_mem( int8_t *name, void **addr,
+		uint32_t *length, uint32_t *attr);
+
+/* find the base address and length of a core's private memory */
+extern int32_t vbi_find_core_prv_mem(void **addr, size_t *length);
+
+extern int32_t vbi_vb_find_ram_size(uint32_t board_id, size_t *phys_mem_size);
+
+#endif /* _ASMLANGUAGE */
+
+#endif  /* _VBI_SHMEM_H */
diff --git a/include/vbi/syscall.h b/include/vbi/syscall.h
new file mode 100644
index 0000000..7b44a3d
--- /dev/null
+++ b/include/vbi/syscall.h
@@ -0,0 +1,170 @@
+/*
+ * syscall.h - hypervisor system calls
+ *
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef _VBI_SYSCALL_H
+#define _VBI_SYSCALL_H
+
+#include <linux/linkage.h>
+#include <vbi/types.h>
+#include <vbi/arch.h>
+#include <vbi/interface.h>
+#include <vbi/syscalls.h>
+
+#ifndef	_ASMLANGUAGE
+
+/* Forward declaration */
+struct vmmuConfig;
+
+/* information about incoming message */
+
+struct vbi_msg_info
+{
+	int32_t  id;		/* context id of sender */
+	uint32_t type;		/* message type (msg/event) */
+	size_t   slen;		/* length of sent buffer */
+	size_t   rlen;		/* length of received buffer */
+	uint16_t status;	/* message status information */
+	uint16_t error;		/* extended error status */
+	time_t   timestamp;	/* time message was sent */
+	uint32_t nmsg;		/* number of queued messages remaining */
+};
+
+/* message status bits as reported in the "status" field */
+
+#define	VBI_MSG_STATUS_OK		0
+#define	VBI_MSG_STATUS_TRUNCATED	1
+#define	VBI_MSG_STATUS_COPY_ERROR	2
+
+/* extended error codes reported in "error" field */
+
+#define	VBI_MSG_ERROR_INTLEVEL	1 /* operation not allowed at interrupt level */
+#define	VBI_MSG_ERROR_BAD_ID    2 /* bad context id specified */
+#define	VBI_MSG_ERROR_ABORTED   3 /* operation aborted */
+#define	VBI_MSG_ERROR_TIMEOUT   4 /* operation timed out */
+#define	VBI_MSG_ERROR_XCALL     5 /* cross call to remote cpu failed */
+
+/* message types as reported in the "type" field */
+
+#define	VBI_MSG_TYPE_REGULAR	1 /* regular message */
+#define	VBI_MSG_TYPE_EVENT	2 /* event message */
+#define	VBI_MSG_TYPE_REPLY	3 /* reply message */
+
+
+/* modifiers for message processing */
+
+struct vbi_msg_ctl
+{
+	uint32_t flags;		/* operation flags */
+	uint32_t ordering;	/* order to receive messages */
+	time_t timeout;		/* receive timeout */
+};
+
+/* message control flags */
+#define VBI_MSG_CTL_FLAG_RETRY 1
+
+/* memory read/write control structure */
+struct vbi_mem_ctl
+{
+	VB_ALIGN_FIELD_64 (void *pBuffer, pad1); /* address of target context   */
+	VB_ALIGN_FIELD_64 (void *pAddress, pad2);/* address of calling context  */
+	uint64_t size_in;	    /* number of bytes to be read	    */
+	uint64_t size_out;	    /* number of bytes successfully read    */
+	uint32_t flags;	    /* data/instruction flush option	    */
+};
+
+#define VBI_DCACHE_FLUSH	0x0001
+#define VBI_ICACHE_INV		0x0002
+
+/* system call prototypes for use within a context */
+
+extern asmlinkage int vbi_hy_ioctl(unsigned ioctl, void *arg1, void *arg2,
+				void *arg3, void *arg4);
+extern asmlinkage int vbi_io_apic_ioctl(unsigned ioctl, unsigned arg1,
+				unsigned arg2);
+extern asmlinkage int vbi_ctx_ctl(unsigned operation, unsigned arg1,
+				unsigned arg2);
+extern asmlinkage int32_t vbi_vb_mgmt(uint32_t cmd, uint32_t boardId,
+				int32_t *outError, uint32_t flags, void * ctl);
+extern asmlinkage int vbi_vtlb_op(unsigned int op, unsigned long arg1,
+				unsigned long arg2, unsigned long arg3);
+
+/*
+ * Modified APIs for VBI 2.0
+ */
+
+/* Message send */
+extern asmlinkage int32_t vbi_send(int32_t id, void *smsg, size_t slen,
+			    void *rmsg, size_t rlen, struct vbi_msg_info *info,
+			    struct vbi_msg_ctl *ctl);
+/* message receive */
+extern int32_t vbi_receive(void *rmsg, uint32_t rlen, struct vbi_msg_info *info,
+				struct vbi_msg_ctl *ctl);
+/* message reply */
+extern asmlinkage int32_t vbi_reply(int32_t id, void *smsg, size_t slen,
+				struct vbi_msg_ctl *ctl);
+
+extern asmlinkage int32_t vbi_panic(const char *msg);
+extern int32_t vbi_flush_dcache(void *saddr, size_t size);
+extern int32_t vbi_flush_icache(void *saddr, size_t size);
+extern asmlinkage int32_t vbi_kputs(const char *s);
+extern asmlinkage int32_t vbi_kputc(int c);
+extern int32_t vbi_config_vmmu(struct vmmuConfig * config);
+extern int32_t vbi_enable_vmmu(uint32_t  vmmu_num);
+extern int32_t vbi_disable_vmmu(uint32_t vmmu_num);
+extern int32_t vbi_ns_register(char  *name, uint32_t  revision);
+extern int32_t vbi_ns_unregister(char *name, uint32_t  revision);
+extern int32_t vbi_ns_lookup(char *name, uint32_t  rev, VBI_NS_HANDLE *pHandle);
+extern int32_t vbi_tlb_flush_vmmu(struct vmmuConfig * config, void *addr, size_t len);
+
+
+/* Prior to vbi 2.0 these api were vbi_set_mmu_attr/Get */
+
+extern asmlinkage int32_t  vbi_set_mem_attr(void *vaddr, size_t len, int32_t attr);
+extern asmlinkage int32_t  vbi_get_mem_attr(void *vaddr, int32_t * attr);
+
+/*
+ * START: New APIs introduced for vbi 2.0
+ */
+
+extern asmlinkage void vbi_vcore_irq_unlock(void);
+extern asmlinkage int32_t vbi_vcore_irq_lock(void);
+extern int32_t vbi_update_text_cache(void *saddr, size_t size);
+extern int32_t vbi_set_exc_base(void *excTblBase);
+
+/* virtual board management API's */
+extern asmlinkage int32_t vbi_vb_suspend(uint32_t id, int32_t core);
+extern asmlinkage int32_t vbi_vb_reset(uint32_t id, int32_t core, uint32_t options);
+extern asmlinkage int32_t vbi_vb_restart(uint32_t id, int32_t core);
+extern asmlinkage int32_t vbi_vb_resume(uint32_t id, int32_t core);
+
+/* read remote vb's memory */
+extern asmlinkage int32_t vbi_vb_read_mem(struct vbi_mem_ctl *memCtl, uint32_t targetBoard);
+extern asmlinkage int32_t vbi_vb_write_mem(struct vbi_mem_ctl *memCtl, uint32_t targetBoard);
+extern asmlinkage void vbi_shell_start_debug(uint32_t  flags);
+
+/* read/write remote vb's registers */
+extern asmlinkage int32_t vbi_vb_read_reg(VBI_HREG_SET_CMPLX_QUALIFIED *regSet,
+				       uint32_t targetBoard, int32_t core);
+extern asmlinkage int32_t vbi_vb_write_reg(VBI_HREG_SET_CMPLX_QUALIFIED *regSet,
+					uint32_t targetBoard, int32_t core);
+
+/*
+ * END: New APIs introduced for vbi 2.0
+ */
+
+
+#endif	/* _ASMLANGUAGE */
+#endif  /* _VBI_SYSCALL_H */
diff --git a/include/vbi/syscalls.h b/include/vbi/syscalls.h
new file mode 100644
index 0000000..53ee53e
--- /dev/null
+++ b/include/vbi/syscalls.h
@@ -0,0 +1,340 @@
+/*
+ * syscalls.h - hypervisor system calls
+ *
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef _VBI_SYSCALLS_H
+#define _VBI_SYSCALLS_H
+
+/*
+ * System call number encoding:
+ *
+ * 31                                                                        0
+ *
+ *  |               |               |        |               |               |
+ *  +---------------+---------------+        +---------------+---------------+
+ *  | | | | | | | | | | | | | | | | | ...... | | | | | | | | | | | | | | | | |
+ *  +---------------+---------------+        +---------------+---------------+
+ *   ^ ^ ^         ^ ^ ^                                                    ^
+ *   | | \--------/  | \----------------------------------------------------/
+ *   | |      |      |                         |
+ *   | |      |      |                         |
+ *   | |      |      |                         +-- System call number
+ *   | |      |      |
+ *   | |      |      +-- Size override
+ *   | |      |
+ *   | |      +-- Fast hypervisor system call number
+ *   | |
+ *   | +--------- Hypervisor system call
+ *   |
+ *   +----------- Fast hypervisor system call
+ *
+ *
+ *
+ *
+ */
+
+/* fast system call numbers handled by assembler code */
+#define HY_FAST_SYSCALL_MASK	0x3f000000
+#define HY_FAST_SYSCALL_SHIFT	24
+#define HY_FAST_SYSCALL_BIT	0x80000000
+#define HY_FAST_SYSCALL(x)	\
+	((((x) << HY_FAST_SYSCALL_SHIFT) & HY_FAST_SYSCALL_MASK) | \
+	 HY_FAST_SYSCALL_BIT)
+
+/* C driven system calls */
+#define HY_SYSCALL_MASK		0x007fffff
+#define HY_SYSCALL_SHIFT	0
+#define HY_SYSCALL_BIT		0x40000000
+#define HY_SYSCALL(x)	\
+	((((x) << HY_SYSCALL_SHIFT) & HY_SYSCALL_MASK) | HY_SYSCALL_BIT)
+
+#define HY_SIZE_OVERRIDE	0x00800000
+
+/* fast system calls */
+#define VBI_SYS_tlb_flush	HY_FAST_SYSCALL(1) /* TLB flush	*/
+#define VBI_SYS_icache_flush	HY_FAST_SYSCALL(2) /* instruction cache flush */
+#define VBI_SYS_dcache_flush	HY_FAST_SYSCALL(3) /* data cache flush */
+#define VBI_SYS_ctx_load	HY_FAST_SYSCALL(4) /* context load */
+#define VBI_SYS_int_enable	HY_FAST_SYSCALL(5) /* int enable */
+#define VBI_SYS_cache_text_update		    \
+				HY_FAST_SYSCALL(6) /* cache text update */
+
+#define	VBI_SYS_pic_EOI		HY_FAST_SYSCALL(7) /* PIC End of interrupt */
+#define VBI_SYS_spefscr_update	HY_FAST_SYSCALL(8) /* update spefscr */
+
+
+/* hypervisor services */
+#define VBI_SYS_hyIoctl		 HY_SYSCALL(1)	/* hypervisor ioctl	     */
+#define VBI_SYS_vmContextCreate	 HY_SYSCALL(2)	/* context create	     */
+#define VBI_SYS_send		 HY_SYSCALL(3)	/* send a messages	     */
+#define VBI_SYS_receive		 HY_SYSCALL(4)	/* receive a messages	     */
+#define VBI_SYS_reply		 HY_SYSCALL(5)	/* reply to a messages	     */
+#define VBI_SYS_panic		 HY_SYSCALL(6)	/* halt the system	     */
+#define VBI_SYS_int		 HY_SYSCALL(7)	/* deliver an interrupt	     */
+#define VBI_SYS_int_controller_done HY_SYSCALL(8)/* done interrupt processing*/
+#define VBI_SYS_ctxctl		 HY_SYSCALL(9)	/* context control operation */
+
+/* VMMU operations */
+#define VBI_SYS_vmmu_config	HY_SYSCALL(10)	/* configure the virtual MMU */
+#define VBI_SYS_vmmu_enable	HY_SYSCALL(11)	/* enable the virtual MMU    */
+#define VBI_SYS_vmmu_disable	HY_SYSCALL(12)	/* disable the virtual MMU   */
+#define VBI_SYS_vmmu_tlbload	HY_SYSCALL(13)	/* load a VMMU TLB entry     */
+#define VBI_SYS_vmmu_tlbflush	HY_SYSCALL(14)	/* flush a VMMU TLB entry    */
+
+/* MMU operations */
+#define VBI_SYS_mmu_attr_set	HY_SYSCALL(16)	/* set physical memory attr  */
+#define VBI_SYS_mmu_attr_get	HY_SYSCALL(17)	/* get physical memory attr  */
+
+/* BSP specific interface */
+#define VBI_SYS_bspIoctl	HY_SYSCALL(18)	/* BSP specific opreration   */
+
+/* vbMgmt services */
+#define VBI_SYS_vbMgmt          HY_SYSCALL(20)
+
+/* Virtual IO APIC services */
+#define VBI_SYS_vIoapicIoctl	HY_SYSCALL(21)
+
+#define VBI_SYS_vbReset         HY_SYSCALL(22)	/* reset  vcores	*/
+#define VBI_SYS_vbRestart       HY_SYSCALL(23)	/* restart vcores	*/
+#define VBI_SYS_vbSuspend       HY_SYSCALL(24)	/* suspend vcores	*/
+#define VBI_SYS_vbResume        HY_SYSCALL(25)	/* Resume vcores	*/
+#define VBI_SYS_vbRemote        HY_SYSCALL(26)	/* Get info of board	*/
+
+
+#define VBI_SYS_intRedirect     HY_SYSCALL(40)  /* vcores int redirect	*/
+
+/* debug facilities */
+#define VBI_SYS_kputs		HY_SYSCALL(50)	/* print a string to the cons*/
+#define VBI_SYS_kputc		HY_SYSCALL(51)	/* print a char to the cons  */
+#define VBI_SYS_ps		HY_SYSCALL(52)	/* process status display    */
+#define VBI_SYS_dbgShStart	HY_SYSCALL(53)	/* start debug shell	     */
+
+/* VTLB MMU operations */
+#define VBI_SYS_vtlb_op		HY_SYSCALL(55)	/* VTLB operation */
+
+/* Name services */
+#define VBI_SYS_ns_op		HY_SYSCALL(60)	/* Name service operation */
+
+/* remote board memory services */
+#define VBI_SYS_memWrite_op	HY_SYSCALL(70)	/* memory write operation */
+#define VBI_SYS_memRead_op	HY_SYSCALL(71)	/* memory read operation */
+
+/* remote board register services */
+#define VBI_SYS_RegsWrite_op	HY_SYSCALL(72)	/* register write operation */
+#define VBI_SYS_RegsRead_op	HY_SYSCALL(73)	/* register read operation */
+
+/* Max number of syscalls*/
+
+#define VBI_SYS_max		(73 + 1)
+
+/* hyIoctl system call supported ioctl's */
+#define VBI_HYIOCTL_GETPID	 1	/* get context's pid		*/
+#define VBI_HYIOCTL_GETPRIORITY	 2	/* get context's priority	*/
+#define VBI_HYIOCTL_PSDISPLAY	 3	/* print context list on console*/
+#define VBI_HYIOCTL_EXCBASE	 4	/* exception vector base addr	*/
+#define VBI_HYIOCTL_INTBASE	 5	/* interrupt vector base addr	*/
+#define VBI_HYIOCTL_GETSTATS	 6	/* get context statistics	*/
+#define VBI_HYIOCTL_DEBUG_SHELL	 7	/* start the debug shell	*/
+#define VBI_HYIOCTL_PADDR	 9	/* translate to physical address*/
+#define VBI_HYIOCTL_EXCOFFSETS_SET  10  /* set exc vector offsets for the VB*/
+#define VBI_HYIOCTL_EXCOFFSETS_GET  11	/* get exc vector offsets for the VB*/
+
+/* vIoapicIoctl system call supported ioctl's */
+#define VBI_IOAPICIOCTL_UNMASK	1	/* unmask v io apic interrupt src */
+#define VBI_IOAPICIOCTL_SEND	2	/* inject a v io apic interrupt */
+#define VBI_IOAPICIOCTL_EOI	3	/* end of interrupt acknowledge */
+#define VBI_IOAPICIOCTL_VCORE_SEND  4	/* Send an irq to a core	*/
+/* remove this after vb_control is working, we don't need a hypercall for it: */
+#define VBI_IOAPICIOCTL_MASK	10	/* mask v io apic interrupt src */
+
+/* VBI_IOAPICIOCTL_SEND options */
+#define VBI_IOAPICSEND_ALL	0	/* send interrupt to all incl self */
+#define VBI_IOAPICSEND_OTHERS	1	/* send interrupt to all except self */
+#define VBI_IOAPICSEND_SELF	2	/* send interrupt to self only */
+#define VBI_IOAPICSEND_UNICAST	3	/* send interrupt to a only one vb*/
+#define VBI_IOAPICSEND_NONE	4	/* ignore this call	       */
+
+/* sent interrupt to a virtual flags */
+#define VBI_IOAPICSEND_VCORE_NONE  0	/* there no option available for now */
+
+
+/* hyCtxctl system call supported operations */
+#define VBI_CTXCTL_IDLE		1	/* make current context idle	*/
+
+/* remote VB syscall call supported operations */
+
+#define VBI_VBREMOTE_BOARDCONFIG    1       /* get guest addr of VBCONFIG */
+#define VBI_VBREMOTE_RAMSIZE        2       /* get memory size */
+
+/* MMU protection attributes */
+#define VBI_MMU_PROT_READ	0x00000001	/* read allowed    */
+#define VBI_MMU_PROT_WRITE	0x00000002	/* write allowed   */
+#define VBI_MMU_PROT_EXECUTE	0x00000004	/* execute allowed */
+
+/* ETSEC MDIO supported ioctl's */
+#define VBI_BSPIOCTL_DRV_MDIO	1		/* mdio messages */
+
+#define VBI_BSPIOCTL_SYS_CLK	2		/* system clk frequency query */
+#define VBI_BSPIOCTL_CLK_FREQ	2		/* Request system clk freq */
+
+/* return physical cpu number given virtual number
+ * - UP should always be 0
+ * - SMP any vcore in the system
+ */
+#define VBI_BSPIOCTL_VIRT_TO_PHYS_CPU_NUM 3
+ 
+#define MDIO_READ		1
+#define MDIO_WRITE		2
+#define MDIO_INT_ENABLE		3
+#define MDIO_INT_DISABLE	4
+
+/* vbi_hy_ioctl for PADDR */
+
+#define VBI_HYIOCTL_PADDR_DMA        0x0 /* Default used for DMA */
+#define VBI_HYIOCTL_PADDR_PHYS       0x1 /* When absolute phys addr needed */
+
+/* vbMgmt commands */
+
+#define VBI_VBMGMT_ATTACH       1       /* Attach to VB for control */
+#define VBI_VBMGMT_DETACH       2       /* Detech from VB */
+#define VBI_VBMGMT_SUSPEND      3       /* Suspend/halt VB */
+#define VBI_VBMGMT_RESUME       4       /* Resume/start a VB */
+#define VBI_VBMGMT_RESET        5       /* Reset VB */
+#define VBI_VBMGMT_RESTART      6       /* Restart a VB */
+
+/* vbMgmt error codes */
+
+#define VBI_ERROR_CODE              int32_t
+#define VBI_ERR_GENERAL             -101   /* General error */
+#define VBI_ERR_INVALID_ARG         -102   /* General error */
+
+/* vbMgmt reset macros */
+
+/* APs don't clear mem */
+
+#define VBI_VBMGMT_RESET_NON_CORE0		0x00000000
+
+/* Disable ELF reloading */
+
+#define VBI_VBMGMT_RESET_DOWNLOAD		0x00000001
+
+/* Do not clear memory */
+#define VBI_VBMGMT_RESET_CLEAR			0x00000002
+#define VBI_VBMGMT_RESET_AND_START_CORE0	0x00000004
+
+/* target vb options */
+#define VBI_VB_CORES_ALL	(0x80000000)
+#define VBI_VB_CORES_OTHERS	(0x40000000)
+
+/* VTLB operation command and flags (intel-vt specific) */
+#define VBI_VTLB_OP_UPDATE_PMD		1
+#define VBI_VTLB_OP_UPDATE_PTE		2
+#define VBI_VTLB_OP_DELETE_PMD		3
+#define VBI_VTLB_OP_SET_PTE_AT		4
+#define VBI_VTLB_OP_SET_PTE		5
+#define VBI_VTLB_OP_FLUSH_OPS		6
+#define VBI_VTLB_OP_INIT		7
+
+/* VTLB macros */
+#define VBI_VTLB_OP_MAX_OPS		100
+#define VBI_VTLB_OP_CR3_CACHE_ENTRIES	4
+
+/* VTLB optimization supported options */
+#define VBI_VTLB_OPTIM_ENABLED			1
+#define VBI_VTLB_CR3_CACHE_ENABLED		2
+#define VBI_VTLB_OPS_CACHE_ENABLED		4
+#define VBI_VTLB_DIRTY_BIT_SUPPORT_ENABLED	8
+
+/* vbi_ns_op system call supported operations */
+#define VBI_NS_REGISTER		1	/* register service name    */
+#define VBI_NS_UNREGISTER	2	/* unregister service name  */
+#define VBI_NS_LOOKUP	        3	/* look up service name	    */
+
+#ifndef _ASMLANGUAGE
+
+/* statistics structure returned by VBI_HYIOCTL_GETSTATS ioctl */
+
+struct vbi_ctx_stats
+{
+	unsigned long ctx_type;		/* type of context (user, supv, etc) */
+	unsigned long switchin;		/* number of times switched in       */
+	unsigned long pended;		/* number of times in pend state     */
+	unsigned long tsCtxSwitchOutH;  /* timestamp: context switch (high)  */
+	unsigned long tsCtxSwitchOutL;  /* timestamp: context switch (low)   */
+	unsigned long tsCtxSwitchInH;   /* timestamp: context switch (high)  */
+	unsigned long tsCtxSwitchInL;   /* timestamp: context switch (low)   */
+	unsigned long tsCtxExcInH;	/* timestamp: exception entry (high) */
+	unsigned long tsCtxExcInL;	/* timestamp: exception entry (low)  */
+	unsigned long reset;		/* number of times context reset     */
+};
+
+/* VTLB operation structures (x86 specific) */
+struct vbi_vtlb_op
+{
+	uint32_t op;		/* VTLB operation id */
+	uint32_t arg1;		/* VTLB operation arg 1 */
+	uint32_t arg2;		/* VTLB operation arg 2 */
+	uint32_t arg3;		/* VTLB operation arg 3 */
+};
+
+struct vbi_vtlb_cr3_cache
+{
+	uint32_t guest_cr3;	/* Guest CR3 register */
+	uint32_t host_cr3;	/* Host CR3 register */
+};
+
+struct vbi_vtlb_control
+{
+	uint32_t size;		/* VTLB Control structure size */
+	uint32_t mode;		/* VTLB module */
+	uint32_t vtlb_ops_ix;	/* VTLB operation index */
+	struct vbi_vtlb_op vtlb_ops[VBI_VTLB_OP_MAX_OPS]; /* VTLB ops array */
+	uint32_t cr3_cache_ix;	/* CR3 cache index */
+				/* cr3 cache*/
+	struct vbi_vtlb_cr3_cache cr3_cache[VBI_VTLB_OP_CR3_CACHE_ENTRIES];
+};
+
+/*
+ * Control structure used by vbi_vb_mgmt for commands memory read, memory write,
+ *  register read, and register write.
+ */
+
+typedef struct vbMgmtCtl
+{
+	union
+	{
+		struct
+		{
+			uint32_t *pBuffer;  /* address of target context */
+			uint32_t *pAddress; /* address of calling context */
+			uint32_t size;	/* number of total bytes */
+			uint32_t width;	/* bus width in bytes */
+		} vbMgmtMem;
+		struct
+		{
+			uint32_t *pBuffer;  /* address of target context */
+			uint32_t regSet;	/* register set */
+			uint32_t reg;	/* macro to specify register */
+			uint32_t size;	/* number of total bytes */
+		} vbMgmtReg;
+	} data;
+} VBMGMT_CTL;
+
+typedef uint32_t VBMGMT_HANDLE;
+typedef uint32_t VBI_NS_HANDLE;
+
+#endif	/* _ASMLANGUAGE */
+
+#endif	/* _VBI_SYSCALLS_H */
diff --git a/include/vbi/types.h b/include/vbi/types.h
new file mode 100644
index 0000000..b367c43
--- /dev/null
+++ b/include/vbi/types.h
@@ -0,0 +1,35 @@
+/*
+ * types.h - virtual board interfaces types definitions
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef _VBI_TYPES_H
+#define _VBI_TYPES_H
+
+#ifdef __ASSEMBLY__
+#define _ASMLANGUAGE
+#endif /* __ASSEMBLY__ */
+
+/* The CPU specifics here should be relocated to arch dirs */
+#ifdef CONFIG_X86
+#define CPU PENTIUM
+#endif /* CONFIG_X86 */
+
+#ifdef CONFIG_PPC
+#define CPU PPC85XX   /* Currently all PPC treated the same in vbi */
+#endif /* CONFIG_PPC */
+
+#include <vbi/cpu_types.h>	/* for PENTIUM, PPC85XX, etc */
+
+#endif  /* _VBI_TYPES_H */
diff --git a/include/vbi/vbi.h b/include/vbi/vbi.h
new file mode 100644
index 0000000..7a539ca
--- /dev/null
+++ b/include/vbi/vbi.h
@@ -0,0 +1,558 @@
+/*
+ * vbi.h - virtual board support definitions
+ *
+ * Copyright (c) 2007 - 2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef _VBI_VBI_H
+#define _VBI_VBI_H
+
+#ifdef CONFIG_64BIT
+#ifndef LP64
+#define LP64
+#endif
+#endif
+
+#include <vbi/errors.h>
+#include <vbi/types.h>
+#include <vbi/version.h>
+#include <vbi/arch.h>
+#include <vbi/interface.h>
+#include <vbi/syscall.h>
+#include <vbi/interrupt.h>
+#include <vbi/shmem.h>
+
+#ifndef _ASMLANGUAGE
+/*
+DESCRIPTION
+This module contains the vbi methods prototypes and access macros to access the
+various data structures.
+*/
+
+/* Access macros for VB control structure */
+
+/*
+ *
+ * VBI_CNTRL_ADDR_GET - Get virtual core control structure base address
+ *
+ * This macro returns the base address of the running virtual core's control
+ * structure.
+ *
+ */
+#define VBI_CNTRL_ADDR_GET()        (wr_vb_control)
+
+#define VBI_INT_STATE_GET()             \
+        ((VBI_CNTRL_ADDR_GET()->irq_disable) == -1 ? TRUE: FALSE)
+
+#define VBI_INT_STATE_SET(value)        \
+        ((VBI_CNTRL_ADDR_GET())->irq_disable = value)
+
+
+#define VBI_INT_PENDING_SET(value)        \
+        (VBI_CNTRL_ADDR_GET()->irq_pend = value)
+
+/*
+ *
+ * VBI_VIOAPIC_BASE_GET - Get the virtual I/O APIC base address
+ *
+ * This macro returns the virtual I/O APIC base address in the configuration
+ * structure. This is a table that controls the state of individual IRQ
+ * connected to a virtual board. If the underlying hardware supports an IRQ can
+ * be redirected to a specific vector number. The redirection capability is not
+ * used for PPC platforms since all interrupts are funneled via vector 0x500.
+ * The VIOAPIC is comprised of a description header and a redirection table.
+ * Each entry in the redirection table is 64 bits wide. The size of the
+ * redirection table is architecture specific. See the VBI user's guide for
+ * more detailed information.
+ *
+ * API's for controlling the VIOAPIC:
+ *
+ *
+ * vbi_send_vioapic_irq()
+ *
+ * vbi_set_vioapic_vec()
+ *
+ * vbi_get_vioapic_vec()
+ *
+ * vbi_ack_vioapic_irq()
+ *
+ * vbi_mask_vioapic_irq()
+ *
+ * vbi_unmask_vioapic_irq()
+ *
+ */
+#define VBI_VIOAPIC_BASE_GET()		\
+        (VBI_CNTRL_ADDR_GET()->vIoapic)
+
+/* VMMU0 and VMMU1 tables for context switch access macro's */
+#define VBI_VMMU0_GET()                   \
+        (VBI_CNTRL_ADDR_GET()->vmmu0)
+
+#define VBI_VMMU0_SET(value)              \
+        (VBI_CNTRL_VMMU0_GET() = value)
+
+/*
+ * VBI_STATUS_ADDR_GET - Get virtual core status structure address
+ *
+ * This macro returns the base address of the status structure of currently
+ * running core. This structure is read-only and contains a description of
+ * the running virtual core. Hypervisor uses this data to inform the
+ * virtual board time variant data that may be updated during hypervisor context
+ * Switch. Typical that are available in the status structure are:
+ *
+ *
+ *
+ *Timer tick counter
+ *
+ *Pending interrupt state
+ *
+ *The interrupt state before this core was schedule
+ *
+ *VMMU configuration
+ *
+ *Virtual core registers state
+ *
+ * RETURNS: virtual core configuration structure base address
+ *
+ */
+#define VBI_STATUS_ADDR_GET()       (wr_vb_status)
+
+/*
+ *
+ * VBI_INT_VCORE_PENDING - Get the pending interrupt
+ *
+ * This returns the pending interrupts vector number for the running core.
+ *
+ * RETURNS: VB Interrupt Vector or 0xffff (PowerPC) Not applicable for X86
+ *
+ */
+#define VBI_INT_VCORE_PENDING()				    \
+        (VBI_CNTRL_ADDR_GET()->irq_pend)
+
+/*
+ * VBI_INT_VCORE_PENDING_TYPE_GET - Get the pending interrupts
+ *
+ * This returns the type of pending interrupts for the running core. This API
+ * are not use by hardware with virtualization support.
+ *
+ * RETURNS: 2 for timer interrupt, 1 for other external interrupts or
+ *	    0 if none is pending
+ */
+#define VBI_INT_VCORE_PENDING_TYPE_GET()            \
+        (VBI_STATUS_ADDR_GET()->irq_pend_type)
+
+/*
+ * VBI_INT_VCORE_PREVSTATE_GET - Get the core's previous interrupt status
+ *
+ * This returns the previous interrupt state of the currently running core. This
+ * flag reflects the state of interrupts before Hypervisor injected an
+ * interrupt. The guest OS must restore this flag in the control structure
+ * before returning from the interrupt service routine.
+ *
+ * RETURNS: TRUE if locked otherwise FALSE
+ *
+ */
+#define VBI_INT_VCORE_PREVSTATE_GET()				\
+        ((VBI_STATUS_ADDR_GET()->prev_irq_disable) == -1? TRUE: FALSE)
+
+/* timeStamp field  */
+#define VBI_TIMESTAMP_GET()					\
+        (VBI_STATUS_ADDR_GET()->timeStamp)
+
+/* vmm[0,1] access macro */
+
+/*
+ * VBI_VMMU_CONFIG_GET - Get a core's VMMU configuration addr
+ *
+ * This macro gets the core's VMMU configuration structure address. The VMMU
+ * structure is a descriptor of the VMMU context with the following info:
+ *
+ *
+ *
+ * The VMMU page table base address
+ *
+ * The VMMU pages
+ *
+ * The page size granularity
+ *
+ * The vmmu virtual address space is restricted to 32 bits and is decoded using
+ * a level-1/level-2 page table.  The virtual address is decoded as follows:
+ *
+ *
+ *                          32-bit Virtual Address
+ *        +---------------------------------------------------------+
+ *        |      L1 offset       | L2 offset |    Page offset       |
+ *        +---------------------------------------------------------+
+ *                11 bits           9 bits           12 bits
+ *                  |                 |
+ *                  |                 |
+ *    +-------------+                 |
+ *    |                               |
+ *    |                               |
+ *    |           L1 Table            |            L2 Table
+ *    |    2047 +----------+          |      511 +----------+
+ *    |         |          |          |          |          |
+ *    |         |          |          |          |          |
+ *    |         |          |          |          |----------|
+ *    |         |          |          |   +----->|    PTE   | 8 byte PTE
+ *    |         |          |          |   |      |----------|
+ *    |         |          |          |   |      |          |
+ *    |         |----------| 20 bits  |   |      |          |
+ *    +-------->|  L2 ptr  |----------+---+      |          |
+ *              |----------|                     |          |
+ *              |          |                     |          |
+ *              |          |                     |          |
+ *            0 +----------+                   0 +----------+
+ *               2 page (8KB)                    1 page (4KB)
+ *             2048 L2 pointers                 512 PTE entries
+ *
+ * Each page table entry is 8 bytes (2 words) and uses the following format:
+ *
+ * word 0 (32-bits):
+ *          0 1            7 8           15 1 1 1 1 2 2 2 2 24   26 27  31
+ *                                          6 7 8 9 0 1 2 3
+ *         +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+ *         |V|  Hypervisor  |   Reserved   |U|U|U|U|U|U|U|U| ERPN  | ATTR |
+ *         | |   Reserved   |              |0|1|2|3|4|5|6|7|       |      |
+ *         +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+ *
+ *                V          - valid bit
+ *                Hypervisor - reserved for use by hypervisor
+ *                U0-U7      - user defined attributes
+ *                ERPN       - extended real page number bits
+ *                ATTR       - page attributes
+ *
+ * word 1 (32-bits):
+ *
+ *          0                                19 20      23 2 2 2 2 2 2 3 3
+ *                                                         4 5 6 7 8 9 0 1
+ *         +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+ *         |                RPN                | Reserved |R|C|U|S|U|S|U|S|
+ *         |                                   |          | | |X|X|W|W|R|R|
+ *         +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+ *
+ *                RPN        - real page number
+ *                R          - page referenced bit
+ *                C          - page changed bit
+ *                SX,SW,SR   - supervisor mode protection bits
+ *                UX,UW,UR   - user mode protection bits
+ *
+ *
+ * RETURNS: A pointer to the cores VMMU_CONFIG structure
+ *
+ */
+#define VBI_VMMU0_CONFIG_GET()          \
+        (VBI_STATUS_ADDR_GET()->vmmu0)
+
+#define VBI_VMMU1_CONFIG_GET()          \
+        (VBI_STATUS_ADDR_GET()->vmmu1)
+
+/*
+ * VBI_TICK_COUNT_GET - Get the elapsed ticks count
+ *
+ * This returns the number timer ticks elapsed since the board has started.
+ * The frequency of the counter is based on the virtual board configuration XML
+ * file "TimerTicksFrequency" flag.
+ *
+ * RETURNS: count number of elapsed ticks for a VB
+ *
+ */
+#define VBI_TICK_COUNT_GET()             \
+        (VBI_STATUS_ADDR_GET()->tick_count)
+
+/*
+ * VBI_CONFIG_ADDR_GET - Get virtual core configuration structure base address
+ *
+ * This macro returns the base address of the configuration structure of the
+ * running core.
+ *
+ * RETURNS: virtual core configuration structure base address
+ *
+ */
+#define VBI_CONFIG_ADDR_GET()       (wr_vb_config)
+
+/*
+ * VBI_CONTEXT_ID_GET - Get virtual core context Id
+ *
+ * This macro returns the virtual core context id.
+ *
+ * RETURNS: virtual core context id
+ *
+ */
+#define VBI_CONTEXT_ID_GET()             \
+        (VBI_CONFIG_ADDR_GET()->pid)
+
+/*
+ * VBI_BOARD_ID_GET - Get virtual Id
+ *
+ * This macro returns the virtual board id that the running core is attached.
+ * This is positive integer in the range [1, N]. Where N is the total number of
+ * boards in the system.
+ *
+ * RETURNS: virtual board id;
+ *
+ */
+#define VBI_BOARD_ID_GET()               \
+        (VBI_CONFIG_ADDR_GET()->boardID)
+
+/*
+ * VBI_VCORES_COUNT_GET - Get the number of cores in a VB.
+ *
+ * This macro returns the number of virtual cores in the VB that the calling
+ * core is attached. This is a positive integer in the range of [1:N]. Where N
+ * the total number of cores in the virtual board.
+ *
+ * RETURNS: number of cores in a virtual board
+ *
+ */
+#define VBI_VCORES_COUNT_GET()               \
+        (VBI_CONFIG_ADDR_GET()->numCores)
+
+/*
+ *
+ * VBI_VCORE_ID_GET - Get a core's id
+ *
+ * This macro returns the running core id. This is a positive integer in the
+ * range of [0:N-1]; Where N is the total number of cores in the system.
+ *
+ * RETURNS: the running core id
+ *
+ */
+#define VBI_VCORE_ID_GET()			\
+        (VBI_CONFIG_ADDR_GET()->coreId)
+
+/*
+ * VBI_VCORE_PRIVMEM_SIZE_GET - Get core's private memory size
+ *
+ * This macro returns the size in bytes of the running core's private memory
+ *
+ * RETURNS: size in bytes of the core's private memory
+ *
+ */
+#define VBI_VCORE_PRIVMEM_SIZE_GET()               \
+        (VBI_CONFIG_ADDR_GET()->corePrivateSize)
+
+/*
+ * VBI_VCORE_PRIVMEM_BASE_GET - Get core's private memory base address
+ *
+ * This macro returns the base of the private memory associated to the running
+ * core's private memory
+ *
+ * RETURNS: a pointer to the core's private memory
+ *
+ */
+#define VBI_VCORE_PRIVMEM_BASE_GET()               \
+        (VBI_CONFIG_ADDR_GET()->corePrivate)
+
+/*
+ * VBI_PRV_MODE_GET - Get virtual core privilege mode
+ *
+ * This macro returns the virtual core privilege mode. A privileged core has
+ * has full privilege access to hardware. If a core is configured to run in
+ * privilege mode then care must be taken to prevent negative impact to the
+ * rest of the system.
+ *
+ * RETURNS: 1 if core has supervisor privilege otherwise 0
+ *
+ */
+#define VBI_PRIV_MODE_GET()			    \
+        (VBI_CONFIG_ADDR_GET()->supervisorMode)
+
+/*
+ * VBI_BOARD_NAME - Get a VB name
+ *
+ * This macro returns the name of the virtual board that the running core is
+ * attached. This is a NULL terminated string of a maximum length of 64 bytes.
+ *
+ * RETURNS: a string representing the board name
+ *
+ */
+#define VBI_BOARD_NAME_GET()			    \
+        (VBI_CONFIG_ADDR_GET()->board_name)
+
+#define VBI_BOARD_TYPE_GET()			    \
+        (VBI_CONFIG_ADDR_GET()->board_type)
+
+/*
+ * VBI_BOOT_COUNT_GET - Get the number of times this board has booted
+ *
+ * This macro returns the number of times a board has booted. This may used to
+ * determine if the .bss data region needs to clear after a reset. This is a
+ * zero value since the board has booted at least one time to call this API.
+ *
+ * RETURNS: a positive number greater than 0
+ *
+ */
+#define VBI_BOOT_COUNT_GET()			    \
+        (VBI_STATUS_ADDR_GET()->boot_count)
+
+/*
+ *
+ * VBI_MEM_SIZE_GET - Get the virtual board ram size
+ *
+ * This macro returns the size of ram memory in bytes that a virtual board
+ * has been assigned. If a virtual board has more than one core then it's memory
+ * is shared among all cores. Hypervisor maps the size of memory provided in the
+ * board's XML configuration file "RamSize" flag.
+ * This is a virtual memory region from Hypervisor perspective but serves as the
+ * phyisical memory for the virtual board.
+ *
+ * The size returned by this macro does not include the following:
+ *
+ *
+ *
+ * Private memory of each core attached to this virtual board
+ *
+ * The regions that contain the configuration, status and control structures
+ *
+ * The shared memory with other boards
+ *
+ * RETURNS: The size of memory in bytes for virtual board
+ *
+ */
+#define VBI_MEM_SIZE_GET()			    \
+        (VBI_CONFIG_ADDR_GET()->phys_mem_size)
+
+/*
+ * VBI_MEM_ALIAS_SIZE_GET - Get the size of aliased ram
+ *
+ * This macro returns a virtual board's aliased memory size.
+ *
+ * RETURNS: The aliased memory size.
+ *
+ */
+#define VBI_MEM_ALIAS_SIZE_GET()		    \
+        (VBI_CONFIG_ADDR_GET()->mem_alias_size)
+
+/*
+ * VBI_MEM_ALIAS_ADDR_GET - Get the virtual board ram alias address
+ *
+ * This macro returns a virtual board's ram alias base address. This is a
+ * physical address from the board's perspective but a virtual address mapped
+ * to the board's ram address from Hypervisor's perspective.
+ * Hypervisor maps this address based on "RamAliasAddr" value in the board's
+ * XML configuration file. The virtual board's ram and this address point to the
+ * same physical address. This is convenient mechanism for a virtual board that
+ * needs to remap it's physical address to a different address.
+ *
+ * RETURNS: The base address of ram alias address
+ *
+ */
+#define VBI_MEM_ALIAS_ADDR_GET()			    \
+        (VBI_CONFIG_ADDR_GET()->mem_alias_addr)
+
+
+/*
+ * VBI_MEM_ENTRY_RTN - Get a core entry point function
+ *
+ * This macro returns the address of the entry point function of a particular
+ * core. This address is derived from the guest OS binary image a compile time
+ * while creating the hypervisor system.elf image. Hypervisor calls this
+ * function and passes it to the configuration address and the boot flag when
+ * launching a virtual core.
+ *
+ * RETURNS: The entry point function of a virtual core
+ *
+ */
+#define VBI_ENTRY_RTN_GET()			    \
+        (VBI_CONFIG_ADDR_GET()->reset_pc)
+
+/*
+ * VBI_TICK_TIMER_FREQ_GET - Get a core timer tick frequency
+ *
+ * This macro returns a core's timer clock frequency. It is the number of timer
+ * ticks per second. It is based on the "TickTimerFrequency" flag specified in
+ * the board's XML configuration file.
+ * The timer tick interrupt is delivered to only the running core of a VB. If a
+ * core is not running the counter in the status page is incremented.
+ * If "TickTimerFrequency" is set to a value of 0 for a board it  disables the
+ * timer tick.
+ *
+ * RETURNS: The number of ticks per second
+ *
+ */
+#define VBI_TICK_TIMER_FREQ_GET()		        \
+        (VBI_CONFIG_ADDR_GET()->tick_freq)
+
+#define VBI_TIMESTAMP_FREQ_GET()			\
+        (VBI_CONFIG_ADDR_GET()->stamp_freq)
+
+/*
+ * VBI_BOOTLINE_ADDR_GET - Get a virtual board bootline parameters address
+ *
+ * The bootline parameters is a string that contains configuration data that a
+ * user may specify in the virtual XML configuration "BootLine" flag. A guest
+ * OS running on Hypervisor must use this bootline instead of it's native
+ * bootline parameters. For example VxWorks bootline parameters are not passed
+ * to the VB running VxWorks. The size of the bootline parameters string is
+ * determined by VB_MAX_BOOTLINE_LENGTH at compile time flag. The bootline is
+ * NULL terminated string.
+ *
+ */
+#define VBI_BOOTLINE_ADDR_GET()				\
+        (VBI_CONFIG_ADDR_GET()->bootLine)
+
+#define VBI_PANIC(vector, halt)					\
+{								\
+	printk("core%d: unhandled exception: 0x%x\n",		\
+		wr_vb_config->coreId, vector);			\
+	if (halt)						\
+		vbi_panic("unhandled exception");		\
+}
+
+struct vbi_clk_hook
+{
+	void (*rtn)(void *pArg);
+	void * pArg;
+};
+
+/* externs */
+extern struct vb_config *wr_vb_config;
+extern struct vb_status *wr_vb_status;
+extern struct vb_control *wr_vb_control;
+extern void vbi_init(struct vb_config *config);
+extern void vbi_exc_stub(void);
+extern void ASSERT_FN(const char *, const char *, int);
+extern void vbi_idle(uint64_t);
+extern void *vbi_get_vioapic_addr(void);
+extern int32_t vbi_set_vioapic_vec(uint32_t irq, int32_t vector);
+extern int32_t vbi_get_vioapic_vec(uint32_t irq);
+extern int32_t vbi_unmask_vioapic_irq(uint32_t irq);
+extern int32_t vbi_mask_vioapic_irq(uint32_t irq);
+extern int32_t vbi_ack_vioapic_irq(uint32_t irq);
+extern int32_t vbi_send_vioapic_irq(uint32_t irq, uint32_t filter,
+				      uint32_t target);
+extern int32_t vbi_send_vioapic_irq(uint32_t irq, uint32_t filter,
+				     uint32_t vb);
+extern int32_t vbi_redir_vioapic_irq(uint32_t irq, int32_t tCore);
+extern int32_t vbi_send_vcore_vioapic_irq(uint32_t irq, uint32_t vcoreSet,
+					  uint32_t options);
+extern uint32_t vbi_get_pending_vioapic_irq(void);
+extern int32_t vbi_get_guest_dma_addr(void *gaddr, uint64_t *paddr);
+extern int32_t vbi_guest_phys_to_phys(void *gaddr, uint64_t *paddr);
+
+extern void vbi_disp_vioapic(void);
+extern void vbi_show_shmem(void);
+extern void vbi_show_stat(void);
+extern void vbi_show_ctrl(void);
+extern void vbi_show_cfg(void);
+extern void vbi_show_mem(void);
+extern void vbi_disp_status_regs(void);
+extern void vbi_disp_ctrl_regs(void);
+extern int32_t vbi_vb_find_board_config(uint32_t board_id, int32_t core_id,
+						void *paddr);
+extern void vbi_show_config_page_map(void);
+
+#endif	/* _ASMLANGUAGE */
+
+#endif  /* _VBI_VBI_H */
diff --git a/include/vbi/version.h b/include/vbi/version.h
new file mode 100644
index 0000000..c8a375d
--- /dev/null
+++ b/include/vbi/version.h
@@ -0,0 +1,44 @@
+/*
+ * version.h - vbi version information
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef _VBI_VERSION_H
+#define _VBI_VERSION_H
+
+/*
+ * Release identification, major, minor, and maintenance numbers.
+ *
+ * Current vbi release number
+ */
+
+#define VBI_RUNTIME_NAME     "Wind River Hypervisor Virtual board interface"
+#define VBI_RUNTIME_VERSION  "2.1.0"
+
+/* textual description of this product version */
+
+#define VBI_VERSION VBI_RUNTIME_NAME " " VBI_RUNTIME_VERSION
+
+#ifndef _ASMLANGUAGE
+extern const char *vbi_creation_date;
+extern const char *vbi_runtime_version;
+extern const char *vbi_runtime_name;
+extern const char *vbi_version;
+
+extern const uint32_t vbi_version_major;
+extern const uint32_t vbi_version_minor;
+extern const uint32_t vbi_version_maint;
+#endif	/* __ASMLANGUAGE */
+
+#endif	/* _VBI_VERSION_H */
diff --git a/include/vbi/vmmu.h b/include/vbi/vmmu.h
new file mode 100644
index 0000000..96e42a1
--- /dev/null
+++ b/include/vbi/vmmu.h
@@ -0,0 +1,286 @@
+/*
+ * vmmu.h - hypervisor virtual MMU structure definitions
+ *
+ * Copyright 2007 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef _VBI_VMMU_H
+#define _VBI_VMMU_H
+
+/*
+
+The vmmu virtual address space is restricted to 32 bits and is decoded using
+a level-1/level-2 page table.  The virtual address is decoded as follows:
+
+
+                          32-bit Virtual Address
+        +---------------------------------------------------------+
+        |      L1 offset       | L2 offset |    Page offset       |
+        +---------------------------------------------------------+
+		11 bits           9 bits           12 bits
+                  |                 |
+                  |                 |
+    +-------------+                 |
+    |                               |
+    |                               |
+    |           L1 Table            |            L2 Table
+    |    2047 +----------+          |      511 +----------+
+    |         |          |          |          |          |
+    |         |          |          |          |          |
+    |         |          |          |          |----------|
+    |         |          |          |   +----->|    PTE   | 8 byte PTE
+    |         |          |          |   |      |----------|
+    |         |          |          |   |      |          |
+    |         |----------| 20 bits  |   |      |          |
+    +-------->|  L2 ptr  |----------+---+      |          |
+              |----------|                     |          |
+              |          |                     |          |
+              |          |                     |          |
+            0 +----------+                   0 +----------+
+               2 page (8KB)                    1 page (4KB)
+             2048 L2 pointers                 512 PTE entries
+
+
+
+Each page table entry is 8 bytes (2 words) and uses the following format:
+
+
+word 0 (32-bits):
+
+	  0 1            7 8           15 1 1 1 1 2 2 2 2 24   26 27  31
+	                                  6 7 8 9 0 1 2 3
+	 +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+	 |V|  Hypervisor  |   Reserved   |U|U|U|U|U|U|U|U| ERPN  | ATTR |
+	 | |   Reserved   |              |0|1|2|3|4|5|6|7|       |      |
+	 +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+
+		V          - valid bit
+		Hypervisor - reserved for use by hypervisor
+		U0-U7      - user defined attributes
+		ERPN       - extended real page number bits
+		ATTR       - page attributes
+
+
+word 1 (32-bits):
+
+	  0                                19 20      23 2 2 2 2 2 2 3 3
+	                                                 4 5 6 7 8 9 0 1
+	 +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+	 |                RPN                | Reserved |R|C|U|S|U|S|U|S|
+	 |                                   |          | | |X|X|W|W|R|R|
+	 +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+
+		RPN        - real page number
+		R          - page referenced bit
+		C          - page changed bit
+		SX,SW,SR   - supervisor mode protection bits
+		UX,UW,UR   - user mode protection bits
+
+*/
+
+#ifndef	_ASMLANGUAGE
+
+/* Page Table Entry Definition */
+
+typedef union vmmu_pte		/* vmmu pte format */
+{
+	struct			/* Bit field description */
+	{
+		/* word 0 */
+		u_int v:1;		/* valid bit */
+		u_int hy:7;		/* reserved for use by hypervisor */
+		u_int rsvd1:8;		/* reserved */
+		u_int u0:1;		/* user attribute 0 */
+		u_int u1:1;		/* user attribute 1 */
+		u_int u2:1;		/* user attribute 2 */
+		u_int u3:1;		/* user attribute 3 */
+		u_int u4:1;		/* user attribute 4 */
+		u_int u5:1;		/* user attribute 5 */
+		u_int u6:1;		/* user attribute 6 */
+		u_int u7:1;		/* user attribute 7 */
+		u_int erpn:3;		/* extended real page number bits */
+		u_int w:1;		/* write thru/back */
+		u_int i:1;		/* cache inhibited */
+		u_int m:1;		/* memory coherent */
+		u_int g:1;		/* memory guarded  */
+		u_int e:1;		/* little endian bit */
+
+		/* word 1 */
+		u_int rpn:20;		/* real page number */
+		u_int rsvd2:4;		/* reserved */
+		u_int r:1;		/* page referenced bit */
+		u_int c:1;		/* page changed bit */
+		u_int ux:1;		/* user execute protection */
+		u_int sx:1;		/* supervisor execute protection */
+		u_int uw:1;		/* user write protection */
+		u_int sw:1;		/* supervisor write protection */
+		u_int ur:1;		/* user read protection */
+		u_int sr:1;		/* supervisor read protection */
+	} field;
+
+	struct
+	{
+		u_int word0;		/* word 0 */
+		u_int word1;		/* word 1 */
+	} words;
+} VMMU_PTE;
+
+/* Effective Address Definition */
+
+typedef union vmmuEffectiveAddr /* effective Address structure */
+{
+	struct
+        {
+		u_int l1index:11;	/* Level 1 Index (2K) */
+		u_int l2index:9;	/* Level 2 Index (512) */
+		u_int po:12;		/* Page Offset (4K) */
+        } field;
+	void *addr;
+} VMMU_EFFECTIVE_ADDR;
+
+/* Real Address Definition */
+
+typedef union vmmuRealAddress	/* Real Address Structure */
+{
+	struct			/* Bit field description */
+	{
+		u_int rpn:20;	/* Real Page Number */
+		u_int po:12;	/* Page Offset */
+	}field;
+	void *realAddr;	/* Real Address */
+} VMMU_REAL_ADDRESS;
+
+/* Level-1 descriptor definition */
+
+typedef union vmmu_level_1_desc	/* Level 1 descriptor format */
+{
+	struct			/* Bit field desciption */
+	{
+		u_int l2ba:20;		/* Level 2 table Base Address */
+		u_int reserved:10;	/* Reserved */
+		u_int b:1;		/* Block translation */
+		u_int v:1;		/* Segment Valid bit */
+        } field;
+	u_int l1desc;		/* Level 1 descriptor */
+} VMMU_LEVEL_1_DESC;
+
+/* Level-2 descriptor definition */
+
+typedef union vmmu_level_2_desc	/* Level 2 descriptor format */
+{
+	VMMU_PTE pte;		/* a full PTE entry */
+} VMMU_LEVEL_2_DESC;
+
+/* Level-2 table pointer definition */
+
+typedef union vmmu_level_2_tbl_ptr /* Level 2 Table pointer structure */
+{
+	struct		/* Bit field description */
+	{
+		u_int l2tb:20;		/* Level 2 Table Base */
+		u_int l2index:9;	/* Level 2 table Index */
+		u_int reserved:3;	/* Reserved */
+        } field;
+	VMMU_LEVEL_2_DESC *pL2Desc;	/* Level 2 descriptor table pointer */
+} VMMU_LEVEL_2_TBL_PTR;
+
+
+/* VMMU configuration system call paramter */
+
+typedef struct vmmuConfig
+{
+VMMU_LEVEL_1_DESC *addr;
+	u_int pageSize;
+	u_int contextId;
+	u_int vmmuNum;
+} VMMU_CONFIG;
+
+#endif /* _ASMLANGUAGE */
+
+#ifndef	VMMU_PAGE_SIZE
+#define	VMMU_PAGE_SIZE	4096	/* always use a 4KB page size */
+#define	VMMU_RPN_SHIFT	12
+#endif
+#define	NVPAGES(x)		((x)/VMMU_PAGE_SIZE)
+
+/* VMMU protection attributes */
+
+#define	VMMU_PROT_SUPV_READ	0x00000001	/* supervisor read allowed    */
+#define	VMMU_PROT_USER_READ	0x00000002	/* user read allowed	      */
+#define	VMMU_PROT_SUPV_WRITE	0x00000004	/* supervisor write allowed   */
+#define	VMMU_PROT_USER_WRITE	0x00000008	/* user write allowed	      */
+#define	VMMU_PROT_SUPV_EXECUTE	0x00000010	/* supervisor execute allowed */
+#define	VMMU_PROT_USER_EXECUTE	0x00000020	/* user execute allowed	      */
+
+
+#define	VMMU_PROT_USER_RWX	VMMU_PROT_USER_READ | \
+				VMMU_PROT_USER_WRITE | \
+				VMMU_PROT_USER_EXECUTE \
+
+#define	VMMU_PROT_USER_RW	VMMU_PROT_USER_READ | \
+				VMMU_PROT_USER_WRITE
+
+#define	VMMU_PROT_USER_RX	VMMU_PROT_USER_READ | \
+				VMMU_PROT_USER_EXECUTE
+
+#define	VMMU_PROT_SUPV_RWX	VMMU_PROT_SUPV_READ | \
+				VMMU_PROT_SUPV_WRITE | \
+				VMMU_PROT_SUPV_EXECUTE \
+
+#define	VMMU_PROT_SUPV_RW	VMMU_PROT_SUPV_READ | \
+				VMMU_PROT_SUPV_WRITE
+
+#define	VMMU_PROT_SUPV_RX	VMMU_PROT_SUPV_READ | \
+				VMMU_PROT_SUPV_EXECUTE
+
+/* VMMU cache attributes */
+#define	VMMU_CACHE_LE		0x00000001	/* cache little endian	*/
+#define	VMMU_CACHE_GUARDED	0x00000002	/* cache guarded	*/
+#define	VMMU_CACHE_COHERENT	0x00000004	/* cache coherency	*/
+#define	VMMU_CACHE_INHIBIT	0x00000008	/* cache inhibit	*/
+#define	VMMU_CACHE_WRITETHROUGH	0x00000010	/* cache write through	*/
+#define	VMMU_CACHE_COPYBACK	0x00000000	/* cache copy back	*/
+
+/* VMMU page table structure */
+#define	VMMU_L1_ENTRIES	2048	/* top 11 bits of address	*/
+#define	VMMU_L1_SIZE	2	/* table size in pages (8KB)	*/
+#define	VMMU_L2_ENTRIES	512	/* middle 9 bits of address	*/
+#define	VMMU_L2_SIZE	1	/* table size in pages (4KB)	*/
+
+/* address to level-1 table offset */
+#define	VMMU_L1_INDEX(v)	(((u_int)(v)) >> 21)
+
+/* address to level-2 table offset */
+#define	VMMU_L2_INDEX(v)	((((u_int)(v)) >> 12) & 0x1ff)
+
+/* offset within page */
+#define	VMMU_PAGE_OFFSET(v)	(((u_int)(v)) & 0xfff)
+
+/* address to logical block number */
+#define	VMMU_ADDR_TO_LBA(v)	(((u_int)(v)) >> VMMU_RPN_SHIFT)
+#define	VMMU_LBA_TO_ADDR(v)	(((u_int)(v)) << VMMU_RPN_SHIFT)
+
+/* bit masks for PTE fields */
+/* word 0 */
+#define	VMMU_PTE_ATTR_MASK	0x0000001f	/* page attributes */
+#define	VMMU_PTE_ERPN_MASK	0x000000e0	/* extended real page number */
+#define	VMMU_PTE_VALID_MASK	0x80000000	/* pte valid */
+#define	VMMU_PTE_SUPER_MASK	0x00008000	/* U0, bit 16 */
+
+/* word 1 */
+#define	VMMU_PTE_PERM_MASK	0x0000003f	/* page permissions */
+#define	VMMU_PTE_CHG_MASK	0x00000040	/* page changed bit */
+#define	VMMU_PTE_REF_MASK	0x00000080	/* page referenced bit */
+#define	VMMU_PTE_RPN_MASK	0xfffff000	/* real page number */
+
+#endif  /* _VBI_VMMU_H */
diff --git a/kernel/vbi/Makefile b/kernel/vbi/Makefile
new file mode 100644
index 0000000..280ac86
--- /dev/null
+++ b/kernel/vbi/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the vbi goodies.
+#
+
+
+# Most everything is conditional on the Wind River Hypervisor being configured.
+# Except the user ABI, which is always present, and defined in syscall_vbi
+
+obj-$(CONFIG_WRHV) += shmem.o wrhv.o interrupt.o paddr.o idle.o io_apic.o lib.o \
+                      version.o msg.o ns.o show.o pdc.o device.o
+obj-y += syscall_vbi.o
diff --git a/kernel/vbi/device.c b/kernel/vbi/device.c
new file mode 100644
index 0000000..33d5f4a
--- /dev/null
+++ b/kernel/vbi/device.c
@@ -0,0 +1,252 @@
+/* device.c - Device Configuration VBI */
+
+/*
+ * Copyright (c) 2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+
+/*
+ * DESCRIPTION
+ *
+ * VBI calls used by Guest OSs to discover Guest Devices
+ *
+ */
+
+#include <linux/types.h>
+#include <vbi/vbi.h>
+#include <vbi/syscall.h>
+#include <vbi/pdc.h>
+#include <vbi/syscalls.h>
+
+#undef DEBUG
+#ifdef DEBUG
+#define DEBUG_PRINTF(fmt, args...) do { printk("%s: %d: %s: " fmt, \
+					VBI_BOARD_NAME_GET(), 	     \
+					VBI_BOARD_ID_GET(), __FUNCTION__, \
+					## args); } while (0)
+#define PRINT_IF_CALLED() DEBUG_PRINTF("called\n")
+#else
+#define DEBUG_PRINTF(fmt, args...)
+#define PRINT_IF_CALLED()
+#endif
+
+
+
+/*
+ *
+ * vbi_dev_count - get the number of devices
+ *
+ */
+
+uint32_t vbi_dev_count(void)
+{
+	struct vb_config *config = VBI_CONFIG_ADDR_GET();
+
+	return config->numDevices;
+}
+
+/*
+ *
+ * vbi_get_dev - get device details
+ *
+ */
+
+uint32_t vbi_get_dev(uint32_t deviceIndex, struct vb_dev_info **vbiDevInfo)
+{
+	struct vb_config *config = VBI_CONFIG_ADDR_GET();
+	struct vb_dev_info *pDevInfo = config->deviceConfiguration;
+	uint32_t retVal = -1;
+
+	/* validate the input device index */
+
+	if (deviceIndex < config->numDevices) {
+		/* make sure the device configuration is valid */
+
+		if (pDevInfo) {
+			/* yes, return the pointer to device info */
+
+			*vbiDevInfo = &pDevInfo[deviceIndex];
+			retVal = 0;
+		}
+	}
+
+	return retVal;
+}
+
+/*
+ *
+ * vbi_get_dev_interrupt - get the details of an Interrupt for a device
+ *
+ */
+
+uint32_t vbi_get_dev_interrupt(uint32_t deviceIndex, uint32_t intIndex,
+					struct vb_dev_int_info **vbiIntDetails)
+{
+	struct vb_config *config = VBI_CONFIG_ADDR_GET();
+	struct vb_dev_info *pDevInfo;
+	struct vb_dev_int_info *pDevIntInfo;
+	uint32_t retVal = -1;
+
+	/* Is the input device index valid */
+
+	if (deviceIndex < config->numDevices) {
+		/* yes, valid device index, get device info */
+
+		pDevInfo = &config->deviceConfiguration[deviceIndex];
+
+		/* is the device info valid */
+
+		if (pDevInfo) {
+			/* yes, device info is valid. get interrupt info */
+
+			pDevIntInfo = (struct vb_dev_int_info *)
+				((char *)pDevInfo + pDevInfo->intInfoOffset);
+			/* is the interrupt info valid */
+
+			if (pDevIntInfo) {
+				/*
+				 * yes, interrupt info is valid, check the
+				 * interrupt index
+				 */
+
+				if (intIndex < pDevInfo->numInterrupts) {
+					/*
+					 * valid interrupt index, return
+					 * pointer to interrupt info
+					 */
+
+					*vbiIntDetails = &pDevIntInfo[intIndex];
+					retVal = 0;
+				}
+			}
+		}
+	}
+
+	return retVal;
+}
+
+
+/*
+ *
+ * vbi_get_dev_registers - get the details of a register set for a device
+ *
+ */
+
+uint32_t vbi_get_dev_registers(uint32_t deviceIndex, uint32_t regSetIndex,
+				struct vb_dev_regset_info **vbiRegSetDetails)
+{
+	struct vb_config *config = VBI_CONFIG_ADDR_GET();
+	struct vb_dev_info *pDevInfo;
+	struct vb_dev_regset_info *pDevRegInfo;
+	uint32_t retVal = -1;
+
+	/* Is the input device index valid */
+
+	if (deviceIndex < config->numDevices) {
+
+		/* yes, valid device index, get device info */
+
+		pDevInfo = &config->deviceConfiguration[deviceIndex];
+
+		/* is the device info valid */
+
+		if (pDevInfo) {
+
+			/* yes, device info is valid. get register set info */
+
+			pDevRegInfo = (struct vb_dev_regset_info *)
+				((char *)pDevInfo + pDevInfo->regSetInfoOffset);
+			/* is the register set info valid */
+
+			if (pDevRegInfo) {
+				/*
+				 * yes, register set info is valid,
+				 * check the regset index
+				 */
+
+				if (regSetIndex < pDevInfo->numRegSets) {
+					/*
+					 * valid regset index, return
+					 * pointer to regset info
+					 */
+
+					*vbiRegSetDetails =
+						&pDevRegInfo[regSetIndex];
+					retVal = 0;
+				}
+			}
+		}
+	}
+
+	return retVal;
+}
+/*
+ *
+ * vbi_get_dev_device_tree_source - get the details of a device tree source for 
+ *                                  a device
+ *
+ */
+ 
+uint32_t vbi_get_dev_device_tree_source(uint32_t deviceIndex, 
+					uint32_t deviceTreeSourceIndex, 
+					struct vb_dev_device_tree_source_info
+						**vbiDeviceTreeSourceDetails)
+{
+	struct vb_config *config = VBI_CONFIG_ADDR_GET();
+	struct vb_dev_info *pDevInfo;
+	struct vb_dev_device_tree_source_info *pDevDTSInfo;
+	uint32_t retVal = -1;
+
+	/* Is the input device index valid */
+
+	if (deviceIndex < config->numDevices) {
+		/* yes, valid device index, get device info */
+
+		pDevInfo = &config->deviceConfiguration[deviceIndex];
+
+		/* is the device info valid */
+
+		if (pDevInfo) {
+
+			/* device info is valid. get device-tree-source info */
+
+			pDevDTSInfo = (struct vb_dev_device_tree_source_info *)
+					((char *)pDevInfo + 
+					 pDevInfo->deviceTreeSourceInfoOffset);    
+			/* is the device-tree-source info valid */
+
+			if (pDevDTSInfo) {
+
+				/*
+				 * device-tree-source info is valid,
+				 * check the devicetreesource index
+				 */
+
+				if (deviceTreeSourceIndex <
+					pDevInfo->numDeviceTreeSources) {
+
+					/*
+					 * valid devicetreesource index, return
+					 * pointer to devicetreesource info
+					 */
+
+					*vbiDeviceTreeSourceDetails =
+					   &pDevDTSInfo[deviceTreeSourceIndex];
+					retVal = 0;
+				}
+			}
+		}
+	}
+    
+	return retVal;
+}
diff --git a/kernel/vbi/idle.c b/kernel/vbi/idle.c
new file mode 100644
index 0000000..1a404af
--- /dev/null
+++ b/kernel/vbi/idle.c
@@ -0,0 +1,44 @@
+/* idle.c - context idle code
+ *
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+/*
+ * This provides an interface to put the currently running virtual board
+ * into the idle state.
+ */
+
+#include <linux/types.h>
+#include <vbi/vbi.h>
+
+/*
+ * vbi_idle - inform the hypervisor scheduler that the virtual board is
+ * idle
+ *
+ * This function informs the hypervisor that the virtual board core's is
+ * idle and also provides a timeout at which it needs to be made ready to
+ * run again. This routine halts the active core untill the specified
+ * timeout expires or and an asynchronous event like a interrupt is
+ * delivered to the calling core. An zero timeout means to halt the core
+ * indefinetly until an asynchronous event occurs.
+ *
+ */
+
+void vbi_idle(uint64_t timeStamp)
+{
+	uint32_t tick_count = timeStamp & 0xFFFFFFFF;
+
+	/* use the hypervisor system call to go into the idle state */
+
+	vbi_ctx_ctl(VBI_CTXCTL_IDLE, tick_count, 0);
+}
diff --git a/kernel/vbi/interrupt.c b/kernel/vbi/interrupt.c
new file mode 100644
index 0000000..ca9e9f7
--- /dev/null
+++ b/kernel/vbi/interrupt.c
@@ -0,0 +1,67 @@
+/*
+ * interrupt.c - virtual board interrupt configuration utility
+ *
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+/*
+ * This module contains the code for accessing the the interrupts configuration
+ * of the virtual board.
+ */
+
+/*#define DEBUG 1*/
+#ifdef DEBUG
+#define DEBUGM(x) x
+#else
+#define DEBUGM(x)
+#endif
+
+#include <linux/string.h>
+#include <vbi/vbi.h>
+#include <linux/types.h>
+#include <vbi/private.h>
+#include <linux/module.h>
+
+/*
+ * vbi_find_irq - determine the irq for a specified name
+ *
+ * This function finds the irq number of a named interrupt from  the virtual
+ * board configuration information.
+ *
+ * The <irq_dir> is either input or output. VB_INPUT_INT for input,
+ * VB_OUTPUT_INT for output.
+ *
+ */
+
+uint32_t vbi_find_irq(char *irq_name, int32_t irq_dir)
+{
+	struct vb_config *config = VBI_CONFIG_ADDR_GET();
+	struct vb_int_info *info = config->interruptConfiguration;
+	int32_t num  = config->num_ints;
+	int32_t i;
+
+	for (i = 0; i < num; i++, info++) {
+		if (irq_dir != (int32_t)(info->irq_dir))
+			continue;
+
+		if (!strncmp((char *)irq_name, (char *)info->irq_name,
+					VB_NAMELEN)) {
+			/* Found */
+			return (int32_t)info->irq_num;
+		}
+	}
+	return VBI_INVALID_IRQ; /* no match */
+}
+
+EXPORT_SYMBOL(vbi_find_irq);
+
diff --git a/kernel/vbi/io_apic.c b/kernel/vbi/io_apic.c
new file mode 100644
index 0000000..b6fba67
--- /dev/null
+++ b/kernel/vbi/io_apic.c
@@ -0,0 +1,366 @@
+/*
+ * io_apic.c - Virtual IO APIC library
+ *
+ * Copyright (c) 2008-2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <vbi/vbi.h>
+#include <vbi/io_apic.h>
+#include <vbi/private.h>
+
+/*
+ * APIC register get/set macros  Accesses are double words using an
+ * indirect addressing scheme.
+ * Redirection table entry bits: lower 32 bit
+ */
+
+/* IO APIC Register Offset */
+
+#define VIOAPIC_REG_ID		0x00	/* IOAPIC ID */
+#define VIOAPIC_REG_VERS	0x01	/* IOAPIC Version */
+#define VIOAPIC_REG_ARB		0x02	/* IOAPIC Arbitration ID */
+#define VIOAPIC_REG_BOOT	0x03	/* IOAPIC Boot Configuration */
+#define VIOAPIC_REG_REDTBL	0x10	/* Redirection Table (24 * 64bit) */
+
+#ifdef DEBUG
+#define DEBUGM(fmt, arg...) printk(fmt, ##arg)
+#else
+#define DEBUGM(fmt, arg...)
+#endif
+
+/*
+ * IO APIC register get/set macros. Accesses are double words using an
+ * indirect addressing scheme.
+ *
+ * FIXME: convert to readb() and let compiler check types etc.
+ */
+
+#define	VIOAPIC_REG_GET(base, offset)		\
+	(*((volatile uint32_t *)(((unsigned long *)(base)) + (offset))))
+
+#define	VIOAPIC_REG_SET(base, offset, value)	\
+	(*((volatile uint32_t *)(((unsigned long *)(base)) + (offset))) = \
+	(value))
+
+/*
+ * vbi_get_vioapic_addr - Get VIOAPIC base address
+ *
+ * This routine gets the base address of the VIOAPIC specified in the VB
+ * control structure.
+ *
+ */
+void *vbi_get_vioapic_addr(void)
+{
+	return VBI_VIOAPIC_BASE_GET();
+}
+
+/*
+ * vbi_set_vioapic_vec - Set a vector for the specified irq entry
+ *
+ * This routine sets a vector for the specified entry in the VIOAPIC
+ * redirection table. The previous entry in the table is trashed. Before
+ * setting the new vector in the entry the user can obtain the previous
+ * entry by calling vbi_get_vioapic_vec(). The first argument passed to
+ * this function represent the index to the VIOAPIC redirection table.  The
+ * second argument is the vector to set in the specified entry.  For Intel
+ * architectures when an interrupt is raised the vector determines the
+ * Interrupt descriptor table (IDT) entry where the IRQ is delivered.
+ *
+ * This routine is currently not supported for PPC.
+ *
+ */
+int32_t vbi_set_vioapic_vec(uint32_t irq, int32_t vector)
+{
+	volatile VIOAPIC *pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+
+	if (pVioapic == NULL)
+		return VBI_VIOAPIC_NULL;
+
+	if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+		return VBI_VIOAPIC_IRQ_OUTBOUND;
+
+	VB_DEBUG_MSG("vbi_set_vioapic_vec: base @ 0x%x\n", vioapicBase);
+	VB_DEBUG_MSG("Set vector %d: @ 0x%x\n", vioapicBase,
+		 &(pVioapic->entry[irq].value));
+
+	pVioapic->entry[irq].vioapic_low.field.vector = vector;
+
+	return 0;
+}
+
+/*
+ * vbi_get_vioapic_vec - Get a vector in the specified irq entry
+ *
+ * This routine gets a vector for the specified entry in the VIOAPIC table in
+ * VIOAPIC redirection table. It may be used for saving the previous entry
+ * before setting a new vector in the specified entry. This takes as an argument
+ * the irq number that corresponds to the redirection table offset.
+ *
+ * This routine is currently not supported for PPC
+ *
+ */
+int32_t vbi_get_vioapic_vec(uint32_t irq)
+{
+	volatile VIOAPIC *pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+	int32_t vector;
+
+	if (pVioapic == NULL)
+		return VBI_VIOAPIC_NULL;
+
+	if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+		return VBI_VIOAPIC_IRQ_OUTBOUND;
+
+	VB_DEBUG_MSG("vbi_get_vioapic_vec: base @ 0x%x\n", vioapicBase);
+
+	vector = pVioapic->entry[irq].vioapic_low.field.vector;
+
+	VB_DEBUG_MSG("vbi_get_vioapic_vec: vector %d: for irq 0x%x\n", vector, irq);
+
+	return vector;
+}
+
+/*
+ * vbi_unmask_vioapic_irq - Unmask an irq for a virtual board
+ *
+ * This routine enables the interrupt vector that matches the specified IRQ at
+ * the VIOAPIC redirection table. This routine makes a hypercall in order to
+ * deliver pending interrupts that might be queued while the irq was masked.
+ * Hypervisor delivers any pending IRQ that may have occurred while the IRQ was
+ * masked. Then clears the mask bit in the VIOAPIC redirection table for the
+ * specified IRQ directed to the calling virtual Core.
+ *
+ */
+int32_t vbi_unmask_vioapic_irq(uint32_t irq)
+{
+	volatile VIOAPIC *pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+
+	DEBUGM("VIOAPIC base: 0x%x \n", pVioapic);
+
+	if (pVioapic == NULL)
+		return VBI_VIOAPIC_NULL;
+
+	if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+		return VBI_VIOAPIC_IRQ_OUTBOUND;
+
+	return vbi_io_apic_op(VBI_IOAPICIOCTL_UNMASK, irq, 0, 0);
+}
+EXPORT_SYMBOL(vbi_unmask_vioapic_irq);
+
+/*
+ * vbi_mask_vioapic_irq - Mask an irq
+ *
+ * This routine disables the interrupt vector that matches the specified IRQ at
+ * the VIOAPIC for the running core. The mask bit for the IRQ entry in the
+ * VIOAPIC redirection table is set to 1. After calling this function hypervisor
+ * will deliver this IRQ only if this IRQ is enabled by calling
+ * vbi_unmask_vioapic_irq().
+ *
+ */
+int32_t vbi_mask_vioapic_irq(uint32_t irq)
+{
+	volatile VIOAPIC *pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+
+	if (pVioapic == NULL)
+		return VBI_VIOAPIC_NULL;
+
+	if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+		return -1;
+
+	pVioapic->entry[irq].vioapic_low.field.mask = 1;
+
+	return 0;
+}
+
+/*
+ * vbi_ack_vioapic_irq - Acknowledge an irq
+ *
+ * This routine acknowledges the specified IRQ for the running core.
+ * Calling this routine causes Hypervisor to purge any pending interrupt
+ * that arrived while the acknowledgement was pending. When a virual board
+ * receives an interrupt it must call this function. Otherwise Hypervisor
+ * will block subsequent interrupt for the same IRQ. Exceptions are not
+ * required to be acknowledged.
+ *
+ */
+int32_t vbi_ack_vioapic_irq(uint32_t irq)
+{
+
+	if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+		return VBI_VIOAPIC_IRQ_OUTBOUND;
+
+	return vbi_io_apic_op(VBI_IOAPICIOCTL_EOI, irq, 0, 0);
+}
+
+/*
+ * vbi_send_vioapic_irq - Send an interrupt
+ *
+ * This routine makes a hypercall to trigger an IRQ to one or more virtual
+ * board that are connected to the line. The first argument passed to this
+ * function specifies the IRQ number. The second argument specifies the
+ * filter to apply to the list of virtual  boards connected to the IRQ.
+ * The third argument is applicable only when VIOAPIC_SEND_UNICAST filter
+ * is specified.
+ *
+ * In a SMP system a virtual board may have more than one core. If an IRQ
+ * is sent to such system hypervisor will deliver the interrupt to the
+ * core that was configured to receive the IRQ. The configuration is
+ * provided in the board XML configuration file as the example shown
+ * below.
+ *
+ *  <In Name="IRQ_NAME" Vector="Vector Number" Core= "1" />.
+ *
+ * The Vector number is not required to be specified in the XML. If not
+ * specified the VB manager assignes a vector to an IRQ. The Guest OS can
+ * obtain the vector number assigned to an IRQ by calling
+ * vbi_find_irq("VECTOR_NAME").
+ *
+ * The possible values for the filter (second argument) may be:
+ *
+ *
+ *
+ * VIOAPIC_SEND_ALL	- Send to the group of virtual boards connected to this
+ *                        IRQ include the sender board.
+ *
+ * VIOAPIC_SEND_OTHERS	- Send to the group of virtual boards connected
+ *			  to this IRQ excluding the sender board
+ *
+ * VIOAPIC_SEND_UNICAST	- Send an interrupt to the specified virtual board. This
+ *			  will be delivered only if the destination board is
+ *			  connected to this IRQ
+ *
+ *
+ * VIOAPIC_SEND_NONE	- Ignore this call.
+ *
+ */
+int32_t vbi_send_vioapic_irq(uint32_t irq, uint32_t filter, uint32_t target)
+{
+	return vbi_io_apic_op(VBI_IOAPICIOCTL_SEND, irq, filter, target);
+}
+EXPORT_SYMBOL(vbi_send_vioapic_irq);
+
+/*
+ * vbi_send_vcore_vioapic_irq - Send an IRQ to a set of virtual cores within a VB
+ *
+ * This routine makes a hypercall to send an IRQ to a set of virtual cores
+ * specified by a 32bit bitmap value. This routine dispatches the output
+ * IRQ to the target cores.  The destination cores must be within the same
+ * VB as the core sending the interrupt.  The output irq must be mapped in
+ * the VB xml configuration xml file. The name of the output IRQ is
+ * matched with an incoming IRQ that is mapped to the VB. Setting a bit
+ * corresponding to an invalid virtual core will simply be ignored. The
+ * same IRQ is delivered for all cores for any given output IRQ. The third
+ * argument passed to this function must be defined as
+ * VBI_IOAPICSEND_VCORE_NONE.
+ *
+ */
+int32_t vbi_send_vcore_vioapic_irq(uint32_t irq, uint32_t coreSet,
+			uint32_t options)
+{
+	return vbi_io_apic_op(VBI_IOAPICIOCTL_VCORE_SEND, irq, coreSet, options);
+}
+
+/*
+ * vbi_redir_vioapic_irq - Redirect an irq to another core
+ *
+ * This routine makes a hypercall to redirect an irq from one core to another
+ * within the same virtual board.
+ *
+ */
+int32_t vbi_redir_vioapic_irq(uint32_t irq, int32_t core)
+{
+	return vbi_vcore_irq_redirect(irq, core);
+}
+
+/*
+ * vbi_get_pending_vioapic_irq - Get the pending interrupt vector number
+ *
+ * This routine returns the pending interrupt vector number for the calling VB. 
+ * Behavior of this function depends on the underlying architectures.
+ * For some architectures (e.g Intel) each external interrupt is delivered into
+ * a specific address therefore it is not required to demultiplex interrupts.
+ * Other architectures (e.g PPC) share the same offset for all multiple external
+ * interrupts which requires support to read the specific vector pending. This
+ * function is provided for all architectures for completeness.
+ */
+uint32_t vbi_get_pending_vioapic_irq(void)
+{
+	uint32_t pendingIrq;
+
+	/* shouldn't these ops be atomic? */
+
+	pendingIrq = VBI_INT_VCORE_PENDING();
+
+	if (pendingIrq != 0xffff)
+		VBI_INT_PENDING_SET(0xffff); 
+
+	return (pendingIrq);
+}
+
+
+/*
+ * vbi_disp_vioapic - display the virtual I/O APIC table
+ */
+void vbi_disp_vioapic(void)
+{
+	union vioapic_redir_low reg_redir_low;
+	union vioapic_redir_high reg_redir_high;
+	volatile VIOAPIC *pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+	uint32_t i;
+
+	static const char *deliveryModes[] =
+	{
+		" Fixed",	/* 0 */
+		"Lowest",	/* 1 */
+		"   SMI",	/* 2 */
+		"  rsvd",	/* 3 */
+		"   NMI",	/* 4 */
+		"  INIT",	/* 5 */
+		"  rsvd",	/* 6 */
+		"ExtINT"	/* 7 */
+	};
+
+	/* get the general virtual I/O APIC info */
+	printk("Virtual I/O APIC:\n");
+	printk("  Base address: 0x%p\n", pVioapic);
+	printk("  id:          %d\n", pVioapic->id.field.IOAPIC_id);
+	printk("  version:     %d\n", pVioapic->version.field.version);
+	printk("  max entries: %d\n", pVioapic->version.field.maxRedirEntry);
+
+	/* dump the virtual I/O APIC table */
+	printk("\nRedirection Table:\n");
+	printk("Entry Vector Mask Status Trig"
+		"  Pol IRR DeliverMode Destination\n");
+	printk(
+	"----- ------ ---- ------ ----- --- --- ----------- -----------\n");
+
+	for (i=0; i < VIOAPIC_MAX_REDTABLE_ENTRIES; i++) {
+
+	reg_redir_low  = pVioapic->entry[i].vioapic_low;
+	reg_redir_high = pVioapic->entry[i].vioapic_high;
+
+	printk(" %3.3d   %3.3d   %4s %6s %5s %3s  %1d     %6s   %6s %d\n",
+			i,
+			reg_redir_low.field.vector,
+			reg_redir_low.field.mask ? "MASK" : "none",
+			reg_redir_low.field.delivStatus ? "PEND" : "idle",
+			reg_redir_low.field.trigger ? "level" : "edge",
+			reg_redir_low.field.polarity ? "lo" : "hi",
+			reg_redir_low.field.irr,
+			deliveryModes[reg_redir_low.field.deliveryMode],
+			reg_redir_low.field.destMode ? "Set: " : "ID: ",
+			reg_redir_high.field.destination);
+	}
+	printk("\n");
+}
diff --git a/kernel/vbi/lib.c b/kernel/vbi/lib.c
new file mode 100644
index 0000000..e1c5a97
--- /dev/null
+++ b/kernel/vbi/lib.c
@@ -0,0 +1,213 @@
+/*
+ * lib.c - virtual Board Interface Library
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+/*
+
+DESCRIPTION
+The vbi library (Virtual board interface) provides support functionality for
+software developers who are writing Virtual board applications, or as a guide
+to developers porting an operating system to the virtual board environment.
+This file contains the generic API that architecture independent. Separate
+documents are provided as supplement for APIs tied to a particular hardware
+architecture platform.
+
+A given system may be composed of multiple VB where each VB may contain multiple
+Cores. During system bring-up stage hypervisor VB manager allocates resources
+specified in the XML configuration file for the each VB and initializes the
+configuration structure. Then the cores are launched starting at the entry point
+specified in the guest payload image. Hypervisor passes a pointer of the
+configuration page and a 32bit flag that holds the boot options of the core.
+These parameters are passed via stack or registers based on the underlying
+architecture platform.
+
+
+figure 1.1: A simplified overview diagram of a hypervisor system.
+
+                           ________Hypercalls___||_______
+       Virtual board 0    |                     ||       |
+     _____________________V___                  ||       |
+    |    _____         _____  |\                ||       |
+    |   |Core |       |Core | | \     shared    ||    ___V____
+    |   | 0   |       | n   | |  \    pages     ||   |        |
+    |   |_____|       |_____| |   \   ______    ||   |        |
+    |_________________________|    \ |______|   ||   |        |
+                         ^           |______|--------|  H     |
+                         |           |______|   ||   |  Y     |
+                .        | interrupts           ||   |  P     |
+                .         ---------------------------|  E     |
+                .        |                      ||   |  R     |
+       Virtual board N   |           ______     ||   |  V     |
+     ____________________V____      |______|    ||   |  I     |
+    |    _____         _____  |    /|______|----||---|  S     |
+    |   |Core |       |Core | |   / |______|    ||   |  O     |
+    |   | 0   |       | n   | |  /              ||   |  R     |
+    |   |_____|       |_____| | /               ||   |________|
+    |_________________________|/                ||        ^
+                          ^                     ||        |
+                          |                     ||        |
+                          |_____________________||________|
+                                                ||
+
+                                                ^
+                                                |
+                                             guest/hypervisor
+                                              speration line
+
+Once the guest starts running it must call vbi_init() with the save parameters
+passed to it's entry routine which is the base address of the configuration.
+page. This routine retrieves the control and status page page pointers and
+saves them in the corresponding global variables.
+
+If the VMMU is turned on care must be taken to ensure that the memory regions
+below are mapped via the VMMU. It is suggested to treat these regions as
+devices regions where the mapping is flat and the cache attribute is guarded.
+
+A virtual board core is presented by hypervisor with 3 memory areas:
+
+1) Virtual Board Configuration Area
+
+This write protected memory area provides fixed configuration information to
+the virtual board.  The address of this is kept in the global variable
+wr_config.  The address of this area is passed to the virtual board as the
+first parameter when the virtual board is started running at it's boot location.
+
+2) Virtual Board Status Area
+
+This write protected memory area provides data to the virtual board that
+changes due to run-time activity, such as registers saved due to an
+interrupt, timestamps, virtual interrupts etc.  The address of this is
+kept in the global variable wr_status.
+
+3) Virtual Board Control Area
+
+This writable memory area is used by the virtual board to communicate
+information to the hypervisor, where they cannot be passed in a faster manner.
+The address of this area is kept in the global variable wr_control.
+
+*/
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <vbi/vbi.h>
+#include <vbi/private.h>
+
+struct vb_config *wr_vb_config;	/* The address of the core's Config area
+				 * This value is passed to the virtual board
+				 * as the first parameter upon startup */
+EXPORT_SYMBOL(wr_vb_config);
+
+struct vb_control *wr_vb_control;/* The address of the core's Control area */
+
+struct vb_status *wr_vb_status;	/* The address of the core's Status area */
+
+/*
+ * vbi_init - Initialize support for vbi library functions
+ *
+ * This routine initializes the vbi library
+ *
+ * The routine should be called before accessing the virtual board configuration
+ * data or making any hypercall. The parameters passed to this function should
+ * be same as the boot parameters passed to the first executing program in the
+ * running core by hypervisor which is a pointer to the core configuration
+ * address. This routine retrieves the status and control page from the
+ * configuration page and initializes the following global variables for future
+ * reference.
+ *
+ * Configuration page base address is stored in wr_vb_config
+ * Status page base address is stored in wr_vb_status
+ * Control page base address is stored in wr_vb_control
+ *
+ * The user must ensure that this memory regions are mapped if the MMU is
+ * turn-on.
+ * A good practice would be to map these regions as devices meaning 1-1
+ * translation.
+ *
+ * The evolution of the vbi library is tracked by the versioning information.
+ * The different versions of the vbi library are guaranteed to be at least
+ * source level compatible. If additional features that compromise the backward
+ * compatibility are required then solution that provides separate libraries
+ * should be considered. In case the source level compatibility must be violated
+ * in the future then vbi_init() must updated to trap an erroneous configuration
+ * at runtime.
+ *
+ * VBI versioning mechanism is composed of three fragments.
+ *
+ * - Major version
+ * - Minor version
+ * - Maintenance version
+ *
+ * Each of these version fragments serves the purpose of tracking a specific
+ * modification of the vbi library.
+ *
+ * The Major version is updated (incremented by one) when the vbi runtime code
+ * modification has the effect of altering the binary compatibility with it's
+ * predecessor. Which means that the VBI lib used in the guest must match the
+ * version that hypervisor kernel was built against in order to be binary
+ * compatible. In otherwords the major version fragments must be identitical
+ * between a guest OS and hypervisor. These type of mods may update the C
+ * structures but conserve the vbi functions signatures. Additional APIs may be
+ * added.
+ *
+ * The Minor version fragment is dedicated for tracking VBI updates that are
+ * carefully done to prevent breaking Guest OS using a older version of the vbi
+ * library. This implies that a Minor version updates must maintain the binary
+ * compatibility between VBI versions. It is important to note that this is
+ * applicable to only to VBI 2.0 or later versions.
+ * This type of updates should not alter the API or structures definitions.
+ * The vbi library may be extended with new API's that are orthogonal with the
+ * existing ones (the current version at any point in time). The existing
+ * structures may be appended with new fields in a fashion not to impact the
+ * current offsets.
+ *
+ * Finally the maintenance version is used for the purpose of fixing bugs on a
+ * specific version of the vbi library. The purpose is to facility the customer
+ * support effort.
+ *
+ * The source compatibility is assured for any version of the VBI lib. Binary
+ * compatibility is guaranteed for the same minor and maint. versions if the
+ * major version is fixed.
+ *
+ */
+void vbi_init(struct vb_config *config)
+{
+	/*
+	 * validate the vbi version; minor and maintenance should be backward
+	 * compatible.
+	 */
+	if ((config->major != vbi_version_major) ||
+					 (config->minor < vbi_version_minor))
+		vbi_panic("Invalid vbi version");
+
+	wr_vb_config = config;
+	wr_vb_control = wr_vb_config->vb_control;
+	wr_vb_status = wr_vb_config->vb_status;
+
+}
+
+/*
+ *
+ * vbi_vb_find_board_config - return board config of VB
+ *
+ * This function gets the board config guest address of the VB's configuration
+ *
+ */
+int32_t vbi_vb_find_board_config(uint32_t board_id, int32_t core_id,
+					void *paddr)
+{
+	return vbi_vb_remote(VBI_VBREMOTE_BOARDCONFIG, board_id, core_id,
+				paddr);
+}
+
diff --git a/kernel/vbi/msg.c b/kernel/vbi/msg.c
new file mode 100644
index 0000000..a614c91
--- /dev/null
+++ b/kernel/vbi/msg.c
@@ -0,0 +1,55 @@
+/*
+ * msg.c - vbi Message library
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#include <linux/types.h>
+#include <vbi/private.h>
+
+#define DEBUGM(fmt, args...)
+#define _DEBUGM(fmt, args...) printk(fmt, ##args)
+
+/*
+ * vbi_receive - Receive a message from another context
+ *
+ * This routine makes a hypercall and waits for a message to be received from
+ * another context. It blocks until a message is received. This operation may
+ * be aborted if an interrupt is delivered to the waiting Virtual board. If the
+ * "flags" field in the control structure passed to this function is set to be
+ * VBI_MSG_CTL_FLAG_RETRY the receive operation will be retried in case it was
+ * aborted before the expected message was received successfully.
+ *
+ */
+
+int32_t vbi_receive(void *rmsg, uint32_t rlen, struct vbi_msg_info *info,
+			struct vbi_msg_ctl *ctl)
+{
+	int32_t retval;
+
+	while (1)
+	{
+		retval = vbi_rx_op(rmsg, rlen, info, ctl);
+
+		/* if retry flag set, continue */
+		if ((ctl->flags & VBI_MSG_CTL_FLAG_RETRY) != VBI_MSG_CTL_FLAG_RETRY)
+			break;
+
+		/* if retry flag is set _AND_ msg was aborted, retry */
+		if (info->error != VBI_MSG_ERROR_ABORTED)
+			break;
+
+		DEBUGM("%s aborted, retrying \n", __FUNCTION__);
+	}
+	return retval;
+}
diff --git a/kernel/vbi/ns.c b/kernel/vbi/ns.c
new file mode 100644
index 0000000..025c986
--- /dev/null
+++ b/kernel/vbi/ns.c
@@ -0,0 +1,84 @@
+/*
+ * ns.c - hypervisor naming service, client side interface
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+/*
+DESCRIPTION
+
+This module implements a the client side of a simple naming service for the
+internal thread managers of the hypervisor.
+
+The interfaces formulate a message request and send it to the naming service
+for processing.
+
+*/
+
+#include <linux/string.h>
+#include <vbi/vbi.h>
+#include <vbi/private.h>
+
+#ifdef DEBUG
+#define DEBUGM(fmt, args...)    printk(fmt, ##args)
+#else
+#define DEBUGM(fmt, args...)
+#endif
+
+/*
+ * vbi_ns_register - register a service with the naming system
+ *
+ * This routine registers us as the provider of the specified service.
+ * A message for the request is formulated and sent off to the name service
+ * manager for processing.
+ *
+ */
+int32_t vbi_ns_register(char *name, uint32_t revision)
+{
+	if (name == NULL)
+		return -1;
+
+	return vbi_ns_op(VBI_NS_REGISTER, name, revision, NULL);
+}
+
+/*
+ * vbi_ns_unregister - un-register a service with the naming system
+ *
+ * This routine removes us as the provider of the specified service.
+ * A message for the request is formulated and sent off to the name service
+ * manager for processing.
+ *
+ */
+int32_t vbi_ns_unregister(char *name, uint32_t revision)
+{
+	if (name == NULL)
+		return -1;
+
+	return vbi_ns_op(VBI_NS_UNREGISTER, name, revision, NULL);
+}
+
+/*
+ * vbi_ns_lookup - look up a service provider using the naming system
+ *
+ * This routine uses the naming system to look up the context id of the
+ * provider of the specified service.  A message for the request is
+ * formulated and sent off to the name service manager for processing.
+ *
+ */
+int32_t vbi_ns_lookup(char *name, uint32_t revision, VBI_NS_HANDLE *handle)
+{
+	if (name == NULL || handle == NULL)
+		return -1;
+
+	return vbi_ns_op(VBI_NS_LOOKUP , name, revision, handle);
+}
diff --git a/kernel/vbi/paddr.c b/kernel/vbi/paddr.c
new file mode 100644
index 0000000..bf6ee77
--- /dev/null
+++ b/kernel/vbi/paddr.c
@@ -0,0 +1,59 @@
+/*
+ * paddr.c - translate virtual address to a physical address
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+/*
+DESCRIPTION
+These modules provide interfaces to translate the current context's guest
+physical address into the physical machine address. vbi_get_guest_dma_addr is
+specifically for a guest wanting an address that can be used by a DMA device.
+vbi_guest_phys_to_phys is used to return an absolute physical address to used
+perhaps to communicate with the hypervisor itself maybe buffer pointers.
+*/
+
+#include <linux/types.h>
+#include <vbi/private.h>
+
+/*
+ * vbi_guest_phys_to_phys - translate the spcified guest physical to physical
+ *                          address
+ *
+ * This function makes a hypervisor call to translate the specified guest
+ * physical address to physical address. This may be required for quick buffer
+ * transfer that requires the physical address of a memory region. The
+ * hypervisor may be running with > 4GB memory so the phys address is always
+ * 64-bit.
+ *
+ */
+int32_t vbi_guest_phys_to_phys(void *gaddr, uint64_t *paddr)
+{
+	return vbi_hy_ioctl(VBI_HYIOCTL_PADDR, gaddr, paddr,
+				(void*)VBI_HYIOCTL_PADDR_PHYS, 0 );
+}
+
+/*
+ * vbi_get_guest_dma_addr - translate the spcified guest physical to DMA address
+ *
+ * This function makes a hypervisor call to translate the specified guest
+ * physical address  to a physical address. This may be required for a device
+ * driver that requires the address it can use for DMA. The hypervisor may be
+ * running with > 4GB memory so the phys address is always 64-bit.
+ *
+ */
+int32_t vbi_get_guest_dma_addr(void *gaddr, uint64_t *paddr)
+{
+	return vbi_hy_ioctl(VBI_HYIOCTL_PADDR, gaddr, paddr,
+				VBI_HYIOCTL_PADDR_DMA, 0);
+}
diff --git a/kernel/vbi/pdc.c b/kernel/vbi/pdc.c
new file mode 100644
index 0000000..199dfd6
--- /dev/null
+++ b/kernel/vbi/pdc.c
@@ -0,0 +1,142 @@
+/* pdc.c - Para-virtualized Device Channel VBI */
+
+/*
+ * Copyright (c) 2009-2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+
+/*
+DESCRIPTION
+These modules provide interfaces to connect paravirtualized
+device driver (PDD) with the Guest Interface of Actual
+Device Driver in the hypervisor (ADD-GI)
+
+*/
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <vbi/vbi.h>
+#include <vbi/syscall.h>
+#include <vbi/pdc.h>
+#include <vbi/syscalls.h>
+
+uint8_t pdcHandleLookup[(VB_MAX_VIRTUAL_BOARDS + (sizeof(uint8_t) - 1)) 
+				/ sizeof(uint8_t)]; 
+
+#undef DEBUG
+#ifdef DEBUG
+#define DEBUG_PRINTF(fmt, args...) do { printk("%s: %d: %s: " fmt, \
+					VBI_BOARD_NAME_GET(), 	     \
+					VBI_BOARD_ID_GET(), __FUNCTION__, \
+					## args); } while (0)
+
+
+#define PRINT_IF_CALLED() DEBUG_PRINTF("called\n")
+#else
+#define DEBUG_PRINTF(fmt, args...)
+#define PRINT_IF_CALLED()
+#endif
+
+static void pdcHandleSet(vbi_pdc_handle pdcHandle)
+{
+	pdcHandleLookup[pdcHandle >> 3] |= (uint8_t)(1 << (pdcHandle % 8));  
+}
+
+static uint32_t pdcHandleGet(vbi_pdc_handle pdcHandle)
+{
+	if (pdcHandleLookup[pdcHandle >> 3] & (uint8_t)(1 << (pdcHandle % 8))) {
+		return 0;
+	}
+	return -1;
+}
+
+/*
+ *
+ * vbiPdcOp - send message on Paravirtualized Device channel
+ *
+ */
+
+int32_t vbi_pdc_op(vbi_pdc_handle pdcHandle, vbi_pdc_request requestType,
+			uint32_t ioctlOp, void *bufferPtr, size_t bufferLen,
+			uint64_t token)
+{
+	struct msg_pdc requestMsg;
+	struct msg_pdc_reply replyMsg;
+
+	if (pdcHandle == 0
+		|| (pdcHandle >= VB_MAX_VIRTUAL_BOARDS)
+		|| -1 == pdcHandleGet(pdcHandle)) {
+			DEBUG_PRINTF("vbiPdcOp: invalid handle\n");
+			return (-1);
+	}
+
+	if ((requestType < PDC_REQUEST_MIN)
+		|| (requestType > PDC_REQUEST_MAX)) {
+		DEBUG_PRINTF("vbiPdcOp: invalid request\n");
+		return (-1);
+	}
+
+	requestMsg.hdr.msgId = 0;
+	requestMsg.hdr.msgArg = 0;
+	requestMsg.request = requestType;
+	requestMsg.op = ioctlOp;
+	requestMsg.buf = bufferPtr;
+	requestMsg.buflen = bufferLen;
+
+	if (vbi_send (pdcHandle, &requestMsg, sizeof(requestMsg),
+		&replyMsg, sizeof(replyMsg), NULL, NULL) != 0) {
+		DEBUG_PRINTF("vbiSend fails\n");
+		return -1;
+	}
+
+	if (replyMsg.status != 0) {	
+		DEBUG_PRINTF("vbiSend reply != OK\n");
+		return (VBI_ERR_ADD_RETRY);
+	}
+
+	if (ioctlOp & PDC_IOCTL_SIO_REQUEST_RESPONSE)
+		return replyMsg.dataVal;
+
+	return 0;
+}
+
+/*
+ *
+ * vbiPdcInit - Initialize Paravirtualized Device channel
+ *
+ */
+
+int32_t vbiPdcInit(const char *instanceName, vbi_pdc_handle *pPdcHandle)
+{
+	int32_t 	retStatus;
+
+	/* validate ADD Guest Interface name */
+
+	if (instanceName == NULL) {
+		DEBUG_PRINTF("vbiPdcInit: instanceName NULL\n");
+		return VBI_ERR_DEVDRV_NULL_NAME;
+	}
+	if (pPdcHandle == NULL) {
+		DEBUG_PRINTF("vbiPdcInit: pPdcHandle NULL\n");
+		return VBI_ERR_DEVDRV_NULL_HANDLE;
+	}
+	/* call Name Server to lookup ADD Guest Interface */
+	retStatus = vbi_ns_lookup((char *)instanceName, 0, pPdcHandle);
+	if (retStatus == 0) {
+		DEBUG_PRINTF("Successfully connected to %s\n", instanceName);
+		pdcHandleSet(*pPdcHandle);
+	}
+	else
+		DEBUG_PRINTF("Failed to connected to %s\n", instanceName);
+	return retStatus;
+}
diff --git a/kernel/vbi/shmem.c b/kernel/vbi/shmem.c
new file mode 100644
index 0000000..a9d7a17
--- /dev/null
+++ b/kernel/vbi/shmem.c
@@ -0,0 +1,132 @@
+/*
+ * shmem.c - shared memory utility functions
+ *
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+/*
+DESCRIPTION
+This module contains the code for retriving the memory regions assigned to
+a virtual board. The information is passed in to the virtual board via the
+configuration structure. There is a descriptor table for each type of memory.
+
+MEMORY TYPES
+
+There is a memory memory region assigned only to each board which can be
+retrieved by calling vbi_find_mem().
+
+There is a shared memory which may be shared with other boards in the
+system. The shared memory can be retrieved by using vbi_find_shmem()
+
+Each core in the system is assigned a private memory region. The base address
+and the length of this region may obtained by calling vbi_find_core_prv_mem ()
+Alternatively the following macros can be used to obtained similar information
+
+*/
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/module.h>
+#include <vbi/vbi.h>
+#include <vbi/private.h>
+
+/*
+ * vbi_find_shmem - locate the shared memory parameters for a given region
+ *
+ * This function finds the shared memory region associated with the name
+ * specified. The first argument to this function indicates the name of the
+ * shared to find. If this region exists in the list of configured regions the
+ * address, length and MMU attributes are set in the pointers passed in as
+ * arguments.
+ *
+ */
+int32_t vbi_find_shmem(int8_t *smName, void **addr,
+				uint32_t *length, uint32_t *attr)
+{
+	struct vb_config *config = VBI_CONFIG_ADDR_GET();
+	struct vb_sm_info *info = config->sharedMemoryRegionsConfigAddress;
+	int32_t num = config->num_sm;
+	int32_t i;
+
+	for (i = 0; i < num; i++, info++) {
+		if (!strncmp((char *)smName, (char *)info->name, VB_NAMELEN)) {
+			/* Found */
+			*addr = info->addr;
+			*length = info->length;
+			*attr = info->attr;
+			return 0;
+		}
+	}
+	*addr = 0;
+	return VBI_INVALID_SHMEM;
+}
+EXPORT_SYMBOL(vbi_find_shmem);
+
+/*
+ * vbi_find_mem - locate the memory parameters for a given region
+ *
+ * This function finds the memory region associated with the name specified.
+ * The first argument to this function indicates the name of the memory to find
+ * If this region exists in the list of configured regions the address,
+ * length and MMU attributes are set in the pointers passed in as
+ * arguments.
+ *
+ */
+int32_t vbi_find_mem(int8_t *name, void **addr,
+				uint32_t *length, uint32_t *attr)
+{
+	struct vb_config *config = VBI_CONFIG_ADDR_GET();
+	struct vb_mem_info *info = config->memoryRegionsConfigAddress;
+	int32_t num = config->num_mem;
+	int32_t i;
+
+	for (i = 0; i < num; i++, info++) {
+		if (!strncmp((char *)name, (char *)info->name, VB_NAMELEN)) {
+			/* Found */
+			*addr = info->addr;
+			*length = info->length;
+			*attr = info->attr;
+			return 0;
+		}
+	}
+	*addr = 0;
+	return VBI_INVALID_SHMEM;
+}
+
+/*
+ * vbi_find_core_prv_mem - locate the private memory for a core
+ *
+ * This function gets the base address of the private memory region assigned to
+ * the running core.
+ *
+ */
+int32_t vbi_find_core_prv_mem(void **addr, size_t *length)
+{
+	*addr = (void *)VBI_VCORE_PRIVMEM_BASE_GET();
+	*length = VBI_VCORE_PRIVMEM_SIZE_GET();
+
+	return 0;
+}
+
+/*
+ * vbi_vb_find_ram_size - return RAM size of VB
+ *
+ * This function gets the RAM size of the VB's configuration
+ *
+ */
+int32_t vbi_vb_find_ram_size(uint32_t board_id, size_t *phys_mem_size)
+{
+	 return vbi_vb_remote(VBI_VBREMOTE_RAMSIZE, board_id, 0,
+				phys_mem_size);
+}
+
diff --git a/kernel/vbi/show.c b/kernel/vbi/show.c
new file mode 100644
index 0000000..a48e306
--- /dev/null
+++ b/kernel/vbi/show.c
@@ -0,0 +1,294 @@
+/*
+ * show.c - virtual board data show functions
+ *
+ * Copyright (c) 2007-2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+/*
+DESCRIPTION
+
+The Virtual Board show functions display virtual board status,
+control and configuration data structures.
+
+*/
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <vbi/vbi.h>
+
+static const char * device_class_name[]={"Serial", "Network", "Block",
+						"Video", "Audio",
+						"Controller",
+						"Other", "Software"};
+
+static const char * device_type_name[]={"None", "ADD", "Emulated",
+					"Passthrough", "Other"};
+
+/*
+ * vbi_show_shmem - print information about the shared memory
+ * configuration
+ *
+ * This routine traverse the array of shared memories descriptor for a
+ * given board and displays the information on hypervisor console.
+ *
+ */
+
+void vbi_show_shmem(void)
+{
+	struct vb_config *config = VBI_CONFIG_ADDR_GET();
+	struct vb_sm_info *p = config->sharedMemoryRegionsConfigAddress;
+	int num_sm = config->num_sm;
+	void *pState = config->sharedMemoryRegionsStateAddress;
+	int i;
+
+	printk("%d Shared memory regions, Config at 0x%p:\n", num_sm, p);
+
+	/* dump shared memory info if we have any attached */
+	for (i=0; i < num_sm; i++,p++) {
+		printk("%8s: 0x%p -> 0x%p  (attr: 0x%x)\n",
+		p->name, p->addr, p->addr + p->length - 1, p->attr);
+	}
+
+	printk("Shared memory State at 0x%p:\n", pState);
+}
+
+/*
+ * vbi_show_mem - print information about a board's  memory
+ * configuration
+ *
+ * This routine traverse the array of memory regions descriptor for a
+ * given board and displays the information on hypervisor console.
+ *
+ */
+void vbi_show_mem(void)
+
+{
+	struct vb_config *config = VBI_CONFIG_ADDR_GET();
+	struct vb_mem_info *p = config->memoryRegionsConfigAddress;
+	int num_sm = config->num_mem;
+	int i;
+
+	printk("%d memory regions, Config at 0x%p:\n", num_sm, p);
+
+	/* dump shared memory info if we have any attached */
+	for (i=0; i < num_sm; i++,p++) {
+		printk("%8s: 0x%p -> 0x%p  (attr: 0x%x) (type: %s)\n",
+			p->name, p->addr, p->addr + p->length - 1,
+			p->attr, p->type);
+	}
+}
+
+/*
+ * vbi_show_irq - print information about a board's
+ * interrupts configuration
+ *
+ * This routine traverse the interrupts descriptors table for a given
+ * board and displays the information on hypervisor console.
+ *
+ */
+static void vbi_show_irq(void)
+{
+	struct vb_config *config = VBI_CONFIG_ADDR_GET();
+	struct vb_int_info *p = config->interruptConfiguration;
+	int num_int = config->num_ints;
+	int i;
+
+	printk("%d Interrupt Configurations, config at 0x%p\n", num_int, p);
+
+	for (i = 0; i < num_int; i++, p++) {
+		if (p->irq_dir == VB_INPUT_INT)
+			printk("%8s: Dir: In, Vector #: %d, Core: %d\n",
+		            p->irq_name, p->irq_num, p->irq_core);
+		else
+			printk("%8s: Dir: Out, Vector #: %d\n",
+		            p->irq_name, p->irq_num);
+	}
+}
+
+/*
+ * vbi_show_device - print information about a board's device configuration
+ *
+ * This routine traverse the device information for a given board and
+ * displays the information on hypervisor console.
+ *
+ */
+
+static void vbi_show_device(void)
+{
+	struct vb_config *config = VBI_CONFIG_ADDR_GET();
+	struct vb_dev_info *p = config->deviceConfiguration;
+	struct vb_dev_int_info *pi = NULL;
+	struct vb_dev_regset_info *pr = NULL;
+	struct vb_dev_device_tree_source_info *pd = NULL;
+	int num_devices = config->numDevices;
+	int i, j, k;
+
+	printk("%d device configurations, Config at 0x%x\n", num_devices,
+			(unsigned int)p);
+
+	for (i = 0; i < num_devices; i++, p++) {
+
+		/* print the device info */
+
+		printk("\n%-8s: %-10s(%d): %-10s: %-10s(%d) "
+			"numInts %d numRegs %d numDTS %d\n",
+			p->deviceName, device_class_name[p->deviceClass],
+			p->deviceClass, p->deviceTemplate,
+			device_type_name[p->deviceType], p->deviceType,
+			p->numInterrupts, p->numRegSets,
+			p->numDeviceTreeSources);
+
+		/* print interrupts for the device */
+
+		if (p->numInterrupts) {
+			pi = (struct vb_dev_int_info *)((char *)p +
+				p->intInfoOffset);
+			for (j = 0; j < p->numInterrupts; j++, pi++) {
+				printk("Interrupt of device:%d intName %s "
+					"intType %s intNum %d\n",
+					pi->indexDevice, pi->intName,
+					pi->intType, pi->intNum);
+			}
+		}
+
+		/* print register set for the device */
+
+		if (p->numRegSets) {
+			pr = (struct vb_dev_regset_info *)((char *)p +
+				p->regSetInfoOffset);
+			for (k = 0; k < p->numRegSets; k++, pr++) {
+				printk("Register Set of device:%d regSetName "
+					"%s Address %llx Length %llx "
+					"Type:%lld\n",
+					pr->indexDevice, pr->regSetName,
+					pr->regSetAddress, pr->regSetLength,
+					pr->regSetType);
+			}
+		}
+
+		/* print device tree source for the device */
+
+		if (p->numDeviceTreeSources) {
+			pd = (struct vb_dev_device_tree_source_info *)
+				((char *)p + p->deviceTreeSourceInfoOffset);
+			for (k = 0; k < p->numDeviceTreeSources; k++, pd++) {
+				printk("Device Tree Source of device:%d "
+					"deviceTreeSourceName %s %p\n",
+					pd->indexDevice,
+					pd->deviceTreeSourceName,
+					&pd->deviceTreeSourceName);
+			}
+		}
+	}
+}
+
+
+/*
+ * vbi_show_stat - print information about a board's status structures
+ *
+ * This routine displays information in the status structure for a given board.
+ *
+ */
+void vbi_show_stat(void)
+{
+	struct vb_status *p = VBI_STATUS_ADDR_GET();
+	printk("VB status: 0x%p\n", p);
+
+	printk("  Pending interrupts: 0x%08x\n", p->irq_pend_type);
+	printk("  timestamp:          %lld\n", p->timeStamp);
+	printk("  old int disable:    0x%08x\n", p->prev_irq_disable);
+#ifdef _WRHV_ARCH_HAS_STATUS_REGS
+	vbi_disp_status_regs();
+#endif
+}
+
+/*
+ * vbi_show_ctrl - print information about a board's control structures
+ *
+ */
+void vbi_show_ctrl(void)
+{
+	struct vb_control *p = VBI_CNTRL_ADDR_GET();
+	int i;
+
+	printk("VB control data: 0x%p\n", p);
+
+	printk("  Disable interrupts:  0x%08x\n", p->irq_disable);
+
+#ifdef _WRHV_ARCH_HAS_STATUS_REGS
+	vbi_disp_ctrl_regs();
+#endif
+
+	printk("  Disabled interrupts:");
+	for (i=0; i < VB_MAX_INTERRUPTS; i++) {
+		if ((p->level_irq_disable & (1 << (32 - i))) != 0)
+			printk(" %d", i);
+	}
+	printk("\n");
+}
+
+void vbi_show_config_page_map()
+{
+	uint32_t i;
+	struct vb_config *config = VBI_CONFIG_ADDR_GET();
+	struct config_page_map *pConfigPageMap = &config->configPageMap[0];
+	uint32_t index=config->configPageNum;
+
+	printk("vbi_show_config_page_map\n\n");
+	for(i=0;i<index;i++)
+		printk("Region No.: %d Address 0x%p Access Privilege 0x%x"
+			" Mapping Size 0x%x\n",i,
+			pConfigPageMap[i].address,
+			pConfigPageMap[i].accessPriv,
+			pConfigPageMap[i].size);
+}
+
+/*
+ * vbi_show_cfg - print information about a board's config structure
+ *
+ */
+
+void vbi_show_cfg(void)
+{
+	struct vb_config *p = VBI_CONFIG_ADDR_GET();
+	printk("VB config data: 0x%p\n", p);
+
+	printk("pid:                %d\n", p->pid);
+	printk("Board ID:           %d\n", p->boardID);
+
+	printk("Status Address:     0x%p\n", p->vb_status);
+	printk("Control Address:    0x%p\n", p->vb_control);
+#if defined (_WRHV_ARCH_HAS_VB_SYSTBL)
+	printk("Syscall Table Address:    0x%lx\n",
+			p->vbSyscallTable);
+#endif
+	printk("SupervisoryMode:    %d\n", p->supervisoryMode);
+
+	printk("Board Name:         %s\n", p->board_name);
+	printk("Board Type:         %d\n", p->board_type);
+	printk("Physical Memory:    %d\n", p->phys_mem_size);
+	printk("Memory Alias Addr:  0x%08x\n", p->mem_alias_addr);
+	printk("Memory Alias Size:  %u\n", p->mem_alias_size);
+	printk("Reset PC:           0x%p\n", p->reset_pc);
+
+	printk("Timer Frequency:     %d/sec\n", p->tick_freq);
+	printk("TimeStamp Frequency: %dULL/sec\n", p->stamp_freq);
+
+	printk("num_ints:             %d\n", p->num_ints);
+
+	vbi_show_mem();
+	vbi_show_shmem();
+	vbi_show_irq();
+	vbi_show_device();
+	vbi_show_config_page_map();
+}
diff --git a/kernel/vbi/version.c b/kernel/vbi/version.c
new file mode 100644
index 0000000..058caac
--- /dev/null
+++ b/kernel/vbi/version.c
@@ -0,0 +1,47 @@
+/*
+ * version.c - creation version/date/time module
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+/*
+This module is always built with each executable image.  It provides
+the VBI version id, and the time and date it was built.
+
+The date stamp may be overriden by defining VBI_RUNTIME_CREATION_DATE. This
+will be primarily used by guest OS's that use VBI.
+
+The ANSI predefined macros __DATE__ and __TIME__ are used to provide
+the date/time information.  ANSI compliant compilers are required for
+building all hypervisor executables.
+*/
+
+#include <linux/types.h>
+#include <vbi/vbi.h>
+#include <vbi/version.h>
+
+/* numerical values for vbi version */
+const uint32_t vbi_version_major = VBI_VERSION_MAJOR;
+const uint32_t vbi_version_minor = VBI_VERSION_MINOR;
+const uint32_t vbi_version_maint = VBI_VERSION_MAINT;
+
+/* string identifiers for vbi version */
+const char *vbi_runtime_name = VBI_RUNTIME_NAME;
+const char *vbi_runtime_version = VBI_RUNTIME_VERSION;
+const char *vbi_version = VBI_VERSION;
+
+#ifdef VBI_RUNTIME_CREATION_DATE
+const char *vbi_creation_date = VBI_RUNTIME_CREATION_DATE;
+#else
+const char *vbi_creation_date = __DATE__ ", " __TIME__;
+#endif
-- 
1.6.4.4

