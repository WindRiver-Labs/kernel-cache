From 17ea5a0c7b47ce99e3f8103169aabc3343033b49 Mon Sep 17 00:00:00 2001
From: WRS Support <support@windriver.com>
Date: Fri, 2 Oct 2009 16:12:13 -0400
Subject: [PATCH] hypervisor: high res timers changes

High res timers on a multicore kernel requires this.

---
 kernel/time/Kconfig          |    5 +++++
 kernel/time/tick-broadcast.c |   15 +++++++++++++++
 kernel/time/tick-oneshot.c   |    5 ++++-

diff --git a/kernel/time/Kconfig b/kernel/time/Kconfig
index 8d53106..6371418 100644
--- a/kernel/time/Kconfig
+++ b/kernel/time/Kconfig
@@ -5,6 +5,10 @@ config TICK_ONESHOT
 	bool
 	default n
 
+config WRHV_X86_HRTIMERS
+	bool
+	default n
+
 config NO_HZ
 	bool "Tickless System (Dynamic Ticks)"
 	depends on GENERIC_TIME && GENERIC_CLOCKEVENTS
@@ -18,6 +22,7 @@ config HIGH_RES_TIMERS
 	bool "High Resolution Timer Support"
 	depends on GENERIC_TIME && GENERIC_CLOCKEVENTS
 	select TICK_ONESHOT
+	select WRHV_X86_HRTIMERS if WRHV && X86
 	help
 	  This option enables high resolution timer support. If your
 	  hardware is not capable then this option only increases
diff --git a/kernel/time/tick-broadcast.c b/kernel/time/tick-broadcast.c
index cb01cd8..ba8b944 100644
--- a/kernel/time/tick-broadcast.c
+++ b/kernel/time/tick-broadcast.c
@@ -430,7 +430,15 @@ again:
 		 */
 		if (tick_broadcast_set_event(next_event, 0))
 			goto again;
+#ifdef CONFIG_WRHV_X86_HRTIMERS
+	} else {
+		now = ktime_get();
+		next_event = ktime_add_ns(now, dev->min_delta_ns);
+		tick_broadcast_set_event(next_event, 1);
+	}
+#else
 	}
+#endif
 	spin_unlock(&tick_broadcast_lock);
 }
 
@@ -528,7 +536,9 @@ void tick_broadcast_setup_oneshot(struct clock_event_device *bc)
 		 * broadcast device to fire.
 		 */
 		mask = tick_broadcast_mask;
+#ifndef CONFIG_WRHV_X86_HRTIMERS
 		cpu_clear(cpu, mask);
+#endif
 		cpus_or(tick_broadcast_oneshot_mask,
 			tick_broadcast_oneshot_mask, mask);
 
@@ -552,7 +562,12 @@ void tick_broadcast_switch_to_oneshot(void)
 
 	tick_broadcast_device.mode = TICKDEV_MODE_ONESHOT;
 	bc = tick_broadcast_device.evtdev;
+
+#ifdef CONFIG_WRHV_X86_HRTIMERS
+	if (bc && !smp_processor_id())
+#else
 	if (bc)
+#endif
 		tick_broadcast_setup_oneshot(bc);
 	spin_unlock_irqrestore(&tick_broadcast_lock, flags);
 }
diff --git a/kernel/time/tick-oneshot.c b/kernel/time/tick-oneshot.c
index 2e8de67..7910e41 100644
--- a/kernel/time/tick-oneshot.c
+++ b/kernel/time/tick-oneshot.c
@@ -104,9 +104,12 @@ int tick_switch_to_oneshot(void (*handler)(struct clock_event_device *))
 	struct tick_device *td = &__get_cpu_var(tick_cpu_device);
 	struct clock_event_device *dev = td->evtdev;
 
+#ifndef CONFIG_WRHV_X86_HRTIMERS
 	if (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT) ||
 		    !tick_device_is_functional(dev)) {
-
+#else
+	if (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT)) {
+#endif
 		printk(KERN_INFO "Clockevents: "
 		       "could not switch to one-shot mode:");
 		if (!dev) {
-- 
1.6.5.2

