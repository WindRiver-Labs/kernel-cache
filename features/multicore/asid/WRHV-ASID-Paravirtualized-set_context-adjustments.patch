From 4d2c4218d0f1797a87c0be9824efd3d1b5948ccc Mon Sep 17 00:00:00 2001
From: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
Date: Wed, 16 Feb 2011 10:52:22 -0500
Subject: [PATCH 09/10] WRHV/ASID: Paravirtualized set_context adjustments

The paravirtualized version of set_context is insuffifcient
for controlling the Hypervisor with ASID optimizations enabled.
Function signature updates are needed to distinguish between
non-asid enabled hypervisor and enabled, this provides backwards
compatibility.

The first ASID is treated differently within the hypervisor,
given that it is statically mapped within the hypervisor.

Signed-off-by: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
---
 arch/powerpc/kernel/vbi/util.c |   36 +++++++++++++++++++++++++++++-------
 arch/powerpc/kernel/vbi/wrhv.c |   22 ++++++++++++++++++----
 2 files changed, 47 insertions(+), 11 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/util.c b/arch/powerpc/kernel/vbi/util.c
index 62e3d6e..0fd41fd 100644
--- a/arch/powerpc/kernel/vbi/util.c
+++ b/arch/powerpc/kernel/vbi/util.c
@@ -88,18 +88,39 @@ void vb_pte_set(void *pPte, unsigned long paddr, int protval)
  */
 
 int vb_context_mmu_on(int pid,	/* context id */
-		      void *pgtable,	/* level 1 page table */
-		      int pagesize, int debug)
+	void *pgtable, int pagesize, int asid, int vmmu_handle,
+	int debug)
 {
 	static VMMU_CONFIG vmmu_cfg;
 
 	if (wr_config == (struct vb_config *)(- 1) || pgtable == NULL || pagesize <= 0)
 		return -1;
 
+#ifdef CONFIG_WRHV_ASID_OPTIMIZATION
+	/* Create needs to be called when dealing with kernel only,
+	   once we create a process, in this case we don't need to
+	   copy the kernel page tables since swapper_pg_dir is being
+	   passed in. */
+	if (asid == 1) { /* special case.  Kernel ASID needs to
+		be created here.  Once the first userspace process is
+		available init, create and destroy will do all the heavy
+		lifting. */
+		vmmu_cfg.addr = (VMMU_LEVEL_1_DESC *) pgtable;
+		vmmu_cfg.flush_type = VMMU_TLB_FLUSH_ASID;
+		vmmu_cfg.asid = asid;
+		vmmu_cfg.vmmu_handle = vmmu_handle;
+
+		if ((vbi_create_vmmu(&vmmu_cfg)) != 0)
+			return -1;
+	}
+	wr_control->vb_control_regs.asid = asid;
+	wr_control->vb_control_regs.vmmu_handle = vmmu_handle;
+	vbi_load_ctx();
+#else
 	vmmu_cfg.addr = (VMMU_LEVEL_1_DESC *) pgtable;
-	vmmu_cfg.pageSize = pagesize;
-	vmmu_cfg.contextId = pid;
-	vmmu_cfg.vmmuNum = 0;	/* only vmmu 0 is support for the time being */
+	vmmu_cfg.flush_type = pagesize;
+	vmmu_cfg.asid = pid;
+	vmmu_cfg.vmmu_handle = 0; /* only vmmu 0 is supported for now */
 
 	if ((vbi_config_vmmu(&vmmu_cfg)) != 0)
 		return -1;
@@ -110,10 +131,11 @@ int vb_context_mmu_on(int pid,	/* context id */
 		printk("End of page table display \n");
 	}
 
-	vbi_enable_vmmu(vmmu_cfg.vmmuNum);
-
+	vbi_enable_vmmu(vmmu_cfg.vmmu_handle);
+#endif
 	return 0;
 }
+EXPORT_SYMBOL(vb_context_mmu_on);
 
 void vb__flush_dcache_icache(void *start)
 {
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 9bb8bf4..42cffee 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -145,7 +145,7 @@ extern int map_page(unsigned long, phys_addr_t, int);
 
 extern int vb_context_mmu_on(int pid,  /* context id */
 			void *pgtable,    /* level 1 page table */
-			int pagesize, int debug);
+			int pagesize, int asid, int vmmu_handle, int debug);
 
 /* declared in linux/arch/powerpc/kernel/time.c */
 
@@ -181,6 +181,11 @@ static void context_check_map(void) { }
 					assumed to be userspace */
 #undef CONFIG_WRHV_DEBUG
 
+#ifdef CONFIG_WRHV_ASID_OPTIMIZATION
+#define KERNEL_BASE_ASID 1
+#else
+#define KERNEL_BASE_ASID 0
+#endif
 
 #define WRHV_EARLYCON_SIZE  14  /* sizeof("wrhv_earlycon=") */
 int __init wrhv_earlycon_setup(void)
@@ -1103,7 +1108,8 @@ void __init wrhv_MMU_init(void)
 	 * we enable the mmu here without having to do this from the caller
 	 * (which is in assembly world)
 	 */
-	vb_context_mmu_on(0, swapper_pg_dir, PAGE_SIZE, 0);
+	vb_context_mmu_on(0, swapper_pg_dir, PAGE_SIZE, KERNEL_BASE_ASID,
+		KERNEL_BASE_ASID, 0);
 #endif
 
 	vbi_get_exc_offset(&exec_table);
@@ -1176,7 +1182,14 @@ void wrhv_set_context(unsigned long contextId, pgd_t * pgd)
 	memcpy(updStart, kpdStart, (kpdEnd - kpdStart + 1) * sizeof (pgd_t));
 
 	/* in linux context, page table entry is not set up yet */
-	vb_context_mmu_on(contextId, pgd, PAGE_SIZE, 0);
+#ifdef CONFIG_WRHV_ASID_OPTIMIZATION
+	vb_context_mmu_on(contextId, pgd, PAGE_SIZE,
+		wr_control->vb_control_regs.asid,
+		wr_control->vb_control_regs.vmmu_handle, 0);
+#else
+	vb_context_mmu_on(contextId, pgd, PAGE_SIZE, KERNEL_BASE_ASID,
+		KERNEL_BASE_ASID, 0);
+#endif
 }
 
 /* arch/powerpc/mm/pgtable_32.c */
@@ -2513,7 +2526,8 @@ int __devinit wrhv_start_secondary(void *unused)
 
 	local_irq_disable();
 #ifndef CONFIG_PPC85xx_VT_MODE
-	vb_context_mmu_on(0, swapper_pg_dir, PAGE_SIZE, 0);
+	vb_context_mmu_on(0, swapper_pg_dir, PAGE_SIZE, KERNEL_BASE_ASID,
+			KERNEL_BASE_ASID, 0);
 #endif
 
 	wrhv_umask_IPIs_for_vcore();
-- 
1.6.5.2

