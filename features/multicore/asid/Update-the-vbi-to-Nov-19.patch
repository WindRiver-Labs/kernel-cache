From 522ed1b6e2885dc28ac74da19750b800f7f9f061 Mon Sep 17 00:00:00 2001
From: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
Date: Fri, 18 Feb 2011 15:24:07 -0500
Subject: [PATCH 10/10] Update the vbi to Nov 19

This is a preliminary patch for testing.

Minor MMU config and control changes from Feb 11.

Signed-off-by: Jim Somerville <Jim.Somerville@windriver.com>
---
 arch/powerpc/include/asm/arch_vbi.h    |   35 +++++-------
 arch/powerpc/include/asm/ppc85xx_vbi.h |   22 +++----
 arch/powerpc/include/asm/reg_vbi.h     |    2 +-
 arch/powerpc/kernel/vbi/syscalls.S     |   23 +++++++-
 arch/powerpc/kernel/vbi/wrhv.c         |    5 +-
 arch/x86/include/asm/reg_vbi.h         |   97 +++++++++++++++++++++----------
 arch/x86/kernel/vbi/syscalls.S         |   54 +++++++++---------
 include/vbi/compat.h                   |    2 +-
 include/vbi/cpu_types.h                |    8 ++-
 include/vbi/interrupt.h                |    2 +-
 include/vbi/pdc.h                      |   10 ++--
 include/vbi/private.h                  |    7 +-
 include/vbi/syscall.h                  |   17 +++++-
 include/vbi/syscalls.h                 |   15 ++++-
 include/vbi/vbi.h                      |   20 +++---
 include/vbi/vmmu.h                     |   60 ++++++++++++++++++--
 kernel/vbi/device.c                    |    2 +
 kernel/vbi/interrupt.c                 |    2 +-
 kernel/vbi/io_apic.c                   |   20 +++---
 kernel/vbi/lib.c                       |    8 +-
 kernel/vbi/msg.c                       |    7 ++-
 kernel/vbi/ns.c                        |   55 ++++++++++++++++--
 kernel/vbi/pdc.c                       |   21 ++++---
 kernel/vbi/show.c                      |    4 +-
 24 files changed, 336 insertions(+), 162 deletions(-)

diff --git a/arch/powerpc/include/asm/arch_vbi.h b/arch/powerpc/include/asm/arch_vbi.h
index 484f277..19d5369 100644
--- a/arch/powerpc/include/asm/arch_vbi.h
+++ b/arch/powerpc/include/asm/arch_vbi.h
@@ -68,7 +68,7 @@
 #define VB_STATUS_ESRR1			(4 * (VB_STATUS_REGS_OFFSET_BASE +14))
 #define VB_STATUS_SPEFSCR		(4 * (VB_STATUS_REGS_OFFSET_BASE +15))
 #define VB_STATUS_ASID			(4 * (VB_STATUS_REGS_OFFSET_BASE +16))
-#define VB_STATUS_RESERVED1_2		(4 * (VB_STATUS_REGS_OFFSET_BASE +17))
+#define VB_STATUS_VMMU_HANDLE		(4 * (VB_STATUS_REGS_OFFSET_BASE +17))
 #define VB_STATUS_RESERVED1_3		(4 * (VB_STATUS_REGS_OFFSET_BASE +18))
 #define VB_STATUS_RESERVED1_4		(4 * (VB_STATUS_REGS_OFFSET_BASE +19))
 #define VB_STATUS_RESERVED1_5		(4 * (VB_STATUS_REGS_OFFSET_BASE +20))
@@ -131,7 +131,7 @@
 #define VB_CONTROL_DAC2			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 25))
 #define VB_CONTROL_SPEFSCR		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 26))
 #define VB_CONTROL_ASID			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 27))
-#define VB_CONTROL_RESERVED2		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 28))
+#define VB_CONTROL_VMMU_HANDLE		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 28))
 #define VB_CONTROL_RESERVED3		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 29))
 #define VB_CONTROL_RESERVED4		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 30))
 #define VB_CONTROL_RESERVED5		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 31))
@@ -198,8 +198,6 @@
 
 struct vb_arch_ctrl_regs
 {
-	/* Registers to be restored by the VDK_SYS_ctx_load fast system call */
-
 	uint32_t srr0;		/*  0: PC */
 	uint32_t srr1;		/*  1: MSR */
 	uint32_t cr;		/*  2: condition registers */
@@ -241,15 +239,15 @@ struct vb_arch_ctrl_regs
 	uint32_t dac2;		/* 25 - instructions access control 4 */
 #if (CPU==PPC85XX)
 	uint32_t spefscr;	/* 26 - SPE float status control */
+#else
+	uint32_t reserved1;	/* 26: Reserved */
+#endif
 	uint32_t asid;		/* 27 - Emulated ASID */
-	/* reserved fields for future use */
+	uint32_t vmmu_handle;	/* 28 - Vmmu Handle */
 
-	uint32_t reserved[8];	/* 28: Reserved */ 
-#else
 	/* reserved fields for future use */
 
-	uint32_t reserved[10];	/* 26: Reserved */
-#endif
+	uint32_t reserved[7];	/* 29: Reserved */
 };
 
 /*
@@ -342,7 +340,11 @@ struct vb_arch_stat_regs
 	uint32_t esrr1;  /* 14: */
 #if (CPU==PPC85XX)
 	uint32_t spefscr;  /* 15: */
+#else
+	uint32_t reserved1; /* 15 */
+#endif
 	uint32_t asid;     /* 16: */
+	uint32_t vmmu_handle; /* 17 */
 	/* 
 	 * keep this part in a separate structure in order to keep the offsets
 	 * to remain the same as in VB_STATUS
@@ -350,17 +352,8 @@ struct vb_arch_stat_regs
 
 	/* reserved fields for future use */
 
-	uint32_t reserved1[6]; /* 16 - 22  */
-#else
-	/*
-	 * keep this part in a separate structure in order to keep the offsets
-	 * to remain the same as in VB_STATUS
-	 */
+	uint32_t reserved2[5]; /* 18 - 22  */
 
-	/* reserved fields for future use */
-
-	uint32_t reserved1[8]; /* 15 - 22  */
-#endif
 	/* Configuration registers (only updated upon board creation */
 
 	uint32_t svr;     /* 23 */
@@ -374,7 +367,7 @@ struct vb_arch_stat_regs
 
 	/* reserved fields for future use */
 
-	uint32_t reserved2[9]; /* 31 - 39 */
+	uint32_t reserved3[9]; /* 31 - 39 */
 
 };
 
@@ -519,6 +512,8 @@ typedef struct
 	uint32_t   dataVal;
 } VBI_BSP_MSG_REPLY;
 
+extern void vbi_load_ctx(void);
+
 #else /*_ASMLANGUAGE */
 
 /*
diff --git a/arch/powerpc/include/asm/ppc85xx_vbi.h b/arch/powerpc/include/asm/ppc85xx_vbi.h
index 10c33cf..630df65 100644
--- a/arch/powerpc/include/asm/ppc85xx_vbi.h
+++ b/arch/powerpc/include/asm/ppc85xx_vbi.h
@@ -62,7 +62,7 @@
  */
 #define	_WRS_SNOOP_NEEDS_DMA_MALLOC_SUPPORT
 
-#if  (CPU != PPCE500MC)
+#if  (CPU != PPCE500MC) || (CPU != PPCE200)
 #define _WRS_SPE_SUPPORT	1
 #endif /* (CPU != PPCE500MC) */
 
@@ -100,28 +100,20 @@
 #define IVOR13  413     /* IVOR Data TLB Error */
 #define IVOR14  414     /* IVOR Instruction TLB Error */
 #define IVOR15  415     /* IVOR Debug */
-#if (CPU==PPC85XX)
+#if (CPU==PPC85XX) || (CPU==PPCE200)
 #define IVOR32  528     /* IVOR SPE */
 #define IVOR33  529     /* IVOR Vector FP Data */
 #define IVOR34  530     /* IVOR Vector FP Round */
 #endif
-#ifndef PPC_e200
 #define IVOR35  531     /* IVOR Performance Monitor */
-#endif
 
-#ifndef PPC_e200
 #define MCSRR0  570     /* Machine Check SRR0 */
 #define MCSRR1  571     /* Machine Check SRR1 */
 #define MCAR    573     /* Machine Check Address Register */
-#else
-#define MCSRR0  CSRR0     /* Machine Check SRR0 */
-#define MCSRR1  CSRR1     /* Machine Check SRR1 */
-#undef MCAR         /* Machine Check Address Register */
-#endif
 
 #define MCSR    572     /* Machine Check Syndrome Register */
 
-#if (CPU==PPC85XX)
+#if (CPU==PPC85XX) || (CPU==PPCE200)
 #define SPEFSCR 512     /* SPE Floating-pt Status and Control Register */
 #endif
 
@@ -144,6 +136,10 @@
 #define DBCR0   308     /* Debug Control Register 0 */
 #define DBCR1   309     /* Debug Control Register 1 */
 #define DBCR2   310     /* Debug Control Register 2 */
+#if (CPU==PPCE500MC)
+#define DBCR4   563     /* Debug Control Register 4 */
+#define DBSRWR  306     /* Debug Status Read Write  */
+#endif
 #define DBSR    304     /* Debug Status Register */
 #define IAC1    312     /* Instr Address Compare Register 1 */
 #define IAC2    313     /* Instr Address Compare Register 2 */
@@ -186,7 +182,7 @@
  * Therefore, _EXC_OFF_CRTL should be defined.
  */
 
-#ifndef PPC_e200
+#if (CPU!=PPCE200)
 #define _PPC_MSR_MCE    _PPC_MSR_ME	/* machine check enable */
 #else
 #undef _PPC_MSR_MCE
@@ -200,7 +196,7 @@
 
 /* Only allow the following bits to be modified by the guest
  * Some of these are also forced on by the hypervisor */
-#if (CPU==PPC85XX)
+#if (CPU==PPC85XX) || (CPU==PPCE200)
 #define CONTROL_MSR_MASK  (_PPC_MSR_CE | _PPC_MSR_SPE | _PPC_MSR_EE |\
 			   _PPC_MSR_PR | _PPC_MSR_ME | _PPC_MSR_DE |\
 			   _PPC_MSR_IS | _PPC_MSR_DS | _PPC_MSR_RI)
diff --git a/arch/powerpc/include/asm/reg_vbi.h b/arch/powerpc/include/asm/reg_vbi.h
index 7d2b156..6a48f11 100644
--- a/arch/powerpc/include/asm/reg_vbi.h
+++ b/arch/powerpc/include/asm/reg_vbi.h
@@ -51,7 +51,7 @@
 
 /* include any cpu specific register declarations */
 
-#if (CPU == PPC85XX) || (CPU == PPCE500MC)
+#if (CPU == PPC85XX) || (CPU == PPCE500MC) || (CPU == PPCE200)
 # include <sys/ppc/ppc85xx.h>
 #endif
 
diff --git a/arch/powerpc/kernel/vbi/syscalls.S b/arch/powerpc/kernel/vbi/syscalls.S
index 47cabb1..b9b9b1f 100644
--- a/arch/powerpc/kernel/vbi/syscalls.S
+++ b/arch/powerpc/kernel/vbi/syscalls.S
@@ -50,6 +50,7 @@ FUNC_EXPORT(vbi_flush_dcache)
 FUNC_EXPORT(vbi_update_text_cache)
 #if (CPU==PPC85XX)
 FUNC_EXPORT(vbi_update_spefscr)
+FUNC_EXPORT(vbi_load_ctx)
 #endif
 FUNC_EXPORT(vbi_flush_tlb)
 FUNC_EXPORT(vbi_panic)
@@ -67,6 +68,9 @@ FUNC_EXPORT(vbi_get_mem_attr)
 FUNC_EXPORT(vbi_config_vmmu)
 FUNC_EXPORT(vbi_enable_vmmu)
 FUNC_EXPORT(vbi_disable_vmmu)
+FUNC_EXPORT(vbi_create_vmmu)
+FUNC_EXPORT(vbi_delete_vmmu)
+FUNC_EXPORT(vbi_max_asid_vmmu)
 FUNC_EXPORT(vbi_tlb_load_vmmu)
 FUNC_EXPORT(vbi_tlb_flush_vmmu)
 FUNC_EXPORT(vbi_vb_mgmt)
@@ -608,6 +612,18 @@ vbi_hcall(vbi_enable_vmmu, vmmu_enable)
 vbi_hcall(vbi_disable_vmmu, vmmu_disable)
 
 /*
+ * vbi_create_vmmu - create the virtual MMU handle
+ *
+ */
+vbi_hcall(vbi_create_vmmu, vmmu_create)
+
+/*
+ * vbi_delete_vmmu - delete the virtual MMU handle
+ *
+ */
+vbi_hcall(vbi_delete_vmmu, vmmu_delete)
+
+/*
  *
  * vbi_tlb_load_vmmu - load a TLB entry into the virtual MMU
  *
@@ -628,6 +644,11 @@ vbi_hcall(vbi_tlb_load_vmmu, vmmu_tlbload)
  */
 vbi_hcall(vbi_tlb_flush_vmmu, vmmu_tlbflush)
 
+/*
+ * vbi_max_asid_vmmu - Get the maximum number of asids available
+ *
+ */
+vbi_hcall(vbi_max_asid_vmmu, vmmu_maxasid)
 
 /*
  *
@@ -700,7 +721,7 @@ vbi_hcall(vbi_io_apic_ioctl, vIoapicIoctl)
 
 /*
  *
- * vbi_ns_op - virtua board name service call
+ * vbi_ns_op - virtual board name service call
  *
  * This system call interfaces to the virtual board
  *
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 42cffee..4b4441c 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -238,7 +238,8 @@ void get_hv_bsp_server_handle(void)
 {
 	int32_t rc;
 
-	rc = vbi_ns_lookup ("bspServer", 0, &service_handle);
+	rc = vbi_ns_lookup ("bspServer", 0, &service_handle,
+				VBI_NS_NO_TIMEOUT, VBI_NS_OPTION_NONE);
 	if (rc)
 		printk ("bspServer lookup returned error code: %d\n", rc);
 }
@@ -1158,7 +1159,7 @@ void wrhv_flush_dcache_page(struct page *page)
 	if (test_bit(PG_arch_1, &page->flags))
 		clear_bit(PG_arch_1, &page->flags);
 
-	vbi_flush_dcache(page_to_pfn(page) << PAGE_SHIFT, PAGE_SIZE);
+	vbi_flush_dcache((void *)(page_to_pfn(page) << PAGE_SHIFT), PAGE_SIZE);
 }
 
 void set_context(unsigned long contextid, pgd_t *pgd) 
diff --git a/arch/x86/include/asm/reg_vbi.h b/arch/x86/include/asm/reg_vbi.h
index 4ec4441..fe774f1 100644
--- a/arch/x86/include/asm/reg_vbi.h
+++ b/arch/x86/include/asm/reg_vbi.h
@@ -91,18 +91,18 @@ typedef struct			/* REG_SET - x86 register set	*/
 
 typedef struct cpuid		/* CPUID - 80x86 cpuid version/feature */
     {
-    int highestValue;		/* EAX=0: highest integer value */
-    int vendorId[3];		/* EAX=0: vendor identification string */
-    int signature;		/* EAX=1: processor signature */
-    int featuresEbx;		/* EAX=1: feature flags EBX */
-    int featuresEcx;		/* EAX=1: feature flags ECX */
-    int featuresEdx;		/* EAX=1: feature flags EDX */
-    int cacheEax;		/* EAX=2: config parameters EAX */
-    int cacheEbx;		/* EAX=2: config parameters EBX */
-    int cacheEcx;		/* EAX=2: config parameters ECX */
-    int cacheEdx;		/* EAX=2: config parameters EDX */
-    int serialNo64[2];		/* EAX=3: lower 64 of 96 bit serial no */
-    int brandString[12];	/* EAX=0x8000000[234]: brand strings */
+    uint32_t highestValue;	/* EAX=0: highest integer value */
+    uint32_t vendorId[3];	/* EAX=0: vendor identification string */
+    uint32_t signature;		/* EAX=1: processor signature */
+    uint32_t featuresEbx;	/* EAX=1: feature flags EBX */
+    uint32_t featuresEcx;	/* EAX=1: feature flags ECX */
+    uint32_t featuresEdx;	/* EAX=1: feature flags EDX */
+    uint32_t cacheEax;		/* EAX=2: config parameters EAX */
+    uint32_t cacheEbx;		/* EAX=2: config parameters EBX */
+    uint32_t cacheEcx;		/* EAX=2: config parameters ECX */
+    uint32_t cacheEdx;		/* EAX=2: config parameters EDX */
+    uint32_t serialNo64[2];	/* EAX=3: lower 64 of 96 bit serial no */
+    uint32_t brandString[12];	/* EAX=0x8000000[234]: brand strings */
     } CPUID;
 
 
@@ -134,7 +134,7 @@ typedef union
 #define CPUID_FAMILY_EXTENDED	15	/* family: Extended		*/
 #define CPUID_FAMILY_PENTIUM4	 0	/* extended family: PENTIUM4	*/
 
-/* Intel family models */
+/* Intel family models (Table B-1 in System Programming Volume 3B) */
 
 #define CPUID_MODEL_PPRO	 1	/* model: Pentium Pro		*/
 #define CPUID_MODEL_P2_OVER	 2	/* model: Pentium II Overdrive	*/
@@ -153,7 +153,7 @@ typedef union
 #define CPUID_MODEL_I7		26	/* model: Core i7		*/
 #define CPUID_MODEL_ATOM	28	/* model: Atom			*/
 #define CPUID_MODEL_NEHALEM1	30	/* model: Core Architecture	*/
-#define CPUID_MODEL_NEHALEM2	32	/* model: Core Architecture	*/
+#define CPUID_MODEL_NEHALEM2	31	/* model: Core Architecture	*/
 #define CPUID_MODEL_NEHALEM3	46	/* model: Core Architecture	*/
 #define CPUID_MODEL_WESTMERE1	37	/* model: next generation	*/
 #define CPUID_MODEL_WESTMERE2	44	/* model: next generation	*/
@@ -281,6 +281,30 @@ typedef union
     uint32_t value;
     } CPUID_80000001_EDX;
 
+/* fields in the EDX register when EAX=0x80000001 */
+typedef union
+    {
+    struct
+	{
+	uint32_t reserved1:11;
+	uint32_t syscall:1;	/* SYSCALL/SYSRET instructions */
+	uint32_t reserved2:7;
+	uint32_t mp:1;		/* Multi-processor capable */
+	uint32_t nx:1;		/* Execute disable */
+	uint32_t reserved3:1;
+	uint32_t amdmmx:1;	/* AMD MMX extensions */
+	uint32_t reserved4:2;
+	uint32_t fxsave_opt:1;	/* FXSAVE/FXRSTOR optimizations */
+	uint32_t gbpage:1;	/* Gigabyte page support */
+	uint32_t rdtscp:1;	/* RDTSCP support */
+	uint32_t reserved5:1;
+	uint32_t lm:1;		/* Long mode em64t */
+	uint32_t amd3dnow2:1;	/* AMD 3DNow! extensions */
+	uint32_t amd3dnow:1;	/* AMD 3DNow! extensions */
+	} field;
+    uint32_t value;
+    } CPUID_80000001_EDX;
+
 /* fields in the EAX/EBX/ECX/EDX register when EAX=4 */
 
 /* CPUID: deterministic cache parameters definitions */
@@ -375,17 +399,29 @@ typedef union
     {
     struct
 	{
-	uint32_t rwx_support:3;	/* R W X support	*/
-	uint32_t gaw_support:5;	/* GAW support		*/
-	uint32_t emt_support:8;	/* EMT support		*/
-	uint32_t sp_support:4;	/* SP support		*/
-	uint32_t invept:1;	/* INVEPT supported	*/
-	uint32_t reserved1:3;
-	uint32_t invept_cap:8;	/* INVEPT capabilities	*/
-	uint32_t invpid:1;	/* INVPID supported	*/
-	uint32_t reserved2:7;
-	uint32_t invpid_cap:8;	/* INVPID capabilities	*/
-	uint32_t reserved3:16;
+	uint64_t ept_x_only:1;	   /* 0:     EPT execute only supported      */
+	uint64_t reserved1:5;	   /* 1-5:                                   */
+	uint64_t ept_pw4:1;	   /* 6:     EPT page walk length of 4       */
+	uint64_t reserved2:1;	   /* 7:                                     */
+	uint64_t ept_uc:1;	   /* 8:     EPT uncacheable supported       */
+	uint64_t reserved3:5;	   /* 9-13:                                  */
+	uint64_t ept_wb:1;	   /* 14:    EPT write-back supported        */
+	uint64_t reserved4:1;	   /* 15:                                    */
+	uint64_t ept_2mb:1;	   /* 16:    EPT 2MB pages supported         */
+	uint64_t ept_1gb:1;	   /* 17:    EPT 1GB pages supported         */
+	uint64_t reserved5:2;	   /* 18-19:                                 */
+	uint64_t invept:1;	   /* 20:    INVEPT supported                */
+	uint64_t reserved6:4;	   /* 21-24:                                 */
+	uint64_t invept_single:1;  /* 25:    single-context INVEPT supported */
+	uint64_t invept_all:1;	   /* 26:    all-context INVEPT supported    */
+	uint64_t reserved7:5;	   /* 27-31:                                 */
+	uint64_t invvpid:1;	   /* 32:    INVVPID supported               */
+	uint64_t reserved8:7;	   /* 33-39:                                 */
+	uint64_t invvpid_ind:1;	   /* 40:    individual-context INVVPID supp */
+	uint64_t invvpid_single:1; /* 41:    single-context INVVPID supported*/
+	uint64_t invvpid_all:1;	   /* 42:    all-context INVVPID supported   */
+	uint64_t invvpid_global:1; /* 43:    keep-global INVVPID supported   */
+	uint64_t reserved9:20;	   /* 44-63				     */
 	} field;
     uint64_t value;
     } EPT_VPID_CAP_MSR;
@@ -403,8 +439,8 @@ typedef struct mtrr_var		/* MTRR - variable range register */
 
 typedef struct mtrr		/* MTRR */
     {
-    int cap[2];			/* MTRR cap register */
-    int deftype[2];		/* MTRR defType register */
+    uint32_t cap[2];		/* MTRR cap register */
+    uint32_t deftype[2];	/* MTRR defType register */
     MTRR_FIX fix[11];		/* MTRR fixed range registers */
     MTRR_VAR var[8];		/* MTRR variable range registers */
     } MTRR;
@@ -1819,10 +1855,9 @@ extern void	x86GetCpuid (uint32_t operation,
 
 /* IDT related macros */
 
-#define IDT_TASK_GATE		0x0000e500	/* task gate: P=1, DPL=3, task id */
-
-#define IDT_TRAP_GATE		0x0000ef00	/* trap gate: P=1, DPL=3, trap id */
-#define IDT_INT_GATE		0x0000ee00	/* int gate: P=1, DPL=3, int id */
+#define IDT_TASK_GATE	0x0000e500	/* task gate: P=1, DPL=3, task id */
+#define IDT_TRAP_GATE	0x0000ef00	/* trap gate: P=1, DPL=3, trap id */
+#define IDT_INT_GATE	0x0000ee00	/* int gate: P=1, DPL=3, int id */
 
 /* TSS related macros */
 
diff --git a/arch/x86/kernel/vbi/syscalls.S b/arch/x86/kernel/vbi/syscalls.S
index c108a92..1817c43 100644
--- a/arch/x86/kernel/vbi/syscalls.S
+++ b/arch/x86/kernel/vbi/syscalls.S
@@ -261,33 +261,31 @@ vbi_hcall(vbi_vb_suspend, vbSuspend, 2)
 /*
  * vbi_vb_reset - Reset a virtual board's core
  *
- * This routine makes a hypercall in order to reset one or more cores
- * that exist within the specified virtual board. Calling this function
- * puts the target core(s) program counter to it's ENTRY function. The
- * ENTRY function is determined based on the loaded binary image. A core
- * does not execute beyond it's ENTRY function unless vbi_vb_restart() is
- * explitly called. Except for core0 within the target VB where
- * VBI_VBMGMT_RESET_AND_START_CORE0 option is set in the flag passed as
- * the third argument to this routine.  The hypercall sends a message to
- * a manager that provides VB managment services.  This function will
- * return only after all victim cores are reset unless the operation
- * fails to complete. The order of which the victim cores are reset is
- * not determined. The second argument identifies the cores to perform
- * the operation on.  The value of the second argument should be set to
- * one of the following:
+ * This routine makes a hypercall in order to reset one or more cores that
+ * exist within the specified virtual board. Calling this function puts the
+ * target core(s) program counter to it's ENTRY function. The ENTRY function
+ * is determined based on the loaded binary image. A core does not execute
+ * beyond it's ENTRY function unless vbiVbRestart() is explitly called.
+ * Except for core0 within the target VB where VBI_VBMGMT_RESET_AND_START_CORE0
+ * option is set in the flag passed as the third argument to this routine.
+ *
+ * The hypercall sends a message to a manager that provides VB managment
+ * services.  This function will return only after all victim cores are reset
+ * unless the operation fails to complete. The order of which the victim cores
+ * are reset is not determined. The second argument identifies the cores to
+ * perform the operation on.  The value of the second argument should be set
+ * to one of the following:
  *
  * VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
  *
  * VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the
  * victim VB
  *
- * A valid core number: Reset the specified core that exist within the
- * Virtual Board.
+ * A valid core number: Reset the specified core that exist within the VB.
  *
- * The third argument argument passed to this function specifies options
- * that are applicable only when the second argument is
- * VBI_VB_CORES_ALL. The options may be one of the following or a
- * combination:
+ * The third argument argument passed to this function specifies options that
+ * are applicable only when the second argument is VBI_VB_CORES_ALL. The
+ * options may be one of the following or a combination:
  *
  * VBI_VBMGMT_RESET_CLEAR: Zero out the core's memory, can only be used in
  * conjunction with VBI_VBMGMT_RESET_DOWNLOAD
@@ -297,10 +295,10 @@ vbi_hcall(vbi_vb_suspend, vbSuspend, 2)
  * VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
  *
  *
- * IMPORTANT: If a user chooses to restart core without reloading the
- * executable image then the data section must be restored to prevent
- * critical errors. It is the guest OS's responsibility to clear the bss
- * data sections in such scenario.
+ * IMPORTANT:
+ * If a user chooses to restart core without reloading the executable image then
+ * the data section must be restored to prevent critical errors. It is the
+ * guest OS's responsibility to clear the bss data sections in such scenario.
  *
  * RETURNS: OK or an error number in case of failure
  *
@@ -456,7 +454,7 @@ vbi_hcall(vbi_get_mem_attr, mmu_attr_get, 1)
  * Returns: OK or ERROR in case of failure
  *
  */
-vbi_hcall(vbi_ns_op, ns_op, 4)
+vbi_hcall(vbi_ns_op, ns_op, 6)
 
 /*
  * vbi_vb_write_mem - copy data to a remote board's memory
@@ -489,7 +487,7 @@ vbi_hcall(vbi_vb_write_mem, memWrite_op, 2)
  * memory control structure contains information about the target memory
  * to read and the destination buffer that hypervisor must populate with
  * the data read. This routine is used to copy data from a remote VB. It
- * is the user's responsability to ensure that the memory read is
+ * is the user's responsibility to ensure that the memory read is
  * accessed orthogonally.  The size_in parameter specifies the number of
  * bytes desired to be copied.  The size_out parameter indicates the
  * number of bytes successfully copied.  A user may set the size_out
@@ -507,8 +505,8 @@ vbi_hcall(vbi_vb_read_mem, memRead_op, 2)
  * This routine sends a message to the hypervisor debug shell manager in
  * order to start the WRHV shell program. The shell program spins
  * therefore does not share the processor with any other WRHV context.
- * By default a caller of this routine is detached to allow the caling
- * core to continue executing (as long as the are not scheduled to run
+ * By default a caller of this routine is detached to allow the calling
+ * core to continue executing (as long as they are not scheduled to run
  * on the same processor). An optional flag VBI_SHELL_ATTACH can be
  * specified to force the caller virtual board core to block while the
  * shell program is running.
diff --git a/include/vbi/compat.h b/include/vbi/compat.h
index a9d587b..873183a 100644
--- a/include/vbi/compat.h
+++ b/include/vbi/compat.h
@@ -68,7 +68,7 @@
 
 #define VB_TIMESTAMP		uint64_t
 #define vbiStatus_t		int32_t
-#define vbiIrq_t		uint32_t
+#define vbiIrq_t		int32_t
 #define vbiVb_t			uint32_t
 #define vbiCore_t		int32_t
 #define vbiCtx_t		int32_t
diff --git a/include/vbi/cpu_types.h b/include/vbi/cpu_types.h
index dbceb30..2d64f8f 100644
--- a/include/vbi/cpu_types.h
+++ b/include/vbi/cpu_types.h
@@ -21,6 +21,10 @@
 #define ARM1136		3
 #define MIPSI64R2	4
 #define PPCE500MC	5
+#define PPC32		6
+#define ARMCA9		7
+#define PPCE200		8
+
 
 #ifndef _ASMLANGUAGE
 
@@ -50,12 +54,14 @@ typedef unsigned long	_RType;		/* registers are 64 bits */
 #endif /* CPU == MIPSI64R2 */
 
 /* PowerPC specific types */
-#if (CPU == PPC85XX) || (CPU == PPCE500MC)
+
+#if (CPU == PPC85XX) || (CPU == PPCE500MC) || (CPU == PPCE200)
 typedef unsigned long	INSTR;		/* 32 bit word-aligned instructions */
 typedef unsigned int	_RType;		/* register type */
 #endif
 
 /* Pentium specific types */
+
 #if (CPU == PENTIUM)
 typedef unsigned char	INSTR;		/* char instructions */
 					/* register type */
diff --git a/include/vbi/interrupt.h b/include/vbi/interrupt.h
index b5c5fc0..5bff285 100644
--- a/include/vbi/interrupt.h
+++ b/include/vbi/interrupt.h
@@ -26,7 +26,7 @@ interrupts configuration data.
 
 #ifndef	_ASMLANGUAGE
 
-extern uint32_t vbi_find_irq(char *irq_name, int32_t irq_dir);
+extern int32_t vbi_find_irq(char *irq_name, int32_t irq_dir);
 
 #endif /* _ASMLANGUAGE */
 
diff --git a/include/vbi/pdc.h b/include/vbi/pdc.h
index b8d4f07..7d634e6 100644
--- a/include/vbi/pdc.h
+++ b/include/vbi/pdc.h
@@ -101,12 +101,12 @@ typedef enum {
 	PDC_REQUEST_MAX		= 4
 } vbi_pdc_request;
 
-extern int32_t vbi_pdc_op(vbi_pdc_handle pdcHandle, vbi_pdc_request requestType,
-			 uint32_t ioctlOp, void *bufferPtr, size_t bufferLen,
-			 uint64_t token);
-
-extern int32_t vbiPdcInit(const char *instanceName, vbi_pdc_handle *pPdcHandle);
+extern int32_t vbi_pdc_op(vbi_pdc_handle pdcHandle,
+			 vbi_pdc_request requestType, uint32_t ioctlOp,
+			 void *bufferPtr, size_t bufferLen, uint64_t token);
 
+extern int32_t vbi_pdc_init(const char *instanceName,
+			  vbi_pdc_handle *pPdcHandle);
 
 #endif
 
diff --git a/include/vbi/private.h b/include/vbi/private.h
index f1206b7..84fabfc 100644
--- a/include/vbi/private.h
+++ b/include/vbi/private.h
@@ -26,14 +26,15 @@
 #ifndef _ASMLANGUAGE
 
 /* private ioapic operator */
-extern asmlinkage int32_t vbi_io_apic_op(uint32_t ioctl, uint32_t irq, uint32_t filter, uint32_t vbId);
+extern asmlinkage int32_t vbi_io_apic_op(uint32_t ioctl, int32_t irq, uint32_t filter, uint32_t vbId);
 
 /* private interrupt redirection operator */
-extern asmlinkage int32_t vbi_vcore_irq_redirect(uint32_t irq, int32_t CoreId);
+extern asmlinkage int32_t vbi_vcore_irq_redirect(int32_t irq, int32_t CoreId);
 
 /* Name service private operator */
 extern asmlinkage int32_t vbi_ns_op(uint32_t op, char* name, uint32_t rev,
-			VBI_NS_HANDLE *handle);
+			VBI_NS_HANDLE *handle, uint32_t timeout,
+			uint32_t options);
 
 /* Message receive private operator */
 extern asmlinkage int32_t vbi_rx_op(void *rmsg, uint32_t rlen,
diff --git a/include/vbi/syscall.h b/include/vbi/syscall.h
index 7b44a3d..d5ac6e7 100644
--- a/include/vbi/syscall.h
+++ b/include/vbi/syscall.h
@@ -73,6 +73,7 @@ struct vbi_msg_ctl
 };
 
 /* message control flags */
+
 #define VBI_MSG_CTL_FLAG_RETRY 1
 
 /* memory read/write control structure */
@@ -101,6 +102,14 @@ extern asmlinkage int32_t vbi_vb_mgmt(uint32_t cmd, uint32_t boardId,
 extern asmlinkage int vbi_vtlb_op(unsigned int op, unsigned long arg1,
 				unsigned long arg2, unsigned long arg3);
 
+/* name server options and timeouts */
+
+#define VBI_NS_NOVERSION	0xffffffff /* no specific service version */
+#define VBI_NS_ANYVERSION	0xffffffff /* match any service version   */
+#define VBI_NS_OPTION_NONE	0x0000     /* no options                  */
+#define VBI_NS_OPTION_LOOKUP_WAIT 0x0001   /* wait for name registration  */
+#define VBI_NS_NO_TIMEOUT	0x0000     /* wait forever */
+
 /*
  * Modified APIs for VBI 2.0
  */
@@ -122,11 +131,17 @@ extern int32_t vbi_flush_icache(void *saddr, size_t size);
 extern asmlinkage int32_t vbi_kputs(const char *s);
 extern asmlinkage int32_t vbi_kputc(int c);
 extern int32_t vbi_config_vmmu(struct vmmuConfig * config);
+extern int32_t vbi_create_vmmu(struct vmmuConfig * config);
+extern int32_t vbi_delete_vmmu(struct vmmuConfig * config);
 extern int32_t vbi_enable_vmmu(uint32_t  vmmu_num);
 extern int32_t vbi_disable_vmmu(uint32_t vmmu_num);
+
 extern int32_t vbi_ns_register(char  *name, uint32_t  revision);
 extern int32_t vbi_ns_unregister(char *name, uint32_t  revision);
-extern int32_t vbi_ns_lookup(char *name, uint32_t  rev, VBI_NS_HANDLE *pHandle);
+extern int32_t vbi_ns_lookup_old(char *name, uint32_t  rev,
+				VBI_NS_HANDLE *pHandle);
+extern int32_t vbi_ns_lookup(char *name, uint32_t  rev, VBI_NS_HANDLE *pHandle,
+				uint32_t timeout, uint32_t options);
 extern int32_t vbi_tlb_flush_vmmu(struct vmmuConfig * config, void *addr, size_t len);
 
 
diff --git a/include/vbi/syscalls.h b/include/vbi/syscalls.h
index 53ee53e..7845091 100644
--- a/include/vbi/syscalls.h
+++ b/include/vbi/syscalls.h
@@ -1,7 +1,7 @@
 /*
  * syscalls.h - hypervisor system calls
  *
- * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ * Copyright (c) 2007-2010 Wind River Systems, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -112,6 +112,10 @@
 #define VBI_SYS_vbResume        HY_SYSCALL(25)	/* Resume vcores	*/
 #define VBI_SYS_vbRemote        HY_SYSCALL(26)	/* Get info of board	*/
 
+/* Additional VMMU calls */
+#define VBI_SYS_vmmu_create	HY_SYSCALL(30)
+#define VBI_SYS_vmmu_delete	HY_SYSCALL(31)
+#define VBI_SYS_vmmu_maxasid	HY_SYSCALL(32)	/* get max asid available */
 
 #define VBI_SYS_intRedirect     HY_SYSCALL(40)  /* vcores int redirect	*/
 
@@ -135,9 +139,12 @@
 #define VBI_SYS_RegsWrite_op	HY_SYSCALL(72)	/* register write operation */
 #define VBI_SYS_RegsRead_op	HY_SYSCALL(73)	/* register read operation */
 
+#define VBI_SYS_Pstate_set	HY_SYSCALL(74)	/* set core P state    */
+#define VBI_SYS_Cstate_set	HY_SYSCALL(75)	/* set core C state    */
+
 /* Max number of syscalls*/
 
-#define VBI_SYS_max		(73 + 1)
+#define VBI_SYS_max		(75 + 1)
 
 /* hyIoctl system call supported ioctl's */
 #define VBI_HYIOCTL_GETPID	 1	/* get context's pid		*/
@@ -150,6 +157,7 @@
 #define VBI_HYIOCTL_PADDR	 9	/* translate to physical address*/
 #define VBI_HYIOCTL_EXCOFFSETS_SET  10  /* set exc vector offsets for the VB*/
 #define VBI_HYIOCTL_EXCOFFSETS_GET  11	/* get exc vector offsets for the VB*/
+#define VBI_HYIOCTL_GETCONFIG	    12  /* get config page address */
 
 /* vIoapicIoctl system call supported ioctl's */
 #define VBI_IOAPICIOCTL_UNMASK	1	/* unmask v io apic interrupt src */
@@ -260,7 +268,8 @@
 /* vbi_ns_op system call supported operations */
 #define VBI_NS_REGISTER		1	/* register service name    */
 #define VBI_NS_UNREGISTER	2	/* unregister service name  */
-#define VBI_NS_LOOKUP	        3	/* look up service name	    */
+#define VBI_NS_LOOKUP_OLD	3	/* look up service name	    */
+#define VBI_NS_LOOKUP		4	/* look up service name	w/option */
 
 #ifndef _ASMLANGUAGE
 
diff --git a/include/vbi/vbi.h b/include/vbi/vbi.h
index 97f2a2a..ab99d6e 100644
--- a/include/vbi/vbi.h
+++ b/include/vbi/vbi.h
@@ -525,20 +525,20 @@ extern void vbi_exc_stub(void);
 extern void ASSERT_FN(const char *, const char *, int);
 extern void vbi_idle(uint64_t);
 extern void *vbi_get_vioapic_addr(void);
-extern int32_t vbi_set_vioapic_vec(uint32_t irq, int32_t vector);
-extern int32_t vbi_get_vioapic_vec(uint32_t irq);
-extern int32_t vbi_unmask_vioapic_irq(uint32_t irq);
-extern int32_t vbi_mask_vioapic_irq(uint32_t irq);
-extern int32_t vbi_ack_vioapic_irq(uint32_t irq);
+extern int32_t vbi_set_vioapic_vec(int32_t irq, int32_t vector);
+extern int32_t vbi_get_vioapic_vec(int32_t irq);
+extern int32_t vbi_unmask_vioapic_irq(int32_t irq);
+extern int32_t vbi_mask_vioapic_irq(int32_t irq);
+extern int32_t vbi_ack_vioapic_irq(int32_t irq);
 extern asmlinkage void vbi_di_eoi(void);
-extern int32_t vbi_send_vioapic_irq(uint32_t irq, uint32_t filter,
+extern int32_t vbi_send_vioapic_irq(int32_t irq, uint32_t filter,
 				      uint32_t target);
-extern int32_t vbi_send_vioapic_irq(uint32_t irq, uint32_t filter,
+extern int32_t vbi_send_vioapic_irq(int32_t irq, uint32_t filter,
 				     uint32_t vb);
-extern int32_t vbi_redir_vioapic_irq(uint32_t irq, int32_t tCore);
-extern int32_t vbi_send_vcore_vioapic_irq(uint32_t irq, uint32_t vcoreSet,
+extern int32_t vbi_redir_vioapic_irq(int32_t irq, int32_t tCore);
+extern int32_t vbi_send_vcore_vioapic_irq(int32_t irq, uint32_t vcoreSet,
 					  uint32_t options);
-extern uint32_t vbi_get_pending_vioapic_irq(void);
+extern int32_t vbi_get_pending_vioapic_irq(void);
 extern int32_t vbi_get_guest_dma_addr(void *gaddr, uint64_t *paddr);
 extern int32_t vbi_guest_phys_to_phys(void *gaddr, uint64_t *paddr);
 
diff --git a/include/vbi/vmmu.h b/include/vbi/vmmu.h
index 96e42a1..6c12eb6 100644
--- a/include/vbi/vmmu.h
+++ b/include/vbi/vmmu.h
@@ -86,6 +86,40 @@ word 1 (32-bits):
 		SX,SW,SR   - supervisor mode protection bits
 		UX,UW,UR   - user mode protection bits
 
+Above page table bits are numbered as per PPC(IBM) format MSB bit as 0, 
+The same entry can be represented using LSB bit as 0, as in mips64 arch:
+
+word 0 (32-bits):
+       
+          3 30          24 23          16 1 1 1 1 1 1 9 8 7     5 4    0
+          1                               5 4 3 2 1 0
+        +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+        |V|  Hypervisor  |   Reserved   |U|U|U|U|U|U|U|U| ERPN  | ATTR |
+        | |   Reserved   |              |0|1|2|3|4|5|6|7|       |      |
+        +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+
+               V          - valid bit
+               Hypervisor - reserved for use by hypervisor
+               U0-U7      - user defined attributes
+               ERPN       - extended real page number bits
+               ATTR       - page attributes
+
+
+word 1 (32-bits):
+
+          31                               12 11       8 7 6 5 4 3 2 1 0
+        +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+        |                RPN                | Reserved |R|C|U|S|U|S|U|S|
+        |                                   |          | | |X|X|W|W|R|R|
+        +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+
+               RPN        - real page number
+               R          - page referenced bit
+               C          - page changed bit
+               SX,SW,SR   - supervisor mode protection bits
+               UX,UW,UR   - user mode protection bits
+
+
 */
 
 #ifndef	_ASMLANGUAGE
@@ -145,7 +179,7 @@ typedef union vmmuEffectiveAddr /* effective Address structure */
 		u_int l2index:9;	/* Level 2 Index (512) */
 		u_int po:12;		/* Page Offset (4K) */
         } field;
-	void *addr;
+	uint32_t addr;
 } VMMU_EFFECTIVE_ADDR;
 
 /* Real Address Definition */
@@ -157,7 +191,7 @@ typedef union vmmuRealAddress	/* Real Address Structure */
 		u_int rpn:20;	/* Real Page Number */
 		u_int po:12;	/* Page Offset */
 	}field;
-	void *realAddr;	/* Real Address */
+	uint32_t realAddr;	/* Real Address */
 } VMMU_REAL_ADDRESS;
 
 /* Level-1 descriptor definition */
@@ -199,14 +233,28 @@ typedef union vmmu_level_2_tbl_ptr /* Level 2 Table pointer structure */
 
 typedef struct vmmuConfig
 {
-VMMU_LEVEL_1_DESC *addr;
-	u_int pageSize;
-	u_int contextId;
-	u_int vmmuNum;
+	/*
+	 * typecast addr to (VMMU_LEVEL_1_DESC *)
+	 * (void *) in 64-bit hypervisor becomes a 64-bit
+	 * value causing incorrect values set for addr
+	 * defining it as uint32_t would provide
+	 * backward compatibility to existing 32-bit Guest OS
+	 * and still support new 64-bit hypervisors
+	 * with 32-bit Guests
+	 */
+	uint32_t	addr;
+	uint32_t	flush_type;
+	uint32_t	asid;
+	uint32_t	vmmu_handle;
 } VMMU_CONFIG;
 
 #endif /* _ASMLANGUAGE */
 
+#define VMMU_TLB_FLUSH_ALL	0
+#define VMMU_TLB_FLUSH_NONE	1
+#define VMMU_TLB_FLUSH_ASID	2
+#define VMMU_TLB_FLUSH_ADDR	3
+
 #ifndef	VMMU_PAGE_SIZE
 #define	VMMU_PAGE_SIZE	4096	/* always use a 4KB page size */
 #define	VMMU_RPN_SHIFT	12
diff --git a/kernel/vbi/device.c b/kernel/vbi/device.c
index 33d5f4a..fd4f58a 100644
--- a/kernel/vbi/device.c
+++ b/kernel/vbi/device.c
@@ -27,8 +27,10 @@
 #include <vbi/syscall.h>
 #include <vbi/pdc.h>
 #include <vbi/syscalls.h>
+#include <vbi/device.h>
 
 #undef DEBUG
+
 #ifdef DEBUG
 #define DEBUG_PRINTF(fmt, args...) do { printk("%s: %d: %s: " fmt, \
 					VBI_BOARD_NAME_GET(), 	     \
diff --git a/kernel/vbi/interrupt.c b/kernel/vbi/interrupt.c
index ca9e9f7..60c1eaf 100644
--- a/kernel/vbi/interrupt.c
+++ b/kernel/vbi/interrupt.c
@@ -43,7 +43,7 @@
  *
  */
 
-uint32_t vbi_find_irq(char *irq_name, int32_t irq_dir)
+int32_t vbi_find_irq(char *irq_name, int32_t irq_dir)
 {
 	struct vb_config *config = VBI_CONFIG_ADDR_GET();
 	struct vb_int_info *info = config->interruptConfiguration;
diff --git a/kernel/vbi/io_apic.c b/kernel/vbi/io_apic.c
index b6fba67..7952485 100644
--- a/kernel/vbi/io_apic.c
+++ b/kernel/vbi/io_apic.c
@@ -81,7 +81,7 @@ void *vbi_get_vioapic_addr(void)
  * This routine is currently not supported for PPC.
  *
  */
-int32_t vbi_set_vioapic_vec(uint32_t irq, int32_t vector)
+int32_t vbi_set_vioapic_vec(int32_t irq, int32_t vector)
 {
 	volatile VIOAPIC *pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
 
@@ -111,7 +111,7 @@ int32_t vbi_set_vioapic_vec(uint32_t irq, int32_t vector)
  * This routine is currently not supported for PPC
  *
  */
-int32_t vbi_get_vioapic_vec(uint32_t irq)
+int32_t vbi_get_vioapic_vec(int32_t irq)
 {
 	volatile VIOAPIC *pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
 	int32_t vector;
@@ -142,7 +142,7 @@ int32_t vbi_get_vioapic_vec(uint32_t irq)
  * specified IRQ directed to the calling virtual Core.
  *
  */
-int32_t vbi_unmask_vioapic_irq(uint32_t irq)
+int32_t vbi_unmask_vioapic_irq(int32_t irq)
 {
 	volatile VIOAPIC *pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
 
@@ -168,7 +168,7 @@ EXPORT_SYMBOL(vbi_unmask_vioapic_irq);
  * vbi_unmask_vioapic_irq().
  *
  */
-int32_t vbi_mask_vioapic_irq(uint32_t irq)
+int32_t vbi_mask_vioapic_irq(int32_t irq)
 {
 	volatile VIOAPIC *pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
 
@@ -194,7 +194,7 @@ int32_t vbi_mask_vioapic_irq(uint32_t irq)
  * required to be acknowledged.
  *
  */
-int32_t vbi_ack_vioapic_irq(uint32_t irq)
+int32_t vbi_ack_vioapic_irq(int32_t irq)
 {
 
 	if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
@@ -244,7 +244,7 @@ int32_t vbi_ack_vioapic_irq(uint32_t irq)
  * VIOAPIC_SEND_NONE	- Ignore this call.
  *
  */
-int32_t vbi_send_vioapic_irq(uint32_t irq, uint32_t filter, uint32_t target)
+int32_t vbi_send_vioapic_irq(int32_t irq, uint32_t filter, uint32_t target)
 {
 	return vbi_io_apic_op(VBI_IOAPICIOCTL_SEND, irq, filter, target);
 }
@@ -265,7 +265,7 @@ EXPORT_SYMBOL(vbi_send_vioapic_irq);
  * VBI_IOAPICSEND_VCORE_NONE.
  *
  */
-int32_t vbi_send_vcore_vioapic_irq(uint32_t irq, uint32_t coreSet,
+int32_t vbi_send_vcore_vioapic_irq(int32_t irq, uint32_t coreSet,
 			uint32_t options)
 {
 	return vbi_io_apic_op(VBI_IOAPICIOCTL_VCORE_SEND, irq, coreSet, options);
@@ -278,7 +278,7 @@ int32_t vbi_send_vcore_vioapic_irq(uint32_t irq, uint32_t coreSet,
  * within the same virtual board.
  *
  */
-int32_t vbi_redir_vioapic_irq(uint32_t irq, int32_t core)
+int32_t vbi_redir_vioapic_irq(int32_t irq, int32_t core)
 {
 	return vbi_vcore_irq_redirect(irq, core);
 }
@@ -294,9 +294,9 @@ int32_t vbi_redir_vioapic_irq(uint32_t irq, int32_t core)
  * interrupts which requires support to read the specific vector pending. This
  * function is provided for all architectures for completeness.
  */
-uint32_t vbi_get_pending_vioapic_irq(void)
+int32_t vbi_get_pending_vioapic_irq(void)
 {
-	uint32_t pendingIrq;
+	int32_t pendingIrq;
 
 	/* shouldn't these ops be atomic? */
 
diff --git a/kernel/vbi/lib.c b/kernel/vbi/lib.c
index e1c5a97..348cfb6 100644
--- a/kernel/vbi/lib.c
+++ b/kernel/vbi/lib.c
@@ -25,10 +25,10 @@ documents are provided as supplement for APIs tied to a particular hardware
 architecture platform.
 
 A given system may be composed of multiple VB where each VB may contain multiple
-Cores. During system bring-up stage hypervisor VB manager allocates resources
+cores. During system bring-up stage hypervisor VB manager allocates resources
 specified in the XML configuration file for the each VB and initializes the
 configuration structure. Then the cores are launched starting at the entry point
-specified in the guest payload image. Hypervisor passes a pointer of the
+specified in the guest payload image. Hypervisor passes a pointer to the
 configuration page and a 32bit flag that holds the boot options of the core.
 These parameters are passed via stack or registers based on the underlying
 architecture platform.
@@ -156,7 +156,7 @@ struct vb_status *wr_vb_status;	/* The address of the core's Status area */
  * modification has the effect of altering the binary compatibility with it's
  * predecessor. Which means that the VBI lib used in the guest must match the
  * version that hypervisor kernel was built against in order to be binary
- * compatible. In otherwords the major version fragments must be identitical
+ * compatible. In otherwords the major version fragments must be identical
  * between a guest OS and hypervisor. These type of mods may update the C
  * structures but conserve the vbi functions signatures. Additional APIs may be
  * added.
@@ -165,7 +165,7 @@ struct vb_status *wr_vb_status;	/* The address of the core's Status area */
  * carefully done to prevent breaking Guest OS using a older version of the vbi
  * library. This implies that a Minor version updates must maintain the binary
  * compatibility between VBI versions. It is important to note that this is
- * applicable to only to VBI 2.0 or later versions.
+ * applicable to only VBI 2.0 or later versions.
  * This type of updates should not alter the API or structures definitions.
  * The vbi library may be extended with new API's that are orthogonal with the
  * existing ones (the current version at any point in time). The existing
diff --git a/kernel/vbi/msg.c b/kernel/vbi/msg.c
index a614c91..df1ffc8 100644
--- a/kernel/vbi/msg.c
+++ b/kernel/vbi/msg.c
@@ -42,11 +42,14 @@ int32_t vbi_receive(void *rmsg, uint32_t rlen, struct vbi_msg_info *info,
 		retval = vbi_rx_op(rmsg, rlen, info, ctl);
 
 		/* if retry flag set, continue */
-		if ((ctl->flags & VBI_MSG_CTL_FLAG_RETRY) != VBI_MSG_CTL_FLAG_RETRY)
+		if (!ctl ||
+			(ctl && ((ctl->flags & VBI_MSG_CTL_FLAG_RETRY)
+				!= VBI_MSG_CTL_FLAG_RETRY)))
 			break;
 
 		/* if retry flag is set _AND_ msg was aborted, retry */
-		if (info->error != VBI_MSG_ERROR_ABORTED)
+		if (!info ||
+			(info && (info->error != VBI_MSG_ERROR_ABORTED)))
 			break;
 
 		DEBUGM("%s aborted, retrying \n", __FUNCTION__);
diff --git a/kernel/vbi/ns.c b/kernel/vbi/ns.c
index 025c986..e0f3121 100644
--- a/kernel/vbi/ns.c
+++ b/kernel/vbi/ns.c
@@ -48,7 +48,8 @@ int32_t vbi_ns_register(char *name, uint32_t revision)
 	if (name == NULL)
 		return -1;
 
-	return vbi_ns_op(VBI_NS_REGISTER, name, revision, NULL);
+	return vbi_ns_op(VBI_NS_REGISTER, name, revision, NULL,
+			VBI_NS_NO_TIMEOUT, VBI_NS_OPTION_NONE);
 }
 
 /*
@@ -64,21 +65,63 @@ int32_t vbi_ns_unregister(char *name, uint32_t revision)
 	if (name == NULL)
 		return -1;
 
-	return vbi_ns_op(VBI_NS_UNREGISTER, name, revision, NULL);
+	return vbi_ns_op(VBI_NS_UNREGISTER, name, revision, NULL,
+			VBI_NS_NO_TIMEOUT, VBI_NS_OPTION_NONE);
+}
+
+/*
+ * vbi_ns_lookup_old - look up a service provider using the naming system
+ *
+ * This routine uses the naming system to look up the context id of the
+ * provider of the specified service.  A service is denoted by both an ASCII
+ * string name and a numerical version number.  When performing a search for
+ * a matching service, both the name and the version number must match.
+ *
+ * If a specific version of a service is not required, the version can
+ * be specified as SYS_NS_ANYVERSION.  In this case the highest version
+ * of the service name will be returned.
+ *
+ * NOTE: this interface is the older interface which does not allow specifying
+ * a timeout value or options.  It is only provided for backwards compatibility
+ * purposes, vbiNsLookup() should be used instead.
+ *
+ */
+int32_t vbi_ns_lookup_old(char *name, uint32_t revision, VBI_NS_HANDLE *handle)
+{
+	if (name == NULL || handle == NULL)
+		return -1;
+
+	return vbi_ns_op(VBI_NS_LOOKUP_OLD, name, revision, handle,
+			VBI_NS_NO_TIMEOUT, VBI_NS_OPTION_NONE);
 }
 
 /*
  * vbi_ns_lookup - look up a service provider using the naming system
  *
  * This routine uses the naming system to look up the context id of the
- * provider of the specified service.  A message for the request is
- * formulated and sent off to the name service manager for processing.
+ * provider of the specified service.  A service is denoted by both an ASCII
+ * string name and a numerical version number.  When performing a search for
+ * a matching service, both the name and the version number must match.
+ *
+ * If a specific version of a service is not required, the version can
+ * be specified as SYS_NS_ANYVERSION.  In this case the highest version
+ * of the service name will be returned.
+ *
+ * The following options may be specified:
+ *
+ * SYS_NS_OPTION_NONE - no additional options
+ * SYS_NS_OPTION_LOOKUP_WAIT - wait for the service to be registered
+ *
+ * The timeout value can be used to limit the amount of time to wait when
+ * the SYS_NS_OPTION_LOOKUP_WAIT option is specified.
  *
  */
-int32_t vbi_ns_lookup(char *name, uint32_t revision, VBI_NS_HANDLE *handle)
+int32_t vbi_ns_lookup(char *name, uint32_t revision, VBI_NS_HANDLE *handle,
+			uint32_t timeout, uint32_t options)
 {
 	if (name == NULL || handle == NULL)
 		return -1;
 
-	return vbi_ns_op(VBI_NS_LOOKUP , name, revision, handle);
+	return vbi_ns_op(VBI_NS_LOOKUP , name, revision, handle, timeout,
+			options);
 }
diff --git a/kernel/vbi/pdc.c b/kernel/vbi/pdc.c
index 199dfd6..48c44ef 100644
--- a/kernel/vbi/pdc.c
+++ b/kernel/vbi/pdc.c
@@ -62,7 +62,7 @@ static uint32_t pdcHandleGet(vbi_pdc_handle pdcHandle)
 
 /*
  *
- * vbiPdcOp - send message on Paravirtualized Device channel
+ * vbi_pdc_op - send message on Paravirtualized Device channel
  *
  */
 
@@ -76,13 +76,13 @@ int32_t vbi_pdc_op(vbi_pdc_handle pdcHandle, vbi_pdc_request requestType,
 	if (pdcHandle == 0
 		|| (pdcHandle >= VB_MAX_VIRTUAL_BOARDS)
 		|| -1 == pdcHandleGet(pdcHandle)) {
-			DEBUG_PRINTF("vbiPdcOp: invalid handle\n");
+			DEBUG_PRINTF("vbi_pdc_op: invalid handle\n");
 			return (-1);
 	}
 
 	if ((requestType < PDC_REQUEST_MIN)
 		|| (requestType > PDC_REQUEST_MAX)) {
-		DEBUG_PRINTF("vbiPdcOp: invalid request\n");
+		DEBUG_PRINTF("vbi_pdc_op: invalid request\n");
 		return (-1);
 	}
 
@@ -95,12 +95,12 @@ int32_t vbi_pdc_op(vbi_pdc_handle pdcHandle, vbi_pdc_request requestType,
 
 	if (vbi_send (pdcHandle, &requestMsg, sizeof(requestMsg),
 		&replyMsg, sizeof(replyMsg), NULL, NULL) != 0) {
-		DEBUG_PRINTF("vbiSend fails\n");
+		DEBUG_PRINTF("vbi_send fails\n");
 		return -1;
 	}
 
 	if (replyMsg.status != 0) {	
-		DEBUG_PRINTF("vbiSend reply != OK\n");
+		DEBUG_PRINTF("vbi_send reply != OK\n");
 		return (VBI_ERR_ADD_RETRY);
 	}
 
@@ -112,26 +112,27 @@ int32_t vbi_pdc_op(vbi_pdc_handle pdcHandle, vbi_pdc_request requestType,
 
 /*
  *
- * vbiPdcInit - Initialize Paravirtualized Device channel
+ * vbi_pdc_init - Initialize Paravirtualized Device channel
  *
  */
 
-int32_t vbiPdcInit(const char *instanceName, vbi_pdc_handle *pPdcHandle)
+int32_t vbi_pdc_init(const char *instanceName, vbi_pdc_handle *pPdcHandle)
 {
 	int32_t 	retStatus;
 
 	/* validate ADD Guest Interface name */
 
 	if (instanceName == NULL) {
-		DEBUG_PRINTF("vbiPdcInit: instanceName NULL\n");
+		DEBUG_PRINTF("vbi_pdc_init: instanceName NULL\n");
 		return VBI_ERR_DEVDRV_NULL_NAME;
 	}
 	if (pPdcHandle == NULL) {
-		DEBUG_PRINTF("vbiPdcInit: pPdcHandle NULL\n");
+		DEBUG_PRINTF("vbi_pdc_init: pPdcHandle NULL\n");
 		return VBI_ERR_DEVDRV_NULL_HANDLE;
 	}
 	/* call Name Server to lookup ADD Guest Interface */
-	retStatus = vbi_ns_lookup((char *)instanceName, 0, pPdcHandle);
+	retStatus = vbi_ns_lookup((char *)instanceName, 0, pPdcHandle,
+				VBI_NS_NO_TIMEOUT, VBI_NS_OPTION_NONE);
 	if (retStatus == 0) {
 		DEBUG_PRINTF("Successfully connected to %s\n", instanceName);
 		pdcHandleSet(*pPdcHandle);
diff --git a/kernel/vbi/show.c b/kernel/vbi/show.c
index a48e306..775b884 100644
--- a/kernel/vbi/show.c
+++ b/kernel/vbi/show.c
@@ -130,8 +130,8 @@ static void vbi_show_device(void)
 	struct vb_dev_int_info *pi = NULL;
 	struct vb_dev_regset_info *pr = NULL;
 	struct vb_dev_device_tree_source_info *pd = NULL;
-	int num_devices = config->numDevices;
-	int i, j, k;
+	unsigned int num_devices = config->numDevices;
+	unsigned int i, j, k;
 
 	printk("%d device configurations, Config at 0x%x\n", num_devices,
 			(unsigned int)p);
-- 
1.6.5.2

