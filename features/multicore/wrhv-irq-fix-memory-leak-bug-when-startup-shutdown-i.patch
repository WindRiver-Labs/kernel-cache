From d8d021db55670bcf40a19affaa51758c28afdcae Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Wed, 11 Aug 2010 15:45:32 +0800
Subject: [PATCH 2/3] wrhv/irq: fix memory leak bug when startup/shutdown irq

Since the irq startup/shutdown are always invoked with irq disabled,
we can't call smp_call_function_signle in these functions. Our
previous implementation pre-allocate a call_single_data structure,
and call __smp_call_function_single to get the mask/unmask function
executed on the specific core. But we don't have a chance to
free the pre-allocate structure, and then cause memory leak.
Fix these bugs by using a tasklet to invoke smp_call_function_single.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 kernel/vbi/wrhv.c |   59 ++++++++++++++++++++++++++++++++--------------------
 1 files changed, 36 insertions(+), 23 deletions(-)

diff --git a/kernel/vbi/wrhv.c b/kernel/vbi/wrhv.c
index 2f99450..bad7ed6 100644
--- a/kernel/vbi/wrhv.c
+++ b/kernel/vbi/wrhv.c
@@ -31,7 +31,9 @@
 
 #ifdef CONFIG_SMP
 enum wrhv_irq_action {
-	WRHV_IRQ_SET_AFFINITY = 1
+	WRHV_IRQ_SET_AFFINITY = 1,
+	WRHV_IRQ_SHUTDOWN,
+	WRHV_IRQ_STARTUP
 };
 
 struct wrhv_irq_struct {
@@ -91,16 +93,6 @@ static void wrhv_unmask_irq(unsigned int irq)
 }
 
 #ifdef CONFIG_SMP
-static void smp_wrhv_mask_irq(void *irq)
-{
-	vbi_mask_vioapic_irq((unsigned int)irq);
-}
-
-static void smp_wrhv_unmask_irq(void *irq)
-{
-	vbi_unmask_vioapic_irq((unsigned int)irq);
-}
-
 static void wrhv_mask_irq_ipi(void *p)
 {
 	unsigned int irq = *(unsigned int *)p;
@@ -142,6 +134,13 @@ static void wrhv_irq_task(unsigned long arg)
 			vbi_vcore_irq_redirect(irq, ncpu);
 			break;
 		}
+		case WRHV_IRQ_SHUTDOWN:
+			smp_call_function_single(0, wrhv_mask_irq_ipi, &irq, 1);
+			break;
+		case WRHV_IRQ_STARTUP:
+			smp_call_function_single(0, wrhv_unmask_irq_ipi,
+						&irq, 1);
+			break;
 		default:
 			printk(KERN_ERR "Unknown action for irq task\n");
 		}
@@ -158,36 +157,50 @@ static void wrhv_irq_task(unsigned long arg)
 static void smp_wrhv_shutdown_irq(unsigned int irq)
 {
 	if (smp_processor_id() == 0)
-		smp_wrhv_mask_irq((void *)irq);
+		wrhv_mask_irq(irq);
 	else {
-		struct call_single_data *data;
+		struct wrhv_irq_struct *data;
+		struct wrhv_irq_head *head = &wrhv_irq_head;
 
 		data = kmalloc(sizeof(*data), GFP_ATOMIC);
 		if (!data)
 			return;
 
-		data->flags = CSD_FLAG_ALLOC;
-		data->func = smp_wrhv_mask_irq;
-		data->info = (void *)irq;
-		__smp_call_function_single(0, data, 0);
+		data->irq = irq;
+		data->next = NULL;
+		data->action = WRHV_IRQ_SHUTDOWN;
+
+		spin_lock(&wrhv_irq_lock);
+		*head->next = data;
+		head->next = &(data->next);
+		spin_unlock(&wrhv_irq_lock);
+
+		tasklet_schedule(&wrhv_irq_tasklet);
 	}
 }
 
 static unsigned int smp_wrhv_startup_irq(unsigned int irq)
 {
 	if (smp_processor_id() == 0)
-		smp_wrhv_unmask_irq((void *)irq);
+		wrhv_unmask_irq(irq);
 	else {
-		struct call_single_data *data;
+		struct wrhv_irq_struct *data;
+		struct wrhv_irq_head *head = &wrhv_irq_head;
 
 		data = kmalloc(sizeof(*data), GFP_ATOMIC);
 		if (!data)
 			return -ENOMEM;
 
-		data->flags = CSD_FLAG_ALLOC;
-		data->func = smp_wrhv_unmask_irq;
-		data->info = (void *)irq;
-		__smp_call_function_single(0, data, 0);
+		data->irq = irq;
+		data->next = NULL;
+		data->action = WRHV_IRQ_STARTUP;
+
+		spin_lock(&wrhv_irq_lock);
+		*head->next = data;
+		head->next = &(data->next);
+		spin_unlock(&wrhv_irq_lock);
+
+		tasklet_schedule(&wrhv_irq_tasklet);
 	}
 	return 0;
 }
-- 
1.6.5.2

