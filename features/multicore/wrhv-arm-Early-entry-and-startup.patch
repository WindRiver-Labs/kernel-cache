From 3146fde44ed7c8273bd3dd8c9b4f4fa4b405975a Mon Sep 17 00:00:00 2001
From: Jim Somerville <Jim.Somerville@windriver.com>
Date: Wed, 3 Aug 2011 13:25:23 -0400
Subject: [PATCH 04/10] wrhv: arm:  Early entry and startup

Note that the vmmu is enabled and used very early in head.S.

Signed-off-by: Jim Somerville <Jim.Somerville@windriver.com>
---
 arch/arm/kernel/asm-offsets.c  |   27 +++++++++++++++++
 arch/arm/kernel/entry-common.S |    2 +-
 arch/arm/kernel/head.S         |   62 ++++++++++++++++++++++++++++++++++++++-
 arch/arm/kernel/setup.c        |   63 +++++++++++++++++++++++++++++++++++++++-
 4 files changed, 150 insertions(+), 4 deletions(-)

diff --git a/arch/arm/kernel/asm-offsets.c b/arch/arm/kernel/asm-offsets.c
index 8835115..eda76f3 100644
--- a/arch/arm/kernel/asm-offsets.c
+++ b/arch/arm/kernel/asm-offsets.c
@@ -19,6 +19,13 @@
 #include <asm/procinfo.h>
 #include <linux/kbuild.h>
 
+#ifdef CONFIG_WRHV
+#include <vbi/types.h>
+#include <asm/arch_vbi.h>
+#include <vbi/interface.h>
+#include <vbi/vmmu.h>
+#endif
+
 /*
  * Make sure that the compiler and target are compatible.
  */
@@ -117,5 +124,25 @@ int main(void)
   DEFINE(DMA_BIDIRECTIONAL,	DMA_BIDIRECTIONAL);
   DEFINE(DMA_TO_DEVICE,		DMA_TO_DEVICE);
   DEFINE(DMA_FROM_DEVICE,	DMA_FROM_DEVICE);
+#ifdef CONFIG_WRHV
+  DEFINE(MM_VMMU_HANDLE,	offsetof(struct mm_struct,
+					context.vmmu_handle));
+  DEFINE(CTRL_SPACE_ASID,	offsetof(struct vb_arch_ctrl_regs, asid));
+  DEFINE(CTRL_SPACE_VMMUHANDLE,	offsetof(struct vb_arch_ctrl_regs,
+					vmmu_handle));
+  DEFINE(STAT_SPACE_IFAR,	offsetof(struct vb_arch_stat_regs, ifar));
+  DEFINE(STAT_SPACE_IFSR,	offsetof(struct vb_arch_stat_regs, ifsr));
+  DEFINE(STAT_SPACE_DFAR,	offsetof(struct vb_arch_stat_regs, dfar));
+  DEFINE(STAT_SPACE_DFSR,	offsetof(struct vb_arch_stat_regs, dfsr));
+  DEFINE(STAT_SPACE_ABT_LR,	offsetof(struct vb_arch_stat_regs,
+					modeSpecificReg[ABT_MODE & 0xf].lr));
+  DEFINE(STAT_SPACE_ABT_SPSR,	offsetof(struct vb_arch_stat_regs,
+					modeSpecificReg[ABT_MODE & 0xf].spsr));
+  DEFINE(CTRL_SPACE_PTR,	offsetof(struct vb_config, vb_control));
+  DEFINE(VMMU_CFG_ADDR,		offsetof(VMMU_CONFIG, addr));
+  DEFINE(VMMU_CFG_FLUSH_TYPE,	offsetof(VMMU_CONFIG, flush_type));
+  DEFINE(VMMU_CFG_ASID,		offsetof(VMMU_CONFIG, asid));
+  DEFINE(VMMU_CFG_VMMU_HANDLE,	offsetof(VMMU_CONFIG, vmmu_handle));
+#endif
   return 0; 
 }
diff --git a/arch/arm/kernel/entry-common.S b/arch/arm/kernel/entry-common.S
index fda8ed1..4c62788 100644
--- a/arch/arm/kernel/entry-common.S
+++ b/arch/arm/kernel/entry-common.S
@@ -250,7 +250,7 @@ ENTRY(vector_swi)
 
 #endif
 
-#ifdef CONFIG_ALIGNMENT_TRAP
+#if defined(CONFIG_ALIGNMENT_TRAP) && !defined(CONFIG_WRHV)
 	ldr	ip, __cr_alignment
 	ldr	ip, [ip]
 	mcr	p15, 0, ip, c1, c0		@ update control register
diff --git a/arch/arm/kernel/head.S b/arch/arm/kernel/head.S
index 82ea924..0e8a01b 100644
--- a/arch/arm/kernel/head.S
+++ b/arch/arm/kernel/head.S
@@ -79,6 +79,17 @@ ENTRY(stext)
 	setmode	PSR_F_BIT | PSR_I_BIT | SVC_MODE, r9 @ ensure svc mode
 						@ and irqs disabled
 	mrc	p15, 0, r9, c0, c0		@ get processor id
+#ifdef CONFIG_WRHV
+	ldr	r1, =wr_config
+	str	r0, [r1]			@ save pointer to config info
+
+	@ Force machine type until we find a better way to be told what
+	@ platform we are running on.  No U-boot here to tell us.  So just
+	@ assume we are running on the first (and likely only) platform that
+	@ has been linked in to our load.
+	ldr	r0, =__arch_info_begin
+	ldr	r1, [r0]
+#endif
 	bl	__lookup_processor_type		@ r5=procinfo r9=cpuid
 	movs	r10, r5				@ invalid processor (r5=0)?
 	beq	__error_p			@ yes, error 'p'
@@ -149,8 +160,17 @@ __secondary_data:
 	.long	secondary_data
 	.long	__secondary_switched
 #endif /* defined(CONFIG_SMP) */
-
-
+#ifdef CONFIG_WRHV
+        .align  2
+        .type   __wrhv_data, %object
+__wrhv_data:
+	.long	BSYM(vbi_enable_vmmu) @ r4
+	.long	BSYM(vbi_create_vmmu) @ r5
+	.long	BSYM(vbi_load_ctx)    @ r6
+	.long	BSYM(wr_config)	      @ r7
+	.long	BSYM(vmmu_cfg)	      @ r8
+	.long   BSYM(init_thread_union) + THREAD_START_SP @ sp
+#endif
 
 /*
  * Setup common bits before finally enabling the MMU.  Essentially
@@ -177,8 +197,34 @@ __enable_mmu:
 		      domain_val(DOMAIN_TABLE, DOMAIN_MANAGER) | \
 		      domain_val(DOMAIN_IO, DOMAIN_CLIENT))
 	mcr	p15, 0, r5, c3, c0, 0		@ load domain access register
+#ifndef CONFIG_WRHV
 	mcr	p15, 0, r4, c2, c0, 0		@ load page table pointer
 	b	__turn_mmu_on
+#else  /* WRHV - turn on the vmmu */
+	mov	r12, r13
+	mov	r11, r1
+	mov	r10, r0
+	adr	r0, BSYM(__wrhv_data)
+	ldmia	r0, {r4-r8,sp}
+	mov	r0, #0
+	blx	r4		@ call vbi_enable_vmmu
+	ldr	r4, =swapper_pg_dir
+	str	r4, [r8, #VMMU_CFG_ADDR]	@ addr field
+	mov	r4, #0
+	str	r4, [r8, #VMMU_CFG_FLUSH_TYPE]	@ flushtype field
+	str	r4, [r8, #VMMU_CFG_ASID]	@ asid field
+	mov	r0, r8
+	blx	r5		@ call vbi_create_vmmu
+	ldr	r5, [r8, #VMMU_CFG_VMMU_HANDLE]	@ handle field
+	ldr	r7, [r7]	@ get pointer to config space
+	ldr	r7, [r7, #CTRL_SPACE_PTR]	@ get pointer to control space
+	str	r5, [r7, #CTRL_SPACE_VMMUHANDLE] @ handle field
+	str	r4, [r7, #CTRL_SPACE_ASID] @ asid field
+	blx	r6		@ call vbi_load_ctx
+	mov	r1, r11
+	mov	r0, r10
+	mov	pc, r12
+#endif
 ENDPROC(__enable_mmu)
 
 /*
@@ -330,6 +376,18 @@ __create_page_tables:
 	add	r0, r4, #0xd8000000 >> 18
 	str	r3, [r0]
 #endif
+#ifdef CONFIG_WRHV
+	/*
+	 * Map in the config/control/status pages for early startup.
+	 * This should get overwritten in paging_init for proper size
+	 * and protection.
+	 */
+	ldr	r6, =wr_config
+	ldr	r6, [r6]			@ r6 now points to config
+	add	r0, r4, r6, lsr #18
+	orr	r3, r7, r6
+	str	r3, [r0]
+#endif
 #endif
 	mov	pc, lr
 ENDPROC(__create_page_tables)
diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index b218e8d..4389de0 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -48,6 +48,12 @@
 #include "atags.h"
 #include "tcm.h"
 
+#ifdef CONFIG_WRHV
+#include <vbi/syscall.h>
+#include <vbi/vmmu.h>
+#include <asm/wrhv.h>
+#endif
+
 #ifndef MEM_SIZE
 #define MEM_SIZE	(16*1024*1024)
 #endif
@@ -115,6 +121,9 @@ struct stack {
 	u32 irq[3];
 	u32 abt[3];
 	u32 und[3];
+#ifdef CONFIG_WRHV
+	u32 fiq[3];
+#endif
 } ____cacheline_aligned;
 
 static struct stack stacks[NR_CPUS];
@@ -358,7 +367,14 @@ void cpu_init(void)
 	"msr	cpsr_c, %5\n\t"
 	"add	r14, %0, %6\n\t"
 	"mov	sp, r14\n\t"
+#ifndef CONFIG_WRHV
 	"msr	cpsr_c, %7"
+#else
+	"msr	cpsr_c, %7\n\t"
+	"add	r14, %0, %8\n\t"
+	"mov	sp, r14\n\t"
+	"msr	cpsr_c, %9"
+#endif
 	    :
 	    : "r" (stk),
 	      PLC (PSR_F_BIT | PSR_I_BIT | IRQ_MODE),
@@ -367,6 +383,10 @@ void cpu_init(void)
 	      "I" (offsetof(struct stack, abt[0])),
 	      PLC (PSR_F_BIT | PSR_I_BIT | UND_MODE),
 	      "I" (offsetof(struct stack, und[0])),
+#ifdef CONFIG_WRHV
+	      PLC (PSR_F_BIT | PSR_I_BIT | FIQ_MODE),
+	      "I" (offsetof(struct stack, fiq[0])),
+#endif
 	      PLC (PSR_F_BIT | PSR_I_BIT | SVC_MODE)
 	    : "r14");
 }
@@ -390,7 +410,11 @@ static struct machine_desc * __init setup_machine(unsigned int nr)
 	return list;
 }
 
+#ifndef CONFIG_WRHV
 static int __init arm_add_memory(unsigned long start, unsigned long size)
+#else
+int __init arm_add_memory(unsigned long start, unsigned long size)
+#endif
 {
 	struct membank *bank = &meminfo.bank[meminfo.nr_banks];
 
@@ -606,6 +630,7 @@ static int __init parse_tag_cmdline(const struct tag *tag)
 
 __tagtable(ATAG_CMDLINE, parse_tag_cmdline);
 
+#ifndef CONFIG_WRHV
 /*
  * Scan the tag table for this tag, and call its parse function.
  * The tag table is built by the linker from all the __tagtable
@@ -654,6 +679,7 @@ static struct init_tags {
 	{ MEM_SIZE, PHYS_OFFSET },
 	{ 0, ATAG_NONE }
 };
+#endif
 
 static void (*init_machine)(void) __initdata;
 
@@ -666,11 +692,25 @@ static int __init customize_machine(void)
 }
 arch_initcall(customize_machine);
 
+#ifdef CONFIG_PARAVIRT
+extern void paravirt_init(void);
+extern void paravirt_MMU_init(void);
+#endif
+
 void __init setup_arch(char **cmdline_p)
 {
+#ifndef CONFIG_WRHV
 	struct tag *tags = (struct tag *)&init_tags;
-	struct machine_desc *mdesc;
 	char *from = default_command_line;
+#endif
+	struct machine_desc *mdesc;
+
+	/*
+	 * initialize paravirtual operations
+	 */
+#ifdef CONFIG_PARAVIRT
+	paravirt_init();
+#endif
 
 	unwind_init();
 
@@ -681,6 +721,7 @@ void __init setup_arch(char **cmdline_p)
 	if (mdesc->soft_reboot)
 		reboot_setup("s");
 
+#ifndef CONFIG_WRHV
 	if (__atags_pointer)
 		tags = phys_to_virt(__atags_pointer);
 	else if (mdesc->boot_params)
@@ -704,14 +745,25 @@ void __init setup_arch(char **cmdline_p)
 		save_atags(tags);
 		parse_tags(tags);
 	}
+#else
+	mdesc->timer->init = wrhv_time_init;
+	mdesc->init_machine = NULL;
+	if (mdesc->fixup)
+		mdesc->fixup(mdesc, NULL, NULL, &meminfo);
+	paravirt_MMU_init();
+
+	init_mm.context.vmmu_handle = vmmu_cfg.vmmu_handle;
+#endif
 
 	init_mm.start_code = (unsigned long) _text;
 	init_mm.end_code   = (unsigned long) _etext;
 	init_mm.end_data   = (unsigned long) _edata;
 	init_mm.brk	   = (unsigned long) _end;
 
+#ifndef CONFIG_WRHV
 	/* parse_early_param needs a boot_command_line */
 	strlcpy(boot_command_line, from, COMMAND_LINE_SIZE);
+#endif
 
 	/* populate cmd_line too for later use, preserving boot_command_line */
 	strlcpy(cmd_line, boot_command_line, COMMAND_LINE_SIZE);
@@ -732,7 +784,12 @@ void __init setup_arch(char **cmdline_p)
 	/*
 	 * Set up various architecture-specific pointers
 	 */
+#ifdef CONFIG_WRHV
+	wrhv_machine_init_irq = mdesc->init_irq;
+	init_arch_irq = wrhv_init_irq;
+#else
 	init_arch_irq = mdesc->init_irq;
+#endif
 	system_timer = mdesc->timer;
 	init_machine = mdesc->init_machine;
 
@@ -744,6 +801,10 @@ void __init setup_arch(char **cmdline_p)
 #endif
 #endif
 	early_trap_init();
+#ifdef CONFIG_WRHV
+	vbi_set_exc_base((void *)CONFIG_VECTORS_BASE);
+#endif
+
 }
 
 
-- 
1.7.0.4

