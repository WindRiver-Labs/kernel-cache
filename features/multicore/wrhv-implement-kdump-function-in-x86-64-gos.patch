From 97c74db0e96e02e2a66788bb42258ef7c01e041d Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Mon, 25 Nov 2013 13:01:51 +0800
Subject: [PATCH 1/2] wrhv: implement kdump function in x86-64 gos

to make kdump work well, kernel options and vb config address needs
to be passed to second kernel correctly, adjust the code to make it
happen, now kernel options passing is the same as native way, and vb
config address needs to be passed through new kernel option: vb_config_addr

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/x86/boot/compressed/head_64.S |   56 +++++++++++++++++++----------
 arch/x86/kernel/head64.c           |   10 +++++-
 arch/x86/kernel/head_64.S          |   10 ++++--
 arch/x86/kernel/vbi/wrhv.c         |   70 ++++++++++++++++++++++++++++--------
 4 files changed, 108 insertions(+), 38 deletions(-)

diff --git a/arch/x86/boot/compressed/head_64.S b/arch/x86/boot/compressed/head_64.S
index b67ac67..aa7720d 100644
--- a/arch/x86/boot/compressed/head_64.S
+++ b/arch/x86/boot/compressed/head_64.S
@@ -56,19 +56,10 @@ ENTRY(startup_32)
 	movl	%eax, %ss
 1:
 #ifdef CONFIG_WRHV
-	/*Copy wrhv config */
-	movl %esi, %eax
-	movl 0x4(%esp), %esi
-	/* Store the address of wrhv config so we can map it later */
-	movl $wrhv_config, %edi
-	movl %esi, (%edi)
-	movl $0, 0x4(%edi)
-	addl $8, %edi
-	movl $1024,%ecx
-	cld
-	rep
-	movsl
-	movl %eax, %esi
+	/* Store the address of wrhv config to wrhv_config */
+	movl $wrhv_config, %eax
+	movl 0x4(%esp), %ebx
+	movl %ebx, (%eax)
 #endif
 
 /*
@@ -103,8 +94,20 @@ ENTRY(startup_32)
  * contains the address where we should move the kernel image temporarily
  * for safe in-place decompression.
  */
-
-#if defined(CONFIG_RELOCATABLE) && !defined(CONFIG_WRHV)
+#ifdef CONFIG_WRHV
+	movl	$LOAD_PHYSICAL_ADDR, %ebx
+	/* When rsi != 0, it means it comes from kdump */
+	cmpl	$0, %esi
+	jz	1f
+	movl	%ebp, %ebx
+	movl	BP_kernel_alignment(%esi), %eax
+	decl	%eax
+	addl	%eax, %ebx
+	notl	%eax
+	andl	%eax, %ebx
+1:
+#else
+#if defined(CONFIG_RELOCATABLE)
 	movl	%ebp, %ebx
 	movl	BP_kernel_alignment(%esi), %eax
 	decl	%eax
@@ -114,6 +117,7 @@ ENTRY(startup_32)
 #else
 	movl	$LOAD_PHYSICAL_ADDR, %ebx
 #endif
+#endif
 
 	/* Target address to relocate to for decompression */
 	addl	$z_extract_offset, %ebx
@@ -246,7 +250,20 @@ ENTRY(startup_64)
 	 */
 
 	/* Start with the delta to where the kernel will run at. */
-#if defined(CONFIG_RELOCATABLE) && !defined(CONFIG_WRHV)
+#ifdef CONFIG_WRHV
+	movq	$LOAD_PHYSICAL_ADDR, %rbp
+	/* When rsi != 0, it means it comes from kdump */
+	cmpq	$0, %rsi
+	jz	1f
+	leaq	startup_32(%rip) /* - $startup_32 */, %rbp
+	movl	BP_kernel_alignment(%rsi), %eax
+	decl	%eax
+	addq	%rax, %rbp
+	notq	%rax
+	andq	%rax, %rbp
+1:
+#else
+#if defined(CONFIG_RELOCATABLE)
 	leaq	startup_32(%rip) /* - $startup_32 */, %rbp
 	movl	BP_kernel_alignment(%rsi), %eax
 	decl	%eax
@@ -256,6 +273,7 @@ ENTRY(startup_64)
 #else
 	movq	$LOAD_PHYSICAL_ADDR, %rbp
 #endif
+#endif
 
 	/* Target address to relocate to for decompression */
 	leaq	z_extract_offset(%rbp), %rbx
@@ -316,8 +334,8 @@ relocated:
 	popq	%rsi
 
 #ifdef CONFIG_WRHV
-	popq   %rbx
-	leaq wrhv_config(%rbx), %rsi
+	popq	%rbx
+	movq	wrhv_config(%rbx), %rax
 #endif
 
 /*
@@ -340,7 +358,7 @@ gdt_end:
 #ifdef CONFIG_WRHV
 .balign 8
 wrhv_config:
-	.fill 0x1008, 1, 0
+	.fill 0x8, 1, 0
 #endif
 
 /*
diff --git a/arch/x86/kernel/head64.c b/arch/x86/kernel/head64.c
index 3a01ee7..7b5d78a 100644
--- a/arch/x86/kernel/head64.c
+++ b/arch/x86/kernel/head64.c
@@ -94,9 +94,17 @@ void __init x86_64_start_kernel(char * real_mode_data)
 	x86_64_start_reservations(real_mode_data);
 }
 
+#ifdef CONFIG_WRHV
+unsigned int kexec_reboot = 0;
+#endif
 void __init x86_64_start_reservations(char *real_mode_data)
 {
-#ifndef CONFIG_WRHV /* real mode data is not provided by wrhv */
+#ifdef CONFIG_WRHV /* real mode data is not provided by wrhv */
+	if (real_mode_data != NULL) {
+		kexec_reboot = 1;
+		copy_bootdata(__va(real_mode_data));
+	}
+#else
 	copy_bootdata(__va(real_mode_data));
 #endif
 
diff --git a/arch/x86/kernel/head_64.S b/arch/x86/kernel/head_64.S
index 5a51bc6..ea6136d 100644
--- a/arch/x86/kernel/head_64.S
+++ b/arch/x86/kernel/head_64.S
@@ -46,14 +46,18 @@ L3_START_KERNEL = pud_index(__START_KERNEL_map)
 startup_64:
 
 #ifdef CONFIG_WRHV
-	movq (%rsi), %rdi
-	movq %rdi, _wr_config(%rip)
-	addq $8, %rsi
+	cmpq $0, %rsi
+	jnz 1f
+	pushq %rsi
+	movq %rax, _wr_config(%rip)
+	movq %rax, %rsi
 	leaq __wr_config(%rip), %rdi
 	movq $(WRHV_VB_CONFIG_SIZE/4),%rcx
 	cld
 	rep
 	movsl
+	popq %rsi
+1:
 #endif
 
 	/*
diff --git a/arch/x86/kernel/vbi/wrhv.c b/arch/x86/kernel/vbi/wrhv.c
index 1341ef6..b3b1830 100644
--- a/arch/x86/kernel/vbi/wrhv.c
+++ b/arch/x86/kernel/vbi/wrhv.c
@@ -61,6 +61,10 @@ static unsigned int wrhv_ipi_num[4] __read_mostly = {20, 21, 22, 23};
 #define WRHV_IPI_FUNC_CALL        wrhv_ipi_num[2]
 #define WRHV_IPI_FUNC_CALL_SINGLE wrhv_ipi_num[3]
 
+#ifdef CONFIG_X86_64
+extern unsigned int kexec_reboot;
+#endif
+
 #ifdef CONFIG_PCI
 extern int (*pcibios_enable_irq)(struct pci_dev *dev);
 extern void (*pcibios_disable_irq)(struct pci_dev *dev);
@@ -474,6 +478,23 @@ static int __init wrhv_check_shared_interrupts(char *str)
 }
 early_param("shared_interrupts", wrhv_check_shared_interrupts);
 
+#ifdef CONFIG_X86_64
+static int __init wrhv_set_vb_config_addr(char *str)
+{
+	unsigned long addr;
+	int i;
+	_wr_config = (struct vb_config *)simple_strtoull(str, NULL, 0);
+	addr = (unsigned long)_wr_config;
+	for (i = WRHV_RESERVED_PAGES - 1; i >= 0; addr += PAGE_SIZE, i--)
+		set_fixmap((FIX_WRHV_RESERVED_BEGIN + i), addr);
+
+	wr_config = (VB_CONFIG *)fix_to_virt(FIX_WRHV_RESERVED_END);
+
+	return 0;
+}
+early_param("vb_config_addr", wrhv_set_vb_config_addr);
+#endif
+
 int find_shared_interrupt(char *devfn)
 {
 	char	shared_interrupts[WRHV_BOOTARG_BUF_SIZE];
@@ -651,18 +672,28 @@ static u32 __init wrhv_config_pages_count(void)
 
 void __init wrhv_boot_config(void)
 {
-	boot_params.hdr.type_of_loader = 0xff; /* Unknown */
+#ifdef CONFIG_X86_64
+	char kexec_cmd_line[COMMAND_LINE_SIZE];
+	if (kexec_reboot == 0)
+		boot_params.hdr.type_of_loader = 0xff; /* Unknown */
+
 	if (__initrd_start != __initrd_end) {
-#ifdef CONFIG_X86_32
 		boot_params.hdr.ramdisk_image =
-			(unsigned long)&__initrd_start - PAGE_OFFSET;
+			(unsigned long)&__initrd_start - __START_KERNEL_map;
+
+		boot_params.hdr.ramdisk_size =
+		(unsigned long)&__initrd_end - (unsigned long)&__initrd_start;
+	}
 #else
+	boot_params.hdr.type_of_loader = 0xff; /* Unknown */
+	if (__initrd_start != __initrd_end) {
 		boot_params.hdr.ramdisk_image =
-			(unsigned long)&__initrd_start - __START_KERNEL_map;
-#endif
+			(unsigned long)&__initrd_start - PAGE_OFFSET;
+
 		boot_params.hdr.ramdisk_size =
 		(unsigned long)&__initrd_end - (unsigned long)&__initrd_start;
 	}
+#endif
 
 	x86_init.resources.memory_setup = wrhv_memory_setup;
 	legacy_pic = &null_legacy_pic;
@@ -681,22 +712,26 @@ void __init wrhv_boot_config(void)
 		"noreplace-smp nosep %s",
 		wr_config->bootLine);
 #else
-	snprintf(boot_command_line, COMMAND_LINE_SIZE,
-		"retain_initrd pci=wrhv idle=wrhv serialnumber nolapic "
-		"noxsave noreplace-smp nomce nosep nogbpages noexec=off "
-		"novtlbopt %s",
-		wr_config->bootLine);
+	if (kexec_reboot == 0) {
+		snprintf(boot_command_line, COMMAND_LINE_SIZE,
+			"retain_initrd pci=wrhv idle=wrhv serialnumber nolapic "
+			"noxsave noreplace-smp nomce nosep nogbpages noexec=off "
+			"novtlbopt %s",
+			wr_config->bootLine);
+	} else {
+		strlcpy(kexec_cmd_line, boot_command_line, COMMAND_LINE_SIZE);
+		snprintf(boot_command_line, COMMAND_LINE_SIZE,
+			"retain_initrd pci=wrhv idle=wrhv serialnumber nolapic "
+			"noxsave noreplace-smp nomce nosep nogbpages noexec=off "
+			"novtlbopt %s",
+			kexec_cmd_line);
+	}
 #endif
 
 #endif
 	if (strstr(boot_command_line, "novtlbopt"))
 		novtlbopt = 1;
 
-	_wr_config_pages = wrhv_config_pages_count();
-#ifdef CONFIG_X86_32
-	reserve_top_address((unsigned long)_wr_config_pages << PAGE_SHIFT);
-#endif
-
 #ifdef CONFIG_WRHV_SAFETY_PROFILE
 	safety_hyp_version = SAFETY_HYP_VER_STD;
 	if (strstr(boot_command_line, "safety_debug"))
@@ -1693,5 +1728,10 @@ void __init wrhv_init(void)
 #ifdef CONFIG_SMP
 	wrhv_smp_init();
 #endif
+	_wr_config_pages = wrhv_config_pages_count();
+#ifdef CONFIG_X86_32
+	reserve_top_address((unsigned long)_wr_config_pages << PAGE_SHIFT);
+#endif
+
 	wrhv_post_memory_setup();
 }
-- 
1.7.0

