From 0703df813e2c7ea95c79356f39aba68c67d8a358 Mon Sep 17 00:00:00 2001
From: Jim Somerville <Jim.Somerville@windriver.com>
Date: Wed, 3 Aug 2011 13:42:16 -0400
Subject: [PATCH] wrhv: arm: Create separate arm gos linker script

This new linker script moves the initramfs so that
relocation branching will work when loading modules from a
large ramdisk.

It also undoes the LOAD_OFFSET changes since the hv
loader deficiencies have been addressed.

The regular linker script is restored, no WRHV touches
are in it anymore.

Signed-off-by: Jim Somerville <Jim.Somerville@windriver.com>
---
 Makefile                           |    9 +-
 arch/arm/kernel/Makefile           |    4 +-
 arch/arm/kernel/vmlinux-wrhv.lds.S |  254 ++++++++++++++++++++++++++++++++++++
 3 files changed, 264 insertions(+), 3 deletions(-)
 create mode 100644 arch/arm/kernel/vmlinux-wrhv.lds.S

diff --git a/Makefile b/Makefile
index 64b1dd6..f086ebd 100644
--- a/Makefile
+++ b/Makefile
@@ -523,6 +523,13 @@ else
 include/config/auto.conf: ;
 endif # $(dot-config)
 
+# Additional ARCH settings for arm
+ifeq ($(ARCH),arm)
+ifdef CONFIG_WRHV
+       export lds-filename-suffix := -wrhv
+endif
+endif
+
 # The all: target is the default when no target is given on the
 # command line.
 # This allow a user to issue only 'make' to build a kernel including modules
@@ -710,7 +717,7 @@ libs-y		:= $(libs-y1) $(libs-y2)
 vmlinux-init := $(head-y) $(init-y)
 vmlinux-main := $(core-y) $(libs-y) $(drivers-y) $(net-y)
 vmlinux-all  := $(vmlinux-init) $(vmlinux-main)
-vmlinux-lds  := arch/$(SRCARCH)/kernel/vmlinux.lds
+vmlinux-lds  := arch/$(SRCARCH)/kernel/vmlinux$(lds-filename-suffix).lds
 export KBUILD_VMLINUX_OBJS := $(vmlinux-all)
 
 # Rule to link vmlinux - also used during CONFIG_KALLSYMS
diff --git a/arch/arm/kernel/Makefile b/arch/arm/kernel/Makefile
index 4272f9a..390d16f 100644
--- a/arch/arm/kernel/Makefile
+++ b/arch/arm/kernel/Makefile
@@ -2,7 +2,7 @@
 # Makefile for the linux kernel.
 #
 
-CPPFLAGS_vmlinux.lds := -DTEXT_OFFSET=$(TEXT_OFFSET)
+CPPFLAGS_vmlinux$(lds-filename-suffix).lds := -DTEXT_OFFSET=$(TEXT_OFFSET)
 AFLAGS_head.o        := -DTEXT_OFFSET=$(TEXT_OFFSET)
 
 ifdef CONFIG_DYNAMIC_FTRACE
@@ -62,7 +62,7 @@ head-y			:= head$(MMUEXT).o
 obj-$(CONFIG_DEBUG_LL)	+= debug.o
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
 
-extra-y := $(head-y) init_task.o vmlinux.lds
+extra-y := $(head-y) init_task.o vmlinux$(lds-filename-suffix).lds
 
 obj-$(CONFIG_AUDIT)		+= audit.o
 compat-obj-$(CONFIG_AUDIT)	+= compat_audit.o
diff --git a/arch/arm/kernel/vmlinux-wrhv.lds.S b/arch/arm/kernel/vmlinux-wrhv.lds.S
new file mode 100644
index 0000000..92b59fb
--- /dev/null
+++ b/arch/arm/kernel/vmlinux-wrhv.lds.S
@@ -0,0 +1,254 @@
+/*
+ * Copyright (c) 2011 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute or otherwise make use of this software may be
+ * licensed only pursuant to the terms of an applicable Wind River license
+ * agreement.
+ */
+
+/* ld script to make ARM Linux guest OS kernel for Wind River Hypervisor.
+ *
+ * The main difference between this and the regular one is the movement
+ * of the initramfs region to avoid relocation limits when loading modules
+ * from rather large ramdisks.  This shuffling breaks XIP, but
+ * references to XIP have been removed as XIP is not supported with
+ * Wind River Hypervisor anyway.
+ *
+ * Derives from the regular arm version with some changes as suggested by
+ * Russell King on the linux kernel mailing list.
+ */
+
+#include <asm-generic/vmlinux.lds.h>
+#include <asm/thread_info.h>
+#include <asm/memory.h>
+#include <asm/page.h>
+
+#ifdef CONFIG_XIP_KERNEL
+#error XIP not supported with Wind River Hypervisor
+#endif
+
+OUTPUT_ARCH(arm)
+ENTRY(stext)
+
+#ifndef __ARMEB__
+jiffies = jiffies_64;
+#else
+jiffies = jiffies_64 + 4;
+#endif
+
+SECTIONS
+{
+	/*
+	 * unwind exit sections must be discarded before the rest of the
+	 * unwind sections get included.
+	 */
+	/DISCARD/ : {
+		*(.ARM.exidx.exit.text)
+		*(.ARM.extab.exit.text)
+#ifndef CONFIG_HOTPLUG_CPU
+		*(.ARM.exidx.cpuexit.text)
+		*(.ARM.extab.cpuexit.text)
+#endif
+#ifndef CONFIG_HOTPLUG
+		*(.ARM.exidx.devexit.text)
+		*(.ARM.extab.devexit.text)
+#endif
+#ifndef CONFIG_MMU
+		*(.fixup)
+		*(__ex_table)
+#endif
+	}
+
+	. = PAGE_OFFSET + TEXT_OFFSET;
+
+	_text = .;
+	_stext = .;
+	HEAD_TEXT_SECTION
+
+	.text : {	/* Real text segment	*/
+			__exception_text_start = .;
+			*(.exception.text)
+			__exception_text_end = .;
+			TEXT_TEXT
+			SCHED_TEXT
+			LOCK_TEXT
+			KPROBES_TEXT
+#ifdef CONFIG_MMU
+			*(.fixup)
+#endif
+			*(.gnu.warning)
+			*(.rodata)
+			*(.rodata.*)
+			*(.glue_7)
+			*(.glue_7t)
+		*(.got)			/* Global offset table		*/
+
+		_etext = .;		/* End of text and rodata section */
+	}
+
+		. = ALIGN(PAGE_SIZE);
+		__init_begin = .;
+
+		INIT_TEXT_SECTION(0)
+
+	.init.proc.info : {
+		__proc_info_begin = .;
+			*(.proc.info.init)
+		__proc_info_end = .;
+	}
+	.init.arch.info : {
+		__arch_info_begin = .;
+			*(.arch.info.init)
+		__arch_info_end = .;
+	}
+	.init.tagtable : {
+		__tagtable_begin = .;
+			*(.taglist.init)
+		__tagtable_end = .;
+	}
+
+	.init.data : {
+		INIT_DATA
+		INIT_SETUP(16)
+
+		INIT_CALLS
+		CON_INITCALL
+		SECURITY_INITCALL
+		INIT_RAM_FS
+
+	}
+
+	PERCPU(PAGE_SIZE)
+
+	. = ALIGN(PAGE_SIZE);
+	__init_end = .;
+
+	RO_DATA(PAGE_SIZE)
+
+#ifdef CONFIG_ARM_UNWIND
+	/*
+	 * Stack unwinding tables
+	 */
+	. = ALIGN(8);
+	.ARM.unwind_idx : {
+		__start_unwind_idx = .;
+		*(.ARM.exidx*)
+		__stop_unwind_idx = .;
+	}
+	.ARM.unwind_tab : {
+		__start_unwind_tab = .;
+		*(.ARM.extab*)
+		__stop_unwind_tab = .;
+	}
+#endif
+
+	. = ALIGN(THREAD_SIZE);
+	__data_loc = .;
+
+	.data : {
+		_data = .;		/* address in memory */
+		_sdata = .;
+
+		/*
+		 * first, the init task union, aligned
+		 * to an 8192 byte boundary.
+		 */
+		INIT_TASK_DATA(THREAD_SIZE)
+
+		NOSAVE_DATA
+		CACHELINE_ALIGNED_DATA(32)
+
+		/*
+		 * The exception fixup table (might need resorting at runtime)
+		 */
+		. = ALIGN(32);
+		__start___ex_table = .;
+#ifdef CONFIG_MMU
+		*(__ex_table)
+#endif
+		__stop___ex_table = .;
+
+		/*
+		 * and the usual data section
+		 */
+		DATA_DATA
+		CONSTRUCTORS
+
+		_edata = .;
+	}
+	_edata_loc = __data_loc + SIZEOF(.data);
+
+#ifdef CONFIG_HAVE_TCM
+        /*
+	 * We align everything to a page boundary so we can
+	 * free it after init has commenced and TCM contents have
+	 * been copied to its destination.
+	 */
+	.tcm_start : {
+		. = ALIGN(PAGE_SIZE);
+		__tcm_start = .;
+		__itcm_start = .;
+	}
+
+	/*
+	 * Link these to the ITCM RAM
+	 * Put VMA to the TCM address and LMA to the common RAM
+	 * and we'll upload the contents from RAM to TCM and free
+	 * the used RAM after that.
+	 */
+	.text_itcm ITCM_OFFSET : AT(__itcm_start)
+	{
+		__sitcm_text = .;
+		*(.tcm.text)
+		*(.tcm.rodata)
+		. = ALIGN(4);
+		__eitcm_text = .;
+	}
+
+	/*
+	 * Reset the dot pointer, this is needed to create the
+	 * relative __dtcm_start below (to be used as extern in code).
+	 */
+	. = ADDR(.tcm_start) + SIZEOF(.tcm_start) + SIZEOF(.text_itcm);
+
+	.dtcm_start : {
+		__dtcm_start = .;
+	}
+
+	/* TODO: add remainder of ITCM as well, that can be used for data! */
+	.data_dtcm DTCM_OFFSET : AT(__dtcm_start)
+	{
+		. = ALIGN(4);
+		__sdtcm_data = .;
+		*(.tcm.data)
+		. = ALIGN(4);
+		__edtcm_data = .;
+	}
+
+	/* Reset the dot pointer or the linker gets confused */
+	. = ADDR(.dtcm_start) + SIZEOF(.data_dtcm);
+
+	/* End marker for freeing TCM copy in linked object */
+	.tcm_end : AT(ADDR(.dtcm_start) + SIZEOF(.data_dtcm)){
+		. = ALIGN(PAGE_SIZE);
+		__tcm_end = .;
+	}
+#endif
+
+	BSS_SECTION(0, 0, 0)
+	_end = .;
+
+	STABS_DEBUG
+	.comment 0 : { *(.comment) }
+
+	/* Default discards */
+	DISCARDS
+}
+
+/*
+ * These must never be empty
+ * If you have to comment these two assert statements out, your
+ * binutils is too old (for other reasons as well)
+ */
+ASSERT((__proc_info_end - __proc_info_begin), "missing CPU support")
+ASSERT((__arch_info_end - __arch_info_begin), "no machine record defined")
-- 
1.7.0.4

