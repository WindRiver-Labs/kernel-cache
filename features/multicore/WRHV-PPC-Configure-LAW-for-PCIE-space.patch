From c31f9fa778bc5f20db215cd10b46c3e8dfd0c5b4 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Wed, 12 May 2010 16:39:51 +0800
Subject: [PATCH 06/14] WRHV/PPC: Configure LAW for PCIE space

Here the following functions are implemented according to different platforms:

ppc_md.set_law_base

It's used to set the PCIE base address.

ppc_md.set_law_attr
ppc_md.get_law_attr

They are used to set/get the PCIE space attributes such as enable/disable flag,
space size and target id. For more info on this you should refer to the platform
manual.

When 'wrhv_pci_law=on' is set on cmd line, we will invalidate those LAW items
we want to set. Then search one free item to configure the PCI/PCIE space. Note
we will get the appropriate PCI/PCIE description on the dts file.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/include/asm/machdep.h |    3 +
 arch/powerpc/include/asm/wrhv.h    |    6 ++
 arch/powerpc/kernel/vbi/wrhv.c     |  120 ++++++++++++++++++++++++++++++++++++
 3 files changed, 129 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/include/asm/machdep.h b/arch/powerpc/include/asm/machdep.h
index eeb1558..671274b 100644
--- a/arch/powerpc/include/asm/machdep.h
+++ b/arch/powerpc/include/asm/machdep.h
@@ -275,6 +275,9 @@ struct machdep_calls {
 #ifdef CONFIG_VIRTUALIZATION
 	int (*earlycon_setup)(void);
 	int (*enable_pci_law)(void);
+	int (*set_law_base)(int index, unsigned long long addr);
+	int (*set_law_attr)(int index, unsigned int attr);
+	int (*get_law_attr)(int index);
 #endif
 };
 
diff --git a/arch/powerpc/include/asm/wrhv.h b/arch/powerpc/include/asm/wrhv.h
index df36456..334dbe7 100644
--- a/arch/powerpc/include/asm/wrhv.h
+++ b/arch/powerpc/include/asm/wrhv.h
@@ -16,6 +16,8 @@
 #define __ASM_WRHV_H
 
 #ifdef CONFIG_WRHV
+extern unsigned char *law_base;
+
 extern void wrhv_mapping(void);
 extern void wrhv_restart(char *cmd);
 extern unsigned long __init wrhv_find_end_of_memory(void);
@@ -32,6 +34,10 @@ extern uint32_t service_handle;
 extern void get_hv_bsp_server_handle(void);
 extern int get_bsp_clock_freq(void);
 
+extern void ppc_setup_law(unsigned int target_id, unsigned long long addr, unsigned int attr);
+extern int ppc_search_free_law(int target_id);
+extern int ppc_setup_pci_law(struct device_node *dev);
+
 #ifdef CONFIG_PCI
 extern int ppc_get_pci_intr_wrhv(struct pci_dev *dev);
 extern int wrhv_enable_pci_law(void);
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 6419168..505f195 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -357,6 +357,126 @@ void __init wrhv_time_init(void)
 	return;
 }
 
+#define LAW_TARGET_ID (0xff << 20)
+#define LAW_EN (0x1 << 31)
+unsigned char *law_base;
+int ppc_search_free_law(int target_id)
+{
+	struct device_node *dev;
+	int i, law_num = 0;
+	static int index = -1;
+	const int *prop;
+
+	dev = of_find_compatible_node(NULL, NULL, "fsl,corenet-law");
+	if (!dev) {
+		printk(KERN_ERR "%s: No corenet law device node.\n", __func__);
+		return -1;
+	}
+
+	law_base = of_iomap(dev, 0);
+	if (!law_base) {
+		printk(KERN_ERR "%s: Can't iomap corenet law.\n", __func__);
+		return -1;
+	}
+
+	/* Get law numbers property */
+	prop = of_get_property(dev, "fsl,num-laws", NULL);
+	if (prop)
+		law_num = *prop;
+	else
+		return -1;
+
+	if ((!ppc_md.set_law_attr) || (!ppc_md.set_law_base) || (!ppc_md.get_law_attr))
+		return -1;
+
+	for (i = index+1;i < law_num;i++) {
+		/* Firstly we should invalid those existed LAW we want configure. */
+		if ((ppc_md.get_law_attr(i) & LAW_TARGET_ID) == target_id)
+			ppc_md.set_law_attr(i, 0);
+
+		/* Skip these used LAW item */
+		if (ppc_md.get_law_attr(i) & LAW_EN)
+			continue;
+
+		index = i;
+		break;
+	}
+
+	return  index;
+}
+
+void ppc_setup_law(unsigned int target_id, unsigned long long addr, unsigned int attr)
+{
+        int index = ppc_search_free_law(target_id);
+	if (index >= 0) {
+		ppc_md.set_law_base(index, addr);
+		ppc_md.set_law_attr(index, attr);
+	}
+}
+
+int ppc_setup_pci_law( struct device_node *dev)
+{
+	unsigned long long pci_addr, cpu_addr, pci_next, cpu_next, size;
+	const u32 *ranges;
+	int rlen;
+	int pna = 0;
+	int np = 0;
+	u32 pci_space, attr;
+	int pcie_index = 0;
+	const int *prop;
+
+	if (!dev)
+		return -ENODEV;
+
+	if (wrhv_pci_law == 1) {
+		/* Get PCIE target id property */
+		prop = of_get_property(dev, "target-id", NULL);
+		if (prop)
+			pcie_index = *prop;
+		else
+			return -1;
+
+		pna = of_n_addr_cells(dev);
+		np = pna + 5;
+		/* Get ranges property */
+		ranges = of_get_property(dev, "ranges", &rlen);
+		if (ranges == NULL)
+			return -1;
+		/* Parse it */
+		while ((rlen -= np * 4) >= 0) {
+			/* Read next ranges element */
+			pci_space = ranges[0];
+			pci_addr = of_read_number(ranges + 1, 2);
+			cpu_addr = of_translate_address(dev, ranges + 3);
+			size = of_read_number(ranges + pna + 3, 2);
+			ranges += np;
+			if (cpu_addr == OF_BAD_ADDR || size == 0)
+				continue;
+
+			/* Now consume following elements while they are contiguous */
+			for (; rlen >= np * sizeof(u32);
+				     ranges += np, rlen -= np * 4) {
+				if (ranges[0] != pci_space)
+					break;
+				pci_next = of_read_number(ranges + 1, 2);
+				cpu_next = of_translate_address(dev, ranges + 3);
+				if (pci_next != pci_addr + size ||
+						    cpu_next != cpu_addr + size)
+					break;
+				size += of_read_number(ranges + pna + 3, 2);
+			}
+
+			printk(KERN_INFO "  Setup LAW for PCIE Space  0x%016llx..0x%016llx \n", 
+					cpu_addr, cpu_addr + size - 1);
+
+			attr = LAW_EN | (pcie_index < 20) | (__ilog2(size) - 1) ;
+			ppc_setup_law(pcie_index, cpu_addr, attr);
+		}
+	}
+
+	return 0;
+}
+
 void __init wrhv_init_irq(void)
 {
 	int i;
-- 
1.6.5.2

