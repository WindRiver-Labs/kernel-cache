From b98b22a6ff127c8cebe28d7c8d9dc9f1acab28d6 Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Tue, 26 May 2009 10:41:40 +0800
Subject: [PATCH] AMP support code to support WRLoad on uAMP and MIPC

From 71822241ad9a9ac86bacc225b1abe0e3a81498a5 Mon Sep 17 00:00:00 2001
Subject: [PATCH] AMP support code to support WRLoad on uAMP and MIPC
initial introduced amp.c
[
- Handles cpu offlining
- Handles MIPC IPIs
]

coremanager/powerpc: change startcore prototype
[
startcore is used from other files, so we need to change its
definition from static.
]

coremanager/powerpc: add 36bit support for coremanager
[
Using the new ioctl interface for coremanager, so we can
support >4G memory.
]

coremanager/powerpc: load upper boot entry first
[
The started core is spinning on the lower boot entry to wait on a
write to the lower address. So we should load the upper boot entry
first.
]

coremanager/powerpc: check bptr_addr for NULL before using it

coremanager/powerpc: change phys_addr_t to u64 for cm_cmd_info structure
[
The phys_addr_t is only used in kernel, and not export to userspace.
So wrload can't use it directly. Instead of add more #ifdef sections
we just use the same cm_cmd_info for 32bit and 36bit mode.
]

coremanager: need export cpu_maps_update_begin/cpu_maps_update_done

Signed-off-by: Dennis Rice <dennis.rice@windriver.com>
Signed-off-by: Zwane Mwaikambo <zwane.mwaikambo@windriver.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
Signed-off-by: Liang Li <liang.li@windriver.com>
---
 arch/powerpc/Kconfig                   |    2 +-
 arch/powerpc/include/asm/mpic.h        |    2 +-
 arch/powerpc/include/asm/smp.h         |    2 +
 arch/powerpc/kernel/smp.c              |   14 ++-
 arch/powerpc/platforms/85xx/Makefile   |    1 +
 arch/powerpc/platforms/85xx/amp.c      |   83 +++++++++++++++++++
 arch/powerpc/platforms/85xx/smp.c      |   17 ++++-
 arch/powerpc/platforms/Kconfig.cputype |   18 ++++
 arch/powerpc/sysdev/mpic.c             |  135 ++++++++++++++++++++++++++++++--
 kernel/cpu.c                           |    2 +
 10 files changed, 260 insertions(+), 16 deletions(-)
 create mode 100755 arch/powerpc/platforms/85xx/amp.c

diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
index bd8afcb..b33a75f 100644
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -331,7 +331,7 @@ config SWIOTLB
 
 config HOTPLUG_CPU
 	bool "Support for enabling/disabling CPUs"
-	depends on SMP && HOTPLUG && EXPERIMENTAL && (PPC_PSERIES || PPC_PMAC)
+	depends on SMP && HOTPLUG && EXPERIMENTAL && (PPC_PSERIES || PPC_PMAC || PPC_E500MC)
 	---help---
 	  Say Y here to be able to disable and re-enable individual
 	  CPUs at runtime on SMP machines.
diff --git a/arch/powerpc/include/asm/mpic.h b/arch/powerpc/include/asm/mpic.h
index 61913d9..34d498d 100644
--- a/arch/powerpc/include/asm/mpic.h
+++ b/arch/powerpc/include/asm/mpic.h
@@ -260,7 +260,7 @@ struct mpic
 #ifdef CONFIG_MPIC_U3_HT_IRQS
 	struct irq_chip		hc_ht_irq;
 #endif
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) || defined(CONFIG_AMP)
 	struct irq_chip		hc_ipi;
 #endif
 	const char		*name;
diff --git a/arch/powerpc/include/asm/smp.h b/arch/powerpc/include/asm/smp.h
index 1d3b270..75eebc8 100644
--- a/arch/powerpc/include/asm/smp.h
+++ b/arch/powerpc/include/asm/smp.h
@@ -45,6 +45,8 @@ int generic_cpu_disable(void);
 int generic_cpu_enable(unsigned int cpu);
 void generic_cpu_die(unsigned int cpu);
 void generic_mach_cpu_die(void);
+extern int start_secondary(void *unused);
+extern void abort(void);
 #endif
 
 #ifdef CONFIG_PPC64
diff --git a/arch/powerpc/kernel/smp.c b/arch/powerpc/kernel/smp.c
index 642687b..cf7d658 100644
--- a/arch/powerpc/kernel/smp.c
+++ b/arch/powerpc/kernel/smp.c
@@ -313,6 +313,8 @@ int generic_cpu_disable(void)
 	set_cpu_online(cpu, false);
 #ifdef CONFIG_PPC64
 	vdso_data->processorCount--;
+#endif
+#ifdef CONFIG_HOTPLUG_CPU
 	fixup_irqs(cpu_online_map);
 #endif
 	return 0;
@@ -329,15 +331,14 @@ int generic_cpu_enable(unsigned int cpu)
 	per_cpu(cpu_state, cpu) = CPU_UP_PREPARE;
 	smp_wmb();
 
-	while (!cpu_online(cpu))
-		cpu_relax();
 
-#ifdef CONFIG_PPC64
+#ifdef CONFIG_HOTPLUG_CPU
 	fixup_irqs(cpu_online_map);
 	/* counter the irq disable in fixup_irqs */
 	local_irq_enable();
 #endif
-	return 0;
+
+	return 1;
 }
 
 void generic_cpu_die(unsigned int cpu)
@@ -362,6 +363,9 @@ void generic_mach_cpu_die(void)
 	printk(KERN_DEBUG "CPU%d offline\n", cpu);
 	__get_cpu_var(cpu_state) = CPU_DEAD;
 	smp_wmb();
+
+	abort();
+
 	while (__get_cpu_var(cpu_state) != CPU_UP_PREPARE)
 		cpu_relax();
 	set_cpu_online(cpu, true);
@@ -552,7 +556,7 @@ int setup_profiling_timer(unsigned int multiplier)
 	return 0;
 }
 
-void __init smp_cpus_done(unsigned int max_cpus)
+void __cpuinit smp_cpus_done(unsigned int max_cpus)
 {
 	cpumask_t old_mask;
 
diff --git a/arch/powerpc/platforms/85xx/Makefile b/arch/powerpc/platforms/85xx/Makefile
index 6a45885..1fe26c3 100644
--- a/arch/powerpc/platforms/85xx/Makefile
+++ b/arch/powerpc/platforms/85xx/Makefile
@@ -6,6 +6,7 @@
 # specific implementation
 ifneq ($(CONFIG_WRHV),y)
 obj-$(CONFIG_SMP) += smp.o
+obj-$(CONFIG_AMP) += amp.o
 endif
 
 obj-$(CONFIG_MPC8540_ADS) += mpc85xx_ads.o
diff --git a/arch/powerpc/platforms/85xx/amp.c b/arch/powerpc/platforms/85xx/amp.c
new file mode 100755
index 0000000..7e8e231
--- /dev/null
+++ b/arch/powerpc/platforms/85xx/amp.c
@@ -0,0 +1,83 @@
+/*
+ * Author: Andy Fleming <afleming@freescale.com>
+ * 	   Kumar Gala <galak@kernel.crashing.org>
+ *
+ * Copyright 2006-2008 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/pci-bridge.h>
+#include <asm/mpic.h>
+#include <asm/cacheflush.h>
+
+#include <sysdev/fsl_soc.h>
+
+extern unsigned long __secondary_hold_acknowledge;
+extern void __early_start(void);
+
+#define BOOT_ENTRY_ADDR_UPPER	0
+#define BOOT_ENTRY_ADDR_LOWER	1
+#define BOOT_ENTRY_R3_UPPER	2
+#define BOOT_ENTRY_R3_LOWER	3
+#define BOOT_ENTRY_RESV		4
+#define BOOT_ENTRY_PIR		5
+#define BOOT_ENTRY_R6_UPPER	6
+#define BOOT_ENTRY_R6_LOWER	7
+#define NUM_BOOT_ENTRY		8
+#define SIZE_BOOT_ENTRY		(NUM_BOOT_ENTRY * sizeof(u32))
+
+void startcore(u64 entryPt, int nr)
+{
+	unsigned long flags;
+	const u64 *cpu_rel_addr;
+	struct device_node *np;
+	__iomem u32 *bptr_vaddr;
+
+	local_irq_save(flags);
+
+	np = of_get_cpu_node(nr, NULL);
+	cpu_rel_addr = of_get_property(np, "cpu-release-addr", NULL);
+
+	if (cpu_rel_addr == NULL) {
+		printk(KERN_ERR "No cpu-release-addr for cpu %d\n", nr);
+		return;
+	}
+
+	printk(KERN_DEBUG "CPU%d RELEASE at %llx\n", nr, *cpu_rel_addr);
+
+	/* Map the spin table */
+	bptr_vaddr = ioremap(*cpu_rel_addr, SIZE_BOOT_ENTRY);
+	if (bptr_vaddr == NULL)
+		return;
+
+	out_be32(bptr_vaddr + BOOT_ENTRY_PIR, nr);
+#ifdef CONFIG_PHYS_64BIT
+	out_be32(bptr_vaddr + BOOT_ENTRY_ADDR_UPPER, (u32)(entryPt >> 32));
+#endif
+	wmb();
+	out_be32(bptr_vaddr + BOOT_ENTRY_ADDR_LOWER, (u32)entryPt);
+
+	/* Wait a bit for the CPU to ack. */
+	while (in_be32(bptr_vaddr + BOOT_ENTRY_ADDR_LOWER) != 3);
+
+	out_be32(bptr_vaddr + BOOT_ENTRY_ADDR_LOWER, 1);
+
+	iounmap(bptr_vaddr);
+
+	local_irq_restore(flags);
+	printk(KERN_DEBUG "CPU%d RELEASE at %llx\n", nr, *cpu_rel_addr);
+
+}
+
+EXPORT_SYMBOL(startcore);
diff --git a/arch/powerpc/platforms/85xx/smp.c b/arch/powerpc/platforms/85xx/smp.c
index a15f582..c19dd0e 100644
--- a/arch/powerpc/platforms/85xx/smp.c
+++ b/arch/powerpc/platforms/85xx/smp.c
@@ -38,7 +38,7 @@ extern void __early_start(void);
 #define NUM_BOOT_ENTRY		8
 #define SIZE_BOOT_ENTRY		(NUM_BOOT_ENTRY * sizeof(u32))
 
-static void __init
+static void __cpuinit
 smp_85xx_kick_cpu(int nr)
 {
 	unsigned long flags;
@@ -95,7 +95,7 @@ smp_85xx_kick_cpu(int nr)
 	pr_debug("waited %d msecs for CPU #%d.\n", n, nr);
 }
 
-static void __init
+static void __cpuinit
 smp_85xx_setup_cpu(int cpu_nr)
 {
 	mpic_setup_this_cpu();
@@ -103,8 +103,21 @@ smp_85xx_setup_cpu(int cpu_nr)
 
 struct smp_ops_t smp_85xx_ops = {
 	.kick_cpu = smp_85xx_kick_cpu,
+#if defined(CONFIG_HOTPLUG_CPU)
+	.cpu_enable = generic_cpu_enable,
+	.cpu_disable = generic_cpu_disable,
+	.cpu_die = generic_cpu_die,
+#endif
 };
 
+#if defined(CONFIG_HOTPLUG_CPU)
+void cpu_die(void)
+{
+	if (smp_85xx_ops.cpu_die)
+		smp_85xx_ops.cpu_die(smp_processor_id());
+}
+#endif
+
 void __init mpc85xx_smp_init(void)
 {
 	struct device_node *np;
diff --git a/arch/powerpc/platforms/Kconfig.cputype b/arch/powerpc/platforms/Kconfig.cputype
index a8aae0b..b7e73d4 100644
--- a/arch/powerpc/platforms/Kconfig.cputype
+++ b/arch/powerpc/platforms/Kconfig.cputype
@@ -154,6 +154,24 @@ config FSL_EMB_PERF_EVENT_E500
 	depends on FSL_EMB_PERF_EVENT && E500
 	default y
 
+config AMP
+	depends on PPC_E500MC || FSL_BOOKE
+	bool "Asymmetric multi-processing support"
+	---help---
+	This enables support for systems with more than one CPU and
+	is only supported currently with 8572/8578.
+	If you don't know what to do here, say N.
+
+config AMP_IPI_NUM
+	depends on PPC_E500MC
+	int "IPI used for AMP shared memory driver"
+	range 0 3
+	default "2" if SMP
+	default "0"
+	---help---
+	The chooses which IPI should be used. If SMP and AMP is both
+	enabled 2  should be the default although this is a untested mode.
+
 config 4xx
 	bool
 	depends on 40x || 44x
diff --git a/arch/powerpc/sysdev/mpic.c b/arch/powerpc/sysdev/mpic.c
index 260295b..2118d13 100644
--- a/arch/powerpc/sysdev/mpic.c
+++ b/arch/powerpc/sysdev/mpic.c
@@ -147,6 +147,13 @@ static u32 mpic_infos[][MPIC_IDX_END] = {
 
 #endif /* CONFIG_MPIC_WEIRD */
 
+#ifdef CONFIG_AMP
+static unsigned int amp_sm_vipi;
+#ifndef CONFIG_SMP
+static unsigned int amp_mpic_probe_called;
+#endif
+#endif
+
 /*
  * Register accessor functions
  */
@@ -638,7 +645,7 @@ static inline u32 mpic_physmask(u32 cpumask)
 	return mask;
 }
 
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) || defined(CONFIG_AMP)
 /* Get the mpic structure from the IPI number */
 static inline struct mpic * mpic_from_ipi(unsigned int ipi)
 {
@@ -772,7 +779,7 @@ static void mpic_end_ht_irq(unsigned int irq)
 }
 #endif /* !CONFIG_MPIC_U3_HT_IRQS */
 
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) || defined(CONFIG_AMP)
 
 static void mpic_unmask_ipi(unsigned int irq)
 {
@@ -911,7 +918,9 @@ static struct irq_chip mpic_irq_chip = {
 	.set_type	= mpic_set_irq_type,
 };
 
-#ifdef CONFIG_SMP
+
+#if defined(CONFIG_SMP) || defined(CONFIG_AMP)
+
 static struct irq_chip mpic_ipi_chip = {
 	.mask		= mpic_mask_ipi,
 	.unmask		= mpic_unmask_ipi,
@@ -937,6 +946,12 @@ static int mpic_host_match(struct irq_host *h, struct device_node *node)
 	return h->of_node == NULL || h->of_node == node;
 }
 
+static void __mpic_setup_irqchip(struct mpic *mpic, unsigned int virq)
+{
+	set_irq_chip_data(virq, mpic);
+	set_irq_chip_and_handler(virq, &mpic->hc_ipi, handle_percpu_irq);
+}
+
 static int mpic_host_map(struct irq_host *h, unsigned int virq,
 			 irq_hw_number_t hw)
 {
@@ -955,9 +970,11 @@ static int mpic_host_map(struct irq_host *h, unsigned int virq,
 		WARN_ON(!(mpic->flags & MPIC_PRIMARY));
 
 		DBG("mpic: mapping as IPI\n");
-		set_irq_chip_data(virq, mpic);
-		set_irq_chip_and_handler(virq, &mpic->hc_ipi,
-					 handle_percpu_irq);
+#ifdef CONFIG_AMP
+		/* need to keep IPI free for AMP */
+		if (mpic->ipi_vecs[0] != CONFIG_AMP_IPI_NUM)
+			__mpic_setup_irqchip(mpic, virq);
+#endif
 		return 0;
 	}
 #endif /* CONFIG_SMP */
@@ -1066,7 +1083,7 @@ struct mpic * __init mpic_alloc(struct device_node *node,
 		mpic->hc_ht_irq.set_affinity = mpic_set_affinity;
 #endif /* CONFIG_MPIC_U3_HT_IRQS */
 
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) || defined(CONFIG_AMP)
 	mpic->hc_ipi = mpic_ipi_chip;
 	mpic->hc_ipi.name = name;
 #endif /* CONFIG_SMP */
@@ -1494,6 +1511,20 @@ void mpic_send_ipi(unsigned int ipi_no, unsigned int cpu_mask)
 		       mpic_physmask(cpu_mask & cpus_addr(cpu_online_map)[0]));
 }
 
+void mpic_send_amp_ipi(unsigned int ipi_no, unsigned int cpu_mask)
+{
+	struct mpic *mpic = mpic_primary;
+
+	BUG_ON(mpic == NULL);
+
+#ifdef DEBUG_IPI
+	DBG("%s: send_ipi(ipi_no: %d)\n", mpic->name, ipi_no);
+#endif
+
+	mpic_cpu_write(MPIC_INFO(CPU_IPI_DISPATCH_0) +
+			ipi_no * MPIC_INFO(CPU_IPI_DISPATCH_STRIDE), cpu_mask);
+}
+
 static unsigned int _mpic_get_one_irq(struct mpic *mpic, int reg)
 {
 	u32 src;
@@ -1585,6 +1616,11 @@ void mpic_request_ipis(void)
 			printk(KERN_ERR "Failed to map %s\n", smp_ipi_name[i]);
 			continue;
 		}
+#ifdef CONFIG_AMP
+		if (i == CONFIG_AMP_IPI_NUM) /*Unused allow request from external driver in AMP */
+			amp_sm_vipi = vipi;
+		else
+#endif
 		smp_request_message_ipi(vipi, i);
 	}
 }
@@ -1632,6 +1668,91 @@ void __devinit smp_mpic_setup_cpu(int cpu)
 }
 #endif /* CONFIG_SMP */
 
+#ifdef CONFIG_AMP
+#ifndef CONFIG_SMP
+void mpic_request_ipis(void)
+{
+
+	struct mpic *mpic = mpic_primary;
+	BUG_ON(mpic == NULL);
+
+	printk(KERN_INFO "mpic: requesting IPIs ... \n");
+
+	amp_sm_vipi = irq_create_mapping(mpic->irqhost,
+					     mpic->ipi_vecs[0] + CONFIG_AMP_IPI_NUM);
+	if (amp_sm_vipi == NO_IRQ)
+		printk(KERN_ERR "Failed to map IPI %d\n",CONFIG_AMP_IPI_NUM );
+}
+#endif
+
+#ifndef MSG_ALL
+#define MSG_ALL 0x22
+#endif
+#ifndef MSG_ALL_BUT_SELF
+#define MSG_ALL_BUT_SELF 0x21
+#endif
+
+void amp_mpic_message_pass(int target, int msg)
+{
+	if (target > MSG_ALL) {
+		printk(KERN_DEBUG "Unknown AMP IPI message: 0x%x\n",msg);
+		return;
+	}
+
+	switch (target) {
+	case MSG_ALL:
+		mpic_send_amp_ipi(msg, 0xffffffff);
+		break;
+	case MSG_ALL_BUT_SELF:
+		mpic_send_amp_ipi(msg, 0xffffffff & ~(1 << smp_processor_id()));
+		break;
+	default:
+		mpic_send_amp_ipi(msg, 1 << target );
+		break;
+	}
+}
+EXPORT_SYMBOL(amp_mpic_message_pass);
+
+void amp_mpic_probe(void)
+{
+#ifndef CONFIG_SMP
+	if (amp_mpic_probe_called == 0) {
+		amp_mpic_probe_called=1;
+		mpic_request_ipis();
+	}
+#endif
+}
+
+
+int amp_ipi_sm_request(void *ipi_isr)
+{
+	struct mpic *mpic = mpic_primary;
+	static char *ipi_names[] = {
+			"IPI0",
+			"IPI1",
+			"IPI2 (shared memory driver)",
+			"IPI3",
+	};
+	int ipi_num = -1;
+
+	amp_mpic_probe();
+
+	ipi_num = CONFIG_AMP_IPI_NUM; /* Default unused IPI in SMP mode*/
+
+	set_irq_chip_data(amp_sm_vipi, mpic);
+	set_irq_chip_and_handler(amp_sm_vipi, &mpic->hc_ipi, handle_fasteoi_irq);
+
+	if ((request_irq(amp_sm_vipi,ipi_isr, IRQF_DISABLED|IRQF_PERCPU,
+			ipi_names[ipi_num], mpic)) !=0) {
+		printk(KERN_DEBUG "request_irq FAILED for %s",ipi_names[ipi_num]);
+		return 1;
+	}
+
+	return ipi_num;
+}
+EXPORT_SYMBOL(amp_ipi_sm_request);
+#endif /* CONFIG_AMP */
+
 #ifdef CONFIG_PM
 static int mpic_suspend(struct sys_device *dev, pm_message_t state)
 {
diff --git a/kernel/cpu.c b/kernel/cpu.c
index 25bba73..430edfa 100644
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@ -77,11 +77,13 @@ void cpu_maps_update_begin(void)
 {
 	mutex_lock(&cpu_add_remove_lock);
 }
+EXPORT_SYMBOL_GPL(cpu_maps_update_begin);
 
 void cpu_maps_update_done(void)
 {
 	mutex_unlock(&cpu_add_remove_lock);
 }
+EXPORT_SYMBOL_GPL(cpu_maps_update_done);
 
 /*
  * This ensures that the hotplug operation can begin only when the
-- 
1.6.5.2

