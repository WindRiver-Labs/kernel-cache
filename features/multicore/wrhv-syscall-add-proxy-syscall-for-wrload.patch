From 673db9e0f0cc8b9ac9b39a0e59f07be1b908aea4 Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Thu, 3 Jun 2010 14:19:52 +0800
Subject: [PATCH] wrhv/syscall: add proxy syscall for wrload

Add syscall to provide proxy syscall to wrload to enable wrload
perform inter-VB load work.

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 arch/powerpc/include/asm/systbl.h  |    4 +
 arch/powerpc/include/asm/unistd.h  |   10 +++
 arch/x86/include/asm/unistd_32.h   |   10 +++
 arch/x86/kernel/syscall_table_32.S |    4 +
 kernel/vbi/Makefile                |    2 +-
 kernel/vbi/syscall_vbi.c           |  122 ++++++++++++++++++++++++++++++++++++
 6 files changed, 151 insertions(+), 1 deletions(-)
 create mode 100644 kernel/vbi/syscall_vbi.c

diff --git a/arch/powerpc/include/asm/systbl.h b/arch/powerpc/include/asm/systbl.h
index a5ee345..bfc4689 100644
--- a/arch/powerpc/include/asm/systbl.h
+++ b/arch/powerpc/include/asm/systbl.h
@@ -326,3 +326,7 @@ SYSCALL_SPU(perf_event_open)
 COMPAT_SYS_SPU(preadv)
 COMPAT_SYS_SPU(pwritev)
 COMPAT_SYS(rt_tgsigqueueinfo)
+#ifdef CONFIG_WRHV
+SYSCALL(vbi_mem)
+SYSCALL(vbi_activate_vb)
+#endif
diff --git a/arch/powerpc/include/asm/unistd.h b/arch/powerpc/include/asm/unistd.h
index f0a1026..e626e77 100644
--- a/arch/powerpc/include/asm/unistd.h
+++ b/arch/powerpc/include/asm/unistd.h
@@ -345,10 +345,20 @@
 #define __NR_preadv		320
 #define __NR_pwritev		321
 #define __NR_rt_tgsigqueueinfo	322
+#ifdef CONFIG_WRHV
+#define __NR_vbi_mem           323
+#define __NR_vbi_activate_vb   324
+#define VBI_MEM_READ           0x0010
+#define VBI_MEM_WRITE          0x0100
+#endif
 
 #ifdef __KERNEL__
 
+#ifdef CONFIG_WRHV
+#define __NR_syscalls		325
+#else
 #define __NR_syscalls		323
+#endif
 
 #define __NR__exit __NR_exit
 #define NR_syscalls	__NR_syscalls
diff --git a/arch/x86/include/asm/unistd_32.h b/arch/x86/include/asm/unistd_32.h
index beb9b5f..beff18e 100644
--- a/arch/x86/include/asm/unistd_32.h
+++ b/arch/x86/include/asm/unistd_32.h
@@ -343,10 +343,20 @@
 #define __NR_rt_tgsigqueueinfo	335
 #define __NR_perf_event_open	336
 #define __NR_recvmmsg		337
+#ifdef CONFIG_WRHV
+#define __NR_vbi_mem           338
+#define __NR_vbi_activate_vb   339
+#define VBI_MEM_READ           0x0010
+#define VBI_MEM_WRITE          0x0100
+#endif
 
 #ifdef __KERNEL__
 
+#ifdef CONFIG_WRHV
+#define NR_syscalls 340
+#else
 #define NR_syscalls 338
+#endif
 
 #define __ARCH_WANT_IPC_PARSE_VERSION
 #define __ARCH_WANT_OLD_READDIR
diff --git a/arch/x86/kernel/syscall_table_32.S b/arch/x86/kernel/syscall_table_32.S
index 8b37293..eb26c3a 100644
--- a/arch/x86/kernel/syscall_table_32.S
+++ b/arch/x86/kernel/syscall_table_32.S
@@ -337,3 +337,7 @@ ENTRY(sys_call_table)
 	.long sys_rt_tgsigqueueinfo	/* 335 */
 	.long sys_perf_event_open
 	.long sys_recvmmsg
+#ifdef CONFIG_WRHV
+	.long sys_vbi_mem           /* 338 */
+	.long sys_vbi_activate_vb   /* 339 */
+#endif
diff --git a/kernel/vbi/Makefile b/kernel/vbi/Makefile
index 2d0af85..4697c87 100644
--- a/kernel/vbi/Makefile
+++ b/kernel/vbi/Makefile
@@ -3,4 +3,4 @@
 #
 
 obj-y     = shmem.o wrhv.o interrupt.o paddr.o idle.o io_apic.o lib.o \
-	    version.o msg.o ns.o show.o
+	    version.o msg.o ns.o show.o syscall_vbi.o
diff --git a/kernel/vbi/syscall_vbi.c b/kernel/vbi/syscall_vbi.c
new file mode 100644
index 0000000..7c46a25
--- /dev/null
+++ b/kernel/vbi/syscall_vbi.c
@@ -0,0 +1,122 @@
+/*
+ * syscall_vbi.c - vbi interface system calls.
+ *
+ * Copyright (c) 2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#include <linux/gfp.h>
+#include <linux/slab.h>
+#include <linux/slub_def.h>
+#include <linux/types.h>
+#include <vbi/vbi.h>
+#include <asm/uaccess.h>
+#include <linux/vmalloc.h>
+#include <asm/unistd.h>
+
+#define OK              0
+#define ERROR           -1
+
+asmlinkage long sys_vbi_activate_vb(uint32_t vb, uint32_t addr)
+{
+	int retval;
+	u32 vb_cfg;
+	VBI_HREG_SET_CMPLX_QUALIFIED rctl;
+
+	retval = vbi_vb_suspend(vb, VBI_VB_CORES_ALL);
+	if (retval) {
+		printk(KERN_ERR "%s: suspend VB%d failed.\n", __func__, vb);
+		return retval;
+	}
+
+	retval = vbi_vb_find_board_config(vb, 0, &vb_cfg);
+	if (retval) {
+		printk(KERN_ERR "%s: Get VB%d config error.\n", __func__, vb);
+		return retval;
+	}
+
+	retval = vbi_vb_read_reg(&rctl, vb, 0);
+	if (retval) {
+		printk(KERN_ERR "%s: read_reg VB%d failed.\n", __func__, vb);
+		return retval;
+	}
+
+#ifdef CONFIG_X86
+	rctl.vbiRegSet.hreg32.eip = addr;
+	rctl.vbiRegSet.hreg32.eax = vb_cfg;
+#endif
+#ifdef CONFIG_PPC
+	rctl.vbiRegSet.hreg32.pc = addr;
+	rctl.vbiRegSet.hreg32.msr = 0x10000000;
+	/* r3, 1st argument pointer to config page */
+	rctl.vbiRegSet.hreg32.gpr[3] = vb_cfg;
+#endif
+
+	retval = vbi_vb_write_reg(&rctl, vb, 0);
+	if (retval) {
+		printk(KERN_ERR "%s: write_reg VB%d failed.\n", __func__, vb);
+		return retval;
+	}
+
+	retval = vbi_vb_resume(vb, 0);
+	if (retval)
+		printk(KERN_ERR "%s: vb_resume VB%d failed.\n", __func__, vb);
+
+	return retval;
+}
+
+asmlinkage long sys_vbi_mem(uint32_t cpu, void *dest, void *src,
+				  uint32_t size, uint32_t flags)
+{
+	struct vbi_mem_ctl memCtl;
+	char *buf = NULL;
+	uint32_t len;
+	long rv = OK;
+
+	if ((buf = vmalloc(size)) == NULL) {
+		rv = -ENOMEM;
+		goto out;
+	}
+
+	if (flags & VBI_MEM_WRITE) {
+		if ((copy_from_user(buf, src, size) > 0))
+			rv = -EACCES;
+		else {
+			memCtl.pBuffer = dest;
+			memCtl.pAddress = buf;
+			memCtl.size_in = size;
+			memCtl.size_out = 0;
+			memCtl.flags = VBI_ICACHE_INV | VBI_DCACHE_FLUSH;
+			if ((vbi_vb_write_mem(&memCtl, cpu) != OK))
+				rv = -EACCES;
+		}
+	} else if (flags & VBI_MEM_READ) {
+		memCtl.pBuffer = src;
+		memCtl.pAddress = buf;
+		memCtl.size_in = size;
+		memCtl.size_out = 0;
+		memCtl.flags = flags;
+		if ((vbi_vb_read_mem(&memCtl, cpu) != OK))
+			rv = -EACCES;
+		else {
+			if ((len = copy_to_user(buf, dest, size)) > 0)
+				rv = -EACCES;
+		}
+	} else {
+		rv = -EINVAL;
+	}
+
+	vfree(buf);
+out:
+	return rv;
+}
+
-- 
1.6.0.3

