From 07700d623837c9d557a61c608256affcc20574ab Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Thu, 3 Jun 2010 14:19:52 +0800
Subject: [PATCH] wrhv/syscall: add proxy syscall for wrload

From 6ba87c4d94ef2b18c31e9f26c43fcabdf4bfbff5 Mon Sep 17 00:00:00 2001
Subject: [PATCH] wrhv/syscall: add proxy syscall for wrload
Add syscall to provide proxy syscall to wrload to enable wrload
perform inter-VB load work.

Signed-off-by: Liang Li <liang.li@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 arch/powerpc/include/asm/systbl.h  |    2 +
 arch/powerpc/include/asm/unistd.h  |    6 ++-
 arch/x86/include/asm/unistd_32.h   |    6 ++-
 arch/x86/kernel/syscall_table_32.S |    2 +
 kernel/Makefile                    |    2 +-
 kernel/vbi/Makefile                |    9 ++-
 kernel/vbi/syscall_vbi.c           |  141 ++++++++++++++++++++++++++++++++++++
 7 files changed, 163 insertions(+), 5 deletions(-)
 create mode 100644 kernel/vbi/syscall_vbi.c

diff --git a/arch/powerpc/include/asm/systbl.h b/arch/powerpc/include/asm/systbl.h
index a5ee345..6c5c2e6 100644
--- a/arch/powerpc/include/asm/systbl.h
+++ b/arch/powerpc/include/asm/systbl.h
@@ -326,3 +326,5 @@ SYSCALL_SPU(perf_event_open)
 COMPAT_SYS_SPU(preadv)
 COMPAT_SYS_SPU(pwritev)
 COMPAT_SYS(rt_tgsigqueueinfo)
+SYSCALL(vbi_mem)
+SYSCALL(vbi_activate_vb)
diff --git a/arch/powerpc/include/asm/unistd.h b/arch/powerpc/include/asm/unistd.h
index f0a1026..c7442de 100644
--- a/arch/powerpc/include/asm/unistd.h
+++ b/arch/powerpc/include/asm/unistd.h
@@ -345,10 +345,14 @@
 #define __NR_preadv		320
 #define __NR_pwritev		321
 #define __NR_rt_tgsigqueueinfo	322
+#define __NR_vbi_mem		323
+#define __NR_vbi_activate_vb	324
+#define VBI_MEM_READ		0x0010
+#define VBI_MEM_WRITE		0x0100
 
 #ifdef __KERNEL__
 
-#define __NR_syscalls		323
+#define __NR_syscalls		325
 
 #define __NR__exit __NR_exit
 #define NR_syscalls	__NR_syscalls
diff --git a/arch/x86/include/asm/unistd_32.h b/arch/x86/include/asm/unistd_32.h
index beb9b5f..f251cf8 100644
--- a/arch/x86/include/asm/unistd_32.h
+++ b/arch/x86/include/asm/unistd_32.h
@@ -343,10 +343,14 @@
 #define __NR_rt_tgsigqueueinfo	335
 #define __NR_perf_event_open	336
 #define __NR_recvmmsg		337
+#define __NR_vbi_mem		338
+#define __NR_vbi_activate_vb	339
+#define VBI_MEM_READ		0x0010
+#define VBI_MEM_WRITE		0x0100
 
 #ifdef __KERNEL__
 
-#define NR_syscalls 338
+#define NR_syscalls 340
 
 #define __ARCH_WANT_IPC_PARSE_VERSION
 #define __ARCH_WANT_OLD_READDIR
diff --git a/arch/x86/kernel/syscall_table_32.S b/arch/x86/kernel/syscall_table_32.S
index 8b37293..2e0165f 100644
--- a/arch/x86/kernel/syscall_table_32.S
+++ b/arch/x86/kernel/syscall_table_32.S
@@ -337,3 +337,5 @@ ENTRY(sys_call_table)
 	.long sys_rt_tgsigqueueinfo	/* 335 */
 	.long sys_perf_event_open
 	.long sys_recvmmsg
+	.long sys_vbi_mem		/* 338 */
+	.long sys_vbi_activate_vb	/* 339 */
diff --git a/kernel/Makefile b/kernel/Makefile
index 9d6837c..5a233e8 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -39,7 +39,7 @@ obj-$(CONFIG_FUTEX) += futex.o
 ifeq ($(CONFIG_COMPAT),y)
 obj-$(CONFIG_FUTEX) += futex_compat.o
 endif
-obj-$(CONFIG_WRHV) += vbi/
+obj-y += vbi/
 obj-$(CONFIG_RT_MUTEXES) += rtmutex.o
 obj-$(CONFIG_DEBUG_RT_MUTEXES) += rtmutex-debug.o
 obj-$(CONFIG_RT_MUTEX_TESTER) += rtmutex-tester.o
diff --git a/kernel/vbi/Makefile b/kernel/vbi/Makefile
index 2d0af85..35113bc 100644
--- a/kernel/vbi/Makefile
+++ b/kernel/vbi/Makefile
@@ -2,5 +2,10 @@
 # Makefile for the vbi goodies.
 #
 
-obj-y     = shmem.o wrhv.o interrupt.o paddr.o idle.o io_apic.o lib.o \
-	    version.o msg.o ns.o show.o
+
+# Most everything is conditional on the Wind River Hypervisor being configured.
+# Except the user ABI, which is always present, and defined in syscall_vbi
+
+obj-$(CONFIG_WRHV) += shmem.o wrhv.o interrupt.o paddr.o idle.o io_apic.o lib.o \
+                      version.o msg.o ns.o show.o 
+obj-y = syscall_vbi.o
diff --git a/kernel/vbi/syscall_vbi.c b/kernel/vbi/syscall_vbi.c
new file mode 100644
index 0000000..ecb2294
--- /dev/null
+++ b/kernel/vbi/syscall_vbi.c
@@ -0,0 +1,141 @@
+/*
+ * syscall_vbi.c - vbi interface system calls.
+ *
+ * Copyright (c) 2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#include <linux/gfp.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#ifdef CONFIG_WRHV
+#include <vbi/vbi.h>
+#endif
+
+#include <asm/uaccess.h>
+#include <linux/vmalloc.h>
+#include <asm/unistd.h>
+
+#define OK              0
+#define ERROR           -1
+
+#ifdef CONFIG_WRHV
+
+asmlinkage long sys_vbi_activate_vb(uint32_t vb, uint32_t addr)
+{
+	int retval;
+	u32 vb_cfg;
+	VBI_HREG_SET_CMPLX_QUALIFIED rctl;
+
+	retval = vbi_vb_suspend(vb, VBI_VB_CORES_ALL);
+	if (retval) {
+		printk(KERN_ERR "%s: suspend VB%d failed.\n", __func__, vb);
+		return retval;
+	}
+
+	retval = vbi_vb_find_board_config(vb, 0, &vb_cfg);
+	if (retval) {
+		printk(KERN_ERR "%s: Get VB%d config error.\n", __func__, vb);
+		return retval;
+	}
+
+	retval = vbi_vb_read_reg(&rctl, vb, 0);
+	if (retval) {
+		printk(KERN_ERR "%s: read_reg VB%d failed.\n", __func__, vb);
+		return retval;
+	}
+
+#ifdef CONFIG_X86
+	rctl.vbiRegSet.hreg32.eip = addr;
+	rctl.vbiRegSet.hreg32.eax = vb_cfg;
+#endif
+#ifdef CONFIG_PPC
+	rctl.vbiRegSet.hreg32.pc = addr;
+	rctl.vbiRegSet.hreg32.msr = 0x10000000;
+	/* r3, 1st argument pointer to config page */
+	rctl.vbiRegSet.hreg32.gpr[3] = vb_cfg;
+#endif
+
+	retval = vbi_vb_write_reg(&rctl, vb, 0);
+	if (retval) {
+		printk(KERN_ERR "%s: write_reg VB%d failed.\n", __func__, vb);
+		return retval;
+	}
+
+	retval = vbi_vb_resume(vb, 0);
+	if (retval)
+		printk(KERN_ERR "%s: vb_resume VB%d failed.\n", __func__, vb);
+
+	return retval;
+}
+
+asmlinkage long sys_vbi_mem(uint32_t cpu, void *dest, void *src,
+				  uint32_t size, uint32_t flags)
+{
+	struct vbi_mem_ctl memCtl;
+	char *buf = NULL;
+	uint32_t len;
+	long rv = OK;
+
+	if ((buf = vmalloc(size)) == NULL) {
+		rv = -ENOMEM;
+		goto out;
+	}
+
+	if (flags & VBI_MEM_WRITE) {
+		if ((copy_from_user(buf, src, size) > 0))
+			rv = -EACCES;
+		else {
+			memCtl.pBuffer = dest;
+			memCtl.pAddress = buf;
+			memCtl.size_in = size;
+			memCtl.size_out = 0;
+			memCtl.flags = VBI_ICACHE_INV | VBI_DCACHE_FLUSH;
+			if ((vbi_vb_write_mem(&memCtl, cpu) != OK))
+				rv = -EACCES;
+		}
+	} else if (flags & VBI_MEM_READ) {
+		memCtl.pBuffer = src;
+		memCtl.pAddress = buf;
+		memCtl.size_in = size;
+		memCtl.size_out = 0;
+		memCtl.flags = flags;
+		if ((vbi_vb_read_mem(&memCtl, cpu) != OK))
+			rv = -EACCES;
+		else {
+			if ((len = copy_to_user(buf, dest, size)) > 0)
+				rv = -EACCES;
+		}
+	} else {
+		rv = -EINVAL;
+	}
+
+	vfree(buf);
+out:
+	return rv;
+}
+
+#else /* native/stub variants CONFIG_WRHV */
+
+asmlinkage long sys_vbi_activate_vb(uint32_t vb, uint32_t addr)
+{
+	return -ENOSYS;
+}
+
+asmlinkage long sys_vbi_mem(uint32_t cpu, void *dest, void *src,
+				  uint32_t size, uint32_t flags)
+{
+	return -ENOSYS;
+}
+
+#endif /* CONFIG_WRHV */
-- 
1.6.5.2

