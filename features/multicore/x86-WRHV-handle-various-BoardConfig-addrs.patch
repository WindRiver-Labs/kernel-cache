From 42ba3b0b8b4c86b118d80e66b79645a40abaf2de Mon Sep 17 00:00:00 2001
From: Dan Krejsa <dan.krejsa@windriver.com>
Date: Mon, 18 Jun 2012 18:23:17 -0700
Subject: [PATCH] x86 WRHV handle various BoardConfig addrs

The arch/x86 WRHV code was previously fairly inflexible in
what different BoardConfig addresses it could handle, and
limited to 64KB in the total amount of space used for the
board configuration/control/status pages. There are three
BoardConfig values in common use in x86 WRHV BSPs:
0xF0000000, 0xFFF00000, and 0xFFFF0000.  Only the last
was properly handled previously by WR linux guests.

This change adds support for board configuration/control/
status data up to 1MB in size, located at any of the above
three guest physical BoardConfig addresses (or others),
assuming no guest-physical collision with PCI device
registers or similar reserved ranges.

Signed-off-by: Dan Krejsa <dan.krejsa@windriver.com>
---
 arch/x86/include/asm/wrhv.h |    2 +-
 arch/x86/kernel/vbi/wrhv.c  |  220 +++++++++++++++++++++++++++++-------------
 2 files changed, 153 insertions(+), 69 deletions(-)

diff --git a/arch/x86/include/asm/wrhv.h b/arch/x86/include/asm/wrhv.h
index 9250283..eecd0ab 100644
--- a/arch/x86/include/asm/wrhv.h
+++ b/arch/x86/include/asm/wrhv.h
@@ -15,7 +15,7 @@
 #define _ASM_WRHV_H
 
 
-#define WRHV_RESERVED_PAGES	16
+#define WRHV_RESERVED_PAGES	256
 #define WRHV_RESERVED_TOP	(WRHV_RESERVED_PAGES * PAGE_SIZE)
 extern void wrhv_init(void);
 extern void wrhv_boot_config(void);
diff --git a/arch/x86/kernel/vbi/wrhv.c b/arch/x86/kernel/vbi/wrhv.c
index dbdf280..328c44d 100644
--- a/arch/x86/kernel/vbi/wrhv.c
+++ b/arch/x86/kernel/vbi/wrhv.c
@@ -53,6 +53,7 @@ struct vb_config *wr_config = &__wr_config;
 struct vb_config *fake_wr_config = &__wr_config;
 struct vb_status *wr_status;
 struct vb_control *wr_control;
+u32 _wr_config_pages;
 
 static unsigned int wrhv_ipi_num[4] __read_mostly = {20, 21, 22, 23};
 #define WRHV_IPI_RESCHED          wrhv_ipi_num[0]
@@ -129,7 +130,6 @@ static void __wrhv_map_page(unsigned long vaddr, unsigned long paddr,
 }
 #endif
 
-#ifdef CONFIG_X86_64
 static inline void construct_fake_wr_config(void)
 {
 	unsigned long delta;
@@ -161,64 +161,88 @@ static inline void construct_fake_wr_config(void)
 
 	fake_wr_config->deviceConfiguration = (struct vb_dev_info *)(delta +
 			 (unsigned long)wr_config->deviceConfiguration);
-
+#ifdef CONFIG_X86_64
 	if ((unsigned long)fake_wr_config->vb_control->vIoapic <
 	    ((unsigned long)1 << 32))
+#endif
 		fake_wr_config->vb_control->vIoapic = (void *)(delta +
 			(unsigned long)fake_wr_config->vb_control->vIoapic);
 }
 
-#endif
-
 void __init wrhv_init_IRQ(void)
 {
 	int i;
 	unsigned long addr;
+	unsigned long vaddr;
 
 #ifdef CONFIG_X86_32
-	/* The following code maps in hypervisor config/status/control space.
-	   It has to be carefully crafted to be an identity mapping.  We ask
-	   for this space to be supplied to us from the hypervisor at
-	   address 0xffff0000 in the virtual board xml, and we essentially
-	   setup WRHV_RESERVED_PAGES to be 16, representing 16 4K pages from the
-	   end of address space.  This gives us the address 0xffff0000 in Linux
-	   which we need for a virt=phys aka identity mapping.  Why do we
-	   need this to be identity mapped?  Because this block of memory
-	   space is supplied by the hypervisor outside of Linux control, and
-	   it contains pointers to places within itself.  We really don't want
-	   to have to hunt down and modify all those pointers at run time to
-	   be a different (virtual) address.  And finally we tell Linux
-	   through the reservetop bootarg to actually move down the end of
-	   memory by the size in bytes represented by WRHV_RESERVED_PAGES
-	   so we don't interfere with Linux's fixmap facility.
-
-	   The numbers mentioned above are examples, but do reflect reality
-	   as of time of writing.  Please check your constants and do not
-	   rely on the numbers in the above paragraph.
-	*/
+	/*
+	 * The following code maps the hypervisor config/status/control space.
+	 *
+	 * The top _wr_config_pages pages of 32-bit guest virtual memory
+	 * space was reserved earlier by a call to reserve_top_address().
+	 * Here that address range is mapped to the 32-bit guest-physical
+	 * address range starting at _wr_config, using a uniform guest-virtual
+	 * to guest-physical offset.
+	 *
+	 * In the usual case this offset is not zero, and some pointers within
+	 * the vb_config structure need to be updated to account for the offset.
+	 * [The vIoapic pointer in the core-specific VB control structure must
+	 * also be adjusted.] We use construct_fake_wr_config() to construct
+	 * a copy of the struct vb_config with adjusted pointers, in the
+	 * corePrivate memory reserved for each core in the VB.
+	 *
+	 * QUESTION: Do we really need corePrivate memory for this copy?
+	 * All the cores of the VB should share the same guest virtual and
+	 * physical addresses for the structures pointed to from struct
+	 * vb_config, and any modifications needed in the control or status
+	 * pages (e.g. to the vIoapic pointer) are already core-specific
+	 * due to the core-specific guest-physical-to-physical mappings set
+	 * up by the hypervisor...  Same question for 64-bit case.
+	 */
 	addr = (unsigned long)_wr_config;
-	for (i = 0; i < WRHV_RESERVED_PAGES; addr += PAGE_SIZE, i++)
-		__wrhv_map_page(addr, addr, PAGE_KERNEL);
-
-	/* We no longer need to use the vbconfig copy, map it straight in */
-	wr_config = _wr_config;
+	vaddr = 0UL - (_wr_config_pages << PAGE_SHIFT);
+	for (i = 0; i < _wr_config_pages;
+	     addr += PAGE_SIZE, vaddr += PAGE_SIZE, i++) {
+		__wrhv_map_page(vaddr, addr, PAGE_KERNEL);
+	}
 
-	/* Setup the global variables used by the vbi */
-	vbi_init(wr_config);
+	if (vaddr != addr) {
+		wr_config = (struct vb_config *)
+			(0UL - (_wr_config_pages << PAGE_SHIFT));
+		construct_fake_wr_config();
+		vbi_init(fake_wr_config);
+	} else {
+		/*
+		 * We no longer need to use the vb_config copy;
+		 * map it straight in.
+		 */
+		wr_config = _wr_config;
+		/* Set up the global variables used by the vbi */
+		vbi_init(wr_config);
+	}
 #else
-	/* vbi_init() needs a non guest-wise per cpu pointer as its parameter.
-	 * for x86-32, it is _wr_config(0xffff0000); Since 0xffff0000 is just
-	 * at the top of kernel space in 32-bit linux, we can reserve them for
-	 * use; However on 64-bit, 0xffff0000 is no longer in kernel space, so
-	 * fixmap is only way to do so. But we can't use fixmaped _wr_config
-	 * (0xffff0000) as parameter of vbi_init, because the pointers in
-	 * _wr_config are still guest-physical address(0xffff0000-0xffffffff),
-	 * not a 64-bit kernel space address, it will cause trouble in future.
-	 * And we can't modify the points in _wr_config since _wr_config is
-	 * set to read-only by hypervisor. So here use per cpu pointer
-	 * corePrivate(writeable) in _wr_config to fake a hypervisor config,
-	 * and change related pointers with fixmaped address then. it works!
+	/*
+	 * In the 64-bit guest, the VB config/status/control structures are
+	 * placed at a guest-physical address (_wr_config) below 0x100000000.
+	 * This data can never be identity mapped, since that would require
+	 * virtual addresses outside the kernel virtual memory region. Also,
+	 * reserve_top_address() is not available for the 64-bit kernel;
+	 * so we use the fixmap mechanism to reserve (guest) virtual address
+	 * space for the VB config/status/control structures.  This routine
+	 * maps the reserved fixmap range to the guest-physical address
+	 * range of the config/status/control data.
+	 *
+	 * The unwriteable struct vb_config structure at _wr_config contains
+	 * some 'pointers' which are actually the guest-physical addresses of
+	 * other pages in the VB config/status/control region. This routine
+	 * calls construct_fake_wr_config() to construct a copy of the struct
+	 * vb_config structure with the (used) pointers in it adjusted to be
+	 * guest-virtual addresses. The copy is made in corePrivate memory.
+	 * The vIoapic pointer in the core-specific VB control structure must
+	 * also be adjusted.
 	 */
+	(void)vaddr;
 	addr = (unsigned long)_wr_config;
 	for (i = WRHV_RESERVED_PAGES - 1; i >= 0; addr += PAGE_SIZE, i--)
 		set_fixmap((FIX_WRHV_RESERVED_BEGIN + i), addr);
@@ -327,8 +351,9 @@ static int wrhv_set_next_event(unsigned long delta,
 
 static void wrhv_timer_broadcast(const struct cpumask *mask)
 {
-	cpus_and(*mask, cpu_online_map, *mask);
-	wrhv_send_IPI_mask(DUMMY_TIMER_INT, *mask);
+	cpumask_t m;
+	cpus_and(m, cpu_online_map, *mask);
+	wrhv_send_IPI_mask(DUMMY_TIMER_INT, m);
 }
 
 struct clock_event_device wrhv_clock_event = {
@@ -530,34 +555,88 @@ char *__init wrhv_memory_setup(void)
 
 }
 
-/* set device space and vb config as E820_RESERVED to avoid conflict with phy mem */
+/*
+ * Set device space and vb config as E820_RESERVED to avoid conflicts
+ * with phy mem
+ */
 #define TYPE_IO 1
 void __init wrhv_post_memory_setup(void)
 {
 	struct vb_dev_info *pdev;
+	struct vb_dev_info *dev_first;
+	struct vb_dev_info *dev_phys;
 	struct vb_dev_regset_info *preg;
-	struct vb_config *pconfig;
+	struct vb_dev_regset_info *reg_first;
 	int i, j;
-	unsigned long delta;
-	pconfig = early_memremap((resource_size_t)_wr_config,
-				WRHV_RESERVED_PAGES << PAGE_SHIFT);
-	delta = (unsigned long)pconfig - (unsigned long)_wr_config;
-	pdev = (struct vb_dev_info *)(delta +
-			 (unsigned long)wr_config->deviceConfiguration);
-	for (i = 0; i < wr_config->numDevices; i++, pdev++) {
-		if (pdev->numRegSets > 0) {
-			preg = (struct vb_dev_regset_info *)((char *)pdev +
-							pdev->regSetInfoOffset);
-			for(j=0; j < pdev->numRegSets; j++, preg++)
-				if (preg->regSetType !=  TYPE_IO)
-					e820_add_region(preg->regSetAddress,
-					 preg->regSetLength, E820_RESERVED);
-		}
+	resource_size_t reg_phys;
+	unsigned long regs_size;
+	unsigned long devs_size;
+
+	if (wr_config->numDevices == 0)
+		return;
+	devs_size = wr_config->numDevices * sizeof(struct vb_dev_info);
+	dev_phys = wr_config->deviceConfiguration;
+	dev_first = early_memremap((resource_size_t)dev_phys, devs_size);
+	pdev = dev_first;
+	for (i = 0; i < wr_config->numDevices; i++, pdev++, dev_phys++) {
+
+		if (pdev->numRegSets == 0)
+			continue;
+		reg_phys = (resource_size_t)dev_phys + pdev->regSetInfoOffset;
+		regs_size = (sizeof(struct vb_dev_regset_info) *
+			     pdev->numRegSets);
+		reg_first = early_memremap(reg_phys, regs_size);
+
+		for (j = 0, preg = reg_first; j < pdev->numRegSets; j++, preg++)
+			if (preg->regSetType !=  TYPE_IO)
+				e820_add_region(preg->regSetAddress,
+						preg->regSetLength,
+						E820_RESERVED);
+		early_iounmap(reg_first, regs_size);
 	}
-	early_iounmap(pconfig, WRHV_RESERVED_PAGES << PAGE_SHIFT);
-	e820_add_region((phys_addr_t)_wr_config, 0x10000, E820_RESERVED);
+	early_iounmap(dev_first, devs_size);
+	e820_add_region((u64)(unsigned long)_wr_config,
+			(u64)_wr_config_pages << PAGE_SHIFT, E820_RESERVED);
 	update_e820();
+}
+
+static u32 __init wrhv_config_pages_count(void)
+{
+	struct config_page_map *cpm = NULL;
+	unsigned long start = (unsigned long)_wr_config;
+	unsigned long stop;
+	u32 n_pages;
 
+	/*
+	 * Working with the local copy of the struct vb_config at wr_config.
+	 * Use the last element of the configPageMap[] array to find the
+	 * ending address (and so the size) of the config/status/control data.
+	 * Note that the config/status/control data presently
+	 * must reside in the 32-bit guest-physical address region, even for
+	 * 64-bit guests.
+	 */
+	if (wr_config->configPageNum > 0) {
+		cpm = &wr_config->configPageMap[wr_config->configPageNum - 1];
+		if (cpm->address >= start &&
+		    (cpm->address & (PAGE_SIZE - 1)) == 0 &&
+		    (cpm->size != 0) &&
+		    (cpm->size & (PAGE_SIZE - 1)) == 0 &&
+		    cpm->size <= (u32)0 - cpm->address) {
+
+			stop = (unsigned long)cpm->address + cpm->size;
+			n_pages = (u32)((stop - start) >> PAGE_SHIFT);
+			BUG_ON(n_pages > WRHV_RESERVED_PAGES);
+			return n_pages;
+		}
+	}
+
+	/* BUG(); */
+	/* Fall back on older method. _wr_config <= 0xffffffff. */
+
+	n_pages = ((u32)0 - (u32)(unsigned long)_wr_config) >> PAGE_SHIFT;
+	if (n_pages > WRHV_RESERVED_PAGES)
+		n_pages = WRHV_RESERVED_PAGES;
+	return n_pages;
 }
 
 void __init wrhv_boot_config(void)
@@ -587,7 +666,7 @@ void __init wrhv_boot_config(void)
 	/* Use the config space copy here, since we haven't mapped in the
 	   actual hypervisor config/status/control space yet */
 #ifdef CONFIG_X86_32
-        snprintf(boot_command_line, COMMAND_LINE_SIZE,
+	snprintf(boot_command_line, COMMAND_LINE_SIZE,
 		"retain_initrd pci=wrhv idle=wrhv serialnumber nolapic nomce "
 		"noreplace-smp nosep %s",
 		wr_config->bootLine);
@@ -603,7 +682,10 @@ void __init wrhv_boot_config(void)
 	if (strstr(boot_command_line, "novtlbopt"))
 		novtlbopt = 1;
 
-	reserve_top_address(WRHV_RESERVED_TOP);
+	_wr_config_pages = wrhv_config_pages_count();
+#ifdef CONFIG_X86_32
+	reserve_top_address((unsigned long)_wr_config_pages << PAGE_SHIFT);
+#endif
 
 #ifdef CONFIG_WRHV_SAFETY_PROFILE
 	safety_hyp_version = SAFETY_HYP_VER_STD;
@@ -1195,9 +1277,11 @@ static int low_mappings;
 
 static void __cpuinit wrhv_smp_start_cpu(void)
 {
-#ifdef CONFIG_X86_64
-	construct_fake_wr_config();
+#ifdef CONFIG_X86_32
+	if ((unsigned long)_wr_config != 0UL - (_wr_config_pages << PAGE_SHIFT))
 #endif
+		construct_fake_wr_config();
+
 	cpu_init();
 
 	wrhv_mask_timer_for_vcore(WRHV_VTIMER_INT);
-- 
1.7.0

