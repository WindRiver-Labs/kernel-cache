From d2817ad261ebd69f47b5cbe871ca7f89d53e07ad Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Wed, 12 Jan 2011 19:42:33 +0800
Subject: [PATCH 3/4] wrhv/powerpc: fixup LAW and res settings of PCIe

No need to clean address setting for PCI devices, just
flag PCI subsystem to do that work would be fine.

And cleanup PCI LAW setting code to give out warning if
overlap occur in LAW settings.

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 arch/powerpc/kernel/vbi/wrhv.c |   67 +++++++++++++++++++++++++--------------
 1 files changed, 43 insertions(+), 24 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 244fd21..6f0cff3 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -423,6 +423,8 @@ void __init wrhv_time_init(void)
 
 #define LAW_TARGET_ID (0xff << 20)
 #define LAW_EN (0x1 << 31)
+#define LAW_SIZE_MASK (0x1f)
+
 unsigned int high_base = -1;
 unsigned int low_base = -1;
 unsigned int law_attrib = -1;
@@ -494,19 +496,37 @@ int ppc_search_free_law(int target_id, unsigned long long addr)
 	int i;
 	static int index = -1;
 
-	ppc_prepare_law_setup();
-
 	if ((!ppc_md.set_law_attr) || (!ppc_md.set_law_base) || (!ppc_md.get_law_attr))
 		return -1;
 
-	for (i = index+1;i < law_num;i++) {
-		/* Firstly we should invalid those existed LAW we want configure. */
-		if (((ppc_md.get_law_attr(i) & LAW_TARGET_ID)
-		    == (target_id << 20)) || (ppc_md.get_law_base(i) == addr))
+	for (i = index + 1; i < law_num; i++) {
+		u32 base = ppc_md.get_law_base(i);
+		u32 attr = ppc_md.get_law_attr(i);
+		u32 len = 1 << ((attr & LAW_SIZE_MASK) + 1) - 1;
+
+		/*
+		 * clean LAW settings in cases:
+		 * #1. target bus has valid LAW setting
+		 * #2. target address space was mapped yet
+		 */
+		if (((attr & LAW_TARGET_ID) == (target_id << 20))
+				|| (base == addr))
 			ppc_md.set_law_attr(i, 0);
 
+		/*
+		 * we'd better to check if existing LAW setting
+		 * overlapped with us, some *strange* thing might
+		 * happen
+		 */
+		if (addr > base && addr < base + len)
+			printk(KERN_WARNING "\n\t--- Warning!!! ---\n\t"
+					"Existing LAW setting partly overlapped with "
+					"new setting:\n\t"
+					"LAW[%d] already mapped 0x%08x to 0x%08x\n",
+					i, base, base + len);
+
 		/* Skip these used LAW item */
-		if (ppc_md.get_law_attr(i) & LAW_EN)
+		if (attr & LAW_EN)
 			continue;
 
 		index = i;
@@ -518,10 +538,20 @@ int ppc_search_free_law(int target_id, unsigned long long addr)
 
 void ppc_setup_law(unsigned int target_id, unsigned long long addr, unsigned int attr)
 {
-	int index = ppc_search_free_law(target_id, addr);
+	int index;
+	ppc_prepare_law_setup();
+
+	index = ppc_search_free_law(target_id, addr);
 	if (index >= 0) {
+		printk(KERN_INFO "WRHV-setup-law: index: "
+				"%#x, addr: %#llx, attr: %#x\n",
+				index, addr, attr);
 		ppc_md.set_law_base(index, addr);
 		ppc_md.set_law_attr(index, attr);
+	} else {
+		printk(KERN_ERR "WRHV-setup-law: fail setup LAW[%d] "
+				"with addr:[%#llx], attr:[%#x]\n",
+				target_id, addr, attr);
 	}
 }
 
@@ -584,8 +614,8 @@ int ppc_setup_pci_law( struct device_node *dev)
 			if (((pci_space >> 24 ) & 0x3) == 0x2)
 				space_type = "MEM";
 
-			printk(KERN_INFO "WRHV: fixup LAW for PCIE %s Space "
-					"[ 0x%016llx..0x%016llx ]\n",
+			printk(KERN_INFO "WRHV: fixup LAW for PCIE[%d] %s Space "
+					"[ 0x%016llx..0x%016llx ]\n", pcie_index,
 					space_type, cpu_addr, cpu_addr + size - 1);
 
 			attr = LAW_EN | (pcie_index << 20) | (__ilog2(size) - 1) ;
@@ -1885,6 +1915,9 @@ void wrhv_init(void)
 #ifdef CONFIG_WRHV_DUART
 	pv_serial_ops.udbg_init_uart = wrhv_udbg_init_uart;
 #endif
+#ifdef CONFIG_PCI
+	ppc_pci_set_flags(PPC_PCI_REASSIGN_ALL_RSRC);
+#endif
 }
 
 __weak void wrhv_setup_msr_for_ap(VBI_HREG_SET_CMPLX_QUALIFIED *regs)
@@ -2269,20 +2302,6 @@ void pci_msi_disable(struct pci_dev *dev)
 	}
 }
 DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, pci_msi_disable);
-/* Clean those previous BASE set since we'll re-configure these for guest OS. */
-void wrhv_pci_fixup_resource(struct pci_dev* dev)
-{
-	/* Only do for PCIe devices, not for any Bridge. */
-	if (dev->hdr_type == PCI_HEADER_TYPE_NORMAL) {
-		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0);
-		pci_write_config_dword(dev, PCI_BASE_ADDRESS_1, 0);
-		pci_write_config_dword(dev, PCI_BASE_ADDRESS_2, 0);
-		pci_write_config_dword(dev, PCI_BASE_ADDRESS_3, 0);
-		pci_write_config_dword(dev, PCI_BASE_ADDRESS_4, 0);
-		pci_write_config_dword(dev, PCI_BASE_ADDRESS_5, 0);
-	}
-}
-DECLARE_PCI_FIXUP_EARLY(PCI_ANY_ID, PCI_ANY_ID, wrhv_pci_fixup_resource);
 #endif
 
 void wrhv_duart_putc(char c)
-- 
1.6.5.2

