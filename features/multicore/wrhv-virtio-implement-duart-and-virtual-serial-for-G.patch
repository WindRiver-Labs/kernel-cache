From ba4543f5898a123b7247fc34a5493c193e2a1dbe Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Tue, 19 Jul 2011 09:30:16 +0800
Subject: [PATCH 8/8] wrhv: virtio: implement duart and virtual serial for GOS

Hypervisor implements the actual serial device driver, instead of
guest OS driving the hardware registers. Guest OS can optionally use
this feature by passing all data to hypervisor via vbi calls, and the
hypervisor in turn drives the actual hardware.

Signed-off-by: Thomas Tai <thomas.tai@windriver.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
Signed-off-by: Liang Li <liang.li@windriver.com>
---
 arch/powerpc/Kconfig.debug          |    7 +
 arch/powerpc/include/asm/paravirt.h |    8 +
 arch/powerpc/include/asm/udbg.h     |    1 +
 arch/powerpc/include/asm/wrhv.h     |    8 +
 arch/powerpc/kernel/paravirt.c      |   10 ++
 arch/powerpc/kernel/udbg.c          |    2 +
 arch/powerpc/kernel/udbg_16550.c    |   60 ++++++++-
 arch/powerpc/kernel/vbi/wrhv.c      |   20 +++
 drivers/serial/8250.c               |  194 ++++++++++++++++++++++++++++
 drivers/serial/Kconfig              |    7 +
 drivers/wrhv/Kconfig                |   15 ++
 drivers/wrhv/Makefile               |    5 +
 drivers/wrhv/wrhv_duart.c           |  163 +++++++++++++++++++++++
 drivers/wrhv/wrhv_serial.c          |  244 +++++++++++++++++++++++++++++++++++
 include/vbi/duart.h                 |   24 ++++
 15 files changed, 766 insertions(+), 2 deletions(-)
 create mode 100644 drivers/wrhv/wrhv_duart.c
 create mode 100644 drivers/wrhv/wrhv_serial.c
 create mode 100644 include/vbi/duart.h

diff --git a/arch/powerpc/Kconfig.debug b/arch/powerpc/Kconfig.debug
index 5cdd7ed..3b11cfb 100644
--- a/arch/powerpc/Kconfig.debug
+++ b/arch/powerpc/Kconfig.debug
@@ -245,6 +245,13 @@ config PPC_EARLY_DEBUG_40x
 	  inbuilt serial port. This works on chips with a 16550 compatible
 	  UART. Xilinx chips with uartlite cannot use this option.
 
+config PPC_EARLY_DEBUG_WRHV_DUART
+	bool "Early serial debugging using wrhv duart"
+	depends on WRHV
+	help
+	  Select this to enable early debugging via the wrhv duart
+	  device driver.
+
 config PPC_EARLY_DEBUG_CPM
 	bool "Early serial debugging for Freescale CPM-based serial ports"
 	depends on SERIAL_CPM
diff --git a/arch/powerpc/include/asm/paravirt.h b/arch/powerpc/include/asm/paravirt.h
index cf0e9f8..bfd9d3b 100644
--- a/arch/powerpc/include/asm/paravirt.h
+++ b/arch/powerpc/include/asm/paravirt.h
@@ -36,6 +36,8 @@ extern int __attribute__((weak)) native_fsl_pq_mdio_write(struct mii_bus *bus, i
 					int devad, int regnum, u16 value);
 extern int __attribute__((weak)) native_fsl_pq_mdio_read(struct mii_bus *bus, int mii_id,
 					int devad, int regnum);
+extern void native_udbg_init_uart(void __iomem *comport, unsigned int speed,
+		unsigned int clock);
 
 extern int native_init_new_context(struct task_struct *t, struct mm_struct *mm);
 extern void native_destroy_context(struct mm_struct *mm);
@@ -115,6 +117,11 @@ struct pv_context_ops {
 	void (*mmu_context_init)(void);
 };
 
+struct pv_serial_ops{
+	void (*udbg_init_uart)(void __iomem *comport, unsigned int speed,
+		unsigned int clock);
+};
+
 extern struct pv_info pv_info;
 extern struct pv_time_ops pv_time_ops;
 extern struct pv_cpu_ops pv_cpu_ops;
@@ -122,6 +129,7 @@ extern struct pv_irq_ops pv_irq_ops;
 extern struct pv_mmu_ops pv_mmu_ops;
 extern struct pv_mdio_ops pv_mdio_ops;
 extern struct pv_context_ops pv_context_ops;
+extern struct pv_serial_ops pv_serial_ops;
 
 #endif /* CONFIG_PARAVIRT */
 #endif	/* __ASM_PARAVIRT_H */
diff --git a/arch/powerpc/include/asm/udbg.h b/arch/powerpc/include/asm/udbg.h
index 11ae699..42d8a14 100644
--- a/arch/powerpc/include/asm/udbg.h
+++ b/arch/powerpc/include/asm/udbg.h
@@ -52,6 +52,7 @@ extern void __init udbg_init_44x_as1(void);
 extern void __init udbg_init_40x_realmode(void);
 extern void __init udbg_init_cpm(void);
 extern void __init udbg_init_usbgecko(void);
+extern void __init udbg_init_wrhv_duart(void);
 
 #endif /* __KERNEL__ */
 #endif /* _ASM_POWERPC_UDBG_H */
diff --git a/arch/powerpc/include/asm/wrhv.h b/arch/powerpc/include/asm/wrhv.h
index a5f51bc..d1baed8 100644
--- a/arch/powerpc/include/asm/wrhv.h
+++ b/arch/powerpc/include/asm/wrhv.h
@@ -60,6 +60,14 @@ extern int wrhv_enable_pci_law(void);
 
 extern unsigned int wrhv_get_direct_irq(void);
 
+/* following extern functions is implemented in wrhv.c
+ * to access hypervisor serial driver
+ */
+extern void wrhv_duart_putc(char c);
+extern int wrhv_duart_tstc(void);
+extern int wrhv_duart_getc(void);
+extern int wrhv_duart_init(void);
+
 #endif /* __ASSEMBLY__ */
 #endif /* CONFIG_WRHV */
 #endif /* __ASM_WRHV_H */
diff --git a/arch/powerpc/kernel/paravirt.c b/arch/powerpc/kernel/paravirt.c
index 5a43f54..a0c7488 100644
--- a/arch/powerpc/kernel/paravirt.c
+++ b/arch/powerpc/kernel/paravirt.c
@@ -158,6 +158,10 @@ struct pv_context_ops pv_context_ops = {
 	.mmu_context_init	= native_mmu_context_init,
 };
 
+struct pv_serial_ops pv_serial_ops = {
+	.udbg_init_uart	= native_udbg_init_uart,
+};
+
 /* pv_time_ops */
 void __init paravirt_time_init_cont(void)
 {
@@ -231,6 +235,12 @@ int fsl_pq_mdio_read(struct mii_bus *bus, int mii_id,
 	return pv_mdio_ops.fsl_pq_mdio_read(bus, mii_id, devad, regnum);
 }
 
+void paravirt_udbg_init_uart(void __iomem *comport, unsigned int speed,
+		unsigned int clock)
+{
+	return pv_serial_ops.udbg_init_uart(comport, speed, clock);
+}
+
 void __kprobes paravirt_DebugException(struct pt_regs *regs, unsigned long debug_status)
 {
 	pv_cpu_ops.DebugException(regs, debug_status);
diff --git a/arch/powerpc/kernel/udbg.c b/arch/powerpc/kernel/udbg.c
index e39cad8..32934c0 100644
--- a/arch/powerpc/kernel/udbg.c
+++ b/arch/powerpc/kernel/udbg.c
@@ -62,6 +62,8 @@ void __init udbg_early_init(void)
 	udbg_init_cpm();
 #elif defined(CONFIG_PPC_EARLY_DEBUG_USBGECKO)
 	udbg_init_usbgecko();
+#elif defined(CONFIG_PPC_EARLY_DEBUG_WRHV_DUART)
+	udbg_init_wrhv_duart();
 #endif
 
 #ifdef CONFIG_PPC_EARLY_DEBUG
diff --git a/arch/powerpc/kernel/udbg_16550.c b/arch/powerpc/kernel/udbg_16550.c
index b4b167b..868c5f2 100644
--- a/arch/powerpc/kernel/udbg_16550.c
+++ b/arch/powerpc/kernel/udbg_16550.c
@@ -12,6 +12,10 @@
 #include <asm/udbg.h>
 #include <asm/io.h>
 
+#include <asm/wrhv.h>
+#include <vbi/vbi.h>
+#include <vbi/pdc.h>
+
 extern u8 real_readb(volatile u8 __iomem  *addr);
 extern void real_writeb(u8 data, volatile u8 __iomem *addr);
 extern u8 real_205_readb(volatile u8 __iomem  *addr);
@@ -87,8 +91,12 @@ static int udbg_550_getc(void)
 	return -1;
 }
 
-void udbg_init_uart(void __iomem *comport, unsigned int speed,
-		    unsigned int clock)
+void paravirt_udbg_init_uart(void __iomem *comport, unsigned int speed,
+		unsigned int clock)
+		__attribute__((weak, alias("native_udbg_init_uart")));
+
+void native_udbg_init_uart(void __iomem *comport, unsigned int speed,
+		unsigned int clock)
 {
 	unsigned int dll, base_bauds;
 
@@ -119,6 +127,13 @@ void udbg_init_uart(void __iomem *comport, unsigned int speed,
 		udbg_getc = udbg_550_getc;
 		udbg_getc_poll = udbg_550_getc_poll;
 	}
+
+}
+
+void udbg_init_uart(void __iomem *comport, unsigned int speed,
+		unsigned int clock)
+{
+	paravirt_udbg_init_uart(comport, speed, clock);
 }
 
 unsigned int udbg_probe_uart_speed(void __iomem *comport, unsigned int clock)
@@ -298,3 +313,44 @@ void __init udbg_init_40x_realmode(void)
 	udbg_getc_poll = NULL;
 }
 #endif /* CONFIG_PPC_EARLY_DEBUG_40x */
+
+#ifdef CONFIG_PPC_EARLY_DEBUG_WRHV_DUART
+/* following extern functions is implemented in wrhv.c
+ * to access hypervisor serial driver
+ */
+extern void wrhv_duart_putc(char c);
+extern vbi_pdc_handle duart_pdc;
+extern int wrhv_duart_tstc(void);
+extern int wrhv_duart_getc(void);
+extern int wrhv_duart_init(void);
+
+static void udbg_wrhv_duart_flush(void)
+{
+}
+
+void udbg_wrhv_duart_putc(char c)
+{
+	wrhv_duart_putc(c);
+}
+
+int udbg_wrhv_duart_getc(void)
+{
+	if (!wrhv_duart_tstc()) {
+		return -1;
+	}
+	return wrhv_duart_getc();
+}
+
+void __init udbg_init_wrhv_duart(void)
+{
+	wrhv_duart_init();
+
+	/* setup function pointer for early
+	 * console output and set no input polling.
+	 */
+	udbg_putc = udbg_wrhv_duart_putc;
+	udbg_flush = udbg_wrhv_duart_flush;
+	udbg_getc = udbg_wrhv_duart_getc;
+	udbg_getc_poll = NULL;
+}
+#endif /* CONFIG_PPC_EARLY_WRHV_DUART */
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 074d055..7409a13 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -142,6 +142,8 @@ struct vb_status *wr_status;
 EXPORT_SYMBOL(wr_config);
 EXPORT_SYMBOL(wr_status);
 
+extern int is_wrhv_duart_inited;
+
 void wrhv_mapping(void);
 void mpc85xx_power_down(void);
 
@@ -414,7 +416,11 @@ void wrhv_power_save(void)
 	 * duart mode, we need core 0 to handle interrupt from hypervisor. In this
 	 * case we do not allow core 0 to go into idle.
 	 */
+#ifdef CONFIG_WRHV_DUART
 	if ((wrhv_dir_irq) || (is_wrhv_duart_inited)) {
+#else
+	if (wrhv_dir_irq) {
+#endif
 		/* running in direct irq or using duart */
 		if (smp_processor_id())
 			vbi_idle(1);
@@ -2158,6 +2164,16 @@ void __init wrhv_mmu_context_init(void)
 }
 #endif
 
+void wrhv_duart_init(void);
+void wrhv_udbg_init_uart(void __iomem *comport, unsigned int speed,
+		unsigned int clock)
+{
+#ifdef CONFIG_WRHV_DUART
+	/* initialize hypervisor duart serial device driver */
+	wrhv_duart_init();
+#endif
+}
+
 void wrhv_init(void)
 {
 	/* initialize wr_config so that we can access
@@ -2216,6 +2232,10 @@ void wrhv_init(void)
 #ifdef CONFIG_PCI
 	ppc_pci_set_flags(PPC_PCI_REASSIGN_ALL_RSRC);
 #endif
+
+#ifdef CONFIG_WRHV_DUART
+	pv_serial_ops.udbg_init_uart = wrhv_udbg_init_uart;
+#endif
 }
 
 __weak void wrhv_setup_msr_for_ap(VBI_HREG_SET_CMPLX_QUALIFIED *regs)
diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index be30075..c1c7aaf 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -43,6 +43,13 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
+#ifdef CONFIG_WRHV
+#include <asm/wrhv.h>
+#include <vbi/vbi.h>
+#include <vbi/pdc.h>
+#include <vbi/duart.h>
+#endif
+
 #include "8250.h"
 
 #ifdef CONFIG_SPARC
@@ -389,6 +396,144 @@ static inline int map_8250_out_reg(struct uart_port *p, int offset)
 
 #endif
 
+#ifdef CONFIG_WRHV_DUART
+
+/* handle to access hypervisor serial device driver */
+extern vbi_pdc_handle duart_pdc;
+
+/* stub registers */
+static unsigned int wrhv_uart_scr;
+static unsigned int wrhv_uart_ier;
+static unsigned int wrhv_uart_iir;
+static unsigned int wrhv_is_opened = 0;
+
+/* stub function to read register */
+static unsigned int wrhv_serial_in(struct uart_port *p, int offset)
+{
+	unsigned int value;
+	switch (offset) {
+
+	case UART_IER: /* interrupt enable register */
+		return wrhv_uart_ier;
+
+	case UART_LSR: /* line status register */
+		value = BOTH_EMPTY;
+		/* check receiver data ready */
+		if (wrhv_duart_tstc()) {
+			value |= UART_LSR_DR;
+		}
+		return value;
+
+	case UART_MSR: /* modem status register */
+		return UART_MSR_CTS;
+
+	case UART_SCR: /* scratch register */
+		return wrhv_uart_scr;
+
+	case UART_IIR: /* interrupt id register */
+		/* always return FIFO enabled bits */
+		return wrhv_uart_iir | 0xc0;
+
+	case UART_RX: /* receive buffer */
+		/* return received character */
+		return wrhv_duart_getc();
+
+	}
+
+	return 0;
+}
+
+/* stub function to write register */
+static void wrhv_serial_out(struct uart_port *p, int offset, int value)
+{
+	unsigned int mode;
+	switch (offset) {
+
+	case UART_IER: /* interrupt enable register */
+		wrhv_uart_ier = (unsigned int)value;
+		/* set wrhv duart to interrupt mode */
+		if (wrhv_uart_ier) {
+			if (!wrhv_is_opened) {
+				wrhv_is_opened = 1;
+				value = vbi_pdc_op(duart_pdc, PDC_REQUEST_IOCTL,
+					PDC_IOCTL_SIO_OPEN,
+					0, 0,
+				0);
+			}
+			/* set driver to interrupt mode */
+			mode = SIO_MODE_INT;
+			value = vbi_pdc_op(duart_pdc, PDC_REQUEST_IOCTL,
+				PDC_IOCTL_SIO_MODE_SET,
+				(void *)mode, SIO_HW_OPTS_CLOCAL,
+				0);
+		}
+		break;
+
+	case UART_TX: /* transmit register */
+		wrhv_duart_putc(value);
+		break;
+
+	case UART_SCR: /* scratch register */
+		wrhv_uart_scr = (unsigned int)value;
+		break;
+
+	case UART_IIR: /* interrupt id register */
+		wrhv_uart_iir = (unsigned int)value;
+		break;
+
+	}
+}
+
+/* function to set terminal options */
+static void wrhv_set_termios(struct uart_port *port, struct ktermios *termios,
+		       struct ktermios *old)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+	unsigned int cval;
+	unsigned long flags;
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		cval = SIO_HW_OPTS_CS5;
+		break;
+	case CS6:
+		cval = SIO_HW_OPTS_CS6;
+		break;
+	case CS7:
+		cval = SIO_HW_OPTS_CS7;
+		break;
+	default:
+	case CS8:
+		cval = SIO_HW_OPTS_CS8;
+		break;
+	}
+
+	if (termios->c_cflag & CSTOPB)
+		cval |= SIO_HW_OPTS_STOPB;
+	if (termios->c_cflag & PARENB)
+		cval |= SIO_HW_OPTS_PARENB;
+	if (!(termios->c_cflag & PARODD))
+		cval |= SIO_HW_OPTS_PARODD;
+
+	/*
+	 * ignore all characters if CREAD is not set
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		up->port.ignore_status_mask |= UART_LSR_DR;
+	else
+		cval |= CREAD;
+
+	/*
+	 * Ok, we're now changing the port state.  Do it with
+	 * interrupts disabled.
+	 */
+	spin_lock_irqsave(&up->port.lock, flags);
+	vbi_pdc_op(duart_pdc, PDC_REQUEST_IOCTL, PDC_IOCTL_SIO_HW_OPTS_SET,
+			(void *)cval, 0, 0);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+#endif
+
 static unsigned int hub6_serial_in(struct uart_port *p, int offset)
 {
 	offset = map_8250_in_reg(p, offset) << p->regshift;
@@ -529,6 +674,13 @@ static void set_io_from_upio(struct uart_port *p)
 		p->serial_out = io_serial_out;
 		break;
 	}
+
+#ifdef CONFIG_WRHV_DUART
+	/* use stub functions to access register */
+	p->serial_in = wrhv_serial_in;
+	p->serial_out = wrhv_serial_out;
+#endif
+
 	/* Remember loaded iotype */
 	up->cur_iotype = p->iotype;
 }
@@ -1055,6 +1207,7 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 	 * already a 1 and maybe locked there before we even start start.
 	 */
 	iersave = serial_in(up, UART_IER);
+#ifndef CONFIG_WRHV_DUART
 	serial_outp(up, UART_IER, iersave & ~UART_IER_UUE);
 	if (!(serial_in(up, UART_IER) & UART_IER_UUE)) {
 		/*
@@ -1079,6 +1232,7 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 		 */
 		DEBUG_AUTOCONF("Couldn't force IER_UUE to 0 ");
 	}
+#endif
 	serial_outp(up, UART_IER, iersave);
 }
 
@@ -1337,6 +1491,16 @@ static void serial8250_start_tx(struct uart_port *port)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
 
+#ifdef CONFIG_WRHV_DUART
+	/* wrhv duart does not support tx interrupt, so need to
+	 * check uart circ_buf and transmit all characters
+	 */
+	do {
+		transmit_chars(up);
+	} while (!uart_circ_empty(&up->port.state->xmit));
+	return;
+#endif
+
 	if (!(up->ier & UART_IER_THRI)) {
 		up->ier |= UART_IER_THRI;
 		serial_out(up, UART_IER, up->ier);
@@ -1533,12 +1697,14 @@ static void serial8250_handle_port(struct uart_8250_port *up)
 
 	spin_lock_irqsave(&up->port.lock, flags);
 
+#ifndef CONFIG_WRHV_DUART
 	if (unlikely(up->lsr_last & UART_LSR_BI && up->bugs & UART_BUG_PPC)) {
 		up->lsr_last &= ~UART_LSR_BI;
 		serial_inp(up, UART_RX);
 		spin_unlock_irqrestore(&up->port.lock, flags);
 		return;
 	}
+#endif
 
 	status = up->lsr_last = serial_inp(up, UART_LSR);
 
@@ -1546,9 +1712,15 @@ static void serial8250_handle_port(struct uart_8250_port *up)
 
 	if (status & (UART_LSR_DR | UART_LSR_BI))
 		receive_chars(up, &status);
+
+/* wrhv duart does not support tx interrupt, we always handle
+ * transmit buffer in start_tx()
+ */
+#ifndef CONFIG_WRHV_DUART
 	check_modem_status(up);
 	if (status & UART_LSR_THRE)
 		transmit_chars(up);
+#endif
 
 	spin_unlock_irqrestore(&up->port.lock, flags);
 }
@@ -1584,6 +1756,15 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 
 		up = list_entry(l, struct uart_8250_port, list);
 
+#ifdef CONFIG_WRHV_DUART
+		/* for wrhv duart, we check rx interrupt in
+		 * serial8250_handl_port()
+		 */
+		serial8250_handle_port(up);
+		handled = 1;
+		end = NULL;
+		break;
+#endif
 		iir = serial_in(up, UART_IIR);
 		if (!(iir & UART_IIR_NO_INT)) {
 			serial8250_handle_port(up);
@@ -1591,6 +1772,7 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 			handled = 1;
 
 			end = NULL;
+			break;
 		} else if (up->port.iotype == UPIO_DWAPB &&
 			  (iir & UART_IIR_BUSY) == UART_IIR_BUSY) {
 			/* The DesignWare APB UART has an Busy Detect (0x07)
@@ -2663,7 +2845,11 @@ static struct uart_ops serial8250_pops = {
 	.break_ctl	= serial8250_break_ctl,
 	.startup	= serial8250_startup,
 	.shutdown	= serial8250_shutdown,
+#ifdef CONFIG_WRHV_DUART
+	.set_termios	= wrhv_set_termios,
+#else
 	.set_termios	= serial8250_set_termios,
+#endif
 	.set_ldisc	= serial8250_set_ldisc,
 	.pm		= serial8250_pm,
 	.type		= serial8250_type,
@@ -2845,6 +3031,7 @@ static int __init serial8250_console_setup(struct console *co, char *options)
 	if (co->index >= nr_uarts)
 		co->index = 0;
 	port = &serial8250_ports[co->index].port;
+
 	if (!port->iobase && !port->membase)
 		return -ENODEV;
 
@@ -2872,6 +3059,9 @@ static struct console serial8250_console = {
 
 static int __init serial8250_console_init(void)
 {
+#ifdef CONFIG_WRHV_DUART
+	wrhv_duart_init();
+#endif
 	if (nr_uarts > UART_NR)
 		nr_uarts = UART_NR;
 
@@ -3247,6 +3437,10 @@ static int __init serial8250_init(void)
 {
 	int ret;
 
+#ifdef CONFIG_WRHV_DUART
+	wrhv_duart_init();
+#endif
+
 	if (nr_uarts > UART_NR)
 		nr_uarts = UART_NR;
 
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index 902d82c..6e704f4 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -70,6 +70,13 @@ config SERIAL_8250_CONSOLE
 
 	  If unsure, say N.
 
+config WRHV_DUART
+	bool "WRHV duart serial support"
+	depends on SERIAL_8250=y && WRHV && PPC32
+	---help---
+	  This selects whether you want to include the driver for the wrhv
+	  duart driver.
+
 config SERIAL_8250_PPC_BUG
 	bool "Fix 8250/16550 to handle IRQ storm after receipt of a break"
 	depends on SERIAL_8250 && PPC32
diff --git a/drivers/wrhv/Kconfig b/drivers/wrhv/Kconfig
index 7f5d7c2..5d2169c 100644
--- a/drivers/wrhv/Kconfig
+++ b/drivers/wrhv/Kconfig
@@ -16,4 +16,19 @@ config WRHV_FRAME_TRANSITION_INTERRUPT_TEST
 	  Enable testing the start frame and end frame transition interrupt
 	  for Certifiable Hypervisor.
 
+config WRHV_VIRTIO_SERIAL
+	bool "Virtual serial device support for WindRiver Hypervisor Guest OS"
+	depends on !WRHV_DUART && !SERIAL_8250
+	select VIRTIO_CONSOLE
+	---help---
+	  This provides support for the virtual serial device support for
+	  WindRiver Hypervisor Guest OS.
+
+config WRHV_VIRTIO_SERIAL_CONSOLE
+	bool "Virtual serial console support for WindRiver Hypervisor Guest OS"
+	depends on WRHV_VIRTIO_SERIAL
+	---help---
+	  If you say Y here, it will be possible to user the virtual
+	  serial as a system console.
+
 endif  # WRHV_VIRTIO
diff --git a/drivers/wrhv/Makefile b/drivers/wrhv/Makefile
index 4ef6e61..f6cf019 100644
--- a/drivers/wrhv/Makefile
+++ b/drivers/wrhv/Makefile
@@ -1,2 +1,7 @@
 obj-$(CONFIG_WRHV_VIRTIO)	+= wrhv_devices.o
 obj-$(CONFIG_WRHV_FRAME_TRANSITION_INTERRUPT_TEST) += wrhv_frame_irq.o
+obj-$(CONFIG_WRHV_DUART)	+= wrhv_duart.o
+
+obj-$(CONFIG_WRHV_VIRTIO_SERIAL) += wrhv_serial_driver.o
+
+wrhv_serial_driver-objs	:= wrhv_serial.o wrhv_duart.o
diff --git a/drivers/wrhv/wrhv_duart.c b/drivers/wrhv/wrhv_duart.c
new file mode 100644
index 0000000..b84d473
--- /dev/null
+++ b/drivers/wrhv/wrhv_duart.c
@@ -0,0 +1,163 @@
+/*
+ *  Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/wrhv.h>
+#include <vbi/vbi.h>
+#include <vbi/errors.h>
+#include <vbi/pdc.h>
+
+extern struct vb_config *wr_config;
+
+/* interface to wrhv duart actual device driver */
+#define WRHV_DUART_RX_SIZE	(16)
+#define WRHV_DUART_TX_SIZE	(1024)
+static char rxBuf[WRHV_DUART_RX_SIZE];
+static char txBuf[WRHV_DUART_TX_SIZE];
+char wrhv_duart_name[256];
+vbi_pdc_handle duart_pdc;
+int is_wrhv_duart_inited;
+
+struct intr_device_channel_buffer idc = {
+	.rxBuf = (void *)rxBuf,
+	.rxBufLen = WRHV_DUART_RX_SIZE,
+	.rxBufWrPtr = (size_t)0,
+	.rxBufRdPtr = (size_t)0,
+	.txBuf = (void *)txBuf,
+	.txBufLen = WRHV_DUART_TX_SIZE,
+	.txBufWrPtr = (size_t)0,
+	.txBufRdPtr = (size_t)0
+};
+
+void __attribute__((weak)) wrhv_get_serial_devices(void)  { return; }
+__attribute__((weak)) char *wrhv_get_serial_dev_name(int index)
+{
+	return NULL;
+}
+
+void wrhv_duart_putc(char c)
+{
+	if (((idc.txBufWrPtr + 1) % WRHV_DUART_TX_SIZE) == idc.txBufRdPtr) {
+		/* tx ring buffer full */
+		return ;
+	}
+
+	if (c == '\n') {
+		wrhv_duart_putc('\r');
+	}
+
+	txBuf[idc.txBufWrPtr] = c;
+	idc.txBufWrPtr = (idc.txBufWrPtr + 1) % WRHV_DUART_TX_SIZE;
+
+	vbi_pdc_op(duart_pdc, PDC_REQUEST_WRITE,
+		0, (void *)idc.txBuf, (size_t)idc.txBufLen, 0);
+
+}
+
+void wrhv_duart_puts(char *str)
+{
+	while (*str != 0) {
+		wrhv_duart_putc(*str);
+		str++;
+	}
+}
+
+int wrhv_duart_tstc(void)
+{
+	if (idc.rxBufWrPtr == idc.rxBufRdPtr) {
+		/* rx ring buffer empty */
+		return 0;
+	}
+	return 1;
+}
+
+int wrhv_duart_getc(void)
+{
+	int value;
+
+	if (!wrhv_duart_tstc()) {
+		return 0;
+	}
+	value = rxBuf[idc.rxBufRdPtr++];
+	idc.rxBufRdPtr = idc.rxBufRdPtr % WRHV_DUART_RX_SIZE;
+	return value;
+}
+
+void wrhv_duart_init(void)
+{
+	const char *opt;
+	char *pstring;
+	unsigned char bootline[VB_MAX_BOOTLINE_LENGTH];
+
+	/* this functions can be called very early, even before
+	 * the platform code. The command line options needed
+	 * to be directly from VBI_BOOTLINE
+	 */
+	strncpy(bootline, wr_config->bootLine, VB_MAX_BOOTLINE_LENGTH - 1);
+	bootline[VB_MAX_BOOTLINE_LENGTH - 1] = 0;
+
+	/* get the duart name, the duart name is
+	 * specified in the hypervisor xml
+	 */
+	memset(wrhv_duart_name, 0, sizeof(wrhv_duart_name));
+	pstring = wrhv_duart_name;
+	opt = strstr(bootline, "duart=");
+	if (opt) {
+		opt += 6;
+		while (*opt && (*opt != ' ')) {
+			*pstring = *opt;
+			pstring++;
+			opt++;
+		}
+	} else {
+		opt = strstr(bootline, "console=hvc");
+		if (opt) {
+			char *p;
+
+			opt += 11;
+			if (*opt < '0' || *opt > '9')
+				return;
+			wrhv_get_serial_devices();
+			p = wrhv_get_serial_dev_name(*opt - '0');
+			strcpy(pstring, p);
+		} else
+			return;
+	}
+
+	/* only init the duart once */
+	if (is_wrhv_duart_inited) {
+		return;
+	}
+	is_wrhv_duart_inited = 1;
+
+
+	/* init channel */
+	if (vbi_pdc_init(wrhv_duart_name, &duart_pdc)) {
+		printk("vbi_pdc_init failed\n");
+		return;
+	}
+
+	/* init device */
+	if (vbi_pdc_op(duart_pdc, PDC_REQUEST_INIT,
+		0, (void *) &idc, 0, 0)) {
+		printk("vbi_pdc_op: PDC_REQUEST_INIT failed\n");
+		return;
+	}
+}
diff --git a/drivers/wrhv/wrhv_serial.c b/drivers/wrhv/wrhv_serial.c
new file mode 100644
index 0000000..7eef360
--- /dev/null
+++ b/drivers/wrhv/wrhv_serial.c
@@ -0,0 +1,244 @@
+/*
+ *  Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/virtio.h>
+#include <linux/virtio_config.h>
+#include <linux/virtio_ids.h>
+#include <linux/virtio_console.h>
+#include <vbi/vbi.h>
+#include <vbi/pdc.h>
+#include <vbi/duart.h>
+#include <linux/scatterlist.h>
+#include <linux/hrtimer.h>
+#include "wrhv_devices.h"
+
+static struct hrtimer *wrhv_serial_timer;
+
+extern vbi_pdc_handle duart_pdc;
+extern struct intr_device_channel_buffer idc;
+extern char wrhv_duart_name[];
+
+#ifdef CONFIG_WRHV_VIRTIO_SERIAL_CONSOLE
+/* interface to wrhv duart actual device driver */
+#define WRHV_DUART_RX_SIZE	(16)
+#define WRHV_DUART_TX_SIZE	(1024)
+
+void wrhv_duart_putc(char c);
+void wrhv_duart_init(void);
+
+static int __init wrhv_early_put_chars(u32 vtermo, const char *buf, int count)
+{
+	int i;
+
+	for (i = 0; i < count; i++, buf++)
+		wrhv_duart_putc(*buf);
+
+	return count;
+}
+
+static int __init wrhv_virtio_console_init(void)
+{
+	wrhv_duart_init();
+
+	return virtio_cons_early_init(wrhv_early_put_chars);
+}
+console_initcall(wrhv_virtio_console_init);
+#endif
+
+#define WRHV_MAX_SERIAL_DEVICES 4
+struct wrhv_serial_dev {
+	char name[16];
+	int irq;
+};
+struct wrhv_serial_dev wrhv_serial_devs[WRHV_MAX_SERIAL_DEVICES];
+
+#define WRHV_CLASS_SERIAL	0
+#define WRHV_TYPE_ADD		1
+
+extern struct vb_config *wr_vb_config;
+void wrhv_get_serial_devices(void)
+{
+	struct vb_dev_info *pdev = wr_vb_config->deviceConfiguration;
+	struct vb_dev_int_info *pint;
+	int num = wr_vb_config->numDevices, i, j;
+	struct wrhv_serial_dev *p;
+	static int done;
+
+	if (done)
+		return;
+	else
+		done = 1;
+
+	j = 0;
+	for (i = 0; i < num; i++, pdev++) {
+		if (pdev->deviceClass != WRHV_CLASS_SERIAL ||
+			pdev->deviceType != WRHV_TYPE_ADD)
+			continue;
+
+		p = &wrhv_serial_devs[j];
+		strcpy(p->name, pdev->deviceName);
+		if (pdev->numInterrupts) {
+			pint = (struct vb_dev_int_info *)((char *)pdev +
+					pdev->intInfoOffset);
+			p->irq = pint ? pint->intNum : 0;
+		}
+		j++;
+		if (j >= WRHV_MAX_SERIAL_DEVICES)
+			break;
+	}
+}
+EXPORT_SYMBOL_GPL(wrhv_get_serial_devices);
+
+char *wrhv_get_serial_dev_name(int index)
+{
+	if (index < 0 || index >= WRHV_MAX_SERIAL_DEVICES)
+		return NULL;
+
+	return wrhv_serial_devs[index].name;
+}
+EXPORT_SYMBOL(wrhv_get_serial_dev_name);
+
+static int is_console_device(struct wrhv_device *vdev)
+{
+	return !strcmp(vdev->desc->name, wrhv_duart_name);
+}
+
+extern void hvc_kick(void);
+static enum hrtimer_restart wrhv_serial_kick(struct hrtimer *t)
+{
+	ktime_t now;
+
+	hvc_kick();
+
+	now = hrtimer_cb_get_time(t);
+	hrtimer_forward(t, now, ktime_set(0, 50000000));
+	return HRTIMER_RESTART;
+}
+
+static int wrhv_serial_init_device(struct wrhv_device *vdev)
+{
+	if (is_console_device(vdev))
+		vdev->pdc_handle = duart_pdc;
+	else {
+		/* init channel */
+		if (vbi_pdc_init(vdev->desc->name, &vdev->pdc_handle))
+			return -1;
+
+		/* init device */
+		if (vbi_pdc_op(vdev->pdc_handle, PDC_REQUEST_INIT, 0,
+			vdev->idc, 0, 0))
+			return -1;
+	}
+
+	if (!(vdev->mode & WRHV_DEVICE_MODE_INT) && !wrhv_serial_timer) {
+		struct hrtimer *t = kzalloc(sizeof(*t), GFP_KERNEL);
+
+		if (!t)
+			return -1;
+		hrtimer_init(t, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		t->function = wrhv_serial_kick;
+		hrtimer_start(t, ktime_set(0, 1000000000), HRTIMER_MODE_REL);
+		wrhv_serial_timer = t;
+	}
+
+	return wrhv_init_device(vdev);
+}
+
+static struct intr_device_channel_buffer *wrhv_serial_alloc_idc(struct wrhv_device *vdev)
+{
+	if (is_console_device(vdev))
+		vdev->idc = &idc;
+	else
+		vdev->idc = kzalloc(sizeof(*vdev->idc), GFP_KERNEL);
+
+	return vdev->idc;
+}
+
+static int wrhv_serial_init_idc(struct wrhv_device *vdev, unsigned int index,
+				struct wrhv_virtqueue *vq)
+{
+	if (is_console_device(vdev)) {
+		switch (index) {
+		case 0:
+			vq->buf = vdev->idc->rxBuf;
+			break;
+		case 1:
+			vq->buf = vdev->idc->txBuf;
+			break;
+		}
+		vq->mode |= WRHV_DEVICE_VQ_NOFREE;
+	} else {
+		vq->buf = kmalloc(vq->len, GFP_KERNEL);
+		if (!vq->buf)
+			return -ENOMEM;
+	}
+
+	wrhv_init_vq(vdev, index, vq);
+	return 0;
+}
+
+static struct wrhv_device_ops wrhv_serial_ops = {
+	.init_dev	= wrhv_serial_init_device,
+	.alloc_idc	= wrhv_serial_alloc_idc,
+	.init_idc	= wrhv_serial_init_idc,
+};
+
+struct wrhv_device_desc wrhv_init_serial_device = {
+	.name		= "uart0",
+	.type		= VIRTIO_ID_CONSOLE,
+	.num_vq		= 2,
+	.feature_len	= 1,
+	.config_len	= 1,
+	.vqconfig[0]	= {
+	.num		= 16,
+		.irq	= 20,
+	},
+	.vqconfig[1]	= {
+		.num	= 1024,
+	},
+};
+
+static __init int wrhv_add_serial(void)
+{
+	struct wrhv_device_desc *desc;
+	struct wrhv_serial_dev *p;
+	int i;
+
+	wrhv_get_serial_devices();
+
+	p = wrhv_serial_devs;
+	for (i = 0; i < WRHV_MAX_SERIAL_DEVICES; i++, p++) {
+		if (!p->name[0])
+			break;
+
+		desc = kzalloc(sizeof(*desc), GFP_KERNEL);
+		if (!desc)
+			return -ENOMEM;
+
+		*desc = wrhv_init_serial_device;
+		sprintf(desc->name, p->name);
+		desc->vqconfig[0].irq = p->irq;
+		wrhv_add_device(desc, &wrhv_serial_ops);
+	}
+
+	return 0;
+}
+module_init(wrhv_add_serial);
diff --git a/include/vbi/duart.h b/include/vbi/duart.h
new file mode 100644
index 0000000..99c6b89
--- /dev/null
+++ b/include/vbi/duart.h
@@ -0,0 +1,24 @@
+#ifndef DAURT_H
+#define DAURT_H
+
+/* taken from wrhv-1.2/include/sys/devices/drivers/serial.h */
+#define SIO_MODE_POLL   1       /* polling mode */
+#define SIO_MODE_INT    2       /* interrupt mode */
+
+/* options to SIO_HW_OPTS_SET (ala POSIX), bitwise or'ed together */
+
+#define SIO_HW_OPTS_CLOCAL 0x1 /* ignore modem status lines */
+#define SIO_HW_OPTS_CREAD  0x2 /* enable device reciever */
+
+#define SIO_HW_OPTS_CSIZE  0xc /* bits 3 and 4 encode the character size */
+#define SIO_HW_OPTS_CS5    0x0 /* 5 bits */
+#define SIO_HW_OPTS_CS6    0x4 /* 6 bits */
+#define SIO_HW_OPTS_CS7    0x8 /* 7 bits */
+#define SIO_HW_OPTS_CS8    0xc /* 8 bits */
+
+#define SIO_HW_OPTS_HUPCL  0x10 /* hang up on last close */
+#define SIO_HW_OPTS_STOPB  0x20 /* send two stop bits (else one) */
+#define SIO_HW_OPTS_PARENB 0x40 /* parity detection enabled (else disabled) */
+#define SIO_HW_OPTS_PARODD 0x80 /* odd parity  (else even) */
+
+#endif /* DUART_H */
-- 
1.7.0.2

