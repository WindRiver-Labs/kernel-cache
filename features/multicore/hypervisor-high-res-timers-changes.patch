From 32927dcda2afbfac4bb3aa5acd8e14f2a39216ca Mon Sep 17 00:00:00 2001
From: WRS Support <support@windriver.com>
Date: Fri, 2 Oct 2009 16:12:13 -0400
Subject: [PATCH 05/18] hypervisor: high res timers changes

High res timers on a multicore kernel requires this.

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 kernel/time/Kconfig          |    5 +++++
 kernel/time/tick-broadcast.c |   15 +++++++++++++++
 kernel/time/tick-oneshot.c   |    5 ++++-
 3 files changed, 24 insertions(+), 1 deletions(-)

diff --git a/kernel/time/Kconfig b/kernel/time/Kconfig
index 95ed429..b3f11ce 100644
--- a/kernel/time/Kconfig
+++ b/kernel/time/Kconfig
@@ -4,6 +4,11 @@
 config TICK_ONESHOT
 	bool
 
+config WRHV_X86_HRTIMERS
+	bool
+	depends on X86
+	default n
+
 config NO_HZ
 	bool "Tickless System (Dynamic Ticks)"
 	depends on GENERIC_TIME && GENERIC_CLOCKEVENTS
@@ -17,6 +21,7 @@ config HIGH_RES_TIMERS
 	bool "High Resolution Timer Support"
 	depends on GENERIC_TIME && GENERIC_CLOCKEVENTS
 	select TICK_ONESHOT
+	select WRHV_X86_HRTIMERS if WRHV && X86
 	help
 	  This option enables high resolution timer support. If your
 	  hardware is not capable then this option only increases
diff --git a/kernel/time/tick-broadcast.c b/kernel/time/tick-broadcast.c
index b3bafd5..49babeb 100644
--- a/kernel/time/tick-broadcast.c
+++ b/kernel/time/tick-broadcast.c
@@ -442,8 +442,16 @@ again:
 		 */
 		if (tick_broadcast_set_event(next_event, 0))
 			goto again;
+#ifdef CONFIG_WRHV_X86_HRTIMERS
+	} else {
+		now = ktime_get();
+		next_event = ktime_add_ns(now, dev->min_delta_ns);
+		tick_broadcast_set_event(next_event, 1);
+	}
+#else
 	}
 	raw_spin_unlock(&tick_broadcast_lock);
+#endif
 }
 
 /*
@@ -541,7 +549,9 @@ void tick_broadcast_setup_oneshot(struct clock_event_device *bc)
 		 * broadcast device to fire.
 		 */
 		cpumask_copy(to_cpumask(tmpmask), tick_get_broadcast_mask());
+#ifndef CONFIG_WRHV_X86_HRTIMERS
 		cpumask_clear_cpu(cpu, to_cpumask(tmpmask));
+#endif
 		cpumask_or(tick_get_broadcast_oneshot_mask(),
 			   tick_get_broadcast_oneshot_mask(),
 			   to_cpumask(tmpmask));
@@ -567,7 +577,12 @@ void tick_broadcast_switch_to_oneshot(void)
 
 	tick_broadcast_device.mode = TICKDEV_MODE_ONESHOT;
 	bc = tick_broadcast_device.evtdev;
+
+#ifdef CONFIG_WRHV_X86_HRTIMERS
+	if (bc && !smp_processor_id())
+#else
 	if (bc)
+#endif
 		tick_broadcast_setup_oneshot(bc);
 	raw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);
 }
diff --git a/kernel/time/tick-oneshot.c b/kernel/time/tick-oneshot.c
index aada0e5..b9dbd65 100644
--- a/kernel/time/tick-oneshot.c
+++ b/kernel/time/tick-oneshot.c
@@ -132,9 +132,12 @@ int tick_switch_to_oneshot(void (*handler)(struct clock_event_device *))
 	struct tick_device *td = &__get_cpu_var(tick_cpu_device);
 	struct clock_event_device *dev = td->evtdev;
 
+#ifndef CONFIG_WRHV_X86_HRTIMERS
 	if (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT) ||
 		    !tick_device_is_functional(dev)) {
-
+#else
+	if (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT)) {
+#endif
 		printk(KERN_INFO "Clockevents: "
 		       "could not switch to one-shot mode:");
 		if (!dev) {
-- 
1.6.5.2

