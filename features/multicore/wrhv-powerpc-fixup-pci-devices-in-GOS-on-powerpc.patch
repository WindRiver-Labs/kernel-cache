From cfecf1b701b7d9042ae73b6fbb6b7394bb86e616 Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Wed, 12 Jan 2011 19:42:32 +0800
Subject: [PATCH 2/4] wrhv/powerpc: fixup pci devices in GOS on powerpc

Switch to common fixup pci resource code.

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 arch/powerpc/include/asm/wrhv.h |    1 -
 arch/powerpc/kernel/paravirt.c  |    5 +---
 arch/powerpc/kernel/vbi/wrhv.c  |   47 ++++++++++++++------------------------
 3 files changed, 18 insertions(+), 35 deletions(-)

diff --git a/arch/powerpc/include/asm/wrhv.h b/arch/powerpc/include/asm/wrhv.h
index 8b50abe..52c9936 100644
--- a/arch/powerpc/include/asm/wrhv.h
+++ b/arch/powerpc/include/asm/wrhv.h
@@ -55,7 +55,6 @@ extern int ppc_search_free_law(int target_id);
 extern int ppc_setup_pci_law(struct device_node *dev);
 
 #ifdef CONFIG_PCI
-extern int ppc_get_pci_intr_wrhv(struct pci_dev *dev);
 extern int wrhv_enable_pci_law(void);
 #endif
 
diff --git a/arch/powerpc/kernel/paravirt.c b/arch/powerpc/kernel/paravirt.c
index 093faf5..f0b9e01 100644
--- a/arch/powerpc/kernel/paravirt.c
+++ b/arch/powerpc/kernel/paravirt.c
@@ -301,10 +301,7 @@ inline int paravirt_enabled(void)
 #ifdef CONFIG_PCI
 int paravirt_pci_read_irq_line(struct pci_dev *dev)
 {
-#if defined(CONFIG_WRHV)
-	return ppc_get_pci_intr_wrhv(dev);
-#endif /* CONFIG_WRHV */ 
-	return -1;
+	return 0;
 }
 #endif
 
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 01bcb7c..244fd21 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -535,6 +535,7 @@ int ppc_setup_pci_law( struct device_node *dev)
 	u32 pci_space, attr;
 	int pcie_index = 0;
 	const int *prop;
+	char *space_type;
 
 	if (!dev)
 		return -ENODEV;
@@ -577,8 +578,15 @@ int ppc_setup_pci_law( struct device_node *dev)
 				size += of_read_number(ranges + pna + 3, 2);
 			}
 
-			printk(KERN_INFO "  Setup LAW for PCIE Space  0x%016llx..0x%016llx \n", 
-					cpu_addr, cpu_addr + size - 1);
+			if (((pci_space >> 24 ) & 0x3) == 0x1)
+				space_type = "I/O";
+
+			if (((pci_space >> 24 ) & 0x3) == 0x2)
+				space_type = "MEM";
+
+			printk(KERN_INFO "WRHV: fixup LAW for PCIE %s Space "
+					"[ 0x%016llx..0x%016llx ]\n",
+					space_type, cpu_addr, cpu_addr + size - 1);
 
 			attr = LAW_EN | (pcie_index << 20) | (__ilog2(size) - 1) ;
 			ppc_setup_law(pcie_index, cpu_addr, attr);
@@ -809,8 +817,11 @@ unsigned int wrhv_map_irq_of_desc(char *irq_name, int32_t irq_dir)
 	struct irq_desc *desc;
 
 	irq = vbi_find_irq(irq_name, irq_dir);
-	if (irq == VBI_INVALID_IRQ)
+	if (irq == VBI_INVALID_IRQ) {
+		printk(KERN_WARNING "WRHV: no defined INT for [ %s ].\n",
+				irq_name);
 		return NO_IRQ;
+	}
 
 	desc = wrhv_irq_to_desc(irq);
 	if (unlikely(!desc))
@@ -1947,9 +1958,6 @@ void wrhv_request_ipis(void)
 		panic("WRHV reslove irq for IPI failed.\n");
 
 	for (i = 0; i < WRHV_IPI_NUM; i++) {
-		set_irq_chip_and_handler_name(irq_base + i,
-				&wrhv_ipi_irq_chip, handle_percpu_irq, "per_cpu");
-
 		err = request_irq(irq_base + i, wrhv_ipi_action,
 				IRQF_DISABLED | IRQF_PERCPU | IRQF_NOBALANCING,
 				ipi_names[i], (void *)i);
@@ -1962,6 +1970,9 @@ void wrhv_request_ipis(void)
 			 */
 			panic("WRHV: request_irq for IPI faild.\n");
 		}
+
+		set_irq_chip_and_handler_name(irq_base + i,
+				&wrhv_ipi_irq_chip, handle_percpu_irq, "per_cpu");
 	}
 }
 
@@ -2240,30 +2251,6 @@ long long wrhv_gettb_diff()
 #endif
 
 #ifdef CONFIG_PCI
-#define VECTOR_NAME_SIZE	8
-int ppc_get_pci_intr_wrhv(struct pci_dev *dev)
-{
-	int irq = -1;
-	u8  pin = 0;
-	char vector_name[VECTOR_NAME_SIZE];
-	static char line[4] = {'A', 'B', 'C', 'D'};
-
-	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
-
-	if (pin) {
-		snprintf(vector_name, VECTOR_NAME_SIZE, "PCIe%d_%c", 
-			(dev->bus->number+1), line[pin-1]);
-		irq = wrhv_map_irq_of_desc(vector_name, 1);
-		if (irq >= 0) {
-			dev->irq = irq;
-			printk("WRHV-PCI: BUS NO:%x CLASS:%x IRQ%d for %s\n", 
-				dev->bus->number, dev->class, dev->irq, vector_name);
-			return 0;
-		}
-	}
-
-	return -1;
-}
 
 /* On PPC we have to disable MSI firstly to adopt the legacy interrupt 
  * since the BootROM with supporting PCIE always use MSI way. 
-- 
1.6.5.2

