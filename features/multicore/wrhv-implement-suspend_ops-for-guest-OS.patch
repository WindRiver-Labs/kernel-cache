From 50cce42c4081355260f3fe97fe24d873ed7cea1e Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Thu, 1 Jul 2010 19:58:54 +0800
Subject: [PATCH 4/7] wrhv: implement suspend_ops for guest OS

Withe suspend_ops get implemented, enables suspend guest
within guest os via:

> echo mem > /sys/power/state
or
> echo standby > /sys/power/state

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 kernel/vbi/wrhv.c |  116 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 116 insertions(+), 0 deletions(-)

diff --git a/kernel/vbi/wrhv.c b/kernel/vbi/wrhv.c
index eccc538..9e39d42 100644
--- a/kernel/vbi/wrhv.c
+++ b/kernel/vbi/wrhv.c
@@ -22,6 +22,8 @@
 #include <linux/sched.h>
 #include <linux/smp.h>
 #include <vbi/vbi.h>
+#include <linux/suspend.h>
+#include <linux/cpu.h>
 
 #define VIOAPIC_BASE_ADDR	(&wr_vb_control->vIoapic)
 
@@ -183,3 +185,117 @@ EXPORT_SYMBOL_GPL(vbi_vb_find_board_config);
 EXPORT_SYMBOL_GPL(vbi_vb_read_reg);
 EXPORT_SYMBOL_GPL(vbi_vb_write_reg);
 EXPORT_SYMBOL_GPL(vbi_vb_resume);
+
+static int wrhv_suspend_valid(suspend_state_t state)
+{
+	return state == PM_SUSPEND_STANDBY || state == PM_SUSPEND_MEM;
+}
+
+static int wrhv_suspend_begin(suspend_state_t state)
+{
+	switch (state) {
+		case PM_SUSPEND_STANDBY:
+		case PM_SUSPEND_MEM:
+			return 0;
+		default:
+			return -EINVAL;
+	}
+}
+
+static int wrhv_suspend_enter(suspend_state_t state)
+{
+	vbi_vb_suspend(VBI_BOARD_ID_GET(), 0);
+	return 0;
+}
+
+static cpumask_var_t wrhv_cpus;
+
+static int wrhv_save_cpus(void)
+{
+	int cpu, first_cpu, error;
+
+	cpumask_clear(wrhv_cpus);
+
+	if (num_online_cpus() == 1)
+		return 0;
+
+	first_cpu = cpumask_first(cpu_online_mask);
+
+	for_each_online_cpu(cpu) {
+		if (cpu == first_cpu)
+			continue;
+		error = cpu_down(cpu);
+		if (!error)
+			cpumask_set_cpu(cpu, wrhv_cpus);
+		else {
+			printk(KERN_ERR "wrhv_bring_nonboot_cpu CPU%d down: %d\n",
+				cpu, error);
+			break;
+		}
+	}
+
+	if (!error)
+		BUG_ON(num_online_cpus() > 1);
+	else
+		printk(KERN_ERR "Non-boot CPUs are not disabled\n");
+
+	return error;
+}
+
+static void wrhv_restore_cpus(void)
+{
+	int cpu, error;
+
+	if (cpumask_empty(wrhv_cpus))
+		return;
+
+	for_each_cpu(cpu, wrhv_cpus) {
+		error = cpu_up(cpu);
+		if (!error) {
+			printk("CPU%d is up\n", cpu);
+			continue;
+		}
+		printk(KERN_WARNING "Error bringing CPU%d up: %d\n", cpu, error);
+	}
+
+}
+
+static int wrhv_suspend_prepare(void)
+{
+	wrhv_save_cpus();
+
+	return 0;
+}
+
+static int wrhv_suspend_prepare_late(void)
+{
+	return 0;
+}
+
+static void wrhv_suspend_end(void)
+{
+	wrhv_restore_cpus();
+}
+
+
+static struct platform_suspend_ops wrhv_suspend_ops = {
+	.valid = wrhv_suspend_valid,
+	.begin = wrhv_suspend_begin,
+	.prepare = wrhv_suspend_prepare,
+	.prepare_late = wrhv_suspend_prepare_late,
+	.enter = wrhv_suspend_enter,
+	.end = wrhv_suspend_end,
+};
+
+int __weak wrhv_arch_late_init(void)
+{
+	return 0;
+}
+
+int __init wrhv_late_init(void)
+{
+	wrhv_arch_late_init();
+	suspend_set_ops(&wrhv_suspend_ops);
+	return 0;
+}
+late_initcall(wrhv_late_init);
-- 
1.6.5.2

