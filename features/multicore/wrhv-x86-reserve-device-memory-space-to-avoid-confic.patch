From 0cb4ea649c4897b8dc766c63506f991688d0104f Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Fri, 12 Aug 2011 09:56:30 +0800
Subject: [PATCH 2/3] wrhv/x86: reserve device memory space to avoid confict with phy mem

PCI device memory space needs to be reserved, or the linux memory management
system will allocate a memory space which belongs to PCI memory space, and
finally cause system failure. A new function wrhv_post_memory_setup which is
called by wrhv_init is introduced to do this reservation. The existing
function wrhv_memory_setup can't do the reservation is that early_memremap
is needed, and this function can only work after NX bit of page table is
masked(NX is not supported in wrhv). So wrhv_init is moved backwards a bit
(just after NX is set up), and wrhv_post_memory_setup is called by wrhv_init
then.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/x86/kernel/setup.c    |    8 ++++----
 arch/x86/kernel/vbi/wrhv.c |   31 ++++++++++++++++++++++++++++++-
 2 files changed, 34 insertions(+), 5 deletions(-)

diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c
index 0cf7e1a..d4d2bb8 100644
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@ -844,14 +844,14 @@ void __init setup_arch(char **cmdline_p)
 	 */
 	x86_configure_nx();
 
-#ifdef CONFIG_WRHV
-	wrhv_init();
-#endif
-
 	parse_early_param();
 
 	x86_report_nx();
 
+#ifdef CONFIG_WRHV
+	wrhv_init();
+#endif
+
 	/* Must be before kernel pagetables are setup */
 	vmi_activate();
 
diff --git a/arch/x86/kernel/vbi/wrhv.c b/arch/x86/kernel/vbi/wrhv.c
index 26dbcec..9dd33c0 100644
--- a/arch/x86/kernel/vbi/wrhv.c
+++ b/arch/x86/kernel/vbi/wrhv.c
@@ -526,9 +526,37 @@ char *__init wrhv_memory_setup(void)
 {
 	char *who = "WRHV-e820";
 	e820_add_region(0, wr_config->phys_mem_size, E820_RAM);
+	return who;
+
+}
+
+/* set device space and vb config as E820_RESERVED to avoid conflict with phy mem */
+#define TYPE_IO 1
+void __init wrhv_post_memory_setup(void)
+{
+	struct vb_dev_info *pdev;
+	struct vb_dev_regset_info *preg;
+	struct vb_config *pconfig;
+	int i, j;
+	unsigned long delta;
+	pconfig = early_memremap((resource_size_t)_wr_config,
+				WRHV_RESERVED_PAGES << PAGE_SHIFT);
+	delta = (unsigned long)pconfig - (unsigned long)_wr_config;
+	pdev = (struct vb_dev_info *)(delta +
+			 (unsigned long)wr_config->deviceConfiguration);
+	for (i = 0; i < wr_config->numDevices; i++, pdev++) {
+		if (pdev->numRegSets > 0) {
+			preg = (struct vb_dev_regset_info *)((char *)pdev +
+							pdev->regSetInfoOffset);
+			for(j=0; j < pdev->numRegSets; j++, preg++)
+				if (preg->regSetType !=  TYPE_IO)
+					e820_add_region(preg->regSetAddress,
+					 preg->regSetLength, E820_RESERVED);
+		}
+	}
+	early_iounmap(pconfig, WRHV_RESERVED_PAGES << PAGE_SHIFT);
 	e820_add_region((phys_addr_t)_wr_config, 0x10000, E820_RESERVED);
 	update_e820();
-	return who;
 
 }
 
@@ -1571,4 +1599,5 @@ void __init wrhv_init(void)
 #ifdef CONFIG_SMP
 	wrhv_smp_init();
 #endif
+	wrhv_post_memory_setup();
 }
-- 
1.7.0.2

