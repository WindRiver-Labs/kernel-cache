From 231e3b84ab2155de7207e4b87d67979bc52f0174 Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Mon, 26 Apr 2010 13:29:39 +0800
Subject: [PATCH 18/18] vbi: update to wrhv1.2 Apr 9th

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 arch/powerpc/include/asm/arch_vbi.h |   42 ++
 arch/powerpc/kernel/vbi/syscalls.S  |   33 ++
 arch/x86/include/asm/arch_vbi.h     |   64 +++-
 arch/x86/include/asm/reg_vbi.h      |  984 ++++++++++++++++++-----------------
 arch/x86/include/asm/vbi.h          |    8 +-
 arch/x86/kernel/vbi/syscalls.S      |   67 ++-
 include/vbi/compat.h                |    5 +
 include/vbi/interface.h             |   26 +-
 include/vbi/private.h               |    3 +
 include/vbi/shmem.h                 |    2 +
 include/vbi/syscall.h               |    6 +-
 include/vbi/syscalls.h              |   33 +-
 include/vbi/vbi.h                   |    2 +
 kernel/vbi/lib.c                    |   16 +
 kernel/vbi/shmem.c                  |   13 +
 15 files changed, 788 insertions(+), 516 deletions(-)

diff --git a/arch/powerpc/include/asm/arch_vbi.h b/arch/powerpc/include/asm/arch_vbi.h
index 46da617..b8cc7d3 100644
--- a/arch/powerpc/include/asm/arch_vbi.h
+++ b/arch/powerpc/include/asm/arch_vbi.h
@@ -390,6 +390,48 @@ typedef struct
 /* VBI_HREG_SET is same as HREG_SET in ppc */
 typedef HREG_SET VBI_HREG_SET;
 
+
+/*
+ *
+ * VBI_HREG_SET_64 - hardware register set, for read/write
+ *
+ * Used by vbiVbRegisterComplexRead/vbiVbRegisterComplexWrite to read/write
+ * registers in another VB
+ * 
+ */
+
+typedef struct
+{
+	uint64_t gpr[GREG_NUM];	/* general purpose registers */
+	uint64_t msr;		/* machine state register */
+	uint64_t lr;		/* link register */
+	uint64_t ctr;		/* count register */
+	uint64_t pc;		/* program counter */
+	uint64_t cr;		/* condition register */
+	uint64_t xer;		/* fixed-point exception register */
+	uint64_t spefscr; 	/* SPE floating-point status & ctrl reg */
+	uint64_t casid;		/* PPC405, Book E PID and PPC860 M_CASID */
+} HREG_SET_64;
+
+/* VBI_HREG_SET_64 is same as HREG_SET_64 in ppc */
+typedef HREG_SET_64 VBI_HREG_SET_64;
+
+
+/* complex register set definition */
+
+typedef union
+{
+	VBI_HREG_SET    hreg32;	/* 32 bit register set */
+	VBI_HREG_SET_64 hreg64;     /* 64 bit register set */
+} VBI_HREG_SET_CMPLX;
+
+
+typedef struct
+{
+	vbiRegSet_t        vbiRegType;
+	VBI_HREG_SET_CMPLX vbiRegSet;
+} VBI_HREG_SET_CMPLX_QUALIFIED;
+
 /* mdio messages */
 #define VBI_MDIO_READ           MDIO_READ
 #define VBI_MDIO_WRITE          MDIO_WRITE
diff --git a/arch/powerpc/kernel/vbi/syscalls.S b/arch/powerpc/kernel/vbi/syscalls.S
index 5b899cb..7a48e9d 100644
--- a/arch/powerpc/kernel/vbi/syscalls.S
+++ b/arch/powerpc/kernel/vbi/syscalls.S
@@ -67,6 +67,8 @@ FUNC_EXPORT(vbi_vb_suspend)
 FUNC_EXPORT(vbi_vb_reset)
 FUNC_EXPORT(vbi_vb_restart)
 FUNC_EXPORT(vbi_vb_resume)
+FUNC_EXPORT(vbi_vb_remote)
+FUNC_EXPORT(vbi_direct_IRQ_EOI)
 
 _WRS_TEXT_SEG_START
 
@@ -711,3 +713,34 @@ vbi_hcall(vbi_vb_write_reg, RegsWrite_op)
  * vbi_vcore_irq_redirect - redirect an irq to another vcore
  */
 vbi_hcall(vbi_vcore_irq_redirect, intRedirect)
+
+/*
+ * vbi_vb_remote - VB remote operations
+ *
+ * This system call interfaces to the virtual board and requests for
+ * information about a remote VB
+ *
+ * commands:
+ *      VBI_VBREMOTE_BOARDCONFIG         get guest addr of VB_CONFIG
+ *      VBI_VBREMOTE_RAMSIZE             get memory size
+ *
+ */
+vbi_hcall(vbi_vb_remote, vbRemote)
+
+/*
+ * vbi_direct_IRQ_EOI - clear last interrupt 
+ *
+ * This system call interfaces to the virtual board to clear the last PIC 
+ * interrupt enabling another interrupt to be triggered in the hardware.
+ * Should be used only when Virtual board is using direct interrupts.
+ *
+ */
+FUNC_LABEL(vbi_direct_IRQ_EOI)
+#ifdef CONFIG_PPC85xx_VT_MODE
+	lis r0, HI(VBI_SYS_pic_EOI)
+	ori r0, r0, LO(VBI_SYS_pic_EOI)
+	HCALL
+#endif
+	blr
+FUNC_END(vbi_direct_IRQ_EOI)
+
diff --git a/arch/x86/include/asm/arch_vbi.h b/arch/x86/include/asm/arch_vbi.h
index 978c5fa..e7544c9 100644
--- a/arch/x86/include/asm/arch_vbi.h
+++ b/arch/x86/include/asm/arch_vbi.h
@@ -56,17 +56,74 @@ typedef struct			/* VBI_REG_SET - used for sys_regsRead/Write */
 	uint32_t  tr;		/* 58: task register		*/
 } VBI_HREG_SET;
 
+
+typedef struct			/* REG_SET - x86 register set	*/
+{
+	_RType   rax;		/* 00: general register		*/
+	_RType   rbx;		/* 08: general register		*/
+	_RType   rcx;		/* 10: general register		*/
+	_RType   rdx;		/* 18: general register		*/
+	_RType   rsp;		/* 20: stack pointer register	*/
+	_RType   rbp;		/* 28: frame pointer register	*/
+	_RType   rsi;		/* 30: general register		*/
+	_RType   rdi;		/* 38: general register		*/
+	_RType   r8;	 	/* 40: general register		*/
+	_RType   r9;	 	/* 48: general register		*/
+	_RType   r10;		/* 50: general register		*/
+	_RType   r11;		/* 58: general register		*/
+	_RType   r12;		/* 60: general register		*/
+	_RType   r13;		/* 68: general register		*/
+	_RType   r14;		/* 70: general register		*/
+	_RType   r15;		/* 78: general register		*/
+	_RType   rip;		/* 80: program counter		*/
+	_RType   rflags;		/* 88: status register		*/
+	_RType   cr0;		/* 90: control register 0	*/
+	_RType   cr2;		/* 98: control register 2	*/
+	_RType   cr3;		/* 100: control register 3	*/
+	_RType   cr4;		/* 108: control register 4	*/
+	_RType   idtr;		/* 110: IDT task register	*/
+	_RType   gdtr;		/* 118: GDT task register	*/
+	_RType   ldtr;		/* 120: LDT task register	*/
+	_RType   cs;		/* 128: code segment		*/
+	_RType   ds;		/* 130: data segment		*/
+	_RType   ss;		/* 138: stack segment		*/
+	_RType   es;		/* 140: E segment		*/
+	_RType   fs;		/* 148: F segment		*/
+	_RType   gs;		/* 150: G segment		*/
+	/* xxx(gws): excluding FP support */
+} VBI_HREG_SET_64;
+
+
+/* complex register set definition */
+
+typedef union
+{
+	VBI_HREG_SET    hreg32;	/* 32 bit register set */
+	VBI_HREG_SET_64 hreg64;	/* 64 bit register set */
+} VBI_HREG_SET_CMPLX;
+
+
+typedef struct
+{
+	uint32_t        vbiRegType;  /* 00: register set to use */
+	uint32_t	    qualifier;   /* 04: optional field, used for alignment */
+
+	VBI_HREG_SET_CMPLX vbiRegSet;
+} VBI_HREG_SET_CMPLX_QUALIFIED;
+
+
 #endif /* _ASMLANGUAGE */
 
+
 /* x86 uses little endian byte ordering */
 
 #define __VBI_BYTE_ORDER __VBI_LITTLE_ENDIAN
 
-#define	VBI_X86_MAX_VECTORS         256	/* maximum number of vectors */
+#define VBI_X86_MAX_VECTORS         256	/* maximum number of vectors */
 #define VBI_ARCH_EXC_TABLE_SIZE     32
 #define VBI_ARCH_IRQ_TABLE_SIZE     (VBI_X86_MAX_VECTORS - VBI_ARCH_EXC_TABLE_SIZE)
 
-#define	VBI_MAX_CORES		    8	/* maximum number of virtual cores */
+#define VBI_MAX_CORES		    8	/* maximum number of virtual cores */
 
 #define VBI_IN_DIVIDE_ERROR		 0
 #define VBI_IN_DEBUG			 1
@@ -149,4 +206,7 @@ typedef struct			/* VBI_REG_SET - used for sys_regsRead/Write */
 #define VBI_CLOCK_TIMER_VECTOR		0
 #define VBI_IN_APIC_TIMER		(VBI_IN_EXT_IRQ0)
 
+/* XXX this is less than desireable */
+#define IS_GUEST_REG_64(pCtx) (pCtx->arch->
+
 #endif /* _ASM_ARCH_VBI_H */
diff --git a/arch/x86/include/asm/reg_vbi.h b/arch/x86/include/asm/reg_vbi.h
index ef5c24e..cffba87 100644
--- a/arch/x86/include/asm/reg_vbi.h
+++ b/arch/x86/include/asm/reg_vbi.h
@@ -14,12 +14,12 @@
  *
  */
 
-#ifndef	__INCx86regsh
-#define	__INCx86regsh
+#ifndef __ASM_REG_VBI_H
+#define __ASM_REG_VBI_H
 
 #define IO_BMAP_SIZE	32	/* IO bitmap for port 0x000 - 0x3ff */
 
-#ifndef	_ASMLANGUAGE
+#ifndef _ASMLANGUAGE
 
 #ifdef LP64
 typedef struct			/* REG_SET - x86 register set	*/
@@ -144,6 +144,7 @@ typedef union
 #define CPUID_MODEL_CORE2	15	/* model: Core2 Duo/Quad/Xeon	*/
 #define CPUID_MODEL_CORE2_E	23	/* model: Core2 Extreme		*/
 #define CPUID_MODEL_I7		26	/* model: Core i7		*/
+#define CPUID_MODEL_ATOM	28	/* model: Atom			*/
 #define CPUID_MODEL_NEHALEM1	30	/* model: Core Architecture	*/
 #define CPUID_MODEL_NEHALEM2	32	/* model: Core Architecture	*/
 #define CPUID_MODEL_NEHALEM3	46	/* model: Core Architecture	*/
@@ -485,29 +486,29 @@ typedef struct idt64_entry
     uint32_t	res3;		/* reserved */
     } IDT64_ENTRY;
 
-#define	GDT_CALL_ENTRY		GDT64_CALL_ENTRY
-#define	IDT_ENTRY		IDT64_ENTRY
+#define GDT_CALL_ENTRY		GDT64_CALL_ENTRY
+#define IDT_ENTRY		IDT64_ENTRY
 #else
-#define	GDT_CALL_ENTRY		GDT32_CALL_ENTRY
-#define	IDT_ENTRY		IDT32_ENTRY
+#define GDT_CALL_ENTRY		GDT32_CALL_ENTRY
+#define IDT_ENTRY		IDT32_ENTRY
 #endif	/* LP64 */
 
 
-#define	GDT_BASE00_SHIFT	00
-#define	GDT_BASE01_SHIFT	16
-#define	GDT_BASE02_SHIFT	24
-#define	GDT_BASE00_MASK		0x0000ffff
-#define	GDT_BASE01_MASK		0x00ff0000
-#define	GDT_BASE02_MASK		0xff000000
+#define GDT_BASE00_SHIFT	00
+#define GDT_BASE01_SHIFT	16
+#define GDT_BASE02_SHIFT	24
+#define GDT_BASE00_MASK		0x0000ffff
+#define GDT_BASE01_MASK		0x00ff0000
+#define GDT_BASE02_MASK		0xff000000
 
-#define	GDT_LIMIT00_SHIFT	00
-#define	GDT_LIMIT01_SHIFT	16
-#define	GDT_LIMIT00_MASK	0x0ffff
-#define	GDT_LIMIT01_MASK	0xf0000
+#define GDT_LIMIT00_SHIFT	00
+#define GDT_LIMIT01_SHIFT	16
+#define GDT_LIMIT00_MASK	0x0ffff
+#define GDT_LIMIT01_MASK	0xf0000
 
-#define	GDT_BASE(p)	((p->base02 << GDT_BASE02_SHIFT) | \
+#define GDT_BASE(p)	((p->base02 << GDT_BASE02_SHIFT) | \
 			 (p->base01 << GDT_BASE01_SHIFT) | p->base00)
-#define	GDT_LIMIT(p)	((p->limit01 << GDT_LIMIT01_SHIFT) | p->limit00)
+#define GDT_LIMIT(p)	((p->limit01 << GDT_LIMIT01_SHIFT) | p->limit00)
 
 #define GDT_LIMIT00(v)	(((v) & GDT_LIMIT00_MASK) >> GDT_LIMIT00_SHIFT)
 #define GDT_LIMIT01(v)	(((v) & GDT_LIMIT01_MASK) >> GDT_LIMIT01_SHIFT)
@@ -518,12 +519,12 @@ typedef struct idt64_entry
 
 /* GDT call entry macros */
 
-#define	GDT32_OFFSET00_SHIFT	00
-#define	GDT32_OFFSET01_SHIFT	16
-#define	GDT32_OFFSET00_MASK	0x0000ffff
-#define	GDT32_OFFSET01_MASK	0xffff0000
+#define GDT32_OFFSET00_SHIFT	00
+#define GDT32_OFFSET01_SHIFT	16
+#define GDT32_OFFSET00_MASK	0x0000ffff
+#define GDT32_OFFSET01_MASK	0xffff0000
 
-#define	GDT32_OFFSET(p)		((p->offset01 << GDT32_OFFSET01_SHIFT) | \
+#define GDT32_OFFSET(p)		((p->offset01 << GDT32_OFFSET01_SHIFT) | \
 				 p->offset00)
 #define GDT32_OFFSET00(v)	(((v) & GDT32_OFFSET00_MASK) >> \
 				 GDT32_OFFSET00_SHIFT)
@@ -531,13 +532,13 @@ typedef struct idt64_entry
 				 GDT32_OFFSET01_SHIFT)
 
 #ifdef	LP64
-#define	GDT64_OFFSET00_SHIFT	00
-#define	GDT64_OFFSET01_SHIFT	16
-#define	GDT64_OFFSET02_SHIFT	32
-#define	GDT64_OFFSET00_MASK	0x000000000000ffff
-#define	GDT64_OFFSET01_MASK	0x00000000ffff0000
+#define GDT64_OFFSET00_SHIFT	00
+#define GDT64_OFFSET01_SHIFT	16
+#define GDT64_OFFSET02_SHIFT	32
+#define GDT64_OFFSET00_MASK	0x000000000000ffff
+#define GDT64_OFFSET01_MASK	0x00000000ffff0000
 
-#define	GDT64_OFFSET(p)		((((uint64_t) p->offset02) << \
+#define GDT64_OFFSET(p)		((((uint64_t) p->offset02) << \
 					GDT64_OFFSET02_SHIFT) | \
 				 (p->offset01 << GDT64_OFFSET01_SHIFT) | \
 				 p->offset00)
@@ -547,117 +548,117 @@ typedef struct idt64_entry
 					    GDT64_OFFSET01_SHIFT)))
 #define GDT64_OFFSET02(v)	((uint32_t)(((v) >> GDT64_OFFSET02_SHIFT)))
 
-#define	GDT_OFFSET		GDT64_OFFSET
-#define	GDT_OFFSET00		GDT64_OFFSET00
-#define	GDT_OFFSET01		GDT64_OFFSET01
-#define	GDT_OFFSET02		GDT64_OFFSET02
+#define GDT_OFFSET		GDT64_OFFSET
+#define GDT_OFFSET00		GDT64_OFFSET00
+#define GDT_OFFSET01		GDT64_OFFSET01
+#define GDT_OFFSET02		GDT64_OFFSET02
 #else	/* LP64 */
-#define	GDT_OFFSET		GDT32_OFFSET
-#define	GDT_OFFSET00		GDT32_OFFSET00
-#define	GDT_OFFSET01		GDT32_OFFSET01
+#define GDT_OFFSET		GDT32_OFFSET
+#define GDT_OFFSET00		GDT32_OFFSET00
+#define GDT_OFFSET01		GDT32_OFFSET01
 #endif
 
 /* IDT aliases */
 
-#define	IDT32_OFFSET(x)		GDT32_OFFSET(x)
-#define	IDT32_OFFSET00(x)	GDT32_OFFSET00(x)
-#define	IDT32_OFFSET01(x)	GDT32_OFFSET01(x)
+#define IDT32_OFFSET(x)		GDT32_OFFSET(x)
+#define IDT32_OFFSET00(x)	GDT32_OFFSET00(x)
+#define IDT32_OFFSET01(x)	GDT32_OFFSET01(x)
 
 #ifdef	LP64
-#define	IDT64_OFFSET(x)		GDT64_OFFSET(x)
-#define	IDT64_OFFSET00(x)	GDT64_OFFSET00(x)
-#define	IDT64_OFFSET01(x)	GDT64_OFFSET01(x)
-#define	IDT64_OFFSET02(x)	GDT64_OFFSET02(x)
-
-#define	IDT_OFFSET		IDT64_OFFSET
-#define	IDT_OFFSET00		IDT64_OFFSET00
-#define	IDT_OFFSET01		IDT64_OFFSET01
-#define	IDT_OFFSET02		IDT64_OFFSET02
+#define IDT64_OFFSET(x)		GDT64_OFFSET(x)
+#define IDT64_OFFSET00(x)	GDT64_OFFSET00(x)
+#define IDT64_OFFSET01(x)	GDT64_OFFSET01(x)
+#define IDT64_OFFSET02(x)	GDT64_OFFSET02(x)
+
+#define IDT_OFFSET		IDT64_OFFSET
+#define IDT_OFFSET00		IDT64_OFFSET00
+#define IDT_OFFSET01		IDT64_OFFSET01
+#define IDT_OFFSET02		IDT64_OFFSET02
 #else	/* LP64 */
-#define	IDT_OFFSET		IDT32_OFFSET
-#define	IDT_OFFSET00		IDT32_OFFSET00
-#define	IDT_OFFSET01		IDT32_OFFSET01
-#define	IDT_OFFSET02		IDT32_OFFSET02
+#define IDT_OFFSET		IDT32_OFFSET
+#define IDT_OFFSET00		IDT32_OFFSET00
+#define IDT_OFFSET01		IDT32_OFFSET01
+#define IDT_OFFSET02		IDT32_OFFSET02
 #endif	/* LP64 */
 
 /* GDT data segment types */
 
-#define	GDT_TYPE_RO		0	/* read-only			   */
-#define	GDT_TYPE_RO_A		1	/* read-only accessed		   */
-#define	GDT_TYPE_RW		2	/* read-write			   */
-#define	GDT_TYPE_RW_A		3	/* read-write accessed		   */
-#define	GDT_TYPE_RO_DOWN	4	/* read-only expand-down	   */
-#define	GDT_TYPE_RO_DOWN_A	5	/* read-only expand-down accessed  */
-#define	GDT_TYPE_RW_DOWN	6	/* read-write expand-down	   */
-#define	GDT_TYPE_RW_DOWN_A	7	/* read-write expand-down accessed */
-#define	GDT_TYPE_EX		8	/* execute			   */
-#define	GDT_TYPE_EX_A		9	/* execute accessed		   */
-#define	GDT_TYPE_EX_RO		10	/* execute read-only		   */
-#define	GDT_TYPE_EX_RO_A	11	/* execute read-only accessed	   */
-#define	GDT_TYPE_EX_CF		12	/* execute conforming		   */
-#define	GDT_TYPE_EX_CF_A	13	/* execute conforming accessed	   */
-#define	GDT_TYPE_EX_RO_CF	14	/* execute read-only conforming	   */
-#define	GDT_TYPE_EX_RO_CF_A	15	/* execute r/o conforming accessed */
+#define GDT_TYPE_RO		0	/* read-only			   */
+#define GDT_TYPE_RO_A		1	/* read-only accessed		   */
+#define GDT_TYPE_RW		2	/* read-write			   */
+#define GDT_TYPE_RW_A		3	/* read-write accessed		   */
+#define GDT_TYPE_RO_DOWN	4	/* read-only expand-down	   */
+#define GDT_TYPE_RO_DOWN_A	5	/* read-only expand-down accessed  */
+#define GDT_TYPE_RW_DOWN	6	/* read-write expand-down	   */
+#define GDT_TYPE_RW_DOWN_A	7	/* read-write expand-down accessed */
+#define GDT_TYPE_EX		8	/* execute			   */
+#define GDT_TYPE_EX_A		9	/* execute accessed		   */
+#define GDT_TYPE_EX_RO		10	/* execute read-only		   */
+#define GDT_TYPE_EX_RO_A	11	/* execute read-only accessed	   */
+#define GDT_TYPE_EX_CF		12	/* execute conforming		   */
+#define GDT_TYPE_EX_CF_A	13	/* execute conforming accessed	   */
+#define GDT_TYPE_EX_RO_CF	14	/* execute read-only conforming	   */
+#define GDT_TYPE_EX_RO_CF_A	15	/* execute r/o conforming accessed */
 
 /* GDT system segment types */
 
-#ifndef	LP64
-#define	GDT_TYPE_SYS_RES0	0	/* reserved			   */
-#define	GDT_TYPE_SYS_TSS16_A	1	/* 16-bit TSS (available)	   */
-#define	GDT_TYPE_SYS_LDT	2	/* local descriptor table	   */
-#define	GDT_TYPE_SYS_TSS16_B	3	/* 16-bit TSS (busy)		   */
-#define	GDT_TYPE_SYS_CALL16	4	/* 16-bit call gate		   */
-#define	GDT_TYPE_SYS_TGATE	5	/* task gate			   */
-#define	GDT_TYPE_SYS_IGATE16	6	/* 16-bit interrupt gate	   */
-#define	GDT_TYPE_SYS_TGATE16	7	/* 16-bit trap gate		   */
-#define	GDT_TYPE_SYS_RES1	8	/* reserved			   */
-#define	GDT_TYPE_SYS_TSS32_A	9	/* 32-bit TSS (available)	   */
-#define	GDT_TYPE_SYS_RES2	10	/* reserved			   */
-#define	GDT_TYPE_SYS_TSS32_B	11	/* 32-bit TSS (busy)		   */
-#define	GDT_TYPE_SYS_CALL32	12	/* 32-bit call gate		   */
-#define	GDT_TYPE_SYS_RES3	13	/* reserved			   */
-#define	GDT_TYPE_SYS_IGATE32	14	/* 32-bit interrupt gate	   */
-#define	GDT_TYPE_SYS_TGATE32	15	/* 32-bit trap gate		   */
+#ifndef LP64
+#define GDT_TYPE_SYS_RES0	0	/* reserved			   */
+#define GDT_TYPE_SYS_TSS16_A	1	/* 16-bit TSS (available)	   */
+#define GDT_TYPE_SYS_LDT	2	/* local descriptor table	   */
+#define GDT_TYPE_SYS_TSS16_B	3	/* 16-bit TSS (busy)		   */
+#define GDT_TYPE_SYS_CALL16	4	/* 16-bit call gate		   */
+#define GDT_TYPE_SYS_TGATE	5	/* task gate			   */
+#define GDT_TYPE_SYS_IGATE16	6	/* 16-bit interrupt gate	   */
+#define GDT_TYPE_SYS_TGATE16	7	/* 16-bit trap gate		   */
+#define GDT_TYPE_SYS_RES1	8	/* reserved			   */
+#define GDT_TYPE_SYS_TSS32_A	9	/* 32-bit TSS (available)	   */
+#define GDT_TYPE_SYS_RES2	10	/* reserved			   */
+#define GDT_TYPE_SYS_TSS32_B	11	/* 32-bit TSS (busy)		   */
+#define GDT_TYPE_SYS_CALL32	12	/* 32-bit call gate		   */
+#define GDT_TYPE_SYS_RES3	13	/* reserved			   */
+#define GDT_TYPE_SYS_IGATE32	14	/* 32-bit interrupt gate	   */
+#define GDT_TYPE_SYS_TGATE32	15	/* 32-bit trap gate		   */
 #else	/* !LP64 */
-#define	GDT32_TYPE_SYS_TSS16_A	1	/* 16-bit TSS (available)	   */
-#define	GDT32_TYPE_SYS_LDT	2	/* local descriptor table	   */
-#define	GDT32_TYPE_SYS_TSS16_B	3	/* 16-bit TSS (busy)		   */
-#define	GDT32_TYPE_SYS_CALL16	4	/* 16-bit call gate		   */
-#define	GDT32_TYPE_SYS_TGATE	5	/* task gate			   */
-#define	GDT32_TYPE_SYS_IGATE16	6	/* 16-bit interrupt gate	   */
-#define	GDT32_TYPE_SYS_TGATE16	7	/* 16-bit trap gate		   */
-#define	GDT32_TYPE_SYS_TSS32_A	9	/* 32-bit TSS (available)	   */
-#define	GDT32_TYPE_SYS_TSS32_B	11	/* 32-bit TSS (busy)		   */
-#define	GDT32_TYPE_SYS_CALL32	12	/* 32-bit call gate		   */
-#define	GDT32_TYPE_SYS_IGATE32	14	/* 32-bit interrupt gate	   */
-#define	GDT32_TYPE_SYS_TGATE32	15	/* 32-bit trap gate		   */
+#define GDT32_TYPE_SYS_TSS16_A	1	/* 16-bit TSS (available)	   */
+#define GDT32_TYPE_SYS_LDT	2	/* local descriptor table	   */
+#define GDT32_TYPE_SYS_TSS16_B	3	/* 16-bit TSS (busy)		   */
+#define GDT32_TYPE_SYS_CALL16	4	/* 16-bit call gate		   */
+#define GDT32_TYPE_SYS_TGATE	5	/* task gate			   */
+#define GDT32_TYPE_SYS_IGATE16	6	/* 16-bit interrupt gate	   */
+#define GDT32_TYPE_SYS_TGATE16	7	/* 16-bit trap gate		   */
+#define GDT32_TYPE_SYS_TSS32_A	9	/* 32-bit TSS (available)	   */
+#define GDT32_TYPE_SYS_TSS32_B	11	/* 32-bit TSS (busy)		   */
+#define GDT32_TYPE_SYS_CALL32	12	/* 32-bit call gate		   */
+#define GDT32_TYPE_SYS_IGATE32	14	/* 32-bit interrupt gate	   */
+#define GDT32_TYPE_SYS_TGATE32	15	/* 32-bit trap gate		   */
 
 #define GDT_TYPE_SYS_LDT	2	/* local descriptor table	   */
 #define GDT_TYPE_SYS_TSS64_A	9	/* 64 bit TSS (available)	   */
 #define GDT_TYPE_SYS_TSS64_B	11	/* 64 bit TSS (busy)	           */
-#define	GDT_TYPE_SYS_CALL64	12	/* 64-bit call gate		   */
-#define	GDT_TYPE_SYS_IGATE64	14	/* 64-bit interrupt gate	   */
-#define	GDT_TYPE_SYS_TGATE63	15	/* 64-bit trap gate		   */
+#define GDT_TYPE_SYS_CALL64	12	/* 64-bit call gate		   */
+#define GDT_TYPE_SYS_IGATE64	14	/* 64-bit interrupt gate	   */
+#define GDT_TYPE_SYS_TGATE63	15	/* 64-bit trap gate		   */
 #endif	/* !LP64 */
 /* GDT segment status */
 
-#define	GDT_SEG_INVALID		0	/* segment is not present	   */
-#define	GDT_SEG_VALID		1	/* segment is present		   */
+#define GDT_SEG_INVALID		0	/* segment is not present	   */
+#define GDT_SEG_VALID		1	/* segment is present		   */
 
 /* GDT segment type */
 
-#define	GDT_SEG_SYSTEM		0	/* system type segment		   */
-#define	GDT_SEG_CODE_DATA	1	/* code/data type segment	   */
+#define GDT_SEG_SYSTEM		0	/* system type segment		   */
+#define GDT_SEG_CODE_DATA	1	/* code/data type segment	   */
 
 /* GDT access types */
 
-#define	GDT_ACCESS_16		0	/* 16-bit access to memory	   */
-#define	GDT_ACCESS_32		1	/* 32-bit access to memory	   */
+#define GDT_ACCESS_16		0	/* 16-bit access to memory	   */
+#define GDT_ACCESS_32		1	/* 32-bit access to memory	   */
 
 /* GDT access types */
 
-#define	GDT_GRAN_BYTE		0	/* byte size page granularity	   */
-#define	GDT_GRAN_4KB_PAGE	1	/* 4KB size page granularity	   */
+#define GDT_GRAN_BYTE		0	/* byte size page granularity	   */
+#define GDT_GRAN_4KB_PAGE	1	/* 4KB size page granularity	   */
 
 /* GDT access types */
 
@@ -666,56 +667,56 @@ typedef struct idt64_entry
 
 /* GDT privilidge level */
 
-#define	GDT_PRIV_RING_0		0	/* ring 0 priv level		   */
-#define	GDT_PRIV_RING_1		1	/* ring 1 priv level		   */
-#define	GDT_PRIV_RING_2		2	/* ring 2 priv level		   */
-#define	GDT_PRIV_RING_3		3	/* ring 3 priv level		   */
+#define GDT_PRIV_RING_0		0	/* ring 0 priv level		   */
+#define GDT_PRIV_RING_1		1	/* ring 1 priv level		   */
+#define GDT_PRIV_RING_2		2	/* ring 2 priv level		   */
+#define GDT_PRIV_RING_3		3	/* ring 3 priv level		   */
 
 /* IDT segment types */
 
-#define	IDT_TYPE_RES0		0	/* reserved			   */
-#define	IDT_TYPE_RES1		1	/* reserved			   */
-#define	IDT_TYPE_RES2		2	/* reserved			   */
-#define	IDT_TYPE_RES3		3	/* reserved			   */
-#define	IDT_TYPE_RES4		4	/* reserved			   */
-#define	IDT_TYPE_TGATE		5	/* task gate			   */
-#define	IDT_TYPE_IGATE_16	6	/* 16-bit interrupt gate	   */
-#define	IDT_TYPE_TRGATE_16	7	/* 16-bit trap gate		   */
-#define	IDT_TYPE_RES8		8	/* reserved			   */
-#define	IDT_TYPE_RES9		9	/* reserved			   */
-#define	IDT_TYPE_RES10		10	/* reserved			   */
-#define	IDT_TYPE_RES11		11	/* reserved			   */
-#define	IDT_TYPE_RES12		12	/* reserved			   */
-#define	IDT_TYPE_RES13		13	/* reserved			   */
-#define	IDT_TYPE_IGATE		14	/* 32-bit interrupt gate	   */
-#define	IDT_TYPE_TRGATE		15	/* 32-bit trap gate		   */
+#define IDT_TYPE_RES0		0	/* reserved			   */
+#define IDT_TYPE_RES1		1	/* reserved			   */
+#define IDT_TYPE_RES2		2	/* reserved			   */
+#define IDT_TYPE_RES3		3	/* reserved			   */
+#define IDT_TYPE_RES4		4	/* reserved			   */
+#define IDT_TYPE_TGATE		5	/* task gate			   */
+#define IDT_TYPE_IGATE_16	6	/* 16-bit interrupt gate	   */
+#define IDT_TYPE_TRGATE_16	7	/* 16-bit trap gate		   */
+#define IDT_TYPE_RES8		8	/* reserved			   */
+#define IDT_TYPE_RES9		9	/* reserved			   */
+#define IDT_TYPE_RES10		10	/* reserved			   */
+#define IDT_TYPE_RES11		11	/* reserved			   */
+#define IDT_TYPE_RES12		12	/* reserved			   */
+#define IDT_TYPE_RES13		13	/* reserved			   */
+#define IDT_TYPE_IGATE		14	/* 32-bit interrupt gate	   */
+#define IDT_TYPE_TRGATE		15	/* 32-bit trap gate		   */
 
 /* IDT segment status */
 
-#define	IDT_SEG_INVALID		0	/* segment is not present	   */
-#define	IDT_SEG_VALID		1	/* segment is present		   */
+#define IDT_SEG_INVALID		0	/* segment is not present	   */
+#define IDT_SEG_VALID		1	/* segment is present		   */
 
 /* IDT segment type */
 
-#define	IDT_SEG_SYSTEM		0	/* system type segment		   */
-#define	IDT_SEG_CODE_DATA	1	/* code/data type segment	   */
+#define IDT_SEG_SYSTEM		0	/* system type segment		   */
+#define IDT_SEG_CODE_DATA	1	/* code/data type segment	   */
 
 /* IDT access types */
 
-#define	IDT_ACCESS_16		0	/* 16-bit access to memory	   */
-#define	IDT_ACCESS_32		1	/* 32-bit access to memory	   */
+#define IDT_ACCESS_16		0	/* 16-bit access to memory	   */
+#define IDT_ACCESS_32		1	/* 32-bit access to memory	   */
 
 /* IDT access types */
 
-#define	IDT_GRAN_BYTE		0	/* byte size page granularity	   */
-#define	IDT_GRAN_4KB_PAGE	1	/* 4KB size page granularity	   */
+#define IDT_GRAN_BYTE		0	/* byte size page granularity	   */
+#define IDT_GRAN_4KB_PAGE	1	/* 4KB size page granularity	   */
 
 /* IDT privilidge level */
 
-#define	IDT_PRIV_RING_0		0	/* ring 0 priv level		   */
-#define	IDT_PRIV_RING_1		1	/* ring 2 priv level		   */
-#define	IDT_PRIV_RING_2		2	/* ring 2 priv level		   */
-#define	IDT_PRIV_RING_3		3	/* ring 3 priv level		   */
+#define IDT_PRIV_RING_0		0	/* ring 0 priv level		   */
+#define IDT_PRIV_RING_1		1	/* ring 2 priv level		   */
+#define IDT_PRIV_RING_2		2	/* ring 2 priv level		   */
+#define IDT_PRIV_RING_3		3	/* ring 3 priv level		   */
 
 /* structure of the global descriptor table register (GDTR) */
 
@@ -734,14 +735,14 @@ typedef union
 	} words;
     } GDTR32;
 
-#define	GDTR32_ADDR00_SHIFT	00
-#define	GDTR32_ADDR01_SHIFT	16
-#define	GDTR32_ADDR00_MASK	0x0000ffff
-#define	GDTR32_ADDR01_MASK	0xffff0000
+#define GDTR32_ADDR00_SHIFT	00
+#define GDTR32_ADDR01_SHIFT	16
+#define GDTR32_ADDR00_MASK	0x0000ffff
+#define GDTR32_ADDR01_MASK	0xffff0000
 
-#define	GDTR32_ADDR(reg)	((reg.field.addr1 << GDTR32_ADDR01_SHIFT) | \
+#define GDTR32_ADDR(reg)	((reg.field.addr1 << GDTR32_ADDR01_SHIFT) | \
 				 reg.field.addr0)
-#define	GDTR32_LIMIT(reg)	(reg.field.limit)
+#define GDTR32_LIMIT(reg)	(reg.field.limit)
 
 #ifdef	LP64
 typedef union
@@ -761,43 +762,43 @@ typedef union
 	} words;
     } GDTR64;
 
-#define	GDTR64_ADDR00_SHIFT	00
-#define	GDTR64_ADDR01_SHIFT	16
-#define	GDTR64_ADDR02_SHIFT	32
-#define	GDTR64_ADDR03_SHIFT	48
-#define	GDTR64_ADDR00_MASK	0x000000000000ffff
-#define	GDTR64_ADDR01_MASK	0x00000000ffff0000
-#define	GDTR64_ADDR02_MASK	0x0000ffff00000000
-#define	GDTR64_ADDR03_MASK	0xffff000000000000
+#define GDTR64_ADDR00_SHIFT	00
+#define GDTR64_ADDR01_SHIFT	16
+#define GDTR64_ADDR02_SHIFT	32
+#define GDTR64_ADDR03_SHIFT	48
+#define GDTR64_ADDR00_MASK	0x000000000000ffff
+#define GDTR64_ADDR01_MASK	0x00000000ffff0000
+#define GDTR64_ADDR02_MASK	0x0000ffff00000000
+#define GDTR64_ADDR03_MASK	0xffff000000000000
 
-#define	GDTR64_ADDR(reg)	(((uint64_t)reg.field.addr1 << \
+#define GDTR64_ADDR(reg)	(((uint64_t)reg.field.addr1 << \
 					GDTR64_ADDR01_SHIFT) | \
 				 ((uint64_t)reg.field.addr2 << \
 					GDTR64_ADDR02_SHIFT) | \
 				 ((uint64_t)reg.field.addr3 << \
 					GDTR64_ADDR03_SHIFT) | \
 				 reg.field.addr0)
-#define	GDTR64_LIMIT(reg)	(reg.field.limit)
-
-#define	GDTR			GDTR64
-#define	GDTR_ADDR00_SHIFT	GDTR64_ADDR00_SHIFT
-#define	GDTR_ADDR01_SHIFT	GDTR64_ADDR01_SHIFT
-#define	GDTR_ADDR02_SHIFT	GDTR64_ADDR02_SHIFT
-#define	GDTR_ADDR03_SHIFT	GDTR64_ADDR03_SHIFT
-#define	GDTR_ADDR00_MASK	GDTR64_ADDR00_MASK
-#define	GDTR_ADDR01_MASK	GDTR64_ADDR01_MASK
-#define	GDTR_ADDR02_MASK	GDTR64_ADDR02_MASK
-#define	GDTR_ADDR03_MASK	GDTR64_ADDR03_MASK
-#define	GDTR_ADDR		GDTR64_ADDR
-#define	GDTR_LIMIT		GDTR64_LIMIT
+#define GDTR64_LIMIT(reg)	(reg.field.limit)
+
+#define GDTR			GDTR64
+#define GDTR_ADDR00_SHIFT	GDTR64_ADDR00_SHIFT
+#define GDTR_ADDR01_SHIFT	GDTR64_ADDR01_SHIFT
+#define GDTR_ADDR02_SHIFT	GDTR64_ADDR02_SHIFT
+#define GDTR_ADDR03_SHIFT	GDTR64_ADDR03_SHIFT
+#define GDTR_ADDR00_MASK	GDTR64_ADDR00_MASK
+#define GDTR_ADDR01_MASK	GDTR64_ADDR01_MASK
+#define GDTR_ADDR02_MASK	GDTR64_ADDR02_MASK
+#define GDTR_ADDR03_MASK	GDTR64_ADDR03_MASK
+#define GDTR_ADDR		GDTR64_ADDR
+#define GDTR_LIMIT		GDTR64_LIMIT
 #else	/* LP64 */
-#define	GDTR			GDTR32
-#define	GDTR_ADDR00_SHIFT	GDTR32_ADDR00_SHIFT
-#define	GDTR_ADDR01_SHIFT	GDTR32_ADDR01_SHIFT
-#define	GDTR_ADDR00_MASK	GDTR32_ADDR00_MASK
-#define	GDTR_ADDR01_MASK	GDTR32_ADDR01_MASK
-#define	GDTR_ADDR		GDTR32_ADDR
-#define	GDTR_LIMIT		GDTR32_LIMIT
+#define GDTR			GDTR32
+#define GDTR_ADDR00_SHIFT	GDTR32_ADDR00_SHIFT
+#define GDTR_ADDR01_SHIFT	GDTR32_ADDR01_SHIFT
+#define GDTR_ADDR00_MASK	GDTR32_ADDR00_MASK
+#define GDTR_ADDR01_MASK	GDTR32_ADDR01_MASK
+#define GDTR_ADDR		GDTR32_ADDR
+#define GDTR_LIMIT		GDTR32_LIMIT
 #endif	/* LP64 */
 
 /* structure of the interrupt descriptor table register (IDTR) */
@@ -817,14 +818,14 @@ typedef union
 	} words;
     } IDTR32;
 
-#define	IDTR32_ADDR00_SHIFT	00
-#define	IDTR32_ADDR01_SHIFT	16
-#define	IDTR32_ADDR00_MASK	0x0000ffff
-#define	IDTR32_ADDR01_MASK	0xffff0000
+#define IDTR32_ADDR00_SHIFT	00
+#define IDTR32_ADDR01_SHIFT	16
+#define IDTR32_ADDR00_MASK	0x0000ffff
+#define IDTR32_ADDR01_MASK	0xffff0000
 
-#define	IDTR32_ADDR(reg)	((reg.field.addr1 << IDTR32_ADDR01_SHIFT) | \
+#define IDTR32_ADDR(reg)	((reg.field.addr1 << IDTR32_ADDR01_SHIFT) | \
 				 reg.field.addr0)
-#define	IDTR32_LIMIT(reg)	(reg.field.limit)
+#define IDTR32_LIMIT(reg)	(reg.field.limit)
 
 #ifdef	LP64
 typedef union
@@ -844,43 +845,43 @@ typedef union
 	} words;
     } IDTR64;
 
-#define	IDTR64_ADDR00_SHIFT	00
-#define	IDTR64_ADDR01_SHIFT	16
-#define	IDTR64_ADDR02_SHIFT	32
-#define	IDTR64_ADDR03_SHIFT	48
-#define	IDTR64_ADDR00_MASK	0x000000000000ffff
-#define	IDTR64_ADDR01_MASK	0x00000000ffff0000
-#define	IDTR64_ADDR02_MASK	0x0000ffff00000000
-#define	IDTR64_ADDR03_MASK	0xffff000000000000
+#define IDTR64_ADDR00_SHIFT	00
+#define IDTR64_ADDR01_SHIFT	16
+#define IDTR64_ADDR02_SHIFT	32
+#define IDTR64_ADDR03_SHIFT	48
+#define IDTR64_ADDR00_MASK	0x000000000000ffff
+#define IDTR64_ADDR01_MASK	0x00000000ffff0000
+#define IDTR64_ADDR02_MASK	0x0000ffff00000000
+#define IDTR64_ADDR03_MASK	0xffff000000000000
 
-#define	IDTR64_ADDR(reg)	(((uint64_t)reg.field.addr1 << \
+#define IDTR64_ADDR(reg)	(((uint64_t)reg.field.addr1 << \
 					IDTR64_ADDR01_SHIFT) | \
 				 ((uint64_t)reg.field.addr2 << \
 					IDTR64_ADDR02_SHIFT) | \
 				 ((uint64_t)reg.field.addr3 << \
 					IDTR64_ADDR03_SHIFT) | \
 				 reg.field.addr0)
-#define	IDTR64_LIMIT(reg)	(reg.field.limit)
-
-#define	IDTR			IDTR64
-#define	IDTR_ADDR00_SHIFT	IDTR64_ADDR00_SHIFT
-#define	IDTR_ADDR01_SHIFT	IDTR64_ADDR01_SHIFT
-#define	IDTR_ADDR02_SHIFT	IDTR64_ADDR02_SHIFT
-#define	IDTR_ADDR03_SHIFT	IDTR64_ADDR03_SHIFT
-#define	IDTR_ADDR00_MASK	IDTR64_ADDR00_MASK
-#define	IDTR_ADDR01_MASK	IDTR64_ADDR01_MASK
-#define	IDTR_ADDR02_MASK	IDTR64_ADDR02_MASK
-#define	IDTR_ADDR03_MASK	IDTR64_ADDR03_MASK
-#define	IDTR_ADDR		IDTR64_ADDR
-#define	IDTR_LIMIT		IDTR64_LIMIT
+#define IDTR64_LIMIT(reg)	(reg.field.limit)
+
+#define IDTR			IDTR64
+#define IDTR_ADDR00_SHIFT	IDTR64_ADDR00_SHIFT
+#define IDTR_ADDR01_SHIFT	IDTR64_ADDR01_SHIFT
+#define IDTR_ADDR02_SHIFT	IDTR64_ADDR02_SHIFT
+#define IDTR_ADDR03_SHIFT	IDTR64_ADDR03_SHIFT
+#define IDTR_ADDR00_MASK	IDTR64_ADDR00_MASK
+#define IDTR_ADDR01_MASK	IDTR64_ADDR01_MASK
+#define IDTR_ADDR02_MASK	IDTR64_ADDR02_MASK
+#define IDTR_ADDR03_MASK	IDTR64_ADDR03_MASK
+#define IDTR_ADDR		IDTR64_ADDR
+#define IDTR_LIMIT		IDTR64_LIMIT
 #else	/* LP64 */
-#define	IDTR			IDTR32
-#define	IDTR_ADDR00_SHIFT	IDTR32_ADDR00_SHIFT
-#define	IDTR_ADDR01_SHIFT	IDTR32_ADDR01_SHIFT
-#define	IDTR_ADDR00_MASK	IDTR32_ADDR00_MASK
-#define	IDTR_ADDR01_MASK	IDTR32_ADDR01_MASK
-#define	IDTR_ADDR		IDTR32_ADDR
-#define	IDTR_LIMIT		IDTR32_LIMIT
+#define IDTR			IDTR32
+#define IDTR_ADDR00_SHIFT	IDTR32_ADDR00_SHIFT
+#define IDTR_ADDR01_SHIFT	IDTR32_ADDR01_SHIFT
+#define IDTR_ADDR00_MASK	IDTR32_ADDR00_MASK
+#define IDTR_ADDR01_MASK	IDTR32_ADDR01_MASK
+#define IDTR_ADDR		IDTR32_ADDR
+#define IDTR_LIMIT		IDTR32_LIMIT
 #endif	/* LP64 */
 
 /* structure of the local descriptor table register (LDTR) */
@@ -1001,9 +1002,9 @@ typedef struct intGate		/* interrupt gate */
     uint16_t    offsetHi;	/* offset 31:16			*/
     } IGATE_DESC;
 
-#define	IGATE_OFFSET00_SHIFT	00
-#define	IGATE_OFFSET01_SHIFT	16
-#define	IGATE_OFFSET(p)	((p->offsetHi << IGATE_OFFSET01_SHIFT) | p->offsetLo)
+#define IGATE_OFFSET00_SHIFT	00
+#define IGATE_OFFSET01_SHIFT	16
+#define IGATE_OFFSET(p)	((p->offsetHi << IGATE_OFFSET01_SHIFT) | p->offsetLo)
 
 
 typedef struct trapGate		/* trap gate */
@@ -1018,9 +1019,9 @@ typedef struct trapGate		/* trap gate */
     uint16_t    offsetHi;	/* offset 31:16			*/
     } TRGATE_DESC;
 
-#define	TRGATE_OFFSET00_SHIFT	00
-#define	TRGATE_OFFSET01_SHIFT	16
-#define	TRGATE_OFFSET(p) ((p->offsetHi << TRGATE_OFFSET01_SHIFT) | p->offsetLo)
+#define TRGATE_OFFSET00_SHIFT	00
+#define TRGATE_OFFSET01_SHIFT	16
+#define TRGATE_OFFSET(p) ((p->offsetHi << TRGATE_OFFSET01_SHIFT) | p->offsetLo)
 
 /* convenience structure to access 32-bit fields of a 64-bit MSR */
 
@@ -1037,7 +1038,7 @@ typedef union
 /* some common names for registers */
 
 #define fpReg		ebp	/* frame pointer */
-#define	spReg		esp	/* stack pointer */
+#define spReg		esp	/* stack pointer */
 #define reg_pc		pc	/* program counter */
 #define reg_sp		spReg	/* stack pointer */
 #define reg_fp		fpReg	/* frame pointer */
@@ -1150,26 +1151,26 @@ extern void	x86GetCpuid (uint32_t operation,
 
 /* bits on EFLAGS */
 
-#define	EFLAGS_EMPTY	0x00000020	/* empty eflags */
-#define	EFLAGS_BRANDNEW	0x00000200	/* brand new EFLAGS */
-#define	EFLAGS_N_MASK	0xffffbfff	/* N(nested task flag) bit mask */
-#define	EFLAGS_TF_MASK	0xfffffeff	/* TF(trap flag) bit mask */
-
-#define	EFLAGS_CF	0x00000001	/* CF(carry flag) bit */
-#define	EFLAGS_PF	0x00000004	/* PF(parity flag) bit */
-#define	EFLAGS_AF	0x00000010	/* AF(borrow flag) bit */
-#define	EFLAGS_ZF	0x00000040	/* ZF(sero flag) bit */
-#define	EFLAGS_SF	0x00000080	/* AF(sign flag) bit */
-#define	EFLAGS_TF	0x00000100	/* TF(trap flag) bit */
-#define	EFLAGS_IF	0x00000200	/* IF(interrupt enable flag) bit */
-#define	EFLAGS_IOPL	0x00003000	/* IOPL(IO privilege level) bits */
-#define	EFLAGS_NT	0x00004000	/* NT(nested task flag) bit */
-#define	EFLAGS_RF	0x00010000	/* RF(resume flag) bit */
-#define	EFLAGS_VM	0x00020000	/* VM(virtual 8086 mode) bit */
-#define	EFLAGS_AC	0x00040000	/* AC(alignment check) bit */
-#define	EFLAGS_VIF	0x00080000	/* VIF(virtual int flag) bit */
-#define	EFLAGS_VIP	0x00100000	/* VIP(virtual int pending) bit */
-#define	EFLAGS_ID	0x00200000	/* ID(identification flag) bit */
+#define EFLAGS_EMPTY	0x00000020	/* empty eflags */
+#define EFLAGS_BRANDNEW	0x00000200	/* brand new EFLAGS */
+#define EFLAGS_N_MASK	0xffffbfff	/* N(nested task flag) bit mask */
+#define EFLAGS_TF_MASK	0xfffffeff	/* TF(trap flag) bit mask */
+
+#define EFLAGS_CF	0x00000001	/* CF(carry flag) bit */
+#define EFLAGS_PF	0x00000004	/* PF(parity flag) bit */
+#define EFLAGS_AF	0x00000010	/* AF(borrow flag) bit */
+#define EFLAGS_ZF	0x00000040	/* ZF(zero flag) bit */
+#define EFLAGS_SF	0x00000080	/* AF(sign flag) bit */
+#define EFLAGS_TF	0x00000100	/* TF(trap flag) bit */
+#define EFLAGS_IF	0x00000200	/* IF(interrupt enable flag) bit */
+#define EFLAGS_IOPL	0x00003000	/* IOPL(IO privilege level) bits */
+#define EFLAGS_NT	0x00004000	/* NT(nested task flag) bit */
+#define EFLAGS_RF	0x00010000	/* RF(resume flag) bit */
+#define EFLAGS_VM	0x00020000	/* VM(virtual 8086 mode) bit */
+#define EFLAGS_AC	0x00040000	/* AC(alignment check) bit */
+#define EFLAGS_VIF	0x00080000	/* VIF(virtual int flag) bit */
+#define EFLAGS_VIP	0x00100000	/* VIP(virtual int pending) bit */
+#define EFLAGS_ID	0x00200000	/* ID(identification flag) bit */
 
 /* control and test registers */
 
@@ -1310,35 +1311,35 @@ extern void	x86GetCpuid (uint32_t operation,
 
 /* MSR_VMX_EPT_VPID_CAP: EOT abd VPID capabilities */
 
-#define	EPT_VPID_RWX_X_ONLY	0	/* execute only supported */
-#define	EPT_VPID_RWX_W_ONLY	1	/* write only supported */
-#define	EPT_VPID_RWX_XW_ONLY	2	/* execute and write supported */
+#define EPT_VPID_RWX_X_ONLY	0	/* execute only supported */
+#define EPT_VPID_RWX_W_ONLY	1	/* write only supported */
+#define EPT_VPID_RWX_XW_ONLY	2	/* execute and write supported */
 
-#define	EPT_VPID_GAW_21BITS	0x01	/* guest address width: 21-bits */
-#define	EPT_VPID_GAW_30BITS	0x02	/* guest address width: 30-bits */
-#define	EPT_VPID_GAW_39BITS	0x04	/* guest address width: 39-bits */
-#define	EPT_VPID_GAW_48BITS	0x08	/* guest address width: 48-bits */
-#define	EPT_VPID_GAW_57BITS	0x10	/* guest address width: 57-bits */
+#define EPT_VPID_GAW_21BITS	0x01	/* guest address width: 21-bits */
+#define EPT_VPID_GAW_30BITS	0x02	/* guest address width: 30-bits */
+#define EPT_VPID_GAW_39BITS	0x04	/* guest address width: 39-bits */
+#define EPT_VPID_GAW_48BITS	0x08	/* guest address width: 48-bits */
+#define EPT_VPID_GAW_57BITS	0x10	/* guest address width: 57-bits */
 
-#define	EPT_VPID_EMT_UC		0x01	/* EMT memory: uncached memory */
-#define	EPT_VPID_EMT_WC		0x02	/* EMT memory: write cache memory */
-#define	EPT_VPID_EMT_WT		0x10	/* EMT memory: write through memory */
-#define	EPT_VPID_EMT_WP		0x20	/* EMT memory: write protect memory */
-#define	EPT_VPID_EMT_WB		0x40	/* EMT memory: write back memory */
+#define EPT_VPID_EMT_UC		0x01	/* EMT memory: uncached memory */
+#define EPT_VPID_EMT_WC		0x02	/* EMT memory: write cache memory */
+#define EPT_VPID_EMT_WT		0x10	/* EMT memory: write through memory */
+#define EPT_VPID_EMT_WP		0x20	/* EMT memory: write protect memory */
+#define EPT_VPID_EMT_WB		0x40	/* EMT memory: write back memory */
 
-#define	EPT_VPID_INVEPT_INDV	0x01	/* individual address sync */
-#define	EPT_VPID_INVEPT_CTX	0x02	/* context sync */
-#define	EPT_VPID_INVEPT_GLOBAL	0x08	/* global sync */
+#define EPT_VPID_INVEPT_INDV	0x01	/* individual address sync */
+#define EPT_VPID_INVEPT_CTX	0x02	/* context sync */
+#define EPT_VPID_INVEPT_GLOBAL	0x08	/* global sync */
 
-#define	EPT_VPID_INVVPID_INDV	0x01	/* individual address sync */
-#define	EPT_VPID_INVVPID_CTX_1	0x02	/* single-context sync */
-#define	EPT_VPID_INVVPID_CTX_A	0x08	/* all context sync */
-#define	EPT_VPID_INVVPID_CTX_G	0x20	/* single context sync, keep global */
+#define EPT_VPID_INVVPID_INDV	0x01	/* individual address sync */
+#define EPT_VPID_INVVPID_CTX_1	0x02	/* single-context sync */
+#define EPT_VPID_INVVPID_CTX_A	0x08	/* all context sync */
+#define EPT_VPID_INVVPID_CTX_G	0x20	/* single context sync, keep global */
 
-#define	EPT_VPID_SP_2MB		0x01	/* super page support: 2MB */
-#define	EPT_VPID_SP_1GB		0x02	/* super page support: 1GB */
-#define	EPT_VPID_SP_512GB	0x04	/* super page support: 512GB */
-#define	EPT_VPID_SP_256TB	0x08	/* super page support: 256TB */
+#define EPT_VPID_SP_2MB		0x01	/* super page support: 2MB */
+#define EPT_VPID_SP_1GB		0x02	/* super page support: 1GB */
+#define EPT_VPID_SP_512GB	0x04	/* super page support: 512GB */
+#define EPT_VPID_SP_256TB	0x08	/* super page support: 256TB */
 
 /* MSR, Model Specific Registers */
 
@@ -1435,18 +1436,18 @@ extern void	x86GetCpuid (uint32_t operation,
 
 /* MSR, Core2 */
 
-#define	MSR_FSB_FREQ		0x00cd
+#define MSR_FSB_FREQ		0x00cd
 
 /* MSR, Nehalem */
 
-#define	MSR_PLATFORM_INFO	0x00ce
+#define MSR_PLATFORM_INFO	0x00ce
 #define MSR_FLEX_RATIO		0x0194
 #define MSR_CORE_THREAD_COUNT	0x0035
 
 /* MSR, VMX specific */
 
-#define	MSR_VMX_FEATURE			0x003A
-#define	MSR_VMX_BASIC			0x0480
+#define MSR_VMX_FEATURE			0x003A
+#define MSR_VMX_BASIC			0x0480
 #define MSR_VMX_PINBASED_CTLS_MSR	0x0481
 #define MSR_VMX_PROCBASED_CTLS_MSR	0x0482
 #define MSR_VMX_EXIT_CTLS_MSR		0x0483
@@ -1456,165 +1457,168 @@ extern void	x86GetCpuid (uint32_t operation,
 #define MSR_VMX_CR0_FIXED1		0x0487
 #define MSR_VMX_CR4_FIXED0		0x0488
 #define MSR_VMX_CR4_FIXED1		0x0489
+#define MSR_VMX_VMCS_ENUM		0x048A
 #define MSR_VMX_PROCBASED_CTLS2_MSR	0x048B
 #define MSR_VMX_EPT_VPID_CAP		0x048C
 
 /* MSR, Architectural MSRs (common MSRs in IA32) */
 
-#define	IA32_P5_MC_ADDR		MSR_P5_MC_ADDR		/* P5 */
-#define	IA32_P5_MC_TYPE		MSR_P5_MC_TYPE		/* P5 */
-#define	IA32_TIME_STAMP_COUNTER	MSR_TSC			/* P5 */
-#define	IA32_PLATFORM_ID	0x0017			/* P6 */
-#define	IA32_APIC_BASE		MSR_APICBASE		/* P6 */
-#define	IA32_BIOS_UPDT_TRIG	MSR_BIOS_UPDT_TRIG	/* P6 */
-#define	IA32_BIOS_SIGN_ID	MSR_BIOS_SIGN		/* P6 */
-#define	IA32_MTRRCAP		MSR_MTRR_CAP		/* P6 */
-#define	IA32_MISC_CTL		MSR_BBL_CR_CTL		/* P6 */
-#define	IA32_SYSENTER_CS	MSR_SYSENTER_CS		/* P6 */
-#define	IA32_SYSENTER_ESP	MSR_SYSENTER_ESP	/* P6 */
-#define	IA32_SYSENTER_EIP	MSR_SYSENTER_EIP	/* P6 */
-#define	IA32_MCG_CAP		MSR_MCG_CAP		/* P6 */
-#define	IA32_MCG_STATUS		MSR_MCG_STATUS		/* P6 */
-#define	IA32_MCG_CTL		MSR_MCG_CTL		/* P6 */
-#define	IA32_MCG_EAX		0x0180			/* Pentium4 */
-#define	IA32_MCG_EBX		0x0181			/* Pentium4 */
-#define	IA32_MCG_ECX		0x0182			/* Pentium4 */
-#define	IA32_MCG_EDX		0x0183			/* Pentium4 */
-#define	IA32_MCG_ESI		0x0184			/* Pentium4 */
-#define	IA32_MCG_EDI		0x0185			/* Pentium4 */
-#define	IA32_MCG_EBP		0x0186			/* Pentium4 */
-#define	IA32_MCG_ESP		0x0187			/* Pentium4 */
-#define	IA32_MCG_EFLAGS		0x0188			/* Pentium4 */
-#define	IA32_MCG_EIP		0x0189			/* Pentium4 */
-#define	IA32_MCG_MISC		0x018a			/* Pentium4 */
-#define	IA32_THERM_CONTROL	0x019a			/* Pentium4 */
-#define	IA32_THERM_INTERRUPT	0x019b			/* Pentium4 */
-#define	IA32_THERM_STATUS	0x019c			/* Pentium4 */
-#define	IA32_MISC_ENABLE	0x01a0			/* Pentium4 */
-#define	IA32_DEBUGCTL		MSR_DEBUGCTLMSR		/* P6 */
-#define	IA32_MTRR_PHYSBASE0	MSR_MTRR_PHYS_BASE0	/* P6 */
-#define	IA32_MTRR_PHYSMASK0	MSR_MTRR_PHYS_MASK0	/* P6 */
-#define	IA32_MTRR_PHYSBASE1	MSR_MTRR_PHYS_BASE1	/* P6 */
-#define	IA32_MTRR_PHYSMASK1	MSR_MTRR_PHYS_MASK1	/* P6 */
-#define	IA32_MTRR_PHYSBASE2	MSR_MTRR_PHYS_BASE2	/* P6 */
-#define	IA32_MTRR_PHYSMASK2	MSR_MTRR_PHYS_MASK2	/* P6 */
-#define	IA32_MTRR_PHYSBASE3	MSR_MTRR_PHYS_BASE3	/* P6 */
-#define	IA32_MTRR_PHYSMASK3	MSR_MTRR_PHYS_MASK3	/* P6 */
-#define	IA32_MTRR_PHYSBASE4	MSR_MTRR_PHYS_BASE4	/* P6 */
-#define	IA32_MTRR_PHYSMASK4	MSR_MTRR_PHYS_MASK4	/* P6 */
-#define	IA32_MTRR_PHYSBASE5	MSR_MTRR_PHYS_BASE5	/* P6 */
-#define	IA32_MTRR_PHYSMASK5	MSR_MTRR_PHYS_MASK5	/* P6 */
-#define	IA32_MTRR_PHYSBASE6	MSR_MTRR_PHYS_BASE6	/* P6 */
-#define	IA32_MTRR_PHYSMASK6	MSR_MTRR_PHYS_MASK6	/* P6 */
-#define	IA32_MTRR_PHYSBASE7	MSR_MTRR_PHYS_BASE7	/* P6 */
-#define	IA32_MTRR_PHYSMASK7	MSR_MTRR_PHYS_MASK7	/* P6 */
-#define	IA32_MTRR_FIX64K_00000	MSR_MTRR_FIX_00000	/* P6 */
-#define	IA32_MTRR_FIX16K_80000	MSR_MTRR_FIX_80000	/* P6 */
-#define	IA32_MTRR_FIX16K_A0000	MSR_MTRR_FIX_A0000	/* P6 */
-#define	IA32_MTRR_FIX4K_C0000	MSR_MTRR_FIX_C0000	/* P6 */
-#define	IA32_MTRR_FIX4K_C8000	MSR_MTRR_FIX_C8000	/* P6 */
-#define	IA32_MTRR_FIX4K_D0000	MSR_MTRR_FIX_D0000	/* P6 */
-#define	IA32_MTRR_FIX4K_D8000	MSR_MTRR_FIX_D8000	/* P6 */
-#define	IA32_MTRR_FIX4K_E0000	MSR_MTRR_FIX_E0000	/* P6 */
-#define	IA32_MTRR_FIX4K_E8000	MSR_MTRR_FIX_E8000	/* P6 */
-#define	IA32_MTRR_FIX4K_F0000	MSR_MTRR_FIX_F0000	/* P6 */
-#define	IA32_MTRR_FIX4K_F8000	MSR_MTRR_FIX_F8000	/* P6 */
-#define	IA32_CR_PAT		0x0277			/* P6 */
-#define	IA32_MTRR_DEF_TYPE	MSR_MTRR_DEFTYPE	/* P6 */
-#define	IA32_PEBS_ENABLE	0x03f1			/* Pentium4 */
-#define	IA32_MC0_CTL		MSR_MC0_CTL		/* P6 */
-#define	IA32_MC0_STATUS		MSR_MC0_STATUS		/* P6 */
-#define	IA32_MC0_ADDR		MSR_MC0_ADDR		/* P6 */
-#define	IA32_MC0_MISC		MSR_MC0_MISC		/* P6 */
-#define	IA32_MC1_CTL		MSR_MC1_CTL		/* P6 */
-#define	IA32_MC1_STATUS		MSR_MC1_STATUS		/* P6 */
-#define	IA32_MC1_ADDR		MSR_MC1_ADDR		/* P6 */
-#define	IA32_MC1_MISC		MSR_MC1_MISC		/* P6 */
-#define	IA32_MC2_CTL		MSR_MC2_CTL		/* P6 */
-#define	IA32_MC2_STATUS		MSR_MC2_STATUS		/* P6 */
-#define	IA32_MC2_ADDR		MSR_MC2_ADDR		/* P6 */
-#define	IA32_MC2_MISC		MSR_MC2_MISC		/* P6 */
-#define	IA32_MC3_CTL		0x040c			/* P6, addr changed */
-#define	IA32_MC3_STATUS		0x040d			/* P6, addr changed */
-#define	IA32_MC3_ADDR		0x040e			/* P6, addr changed */
-#define	IA32_MC3_MISC		0x040f			/* P6, addr changed */
-#define	IA32_DS_AREA		0x0600			/* Pentium4 */
-#define	IA32_PERF_STAT		0x0198			/* Core2 */
-#define	IA32_EFER		0xc0000080		/* Core2 - extended feature */
+#define IA32_P5_MC_ADDR		MSR_P5_MC_ADDR		/* P5 */
+#define IA32_P5_MC_TYPE		MSR_P5_MC_TYPE		/* P5 */
+#define IA32_TIME_STAMP_COUNTER	MSR_TSC			/* P5 */
+#define IA32_PLATFORM_ID	0x0017			/* P6 */
+#define IA32_APIC_BASE		MSR_APICBASE		/* P6 */
+#define IA32_BIOS_UPDT_TRIG	MSR_BIOS_UPDT_TRIG	/* P6 */
+#define IA32_BIOS_SIGN_ID	MSR_BIOS_SIGN		/* P6 */
+#define IA32_MTRRCAP		MSR_MTRR_CAP		/* P6 */
+#define IA32_MISC_CTL		MSR_BBL_CR_CTL		/* P6 */
+#define IA32_SYSENTER_CS	MSR_SYSENTER_CS		/* P6 */
+#define IA32_SYSENTER_ESP	MSR_SYSENTER_ESP	/* P6 */
+#define IA32_SYSENTER_EIP	MSR_SYSENTER_EIP	/* P6 */
+#define IA32_MCG_CAP		MSR_MCG_CAP		/* P6 */
+#define IA32_MCG_STATUS		MSR_MCG_STATUS		/* P6 */
+#define IA32_MCG_CTL		MSR_MCG_CTL		/* P6 */
+#define IA32_MCG_EAX		0x0180			/* Pentium4 */
+#define IA32_MCG_EBX		0x0181			/* Pentium4 */
+#define IA32_MCG_ECX		0x0182			/* Pentium4 */
+#define IA32_MCG_EDX		0x0183			/* Pentium4 */
+#define IA32_MCG_ESI		0x0184			/* Pentium4 */
+#define IA32_MCG_EDI		0x0185			/* Pentium4 */
+#define IA32_MCG_EBP		0x0186			/* Pentium4 */
+#define IA32_MCG_ESP		0x0187			/* Pentium4 */
+#define IA32_MCG_EFLAGS		0x0188			/* Pentium4 */
+#define IA32_MCG_EIP		0x0189			/* Pentium4 */
+#define IA32_MCG_MISC		0x018a			/* Pentium4 */
+#define IA32_THERM_CONTROL	0x019a			/* Pentium4 */
+#define IA32_THERM_INTERRUPT	0x019b			/* Pentium4 */
+#define IA32_THERM_STATUS	0x019c			/* Pentium4 */
+#define IA32_MISC_ENABLE	0x01a0			/* Pentium4 */
+#define IA32_DEBUGCTL		MSR_DEBUGCTLMSR		/* P6 */
+#define IA32_MTRR_PHYSBASE0	MSR_MTRR_PHYS_BASE0	/* P6 */
+#define IA32_MTRR_PHYSMASK0	MSR_MTRR_PHYS_MASK0	/* P6 */
+#define IA32_MTRR_PHYSBASE1	MSR_MTRR_PHYS_BASE1	/* P6 */
+#define IA32_MTRR_PHYSMASK1	MSR_MTRR_PHYS_MASK1	/* P6 */
+#define IA32_MTRR_PHYSBASE2	MSR_MTRR_PHYS_BASE2	/* P6 */
+#define IA32_MTRR_PHYSMASK2	MSR_MTRR_PHYS_MASK2	/* P6 */
+#define IA32_MTRR_PHYSBASE3	MSR_MTRR_PHYS_BASE3	/* P6 */
+#define IA32_MTRR_PHYSMASK3	MSR_MTRR_PHYS_MASK3	/* P6 */
+#define IA32_MTRR_PHYSBASE4	MSR_MTRR_PHYS_BASE4	/* P6 */
+#define IA32_MTRR_PHYSMASK4	MSR_MTRR_PHYS_MASK4	/* P6 */
+#define IA32_MTRR_PHYSBASE5	MSR_MTRR_PHYS_BASE5	/* P6 */
+#define IA32_MTRR_PHYSMASK5	MSR_MTRR_PHYS_MASK5	/* P6 */
+#define IA32_MTRR_PHYSBASE6	MSR_MTRR_PHYS_BASE6	/* P6 */
+#define IA32_MTRR_PHYSMASK6	MSR_MTRR_PHYS_MASK6	/* P6 */
+#define IA32_MTRR_PHYSBASE7	MSR_MTRR_PHYS_BASE7	/* P6 */
+#define IA32_MTRR_PHYSMASK7	MSR_MTRR_PHYS_MASK7	/* P6 */
+#define IA32_MTRR_FIX64K_00000	MSR_MTRR_FIX_00000	/* P6 */
+#define IA32_MTRR_FIX16K_80000	MSR_MTRR_FIX_80000	/* P6 */
+#define IA32_MTRR_FIX16K_A0000	MSR_MTRR_FIX_A0000	/* P6 */
+#define IA32_MTRR_FIX4K_C0000	MSR_MTRR_FIX_C0000	/* P6 */
+#define IA32_MTRR_FIX4K_C8000	MSR_MTRR_FIX_C8000	/* P6 */
+#define IA32_MTRR_FIX4K_D0000	MSR_MTRR_FIX_D0000	/* P6 */
+#define IA32_MTRR_FIX4K_D8000	MSR_MTRR_FIX_D8000	/* P6 */
+#define IA32_MTRR_FIX4K_E0000	MSR_MTRR_FIX_E0000	/* P6 */
+#define IA32_MTRR_FIX4K_E8000	MSR_MTRR_FIX_E8000	/* P6 */
+#define IA32_MTRR_FIX4K_F0000	MSR_MTRR_FIX_F0000	/* P6 */
+#define IA32_MTRR_FIX4K_F8000	MSR_MTRR_FIX_F8000	/* P6 */
+#define IA32_CR_PAT		0x0277			/* P6 */
+#define IA32_MTRR_DEF_TYPE	MSR_MTRR_DEFTYPE	/* P6 */
+#define IA32_PEBS_ENABLE	0x03f1			/* Pentium4 */
+#define IA32_MC0_CTL		MSR_MC0_CTL		/* P6 */
+#define IA32_MC0_STATUS		MSR_MC0_STATUS		/* P6 */
+#define IA32_MC0_ADDR		MSR_MC0_ADDR		/* P6 */
+#define IA32_MC0_MISC		MSR_MC0_MISC		/* P6 */
+#define IA32_MC1_CTL		MSR_MC1_CTL		/* P6 */
+#define IA32_MC1_STATUS		MSR_MC1_STATUS		/* P6 */
+#define IA32_MC1_ADDR		MSR_MC1_ADDR		/* P6 */
+#define IA32_MC1_MISC		MSR_MC1_MISC		/* P6 */
+#define IA32_MC2_CTL		MSR_MC2_CTL		/* P6 */
+#define IA32_MC2_STATUS		MSR_MC2_STATUS		/* P6 */
+#define IA32_MC2_ADDR		MSR_MC2_ADDR		/* P6 */
+#define IA32_MC2_MISC		MSR_MC2_MISC		/* P6 */
+#define IA32_MC3_CTL		0x040c			/* P6, addr changed */
+#define IA32_MC3_STATUS		0x040d			/* P6, addr changed */
+#define IA32_MC3_ADDR		0x040e			/* P6, addr changed */
+#define IA32_MC3_MISC		0x040f			/* P6, addr changed */
+#define IA32_DS_AREA		0x0600			/* Pentium4 */
+#define IA32_PERF_STAT		0x0198			/* Core2 */
+#define IA32_EFER		0xc0000080		/* Core2 - extended feature */
+#define IA32_GSBASE		0xc0000101		/* P4 */
+#define IA32_KERNEL_GSBASE	0xc0000102		/* P4 */
 
 /* MSR, IA32_DEBUGCTL, in Pentium4, bits */
 
-#define	DBG_P7_LBR		0x00000001
-#define	DBG_P7_BTF		0x00000002
-#define	DBG_P7_TR		0x00000004
-#define	DBG_P7_BTS		0x00000008
-#define	DBG_P7_BTINT		0x00000010
+#define DBG_P7_LBR		0x00000001
+#define DBG_P7_BTF		0x00000002
+#define DBG_P7_TR		0x00000004
+#define DBG_P7_BTS		0x00000008
+#define DBG_P7_BTINT		0x00000010
 
 /* MSR, IA32_DEBUGCTL, in P6, bits */
 
-#define	DBG_P6_LBR		0x00000001
-#define	DBG_P6_BTF		0x00000002
-#define	DBG_P6_PB0		0x00000004
-#define	DBG_P6_PB1		0x00000008
-#define	DBG_P6_PB2		0x00000010
-#define	DBG_P6_PB3		0x00000020
-#define	DBG_P6_TR		0x00000040
+#define DBG_P6_LBR		0x00000001
+#define DBG_P6_BTF		0x00000002
+#define DBG_P6_PB0		0x00000004
+#define DBG_P6_PB1		0x00000008
+#define DBG_P6_PB2		0x00000010
+#define DBG_P6_PB3		0x00000020
+#define DBG_P6_TR		0x00000040
 
 /* MSR, MSR_LASTBRANCH_TOS, in Pentium4, bits */
 
-#define	TOS_MASK		0x00000003
+#define TOS_MASK		0x00000003
 
 /* MSR, IA32_MISC_ENABLE bits */
 
-#define	MSC_FAST_STRING_ENABLE	0x00000001
-#define	MSC_FOPCODE_ENABLE	0x00000004
-#define	MSC_THERMAL_MON_ENABLE	0x00000008
-#define	MSC_SPLIT_LOCK_DISABLE	0x00000010
-#define	MSC_PMON_AVAILABLE	0x00000080
-#define	MSC_BTS_UNAVAILABLE	0x00000800
-#define	MSC_PEBS_UNAVAILABLE	0x00001000
-#define	MSC_GV1_EN		0x00008000
-#define	MSC_GV3_EN		0x00010000
-#define	MSC_GV_SEL_LOCK		0x00100000
-#define	MSC_LEAF_REPORTING	0x00400000
+#define MSC_FAST_STRING_ENABLE	0x00000001
+#define MSC_FOPCODE_ENABLE	0x00000004
+#define MSC_THERMAL_MON_ENABLE	0x00000008
+#define MSC_SPLIT_LOCK_DISABLE	0x00000010
+#define MSC_PMON_AVAILABLE	0x00000080
+#define MSC_BTS_UNAVAILABLE	0x00000800
+#define MSC_PEBS_UNAVAILABLE	0x00001000
+#define MSC_GV1_EN		0x00008000
+#define MSC_GV3_EN		0x00010000
+#define MSC_GV_SEL_LOCK		0x00100000
+#define MSC_LEAF_REPORTING	0x00400000
 
 /* MSR, IA32_PEBS_ENABLE bits */
 
-#define	PEBS_METRICS		0x00001fff
-#define	PEBS_UOP_TAG		0x01000000
-#define	PEBS_ENABLE		0x02000000
+#define PEBS_METRICS		0x00001fff
+#define PEBS_UOP_TAG		0x01000000
+#define PEBS_ENABLE		0x02000000
 
 /* MSR, IA32_PLATFORM_ID bits (upper 32) */
 
-#define	PFM_PLATFORM_ID		0x001c0000
-#define	PFM_MOBILE_GV		0x00040000
+#define PFM_PLATFORM_ID		0x001c0000
+#define PFM_MOBILE_GV		0x00040000
 
 /* MSR, IA32_PLATFORM_ID bits (lower 32) */
 
-#define	PFM_MAX_VID		0x0000003f
-#define	PFM_MAX_FREQ		0x00000f80
-#define	PFM_RATIO_LOCKED	0x00008000
-#define	PFM_GV3_TM_DISABLED	0x00010000
-#define	PFM_GV3_DISABLED	0x00020000
-#define	PFM_GV1_DISABLED	0x00040000
-#define	PFM_TM_DISABLED		0x00080000
-#define	PFM_L2_CACHE_SIZE	0x06000000
-#define	PFM_SAMPLE		0x08000000
+#define PFM_MAX_VID		0x0000003f
+#define PFM_MAX_FREQ		0x00000f80
+#define PFM_RATIO_LOCKED	0x00008000
+#define PFM_GV3_TM_DISABLED	0x00010000
+#define PFM_GV3_DISABLED	0x00020000
+#define PFM_GV1_DISABLED	0x00040000
+#define PFM_TM_DISABLED		0x00080000
+#define PFM_L2_CACHE_SIZE	0x06000000
+#define PFM_SAMPLE		0x08000000
 
 /* MSR, IA32_THERM_CONTROL bits */
 
-#define	THERM_DUTY_CYCLE	0x0000000e
-#define	THERM_TCC_EN		0x00000010
+#define THERM_DUTY_CYCLE	0x0000000e
+#define THERM_TCC_EN		0x00000010
 
 /* MSR, IA32_THERM_STATUS bits */
 
-#define	THERM_HOT_NOW		0x00000001
-#define	THERM_HOT_LOG		0x00000002
+#define THERM_HOT_NOW		0x00000001
+#define THERM_HOT_LOG		0x00000002
 
 /* MSR, IA32_THERM_INTERRUPT bits */
 
-#define	THERM_HOT_INT_EN	0x00000001
-#define	THERM_COLD_INT_EN	0x00000002
+#define THERM_HOT_INT_EN	0x00000001
+#define THERM_COLD_INT_EN	0x00000002
 
 /* PMC, Performance Monitoring Event Select MSR bits */
 
@@ -1737,78 +1741,78 @@ extern void	x86GetCpuid (uint32_t operation,
 
 /* P6 PMC event list */
 
-#define	PMC_DATA_MEM_REFS		0x43
-#define	PMC_DCU_LINES_IN		0x45
-#define	PMC_DCU_M_LINES_IN		0x46
-#define	PMC_DCU_M_LINES_OUT		0x47
-#define	PMC_DCU_MISS_OUTSTANDING	0x48
-#define	PMC_IFU_IFETCH			0x80
-#define	PMC_IFU_IFETCH_MISS		0x81
-#define	PMC_ITLB_MISS			0x85
-#define	PMC_IFU_MEM_STALL		0x86
-#define	PMC_IDL_STALL			0x87
-#define	PMC_L2_IFETCH			0x28
-#define	PMC_L2_LD			0x29
-#define	PMC_L2_ST			0x2a
-#define	PMC_L2_LINES_IN			0x24
-#define	PMC_L2_LINES_OUT		0x26
-#define	PMC_L2_M_LINES_INM		0x25
-#define	PMC_L2_M_LINES_OUTM		0x27
-#define	PMC_L2_RQSTS			0x2e
-#define	PMC_L2_ADS			0x21
-#define	PMC_L2_DBUS_BUSY		0x22
-#define	PMC_L2_DBUS_BUSY_RD		0x23
-#define	PMC_BUS_DRDY_CLOCKS		0x62
-#define	PMC_BUS_LOCK_CLOCKS		0x63
-#define	PMC_BUS_REQ_OUTSTANDING		0x60
-#define	PMC_BUS_TRAN_BRD		0x65
-#define	PMC_BUS_TRAN_RFO		0x66
-#define	PMC_BUS_TRANS_WB		0x67
-#define	PMC_BUS_TRAN_IFETCH		0x68
-#define	PMC_BUS_TRAN_INVAL		0x69
-#define	PMC_BUS_TRAN_PWR		0x6a
-#define	PMC_BUS_TRANS_P			0x6b
-#define	PMC_BUS_TRANS_IO		0x6c
-#define	PMC_BUS_TRAN_DEF		0x6d
-#define	PMC_BUS_TRAN_BURST		0x6e
-#define	PMC_BUS_TRAN_ANY		0x70
-#define	PMC_BUS_TRAN_MEM		0x6f
-#define	PMC_BUS_DATA_RCV		0x64
-#define	PMC_BUS_BNR_DRV			0x61
-#define	PMC_BUS_HIT_DRV			0x7a
-#define	PMC_BUS_HITM_DRV		0x7b
-#define	PMC_BUS_SNOOP_STALL		0x7e
-#define	PMC_FLOPS			0xc1
-#define	PMC_FP_COMP_OPS_EXE		0x10
-#define	PMC_FP_ASSIST			0x11
-#define	PMC_MUL				0x12
-#define	PMC_DIV				0x13
-#define	PMC_CYCLES_DIV_BUSY		0x14
-#define	PMC_LD_BLOCKS			0x03
-#define	PMC_SB_DRAINS			0x04
-#define	PMC_MISALIGN_MEM_REF		0x05
-#define	PMC_INST_RETIRED		0xc0
-#define	PMC_UOPS_RETIRED		0xc2
-#define	PMC_INST_DECODER		0xd0
-#define	PMC_HW_INT_RX			0xc8
-#define	PMC_CYCLES_INT_MASKED		0xc6
-#define	PMC_CYCLES_INT_PENDING_AND_MASKED 0xc7
-#define	PMC_BR_INST_RETIRED		0xc4
-#define	PMC_BR_MISS_PRED_RETIRED	0xc5
-#define	PMC_BR_TAKEN_RETIRED		0xc9
-#define	PMC_BR_MISS_PRED_TAKEN_RETIRED	0xca
-#define	PMC_BR_INST_DECODED		0xe0
-#define	PMC_BTB_MISSES			0xe2
-#define	PMC_BR_BOGUS			0xe4
-#define	PMC_BACLEARS			0xe6
-#define	PMC_RESOURCE_STALLS		0xa2
-#define	PMC_PARTIAL_RAT_STALLS		0xd2
-#define	PMC_SEGMENT_REG_LOADS		0x06
-#define	PMC_CPU_CLK_UNHALTED		0x79
-#define	PMC_UMASK_00			0x00
-#define	PMC_UMASK_0F			0x0f
-#define	PMC_UMASK_SELF			0x00
-#define	PMC_UMASK_ANY			0x20
+#define PMC_DATA_MEM_REFS		0x43
+#define PMC_DCU_LINES_IN		0x45
+#define PMC_DCU_M_LINES_IN		0x46
+#define PMC_DCU_M_LINES_OUT		0x47
+#define PMC_DCU_MISS_OUTSTANDING	0x48
+#define PMC_IFU_IFETCH			0x80
+#define PMC_IFU_IFETCH_MISS		0x81
+#define PMC_ITLB_MISS			0x85
+#define PMC_IFU_MEM_STALL		0x86
+#define PMC_IDL_STALL			0x87
+#define PMC_L2_IFETCH			0x28
+#define PMC_L2_LD			0x29
+#define PMC_L2_ST			0x2a
+#define PMC_L2_LINES_IN			0x24
+#define PMC_L2_LINES_OUT		0x26
+#define PMC_L2_M_LINES_INM		0x25
+#define PMC_L2_M_LINES_OUTM		0x27
+#define PMC_L2_RQSTS			0x2e
+#define PMC_L2_ADS			0x21
+#define PMC_L2_DBUS_BUSY		0x22
+#define PMC_L2_DBUS_BUSY_RD		0x23
+#define PMC_BUS_DRDY_CLOCKS		0x62
+#define PMC_BUS_LOCK_CLOCKS		0x63
+#define PMC_BUS_REQ_OUTSTANDING		0x60
+#define PMC_BUS_TRAN_BRD		0x65
+#define PMC_BUS_TRAN_RFO		0x66
+#define PMC_BUS_TRANS_WB		0x67
+#define PMC_BUS_TRAN_IFETCH		0x68
+#define PMC_BUS_TRAN_INVAL		0x69
+#define PMC_BUS_TRAN_PWR		0x6a
+#define PMC_BUS_TRANS_P			0x6b
+#define PMC_BUS_TRANS_IO		0x6c
+#define PMC_BUS_TRAN_DEF		0x6d
+#define PMC_BUS_TRAN_BURST		0x6e
+#define PMC_BUS_TRAN_ANY		0x70
+#define PMC_BUS_TRAN_MEM		0x6f
+#define PMC_BUS_DATA_RCV		0x64
+#define PMC_BUS_BNR_DRV			0x61
+#define PMC_BUS_HIT_DRV			0x7a
+#define PMC_BUS_HITM_DRV		0x7b
+#define PMC_BUS_SNOOP_STALL		0x7e
+#define PMC_FLOPS			0xc1
+#define PMC_FP_COMP_OPS_EXE		0x10
+#define PMC_FP_ASSIST			0x11
+#define PMC_MUL				0x12
+#define PMC_DIV				0x13
+#define PMC_CYCLES_DIV_BUSY		0x14
+#define PMC_LD_BLOCKS			0x03
+#define PMC_SB_DRAINS			0x04
+#define PMC_MISALIGN_MEM_REF		0x05
+#define PMC_INST_RETIRED		0xc0
+#define PMC_UOPS_RETIRED		0xc2
+#define PMC_INST_DECODER		0xd0
+#define PMC_HW_INT_RX			0xc8
+#define PMC_CYCLES_INT_MASKED		0xc6
+#define PMC_CYCLES_INT_PENDING_AND_MASKED 0xc7
+#define PMC_BR_INST_RETIRED		0xc4
+#define PMC_BR_MISS_PRED_RETIRED	0xc5
+#define PMC_BR_TAKEN_RETIRED		0xc9
+#define PMC_BR_MISS_PRED_TAKEN_RETIRED	0xca
+#define PMC_BR_INST_DECODED		0xe0
+#define PMC_BTB_MISSES			0xe2
+#define PMC_BR_BOGUS			0xe4
+#define PMC_BACLEARS			0xe6
+#define PMC_RESOURCE_STALLS		0xa2
+#define PMC_PARTIAL_RAT_STALLS		0xd2
+#define PMC_SEGMENT_REG_LOADS		0x06
+#define PMC_CPU_CLK_UNHALTED		0x79
+#define PMC_UMASK_00			0x00
+#define PMC_UMASK_0F			0x0f
+#define PMC_UMASK_SELF			0x00
+#define PMC_UMASK_ANY			0x20
 
 /* MTRR related defines */
 
@@ -1825,29 +1829,29 @@ extern void	x86GetCpuid (uint32_t operation,
 
 /* MCA related defines */
 
-#define	MCG_CTL_P			0x00000100
-#define	MCG_COUNT			0x000000ff
-#define	MCG_MCIP			0x00000004
-#define	MCG_EIPV			0x00000002
-#define	MCG_RIPV			0x00000001
-#define	MCI_VAL				0x80000000
-#define	MCI_OVER			0x40000000
-#define	MCI_UC				0x20000000
-#define	MCI_EN				0x10000000
-#define	MCI_MISCV			0x08000000
-#define	MCI_ADDRV			0x04000000
-#define	MCI_PCC				0x02000000
+#define MCG_CTL_P			0x00000100
+#define MCG_COUNT			0x000000ff
+#define MCG_MCIP			0x00000004
+#define MCG_EIPV			0x00000002
+#define MCG_RIPV			0x00000001
+#define MCI_VAL				0x80000000
+#define MCI_OVER			0x40000000
+#define MCI_UC				0x20000000
+#define MCI_EN				0x10000000
+#define MCI_MISCV			0x08000000
+#define MCI_ADDRV			0x04000000
+#define MCI_PCC				0x02000000
 
 /* segment descriptor: types for application code, data segment */
 
-#define	SEG_DATA_RO_U		0x00000000	/* read only */
-#define	SEG_DATA_RW_U		0x00000200	/* read write */
-#define	SEG_DATA_RO_D		0x00000400	/* read only expand down */
-#define	SEG_DATA_RW_D		0x00000600	/* read write expand down */
-#define	SEG_CODE_EO		0x00000800	/* exec only */
-#define	SEG_CODE_ER		0x00000a00	/* exec read */
-#define	SEG_CODE_EO_C		0x00000c00	/* exec only conform. */
-#define	SEG_CODE_ERO_C		0x00000e00	/* exec read only conform. */
+#define SEG_DATA_RO_U		0x00000000	/* read only */
+#define SEG_DATA_RW_U		0x00000200	/* read write */
+#define SEG_DATA_RO_D		0x00000400	/* read only expand down */
+#define SEG_DATA_RW_D		0x00000600	/* read write expand down */
+#define SEG_CODE_EO		0x00000800	/* exec only */
+#define SEG_CODE_ER		0x00000a00	/* exec read */
+#define SEG_CODE_EO_C		0x00000c00	/* exec only conform. */
+#define SEG_CODE_ERO_C		0x00000e00	/* exec read only conform. */
 
 /* segment descriptor: types for system segment and gate */
 
@@ -1895,11 +1899,11 @@ extern void	x86GetCpuid (uint32_t operation,
 
 /* segment register requested privilege levels */
 
-#define	SEG_RPL_RING_0		0x0
-#define	SEG_RPL_RING_1		0x1
-#define	SEG_RPL_RING_2		0x2
-#define	SEG_RPL_RING_3		0x3
-#define	SEG_RPL_MASK		0x3
+#define SEG_RPL_RING_0		0x0
+#define SEG_RPL_RING_1		0x1
+#define SEG_RPL_RING_2		0x2
+#define SEG_RPL_RING_3		0x3
+#define SEG_RPL_MASK		0x3
 
 /* IDT related macros */
 
@@ -1943,8 +1947,8 @@ extern void	x86GetCpuid (uint32_t operation,
 
 /* VMX realted defines */
 
-#define	VMX_MEMORY_TYPE_UC	0	/* Strong uncacheable (UC) */
-#define	VMX_MEMORY_TYPE_WB	6	/* Write back (WB) */
+#define VMX_MEMORY_TYPE_UC	0	/* Strong uncacheable (UC) */
+#define VMX_MEMORY_TYPE_WB	6	/* Write back (WB) */
 
 /* inline version of intLock()/intUnlock() : used in mmuI86Lib.c */
 
@@ -1956,4 +1960,4 @@ extern void	x86GetCpuid (uint32_t operation,
     WRS_ASM ("testl $0x00000200, %0 ; jz 0f ; sti ; 0:" \
     : /* no output */ : "rm" (oldLevel) : "memory")
 
-#endif	/* __INCx86regsh */
+#endif	/* __ASM_REG_VBI_H */
diff --git a/arch/x86/include/asm/vbi.h b/arch/x86/include/asm/vbi.h
index 97e2f47..ee5908b 100644
--- a/arch/x86/include/asm/vbi.h
+++ b/arch/x86/include/asm/vbi.h
@@ -14,8 +14,8 @@
  *
  */
 
-#ifndef __INCsysX86Asmh
-#define __INCsysX86Asmh
+#ifndef __ASM_VBI_H
+#define __ASM_VBI_H
 
 /*
  * The following definitions are used for symbol name compatibility.
@@ -104,7 +104,7 @@
 #define ARG12	52
 
 #define DARG1	8		/* double arguments */
-#define	DARG1L	12
+#define DARG1L	12
 #define DARG2	16
 #define DARG2L	20
 #define DARG3	24
@@ -134,4 +134,4 @@
 
 #define _WRS_ASM(x) __asm volatile (x)
 
-#endif /* __INCsysX86Asmh */
+#endif /* __ASM_VBI_H */
diff --git a/arch/x86/kernel/vbi/syscalls.S b/arch/x86/kernel/vbi/syscalls.S
index e9b1f36..4cf386e 100644
--- a/arch/x86/kernel/vbi/syscalls.S
+++ b/arch/x86/kernel/vbi/syscalls.S
@@ -25,6 +25,28 @@
 .text
 .balign 16
 
+#ifdef LP64
+#define VBI_STACK_FRAME_SIZE   8
+
+#define ARG1 %rdi
+#define ARG2 %rsi
+#define ARG3 %rdx
+#define ARG4 %rcx
+#define ARG5 %r8
+#define ARG6 %r9
+#define ARG7(offset) offset(%rsp)
+#define ARG8(offset) 0x8+offset(%rsp)
+
+#define vbi_hcall(name, call, args)			\
+.globl name;						\
+name:							\
+	push $##args;					\
+	mov $(VBI_SYS_##call | HY_SIZE_OVERRIDE),%rax;	\
+	vmcall;						\
+	add $VBI_STACK_FRAME_SIZE, %rsp;		\
+	ret
+
+#else	/* !LP64 */
 #define VBI_STACK_FRAME_SIZE	4
 
 #define vbi_hcall(name, call, args)		\
@@ -36,6 +58,8 @@ name:						\
 	addl $VBI_STACK_FRAME_SIZE, %esp;	\
 	ret
 
+#endif	/* LP64 */
+
 /*
  * vbi_send - Send a message to another context
  *
@@ -45,7 +69,22 @@ name:						\
  *
  *
  */
+#ifdef LP64
+vbi_send:
+	mov     %rax,ARG7(VBI_STACK_FRAME_SIZE) /* ctl */
+	push    %r10            /* save the value of r10 */
+	mov     %rax,%r10       /* load r10 with the values of "ctl" */
+	push    $7              /* number of arguments */
+
+	mov     $VBI_SYS_send+$HY_SIZE_OVERRIDE,%rax /* system call number */
+	vmcall
+
+	pop     %r10            /* pop the number of arguments */
+	pop     %r10            /* pop the value of r10 */
+	ret
+#else
 vbi_hcall(vbi_send, send, 7)
+#endif
 
 /*
  * vbi_rx_op - Receive a message from another context
@@ -143,8 +182,12 @@ vbi_vcore_irq_unlock:
 .globl vbi_vcore_irq_lock
 vbi_vcore_irq_lock:
     pushf				/* push EFLAGS on stack */
-    popl	%eax			/* get EFLAGS in EAX */
-    andl	$EFLAGS_IF,%eax		/* mask it with IF bit */
+#ifdef LP64
+    pop		eax			/* get EFLAGS in EAX */
+#else
+    pop		%eax			/* get EFLAGS in EAX */
+#endif
+    and		$EFLAGS_IF,%eax		/* mask it with IF bit */
     cli					/* lock interrupts */
     ret
 
@@ -520,10 +563,16 @@ vbi_hcall(vbi_vcore_irq_redirect, intRedirect, 2)
  *
  * Returns: OK or ERROR if the VTLB operation has failed
  */
-.globl vbi_vtlb_op
-vbi_vtlb_op:
-	movl $VBI_SYS_vtlb_op, %eax
-	pushl $4
-	vmcall
-	addl $VBI_STACK_FRAME_SIZE, %esp
-	ret
+vbi_hcall(vbi_vtlb_op, vtlb_op, 4)
+
+/*
+ * vbi_vb_remote - execute a specified remote VB operation
+ *
+ * This system call requests for information about a remote VB. The possible
+ * operations are:
+ *
+ *   VBI_VBREMOTE_BOARDCONFIG    returns guest address of VB_CONFIG in out
+ *   VBI_VBREMOTE_RAMSIZE        returns memory size in out
+ *
+ */
+vbi_hcall(vbi_vb_remote, vbRemote, 4)
diff --git a/include/vbi/compat.h b/include/vbi/compat.h
index fa1fe7d..c65b8a1 100644
--- a/include/vbi/compat.h
+++ b/include/vbi/compat.h
@@ -37,6 +37,7 @@
 #define VB_INT_INFO	struct vb_int_info
 #define VB_MEM_INFO	struct vb_mem_info
 #define VB_SM_INFO	struct vb_sm_info
+#define VB_DEV_INFO	struct vb_dev_info
 
 #define VBI_MSG_INFO		struct vbi_msg_info
 #define VBI_MSG_CTL		struct vbi_msg_ctl
@@ -71,6 +72,7 @@
 #define vbiMemAttr_t		int32_t
 #define vbiVector_t		int32_t
 #define vbiCoreSet_t		uint32_t
+#define vbiRegSet_t		uint32_t
 
 /*
  * struct fields and similar
@@ -126,11 +128,13 @@
 #define vbiVbResume		vbi_vb_resume
 #define vbiVbRestart		vbi_vb_restart
 #define vbiVbReset		vbi_vb_reset
+#define vbiVbRemote		vbi_vb_remote
 
 #define vbiVbRegisterRead	vbi_vb_read_reg
 #define vbiVbRegisterWrite	vbi_vb_write_reg
 #define vbiVbMemoryRead		vbi_vb_read_mem
 #define vbiVbMemoryWrite	vbi_vb_write_mem
+#define vbiVbBoardConfigFind	vbi_vb_find_board_config
 
 #define vbiVcoreIntRed_op	vbi_vcore_irq_redirect
 #define vbiDebugShellStart	vbi_shell_start_debug
@@ -154,6 +158,7 @@
 #define vbiTlbFlush		vbi_flush_tlb
 #define vbiVtlbOp		vbi_vtlb_op
 
+#define vbiDirectInterruptEOI	vbi_direct_IRQ_EOI
 #define vbiIntVCoreUnlock	vbi_vcore_irq_unlock
 #define vbiIntVCoreLock		vbi_vcore_irq_lock
 #define vbiIntVCoreStateGet	vbi_vcore_irq_state
diff --git a/include/vbi/interface.h b/include/vbi/interface.h
index 51754d4..6f62d69 100644
--- a/include/vbi/interface.h
+++ b/include/vbi/interface.h
@@ -85,6 +85,7 @@ identity mapped.
 
 #include <vbi/types.h>
 #include <vbi/arch.h>
+#include <vbi/compat.h>
 
 /* VB versioning information */
 #define	VBI_VERSION_MAJOR	2	/* major version */
@@ -169,8 +170,9 @@ identity mapped.
 #endif /* __VBI_BYTE_ORDER */
 
 /* Bit Mask definitions for VB_STATUS_INT_PENDING */
-#define VB_STATUS_INT_PENDING_INT	1	/* Interrupt controller */
+#define VB_STATUS_INT_PENDING_INT	1	/* Virtual Interrupt */
 #define VB_STATUS_INT_PENDING_TICK	2	/* Tick interrupt */
+#define VB_STATUS_INT_PENDING_DIRECT_INT	4   /* Direct Interrupt */
 
 /* Assembler offsets for vb_status */
 #if !defined(_WRHV_ARCH_HAS_STATUS_REGS)
@@ -224,6 +226,11 @@ identity mapped.
 /* define 128 entries for all platforms */
 #define VIOAPIC_MAX_REDTABLE_ENTRIES	VB_MAX_INTERRUPTS
 
+/* define valid guest to guest register operations */
+
+#define VBI_REG_SET_32BIT	0
+#define VBI_REG_SET_64BIT	1
+
 #ifndef	_ASMLANGUAGE
 
 /*
@@ -432,6 +439,14 @@ struct vb_status {
 
 };
 
+/* Configuration information for devices */
+struct vb_dev_info {
+	char giName[VB_NAMELEN]; /* the name of this interrupt */
+	uint16_t Class;		 	/* class: serial, net, block, other */
+	char Template[VB_NAMELEN];/* the name of template */
+};
+
+
 /* Configuration information for interrupts */
 struct vb_int_info
 {
@@ -579,6 +594,15 @@ struct vb_config
 	VB_ALIGN_FIELD_64 (struct vb_syscall *vbSyscallTable, pad9);
 	VB_ALIGN_FIELD_64 (struct vb_syscall_stub2 *vbSyscallStub2, pad10);
 #endif
+
+    /* information about devices */
+
+    VB_ALIGN_FIELD_64 (VB_DEV_INFO *deviceConfiguration, pad11);
+
+    /* number of devices connected to this board */
+
+    uint32_t  numDevices;
+
 };
 
 #endif /*_ASMLANGUAGE */
diff --git a/include/vbi/private.h b/include/vbi/private.h
index fdc00fb..f1206b7 100644
--- a/include/vbi/private.h
+++ b/include/vbi/private.h
@@ -39,6 +39,9 @@ extern asmlinkage int32_t vbi_ns_op(uint32_t op, char* name, uint32_t rev,
 extern asmlinkage int32_t vbi_rx_op(void *rmsg, uint32_t rlen,
 			struct vbi_msg_info *info, struct vbi_msg_ctl *ctl);
 
+extern asmlinkage int32_t vbi_vb_remote(uint32_t op, uint32_t board_id,
+			int32_t core_id,  void *out);
+
 #endif
 
 #endif  /* _VBI_PRIVATE_H */
diff --git a/include/vbi/shmem.h b/include/vbi/shmem.h
index a3b8228..8722b68 100644
--- a/include/vbi/shmem.h
+++ b/include/vbi/shmem.h
@@ -34,6 +34,8 @@ extern int32_t vbi_find_mem( int8_t *name, void **addr,
 /* find the base address and length of a core's private memory */
 extern int32_t vbi_find_core_prv_mem(void **addr, size_t *length);
 
+extern int32_t vbi_vb_find_ram_size(uint32_t board_id, size_t *phys_mem_size);
+
 #endif /* _ASMLANGUAGE */
 
 #endif  /* _VBI_SHMEM_H */
diff --git a/include/vbi/syscall.h b/include/vbi/syscall.h
index ce72393..9d37d4a 100644
--- a/include/vbi/syscall.h
+++ b/include/vbi/syscall.h
@@ -148,10 +148,10 @@ extern asmlinkage int32_t vbi_vb_read_mem(struct vbi_mem_ctl *memCtl, uint32_t t
 extern asmlinkage int32_t vbi_vb_write_mem(struct vbi_mem_ctl *memCtl, uint32_t targetBoard);
 extern asmlinkage void vbi_shell_start_debug(uint32_t  flags);
 
-/* read remote vb's registers */
-extern asmlinkage int32_t vbi_vb_read_reg(VBI_HREG_SET *regCtl,
+/* read/write remote vb's registers */
+extern asmlinkage int32_t vbi_vb_read_reg(VBI_HREG_SET_CMPLX_QUALIFIED *regSet,
 				       uint32_t targetBoard, int32_t core);
-extern asmlinkage int32_t vbi_vb_write_reg(VBI_HREG_SET *regCtl,
+extern asmlinkage int32_t vbi_vb_write_reg(VBI_HREG_SET_CMPLX_QUALIFIED *regSet,
 					uint32_t targetBoard, int32_t core);
 
 /*
diff --git a/include/vbi/syscalls.h b/include/vbi/syscalls.h
index ab61c84..634913e 100644
--- a/include/vbi/syscalls.h
+++ b/include/vbi/syscalls.h
@@ -26,11 +26,13 @@
  *  +---------------+---------------+        +---------------+---------------+
  *  | | | | | | | | | | | | | | | | | ...... | | | | | | | | | | | | | | | | |
  *  +---------------+---------------+        +---------------+---------------+
- *   ^ ^ ^         ^ ^                                                      ^
- *   | | \--------/  \------------------------------------------------------/
- *   | |      |                                |
- *   | |      |                                |
- *   | |      |                                +-- System call number
+ *   ^ ^ ^         ^ ^ ^                                                    ^
+ *   | | \--------/  | \----------------------------------------------------/
+ *   | |      |      |                         |
+ *   | |      |      |                         |
+ *   | |      |      |                         +-- System call number
+ *   | |      |      |
+ *   | |      |      +-- Size override
  *   | |      |
  *   | |      +-- Fast hypervisor system call number
  *   | |
@@ -52,12 +54,14 @@
 	 HY_FAST_SYSCALL_BIT)
 
 /* C driven system calls */
-#define HY_SYSCALL_MASK		0x00ffffff
+#define HY_SYSCALL_MASK		0x007fffff
 #define HY_SYSCALL_SHIFT	0
 #define HY_SYSCALL_BIT		0x40000000
 #define HY_SYSCALL(x)	\
 	((((x) << HY_SYSCALL_SHIFT) & HY_SYSCALL_MASK) | HY_SYSCALL_BIT)
 
+#define HY_SIZE_OVERRIDE	0x00800000
+
 /* fast system calls */
 #define VBI_SYS_tlb_flush	HY_FAST_SYSCALL(1) /* TLB flush			*/
 #define VBI_SYS_icache_flush	HY_FAST_SYSCALL(2) /* instruction cache flush	*/
@@ -67,6 +71,8 @@
 #define VBI_SYS_cache_text_update		    \
 				HY_FAST_SYSCALL(6) /* cache text update		*/
 
+#define	VBI_SYS_pic_EOI		    \
+				HY_FAST_SYSCALL(7) /* cache text update		*/
 
 
 /* hypervisor services */
@@ -104,7 +110,9 @@
 #define VBI_SYS_vbReset         HY_SYSCALL(22)	/* reset  vcores	*/
 #define VBI_SYS_vbRestart       HY_SYSCALL(23)	/* restart vcores	*/
 #define VBI_SYS_vbSuspend       HY_SYSCALL(24)	/* suspend vcores	*/
-#define VBI_SYS_vbResume        HY_SYSCALL(25)  /* Resume vcores	*/
+#define VBI_SYS_vbResume        HY_SYSCALL(25)	/* Resume vcores	*/
+#define VBI_SYS_vbRemote        HY_SYSCALL(26)	/* Get info of board	*/
+
 
 #define VBI_SYS_intRedirect     HY_SYSCALL(40)  /* vcores int redirect	*/
 
@@ -168,6 +176,11 @@
 /* hyCtxctl system call supported operations */
 #define VBI_CTXCTL_IDLE		1	/* make current context idle	*/
 
+/* remote VB syscall call supported operations */
+
+#define VBI_VBREMOTE_BOARDCONFIG    1       /* get guest addr of VBCONFIG */
+#define VBI_VBREMOTE_RAMSIZE        2       /* get memory size */
+
 /* MMU protection attributes */
 #define VBI_MMU_PROT_READ	0x00000001	/* read allowed    */
 #define VBI_MMU_PROT_WRITE	0x00000002	/* write allowed   */
@@ -181,6 +194,12 @@
 
 #define VBI_BSPIOCTL_CLK_FREQ 2	/* Request system clk freq */
 
+/* return physical cpu number given virtual number
+ * - UP should always be 0
+ * - SMP any vcore in the system
+ */
+#define VBI_BSPIOCTL_VIRT_TO_PHYS_CPU_NUM 3
+ 
 #define MDIO_READ 1
 #define MDIO_WRITE 2
 #define MDIO_INT_ENABLE 3
diff --git a/include/vbi/vbi.h b/include/vbi/vbi.h
index fcc765b..560f638 100644
--- a/include/vbi/vbi.h
+++ b/include/vbi/vbi.h
@@ -543,6 +543,8 @@ extern void vbi_show_cfg(void);
 extern void vbi_show_mem(void);
 extern void vbi_disp_status_regs(void);
 extern void vbi_disp_ctrl_regs(void);
+extern int32_t vbi_vb_find_board_config(uint32_t board_id, int32_t core_id,
+						void *paddr);
 
 #endif	/* _ASMLANGUAGE */
 
diff --git a/kernel/vbi/lib.c b/kernel/vbi/lib.c
index a524769..e1c5a97 100644
--- a/kernel/vbi/lib.c
+++ b/kernel/vbi/lib.c
@@ -102,6 +102,7 @@ The address of this area is kept in the global variable wr_control.
 #include <linux/types.h>
 #include <linux/module.h>
 #include <vbi/vbi.h>
+#include <vbi/private.h>
 
 struct vb_config *wr_vb_config;	/* The address of the core's Config area
 				 * This value is passed to the virtual board
@@ -195,3 +196,18 @@ void vbi_init(struct vb_config *config)
 	wr_vb_status = wr_vb_config->vb_status;
 
 }
+
+/*
+ *
+ * vbi_vb_find_board_config - return board config of VB
+ *
+ * This function gets the board config guest address of the VB's configuration
+ *
+ */
+int32_t vbi_vb_find_board_config(uint32_t board_id, int32_t core_id,
+					void *paddr)
+{
+	return vbi_vb_remote(VBI_VBREMOTE_BOARDCONFIG, board_id, core_id,
+				paddr);
+}
+
diff --git a/kernel/vbi/shmem.c b/kernel/vbi/shmem.c
index b9b214e..f4b3c0e 100644
--- a/kernel/vbi/shmem.c
+++ b/kernel/vbi/shmem.c
@@ -117,3 +117,16 @@ int32_t vbi_find_core_prv_mem(void **addr, size_t *length)
 
 	return 0;
 }
+
+/*
+ * vbi_vb_find_ram_size - return RAM size of VB
+ *
+ * This function gets the RAM size of the VB's configuration
+ *
+ */
+int32_t vbi_vb_find_ram_size(uint32_t board_id, size_t *phys_mem_size)
+{
+	 return vbi_vb_remote(VBI_VBREMOTE_RAMSIZE, board_id, NULL,
+				phys_mem_size);
+}
+
-- 
1.6.5.2

