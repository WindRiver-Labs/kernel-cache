From 4888bbab1c4772f3e3b2d495cb2bad0a749a1a24 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Mon, 25 Apr 2011 15:48:28 +0800
Subject: [PATCH 1/2] wrhv/ppc: fix the limitation of using fixed address for each IVOR

Currently each interrupt handler use a fixed length space, and we
will set the GOS IVOR based on this assumption. This has the following
drawbacks:

1. Create bigger footprint. Currently the size of text section is
7743088, after using unfixed length handler the size of text section
is reduced to 7736432.

2. It is very inconvenient to adjust the interrupt handler according
to the cpu type.

So instead of assuming every interrupt handler is at the fixed address,
we will set the address of each interrupt handler to exception table
before setting the GOS IVOR via vbi.

It is also no harm to set the direct interrupt handler even that is not
enabled. So always set it.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/kernel/head_wrhv.S       |   44 ++++++++++++++++++++++++++-----
 arch/powerpc/kernel/head_wrhv.h       |   31 +++++----------------
 arch/powerpc/kernel/head_wrhv_p4080.S |   47 ++++++++++++++++++++++++++++-----
 arch/powerpc/kernel/vbi/wrhv.c        |   36 ++++++-------------------
 4 files changed, 94 insertions(+), 64 deletions(-)

diff --git a/arch/powerpc/kernel/head_wrhv.S b/arch/powerpc/kernel/head_wrhv.S
index 8ae74a0..27c3ef3 100644
--- a/arch/powerpc/kernel/head_wrhv.S
+++ b/arch/powerpc/kernel/head_wrhv.S
@@ -138,6 +138,30 @@ _ENTRY(__early_start)
 	li	r0,0
 	stwu	r0,THREAD_SIZE-STACK_FRAME_OVERHEAD(r1)
 
+	/* Establish the interrupt vector offsets */
+	SET_IVOR(0,  CriticalInput);
+	SET_IVOR(1,  MachineCheck);
+	SET_IVOR(2,  DataStorage);
+	SET_IVOR(3,  InstructionStorage);
+	SET_IVOR(4,  ExternalInput);
+	SET_IVOR(5,  Alignment);
+	SET_IVOR(6,  Program);
+	SET_IVOR(7,  FloatingPointUnavailable);
+	SET_IVOR(8,  SystemCall);
+	SET_IVOR(9,  AuxillaryProcessorUnavailable);
+	SET_IVOR(10, Decrementer);
+	SET_IVOR(11, FixedIntervalTimer);
+	SET_IVOR(12, WatchdogTimer);
+	SET_IVOR(13, DataTLBError);
+	SET_IVOR(14, InstructionTLBError);
+	SET_IVOR(15, DebugDebug);
+	SET_IVOR(32, SPEUnavailable);
+	SET_IVOR(33, SPEFloatingPointData);
+	SET_IVOR(34, SPEFloatingPointRound);
+	SET_IVOR(35, PerformanceMonitor);
+	SET_IVOR(36, doorbell_exception);
+	SET_IVOR(37, CriticalDoorbell);
+
 	bl	early_init
 
 #ifdef CONFIG_RELOCATABLE
@@ -230,13 +254,6 @@ _ENTRY(__early_start)
  * Interrupt vectors must be aligned on a 16 byte boundary.
  * We align on a 32 byte cache line boundary for good measure.
  */
-
-/* Align 0x100 boundary for guest OS.
-#ifdef CONFIG_SMP
-	.align 9
-#else
-	.align 8
-#endif
 interrupt_base:
 	/* Critical Input Interrupt */
 	CRITICAL_EXCEPTION(0x0100, CriticalInput, unknown_exception)
@@ -684,6 +701,19 @@ KernelSPE:
 #endif /* CONFIG_SPE */
 
 /*
+ * Set the interrupt vector offset to the exec table
+ * r3 - the interrupt vector number
+ * r4 - the vector handler label
+ */
+set_exec_table:
+	lis	r5,exec_table@h
+	ori	r5,r5,exec_table@l
+	slwi	r3,r3,2
+	subis	r4,r4,PAGE_OFFSET@h
+	stwx	r4,r3,r5
+	blr
+
+/*
  * Global functions
  */
 
diff --git a/arch/powerpc/kernel/head_wrhv.h b/arch/powerpc/kernel/head_wrhv.h
index 96a11f2..2133805 100644
--- a/arch/powerpc/kernel/head_wrhv.h
+++ b/arch/powerpc/kernel/head_wrhv.h
@@ -100,30 +100,15 @@
         lwz     r4,VB_STATUS_R4(r4)
 #endif
 
-
 /*
- * Exception vectors.
- */
-#if defined (CONFIG_WR_OCD_DEBUG) && defined (CONFIG_BOOKE)
-#define	START_EXCEPTION(label)						     \
-        .align 5;              						     \
-label:									     \
-	nop;								     \
-	nop;								     \
-	nop;								     \
-	isync;
-#else
-#ifdef CONFIG_WRHV
-#undef START_EXCEPTION
-#define        START_EXCEPTION(label)				\
-       .align 9;						\
-label:
-#else
-#define        START_EXCEPTION(label)                                  \
-       .align 5;                                               \
-label:
-#endif /* CONFIG_WRHV */
-#endif
+ * Macros used for set Book-e exception table
+*/
+#undef SET_IVOR
+#define SET_IVOR(vector_number, vector_label)		\
+	li	r3,vector_number@l;			\
+	lis	r4,vector_label@h;			\
+	ori	r4,r4,vector_label@l;			\
+	bl	set_exec_table
 
 #undef DEBUG_DEBUG_EXCEPTION
 #define DEBUG_DEBUG_EXCEPTION						      \
diff --git a/arch/powerpc/kernel/head_wrhv_p4080.S b/arch/powerpc/kernel/head_wrhv_p4080.S
index 32197b5..a2d11f2 100644
--- a/arch/powerpc/kernel/head_wrhv_p4080.S
+++ b/arch/powerpc/kernel/head_wrhv_p4080.S
@@ -161,6 +161,33 @@ _ENTRY(__early_start)
 	li	r0,0
 	stwu	r0,THREAD_SIZE-STACK_FRAME_OVERHEAD(r1)
 
+	/* Establish the interrupt vector offsets */
+	SET_IVOR(0,  CriticalInput);
+	SET_IVOR(1,  MachineCheck);
+	SET_IVOR(2,  DataStorage);
+	SET_IVOR(3,  InstructionStorage);
+	SET_IVOR(4,  ExternalInput);
+	SET_IVOR(5,  Alignment);
+	SET_IVOR(6,  Program);
+	SET_IVOR(7,  FloatingPointUnavailableErrata);
+	SET_IVOR(8,  SystemCall);
+	SET_IVOR(9,  AuxillaryProcessorUnavailable);
+	SET_IVOR(10, Decrementer);
+	SET_IVOR(11, FixedIntervalTimer);
+	SET_IVOR(12, WatchdogTimer);
+	SET_IVOR(13, DataTLBError);
+	SET_IVOR(14, InstructionTLBError);
+	SET_IVOR(15, DebugDebug);
+	SET_IVOR(20, DirectExternalInput);
+#ifdef CONFIG_SPE
+	SET_IVOR(32, SPEUnavailable);
+#endif
+	SET_IVOR(33, SPEFloatingPointData);
+	SET_IVOR(34, SPEFloatingPointRound);
+	SET_IVOR(35, PerformanceMonitor);
+	SET_IVOR(36, doorbell_exception);
+	SET_IVOR(37, CriticalDoorbell);
+
 	bl	early_init
 
 #ifdef CONFIG_RELOCATABLE
@@ -234,13 +261,6 @@ _ENTRY(__early_start)
  * Interrupt vectors must be aligned on a 16 byte boundary.
  * We align on a 32 byte cache line boundary for good measure.
  */
-
-/* Align 0x100 boundary for guest OS.
-#ifdef CONFIG_SMP
-	.align 9
-#else
-	.align 8
-#endif
 interrupt_base:
 	/* Critical Input Interrupt */
 	CRITICAL_EXCEPTION(0x0100, CriticalInput, unknown_exception)
@@ -675,6 +695,19 @@ KernelSPE:
 #endif /* CONFIG_SPE */
 
 /*
+ * Set the interrupt vector offset to the exec table
+ * r3 - the interrupt vector number
+ * r4 - the vector handler label
+*/
+set_exec_table:
+	lis	r5,exec_table@h
+	ori	r5,r5,exec_table@l
+	slwi	r3,r3,2
+	subis	r4,r4,PAGE_OFFSET@h
+	stwx	r4,r3,r5
+	blr
+
+/*
  * Global functions
  */
 
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index ac93256..fcc7dd3 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -129,7 +129,13 @@
 #include <vbi/vbi.h>
 #include <vbi/interface.h>
 
-VBI_EXC_OFFSETS_TABLE  exec_table;
+/*
+ * We will set the default interrupt handler address into exec_table before
+ * early_init, then adjust the interrupt handler in early_init according to
+ * the cpu type. Since the early_init will zero all the bss section, we can't
+ * put the exec_table in bss section.
+ */
+VBI_EXC_OFFSETS_TABLE  exec_table __attribute__((__section__(".data")));
 struct vb_config *wr_config;		/* TODO kernel relocation friendly ? */
 struct vb_control *wr_control;
 struct vb_status *wr_status;
@@ -1054,12 +1060,11 @@ void wrhv_MMU_setup(void)
 #endif
 }
 
-#define E500MC_DIR_EXC_INDEX	20
-#define E500MC_DIR_EXC_OFFSET	0x1600
-
 void __init wrhv_MMU_init(void)
 {
+#ifdef DEBUG
 	int i;
+#endif
 
 	if (ppc_md.progress)
 		ppc_md.progress("MMU:enter", 0x111);
@@ -1120,32 +1125,9 @@ void __init wrhv_MMU_init(void)
 		KERNEL_BASE_ASID, 0);
 #endif
 
-	vbi_get_exc_offset(&exec_table);
-#ifdef DEBUG
-	printk("****DUMP EXEC OFFSET***\n");
-	for(i=0;i<VBI_ARCH_MAX_EXC_OFFSETS;i++)
-		printk("execoffset:%d	----	0x%08x\n",i,exec_table.excOffset[i]);
-#endif 
-
-	for(i=0;i<VBI_ARCH_MAX_EXC_OFFSETS;i++)
-		if(exec_table.excOffset[i])
-			/*extend to 0x200, 9bits space*/
-			exec_table.excOffset[i] = exec_table.excOffset[i] << 1;
 	/* Check if enable direct interrupt mode. */
 	wrhv_enable_dir_irq();
 	
-	/* IVOR20 is dedicated to for direct interrupt offset
-	 * Here get 0x1600/0x2c00 from head_wrhv.s.
-	 */
-	if (wrhv_dir_irq) {
-		printk ("WRHV: guest OS is under Direct Interrupt mode.\n");
-#ifdef CONFIG_SMP
-		exec_table.excOffset[E500MC_DIR_EXC_INDEX] = E500MC_DIR_EXC_OFFSET << 1 ;
-#else
-		exec_table.excOffset[E500MC_DIR_EXC_INDEX] = E500MC_DIR_EXC_OFFSET;
-#endif
-	}
-
 	vbi_set_exc_offset(&exec_table);
 
 #ifdef DEBUG
-- 
1.7.0.2

