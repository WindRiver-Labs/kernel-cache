From 2095252650caa38f16658cd8aac19b8b13bf313c Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Wed, 17 Nov 2010 23:17:08 -0800
Subject: [PATCH 1/2] wrhv/gos: fix irq affinity issue on guest OS

After set irq affinity, cpu hotplug need to fixup irqs before
take a core offline. Consider following situation(take irq4
for example):

Set irq4's affinity to cpu1 then offline the cpu1. This will
cause GOS no longer receive irq4 after cpu1 offline'd. Since hyp
try to deliver irq4 to vcore1 of the VB but vcore1 was offline'd.

Before offline a cpu in GOS, we redirect irqs that bond to
victim cpu to BP of the VB.

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 arch/powerpc/kernel/vbi/wrhv.c |    2 ++
 arch/x86/kernel/vbi/wrhv.c     |    1 +
 include/linux/wrhv.h           |    3 +++
 kernel/vbi/wrhv.c              |   40 ++++++++++++++++++++++++++++++++++++++++
 4 files changed, 46 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 99e780d..6f30140 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -1804,6 +1804,8 @@ static int wrhv_cpu_disable(void)
 	if (cpu == boot_cpuid)
 		return -EBUSY;
 
+	wrhv_fixup_irqs(cpu);
+
 	wrhv_mask_IPIs_for_vcore();
 
 	set_cpu_online(cpu, false);
diff --git a/arch/x86/kernel/vbi/wrhv.c b/arch/x86/kernel/vbi/wrhv.c
index a5d94e3..95a2ae9 100644
--- a/arch/x86/kernel/vbi/wrhv.c
+++ b/arch/x86/kernel/vbi/wrhv.c
@@ -1460,6 +1460,7 @@ static int wrhv_cpu_disable(void)
 	if (cpu == 0)
 		return -EBUSY;
 
+	wrhv_fixup_irqs(cpu);
 	cpu_disable_common();
 
 	return 0;
diff --git a/include/linux/wrhv.h b/include/linux/wrhv.h
index 68a95b1..99d0032 100644
--- a/include/linux/wrhv.h
+++ b/include/linux/wrhv.h
@@ -24,6 +24,9 @@ extern struct irq_chip wrhv_irq_chip;
 extern struct irq_chip wrhv_ipi_irq_chip;
 #endif
 
+#ifdef CONFIG_HOTPLUG_CPU
+extern void wrhv_fixup_irqs(int);
+#endif
 /* IO APIC register get/set macros */
 /* Accesses are double words using an
  * indirect addressing scheme.
diff --git a/kernel/vbi/wrhv.c b/kernel/vbi/wrhv.c
index 95abed1..fba5b7b 100644
--- a/kernel/vbi/wrhv.c
+++ b/kernel/vbi/wrhv.c
@@ -26,6 +26,7 @@
 #include <linux/cpu.h>
 #include <linux/debugfs.h>
 #include <vbi/private.h>
+#include <linux/reboot.h>
 
 #define VIOAPIC_BASE_ADDR	(&wr_vb_control->vIoapic)
 
@@ -271,6 +272,45 @@ int wrhv_irq_set_affinity(unsigned int irq,
 
 	return 0;
 }
+
+#ifdef CONFIG_HOTPLUG_CPU
+void __weak wrhv_fixup_irqs(int cpu)
+{
+	unsigned int    irq;
+	struct irq_desc *desc;
+
+	printk(KERN_INFO "WRHV: reset irq to core0 on core%d\n", cpu);
+	for_each_irq_desc(irq, desc) {
+		struct cpumask *affinity;
+		int ret = 0;
+
+		if (!desc)
+			continue;
+
+		if (desc->status & IRQ_PER_CPU)
+			continue;
+
+		raw_spin_lock(&desc->lock);
+
+		affinity = desc->affinity;
+		cpumask_and(affinity, affinity, cpu_online_mask);
+		if (!irq_has_action(irq) ||
+		    cpumask_equal(affinity, cpu_online_mask) ||
+			!cpu_isset(cpu, *affinity)) {
+			raw_spin_unlock(&desc->lock);
+			continue;
+		}
+
+		if (desc->chip->set_affinity)
+			ret = desc->chip->set_affinity(irq, cpumask_of(0));
+
+		if (!ret)
+			cpumask_copy(desc->affinity, cpumask_of(0));
+
+		raw_spin_unlock(&desc->lock);
+	}
+}
+#endif /* CONFIG_HOTPLUG_CPU */
 #endif
 
 struct irq_chip wrhv_irq_chip = {
-- 
1.6.5.2

