From e67a553da60e46b4e1ff9ecdeae874e57551116d Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Tue, 12 Oct 2010 21:09:30 -0700
Subject: [PATCH] ppc-mc: support sparse irq as a common

Currently we cannot call VBI directly to support sparse irq with
the original implementation. So add those allocing irq descriptors
to the bottom function, request_threaded_irq().

Note we should not worry another path, setup_irq(), since on PPC it's
alway use the irq from our paravirted irq_of_parse_and_map()

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/kernel/irq.c      |    6 ++++++
 arch/powerpc/kernel/vbi/wrhv.c |   38 ++++++++++++++++++++++++++------------
 kernel/irq/manage.c            |   10 ++++++++--
 3 files changed, 40 insertions(+), 14 deletions(-)

diff --git a/arch/powerpc/kernel/irq.c b/arch/powerpc/kernel/irq.c
index 5805157..8bf1148 100644
--- a/arch/powerpc/kernel/irq.c
+++ b/arch/powerpc/kernel/irq.c
@@ -386,6 +386,12 @@ EXPORT_SYMBOL(handle_one_irq);
 EXPORT_SYMBOL(check_stack_overflow);
 #endif
 
+/* Weak this for Native Linux. */
+__weak struct irq_desc *wrhv_irq_to_desc(unsigned int irq)
+{
+	return NULL;
+}
+
 void paravirt_do_IRQ(struct pt_regs *regs) __attribute__((weak, alias("native_do_IRQ")));
 
 void do_IRQ(struct pt_regs *regs)
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 4d4b1c7..0ade39e 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -651,28 +651,42 @@ check_again:
 	trace_irq_exit(IRQ_HANDLED);
 }
 
+struct irq_desc * __ref wrhv_irq_to_desc(unsigned int irq)
+{
+	struct irq_desc *desc = irq_to_desc(irq);
+	if (desc)
+		return desc;
+
+#ifdef CONFIG_SPARSE_IRQ
+	desc = irq_to_desc_alloc_node(irq, 0);
+	if (unlikely(!desc)) {
+		pr_err("can't get irq_desc for irq%d\n", irq);
+		goto out;
+	}
+
+	desc->status = IRQ_DISABLED | IRQ_LEVEL;
+	desc->action = NULL;
+	desc->depth = 1;
+	set_irq_chip_and_handler(irq, &wrhv_irq_chip, handle_fasteoi_irq);
+out:	
+#endif
+	return desc;
+}
+EXPORT_SYMBOL(wrhv_irq_to_desc);
+
 unsigned int wrhv_map_irq_of_desc(char *irq_name, int32_t irq_dir)
 {
 	int irq;
-#ifdef CONFIG_SPARSE_IRQ
 	struct irq_desc *desc;
-#endif
 
 	irq = vbi_find_irq(irq_name, irq_dir);
 	if (irq == VBI_INVALID_IRQ)
 		return NO_IRQ;
 
-#ifdef CONFIG_SPARSE_IRQ
-	desc = irq_to_desc_alloc_node(irq, 0);
-	if (!desc) {
-		pr_debug("irq: -> allocating desc failed\n");
+	desc = wrhv_irq_to_desc(irq);
+	if (unlikely(!desc))
 		return NO_IRQ;
-	} 
-	desc->status = IRQ_DISABLED | IRQ_LEVEL;
-	desc->action = NULL;
-	desc->depth = 1;
-	set_irq_chip_and_handler(irq, &wrhv_irq_chip, handle_fasteoi_irq);
-#endif
+
 	return irq;
 }
 
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 26b1b7b..26342a8 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -1072,8 +1072,14 @@ int request_threaded_irq(unsigned int irq, irq_handler_t handler,
 		return -EINVAL;
 
 	desc = irq_to_desc(irq);
-	if (!desc)
-		return -EINVAL;
+	if (!desc) {
+#if defined(CONFIG_WRHV) && defined(CONFIG_PPC)
+		/* Re-check if someone call vbi to get irq directly on PPC. */
+		extern struct irq_desc *wrhv_irq_to_desc(unsigned int irq);
+		if (!wrhv_irq_to_desc(irq))
+#endif
+			return -EINVAL;
+	}
 
 	if (desc->status & IRQ_NOREQUEST)
 		return -EINVAL;
-- 
1.6.5.2

