From 76882260538cd1b529063aeb04be7bdcac98d9cd Mon Sep 17 00:00:00 2001
From: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
Date: Wed, 27 Oct 2010 18:21:44 -0700
Subject: [PATCH] ppc/85xx: Kernel userspace memory separation

Natively Linux marks pages 0xc0000000-0xcfffffff as supervisor WRX,
to provide protection from nefarious userspace processes which could
maliciously or inadvertently alter kernel code or data.  For example
writing random information into kernel space.  Given that the Linux
guest is running as a user process with the associated permissions
under the hypervisor, and thus no permission distinction between
userspace and kernel space exists.

There is only 1 bit in the MSR to distinguish between userspace
and kernel.  This is insufficient in order to provide protection for
3 different levels/rings. (Hypervisor, Linux Kernel, Linux Userspace)

By marking each kernel page with U0 it allows the hypervisor at each
TLB page fault to check whether the address which is being faulting on
is a kernel or user address.  To indicate a page is writable by the
kernel (0xc0000000-0xcfffffff) VMMU TLB word 0, U0 (bit 16) needs to
be set.  The hypervisor is responsible for checking this bit as a way
to distinguish kernel level permissions (U0 set) vs user level
permissions(U0 clear).

Below is the VMMU TLB bit mappings provided by the hypervisor.

 VMMU TLB Word 0:

  0 1            7 8           15 1 1 1 1 2 2 2 2 24   26 27  31
                                  6 7 8 9 0 1 2 3
 +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
 |V|  Hypervisor  |   Reserved   |U|U|U|U|U|U|U|U| ERPN  | ATTR |
 | |   Reserved   |              |0|1|2|3|4|5|6|7|       |      |
 +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+

 VMMU TLB Word 1:

  0                                19 20      23 2 2 2 2 2 2 3 3
                                                 4 5 6 7 8 9 0 1
 +-----------------------------------+----------+-+-+-+-+-+-+-+-+
 |                RPN                | Reserved |R|C|U|S|U|S|U|S|
 |                                   |          | | |X|X|W|W|R|R|
 +-----------------------------------+----------+-+-+-+-+-+-+-+-+

The hypervisor roughly performs the following logic to check if
a fault needs to be generated or not:

IF [U0 faulting addr. && U0 addr. running from]
   Guest running in supervisor mode trying to access kernel addr
   continue
ELSE
   fault
ENDIF

Signed-off-by: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
---
 arch/powerpc/kernel/vbi/wrhv.c |   17 +++++++++++++++++
 include/vbi/vmmu.h             |    1 +
 init/Kconfig.wrhv              |   12 ++++++++++++
 3 files changed, 30 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 11ea34e..550bdcb 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -1153,6 +1153,14 @@ out:
 	return (void __iomem *) (v + ((unsigned long)addr & ~PAGE_MASK));
 }
 
+#if defined(CONFIG_WRHV_GUEST_PROTECTION)
+/* In native Linux the kernel page table addresses are marked as supervisor
+ * RWX only.  So that the Linux guest can protect kernel memory space from
+ *  nefarious users the same range of pages need to be set. */
+#define KERNEL_MEMORY_START	(CONFIG_KERNEL_START)
+#define KERNEL_MEMORY_END	(CONFIG_KERNEL_START+0x0FFFFFFF)
+#endif
+
 /* From arch/powerpc/include/asm/pgtable.h */
 static inline void wrhv__set_pte_at(struct mm_struct *mm, unsigned long addr,
 				pte_t *ptep, pte_t pte, int percpu)
@@ -1213,9 +1221,18 @@ static inline void wrhv__set_pte_at(struct mm_struct *mm, unsigned long addr,
 #if defined(CONFIG_WRHV) && !defined(CONFIG_PPC85xx_VT_MODE)
 	/* linux does not use valid bit, hypervisor does, in word0 */
 	*(u_int *)ptep |= (u_int) VMMU_PTE_VALID_MASK;
+
+#if defined(CONFIG_WRHV_GUEST_PROTECTION)
+	/* The P4080 does not suffer from lack of protection like that
+	of the 8548 and 8572. */
+	if ((addr >= KERNEL_MEMORY_START) && (addr <= KERNEL_MEMORY_END))
+		*(u_int *)ptep |= (u_int) VMMU_PTE_SUPER_MASK;
+#endif
+
 #endif /* CONFIG_WRHV */
 
 #endif
+
 }
 
 static void wrhv_handle_debug(struct pt_regs *regs, unsigned long debug_status)
diff --git a/include/vbi/vmmu.h b/include/vbi/vmmu.h
index 52a24ba..96e42a1 100644
--- a/include/vbi/vmmu.h
+++ b/include/vbi/vmmu.h
@@ -275,6 +275,7 @@ VMMU_LEVEL_1_DESC *addr;
 #define	VMMU_PTE_ATTR_MASK	0x0000001f	/* page attributes */
 #define	VMMU_PTE_ERPN_MASK	0x000000e0	/* extended real page number */
 #define	VMMU_PTE_VALID_MASK	0x80000000	/* pte valid */
+#define	VMMU_PTE_SUPER_MASK	0x00008000	/* U0, bit 16 */
 
 /* word 1 */
 #define	VMMU_PTE_PERM_MASK	0x0000003f	/* page permissions */
diff --git a/init/Kconfig.wrhv b/init/Kconfig.wrhv
index 5cc80a8..792c2a0 100644
--- a/init/Kconfig.wrhv
+++ b/init/Kconfig.wrhv
@@ -12,3 +12,15 @@ config DEBUG_VIRTUAL_IRQS
 	bool "Debug VIOAPIC with software IRQ"
 	default n
 	depends on WRHV
+
+config WRHV_GUEST_PROTECTION
+	bool "Guest kernel memory separation and protection"
+	default y
+	depends on WRHV
+	help
+	   Memory separation and protection between kernel and userspace.
+	   Warning, please exercise caution when disabling this option
+	   as it will allow userspace processes to directly read and write
+	   kernel memory.
+
+	   Don't change this option unless you know what you are doing.
-- 
1.6.5.2

