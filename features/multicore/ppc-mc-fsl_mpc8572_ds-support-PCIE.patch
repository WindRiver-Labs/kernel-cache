From 18e472fae1af863dbfae15e93ad825d93de2e093 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Wed, 28 Jul 2010 20:02:00 -0700
Subject: [PATCH] ppc-mc/fsl_mpc8572_ds: support PCIE

Add the law configuration function like fsl_p4080 since we should
configure law for PCIE space if necessary. And fix one small typo
while setting target_id to law attribute filed.

And define one function with DECLARE_PCI_FIXUP_EARLY to clean those
previous BASE setting from the bootloader. You know we should set
them as guest OS expect.

We should do only for PCI/PCIe devices, not for the PCI/PCIe contorller(bridge)
existed on the target platform. Because BASE0 existed on PCI controller is used
for the default no.0 InBound window fixed with 16M space to access CCSRBAR,
0xfe000000. If we clean this as '0' this means the PCI window base address is
'0'. Then the dma address 0x_xxxxxx < 16M from PCI/PCIe device would be
converted to 0x_fexxxxxx for the internal memory with this inBound Window.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/kernel/vbi/wrhv.c |   16 +++++++++++++++-
 1 files changed, 15 insertions(+), 1 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 550bdcb..4edafdc 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -506,7 +506,7 @@ int ppc_setup_pci_law( struct device_node *dev)
 			printk(KERN_INFO "  Setup LAW for PCIE Space  0x%016llx..0x%016llx \n", 
 					cpu_addr, cpu_addr + size - 1);
 
-			attr = LAW_EN | (pcie_index < 20) | (__ilog2(size) - 1) ;
+			attr = LAW_EN | (pcie_index << 20) | (__ilog2(size) - 1) ;
 			ppc_setup_law(pcie_index, cpu_addr, attr);
 		}
 	}
@@ -1926,6 +1926,20 @@ void pci_msi_disable(struct pci_dev *dev)
 	}
 }
 DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, pci_msi_disable);
+/* Clean those previous BASE set since we'll re-configure these for guest OS. */
+void wrhv_pci_fixup_resource(struct pci_dev* dev)
+{
+	/* Only do for PCIe devices, not for any Bridge. */
+	if (dev->hdr_type == PCI_HEADER_TYPE_NORMAL) {
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0);
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_1, 0);
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_2, 0);
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_3, 0);
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_4, 0);
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_5, 0);
+	}
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_ANY_ID, PCI_ANY_ID, wrhv_pci_fixup_resource);
 #endif
 
 /* interface to wrhv duart actual device driver */
-- 
1.6.5.2

