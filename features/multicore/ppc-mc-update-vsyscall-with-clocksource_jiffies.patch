From b4bc1db52f4e27fd72d20683ad55c6637937b702 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Fri, 16 Jul 2010 23:26:29 -0700
Subject: [PATCH] ppc-mc: update vsyscall with clocksource_jiffies

On current PPC guest OS we don't register clocksource_timebase so
we will miss update_vsyscall(). As a result it's always failed to
get/set system time via VDSO.

So here paravirt update_vsyscall to use clocksource_jiffies to sync
vsyscall on PPC. And it's unnecessary to convert mult to convert mult
and stamp_xsec for clocksource_jiffies.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/include/asm/paravirt.h |    7 +++++
 arch/powerpc/kernel/paravirt.c      |    9 ++++++
 arch/powerpc/kernel/time.c          |   10 +++++++
 arch/powerpc/kernel/vbi/wrhv.c      |   50 +++++++++++++++++++++++++++++++++++
 4 files changed, 76 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/include/asm/paravirt.h b/arch/powerpc/include/asm/paravirt.h
index 1be7130..df1f14d 100644
--- a/arch/powerpc/include/asm/paravirt.h
+++ b/arch/powerpc/include/asm/paravirt.h
@@ -34,6 +34,8 @@ extern int native_fsl_pq_mdio_write(struct mii_bus *bus, int mii_id,
 					int devad, int regnum, u16 value);
 extern int native_fsl_pq_mdio_read(struct mii_bus *bus, int mii_id,
 					int devad, int regnum);
+#include <linux/clocksource.h>
+extern void native_update_vsyscall(struct timespec *wall_time, struct clocksource *clock, u32 mult);
 
 /*
  * paravirtual operations structure
@@ -97,12 +99,17 @@ struct pv_mdio_ops {
 					int devad, int regnum);
 };
 
+struct pv_vdso_ops {
+	void (*update_vsyscall)(struct timespec *ts, struct clocksource *c, u32 mult);
+};
+
 extern struct pv_info pv_info;
 extern struct pv_time_ops pv_time_ops;
 extern struct pv_cpu_ops pv_cpu_ops;
 extern struct pv_irq_ops pv_irq_ops;
 extern struct pv_mmu_ops pv_mmu_ops;
 extern struct pv_mdio_ops pv_mdio_ops;
+extern struct pv_vdso_ops pv_vdso_ops;
 
 #endif /* CONFIG_PARAVIRT */
 #endif	/* __ASM_PARAVIRT_H */
diff --git a/arch/powerpc/kernel/paravirt.c b/arch/powerpc/kernel/paravirt.c
index a144c72..cdb2357 100644
--- a/arch/powerpc/kernel/paravirt.c
+++ b/arch/powerpc/kernel/paravirt.c
@@ -149,6 +149,10 @@ struct pv_mdio_ops pv_mdio_ops = {
 	.fsl_pq_mdio_read	= native_fsl_pq_mdio_read,
 };
 
+struct pv_vdso_ops pv_vdso_ops = {
+	.update_vsyscall	= native_update_vsyscall,
+};
+
 /* pv_time_ops */
 void __init paravirt_time_init_cont(void)
 {
@@ -165,6 +169,11 @@ void __init paravirt_clocksource_init(void)
 	pv_time_ops.clocksource_init();
 }
 
+void paravirt_update_vsyscall(struct timespec *wall_time, 
+		struct clocksource *clock, u32 mult)
+{
+	pv_vdso_ops.update_vsyscall(wall_time, clock, mult);
+}
 
 /* pv_irq_ops */
 void paravirt_do_IRQ(struct pt_regs *regs)
diff --git a/arch/powerpc/kernel/time.c b/arch/powerpc/kernel/time.c
index 4800525..ea15138 100644
--- a/arch/powerpc/kernel/time.c
+++ b/arch/powerpc/kernel/time.c
@@ -886,9 +886,19 @@ static cycle_t timebase_read(struct clocksource *cs)
 	return (cycle_t)get_tb();
 }
 
+void paravirt_update_vsyscall(struct timespec *wall_time, struct clocksource *clock, 
+					u32 mult)
+	__attribute__((weak, alias("native_update_vsyscall")));
+
 void update_vsyscall(struct timespec *wall_time, struct clocksource *clock,
 		     u32 mult)
 {
+	paravirt_update_vsyscall(wall_time, clock, mult);
+}
+
+void native_update_vsyscall(struct timespec *wall_time, struct clocksource *clock,
+		     u32 mult)
+{
 	u64 t2x, stamp_xsec;
 
 	if (clock != &clocksource_timebase)
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 2288d8c..228d938 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -117,6 +117,8 @@
 #include <linux/clocksource.h>
 #include <linux/kgdb.h>
 
+#include <asm/vdso_datapage.h>
+
 #include <asm/cputhreads.h>
 #include <linux/irq.h>
 #include <asm/tlb.h>
@@ -762,6 +764,53 @@ void wrhv_hw_timer_interrupt(struct pt_regs * regs)
 	trace_timer_interrupt_exit(regs);
 }
 
+/* Refer to the file, arch/powerpc/kernel/time.c. */
+#define WRHV_XSEC_PER_SEC (1024*1024)
+static inline void wrhv_update_gtod(u64 new_tb_stamp, u64 new_stamp_xsec,
+			       u64 new_tb_to_xs)
+{
+	/*
+	 * tb_update_count is used to allow the userspace gettimeofday code
+	 * to assure itself that it sees a consistent view of the tb_to_xs and
+	 * stamp_xsec variables.  It reads the tb_update_count, then reads
+	 * tb_to_xs and stamp_xsec and then reads tb_update_count again.  If
+	 * the two values of tb_update_count match and are even then the
+	 * tb_to_xs and stamp_xsec values are consistent.  If not, then it
+	 * loops back and reads them again until this criteria is met.
+	 * We expect the caller to have done the first increment of
+	 * vdso_data->tb_update_count already.
+	 */
+	vdso_data->tb_orig_stamp = new_tb_stamp;
+	vdso_data->stamp_xsec = new_stamp_xsec;
+	vdso_data->tb_to_xs = new_tb_to_xs;
+	vdso_data->wtom_clock_sec = wall_to_monotonic.tv_sec;
+	vdso_data->wtom_clock_nsec = wall_to_monotonic.tv_nsec;
+	vdso_data->stamp_xtime = xtime;
+	smp_wmb();
+	++(vdso_data->tb_update_count);
+}
+
+extern struct clocksource clocksource_jiffies;
+void wrhv_update_vsyscall(struct timespec *wall_time, struct clocksource *clock,
+		     u32 mult)
+{
+	u64 t2x, stamp_xsec;
+
+	/* PPC guest OS update vsyscall against clocksource_jiffies. */
+	if (clock != &clocksource_jiffies)
+		return;
+
+	/* Make userspace gettimeofday spin until we're done. */
+	++vdso_data->tb_update_count;
+	smp_mb();
+
+	t2x = (u64) mult;
+	stamp_xsec = (u64) xtime.tv_nsec * WRHV_XSEC_PER_SEC;
+	do_div(stamp_xsec, 1000000000);
+	stamp_xsec += (u64) xtime.tv_sec * WRHV_XSEC_PER_SEC;
+	wrhv_update_gtod(clock->cycle_last, stamp_xsec, t2x);
+}
+
 void __init wrhv_clocksource_init(void)
 {
 	return;
@@ -1367,6 +1416,7 @@ void wrhv_init(void)
 	pv_time_ops.time_init_cont = wrhv_time_init_cont;
 	pv_time_ops.timer_interrupt = wrhv_hw_timer_interrupt;
 	pv_time_ops.clocksource_init = wrhv_clocksource_init;
+	pv_vdso_ops.update_vsyscall = wrhv_update_vsyscall;
 
 	pv_irq_ops.do_IRQ = wrhv_do_IRQ;
 	pv_irq_ops.irq_of_parse_and_map =
-- 
1.6.5.2

