From 6e7405fb14ae4ce3d841315d1934e4a9296150c4 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Fri, 12 Nov 2010 01:13:44 -0800
Subject: [PATCH] update current mm pgd entry when kernel pgd changed

In ppc e500 guest os, kernel will copy init process kernel page
table to current process when process switching to make sure process
has the correct kernel page table. But if there is no process switching
when kernel changes kernel page table via ioremap and vmalloc the
current process will get the incorrect kernel page table. For example,
a kernel module map a memory area via ioremap or vmalloc, then access
this area, the current process will have the incorrect kernel page table
if there is no process switching.

currently a function wrhv___ioremap() is used to fix ioremap issue, but
vmalloc is still not covered, not to mention other kernel space allocation
function such as set_fixmap. But no matter which high level functions is
called, function map_page() or vmap_page_range_noflush() will be called
finally, so here we fix up current process pgd entry in these two functions
to make kernel safe.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/powerpc/kernel/vbi/wrhv.c |    6 ++++++
 mm/vmalloc.c                   |    5 +++++
 2 files changed, 11 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 25eec50..99e780d 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -1062,6 +1062,12 @@ int wrhv_map_page(unsigned long va, phys_addr_t pa, int flags)
 		BUG_ON(pte_val(*pg) & (_PAGE_PRESENT | _PAGE_HASHPTE));
 		set_pte_at(&init_mm, va, pg, pfn_pte(pa >> PAGE_SHIFT,
 						     __pgprot(flags)));
+#if defined(CONFIG_WRHV_E500) && !defined(CONFIG_PHYS_64BIT) \
+			      && !defined(CONFIG_PPC85xx_VT_MODE)
+		if (current->active_mm != &init_mm)
+			*pgd_offset(current->active_mm, va) =
+						*pgd_offset_k(va);
+#endif
 	}
 
 	return err;
diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index 9a76c46..bd4e698 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -170,6 +170,11 @@ static int vmap_page_range_noflush(unsigned long start, unsigned long end,
 		err = vmap_pud_range(pgd, addr, next, prot, pages, &nr);
 		if (err)
 			return err;
+#if defined(CONFIG_WRHV_E500) && !defined(CONFIG_PHYS_64BIT) \
+			      && !defined(CONFIG_PPC85xx_VT_MODE)
+		if (current->active_mm != &init_mm)
+			*pgd_offset(current->active_mm, addr) = *pgd;
+#endif
 	} while (pgd++, addr = next, addr != end);
 
 	return nr;
-- 
1.6.5.2

