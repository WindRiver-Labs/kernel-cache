From 90dfa08a311b9fd4b342e3997b4e8947206c95ee Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Tue, 2 Aug 2011 16:40:21 +0800
Subject: [PATCH 2/2] wrhv: x86: paravirt emgd for intel-atom-z530 board

SCH on atom-z530 target dose not support VT-d hence memory
management code of emgd need be tweaked to fit with wrhv. This
actually enables accelerated graphics for GMA500 on z530 GOS.

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 .../gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c  |    9 +++++++++
 drivers/gpu/drm/emgd/emgd/gmm/gmm.c                |   16 ++++++++++++++++
 drivers/gpu/drm/emgd/emgd/gmm/gtt.c                |   13 ++++++++++---
 .../emgd/pvr/services4/system/common/sysconfig.c   |   10 ++++++++++
 4 files changed, 45 insertions(+), 3 deletions(-)

diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c b/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c
index d5eef1f..39ee5b1 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c
@@ -59,6 +59,12 @@
 #include <linux/spinlock.h>
 #include <drm/drmP.h>
 
+#if defined(CONFIG_WRHV)
+extern u64 wrhv_phys_offset;
+#define phys_offset wrhv_phys_offset
+#else
+static u64 phys_offset = 0;
+#endif
 
 /* Registered VBlank interrupt callbacks (one-per-pipe): */
 static emgd_vblank_callback_t interrupt_callbacks_plb[IGD_MAX_PORTS] =
@@ -678,6 +684,9 @@ static void program_cursor_plb(igd_display_context_t *display,
 
 	WRITE_MMIO_REG(display, cursor_reg,
 		cursor_control | (PIPE(display)->pipe_num<<28));
+
+	cursor_base += phys_offset;
+
 	WRITE_MMIO_REG(display, cursor_reg + CUR_BASE_OFFSET, cursor_base);
 }
 
diff --git a/drivers/gpu/drm/emgd/emgd/gmm/gmm.c b/drivers/gpu/drm/emgd/emgd/gmm/gmm.c
index ce65ba1..4b1dd37 100644
--- a/drivers/gpu/drm/emgd/emgd/gmm/gmm.c
+++ b/drivers/gpu/drm/emgd/emgd/gmm/gmm.c
@@ -39,6 +39,13 @@
 
 #include <asm/agp.h>
 
+#if defined(CONFIG_WRHV)
+extern u64 wrhv_phys_offset;
+#define phys_offset wrhv_phys_offset
+#else
+static u64 phys_offset = 0;
+#endif
+
 #define AGP_PHYS_MEMORY 2 /* Physical contigous memory */
 
 
@@ -280,6 +287,13 @@ static int gmm_virt_to_phys(unsigned long offset,
 	while (chunk) {
 		if (chunk->offset == offset) {
 			*physical = chunk->gtt_mem->physical;
+
+			/*
+			 * below change is paired with the change to
+			 * emgd_alloc_pages in gtt.c
+			 */
+			*physical -= phys_offset;
+
 			EMGD_DEBUG("Physical address = 0x%08lx", *physical);
 			EMGD_TRACE_EXIT;
 			return 0;
@@ -752,6 +766,7 @@ static int gmm_alloc_chunk_space(gmm_context_t *gmm_context,
 	 */
 	if (chunk->gtt_mem->physical == 0x0) {
 		chunk->gtt_mem->physical = page_to_phys(chunk->gtt_mem->pages[0]);
+		chunk->gtt_mem->physical += phys_offset;
 	}
 
 	*offset = chunk->offset;
@@ -801,6 +816,7 @@ static int gmm_get_page_list(unsigned long offset,
 	/* Populate the array with the starting addresses of the pages: */
 	for (i = 0; i < *page_cnt; i++) {
 		chunk->page_addresses[i] = page_to_phys(chunk->gtt_mem->pages[i]);
+		chunk->page_addresses[i] += phys_offset;
 	}
 
 	*pages = chunk->page_addresses;
diff --git a/drivers/gpu/drm/emgd/emgd/gmm/gtt.c b/drivers/gpu/drm/emgd/emgd/gmm/gtt.c
index aee1130..30585e9 100644
--- a/drivers/gpu/drm/emgd/emgd/gmm/gtt.c
+++ b/drivers/gpu/drm/emgd/emgd/gmm/gtt.c
@@ -36,6 +36,13 @@
 #include <asm/cacheflush.h>
 #include <linux/version.h>
 
+#if defined(CONFIG_WRHV)
+extern u64 wrhv_phys_offset;
+#define phys_offset wrhv_phys_offset
+#else
+static u64 phys_offset = 0;
+#endif
+
 #define PFX "EMGD: "
 
 #define SCR1	0x71410 /* scratch register set by vbios indicating status*/
@@ -293,7 +300,7 @@ gmm_mem_buffer_t *emgd_alloc_pages(unsigned long num_pages, int type) {
 					mem->pages[i] = mem->pages[i-1] + 1;
 				}
 			}
-			mem->physical = page_to_phys(mem->pages[0]);
+			mem->physical = page_to_phys(mem->pages[0]) + phys_offset;
 			mem->page_count = num_pages;
 		}
 	}
@@ -372,7 +379,7 @@ void emgd_gtt_insert(igd_context_t *context,
 		}
 
 		/* Mark the page as valid */
-		pte = page_to_phys(page) | PSB_PTE_VALID;
+		pte = (page_to_phys(page) + phys_offset) | PSB_PTE_VALID;
 		writel(pte, (context->device_context.virt_gttadr + j));
 		readl(context->device_context.virt_gttadr + j);
 
@@ -416,7 +423,7 @@ void emgd_gtt_remove(igd_context_t *context,
 	mutex_lock(&gtt_sem);
 
 	page = context->device_context.scratch_page;
-	pte = page_to_phys(page) | PSB_PTE_VALID;
+	pte = (page_to_phys(page) + phys_offset) | PSB_PTE_VALID;
 
 	/* Insert the scratch page into the GTT */
 	for (i = pg_start; i < (mem->page_count + pg_start); i++) {
diff --git a/drivers/gpu/drm/emgd/pvr/services4/system/common/sysconfig.c b/drivers/gpu/drm/emgd/pvr/services4/system/common/sysconfig.c
index 2967051..4f2f0ab 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/system/common/sysconfig.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/system/common/sysconfig.c
@@ -50,6 +50,12 @@
 #include "sysconfig.h"
 #include "pvr_debug.h"
 #include "msvdx_pvr.h"
+#if defined(CONFIG_WRHV)
+extern u64 wrhv_phys_offset;
+#define phys_offset wrhv_phys_offset
+#else
+static u64 phys_offset = 0;
+#endif
 
 /* --------------------------------------------------------------------------*/
 /**
@@ -1154,6 +1160,7 @@ IMG_DEV_PHYADDR SysCpuPAddrToDevPAddr (PVRSRV_DEVICE_TYPE eDeviceType,
 
 
 	DevPAddr.uiAddr = CpuPAddr.uiAddr;
+	DevPAddr.uiAddr += phys_offset;
 
 	return DevPAddr;
 }
@@ -1165,6 +1172,9 @@ IMG_CPU_PHYADDR SysSysPAddrToCpuPAddr (IMG_SYS_PHYADDR sys_paddr)
 
 
 	cpu_paddr.uiAddr = sys_paddr.uiAddr;
+	if (cpu_paddr.uiAddr < ((num_physpages << PAGE_SHIFT) + phys_offset))
+			cpu_paddr.uiAddr -= phys_offset;
+
 	return cpu_paddr;
 }
 
-- 
1.7.0.2

