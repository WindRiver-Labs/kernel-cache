From 4d23fa9a75d26c53da1d18a3bd627593553baa9f Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Thu, 22 Jul 2010 17:50:10 +0800
Subject: [PATCH 7/7] wrhv/powerpc: add cpu hotplug support for GOS

powerpc common part for support cpu hotplug and some minor
code cleanup

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 arch/powerpc/kernel/vbi/wrhv.c |  236 ++++++++++++++++++++++++----------------
 1 files changed, 142 insertions(+), 94 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 228d938..c2b26e9 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -303,7 +303,7 @@ unsigned long __init wrhv_find_end_of_memory(void)
 	return wr_config->phys_mem_size;
 }
 
-int wrhv_early_init_dt_scan_memory_ppc(unsigned long node,
+int __init wrhv_early_init_dt_scan_memory_ppc(unsigned long node,
 			const char *uname, int depth, void *data)
 {
 	/* instead of using the memory size from
@@ -328,24 +328,37 @@ void wrhv_power_save(void)
 	vbi_idle(1);
 }
 
-void wrhv_restart(char *cmd)
+static void wrhv_do_restart(void *data)
 {
 	int ret;
-	printk(KERN_INFO "WRHV: rebooting \n");
+	int cpu = smp_processor_id();
+
+	if (!cpu) {
+		printk(KERN_INFO "WRHV: rebooting \n");
+
+		ret = vbi_vb_reset(VBI_BOARD_ID_GET(), VBI_VB_CORES_ALL,
+				VBI_VBMGMT_RESET_AND_START_CORE0 |
+				VBI_VBMGMT_RESET_DOWNLOAD
+				);
 
-	ret = vbi_vb_reset(VBI_BOARD_ID_GET(), VBI_VB_CORES_ALL,
-		VBI_VBMGMT_RESET_AND_START_CORE0 |
-		VBI_VBMGMT_RESET_DOWNLOAD |
-		VBI_VBMGMT_RESET_CLEAR
-		);
+		if (ret)
+			printk(KERN_ERR "WRHV: reboot failed. ret = %d\n", ret);
+	}
+}
 
-	if (unlikely(ret != 0))
-		printk(KERN_ERR "WRHV: reboot failed. \n");
+void wrhv_restart(char *cmd)
+{
+	int cpu = smp_processor_id();
+
+	if (!cpu)
+		wrhv_do_restart(NULL);
+	else
+		smp_call_function(wrhv_do_restart, NULL, 1);
 
 	while (1);
 }
 
-void __init wrhv_calibrate_decr(void)
+void __devinit wrhv_calibrate_decr(void)
 {
 	/* The timebase is updated every 8 bus clocks */
 	ppc_tb_freq = wrhv_cpu_freq / 8;
@@ -1450,6 +1463,7 @@ void wrhv_init(void)
 VBI_HREG_SET_CMPLX_QUALIFIED bootREG;
 #define IPI_IRQ_BASE_NAME "ipi0"
 int irq_base = 0xFFFF; /*init as invalid IRQ number*/
+#define WRHV_IPI_NUM      4
 
 DEFINE_PER_CPU(long long, tb_diff);
 
@@ -1472,59 +1486,58 @@ static irqreturn_t wrhv_ipi_action(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-void __init smp_wrhv_setup_cpu(int cpu_nr)
+void __devinit smp_wrhv_setup_cpu(int cpu_nr)
 {
 	return;
 }
 
+static void wrhv_mask_IPIs_for_vcore(void)
+{
+	int i;
+
+	for (i = 0; i < WRHV_IPI_NUM; i++)
+		vbi_mask_vioapic_irq(irq_base + i);
+}
+
 void wrhv_umask_IPIs_for_vcore(void)
 {
 	int i;
 
-	for (i = 0; i < 4; i++) {
-		 vbi_unmask_vioapic_irq(irq_base+i);
-	}
+	for (i = 0; i < WRHV_IPI_NUM; i++)
+		vbi_unmask_vioapic_irq(irq_base + i);
 }
 
 void wrhv_request_ipis(void)
 {
-/* Need call vbiIntVecFind to get IPI IRQ numbers
- * from Hypervisor configuration. So comment out
- * this temprorily.
- * IPI0 (call function)		irq_base
- * IPI1 (reschedule)		irq_base+1
- * IPI2 (call function single)	irq_base+2
- * IPI3 (debugger break)	irq_base+3
- */
 	static char *ipi_names[] = {
 		"IPI0 (call function)",
 		"IPI1 (reschedule)",
 		"IPI2 (call function single)",
 		"IPI3 (debugger break)",
 	};
-	int i,err;
+	int i, err;
 
 	printk(KERN_INFO "WRHV requesting IPIs ... \n");
-	
+
 	irq_base = wrhv_map_irq_of_desc(IPI_IRQ_BASE_NAME, VB_INPUT_INT);
 	if (irq_base == VBI_INVALID_IRQ)
 		panic("WRHV reslove irq for IPI failed.\n");
 
-	for (i = 0; i < 4; i++) {
-		set_irq_chip_and_handler_name(irq_base+i,
-			&wrhv_ipi_irq_chip, handle_percpu_irq, "per_cpu");
+	for (i = 0; i < WRHV_IPI_NUM; i++) {
+		set_irq_chip_and_handler_name(irq_base + i,
+				&wrhv_ipi_irq_chip, handle_percpu_irq, "per_cpu");
 
-		err = request_irq(irq_base+i, wrhv_ipi_action,
-				  IRQF_DISABLED|IRQF_PERCPU,
-				  ipi_names[i], (void *)i);
+		err = request_irq(irq_base + i, wrhv_ipi_action,
+				IRQF_DISABLED | IRQF_PERCPU | IRQF_NOBALANCING,
+				ipi_names[i], (void *)i);
 		if (err) {
-			printk(KERN_ERR "WRHV Request of irq %d for IPI(%s) failed\n", 
-				irq_base+i,ipi_names[i]);
-			if (i) {
-				while (--i)
-					free_irq(irq_base+i, wrhv_ipi_action);	
-			}
-			break;
+			printk(KERN_ERR "WRHV Request of irq %d for %s failed\n",
+					irq_base + i, ipi_names[i]);
+			/*
+			 * There is no really clean work here. The best choice
+			 * here might panic() immediately
+			 */
+			panic("WRHV: request_irq for IPI faild.\n");
 		}
 	}
 }
@@ -1539,10 +1552,10 @@ int __init smp_wrhv_probe(void)
 
 	pr_debug("nr_cpus: %d\n", nr_cpus);
 
-	if (nr_cpus > 1)
+	if (nr_cpus > 1) {
 		wrhv_request_ipis();
-
-	wrhv_umask_IPIs_for_vcore();
+		wrhv_umask_IPIs_for_vcore();
+	}
 
 	return nr_cpus;
 }
@@ -1560,51 +1573,42 @@ static inline void wrhv_send_IPI_mask(int irq, cpumask_t mask)
 
 void smp_wrhv_message_pass(int target, int msg)
 {
-  
+	cpumask_t mask, dst;
+	int self = smp_processor_id();
+
 	/* make sure we're sending something that translates to an IPI */
-	if ((unsigned int)msg > 3) {
-		printk("SMP %d: smp_message_pass: unknown msg %d\n",
-		       smp_processor_id(), msg);
+	if (msg > 3) {
+		printk(KERN_INFO "SMP %d: smp_message_pass: unknown msg %d\n",
+				smp_processor_id(), msg);
 		return;
 	}
 
 	switch (target) {
-	case MSG_ALL:{
-		cpumask_t mask,dst;
-		
-		cpus_setall(dst);
-		cpus_and(mask, dst, cpu_online_map);
-		wrhv_send_IPI_mask(msg+irq_base,mask);
-
-		break;
-		}
-	case MSG_ALL_BUT_SELF:{
-		cpumask_t mask,dst;
-		int self = smp_processor_id();
-		
-		cpus_setall(dst);
-		cpu_clear(self,dst);
-		cpus_and(mask, dst, cpu_online_map);
-		wrhv_send_IPI_mask(msg+irq_base,mask);
-		break;
-		}
-	default:{
-		cpumask_t mask,dst;
-		cpus_clear(dst);
-		cpu_set(target,dst);
-		cpus_and(mask, dst, cpu_online_map);
-		wrhv_send_IPI_mask(msg+irq_base,mask);
-		break;
-		}
+		case MSG_ALL:
+			cpus_setall(dst);
+			cpus_and(mask, dst, cpu_online_map);
+			wrhv_send_IPI_mask(msg + irq_base,mask);
+			break;
+		case MSG_ALL_BUT_SELF:
+			cpus_setall(dst);
+			cpu_clear(self, dst);
+			cpus_and(mask, dst, cpu_online_map);
+			wrhv_send_IPI_mask(msg + irq_base, mask);
+			break;
+		default:
+			cpus_clear(dst);
+			cpu_set(target, dst);
+			cpus_and(mask, dst, cpu_online_map);
+			wrhv_send_IPI_mask(msg + irq_base, mask);
+			break;
 	}
 }
 
-static void __init  smp_wrhv_kick_cpu(int nr)
+static void __devinit smp_wrhv_kick_cpu(int nr)
 {
 	unsigned long flags;
 	int32_t ret;
 	
-
 	int n = 0;
 	WARN_ON (nr < 0 || nr >= NR_CPUS);
 
@@ -1612,36 +1616,88 @@ static void __init  smp_wrhv_kick_cpu(int nr)
 
 	bootREG.vbiRegType = VBI_REG_SET_32BIT;
 
-	ret=vbi_vb_read_reg(&bootREG, VBI_BOARD_ID_GET(), nr);
-	if(ret)
-		printk("WRHV read REG failed:%d\n",ret);
+	ret = vbi_vb_read_reg(&bootREG, VBI_BOARD_ID_GET(), nr);
+	if (ret)
+		printk(KERN_ERR "WRHV read REG failed: %d\n", ret);
 
 	bootREG.vbiRegType = VBI_REG_SET_32BIT;
 	bootREG.vbiRegSet.hreg32.pc = 0xc0000000;
+#ifdef CONFIG_PPC85xx_VT_MODE
+	bootREG.vbiRegSet.hreg32.msr = 0x10000000;
+#endif
 
-	ret=vbi_vb_write_reg(&bootREG, VBI_BOARD_ID_GET(), nr);
-	if(ret)
-		printk("WRHV write REG failed:%d\n",ret);
+	ret = vbi_vb_write_reg(&bootREG, VBI_BOARD_ID_GET(), nr);
+	if (ret)
+		printk(KERN_ERR "WRHV write REG failed: %d\n", ret);
 
-	ret=vbi_vb_resume(VBI_BOARD_ID_GET(), nr);
-	if(ret)
-		printk("WRHV resume CPU failed:%d\n",ret);
+	ret = vbi_vb_resume(VBI_BOARD_ID_GET(), nr);
+	if (ret)
+		printk(KERN_ERR "WRHV resume CPU failed: %d\n", ret);
 
 	/* Wait a bit for the CPU to ack. */
 	while ((__secondary_hold_acknowledge != nr) && (++n < 1000))
 		mdelay(1);
 
 	local_irq_restore(flags);
-
 }
 
 unsigned long mpc85xx_smp_message[NR_CPUS]; /*fix doorbell_exception link error */
 
+#ifdef CONFIG_HOTPLUG_CPU
+DECLARE_PER_CPU(int, cpu_state);
+void cpu_die(void)
+{
+	unsigned int cpu;
+	int ret;
+
+	idle_task_exit();
+
+	local_irq_disable();
+	cpu = smp_processor_id();
+	printk(KERN_DEBUG "CPU%d offline\n", cpu);
+	__get_cpu_var(cpu_state) = CPU_DEAD;
+	smp_wmb();
+
+	preempt_enable();
+	ret = vbi_vb_suspend(VBI_BOARD_ID_GET(), cpu);
+	if (ret)
+		printk(KERN_ERR "%s: suspend result: %d\n", __func__, ret);
+
+	while (1);
+}
+
+static int wrhv_cpu_disable(void)
+{
+	int cpu = smp_processor_id();
+	printk(KERN_INFO "%s: cpu = %d\n", __func__, cpu);
+
+	if (cpu == boot_cpuid)
+		return -EBUSY;
+
+	wrhv_mask_IPIs_for_vcore();
+
+	set_cpu_online(cpu, false);
+
+	return 0;
+}
+
+static int wrhv_cpu_enable(unsigned int cpu)
+{
+	printk(KERN_INFO "%s: cpu = %d\n", __func__, cpu);
+
+	if (system_state != SYSTEM_RUNNING)
+		return -ENOSYS;
+
+	return 1;
+}
+
+#endif
+
 struct smp_ops_t smp_wrhv_ops = {
 	.kick_cpu = smp_wrhv_kick_cpu,
 #if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PPC32)
-	.cpu_enable = generic_cpu_enable,
-	.cpu_disable = generic_cpu_disable,
+	.cpu_enable  = wrhv_cpu_enable,
+	.cpu_disable = wrhv_cpu_disable,
 	.cpu_die = generic_cpu_die,
 #endif
 	.probe = smp_wrhv_probe,
@@ -1649,14 +1705,6 @@ struct smp_ops_t smp_wrhv_ops = {
 	.setup_cpu = smp_wrhv_setup_cpu,
 };
 
-#if defined(CONFIG_HOTPLUG_CPU)
-void cpu_die(void)
-{
-	if (smp_ops->cpu_die)
-	smp_ops->cpu_die(smp_processor_id());
-}
-#endif
-
 void __init wrhv_smp_init(void)
 {
 	smp_ops = &smp_wrhv_ops;
-- 
1.6.5.2

