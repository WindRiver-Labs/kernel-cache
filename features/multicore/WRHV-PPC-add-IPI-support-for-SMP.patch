From ca3dc953bee539fd0201b0eeef4ae56537e64e0e Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Wed, 12 May 2010 16:39:50 +0800
Subject: [PATCH 11/14] WRHV/PPC: add IPI support for SMP

Via a guest OS specific smpops, this implements IPI functionality
via the hypervisor vioapic interface.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/include/asm/wrhv.h |    5 ++
 arch/powerpc/kernel/vbi/wrhv.c  |  140 +++++++++++++++++++++++++++++++++++++++
 2 files changed, 145 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/include/asm/wrhv.h b/arch/powerpc/include/asm/wrhv.h
index 334dbe7..01ea5f7 100644
--- a/arch/powerpc/include/asm/wrhv.h
+++ b/arch/powerpc/include/asm/wrhv.h
@@ -28,6 +28,11 @@ extern void __init wrhv_calibrate_decr(void);
 extern void __init wrhv_time_init(void);
 extern int __init wrhv_earlycon_setup(void);
 
+extern int __init smp_wrhv_probe(void);
+extern void smp_wrhv_message_pass(int target, int msg);
+extern void __init smp_wrhv_setup_cpu(int cpu_nr);
+extern void wrhv_umask_IPIs_for_vcore(void);
+extern void wrhv_request_ipis(void);
 extern unsigned long wrhv_cpu_freq;
 
 extern uint32_t service_handle;
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 43a8457..a06757a 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -1279,6 +1279,141 @@ void wrhv_init(void)
 
 #ifdef CONFIG_SMP
 VBI_HREG_SET_CMPLX_QUALIFIED bootREG;
+#define IPI_IRQ_BASE_NAME "ipi0"
+int irq_base = 0xFFFF; /*init as invalid IRQ number*/
+
+static irqreturn_t wrhv_ipi_action(int irq, void *data)
+{
+	long ipi = (long)data;
+
+	smp_message_recv(ipi);
+
+	return IRQ_HANDLED;
+}
+
+void __init smp_wrhv_setup_cpu(int cpu_nr)
+{
+	return;
+}
+
+void wrhv_umask_IPIs_for_vcore(void)
+{
+	int i;
+
+	for (i = 0; i < 4; i++) {
+		 vbi_unmask_vioapic_irq(irq_base+i);
+	}
+}
+
+void wrhv_request_ipis(void)
+{
+/* Need call vbiIntVecFind to get IPI IRQ numbers
+ * from Hypervisor configuration. So comment out
+ * this temprorily.
+ * IPI0 (call function)		irq_base
+ * IPI1 (reschedule)		irq_base+1
+ * IPI2 (call function single)	irq_base+2
+ * IPI3 (debugger break)	irq_base+3
+ */
+	static char *ipi_names[] = {
+		"IPI0 (call function)",
+		"IPI1 (reschedule)",
+		"IPI2 (call function single)",
+		"IPI3 (debugger break)",
+	};
+	int i,err;
+
+	printk(KERN_INFO "WRHV requesting IPIs ... \n");
+	
+	irq_base = wrhv_map_irq_of_desc(IPI_IRQ_BASE_NAME, VB_INPUT_INT);
+	if (irq_base == VBI_INVALID_IRQ)
+		panic("WRHV reslove irq for IPI failed.\n");
+
+	for (i = 0; i < 4; i++) {
+		err = request_irq(irq_base+i, wrhv_ipi_action,
+				  IRQF_DISABLED|IRQF_PERCPU,
+				  ipi_names[i], (void *)i);
+		if (err) {
+			printk(KERN_ERR "WRHV Request of irq %d for IPI(%s) failed\n", 
+				irq_base+i,ipi_names[i]);
+			if (i) {
+				while (--i)
+					free_irq(irq_base+i, wrhv_ipi_action);	
+			}
+			break;
+		}
+	}
+}
+
+int __init smp_wrhv_probe(void)
+{
+	int nr_cpus;
+
+	pr_debug("smp_mpic_probe()...\n");
+
+	nr_cpus = cpus_weight(cpu_possible_map);
+
+	pr_debug("nr_cpus: %d\n", nr_cpus);
+
+	if (nr_cpus > 1)
+		wrhv_request_ipis();
+
+	wrhv_umask_IPIs_for_vcore();
+
+	return nr_cpus;
+}
+
+static inline void wrhv_send_IPI_mask(int irq, cpumask_t mask)
+{
+	unsigned long coreset = cpus_addr(mask)[0];
+	unsigned long flags;
+
+	local_irq_save(flags);
+	WARN_ON(coreset & ~cpus_addr(cpu_online_map)[0]);
+	vbi_send_vcore_vioapic_irq(irq, coreset, 0);
+	local_irq_restore(flags);
+}
+
+void smp_wrhv_message_pass(int target, int msg)
+{
+  
+	/* make sure we're sending something that translates to an IPI */
+	if ((unsigned int)msg > 3) {
+		printk("SMP %d: smp_message_pass: unknown msg %d\n",
+		       smp_processor_id(), msg);
+		return;
+	}
+
+	switch (target) {
+	case MSG_ALL:{
+		cpumask_t mask,dst;
+		
+		cpus_setall(dst);
+		cpus_and(mask, dst, cpu_online_map);
+		wrhv_send_IPI_mask(msg+irq_base,mask);
+
+		break;
+		}
+	case MSG_ALL_BUT_SELF:{
+		cpumask_t mask,dst;
+		int self = smp_processor_id();
+		
+		cpus_setall(dst);
+		cpu_clear(self,dst);
+		cpus_and(mask, dst, cpu_online_map);
+		wrhv_send_IPI_mask(msg+irq_base,mask);
+		break;
+		}
+	default:{
+		cpumask_t mask,dst;
+		cpus_clear(dst);
+		cpu_set(target,dst);
+		cpus_and(mask, dst, cpu_online_map);
+		wrhv_send_IPI_mask(msg+irq_base,mask);
+		break;
+		}
+	}
+}
 
 static void __init  smp_wrhv_kick_cpu(int nr)
 {
@@ -1325,6 +1460,9 @@ struct smp_ops_t smp_wrhv_ops = {
 	.cpu_disable = generic_cpu_disable,
 	.cpu_die = generic_cpu_die,
 #endif
+	.probe = smp_wrhv_probe,
+	.message_pass = smp_wrhv_message_pass,
+	.setup_cpu = smp_wrhv_setup_cpu,
 };
 
 void __init wrhv_smp_init(void)
@@ -1373,6 +1511,8 @@ int __devinit wrhv_start_secondary(void *unused)
 	wrhv_umask_IPIs_for_vcore();
 	vbi_set_exc_offset(&exec_table);
 
+	wrhv_umask_IPIs_for_vcore();
+
 	atomic_inc(&init_mm.mm_count);
 	current->active_mm = &init_mm;
 
-- 
1.6.5.2

