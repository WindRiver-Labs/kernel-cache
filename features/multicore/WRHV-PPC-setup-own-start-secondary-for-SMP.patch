From f4463bd33fbe7e0ba6e9ead94342d1368be1d90c Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Wed, 12 May 2010 16:39:49 +0800
Subject: [PATCH 09/14] WRHV/PPC: setup own start secondary for SMP

Create a guest OS specific wrhv_start_secondary, since the guest OS
has different requirements than a native secondary cpu startup.

In particular, the guest doesn't need the decrementer initialization for secondary cpu.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/kernel/vbi/wrhv.c |   92 ++++++++++++++++++++++++++++++++++++++++
 1 files changed, 92 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 0977c96..8f6bb6f 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -1277,6 +1277,98 @@ void wrhv_init(void)
 
 }
 
+#ifdef CONFIG_SMP
+extern struct smp_ops_t *smp_ops;
+extern volatile unsigned int cpu_callin_map[NR_CPUS];
+
+static void __devinit smp_store_cpu_info(int id)
+{
+	per_cpu(cpu_pvr, id) = get_pvr();
+}
+
+/* Must be called when no change can occur to cpu_present_map,
+ * i.e. during cpu online or offline.
+ */
+static struct device_node *cpu_to_l2cache(int cpu)
+{
+	struct device_node *np;
+	struct device_node *cache;
+
+	if (!cpu_present(cpu))
+		return NULL;
+
+	np = of_get_cpu_node(cpu, NULL);
+	if (np == NULL)
+		return NULL;
+
+	cache = of_find_next_cache_node(np);
+
+	of_node_put(np);
+
+	return cache;
+}
+
+/* Activate a secondary processor. */
+int __devinit wrhv_start_secondary(void *unused)
+{
+	unsigned int cpu = smp_processor_id();
+	struct device_node *l2_cache;
+	int i, base;
+
+	atomic_inc(&init_mm.mm_count);
+	current->active_mm = &init_mm;
+
+	smp_store_cpu_info(cpu);
+	preempt_disable();
+	cpu_callin_map[cpu] = 1;
+
+	if (smp_ops->setup_cpu)
+		smp_ops->setup_cpu(cpu);
+	if (smp_ops->take_timebase)
+		smp_ops->take_timebase();
+
+	if (system_state > SYSTEM_BOOTING)
+		snapshot_timebase();
+
+	ipi_call_lock();
+	notify_cpu_starting(cpu);
+	set_cpu_online(cpu, true);
+	/* Update sibling maps */
+	base = cpu_first_thread_in_core(cpu);
+	for (i = 0; i < threads_per_core; i++) {
+		if (cpu_is_offline(base + i))
+			continue;
+		cpu_set(cpu, per_cpu(cpu_sibling_map, base + i));
+		cpu_set(base + i, per_cpu(cpu_sibling_map, cpu));
+
+		/* cpu_core_map should be a superset of
+		 * cpu_sibling_map even if we don't have cache
+		 * information, so update the former here, too.
+		 */
+		cpu_set(cpu, per_cpu(cpu_core_map, base +i));
+		cpu_set(base + i, per_cpu(cpu_core_map, cpu));
+	}
+	l2_cache = cpu_to_l2cache(cpu);
+	for_each_online_cpu(i) {
+		struct device_node *np = cpu_to_l2cache(i);
+		if (!np)
+			continue;
+		if (np == l2_cache) {
+			cpu_set(cpu, per_cpu(cpu_core_map, i));
+			cpu_set(i, per_cpu(cpu_core_map, cpu));
+		}
+		of_node_put(np);
+	}
+	of_node_put(l2_cache);
+	ipi_call_unlock();
+
+	local_irq_enable();
+
+	cpu_idle();
+	return 0;
+}
+#endif
+
 #ifdef CONFIG_PCI
 #define VECTOR_NAME_SIZE	8
 int ppc_get_pci_intr_wrhv(struct pci_dev *dev)
-- 
1.6.5.2

