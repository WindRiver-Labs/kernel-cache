From 4c459d48ff1132cb2b4487b06e54ba89a47b858e Mon Sep 17 00:00:00 2001
From: Thomas Tai <thomas.tai@windriver.com>
Date: Fri, 14 Jan 2011 11:28:15 -0500
Subject: [PATCH] wrhv: do no idle core 0

When running in direct irq and duart mode, core 0 needs
to handle interrupt from hypervisor. In this case we do
not allow core 0 to go into idle. To avoid confusion
we keep core 0 running at all times.

Also move duart related variables earlier in the file,
so that we can make use of is_wrhv_duart_init variable.

Signed-off-by: Thomas Tai <thomas.tai@windriver.com>
---
 arch/powerpc/kernel/vbi/wrhv.c |   57 +++++++++++++++++++++++++--------------
 1 files changed, 36 insertions(+), 21 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index b0da691..17a0a85 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -152,6 +152,26 @@ int wrhv_earlycon = -1;
 int wrhv_pci_devfn = -1;
 char wrhv_macaddr[6];
 
+/* interface to wrhv duart actual device driver */
+#define WRHV_DUART_RX_SIZE	(16)
+#define WRHV_DUART_TX_SIZE	(1024)
+static char rxBuf[WRHV_DUART_RX_SIZE];
+static char txBuf[WRHV_DUART_TX_SIZE];
+static char wrhv_duart_name[256];
+vbi_pdc_handle duartPdc;
+static int is_wrhv_duart_inited = 0;
+
+struct intrDeviceChannelBuffer idc = {
+	.rxBuf = (void *)rxBuf,
+	.rxBufLen = WRHV_DUART_RX_SIZE,
+	.rxBufWrPtr = (size_t)0,
+	.rxBufRdPtr = (size_t)0,
+	.txBuf = (void *)txBuf,
+	.txBufLen = WRHV_DUART_TX_SIZE,
+	.txBufWrPtr = (size_t)0,
+	.txBufRdPtr = (size_t)0
+};
+
 #define WRHV_EARLYCON_SIZE  14  /* sizeof("wrhv_earlycon=") */
 int __init wrhv_earlycon_setup(void)
 {
@@ -334,7 +354,22 @@ int __init wrhv_early_init_dt_scan_memory_ppc(unsigned long node,
 void wrhv_power_save(void)
 {
 	local_irq_enable();
-	vbi_idle(1);
+
+	/*
+	 * wrhv_power_save() is called by cpu_idle. When running in direct irq or
+	 * duart mode, we need core 0 to handle interrupt from hypervisor. In this
+	 * case we do not allow core 0 to go into idle.
+	 */
+	if ((wrhv_dir_irq) || (is_wrhv_duart_inited)) {
+		/* running in direct irq or using duart */
+		if (smp_processor_id())
+			vbi_idle(1);
+	}
+	else {
+		/* not using direct irq and not using duart */
+		vbi_idle(1);
+	}
+
 }
 
 static void wrhv_do_restart(void *data)
@@ -2272,26 +2307,6 @@ void wrhv_pci_fixup_resource(struct pci_dev* dev)
 DECLARE_PCI_FIXUP_EARLY(PCI_ANY_ID, PCI_ANY_ID, wrhv_pci_fixup_resource);
 #endif
 
-/* interface to wrhv duart actual device driver */
-#define WRHV_DUART_RX_SIZE	(16)
-#define WRHV_DUART_TX_SIZE	(1024)
-static char rxBuf[WRHV_DUART_RX_SIZE];
-static char txBuf[WRHV_DUART_TX_SIZE];
-static char wrhv_duart_name[256];
-vbi_pdc_handle duartPdc;
-static int is_wrhv_duart_inited = 0;
-
-struct intrDeviceChannelBuffer idc = {
-	.rxBuf = (void *)rxBuf,
-	.rxBufLen = WRHV_DUART_RX_SIZE,
-	.rxBufWrPtr = (size_t)0,
-	.rxBufRdPtr = (size_t)0,
-	.txBuf = (void *)txBuf,
-	.txBufLen = WRHV_DUART_TX_SIZE,
-	.txBufWrPtr = (size_t)0,
-	.txBufRdPtr = (size_t)0
-};
-
 void wrhv_duart_putc(char c)
 {
 	if (((idc.txBufWrPtr + 1) % WRHV_DUART_TX_SIZE) == idc.txBufRdPtr) {
-- 
1.6.5.2

