From 5c01d68a5e657d40f17be1f32b8e6e70f957c9bd Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Wed, 17 Nov 2010 08:02:34 -0800
Subject: [PATCH 2/2] wrhv/gos: reset irq affinity on reboot

Hyp fail to reset irq affinity upon GOS's reboot. Take irq4
for example:

Set irq4's affinity to cpu1 then reboot VB. This will cause
GOS think the irq4's affinity is 0x1 after boot up but hyp
still route irq4 to vcore1 other than vcore0 of the VB. Hence
irq4 won't be handled correctly after reboot.

The root cause is hyp's reset vcore logic did not reset irq
affinities accordingly.

We work around it in GOS now. At reboot stage, reset all irq's
affinity to BP of the VB before actually ask hyp reset vcores.

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 kernel/vbi/wrhv.c |   53 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 53 insertions(+), 0 deletions(-)

diff --git a/kernel/vbi/wrhv.c b/kernel/vbi/wrhv.c
index fba5b7b..dac176d 100644
--- a/kernel/vbi/wrhv.c
+++ b/kernel/vbi/wrhv.c
@@ -580,6 +580,58 @@ static int wrhv_hysh_init_sysfs(void)
 	return 0;
 }
 
+static int wrhv_reset_all_irqs(struct notifier_block *self,
+		unsigned long code, void *t)
+{
+	unsigned int    irq;
+	struct irq_desc *desc;
+
+	for_each_irq_desc(irq, desc) {
+		struct cpumask *affinity;
+		struct cpumask non_bp_affinity;
+
+		if (!desc)
+			continue;
+		if (desc->status & IRQ_PER_CPU)
+			continue;
+
+		raw_spin_lock(&desc->lock);
+
+		affinity = desc->affinity;
+		cpumask_and(affinity, affinity, cpu_online_mask);
+		cpumask_copy(&non_bp_affinity, affinity);
+		cpu_clear(0, non_bp_affinity);
+		if (!irq_has_action(irq) ||
+		    cpumask_equal(affinity, cpu_online_mask) ||
+			cpumask_empty(&non_bp_affinity)) {
+			raw_spin_unlock(&desc->lock);
+			continue;
+		}
+
+		if (desc->chip->set_affinity)
+			desc->chip->set_affinity(irq, cpumask_of(0));
+
+		raw_spin_unlock(&desc->lock);
+	}
+	return 0;
+}
+
+static struct notifier_block wrhv_reboot_notifier = {
+	.notifier_call = wrhv_reset_all_irqs,
+};
+
+int wrhv_register_reboot_notifier(void)
+{
+	int ret = 0;
+	ret = register_reboot_notifier(&wrhv_reboot_notifier);
+	if (ret)
+		printk(KERN_ERR
+			"WRHV: unable to install reboot notifier"
+			"(err = %d)\n", ret);
+
+	return ret;
+}
+
 int __init wrhv_late_init(void)
 {
 	wrhv_arch_late_init();
@@ -587,6 +639,7 @@ int __init wrhv_late_init(void)
 	wrhv_init_sysfs();
 	wrhv_init_debugfs();
 	wrhv_hysh_init_sysfs();
+	wrhv_register_reboot_notifier();
 	return 0;
 }
 late_initcall(wrhv_late_init);
-- 
1.6.5.2

