From 20d11b37ba1ece4fde53d1c729322206fe24740f Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Fri, 21 Jan 2011 19:30:41 +0800
Subject: [PATCH 7/8] wrhv: drivers: enable various drivers for guest

There are drivers that require code changes to their specific
 support in order to be used in a guest mode.

Also enable virtio for WindRiver hypervisor.
[
For WindRiver hypervisor, the host and guest can transfer data
by using two ring buffers. One for transmit and the other
for receive. The guest will use vbi to notify host, and
the host will use interrupt to inform guest when there
is data need to process. This just add the basic virtual
device support for this model.
]

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
Signed-off-by: Liang Li <liang.li@windriver.com>
---
 arch/powerpc/kernel/legacy_serial.c |    7 +
 drivers/Kconfig                     |    2 +
 drivers/Makefile                    |    2 +
 drivers/net/gianfar.c               |   59 ++++-
 drivers/serial/8250.c               |    6 +
 drivers/wrhv/Kconfig                |   20 ++
 drivers/wrhv/Makefile               |    3 +
 drivers/wrhv/wrhv_devices.c         |  480 +++++++++++++++++++++++++++++++++++
 drivers/wrhv/wrhv_devices.h         |  105 ++++++++
 drivers/wrhv/wrhv_frame_irq.c       |   93 +++++++
 10 files changed, 775 insertions(+), 2 deletions(-)
 create mode 100644 drivers/wrhv/Kconfig
 create mode 100644 drivers/wrhv/Makefile
 create mode 100644 drivers/wrhv/wrhv_devices.c
 create mode 100644 drivers/wrhv/wrhv_devices.h
 create mode 100644 drivers/wrhv/wrhv_frame_irq.c

diff --git a/arch/powerpc/kernel/legacy_serial.c b/arch/powerpc/kernel/legacy_serial.c
index 035ada5..89a15f3 100644
--- a/arch/powerpc/kernel/legacy_serial.c
+++ b/arch/powerpc/kernel/legacy_serial.c
@@ -23,6 +23,9 @@
 
 #define MAX_LEGACY_SERIAL_PORTS	8
 
+#ifdef CONFIG_WRHV
+extern int wrhv_earlycon;
+#endif
 static struct plat_serial8250_port
 legacy_serial_ports[MAX_LEGACY_SERIAL_PORTS+1];
 static struct legacy_serial_info {
@@ -379,6 +382,10 @@ void __init find_legacy_serial_ports(void)
 	}
 #endif
 
+#ifdef CONFIG_WRHV
+	if(wrhv_earlycon != -1 && wrhv_earlycon < MAX_LEGACY_SERIAL_PORTS)
+		legacy_serial_console = wrhv_earlycon;
+#endif
 	DBG("legacy_serial_console = %d\n", legacy_serial_console);
 	if (legacy_serial_console >= 0)
 		setup_legacy_serial_console(legacy_serial_console);
diff --git a/drivers/Kconfig b/drivers/Kconfig
index a2b902f..a6481af 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -111,4 +111,6 @@ source "drivers/xen/Kconfig"
 source "drivers/staging/Kconfig"
 
 source "drivers/platform/Kconfig"
+
+source "drivers/wrhv/Kconfig"
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index b64e7f1..812ccd4 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -113,3 +113,5 @@ obj-$(CONFIG_VLYNQ)		+= vlynq/
 obj-$(CONFIG_STAGING)		+= staging/
 obj-y				+= platform/
 obj-y				+= ieee802154/
+obj-y				+= wrhv/
+
diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index 23a9c5a..0cf6ba1 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -102,6 +102,14 @@
 #undef BRIEF_GFAR_ERRORS
 #undef VERBOSE_GFAR_ERRORS
 
+#ifdef CONFIG_WRHV
+#define NIC_STR_LEN	15
+extern char wrhv_macaddr[MAC_ADDR_LEN];
+extern char wrhv_net_name[NIC_STR_LEN]; /* eth0, eth1, eth2... */
+extern int wrhv_nic_num;
+extern int wrhv_nic_start; /* which index should we start at */
+#endif
+
 const char gfar_driver_name[] = "Gianfar Ethernet";
 const char gfar_driver_version[] = "1.3";
 
@@ -862,11 +870,13 @@ static void gfar_init_filer_table(struct gfar_private *priv)
 	}
 }
 
+extern unsigned int get_pvr(void);
+extern unsigned int get_svr(void);
 static void gfar_detect_errata(struct gfar_private *priv)
 {
 	struct device *dev = &priv->ofdev->dev;
-	unsigned int pvr = mfspr(SPRN_PVR);
-	unsigned int svr = mfspr(SPRN_SVR);
+	unsigned int pvr = get_pvr();
+	unsigned int svr = get_svr();
 	unsigned int mod = (svr >> 16) & 0xfff6; /* w/o E suffix */
 	unsigned int rev = svr & 0xffff;
 
@@ -904,6 +914,7 @@ static int gfar_probe(struct of_device *ofdev,
 	u32 rstat = 0, tstat = 0, rqueue = 0, tqueue = 0;
 	u32 isrg = 0;
 	u32 __iomem *baddr;
+	int j;
 
 	err = gfar_of_init(ofdev, &dev);
 
@@ -1091,6 +1102,50 @@ static int gfar_probe(struct of_device *ofdev,
 
 	err = register_netdev(dev);
 
+#ifdef CONFIG_WRHV
+	if (wrhv_nic_start > wrhv_nic_num) {
+		printk(KERN_ERR " WRHV: bootline NIC setup error\n");
+		return -ENODEV;
+	}
+
+	for (j = wrhv_nic_start; j <= wrhv_nic_num; j++) {
+		char nic_num[NIC_STR_LEN] = "";
+		char net_sub_name[NIC_STR_LEN]; /* eth on most platforms except
+		on cavium they call there network devices mgmtX */
+
+		if (!is_valid_ether_addr(wrhv_macaddr))
+				break;
+		else if (!wrhv_net_name[0])
+			strcpy(wrhv_net_name, "eth0");
+
+		/* eth0 --> we only want the eth part so we
+		   Simply append to the ifname the nic number */
+
+		/* Clear out the buffer for the next iteration */
+		memset(net_sub_name, '\0', NIC_STR_LEN);
+
+		/* get rid of the number on the end 'ethX' */
+		strncpy(net_sub_name, wrhv_net_name, strlen(wrhv_net_name) - 1);
+		sprintf(nic_num, "%d", j);
+		strcat(net_sub_name, nic_num);
+
+		if (strcmp(dev->name, net_sub_name) == 0) {
+			char local_mac[MAC_ADDR_LEN];
+			char last_byte = wrhv_macaddr[MAC_ADDR_LEN - 1];
+
+			memcpy(local_mac, wrhv_macaddr, MAC_ADDR_LEN);
+			/* Extract the last byte of the MAC address */
+			/* One limitation is that we do not check to see if
+			the last byte needs to wrap around.  We expect sane
+			values are being passed in.  This limitation has been
+			documented in the README.bootline */
+
+			local_mac[MAC_ADDR_LEN - 1] = (last_byte + j) & 0xff;
+			memcpy(dev->dev_addr, local_mac, MAC_ADDR_LEN);
+		}
+	}
+#endif
+
 	if (err) {
 		printk(KERN_ERR "%s: Cannot register net device, aborting.\n",
 				dev->name);
diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 73ab756..be30075 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -108,6 +108,9 @@ static unsigned int skip_txen_test; /* force skip of txen test at init time */
 #define CONFIG_HUB6 1
 
 #include <asm/serial.h>
+#if defined(CONFIG_WRHV) && defined(CONFIG_X86)
+#include <asm/wrhv_serial.h>
+#endif
 /*
  * SERIAL_PORT_DFNS tells us about built-in ports that have no
  * standard enumeration mechanism.   Platforms that can find all
@@ -2394,7 +2397,10 @@ serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
 		/* Switch to bank 2 not bank 1, to avoid resetting EXCR2 */
 		serial_outp(up, UART_LCR, 0xe0);
 	} else {
+		/* skip DLAB on WRHV + PPC */
+#if !defined(CONFIG_WRHV) || !defined(CONFIG_PPC)
 		serial_outp(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
+#endif
 	}
 
 	serial_dl_write(up, quot);
diff --git a/drivers/wrhv/Kconfig b/drivers/wrhv/Kconfig
new file mode 100644
index 0000000..21c277f
--- /dev/null
+++ b/drivers/wrhv/Kconfig
@@ -0,0 +1,20 @@
+menuconfig WRHV_VIRTIO
+	bool "Virtual devices support for WindRiver Hypervisor Guest OS"
+	depends on WRHV
+	select VIRTIO
+	---help---
+	  This provides support for the virtio based paravirtual device on
+	  the WindRiver Hypervisor Guest OS.
+
+if WRHV_VIRTIO
+
+config WRHV_FRAME_TRANSITION_INTERRUPT_TEST
+	bool "Frame transition interrupt test"
+	depends on WRHV_CERT
+	default n
+	---help---
+	  Enable testing the start frame and end frame transition interrupt
+	  for Certifiable Hypervisor.
+
+endif  # WRHV_VIRTIO
+
diff --git a/drivers/wrhv/Makefile b/drivers/wrhv/Makefile
new file mode 100644
index 0000000..bdc5fc8
--- /dev/null
+++ b/drivers/wrhv/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_WRHV_VIRTIO)	+= wrhv_devices.o
+obj-$(CONFIG_WRHV_FRAME_TRANSITION_INTERRUPT_TEST) += wrhv_frame_irq.o
+
diff --git a/drivers/wrhv/wrhv_devices.c b/drivers/wrhv/wrhv_devices.c
new file mode 100644
index 0000000..6d5571c
--- /dev/null
+++ b/drivers/wrhv/wrhv_devices.c
@@ -0,0 +1,480 @@
+/*
+ *  Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ *  This file is based on drivers/lguest/lguest_device.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/virtio.h>
+#include <linux/virtio_config.h>
+#include <linux/virtio_ids.h>
+#include <linux/virtio_console.h>
+#include <vbi/vbi.h>
+#include <vbi/pdc.h>
+#include <vbi/duart.h>
+#include <linux/scatterlist.h>
+#include <linux/circ_buf.h>
+#include "wrhv_devices.h"
+
+/*
+ * Device configurations
+ *
+ * The configuration information for a device consists of
+ * virtqueues, a feature bitmap, and some configuration bytes.
+ */
+static inline struct wrhv_vqconfig *wrhv_vq(struct wrhv_device_desc *desc)
+{
+	return desc->vqconfig;
+}
+
+static inline u8 *wrhv_features(struct wrhv_device_desc *desc)
+{
+	return desc->features;
+}
+
+static inline u8 *wrhv_config(struct wrhv_device_desc *desc)
+{
+	return desc->config;
+}
+
+/* The total size of the config page used by this device (incl. desc) */
+static inline unsigned desc_size(struct wrhv_device_desc *desc)
+{
+	return sizeof(*desc);
+}
+
+static u32 wrhv_get_features(struct virtio_device *vdev)
+{
+	unsigned int i;
+	u32 features = 0;
+	struct wrhv_device_desc *desc = to_wrhvdev(vdev)->desc;
+	u8 *in_features = wrhv_features(desc);
+
+	for (i = 0; i < min(desc->feature_len * 8, 32); i++)
+		if (in_features[i / 8] & (1 << (i % 8)))
+			features |= (1 << i);
+
+	return features;
+}
+
+/*
+ * The virtio core takes the features the Host offers, and copies the ones
+ * supported by the driver into the vdev->features array.  Once that's all
+ * sorted out, this routine is called so we can tell the Host which features we
+ * understand and accept.
+ */
+static void wrhv_finalize_features(struct virtio_device *vdev)
+{
+	unsigned int i, bits;
+	struct wrhv_device_desc *desc = to_wrhvdev(vdev)->desc;
+	u8 *out_features = wrhv_features(desc) + WRHV_DEVICE_MAX_FEATURES_LEN;
+
+	memset(out_features, 0, desc->feature_len);
+	bits = min_t(unsigned, desc->feature_len, sizeof(vdev->features)) * 8;
+	for (i = 0; i < bits; i++) {
+		if (test_bit(i, vdev->features))
+			out_features[i / 8] |= (1 << (i % 8));
+	}
+}
+
+/*
+ * Reading and writing elements in config space
+ */
+static void wrhv_get(struct virtio_device *vdev, unsigned int offset,
+			void *buf, unsigned len)
+{
+	struct wrhv_device_desc *desc = to_wrhvdev(vdev)->desc;
+
+	BUG_ON(offset + len > desc->config_len);
+	memcpy(buf, wrhv_config(desc) + offset, len);
+}
+
+static void wrhv_set(struct virtio_device *vdev, unsigned int offset,
+			const void *buf, unsigned len)
+{
+	struct wrhv_device_desc *desc = to_wrhvdev(vdev)->desc;
+
+	BUG_ON(offset + len > desc->config_len);
+	memcpy(wrhv_config(desc) + offset, buf, len);
+}
+
+/*
+ * The operations to get and set the status word just access the status field
+ * of the device descriptor.
+ */
+static u8 wrhv_get_status(struct virtio_device *vdev)
+{
+	return to_wrhvdev(vdev)->desc->status;
+}
+
+static void wrhv_set_status(struct virtio_device *vdev, u8 status)
+{
+	to_wrhvdev(vdev)->desc->status = status;
+}
+
+static void wrhv_reset(struct virtio_device *vdev)
+{
+	wrhv_set_status(vdev, 0);
+}
+
+static int wrhv_vq_buf_space(struct wrhv_virtqueue *vq)
+{
+	u32 h = *vq->ph, t = *vq->pt;
+	size_t len = vq->len;
+
+	return CIRC_SPACE(h, t, len);
+}
+
+static int wrhv_vq_buf_count(struct wrhv_virtqueue *vq)
+{
+	u32 h = *vq->ph, t = *vq->pt;
+	size_t len = vq->len;
+
+	return CIRC_CNT(h, t, len);
+}
+
+static int wrhv_add_sg(struct wrhv_virtqueue *vq,
+			struct scatterlist *sg)
+{
+	u32 len = sg->length;
+	size_t l = vq->len;
+	u32 h = *vq->ph, t = *vq->pt;
+
+	while (len) {
+		u32 free = wrhv_vq_buf_space(vq);
+		u32 s, r;
+
+		if (!free) {
+			vq->vq.vq_ops->kick(&vq->vq);
+			continue;
+		}
+
+		s = min(len, free);
+		len -= s;
+
+		r = CIRC_SPACE_TO_END(h, t, l);
+		if (s  > r) {
+			memcpy(vq->buf + h, sg_virt(sg), r);
+			memcpy(vq->buf, sg_virt(sg) + r, s - r);
+		} else
+			memcpy(vq->buf + h, sg_virt(sg), s);
+
+		*vq->ph = (h + s) % vq->len;
+	}
+	return 0;
+}
+
+static int wrhv_add_buf(struct virtqueue *_vq,
+			struct scatterlist *sg,
+			unsigned int out,
+			unsigned int in,
+			void *data)
+{
+	struct wrhv_virtqueue *vq = to_wrhvvq(_vq);
+
+	vq->data = data;
+	while (out--) {
+		wrhv_add_sg(vq, sg);
+		sg = sg_next(sg);
+	}
+
+	WARN_ONCE(in > 1, "We only support one read buffer now");
+
+	if (in) {
+		vq->read_buf = sg_virt(sg);
+		vq->read_len = sg->length;
+	}
+
+	return 0;
+}
+
+static void *wrhv_get_buf(struct virtqueue *_vq, unsigned int *len)
+{
+	struct wrhv_virtqueue *vq = to_wrhvvq(_vq);
+	u32 n, r;
+	u32 h = *vq->ph, t = *vq->pt;
+	size_t l = vq->len;
+	unsigned char *pt = vq->buf + t;
+
+	if (!(vq->mode & WRHV_DEVICE_VQ_IN))
+		return vq->data;
+
+	n = wrhv_vq_buf_count(vq);
+	if (!n) {
+		*len = 0;
+		return NULL;
+	}
+
+	n = min(n, vq->read_len);
+	r = CIRC_CNT_TO_END(h, t, l);
+	if (n > r) {
+		memcpy(vq->read_buf, pt, r);
+		memcpy(vq->read_buf + r, vq->buf, n - r);
+	} else
+		memcpy(vq->read_buf, pt, n);
+
+	*vq->pt = (t + n) % vq->len;
+
+	*len = n;
+	return vq->data;
+}
+
+static void wrhv_kick(struct virtqueue *_vq)
+{
+	struct wrhv_virtqueue *vq = to_wrhvvq(_vq);
+	struct wrhv_device *vdev = to_wrhvdev(vq->vq.vdev);
+
+	if (!(vq->mode & WRHV_DEVICE_VQ_OUT))
+		return;
+
+	vbi_pdc_op(vdev->pdc_handle, PDC_REQUEST_WRITE, 0,
+			vq->buf, vq->len, 0);
+}
+
+static struct virtqueue_ops wrhv_vq_ops = {
+	.add_buf = wrhv_add_buf,
+	.get_buf = wrhv_get_buf,
+	.kick = wrhv_kick,
+};
+
+static irqreturn_t wrhv_interrupt(int irq, void *_vq)
+{
+	struct wrhv_virtqueue *vq = _vq;
+
+	/*
+	 * Don't run the input virtual queue callback function before we
+	 * fill the read buffer.
+	 */
+	if ((vq->mode & WRHV_DEVICE_VQ_IN) &&
+		(!vq->read_buf || !vq->len))
+		return IRQ_HANDLED;
+
+	if (vq->vq.callback)
+		vq->vq.callback(&vq->vq);
+
+	return IRQ_HANDLED;
+}
+
+int wrhv_init_vq(struct wrhv_device *vdev, unsigned int index,
+			struct wrhv_virtqueue *vq)
+{
+	struct intr_device_channel_buffer *idc = vdev->idc;
+
+	/* index 0 should be rx queue, index 1 should be tx queue */
+	switch (index) {
+	case 0:
+		idc->rxBuf = vq->buf;
+		idc->rxBufLen = vq->len;
+		vq->ph = &idc->rxBufWrPtr;
+		vq->pt = &idc->rxBufRdPtr;
+		vq->mode |= WRHV_DEVICE_VQ_IN;
+		break;
+	case 1:
+		idc->txBuf = vq->buf;
+		idc->txBufLen = vq->len;
+		vq->ph = &idc->txBufWrPtr;
+		vq->pt = &idc->txBufRdPtr;
+		vq->mode |= WRHV_DEVICE_VQ_OUT;
+		break;
+	default:
+		pr_err("unsupported queue for wrhv virtual device\n");
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(wrhv_init_vq);
+
+/*
+ * This routine finds the Nth virtqueue described in the configuration of
+ * this device and sets it up.
+ */
+static struct virtqueue *wrhv_find_vq(struct virtio_device *vdev,
+					unsigned int index,
+					void (*callback)(struct virtqueue *vq),
+					const char *name)
+{
+	struct wrhv_device *wdev = to_wrhvdev(vdev);
+	struct wrhv_virtqueue *vq;
+	struct wrhv_vqconfig *vconfig = wrhv_vq(wdev->desc) + index;
+	int err;
+
+	if (index >= wdev->desc->num_vq)
+		return ERR_PTR(-ENOENT);
+
+	vq = kzalloc(sizeof(*vq), GFP_KERNEL);
+	if (!vq)
+		return ERR_PTR(-ENOMEM);
+
+	vq->vq.callback = callback;
+	vq->vq.vdev = vdev;
+	vq->vq.vq_ops = &wrhv_vq_ops;
+	vq->vq.name = name;
+	vq->vq.priv = vconfig;
+	vq->len = vconfig->num;
+
+	if (wdev->ops && wdev->ops->init_idc)
+		wdev->ops->init_idc(wdev, index, vq);
+
+	if (vconfig->irq) {
+		err = request_irq(vconfig->irq, wrhv_interrupt, IRQF_SHARED,
+					dev_name(&vdev->dev), vq);
+		if (err) {
+			kfree(vq->buf);
+			kfree(vq);
+			return ERR_PTR(err);
+		}
+
+		wdev->mode |= WRHV_DEVICE_MODE_INT;
+	}
+
+	return &vq->vq;
+}
+
+static void wrhv_del_vq(struct virtqueue *vq)
+{
+	struct wrhv_vqconfig *vconfig = vq->priv;
+	struct wrhv_virtqueue *wvq = to_wrhvvq(vq);
+
+	if (vconfig->irq)
+		free_irq(vconfig->irq, vq);
+	if (!(wvq->mode & WRHV_DEVICE_VQ_NOFREE))
+		kfree(wvq->buf);
+	kfree(wvq);
+}
+
+static void wrhv_del_vqs(struct virtio_device *vdev)
+{
+	struct virtqueue *vq, *n;
+
+	list_for_each_entry_safe(vq, n, &vdev->vqs, list)
+		wrhv_del_vq(vq);
+}
+
+int wrhv_init_device(struct wrhv_device *vdev)
+{
+	if (vbi_pdc_op(vdev->pdc_handle, PDC_REQUEST_IOCTL,
+			PDC_IOCTL_SIO_OPEN, 0, 0, 0))
+		return -1;
+
+	if (vbi_pdc_op(vdev->pdc_handle, PDC_REQUEST_IOCTL,
+			PDC_IOCTL_SIO_MODE_SET, (void *)SIO_MODE_INT,
+			SIO_HW_OPTS_CLOCAL, 0))
+		return -1;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(wrhv_init_device);
+
+static int wrhv_find_vqs(struct virtio_device *vdev, unsigned nvqs,
+			struct virtqueue *vqs[], vq_callback_t *callbacks[],
+			const char *names[])
+{
+	struct wrhv_device *wdev = to_wrhvdev(vdev);
+	int i;
+
+	if (nvqs > wdev->desc->num_vq)
+		return -ENOENT;
+
+	for (i = 0; i < nvqs; i++) {
+		vqs[i] = wrhv_find_vq(vdev, i, callbacks[i], names[i]);
+		if (IS_ERR(vqs[i]))
+			goto error;
+	}
+
+	if (wdev->ops && wdev->ops->init_dev)
+		wdev->ops->init_dev(wdev);
+
+	return 0;
+error:
+	wrhv_del_vqs(vdev);
+	return PTR_ERR(vqs[i]);
+}
+
+static struct virtio_config_ops wrhv_config_ops = {
+	.get_features		= wrhv_get_features,
+	.finalize_features	= wrhv_finalize_features,
+	.get			= wrhv_get,
+	.set			= wrhv_set,
+	.get_status		= wrhv_get_status,
+	.set_status		= wrhv_set_status,
+	.reset			= wrhv_reset,
+	.find_vqs		= wrhv_find_vqs,
+	.del_vqs		= wrhv_del_vqs,
+};
+
+/*
+ * The root device for the wrhv virtio devices. This makes them appear as
+ * /sys/devices/wrhv/0,1,2 not /sys/devices/0,1,2.
+ */
+static struct device *wrhv_root;
+
+static int wrhv_device_sanity_check(struct wrhv_device_desc *d)
+{
+	if (d->num_vq > WRHV_DEVICE_MAX_VQS ||
+		d->feature_len > WRHV_DEVICE_MAX_FEATURES_LEN ||
+		d->config_len > WRHV_DEVICE_MAX_CONFIG_LEN) {
+		pr_err("incorrect description for wrhv device type %u\n",
+			d->type);
+		return -1;
+	}
+	return 0;
+}
+
+
+int wrhv_add_device(struct wrhv_device_desc *d, struct wrhv_device_ops *ops)
+{
+	struct wrhv_device *vdev;
+
+	if (wrhv_device_sanity_check(d))
+		return -1;
+
+	vdev = kzalloc(sizeof(*vdev), GFP_KERNEL);
+	if (!vdev) {
+		pr_err("Cannot allocate wrhv dev type %u\n", d->type);
+		return -ENOMEM;
+	}
+
+	vdev->vdev.dev.parent = wrhv_root;
+	vdev->vdev.id.device = d->type;
+	vdev->vdev.config = &wrhv_config_ops;
+	vdev->desc = d;
+	vdev->ops = ops;
+
+	vdev->idc = ops->alloc_idc(vdev);
+	if (!vdev->idc)
+		return -ENOMEM;
+
+	if (register_virtio_device(&vdev->vdev)  != 0) {
+		pr_err("Failed to register wrhv dev type %u\n", d->type);
+		kfree(vdev);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(wrhv_add_device);
+
+static int __init wrhv_devices_init(void)
+{
+	wrhv_root = root_device_register("wrhv");
+	if (IS_ERR(wrhv_root))
+		panic("Could not register wrhv root");
+
+	return 0;
+}
+postcore_initcall(wrhv_devices_init);
diff --git a/drivers/wrhv/wrhv_devices.h b/drivers/wrhv/wrhv_devices.h
new file mode 100644
index 0000000..2f9efe2
--- /dev/null
+++ b/drivers/wrhv/wrhv_devices.h
@@ -0,0 +1,105 @@
+/*
+ *  Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _LINUX_WRHV_DEVICES
+#define _LINUX_WRHV_DEVICES
+
+#define WRHV_DEVICE_MAX_NAME_LEN	16
+#define WRHV_DEVICE_MAX_VQS		4
+#define WRHV_DEVICE_MAX_FEATURES_LEN	4
+#define WRHV_DEVICE_MAX_CONFIG_LEN	4
+
+/*
+ * This is how we expect the device configuration field for a virtqueue
+ * to be laid out in config space.
+ */
+struct wrhv_vqconfig {
+	/* The number of bytes for the buffer */
+	__u32 num;
+	/* The interrupt we get when something happens. */
+	__u32 irq;
+};
+
+struct wrhv_device_desc {
+	char name[WRHV_DEVICE_MAX_NAME_LEN];
+	/* The device type: console, network, disk etc. Type 0 terminates. */
+	__u8 type;
+	/* The number of virtqueus (first in config array) */
+	__u8 num_vq;
+	/*
+	 * The number of bytes of feature bits.  Multiply by 2: one for host
+	 * features and one for Guest acknowledgements.
+	 */
+	__u8 feature_len;
+	/* The number of bytes of the config array after virtqueues. */
+	__u8 config_len;
+	/* A status byte, written by the Guest. */
+	__u8 status;
+	struct wrhv_vqconfig vqconfig[WRHV_DEVICE_MAX_VQS];
+	__u8 features[WRHV_DEVICE_MAX_FEATURES_LEN * 2];
+	__u8 config[WRHV_DEVICE_MAX_CONFIG_LEN];
+};
+
+struct wrhv_device;
+struct wrhv_virtqueue;
+
+struct wrhv_device_ops {
+	int (*init_dev)(struct wrhv_device *vdev);
+	struct intr_device_channel_buffer *(*alloc_idc)(struct wrhv_device *vdev);
+	int (*init_idc)(struct wrhv_device *vdev, unsigned int index,
+			struct wrhv_virtqueue *vq);
+};
+
+#define WRHV_DEVICE_MODE_INT	1
+
+struct wrhv_device {
+	unsigned int mode;
+	struct virtio_device vdev;
+	struct wrhv_device_desc *desc;
+	struct intr_device_channel_buffer *idc;
+	vbi_pdc_handle	pdc_handle;
+	struct wrhv_device_ops *ops;
+};
+
+#define to_wrhvdev(vd) container_of(vd, struct wrhv_device, vdev)
+
+#define WRHV_DEVICE_VQ_IN	1
+#define WRHV_DEVICE_VQ_OUT	2
+#define WRHV_DEVICE_VQ_NOFREE	4
+
+struct wrhv_virtqueue {
+	struct virtqueue vq;
+	void *buf;	/* the virtqueue idc buffer */
+	size_t len;	/* the idc buffer length */
+	unsigned int mode;	/* in or out */
+	u32 *ph;	/* head pointer, must be consistent with ptr in idc */
+	u32 *pt;	/* tail pointer, must be consistent with ptr in idc */
+	void *read_buf;	/* the buffer used by guest for read */
+	u32 read_len;	/* the read buffer len */
+	void *data;	/* Token for callbacks */
+};
+
+#define to_wrhvvq(v) container_of(v, struct wrhv_virtqueue, vq)
+
+
+extern int wrhv_add_device(struct wrhv_device_desc *d,
+			struct wrhv_device_ops *ops);
+extern int wrhv_init_device(struct wrhv_device *vdev);
+extern int wrhv_init_vq(struct wrhv_device *vdev, unsigned int index,
+			struct wrhv_virtqueue *vq);
+#endif /* _LINUX_WRHV_DEVICES */
diff --git a/drivers/wrhv/wrhv_frame_irq.c b/drivers/wrhv/wrhv_frame_irq.c
new file mode 100644
index 0000000..e6c5d87
--- /dev/null
+++ b/drivers/wrhv/wrhv_frame_irq.c
@@ -0,0 +1,93 @@
+/*
+ *  Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/wrhv.h>
+#include <vbi/vbi.h>
+#include <vbi/errors.h>
+
+#define START_FRAME_IRQ_NAME	"start"
+#define END_FRAME_IRQ_NAME	"end"
+
+/* a simple start of frame interrupt handler */
+static irqreturn_t start_frame_interrupt(int irq, void *p)
+{
+	return IRQ_HANDLED;
+}
+
+/* a simple end of frame interrupt handler */
+static irqreturn_t end_frame_interrupt(int irq, void *p)
+{
+	return IRQ_HANDLED;
+}
+
+/* certifiable hypervisor support start and end frame transition interrupts.
+   User can make use of this interrupt to maintain house keeping related tasks.
+*/
+static int __init frame_transition_test_init(void)
+{
+	int rc;
+	int start_irq;
+	int end_irq;
+
+	printk(KERN_INFO "Initialize frame transition interrupt test");
+
+	/* scheduled transition vbi, the schedule name "init" is
+	 * defined in the scheduler section of wrhvConfig.xml
+	 */
+	rc = vbi_sched_transition("init", SCHEDULER_TRANSITION_MAJOR,
+		VBI_VCORE_ID_GET());
+
+	if (rc) {
+		printk(KERN_WARNING
+			"Failed to schedule transition %s core id=%d\n", "init",
+			 VBI_VCORE_ID_GET());
+	}
+
+	start_irq = vbi_find_irq(START_FRAME_IRQ_NAME, 1);
+	if (start_irq != VBI_INVALID_IRQ) {
+		/* request start frame interrupt handler */
+		rc = request_irq(start_irq, start_frame_interrupt,
+				IRQF_SHARED, "start_frame_interrupt",
+				start_frame_interrupt);
+		if (rc) {
+			printk(KERN_WARNING 
+				"Failed to request start frame irq at %d\n", start_irq);
+		}
+	}
+
+	end_irq = vbi_find_irq(END_FRAME_IRQ_NAME, 1);
+	if (end_irq != VBI_INVALID_IRQ) {
+		/* request end frame interrupt handler */
+		rc = request_irq(end_irq, end_frame_interrupt,
+				IRQF_SHARED, "end_frame_interrupt",
+				end_frame_interrupt);
+		if (rc) {
+			printk(KERN_WARNING 
+				"Failed to request start frame irq at %d\n", end_irq);
+		}
+	}
+
+	return rc;
+}
+module_init(frame_transition_test_init);
+
+
-- 
1.7.0.4

