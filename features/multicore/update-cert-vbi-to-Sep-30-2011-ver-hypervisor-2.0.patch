From 2566719dc897050df9ed1fa06cad9a69085efa34 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Mon, 17 Oct 2011 12:45:08 +0800
Subject: [PATCH 1/2] update cert vbi to Sep 30, 2011 - ver hypervisor 2.0

The main change is that port vbi is dropped. In hypervisor
2.0, port vbi was designed to implement Safe IPC, but now
Safe IPC is implemented using the PDC messaging calls, so
port vbi is already stale and need to be dropped.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/x86/kernel/vbi/syscalls.S |    8 --
 include/vbi/interface.h        |   58 ----------
 include/vbi/private.h          |    2 -
 include/vbi/syscall.h          |    9 --
 kernel/vbi/Makefile            |    2 +-
 kernel/vbi/port.c              |  235 ----------------------------------------
 6 files changed, 1 insertions(+), 313 deletions(-)
 delete mode 100644 kernel/vbi/port.c

diff --git a/arch/x86/kernel/vbi/syscalls.S b/arch/x86/kernel/vbi/syscalls.S
index 752cba1..2221592 100644
--- a/arch/x86/kernel/vbi/syscalls.S
+++ b/arch/x86/kernel/vbi/syscalls.S
@@ -651,12 +651,4 @@ vbi_hcall(vbi_vb_set_priority, vbPrioSet, 3)
  */
 vbi_hcall(vbi_sched_control_op, schedControl, 5)
 
-/*
- * vbi_port_op - port operations
- *
- * This system call executes a port operation.
- *
- * Returns: OK or ERROR if transition setup is not successful
- */
-vbi_hcall(vbi_port_op, port, 3)
 #endif
diff --git a/include/vbi/interface.h b/include/vbi/interface.h
index 92c369a..48d7ae6 100644
--- a/include/vbi/interface.h
+++ b/include/vbi/interface.h
@@ -270,29 +270,10 @@ identity mapped.
 #define SCHEDULER_TRANSITION_MINOR 2
 #define SCHEDULER_TRANSITION_TICK  3
 
-/* define port operation definitions */
-#define PORT_SEND 1
-#define PORT_BUF_RELEASE 2
-
 #endif
 
 #ifndef	_ASMLANGUAGE
 
-#ifdef CONFIG_WRHV_CERT
-/* port direction type */
-enum PORT_DIRECTION {
-	SOURCE = 0,
-	DESTINATION
-};
-
-/* queuing port protocol */
-enum PORT_PROTOCOL_MODE {
-	SENDER_BLOCK = 0,
-	RECEIVER_DISCARD,
-	NOT_APPLICABLE
-};
-#endif
-
 /*
  * vb_control - Virtual board cores control structure
  *
@@ -455,17 +436,6 @@ struct vb_control
  *
  */
 
-#ifdef CONFIG_WRHV_CERT
-struct vb_port_status{
-	VB_ALIGN_FIELD_64(uint8_t *s_buf, pad1);         /* SIPC buffer */
-	VB_ALIGN_FIELD_64(uint32_t *msg_len_array, pad2); /* message length */
-	uint32_t    write_index;             	/* write buffer index */
-	uint32_t    read_index;              	/* index of buffer to read */
-	uint32_t    num_msg;                 	/* number of messages */
-	uint32_t    mem_align_msg_size; 	/* max msg size aligned */
-};
-#endif
-
 struct vb_status {
 
 #ifdef _WRHV_ARCH_HAS_STATUS_REGS
@@ -512,11 +482,6 @@ struct vb_status {
 	/* The simulatror flag  */
 	uint32_t sim;
 
-#ifdef CONFIG_WRHV_CERT
-	/* port staus information */
-	VB_ALIGN_FIELD_64(struct vb_port_status *port_status, pad3);
-#endif
-
 };
 
 #define ALIGN_DEV_INFO_SIZE	8	/* vb_dev_info, vb_dev_int_info,
@@ -621,22 +586,6 @@ struct config_page_map
 	uint32_t accessPriv;
 };
 
-#if defined(CONFIG_WRHV_CERT)
-/* Information for the port configuration */
-
-/* Field order in this structure must match the ones in board_q_port_t */
-struct vb_port_config {
-	uint32_t vb_port_id;	/* unique Id starting at 0 */
-	char name[VB_NAMELEN];	/* port name */
-	uint32_t vb_id;		/* vb Id where port reside */
-	uint32_t channel_id;	/* channel id to which the port is connected */
-	uint32_t direction;	/* SOURCE or DESTINATION */
-	uint32_t protocol;	/* SENDER_BLOCK or RECEIVER_DISCARD */
-	uint32_t max_msg_size;	/* max messages size in bytes */
-	uint32_t max_num_msgs;	/* queue length */
-};
-#endif
-
 struct vb_config
 {
 
@@ -763,13 +712,6 @@ struct vb_config
 	struct config_page_map configPageMap[MAX_VB_CONFIG_REGIONS];
 	uint32_t configPageNum;
 
-#if defined(CONFIG_WRHV_CERT)
-	uint32_t num_ports;
-
-	/* ports configuration information */
-	VB_ALIGN_FIELD_64(struct vb_port_config *port_config, pad12);
-#endif
-
 	/* guest type */
 
 	uint32_t   guestOS;
diff --git a/include/vbi/private.h b/include/vbi/private.h
index bb27e48..3bda932 100644
--- a/include/vbi/private.h
+++ b/include/vbi/private.h
@@ -42,8 +42,6 @@ extern asmlinkage int32_t vbi_ns_op(uint32_t op, char* name, uint32_t rev,
 extern asmlinkage int32_t vbi_sched_control_op(uint32_t transition,
 			char *sched_name, void *transition_type, void *core_id,
 			void *args);
-extern asmlinkage int32_t vbi_port_op(uint32_t operation_type,
-			uint32_t vb_port_id, uint32_t length);
 #endif
 
 /* Message receive private operator */
diff --git a/include/vbi/syscall.h b/include/vbi/syscall.h
index 63edf9e..d7c6ed8 100644
--- a/include/vbi/syscall.h
+++ b/include/vbi/syscall.h
@@ -165,15 +165,6 @@ extern asmlinkage void cert_debug_vbi_shell_start_debug(uint32_t  flags);
 extern int32_t vbi_sched_transition(char *name, uint32_t transition_type,
 				uint32_t core_id);
 
-/* port api */
-extern int32_t vbi_port_id_get(char *name,  uint32_t *vb_port_id);
-
-extern int32_t vbi_port_send(uint32_t vb_port_id, const char *message,
-				size_t length);
-
-extern int32_t vbi_port_receive(uint32_t vb_port_id, char *buffer,
-				size_t *length);
-
 /* system call prototypes for use within a context */
 static inline int vbi_ctx_ctl(unsigned operation, unsigned arg1,
 				unsigned arg2)
diff --git a/kernel/vbi/Makefile b/kernel/vbi/Makefile
index 11d3144..5b19c6a 100644
--- a/kernel/vbi/Makefile
+++ b/kernel/vbi/Makefile
@@ -9,6 +9,6 @@
 obj-$(CONFIG_WRHV) += shmem.o wrhv.o interrupt.o paddr.o idle.o io_apic.o lib.o \
                       version.o msg.o ns.o show.o pdc.o device.o procfs.o
 
-obj-$(CONFIG_WRHV_CERT) += sched.o port.o
+obj-$(CONFIG_WRHV_CERT) += sched.o
 
 obj-y += syscall_vbi.o
diff --git a/kernel/vbi/port.c b/kernel/vbi/port.c
deleted file mode 100644
index a82b78d..0000000
--- a/kernel/vbi/port.c
+++ /dev/null
@@ -1,235 +0,0 @@
-/*
- * port.c - hypervisor vbi port library
- *
- * Copyright (c) 2011 Wind River Systems, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- *
- */
-
-#include <linux/string.h>
-#include <vbi/vbi.h>
-#include <vbi/private.h>
-
-/*
-
-DESCRIPTION
-
-This module implements the inter-VB communication services through queuing
-ports. The APIs in this module are non-blocking. ERROR is returned when sending
-a message and the queue is fulll or when receiving a message and the queue
-is empty
-
-*/
-
-#ifdef DEBUG
-#define DEBUGM(x) x
-#else
-#define DEBUGM(x)
-#endif
-
-/*******************************************************************************
-*
-* vbi_port_id_get - return the port id given his name
-*
-* The name is case sensitive
-*
-* RETURNS: OK if the port name was found.
-*	   ERROR otherwise.
-*
-* ERRNO: N/A
-*
-* SEE ALSO: vbi_port_send(), vbi_port_receive().
-*/
-int32_t vbi_port_id_get(char *name,  uint32_t *vb_port_id)
-{
-	uint32_t i;
-	int32_t ret_val = -1;
-
-	/* go through all ports config to find a matching name */
-	for (i = 0; i < VBI_CONFIG_ADDR_GET()->num_ports; i++) {
-		if (strncmp((const char *)name,
-			(const char *)(&(VBI_CONFIG_ADDR_GET()->port_config[i].name)),
-			VB_NAMELEN) == 0) {
-				*vb_port_id =
-				VBI_CONFIG_ADDR_GET()->port_config[i].vb_port_id;
-				ret_val = 0;
-				break;
-			}
-	}
-	return ret_val;
-}
-
-/*******************************************************************************
-*
-* vbi_port_send - send a message to a queuing port
-*
-* This routine copies the message to send to the source port's message buffer,
-* if space is available, and makes a hypercall.
-*
-* RETURNS: OK if message could be copied to the source port message queue.
-*	   ERROR otherwise.
-*
-* ERRNO: N/A
-*
-* SEE ALSO: vbi_port_receive(), vbi_port_id_get().
-*/
-
-int32_t vbi_port_send(uint32_t vb_port_id, const char *message, size_t length)
-{
-	int32_t status = 0;
-	uint8_t *s_buf;
-	struct vb_port_status *port_status;
-	struct vb_port_config *port_config;
-
-	/* make sure the port id is valid and it is a source port and that the
-	 * message is not too long for this port
-	 */
-
-	if ((vb_port_id >= VBI_CONFIG_ADDR_GET()->num_ports) ||
-		(VBI_CONFIG_ADDR_GET()->port_config[vb_port_id].direction != SOURCE) ||
-		(VBI_CONFIG_ADDR_GET()->port_config[vb_port_id].max_msg_size < length)) {
-		return -1;
-	}
-
-	/* lock interrupt when manipulating port status fields */
-	vbi_vcore_irq_lock();
-
-	/* make sure port is not full */
-	if (VBI_CONFIG_ADDR_GET()->vb_status->port_status[vb_port_id].num_msg ==
-		VBI_CONFIG_ADDR_GET()->port_config[vb_port_id].max_num_msgs) {
-		vbi_vcore_irq_unlock();
-		return -1;
-	}
-
-	port_status =
-		&(VBI_CONFIG_ADDR_GET()->vb_status->port_status[vb_port_id]);
-
-	DEBUGM(printk(KERN_INFO
-		"vbi_port_send: port_status.s_buf %p\n", port_status->s_buf);)
-	DEBUGM(printk(KERN_INFO
-		"vbi_port_send: port_status.msg_len_array %p\n",
-		port_status->msg_len_array);)
-	DEBUGM(printk(KERN_INFO
-		"vbi_port_send: port_status.write_index %d\n",
-		port_status->write_index);)
-	DEBUGM(printk(KERN_INFO
-		"vbi_port_send: port_status.read_index %d\n",
-		port_status->read_index);)
-	DEBUGM(printk(KERN_INFO
-		"vbi_port_send: port_status.num_msg %d\n",
-		port_status->num_msg);)
-
-	port_config = &(VBI_CONFIG_ADDR_GET()->port_config[vb_port_id]);
-
-	/* get the pointer to the buffer where the message should be copied */
-	s_buf = port_status->s_buf +
-		(port_status->write_index * port_status->mem_align_msg_size);
-	DEBUGM(KERN_INFO printk("vbi_port_send: s_buf %p\n", s_buf);)
-
-	/* copy the message in the queue */
-	memcpy((void *)message, (void *)s_buf, length);
-
-	/* make a hypercall to notify HV that there is a new message
-	 * in the queue
-	 */
-	status = vbi_port_op(PORT_SEND, vb_port_id, length);
-
-	vbi_vcore_irq_unlock();
-
-	return status;
-}
-
-/*******************************************************************************
-*
-* vbi_port_receive - receive a message from a queuing port
-*
-* This routine copies to the provided buffer a message from the port's queue,
-* if any.
-*
-* RETURNS: OK if a message has been received,
-	   ERROR otherwise.
-*
-* ERRNO: N/A
-*
-* SEE ALSO: vbi_port_send(), vbi_port_id_get()
-*/
-
-int32_t vbi_port_receive(uint32_t vb_port_id, char *buffer, size_t *length)
-{
-
-	uint8_t *s_buf;
-	uint32_t msg_len;
-	int32_t	status;
-	struct vb_port_status *port_status;
-	struct vb_port_config *port_config;
-
-	/* make sure the port id is valid and that itis a destination port */
-	if ((vb_port_id >= VBI_CONFIG_ADDR_GET()->num_ports) ||
-		(VBI_CONFIG_ADDR_GET()->port_config[vb_port_id].direction !=
-		DESTINATION)) {
-		return -1;
-	}
-
-	/* lock interrupt when manipulating port status fields */
-	vbi_vcore_irq_lock();
-
-	/* verify if there is any mssage in the destination queue */
-	if (VBI_CONFIG_ADDR_GET()->vb_status->port_status[vb_port_id].num_msg
-		 == 0) {
-		vbi_vcore_irq_unlock();
-		return -1;
-	}
-
-	port_status =
-		&(VBI_CONFIG_ADDR_GET()->vb_status->port_status[vb_port_id]);
-
-	DEBUGM(printk(KERN_INFO
-		"vbi_port_receive: port_status.s_buf %p\n",
-		port_status->s_buf);)
-	DEBUGM(printk(KERN_INFO
-		"vbi_port_receive: port_status.msg_len_array %p\n",
-		port_status->msg_len_array);)
-	DEBUGM(printk(KERN_INFO
-		"vbi_port_receive: port_status.write_index %d\n",
-		port_status->write_index);)
-	DEBUGM(printk(KERN_INFO
-		"vbi_port_receive: port_status.read_index %d\n",
-		port_status->read_index);)
-	DEBUGM(printk(KERN_INFO
-		"vbi_port_receive: port_status.num_msg %d\n",
-		port_status->num_msg);)
-
-	port_config = &(VBI_CONFIG_ADDR_GET()->port_config[vb_port_id]);
-
-	/* get the pointer to the buffer where the message to be read reside */
-	s_buf = port_status->s_buf +
-		(port_status->read_index * port_status->mem_align_msg_size);
-	DEBUGM(printk(KERN_INFO
-		"vbi_port_receive: s_buf %p\n", s_buf);)
-
-	/* get the length of the message to be received */
-	msg_len = port_status->msg_len_array[port_status->read_index];
-	DEBUGM(printk(KERN_INFO
-		"vbi_port_receive: msg_len %d\n", msg_len);)
-
-	/* copy the message to the buffer provided */
-	memcpy((void *)s_buf, (void *)buffer, msg_len);
-
-	/* make a hypercall to notify HV that a message has been read */
-	status = vbi_port_op((int)PORT_BUF_RELEASE, (int)vb_port_id, 0);
-
-	vbi_vcore_irq_unlock();
-
-	/* return the message length */
-	*length = msg_len;
-
-	return status;
-}
-- 
1.7.0.4

