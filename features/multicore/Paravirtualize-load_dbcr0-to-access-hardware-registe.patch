From f0a849c209261736c49a642eefdd1a95e939d139 Mon Sep 17 00:00:00 2001
From: Thomas Tai <thomas.tai@windriver.com>
Date: Fri, 20 Aug 2010 10:55:10 -0700
Subject: [PATCH 3/3] Paravirtualize load_dbcr0 to access hardware register

Signed-off-by: Thomas Tai <thomas.tai@windriver.com>
---
 arch/powerpc/kernel/entry_32.S          |   10 ++++++
 arch/powerpc/kernel/paravirt_entry_32.S |    5 +++
 arch/powerpc/kernel/wrhv_entry_32.S     |   48 +++++++++++++++++++++++++++++--
 3 files changed, 60 insertions(+), 3 deletions(-)

diff --git a/arch/powerpc/kernel/entry_32.S b/arch/powerpc/kernel/entry_32.S
index 14d620a..88d3fe4 100644
--- a/arch/powerpc/kernel/entry_32.S
+++ b/arch/powerpc/kernel/entry_32.S
@@ -1170,7 +1170,16 @@ ret_from_mcheck_exc:
  * having first saved away the global DBCR0.  Note that r0
  * has the dbcr0 value to set upon entry to this.
  */
+	.globl  load_dbcr0
 load_dbcr0:
+#ifndef CONFIG_PARAVIRT
+	b	native_load_dbcr0
+#else
+	b	paravirt_load_dbcr0
+#endif
+
+	.globl native_load_dbcr0
+native_load_dbcr0:
 	mfmsr	r10		/* first disable debug exceptions */
 	rlwinm	r10,r10,0,~MSR_DE
 	mtmsr	r10
@@ -1195,6 +1204,7 @@ load_dbcr0:
 
 	.section .bss
 	.align	4
+	.globl	global_dbcr0
 global_dbcr0:
 	.space	8*NR_CPUS
 	.previous
diff --git a/arch/powerpc/kernel/paravirt_entry_32.S b/arch/powerpc/kernel/paravirt_entry_32.S
index ce8bfdb..32077b6 100644
--- a/arch/powerpc/kernel/paravirt_entry_32.S
+++ b/arch/powerpc/kernel/paravirt_entry_32.S
@@ -34,6 +34,11 @@ paravirt_syscall_exit_work:
 paravirt_restore:
 	b	native_restore
 
+	.globl	paravirt_load_dbcr0
+	.weak	paravirt_load_dbcr0
+paravirt_load_dbcr0:
+	b	native_load_dbcr0
+
 _GLOBAL(paravirt_switch)
 .weak paravirt_switch
 	b	native_switch
diff --git a/arch/powerpc/kernel/wrhv_entry_32.S b/arch/powerpc/kernel/wrhv_entry_32.S
index 5e3ab79..5ce9ec0 100644
--- a/arch/powerpc/kernel/wrhv_entry_32.S
+++ b/arch/powerpc/kernel/wrhv_entry_32.S
@@ -84,19 +84,34 @@ paravirt_transfer_to_handler:
 	beq	2f			/* if from user, fix up THREAD.regs */
 	addi	r11,r1,STACK_FRAME_OVERHEAD
 	stw	r11,PT_REGS(r12)
-#if 0
 #if defined(CONFIG_40x) || defined(CONFIG_BOOKE)
+	/* Check to see if the dbcr0 register is set up to debug.  Use the
+	internal debug mode bit to do this. */
+	lwz	r12,THREAD_DBCR0(r12)
+	andis.	r12,r12,DBCR0_IDM@h
+	beq+	3f
+	/* From user and task is ptraced - load up global dbcr0 */
+	li	r12,-1                  /* clear all pending debug events */
+	lis	r9,wr_control@ha
+	lwz	r9,wr_control@l(r9)
+	stw	r12,VB_CONTROL_DBCR0(r9)
+	lis	r11,global_dbcr0@ha
+	tophys(r11,r11)
+	addi	r11,r11,global_dbcr0@l
 #ifdef CONFIG_SMP
 	rlwinm	r9,r1,0,0,(31-THREAD_SHIFT)
 	lwz	r9,TI_CPU(r9)
 	slwi	r9,r9,3
 	add	r11,r11,r9
 #endif
+	lwz	r12,0(r11)
+	lis	r9,wr_control@ha
+	lwz	r9,wr_control@l(r9)
+	stw	r12,VB_CONTROL_DBCR0(r9)
 	lwz	r12,4(r11)
 	addi	r12,r12,-1
 	stw	r12,4(r11)
 #endif
-#endif
 	b	3f
 
 2:	/* if from kernel, check interrupted DOZE/NAP mode and
@@ -240,7 +255,7 @@ paravirt_ret_from_syscall:
 	oris	r11,r11,0x1000	/* Set SO bit in CR */
 	stw	r11,_CCR(r1)
 paravirt_syscall_exit_cont:
-#if defined(CONFIG_4xx) || defined(CONFIG_BOOKE) && !(CONFIG_WRHV)
+#if defined(CONFIG_4xx) || defined(CONFIG_BOOKE)
 	/* If the process has its own DBCR0 value, load it up.  The internal
 	   debug mode bit tells us that dbcr0 should be loaded. */
 	lwz	r0,THREAD+THREAD_DBCR0(r2)
@@ -507,3 +522,30 @@ paravirt_restore:
 	/* Never back from here */
 #endif /* CONFIG_WRHV */
 
+	.globl  paravirt_load_dbcr0
+paravirt_load_dbcr0:
+	lis	r9,wr_control@ha
+	lwz	r9,wr_control@l(r9)
+	lwz	r10,VB_CONTROL_DBCR0(r9)
+	lis	r11,global_dbcr0@ha
+	addi	r11,r11,global_dbcr0@l
+#ifdef CONFIG_SMP
+	rlwinm	r9,r1,0,0,(31-THREAD_SHIFT)
+	lwz	r9,TI_CPU(r9)
+	slwi	r9,r9,3
+	add 	r11,r11,r9
+#endif
+	stw	r10,0(r11)
+	lis	r9,wr_control@ha
+	lwz	r9,wr_control@l(r9)
+	stw	r0,VB_CONTROL_DBCR0(r9)
+	lwz	r10,4(r11)
+	addi	r10,r10,1
+	stw	r10,4(r11)
+	li	r11,-1
+	/* clear all pending debug events */
+	lis	r9,wr_control@ha
+	lwz	r9,wr_control@l(r9)
+	stw	r11,VB_CONTROL_DBSR(r9)
+	blr
+
-- 
1.6.5.2

