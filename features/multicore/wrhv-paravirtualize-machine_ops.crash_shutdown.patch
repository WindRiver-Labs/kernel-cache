From 1d046f1882446df5e18cde7315f7ef94e63f3bcb Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Mon, 25 Nov 2013 12:59:13 +0800
Subject: [PATCH 2/2] wrhv: paravirtualize machine_ops.crash_shutdown

machine_ops.crash_shutdown need to be paravirtualized in
kdump scenario smp mode. implement it here

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/x86/kernel/irq_64.c   |    7 ++++
 arch/x86/kernel/vbi/wrhv.c |   87 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 94 insertions(+), 0 deletions(-)

diff --git a/arch/x86/kernel/irq_64.c b/arch/x86/kernel/irq_64.c
index acf8fbf..f9dbb4c 100644
--- a/arch/x86/kernel/irq_64.c
+++ b/arch/x86/kernel/irq_64.c
@@ -48,11 +48,18 @@ static inline void stack_overflow_check(struct pt_regs *regs)
 #endif
 }
 
+#if defined(CONFIG_WRHV) && defined(CONFIG_KEXEC)
+struct pt_regs wrhv_kexec_pt_regs;
+DEFINE_PER_CPU(struct pt_regs, wrhv_kexec_pt_regs);
+#endif
 bool handle_irq(unsigned irq, struct pt_regs *regs)
 {
 	struct irq_desc *desc;
 
 	stack_overflow_check(regs);
+#if defined(CONFIG_WRHV) && defined(CONFIG_KEXEC)
+	per_cpu(wrhv_kexec_pt_regs, raw_smp_processor_id()) = *regs;
+#endif
 
 	desc = irq_to_desc(irq);
 	if (unlikely(!desc))
diff --git a/arch/x86/kernel/vbi/wrhv.c b/arch/x86/kernel/vbi/wrhv.c
index b3b1830..17aacdd 100644
--- a/arch/x86/kernel/vbi/wrhv.c
+++ b/arch/x86/kernel/vbi/wrhv.c
@@ -38,6 +38,9 @@
 #include <asm/desc.h>
 #include <asm/e820.h>
 #include <asm/i8259.h>
+#if defined(CONFIG_KEXEC) && defined(CONFIG_X86_64)
+#include <linux/kexec.h>
+#endif
 
 
 #define WRHV_DEBUG_MSR          0
@@ -1669,6 +1672,87 @@ void wrhv_restart(void)
 	while (1);
 }
 
+#if defined(CONFIG_KEXEC) && defined(CONFIG_X86_64)
+DECLARE_PER_CPU(struct pt_regs, wrhv_kexec_pt_regs);
+static int crashing_cpu;
+static atomic_t waiting_for_crash_ipi;
+static void wrhv_shootdown_cb(void * t)
+{
+	int cpu;
+
+	cpu = raw_smp_processor_id();
+
+	/* Don't do anything if this handler is invoked on crashing cpu.
+	 * Otherwise, system will completely hang. Crashing cpu can get
+	 * an NMI if system was initially booted with nmi_watchdog parameter.
+	 */
+	if (cpu == crashing_cpu)
+		return;
+
+	local_irq_disable();
+
+	crash_save_cpu(&per_cpu(wrhv_kexec_pt_regs, cpu), cpu);
+
+	atomic_dec(&waiting_for_crash_ipi);
+
+	write_cr3(__pa(swapper_pg_dir));
+
+	vbi_vb_reset(VBI_BOARD_ID_GET(), raw_smp_processor_id(), 0);
+
+	/*
+	 * Verbose report that reset self core failed then
+	 * into infinite loop
+	 */
+	BUG();
+	while (1);
+}
+
+static void wrhv_kdump_shootdown_cpus(void)
+{
+	unsigned long msecs;
+	local_irq_disable();
+
+	/* Make a note of crashing cpu. Will be used in NMI callback.*/
+	crashing_cpu = safe_smp_processor_id();
+
+	atomic_set(&waiting_for_crash_ipi, num_online_cpus() - 1);
+	smp_call_function(wrhv_shootdown_cb, NULL, 0);
+/*
+	cpumask_clear_cpu(this_cpu, data->cpumask);
+	smp_call_function_many(cpu_online_mask
+*/
+
+	msecs = 1000; /* Wait at most a second for the other cpus to stop */
+	while ((atomic_read(&waiting_for_crash_ipi) > 0) && msecs) {
+		mdelay(1);
+		msecs--;
+	}
+
+	/* Leave the nmi callback set */
+}
+
+void wrhv_machine_crash_shutdown(struct pt_regs *regs)
+{
+	/* This function is only called after the system
+	 * has panicked or is otherwise in a critical state.
+	 * The minimum amount of code to allow a kexec'd kernel
+	 * to run successfully needs to happen here.
+	 *
+	 * In practice this means shooting down the other cpus in
+	 * an SMP system.
+	 */
+	/* The kernel is broken so disable interrupts */
+	local_irq_disable();
+
+	wrhv_kdump_shootdown_cpus();
+
+#ifdef CONFIG_HPET_TIMER
+	hpet_disable();
+#endif
+	crash_save_cpu(regs, safe_smp_processor_id());
+}
+#endif
+
 void __init wrhv_setup_timer_irq(void)
 {
 #ifdef CONFIG_WRHV_X86_HRTIMERS
@@ -1714,6 +1798,9 @@ void __init wrhv_init(void)
 	x86_init.irqs.intr_init = wrhv_init_IRQ;
 
 	machine_ops.emergency_restart = wrhv_restart;
+#if defined(CONFIG_KEXEC) && defined(CONFIG_X86_64)
+	machine_ops.crash_shutdown = wrhv_machine_crash_shutdown,
+#endif
 
 #ifdef CONFIG_KGDB
 	arch_kgdb_ops.flags &= ~KGDB_HW_BREAKPOINT,
-- 
1.7.0

