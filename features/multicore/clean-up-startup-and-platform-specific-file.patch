From 6aabc53f4896714d4d64d1e27e9a179f9829e11f Mon Sep 17 00:00:00 2001
From: Thomas Tai <thomas.tai@windriver.com>
Date: Tue, 13 Apr 2010 13:15:43 -0400
Subject: [PATCH 8/9] clean up startup and platform specific file

Correct tab vs white space coding style for wrhv_head_stdmmu.S,
changed incorrect comments and wrong pci node name on platform
file.

Signed-off-by: Thomas Tai <thomas.tai@windriver.com>
---
 arch/powerpc/kernel/head_wrhv_stdmmu.S      |  358 ++++++++++++++-------------
 arch/powerpc/platforms/86xx/wrhv_mpc8641d.c |   13 +-
 2 files changed, 187 insertions(+), 184 deletions(-)

diff --git a/arch/powerpc/kernel/head_wrhv_stdmmu.S b/arch/powerpc/kernel/head_wrhv_stdmmu.S
index 72596d7..4420a5c 100644
--- a/arch/powerpc/kernel/head_wrhv_stdmmu.S
+++ b/arch/powerpc/kernel/head_wrhv_stdmmu.S
@@ -43,6 +43,9 @@
 #include <vbi/syscalls.h>
 #endif
 
+/*
+ * Following section is based on head_32.S
+ */
 /* 601 only have IBAT; cr0.eq is set on 601 when using this macro */
 #define LOAD_BAT(n, reg, RA, RB)	\
 	/* see the comment for clear_bats() -- Cort */ \
@@ -129,56 +132,56 @@ turn_on_mmu:
 	b	start_here
 
 /*
- * Refer to head_wrhv.S for reference
+ * Following section is based on head_wrhv.S
  */
 #if defined(CONFIG_PTE_64BIT) || defined(CONFIG_WRHV)
-#  define FIND_PTE_ADDR \
-        rlwinm  r12, r10, 13, 19, 29;   /* Compute pgdir/pmd offset */  \
-        lwzx    r11, r12, r11;          /* Get pgd/pmd entry */         \
-        rlwinm. r12, r11, 0, 0, 20;     /* Extract pt base address */   \
-        rlwimi  r12, r10, 23, 20, 28;   /* Compute pte address */
-
-#    define LOAD_PTE \
-        lwz     r11, 4(r12);
-
-#  ifdef CONFIG_SMP
-#    define LWARX_PTE \
-        li      r11, 4;                                                 \
-        lwarx   r11, r11, r12;          /* lwarx pte */
-
-#    define STWCX_PTE \
-        addi    r12, r12, 4;    \
-        stwcx.  r11, 0, r12;    \
-        addi    r12, r12, -4;
+#define FIND_PTE_ADDR \
+	rlwinm	r12, r10, 13, 19, 29;	/* Compute pgdir/pmd offset */  \
+	lwzx	r11, r12, r11;		/* Get pgd/pmd entry */         \
+	rlwinm.	r12, r11, 0, 0, 20;	/* Extract pt base address */   \
+	rlwimi	r12, r10, 23, 20, 28;	/* Compute pte address */
+
+#define LOAD_PTE \
+	lwz	r11, 4(r12);
+
+#ifdef CONFIG_SMP
+#define LWARX_PTE \
+	li	r11, 4;                                                 \
+	lwarx	r11, r11, r12;		/* lwarx pte */
+
+#define STWCX_PTE \
+	addi	r12, r12, 4;    \
+	stwcx.	r11, 0, r12;    \
+	addi	r12, r12, -4;
 #else
-#    define LWARX_PTE \
-        lwz     r11, 4(r12)
+#define LWARX_PTE \
+	lwz	r11, 4(r12)
 
-#    define STWCX_PTE \
-        stw     r11, 4(r12)
+#define STWCX_PTE \
+	stw	r11, 4(r12)
 #endif /* CONFIG_SMP */
 
 #else /* 32-bit PTEs */
-#  define FIND_PTE_ADDR \
-        rlwinm  r12, r10, 12, 20, 29;   /* Compute pgdir/pmd offset */  \
-        lwzx    r11, r12, r11;          /* Get L1 entry */              \
-        rlwinm. r12, r11, 0, 0, 19;     /* Extract pte base address */  \
-        rlwimi  r12, r10, 22, 20, 29;   /* Compute PTE address */       \
-
-#    define LOAD_PTE \
-        lwz     r11, 0(r12);
-
-#  ifdef CONFIG_SMP
-#    define LWARX_PTE \
-        lwarx   r11, 0, r12;            /* lwarx pte */
-#    define STWCX_PTE \
-        stwcx.  r11, 0, r12;
-#  else
-#    define LWARX_PTE \
-        lwz     r11, 0(r12);
-#    define STWCX_PTE \
-        stw     r11, 0(r12);
-#  endif
+#define FIND_PTE_ADDR \
+	rlwinm	r12, r10, 12, 20, 29;	/* Compute pgdir/pmd offset */  \
+	lwzx	r11, r12, r11;		/* Get L1 entry */              \
+	rlwinm.	r12, r11, 0, 0, 19;	/* Extract pte base address */  \
+	rlwimi	r12, r10, 22, 20, 29;	/* Compute PTE address */       \
+
+#define LOAD_PTE \
+	lwz	r11, 0(r12);
+
+#ifdef CONFIG_SMP
+#define LWARX_PTE \
+	lwarx	r11, 0, r12;		/* lwarx pte */
+#define STWCX_PTE \
+	stwcx.	r11, 0, r12;
+#else
+#define LWARX_PTE \
+	lwz	r11, 0(r12);
+#define STWCX_PTE \
+	stw	r11, 0(r12);
+#endif
 #endif
 
 
@@ -352,123 +355,124 @@ i##n:								\
 
 /* Data access exception. */
 	. = 0x300
-        START_EXCEPTION(DataStorage)
-        /*    only  r3, r4, CR are saved in vb_status */
-        lis     r4,wr_control@ha
-        lwz     r4,wr_control@l(r4)
-        stw     r10,VB_CONTROL_R10(r4)
-        stw     r11,VB_CONTROL_R11(r4)
-        stw     r12,VB_CONTROL_R12(r4)
-        stw     r13,VB_CONTROL_R13(r4)
-
-        /*
-         * Check if it was a store fault, if not then bail
-         * because a user tried to access a kernel or
-         * read-protected page.  Otherwise, get the
-         * offending address and handle it.
-         */
-        lis     r11,wr_status@ha
-        lwz     r11,wr_status@l(r11)
-        lwz     r10,VB_STATUS_DSISR(r11)
-        srwi    r10,r10,16    /* get the store bit of DSISR */
-        andis.  r10, r10, DSISR_ISSTORE@h
-        beq     2f
+	START_EXCEPTION(DataStorage)
+	/*    only  r3, r4, CR are saved in vb_status */
+	lis	r4,wr_control@ha
+	lwz	r4,wr_control@l(r4)
+	stw	r10,VB_CONTROL_R10(r4)
+	stw	r11,VB_CONTROL_R11(r4)
+	stw	r12,VB_CONTROL_R12(r4)
+	stw	r13,VB_CONTROL_R13(r4)
+
+	/*
+	* Check if it was a store fault, if not then bail
+	* because a user tried to access a kernel or
+	* read-protected page.  Otherwise, get the
+	* offending address and handle it.
+	*/
+	lis	r11,wr_status@ha
+	lwz	r11,wr_status@l(r11)
+	lwz	r10,VB_STATUS_DSISR(r11)
+	srwi	r10,r10,16    /* get the store bit of DSISR */
+	andis.	r10, r10, DSISR_ISSTORE@h
+	beq	2f
 
 	/* never come here */
 	b	.
-        lwz     r10,VB_STATUS_DAR(r11)
+	lwz	r10,VB_STATUS_DAR(r11)
 
-        /* If we are faulting a kernel address, we have to use the
-         * kernel page tables.
-         */
-        lis     r11, PAGE_OFFSET@h
-        cmplw   0, r10, r11
-        bge     2f
+	/* If we are faulting a kernel address, we have to use the
+	* kernel page tables.
+	*/
+	lis	r11, PAGE_OFFSET@h
+	cmplw	0, r10, r11
+	bge	2f
 
-        /* Get the PGD for the current thread */
+	/* Get the PGD for the current thread */
 3:
-        WRHV_MFSPRG3(r11)
-        lwz     r11,PGDIR(r11)
+	WRHV_MFSPRG3(r11)
+	lwz	r11,PGDIR(r11)
 4:
-        FIND_PTE_ADDR
+	FIND_PTE_ADDR
 
-        beq     2f      /* Bail if there's no entry */
+	beq	2f	/* Bail if there's no entry */
 
 5:
-        LOAD_PTE
+	LOAD_PTE
 
-        /* Are _PAGE_USER & _PAGE_RW set & _PAGE_HWWRITE not? */
-        andi.   r13, r11, _PAGE_RW|_PAGE_USER|_PAGE_HWWRITE
-        cmpwi   0, r13, _PAGE_RW|_PAGE_USER
-        bne     2f                      /* Bail if not */
+	/* Are _PAGE_USER & _PAGE_RW set & _PAGE_HWWRITE not? */
+	andi.	r13, r11, _PAGE_RW|_PAGE_USER|_PAGE_HWWRITE
+	cmpwi	0, r13, _PAGE_RW|_PAGE_USER
+	bne	2f	/* Bail if not */
 
-        /* find the TLB index that caused the fault. */
-        tlbsx   0, r10
+/* find the TLB index that caused the fault. */
+	tlbsx	0, r10
 
 #if defined(CONFIG_SMP) && !defined(CONFIG_WRHV)
-        /*
-         * It's possible another processor kicked out the entry
-         * before we did our tlbsx, so check if we hit
-         */
-        mfspr   r13, SPRN_MAS1
-        rlwinm. r13,r13, 0, 0, 0;       /* Check the Valid bit */
-        beq     2f
+/*
+* It's possible another processor kicked out the entry
+* before we did our tlbsx, so check if we hit
+*/
+	mfspr	r13, SPRN_MAS1
+	rlwinm.	r13,r13, 0, 0, 0;	/* Check the Valid bit */
+	beq	2f
 #endif /* CONFIG_SMP */
 
 #if defined(CONFIG_SMP) && !defined(CONFIG_WRHV)
-        mr      r13, r11
-        LWARX_PTE
-        cmpw    r13, r11
-        bne-    7f
+	mr	r13, r11
+	LWARX_PTE
+	cmpw	r13, r11
+	bne-	7f
 #endif
 
-        /* Update 'changed'. */
-        ori     r11, r11, _PAGE_DIRTY|_PAGE_ACCESSED|_PAGE_HWWRITE
-        STWCX_PTE       /* r11 and r12 must be PTE and &PTE */
+	/* Update 'changed'. */
+	ori	r11, r11, _PAGE_DIRTY|_PAGE_ACCESSED|_PAGE_HWWRITE
+	STWCX_PTE	/* r11 and r12 must be PTE and &PTE */
 
 #if defined(CONFIG_SMP) && !defined(CONFIG_WRHV)
-        /*
-         * If the stwcx. failed, we invalidate the entry we just wrote,
-         * and start over
-         */
-        beq+    6f
-7:      mfspr   r13, SPRN_MAS1
-        rlwinm  r13, r13, 0, 1, 31      /* Clear Valid bit */
-        mtspr   SPRN_MAS1, r13
-        tlbwe
-
-        b       5b              /* Try again */
+	/*
+	 * If the stwcx. failed, we invalidate the entry we just wrote,
+	 * and start over
+	 */
+	beq+	6f
+7:
+	mfspr	r13, SPRN_MAS1
+	rlwinm	r13, r13, 0, 1, 31	/* Clear Valid bit */
+	mtspr	SPRN_MAS1, r13
+	tlbwe
+
+	b	5b		/* Try again */
 #endif  /* CONFIG_SMP */
 6:
 
-        /* Done...restore registers and get out of here.  */
-        mfspr   r11, SPRN_SPRG1
-        mfspr   r10, SPRN_SPRG0
-        rfi                     /* Force context change */
+	/* Done...restore registers and get out of here.  */
+	mfspr	r11, SPRN_SPRG1
+	mfspr	r10, SPRN_SPRG0
+	rfi			/* Force context change */
 
 2:
 #if defined(CONFIG_SMP) && !defined(CONFIG_WRHV)
-        /* Clear the reservation */
-        lis     r11, dummy_stwcx@h
-        ori     r11,r11, dummy_stwcx@l
-        stwcx.  r11, 0, r11
+	/* Clear the reservation */
+	lis	r11, dummy_stwcx@h
+	ori	r11,r11, dummy_stwcx@l
+	stwcx.	r11, 0, r11
 #endif
 
-        /*
-         * The bailout.  Restore registers to pre-exception conditions
-         * and call the heavyweights to help us out.
-         */
-        lis     r11,wr_control@ha
-        lwz     r11,wr_control@l(r11)
-        lwz     r13,VB_CONTROL_R13(r11)
-        lwz     r12,VB_CONTROL_R12(r11)
-        lwz     r10,VB_CONTROL_R10(r11)
-        lwz     r11,VB_CONTROL_R11(r11)
-        b       data_access
+	/*
+	 * The bailout.  Restore registers to pre-exception conditions
+	 * and call the heavyweights to help us out.
+	 */
+	lis	r11,wr_control@ha
+	lwz	r11,wr_control@l(r11)
+	lwz	r13,VB_CONTROL_R13(r11)
+	lwz	r12,VB_CONTROL_R12(r11)
+	lwz	r10,VB_CONTROL_R10(r11)
+	lwz	r11,VB_CONTROL_R11(r11)
+	b	data_access
 
 /* Instruction access exception. */
 	.=0x400
-        INSTRUCTION_STORAGE_EXCEPTION
+	INSTRUCTION_STORAGE_EXCEPTION
 
 /* External interrupt */
 	EXCEPTION(0x500, HardwareInterrupt, do_IRQ, EXC_XFER_LITE)
@@ -487,7 +491,7 @@ Alignment:
 /* Program check exception */
 	. = 0x700
 i0x700:
-        PROGRAM_EXCEPTION
+	PROGRAM_EXCEPTION
 
 /* Floating-point unavailable */
 	. = 0x800
@@ -513,9 +517,9 @@ END_FTR_SECTION_IFSET(CPU_FTR_FPU_UNAVAILABLE)
 	EXCEPTION(0xb00, Trap_0b, unknown_exception, EXC_XFER_EE)
 
 	/* System Call Interrupt */
-        START_EXCEPTION(SystemCall)
-        NORMAL_EXCEPTION_PROLOG
-        EXC_XFER_EE_LITE(0xc00, DoSyscall)
+	START_EXCEPTION(SystemCall)
+	NORMAL_EXCEPTION_PROLOG
+	EXC_XFER_EE_LITE(0xc00, DoSyscall)
 
 /* Single step - not used on 601 */
 	EXCEPTION(0xd00, SingleStep, single_step_exception, EXC_XFER_STD)
@@ -541,22 +545,22 @@ END_FTR_SECTION_IFSET(CPU_FTR_FPU_UNAVAILABLE)
  */
 	. = 0x1000
 	START_EXCEPTION(InstructionTLBMiss)
-        b       InstructionStorage
+	b       InstructionStorage
 
 /*
  * Handle TLB miss for DATA Load operation on 603/603e
  */
 	. = 0x1100
-        START_EXCEPTION(DataLoadTLBMiss)
-        b       data_access
+	START_EXCEPTION(DataLoadTLBMiss)
+	b       data_access
 
 /*
  * Handle TLB miss for DATA Store on 603/603e
  */
 	. = 0x1200
 DataStoreTLBMiss:
-        START_EXCEPTION(DataTLBError)
-        b       data_access
+	START_EXCEPTION(DataTLBError)
+	b       data_access
 
 #ifndef CONFIG_ALTIVEC
 #define altivec_assist_exception	unknown_exception
@@ -625,7 +629,7 @@ load_up_altivec:
  */
 	mfmsr	r5
 	oris	r5,r5,MSR_VEC@h
-	MTMSRD(r5)			/* enable use of AltiVec now */
+	MTMSRD(r5)		/* enable use of AltiVec now */
 	isync
 /*
  * For SMP, we don't do lazy AltiVec switching because it just gets too
@@ -731,14 +735,14 @@ _ENTRY(copy_and_flush)
 #ifdef CONFIG_GEMINI
 	.globl	__secondary_start_gemini
 __secondary_start_gemini:
-        mfspr   r4,SPRN_HID0
-        ori     r4,r4,HID0_ICFI
-        li      r3,0
-        ori     r3,r3,HID0_ICE
-        andc    r4,r4,r3
-        mtspr   SPRN_HID0,r4
-        sync
-        b       __secondary_start
+	mfspr	r4,SPRN_HID0
+	ori	r4,r4,HID0_ICFI
+	li	r3,0
+	ori	r3,r3,HID0_ICE
+	andc	r4,r4,r3
+	mtspr	SPRN_HID0,r4
+	sync
+	b	__secondary_start
 #endif /* CONFIG_GEMINI */
 
 	.globl __secondary_start_mpc86xx
@@ -879,29 +883,29 @@ start_here:
 	lis	r2,init_task@h
 	ori	r2,r2,init_task@l
 
-        /* ptr to current thread */
-        addi    r4,r2,THREAD    /* init task's THREAD */
-        WRHV_MTSPRG3(r4,r1)
-        /* Establish the interrupt vector offsets */
+/* ptr to current thread */
+	addi    r4,r2,THREAD	/* init task's THREAD */
+	WRHV_MTSPRG3(r4,r1)
+/* Establish the interrupt vector offsets */
 #ifndef CONFIG_WRHV_MILS
-        lis     r0,VBI_SYS_hyIoctl@h
-        ori     r0,r0,VBI_SYS_hyIoctl@l
-        lis     r3,VBI_HYIOCTL_EXCBASE@h
-        ori     r3,r3,VBI_HYIOCTL_EXCBASE@l
-        lis     r4,_start@h
-        ori     r4,r4,_start@l
-        sc
+	lis	r0,VBI_SYS_hyIoctl@h
+	ori	r0,r0,VBI_SYS_hyIoctl@l
+	lis	r3,VBI_HYIOCTL_EXCBASE@h
+	ori	r3,r3,VBI_HYIOCTL_EXCBASE@l
+	lis	r4,_start@h
+	ori	r4,r4,_start@l
+	sc
 #else
-        lis     r3,_start@h
-        ori     r3,r3,_start@l
-        bl      vbi_exec_vec_base_addr_set
+	lis	r3,_start@h
+	ori	r3,r3,_start@l
+	bl	vbi_exec_vec_base_addr_set
 #endif
 
-        /* stack */
-        lis     r1,init_thread_union@h
-        ori     r1,r1,init_thread_union@l
-        li      r0,0
-        stwu    r0,THREAD_SIZE-STACK_FRAME_OVERHEAD(r1)
+	/* stack */
+	lis	r1,init_thread_union@h
+	ori	r1,r1,init_thread_union@l
+	li	r0,0
+	stwu	r0,THREAD_SIZE-STACK_FRAME_OVERHEAD(r1)
 
 /*
  * Do early platform-specific initialization,
@@ -1043,18 +1047,18 @@ setup_cpm_bat:
  * Local functions
  */
 
-        /*
-         * Data TLB exceptions will bail out to this point
-         * if they can't resolve the lightweight TLB fault.
-         */
+	/*
+	 * Data TLB exceptions will bail out to this point
+	 * if they can't resolve the lightweight TLB fault.
+	 */
 data_access:
-        NORMAL_EXCEPTION_PROLOG
-        lis     r6,wr_status@ha
-        lwz     r6,wr_status@l(r6)
+	NORMAL_EXCEPTION_PROLOG
+	lis     r6,wr_status@ha
+	lwz     r6,wr_status@l(r6)
 	lwz     r5, VB_STATUS_DSISR(r6)
-	stw	r5, _ESR(r11)
-        lwz     r4, VB_STATUS_DAR(r6)
-        EXC_XFER_EE_LITE(0x300, handle_page_fault)
+	stw     r5, _ESR(r11)
+	lwz     r4, VB_STATUS_DAR(r6)
+	EXC_XFER_EE_LITE(0x300, handle_page_fault)
 
 
 /*
@@ -1063,7 +1067,7 @@ data_access:
  * native implementation
  */
 _GLOBAL(giveup_fpu)
-        blr
+	blr
 
 _GLOBAL(load_up_fpu)
 	blr
@@ -1095,7 +1099,7 @@ swapper_pg_dir:
  */
         .globl  dummy_stwcx
 dummy_stwcx:
-        .space  4
+	.space  4
 
 	.globl intercept_table
 intercept_table:
diff --git a/arch/powerpc/platforms/86xx/wrhv_mpc8641d.c b/arch/powerpc/platforms/86xx/wrhv_mpc8641d.c
index 697ebf4..bc2ec7b 100644
--- a/arch/powerpc/platforms/86xx/wrhv_mpc8641d.c
+++ b/arch/powerpc/platforms/86xx/wrhv_mpc8641d.c
@@ -48,7 +48,9 @@
 
 #include <sysdev/fsl_soc.h>
 #include <sysdev/fsl_pci.h>
-#define STAMP_FACTOR 8 /* See e500 reference manual (E500CORERM) section 9.3 */
+
+/* See e600 Core Reference Manual - Core Register Summary*/
+#define STAMP_FACTOR 4
 
 extern struct vb_config *wr_config;
 extern struct vb_status *wr_status;
@@ -56,9 +58,7 @@ extern struct vb_control *wr_control;
 
 static void __init wrhv_mpc8641_setup_freq(void)
 {
-	/* The cpu updates the Time Base every 8 CCB (Core Complex Bus)
-	 cycles.  According to section 9.1 of the core e500 reference manual
-	 the maximum value cannot exceed that of 1/8 the core frequency */
+	/* The time base increments at 1/4 of the MPX bus clock frequency. */
 	wrhv_cpu_freq = wr_config->stamp_freq * STAMP_FACTOR;
 }
 
@@ -100,8 +100,7 @@ static void __init mpc8641_setup_arch(void)
 	wrhv_mpc8641_setup_freq();
 #ifdef CONFIG_PCI
 	for_each_node_by_type(np, "pci") {
-		if (of_device_is_compatible(np, "fsl,mpc8540-pci") ||
-		    of_device_is_compatible(np, "fsl,mpc8548-pcie")) {
+		if (of_device_is_compatible(np, "fsl,mpc8561-pice")) {
 			struct resource rsrc;
 			of_address_to_resource(np, 0, &rsrc);
 			if ((rsrc.start & 0xfffff) == 0x8000)
@@ -145,7 +144,7 @@ static int __init mpc8641_probe(void)
 	unsigned long root = of_get_flat_dt_root();
 
 	wrhv_mpc8641_map_config();
-	return of_flat_dt_is_compatible(root, "fsl,mpc8641hpcn");
+	return of_flat_dt_is_compatible(root, "WRHV_MPC8641");
 }
 
 define_machine(mpc8641) {
-- 
1.6.5.2

