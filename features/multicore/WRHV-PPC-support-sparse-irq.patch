From d888de3f5d29706b531b4faee8737b30041b0e30 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Mon, 24 May 2010 20:33:03 +0800
Subject: [PATCH 07/14] WRHV/PPC: support sparse irq

When sparse_irq is used (CONFIG_SPARSE_IRQ), use kzalloc_node to get irq_desc. So
we have to add irq_to_desc_alloc_node while map irq.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/kernel/vbi/wrhv.c |   40 +++++++++++++++++++++++++++++++++-------
 1 files changed, 33 insertions(+), 7 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 505f195..0977c96 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -477,15 +477,22 @@ int ppc_setup_pci_law( struct device_node *dev)
 	return 0;
 }
 
+#ifdef CONFIG_SPARSE_IRQ
+#define WRHV_NR_IRQS	NR_IRQS_LEGACY
+#else
+#define WRHV_NR_IRQS	NR_IRQS
+#endif
 void __init wrhv_init_irq(void)
 {
 	int i;
+	struct irq_desc *desc;
 
 	wrhv_irq_chip.typename = "WRHV-PIC";
-	for (i = 0; i < NR_IRQS; i++) {
-		irq_desc[i].status = IRQ_DISABLED | IRQ_LEVEL;
-		irq_desc[i].action = NULL;
-		irq_desc[i].depth = 1;
+	for (i = 0; i < WRHV_NR_IRQS; i++) {
+		desc = irq_to_desc_alloc_node(i, 0);
+		desc->status = IRQ_DISABLED | IRQ_LEVEL;
+		desc->action = NULL;
+		desc->depth = 1;
 		set_irq_chip_and_handler(i, &wrhv_irq_chip, handle_fasteoi_irq);
 	}
 }
@@ -571,17 +578,36 @@ check_again:
 	trace_irq_exit(regs);
 }
 
-unsigned int wrhv_irq_of_parse_and_map(struct device_node *dev, int index)
+unsigned int wrhv_map_irq_of_desc(char *irq_name, int32_t irq_dir)
 {
 	int irq;
+#ifdef CONFIG_SPARSE_IRQ
+	struct irq_desc *desc;
+#endif
 
-	irq = vbi_find_irq(dev->full_name, VB_INPUT_INT);
+	irq = vbi_find_irq(irq_name, irq_dir);
 	if (irq == VBI_INVALID_IRQ)
 		return NO_IRQ;
 
+#ifdef CONFIG_SPARSE_IRQ
+	desc = irq_to_desc_alloc_node(irq, 0);
+	if (!desc) {
+		pr_debug("irq: -> allocating desc failed\n");
+		return NO_IRQ;
+	} 
+	desc->status = IRQ_DISABLED | IRQ_LEVEL;
+	desc->action = NULL;
+	desc->depth = 1;
+	set_irq_chip_and_handler(irq, &wrhv_irq_chip, handle_fasteoi_irq);
+#endif
 	return irq;
 }
 
+unsigned int wrhv_irq_of_parse_and_map(struct device_node *dev, int index)
+{
+	return wrhv_map_irq_of_desc(dev->full_name, VB_INPUT_INT);
+}
+
 unsigned int wrhv_get_pvr(void)
 {
        return 0x80200000;
@@ -1265,7 +1291,7 @@ int ppc_get_pci_intr_wrhv(struct pci_dev *dev)
 	if (pin) {
 		snprintf(vector_name, VECTOR_NAME_SIZE, "PCIe%d_%c", 
 			(dev->bus->number+1), line[pin-1]);
-		irq = vbi_find_irq(vector_name, 1);
+		irq = wrhv_map_irq_of_desc(vector_name, 1);
 		if (irq >= 0) {
 			dev->irq = irq;
 			printk("WRHV-PCI: BUS NO:%x CLASS:%x IRQ%d for %s\n", 
-- 
1.6.5.2

