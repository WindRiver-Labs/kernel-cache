From a3d8987f7f0e99ba516490131af33407c4ca593b Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Wed, 12 May 2010 16:39:49 +0800
Subject: [PATCH 10/14] WRHV/PPC: kick up secondary cpu for SMP

Create the infrastructure to kick a secondary cpu.

 1.kick an AP, Application Processor, using hypervisor constructs
 2.hook smp init on wrhv-p4080ds platform

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/kernel/head_wrhv.h      |    2 +
 arch/powerpc/kernel/vbi/wrhv.c       |   58 ++++++++++++++++++++++++++++++++++
 arch/powerpc/platforms/85xx/Makefile |    5 +++
 3 files changed, 65 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/kernel/head_wrhv.h b/arch/powerpc/kernel/head_wrhv.h
index 5c4aef8..ff215b5 100644
--- a/arch/powerpc/kernel/head_wrhv.h
+++ b/arch/powerpc/kernel/head_wrhv.h
@@ -22,6 +22,8 @@
 #define TLBSX_CODE	0x7c005724
 #endif
 
+#define WRHV_COREID_OFFSET	0x98
+
 	/* Interrupts are disabled by hypervisor at this entry point.
 	 * It puts the following registers into the status page:
 	 *   VB_STATUS_OLD_INT_DISABLE (the INT_DISABLE from Control)
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 8f6bb6f..43a8457 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -1278,6 +1278,60 @@ void wrhv_init(void)
 }
 
 #ifdef CONFIG_SMP
+VBI_HREG_SET_CMPLX_QUALIFIED bootREG;
+
+static void __init  smp_wrhv_kick_cpu(int nr)
+{
+	unsigned long flags;
+	int32_t ret;
+	
+
+	int n = 0;
+	WARN_ON (nr < 0 || nr >= NR_CPUS);
+
+	local_irq_save(flags);
+
+	bootREG.vbiRegType = VBI_REG_SET_32BIT;
+
+	ret=vbi_vb_read_reg(&bootREG, VBI_BOARD_ID_GET(), nr);
+	if(ret)
+		printk("WRHV read REG failed:%d\n",ret);
+
+	bootREG.vbiRegType = VBI_REG_SET_32BIT;
+	bootREG.vbiRegSet.hreg32.pc = 0xc0000000;
+
+	ret=vbi_vb_write_reg(&bootREG, VBI_BOARD_ID_GET(), nr);
+	if(ret)
+		printk("WRHV write REG failed:%d\n",ret);
+
+	ret=vbi_vb_resume(VBI_BOARD_ID_GET(), nr);
+	if(ret)
+		printk("WRHV resume CPU failed:%d\n",ret);
+
+	/* Wait a bit for the CPU to ack. */
+	while ((__secondary_hold_acknowledge != nr) && (++n < 1000))
+		mdelay(1);
+
+	local_irq_restore(flags);
+
+}
+
+unsigned long mpc85xx_smp_message[NR_CPUS]; /*fix doorbell_exception link error */
+
+struct smp_ops_t smp_wrhv_ops = {
+	.kick_cpu = smp_wrhv_kick_cpu,
+#if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PPC32)
+	.cpu_enable = generic_cpu_enable,
+	.cpu_disable = generic_cpu_disable,
+	.cpu_die = generic_cpu_die,
+#endif
+};
+
+void __init wrhv_smp_init(void)
+{
+	smp_ops = &smp_wrhv_ops;
+}
+
 extern struct smp_ops_t *smp_ops;
 extern volatile unsigned int cpu_callin_map[NR_CPUS];
 
@@ -1315,6 +1369,10 @@ int __devinit wrhv_start_secondary(void *unused)
 	struct device_node *l2_cache;
 	int i, base;
 
+	vbi_set_exc_base((char*)0xC0000000);
+	wrhv_umask_IPIs_for_vcore();
+	vbi_set_exc_offset(&exec_table);
+
 	atomic_inc(&init_mm.mm_count);
 	current->active_mm = &init_mm;
 
diff --git a/arch/powerpc/platforms/85xx/Makefile b/arch/powerpc/platforms/85xx/Makefile
index 387c128..6a45885 100644
--- a/arch/powerpc/platforms/85xx/Makefile
+++ b/arch/powerpc/platforms/85xx/Makefile
@@ -1,7 +1,12 @@
 #
 # Makefile for the PowerPC 85xx linux kernel.
 #
+
+# we want all the rest of the SMP code, except the 85xx 
+# specific implementation
+ifneq ($(CONFIG_WRHV),y)
 obj-$(CONFIG_SMP) += smp.o
+endif
 
 obj-$(CONFIG_MPC8540_ADS) += mpc85xx_ads.o
 obj-$(CONFIG_MPC8560_ADS) += mpc85xx_ads.o
-- 
1.6.5.2

