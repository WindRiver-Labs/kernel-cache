From db236fd5bc152c59ada7c2815d97577cb2a6987b Mon Sep 17 00:00:00 2001
From: Thomas Tai <thomas.tai@windriver.com>
Date: Thu, 21 Oct 2010 07:53:00 -0700
Subject: [PATCH] implementation for using hypervisor serial actual device driver

Hypervisor implements the actual serial device driver, instead of guest OS
driving the hardware registers. Guest OS can optionally use this feature by
passing all data to hypervisor via vbi calls, and the hypervisor in turn
drives the actual hardware.

Paravirtualize early console init functions so that the early boot
message will show up using duart.

For serial device, guest OS prepare a transmit and receive ring buffer.
During data output, guest OS put data in the ring buffer and increase the
tx write pointer and then use vbi call to let hypervisor pick the the
data and send it out. hypervisor then update the rx ring read pointer.
Hypervisor does not support tx interrupt to guest OS, guest OS is
responsible to transmit all data without the use of tx interrupt.

For input, hypervisor will generate a rx interrupt and guest OS
read the ring buffer and update the rx ring buffer read pointer.
Alternatively, guest OS can check the rx ring buffer to pick up
data in polling mode.

In the xml, user can choose polling or interrupt mode for hypervisor
serial port. This feature is enable/disable via kernel options.

In order to use duart, Bootline must include "duart=uart0" or
"duart=uart1".

Signed-off-by: Thomas Tai <thomas.tai@windriver.com>
---
 arch/powerpc/include/asm/paravirt.h |    8 ++
 arch/powerpc/kernel/paravirt.c      |   10 +++
 arch/powerpc/kernel/vbi/wrhv.c      |  131 +++++++++++++++++++++++++++++++++++
 drivers/serial/Kconfig              |    7 ++
 4 files changed, 156 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/include/asm/paravirt.h b/arch/powerpc/include/asm/paravirt.h
index 2b32578..db00bd7 100644
--- a/arch/powerpc/include/asm/paravirt.h
+++ b/arch/powerpc/include/asm/paravirt.h
@@ -35,6 +35,8 @@ extern int native_fsl_pq_mdio_write(struct mii_bus *bus, int mii_id,
 					int devad, int regnum, u16 value);
 extern int native_fsl_pq_mdio_read(struct mii_bus *bus, int mii_id,
 					int devad, int regnum);
+extern void native_udbg_init_uart(void __iomem *comport, unsigned int speed,
+		unsigned int clock);
 
 /*
  * paravirtual operations structure
@@ -99,12 +101,18 @@ struct pv_mdio_ops {
 					int devad, int regnum);
 };
 
+struct pv_serial_ops{
+	void (*udbg_init_uart)(void __iomem *comport, unsigned int speed,
+		unsigned int clock);
+};
+
 extern struct pv_info pv_info;
 extern struct pv_time_ops pv_time_ops;
 extern struct pv_cpu_ops pv_cpu_ops;
 extern struct pv_irq_ops pv_irq_ops;
 extern struct pv_mmu_ops pv_mmu_ops;
 extern struct pv_mdio_ops pv_mdio_ops;
+extern struct pv_serial_ops pv_serial_ops;
 
 #endif /* CONFIG_PARAVIRT */
 #endif	/* __ASM_PARAVIRT_H */
diff --git a/arch/powerpc/kernel/paravirt.c b/arch/powerpc/kernel/paravirt.c
index 047c858..e734e48 100644
--- a/arch/powerpc/kernel/paravirt.c
+++ b/arch/powerpc/kernel/paravirt.c
@@ -150,6 +150,10 @@ struct pv_mdio_ops pv_mdio_ops = {
 	.fsl_pq_mdio_read	= native_fsl_pq_mdio_read,
 };
 
+struct pv_serial_ops pv_serial_ops = {
+	.udbg_init_uart	= native_udbg_init_uart,
+};
+
 /* pv_time_ops */
 void __init paravirt_time_init_cont(void)
 {
@@ -202,6 +206,12 @@ int paravirt_fsl_pq_mdio_read(struct mii_bus *bus, int mii_id,
 	return pv_mdio_ops.fsl_pq_mdio_read(bus, mii_id, devad, regnum);
 }
 
+void paravirt_udbg_init_uart(void __iomem *comport, unsigned int speed,
+		unsigned int clock)
+{
+	return pv_serial_ops.udbg_init_uart(comport, speed, clock);
+}
+
 void __kprobes paravirt_DebugException(struct pt_regs *regs, unsigned long debug_status)
 {
 	pv_cpu_ops.DebugException(regs, debug_status);
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index e4e1359..eb387ae 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -124,6 +124,7 @@
 
 #include <vbi/vbi.h>
 #include <vbi/interface.h>
+#include <vbi/pdc.h>
 
 VBI_EXC_OFFSETS_TABLE  exec_table;
 struct vb_config *wr_config;		/* TODO kernel relocation friendly ? */
@@ -1401,6 +1402,14 @@ int wrhv_mdio_read(struct mii_bus *bus, int mii_id, int devad, int regnum)
 	return mdio_reply.dataVal;
 }
 
+void wrhv_duart_init(void);
+void wrhv_udbg_init_uart(void __iomem *comport, unsigned int speed,
+		unsigned int clock)
+{
+	/* initialize hypervisor duart serial device driver */
+	wrhv_duart_init();
+}
+
 void wrhv_init(void)
 {
 	/* initialize wr_config so that we can access
@@ -1445,6 +1454,10 @@ void wrhv_init(void)
 	pv_mmu_ops.__set_pte_at = wrhv__set_pte_at;
 	pv_mdio_ops.fsl_pq_mdio_write = wrhv_mdio_write;
 	pv_mdio_ops.fsl_pq_mdio_read = wrhv_mdio_read;
+
+#ifdef CONFIG_WRHV_DUART
+	pv_serial_ops.udbg_init_uart = wrhv_udbg_init_uart;
+#endif
 }
 
 __weak void wrhv_setup_msr_for_ap(VBI_HREG_SET_CMPLX_QUALIFIED *regs)
@@ -1850,3 +1863,121 @@ void pci_msi_disable(struct pci_dev *dev)
 }
 DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, pci_msi_disable);
 #endif
+
+/* interface to wrhv duart actual device driver */
+#define WRHV_DUART_RX_SIZE	(16)
+#define WRHV_DUART_TX_SIZE	(1024)
+static char rxBuf[WRHV_DUART_RX_SIZE];
+static char txBuf[WRHV_DUART_TX_SIZE];
+static char wrhv_duart_name[256];
+vbi_pdc_handle duartPdc;
+static int is_wrhv_duart_inited = 0;
+
+struct intrDeviceChannelBuffer idc = {
+	.rxBuf = (void *)rxBuf,
+	.rxBufLen = WRHV_DUART_RX_SIZE,
+	.rxBufWrPtr = (size_t)0,
+	.rxBufRdPtr = (size_t)0,
+	.txBuf = (void *)txBuf,
+	.txBufLen = WRHV_DUART_TX_SIZE,
+	.txBufWrPtr = (size_t)0,
+	.txBufRdPtr = (size_t)0
+};
+
+void wrhv_duart_putc(char c)
+{
+	if (((idc.txBufWrPtr + 1) % WRHV_DUART_TX_SIZE) == idc.txBufRdPtr) {
+		/* tx ring buffer full */
+		return ;
+	}
+
+	if (c == '\n') {
+		wrhv_duart_putc('\r');
+	}
+
+	txBuf[idc.txBufWrPtr] = c;
+	idc.txBufWrPtr = (idc.txBufWrPtr + 1) % WRHV_DUART_TX_SIZE;
+
+	vbi_pdc_op(duartPdc, PDC_REQUEST_WRITE,
+		0, (void *)idc.txBuf, (size_t)idc.txBufLen, 0);
+
+}
+
+void wrhv_duart_puts(char *str)
+{
+	while (*str != 0) {
+		wrhv_duart_putc(*str);
+		str++;
+	}
+}
+
+int wrhv_duart_tstc(void)
+{
+	if (idc.rxBufWrPtr == idc.rxBufRdPtr) {
+		/* rx ring buffer empty */
+		return 0;
+	}
+	return 1;
+}
+
+int wrhv_duart_getc(void)
+{
+	int value;
+
+	if (!wrhv_duart_tstc()) {
+		return 0;
+	}
+	value = rxBuf[idc.rxBufRdPtr++];
+	idc.rxBufRdPtr = idc.rxBufRdPtr % WRHV_DUART_RX_SIZE;
+	return value;
+}
+
+void wrhv_duart_init(void)
+{
+	const char *opt;
+	char *pstring;
+	unsigned char bootline[VB_MAX_BOOTLINE_LENGTH];
+
+	/* this functions can be called very early, even before
+	 * the platform code. The command line options needed
+	 * to be directly from VBI_BOOTLINE
+	 */
+	strncpy(bootline, wr_config->bootLine, VB_MAX_BOOTLINE_LENGTH - 1);
+	bootline[VB_MAX_BOOTLINE_LENGTH - 1] = 0;
+
+	/* get the duart name, the duart name is
+	 * specified in the hypervisor xml
+	 */
+	memset(wrhv_duart_name, 0, sizeof(wrhv_duart_name));
+	pstring = wrhv_duart_name;
+	opt = strstr(bootline, "duart=");
+	if (opt) {
+		opt += 6;
+		while (*opt && (*opt != ' ')) {
+			*pstring = *opt;
+			pstring++;
+			opt++;
+		}
+	}
+
+	/* only init the duart once */
+	if (is_wrhv_duart_inited) {
+		return;
+	}
+	is_wrhv_duart_inited = 1;
+
+
+	/* init channel */
+	if (vbiPdcInit(wrhv_duart_name, &duartPdc)) {
+		printk("vbiPdcInit failed\n");
+		return;
+	}
+
+	/* init device */
+	if (vbi_pdc_op(duartPdc, PDC_REQUEST_INIT,
+		0, (void *) &idc, 0, 0)) {
+		printk("vbi_pdc_op: PDC_REQUEST_INIT failed\n");
+		return;
+	}
+}
+
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index 902d82c..d14e739 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -70,6 +70,13 @@ config SERIAL_8250_CONSOLE
 
 	  If unsure, say N.
 
+config WRHV_DUART
+	bool "WRHV duart serial support"
+	depends on SERIAL_8250=y && WRHV && PPC32
+	---help---
+	  This selects whether you want to include the driver for the wrhv
+	  duart driver.
+
 config SERIAL_8250_PPC_BUG
 	bool "Fix 8250/16550 to handle IRQ storm after receipt of a break"
 	depends on SERIAL_8250 && PPC32
-- 
1.7.0

