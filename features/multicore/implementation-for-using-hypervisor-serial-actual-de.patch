From 3823e2c62ca027a626d3edcd1b18681999321693 Mon Sep 17 00:00:00 2001
From: Thomas Tai <thomas.tai@windriver.com>
Date: Thu, 21 Oct 2010 07:53:00 -0700
Subject: [PATCH] implementation for using hypervisor serial actual device driver

hypervisor implemented serial actual device driver, instead of guest os
driving the hardware registers. Guest os can optionally use this feature by
passing all data to hypervisor via vbi calls, hypervisor in term
drive the actual hardware.

Paravirtualize early console init functions so that the early boot
message will show up using duart.

For serial device, guest os prepare a transmit and receive ring buffer.
During data output, guest os put data in the ring buffer and increase the
tx write pointer and then use vbi call to let hypervisor pick the the
data and send it out. hypervisor then update the rx ring read pointer.
Hypervisor does not support tx interrupt to guest os, guest os is
responsible to transmit all data without the use of tx interrupt.

For input, hypervisor will generate a rx interrupt and guest os
read the ring buffer and update the rx ring buffer read pointer.
Alternatively, guest os can check the rx ring buffer to pick up
data in polling mode.

In the xml, user can choose polling or interrupt mode for hypervisor
serial port. This feature is enable/disable via kernel options.

In order to use duart, Bootline must include "duart=uart0" or
"duart=uart1".

Signed-off-by: Thomas Tai <thomas.tai@windriver.com>
---
 arch/powerpc/include/asm/paravirt.h |    8 ++
 arch/powerpc/kernel/paravirt.c      |   10 +++
 arch/powerpc/kernel/vbi/wrhv.c      |  131 +++++++++++++++++++++++++++++++++++
 drivers/serial/Kconfig              |    7 ++
 include/vbi/pdc.h                   |   29 +++-----
 5 files changed, 168 insertions(+), 17 deletions(-)

diff --git a/arch/powerpc/include/asm/paravirt.h b/arch/powerpc/include/asm/paravirt.h
index 046db30..fc8bfbd 100644
--- a/arch/powerpc/include/asm/paravirt.h
+++ b/arch/powerpc/include/asm/paravirt.h
@@ -35,6 +35,8 @@ extern int native_fsl_pq_mdio_write(struct mii_bus *bus, int mii_id,
 					int devad, int regnum, u16 value);
 extern int native_fsl_pq_mdio_read(struct mii_bus *bus, int mii_id,
 					int devad, int regnum);
+extern void native_udbg_init_uart(void __iomem *comport, unsigned int speed,
+		unsigned int clock);
 #include <linux/clocksource.h>
 extern void native_update_vsyscall(struct timespec *wall_time, struct clocksource *clock, u32 mult);
 
@@ -105,6 +107,11 @@ struct pv_vdso_ops {
 	void (*update_vsyscall)(struct timespec *ts, struct clocksource *c, u32 mult);
 };
 
+struct pv_serial_ops{
+	void (*udbg_init_uart)(void __iomem *comport, unsigned int speed,
+		unsigned int clock);
+};
+
 extern struct pv_info pv_info;
 extern struct pv_time_ops pv_time_ops;
 extern struct pv_cpu_ops pv_cpu_ops;
@@ -112,6 +119,7 @@ extern struct pv_irq_ops pv_irq_ops;
 extern struct pv_mmu_ops pv_mmu_ops;
 extern struct pv_mdio_ops pv_mdio_ops;
 extern struct pv_vdso_ops pv_vdso_ops;
+extern struct pv_serial_ops pv_serial_ops;
 
 #endif /* CONFIG_PARAVIRT */
 #endif	/* __ASM_PARAVIRT_H */
diff --git a/arch/powerpc/kernel/paravirt.c b/arch/powerpc/kernel/paravirt.c
index 862c6be..9d32389 100644
--- a/arch/powerpc/kernel/paravirt.c
+++ b/arch/powerpc/kernel/paravirt.c
@@ -154,6 +154,10 @@ struct pv_vdso_ops pv_vdso_ops = {
 	.update_vsyscall	= native_update_vsyscall,
 };
 
+struct pv_serial_ops pv_serial_ops = {
+	.udbg_init_uart	= native_udbg_init_uart,
+};
+
 /* pv_time_ops */
 void __init paravirt_time_init_cont(void)
 {
@@ -211,6 +215,12 @@ int paravirt_fsl_pq_mdio_read(struct mii_bus *bus, int mii_id,
 	return pv_mdio_ops.fsl_pq_mdio_read(bus, mii_id, devad, regnum);
 }
 
+void paravirt_udbg_init_uart(void __iomem *comport, unsigned int speed,
+		unsigned int clock)
+{
+	return pv_serial_ops.udbg_init_uart(comport, speed, clock);
+}
+
 void __kprobes paravirt_DebugException(struct pt_regs *regs, unsigned long debug_status)
 {
 	pv_cpu_ops.DebugException(regs, debug_status);
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 0ade39e..7a51b67 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -126,6 +126,7 @@
 
 #include <vbi/vbi.h>
 #include <vbi/interface.h>
+#include <vbi/pdc.h>
 
 VBI_EXC_OFFSETS_TABLE  exec_table;
 struct vb_config *wr_config;		/* TODO kernel relocation friendly ? */
@@ -1450,6 +1451,14 @@ int wrhv_mdio_read(struct mii_bus *bus, int mii_id, int devad, int regnum)
 	return mdio_reply.dataVal;
 }
 
+void wrhv_duart_init(void);
+void wrhv_udbg_init_uart(void __iomem *comport, unsigned int speed,
+		unsigned int clock)
+{
+	/* initialize hypervisor duart serial device driver */
+	wrhv_duart_init();
+}
+
 void wrhv_init(void)
 {
 	/* initialize wr_config so that we can access
@@ -1495,6 +1504,10 @@ void wrhv_init(void)
 	pv_mmu_ops.__set_pte_at = wrhv__set_pte_at;
 	pv_mdio_ops.fsl_pq_mdio_write = wrhv_mdio_write;
 	pv_mdio_ops.fsl_pq_mdio_read = wrhv_mdio_read;
+
+#ifdef CONFIG_WRHV_DUART
+	pv_serial_ops.udbg_init_uart = wrhv_udbg_init_uart;
+#endif
 }
 
 __weak void wrhv_setup_msr_for_ap(VBI_HREG_SET_CMPLX_QUALIFIED *regs)
@@ -1900,3 +1913,121 @@ void pci_msi_disable(struct pci_dev *dev)
 }
 DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, pci_msi_disable);
 #endif
+
+/* interface to wrhv duart actual device driver */
+#define WRHV_DUART_RX_SIZE	(16)
+#define WRHV_DUART_TX_SIZE	(1024)
+static char rxBuf[WRHV_DUART_RX_SIZE];
+static char txBuf[WRHV_DUART_TX_SIZE];
+static char wrhv_duart_name[256];
+vbi_pdc_handle duartPdc;
+static int is_wrhv_duart_inited = 0;
+
+intrDeviceChannelBuffer idc = {
+	.rxBuf = (void *)rxBuf,
+	.rxBufLen = WRHV_DUART_RX_SIZE,
+	.rxBufWrPtr = (size_t)0,
+	.rxBufRdPtr = (size_t)0,
+	.txBuf = (void *)txBuf,
+	.txBufLen = WRHV_DUART_TX_SIZE,
+	.txBufWrPtr = (size_t)0,
+	.txBufRdPtr = (size_t)0
+};
+
+void wrhv_duart_putc(char c)
+{
+	if (((idc.txBufWrPtr + 1) % WRHV_DUART_TX_SIZE) == idc.txBufRdPtr) {
+		/* tx ring buffer full */
+		return ;
+	}
+
+	if (c == '\n') {
+		wrhv_duart_putc('\r');
+	}
+
+	txBuf[idc.txBufWrPtr] = c;
+	idc.txBufWrPtr = (idc.txBufWrPtr + 1) % WRHV_DUART_TX_SIZE;
+
+	vbi_pdc_op(duartPdc, PDC_REQUEST_WRITE,
+		0, (void *)idc.txBuf, (size_t)idc.txBufLen, 0);
+
+}
+
+void wrhv_duart_puts(char *str)
+{
+	while (*str != 0) {
+		wrhv_duart_putc(*str);
+		str++;
+	}
+}
+
+int wrhv_duart_tstc(void)
+{
+	if (idc.rxBufWrPtr == idc.rxBufRdPtr) {
+		/* rx ring buffer empty */
+		return 0;
+	}
+	return 1;
+}
+
+int wrhv_duart_getc(void)
+{
+	int value;
+
+	if (!wrhv_duart_tstc()) {
+		return 0;
+	}
+	value = rxBuf[idc.rxBufRdPtr++];
+	idc.rxBufRdPtr = idc.rxBufRdPtr % WRHV_DUART_RX_SIZE;
+	return value;
+}
+
+void wrhv_duart_init(void)
+{
+	const char *opt;
+	char *pstring;
+	unsigned char bootline[VB_MAX_BOOTLINE_LENGTH];
+
+	/* this functions can be called very early, even before
+	 * the platform code. The command line options needed
+	 * to be directly from VBI_BOOTLINE
+	 */
+	strncpy(bootline, wr_config->bootLine, VB_MAX_BOOTLINE_LENGTH - 1);
+	bootline[VB_MAX_BOOTLINE_LENGTH - 1] = 0;
+
+	/* get the duart name, the duart name is
+	 * specified in the hypervisor xml
+	 */
+	memset(wrhv_duart_name, 0, sizeof(wrhv_duart_name));
+	pstring = wrhv_duart_name;
+	opt = strstr(bootline, "duart=");
+	if (opt) {
+		opt += 6;
+		while (*opt && (*opt != ' ')) {
+			*pstring = *opt;
+			pstring++;
+			opt++;
+		}
+	}
+
+	/* only init the duart once */
+	if (is_wrhv_duart_inited) {
+		return;
+	}
+	is_wrhv_duart_inited = 1;
+
+
+	/* init channel */
+	if (vbiPdcInit(wrhv_duart_name, &duartPdc)) {
+		printk("vbiPdcInit failed\n");
+		return;
+	}
+
+	/* init device */
+	if (vbi_pdc_op(duartPdc, PDC_REQUEST_INIT,
+		0, (void *) &idc, 0, 0)) {
+		printk("vbi_pdc_op: PDC_REQUEST_INIT failed\n");
+		return;
+	}
+}
+
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index 902d82c..d14e739 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -70,6 +70,13 @@ config SERIAL_8250_CONSOLE
 
 	  If unsure, say N.
 
+config WRHV_DUART
+	bool "WRHV duart serial support"
+	depends on SERIAL_8250=y && WRHV && PPC32
+	---help---
+	  This selects whether you want to include the driver for the wrhv
+	  duart driver.  
+
 config SERIAL_8250_PPC_BUG
 	bool "Fix 8250/16550 to handle IRQ storm after receipt of a break"
 	depends on SERIAL_8250 && PPC32
diff --git a/include/vbi/pdc.h b/include/vbi/pdc.h
index 7ff3441..bd051c8 100644
--- a/include/vbi/pdc.h
+++ b/include/vbi/pdc.h
@@ -64,23 +64,18 @@ struct ioctlOp
 }
 #endif /* DEV_ASYNC_IOCTL */
 
-struct intrDeviceChannelBuffer
+typedef struct intrDeviceChannelBuffer_
 {
-	VB_ALIGN_FIELD_64 (void *rxBuf, pad1);
-	VB_ALIGN_FIELD_64 (size_t rxBufLen, pad2);
-	VB_ALIGN_FIELD_64 (void *txBuf, pad3);
-	VB_ALIGN_FIELD_64 (size_t txBufLen, pad4);
-	uint64_t rxBufRdPtr;
-	uint64_t rxBufWrPtr;
-	uint64_t txBufRdPtr;
-	uint64_t txBufWrPtr;
-#ifdef DEV_ASYNC_IOCTL
-	VB_ALIGN_FIELD_64 (struct ioctlOp *ioctlBuf, pad5);
-	VB_ALIGN_FIELD_64 (size_t ioctlBufLen, pad6);
-	uint64_t ioctlBufRdPtr;
-	uint64_t ioctlBufWrPtr;
-#endif
-};
+	VB_ALIGN_FIELD_64(void *rxBuf, pad1);		/* rx buffer */
+	VB_ALIGN_FIELD_64(size_t rxBufLen, pad2);	/* rx buffer length */
+	VB_ALIGN_FIELD_64(void *txBuf, pad3);		/* tx buffer */
+	VB_ALIGN_FIELD_64(size_t txBufLen, pad4);	/* tx buffer length */
+	uint32_t rxBufRdPtr;	/* rx buffer read pointer */
+	uint32_t rxBufWrPtr;	/* rx buffer write pointer */
+	uint32_t txBufRdPtr;	/* tx buffer read pointer */
+	uint32_t txBufWrPtr;	/* tx buffer write pointer */
+	uint32_t intStatus; 	/* intStatus, or what intr */
+} intrDeviceChannelBuffer;
 
 #define SYS_PDC_REQUEST_OK		0
 #define SYS_PDC_REQUEST_FAILED		-1
@@ -103,7 +98,7 @@ typedef enum {
 	PDC_REQUEST_MAX		= 4
 } vbi_pdc_request;
 
-extern uint32_t vbiPdcOp(vbi_pdc_handle pdcHandle, vbi_pdc_request requestType,
+extern int32_t vbi_pdc_op(vbi_pdc_handle pdcHandle, vbi_pdc_request requestType,
 			 uint32_t ioctlOp, void *bufferPtr, size_t bufferLen,
 			 uint64_t token);
 
-- 
1.6.5.2

