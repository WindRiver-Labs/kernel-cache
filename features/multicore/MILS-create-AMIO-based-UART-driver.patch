From 72ea3b0486ed51c881beb89ff7fd9b0690ae6b7e Mon Sep 17 00:00:00 2001
From: Keith Backensto <keith.backensto@windriver.com>
Date: Thu, 29 Apr 2010 11:26:30 -0400
Subject: [PATCH] MILS: create AMIO based UART driver

This driver creates a virtual UART that allows the guest OS
to write data (e.g. printk console messages) into a shared
memory area where it can be processed and displayed later.
This frees up the real UART for use by other virtual boards.

Signed-off-by: Keith Backensto <keith.backensto@windriver.com
---
 arch/powerpc/include/asm/serial.h   |    4 +
 arch/powerpc/kernel/setup_32.c      |    4 +
 arch/powerpc/platforms/85xx/Kconfig |    2 +-
 arch/powerpc/platforms/86xx/Kconfig |    2 +-
 arch/powerpc/platforms/chrp/Kconfig |    2 +-
 drivers/serial/Kconfig              |   29 ++
 drivers/serial/Makefile             |    1 +
 drivers/serial/amio_uart.c          |  546 +++++++++++++++++++++++++++++++++++
 include/linux/serial_core.h         |    3 +
 9 files changed, 590 insertions(+), 3 deletions(-)
 create mode 100644 drivers/serial/amio_uart.c

diff --git a/arch/powerpc/include/asm/serial.h b/arch/powerpc/include/asm/serial.h
index 3e8589b..9a1fed1 100644
--- a/arch/powerpc/include/asm/serial.h
+++ b/arch/powerpc/include/asm/serial.h
@@ -21,4 +21,8 @@ extern void find_legacy_serial_ports(void);
 #define find_legacy_serial_ports()	do { } while (0)
 #endif
 
+#ifdef CONFIG_SERIAL_AMIO_UDBG
+extern int amio_udbg_init(void);
+#endif
+
 #endif /* _PPC64_SERIAL_H */
diff --git a/arch/powerpc/kernel/setup_32.c b/arch/powerpc/kernel/setup_32.c
index 47883cd..413dbb8 100644
--- a/arch/powerpc/kernel/setup_32.c
+++ b/arch/powerpc/kernel/setup_32.c
@@ -312,6 +312,10 @@ void __init setup_arch(char **cmdline_p)
 
 	find_legacy_serial_ports();
 
+#ifdef CONFIG_SERIAL_AMIO_UDBG
+	amio_udbg_init();
+#endif
+
 	smp_setup_cpu_maps();
 
 	/* Register early console */
diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index 05df89b..c6516f6 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -1,7 +1,7 @@
 menuconfig MPC85xx
 	bool "Machine Type"
 	depends on PPC_85xx
-	select PPC_UDBG_16550
+	select PPC_UDBG_16550 if !SERIAL_AMIO_UDBG
 	select MPIC
 	select PPC_PCI_CHOICE
 	select FSL_PCI if PCI
diff --git a/arch/powerpc/platforms/86xx/Kconfig b/arch/powerpc/platforms/86xx/Kconfig
index 0b175a9..2dd7420 100644
--- a/arch/powerpc/platforms/86xx/Kconfig
+++ b/arch/powerpc/platforms/86xx/Kconfig
@@ -42,7 +42,7 @@ config MPC8641
 	bool
 	select PPC_PCI_CHOICE
 	select FSL_PCI if PCI
-	select PPC_UDBG_16550
+	select PPC_UDBG_16550 if !SERIAL_AMIO_UDBG
 	select MPIC
 	default y if MPC8641_HPCN || SBC8641D  || WRHV_8641D
 
diff --git a/arch/powerpc/platforms/chrp/Kconfig b/arch/powerpc/platforms/chrp/Kconfig
index 22b4b4e..62363a3 100644
--- a/arch/powerpc/platforms/chrp/Kconfig
+++ b/arch/powerpc/platforms/chrp/Kconfig
@@ -6,7 +6,7 @@ config PPC_CHRP
 	select PPC_INDIRECT_PCI
 	select PPC_RTAS
 	select PPC_MPC106
-	select PPC_UDBG_16550
+	select PPC_UDBG_16550 if !SERIAL_AMIO_UDBG
 	select PPC_NATIVE
 	select PCI
 	default y
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index febfc79..29e27e0 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -1435,4 +1435,33 @@ config SPORT_BAUD_RATE
 	default 19200 if (SERIAL_SPORT_BAUD_RATE_19200)
 	default 9600 if (SERIAL_SPORT_BAUD_RATE_9600)
 
+config SERIAL_AMIO
+	tristate "AMIO serial port support"
+	depends on WRHV_MILS
+	select SERIAL_CORE
+	help
+	  Say Y here if you want to enable serial AMIO.  Doing so
+	  will get you a virtual UART that can be used to pass
+	  data (i.e. console printk messages) from the Linux
+	  guest back up to the hypervisor without tying up a
+	  real physical UART.
+
+config SERIAL_AMIO_CONSOLE
+	bool "Console on AMIO serial port"
+	depends on SERIAL_AMIO=y
+	select SERIAL_CORE_CONSOLE
+	select SERIAL_AMIO_UDBG
+	default y
+	help
+	  Say Y here if you want to support a serial AMIO console.
+
+	  You will also need to set "console=ttyAMIO0" as a kernel command
+	  line option. (Try "man bootparam" or see the documentation of
+	  your boot loader (grub or lilo or loadlin) about how to pass options
+	  to the kernel at boot time.)
+
+config SERIAL_AMIO_UDBG
+	bool
+	default n
+
 endmenu
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index 4534b00..f6edacb 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -70,3 +70,4 @@ obj-$(CONFIG_SERIAL_KS8695) += serial_ks8695.o
 obj-$(CONFIG_KGDB_SERIAL_CONSOLE) += kgdboc.o
 obj-$(CONFIG_KGDB_8250) += 8250_kgdb.o
 obj-$(CONFIG_SERIAL_QE) += ucc_uart.o
+obj-$(CONFIG_SERIAL_AMIO) += amio_uart.o
diff --git a/drivers/serial/amio_uart.c b/drivers/serial/amio_uart.c
new file mode 100644
index 0000000..3d73458
--- /dev/null
+++ b/drivers/serial/amio_uart.c
@@ -0,0 +1,546 @@
+/*
+ * amio_uart.c
+ *
+ * AMIO serial driver
+ *
+ * Copyright (c) 2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/platform_device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <asm/udbg.h>
+#include <asm/io.h>
+
+#include <vbi/types.h>
+#include <vbi/compat.h>
+#include <vbi/shmem.h>
+#include <vbi/interrupt.h>
+#include <vbi/vdk_interface.h>
+#include <vbi/errors.h>
+
+/* Macro Definitions */
+
+#define AMIO_DRIVER_NAME	"amio"
+#define AMIO_DEV_NAME		"ttyAMIO"
+#define AMIO_SERIAL_MAJOR	251
+
+#define UART_NR	1
+
+/* Two rings must fit into one page, assuming 4096 page size */
+#define AMIO_RING_SIZE 1536
+
+#define AMIO_INC_INDEX(x) \
+	((((x)+1) == AMIO_RING_SIZE) ? 0 : ((x)+1))
+
+#define AMIO_RING_FULL(x) \
+	(AMIO_INC_INDEX((x)->tail) == (x)->head)
+
+#define AMIO_RING_EMPTY(x) \
+	((x)->head == (x)->tail)
+
+/* Type Declarations */
+
+struct amio_ring {
+	unsigned int connected;	/* If 1 send/receive can start */
+	unsigned int head;	/* Reader advances the head point */
+	unsigned int tail;	/* Writer advances the tail index */
+	char ring[AMIO_RING_SIZE];
+};
+
+struct amio_port {
+	struct uart_port port;
+	volatile struct amio_ring *ring_tx;
+	volatile struct amio_ring *ring_rx;
+};
+
+/* Local Variables */
+
+static struct amio_port amio_ports[UART_NR];
+static int amio_sched_start_irq = VBI_INVALID_IRQ;
+
+/* Function Definitions */
+
+static int amio_poll_output(struct amio_port *aport, char out_char)
+{
+	volatile struct amio_ring *ring_tx;
+	int new_tail;
+
+	ring_tx = aport->ring_tx;
+	if (ring_tx == NULL)
+		return -EIO;
+
+	if (!ring_tx->connected)
+		return -EIO;
+
+	/* is the transmitter ready to accept a character? */
+	new_tail = AMIO_INC_INDEX(ring_tx->tail);
+	if (new_tail == ring_tx->head)
+		return -EAGAIN;
+
+	/* transmit character */
+	ring_tx->ring[ring_tx->tail] = out_char;
+	ring_tx->tail = new_tail;
+
+	return 0;
+}
+
+static int amio_poll_input(struct amio_port *aport, char *pchar)
+{
+	volatile struct amio_ring *ring_rx;
+	int new_head;
+
+	ring_rx = aport->ring_rx;
+	if (ring_rx == NULL)
+		return -EIO;
+
+	if (!ring_rx->connected)
+		return -EIO;
+
+	if (ring_rx->head == ring_rx->tail)
+		return -EAGAIN;
+
+	/* got a character */
+	*pchar = ring_rx->ring[ring_rx->head];
+	new_head = AMIO_INC_INDEX(ring_rx->head);
+	ring_rx->head = new_head;
+
+	return 0;
+}
+
+static void amio_start_tx(struct uart_port *port)
+{
+	struct amio_port *aport = (struct amio_port*)port;
+	struct circ_buf *xmit = &port->info->xmit;
+
+	while (amio_poll_output(aport, xmit->buf[xmit->tail]) == 0) {
+
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+
+		if (uart_circ_empty(xmit))
+			break;
+	}
+}
+
+/*
+ * Check shm region for data from AMIO server VB.
+ */
+#ifdef CONFIG_X86
+static void amio_int(void *dev_id, struct vbInterruptLevel *int_level)
+#else
+static irqreturn_t amio_int(int irq, void *dev_id)
+#endif
+{
+	struct amio_port *aport = dev_id;
+	struct tty_struct *tty = aport->port.info->port.tty;
+	struct circ_buf *xmit = &aport->port.info->xmit;
+	unsigned long flags;
+	char c = 0;
+
+	spin_lock_irqsave(&aport->port.lock, flags);
+
+	while (amio_poll_input(aport, &c) == 0) {
+		aport->port.icount.rx++;
+		tty_insert_flip_char(tty, c, TTY_NORMAL);
+		tty_flip_buffer_push(tty);
+	}
+
+	if (!uart_circ_empty(xmit)) {
+		amio_start_tx(&aport->port);
+		if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+			uart_write_wakeup(&aport->port);
+	}
+
+	spin_unlock_irqrestore(&aport->port.lock, flags);
+#ifndef CONFIG_X86
+	return IRQ_HANDLED;
+#endif
+}
+
+static int amio_startup(struct uart_port *port)
+{
+	struct amio_port *aport = (struct amio_port *)port;
+
+#ifdef CONFIG_X86
+	vdkIntControllerConnect(amio_sched_start_irq,
+				(void (*)(void *, void*))amio_int, NULL);
+#else
+	if (request_irq(amio_sched_start_irq, amio_int, IRQF_SHARED,
+			AMIO_DRIVER_NAME, aport) < 0)
+		return -ENODEV;
+#endif
+
+	return 0;
+}
+
+static void amio_shutdown(struct uart_port *port)
+{
+	struct amio_port *aport = (struct amio_port *)port;
+
+#ifdef CONFIG_X86
+	vdkIntControllerDisconnect(amio_sched_start_irq);
+#else
+	free_irq(amio_sched_start_irq, aport);
+#endif
+}
+
+static unsigned int amio_tx_empty(struct uart_port *port)
+{
+	struct amio_port *aport = (struct amio_port*)port;
+
+	return AMIO_RING_EMPTY(aport->ring_tx) ? TIOCSER_TEMT : 0;
+}
+
+static const char *amio_type(struct uart_port *port)
+{
+	return AMIO_DRIVER_NAME;
+}
+
+static unsigned int amio_get_mctrl(struct uart_port *port)
+{
+	return 0;
+}
+
+static int amio_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+static void amio_config_port(struct uart_port *port, int flags)
+{
+	port->type = PORT_AMIO;
+}
+
+static int amio_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	return -EINVAL;
+}
+
+static void amio_set_na(struct uart_port *port)
+{
+}
+
+static void amio_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+}
+
+static void amio_break_ctl(struct uart_port *port, int break_state)
+{
+}
+
+static void amio_set_termios(struct uart_port *port, struct ktermios *termios,
+				struct ktermios *old)
+{
+}
+
+static struct uart_ops amio_ops = {
+	.tx_empty	= amio_tx_empty,
+	.set_mctrl	= amio_set_mctrl,
+	.get_mctrl	= amio_get_mctrl,
+	.stop_tx	= amio_set_na,
+	.start_tx	= amio_start_tx,
+	.stop_rx	= amio_set_na,
+	.enable_ms	= amio_set_na,
+	.break_ctl	= amio_break_ctl,
+	.startup	= amio_startup,
+	.shutdown	= amio_shutdown,
+	.set_termios	= amio_set_termios,
+	.type		= amio_type,
+	.release_port	= amio_set_na,
+	.request_port	= amio_request_port,
+	.config_port	= amio_config_port,
+	.verify_port	= amio_verify_port,
+};
+
+static int __init amio_init_port(int line, int channel_id)
+{
+	struct amio_port *aport = &amio_ports[line];
+	char shm_name[VB_NAMELEN];
+	unsigned int attr;
+	unsigned int shmsize;
+
+	if (aport->port.membase)
+	    return 0;
+
+	memset(&aport->port, 0, sizeof(struct uart_port));
+
+	sprintf(shm_name, "amioSerialChannel%d", channel_id);
+
+	if (vbiShmemRegionFind(shm_name, (void**)&aport->port.mapbase,
+				&shmsize, &attr) != 0) {
+		printk(KERN_ERR "AMIO: Cannot find shared memory region "
+			"'%s'\n", shm_name);
+		return -ENODEV;
+	}
+
+	aport->port.membase = ioremap_nocache(aport->port.mapbase, shmsize);
+	if (!aport->port.membase)
+		return -ENOMEM;
+
+	aport->ring_rx = (struct amio_ring*)aport->port.membase;
+	aport->ring_tx = aport->ring_rx + 1;
+
+	aport->port.iotype = UPIO_MEM;
+	aport->port.ops = &amio_ops;
+	aport->port.flags = UPF_BOOT_AUTOCONF;
+	aport->port.line = line;
+	aport->port.fifosize = shmsize;
+	aport->port.timeout = HZ / 50;
+
+	return 0;
+}
+
+#ifdef CONFIG_SERIAL_AMIO_CONSOLE
+static void amio_console_putchar(struct uart_port *port, int ch)
+{
+	struct amio_port *aport = (struct amio_port*)port;
+
+	while (amio_poll_output(aport, ch) == -EAGAIN)
+		barrier();
+}
+
+static void amio_console_write(struct console *co, const char *s,
+				unsigned int count)
+{
+	struct amio_port *aport = &amio_ports[co->index];
+
+	uart_console_write(&aport->port, s, count, amio_console_putchar);
+}
+
+static int __init amio_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/* Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if ((unsigned int)co->index >= UART_NR)
+		co->index = 0;
+	port = &amio_ports[co->index].port;
+
+	if (!port->membase)
+		return -ENODEV;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver amio_reg;
+static struct console amio_console = {
+	.name	= AMIO_DEV_NAME,
+	.write	= amio_console_write,
+	.device	= uart_console_device,
+	.setup	= amio_console_setup,
+	.flags	= CON_PRINTBUFFER,
+	.index	= -1,
+	.data	= &amio_reg,
+};
+
+static int __init amio_console_init(void)
+{
+	static int first = 1;
+	int i;
+
+	if (!first)
+		return 0;
+	first = 0;
+
+	for (i=0; i < UART_NR; i++)
+		amio_init_port(i, wr_config->boardID);
+
+	register_console(&amio_console);
+
+	return 0;
+}
+console_initcall(amio_console_init);
+
+#define AMIO_CONSOLE	&amio_console
+#else
+#define AMIO_CONSOLE	NULL
+#endif /* CONFIG_SERIAL_AMIO_CONSOLE */
+
+#ifdef CONFIG_SERIAL_AMIO_UDBG
+static void amio_udbg_putc(char c)
+{
+	while (amio_poll_output(&amio_ports[0], c) == -EAGAIN)
+		barrier();
+
+	if (c == '\n')
+		amio_udbg_putc('\r');
+}
+
+int __init amio_udbg_init(void)
+{
+	int ret;
+
+	if ((ret = amio_init_port(0, wr_config->boardID)) != 0)
+		return ret;
+
+	udbg_putc = amio_udbg_putc;
+	udbg_getc = NULL;
+	udbg_getc_poll = NULL;
+
+	return 0;
+}
+#endif /* CONFIG_SERIAL_AMIO_UDBG */
+
+static struct uart_driver amio_reg = {
+	.owner		= THIS_MODULE,
+	.driver_name	= AMIO_DRIVER_NAME,
+	.dev_name	= AMIO_DEV_NAME,
+	.major		= AMIO_SERIAL_MAJOR,
+	.minor		= 0,
+	.nr		= UART_NR,
+	.cons		= AMIO_CONSOLE,
+};
+
+static int __init serial_amio_probe(struct platform_device *pdev)
+{
+	struct amio_port *aport = &amio_ports[pdev->id];
+	int ret;
+
+	if (!aport->port.membase &&
+	    (ret = amio_init_port(pdev->id, wr_config->boardID)) != 0)
+		return ret;
+
+	aport->port.dev = &pdev->dev;
+	uart_add_one_port(&amio_reg, &aport->port);
+	platform_set_drvdata(pdev, &aport->port);
+
+	return 0;
+}
+
+static int serial_amio_remove(struct platform_device *pdev)
+{
+	struct amio_port *aport = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+
+	if (aport != NULL)
+		uart_remove_one_port(&amio_reg, &aport->port);
+
+	iounmap(aport->port.membase);
+
+	return 0;
+}
+
+static int serial_amio_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct amio_port *aport = platform_get_drvdata(dev);
+
+	if (aport != NULL)
+		uart_suspend_port(&amio_reg, &aport->port);
+
+	return 0;
+}
+
+static int serial_amio_resume(struct platform_device *dev)
+{
+	struct amio_port *aport = platform_get_drvdata(dev);
+
+	if (aport != NULL)
+		uart_resume_port(&amio_reg, &aport->port);
+
+	return 0;
+}
+
+static struct platform_driver serial_amio_driver = {
+	.probe		= serial_amio_probe,
+	.remove		= serial_amio_remove,
+	.suspend	= serial_amio_suspend,
+	.resume		= serial_amio_resume,
+	.driver		= {
+		.name	= AMIO_DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static struct platform_device *amio_platform_device[UART_NR];
+
+static int __init amio_init(void)
+{
+	int ret;
+	int i;
+
+	amio_sched_start_irq = vbi_find_irq(VDK_SCHED_START_INT_NAME, VB_INPUT_INT);
+	if (amio_sched_start_irq == VBI_INVALID_IRQ) {
+		printk(KERN_ERR "AMIO: %s interrupt not found.\n",
+			VDK_SCHED_START_INT_NAME);
+		return -EINVAL;
+	}
+
+	if ((ret = uart_register_driver(&amio_reg)) != 0)
+		return ret;
+
+
+	for (i=0; i < UART_NR; i++) {
+		amio_platform_device[i] =
+			platform_device_register_simple(AMIO_DRIVER_NAME, i, NULL, 0);
+		if (IS_ERR(amio_platform_device[i])) {
+			ret = PTR_ERR(amio_platform_device[i]);
+			goto err_unregister;
+		}
+	}
+
+	if ((ret = platform_driver_register(&serial_amio_driver)) != 0)
+		goto err_unregister;
+
+	return 0;
+
+err_unregister:
+	while (--i >= 0)
+		platform_device_unregister(amio_platform_device[i]);
+
+	uart_unregister_driver(&amio_reg);
+
+	return ret;
+}
+
+static void __exit amio_exit(void)
+{
+	int i;
+
+	platform_driver_unregister(&serial_amio_driver);
+
+	for (i=0; i < UART_NR; i++)
+		platform_device_unregister(amio_platform_device[i]);
+
+	uart_unregister_driver(&amio_reg);
+}
+
+module_init(amio_init);
+module_exit(amio_exit);
+
+MODULE_AUTHOR("Wind River");
+MODULE_DESCRIPTION("MILS AMIO serial driver");
+MODULE_LICENSE("GPL v2");
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 43d3ec4..1a28cdc 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -155,6 +155,9 @@
 
 #define PORT_SC26XX	82
 
+/* Wind River MILS AMIO */
+#define PORT_AMIO	83
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>
-- 
1.7.1.rc2

