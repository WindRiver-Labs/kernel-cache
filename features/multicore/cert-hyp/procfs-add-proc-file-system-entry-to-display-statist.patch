From 3dfcce3fbfe34e05653cd0b3a39cea22e7377184 Mon Sep 17 00:00:00 2001
From: Thomas Tai <thomas.tai@windriver.com>
Date: Fri, 18 Feb 2011 15:38:50 -0500
Subject: [PATCH 4/7] procfs: add proc file system entry to display statistic count

In order to display or reset statistic counts, proc/vbistat
is created. User can use cat /proc/vbistat to display the counter
value.

echo "0" > /proc/vbistat to reset the counter
echo "v" > /proc/vbistat to enable printk message when an unsupported
VBI is called.
echo "q" > /proc/vbistat to quiet printk message when an unsupported
VBI is called.

Signed-off-by: Thomas Tai <thomas.tai@windriver.com>
---
 kernel/vbi/procfs.c |  204 ++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 203 insertions(+), 1 deletions(-)

diff --git a/kernel/vbi/procfs.c b/kernel/vbi/procfs.c
index e8ab1d7..c67d2e1 100644
--- a/kernel/vbi/procfs.c
+++ b/kernel/vbi/procfs.c
@@ -17,7 +17,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  */
-
+#include <linux/uaccess.h>
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/seq_file.h>
@@ -106,9 +106,199 @@ static const struct file_operations procfs_hypinfo_operations = {
 	.release        = seq_release,
 };
 
+/*
+ * Certifiable Hypervisor VBI statistic counts
+ */
+static char vbistat_name[] = "vbistat";
+int vbistat_verbose;
+
+/* variable to identify difference certifiable hypervisor version */
+int cert_hyp_version = CERT_HYP_VER_NONE;
+
+struct vbi_api_stats vbistat_count = {
+	/* functions implemented in vbi.h */
+	.vbi_vb_find_board_config = 0,
+	.vbi_send_vcore_vioapic_irq = 0,
+	.vbi_redir_vioapic_irq = 0,
+	.vbi_disp_vioapic = 0,
+	.vbi_show_shmem = 0,
+	.vbi_show_stat = 0,
+	.vbi_show_ctrl = 0,
+	.vbi_show_cfg = 0,
+	.vbi_show_mem = 0,
+	.vbi_disp_status_regs = 0,
+	.vbi_disp_ctrl_regs = 0,
+	.vbi_show_config_page_map = 0,
+
+	/* functions implemented in syscall.h */
+	.vbi_set_mem_attr = 0,
+	.vbi_get_mem_attr = 0,
+	.vbi_kputs = 0,
+	.vbi_kputc = 0,
+	.vbi_send = 0,
+	.vbi_receive = 0,
+	.vbi_reply = 0,
+	.vbi_vb_restart = 0,
+	.vbi_vb_resume = 0,
+	.vbi_vb_read_mem = 0,
+	.vbi_vb_write_mem = 0,
+	.vbi_shell_start_debug = 0,
+	.vbi_vb_read_reg = 0,
+	.vbi_vb_write_reg = 0,
+	.vbi_ns_register = 0,
+	.vbi_ns_unregister = 0,
+	.vbi_ns_lookup = 0,
+	.vbi_vb_suspend = 0,
+	.vbi_ctx_ctl = 0,
+	.vbi_vb_mgmt = 0,
+
+};
+
+static int vbistat_proc_show(struct seq_file *m, void *v)
+{
+	switch (cert_hyp_version) {
+
+	case CERT_HYP_VER_STD:
+		seq_printf(m, "Certifiable ");
+		break;
+
+	case CERT_HYP_VER_DEBUG:
+		seq_printf(m, "Certifiable Debug Version ");
+		break;
+	}
+	seq_printf(m, "Hypervisor API Call Counts:\n");
+
+	/* functions implemented in vbi.h */
+	seq_printf(m, "vbi_vb_find_board_config %d\n",
+		vbistat_count.vbi_vb_find_board_config);
+	seq_printf(m, "vbi_send_vcore_vioapic_irq %d\n",
+		vbistat_count.vbi_send_vcore_vioapic_irq);
+	seq_printf(m, "vbi_redir_vioapic_irq %d\n",
+		vbistat_count.vbi_redir_vioapic_irq);
+	seq_printf(m, "vbi_disp_vioapic %d\n",
+		vbistat_count.vbi_disp_vioapic);
+	seq_printf(m, "vbi_show_shmem %d\n",
+		vbistat_count.vbi_show_shmem);
+	seq_printf(m, "vbi_show_stat %d\n",
+		vbistat_count.vbi_show_stat);
+	seq_printf(m, "vbi_show_ctrl %d\n",
+		vbistat_count.vbi_show_ctrl);
+	seq_printf(m, "vbi_show_cfg %d\n",
+		vbistat_count.vbi_show_cfg);
+	seq_printf(m, "vbi_show_mem %d\n",
+		vbistat_count.vbi_show_mem);
+	seq_printf(m, "vbi_disp_status_regs %d\n",
+		vbistat_count.vbi_disp_status_regs);
+	seq_printf(m, "vbi_disp_ctrl_regs %d\n",
+		vbistat_count.vbi_disp_ctrl_regs);
+	seq_printf(m, "vbi_show_config_page_map %d\n",
+		vbistat_count.vbi_show_config_page_map);
+
+	/* functions implementted in syscall.h */
+	seq_printf(m, "vbi_set_mem_attr %d\n",
+		vbistat_count.vbi_set_mem_attr);
+	seq_printf(m, "vbi_get_mem_attr %d\n",
+		vbistat_count.vbi_get_mem_attr);
+	seq_printf(m, "vbi_kputs %d\n",
+		vbistat_count.vbi_kputs);
+	seq_printf(m, "vbi_kputc %d\n",
+		vbistat_count.vbi_kputc);
+	seq_printf(m, "vbi_send %d\n",
+		vbistat_count.vbi_send);
+	seq_printf(m, "vbi_receive %d\n",
+		vbistat_count.vbi_receive);
+	seq_printf(m, "vbi_reply %d\n",
+		vbistat_count.vbi_reply);
+	seq_printf(m, "vbi_vb_restart %d\n",
+		vbistat_count.vbi_vb_restart);
+	seq_printf(m, "vbi_vb_resume %d\n",
+		vbistat_count.vbi_vb_resume);
+	seq_printf(m, "vbi_vb_read_mem %d\n",
+		vbistat_count.vbi_vb_read_mem);
+	seq_printf(m, "vbi_vb_write_mem %d\n",
+		vbistat_count.vbi_vb_write_mem);
+	seq_printf(m, "vbi_shell_start_debug %d\n",
+		vbistat_count.vbi_shell_start_debug);
+	seq_printf(m, "vbi_vb_read_reg %d\n",
+		vbistat_count.vbi_vb_read_reg);
+	seq_printf(m, "vbi_vb_write_reg %d\n",
+		vbistat_count.vbi_vb_write_reg);
+	seq_printf(m, "vbi_ns_register %d\n",
+		vbistat_count.vbi_ns_register);
+	seq_printf(m, "vbi_ns_unregister %d\n",
+		vbistat_count.vbi_ns_unregister);
+	seq_printf(m, "vbi_ns_lookup %d\n",
+		vbistat_count.vbi_ns_lookup);
+	seq_printf(m, "vbi_vb_suspend %d\n",
+		vbistat_count.vbi_vb_suspend);
+	seq_printf(m, "vbi_ctx_ctl %d\n",
+		vbistat_count.vbi_ctx_ctl);
+	seq_printf(m, "vbi_vb_mgmt %d\n",
+		vbistat_count.vbi_vb_mgmt);
+
+	seq_printf(m, "\n");
+
+	return 0;
+}
+static int vbistat_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, vbistat_proc_show, NULL);
+}
+
+/* reset stats counter, code template is from linux/fs/proc/base.c */
+static ssize_t vbistat_write(struct file *file, const char __user *buf,
+				size_t count, loff_t *offs)
+{
+	char c;
+
+	if (copy_from_user(&c, buf, 1))
+		return -EFAULT;
+
+	switch (c) {
+
+	case '0':
+		/* clear statistic counter */
+		memset(&vbistat_count, 0, sizeof(vbistat_count));
+		break;
+
+	case 'v':
+		/* printk message whenever an unsupported VBI is called */
+		vbistat_verbose = 1;
+		break;
+
+	case 'q':
+		/* quiet printk message whenever an unsupported VBI is called */
+		vbistat_verbose = 0;
+		break;
+
+	default:
+		/* help message */
+		printk(KERN_INFO "\n");
+		printk(KERN_INFO "echo 0 > /proc/%s/%s to clear counters\n",
+				wind_name,  vbistat_name);
+		printk(KERN_INFO "echo v > /proc/%s/%s to print warning message\n",
+				wind_name, vbistat_name);
+		printk(KERN_INFO "echo q > /proc/%s/%s to quiet warning message\n",
+				wind_name, vbistat_name);
+		break;
+
+	}
+
+	return count;
+}
+
+static const struct file_operations procfs_vbistat_operations = {
+	.open    = vbistat_open,
+	.read    = seq_read,
+	.write   = vbistat_write,
+	.llseek  = seq_lseek,
+	.release = seq_release,
+};
+
 void wrhv_init_procfs(void)
 {
 	struct proc_dir_entry *hypinfo_procfs = NULL;
+	struct proc_dir_entry *vbistat_procfs = NULL;
 
 	wrhv_procfs_root = proc_mkdir(wind_name, NULL);
 	if (!wrhv_procfs_root) {
@@ -124,4 +314,16 @@ void wrhv_init_procfs(void)
 		       wind_name,
 		       hypinfo_name);
 	}
+
+	/* Certifiable VBI statistic counts */
+	vbistat_procfs = proc_create(vbistat_name, 0,
+				wrhv_procfs_root,
+				&procfs_vbistat_operations);
+
+	if (!vbistat_procfs) {
+		printk(KERN_WARNING "Cannot create %s/%s\n",
+		       wind_name,
+		       vbistat_name);
+	}
+
 }
-- 
1.6.5.2

