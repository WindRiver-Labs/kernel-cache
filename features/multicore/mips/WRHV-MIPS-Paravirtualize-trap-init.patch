From 787ddea154a1ce1cbc36ef95915131579765d22d Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Tue, 1 Mar 2011 09:46:06 +0800
Subject: [PATCH 32/38] WRHV: MIPS: Paravirtualize trap init

The most hardware dependent trap init is made by per_cpu_trap_init,
so paravirtualize this function. And, move ebase initialization into
it and call vbi_set_exc_base to setup exception handler base address to
except_vec3_generic. But, still copy the exception handler to ebase+0x180
to keep the compatibility with native Linux.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/include/asm/paravirt.h |    6 +++
 arch/mips/kernel/paravirt.c      |   11 ++++++
 arch/mips/kernel/traps.c         |   12 ++++++-
 arch/mips/kernel/vbi/wrhv.c      |   75 ++++++++++++++++++++++++++++++++++++++
 4 files changed, 103 insertions(+), 1 deletions(-)

diff --git a/arch/mips/include/asm/paravirt.h b/arch/mips/include/asm/paravirt.h
index 29f401a..5882571 100644
--- a/arch/mips/include/asm/paravirt.h
+++ b/arch/mips/include/asm/paravirt.h
@@ -11,10 +11,16 @@ struct pv_info {
 /*
  * native functions
  */
+extern void __init native_per_cpu_trap_init(void);
 
 /*
  * paravirtual operations structure
  */
+struct pv_cpu_ops {
+	void (*per_cpu_trap_init)(void);
+};
+
+extern struct pv_cpu_ops pv_cpu_ops;
 
 #endif /* CONFIG_PARAVIRT */
 #endif	/* __ASM_PARAVIRT_H */
diff --git a/arch/mips/kernel/paravirt.c b/arch/mips/kernel/paravirt.c
index b8fedc1..63f272b 100644
--- a/arch/mips/kernel/paravirt.c
+++ b/arch/mips/kernel/paravirt.c
@@ -38,3 +38,14 @@ struct pv_info pv_info = {
 	.name = "bare hardware",
 	.paravirt_enabled = 0,
 };
+
+struct pv_cpu_ops pv_cpu_ops = {
+	.per_cpu_trap_init = native_per_cpu_trap_init,
+};
+
+void __init paravirt_per_cpu_trap_init(void)
+{
+	pv_cpu_ops.per_cpu_trap_init();
+}
+
+EXPORT_SYMBOL(pv_cpu_ops);
diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index 98f4de8..9d01fc3 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -1458,7 +1458,10 @@ static int __init ulri_disable(char *s)
 }
 __setup("noulri", ulri_disable);
 
-void __cpuinit per_cpu_trap_init(void)
+void paravirt_per_cpu_trap_init(void)
+	__attribute__((weak, alias("native_per_cpu_trap_init")));
+
+void __cpuinit native_per_cpu_trap_init(void)
 {
 	unsigned int cpu = smp_processor_id();
 	unsigned int status_set = ST0_CU0;
@@ -1570,6 +1573,11 @@ void __cpuinit per_cpu_trap_init(void)
 #endif /* CONFIG_MIPS_MT_SMTC */
 }
 
+void __cpuinit per_cpu_trap_init(void)
+{
+	paravirt_per_cpu_trap_init();
+}
+
 /* Install CPU exception handler */
 void __init set_handler(unsigned long offset, void *addr, unsigned long size)
 {
@@ -1625,9 +1633,11 @@ void __init trap_init(void)
 		ebase = (unsigned long)
 			__alloc_bootmem(size, 1 << fls(size), 0);
 	} else {
+#ifndef CONFIG_WRHV
 		ebase = CKSEG0;
 		if (cpu_has_mips_r2)
 			ebase += (read_c0_ebase() & 0x3ffff000);
+#endif
 	}
 
 	per_cpu_trap_init();
diff --git a/arch/mips/kernel/vbi/wrhv.c b/arch/mips/kernel/vbi/wrhv.c
index c55db1c..5326deb 100644
--- a/arch/mips/kernel/vbi/wrhv.c
+++ b/arch/mips/kernel/vbi/wrhv.c
@@ -14,10 +14,83 @@
 
 #include <linux/init.h>
 #include <linux/types.h>
+#include <linux/sched.h>
+
+#include <asm/mipsmtregs.h>
+#include <asm/mmu_context.h>
+
 #include <vbi/vbi.h>
 
 struct vb_config *wr_config;
 
+extern void cpu_cache_init(void);
+extern void tlb_init(void);
+
+#define VECTORSPACING 0x100
+
+void __cpuinit wrhv_per_cpu_trap_init(void)
+{
+	extern char except_vec3_generic;
+	unsigned int cpu = smp_processor_id();
+
+	if (cpu_has_veic || cpu_has_vint) {
+		unsigned long sr = set_c0_status(ST0_BEV);
+		write_c0_ebase(ebase);
+		write_c0_status(sr);
+		/* Setting vector spacing enables EI/VI mode  */
+		change_c0_intctl(0x3e0, VECTORSPACING);
+	}
+	if (cpu_has_divec) {
+		if (cpu_has_mipsmt) {
+			unsigned int vpflags = dvpe();
+			set_c0_cause(CAUSEF_IV);
+			evpe(vpflags);
+		} else
+			set_c0_cause(CAUSEF_IV);
+	} else {
+#ifndef CONFIG_WRHV
+		clear_c0_cause(CAUSEF_IV);
+#endif
+	}
+
+#ifndef CONFIG_WRHV
+	/*
+	 * Before R2 both interrupt numbers were fixed to 7, so on R2 only:
+	 *
+	 *  o read IntCtl.IPTI to determine the timer interrupt
+	 *  o read IntCtl.IPPCI to determine the performance counter interrupt
+	 */
+	if (cpu_has_mips_r2) {
+		cp0_compare_irq_shift = CAUSEB_TI - CAUSEB_IP;
+		cp0_compare_irq = (read_c0_intctl() >> INTCTLB_IPTI) & 7;
+		cp0_perfcount_irq = (read_c0_intctl() >> INTCTLB_IPPCI) & 7;
+		if (cp0_perfcount_irq == cp0_compare_irq)
+			cp0_perfcount_irq = -1;
+	} else {
+		cp0_compare_irq = CP0_LEGACY_COMPARE_IRQ;
+		cp0_compare_irq_shift = cp0_compare_irq;
+		cp0_perfcount_irq = -1;
+	}
+#endif
+
+	cpu_data[cpu].asid_cache = ASID_FIRST_VERSION;
+
+	atomic_inc(&init_mm.mm_count);
+	current->active_mm = &init_mm;
+	BUG_ON(current->mm);
+	enter_lazy_tlb(&init_mm, current);
+
+	ebase = 0xffffffffc0000000;
+	/* Set exception base to except_vec3_generic */
+	vbi_hy_ioctl(VBI_HYIOCTL_EXCBASE, &except_vec3_generic, 0, 0, 0);
+
+	cpu_cache_init();
+	/* Paravirt tlb_init is empty */
+	tlb_init();
+
+	TLBMISS_HANDLER_SETUP();
+}
+
 void __init wrhv_init(void)
 {
 	/* initialize wr_config so that we can access
@@ -27,6 +100,8 @@ void __init wrhv_init(void)
 	wr_config = (struct vb_config *)0xFFFFFFFFD0000000;
 
 	vbi_init(wr_config);
+
+	pv_cpu_ops.per_cpu_trap_init = wrhv_per_cpu_trap_init;
 }
 
 #ifdef CONFIG_PARAVIRT
-- 
1.6.5.2

