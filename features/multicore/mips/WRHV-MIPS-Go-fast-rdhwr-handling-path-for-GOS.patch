From 0037953e31980b2d39a4e835f5e4199bb8a9cdc0 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Tue, 14 Dec 2010 15:12:16 +0800
Subject: [PATCH 15/38] WRHV: MIPS: Go fast rdhwr handling path for GOS

On GOS, exception handler still run in non-exception level, SR[EXL]
is cleared by Hypervisor, so don't need worry TLB exception is
triggered in exception level.
And, even though TLB exception is triggered, Hyerpvisor can lookup
the suitable VMMU table according to the fault address.
So, remove the fault address TLB mapping check and go the fast handling
path for rdhwr exception.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/kernel/wrhv_genex.S |   49 +++++++++++++++++++++++++----------------
 1 files changed, 30 insertions(+), 19 deletions(-)

diff --git a/arch/mips/kernel/wrhv_genex.S b/arch/mips/kernel/wrhv_genex.S
index 22e5a30..b71e59a 100644
--- a/arch/mips/kernel/wrhv_genex.S
+++ b/arch/mips/kernel/wrhv_genex.S
@@ -488,20 +488,19 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	.set	push
 	.set	noat
 	.set	noreorder
-	/* check if TLB contains a entry for EPC */
-	MFC0	k1, CP0_ENTRYHI
-	andi	k1, 0xff	/* ASID_MASK */
-	MFC0	k0, CP0_EPC
-	PTR_SRL	k0, PAGE_SHIFT + 1
-	PTR_SLL	k0, PAGE_SHIFT + 1
-	or	k1, k0
-	MTC0	k1, CP0_ENTRYHI
-	mtc0_tlbw_hazard
-	tlbp
-	tlb_probe_hazard
-	mfc0	k1, CP0_INDEX
+	/*
+	 * On GOS, exception still run in non-exception
+	 * level, SR[EXL] is cleared by Hypervisor, so don't
+	 * need worry TLB exception is triggered in exception
+	 * level.
+	 * And, even though TLB exception is triggered, Hyerpvisor
+	 * can lookup the suitable VMMU table according to the
+	 * fault address.
+	 */
 	.set	pop
-	bltz	k1, handle_ri	/* slow path */
+#ifndef CONFIG_WRHV
+	b	handle_ri /* slow path */
+#endif
 	/* fall thru */
 #endif
 	END(handle_ri_rdhwr_vivt)
@@ -511,23 +510,25 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	.set	noat
 	.set	noreorder
 	/* 0x7c03e83b: rdhwr v1,$29 */
-	MFC0	k1, CP0_EPC
+	PTR_L	k1, wr_vb_status
+	LONG_L	k1, VB_STATUS_EPC(k1)
 	lui	k0, 0x7c03
-	lw	k1, (k1)
+	lw	k1, (k1) /* May cause TLB exception */
 	ori	k0, 0xe83b
 	.set	reorder
 	bne	k0, k1, handle_ri	/* if not ours */
 	/* The insn is rdhwr.  No need to check CAUSE.BD here. */
 	get_saved_sp	/* k1 := current_thread_info */
 	.set	noreorder
-	MFC0	k0, CP0_EPC
+	PTR_L	k0, wr_vb_status
+	LONG_L	k0, VB_STATUS_EPC(k0)
 #if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
 	ori	k1, _THREAD_MASK
 	xori	k1, _THREAD_MASK
 	LONG_L	v1, TI_TP_VALUE(k1)
 	LONG_ADDIU	k0, 4
 	jr	k0
-	 rfe
+	rfe
 #else
 #ifndef CONFIG_CPU_DADDI_WORKAROUNDS
 	LONG_ADDIU	k0, 4		/* stall on $k0 */
@@ -536,7 +537,8 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	LONG_ADDIU	k0, 4
 	.set	noat
 #endif
-	MTC0	k0, CP0_EPC
+	PTR_L	v1, wr_vb_control
+	LONG_S	k0, VB_CONTROL_EPC(v1)
 	/* I hope three instructions between MTC0 and ERET are enough... */
 	ori	k1, _THREAD_MASK
 	xori	k1, _THREAD_MASK
@@ -544,8 +546,17 @@ NESTED(nmi_handler, PT_SIZE, sp)
 #ifdef CONFIG_FAST_ACCESS_TO_THREAD_POINTER
 	move	k0, v1
 #endif
+	PTR_L	k1, wr_vb_status
+	PTR_L	v0, wr_vb_control
+	LONG_S	k0, VB_CONTROL_K0(v0)
+	PTR_L	k0, wr_vb_control
+	LONG_L	v0, VB_STATUS_SR(k1)
+	LONG_S	v0, VB_CONTROL_SR(k0)
+	LONG_L	v0, VB_STATUS_V0(k1)
+	LONG_S	v0, VB_CONTROL_V0(k0)
 	.set	mips3
-	eret
+	jal	vbi_ctx_load
+	nop	
 	.set	mips0
 #endif
 	.set	pop
-- 
1.6.5.2

