From fd3506583797e3fe01d1c57a7a6de4066e6fad17 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Thu, 12 Aug 2010 14:18:00 +0800
Subject: [PATCH] ppc-mc/e500v2: improve law configuration process

Looks the law register offset is different platform so define one variable
for this given case. And it's safe to invalid those address space which are
same as PCIE space so provide the newbie to check if we reuse the same space
then invalid them.

Additionally fix incorrect base address offset while configuring LAW since
we have 36-bit physical address on e500v2.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/include/asm/machdep.h |    1 +
 arch/powerpc/kernel/vbi/wrhv.c     |   36 ++++++++++++++++++++++++++----------
 2 files changed, 27 insertions(+), 10 deletions(-)

diff --git a/arch/powerpc/include/asm/machdep.h b/arch/powerpc/include/asm/machdep.h
index d94b097..92fb12d 100644
--- a/arch/powerpc/include/asm/machdep.h
+++ b/arch/powerpc/include/asm/machdep.h
@@ -281,6 +281,7 @@ struct machdep_calls {
 	int (*earlycon_setup)(void);
 	int (*enable_pci_law)(void);
 	int (*set_law_base)(int index, unsigned long long addr);
+	unsigned long long (*get_law_base)(int index);
 	int (*set_law_attr)(int index, unsigned int attr);
 	int (*get_law_attr)(int index);
 	uint32_t (*get_mdio_bus)(struct mii_bus *bus, int mii_id);
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 4f1e3ec..c2b4317 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -375,8 +375,9 @@ void __init wrhv_time_init(void)
 unsigned int high_base = -1;
 unsigned int low_base = -1;
 unsigned int law_attrib = -1;
+unsigned int law_offset = 0x10;
 unsigned char *law_base;
-int ppc_search_free_law(int target_id)
+int ppc_search_free_law(int target_id, unsigned long long addr)
 {
 	struct device_node *dev;
 	int i, law_num = 0;
@@ -423,12 +424,18 @@ int ppc_search_free_law(int target_id)
 	else
 		return -1;
 
+	/* Get the law register offset for setting law address */
+	prop = of_get_property(dev, "offset", NULL);
+	if (prop)
+		law_offset = *prop;
+
 	if ((!ppc_md.set_law_attr) || (!ppc_md.set_law_base) || (!ppc_md.get_law_attr))
 		return -1;
 
 	for (i = index+1;i < law_num;i++) {
 		/* Firstly we should invalid those existed LAW we want configure. */
-		if ((ppc_md.get_law_attr(i) & LAW_TARGET_ID) == target_id)
+		if (((ppc_md.get_law_attr(i) & LAW_TARGET_ID) == target_id) 
+			|| (ppc_md.get_law_base(i) == addr))
 			ppc_md.set_law_attr(i, 0);
 
 		/* Skip these used LAW item */
@@ -444,7 +451,7 @@ int ppc_search_free_law(int target_id)
 
 void ppc_setup_law(unsigned int target_id, unsigned long long addr, unsigned int attr)
 {
-        int index = ppc_search_free_law(target_id);
+	int index = ppc_search_free_law(target_id, addr);
 	if (index >= 0) {
 		ppc_md.set_law_base(index, addr);
 		ppc_md.set_law_attr(index, attr);
@@ -520,29 +527,38 @@ int wrhv_set_law_base(int index, unsigned long long addr)
 	/* The secret here is that the P4080 has both a high-base and low-base
 	   where as the 8572 only has a high-base attribute */
 	if (low_base == -1)
-		out_be32((unsigned int *)(law_base + high_base + index * 0x10), (unsigned int)(addr >> 8));
+		out_be32((unsigned int *)(law_base + high_base + index * law_offset), (unsigned int)(addr >> 12));
 	else
 	{
-		out_be32((unsigned int *)(law_base + high_base + index * 0x10), (addr >> 32) & 0xf);
+		out_be32((unsigned int *)(law_base + high_base + index * law_offset), (addr >> 32) & 0xf);
 		/* Set Low base address */
-		out_be32((unsigned int *)(law_base + low_base + index * 0x10), (unsigned int)addr);
+		out_be32((unsigned int *)(law_base + low_base + index * law_offset), (unsigned int)addr);
 	}
 	return 0;
 }
- 
+
+unsigned long long wrhv_get_law_base(int index)
+{
+	unsigned long long volatile val = 0;
+	if (low_base == -1)
+		val = in_be32((unsigned int *)(law_base + high_base + index * law_offset));
+
+	return (val << 12);
+}
+
 int wrhv_set_law_attr(int index, unsigned int attr)
 {
 	/* Set Attributes */
-	out_be32((unsigned int *)(law_base + law_attrib + index * 0x10), attr);
+	out_be32((unsigned int *)(law_base + law_attrib + index * law_offset), attr);
 	return 0;
 }
  
 int wrhv_get_law_attr(int index)
 {
-	unsigned int attr = -1;
+	unsigned int volatile attr = -1;
 
 	/* Get Attributes */
-	attr = in_be32((unsigned int *)(law_base + law_attrib + index * 0x10));
+	attr = in_be32((unsigned int *)(law_base + law_attrib + index * law_offset));
 	return attr;
 }
 
-- 
1.6.0.3

