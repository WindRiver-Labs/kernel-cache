From 169bf10cdf10fe71bd8e7d1c937845d3feee33aa Mon Sep 17 00:00:00 2001
From: Jim Somerville <Jim.Somerville@windriver.com>
Date: Fri, 11 Jan 2013 14:08:01 -0500
Subject: [PATCH 2/3] wrhv: arm: paravirt cpu init and die functions

Both cpu_init and platform_cpu_die are covered here.
Includes cpu init changes for unpriv.

Signed-off-by: Jim Somerville <Jim.Somerville@windriver.com>
---
 arch/arm/include/asm/paravirt.h |    2 +
 arch/arm/include/asm/wrhv.h     |   12 ++++
 arch/arm/kernel/paravirt.c      |   10 +++
 arch/arm/kernel/setup.c         |   24 +++-----
 arch/arm/kernel/vbi/wrhv.c      |  117 +++++++++++++++++++++++++++++++++++++++
 5 files changed, 150 insertions(+), 15 deletions(-)

diff --git a/arch/arm/include/asm/paravirt.h b/arch/arm/include/asm/paravirt.h
index 8c61687..939356d 100644
--- a/arch/arm/include/asm/paravirt.h
+++ b/arch/arm/include/asm/paravirt.h
@@ -34,9 +34,11 @@ struct pv_smp_ops {
 	void (*smp_cross_call)(const struct cpumask *mask);
 	int (*boot_secondary)(unsigned int cpu, struct task_struct *idle);
 	void (*platform_secondary_init)(unsigned int cpu);
+	void (*platform_cpu_die)(unsigned int cpu);
 };
 
 struct pv_cpu_ops {
+	void (*cpu_init)(void);
 	void (*do_idle)(void);
 };
 
diff --git a/arch/arm/include/asm/wrhv.h b/arch/arm/include/asm/wrhv.h
index 10500fb..9271980 100644
--- a/arch/arm/include/asm/wrhv.h
+++ b/arch/arm/include/asm/wrhv.h
@@ -21,6 +21,18 @@
 
 #define FAKE_READ_TLS_REG_UNDEF_INSTR	0xee1d0f72 /* mrc p15,0,r0,c13,c2,3 */
 
+#define MAX_BOARD_ID	9
+
+#ifdef CONFIG_THUMB2_KERNEL
+#warning Use of THUMB is unsupported
+/*
+ * In Thumb-2, msr with an immediate value is not allowed.
+ */
+#define PLC	"r"
+#else
+#define PLC	"I"
+#endif
+
 #ifndef __ASSEMBLY__
 
 #include <vbi/vmmu.h>
diff --git a/arch/arm/kernel/paravirt.c b/arch/arm/kernel/paravirt.c
index 81f84ab..9b8b729 100644
--- a/arch/arm/kernel/paravirt.c
+++ b/arch/arm/kernel/paravirt.c
@@ -62,6 +62,11 @@ void paravirt_do_IRQ(struct pt_regs *regs)
 	pv_irq_ops.do_IRQ(regs);
 }
 
+void paravirt_cpu_init(void)
+{
+	pv_cpu_ops.cpu_init();
+}
+
 void paravirt_do_idle(void)
 {
 	pv_cpu_ops.do_idle();
@@ -112,6 +117,11 @@ void paravirt_platform_secondary_init(unsigned int cpu)
 	pv_smp_ops.platform_secondary_init(cpu);
 }
 
+void paravirt_platform_cpu_die(unsigned int cpu)
+{
+	pv_smp_ops.platform_cpu_die(cpu);
+}
+
 void paravirt_smp_cross_call(const struct cpumask *mask)
 {
 	pv_smp_ops.smp_cross_call(mask);
diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 8e17d19..c96f19a 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -121,9 +121,6 @@ struct stack {
 	u32 irq[3];
 	u32 abt[3];
 	u32 und[3];
-#ifdef CONFIG_WRHV
-	u32 fiq[3];
-#endif
 } ____cacheline_aligned;
 
 static struct stack stacks[NR_CPUS];
@@ -334,7 +331,7 @@ static void __init setup_processor(void)
  *
  * cpu_init sets up the per-CPU stacks.
  */
-void cpu_init(void)
+void native_cpu_init(void)
 {
 	unsigned int cpu = smp_processor_id();
 	struct stack *stk = &stacks[cpu];
@@ -367,14 +364,7 @@ void cpu_init(void)
 	"msr	cpsr_c, %5\n\t"
 	"add	r14, %0, %6\n\t"
 	"mov	sp, r14\n\t"
-#ifndef CONFIG_WRHV
 	"msr	cpsr_c, %7"
-#else
-	"msr	cpsr_c, %7\n\t"
-	"add	r14, %0, %8\n\t"
-	"mov	sp, r14\n\t"
-	"msr	cpsr_c, %9"
-#endif
 	    :
 	    : "r" (stk),
 	      PLC (PSR_F_BIT | PSR_I_BIT | IRQ_MODE),
@@ -383,14 +373,18 @@ void cpu_init(void)
 	      "I" (offsetof(struct stack, abt[0])),
 	      PLC (PSR_F_BIT | PSR_I_BIT | UND_MODE),
 	      "I" (offsetof(struct stack, und[0])),
-#ifdef CONFIG_WRHV
-	      PLC (PSR_F_BIT | PSR_I_BIT | FIQ_MODE),
-	      "I" (offsetof(struct stack, fiq[0])),
-#endif
 	      PLC (PSR_F_BIT | PSR_I_BIT | SVC_MODE)
 	    : "r14");
 }
 
+void paravirt_cpu_init(void)
+	__attribute__((weak, alias("native_cpu_init")));
+
+void cpu_init(void)
+{
+	paravirt_cpu_init();
+}
+
 static struct machine_desc * __init setup_machine(unsigned int nr)
 {
 	struct machine_desc *list;
diff --git a/arch/arm/kernel/vbi/wrhv.c b/arch/arm/kernel/vbi/wrhv.c
index e07bc1b..33a86b8 100644
--- a/arch/arm/kernel/vbi/wrhv.c
+++ b/arch/arm/kernel/vbi/wrhv.c
@@ -321,6 +321,17 @@ void __cpuinit wrhv_platform_secondary_init(unsigned int cpu)
 	spin_unlock(&boot_lock);
 }
 
+void wrhv_platform_cpu_die(unsigned int cpu)
+{
+	int ret;
+	ret = vbi_vb_suspend(VBI_BOARD_ID_GET(), cpu);
+	if (ret) {
+		printk(KERN_ERR "WRHV:  cpu %d failed to suspend\n", cpu);
+		while (1);  /* No point in continuing */
+	}
+	printk(KERN_INFO "WRHV:  cpu %d returned from suspend\n", cpu);
+}
+
 irqreturn_t wrhv_timer_interrupt(int irq, void *dev_id)
 {
 	u64 ticks;
@@ -567,6 +578,110 @@ void wrhv_calculate_clock_freq(void)
 		cpu_khz % 1000);
 }
 
+struct wrhv_stack {
+	u32 irq[8];
+	u32 abt[8];
+	u32 und[8];
+	u32 fiq[8];
+} ____cacheline_aligned;
+
+static struct wrhv_stack wrhv_stacks[NR_CPUS];
+
+void wrhv_cpu_init(void)
+{
+	unsigned int cpu = smp_processor_id();
+	struct wrhv_stack *stk = &wrhv_stacks[cpu];
+
+	if (cpu >= NR_CPUS) {
+		printk(KERN_CRIT "CPU%u: bad primary CPU number\n", cpu);
+		BUG();
+	}
+
+#ifndef CONFIG_WRHV_UNPRIV
+	/*
+	 * setup stacks for re-entrant exception handlers
+	 */
+	__asm__ (
+	"msr	cpsr_c, %1\n\t"
+	"add	r14, %0, %2\n\t"
+	"mov	sp, r14\n\t"
+	"msr	cpsr_c, %3\n\t"
+	"add	r14, %0, %4\n\t"
+	"mov	sp, r14\n\t"
+	"msr	cpsr_c, %5\n\t"
+	"add	r14, %0, %6\n\t"
+	"mov	sp, r14\n\t"
+	"msr	cpsr_c, %7\n\t"
+	"add	r14, %0, %8\n\t"
+	"mov	sp, r14\n\t"
+	"msr	cpsr_c, %9"
+	    :
+	    : "r" (stk),
+	      PLC (PSR_F_BIT | PSR_I_BIT | IRQ_MODE),
+	      "I" (offsetof(struct wrhv_stack, irq[0])),
+	      PLC (PSR_F_BIT | PSR_I_BIT | ABT_MODE),
+	      "I" (offsetof(struct wrhv_stack, abt[0])),
+	      PLC (PSR_F_BIT | PSR_I_BIT | UND_MODE),
+	      "I" (offsetof(struct wrhv_stack, und[0])),
+	      PLC (PSR_F_BIT | PSR_I_BIT | FIQ_MODE),
+	      "I" (offsetof(struct wrhv_stack, fiq[0])),
+	      PLC (PSR_F_BIT | PSR_I_BIT | SVC_MODE)
+	    : "r14");
+#else
+	printk(KERN_INFO "WRHV UNPRIV:  Setting up mode stacks for cpu %d\n",
+		cpu);
+	/* Zero the sp and lr fields so they don't get loaded as we
+	   switch modes.
+	 */
+	wr_config->vb_control->vb_control_regs.sp = 0;
+	wr_config->vb_control->vb_control_regs.lr = 0;
+
+	__asm__ (
+	"mov	r0, #0\n\t"
+	"mov	r1, %2\n\t"
+	"mov	r8, %1\n\t"
+	"smc	#0\n\t"
+	"add	r14, %0, %3\n\t"
+	"mov	sp, r14\n\t"
+	"mov	r0, #0\n\t"
+	"mov	r1, %4\n\t"
+	"mov	r8, %1\n\t"
+	"smc	#0\n\t"
+	"add	r14, %0, %5\n\t"
+	"mov	sp, r14\n\t"
+	"mov	r0, #0\n\t"
+	"mov	r1, %6\n\t"
+	"mov	r8, %1\n\t"
+	"smc	#0\n\t"
+	"add	r14, %0, %7\n\t"
+	"mov	sp, r14\n\t"
+	"mov	r0, #0\n\t"
+	"mov	r1, %8\n\t"
+	"mov	r8, %1\n\t"
+	"smc	#0\n\t"
+	"add	r14, %0, %9\n\t"
+	"mov	sp, r14\n\t"
+	"mov	r0, #0\n\t"
+	"mov	r1, %10\n\t"
+	"mov	r8, %1\n\t"
+	"smc	#0"
+	    :
+	    : "r" (stk),
+	      PLC (VBI_SYS_ctx_load),
+	      PLC (PSR_F_BIT | PSR_I_BIT | IRQ_MODE),
+	      "I" (offsetof(struct wrhv_stack, irq[0])),
+	      PLC (PSR_F_BIT | PSR_I_BIT | ABT_MODE),
+	      "I" (offsetof(struct wrhv_stack, abt[0])),
+	      PLC (PSR_F_BIT | PSR_I_BIT | UND_MODE),
+	      "I" (offsetof(struct wrhv_stack, und[0])),
+	      PLC (PSR_F_BIT | PSR_I_BIT | FIQ_MODE),
+	      "I" (offsetof(struct wrhv_stack, fiq[0])),
+	      PLC (PSR_F_BIT | PSR_I_BIT | SVC_MODE)
+	    : "r14");
+
+#endif
+}
+
 void __init wrhv_init(void)
 {
 	/* wr_config was already set, super early */
@@ -581,6 +696,7 @@ void __init wrhv_init(void)
 
 	pv_irq_ops.do_IRQ = wrhv_do_IRQ;
 
+	pv_cpu_ops.cpu_init = wrhv_cpu_init;
 	pv_cpu_ops.do_idle = wrhv_do_idle;
 
 	pv_smp_ops.smp_init_cpus = wrhv_smp_init_cpus;
@@ -588,6 +704,7 @@ void __init wrhv_init(void)
 	pv_smp_ops.smp_cross_call = wrhv_smp_cross_call;
 	pv_smp_ops.boot_secondary = wrhv_boot_secondary;
 	pv_smp_ops.platform_secondary_init = wrhv_platform_secondary_init;
+	pv_smp_ops.platform_cpu_die = wrhv_platform_cpu_die;
 
 	pv_mmu_ops.MMU_init = wrhv_MMU_init;
 	pv_mmu_ops.do_switch_mm = wrhv_do_switch_mm;
-- 
1.7.0

