From 296958eae64a7f461123dd9bd952fc87a0142930 Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Wed, 12 Jan 2011 19:42:34 +0800
Subject: [PATCH] wrhv/gianfar: specify madaddress in kernel cmdline

Different target have different mac address for its
gianfar NIC. Other than specify mac address in dts
file for each board, provide mechanism to enable users
specify mac address in XML file by change kernel
command line parameter would be more flexiable.

Signed-off-by: Liang Li <liang.li@windriver.com>
Signed-off-by: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
---
 arch/powerpc/kernel/vbi/wrhv.c |   43 ++++++++++++++++++++++++++++-------
 drivers/net/gianfar.c          |   48 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 82 insertions(+), 9 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 8e4a90e..f8341e8 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -149,9 +149,10 @@ extern int vb_context_mmu_on(int pid,  /* context id */
 unsigned long wrhv_cpu_freq = 0;
 
 int wrhv_earlycon = -1;
-int wrhv_pci_devfn = -1;
 char wrhv_macaddr[6];
-
+char wrhv_net_name[15]; /* eth0, eth1, eth2... */
+int wrhv_nic_num = 0; /* start with eth0 as default */
+int wrhv_nic_start = 0;
 /* interface to wrhv duart actual device driver */
 #define WRHV_DUART_RX_SIZE	(16)
 #define WRHV_DUART_TX_SIZE	(1024)
@@ -177,7 +178,7 @@ int __init wrhv_earlycon_setup(void)
 {
 	char *p = NULL;
 
-	if((p=strstr(cmd_line, "wrhv_earlycon=")) != NULL){
+	if ((p = strstr(cmd_line, "wrhv_earlycon=")) != NULL) {
 	/* Since the maximal number supported of serial port is 8
 	 * in legacy serial, so here we just use this convention
 	 */
@@ -190,13 +191,38 @@ int __init wrhv_earlycon_setup(void)
 	return 0;
 }
 
-static int __init wrhv_pci_devfn_setup(char *s)
+#define WRHV_IF_NAME 7 /* sizeof(ifname) */
+#define ETH_LENGTH   4 /* length of eth */
+static int __init wrhv_net_name_setup(void)
 {
-	wrhv_pci_devfn = simple_strtoul(s, NULL, 0);
-	return 1;
+	char *p = NULL;
+
+	if ((p = strstr(cmd_line, "ifname=")) != NULL) {
+		printk(KERN_INFO "WRHV: replacing MAC address for %s\n", p);
+		/* First occurance of ifname= in the bootline. Only copy 1
+		"ethX" for now */
+		strncpy(wrhv_net_name, p + WRHV_IF_NAME, ETH_LENGTH);
+		wrhv_nic_start = p[WRHV_IF_NAME + ETH_LENGTH-1] - 0x30;
+		return 1;
+	}
+	return 0;
+}
+__setup("ifname=", wrhv_net_name_setup);
+
+/* How many nics are we setting up? */
+#define WRHV_IFNIC_SIZE 7
+static int __init wrhv_net_num_setup(void)
+{
+	char *p = NULL;
+
+	if ((p = strstr(cmd_line, "ifnics=")) != NULL) {
+		wrhv_nic_num = p[WRHV_IFNIC_SIZE] - 0x30;
+		return 1;
+	}
+	return 0;
 }
+__setup("ifnics=", wrhv_net_num_setup);
 
-__setup("wrhv_pci_devfn=", wrhv_pci_devfn_setup);
 
 static int __init wrhv_macaddr_setup(char *str)
 {
@@ -215,8 +241,7 @@ static int __init wrhv_macaddr_setup(char *str)
 	}
 	return 1;
 }
-
-__setup("wrhv_macaddr=", wrhv_macaddr_setup);
+__setup("ifmacaddr=", wrhv_macaddr_setup);
 
 uint32_t service_handle;
 void get_hv_bsp_server_handle(void)
diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index 233ef2b..3ff1a9f 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -102,6 +102,14 @@
 #undef BRIEF_GFAR_ERRORS
 #undef VERBOSE_GFAR_ERRORS
 
+#ifdef CONFIG_WRHV
+#define NIC_STR_LEN	15
+extern char wrhv_macaddr[MAC_ADDR_LEN];
+extern char wrhv_net_name[NIC_STR_LEN]; /* eth0, eth1, eth2... */
+extern int wrhv_nic_num;
+extern int wrhv_nic_start; /* which index should we start at */
+#endif
+
 const char gfar_driver_name[] = "Gianfar Ethernet";
 const char gfar_driver_version[] = "1.3";
 
@@ -906,6 +914,7 @@ static int gfar_probe(struct of_device *ofdev,
 	u32 rstat = 0, tstat = 0, rqueue = 0, tqueue = 0;
 	u32 isrg = 0;
 	u32 __iomem *baddr;
+	int j;
 
 	err = gfar_of_init(ofdev, &dev);
 
@@ -1093,6 +1102,45 @@ static int gfar_probe(struct of_device *ofdev,
 
 	err = register_netdev(dev);
 
+#ifdef CONFIG_WRHV
+	if (wrhv_nic_start > wrhv_nic_num) {
+		printk(KERN_ERR " WRHV: bootline NIC setup error\n");
+		return -ENODEV;
+	}
+
+	for (j = wrhv_nic_start; j <= wrhv_nic_num; j++) {
+		char nic_num[NIC_STR_LEN] = "";
+		char net_sub_name[NIC_STR_LEN]; /* eth on most platforms except
+		on cavium they call there network devices mgmtX */
+
+		/* eth0 --> we only want the eth part so we
+		   Simply append to the ifname the nic number */
+
+		/* Clear out the buffer for the next iteration */
+		memset(net_sub_name, '\0', NIC_STR_LEN);
+
+		/* get rid of the number on the end 'ethX' */
+		strncpy(net_sub_name, wrhv_net_name, strlen(wrhv_net_name) - 1);
+		sprintf(nic_num, "%d", j);
+		strcat(net_sub_name, nic_num);
+
+		if (strcmp(dev->name, net_sub_name) == 0) {
+			char local_mac[MAC_ADDR_LEN];
+			char last_byte = wrhv_macaddr[MAC_ADDR_LEN - 1];
+
+			memcpy(local_mac, wrhv_macaddr, MAC_ADDR_LEN);
+			/* Extract the last byte of the MAC address */
+			/* One limitation is that we do not check to see if
+			the last byte needs to wrap around.  We expect sane
+			values are being passed in.  This limitation has been
+			documented in the README.bootline */
+
+			local_mac[MAC_ADDR_LEN - 1] = (last_byte + j) & 0xff;
+			memcpy(dev->dev_addr, local_mac, MAC_ADDR_LEN);
+		}
+	}
+#endif
+
 	if (err) {
 		printk(KERN_ERR "%s: Cannot register net device, aborting.\n",
 				dev->name);
-- 
1.6.5.2

