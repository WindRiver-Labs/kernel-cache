From 9608a7f699565b54cfd741626fb43ab9de7739f3 Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Wed, 9 Jun 2010 16:45:34 +0800
Subject: [PATCH] wrhv/syscall: add vbi_control syscall

Provide a system call to export VBI control interface to
userspace

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 arch/powerpc/include/asm/systbl.h  |    1 +
 arch/powerpc/include/asm/unistd.h  |    6 +++-
 arch/x86/include/asm/unistd_32.h   |    6 +++-
 arch/x86/kernel/syscall_table_32.S |    1 +
 kernel/vbi/syscall_vbi.c           |   54 +++++++++++++++++++++++++++++++++++-
 5 files changed, 65 insertions(+), 3 deletions(-)

diff --git a/arch/powerpc/include/asm/systbl.h b/arch/powerpc/include/asm/systbl.h
index 6c5c2e6..5b747a1 100644
--- a/arch/powerpc/include/asm/systbl.h
+++ b/arch/powerpc/include/asm/systbl.h
@@ -328,3 +328,4 @@ COMPAT_SYS_SPU(pwritev)
 COMPAT_SYS(rt_tgsigqueueinfo)
 SYSCALL(vbi_mem)
 SYSCALL(vbi_activate_vb)
+SYSCALL(vbi_control)
diff --git a/arch/powerpc/include/asm/unistd.h b/arch/powerpc/include/asm/unistd.h
index c7442de..3b413e0 100644
--- a/arch/powerpc/include/asm/unistd.h
+++ b/arch/powerpc/include/asm/unistd.h
@@ -347,12 +347,16 @@
 #define __NR_rt_tgsigqueueinfo	322
 #define __NR_vbi_mem		323
 #define __NR_vbi_activate_vb	324
+#define __NR_vbi_control		325
 #define VBI_MEM_READ		0x0010
 #define VBI_MEM_WRITE		0x0100
+#define SYS_VBI_VB_SUSPEND	0x10001
+#define SYS_VBI_VB_RESUME	0x20002
+#define SYS_VBI_VB_RESTART	0x40004
 
 #ifdef __KERNEL__
 
-#define __NR_syscalls		325
+#define __NR_syscalls		326
 
 #define __NR__exit __NR_exit
 #define NR_syscalls	__NR_syscalls
diff --git a/arch/x86/include/asm/unistd_32.h b/arch/x86/include/asm/unistd_32.h
index f251cf8..773e01f 100644
--- a/arch/x86/include/asm/unistd_32.h
+++ b/arch/x86/include/asm/unistd_32.h
@@ -345,12 +345,16 @@
 #define __NR_recvmmsg		337
 #define __NR_vbi_mem		338
 #define __NR_vbi_activate_vb	339
+#define __NR_vbi_control		340
 #define VBI_MEM_READ		0x0010
 #define VBI_MEM_WRITE		0x0100
+#define SYS_VBI_VB_SUSPEND	0x10001
+#define SYS_VBI_VB_RESUME	0x20002
+#define SYS_VBI_VB_RESTART	0x40004
 
 #ifdef __KERNEL__
 
-#define NR_syscalls 340
+#define NR_syscalls 341
 
 #define __ARCH_WANT_IPC_PARSE_VERSION
 #define __ARCH_WANT_OLD_READDIR
diff --git a/arch/x86/kernel/syscall_table_32.S b/arch/x86/kernel/syscall_table_32.S
index 2e0165f..b803225 100644
--- a/arch/x86/kernel/syscall_table_32.S
+++ b/arch/x86/kernel/syscall_table_32.S
@@ -339,3 +339,4 @@ ENTRY(sys_call_table)
 	.long sys_recvmmsg
 	.long sys_vbi_mem		/* 338 */
 	.long sys_vbi_activate_vb	/* 339 */
+	.long sys_vbi_control		/* 340 */
diff --git a/kernel/vbi/syscall_vbi.c b/kernel/vbi/syscall_vbi.c
index ecb2294..89a7f88 100644
--- a/kernel/vbi/syscall_vbi.c
+++ b/kernel/vbi/syscall_vbi.c
@@ -37,9 +37,13 @@ asmlinkage long sys_vbi_activate_vb(uint32_t vb, uint32_t addr)
 	u32 vb_cfg;
 	VBI_HREG_SET_CMPLX_QUALIFIED rctl;
 
+	/*
+	 * Note, here suspend all cores means if dest VB is configured
+	 * as multi CPUs VB, all vcpus of this VB will be suspended.
+	 */
 	retval = vbi_vb_suspend(vb, VBI_VB_CORES_ALL);
 	if (retval) {
-		printk(KERN_ERR "%s: suspend VB%d failed.\n", __func__, vb);
+		printk(KERN_ERR "%s: vb_suspend VB%d failed.\n", __func__, vb);
 		return retval;
 	}
 
@@ -72,6 +76,9 @@ asmlinkage long sys_vbi_activate_vb(uint32_t vb, uint32_t addr)
 		return retval;
 	}
 
+	/*
+	 * Here just core0 of the VB gets re-activated.
+	 */
 	retval = vbi_vb_resume(vb, 0);
 	if (retval)
 		printk(KERN_ERR "%s: vb_resume VB%d failed.\n", __func__, vb);
@@ -125,6 +132,47 @@ out:
 	return rv;
 }
 
+asmlinkage long sys_vbi_control(uint32_t vb, uint32_t command, uint32_t flags)
+{
+	long ret = 0;
+
+	switch(command) {
+	case SYS_VBI_VB_SUSPEND:
+		ret = vbi_vb_suspend(vb, VBI_VB_CORES_ALL);
+		if (ret)
+			printk(KERN_ERR "%s: vb_suspend VB%d failed.\n", __func__, vb);
+		break;
+	case SYS_VBI_VB_RESUME:
+		ret = vbi_vb_resume(vb, VBI_VB_CORES_ALL);
+		if (ret)
+			printk(KERN_ERR "%s: vb_resume VB%d failed.\n", __func__, vb);
+		break;
+	case SYS_VBI_VB_RESTART:
+		if (vb == VBI_BOARD_ID_GET()) {
+			/*
+			 * The policy 'should not suspend self' may change per
+			 * design
+			 */
+			printk(KERN_ERR "%s: can not reset self.\n", __func__);
+			ret = -EPERM;
+		} else {
+			ret = vbi_vb_reset(vb, VBI_VB_CORES_ALL,
+				VBI_VBMGMT_RESET_AND_START_CORE0 |
+				VBI_VBMGMT_RESET_DOWNLOAD |
+				VBI_VBMGMT_RESET_CLEAR
+				);
+			if (ret)
+				printk(KERN_ERR "%s: vb_reset VB%d failed.\n", __func__, vb);
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
 #else /* native/stub variants CONFIG_WRHV */
 
 asmlinkage long sys_vbi_activate_vb(uint32_t vb, uint32_t addr)
@@ -138,4 +186,8 @@ asmlinkage long sys_vbi_mem(uint32_t cpu, void *dest, void *src,
 	return -ENOSYS;
 }
 
+asmlinkage long sys_vbi_control(uint32_t vb, uint32_t command, uint32_t flags)
+{
+	return -ENOSYS;
+}
 #endif /* CONFIG_WRHV */
-- 
1.6.5.2

