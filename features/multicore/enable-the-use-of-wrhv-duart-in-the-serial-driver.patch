From 441152ab683e98eb12eb5c8baf2f13d49c772c6b Mon Sep 17 00:00:00 2001
From: Thomas Tai <thomas.tai@windriver.com>
Date: Thu, 21 Oct 2010 07:53:02 -0700
Subject: [PATCH] enable the use of wrhv duart in the serial driver

The existing linux serial port driver already use serial_in and serial_out
functions pointer to support difference version of serial chips. This two
pointers can be use to support accessing wrhv duart via vbi call. A few
stub functions is hooked to these two pointers, whenever the driver
access the hardware registers, it in term call vbi call to set terminal
options, set interrupt mode and tx/rx data.

A block of stub functions implementation is added at the begin of the
driver and during driver initialization. Since that hypervisor does
not support tx interrupt, changes is required in start_tx to
transmit all data in the uart circular buffer.

The existing driver support both polling and interrupt mode, by patching
the driver wrhv duart support both polling and interrupt automatically.

Signed-off-by: Thomas Tai <thomas.tai@windriver.com>
---
 arch/powerpc/include/asm/wrhv.h |    9 ++
 drivers/serial/8250.c           |  194 +++++++++++++++++++++++++++++++++++++++
 include/vbi/duart.h             |   24 +++++
 3 files changed, 227 insertions(+), 0 deletions(-)
 create mode 100644 include/vbi/duart.h

diff --git a/arch/powerpc/include/asm/wrhv.h b/arch/powerpc/include/asm/wrhv.h
index 8208029..0eabef5 100644
--- a/arch/powerpc/include/asm/wrhv.h
+++ b/arch/powerpc/include/asm/wrhv.h
@@ -59,6 +59,15 @@ extern int ppc_get_pci_intr_wrhv(struct pci_dev *dev);
 extern int wrhv_enable_pci_law(void);
 #endif
 
+
+/* following extern functions is implemented in wrhv.c
+ * to access hypervisor serial driver
+ */
+extern void wrhv_duart_putc(char c);
+extern int wrhv_duart_tstc(void);
+extern int wrhv_duart_getc(void);
+extern int wrhv_duart_init(void);
+
 #endif /* __ASSEMBLY__ */
 #endif /* CONFIG_WRHV */
 #endif /* __ASM_WRHV_H */
diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 5b63294..2fd02f9 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -43,6 +43,13 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
+#ifdef CONFIG_WRHV
+#include <asm/wrhv.h>
+#include <vbi/vbi.h>
+#include <vbi/pdc.h>
+#include <vbi/duart.h>
+#endif
+
 #include "8250.h"
 
 #ifdef CONFIG_SPARC
@@ -388,6 +395,144 @@ static inline int map_8250_out_reg(struct uart_port *p, int offset)
 
 #endif
 
+#ifdef CONFIG_WRHV_DUART
+
+/* handle to access hypervisor serial device driver */
+extern vbi_pdc_handle duartPdc;
+
+/* stub registers */
+static unsigned int wrhv_uart_scr;
+static unsigned int wrhv_uart_ier;
+static unsigned int wrhv_uart_iir;
+static unsigned int wrhv_is_opened = 0;
+
+/* stub function to read register */
+static unsigned int wrhv_serial_in(struct uart_port *p, int offset)
+{
+	unsigned int value;
+	switch (offset) {
+
+	case UART_IER: /* interrupt enable register */
+		return wrhv_uart_ier;
+
+	case UART_LSR: /* line status register */
+		value = BOTH_EMPTY;
+		/* check receiver data ready */
+		if (wrhv_duart_tstc()) {
+			value |= UART_LSR_DR;
+		}
+		return value;
+
+	case UART_MSR: /* modem status register */
+		return UART_MSR_CTS;
+
+	case UART_SCR: /* scratch register */
+		return wrhv_uart_scr;
+
+	case UART_IIR: /* interrupt id register */
+		/* always return FIFO enabled bits */
+		return wrhv_uart_iir | 0xc0;
+
+	case UART_RX: /* receive buffer */
+		/* return received character */
+		return wrhv_duart_getc();
+
+	}
+
+	return 0;
+}
+
+/* stub function to write register */
+static void wrhv_serial_out(struct uart_port *p, int offset, int value)
+{
+	unsigned int mode;
+	switch (offset) {
+
+	case UART_IER: /* interrupt enable register */
+		wrhv_uart_ier = (unsigned int)value;
+		/* set wrhv duart to interrupt mode */
+		if (wrhv_uart_ier) {
+			if (!wrhv_is_opened) {
+				wrhv_is_opened = 1;
+				value = vbi_pdc_op(duartPdc, PDC_REQUEST_IOCTL,
+					PDC_IOCTL_SIO_OPEN,
+					0, 0,
+				0);
+			}
+			/* set driver to interrupt mode */
+			mode = SIO_MODE_INT;
+			value = vbi_pdc_op(duartPdc, PDC_REQUEST_IOCTL,
+				PDC_IOCTL_SIO_MODE_SET,
+				(void *)mode, SIO_HW_OPTS_CLOCAL,
+				0);
+		}
+		break;
+
+	case UART_TX: /* transmit register */
+		wrhv_duart_putc(value);
+		break;
+
+	case UART_SCR: /* scratch register */
+		wrhv_uart_scr = (unsigned int)value;
+		break;
+
+	case UART_IIR: /* interrupt id register */
+		wrhv_uart_iir = (unsigned int)value;
+		break;
+
+	}
+}
+
+/* function to set terminal options */
+static void wrhv_set_termios(struct uart_port *port, struct ktermios *termios,
+		       struct ktermios *old)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+	unsigned int cval;
+	unsigned long flags;
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		cval = SIO_HW_OPTS_CS5;
+		break;
+	case CS6:
+		cval = SIO_HW_OPTS_CS6;
+		break;
+	case CS7:
+		cval = SIO_HW_OPTS_CS7;
+		break;
+	default:
+	case CS8:
+		cval = SIO_HW_OPTS_CS8;
+		break;
+	}
+
+	if (termios->c_cflag & CSTOPB)
+		cval |= SIO_HW_OPTS_STOPB;
+	if (termios->c_cflag & PARENB)
+		cval |= SIO_HW_OPTS_PARENB;
+	if (!(termios->c_cflag & PARODD))
+		cval |= SIO_HW_OPTS_PARODD;
+
+	/*
+	 * ignore all characters if CREAD is not set
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		up->port.ignore_status_mask |= UART_LSR_DR;
+	else
+		cval |= CREAD;
+
+	/*
+	 * Ok, we're now changing the port state.  Do it with
+	 * interrupts disabled.
+	 */
+	spin_lock_irqsave(&up->port.lock, flags);
+	vbi_pdc_op(duartPdc, PDC_REQUEST_IOCTL, PDC_IOCTL_SIO_HW_OPTS_SET,
+			(void *)cval, 0, 0);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+#endif
+
 static unsigned int hub6_serial_in(struct uart_port *p, int offset)
 {
 	offset = map_8250_in_reg(p, offset) << p->regshift;
@@ -528,6 +673,13 @@ static void set_io_from_upio(struct uart_port *p)
 		p->serial_out = io_serial_out;
 		break;
 	}
+
+#ifdef CONFIG_WRHV_DUART
+	/* use stub functions to access register */
+	p->serial_in = wrhv_serial_in;
+	p->serial_out = wrhv_serial_out;
+#endif
+
 	/* Remember loaded iotype */
 	up->cur_iotype = p->iotype;
 }
@@ -1054,6 +1206,7 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 	 * already a 1 and maybe locked there before we even start start.
 	 */
 	iersave = serial_in(up, UART_IER);
+#ifndef CONFIG_WRHV_DUART
 	serial_outp(up, UART_IER, iersave & ~UART_IER_UUE);
 	if (!(serial_in(up, UART_IER) & UART_IER_UUE)) {
 		/*
@@ -1078,6 +1231,7 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 		 */
 		DEBUG_AUTOCONF("Couldn't force IER_UUE to 0 ");
 	}
+#endif
 	serial_outp(up, UART_IER, iersave);
 }
 
@@ -1336,6 +1490,16 @@ static void serial8250_start_tx(struct uart_port *port)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
 
+#ifdef CONFIG_WRHV_DUART
+	/* wrhv duart does not support tx interrupt, so need to
+	 * check uart circ_buf and transmit all characters
+	 */
+	do {
+		transmit_chars(up);
+	} while (!uart_circ_empty(&up->port.state->xmit));
+	return;
+#endif
+
 	if (!(up->ier & UART_IER_THRI)) {
 		up->ier |= UART_IER_THRI;
 		serial_out(up, UART_IER, up->ier);
@@ -1532,12 +1696,14 @@ static void serial8250_handle_port(struct uart_8250_port *up)
 
 	spin_lock_irqsave(&up->port.lock, flags);
 
+#ifndef CONFIG_WRHV_DUART
 	if (unlikely(up->lsr_last & UART_LSR_BI && up->bugs & UART_BUG_PPC)) {
 		up->lsr_last &= ~UART_LSR_BI;
 		serial_inp(up, UART_RX);
 		spin_unlock_irqrestore(&up->port.lock, flags);
 		return;
 	}
+#endif
 
 	status = up->lsr_last = serial_inp(up, UART_LSR);
 
@@ -1545,9 +1711,15 @@ static void serial8250_handle_port(struct uart_8250_port *up)
 
 	if (status & (UART_LSR_DR | UART_LSR_BI))
 		receive_chars(up, &status);
+
+/* wrhv duart does not support tx interrupt, we always handle
+ * transmit buffer in start_tx()
+ */
+#ifndef CONFIG_WRHV_DUART
 	check_modem_status(up);
 	if (status & UART_LSR_THRE)
 		transmit_chars(up);
+#endif
 
 	spin_unlock_irqrestore(&up->port.lock, flags);
 }
@@ -1583,6 +1755,15 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 
 		up = list_entry(l, struct uart_8250_port, list);
 
+#ifdef CONFIG_WRHV_DUART
+		/* for wrhv duart, we check rx interrupt in
+		 * serial8250_handl_port()
+		 */
+		serial8250_handle_port(up);
+		handled = 1;
+		end = NULL;
+		break;
+#endif
 		iir = serial_in(up, UART_IIR);
 		if (!(iir & UART_IIR_NO_INT)) {
 			serial8250_handle_port(up);
@@ -1590,6 +1771,7 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 			handled = 1;
 
 			end = NULL;
+			break;
 		} else if (up->port.iotype == UPIO_DWAPB &&
 			  (iir & UART_IIR_BUSY) == UART_IIR_BUSY) {
 			/* The DesignWare APB UART has an Busy Detect (0x07)
@@ -2662,7 +2844,11 @@ static struct uart_ops serial8250_pops = {
 	.break_ctl	= serial8250_break_ctl,
 	.startup	= serial8250_startup,
 	.shutdown	= serial8250_shutdown,
+#ifdef CONFIG_WRHV_DUART
+	.set_termios	= wrhv_set_termios,
+#else
 	.set_termios	= serial8250_set_termios,
+#endif
 	.set_ldisc	= serial8250_set_ldisc,
 	.pm		= serial8250_pm,
 	.type		= serial8250_type,
@@ -2844,6 +3030,7 @@ static int __init serial8250_console_setup(struct console *co, char *options)
 	if (co->index >= nr_uarts)
 		co->index = 0;
 	port = &serial8250_ports[co->index].port;
+
 	if (!port->iobase && !port->membase)
 		return -ENODEV;
 
@@ -2871,6 +3058,9 @@ static struct console serial8250_console = {
 
 static int __init serial8250_console_init(void)
 {
+#ifdef CONFIG_WRHV_DUART
+	wrhv_duart_init();
+#endif
 	if (nr_uarts > UART_NR)
 		nr_uarts = UART_NR;
 
@@ -3246,6 +3436,10 @@ static int __init serial8250_init(void)
 {
 	int ret;
 
+#ifdef CONFIG_WRHV_DUART
+	wrhv_duart_init();
+#endif
+
 	if (nr_uarts > UART_NR)
 		nr_uarts = UART_NR;
 
diff --git a/include/vbi/duart.h b/include/vbi/duart.h
new file mode 100644
index 0000000..99c6b89
--- /dev/null
+++ b/include/vbi/duart.h
@@ -0,0 +1,24 @@
+#ifndef DAURT_H
+#define DAURT_H
+
+/* taken from wrhv-1.2/include/sys/devices/drivers/serial.h */
+#define SIO_MODE_POLL   1       /* polling mode */
+#define SIO_MODE_INT    2       /* interrupt mode */
+
+/* options to SIO_HW_OPTS_SET (ala POSIX), bitwise or'ed together */
+
+#define SIO_HW_OPTS_CLOCAL 0x1 /* ignore modem status lines */
+#define SIO_HW_OPTS_CREAD  0x2 /* enable device reciever */
+
+#define SIO_HW_OPTS_CSIZE  0xc /* bits 3 and 4 encode the character size */
+#define SIO_HW_OPTS_CS5    0x0 /* 5 bits */
+#define SIO_HW_OPTS_CS6    0x4 /* 6 bits */
+#define SIO_HW_OPTS_CS7    0x8 /* 7 bits */
+#define SIO_HW_OPTS_CS8    0xc /* 8 bits */
+
+#define SIO_HW_OPTS_HUPCL  0x10 /* hang up on last close */
+#define SIO_HW_OPTS_STOPB  0x20 /* send two stop bits (else one) */
+#define SIO_HW_OPTS_PARENB 0x40 /* parity detection enabled (else disabled) */
+#define SIO_HW_OPTS_PARODD 0x80 /* odd parity  (else even) */
+
+#endif /* DUART_H */
-- 
1.6.5.2

