From 3ec6b4e619cb76d5fb53671099891c5227330761 Mon Sep 17 00:00:00 2001
From: WRS Support <support@windriver.com>
Date: Fri, 2 Oct 2009 16:10:07 -0400
Subject: [PATCH] wrhv: introduce the core WR hypervisor support

These files represent the Linux specific additions that
were not specifically a part of the reference VBI implementation.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 include/linux/wrhv.h |   92 ++++++++++++++++++++++++++
 init/Kconfig.wrhv    |   14 ++++
 kernel/vbi/wrhv.c    |  174 ++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 280 insertions(+), 0 deletions(-)
 create mode 100644 include/linux/wrhv.h
 create mode 100644 init/Kconfig.wrhv
 create mode 100644 kernel/vbi/wrhv.c

diff --git a/include/linux/wrhv.h b/include/linux/wrhv.h
new file mode 100644
index 0000000..885269d
--- /dev/null
+++ b/include/linux/wrhv.h
@@ -0,0 +1,92 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  Copyright (C) 2008 Wind River Systems, Inc.
+ */
+
+#ifndef __LINUX_WRHV_H
+#define __LINUX_WRHV_H
+
+#ifdef CONFIG_WRHV
+extern irqreturn_t wrhv_timer_interrupt(int irq, void *dev_id);
+extern unsigned long wrhv_calculate_cpu_khz(void);
+extern struct irq_chip wrhv_irq_chip;
+
+#ifdef CONFIG_SMP
+extern struct irq_chip wrhv_ipi_irq_chip;
+#endif
+
+/* IO APIC register get/set macros */
+/* Accesses are double words using an
+ * indirect addressing scheme.
+ */
+/* Redirection table entry bits: lower 32 bit */
+
+#define VIOAPIC_INT_MASK	0x00010000
+#define VIOAPIC_LEVEL		0x00008000
+#define VIOAPIC_EDGE		0x00000000
+#define VIOAPIC_HIGH		0x00000000
+#define VIOAPIC_REMOTE		0x00004000
+#define VIOAPIC_LOW		0x00002000
+#define VIOAPIC_LOGICAL		0x00000800
+#define VIOAPIC_PHYSICAL	0x00000000
+#define VIOAPIC_FIXED		0x00000000
+#define VIOAPIC_LOWEST		0x00000100
+#define VIOAPIC_SMI		0x00000200
+#define VIOAPIC_NMI		0x00000400
+#define VIOAPIC_INIT		0x00000500
+#define VIOAPIC_EXTINT		0x00000700
+#define VIOAPIC_VEC_MASK	0x000000ff
+
+/* Redirection table entry size per IO APIC */
+
+#define MAX_REDTABLE_ENTRIES_PER_APIC	24
+#define VIOAPIC_REG_REDTBL		0x10	/* Redirection Table (24 * 64bit) */
+
+#define	VIOAPIC_REG_GET(base, offset)		\
+		(*((volatile unsigned int *)((base) + (offset))))
+
+#define	VIOAPIC_REG_SET(base, offset, value)	\
+		(*((volatile unsigned int *)((base) + (offset))) = (value))
+
+/* IO APIC redirection table entry. Split into high/low 32 */
+
+typedef union {
+	struct {
+		uint32_t reserved:24;	/* reserved bits */
+		uint32_t destination:8;	/* destination field */
+	} field;
+	uint32_t value;
+} VIOAPIC_REDIR_HIGH;
+
+typedef union {
+	struct {
+		uint32_t vector:8;	/* vector number */
+		uint32_t deliveryMode:3;/* delivery mode:
+					 * fixed, lowest, SMI, reserved, NMI,
+					 * INIT, reserved, extInt */
+		uint32_t destMode:1;	/* destination mode: 0=physical, 1=logical */
+		uint32_t delivStatus:1;	/* delivery status: 0=idle, 1=pending*/
+		uint32_t polarity:1;	/* polarity: 0=high active */
+		uint32_t irr:1;		/* remote IRR (level only): 1 before LAPIC
+					 * accepts level, 0 after EOI */
+		uint32_t trigger:1;	/* 0=edge, 1=level */
+		uint32_t mask:1;	/* 1=masked */
+		uint32_t reserved:15;	/* reserved bits */
+	} field;
+
+	uint32_t value;
+} VIOAPIC_REDIR_LOW;
+
+#else
+#endif
+
+#endif	/* __LINUX_WRHV_H */
diff --git a/init/Kconfig.wrhv b/init/Kconfig.wrhv
new file mode 100644
index 0000000..f13152b
--- /dev/null
+++ b/init/Kconfig.wrhv
@@ -0,0 +1,14 @@
+config WRHV
+	bool "Wind River Hypervisor Virtualization"
+	default y
+	depends on PARAVIRT && !(X86 && SPARSE_IRQ)
+	help
+	  This option is provided to enable the Wind River virtualization in the
+	  Linux Kernel.
+	select SERIAL_CORE
+	select SERIAL_CORE_CONSOLE
+
+config DEBUG_VIRTUAL_IRQS
+	bool "Debug VIOAPIC with software IRQ"
+	default n
+	depends on WRHV
diff --git a/kernel/vbi/wrhv.c b/kernel/vbi/wrhv.c
new file mode 100644
index 0000000..59fa6a7
--- /dev/null
+++ b/kernel/vbi/wrhv.c
@@ -0,0 +1,174 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  Copyright (C) 2008 Wind River Systems, Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/profile.h>
+#include <linux/kernel_stat.h>
+#include <linux/wrhv.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+#include <vbi/vbi.h>
+
+#define VIOAPIC_BASE_ADDR	(&wr_vb_control->vIoapic)
+
+static void wrhv_enable_irq(unsigned int irq)
+{
+	vbi_unmask_vioapic_irq(irq);
+}
+
+static void wrhv_disable_irq(unsigned int irq)
+{
+	vbi_mask_vioapic_irq(irq);
+}
+
+static void wrhv_ack_irq(unsigned int irq)
+{
+	vbi_ack_vioapic_irq(irq);
+}
+
+static void wrhv_maskack_irq(unsigned int irq)
+{
+	if (irq != 0)
+		vbi_mask_vioapic_irq(irq);
+	vbi_ack_vioapic_irq(irq);
+}
+
+static void wrhv_mask_irq(unsigned int irq)
+{
+	if (irq != 0)
+		vbi_mask_vioapic_irq(irq);
+}
+
+static void wrhv_unmask_irq(unsigned int irq)
+{
+	if (irq != 0)
+		vbi_unmask_vioapic_irq(irq);
+}
+
+#ifdef CONFIG_SMP
+static void smp_wrhv_mask_irq(void *irq)
+{
+	vbi_mask_vioapic_irq((unsigned int)irq);
+}
+
+static void smp_wrhv_unmask_irq(void *irq)
+{
+	vbi_unmask_vioapic_irq((unsigned int)irq);
+}
+
+/* Currently all the external interrupts are routed to cpu 0 and
+ * handled by cpu0, so we need make sure the startup/shutdown functions
+ * operate cpu 0's vioapic.
+ */
+static void smp_wrhv_shutdown_irq(unsigned int irq)
+{
+	if (smp_processor_id() == 0)
+		smp_wrhv_mask_irq((void *)irq);
+	else {
+		struct call_single_data *data;
+
+		data = kmalloc(sizeof(*data), GFP_ATOMIC);
+		if (!data)
+			return;
+
+		data->flags = CSD_FLAG_ALLOC;
+		data->func = smp_wrhv_mask_irq;
+		data->info = (void *)irq;
+		__smp_call_function_single(0, data);
+	}
+}
+
+static unsigned int smp_wrhv_startup_irq(unsigned int irq)
+{
+	if (smp_processor_id() == 0)
+		smp_wrhv_unmask_irq((void *)irq);
+	else {
+		struct call_single_data *data;
+
+		data = kmalloc(sizeof(*data), GFP_ATOMIC);
+		if (!data)
+			return -ENOMEM;
+
+		data->flags = CSD_FLAG_ALLOC;
+		data->func = smp_wrhv_unmask_irq;
+		data->info = (void *)irq;
+		__smp_call_function_single(0, data);
+	}
+	return 0;
+}
+#endif
+
+struct irq_chip wrhv_irq_chip = {
+	.name		= "WRHV-PIC",
+#ifdef CONFIG_SMP
+	.startup	= smp_wrhv_startup_irq,
+	.shutdown	= smp_wrhv_shutdown_irq,
+#endif
+	.mask		= wrhv_mask_irq,
+	.ack		= wrhv_ack_irq,
+	.disable	= wrhv_disable_irq,
+	.enable		= wrhv_enable_irq,
+	.unmask		= wrhv_unmask_irq,
+	.mask_ack	= wrhv_maskack_irq,
+	.eoi		= wrhv_ack_irq,
+};
+
+#ifdef CONFIG_SMP
+struct irq_chip wrhv_ipi_irq_chip = {
+	.name		= "WRHV-IPI-PIC",
+	.mask		= wrhv_mask_irq,
+	.disable	= wrhv_disable_irq,
+	.enable		= wrhv_enable_irq,
+	.unmask		= wrhv_unmask_irq,
+	.mask_ack	= wrhv_maskack_irq,
+	.eoi		= wrhv_ack_irq,
+};
+#endif
+
+unsigned long wrhv_calculate_cpu_khz(void)
+{
+	printk(KERN_DEBUG "WRHV: Timestamp Frequency %u Hz\n",
+		wr_vb_config->stamp_freq);
+	return wr_vb_config->stamp_freq / 1000;
+}
+
+irqreturn_t __weak wrhv_timer_interrupt(int irq, void *dev_id)
+{
+	static long long mark_offset;
+	long long ticks;
+	int lost_jiffies = 0;
+	struct pt_regs *regs = get_irq_regs();
+
+	ticks = wr_vb_status->tick_count;
+	ticks -= mark_offset;
+	lost_jiffies = ticks - 1;
+	mark_offset = wr_vb_status->tick_count;
+
+	do {
+		do_timer(1);
+		update_process_times(user_mode(regs));
+		profile_tick(CPU_PROFILING);
+		if (lost_jiffies > (2*HZ)) {
+			printk(KERN_DEBUG "Time falling behind %d jiffies\n",
+				lost_jiffies);
+			break;
+		}
+	} while (--ticks > 0);
+
+	if (lost_jiffies)
+		account_steal_time(NULL, jiffies_to_cputime(lost_jiffies));
+	return IRQ_HANDLED;
+}
-- 
1.7.4.1

