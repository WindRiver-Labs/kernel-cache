From 25d213e62a135935bca1e977d1c18a8ceca0122b Mon Sep 17 00:00:00 2001
From: Diana Craciun <Diana.Craciun@freescale.com>
Date: Tue, 2 Jun 2015 11:18:41 +0300
Subject: [PATCH 005/452] Fixed: BUG: failure at
 ./arch/arm64/include/asm/arch_timer.h:135/arch_counter_get_cntvct()!

Commit 97da8b8f8abcb2c9bd479adcd365fb1da66166ad:
fsl/ls2085a: Add handling for ARM generic timer errata (ERR008585)
implemented the workaround for ERR008585 erratum by reading certain
time related registers twice. The code for reading the CNTCVT_EL0
register is as follows:

	isb();
	asm volatile("mrs %0, cntvct_el0" : "=r" (cval));

	asm volatile("mrs %0, cntvct_el0" : "=r" (cval_new));
	while (cval != cval_new && timeout) {
		cval = cval_new;
		asm volatile("mrs %0, cntvct_el0" : "=r"(cval_new));
        timeout--;
    }
    BUG_ON((timeout <= 0) && (cval != cval_new));
Sometimes the BUG_ON was triggered. The problem is that between the
two reads of the cntvct_el0 there is a delay (there are some
instructions between the reads) and the timer is naturally incremented.
In this way the two values read will be never the same and the timeout
will expire.
The fix use two consecutive reads of the timer without any other
instruction between them to avoid the natural increment of the timer.

Signed-off-by: Diana Craciun <Diana.Craciun@freescale.com>
Change-Id: I664f469a5aa460772bcdad437091a26ce6396384
Reviewed-on: http://git.am.freescale.net:8181/37309
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
Tested-by: Stuart Yoder <stuart.yoder@freescale.com>
[Xulin: Original patch taken from FSL LS2085 SDK EAR6.0,
LS2085A-SDK-SOURCE-20160304-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 arch/arm64/include/asm/arch_timer.h |   13 ++++++-------
 1 files changed, 6 insertions(+), 7 deletions(-)

diff --git a/arch/arm64/include/asm/arch_timer.h b/arch/arm64/include/asm/arch_timer.h
index a7c9e02..2ba4007 100644
--- a/arch/arm64/include/asm/arch_timer.h
+++ b/arch/arm64/include/asm/arch_timer.h
@@ -113,26 +113,25 @@ static inline u64 arch_counter_get_cntpct(void)
 	BUG();
 	return 0;
 }
-
 static inline u64 arch_counter_get_cntvct(void)
 {
 	u64 cval;
 
 #ifdef CONFIG_LS2085A_ERRATA_ERR008585
-	u64 cval_new, timeout = 200;
+	u64 tmp, timeout = 200;
 #endif
 
 	isb();
 	asm volatile("mrs %0, cntvct_el0" : "=r" (cval));
 
 #ifdef CONFIG_LS2085A_ERRATA_ERR008585
-	asm volatile("mrs %0, cntvct_el0" : "=r" (cval_new));
-	while (cval != cval_new && timeout) {
-		cval = cval_new;
-		asm volatile("mrs %0, cntvct_el0" : "=r" (cval_new));
+	asm volatile("mrs %0, cntvct_el0" : "=r" (tmp));
+	while (cval != tmp && timeout) {
+		asm volatile("mrs %0, cntvct_el0" : "=r" (cval));
+		asm volatile("mrs %0, cntvct_el0" : "=r" (tmp));
 		timeout--;
 	}
-	BUG_ON((timeout <= 0) && (cval != cval_new));
+	BUG_ON((timeout <= 0) && (cval != tmp));
 #endif
 
 	return cval;
-- 
1.7.5.4

