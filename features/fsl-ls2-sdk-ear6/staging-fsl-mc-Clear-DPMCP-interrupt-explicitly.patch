From 94a7b6d6e2abbbfb0444dda42a3ef7999102ec74 Mon Sep 17 00:00:00 2001
From: "J. German Rivera" <German.Rivera@freescale.com>
Date: Wed, 24 Jun 2015 08:52:26 -0500
Subject: [PATCH 091/452] staging: fsl-mc: Clear DPMCP interrupt explicitly

Signed-off-by: J. German Rivera <German.Rivera@freescale.com>
Change-Id: I11ee4bf654ecf576bf81a5a06f5f15ab68e45845
Reviewed-on: http://git.am.freescale.net:8181/38767
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
[Xulin: Original patch taken from FSL LS2085 SDK EAR6.0,
LS2085A-SDK-SOURCE-20160304-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/staging/fsl-mc/bus/dprc-driver.c  |    6 +-
 drivers/staging/fsl-mc/bus/mc-allocator.c |    7 ++-
 drivers/staging/fsl-mc/bus/mc-sys.c       |  114 ++++++++++++++++++++++++++--
 drivers/staging/fsl-mc/include/mc-sys.h   |   15 ++++
 4 files changed, 130 insertions(+), 12 deletions(-)

diff --git a/drivers/staging/fsl-mc/bus/dprc-driver.c b/drivers/staging/fsl-mc/bus/dprc-driver.c
index 5231410..4fdce28 100644
--- a/drivers/staging/fsl-mc/bus/dprc-driver.c
+++ b/drivers/staging/fsl-mc/bus/dprc-driver.c
@@ -875,7 +875,9 @@ static int dprc_probe(struct fsl_mc_device *mc_dev)
 
 	if (fsl_mc_interrupts_supported()) {
 		/*
-		 * Create DPMCP for the DPRC's built-in portal:
+		 * Create DPMCP for the DPRC's built-in portal, to have
+		 * DPMCP completion interrupts for MC commands sent on
+		 * the DPRC's built-in portal:
 		 */
 		error = dprc_create_dpmcp(mc_dev);
 		if (error < 0)
@@ -907,7 +909,7 @@ static int dprc_probe(struct fsl_mc_device *mc_dev)
 		 * DPRC object's built-in portal:
 		 *
 		 * NOTE: We have to do this after calling dprc_scan_container(),
-		 * since dprc_scan_container() will populate the IRQ pool for
+		 * since dprc_scan_container() populates the IRQ pool for
 		 * this DPRC.
 		 */
 		error = fsl_mc_io_setup_dpmcp_irq(mc_dev->mc_io);
diff --git a/drivers/staging/fsl-mc/bus/mc-allocator.c b/drivers/staging/fsl-mc/bus/mc-allocator.c
index 3531ca3..79d2afb 100644
--- a/drivers/staging/fsl-mc/bus/mc-allocator.c
+++ b/drivers/staging/fsl-mc/bus/mc-allocator.c
@@ -290,7 +290,12 @@ int __must_check fsl_mc_portal_allocate(struct fsl_mc_device *mc_dev,
 	struct fsl_mc_resource *resource = NULL;
 	struct fsl_mc_io *mc_io = NULL;
 
-	if (mc_dev->flags & FSL_MC_IS_DPRC) {
+	if (!mc_dev) {
+		if (WARN_ON(!fsl_mc_bus_type.dev_root))
+			return error;
+
+		mc_bus_dev = to_fsl_mc_device(fsl_mc_bus_type.dev_root);
+	} else if (mc_dev->flags & FSL_MC_IS_DPRC) {
 		mc_bus_dev = mc_dev;
 	} else {
 		if (WARN_ON(mc_dev->dev.parent->bus != &fsl_mc_bus_type))
diff --git a/drivers/staging/fsl-mc/bus/mc-sys.c b/drivers/staging/fsl-mc/bus/mc-sys.c
index 4fb9e8e..45d24f5 100644
--- a/drivers/staging/fsl-mc/bus/mc-sys.c
+++ b/drivers/staging/fsl-mc/bus/mc-sys.c
@@ -58,6 +58,32 @@
 	((uint16_t)mc_dec((_hdr), MC_CMD_HDR_CMDID_O, MC_CMD_HDR_CMDID_S))
 
 /**
+ * Global state variables for the DPMCP Command completion ISR
+ *
+ * @mc_io: Pointer to MC IO object to be used to send MC commands
+ * from the DPMCP completion interrupt handler.
+ * @dpmcp_count: Coun of of DPMCP objects for which fsl_mc_io_setup_dpmcp_irq()
+ * has been called.
+ *
+ * NOTE: We use a common atomic MC portal for handling DPMCP completion
+ * interrupts for all DPMCPs, for scalability. Otherwise, we would need
+ * to have an additional MC portal per DPMCP.
+ *
+ * TODO: If needed, to avoid contention between DPMCP completion interrupts
+ * that fired on different CPUs (for different DPMCPs), we should have
+ * one dedicated MC portal per CPU, to be used for sending MC commands from
+ * the DPMCP completion ISR.
+ */
+struct fsl_mc_dpmcp_isr {
+	struct fsl_mc_io *mc_io;
+	atomic_t dpmcp_count;
+};
+
+static struct fsl_mc_dpmcp_isr fsl_mc_dpmcp_isr = {
+	.dpmcp_count = ATOMIC_INIT(0),
+};
+
+/**
  * dpmcp_irq0_handler - Regular ISR for DPMCP interrupt 0
  *
  * @irq: IRQ number of the interrupt being handled
@@ -65,8 +91,10 @@
  */
 static irqreturn_t dpmcp_irq0_handler(int irq_num, void *arg)
 {
+	int error;
 	struct device *dev = (struct device *)arg;
 	struct fsl_mc_device *dpmcp_dev = to_fsl_mc_device(dev);
+	struct fsl_mc_io *mc_io = dpmcp_dev->mc_io;
 
 	dev_dbg(dev, "DPMCP IRQ %d triggered on CPU %u\n", irq_num,
 		smp_processor_id());
@@ -74,14 +102,30 @@ static irqreturn_t dpmcp_irq0_handler(int irq_num, void *arg)
 	if (WARN_ON(dpmcp_dev->irqs[0]->irq_number != (uint32_t)irq_num))
 		goto out;
 
-	if (WARN_ON(!dpmcp_dev->mc_io))
+	if (WARN_ON(!mc_io))
+		goto out;
+
+	if (WARN_ON(!fsl_mc_dpmcp_isr.mc_io))
 		goto out;
 
 	/*
-	 * NOTE: We cannot invoke MC flib function here
+	 * Clear interrupt source at the MC:
+	 *
+	 * NOTE: We clear all DPMCP IRQ events, rather than calling
+	 * dpmcp_get_irq_status() here to save one trip to the MC
 	 */
+	error = dpmcp_clear_irq_status(fsl_mc_dpmcp_isr.mc_io,
+				       MC_CMD_FLAG_INTR_DIS | MC_CMD_FLAG_PRI,
+				       mc_io->dpmcp_isr_mc_handle,
+				       DPMCP_IRQ_INDEX, ~0x0U);
+	if (error < 0) {
+		dev_err(&dpmcp_dev->dev,
+			"dpmcp_clear_irq_status() failed: %d\n",
+			error);
+		goto out;
+	}
 
-	complete(&dpmcp_dev->mc_io->mc_command_done_completion);
+	complete(&mc_io->mc_command_done_completion);
 out:
 	return IRQ_HANDLED;
 }
@@ -231,6 +275,9 @@ int fsl_mc_io_setup_dpmcp_irq(struct fsl_mc_io *mc_io)
 	int error;
 	struct fsl_mc_device *dpmcp_dev = mc_io->dpmcp_dev;
 
+	if (WARN_ON(mc_io->flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL))
+		return -EINVAL;
+
 	if (WARN_ON(!dpmcp_dev))
 		return -EINVAL;
 
@@ -240,12 +287,34 @@ int fsl_mc_io_setup_dpmcp_irq(struct fsl_mc_io *mc_io)
 	if (WARN_ON(dpmcp_dev->obj_desc.irq_count != 1))
 		return -EINVAL;
 
-	if (WARN_ON(!dpmcp_dev->mc_io))
+	if (WARN_ON(dpmcp_dev->mc_io != mc_io))
+		return -EINVAL;
+
+	if (WARN_ON(mc_io == fsl_mc_dpmcp_isr.mc_io))
 		return -EINVAL;
 
+	if (WARN_ON(atomic_read(&fsl_mc_dpmcp_isr.dpmcp_count) < 0))
+		return -EINVAL;
+
+	if (atomic_add_return(1, &fsl_mc_dpmcp_isr.dpmcp_count) == 1) {
+		/*
+		 * Create mc_io to be used to send MC commands from
+		 * the DPMCP command completion ISR (i.e. to clear the
+		 * DPMCP interrupt)
+		 */
+		error = fsl_mc_portal_allocate(NULL,
+					       FSL_MC_IO_ATOMIC_CONTEXT_PORTAL,
+					       &fsl_mc_dpmcp_isr.mc_io);
+		if (error < 0)
+			goto error_dec_dpmcp_count;
+
+		pr_info("fsl-mc: Allocated dpmcp.%d to DPMCP command completion ISR\n",
+			fsl_mc_dpmcp_isr.mc_io->dpmcp_dev->obj_desc.id);
+	}
+
 	error = fsl_mc_allocate_irqs(dpmcp_dev);
 	if (error < 0)
-		return error;
+		goto error_dec_dpmcp_count;
 
 	error = disable_dpmcp_irq(dpmcp_dev);
 	if (error < 0)
@@ -255,18 +324,36 @@ int fsl_mc_io_setup_dpmcp_irq(struct fsl_mc_io *mc_io)
 	if (error < 0)
 		goto error_free_irqs;
 
-	error = enable_dpmcp_irq(dpmcp_dev);
+	error = dpmcp_open(fsl_mc_dpmcp_isr.mc_io,
+			   MC_CMD_FLAG_INTR_DIS,
+			   dpmcp_dev->obj_desc.id,
+			   &mc_io->dpmcp_isr_mc_handle);
 	if (error < 0)
 		goto error_unregister_irq_handler;
 
+	error = enable_dpmcp_irq(dpmcp_dev);
+	if (error < 0)
+		goto error_close_dpmcp;
+
 	mc_io->mc_command_done_irq_armed = true;
 	return 0;
 
+error_close_dpmcp:
+	(void)dpmcp_close(fsl_mc_dpmcp_isr.mc_io, 0,
+			  mc_io->dpmcp_isr_mc_handle);
+
 error_unregister_irq_handler:
 	unregister_dpmcp_irq_handler(dpmcp_dev);
 
 error_free_irqs:
 	fsl_mc_free_irqs(dpmcp_dev);
+
+error_dec_dpmcp_count:
+	if (atomic_sub_return(1, &fsl_mc_dpmcp_isr.dpmcp_count) == 0) {
+		fsl_mc_portal_free(fsl_mc_dpmcp_isr.mc_io);
+		fsl_mc_dpmcp_isr.mc_io = NULL;
+	}
+
 	return error;
 }
 EXPORT_SYMBOL_GPL(fsl_mc_io_setup_dpmcp_irq);
@@ -286,10 +373,17 @@ static void teardown_dpmcp_irq(struct fsl_mc_io *mc_io)
 	if (WARN_ON(!dpmcp_dev->irqs))
 		return;
 
+	if (WARN_ON(atomic_read(&fsl_mc_dpmcp_isr.dpmcp_count) <= 0))
+		return;
+
 	mc_io->mc_command_done_irq_armed = false;
 	(void)disable_dpmcp_irq(dpmcp_dev);
 	unregister_dpmcp_irq_handler(dpmcp_dev);
 	fsl_mc_free_irqs(dpmcp_dev);
+	if (atomic_sub_return(1, &fsl_mc_dpmcp_isr.dpmcp_count) == 0) {
+		fsl_mc_portal_free(fsl_mc_dpmcp_isr.mc_io);
+		fsl_mc_dpmcp_isr.mc_io = NULL;
+	}
 }
 
 /**
@@ -630,9 +724,12 @@ int mc_send_command(struct fsl_mc_io *mc_io, struct mc_command *cmd)
 {
 	int error;
 	enum mc_cmd_status status;
+	bool dpmcp_completion_intr_disabled =
+		(MC_CMD_HDR_READ_FLAGS(cmd->header) & MC_CMD_FLAG_INTR_DIS);
 
 	if (WARN_ON(in_irq() &&
-		!(MC_CMD_HDR_READ_FLAGS(cmd->header) & MC_CMD_FLAG_INTR_DIS)))
+		    (!dpmcp_completion_intr_disabled ||
+		    !(mc_io->flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL))))
 		return -EINVAL;
 
 	if (mc_io->flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL)
@@ -648,8 +745,7 @@ int mc_send_command(struct fsl_mc_io *mc_io, struct mc_command *cmd)
 	/*
 	 * Wait for response from the MC hardware:
 	 */
-	if (mc_io->mc_command_done_irq_armed &&
-	    !(MC_CMD_HDR_READ_FLAGS(cmd->header) & MC_CMD_FLAG_INTR_DIS))
+	if (mc_io->mc_command_done_irq_armed && !dpmcp_completion_intr_disabled)
 		error = mc_completion_wait(mc_io, cmd, &status);
 	else
 		error = mc_polling_wait(mc_io, cmd, &status);
diff --git a/drivers/staging/fsl-mc/include/mc-sys.h b/drivers/staging/fsl-mc/include/mc-sys.h
index fbf4b73..ce15c2d 100644
--- a/drivers/staging/fsl-mc/include/mc-sys.h
+++ b/drivers/staging/fsl-mc/include/mc-sys.h
@@ -63,10 +63,24 @@ struct mc_command;
  * is currently armed.
  * @mc_command_done_completion: Completion variable to be signaled when an MC
  * command sent to the MC fw is completed.
+ *
+ * Fields are only meaningful if the FSL_MC_IO_ATOMIC_CONTEXT_PORTAL flag is not
+ * set:
  * @mutex: Mutex to serialize mc_send_command() calls that use the same MC
  * portal, if the fsl_mc_io object was created with the
  * FSL_MC_IO_ATOMIC_CONTEXT_PORTAL flag off. mc_send_command() calls for this
  * fsl_mc_io object must be made only from non-atomic context.
+ * @mc_command_done_completion: Linux completion variable to be signaled
+ * when a DPMCP command completion interrupts is received.
+ * @mc_command_done_irq_armed: Boolean flag that indicates if interrupts have
+ * been successfully configured for the corresponding DPMCP object.
+ * @ dpmcp_isr_mc_handle: MC handle to be used to send the command to clear
+ * DPMCP command completion interrupts. (We need as separate MC handle that
+ * was opened using the portal that will be used to send the clear interrupt
+ * command).
+ *
+ * Fields are only meaningful if the FSL_MC_IO_ATOMIC_CONTEXT_PORTAL flag is
+ * set:
  * @spinlock: Spinlock to serialize mc_send_command() calls that use the same MC
  * portal, if the fsl_mc_io object was created with the
  * FSL_MC_IO_ATOMIC_CONTEXT_PORTAL flag on. mc_send_command() calls for this
@@ -88,6 +102,7 @@ struct fsl_mc_io {
 			struct mutex mutex; /* serializes mc_send_command() */
 			struct completion mc_command_done_completion;
 			bool mc_command_done_irq_armed;
+			uint16_t dpmcp_isr_mc_handle;
 		};
 
 		/*
-- 
1.7.5.4

