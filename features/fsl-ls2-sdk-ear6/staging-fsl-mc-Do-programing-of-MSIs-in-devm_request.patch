From 4dd15c2985ae2be3b6e8d7737356f55a4d04d86a Mon Sep 17 00:00:00 2001
From: Itai Katz <itai.katz@freescale.com>
Date: Wed, 24 Jun 2015 18:10:26 +0300
Subject: [PATCH 094/452] staging: fsl-mc: Do programing of MSIs in
 devm_request_threaded_irq()

With the new dprc_set_obj_irq() we can now program MSIS in the device
in the callback invoked from devm_request_threaded_irq().
Since this callback is invoked with interrupts disabled, we need to
use an atomic portal, instead of the root DPRC's built-in portal
which is non-atomic.

Signed-off-by: Itai Katz <itai.katz@freescale.com>
Signed-off-by: J. German Rivera <German.Rivera@freescale.com>
[Stuart: split out dpaa-eth, dpmac, and dpio updates]
Signed-off-by: Stuart Yoder <stuart.yoder@freescale.com>
[Xulin: Original patch taken from FSL LS2085 SDK EAR6.0,
LS2085A-SDK-SOURCE-20160304-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/staging/fsl-mc/bus/dprc-driver.c    |   76 ++++++++++++++++-----------
 drivers/staging/fsl-mc/bus/mc-bus.c         |   61 ++++++++++++++++++++--
 drivers/staging/fsl-mc/bus/mc-sys.c         |   32 ++++-------
 drivers/staging/fsl-mc/include/mc-private.h |    5 ++
 4 files changed, 118 insertions(+), 56 deletions(-)

diff --git a/drivers/staging/fsl-mc/bus/dprc-driver.c b/drivers/staging/fsl-mc/bus/dprc-driver.c
index 4fdce28..1a5eeaf 100644
--- a/drivers/staging/fsl-mc/bus/dprc-driver.c
+++ b/drivers/staging/fsl-mc/bus/dprc-driver.c
@@ -559,7 +559,6 @@ static int register_dprc_irq_handlers(struct fsl_mc_device *mc_dev)
 	struct fsl_mc_device_irq *irq;
 	unsigned int num_irq_handlers_registered = 0;
 	int irq_count = mc_dev->obj_desc.irq_count;
-	struct dprc_irq_cfg irq_cfg;
 
 	if (WARN_ON(irq_count != ARRAY_SIZE(irq_handlers)))
 		return -EINVAL;
@@ -567,20 +566,9 @@ static int register_dprc_irq_handlers(struct fsl_mc_device *mc_dev)
 	for (i = 0; i < ARRAY_SIZE(irq_handlers); i++) {
 		irq = mc_dev->irqs[i];
 
-		if (WARN_ON(irq->dev_irq_index != i)) {
-			error = -EINVAL;
-			goto error_unregister_irq_handlers;
-		}
-
 		/*
-		 * NOTE: Normally, devm_request_threaded_irq() programs the MSI
-		 * physically in the device (by invoking a device-specific
-		 * callback). However, for MC IRQs, we have to program the MSI
-		 * outside of this callback, because this callback is invoked
-		 * with interrupts disabled, and we don't have a reliable
-		 * way of sending commands to the MC from atomic context.
-		 * The MC callback just set the msi_paddr and msi_value
-		 * fields of the irq structure.
+		 * NOTE: devm_request_threaded_irq() invokes the device-specific
+		 * function that programs the MSI physically in the device
 		 */
 		error = devm_request_threaded_irq(&mc_dev->dev,
 						  irq->irq_number,
@@ -599,20 +587,6 @@ static int register_dprc_irq_handlers(struct fsl_mc_device *mc_dev)
 		}
 
 		num_irq_handlers_registered++;
-		irq_cfg.paddr = irq->msi_paddr;
-		irq_cfg.val = irq->msi_value;
-		irq_cfg.user_irq_id = irq->irq_number;
-		error = dprc_set_irq(mc_dev->mc_io,
-				     0,
-				     mc_dev->mc_handle,
-				     i,
-				     &irq_cfg);
-		if (error < 0) {
-			dev_err(&mc_dev->dev,
-				"dprc_set_irq() failed for IRQ %u: %d\n",
-				i, error);
-			goto error_unregister_irq_handlers;
-		}
 	}
 
 	return 0;
@@ -905,6 +879,31 @@ static int dprc_probe(struct fsl_mc_device *mc_dev)
 		}
 
 		/*
+		 * Allocate MC portal to be used in atomic context
+		 * (e.g., to program MSIs from program_msi_at_mc())
+		 */
+		error = fsl_mc_portal_allocate(NULL,
+					       FSL_MC_IO_ATOMIC_CONTEXT_PORTAL,
+					       &mc_bus->atomic_mc_io);
+		if (error < 0)
+			goto error_cleanup_dprc_scan;
+
+		pr_info("fsl-mc: Allocated dpmcp.%d to dprc.%d for atomic MC I/O\n",
+			mc_bus->atomic_mc_io->dpmcp_dev->obj_desc.id,
+			mc_dev->obj_desc.id);
+
+		/*
+		 * Open DPRC handle to be used with mc_bus->atomic_mc_io:
+		 */
+		error = dprc_open(mc_bus->atomic_mc_io, 0, mc_dev->obj_desc.id,
+				  &mc_bus->atomic_dprc_handle);
+		if (error < 0) {
+			dev_err(&mc_dev->dev, "dprc_open() failed: %d\n",
+				error);
+			goto error_cleanup_atomic_mc_io;
+		}
+
+		/*
 		 * Configure interrupt for the DPMCP object associated with the
 		 * DPRC object's built-in portal:
 		 *
@@ -914,7 +913,7 @@ static int dprc_probe(struct fsl_mc_device *mc_dev)
 		 */
 		error = fsl_mc_io_setup_dpmcp_irq(mc_dev->mc_io);
 		if (error < 0)
-			goto error_cleanup_dprc_scan;
+			goto error_cleanup_atomic_dprc_handle;
 
 		/*
 		 * Configure interrupts for the DPRC object associated with
@@ -922,12 +921,18 @@ static int dprc_probe(struct fsl_mc_device *mc_dev)
 		 */
 		error = dprc_setup_irqs(mc_dev);
 		if (error < 0)
-			goto error_cleanup_dprc_scan;
+			goto error_cleanup_atomic_dprc_handle;
 	}
 
 	dev_info(&mc_dev->dev, "DPRC device bound to driver");
 	return 0;
 
+error_cleanup_atomic_dprc_handle:
+	(void)dprc_close(mc_bus->atomic_mc_io, 0, mc_bus->atomic_dprc_handle);
+
+error_cleanup_atomic_mc_io:
+	fsl_mc_portal_free(mc_bus->atomic_mc_io);
+
 error_cleanup_dprc_scan:
 	fsl_mc_io_unset_dpmcp(mc_dev->mc_io);
 	device_for_each_child(&mc_dev->dev, NULL, __fsl_mc_device_remove);
@@ -986,8 +991,17 @@ static int dprc_remove(struct fsl_mc_device *mc_dev)
 	if (WARN_ON(!mc_bus->irq_resources))
 		return -EINVAL;
 
-	if (fsl_mc_interrupts_supported())
+	if (fsl_mc_interrupts_supported()) {
 		dprc_teardown_irqs(mc_dev);
+		error = dprc_close(mc_bus->atomic_mc_io, 0,
+				   mc_bus->atomic_dprc_handle);
+		if (error < 0) {
+			dev_err(&mc_dev->dev, "dprc_close() failed: %d\n",
+				error);
+		}
+
+		fsl_mc_portal_free(mc_bus->atomic_mc_io);
+	}
 
 	fsl_mc_io_unset_dpmcp(mc_dev->mc_io);
 	device_for_each_child(&mc_dev->dev, NULL, __fsl_mc_device_remove);
diff --git a/drivers/staging/fsl-mc/bus/mc-bus.c b/drivers/staging/fsl-mc/bus/mc-bus.c
index a4c8cf9..ffef959 100644
--- a/drivers/staging/fsl-mc/bus/mc-bus.c
+++ b/drivers/staging/fsl-mc/bus/mc-bus.c
@@ -666,6 +666,61 @@ static void mc_bus_unmask_msi_irq(struct irq_data *d)
 	irq_chip_unmask_parent(d);
 }
 
+static void program_msi_at_mc(struct fsl_mc_device *mc_bus_dev,
+			      struct fsl_mc_device_irq *irq)
+{
+	int error;
+	struct fsl_mc_device *owner_mc_dev = irq->mc_dev;
+	struct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);
+	struct dprc_irq_cfg irq_cfg;
+
+	if (WARN_ON(!owner_mc_dev))
+		return;
+
+	if (owner_mc_dev == mc_bus_dev) {
+		/*
+		 * IRQ is for the mc_bus_dev's DPRC itself
+		 */
+		irq_cfg.paddr = irq->msi_paddr;
+		irq_cfg.val = irq->msi_value;
+		irq_cfg.user_irq_id = irq->irq_number;
+
+		/*
+		 * TODO: Add the MC_CMD_FLAG_PRI flag below when
+		 * a fix for CR:ENGR00361583 becomes available
+		 */
+		error = dprc_set_irq(mc_bus->atomic_mc_io,
+				     MC_CMD_FLAG_INTR_DIS,
+				     mc_bus->atomic_dprc_handle,
+				     irq->dev_irq_index,
+				     &irq_cfg);
+		if (error < 0) {
+			dev_err(&owner_mc_dev->dev,
+				"dprc_set_irq() failed: %d\n", error);
+		}
+	} else {
+		irq_cfg.paddr = irq->msi_paddr;
+		irq_cfg.val = irq->msi_value;
+		irq_cfg.user_irq_id = irq->irq_number;
+
+		/*
+		 * TODO: Add the MC_CMD_FLAG_PRI flag below when
+		 * a fix for CR:ENGR00361583 becomes available
+		 */
+		error = dprc_set_obj_irq(mc_bus->atomic_mc_io,
+					 MC_CMD_FLAG_INTR_DIS,
+					 mc_bus->atomic_dprc_handle,
+					 owner_mc_dev->obj_desc.type,
+					 owner_mc_dev->obj_desc.id,
+					 irq->dev_irq_index,
+					 &irq_cfg);
+		if (error < 0) {
+			dev_err(&owner_mc_dev->dev,
+				"dprc_obj_set_irq() failed: %d\n", error);
+		}
+	}
+}
+
 /*
  * This function is invoked from devm_request_irq(),
  * devm_request_threaded_irq(), dev_free_irq()
@@ -690,11 +745,9 @@ static void mc_bus_msi_domain_write_msg(struct irq_data *irq_data,
 		irq_res->msi_value = msg->data;
 
 		/*
-		 * NOTE: We cannot do the actual programming of the MSI
-		 * in the MC, as this function is invoked in atomic context
-		 * (interrupts disabled) and we cannot reliably send MC commands
-		 * in atomic context.
+		 * Program the MSI (paddr, value) pair in the device:
 		 */
+		program_msi_at_mc(mc_bus_dev, irq_res);
 	}
 }
 
diff --git a/drivers/staging/fsl-mc/bus/mc-sys.c b/drivers/staging/fsl-mc/bus/mc-sys.c
index 8c4c993..df40b55 100644
--- a/drivers/staging/fsl-mc/bus/mc-sys.c
+++ b/drivers/staging/fsl-mc/bus/mc-sys.c
@@ -193,7 +193,6 @@ static int register_dpmcp_irq_handler(struct fsl_mc_device *dpmcp_dev)
 {
 	int error;
 	struct fsl_mc_device_irq *irq = dpmcp_dev->irqs[DPMCP_IRQ_INDEX];
-	struct dpmcp_irq_cfg irq_cfg;
 
 	error = devm_request_irq(&dpmcp_dev->dev,
 				 irq->irq_number,
@@ -208,26 +207,7 @@ static int register_dpmcp_irq_handler(struct fsl_mc_device *dpmcp_dev)
 		return error;
 	}
 
-	irq_cfg.paddr = irq->msi_paddr;
-	irq_cfg.val = irq->msi_value;
-	irq_cfg.user_irq_id = irq->irq_number;
-
-	error = dpmcp_set_irq(dpmcp_dev->mc_io,
-			      MC_CMD_FLAG_INTR_DIS,
-			      dpmcp_dev->mc_handle,
-			      DPMCP_IRQ_INDEX,
-			      &irq_cfg);
-	if (error < 0) {
-		dev_err(&dpmcp_dev->dev,
-			"dpmcp_set_irq() failed: %d\n", error);
-		goto error_unregister_irq_handler;
-	}
-
 	return 0;
-
-error_unregister_irq_handler:
-	devm_free_irq(&dpmcp_dev->dev, irq->irq_number, &dpmcp_dev->dev);
-	return error;
 }
 
 static int enable_dpmcp_irq(struct fsl_mc_device *dpmcp_dev)
@@ -339,7 +319,8 @@ int fsl_mc_io_setup_dpmcp_irq(struct fsl_mc_io *mc_io)
 	return 0;
 
 error_close_dpmcp:
-	(void)dpmcp_close(fsl_mc_dpmcp_isr.mc_io, 0,
+	(void)dpmcp_close(fsl_mc_dpmcp_isr.mc_io,
+			  MC_CMD_FLAG_INTR_DIS,
 			  mc_io->dpmcp_isr_mc_handle);
 
 error_unregister_irq_handler:
@@ -364,6 +345,7 @@ EXPORT_SYMBOL_GPL(fsl_mc_io_setup_dpmcp_irq);
  */
 static void teardown_dpmcp_irq(struct fsl_mc_io *mc_io)
 {
+	int error;
 	struct fsl_mc_device *dpmcp_dev = mc_io->dpmcp_dev;
 
 	if (WARN_ON(!dpmcp_dev))
@@ -380,6 +362,14 @@ static void teardown_dpmcp_irq(struct fsl_mc_io *mc_io)
 	(void)disable_dpmcp_irq(dpmcp_dev);
 	unregister_dpmcp_irq_handler(dpmcp_dev);
 	fsl_mc_free_irqs(dpmcp_dev);
+	error = dpmcp_close(fsl_mc_dpmcp_isr.mc_io,
+			    MC_CMD_FLAG_INTR_DIS,
+			    mc_io->dpmcp_isr_mc_handle);
+	if (error < 0) {
+		dev_err(&dpmcp_dev->dev,
+			"dpmcp_close(dpmcp_isr_mc_handle) failed: %d\n", error);
+	}
+
 	if (atomic_sub_return(1, &fsl_mc_dpmcp_isr.dpmcp_count) == 0) {
 		fsl_mc_portal_free(fsl_mc_dpmcp_isr.mc_io);
 		fsl_mc_dpmcp_isr.mc_io = NULL;
diff --git a/drivers/staging/fsl-mc/include/mc-private.h b/drivers/staging/fsl-mc/include/mc-private.h
index 90b059a..53dae5c 100644
--- a/drivers/staging/fsl-mc/include/mc-private.h
+++ b/drivers/staging/fsl-mc/include/mc-private.h
@@ -109,6 +109,9 @@ struct fsl_mc_resource_pool {
  * @resource_pools: array of resource pools (one pool per resource type)
  * for this MC bus. These resources represent allocatable entities
  * from the physical DPRC.
+ * @atomic_mc_io: mc_io object to be used to send DPRC commands to the MC
+ * in atomic context (e.g., when programming MSIs in program_msi_at_mc()).
+ * @atomic_dprc_handle: DPRC handle opened using the atomic_mc_io's portal.
  * @irq_resources: Pointer to array of IRQ objects for the IRQ pool.
  * @scan_mutex: Serializes bus scanning
  * @dprc_attr: DPRC attributes
@@ -117,6 +120,8 @@ struct fsl_mc_bus {
 	struct fsl_mc_device mc_dev;
 	struct fsl_mc_resource_pool resource_pools[FSL_MC_NUM_POOL_TYPES];
 	struct fsl_mc_device_irq *irq_resources;
+	struct fsl_mc_io *atomic_mc_io;
+	uint16_t atomic_dprc_handle;
 	struct mutex scan_mutex;    /* serializes bus scanning */
 	struct dprc_attributes dprc_attr;
 };
-- 
1.7.5.4

