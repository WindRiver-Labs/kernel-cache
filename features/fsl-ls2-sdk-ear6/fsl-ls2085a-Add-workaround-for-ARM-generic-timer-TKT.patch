From b3714eae5ec52eed54883c465eeca0e29be701ee Mon Sep 17 00:00:00 2001
From: Priyanka Jain <Priyanka.Jain@freescale.com>
Date: Fri, 3 Jul 2015 16:09:45 +0530
Subject: [PATCH 007/452] fsl/ls2085a: Add workaround for ARM generic timer
 TKT269926 issue

This enables support for workaround for Freescale LS2085A SOC
open issue TKT269926. This issue is related to CNTP_TVAL register
not getting properly set leading to delay in timer interrupt
being generated. As a workaround software clears the CNTP_TVAL
register and then write again in case it finds mismatch between
value written and read.

Signed-off-by: Priyanka Jain <Priyanka.Jain@freescale.com>
[Xulin: Original patch taken from FSL LS2085 SDK EAR6.0,
LS2085A-SDK-SOURCE-20160304-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 arch/arm64/Kconfig                   |   11 +++++++++++
 drivers/clocksource/arm_arch_timer.c |   12 ++++++++++++
 2 files changed, 23 insertions(+), 0 deletions(-)

diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 069a009..4ba5161 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -196,9 +196,20 @@ config LS2085A_ERRATA_ERR008585
 	  If the value read differs, then re-read the register, and continue to
 	  read until two consecutive reads return the same value.
 
+config LS2085A_ERRATA_TKT269926
+	bool "Freescale LS2085A SOC issue TKT269926"
+	help
+	  This enables support for workaround for Freescale LS2085A SOC
+	  open issue TKT269926. This issue is related to CNTP_TVAL register
+	  not getting properly set leading to delay in timer interrupt
+	  being generated. As a workaround software clears the CNTP_TVAL
+	  register and then write again in case it finds mismatch between
+	  value written and read.
+
 config ARCH_FSL_LS2085A
 	bool "Freescale LS2085A SOC"
 	select LS2085A_ERRATA_ERR008585
+	select LS2085A_ERRATA_TKT269926
 	help
 	  This enables support for Freescale LS2085A SOC.
 
diff --git a/drivers/clocksource/arm_arch_timer.c b/drivers/clocksource/arm_arch_timer.c
index a3bb645..6315947 100644
--- a/drivers/clocksource/arm_arch_timer.c
+++ b/drivers/clocksource/arm_arch_timer.c
@@ -70,6 +70,8 @@ static struct clock_event_device __percpu *arch_timer_evt;
 static bool arch_timer_use_virtual = true;
 static bool arch_timer_c3stop;
 static bool arch_timer_mem_use_virtual;
+static __always_inline u32 arch_timer_reg_read(int access,
+		enum arch_timer_reg reg, struct clock_event_device *clk);
 
 /*
  * Architected system timer support.
@@ -79,6 +81,9 @@ static __always_inline
 void arch_timer_reg_write(int access, enum arch_timer_reg reg, u32 val,
 			  struct clock_event_device *clk)
 {
+#ifdef CONFIG_LS2085A_ERRATA_TKT269926
+	u32 val_read;
+#endif
 	if (access == ARCH_TIMER_MEM_PHYS_ACCESS) {
 		struct arch_timer *timer = to_arch_timer(clk);
 		switch (reg) {
@@ -101,6 +106,13 @@ void arch_timer_reg_write(int access, enum arch_timer_reg reg, u32 val,
 		}
 	} else {
 		arch_timer_reg_write_cp15(access, reg, val);
+#ifdef CONFIG_LS2085A_ERRATA_TKT269926
+		val_read = arch_timer_reg_read_cp15(access, reg);
+		if ((val & 0xffffff00) != (val_read & 0xffffff00)) {
+			arch_timer_reg_write_cp15(access, reg, 0x00000000);
+			arch_timer_reg_write_cp15(access, reg, val);
+		}
+#endif
 	}
 }
 
-- 
1.7.5.4

