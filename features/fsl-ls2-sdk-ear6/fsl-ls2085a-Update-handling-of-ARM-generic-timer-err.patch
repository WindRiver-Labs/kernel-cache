From 5939c3fd97d0828e0c2e2f6391cbdffa9f564955 Mon Sep 17 00:00:00 2001
From: Priyanka Jain <Priyanka.Jain@freescale.com>
Date: Fri, 26 Jun 2015 15:11:19 +0530
Subject: [PATCH 006/452] fsl,ls2085a:Update handling of ARM generic timer
 errata ERR008585

LS2 Errata ERR008585 Workaround says
--------------------------------------
Use ARM Generic Timer and ignore spurious interrupts. Any time in
software reading registers CNTHP_TVAL, CNTP_TVAL, CNTPS_TVAL, CNTV_TVAL,
CNTPCT, or CNTVCT), have software read the register twice. If the
value read differs, then re-read the register, and continue to read
until two consecutive reads return the same value.

This patch
------------
-adds errata workaround in vdso/gettimeofday.S driver.
-Update current workaround implementation
	In current implementation, there can be some delay in
	between two reads. Update the implementation to have
	immediate consecutive reads to avoid extra delay.

Signed-off-by: Priyanka Jain <Priyanka.Jain@freescale.com>
Signed-off-by: Bogdan Purcareata <bogdan.purcareata@freescale.com>
Change-Id: I26a4f805716f64a56490a6b0bd7baa78cea876ef
Reviewed-on: http://git.am.freescale.net:8181/38772
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
[Xulin: Original patch taken from FSL LS2085 SDK EAR6.0,
LS2085A-SDK-SOURCE-20160304-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 arch/arm64/include/asm/arch_timer.h   |   25 +++++++++++++++++++++++++
 arch/arm64/kernel/vdso/gettimeofday.S |   12 +++++++++++-
 drivers/clocksource/arm_arch_timer.c  |   13 ++-----------
 3 files changed, 38 insertions(+), 12 deletions(-)

diff --git a/arch/arm64/include/asm/arch_timer.h b/arch/arm64/include/asm/arch_timer.h
index 2ba4007..099165a 100644
--- a/arch/arm64/include/asm/arch_timer.h
+++ b/arch/arm64/include/asm/arch_timer.h
@@ -62,6 +62,9 @@ static __always_inline
 u32 arch_timer_reg_read_cp15(int access, enum arch_timer_reg reg)
 {
 	u32 val;
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+	u64 val_new, timeout = 200;
+#endif
 
 	if (access == ARCH_TIMER_PHYS_ACCESS) {
 		switch (reg) {
@@ -70,6 +73,17 @@ u32 arch_timer_reg_read_cp15(int access, enum arch_timer_reg reg)
 			break;
 		case ARCH_TIMER_REG_TVAL:
 			asm volatile("mrs %0, cntp_tval_el0" : "=r" (val));
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+			asm volatile("mrs %0, cntp_tval_el0" : "=r" (val_new));
+			while (val != val_new && timeout) {
+				asm volatile("mrs %0, cntp_tval_el0" \
+					     : "=r" (val));
+				asm volatile("mrs %0, cntp_tval_el0" \
+					     : "=r" (val_new));
+				timeout--;
+			}
+			BUG_ON((timeout <= 0) && (val != val_new));
+#endif
 			break;
 		}
 	} else if (access == ARCH_TIMER_VIRT_ACCESS) {
@@ -79,6 +93,17 @@ u32 arch_timer_reg_read_cp15(int access, enum arch_timer_reg reg)
 			break;
 		case ARCH_TIMER_REG_TVAL:
 			asm volatile("mrs %0, cntv_tval_el0" : "=r" (val));
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+			asm volatile("mrs %0, cntv_tval_el0" : "=r" (val_new));
+			while (val != val_new && timeout) {
+				asm volatile("mrs %0, cntv_tval_el0" \
+					     : "=r" (val));
+				asm volatile("mrs %0, cntv_tval_el0" \
+					     : "=r" (val_new));
+				timeout--;
+			}
+			BUG_ON((timeout <= 0) && (val != val_new));
+#endif
 			break;
 		}
 	}
diff --git a/arch/arm64/kernel/vdso/gettimeofday.S b/arch/arm64/kernel/vdso/gettimeofday.S
index efa79e8..525ed61 100644
--- a/arch/arm64/kernel/vdso/gettimeofday.S
+++ b/arch/arm64/kernel/vdso/gettimeofday.S
@@ -224,7 +224,17 @@ ENTRY(__do_get_tspec)
 
 	/* Read the virtual counter. */
 	isb
-	mrs	x15, cntvct_el0
+1:	mrs	x15, cntvct_el0
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+	/*
+	 * ERR008585 workaround says to read register twice till
+	 * two conecutive read return same value
+	 * TODO: Add check for maximum number of read.
+	 */
+	mrs	x16, cntvct_el0
+	cmp	x16, x15
+	b.ne	1b
+#endif
 
 	/* Calculate cycle delta and convert to ns. */
 	sub	x10, x15, x10
diff --git a/drivers/clocksource/arm_arch_timer.c b/drivers/clocksource/arm_arch_timer.c
index 1f0238e..a3bb645 100644
--- a/drivers/clocksource/arm_arch_timer.c
+++ b/drivers/clocksource/arm_arch_timer.c
@@ -125,7 +125,7 @@ u32 arch_timer_reg_read(int access, enum arch_timer_reg reg,
 #ifdef CONFIG_LS2085A_ERRATA_ERR008585
 			val_new = readl_relaxed(timer->base + CNTP_TVAL);
 			while (val != val_new && timeout) {
-				val = val_new;
+				val = readl_relaxed(timer->base + CNTP_TVAL);
 				val_new = readl_relaxed(timer->base +
 							CNTP_TVAL);
 				timeout--;
@@ -146,7 +146,7 @@ u32 arch_timer_reg_read(int access, enum arch_timer_reg reg,
 #ifdef CONFIG_LS2085A_ERRATA_ERR008585
 			val_new = readl_relaxed(timer->base + CNTV_TVAL);
 			while (val != val_new && timeout) {
-				val = val_new;
+				val = readl_relaxed(timer->base + CNTV_TVAL);
 				val_new = readl_relaxed(timer->base +
 							CNTV_TVAL);
 				timeout--;
@@ -158,15 +158,6 @@ u32 arch_timer_reg_read(int access, enum arch_timer_reg reg,
 		}
 	} else {
 		val = arch_timer_reg_read_cp15(access, reg);
-#ifdef CONFIG_LS2085A_ERRATA_ERR008585
-		val_new = arch_timer_reg_read_cp15(access, reg);
-		while (val != val_new && timeout) {
-			val = val_new;
-			val_new = arch_timer_reg_read_cp15(access, reg);
-			timeout--;
-		}
-		BUG_ON((timeout <= 0) && (val != val_new));
-#endif
 	}
 
 	return val;
-- 
1.7.5.4

