From 0243c69bfb083be205c715f175084cfc09fa7e8a Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Thu, 23 Apr 2015 16:11:04 +0300
Subject: [PATCH 139/452] dpaa2-eth: Selectively disable preemption

Temporary workaround for a MC Bus API quirk which only allows us to
specify exclusively, either a spinlock-protected MC Portal, or a
mutex-protected one, but then tries to match the runtime context in
order to enforce their usage.

Te Be Reverted.

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Change-Id: Ida2ec1fdbdebfd2e427f96ddad7582880146fda9
Reviewed-on: http://git.am.freescale.net:8181/35580
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
[Xulin: Original patch taken from FSL LS2085 SDK EAR6.0,
LS2085A-SDK-SOURCE-20160304-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/staging/fsl-dpaa2/ethernet/ldpaa_eth.c     |   32 +++++++++++++++++++-
 drivers/staging/fsl-dpaa2/ethernet/ldpaa_eth.h     |    4 ++
 drivers/staging/fsl-dpaa2/ethernet/ldpaa_ethtool.c |    6 ++++
 3 files changed, 41 insertions(+), 1 deletions(-)

diff --git a/drivers/staging/fsl-dpaa2/ethernet/ldpaa_eth.c b/drivers/staging/fsl-dpaa2/ethernet/ldpaa_eth.c
index a3e5b84..73f27b5 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/ldpaa_eth.c
+++ b/drivers/staging/fsl-dpaa2/ethernet/ldpaa_eth.c
@@ -797,7 +797,13 @@ static int __cold ldpaa_eth_open(struct net_device *net_dev)
 	 */
 	netif_tx_stop_all_queues(net_dev);
 
+#ifdef DPAA2_ETH_ATOMIC_PORTAL_HACK
+	preempt_disable();
+#endif
 	err = dpni_enable(priv->mc_io, priv->mc_token);
+#ifdef DPAA2_ETH_ATOMIC_PORTAL_HACK
+	preempt_enable();
+#endif
 	if (err < 0) {
 		dev_err(net_dev->dev.parent, "dpni_enable() failed\n");
 		return err;
@@ -814,7 +820,13 @@ static int __cold ldpaa_eth_stop(struct net_device *net_dev)
 
 	/* Stop Tx and Rx traffic */
 	netif_tx_stop_all_queues(net_dev);
+#ifdef DPAA2_ETH_ATOMIC_PORTAL_HACK
+	preempt_disable();
+#endif
 	dpni_disable(priv->mc_io, priv->mc_token);
+#ifdef DPAA2_ETH_ATOMIC_PORTAL_HACK
+	preempt_enable();
+#endif
 
 	/* TODO: Make sure queues are drained before if down is complete! */
 	msleep(100);
@@ -1791,6 +1803,9 @@ static irqreturn_t dpni_irq0_handler_thread(int irq_num, void *arg)
 	if (WARN_ON(dpni_dev->irqs[irq_index]->irq_number != irq_num))
 		goto out;
 
+#ifdef DPAA2_ETH_ATOMIC_PORTAL_HACK
+	preempt_disable();
+#endif
 	err = dpni_get_irq_status(io, token, irq_index, &status);
 	if (unlikely(err)) {
 		netdev_err(net_dev, "Can't get irq status (err %d)", err);
@@ -1820,6 +1835,9 @@ static irqreturn_t dpni_irq0_handler_thread(int irq_num, void *arg)
 
 out:
 	dpni_clear_irq_status(io, token, irq_index, clear);
+#ifdef DPAA2_ETH_ATOMIC_PORTAL_HACK
+	preempt_enable();
+#endif
 	return IRQ_HANDLED;
 }
 
@@ -1836,11 +1854,18 @@ static int ldpaa_eth_setup_irqs(struct fsl_mc_device *ls_dev)
 		return -EINVAL;
 
 	irq = ls_dev->irqs[0];
+#ifdef DPAA2_ETH_ATOMIC_PORTAL_HACK
+	preempt_enable();
+#endif
 	err = devm_request_threaded_irq(&ls_dev->dev, irq->irq_number,
 					dpni_irq0_handler,
 					dpni_irq0_handler_thread,
 					IRQF_NO_SUSPEND | IRQF_ONESHOT,
 					dev_name(&ls_dev->dev), &ls_dev->dev);
+#ifdef DPAA2_ETH_ATOMIC_PORTAL_HACK
+	/* Yes, I know error paths are not covered. */
+	preempt_disable();
+#endif
 	if (err < 0) {
 		dev_err(&ls_dev->dev, "devm_request_threaded_irq(): %d", err);
 		return err;
@@ -1946,7 +1971,9 @@ ldpaa_eth_probe(struct fsl_mc_device *dpni_dev)
 	if (err < 0)
 		/* FIXME: add error label */
 		return -EINVAL;
-
+#ifdef DPAA2_ETH_ATOMIC_PORTAL_HACK
+	preempt_disable();
+#endif
 	/* DPNI initialization */
 	err = ldpaa_dpni_setup(dpni_dev);
 	if (err < 0)
@@ -2040,6 +2067,9 @@ ldpaa_eth_probe(struct fsl_mc_device *dpni_dev)
 		goto err_setup_irqs;
 	}
 
+#ifdef DPAA2_ETH_ATOMIC_PORTAL_HACK
+	preempt_enable();
+#endif
 	dev_info(dev, "ldpaa ethernet: Probed interface %s\n", net_dev->name);
 	return 0;
 
diff --git a/drivers/staging/fsl-dpaa2/ethernet/ldpaa_eth.h b/drivers/staging/fsl-dpaa2/ethernet/ldpaa_eth.h
index ebf96fb..850d221 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/ldpaa_eth.h
+++ b/drivers/staging/fsl-dpaa2/ethernet/ldpaa_eth.h
@@ -41,6 +41,10 @@
 #include "../../fsl-mc/include/dpni-cmd.h"
 
 #include "ldpaa_eth_trace.h"
+/* FIXME HACK! */
+#ifndef DPAA2_ETH_ATOMIC_PORTAL_HACK
+#define DPAA2_ETH_ATOMIC_PORTAL_HACK
+#endif
 
 /* TODO : how many queues here? NR_CPUS? */
 #define LDPAA_ETH_TX_QUEUES		1
diff --git a/drivers/staging/fsl-dpaa2/ethernet/ldpaa_ethtool.c b/drivers/staging/fsl-dpaa2/ethernet/ldpaa_ethtool.c
index ac1941a..8061ead 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/ldpaa_ethtool.c
+++ b/drivers/staging/fsl-dpaa2/ethernet/ldpaa_ethtool.c
@@ -198,8 +198,14 @@ static void ldpaa_get_ethtool_stats(struct net_device *net_dev,
 
 	/* Print standard counters, from DPNI statistics */
 	for (i = 0; i < DPNI_CNT_NUM_STATS; i++) {
+#ifdef DPAA2_ETH_ATOMIC_PORTAL_HACK
+		preempt_disable();
+#endif
 		err = dpni_get_counter(priv->mc_io, priv->mc_token, i,
 				       data + i);
+#ifdef DPAA2_ETH_ATOMIC_PORTAL_HACK
+		preempt_enable();
+#endif
 		if (err != 0)
 			netdev_warn(net_dev, "Err %d getting DPNI counter %d",
 				    err, i);
-- 
1.7.5.4

