From 1534c8b344815cc9247d79209012d604c3253b68 Mon Sep 17 00:00:00 2001
From: "J. German Rivera" <German.Rivera@freescale.com>
Date: Tue, 28 Jul 2015 20:10:10 -0500
Subject: [PATCH 105/452] staging: fsl-mc: Fixed crash when tearing down MC
 MSIs

For MSIs, devm_free_irq()/free_irq() invoke the same callback as
devm_request_irq()/request_irq(), but passing 0x0 in irq->msi_paddr,
to "unprogram" the MSI in the device. However, for MC MSIs, we don't
really need to "unprogram" the MSI. So, now, when the MC bus callback
is invoked in the free_irq() code path, we don't call dprc_set_irq()/
dprc_set_obj_irq(). This helps avoid subtle ordering problems in the
MC bus IRQ teardown sequence.

Signed-off-by: J. German Rivera <German.Rivera@freescale.com>
[Stuart: added fixme comment in patch]
Signed-off-by: Stuart Yoder <stuart.yoder@freescale.com>
[Xulin: Original patch taken from FSL LS2085 SDK EAR6.0,
LS2085A-SDK-SOURCE-20160304-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/staging/fsl-mc/bus/mc-bus.c |   20 ++++++++++++--------
 1 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/drivers/staging/fsl-mc/bus/mc-bus.c b/drivers/staging/fsl-mc/bus/mc-bus.c
index 4147f36..52fdd59 100644
--- a/drivers/staging/fsl-mc/bus/mc-bus.c
+++ b/drivers/staging/fsl-mc/bus/mc-bus.c
@@ -670,6 +670,18 @@ static void program_msi_at_mc(struct fsl_mc_device *mc_bus_dev,
 	struct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);
 	struct dprc_irq_cfg irq_cfg;
 
+	/*
+	 * irq->msi_paddr is 0x0 when this function is invoked in the
+	 * free_irq() code path. In this case, for the MC, we don't
+	 * really need to "unprogram" the MSI, so we just return.
+	 * This helps avoid subtle ordering problems in the MC
+	 * bus IRQ teardown logic.
+	 * FIXME: evaluate whether there is a better way to address
+	 * the underlying issue (upstreamability concern)
+	 */
+	if (irq->msi_paddr == 0x0)
+		return;
+
 	if (WARN_ON(!owner_mc_dev))
 		return;
 
@@ -691,14 +703,6 @@ static void program_msi_at_mc(struct fsl_mc_device *mc_bus_dev,
 				"dprc_set_irq() failed: %d\n", error);
 		}
 	} else {
-		/* FIXME: We have only one DPIO register, we should set
-		 * MSI address = 0 only when no DPIO uses MSI interrupt.
-		 * Below is just a workaround, where we never set 0
-		 * MSI address */
-		if (irq_cfg.paddr == 0x0 &&
-		    (strncmp("dpio", owner_mc_dev->obj_desc.type, 4) == 0))
-			return;
-
 		error = dprc_set_obj_irq(mc_bus->atomic_mc_io,
 					 MC_CMD_FLAG_INTR_DIS | MC_CMD_FLAG_PRI,
 					 mc_bus->atomic_dprc_handle,
-- 
1.7.5.4

