From 0f84774a539e6faae212dc0a7ca526bf57ce5f65 Mon Sep 17 00:00:00 2001
From: Haikun Wang <Haikun.Wang@freescale.com>
Date: Fri, 29 May 2015 03:30:14 +0800
Subject: [PATCH 052/452] spi: fsl_dspi: use one CTAR between different CS
 slaves

Every DSPI slave device using a unique CTAR register now.
DSPI works correctlly in this mode because DSPI only has one slave
device and it has more than one CTAR registers usually.
So there is no conflict.
There are three DSPI slaves and DSPI controller only has two CTAR
registers on LS2085AQDS board.
So slave device in CS2 can't be accessed.
This patch fix this problem.
All slave devices using the same CTAR0 register.

Signed-off-by: Haikun Wang <B53464@freescale.com>
Change-Id: Ia1b899040aaa0703d8b5f475ebbbd792c3154e00
Reviewed-on: http://git.am.freescale.net:8181/37033
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
[Xulin: Original patch taken from FSL LS2085 SDK EAR6.0,
LS2085A-SDK-SOURCE-20160304-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/spi/spi-fsl-dspi.c |   14 +++++++-------
 1 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/drivers/spi/spi-fsl-dspi.c b/drivers/spi/spi-fsl-dspi.c
index 808e828..95d5a74 100644
--- a/drivers/spi/spi-fsl-dspi.c
+++ b/drivers/spi/spi-fsl-dspi.c
@@ -145,7 +145,7 @@ static inline int is_double_byte_mode(struct fsl_dspi *dspi)
 {
 	unsigned int val;
 
-	regmap_read(dspi->regmap, SPI_CTAR(dspi->cs), &val);
+	regmap_read(dspi->regmap, SPI_CTAR(0), &val);
 
 	return ((val & SPI_FRAME_BITS_MASK) == SPI_FRAME_BITS(8)) ? 0 : 1;
 }
@@ -235,7 +235,7 @@ static u32 dspi_data_to_pushr(struct fsl_dspi *dspi, int tx_word)
 
 	return	SPI_PUSHR_TXDATA(d16) |
 		SPI_PUSHR_PCS(dspi->cs) |
-		SPI_PUSHR_CTAS(dspi->cs) |
+		SPI_PUSHR_CTAS(0) |
 		SPI_PUSHR_CONT;
 }
 
@@ -269,7 +269,7 @@ static int dspi_eoq_write(struct fsl_dspi *dspi)
 		 */
 		if (tx_word && (dspi->len == 1)) {
 			dspi->dataflags |= TRAN_STATE_WORD_ODD_NUM;
-			regmap_update_bits(dspi->regmap, SPI_CTAR(dspi->cs),
+			regmap_update_bits(dspi->regmap, SPI_CTAR(0),
 					SPI_FRAME_BITS_MASK, SPI_FRAME_BITS(8));
 			tx_word = 0;
 		}
@@ -323,7 +323,7 @@ static int dspi_tcfq_write(struct fsl_dspi *dspi)
 
 	if (tx_word && (dspi->len == 1)) {
 		dspi->dataflags |= TRAN_STATE_WORD_ODD_NUM;
-		regmap_update_bits(dspi->regmap, SPI_CTAR(dspi->cs),
+		regmap_update_bits(dspi->regmap, SPI_CTAR(0),
 				SPI_FRAME_BITS_MASK, SPI_FRAME_BITS(8));
 		tx_word = 0;
 	}
@@ -386,10 +386,10 @@ static int dspi_transfer_one_message(struct spi_master *master,
 		regmap_update_bits(dspi->regmap, SPI_MCR,
 				SPI_MCR_CLR_TXF | SPI_MCR_CLR_RXF,
 				SPI_MCR_CLR_TXF | SPI_MCR_CLR_RXF);
-		regmap_write(dspi->regmap, SPI_CTAR(dspi->cs),
+		regmap_write(dspi->regmap, SPI_CTAR(0),
 				dspi->cur_chip->ctar_val);
 		if (transfer->speed_hz)
-			regmap_write(dspi->regmap, SPI_CTAR(dspi->cs),
+			regmap_write(dspi->regmap, SPI_CTAR(0),
 					dspi->cur_chip->ctar_val);
 
 		if (dspi->trans_mode == DSPI_EOQ_MODE) {
@@ -499,7 +499,7 @@ static irqreturn_t dspi_interrupt(int irq, void *dev_id)
 
 	if (!dspi->len) {
 		if (dspi->dataflags & TRAN_STATE_WORD_ODD_NUM) {
-			regmap_update_bits(dspi->regmap, SPI_CTAR(dspi->cs),
+			regmap_update_bits(dspi->regmap, SPI_CTAR(0),
 			SPI_FRAME_BITS_MASK, SPI_FRAME_BITS(16));
 			dspi->dataflags &= ~TRAN_STATE_WORD_ODD_NUM;
 		}
-- 
1.7.5.4

