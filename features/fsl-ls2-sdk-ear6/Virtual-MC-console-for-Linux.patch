From fce2d69043618b781ec4f372956a01803dfb4fda Mon Sep 17 00:00:00 2001
From: Stuart Yoder <stuart.yoder@freescale.com>
Date: Thu, 13 Aug 2015 16:31:20 -0500
Subject: [PATCH 056/452] Virtual MC console for Linux

Create a character device that makes the LS2 virtual console look
like a file.  This allows users to cat or tail /dev/fsl_mc_console
on systems that do not have an MC UART

Signed-off-by: Roy Pledge <Roy.Pledge@freescale.com>
Signed-off-by: Stuart Yoder <stuart.yoder@freescale.com>
[Xulin: Original patch taken from FSL LS2085 SDK EAR6.0,
LS2085A-SDK-SOURCE-20160304-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/soc/fsl/Kconfig.arm               |    1 +
 drivers/soc/fsl/Makefile                  |    2 +
 drivers/soc/fsl/ls2-console/Kconfig       |    4 +
 drivers/soc/fsl/ls2-console/Makefile      |    1 +
 drivers/soc/fsl/ls2-console/ls2-console.c |  130 +++++++++++++++++++++++++++++
 5 files changed, 138 insertions(+), 0 deletions(-)
 create mode 100644 drivers/soc/fsl/ls2-console/Kconfig
 create mode 100644 drivers/soc/fsl/ls2-console/Makefile
 create mode 100644 drivers/soc/fsl/ls2-console/ls2-console.c

diff --git a/drivers/soc/fsl/Kconfig.arm b/drivers/soc/fsl/Kconfig.arm
index 63bacdd..33ce70c 100644
--- a/drivers/soc/fsl/Kconfig.arm
+++ b/drivers/soc/fsl/Kconfig.arm
@@ -12,4 +12,5 @@ config	LS_SOC_DRIVERS
 
 if LS_SOC_DRIVERS
 	source "drivers/soc/fsl/ls/Kconfig"
+	source "drivers/soc/fsl/ls2-console/Kconfig"
 endif
diff --git a/drivers/soc/fsl/Makefile b/drivers/soc/fsl/Makefile
index 6ff660d..f8ae901 100644
--- a/drivers/soc/fsl/Makefile
+++ b/drivers/soc/fsl/Makefile
@@ -1,3 +1,5 @@
 #
 # Makefile for Freescale Soc specific device drivers.
 #
+
+obj-$(CONFIG_LS_SOC_DRIVERS) += ls2-console/
diff --git a/drivers/soc/fsl/ls2-console/Kconfig b/drivers/soc/fsl/ls2-console/Kconfig
new file mode 100644
index 0000000..00d815e
--- /dev/null
+++ b/drivers/soc/fsl/ls2-console/Kconfig
@@ -0,0 +1,4 @@
+config FSL_LS2_CONSOLE
+        bool "Layerscape MC and AIOP console support"
+	depends on SOC_LS1021A || ARCH_FSL_LS2085A
+        default y
diff --git a/drivers/soc/fsl/ls2-console/Makefile b/drivers/soc/fsl/ls2-console/Makefile
new file mode 100644
index 0000000..62b9634
--- /dev/null
+++ b/drivers/soc/fsl/ls2-console/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_FSL_LS2_CONSOLE) += ls2-console.o
diff --git a/drivers/soc/fsl/ls2-console/ls2-console.c b/drivers/soc/fsl/ls2-console/ls2-console.c
new file mode 100644
index 0000000..f2b6826
--- /dev/null
+++ b/drivers/soc/fsl/ls2-console/ls2-console.c
@@ -0,0 +1,130 @@
+#include <linux/miscdevice.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/compat.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+
+/* MC and IOP character device to read from RAM */
+
+#define MC_BASE_ADDR 0x83e0000000
+#define MC_BUFFER_SIZE (1024*1024*3)
+
+struct console_data {
+	char *start_addr; /* Start of buffer */
+	char *end_addr; /* End of buffer */
+	char *end_of_data; /* Current end of data */
+	char *last_to_console; /* Last data sent to console */
+};
+
+
+static int fsl_ls2_console_open(struct inode *node, struct file *fp)
+{
+	struct console_data *cd;
+
+	cd = kmalloc(sizeof(*cd), GFP_KERNEL);
+	if (cd == NULL)
+		return -ENOMEM;
+	fp->private_data = cd;
+	cd->start_addr = ioremap(MC_BASE_ADDR + 0x01000000, MC_BUFFER_SIZE);
+	cd->end_addr = cd->start_addr + MC_BUFFER_SIZE;
+	cd->end_of_data = cd->start_addr;
+	cd->last_to_console = cd->start_addr;
+	return 0;
+}
+
+static int fsl_ls2_console_close(struct inode *node, struct file *fp)
+{
+	struct console_data *cd = fp->private_data;
+
+	iounmap(cd->start_addr);
+	kfree(cd);
+	return 0;
+}
+
+static void adjust_end(struct console_data *cd)
+{
+	while (strncmp(cd->end_of_data, "END", 3) != 0) {
+		if (cd->end_of_data == cd->end_addr)
+			cd->end_of_data = cd->start_addr;
+		else
+			++cd->end_of_data;
+	}
+}
+
+/* Read one past the end of the buffer regardless of end */
+static char consume_next_char(struct console_data *cd)
+{
+	if (cd->last_to_console == cd->end_addr)
+		cd->last_to_console = cd->start_addr;
+	else
+		++cd->last_to_console;
+
+	return *(cd->last_to_console);
+}
+
+ssize_t fsl_ls2_console_read(struct file *fp, char __user *buf, size_t count,
+			     loff_t *f_pos)
+{
+	struct console_data *cd = fp->private_data;
+	size_t bytes = 0;
+	char data;
+
+	/* Check if we need to adjust the end of data addr */
+	adjust_end(cd);
+
+	while (count != bytes && ((cd->end_of_data-1) != cd->last_to_console)) {
+		data = consume_next_char(cd);
+		if (copy_to_user(&buf[bytes], &data, 1))
+			return -EFAULT;
+		++bytes;
+	}
+	return bytes;
+}
+
+
+static const struct file_operations fsl_ls2_console_fops = {
+	.owner          = THIS_MODULE,
+	.open           = fsl_ls2_console_open,
+	.release        = fsl_ls2_console_close,
+	.read           = fsl_ls2_console_read,
+};
+
+static struct miscdevice fsl_ls2_mc_console_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "fsl_mc_console",
+	.fops = &fsl_ls2_console_fops
+};
+
+static int __init fsl_ls2_console_init(void)
+{
+	int err = 0;
+
+	pr_info("Freescale LS2 console driver\n");
+	err = misc_register(&fsl_ls2_mc_console_dev);
+	if (err) {
+		pr_err("fsl_mc_console: cannot register device\n");
+		return err;
+	}
+	pr_info("fsl-ls2-console: device %s registered\n",
+		fsl_ls2_mc_console_dev.name);
+	return 0;
+}
+
+static void __exit fsl_ls2_console_exit(void)
+{
+	int err = misc_deregister(&fsl_ls2_mc_console_dev);
+
+	if (err)
+		pr_err("Failed to deregister device %s code %d\n",
+		       fsl_ls2_mc_console_dev.name, err);
+	pr_info("device %s deregistered\n", fsl_ls2_mc_console_dev.name);
+}
+
+module_init(fsl_ls2_console_init);
+module_exit(fsl_ls2_console_exit);
+
+MODULE_AUTHOR("Roy Pledge <roy.pledge@freescale.com>");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("Freescale LS2 console driver");
-- 
1.7.5.4

