From cb6d00d4e65e276bed59a2db655dbd9d929d3653 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Sun, 2 Sep 2012 12:33:09 -0700
Subject: [PATCH] Support for linux kernels 2.6.32 through 2.6.37

commit 3a523f5b6b4f8ca82412cb45f2d2ad9c44e7d249 lttng.org/lttng-modules.git

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Signed-off-by: Paul Barrette <paul.barrette@windriver.com>

diff --git a/drivers/staging/lttng/Makefile b/drivers/staging/lttng/Makefile
index 05e786b..939d258 100644
--- a/drivers/staging/lttng/Makefile
+++ b/drivers/staging/lttng/Makefile
@@ -29,7 +29,7 @@ endif
 ifneq ($(CONFIG_PERF_EVENTS),)
 lttng-tracer-objs += $(shell \
 	if [ $(VERSION) -ge 3 \
-		-o \( $(VERSION) -eq 2 -a $(PATCHLEVEL) -ge 6 -a $(SUBLEVEL) -ge 33 \) ] ; then \
+		-o \( $(VERSION) -eq 2 -a $(PATCHLEVEL) -ge 6 -a $(SUBLEVEL) -ge 34 \) ] ; then \
 		echo "lttng-context-perf-counters.o" ; fi;)
 endif
 
diff --git a/drivers/staging/lttng/README b/drivers/staging/lttng/README
index 9eccec7..1aeec6e 100644
--- a/drivers/staging/lttng/README
+++ b/drivers/staging/lttng/README
@@ -27,15 +27,16 @@ http://lttng.org/lttng2.0
 
 So far, it has been tested on vanilla Linux kernels 2.6.38, 2.6.39, 3.0,
 3.1, 3.2, 3.3 (on x86 32/64-bit, and powerpc 32-bit at the moment, build
-tested on ARM). It should work fine with newer kernels and other
-architectures, but expect build issues with kernels older than 2.6.36.
-The clock source currently used is the standard gettimeofday (slower,
-less scalable and less precise than the LTTng 0.x clocks).  Support for
-LTTng 0.x clocks will be added back soon into LTTng 2.0.  Please note
-that lttng-modules 2.0 can build on a Linux kernel patched with the
-LTTng 0.x patchset, but the lttng-modules 2.0 replace the lttng-modules
-0.x, so both tracers cannot be installed at the same time for a given
-kernel version.
+tested on ARM). Kernels 2.6.32 to 2.6.34 need up to 3 patches applied
+(refer to linux-patches within the lttng-modules tree). It should work
+fine with newer kernels and other architectures, but expect build issues
+with kernels older than 2.6.36.  The clock source currently used is the
+standard gettimeofday (slower, less scalable and less precise than the
+LTTng 0.x clocks).  Support for LTTng 0.x clocks will be added back soon
+into LTTng 2.0.  Please note that lttng-modules 2.0 can build on a Linux
+kernel patched with the LTTng 0.x patchset, but the lttng-modules 2.0
+replace the lttng-modules 0.x, so both tracers cannot be installed at
+the same time for a given kernel version.
 
 
 * Kernel config options required
diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/irq.h b/drivers/staging/lttng/instrumentation/events/lttng-module/irq.h
index 344015d..e766326 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/irq.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/irq.h
@@ -89,6 +89,7 @@ TRACE_EVENT(irq_handler_exit,
 		  __entry->irq, __entry->ret ? "handled" : "unhandled")
 )
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
 DECLARE_EVENT_CLASS(softirq,
 
 	TP_PROTO(unsigned int vec_nr),
@@ -148,6 +149,70 @@ DEFINE_EVENT(softirq, softirq_raise,
 
 	TP_ARGS(vec_nr)
 )
+#else /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
+DECLARE_EVENT_CLASS(softirq,
+
+	TP_PROTO(struct softirq_action *h, struct softirq_action *vec),
+
+	TP_ARGS(h, vec),
+
+	TP_STRUCT__entry(
+		__field(	unsigned int,	vec	)
+	),
+
+	TP_fast_assign(
+		tp_assign(vec, (int)(h - vec))
+	),
+
+	TP_printk("vec=%u [action=%s]", __entry->vec,
+		  show_softirq_name(__entry->vec))
+)
+
+/**
+ * softirq_entry - called immediately before the softirq handler
+ * @h: pointer to struct softirq_action
+ * @vec: pointer to first struct softirq_action in softirq_vec array
+ *
+ * When used in combination with the softirq_exit tracepoint
+ * we can determine the softirq handler runtine.
+ */
+DEFINE_EVENT(softirq, softirq_entry,
+
+	TP_PROTO(struct softirq_action *h, struct softirq_action *vec),
+
+	TP_ARGS(h, vec)
+)
+
+/**
+ * softirq_exit - called immediately after the softirq handler returns
+ * @h: pointer to struct softirq_action
+ * @vec: pointer to first struct softirq_action in softirq_vec array
+ *
+ * When used in combination with the softirq_entry tracepoint
+ * we can determine the softirq handler runtine.
+ */
+DEFINE_EVENT(softirq, softirq_exit,
+
+	TP_PROTO(struct softirq_action *h, struct softirq_action *vec),
+
+	TP_ARGS(h, vec)
+)
+
+/**
+ * softirq_raise - called immediately when a softirq is raised
+ * @h: pointer to struct softirq_action
+ * @vec: pointer to first struct softirq_action in softirq_vec array
+ *
+ * When used in combination with the softirq_entry tracepoint
+ * we can determine the softirq raise to run latency.
+ */
+DEFINE_EVENT(softirq, softirq_raise,
+
+	TP_PROTO(struct softirq_action *h, struct softirq_action *vec),
+
+	TP_ARGS(h, vec)
+)
+#endif /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
 
 #endif /*  _TRACE_IRQ_H */
 
diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/sched.h b/drivers/staging/lttng/instrumentation/events/lttng-module/sched.h
index 33f6921..b68616e 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/sched.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/sched.h
@@ -74,9 +74,15 @@ TRACE_EVENT(sched_kthread_stop_ret,
  */
 DECLARE_EVENT_CLASS(sched_wakeup_template,
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	TP_PROTO(struct task_struct *p, int success),
 
 	TP_ARGS(p, success),
+#else
+	TP_PROTO(struct rq *rq, struct task_struct *p, int success),
+
+	TP_ARGS(rq, p, success),
+#endif
 
 	TP_STRUCT__entry(
 		__array_text(	char,	comm,	TASK_COMM_LEN	)
@@ -99,6 +105,8 @@ DECLARE_EVENT_CLASS(sched_wakeup_template,
 		  __entry->success, __entry->target_cpu)
 )
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+
 DEFINE_EVENT(sched_wakeup_template, sched_wakeup,
 	     TP_PROTO(struct task_struct *p, int success),
 	     TP_ARGS(p, success))
@@ -110,15 +118,37 @@ DEFINE_EVENT(sched_wakeup_template, sched_wakeup_new,
 	     TP_PROTO(struct task_struct *p, int success),
 	     TP_ARGS(p, success))
 
+#else /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)) */
+
+DEFINE_EVENT(sched_wakeup_template, sched_wakeup,
+	     TP_PROTO(struct rq *rq, struct task_struct *p, int success),
+	     TP_ARGS(rq, p, success))
+
+/*
+ * Tracepoint for waking up a new task:
+ */
+DEFINE_EVENT(sched_wakeup_template, sched_wakeup_new,
+	     TP_PROTO(struct rq *rq, struct task_struct *p, int success),
+	     TP_ARGS(rq, p, success))
+
+#endif /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)) */
+
 /*
  * Tracepoint for task switches, performed by the scheduler:
  */
 TRACE_EVENT(sched_switch,
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	TP_PROTO(struct task_struct *prev,
 		 struct task_struct *next),
 
 	TP_ARGS(prev, next),
+#else /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)) */
+	TP_PROTO(struct rq *rq, struct task_struct *prev,
+		 struct task_struct *next),
+
+	TP_ARGS(rq, prev, next),
+#endif /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)) */
 
 	TP_STRUCT__entry(
 		__array_text(	char,	prev_comm,	TASK_COMM_LEN	)
@@ -220,9 +250,15 @@ DEFINE_EVENT(sched_process_template, sched_process_exit,
 /*
  * Tracepoint for waiting on task to unschedule:
  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 DEFINE_EVENT(sched_process_template, sched_wait_task,
 	TP_PROTO(struct task_struct *p),
 	TP_ARGS(p))
+#else /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)) */
+DEFINE_EVENT(sched_process_template, sched_wait_task,
+	TP_PROTO(struct rq *rq, struct task_struct *p),
+	TP_ARGS(rq, p))
+#endif /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)) */
 
 /*
  * Tracepoint for a waiting task:
diff --git a/drivers/staging/lttng/instrumentation/events/lttng-module/timer.h b/drivers/staging/lttng/instrumentation/events/lttng-module/timer.h
index fa89f66..dd27838 100644
--- a/drivers/staging/lttng/instrumentation/events/lttng-module/timer.h
+++ b/drivers/staging/lttng/instrumentation/events/lttng-module/timer.h
@@ -10,6 +10,9 @@
 #define _TRACE_TIMER_DEF_
 #include <linux/hrtimer.h>
 #include <linux/timer.h>
+
+struct timer_list;
+
 #endif /* _TRACE_TIMER_DEF_ */
 
 DECLARE_EVENT_CLASS(timer_class,
diff --git a/drivers/staging/lttng/lttng-events.c b/drivers/staging/lttng/lttng-events.c
index 76844de..5d06b101 100644
--- a/drivers/staging/lttng/lttng-events.c
+++ b/drivers/staging/lttng/lttng-events.c
@@ -30,6 +30,7 @@
 #include "wrapper/uuid.h"
 #include "wrapper/vmalloc.h"	/* for wrapper_vmalloc_sync_all() */
 #include "wrapper/random.h"
+#include "wrapper/tracepoint.h"
 #include "lttng-events.h"
 #include "lttng-tracer.h"
 
@@ -316,7 +317,7 @@ struct lttng_event *lttng_event_create(struct lttng_channel *chan,
 		event->desc = lttng_event_get(event_param->name);
 		if (!event->desc)
 			goto register_error;
-		ret = tracepoint_probe_register(event_param->name,
+		ret = kabi_2635_tracepoint_probe_register(event_param->name,
 				event->desc->probe_callback,
 				event);
 		if (ret)
@@ -420,7 +421,7 @@ int _lttng_event_unregister(struct lttng_event *event)
 
 	switch (event->instrumentation) {
 	case LTTNG_KERNEL_TRACEPOINT:
-		ret = tracepoint_probe_unregister(event->desc->name,
+		ret = kabi_2635_tracepoint_probe_unregister(event->desc->name,
 						  event->desc->probe_callback,
 						  event);
 		if (ret)
diff --git a/drivers/staging/lttng/lttng-events.h b/drivers/staging/lttng/lttng-events.h
index be3979a..af5aa65 100644
--- a/drivers/staging/lttng/lttng-events.h
+++ b/drivers/staging/lttng/lttng-events.h
@@ -23,6 +23,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include <linux/version.h>
 #include <linux/list.h>
 #include <linux/kprobes.h>
 #include "wrapper/uuid.h"
@@ -320,7 +321,7 @@ void lttng_event_put(const struct lttng_event_desc *desc);
 int lttng_probes_init(void);
 void lttng_probes_exit(void);
 
-#ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS
+#if defined(CONFIG_HAVE_SYSCALL_TRACEPOINTS)
 int lttng_syscalls_register(struct lttng_channel *chan, void *filter);
 int lttng_syscalls_unregister(struct lttng_channel *chan);
 #else
diff --git a/drivers/staging/lttng/lttng-statedump-impl.c b/drivers/staging/lttng/lttng-statedump-impl.c
index c92c331..be498ac 100644
--- a/drivers/staging/lttng/lttng-statedump-impl.c
+++ b/drivers/staging/lttng/lttng-statedump-impl.c
@@ -48,6 +48,7 @@
 
 #include "lttng-events.h"
 #include "wrapper/irqdesc.h"
+#include "wrapper/spinlock.h"
 
 #ifdef CONFIG_GENERIC_HARDIRQS
 #include <linux/irq.h>
@@ -255,12 +256,12 @@ void lttng_list_interrupts(struct lttng_session *session)
 			irq_desc_get_chip(desc)->name ? : "unnamed_irq_chip";
 
 		local_irq_save(flags);
-		raw_spin_lock(&desc->lock);
+		wrapper_desc_spin_lock(&desc->lock);
 		for (action = desc->action; action; action = action->next) {
 			trace_lttng_statedump_interrupt(session,
 				irq, irq_chip_name, action);
 		}
-		raw_spin_unlock(&desc->lock);
+		wrapper_desc_spin_unlock(&desc->lock);
 		local_irq_restore(flags);
 	}
 #undef irq_to_desc
diff --git a/drivers/staging/lttng/lttng-syscalls.c b/drivers/staging/lttng/lttng-syscalls.c
index ad0d728..a9cbdf8 100644
--- a/drivers/staging/lttng/lttng-syscalls.c
+++ b/drivers/staging/lttng/lttng-syscalls.c
@@ -26,6 +26,7 @@
 #include <asm/ptrace.h>
 #include <asm/syscall.h>
 
+#include "wrapper/tracepoint.h"
 #include "lttng-events.h"
 
 #ifndef CONFIG_COMPAT
@@ -38,6 +39,16 @@ static
 void syscall_entry_probe(void *__data, struct pt_regs *regs, long id);
 
 /*
+ * Forward declarations for old kernels.
+ */
+struct mmsghdr;
+struct rlimit64;
+struct oldold_utsname;
+struct old_utsname;
+struct sel_arg_struct;
+struct mmap_arg_struct;
+
+/*
  * Take care of NOARGS not supported by mainline.
  */
 #define DECLARE_EVENT_CLASS_NOARGS(name, tstruct, assign, print)
@@ -404,7 +415,7 @@ int lttng_syscalls_register(struct lttng_channel *chan, void *filter)
 	if (ret)
 		return ret;
 #endif
-	ret = tracepoint_probe_register("sys_enter",
+	ret = kabi_2635_tracepoint_probe_register("sys_enter",
 			(void *) syscall_entry_probe, chan);
 	if (ret)
 		return ret;
@@ -412,11 +423,11 @@ int lttng_syscalls_register(struct lttng_channel *chan, void *filter)
 	 * We change the name of sys_exit tracepoint due to namespace
 	 * conflict with sys_exit syscall entry.
 	 */
-	ret = tracepoint_probe_register("sys_exit",
+	ret = kabi_2635_tracepoint_probe_register("sys_exit",
 			(void *) __event_probe__exit_syscall,
 			chan->sc_exit);
 	if (ret) {
-		WARN_ON_ONCE(tracepoint_probe_unregister("sys_enter",
+		WARN_ON_ONCE(kabi_2635_tracepoint_probe_unregister("sys_enter",
 			(void *) syscall_entry_probe, chan));
 	}
 	return ret;
@@ -431,12 +442,12 @@ int lttng_syscalls_unregister(struct lttng_channel *chan)
 
 	if (!chan->sc_table)
 		return 0;
-	ret = tracepoint_probe_unregister("sys_exit",
+	ret = kabi_2635_tracepoint_probe_unregister("sys_exit",
 			(void *) __event_probe__exit_syscall,
 			chan->sc_exit);
 	if (ret)
 		return ret;
-	ret = tracepoint_probe_unregister("sys_enter",
+	ret = kabi_2635_tracepoint_probe_unregister("sys_enter",
 			(void *) syscall_entry_probe, chan);
 	if (ret)
 		return ret;
diff --git a/drivers/staging/lttng/probes/Makefile b/drivers/staging/lttng/probes/Makefile
index 9626d30..58d3782 100644
--- a/drivers/staging/lttng/probes/Makefile
+++ b/drivers/staging/lttng/probes/Makefile
@@ -6,10 +6,8 @@ ccflags-y += -I$(PWD)/probes
 obj-m += lttng-types.o
 
 obj-m += lttng-probe-lttng.o
-
 obj-m += lttng-probe-sched.o
 obj-m += lttng-probe-irq.o
-obj-m += lttng-probe-signal.o
 obj-m += lttng-probe-timer.o
 
 obj-m += lttng-probe-statedump.o
@@ -18,6 +16,11 @@ ifneq ($(CONFIG_KVM),)
 obj-m += lttng-probe-kvm.o
 endif
 
+obj-m +=  $(shell \
+	if [ $(VERSION) -ge 3 \
+		-o \( $(VERSION) -eq 2 -a $(PATCHLEVEL) -ge 6 -a $(SUBLEVEL) -ge 35 \) ] ; then \
+		echo "lttng-probe-signal.o" ; fi;)
+
 ifneq ($(CONFIG_BLOCK),)
 ifneq ($(CONFIG_EVENT_TRACING),)	# need blk_cmd_buf_len
 obj-m +=  $(shell \
diff --git a/drivers/staging/lttng/probes/define_trace.h b/drivers/staging/lttng/probes/define_trace.h
index e903103..a518390 100644
--- a/drivers/staging/lttng/probes/define_trace.h
+++ b/drivers/staging/lttng/probes/define_trace.h
@@ -125,7 +125,6 @@
 #undef DEFINE_EVENT_PRINT
 #undef DEFINE_EVENT_CONDITION
 #undef TRACE_HEADER_MULTI_READ
-#undef DECLARE_TRACE
 
 /* Only undef what we defined in this file */
 #ifdef UNDEF_TRACE_INCLUDE_FILE
diff --git a/drivers/staging/lttng/probes/lttng-probe-irq.c b/drivers/staging/lttng/probes/lttng-probe-irq.c
index 8f5bcd2..afcd1d2 100644
--- a/drivers/staging/lttng/probes/lttng-probe-irq.c
+++ b/drivers/staging/lttng/probes/lttng-probe-irq.c
@@ -22,6 +22,7 @@
 
 #include <linux/module.h>
 #include <linux/interrupt.h>
+#include "../wrapper/tracepoint.h"
 
 /*
  * Create the tracepoint static inlines from the kernel to validate that our
diff --git a/drivers/staging/lttng/probes/lttng-probe-sched.c b/drivers/staging/lttng/probes/lttng-probe-sched.c
index 9b3ca5d..caef6f7 100644
--- a/drivers/staging/lttng/probes/lttng-probe-sched.c
+++ b/drivers/staging/lttng/probes/lttng-probe-sched.c
@@ -21,6 +21,7 @@
  */
 
 #include <linux/module.h>
+#include "../wrapper/tracepoint.h"
 
 /*
  * Create the tracepoint static inlines from the kernel to validate that our
diff --git a/drivers/staging/lttng/probes/lttng-probe-timer.c b/drivers/staging/lttng/probes/lttng-probe-timer.c
index 3368bd8..9cf7492 100644
--- a/drivers/staging/lttng/probes/lttng-probe-timer.c
+++ b/drivers/staging/lttng/probes/lttng-probe-timer.c
@@ -21,11 +21,13 @@
  */
 
 #include <linux/module.h>
+#include "../wrapper/tracepoint.h"
 
 /*
  * Create the tracepoint static inlines from the kernel to validate that our
  * trace event macros match the kernel we run on.
  */
+
 #include <linux/sched.h>
 #include <trace/events/timer.h>
 
diff --git a/drivers/staging/lttng/wrapper/perf.h b/drivers/staging/lttng/wrapper/perf.h
index 2caf308..5dfa84b 100644
--- a/drivers/staging/lttng/wrapper/perf.h
+++ b/drivers/staging/lttng/wrapper/perf.h
@@ -32,7 +32,9 @@ wrapper_perf_event_create_kernel_counter(struct perf_event_attr *attr,
 {
 	return perf_event_create_kernel_counter(attr, cpu, task, callback, NULL);
 }
-#else
+#else /* defined(CONFIG_PERF_EVENTS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,99)) */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 static inline struct perf_event *
 wrapper_perf_event_create_kernel_counter(struct perf_event_attr *attr,
 				int cpu,
@@ -41,6 +43,26 @@ wrapper_perf_event_create_kernel_counter(struct perf_event_attr *attr,
 {
 	return perf_event_create_kernel_counter(attr, cpu, task, callback);
 }
-#endif
+#else /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)) */
+static inline struct perf_event *
+wrapper_perf_event_create_kernel_counter(struct perf_event_attr *attr,
+				int cpu,
+				struct task_struct *task,
+				perf_overflow_handler_t callback)
+{
+	pid_t pid;
+
+	if (!task)
+		pid = -1;
+	else
+		pid = task->pid;
+
+	return perf_event_create_kernel_counter(attr, cpu, pid, callback);
+}
+
+#define local64_read(l)		atomic64_read(l)
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)) */
+
+#endif /* defined(CONFIG_PERF_EVENTS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,99)) */
 
 #endif /* _LTTNG_WRAPPER_PERF_H */
diff --git a/drivers/staging/lttng/wrapper/spinlock.h b/drivers/staging/lttng/wrapper/spinlock.h
index fdeb91a..bc71b4f 100644
--- a/drivers/staging/lttng/wrapper/spinlock.h
+++ b/drivers/staging/lttng/wrapper/spinlock.h
@@ -35,6 +35,13 @@
 
 #define raw_spin_is_locked(lock)	__raw_spin_is_locked(lock)
 
+#define wrapper_desc_spin_lock(lock)	spin_lock(lock)
+#define wrapper_desc_spin_unlock(lock)	spin_unlock(lock)
+
+#else
+
+#define wrapper_desc_spin_lock(lock)	raw_spin_lock(lock)
+#define wrapper_desc_spin_unlock(lock)	raw_spin_unlock(lock)
 
 #endif
 #endif /* _LTTNG_WRAPPER_SPINLOCK_H */
diff --git a/drivers/staging/lttng/wrapper/tracepoint.h b/drivers/staging/lttng/wrapper/tracepoint.h
new file mode 100644
index 0000000..798d785
--- /dev/null
+++ b/drivers/staging/lttng/wrapper/tracepoint.h
@@ -0,0 +1,44 @@
+#ifndef _LTTNG_WRAPPER_TRACEPOINT_H
+#define _LTTNG_WRAPPER_TRACEPOINT_H
+
+/*
+ * wrapper/tracepoint.h
+ *
+ * wrapper around DECLARE_EVENT_CLASS.
+ *
+ * Copyright (C) 2011-2012 Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; only
+ * version 2.1 of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <linux/version.h>
+#include <linux/tracepoint.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+
+#define DECLARE_EVENT_CLASS(name, proto, args, tstruct, assign, print)
+
+#endif
+
+#ifndef HAVE_KABI_2635_TRACEPOINT
+
+#define kabi_2635_tracepoint_probe_register tracepoint_probe_register
+#define kabi_2635_tracepoint_probe_unregister tracepoint_probe_unregister
+#define kabi_2635_tracepoint_probe_register_noupdate tracepoint_probe_register_noupdate
+#define kabi_2635_tracepoint_probe_unregister_noupdate tracepoint_probe_unregister_noupdate
+
+#endif /* HAVE_KABI_2635_TRACEPOINT */
+
+#endif /* _LTTNG_WRAPPER_TRACEPOINT_H */
-- 
1.8.3.1

