From dc007a2a98817cbf8db1943124228daff1e6b86e Mon Sep 17 00:00:00 2001
From: Eric Lapuyade <eric.lapuyade@linux.intel.com>
Date: Mon, 2 Sep 2013 12:35:39 +0200
Subject: [PATCH 34/44] NFC: NCI: Rename spi ndev -> nsdev and nci_dev -> ndev
 for consistency

An hci dev is an hdev. An nci dev is an ndev. Calling an nci spi dev an
ndev is misleading since it's not the same thing. The nci dev contained
in the nci spi dev is also named inconsistently.

Signed-off-by: Eric Lapuyade <eric.lapuyade@intel.com>
Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>
(cherry picked from commit f86715723c0ace974220ed7c346236238c76c4cd)
---
 include/net/nfc/nci_core.h |  26 ++++-----
 net/nfc/nci/spi.c          | 128 ++++++++++++++++++++++-----------------------
 2 files changed, 77 insertions(+), 77 deletions(-)

diff --git a/include/net/nfc/nci_core.h b/include/net/nfc/nci_core.h
index 99fc1f3..c083996 100644
--- a/include/net/nfc/nci_core.h
+++ b/include/net/nfc/nci_core.h
@@ -210,14 +210,14 @@ int nci_to_errno(__u8 code);
 struct nci_spi_dev;
 
 struct nci_spi_ops {
-	int (*open)(struct nci_spi_dev *ndev);
-	int (*close)(struct nci_spi_dev *ndev);
-	void (*assert_int)(struct nci_spi_dev *ndev);
-	void (*deassert_int)(struct nci_spi_dev *ndev);
+	int (*open)(struct nci_spi_dev *nsdev);
+	int (*close)(struct nci_spi_dev *nsdev);
+	void (*assert_int)(struct nci_spi_dev *nsdev);
+	void (*deassert_int)(struct nci_spi_dev *nsdev);
 };
 
 struct nci_spi_dev {
-	struct nci_dev		*nci_dev;
+	struct nci_dev		*ndev;
 	struct spi_device	*spi;
 	struct nci_spi_ops	*ops;
 
@@ -238,20 +238,20 @@ struct nci_spi_dev *nci_spi_allocate_device(struct spi_device *spi,
 						u32 supported_se,
 						u8 acknowledge_mode,
 						unsigned int delay);
-void nci_spi_free_device(struct nci_spi_dev *ndev);
-int nci_spi_register_device(struct nci_spi_dev *ndev);
-void nci_spi_unregister_device(struct nci_spi_dev *ndev);
-int nci_spi_recv_frame(struct nci_spi_dev *ndev);
+void nci_spi_free_device(struct nci_spi_dev *nsdev);
+int nci_spi_register_device(struct nci_spi_dev *nsdev);
+void nci_spi_unregister_device(struct nci_spi_dev *nsdev);
+int nci_spi_recv_frame(struct nci_spi_dev *nsdev);
 
-static inline void nci_spi_set_drvdata(struct nci_spi_dev *ndev,
+static inline void nci_spi_set_drvdata(struct nci_spi_dev *nsdev,
 					    void *data)
 {
-	ndev->driver_data = data;
+	nsdev->driver_data = data;
 }
 
-static inline void *nci_spi_get_drvdata(struct nci_spi_dev *ndev)
+static inline void *nci_spi_get_drvdata(struct nci_spi_dev *nsdev)
 {
-	return ndev->driver_data;
+	return nsdev->driver_data;
 }
 
 #endif /* __NCI_CORE_H */
diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index b679595..e66fda4 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -41,21 +41,21 @@
 
 #define CRC_INIT		0xFFFF
 
-static int nci_spi_open(struct nci_dev *nci_dev)
+static int nci_spi_open(struct nci_dev *ndev)
 {
-	struct nci_spi_dev *ndev = nci_get_drvdata(nci_dev);
+	struct nci_spi_dev *nsdev = nci_get_drvdata(ndev);
 
-	return ndev->ops->open(ndev);
+	return nsdev->ops->open(nsdev);
 }
 
-static int nci_spi_close(struct nci_dev *nci_dev)
+static int nci_spi_close(struct nci_dev *ndev)
 {
-	struct nci_spi_dev *ndev = nci_get_drvdata(nci_dev);
+	struct nci_spi_dev *nsdev = nci_get_drvdata(ndev);
 
-	return ndev->ops->close(ndev);
+	return nsdev->ops->close(nsdev);
 }
 
-static int __nci_spi_send(struct nci_spi_dev *ndev, struct sk_buff *skb)
+static int __nci_spi_send(struct nci_spi_dev *nsdev, struct sk_buff *skb)
 {
 	struct spi_message m;
 	struct spi_transfer t;
@@ -63,32 +63,32 @@ static int __nci_spi_send(struct nci_spi_dev *ndev, struct sk_buff *skb)
 	t.tx_buf = skb->data;
 	t.len = skb->len;
 	t.cs_change = 0;
-	t.delay_usecs = ndev->xfer_udelay;
+	t.delay_usecs = nsdev->xfer_udelay;
 
 	spi_message_init(&m);
 	spi_message_add_tail(&t, &m);
 
-	return spi_sync(ndev->spi, &m);
+	return spi_sync(nsdev->spi, &m);
 }
 
-static int nci_spi_send(struct nci_dev *nci_dev, struct sk_buff *skb)
+static int nci_spi_send(struct nci_dev *ndev, struct sk_buff *skb)
 {
-	struct nci_spi_dev *ndev = nci_get_drvdata(nci_dev);
+	struct nci_spi_dev *nsdev = nci_get_drvdata(ndev);
 	unsigned int payload_len = skb->len;
 	unsigned char *hdr;
 	int ret;
 	long completion_rc;
 
-	ndev->ops->deassert_int(ndev);
+	nsdev->ops->deassert_int(nsdev);
 
 	/* add the NCI SPI header to the start of the buffer */
 	hdr = skb_push(skb, NCI_SPI_HDR_LEN);
 	hdr[0] = NCI_SPI_DIRECT_WRITE;
-	hdr[1] = ndev->acknowledge_mode;
+	hdr[1] = nsdev->acknowledge_mode;
 	hdr[2] = payload_len >> 8;
 	hdr[3] = payload_len & 0xFF;
 
-	if (ndev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
+	if (nsdev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
 		u16 crc;
 
 		crc = crc_ccitt(CRC_INIT, skb->data, skb->len);
@@ -96,20 +96,20 @@ static int nci_spi_send(struct nci_dev *nci_dev, struct sk_buff *skb)
 		*skb_put(skb, 1) = crc & 0xFF;
 	}
 
-	ret = __nci_spi_send(ndev, skb);
+	ret = __nci_spi_send(nsdev, skb);
 
 	kfree_skb(skb);
-	ndev->ops->assert_int(ndev);
+	nsdev->ops->assert_int(nsdev);
 
-	if (ret != 0 || ndev->acknowledge_mode == NCI_SPI_CRC_DISABLED)
+	if (ret != 0 || nsdev->acknowledge_mode == NCI_SPI_CRC_DISABLED)
 		goto done;
 
-	init_completion(&ndev->req_completion);
-	completion_rc =
-		wait_for_completion_interruptible_timeout(&ndev->req_completion,
-							  NCI_SPI_SEND_TIMEOUT);
+	init_completion(&nsdev->req_completion);
+	completion_rc =	wait_for_completion_interruptible_timeout(
+							&nsdev->req_completion,
+							NCI_SPI_SEND_TIMEOUT);
 
-	if (completion_rc <= 0 || ndev->req_result == ACKNOWLEDGE_NACK)
+	if (completion_rc <= 0 || nsdev->req_result == ACKNOWLEDGE_NACK)
 		ret = -EIO;
 
 done:
@@ -141,7 +141,7 @@ struct nci_spi_dev *nci_spi_allocate_device(struct spi_device *spi,
 						u8 acknowledge_mode,
 						unsigned int delay)
 {
-	struct nci_spi_dev *ndev;
+	struct nci_spi_dev *nsdev;
 	int tailroom = 0;
 
 	if (!ops->open || !ops->close || !ops->assert_int || !ops->deassert_int)
@@ -150,36 +150,36 @@ struct nci_spi_dev *nci_spi_allocate_device(struct spi_device *spi,
 	if (!supported_protocols)
 		return NULL;
 
-	ndev = devm_kzalloc(&spi->dev, sizeof(struct nci_spi_dev), GFP_KERNEL);
-	if (!ndev)
+	nsdev = devm_kzalloc(&spi->dev, sizeof(struct nci_spi_dev), GFP_KERNEL);
+	if (!nsdev)
 		return NULL;
 
-	ndev->ops = ops;
-	ndev->acknowledge_mode = acknowledge_mode;
-	ndev->xfer_udelay = delay;
+	nsdev->ops = ops;
+	nsdev->acknowledge_mode = acknowledge_mode;
+	nsdev->xfer_udelay = delay;
 
 	if (acknowledge_mode == NCI_SPI_CRC_ENABLED)
 		tailroom += NCI_SPI_CRC_LEN;
 
-	ndev->nci_dev = nci_allocate_device(&nci_spi_ops, supported_protocols,
-					    NCI_SPI_HDR_LEN, tailroom);
-	if (!ndev->nci_dev)
+	nsdev->ndev = nci_allocate_device(&nci_spi_ops, supported_protocols,
+					  NCI_SPI_HDR_LEN, tailroom);
+	if (!nsdev->ndev)
 		return NULL;
 
-	nci_set_drvdata(ndev->nci_dev, ndev);
+	nci_set_drvdata(nsdev->ndev, nsdev);
 
-	return ndev;
+	return nsdev;
 }
 EXPORT_SYMBOL_GPL(nci_spi_allocate_device);
 
 /**
  * nci_spi_free_device - deallocate nci spi device
  *
- * @ndev: The nci spi device to deallocate
+ * @nsdev: The nci spi device to deallocate
  */
-void nci_spi_free_device(struct nci_spi_dev *ndev)
+void nci_spi_free_device(struct nci_spi_dev *nsdev)
 {
-	nci_free_device(ndev->nci_dev);
+	nci_free_device(nsdev->ndev);
 }
 EXPORT_SYMBOL_GPL(nci_spi_free_device);
 
@@ -188,9 +188,9 @@ EXPORT_SYMBOL_GPL(nci_spi_free_device);
  *
  * @pdev: The nci spi device to register
  */
-int nci_spi_register_device(struct nci_spi_dev *ndev)
+int nci_spi_register_device(struct nci_spi_dev *nsdev)
 {
-	return nci_register_device(ndev->nci_dev);
+	return nci_register_device(nsdev->ndev);
 }
 EXPORT_SYMBOL_GPL(nci_spi_register_device);
 
@@ -199,20 +199,20 @@ EXPORT_SYMBOL_GPL(nci_spi_register_device);
  *
  * @dev: The nci spi device to unregister
  */
-void nci_spi_unregister_device(struct nci_spi_dev *ndev)
+void nci_spi_unregister_device(struct nci_spi_dev *nsdev)
 {
-	nci_unregister_device(ndev->nci_dev);
+	nci_unregister_device(nsdev->ndev);
 }
 EXPORT_SYMBOL_GPL(nci_spi_unregister_device);
 
-static int send_acknowledge(struct nci_spi_dev *ndev, u8 acknowledge)
+static int send_acknowledge(struct nci_spi_dev *nsdev, u8 acknowledge)
 {
 	struct sk_buff *skb;
 	unsigned char *hdr;
 	u16 crc;
 	int ret;
 
-	skb = nci_skb_alloc(ndev->nci_dev, 0, GFP_KERNEL);
+	skb = nci_skb_alloc(nsdev->ndev, 0, GFP_KERNEL);
 
 	/* add the NCI SPI header to the start of the buffer */
 	hdr = skb_push(skb, NCI_SPI_HDR_LEN);
@@ -225,14 +225,14 @@ static int send_acknowledge(struct nci_spi_dev *ndev, u8 acknowledge)
 	*skb_put(skb, 1) = crc >> 8;
 	*skb_put(skb, 1) = crc & 0xFF;
 
-	ret = __nci_spi_send(ndev, skb);
+	ret = __nci_spi_send(nsdev, skb);
 
 	kfree_skb(skb);
 
 	return ret;
 }
 
-static struct sk_buff *__nci_spi_recv_frame(struct nci_spi_dev *ndev)
+static struct sk_buff *__nci_spi_recv_frame(struct nci_spi_dev *nsdev)
 {
 	struct sk_buff *skb;
 	struct spi_message m;
@@ -243,7 +243,7 @@ static struct sk_buff *__nci_spi_recv_frame(struct nci_spi_dev *ndev)
 
 	spi_message_init(&m);
 	req[0] = NCI_SPI_DIRECT_READ;
-	req[1] = ndev->acknowledge_mode;
+	req[1] = nsdev->acknowledge_mode;
 	tx.tx_buf = req;
 	tx.len = 2;
 	tx.cs_change = 0;
@@ -252,18 +252,18 @@ static struct sk_buff *__nci_spi_recv_frame(struct nci_spi_dev *ndev)
 	rx.len = 2;
 	rx.cs_change = 1;
 	spi_message_add_tail(&rx, &m);
-	ret = spi_sync(ndev->spi, &m);
+	ret = spi_sync(nsdev->spi, &m);
 
 	if (ret)
 		return NULL;
 
-	if (ndev->acknowledge_mode == NCI_SPI_CRC_ENABLED)
+	if (nsdev->acknowledge_mode == NCI_SPI_CRC_ENABLED)
 		rx_len = ((resp_hdr[0] & NCI_SPI_MSB_PAYLOAD_MASK) << 8) +
 				resp_hdr[1] + NCI_SPI_CRC_LEN;
 	else
 		rx_len = (resp_hdr[0] << 8) | resp_hdr[1];
 
-	skb = nci_skb_alloc(ndev->nci_dev, rx_len, GFP_KERNEL);
+	skb = nci_skb_alloc(nsdev->ndev, rx_len, GFP_KERNEL);
 	if (!skb)
 		return NULL;
 
@@ -271,14 +271,14 @@ static struct sk_buff *__nci_spi_recv_frame(struct nci_spi_dev *ndev)
 	rx.rx_buf = skb_put(skb, rx_len);
 	rx.len = rx_len;
 	rx.cs_change = 0;
-	rx.delay_usecs = ndev->xfer_udelay;
+	rx.delay_usecs = nsdev->xfer_udelay;
 	spi_message_add_tail(&rx, &m);
-	ret = spi_sync(ndev->spi, &m);
+	ret = spi_sync(nsdev->spi, &m);
 
 	if (ret)
 		goto receive_error;
 
-	if (ndev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
+	if (nsdev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
 		*skb_push(skb, 1) = resp_hdr[1];
 		*skb_push(skb, 1) = resp_hdr[0];
 	}
@@ -320,7 +320,7 @@ static u8 nci_spi_get_ack(struct sk_buff *skb)
 /**
  * nci_spi_recv_frame - receive frame from NCI SPI drivers
  *
- * @ndev: The nci spi device
+ * @nsdev: The nci spi device
  * Context: can sleep
  *
  * This call may only be used from a context that may sleep.  The sleep
@@ -328,32 +328,32 @@ static u8 nci_spi_get_ack(struct sk_buff *skb)
  *
  * It returns zero on success, else a negative error code.
  */
-int nci_spi_recv_frame(struct nci_spi_dev *ndev)
+int nci_spi_recv_frame(struct nci_spi_dev *nsdev)
 {
 	struct sk_buff *skb;
 	int ret = 0;
 
-	ndev->ops->deassert_int(ndev);
+	nsdev->ops->deassert_int(nsdev);
 
 	/* Retrieve frame from SPI */
-	skb = __nci_spi_recv_frame(ndev);
+	skb = __nci_spi_recv_frame(nsdev);
 	if (!skb) {
 		ret = -EIO;
 		goto done;
 	}
 
-	if (ndev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
+	if (nsdev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
 		if (!nci_spi_check_crc(skb)) {
-			send_acknowledge(ndev, ACKNOWLEDGE_NACK);
+			send_acknowledge(nsdev, ACKNOWLEDGE_NACK);
 			goto done;
 		}
 
 		/* In case of acknowledged mode: if ACK or NACK received,
 		 * unblock completion of latest frame sent.
 		 */
-		ndev->req_result = nci_spi_get_ack(skb);
-		if (ndev->req_result)
-			complete(&ndev->req_completion);
+		nsdev->req_result = nci_spi_get_ack(skb);
+		if (nsdev->req_result)
+			complete(&nsdev->req_completion);
 	}
 
 	/* If there is no payload (ACK/NACK only frame),
@@ -364,14 +364,14 @@ int nci_spi_recv_frame(struct nci_spi_dev *ndev)
 		goto done;
 	}
 
-	if (ndev->acknowledge_mode == NCI_SPI_CRC_ENABLED)
-		send_acknowledge(ndev, ACKNOWLEDGE_ACK);
+	if (nsdev->acknowledge_mode == NCI_SPI_CRC_ENABLED)
+		send_acknowledge(nsdev, ACKNOWLEDGE_ACK);
 
 	/* Forward skb to NCI core layer */
-	ret = nci_recv_frame(ndev->nci_dev, skb);
+	ret = nci_recv_frame(nsdev->ndev, skb);
 
 done:
-	ndev->ops->assert_int(ndev);
+	nsdev->ops->assert_int(nsdev);
 
 	return ret;
 }
-- 
1.8.4.93.g57e4c17

