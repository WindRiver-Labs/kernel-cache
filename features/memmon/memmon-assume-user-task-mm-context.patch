From 9cbc0839b0cf13407513d9618716283f4ec411b9 Mon Sep 17 00:00:00 2001
From: Hong H. Pham <hong.pham@windriver.com>
Date: Wed, 5 Nov 2008 18:54:28 -0500
Subject: [PATCH] memmon assume user task mm context

The Netlink Connector Queue kernel thread must assume the memmon user's
mm context for kernel user space access functions such as put_user() to work.

Signed-off-by: Hong H. Pham <hong.pham@windriver.com>
---
 mm/memmon.c |   63 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 63 insertions(+), 0 deletions(-)

diff --git a/mm/memmon.c b/mm/memmon.c
index c944f1b..6e53caa 100644
--- a/mm/memmon.c
+++ b/mm/memmon.c
@@ -28,6 +28,7 @@
 #include <linux/highmem.h>
 
 #include <asm/timex.h>
+#include <asm/mmu_context.h>
 
 
 #ifdef CONFIG_PPC64
@@ -112,6 +113,54 @@ static inline int memmon_test_flags(unsigned char *flagptr, unsigned char flags)
 }
 
 
+/*
+ * Copied from fs/aio.c
+ * The calling kernel thread is the netlink connector queue (cqueue).
+ *
+ * use_mm
+ *      Makes the calling kernel thread take on the specified
+ *      mm context.
+ *      Called by the retry thread execute retries within the
+ *      iocb issuer's mm context, so that copy_from/to_user
+ *      operations work seamlessly for aio.
+ *      (Note: this routine is intended to be called only
+ *      from a kernel thread context)
+ */
+static void use_mm(struct mm_struct *mm)
+{
+	struct mm_struct *active_mm;
+	struct task_struct *tsk = current;
+
+	task_lock(tsk);
+	active_mm = tsk->active_mm;
+	atomic_inc(&mm->mm_count);
+	tsk->mm = mm;
+	tsk->active_mm = mm;
+	switch_mm(active_mm, mm, tsk);
+	task_unlock(tsk);
+
+	mmdrop(active_mm);
+}
+
+/*
+ * unuse_mm
+ *      Reverses the effect of use_mm, i.e. releases the
+ *      specified mm context which was earlier taken on
+ *      by the calling kernel thread
+ *      (Note: this routine is intended to be called only
+ *      from a kernel thread context)
+ */
+static void unuse_mm(struct mm_struct *mm)
+{
+	struct task_struct *tsk = current;
+
+	task_lock(tsk);
+	tsk->mm = NULL;
+	/* active_mm is still 'mm' */
+	enter_lazy_tlb(mm, tsk);
+	task_unlock(tsk);
+}
+
 /* This routine allows us to set flag bits in the byte reserved for memmon
  * flags for the specified address range.
  *
@@ -451,6 +500,7 @@ out:
 int memmon_collect_data(struct mm_struct *mm, struct memmon_info *args)
 {
 	int ret;
+	mm_segment_t old_fs;
 	unsigned int start = args->start;
 	unsigned int end = args->end;
 	unsigned long bufaddr = args->buf;
@@ -466,7 +516,15 @@ int memmon_collect_data(struct mm_struct *mm, struct memmon_info *args)
 #endif
 	ret = -EFAULT;
 
+	old_fs = get_fs();
 	if (options & STORE_MATCHING_PAGES) {
+		/*
+		 * Take on the memmon user's mm context so that put_user()
+		 * operates in the proper address space.
+		 */
+		set_fs(USER_DS);
+		use_mm(mm);
+
 		ret = !access_ok(VERIFY_WRITE, buf, args->bufsize);
 		if (ret) {
 			printk("verification failed\n");
@@ -604,6 +662,11 @@ out:
        if (need_flush)
                flush_tlb_pending();
 #endif
+	if (options & STORE_MATCHING_PAGES) {
+		unuse_mm(mm);
+		set_fs(old_fs);
+	}
+
 	return ret;
 }
 
-- 
1.5.5.1

