From de2a2fabd7fc48b2906c5cc1b4ff102d3011723c Mon Sep 17 00:00:00 2001
From: Hong H. Pham <hong.pham@windriver.com>
Date: Wed, 5 Nov 2008 18:54:28 -0500
Subject: [PATCH] memmon unaligned access and 64bit fixes

* Fix unaligned access to memmon_info structure in connector message buffer.

* Disallow memmon access from 64-bit user space tasks.  Memmon works on
  32-bit user space tasks only.

* Modify Memmon Flag Table (MFT) and Memmon Flag Directory (MFD) access
  macros to work with page sizes other than 4K.

Signed-off-by: Hong H. Pham <hong.pham@windriver.com>
---
 drivers/connector/cn_memmon.c |   82 +++++++++++++++++++++++++++-------------
 mm/memmon.c                   |   30 ++++++++-------
 2 files changed, 71 insertions(+), 41 deletions(-)

diff --git a/drivers/connector/cn_memmon.c b/drivers/connector/cn_memmon.c
index 6f89bf5..c716716 100644
--- a/drivers/connector/cn_memmon.c
+++ b/drivers/connector/cn_memmon.c
@@ -16,16 +16,18 @@
  * along with this program; if not, write to the Free Software 
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
  * 
  */
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/skbuff.h>
+#include <linux/compat.h>
+#include <asm/unaligned.h>
 
 #include <linux/cn_memmon.h>
 
 static struct cb_id cn_memmon_id = { CN_IDX_MEMMON, CN_VAL_MEMMON };
 static char cn_memmon_name[] = "cn_memmon";
 
 #define CN_MEMMON_MSG_SIZE (sizeof(struct cn_msg) + sizeof(struct memmon_info))
 
@@ -34,84 +36,107 @@ void cn_memmon_callback(void *data)
 	struct cn_msg *msg = (struct cn_msg *)data;
 	struct memmon_info *args = NULL;
 	struct mm_struct *mm;
 	struct cn_msg *reply;
 	struct memmon_info *replymsg = NULL;
 	int ret;
 	char replybuf[CN_MEMMON_MSG_SIZE];
 	struct task_struct *p;
+	int  args_options;
+	char args_cmd;
+#if (BITS_PER_LONG == 64)
+	compat_pid_t args_pid;
+#else
+	pid_t args_pid;
+#endif
 
 	reply = (struct cn_msg *) replybuf;
+	memset(replybuf, 0x00, sizeof(replybuf));
 
 	args = (struct memmon_info *)msg->data;
 
+	args_cmd     = get_unaligned(&args->cmd);
+	args_options = get_unaligned(&args->options);
+	args_pid     = get_unaligned(&args->pid);
 #ifdef DEBUG
 	printk("cn_memmon_callback:\n");
-	printk("\tpid: %d\n", args->pid);
-	printk("\tseq: %d\n", msg->seq);
-	printk("\tack: %d\n", msg->ack);
+	printk("\tpid: %d\n", args_pid);
+	printk("\tseq: %d\n", get_unaligned(&msg->seq));
+	printk("\tack: %d\n", get_unaligned(&msg->ack));
 
-	switch (args->cmd) {
+	switch (args_cmd) {
 		case MONITOR_SET:
 			printk("\tcmd: MONITOR_SET\n");
 			break;
 		case MONITOR_CLR:
 			printk("\tcmd: MONITOR_CLR\n");
 			break;
 		case MONITOR_COLLECT:
 			printk("\tcmd: MONITOR_COLLECT\n");
 			break;
 		default:
 			printk("\tcmd: UNKNOWN\n");
 	}
 
-	printk("\tflags: %c\n", args->flags);
-	printk("\tbufsize: %d\n", args->bufsize);
-	printk("\tbuf: %p\n", args->buf);
-	printk("\tstart: %p\n", args->start);
-	printk("\tend: %p\n", args->end);
-	printk("\toptions: %d\n", args->options);
+	printk("\tflags: %u\n", get_unaligned(&args->flags));
+	printk("\tbufsize: %u\n", get_unaligned(&args->bufsize));
+	printk("\tbuf: 0x%08x\n", get_unaligned(&args->buf));
+	printk("\tstart: 0x%08x\n", get_unaligned(&args->start));
+	printk("\tend: 0x%08x\n", get_unaligned(&args->end));
+	printk("\toptions: 0x%04x\n", args_options);
 
-	if (args->options & CHECK_DIRTY_STATE)
+	if (args_options & CHECK_DIRTY_STATE)
 		printk("\t\tCHECK_DIRTY_STATE\n");
-	if (args->options & CHECK_FLAGS)
+	if (args_options & CHECK_FLAGS)
 		printk("\t\tCHECK_FLAGS\n");
-	if (args->options & STORE_MATCHING_PAGES)
+	if (args_options & STORE_MATCHING_PAGES)
 		printk("\t\tSTORE_MATCHING_PAGES\n");
-	if (args->options & CLEAN_STORED_PAGES)
+	if (args_options & CLEAN_STORED_PAGES)
 		printk("\t\tCLEAN_STORED_PAGES\n");
-	if (args->options & CLEAN_MATCHING_PAGES)
+	if (args_options & CLEAN_MATCHING_PAGES)
 		printk("\t\tCLEAN_MATCHING_PAGES\n");
-	if (args->options & STOP_WHEN_BUF_FULL)
+	if (args_options & STOP_WHEN_BUF_FULL)
 		printk("\t\tSTOP_WHEN_BUF_FULL\n");
-	if (args->options & CHECK_SWAPPED_STATE)
+	if (args_options & CHECK_SWAPPED_STATE)
 		printk("\t\tCHECK_SWAPPED_STATE\n");
-	if (args->options & VALID_PAGES_ONLY)
+	if (args_options & VALID_PAGES_ONLY)
 		printk("\t\tVALID_PAGES_ONLY\n");
 #endif
 
 	ret = -EINVAL;
-	if (args->start > args->end)
+	if (get_unaligned(&args->start) > get_unaligned(&args->end))
 		goto out;
 
-	p = find_task_by_pid_ns(args->pid, &init_pid_ns);
+	p = find_task_by_pid_ns(args_pid, &init_pid_ns);
 	if (!p) {
-		printk(KERN_ERR "memmon: invalid pid %d\n", args->pid);
+		printk(KERN_ERR "memmon: invalid pid %d\n", args_pid);
+		goto out;
+	}
+
+#if (BITS_PER_LONG == 64)
+	/* Memmon only works on 32-bit user space tasks. */
+	if (! test_tsk_thread_flag(p, TIF_32BIT)) {
+		printk(KERN_ERR
+		       "memmon: memmon is not available for 64 bit tasks "
+		       "(pid=%i, %s)\n",
+		       args_pid, p->comm);
+		ret = -ENOSYS; /* ENOTSUP is not defined in the kernel */
 		goto out;
 	}
+#endif
 
 	mm = get_task_mm(p);
 	if (!mm) {
 		printk(KERN_ERR "memmon: no mm context\n");
 		ret = -EFAULT;
 		goto out;
 	}
 
-	switch (args->cmd) {
+	switch (args_cmd) {
 		case MONITOR_SET:
 			ret = memmon_set_address_flags(mm, args);
 			break;
 		case MONITOR_CLR:
 			ret = 0;
 			memmon_clr_address_flags(mm, args);
 			break;
 		case MONITOR_COLLECT:
@@ -119,22 +144,25 @@ void cn_memmon_callback(void *data)
 			break;
 	}
 	mmput(mm);
 out:
 #ifdef DEBUG
 	printk("\tretval: %d\n", ret);
 #endif
         memcpy(&reply->id, &cn_memmon_id, sizeof(reply->id));
-	reply->seq = msg->seq;
-	reply->ack = msg->ack + 1;
-	reply->len = sizeof(struct memmon_info);
+
+	put_unaligned(get_unaligned(&msg->seq), &reply->seq);
+	put_unaligned(get_unaligned(&msg->ack) + 1, &reply->ack);
+	put_unaligned(sizeof(struct memmon_info), &reply->len);
+
 	replymsg = (struct memmon_info *) reply->data;
-	replymsg->cmd= KERNEL_REPLY;
-	replymsg->count = ret;
+	put_unaligned(KERNEL_REPLY, &replymsg->cmd);
+	put_unaligned(ret, &replymsg->count);
+
 	cn_netlink_send(reply, CN_IDX_MEMMON, GFP_KERNEL);
 #ifdef DEBUG
 	printk("\tcn_netlink_send done\n");
 #endif
 	return;
 }
 
 static int cn_memmon_init(void)
diff --git a/mm/memmon.c b/mm/memmon.c
index 53753ee..1704ce9 100644
--- a/mm/memmon.c
+++ b/mm/memmon.c
@@ -17,16 +17,17 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
  * 
  */
 #include <linux/errno.h>
 #include <linux/cn_memmon.h>
 #include <linux/sched.h>
 #include <linux/gfp.h>
 #include <asm/uaccess.h>
+#include <asm/unaligned.h>
 #include <asm/pgtable.h>
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
 #include <linux/highmem.h>
 
 #include <asm/timex.h>
 
 
@@ -70,27 +71,26 @@ static inline void flush_tlb_pending()
  *    memmon flag directory.
  * 3) Get the location of the memmon flag table.  (Note: it may not exist
  *    in which case there were no flags for that address.)
  * 4) Use the next 12 bits of the memory address as an offset within the
  *    memmon flag table.
  * 5) The byte at that location are the flag bits for the address in question.
  */
 
+#define MFT_SHIFT         PAGE_SHIFT
+#define ENTRIES_PER_MFT   PAGE_SIZE
+#define MFT_MASK          (ENTRIES_PER_MFT - 1)
+#define mfte_offset(addr) (((addr) >> (MFT_SHIFT)) & MFT_MASK)
 
-#define MFD_SHIFT 24
-#define PTRS_PER_MFD 256
-#define MFD_MASK (PTRS_PER_MFD - 1)
+#define MFD_SHIFT         (PAGE_SHIFT + PAGE_SHIFT)
+#define PTRS_PER_MFD      (2 << (32 - MFD_SHIFT))
+#define MFD_MASK          (PTRS_PER_MFD - 1)
 #define mfde_offset(addr) (((addr) >> (MFD_SHIFT)) & MFD_MASK)
 
-#define MFT_SHIFT 12
-#define ENTRIES_PER_MFT 4096
-#define MFT_MASK (ENTRIES_PER_MFT - 1)
-#define mfte_offset(addr) (((addr) >> (MFT_SHIFT)) & MFT_MASK)
-
 #define LAST_FLAG_TABLE_ADDR(addr) ((addr)|0xFFFFFF)
 
 #define memmon_flag_dir(mm) ((mfdep_t *) &mm->memmon_flag_dir)
 #define memmon_flag_dir_entry(mfdp, addr) (*mfdp + mfde_offset(addr))
 #define memmon_flag_table_entry(mfdep, addr) (*mfdep + mfte_offset(addr))
 
 typedef unsigned char mfte_t;
 typedef mfte_t * mfde_t;
@@ -495,47 +495,49 @@ static  pte_t *va_to_ptep_map(struct mm_struct *mm, unsigned long addr)
 out:
 	return ptep;
 }
 
 int memmon_collect_data(struct mm_struct *mm, struct memmon_info *args)
 {
 	int ret;
 	mm_segment_t old_fs;
-	unsigned int start = args->start;
-	unsigned int end = args->end;
-	unsigned long bufaddr = args->buf;
+	unsigned int start = get_unaligned(&args->start);
+	unsigned int end = get_unaligned(&args->end);
+	unsigned long bufaddr = get_unaligned(&args->buf);
 	unsigned int __user *buf = (unsigned int __user *) bufaddr;
-	int options = args->options;
+	int options = get_unaligned(&args->options);
 	unsigned int entries = 0;
 
 	unsigned int addr;
 	unsigned int page_count=0;
 	unsigned int loop_count=0;
+	int args_bufsize;
 #ifdef BATCH_FLUSH
 	int need_flush=0;
 #endif
 	ret = -EFAULT;
 
+	args_bufsize = get_unaligned(&args->bufsize);
 	old_fs = get_fs();
 	if (options & STORE_MATCHING_PAGES) {
 		/*
 		 * Take on the memmon user's mm context so that put_user()
 		 * operates in the proper address space.
 		 */
 		set_fs(USER_DS);
 		use_mm(mm);
 
-		ret = !access_ok(VERIFY_WRITE, buf, args->bufsize);
+		ret = !access_ok(VERIFY_WRITE, buf, args_bufsize);
 		if (ret) {
 			printk("verification failed\n");
 			ret = -EFAULT;
 			goto out;
 		}
-		entries =  args->bufsize / sizeof(*buf);
+		entries = args_bufsize / sizeof(*buf);
 	}
 
 	down_write(&mm->mmap_sem);
 
 	/* scan through the entire address space given */
 	page_count = 0;
 
 	/* Must hold the page table spinlock while walking */
-- 
1.5.5.1

