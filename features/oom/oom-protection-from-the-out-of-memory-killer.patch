From 8cc540cc6e6562387ec6fff193f0feae9a19cdb0 Mon Sep 17 00:00:00 2001
From: Greg Moffatt <greg.moffatt@windriver.com>
Date: Mon, 26 Apr 2010 05:56:01 -0700
Subject: [PATCH] oom: protection from the out-of-memory killer

OOM Protection Feature:

This adds a new capability to the kernel which
may be called (by processes with appropriate priviledges) to
request protection from the out-of-memory killer as long as
the process is using less than the specified amount of virtual
memory.  This is accomplished through a call to setrlimit().

It was possible to get unitialized results returned from
getrlimit/setrlimit calls with OOM_MAXVM flags if passed invalid options
and the limits had not been previously set.  This also corrects a minor
race condition in getrlimit where the structure to be filled out with
OOM_MAXVM data was copied from userspace, it would occasionally cause no
data to be returned.

Child Protection:

When a process is flagged by OOM the first thing that happens is OOM
attempts to kill a child of that process to resolve the out of memory
condition.  It is never considered whether the child process has itself
registered to be protected from OOM.  An example of this happening is when
a number of processes are started manually by a user from a shell.  If one
of the children of shell misbehaves all children will be considered for
termination without seeing whether they are protected.

To address this the same check that is done for a process is added in the
children loop.  For a child if the total number of VM pages allocated are
less than the set value (as set by the child when protecting itself),
the child will not be immediately killed by OOM.

[ This squashes the original two OOM protection patches from the ECGL kernel
  and adds the child protection, all formatted to apply cleanly to the
  2.6.34 kernel as a single patch since they are all related to the same
  overall function. ]

[ The original two patches, as described in "OOM Protection Feature" : ]

Signed-off-by: Yongli he   <yongli.he@windriver.com>
Signed-off-by: MacDonald, Joe <Joe.MacDonald@windriver.com>

[ The child protection function, as described "Child Protection" : ]

Signed-off-by: Greg Moffatt <greg.moffatt@windriver.com>
---
 include/asm-generic/resource.h |    7 +++
 include/linux/mm_types.h       |    4 ++
 include/linux/oom-protect.h    |   22 ++++++++
 init/Kconfig                   |    9 ++++
 kernel/Makefile                |    1 +
 kernel/compat.c                |    5 ++
 kernel/fork.c                  |    4 ++
 kernel/oom-protect.c           |  104 ++++++++++++++++++++++++++++++++++++++++
 kernel/sys.c                   |   37 ++++++++++++++
 mm/oom_kill.c                  |   26 ++++++++++
 10 files changed, 219 insertions(+), 0 deletions(-)
 create mode 100644 include/linux/oom-protect.h
 create mode 100644 kernel/oom-protect.c

diff --git a/include/asm-generic/resource.h b/include/asm-generic/resource.h
index 587566f..fd00e07 100644
--- a/include/asm-generic/resource.h
+++ b/include/asm-generic/resource.h
@@ -45,7 +45,14 @@
 					   0-39 for nice level 19 .. -20 */
 #define RLIMIT_RTPRIO		14	/* maximum realtime priority */
 #define RLIMIT_RTTIME		15	/* timeout for RT tasks in us */
+#ifdef CONFIG_OOM_PROTECT
+#define RLIMIT_OOM_MAXVM	16	/* The maximum amount of virtual memory
+					 a process may allocate and still be
+					 safe from the OOM killer */
+#define RLIM_NLIMITS		17
+#else
 #define RLIM_NLIMITS		16
+#endif /* CONFIG_OOM_PROTECT */
 
 /*
  * SuS says limits have to be unsigned.
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index 937af08..ac49387 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -330,6 +330,10 @@ struct mm_struct {
 	unsigned long delta_mmap;		/* randomized offset */
 	unsigned long delta_stack;		/* randomized offset */
 #endif
+#ifdef CONFIG_OOM_PROTECT
+	unsigned long oom_protect_bytes;	/* exempt from oom death if
+						 * total vm < this */
+#endif /* CONFIG_OOM_PROTECT */
 };
 
 /* Future-safe accessor for struct mm_struct's cpu_vm_mask. */
diff --git a/include/linux/oom-protect.h b/include/linux/oom-protect.h
new file mode 100644
index 0000000..4081c90
--- /dev/null
+++ b/include/linux/oom-protect.h
@@ -0,0 +1,22 @@
+#ifndef _LINUX_OOM_PROTECT_H
+#define _LINUX_OOM_PROTECT_H
+
+/* The following commands may be specified for oom protection */
+#define SET_OOM_PROTECT 1
+#define QUERY_OOM_PROTECT 2
+
+/* This is the data structure for setting oom protection.
+ * The caller fills in the pid of the process to protect
+ * and the number of bytes for which to request protection.
+ */
+struct set_oom_protect_info {
+	unsigned int cmd;
+	int pid;
+	unsigned int max_vm_bytes;
+};
+
+#ifdef __KERNEL__
+int do_oom_protect(unsigned long);
+#endif /* __KERNEL__ */
+
+#endif /* _LINUX_OOM_PROTECT_H */
diff --git a/init/Kconfig b/init/Kconfig
index de2d6af..0510306 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1198,6 +1198,15 @@ config IMMEDIATE
 	  each time any specially-marked variable is updated. Should really be
 	  disabled for embedded systems with read-only text.
 
+config OOM_PROTECT
+	bool "OOM killer protection"
+	default y
+	help
+	  When enabled this adds a new capability to the kernel which
+	  may be called (by processes with appropriate priviledges) to
+	  request protection from the out-of-memory killer as long as
+	  the process is using less than the specified amount of virtual
+	  memory.  This is accomplished through a call to setrlimit().
 endmenu		# General setup
 
 config HAVE_GENERIC_DMA_COHERENT
diff --git a/kernel/Makefile b/kernel/Makefile
index 9d6837c..c1f6735 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -111,6 +111,7 @@ obj-$(CONFIG_HAVE_HW_BREAKPOINT) += hw_breakpoint.o
 obj-$(CONFIG_USER_RETURN_NOTIFIER) += user-return-notifier.o
 obj-$(CONFIG_PADATA) += padata.o
 obj-$(CONFIG_VBUS) += vbus/
+obj-$(CONFIG_OOM_PROTECT) += oom-protect.o
 
 ifneq ($(CONFIG_SCHED_OMIT_FRAME_POINTER),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
diff --git a/kernel/compat.c b/kernel/compat.c
index 7f40e92..7ab68cf 100644
--- a/kernel/compat.c
+++ b/kernel/compat.c
@@ -309,6 +309,11 @@ asmlinkage long compat_sys_old_getrlimit(unsigned int resource,
 	int ret;
 	mm_segment_t old_fs = get_fs();
 
+#ifdef CONFIG_OOM_PROTECT
+	if (resource == RLIMIT_OOM_MAXVM)
+		printk(KERN_CRIT "OOM_PROTECT:fatal in %s:%d\n",
+			__FILE__,__LINE__);
+#endif /* CONFIG_OOM_PROTECT */
 	set_fs(KERNEL_DS);
 	ret = sys_old_getrlimit(resource, &r);
 	set_fs(old_fs);
diff --git a/kernel/fork.c b/kernel/fork.c
index b1ea0a6..704f06c 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -504,6 +504,10 @@ static struct mm_struct * mm_init(struct mm_struct * mm, struct task_struct *p)
 	mm_init_aio(mm);
 	mm_init_owner(mm, p);
 
+#ifdef CONFIG_OOM_PROTECT
+	mm->oom_protect_bytes = 0;
+#endif
+
 	if (likely(!mm_alloc_pgd(mm))) {
 		mm->def_flags = 0;
 		mmu_notifier_mm_init(mm);
diff --git a/kernel/oom-protect.c b/kernel/oom-protect.c
new file mode 100644
index 0000000..0b19f3d
--- /dev/null
+++ b/kernel/oom-protect.c
@@ -0,0 +1,104 @@
+/*
+ * kernel/oom-protect.c, Out Of Memory Protect  surport
+ *
+ * Copyright (c) 2006-2008 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+*/
+#ifdef __KERNEL__
+#include <linux/types.h>
+#endif
+
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <asm/uaccess.h>
+
+#include <linux/oom-protect.h>
+
+/*
+ * Protect the process whose pid is given from selection by the OOM killer
+ * when the system is out of memory.  If the total virtual memory allocated
+ * by the process (in pages) is less than the max_vm_bytes value passed,
+ * it will be exempt, otherwise it will be treated normally.
+ *
+ * On success we return the previous protection limit, on failure we return
+ * an appropriate error code.
+ *
+ * We take the read lock on tasklist to ensure the task doesn't go away
+ * between finding the task and setting oom protection on it.
+ *
+ * We take the task_lock to protect against others racing to  modify p->mm.
+ */
+int do_oom_protect(unsigned long arg)
+{
+	int ret = 0;
+	struct task_struct *p = NULL;
+	struct set_oom_protect_info args;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	if (copy_from_user(&args, (struct set_oom_protect_info __user *)arg,
+				sizeof(args)))
+		return -EFAULT;
+
+	ret = -ESRCH;
+	read_lock(&tasklist_lock);
+	p = args.pid ? find_task_by_pid_ns(args.pid,&init_pid_ns) : current;
+
+	if (!p)
+		goto tasklist_unlock_out;
+
+	ret = -EINVAL;
+	task_lock(p);
+	if (!p->mm)
+		goto task_unlock_out;
+
+	switch (args.cmd) {
+		case SET_OOM_PROTECT:
+			/*
+			 * Even though the standard setrlimit() code doesn't
+			 * allow you to reduce your limits, we will allow it
+			 * for OOM protection to let applications disable it.
+			 */
+			p->mm->oom_protect_bytes = args.max_vm_bytes;
+			ret = 0;
+			break;
+
+		case QUERY_OOM_PROTECT:
+			args.max_vm_bytes = p->mm->oom_protect_bytes;
+
+			if (copy_to_user((struct set_oom_protect_info __user *) arg,
+						&args, sizeof(struct set_oom_protect_info))) {
+				ret = -EFAULT;
+				goto task_unlock_out;
+			}
+
+			ret = 0;
+			break;
+
+		default:
+			printk(KERN_WARNING "do_oom_protect: args.cmd: %d\n",args.cmd);
+			ret = -EINVAL;
+			break;
+	}
+
+task_unlock_out:
+	task_unlock(p);
+
+tasklist_unlock_out:
+	read_unlock(&tasklist_lock);
+	return ret;
+}
diff --git a/kernel/sys.c b/kernel/sys.c
index e796474..7d36e58 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -43,6 +43,8 @@
 #include <linux/kprobes.h>
 #include <linux/user_namespace.h>
 
+#include <linux/oom-protect.h>
+
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/unistd.h>
@@ -1305,6 +1307,21 @@ SYSCALL_DEFINE2(getrlimit, unsigned int, resource, struct rlimit __user *, rlim)
 		return -EINVAL;
 	else {
 		struct rlimit value;
+#ifdef CONFIG_OOM_PROTECT
+		/* Some special handling is required for the OOM protection
+		 * information since it passes structures, not integers */
+		if (resource == RLIMIT_OOM_MAXVM) {
+			task_lock(current->group_leader);
+			value = current->signal->rlim[resource];
+			task_unlock(current->group_leader);
+
+			if (!do_oom_protect(value.rlim_cur)) {
+				return copy_to_user(rlim, &value.rlim_cur,
+					sizeof(rlim))?-EFAULT:0;
+			}
+
+		}
+#endif /* CONFIG_OOM_PROTECT */
 		task_lock(current->group_leader);
 		value = current->signal->rlim[resource];
 		task_unlock(current->group_leader);
@@ -1325,6 +1342,15 @@ SYSCALL_DEFINE2(old_getrlimit, unsigned int, resource,
 	if (resource >= RLIM_NLIMITS)
 		return -EINVAL;
 
+#ifdef CONFIG_OOM_PROTECT
+	/* jjmac: (2006.12.15)
+	 * Never seen this happen, but if it does, we need to know about it */
+	if (resource == RLIMIT_OOM_MAXVM) {
+		printk(KERN_CRIT "OOM_PROTECT:fatal in %s:%d\n",
+			__FILE__,__LINE__);
+	}
+#endif
+
 	task_lock(current->group_leader);
 	x = current->signal->rlim[resource];
 	task_unlock(current->group_leader);
@@ -1348,6 +1374,17 @@ SYSCALL_DEFINE2(setrlimit, unsigned int, resource, struct rlimit __user *, rlim)
 		return -EFAULT;
 	if (new_rlim.rlim_cur > new_rlim.rlim_max)
 		return -EINVAL;
+#ifdef CONFIG_OOM_PROTECT
+	if (resource == RLIMIT_OOM_MAXVM) {
+		/* Special handling for the OOM-protection bits, where the
+		 * rlim_max and rlim_cur values are pointers to structures. */
+		retval = do_oom_protect(new_rlim.rlim_max);
+		if (!retval)
+			current->signal->rlim[resource].rlim_cur =
+				new_rlim.rlim_max;
+		return retval;
+	}
+#endif /* CONFIG_OOM_PROTECT */
 	old_rlim = current->signal->rlim + resource;
 	if ((new_rlim.rlim_max > old_rlim->rlim_max) &&
 	    !capable(CAP_SYS_RESOURCE))
diff --git a/mm/oom_kill.c b/mm/oom_kill.c
index b68e802..4611c2e 100644
--- a/mm/oom_kill.c
+++ b/mm/oom_kill.c
@@ -96,6 +96,24 @@ unsigned long badness(struct task_struct *p, unsigned long uptime)
 	 */
 	points = mm->total_vm;
 
+#ifdef CONFIG_OOM_PROTECT
+	/* Don't even consider this task if he's still within his
+	 * oom_protect_bytes range.  Question:  is this the best place to put
+	 * this short-cut?  Or should we calculate a point value for the process
+	 * anyway, even though we know he's not going to get killed?  Either way
+	 * is likely to have an impact on the total system statistics.  The
+	 * correct way to do this would be to rip through here and mark this guy
+	 * (these guys?) safe for a while until we determine that there are
+	 * *only* well-behaved processes left, then start killing the biggest
+	 * offenders of that bunch. */
+
+	/* mm->total_vm in pages */
+	if (p->mm->total_vm < (p->mm->oom_protect_bytes / PAGE_SIZE)) {
+		task_unlock(p);
+		return 0;
+	}
+#endif /* CONFIG_OOM_PROTECT */
+
 	/*
 	 * After this unlock we can no longer dereference local variable `mm'
 	 */
@@ -462,6 +480,14 @@ static int oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order,
 			continue;
 		if (mem && !task_in_mem_cgroup(c, mem))
 			continue;
+#ifdef CONFIG_OOM_PROTECT
+		/* as for parent processes, don't even consider this child
+		 * if it's still within its oom_protect_bytes range (ie.
+		 * the child has protected itself)
+		 * mm->total_vm in pages */
+		if (c->mm->total_vm < (c->mm->oom_protect_bytes / PAGE_SIZE))
+			continue;
+#endif /* CONFIG_OOM_PROTECT */
 		if (!oom_kill_task(c))
 			return 0;
 	}
-- 
1.6.0.3

