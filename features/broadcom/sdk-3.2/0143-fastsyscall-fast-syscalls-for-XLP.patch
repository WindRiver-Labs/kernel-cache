From 31fdc49c0b83e700bbe2e880cc48a6c10008ac92 Mon Sep 17 00:00:00 2001
From: Jayachandran C <jchandra@broadcom.com>
Date: Tue, 26 Aug 2014 18:11:06 +0530
Subject: [PATCH 0143/1532] fastsyscall: fast syscalls for XLP

New version of the fast syscall code, pulled everything into a file and
wrapped it in a kernel config option
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/kernel/scall32-o32.S       |  22 ++
 arch/mips/kernel/scall64-o32.S       |  24 ++
 arch/mips/netlogic/Kconfig           |   8 +
 arch/mips/netlogic/xlp/Makefile      |   1 +
 arch/mips/netlogic/xlp/fastsyscall.S | 486 +++++++++++++++++++++++++++++++++++
 5 files changed, 541 insertions(+)
 create mode 100644 arch/mips/netlogic/xlp/fastsyscall.S

diff --git a/arch/mips/kernel/scall32-o32.S b/arch/mips/kernel/scall32-o32.S
index 1f6f730..00b1b67 100644
--- a/arch/mips/kernel/scall32-o32.S
+++ b/arch/mips/kernel/scall32-o32.S
@@ -26,6 +26,28 @@
 
 	.align	5
 NESTED(handle_sys, PT_SIZE, sp)
+#ifdef CONFIG_NLM_FASTSYSCALL
+	.set push
+	.set mips64
+	/* Broadcom EP Specific fast system calls */
+	mfc0	k1, CP0_EPC
+	lw	k0, 0(k1)
+	dsll32	k0, k0, 0
+	dsrl32	k0, k0, 6
+	beqz	k0, 1f
+	nop
+	sll	k0, k0, 2
+	lw	k1, nlm_fs_table(k0)
+	jr	k1
+	nop
+	/* should never come here */
+2:	wait
+	b	2b
+	nop
+	.set pop
+1:
+#endif
+
 	.set	noat
 	SAVE_SOME
 	TRACE_IRQS_ON_RELOAD
diff --git a/arch/mips/kernel/scall64-o32.S b/arch/mips/kernel/scall64-o32.S
index e277e32..ea75242 100644
--- a/arch/mips/kernel/scall64-o32.S
+++ b/arch/mips/kernel/scall64-o32.S
@@ -26,6 +26,30 @@
 
 	.align	5
 NESTED(handle_sys, PT_SIZE, sp)
+#ifdef CONFIG_NLM_FASTSYSCALL
+	.set push
+	.set	noat
+	.set mips64
+	/* Broadcom EP Specific fast system calls */
+	dmfc0	k1, CP0_EPC
+	lw	k0, 0(k1)
+	dsll32	k0, k0, 0
+	dsrl32	k0, k0, 6
+	beqz	k0, 1f
+	nop
+	sll	k0, k0, 3
+	PTR_LA	k1, nlm_fs_table
+	PTR_ADDU k1, k0, k1
+	ld	k1, 0(k1)
+	jr	k1
+	nop
+	/* should never come here */
+2:	wait
+	b	2b
+	nop
+1:
+	.set pop
+#endif
 	.set	noat
 	SAVE_SOME
 	TRACE_IRQS_ON_RELOAD
diff --git a/arch/mips/netlogic/Kconfig b/arch/mips/netlogic/Kconfig
index ed16db0..bc5272b 100644
--- a/arch/mips/netlogic/Kconfig
+++ b/arch/mips/netlogic/Kconfig
@@ -73,6 +73,14 @@ config NLM_MULTINODE_4
 endchoice
 
 endif
+
+config NLM_FASTSYSCALL
+	bool "Fast system call support"
+	default y
+	help
+	  Shortcut for userspace to access kernel space and do IO
+	  Say N unless you really need it
+
 endif
 
 config NLM_COMMON
diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index 98f70d4..a9e0ef8 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -7,3 +7,4 @@ obj-$(subst m,y,$(CONFIG_SATA_AHCI))	+= ahci-init.o
 obj-$(subst m,y,$(CONFIG_SATA_AHCI))	+= ahci-init-xlp2.o
 
 obj-$(CONFIG_NUMA)		+= numa.o
+obj-$(CONFIG_NLM_FASTSYSCALL)	+= fastsyscall.o
diff --git a/arch/mips/netlogic/xlp/fastsyscall.S b/arch/mips/netlogic/xlp/fastsyscall.S
new file mode 100644
index 0000000..82f607f
--- /dev/null
+++ b/arch/mips/netlogic/xlp/fastsyscall.S
@@ -0,0 +1,486 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#include <asm/addrspace.h>
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+#include <asm/asm-offsets.h>
+
+#include <asm/netlogic/interrupt.h>
+
+#define XLP_TX_BUF_REG			$0
+#define XLP_MSG_RXSTATUS_REG		$3
+#define XLP_RX_BUF_REG			$1
+#define ASM_XLP_IO_PIC_OFFSET		0xffffffffb8004100
+#define PIC_SYS_TIMER_0_COUNTER		0x22
+#define PIC_SYS_TIMER_COUNTER(id)	(PIC_SYS_TIMER_0_COUNTER + (id))
+#define PIC_TIMER_6_COUNTER		PIC_SYS_TIMER_COUNTER(6)
+
+#define CP0_PERF_CTR			$25
+#define PERF_CTR_EVENT0			0
+#define PERF_CTR_EVENT0_VALUE		1
+#define PERF_CTR_EVENT1			2
+#define PERF_CTR_EVENT1_VALUE		3
+
+#ifdef CONFIG_32BIT
+	#define T0 t0
+	#define T1 t1
+	#define T2 t2
+	#define T3 t3
+	#define T4 t4
+	#define T5 t5
+	#define T6 t6
+	#define T7 t7
+#else
+	#define T0 ta0
+	#define T1 ta1
+	#define T2 ta2
+	#define T3 ta3
+	#define T4 t0
+	#define T5 t1
+	#define T6 t2
+	#define T7 t3
+#endif
+	.text
+	.set	push
+	.set	noreorder
+	.set	mips64
+	.align	5
+
+.macro	fs_eret
+	/* skip the syscall instruction */
+	MFC0    k0, CP0_EPC
+	PTR_ADDIU   k0, 4
+	MTC0    k0, CP0_EPC
+	eret
+.endm
+
+	.set	arch=xlp
+
+NESTED(nlm_fs_msgsnd3, PT_SIZE, sp)
+	/* msgsnd arg0 is in (t1, t2) */
+	dsll32  k0, T1, 0
+	dsll32	k1, T2, 0
+	dsrl32	T2, k1, 0
+	or      T1, k0, T2
+	dmtc2	T1, XLP_TX_BUF_REG, 0
+
+	/* msgsnd arg1 is in (t3, t4) */
+	dsll32  k0, T3, 0
+	dsll32	k1, T4, 0
+	dsrl32	T4, k1, 0
+	or      T3, k0, T4
+	dmtc2   T3, XLP_TX_BUF_REG, 1
+
+	/* msgsnd arg1 is in (t5, t6) */
+	dsll32  k0, T5, 0
+	dsll32	k1, T6, 0
+	dsrl32	T6, k1, 0
+	or      T5, k0, T6
+	dmtc2   T5, XLP_TX_BUF_REG, 2
+
+	sync
+
+	/* msgsnd dst is in t0, status returned in t1 */
+1:	msgsnds	T1, T0
+	beqz	T1, 1b /* comment out the branch              */
+	nop            /* for non-blocking msgsnd fastsyscall */
+
+	fs_eret
+END(nlm_fs_msgsnd3)
+
+NESTED(nlm_fs_msgsnd, PT_SIZE, sp)
+	/* msgsnd arg0 is in (t1, t2) */
+	dsll32  k0, T1, 0
+	dsll32	k1, T2, 0
+	dsrl32	T2, k1, 0
+	or      T1, k0, T2
+	dmtc2	T1, XLP_TX_BUF_REG, 0
+
+	/* msgsnd arg1 is in (t3, t4) */
+	dsll32  k0, T3, 0
+	dsll32	k1, T4, 0
+	dsrl32	T4, k1, 0
+	or      T3, k0, T4
+	dmtc2   T3, XLP_TX_BUF_REG, 1
+
+	sync
+
+	/* msgsnd dst is in t0, status returned in t1 */
+1:	msgsnds	T1, T0
+	beqz	T1, 1b /* comment out the branch              */
+	nop            /* for non-blocking msgsnd fastsyscall */
+
+	fs_eret
+END(nlm_fs_msgsnd)
+
+NESTED(nlm_fs_msgrcv, PT_SIZE, sp)
+	/* msgld vc is in t0, status returned in k0 */
+	msglds	k0, T0
+	beqz	k0, 1f
+	move	T0, k0
+
+	/* msgld status  t0       *
+	 * arg0          (t1, t2) *
+	 * msg_rxstatus  t3       *
+	 * arg1          (t4, t5) */
+	mfc2	T3, XLP_MSG_RXSTATUS_REG
+	dmfc2	T2, XLP_RX_BUF_REG, 0
+	dmfc2   T5, XLP_RX_BUF_REG, 1
+	dsra32  T1, T2, 0
+	dsra32  T4, T5, 0
+1:
+	fs_eret
+END(nlm_fs_msgrcv)
+
+NESTED(nlm_fs_msgrcv1, PT_SIZE, sp)
+	/* msgld vc is in t0, status returned in k0 */
+	msglds	k0, T0
+	beqz	k0, 1f
+	move	T0, k0
+
+	/* msgld status  t0       *
+	 * arg0          (t1, t2) *
+	 * msg_rxstatus  t3       *
+	 * arg1          (t4, t5) */
+	mfc2	T3, XLP_MSG_RXSTATUS_REG
+	dmfc2	T2, XLP_RX_BUF_REG, 0
+	dsra32  T1, T2, 0
+1:
+	fs_eret
+END(nlm_fs_msgrcv1)
+
+NESTED(nlm_fs_mem_read64, PT_SIZE, sp)
+	/* address is in (t0, t1) */
+	dsll32  k0, T0, 0
+	dsll32	k1, T1, 0
+	dsrl32	T1, k1, 0
+	or      T0, k0, T1
+
+	/* data is in (t2, t3) */
+	ld	T3, (T0)
+	dsra32	T2, T3, 0
+
+	fs_eret
+END(nlm_fs_mem_read64)
+
+NESTED(nlm_fs_mem_write64, PT_SIZE, sp)
+	/* address is in (t0, t1) */
+	dsll32  k0, T0, 0
+	dsll32	k1, T1, 0
+	dsrl32	T1, k1, 0
+	or      T0, k0, T1
+
+	/* data is in (t2, t3) */
+	dsll32  k0, T2, 0
+	dsll32	k1, T3, 0
+	dsrl32	T3, k1, 0
+	or      T1, k0, T3
+
+	sd	T1, (T0)
+
+	fs_eret
+END(nlm_fs_mem_write64)
+
+NESTED(nlm_fs_mem_read32, PT_SIZE, sp)
+	/* address is in (t0, t1) */
+	dsll32  k0, T0, 0
+	dsll32	k1, T1, 0
+	dsrl32	T1, k1, 0
+	or      T0, k0, T1
+
+	/* data is in t2 */
+	lw	T2, (T0)
+
+	fs_eret
+END(nlm_fs_mem_read32)
+
+NESTED(nlm_fs_mem_write32, PT_SIZE, sp)
+	/* address is in (t0, t1) */
+	dsll32  k0, T0, 0
+	dsll32	k1, T1, 0
+	dsrl32	T1, k1, 0
+	or      T0, k0, T1
+
+	/* data is in t2 */
+	sw	T2, (T0)
+
+	fs_eret
+END(nlm_fs_mem_write32)
+
+NESTED(nlm_fs_mem_read16, PT_SIZE, sp)
+       /* address is in (t0-msb, t1-lsb) */
+       dsll32  k0, T0, 0
+       dsll32  k1, T1, 0
+       dsrl32  T1, k1, 0
+       or      T0, k0, T1
+
+       /* data is in t2 */
+       lh      T2, (T0)
+       fs_eret
+END(nlm_fs_mem_read16)
+
+NESTED(nlm_fs_mem_write16, PT_SIZE, sp)
+        /* address is in (t0-msb, t1-lsb) */
+        dsll32  k0, T0, 0
+        dsll32  k1, T1, 0
+        dsrl32  T1, k1, 0
+        or      T0, k0, T1
+
+        /* data is in t2 */
+        sh      T2, (T0)
+        fs_eret
+END(nlm_fs_mem_write16)
+
+NESTED(nlm_fs_mem_read8, PT_SIZE, sp)
+       /* address is in (t0-msb, t1-lsb) */
+       dsll32  k0, T0, 0
+       dsll32  k1, T1, 0
+       dsrl32  T1, k1, 0
+       or      T0, k0, T1
+
+       /* data is in t2 */
+       lb      T2, (T0)
+       fs_eret
+END(nlm_fs_mem_read8)
+
+NESTED(nlm_fs_mem_write8, PT_SIZE, sp)
+        /* address is in (t0-msb, t1-lsb) */
+        dsll32  k0, T0, 0
+        dsll32  k1, T1, 0
+        dsrl32  T1, k1, 0
+        or      T0, k0, T1
+
+        /* data is in t2 */
+        sb      T2, (T0)
+        fs_eret
+END(nlm_fs_mem_write8)
+
+NESTED(nlm_fs_c0_count, PT_SIZE, sp)
+
+	mfc0    T0, $9, 0
+
+	fs_eret
+END(nlm_fs_c0_count)
+
+NESTED(nlm_fs_iomem_read, PT_SIZE, sp)
+
+	/* t0 has the address */
+	lw      T1, (T0)
+
+	fs_eret
+END(nlm_fs_iomem_read)
+
+NESTED(nlm_fs_iomem_write, PT_SIZE, sp)
+
+	/* t0 has the address, t1 has the data */
+	sw      T1, (T0)
+
+	fs_eret
+END(nlm_fs_iomem_write)
+
+
+NESTED(nlm_fs_msg_write, PT_SIZE, sp)
+
+	/* disable the message ring interrupts and enable 64 bits operations */
+	mfc0    k0, CP0_STATUS
+	li      k1, 1
+	dsll    k1, k1, 30
+	or      k0, k0, k1
+	li      k1, 1
+	dsll    k1, k1, 23
+	or      k0, k0, k1
+	mtc0    k0, CP0_STATUS
+	bnez	T1, 1f
+	nop
+	mtc2    T1, $3, 0
+1:
+
+	fs_eret
+END(nlm_fs_msg_write)
+
+
+NESTED(nlm_fs_msg_read, PT_SIZE, sp)
+
+	/* read C0 and C2 registers */
+	mfc0    T0, CP0_STATUS
+	mfc2    T1, $2, 0
+	mfc2    T2, $2, 1
+	mfc2    T3, $3, 0
+	mfc2    T4, $3, 1
+
+	fs_eret
+END(nlm_fs_msg_read)
+
+NESTED(nlm_fs_perf_ctr_start, PT_SIZE, sp)
+
+	/* reset value counters */
+	dmtc0    $0, CP0_PERF_CTR, PERF_CTR_EVENT0_VALUE
+	dmtc0    $0, CP0_PERF_CTR, PERF_CTR_EVENT1_VALUE
+
+	/* arm the counters */
+	mtc0    T0, CP0_PERF_CTR, PERF_CTR_EVENT0
+	mtc0    T1, CP0_PERF_CTR, PERF_CTR_EVENT1
+
+	fs_eret
+END(nlm_fs_perf_ctr_start)
+
+	/* {evt@0:hi=T1, evt@0:lo=T0}
+	 * {evt@1:hi=T3, evt@1:lo=T2}
+	 * nlm_fs_perf_ctr_stop(uint32_t val) */
+NESTED(nlm_fs_perf_ctr_stop, PT_SIZE, sp)
+
+	/* stop the counters */
+	mtc0    T0, CP0_PERF_CTR, PERF_CTR_EVENT0
+	mtc0    T0, CP0_PERF_CTR, PERF_CTR_EVENT1
+
+	/* load return values */
+	dmfc0    k1, CP0_PERF_CTR, PERF_CTR_EVENT0_VALUE
+	dsrl32 	 T1, k1, 0
+	dsll32   k1, k1, 0
+	dsrl32   T0, k1, 0
+
+	dmfc0    k1, CP0_PERF_CTR, PERF_CTR_EVENT1_VALUE
+	dsrl32 	 T3, k1, 0
+	dsll32   k1, k1, 0
+	dsrl32   T2, k1, 0
+
+	fs_eret
+END(nlm_fs_perf_ctr_stop)
+
+NESTED(nlm_fs_processorId, PT_SIZE, sp)
+
+	mfc0    T0, $15, 0
+
+	fs_eret
+END(nlm_fs_processorId)
+
+NESTED(nlm_fs_read_timer, PT_SIZE, sp)
+
+        MFC0    k0, CP0_PRID, 1
+        andi    k0, k0, 0x3ff
+        srl     k0, k0, 5  /* grab node id */
+        sll     k0, k0, 18 /* Use local PIC */
+        dli     k1, ASM_XLP_IO_PIC_OFFSET + (PIC_TIMER_6_COUNTER << 3)
+        dadd    k0, k1, k0
+	ld	k1, 0(k0)
+	dsrl32	$9, k1, 0
+	dsll32  $8, k1, 0
+	dsrl32  $8, T0, 0
+	fs_eret
+
+END(nlm_fs_read_timer)
+
+NESTED(nlm_fs_hard_cpuid, PT_SIZE, sp)
+
+	mfc0	T0, $15, 1
+	andi	T0, T0, 0x3ff
+
+	fs_eret
+
+END(nlm_fs_hard_cpuid)
+
+NESTED(nlm_fs_is_big_endian, PT_SIZE, sp)
+	mfc0	T0, $16, 0
+	andi	T0, T0, 0x8000
+
+	fs_eret
+END(nlm_fs_is_big_endian)
+
+NESTED(nlm_fs_is_endian_reversed, PT_SIZE, sp)
+	mfc0	T0, $12, 0
+	li	k1, 0x2000000
+	and	T0, T0, k1
+
+	fs_eret
+END(nlm_fs_is_endian_reversed)
+
+NESTED(nlm_fs_uspace_64bit_ins_enabled, PT_SIZE, sp)
+	mfc0	T0, $12, 0
+	li	k1, 0x800000
+	and	T0, T0, k1
+
+	fs_eret
+END(nlm_fs_uspace_64bit_ins_enabled)
+
+	/* {hi=T1, lo=T0} nlm_fs_cpu_max_freq(void) */
+NESTED(nlm_fs_cpu_max_freq, PT_SIZE, sp)
+	PTR_LA k0, mips_hpt_frequency
+	lw     k1, 0(k0)
+	dsrl32 T1, k1, 0
+	dsll32 k1, k1, 0
+	dsrl32 T0, k1, 0
+
+	fs_eret
+END(nlm_fs_cpu_max_freq)
+
+LEAF(nlm_fs_unused)
+	fs_eret
+END(nlm_fs_unused)
+
+	.set pop
+	.data
+	.align 3
+	.type	nlm_fs_table, @object
+EXPORT(nlm_fs_table)
+	PTR	nlm_fs_unused			/*0  NLM_FS_UNUSED */
+	PTR	nlm_fs_msgsnd			/*1  NLM_FS_MSGSND */
+	PTR	nlm_fs_msgrcv			/*2  NLM_FS_MSGRCV */
+	PTR	nlm_fs_c0_count			/*3  NLM_FS_C0_COUNT */
+	PTR	nlm_fs_iomem_read		/*4  NLM_FS_MEM_READ */
+	PTR	nlm_fs_iomem_write		/*5  NLM_FS_MEM_WRITE */
+	PTR	nlm_fs_unused			/*6  NLM_FS_MSGINT */
+	PTR	nlm_fs_msg_read			/*7  NLM_FS_READ_COP */
+	PTR	nlm_fs_perf_ctr_start		/*8  NLM_FS_PERFCTR_START */
+	PTR	nlm_fs_perf_ctr_stop		/*9  NLM_FS_PERFCTR_STOP */
+	PTR	nlm_fs_unused			/*10 NLM_FS_READ_CPUMASKS */
+	PTR	nlm_fs_processorId		/*11 NLM_FS_READ_PROCID */
+	PTR	nlm_fs_unused			/*12 NLM_FS_PROMINFO */
+	PTR	nlm_fs_read_timer		/*13 NLM_FS_READ_TIMER */
+	PTR	nlm_fs_hard_cpuid		/*14 NLM_FS_HARD_CPUID */
+	PTR	nlm_fs_is_big_endian		/*15 NLM_FS_ENDIANESS */
+	PTR	nlm_fs_is_endian_reversed	/*16 NLM_FS_REVERSE_ENDIANESS */
+	PTR	nlm_fs_uspace_64bit_ins_enabled	/*17 NLM_FS_USPACE_64BIT_INS */
+	PTR	nlm_fs_cpu_max_freq		/*18 NLM_FS_CPU_MAX_FREQ */
+	PTR	nlm_fs_mem_read64		/*19 NLM_FS_MEM_READ64 */
+	PTR	nlm_fs_mem_write64		/*20 NLM_FS_MEM_WRITE64 */
+	PTR	nlm_fs_mem_read32		/*21 NLM_FS_MEM_READ32 */
+	PTR	nlm_fs_mem_write32		/*22 NLM_FS_MEM_WRITE32 */
+	PTR	nlm_fs_msgsnd3			/*23 NLM_FS_MSGSND3 */
+	PTR	nlm_fs_msgrcv1			/*24 NLM_FS_MSGRCV1 */
+	PTR	nlm_fs_mem_read16		/*25 NLM_FS_MEM_READ16 */
+	PTR	nlm_fs_mem_write16		/*26 NLM_FS_MEM_WRITE16 */
+	PTR	nlm_fs_mem_read8		/*27 NLM_FS_MEM_READ8 */
+	PTR	nlm_fs_mem_write8		/*28 NLM_FS_MEM_WRITE8 */
+	PTR	nlm_fs_unused			/*29 NLM_FS_UNUSED */
+	PTR	nlm_fs_unused			/*30 NLM_FS_UNUSED */
+	PTR	nlm_fs_unused			/*31 NLM_FS_UNUSED */
+	.size   nlm_fs_table, . - nlm_fs_table
-- 
1.9.1

