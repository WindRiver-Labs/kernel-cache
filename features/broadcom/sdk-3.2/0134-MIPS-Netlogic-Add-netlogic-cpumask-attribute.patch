From 909d24c604c27f6bcfb9bab2efd38ad94d9fead0 Mon Sep 17 00:00:00 2001
From: Jayachandran C <jchandra@broadcom.com>
Date: Mon, 29 Apr 2013 18:01:50 +0530
Subject: [PATCH 0134/1532] MIPS: Netlogic: Add netlogic,cpumask attribute

Add a custom attribute under '/chosen' node 'netlogic,cpumask'
to specify the cpus to be woken up by linux.

This will be read into cpu_possible_mask in linux.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/include/asm/netlogic/xlp-hal/xlp.h |  3 ++
 arch/mips/netlogic/xlp/dt.c                  | 50 ++++++++++++++++++++++++++++
 arch/mips/netlogic/xlp/setup.c               |  4 +--
 3 files changed, 54 insertions(+), 3 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/xlp-hal/xlp.h b/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
index 0a11c2f..d591f2b4 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
@@ -83,6 +83,7 @@
 #define PIC_IRT_LAST_IRQ		63
 
 #ifndef __ASSEMBLY__
+#include <linux/cpumask.h>
 
 /* SMP support functions */
 void xlp_boot_core0_siblings(void);
@@ -102,7 +103,9 @@ static inline void xlp_numa_init(void) {}
 
 /* Device tree related */
 void *xlp_dt_init(void *fdtp);
+int xlp_dt_get_cpumask(cpumask_t *mask);
 
+/* XLP CPU types */
 static inline int cpu_is_xlpii(void)
 {
 	int chip = read_c0_prid() & PRID_IMP_MASK;
diff --git a/arch/mips/netlogic/xlp/dt.c b/arch/mips/netlogic/xlp/dt.c
index a9bf5d8..acfd697 100644
--- a/arch/mips/netlogic/xlp/dt.c
+++ b/arch/mips/netlogic/xlp/dt.c
@@ -78,6 +78,7 @@ void __init *xlp_dt_init(void *fdtp)
 			break;
 		}
 	}
+
 	initial_boot_params = fdtp;
 	return fdtp;
 }
@@ -88,6 +89,55 @@ EXPORT_SYMBOL(nlm_fdt_blob);
 
 EXPORT_SYMBOL(initial_boot_params); /* deprecated */
 
+#ifdef CONFIG_SMP
+static int __init xlp_dt_scan_chosen(unsigned long node, const char *uname,
+				     int depth, void *data)
+{
+	unsigned long size = 0;
+	cpumask_t *mask = data;
+	const __be32 *p;
+	int i, pos, last;
+
+	if (depth != 1 || strcmp(uname, "chosen") != 0)
+		return 0;
+
+	p = of_get_flat_dt_prop(node, "netlogic,cpumask", &size);
+	if (p == NULL)
+		return 1;	/* no cpumask, leave */
+
+	pos = 0;
+	/* iterate over the u32 cpumask values backwards */
+	for (last = (int)size / 4 - 1; last >= 0; last--) {
+		u32 m = be32_to_cpup(&p[last]);
+		for (i = 0; i < sizeof(m) * BITS_PER_BYTE ; i++, pos++) {
+			if (pos == cpumask_size() * BITS_PER_BYTE)
+				goto out;
+			if ((m & (1u << i)) == 0)
+				continue;
+			cpumask_set_cpu(pos, mask);
+		}
+	}
+
+out:
+	return 1;
+}
+#endif
+
+int __init xlp_dt_get_cpumask(cpumask_t *mask)
+{
+#ifdef CONFIG_SMP
+	cpumask_clear(mask);
+	of_scan_flat_dt(xlp_dt_scan_chosen, mask);
+	if (!cpumask_empty(mask))
+		return 1;
+
+	cpumask_setall(mask);
+#else
+	cpumask_set_cpu(0, mask);
+#endif
+	return 0;
+}
+
 void __init device_tree_init(void)
 {
 	unsigned long dt_size;
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index 9e7def6..9c24f99 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -85,6 +85,7 @@ static void __init xlp_init_mem_from_bars(void)
 void __init plat_mem_setup(void)
 {
 #ifdef CONFIG_SMP
+	xlp_dt_get_cpumask(&nlm_cpumask);
 	nlm_wakeup_secondary_cpus();
 
 	/* update TLB size after waking up threads */
@@ -166,7 +167,4 @@ void __init prom_init(void)
 	memcpy(reset_vec, (void *)nlm_reset_entry,
 			(nlm_reset_entry_end - nlm_reset_entry));
 
-#ifdef CONFIG_SMP
-	cpumask_setall(&nlm_cpumask);
-#endif
 }
-- 
1.9.1

