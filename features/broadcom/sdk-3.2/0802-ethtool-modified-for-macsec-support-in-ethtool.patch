From 968d918e8596f122f4db6c74a4649d31a1368d64 Mon Sep 17 00:00:00 2001
From: Alok Agrawat <alok@broadcom.com>
Date: Thu, 3 Oct 2013 03:36:23 -0700
Subject: [PATCH 0802/1532] ethtool: modified for macsec support in ethtool.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/netlib/include/export_sym.h |   6 +
 arch/mips/netlogic/lib/netlib/include/netsoc_nae.h | 115 +++---
 arch/mips/netlogic/lib/netlib/include/nlm_nae.h    |   3 +
 arch/mips/netlogic/lib/netlib/src/netsoc_nae.c     | 428 +++++++++++----------
 4 files changed, 290 insertions(+), 262 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/include/export_sym.h b/arch/mips/netlogic/lib/netlib/include/export_sym.h
index 4ac1395..f76ff6d 100644
--- a/arch/mips/netlogic/lib/netlib/include/export_sym.h
+++ b/arch/mips/netlogic/lib/netlib/include/export_sym.h
@@ -66,4 +66,10 @@ EXPORT_SYMBOL(netsoc_lib_writel);
 EXPORT_SYMBOL(netsoc_lib_readl);
 
 EXPORT_SYMBOL(netsoc_print_nae_config);
+EXPORT_SYMBOL(__netsoc_msec_rx_mem_config);
+EXPORT_SYMBOL(__netsoc_msec_rx_config);
+EXPORT_SYMBOL(__netsoc_msec_rx_default_config);
+EXPORT_SYMBOL(__netsoc_msec_tx_mem_config);
+EXPORT_SYMBOL(__netsoc_msec_tx_config);
+EXPORT_SYMBOL(__netsoc_msec_tx_default_config);
 #endif
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
index b272d16..5e9f241 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
@@ -61,6 +61,13 @@ enum net_path{
 #define VAL_UCORE_RESET(x) 		(((x) &0xffff) << 8)
 #define NLM_NAE_MAX_XONOFF_THR_GRPS 	8
 
+void __netsoc_msec_rx_mem_config(nae_t *nae, int port, int index, uint64_t sci, unsigned char *key, uint64_t sci_mask);
+void __netsoc_msec_rx_config(nae_t *nae, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int replay_win_size);
+void __netsoc_msec_rx_default_config(nae_t *nae, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int replay_win_size);
+void __netsoc_msec_tx_mem_config(nae_t *nae, int context, int tci, uint64_t sci, unsigned char *key);
+void __netsoc_msec_tx_config(nae_t *nae, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int pn_thrshld);
+void __netsoc_msec_tx_default_config(nae_t *nae, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int pn_thrshld);
+
 static inline uint32_t __netsoc_get_max_ports(void)
 {
         return current_netsoc->max_ports;
@@ -82,7 +89,7 @@ static inline int __netsoc_get_frin_queue_base(nae_t *nae)
 }
 
 static inline void __netsoc_set_frin_total_queue(nae_t *nae)
-{	
+{
 	nae->frin_total_queue = __netsoc_get_max_frinqs();
 }
 
@@ -96,13 +103,13 @@ static inline int __netsoc_set_frin_queue_base(nae_t *nae)
 	}
         else if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
                 nae->frin_queue_base = (nae->node <<10) | XLP_3XX_NET_RX_VC_BASE;
-        }else{    
+        }else{
                 nae->frin_queue_base = (nae->node << 10) | XLP_NET_RX_VC_BASE;
         }
         return nae->frin_queue_base;
 
 }
- 
+
 static inline int __netsoc_get_tx_queue_base(nae_t *nae)
 {
         if (is_nlm_xlp9xx()) {
@@ -113,7 +120,7 @@ static inline int __netsoc_get_tx_queue_base(nae_t *nae)
         }
         else if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
                 return ((nae->node <<10) | XLP_3XX_NET_TX_VC_BASE);
-        }else{  
+        }else{
                 return ((nae->node << 10) | XLP_NET_TX_VC_BASE);
         }
 }
@@ -125,19 +132,19 @@ static inline uint32_t __netsoc_get_free_desc(nae_t *nae, uint32_t frin_qnum)
 	val = netsoc_read_nae_reg(nae->nae_base, RX_ERRINJ_CTRL1);
 	val |= (1<<31);
 	netsoc_write_nae_reg(nae->nae_base, RX_ERRINJ_CTRL1, val);
-	
-	netsoc_write_nae_reg(nae->nae_base, FREE_IN_FIFO_CFG, (frin_qnum | (1<<31))); 
+
+	netsoc_write_nae_reg(nae->nae_base, FREE_IN_FIFO_CFG, (frin_qnum | (1<<31)));
 
 	val = netsoc_read_nae_reg(nae->nae_base, FREE_IN_FIFO_CFG);
 	num_onchip_desc = (((val >> 20) & 0x3ff) << 1);
-	
+
 	return num_onchip_desc;
 }
 
 static inline uint64_t __netsoc_read_spill_base(nae_t *nae, uint32_t frin_qnum)
 {
 	uint64_t spill_base;
-	
+
         netsoc_write_nae_reg(nae->nae_base, FREE_IN_FIFO_CFG, (frin_qnum | (1<<31)));
 
         spill_base = netsoc_read_nae_reg(nae->nae_base, FREE_SPILL0_MEM_CFG);
@@ -152,7 +159,7 @@ static inline uint32_t __netsoc_get_free_spill_desc(nae_t *nae, uint32_t frin_qn
 
 	netsoc_write_nae_reg(nae->nae_base, RX_ERRINJ_CTRL1, 0);
 
-	spill_base0 = __netsoc_read_spill_base(nae, frin_qnum); 
+	spill_base0 = __netsoc_read_spill_base(nae, frin_qnum);
 
         val = netsoc_read_nae_reg(nae->nae_base, RX_ERRINJ_CTRL1);
         val |= (1<<31);
@@ -214,8 +221,8 @@ static int __netsoc_pma2p0_cmd_poll_pend(uint64_t mac_base)
                         retries++;
                         nlm_mdelay(1);
                         continue;
-                }else{  
-                        //nlm_print("PMA2P0 cmd pend clear\n");  
+                }else{
+                        //nlm_print("PMA2P0 cmd pend clear\n");
                         break;
                 }
         }
@@ -229,7 +236,7 @@ static int __netsoc_pma2p0_cmd_poll_pend(uint64_t mac_base)
 }
 
 static inline void __netsoc_write_pma2p0_reg(uint64_t base, uint32_t lane_no, uint32_t addr, uint32_t data)
-{   
+{
     uint32_t tmp_data;
     tmp_data = (0x2 << 29) | (lane_no << 21) | ((addr & 0x1fff) << 8) | (data & 0xff);
     netsoc_write_mac_reg(base, PMA2P0_CMD, tmp_data);
@@ -237,7 +244,7 @@ static inline void __netsoc_write_pma2p0_reg(uint64_t base, uint32_t lane_no, ui
 }
 
 static inline uint32_t __netsoc_read_pma2p0_reg(uint64_t base, uint32_t lane_no, uint32_t addr)
-{   
+{
     uint32_t tmp_data, rd_data;
     tmp_data = (0x3 << 29) | (lane_no << 21) | ((addr & 0x1fff) << 8);
     netsoc_write_mac_reg(base, PMA2P0_CMD, tmp_data);
@@ -249,7 +256,7 @@ static inline uint32_t __netsoc_indirect_pma_register_read(nae_t *nae, int block
 {
         uint32_t val = 0;
 	uint64_t mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-	
+
         val = netsoc_read_mac_reg(mac_base, lane_ctrl);
         val |= (1<<30) | (1<<17) | (1<<16);
         val = val | (pma_reg_addr<<8);
@@ -318,13 +325,13 @@ static inline void __netsoc_write_ucore_sprayvec(nae_t *nae, int hw_port_id, uin
 static inline void __netsoc_write_fifo_size(nae_t *nae, int hw_port_id, uint32_t size)
 {
 	uint32_t moddescsz, desc_size = (size/XLP_CACHELINE_SIZE) & 0xff;
-	
+
 	netsoc_api_print(NETSOC_APIDBG_TRACE, "Writing LIFO %d descsize %d\n",hw_port_id, desc_size);
 	if ((desc_size == 0) || (desc_size > (DEFAULT_PARSER_THR / XLP_CACHELINE_SIZE)))
 		moddescsz = (DEFAULT_PARSER_THR / XLP_CACHELINE_SIZE) & 0xff;
 	else
 		moddescsz = ((DEFAULT_PARSER_THR / XLP_CACHELINE_SIZE) % desc_size) & 0xff;
-	
+
         netsoc_write_nae_reg(nae->nae_base, FREE_IN_FIFO_UNIQ_SZ_CFG, (moddescsz << 16) | (desc_size << 8) | (hw_port_id & 0x1f) );
 }
 
@@ -340,7 +347,7 @@ static inline void __netsoc_write_interface_fifo(nae_t *nae, int hw_port_id, uin
 	val = (1<<31) | hw_port_id;
 	netsoc_write_nae_reg(nae->nae_base, IFACE_FIFO_CFG, val);
 	val = netsoc_read_nae_reg(nae->nae_base, IFACE_FIFO_CFG);
-        netsoc_api_print(NETSOC_APIDBG_TRACE, "IFACE_FIFO_CFG port %d start %d size %d xoffth %d \n",hw_port_id, 
+        netsoc_api_print(NETSOC_APIDBG_TRACE, "IFACE_FIFO_CFG port %d start %d size %d xoffth %d \n",hw_port_id,
 					((val >> 8) & 0xff), ((val >> 16) & 0x1ff) , ((val >> 25) & 0x3f));
 }
 
@@ -482,7 +489,7 @@ static inline uint32_t __netsoc_get_rtc(nae_t *nae, uint32_t* p_val_hi,  uint32_
 static inline int __netsoc_set_ilk_framesize(net_port_t *port, uint32_t size)
 {
 #ifdef NLM_CORTINA_SUPPORT
-        return cortina_set_max_framesize(port->hw_port_id, port->ext_phy_addr, size);	
+        return cortina_set_max_framesize(port->hw_port_id, port->ext_phy_addr, size);
 #else
         return 0;
 #endif
@@ -492,7 +499,7 @@ static inline int __netsoc_get_ilk_mac_stats(net_port_t *port, void *data)
 {
 #if defined(NLM_CORTINA_SUPPORT) && defined(NLM_HAL_LINUX_KERNEL)
         struct net_device_stats *stats = (struct net_device_stats *)data;
-        return cortina_get_mac_stats(port->nae->node, port->hw_port_id, port->ext_phy_addr, (void *) stats);	
+        return cortina_get_mac_stats(port->nae->node, port->hw_port_id, port->ext_phy_addr, (void *) stats);
 #else
         return 0;
 #endif
@@ -554,7 +561,7 @@ static inline void __netsoc_PMFF_ALL_workaround(nae_t *nae, int block, int lane_
 {
         volatile int val = 0;
 
-        if (is_nlm_xlp3xx()) {
+        if (is_nlm_xlp3xx() ) {
                 val = __netsoc_read_pma_reg(nae, block, lane_ctrl, SER_GEN1_PWR_DOWN);
                 val = val | SERDES_PMFF_ALL_SET;
                 __netsoc_write_pma_reg(nae, block, lane_ctrl, SER_GEN1_PWR_DOWN, val);
@@ -661,7 +668,7 @@ static inline int __netsoc_config_wred_perclass(nae_t *nae, uint32_t class_num,
 		netsoc_write_nae_reg(nae->nae_base, WRED_CMD_REG, val | (class_num & 0x7));
 	}
 	return 0;
-} 
+}
 
 static inline int __netsoc_config_wred_enable(nae_t *nae, uint32_t thres_lo, uint32_t thres_hi)
 {
@@ -684,7 +691,7 @@ static inline int __netsoc_config_wred_disable(nae_t *nae)
         for(class_num=0; class_num < 8; class_num++) {
               	netsoc_write_nae_reg(nae->nae_base, WRED_CMD_REG, (class_num & 0x7));
         }
-        return 0;  
+        return 0;
 }
 
 static inline int __netsoc_config_ale_enable(nae_t *nae)
@@ -700,11 +707,11 @@ static inline int __netsoc_config_ale_disable(nae_t *nae)
 {
        if (!(current_netsoc->hw_features & NETSOC_ALE))
                 return -NETSOC_API_NOT_SUPPORTED;
- 
+
        netsoc_api_print(NETSOC_APIDBG_CONFIG, "%s %d:%d\n",__func__,nae->node,nae->nae_id);
        netsoc_write_nae_reg(nae->nae_base, ALE_BYPASS, 1);
        return 0;
-} 
+}
 
 static inline int __netsoc_config_string_dest_offset(nae_t *nae, uint32_t offset, ucore_string_t string_type)
 {
@@ -730,8 +737,8 @@ static inline int __netsoc_config_per_freein(nae_t *nae, uint32_t frin_lifo, fri
 		return -NETSOC_API_PARAM_INVALID;
 	/* cache line address / 64 */
 	spill_addr = frin->spill_base >> 6;
-	 
-	/* in cachelines, 1 cacheline can store 12 descs  and 
+
+	/* in cachelines, 1 cacheline can store 12 descs  and
         get the number of cacheline required */
         if (frin->spill_size != 0) {
                 spillsz = frin->spill_num_descs / 12 ;
@@ -741,7 +748,7 @@ static inline int __netsoc_config_per_freein(nae_t *nae, uint32_t frin_lifo, fri
         else
                 spillsz = 0;
 
-	
+
 
         if(spillsz) {
 		reg = spill_addr & 0xffffffff;
@@ -756,7 +763,7 @@ static inline int __netsoc_config_per_freein(nae_t *nae, uint32_t frin_lifo, fri
       		netsoc_write_nae_reg(nae->nae_base, FREE_SPILL0_MEM_CFG, 0);
                 netsoc_write_nae_reg(nae->nae_base, FREE_SPILL1_MEM_CFG, 0);
         }
-	
+
 	if (current_netsoc->hw_features & NETSOC_IOVIRT) {
 		netsoc_write_nae_reg(nae->nae_base, FREE_IN_GST_MAP, frin->guest_id & 0xFF);
 	}
@@ -789,7 +796,7 @@ static inline int __netsoc_config_per_freein(nae_t *nae, uint32_t frin_lifo, fri
 }
 
 static inline int __netsoc_config_ucore_memtype(nae_t *nae, uint32_t type)
-{  
+{
     volatile uint32_t ucore_cfg = 0;
 
     if ((type==0) || (type == 1)) {
@@ -799,12 +806,12 @@ static inline int __netsoc_config_ucore_memtype(nae_t *nae, uint32_t type)
         netsoc_write_nae_reg(nae->nae_base, RX_UCORE_CFG, ucore_cfg);
         return NETSOC_API_SUCCESS;
     }
-    else 
+    else
         return -NETSOC_API_PARAM_INVALID;
 }
 
 static inline int __netsoc_stop_ucore(nae_t *nae)
-{   
+{
     volatile uint32_t ucore_cfg = 0;
     int i = 0;
 
@@ -818,7 +825,7 @@ static inline int __netsoc_stop_ucore(nae_t *nae)
             break;
         }
     }
-    
+
     netsoc_api_print(NETSOC_APIDBG_ERROR, "RX_UCORE_CFG 0x%x\n", ucore_cfg);
 
     if (i < 500000)
@@ -828,7 +835,7 @@ static inline int __netsoc_stop_ucore(nae_t *nae)
 }
 
 static inline int __netsoc_start_ucore(nae_t *nae)
-{   
+{
     volatile uint32_t ucore_cfg = 0;
     ucore_cfg = netsoc_read_nae_reg(nae->nae_base, RX_UCORE_CFG);
     ucore_cfg &= ~(1 << 24);
@@ -846,7 +853,7 @@ static inline int __netsoc_config_burstmax(net_port_t *netport, uint32_t max)
         return 0;
 }
 
-static inline uint32_t __netsoc_read_xlgmac_reg(net_port_t *netport, uint32_t addr) 
+static inline uint32_t __netsoc_read_xlgmac_reg(net_port_t *netport, uint32_t addr)
 {
 	uint64_t mac_base;
 	uint32_t cmd;
@@ -857,7 +864,7 @@ static inline uint32_t __netsoc_read_xlgmac_reg(net_port_t *netport, uint32_t ad
 	cmd  = ( 1 << 30)  |          // Req
 		( 1 << 29)  |          // Read
 		((addr >> 2) & 0x1ff); // Byte addr
-	
+
 	// Write the command
 	netsoc_write_mac_reg(mac_base , XLGMACPCS_CMD, cmd);
 
@@ -866,7 +873,7 @@ static inline uint32_t __netsoc_read_xlgmac_reg(net_port_t *netport, uint32_t ad
 	while((val & (1<<31)) == (1<<31)){
 		val = netsoc_read_mac_reg(mac_base, XLGMACPCS_CMD);
 	}
-	
+
 	return netsoc_read_mac_reg(mac_base, XLGMACPCS_DATA);
 }
 
@@ -877,7 +884,7 @@ static inline void __netsoc_write_xlgmac_reg(net_port_t *netport, uint32_t addr,
 	volatile uint32_t val;
 	nae_t *nae = netport->nae;
         mac_base = netsoc_get_macreg_base_for_xlgmac(nae->mac_base, netport->hw_port_id);
-	
+
 	netsoc_write_mac_reg(mac_base , XLGMACPCS_DATA, data);
     	cmd  = ( 1 << 30)  |          // Req
            ( 0 << 29)  |          // Write
@@ -903,7 +910,7 @@ static inline uint64_t __netsoc_get_xgmac_base(net_port_t *netport)
             case 2: mac_base = netsoc_get_macreg_base_for_xgmac2(nae->mac_base, netport->hw_port_id); break;
             case 3: mac_base = netsoc_get_macreg_base_for_xgmac3(nae->mac_base, netport->hw_port_id); break;
 	    default:
-		return 0; 	
+		return 0;
         }
 	return mac_base;
 }
@@ -912,7 +919,7 @@ static void __netsoc_get_xlgmac_counters(net_port_t *netport, dev_stat_t* stats)
 {
 	stats->tx_packets = __netsoc_read_xlgmac_reg(netport, XLAUI_FRAME_TRANSMITTED);
 	stats->tx_bytes = __netsoc_read_xlgmac_reg(netport, XLAUI_TX_BYTE_CNT);
-	
+
 	stats->rx_packets = __netsoc_read_xlgmac_reg(netport, XLAUI_FRAME_RECEIVED);
 	stats->rx_bytes = __netsoc_read_xlgmac_reg(netport, XLAUI_RX_BYTE_CNT);
 	/*TODO : read other counters and add them below.*/
@@ -969,7 +976,7 @@ static void __netsoc_read_mac_counters(uint64_t mac_base, dev_stat_t* stats)
 				stats->rx_frame_errors + stats->rx_fifo_errors +
 				stats->rx_missed_errors);
 	stats->tx_aborted_errors = netsoc_read_mac_reg(mac_base, TX_EXCESSIVE_COLLISION_PACKET_COUNTER);
-	return; 
+	return;
 }
 
 static inline void __netsoc_get_mac_statistics(net_port_t *netport, dev_stat_t* dev_stat)
@@ -991,7 +998,7 @@ static inline void __netsoc_get_mac_statistics(net_port_t *netport, dev_stat_t*
         }else if(netport->iftype==XLAUI_IF){
                 mac_base = netsoc_get_macreg_base_for_xlgmac(nae->mac_base, netport->hw_port_id);
                 __netsoc_get_xlgmac_counters(netport, dev_stat);
-        }else{  
+        }else{
                 memset(dev_stat, 0, sizeof(dev_stat_t));
                 return;
         }
@@ -1025,7 +1032,7 @@ static inline int  __netsoc_config_macen(net_port_t *netport, uint32_t enable, u
                         mac_base = netsoc_get_macreg_base_for_gmac(nae->mac_base, netport->hw_port_id);
                         netwk_inf  = netsoc_read_mac_reg(mac_base, NETWK_INF_CTRL_REG);
                         mac_cfg1 = netsoc_read_mac_reg(mac_base, MAC_CONF1);
-  
+
 			if (enable) {
                              if (path == EGRESS_PATH) {
                                     netwk_inf |= TX_EN(1);
@@ -1069,7 +1076,7 @@ static inline int  __netsoc_config_macen(net_port_t *netport, uint32_t enable, u
                              }
                              else {
                                 xaui_cfg &= ~(XAUI_CONFIG_RFEN);
-                             }  
+                             }
 		 	}
                         netsoc_write_mac_reg(mac_base, XAUI_CONFIG_1, xaui_cfg);
                         netsoc_api_print(NETSOC_APIDBG_PORT,"%s: XGMAC enable XAUI_CONFIG_1 0x%x\n",__func__, xaui_cfg);
@@ -1108,15 +1115,15 @@ static inline int __netsoc_nae_config_txrx(nae_t *nae, uint32_t enable, uint32_t
 static inline int __netsoc_map_context_toclass(nae_t *nae, uint32_t context, uint32_t class)
 {
     	uint32_t val, index, ctxindex;
-    
+
         if (context >= current_netsoc->max_contexts)
               return -NETSOC_API_PARAM_INVALID;
 
 	index = context / 8;
-	netsoc_write_nae_reg(nae->nae_base, POE_CLASS_SETUP_CFG, (1<<7) | index); 
+	netsoc_write_nae_reg(nae->nae_base, POE_CLASS_SETUP_CFG, (1<<7) | index);
         val = netsoc_read_nae_reg(nae->nae_base, POE_CLASS_SETUP_CFG);
         ctxindex = ((context % 8) * 3) + 8;
-        val &= ~((0x7 << ctxindex) | (0xFF)); 
+        val &= ~((0x7 << ctxindex) | (0xFF));
         val |= (class << ctxindex);
 	netsoc_write_nae_reg(nae->nae_base, POE_CLASS_SETUP_CFG, val | index);
 
@@ -1137,18 +1144,18 @@ static inline int __netsoc_config_drr_context(nae_t *nae, uint32_t context, uint
 
         netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_STATUS0, 0x1);
         // Read context schedule status
-	netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0, (context << 5)); 
+	netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0, (context << 5));
 	while(i++ <= 1000) {
 	        val = netsoc_read_nae_reg(nae_base, TX_SCHED_MAP_STATUS0);
 		if (val & 0x1)
 		    break;
-	}				
+	}
 	if (i>1000)
 		return -NETSOC_ERROR_INTERNAL;
 
         channel = (val >> 10) & 0xFF;
         interface = (val >> 5) & 0x1F;
- 
+
 	netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD1,(uint32_t) drr_quantum);
 	val = (((drr_quantum >> 32) & 0x3) << 30) | (channel << 20) | (interface << 15) | (context << 5);
 	netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0, val | 1);
@@ -1175,7 +1182,7 @@ static inline int __netsoc_config_pri_context(nae_t *nae, uint32_t context, uint
               return -NETSOC_API_PARAM_INVALID;
 
 	netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_STATUS0, 0x1);
-	
+
         // Read context schedule status
         netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0, (context << 5));
 	while(i++ <= 1000) {
@@ -1210,7 +1217,7 @@ static inline int __netsoc_schedule_context_onport(nae_t *nae, uint32_t context,
 
 	if ((context >= current_netsoc->max_contexts) || (hwport >= current_netsoc->max_ports))
 		return -NETSOC_API_PARAM_INVALID;
-	
+
 	netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_STATUS0, 0x1);
 
         // Read context schedule status
@@ -1222,7 +1229,7 @@ static inline int __netsoc_schedule_context_onport(nae_t *nae, uint32_t context,
         }
         if (i>1000)
                 return -NETSOC_ERROR_INTERNAL;
-	
+
 	drr_hi = (val >> 30) & 0x3;
         sp = (val >> 4) & 0x1;
 	spnum = (val >> 1) & 0x7;
@@ -1263,7 +1270,7 @@ static inline void __netsoc_drop_runt_pkts(nae_t *nae, uint32_t enable)
 	val |= (enable << 11);
 	netsoc_write_nae_reg(nae->nae_base, RX_ST_FWD_MODE, val);
 }
- 
+
 static inline int __netsoc_get_frame_size(net_port_t *netport)
 {
         nae_t *nae = netport->nae;
@@ -1296,7 +1303,7 @@ static inline int __netsoc_enable_deepfifo(nae_t *nae, uint32_t context)
 
 	val = netsoc_read_nae_reg(nae->nae_base, TX_STG1_DEEPFIFO_CFG);
 	val |= (1 << (context/2));
-	netsoc_write_nae_reg(nae->nae_base, TX_STG1_DEEPFIFO_CFG, val);	
+	netsoc_write_nae_reg(nae->nae_base, TX_STG1_DEEPFIFO_CFG, val);
 	return NETSOC_API_SUCCESS;
 }
 
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
index d1ce4f5..645eb9f 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -378,6 +378,9 @@ struct nlm_hal_nae_config {
 	
 	struct nlm_nae_shinfo shinfo[NLM_NAE_MAX_SHARED_DOMS  + 1]; /* 1 extra for the owner */
 	uint32_t msec_port_enable;
+	uint32_t msec_tx_port_enable;
+ 	uint32_t msec_rx_port_enable;
+
 	unsigned char sectag_offset[MAX_NAE_PORTS_PERNODE];
 	unsigned char sectag_len[MAX_NAE_PORTS_PERNODE];
 	unsigned char icv_len[MAX_NAE_PORTS_PERNODE];
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index c47ebaa..bbf2384 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -122,7 +122,7 @@ static uint32_t nae_get_EXT_XG_MDIO_DIV(void)
  */
 /**
 * @brief __netsoc_int_gmac_mdio_read function is used to read an SGMII PCS register.
-* 
+*
 * @param [in] pointer to nae configuration
 * @param [in] bus Internal MDIO bus number
 * @param [in] phyaddr Internal PHY's address
@@ -130,7 +130,7 @@ static uint32_t nae_get_EXT_XG_MDIO_DIV(void)
 *
 * @return
 * 	- value of MDIO register
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -204,7 +204,7 @@ int __netsoc_int_gmac_mdio_read(nae_t *nae, uint32_t bus, uint32_t phyaddr, uint
 *
 * @return
 * 	- 0 on success
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -274,7 +274,7 @@ static int __netsoc_int_gmac_mdio_write(nae_t *nae, uint32_t bus, uint32_t phyad
 *
 * @return
 * 	- 0 on success
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -304,7 +304,7 @@ int __netsoc_int_gmac_mdio_reset(nae_t *nae, int bus)
 *
 * @return
 *	- value read (16 bits), or 0xffffffff if an error occurred.
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -397,7 +397,7 @@ static int __netsoc_gmac_mdio_write(nae_t *nae, uint32_t bus, uint32_t phyaddr,
 *
 * @return
 * 	- 0 on success
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -470,8 +470,8 @@ int __netsoc_write_ucore_shared_mem(nae_t *nae, unsigned int *data, uint32_t wor
 {
 	uint32_t i = 0, node, nae_id;
 	uint32_t end;
-	
-	node = nae->node; 
+
+	node = nae->node;
 	nae_id = nae->nae_id;
 
 	end =  ucore_shared_scratch_words[node][nae_id] + words;
@@ -499,7 +499,7 @@ int __netsoc_write_ucore_shared_mem(nae_t *nae, unsigned int *data, uint32_t wor
 *
 * @return
 *  - 0 on success
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -510,7 +510,6 @@ int __netsoc_reset_and_load_ucore(nae_t *nae, uint32_t ucore_mask, unsigned int
 	int i, max_ucore = current_netsoc->max_ucores;
 	volatile uint32_t ucore_cfg = 0;
 
-	netsoc_api_print(NETSOC_APIDBG_TRACE, "NAE %d:%d soc_ucore_mask 0x%x num_opcodes %d\n",node, nae_id, current_netsoc->ucore_mask, num_opcodes);
 	netsoc_api_print(NETSOC_APIDBG_TRACE, " %p %x\n",opcodes, *opcodes);
 
 	if (1) { // FIXME is_nlm_xlp8xx_bx()
@@ -545,13 +544,13 @@ int __netsoc_reset_and_load_ucore(nae_t *nae, uint32_t ucore_mask, unsigned int
 		}
 		if(num_opcodes & 0x1){
 			/* Add 'nop' if total number of instructions are odd */
-			netsoc_write_ucode(nae->mac_base, id, (i * 4), 0x0);	
+			netsoc_write_ucode(nae->mac_base, id, (i * 4), 0x0);
 		}
 		id++;
 	}
 	/* Download u-core shared memory data*/
 	if(ucore_shared_scratch_words[node][nae_id]){
-		ucore_cfg = netsoc_read_nae_reg(nae->nae_base, RX_UCORE_CFG);	
+		ucore_cfg = netsoc_read_nae_reg(nae->nae_base, RX_UCORE_CFG);
 		/*set iram to 0*/
 		netsoc_write_nae_reg(nae->nae_base, RX_UCORE_CFG, ucore_cfg & ~(1<<7));
 		for (i=0; i<ucore_shared_scratch_words[node][nae_id]; ++i) {
@@ -585,7 +584,7 @@ int __netsoc_reset_and_load_ucore(nae_t *nae, uint32_t ucore_mask, unsigned int
 *
 * @return
 *  - none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -606,10 +605,10 @@ void __netsoc_config_egress_fifo_carvings(nae_t *nae, int start_ctxt, int num_ct
 		else
                         offset = size -1;
 
-		data =   offset << 23  | 
-			start << 11 |	
+		data =   offset << 23  |
+			start << 11 |
 			i << 1      |
-			1;	
+			1;
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "program_nae_stg2_pmem: ctxt_num:%d start:%d size:%d\n", i, start, (offset+1));
 		netsoc_write_nae_reg(nae_base, STG2_PMEM_PROG, data);
 		start += offset+1;
@@ -617,7 +616,7 @@ void __netsoc_config_egress_fifo_carvings(nae_t *nae, int start_ctxt, int num_ct
 	nae->stg2fifo_base = start;
 
 	/* EH FIFO */
-	start  = nae->ehfifo_base;	
+	start  = nae->ehfifo_base;
 	for(i=start_ctxt;i<limit;i++){
 		size   = current_netsoc->egress.max_eh_fifo / nae->num_contexts;
 
@@ -626,10 +625,10 @@ void __netsoc_config_egress_fifo_carvings(nae_t *nae, int start_ctxt, int num_ct
 		else
 			offset = size -1;
 
-		data =   offset << 23  | 
-			start << 11 |	
+		data =   offset << 23  |
+			start << 11 |
 			i << 1      |
-			1;	
+			1;
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "program_nae_eh_pmem: ctxt_num:%d start:%d size:%d\n", i, start, (offset + 1));
 		netsoc_write_nae_reg(nae_base, EH_PMEM_PROG, data);
 		start+= offset+1;
@@ -637,7 +636,7 @@ void __netsoc_config_egress_fifo_carvings(nae_t *nae, int start_ctxt, int num_ct
 	nae->ehfifo_base = start;
 
 	/* FROUT FIFO */
-	start  = nae->froutfifo_base;	
+	start  = nae->froutfifo_base;
 	for(i=start_ctxt;i<limit;i++){
 		size   = current_netsoc->egress.max_frout_fifo / nae->num_contexts;
 
@@ -646,10 +645,10 @@ void __netsoc_config_egress_fifo_carvings(nae_t *nae, int start_ctxt, int num_ct
 		else
 			offset = size -1;
 
-		data =   offset << 23  | 
-			start << 11 |	
+		data =   offset << 23  |
+			start << 11 |
 			i << 1      |
-			1;	
+			1;
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "program_nae_frout_pmem: ctxt_num:%d start:%d size:%d\n", i, start, (offset + 1));
 		netsoc_write_nae_reg(nae_base, FREE_PMEM_PROG, data);
 		start+= offset+1;
@@ -657,7 +656,7 @@ void __netsoc_config_egress_fifo_carvings(nae_t *nae, int start_ctxt, int num_ct
 	nae->froutfifo_base = start;
 
 	/* MS FIFO */
-	start  = nae->msfifo_base;	
+	start  = nae->msfifo_base;
 	for(i=start_ctxt;i<limit;i++){
 		size   = current_netsoc->egress.max_ms_fifo / nae->num_contexts;
 
@@ -666,10 +665,10 @@ void __netsoc_config_egress_fifo_carvings(nae_t *nae, int start_ctxt, int num_ct
 		else
 			offset = size -1;
 
-		data =   offset << 22  | 	
-			start << 11 |	
+		data =   offset << 22  |
+			start << 11 |
 			i << 1      |
-			1;	
+			1;
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "program_nae_ms_pmem: ctxt_num:%d start:%d size:%d\n", i, start, (offset + 1));
 		netsoc_write_nae_reg(nae_base, STR_PMEM_CMD, data);
 		start+= offset+1;
@@ -677,7 +676,7 @@ void __netsoc_config_egress_fifo_carvings(nae_t *nae, int start_ctxt, int num_ct
 	nae->msfifo_base = start;
 
 	/* PKT FIFO */
-	start  = nae->pktfifo_base;	
+	start  = nae->pktfifo_base;
 	for(i=start_ctxt;i<limit;i++){
 		size   = current_netsoc->egress.max_tx_fifo / nae->num_contexts;
 
@@ -687,9 +686,9 @@ void __netsoc_config_egress_fifo_carvings(nae_t *nae, int start_ctxt, int num_ct
 			offset = size -1;
 		netsoc_write_nae_reg(nae_base, TX_PKT_PMEM_CMD1, offset);
 
-		data =   start << 11 |	
+		data =   start << 11 |
 			i << 1      |
-			1;	
+			1;
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "program_nae_pkt_pmem: ctxt_num:%d start:%d size:%d\n", i, start, offset);
 		netsoc_write_nae_reg(nae_base, TX_PKT_PMEM_CMD0, data);
 		start+= offset + 1;
@@ -697,7 +696,7 @@ void __netsoc_config_egress_fifo_carvings(nae_t *nae, int start_ctxt, int num_ct
 	nae->pktfifo_base = start;
 
 	/* PKT LEN FIFO */
-	start  = nae->pktlenfifo_base;	
+	start  = nae->pktlenfifo_base;
 	for(i=start_ctxt;i<limit;i++){
 		size   = current_netsoc->egress.max_pktlen_fifo / nae->num_contexts;
 
@@ -706,10 +705,10 @@ void __netsoc_config_egress_fifo_carvings(nae_t *nae, int start_ctxt, int num_ct
 		else
 			offset = size -1;
 
-		data =   offset  << 22 |	
-			start << 11 |	
+		data =   offset  << 22 |
+			start << 11 |
 			i << 1      |
-			1;	
+			1;
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "program_nae_plen_pmem: ctxt_num:%d start:%d size:%d\n", i, start, offset);
 		netsoc_write_nae_reg(nae_base, TX_PKTLEN_PMEM_CMD, data);
 		start+= offset+1;
@@ -729,7 +728,7 @@ void __netsoc_config_egress_fifo_carvings(nae_t *nae, int start_ctxt, int num_ct
 *
 * @return
 *  - none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -746,9 +745,9 @@ void __netsoc_config_egress_fifo_credits(nae_t *nae, int start_ctxt, int num_ctx
 		if (credit > max_credit)
 			credit = max_credit;
 
-		data =   credit << 16  | 
+		data =   credit << 16  |
 			i << 4      |
-			1;	
+			1;
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "program_nae_stg1_2_stg2_credit: ctxt_num:%d credit:%d\n", i, credit);
 		netsoc_write_nae_reg(nae_base, STG1_STG2CRDT_CMD, data);
 	}
@@ -760,9 +759,9 @@ void __netsoc_config_egress_fifo_credits(nae_t *nae, int start_ctxt, int num_ctx
 		if (credit > max_credit)
 			credit = max_credit;
 
-		data =   credit << 16  | 
+		data =   credit << 16  |
 			i << 4      |
-			1;	
+			1;
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "program_nae_stg2_2_eh_credit: ctxt_num:%d credit:%d\n", i, credit);
 		netsoc_write_nae_reg(nae_base, STG2_EHCRDT_CMD, data);
 	}
@@ -774,9 +773,9 @@ void __netsoc_config_egress_fifo_credits(nae_t *nae, int start_ctxt, int num_ctx
 		if (credit > max_credit)
 			credit = max_credit;
 
-		data =   credit << 16  | 
+		data =   credit << 16  |
 			i << 4      |
-			1;	
+			1;
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "program_nae_stg2_2_frout_credit: ctxt_num:%d credit:%d\n", i, credit);
 		netsoc_write_nae_reg(nae_base, STG2_FREECRDT_CMD, data);
 	}
@@ -788,9 +787,9 @@ void __netsoc_config_egress_fifo_credits(nae_t *nae, int start_ctxt, int num_ctx
 		if (credit > max_credit)
 			credit = max_credit;
 
-		data =   credit << 16  | 
+		data =   credit << 16  |
 			i << 4      |
-			1;	
+			1;
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "program_nae_stg2_2_ms_credit: ctxt_num:%d credit:%d\n", i, credit);
 		netsoc_write_nae_reg(nae_base, STG2_STRCRDT_CMD, data);
 	}
@@ -805,7 +804,7 @@ void __netsoc_config_egress_fifo_credits(nae_t *nae, int start_ctxt, int num_ctx
 *
 * @return
 *  - Interface number
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -831,7 +830,7 @@ uint32_t __netsoc_context_to_port_channel(nae_t *nae, uint32_t context)
 	}
 
         /* Set it to non-existent port */
-	data = 19 << 10 ;             
+	data = 19 << 10 ;
 	for(i=0;i<NUM_INGRESS_PORTS;i++){
 		base = netsoc_read_nae_reg(nae->nae_base, RX_IF_BASE_CONFIG_0 + i/2);
 
@@ -865,7 +864,7 @@ uint32_t __netsoc_context_to_port_channel(nae_t *nae, uint32_t context)
 *
 * @return
 *  - none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -911,7 +910,7 @@ void __netsoc_config_egress_drr(nae_t *nae, int start_ctxt, int end_ctxt)
 *
 * @return
 *  - none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -928,7 +927,7 @@ void __netsoc_config_egress(net_port_t *netport, int context_base)
 	data  = ((context_base + netport->num_channels - 1) << 22) | (context_base << 12) |
 		 (netport->hw_port_id << 4) | 1 ;
 	netsoc_write_nae_reg(nae_base, TX_DRR_ACTVLIST_CMD, data);
-	
+
 	__netsoc_config_egress_fifo_carvings(nae, context_base, netport->num_channels);
 	__netsoc_config_egress_fifo_credits(nae, context_base, netport->num_channels, nae->num_contexts);
 
@@ -962,7 +961,7 @@ void __netsoc_config_egress(net_port_t *netport, int context_base)
 				netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD1, DRR_QUANTA);
 				data =  (netport->hw_port_id << 15) | ((context_base + offset) << 5) ;
 				netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0 , data | 1 );
-				//Read the sched status 
+				//Read the sched status
 				do {
 					netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0 , ((context_base + offset)<<5));
 					data = netsoc_read_nae_reg(nae_base, TX_SCHED_MAP_STATUS0);
@@ -997,15 +996,15 @@ void __netsoc_config_flow_base(nae_t *nae)
         uint32_t reg, cur_flow_base = 0;
 	uint32_t per_port_num_flows = XLP_MAX_FLOWS / nae->num_ports;
 
-	for (port = 0, hw_port = 0 ; port < nae->num_ports; hw_port++) { 
+	for (port = 0, hw_port = 0 ; port < nae->num_ports; hw_port++) {
             if (hw_port == nae->ports[port].hw_port_id) {
 		reg = (cur_flow_base << 16) | hw_port;
 		reg |= ((flow_mask & 0x1f) << 8);
 	        netsoc_write_nae_reg(nae->nae_base, FLOW_BASE_MASK_CFG, reg);
         	cur_flow_base += per_port_num_flows;
 		port++;
-	    }	   
-	}	
+	    }
+	}
 }
 
 
@@ -1029,7 +1028,7 @@ void __netsoc_config_rx_calendar(nae_t *nae)
 
 				//Read RX calendar slots
 				val = (1<<31) | (cal_len << 16) | cal;
-				netsoc_write_nae_reg(nae->nae_base, RX_IFACE_SLOT_CAL, val);	
+				netsoc_write_nae_reg(nae->nae_base, RX_IFACE_SLOT_CAL, val);
 				val = netsoc_read_nae_reg(nae->nae_base, RX_IFACE_SLOT_CAL);
                                 netsoc_api_print(NETSOC_APIDBG_CONFIG, "Rx total-cal %d slot %d assigned to hwport %d \n",
 						(((val>>16) & 0x3f) + 1), cal, ((val>>8) & 0x1f));
@@ -1050,7 +1049,7 @@ void __netsoc_config_tx_calendar(nae_t *nae)
 
 	max_ports = __netsoc_get_max_ports();
 	cal_len = nae->tx_cal_slots - 1;
-	
+
 	netsoc_write_nae_reg(nae->nae_base, EGR_NIOR_CAL_LEN_REG, cal_len);
         do {
                 if (cal >= MAX_CAL_SLOTS)
@@ -1081,8 +1080,8 @@ void __netsoc_config_tx_calendar(nae_t *nae)
 
 /*
 Input:
-node - nae node id 	
-start - vfbid table index. 
+node - nae node id
+start - vfbid table index.
 num_entries - number of entries to be configured from start
 vfbid_tbl - array of destination VCs
 (Entries 126 and 127 can not be used by software)
@@ -1093,20 +1092,20 @@ Returns:
 
 int __netsoc_config_vfbid_table(nae_t *nae, uint32_t start, uint32_t num_entries, uint32_t *vfbid_tbl)
 {
-	int vfbid;		
+	int vfbid;
 	volatile uint32_t val = 0;
 	if (vfbid_tbl == NULL)
 		return -1;
-	
+
 	if ((start + num_entries) > 128)
 		return -1;
 
 	for(vfbid = start; vfbid < (start + num_entries); vfbid++, vfbid_tbl++) {
 		val = ((*vfbid_tbl) << 16) | (vfbid << 4) | 1;
-		netsoc_write_nae_reg(nae->nae_base, VFBID_TO_DEST_MAP_CMD, val);		
+		netsoc_write_nae_reg(nae->nae_base, VFBID_TO_DEST_MAP_CMD, val);
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "node %d vfbid %d *vfbid %d\n", nae->node, vfbid, *vfbid_tbl);
 	}
-	return NETSOC_API_SUCCESS;	
+	return NETSOC_API_SUCCESS;
 }
 
 void __netsoc_config_poe_class(nae_t *nae)
@@ -1117,7 +1116,7 @@ void __netsoc_config_poe_class(nae_t *nae)
         int poe_cl_tbl[MAX_POE_CLASSES] = {0x0, 0x249249, 0x492492,
                                            0x6db6db, 0x924924, 0xb6db6d,
                                            0xdb6db6, 0xffffff};
-	
+
 	max_poe_tbl_sz = current_netsoc->max_contexts / MAX_POE_CLASSES;
 
 	if (current_netsoc->max_contexts % MAX_POE_CLASSES)
@@ -1169,7 +1168,7 @@ void __netsoc_config_context_xoff_thr(nae_t *nae, net_port_t *netport, int thgrp
 
 	netsoc_write_nae_reg(nae->nae_base, RX_BUFFER_XONOFF_THR, (1 << 31) | thgrp);
 	val = netsoc_read_nae_reg(nae->nae_base, RX_BUFFER_XONOFF_THR);
-	netsoc_api_print(NETSOC_APIDBG_CONFIG, "thgrp %d xoff %d xon %d maxbuf %d\n", 
+	netsoc_api_print(NETSOC_APIDBG_CONFIG, "thgrp %d xoff %d xon %d maxbuf %d\n",
 			thgrp, (val >> 3) & 0x3fff, (val >> 17) & 0x3fff, maxbuf);
 }
 
@@ -1177,7 +1176,7 @@ void __netsoc_config_context_xoff_thr(nae_t *nae, net_port_t *netport, int thgrp
 
 void __netsoc_config_rxbuf_xoff_thr(nae_t *nae, uint32_t maxbuf)
 {
-        /* xon & xoff threshold is based on the number of entries used 
+        /* xon & xoff threshold is based on the number of entries used
          send xon when rx_data_buffer_used <= xon threshold
          send xoff when rx_data_buffer_used >= xoff threshold */
         uint32_t xoff , xon, val;
@@ -1196,7 +1195,7 @@ void __netsoc_config_rxbuf_xoff_thr(nae_t *nae, uint32_t maxbuf)
 	        val = netsoc_read_nae_reg(nae->nae_base, RX_BUFFER_XONOFF_THR);
         	netsoc_api_print(NETSOC_APIDBG_CONFIG, "thgrp %d xoff %d xon %d maxbuf %d\n",
                         thgrp, (val >> 3) & 0x3fff, (val >> 17) & 0x3fff, maxbuf);
-		
+
 		maxbuf /= (thrgrp + 1);
 	}
 }
@@ -1220,7 +1219,7 @@ void __netsoc_config_rxbuffer(nae_t *nae, int context_base, int num_channels, ui
                 val |= (((size << 2)  & 0x3fff) << 16); /* size */
                 netsoc_write_nae_reg(nae_base, RX_BUFFER_BASE_DEPTH_REG, val);
 
-		// Read back 
+		// Read back
 		netsoc_write_nae_reg(nae_base, RX_BUFFER_BASE_DEPTH_REG, 0);
 		netsoc_write_nae_reg(nae_base, RX_BUFFER_BASE_DEPTH_ADDR_REG, (context_base + offset));
 		netsoc_write_nae_reg(nae_base, RX_BUFFER_BASE_DEPTH_REG, 0);
@@ -1255,7 +1254,7 @@ void __netsoc_config_parserfifo(nae_t *nae, int hw_port_id, uint32_t start, uint
 	}
 
 	// MD is zero, 1024 entries
-	val = (1<<31) | (hw_port_id & 0x1f); 
+	val = (1<<31) | (hw_port_id & 0x1f);
 	netsoc_write_nae_reg(nae->nae_base, PARSER_SEQ_FIFO_CFG, val);
 	val = netsoc_read_nae_reg(nae->nae_base, PARSER_SEQ_FIFO_CFG);
 	netsoc_api_print(NETSOC_APIDBG_CONFIG,"PARSER_SEQ_FIFO_CFG port %d fcsz %d fcstart %d\n", hw_port_id,
@@ -1276,7 +1275,7 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 
 	max_ports = __netsoc_get_max_ports();
         netsoc_api_print(NETSOC_APIDBG_CONFIG, "Interface FIFO carving max_ports:%d \n", max_ports);
-        for (port = 0, hw_port = 0 ; hw_port <= max_ports; ) { 
+        for (port = 0, hw_port = 0 ; hw_port <= max_ports; ) {
 	    if (hw_port == nae->ports[port].hw_port_id) {
 
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "port:%d iftype:%d\n", port, nae->ports[port].iftype);
@@ -1298,10 +1297,10 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 			thrgrp = 1;
 			rx_buf_size = nae->ports[port].rx_buf_size;
 			break;
-		//TODO: Verify the values	
+		//TODO: Verify the values
 		   case XFI_IF:
 			fifo_xoff_thresh = 6;
-			//TODO: check thgrp	
+			//TODO: check thgrp
 			thrgrp = 3;
 			break;
 		   case SGMII_IF:
@@ -1333,7 +1332,7 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 
 
 		__netsoc_config_rxbuffer(nae, context_base,nae->ports[port].num_channels,
-                                        rx_buf_base, nae->ports[port].rx_buf_size, thrgrp);  
+                                        rx_buf_base, nae->ports[port].rx_buf_size, thrgrp);
                 rx_buf_base += nae->ports[port].rx_buf_size;
 
 		for (lane = 0 ; lane < max_lanes; lane++) {
@@ -1343,7 +1342,7 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 			__netsoc_write_interface_fifo(nae, nae->ports[port].hw_port_id + lane,
                                                          cur_iface_start, size, fifo_xoff_thresh );
 			cur_iface_start += size;
-			
+
 			// carving Rx base
 			netsoc_api_print(NETSOC_APIDBG_CONFIG, "carving rx buffer: lane:%d\n", lane);
 			__netsoc_write_rxbase(nae, nae->ports[port].hw_port_id + lane, context_base);
@@ -1357,7 +1356,7 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
                         		context_base += 8;
 #endif
 			}
-			
+
 			size = ((lane == 0) ? nae->ports[port].prsr_seq_fifo_size : 0);
 			__netsoc_config_parserfifo(nae, nae->ports[port].hw_port_id + lane, cur_parser_base, size);
 			cur_parser_base += size;
@@ -1371,11 +1370,11 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 		__netsoc_write_rxbase(nae, hw_port, context_base);
 		__netsoc_config_parserfifo(nae, hw_port, cur_parser_base, 0);
 		hw_port++;
-	    }		
+	    }
         }
 }
 
-void __netsoc_config_nae_global(nae_t *nae) 
+void __netsoc_config_nae_global(nae_t *nae)
 {
 	uint32_t vfbid = 0, i = 0;
         volatile uint32_t val = 0;
@@ -1400,7 +1399,7 @@ void __netsoc_config_nae_global(nae_t *nae)
 	else {
 		for (i = 0, vfbid = 0; i < NLM_MAX_NODES; i++) {
                         dest = nae->fb_vc;
-                        for (;vfbid < ((i+1) * 32); vfbid++) { 
+                        for (;vfbid < ((i+1) * 32); vfbid++) {
 				if (vfbid >= 126) {
 					i = NLM_MAX_NODES;
 					break;
@@ -1428,7 +1427,7 @@ void __netsoc_config_nae_global(nae_t *nae)
 void __netsoc_set_frequency(nae_t *nae, uint32_t frequency)
 {
         const uint64_t mhz = 1000000;
-        uint64_t set_freq, set_freq_d; 
+        uint64_t set_freq, set_freq_d;
 	if(is_nlm_xlp2xx()){
 		set_freq_d = nlm_hal_xlp2xx_set_clkdev_frq(nae->node, XLP2XX_CLKDEVICE_NAE, frequency * mhz);
 		NLM_HAL_DO_DIV(set_freq_d, mhz);
@@ -1436,7 +1435,7 @@ void __netsoc_set_frequency(nae_t *nae, uint32_t frequency)
 		return;
 	}
 	else if (is_nlm_xlp9xx()) {
-		set_soc_frequency(nae->node, XLP9XX_CLKDEV_NET, (frequency * mhz));	
+		set_soc_frequency(nae->node, XLP9XX_CLKDEV_NET, (frequency * mhz));
 	}
 	else{
         	/* Note that the DFS sets the NAE 2X frequency.
@@ -1446,7 +1445,7 @@ void __netsoc_set_frequency(nae_t *nae, uint32_t frequency)
 		NLM_HAL_DO_DIV(set_freq_d, mhz);
 	        set_freq = set_freq_d;
 		NLM_HAL_DO_DIV(set_freq, 2);
-	        netsoc_api_print(NETSOC_APIDBG_DEFAULT, "NAE 2X Frequency set to %lluMHz (NAE frequency %llu MHz)\n", 
+	        netsoc_api_print(NETSOC_APIDBG_DEFAULT, "NAE 2X Frequency set to %lluMHz (NAE frequency %llu MHz)\n",
 					(unsigned long long)set_freq_d, (unsigned long long)set_freq);
 	}
 	return;
@@ -1480,7 +1479,7 @@ int __netsoc_drain_frin_fifo_descs(nae_t *nae, uint32_t frin_q)
 	uint32_t value, fifo_mask = 1 << frin_q;
 	int timeout = 10;
 	uint64_t nae_base = nae->nae_base;
-	
+
 	netsoc_write_nae_reg(nae_base, RX_FREE_FIFO_POP, fifo_mask);
 	for (; timeout >= 0; timeout--) {
 		nlm_mdelay(1);
@@ -1529,7 +1528,7 @@ void __netsoc_print_frin_desc_carving(nae_t *nae)
 *
 * @return
 *  - none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -1574,7 +1573,7 @@ void __netsoc_deflate_frin_fifo_carving(nae_t *nae)
  *                   XAUI Support
  *
  */
-static int __netsoc_xgmac_mdio_write(nae_t *nae, uint32_t bus, 
+static int __netsoc_xgmac_mdio_write(nae_t *nae, uint32_t bus,
 	uint32_t phyaddr, uint32_t dev_addr, uint32_t regidx, uint16_t val)
 {
 	uint64_t mac_base = netsoc_get_macreg_base_for_mdio(nae->mac_base);
@@ -1829,37 +1828,37 @@ void __netsoc_mdio_init(nae_t *nae)
 	nlm_mdelay(3);
 }
 
-void __netsoc_set_xlgmac_enable(net_port_t *netport) 
+void __netsoc_set_xlgmac_enable(net_port_t *netport)
 {
 	volatile uint32_t val;
 	nae_t *nae = netport->nae;
         uint64_t mac_base = netsoc_get_macreg_base_for_xlgmac(nae->mac_base, netport->hw_port_id);
 	/*TODO: remove after all fields are verified*/
 	uint32_t pad_mode=1, crc_enable=1;
-	
+
 	val = netsoc_read_mac_reg(mac_base, XLGMAC1_CTL);
-	val &= ~(1<<1 | 1<<0);	
+	val &= ~(1<<1 | 1<<0);
 	val |= pad_mode | crc_enable;
         netsoc_write_mac_reg(mac_base, XLGMAC1_CTL, val);
 	/* flow control*/
         netsoc_write_mac_reg(mac_base, XLGMACPCS_CTRL, 0x5);
-	
+
 	val = __netsoc_read_xlgmac_reg(netport, XLAUI_TX_FIFO_SECTIONS);
 	val &= 0xffff0000;
 	val |= 0x9;
 	val = 9; // Workaround for XLGMAC read bug
         __netsoc_write_xlgmac_reg(netport, XLAUI_TX_FIFO_SECTIONS, val);
-	
+
 	val = __netsoc_read_xlgmac_reg(netport, XLAUI_RX_FIFO_SECTIONS);
 	val &= 0xffff0000;
 	val |= 0x4;
 	val = 0x4; // Workaround for XLGMAC read bug
         __netsoc_write_xlgmac_reg(netport, XLAUI_RX_FIFO_SECTIONS, val);
-	
+
 	val = 0x220d3; // PFC disable
         __netsoc_write_xlgmac_reg(netport, XLAUI_COMMNAD_CONFIG, val);
-	
-	
+
+
 	val  = __netsoc_read_xlgmac_reg(netport, XLAUI_FRM_LENGTH);
 	val &= 0xffffc000;
 	val |= 0x3fe0; // 0xff for max_frame
@@ -1884,7 +1883,7 @@ static void __netsoc_xlgmac_threshold(uint64_t mac_base,  uint32_t thres_val)
 	val &= (~(XLGMAC3_CTL_SOFTH_MASK << XLGMAC3_CTL_SOFTH_SHIFT));
 	val |= ((thres_val & XLGMAC3_CTL_SOFTH_MASK) << XLGMAC3_CTL_SOFTH_SHIFT);
         netsoc_write_mac_reg(mac_base, XLGMAC3_CTL, val);
-    	netsoc_api_print(NETSOC_APIDBG_PORT,"XLAUI Rd XLGMAC3_CTL : 0x%x\n",  netsoc_read_mac_reg(mac_base, XLGMAC3_CTL)); 
+    	netsoc_api_print(NETSOC_APIDBG_PORT,"XLAUI Rd XLGMAC3_CTL : 0x%x\n",  netsoc_read_mac_reg(mac_base, XLGMAC3_CTL));
 
 }
 
@@ -1917,7 +1916,7 @@ static void __netsoc_xfi_softreset(uint64_t mac_base,  uint32_t rst_val)
 	val |= ((rst_val & 0x3) << 11);
         netsoc_write_mac_reg(mac_base3, XGMAC_CTL_REG1, val);
 #endif
-	 
+
 	netsoc_api_print(NETSOC_APIDBG_PORT, "%s All XFI ports in a Quad resetted\n", __func__);
 
 }
@@ -1929,7 +1928,7 @@ static void __netsoc_config_sgmii(net_port_t *netport)
         unsigned int ifmode, speed, duplex;
 	nae_t *nae = netport->nae;
 	uint64_t mac_base = netsoc_get_macreg_base_for_gmac(nae->mac_base, netport->hw_port_id);
-        
+
         // Disable TX , Rx for now
         mac_cfg1 = netsoc_read_mac_reg(mac_base, MAC_CONF1);
         netsoc_write_mac_reg(mac_base, MAC_CONF1, mac_cfg1 & ~(0x5));
@@ -1967,12 +1966,12 @@ static void __netsoc_config_sgmii(net_port_t *netport)
         // Enable statistics counters
         netwk_inf  = netsoc_read_mac_reg(mac_base, NETWK_INF_CTRL_REG);
         netsoc_write_mac_reg(mac_base, NETWK_INF_CTRL_REG, (netwk_inf & (~(1<<15))) | (1 << 16));
-	
+
 	// Enable flow control
         mac_cfg1 = netsoc_read_mac_reg(mac_base, MAC_CONF1);
         netsoc_write_mac_reg(mac_base, MAC_CONF1, mac_cfg1 | (0x3 << 4));
         val = netsoc_read_mac_reg(mac_base, NETIOR_GMAC_CTRL1);
-	val |= (1 << NETIOR_GMAC_TX_PAUSE_POS);	
+	val |= (1 << NETIOR_GMAC_TX_PAUSE_POS);
         netsoc_write_mac_reg(mac_base, NETIOR_GMAC_CTRL1, val);
 
 }
@@ -1983,7 +1982,7 @@ static void __netsoc_config_sgmii(net_port_t *netport)
 *
 * @return
 *       - none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -1993,9 +1992,9 @@ static void __netsoc_config_xaui(net_port_t *netport)
 	nae_t *nae = netport->nae;
         int rxaui_en = ((netport->rxaui_mode == NLP1042_PHY_10G_RXAUI_MODE1) ||
                         (netport->rxaui_mode == NLP1042_PHY_10G_RXAUI_MODE2)) ? 1 : 0;
-	
+
 	uint64_t mac_base = __netsoc_get_xgmac_base(netport);
-	
+
 	higig_type = nae->higig_mode[netport->hw_port_id >> 2];
         if(higig_type){
                 /*enable higig */
@@ -2072,14 +2071,14 @@ static void __netsoc_config_xaui(net_port_t *netport)
 
                 /*
                  * Configuring the OFF/ON timer
-                 * 31:16  - In PFC mode is used as the Xoff value                                     
-                 * 15:0   - In PFC mode is used as the Xon value                                      
-                 *        - in Link level FC mode, is used as the Xoff value.                         
+                 * 31:16  - In PFC mode is used as the Xoff value
+                 * 15:0   - In PFC mode is used as the Xon value
+                 *        - in Link level FC mode, is used as the Xoff value.
                  */
         if (netport->vlan_pri_en) {
-                val = 0xF1230000;          // PFC mode:  OffTimer = 0xF123  OnTimer = 0x0000  
+                val = 0xF1230000;          // PFC mode:  OffTimer = 0xF123  OnTimer = 0x0000
         } else {
-                val = 0x0000F123;          // Link level FC: OffTimer = 0xF123    
+                val = 0x0000F123;          // Link level FC: OffTimer = 0xF123
         }
         netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL2, val);
 
@@ -2126,7 +2125,7 @@ static void __netsoc_set_xlgmac_pause_config(net_port_t *netport)
 *
 * @return
 *       - none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -2135,7 +2134,7 @@ static void __netsoc_config_xlgmac(net_port_t *netport)
 {
 	nae_t *nae = netport->nae;
         uint64_t mac_base = netsoc_get_macreg_base_for_xlgmac(nae->mac_base, netport->hw_port_id);
-	
+
 	__netsoc_xlgmac_softreset(mac_base, 0x3);
 	__netsoc_xlgmac_softreset(mac_base, 0x0);
 	__netsoc_xlgmac_threshold(mac_base, 0x1f);
@@ -2154,7 +2153,7 @@ static void __netsoc_config_xlgmac(net_port_t *netport)
 *
 * @return
 *       - none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -2163,11 +2162,11 @@ static void __netsoc_config_xfi(net_port_t *netport)
 	/*Reset the XGMAC : reset all ports in quad */
         uint32_t val = 0;
 	uint64_t mac_base = __netsoc_get_xgmac_base(netport);
-        
+
 	// Apply a soft reset.
 	__netsoc_xfi_softreset(mac_base, 0x2);
 	__netsoc_xfi_softreset(mac_base, 0x0);
-        
+
 	netsoc_write_mac_reg(mac_base, XAUI_CONFIG_0, 0xFFFFFFFF);
         netsoc_write_mac_reg(mac_base, XAUI_CONFIG_0, 0x00000000);
 
@@ -2197,14 +2196,14 @@ static void __netsoc_config_xfi(net_port_t *netport)
 
                 /*
                  * Configuring the OFF/ON timer
-                 * 31:16  - In PFC mode is used as the Xoff value                                     
-                 * 15:0   - In PFC mode is used as the Xon value                                      
-                 *        - in Link level FC mode, is used as the Xoff value.                         
+                 * 31:16  - In PFC mode is used as the Xoff value
+                 * 15:0   - In PFC mode is used as the Xon value
+                 *        - in Link level FC mode, is used as the Xoff value.
                  */
         if (netport->vlan_pri_en) {
-                val = 0xF1230000;          // PFC mode:  OffTimer = 0xF123  OnTimer = 0x0000  
+                val = 0xF1230000;          // PFC mode:  OffTimer = 0xF123  OnTimer = 0x0000
         } else {
-                val = 0x0000F123;          // Link level FC: OffTimer = 0xF123    
+                val = 0x0000F123;          // Link level FC: OffTimer = 0xF123
         }
         netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL2, val);
 }
@@ -2233,7 +2232,7 @@ static void __netsoc_config_interlaken(net_port_t *netport, int num_lanes)
                 txctrl = ILK_TX_CTRL_BAD_LANE | (num_lanes << ILK_TX_CTRL_BLS_POS)
                          | (num_lanes << ILK_TX_CTRL_LLS_POS);
         }
-        else {  
+        else {
                 rxctrl = (num_lanes - 1) << ILK_RX_CTRL_LLS_POS | ((num_lanes-1) << ILK_RX_CTRL_BLS_POS);
                 txctrl = (num_lanes - 1) << ILK_TX_CTRL_LLS_POS | ((num_lanes-1) << ILK_TX_CTRL_BLS_POS) | (3 << ILK_TX_CTRL_BS_POS);
         }
@@ -2241,7 +2240,7 @@ static void __netsoc_config_interlaken(net_port_t *netport, int num_lanes)
         rxctrl |= (ILK_BURST_MAX << ILK_RX_CTRL_BMAX_POS) ;
         txctrl |= (ILK_BURST_MAX << ILK_TX_CTRL_BMAX_POS) | (0x1 << ILK_TX_CTRL_CAL_LEN_POS) | ILK_TX_CTRL_TX_EN ;
         // Enable packet mode and ratelimit for cortina IL card
-        rxctrl |= ILK_RX_CTRL_PKT_MODE; 
+        rxctrl |= ILK_RX_CTRL_PKT_MODE;
         txctrl |= ILK_TX_CTRL_RATELIM_EN;
         netsoc_write_mac_reg(mac_base, ILK_RX_CONTROL, rxctrl);
         netsoc_write_mac_reg(mac_base, ILK_TX_CONTROL, txctrl);
@@ -2333,8 +2332,8 @@ uint16_t __netsoc_get_hwport(nae_t *nae, uint32_t context)
 		port++;
 		rxbase1 = netsoc_read_nae_reg(nae->nae_base, RX_IF_BASE_CONFIG_0 + i + 1);
 		if ((context >= ((rxbase >> 16) & 0x3FF)) && ( context <  (rxbase1 & 0x3FF)))
-			return port;	
-		port++;		
+			return port;
+		port++;
 	}
 	return MAX_GMAC_PORT;
 }
@@ -2350,7 +2349,7 @@ static int __netsoc_init_netior(nae_t *nae)
 	ilk_ifcredit = 7; //get_iface_credit(INTERLAKEN_IF);
 
         netsoc_write_nae_iface_reg(nae_base, NETIOR_SOFTRESET, 0);
-	
+
 	for (block=0; block < current_netsoc->max_blocks; block++) {
 		if (block == 4) {
 			break;
@@ -2358,7 +2357,7 @@ static int __netsoc_init_netior(nae_t *nae)
 		if (nae->sgmii_complex_map & (1 << block)) {
 			ifcredit_val = get_iface_credit(SGMII_IF);
 			ifcredit |= (ifcredit_val << (block * 8));
-			complex_mask |= (0xF << (block * 4));		//FIXME 
+			complex_mask |= (0xF << (block * 4));		//FIXME
 		}
 		else if (nae->xaui_complex_map & (1 << block)) {
 			ifcredit_val = get_iface_credit(XAUI_IF);
@@ -2368,7 +2367,7 @@ static int __netsoc_init_netior(nae_t *nae)
 		else if (nae->rxaui_complex_map & (1 << block)) {
 			ifcredit_val = get_iface_credit(RXAUI_IF);
 			ifcredit |= (ifcredit_val << (block * 8));
-			complex_mask |= (0xf << (block * 4)); 
+			complex_mask |= (0xf << (block * 4));
 		}
 		else if (nae->xfi_complex_map & (1 << block)) {
 			ifcredit_val = get_iface_credit(XFI_IF);
@@ -2382,7 +2381,7 @@ static int __netsoc_init_netior(nae_t *nae)
 		}
 		else {
 			ifcredit |= (ilk_ifcredit << (block * 8));
-			complex_mask |= (0xf << (block * 4));	
+			complex_mask |= (0xf << (block * 4));
 		}
 	}
 
@@ -2400,7 +2399,7 @@ static int __netsoc_init_netior(nae_t *nae)
         netsoc_write_nae_iface_reg(nae_base, NETIOR_MISC_REG3_ADDR , ifcredit_1);
         netsoc_write_nae_iface_reg(nae_base, NETIOR_MISC_REG2_ADDR , ifcredit );
         netsoc_write_nae_iface_reg(nae_base, NETIOR_MISC_REG1_ADDR , complex_mask);
-        
+
 	// Clear credit reset
 	netsoc_write_nae_iface_reg(nae_base, NETIOR_MISC_REG1_ADDR , 0);
 
@@ -2426,7 +2425,7 @@ static int __netsoc_init_netior(nae_t *nae)
 *
 * @return
 *       - none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -2436,8 +2435,8 @@ void __netsoc_init_ingress(nae_t *nae, uint32_t desc_size)
         unsigned int parser_threshold = DEFAULT_PARSER_THR;
 	uint64_t nae_base = nae->nae_base;
 	unsigned int frin_descsz = 0, divdescsz, moddescsz;
-	
-	
+
+
         if (!desc_size)
 #ifdef CONFIG_64BIT
                 desc_size = 5504; /* to support 16384(mtu)/(max 3 P2Ds) and cacheline aligned */
@@ -2485,7 +2484,7 @@ void __netsoc_init_ingress(nae_t *nae, uint32_t desc_size)
                                PARSER_THRESHOLD_DIV_DESCSIZE(divdescsz) |
                                PARSER_THRESHOLD_MOD_DESCSIZE_CL(moddescsz));
 		rx_cfg = netsoc_read_nae_reg(nae_base, XLP_PARSER_CONFIG);
-		netsoc_api_print(NETSOC_APIDBG_GLOBAL,"Parser thr %d devdescSz %d moddescSz %d \n", 
+		netsoc_api_print(NETSOC_APIDBG_GLOBAL,"Parser thr %d devdescSz %d moddescSz %d \n",
 			(rx_cfg & 0x3ff), ((rx_cfg>>12) & 0xff), ((rx_cfg>>20) & 0xff));
 	}
 	else {
@@ -2506,7 +2505,7 @@ void __netsoc_init_ingress(nae_t *nae, uint32_t desc_size)
 			desc_size = ((val>>8) & 0xff) * XLP_CACHE_LINE_SIZE;
 			netsoc_api_print(NETSOC_APIDBG_GLOBAL,"LIFO %d descsize %d\n",i, desc_size);
 			if (desc_size == 0)
-				desc_size = 16*1024; 
+				desc_size = 16*1024;
 			if (i==0)
 				frin_descsz = desc_size;
 			if (desc_size < frin_descsz)
@@ -2520,7 +2519,7 @@ void __netsoc_init_ingress(nae_t *nae, uint32_t desc_size)
                         moddescsz = (parser_threshold / XLP_CACHE_LINE_SIZE) % frin_descsz;
 
 		netsoc_api_print(NETSOC_APIDBG_GLOBAL,"parthr %d moddescsz %d frin_descsz %d \n",parser_threshold, moddescsz, frin_descsz);
-		netsoc_write_nae_reg(nae_base, XLP_PARSER_CONFIG, 
+		netsoc_write_nae_reg(nae_base, XLP_PARSER_CONFIG,
                                PARSER_THRESHOLD(parser_threshold) |
                                PARSER_THRESHOLD_DIV_DESCSIZE(divdescsz) |
 			       PARSER_THRESHOLD_MOD_DESCSIZE_CL(moddescsz));
@@ -2538,7 +2537,7 @@ void __netsoc_init_ingress(nae_t *nae, uint32_t desc_size)
 *
 * @return
 *       - none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -2566,7 +2565,7 @@ int __netsoc_config_port(net_port_t *netport)
 	unsigned int netior_ctrl3 = 0;
 	uint32_t block = netport->hw_port_id >> 2;
 	nae_t *nae = netport->nae;
-	uint64_t mac_base =0; 
+	uint64_t mac_base =0;
 	uint64_t nae_base = nae->nae_base;
 
 	netsoc_api_print(NETSOC_APIDBG_PORT, "%s: %d node %d ",__func__,block , nae->node);
@@ -2586,7 +2585,7 @@ int __netsoc_config_port(net_port_t *netport)
 				netsoc_write_nae_reg(nae_base, TX_IORCRDT_INIT,  tx_ior_credit & (~ (1<<netport->hw_port_id)));
 			}else{
 				netsoc_write_nae_reg(nae_base, TX_IORCRDT_INIT, tx_ior_credit | ifmask);
-			}	
+			}
 
 		        tx_config = netsoc_read_nae_reg(nae_base, TX_CONFIG);
 			// need to toggle these bits for credits to be loaded
@@ -2600,7 +2599,7 @@ int __netsoc_config_port(net_port_t *netport)
 			netwk_inf |= (1 << NETIOR_XGMAC_STATS_CLR_POS);
 			netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL1, netwk_inf);
 
-			/*TODO: verify tx_ior_credit */	
+			/*TODO: verify tx_ior_credit */
                         tx_ior_credit = netsoc_read_nae_reg(nae_base, TX_IORCRDT_INIT);
 			netsoc_write_nae_reg(nae_base, TX_IORCRDT_INIT, tx_ior_credit & (~ (1<<netport->hw_port_id)));
 			tx_config = netsoc_read_nae_reg(nae_base, TX_CONFIG);
@@ -2615,7 +2614,7 @@ int __netsoc_config_port(net_port_t *netport)
 			netwk_inf |= (1 << NETIOR_XGMAC_STATS_CLR_POS);
 			netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL1, netwk_inf);
 
-			/*TODO: verify tx_ior_credit */	
+			/*TODO: verify tx_ior_credit */
 			ifmask = 0xf << netport->hw_port_id;
                         tx_ior_credit = netsoc_read_nae_reg(nae_base, TX_IORCRDT_INIT);
 			netsoc_write_nae_reg(nae_base, TX_IORCRDT_INIT, tx_ior_credit | ifmask );
@@ -2643,7 +2642,7 @@ int __netsoc_config_port(net_port_t *netport)
 			// need to toggle these bits for credits to be loaded
 			netsoc_write_nae_reg(nae_base, TX_CONFIG, tx_config | ( TXINITIORCR(1<<netport->hw_port_id)));
 			netsoc_write_nae_reg(nae_base, TX_CONFIG, tx_config & (~( TXINITIORCR(1<<netport->hw_port_id))));
-	
+
 			/* init phy id to access internal PCS */
 		        netwk_inf = netsoc_read_mac_reg(mac_base, NETWK_INF_CTRL_REG);
         		netwk_inf &= 0x7ffffff;
@@ -2653,21 +2652,21 @@ int __netsoc_config_port(net_port_t *netport)
 			/* Sofreset set bit 11 to 0  */
 
 			netsoc_write_mac_reg(mac_base, NETWK_INF_CTRL_REG,  netwk_inf & 0xfffff7ff);
-                        
-			// Reset GMAC 
+
+			// Reset GMAC
 			mac_cfg1 = netsoc_read_mac_reg(mac_base, MAC_CONF1);
-		        netsoc_write_mac_reg(mac_base , MAC_CONF1, mac_cfg1 | INF_SOFTRESET(1)); 
-			
+		        netsoc_write_mac_reg(mac_base , MAC_CONF1, mac_cfg1 | INF_SOFTRESET(1));
+
                         // Default 1G
 		        netsoc_write_mac_reg(mac_base , MAC_CONF2,  INF_PREMBL_LEN(0x7) |
                         		     	INF_IFMODE(2)  |
                 	               		INF_FULLDUP(1) |
 		  			        INF_PADCRCEN(1));
-                         
+
 			// Clear GMAC reset
 			mac_cfg1 = netsoc_read_mac_reg(mac_base, MAC_CONF1);
 		        netsoc_write_mac_reg(mac_base , MAC_CONF1, mac_cfg1 & ~(INF_SOFTRESET(1)));
-                       
+
 			// Clear speed debug bit
 		        netior_ctrl3 = netsoc_read_mac_reg(mac_base, NETWK_INF_CTRL3_REG);
 		        netsoc_write_mac_reg(mac_base, NETWK_INF_CTRL3_REG, netior_ctrl3 & (~(1<<6)));
@@ -2679,7 +2678,7 @@ int __netsoc_config_port(net_port_t *netport)
 			__netsoc_config_sgmii(netport);
 			break;
 		default:
-			netsoc_api_print(NETSOC_APIDBG_ERROR, "Unknown interface type\n");	
+			netsoc_api_print(NETSOC_APIDBG_ERROR, "Unknown interface type\n");
 			return 0;
 	}
 	return NETSOC_API_SUCCESS;
@@ -2691,7 +2690,7 @@ int __netsoc_config_port(net_port_t *netport)
 *
 * @return
 * 	- none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -2736,22 +2735,22 @@ int __netsoc_flow_control_status(nae_t *nae, uint32_t port)
 	unsigned int mac_cfg0 = 0,mac_cfg1 = 0, mask0;
 	unsigned int xaui_cfg0 = 0, xaui_cfg1 = 0, mask1;
 	net_port_t *netport = &nae->ports[port];
-	
+
 	switch(netport->iftype) {
                 case SGMII_IF:
                         mac_base = netsoc_get_macreg_base_for_gmac(nae->mac_base, netport->hw_port_id);
                         mac_cfg0 = netsoc_read_mac_reg(mac_base, MAC_CONF1);
                         mac_cfg1 = netsoc_read_mac_reg(mac_base, NETIOR_GMAC_CTRL1);
 			mask0    = (mac_cfg0 & (1 << 4)) && (mac_cfg1 & (1 << 5));
-			
+
 			if (netport->flow_control_type == PFC_LEVEL) {
-				mask1 = (mac_cfg1 & ((1 << NETIOR_GMAC_TX_PFC_EN_POS) | (mac_cfg1 & 
+				mask1 = (mac_cfg1 & ((1 << NETIOR_GMAC_TX_PFC_EN_POS) | (mac_cfg1 &
 										(1<<NETIOR_GMAC_RX_PFC_EN_POS))));
 				val   = mask0 && mask1;
 			}
 			else
                         	val= mask0 && (mac_cfg1 & (1 << NETIOR_GMAC_TX_PAUSE_POS));
-                        
+
 			if (val)
 				return 1;
 			break;
@@ -2767,17 +2766,17 @@ int __netsoc_flow_control_status(nae_t *nae, uint32_t port)
 			xaui_cfg0 = netsoc_read_mac_reg(mac_base, XAUI_CONFIG_1);
 			xaui_cfg1 = netsoc_read_mac_reg(mac_base, NETIOR_XGMAC_CTRL1);
 			mask0     = (xaui_cfg0 & XAUI_CONFIG_TCTLEN) && (xaui_cfg0 & XAUI_CONFIG_RCTLEN);
-			
+
 			if (netport->flow_control_type == PFC_LEVEL) {
                         	mask1 = (xaui_cfg1 & ((1 << NETIOR_XGMAC_TX_PFC_EN_POS) | (xaui_cfg1 &													 (1<<NETIOR_XGMAC_RX_PFC_EN_POS))));
 				val = mask0 && mask1;
 			}
 			else
 				val = mask0 && (xaui_cfg1 & (1 << NETIOR_XGMAC_TX_PAUSE_POS));
-			
+
 			if (val)
 				return 1;
-	
+
 			break;
 		case INTERLAKEN_IF:
                         break;
@@ -2793,7 +2792,7 @@ int __netsoc_flow_control_status(nae_t *nae, uint32_t port)
 *
 * @return
 * 	- none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -2803,14 +2802,14 @@ void __netsoc_mac_enable(net_port_t *netport)
         unsigned int netwk_inf = 0;
 	nae_t *nae = netport->nae;
 	uint64_t mac_base;
-        
+
         switch(netport->iftype) {
                 case SGMII_IF:
 			mac_base = netsoc_get_macreg_base_for_gmac(nae->mac_base, netport->hw_port_id);
 			netwk_inf  = netsoc_read_mac_reg(mac_base, NETWK_INF_CTRL_REG);
-		        netsoc_write_mac_reg(mac_base , NETWK_INF_CTRL_REG, 
+		        netsoc_write_mac_reg(mac_base , NETWK_INF_CTRL_REG,
 					netwk_inf | TX_EN(1)| STATS_EN(1));
-                        
+
                         mac_cfg1 = netsoc_read_mac_reg(mac_base, MAC_CONF1);
         		netsoc_write_mac_reg(mac_base , MAC_CONF1, mac_cfg1 | INF_RX_ENABLE(1) | INF_TX_ENABLE(1));
                         netsoc_api_print(NETSOC_APIDBG_PORT,"%s: MAC_CONF1 0x%x \n",__func__, netsoc_read_mac_reg(mac_base, MAC_CONF1));
@@ -2821,11 +2820,11 @@ void __netsoc_mac_enable(net_port_t *netport)
                 case RXAUI_IF:
 			//mac_base = netsoc_get_macreg_base_for_xgmac0(nae->mac_base, netport->hw_port_id);
 			mac_base = __netsoc_get_xgmac_base(netport);
-			
+
 			netsoc_api_print(NETSOC_APIDBG_PORT,"%s: XGMAC enabling.. XAUI_CONFIG_1 0x%x\n",__func__, xaui_cfg);
 			xaui_cfg=netsoc_read_mac_reg(mac_base, XAUI_CONFIG_1);
 	                netsoc_write_mac_reg(mac_base, XAUI_CONFIG_1, xaui_cfg |
-							XAUI_CONFIG_TFEN | XAUI_CONFIG_RFEN);                           
+							XAUI_CONFIG_TFEN | XAUI_CONFIG_RFEN);
 			xaui_cfg=netsoc_read_mac_reg(mac_base, XAUI_CONFIG_1);
 			netsoc_api_print(NETSOC_APIDBG_PORT,"%s: XGMAC enabled XAUI_CONFIG_1 0x%x\n",__func__, xaui_cfg);
 
@@ -2841,8 +2840,8 @@ void __netsoc_modify_nae_ucore_sram_mem(nae_t *nae, unsigned int *data, uint32_t
 	int i;
 	unsigned int ucore_cfg;
 	uint64_t nae_base = nae->nae_base;
-	
-	ucore_cfg = netsoc_read_nae_reg(nae_base, RX_UCORE_CFG);	
+
+	ucore_cfg = netsoc_read_nae_reg(nae_base, RX_UCORE_CFG);
 	/*set iram to 0*/
 	netsoc_write_nae_reg(nae_base, RX_UCORE_CFG, ucore_cfg & ~(1<<7));
 	for (i = 0; i < words; ++i, off += 4) {
@@ -2856,7 +2855,7 @@ void __netsoc_read_nae_ucore_sram_mem(nae_t *nae, unsigned int *data, uint32_t o
 	unsigned int ucore_cfg;
         uint64_t nae_base = nae->nae_base;
 
-	ucore_cfg = netsoc_read_nae_reg(nae_base, RX_UCORE_CFG);	
+	ucore_cfg = netsoc_read_nae_reg(nae_base, RX_UCORE_CFG);
 	/*set iram to 0*/
 	netsoc_write_nae_reg(nae_base, RX_UCORE_CFG, ucore_cfg & ~(1<<7));
 	for (i = 0; i < words; ++i, off += 4) {
@@ -2883,9 +2882,9 @@ int __netsoc_config_frame_size(net_port_t *netport, uint32_t size)
 		default:
 			return -NETSOC_API_PARAM_INVALID;
 	}
-	return NETSOC_API_SUCCESS;	
+	return NETSOC_API_SUCCESS;
 }
- 
+
 
 int __netsoc_config_flow_control(net_port_t *netport, uint32_t enable)
 {
@@ -2907,7 +2906,7 @@ int __netsoc_config_flow_control(net_port_t *netport, uint32_t enable)
                                         val |= (1 << NETIOR_GMAC_TX_PAUSE_POS);
                                 netsoc_write_mac_reg(mac_base, NETIOR_GMAC_CTRL1, val);
                         }
-                        else {  
+                        else {
                                 val = netsoc_read_mac_reg(mac_base, NETIOR_GMAC_CTRL1);
                                 mask = (1 << NETIOR_GMAC_TX_PFC_EN_POS) | (1<<NETIOR_GMAC_RX_PFC_EN_POS) | (1 << NETIOR_GMAC_TX_PAUSE_POS);
                                 val &= ~(mask);
@@ -2918,14 +2917,14 @@ int __netsoc_config_flow_control(net_port_t *netport, uint32_t enable)
 			break;
 		case XAUI_IF:
 		case XFI_IF:
-		case RXAUI_IF:		
+		case RXAUI_IF:
 			mac_base = __netsoc_get_xgmac_base(netport);
 			if(netport->iftype==RXAUI_IF){
 				if((netport->hw_port_id%4)==2) {/*true if xlp9xx 2nd  port*/
 					mac_base = netsoc_get_macreg_base_for_xgmac2(nae->mac_base, netport->hw_port_id);
 				}
 			}
-		
+
 			if (enable) {
 				val = netsoc_read_mac_reg(mac_base, NETIOR_XGMAC_CTRL1);
 				mask = (1 << NETIOR_XGMAC_TX_PFC_EN_POS) | (1<<NETIOR_XGMAC_RX_PFC_EN_POS) | (1 << NETIOR_XGMAC_TX_PAUSE_POS);
@@ -3178,8 +3177,10 @@ void __netsoc_msec_tx_config(nae_t *nae, unsigned int port_enable, unsigned int
 	sec_tag_offset[0] = 0x0c0c0c0c;
 	sec_tag_offset[1] = 0x0c0c0c0c;
 	sec_tag_offset[2] = 0x0c;
+
+	nae->msec_tx_port_enable = port_enable;
 #ifdef MACSEC_DEBUG
-	netsoc_api_print(NETSOC_APIDBG_TRACE, "%s node = %d port_enable = %x preamble_len = %x packet_num = %d pn_thrshld = %d\n", __FUNCTION__, nae->node, port_enable, preamble_len, packet_num, pn_thrshld);
+	netsoc_api_print(NETSOC_APIDBG_TRACE, "%s node = %d num_nae = %d port_enable = %x preamble_len = %x packet_num = %d pn_thrshld = %d nae->msec_tx_port_enable = %x\n", __FUNCTION__, nae->node, nae->nae_id, port_enable, preamble_len, packet_num, pn_thrshld, nae->msec_tx_port_enable);
 #endif
 	netsoc_write_nae_reg(nae_base, TX_MSEC_BYPASS, 0x0);
 	netsoc_write_nae_reg(nae_base, TX_MSEC_ETHER_TYPE, 0x88e5);
@@ -3192,7 +3193,7 @@ void __netsoc_msec_tx_config(nae_t *nae, unsigned int port_enable, unsigned int
 	netsoc_write_nae_reg(nae_base, TX_MSEC_PREAMBLE_LEN_CODE, preamble_len);
 
 	while(preamble_len)
-	{	
+	{
 		if((preamble_len & 0x3) == 0x1)
 			sec_tag_offset[i/4] += 0xc << ((i%4) * 8);
 		if((preamble_len & 0x3) == 0x2)
@@ -3206,9 +3207,9 @@ void __netsoc_msec_tx_config(nae_t *nae, unsigned int port_enable, unsigned int
                num_ports = 9;
         else
                num_ports = 8;
-       
+
 	//for(i = 0; i < 8/*Num_ports*/;i++)
-        for(i = 0; i < num_ports;i++) 
+        for(i = 0; i < num_ports;i++)
 	{
 		nae->sectag_offset[i] = (sec_tag_offset[i/4] >> (i *8)) &0xff;
 		nae->icv_len[i] = icv_len;
@@ -3253,7 +3254,7 @@ void __netsoc_msec_tx_default_config(nae_t *nae, unsigned int port_enable, unsig
 		sci = sci | 1; /* Port identifier 1. 0 will be taken directly from SRC MAC */
 
 #ifdef MACSEC_DEBUG
-        	netsoc_api_print(NETSOC_APIDBG_TRACE, "macsec port_num = %d cntx = %d, tci = %d src_mac = %llx dst_mac = %llx sci = %llx tci = %x \n",sa[i].port_num, sa[i].cntx, sa[i].tci, sa[i].src, sa[i].dst, sci, sa[i].tci); 
+        	netsoc_api_print(NETSOC_APIDBG_TRACE, "macsec port_num = %d cntx = %d, tci = %d src_mac = %llx dst_mac = %llx sci = %llx tci = %x \n",sa[i].port_num, sa[i].cntx, sa[i].tci, sa[i].src, sa[i].dst, sci, sa[i].tci);
 		dump_buffer(tx_ci_key[i].key, 16, "tx_default_key:");
 #endif
 
@@ -3333,7 +3334,7 @@ void __netsoc_msec_set_rx_cam(nae_t *nae, int index, int port_num, uint64_t sci,
         uint64_t nae_base = nae->nae_base;
 
 	sci = sci & sci_mask;
-	
+
 	netsoc_write_nae_reg(nae_base, RX_MSEC_MEM_DATAREG_0, sci & 0xffffffff);
 	netsoc_write_nae_reg(nae_base, RX_MSEC_MEM_DATAREG_1, (sci>>32) & 0xffffffff);
  	if(is_nlm_xlp9xx())
@@ -3408,7 +3409,7 @@ void __netsoc_msec_set_rx_key(nae_t *nae, int index, unsigned char *key)
 void nlm_hal_msec_set_rx_key(int node, int index, unsigned char *key)
 {
 	unsigned int cntrl_reg_val = (1 << 22 | (index & 0x7ff)), local_key;
-	
+
 	local_key = (key[3] << 24) | (key[2] << 16) | (key[1] << 8) | key[0];
 	netsoc_write_nae_reg(nae_base, RX_MSEC_MEM_DATAREG_0, local_key);
 	key = key+4;
@@ -3511,7 +3512,7 @@ static void dump_rx_mem_config(nae_t *nae)
 
 }
 #endif
- 
+
 void __netsoc_msec_rx_config(nae_t *nae, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int replay_win_size)
 {
 	unsigned int sec_tag_offset[3], i = 0, port, param;
@@ -3521,16 +3522,27 @@ void __netsoc_msec_rx_config(nae_t *nae, unsigned int port_enable, unsigned int
 	sec_tag_offset[0] = 0x0c0c0c0c;
 	sec_tag_offset[1] = 0x0c0c0c0c;
  	sec_tag_offset[2] = 0x0c;
+
+	nae->msec_rx_port_enable = port_enable;
 #ifdef MACSEC_DEBUG
-        netsoc_api_print(NETSOC_APIDBG_TRACE, "%s node = %d, port_enable = %x, preamble_len = %x, packet_num = %x, replay_win_size = %d\n", __FUNCTION__, nae->node, port_enable, preamble_len, packet_num, replay_win_size);
+        netsoc_api_print(NETSOC_APIDBG_TRACE, "%s node = %d, num_nae = %d, port_enable = %x, preamble_len = %x, packet_num = %x, replay_win_size = %d nae->msec_rx_port_enable = %x\n", __FUNCTION__, nae->node, nae->nae_id, port_enable, preamble_len, packet_num, replay_win_size, nae->msec_rx_port_enable);
 #endif
  	/* Anti reply mode is not working. Always bypass anti reply check*/ /* TBD- add code for ICV removal */
-	netsoc_write_nae_reg(nae_base, RX_MSEC_BYPASS, 0x2);
-	/* Enable port and pramble len for each port */
- 	netsoc_write_nae_reg(nae_base, RX_MSEC_PORT_EN, (preamble_len | port_enable) & 0x7ffffff);
+	if(replay_win_size)
+		netsoc_write_nae_reg(nae_base, RX_MSEC_BYPASS, 0x0);
+	else
+		netsoc_write_nae_reg(nae_base, RX_MSEC_BYPASS, 0x2);
+
+ 	if(is_nlm_xlp9xx())
+		/* Enable port and pramble len for each port */
+		netsoc_write_nae_reg(nae_base, RX_MSEC_PORT_EN, (preamble_len << 9| port_enable) & 0x7ffffff);
+	else
+		netsoc_write_nae_reg(nae_base, RX_MSEC_PORT_EN, (preamble_len << 8| port_enable) & 0x7ffffff);
+
+	nae->msec_rx_port_enable = port_enable;
 
 	while(preamble_len)
-	{	
+	{
 		if((preamble_len & 0x3) == 0x1)
 			sec_tag_offset[i/4] += 0xc << ((i%4) * 8);
 		if((preamble_len & 0x3) == 0x2)
@@ -3558,7 +3570,7 @@ void __netsoc_msec_rx_config(nae_t *nae, unsigned int port_enable, unsigned int
 
 	sec_tag_preamble = (((uint64_t)sec_tag_offset[1]) << 32) | sec_tag_offset[0];
 
-	port = 0; 
+	port = 0;
 	while(port_enable)
 	{
 		if(port_enable & 0x1)
@@ -3566,7 +3578,7 @@ void __netsoc_msec_rx_config(nae_t *nae, unsigned int port_enable, unsigned int
 			/* ci offset = sectag_preamble + 16 (sectag header length)*/
 		//	param = (((sec_tag_preamble >> (port * 8)) & 0xff) + 8/*16*/) << 8 | 0x10;
  			param = (((sec_tag_offset[port/4] >> ((port%4) * 8)) & 0xff) + 8/*16*/) << 8 | 0x10;
-			
+
 #ifdef MACSEC_DEBUG
 			netsoc_api_print(NETSOC_APIDBG_TRACE, "%s param = %x\n", __FUNCTION__, param);
 #endif
@@ -3593,7 +3605,7 @@ void __netsoc_msec_rx_default_config(nae_t *nae, unsigned int port_enable, unsig
 		/* sci | port identifier = 0001 as SCB bit is not set*/
 		/*sci = sci | 1;//i%2;*/ /* As sci mask is 0xffffffffffff0000 then port identifier is not required */
 #ifdef MACSEC_DEBUG
-        	netsoc_api_print(NETSOC_APIDBG_TRACE, "macsec port_num = %d src = %llx dst = %llx sci = %llx\n",sa[i].port_num, sa[i].src, sa[i].dst, sci); 
+        	netsoc_api_print(NETSOC_APIDBG_TRACE, "macsec port_num = %d src = %llx dst = %llx sci = %llx\n",sa[i].port_num, sa[i].src, sa[i].dst, sci);
 		dump_buffer(rx_ci_key[i].key, 16, "rx_key:");
 #endif
 		__netsoc_msec_rx_mem_config(nae, sa[i].port_num, i, sci, rx_ci_key[i].key, sci_mask);
@@ -3608,7 +3620,7 @@ int __netsoc_init_ucore(nae_t *nae)
 {
 	ucore_config_t *ucore;
 	uint32_t count;
-	
+
 	netsoc_api_print(NETSOC_APIDBG_TRACE,"%s nae%d:%d\n",__func__,nae->node,nae->nae_id);
 	for(count = 0; count < 16; count++) {
 		ucore = &nae->ucore_config[count];
@@ -3629,17 +3641,17 @@ static void __netsoc_nlp1042c2_init(nae_t* nae)
 	uint32_t cplx_mask_10g_phy = nae->xaui_complex_map | nae->rxaui_complex_map;
 	int phyaddr=0, phybus=0, i; /* use these variables carefully as they are used in headers included below*/
 	int max_ports= current_netsoc->max_ports;
-	
+
 	netsoc_api_print(NETSOC_APIDBG_CONFIG,"Initializing external NLP1042 PHY with cmplex mask = 0x%x\n", cplx_mask_10g_phy);
 
 	for(port=0; port<max_ports; port++){
 		if((nae->ports[port].iftype == RXAUI_IF) || (nae->ports[port].iftype == XAUI_IF)){
-			phyaddr = nae->ports[port].ext_phy_addr;  
-			phybus = nae->ports[port].ext_phy_bus;  
-			submode = nae->ports[port].rxaui_mode; 
+			phyaddr = nae->ports[port].ext_phy_addr;
+			phybus = nae->ports[port].ext_phy_bus;
+			submode = nae->ports[port].rxaui_mode;
 			netsoc_api_print(NETSOC_APIDBG_CONFIG, "Initializing external NLP1042 PHY phyaddr= 0x%x bus = 0x%x submode=0x%x\n",  phyaddr, phybus, submode);
 			if(submode == NLP1042_PHY_10G_NONE){
-				continue;	
+				continue;
 			}else if(submode== NLP1042_PHY_10G_XAUI){
 				data = NETSOC_NLM_C45_READ(nae, phybus, phyaddr, 1, 0xc205);
 				netsoc_api_print(NETSOC_APIDBG_CONFIG, "NLP1042C2 XAUI p:%d 0xc205:%x \n", port, data);
@@ -3649,7 +3661,7 @@ static void __netsoc_nlp1042c2_init(nae_t* nae)
 				netsoc_api_print(NETSOC_APIDBG_CONFIG, "NLP1042C2 RXAUI p:%d 0xc205:%x \n", port, data);
 				#include "NETSOC_NLP1042C2_RXAUI_Dune.h"
 			}
-		}	
+		}
 	}
 }
 
@@ -3668,7 +3680,7 @@ int __netsoc_pcs_init(nae_t *nae)
                 __netsoc_xaui_pcs_init(nae, nae->xaui_complex_map, PHYMODE_XAUI);
                 __netsoc_nlp1042c2_init(nae);
         }
-        
+
 	if (nae->xfi_complex_map) {
                 netsoc_api_print(NETSOC_APIDBG_GLOBAL, "node %d XFI PCS init 0x%x \n", node, nae->xfi_complex_map);
 		__netsoc_xfi_pcs_init(nae, nae->xfi_complex_map, PHYMODE_XFI);
@@ -3729,7 +3741,7 @@ static int __netsoc_config_freein_fifo(nae_t *nae)
         /* in cache addr */
         spill_addr = spill_mem_addr >> 6;
 
-        /* in cachelines, 1 cacheline can store 12 descs  and 
+        /* in cachelines, 1 cacheline can store 12 descs  and
         get the number of cacheline required */
         if (spill_mem_size != 0) {
                 spillsz = nae->freein_fifo_spill_num_descs / 12 ;
@@ -3746,10 +3758,10 @@ static int __netsoc_config_freein_fifo(nae_t *nae)
                              buf = netsoc_api_contig_malloc(XLP_CACHE_LINE_SIZE, (spillsz * XLP_CACHELINE_SIZE));
                              if (buf == NULL) {
                                  netsoc_api_print(NETSOC_APIDBG_ERROR, "%s spill mem alloc failed fifo#%d\n",__func__, i);
-                                 spillsz = 0;                                
+                                 spillsz = 0;
                              }
                              else {
-                                 spill_addr = netsoc_api_virttophys(buf);  
+                                 spill_addr = netsoc_api_virttophys(buf);
                                  netsoc_api_print(NETSOC_APIDBG_CONFIG, "spilladdr %llx spill sz %d \n",spill_addr, (spillsz * XLP_CACHELINE_SIZE));
                                  spill_addr >>= 6;
                              }
@@ -3795,7 +3807,7 @@ static int __netsoc_config_freein_fifo(nae_t *nae)
                 /* spill credits [27:24] has to be 2 */
                 reg = (2 << 24) | th_lo | (th_hi << 12);
                 netsoc_write_nae_reg(nae->nae_base, FREE_FIFO_THRESHOLD_CFG, reg);
-		
+
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "Freein fifo spill thrhi %d thrlo %d\n",th_hi, th_lo);
                 if(spill_mem_addr && ((spill_addr << 6) > (spill_mem_addr + spill_mem_size))) {
                         netsoc_api_print(NETSOC_APIDBG_ERROR, "ERROR : Spill address range overflow\n");
@@ -3867,7 +3879,7 @@ static int __netsoc_init_net_port(net_port_t *netport, uint32_t context)
         	        nae->lane_rate[hw_port / XLP_ILK_MAX_LANES]) == 0) &&
                 	        (is_ilk_lanealigned(nae, hw_port/4))) {
                         netsoc_api_print(NETSOC_APIDBG_PORT, "Interlaken lanes on port %d are aligned\n", hw_port);
-		}	
+		}
                 else {
                         netsoc_api_print(NETSOC_APIDBG_ERROR, "Interlaken initialization on port %d failed\n", hw_port);
 		}
@@ -3897,16 +3909,16 @@ static int __netsoc_init_net_port(net_port_t *netport, uint32_t context)
 static int __netsoc_init_all_ports(nae_t *nae)
 {
 	uint32_t port =0, contexts_allocated, context = 0;
-	
+
         for(port = 0; port < nae->num_ports; port++)
         {
 		nae->ports[port].nae = nae;
-		contexts_allocated = __netsoc_init_net_port(&nae->ports[port], context);		
+		contexts_allocated = __netsoc_init_net_port(&nae->ports[port], context);
 		if (contexts_allocated < 0) {
 			netsoc_api_print(NETSOC_APIDBG_PORT, "Failed to initialize node %d nae %d port %d\n",nae->node, nae->nae_id, port);
 			while(1);
 		}
-		context += contexts_allocated;	
+		context += contexts_allocated;
 	}
 	return NETSOC_API_SUCCESS;
 }
@@ -3943,7 +3955,7 @@ int __netsoc_init_nae(nae_t *nae)
         	/* frin_fifo represents the 20 pools of free-in descriptor fifos */
 	        __netsoc_drain_allfrin_fifo_descs(nae);
                 __netsoc_deflate_frin_fifo_carving(nae);
-                
+
                 /* For U-Boot, reset_nae clears all IO BARs
                  * which messes up Flash/CPLD/GBU BARs etc
                  */
@@ -3961,7 +3973,7 @@ int __netsoc_init_nae(nae_t *nae)
 #ifndef XLP_SIM
 		//Set NAE frequency
 		__netsoc_set_frequency(nae, nae->frequency);
-#endif	
+#endif
 		__netsoc_mdio_init(nae);
 
 		__netsoc_pcs_init(nae);
@@ -3982,20 +3994,20 @@ int __netsoc_init_nae(nae_t *nae)
                 	tx_config = netsoc_read_nae_reg(nae->nae_base, TX_CONFIG);
 	                tx_config &= ~(1<<3);
         	        netsoc_write_nae_reg(nae->nae_base, TX_CONFIG, tx_config);
-        	}      
+        	}
 
 	        __netsoc_config_nae_global(nae);
 
         	if (nae->flags & VFBID_FROM_FDT) {
                 	__netsoc_config_vfbid_table(nae, 0 , MAX_VFBID_ENTRIES, nae_vfbid_tbl[nae->node][nae->nae_id]);
         	}
- 
+
 		if (is_nlm_xlp9xx()) {
-		      /* Configured for default MTU. This may not work for ports with different MTU size. */	
+		      /* Configured for default MTU. This may not work for ports with different MTU size. */
 		      netsoc_write_nae_reg(nae->nae_base, RX_ST_FWD_MODE, (1<<10) | (1536/16));
-		      			
+
 		      __netsoc_drop_runt_pkts(nae, 1);
-                      /* Disable WRED discard for now. No PRM/document available to know how to configure WRED thresholds */ 
+                      /* Disable WRED discard for now. No PRM/document available to know how to configure WRED thresholds */
                       __netsoc_config_wred_disable(nae);
                 }
 
@@ -4018,17 +4030,17 @@ int __netsoc_init_nae(nae_t *nae)
 
                 if (nae->ale_enable)
                       __netsoc_config_ale_enable(nae);
-                else 
+                else
                       __netsoc_config_ale_disable(nae);
 
- 
- 		if((is_nlm_xlp9xx() | is_nlm_xlp2xx()) && nae->msec_port_enable)
+
+ 		if((is_nlm_xlp9xx() | is_nlm_xlp2xx()) && (nae->msec_tx_port_enable || nae->msec_rx_port_enable))
  		{
- 			__netsoc_msec_tx_default_config(nae,/* port_enable0xff*/nae->msec_port_enable, /*unsigned int preamble_len*//*0x5555*/0, /*packet_num*/ 0x1, /*pn_thrshld*/0x7fffffff);
-                         __netsoc_msec_rx_default_config(nae, /*port_enable0xff*/nae->msec_port_enable, /*preamble_len*//*0xaaaa*/0, /*packet_num*/0x1, /*replay_win_size*/0x64);
+ 			__netsoc_msec_tx_default_config(nae,/* port_enable0xff*/nae->msec_tx_port_enable, /*unsigned int preamble_len*//*0x5555*/0, /*packet_num*/ 0x1, /*pn_thrshld*/0x7fffffff);
+                         __netsoc_msec_rx_default_config(nae, /*port_enable0xff*/nae->msec_rx_port_enable, /*preamble_len*//*0xaaaa*/0, /*packet_num*/0x1, /*replay_win_size*/0x64);
                  }
                  else
-                         nae->msec_port_enable = 0;
+                         nae->msec_rx_port_enable =  nae->msec_tx_port_enable = 0;
 	}
 	return NETSOC_API_SUCCESS;
 }
-- 
1.9.1

