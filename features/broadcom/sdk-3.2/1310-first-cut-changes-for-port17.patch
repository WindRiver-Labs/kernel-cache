From fdb369408efc9ba00844578e8214da5a9b390eea Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Thu, 7 Oct 2010 23:32:33 -0700
Subject: [PATCH 1310/1532] first cut changes for port17

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/init_nae.c   | 122 +++++++++++++------------
 drivers/net/ethernet/broadcom/nae/net_common.h |  25 ++++-
 drivers/net/ethernet/broadcom/nae/xlp_nae.c    |  88 +++++++++---------
 3 files changed, 125 insertions(+), 110 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/init_nae.c b/drivers/net/ethernet/broadcom/nae/init_nae.c
index f9b05eb..4bd75e4a 100644
--- a/drivers/net/ethernet/broadcom/nae/init_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/init_nae.c
@@ -16,6 +16,9 @@
 
 #define VAL_UCORE_RESET(x)             ( ( (x) &0xffff) << 8)
 
+struct nae_config nae_cfg;
+int cntx2port[1024];
+
 /*
  *  Temporary direct ucore configuration. HAL needs to support stop and restart
  * of ucores before reloading code
@@ -130,7 +133,6 @@ static void parse_poe_config(void)
 
 	getprop(node, "regs", poe_regs, size);
 
-	//local_load_ucore(uc_mask, (unsigned int *)uc_opcodes, num_opcodes);
 	nlm_hal_init_poe_regs(PCIE_MEM_POE_REG, poe_regs, num_regs);
 
 	kfree(poe_regs);
@@ -144,24 +146,20 @@ static void parse_fdt_cpu_config(void)
 	if (!node) {
 		printk("[%s] Unable to parse cpu-nae configuration! Using defaults:\n",
 		       __func__);
-		goto use_defaults;
+		goto out;
 	}
 
-	if (getprop(node, "nae-rx-vc", &nae_rx_vc, sizeof(uint32_t)) < 0) {
+	if (getprop(node, "nae-rx-vc", &nae_cfg.rx_vc, sizeof(uint32_t)) < 0) {
 		printk("Unable to parse nae_rx_vc, using defaults\n");
-		goto use_defaults;
+		goto out;
 	}
 
-	if (getprop(node, "nae-fb-vc", &nae_fb_vc, sizeof(uint32_t)) < 0) {
+	if (getprop(node, "nae-fb-vc", &nae_cfg.fb_vc, sizeof(uint32_t)) < 0) {
 		printk("Unable to parse nae_rx_vc, using defaults\n");
-		goto use_defaults;
+		goto out;
 	}
 
-	return;
-
- use_defaults:
-	nae_rx_vc = 0;
-	nae_fb_vc = 1;
+ out:
 
 	return;
 }
@@ -174,8 +172,8 @@ static void parse_fdt_nae_config(void)
 	int port_type = UNKNOWN_IF;
 	char port_type_str[MAX_PROP_LEN];
 	int size = 0;
-	uint32_t start_port, num_nae_regs, num_intf_regs;
 	int num_ports = 0;
+	uint32_t start_port, num_nae_regs, num_intf_regs;
 
 	/* Parse Nae Config */
 	start_port = num_nae_regs = num_intf_regs = 0;
@@ -218,9 +216,7 @@ static void parse_fdt_nae_config(void)
 	{
 		uint32_t *nae_regs = 0, *intf_regs = 0;
 		int mgmt_intf = 0;
-		int hw_port_id = 0;
-		int txq_range[2];
-		int rxq;
+		int port = 0;
 
 		sprintf(domstr, "/soc/nae-cfg/port@%d", i);
 
@@ -229,31 +225,30 @@ static void parse_fdt_nae_config(void)
 
 		if (getprop(subnode, "mgmt", &mgmt_intf, sizeof(uint32_t)) < 0)
 			printk("fdt missing mgmt\n");
-		else {
-			if (!mgmt_intf) {
-				printk("Skipping non-mgmt port[%d]\n", i);
-				continue;
-			}
-		}
 
-		netif_ports++;
+		port = nae_cfg.num_ports;
+		nae_cfg.num_ports++;
 
-		if (getprop(subnode, "tx-que-range", txq_range, sizeof(uint32_t) * 2) < 0)
+		nae_cfg.ports[port].valid = 1;
+		nae_cfg.ports[port].mgmt = mgmt_intf;
+
+		if (getprop(subnode, "tx-que-range", &nae_cfg.ports[port].txq_range[0], sizeof(uint32_t) * 2) < 0)
 			printk("fdt missing tx-que-range\n");
 		else {
-			printk("tx-que-range[%d %d]\n", txq_range[0], txq_range[1]);
+			printk("tx-que-range[%d %d]\n", nae_cfg.ports[port].txq_range[0],
+			       nae_cfg.ports[port].txq_range[1]);
 		}
 
-		if (getprop(subnode, "rx-que", &rxq, sizeof(uint32_t)) < 0)
+		if (getprop(subnode, "rx-que", &nae_cfg.ports[port].rxq, sizeof(uint32_t)) < 0)
 			printk("fdt missing rx-que\n");
 		else {
-			printk("rx-que[%d]\n", rxq);
+			printk("rx-que[%d]\n", nae_cfg.ports[port].rxq);
 		}
 
-		if (getprop(subnode, "hw-port-id", &hw_port_id, sizeof(uint32_t)) < 0)
+		if (getprop(subnode, "hw-port-id", &nae_cfg.ports[port].hw_port_id, sizeof(uint32_t)) < 0)
 			printk("fdt missing hw-port-id\n");
 		else {
-			printk("hw-port-id[%d]\n", hw_port_id);
+			printk("hw-port-id[%d]\n", nae_cfg.ports[port].hw_port_id);
 		}
 
 		getprop(subnode, "type", port_type_str, MAX_PROP_LEN);
@@ -262,7 +257,7 @@ static void parse_fdt_nae_config(void)
 		else if (!strcmp(port_type_str, "INTERLAKEN_IF")) port_type = INTERLAKEN_IF;
 		else port_type = UNKNOWN_IF;
 
-		getprop(subnode, "num-free-desc", &max_num_desc,
+		getprop(subnode, "num-free-desc", &nae_cfg.ports[port].num_free_desc,
 			sizeof(uint32_t));
 
 		size = sizeof(uint32_t) * num_nae_regs * 2;
@@ -284,7 +279,7 @@ static void parse_fdt_nae_config(void)
 #ifndef RELY_ON_FIRMWARE_CONFIG
 		printk("Configuring per-port interface registers for port@%d\n", i);
 		/* Configure per port interface registers */
-		nlm_hal_init_if_regs(port_type, hw_port_id, intf_regs, num_intf_regs);
+		nlm_hal_init_if_regs(port_type, nae_cfg.ports[port].hw_port_id, intf_regs, num_intf_regs);
 
 		printk("Configuring per-port NAE registers for port@%d\n", i);
 		/* Configure per port NAE registers */
@@ -294,7 +289,7 @@ static void parse_fdt_nae_config(void)
 		kfree(intf_regs);
 
 #ifndef RELY_ON_FIRMWARE_CONFIG
-		if (nlm_hal_open_if(port_type, hw_port_id) < 0) {
+		if (nlm_hal_open_if(port_type, nae_cfg.ports[port].hw_port_id) < 0) {
 			printk("[%s] Unable to open port %d\n", __func__, i);
 			continue;
 		}
@@ -303,28 +298,6 @@ static void parse_fdt_nae_config(void)
 	}
 }
 
-static void config_poe_dist_vect(void)
-{
-	int reg_index_base = 0x400 >> 2;
-	int reg_offset = 0x30 >> 2;
-	int reg = 0;
-	int i = 0;
-	uint32_t vc_mask[4] = {
-		[0] = 0x11111111,
-		[1] = 0x11111111,
-		[2] = 0x11111111,
-		[3] = 0x11111111,
-	};
-
-	for (i = 0; i < 4; i++) {
-
-		reg = reg_index_base + reg_offset + i;
-
-		nlm_hal_write_poe_pcim_reg(reg, vc_mask[i]);
-	}
-
-}
-
 static void config_fmn(void)
 {
 	unsigned long mflags = 0;
@@ -355,11 +328,26 @@ static void zap_nae_frin_fifo(void)
 	nlm_hal_write_nae_reg(RX_FREE_FIFO_POP, 0);
 }
 
-void initialize_nae(void)
+int initialize_nae(void)
 {
+	int i = 0;
+
 	if (check_header()) {
 		printk("Sanity check on FDT blob failed! Aborting\n");
-		return;
+		return -1;
+	}
+
+	/* Initialize default configuration */
+	for (i = 0; i < 18; i++) {
+		nae_cfg.fb_vc = 1;
+		nae_cfg.rx_vc = 0;
+		nae_cfg.ports[i].valid = 0;
+		nae_cfg.ports[i].mgmt = 0;
+	}
+
+	for (i = 0; i < 1024; i++) {
+		/* 18 is an invalid port */
+		cntx2port[i] = 18;
 	}
 
 	zap_nae_frin_fifo();
@@ -378,8 +366,26 @@ void initialize_nae(void)
 	printk("Configuring PoE...\n");
 	parse_poe_config();
 
-/* 	printk("Configuring POE distribution vector...\n"); */
-/* 	config_poe_dist_vect(); */
-
 	printk("NAE configuration done!\n");
+
+	printk("Digest of FDT based NAE config: \n");
+	printk("fb_vc = %d, rx_vc = %d\n", nae_cfg.fb_vc, nae_cfg.rx_vc);
+	for (i = 0; i < 18; i++) {
+		int context = 0;
+		struct nae_port *port = &nae_cfg.ports[i];
+
+		if (!port->valid) continue;
+
+		/* Default NAE configuration uses hw_port_id as the context */
+		context = port->hw_port_id;
+		cntx2port[context] = i; /* logical port */
+
+		printk("port@%d: valid = %d, mgmt = %d, num_free_desc = %d\n"
+		       "\t txq[0] = %d, txq[1] = %d, rxq = %d, hw_port_id = %d\n", i,
+		       port->valid, port->mgmt, port->num_free_desc,
+		       port->txq_range[0], port->txq_range[1], port->rxq, port->hw_port_id);
+
+	}
+
+	return 0;
 }
diff --git a/drivers/net/ethernet/broadcom/nae/net_common.h b/drivers/net/ethernet/broadcom/nae/net_common.h
index e3e7529..d6e3c72 100644
--- a/drivers/net/ethernet/broadcom/nae/net_common.h
+++ b/drivers/net/ethernet/broadcom/nae/net_common.h
@@ -158,12 +158,27 @@ static __inline__ void tx_print(uint64_t msg0) {
 	       (msg0) & 0xffffffffffULL);
 }
 
-extern int netif_ports;
-extern uint32_t max_num_desc;
 extern int debug;
-extern uint32_t nae_rx_vc;
-extern uint32_t nae_fb_vc;
 
-extern void initialize_nae(void);
+struct nae_port {
+	int  valid;
+	int  mgmt;
+        int  num_free_desc;
+        int  txq_range[2];
+        int  rxq;
+        int  hw_port_id;
+};
+
+struct nae_config {
+	int fb_vc;
+        int rx_vc;
+	int num_ports;
+	struct nae_port ports[18];
+};
+
+extern struct nae_config nae_cfg;
+extern int cntx2port[];
+
+extern int initialize_nae(void);
 
 #endif
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index e0b075e..e1cde3e 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -103,14 +103,11 @@ module_param(naecfg_hack, int, 0);
  *
  * Below parameters are set during FDT file parsing
  */
-int netif_ports = 0;
-uint32_t max_num_desc = 32;
-/* Keep this 3/4th of max_num_desc. This gets initialized after
- * FDT processing
- */
-uint32_t frin_desc_thres = 24;
-uint32_t nae_rx_vc = 0;
-uint32_t nae_fb_vc = 0;
+int frin_desc_thres = 24;
+module_param(frin_desc_thres, int, 0);
+
+static uint32_t nae_rx_vc = 0;
+static uint32_t nae_fb_vc = 0;
 /***************************************************************/
 
 unsigned char eth_hw_addr[18][6] = {
@@ -167,7 +164,6 @@ static void nlm_xlp_mac_timer(unsigned long data);
 static struct net_device_stats *nlm_xlp_mac_get_stats(struct net_device *dev);
 
 static struct net_device *dev_mac[MAX_GMAC_PORT];
-struct net_device *dev_mac_type[MAX_XLP_NET_TYPES][MAX_GMAC_PORT];
 
 extern struct proc_dir_entry *nlm_root_proc;
 static struct tasklet_struct mac_refill_task[MAX_GMAC_PORT];
@@ -392,16 +388,20 @@ static void nlm_xlp_nae_init(void)
 	struct proc_dir_entry *entry;
 
 	printk("======= Module Parameters =========\n");
-	printk("debug = %d, naecfg_hack=%d drop_uboot_pkt=%d\n",
-	       debug, naecfg_hack, drop_uboot_pkt);
+	printk("debug = %d, frin_desc_thres=%d naecfg_hack=%d drop_uboot_pkt=%d\n",
+	       debug, frin_desc_thres, naecfg_hack, drop_uboot_pkt);
 
-	initialize_nae();
+	if (initialize_nae()) return;
 
-	/* max_num_desc is set through FDT */
-	frin_desc_thres = (max_num_desc * 3) / 4;
+	nae_fb_vc = nae_cfg.fb_vc;
+	nae_rx_vc = nae_cfg.rx_vc;
 
-	for(i = 0; i < netif_ports; i++)
+	for(i = 0; i < nae_cfg.num_ports; i++)
 	{
+		/* Register only valid ports which are management */
+		if (!nae_cfg.ports[i].valid)
+			continue;
+
 		dev = alloc_etherdev(sizeof(struct dev_data));
 		if(!dev)
 			return;
@@ -420,18 +420,19 @@ static void nlm_xlp_nae_init(void)
 		dev->dev_addr = eth_hw_addr[i];
 		priv->port	= i;
 
-		atomic64_set(&priv->frin_to_be_sent, max_num_desc);
+		atomic64_set(&priv->frin_to_be_sent, nae_cfg.ports[i].num_free_desc);
 		atomic64_set(&priv->num_replenishes, 0);
 		atomic64_set(&priv->total_frin_sent, 0);
 
 		priv->inited	= 0;
 		priv->block 	=(i & 0xff) >> 2;
 		priv->index 	= i & 0x3;
-		priv->nae_tx_qid 	= 492 + i;
-		priv->nae_rx_qid 	= 1016 + i;
+
+		priv->nae_tx_qid 	= nae_cfg.ports[i].txq_range[0];
+		priv->nae_rx_qid 	= nae_cfg.ports[i].rxq;
+
 		register_netdev(dev);
 
-		dev_mac_type[priv->type][priv->port] = dev;
 		dev_mac[i] = dev;
 
 		tasklet_init(&mac_refill_task[priv->port],
@@ -769,32 +770,26 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 
 	if( vc == nae_fb_vc && size == 1)
 	{
-		/* Process Transmit Complete */
+		/* Process Transmit Complete, addr is the skb pointer */
 		addr = msg0 & 0xffffffffffULL;
 
-		/* context is XLP_SGMII_RCV_CONTEXT_NUM + three bit vlan type
-		 * or vlan priority
-		 */
-		context = (msg0 >> 40) & 0x3fff;
-		port = 0;//context / XLP_SGMII_RCV_CONTEXT_NUM;
-
-		/* update dev and port to be accurate */
-		if(port >= MAX_GMAC_PORT) {
-			printk("[%s]: [txc] Bad port %d (context=%d)\n",
-			       __func__, port, context);
+		if (drop_uboot_pkt) {
+			if ( (addr >= (192<<20)) && (addr < (256 << 20)) ) {
+				printk("Dropping firmware TXC packet (addr=%llx)!\n", addr);
+				stats_uboot_pkts++;
+				return;
+			}
 		}
 
-		pdev = (struct net_device*)dev_mac[port];
-		if(!pdev) {
-			printk("[%s]: [txc] wrong port=%d? pdev = NULL!\n",
-			       __func__, port);
-			return;
-		}
-		priv = netdev_priv(pdev);
+		/* context field is currently unused */
+		context = (msg0 >> 40) & 0x3fff;
+		port = cntx2port[context];
 
 		skb = (struct sk_buff *)bus_to_virt(addr);
 		if(skb)
 		{
+			priv = netdev_priv(skb->dev);
+
 			if (debug) {
 				printk("[%s][TXC] addr=%llx, skb=%p, context=%d, port=%d\n",
 				       __func__, addr, skb, context, port);
@@ -804,7 +799,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			priv->cpu_stats[cpu].txc_packets++;
 		}
 		else {
-			printk("[%s]: [txc] Null skb? paddr = %llx\n", __func__, addr);
+			printk("[%s]: [txc] Null skb? paddr = %llx (halting cpu!)\n", __func__, addr);
 			cpu_halt();
 		}
 	}
@@ -813,27 +808,26 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		/* Rx packet */
 		addr	= msg1 & 0xffffffffc0ULL;
 		len	= (msg1 >> 40) & 0x3fff;
-		context = msg1 >> 54;
+		context = (msg1 >> 54) & 0x3ff;
 
 		if (drop_uboot_pkt) {
 			if ( (addr >= (192<<20)) && (addr < (256 << 20)) ) {
-				printk("Dropping firmware network packet (addr=%llx)!\n", addr);
+				printk("Dropping firmware RX packet (addr=%llx)!\n", addr);
 				stats_uboot_pkts++;
 				return;
 			}
 		}
 
-		/*context is XLP_SGMII_RCV_CONTEXT_NUM + three bit vlan type or vlan priority*/
-		port = 0; //context / XLP_SGMII_RCV_CONTEXT_NUM;
-
-		/* update dev and port to be accurate */
-		if(port < 0 || port >= MAX_GMAC_PORT)
+		port = cntx2port[context];
+		if(port >= MAX_GMAC_PORT)
 		{
-			port = 0;
+			printk("[%s]: bad port=%d, context=%d\n", __func__, port, context);
+			return;
 		}
+
 		pdev = (struct net_device*)dev_mac[port];
 		if(!pdev) {
-			printk("[%s]: [rx] wrong port=%d? pdev = NULL!\n", __func__, port);
+			printk("[%s]: [rx] wrong port=%d(context=%d)? pdev = NULL!\n", __func__, port, context);
 			return;
 		}
 		priv = netdev_priv(pdev);
-- 
1.9.1

