From 3542bbd51d9342c89d3c7522cd649a4a8bf696af Mon Sep 17 00:00:00 2001
From: "P. Sadik" <psadik@broadcom.com>
Date: Wed, 1 May 2013 16:06:59 +0530
Subject: [PATCH 1137/1532] soc_interface: Fix compilation warning.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/soc_interface/on_chip.c | 55 ++++++++++++++-------------
 1 file changed, 28 insertions(+), 27 deletions(-)

diff --git a/drivers/misc/netlogic/soc_interface/on_chip.c b/drivers/misc/netlogic/soc_interface/on_chip.c
index 169cc57..815448d 100644
--- a/drivers/misc/netlogic/soc_interface/on_chip.c
+++ b/drivers/misc/netlogic/soc_interface/on_chip.c
@@ -36,6 +36,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/timer.h>
+#include <linux/proc_fs.h>
 
 #include "nlm_msgring.h"
 #include "nlm_xlp.h"
@@ -158,7 +159,7 @@ static uint16_t vc_to_handle_map[MAX_VC] = {
 	[1416 ... 1499] = XLP_MSG_HANDLE_INVALID,
 	[1500 ... 2043] = XLP_MSG_HANDLE_NAE_0,
 	[2044 ... 2047] = XLP_MSG_HANDLE_INVALID,
-	// NODE-2	
+	// NODE-2
 	[2048 ... 2063] = XLP_MSG_HANDLE_CPU0,
 	[2064 ... 2079] = XLP_MSG_HANDLE_CPU1,
 	[2080 ... 2095] = XLP_MSG_HANDLE_CPU2,
@@ -176,7 +177,7 @@ static uint16_t vc_to_handle_map[MAX_VC] = {
 	[2316 ... 2319] = XLP_MSG_HANDLE_GDX,
 	[2320 ... 2328] = XLP_MSG_HANDLE_RSA_ECC,
 	[2329 ... 2344] = XLP_MSG_HANDLE_CRYPTO,
-	[2345 ... 2352] = XLP_MSG_HANDLE_CMP, 
+	[2345 ... 2352] = XLP_MSG_HANDLE_CMP,
 	[2353 ... 2431] = XLP_MSG_HANDLE_INVALID,
 	[2432 ... 2439] = XLP_MSG_HANDLE_NAE_0,
 	[2440 ... 2523] = XLP_MSG_HANDLE_INVALID,
@@ -270,20 +271,20 @@ static uint16_t xlp2xx_vc_to_handle_map[MAX_VC] = {
 static uint16_t *vc_to_handle = vc_to_handle_map;
 
 /******************************************************************************************
- *  dummy_handler 
+ *  dummy_handler
  *
  *  @vc		cpu vc number
  *  @src_id	msg sender station vc
  *  @size	msg_size-1
  *  @code	software code nae or poe can put in
- *  @msg0	64 bit msg0 structure 
- *  @msg1	64 bit msg1 structure 
- *  @msg2	64 bit msg2 structure 
- *  @msg3	64 bit msg3 structure 
+ *  @msg0	64 bit msg0 structure
+ *  @msg1	64 bit msg1 structure
+ *  @msg2	64 bit msg2 structure
+ *  @msg3	64 bit msg3 structure
  *  @dev_id	driver write can save a device id here
  *
  ******************************************************************************************/
-void dummy_handler(uint32_t vc, uint32_t src_id, uint32_t size, uint32_t code, 
+void dummy_handler(uint32_t vc, uint32_t src_id, uint32_t size, uint32_t code,
 		   uint64_t msg0, uint64_t msg1, uint64_t msg2, uint64_t msg3, void *dev_id)
 {
 #if 0
@@ -319,7 +320,7 @@ int nlm_xlp_register_napi_vc_handler(int vc, int (*handler)(int vc, int budget))
 
 	if(!xlp_fmn_init_done)
 		xlp_fmn_init_done = 1;
-	
+
 	xlp_napi_vc_handlers[vc] = handler;
 	return 0;
 }
@@ -356,14 +357,14 @@ int nlm_xlp_register_intr_vc(int cpu, int vc)
 
 	if(!xlp_fmn_init_done)
 		xlp_fmn_init_done = 1;
-	
+
 	node = cpu / 32;
 	nlm_hal_enable_vc_intr(node, (cpu*4 + vc) & 0x7f);
 
 	spin_lock_irqsave(&msgrng_lock, flags);
 	intr_vc_mask[cpu] |= (1 << vc);
 	spin_unlock_irqrestore(&msgrng_lock, flags);
-	
+
 	/*printk("%s in, cpu %d intr_vc_mask %x\n", __FUNCTION__, cpu, intr_vc_mask[cpu]);*/
 	return 0;
 }
@@ -386,11 +387,11 @@ int nlm_xlp_unregister_intr_vc(int cpu, int vc)
 EXPORT_SYMBOL(nlm_xlp_unregister_intr_vc);
 
 /*********************************************************************
- * nlm_xlp_msgring_int_handler 
+ * nlm_xlp_msgring_int_handler
  *
  *  @irq	msgring irq number
- *  @regs	linux systems call back function provide struct pt_regs 
- *  
+ *  @regs	linux systems call back function provide struct pt_regs
+ *
  ********************************************************************/
 void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 {
@@ -407,7 +408,7 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	unsigned int vcmask;
 
 	msg0 = msg1 = msg2 = msg3 = 0;
-	
+
 	if (irq == XLP_IRQ_MSGRING_RVEC) {
                 /* normal message ring interrupt */
                 /* xlr_inc_counter(MSGRNG_INT);  */
@@ -444,7 +445,7 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 		}
 
 		vc_empty_status = (msg_status1 >> 24) & pop_vc_mask;
-		if (vc_empty_status == pop_vc_mask) break;  
+		if (vc_empty_status == pop_vc_mask) break;
 
 		for( vc = 0; vc < 4; vc++)
 		{
@@ -538,7 +539,7 @@ void xlp_poll_vc0_messages(void)
 EXPORT_SYMBOL(xlp_poll_vc0_messages);
 
 /*******************************************************************************************
- *  register_xlp_msgring_handler 
+ *  register_xlp_msgring_handler
  *
  *  @major      handler id number, each type handler has an ID
  *  @action     handler callback function (see dummy_handler above for detail)
@@ -630,7 +631,7 @@ EXPORT_SYMBOL(nlm_xlp_register_napi_final_handler);
 #include "nlm_cpumask.h"
 
 /*********************************************************************
- * enable_msgconfig_int 
+ * enable_msgconfig_int
  *
  ********************************************************************/
 void enable_msgconfig_int(void *data)
@@ -688,10 +689,10 @@ int xlp_fmn_poll(struct napi_struct *napi, int budget)
 	while(count < budget){
 		for( no_msg = 0, vc = 0; vc < 4; vc++)
 		{
-			
+
 			if(!(napi_vc_mask & (1<<vc)))
 				continue;
-	
+
 			/* Explicit per vc napi handlers. Here the vc handler does the polling of
 			 all the packets */
 			if(xlp_napi_vc_handlers[vc]) {
@@ -701,7 +702,7 @@ int xlp_fmn_poll(struct napi_struct *napi, int budget)
 					no_msg++;
 				continue;
 			}
-			
+
 			msgrng_access_enable(mflags);
 			status = xlp_message_receive( vc, &src_id, &size, &code, &msg0, &msg1, &msg2, &msg3);
 			msgrng_access_disable(mflags);
@@ -733,7 +734,7 @@ int xlp_fmn_poll(struct napi_struct *napi, int budget)
 		hndlr_id = handler - &msg_handler_map[0];
 		napi_final_needed[cpu][hndlr_id] = 0;
 	}
-	
+
 
 	/*Ack fmn interrupts.*/
 	if(count < budget) {
@@ -742,7 +743,7 @@ int xlp_fmn_poll(struct napi_struct *napi, int budget)
 		local_irq_save(flags);
 		msgrng_access_enable(mflags);
                 napi_complete(napi);
-		
+
 		if (is_cpu_core_xlp_ii) {
                 	xlp_write_msg_int(napi_vc_mask);
 		}
@@ -814,7 +815,7 @@ EXPORT_SYMBOL(msgring_irq_init);
 
 /*********************************************************************
  * on_chip_init
- *  
+ *
  ********************************************************************/
 struct proc_dir_entry *nlm_root_proc;
 EXPORT_SYMBOL(nlm_root_proc);
@@ -981,7 +982,7 @@ static int __init on_chip_init(void)
 	for_each_possible_cpu(i)
 		cpumask_set_cpu(cpu_logical_map(i), &phys_cpu_present_map);
 
-	is_cpu_core_xlp_ii = is_nlm_xlp2xx();	
+	is_cpu_core_xlp_ii = is_nlm_xlp2xx();
 	node = hard_smp_processor_id() / NLM_MAX_CPU_PER_NODE;
 	nlm_proc_setup();
 
@@ -1013,11 +1014,11 @@ static int __init on_chip_init(void)
 		vc_to_handle = xlp3xx_vc_to_handle_map;
 	else
 		vc_to_handle = vc_to_handle_map;
-		
+
 	if(xlp_napi_vc_mask)
 		xlp_napi_fmn_setup();
 #endif
-	
+
 	nlm_fmn_init();
 
 	msgring_irq_init();
-- 
1.9.1

