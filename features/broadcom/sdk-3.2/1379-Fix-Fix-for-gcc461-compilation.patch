From 0bde6b245056525d496ab5b75836512575c3f06f Mon Sep 17 00:00:00 2001
From: Anurag <anurag.gopinath@broadcom.com>
Date: Wed, 31 Oct 2012 17:58:42 +0530
Subject: [PATCH 1379/1532] Fix : Fix for gcc461 compilation

When "-Winline" option is enabled in the commandline and it searches
for the inline function definition in each of the files where inline
function calls are made. Without this option being set, if the compiler
doesn't find the function definition in a file, it treats the functions
as normal function and will look for the function defintion at the linker stage.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/xlpge_rx.c | 50 ++++++++++++++++++++++++++++
 drivers/net/ethernet/broadcom/nae/xlpge_tx.c | 50 ----------------------------
 2 files changed, 50 insertions(+), 50 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_rx.c b/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
index bccc6dd..e4c043e 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
@@ -44,6 +44,56 @@
 
 uint64_t receive_count[NR_CPUS * 8] __cacheline_aligned;
 
+inline void process_tx_complete(int cpu, uint32_t src_id, uint64_t msg0)
+{
+        struct sk_buff* skb;
+#ifdef TSO_ENABLED
+        uint64_t *p2pfbdesc;
+#endif
+        uint64_t addr;
+        uint32_t context, port, node;
+
+        Message("%s cpu %d src_id %d\n", __FUNCTION__, cpu, src_id);
+
+        /* Process Transmit Complete, addr is the skb pointer */
+        addr = msg0 & 0xffffffffffULL;
+
+        /* context field is currently unused */
+        context = (msg0 >> 40) & 0x3fff;
+        node = (src_id >> 10) & 0x3;
+        port = *(cntx2port[node] + context);
+
+        if (addr == dummy_pktdata_addr[node]){
+                printk("Dropping firmware RX packet (addr=%llx)!\n", addr);
+                return;
+        }
+
+#ifdef TSO_ENABLED
+        if(nlm_mode[CPU_INDEX(cpu)] == NLM_TCP_MODE){
+                p2pfbdesc = bus_to_virt(addr);
+                skb = (struct sk_buff *)(ulong)(p2pfbdesc[P2P_SKB_OFF]);
+                free_p2p_desc_mem(cpu, p2pfbdesc);
+        } else
+#endif
+                skb = (struct sk_buff *)bus_to_virt(addr);
+
+        if(skb)
+        {
+#ifdef IEEE_1588_PTP_ENABLED
+                if(skb->sk &&
+                        sock_flag(skb->sk, SOCK_TIMESTAMPING_TX_HARDWARE))
+                        nlm_1588_ptp_hwtstamp_tx(skb);
+#endif
+
+                dev_kfree_skb_any(skb);
+        }
+        else {
+                printk("[%s]: [txc] Null skb? "
+                       " paddr = %llx (halting cpu!)\n", __func__, addr);
+                cpu_halt();
+        }
+}
+
 static inline void process_rx_packets(int cpu, unsigned int src_id, 
 		unsigned long long msg0, unsigned long long msg1)
 {
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_tx.c b/drivers/net/ethernet/broadcom/nae/xlpge_tx.c
index f03d6c6..42d7bf9 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_tx.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_tx.c
@@ -47,56 +47,6 @@ uint64_t err_replenish_count[NR_CPUS * 8] __cacheline_aligned;
 
 extern uint64_t dummy_pktdata_addr[NLM_MAX_NODES];
 
-inline void process_tx_complete(int cpu, uint32_t src_id, uint64_t msg0)
-{
-	struct sk_buff* skb;
-#ifdef TSO_ENABLED
-	uint64_t *p2pfbdesc;
-#endif
-	uint64_t addr;
-	uint32_t context, port, node;
-
-	Message("%s cpu %d src_id %d\n", __FUNCTION__, cpu, src_id);
-
-	/* Process Transmit Complete, addr is the skb pointer */
-	addr = msg0 & 0xffffffffffULL;
-
-	/* context field is currently unused */
-	context = (msg0 >> 40) & 0x3fff;
-	node = (src_id >> 10) & 0x3;
-	port = *(cntx2port[node] + context);
-
-	if (addr == dummy_pktdata_addr[node]){
-		printk("Dropping firmware RX packet (addr=%llx)!\n", addr);
-		return;
-	}
-
-#ifdef TSO_ENABLED
-	if(nlm_mode[CPU_INDEX(cpu)] == NLM_TCP_MODE){
-		p2pfbdesc = bus_to_virt(addr);
-		skb = (struct sk_buff *)(ulong)(p2pfbdesc[P2P_SKB_OFF]);
-		free_p2p_desc_mem(cpu, p2pfbdesc);
-	} else
-#endif
-		skb = (struct sk_buff *)bus_to_virt(addr);
-
-	if(skb)
-	{
-#ifdef IEEE_1588_PTP_ENABLED	
-		if(skb->sk &&
-			sock_flag(skb->sk, SOCK_TIMESTAMPING_TX_HARDWARE))
-			nlm_1588_ptp_hwtstamp_tx(skb);
-#endif
-		
-		dev_kfree_skb_any(skb);
-	}
-	else {
-		printk("[%s]: [txc] Null skb? "
-		       " paddr = %llx (halting cpu!)\n", __func__, addr);
-		cpu_halt();
-	}
-}
-
 /**********************************************************************
  * nlm_xlp_nae_start_xmit -  transmit a packet from buffer
  * @dev  -  this is per device based function
-- 
1.9.1

