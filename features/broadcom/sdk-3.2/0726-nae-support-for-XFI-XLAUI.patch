From 45ab39ae98cd33dcb3d67fa8ebadfa5d48c5e18f Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikas.gupta@broadcom.com>
Date: Mon, 17 Jun 2013 18:25:46 -0700
Subject: [PATCH 0726/1532] nae: support for XFI/XLAUI.

	1) XFI/XLAUI support added/updated.
	2) Statistics count API added for all interfaces type.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/netlib/include/export_sym.h |   1 +
 .../netlogic/lib/netlib/include/netsoc_common.h    |   8 +-
 arch/mips/netlogic/lib/netlib/include/netsoc_dev.h | 115 ++++++++++++++++
 .../netlogic/lib/netlib/include/netsoc_haliface.h  |   1 +
 .../netlogic/lib/netlib/include/netsoc_libiface.h  |  33 +++++
 arch/mips/netlogic/lib/netlib/include/netsoc_nae.h | 141 +++++++++++++++++++-
 arch/mips/netlogic/lib/netlib/include/nlm_nae.h    |   1 +
 arch/mips/netlogic/lib/netlib/src/netsoc_api.c     |   8 +-
 arch/mips/netlogic/lib/netlib/src/netsoc_config.c  |   2 +-
 arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c     |  19 +++
 arch/mips/netlogic/lib/netlib/src/netsoc_nae.c     | 146 +++++++++++++++++----
 arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c     |  20 ++-
 12 files changed, 454 insertions(+), 41 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/include/export_sym.h b/arch/mips/netlogic/lib/netlib/include/export_sym.h
index 780f268..6fccefb 100644
--- a/arch/mips/netlogic/lib/netlib/include/export_sym.h
+++ b/arch/mips/netlogic/lib/netlib/include/export_sym.h
@@ -50,6 +50,7 @@ EXPORT_SYMBOL(get_num_nae_pernode);
 EXPORT_SYMBOL(get_poe);
 EXPORT_SYMBOL(get_num_poe_pernode);
 EXPORT_SYMBOL(get_netsoc_features);
+EXPORT_SYMBOL(netsoc_get_port_stats);
 
 EXPORT_SYMBOL(netsoc_get_flowid);
 EXPORT_SYMBOL(netsoc_build_crc32_table);
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
index 414c4a0..12e9f54 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
@@ -69,7 +69,7 @@
 #define DEFAULT_XAUI_CAL_SLOTS          8
 #define DEFAULT_ILK_CAL_SLOTS           26
 #define DEFAULT_XFI_CAL_SLOTS          7
-#define DEFAULT_XLAUI_CAL_SLOTS                13
+#define DEFAULT_XLAUI_CAL_SLOTS        13
 
 
 
@@ -236,6 +236,7 @@ static inline uint32_t get_numfree_desc(uint32_t intf_type)
 		return DEFAULT_XAUI_NUM_FREEDESC/2;
 		
 	case XAUI_IF:
+        case XLAUI_IF:
 	case RXAUI_IF:
 		return DEFAULT_XAUI_NUM_FREEDESC;
 	case INTERLAKEN_IF:
@@ -271,6 +272,7 @@ static inline uint32_t get_free_desc_size(uint32_t intf_type)
                 return DEFAULT_SGMII_FREEDESC_SZ;
 	case XFI_IF:
         case XAUI_IF:
+        case XLAUI_IF:
         case RXAUI_IF:
                 return DEFAULT_XAUI_FREEDESC_SZ;
         case INTERLAKEN_IF:
@@ -287,6 +289,7 @@ static inline uint32_t get_intf_fifo_size(uint32_t intf_type)
         case SGMII_IF:
                 return (current_netsoc->ingress.max_if_fifo / current_netsoc->max_ports);
         case XAUI_IF:
+        case XLAUI_IF:
                 return (current_netsoc->ingress.max_if_fifo / current_netsoc->max_ports)*4;
         case RXAUI_IF:
 		if(is_nlm_xlp9xx())
@@ -312,6 +315,7 @@ static inline uint32_t get_prsr_seq_fifo_size(uint32_t intf_type)
         case SGMII_IF:
                 return DEFAULT_SGMII_PARSERSEQFIFO_SZ;
         case XAUI_IF:
+        case XLAUI_IF:
                 return DEFAULT_XAUI_PARSERSEQFIFO_SZ;
         case RXAUI_IF:
 		if(is_nlm_xlp9xx())
@@ -331,6 +335,7 @@ static inline uint32_t get_rx_buf_size(uint32_t intf_type)
         case SGMII_IF:
                 return DEFAULT_SGMII_RXFIFO_SZ;
         case XAUI_IF:
+        case XLAUI_IF:
                 return DEFAULT_XAUI_RXFIFO_SZ;
         case RXAUI_IF:
 		if(is_nlm_xlp9xx())
@@ -383,6 +388,7 @@ static inline uint32_t get_msec_port_enable(uint32_t intf_type)
 static inline void update_default_config(int intf_type, uint32_t *config, uint32_t val)
 {
         uint32_t iface;
+	
         if (intf_type == SGMII_IF) {
                 for(iface = 0; iface < 4; iface++) {
                         *config++ = val;
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
index da9ef10..e6a4a9a 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
@@ -1039,6 +1039,121 @@ enum {
 
 #define XLP_ILK_MAX_LANES               8
 
+#define	TX_PACKET_COUNTER		0x39
+#define	RX_PACKET_COUNTER		0x28
+#define	TX_BYTE_COUNTER			0x38
+#define	RX_BYTE_COUNTER			0x27
+#define	TX_FCS_ERROR_COUNTER		0x47
+#define	TX_JABBER_FRAME_COUNTER		0x46
+#define	RX_DROP_PACKET_COUNTER		0x37
+#define	TX_DROP_FRAME_COUNTER		0x45
+#define	RX_MULTICAST_PACKET_COUNTER	0x2a
+#define	TX_TOTAL_COLLISION_COUNTER	0x43
+#define	RX_FRAME_LENGTH_ERROR_COUNTER	0x30
+#define	RX_FCS_ERROR_COUNTER		0x29
+#define	RX_JABBER_COUNTER		0x36
+#define	RX_ALIGNMENT_ERROR_COUNTER	0x2f
+#define	RX_CARRIER_SENSE_ERROR_COUNTER	0x32
+#define	TX_EXCESSIVE_COLLISION_PACKET_COUNTER	0x42
+
+/*XLGMAC related registers*/
+// XLAUI/XLGMAC related registers
+#define XLGMAC_CONFIG_REG1               0x00 // Does it exist?
+#define XLGMAC_CONFIG_REG2               0x01 // Does it exist?
+#define XLGMAC_CONFIG_REG3               0x02 // Does it exist?
+#define XLGMAC_CONFIG_REG4               0x03 // Does it exist?
+#define XLGMAC_MAXLENG                   0x08 // Does it exist?
+#define XLGMACPCS_CMD                    0x70
+#define XLGMACPCS_DATA                   0x71
+#define XLGMACPCS_CTRL                   0x72
+#define XLGMACPCS_STATUS                 0x73
+#define XLGMAC_MISC                      0x76
+#define XLGMAC_RXDROP                    0x77
+#define XLGMAC_PAUSE_QUNTA               0x78
+#define XLGMAC_PAUSE_OPC                 0x79
+#define XLGMAC_PAUSE_DA_HI               0x7A
+#define XLGMAC_PAUSE_DA_LO               0x7B
+#define XLGMAC_STATUS                    0x7C
+#define XLGMAC3_CTL                      0x7D
+#define XLGMAC3_CTL_SOFTH_SHIFT          10
+#define XLGMAC3_CTL_SOFTH_MASK           0x1F
+#define XLGMAC2_CTL                      0x7E
+#define XLGMAC1_CTL                      0x7F
+
+// Indirect registers 
+#define XLAUI_REVISION                    0x00
+#define XLAUI_SCRATCH                     0x04
+#define XLAUI_COMMNAD_CONFIG              0x08
+#define XLAUI_MAC_ADDR_0                  0x0c
+#define XLAUI_MAC_ADDR_1                  0x10
+#define XLAUI_FRM_LENGTH                  0x14
+#define XLAUI_RX_FIFO_SECTIONS            0x1c
+#define XLAUI_TX_FIFO_SECTIONS            0x20
+#define XLAUI_RX_FFO_ALMOST_F_E           0x24
+#define XLAUI_TX_FFO_ALMOST_F_E           0x28
+#define XLAUI_HASHTABLE_LOAD              0x2c
+#define XLAUI_MDIO_CFG_STATUS             0x30
+#define XLAUI_MDIO_COMMAND                0x34
+#define XLAUI_MDIO_DATA                   0x38
+#define XLAUI_MDIO_REGADDR                0x3c
+#define XLAUI_GP_STATUS                   0x40
+#define XLAUI_TX_IPG_LENGTH               0x44
+#define XLAUI_CREDIT_TRIGGER              0x48
+#define XLAUI_INIT_CREDIT                 0x4c
+#define XLAUI_CREDIT_REG                  0x50
+#define XLAUI_CL01_PAUSE_QUANTA           0x54
+#define XLAUI_CL23_PAUSE_QUANTA           0x58
+#define XLAUI_CL45_PAUSE_QUANTA           0x5c
+#define XLAUI_CL67_PAUSE_QUANTA           0x60
+#define XLAUI_CL01_QUANTA_THRESH          0x64
+#define XLAUI_CL23_QUANTA_THRESH          0x68
+#define XLAUI_CL45_QUANTA_THRESH          0x6c
+#define XLAUI_CL67_QUANTA_THRESH          0x70
+#define XLAUI_RX_PAUSE_STATUS             0x74
+#define XLAUI_TS_TIMESTAMP                0x7C
+
+
+// Status counters
+#define XLAUI_FRAME_TRANSMITTED           0x80
+#define XLAUI_FRAME_RECEIVED              0x88
+#define XLAUI_FCS_ERROR                   0x90
+#define XLAUI_ALN_ERROR                   0x98
+#define XLAUI_PAUSE_TRANSMITTED           0xa0
+#define XLAUI_PAUSE_RECEIVED              0xa8
+#define XLAUI_FTL_ERROR                   0xb0
+#define XLAUI_IRL_ERROR                   0xb8
+#define XLAUI_VLAN_TRANSMITTED            0xc0
+#define XLAUI_VLAN_RECEIVED               0xc8
+#define XLAUI_TX_BYTE_CNT                 0xd0 // 64 bit?
+#define XLAUI_RX_BYTE_CNT                 0xd8 // 64 bit?
+#define XLAUI_RX_UCAST_CNT                0xe0
+#define XLAUI_RX_MCAST_CNT                0xe8
+#define XLAUI_RX_BCAST_CNT                0xf0
+#define XLAUI_OUT_ERROR                   0xf8
+#define XLAUI_TX_UCAST_CNT                0x108
+#define XLAUI_TX_MCAST_CNT                0x110
+#define XLAUI_TX_BCAST_CNT                0x118
+#define XLAUI_ETHER_STATS_DROP_EVENT      0x120
+#define XLAUI_ETHER_STATS_BYTE            0x128 // 64 Bit?
+#define XLAUI_ETHER_STATS_PKT             0x130
+#define XLAUI_ETHER_STATS_UNDERSIZE_PKT   0x138
+#define XLAUI_ETHER_STATS_64B_PKT         0x140
+#define XLAUI_ETHER_STATS_65TO127B_PKT    0x148
+#define XLAUI_ETHER_STATS_128TO255B_PKT   0x150
+#define XLAUI_ETHER_STATS_256TO511B_PKT   0x158
+#define XLAUI_ETHER_STATS_512TO1023B_PKT  0x160
+#define XLAUI_ETHER_STATS_1024TO1518B_PKT 0x160
+#define XLAUI_ETHER_STATS_1519TOMAXB_PKT  0x170
+#define XLAUI_ETHER_STATS_OVERSIZE_PKT    0x178
+#define XLAUI_ETHER_STATS_JABBERS         0x180
+#define XLAUI_ETHER_STATS_FRAGMENTS       0x188
+#define XLAUI_IN_ERROR                    0x190
+#define XLAUI_CBFC_PAUSE_TRANSMITTED_0    0x198
+#define XLAUI_CBFC_PAUSE_RECEIVED_0       0x1d8
+#define XLAUI_MAC_CTL_FRAME_TRANSMITTED   0x218
+#define XLAUI_MAC_CTL_FRAME_RECEIVED      0x220
+
+
 #endif /*__ASSEMBLY__*/
 
 #endif /* #ifndef __NETSOC_DEV_H_ */
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
index ed76e21..55f6d7b 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
@@ -80,6 +80,7 @@ extern int __netsoc_init_poe(poe_t *poe);
 extern void __netsoc_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask);
 extern void __netsoc_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phymode);
 extern void __netsoc_xfi_pcs_init(nae_t *nae, uint32_t xfi_cplx_mask, uint32_t phymode);
+extern void __netsoc_xlaui_pcs_init(nae_t *nae, uint32_t xlaui_cplx_mask, uint32_t phymode);
 extern int __netsoc_interlaken_pcs_init(nae_t *nae, uint32_t ilk_complex_map);
 extern int register_marvell_phy(void);
 extern int register_broadcom_phy(void);
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
index 4903c00..6446932 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
@@ -70,6 +70,33 @@ enum netsoc_api_error {
 	NETSOC_API_NOT_SUPPORTED,
 };
 
+struct __netsoc_dev_stat{
+	unsigned long	rx_packets;
+	unsigned long	tx_packets;
+	unsigned long	rx_bytes;
+	unsigned long	tx_bytes;
+	unsigned long	rx_errors;
+	unsigned long	tx_errors;
+	unsigned long	rx_dropped;
+	unsigned long	tx_dropped;
+	unsigned long	multicast;
+	unsigned long	collisions;
+	unsigned long	rx_length_errors;
+	unsigned long	rx_over_errors;
+	unsigned long	rx_crc_errors;
+	unsigned long	rx_frame_errors;
+	unsigned long	rx_fifo_errors;
+	unsigned long	rx_missed_errors;
+	unsigned long	tx_aborted_errors;
+	unsigned long	tx_carrier_errors;
+	unsigned long	tx_fifo_errors;
+	unsigned long	tx_heartbeat_errors;
+	unsigned long	tx_window_errors;
+	unsigned long	rx_compressed;
+	unsigned long	tx_compressed;
+};
+typedef struct __netsoc_dev_stat dev_stat_t;
+
 struct netsoc_lib_param {
         void *(*malloc)(uint32_t size);
         void (*free)(void *buf);
@@ -250,6 +277,9 @@ static inline void netsoc_api_writel(uint64_t base, uint32_t index, uint32_t val
 #define netsoc_get_macreg_base_for_xgmac3(mac_base, hwport) \
         NETSOC_MAC_OFFSET(mac_base, (hwport / MAX_PORTS_PERBLOCK), XGMAC3)
 
+#define netsoc_get_macreg_base_for_xlgmac(mac_base, hwport) \
+        NETSOC_MAC_OFFSET(mac_base, (hwport / MAX_PORTS_PERBLOCK), XLGMAC)
+
 #define netsoc_get_macreg_base_for_gmac(mac_base, hwport) \
         NETSOC_MAC_OFFSET(mac_base, (hwport / MAX_PORTS_PERBLOCK), (hwport % MAX_PORTS_PERBLOCK))
 
@@ -302,11 +332,14 @@ extern void netsoc_read_ucore_sram(nae_t *nae, uint32_t *data,uint32_t off, uint
 extern void netsoc_modify_ucore_sram(nae_t *nae, uint32_t *data,uint32_t off, uint32_t words);
 extern int netsoc_restart_ucore_using_fdt(nae_t *nae, void *fdt);
 extern int netsoc_restart_ucore(nae_t *nae, uint32_t ucore_mask, uint32_t *opcodes, uint32_t num_opcodes);
+extern void netsoc_get_port_stats(net_port_t *netport, dev_stat_t* dev_stat);
 extern int netsoc_mac_disable(net_port_t *netport);
 extern int netsoc_mac_enable(net_port_t *netport);
 extern int netsoc_close_port(net_port_t *netport);
 extern net_port_t *netsoc_open_port(nae_t *nae, uint32_t port);
 extern int netsoc_set_framesize(net_port_t *netport, uint32_t size);
+extern void netsoc_read_mac_statistics(net_port_t *netport, dev_stat_t *dev_stat);
+
 extern int netsoc_disable_flow_control(net_port_t *netport);
 extern int netsoc_enable_flow_control(net_port_t *netport);
 extern int netsoc_mdio_write(net_port_t *netport, uint32_t type, uint32_t phyaddr, uint32_t regidx, uint32_t val);
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
index 442b03f..ecfc1e1 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
@@ -826,10 +826,57 @@ static inline int __netsoc_config_burstmax(net_port_t *netport, uint32_t max)
         return 0;
 }
 
-static inline uint64_t __netsoc_get_xgmac_base(net_port_t *netport)
+static inline uint32_t __netsoc_read_xlgmac_reg(net_port_t *netport, uint32_t addr) 
 {
+	uint64_t mac_base;
+	uint32_t cmd;
+	volatile uint32_t val;
 	nae_t *nae = netport->nae;
+        mac_base = netsoc_get_macreg_base_for_xlgmac(nae->mac_base, netport->hw_port_id);
+
+	cmd  = ( 1 << 30)  |          // Req
+		( 1 << 29)  |          // Read
+		((addr >> 2) & 0x1ff); // Byte addr
+	
+	// Write the command
+	netsoc_write_mac_reg(mac_base , XLGMACPCS_CMD, cmd);
+
+	// Wait for Busy bit to clear
+	val = (1<<31);
+	while((val & (1<<31)) == (1<<31)){
+		val = netsoc_read_mac_reg(mac_base, XLGMACPCS_CMD);
+	}
+	
+	return netsoc_read_mac_reg(mac_base, XLGMACPCS_DATA);
+}
+
+static inline void __netsoc_write_xlgmac_reg(net_port_t *netport, uint32_t addr, uint32_t data)
+{
 	uint64_t mac_base;
+	uint32_t cmd;
+	volatile uint32_t val;
+	nae_t *nae = netport->nae;
+        mac_base = netsoc_get_macreg_base_for_xlgmac(nae->mac_base, netport->hw_port_id);
+	
+	netsoc_write_mac_reg(mac_base , XLGMACPCS_DATA, data);
+    	cmd  = ( 1 << 30)  |          // Req
+           ( 0 << 29)  |          // Write
+           ((addr >> 2) & 0x1ff); // Byte addr
+
+	// Write the command
+	netsoc_write_mac_reg(mac_base , XLGMACPCS_CMD, cmd);
+	// Wait for Busy bit to clear
+	val = (1<<31);
+	while((val & (1<<31)) == (1<<31)){
+		val = netsoc_read_mac_reg(mac_base, XLGMACPCS_CMD);
+	}
+	return;
+}
+
+static inline uint64_t __netsoc_get_xgmac_base(net_port_t *netport)
+{
+	uint64_t mac_base;
+	nae_t *nae = netport->nae;
 	switch (netport->hw_port_id%MAX_PORTS_PERBLOCK) {
             case 0: mac_base = netsoc_get_macreg_base_for_xgmac0(nae->mac_base, netport->hw_port_id); break;
             case 1: mac_base = netsoc_get_macreg_base_for_xgmac1(nae->mac_base, netport->hw_port_id); break;
@@ -841,6 +888,96 @@ static inline uint64_t __netsoc_get_xgmac_base(net_port_t *netport)
 	return mac_base;
 }
 
+static void __netsoc_get_xlgmac_counters(uint64_t mac_base, dev_stat_t* stats)
+{
+	stats->tx_packets = netsoc_read_mac_reg(mac_base, XLAUI_FRAME_TRANSMITTED);
+	stats->tx_bytes = netsoc_read_mac_reg(mac_base, XLAUI_TX_BYTE_CNT);
+	
+	stats->rx_packets = netsoc_read_mac_reg(mac_base, XLAUI_FRAME_RECEIVED);
+	stats->rx_bytes = netsoc_read_mac_reg(mac_base, XLAUI_RX_BYTE_CNT);
+	/*TODO : read other counters and add below.*/
+	return;
+}
+
+static void __netsoc_read_mac_counters(uint64_t mac_base, dev_stat_t* stats)
+{
+	uint64_t val;
+
+	stats->tx_packets = netsoc_read_mac_reg(mac_base, TX_PACKET_COUNTER);
+#ifdef CONFIG_64BIT
+	val = netsoc_read_mac_reg(mac_base, 0x1f);
+	stats->tx_packets |= ( val << 32);
+#endif
+	stats->rx_packets = netsoc_read_mac_reg(mac_base, RX_PACKET_COUNTER);
+#ifdef CONFIG_64BIT
+	val = netsoc_read_mac_reg(mac_base, 0x1f);
+	stats->rx_packets |= (val << 32);
+#endif
+
+	stats->tx_bytes = netsoc_read_mac_reg(mac_base,TX_BYTE_COUNTER);
+#ifdef CONFIG_64BIT
+	val = netsoc_read_mac_reg(mac_base,0x1f);
+	stats->tx_bytes |= ( val << 32);
+#endif
+
+	stats->rx_bytes = netsoc_read_mac_reg(mac_base,RX_BYTE_COUNTER);
+#ifdef CONFIG_64BIT
+	val = netsoc_read_mac_reg(mac_base, 0x1f);
+	stats->rx_bytes |= ( val << 32);
+#endif
+
+	stats->tx_errors = netsoc_read_mac_reg(mac_base, TX_FCS_ERROR_COUNTER) +
+				netsoc_read_mac_reg(mac_base, TX_JABBER_FRAME_COUNTER);
+	stats->rx_dropped = netsoc_read_mac_reg(mac_base, RX_DROP_PACKET_COUNTER);
+	stats->tx_dropped = netsoc_read_mac_reg(mac_base, TX_DROP_FRAME_COUNTER);
+
+	stats->multicast = netsoc_read_mac_reg(mac_base, RX_MULTICAST_PACKET_COUNTER);
+#ifdef CONFIG_64BIT
+	val = netsoc_read_mac_reg(mac_base, 0x1f);
+	stats->multicast |= ( val << 32);
+#endif
+
+	stats->collisions = netsoc_read_mac_reg(mac_base, TX_TOTAL_COLLISION_COUNTER);
+	stats->rx_length_errors = netsoc_read_mac_reg(mac_base, RX_FRAME_LENGTH_ERROR_COUNTER);
+	stats->rx_over_errors = netsoc_read_mac_reg(mac_base, RX_DROP_PACKET_COUNTER);
+	stats->rx_crc_errors = netsoc_read_mac_reg(mac_base, RX_FCS_ERROR_COUNTER) +
+				netsoc_read_mac_reg(mac_base, RX_JABBER_COUNTER);
+	stats->rx_frame_errors = netsoc_read_mac_reg(mac_base, RX_ALIGNMENT_ERROR_COUNTER);
+	stats->rx_fifo_errors = netsoc_read_mac_reg(mac_base, RX_DROP_PACKET_COUNTER);
+	stats->rx_missed_errors = netsoc_read_mac_reg(mac_base, RX_CARRIER_SENSE_ERROR_COUNTER);
+	stats->rx_errors = (stats->rx_over_errors + stats->rx_crc_errors +
+				stats->rx_frame_errors + stats->rx_fifo_errors +
+				stats->rx_missed_errors);
+	stats->tx_aborted_errors = netsoc_read_mac_reg(mac_base, TX_EXCESSIVE_COLLISION_PACKET_COUNTER);
+	return; 
+}
+
+static inline void __netsoc_get_mac_statistics(net_port_t *netport, dev_stat_t* dev_stat)
+{
+        uint64_t mac_base;
+        nae_t *nae = netport->nae;
+
+        if(netport->iftype==SGMII_IF){
+                mac_base = netsoc_get_macreg_base_for_gmac(nae->mac_base, netport->hw_port_id);
+                return __netsoc_read_mac_counters(mac_base, dev_stat);
+
+        }else if(netport->iftype==XAUI_IF || netport->iftype== XFI_IF || netport->iftype== RXAUI_IF){
+                mac_base = __netsoc_get_xgmac_base(netport);
+                return __netsoc_read_mac_counters(mac_base, dev_stat);
+
+        }else if(netport->iftype==INTERLAKEN_IF){
+                __netsoc_get_ilk_mac_stats(netport, dev_stat);
+
+        }else if(netport->iftype==XLAUI_IF){
+                mac_base = netsoc_get_macreg_base_for_xlgmac(nae->mac_base, netport->hw_port_id);
+                __netsoc_get_xlgmac_counters(mac_base, dev_stat);
+        }else{  
+                memset(dev_stat, 0, sizeof(dev_stat_t));
+                return;
+        }
+}
+
+
 static inline int __netsoc_get_burstmax(net_port_t *netport)
 {
 	uint64_t nae_base = netport->nae->nae_base;
@@ -896,7 +1033,7 @@ static inline int  __netsoc_config_macen(net_port_t *netport, uint32_t enable, u
                         break;
                 case XAUI_IF:
                 case RXAUI_IF:
-                        mac_base = netsoc_get_macreg_base_for_xgmac0(nae->mac_base, netport->hw_port_id);
+			mac_base = __netsoc_get_xgmac_base(netport);
                         xaui_cfg=netsoc_read_mac_reg(mac_base, XAUI_CONFIG_1);
                         if (enable) {
                              if (path == EGRESS_PATH) {
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
index bab3c94..b041afa 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -290,6 +290,7 @@ struct nlm_hal_nae_config {
         int rx_vc;
         int frin_queue_base;
         int frin_total_queue;
+	int poe_queue_base;
         int num_ports;
 	uint32_t flags;
 	int rx_cal_slots;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
index c8342a9..8889148 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
@@ -430,12 +430,10 @@ int netsoc_rx_control_perport(net_port_t *netport, uint32_t enable)
 }       
 
 
-int netsoc_get_port_stats(net_port_t *netport, uint32_t mac_stat)
+void netsoc_get_port_stats(net_port_t *netport, dev_stat_t* dev_stat)
 {
-        if (netport == NULL)
-                return -NAE_PORT_INSTANCE_INVALID;
-	return 0;
-	//return 	__netsoc_read_mac_statistics(netport, mac_stat);
+	__netsoc_get_mac_statistics(netport, dev_stat);
+	return; 
 }
 // UCORE 
 /**
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
index 84d79533..64d4b71 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
@@ -599,7 +599,7 @@ int __netsoc_parse_and_init(void *fdt, int dom_id)
 			retval = fdt_parse_netsoc_nae_config(fdt, dom_id, nae);
 			if (retval) {
 				netsoc_api_print(NETSOC_APIDBG_ERROR,"%s: parse nae fdt failed\n",__func__);
-				return -1;		
+				return -1;
 			}
 			// update context mapping based on the port configuration
 			__netsoc_update_context_mapping(nae, cntx2netport[node][id]);
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index 774cf58..1465d88 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -1348,6 +1348,21 @@ int fdt_parse_netsoc_poe_config(void *fdt,poe_t *poe)
 	return NETSOC_API_SUCCESS;
 }
 
+int fdt_get_nae(void *fdt, nae_t *nae)
+{
+        int nodeoffset, plen;
+        char path_str[50];
+        uint32_t *pval;
+	
+	printk("node %d nae_id %d\n", nae->node, nae->nae_id);        
+	sprintf(path_str, "/soc/net@node-%d/nae-%d", nae->node, nae->nae_id);
+
+        nodeoffset = fdt_path_offset(fdt, path_str);
+	printk("nodeoffset =%d\n", nodeoffset);
+        return (nodeoffset >= 0);
+}
+
+
 int fdt_get_nae_frequency(void *fdt, nae_t *nae)
 {
         int nodeoffset, plen;
@@ -1391,6 +1406,10 @@ int fdt_get_nae_ale_config(void *fdt, nae_t *nae)
  
 int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae)
 {
+        if (is_nlm_xlp9xx()) {
+		if(!fdt_get_nae(fdt, nae))	
+             		return 1;
+	}
 
         if (is_nlm_xlp9xx()) {
              fdt_get_nae_frequency(fdt, nae);
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 1fabc0e..a8f3f90 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -1134,8 +1134,8 @@ void __netsoc_config_context_xoff_thr(nae_t *nae, int thgrp, int maxbuf)
 	int xoff = ((maxbuf * 16) - 504 - 1500)  / 16;
 	int xon = xoff - 94 ;
 	int val = (xoff << 3) | (xon << 17) | thgrp;
+
 	static int done[NLM_MAX_NODES][XLP9XX_MAX_NAE_PERNODE][NLM_NAE_MAX_XONOFF_THR_GRPS];
-printk("__netsoc_config_context_xoff_thr  thgrp = 0x%x maxbuf=0x%x\n ", thgrp, maxbuf );
 	if(thgrp >= NLM_NAE_MAX_XONOFF_THR_GRPS)
 		return;
 	if(done[nae->node][nae->nae_id][thgrp])
@@ -1264,6 +1264,11 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 			thrgrp = 2;
 			rx_buf_size = nae->ports[port].rx_buf_size;
 			break;
+		   case XLAUI_IF:
+			fifo_xoff_thresh = 12;
+			thrgrp = 1;
+			rx_buf_size = nae->ports[port].rx_buf_size;
+			break;
 		   case XAUI_IF:
 			fifo_xoff_thresh = 12;
 			thrgrp = 1;
@@ -1415,8 +1420,6 @@ void __netsoc_set_frequency(nae_t *nae, uint32_t frequency)
 
 }
 
-
-
 int __netsoc_drain_allfrin_fifo_descs(nae_t *nae)
 {
         uint32_t value, fifo_mask;
@@ -1591,7 +1594,6 @@ int __netsoc_c45_mdio_indirect_read_external (nae_t *nae, int bus,
 {
 	int rdval = __netsoc_xgmac_mdio_read(nae, bus, phyaddr, dev_addr, reg_addr);
 	//netsoc_api_print(NETSOC_APIDBG_PORT, "C45 MDIO r phy:%d dev:%d reg[%04X]=[%04X]\n", phyaddr, dev_addr, reg_addr, rdval);
-	printk( "NAE is = %d C45 MDIO r phy:%d dev:%d reg[%04X]=[%04X]\n", nae->nae_id, phyaddr, dev_addr, reg_addr, rdval);
 	return rdval;
 }
 
@@ -1784,9 +1786,6 @@ int __netsoc_mdio_reset(nae_t *nae, int type, int bus)
 	}
 }
 
-
-
-
 void __netsoc_mdio_init(nae_t *nae)
 {
         __netsoc_mdio_reset(nae, NLM_HAL_INT_MDIO, 0);
@@ -1797,6 +1796,64 @@ void __netsoc_mdio_init(nae_t *nae)
 	nlm_mdelay(3);
 }
 
+void __netsoc_set_xlgmac_enable(net_port_t *netport) 
+{
+	uint32_t i;
+	volatile uint32_t val;
+	nae_t *nae = netport->nae;
+        uint64_t mac_base = netsoc_get_macreg_base_for_xlgmac(nae->mac_base, netport->hw_port_id);
+	/*TODO: remove after all fields are verified*/
+	uint32_t pad_mode=1, crc_enable=1;
+	
+	val = netsoc_read_mac_reg(mac_base, XLGMAC1_CTL);
+	val &= ~(1<<1 | 1<<0);	
+	val |= pad_mode | crc_enable;
+        netsoc_write_mac_reg(mac_base, XLGMAC1_CTL, val);
+	/* flow control*/
+        netsoc_write_mac_reg(mac_base, XLGMACPCS_CTRL, 0x5);
+	
+	val = netsoc_read_mac_reg(mac_base, XLAUI_TX_FIFO_SECTIONS);
+	val &= 0xffff0000;
+	val |= 0x9;
+	val = 9; // Workaround for XLGMAC read bug
+        netsoc_write_mac_reg(mac_base, XLAUI_TX_FIFO_SECTIONS, val);
+	
+	val = netsoc_read_mac_reg(mac_base, XLAUI_RX_FIFO_SECTIONS);
+	val &= 0xffff0000;
+	val |= 0x4;
+	val = 0x4; // Workaround for XLGMAC read bug
+        netsoc_write_mac_reg(mac_base, XLAUI_RX_FIFO_SECTIONS, val);
+	
+	val = 0x220d3; // PFC disable
+        netsoc_write_mac_reg(mac_base, XLAUI_COMMNAD_CONFIG, val);
+	
+	
+	val  = netsoc_read_mac_reg(mac_base, XLAUI_FRM_LENGTH);
+	val &= 0xffffc000;
+	val |= 0x3fe0; // 0xff for max_frame
+	netsoc_write_mac_reg(mac_base, XLAUI_FRM_LENGTH, val);
+}
+
+static void __netsoc_xlgmac_softreset(uint64_t mac_base,  uint32_t rst_val)
+{
+	uint32_t val;
+	val =  netsoc_read_mac_reg(mac_base, XLGMAC1_CTL);
+	val &= ~(0x3 << 11);
+	val |= ((rst_val & 0x3) << 11);
+        netsoc_write_mac_reg(mac_base, XLGMAC1_CTL, val);
+}
+
+static void __netsoc_xlgmac_threshold(uint64_t mac_base,  uint32_t thres_val)
+{
+
+	uint32_t val;
+	val =  netsoc_read_mac_reg(mac_base, XLGMAC3_CTL);
+	val &= (~(XLGMAC3_CTL_SOFTH_MASK << XLGMAC3_CTL_SOFTH_SHIFT));
+	val |= ((thres_val & XLGMAC3_CTL_SOFTH_MASK) << XLGMAC3_CTL_SOFTH_SHIFT);
+        netsoc_write_mac_reg(mac_base, XLGMAC3_CTL, val);
+    	netsoc_api_print(NETSOC_APIDBG_PORT,"XLAUI Rd XLGMAC3_CTL : 0x%x\n",  netsoc_read_mac_reg(mac_base, XLGMAC3_CTL)); 
+
+}
 
 static void __netsoc_xfi_softreset(uint64_t mac_base,  uint32_t rst_val)
 {
@@ -1900,7 +1957,6 @@ static void __netsoc_config_xaui(net_port_t *netport)
                         (netport->rxaui_mode == NLP1042_PHY_10G_RXAUI_MODE2)) ? 1 : 0;
 	
 	uint64_t mac_base = __netsoc_get_xgmac_base(netport);
-	printk("MAC BASE for RXAUI = 0x%llx\n", mac_base);
 	
 	higig_type = nae->higig_mode[netport->hw_port_id >> 2];
         if(higig_type){
@@ -2000,7 +2056,29 @@ static void __netsoc_config_xaui(net_port_t *netport)
 }
 
 /*
-* @brief __netsoc_config_xfi initializes a XAUI port at the MAC level.
+* @brief __netsoc_config_xlgmac initializes a XLGMAC port at the MAC level.
+*
+*
+* @return
+*       - none
+* 
+* @ingroup hal_nae
+*
+*/
+
+static void __netsoc_config_xlgmac(net_port_t *netport)
+{
+	nae_t *nae = netport->nae;
+        uint64_t mac_base = netsoc_get_macreg_base_for_xlgmac(nae->mac_base, netport->hw_port_id);
+	
+	__netsoc_xlgmac_softreset(mac_base, 0x3);
+	__netsoc_xlgmac_softreset(mac_base, 0x0);
+	__netsoc_xlgmac_threshold(mac_base, 0x1f);
+	__netsoc_set_xlgmac_enable(netport);
+	return;
+}
+/*
+* @brief __netsoc_config_xfi initializes a XGMAC port at the MAC level.
 *
 *
 * @return
@@ -2210,7 +2288,8 @@ static int __netsoc_init_netior(nae_t *nae)
 			ifcredit |= (sgmii_ifcredit << (block * 8));
 			complex_mask |= (0xF << (block * 4));		//FIXME 
 		}
-		else if ((nae->xaui_complex_map & (1 << block)) || (nae->rxaui_complex_map & (1 << block)) || (nae->xfi_complex_map & (1 << block))) {
+		else if ((nae->xaui_complex_map & (1 << block)) || (nae->rxaui_complex_map & (1 << block)) 
+					|| (nae->xfi_complex_map & (1 << block)) || (nae->xlgmac_complex_map & (1 << block))) {
 			ifcredit |= (xaui_ifcredit << (block * 8));
 			complex_mask |= (0xf << (block * 4));
 		}
@@ -2385,16 +2464,7 @@ int __netsoc_config_port(net_port_t *netport)
 	switch(netport->iftype) {
 		case XAUI_IF:
 		case RXAUI_IF:
-			// block is a complex number
-			//mac_base = netsoc_get_macreg_base_for_xgmac0(nae->mac_base, netport->hw_port_id);
 			mac_base = __netsoc_get_xgmac_base(netport);
-#if 0
-			if(netport->iftype==RXAUI_IF){
-				if((netport->hw_port_id%4)==2) {/*true if xlp9xx 2nd  port*/
-					mac_base = netsoc_get_macreg_base_for_xgmac2(nae->mac_base, netport->hw_port_id);
-				}
-			}
-#endif
 
 			netwk_inf = netsoc_read_mac_reg(mac_base, NETIOR_XGMAC_CTRL1);
 			netwk_inf |= (1 << NETIOR_XGMAC_STATS_CLR_POS);
@@ -2403,7 +2473,11 @@ int __netsoc_config_port(net_port_t *netport)
 			//ifmask = 0xf << netport->hw_port_id;
 			ifmask = 0x1 << netport->hw_port_id;
 			tx_ior_credit = netsoc_read_nae_reg(nae_base, TX_IORCRDT_INIT);
-			netsoc_write_nae_reg(nae_base, TX_IORCRDT_INIT, tx_ior_credit | ifmask);
+			if(is_nlm_xlp9xx()){
+				netsoc_write_nae_reg(nae_base, TX_IORCRDT_INIT,  tx_ior_credit & (~ (1<<netport->hw_port_id)));
+			}else{
+				netsoc_write_nae_reg(nae_base, TX_IORCRDT_INIT, tx_ior_credit | ifmask);
+			}	
 
 		        tx_config = netsoc_read_nae_reg(nae_base, TX_CONFIG);
 			// need to toggle these bits for credits to be loaded
@@ -2424,6 +2498,23 @@ int __netsoc_config_port(net_port_t *netport)
 			// need to toggle these bits for credits to be loaded
 			netsoc_write_nae_reg(nae_base, TX_CONFIG, tx_config | ( TXINITIORCR(1<<netport->hw_port_id)));
 			netsoc_write_nae_reg(nae_base, TX_CONFIG, tx_config & (~( TXINITIORCR(1<<netport->hw_port_id))));
+			break;
+		case XLAUI_IF:
+			/*Clear all statistics */
+			mac_base = __netsoc_get_xgmac_base(netport);
+			netwk_inf = netsoc_read_mac_reg(mac_base, NETIOR_XGMAC_CTRL1);
+			netwk_inf |= (1 << NETIOR_XGMAC_STATS_CLR_POS);
+			netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL1, netwk_inf);
+
+			/*TODO: verify tx_ior_credit */	
+			ifmask = 0xf << netport->hw_port_id;
+                        tx_ior_credit = netsoc_read_nae_reg(nae_base, TX_IORCRDT_INIT);
+			netsoc_write_nae_reg(nae_base, TX_IORCRDT_INIT, tx_ior_credit | ifmask );
+			tx_config = netsoc_read_nae_reg(nae_base, TX_CONFIG);
+			// need to toggle these bits for credits to be loaded
+			netsoc_write_nae_reg(nae_base, TX_CONFIG, tx_config | ( TXINITIORCR(ifmask)));
+			netsoc_write_nae_reg(nae_base, TX_CONFIG, tx_config & (~( TXINITIORCR(ifmask))));
+			break;
 
 		case INTERLAKEN_IF:
 			// block is a complex number
@@ -3386,19 +3477,18 @@ int __netsoc_pcs_init(nae_t *nae)
         }
         
 	if (nae->xfi_complex_map) {
-                netsoc_api_print(NETSOC_APIDBG_GLOBAL, "node %d XFI PCS init 0x%x \n", node, nae->xaui_complex_map);
+                netsoc_api_print(NETSOC_APIDBG_GLOBAL, "node %d XFI PCS init 0x%x \n", node, nae->xfi_complex_map);
 		__netsoc_xfi_pcs_init(nae, nae->xfi_complex_map, PHYMODE_XFI);
         }
+	if (nae->xlgmac_complex_map) {
+                netsoc_api_print(NETSOC_APIDBG_GLOBAL, "node %d XLAUI PCS init 0x%x \n", node, nae->xlgmac_complex_map);
+		__netsoc_xlaui_pcs_init(nae, nae->xlgmac_complex_map, PHYMODE_XLAUI);
+        }
 
         if (nae->rxaui_complex_map) {
                 netsoc_api_print(NETSOC_APIDBG_GLOBAL, "node %d RXAUI PCS init 0x%x\n", node, nae->rxaui_complex_map);
                 __netsoc_xaui_pcs_init(nae, nae->rxaui_complex_map, PHYMODE_RXAUI);
                 __netsoc_nlp1042c2_init(nae);
-//#ifdef NLP1042_INCL
-                //for(port = 0; port < num_ports; port++) {
-                                //nlm_hal_rxaui_nlp1042c2_init(port, nae->ports[port].rxaui_mode);
-                //}
-//#endif
         }
 
         if (nae->ilk_complex_map) {
@@ -3560,6 +3650,10 @@ static int __netsoc_init_net_port(net_port_t *netport, uint32_t context)
                 //netsoc_api_print(NETSOC_APIDBG_PORT, "Cfg XFI mode:%d \n", netport->xfi_mode);
                 __netsoc_config_xfi(netport);
         }
+	else if (netport->iftype == XLAUI_IF) {
+                //netsoc_api_print(NETSOC_APIDBG_PORT, "Cfg XFI mode:%d \n", netport->xfi_mode);
+                __netsoc_config_xlgmac(netport);
+	}
 	else if (netport->iftype == RXAUI_IF) {
                 netsoc_api_print(NETSOC_APIDBG_PORT, "Cfg RXAUI mode:%d scrambler:%d\n",
                         netport->rxaui_mode, netport->rxaui_scrambler);
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
index 00d2c32..6540fb1 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
@@ -1220,18 +1220,19 @@ static void xlp9xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
         }
 }
 
-static void xlp9xx_xfi_pcs_init(nae_t *nae, uint32_t xfi_cplx_mask, uint32_t phymode)
+static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t phymode)
 {
 	uint32_t block, lane_status, lane_ctrl, count, timeout = 10000;
 	static int vsemi_por=0;
 	uint64_t mac_base;
-	
-	config_lanes_for_xfi(nae, xfi_cplx_mask);
+
+	if(!(phymode==PHYMODE_XLAUI))	
+		config_lanes_for_xfi(nae, cplx_mask);
 
 	for( block = 0; block < 4; block++)
         {
 
-                if ((xfi_cplx_mask & (1 << block)) == 0) {
+                if ((cplx_mask & (1 << block)) == 0) {
                         continue;
                 }
 		nlm_hal_config_vsemi_mem_10G_lane_4page();
@@ -1254,7 +1255,7 @@ static void xlp9xx_xfi_pcs_init(nae_t *nae, uint32_t xfi_cplx_mask, uint32_t phy
         /* Wait for Rx & TX clock stable */
         for( block = 0; block < 4; block++)
         {
-                if ((xfi_cplx_mask & (1 << block)) == 0) {
+                if ((cplx_mask & (1 << block)) == 0) {
                         continue;
                 }
 		mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
@@ -1420,7 +1421,14 @@ void __netsoc_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phymod
 void __netsoc_xfi_pcs_init(nae_t *nae, uint32_t xfi_cplx_mask, uint32_t phymode)
 {
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
-	xlp9xx_xfi_pcs_init(nae, xfi_cplx_mask, phymode);
+	xlp9xx_10G_lane_pcs_init(nae, xfi_cplx_mask, phymode);
+#endif
+}
+
+void __netsoc_xlaui_pcs_init(nae_t *nae, uint32_t xlaui_cplx_mask, uint32_t phymode)
+{
+#if !defined(XLP_SIM) || defined(NLM_BOARD)
+	xlp9xx_10G_lane_pcs_init(nae, xlaui_cplx_mask, phymode); /*10G per lane config same as xfi*/
 #endif
 }
 
-- 
1.9.1

