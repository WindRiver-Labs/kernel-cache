From e1a6de544e66e486081ed6d978cf85ae57edd656 Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikas.gupta@broadcom.com>
Date: Wed, 17 Jul 2013 04:45:29 -0700
Subject: [PATCH 0750/1532] xlp9xx: XLAUI support modified.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../netlogic/lib/netlib/include/netsoc_common.h    |  2 +-
 arch/mips/netlogic/lib/netlib/include/netsoc_dev.h |  7 +-
 arch/mips/netlogic/lib/netlib/include/netsoc_nae.h | 31 ++++++--
 arch/mips/netlogic/lib/netlib/include/nlm_nae.h    |  3 +-
 arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c     | 27 ++++++-
 arch/mips/netlogic/lib/netlib/src/netsoc_nae.c     | 20 +++--
 arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c     | 93 +++++++++++++++-------
 7 files changed, 129 insertions(+), 54 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
index 75b9dc1..a4637bd 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
@@ -358,7 +358,7 @@ static inline uint32_t get_max_lanes(uint32_t intf_type)
 		if(is_nlm_xlp9xx()) 
 			return 2;
 		return 4;
-	}else if(XAUI_IF==intf_type){
+	}else if(XAUI_IF==intf_type || XLAUI_IF==intf_type){
 		return 4;
 	}
 	else if(INTERLAKEN_IF==intf_type){
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
index 0fa47fc..daebded 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
@@ -535,6 +535,7 @@ enum {
 	LM_SGMII = 1,
 	LM_XAUI = 2,
 	LM_IL = 3,
+	LM_XLAUI = 4,
 };	
 
 #define MAX_GMAC_PORT			18
@@ -556,9 +557,9 @@ enum {
 	#define VSEMI_CTL_XAUI_DR	(0x2)
 	#define VSEMI_CTL_SGMII_DR	(0x1)
 
-       #define VSEMI_CTL_XFI_DR        (3)
-       #define VSEMI_CTL_XLAUI_DR      (3)
-       #define VSEMI_CTL_XLAUI_ILK     (3)
+       #define VSEMI_CTL_XFI_DR        (0x3)
+       #define VSEMI_CTL_XLAUI_DR      (0x3)
+       #define VSEMI_CTL_XLAUI_ILK     (0x3)
 
 
 	#define VSEMI_CTL_MASK_DW	(0x70)
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
index ecfc1e1..c3566c9 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
@@ -260,6 +260,23 @@ static inline uint32_t __netsoc_indirect_pma_register_read(nae_t *nae, int block
         return (val&0xff);
 }
 
+#ifdef VSEMI_DEBUG
+static void __netsoc_display_vsemi_indirect_reg(uint64_t base, int block)
+{
+    uint32_t rd_data, reg_addr, lane_no;
+    for (reg_addr=101; reg_addr <111; reg_addr++) {
+        for (lane_no=0; lane_no < 4; lane_no++) {
+            rd_data = __netsoc_read_vsemi_reg(base,  lane_no, reg_addr);
+            nlm_print("VSEMI::  lane:%0d addr: 0x%x rd_data: 0x%02x\n",lane_no, reg_addr, rd_data);
+        }
+    }
+    for (reg_addr=101; reg_addr <165; reg_addr++) {
+        rd_data = __netsoc_read_vsemi_reg(base, 4, reg_addr);
+        nlm_print("VSEMI:: common lane addr: 0x%x rd_data: 0x%02x\n", reg_addr, rd_data);
+    }
+
+}
+#endif
 
 static inline void __netsoc_indirect_pma_register_wite(nae_t *nae, int block, int lane_ctrl, int pma_reg_addr, int reg_val)
 {
@@ -888,14 +905,14 @@ static inline uint64_t __netsoc_get_xgmac_base(net_port_t *netport)
 	return mac_base;
 }
 
-static void __netsoc_get_xlgmac_counters(uint64_t mac_base, dev_stat_t* stats)
+static void __netsoc_get_xlgmac_counters(net_port_t *netport, dev_stat_t* stats)
 {
-	stats->tx_packets = netsoc_read_mac_reg(mac_base, XLAUI_FRAME_TRANSMITTED);
-	stats->tx_bytes = netsoc_read_mac_reg(mac_base, XLAUI_TX_BYTE_CNT);
+	stats->tx_packets = __netsoc_read_xlgmac_reg(netport, XLAUI_FRAME_TRANSMITTED);
+	stats->tx_bytes = __netsoc_read_xlgmac_reg(netport, XLAUI_TX_BYTE_CNT);
 	
-	stats->rx_packets = netsoc_read_mac_reg(mac_base, XLAUI_FRAME_RECEIVED);
-	stats->rx_bytes = netsoc_read_mac_reg(mac_base, XLAUI_RX_BYTE_CNT);
-	/*TODO : read other counters and add below.*/
+	stats->rx_packets = __netsoc_read_xlgmac_reg(netport, XLAUI_FRAME_RECEIVED);
+	stats->rx_bytes = __netsoc_read_xlgmac_reg(netport, XLAUI_RX_BYTE_CNT);
+	/*TODO : read other counters and add them below.*/
 	return;
 }
 
@@ -970,7 +987,7 @@ static inline void __netsoc_get_mac_statistics(net_port_t *netport, dev_stat_t*
 
         }else if(netport->iftype==XLAUI_IF){
                 mac_base = netsoc_get_macreg_base_for_xlgmac(nae->mac_base, netport->hw_port_id);
-                __netsoc_get_xlgmac_counters(mac_base, dev_stat);
+                __netsoc_get_xlgmac_counters(netport, dev_stat);
         }else{  
                 memset(dev_stat, 0, sizeof(dev_stat_t));
                 return;
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
index b041afa..574547a 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -368,9 +368,8 @@ enum if_type {
         SGMII_IF      = 1,
         XAUI_IF       = 2,
         INTERLAKEN_IF = 3,
-        /* Net version 1 */
-	XFI_IF	=	5,
         XLAUI_IF      = 4 ,
+	XFI_IF	=	5,
         RXAUI_IF      = 6,
 };
 
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index 1502ce0..8a278d4 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -179,6 +179,9 @@ static int fdt_get_interface_type(void *fdt, char *nae_port_str, int block, int
                 else if (!strcmp(port_type_str, "xfi")) {
                         intf_type = DC_XFI;
                 }
+                else if (!strcmp(port_type_str, "xlaui")) {
+                        intf_type = DC_XLAUI;
+                }
                 else if (!strcmp(port_type_str, "rxaui")) {
                         intf_type = DC_RXAUI;
                 }
@@ -233,11 +236,15 @@ static int fdt_get_interface_type(void *fdt, char *nae_port_str, int block, int
                         }
                         break;
                 case DC_XAUI:
-                        netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Complex %d in xaui mode\n", block);
+                        netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Complex %d in XAUI mode\n", block);
                         nae_cfg->ports[port].iftype = XAUI_IF;
                         break;
+                case DC_XLAUI:
+                        netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Complex %d in XLAUI mode\n", block);
+                        nae_cfg->ports[port].iftype = XLAUI_IF;
+                        break;
                 case DC_RXAUI:
-                        netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Complex %d in rxaui mode\n", block);
+                        netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Complex %d in RXAUI mode\n", block);
                         for(offset = 0; offset < get_num_ports(block, RXAUI_IF); offset++) {
                                 nae_cfg->ports[port+offset].iftype = RXAUI_IF;
                         }
@@ -1066,7 +1073,7 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
 		}
 		else if (intf_type == XFI_IF) {
 			if (!socnet_version_v0) {
-				sprintf(nae_port_str, "/soc/net@node-%d/nae-%d/complex@%d/xfi", node, nae_cfg->nae_id, block);
+				sprintf(nae_port_str, "/soc/net@node-%d/nae-%d/complex@%d/xgmac", node, nae_cfg->nae_id, block);
 			}
 
 			fdt_cmplx_offset = fdt_path_offset(fdt, nae_port_str);
@@ -1076,6 +1083,19 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
 			}
 			nae_cfg->xfi_complex_map |= (1 << block);
 		}
+		else if (intf_type == XLAUI_IF) {
+			if (!socnet_version_v0) {
+				sprintf(nae_port_str, "/soc/net@node-%d/nae-%d/complex@%d/xgmac", node, nae_cfg->nae_id, block);
+			}
+
+			fdt_cmplx_offset = fdt_path_offset(fdt, nae_port_str);
+			if (fdt_cmplx_offset < 0) {
+				netsoc_api_print(NETSOC_APIDBG_FDT,"Complex %d XLAUI configuration missing in FDT \n", block);
+				continue;
+			}
+			nae_cfg->xlgmac_complex_map |= (1 << block);
+		}
+
 		else if (intf_type == RXAUI_IF) {
 			if (socnet_version_v0) {
 				sprintf(nae_port_str, "/soc/nae@node-%d/complex@%d/rxaui", node, block);
@@ -1136,6 +1156,7 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
                 netsoc_api_print(NETSOC_APIDBG_FDT," nae_cfg->msec_port_enable = %x block = %d cmplx_cfg.msec_port_enable = %x\n",
                 nae_cfg->msec_port_enable, block, cmplx_cfg.msec_port_enable);
 #endif
+
                 for(offset = 0; offset < num_ports; offset++, port++) {
                         nae_port = &nae_cfg->ports[port];
                         nae_port->hw_port_id = get_intf_hw_port_id(block, intf_type, offset);
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 7cab413..b29e419 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -476,7 +476,7 @@ int __netsoc_write_ucore_shared_mem(nae_t *nae, unsigned int *data, uint32_t wor
 	end =  ucore_shared_scratch_words[node][nae_id] + words;
 	if(end > 128)
 		return -1;
-	
+
 	for (i=ucore_shared_scratch_words[node][nae_id]; i<end; ++i) {
 		ucore_shared_scratch[node][nae_id][i] = data[i];
 	}
@@ -1423,7 +1423,6 @@ void __netsoc_set_frequency(nae_t *nae, uint32_t frequency)
 					(unsigned long long)set_freq_d, (unsigned long long)set_freq);
 	}
 	return;
-
 }
 
 int __netsoc_drain_allfrin_fifo_descs(nae_t *nae)
@@ -1804,7 +1803,6 @@ void __netsoc_mdio_init(nae_t *nae)
 
 void __netsoc_set_xlgmac_enable(net_port_t *netport) 
 {
-	uint32_t i;
 	volatile uint32_t val;
 	nae_t *nae = netport->nae;
         uint64_t mac_base = netsoc_get_macreg_base_for_xlgmac(nae->mac_base, netport->hw_port_id);
@@ -1818,26 +1816,27 @@ void __netsoc_set_xlgmac_enable(net_port_t *netport)
 	/* flow control*/
         netsoc_write_mac_reg(mac_base, XLGMACPCS_CTRL, 0x5);
 	
-	val = netsoc_read_mac_reg(mac_base, XLAUI_TX_FIFO_SECTIONS);
+	val = __netsoc_read_xlgmac_reg(netport, XLAUI_TX_FIFO_SECTIONS);
 	val &= 0xffff0000;
 	val |= 0x9;
 	val = 9; // Workaround for XLGMAC read bug
-        netsoc_write_mac_reg(mac_base, XLAUI_TX_FIFO_SECTIONS, val);
+        __netsoc_write_xlgmac_reg(netport, XLAUI_TX_FIFO_SECTIONS, val);
 	
-	val = netsoc_read_mac_reg(mac_base, XLAUI_RX_FIFO_SECTIONS);
+	val = __netsoc_read_xlgmac_reg(netport, XLAUI_RX_FIFO_SECTIONS);
 	val &= 0xffff0000;
 	val |= 0x4;
 	val = 0x4; // Workaround for XLGMAC read bug
-        netsoc_write_mac_reg(mac_base, XLAUI_RX_FIFO_SECTIONS, val);
+        __netsoc_write_xlgmac_reg(netport, XLAUI_RX_FIFO_SECTIONS, val);
 	
 	val = 0x220d3; // PFC disable
-        netsoc_write_mac_reg(mac_base, XLAUI_COMMNAD_CONFIG, val);
+        __netsoc_write_xlgmac_reg(netport, XLAUI_COMMNAD_CONFIG, val);
 	
 	
-	val  = netsoc_read_mac_reg(mac_base, XLAUI_FRM_LENGTH);
+	val  = __netsoc_read_xlgmac_reg(netport, XLAUI_FRM_LENGTH);
 	val &= 0xffffc000;
 	val |= 0x3fe0; // 0xff for max_frame
-	netsoc_write_mac_reg(mac_base, XLAUI_FRM_LENGTH, val);
+	__netsoc_write_xlgmac_reg(netport, XLAUI_FRM_LENGTH, val);
+
 }
 
 static void __netsoc_xlgmac_softreset(uint64_t mac_base,  uint32_t rst_val)
@@ -3861,7 +3860,6 @@ int __netsoc_init_nae(nae_t *nae)
                 else 
                       __netsoc_config_ale_disable(nae);
 
-		//printk("\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%s %x nae->msec_port_enable = %d\n",__FUNCTION__, __LINE__, nae->msec_port_enable);
  
  		if((is_nlm_xlp9xx() | is_nlm_xlp2xx()) && nae->msec_port_enable)
  		{
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
index 2289af2..4f0c4ca 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
@@ -353,12 +353,12 @@ static void xlp9xx_lane_reset(nae_t *nae, int block, int lane_ctrl, int mode)
 	if(mode==PHYMODE_SGMII || mode==PHYMODE_HS_SGMII){
         	val = (1<<20) | (1<<29) | (1<<31);
 	}else{
-        	val = (1<<20) | (1<<29);
+        	val = (1<<20) | (1<<29) | (1<<31);
 	}
 	if(mode==PHYMODE_XFI){
 		mode = PHYMODE_XAUI;
 	}	
-	val = (mode << PHY_LANE_CTRL_PHYMODE_POS);
+	val |= (mode << PHY_LANE_CTRL_PHYMODE_POS);
 	if(lane_ctrl != 0){ //TODO: Verify for XLP9XX
         	netsoc_write_mac_reg(mac_base, lane_ctrl, val);
         	val = netsoc_read_mac_reg(mac_base, lane_ctrl);
@@ -598,9 +598,6 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 	if((phy_mode == PHYMODE_XFI) || (phy_mode == PHYMODE_XLAUI))
 		lane_speed = XFI_TYPE_LANE;	
 	
-	if(phy_mode == PHYMODE_RXAUI){
-		lwidth =1; /*TODO: Verify for XLP9XX*/
-	}
 	if(block==2 && (phy_mode == PHYMODE_SGMII)){
 		max_lanes =1;
 	}	
@@ -619,17 +616,15 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
                         }else  if((xgmii_speed==10 ) && (lane_speed ==XAUI_TYPE_LANE)){
                                 vsemi_cmd |= vsemi_mem_xaui_4page[reg_addr];
 			}
-                        if((xgmii_speed==10 ) && (lane_speed ==XFI_TYPE_LANE)){
+                        else if((xgmii_speed==10 ) && (lane_speed ==XFI_TYPE_LANE)){
 				 vsemi_cmd |= vsemi_mem_10G_lane_4page[reg_addr];	
 			}
                         if(phy_mode==PHYMODE_SGMII){
-				//printf("xlp9xx_nae_write_pma2p0_mem vsemi_mem_sgmii_4page[%d]= 0x%x\n", reg_addr ,vsemi_mem_sgmii_4page[reg_addr]);
                                 vsemi_cmd |= vsemi_mem_sgmii_4page[reg_addr];
                         }
                         __netsoc_write_vsemi_reg(mac_base, lane_no, reg_addr, vsemi_cmd);
                 }
         }
-	//printf("SGMII 4 page programming done\n");
         /*configure only page 4*/
         for (reg_addr=101; reg_addr <165; reg_addr++){
                 vsemi_cmd=0;
@@ -640,7 +635,6 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
                         vsemi_cmd |= vsemi_mem_12G[reg_addr];
                 }
 		if((xgmii_speed==10 ) && (lane_speed ==XAUI_TYPE_LANE) && (phy_mode == PHYMODE_RXAUI)){
-                        //vsemi_cmd |= vsemi_mem_xaui[reg_addr];
                         vsemi_cmd |= vsemi_mem_rxaui[reg_addr];
 		}else if((xgmii_speed==10 ) && (lane_speed ==XAUI_TYPE_LANE)){
                         vsemi_cmd |= vsemi_mem_xaui[reg_addr];
@@ -670,7 +664,6 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 		 __netsoc_write_vsemi_reg(mac_base, 4, 0x37, vsemi_cmd);
 	}
 	
-
         for (lane_no=0; lane_no<max_lanes; lane_no++) {
                 __netsoc_write_vsemi_reg(mac_base, lane_no, 21, 0xd9);
                 __netsoc_write_vsemi_reg(mac_base, lane_no, 22, 0x0);
@@ -688,6 +681,16 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
                 vsemi_cmd &= ~(1<<3);
                 __netsoc_write_vsemi_reg(mac_base, lane_no, 86, vsemi_cmd);
         }
+	// For 40G - Got it from Amar after lab experiment - 6/25/2013
+	if((phy_mode == PHYMODE_XLAUI) || (phy_mode == PHYMODE_XFI)){ 
+		for (lane_no=0; lane_no<max_lanes; lane_no++) {
+			__netsoc_write_vsemi_reg(mac_base, lane_no, 0x15, 0xd9);
+			__netsoc_write_vsemi_reg(mac_base, lane_no, 0x16, 0x07);
+			__netsoc_write_vsemi_reg(mac_base, lane_no, 0x1c, 0xc0);
+			__netsoc_write_vsemi_reg(mac_base, lane_no, 0x1b, 0x70);
+             }
+	}
+
 
 	for(delay=0; delay<10000; delay++);
 
@@ -756,20 +759,20 @@ static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t vse
 	                vsemi_config |= VSEMI_CTL_SGMII_DR | VSEMI_CTL_SGMII_DW;
 		else if((PHYMODE_RXAUI==phymode) || (PHYMODE_XAUI==phymode)){
 			if(speed==16)
-                                 vsemi_config = VSEMI_CTL_XAUI_16G_DR | VSEMI_CTL_XAUI_16G_DW;
+                                 vsemi_config |= VSEMI_CTL_XAUI_16G_DR | VSEMI_CTL_XAUI_16G_DW;
                         else if(speed==12)
-                                 vsemi_config = VSEMI_CTL_XAUI_12G_DR | VSEMI_CTL_XAUI_12G_DW;
+                                 vsemi_config |= VSEMI_CTL_XAUI_12G_DR | VSEMI_CTL_XAUI_12G_DW;
                         else if((PHYMODE_RXAUI==phymode) && (speed==10)) {
-                                 vsemi_config = VSEMI_CTL_RXAUI_10G_DR | VSEMI_CTL_RXAUI_10G_DW;
+                                 vsemi_config |= VSEMI_CTL_RXAUI_10G_DR | VSEMI_CTL_RXAUI_10G_DW;
                         }
                         else //XAUII/10G
                                  vsemi_config = VSEMI_CTL_XAUI_DR | VSEMI_CTL_XAUI_DW;
 		}else if(PHYMODE_XFI==phymode){
-			vsemi_config = VSEMI_CTL_XFI_DR | VSEMI_CTL_XFI_DW;	
+			vsemi_config |= VSEMI_CTL_XFI_DR | VSEMI_CTL_XFI_DW;	
 		}else if(PHYMODE_XLAUI==phymode){
-			vsemi_config = VSEMI_CTL_XLAUI_DW | VSEMI_CTL_XLAUI_DR;	
+			vsemi_config |= VSEMI_CTL_XLAUI_DW | VSEMI_CTL_XLAUI_DR;	
 		}else if (PHYMODE_IL==phymode){
-			 vsemi_config =VSEMI_CTL_XLAUI_ILK | VSEMI_CTL_ILK_DW;	
+			 vsemi_config |= VSEMI_CTL_XLAUI_ILK | VSEMI_CTL_ILK_DW;	
 		}
 		
 		for(delay=0; delay<1000000; delay++);
@@ -778,7 +781,7 @@ static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t vse
 
                 xlp9xx_nae_write_pma2p0_mem(mac_base, block, speed, phymode);
 #ifdef VSEMI_DEBUG
-                display_vsemi_indirect_reg(node, block);
+		__netsoc_display_vsemi_indirect_reg(mac_base, block);	
 #endif
 
 }
@@ -959,6 +962,42 @@ static void xlp_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask)
         netsoc_api_print(NETSOC_APIDBG_PORT,"Net: Completed PCS Configuration\n");
 }
 
+static void config_lanes_for_xlgmac(nae_t *nae, uint32_t xgmac_cplx_mask, uint32_t phymode)
+{
+	uint64_t mac_base = netsoc_get_macreg_base_for_lanecfg(nae->mac_base);
+	uint32_t lane_enable;
+	uint32_t cplx_lane_enable = LM_XLAUI | (LM_XLAUI << 4) | (LM_XLAUI << 8) | (LM_XLAUI << 12);
+
+        if (xgmac_cplx_mask & 0x3) { /* Complexes 0, 1 */
+                lane_enable = netsoc_read_mac_reg(mac_base, LANE_CFG_CPLX_0_1);
+                if (xgmac_cplx_mask & 0x1) { /* Complex 0 */
+                        lane_enable &= ~(0xFFFF);
+                        lane_enable |= cplx_lane_enable;
+                }
+                if (xgmac_cplx_mask & 0x2) {/* Complex 1 */
+                        lane_enable &= ~(0xFFFF<<16);
+                        lane_enable |= (cplx_lane_enable << 16);
+                }
+                netsoc_write_mac_reg(mac_base, LANE_CFG_CPLX_0_1,   lane_enable);
+                netsoc_api_delay(1);
+        }
+        lane_enable = 0;
+        if (xgmac_cplx_mask & 0xc) { /* Complexes 2, 3 */
+                lane_enable = netsoc_read_mac_reg(mac_base, LANE_CFG_CPLX_2_3);
+                if (xgmac_cplx_mask & 0x4) { /* Complex 2 */
+                        lane_enable &= ~(0xFFFF);
+                        lane_enable |= cplx_lane_enable;
+                }
+                if (xgmac_cplx_mask & 0x8) {/* Complex 3 */
+                        lane_enable &= ~(0xFFFF<<16);
+                        lane_enable |= (cplx_lane_enable << 16);
+                }
+                netsoc_write_mac_reg(mac_base, LANE_CFG_CPLX_2_3,   lane_enable);
+                netsoc_api_delay(1);
+        }
+
+}
+
 static void config_lanes_for_xgmac(nae_t *nae, uint32_t xgmac_cplx_mask, uint32_t phymode)
 {
 	uint64_t mac_base = netsoc_get_macreg_base_for_lanecfg(nae->mac_base);
@@ -1006,6 +1045,7 @@ static void config_lanes_for_xgmac(nae_t *nae, uint32_t xgmac_cplx_mask, uint32_
 
 }
 
+
 static void config_lanes_for_xfi(nae_t *nae, uint32_t xfi_cplx_mask)
 {
 	uint32_t val;
@@ -1226,11 +1266,13 @@ static void xlp9xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
 static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t phymode)
 {
 	uint32_t block, lane_status, lane_ctrl, count, timeout = 10000;
-	static int vsemi_por=0;
 	uint64_t mac_base;
 
-	if(!(phymode==PHYMODE_XLAUI))	
+	if((phymode==PHYMODE_XFI))	
 		config_lanes_for_xfi(nae, cplx_mask);
+	else{
+		config_lanes_for_xlgmac(nae, cplx_mask, PHYMODE_XLAUI);
+	}
 
 	for( block = 0; block < 4; block++)
         {
@@ -1241,12 +1283,9 @@ static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t ph
 		nlm_hal_config_vsemi_mem_10G_lane_4page();
 		nlm_hal_config_vsemi_mem_10G_lane();
 		//TODO: If HIGIG pass XGMII speed.
-		xlp9xx_config_pma2p0_serdes(nae, block, vsemi_por, 10, phymode);
+		xlp9xx_config_pma2p0_serdes(nae, block, nae->serdes_init_cnt, 10, phymode);
+		nae->serdes_init_cnt++;	
                 
-		if (!vsemi_por){
-                        vsemi_por++;
-                }
-
                 for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++){
 			xlp9xx_lane_reset(nae, block, lane_ctrl, phymode);
 		}
@@ -1271,7 +1310,7 @@ static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t ph
                         while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_STCS)) != PHY_LANE_STAT_STCS) {
 				count++;
 				if (count == timeout) {
-					netsoc_api_print(NETSOC_APIDBG_ERROR,"%s TX clock not stable", __func__);
+					netsoc_api_print(NETSOC_APIDBG_ERROR,"%s TX clock not stable\n", __func__);
 					break;
 				}
                         }
@@ -1282,7 +1321,7 @@ static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t ph
                         while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_SRCS)) != PHY_LANE_STAT_SRCS) {
 				count++;
                                 if (count == timeout) {   
-                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s RX clock not stable", __func__);
+                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s RX clock not stable\n", __func__);
 					break;
                                 }
                         }
@@ -1293,7 +1332,7 @@ static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t ph
                                 /* Wait for XAUI Lane fault to be cleared */
 				count++;
                                 if (count == timeout) {   
-                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s XFI lane fault not cleared", __func__);
+                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s XFI lane fault not cleared \n", __func__);
 					break;
                                 }
                         }
-- 
1.9.1

