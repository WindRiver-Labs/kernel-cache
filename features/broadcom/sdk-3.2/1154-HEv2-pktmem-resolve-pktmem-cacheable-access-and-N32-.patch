From fd45857dd91454bd50fdded8bb4b7fb1298e9d6b Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Fri, 28 Jun 2013 10:22:05 -0700
Subject: [PATCH 1154/1532] HEv2: pktmem: resolve pktmem cacheable access and
 N32 mmap >=2GB physical address issue

  o Previous implement is using /dev/mem for pktmem. However, if the packet memory
    is beyond the maximum pfn linux owns, the linux will returns it as uncached.
    Since /dev/mem is in general used for memories known to linux, special hack
    is needed to let linux know certain address is cacheable.

  o In old SDKs, to resolve N32 mmap >=2GB physical address issue, we introduced
    mmap2 syscall. In particular, N32 syscall number is baked into the toolchain
    for mmap64 library call. This makes toolchain not compatible for mmap64 library call
    as different kernel will have different mmap2 syscall number.

  o This change resolves the above two issues. First, /dev/mem will not be used
    any more for packet memory. mmap hook is implemented for pktmem driver and
    correct cacheable attribute will be assigned. Second, mmap2 syscall will be
    removed from kernel, syscall interface will be used directly for N32 mmap
    >=2GB physical address.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c | 27 +++++++++++++++++++----
 1 file changed, 23 insertions(+), 4 deletions(-)

diff --git a/drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c b/drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c
index e5efbf3..d4a41e4 100644
--- a/drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c
+++ b/drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c
@@ -4,6 +4,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/fs.h>
+#include <linux/mm.h>
 #include "libfdt.h"
 
 
@@ -20,8 +21,7 @@ typedef struct memory_pool
 	int in_use;
 } memory_pool_t;
 
-memory_pool_t mem_pool_data[MAX_NODES];
-uint32_t pktregs[MAX_NODES * 5];
+static memory_pool_t mem_pool_data[MAX_NODES];
 
 typedef struct brcm_devmem_ioctl {
 	unsigned int node_id;
@@ -208,12 +208,30 @@ static long pktmem_ioctl (struct file *fptr, unsigned int cmd, unsigned long dp)
 	return rc;
 }
 
+static int pktmem_mmap(struct file *file_p, struct vm_area_struct *vm_p)
+{
+#if 0
+	/* make sure it is cacheable */
+	if ((pgprot_val(vm_p->vm_page_prot) & _CACHE_MASK) != _CACHE_CACHABLE_NONCOHERENT) {
+		printk("BUG: packet memory as uncached ...\n");
+		return -EPERM;
+	}
+#endif
+
+	if (remap_pfn_range(vm_p, vm_p->vm_start, vm_p->vm_pgoff,
+		vm_p->vm_end - vm_p->vm_start, vm_p->vm_page_prot))
+		return -EFAULT;
+
+	return 0;
+}
+
 static const struct file_operations pktmem_ops = {
 	.owner  = THIS_MODULE,
 	.unlocked_ioctl = pktmem_ioctl,
 #ifdef CONFIG_COMPAT
 	.compat_ioctl = pktmem_ioctl,
 #endif
+	.mmap = pktmem_mmap,
 };
 
 static inline int get_fdt_prop(void *fdt, const char* node_path,
@@ -244,6 +262,7 @@ static int __init brcm_xlp_ppm_init (void)
 {
 	int i, node;
 	void *fdt;
+	uint32_t pktregs[MAX_NODES * 5];
 
 	i = register_chrdev(PKTMEM_MAJOR, "brcm_pktmem", &pktmem_ops);
 	if (i < 0)
@@ -264,8 +283,8 @@ static int __init brcm_xlp_ppm_init (void)
 			mem_pool_data[node].next = NULL;
 			memset(mem_pool_data[node].shr_id, '\0', 64);
 			mem_pool_data[node].in_use = 0;
-			mem_pool_data[node].start = ((pktregs[i+1]<<32) | (pktregs[i+2]));
-			mem_pool_data[node].size = ((pktregs[i+3]<<32) | (pktregs[i+4]));
+			mem_pool_data[node].start = ((((unsigned long long)pktregs[i+1])<<32) | (pktregs[i+2]));
+			mem_pool_data[node].size = ((((unsigned long long)pktregs[i+3])<<32) | (pktregs[i+4]));
 		}
 	}
 	else
-- 
1.9.1

