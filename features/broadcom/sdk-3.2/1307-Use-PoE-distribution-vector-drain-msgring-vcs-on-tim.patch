From dbfe7d56bdf8e1c038703697291f5d3b8ce04fa1 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Mon, 4 Oct 2010 19:58:13 -0700
Subject: [PATCH 1307/1532] Use PoE distribution vector, drain msgring vcs on
 timer cpu also

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/init_nae.c | 26 ++++++++++++++++++++++++++
 drivers/net/ethernet/broadcom/nae/xlp_nae.c  | 11 +++++------
 2 files changed, 31 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/init_nae.c b/drivers/net/ethernet/broadcom/nae/init_nae.c
index 0588880..bf6a886 100644
--- a/drivers/net/ethernet/broadcom/nae/init_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/init_nae.c
@@ -261,6 +261,28 @@ static void parse_fdt_nae_config(void)
 	}
 }
 
+static void config_poe_dist_vect(uint32_t cpumask, int rx_vc)
+{
+	int reg_index_base = 0x400 >> 2;
+	int reg_offset = 0x30 >> 2;
+	int reg = 0;
+	int i = 0;
+	uint32_t vc_mask[4] = {
+		[0] = 0x11111111,
+		[1] = 0x11111111,
+		[2] = 0x11111111,
+		[3] = 0x11111111,
+	};
+
+	for (i = 0; i < 4; i++) {
+
+		reg = reg_index_base + reg_offset + i;
+
+		nlm_hal_write_poe_pcim_reg(reg, vc_mask[i]);
+	}
+
+}
+
 void initialize_nae(void)
 {
 	if (check_header()) {
@@ -277,5 +299,9 @@ void initialize_nae(void)
 	printk("Configuring CPU-NAE...\n");
 	parse_fdt_cpu_config();
 
+	printk("Configuring POE distribution vector...\n");
+	uint32_t cpumask = 0xffffffff; // XXXXXXXXXXXXXXXXXXXX
+	config_poe_dist_vect(cpumask, nae_rx_vc);
+
 	printk("NAE configuration done!\n");
 }
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index c89991f..bdc3397 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -482,7 +482,7 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 	}
 
 	ret = mac_refill_frin_desc((unsigned long)dev);
-	if (ret) goto out;
+	if (0/*ret*/) goto out;
 
 #ifdef ENABLE_NAE_PIC_INT
 	{
@@ -984,9 +984,6 @@ static void nlm_xlp_mac_timer(unsigned long data)
         int next_tick = HZ / 1000; /* 1ms */
 
 	/* printk("[%s] A0 Workaround, forcing FMN int handling \n",__func__); */
-#if 0
-	nlm_xlp_msgring_int_handler(IRQ_MSGRING, NULL);
-#else
 	{
 		uint32_t cpumask = 0xffffffff;
 		pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
@@ -994,12 +991,14 @@ static void nlm_xlp_mac_timer(unsigned long data)
 
 		cpumask = cpumask & ~(1 << cpu);
 
-		/* Send IRQ_MSGRING vector in an IPI to all cpus */
+		/* Send IRQ_MSGRING vector in an IPI to all cpus but the current one */
 		nlm_hal_write_pic_reg(mmio, PIC_IPI_CTL, (IRQ_MSGRING << 20) | (cpumask & 0xffff) );
 		nlm_hal_write_pic_reg(mmio, PIC_IPI_CTL, (IRQ_MSGRING << 20) | (1 << 16)
 				      | ( (cpumask >> 16) & 0xffff) );
+
+		/* Run the IPI handler on this cpu too */
+		nlm_xlp_msgring_int_handler(IRQ_MSGRING, NULL);
 	}
-#endif
 
         priv->link_timer.expires = jiffies + next_tick;
         add_timer(&priv->link_timer);
-- 
1.9.1

