From 78d412546bbe9e0773693fd5935183c749f12d0b Mon Sep 17 00:00:00 2001
From: Alok Agrawat <alok@dt-sj4-232.sj.broadcom.com>
Date: Mon, 27 Aug 2012 17:32:37 -0700
Subject: [PATCH 1367/1532] macSec: Added pading in nae driver for msec

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/xlp_nae.c | 68 +++++++++++++++++++++++++++--
 1 file changed, 65 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index 3a9cbce..514bf9c 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -1591,7 +1591,22 @@ out_unlock:
 	return NETDEV_TX_OK;
 }
 
+#define MAC_HEADER_LEN		12
+#define PROTOCOL_TYPE_IP 	0x0800
+#define MAC_SEC_PADDING		(12+16+16+16) /* !2 byte DA and SA, 16 byte preamble len, 16 byte sectag hear, 16 byte ICV len*/
 
+void dump_buffer(unsigned char *buf, unsigned int len, unsigned char *msg)
+{
+    int k = 0;
+    printk("\n%s\n",msg);
+    for(k = 0; k < len; k++)
+    {
+        printk("%.2x ",buf[k]);
+        if((k+1) % 16 == 0)
+            printk("\n");
+    }
+    printk("\n");
+}
 
 /**********************************************************************
  * nlm_xlp_nae_start_xmit -  transmit a packet from buffer
@@ -1602,7 +1617,7 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct dev_data *priv = netdev_priv(dev);
 	int cpu = hard_smp_processor_id(), ret = 0;
-	uint64_t msg0, msg1;
+	uint64_t msg0, msg1, msg2, msg3;
 	int retry_count = 128;
 	volatile int hw_repl = 0;
 	int  offset, qid;
@@ -1610,9 +1625,43 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 #ifdef IEEE_1588_PTP_ENABLED	
 	union skb_shared_tx *shtx;
 #endif
+	uint32_t msec_port, send_msec = 0, pad_len, icv_len;
+	unsigned char *msec_pad_mem, *msec_icv_mem;
 
 	nlm_nae_config_ptr nae_cfg = nlm_node_cfg.nae_cfg[priv->node];
 
+printk("nae_cfg->sectag_offset = %d sectag_len = %d icv_len = %d\n",nae_cfg->sectag_offset[priv->port], nae_cfg->sectag_len[priv->port], nae_cfg->icv_len[priv->port]);
+printk("size of skb end = %llx head = %llx\n", (unsigned long)skb->end, (unsigned long)skb->head);
+	if(priv->index == XGMAC)
+		msec_port = (priv->port | 0xf) << (4 * priv->block) ;
+	else
+		msec_port = 1 << priv->port;
+
+dump_buffer(skb->data, skb->len, "Org skb pkt:");		
+printk("msec_port = %x priv->port = %d priv->block = %d priv->index = %d skb->len = %d nae_cfg->msec_port_enable = %x\n",msec_port, priv->port, priv->block, priv->index, skb->len, nae_cfg->msec_port_enable);
+	if(1/*nae_cfg->msec_port_enable & msec_port*/)/* check if port is tx port is enabled for msec else bypass MACSec*/
+	{
+		short ether_type = *(short*)(((char*)skb->data) + MAC_HEADER_LEN);
+
+printk("skb->len = %d ether_type = %x\n", skb->len, ether_type);
+		if((ether_type & 0xffff) == PROTOCOL_TYPE_IP)/*Enable MACSEc processing*/			
+		{
+			send_msec = 1;
+			msec_pad_mem = (unsigned char*)cacheline_aligned_kmalloc(MAC_SEC_PADDING, GFP_KERNEL);
+			msec_icv_mem = (unsigned char*)cacheline_aligned_kmalloc(nae_cfg->sectag_len[priv->port], GFP_KERNEL);
+
+			pad_len = 12 + 8;
+			icv_len = nae_cfg->icv_len[priv->port];
+
+			memcpy(msec_pad_mem, skb->data, MAC_HEADER_LEN);		
+			skb_reserve(skb, MAC_HEADER_LEN);
+			//skb_push(skb, nae_cfg->sectag_offset[priv->port]);
+printk("skb->len = %d ether_type = %x\n", skb->len, ether_type);
+dump_buffer(skb->data, skb->len, "mod skb pkt:");		
+		}
+//		skb->len +=  nae_cfg->icv_len[priv->port];
+		
+	}
 
 #ifdef ENABLE_SANITY_CHECKS
 	if(!skb)
@@ -1668,7 +1717,17 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	else
 #endif
 	{
-		msg1 = nae_tx_desc(P2D_EOP, 0, NULL_VFBID, skb->len,
+		/*if(send_msec)
+		{
+			msg1 = nae_tx_desc(P2D_NEOP, 0, NULL_VFBID, pad_len,
+			       virt_to_bus(msec_pad_mem));
+			msg2 = nae_tx_desc(P2D_NEOP, 0, NULL_VFBID, skb->len,
+			       virt_to_bus(skb->data));
+			msg3 = nae_tx_desc(P2D_EOP, 0, NULL_VFBID, icv_len,
+			       msec_icv_mem);
+		}
+		else*/
+			msg1 = nae_tx_desc(P2D_EOP, 0, NULL_VFBID, skb->len,
 			       virt_to_bus(skb->data));
 	}
 	if(hw_repl) {
@@ -1691,7 +1750,10 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 retry_send:
 	msgrng_access_enable(mflags);
-	ret = nlm_hal_send_msg2(priv->nae_tx_qid, 0, msg0, msg1);
+	if(send_msec)
+		ret = nlm_hal_send_msg4(priv->nae_tx_qid, 0, msg0, msg1, msg2, msg3);
+	else
+		ret = nlm_hal_send_msg2(priv->nae_tx_qid, 0, msg0, msg1);
 	msgrng_access_disable(mflags);
 	if (ret)
 	{
-- 
1.9.1

