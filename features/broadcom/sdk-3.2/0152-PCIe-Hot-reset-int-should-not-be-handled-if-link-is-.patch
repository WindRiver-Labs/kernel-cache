From 6f119482a06dace2cb0ef0f5cef00741c26c6869 Mon Sep 17 00:00:00 2001
From: ajesh <ajesh@broadcom.com>
Date: Tue, 1 Jul 2014 16:41:43 +0530
Subject: [PATCH 0152/1532] PCIe: Hot reset int should not be handled if link
 is up

Conflicts:
	arch/mips/netlogic/xlp/pci-hot-reset.c
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/include/asm/netlogic/xlp-hal/pcibus.h |   1 +
 arch/mips/netlogic/xlp/pci-hot-reset.c          | 121 +++++++++++++-----------
 2 files changed, 69 insertions(+), 53 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/xlp-hal/pcibus.h b/arch/mips/include/asm/netlogic/xlp-hal/pcibus.h
index 91540f4..27cc50e 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/pcibus.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/pcibus.h
@@ -58,6 +58,7 @@
 #define PCIE_MSI_STATUS			0x25A
 #define PCIE_MSI_EN			0x25B
 #define PCIE_MSIX_STATUS		0x25D
+#define PCIE_LTSSM_STATE        0x25E
 #define PCIE_INT_STATUS0		0x25F
 #define PCIE_INT_STATUS1		0x260
 #define PCIE_INT_EN0			0x261
diff --git a/arch/mips/netlogic/xlp/pci-hot-reset.c b/arch/mips/netlogic/xlp/pci-hot-reset.c
index a495c99..69e289c 100644
--- a/arch/mips/netlogic/xlp/pci-hot-reset.c
+++ b/arch/mips/netlogic/xlp/pci-hot-reset.c
@@ -55,67 +55,84 @@
 static void modify_def_value(void)
 {
 	uint64_t sysbase = nlm_get_sys_regbase(0);
-	uint32_t sysreg = nlm_read_sys_reg(sysbase,SYS_POWER_ON_RESET_CFG);	
+	uint32_t sysreg = nlm_read_sys_reg(sysbase, SYS_POWER_ON_RESET_CFG);
 	uint32_t pcfg = (sysreg >> 12) & 0x3;
-	uint64_t pciebase = nlm_get_pcie_base(0,0);
+	uint64_t pciebase = nlm_get_pcie_base(0, 0);
 	uint32_t pcicontrol, link;
 
-	switch(pcfg)
-	{
-		case 1:
-			link = nlm_read_pci_reg(pciebase, 0x1f);
-			nlm_write_pci_reg(pciebase, 0x1f, ((link & 0xfffffc0f) | 0x20));
-			break;
-		case 2:
-		case 3:
-		    link = nlm_read_pci_reg(pciebase, 0x1f);
-			nlm_write_pci_reg(pciebase, 0x1f, ((link & 0xfffffc0f) | 0x10));
-			break;
-		default:
-			break;
+	switch (pcfg) {
+	case 1:
+		link = nlm_read_pci_reg(pciebase, 0x1f);
+		nlm_write_pci_reg(pciebase, 0x1f, ((link & 0xfffffc0f) | 0x20));
+		break;
+	case 2:
+	case 3:
+		link = nlm_read_pci_reg(pciebase, 0x1f);
+		nlm_write_pci_reg(pciebase, 0x1f, ((link & 0xfffffc0f) | 0x10));
+		break;
+	default:
+		break;
 	}
 
 	nlm_write_pci_reg(pciebase, 0x5f, 0x00000000);
 
 	pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
-	nlm_write_pci_reg(pciebase, 0x240,(pcicontrol | (1 << 21)));
+	nlm_write_pci_reg(pciebase, 0x240, (pcicontrol | (1 << 21)));
 
-	pcicontrol = nlm_read_pci_reg(pciebase,0x65);
-	nlm_write_pci_reg(pciebase,0x65,((pcicontrol & 0xf) | 0x3ff1));
+	pcicontrol = nlm_read_pci_reg(pciebase, 0x65);
+	nlm_write_pci_reg(pciebase, 0x65, ((pcicontrol & 0xf) | 0x3ff1));
 
 	pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
 	nlm_write_pci_reg(pciebase, 0x240, (pcicontrol & ~(1 << 21)));
 }
+
 static irqreturn_t xlp_pcie_hot_reset_handler(int irq, void *dev_id)
 {
 	uint64_t pciebase;
-	uint32_t pciint, pcicontrol;
-
-	pr_err("In Int Handler\n");
-	pciebase = nlm_get_pcie_base(0,0);
+	uint32_t pciint, pcicontrol, pcistate;
+
+	pr_err("Hot Reset Int Handler\n");
+	pciebase = nlm_get_pcie_base(0, 0);
+
+	pcistate = nlm_read_pci_reg(pciebase, PCIE_LTSSM_STATE);
+
+	if ((pcistate & 0xfc6000) == 0x446000) {
+		/* read the pci ltssm state again to comfirm the L0 state */
+		pcistate = nlm_read_pci_reg(pciebase, PCIE_LTSSM_STATE);
+		if ((pcistate & 0xfc6000) == 0x446000) {
+			pciint = nlm_read_pci_reg(pciebase, PCIE_INT_STATUS1);
+
+			if (pciint & 0x1) {
+				/* clear the interrupt */
+				nlm_write_pci_reg(pciebase, PCIE_INT_STATUS1,
+						  0x1);
+			}
+			/* return without handling the interrupt as the link is already up */
+			pr_err("Link already up \n");
+			return IRQ_HANDLED;
+		}
+	}
 
 	pciint = nlm_read_pci_reg(pciebase, PCIE_INT_STATUS1);
 
-	if(pciint & 0x1)
-	{
-		if(((nlm_read_pci_reg(pciebase, 0x1e)) & (0x1 << 21)) != 0)
-		{
+	if (pciint & 0x1) {
+		if (((nlm_read_pci_reg(pciebase, 0x1e)) & (0x1 << 21)) != 0) {
 			pr_info("Transaction Pending \n");
 			pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
-			nlm_write_pci_reg(pciebase, 0x240, pcicontrol | (0x3 << 27));
+			nlm_write_pci_reg(pciebase, 0x240,
+					  (pcicontrol | (0x3 << 27)));
 		}
-		
+
 		pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
-		nlm_write_pci_reg(pciebase, 0x240, pcicontrol & ~(0x1 << 3));
+		nlm_write_pci_reg(pciebase, 0x240, (pcicontrol & ~(0x1 << 3)));
 
-		while(((nlm_read_pci_reg(pciebase, 0x1e)) & (0x1 << 21)) != 0)
-		{
+		while (((nlm_read_pci_reg(pciebase, 0x1e)) & (0x1 << 21)) != 0) {
 			//udelay(200);
 		}
 		pr_err("Transaction Cleared\n");
 
 		pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
-        nlm_write_pci_reg(pciebase, 0x240, pcicontrol & ~(0x1));
+		nlm_write_pci_reg(pciebase, 0x240, pcicontrol & ~(0x1));
 
 		pcicontrol = nlm_read_pci_reg(pciebase, 0x241);
 		nlm_write_pci_reg(pciebase, 0x241, pcicontrol | (0x1 << 17));
@@ -124,7 +141,7 @@ static irqreturn_t xlp_pcie_hot_reset_handler(int irq, void *dev_id)
 		nlm_write_pci_reg(pciebase, 0x241, pcicontrol & ~(0x1 << 17));
 
 		pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
-        nlm_write_pci_reg(pciebase, 0x240, pcicontrol | (0x9));
+		nlm_write_pci_reg(pciebase, 0x240, pcicontrol | (0x9));
 
 		pciint = nlm_read_pci_reg(pciebase, PCIE_INT_STATUS1);
 		nlm_write_pci_reg(pciebase, PCIE_INT_STATUS1, pciint | 0x1);
@@ -132,9 +149,7 @@ static irqreturn_t xlp_pcie_hot_reset_handler(int irq, void *dev_id)
 		modify_def_value();
 
 		pr_info("Hot Reset Interrupt handled \n");
-	}
-	else
-	{
+	} else {
 		pr_info("spurious Interrupt PCIe hot Reset \n");
 	}
 	return IRQ_HANDLED;
@@ -143,41 +158,41 @@ static irqreturn_t xlp_pcie_hot_reset_handler(int irq, void *dev_id)
 static int __init xlp_pci_hot_reset_init(void)
 {
 	uint64_t sysbase = nlm_get_sys_regbase(0);
-	uint32_t sysreg = nlm_read_sys_reg(sysbase,SYS_POWER_ON_RESET_CFG);	
-	uint64_t pciebase = nlm_get_pcie_base(0,0);
+	uint32_t sysreg = nlm_read_sys_reg(sysbase, SYS_POWER_ON_RESET_CFG);
+	uint64_t pciebase = nlm_get_pcie_base(0, 0);
 	uint64_t picbase, picreg;
 	uint32_t irq, pciintenable;
 
-	if((read_c0_prid() & PRID_IMP_MASK) == PRID_IMP_NETLOGIC_XLP2XX)
-	  {
-		  pr_err("Hot Reset not handled\n");
-		  return 0;
-	  }
+	if (!cpu_is_xlp2xx()) {
+		pr_err("Hot Reset not handled\n");
+		return 0;
+	}
 	pr_info("Sysreg is 0x%x \n", sysreg);
-	if(((sysreg >> 8) & 0xf) & 0x1)
-	{
+	if (((sysreg >> 8) & 0xf) & 0x1) {
 		pr_err("PCIE in RC Mode \n");
 		return 0;
 	}
 	pr_info("PCIE in EP mode 0x%x\n", sysreg);
 	pciintenable = nlm_read_pci_reg(pciebase, PCIE_INT_EN1);
 	pciintenable |= 0x1;
-	nlm_write_pci_reg(pciebase,PCIE_INT_EN1, pciintenable);
+	nlm_write_pci_reg(pciebase, PCIE_INT_EN1, pciintenable);
 
-	pr_err("PCIE in Mode \n");
 	pciintenable = nlm_read_pci_reg(pciebase, PCIE_INT_EN1);
 	picbase = nlm_get_pic_pcibase(0);
 	/* enable the link interrupt */
 	picreg = nlm_read_pic_reg(picbase, PIC_IRT(PIC_IRT_PCIE_LINK_0_INDEX));
-	nlm_write_pic_reg(picbase, PIC_IRT(PIC_IRT_PCIE_LINK_0_INDEX), picreg | (1u << 31));
+	nlm_write_pic_reg(picbase, PIC_IRT(PIC_IRT_PCIE_LINK_0_INDEX),
+			  picreg | (1u << 31));
 
 	irq = PIC_PCIE_LINK_LEGACY_IRQ_BASE;
-	if(request_irq(irq, xlp_pcie_hot_reset_handler,0,"PCIE_HOTRESET",NULL))
-		{
-			pr_info("Could not register PCIe hot Reset interrupt handler \n");
-			return 0;
-		}
+	if (request_irq
+	    (irq, xlp_pcie_hot_reset_handler, 0, "PCIE_HOTRESET", NULL)) {
+		pr_info
+		    ("Could not register PCIe hot Reset interrupt handler \n");
+		return 0;
+	}
 	//pr_err("PCIE in Mode 2\n");
 	return 0;
 }
+
 late_initcall(xlp_pci_hot_reset_init);
-- 
1.9.1

