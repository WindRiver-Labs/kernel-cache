From 143d8a7aea30f9ef00bf7d3704dc80a7d477250b Mon Sep 17 00:00:00 2001
From: kopal <kopal@broadcom.com>
Date: Wed, 17 Jul 2013 11:13:35 +0530
Subject: [PATCH 0751/1532] netlib: ethtool support for flow control.

     Added a new api to get the flow control status.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/netlib/include/export_sym.h |  1 +
 .../netlogic/lib/netlib/include/netsoc_haliface.h  |  1 +
 .../netlogic/lib/netlib/include/netsoc_libiface.h  |  1 +
 arch/mips/netlogic/lib/netlib/src/netsoc_api.c     |  7 +++
 arch/mips/netlogic/lib/netlib/src/netsoc_nae.c     | 72 +++++++++++++++++++---
 5 files changed, 72 insertions(+), 10 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/include/export_sym.h b/arch/mips/netlogic/lib/netlib/include/export_sym.h
index 6fccefb..ce00a55 100644
--- a/arch/mips/netlogic/lib/netlib/include/export_sym.h
+++ b/arch/mips/netlogic/lib/netlib/include/export_sym.h
@@ -15,6 +15,7 @@ EXPORT_SYMBOL(netsoc_mdio_read);
 EXPORT_SYMBOL(netsoc_mdio_write);
 EXPORT_SYMBOL(netsoc_enable_flow_control);
 EXPORT_SYMBOL(netsoc_disable_flow_control);
+EXPORT_SYMBOL(netsoc_flow_control_status);
 EXPORT_SYMBOL(netsoc_set_framesize);
 
 EXPORT_SYMBOL(netsoc_open_port);
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
index 55f6d7b..f2100b9 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
@@ -57,6 +57,7 @@ extern int __netsoc_update_ucore_srclist(nae_t *nae, ucore_config_t *ucore_src,
 extern int __netsoc_mdio_rd(nae_t *nae, uint32_t type, uint32_t bus, uint32_t phyaddr, uint32_t regidx);
 extern int __netsoc_mdio_wr(nae_t *nae, uint32_t type, uint32_t bus, uint32_t phyaddr, uint32_t regidx, uint16_t val);
 extern int __netsoc_config_flow_control(net_port_t *netport, uint32_t enable);
+extern int __netsoc_flow_control_status(nae_t *nae, uint32_t port);
 extern int __netsoc_config_frame_size(net_port_t *netport, uint32_t size);
 extern void __netsoc_mac_enable(net_port_t *netport);
 extern void __netsoc_mac_disable(net_port_t *netport);
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
index 09c2870..077ab10 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
@@ -350,6 +350,7 @@ extern void netsoc_read_mac_statistics(net_port_t *netport, dev_stat_t *dev_stat
 
 extern int netsoc_disable_flow_control(net_port_t *netport);
 extern int netsoc_enable_flow_control(net_port_t *netport);
+extern int netsoc_flow_control_status(nae_t *nae, uint32_t port);
 extern int netsoc_mdio_write(net_port_t *netport, uint32_t type, uint32_t phyaddr, uint32_t regidx, uint32_t val);
 extern int netsoc_mdio_read(net_port_t *netport, uint32_t type, uint32_t phyaddr, uint32_t regidx);
 extern int netsoc_enable_nae_hwparser(nae_t *nae);
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
index 8889148..b89e8de 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
@@ -377,6 +377,13 @@ int netsoc_mac_enable(net_port_t *netport)
 *
 */
 
+int netsoc_flow_control_status(nae_t *nae, uint32_t port)
+{
+	if (nae == NULL)
+                return -NAE_INSTANCE_INVALID;
+	
+	return __netsoc_flow_control_status(nae, port);
+}
 int netsoc_mac_disable(net_port_t *netport)
 {
 	if (netport == NULL)
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index b29e419..20f4692 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -1897,7 +1897,7 @@ static void __netsoc_xfi_softreset(uint64_t mac_base,  uint32_t rst_val)
 static void __netsoc_config_sgmii(net_port_t *netport)
 {
         unsigned int mac_cfg1 = 0, mac_cfg2 = 0;
-        unsigned int netwk_inf = 0;
+        unsigned int netwk_inf = 0, val;
         unsigned int ifmode, speed, duplex;
 	nae_t *nae = netport->nae;
 	uint64_t mac_base = netsoc_get_macreg_base_for_gmac(nae->mac_base, netport->hw_port_id);
@@ -1939,9 +1939,14 @@ static void __netsoc_config_sgmii(net_port_t *netport)
         // Enable statistics counters
         netwk_inf  = netsoc_read_mac_reg(mac_base, NETWK_INF_CTRL_REG);
         netsoc_write_mac_reg(mac_base, NETWK_INF_CTRL_REG, (netwk_inf & (~(1<<15))) | (1 << 16));
-
+	
+	// Enable flow control
         mac_cfg1 = netsoc_read_mac_reg(mac_base, MAC_CONF1);
         netsoc_write_mac_reg(mac_base, MAC_CONF1, mac_cfg1 | (0x3 << 4));
+        val = netsoc_read_mac_reg(mac_base, NETIOR_GMAC_CTRL1);
+	val |= (1 << NETIOR_GMAC_TX_PAUSE_POS);	
+        netsoc_write_mac_reg(mac_base, NETIOR_GMAC_CTRL1, val);
+
 }
 
 /**
@@ -2629,6 +2634,61 @@ void __netsoc_mac_disable(net_port_t *netport)
 	}
 }
 
+int __netsoc_flow_control_status(nae_t *nae, uint32_t port)
+{
+        uint64_t mac_base, val;
+	unsigned int mac_cfg0 = 0,mac_cfg1 = 0, mask0;
+	unsigned int xaui_cfg0 = 0, xaui_cfg1 = 0, mask1;
+	net_port_t *netport = &nae->ports[port];
+	
+	switch(netport->iftype) {
+                case SGMII_IF:
+                        mac_base = netsoc_get_macreg_base_for_gmac(nae->mac_base, netport->hw_port_id);
+                        mac_cfg0 = netsoc_read_mac_reg(mac_base, MAC_CONF1);
+                        mac_cfg1 = netsoc_read_mac_reg(mac_base, NETIOR_GMAC_CTRL1);
+			mask0    = (mac_cfg0 & (1 << 4)) && (mac_cfg1 & (1 << 5));
+			
+			if (netport->flow_control_type == PFC_LEVEL) {
+				mask1 = (mac_cfg1 & ((1 << NETIOR_GMAC_TX_PFC_EN_POS) | (mac_cfg1 & 
+										(1<<NETIOR_GMAC_RX_PFC_EN_POS))));
+				val   = mask0 && mask1;
+			}
+			else
+                        	val= mask0 && (mac_cfg1 & (1 << NETIOR_GMAC_TX_PAUSE_POS));
+                        
+			if (val)
+				return 1;
+			break;
+
+		case XAUI_IF:
+                case RXAUI_IF:
+                        mac_base = __netsoc_get_xgmac_base(netport);
+			if(netport->iftype==RXAUI_IF){
+                                if((netport->hw_port_id%4)==2) {/*true if xlp9xx 2nd  port*/
+                                        mac_base = netsoc_get_macreg_base_for_xgmac2(nae->mac_base, netport->hw_port_id);
+                                }
+                        }
+			xaui_cfg0 = netsoc_read_mac_reg(mac_base, XAUI_CONFIG_1);
+			xaui_cfg1 = netsoc_read_mac_reg(mac_base, NETIOR_XGMAC_CTRL1);
+			mask0     = (xaui_cfg0 & XAUI_CONFIG_TCTLEN) && (xaui_cfg0 & XAUI_CONFIG_RCTLEN);
+			
+			if (netport->flow_control_type == PFC_LEVEL) {
+                        	mask1 = (xaui_cfg1 & ((1 << NETIOR_XGMAC_TX_PFC_EN_POS) | (xaui_cfg1 &													 (1<<NETIOR_XGMAC_RX_PFC_EN_POS))));
+				val = mask0 && mask1;
+			}
+			else
+				val = mask0 && (xaui_cfg1 & (1 << NETIOR_XGMAC_TX_PAUSE_POS));
+			
+			if (val)
+				return 1;
+	
+			break;
+		case INTERLAKEN_IF:
+                        break;
+
+	}
+	return 0;
+}
 /**
 * @brief nlm_hal_mac_enable function is used to enable an interface at the MAC level.
 *
@@ -2779,10 +2839,6 @@ int __netsoc_config_flow_control(net_port_t *netport, uint32_t enable)
                                 else {
                         	        val |= (1 << NETIOR_XGMAC_TX_PAUSE_POS);
 					netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL1, val);
-
-					val = netsoc_read_mac_reg(mac_base, XAUI_CONFIG_1);
-					val |= (XAUI_CONFIG_TCTLEN | XAUI_CONFIG_RCTLEN);
-					netsoc_write_mac_reg(mac_base, XAUI_CONFIG_1, val);
 				}
                         }
                         else {
@@ -2791,10 +2847,6 @@ int __netsoc_config_flow_control(net_port_t *netport, uint32_t enable)
                                 val &= ~(mask);
 				netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL1, val);
 
-				val = netsoc_read_mac_reg(mac_base, XAUI_CONFIG_1);	//FIXME J
-	                        val &= (~(XAUI_CONFIG_TCTLEN | XAUI_CONFIG_RCTLEN));
-        	                netsoc_write_mac_reg(mac_base, XAUI_CONFIG_1, val);
-
                         }
 			netsoc_api_print(NETSOC_APIDBG_PORT,"%s: XGMAC enable %d NETIOR_GMAC_CTRL1 0x%x\n",__func__, enable, netsoc_read_mac_reg(mac_base, NETIOR_GMAC_CTRL1));
 			break;
-- 
1.9.1

