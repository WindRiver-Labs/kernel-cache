From 0c5e05be9ca2aaf8597c999c7573301b12484e27 Mon Sep 17 00:00:00 2001
From: Ajeesh Chandra <ajeesh@broadcom.com>
Date: Wed, 27 Aug 2014 17:26:45 +0530
Subject: [PATCH 1018/1532] syslib: Best input clk src & divider for device
 based on input frequency

The updated function now determines and sets best combination of input clock
source (refclk,dev0,dev1,dev2 plls) and divider to achieve the required
device clock frequency.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/syslib/src/nlm_hal_sys.c | 66 +++++++++++++------------
 1 file changed, 35 insertions(+), 31 deletions(-)

diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal_sys.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal_sys.c
index bd544c2..c9381a0 100644
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal_sys.c
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal_sys.c
@@ -903,39 +903,43 @@ uint64_t nlm_hal_xlp2xx_get_clkdev_frq(int node, soc_device_id_t dev_type)
 
 uint64_t nlm_hal_xlp2xx_set_clkdev_frq(int node, soc_device_id_t dev_type, uint64_t new_frq)
 {
-	uint64_t frq;
-	uint8_t new_div, div;
-	xlp2xx_clkdev_sel_t pll_sel;
-
-	pll_sel = xlp2xx_get_clk_dev_sel(node, dev_type);
-	div = xlp2xx_get_clkdev_div(node, dev_type);
-	frq = nlm_hal_xlp2xx_get_clkdev_frq(node, dev_type);
-	/*TODO: Setting freq for devices disabled and using freq set by firmware */
-	return frq;
+	int i = 0;
+	uint32_t j = 0;
+	uint8_t new_div = 0;
+	xlp2xx_clkdev_sel_t new_clk_src = 0;
+	xlp2xx_pll_type_t pll = DEV0_PLL;
+	uint64_t input_clk_freqs[4];
+	uint64_t optim_delta = (FREQ_RESOLUTION + 1), cur_delta;
 
-	/* new_frq*new_div=frq*div
-	 *  new_div = frq*div/new_frq;
-	 */
-	new_div = fuzzy_divider(frq*div, new_frq);
-	switch (new_div)
-	{
-		case 1:
-			nlm_hal_xlp2xx_dev_pll_cfg(node, dev_type, pll_sel, DIV_BYPASS);
-		break;
-		case 2:
-			nlm_hal_xlp2xx_dev_pll_cfg(node, dev_type, pll_sel, DIV_DIV2);
-		break;
-		case 4:
-			nlm_hal_xlp2xx_dev_pll_cfg(node, dev_type, pll_sel, DIV_DIV4);
-		break;
-		case 8:
-			nlm_hal_xlp2xx_dev_pll_cfg(node, dev_type, pll_sel, DIV_DIV8);
-		break;
-		default:
-		break;
+	/* func: does not check NULL, hence passing some place holder out vars */
+	input_clk_freqs[0] = xlp2xx_get_ref_clk(0, &cur_delta, &j);
+
+	for(pll = DEV0_PLL; pll <= DEV2_PLL; pll++)
+		input_clk_freqs[1 + pll - DEV0_PLL] = nlm_hal_xlp2xx_get_pll_out_frq(node, pll);
+
+	for(i = 0; i < sizeof(input_clk_freqs)/sizeof(input_clk_freqs[0]); i++) {
+		for(j = 0; j <= 3; j++) {
+
+			if(input_clk_freqs[i] < new_frq)
+				break;
+
+			cur_delta = input_clk_freqs[i] - new_frq;
+
+			if(cur_delta < optim_delta) {
+				optim_delta = cur_delta;
+				new_clk_src = i;
+				new_div = (uint8_t)j;
+				break;
+			}
+
+			NLM_HAL_DO_DIV(input_clk_freqs[i], 2);
+		}
 	}
-	frq = nlm_hal_xlp2xx_get_clkdev_frq(node, dev_type);
-	return frq;
+
+	if (optim_delta <= FREQ_RESOLUTION)
+		nlm_hal_xlp2xx_dev_pll_cfg(node, dev_type, new_clk_src, new_div);
+
+	return nlm_hal_xlp2xx_get_clkdev_frq(node, dev_type);
 }
 
 /**
-- 
1.9.1

