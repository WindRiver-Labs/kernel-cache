From 019e9c2b6197b0e54e76df3c1e48024034b311fe Mon Sep 17 00:00:00 2001
From: Prasanna Mumbai <prasanna.mumbai@broadcom.com>
Date: Wed, 5 Jun 2013 21:14:41 +0530
Subject: [PATCH 1146/1532] HEv2: kernel module & user library for Hyperexec
 version 2

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c | 254 ++++++++++++++++++++++
 1 file changed, 254 insertions(+)
 create mode 100644 drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c

diff --git a/drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c b/drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c
new file mode 100644
index 0000000..512bf0d
--- /dev/null
+++ b/drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c
@@ -0,0 +1,254 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+
+
+#define MAX_NODES 	8
+#define MB(x) 		(x*1024*1024)
+#define PKTMEM_MAJOR 	123
+
+/* module parameters as array */
+static int addr[MAX_NODES];
+static int size[MAX_NODES];
+static int addr_count;
+static int size_count;
+
+module_param_array(addr, int, &addr_count, 0);
+module_param_array(size, int, &size_count, 0);
+
+typedef struct memory_pool 
+{
+	struct memory_pool * next;
+	unsigned long long start;
+	uint32_t size;
+	int inst_id;
+	int in_use;
+} memory_pool_t;
+
+memory_pool_t mem_pool_data[MAX_NODES];
+
+typedef struct brcm_devmem_ioctl {
+	unsigned int node_id;
+	unsigned int inst_id;
+	unsigned long long phys_addr;
+	unsigned long long size;
+} brcm_devmem_ioctl_t;
+
+enum pktmem_ops {
+	ALLOC_POOL = 0,
+	FREE_POOL,
+	PRINT_POOL,
+};
+
+static int print_memory(brcm_devmem_ioctl_t * param)
+{
+	memory_pool_t *mem;
+	mem = &mem_pool_data[param->node_id];
+
+	printk("pktmem: printing for node %d.\n", param->node_id);
+	while (mem != NULL)
+	{
+		printk("pktmem: addr %#x, size %#x, inst_id %d, in_use %d.\n",
+				mem->start, mem->size, mem->inst_id, mem->in_use);
+		mem = mem->next;
+	}
+
+	return 0;
+}
+
+static int alloc_memory (brcm_devmem_ioctl_t * param)
+{
+	int alloc;
+	memory_pool_t *mem, *newmem;
+
+	/* take care of shared memory request first */
+	mem = &mem_pool_data[param->node_id];
+	alloc = 0;
+	if (param->inst_id)
+	{
+		while (mem != NULL)
+		{
+			if (param->inst_id == mem->inst_id)
+			{
+				param->phys_addr = mem->start;
+				alloc = 1;
+				break;
+			}
+			mem = mem->next;
+		}
+	}
+
+	if (alloc)
+		return 0;
+
+	mem = &mem_pool_data[param->node_id];
+	alloc = 0;
+	while (mem != NULL)
+	{
+		if (mem->in_use == 0)
+		{
+			if (mem->size == param->size)
+			{
+				param->phys_addr = mem->start;
+				mem->in_use = 1;
+				alloc = 1;
+				break;
+			}
+
+			if (mem->size > param->size)
+			{
+				newmem = (memory_pool_t *) kmalloc(sizeof(memory_pool_t), GFP_KERNEL);
+				newmem->next = NULL;
+				newmem->start = mem->start;
+				newmem->size = param->size;
+				newmem->inst_id = param->inst_id;
+				newmem->in_use = 1;
+
+				param->phys_addr = newmem->start;
+
+				mem->size -= param->size;
+				mem->start += param->size;
+
+				while (mem->next != NULL) {
+					mem = mem->next;
+				}
+				mem->next = newmem;
+				alloc = 1;
+			}
+
+
+		}
+
+		mem = mem->next;
+	}
+
+	if (alloc)
+		return 0;
+	else
+		return -1;
+}
+
+static int free_memory (brcm_devmem_ioctl_t * param)
+{
+	int free;
+	memory_pool_t *mem;
+
+	mem = &mem_pool_data[param->node_id];
+	free = 0;
+
+	while (mem != NULL)
+	{
+		if (param->phys_addr == mem->start)
+		{
+			mem->inst_id = 0;
+			mem->in_use = 0;
+			free = 1;
+			break;
+		}
+		mem = mem->next;
+	}
+	
+	if (free)
+		return 0;
+	else
+		return -1;
+}
+
+static long pktmem_ioctl (struct file *fptr, unsigned int cmd, unsigned long dp)
+{
+	int rc;
+	brcm_devmem_ioctl_t *dptr;
+
+	printk("pktmem: icoctl enter, cmd %d.\n", cmd);
+
+	dptr = (brcm_devmem_ioctl_t *)dp;
+	rc = 0;
+
+	printk("pktmem: memory map before\n");
+	print_memory(dptr);
+
+	switch (cmd)
+	{
+		case ALLOC_POOL:
+			rc = alloc_memory(dptr);
+			break;
+		case FREE_POOL:
+			rc = free_memory(dptr);
+			break;
+		case PRINT_POOL:
+			rc = print_memory(dptr);
+			break;
+		default:
+			rc = -1;
+			break;
+	}
+
+	printk("pktmem: memory map after\n");
+	print_memory(dptr);
+
+	printk("pktmem: ioctl returns rc %d.\n", rc);
+	return rc;
+}
+
+static const struct file_operations pktmem_ops = {
+	.owner  = THIS_MODULE,
+	.unlocked_ioctl = pktmem_ioctl,
+};
+
+/*
+   It could be insmod pktmem.ko -mem_region <node_id>,<start_address>,<size> -mem_region <node_id>,<start_address>,<size> ...
+   modprobe pktmem.ko addr=1024,2048 size=32,64
+   */
+
+static int __init brcm_xlp_ppm_init (void)
+{
+	int i;
+
+	i = register_chrdev(PKTMEM_MAJOR, "brcm_pktmem", &pktmem_ops);
+	if (i < 0)
+	{
+		printk(KERN_ERR "brcm_pktmem: unable to register %d", PKTMEM_MAJOR);
+		return i;
+	}
+
+	printk("pktmem: addr count: %d, size count %d.\n", addr_count, size_count);
+	if ((addr_count != size_count) || !(addr_count) || !(size_count))
+	{
+		printk("pktmem: addr and size mismatch.\n");
+		printk("pktmem usage: modprobe pktmem.ko addr=10,20 size=2,4 in MB.\n");
+		return -1;
+	}
+
+	for (i=0; i<MAX_NODES; i++)
+	{
+		mem_pool_data[i].next = NULL;
+		mem_pool_data[i].inst_id = 0;
+		mem_pool_data[i].in_use = 0;
+		mem_pool_data[i].start = (unsigned long long) MB(addr[i]);
+		mem_pool_data[i].size = (uint32_t) MB(size[i]);
+		printk("pktmem: node %d, addr %#x size %#x.\n", 
+				i, mem_pool_data[i].start, mem_pool_data[i].size);
+#if 0
+		printk("pktmem: node %d, addr %d MB size %d MB.\n", i, addr[i], size[i]);
+#endif
+	}
+
+	printk (" brcm pkt mem module init.\n");
+	return 0;
+}
+
+static void __exit brcm_xlp_ppm_exit (void)
+{
+	printk (" brcm pkt mem module exit.\n");
+}
+
+module_init(brcm_xlp_ppm_init);
+module_exit(brcm_xlp_ppm_exit);
+
+MODULE_AUTHOR("Broadcom");
+MODULE_DESCRIPTION("Packet Pool Manager");
+MODULE_LICENSE("Proprietary");
+MODULE_VERSION("0.1");
-- 
1.9.1

