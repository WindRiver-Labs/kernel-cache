From 396e2ad56543c2284e1483a8c2adec9e0cda0a04 Mon Sep 17 00:00:00 2001
From: Siva Pochiraju <sivap@broadcom.com>
Date: Thu, 7 Mar 2013 03:05:01 -0800
Subject: [PATCH 1135/1532] cleanup: Removed kmod/linux-loader

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/linux-loader/Makefile        |   9 -
 drivers/misc/netlogic/linux-loader/console.c       |  73 --
 drivers/misc/netlogic/linux-loader/cpumask.h       | 928 ---------------------
 drivers/misc/netlogic/linux-loader/entry.S         | 130 ---
 drivers/misc/netlogic/linux-loader/fdt.c           | 202 -----
 drivers/misc/netlogic/linux-loader/fdt_ro.c        | 469 -----------
 drivers/misc/netlogic/linux-loader/fdt_rw.c        | 474 -----------
 drivers/misc/netlogic/linux-loader/fdt_wip.c       | 145 ----
 drivers/misc/netlogic/linux-loader/fifo.h          |  95 ---
 .../misc/netlogic/linux-loader/libfdt-wrapper.c    | 228 -----
 drivers/misc/netlogic/linux-loader/libfdt_env.h    |  50 --
 drivers/misc/netlogic/linux-loader/loader.c        | 913 --------------------
 drivers/misc/netlogic/linux-loader/ops.h           | 268 ------
 drivers/misc/netlogic/linux-loader/phnx_loader.c   | 646 --------------
 drivers/misc/netlogic/linux-loader/phnx_loader.h   | 215 -----
 .../netlogic/linux-loader/reload_irq_handler.S     |  80 --
 drivers/misc/netlogic/linux-loader/traps.c         | 242 ------
 drivers/misc/netlogic/linux-loader/uart.c          | 328 --------
 drivers/misc/netlogic/linux-loader/uart.h          |  75 --
 drivers/misc/netlogic/linux-loader/xlr_boot_lib.h  | 413 ---------
 .../misc/netlogic/linux-loader/xlr_lib_launch.c    | 663 ---------------
 .../misc/netlogic/linux-loader/xlr_lib_platform.h  | 103 ---
 .../netlogic/linux-loader/xlr_rmios_stackframe.h   | 201 -----
 23 files changed, 6950 deletions(-)
 delete mode 100644 drivers/misc/netlogic/linux-loader/Makefile
 delete mode 100644 drivers/misc/netlogic/linux-loader/console.c
 delete mode 100644 drivers/misc/netlogic/linux-loader/cpumask.h
 delete mode 100644 drivers/misc/netlogic/linux-loader/entry.S
 delete mode 100644 drivers/misc/netlogic/linux-loader/fdt.c
 delete mode 100644 drivers/misc/netlogic/linux-loader/fdt_ro.c
 delete mode 100644 drivers/misc/netlogic/linux-loader/fdt_rw.c
 delete mode 100644 drivers/misc/netlogic/linux-loader/fdt_wip.c
 delete mode 100644 drivers/misc/netlogic/linux-loader/fifo.h
 delete mode 100644 drivers/misc/netlogic/linux-loader/libfdt-wrapper.c
 delete mode 100644 drivers/misc/netlogic/linux-loader/libfdt_env.h
 delete mode 100644 drivers/misc/netlogic/linux-loader/loader.c
 delete mode 100644 drivers/misc/netlogic/linux-loader/ops.h
 delete mode 100644 drivers/misc/netlogic/linux-loader/phnx_loader.c
 delete mode 100644 drivers/misc/netlogic/linux-loader/phnx_loader.h
 delete mode 100644 drivers/misc/netlogic/linux-loader/reload_irq_handler.S
 delete mode 100644 drivers/misc/netlogic/linux-loader/traps.c
 delete mode 100644 drivers/misc/netlogic/linux-loader/uart.c
 delete mode 100644 drivers/misc/netlogic/linux-loader/uart.h
 delete mode 100644 drivers/misc/netlogic/linux-loader/xlr_boot_lib.h
 delete mode 100644 drivers/misc/netlogic/linux-loader/xlr_lib_launch.c
 delete mode 100644 drivers/misc/netlogic/linux-loader/xlr_lib_platform.h
 delete mode 100644 drivers/misc/netlogic/linux-loader/xlr_rmios_stackframe.h

diff --git a/drivers/misc/netlogic/linux-loader/Makefile b/drivers/misc/netlogic/linux-loader/Makefile
deleted file mode 100644
index 86ca512..0000000
--- a/drivers/misc/netlogic/linux-loader/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-################################################################################
-#
-# Makefile for linux loader driver
-#
-EXTRA_CFLAGS := -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogic/hal
-EXTRA_CFLAGS += -Iarch/mips/netlogic/boot -I./
-
-obj-m 		       += linux-loader.o
-linux-loader-objs	:= phnx_loader.o loader.o xlr_lib_launch.o uart.o libfdt-wrapper.o fdt_ro.o fdt_rw.o fdt_wip.o fdt.o #entry.o traps.o #reload_irq_handler.o 
diff --git a/drivers/misc/netlogic/linux-loader/console.c b/drivers/misc/netlogic/linux-loader/console.c
deleted file mode 100644
index bfd82b2..0000000
--- a/drivers/misc/netlogic/linux-loader/console.c
+++ /dev/null
@@ -1,73 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_2# */
-
-/*
- *  Derived in part from linux/lib/vsprintf.c
- *
- *  Copyright (C) 1991, 1992  Linus Torvalds
- */
-
-/* vsprintf.c -- Lars Wirzenius & Linus Torvalds. */
-
-#include <linux/console.h>
-
-#define CFG_PBSIZE 128
-
-extern void serial_puts (const char *s);
-extern int outbyte(char c);
-
-int puts (const char *s)
-{
-    serial_puts (s);
-    return 0;
-}
-
-int putchar (int c){
-    outbyte(c);
-    return 0;
-}
-
-/* we use this so that we can do without the ctype library */
-#define is_digit(c)	((c) >= '0' && (c) <= '9')
-
-#define ZEROPAD	1		/* pad with zero */
-#define SIGN	2		/* unsigned/signed long */
-#define PLUS	4		/* show plus */
-#define SPACE	8		/* space if plus */
-#define LEFT	16		/* left justified */
-#define SPECIAL	32		/* 0x */
-#define LARGE	64		/* use 'ABCDEF' instead of 'abcdef' */
-
-#define do_div(n,base) ({ \
-int __res; \
-__res = ((unsigned long) n) % (unsigned) base; \
-n = ((unsigned long) n) / (unsigned) base; \
-__res; })
-
-
diff --git a/drivers/misc/netlogic/linux-loader/cpumask.h b/drivers/misc/netlogic/linux-loader/cpumask.h
deleted file mode 100644
index b96e0c8..0000000
--- a/drivers/misc/netlogic/linux-loader/cpumask.h
+++ /dev/null
@@ -1,928 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * #BRCM_2# */
-#ifndef __LINUX_CPUMASK_H
-#define __LINUX_CPUMASK_H
-
-/*
- * Cpumasks provide a bitmap suitable for representing the
- * set of CPU's in a system, one bit position per CPU number.  In general,
- * only nr_cpu_ids (<= NR_CPUS) bits are valid.
- */
-#include <linux/kernel.h>
-#include <linux/threads.h>
-#include <linux/bitmap.h>
-
-typedef struct cpumask { DECLARE_BITMAP(bits, NR_CPUS); } cpumask_t;
-
-/**
- * cpumask_bits - get the bits in a cpumask
- * @maskp: the struct cpumask *
- *
- * You should only assume nr_cpu_ids bits of this mask are valid.  This is
- * a macro so it's const-correct.
- */
-#define cpumask_bits(maskp) ((maskp)->bits)
-
-#if NR_CPUS == 1
-#define nr_cpu_ids		1
-#else
-extern int nr_cpu_ids;
-#endif
-
-#ifdef CONFIG_CPUMASK_OFFSTACK
-/* Assuming NR_CPUS is huge, a runtime limit is more efficient.  Also,
- * not all bits may be allocated. */
-#define nr_cpumask_bits	nr_cpu_ids
-#else
-#define nr_cpumask_bits	NR_CPUS
-#endif
-
-/*
- * The following particular system cpumasks and operations manage
- * possible, present, active and online cpus.
- *
- *     cpu_possible_mask- has bit 'cpu' set iff cpu is populatable
- *     cpu_present_mask - has bit 'cpu' set iff cpu is populated
- *     cpu_online_mask  - has bit 'cpu' set iff cpu available to scheduler
- *     cpu_active_mask  - has bit 'cpu' set iff cpu available to migration
- *
- *  If !CONFIG_HOTPLUG_CPU, present == possible, and active == online.
- *
- *  The cpu_possible_mask is fixed at boot time, as the set of CPU id's
- *  that it is possible might ever be plugged in at anytime during the
- *  life of that system boot.  The cpu_present_mask is dynamic(*),
- *  representing which CPUs are currently plugged in.  And
- *  cpu_online_mask is the dynamic subset of cpu_present_mask,
- *  indicating those CPUs available for scheduling.
- *
- *  If HOTPLUG is enabled, then cpu_possible_mask is forced to have
- *  all NR_CPUS bits set, otherwise it is just the set of CPUs that
- *  ACPI reports present at boot.
- *
- *  If HOTPLUG is enabled, then cpu_present_mask varies dynamically,
- *  depending on what ACPI reports as currently plugged in, otherwise
- *  cpu_present_mask is just a copy of cpu_possible_mask.
- *
- *  (*) Well, cpu_present_mask is dynamic in the hotplug case.  If not
- *      hotplug, it's a copy of cpu_possible_mask, hence fixed at boot.
- *
- * Subtleties:
- * 1) UP arch's (NR_CPUS == 1, CONFIG_SMP not defined) hardcode
- *    assumption that their single CPU is online.  The UP
- *    cpu_{online,possible,present}_masks are placebos.  Changing them
- *    will have no useful affect on the following num_*_cpus()
- *    and cpu_*() macros in the UP case.  This ugliness is a UP
- *    optimization - don't waste any instructions or memory references
- *    asking if you're online or how many CPUs there are if there is
- *    only one CPU.
- */
-
-extern const struct cpumask *const cpu_possible_mask;
-extern const struct cpumask *const cpu_online_mask;
-extern const struct cpumask *const cpu_present_mask;
-extern const struct cpumask *const cpu_active_mask;
-
-#if NR_CPUS > 1
-#define num_online_cpus()	cpumask_weight(cpu_online_mask)
-#define num_possible_cpus()	cpumask_weight(cpu_possible_mask)
-#define num_present_cpus()	cpumask_weight(cpu_present_mask)
-#define num_active_cpus()	cpumask_weight(cpu_active_mask)
-#define cpu_online(cpu)		cpumask_test_cpu((cpu), cpu_online_mask)
-#define cpu_possible(cpu)	cpumask_test_cpu((cpu), cpu_possible_mask)
-#define cpu_present(cpu)	cpumask_test_cpu((cpu), cpu_present_mask)
-#define cpu_active(cpu)		cpumask_test_cpu((cpu), cpu_active_mask)
-#else
-#define num_online_cpus()	1
-#define num_possible_cpus()	1
-#define num_present_cpus()	1
-#define num_active_cpus()	1
-#define cpu_online(cpu)		((cpu) == 0)
-#define cpu_possible(cpu)	((cpu) == 0)
-#define cpu_present(cpu)	((cpu) == 0)
-#define cpu_active(cpu)		((cpu) == 0)
-#endif
-
-/* verify cpu argument to cpumask_* operators */
-static inline unsigned int cpumask_check(unsigned int cpu)
-{
-#ifdef CONFIG_DEBUG_PER_CPU_MAPS
-	WARN_ON_ONCE(cpu >= nr_cpumask_bits);
-#endif /* CONFIG_DEBUG_PER_CPU_MAPS */
-	return cpu;
-}
-
-#if NR_CPUS == 1
-/* Uniprocessor.  Assume all masks are "1". */
-static inline unsigned int cpumask_first(const struct cpumask *srcp)
-{
-	return 0;
-}
-
-/* Valid inputs for n are -1 and 0. */
-static inline unsigned int cpumask_next(int n, const struct cpumask *srcp)
-{
-	return n+1;
-}
-
-static inline unsigned int cpumask_next_zero(int n, const struct cpumask *srcp)
-{
-	return n+1;
-}
-
-static inline unsigned int cpumask_next_and(int n,
-					    const struct cpumask *srcp,
-					    const struct cpumask *andp)
-{
-	return n+1;
-}
-
-/* cpu must be a valid cpu, ie 0, so there's no other choice. */
-static inline unsigned int cpumask_any_but(const struct cpumask *mask,
-					   unsigned int cpu)
-{
-	return 1;
-}
-
-#define for_each_cpu(cpu, mask)			\
-	for ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask)
-#define for_each_cpu_and(cpu, mask, and)	\
-	for ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask, (void)and)
-#else
-/**
- * cpumask_first - get the first cpu in a cpumask
- * @srcp: the cpumask pointer
- *
- * Returns >= nr_cpu_ids if no cpus set.
- */
-static inline unsigned int cpumask_first(const struct cpumask *srcp)
-{
-	return find_first_bit(cpumask_bits(srcp), nr_cpumask_bits);
-}
-
-/**
- * cpumask_next - get the next cpu in a cpumask
- * @n: the cpu prior to the place to search (ie. return will be > @n)
- * @srcp: the cpumask pointer
- *
- * Returns >= nr_cpu_ids if no further cpus set.
- */
-static inline unsigned int cpumask_next(int n, const struct cpumask *srcp)
-{
-	/* -1 is a legal arg here. */
-	if (n != -1)
-		cpumask_check(n);
-	return find_next_bit(cpumask_bits(srcp), nr_cpumask_bits, n+1);
-}
-
-/**
- * cpumask_next_zero - get the next unset cpu in a cpumask
- * @n: the cpu prior to the place to search (ie. return will be > @n)
- * @srcp: the cpumask pointer
- *
- * Returns >= nr_cpu_ids if no further cpus unset.
- */
-static inline unsigned int cpumask_next_zero(int n, const struct cpumask *srcp)
-{
-	/* -1 is a legal arg here. */
-	if (n != -1)
-		cpumask_check(n);
-	return find_next_zero_bit(cpumask_bits(srcp), nr_cpumask_bits, n+1);
-}
-
-int cpumask_next_and(int n, const struct cpumask *, const struct cpumask *);
-int cpumask_any_but(const struct cpumask *mask, unsigned int cpu);
-
-/**
- * for_each_cpu - iterate over every cpu in a mask
- * @cpu: the (optionally unsigned) integer iterator
- * @mask: the cpumask pointer
- *
- * After the loop, cpu is >= nr_cpu_ids.
- */
-#define for_each_cpu(cpu, mask)				\
-	for ((cpu) = -1;				\
-		(cpu) = cpumask_next((cpu), (mask)),	\
-		(cpu) < nr_cpu_ids;)
-
-/**
- * for_each_cpu_and - iterate over every cpu in both masks
- * @cpu: the (optionally unsigned) integer iterator
- * @mask: the first cpumask pointer
- * @and: the second cpumask pointer
- *
- * This saves a temporary CPU mask in many places.  It is equivalent to:
- *	struct cpumask tmp;
- *	cpumask_and(&tmp, &mask, &and);
- *	for_each_cpu(cpu, &tmp)
- *		...
- *
- * After the loop, cpu is >= nr_cpu_ids.
- */
-#define for_each_cpu_and(cpu, mask, and)				\
-	for ((cpu) = -1;						\
-		(cpu) = cpumask_next_and((cpu), (mask), (and)),		\
-		(cpu) < nr_cpu_ids;)
-#endif /* SMP */
-
-#define CPU_BITS_NONE						\
-{								\
-	[0 ... BITS_TO_LONGS(NR_CPUS)-1] = 0UL			\
-}
-
-#define CPU_BITS_CPU0						\
-{								\
-	[0] =  1UL						\
-}
-
-/**
- * cpumask_set_cpu - set a cpu in a cpumask
- * @cpu: cpu number (< nr_cpu_ids)
- * @dstp: the cpumask pointer
- */
-static inline void cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)
-{
-	set_bit(cpumask_check(cpu), cpumask_bits(dstp));
-}
-
-/**
- * cpumask_clear_cpu - clear a cpu in a cpumask
- * @cpu: cpu number (< nr_cpu_ids)
- * @dstp: the cpumask pointer
- */
-static inline void cpumask_clear_cpu(int cpu, struct cpumask *dstp)
-{
-	clear_bit(cpumask_check(cpu), cpumask_bits(dstp));
-}
-
-/**
- * cpumask_test_cpu - test for a cpu in a cpumask
- * @cpu: cpu number (< nr_cpu_ids)
- * @cpumask: the cpumask pointer
- *
- * No static inline type checking - see Subtlety (1) above.
- */
-#define cpumask_test_cpu(cpu, cpumask) \
-	test_bit(cpumask_check(cpu), cpumask_bits((cpumask)))
-
-/**
- * cpumask_test_and_set_cpu - atomically test and set a cpu in a cpumask
- * @cpu: cpu number (< nr_cpu_ids)
- * @cpumask: the cpumask pointer
- *
- * test_and_set_bit wrapper for cpumasks.
- */
-static inline int cpumask_test_and_set_cpu(int cpu, struct cpumask *cpumask)
-{
-	return test_and_set_bit(cpumask_check(cpu), cpumask_bits(cpumask));
-}
-
-/**
- * cpumask_test_and_clear_cpu - atomically test and clear a cpu in a cpumask
- * @cpu: cpu number (< nr_cpu_ids)
- * @cpumask: the cpumask pointer
- *
- * test_and_clear_bit wrapper for cpumasks.
- */
-static inline int cpumask_test_and_clear_cpu(int cpu, struct cpumask *cpumask)
-{
-	return test_and_clear_bit(cpumask_check(cpu), cpumask_bits(cpumask));
-}
-
-/**
- * cpumask_setall - set all cpus (< nr_cpu_ids) in a cpumask
- * @dstp: the cpumask pointer
- */
-static inline void cpumask_setall(struct cpumask *dstp)
-{
-	bitmap_fill(cpumask_bits(dstp), nr_cpumask_bits);
-}
-
-/**
- * cpumask_clear - clear all cpus (< nr_cpu_ids) in a cpumask
- * @dstp: the cpumask pointer
- */
-static inline void cpumask_clear(struct cpumask *dstp)
-{
-	bitmap_zero(cpumask_bits(dstp), nr_cpumask_bits);
-}
-
-/**
- * cpumask_and - *dstp = *src1p & *src2p
- * @dstp: the cpumask result
- * @src1p: the first input
- * @src2p: the second input
- */
-static inline int cpumask_and(struct cpumask *dstp,
-			       const struct cpumask *src1p,
-			       const struct cpumask *src2p)
-{
-	return bitmap_and(cpumask_bits(dstp), cpumask_bits(src1p),
-				       cpumask_bits(src2p), nr_cpumask_bits);
-}
-
-/**
- * cpumask_or - *dstp = *src1p | *src2p
- * @dstp: the cpumask result
- * @src1p: the first input
- * @src2p: the second input
- */
-static inline void cpumask_or(struct cpumask *dstp, const struct cpumask *src1p,
-			      const struct cpumask *src2p)
-{
-	bitmap_or(cpumask_bits(dstp), cpumask_bits(src1p),
-				      cpumask_bits(src2p), nr_cpumask_bits);
-}
-
-/**
- * cpumask_xor - *dstp = *src1p ^ *src2p
- * @dstp: the cpumask result
- * @src1p: the first input
- * @src2p: the second input
- */
-static inline void cpumask_xor(struct cpumask *dstp,
-			       const struct cpumask *src1p,
-			       const struct cpumask *src2p)
-{
-	bitmap_xor(cpumask_bits(dstp), cpumask_bits(src1p),
-				       cpumask_bits(src2p), nr_cpumask_bits);
-}
-
-/**
- * cpumask_andnot - *dstp = *src1p & ~*src2p
- * @dstp: the cpumask result
- * @src1p: the first input
- * @src2p: the second input
- */
-static inline int cpumask_andnot(struct cpumask *dstp,
-				  const struct cpumask *src1p,
-				  const struct cpumask *src2p)
-{
-	return bitmap_andnot(cpumask_bits(dstp), cpumask_bits(src1p),
-					  cpumask_bits(src2p), nr_cpumask_bits);
-}
-
-/**
- * cpumask_complement - *dstp = ~*srcp
- * @dstp: the cpumask result
- * @srcp: the input to invert
- */
-static inline void cpumask_complement(struct cpumask *dstp,
-				      const struct cpumask *srcp)
-{
-	bitmap_complement(cpumask_bits(dstp), cpumask_bits(srcp),
-					      nr_cpumask_bits);
-}
-
-/**
- * cpumask_equal - *src1p == *src2p
- * @src1p: the first input
- * @src2p: the second input
- */
-static inline bool cpumask_equal(const struct cpumask *src1p,
-				const struct cpumask *src2p)
-{
-	return bitmap_equal(cpumask_bits(src1p), cpumask_bits(src2p),
-						 nr_cpumask_bits);
-}
-
-/**
- * cpumask_intersects - (*src1p & *src2p) != 0
- * @src1p: the first input
- * @src2p: the second input
- */
-static inline bool cpumask_intersects(const struct cpumask *src1p,
-				     const struct cpumask *src2p)
-{
-	return bitmap_intersects(cpumask_bits(src1p), cpumask_bits(src2p),
-						      nr_cpumask_bits);
-}
-
-/**
- * cpumask_subset - (*src1p & ~*src2p) == 0
- * @src1p: the first input
- * @src2p: the second input
- */
-static inline int cpumask_subset(const struct cpumask *src1p,
-				 const struct cpumask *src2p)
-{
-	return bitmap_subset(cpumask_bits(src1p), cpumask_bits(src2p),
-						  nr_cpumask_bits);
-}
-
-/**
- * cpumask_empty - *srcp == 0
- * @srcp: the cpumask to that all cpus < nr_cpu_ids are clear.
- */
-static inline bool cpumask_empty(const struct cpumask *srcp)
-{
-	return bitmap_empty(cpumask_bits(srcp), nr_cpumask_bits);
-}
-
-/**
- * cpumask_full - *srcp == 0xFFFFFFFF...
- * @srcp: the cpumask to that all cpus < nr_cpu_ids are set.
- */
-static inline bool cpumask_full(const struct cpumask *srcp)
-{
-	return bitmap_full(cpumask_bits(srcp), nr_cpumask_bits);
-}
-
-/**
- * cpumask_weight - Count of bits in *srcp
- * @srcp: the cpumask to count bits (< nr_cpu_ids) in.
- */
-static inline unsigned int cpumask_weight(const struct cpumask *srcp)
-{
-	return bitmap_weight(cpumask_bits(srcp), nr_cpumask_bits);
-}
-
-/**
- * cpumask_shift_right - *dstp = *srcp >> n
- * @dstp: the cpumask result
- * @srcp: the input to shift
- * @n: the number of bits to shift by
- */
-static inline void cpumask_shift_right(struct cpumask *dstp,
-				       const struct cpumask *srcp, int n)
-{
-	bitmap_shift_right(cpumask_bits(dstp), cpumask_bits(srcp), n,
-					       nr_cpumask_bits);
-}
-
-/**
- * cpumask_shift_left - *dstp = *srcp << n
- * @dstp: the cpumask result
- * @srcp: the input to shift
- * @n: the number of bits to shift by
- */
-static inline void cpumask_shift_left(struct cpumask *dstp,
-				      const struct cpumask *srcp, int n)
-{
-	bitmap_shift_left(cpumask_bits(dstp), cpumask_bits(srcp), n,
-					      nr_cpumask_bits);
-}
-
-/**
- * cpumask_copy - *dstp = *srcp
- * @dstp: the result
- * @srcp: the input cpumask
- */
-static inline void cpumask_copy(struct cpumask *dstp,
-				const struct cpumask *srcp)
-{
-	bitmap_copy(cpumask_bits(dstp), cpumask_bits(srcp), nr_cpumask_bits);
-}
-
-/**
- * cpumask_any - pick a "random" cpu from *srcp
- * @srcp: the input cpumask
- *
- * Returns >= nr_cpu_ids if no cpus set.
- */
-#define cpumask_any(srcp) cpumask_first(srcp)
-
-/**
- * cpumask_first_and - return the first cpu from *srcp1 & *srcp2
- * @src1p: the first input
- * @src2p: the second input
- *
- * Returns >= nr_cpu_ids if no cpus set in both.  See also cpumask_next_and().
- */
-#define cpumask_first_and(src1p, src2p) cpumask_next_and(-1, (src1p), (src2p))
-
-/**
- * cpumask_any_and - pick a "random" cpu from *mask1 & *mask2
- * @mask1: the first input cpumask
- * @mask2: the second input cpumask
- *
- * Returns >= nr_cpu_ids if no cpus set.
- */
-#define cpumask_any_and(mask1, mask2) cpumask_first_and((mask1), (mask2))
-
-/**
- * cpumask_of - the cpumask containing just a given cpu
- * @cpu: the cpu (<= nr_cpu_ids)
- */
-#define cpumask_of(cpu) (get_cpu_mask(cpu))
-
-/**
- * cpumask_scnprintf - print a cpumask into a string as comma-separated hex
- * @buf: the buffer to sprintf into
- * @len: the length of the buffer
- * @srcp: the cpumask to print
- *
- * If len is zero, returns zero.  Otherwise returns the length of the
- * (nul-terminated) @buf string.
- */
-static inline int cpumask_scnprintf(char *buf, int len,
-				    const struct cpumask *srcp)
-{
-	return bitmap_scnprintf(buf, len, cpumask_bits(srcp), nr_cpumask_bits);
-}
-
-/**
- * cpumask_parse_user - extract a cpumask from a user string
- * @buf: the buffer to extract from
- * @len: the length of the buffer
- * @dstp: the cpumask to set.
- *
- * Returns -errno, or 0 for success.
- */
-static inline int cpumask_parse_user(const char __user *buf, int len,
-				     struct cpumask *dstp)
-{
-	return bitmap_parse_user(buf, len, cpumask_bits(dstp), nr_cpumask_bits);
-}
-
-/**
- * cpulist_scnprintf - print a cpumask into a string as comma-separated list
- * @buf: the buffer to sprintf into
- * @len: the length of the buffer
- * @srcp: the cpumask to print
- *
- * If len is zero, returns zero.  Otherwise returns the length of the
- * (nul-terminated) @buf string.
- */
-static inline int cpulist_scnprintf(char *buf, int len,
-				    const struct cpumask *srcp)
-{
-	return bitmap_scnlistprintf(buf, len, cpumask_bits(srcp),
-				    nr_cpumask_bits);
-}
-
-/**
- * cpulist_parse_user - extract a cpumask from a user string of ranges
- * @buf: the buffer to extract from
- * @len: the length of the buffer
- * @dstp: the cpumask to set.
- *
- * Returns -errno, or 0 for success.
- */
-static inline int cpulist_parse(const char *buf, struct cpumask *dstp)
-{
-	return bitmap_parselist(buf, cpumask_bits(dstp), nr_cpumask_bits);
-}
-
-/**
- * cpumask_size - size to allocate for a 'struct cpumask' in bytes
- *
- * This will eventually be a runtime variable, depending on nr_cpu_ids.
- */
-static inline size_t cpumask_size(void)
-{
-	/* FIXME: Once all cpumask assignments are eliminated, this
-	 * can be nr_cpumask_bits */
-	return BITS_TO_LONGS(NR_CPUS) * sizeof(long);
-}
-
-/*
- * cpumask_var_t: struct cpumask for stack usage.
- *
- * Oh, the wicked games we play!  In order to make kernel coding a
- * little more difficult, we typedef cpumask_var_t to an array or a
- * pointer: doing &mask on an array is a noop, so it still works.
- *
- * ie.
- *	cpumask_var_t tmpmask;
- *	if (!alloc_cpumask_var(&tmpmask, GFP_KERNEL))
- *		return -ENOMEM;
- *
- *	  ... use 'tmpmask' like a normal struct cpumask * ...
- *
- *	free_cpumask_var(tmpmask);
- */
-#ifdef CONFIG_CPUMASK_OFFSTACK
-typedef struct cpumask *cpumask_var_t;
-
-bool alloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags, int node);
-bool alloc_cpumask_var(cpumask_var_t *mask, gfp_t flags);
-bool zalloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags, int node);
-bool zalloc_cpumask_var(cpumask_var_t *mask, gfp_t flags);
-void alloc_bootmem_cpumask_var(cpumask_var_t *mask);
-void free_cpumask_var(cpumask_var_t mask);
-void free_bootmem_cpumask_var(cpumask_var_t mask);
-
-#else
-typedef struct cpumask cpumask_var_t[1];
-
-static inline bool alloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
-{
-	return true;
-}
-
-static inline bool alloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags,
-					  int node)
-{
-	return true;
-}
-
-static inline bool zalloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
-{
-	cpumask_clear(*mask);
-	return true;
-}
-
-static inline bool zalloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags,
-					  int node)
-{
-	cpumask_clear(*mask);
-	return true;
-}
-
-static inline void alloc_bootmem_cpumask_var(cpumask_var_t *mask)
-{
-}
-
-static inline void free_cpumask_var(cpumask_var_t mask)
-{
-}
-
-static inline void free_bootmem_cpumask_var(cpumask_var_t mask)
-{
-}
-#endif /* CONFIG_CPUMASK_OFFSTACK */
-
-/* It's common to want to use cpu_all_mask in struct member initializers,
- * so it has to refer to an address rather than a pointer. */
-extern const DECLARE_BITMAP(cpu_all_bits, NR_CPUS);
-#define cpu_all_mask to_cpumask(cpu_all_bits)
-
-/* First bits of cpu_bit_bitmap are in fact unset. */
-#define cpu_none_mask to_cpumask(cpu_bit_bitmap[0])
-
-#define for_each_possible_cpu(cpu) for_each_cpu((cpu), cpu_possible_mask)
-#define for_each_online_cpu(cpu)   for_each_cpu((cpu), cpu_online_mask)
-#define for_each_present_cpu(cpu)  for_each_cpu((cpu), cpu_present_mask)
-
-/* Wrappers for arch boot code to manipulate normally-constant masks */
-void set_cpu_possible(unsigned int cpu, bool possible);
-void set_cpu_present(unsigned int cpu, bool present);
-void set_cpu_online(unsigned int cpu, bool online);
-void set_cpu_active(unsigned int cpu, bool active);
-void init_cpu_present(const struct cpumask *src);
-void init_cpu_possible(const struct cpumask *src);
-void init_cpu_online(const struct cpumask *src);
-
-/**
- * to_cpumask - convert an NR_CPUS bitmap to a struct cpumask *
- * @bitmap: the bitmap
- *
- * There are a few places where cpumask_var_t isn't appropriate and
- * static cpumasks must be used (eg. very early boot), yet we don't
- * expose the definition of 'struct cpumask'.
- *
- * This does the conversion, and can be used as a constant initializer.
- */
-#define to_cpumask(bitmap)						\
-	((struct cpumask *)(1 ? (bitmap)				\
-			    : (void *)sizeof(__check_is_bitmap(bitmap))))
-
-static inline int __check_is_bitmap(const unsigned long *bitmap)
-{
-	return 1;
-}
-
-/*
- * Special-case data structure for "single bit set only" constant CPU masks.
- *
- * We pre-generate all the 64 (or 32) possible bit positions, with enough
- * padding to the left and the right, and return the constant pointer
- * appropriately offset.
- */
-extern const unsigned long
-	cpu_bit_bitmap[BITS_PER_LONG+1][BITS_TO_LONGS(NR_CPUS)];
-
-static inline const struct cpumask *get_cpu_mask(unsigned int cpu)
-{
-	const unsigned long *p = cpu_bit_bitmap[1 + cpu % BITS_PER_LONG];
-	p -= cpu / BITS_PER_LONG;
-	return to_cpumask(p);
-}
-
-#define cpu_is_offline(cpu)	unlikely(!cpu_online(cpu))
-
-#if NR_CPUS <= BITS_PER_LONG
-#define CPU_BITS_ALL						\
-{								\
-	[BITS_TO_LONGS(NR_CPUS)-1] = CPU_MASK_LAST_WORD	\
-}
-
-#else /* NR_CPUS > BITS_PER_LONG */
-
-#define CPU_BITS_ALL						\
-{								\
-	[0 ... BITS_TO_LONGS(NR_CPUS)-2] = ~0UL,		\
-	[BITS_TO_LONGS(NR_CPUS)-1] = CPU_MASK_LAST_WORD		\
-}
-#endif /* NR_CPUS > BITS_PER_LONG */
-
-/*
- *
- * From here down, all obsolete.  Use cpumask_ variants!
- *
- */
-#ifndef CONFIG_DISABLE_OBSOLETE_CPUMASK_FUNCTIONS
-/* These strip const, as traditionally they weren't const. */
-#define cpu_possible_map	(*(cpumask_t *)cpu_possible_mask)
-#define cpu_online_map		(*(cpumask_t *)cpu_online_mask)
-#define cpu_present_map		(*(cpumask_t *)cpu_present_mask)
-#define cpu_active_map		(*(cpumask_t *)cpu_active_mask)
-
-#define cpumask_of_cpu(cpu) (*get_cpu_mask(cpu))
-
-#define CPU_MASK_LAST_WORD BITMAP_LAST_WORD_MASK(NR_CPUS)
-
-#if NR_CPUS <= BITS_PER_LONG
-
-#define CPU_MASK_ALL							\
-(cpumask_t) { {								\
-	[BITS_TO_LONGS(NR_CPUS)-1] = CPU_MASK_LAST_WORD			\
-} }
-
-#else
-
-#define CPU_MASK_ALL							\
-(cpumask_t) { {								\
-	[0 ... BITS_TO_LONGS(NR_CPUS)-2] = ~0UL,			\
-	[BITS_TO_LONGS(NR_CPUS)-1] = CPU_MASK_LAST_WORD			\
-} }
-
-#endif
-
-#define CPU_MASK_NONE							\
-(cpumask_t) { {								\
-	[0 ... BITS_TO_LONGS(NR_CPUS)-1] =  0UL				\
-} }
-
-#define CPU_MASK_CPU0							\
-(cpumask_t) { {								\
-	[0] =  1UL							\
-} }
-
-#if NR_CPUS == 1
-#define first_cpu(src)		({ (void)(src); 0; })
-#define next_cpu(n, src)	({ (void)(src); 1; })
-#define any_online_cpu(mask)	0
-#define for_each_cpu_mask(cpu, mask)	\
-	for ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask)
-#else /* NR_CPUS > 1 */
-int __first_cpu(const cpumask_t *srcp);
-int __next_cpu(int n, const cpumask_t *srcp);
-int __any_online_cpu(const cpumask_t *mask);
-
-#define first_cpu(src)		__first_cpu(&(src))
-#define next_cpu(n, src)	__next_cpu((n), &(src))
-#define any_online_cpu(mask) __any_online_cpu(&(mask))
-#define for_each_cpu_mask(cpu, mask)			\
-	for ((cpu) = -1;				\
-		(cpu) = next_cpu((cpu), (mask)),	\
-		(cpu) < NR_CPUS; )
-#endif /* SMP */
-
-#if NR_CPUS <= 64
-
-#define for_each_cpu_mask_nr(cpu, mask)	for_each_cpu_mask(cpu, mask)
-
-#else /* NR_CPUS > 64 */
-
-int __next_cpu_nr(int n, const cpumask_t *srcp);
-#define for_each_cpu_mask_nr(cpu, mask)			\
-	for ((cpu) = -1;				\
-		(cpu) = __next_cpu_nr((cpu), &(mask)),	\
-		(cpu) < nr_cpu_ids; )
-
-#endif /* NR_CPUS > 64 */
-
-#define cpus_addr(src) ((src).bits)
-
-#define cpu_set(cpu, dst) __cpu_set((cpu), &(dst))
-static inline void __cpu_set(int cpu, volatile cpumask_t *dstp)
-{
-	set_bit(cpu, dstp->bits);
-}
-
-#define cpu_clear(cpu, dst) __cpu_clear((cpu), &(dst))
-static inline void __cpu_clear(int cpu, volatile cpumask_t *dstp)
-{
-	clear_bit(cpu, dstp->bits);
-}
-
-#define cpus_setall(dst) __cpus_setall(&(dst), NR_CPUS)
-static inline void __cpus_setall(cpumask_t *dstp, int nbits)
-{
-	bitmap_fill(dstp->bits, nbits);
-}
-
-#define cpus_clear(dst) __cpus_clear(&(dst), NR_CPUS)
-static inline void __cpus_clear(cpumask_t *dstp, int nbits)
-{
-	bitmap_zero(dstp->bits, nbits);
-}
-
-/* No static inline type checking - see Subtlety (1) above. */
-#define cpu_isset(cpu, cpumask) test_bit((cpu), (cpumask).bits)
-
-#define cpu_test_and_set(cpu, cpumask) __cpu_test_and_set((cpu), &(cpumask))
-static inline int __cpu_test_and_set(int cpu, cpumask_t *addr)
-{
-	return test_and_set_bit(cpu, addr->bits);
-}
-
-#define cpus_and(dst, src1, src2) __cpus_and(&(dst), &(src1), &(src2), NR_CPUS)
-static inline int __cpus_and(cpumask_t *dstp, const cpumask_t *src1p,
-					const cpumask_t *src2p, int nbits)
-{
-	return bitmap_and(dstp->bits, src1p->bits, src2p->bits, nbits);
-}
-
-#define cpus_or(dst, src1, src2) __cpus_or(&(dst), &(src1), &(src2), NR_CPUS)
-static inline void __cpus_or(cpumask_t *dstp, const cpumask_t *src1p,
-					const cpumask_t *src2p, int nbits)
-{
-	bitmap_or(dstp->bits, src1p->bits, src2p->bits, nbits);
-}
-
-#define cpus_xor(dst, src1, src2) __cpus_xor(&(dst), &(src1), &(src2), NR_CPUS)
-static inline void __cpus_xor(cpumask_t *dstp, const cpumask_t *src1p,
-					const cpumask_t *src2p, int nbits)
-{
-	bitmap_xor(dstp->bits, src1p->bits, src2p->bits, nbits);
-}
-
-#define cpus_andnot(dst, src1, src2) \
-				__cpus_andnot(&(dst), &(src1), &(src2), NR_CPUS)
-static inline int __cpus_andnot(cpumask_t *dstp, const cpumask_t *src1p,
-					const cpumask_t *src2p, int nbits)
-{
-	return bitmap_andnot(dstp->bits, src1p->bits, src2p->bits, nbits);
-}
-
-#define cpus_equal(src1, src2) __cpus_equal(&(src1), &(src2), NR_CPUS)
-static inline int __cpus_equal(const cpumask_t *src1p,
-					const cpumask_t *src2p, int nbits)
-{
-	return bitmap_equal(src1p->bits, src2p->bits, nbits);
-}
-
-#define cpus_intersects(src1, src2) __cpus_intersects(&(src1), &(src2), NR_CPUS)
-static inline int __cpus_intersects(const cpumask_t *src1p,
-					const cpumask_t *src2p, int nbits)
-{
-	return bitmap_intersects(src1p->bits, src2p->bits, nbits);
-}
-
-#define cpus_subset(src1, src2) __cpus_subset(&(src1), &(src2), NR_CPUS)
-static inline int __cpus_subset(const cpumask_t *src1p,
-					const cpumask_t *src2p, int nbits)
-{
-	return bitmap_subset(src1p->bits, src2p->bits, nbits);
-}
-
-#define cpus_empty(src) __cpus_empty(&(src), NR_CPUS)
-static inline int __cpus_empty(const cpumask_t *srcp, int nbits)
-{
-	return bitmap_empty(srcp->bits, nbits);
-}
-
-#define cpus_weight(cpumask) __cpus_weight(&(cpumask), NR_CPUS)
-static inline int __cpus_weight(const cpumask_t *srcp, int nbits)
-{
-	return bitmap_weight(srcp->bits, nbits);
-}
-
-#define cpus_shift_left(dst, src, n) \
-			__cpus_shift_left(&(dst), &(src), (n), NR_CPUS)
-static inline void __cpus_shift_left(cpumask_t *dstp,
-					const cpumask_t *srcp, int n, int nbits)
-{
-	bitmap_shift_left(dstp->bits, srcp->bits, n, nbits);
-}
-#endif /* !CONFIG_DISABLE_OBSOLETE_CPUMASK_FUNCTIONS */
-
-#endif /* __LINUX_CPUMASK_H */
diff --git a/drivers/misc/netlogic/linux-loader/entry.S b/drivers/misc/netlogic/linux-loader/entry.S
deleted file mode 100644
index 3b02904..0000000
--- a/drivers/misc/netlogic/linux-loader/entry.S
+++ /dev/null
@@ -1,130 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_2# */
-
-
-#include <asm/mipsregs.h>
-#include <asm/regdef.h>
-#include <asm/asm.h> 
-#include "xlr_rmios_stackframe.h"
-#include <asm/stackframe.h>
-#include <asm/asm-offsets.h>
-
-#define KU_USER 0x10
-
-.text
-.align 4
-.set push
-.set reorder
-
-FEXPORT(r_ret_from_exception)
-FEXPORT(r_ret_from_irq)
-	.set    noat
-	/* STI */
-	restore_stack_frame
-	eret
-	/*   RESTORE_ALL_AND_RET*/
-	.set    at
-
-NESTED(xlr_tlb_refill_secondary, K_STACK_SIZE, sp)
-	save_stack_frame
-	move a0, sp
-	jal xlr_tlb_panic
-	nop
-END(xlr_tlb_refill_secondary)
-
-NESTED(reload_except_vec_tlbrefill, 0, sp)
-	jal xlr_tlb_refill_secondary 
-	nop    
-END(reload_except_vec_tlbrefill)
-
-NESTED(xlr_xtlb_refill_secondary, K_STACK_SIZE, sp)
-	save_stack_frame
-	move a0, sp
-	jal xlr_xtlb_panic
-	nop
-END(xlr_xtlb_refill_secondary)
-
-
-NESTED(reload_except_vec_xtlbrefill, 0, sp)
-	jal xlr_xtlb_refill_secondary
-	nop
-END(reload_except_vec_xtlbrefill)
-
-NESTED(reload_except_vec_cacheerr, 0, sp)
-	PANIC("Unhandled Cache Err Exception, Reloading CPU\n")
-	nop
-END(reload_except_vec_cacheerr)
-
-NESTED(xlr_vecinit_secondary, K_STACK_SIZE, sp)
-	save_stack_frame
-	move a0, sp
-	jal xlr_vecint_panic
-	nop
-END(xlr_vecinit_secondary)
-
-NESTED(reload_except_vec_vecint, 0, sp)
-	jal xlr_vecinit_secondary
-	nop
-END(reload_except_vec_vecint)
-
-NESTED(reload_except_vec_genex, 0, sp)
-	mfc0    k1, CP0_CAUSE
-	PTR_LA      k0, r_exception_handlers 
-	andi    k1, k1, 0x7c
-	addu    k0, k0, k1
-	lw      k0, (k0)
-	jr      k0
-	nop
-END(reload_except_vec_genex)
-
-.set pop
-
-.text
-.set    push
-.set    noreorder
-.set    mips4
-.align    5
-NESTED(reload_handle_reserved, K_STACK_SIZE, sp)    
-	.set    noat
-	save_stack_frame 
-	.set    at
-	KMODE
-	dmfc0   t0, CP0_STATUS
-	ori t0, 2
-	xori t0, 2
-	dmtc0   t0, CP0_STATUS
-	jal     do_reload_setup
-	move 	a0, sp
-	j   	r_ret_from_exception
-	nop
-END(reload_handle_reserved)    
-
-.set pop
-
-
diff --git a/drivers/misc/netlogic/linux-loader/fdt.c b/drivers/misc/netlogic/linux-loader/fdt.c
deleted file mode 100644
index 3d7dc7c..0000000
--- a/drivers/misc/netlogic/linux-loader/fdt.c
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * libfdt - Flat Device Tree manipulation
- * Copyright (C) 2006 David Gibson, IBM Corporation.
- *
- * libfdt is dual licensed: you can use it either under the terms of
- * the GPL, or the BSD license, at your option.
- *
- *  a) This library is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This library is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- *     You should have received a copy of the GNU General Public
- *     License along with this library; if not, write to the Free
- *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
- *     MA 02110-1301 USA
- *
- * Alternatively,
- *
- *  b) Redistribution and use in source and binary forms, with or
- *     without modification, are permitted provided that the following
- *     conditions are met:
- *
- *     1. Redistributions of source code must retain the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer.
- *     2. Redistributions in binary form must reproduce the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *
- *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
- *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
- *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
- *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#include "libfdt_env.h"
-
-#include <fdt.h>
-#include <libfdt.h>
-
-#include "libfdt_internal.h"
-
-int fdt_check_header(const void *fdt)
-{
-	if (fdt_magic(fdt) == FDT_MAGIC) {
-		/* Complete tree */
-		if (fdt_version(fdt) < FDT_FIRST_SUPPORTED_VERSION)
-			return -FDT_ERR_BADVERSION;
-		if (fdt_last_comp_version(fdt) > FDT_LAST_SUPPORTED_VERSION)
-			return -FDT_ERR_BADVERSION;
-	} else if (fdt_magic(fdt) == FDT_SW_MAGIC) {
-		/* Unfinished sequential-write blob */
-		if (fdt_size_dt_struct(fdt) == 0)
-			return -FDT_ERR_BADSTATE;
-	} else {
-		return -FDT_ERR_BADMAGIC;
-	}
-
-	return 0;
-}
-
-const void *fdt_offset_ptr(const void *fdt, int offset, int len)
-{
-	const char *p;
-
-	if (fdt_version(fdt) >= 0x11)
-		if (((offset + len) < offset)
-		    || ((offset + len) > fdt_size_dt_struct(fdt)))
-			return NULL;
-
-	p = _fdt_offset_ptr(fdt, offset);
-
-	if (p + len < p)
-		return NULL;
-	return p;
-}
-
-uint32_t fdt_next_tag(const void *fdt, int offset, int *nextoffset)
-{
-	const uint32_t *tagp, *lenp;
-	uint32_t tag;
-	const char *p;
-
-	if (offset % FDT_TAGSIZE)
-		return -1;
-
-	tagp = fdt_offset_ptr(fdt, offset, FDT_TAGSIZE);
-	if (! tagp)
-		return FDT_END; /* premature end */
-	tag = fdt32_to_cpu(*tagp);
-	offset += FDT_TAGSIZE;
-
-	switch (tag) {
-	case FDT_BEGIN_NODE:
-		/* skip name */
-		do {
-			p = fdt_offset_ptr(fdt, offset++, 1);
-		} while (p && (*p != '\0'));
-		if (! p)
-			return FDT_END;
-		break;
-	case FDT_PROP:
-		lenp = fdt_offset_ptr(fdt, offset, sizeof(*lenp));
-		if (! lenp)
-			return FDT_END;
-		/* skip name offset, length and value */
-		offset += 2*FDT_TAGSIZE + fdt32_to_cpu(*lenp);
-		break;
-	}
-
-	if (nextoffset)
-		*nextoffset = FDT_TAGALIGN(offset);
-
-	return tag;
-}
-
-int _fdt_check_node_offset(const void *fdt, int offset)
-{
-	if ((offset < 0) || (offset % FDT_TAGSIZE)
-	    || (fdt_next_tag(fdt, offset, &offset) != FDT_BEGIN_NODE))
-		return -FDT_ERR_BADOFFSET;
-
-	return offset;
-}
-
-int fdt_next_node(const void *fdt, int offset, int *depth)
-{
-	int nextoffset = 0;
-	uint32_t tag;
-
-	if (offset >= 0)
-		if ((nextoffset = _fdt_check_node_offset(fdt, offset)) < 0)
-			return nextoffset;
-
-	do {
-		offset = nextoffset;
-		tag = fdt_next_tag(fdt, offset, &nextoffset);
-
-		switch (tag) {
-		case FDT_PROP:
-		case FDT_NOP:
-			break;
-
-		case FDT_BEGIN_NODE:
-			if (depth)
-				(*depth)++;
-			break;
-
-		case FDT_END_NODE:
-			if (depth)
-				(*depth)--;
-			break;
-
-		case FDT_END:
-			return -FDT_ERR_NOTFOUND;
-
-		default:
-			return -FDT_ERR_BADSTRUCTURE;
-		}
-	} while (tag != FDT_BEGIN_NODE);
-
-	return offset;
-}
-
-const char *_fdt_find_string(const char *strtab, int tabsize, const char *s)
-{
-	int len = strlen(s) + 1;
-	const char *last = strtab + tabsize - len;
-	const char *p;
-
-	for (p = strtab; p <= last; p++)
-		if (memcmp(p, s, len) == 0)
-			return p;
-	return NULL;
-}
-
-int fdt_move(const void *fdt, void *buf, int bufsize)
-{
-#if 0
-	FDT_CHECK_HEADER(fdt);
-
-	if (fdt_totalsize(fdt) > bufsize)
-		return -FDT_ERR_NOSPACE;
-#endif
-	memcpy(buf, fdt, fdt_totalsize(fdt));
-	return 0;
-}
diff --git a/drivers/misc/netlogic/linux-loader/fdt_ro.c b/drivers/misc/netlogic/linux-loader/fdt_ro.c
deleted file mode 100644
index 22e69291..0000000
--- a/drivers/misc/netlogic/linux-loader/fdt_ro.c
+++ /dev/null
@@ -1,469 +0,0 @@
-/*
- * libfdt - Flat Device Tree manipulation
- * Copyright (C) 2006 David Gibson, IBM Corporation.
- *
- * libfdt is dual licensed: you can use it either under the terms of
- * the GPL, or the BSD license, at your option.
- *
- *  a) This library is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This library is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- *     You should have received a copy of the GNU General Public
- *     License along with this library; if not, write to the Free
- *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
- *     MA 02110-1301 USA
- *
- * Alternatively,
- *
- *  b) Redistribution and use in source and binary forms, with or
- *     without modification, are permitted provided that the following
- *     conditions are met:
- *
- *     1. Redistributions of source code must retain the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer.
- *     2. Redistributions in binary form must reproduce the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *
- *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
- *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
- *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
- *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#include "libfdt_env.h"
-
-#include <fdt.h>
-#include <libfdt.h>
-
-#include "libfdt_internal.h"
-
-static int _fdt_nodename_eq(const void *fdt, int offset,
-			    const char *s, int len)
-{
-	const char *p = fdt_offset_ptr(fdt, offset + FDT_TAGSIZE, len+1);
-
-	if (! p)
-		/* short match */
-		return 0;
-
-	if (memcmp(p, s, len) != 0)
-		return 0;
-
-	if (p[len] == '\0')
-		return 1;
-	else if (!memchr(s, '@', len) && (p[len] == '@'))
-		return 1;
-	else
-		return 0;
-}
-
-const char *fdt_string(const void *fdt, int stroffset)
-{
-	return (const char *)fdt + fdt_off_dt_strings(fdt) + stroffset;
-}
-
-int fdt_get_mem_rsv(const void *fdt, int n, uint64_t *address, uint64_t *size)
-{
-	FDT_CHECK_HEADER(fdt);
-	*address = fdt64_to_cpu(_fdt_mem_rsv(fdt, n)->address);
-	*size = fdt64_to_cpu(_fdt_mem_rsv(fdt, n)->size);
-	return 0;
-}
-
-int fdt_num_mem_rsv(const void *fdt)
-{
-	int i = 0;
-
-	while (fdt64_to_cpu(_fdt_mem_rsv(fdt, i)->size) != 0)
-		i++;
-	return i;
-}
-
-int fdt_subnode_offset_namelen(const void *fdt, int offset,
-			       const char *name, int namelen)
-{
-	int depth;
-
-	FDT_CHECK_HEADER(fdt);
-
-	for (depth = 0, offset = fdt_next_node(fdt, offset, &depth);
-	     (offset >= 0) && (depth > 0);
-	     offset = fdt_next_node(fdt, offset, &depth)) {
-		if (depth < 0)
-			return -FDT_ERR_NOTFOUND;
-		else if ((depth == 1)
-			 && _fdt_nodename_eq(fdt, offset, name, namelen))
-			return offset;
-	}
-
-	if (offset < 0)
-		return offset; /* error */
-	else
-		return -FDT_ERR_NOTFOUND;
-}
-
-int fdt_subnode_offset(const void *fdt, int parentoffset,
-		       const char *name)
-{
-	return fdt_subnode_offset_namelen(fdt, parentoffset, name, strlen(name));
-}
-
-int fdt_path_offset(const void *fdt, const char *path)
-{
-	const char *end = path + strlen(path);
-	const char *p = path;
-	int offset = 0;
-
-	FDT_CHECK_HEADER(fdt);
-
-	if (*path != '/')
-		return -FDT_ERR_BADPATH;
-
-	while (*p) {
-		const char *q;
-
-		while (*p == '/')
-			p++;
-		if (! *p)
-			return offset;
-		q = strchr(p, '/');
-		if (! q)
-			q = end;
-
-		offset = fdt_subnode_offset_namelen(fdt, offset, p, q-p);
-		if (offset < 0)
-			return offset;
-
-		p = q;
-	}
-
-	return offset;
-}
-
-const char *fdt_get_name(const void *fdt, int nodeoffset, int *len)
-{
-	const struct fdt_node_header *nh = _fdt_offset_ptr(fdt, nodeoffset);
-	int err;
-
-	if (((err = fdt_check_header(fdt)) != 0)
-	    || ((err = _fdt_check_node_offset(fdt, nodeoffset)) < 0))
-			goto fail;
-
-	if (len)
-		*len = strlen(nh->name);
-
-	return nh->name;
-
- fail:
-	if (len)
-		*len = err;
-	return NULL;
-}
-
-const struct fdt_property *fdt_get_property(const void *fdt,
-					    int nodeoffset,
-					    const char *name, int *lenp)
-{
-	uint32_t tag;
-	const struct fdt_property *prop;
-	int namestroff;
-	int offset, nextoffset;
-	int err;
-
-	if (((err = fdt_check_header(fdt)) != 0)
-	    || ((err = _fdt_check_node_offset(fdt, nodeoffset)) < 0))
-			goto fail;
-
-	nextoffset = err;
-	do {
-		offset = nextoffset;
-
-		tag = fdt_next_tag(fdt, offset, &nextoffset);
-		switch (tag) {
-		case FDT_END:
-			err = -FDT_ERR_TRUNCATED;
-			goto fail;
-
-		case FDT_BEGIN_NODE:
-		case FDT_END_NODE:
-		case FDT_NOP:
-			break;
-
-		case FDT_PROP:
-			err = -FDT_ERR_BADSTRUCTURE;
-			prop = fdt_offset_ptr(fdt, offset, sizeof(*prop));
-			if (! prop)
-				goto fail;
-			namestroff = fdt32_to_cpu(prop->nameoff);
-			if (strcmp(fdt_string(fdt, namestroff), name) == 0) {
-				/* Found it! */
-				int len = fdt32_to_cpu(prop->len);
-				prop = fdt_offset_ptr(fdt, offset,
-						      sizeof(*prop)+len);
-				if (! prop)
-					goto fail;
-
-				if (lenp)
-					*lenp = len;
-
-				return prop;
-			}
-			break;
-
-		default:
-			err = -FDT_ERR_BADSTRUCTURE;
-			goto fail;
-		}
-	} while ((tag != FDT_BEGIN_NODE) && (tag != FDT_END_NODE));
-
-	err = -FDT_ERR_NOTFOUND;
- fail:
-	if (lenp)
-		*lenp = err;
-	return NULL;
-}
-
-const void *fdt_getprop(const void *fdt, int nodeoffset,
-		  const char *name, int *lenp)
-{
-	const struct fdt_property *prop;
-
-	prop = fdt_get_property(fdt, nodeoffset, name, lenp);
-	if (! prop)
-		return NULL;
-
-	return prop->data;
-}
-
-uint32_t fdt_get_phandle(const void *fdt, int nodeoffset)
-{
-	const uint32_t *php;
-	int len;
-
-	php = fdt_getprop(fdt, nodeoffset, "linux,phandle", &len);
-	if (!php || (len != sizeof(*php)))
-		return 0;
-
-	return fdt32_to_cpu(*php);
-}
-
-int fdt_get_path(const void *fdt, int nodeoffset, char *buf, int buflen)
-{
-	int pdepth = 0, p = 0;
-	int offset, depth, namelen;
-	const char *name;
-
-	FDT_CHECK_HEADER(fdt);
-
-	if (buflen < 2)
-		return -FDT_ERR_NOSPACE;
-
-	for (offset = 0, depth = 0;
-	     (offset >= 0) && (offset <= nodeoffset);
-	     offset = fdt_next_node(fdt, offset, &depth)) {
-		if (pdepth < depth)
-			continue; /* overflowed buffer */
-
-		while (pdepth > depth) {
-			do {
-				p--;
-			} while (buf[p-1] != '/');
-			pdepth--;
-		}
-
-		name = fdt_get_name(fdt, offset, &namelen);
-		if (!name)
-			return namelen;
-		if ((p + namelen + 1) <= buflen) {
-			memcpy(buf + p, name, namelen);
-			p += namelen;
-			buf[p++] = '/';
-			pdepth++;
-		}
-
-		if (offset == nodeoffset) {
-			if (pdepth < (depth + 1))
-				return -FDT_ERR_NOSPACE;
-
-			if (p > 1) /* special case so that root path is "/", not "" */
-				p--;
-			buf[p] = '\0';
-			return p;
-		}
-	}
-
-	if ((offset == -FDT_ERR_NOTFOUND) || (offset >= 0))
-		return -FDT_ERR_BADOFFSET;
-	else if (offset == -FDT_ERR_BADOFFSET)
-		return -FDT_ERR_BADSTRUCTURE;
-
-	return offset; /* error from fdt_next_node() */
-}
-
-int fdt_supernode_atdepth_offset(const void *fdt, int nodeoffset,
-				 int supernodedepth, int *nodedepth)
-{
-	int offset, depth;
-	int supernodeoffset = -FDT_ERR_INTERNAL;
-
-	FDT_CHECK_HEADER(fdt);
-
-	if (supernodedepth < 0)
-		return -FDT_ERR_NOTFOUND;
-
-	for (offset = 0, depth = 0;
-	     (offset >= 0) && (offset <= nodeoffset);
-	     offset = fdt_next_node(fdt, offset, &depth)) {
-		if (depth == supernodedepth)
-			supernodeoffset = offset;
-
-		if (offset == nodeoffset) {
-			if (nodedepth)
-				*nodedepth = depth;
-
-			if (supernodedepth > depth)
-				return -FDT_ERR_NOTFOUND;
-			else
-				return supernodeoffset;
-		}
-	}
-
-	if ((offset == -FDT_ERR_NOTFOUND) || (offset >= 0))
-		return -FDT_ERR_BADOFFSET;
-	else if (offset == -FDT_ERR_BADOFFSET)
-		return -FDT_ERR_BADSTRUCTURE;
-
-	return offset; /* error from fdt_next_node() */
-}
-
-int fdt_node_depth(const void *fdt, int nodeoffset)
-{
-	int nodedepth;
-	int err;
-
-	err = fdt_supernode_atdepth_offset(fdt, nodeoffset, 0, &nodedepth);
-	if (err)
-		return (err < 0) ? err : -FDT_ERR_INTERNAL;
-	return nodedepth;
-}
-
-int fdt_parent_offset(const void *fdt, int nodeoffset)
-{
-	int nodedepth = fdt_node_depth(fdt, nodeoffset);
-
-	if (nodedepth < 0)
-		return nodedepth;
-	return fdt_supernode_atdepth_offset(fdt, nodeoffset,
-					    nodedepth - 1, NULL);
-}
-
-int fdt_node_offset_by_prop_value(const void *fdt, int startoffset,
-				  const char *propname,
-				  const void *propval, int proplen)
-{
-	int offset;
-	const void *val;
-	int len;
-
-	FDT_CHECK_HEADER(fdt);
-
-	/* FIXME: The algorithm here is pretty horrible: we scan each
-	 * property of a node in fdt_getprop(), then if that didn't
-	 * find what we want, we scan over them again making our way
-	 * to the next node.  Still it's the easiest to implement
-	 * approach; performance can come later. */
-	for (offset = fdt_next_node(fdt, startoffset, NULL);
-	     offset >= 0;
-	     offset = fdt_next_node(fdt, offset, NULL)) {
-		val = fdt_getprop(fdt, offset, propname, &len);
-		if (val && (len == proplen)
-		    && (memcmp(val, propval, len) == 0))
-			return offset;
-	}
-
-	return offset; /* error from fdt_next_node() */
-}
-
-int fdt_node_offset_by_phandle(const void *fdt, uint32_t phandle)
-{
-	if ((phandle == 0) || (phandle == -1))
-		return -FDT_ERR_BADPHANDLE;
-	phandle = cpu_to_fdt32(phandle);
-	return fdt_node_offset_by_prop_value(fdt, -1, "linux,phandle",
-					     &phandle, sizeof(phandle));
-}
-
-static int _stringlist_contains(const char *strlist, int listlen, const char *str)
-{
-	int len = strlen(str);
-	const char *p;
-
-	while (listlen >= len) {
-		if (memcmp(str, strlist, len+1) == 0)
-			return 1;
-		p = memchr(strlist, '\0', listlen);
-		if (!p)
-			return 0; /* malformed strlist.. */
-		listlen -= (p-strlist) + 1;
-		strlist = p + 1;
-	}
-	return 0;
-}
-
-int fdt_node_check_compatible(const void *fdt, int nodeoffset,
-			      const char *compatible)
-{
-	const void *prop;
-	int len;
-
-	prop = fdt_getprop(fdt, nodeoffset, "compatible", &len);
-	if (!prop)
-		return len;
-	if (_stringlist_contains(prop, len, compatible))
-		return 0;
-	else
-		return 1;
-}
-
-int fdt_node_offset_by_compatible(const void *fdt, int startoffset,
-				  const char *compatible)
-{
-	int offset, err;
-
-	FDT_CHECK_HEADER(fdt);
-
-	/* FIXME: The algorithm here is pretty horrible: we scan each
-	 * property of a node in fdt_node_check_compatible(), then if
-	 * that didn't find what we want, we scan over them again
-	 * making our way to the next node.  Still it's the easiest to
-	 * implement approach; performance can come later. */
-	for (offset = fdt_next_node(fdt, startoffset, NULL);
-	     offset >= 0;
-	     offset = fdt_next_node(fdt, offset, NULL)) {
-		err = fdt_node_check_compatible(fdt, offset, compatible);
-		if ((err < 0) && (err != -FDT_ERR_NOTFOUND))
-			return err;
-		else if (err == 0)
-			return offset;
-	}
-
-	return offset; /* error from fdt_next_node() */
-}
diff --git a/drivers/misc/netlogic/linux-loader/fdt_rw.c b/drivers/misc/netlogic/linux-loader/fdt_rw.c
deleted file mode 100644
index 3b1b1c7..0000000
--- a/drivers/misc/netlogic/linux-loader/fdt_rw.c
+++ /dev/null
@@ -1,474 +0,0 @@
-/*
- * libfdt - Flat Device Tree manipulation
- * Copyright (C) 2006 David Gibson, IBM Corporation.
- *
- * libfdt is dual licensed: you can use it either under the terms of
- * the GPL, or the BSD license, at your option.
- *
- *  a) This library is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This library is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- *     You should have received a copy of the GNU General Public
- *     License along with this library; if not, write to the Free
- *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
- *     MA 02110-1301 USA
- *
- * Alternatively,
- *
- *  b) Redistribution and use in source and binary forms, with or
- *     without modification, are permitted provided that the following
- *     conditions are met:
- *
- *     1. Redistributions of source code must retain the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer.
- *     2. Redistributions in binary form must reproduce the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *
- *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
- *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
- *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
- *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#include "libfdt_env.h"
-
-#include <fdt.h>
-#include <libfdt.h>
-
-#include "libfdt_internal.h"
-
-static int _fdt_blocks_misordered(const void *fdt,
-			      int mem_rsv_size, int struct_size)
-{
-	return (fdt_off_mem_rsvmap(fdt) < FDT_ALIGN(sizeof(struct fdt_header), 8))
-		|| (fdt_off_dt_struct(fdt) <
-		    (fdt_off_mem_rsvmap(fdt) + mem_rsv_size))
-		|| (fdt_off_dt_strings(fdt) <
-		    (fdt_off_dt_struct(fdt) + struct_size))
-		|| (fdt_totalsize(fdt) <
-		    (fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt)));
-}
-
-static int _fdt_rw_check_header(void *fdt)
-{
-	FDT_CHECK_HEADER(fdt);
-
-	if (fdt_version(fdt) < 17)
-		return -FDT_ERR_BADVERSION;
-	if (_fdt_blocks_misordered(fdt, sizeof(struct fdt_reserve_entry),
-				   fdt_size_dt_struct(fdt)))
-		return -FDT_ERR_BADLAYOUT;
-	if (fdt_version(fdt) > 17)
-		fdt_set_version(fdt, 17);
-
-	return 0;
-}
-
-#define FDT_RW_CHECK_HEADER(fdt) \
-	{ \
-		int err; \
-		if ((err = _fdt_rw_check_header(fdt)) != 0) \
-			return err; \
-	}
-
-static inline int _fdt_data_size(void *fdt)
-{
-	return fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
-}
-
-static int _fdt_splice(void *fdt, void *splicepoint, int oldlen, int newlen)
-{
-	char *p = splicepoint;
-	char *end = (char *)fdt + _fdt_data_size(fdt);
-
-	if (((p + oldlen) < p) || ((p + oldlen) > end))
-		return -FDT_ERR_BADOFFSET;
-	if ((end - oldlen + newlen) > ((char *)fdt + fdt_totalsize(fdt)))
-		return -FDT_ERR_NOSPACE;
-	memmove(p + newlen, p + oldlen, end - p - oldlen);
-	return 0;
-}
-
-static int _fdt_splice_mem_rsv(void *fdt, struct fdt_reserve_entry *p,
-			       int oldn, int newn)
-{
-	int delta = (newn - oldn) * sizeof(*p);
-	int err;
-	err = _fdt_splice(fdt, p, oldn * sizeof(*p), newn * sizeof(*p));
-	if (err)
-		return err;
-	fdt_set_off_dt_struct(fdt, fdt_off_dt_struct(fdt) + delta);
-	fdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);
-	return 0;
-}
-
-static int _fdt_splice_struct(void *fdt, void *p,
-			      int oldlen, int newlen)
-{
-	int delta = newlen - oldlen;
-	int err;
-
-	if ((err = _fdt_splice(fdt, p, oldlen, newlen)))
-		return err;
-
-	fdt_set_size_dt_struct(fdt, fdt_size_dt_struct(fdt) + delta);
-	fdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);
-	return 0;
-}
-
-static int _fdt_splice_string(void *fdt, int newlen)
-{
-	void *p = (char *)fdt
-		+ fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
-	int err;
-
-	if ((err = _fdt_splice(fdt, p, 0, newlen)))
-		return err;
-
-	fdt_set_size_dt_strings(fdt, fdt_size_dt_strings(fdt) + newlen);
-	return 0;
-}
-
-static int _fdt_find_add_string(void *fdt, const char *s)
-{
-	char *strtab = (char *)fdt + fdt_off_dt_strings(fdt);
-	const char *p;
-	char *new;
-	int len = strlen(s) + 1;
-	int err;
-
-	p = _fdt_find_string(strtab, fdt_size_dt_strings(fdt), s);
-	if (p)
-		/* found it */
-		return (p - strtab);
-
-	new = strtab + fdt_size_dt_strings(fdt);
-	err = _fdt_splice_string(fdt, len);
-	if (err)
-		return err;
-
-	memcpy(new, s, len);
-	return (new - strtab);
-}
-
-int fdt_add_mem_rsv(void *fdt, uint64_t address, uint64_t size)
-{
-	struct fdt_reserve_entry *re;
-	int err;
-
-	FDT_RW_CHECK_HEADER(fdt);
-
-	re = _fdt_mem_rsv_w(fdt, fdt_num_mem_rsv(fdt));
-	err = _fdt_splice_mem_rsv(fdt, re, 0, 1);
-	if (err)
-		return err;
-
-	re->address = cpu_to_fdt64(address);
-	re->size = cpu_to_fdt64(size);
-	return 0;
-}
-
-int fdt_del_mem_rsv(void *fdt, int n)
-{
-	struct fdt_reserve_entry *re = _fdt_mem_rsv_w(fdt, n);
-	int err;
-
-	FDT_RW_CHECK_HEADER(fdt);
-
-	if (n >= fdt_num_mem_rsv(fdt))
-		return -FDT_ERR_NOTFOUND;
-
-	err = _fdt_splice_mem_rsv(fdt, re, 1, 0);
-	if (err)
-		return err;
-	return 0;
-}
-
-static int _fdt_resize_property(void *fdt, int nodeoffset, const char *name,
-				int len, struct fdt_property **prop)
-{
-	int oldlen;
-	int err;
-
-	*prop = fdt_get_property_w(fdt, nodeoffset, name, &oldlen);
-	if (! (*prop))
-		return oldlen;
-
-	if ((err = _fdt_splice_struct(fdt, (*prop)->data, FDT_TAGALIGN(oldlen),
-				      FDT_TAGALIGN(len))))
-		return err;
-
-	(*prop)->len = cpu_to_fdt32(len);
-	return 0;
-}
-
-static int _fdt_add_property(void *fdt, int nodeoffset, const char *name,
-			     int len, struct fdt_property **prop)
-{
-	int proplen;
-	int nextoffset;
-	int namestroff;
-	int err;
-
-	if ((nextoffset = _fdt_check_node_offset(fdt, nodeoffset)) < 0)
-		return nextoffset;
-
-	namestroff = _fdt_find_add_string(fdt, name);
-	if (namestroff < 0)
-		return namestroff;
-
-	*prop = _fdt_offset_ptr_w(fdt, nextoffset);
-	proplen = sizeof(**prop) + FDT_TAGALIGN(len);
-
-	err = _fdt_splice_struct(fdt, *prop, 0, proplen);
-	if (err)
-		return err;
-
-	(*prop)->tag = cpu_to_fdt32(FDT_PROP);
-	(*prop)->nameoff = cpu_to_fdt32(namestroff);
-	(*prop)->len = cpu_to_fdt32(len);
-	return 0;
-}
-
-int fdt_set_name(void *fdt, int nodeoffset, const char *name)
-{
-	char *namep;
-	int oldlen, newlen;
-	int err;
-
-	FDT_RW_CHECK_HEADER(fdt);
-
-	namep = (char *)(uintptr_t)fdt_get_name(fdt, nodeoffset, &oldlen);
-	if (!namep)
-		return oldlen;
-
-	newlen = strlen(name);
-
-	err = _fdt_splice_struct(fdt, namep, FDT_TAGALIGN(oldlen+1),
-				 FDT_TAGALIGN(newlen+1));
-	if (err)
-		return err;
-
-	memcpy(namep, name, newlen+1);
-	return 0;
-}
-
-int fdt_setprop(void *fdt, int nodeoffset, const char *name,
-		const void *val, int len)
-{
-	struct fdt_property *prop;
-	int err;
-
-	FDT_RW_CHECK_HEADER(fdt);
-
-	err = _fdt_resize_property(fdt, nodeoffset, name, len, &prop);
-	if (err == -FDT_ERR_NOTFOUND)
-		err = _fdt_add_property(fdt, nodeoffset, name, len, &prop);
-	if (err)
-		return err;
-
-	memcpy(prop->data, val, len);
-	return 0;
-}
-
-int fdt_delprop(void *fdt, int nodeoffset, const char *name)
-{
-	struct fdt_property *prop;
-	int len, proplen;
-
-	FDT_RW_CHECK_HEADER(fdt);
-
-	prop = fdt_get_property_w(fdt, nodeoffset, name, &len);
-	if (! prop)
-		return len;
-
-	proplen = sizeof(*prop) + FDT_TAGALIGN(len);
-	return _fdt_splice_struct(fdt, prop, proplen, 0);
-}
-
-int fdt_add_subnode_namelen(void *fdt, int parentoffset,
-			    const char *name, int namelen)
-{
-	struct fdt_node_header *nh;
-	int offset, nextoffset;
-	int nodelen;
-	int err;
-	uint32_t tag;
-	uint32_t *endtag;
-
-	FDT_RW_CHECK_HEADER(fdt);
-
-	offset = fdt_subnode_offset_namelen(fdt, parentoffset, name, namelen);
-	if (offset >= 0)
-		return -FDT_ERR_EXISTS;
-	else if (offset != -FDT_ERR_NOTFOUND)
-		return offset;
-
-	/* Try to place the new node after the parent's properties */
-	fdt_next_tag(fdt, parentoffset, &nextoffset); /* skip the BEGIN_NODE */
-	do {
-		offset = nextoffset;
-		tag = fdt_next_tag(fdt, offset, &nextoffset);
-	} while ((tag == FDT_PROP) || (tag == FDT_NOP));
-
-	nh = _fdt_offset_ptr_w(fdt, offset);
-	nodelen = sizeof(*nh) + FDT_TAGALIGN(namelen+1) + FDT_TAGSIZE;
-
-	err = _fdt_splice_struct(fdt, nh, 0, nodelen);
-	if (err)
-		return err;
-
-	nh->tag = cpu_to_fdt32(FDT_BEGIN_NODE);
-	memset(nh->name, 0, FDT_TAGALIGN(namelen+1));
-	memcpy(nh->name, name, namelen);
-	endtag = (uint32_t *)((char *)nh + nodelen - FDT_TAGSIZE);
-	*endtag = cpu_to_fdt32(FDT_END_NODE);
-
-	return offset;
-}
-
-int fdt_add_subnode(void *fdt, int parentoffset, const char *name)
-{
-	return fdt_add_subnode_namelen(fdt, parentoffset, name, strlen(name));
-}
-
-int fdt_del_node(void *fdt, int nodeoffset)
-{
-	int endoffset;
-
-	FDT_RW_CHECK_HEADER(fdt);
-
-	endoffset = _fdt_node_end_offset(fdt, nodeoffset);
-	if (endoffset < 0)
-		return endoffset;
-
-	return _fdt_splice_struct(fdt, _fdt_offset_ptr_w(fdt, nodeoffset),
-				  endoffset - nodeoffset, 0);
-}
-
-static void _fdt_packblocks(const char *old, char *new,
-			    int mem_rsv_size, int struct_size)
-{
-	int mem_rsv_off, struct_off, strings_off;
-
-	mem_rsv_off = FDT_ALIGN(sizeof(struct fdt_header), 8);
-	struct_off = mem_rsv_off + mem_rsv_size;
-	strings_off = struct_off + struct_size;
-
-	memmove(new + mem_rsv_off, old + fdt_off_mem_rsvmap(old), mem_rsv_size);
-	fdt_set_off_mem_rsvmap(new, mem_rsv_off);
-
-	memmove(new + struct_off, old + fdt_off_dt_struct(old), struct_size);
-	fdt_set_off_dt_struct(new, struct_off);
-	fdt_set_size_dt_struct(new, struct_size);
-
-	memmove(new + strings_off, old + fdt_off_dt_strings(old),
-		fdt_size_dt_strings(old));
-	fdt_set_off_dt_strings(new, strings_off);
-	fdt_set_size_dt_strings(new, fdt_size_dt_strings(old));
-}
-
-int fdt_open_into(const void *fdt, void *buf, int bufsize)
-{
-	int err;
-	int mem_rsv_size, struct_size;
-	int newsize;
-	const char *fdtstart = fdt;
-	const char *fdtend = fdtstart + fdt_totalsize(fdt);
-	char *tmp;
-
-	FDT_CHECK_HEADER(fdt);
-
-	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
-		* sizeof(struct fdt_reserve_entry);
-	
-	__asm__ __volatile__ (
-			"sync\n"
-			"nop\n"
-			"nop\n"
-			"nop\n"
-			"nop\n"
-			"nop\n"
-			"nop\n"
-			"nop\n"
-			"sync\n");
-
-	if (fdt_version(fdt) >= 17) {
-		struct_size = fdt_size_dt_struct(fdt);
-	} else {
-		struct_size = 0;
-		while (fdt_next_tag(fdt, struct_size, &struct_size) != FDT_END)
-			;
-	}
-
-	if (!_fdt_blocks_misordered(fdt, mem_rsv_size, struct_size)) {
-		/* no further work necessary */
-		err = fdt_move(fdt, buf, bufsize);
-		if (err)
-			return err;
-		fdt_set_version(buf, 17);
-		fdt_set_size_dt_struct(buf, struct_size);
-		fdt_set_totalsize(buf, bufsize);
-		return 0;
-	}
-
-	/* Need to reorder */
-	newsize = FDT_ALIGN(sizeof(struct fdt_header), 8) + mem_rsv_size
-		+ struct_size + fdt_size_dt_strings(fdt);
-
-	if (bufsize < newsize)
-		return -FDT_ERR_NOSPACE;
-
-	/* First attempt to build converted tree at beginning of buffer */
-	tmp = buf;
-	/* But if that overlaps with the old tree... */
-	if (((tmp + newsize) > fdtstart) && (tmp < fdtend)) {
-		/* Try right after the old tree instead */
-		tmp = (char *)(uintptr_t)fdtend;
-		if ((tmp + newsize) > ((char *)buf + bufsize))
-			return -FDT_ERR_NOSPACE;
-	}
-
-	_fdt_packblocks(fdt, tmp, mem_rsv_size, struct_size);
-	memmove(buf, tmp, newsize);
-
-	fdt_set_magic(buf, FDT_MAGIC);
-	fdt_set_totalsize(buf, bufsize);
-	fdt_set_version(buf, 17);
-	fdt_set_last_comp_version(buf, 16);
-	fdt_set_boot_cpuid_phys(buf, fdt_boot_cpuid_phys(fdt));
-
-	return 0;
-}
-
-int fdt_pack(void *fdt)
-{
-	int mem_rsv_size;
-
-	FDT_RW_CHECK_HEADER(fdt);
-
-	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
-		* sizeof(struct fdt_reserve_entry);
-	_fdt_packblocks(fdt, fdt, mem_rsv_size, fdt_size_dt_struct(fdt));
-	fdt_set_totalsize(fdt, _fdt_data_size(fdt));
-
-	return 0;
-}
diff --git a/drivers/misc/netlogic/linux-loader/fdt_wip.c b/drivers/misc/netlogic/linux-loader/fdt_wip.c
deleted file mode 100644
index a4652c6..0000000
--- a/drivers/misc/netlogic/linux-loader/fdt_wip.c
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * libfdt - Flat Device Tree manipulation
- * Copyright (C) 2006 David Gibson, IBM Corporation.
- *
- * libfdt is dual licensed: you can use it either under the terms of
- * the GPL, or the BSD license, at your option.
- *
- *  a) This library is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This library is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- *     You should have received a copy of the GNU General Public
- *     License along with this library; if not, write to the Free
- *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
- *     MA 02110-1301 USA
- *
- * Alternatively,
- *
- *  b) Redistribution and use in source and binary forms, with or
- *     without modification, are permitted provided that the following
- *     conditions are met:
- *
- *     1. Redistributions of source code must retain the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer.
- *     2. Redistributions in binary form must reproduce the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *
- *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
- *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
- *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
- *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#include "libfdt_env.h"
-
-#include <fdt.h>
-#include <libfdt.h>
-
-#include "libfdt_internal.h"
-
-int fdt_setprop_inplace(void *fdt, int nodeoffset, const char *name,
-			const void *val, int len)
-{
-	void *propval;
-	int proplen;
-
-	propval = fdt_getprop_w(fdt, nodeoffset, name, &proplen);
-	if (! propval)
-		return proplen;
-
-	if (proplen != len)
-		return -FDT_ERR_NOSPACE;
-
-	memcpy(propval, val, len);
-	return 0;
-}
-
-static void _fdt_nop_region(void *start, int len)
-{
-	uint32_t *p;
-
-	for (p = start; (char *)p < ((char *)start + len); p++)
-		*p = cpu_to_fdt32(FDT_NOP);
-}
-
-int fdt_nop_property(void *fdt, int nodeoffset, const char *name)
-{
-	struct fdt_property *prop;
-	int len;
-
-	prop = fdt_get_property_w(fdt, nodeoffset, name, &len);
-	if (! prop)
-		return len;
-
-	_fdt_nop_region(prop, len + sizeof(*prop));
-
-	return 0;
-}
-
-int _fdt_node_end_offset(void *fdt, int nodeoffset)
-{
-	int level = 0;
-	uint32_t tag;
-	int offset, nextoffset;
-
-	tag = fdt_next_tag(fdt, nodeoffset, &nextoffset);
-	if (tag != FDT_BEGIN_NODE)
-		return -FDT_ERR_BADOFFSET;
-	do {
-		offset = nextoffset;
-		tag = fdt_next_tag(fdt, offset, &nextoffset);
-
-		switch (tag) {
-		case FDT_END:
-			return offset;
-
-		case FDT_BEGIN_NODE:
-			level++;
-			break;
-
-		case FDT_END_NODE:
-			level--;
-			break;
-
-		case FDT_PROP:
-		case FDT_NOP:
-			break;
-
-		default:
-			return -FDT_ERR_BADSTRUCTURE;
-		}
-	} while (level >= 0);
-
-	return nextoffset;
-}
-
-int fdt_nop_node(void *fdt, int nodeoffset)
-{
-	int endoffset;
-
-	endoffset = _fdt_node_end_offset(fdt, nodeoffset);
-	if (endoffset < 0)
-		return endoffset;
-
-	_fdt_nop_region(fdt_offset_ptr_w(fdt, nodeoffset, 0),
-			endoffset - nodeoffset);
-	return 0;
-}
diff --git a/drivers/misc/netlogic/linux-loader/fifo.h b/drivers/misc/netlogic/linux-loader/fifo.h
deleted file mode 100644
index c762052..0000000
--- a/drivers/misc/netlogic/linux-loader/fifo.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_2# */
-
-
-#ifndef _FIFO_H
-#define _FIFO_H
-
-#define FIFO_SIZE 32
-
-struct fifo {
-	int data[FIFO_SIZE];
-	int size;
-	int head;
-	int tail;
-};
-
-static __inline__ int fifo_next_head(struct fifo *fifo)
-{
-	return (fifo->head + 1) % fifo->size;
-}
-
-static __inline__ int fifo_next_tail(struct fifo *fifo)
-{
-	return (fifo->tail + 1) % fifo->size;
-}
-
-static __inline__ int fifo_empty(struct fifo *fifo)
-{
-	return fifo->head == fifo->tail ? 1 : 0;
-}
-
-static __inline__ int fifo_full(struct fifo *fifo)
-{
-	return fifo_next_tail(fifo) == fifo->head ? 1 : 0;
-}
-
-static __inline__ int fifo_size(struct fifo *fifo)
-{
-	if (fifo->head <= fifo->tail)
-		return fifo->tail - fifo->head;
-	else
-		return (fifo->size - fifo->head) + (fifo->tail - 0);
-}
-
-static __inline__ int fifo_dequeue(struct fifo *fifo, int *data)
-{
-	if (fifo_empty(fifo))
-		return 0;
-	*data = (fifo->data)[fifo->head];
-	fifo->head = fifo_next_head(fifo);
-	return 1;
-}
-
-static __inline__ int fifo_enqueue(struct fifo *fifo, int data)
-{
-	if (fifo_full(fifo))
-		return 0;
-	fifo->data[fifo->tail] = data;
-	fifo->tail = fifo_next_tail(fifo);
-	return 1;
-}
-
-static __inline__ void fifo_init(struct fifo *f)
-{
-	f->head = f->tail = 0;
-	f->size = FIFO_SIZE;
-}
-
-#endif
diff --git a/drivers/misc/netlogic/linux-loader/libfdt-wrapper.c b/drivers/misc/netlogic/linux-loader/libfdt-wrapper.c
deleted file mode 100644
index 0ed262a..0000000
--- a/drivers/misc/netlogic/linux-loader/libfdt-wrapper.c
+++ /dev/null
@@ -1,228 +0,0 @@
-/*
- * This file does the necessary interface mapping between the bootwrapper
- * device tree operations and the interface provided by shared source
- * files flatdevicetree.[ch].
- *
- * Copyright 2007 David Gibson, IBM Corporation.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-
-#include <stddef.h>
-#include <stdio.h>
-#include <page.h>
-#include <libfdt.h>
-#include "ops.h"
-
-#if 0
-(BAD_ERROR(err) || ((err < 0) && DEBUG)) 
-	printf("%s():%d  %s\n\r", __func__, __LINE__, fdt_strerror(err)); 
-#endif
-
-#define min(x,y) ({ \
-		typeof(x) _x = (x); \
-		typeof(y) _y = (y); \
-		(void) (&_x == &_y);    \
-		_x < _y ? _x : _y; })
-
-
-#define DEBUG	0
-#define BAD_ERROR(err)	(((err) < 0) \
-			 && ((err) != -FDT_ERR_NOTFOUND) \
-			 && ((err) != -FDT_ERR_EXISTS))
-
-#define check_err(err) \
-	({ \
-		if (BAD_ERROR(err)) \
-			exit(); \
-		(err < 0) ? -1 : 0; \
-	})
-
-#define offset_devp(off)	\
-	({ \
-		int _offset = (off); \
-		check_err(_offset) ? NULL : (void *)(unsigned long)(_offset+1); \
-	})
-
-#define devp_offset_find(devp)	(((int)(unsigned long)(devp))-1)
-#define devp_offset(devp)	(devp ? ((int)(unsigned long)(devp))-1 : 0)
-
-void *fdt;
-static void *buf; /* = NULL */
-
-#define EXPAND_GRANULARITY	1024
-
-struct platform_ops platform_ops;
-struct dt_ops dt_ops;
-
-
-static void expand_buf(int minexpand)
-{
-	int size = fdt_totalsize(fdt);
-	int rc;
-
-	size = _ALIGN(size + minexpand, EXPAND_GRANULARITY);
-	buf = platform_ops.realloc(buf, size);
-	rc = fdt_open_into(fdt, buf, size);
-	fdt = buf;
-}
-
-static void *fdt_wrapper_finddevice(const char *path)
-{
-	return offset_devp(fdt_path_offset(fdt, path));
-}
-
-static int fdt_wrapper_getprop(const void *devp, const char *name,
-			       void *buf, const int buflen)
-{
-	const void *p;
-	int len;
-
-	p = fdt_getprop(fdt, devp_offset(devp), name, &len);
-	if (!p)
-		return check_err(len);
-	memcpy(buf, p, min(len, buflen));
-	return len;
-}
-
-static int fdt_wrapper_setprop(const void *devp, const char *name,
-			       const void *buf, const int len)
-{
-	int rc;
-
-	rc = fdt_setprop(fdt, devp_offset(devp), name, buf, len);
-	if (rc == -FDT_ERR_NOSPACE) {
-		expand_buf(len + 16);
-		rc = fdt_setprop(fdt, devp_offset(devp), name, buf, len);
-	}
-
-	return check_err(rc);
-}
-
-static int fdt_wrapper_del_node(const void *devp)
-{
-	return fdt_del_node(fdt, devp_offset(devp));
-}
-
-static void *fdt_wrapper_get_parent(const void *devp)
-{
-	return offset_devp(fdt_parent_offset(fdt, devp_offset(devp)));
-}
-
-static void *fdt_wrapper_create_node(const void *devp, const char *name)
-{
-	int offset;
-
-	offset = fdt_add_subnode(fdt, devp_offset(devp), name);
-	if (offset == -FDT_ERR_NOSPACE) {
-		expand_buf(strlen(name) + 16);
-		offset = fdt_add_subnode(fdt, devp_offset(devp), name);
-	}
-
-	return offset_devp(offset);
-}
-
-static void *fdt_wrapper_find_node_by_prop_value(const void *prev,
-						 const char *name,
-						 const char *val,
-						 int len)
-{
-	int offset = fdt_node_offset_by_prop_value(fdt, devp_offset_find(prev),
-	                                           name, val, len);
-	return offset_devp(offset);
-}
-
-static void *fdt_wrapper_find_node_by_compatible(const void *prev,
-						 const char *val)
-{
-	int offset = fdt_node_offset_by_compatible(fdt, devp_offset_find(prev),
-	                                           val);
-	return offset_devp(offset);
-}
-
-static char *fdt_wrapper_get_path(const void *devp, char *buf, int len)
-{
-	int rc;
-
-	rc = fdt_get_path(fdt, devp_offset(devp), buf, len);
-	if (check_err(rc))
-		return NULL;
-	return buf;
-}
-
-static unsigned long fdt_wrapper_finalize(void)
-{
-	int rc;
-
-	rc = fdt_pack(fdt);
-#if 0
-	if (rc != 0)
-		fatal("Couldn't pack flat tree: %s\n\r",
-		      fdt_strerror(rc));
-#endif
-	return (unsigned long)fdt;
-}
-
-static int fdt_wrapper_check_header(void)
-{
-	int err;
-
-	if ((err = fdt_check_header(fdt)) != 0)
-		return err;
-
-	return 0;
-}
-
-void *fdt_init(void *blob)
-{
-	dt_ops.finddevice = fdt_wrapper_finddevice;
-	dt_ops.getprop = fdt_wrapper_getprop;
-	dt_ops.setprop = fdt_wrapper_setprop;
-	dt_ops.get_parent = fdt_wrapper_get_parent;
-	dt_ops.create_node = fdt_wrapper_create_node;
-	dt_ops.find_node_by_prop_value = fdt_wrapper_find_node_by_prop_value;
-	dt_ops.find_node_by_compatible = fdt_wrapper_find_node_by_compatible;
-	dt_ops.del_node = fdt_wrapper_del_node;
-	dt_ops.get_path = fdt_wrapper_get_path;
-	dt_ops.finalize = fdt_wrapper_finalize;
-	dt_ops.check_header = fdt_wrapper_check_header;
-
-	/* Make sure the dt blob is the right version and so forth */
-	fdt = blob;
-
-	/* Don't use local copy as Kernel claims this memory after mem init
-	 * As a result, FDT can not be parsed in kernel modules
-	 */
-#ifdef USE_LOCAL_FDT_COPY
-	{
-		int err;
-		int bufsize;
-
-		bufsize = fdt_totalsize(fdt) + EXPAND_GRANULARITY;
-		buf = malloc(bufsize);
-		//if(!buf)
-		//	fatal("malloc failed. can't relocate the device tree\n\r");
-
-		err = fdt_open_into(fdt, buf, bufsize);
-
-		//if (err != 0)
-		//	fatal("fdt_init(): %s\n\r", fdt_strerror(err));
-
-		fdt = buf;
-	}
-#endif
-	return fdt;
-}
diff --git a/drivers/misc/netlogic/linux-loader/libfdt_env.h b/drivers/misc/netlogic/linux-loader/libfdt_env.h
deleted file mode 100644
index 81e41bf..0000000
--- a/drivers/misc/netlogic/linux-loader/libfdt_env.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * #BRCM_2# */
-#ifndef _ARCH_MIPS_BOOT_LIBFDT_ENV_H
-#define _ARCH_MIPS_BOOT_LIBFDT_ENV_H
-
-#include <linux/types.h>
-#include <string.h>
-
-#define _B(n)	((unsigned long long)((uint8_t *)&x)[n])
-static inline uint32_t fdt32_to_cpu(uint32_t x)
-{
-	return (_B(0) << 24) | (_B(1) << 16) | (_B(2) << 8) | _B(3);
-}
-#define cpu_to_fdt32(x) fdt32_to_cpu(x)
-
-static inline uint64_t fdt64_to_cpu(uint64_t x)
-{
-	return (_B(0) << 56) | (_B(1) << 48) | (_B(2) << 40) | (_B(3) << 32)
-		| (_B(4) << 24) | (_B(5) << 16) | (_B(6) << 8) | _B(7);
-}
-#define cpu_to_fdt64(x) fdt64_to_cpu(x)
-#undef _B
-
-#endif /* _ARCH_MIPS_BOOT_LIBFDT_ENV_H */
diff --git a/drivers/misc/netlogic/linux-loader/loader.c b/drivers/misc/netlogic/linux-loader/loader.c
deleted file mode 100644
index c7f5dec..0000000
--- a/drivers/misc/netlogic/linux-loader/loader.c
+++ /dev/null
@@ -1,913 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_2# */
-
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/smp.h>
-#include <linux/interrupt.h>
-
-#include <asm/cpu-info.h>
-#include <asm/mipsregs.h>
-#include <asm/mmu_context.h>
-#include <asm/atomic.h>
-#include <asm/netlogic/cpumask.h>
-#include <asm/netlogic/xlp.h>
-//#include <asm/rmi/msgring.h>
-//#include <asm/rmi/mips-exts.h>
-#include <asm/bootinfo.h>
-#include <asm/asm.h>
-#include <asm/mipsregs.h>
-//#include <asm/rmi/phnx_loader.h>
-#include "phnx_loader.h"
-#include "xlr_boot_lib.h"
-#include "ops.h"
-#include "libfdt_env.h"
-#include <asm/mach-netlogic/xlp-mmu.h>
-#include <asm/cacheops.h>
-#include <asm/r4kcache.h>
-
-#define GPIO_SWRESET_REG           	(8)
-#define GENERIC_LOCK_SIZE          	(16)
-#define Message(a,b...)            	//printk("[%s@%d] "a"\n",__FUNCTION__,__LINE__,##b)
-#define ErrorMsg(a,b...)           	xlr_loader_print(a,##b)
-
-#define cacheop(op, base)          	__asm__ __volatile__ (".set push\n.set mips4\ncache %0, 0(%1)\n.set pop\n" : : "i"(op), "r"(base))
-
-#define MAX_CPUMASK_CELLS 		4
-#define fdt32_to_cpu(x) 		be32_to_cpu(x)
-
-/* Global */
-struct xlr_vcpu_wakeup_info	*xlr_wakeup_info;
-struct xlr_lib_launch_import	*xlr_launch; /*Setup this structure and pass it to lib_launch_init. */
-struct xlr_lib_load_import	*xlr_load;
-struct loader_mem_info 		loader_mem_map[MAX_NUM_LOADER_MEM_BLK];
-struct psb_mem_map 		xlr_loader_mem_map;
-unsigned char *xlr_lib_shmem_start  = NULL;
-uint32_t xlr_lib_shmem_size = 0;
-volatile int xlr_wakeup_ipi[XLR_NUM_CPU];
-cpumask_t fdt_loadermask;
-int xlp_loader_support;
-
-/* Static */
-static unsigned char printk_lock[GENERIC_LOCK_SIZE];
-static unsigned char loader_lock[GENERIC_LOCK_SIZE];
-static unsigned int global_wakeup_mask;
-static unsigned int icache_lines;
-static unsigned int icache_linesz;
-static unsigned int dcache_lines;
-static unsigned int dcache_linesz;
-
-/* Extern */
-extern unsigned long fw_arg0; //from linux: exported from setup.c.
-extern int xlp_loader_support;
-extern void xlr_lib_entry(unsigned long args);
-
-
-void reload_trap_init(void) {}
-int xlr_loader_print(const char *fmt, ...) 
-{
-	return 0;
-}
-
-int fdt_process(void)
-{
-	int  domain=0;
-	char domstr[32] = "";
-	uint32_t  i, na, ns, regs[16], entries, cpu_cells = 0;
-	int index = 0;
- 	uint32_t linux_loader_mask[MAX_CPUMASK_CELLS] = {0};
-
-	/* If booted using FDT and U-Boot, all
-	 * we get is a pointer to an FDT Blob
-	 */
-	void *blob = (void *)fw_arg0;
-	void *node, *fdt;
-
-	//cpumask_clear(&fdt_cpumask);
-	cpumask_clear(&fdt_loadermask);
-
-	if(!blob)
-		return -1;
-
-	/* Create a local copy of the FDT
-	 */
-	fdt = fdt_init(blob);
-	if(!fdt)
-		return -1;
-	Message("Cached handle for FDT @ 0x%p", fdt);
-
-	/* extract memory ranges,
-	 * add to command line
-	 */
-	node = finddevice("/doms/dom@0");
-	if (node) {
-		if (getprop(node, "#address-cells", &na, sizeof(na)) < 0)
-			na = 1;
-		else
-			na = fdt32_to_cpu(na);
-		if (na < 1 || na > 2)
-			printk("Can't cope with #address-cells == %d.\n\r", na);
-
-		if (getprop(node, "#size-cells", &ns, sizeof(ns)) < 0)
-			ns = 1;
-		else
-			ns = fdt32_to_cpu(ns);
-		if (ns < 1 || ns > 2)
-			printk("Can't cope with #size-cells == %d.\n\r", ns);
-
-		if (getprop(node, "#cpumask-cells", &cpu_cells, sizeof(cpu_cells)) < 0)
-			cpu_cells = 1;
-		else
-			cpu_cells = fdt32_to_cpu(cpu_cells);
-
-		if (cpu_cells < 1 || cpu_cells > MAX_CPUMASK_CELLS)
-			printk("Can't cope with #cpumask-cells == %d\n\r", cpu_cells);
-	}
-#if 0
-	node = finddevice("/doms/dom@0/memory");
-	if (node) {
-		entries = (getprop(node, "reg", regs, sizeof(regs))) / sizeof(regs[0]);
-		if (!entries || (entries % (na+ns)))
-			printk("Invalid Memory Map Specified!\n");
-
-		for (i=0; i<entries; i+=2) {
-			unsigned long long addr, size;
-
-			addr = fdt32_to_cpu(regs[i]);
-			size = fdt32_to_cpu(regs[i + 1]);
-
-			sprintf(domstr, " mem=%lldm@%lldm ", (size >> 20), (addr >> 20));
-			strcat(arcs_cmdline, domstr);
-			memset((void *)&domstr, '\0', sizeof(domstr));
-		}
-	}
-
-	printk("FDT Cmdline: %s\n", arcs_cmdline);
-
-
-	/
-	 * extract CPU online mask for domain 0 (linux)
-	 */
-	for (i = 0; i < MAX_CPUMASK_CELLS; i++)
-		onlinemask[i] = 0;
-
-	sprintf(domstr, "/doms/dom@%d/cpu", domain);
-
-	node = finddevice(domstr);
-	if (node) {
-		uint32_t onlinemask_buf[MAX_CPUMASK_CELLS];
-
-		char buf[CPUMASK_BUF];
-
-		/* Initialize buffers */
-		for (i = 0; i < MAX_CPUMASK_CELLS; i++)
-			onlinemask_buf[i] = 0;
-
-		/* Parse cpumask from FDT and handle endianness */
-		getprop(node, "onlinemask", &onlinemask_buf[0], sizeof(uint32_t) * cpu_cells);
-
-		for (i = 0; i < cpu_cells; i++) {
-			onlinemask_buf[i] = fdt32_to_cpu(onlinemask_buf[i]);
-
-			printk("FDT: cpu_cells: %d onlinemask[%d]: %08x\n",
-			       cpu_cells, i, onlinemask_buf[i]);
-		}
-
-		/* Store cpumask in predefined order */
-		for (i = 0; i < cpu_cells; i++)
-			onlinemask[i] = onlinemask_buf[cpu_cells - 1 - i];
-
-		for (i = 0; i < MAX_CPUMASK_CELLS; i++) {
-			int j = 0;
-
-			for (j = 0; j < 32; j++) {
-				if ((onlinemask[i] & (1 << j)) == 0)
-					continue;
-				cpumask_set_cpu((i * 32 + j), &fdt_cpumask);
-			}
-		}
-
-		cpumask_scnprintf(buf, CPUMASK_BUF, &fdt_cpumask);
-		printk("fdt_cpumask: %s\n", buf);
-	}
-#endif
-	sprintf(domstr, "/doms/dom@%d/linuxloader", domain);
-	node = finddevice(domstr);
-	if (node) {
-		uint32_t loadermask_buf[MAX_CPUMASK_CELLS];
-		char buf[CPUMASK_BUF];
-
-		xlp_loader_support = 1;
-		/* Initialize buffers */
-		for (i = 0; i < MAX_CPUMASK_CELLS; i++)
-			loadermask_buf[i] = 0;
-
-		/* Parse cpumask from FDT and handle endianness */
-		if((getprop(node, "loadermask", &loadermask_buf[0], sizeof(uint32_t) * cpu_cells) < 0)){
-			xlp_loader_support = 0;
-			goto noloadermask;
-		}
-
-		for (i = 0; i < cpu_cells; i++) {
-			loadermask_buf[i] = fdt32_to_cpu(loadermask_buf[i]);
-
-			printk("FDT: cpu_cells: %d loadermask_buf[%d]: %08x\n",
-			       cpu_cells, i, loadermask_buf[i]);
-		}
-
-		/* Store cpumask in predefined order */
-		for (i = 0; i < cpu_cells; i++){
-			linux_loader_mask[i] = loadermask_buf[cpu_cells - 1 - i];
-			printk("linux_loader_mask[%d] = %#x\n",i,linux_loader_mask[i]);
-		}
-
-		for (i = 0; i < MAX_CPUMASK_CELLS; i++) {
-			int j = 0;
-
-			for (j = 0; j < 32; j++) {
-				if ((linux_loader_mask[i] & (1 << j)) == 0)
-					continue;
-				cpumask_set_cpu((i * 32 + j), &fdt_loadermask);
-			}
-		}
-
-		entries = (getprop(node, "memory", regs, sizeof(regs))) / sizeof(regs[0]);
-		if (!entries || (entries % (na+ns))){
-			printk("Invalid Memory Map Specified!\n");
-			xlp_loader_support = 0;
-			goto noloadermask;
-		}
-		for (i=0,index=0; i<entries; i+=4, index++) {
-				unsigned long long lsb_addr, msb_addr, lsb_size, msb_size;
-				msb_addr = fdt32_to_cpu(regs[i]);
-				lsb_addr = fdt32_to_cpu(regs[i + 1]);
-				msb_size = fdt32_to_cpu(regs[i + 2]);
-				lsb_size = fdt32_to_cpu(regs[i + 3]);
-				loader_mem_map[index].start_addr = lsb_addr | (msb_addr << 32);
-				loader_mem_map[index].size  = lsb_size | (msb_size << 32);
-				printk("LoaderMemory [%#llx] @ [%#llx]\n",loader_mem_map[index].size, loader_mem_map[index].start_addr);
-		}
-noloadermask:
-		cpumask_scnprintf(buf, CPUMASK_BUF, &fdt_loadermask);
-		printk("fdt_loadermask: %s\n", buf);
-	}
-#if 0
-	node = finddevice("/doms/dom@0/fmn");
-	if (node) {
-		for (i = 0; i < NLM_MAX_CPU_NODE; i++) {
-			sprintf(buf, "node_%d_vc_mask",i);
-			memset(&node_vc_mask, 0, sizeof(node_vc_mask));
-			if (getprop(node, buf, &node_vc_mask, sizeof(node_vc_mask)) < 0) {
-				/* If no mask is passed, derive it from cpu online mask */
-				if (onlinemask[i]) {
-					for (j = 0; j < NLM_MAX_CPU_PER_NODE; j++, id++) {
-						if (onlinemask[i] & (1 << j))
-							nlm_cpu_vc_mask[id] = 0xf;
-					}
-				}
-			}
-			else {	/* Get vc mask from the fdt */
-				for (j = 0; j < 4; j++) {
-					tmp = fdt32_to_cpu(node_vc_mask[j]);
-					for (k = 0; k < 8; k++) {
-						nlm_cpu_vc_mask[id++] = (tmp >> (k * 4)) & 0xf;
-					}
-				}
-			}
-		}
-	}
-	else {	/* Derive vc mask from cpu online map */
-		for (i = 0; i < NLM_MAX_CPU_NODE; i++) {
-			if (onlinemask[i]) {
-				for (j = 0; j < NLM_MAX_CPU_PER_NODE; j++, id++) {
-					if (onlinemask[i] & (1 << j))
-						nlm_cpu_vc_mask[id] = 0xf;
-				}
-			}
-		}
-	}
-
-	sprintf(domstr, "/doms/dom@%d/uart", domain);
-	node = finddevice(domstr);
-	if (node) {
-		if (getprop(node, "id", &xlp_uart_portid, sizeof(xlp_uart_portid)) < 0)
-			return -1;
-	}
-#endif
-	return 0;
-}
-
-int nlm_get_domain_info(int domain, struct domain_info *dom)
-{
-	char domstr[32];
-	unsigned char app_mode[256];
-	unsigned char app_loadaddr[64];
-	uint32_t onlinemask;
-	void *node;
-
-	app_mode[0] = app_loadaddr[0] = 0;
-
-	sprintf(domstr, "/doms/dom@%d", domain);
-	node = finddevice(domstr);
-	if(!node){
-		printk("Invalid domain..\n");
-		dom->domain = -1;
-		return -1;
-	}
-	//SMP/AMP Mode
-	if (getprop(node, "app-bootcmd", &app_mode[0], 256) < 0){
-		printk("No APP MODE passed!!!\n");
-		dom->domain = -1;
-		return -1;
-	}
-	//Loadaddress
-	if (getprop(node, "app-loadaddr", &app_loadaddr[0], 64) < 0){
-		printk("No APP Loadaddr passed!!!\n");
-		dom->domain = -1;
-		return -1;
-	}
-
-	//Online mask
-	sprintf(domstr, "/doms/dom@%d/cpu", domain);
-	node = finddevice(domstr);
-	if(getprop(node, "onlinemask", &onlinemask, sizeof(uint32_t)) < 0){
-		printk("No online mask passed ...\n");
-		dom->domain = -1;
-		return -1;
-	}
-	onlinemask = fdt32_to_cpu(onlinemask);
-
-	dom->cpumask = onlinemask;
-	dom->mastercpu = ffs(onlinemask) - 1;
-	if(strncmp(app_mode, "smpload", strlen("smpload")) == 0){
-		dom->mode = 1;
-	}else
-		dom->mode = 2;
-	dom->app_addr = simple_strtoul((const char *)app_loadaddr, NULL, 0);
-	dom->fdt_blob = fw_arg0;
-
-	return 0;
-}
-
-static __inline__ void cacheop_hazard(void)
-{
-	pipeline_flush();
-}
-
-static __inline__ void cacheop_sync_istream(void)
-{
-	pipeline_flush();
-}
-
-void xlp_flush_local_icache(void)
-{
-       int i=0;
-       unsigned long base = CKSEG0;
-
-       /* Index Invalidate all the lines and the ways */
-       for(i=0;i<icache_lines;i++) {
-              cacheop(Index_Invalidate_I, base);
-              base += icache_linesz;
-       }
-       cacheop_sync_istream();
-}
-
-void xlp_flush_local_dcache(void)
-{
-       int i=0;
-       unsigned long base = CKSEG0;
-
-       /* Index Invalidate all the lines and the ways */
-       for(i=0;i<dcache_lines;i++) {
-              cacheop(Index_Writeback_Inv_D, base);
-              base += dcache_linesz;
-       }
-       cacheop_hazard();
-}
-#if 0
-void xlr_flush_dcache_all(void)
-{
-	int i = 0;
-	int dcache_lines, dcache_sets, dcache_assoc, dcache_line_size;
-	uint32_t config1;
-	unsigned long base = (unsigned long)CKSEG0;
-
-	config1 = read_c0_config1();
-
-	dcache_sets = 1 << (((config1 >> 13) & 0x7) + 6);
-	dcache_assoc = ((config1 >> 7) & 0x7) + 1;
-	dcache_line_size = 1 << (((config1 >> 10) & 0x7) + 1);
-	dcache_lines = dcache_sets * dcache_assoc;
-
-	for (i = 0; i < dcache_lines; i++) {
-		cache_op(Index_Writeback_Inv_D, base);
-		base += dcache_line_size;
-	}
-}
-void local_flush_icache_all(void)
-{
-	int i = 0;
-	int icache_lines, icache_sets, icache_assoc, icache_line_size;
-	uint32_t config1;
-	unsigned long base = (unsigned long)CKSEG0;
-
-	config1 = read_c0_config1();
-	icache_sets = 1 << (((config1 >> 22) & 0x7) + 6);
-	icache_assoc = ((config1 >> 16) & 0x7) + 1;
-	icache_line_size = 1 << (((config1 >> 19) & 0x7) + 1);
-
-	icache_lines = icache_sets * icache_assoc;
-
-	for (i = 0; i < icache_lines; i++) {
-		cache_op(Index_Invalidate_I, base);
-		base += icache_line_size;
-	}
-}
-#endif
-void phnx_local_flush_tlb_all(void)
-{
-#if 0
-	unsigned long old_ctx;
-	int entry;
-	int tlbsize;
-	unsigned int config1;
-
-	config1 = read_c0_config1();
-	tlbsize = ((config1 >> 25) & 0x3f) + 1;
-
-	/* Save old context and create impossible VPN2 value */
-	old_ctx = (read_c0_entryhi() & 0xff);
-	write_c0_entrylo0(0);
-	write_c0_entrylo1(0);
-	for (entry = 0; entry < tlbsize; entry++) {
-		write_c0_entryhi(((unsigned long)CKSEG0 + (PAGE_SIZE << 1) * entry));
-		write_c0_index(entry);
-		tlb_write_indexed();
-	}
-	write_c0_entryhi(old_ctx);
-#endif
-}
-
-static uint32_t tlb_size_to_page_size(uint32_t size)
-{
-	if (size <= (4 * 1024))
-		return 4 * 1024;
-	if (size <= (16 * 1024))
-		return 16 * 1024;
-	if (size <= (64 * 1024))
-		return 64 * 1024;
-	if (size <= (256 * 1024))
-		return 256 * 1024;
-	if (size <= (1024 * 1024))
-		return 1024 * 1024;
-	if (size <= (4 * 1024 * 1024))
-		return 4 * 1024 * 1024;
-	if (size <= (16 * 1024 * 1024))
-		return 16 * 1024 * 1024;
-	if (size <= (64 * 1024 * 1024))
-		return 64 * 1024 * 1024;
-
-	return 256 * 1024 * 1024;
-}
-
-static uint32_t tlb_size_to_mask(uint32_t size)
-{
-	if (size <= (4 * 1024))
-		return 0x0 << 13;
-	if (size <= (16 * 1024))
-		return 0x03 << 13;
-	if (size <= (64 * 1024))
-		return 0x0f << 13;
-	if (size <= (256 * 1024))
-		return 0x3f << 13;
-	if (size <= (1024 * 1024))
-		return 0xff << 13;
-	if (size <= (4 * 1024 * 1024))
-		return 0x3ff << 13;
-	if (size <= (16 * 1024 * 1024))
-		return 0xfff << 13;
-	if (size <= (64 * 1024 * 1024))
-		return 0x3fff << 13;
-
-	return 0xffff << 13;
-}
-
-
-void phnx_setup_tlb(uint64_t virt, uint64_t phys, int size)
-{
-	uint64_t value = 0;
-	uint64_t attr = (3 << 3) | (1 << 2) | (1 << 1) | (1 << 0);
-	int wired = 0;
-	int page_size = tlb_size_to_page_size(size);
-	int page_mask = tlb_size_to_mask(page_size);
-
-	write_c0_pagemask(page_mask);
-	__write_64bit_c0_register($10, 0, virt);
-
-	value = (((phys & 0xffffffffffULL) >> 12) << 6) | attr;
-	write_c0_entrylo0(value);
-
-	value = ((((phys + page_size) & 0xffffffffffULL) >> 12) << 6) | attr;
-	write_c0_entrylo1(value);
-	wired = read_c0_wired();
-
-	write_c0_index(wired);
-	tlb_write_indexed();
-
-	write_c0_wired(wired + 1);
-}
-#if 0
-void phnx_get_sp_gp(void)
-{
-	unsigned long sp, gp;
-		__asm__ __volatile__(
-				".set push\n"
-				".set noreorder\n"
-				"move %1, $28\n"
-				"move %0, $29\n"
-				"nop\n"
-				".set pop\n"
-				:"=r"(sp), "=r"(gp)
-				);
-	Message("SP = 0x%lx GP = 0x%lx", sp, gp);
-}
-#endif
-#if 0
-void phnx_update_args(phnx_loader_shared_struct_t *sh_mem)
-{
-	struct cpu_wakeup_info *p = &sh_mem->run_info;
-	int i;
-
-	for(i=0; i < p->argc; i++) {
-		p->argv[i] =(char *)((unsigned long)p->argv[i] +
-				(unsigned long)p->buf);
-	}
-}
-#endif
-
-void phnx_prepare_cpu(void)
-{
-#if 1
-//	uint32_t status;
-	uint64_t eirr;
-
-//	write_c0_pagemask(0);
-//	write_c0_wired(0);
-
-	write_c0_status(ST0_KX | ST0_CU0 | ST0_CU2 | ST0_UX);
-	write_c0_cause(0);
-	write_c0_compare(0);
-
-//	status = read_c0_status();
-//	write_c0_status((status & ~ST0_KX));
-
-	eirr = read_64bit_cp0_eirr();
-	write_64bit_cp0_eirr(eirr);
-#endif
-}
-#if 0
-static void xlr_loader_not_implemented(void)
-{
-	ErrorMsg("xlr_loader: Unimplemented service requested");
-	while(1);
-}
-#endif
-#if 0
-static void xlr_loader_shutdown(void)
-{
-	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_GPIO_OFFSET);
-
-	/* trigger a chip reset */
-	phoenix_write_reg(mmio, GPIO_SWRESET_REG, 1);
-	for(;;) cpu_wait();
-}
-
-void prom_init_setup(struct psb_info *prom_info)
-{
-	loader_prom_info = *prom_info;
-	loader_prom_info.size = sizeof(loader_prom_info);
-	loader_prom_info.bldr_envp = (uint64_t)(unsigned long)&xlr_bldr_env;
-}
-#endif
-
-//void prom_init(struct psb_info *prom_info)
-void prom_init(void)
-{
-	unsigned long shared_mem_size=0;
-
-	Message("Entering %s", __func__);
-
-	shared_mem_size = sizeof(struct xlr_vcpu_wakeup_info) * XLR_NUM_CPU;
-	//shared_mem_size += sizeof(struct psb_info);
-	shared_mem_size += sizeof(struct xlr_lib_load_import);
-	shared_mem_size += sizeof(struct xlr_lib_launch_import);
-	shared_mem_size += sizeof(struct vcpu_extended_info);
-	shared_mem_size += sizeof(struct per_cpu_info_loader) * XLR_NUM_CPU;
-	shared_mem_size += sizeof(struct device_locks);
-	/* 1 additional slot for storing malloc info */
-	shared_mem_size += sizeof(struct ext_tlb) * (MAX_EXTENDED_TLBS+1) * XLR_NUM_CPU;
-	/* room for cacheline alignment if needed by app*/
-	shared_mem_size += 64;
-
-	Message("******Required Shared Mem Size for %d CPUs*********", XLR_NUM_CPU);
-	Message("xlr_vcpu_wakeup_info [%#lx]", (unsigned long)sizeof(struct xlr_vcpu_wakeup_info) * XLR_NUM_CPU);
-	//Message("PsbInfo [%lx]",(unsigned long)sizeof(struct psb_info));
-	Message("xlr_lib_load_import [%#lx]", (unsigned long)sizeof(struct xlr_lib_load_import));
-	Message("xlr_lib_launch_import [%#lx]", (unsigned long)sizeof(struct xlr_lib_launch_import));
-       //Message("SharedMemSize [%lx]",(unsigned long)phnx_app_sh_mem_sz);
-	Message("TotalSize Required before making PageAlign [%#lx]", (unsigned long)shared_mem_size);
-	/*Make shared mem size aligned.*/
-	if(shared_mem_size & (PAGE_SIZE-1)){
-		shared_mem_size += PAGE_SIZE;
-		shared_mem_size = shared_mem_size & ~(PAGE_SIZE-1);
-	}
-	xlr_lib_shmem_size = shared_mem_size;
-	Message("TotalSize Required after making PageAlign [%#lx]", (unsigned long)shared_mem_size);
-
-#ifdef CONFIG_64BIT
-	xlr_lib_shmem_start = (unsigned char *)(SHARED_MEM_ADDR | 0xffffffff80000000ULL);
-#else
-	xlr_lib_shmem_start = phys_to_virt(49 << 20);
-#endif
-
-	/*SANITY CHECK*/
-	if(shared_mem_size > (2 << 20)){
-		printk("Required Shared Mem Size %#lx",shared_mem_size);
-		panic("---PANIC---\n");
-	}
-
-	if(!xlr_lib_shmem_start){
-		panic("Couldnt Allocate Memory For shared DataStructure\n");
-	}
-	Message("Before Alignment Addr %#lx", (unsigned long)xlr_lib_shmem_start);
-
-	if(((unsigned long)xlr_lib_shmem_start) & (PAGE_SIZE-1)){
-		xlr_lib_shmem_start += PAGE_SIZE;
-		xlr_lib_shmem_start = (unsigned char *)
-						(((unsigned long)xlr_lib_shmem_start)&~(PAGE_SIZE-1));
-	}
-	Message("After alignment, Got the memory @ %#lx, size %#lx",
-			(unsigned long)xlr_lib_shmem_start,
-			(unsigned long)xlr_lib_shmem_size);
-
-	xlr_wakeup_info = (struct xlr_vcpu_wakeup_info *)xlr_lib_shmem_start;
-	//xlr_linux_boot_info = (struct psb_info *)(xlr_wakeup_info + XLR_NUM_CPU);
-	//xlr_load = (struct xlr_lib_load_import *)(xlr_linux_boot_info + 1);
-	xlr_load = (struct xlr_lib_load_import *)(xlr_wakeup_info + XLR_NUM_CPU);
-	xlr_launch = (struct xlr_lib_launch_import *)(xlr_load + 1);
-
-	Message("xlr_wakeup_info @ %#lx, Size %#lx",(unsigned long)xlr_wakeup_info,
-						sizeof(struct xlr_vcpu_wakeup_info));
-	//Message("xlr_linux_boot_info @ %#lx, Size %#lx",
-	//			(unsigned long)xlr_linux_boot_info,	sizeof(struct psb_info));
-	Message("xlr_load @ %#lx, Size %#lx",(unsigned long)xlr_load,
-					sizeof(struct xlr_lib_load_import));
-	Message("xlr_launch @ %#lx, size %#lx",(unsigned long)xlr_launch,
-					sizeof(struct xlr_lib_launch_import));
-	//Message(" shared mem size is %#lx",(unsigned long)phnx_app_sh_mem_sz);
-
-	//Message("sanity access %#x",*xlr_lib_shmem_start);
-	memset((void *)xlr_lib_shmem_start,0,xlr_lib_shmem_size);
-#if 0
-	xlr_uart_init();
-	Message("UartInit Done.");
-#endif
-	//memcpy((void *)xlr_linux_boot_info, prom_info, sizeof(struct psb_info));
-
-#if 0
-	memset((void *)xlr_linux_boot_info, 0, sizeof(struct psb_info));
-	spin_lock_init(&phnx_loader_lock);
-	xlr_linux_boot_info->uart_print = PTR2U64(&xlr_loader_not_implemented);
-	xlr_linux_boot_info->led_output = PTR2U64(&xlr_loader_not_implemented);
-	xlr_linux_boot_info->init = PTR2U64(&xlr_loader_not_implemented);
-	xlr_linux_boot_info->exit = PTR2U64(&xlr_loader_not_implemented);
-	xlr_linux_boot_info->warm_reset = PTR2U64(&xlr_loader_shutdown); /*Make this unimplemented.*/
-	xlr_linux_boot_info->wakeup = PTR2U64(&xlr_loader_not_implemented);
-	xlr_linux_boot_info->cpu_online_map &= ~xlr_linux_cpu_mask;
-	xlr_linux_boot_info->master_reentry_sp = 0;
-	xlr_linux_boot_info->master_reentry_gp = 0;
-	xlr_linux_boot_info->master_reentry_fn =
-					PTR2U64(&xlr_loader_not_implemented);
-	xlr_linux_boot_info->slave_reentry_fn =
-					PTR2U64(&xlr_loader_not_implemented);
-	xlr_linux_boot_info->uart_putchar = PTR2U64(&xlr_loader_put_char); /*Make this not implemented*/
-	xlr_linux_boot_info->uart_getchar = PTR2U64(&xlr_loader_get_char); /*Make this not implemented.*/
-	xlr_linux_boot_info->nmi_handler = PTR2U64(&xlr_loader_not_implemented);
-	xlr_linux_boot_info->malloc = PTR2U64(&xlr_loader_not_implemented);
-	xlr_linux_boot_info->free = PTR2U64(&xlr_loader_not_implemented);
-	xlr_linux_boot_info->global_shmem_addr = prom_info->global_shmem_addr;
-	xlr_linux_boot_info->global_shmem_size = prom_info->global_shmem_size;
-	xlr_linux_boot_info->wakeup_os = PTR2U64(&xlr_loader_not_implemented);
-	/*yet xlr_loader_mem_map is not filled up with proper values,
-	  we will do it once we are done with parsing of all arguments.*/
-	xlr_linux_boot_info->psb_mem_map = PTR2U64(&xlr_loader_mem_map);
-	memcpy((void *)&xlr_loader_io_map,
-			(void *)(unsigned long)prom_info->psb_physaddr_map,
-				sizeof(struct psb_io_map));
-	xlr_linux_boot_info->psb_physaddr_map = PTR2U64(&xlr_loader_io_map);
-#endif
-}
-
-void prom_start_loader(int cpu, unsigned long sp, unsigned long gp)
-{
-	extern struct smp_boot_info smp_boot; //from Linux: exported form file smp.c.
-	/* Load Linux SP and GP for this thread and jump to loader function */
-	smp_boot.boot_info[cpu].sp = sp;
-	smp_boot.boot_info[cpu].gp = gp;
-	smp_boot.boot_info[cpu].fn = (unsigned long)&xlr_lib_entry;
-	/* barrier */
-	__sync();
-	smp_boot.boot_info[cpu].ready = 1;
-}
-
-int loader_processor_id(void)
-{
-	unsigned int id;
-	id  = __read_32bit_c0_register($15, 1);
-	//return (id & 0x1f);
-	return (id & 0x3f);
-}
-
-static unsigned int calculate_loader_mask(void)
-{
-	cpumask_t tmploader_mask, loadernode_mask;
-	unsigned int onlinemask;
-	int node=0;
-	cpumask_t mask32;
-
-	cpumask_clear(&mask32);
-	uint32_to_cpumask(&mask32, 0xffffffff);
-
-	cpumask_clear(&tmploader_mask);
-	cpumask_clear(&loadernode_mask);
-
-	cpumask_shift_right(&loadernode_mask, &fdt_loadermask, 32 * node);
-	cpumask_and(&tmploader_mask, &loadernode_mask, &mask32);
-
-	onlinemask = cpumask_to_uint32(&tmploader_mask);
-	return onlinemask;
-}
-
-void start_threads(void)
-{
-	int i,index=0;
-	uint32_t mask = calculate_loader_mask();
-	unsigned long long sp = 0, gp = 0;
-	uint64_t stack_start = 0;
-	extern struct loader_mem_info loader_mem_map[MAX_NUM_LOADER_MEM_BLK]; //from Linux: filled in function fdt_process.
-
-	icache_lines = current_cpu_data.icache.ways * current_cpu_data.icache.sets;
-	icache_linesz = current_cpu_data.icache.linesz;
-  	dcache_lines = current_cpu_data.dcache.ways * current_cpu_data.dcache.sets;
-  	dcache_linesz = current_cpu_data.dcache.linesz;
-
-	Message("icache_lines = %d, icache_linesz = %d", icache_lines, icache_linesz);
-	Message("dcache_lines = %d, dcache_linesz = %d", dcache_lines, dcache_linesz);
-
-	prom_init();
-
-	stack_start = (uint64_t)(unsigned long) (xlr_lib_shmem_start + xlr_lib_shmem_size);
-	stack_start = (stack_start + PAGE_SIZE) & ~(PAGE_SIZE-1);
-	xlr_launch->xlr_wakeup_info = (uint32_t)(unsigned long)xlr_wakeup_info;
-	//xlr_launch->xlr_lib_boot1_info = (uint32_t)(unsigned long) xlr_linux_boot_info;
-
-	/*Below routine ll fill up 'r_exception_vectors+32' with proper exception
-	handlers*/
-	//Message("");
-	//reload_generic_trap_init();
-
-	/*'r_exception_vectors + 1' is filled up with proper exception hadnerls.*/
-	//xlr_launch->default_ebase = (uint32_t)(unsigned long)
-								//(r_exception_vectors + 32);
-
-	//Message("Default Ebase %#x",xlr_launch->default_ebase);
-	for(i=0; i < XLR_NUM_CPU; i++) {
-		if(((1U << i) & mask) == 0)
-			continue;
-		gp = stack_start + ((PAGE_SIZE<<1)*i);
-		if(gp == 0) {
-			panic("%s:No memory available for launching xlr loader threads\n", __FUNCTION__);
-		}
-		sp = gp + (PAGE_SIZE << 1);
-		xlr_launch->gp[i] = gp;
-		xlr_launch->sp[i] = sp - 32;
-		Message("Thread %d==>sp [%#llx], gp [%#llx]",
-					i,(unsigned long long)xlr_launch->sp[i],
-					(unsigned long long)xlr_launch->gp[i]);
-	}
-	memset(loader_lock, 0, GENERIC_LOCK_SIZE);
-	memset(printk_lock, 0, GENERIC_LOCK_SIZE);
-
-	xlr_launch->cb_prelaunch_init_kuseg       = 0;
-	xlr_launch->cb_prelaunch_init_kseg        = 0;
-	xlr_launch->flush_icache_all              = (int32_t)(long)xlp_flush_local_icache;
-	xlr_launch->flush_dcache_all              = (int32_t)(long)xlp_flush_local_dcache;
-	xlr_launch->flush_tlb_all                 = (int32_t)(long)phnx_local_flush_tlb_all;
-	xlr_launch->xlr_setup_tlb                 = (int32_t)(long)phnx_setup_tlb;
-	xlr_launch->xlr_hard_vcpu_id              = (int32_t)(long)loader_processor_id;
-	xlr_launch->global_wakeup_mask            = (int32_t)(long)&global_wakeup_mask;
-	xlr_launch->trap_init                     = (int32_t)(long)reload_trap_init;
-	xlr_launch->cpu_init                      = (int32_t)(long)phnx_prepare_cpu;
-	xlr_launch->print                         = (int32_t)(long)printk; //RAHUL xlr_loader_print;
-	xlr_launch->loader_lock                   = (int32_t)(long)loader_lock;
-
-	/*Do launch Init.*/
-	xlr_lib_launch_init (xlr_launch);
-
-	/*Put all loader threads in "wait" inst loop..*/
-	for (i=0; i < XLR_NUM_CPU; i++){
-		if(((1U << i) & mask) == 0)
-			continue;
-		sp = xlr_launch->sp[i];
-		gp = xlr_launch->gp[i];
-		prom_start_loader(i, sp, gp);
-	}
-
-	/*Setup xlr_loader_mem_map with argument passed by user*/
-	index = 0;
-	//xlr_loader_mem_map.map[index].addr = (uint64_t)phnx_loader_kseg_start;
-	//xlr_loader_mem_map.map[index].size = (uint64_t)phnx_loader_kseg_size;
-	xlr_loader_mem_map.map[index].addr = (uint64_t)0;
-	xlr_loader_mem_map.map[index].size = (uint64_t)0;
-	xlr_loader_mem_map.map[index].type = BOOT_MEM_RAM;
-	index++;
-	xlr_loader_mem_map.nr_map = 1;
-
-#if 0
-	for ( i = 0; i < MAX_NUM_KUSEG_BLOCKS;i++) {
-		if ( (kuseg_mem_map[i].start_addr == 0 ) && (kuseg_mem_map[i].size == 0) )
-			continue;
-
-		xlr_loader_mem_map.map[index].addr = kuseg_mem_map[i].start_addr;
-		xlr_loader_mem_map.map[index].size = kuseg_mem_map[i].size;
-		xlr_loader_mem_map.map[index].type = BOOT_MEM_RAM;
-		index++;
-		xlr_loader_mem_map.nr_map = xlr_loader_mem_map.nr_map + 1;
-	}
-#else
-	for ( i = 0; i < MAX_NUM_LOADER_MEM_BLK; i++) {
-		if ( (loader_mem_map[i].start_addr == 0 ) && (loader_mem_map[i].size == 0) )
-			continue;
-
-		xlr_loader_mem_map.map[index].addr = loader_mem_map[i].start_addr;
-		xlr_loader_mem_map.map[index].size = loader_mem_map[i].size;
-		xlr_loader_mem_map.map[index].type = BOOT_MEM_RAM;
-		index++;
-		xlr_loader_mem_map.nr_map = xlr_loader_mem_map.nr_map + 1;
-	}
-	for ( i = 0;i <xlr_loader_mem_map.nr_map; i++) {
-		Message("KUSEG Mem %#llx @ %#llx",
-					(unsigned long long)xlr_loader_mem_map.map[i].size,
-					(unsigned long long)xlr_loader_mem_map.map[i].addr);
-	}
-#endif
-
-	/*Setup load_init data structure.*/
-	memcpy((void *)&xlr_load->default_map, (void *)&xlr_loader_mem_map, sizeof(struct psb_mem_map));
-	memcpy((void *)&xlr_load->recent_map, (void *)&xlr_loader_mem_map, sizeof(struct psb_mem_map));
-	//xlr_load->userapp_cpu_mask = phnx_loader_mask;
-	//xlr_load->total_avail_cpu = phnx_loader_mask;
-	//xlr_load->recent_avail_cpu = phnx_loader_mask;
-	xlr_load->userapp_cpu_mask                = calculate_loader_mask();
-	xlr_load->total_avail_cpu                 = calculate_loader_mask();
-	xlr_load->recent_avail_cpu                = calculate_loader_mask();
-	xlr_load->lib_base_lock                   = (int32_t)(long)printk_lock;
-	xlr_load->coredump_support                = 0;
-	xlr_load->persistent_data                 = 0;
-
-	Message("*****XLR LOAD INFO*****");
-	Message("Total Avail Vcpu %#x",xlr_load->total_avail_cpu);
-	Message("Recent Avail Vcpu %#x",xlr_load->recent_avail_cpu);
-//	Message("Kseg Mem %#llx @ %#llx",(unsigned long long)phnx_loader_kseg_size,
-//					(unsigned long long)phnx_loader_kseg_start);
-	Message("**********************");
-	Message("Main Thread Returning.");
-}
-
diff --git a/drivers/misc/netlogic/linux-loader/ops.h b/drivers/misc/netlogic/linux-loader/ops.h
deleted file mode 100644
index a60c2d5..0000000
--- a/drivers/misc/netlogic/linux-loader/ops.h
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
- * Global definition of all the bootwrapper operations.
- *
- * Author: Mark A. Greer <mgreer@mvista.com>
- *
- * 2006 (c) MontaVista Software, Inc.  This file is licensed under
- * the terms of the GNU General Public License version 2.  This program
- * is licensed "as is" without any warranty of any kind, whether express
- * or implied.
- */
-#ifndef _PPC_BOOT_OPS_H_
-#define _PPC_BOOT_OPS_H_
-
-#include <stddef.h>
-//#include "types.h"
-#include "string.h"
-
-//#define	COMMAND_LINE_SIZE	512
-#define	MAX_PATH_LEN		256
-#define	MAX_PROP_LEN		256 /* What should this be? */
-
-typedef void (*kernel_entry_t)(unsigned long r3, unsigned long r4, void *r5);
-
-/* Platform specific operations */
-struct platform_ops {
-	void	(*fixups)(void);
-	void	(*image_hdr)(const void *);
-	void *	(*malloc)(unsigned long size);
-	void	(*free)(void *ptr);
-	void *	(*realloc)(void *ptr, unsigned long size);
-	void	(*exit)(void);
-	void *	(*vmlinux_alloc)(unsigned long size);
-};
-extern struct platform_ops platform_ops;
-
-/* Device Tree operations */
-struct dt_ops {
-	void *	(*finddevice)(const char *name);
-	int	(*getprop)(const void *phandle, const char *name, void *buf,
-			const int buflen);
-	int	(*setprop)(const void *phandle, const char *name,
-			const void *buf, const int buflen);
-	int (*del_node)(const void *phandle);
-	void *(*get_parent)(const void *phandle);
-	/* The node must not already exist. */
-	void *(*create_node)(const void *parent, const char *name);
-	void *(*find_node_by_prop_value)(const void *prev,
-	                                 const char *propname,
-	                                 const char *propval, int proplen);
-	void *(*find_node_by_compatible)(const void *prev,
-	                                 const char *compat);
-	unsigned long (*finalize)(void);
-	char *(*get_path)(const void *phandle, char *buf, int len);
-	int (*check_header)(void);
-};
-extern struct dt_ops dt_ops;
-
-/* Console operations */
-struct console_ops {
-	int		(*open)(void);
-	void	(*write)(const char *buf, int len);
-	void	(*edit_cmdline)(char *buf, int len);
-	void	(*close)(void);
-	void	*data;
-};
-extern struct console_ops console_ops;
-
-/* Serial console operations */
-struct serial_console_data {
-	int		(*open)(void);
-	void	(*putc)(unsigned char c);
-	unsigned char	(*getc)(void);
-	unsigned char		(*tstc)(void);
-	void	(*close)(void);
-};
-
-struct loader_info {
-	void *promptr;
-	unsigned long initrd_addr, initrd_size;
-	char *cmdline;
-	int cmdline_len;
-};
-extern struct loader_info loader_info;
-
-void start(void);
-void *fdt_init(void *blob);
-//int serial_console_init(void);
-int ns16550_console_init(void *devp, struct serial_console_data *scdp);
-void *simple_alloc_init(char *base, unsigned long heap_size,
-			unsigned long granularity, unsigned long max_allocs);
-extern void flush_cache(void *, unsigned long);
-int dt_xlate_reg(void *node, int res, unsigned long *addr, unsigned long *size);
-int dt_xlate_addr(void *node, unsigned int *buf, int buflen, unsigned long *xlated_addr);
-int dt_is_compatible(void *node, const char *compat);
-void dt_get_reg_format(void *node, unsigned int *naddr, unsigned int *nsize);
-int dt_get_virtual_reg(void *node, void **addr, int nres);
-
-
-static inline void *finddevice(const char *name)
-{
-	return (dt_ops.finddevice) ? dt_ops.finddevice(name) : NULL;
-}
-
-static inline int getprop(void *devp, const char *name, void *buf, int buflen)
-{
-	return (dt_ops.getprop) ? dt_ops.getprop(devp, name, buf, buflen) : -1;
-}
-
-static inline int setprop(void *devp, const char *name,
-                          const void *buf, int buflen)
-{
-	return (dt_ops.setprop) ? dt_ops.setprop(devp, name, buf, buflen) : -1;
-}
-#define setprop_val(devp, name, val) \
-	do { \
-		typeof(val) x = (val); \
-		setprop((devp), (name), &x, sizeof(x)); \
-	} while (0)
-
-static inline int setprop_str(void *devp, const char *name, const char *buf)
-{
-	if (dt_ops.setprop)
-		return dt_ops.setprop(devp, name, buf, strlen(buf) + 1);
-
-	return -1;
-}
-
-static inline int del_node(const void *devp)
-{
-	return dt_ops.del_node ? dt_ops.del_node(devp) : -1;
-}
-
-static inline void *get_parent(const char *devp)
-{
-	return dt_ops.get_parent ? dt_ops.get_parent(devp) : NULL;
-}
-
-static inline void *create_node(const void *parent, const char *name)
-{
-	return dt_ops.create_node ? dt_ops.create_node(parent, name) : NULL;
-}
-
-
-static inline void *find_node_by_prop_value(const void *prev,
-                                            const char *propname,
-                                            const char *propval, int proplen)
-{
-	if (dt_ops.find_node_by_prop_value)
-		return dt_ops.find_node_by_prop_value(prev, propname,
-		                                      propval, proplen);
-
-	return NULL;
-}
-
-static inline void *find_node_by_prop_value_str(const void *prev,
-                                                const char *propname,
-                                                const char *propval)
-{
-	return find_node_by_prop_value(prev, propname, propval,
-	                               strlen(propval) + 1);
-}
-
-static inline void *find_node_by_devtype(const void *prev,
-                                         const char *type)
-{
-	return find_node_by_prop_value_str(prev, "device_type", type);
-}
-
-static inline void *find_node_by_alias(const char *alias)
-{
-	void *devp = finddevice("/aliases");
-
-	if (devp) {
-		char path[MAX_PATH_LEN];
-		if (getprop(devp, alias, path, MAX_PATH_LEN) > 0)
-			return finddevice(path);
-	}
-
-	return NULL;
-}
-
-static inline void *find_node_by_compatible(const void *prev,
-                                            const char *compat)
-{
-	if (dt_ops.find_node_by_compatible)
-		return dt_ops.find_node_by_compatible(prev, compat);
-
-	return NULL;
-}
-
-static inline int check_header(void)
-{
-	if (dt_ops.check_header)
-		return dt_ops.check_header();
-	return -1;
-}
-
-void dt_fixup_memory(unsigned long long start, unsigned long long size);
-void dt_fixup_cpu_clocks(unsigned int cpufreq, unsigned int tbfreq, unsigned int busfreq);
-void dt_fixup_clock(const char *path, unsigned int freq);
-void dt_fixup_mac_address_by_alias(const char *alias, const unsigned char *addr);
-void dt_fixup_mac_address(unsigned int index, const unsigned char *addr);
-void __dt_fixup_mac_addresses(unsigned int startindex, ...);
-#define dt_fixup_mac_addresses(...) \
-	__dt_fixup_mac_addresses(0, __VA_ARGS__, NULL)
-
-
-static inline void *find_node_by_linuxphandle(const unsigned int linuxphandle)
-{
-	return find_node_by_prop_value(NULL, "linux,phandle",
-			(char *)&linuxphandle, sizeof(unsigned int));
-}
-
-static inline char *get_path(const void *phandle, char *buf, int len)
-{
-	if (dt_ops.get_path)
-		return dt_ops.get_path(phandle, buf, len);
-
-	return NULL;
-}
-
-static inline void *malloc(unsigned long size)
-{
-	return (platform_ops.malloc) ? platform_ops.malloc(size) : NULL;
-}
-
-static inline void free(void *ptr)
-{
-	if (platform_ops.free)
-		platform_ops.free(ptr);
-}
-
-static inline void exit(void)
-{
-	if (platform_ops.exit)
-		platform_ops.exit();
-	for(;;);
-}
-#define fatal(args...) { printf(args); exit(); }
-
-
-#define BSS_STACK(size) \
-	static char _bss_stack[size]; \
-	void *_platform_stack_top = _bss_stack + sizeof(_bss_stack);
-
-extern unsigned long timebase_period_ns;
-//void udelay(long delay);
-#if 0
-extern char _start[];
-extern char __bss_start[];
-extern char _end[];
-extern char _vmlinux_start[];
-extern char _vmlinux_end[];
-extern char _initrd_start[];
-extern char _initrd_end[];
-extern char _dtb_start[];
-extern char _dtb_end[];
-
-static inline __attribute__((const))
-int __ilog2_u32(unsigned int n)
-{
-	int bit;
-	asm ("cntlzw %0,%1" : "=r" (bit) : "r" (n));
-	return 31 - bit;
-}
-#endif
-
-#endif /* _PPC_BOOT_OPS_H_ */
diff --git a/drivers/misc/netlogic/linux-loader/phnx_loader.c b/drivers/misc/netlogic/linux-loader/phnx_loader.c
deleted file mode 100644
index 76dfe7a..0000000
--- a/drivers/misc/netlogic/linux-loader/phnx_loader.c
+++ /dev/null
@@ -1,646 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_2# */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/spinlock.h>
-#include <linux/sched.h>
-#include <linux/mm.h>
-#include <linux/vmalloc.h>
-#include <linux/poll.h>
-#include <asm/uaccess.h>
-//#include <asm/rmi/devices.h>
-#include "phnx_loader.h"
-//#include <asm/rmi/pic.h>
-#include <asm/io.h>
-#include <asm/system.h>
-#include <linux/rwsem.h>
-#include <linux/smp_lock.h>
-
-#define Message(fmt, args...)      //printk("[%s]-[%d] "fmt"\n",__FUNCTION__,__LINE__,##args)
-#define dbg_msg(fmt, args...)      //printk("[%s]-[%d] "fmt"\n",__FUNCTION__,__LINE__,##args)
-
-/* Extern */
-extern int xlr_lib_launch_userapp(int cpu);
-extern void wakeup_cpu(unsigned int cpu, unsigned long fn, unsigned long args);
-extern void xlr_send_stop_ipi(unsigned long mask);
-extern int nlm_get_domain_info(int domain, struct domain_info *dom);
-extern void start_threads(void);
-extern int fdt_process(void);
-
-extern volatile unsigned int xlr_lib_shmem_size;
-extern int xlp_loader_support;
-extern unsigned char *xlr_lib_shmem_start;
-
-/* Static */
-static spinlock_t phnx_loader_lock;
-static int phnx_loader_user = 0;
-static int phnx_map_sh_mem=0;
-static int phnx_map_persistent_mem = 0;
-static int phnx_map_load_addr = 0;
-static int phnx_map_app_shmem=0;
-static uint64_t xlr_app_shmem_start = 0x0;
-static uint32_t phnx_app_sh_mem_sz = 0; /* Size of the shared memory b/w Linux userapp and rmios apps */
-static struct xlr_lib_shared_mem app_shared_mem;
-
-/* Global */
-unsigned char *xlr_persistent_data_start=NULL;
-unsigned char *xlr_persistent_data_start_orig=NULL;
-unsigned int xlr_persistent_data_size=0;
-unsigned char load_env[32][6];
-struct xlr_load_addr xlr_image_load_addr;
-
-static int phnx_loader_open (struct inode *inode, struct file *filp)
-{
-	uint32_t minor=0;
-	if(xlp_loader_support == 0)
-		return -EPERM;
-
-	minor = MINOR(inode->i_rdev);
-	if(minor == XLR_MAP_SLAVE_DEVICE){
-		filp->private_data = (void *)inode;
-		return 0;
-	}
-
-	/* ALLOW ONLY ONE OPEN at a time */
-	spin_lock(&phnx_loader_lock);
-	if(phnx_loader_user == 1){
-		spin_unlock(&phnx_loader_lock);
-		return -EAGAIN;
-	}
-	filp->private_data = (void *)inode;
-	phnx_loader_user = 1;
-	phnx_map_load_addr = 0;
-	phnx_map_persistent_mem = 0;
-	phnx_map_sh_mem = 0;
-	phnx_map_app_shmem = 0;
-
-	spin_unlock(&phnx_loader_lock);
-	return 0;
-}
-
-#if 0
-void phnx_loader_send_ipi(struct loader_send_ipi *data)
-{
-	uint32_t i;
-	uint32_t pid, tid;
-	uint32_t val;
-	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
-
-	for(i=0; i<32; i++){
-		if((data->mask) & (1<<i)){
-				pid = i >> 2;
-				tid = i % 4;
-				val = (pid << 20) | (tid << 16) | data->ipi;
-				phoenix_write_reg(mmio, PIC_IPI, val);
-		}
-	}
-}
-#endif
-/*
-       Various ioctl options are listed:-
-
-       PHNX_LOADER_IOC_SHMEM_SIZE: return shared mem size to user
-       PHNX_LOADER_IOC_MMAP_SHMEM: map shared mem
-       PHNX_LOADER_IOC_MMAP_LOAD_ADDR: map passed physical address and size
-       PHNX_LOADER_IOC_START_IPI: wakeup cpu by sending START IPI
-       PHNX_LOADER_IOC_STOP_IPI: stop cpu
-       PHNX_LOADER_IOC_LIB_BKP: to check if persistent memory is present
-       PHNX_LOADER_IOC_STORE_APP_SHMEM_INFO: store app shared memory info
-       PHNX_LOADER_IOC_GET_APP_SHMEM_INFO: retrieve shared memory to user
-       PHNX_LOADER_IOC_SHMEM_KSEG_ADDR: return kseg0 base of the data structure's
-                                   shared memory used by mmap_to_kseg/kseg_to_mmap
-       PHNX_LOADER_IOC_FREE_PERSISTENT_MEM: free persistent memory
-       PHNX_LOADER_IOC_ALLOC_PERSISTENT_MEM: alloc persistent meory of size given by user
-                     from kernel heap.
-       PHNX_LOADER_IOC_MMAP_PERSISTENT_MEM: map persistent memory.
-       PHNX_LOADER_IOC_LAUNCH_KSEG: launch userapp for kseg app given at user cpu
-       PHNX_LOADER_STORE_ENV: store user env
-       PHNX_LOADER_IOC_FDT_CPUMASK:  get domain related info from FDT for user given domid
-*/
-
-static int phnx_loader_ioctl (struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	unsigned int *addr = (unsigned int*)arg;
-	switch (cmd) {
-		/*size of the data structures shared memory - this includes
-		 all xlr_vcpu_wakeup_info and other lib data structure.*/
-		case PHNX_LOADER_IOC_SHMEM_SIZE:
-		{
-			//Message(" available shared mem [%#x]",xlr_lib_shmem_size);
-			if(put_user(xlr_lib_shmem_size, addr)){
-				panic("\nput user failed for ioc shmem size\n");
-			}
-		}
-		break;
-
-		/*Next mmap should be for global data structure -
-		 wakeup_info and other structures*/
-		case PHNX_LOADER_IOC_MMAP_SHMEM:
-		{
-			phnx_map_sh_mem = 1;
-			phnx_map_persistent_mem = 0;
-			phnx_map_load_addr = 0;
-			phnx_map_app_shmem = 0;
-		}
-		break;
-
-		/*Do an mmap of the passed physical address and size*/
-		case PHNX_LOADER_IOC_MMAP_LOAD_ADDR:
-		{
-			if(copy_from_user((void *)&xlr_image_load_addr,
-						(const void __user *)addr,
-						sizeof(struct xlr_load_addr)))
-				panic("\nmmap load addr - copy frm user - failed\n");
-			phnx_map_load_addr = 1;
-			phnx_map_persistent_mem = 0;
-			phnx_map_sh_mem = 0;
-			phnx_map_app_shmem = 0;
-		}
-		break;
-
-		/*Wakeup cpu*/
-		case PHNX_LOADER_IOC_START_IPI:
-		{
-			struct wakeup_info tmp;
-			if(copy_from_user((void *)&tmp, (const void __user *)addr, sizeof(struct wakeup_info)))
-				panic("copy from user failed for START IPI\n");
-			wakeup_cpu(tmp.vcpu, (unsigned long)tmp.func, (unsigned long)tmp.data);
-		}
-		break;
-
-		/*Stop cpu*/
-		case PHNX_LOADER_IOC_STOP_IPI:
-		{
-			uint32_t vcpu=0;
-			if(get_user(vcpu, (uint32_t *)addr))
-				panic("\nGetUser Failed for stop ipi\n");
-			/*Below Func Is Library Call.*/
-			xlr_send_stop_ipi(vcpu);
-		}
-		break;
-#if 0
-		/*Send ipi to the cpu*/
-		case PHNX_LOADER_SEND_IPI:
-		{
-			if(copy_from_user((void *)&data , (const void __user *)arg,
-							sizeof(data))){
-					panic("\ncopy_from_user failed for send_ipi\n");
-			}
-			phnx_loader_send_ipi(&data);
-		}
-		break;
-#endif
-		/*Check if persistent memory is present*/
-		case PHNX_LOADER_IOC_LIB_BKP:
-		{
-			if(xlr_persistent_data_start_orig){
-				if(put_user(1, addr))
-					panic("\nput_user failed for lib_bkp\n");
-			}
-			else{
-				if(put_user(0, addr))
-					panic("\nput_user failed for lib_bkp\n");
-			}
-		}
-		break;
-
-		/*Store shared memory info*/
-		case PHNX_LOADER_IOC_STORE_APP_SHMEM_INFO:
-		{
-			if(copy_from_user((void *)&app_shared_mem, (const void __user *)arg,
-							sizeof(app_shared_mem))){
-				panic("copy from User failed for app shared mem info\n");
-			}
-			/*
-			int i=0;
-			for(i=0; i<app_shared_mem.entries; i++){
-				printk("\nStoring Physical Addr %#llx, Size %#llx\n",
-						(unsigned long long)app_shared_mem.addr[i],
-						(unsigned long long)app_shared_mem.size[i]);
-			}
-			*/
-		}
-		break;
-
-		/*Retrieve shared memory info*/
-		case PHNX_LOADER_IOC_GET_APP_SHMEM_INFO:
-		{
-			/*
-			int i=0;
-			for(i=0; i<app_shared_mem.entries; i++){
-				printk("\nRetrive Physical Addr %#llx, Size %#llx\n",
-						(unsigned long long)app_shared_mem.addr[i],
-						(unsigned long long)app_shared_mem.size[i]);
-			}*/
-
-			if(copy_to_user((void __user *)arg, (const void *)&app_shared_mem,
-							sizeof(app_shared_mem))){
-				panic("\ncopy_to_user failed for app shared mem info\n");
-			}
-		}
-		break;
-
-		/*Get the kseg0 base of the data structure's shared memory
-		  used by mmap_to_kseg/kseg_to_mmap*/
-		case PHNX_LOADER_IOC_SHMEM_KSEG_ADDR:
-		{
-			if (put_user((long long)(int)(long)xlr_lib_shmem_start, (uint64_t *)addr)){
-				panic("\nput user failed for ioc shmem kseg addr\n");
-			}
-		}
-		break;
-
-
-		/*Free persistent memory*/
-		case PHNX_LOADER_IOC_FREE_PERSISTENT_MEM:
-		{
-			unsigned long addr=0;
-			if(!xlr_persistent_data_start_orig){
-				printk("Data Is Not Allocated.\n");
-				return -EINVAL;
-			}
-			addr = (unsigned long)xlr_persistent_data_start;
-                     while(addr < (unsigned long)
-                                   (xlr_persistent_data_start+xlr_persistent_data_size)){
-                            ClearPageReserved(virt_to_page((void *)addr));
-                            addr += PAGE_SIZE;
-                     }
-                     kfree(xlr_persistent_data_start_orig);
-                     xlr_persistent_data_start_orig = xlr_persistent_data_start = NULL;
-		}
-		break;
-
-		/*Alloc persistent memory*/
-		case PHNX_LOADER_IOC_ALLOC_PERSISTENT_MEM:
-		{
-			unsigned long tmp_addr=0;
-			if(get_user(xlr_persistent_data_size,(unsigned int *)addr)){
-				panic("GetUser Failed for alloc persistent mem\n");
-			}
-			if(!xlr_persistent_data_size){
-				printk("Invalid Len %#x\n", xlr_persistent_data_size);
-				return -EINVAL;
-			}
-			xlr_persistent_data_start_orig =
-				kmalloc(xlr_persistent_data_size+PAGE_SIZE, GFP_KERNEL|GFP_DMA);
-			if(!xlr_persistent_data_start_orig)
-				return -ENOMEM;
-			xlr_persistent_data_start = (unsigned char *)
-						(((unsigned long)(xlr_persistent_data_start_orig +
-											PAGE_SIZE)) & ~(PAGE_SIZE-1));
-			tmp_addr = (unsigned long)xlr_persistent_data_start;
-                     while(tmp_addr < (unsigned long) (xlr_persistent_data_start+xlr_persistent_data_size))
-                     {
-                            /* The calls to SetPageReserved cause the swapper
-                               not to swap those pages out to disk */
-                            SetPageReserved(virt_to_page((void *)tmp_addr));
-                            tmp_addr += PAGE_SIZE;
-                     }
-		}
-		break;
-
-		/*mmap persistent memory in next mmap call.*/
-		case PHNX_LOADER_IOC_MMAP_PERSISTENT_MEM:
-		{
-			phnx_map_persistent_mem = 1;
-			phnx_map_sh_mem = 0;
-			phnx_map_load_addr = 0;
-			phnx_map_app_shmem = 0;
-		}
-		break;
-
-		/*call lib_launch.c's launch_userapp for kseg app*/
-		case PHNX_LOADER_IOC_LAUNCH_KSEG:
-		{
-                     uint32_t vcpu=0;
-                     if(get_user(vcpu, (uint32_t *)addr))
-                            panic("\nGetUser Failed for launch kseg\n");
-                     /*Below Func Is Library Call.*/
-                     xlr_lib_launch_userapp(vcpu);
-              }
-              break;
-
-              /*store UART info*/
-              case PHNX_LOADER_STORE_ENV:
-              {
-                     int i;
-                     unsigned char temp[32][6];
-                     copy_from_user ((void *)&temp , (const void __user *)addr, sizeof(temp));
-
-                     for (i=0; i<32; i++)    {
-                            if (strcmp(temp[i],"") != 0)
-                                   strcpy(load_env[i],temp[i]);
-                     }
-              }
-              break;
-
-              //IOCTL to return cpu_mask & master_cpu from domain ID.
-              case PHNX_LOADER_IOC_FDT_CPUMASK:
-              {
-                     struct domain_info dom;
-                     if(copy_from_user(&dom, (const void __user *)addr, sizeof(dom))){
-                            panic("\nCopyFromUser Failed for domain info\n");
-                     }
-                     nlm_get_domain_info(dom.domain, &dom);
-                     if(copy_to_user((void __user*)addr, (const void *)&dom, sizeof(dom))){
-					panic("\nCopyToUser Failed for domain info\n");
-			}
-			break;
-		}
-
-		default:
-		{
-			printk("ioctl(): invalid command=0x%x\n", cmd);
-			return -EINVAL;
-		}
-	}
-	return 0;
-}
-
-static long 
-phnx_loader_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	unsigned long ret = -1;
-	lock_kernel();
-	//Message("Got the user space address [%#lx]",arg);
-	ret = phnx_loader_ioctl (NULL, filp, cmd, (uint32_t)arg);
-	unlock_kernel();
-	if(ret){
-		printk("phnx_loader_ioctl returned with an error.");
-		return -ENOIOCTLCMD;
-	}
-	return ret;
-}
-
-static int phnx_loader_mmap_app_shared_mem(struct file *file,
-              struct vm_area_struct *vma)
-{
-	struct xlr_lib_shared_mem *shmem = &app_shared_mem;
-	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
-	unsigned long vaddr = 0;
-	int i=0;
-	int result = 0;
-	unsigned long mmap_size = 0;
-	unsigned long size = 0;
-
-	for(i=0; i < shmem->entries; i++){
-		if(shmem->addr[i] & (PAGE_SIZE-1)){
-			printk("Mmaping to invalid address ... %#llx\n",
-						(unsigned long long)shmem->addr[i]);
-			return -EINVAL;
-		}
-	}
-
-	if (vma->vm_flags & VM_LOCKED) return -EPERM;
-
-	if (offset >= shmem->tot_size) return -ESPIPE;
-
-	pgprot_val (vma->vm_page_prot) &= ~_CACHE_MASK;
-	pgprot_val (vma->vm_page_prot) |= _CACHE_CACHABLE_COW;
-
-	vaddr = vma->vm_start;
-	size = vma->vm_end - vma->vm_start;
-
-	for(i=0; i < shmem->entries && size; i++){
-	/*	printk("\nMapping vaddr = %#lx, Physical Addr %#llx, Size %#llx\n",
-						(unsigned long)vaddr,
-						(unsigned long long)shmem->addr[i],
-						(unsigned long long)shmem->size[i]);
-	*/
-		mmap_size = (shmem->size[i] > size) ? size : shmem->size[i];
-		result = remap_pfn_range(vma, vaddr, (shmem->addr[i])>>PAGE_SHIFT,
-					mmap_size, vma->vm_page_prot);
-		if (result) return -EAGAIN;
-		vaddr += shmem->size[i];
-		size -= mmap_size;
-	}
-	return 0;
-}
-
-#if 0
-static uint32_t compare_values[10][2] =
-		/*	physaddr		opcode	*/
-		{	{0x80000120,0x67bdffd0},
-			{0x80010000,0x67bdffd0},
-			{0x80024aec,0x3c022400},
-			{0x80060000, 0x90840010}
-		};
-#endif
-		
-static int phnx_loader_map_helper(struct file *file, struct vm_area_struct *vma)
-{
-	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
-	uint64_t shm_addr;
-	unsigned long shm_size;
-	unsigned long size = 0;
-	int result = 0;
-	unsigned long shm_pfn_addr = 0;
-	struct inode *i;
-	uint32_t minor;
-//	int j=0;
-//	static uint64_t last_phys = 0, last_size=0;
-
-	i = (struct inode *)file->private_data;
-	minor = MINOR(i->i_rdev);
-
-	if(minor == XLR_MAP_SLAVE_DEVICE){
-		return phnx_loader_mmap_app_shared_mem(file, vma);
-	}else if(phnx_map_sh_mem){
-		shm_addr = (uint64_t)SHARED_MEM_ADDR;
-		shm_size = xlr_lib_shmem_size;
-		shm_pfn_addr = ((uint64_t)shm_addr >> PAGE_SHIFT);
-	}else if(phnx_map_persistent_mem){
-		shm_addr = (uint64_t)virt_to_phys(xlr_persistent_data_start);
-		shm_size = xlr_persistent_data_size;
-		shm_pfn_addr = ((uint64_t)shm_addr >> PAGE_SHIFT);
-	}else if(phnx_map_load_addr){
-		shm_addr = xlr_image_load_addr.phys;
-		shm_size = (unsigned long)xlr_image_load_addr.size;
-		shm_pfn_addr = ((uint64_t)shm_addr >> PAGE_SHIFT);
-#if 0
-		///////
-		if(last_phys){
-			uint32_t *virt = (uint32_t *)(0xa800000000000000ULL | (last_phys));
-			printk("checking last phys[%#lx] and last_size %ld \n",(unsigned long)last_phys,(unsigned long)last_size);
-			for(j=0; j<=(last_size/4); j++){
-				if(*(virt+j) != 0){
-					printk("Found some valid data...@ %#lx, data %#x\n",(unsigned long)virt, *virt);
-					break;
-				}
-			}
-			if(j > (last_size/4)){
-				printk("NO VALID DATA FOUND!!!!!\n");
-			}
-			last_phys = shm_addr;
-			last_size = shm_size;
-		}else{
-			uint32_t *virt = (uint32_t *)(0xa800000000000000ULL | (shm_addr));
-			last_phys = shm_addr;
-			last_size = shm_size;
-			printk("last_phys %#lx, last_size %ld\n", (unsigned long)last_phys,(unsigned long)last_size);
-			memset(virt, 0, shm_size);
-		}
-		///////
-		for(j=0; j<4; j++){
-			printk("VALUE @ phys - %#x is %#x, it should become %#x\n",compare_values[j][0],
-					*(unsigned int *)(0xa800000000000000ULL|compare_values[j][0]), compare_values[j][1]);
-		}
-#endif
-	}else if(phnx_map_app_shmem){
-		shm_addr = xlr_app_shmem_start;
-		shm_size = phnx_app_sh_mem_sz;
-		shm_pfn_addr = (unsigned long)((uint64_t)shm_addr >> PAGE_SHIFT);
-	}else{
-		printk("Invalid mmap command.\n");
-		return -EINVAL;
-	}
-
-	dbg_msg("shm_addr=%#lx, shm_size=%#lx \n", (unsigned long)shm_addr, (unsigned long)shm_size);
-	dbg_msg("offset = %#lx, vm_start=%#lx, vm_size=%#lx, vm_flags=%#lx, vm_page_prot=%#lx\n",
-		offset, vma->vm_start, vma->vm_end-vma->vm_start, vma->vm_flags, pgprot_val(vma->vm_page_prot));
-
-	if (!shm_addr) return -ENXIO;
-
-	if(shm_addr & (PAGE_SIZE-1)){
-		printk("Mmaping to invalid address ... %#llx\n",
-				(unsigned long long)shm_addr);
-		return -EINVAL;
-	}
-	if (offset >= shm_size) return -ESPIPE;
-
-	if (vma->vm_flags & VM_LOCKED) return -EPERM;
-
-	size = vma->vm_end - vma->vm_start;
-	pgprot_val (vma->vm_page_prot) &= ~_CACHE_MASK;
-
-	if(phnx_map_load_addr && (xlr_image_load_addr.flag == XLR_MAP_UNCACHED)){
-		pgprot_val (vma->vm_page_prot) |= _CACHE_UNCACHED;
-	}else{
-		pgprot_val (vma->vm_page_prot) |= _CACHE_CACHABLE_COW;
-	}
-	result = remap_pfn_range(vma, vma->vm_start, shm_pfn_addr, size,
-			vma->vm_page_prot);
-	if (result) {
-		panic("mmap failed!!\n");
-		return -EAGAIN;
-	}
-
-	return 0;
-}
-
-static int phnx_loader_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	int res;
-	res = phnx_loader_map_helper(file, vma);
-	phnx_map_app_shmem = 0;
-	phnx_map_sh_mem = 0;
-	phnx_map_persistent_mem = 0;
-	phnx_map_load_addr = 0;
-	return res;
-}
-
-static int phnx_loader_release (struct inode *inode, struct file *filp)
-{
-	return 0;
-}
-
-static int phnx_loader_flush(struct file *fp, fl_owner_t id)
-{
-	uint32_t minor=0;
-	struct inode *inode = (struct inode *)(fp->private_data);
-	minor = MINOR(inode->i_rdev);
-	if(minor == XLR_MAP_SLAVE_DEVICE){
-		return 0;
-	}
-	spin_lock(&phnx_loader_lock);
-	phnx_loader_user = 0;
-	spin_unlock(&phnx_loader_lock);
-	return 0;
-
-}
-
-struct file_operations phnx_loader_fops = {
-	.mmap         = phnx_loader_mmap,
-	.open	      = phnx_loader_open,
-	.ioctl        = phnx_loader_ioctl,
-	.release      = phnx_loader_release,
-	.flush        = phnx_loader_flush,
-	.compat_ioctl = phnx_loader_compat_ioctl,
-};
-
-static int __init
-phnx_loader_init(void)
-{
-	static int ret;
-
-	fdt_process ();
-
-	if(xlp_loader_support == 0){
-		printk("******************************\n");
-		printk("******************************\n");
-		printk("NO LOADER SUPPORT\n");
-		printk("******************************\n");
-		printk("******************************\n");
-		return -EINVAL;
-	}
-
-	spin_lock_init(&phnx_loader_lock);
-
-	ret = register_chrdev (XLP_APP_LOADER_MAJOR, PHNX_APP_LOADER_CHRDEV_NAME, &phnx_loader_fops);
-
-	if (ret < 0) {
-		printk("[%s]: register_chrdev failed\n", __FUNCTION__);
-		return ret;
-	}
-
-	/* Launch the threads now */
-	start_threads();
-
-	printk("Registered loader driver (%s) major no (%d)\n", PHNX_APP_LOADER_CHRDEV_NAME, XLP_APP_LOADER_MAJOR);
-
-	return 0;
-}
-
-static void __exit phnx_loader_exit(void)
-{
-	/*TODO: Clean up*/
-       unregister_chrdev (XLP_APP_LOADER_MAJOR, PHNX_APP_LOADER_CHRDEV_NAME);
-       printk("Unregistered loader driver (%s) major no (%d)\n", PHNX_APP_LOADER_CHRDEV_NAME, XLP_APP_LOADER_MAJOR);
-}
-
-module_init(phnx_loader_init);
-module_exit(phnx_loader_exit);
-
-MODULE_AUTHOR("Netlogic Microsystems");
-MODULE_DESCRIPTION("Netlogic XLP Linux Loader");
-MODULE_LICENSE("GPL");
-MODULE_VERSION("0.1");
diff --git a/drivers/misc/netlogic/linux-loader/phnx_loader.h b/drivers/misc/netlogic/linux-loader/phnx_loader.h
deleted file mode 100644
index 7c836e8..0000000
--- a/drivers/misc/netlogic/linux-loader/phnx_loader.h
+++ /dev/null
@@ -1,215 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_2# */
-
-
-#ifndef __USER_RMI_PHNX_LOADER_H
-#define __USER_RMI_PHNX_LOADER_H
-
-#include <asm/ioctl.h>
-#include <asm/types.h>
-
-#define PHNX_LOADER_INFO_MAGIC 			0x600ddeed
-#define XLR_MAP_SLAVE_DEVICE 			0x1
-#define XLR_MAP_UNCACHED 			0x1
-#define XLR_MAP_CACHED				0x2
-#define PHNX_APP_LOADER_CHRDEV_NAME 		"linux_loader"
-#define MAX_NUM_LOADER_MEM_BLK 			4
-#define SHARED_MEM_ADDR            		(3 << 20)
-#define XLP_APP_LOADER_MAJOR       		(245)
-
-#define PSB_MEM_MAP_MAX 			32
-#define PSB_IO_MAP_MAX 				32
-#define MAX_FRAGMENTS 				32
-
-#define MAX_TLB_MAPPINGS 			16
-#define MAX_ARGS 				16
-#define MAX_ARGV_LEN 				16
-
-#define PHNX_LOADER_IOC_MAGIC 			'X'
-#define PHNX_LOADER_IOC_SHMEM_SIZE 		_IOR(PHNX_LOADER_IOC_MAGIC, 0, unsigned int)
-#define PHNX_LOADER_IOC_MMAP_SHMEM 		_IOR(PHNX_LOADER_IOC_MAGIC, 1, unsigned int)
-#define PHNX_LOADER_IOC_LIB_BKP 		_IOR(PHNX_LOADER_IOC_MAGIC, 2, unsigned int)
-#define PHNX_LOADER_IOC_MMAP_LOAD_ADDR  	_IOR(PHNX_LOADER_IOC_MAGIC, 3, unsigned int)
-#define PHNX_LOADER_IOC_START_IPI 		_IOR(PHNX_LOADER_IOC_MAGIC, 4, unsigned int)
-#define PHNX_LOADER_IOC_STOP_IPI  		_IOR(PHNX_LOADER_IOC_MAGIC, 5, unsigned int)
-#define PHNX_LOADER_IOC_ALLOC_PERSISTENT_MEM  	_IOR(PHNX_LOADER_IOC_MAGIC, 6, unsigned int)
-#define PHNX_LOADER_IOC_MMAP_PERSISTENT_MEM  	_IOR(PHNX_LOADER_IOC_MAGIC, 7, unsigned int)
-#define PHNX_LOADER_IOC_FREE_PERSISTENT_MEM  	_IOR(PHNX_LOADER_IOC_MAGIC, 8, unsigned int)
-#define PHNX_LOADER_IOC_SHMEM_KSEG_ADDR 	_IOR(PHNX_LOADER_IOC_MAGIC, 10, unsigned int)
-#define PHNX_LOADER_IOC_LAUNCH_KSEG 		_IOR(PHNX_LOADER_IOC_MAGIC, 15, unsigned int)
-#define PHNX_LOADER_IOC_APP_SHMEM_SIZE 		_IOR(PHNX_LOADER_IOC_MAGIC, 25, unsigned int)
-#define PHNX_LOADER_IOC_APP_SHMEM_RESERVE 	_IOR(PHNX_LOADER_IOC_MAGIC, 35, unsigned int)
-#define PHNX_LOADER_IOC_MMAP_APP_SHMEM 		_IOR(PHNX_LOADER_IOC_MAGIC, 45, unsigned int)
-#define PHNX_LOADER_IOC_APP_SHMEM_PHYS 		_IOR(PHNX_LOADER_IOC_MAGIC, 55, unsigned int)
-#define PHNX_LOADER_STORE_ENV 			_IOR(PHNX_LOADER_IOC_MAGIC, 65, unsigned int)
-#define PHNX_LOADER_SEND_IPI 			_IOR(PHNX_LOADER_IOC_MAGIC, 75, unsigned int)
-#define PHNX_LOADER_IOC_STORE_APP_SHMEM_INFO 	_IOR(PHNX_LOADER_IOC_MAGIC, 85, unsigned int)
-#define PHNX_LOADER_IOC_GET_APP_SHMEM_INFO 	_IOR(PHNX_LOADER_IOC_MAGIC, 95, unsigned int)
-#define PHNX_LOADER_IOC_FDT_CPUMASK 		_IOWR(PHNX_LOADER_IOC_MAGIC, 105, unsigned int)
-
-enum { KUSEG_MODE, KSEG0_MODE };
-typedef enum {
-	STOP_THREAD=0xbeef,
-	START_THREAD,
-	RUN_FUNCTION, /* Used by wakeup and wakeup_os call */
-
-}loader_cmd;
-
-typedef enum {
-	THREAD_STOPPED=0x600d,
-	THREAD_RUNNING,
-	THREAD_SCHEDULED,
-}thread_status;
-
-struct cpu_tlb_mapping {
-	int page_size;
-	int asid;
-	int coherency;
-	int attr;
-	unsigned long virt;
-	uint64_t phys;
-};
-
-struct cpu_wakeup_info {
-	int            master_cpu;
-	int            map_count;
-	int            valid;
-	unsigned long  func;
-	unsigned long  args;
-	int            argc;
-	uint32_t       buddy_mask;
-	uint32_t       cpu_mask;
-	char          *argv[32]; /* RMIOS LIB NEEDS this to be 32 */
-	char           buf[256];/* must be > MAX_ARGS * MAX_ARGV_LEN + some buffer */
-	struct cpu_tlb_mapping map[MAX_TLB_MAPPINGS];
-};
-
-/* SHARED memory structure b/w loader app, linux and RMIOS apps */
-typedef struct phnx_loader_shared_struct {
-	unsigned long park_entry;
-	loader_cmd    cmd;
-	thread_status thr_status;
-	unsigned long entry; /* Entry point address */
-	int 	      run_mode;
-	struct cpu_wakeup_info run_info;
-	uint32_t 	app_sh_mem_sz; /* Size of the shared memory */
-	unsigned long	sp;/* Used for reentry */
-	unsigned long	gp;
-}phnx_loader_shared_struct_t;
-
-
-/* This structure is passed to all applications launched from the linux
-   loader through OS 7 scratch register
-   */
-typedef struct phnx_loader_info {
-	uint32_t magic;
-	/* phnx_loader_shared_struct_t for CPU 0 will start here */
-	unsigned long sh_mem_start;
-	/* Size of the shared memory b/w linux apps and rmios apps  */
-	uint32_t app_sh_mem_size;
-	uint8_t printk_lock[16]; /* used for printk */
-}phnx_loader_info_t;
-
-struct psb_mem_map {
-	int nr_map;
-	struct psb_mem_map_entry {
-		uint64_t addr;  /* start of memory segment */
-		uint64_t size;  /* size of memory segment */
-		uint32_t type;      /* type of memory segment */
-	} map[PSB_MEM_MAP_MAX];
-};
-
-struct psb_io_map {
-	int nr_map;
-	struct psb_io_map_entry {
-		uint64_t addr;  /* start of IO segment */
-		uint64_t size;  /* size of IO segment */
-		long type;      /* type of IO segment */
-	} map[PSB_IO_MAP_MAX];
-};
-
-struct r_exception_region {
-	    unsigned int data[1024];
-};
-
-struct xlr_rmios_pt_regs {
-	unsigned long long pad0[6];
-
-	unsigned long long regs[32];
-
-	unsigned long long cp0_status;
-	unsigned long long hi;
-	unsigned long long lo;
-
-	/*
-	 * saved cp0 registers
-	 */
-	unsigned long long cp0_badvaddr;
-	unsigned long long cp0_cause;
-	unsigned long long cp0_epc;
-};
-
-struct domain_info
-{
-	uint32_t domain;
-	uint32_t cpumask;	////cpu mask -- currently 32bit.
-	uint32_t mastercpu;	///master cpu id
-	uint32_t mode; //// 0-smp, 1-amp
-	uint64_t app_addr;	//Hyperapp app load address
-	uint64_t fdt_blob;	//FDT blob address.
-};
-
-struct wakeup_info
-{
-       int vcpu;
-       unsigned long long func;
-       unsigned long long data;
-};
-
-struct xlr_load_addr
-{
-       uint64_t phys;
-       uint64_t size;
-       uint32_t flag;
-};
-
-struct xlr_lib_shared_mem
-{
-	uint64_t entries;
-	uint64_t tot_size;
-	uint64_t addr[MAX_FRAGMENTS];
-	uint64_t size[MAX_FRAGMENTS];
-};
-
-struct loader_mem_info{
-	uint64_t size;
-	uint64_t start_addr;
-};
-
-#endif
diff --git a/drivers/misc/netlogic/linux-loader/reload_irq_handler.S b/drivers/misc/netlogic/linux-loader/reload_irq_handler.S
deleted file mode 100644
index 942b63e..0000000
--- a/drivers/misc/netlogic/linux-loader/reload_irq_handler.S
+++ /dev/null
@@ -1,80 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_2# */
-
-
-#include <asm/mipsregs.h>
-#include <asm/regdef.h>
-#include <asm/asm.h> 
-#include <asm/stackframe.h>
-#include <asm/asm-offsets.h>
-#include "xlr_rmios_stackframe.h"
-
-#define KU_USER 0x10
-     
-	.text
-        .set    push
-        .set    noreorder
-        .set    mips4
-        .align  5
-        NESTED(reload_irq_handler, K_STACK_SIZE, sp)
-        save_stack_frame 
-        CLI
-
-        /* Read EIRR :   */
-        .word   0x40304806        /* dmfc0 s0, eirr */
-
-        /* If no interrupts, return */
-        beqz    s0, 2f
-        nop
-
-1:
-        /* retrieve the highest priority interrupt */
-        .word   0x72118824        /* dclz s1 s0 */
-        dsubu   a0, zero, s1
-        daddiu  a0, a0, 63
-        /* a0 now has irq# */
-        move    a1, sp
-        /* a1 now has sp */
-        /* first things first : clear the irq in eirr
-        *  note that setting a bit in eirr actually clears it!
-        */
-        li      s0, 1
-        dsllv   s0, s0, a0
-        .word   0x40b04806        /* dmtc0 s0, eirr */
-
-
-        /* a0 = irq, a1 = sp (regs) */
-        jal     reload_do_IRQ
-        nop
-2:      j       r_ret_from_irq
-        nop
-
-        .set pop
-        END(reload_irq_handler)
-
diff --git a/drivers/misc/netlogic/linux-loader/traps.c b/drivers/misc/netlogic/linux-loader/traps.c
deleted file mode 100644
index 2c3df4c..0000000
--- a/drivers/misc/netlogic/linux-loader/traps.c
+++ /dev/null
@@ -1,242 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_2# */
-
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/smp.h>
-
-#include <asm/mipsregs.h>
-#include <asm/asm.h>
-#include <asm/addrspace.h>
-#include "xlr_boot_lib.h"
-#include <asm/netlogic/phnx_loader.h>
-#include "xlr_rmios_stackframe.h"
-
-extern int xlr_loader_print(const char *fmt, ...);
-//extern void xlr_loader_show_regs(struct xlr_rmios_pt_regs *regs);
-#define Message(a,b...) 
-#define ErrorMsg(a,b...) xlr_loader_print(a,##b)
-unsigned int r_exception_handlers[32];
-
-struct r_exception_region *r_exception_vectors = 
-			(struct r_exception_region *)CKSEG0;
-
-
-void xlp_flush_local_icache(void);
-void xlp_flush_local_dcache(void);
-
-extern void reload_handle_reserved(void);
-//extern void reload_irq_handler(void);
-
-extern char    reload_except_vec_tlbrefill[], reload_except_vec_xtlbrefill[];
-extern char    reload_except_vec_genex[], reload_except_vec_cacheerr[];
-extern char    reload_except_vec_vecint[];
-
-void xlr_loader_show_regs(struct xlr_rmios_pt_regs *regs)
-{
-    /* Saved main processor registers */
-    ErrorMsg("\n$0 :0x%016llx 0x%016llx 0x%016llx 0x%016llx",
-            0ULL, regs->regs[1], regs->regs[2], regs->regs[3]);
-    ErrorMsg("\n$4 :0x%016llx 0x%016llx 0x%016llx 0x%016llx",
-            regs->regs[4], regs->regs[5], regs->regs[6], regs->regs[7]);
-    ErrorMsg("\n$8 :0x%016llx 0x%016llx 0x%016llx 0x%016llx", regs->regs[8],  
-			regs->regs[9],  regs->regs[10], regs->regs[11]);
-    ErrorMsg("\n$12 :0x%016llx 0x%016llx 0x%016llx 0x%016llx",
-                  regs->regs[12], regs->regs[13], regs->regs[14], regs->regs[15]);
-    ErrorMsg("\n$16 :0x%016llx 0x%016llx 0x%016llx 0x%016llx",
-            regs->regs[16], regs->regs[17], regs->regs[18], regs->regs[19]);
-    ErrorMsg("\n$20 :0x%016llx 0x%016llx 0x%016llx 0x%016llx",
-            regs->regs[20], regs->regs[21], regs->regs[22], regs->regs[23]);
-    ErrorMsg("\n$24 :0x%016llx 0x%016llx 0x%016llx 0x%016llx",
-			   regs->regs[24], regs->regs[25], regs->regs[26], regs->regs[27]);
-    ErrorMsg("\n$28 :0x%016llx 0x%016llx 0x%016llx 0x%016llx\n",            
-			   regs->regs[28], regs->regs[29], regs->regs[30], regs->regs[31]);
-    /* Saved cp0 registers */
-    ErrorMsg("Hi : 0x%016llx\n", regs->hi);
-    ErrorMsg("Lo : 0x%016llx\n", regs->lo);
-    ErrorMsg("epc  : 0x%016llx    \nStatus: 0x%016llx\nCause : 0x%016llx\n",
-        regs->cp0_epc, regs->cp0_status, regs->cp0_cause);
-}
-
-static void *r_set_except_vector(int n, void *addr)
-{
-	unsigned long handler = (unsigned long) addr;
-	unsigned long old_handler = r_exception_handlers[n];
-
-	r_exception_handlers[n] = (unsigned int)handler;
-	return (void *)old_handler;
-}
-
-#define CP0_EBASE     $15
-#if 0
-void reload_generic_trap_init(void)
-{
-	int    i;
-	unsigned long ebase;
-	int cpu = 32;
-	for (i = 1; i < 32; i++) {
-		r_set_except_vector(i, reload_handle_reserved);
-	}
-
-	/* Set the Interrupt - Exception Handler (Ex Code 0) */
-	r_set_except_vector(0, reload_irq_handler);
-	ebase = (unsigned long)&r_exception_vectors[cpu];
-
-	memcpy((void *)(ebase       ),  reload_except_vec_tlbrefill, 0x80);
-	memcpy((void *)(ebase + 0x80),  reload_except_vec_xtlbrefill, 0x80);
-	memcpy((void *)(ebase + 0x100), reload_except_vec_cacheerr, 0x80);
-	memcpy((void *)(ebase + 0x180), reload_except_vec_genex, 0x80);
-	memcpy((void *)(ebase + 0x200), reload_except_vec_vecint, 0x80);
-	xlp_flush_local_icache();
-	xlp_flush_local_dcache();
-}
-#endif
-void reload_trap_init(void)
-{
-#if 0
-	int    i;
-	unsigned long ebase;
-	int cpu;
-	cpu = hard_smp_processor_id();
-
-	/* Setup default vectors */
-	for (i = 1; i < 32; i++) {
-		r_set_except_vector(i, reload_handle_reserved);
-	}
-
-	/* Set the Interrupt - Exception Handler (Ex Code 0) */
-	r_set_except_vector(0, reload_irq_handler);
-
-	/* Copy the generic exception handler code to it's final destination. */
-
-	ebase = (unsigned long)&r_exception_vectors[cpu];
-
-	memcpy((void *)(ebase       ),  reload_except_vec_tlbrefill, 0x80);
-	memcpy((void *)(ebase + 0x80),  reload_except_vec_xtlbrefill, 0x80);
-	memcpy((void *)(ebase + 0x100), reload_except_vec_cacheerr, 0x80);
-	memcpy((void *)(ebase + 0x180), reload_except_vec_genex, 0x80);
-	memcpy((void *)(ebase + 0x200), reload_except_vec_vecint, 0x80);
-
-	/* set up the ebase register */
-	__write_32bit_c0_register($15, 1, (uint32_t)(ebase & 0x3ffff000));
-	/* Flush I-Cache */
-	xlp_flush_local_icache();
-
-	// Note: Need to do this only because the cacheerr exception vector may be still in
-	// D-cache when cpu takes the exception
-
-	xlp_flush_local_dcache();
-#endif
-}
-
-unsigned int reload_do_IRQ(int irq, struct xlr_rmios_pt_regs *regs)
-{
-	int cpu ;
-	cpu = hard_smp_processor_id();
-	switch (irq) {
-		case IRQ_WAKEUP_CPU_IPI:
-		case IRQ_STOP_CPU_IPI:
-		case IRQ_RECLAIM_CPU_RSRC_IPI:
-			xlr_lib_intr_handler(irq);
-			break;
-		default:
-			ErrorMsg(" Received Unhandled Interrupt = %d!\n", irq);
-			break;
-	}
-	return 0;
-}
-
-void xlr_tlb_panic(struct xlr_rmios_pt_regs *pt_regs)
-{
-       int id = hard_smp_processor_id();
-       reset_printk_base_lock();
-       xlr_loader_show_regs(pt_regs);
-       ErrorMsg("\nUnahandled TLB Refill Exception!!");
-       ErrorMsg("\ncpu_%d: PANIC!!",id);
-       ErrorMsg("\nStop this vcpu using \"stop_vcpu -m <mask>\" cmd.\n");
-       __asm__ __volatile__(
-                     "mtc0 %0, $14\n"
-                     "move $4,%1\n"
-                     "nop\n"
-                     "eret\n"
-                     "nop\n"
-                     ::"r"(xlr_lib_entry),"r"(id)
-                     );
-}
-
-void xlr_xtlb_panic(struct xlr_rmios_pt_regs *pt_regs)
-{
-	int id = hard_smp_processor_id();
-        reset_printk_base_lock();
-	xlr_loader_show_regs(pt_regs);
-        ErrorMsg("\nUnahandled XTLB Refill Exception!!");
-        ErrorMsg("\nStop this vcpu using \"stop_vcpu -m <mask>\" cmd.\n");
-        __asm__ __volatile__(
-                "mtc0 %0, $14\n"
-                "move $4,%1\n"
-                "nop\n"
-                "eret\n"
-                "nop\n"
-                ::"r"(xlr_lib_entry),"r"(id)
-        );
-}
-void xlr_vecint_panic(struct xlr_rmios_pt_regs *pt_regs)
-{
-	int id = hard_smp_processor_id();
-        reset_printk_base_lock();
-	xlr_loader_show_regs(pt_regs);
-        ErrorMsg("\nUnahandled Vectored Interrupt !!");
-        ErrorMsg("\nStop this vcpu using \"stop_vcpu -m <mask>\" cmd.\n");
-        __asm__ __volatile__(
-                "mtc0 %0, $14\n"
-                "move $4,%1\n"
-                "nop\n"
-                "eret\n"
-                "nop\n"
-                ::"r"(xlr_lib_entry),"r"(id)
-        );
-}
-
-void do_reload_setup(struct xlr_rmios_pt_regs *regs)
-{
-	int id = hard_smp_processor_id();
-        reset_printk_base_lock();
-	xlr_loader_show_regs(regs);
-	ErrorMsg("\ncpu_%d: PANIC!!",id);
-	ErrorMsg("Stop this vcpu using stop -m <mask> cmd\n");
-        __asm__ __volatile__(
-                "mtc0 %0, $14\n"
-                "move $4,%1\n"
-                "nop\n"
-                "eret\n"
-                "nop\n"
-                ::"r"(xlr_lib_entry),"r"(id)
-        );
-}
diff --git a/drivers/misc/netlogic/linux-loader/uart.c b/drivers/misc/netlogic/linux-loader/uart.c
deleted file mode 100644
index 602ed30..0000000
--- a/drivers/misc/netlogic/linux-loader/uart.c
+++ /dev/null
@@ -1,328 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_2# */
-
-#include <linux/spinlock.h>
-#include <linux/mm.h>
-#include <linux/bootmem.h>
-#include <linux/init.h>
-
-#include <asm/irq.h>
-#include <asm/io.h>
-#include <asm/bootinfo.h>
-#include <asm/addrspace.h>
-#include <asm/reboot.h>
-#include <asm/time.h>
-#include <linux/interrupt.h>
-#include <asm/atomic.h>
-#include <asm/bootinfo.h>
-
-//#include <asm/rmi/sim.h>
-//#include <asm/rmi/mips-exts.h>
-//#include <asm/rmi/iomap.h>
-//#include <asm/rmi/xlr_virt_uart.h>
-#include "uart.h"
-#include "fifo.h"
-
-#if 0
-static struct fifo tx_fifo;
-static struct fifo rx_fifo;
-
-virt_uart virt_uart_outbuf[32];
-
-extern unsigned char load_env[32][6];
-extern int loader_processor_id(void);
-
-#define TX_BURST_SIZE 1
-
-#define DMESG_BUFSIZE 0x1000
-
-
-int tstbyte(void)
-{
-	int data = 0;
-	if (fifo_dequeue(&rx_fifo, &data)) {
-		/* FIFO not empty */
-		return 1;
-	}
-	return 0;
-}
-
-
-char inbyte(void)
-{
-	int data = 0;
-	int lsr = 0;
-	int i = 0;
-	volatile uint32_t *mmio = phoenix_io_mmio(PHOENIX_IO_UART_1_OFFSET);
-
-	if (fifo_dequeue(&rx_fifo, &data)) {
-		/* characters to be read already in fifo */
-		return (char)data;
-	}
-
-	for (;;) {
-
-		lsr = be32_to_cpu(phoenix_read_reg(mmio,UART_LSR));
-
-		if (lsr & 0x20) {
-			/* Tx available, try to send any characters */
-			for (i = 0;
-			     i < TX_BURST_SIZE && fifo_dequeue(&tx_fifo, &data);
-			     i++) {
-			//	uart_outbyte(mmio, data);
-                phoenix_write_reg(mmio,UART_THR, cpu_to_be32(data));
-			}
-		}
-		if (lsr & 0x80) {
-			/* parity/frame/break - push a 0! */
-			if (!fifo_enqueue(&rx_fifo, 0))
-				break;
-		}
-		if (lsr & 0x01) {
-			/* Rx Data */
-			data = be32_to_cpu(phoenix_read_reg(mmio,UART_RHR));
-			if (!fifo_enqueue(&rx_fifo, data))
-				break;
-		}
-		if (!fifo_empty(&rx_fifo))
-			break;
-	}
-
-	fifo_dequeue(&rx_fifo, &data);
-
-	return (char)data;
-}
-
-
-void virt_uart_outbyte(char c,int thrd_id)
-{
-
-       if(*(virt_uart_outbuf[thrd_id].status) != VIRT_UART_OPENED)
-               return;
-
-       while (((*(virt_uart_outbuf[thrd_id].tx_pro) + 1) % (USER_RESULT_SIZE))  ==
-               (*(virt_uart_outbuf[thrd_id].tx_con)))
-                               ;
-
-         *((virt_uart_outbuf[thrd_id].tx_fifo) + *(virt_uart_outbuf[thrd_id].tx_pro)) = c;
-         *(virt_uart_outbuf[thrd_id].tx_pro) = (*(virt_uart_outbuf[thrd_id].tx_pro) + 1) % (USER_RESULT_SIZE);
-	
-	if (c == '\n') {
-	       while (((*(virt_uart_outbuf[thrd_id].tx_pro) + 1) % (USER_RESULT_SIZE))  ==
-        	       (*(virt_uart_outbuf[thrd_id].tx_con)))
-                               ;
-                *((virt_uart_outbuf[thrd_id].tx_fifo) + *(virt_uart_outbuf[thrd_id].tx_pro)) = '\r';
-     		*(virt_uart_outbuf[thrd_id].tx_pro) = (*(virt_uart_outbuf[thrd_id].tx_pro) + 1) % (USER_RESULT_SIZE);
-	}
-        return ;
-}
-
-int outbyte(char c)
-{
-	int data = 0;
-	int lsr = 0;
-	int i = 0;
-	int thrd_id;
-
-	volatile uint32_t *mmio = phoenix_io_mmio(PHOENIX_IO_UART_1_OFFSET);
-
-	thrd_id = loader_processor_id();
-
-       if ( strcmp(load_env[thrd_id],"vuart") == 0)    {
-               virt_uart_outbyte(c,thrd_id);
-               return 0;
-       }
-	if (c == '\n') {
-		char cr = '\r';
-		if (!fifo_enqueue(&tx_fifo, (int)cr)) {
-			/* Too bad tx fifo is full, drop the character */
-			return 1;
-		}
-	}
-	if (!fifo_enqueue(&tx_fifo, (int)c)) {
-		/* Too bad tx fifo is full, drop the character */
-		return 1;
-	}
-
-	/* accumalate some more characters */
-	if ((fifo_size(&tx_fifo) < TX_BURST_SIZE) && (c != '\n') && (c != '\r'))
-		return 0;
-	for (;;) {
-
-		if (fifo_empty(&tx_fifo))
-			break;
-
-		/* wait for Tx empty indication */
-		for (;;) {
-
-			lsr = be32_to_cpu(phoenix_read_reg(mmio,UART_LSR));
-
-			if (lsr & 0x80) {
-				/* parity/frame/break - push a 0! */
-				fifo_enqueue(&rx_fifo, 0);
-			}
-			if (lsr & 0x01) {
-				/* Rx Data */
-				data = 
-				be32_to_cpu(phoenix_read_reg(mmio,UART_RHR));
-				fifo_enqueue(&rx_fifo, data);
-			}
-			/* Tx Fifo empty */
-			if (lsr & 0x20)
-				break;
-		}
-
-		/* transmit upto TX_BURST_SIZE char */
-		for (i = 0; i < TX_BURST_SIZE && fifo_dequeue(&tx_fifo, &data);
-		     i++) {
-			//uart_outbyte(mmio, data);
-                phoenix_write_reg(mmio,UART_THR, cpu_to_be32(data));
-		}
-	}
-
-	return 0;
-}
-
-void
-serial_puts (const char *s)
-{
-    while (*s) {
-        outbyte (*s++);
-    }
-}
-
-int putch(int ch){
-    return outbyte(ch);
-}
-void uart_flush_tx_buf(void)
-{
-	int data = 0;
-	int lsr = 0;
-	volatile uint32_t *mmio = phoenix_io_mmio(PHOENIX_IO_UART_1_OFFSET);
-
-	for (;;) {
-
-		lsr = be32_to_cpu(phoenix_read_reg(mmio,UART_LSR));
-
-		if (lsr & 0x20) {
-
-			if (!fifo_dequeue(&tx_fifo, &data))
-				break;
-
-			/* Tx available, try to send more characters */
-		//	uart_outbyte(mmio, data);
-                	phoenix_write_reg(mmio,UART_THR, cpu_to_be32(data));
-		}
-	}
-}
-
-    
-spinlock_t printf_lock;
-
-void xlr_virt_uart_init(void)
-{
-       int i, size;
-
-       size = USER_CMD_SIZE + USER_RESULT_SIZE + sizeof(unsigned int) * 5;
-
-         for (i=0; i<32; i++){
-                 virt_uart_outbuf[i].rx_fifo = i*size + (unsigned char *) VIRT_UART_BUF_START;
-                 virt_uart_outbuf[i].rx_pro = (unsigned int *)(virt_uart_outbuf[i].rx_fifo + USER_CMD_SIZE);
-                 virt_uart_outbuf[i].rx_con = (unsigned int *)(virt_uart_outbuf[i].rx_pro + 1);
-                 virt_uart_outbuf[i].tx_fifo = (unsigned char *) (virt_uart_outbuf[i].rx_con + 1);
-                 virt_uart_outbuf[i].tx_pro = (unsigned int *) (virt_uart_outbuf[i].tx_fifo + USER_RESULT_SIZE);
-                 virt_uart_outbuf[i].tx_con = (unsigned int *) (virt_uart_outbuf[i].tx_pro + 1);
-                 virt_uart_outbuf[i].status = (unsigned int *) (virt_uart_outbuf[i].tx_con + 1);
-         }
-}
-
-void xlr_uart_init(void)
-{
-	volatile uint32_t *mmio = phoenix_io_mmio(PHOENIX_IO_UART_1_OFFSET);
-
-	fifo_init(&rx_fifo);
-	fifo_init(&tx_fifo);
-	spin_lock_init(&printf_lock);
-	xlr_virt_uart_init();
-
-	/* Set up the baud rate */
-	phoenix_write_reg(mmio,UART_LCR,
-		     cpu_to_be32(be32_to_cpu(phoenix_read_reg(mmio,UART_LCR)) 
-			     		| (1 << 7)));
-	phoenix_write_reg(mmio,UART_DLB_1,  cpu_to_be32(UART_BR_DLB1));
-	phoenix_write_reg(mmio,UART_DLB_2, cpu_to_be32(UART_BR_DLB2));
-	phoenix_write_reg(mmio,UART_LCR, 
-		cpu_to_be32(be32_to_cpu(
-			phoenix_read_reg(mmio, UART_LCR)) & ~(1 << 7)));
-
-}
-
-
-
-char xlr_loader_get_char(void)
-{
-	return inbyte();
-}
-
-
-#define CFG_PBSIZE 128
-int puts (const char *s);
-int xlr_loader_print(const char *fmt, ...)
-{
-	va_list args;
-	unsigned long flags;
-	char printbuffer[CFG_PBSIZE];
-	int i;
-
-	local_irq_save(flags);
-	spin_lock(&printf_lock);
-
-	va_start(args, fmt);
-	/* For this to work, printbuffer must be larger than
-	 * anything we ever want to print.
-	 */
-	i = vsprintf (printbuffer, fmt, args);
-	va_end (args);
-
-
-	/* Print the string */
-	puts (printbuffer);
-	/* flush the transmit buffer */
-	uart_flush_tx_buf();
-	spin_unlock(&printf_lock);
-	local_irq_restore(flags);
-	return 0;
-}
-
-int xlr_loader_put_char(char c) 
-{
-	outbyte(c);
-	return 0;
-}
-#endif
diff --git a/drivers/misc/netlogic/linux-loader/uart.h b/drivers/misc/netlogic/linux-loader/uart.h
deleted file mode 100644
index f9866c0..0000000
--- a/drivers/misc/netlogic/linux-loader/uart.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_2# */
-
-
-#ifndef _UART_H
-#define _UART_H
-
-#define UART_RHR 0
-#define UART_THR 0
-#define UART_IER 1
-#define UART_IIR 2
-#define UART_FCR 2
-#define UART_LCR 3
-#define UART_MCR 4
-#define UART_LSR 5
-#define UART_MSR 6
-
-#define UART_DLB_1 0
-#define UART_DLB_2 1
-
-#define UART_DEBUG_1 8
-#define UART_DEBUG_2 9
-
-// baud rate divisors
-#define UART_BR9600_DLB1 0xad
-#define UART_BR9600_DLB2 0x01
-
-#define UART_BR38400_DLB1 0x6b
-#define UART_BR38400_DLB2 0x00
-
-#define UART_BR115200_DLB1 0x23
-#define UART_BR115200_DLB2 0x00
-
-//#define UART_BR_DLB1 UART_BR9600_DLB1
-//#define UART_BR_DLB2 UART_BR9600_DLB2
-#ifndef PHOENIX_SIM
-#define UART_BR_DLB1 UART_BR38400_DLB1
-#define UART_BR_DLB2 UART_BR38400_DLB2
-#else
-#define UART_BR_DLB1 UART_BR115200_DLB1
-#define UART_BR_DLB2 UART_BR115200_DLB2
-#endif
-
-#ifndef __ASSEMBLY__
-extern int outbyte(char c);
-extern char inbyte(void);
-#endif
-
-#endif
diff --git a/drivers/misc/netlogic/linux-loader/xlr_boot_lib.h b/drivers/misc/netlogic/linux-loader/xlr_boot_lib.h
deleted file mode 100644
index 3645591..0000000
--- a/drivers/misc/netlogic/linux-loader/xlr_boot_lib.h
+++ /dev/null
@@ -1,413 +0,0 @@
-/*-
- * Copyright 2003-2013 Broadcom Corporation
- * 
- * This program is the proprietary software of Broadcom Corporation and/or its
- * licensors, and may only be used, duplicated, modified or distributed pursuant
- * to the terms and conditions of a separate, written license agreement executed
- * between you and Broadcom (an "Authorized License"). Except as set forth in
- * an Authorized License, Broadcom grants no license (express or implied), right
- * to use, or waiver of any kind with respect to the Software, and Broadcom
- * expressly eserves all rights in and to the Software and all intellectual
- * tproperty rights herein. IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO
- * RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM
- * AND DISCONTINUE ALL USE OF THE SOFTWARE.
- * 
- * Except as expressly set forth in the Authorized License,
- * 
- * 1.This program, including its structure, sequence and organization,
- * constitutes the valuable trade secrets of Broadcom, and you shall use all
- * reasonable efforts to protect the confidentiality thereof, and to use this
- * information only in connection with your use of Broadcom integrated circuit
- * products.
- * 
- * 2.TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
- * "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS
- * OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT
- * TO THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED
- * WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A
- * PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET
- * ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE
- * ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
- *
- * 3.TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
- * ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT,
- * OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO YOUR
- * USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF THE AMOUNT
- * ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER.
- * THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF ESSENTIAL
- * PURPOSE OF ANY LIMITED REMEDY.
- *
- *  * #BRCM_3# */
-
-#ifndef __XLR_BOOT_LIB_H
-#define __XLR_BOOT_LIB_H
-typedef struct {
-    volatile unsigned int lock;
-} lib_spinlock_t;
-
-#define CPU_RUNNING 0x1
-#define CPU_STOPPED 0x2
-#define CPU_WAIT_TO_RELEASE_RESOURCE 0x3
-#define CPU_RESOURCE_RELEASED 0x4
-
-#define MAX_ELF_SEGMENTS 16
-#define MAX_TLB_MAPPINGS 16
-#define MAX_EXTENDED_TLBS 512
-#define MAX_WIRED_ENTRIES 14
-#include "xlr_lib_platform.h"
-
-enum {KUSEG_APP, KSEG0_APP};
-
-typedef volatile uint32_t xlr_lib_phnx_reg_t;
-
-#define IRQ_STOP_CPU_IPI 		51
-#define IRQ_WAKEUP_CPU_IPI 		52
-#define IRQ_RECLAIM_CPU_RSRC_IPI 	53
-
-#define XLR_PERSISTENT_MEMORY_MAGIC 	0xdead900d
-#define NMI_BL_SHARED_REGION 		0x1f000000
-
-#define KSEG0_MEM_MAP 			0x10000001
-#define KUSEG_MEM_MAP 			0x10000002
-
-#define XLR_ARGV_BUF_SIZE 		256
-#define XLR_ENV_BUF_SIZE 		256
-#define XLR_MAX_ARGV 			32
-#define XLR_MAX_ENV 			32
-#define XLR_NUM_CPU 			32
-
-#define EXTENDED_BOOT_MAGIC 		0xE88E8DED
-#define FREE_TLB_NONSHARED 		1
-#define FREE_TLB_ALL 			2
-
-struct proc_section_info
-{
-        int mode;
-        uint32_t vaddr[MAX_ELF_SEGMENTS];
-        uint32_t size[MAX_ELF_SEGMENTS];
-        uint32_t tlb_vaddr[MAX_TLB_MAPPINGS];
-        uint32_t tlb_size[MAX_TLB_MAPPINGS];
-        uint64_t tlb_phys[MAX_TLB_MAPPINGS];
-};
-
-
-struct lib_cpu_tlb_mapping {
-	int page_size;
-	int asid;
-	int coherency;
-	int attr;
-	uint32_t virt;
-	uint64_t phys;
-};
-
-
-struct core_segment_info
-{
-	uint64_t vaddr;
-	uint64_t memsz;
-	uint32_t flags;
-};
-
-
-struct xlr_vcpu_wakeup_info {
-
-	volatile uint32_t cpu_status; /*RUNNING or STOPPED*/
- 
-	/*Validity for this structure.*/
-	int            valid;
- 
-	/*For master vcpu this is an elf_entry, for buddy vcpus this points to the function pointer passed in "wakeup" call.*/
-	int32_t func,args;
-
-	/*Stack pointer for this cpu.*/
-	uint64_t sp, gp;
-
-	/*Master CPU No.*/
-	int master_cpu;
- 
-	/*Master CPU Mask.*/
-	uint32_t master_mask;
-
-	/*Buddy CPU Mask*/
-	uint32_t buddy_mask;
-
-	uint32_t       psb_os_cpu_map;
- 
-	/*Argv passed while launching application. These all are pointers in 
-    argv_buf.*/
-
-	int argc; /*No. of arg*/
-	uint32_t argv[XLR_MAX_ARGV];
-	char argv_buf[XLR_ARGV_BUF_SIZE]; /*Actual Argv */
- 
-	/*No. Of Valid TLB Entries*/
-	int            map_count;
-
-	/*Valid only in case of kuseg applications. Kuseg master and buddy vcpus 
-	both will have valid entries here.*/
-	struct lib_cpu_tlb_mapping map[MAX_TLB_MAPPINGS];
-	struct core_segment_info seg_info[MAX_ELF_SEGMENTS];
- 
-	/*Environment variables, envs is an array of pointers. All pointers points 
-	in to env_buf. Output io device is specfied in one of the environment 
-    variale as ttyS0 or ttyS1. Generic bootloader always sets this to ttyS0*/
-	int env; /*No. Of env*/
-	uint32_t envs[XLR_MAX_ENV];   
-	char env_buf[XLR_ENV_BUF_SIZE];
-
-	/*Mode to decide Kuseg/Kseg applications*/
-	uint32_t mode; 
-
-	/*This points to same physical memory (kseg0), for all applications. "printk" routine of rmios_lib will hold this lock while dumping*/
-	int32_t printk_lock;
-
-	/*Set when we are launching an kseg application on other than vcpu0*/
-	int kseg_master;
-
-	/*Reentry Function For KUSEG Applications, Each vcpu can have its own 
-	reentry function.*/
-	int32_t reentry_function;
-	uint32_t reentry_args;
-
-	/*Reserved shared memory between all application launched by bootloader*/
-	uint64_t app_shared_mem_addr;
-	uint64_t app_shared_mem_size;
-	uint64_t app_shared_mem_orig;
-
-	/*Lock used to avoid window between wakeup and stop*/
-	int32_t loader_lock;
-
-	/*This must contain same values in all xlr_vcpu_wakeup_info structures.
-	  This is used to avoid window while freeing memory.
-	*/
-	/*unsigned long *global_wakeup_mask;*/
-	int32_t global_wakeup_mask;
-
-	/*Unused variables - free for future use*/
-	union {
-		uint32_t unused_0;
-		struct vcpu_extended_info *vcpu_extended_info_ptr;
-	};
-	
-	/*XLP - LOADING INFO for NETOS*/
-	uint64_t fdt_base;	//a0
-	uint64_t app_addr;	//a1
-	uint64_t domain;	//a2
-};
-
-struct per_cpu_info_loader {
-	uint64_t num_tlbs;
-	uint64_t ext_tlb_ptr;
-};
-
-struct per_cpu_info{
-	uint64_t num_tlbs;
-	struct tlb *ext_tlb_ptr;
-};
-
-struct device_locks{
-	unsigned char uart0_lock[32];
-	unsigned char uart1_lock[32];
-	unsigned char global_lock[32];
-	unsigned char bridge_io_lock[32];
-	/* Following locks wont be used often. Put them in the same cacheline */
-	unsigned char gmac_lock[8][4];
-	unsigned char xgmac_lock[2][4];
-	unsigned char spi4_lock[2][4];
-} __attribute__ ((aligned(32)));
-
-struct vcpu_extended_info {
-	uint64_t magic;
-	uint64_t ver_major;
-	uint64_t ver_minor;
-	uint64_t size;
-	uint64_t per_cpu_info_size;
-	uint64_t per_cpu_info_ptr;
-	uint64_t uart0_lock;
-	uint64_t uart1_lock;
-	uint64_t global_lock;
-	uint64_t bridge_io_lock;
-	uint64_t gmac_lock[8];
-	uint64_t xgmac_lock[2];
-	uint64_t spi4_lock[2];
-	struct xlr_lib_shared_mem loader_shmem;
-};
-
-struct ext_tlb{
-	uint32_t page_size;
-	uint32_t asid;
-	uint32_t coherency;
-	uint32_t attr;
-	uint64_t virt;
-	uint64_t phys;
-};
-
-
-/*GLOBAL STRUCTURES SHARED BETWEEN ALL VCPUS
-	xlr_lib_load_import:	Used For Elfload.
-	xlr_lib_launch_import:	Used During Launching any application, 
-							for setup tlb, wakeup, prelaunchinit etc.
-*/
-
-/*Foll. structure contains implementation dependent routines and variables. This must be filled by the loader implementation. Strucure should be defined in KSEG0 region, and memory has to be persistent. Library may change values of this structure variables, and also expects value to be same when load_init/launch_init gets call second time.
-	
-	Linux Loader:	In case of linux loader, "loading" is done from user space and "launhing" is done from kernel space, so foll routines will have mixed kernel/user space address. This will be mmaped structure for linux loader, whenver any application is launched using "load" cmd, he has to set this structure with proper function pointers. Kernel Implementation of linux loader has to take care of setting "prelaunch_init" routines.*/
-
-/*Implementation has to fill up foll. structures with appropriate values.
-	This strucure must be defined in KSEG0 Region. Linux Loader loading applications must have to mmap this structure.
-	*Generic Bootloader: All pointers will have kseg0 address.
-	*Linux Loader: All pointers will have kuseg address.
-*/
-struct xlr_lib_load_import
-{
-	/*CopyData - (DestPhysAddr, SrcVirtAddr, Size). Must contain "kuseg" 
-	address for linux loader.*/
-	int32_t copy_data;
-	int32_t copy_data_uncached;
-
-	/*SetData - (DestPhysAddr, SetValue, Size). Must contain "kuseg" address for linux loader.*/
-	int32_t set_data;
-	
-	/*Pointer to function to call wakeup_cpu. Proceduer is implementation dependent. 
-	LinuxLoader: Linux loader sends an ioctl to the driver and driver sends an ipi to the specified cpu and wakes up it.
-	GenericLoader: Directly sends an ipi to the specified vcpu.
-	*/
-
-	/*Args: (cpu, Func, Data) 
-	TODO: Check if we can remove this callback.
-	*/
-
-	int32_t call_wakeup_cpu;
-	int32_t call_stop_vcpu;
-
-	/*call_xlr_start_app: valid only in case of generic bootlaoder.*/
-	int32_t call_xlr_start_app;
-
-	/*Implementation must have to fill up this region.*/
-	struct xlr_lib_psb_mem_map default_map;
-	struct xlr_lib_psb_mem_map recent_map;
-
-	/*Befor Loading Verify whether application can be launched on specified 
-	cpu or not.
-	*Linux Loader	: Before loading any kuseg/kseg application verify whether specified vcpu is available or not. If available then update the mask.
-	*Generic Loader	: Before loading any kuseg application verify whether specified vcpu is availble or not, if yes then update it while loading only. Kseg application never fails in case of generic bootloader, atleast you will find one vcpu free (vcpu0) which can launch this application. Once kseg is launched we are mot much bothered about any other stuffs .. as we wont have any other control.. though update boot1_info as it is.
-	*/
-
-	uint32_t total_avail_cpu;
-	uint32_t recent_avail_cpu;	
-	uint32_t userapp_cpu_mask;
-	
-	/*Pointer To Base of WakeupInfo Structure.*/
-	int32_t xlr_wakeup_info;
-	int32_t vcpu_extended_info;
-	int32_t per_cpu_info;
-
-	/*Pointer To Generic Boot1Info*/
-	int32_t xlr_lib_boot1_info;
-
-	/*Define This as a pointer to buffer of 16 bytes and must be defined in kseg0 region. 
-         Implementation must have to do memset on this before calling library routines. This must be done only once. 
-         Linux loader has to take care of this with some additional logic. This will be used for printk spin_lock.*/
-	/*unsigned char *lib_base_lock;*/
-	int32_t lib_base_lock;
-	
-	int coredump_support;
-
-	/*Below routine must return hard vcpu id if and only if launching is allowed on threads running loader, Otherwise return -1*/
-	uint32_t xlr_hard_vcpu_id;
-
-	/*Library can call this routine to store some data, this memory has to be persistent, next time while calling lib_load_init, implementation has to set persistent_data to this memory*/
-	int32_t xlr_get_persistent_memory;
-	int32_t xlr_free_persistent_memory;
-
-	/*If lib has ever stored anything in persistent memory then this pointer will point to that memory. Implementation need not worry about the way data is stored in to this memory, it must mmap(in case of linux loader) this memory and pass it to loader library.*/
-	int32_t persistent_data;	   
-	uint32_t persistent_data_length;
-	int32_t print;
-
-	int32_t lib_malloc;
-	int32_t lib_free;
-
-	int32_t mmap_to_kseg;
-	int32_t kseg_to_mmap;
-	int32_t lib_send_ipi;
-};
-
-/*Implementation has to fill up foll. structures with appropriate values.
-	This strucure must be defined in KSEG0 Region. Linux Loader loading applications must have to mmap this structure.
-	*Generic Bootloader: All pointers will have kseg0 address.
-	*Linux Loader: All pointers will have kseg0/kseg2 address.
-*/
-
-struct xlr_lib_launch_import
-{
-
-	/*Implementation has to set this to some kseg0 values for each cpu.*/
-	uint64_t sp[32];
-	uint64_t gp[32];
-
-	/*PreLaunchInit, Before launching any application on the kuseg/kseg "master" cpu respective routine will get call. In linux loader this ll be called frm kernel context and in generic bootloader this ll get call in context of vcpu0.
-*/
-	int32_t cb_prelaunch_init_kuseg;	
-	int32_t cb_prelaunch_init_kseg;	
-
-	/*Foll. Args will be passed to callbacks. Make sure if it is an address of any variable then it must be kseg0 address.*/
-	uint32_t kuseg_prelaunch_init_args;
-	uint32_t kseg_prelaunch_init_args;
-
-	/*Foll. is the pointer to the boot1_info, this address will be passed to the all applications (in scratch-0)*/
-	int32_t xlr_lib_boot1_info;
-
-
-	/*Pointer To Base of WakeupInfo Structure.*/
-	int32_t xlr_wakeup_info;
-	int32_t vcpu_extended_info;
-	int32_t per_cpu_info;
-	
-	uint32_t default_ebase;	
-	int32_t global_wakeup_mask;
-	int32_t loader_lock;
-
-	int32_t flush_icache_all;
-	int32_t flush_dcache_all;
-	int32_t flush_tlb_all;
-	int32_t xlr_setup_tlb;
-	int32_t xlr_hard_vcpu_id;
-	int32_t trap_init;
-	int32_t cpu_init;	
-	int32_t print;
-};
-
-struct xlr_kuseg_mem_blk
-{
-	uint64_t phys;
-	uint64_t size;
-	struct xlr_kuseg_mem_blk *next;
-};
-
-extern void xlr_start_app(void);
-extern void wakeup_cpu(uint32_t cpu, unsigned long fn, unsigned long args);
-extern void xlr_send_stop_ipi(unsigned long mask);
-extern void xlr_lib_load_init(struct xlr_lib_load_import *lib_load);
-extern void xlr_lib_launch_init(struct xlr_lib_launch_import *lib_launch);
-extern void xlr_lib_prelaunch_init_kseg(unsigned long data);
-extern int xlr_lib_stop_vcpu(unsigned long mask);
-extern void xlr_lib_load_exit(void);
-int setup_lib_env(void);
-extern int xlr_load_kuseg_app(struct xlr_lib_boot_file *file, uint32_t master, char *loadaddr,
-			      char *user_app_addr, uint32_t buddy, int override, int nargs,
-			      char **cmdline_args, char **, int );
-extern void xlr_lib_get_avail_mem(unsigned long *kuseg_mem, 
-											unsigned long *kseg_mem);
-extern uint64_t xlr_lib_reserve_shmem(uint64_t);
-extern void xlr_lib_intr_handler(int ipi);
-extern void xlr_lib_entry(unsigned long args);
-extern void reset_printk_base_lock(void);
-extern int xlr_lib_launch_userapp(int cpu);
-extern int xlr_load_kseg_app(struct xlr_lib_boot_file *file, uint32_t master, 
-					int argc,char *argv[], int nmiload);
-extern int xlr_lib_load_userapp(uint32_t cpu, int nargs, char *cmdline_args[], 						char *env_args[]);
-
-
-#endif
diff --git a/drivers/misc/netlogic/linux-loader/xlr_lib_launch.c b/drivers/misc/netlogic/linux-loader/xlr_lib_launch.c
deleted file mode 100644
index 8af81b8..0000000
--- a/drivers/misc/netlogic/linux-loader/xlr_lib_launch.c
+++ /dev/null
@@ -1,663 +0,0 @@
-/*-
- * Copyright 2003-2013 Broadcom Corporation
- * 
- * This program is the proprietary software of Broadcom Corporation and/or its
- * licensors, and may only be used, duplicated, modified or distributed pursuant
- * to the terms and conditions of a separate, written license agreement executed
- * between you and Broadcom (an "Authorized License"). Except as set forth in
- * an Authorized License, Broadcom grants no license (express or implied), right
- * to use, or waiver of any kind with respect to the Software, and Broadcom
- * expressly eserves all rights in and to the Software and all intellectual
- * tproperty rights herein. IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO
- * RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM
- * AND DISCONTINUE ALL USE OF THE SOFTWARE.
- * 
- * Except as expressly set forth in the Authorized License,
- * 
- * 1.This program, including its structure, sequence and organization,
- * constitutes the valuable trade secrets of Broadcom, and you shall use all
- * reasonable efforts to protect the confidentiality thereof, and to use this
- * information only in connection with your use of Broadcom integrated circuit
- * products.
- * 
- * 2.TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
- * "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS
- * OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT
- * TO THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED
- * WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A
- * PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET
- * ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE
- * ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
- *
- * 3.TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
- * ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT,
- * OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO YOUR
- * USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF THE AMOUNT
- * ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER.
- * THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF ESSENTIAL
- * PURPOSE OF ANY LIMITED REMEDY.
- *
- *  * #BRCM_3# */
-
-/*This is the main bootloader lib file.*/
-#include <linux/kernel.h>
-#include "phnx_loader.h"
-#include "xlr_boot_lib.h"
-
-#define Message(a,b...) //printk("\n[%s]-[%d] "a"\n",__FUNCTION__,__LINE__,##b)
-
-static volatile struct xlr_vcpu_wakeup_info *xlr_vcpu_wakeup_info = NULL;
-//static struct xlr_lib_psb_info *xlr_lib_boot1_info=NULL;
-static struct xlr_lib_launch_import *xlr_lib_launch = NULL;
-static void xlr_park(unsigned long args);
-static void xlr_lib_kuseg_helper(void);
-static void load_scratch_info(void);
-static void disable_ie(void);
-static void enable_ie(void);
-struct exception_region {
-	unsigned long data[1024];
-};
-
-static volatile int xlr_wakeup_ipi[XLR_NUM_CPU] = {0};
-static int loading_kseg0 = 0;
-#ifndef __STR
-#define __STR(x) #x
-#endif
-#ifndef STR
-#define STR(x) __STR(x)
-#endif
-
-struct nlm_loader_cpu
-{
-	volatile uint64_t ready;
-	uint64_t func;
-	uint64_t args;
-};
-struct nlm_loader_cpu *nlm_cpu_config;
-
-static void (*flush_icache_all)(void);
-static void (*flush_dcache_all) (void);
-static void (*loader_flush_tlb_all) (void);
-static void (*xlr_setup_tlb)(uint64_t, uint64_t , int );
-static int (*xlr_hard_vcpu_id)(void);
-static void (*trap_init) (void);
-static void (*cpu_init) (void);
-static int (*print)(const char *fmt, ...);
-static void (*cb_prelaunch_init_kseg)(unsigned long);
-
-static __inline__ void lib_sync(void)
-{
-	__asm__ volatile(
-		".set push\n"
-		".set noreorder\n"
-		".set mips64r2\n"
-		"sync\n"
-		".set pop\n"
-	);
-
-}
-
-static __inline__ void load_scratch_info(void)
-{
-	struct xlr_vcpu_wakeup_info *t = (struct xlr_vcpu_wakeup_info *)
-									xlr_vcpu_wakeup_info + xlr_hard_vcpu_id();
-	__asm__ volatile(
-		".set push\n"
-		".set noreorder\n"
-		".set mips64\n"	
-//		"dmtc0 %0, $22, 0\n"	/* move (&boot1_info) into $22    */
-		"dmtc0 %0, $22, 0\n"	/* move nlm_cpu_config into $22    */
-		"dmtc0 %1, $22, 1\n"	/* move (master cpu + buddy mask) into $22 */
-		"dmtc0 %2, $22, 3\n"
-		"dmtc0 %3, $22, 4\n"
-		"dmtc0 %4, $22, 5\n"
-		"dmtc0 %5, $22, 6\n"
-		"dmtc0 %6, $22, 7\n"
-		".set pop\n"
-//		:: "r"(xlr_lib_boot1_info),"r"(xlr_lib_boot1_info->userapp_cpu_map),
-		:: "r"(nlm_cpu_config),"r"(0),
-		"r"(1),"r"((int)t->argc),
-		"r"((unsigned long)t->argv),
-		"r"((unsigned long)t->envs),"r"(xlr_vcpu_wakeup_info)
-	);
-}
-
-static __inline__ void disable_ie()
-{
-	__asm__ volatile (
-			".set push     \n"
-			".set noreorder        \n"
-			".set noat             \n"
-			"mfc0 $1, $12          \n"
-			"ori  $1, 0x1          \n"
-			"xori $1, 0x1          \n"
-			"mtc0 $1, $12          \n"
-			"nop                   \n"
-			"nop                   \n"
-			"nop                   \n"
-			"nop                   \n"
-			".set pop              \n"
-			);
-}
-
-static __inline__ void enable_ie()
-{
-	__asm__ volatile (
-			".set push             \n"
-			".set noreorder        \n"
-			".set noat             \n"
-			"mfc0 $1, $12          \n"
-			"ori  $1, 0x1f         \n"
-			"xori $1, 0x1e         \n"
-			"mtc0 $1, $12          \n"
-			"nop                   \n"
-			"nop                   \n"
-			"nop                   \n"
-			"nop                   \n"
-			".set pop              \n"
-			);
-}
-
-void xlr_lib_reclaim_resources(void)
-{
-	struct xlr_vcpu_wakeup_info *t = (struct xlr_vcpu_wakeup_info *)
-                                      xlr_vcpu_wakeup_info + xlr_hard_vcpu_id();
-	t->cpu_status = CPU_WAIT_TO_RELEASE_RESOURCE;
-	lib_sync();
-
-	while(t->cpu_status != CPU_RESOURCE_RELEASED);
-
-	t->cpu_status = CPU_STOPPED;
-	lib_sync();
-}
-
-void xlr_lib_entry(unsigned long args)
-{
-	struct xlr_vcpu_wakeup_info *t = (struct xlr_vcpu_wakeup_info *)
-					xlr_vcpu_wakeup_info + xlr_hard_vcpu_id();
-
-	register unsigned long __sp asm("$29") = t->sp;
-	register unsigned long __gp asm("$28") = t->gp;
-	register unsigned long __func asm("$25") = (unsigned long) xlr_park;
-	register unsigned long __a0 asm("$4") = 0;
-	
-	__asm__ volatile(
-		".set noreorder\n"
-		"jr $25\n"
-		"nop\n"
-		".set reorder\n"
-		:
-		: "r"(__sp), "r"(__a0), "r"(__gp),"r"(__func)
-	);
-}
-
-void set_argv_envs(struct xlr_vcpu_wakeup_info *t)
-{
-	int i=0;
-	unsigned char *tmp=NULL;
-	tmp = t->argv_buf;
-
-	for(i=0;i<t->argc;i++){
-		t->argv[i] = (int32_t)(long)tmp;
-		while(*tmp != ' ' && *tmp)
-			tmp++;
-		tmp++;
-	}
-	for(;i<XLR_MAX_ARGV;i++)
-		t->argv[i] = (int32_t)(long)NULL;
-
-	tmp = t->env_buf;
-	for(i=0;i<t->env;i++){
-		t->envs[i] = (int32_t)(long)tmp;
-		while(*tmp != ' ' && *tmp)
-			tmp++;
-		tmp++;
-	}
-	for(;i<XLR_MAX_ARGV;i++)
-		t->envs[i] = (int32_t)(long)NULL;
-}
-
-void xlr_start_app(void)
-{
-	int vcpu = xlr_hard_vcpu_id();
-	struct xlr_vcpu_wakeup_info *t = (struct xlr_vcpu_wakeup_info *)
-						(xlr_vcpu_wakeup_info + vcpu);
-	//unsigned long ebase = xlr_lib_launch->default_ebase;
-	volatile int i=0;
-	uint32_t *gbl_wakeup_mask = (uint32_t *)(long)t->global_wakeup_mask;
-
-	t->cpu_status = CPU_RUNNING;
-	lib_spin_lock(((lib_spinlock_t *)(long)t->loader_lock));
-	*gbl_wakeup_mask = (*gbl_wakeup_mask) & ~(1UL<<vcpu);
-	lib_spin_unlock(((lib_spinlock_t *)(long)t->loader_lock));
-	
-	loader_flush_tlb_all();
-
-	/*Reset EBASE Value*/
-	//xlr_fill_cop0_reg_32($15,1,ebase&0x3ffff000);
-	/*Reset STATUS Register*/
-	//xlr_fill_cop0_reg_32($12,0,0x50000000);
-
-	/*Call Helper And Setup TLB For KUSEG Apps*/
-	if(t->mode == KUSEG_APP){
-		xlr_lib_kuseg_helper();
-	}
-	/*Set argv and envs with proper pointers.*/
-	//set_argv_envs(t);
-	/*Implementation must setup all default handler @ this ebase.*/
-
-	flush_icache_all();
-	flush_dcache_all();
-	
-	/*
-	1)Setup $22,0 with boot1_info structure. This may required for initialization process.
-	2)Setup $22,7 with "xlr_vcpu_wakeup_info" base address. Rmios lib startup routine will find the appropriate offset based on this.
-	*/
-	load_scratch_info();
-	if(!loading_kseg0)
-		for(i=0;i<10000000;i++);
-
-	if(t->kseg_master == 1)
-	{
-		/*Case where we are launching kseg application on vcpu not running 
-		  loader, Setup all the required arguments accordingly.*/
-		__asm__ volatile(
-				".set push\n"
-				".set noreorder\n"
-				".set mips64\n"
-				"move $4, %0\n"
-				"move $5, %1\n"
-				"move $6, %2\n"
-				"move $7, %3\n"
-				"nop\n"
-				"nop\n"
-				".set reorder\n"
-				".set pop\n"
-				::"r"(t->argc),"r"(t->argv),"r"(t->envs),
-				//			"r"((unsigned long)xlr_lib_boot1_info)
-				"r"((unsigned long)0)
-				:"$4","$5","$6","$7"
-				);
-	}
-	else
-	{
-		__asm__ volatile(
-				".set push\n"
-				".set noreorder\n"
-				".set mips64\n"
-				"move $4, %0\n"
-				"move $5, %0\n"
-				"nop\n"
-				"nop\n"
-				".set reorder\n"
-				".set pop\n"
-				::"r"(t->args)
-				:"$4","$5"
-				);
-#if 0
-		__asm__ volatile(
-				".set noreorder\n"
-				".set mips64\n"
-				"move $4, %0\n"
-				"move $5, %0\n"
-				"nop\n"
-				"nop\n"
-				".set reorder\n"
-				::"r"(t->args)
-				:"$4","$5"
-				);
-#endif
-	}
-	/*Setup gp,sp and jump to the elf entry address function.*/
-	{
-		__asm__ volatile(
-				".set noreorder\n\t"
-				"move $25, %3\n\t"
-				"move $29, %4\n\t"
-				"move $28, %5\n\t"
-				"move $4, %0\n\t"
-				"move $5, %1\n\t"
-				"move $6, %2\n\t"
-				"jr $25\n\t"
-				"nop\n\t"
-				".set  reorder\n\t"
-				:
-				:"r"(t->fdt_base), "r"(t->app_addr), "r"(t->domain), "r"(t->func), "r"(t->sp), "r"(t->gp)
-				:"$25","$4","$5","$6"
-				);
-#if 0
-		register unsigned long __func asm("$25") = t->func;
-		register unsigned long __sp asm("$29") = t->sp;
-		register unsigned long __gp asm("$28") = t->gp;
-		register unsigned long __rentry_func asm("$31") = (unsigned long) t->reentry_function;
-
-		((void (*)(uint64_t, uint64_t, uint64_t))(long)t->func)(t->fdt_base, t->app_addr, t->domain);
-		__asm__ volatile(
-				".set noreorder\n\t"
-				"jr $25\n\t"
-				"nop\n\t"
-				".set  reorder\n\t"
-				:
-				:"r"(__sp), "r"(__gp), "r"(__func), "r"(__rentry_func)
-				);
-#endif
-	}
-	/*We will never come back here.*/
-}
-
-void xlr_send_stop_ipi(unsigned long mask)
-{
-#if 0
-	int ipi;
-	volatile unsigned long k = 0;
-	int pid, tid;
-	xlr_lib_phnx_reg_t *mmio = xlr_lib_phnx_io_mmio(PHOENIX_IO_PIC_OFFSET);
-	volatile struct xlr_vcpu_wakeup_info *m = xlr_vcpu_wakeup_info;
-	volatile struct xlr_vcpu_wakeup_info *t = NULL;
-	volatile int i;
-
-	lib_spin_lock(((lib_spinlock_t *)(long)m->loader_lock));
-
-	/*Send stop ipi to all requested vcpus.*/
-	for(i=0; i<XLR_NUM_CPU; i++){
-		if(mask & (1U<<i)){
-			pid = i >> 2;
-			tid = i % 4;
-			ipi = (pid << 20) | (tid << 16) | IRQ_STOP_CPU_IPI ;
-			xlr_lib_phnx_write_reg(mmio, PIC_IPI, ipi);
-		}
-	}
-
-	/*wait for some time.... let cpus come back to park mode.*/
-	for(k=0;k<100000000UL;k++);
-
-	for(i=0; i<XLR_NUM_CPU; i++){
-		if(mask & (1U<<i)){
-			t = xlr_vcpu_wakeup_info + i;
-			if(t->cpu_status == CPU_STOPPED){
-				pid = i >> 2;
-				tid = i % 4;
-				ipi = (pid << 20) | (tid << 16) | IRQ_RECLAIM_CPU_RSRC_IPI;
-				xlr_lib_phnx_write_reg(mmio, PIC_IPI, ipi);
-				lib_sync();
-				/*wait till cpu comes to wait_to_release state*/
-				while(t->cpu_status != CPU_WAIT_TO_RELEASE_RESOURCE);
-			}
-		}
-	}
-
-	lib_spin_unlock(((lib_spinlock_t *)(long)m->loader_lock));
-
-#endif
-}
-
-void wakeup_cpu(unsigned int cpu, unsigned long fn, unsigned long args)
-{
-	volatile struct xlr_vcpu_wakeup_info *t;
-	uint32_t *gbl_wakeup_mask;
-	t = xlr_vcpu_wakeup_info + cpu;
-	gbl_wakeup_mask = (uint32_t *)(long)t->global_wakeup_mask;
-	lib_spin_lock(((lib_spinlock_t *)(long)t->loader_lock));
-	t = xlr_vcpu_wakeup_info + cpu;
-	t->func = fn;
-	t->args = args;
-	*gbl_wakeup_mask = (*gbl_wakeup_mask) | (1UL<<cpu);
-	lib_spin_unlock(((lib_spinlock_t *)(long)t->loader_lock));
-	//	lib_sync();
-	__sync();
-
-	/*mark cpu ready now...*/
-	nlm_cpu_config[cpu].func = (uint64_t)(unsigned long)t->func;
-	nlm_cpu_config[cpu].ready = 1;
-	//	lib_sync();
-	__sync();
-#if 0
-	volatile struct xlr_vcpu_wakeup_info *t;
-	int ipi;
-	int pid = cpu >> 2;
-	int tid = cpu % 4;
-	uint32_t *gbl_wakeup_mask;
-	xlr_lib_phnx_reg_t *mmio = xlr_lib_phnx_io_mmio(PHOENIX_IO_PIC_OFFSET);
-
-	t = xlr_vcpu_wakeup_info + cpu;
-	gbl_wakeup_mask = (uint32_t *)(long)t->global_wakeup_mask;
-	lib_spin_lock(((lib_spinlock_t *)(long)t->loader_lock));
-	t = xlr_vcpu_wakeup_info + cpu;
-	t->func = fn;
-	t->args = args;
-	ipi = (pid << 20) | (tid << 16) | IRQ_WAKEUP_CPU_IPI ;
-	*gbl_wakeup_mask = (*gbl_wakeup_mask) | (1UL<<cpu);
-	xlr_lib_phnx_write_reg(mmio, PIC_IPI, ipi);
-	lib_spin_unlock(((lib_spinlock_t *)(long)t->loader_lock));
-#endif
-}
-
-static void xlr_lib_kuseg_helper(void)
-{
-	struct xlr_vcpu_wakeup_info *t = (struct xlr_vcpu_wakeup_info *)
-		xlr_vcpu_wakeup_info + xlr_hard_vcpu_id();
-	int i;
-	//	xlr_fill_cop0_reg_32($6,0,0);
-
-	if (!t->map_count) {
-		print("cpu_%d: No TLB mappings?\n", xlr_hard_vcpu_id());
-		return;
-	}
-	for (i = 0; i < t->map_count; i++){
-		xlr_setup_tlb((unsigned long long)t->map[i].virt 
-				|((unsigned long long)t->map[i].asid << 32), 
-				t->map[i].phys, t->map[i].page_size);
-	}
-	trap_init();
-}
-
-void xlr_lib_launch_init(struct xlr_lib_launch_import *lib_launch)
-{
-	int i=0;
-	struct xlr_vcpu_wakeup_info *t = NULL;
-	xlr_lib_launch = lib_launch;
-
-	Message("Entering %s", __func__);
-
-	/*Initialize All Callbacks*/
-	flush_icache_all = (void (*) (void))(long)(xlr_lib_launch->flush_icache_all);
-	flush_dcache_all = (void (*) (void))(long)(xlr_lib_launch->flush_dcache_all);
-	loader_flush_tlb_all = (void (*) (void))(long)(xlr_lib_launch->flush_tlb_all);
-	xlr_setup_tlb = (void (*)(uint64_t, uint64_t , int ))
-		(long)(xlr_lib_launch->xlr_setup_tlb);
-	xlr_hard_vcpu_id = (int(*)(void))(long)(xlr_lib_launch->xlr_hard_vcpu_id);
-	trap_init = (void(*)(void))(long)(xlr_lib_launch->trap_init);
-	cpu_init = (void(*)(void))(long)(xlr_lib_launch->cpu_init);
-	print = (int (*)(const char *fmt, ...))(long)(xlr_lib_launch->print);
-	cb_prelaunch_init_kseg = (void (*)(unsigned long))
-		(long)(xlr_lib_launch->cb_prelaunch_init_kseg);
-
-	xlr_vcpu_wakeup_info = t = (struct xlr_vcpu_wakeup_info *)(long)lib_launch->xlr_wakeup_info;
-	//xlr_vcpu_wakeup_info = t;
-	//xlr_lib_boot1_info = (struct xlr_lib_psb_info *)(long)
-	//lib_launch->xlr_lib_boot1_info;
-	//Message("");
-	memset((void *)(long)lib_launch->loader_lock, 0, sizeof(t->loader_lock));
-
-	//Message("");
-	for(i=0; i < XLR_NUM_CPU; i++){
-		t->sp = lib_launch->sp[i];
-		t->gp = lib_launch->gp[i];
-		t->global_wakeup_mask = lib_launch->global_wakeup_mask;
-		t->loader_lock = lib_launch->loader_lock;
-		t++;
-	}
-	//Message("");
-
-	/*Allocate memory for nlm_loader_cpu...*/
-	nlm_cpu_config= kmalloc (sizeof(struct nlm_loader_cpu) * XLR_NUM_CPU, GFP_KERNEL);
-	Message("nlm_cpu_config @ %#lx\n",(unsigned long)nlm_cpu_config);
-
-	/*convert addr to xkseg*/
-	nlm_cpu_config = (struct nlm_loader_cpu *)((unsigned long)nlm_cpu_config - 0xc000000000000000ULL + 0xa800000000000000ULL);
-	memset(nlm_cpu_config, 0, sizeof(struct nlm_loader_cpu) * XLR_NUM_CPU);
-#if 0
-	for(i=0; i<32; i++){
-		Message("CPU[%d] --> %#lx\n",i, (unsigned long)&nlm_cpu_config[i]);
-	}
-#endif
-	Message("nlm_cpu_config @ %#lx\n",(unsigned long)nlm_cpu_config);
-}
-
-int xlr_lib_launch_userapp(int cpu)
-{
-	struct xlr_vcpu_wakeup_info *t = (struct xlr_vcpu_wakeup_info *)
-		xlr_vcpu_wakeup_info + cpu;
-
-	loading_kseg0 = 1;
-
-	if(cb_prelaunch_init_kseg)
-		cb_prelaunch_init_kseg(xlr_lib_launch->kseg_prelaunch_init_args);
-
-	t->cpu_status = CPU_RUNNING;
-
-	if(cpu != xlr_hard_vcpu_id()){
-		t->kseg_master = 1;
-		wakeup_cpu(cpu,t->func,t->args);
-		return 0;
-	}
-	loader_flush_tlb_all();
-	load_scratch_info();
-	__asm__ volatile(
-			".set noreorder\n"
-			".set mips64\n"
-			"move $29, %0\n"
-			"move $28, %1\n"
-			"nop\n"
-			".set reorder\n"
-			::"r"(t->sp), "r"(t->gp)
-			);
-
-	((void (*)(int, char *, char *, uint64_t))(long)t->func)
-		(t->argc,(char *)t->argv,(char *)t->envs,
-		 //			 (unsigned long)xlr_lib_boot1_info;
-		 (unsigned long)0);
-	/*We will never come back here.*/
-	return 0;	
-}
-
-void xlr_lib_intr_handler(int irq)
-{
-	int cpu = xlr_hard_vcpu_id();
-	switch(irq){
-		case IRQ_WAKEUP_CPU_IPI:
-			xlr_wakeup_ipi[cpu] = 1;
-			break;
-		case IRQ_STOP_CPU_IPI:
-			reset_printk_base_lock();
-			__asm__ __volatile__(
-					"mtc0 %0, $14\n"
-					"nop\n"
-					"eret\n"
-					"nop\n"
-					::"r"(xlr_lib_entry)
-					);
-			break;
-		case IRQ_RECLAIM_CPU_RSRC_IPI:
-			xlr_lib_reclaim_resources();
-			break;
-		default:
-			print("Lib Doesnt support Interupt %d\n",irq);
-			break;
-	}
-	return;
-}
-
-static void xlr_park(unsigned long args)
-{
-	volatile struct xlr_vcpu_wakeup_info *t;
-	//	volatile struct xlr_vcpu_wakeup_info *master;
-	int cpu = xlr_hard_vcpu_id();
-
-	cpu_init();
-	t = (struct xlr_vcpu_wakeup_info *)xlr_vcpu_wakeup_info + cpu;
-	t->reentry_function = (int32_t)(long)xlr_lib_entry;
-	t->reentry_args = cpu;
-	disable_ie();
-	//	trap_init();
-	/*clear any pending interrupts in eirr.*/
-	//	xlr_fill_cop0_reg_64($9, 6, ~0x0);
-	/*setup a new eimr mask*/
-	//	xlr_fill_cop0_reg_64($9,7,0);
-	t->cpu_status = CPU_STOPPED;
-	lib_sync();
-
-	while(!nlm_cpu_config[cpu].ready);
-
-	//	disable_ie();
-	t->func = nlm_cpu_config[cpu].func;
-	nlm_cpu_config[cpu].ready = 0;
-
-	xlr_start_app();
-}
-
-#if 0
-static void xlr_park(unsigned long args)
-{
-	uint64_t new_mask = (1ULL<<IRQ_WAKEUP_CPU_IPI) | (1ULL<<IRQ_STOP_CPU_IPI)
-		|(1ULL<<IRQ_RECLAIM_CPU_RSRC_IPI);
-	uint64_t old_mask = (1ULL<<4);
-	volatile struct xlr_vcpu_wakeup_info *t;
-	volatile struct xlr_vcpu_wakeup_info *master;
-	int cpu = xlr_hard_vcpu_id();
-
-	/*Dont Read EIMR and or with newmask, we may come here from rmios 
-	  applications, which may have all interrupts enabled, here we have to 
-	  reset all interrupts except wakeup/stop ipi.*/
-
-	new_mask = new_mask | old_mask;
-	cpu_init();
-
-	/*Set Proper Status Reg Value.*/
-	t = (struct xlr_vcpu_wakeup_info *)xlr_vcpu_wakeup_info + cpu;
-	t->reentry_function = (int32_t)(long)xlr_lib_entry;
-	t->reentry_args = cpu;
-	disable_ie();
-	trap_init();
-	/*clear any pending interrupts in eirr.*/
-	xlr_fill_cop0_reg_64($9, 6, ~0x0);
-	/*setup a new eimr mask*/
-	xlr_fill_cop0_reg_64($9,7,new_mask);
-	t->cpu_status = CPU_STOPPED;
-	lib_sync();
-
-	enable_ie();
-	while(!xlr_wakeup_ipi[cpu])
-		__asm__ volatile(
-				".set noreorder\n"
-				"wait\n"
-				".set reorder\n"	
-				);
-	disable_ie();
-	xlr_wakeup_ipi[cpu] = 0;
-	/*Continue if this cpu is a master*/
-	if(t->master_cpu != cpu){
-		/*check if this is still a valid buddy!!*/
-		master = (struct xlr_vcpu_wakeup_info *)
-			xlr_vcpu_wakeup_info + t->master_cpu;
-		if(!(master->buddy_mask & (1<<cpu))){
-			/*this cpu is just stopped*/
-			xlr_lib_entry(0UL);
-		}
-	}
-	xlr_fill_cop0_reg_64($9,6,0xfffffffffffffffcULL);
-	xlr_fill_cop0_reg_64($9,7,old_mask);
-	xlr_start_app();
-}
-#endif
-
-void reset_printk_base_lock(void)
-{
-	struct xlr_vcpu_wakeup_info *t = (struct xlr_vcpu_wakeup_info *)
-		xlr_vcpu_wakeup_info + xlr_hard_vcpu_id();
-	uint32_t *ptr = (uint32_t *)(long)t->printk_lock;
-
-	if(*ptr ==  (xlr_hard_vcpu_id()+1))
-		*ptr = 0;
-}
diff --git a/drivers/misc/netlogic/linux-loader/xlr_lib_platform.h b/drivers/misc/netlogic/linux-loader/xlr_lib_platform.h
deleted file mode 100644
index aad7c5c..0000000
--- a/drivers/misc/netlogic/linux-loader/xlr_lib_platform.h
+++ /dev/null
@@ -1,103 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_2# */
-
-
-#ifndef __XLR_LIB_PLATEFORM_H
-#define __XLR_LIB_PLATEFORM_H
-
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-#include <linux/string.h>
-
-#include <linux/types.h>/*All kind of type conversions.*/
-//#include <asm/rmi/sim.h>/*boot1_info*/
-//#include <asm/rmi/iomap.h>/*PHOENIX_IO_PIC_OFFSET*/
-//#include <asm/rmi/pic.h>/*PIC Offset*/
-#include <linux/kernel.h>
-#include <linux/string.h>
-#include "xlr_boot_lib.h"
-
-#define xlr_lib_psb_mem_map psb_mem_map
-//#define xlr_lib_psb_info psb_info
-#define xlr_lib_phnx_io_mmio(offset) phoenix_io_mmio(offset)
-#define xlr_lib_phnx_write_reg(base,offset,val) phoenix_write_reg(base,offset,val)
-#define xlr_lib_phnx_read_reg(base,offset) phoenix_read_reg(base,offset)
-
-#define xlr_fill_cop0_reg_32(reg,sel,value) 	\
-				__asm__ __volatile__(\
-					".set\tpush\n\t"\
-					".set mips32\n\t"\
-					"mtc0\t%0,"STR(reg)", %1\n\t"\
-					".set\tpop"\
-					:: "r" (value), "i" (sel) );
-
-#define xlr_fill_cop0_reg_64(source,sel,val) __write_64bit_c0_register(source,sel,val)
-
-struct xlr_lib_boot_file{
-        char *name;
-        unsigned char *start;
-        int size;
-        unsigned int max_size;
-        int valid;
-};
-
-static __inline__ void lib_spin_lock(lib_spinlock_t *lock)
-{
-	unsigned int tmp;
-
-	__asm__ __volatile__(
-	    ".set\tnoreorder\t\t\t# spin_lock\n"
-	    "1:\tll\t%1, %2\n\t"
-	    "bnez\t%1, 1b\n\t"
-	    " li\t%1, 1\n\t"
-	    "sc\t%1, %0\n\t"
-	    "beqz\t%1, 1b\n\t"
-	    " nop\n\t"
-	    ".set\treorder"
-	    : "=m" (lock->lock), "=&r" (tmp)
-	    : "m" (lock->lock)
-	    : "memory");
-}
-
-static __inline__ void lib_spin_unlock(lib_spinlock_t *lock)
-{
-	__asm__ __volatile__(
-	    ".set\tnoreorder\t\t\t# spin_unlock\n\t"
-	    "sync\n\t"
-	    "sw\t$0, %0\n\t"
-	    ".set\treorder"
-	    : "=m" (lock->lock)
-	    : "m" (lock->lock)
-	    : "memory");
-}
-
-
-#endif
diff --git a/drivers/misc/netlogic/linux-loader/xlr_rmios_stackframe.h b/drivers/misc/netlogic/linux-loader/xlr_rmios_stackframe.h
deleted file mode 100644
index f172f71..0000000
--- a/drivers/misc/netlogic/linux-loader/xlr_rmios_stackframe.h
+++ /dev/null
@@ -1,201 +0,0 @@
-/*-
- * Copyright 2003-2013 Broadcom Corporation
- * 
- * This program is the proprietary software of Broadcom Corporation and/or its
- * licensors, and may only be used, duplicated, modified or distributed pursuant
- * to the terms and conditions of a separate, written license agreement executed
- * between you and Broadcom (an "Authorized License"). Except as set forth in
- * an Authorized License, Broadcom grants no license (express or implied), right
- * to use, or waiver of any kind with respect to the Software, and Broadcom
- * expressly eserves all rights in and to the Software and all intellectual
- * tproperty rights herein. IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO
- * RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM
- * AND DISCONTINUE ALL USE OF THE SOFTWARE.
- * 
- * Except as expressly set forth in the Authorized License,
- * 
- * 1.This program, including its structure, sequence and organization,
- * constitutes the valuable trade secrets of Broadcom, and you shall use all
- * reasonable efforts to protect the confidentiality thereof, and to use this
- * information only in connection with your use of Broadcom integrated circuit
- * products.
- * 
- * 2.TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
- * "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS
- * OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT
- * TO THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED
- * WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A
- * PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET
- * ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE
- * ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
- *
- * 3.TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
- * ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT,
- * OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO YOUR
- * USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF THE AMOUNT
- * ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER.
- * THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF ESSENTIAL
- * PURPOSE OF ANY LIMITED REMEDY.
- *
- *  * #BRCM_3# */
-#ifndef __RMIOS_STACKFRAME_H__
-#define __RMIOS_STACKFRAME_H__
-
-#include <asm/regdef.h>
-#include <asm/asm.h>
-#include <asm/types.h>
-
-
-#define COP_0_STATUS      $12
-#define COP_0_CAUSE       $13
-#define COP_0_EPC         $14
-
-#define STACK_OFF_R0  		    48
-#define STACK_OFF_R1     	    56
-#define STACK_OFF_R2     	    64
-#define STACK_OFF_R3     	    72
-#define STACK_OFF_R4     	    80
-#define STACK_OFF_R5     	    88
-#define STACK_OFF_R6     	    96
-#define STACK_OFF_R7     	   104
-#define STACK_OFF_R8     	   112
-#define STACK_OFF_R9     	   120
-#define STACK_OFF_R10    	   128
-#define STACK_OFF_R11    	   136
-#define STACK_OFF_R12    	   144
-#define STACK_OFF_R13    	   152
-#define STACK_OFF_R14    	   160
-#define STACK_OFF_R15    	   168
-#define STACK_OFF_R16    	   176
-#define STACK_OFF_R17    	   184
-#define STACK_OFF_R18    	   192
-#define STACK_OFF_R19    	   200
-#define STACK_OFF_R20    	   208
-#define STACK_OFF_R21    	   216
-#define STACK_OFF_R22    	   224
-#define STACK_OFF_R23    	   232
-#define STACK_OFF_R24    	   240
-#define STACK_OFF_R25    	   248
-#define STACK_OFF_R26    	   256
-#define STACK_OFF_R27    	   264
-#define STACK_OFF_R28    	   272
-#define STACK_OFF_R29    	   280
-#define STACK_OFF_R30    	   288
-#define STACK_OFF_R31    	   296
-
-#define STACK_OFF_STATUS 	   304
-#define STACK_OFF_HI     	   312
-#define STACK_OFF_LO     	   320
-
-#define STACK_OFF_BVADDR 	   328
-#define STACK_OFF_CAUSE  	   336
-#define STACK_OFF_EPC    	   344
-
-#define K_STACK_SIZE   	           352
-
-
-#define save_stack_frame           \
-	.set push;                 \
-	.set noat;                 \
-	.set reorder;              \
-	move	k1, sp;            \
-        move	k0, sp;            \
-	dsubu	sp, k1, K_STACK_SIZE;     \
-	sd	k0, STACK_OFF_R29(sp);	  \
-        sd	$3, STACK_OFF_R3(sp);	  \
-	sd	$0, STACK_OFF_R0(sp);	  \
-	dmfc0	v1, COP_0_STATUS;         \
-	sd	$2, STACK_OFF_R2(sp);	  \
-	sd	v1, STACK_OFF_STATUS(sp); \
-	sd	$4, STACK_OFF_R4(sp);	  \
-	dmfc0	v1, COP_0_CAUSE;          \
-	sd	$5, STACK_OFF_R5(sp);	  \
-	sd	v1, STACK_OFF_CAUSE(sp);  \
-	sd	$6, STACK_OFF_R6(sp);	  \
-	dmfc0	v1, COP_0_EPC;            \
-	sd	$7, STACK_OFF_R7(sp);	  \
-	sd	v1, STACK_OFF_EPC(sp);	  \
-	sd	$25, STACK_OFF_R25(sp);   \
-	sd	$28, STACK_OFF_R28(sp);   \
-	sd	$31, STACK_OFF_R31(sp);   \
-	ori	$28, sp, 0x1fff;          \
-	xori	$28, 0x1fff;              \
-	sd	$1, STACK_OFF_R1(sp);	  \
-	mfhi	v1;		          \
-	sd	$8, STACK_OFF_R8(sp);	  \
-	sd	$9, STACK_OFF_R9(sp);	  \
-	sd	v1, STACK_OFF_HI(sp);	  \
-	mflo	v1;		          \
-	sd	$10,STACK_OFF_R10(sp);	  \
-	sd	$11, STACK_OFF_R11(sp);   \
-	sd	v1,  STACK_OFF_LO(sp);	  \
-	sd	$12, STACK_OFF_R12(sp);   \
-	sd	$13, STACK_OFF_R13(sp);   \
-	sd	$14, STACK_OFF_R14(sp);   \
-	sd	$15, STACK_OFF_R15(sp);   \
-	sd	$24, STACK_OFF_R24(sp);   \
-	sd	$16, STACK_OFF_R16(sp);   \
-	sd	$17, STACK_OFF_R17(sp);   \
-	sd	$18, STACK_OFF_R18(sp);   \
-	sd	$19, STACK_OFF_R19(sp);   \
-	sd	$20, STACK_OFF_R20(sp);   \
-	sd	$21, STACK_OFF_R21(sp);   \
-	sd	$22, STACK_OFF_R22(sp);   \
-	sd	$23, STACK_OFF_R23(sp);   \
-	sd	$30, STACK_OFF_R30(sp);   \
-.set pop;			   
-
-#define restore_stack_frame                  \
-	.set	push;		             \
-	.set    noat;                        \
-	.set	reorder;	             \
-	mfc0	t0, COP_0_STATUS;            \
-	ori	t0, 0x1f;	             \
-	xori	t0, 0x1f;	             \
-	mtc0	t0, COP_0_STATUS;            \
-	li	v1, 0xff00;	             \
-	and	t0, v1;		             \
-	ld	v0, STACK_OFF_STATUS(sp);    \
-	nor	v1, $0, v1;	             \
-	and	v0, v1;		             \
-	or	v0, t0;		             \
-	mtc0	v0, COP_0_STATUS;            \
-	ld	v1, STACK_OFF_EPC(sp);	     \
-	mtc0	v1, COP_0_EPC;	             \
-	ld	$31, STACK_OFF_R31(sp);      \
-	ld	$28, STACK_OFF_R28(sp);      \
-	ld	$25, STACK_OFF_R25(sp);      \
-	ld	$7,  STACK_OFF_R7(sp);	     \
-	ld	$6,  STACK_OFF_R6(sp);	     \
-	ld	$5,  STACK_OFF_R5(sp);	     \
-	ld	$4,  STACK_OFF_R4(sp);	     \
-	ld	$3,  STACK_OFF_R3(sp);	     \
-	ld	$2,  STACK_OFF_R2(sp);	     \
-	ld	$1,  STACK_OFF_R1(sp);       \
-	ld	$24, STACK_OFF_LO(sp);	     \
-	ld	$8, STACK_OFF_R8(sp);	     \
-	ld	$9, STACK_OFF_R9(sp);	     \
-	mtlo	$24;		             \
-	ld	$24, STACK_OFF_HI(sp);	     \
-	ld	$10,STACK_OFF_R10(sp);	     \
-	ld	$11, STACK_OFF_R11(sp);      \
-	mthi	$24;		             \
-	ld	$12, STACK_OFF_R12(sp);      \
-	ld	$13, STACK_OFF_R13(sp);      \
-	ld	$14, STACK_OFF_R14(sp);      \
-	ld	$15, STACK_OFF_R15(sp);      \
-	ld	$24, STACK_OFF_R24(sp);      \
-	ld	$16, STACK_OFF_R16(sp);      \
-	ld	$17, STACK_OFF_R17(sp);      \
-	ld	$18, STACK_OFF_R18(sp);      \
-	ld	$19, STACK_OFF_R19(sp);      \
-	ld	$20, STACK_OFF_R20(sp);      \
-	ld	$21, STACK_OFF_R21(sp);      \
-	ld	$22, STACK_OFF_R22(sp);      \
-	ld	$23, STACK_OFF_R23(sp);      \
-	ld	$30, STACK_OFF_R30(sp);      \
-	ld	sp,  STACK_OFF_R29(sp);      \
-.set pop;			   
-
-#endif
-- 
1.9.1

