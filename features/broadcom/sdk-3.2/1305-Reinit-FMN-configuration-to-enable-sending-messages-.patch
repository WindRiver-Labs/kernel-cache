From e4bc6d7dbaadaae9c36091218786d28e9fa3fe1f Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Sun, 3 Oct 2010 16:29:31 -0700
Subject: [PATCH 1305/1532] Reinit FMN configuration to enable sending messages
 from non-core 0. U-boot config does not help as the cores were in reset\!

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/init_nae.c   | 22 +++++-----
 drivers/net/ethernet/broadcom/nae/net_common.h | 29 +++++--------
 drivers/net/ethernet/broadcom/nae/xlp_nae.c    | 58 ++++++++++++++++----------
 3 files changed, 58 insertions(+), 51 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/init_nae.c b/drivers/net/ethernet/broadcom/nae/init_nae.c
index 1a20e21..252aadc 100644
--- a/drivers/net/ethernet/broadcom/nae/init_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/init_nae.c
@@ -10,6 +10,8 @@
 
 #define VAL_UCORE_RESET(x)		((x&0xffff)<<8)
 
+#define RELY_ON_FIRMWARE_CONFIG
+
 static void parse_ucore_config(void)
 {
         uint32_t ucore_cfg;
@@ -123,7 +125,9 @@ static void parse_fdt_nae_config(void)
 	if (debug)
 		printk("num-nae-regs = %d, num-intf-regs = %d\n", num_nae_regs, num_intf_regs);
 
-	//nlm_hal_sgmii_pcs_init();
+#ifndef RELY_ON_FIRMWARE_CONFIG
+	nlm_hal_sgmii_pcs_init();
+#endif
 
 	for(i = 0; i < num_ports; i++)
 	{
@@ -192,18 +196,19 @@ static void parse_fdt_nae_config(void)
 		}
 		getprop(subnode, "intf-regs", intf_regs, size);
 
-		//printk("Configuring per-port interface registers for port@%d\n", i);
+#ifndef RELY_ON_FIRMWARE_CONFIG
+		printk("Configuring per-port interface registers for port@%d\n", i);
 		/* Configure per port interface registers */
-		//nlm_hal_init_if_regs(port_type, hw_port_id, intf_regs, num_intf_regs);
+		nlm_hal_init_if_regs(port_type, hw_port_id, intf_regs, num_intf_regs);
 
-		//printk("Configuring per-port NAE registers for port@%d\n", i);
+		printk("Configuring per-port NAE registers for port@%d\n", i);
 		/* Configure per port NAE registers */
-		//nlm_hal_init_nae_regs(port_type, nae_regs, num_nae_regs);
-
+		nlm_hal_init_nae_regs(port_type, nae_regs, num_nae_regs);
+#endif
 		kfree(nae_regs);
 		kfree(intf_regs);
 
-#if 0
+#ifndef RELY_ON_FIRMWARE_CONFIG
 		if (nlm_hal_open_if(port_type, hw_port_id) < 0) {
 			printk("[%s] Unable to open port %d\n", __func__, i);
 			continue;
@@ -215,9 +220,6 @@ static void parse_fdt_nae_config(void)
 
 void initialize_nae(void)
 {
-	uint32_t val = 0;
-	int i = 0;
-
 	if (check_header()) {
 		printk("Sanity check on FDT blob failed! Aborting\n");
 		return;
diff --git a/drivers/net/ethernet/broadcom/nae/net_common.h b/drivers/net/ethernet/broadcom/nae/net_common.h
index 478a1bb..e3e7529 100644
--- a/drivers/net/ethernet/broadcom/nae/net_common.h
+++ b/drivers/net/ethernet/broadcom/nae/net_common.h
@@ -9,11 +9,10 @@
 #define FAIL                    -1
 #define CPU0_VC                 0
 
-#define CPU_Q_ID(cpu, tid, vid) (cpu<<4|tid<<2|vid)
-#define QID_2_CPU(qid)          ((qid & 0x7F)>> 4)
-#define QID_2_TID(qid)          ((qid & 0xc)>>2 )
-#define QID_2_QID(qid)          (qid & 0x3)
+#define CPU_Q_ID(cpu, vid) ( ((cpu) << 2) | (vid) )
+
 #define MAX_DEST_QID            50
+
 typedef struct fmn_credit_struct {
    unsigned int   s_qid;
    unsigned int   d_qid;
@@ -26,6 +25,7 @@ typedef struct fmn_credit_struct {
 #define FMN_QLEN_USE_DEFAULT      0
    unsigned int   credit;
 } fmn_credit_type;
+
 extern int init_gmac(unsigned int inf);
 extern int init_tx_if_credit( /*uint32_t*/__u32 credit_val, unsigned int if_bmask);
 extern int init_ucore(uint32_t ucore_mask, int if_num);
@@ -33,15 +33,15 @@ extern void init_ingress(void);
 extern void init_egress(void);
 extern int fmn_init(const fmn_credit_type *credit);
 extern void *xlp_init_buffer( size_t size,
-                   size_t pbase ,
-                   uint64_t *vaddr_base
-                           );
+			      size_t pbase ,
+			      uint64_t *vaddr_base);
 
 extern void *init_nae_free_pool(int num_queue,
-                              unsigned char *pktmem ,
-                              int num_bytes,
-                              int num_desc);
+				unsigned char *pktmem ,
+				int num_bytes,
+				int num_desc);
 extern void print_netreg(void);
+
 #define DBG        1
 #ifdef DBG
     #define log_dbg     printk
@@ -63,14 +63,6 @@ static __inline__ void press_key_to_continue(void) {
 #define press_key_to_continue()
 #endif
 
-#define CPU_Q_ID(cpu, tid, vid) (cpu<<4|tid<<2|vid)
-//TO BE changed
-#define XKPHYS_UNCACHED 0x9000000000000000ULL
-#define XLP_NAE_IO_OFFSET        (XKPHYS_UNCACHED | 0xd000e000)
-
-
-#define OUTQ_ENABLE 0x8000000000000000ULL
-
 enum NAE_REG_CMD {
 	CMD_READ = 0,
 	CMD_WRITE
@@ -79,7 +71,6 @@ enum NAE_REG_CMD {
 #define NAE_RX_ENABLE 0x1
 #define NAE_TX_ENABLE 0x1
 
-#define CPU_Q_ID(cpu, tid, vid) (cpu<<4|tid<<2|vid)
 struct xlp_msg {
 	uint64_t entry[4];
 };
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index a8913e8..21de461 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -174,7 +174,7 @@ struct net_device *dev_mac_type[MAX_XLP_NET_TYPES][MAX_GMAC_PORT];
 
 extern struct proc_dir_entry *nlm_root_proc;
 static struct tasklet_struct mac_refill_task[MAX_GMAC_PORT];
-static void mac_refill_frin_desc(unsigned long dev);
+static int mac_refill_frin_desc(unsigned long dev);
 
 extern void nlm_xlp_mac_set_enable(struct dev_data *priv, int flag);
 
@@ -203,7 +203,8 @@ static __inline__ void cpu_halt(void)
 
 static __inline__ void print_fmn_send_error(const char *str, uint32_t send_result)
 {
-#if 0
+	if (debug < 1) return;
+
 	if(send_result & MSG_DST_FC_FAIL)
 	{
 		printk("[%s] Msg Destination flow control credit fail(send_result=%08x)\n",
@@ -218,7 +219,6 @@ static __inline__ void print_fmn_send_error(const char *str, uint32_t send_resul
 	else {
 		printk("[%s] Unknown send error type(send_result=%08x)\n", __func__, send_result);
 	}
-#endif
 }
 
 static __inline__ struct sk_buff *mac_get_skb_back_ptr(uint64_t addr)
@@ -316,7 +316,7 @@ static inline void nlm_xlp_free_skb(struct xlp_msg *msg)
  * @dev -  this is per device based function
  *
  **********************************************************************/
-static void mac_refill_frin_desc(unsigned long dev)
+static int mac_refill_frin_desc(unsigned long dev)
 {
 	struct dev_data* priv;
 	struct net_device *ndev;
@@ -339,7 +339,9 @@ static void mac_refill_frin_desc(unsigned long dev)
 		if(!skb)
 		{
 			printk("[%s] alloc skb failed\n",__FUNCTION__);
-			return;
+
+			ret = -ENOMEM;
+			break;
 		}
 
 		skb->dev = ndev;
@@ -355,12 +357,19 @@ static void mac_refill_frin_desc(unsigned long dev)
 		msg.entry[1]= msg.entry[2] = msg.entry[3] = 0;
 		/* Send the packet to nae rx  */
 		__sync();
-	retry_send:
+
                 if ( (ret = nlm_hal_send_msg1(priv->nae_rx_qid, code, msg.entry[0])) )
 		{
 			print_fmn_send_error(__func__, ret);
-			if (debug) printk("[%s]: retrying...\n", __func__);
-			goto retry_send;
+			printk("[%s]: giving up (qid=%d)\n", __func__, priv->nae_rx_qid);
+
+			/* free the buffer and return! */
+			dev_kfree_skb_any(skb);
+
+			msgrng_access_disable(mflags);
+
+			ret = -EBUSY;
+			break;
                 }
 		msgrng_access_disable(mflags);
 
@@ -368,7 +377,8 @@ static void mac_refill_frin_desc(unsigned long dev)
 
 		atomic64_inc(&priv->total_frin_sent);
 	}
-        return;
+
+        return ret;
 }
 
 /**********************************************************************
@@ -387,11 +397,11 @@ static void nlm_xlp_nae_init(void)
 	printk("======= Module Parameters =========\n");
 	printk("debug = %d, hwemul=%d, naecfg_hack=%d drop_uboot_pkt=%d\n",
 	       debug, hwemul, naecfg_hack, drop_uboot_pkt);
-#if 0
-	if (hwemul) {
+#if 1
+	if (1/*hwemul*/) {
 		unsigned long mflags = 0;
 		msgrng_access_enable(mflags);
-		nlm_hal_fmn_init(0xE0000000ULL, 0x1000000, 50);
+		nlm_hal_fmn_init(0x10000000, 0x02000000, 50);
 		msgrng_access_disable(mflags);
 	}
 #endif
@@ -435,7 +445,9 @@ static void nlm_xlp_nae_init(void)
 		dev_mac_type[priv->type][priv->port] = dev;
 		dev_mac[i] = dev;
 
-		tasklet_init(&mac_refill_task[priv->port], mac_refill_frin_desc,(unsigned long)dev);
+		tasklet_init(&mac_refill_task[priv->port],
+			     (void (*)(long unsigned int))mac_refill_frin_desc,
+			     (unsigned long)dev);
 	}
 
 	entry = create_proc_read_entry("mac_stats", 0 /* def mode */ ,
@@ -458,15 +470,19 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 {
 	struct dev_data *priv = netdev_priv(dev);
 	int i;
+	int ret = 0;
 
 	if (priv->inited) return 0;
 
 	if(register_xlp_msgring_handler( XLP_MSG_HANDLE_NAE_0 , nlm_xlp_nae_msgring_handler, dev))
 	{
-		panic("can't register msgring handler for TX_STN_GMAC0");
+		printk("Fatal error! Can't register msgring handler for TX_STN_GMAC0");
+		ret = -1;
+		goto out;
 	}
 
-	mac_refill_frin_desc((unsigned long)dev);
+	ret = mac_refill_frin_desc((unsigned long)dev);
+	if (ret) goto out;
 
 #ifdef ENABLE_NAE_PIC_INT
 	{
@@ -513,7 +529,8 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 
 	priv->inited = 1;
 
-	return 0;
+ out:
+	return ret;
 }
 
 /**********************************************************************
@@ -560,7 +577,7 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		return -1;
 	}
 
-	msg.entry[0] = nae_tx_desc(P2D_NEOP, 0, CPU_Q_ID( 0, 0, nae_fb_vc), 0, virt_to_bus(skb));
+	msg.entry[0] = nae_tx_desc(P2D_NEOP, 0, CPU_Q_ID(cpu, nae_fb_vc), 0, virt_to_bus(skb));
 	msg.entry[1] = nae_tx_desc(P2D_EOP,
 				   0,
 				   NULL_VFBID,
@@ -586,10 +603,9 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 				      msg.entry[1])) )
         {
 		print_fmn_send_error(__func__, ret);
-		if (debug) printk("[%s]: retrying message send...\n", __func__);
 		//printk("[%s] HACK ALERT! dropping packet(skb=%p)!\n", __func__, skb);
-		dev_kfree_skb_any(skb);
-		//goto retry_send;
+		//dev_kfree_skb_any(skb);
+		goto retry_send;
         }
 
 	msgrng_access_disable(mflags);
@@ -964,8 +980,6 @@ static void nlm_xlp_mac_timer(unsigned long data)
         struct dev_data *priv = netdev_priv(dev);
         int next_tick = HZ / 100; /* 10ms */
 
-	//if (port == 0) mac_refill_frin_desc((unsigned long)dev) ;
-
 	/* printk("[%s] A0 Workaround, forcing FMN int handling \n",__func__); */
 	nlm_xlp_msgring_int_handler(IRQ_MSGRING, NULL);
 
-- 
1.9.1

