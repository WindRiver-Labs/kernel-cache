From 49f3ff99ff1a5d7c75c108fc1d3e59d50a1aa210 Mon Sep 17 00:00:00 2001
From: Abhishek Joshi <abjoshi@broadcom.com>
Date: Mon, 3 Mar 2014 18:11:01 +0530
Subject: [PATCH 0902/1532] poe: added support for context-class mapping in a
 round robin fashion

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/netlib/include/netsoc_nae.h |  3 ++
 arch/mips/netlogic/lib/netlib/include/nlm_nae.h    |  1 -
 arch/mips/netlogic/lib/netlib/src/netsoc_config.c  |  1 -
 arch/mips/netlogic/lib/netlib/src/netsoc_nae.c     | 42 +++++++++-------------
 4 files changed, 20 insertions(+), 27 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
index ad6f91e..08bb0b0 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
@@ -31,6 +31,7 @@
 #ifndef __BRCM_NETSOC_NAE_H
 #define __BRCM_NETSOC_NAE_H
 
+/*#define NETSOC_DBG*/
 #include "netsoc_haliface.h"
 #include "netsoc_libiface.h"
 
@@ -1203,7 +1204,9 @@ static inline int __netsoc_map_context_toclass(nae_t *nae, uint32_t context, uin
 
         netsoc_write_nae_reg(nae->nae_base, POE_CLASS_SETUP_CFG, (1<<7) | index);
         val = netsoc_read_nae_reg(nae->nae_base, POE_CLASS_SETUP_CFG);
+#ifdef NETSOC_DBG
         netsoc_api_print(NETSOC_APIDBG_CONFIG,"%s context %d class %d \n",__func__, context, ((val >> ctxindex) & 0x7));
+#endif
         return NETSOC_API_SUCCESS;
 }
 
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
index 4c1273b..47618f3 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -424,7 +424,6 @@ struct nlm_hal_nae_config {
 	nae_hw_parser_t hwparser;
        
         uint32_t cpu_bypass_mode;  /* ucore cpu bypass mode enable */
-	uint32_t default_class;
         /* ALE */
         uint32_t ale_enable;
 	uint32_t parser_enable;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
index 11d3265..e4123cb 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
@@ -491,7 +491,6 @@ static void __netsoc_update_nae_defaultconfig(nae_t *nae)
                 /* MAX_NAE_PORTS_PERNODE = 18 is an invalid port */
                 nae->cntx2port[i] = MAX_NAE_PORTS_PERNODE;
         }
-	nae->default_class = 0;
 	__netsoc_set_frin_queue_base(nae);
 	__netsoc_set_frin_total_queue(nae);
 	
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 7ffb2ea..17990e9 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -1144,46 +1144,38 @@ int __netsoc_config_vfbid_table(nae_t *nae, uint32_t start, uint32_t num_entries
 
 /* __netsoc_config_poe_class: configure context to poe class mapping.
  *
- * If poe class mapping is not enabled then all context are mapped
- * to a default class (nae->default_class).
- * Otherwise for each context within a poe class table entry, class values 
- * are calculated from nae->poe_cl_tbl. Then calculated mapping (val)
- * is updated in POE_CLASS_SETUP_CFG.
- * Above step is repeated for all table entries upto max_poe_tbl_sz.
- **/
+ * Maps all contexts to available classes in a round robin fashion. Available
+ * classes are determined by the cpu enque mode ("class-map-mode" field in dts)
+ *
+ */
 
 int __netsoc_config_poe_class(nae_t *nae)
 {
-        int i, j;
-        uint32_t val, cval;
+        uint32_t val;
 	int max_poe_tbl_sz;
-	int class_num = 0;
-	int ctx_num;
-        int poe_cl_tbl[MAX_POE_CLASSES] = {0x0, 0x249249, 0x492492,
-                                           0x6db6db, 0x924924, 0xb6db6d,
-                                           0xdb6db6, 0xffffff};
+	int class_num = 0, cpu_class_map =0, cntx;
 
 	max_poe_tbl_sz = current_netsoc->max_contexts / MAX_POE_CLASSES;
+	cpu_class_map = nae->poe->cpu_poe_class_map;
 
 	if (current_netsoc->max_contexts % MAX_POE_CLASSES)
 		max_poe_tbl_sz++;
 
         netsoc_api_print(NETSOC_APIDBG_CONFIG, "max_poe_tbl_sz %d\n",max_poe_tbl_sz);
 
-	if (nae->poe->cpu_poe_class_map) {
-		netsoc_api_print(NETSOC_APIDBG_CONFIG, "%s cpu enqueue class mapping enabled \n",__func__);
-		if (!(validate_nae_rx_class_map(nae, (nae->default_class & 0x7)))) {
-			netsoc_api_print(NETSOC_APIDBG_ERROR, "%s Invalid NAE_RX TO POE Class Mapping\n", __func__);
-			return -NETSOC_API_ERROR;
-		}
+	if (cpu_class_map) {
+		netsoc_api_print(NETSOC_APIDBG_CONFIG, "%s cpu enqueue class mapping enabled, class map %d \n",__func__, cpu_class_map);
 	}
 
-        for (i = 0; i <max_poe_tbl_sz; ++i) {
-                val = (0x00 | i); /* clear the read bit 0x80 */
-                val |= (poe_cl_tbl[nae->default_class & 0x7] << 8); // All the contexts are mapped to default class number.
+	netsoc_api_print(NETSOC_APIDBG_CONFIG, "%s Round Robin configuration of valid classes\n", __func__);
+
+	class_num = valid_nae_rx_class[cpu_class_map][MIN_VALID_CLASS_INDX];
 
-                netsoc_api_print(NETSOC_APIDBG_CONFIG, "POE index %d val %x \n",i, val);
-                netsoc_write_nae_reg(nae->nae_base, POE_CLASS_SETUP_CFG, val);
+        for (cntx = 0; cntx < current_netsoc->max_contexts; ++cntx) {
+		if (class_num > valid_nae_rx_class[cpu_class_map][MAX_VALID_CLASS_INDX])
+			class_num = valid_nae_rx_class[cpu_class_map][MIN_VALID_CLASS_INDX];
+		__netsoc_map_context_toclass (nae, cntx, class_num);
+		class_num++;
         }
 	return NETSOC_API_SUCCESS;
 }
-- 
1.9.1

