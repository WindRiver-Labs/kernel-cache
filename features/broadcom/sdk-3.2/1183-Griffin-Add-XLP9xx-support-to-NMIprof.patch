From b4f1547a8ba5eb21ed6d95a44e38ae15e7657a74 Mon Sep 17 00:00:00 2001
From: Ganesan Ramalingam <ganesanr@broadcom.com>
Date: Thu, 29 Aug 2013 16:31:34 +0530
Subject: [PATCH 1183/1532] Griffin: Add XLP9xx support to NMIprof

[Based on SDK 3.2]
Adjust the code because of the modification int the patch
"0078-Linux-userspace-kmod-Add-NMI-profiler.patch"

Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/nmiprof/nmiprof-sys.c     | 66 ++++++++++--------------
 drivers/misc/netlogic/nmiprof/nmiprof.h         | 68 ++++++++++++++++++++-----
 drivers/misc/netlogic/nmiprof/nmiprof_asm.S     | 20 +++++---
 drivers/misc/netlogic/nmiprof/nmiprof_asm_xlr.S | 42 ---------------
 4 files changed, 92 insertions(+), 104 deletions(-)
 delete mode 100644 drivers/misc/netlogic/nmiprof/nmiprof_asm_xlr.S

diff --git a/drivers/misc/netlogic/nmiprof/nmiprof-sys.c b/drivers/misc/netlogic/nmiprof/nmiprof-sys.c
index dde80d5..e5809e9 100644
--- a/drivers/misc/netlogic/nmiprof/nmiprof-sys.c
+++ b/drivers/misc/netlogic/nmiprof/nmiprof-sys.c
@@ -19,20 +19,14 @@ struct nlm_nmiprof_dev {
 	struct bin_attribute bindata_attr;
 	struct bin_attribute binnmiprof_attr;
 	u64 *base;
-	u32 nlm_cpu;
+	int nlm_cpu;
 };
 
 struct nlm_nmiprof_dev *jdev;
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
 static ssize_t nlm_nmiprof_read(struct file *filp, struct kobject *kobj,
 		struct bin_attribute *bin_attr,
 		char *buf, loff_t pos, size_t size)
-#else
-static ssize_t nlm_nmiprof_read(struct kobject *kobj,
-		struct bin_attribute *bin_attr,
-		char *buf, loff_t pos, size_t size)
-#endif
 {
 	size_t log_size = bin_attr->size;
 
@@ -45,28 +39,16 @@ static ssize_t nlm_nmiprof_read(struct kobject *kobj,
 	return size;
 }
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
 static ssize_t nlm_nmiprof_write(struct file *filp, struct kobject *kobj,
 		struct bin_attribute *bin_attr,
 		char *buf, loff_t pos, size_t size)
-#else
-static ssize_t nlm_nmiprof_write(struct kobject *kobj,
-		struct bin_attribute *bin_attr,
-		char *buf, loff_t pos, size_t size)
-#endif
 {
 	return 0;
 }
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
 static ssize_t nlm_nmiprofcontrol_read(struct file *filp, struct kobject *kobj,
 		struct bin_attribute *bin_attr,
 		char *buf, loff_t pos, size_t size)
-#else
-static ssize_t nlm_nmiprofcontrol_read(struct kobject *kobj,
-		struct bin_attribute *bin_attr,
-		char *buf, loff_t pos, size_t size)
-#endif
 {
 	int count = 0;
 	if (!pos)
@@ -74,29 +56,25 @@ static ssize_t nlm_nmiprofcontrol_read(struct kobject *kobj,
 	return count;
 }
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
 static ssize_t nlm_nmiprofcontrol_write(struct file *filp, struct kobject *kobj,
 		struct bin_attribute *bin_attr,
 		char *buf, loff_t pos, size_t size)
-#else
-static ssize_t nlm_nmiprofcontrol_write(struct kobject *kobj,
-		struct bin_attribute *bin_attr,
-		char *buf, loff_t pos, size_t size)
-#endif
-
 {
 	char *reset_data;
+	u32 *write_asm;
 	uint64_t xlp_pic_base;
 	int ret;
-	u32 use_cpu;
+	int use_cpu;
 
-	pr_debug("Jprof control jdev->nlm_cpu %d\n", jdev->nlm_cpu);
+	pr_debug("nmiprof control jdev->nlm_cpu %d\n", jdev->nlm_cpu);
 
 	/* Get cpu */
-	use_cpu = simple_strtoul(buf, NULL, 0);
+	use_cpu = simple_strtol(buf, NULL, 0);
 
-	if (jdev->nlm_cpu != 32 && use_cpu != 32) {
-		pr_info("Jprof running on cpu %d\n", jdev->nlm_cpu);
+	if (jdev->nlm_cpu >= 0 && jdev->nlm_cpu < NLM_NR_CPUS && use_cpu >= 0) {
+		pr_info("nmiprof running on cpu %d\n", jdev->nlm_cpu);
+		pr_info("Help : cpu mask on XLP8xx 0-31 and on XLP9xx 0-79\n");
+		pr_info("	To stop nmiprof -1\n");
 		return size + 1;
 	}
 
@@ -104,7 +82,7 @@ static ssize_t nlm_nmiprofcontrol_write(struct kobject *kobj,
 	xlp_pic_base = nlm_get_pic_regbase(0); /* Node 0 */
 	reset_data = (char *)CKSEG1ADDR(RESET_VEC_PHYS);
 
-	if (jdev->nlm_cpu >= 0 && jdev->nlm_cpu < 32) {
+	if (jdev->nlm_cpu >= 0 && jdev->nlm_cpu < NLM_NR_CPUS) {
 		/* Setting scratch reg of requested cpu
 		 * with the memory address */
 		ret = smp_call_function_single(jdev->nlm_cpu, nlm_config_cpu,
@@ -114,21 +92,29 @@ static ssize_t nlm_nmiprofcontrol_write(struct kobject *kobj,
 			return ret;
 		}
 
-		pr_info("Jprof: start tracing cpu %d, jdev->base %p\n",
-				jdev->nlm_cpu, jdev->base);
+		pr_info("nmiprof: start tracing on cpu %d\n", jdev->nlm_cpu);
 		memcpy((void *)nmiprofsave, reset_data,
 				(nlm_nmiprof_end - nlm_nmiprof));
 		memcpy(reset_data, nlm_nmiprof, (nlm_nmiprof_end - nlm_nmiprof));
+
+		write_asm = (u32 *) (reset_data + (&pic_entry - nlm_nmiprof));
+		*write_asm |= (xlp_pic_base & 0xffff0000) >> 16;
+		write_asm++;
+		*write_asm |= 0x400;
+		write_asm++;
+		*write_asm |= ((xlp_pic_base & 0xffff) + (PIC_STATUS << 2));
+		write_asm++;
+		*write_asm |= 0xa;
+		write_asm++;
+		*write_asm |= ((xlp_pic_base & 0xffff) + (PIC_INT_ACK << 2));
+
 		nlm_pic_set_timer(xlp_pic_base, 6, 509 * 1499ull, -3,
 				jdev->nlm_cpu);
-	} else if (jdev->nlm_cpu == 32) {
+	} else if (jdev->nlm_cpu < 0) {
 		nlm_pic_set_timer(xlp_pic_base, 6, ~0ULL, 0, 0);
 		memcpy(reset_data, (void *)nmiprofsave,
 				(nlm_nmiprof_end - nlm_nmiprof));
-		pr_info("Jprof: stopped tracing\n");
-	} else {
-		pr_info("Help : cpu mask 0-31\n");
-		pr_info("	To stop Jprof 32\n");
+		pr_info("nmiprof: stopped tracing\n");
 	}
 
 	return size + 1;
@@ -142,7 +128,7 @@ static int __init nlm_init_sys(void)
 	if (!jdev)
 		return ENOMEM;
 
-	jdev->nlm_cpu = 32;
+	jdev->nlm_cpu = NLM_NR_CPUS;
 	/* Allocate memory for dumping the statistic collected */
 	jdev->base = (u64 *) __get_free_pages(GFP_ATOMIC,
 			get_order(NMIPROF_LOG_SIZE));
diff --git a/drivers/misc/netlogic/nmiprof/nmiprof.h b/drivers/misc/netlogic/nmiprof/nmiprof.h
index b7444cf..c7986dd 100644
--- a/drivers/misc/netlogic/nmiprof/nmiprof.h
+++ b/drivers/misc/netlogic/nmiprof/nmiprof.h
@@ -81,36 +81,57 @@
 #define PIC_IRT_CLOCK_INDEX	PIC_IRT_TIMER_7_INDEX
 #define PIC_IRT_TIMER_INDEX(num)	((num) + PIC_IRT_TIMER_0_INDEX)
 
-
+#define PIC_STATUS              0x04
+#define PIC_INT_ACK             0x10
 
 #define XLP_DEFAULT_IO_BASE             0x18000000
 #define RESET_VEC_PHYS			0x1fc00000
 #define XLP_IO_PCI_HDRSZ		0x100
-#define XLP_IO_DEV(node, dev)		((dev) + (node) * 8)
-#define XLP_HDR_OFFSET(node, bus, dev, fn)	(((bus) << 20) | \
-				((XLP_IO_DEV(node, dev)) << 15) | ((fn) << 12))
+#define XLP_IO_DEV(node, dev)           ((dev) + (node) * 8)
+#define XLP_IO_PCI_OFFSET(b, d, f)      (((b) << 20) | ((d) << 15) | ((f) << 12))
+
+#define XLP_HDR_OFFSET(node, bus, dev, fn) \
+                XLP_IO_PCI_OFFSET(bus, XLP_IO_DEV(node, dev), fn)
+
+/* On node 0 bus 1 */
+#define XLP9XX_HDR_OFFSET(n, d, f)      \
+                        XLP_IO_PCI_OFFSET(1, d, f)
 
 /* coherent inter chip */
 #define XLP_IO_PIC_OFFSET(node)		XLP_HDR_OFFSET(node, 0, 0, 4)
+#define XLP9XX_IO_PIC_OFFSET(node)      XLP9XX_HDR_OFFSET(node, 2, 0)
+
+#define PIC_9XX_IRT0			0x1c0  /* this should be 0x200, FIXME */
+#define PIC_9XX_IRT(i)			(PIC_9XX_IRT0 + ((i) * 2))
 
 #define nlm_read_pci_reg(b, r)		nlm_read_reg(b, r)
 #define nlm_write_pci_reg(b, r, v)	nlm_write_reg(b, r, v)
 
-#define nlm_read_pic_reg(b, r)  nlm_read_reg64(b, r)
-#define nlm_write_pic_reg(b, r, v) nlm_write_reg64(b, r, v)
+#define nlm_read_pic_reg(b, r)		nlm_read_reg64(b, r)
+#define nlm_write_pic_reg(b, r, v)	nlm_write_reg64(b, r, v)
+
+#define nlm_get_pic_pcibase(node)       nlm_pcicfg_base(cpu_is_xlp9xx() ? \
+		                XLP9XX_IO_PIC_OFFSET(node) : XLP_IO_PIC_OFFSET(node))
 
-#define nlm_get_pic_pcibase(node) nlm_pcicfg_base(XLP_IO_PIC_OFFSET(node))
-#define nlm_get_pic_regbase(node) (nlm_get_pic_pcibase(node) + XLP_IO_PCI_HDRSZ)
+#define nlm_get_pic_regbase(node) 	(nlm_get_pic_pcibase(node) + XLP_IO_PCI_HDRSZ)
 
 #define write_c0_scratch(sel, val)	__write_64bit_c0_register($22, sel, val)
-#define read_c0_scratch(sel)	__read_64bit_c0_register($22, sel)
+#define read_c0_scratch(sel)		__read_64bit_c0_register($22, sel)
 
 /* NMIprof log size 4MB*/
 #define NMIPROF_LOG_SIZE	0x400000
+#define NLM_NR_CPUS	(cpu_is_xlp9xx() ? 80 : 32)
 
-extern char nlm_nmiprof[], nlm_nmiprof_end[];
+extern char nlm_nmiprof[], nlm_nmiprof_end[], pic_entry;
 extern uint64_t nlm_io_base;
 
+static inline int cpu_is_xlp9xx(void)
+{
+        int chip = read_c0_prid() & 0xff00;
+
+        return chip == PRID_IMP_NETLOGIC_XLP9XX;
+}
+
 static inline uint64_t nlm_pcicfg_base(uint32_t devoffset)
 {
 	return nlm_io_base + devoffset;
@@ -172,6 +193,20 @@ nlm_write_reg64(uint64_t base, uint32_t reg, uint64_t val)
 
 /* IRT and h/w interrupt routines */
 
+static inline void
+nlm_9xx_pic_write_irt(uint64_t base, int irt_num, int en, int nmi,
+	int sch, int vec, int dt, int db, int cpu)
+{
+	uint64_t val;
+
+	val = (((uint64_t)en & 0x1) << 22) | ((nmi & 0x1) << 23) |
+			((0 /*mc*/) << 20) | ((vec & 0x3f) << 24) |
+			((dt & 0x1) << 21) | (0 /*ptr*/ << 16) |
+			(cpu & 0x3ff);
+
+	nlm_write_pic_reg(base, PIC_9XX_IRT(irt_num), val);
+}
+
 inline void nlm_pic_write_irt(uint64_t base, int irt_num, int en,
 		int nmi, int sch, int vec, int dt, int db, int dte)
 {
@@ -189,9 +224,13 @@ inline void
 nlm_pic_write_irt_direct(uint64_t base, int irt_num, int en, int nmi,
 	int sch, int vec, int cpu)
 {
-	nlm_pic_write_irt(base, irt_num, en, nmi, sch, vec, 1,
-		(cpu >> 4),		/* thread group */
-		1 << (cpu & 0xf));	/* thread mask */
+	if (cpu_is_xlp9xx())
+		nlm_9xx_pic_write_irt(base, irt_num, en, nmi, sch, vec,
+							1, 0, cpu);
+	else
+		nlm_pic_write_irt(base, irt_num, en, nmi, sch, vec, 1,
+			(cpu >> 4),		/* thread group */
+			1 << (cpu & 0xf));	/* thread mask */
 }
 
 inline void
@@ -219,5 +258,6 @@ nlm_pic_set_timer(uint64_t base, int timer, uint64_t value, int irq, int cpu)
 
 static void nlm_config_cpu(void *data)
 {
-	write_c0_scratch(2, (u64 *)data);
+	write_c0_scratch(5, (u64 *)data);
 }
+
diff --git a/drivers/misc/netlogic/nmiprof/nmiprof_asm.S b/drivers/misc/netlogic/nmiprof/nmiprof_asm.S
index 44da885..6fb6876 100644
--- a/drivers/misc/netlogic/nmiprof/nmiprof_asm.S
+++ b/drivers/misc/netlogic/nmiprof/nmiprof_asm.S
@@ -11,23 +11,27 @@
 	.set	noreorder
 	.set	mips64r2
 	.set	noat
-
 FEXPORT(nlm_nmiprof)
 	dmtc0	k0, CP0_DIAGNOSTIC, 6
 	dmtc0	k1, CP0_DIAGNOSTIC, 7
-	dmfc0	k0, CP0_DIAGNOSTIC, 2
+	dmfc0	k0, CP0_DIAGNOSTIC, 5
 	dmfc0	k1, CP0_ERROREPC
 	sw	k1, 0(k0)
 	sw	ra, 4(k0)
+	/* Do over lap on single 4MB memory */
 	dextm	k1, k0, 22, 42
 	daddi	k0, 8
 	dinsm	k0, k1, 22, 42
-	dmtc0	k0, CP0_DIAGNOSTIC, 2
-	li	k0, 0xb8004100
-	li	k1, 0x400	/* (1 << PIC_IRT_TIMER_6_INDEX) */
-	sd	k1, (0x10)(k0)	/* (PIC_STATUS * 4)(k0) */
-	li	k1, 0xa		/* PIC_IRT_TIMER_6_INDEX */
-	sd	k1, (0x40)(k0)	/* (PIC_INT_ACK * 4)(k0) */
+	dmtc0	k0, CP0_DIAGNOSTIC, 5
+	.global	pic_entry
+pic_entry:
+	lui	k0, 0
+	li	k1, 0
+	sd	k1, 0(k0)
+
+	li	k1, 0
+	sd	k1, 0(k0)
+
 	li	k1, 0x00480000	/* set ack mask */
 	mfc0	k0, CP0_STATUS	/* Read status */
 	xor	k0, k1		/* Ack */
diff --git a/drivers/misc/netlogic/nmiprof/nmiprof_asm_xlr.S b/drivers/misc/netlogic/nmiprof/nmiprof_asm_xlr.S
deleted file mode 100644
index cb9e553..0000000
--- a/drivers/misc/netlogic/nmiprof/nmiprof_asm_xlr.S
+++ /dev/null
@@ -1,42 +0,0 @@
-#include <linux/init.h>
-
-#include <asm/asm.h>
-#include <asm/asm-offsets.h>
-#include <asm/regdef.h>
-#include <asm/mipsregs.h>
-#include <asm/stackframe.h>
-#include <asm/asmmacro.h>
-#include <asm/addrspace.h>
-
-	.set	noreorder
-	.set	mips64r2
-	.set	noat
-
-FEXPORT(nlm_nmiprof)
-	dmtc0	k0, CP0_DIAGNOSTIC, 6
-	dmtc0	k1, CP0_DIAGNOSTIC, 7
-	dmfc0	k0, CP0_DIAGNOSTIC, 2
-	dmfc0	k1, CP0_ERROREPC
-	sw	k1, 0(k0)
-	sw	ra, 4(k0)
-	dsrl	k1, k0, 22
-	dsll	k1, k1, 22
-	daddi	k0, 8
-	dsll32	k0, k0, 10
-	dsrl32	k0, k0, 10
-	or	k0, k0, k1
-	dmtc0	k0, CP0_DIAGNOSTIC, 2
-	li	k0, 0xb8004100
-	li	k1, 0x400	/* (1 << PIC_IRT_TIMER_6_INDEX) */
-	sd	k1, (0x10)(k0)	/* (PIC_STATUS * 4)(k0) */
-	li	k1, 0xa		/* PIC_IRT_TIMER_6_INDEX */
-	sd	k1, (0x40)(k0)	/* (PIC_INT_ACK * 4)(k0) */
-	li	k1, 0x00480000	/* set ack mask */
-	mfc0	k0, CP0_STATUS	/* Read status */
-	xor	k0, k1		/* Ack */
-	mtc0	k0, CP0_STATUS	/* Write status */
-	dmfc0	k0, CP0_DIAGNOSTIC, 6
-	dmfc0	k1, CP0_DIAGNOSTIC, 7
-	eret
-	nop
-EXPORT(nlm_nmiprof_end)
-- 
1.9.1

