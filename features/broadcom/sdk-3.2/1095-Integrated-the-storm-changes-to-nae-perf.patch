From 3f6c492ea6d86fd4465b7574c2230ebc84be3815 Mon Sep 17 00:00:00 2001
From: Hareesh Ramachandran <hareesh@london.(none)>
Date: Mon, 12 Dec 2011 05:02:57 -0800
Subject: [PATCH 1095/1532] Integrated the storm changes to nae-perf

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/nae-perf/xlp_nae.c | 729 ++++++++-----------------------
 1 file changed, 189 insertions(+), 540 deletions(-)

diff --git a/drivers/misc/netlogic/nae-perf/xlp_nae.c b/drivers/misc/netlogic/nae-perf/xlp_nae.c
index 2187bf4..2a9fe01 100755
--- a/drivers/misc/netlogic/nae-perf/xlp_nae.c
+++ b/drivers/misc/netlogic/nae-perf/xlp_nae.c
@@ -110,38 +110,30 @@
 
 #define NLM_TCP_MODE	1
 #define NLM_RT_MODE	2
-/*calculate number of instructions/clocks per packet*/
-#undef ENABLE_DEBUG_STATISTICS
 
-/*Calculate per cpu statistics - fast_path_replenish, total_packet_rcvd etc*/
-#undef ENABLE_PER_CPU_COUNTER
+/* Applicable only in tcp mode */
+#define TSO_ENABLED 1
 
 /*Enable sanity checks while receiving or transmitting buffer */
 #undef ENABLE_SANITY_CHECKS
 
-#undef ENABLE_LRO_DEBUG_STATS
 /* Module Parameters */
 static int debug = 0;
 module_param(debug, int, 0);
 
 static int drop_uboot_pkt = 1;
-module_param(drop_uboot_pkt, int, 0);
-static unsigned long stats_uboot_pkts;
-
-extern int naecfg_hack;
-module_param(naecfg_hack, int, 0);
 
 static int perf_mode= NLM_TCP_MODE;
 module_param(perf_mode, int, 0);
 static int enable_lro =  0;
 module_param(enable_lro, int, 0);
 
+static int num_descs_perq = 500;
+module_param(num_descs_perq, int, 0);
 /***************************************************************
  *
  * Below parameters are set during FDT file parsing
  */
-static int frin_desc_thres = 24;
-module_param(frin_desc_thres, int, 0);
 
 static uint32_t frin_queue_base = 1000;
 static uint32_t frin_total_queue = 18;
@@ -179,14 +171,8 @@ uint64_t last_rcvd_skb_phys[NR_CPUS * 8] ____cacheline_aligned;
 uint64_t fast_replenish_count[NR_CPUS * 8] __cacheline_aligned;
 uint64_t slow_replenish_count[NR_CPUS * 8] __cacheline_aligned;
 uint64_t err_replenish_count[NR_CPUS * 8] __cacheline_aligned;
-#ifdef ENABLE_DEBUG_STATISTICS
-volatile uint64_t skbuff_clocks[NR_CPUS * 8] __cacheline_aligned;
-volatile uint64_t skbuff_event[NR_CPUS * 8] __cacheline_aligned;
-#endif
 //make this array of 24 ports to keep it cacheline aligned.
 struct net_device *per_cpu_netdev[NR_CPUS][24] __cacheline_aligned;
-uint64_t total_cycles[NR_CPUS * 8] __cacheline_aligned;
-uint64_t total_rx_pkts[NR_CPUS * 8] __cacheline_aligned;
 
 #define ETHER_FRAME_MIN_LEN	64
 static struct pci_device_id soc_pci_table[] __devinitdata = {
@@ -246,19 +232,12 @@ static void xlp_mac_setup_hwaddr(struct dev_data *priv);
 static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id);
 #endif
 
-static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
-					uint32_t size, uint32_t code,
-					uint64_t msg0, uint64_t msg1,
-					uint64_t msg2, uint64_t msg3, void* data);
-
 static void nlm_xlp_mac_timer(unsigned long data);
 static struct net_device_stats *nlm_xlp_mac_get_stats(struct net_device *dev);
 
 static struct net_device *dev_mac[MAX_GMAC_PORT];
 
 extern struct proc_dir_entry *nlm_root_proc;
-static struct tasklet_struct mac_refill_task[MAX_GMAC_PORT];
-static int mac_refill_frin_desc(unsigned long dev);
 
 extern void nlm_xlp_mac_set_enable(struct dev_data *priv, int flag);
 
@@ -393,39 +372,6 @@ static __inline__ struct sk_buff *nlm_xlp_alloc_skb_atomic(void)
         return skb;
 }
 
-
-/**********************************************************************
- * nlm_xlp_free_skb -  change msg into skb buffer address, free it
- * @msg - freeback msg that sent to cpu vc
- *
- **********************************************************************/
-static inline void nlm_xlp_free_skb(struct xlp_msg *msg)
-{
-	struct sk_buff *skb;
-	struct dev_data *priv;
-	int cpu = hard_smp_processor_id();
-	unsigned long tmp;
-
-	tmp = (unsigned long)(msg->entry[0] & 0xffffffffffULL);
-	skb = (struct sk_buff *)bus_to_virt(tmp);
-
-	if(!skb)
-		return;
-	/* Tx Complete */
-
-	/* release the skb and update statistics outside the spinlock */
-	priv = netdev_priv(skb->dev);
-	STATS_INC(priv->stats.tx_packets);
-	STATS_ADD(priv->stats.tx_bytes, skb->len);
-	priv->cpu_stats[cpu].txc_packets++;
-
-
-	netif_tx_wake_all_queues(skb->dev);
-	/* nlm_netif_queue_tx_complete(skb->dev);*/
-
-	dev_kfree_skb_any(skb);
-}
-
 /*********************************************************************
   * set tso enable features in the dev list
  **********************************************************************/
@@ -684,7 +630,7 @@ void lro_init(struct net_device *dev)
 		dev->features |= NETIF_F_LRO;
 		for (cpu=0; cpu<NR_CPUS; cpu++) {
 			memset(&priv->lro_mgr[cpu], 0, sizeof(struct net_lro_mgr));
-			priv->lro_mgr[cpu].max_aggr = 16;
+			priv->lro_mgr[cpu].max_aggr = 48;
 			priv->lro_mgr[cpu].max_desc = LRO_MAX_DESCS;
 			priv->lro_mgr[cpu].get_skb_header = lro_get_skb_hdr;
 			priv->lro_mgr[cpu].features = LRO_F_NAPI;
@@ -700,13 +646,11 @@ void lro_init(struct net_device *dev)
 	if(!done) {
 		done = 1;
 		nlm_enable_l3_l4_parser();
-		#ifdef ENABLE_LRO_DEBUG_STATS
-		dump_parser_config();
-		#endif
+		//dump_parser_config();
 	}
 }
 
-#ifdef ENABLE_LRO_DEBUG_STATS
+#if 0
 static void dump_skb_info(struct sk_buff *skb, uint64_t msg1)
 {
 	struct tcphdr *tcp = (void *)(skb->data + 20);
@@ -732,73 +676,6 @@ static void dump_skb_info(struct sk_buff *skb, uint64_t msg1)
 }
 #endif
 
-/**********************************************************************
- * mac_refill_frin_desc -  refill rx freein buffer for a device
- * @dev -  this is per device based function
- *
- **********************************************************************/
-static int mac_refill_frin_desc(unsigned long dev)
-{
-	struct dev_data* priv;
-	struct net_device *ndev;
-        int ret, mflags, i, code,limit;
-        struct xlp_msg msg;
-	struct sk_buff * skb;
-
-	ndev = (struct net_device *) dev;
-	priv = netdev_priv(ndev);
-	ret = 0;
-
-	atomic64_inc(&priv->num_replenishes);
-
-	limit = atomic64_read(&priv->frin_to_be_sent);
-
-	for(i = 0; i < limit; i++)
-	{
-		skb = nlm_xlp_alloc_skb_atomic();
-		if(!skb)
-		{
-			printk("[%s] alloc skb failed\n",__FUNCTION__);
-
-			ret = -ENOMEM;
-			break;
-		}
-
-		skb->dev = ndev;
-
-		/* Send the free Rx desc to the MAC */
-		mac_put_skb_back_ptr(skb);
-		code = 0;
-
-		msgrng_access_enable(mflags);
-		msg.entry[0] = (unsigned long long)virt_to_bus(skb->data) & 0xffffffffffULL;
-		msg.entry[1]= msg.entry[2] = msg.entry[3] = 0;
-		/* Send the packet to nae rx  */
-		__sync();
-
-		if ( (ret = nlm_hal_send_msg1(priv->nae_rx_qid, code, msg.entry[0])) & 0x7)
-		{
-			print_fmn_send_error(__func__, ret);
-			printk("Unable to send configured free desc, check freein carving (qid=%d)\n", priv->nae_rx_qid);
-
-			/* free the buffer and return! */
-			dev_kfree_skb_any(skb);
-
-			msgrng_access_disable(mflags);
-
-			ret = -EBUSY;
-			break;
-                }
-		msgrng_access_disable(mflags);
-
-		atomic64_dec(&priv->frin_to_be_sent);
-
-		atomic64_inc(&priv->total_frin_sent);
-	}
-
-        return ret;
-}
-
 static int mac_refill_frin_skb(uint64_t paddr, int qid)
 {
        int ret, code;
@@ -838,10 +715,7 @@ static int mac_refill_frin_one_buffer(struct net_device *dev, int cpu)
 	priv = netdev_priv(ndev);
 	skb->dev = ndev;
 	mac_put_skb_back_ptr(skb);
-	if(nlm_mode[LAST_RCVD_INDEX(cpu)] == NLM_RT_MODE)
-		return mac_refill_frin_skb((unsigned long long)virt_to_bus(skb->data), frin_queue_base + (cpu/2));
-	else
-		return mac_refill_frin_skb((unsigned long long)virt_to_bus(skb->data), priv->nae_rx_qid);
+	return mac_refill_frin_skb((unsigned long long)virt_to_bus(skb->data), frin_queue_base + (cpu/2));
 }
 
 static int nae_proc_read(char *page, char **start, off_t off,
@@ -850,21 +724,12 @@ static int nae_proc_read(char *page, char **start, off_t off,
 	int len = 0;
 	int i = 0;
 	uint64_t total_err = 0, total_fast = 0, total_slow = 0;
-#ifdef ENABLE_DEBUG_STATISTICS
-	uint64_t clocks = 0, instrs = 0;
-#endif
+
 	for(i=0; i<32; i++){
 		printk("cpu%d, fast_repl %ld, slow_repl %ld, err_repl %ld tcprxcons %lld p2pdalloc %lld\n",i, (unsigned long)fast_replenish_count[LAST_RCVD_INDEX(i)], (unsigned long)slow_replenish_count[LAST_RCVD_INDEX(i)], (unsigned long)err_replenish_count[LAST_RCVD_INDEX(i)], dbg_tcp_rx_cons[CPU_INDEX(i)], p2p_dynamic_alloc_cnt[CPU_INDEX(i)]);
 		total_err += err_replenish_count[LAST_RCVD_INDEX(i)];
 		total_fast += fast_replenish_count[LAST_RCVD_INDEX(i)];
 		total_slow += slow_replenish_count[LAST_RCVD_INDEX(i)];
-#ifdef ENABLE_DEBUG_STATISTICS
-		clocks += skbuff_clocks[LAST_RCVD_INDEX(i)];
-		instrs += skbuff_event[LAST_RCVD_INDEX(i)];
-		printk("%d %lld %lld\n",i, (unsigned long long)skbuff_clocks[LAST_RCVD_INDEX(i)], skbuff_event[LAST_RCVD_INDEX(i)]);
-		skbuff_clocks[LAST_RCVD_INDEX(i)] = 0;
-		skbuff_event[LAST_RCVD_INDEX(i)] = 0 ;
-#endif
 		dbg_tcp_rx_cons[CPU_INDEX(i)] = 0;
 		p2p_dynamic_alloc_cnt[CPU_INDEX(i)] = 0;
 	}
@@ -874,6 +739,22 @@ static int nae_proc_read(char *page, char **start, off_t off,
 	*eof = 1;
 	return len;
 }
+
+#ifdef NAPI_MODEL
+static inline void nlm_enable_msgring_intr(void)
+{
+	uint32_t val;
+	/* Need write vc into the register */
+	val =  _read_32bit_cp2_register(XLP_MSG_STATUS1_REG);
+	//val |= ((1 << vc) << 16);
+	val |= (0xf << 16);
+	_write_32bit_cp2_register(XLP_MSG_STATUS1_REG, val);
+
+}
+#endif
+
+
+
 /*
  * NAE poll function on upper four buckets
 */
@@ -898,7 +779,6 @@ xlp_poll_upper(int cpu)
 			if (drop_uboot_pkt) {
 				if ( (addr >= (192<<20)) && (addr < (256 << 20)) ){
 					printk("Dropping firmware TXC packet (addr=%llx)!\n", addr);
-					//stats_uboot_pkts++;
 					return;
 				}
 			}
@@ -906,14 +786,15 @@ xlp_poll_upper(int cpu)
 			/* context field is currently unused */
 			context = (msg0 >> 40) & 0x3fff;
 			port = cntx2port[context];
+#ifdef TSO_ENABLED
 			if(nlm_mode[LAST_RCVD_INDEX(cpu)] == NLM_TCP_MODE){
 				p2pfbdesc = bus_to_virt(addr);
 				skb = (struct sk_buff *)(p2pfbdesc[P2P_SKB_OFF]);
 				free_p2p_desc_mem(cpu, p2pfbdesc);
-			}
-			else{
+			} else
+#endif
 				skb = (struct sk_buff *)bus_to_virt(addr);
-			}
+			
 			if(skb)
 			{
 				priv = netdev_priv(skb->dev);
@@ -931,11 +812,11 @@ xlp_poll_upper(int cpu)
 	} /* closing while (1) */
 }
 
+
 /*
  * NAE poll function on lower four buckets
 */
-static int
-xlp_poll_lower(int budget, int cpu)
+static int xlp_poll_lower(int budget, int cpu)
 {
 	int err ;
 	int status;
@@ -950,10 +831,7 @@ xlp_poll_lower(int budget, int cpu)
 	struct sk_buff* skb;
 	uint64_t msg0;
 	uint32_t src_id, size, code;
-#ifdef ENABLE_DEBUG_STATISTICS
-	uint64_t stamp1, stamp2;
-	uint64_t count1, count2;
-#endif
+
 #ifdef CONFIG_INET_LRO		  
 	int lro_flush_priv_cnt = 0, i;
 	char lro_flush_needed[20] = { 0 };
@@ -962,11 +840,15 @@ xlp_poll_lower(int budget, int cpu)
 	while (budget--) {
 
 		status = xlp_message_receive_2(nae_rx_vc, &src_id, &size, &code, &msg0, &msg1);
-		if (status)	continue;
-//		__sync();
-#ifdef ENABLE_PER_CPU_COUNTER
-		no_rx_pkt_rcvd++;
+#ifdef NAPI_MODEL
+		if(status)
+			break;
+#else
+		if (status)	
+			continue;
 #endif
+
+		no_rx_pkt_rcvd++;
 #ifdef ENABLE_SANITY_CHECKS
 		if(size != 2) {
 			printk("Unexpected single entry packet in poll_lower\n");
@@ -982,15 +864,7 @@ xlp_poll_lower(int budget, int cpu)
 		context = (msg1 >> 54) & 0x3ff;
 
 		if (err) {
-			if(nlm_mode[LAST_RCVD_INDEX(cpu)] == NLM_RT_MODE){
-				mac_refill_frin_skb(addr, frin_queue_base + (cpu/2));
-			}
-			else{
-					int qid = frin_queue_base + context * 4;
-			        if(context >= 4)
-					qid = 1016 + context - 4;
-				mac_refill_frin_skb(addr, qid);
-			}
+			mac_refill_frin_skb(addr, frin_queue_base + (cpu/2));
 			STATS_INC(priv->stats.rx_errors);
 			STATS_INC(priv->stats.rx_dropped);
 			err_replenish_count[LAST_RCVD_INDEX(cpu)]++;
@@ -999,24 +873,11 @@ xlp_poll_lower(int budget, int cpu)
 
 		if ( (addr >= (192<<20)) && (addr < (256 << 20))){
 			printk("Dropping firmware RX packet (addr=%llx)!\n", addr);
-			//stats_uboot_pkts++;
 			continue;
 		}
 
-#if 0
-		if(context == 0){
-			port = 0;
-		}else if(context == 4){
-			port = 1;
-		}else{
-			port = cntx2port[context];
-		}
-#endif
-		if(context < 4)
-			port = context;
-		else
-			port = cntx2port[context];
-//		port = cntx2port[context];
+		port = cntx2port[context];
+
 #ifdef ENABLE_SANITY_CHECKS
 		if(port >= MAX_GMAC_PORT)
 		{
@@ -1049,99 +910,46 @@ xlp_poll_lower(int budget, int cpu)
 			continue;
 		}
 #endif
-#if 0
-		prefetch_local(skb);
-		prefetch_local((void *)((unsigned long)skb + 1 * SMP_CACHE_BYTES));
-		prefetch_local((void *)((unsigned long)skb + 2 * SMP_CACHE_BYTES));
-		prefetch_local((void *)((unsigned long)skb + 3 * SMP_CACHE_BYTES));
-		prefetch_local(skb->data);
-#endif
-
-//		skb->dev = dev_mac[port];
 
 		skb_put(skb, len);
 
 		skb->protocol = eth_type_trans(skb, pdev);
 		//skb->dev->last_rx = jiffies;
-//		skb->ip_summed = CHECKSUM_UNNECESSARY;
 
 		/* Pass the packet to Network stack */
 		last_rcvd_skb[LAST_RCVD_INDEX(cpu)] = skb;
 		last_rcvd_skb_phys[LAST_RCVD_INDEX(cpu)] = addr;
 
-//		start_counter = read_dmfur_cycles();
-		{
-#ifdef DRV_LOOPBACK
-		  if(port > 3)
-		    netif_receive_skb(skb);
-		  else
-		    nlm_xlp_nae_start_xmit(skb, skb->dev);
-#else
-#ifdef ENABLE_DEBUG_STATISTICS
-		  stamp1 = read_dmfur_cycles();
-		  count1 = read_c0_perfcntr0();
-#endif
 #ifdef CONFIG_INET_LRO
-		  if((skb->dev->features & NETIF_F_LRO) && 
-				  (msg1 & RX_IP_CSUM_VALID) && (msg1 & RX_TCP_CSUM_VALID)) {		
-			 #ifdef ENABLE_LRO_DEBUG_STATS
-			 dump_skb_info(skb, msg1);
-			 #endif			 
-			 skb->ip_summed = CHECKSUM_UNNECESSARY;
-			 lro_receive_skb(&priv->lro_mgr[cpu], skb, (void *)msg1);
-			 if(!lro_flush_needed[port]) {
-				 lro_flush_priv[lro_flush_priv_cnt] = priv;
-				 lro_flush_needed[port] = 1;
-				 lro_flush_priv_cnt++;
-			 }
-		  } else
-#endif
-		  {
-		  	netif_receive_skb(skb);
-		  }
-#ifdef ENABLE_DEBUG_STATISTICS
-		  stamp2 = read_dmfur_cycles();
-		  count2 = read_c0_perfcntr0();
-
-		  if(skbuff_clocks[LAST_RCVD_INDEX(cpu)]){
-			  skbuff_clocks[LAST_RCVD_INDEX(cpu)] = ((stamp2 - stamp1) + skbuff_clocks[LAST_RCVD_INDEX(cpu)])/2;
-			  skbuff_event[LAST_RCVD_INDEX(cpu)] = ((count2 - count1) + skbuff_event[LAST_RCVD_INDEX(cpu)])/2;
-		  }
-		  else{
-			  skbuff_clocks[LAST_RCVD_INDEX(cpu)] = stamp2 - stamp1;
-			  skbuff_event[LAST_RCVD_INDEX(cpu)] = count2 - count1;
-		  }
-#endif
+		if((skb->dev->features & NETIF_F_LRO) && 
+				(msg1 & RX_IP_CSUM_VALID) && (msg1 & RX_TCP_CSUM_VALID)) {		
+			 
+			skb->ip_summed = CHECKSUM_UNNECESSARY;
+			lro_receive_skb(&priv->lro_mgr[cpu], skb, (void *)msg1);
+			if(!lro_flush_needed[port]) {
+				lro_flush_priv[lro_flush_priv_cnt] = priv;
+				lro_flush_needed[port] = 1;
+				lro_flush_priv_cnt++;
+			}
+		} else
 #endif
+		{
+			netif_receive_skb(skb);
 		}
-//		stop_counter = read_dmfur_cycles();
-		//total_cycles[LAST_RCVD_INDEX(cpu)] += (stop_counter - start_counter);
 
 		/* Update Stats */
 		STATS_ADD(priv->stats.rx_bytes, len);
 		STATS_INC(priv->stats.rx_packets);
 		//priv->cpu_stats[cpu].rx_packets++;
-#if 0
-		if (atomic64_inc_return(&priv->frin_to_be_sent) > frin_desc_thres);
-		{
-			tasklet_schedule(&mac_refill_task[port]);
-			//mac_refill_frin_desc((unsigned long) skb->dev) ;
-		}
 
-		if((no_rx_pkt_rcvd + 1) == budget)
-				break;
-#else
 		if (last_rcvd_skb[LAST_RCVD_INDEX(cpu)]) {
 		  //printk("[%s@%d]: Unwanted buffer allocation in driver data path!\n", __FILE__, __LINE__);
 			slow_replenish_count[LAST_RCVD_INDEX(cpu)]++;
 			mac_refill_frin_one_buffer(pdev, cpu);
 			last_rcvd_skb[LAST_RCVD_INDEX(cpu)] = NULL;
 		}
-#endif
 	}
-#ifdef ENABLE_PER_CPU_COUNTER
-	total_rx_pkts[LAST_RCVD_INDEX(cpu)] += no_rx_pkt_rcvd;
-#endif
+
 #ifdef CONFIG_INET_LRO
 	for(i = 0; i < lro_flush_priv_cnt; i++)
                 lro_flush_all(&lro_flush_priv[i]->lro_mgr[cpu]);
@@ -1154,43 +962,49 @@ xlp_poll_lower(int budget, int cpu)
 /*
  * Main NAE poll loop
 */
+
+#ifdef NAPI_MODEL
+static int xlp_nae_poll(struct napi_struct *napi, int budget)
+{
+	int rx_pkts = 0;
+	int cpu = hard_smp_processor_id();
+
+	napi_dbg("%s in budget %d\n", __FUNCTION__, budget);
+	if(perf_mode == NLM_RT_MODE)
+		budget = 300000;
+
+	xlp_poll_upper(cpu);
+	rx_pkts = xlp_poll_lower(budget, cpu);
+
+	if(rx_pkts < budget) {
+		napi_complete(napi);
+
+		nlm_enable_msgring_intr();
+	}
+
+	return rx_pkts;
+}
+#else
+
 static int xlp_nae_poll(void *buf)
 {
 	//unsigned int count=0;
 	int rx_pkts = 0;
 	int cpu = hard_smp_processor_id();
-	int budget = 64;
+	int budget = 96;
 
 	if(perf_mode == NLM_RT_MODE)
 		budget = 300000;
-#ifdef ENABLE_DEBUG_STATISTICS
-	/*start perf counter to count number of instructions..*/
-	write_c0_perfctrl0(24<<5|0xf);
-#endif
+
 	while (1) {
-#ifdef ENABLE_PER_CPU_COUNTER
-        uint64_t pkts = 0;
-	total_cycles[LAST_RCVD_INDEX(cpu)] = 0;
-	total_rx_pkts[LAST_RCVD_INDEX(cpu)] = 0;
-#endif
 
-	local_bh_disable();
-	xlp_poll_upper(cpu);
-	rx_pkts = xlp_poll_lower(budget, cpu);
-	local_bh_enable();
+		local_bh_disable();
+		xlp_poll_upper(cpu);
+		rx_pkts = xlp_poll_lower(budget, cpu);
+		local_bh_enable();
+
 
-#ifdef ENABLE_PER_CPU_COUNTER
-	pkts = total_rx_pkts[LAST_RCVD_INDEX(cpu)];
-#endif
-	/* if (pkts) { */
-	/*   printk("[cpu@%d]/cycles: total_cycles = %llu, pkts = %llu, cycles/pkt = %llu\n", */
-	/* 	 cpu, total_cycles, pkts, total_cycles[LAST_RCVD_INDEX(cpu)]/pkts); */
-	/* } */
-	//count++;
-	//if(count == 1000) {
 		schedule();
-	//	count=0;
-	//}
 	}
 	return 0;
 }
@@ -1219,33 +1033,6 @@ void nlm_spawn_kthread(void)
     }
 
 }
-
-#if 0
-static void nlm_enable_parser(void)
-{
-	int l2proto = 1; //ethernet
-	int port = 0, i, ipchk = 1;
-	uint32_t val = 0;
-	uint32_t naereg = nlm_hal_read_nae_reg(RX_CONFIG);
-
-	nlm_hal_write_nae_reg(RX_CONFIG, (naereg | 1 << 12 | 1 << 13 | 3 << 22)); //enabling hardware parser
-	printk("Enabling parser reg.. %x\n", nlm_hal_read_nae_reg(RX_CONFIG));
-
-	/* enabling extraction of data */
-	for(i=0; i<16;i++)
-		nlm_hal_write_nae_reg(L2_TYPE_0 + i, l2proto);
-
-	nlm_hal_write_nae_reg(L3_CTABLE_MASK_0, port | 0 << 5 | 1 << 6); // l2proto and ethtype included
-
-	val = ((0 << 26) | (9 << 20) | (ipchk << 18) | (1 << 16) | (0x800));
-	nlm_hal_write_nae_reg(L3_CTABLE_0_0, val);
-	val =   (12 << 26) | (4 << 21) | (16 << 15) | (4 << 10); /* extract sourceip and dstip */
-	nlm_hal_write_nae_reg(L3_CTABLE_0_1, val);
-
-//	nlm_hal_write_nae_reg(L4_CTABLE_0_0, 1 << 17 | 0x6); /* ip_proto = tcp */
-//	val = ((0 << 21) | (2 << 17) | (2 << 11) | (2 << 7)); /* extract source and dst port*/
-//	nlm_hal_write_nae_reg(L4_CTABLE_0_1, val);
-}
 #endif
 
 static void nlm_update_ucore_shared_memory(void)
@@ -1270,7 +1057,7 @@ static void nlm_update_ucore_shared_memory(void)
 }
 
 
-static void nlm_replenish_per_cpu_buffer(void)
+static void nlm_replenish_per_cpu_buffer(int qindex, int bufcnt)
 {
 	int i;
 	int vc_index = 0;
@@ -1279,11 +1066,9 @@ static void nlm_replenish_per_cpu_buffer(void)
 	struct sk_buff * skb;
 	int ret = 0;
 
-	/*Using 16 rx_free_in_fifo (1 per 2 cpu)
-	  Allocate 16 buffers per queue.*/
-	for(i = 0; i < frin_total_queue*16; i++)
+	for(i = 0; i < bufcnt; i++)
 	{
-		vc_index = (i/16) + frin_queue_base;
+		vc_index =  qindex + frin_queue_base;
 		skb = nlm_xlp_alloc_skb_atomic();
 		if(!skb)
 		{
@@ -1313,8 +1098,63 @@ static void nlm_replenish_per_cpu_buffer(void)
 		}
 		msgrng_access_disable(mflags);
 	}
+	printk("Send %d descriptors for queue %d(vc %d)\n", bufcnt, qindex, vc_index);
 }
-//#endif
+
+#ifdef NAPI_MODEL
+/*
+ * Setup XLP NAPI subsystem
+ */
+static int napi_weight = 300;
+/* XLP_NAPI global data strucutre */
+struct net_device xlp_napi_dummy_dev;
+DEFINE_PER_CPU(struct napi_struct, xlp_napi_poll_struct);
+
+/* XLR NAPI per CPU packet counter */
+DEFINE_PER_CPU(unsigned long long, xlp_napi_rx_count);
+
+static void napi_msgint_handler(int vc)
+{
+	struct napi_struct *napi;
+	int cpu = hard_smp_processor_id();
+
+	napi_dbg("%s in vc %d cpu %d\n", __FUNCTION__, vc, cpu);
+
+	napi = &__get_cpu_var(xlp_napi_poll_struct);
+	napi_schedule(napi);
+}
+
+extern int register_vc_handler(int nae_rx_vc, void (*napi_msgint_handler)(int));
+
+static int nlm_xlp_napi_setup(void)
+{
+	int i, cpu_count;
+	struct napi_struct *napi;
+	int weight_p = napi_weight;
+
+	printk("MSGRING_NAPI: Initializing NLM NAPI subsystem\n");
+
+	init_dummy_netdev(&xlp_napi_dummy_dev);
+
+	for (cpu_count = 0; cpu_count < NR_CPUS; cpu_count++)
+	{
+		napi = &per_cpu(xlp_napi_poll_struct, cpu_count);
+		memset(napi, 0, sizeof(*napi));
+		netif_napi_add(&xlp_napi_dummy_dev, napi, xlp_nae_poll, weight_p);
+		napi_enable(napi);
+	}
+
+	for (i = 0; i < NR_CPUS; i++) {
+		per_cpu(xlp_napi_rx_count, i) = 0;
+	}
+
+	register_vc_handler(nae_rx_vc, napi_msgint_handler);
+	register_vc_handler(nae_fb_vc, napi_msgint_handler);
+
+	return 0;
+}
+
+#endif
 
 
 
@@ -1341,8 +1181,8 @@ static void nlm_xlp_nae_init(void)
 
 
 	printk("======= Module Parameters =========\n");
-	printk("debug = %d, frin_desc_thres=%d naecfg_hack=%d drop_uboot_pkt=%d, perf_mode=%s\n",
-	       debug, frin_desc_thres, naecfg_hack, drop_uboot_pkt, mode_str[perf_mode]);
+	printk("debug = %d, num_descs_perq=%d perf_mode=%s\n",
+	       debug, num_descs_perq, mode_str[perf_mode]);
 
 	for(i=0; i<NR_CPUS; i++)
 		nlm_mode[LAST_RCVD_INDEX(i)] = perf_mode;
@@ -1397,16 +1237,10 @@ static void nlm_xlp_nae_init(void)
 		/* set ethtool_ops which is inside xlp_ethtool.c file*/
 		xlp_set_ethtool_ops(dev);
 
-		/*netif_napi_add(dev, &priv->napi, nlm_xlp_napi_poll, 16);*/
-
 		dev->dev_addr = eth_hw_addr[i];
 		priv->port	= i;
 		priv->hw_port_id = nae_cfg.ports[i].hw_port_id;
 
-		atomic64_set(&priv->frin_to_be_sent, nae_cfg.ports[i].num_free_desc);
-		atomic64_set(&priv->num_replenishes, 0);
-		atomic64_set(&priv->total_frin_sent, 0);
-
 		priv->inited	= 0;
 		priv->block 	= nae_cfg.ports[i].hw_port_id / 4;
 		priv->type = nae_cfg.ports[i].iftype;
@@ -1441,9 +1275,6 @@ static void nlm_xlp_nae_init(void)
 			per_cpu_netdev[cpu][i] = dev;
 		}
 
-		tasklet_init(&mac_refill_task[priv->port],
-			     (void (*)(long unsigned int))mac_refill_frin_desc,
-			     (unsigned long)dev);
 	}
 
 	entry = create_proc_read_entry("mac_stats", 0 /* def mode */ ,
@@ -1460,12 +1291,37 @@ static void nlm_xlp_nae_init(void)
 		printk("[%s]: Unable to create proc read entry for nae_proc!\n",
 		       __FUNCTION__);
 	}
+
+#ifndef NAPI_MODEL
 	/*spawn percpu kthread*/
 	nlm_spawn_kthread();
-//	nlm_enable_parser();
-	if(perf_mode == NLM_RT_MODE)
-		nlm_replenish_per_cpu_buffer();
+#endif
+
+	/* configure the descs */
+	if(nae_cfg.freein_fifo_shared) {
+		int max_descs_pqueue, num_descs;
+		max_descs_pqueue = nae_cfg.freein_fifo_onchip_num_descs +  nae_cfg.freein_fifo_spill_num_descs;
+		num_descs = num_descs_perq <= max_descs_pqueue ? num_descs_perq : max_descs_pqueue;
+
+		for(i = 0; i < frin_total_queue; i++) {
+			if(i < 16) 
+				nlm_replenish_per_cpu_buffer(i, num_descs);
+		}
+		/* configure the mgmt port, for mgmt ports take it from the port config */
+		for(i = 0; i < nae_cfg.num_ports; i++) {
+			if(!nae_cfg.ports[i].mgmt)
+				continue;
+			nlm_replenish_per_cpu_buffer(nae_cfg.ports[i].rxq - frin_queue_base, 
+					nae_cfg.ports[i].num_free_desc);
+		}
 
+	} else {
+		for(i = 0; i < nae_cfg.num_ports; i++)
+		{
+			nlm_replenish_per_cpu_buffer(nae_cfg.ports[i].rxq - frin_queue_base, 
+					nae_cfg.ports[i].num_free_desc);
+		}
+	}
 }
 
 /**********************************************************************
@@ -1480,7 +1336,9 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 	int ret = 0;
 
 	if(perf_mode == NLM_TCP_MODE) {
+#ifdef TSO_ENABLED
 		tso_enable(dev, 1);
+#endif
 		lro_init(dev);
 	}
 
@@ -1492,20 +1350,6 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 		return 0;
 	}
 
-#if 0
-	if(register_xlp_msgring_handler( XLP_MSG_HANDLE_NAE_0 , nlm_xlp_nae_msgring_handler, dev))
-	{
-		printk("Fatal error! Can't register msgring handler for TX_STN_GMAC0");
-		ret = -1;
-		goto out;
-	}
-#endif
-
-	if(perf_mode == NLM_TCP_MODE){
-		ret = mac_refill_frin_desc((unsigned long)dev);
-		if (ret) goto out;
-	}
-
 #ifdef ENABLE_NAE_PIC_INT
 	{
 		int port = priv->port;
@@ -1571,7 +1415,6 @@ static int  nlm_xlp_nae_stop (struct net_device *dev)
 
 	netif_tx_stop_all_queues(dev);
 
-//	napi_disable(&priv->napi);
 	spin_unlock_irq(&priv->lock);
 	return 0;
 }
@@ -1765,9 +1608,11 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		return -1;
 	}
 #endif
+#ifdef TSO_ENABLED
 	if(nlm_mode[LAST_RCVD_INDEX(cpu)] == NLM_TCP_MODE){
 		return tso_xmit_skb(skb, dev);
 	}
+#endif
 
 #ifdef CONFIG_NLM_NET_OPTS
 	if(skb->netl_skb && (last_rcvd_skb[LAST_RCVD_INDEX(cpu)] == skb->netl_skb) && !skb_shared(skb)) 
@@ -1780,9 +1625,8 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		msg0 = nae_tx_desc(P2D_NEOP, 0, (cpu/2) + 32,
 					   0, last_rcvd_skb_phys[LAST_RCVD_INDEX(cpu)]);
 		hw_repl = 1;
-#ifdef ENABLE_PER_CPU_COUNTER
-		fast_replenish_count[LAST_RCVD_INDEX(cpu)]++;
-#endif
+		
+		//fast_replenish_count[LAST_RCVD_INDEX(cpu)]++;
 	}
 	else {
 		msg0 = nae_tx_desc(P2D_NEOP, 0, cpu, 0, virt_to_bus(skb));
@@ -1790,34 +1634,23 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
        msg1 = nae_tx_desc(P2D_EOP, 0, NULL_VFBID, skb->len, 
 		       virt_to_bus(skb->data));
 	if(hw_repl) {
-//      	uint64_t cycles = 0;
-
-//		cycles = read_dmfur_cycles();
 		/* reset the skb for next rx */
 #ifndef DRV_LOOPBACK
 		/* Leak no dsk entries! */
 		//dst_release((struct dst_entry *)skb->_skb_dst);
 		skb_dst_drop(skb);
 #endif
-		//total_cycles[LAST_RCVD_INDEX(hard_smp_processor_id())] += (read_dmfur_cycles() - cycles);
-
 		/* Reset all fields to 0, reset data pointers */
 		skb_reset_ptrs(skb);
 
 		offset = (((unsigned long)skb->data + CACHELINE_SIZE) & ~(CACHELINE_SIZE - 1));
 		skb_reserve(skb, (offset - (unsigned long)skb->data));
 
-		/*this buffer already has backptr...*/
-//		mac_put_skb_back_ptr(skb);
+		/*this buffer already has backptr...
+		mac_put_skb_back_ptr(skb); */
 		skb_reserve(skb, CACHELINE_SIZE);
 	}
 
-#ifdef ENABLE_SANITY_CHECKS
-	if (0) {
-//		printk("[%s]: tx_qid=%d, entry0=%llx, entry1=%llx\n", __func__,
-//		       priv->nae_tx_qid, msg.entry[0], msg.entry[1]);
-	}
-#endif
 
 retry_send:
 	ret = nlm_hal_send_msg2(priv->nae_tx_qid, 0, msg0, msg1);
@@ -1832,7 +1665,6 @@ retry_send:
 		//print_fmn_send_error(__func__, ret);
 		//printk("[%s] HACK ALERT! dropping packet(skb=%p)!\n", __func__, skb);
 		dev_kfree_skb_any(skb);
-		//goto retry_send;
         }
 //	dev->trans_start = jiffies;
 
@@ -1997,186 +1829,6 @@ static irqreturn_t nlm_xlp_nae_int_handler(int irq, void *dev_id)
 #endif
 
 /**********************************************************************
- * nlm_xlp_nae_msgring_handler -  message ring interrupt handler
- * @vc-  virtual channel number
- * @dev_id  -  this device
- *
- **********************************************************************/
-static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
-					uint32_t size, uint32_t code,
-					uint64_t msg0, uint64_t msg1,
-					uint64_t msg2, uint64_t msg3, void* data)
-{
-        struct net_device *pdev;
-        struct dev_data *priv;
-	unsigned int len, port = 0, context;
-        uint64_t addr , vaddr;
-	struct sk_buff* skb;
-	int cpu = 0;
-
-	printk("[%s @ %d] MSGRING HANDLER CALLED!!!!!!!\n",__FUNCTION__,__LINE__);
-	cpu = hard_smp_processor_id();
-	vc = vc & 0x03;
-
-	if (debug) {
-		printk("[%s] src_id=%d vc = %d, size = %d, entry0=%llx entry1=%llx\n", __func__,
-		       src_id, vc, size, msg0, msg1);
-	}
-
-	if( vc == nae_fb_vc && size == 1)
-	{
-		/* Process Transmit Complete, addr is the skb pointer */
-		addr = msg0 & 0xffffffffffULL;
-
-		if (drop_uboot_pkt) {
-			if ( (addr >= (192<<20)) && (addr < (256 << 20)) ) {
-				printk("Dropping firmware TXC packet (addr=%llx)!\n", addr);
-				stats_uboot_pkts++;
-				return;
-			}
-		}
-
-		/* context field is currently unused */
-		context = (msg0 >> 40) & 0x3fff;
-		port = cntx2port[context];
-#ifdef DEBUG_CONTEXT_PORT_MAPPING
-                if (port == 0) printk("FB context %d port %d \n",context, port);
-#endif
-		skb = (struct sk_buff *)bus_to_virt(addr);
-		if(skb)
-		{
-			priv = netdev_priv(skb->dev);
-
-			if (debug) {
-				printk("[%s][TXC] addr=%llx, skb=%p, context=%d, port=%d\n",
-				       __func__, addr, skb, context, port);
-			}
-			dev_kfree_skb_any(skb);
-
-			priv->cpu_stats[cpu].txc_packets++;
-		}
-		else {
-			printk("[%s]: [txc] Null skb? paddr = %llx (halting cpu!)\n", __func__, addr);
-			cpu_halt();
-		}
-	}
-	else if(vc == nae_rx_vc && size == 2)
-	{
-		int bad_pkt = 0;
-		int err = (msg1 >> 4) & 0x1;
-		int ip_csum_valid = (msg1 >> 3) & 0x1;
-		int tcp_csum_valid = (msg1 >> 2) & 0x1;
-
-		/* Rx packet */
-		addr	= msg1 & 0xffffffffc0ULL;
-		len	= (msg1 >> 40) & 0x3fff;
-		context = (msg1 >> 54) & 0x3ff;
-
-#ifdef DEBUG_RXPKT_ADDR_NULL
-		if (addr == 0) {
-			printk("Rcvd pkt address NULL !!!\n");
-			printk("[%s] src_id=%d vc = %d, size = %d, entry0=%llx entry1=%llx\n", __func__,
-                       src_id, vc, size, msg0, msg1);
-			return;
-		}
-#endif
-		if (err) bad_pkt = 1;
-
-		if (drop_uboot_pkt) {
-			if ( (addr >= (192<<20)) && (addr < (256 << 20)) ) {
-				printk("Dropping firmware RX packet (addr=%llx)!\n", addr);
-				stats_uboot_pkts++;
-				return;
-			}
-		}
-
-		port = cntx2port[context];
-#ifdef DEBUG_CONTEXT_PORT_MAPPING
-		if (port == 0) printk("Rx context %d port %d \n",context, port);
-#endif
-		if(port >= MAX_GMAC_PORT)
-		{
-			printk("[%s]: bad port=%d, context=%d\n", __func__, port, context);
-			return;
-		}
-
-		pdev = (struct net_device*)dev_mac[port];
-		if(!pdev) {
-			printk("[%s]: [rx] wrong port=%d(context=%d)? pdev = NULL!\n", __func__, port, context);
-			return;
-		}
-		priv = netdev_priv(pdev);
-
-		vaddr = (uint64_t)bus_to_virt(addr);
-
-		if (debug) {
-			printk("[%s][RX] addr=%llx, len=%d, context=%d, port=%d, vaddr=%llx\n",
-			       __func__, addr, len, context, port, vaddr);
-		}
-
-		DUMP_PKT("RX Packet: ", (unsigned char *)vaddr, len);
-
-		len = len  - MAC_CRC_LEN;
-
-		skb = mac_get_skb_back_ptr(vaddr);
-		if (!skb) {
-			STATS_INC(priv->stats.rx_errors);
-			STATS_INC(priv->stats.rx_dropped);
-			printk("[%s] Null skb? addr=%llx, vaddr=%llx, drop it!\n",
-			       __func__, addr, vaddr);
-			cpu_halt();
-			return;
-		}
-
-		if (debug) {
-			struct iphdr *iph = (struct iphdr *)(vaddr + 14);
-			int net_pkt_len = iph->tot_len + 14;
-			int eth_proto = *(unsigned short *)(vaddr + 12);
-
-			if ((eth_proto == 0x800) && (net_pkt_len != len)) bad_pkt = 1;
-
-			if (bad_pkt) {
-				printk("[%s]: vaddr=%llx (len:%d/%d) (ip:proto=%d) (%d/%d/%d))\n",
-				       __func__, vaddr, net_pkt_len, len, iph->protocol,
-				       err, ip_csum_valid, tcp_csum_valid);
-			}
-		}
-
-		if (bad_pkt) {
-			STATS_INC(priv->stats.rx_errors);
-			STATS_INC(priv->stats.rx_dropped);
-
-			dev_kfree_skb_any(skb);
-			goto out;
-		}
-
-		skb_put(skb, len);
-		skb->dev = dev_mac[port];
-		skb->protocol = eth_type_trans(skb, dev_mac[port]);
-		skb->dev->last_rx = jiffies;
-
-		/* Pass the packet to Network stack */
-		netif_rx (skb);
-
-		/* Update Stats */
-		STATS_ADD(priv->stats.rx_bytes, len);
-		STATS_INC(priv->stats.rx_packets);
-		priv->cpu_stats[cpu].rx_packets++;
-
-	out:
-		if (atomic64_inc_return(&priv->frin_to_be_sent) > frin_desc_thres);
-		{
-			tasklet_schedule(&mac_refill_task[port]);
-			//mac_refill_frin_desc((unsigned long) skb->dev) ;
-		}
-	} else {
-		printk("[%s]: wrong vc=%d or size=%d?\n", __func__, vc, size);
-	}
-
-	return;
-}
-
-/**********************************************************************
  * xlp_mac_proc_read -  proc file system read routine
  * @page     -  buffer address
  * @dev_id  -  this device
@@ -2191,8 +1843,6 @@ static int xlp_mac_proc_read(char *page, char **start, off_t off,
 	struct net_device *dev = 0;
 	struct dev_data *priv = 0;
 
-	len += sprintf(page + len, "uboot_pkts = %ld\n", stats_uboot_pkts);
-
 	for (i = 0; i < MAX_GMAC_PORT; i++) {
 
 		dev = dev_mac[i];
@@ -2203,11 +1853,6 @@ static int xlp_mac_proc_read(char *page, char **start, off_t off,
 
 		len += sprintf(page + len, "=============== port@%d ==================\n", i);
 
-		len += sprintf(page + len, "per port@%d: frin_to_be_sent = %ld num_replenishes = %ld frin_sent = %ld\n",
-			       i, atomic64_read(&priv->frin_to_be_sent),
-			       atomic64_read(&priv->num_replenishes),
-			       atomic64_read(&priv->total_frin_sent));
-
 		len += sprintf(page + len,
 			       "per port@%d: %lu(rxp) %lu(rxb) %lu(txp) %lu(txb)\n",
 			       i,
@@ -2331,6 +1976,10 @@ static int __init nlm_xlp_mac_init(void)
 
 	nlm_xlp_nae_init();
 
+#ifdef NAPI_MODEL
+	nlm_xlp_napi_setup();
+#endif
+
 	return pci_register_driver(&soc_driver);
 }
 
-- 
1.9.1

