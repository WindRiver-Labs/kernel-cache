From ffc17f6f2fab567a08df78e9cc961c23aebe03e2 Mon Sep 17 00:00:00 2001
From: Quanyang Wang <quanyang.wang@windriver.com>
Date: Wed, 22 Apr 2015 10:36:02 +0800
Subject: [PATCH] bcm-xlp: add ipi interrupt to support for flush icache

The function smp_call_function_many() can't be called with irqs_disabled.
But ftrace_init() disables interrupts before calling it, so add ipi
interrupt to support for flush icache and use for_each_cpu() to replace
on_each_cpu(), else we got the below call trace.

  0:<4>------------[ cut here ]------------
  0:<4>WARNING: at ...kernel/smp.c:464 smp_call_function_many+0x13c/0x3f8()
  0:<d>Modules linked in:  0:
  0:Call Trace:
  0:[<ffffffffc17b3538>] dump_stack+0x1c/0x50
  0:[<ffffffffc10f086c>] warn_slowpath_common+0x8c/0xc0
  0:[<ffffffffc10f08cc>] warn_slowpath_null+0x2c/0x40
  0:[<ffffffffc114da4c>] smp_call_function_many+0x13c/0x3f8
  0:[<ffffffffc114dd70>] on_each_cpu_mask+0x68/0x108
  0:[<ffffffffc10dccfc>] nlm_common_flush_icache_range+0x10c/0x120
  0:[<ffffffffc10cb700>] ftrace_modify_code+0x30/0x48
  0:[<ffffffffc1c58430>] ftrace_dyn_arch_init+0x8c/0xb0
  0:[<ffffffffc1c5dfc8>] ftrace_init+0x38/0x1ac
  0:[<ffffffffc1c50a58>] start_kernel+0x408/0x43c

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/include/asm/netlogic/common.h    |    2 ++
 arch/mips/include/asm/netlogic/interrupt.h |    1 +
 arch/mips/mm/c-netlogic.c                  |   15 ++++++++++++++-
 arch/mips/netlogic/common/irq.c            |    3 +++
 arch/mips/netlogic/common/smp.c            |   15 +++++++++++++++
 5 files changed, 35 insertions(+), 1 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/common.h b/arch/mips/include/asm/netlogic/common.h
index 772d43d..a0e1958 100644
--- a/arch/mips/include/asm/netlogic/common.h
+++ b/arch/mips/include/asm/netlogic/common.h
@@ -70,6 +70,8 @@
 struct irq_desc;
 void nlm_smp_function_ipi_handler(unsigned int irq, struct irq_desc *desc);
 void nlm_smp_resched_ipi_handler(unsigned int irq, struct irq_desc *desc);
+void nlm_smp_flush_icache_handler(unsigned int irq, struct irq_desc *desc);
+void nlm_send_ipi_single(int logical_cpu, unsigned int action);
 void nlm_smp_irq_init(int hwcpuid);
 void nlm_boot_secondary_cpus(void);
 int nlm_wakeup_secondary_cpus(void);
diff --git a/arch/mips/include/asm/netlogic/interrupt.h b/arch/mips/include/asm/netlogic/interrupt.h
index 7df21bf..5a8e1eb 100644
--- a/arch/mips/include/asm/netlogic/interrupt.h
+++ b/arch/mips/include/asm/netlogic/interrupt.h
@@ -37,6 +37,7 @@
 
 /* Defines for the IRQ numbers */
 
+#define IRQ_IPI_SMP_FLUSH_ICACHE	2
 #define IRQ_IPI_SMP_FUNCTION	3
 #define IRQ_IPI_SMP_RESCHEDULE	4
 #define IRQ_FMN			5
diff --git a/arch/mips/mm/c-netlogic.c b/arch/mips/mm/c-netlogic.c
index ab3f34f..73355a5 100644
--- a/arch/mips/mm/c-netlogic.c
+++ b/arch/mips/mm/c-netlogic.c
@@ -27,6 +27,7 @@
 #include <asm/uaccess.h>
 #include <asm/r4kcache.h>
 #include <asm/traps.h>
+#include <asm/netlogic/common.h>
 
 #include <linux/bug.h>
 #include <linux/smp.h>
@@ -347,10 +348,22 @@ static void nlm_flush_icache_range_ipi(void *info)
 void nlm_flush_icache_range(unsigned long start, unsigned long end)
 {
 	struct flush_icache_range_args args;
+	int cpu;
+	cpumask_t mask;
 
 	args.start = start;
 	args.end = end;
-	on_each_cpu(nlm_flush_icache_range_ipi, &args, 1);
+
+	nlm_flush_icache_range_ipi(&args);
+	preempt_disable();
+
+	cpu = smp_processor_id();
+	mask = *cpu_online_mask;
+	cpumask_clear_cpu(cpu, &mask);
+	for_each_cpu(cpu, &mask)
+		nlm_send_ipi_single(cpu, SMP_ICACHE_FLUSH);
+
+	preempt_enable();
 }
 
 static void nlm_flush_cache_sigtramp_ipi(void *info)
diff --git a/arch/mips/netlogic/common/irq.c b/arch/mips/netlogic/common/irq.c
index 2e5099e..b9595e8 100644
--- a/arch/mips/netlogic/common/irq.c
+++ b/arch/mips/netlogic/common/irq.c
@@ -70,6 +70,7 @@
 #ifdef CONFIG_SMP
 #define SMP_IRQ_MASK	((1ULL << IRQ_IPI_SMP_FUNCTION) | \
 				 (1ULL << IRQ_IPI_SMP_RESCHEDULE) | \
+				 (1ULL << IRQ_IPI_SMP_FLUSH_ICACHE) | \
                                   (1ULL << IRQ_IPI_SMP_KGDB))
 #else
 #define SMP_IRQ_MASK	0
@@ -197,6 +198,8 @@ static void __init nlm_init_percpu_irqs(void)
 			 nlm_smp_resched_ipi_handler);
 	irq_set_chip_and_handler(IRQ_IPI_SMP_KGDB, &nlm_cpu_intr,
 			 nlm_smp_function_ipi_handler);
+	irq_set_chip_and_handler(IRQ_IPI_SMP_FLUSH_ICACHE, &nlm_cpu_intr,
+			 nlm_smp_flush_icache_handler);
 #endif
 }
 
diff --git a/arch/mips/netlogic/common/smp.c b/arch/mips/netlogic/common/smp.c
index dae1be0..40a8229 100644
--- a/arch/mips/netlogic/common/smp.c
+++ b/arch/mips/netlogic/common/smp.c
@@ -45,6 +45,9 @@
 #include <asm/netlogic/mips-extns.h>
 #include <asm/netlogic/haldefs.h>
 #include <asm/netlogic/common.h>
+#include <asm/cacheops.h>
+#include <asm/r4kcache.h>
+#include <asm/hazards.h>
 
 #if defined(CONFIG_CPU_XLP)
 #include <asm/netlogic/xlp-hal/iomap.h>
@@ -107,6 +110,8 @@ void nlm_send_ipi_single(int logical_cpu, unsigned int action)
 		nlm_pic_send_ipi(picbase, cpu, IRQ_IPI_SMP_RESCHEDULE, 0);
 	if (action & SMP_CALL_KGDB_HOOK)
 		nlm_pic_send_ipi(picbase, cpu, IRQ_IPI_SMP_KGDB, 1);
+	if (action & SMP_ICACHE_FLUSH)
+		nlm_pic_send_ipi(picbase, cpu, IRQ_IPI_SMP_FLUSH_ICACHE, 0);
 }
 
 void nlm_send_ipi_mask(const struct cpumask *mask, unsigned int action)
@@ -136,6 +141,16 @@ void nlm_smp_resched_ipi_handler(unsigned int irq, struct irq_desc *desc)
 	set_c0_eimr(irq);
 }
 
+/* IRQ_IPI_SMP_RESCHEDULE  handler */
+void nlm_smp_flush_icache_handler(unsigned int irq, struct irq_desc *desc)
+{
+	clear_c0_eimr(irq);
+	ack_c0_eirr(irq);
+	blast_icache32();
+	instruction_hazard();
+	set_c0_eimr(irq);
+}
+
 /*
  * Called before going into mips code, early cpu init
  */
-- 
1.7.5.4

