From c910c499e1b93ee0d63ad6491203cef3f1db5b18 Mon Sep 17 00:00:00 2001
From: Subhendu Sekhar Behera <sbehera@broadcom.com>
Date: Fri, 28 Mar 2014 16:38:28 +0530
Subject: [PATCH 1440/1532] nae: Fix hotplug-in & out of ethernet cable

Issue is due to use of sleep inside timer handler. Move the
phy state checking into a kthread which goes to sleep after each
check. Just wake up the thread in the timer handler.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/xlpge_nae.c | 39 +++++++++++++++++++--------
 1 file changed, 28 insertions(+), 11 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_nae.c b/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
index 8c9fd55..f284aca 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
@@ -36,6 +36,7 @@
 #include <linux/timecompare.h>
 #include <linux/proc_fs.h>
 #include <linux/timer.h>
+#include <linux/kthread.h>
 //#include <nlm_xlp.h>
 //#include <nlm_msgring.h>
 //#include <nlm_hal_fmn.h>
@@ -99,6 +100,7 @@ module_param(enable_jumbo, int, 0);
 struct p2p_desc_mem p2p_desc_mem[NR_CPUS] __cacheline_aligned;
 static unsigned int phys_cpu_map[NLM_MAX_NODES];
 struct timer_list phy_int_timer;
+struct task_struct *kthread_an;
 #ifdef CONFIG_NLM_ENABLE_LOAD_BALANCING
 struct file_operations nlm_load_balance_proc_fops = {
 	.owner = THIS_MODULE,
@@ -799,36 +801,51 @@ void nlm_xlp_nae_remove(void)
 	nlm_nae_remove_procentries();
 }
 
-static void phy_st_timer_handler(unsigned long data)
+static int nlm_xlp_port_poll(void *buff)
 {
-        struct timer_list *timer = &phy_int_timer;
 	uint32_t i,num_ports,maxnae,node,speed,duplex,port_index;
 	nae_t *nae_cfg;
 	static int arr[NLM_MAX_NODES][18];
 	maxnae = get_num_nae_pernode();
-        for (node = 0; node < NLM_MAX_NODES; node++) {
-                int num_nae, tmp;
-                for(num_nae=0; num_nae<maxnae; num_nae++){
-                        nae_cfg = get_nae(node, num_nae);
-                        if (nae_cfg == NULL)
-                                continue;
-				for(i=0;i<nae_cfg->num_ports;i++){
+	while(1) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		for (node = 0;node < NLM_MAX_NODES; node++) {
+			int num_nae, tmp;
+			for(num_nae=0; num_nae<maxnae; num_nae++) {
+				nae_cfg = get_nae(node, num_nae);
+				if (nae_cfg == NULL)
+					continue;
+				for(i=0; i < nae_cfg->num_ports; i++) {
 					port_index = i + (nae_cfg->nae_id * nae_cfg->num_ports);
 					tmp=arr[node][port_index];
 					arr[node][port_index]=netsoc_get_phy_status(&nae_cfg->ports[i],&speed,&duplex);
-					if((arr[node][port_index]>-1)&&(arr[node][port_index]<tmp))
+					if ((arr[node][port_index]>-1)&&(arr[node][port_index]<tmp))
 						netsoc_start_autoneg(&nae_cfg->ports[i]);
 					else
 						continue;
-					}
+				}
+			}
 		}
+		schedule();
 	}
+	return 0;
+}
+
+static void phy_st_timer_handler(unsigned long data)
+{
+        struct timer_list *timer = &phy_int_timer;
+	wake_up_process(kthread_an);
         timer->expires = jiffies + (HZ * 2);
         add_timer(timer);
 }
 void init_phy_state_timer(void *data)
 {
         struct timer_list *timer = &phy_int_timer;
+	kthread_an = kthread_create(nlm_xlp_port_poll, NULL, "nae_port_poll");
+	if (IS_ERR(kthread_an)) {
+		nae_print(NAE_DBG_ERROR, "Can't create nae port probe thread !!!\n");
+		nae_print(NAE_DBG_ERROR, "Skipping phy state timer initialization !!!\n");
+	}
         init_timer(timer);
         timer->expires = jiffies + 10;
         timer->data = 0;
-- 
1.9.1

