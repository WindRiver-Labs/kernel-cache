From 9399b22667f9761496d8d2d7d4ee2d3355f0643c Mon Sep 17 00:00:00 2001
From: Alok Agrawat <aagrawat@netlogicmicro.com>
Date: Fri, 23 Sep 2011 20:01:54 +0530
Subject: [PATCH 1073/1532] added compression/decompression driver

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/nlm_cde/cdetest.c     | 235 ++++++++
 drivers/misc/netlogic/nlm_cde/nlm_cde.c     | 829 ++++++++++++++++++++++++++++
 drivers/misc/netlogic/nlm_cde/nlm_cde.h     |  80 +++
 drivers/misc/netlogic/nlm_cde/nlm_cde_api.h |  62 +++
 4 files changed, 1206 insertions(+)
 create mode 100644 drivers/misc/netlogic/nlm_cde/cdetest.c
 create mode 100644 drivers/misc/netlogic/nlm_cde/nlm_cde.c
 create mode 100644 drivers/misc/netlogic/nlm_cde/nlm_cde.h
 create mode 100644 drivers/misc/netlogic/nlm_cde/nlm_cde_api.h

diff --git a/drivers/misc/netlogic/nlm_cde/cdetest.c b/drivers/misc/netlogic/nlm_cde/cdetest.c
new file mode 100644
index 0000000..064fd13
--- /dev/null
+++ b/drivers/misc/netlogic/nlm_cde/cdetest.c
@@ -0,0 +1,235 @@
+/***********************************************************************
+Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#RMI_2#**********************************/
+/* Reference application for compression driver
+ * usage: mips64-nlm-linux-gcc  -g cdetest.c -o cdetest
+ *>../cdetest <inputfile>
+ */
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+
+static int sleep_usec = 100;
+static int LEN = 1024 * 16;
+static int dfd;
+struct nlm_cde_op
+{
+        unsigned int compression_type;
+        unsigned int sof;
+        unsigned int eof;
+};
+
+struct nlm_cde_op cde;
+
+void test()
+{
+        int i, ret, cd_fd;
+        unsigned char *buf;
+
+        for(i = 0; i < 10; i++)
+        {
+                ret = ioctl(dfd, i, (unsigned long)buf);
+	   	printf("ioctl %d bytes of data to devicee\n", ret);
+	        ret = read(dfd, buf, 10);
+	   	printf("read %d bytes of data to devicee\n", ret);
+	        ret = write(dfd, buf, 10);
+	   	printf("write %d bytes of data to devicee\n", ret);
+        }
+
+}
+
+static int cde_op(int op, char *buf, int len)
+{
+        int ret;
+       
+        ret = ioctl(dfd, op, (unsigned long)&cde);
+
+	if (ret < 0) {
+		perror("can't ioctl");
+		return -1;
+	}
+
+	ret = write(dfd, buf, len);
+	if (ret < 0) {
+		perror("can't write to device");
+		return -1;
+	}
+	else {
+	   	printf("write %d bytes of data to devicee\n", ret);
+	}
+
+	return ret;
+}
+
+static int cde_result(char *buf, int len)
+{
+	int ret = 0;
+
+        while(ret == 0)
+        {
+                ret = read(dfd, buf, len);
+                if (ret < 0) {
+                        perror("can't read device");
+                        return -1;
+                }
+        }
+	printf("read %d bytes of data from devicee\n", ret);
+
+	return ret;
+}
+
+int main(int argc, char *argv[])
+{
+        char buf[LEN];
+	char buf1[LEN];
+        char buf2[LEN];
+
+	int tfd = open(argv[1], O_RDONLY);
+        int vfd = open("out.txt",O_WRONLY);
+        if (tfd < 0 || vfd < 0) {
+		perror("can't open test file");
+		return -1;
+	}
+
+        int data_len = read(tfd, buf, LEN);
+        if (data_len < 0) {
+		perror("can't read test file");
+		return -1;
+	}
+	else {
+	   	printf("read %d bytes of data from test file\n", data_len);
+	}	
+
+	char *dev_name = "/dev/nlm_cde";
+	dfd = open(dev_name, O_RDWR);
+
+        if (dfd < 0) {
+		perror("can't open device");
+		return -1;
+	}
+//        test();
+  //      return 0;
+
+        cde.compression_type = 1;
+        cde.sof = 1;
+        cde.eof = 1;
+
+	int ret = 0;
+        /*block_test();*/
+        if(0)
+        {
+        int i, num_blk = 2, data_len_ext, j = 0, def_len = 0;
+        data_len_ext = data_len /num_blk;
+        for(i = 0; i < num_blk; i++)
+        {
+                if (i ==0)
+                        cde.eof = 0;
+                if(i == (num_blk -1))
+                {
+                        cde.eof = 1;
+		        ret = cde_op(2, &buf[j], (data_len - (data_len_ext * i)));//deflate
+                }
+                else
+		        ret = cde_op(2, &buf[j], data_len_ext);//deflate
+	 	ret = cde_result(&buf1[def_len], LEN);
+                j += data_len_ext;
+                cde.sof = 0;
+                def_len += ret;
+        }
+        data_len = def_len;
+        data_len_ext = data_len /num_blk;
+        cde.sof = 1;
+        j = 0;
+        def_len = 0;
+        for(i = 0; i < num_blk; i++)
+        {
+                if (i ==0)
+                        cde.eof = 0;
+                if(i == (num_blk -1))
+                {
+                        cde.eof = 1;
+		        ret = cde_op(1, &buf1[j], (data_len - (data_len_ext * i)));//deflate
+                }
+                else
+		        ret = cde_op(1, &buf1[j], data_len_ext); //inflate
+	        if (ret < 0) break;
+
+	 	ret = cde_result(&buf2[def_len], LEN);
+	        if (ret < 0) break;
+                write(vfd, &buf2[def_len], ret);
+                j += data_len_ext;
+                cde.sof = 0;
+                def_len += ret;
+        }
+        return 0;
+        }
+        
+	do 
+        {
+		ret = cde_op(2, buf, data_len);//deflate
+	        //if (ret < 0) break;
+
+	        usleep(sleep_usec);
+
+	        char buf1[LEN];
+	 	ret = cde_result(buf1, LEN);
+	  //      if (ret < 0) break;
+
+	        usleep(sleep_usec);
+//                printf("read buf = %s ret = %d\n",buf1, ret );
+
+		ret = cde_op(1, buf1, ret); //inflate
+	        if (ret < 0) break;
+	
+	        usleep(sleep_usec);
+
+	 	ret = cde_result(buf2, LEN);
+	        if (ret < 0) break;
+                write(vfd, buf2, ret);
+	} 
+        while (0);
+
+	close(dfd);	
+
+	if (ret <= 0) {
+	         printf("test aborted !\n");
+	         return -1;
+        }
+	
+        if (ret != data_len) {
+	         printf("test failed: size mismatch !\n");
+	         return -1;
+        }
+
+        ret = memcmp(buf, buf2, data_len);
+        if (ret != 0) {
+	         printf("test failed: data mismatch !\n");
+	         return -1;
+        }
+
+	printf("test passed !\n");	       
+        return 0;
+}
+
+
diff --git a/drivers/misc/netlogic/nlm_cde/nlm_cde.c b/drivers/misc/netlogic/nlm_cde/nlm_cde.c
new file mode 100644
index 0000000..171532c
--- /dev/null
+++ b/drivers/misc/netlogic/nlm_cde/nlm_cde.c
@@ -0,0 +1,829 @@
+/*************************************************************************
+  Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+  reserved.
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are
+  met:
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+  THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NLMOGIC OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+ *******************************#NLM_2#**********************************/
+
+#include <linux/module.h>
+
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/errno.h>	/* for -EBUSY */
+#include <linux/ioport.h>	/* for request_region */
+#include <linux/delay.h>	/* for loops_per_jiffy */
+#include <linux/sched.h>
+#include <linux/smp_lock.h>	/* cycle_kernel_lock() */
+#include <asm/io.h>		/* for inb_p, outb_p, inb, outb, etc. */
+#include <asm/uaccess.h>	/* for get_user, etc. */
+#include <linux/init.h>		/* for __init, module_{init,exit} */
+#include <linux/poll.h>		/* for POLLIN, etc. */
+#include <asm/netlogic/msgring.h>
+#include <asm/mutex.h>
+
+#include <asm/netlogic/hal/nlm_hal_fmn.h>
+#include <asm/netlogic/hal/nlm_hal_macros.h>
+#include <asm/netlogic/hal/nlm_hal_cde.h>
+#include "nlm_cde.h"
+#include "nlm_cde_api.h"
+
+#define printf(a, b...) printk(KERN_ERR a, ##b)
+#define malloc(a) kmalloc(a, GFP_ATOMIC)
+#define free kfree
+
+#define L3_CACHELINE_SIZE 64
+#define L3_CACHELINE_MASK 0x3fULL
+#define VC_MODE_ROUND_ROBIN 1
+
+static int xlp_cde_major;
+int xlp_cde_open(struct inode *, struct file *);
+int xlp_cde_release(struct inode *, struct file *);
+int xlp_cde_ioctl(struct inode *inode, struct file *fptr, unsigned int type, unsigned long val);
+ssize_t xlp_cde_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);
+ssize_t xlp_cde_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);
+
+typedef struct free_page_structure {
+	  char *data_array;
+} fr_page;
+
+volatile msg cmp_msg[MAX_NUM_MESSAGES]    __attribute__((aligned(32)));
+volatile fr_page page_array[MAX_NUM_PAGES]    __attribute__((aligned(32)));
+volatile char *(page_array_tmp_data_array[MAX_NUM_PAGES])__attribute__((aligned(32)));
+
+//#define CDE_DEBUG 0
+#ifdef CDE_DEBUG
+static void dump_buffer(unsigned char *buf, unsigned int len, unsigned char *msg)
+{
+    int k = 0;
+    printk("\n %s", msg);
+    for(k = 0; k < len; k++)
+    {
+	printk(" %.2x",buf[k]);
+	if((k+1) % 16 == 0)
+	    printk("\n");
+    }
+    printk("\n");
+}
+#endif
+
+static void *
+get_cache_aligned_mem(size_t size)
+{
+    void *addr, **tmp;
+    unsigned long loc;
+    addr = malloc(size + L3_CACHELINE_SIZE * 2);
+
+    if (addr == NULL) {
+	printk(KERN_ERR
+		"\n Malloc failed for cache aligned memory allocation");
+	return NULL;    //NLM_ERR_NO_MEM;
+    }
+    loc = (unsigned long) addr;
+    loc = (loc + L3_CACHELINE_SIZE - 1) & ~L3_CACHELINE_MASK;
+
+    tmp = (void **) loc;
+
+    *tmp = addr;
+
+    loc += L3_CACHELINE_SIZE;
+
+    addr = (void *) loc;
+
+    return addr;
+}
+
+static void
+free_cache_aligned_mem(void *addr)
+{
+    unsigned long loc;
+
+    loc = (unsigned long) addr;
+
+    loc -= 64;
+
+    addr = (void *) loc;
+
+    addr = (void *) *(unsigned long *) addr;
+
+    free(addr);
+}
+
+static int
+cde_get_fb_vc(void)
+{
+    int vc, cpu;
+
+    vc = RTN_BKT;
+    cpu = hard_smp_processor_id();
+    cpu = cpu * 4 + vc;
+    return cpu;
+}
+
+static const struct file_operations xlp_cde_fops = {
+    .owner = THIS_MODULE,
+    .open = xlp_cde_open,
+    .read = xlp_cde_read,
+    .write = xlp_cde_write,
+    .ioctl = xlp_cde_ioctl,
+    .release = xlp_cde_release,
+};
+
+
+static int config_cmp(void)
+{
+  int i;
+   
+#ifdef CDE_DEBUG
+	printk("config_cmp \n");
+#endif
+  for(i = 0; i < NUM_CDE_ENGINE; i++)
+  {
+    unsigned int val = nlm_hal_read_cde_reg(CMP_REG_CTRL_REG(i));
+#ifdef CDE_DEBUG
+	printk("config_cmp i = %d cntrl_reg val = %x\n", i, val);
+#endif
+    val = nlm_hal_read_cde_reg(CMP_REG_SCRATCH_PAGE(i));
+#ifdef CDE_DEBUG
+	printk("config_cmp i = %d scratch_reg val = %x\n", i, val);
+#endif
+    nlm_hal_write_cde_reg(CMP_REG_CTRL_REG(i), ((0x0012 << 16) | CMP_PAGE_SIZE)); //16'h{CMP_PAGE_SIZE}
+    nlm_hal_write_cde_reg(CMP_REG_SCRATCH_PAGE(i), 0x801000); //16'h{CMP_PAGE_SIZE}
+  }
+  return 0;
+}
+
+static int send_message(int stid, struct msgrng_msg *msg)
+{
+  int ret = 0;
+
+#ifdef CDE_DEBUG
+	printk("send_message = stid = %x msg = %llx\n",stid, msg->msg0);
+#endif
+  nlm_hal_cde_send_request(stid, msg->msg0);
+#if 0
+  msgrng_flags_save(mflags);
+  ret = message_send_retry(1, 0, stid, msg);
+  msgrng_flags_restore(mflags);
+#endif
+  return ret;
+}
+
+
+static int send_free_desc(void)
+{
+  int i;
+  int status = 0;
+  int stid;
+  struct msgrng_msg fd_msg;
+
+  // send free descriptors to cmp block
+  for (i = 0; i < NUM_FREE_DESCRIPTORS; i++) {
+    if (!page_array[i].data_array)	  
+	page_array[i].data_array = get_cache_aligned_mem(CMP_PAGE_SIZE);
+    if (!page_array[i].data_array)	{
+	    printk("cacheline_aligned_kmalloc returmed error\n");
+	    return -1;
+    }
+
+    stid = nlm_hal_cde_make_fd_msg((uint64_t*)&fd_msg.msg0, (unsigned long)virt_to_phys(page_array[i].data_array));
+#ifdef CDE_DEBUG
+    	printk("Free descriptor message [%0d] = 0x%016llx\n", i, fd_msg.msg0);
+#endif
+
+    status = send_message(MSGRNG_STNID_CMP1, &fd_msg);
+
+    if (status != 0) {
+      printk("[%s@%d]: Free descriptor (%d) didnt not reach cmpm status=%0d\n",
+	     __FUNCTION__, __LINE__, i, status);
+      return -1;
+    }
+  }
+
+#ifdef CDE_DEBUG
+    printk("[%s@%d]: Sent %d free desc to comp engine\n",
+	   __FUNCTION__, __LINE__, i);
+#endif
+
+  return 0;
+}
+
+
+int create_inf_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of_file)
+{
+  int num_messages, num_desc, num_blk;
+  int i,j,k,stid;
+
+  int rtn_bkt;
+
+  int cur_blk = 0;
+  int cur_desc = 0;
+
+  int eof  = 0;
+  int sod  = 0;
+  int sob  = 0;
+  int eob  = 0;
+  int save = 0;
+  int restore = 0;
+
+  int desc_idx = 0;
+  int length = 0;
+  int start = 0;
+  int div;
+
+ /* Number of block and number of messages are always 1. 
+    User is expected to send one block at a time */
+  num_blk = num_desc = num_messages = 1;
+  div = num_blk * num_desc;
+
+  rtn_bkt = cde_get_fb_vc();
+  type = 3;
+  if(cmp_data->src_size > MAX_BUFFER_SIZE)
+  {
+	  printk("ERROR:src_size if more than %d. No space to store\n", MAX_BUFFER_SIZE);
+	  return 0;
+  }
+  num_desc = (cmp_data->src_size/PAGE_SIZE) + ((cmp_data->src_size %PAGE_SIZE)?1:0);
+
+  for (i = 0; i < num_messages; i++) {
+    //create scratch page descriptor
+    cur_desc = 0;
+    restore = (start_of_file == 0);//((num_messages > 1) & (cur_blk != 0));
+    length = SCRATCH_SIZE;
+
+    cmp_data->src_desc[desc_idx] =
+      nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (unsigned long)virt_to_phys(cmp_data->scratch));
+
+#ifdef CDE_DEBUG
+      printk("scratch=0x%p, v2p=0x%lx, scratch_desc = 0x%016llx &scratch_desc=0x%p\n", 
+	     cmp_data->scratch, virt_to_phys(cmp_data->scratch), cmp_data->src_desc[desc_idx], &(cmp_data->src_desc[0])); 
+#endif
+    cur_desc++;
+
+    for (j = 0; j < num_blk/num_messages; j++) {
+      for (k = 0; k < num_desc; k++) {
+	eof = 1;//end_of_file;
+
+	sod = 1;//(start == 0);
+	sob = (k == 0);
+	eob = (k == num_desc-1);
+	save = ((eob == 1) & (end_of_file == 0)); //((eof == 0) & (eob == 1));
+	restore = 0; //restore only can be 1 on scratch descriptor
+
+	length = ((cmp_data->src_size - start)> PAGE_SIZE)?PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
+
+	cmp_data->src_desc[cur_desc] =
+	  nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (unsigned long)virt_to_phys(cmp_data->src + start));
+
+#ifdef CDE_DEBUG
+	  printk("[%s@%d]: eof=%d, sod=%d, sob=%d, eob=%d, save=%d, restore=0, length=%d\n",
+		 __FUNCTION__, __LINE__, eof, sod, sob, eob, save, length);
+	  
+	  printk("[%s@%d]: cur_desc=%d, i=%d, j=%d, k=%d, &(cmp_data->src)=0x%p, src_desc[1]=0x%llx &(src_desc[1])=0x%p\n",
+		 __FUNCTION__, __LINE__,
+		 cur_desc, i, j, k, cmp_data->src, cmp_data->src_desc[cur_desc], &(cmp_data->src_desc[cur_desc]));
+#endif
+
+	start = start + length;
+	cur_desc++;
+      }
+
+      cur_blk++;
+    }
+
+    stid = nlm_hal_cde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0, 0, cmp_data->op, rtn_bkt,
+			cur_desc, (unsigned long)virt_to_phys(cmp_data->src_desc + desc_idx));
+#ifdef CDE_DEBUG
+      printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx\n", __FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0); 
+#endif
+
+    desc_idx = desc_idx + cur_desc;
+  }
+
+  // returns the number of messages created
+  return (num_messages);
+}
+
+int create_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of_file)
+{
+  int num_messages, num_desc, num_blk;
+  int i,j,k,stid;
+
+  int rtn_bkt;
+
+  int cur_blk = 0;
+  int cur_desc = 0;
+
+  int eof  = 0;
+  int sod  = 0;
+  int sob  = 0;
+  int eob  = 0;
+  int save = 0;
+  int restore = 0;
+
+  int desc_idx = 0;
+  int length = 0;
+  int start = 0;
+  int div;
+
+  num_blk = num_desc = num_messages = 1;
+  div = num_blk * num_desc;
+
+  rtn_bkt = cde_get_fb_vc();
+
+  if(cmp_data->src_size > MAX_BUFFER_SIZE)
+  {
+	  printk("ERROR:src_size if more than %d. No space to store\n", MAX_BUFFER_SIZE);
+	  return 0;
+  }
+  num_desc = (cmp_data->src_size/PAGE_SIZE) + ((cmp_data->src_size %PAGE_SIZE)?1:0);
+
+  for (i = 0; i < num_messages; i++) {
+    //create scratch page descriptor
+    cur_desc = 0;
+    restore = (start_of_file == 0);//((num_messages > 1) & (cur_blk != 0));
+    length = SCRATCH_SIZE;
+
+    cmp_data->src_desc[desc_idx] =
+      nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (unsigned long)virt_to_phys(cmp_data->scratch));
+
+#ifdef CDE_DEBUG
+      printk("scratch=0x%p, v2p=0x%lx, scratch_desc = 0x%016llx &scratch_desc=0x%p\n", 
+	     cmp_data->scratch, virt_to_phys(cmp_data->scratch), cmp_data->src_desc[desc_idx], &(cmp_data->src_desc[0])); 
+#endif
+
+    cur_desc++;
+
+    for (j = 0; j < num_blk/num_messages; j++) {
+      for (k = 0; k < num_desc; k++) {
+	eof = end_of_file;
+
+	sod = (start == 0);
+	sob = (k == 0);
+	eob = (k == num_desc-1);
+	save = ((type == CDE_STATIC) & (eof == 0) & (eob == 1));
+	restore = 0; //restore only can be 1 on scratch descriptor
+
+	//	length = (cmp_data->src_size - start) / div;
+	length = ((cmp_data->src_size - start)> PAGE_SIZE)?PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
+
+	cmp_data->src_desc[cur_desc] =
+	  nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (unsigned long)virt_to_phys(cmp_data->src + start));
+
+	if (type == CDE_DYNAMIC) {//for dynamic duplicate desc and set type to 3
+		save = ( (eob == 1) & (eof == 0)) ;
+		cmp_data->src_desc[cur_desc+num_desc] = nlm_hal_cde_make_data_desc ( eof, 3, 1/*sod*/, sob, save, 0, eob, length, (unsigned long)virt_to_phys(cmp_data->src + start));
+#ifdef CDE_DEBUG
+	  printf("cur_desc = %0d, i = %0d, j = %0d, k = %0d, src_desc[%0d] = 0x%016llx \n", 
+		cur_desc, i, j, k, cur_desc+num_desc, (long long unsigned int)cmp_data->src_desc[cur_desc+num_desc]);
+#endif
+	}
+
+#ifdef CDE_DEBUG
+	  printk("[%s@%d]: eof=%d, sod=%d, sob=%d, eob=%d, save=%d, restore=0, length=%d\n",
+		 __FUNCTION__, __LINE__, eof, sod, sob, eob, save, length);
+	  
+	  printk("[%s@%d]: cur_desc=%d, i=%d, j=%d, k=%d, &(cmp_data->src)=0x%p, src_desc[1]=0x%llx &(src_desc[1])=0x%p\n",
+		 __FUNCTION__, __LINE__,
+		 cur_desc, i, j, k, cmp_data->src, cmp_data->src_desc[cur_desc], &(cmp_data->src_desc[cur_desc]));
+#endif
+	start = start + length;
+	cur_desc++;
+      }
+
+      if (type == CDE_DYNAMIC) {//dynamic has 2x descriptors
+	cur_desc = cur_desc + num_desc;
+      }
+
+      cur_blk++;
+    }
+
+    stid = nlm_hal_cde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0, 0, cmp_data->op, rtn_bkt,
+			cur_desc, (unsigned long)virt_to_phys(cmp_data->src_desc + desc_idx));
+#ifdef CDE_DEBUG
+    printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx\n",
+	 __FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0); 
+#endif
+
+    desc_idx = desc_idx + cur_desc;
+  }
+
+  // returns the number of messages created
+  return (num_messages);
+}
+
+
+void return_free_descriptors(msg *msg_list, int msg_index)
+{
+  int i, j, k, status, num_desc;
+  msg return_msg, fd_msg;
+  uint64_t * temp_desc;
+  uint64_t dest_desc;
+  int used_fd_index = 0;
+
+  volatile uint64_t used_fd[NUM_FREE_DESCRIPTORS] __attribute__((aligned(32)));
+
+  for (i = 0; i < msg_index; i++) {
+
+    memcpy ((void *) &return_msg, (void *)(msg_list+i), sizeof(msg));
+    used_fd[used_fd_index++] = ((uint64_t) return_msg.msg1 & 0xffffffffffUll);
+
+    num_desc = (return_msg.msg1>>40 & 0xffff);
+
+    temp_desc = (uint64_t *) phys_to_virt(return_msg.msg1 & 0xffffffffffUll);
+
+    for (j = 0; j< num_desc; j++) {
+      dest_desc = temp_desc[j];
+      used_fd[used_fd_index++] = ((uint64_t) dest_desc & 0xffffffffffUll);
+    }
+
+
+    if (used_fd_index > FD_BURST_SIZE) {
+      for (k = 0; k < used_fd_index; k++) {
+	fd_msg.msg0 = ((uint64_t) used_fd[k]);
+	status = send_message(MSGRNG_STNID_CMP1, &fd_msg);
+	if (status != 0)
+	  printk("Return free descriptor didnt not reach cmp! status=%0d\n", status);
+	}
+        used_fd_index = 0;
+    }
+  }
+}
+
+static cmp_data_t *cmp_data = 0;
+
+static int nlm_hal_cde_read_cmp_msg(char *buffer, uint64_t payload)
+{
+  uint64_t i,j,num_bytes;
+  int offset = 0;
+  uint64_t *desc, dest_addr;
+  int num_desc = (payload >> 40) & 0x3fff;
+  char * tmp_ptr;
+
+
+  for (i = 0; i < num_desc; i++) {
+    desc = phys_to_virt(payload & 0xffffffffffUll) + i*8; //64 byte descriptors //dliao: why i*8??
+
+    num_bytes = (*desc >> 40) & 0xffff;
+    dest_addr = *desc & 0xffffffffffUll;
+    tmp_ptr = (char *) phys_to_virt(dest_addr & 0xffffffffffUll);
+
+    for (j = 0; j < num_bytes; j++) {
+      buffer[offset+j] = tmp_ptr[j];
+    }
+    offset = offset + num_bytes;
+  }
+  return offset;
+}
+
+
+static void
+nlm_xlp_cde_msgring_handler(uint32_t vc, uint32_t src_id,
+        uint32_t size, uint32_t code,
+        uint64_t msg0, uint64_t msg1,
+        uint64_t msg2, uint64_t msg3, void *data)
+{
+  struct msgrng_msg *msg, temp_msg;
+  int last = 0; 
+  int msg_index = 0; 
+  struct msgrng_msg msg_list[MAX_NUM_MESSAGES]; 
+  int offset = cmp_data->target_size;
+
+#ifdef CDE_DEBUG
+  printk("nlm_xlp_cde_msgring_handler = vc = %d, src_id = %d size = %d code = %d msg0 = %llx, msg1 = %llx msg2 = %llx\n", vc, src_id, size, code, msg0, msg1, msg2);
+#endif
+
+  msg = (struct msgrng_msg *)&temp_msg;
+  msg->msg0 = msg0;
+  msg->msg1 = msg1;
+
+  last = ((msg->msg0 >> 63) & 0x1ULL); 
+  
+#ifdef CDE_DEBUG
+  printk("[%s@%d]: last = %d offset = %d target_size = %d\n", __FUNCTION__, __LINE__, last, offset, cmp_data->target_size); 
+#endif
+    
+  offset = cmp_data->target_size; 
+  cmp_data->target_size += nlm_hal_cde_read_cmp_msg((char *) cmp_data->target + offset, msg->msg1);
+
+#ifdef CDE_DEBUG
+  printk("cmp_data->target_size = %d\n",cmp_data->target_size);
+  dump_buffer((char *) (cmp_data->target + offset), cmp_data->target_size, "returned data:");
+#endif
+
+  memcpy((void *)&msg_list[msg_index++],(void *)msg, sizeof(struct msgrng_msg));
+
+  return_free_descriptors(msg_list, msg_index); 
+#ifdef CDE_DEBUG
+  printk("[\n%s@%d]:end of phnx_msgring_comp_int_handler\n", __FUNCTION__, __LINE__);
+#endif
+}
+
+cmp_data_t* nlm_cde_init()
+{
+
+  cmp_data = (cmp_data_t *) kmalloc(sizeof(cmp_data_t), GFP_KERNEL);
+  if (!cmp_data)
+    return NULL;
+  memset(cmp_data, 0, sizeof(cmp_data_t));
+
+  cmp_data->src = kmalloc(MAX_BUFFER_SIZE, GFP_KERNEL);
+  if (! cmp_data->src)	{
+	  printk("kmalloc returns Error : cmp_data->src\n");
+	  kfree(cmp_data);
+	  
+	  return NULL;
+  }
+	  
+  cmp_data->target = kmalloc(MAX_BUFFER_SIZE, GFP_KERNEL);
+  if (! cmp_data->target)	{
+	  printk("kmalloc returns Error : cmp_data->target\n");
+	  kfree(cmp_data->src);
+	  kfree(cmp_data);
+	  return NULL;
+  }
+  cmp_data->src_desc = kmalloc(sizeof(unsigned long long) * CMP_PAGE_SIZE , GFP_KERNEL);
+  if (! cmp_data->src_desc)	{
+	  printk("kmalloc returns Error : cmp_data->src_desc\n");
+	  kfree(cmp_data->src);
+	  kfree(cmp_data->target);
+	  kfree(cmp_data);
+	  return NULL;
+  }
+  cmp_data->scratch = kmalloc(sizeof(unsigned long long) * SCRATCH_SIZE , GFP_KERNEL);
+  if (! cmp_data->scratch)	{
+	  printk("kmalloc returns Error : cmp_data->scratch\n");
+	  kfree(cmp_data->src);
+	  kfree(cmp_data->target);
+	  kfree(cmp_data->src_desc);
+	  kfree(cmp_data);
+	  return NULL;
+  }
+  memset(cmp_data->src, 0, MAX_BUFFER_SIZE);
+  memset(cmp_data->target, 0, MAX_BUFFER_SIZE);
+  memset(cmp_data->src_desc, 0, sizeof(unsigned long long) * CMP_PAGE_SIZE);
+  memset(cmp_data->scratch, 0, sizeof(unsigned long long) * SCRATCH_SIZE);
+
+  if (config_cmp() == -1)
+	return NULL;
+
+  if (send_free_desc() == -1)
+	return NULL;
+
+  return cmp_data;
+}
+
+int xlp_cde_open(struct inode *inode, struct file *filp)
+{
+#ifdef CDE_DEBUG
+	printk("xlp_cde_open \n");
+#endif
+
+  nlm_cde_init();
+  return 0;
+}
+
+
+void nlm_cde_cleanup(cmp_data_t *cmp_data)
+{
+  int i;
+
+  if (cmp_data->src)  
+	  kfree(cmp_data->src);
+  if (cmp_data->target)  
+	  kfree(cmp_data->target);
+  if (cmp_data->src_desc)  
+	  kfree(cmp_data->src_desc);
+  if (cmp_data->scratch)  
+	  kfree(cmp_data->scratch);
+  if (cmp_data)
+    kfree(cmp_data);
+    cmp_data->src = NULL;
+    cmp_data->target = NULL;
+    cmp_data->src_desc = NULL; 
+    cmp_data->scratch = NULL;
+    cmp_data = NULL;
+
+  for (i = 0; i < NUM_FREE_DESCRIPTORS; i++) {
+    if (page_array[i].data_array)	{
+	free_cache_aligned_mem((void*)page_array_tmp_data_array[i]);
+	page_array[i].data_array = NULL;
+    }	
+  }
+}
+
+int xlp_cde_release(struct inode *inode, struct file *filp)
+{ 
+  nlm_cde_cleanup(cmp_data);
+  return 0;
+}
+
+unsigned int nlm_cde_receive_response(cmp_data_t *cmp_data, unsigned char *buf, unsigned int count)
+{
+  int size = 0;
+
+  if(cmp_data->target_size)
+  {
+	size = count < cmp_data->target_size ? count : cmp_data->target_size;
+
+	memcpy(buf, cmp_data->target, size);
+#ifdef CDE_DEBUG
+	printk("xlp_cde_read cmp_data->target_size = %d size = %d\n",cmp_data->target_size, size);
+	dump_buffer(cmp_data->target, size, "Output:");
+	//printk("Read: cmp_data->target = %s size = %d\n", cmp_data->target, size);
+#endif
+	cmp_data->target_size = cmp_data->target_size - size;
+
+	return size;
+  }
+  else
+	return 0;
+}
+
+ssize_t xlp_cde_read(struct file *filp, char __user *buf,
+		 size_t count, loff_t *f_pos)
+{
+	unsigned char temp_buf[count+1];
+	int size;
+	size = nlm_cde_receive_response(cmp_data, (unsigned char*)&temp_buf, count);
+	if (copy_to_user(buf, &temp_buf, size)) {
+                  printk("copy_to_user failed\n");
+                  size = -EFAULT;
+        }
+	return size;
+}
+
+unsigned int nlm_cde_send_request(cmp_data_t *cmp_data, unsigned int op,
+			unsigned int type, 
+			unsigned int sof, 
+			unsigned int eof, 
+			unsigned char *src_buf, 
+			unsigned int size)
+{
+  int i;
+  int num_messages = 0;
+
+  memcpy(cmp_data->src, src_buf, size);
+  cmp_data->src_size = size;
+
+#ifdef CDE_DEBUG
+	printk("xlp_cde_write count = %d\n", size);
+ 	dump_buffer(cmp_data->src, cmp_data->src_size, "\nInput Buf:");
+	printk("write: cmp_data->compression_type = %d cmp_data->sof = %d, cmp_data->eof = %d\n",cmp_data->compression_type, cmp_data->sof, cmp_data->eof);
+#endif
+
+  if(cmp_data->op == 0/*CDE_INFLATE*/)
+    num_messages = create_inf_message(cmp_data, cmp_data->compression_type, cmp_data->sof, cmp_data->eof);
+  else
+    num_messages = create_message(cmp_data, cmp_data->compression_type, cmp_data->sof, cmp_data->eof);
+
+  // send message
+  for (i = 0; i < num_messages; i++) {
+
+    int status = send_message(MSGRNG_STNID_CMP0, (struct msgrng_msg *) (cmp_msg + i));
+#ifdef CDE_DEBUG
+    printk("write: status = %x\n", status);
+#endif
+    if (status != 0) {
+	    printk("Cmp Message didnt not reach cmp, status=%0d\n", status);
+    }
+  }
+
+  return size;
+}
+
+ssize_t xlp_cde_write(struct file *filp, const char __user *buf,
+		size_t count, loff_t *f_pos)
+{
+  unsigned char temp_buf[count+1];
+  if (copy_from_user(&temp_buf, buf, count)) {
+        printk("copy from user failed \n");
+          return -EFAULT;
+  }
+
+  return nlm_cde_send_request(cmp_data, cmp_data->op, cmp_data->compression_type, cmp_data->sof, cmp_data->eof, (unsigned char*)&temp_buf, count);
+}
+
+struct nlm_cde_op
+{
+  unsigned int compression_type;
+  unsigned int sof;
+  unsigned int eof;
+};
+
+int xlp_cde_ioctl(struct inode *inode, struct file *filp,
+	      unsigned int cmd, unsigned long arg)
+{
+  int err = 0;
+  struct nlm_cde_op cde;
+ 
+  if (copy_from_user(&cde, (unsigned char*)arg, sizeof(struct nlm_cde_op))) 
+  {
+        printk("copy from user failed \n");
+          return -EFAULT;
+  }
+
+#ifdef CDE_DEBUG
+  printk("cde.compression_type = %d cde.sof = %d, cde.eof = %d\n",cde.compression_type, cde.sof, cde.eof);
+#endif
+  cmp_data->compression_type = cde.compression_type;
+  cmp_data->sof = cde.sof;
+  cmp_data->eof = cde.eof;
+
+#ifdef CDE_DEBUG
+  printk("xlp_cde_ioctl: cmd = %d\n", cmd);
+#endif
+  switch(cmd) {
+
+  case CDE_INFLATE:
+    cmp_data->op = 0;
+    break;
+
+  case CDE_DEFLATE:
+    cmp_data->op = 1;
+    break;
+
+  default:
+	printk("xlp_cde_ioctl: default\n");
+    return -ENOTTY;
+  }
+
+  return err;
+}
+
+/* ##################################
+   ##################################*/
+
+
+static int __init xlp_cde_init(void)
+{
+    printk(KERN_ERR ",\n XLP CDE Initialization \n");
+
+    xlp_cde_major = register_chrdev(0, "NLM_XLP_CDE", &xlp_cde_fops);
+    if (xlp_cde_major < 0) {
+	printk(KERN_ERR "XLP_CDE - cannot register device\n");
+	return xlp_cde_major;
+    }
+    printk (KERN_ERR ",XLP CDE MAJOR %d\n", xlp_cde_major);
+
+    if (register_xlp_msgring_handler
+	    (XLP_MSG_HANDLE_CMP, nlm_xlp_cde_msgring_handler, NULL)) {
+	panic("can't register msgring handler for XLP_MSG_HANDLE_CMP");
+    }
+    printk("xlp_cde_init done\n\n");
+{
+  int i =0;
+  unsigned int ret;
+  for(i = 0; i < NUM_CDE_ENGINE; i++)
+  {
+    ret = nlm_hal_read_cde_reg(CMP_REG_RESET_REG(i));
+#ifdef CDE_DEBUG
+    printk("reset_reg = ret = %x\n", ret);
+#endif
+    nlm_hal_write_cde_reg(CMP_REG_RESET_REG(i), 0x8);
+    do {
+    ret = nlm_hal_read_cde_reg(CMP_REG_RESET_REG(i));
+#ifdef CDE_DEBUG
+    printk("reset_reg = ret = %x\n", ret);
+#endif
+    if (((ret >> 4) & 0x1) == 1)
+      break;
+    } while (1);
+
+    nlm_hal_write_cde_reg(CMP_REG_RESET_REG(i), 0x01);
+    nlm_hal_write_cde_reg(CMP_REG_RESET_REG(i), 0x00);
+  }  
+}
+
+    return 0;
+}
+
+static void __exit xlp_cde_cleanup(void)
+{
+    unregister_chrdev(xlp_cde_major, "NLM_XLP_CDE");
+}
+
+module_init(xlp_cde_init);
+module_exit(xlp_cde_cleanup);
+MODULE_DESCRIPTION("XLP Hardware CDE Support.");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.1");
+MODULE_AUTHOR("Alok Agrawat");
diff --git a/drivers/misc/netlogic/nlm_cde/nlm_cde.h b/drivers/misc/netlogic/nlm_cde/nlm_cde.h
new file mode 100644
index 0000000..8d7488f
--- /dev/null
+++ b/drivers/misc/netlogic/nlm_cde/nlm_cde.h
@@ -0,0 +1,80 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+#ifndef _NLM_CDE_H_
+#define _NLM_CDE_H_
+
+#define NUM_VC 8
+#define NLM_CDE_VC_BASE 297
+#define NUM_CDE_ENGINE 4
+
+#define CDE_INFLATE 			1
+#define CDE_DEFLATE 			2
+
+#define CDE_NON      0
+#define CDE_STATIC   1
+#define CDE_DYNAMIC  2
+#define CDE_DYNAMIC2 3
+
+#define CMP_REG_SCRATCH_PAGE(i)  (0x47 + i * 0x10)
+#define CMP_REG_RESET_REG(i)     (0x4c + i * 0x10)
+#define CMP_REG_CTRL_REG(i)	(0x41 + (i * 0x10))
+
+#define MSGRNG_STNID_CMP0 XLP_STNID_CMP
+#define MSGRNG_STNID_CMP1 (XLP_STNID_CMP + 4)
+
+#define RTN_BKT 2
+#define FD_BURST_SIZE 1
+#define NUM_FREE_DESCRIPTORS 100 //must be less or equal to MAX_NUM_PAGES
+#define MAX_NUM_PAGES 100
+#define MAX_BUFFER_SIZE 1024*16
+#define CMP_PAGE_SIZE   1024
+#define SCRATCH_SIZE    1024
+#define MAX_NUM_MESSAGES 20
+
+
+typedef struct cmp_data_structure {
+  char *src;    // source data
+  char *target; // inflated or deflated result
+  unsigned long long *src_desc;  // source descriptors
+  unsigned long long *scratch;    // scratch page
+  unsigned long long src_size;    //size of source data
+  unsigned long long target_size; // size of result
+  unsigned long long num_desc;    // number of source descriptors including scratch desc
+  short op;                       // to deflate or inflate
+  unsigned int compression_type;
+  unsigned int sof;
+  unsigned int eof;
+} cmp_data_t;
+
+typedef enum {
+	CDE_READ_DONE = 0,
+	CDE_WRITE_PENDING,
+	CDE_WRITE_DONE
+} nlm_cde_state;
+
+typedef struct msgrng_msg msg;
+
+#endif
+
diff --git a/drivers/misc/netlogic/nlm_cde/nlm_cde_api.h b/drivers/misc/netlogic/nlm_cde/nlm_cde_api.h
new file mode 100644
index 0000000..d865c50
--- /dev/null
+++ b/drivers/misc/netlogic/nlm_cde/nlm_cde_api.h
@@ -0,0 +1,62 @@
+/***********************************************************************
+  Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+  reserved.
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are
+  met:
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+  THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+ *****************************#NETL_2#********************************/
+#ifndef _NLM_CDE_API_H_
+#define _NLM_CDE_API_H_
+
+/**
+ * @file_name nlm_cde_api.h
+ */
+
+/**
+ * @defgroup cde Compression/Decompression API
+ * @brief Description about the cde apis supported.
+ */
+
+
+#define NLM_ERR_BASE				0xEAE0000
+#define NLM_ERR_CDE_PARAM_NULL 			(NLM_ERR_BASE | 1)
+#define NLM_ERR_INVALID_PARAM 			(NLM_ERR_BASE | 2)
+#define NLM_ERR_NO_MEM 				(NLM_ERR_BASE | 3)
+#define NLM_ERR_UNSPECIFIED 			(NLM_ERR_BASE | 4)
+#define	NLM_ERR_SEND_TIMEOUT 			(NLM_ERR_BASE | 5)
+#define NLM_ERR_IN_PROGRESS 			(NLM_ERR_BASE | 6)
+
+#define NLM_ERR_FREEBACK_NOT_RECEIVED 		(NLM_ERR_BASE | 256)
+
+
+
+cmp_data_t* nlm_cde_init(void);
+unsigned int nlm_cde_send_request(cmp_data_t *cmp_data, unsigned int op,
+			unsigned int type, 
+			unsigned int sof, 
+			unsigned int eof, 
+			unsigned char *src_buf, 
+			unsigned int size);
+unsigned int nlm_cde_receive_response(cmp_data_t *cmp_data, 
+						unsigned char *buf, 
+						unsigned int count);
+void nlm_cde_cleanup(cmp_data_t *cmp_data);
+
+#endif
-- 
1.9.1

