From 7768e3b74ab295310f9798c6cce898c988e4ef39 Mon Sep 17 00:00:00 2001
From: "P. Sadik" <psadik@broadcom.com>
Date: Tue, 27 May 2014 13:47:38 +0530
Subject: [PATCH 0949/1532] General: Remove printing function name in debug
 prints.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c | 464 ++++++++++++-------------
 1 file changed, 232 insertions(+), 232 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
index 724c664..ae5e30f 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
@@ -128,7 +128,7 @@ static inline void nlm_hal_PMFF_ALL_workaround(nae_t *nae, int block, int lane_c
 *
 * @return
 *       - none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -251,7 +251,7 @@ void xlp8xx_ax_lane_reset_txpll(nae_t *nae, int block, int lane_ctrl, int mode)
 *
 * @return
 *       - 0 on success, non-zero on failure
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -264,7 +264,7 @@ static int xlp3xx_8xxb0_lane_reset_txpll(nae_t *nae, uint32_t block, uint32_t la
 	uint64_t mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
 
 
-        netsoc_api_print(NETSOC_APIDBG_PORT,"%s: node %d block %d lane_ctrl %x \n", __func__, nae->node, block, lane_ctrl);
+        netsoc_api_print(NETSOC_APIDBG_PORT,"node %d block %d lane_ctrl %x \n",nae->node, block, lane_ctrl);
 
         /* rxaui mode only lanes 0 and 2 are used in each complex, 1/3 not used
          * skip lane 1 & 3 by setting lane_inc = 2
@@ -285,7 +285,7 @@ static int xlp3xx_8xxb0_lane_reset_txpll(nae_t *nae, uint32_t block, uint32_t la
         if(mode != PHYMODE_SGMII){
                 val |= PHY_LANE_CTRL_BPC_XAUI; /*Set comma bypass for XAUII*/
         }
- 
+
         val |= 0x100000 | (mode << PHY_LANE_CTRL_PHYMODE_POS);  /* Bit20: serdes reg reset Storm & Eagle B0 */
         val &= ~(0x20000);
         netsoc_write_mac_reg(mac_base, lane_ctrl,val);
@@ -346,13 +346,13 @@ static void xlp9xx_lane_reset(nae_t *nae, int block, int lane_ctrl, int mode)
         uint32_t val = 0, count=0;
 	uint64_t mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
 
-        netsoc_api_print(NETSOC_APIDBG_PORT,"%s: block %d lane_ctrl %x \n",__func__,block,lane_ctrl);
+        netsoc_api_print(NETSOC_APIDBG_PORT,"block %d lane_ctrl %x \n",block,lane_ctrl);
 	/*TODO: XLP9XX RXAUI check*/
 
 	if(mode==PHYMODE_SGMII && block==2 && lane_ctrl !=PHY_LANE_0_CTRL){
 		return; /*Only one lane in complex 2 */
 	}
-	
+
 	if (mode==PHYMODE_SGMII) { // FIXME PHYMODE_HS_SGMII support is yet to be added; || mode==PHYMODE_HS_SGMII){
         	val = (1<<20) | (1<<29);
 	}else{
@@ -360,35 +360,35 @@ static void xlp9xx_lane_reset(nae_t *nae, int block, int lane_ctrl, int mode)
 	}
 	if(mode==PHYMODE_XFI){
 		mode = PHYMODE_XAUI;
-	}	
+	}
 	val |= (mode << PHY_LANE_CTRL_PHYMODE_POS);
 	if(lane_ctrl != 0){ //TODO: Verify for XLP9XX
                 netsoc_write_mac_reg(mac_base, lane_ctrl, val);
                 val = netsoc_read_mac_reg(mac_base, lane_ctrl);
-                netsoc_api_print(NETSOC_APIDBG_PORT,"%s Bit 20 reg reset removed val =0x%x\n",__func__, val);
-        }   
+                netsoc_api_print(NETSOC_APIDBG_PORT,"Bit 20 reg reset removed val =0x%x\n",val);
+        }
 
         if ((mode == PHYMODE_RXAUI) || (mode == PHYMODE_IL)) {
         	val = netsoc_read_mac_reg(mac_base, lane_ctrl);
 		val |= 1<<30;
         	netsoc_write_mac_reg(mac_base, lane_ctrl, val);
-        	netsoc_api_print(NETSOC_APIDBG_PORT,"%s Bit 30 epcs removed val =0x%x\n",__func__, val);
+        	netsoc_api_print(NETSOC_APIDBG_PORT,"Bit 30 epcs removed val =0x%x\n",val);
 	}else{
-		val = netsoc_read_mac_reg(mac_base, lane_ctrl); 
+		val = netsoc_read_mac_reg(mac_base, lane_ctrl);
 		val &=~(1<<29);
 		val = val & 0xfff80000;
         	netsoc_write_mac_reg(mac_base, lane_ctrl, val);
-        	netsoc_api_print(NETSOC_APIDBG_PORT,"%s Bit 29 power down  removed val =0x%x\n",__func__, val);
-		val = netsoc_read_mac_reg(mac_base, lane_ctrl); 
+        	netsoc_api_print(NETSOC_APIDBG_PORT,"Bit 29 power down  removed val =0x%x\n",val);
+		val = netsoc_read_mac_reg(mac_base, lane_ctrl);
 		val |= 1<<30;
         	netsoc_write_mac_reg(mac_base, lane_ctrl, val);
-        	netsoc_api_print(NETSOC_APIDBG_PORT,"%s Bit 30 epcs removed val =0x%x\n",__func__, val);
+        	netsoc_api_print(NETSOC_APIDBG_PORT,"Bit 30 epcs removed val =0x%x\n",val);
 	}
         while(!((val = netsoc_read_mac_reg(mac_base, lane_ctrl-PHY_LANE_0_CTRL)) & PHY_LANE_STAT_PCR)) {
                 count++;
                 if (count == 1000) {
-                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s PMA controller not ready\n",__func__);
-			 netsoc_api_delay(1000);	
+                        netsoc_api_print(NETSOC_APIDBG_ERROR,"PMA controller not ready\n");
+			 netsoc_api_delay(1000);
                 }
         }
 	netsoc_api_print(NETSOC_APIDBG_PORT, "Lane reset complete - PMA ready\n");
@@ -397,7 +397,7 @@ static void xlp9xx_lane_reset(nae_t *nae, int block, int lane_ctrl, int mode)
 
 /**********************************************************************
  *  nae_lane_reset_txpll
- * * serdes lane progaming 
+ * * serdes lane progaming
  ********************************************************************* */
 /**
 * @brief xlp2xx_nae_lane_reset_txpll function is used to reset the Tx PLL for XLP2XX products.
@@ -409,7 +409,7 @@ static void xlp9xx_lane_reset(nae_t *nae, int block, int lane_ctrl, int mode)
 *
 * @return
 *       - none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -419,13 +419,13 @@ static void xlp2xx_lane_reset_txpll(nae_t *nae, int block, int lane_ctrl, int mo
         uint32_t val = 0, count;
 	uint64_t mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
 
-        netsoc_api_print(NETSOC_APIDBG_PORT,"%s: block %d lane_ctrl %x \n",__func__,block,lane_ctrl);
+        netsoc_api_print(NETSOC_APIDBG_PORT,"block %d lane_ctrl %x \n",block,lane_ctrl);
 
         /* rxaui mode only lanes 0 and 2 are used in each complex, 1/3 not used
          * skip lane 1 & 3 by setting lane_inc = 2
          */
         if (mode == PHYMODE_RXAUI) {
-             if (lane_ctrl%2) 
+             if (lane_ctrl%2)
                 return;
         }
 
@@ -435,7 +435,7 @@ static void xlp2xx_lane_reset_txpll(nae_t *nae, int block, int lane_ctrl, int mo
         nlm_mdelay(1);
 
         val = netsoc_read_mac_reg(mac_base, lane_ctrl);
-        netsoc_api_print(NETSOC_APIDBG_PORT,"%s value before power down =0x%x\n",__func__, val);
+        netsoc_api_print(NETSOC_APIDBG_PORT,"value before power down =0x%x\n",val);
 
         val &= ~(1<<29);
         val = val & 0xfff80000;
@@ -443,7 +443,7 @@ static void xlp2xx_lane_reset_txpll(nae_t *nae, int block, int lane_ctrl, int mo
         nlm_mdelay(1);
 
         val = netsoc_read_mac_reg(mac_base, lane_ctrl);
-        netsoc_api_print(NETSOC_APIDBG_PORT,"%s value after power up =0x%x\n", __func__, val);
+        netsoc_api_print(NETSOC_APIDBG_PORT,"value after power up =0x%x\n",val);
         val |=(1<<30);
         netsoc_write_mac_reg(mac_base, lane_ctrl, val);
         nlm_mdelay(1);
@@ -451,7 +451,7 @@ static void xlp2xx_lane_reset_txpll(nae_t *nae, int block, int lane_ctrl, int mo
         while(!((val = netsoc_read_mac_reg(mac_base, lane_ctrl-PHY_LANE_0_CTRL)) & PHY_LANE_STAT_PCR)) {
 		count++;
 		if (count == 1000) {
-			netsoc_api_print(NETSOC_APIDBG_ERROR,"%s PMA controller not ready\n",__func__);
+			netsoc_api_print(NETSOC_APIDBG_ERROR,"PMA controller not ready\n");
 			break;
 		}
 	}
@@ -495,7 +495,7 @@ static void xlp8xxbx_ilkport_reset_txpll(nae_t *nae, uint32_t ilk_block_base, ui
                         netsoc_write_mac_reg(mac_base, lane,  val);
                         netsoc_api_print(NETSOC_APIDBG_PORT,"Reset PLL done \n");
         	}
-	}     
+	}
 }
 
 static void xlp8xxax_ilkport_reset_txpll(nae_t *nae, uint32_t ilk_block_base, uint32_t max_block)
@@ -504,7 +504,7 @@ static void xlp8xxax_ilkport_reset_txpll(nae_t *nae, uint32_t ilk_block_base, ui
                                 PHY_LANE_CTRL_PWRDOWN | (PHYMODE_IL << PHY_LANE_CTRL_PHYMODE_POS);
 	uint32_t block, lane, val, rext_sel, i;
         uint64_t mac_base;
- 
+
         for(block = ilk_block_base; block < max_block ; block++) {
 		mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
                 for (lane = PHY_LANE_0_CTRL; lane <= PHY_LANE_3_CTRL; lane++) {
@@ -598,9 +598,9 @@ static void xlp8xx_ilk_reset_pll(nae_t *nae, int ilk_block_base, int ilk_num_lan
 
 static void vsemi_configure_loopback(uint64_t mac_base)
 {
-        uint32_t reg_addr, lane_no, max_lanes =4;  
+        uint32_t reg_addr, lane_no, max_lanes =4;
         for (lane_no=0; lane_no<max_lanes; lane_no++) {
-	
+
                 __netsoc_write_pma2p0_reg(mac_base, lane_no, PMA2P0_INDIRECT_ADDRESS_0055, 0xFD);
                 __netsoc_write_pma2p0_reg(mac_base, lane_no, PMA2P0_INDIRECT_ADDRESS_0007,PMA2P0_INTERNAL_BUFF_TXRX_LOOPBACK);
 	}
@@ -608,19 +608,19 @@ static void vsemi_configure_loopback(uint64_t mac_base)
 
 void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed, int phy_mode, int kr_en)
 {
-        uint32_t reg_addr, lane_no, max_lanes =4;  
+        uint32_t reg_addr, lane_no, max_lanes =4;
         uint32_t pma2p0_cmd=0;
 	uint32_t delay, pma2p0_config;
 	uint32_t lwidth = 1;
-	
+
 	uint32_t lane_speed = XAUI_TYPE_LANE;
-	
+
 	if((phy_mode == PHYMODE_XFI) || (phy_mode == PHYMODE_XLAUI))
-		lane_speed = XFI_TYPE_LANE;	
-	
+		lane_speed = XFI_TYPE_LANE;
+
 	if(block==2 && (phy_mode == PHYMODE_SGMII)){
 		max_lanes =1;
-	}	
+	}
 
         for (reg_addr=101; reg_addr <111; reg_addr++){
                 for (lane_no=0; lane_no<max_lanes; lane_no++) {
@@ -637,7 +637,7 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
                                 pma2p0_cmd |= pma2p0_mem_xaui_4page[reg_addr];
 			}
                         else if((xgmii_speed==10 ) && (lane_speed ==XFI_TYPE_LANE)){
-				 pma2p0_cmd |= pma2p0_mem_10G_lane_4page[reg_addr];	
+				 pma2p0_cmd |= pma2p0_mem_10G_lane_4page[reg_addr];
 			}
                         if(phy_mode==PHYMODE_SGMII){
                                 pma2p0_cmd |= pma2p0_mem_sgmii_4page[reg_addr];
@@ -652,7 +652,7 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 	for (reg_addr=101; reg_addr <165; reg_addr++){
 		int extra_common_lanes = max_lanes;
 		if(!(is_nlm_xlp5xx())){
-			extra_common_lanes = 1;	
+			extra_common_lanes = 1;
 		}
 
 		for (lane_no=0; lane_no<extra_common_lanes; lane_no++) {
@@ -669,7 +669,7 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 				pma2p0_cmd |= pma2p0_mem_xaui[reg_addr];
 			}
 			if((xgmii_speed==10 ) && (lane_speed ==XFI_TYPE_LANE)){
-				pma2p0_cmd |= pma2p0_mem_10G_lane[reg_addr];	
+				pma2p0_cmd |= pma2p0_mem_10G_lane[reg_addr];
 			}
 			if(phy_mode==PHYMODE_SGMII){
 				pma2p0_cmd |= pma2p0_mem_sgmii[reg_addr];
@@ -699,9 +699,9 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 			__netsoc_write_pma2p0_reg(mac_base, 4, 0x37, pma2p0_cmd);
 		}
 	}
-	
+
 	// Extra configuration for XLAUI
-	if(phy_mode == PHYMODE_XLAUI){ 
+	if(phy_mode == PHYMODE_XLAUI){
 		if(is_nlm_xlp5xx()){
 			for (lane_no=0; lane_no<max_lanes; lane_no++){
 				pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, PMA2P0_COMMON_LANE0 + lane_no, 0x37);
@@ -711,14 +711,14 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 
 			}
 
-		}else{	
+		}else{
 			pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, 4, 0x37);
 			pma2p0_cmd &= 0x80;
 			pma2p0_cmd |= 0x10;
 			__netsoc_write_pma2p0_reg(mac_base, 4, 0x37, pma2p0_cmd);
 		}
 	}
-	
+
         for (lane_no=0; lane_no<max_lanes; lane_no++) {
 #if 1
                 __netsoc_write_pma2p0_reg(mac_base, lane_no, 21, 0xd9);
@@ -745,20 +745,20 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
                 pma2p0_cmd &= ~(1<<3);
                 __netsoc_write_pma2p0_reg(mac_base, lane_no, 86, pma2p0_cmd);
         }
-	
-	if((phy_mode == PHYMODE_XLAUI) || (phy_mode == PHYMODE_XFI) || (phy_mode == PHYMODE_IL)){ 
+
+	if((phy_mode == PHYMODE_XLAUI) || (phy_mode == PHYMODE_XFI) || (phy_mode == PHYMODE_IL)){
 		for (lane_no=0; lane_no<max_lanes; lane_no++) {
 			if (kr_en)
 				__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x15, 0xdf);
 			else
 				__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x15, 0xd9);
-					
+
 			__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x16, 0x07);
 			if (kr_en)
 				__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x1c, 0x50);
 			else
 				__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x1c, 0x00);
-				
+
 			__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x1b, 0x70);
              }
 	}
@@ -769,7 +769,7 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
     	// De-assert hard reset
 	pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
 	if(is_nlm_xlp5xx()){
-			
+
     		pma2p0_config &= ~(PMA2P0_LANE0_RXTX_HARD_RESET | PMA2P0_LANE0_SYNTH_HARD_RESET);
 		 pma2p0_config  &= ~(PMA2P0_LANE1_RXTX_HARD_RESET | PMA2P0_LANE1_SYNTH_HARD_RESET);
 		pma2p0_config &= ~(PMA2P0_LANE2_RXTX_HARD_RESET | PMA2P0_LANE2_SYNTH_HARD_RESET);
@@ -778,11 +778,11 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 		pma2p0_config &= ~(PMA2P0_CTL_POR | PMA2P0_CTL_SYNTH_RST | PMA2P0_CTL_RTHR);
 	}
 	netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
-    
+
 	for(delay=0; delay<10000; delay++);
-	
+
 	netsoc_api_print(NETSOC_APIDBG_PORT,"Waiting for block %d PCSOUTSYNTH_READY\n", block);
-	
+
     	for (lane_no=0; lane_no<max_lanes; lane_no=lane_no+lwidth) {
 		if((!(is_nlm_xlp5xx())) && lane_no>0)
 			break;
@@ -790,30 +790,30 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 		while((pma2p0_cmd& 0x1) != 0x1){
 			pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, 0x4 + lane_no, 0x4);
 		}
-	}	
-    	
+	}
+
 	for (lane_no=0; lane_no<max_lanes; lane_no=lane_no+lwidth) {
 		netsoc_api_print(NETSOC_APIDBG_PORT,"PMA2P0: Waiting for block %d lane %d PCSOUT_RX_READY\n", block, lane_no);
 		pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, lane_no, 11);
 		while((pma2p0_cmd & 0x1) != 0x1){
 			pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, lane_no, 11);
 		}
-	}	
-    	
+	}
+
 	for (lane_no=0; lane_no<max_lanes; lane_no=lane_no+lwidth) {
 		netsoc_api_print(NETSOC_APIDBG_PORT,"PMA2P0: Waiting for block %d lane %d PCSOUT_TX_READY\n", block, lane_no);
 		pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, lane_no, 11);
 		while((pma2p0_cmd & 0x4) != 0x4){
 			pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, lane_no, 11);
 		}
-	}	
+	}
         nlm_print("PMA2P0 configuration is OK \n");
 #if 0
 	vsemi_configure_loopback(mac_base);
 	for (lane_no=0; lane_no<max_lanes; lane_no++) {
 		pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, lane_no, PMA2P0_INDIRECT_ADDRESS_0055);
 	}
-#endif 
+#endif
 }
 
 static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t pma2p0_por , uint32_t speed, uint32_t phymode)
@@ -827,7 +827,7 @@ static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t pma
 
 	if(!pma2p0_por){
 		if(is_nlm_xlp5xx()){
-			
+
 			pma2p0_config = netsoc_read_mac_reg(netsoc_get_macreg_base_for_phy(nae->mac_base, 0), PMA2P0_CTL0);
 			pma2p0_config &= ~XLP5XX_PMA2P0_CTL_POR;
 			netsoc_write_mac_reg(netsoc_get_macreg_base_for_phy(nae->mac_base, 0), PMA2P0_CTL0, pma2p0_config);
@@ -882,7 +882,7 @@ static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t pma
 					data_rate_width = (PMA2P0_DATA_RATE_GTE_5G | PMA2P0_DATA_WIDTH_10BIT);
 				}else{
 					data_rate_width = (PMA2P0_DATA_RATE_GTE_2P5G_LT_5G | PMA2P0_DATA_WIDTH_10BIT);
-				}		
+				}
 			}else if(PHYMODE_RXAUI==phymode){
 				if(16==speed){
 					data_rate_width = (PMA2P0_DATA_RATE_GTE_5G | PMA2P0_DATA_WIDTH_20BIT);
@@ -892,14 +892,14 @@ static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t pma
 					data_rate_width = (PMA2P0_DATA_RATE_GTE_5G | PMA2P0_DATA_WIDTH_20BIT);
 				}
 			}else if(PHYMODE_XLAUI==phymode){
-				data_rate_width = (PMA2P0_DATA_RATE_GTE_5G | PMA2P0_DATA_WIDTH_40BIT);		
+				data_rate_width = (PMA2P0_DATA_RATE_GTE_5G | PMA2P0_DATA_WIDTH_40BIT);
 			}else if(PHYMODE_XFI==phymode){
 				data_rate_width = (PMA2P0_DATA_RATE_GTE_5G | PMA2P0_DATA_WIDTH_40BIT);
 			}else if(PHYMODE_IL==phymode){
 				data_rate_width = (PMA2P0_DATA_RATE_GTE_5G | PMA2P0_DATA_WIDTH_20BIT);
 			}
 			pma2p0_config |= (data_rate_width << (8 * lane_no));
-		}	
+		}
 
 	}else{
 		pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL1);
@@ -918,13 +918,13 @@ static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t pma
 			else //XAUII/10G
 				pma2p0_config = PMA2P0_CTL_XAUI_DR | PMA2P0_CTL_XAUI_DW;
 		}else if(PHYMODE_XFI==phymode){
-			pma2p0_config |= PMA2P0_CTL_XFI_DR | PMA2P0_CTL_XFI_DW;	
+			pma2p0_config |= PMA2P0_CTL_XFI_DR | PMA2P0_CTL_XFI_DW;
 		}else if(PHYMODE_XLAUI==phymode){
-			pma2p0_config |= PMA2P0_CTL_XLAUI_DW | PMA2P0_CTL_XLAUI_DR;	
+			pma2p0_config |= PMA2P0_CTL_XLAUI_DW | PMA2P0_CTL_XLAUI_DR;
 		}else if (PHYMODE_IL==phymode){
-			pma2p0_config |= PMA2P0_CTL_XLAUI_ILK | PMA2P0_CTL_ILK_DW;	
+			pma2p0_config |= PMA2P0_CTL_XLAUI_ILK | PMA2P0_CTL_ILK_DW;
 		}
-	}	
+	}
 
 	for(delay=0; delay<1000000; delay++);
 
@@ -932,7 +932,7 @@ static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t pma
 
         xlp9xx_nae_write_pma2p0_mem(mac_base, block, speed, phymode, nae->bkpl_cfg[block].kr_en);
 #ifdef PMA2P0_DEBUG
-	__netsoc_display_pma2p0_indirect_reg(mac_base, block);	
+	__netsoc_display_pma2p0_indirect_reg(mac_base, block);
 #endif
 
 }
@@ -948,7 +948,7 @@ static void xlp2xx_config_block_pma2p0(nae_t *nae, uint32_t block, uint32_t pma2
                         pma2p0_config &= ~PMA2P0_CTL_POR;
                         netsoc_write_mac_reg(netsoc_get_macreg_base_for_phy(nae->mac_base, block+1), PMA2P0_CTL0, pma2p0_config);
                	}
-               
+
 		pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
                 pma2p0_config &= 0xFFFF01FF;
                 pma2p0_config |= PMA2P0_CTL_POR | PMA2P0_CTL_SYNTH_RST | PMA2P0_CTL_RTHR;
@@ -962,7 +962,7 @@ static void xlp2xx_config_block_pma2p0(nae_t *nae, uint32_t block, uint32_t pma2
                 netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
 
                 for(delay=0; delay<1000000; delay++);
- 
+
                 pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL1);
                 pma2p0_config &= ~((0x7<<4) | 0x7);
 
@@ -1006,7 +1006,7 @@ static void xlp2xx_config_block_pma2p0(nae_t *nae, uint32_t block, uint32_t pma2
 *
 * @return
 *       - none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -1053,7 +1053,7 @@ static void __netsoc_xlp_nae_config_lane_gmac(nae_t *nae, int cplx_mask)
                                 xlp8xx_ax_lane_reset_txpll(nae, block, lane_ctrl, PHYMODE_SGMII);
                         }
                 }
-        }      
+        }
 
         for( block = 0; block < 4; block++)
         {
@@ -1063,11 +1063,11 @@ static void __netsoc_xlp_nae_config_lane_gmac(nae_t *nae, int cplx_mask)
 
                 if(is_nlm_xlp2xx()){
 			xlp2xx_config_block_pma2p0(nae, block, nae->serdes_init_cnt, 0, PHYMODE_SGMII);
-			nae->serdes_init_cnt++; 
+			nae->serdes_init_cnt++;
                 }
 		if(IS_NLM_XLP9XX_FAMILY){
 			xlp9xx_config_pma2p0_serdes(nae, block, nae->serdes_init_cnt, 0, PHYMODE_SGMII);
-			nae->serdes_init_cnt++;	
+			nae->serdes_init_cnt++;
 		}
 
                 for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++){
@@ -1076,10 +1076,10 @@ static void __netsoc_xlp_nae_config_lane_gmac(nae_t *nae, int cplx_mask)
                                 nlm_hal_PMFF_ALL_workaround(nae, block, lane_ctrl);
                         }else if(is_nlm_xlp2xx()){
                                 xlp2xx_lane_reset_txpll(nae, block, lane_ctrl, PHYMODE_SGMII);
-			}	
+			}
 			else if(IS_NLM_XLP9XX_FAMILY){
 				xlp9xx_lane_reset(nae, block, lane_ctrl, PHYMODE_SGMII);
-			}else{  
+			}else{
                                 xlp8xx_ax_lane_reset_txpll(nae, block, lane_ctrl, PHYMODE_SGMII);
                         }
                 }
@@ -1186,12 +1186,12 @@ static void config_lanes_for_xgmac(nae_t *nae, uint32_t xgmac_cplx_mask, uint32_
         }
 
 	if((phymode==PHYMODE_RXAUI) && IS_NLM_XLP9XX_FAMILY){
-		lane_enable = netsoc_read_mac_reg(mac_base, LANE_CFG_CPLX_4); 
+		lane_enable = netsoc_read_mac_reg(mac_base, LANE_CFG_CPLX_4);
 		if(xgmac_cplx_mask & 0x1){
-			lane_enable |= (1<< 16); 
+			lane_enable |= (1<< 16);
 		}
 		if(xgmac_cplx_mask & 0x2){
-			lane_enable |= (1<< 18); 
+			lane_enable |= (1<< 18);
 		}
 		netsoc_write_mac_reg(mac_base, LANE_CFG_CPLX_4, lane_enable);
 	}
@@ -1203,15 +1203,15 @@ static void config_lanes_for_xfi(nae_t *nae, uint32_t xfi_cplx_mask)
 {
 	uint32_t val;
 	uint64_t mac_base = netsoc_get_macreg_base_for_lanecfg(nae->mac_base);
-	val = netsoc_read_mac_reg(mac_base, LANE_CFG_CPLX_4); 
+	val = netsoc_read_mac_reg(mac_base, LANE_CFG_CPLX_4);
 	if(xfi_cplx_mask & 0x1){
-		val |= (1<< COMPLEX0_XFI_EN); 
+		val |= (1<< COMPLEX0_XFI_EN);
 	}
 	if(xfi_cplx_mask & 0x2){
-		val |= (1<< COMPLEX1_XFI_EN); 
+		val |= (1<< COMPLEX1_XFI_EN);
 	}
 	netsoc_write_mac_reg(mac_base, LANE_CFG_CPLX_4, val);
-	
+
 	config_lanes_for_xgmac(nae, xfi_cplx_mask, PHYMODE_XFI);/*same lane mode as XAUI*/
 }
 
@@ -1219,7 +1219,7 @@ static void xlp2xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
 {
 	uint32_t block, lane_status, lane_ctrl, count, timeout = 10000;
 	uint64_t mac_base;
-	
+
 	config_lanes_for_xgmac(nae, xaui_cplx_mask, phymode);
 
 	for( block = 0; block < 4; block++)
@@ -1245,9 +1245,9 @@ static void xlp2xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
                         nlm_hal_config_pma2p0_mem_xaui_4page_125();
                         nlm_hal_config_pma2p0_mem_xaui_125();
                 }
-		
+
 		xlp2xx_config_block_pma2p0(nae, block, nae->serdes_init_cnt, xaui_speed, phymode);
-		nae->serdes_init_cnt++;	
+		nae->serdes_init_cnt++;
 
                 for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++){
 			//TODO: XLP9XX all four lanes used for RXAUI
@@ -1257,7 +1257,7 @@ static void xlp2xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
 		}
 	}
 
-//        netsoc_api_print(NETSOC_APIDBG_PORT, "%s all blocks & lanes out of TXPLL\n", __func__);
+//        netsoc_api_print(NETSOC_APIDBG_PORT, "all blocks & lanes out of TXPLL\n");
 
         netsoc_api_delay(10);
         /* Wait for Rx & TX clock stable */
@@ -1279,7 +1279,7 @@ static void xlp2xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
                         while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_STCS)) != PHY_LANE_STAT_STCS) {
 				count++;
 				if (count == timeout) {
-					netsoc_api_print(NETSOC_APIDBG_ERROR,"%s TX clock not stable", __func__);
+					netsoc_api_print(NETSOC_APIDBG_ERROR,"TX clock not stable");
 					break;
 				}
                         }
@@ -1289,8 +1289,8 @@ static void xlp2xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
 			count = 0;
                         while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_SRCS)) != PHY_LANE_STAT_SRCS) {
 				count++;
-                                if (count == timeout) {   
-                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s RX clock not stable", __func__);
+                                if (count == timeout) {
+                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"RX clock not stable");
 					break;
                                 }
                         }
@@ -1300,8 +1300,8 @@ static void xlp2xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
                         while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_XLF)) != 0) {
                                 /* Wait for XAUI Lane fault to be cleared */
 				count++;
-                                if (count == timeout) {   
-                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s XAUI lane fault not cleared", __func__);
+                                if (count == timeout) {
+                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"XAUI lane fault not cleared");
 					break;
                                 }
                         }
@@ -1319,7 +1319,7 @@ static void xlp9xx_ilk_pcs_init(nae_t *nae, uint32_t ilk_complex_map)
 	uint32_t lane_status, lane_ctrl, count, timeout = 10000;
         volatile uint32_t lane_mask = 0;
         uint32_t ilk_lane_eable = 0;
-        volatile uint32_t lane_config = 0, lane_cfg_reg = 0; 
+        volatile uint32_t lane_config = 0, lane_cfg_reg = 0;
         uint32_t block, temp_block=0, max_block;
 	uint64_t mac_base = netsoc_get_macreg_base_for_lanecfg(nae->mac_base);
 	int ilk_num_lanes, ilk_rate;
@@ -1336,11 +1336,11 @@ static void xlp9xx_ilk_pcs_init(nae_t *nae, uint32_t ilk_complex_map)
 		netsoc_api_print(NETSOC_APIDBG_PORT,"VSEMI: config data for Interlaken \n");
         	       nlm_hal_config_pma2p0_mem_rxaui_4page();
                 nlm_hal_config_pma2p0_mem_rxaui();
-		
+
 		netsoc_api_print(NETSOC_APIDBG_TRACE,"\n################# vsemi config done ###############\n");
 		/*config PMA2P0 block */
 		xlp9xx_config_pma2p0_serdes(nae, block, nae->serdes_init_cnt, speed, phymode);
-		nae->serdes_init_cnt++;	
+		nae->serdes_init_cnt++;
 
 		if (ilk_complex_map & (1<<block)) {
 			ilk_num_lanes = nae->num_lanes[block/2];
@@ -1380,7 +1380,7 @@ static void xlp9xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
 {
 	uint32_t block, lane_status, lane_ctrl, count, timeout = 10000;
 	uint64_t mac_base;
-	
+
 	config_lanes_for_xgmac(nae, xaui_cplx_mask, phymode);
 
 	for( block = 0; block < 4; block++)
@@ -1413,11 +1413,11 @@ static void xlp9xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
                         nlm_hal_config_pma2p0_mem_xaui_4page();
                         nlm_hal_config_pma2p0_mem_xaui();
                 }
-		
+
 		/*config PMA2P0 block */
 		xlp9xx_config_pma2p0_serdes(nae, block, nae->serdes_init_cnt, xaui_speed, phymode);
-		nae->serdes_init_cnt++;	
-                
+		nae->serdes_init_cnt++;
+
                 for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++){
 			//TODO: XLP9XX all four lanes used for RXAUI
 			//if(phymode == PHYMODE_RXAUI && (lane_ctrl%2))
@@ -1426,7 +1426,7 @@ static void xlp9xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
 		}
 	}
 
-        netsoc_api_print(NETSOC_APIDBG_PORT, "%s all blocks & lanes out of TXPLL\n", __func__);
+        netsoc_api_print(NETSOC_APIDBG_PORT, "all blocks & lanes out of TXPLL\n");
 
         netsoc_api_delay(10);
         /* Wait for Rx & TX clock stable */
@@ -1448,7 +1448,7 @@ static void xlp9xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
                         while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_STCS)) != PHY_LANE_STAT_STCS) {
 				count++;
 				if (count == timeout) {
-					netsoc_api_print(NETSOC_APIDBG_ERROR,"%s TX clock not stable", __func__);
+					netsoc_api_print(NETSOC_APIDBG_ERROR,"TX clock not stable");
 					break;
 				}
                         }
@@ -1458,8 +1458,8 @@ static void xlp9xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
 			count = 0;
                         while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_SRCS)) != PHY_LANE_STAT_SRCS) {
 				count++;
-                                if (count == timeout) {   
-                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s RX clock not stable", __func__);
+                                if (count == timeout) {
+                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"RX clock not stable");
 					break;
                                 }
                         }
@@ -1469,12 +1469,12 @@ static void xlp9xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
                         while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_XLF)) != 0) {
                                 /* Wait for XAUI Lane fault to be cleared */
 				count++;
-                                if (count == timeout) {   
-                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s XAUI lane fault not cleared", __func__);
+                                if (count == timeout) {
+                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"XAUI lane fault not cleared");
 					break;
                                 }
                         }
-			netsoc_api_print(NETSOC_APIDBG_ERROR,"%s XAUI lane status 0x%x\n",__func__, netsoc_read_mac_reg(mac_base, lane_status));
+			netsoc_api_print(NETSOC_APIDBG_ERROR,"XAUI lane status 0x%x\n",netsoc_read_mac_reg(mac_base, lane_status));
                 }
         }
 }
@@ -1495,15 +1495,15 @@ static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t ph
 		nlm_hal_config_pma2p0_mem_10G_lane();
 		//TODO: If HIGIG pass XGMII speed.
 		xlp9xx_config_pma2p0_serdes(nae, block, nae->serdes_init_cnt, 10, phymode);
-		nae->serdes_init_cnt++;	
+		nae->serdes_init_cnt++;
 	}
-	
-	if((phymode==PHYMODE_XFI))	
+
+	if((phymode==PHYMODE_XFI))
 		config_lanes_for_xfi(nae, cplx_mask);
 	else{
 		config_lanes_for_xlgmac(nae, cplx_mask, PHYMODE_XLAUI);
 	}
-	
+
 	for( block = 0; block < 4; block++)
         {
                 if ((cplx_mask & (1 << block)) == 0) {
@@ -1515,7 +1515,7 @@ static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t ph
 		}
 	}
 
-//        netsoc_api_print(NETSOC_APIDBG_PORT, "%s all blocks & lanes out of TXPLL\n", __func__);
+//        netsoc_api_print(NETSOC_APIDBG_PORT, "all blocks & lanes out of TXPLL\n");
 
         netsoc_api_delay(10);
         /* Wait for Rx & TX clock stable */
@@ -1534,7 +1534,7 @@ static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t ph
                         while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_STCS)) != PHY_LANE_STAT_STCS) {
 				count++;
 				if (count == timeout) {
-					netsoc_api_print(NETSOC_APIDBG_ERROR,"%s TX clock not stable\n", __func__);
+					netsoc_api_print(NETSOC_APIDBG_ERROR,"TX clock not stable\n");
 					break;
 				}
                         }
@@ -1544,8 +1544,8 @@ static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t ph
 			count = 0;
                         while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_SRCS)) != PHY_LANE_STAT_SRCS) {
 				count++;
-                                if (count == timeout) {   
-                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s RX clock not stable\n", __func__);
+                                if (count == timeout) {
+                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"RX clock not stable\n");
 					break;
                                 }
                         }
@@ -1557,13 +1557,13 @@ static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t ph
                                 /* Wait for XAUI Lane fault to be cleared */
                                 count++;
                                 if (count == timeout) {
-                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s XFI/XLAUI lane fault not cleared \n", __func__);
+                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"XFI/XLAUI lane fault not cleared \n");
                                 }
                         }
 #endif
                 }
         }
-		
+
 }
 
 static void xlp_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phymode)
@@ -1593,7 +1593,7 @@ static void xlp_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phym
                         }
                 }
         }
-        netsoc_api_print(NETSOC_APIDBG_PORT,"%s all blocks & lanes out of TXPLL\n", __func__);
+        netsoc_api_print(NETSOC_APIDBG_PORT,"all blocks & lanes out of TXPLL\n");
 
         netsoc_api_delay(10);
         /* Wait for Rx & TX clock stable */
@@ -1615,7 +1615,7 @@ static void xlp_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phym
                         while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_STCS)) != PHY_LANE_STAT_STCS) {
 				count++;
                                 if (count == timeout) {
-                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s TX clock not stable", __func__);
+                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"TX clock not stable");
                                         break;
                                 }
                         }
@@ -1626,7 +1626,7 @@ static void xlp_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phym
                         while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_SRCS)) != PHY_LANE_STAT_SRCS) {
 				count++;
                                 if (count == timeout) {
-                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s RX clock not stable", __func__);
+                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"RX clock not stable");
                                         break;
                                 }
                         }
@@ -1637,7 +1637,7 @@ static void xlp_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phym
                                 /* Wait for XAUI Lane fault to be cleared */
 				count++;
                                 if (count == timeout) {
-                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s XAUI lane fault not cleared", __func__);
+                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"XAUI lane fault not cleared");
                                         break;
                                 }
                         }
@@ -1667,7 +1667,7 @@ void __netsoc_clause_173_enable(nae_t *nae, uint32_t block, uint32_t lane_no)
 	volatile uint32_t rd_data;
 	uint32_t port_no;
 	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-	uint32_t phymode = get_phy_mode(nae, block); 
+	uint32_t phymode = get_phy_mode(nae, block);
 
 
 	//DEBUG: Read DME VSEMI register bit
@@ -1680,7 +1680,7 @@ void __netsoc_clause_173_enable(nae_t *nae, uint32_t block, uint32_t lane_no)
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_0);
 	//TODO; NEXT PAGE ENABLED
 	//if(nae->bkpl_cfg[block].next_page == 1) {
-		//rd_data |= (0x1 << 15); // Next Page 
+		//rd_data |= (0x1 << 15); // Next Page
 	//}
 	__netsoc_write_kr_reg(base, lane_no, KXAN_ABILITY_0, rd_data);
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_0);
@@ -1692,7 +1692,7 @@ void __netsoc_clause_173_enable(nae_t *nae, uint32_t block, uint32_t lane_no)
 	if(block==0) {
 		rd_data &= 0xFFE0; //Transmitted nonce [4:0]
 		rd_data |= 0x1F;
-	}  
+	}
 	if(block==1) {
 		rd_data &= 0xFFE0; //Transmitted nonce
 		rd_data |= 0x07;
@@ -1701,7 +1701,7 @@ void __netsoc_clause_173_enable(nae_t *nae, uint32_t block, uint32_t lane_no)
 	if(phymode==PHYMODE_XFI){
 		rd_data |= (0x1 << 7); // technology ability is 10g-KR
 	}else if(phymode==PHYMODE_XLAUI){
-		rd_data |= (0x1 << 8) | (0x1 << 7) | (0x1 << 6) | (0x1 << 5);  
+		rd_data |= (0x1 << 8) | (0x1 << 7) | (0x1 << 6) | (0x1 << 5);
 	}
 	__netsoc_write_kr_reg(base, lane_no, KXAN_ABILITY_1, rd_data);
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_1);
@@ -1724,15 +1724,15 @@ void __netsoc_clause_173_enable(nae_t *nae, uint32_t block, uint32_t lane_no)
 		nlm_print("KR enabled for complex: %d lane 0\n", block, lane_no);
 	}
 
-	data &= (~0xF0); 
-	data |= (KR_PHY_STATUS | KR_UNBYPASS); 
+	data &= (~0xF0);
+	data |= (KR_PHY_STATUS | KR_UNBYPASS);
 	netsoc_write_mac_reg(base, KR_CTRL, data);
 	data = netsoc_read_mac_reg(base, KR_CTRL);
-	
+
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_CONTROL);
 	if(nae->bkpl_cfg[block].kr_lpbk){
 		/*restart the AN on one of the block*/
-		if((block==1))  	
+		if((block==1))
 			rd_data |= (0x1 << 9); // an-restart
 	}
 	rd_data |= (0x1 << 12); // an-enable
@@ -1743,7 +1743,7 @@ void __netsoc_clause_173_enable(nae_t *nae, uint32_t block, uint32_t lane_no)
 	//}
 	__netsoc_write_kr_reg(base, lane_no, KXAN_CONTROL, rd_data);
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_CONTROL);
-	//nlm_print(" AN_CONTROL:  lane:%d value is 0x%x\n",  lane_no, rd_data); 
+	//nlm_print(" AN_CONTROL:  lane:%d value is 0x%x\n",  lane_no, rd_data);
 
 	//DEBUG: Read DME VSEMI register bit
 	//rd_data = read_vsemi_reg( lane_no, 0x28);
@@ -1760,9 +1760,9 @@ void __netsoc_perform_clause_173_base_page(nae_t *nae, uint32_t block, uint32_t
 	//Step3:
 	//check for base page exchange completion
 	//status register
-#if 0	
+#if 0
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_CONTROL);
-	if((block==1))  	
+	if((block==1))
 		rd_data |= (0x1 << 9); // an-restart
 	__netsoc_write_kr_reg(base, lane_no, KXAN_CONTROL, rd_data);
 	return;
@@ -1774,7 +1774,7 @@ void __netsoc_perform_clause_173_base_page(nae_t *nae, uint32_t block, uint32_t
 		nlm_print(" AN_STATUS: complex: %d lane: %d Waiting for base page exchange completion value:0x%x\n",block, lane_no, rd_data);
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
 		nlm_mdelay(10);
-		//if(count++ == 50) break; 
+		//if(count++ == 50) break;
 	}
 	//nlm_print(" AN_STATUS: complex: %d lane: %d Base page exchange completed value:0x%x\n",block, lane_no, rd_data);
 	//TODO:
@@ -1805,11 +1805,11 @@ void __netsoc_clause_173_next_page(nae_t *nae, uint32_t block, uint32_t lane_no)
 	if(nae->bkpl_cfg[block].message_page == 1) {
 		rd_data |= (0x1 << 13); // set MP
 		rd_data &= 0xFFFFF800; //10:0 //Refer to NextPage Message code field definitions (IEEE Std 802.3-2005 Annex28C)
-		rd_data |= (0x1 << 0); 
+		rd_data |= (0x1 << 0);
 	} else {
 		rd_data |= (0x0 << 13); // set MP
-		rd_data &= 0xFFFFF800; //10:0 
-		rd_data |= (0xAB + block); 
+		rd_data &= 0xFFFFF800; //10:0
+		rd_data |= (0xAB + block);
 	}
 	rd_data |= (0x0 << 15); // Next page (XNP)
 	__netsoc_write_kr_reg(base, lane_no, AN_XNP_0, rd_data);
@@ -1842,7 +1842,7 @@ void __netsoc_perform_clause_173_next_page(nae_t *nae, uint32_t block, uint32_t
 	//status register
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
 	// looping on status until an complete or page received
-	while((rd_data & (1<<6)) == 0 ) { 
+	while((rd_data & (1<<6)) == 0 ) {
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);;
 	}
 	nlm_print(" AN_STATUS: complex: %d: Next page exchange completed value:0x%x\n", block, rd_data);
@@ -1865,7 +1865,7 @@ void __netsoc_perform_clause_173_next_page(nae_t *nae, uint32_t block, uint32_t
 
 #define BIT(n)  (1<<n)
 #define  bit_clear(data, n)  data &= ~(n)
-#define bit_set(data, n)     data |= (n)       
+#define bit_set(data, n)     data |= (n)
 # if 0
 void __netsoc_bkpl_write_pma2p0_txdriver_registers(nae_t *nae, uint32_t block, uint32_t lane_no) {
 	volatile uint32_t rd_data;
@@ -1876,9 +1876,9 @@ void __netsoc_bkpl_write_pma2p0_txdriver_registers(nae_t *nae, uint32_t block, u
 	// TXDRV_LEVNM2  22[5:4]    0 1 2 3  2'h0
 	// TXDRV_LEVNP1  23[2:0]    0 1 2 3  3'h0
 	// TXDRV_SLEW    23[4:3]    0 1 2 3  2'h0
-	// TXDRV_LOCWREN 87[6:6]    0 1 2 3  
+	// TXDRV_LOCWREN 87[6:6]    0 1 2 3
 	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 87);
-	bit_clear(rd_data, BIT(5)); 
+	bit_clear(rd_data, BIT(5));
 	__netsoc_write_pma2p0_reg(mac_base, lane_no, 87, rd_data);
 	__netsoc_write_pma2p0_reg(mac_base, lane_no, 21, 0xdf);
 	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 21);
@@ -1891,7 +1891,7 @@ void __netsoc_bkpl_write_pma2p0_txdriver_registers(nae_t *nae, uint32_t block, u
 	nlm_print("write_vsemi_txdriver_registers:  lane:%d 23:0x%x\n",  lane_no, rd_data);
 
 }
-void __netsoc_bkpl_read_vsemi_rxequalization_registers(nae_t *nae, uint32_t block, uint32_t lane_no) 
+void __netsoc_bkpl_read_vsemi_rxequalization_registers(nae_t *nae, uint32_t block, uint32_t lane_no)
 {
 	volatile uint32_t rd_data;
 	volatile uint32_t rxcaleq_dcgain, rxcaleq_dfepstapf3db, rxcaleq_dfepstapgain, rxcaleq_dfetap1gain, rxcaleq_dfetap2gain, rxcaleq_dfetap3gain, rxcaleq_dfetap4gain, rxcaleq_lofreqagcgain, rxcaleq_hifreqagccap, rxcaleq_locwren;
@@ -1936,14 +1936,14 @@ void __netsoc_bkpl_read_vsemi_rxequalization_registers(nae_t *nae, uint32_t bloc
 	__netsoc_write_pma2p0_reg(mac_base, lane_no, 86, rd_data);
 }
 
-#endif 
+#endif
 static inline uint32_t mod(int32_t value){
 	volatile uint32_t mod_value;
 
 	if (value < 0) {
 		mod_value = -value;
 	} else {
-		mod_value = value;    
+		mod_value = value;
 	}
 	return(mod_value);
 }
@@ -1954,7 +1954,7 @@ static inline uint32_t update_coefficient(uint32_t update, int32_t present_coeff
 	uint32_t step = 1;
 
 	switch (update) {
-		case 0 : updated_coeff = present_coeff;        break;  
+		case 0 : updated_coeff = present_coeff;        break;
 		case 1 : updated_coeff = present_coeff + step; break;
 		case 2 : updated_coeff = present_coeff - step; break;
 	}
@@ -1969,10 +1969,10 @@ static inline void __netsoc_bkpl_wait_for_lt_done(uint64_t base, uint32_t lane_n
 	while((rd_data & (1<<15)) == 0) { //signal detection - indicates training process is complete
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
 	}
-	nlm_print("Wait for Link Training done\n");	
+	nlm_print("Wait for Link Training done\n");
 }
 
-void __netsoc_bkpl_wait_for_lt_int(nae_t *nae, uint32_t block, uint32_t lane_no uint32_t update) { 
+void __netsoc_bkpl_wait_for_lt_int(nae_t *nae, uint32_t block, uint32_t lane_no uint32_t update) {
 	volatile uint32_t rd_data;
 	uint64_t cnt=0,cnt1=0;
 
@@ -1980,39 +1980,39 @@ void __netsoc_bkpl_wait_for_lt_int(nae_t *nae, uint32_t block, uint32_t lane_no
 
 	if(block==1) {
 		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1_MASK);
-		rd_data |= (0x1 << 22); 
+		rd_data |= (0x1 << 22);
 		netsoc_write_nae_iface_reg(nae_base, NETIOR_INT1_MASK, rd_data);
 		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
 		while((rd_data & BIT(22)) == 0) {
 			rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
-		}  
+		}
 		nlm_print("wait_for_lt_int:  lane:%d NetiorINT1 interrupt status after polling value: 0x%x\n",  lane_no, rd_data);
-		rd_data |= (0x1 << 22); //write 1 to clear 
+		rd_data |= (0x1 << 22); //write 1 to clear
 		netsoc_write_nae_iface_reg(nae_base, NETIOR_INT1, rd_data);
 		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
 	}
 	if(block==0) {
 		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1_MASK);
-		rd_data |= (0x1 << 23); 
+		rd_data |= (0x1 << 23);
 		netsoc_write_nae_iface_reg(nae_base, NETIOR_INT1_MASK, rd_data);
 		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
 		while((rd_data & BIT(23)) == 0) {
 			rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
-		}  
+		}
 		nlm_print("wait_for_lt_int:  lane:%d NetiorINT1 interrupt status after polling value: 0x%x\n",  lane_no, rd_data);
-		rd_data |= (0x1 << 23); //write 1 to clear 
+		rd_data |= (0x1 << 23); //write 1 to clear
 		netsoc_write_nae_iface_reg(nae_base, NETIOR_INT1, rd_data);
 		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
 	}
 }
 
-#endif 
+#endif
 
 void __netsoc_bkpl_enable_link_training(nae_t *nae, uint32_t block, uint32_t lane_no)
 {
 	volatile uint32_t rd_data;
 	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-	uint32_t phymode = get_phy_mode(nae, block); 
+	uint32_t phymode = get_phy_mode(nae, block);
 
 	rd_data = __netsoc_read_kr_reg(base, lane_no, BP_ETH_STATUS);
 	if(phymode == PHYMODE_XLAUI) {
@@ -2035,8 +2035,8 @@ void __netsoc_bkpl_enable_link_training(nae_t *nae, uint32_t block, uint32_t lan
 
 }
 
-static void __netsoc_bkpl_restart_link_training(nae_t *nae, uint32_t block, uint32_t lane_no) 
-{ 
+static void __netsoc_bkpl_restart_link_training(nae_t *nae, uint32_t block, uint32_t lane_no)
+{
 	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
 	volatile uint32_t rd_data;
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_CONTROL);
@@ -2046,14 +2046,14 @@ static void __netsoc_bkpl_restart_link_training(nae_t *nae, uint32_t block, uint
 	nlm_print("restart_link_training: lane:%d restart training \n",lane_no);
 }
 
-void send_maintap_update (nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t update) 
+void send_maintap_update (nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t update)
 {
 	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
 	volatile uint32_t main_tap_coeff, main_tap_status;
 	volatile uint32_t rd_data;
 
-	main_tap_coeff = update; 
-	rd_data = (main_tap_coeff << 2); 
+	main_tap_coeff = update;
+	rd_data = (main_tap_coeff << 2);
 	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
 	//nlm_print("send_maintap_update: SEND C(0) update  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
 
@@ -2062,12 +2062,12 @@ void send_maintap_update (nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
 		main_tap_status = ((rd_data & 0xC) >> 2);
 		if((main_tap_status == 0x3) || (main_tap_status == 0x2) || (main_tap_status == 0x1)) { //if maximum or minimum or updated, set LD coeff to hold
-			main_tap_coeff = 0x0; // hold 
-			rd_data = (main_tap_coeff << 2); 
+			main_tap_coeff = 0x0; // hold
+			rd_data = (main_tap_coeff << 2);
 			__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
 			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_COEFF);
 			//nlm_print("send_maintap_update: Set C(0) to HOLD  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
-		} 
+		}
 	} while (main_tap_status == 0x0);
 	do {
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
@@ -2082,8 +2082,8 @@ void send_pretap_update(nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t u
 	volatile uint32_t rd_data;
 	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
 
-	pre_tap_coeff = update; 
-	rd_data = pre_tap_coeff; 
+	pre_tap_coeff = update;
+	rd_data = pre_tap_coeff;
 	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
 	//nlm_print("send_pretap_update: SEND C(-1) update  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
 
@@ -2093,8 +2093,8 @@ void send_pretap_update(nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t u
 		//nlm_print("send_pretap_update:  lane:%d Value of LP status register is 0x%x\n",  lane_no, rd_data);
 		pre_tap_status = (rd_data & 0x3);
 		if((pre_tap_status == 0x3) || (pre_tap_status == 0x2) || (pre_tap_status == 0x1)) { //if maximum or minimum or updated, set LD coeff to hold
-			pre_tap_coeff = 0x0; // hold 
-			rd_data = pre_tap_coeff; 
+			pre_tap_coeff = 0x0; // hold
+			rd_data = pre_tap_coeff;
 			__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
 		//	nlm_print("send_pretap_update: Set C(-1) to HOLD  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
 		}
@@ -2111,8 +2111,8 @@ void send_posttap_update( nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t
 	volatile uint32_t rd_data;
 	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
 
-	post_tap_coeff = update; 
-	rd_data = (post_tap_coeff << 4); 
+	post_tap_coeff = update;
+	rd_data = (post_tap_coeff << 4);
 	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
 	//nlm_print("send_posttap_update: SEND C(+1) update  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
 
@@ -2122,12 +2122,12 @@ void send_posttap_update( nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t
 		//nlm_print("send_posttap_update:  lane:%d Value of LP status register is 0x%x \n",  lane_no, rd_data);
 		post_tap_status = ((rd_data & 0x30) >> 4);
 		if((post_tap_status == 0x3) || (post_tap_status == 0x2) || (post_tap_status == 0x1)) { //if maximum or minimum or updated, set LD coeff to hold
-			post_tap_coeff = 0x0; // hold 
-			rd_data = (post_tap_coeff << 4); 
+			post_tap_coeff = 0x0; // hold
+			rd_data = (post_tap_coeff << 4);
 			__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
 			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_COEFF);
 		//	nlm_print("send_posttap_update: Set C(+1) to HOLD  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
-		} 
+		}
 	} while (post_tap_status == 0x0);
 	do {
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
@@ -2164,22 +2164,22 @@ static void  __netsoc_bkpl_program_tx_driver(nae_t *nae, uint32_t block, uint32_
 	// TXDRV_LEVNM2  22[5:4]    0 1 2 3  2'h0
 	// TXDRV_LEVNP1  23[2:0]    0 1 2 3  3'h0
 	// TXDRV_SLEW    23[4:3]    0 1 2 3  2'h0
-	// TXDRV_LOCWREN 87[6:6]    0 1 2 3  
+	// TXDRV_LOCWREN 87[6:6]    0 1 2 3
 
 	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 21);
-	//txdrv_hlev = (rd_data & 0x7);        //21[2:0] 
+	//txdrv_hlev = (rd_data & 0x7);        //21[2:0]
 	txdrv_levn = ((rd_data >> 3) & 0x1F);//21[7:3]
 	////nlm_print("program_tx_driver:  lane:%d 21:0x%x\n",  lane_no, rd_data);
 	rd_data =  __netsoc_read_pma2p0_reg(base, lane_no, 22);
 	txdrv_levnm1 = (rd_data & 0xF);       //22[3:0]
-	//txdrv_levnm2 = ((rd_data >> 4) & 0xF);//22[7:4] 
+	//txdrv_levnm2 = ((rd_data >> 4) & 0xF);//22[7:4]
 	//nlm_print("program_tx_driver:  lane:%d 22:0x%x\n",  lane_no, rd_data);
 	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 23);
 	txdrv_levnp1 = (rd_data & 0x7);      //23[2:0]
 	//txdrv_slew = ((rd_data >> 3) & 0x3); //23[4:3]
 	//nlm_print("program_tx_driver: inst:%d complex
 
-	//Get initial coefficients 
+	//Get initial coefficients
 	coeff27_minus1 = ((txdrv_levnp1));
 	coeff27_plus1  = ((txdrv_levnm1));
 	mod_coeff27_minus1 = mod(coeff27_minus1);
@@ -2197,7 +2197,7 @@ static void  __netsoc_bkpl_program_tx_driver(nae_t *nae, uint32_t block, uint32_
 
 	//Read LP coefficient update
 	do {
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF); 
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF);
 		//nlm_print("program_tx_driver:  lane:%d Value of LP coefficient update register is 0x%x --1\n", lane_no, rd_data);
 		//Get coeff updates
 		coeff_minus1_update = (rd_data & 0x3);
@@ -2213,7 +2213,7 @@ static void  __netsoc_bkpl_program_tx_driver(nae_t *nae, uint32_t block, uint32_
 		temp_coeff27_zero   = update_coefficient(coeff_zero_update, present_coeff_zero);
 		temp_coeff27_plus1  = update_coefficient(coeff_plus1_update, present_coeff_plus1);
 
-		mod_temp_coeff27_minus1 =  mod(temp_coeff27_minus1); 
+		mod_temp_coeff27_minus1 =  mod(temp_coeff27_minus1);
 		mod_temp_coeff27_zero   =  mod(temp_coeff27_zero);
 		mod_temp_coeff27_plus1  =  mod(temp_coeff27_plus1);
 
@@ -2235,7 +2235,7 @@ static void  __netsoc_bkpl_program_tx_driver(nae_t *nae, uint32_t block, uint32_
 				updated_status_minus1 = 0;
 			}
 			if(coeff_zero_update != 0) {
-				if(mod_temp_coeff27_zero > 0x1B) { 
+				if(mod_temp_coeff27_zero > 0x1B) {
 					updated_status_zero = 3;//maximum
 					updated_coeff_zero = present_coeff_zero;
 					//} else if(mod_temp_coeff27_zero < 0) { //FIXME
@@ -2253,13 +2253,13 @@ static void  __netsoc_bkpl_program_tx_driver(nae_t *nae, uint32_t block, uint32_
 				if(mod_temp_coeff27_plus1 > 0x9) {
 					updated_coeff_plus1  = present_coeff_plus1;
 					updated_status_plus1 = 3;//maximum
-				} else if(mod_temp_coeff27_plus1 < 0) { 
+				} else if(mod_temp_coeff27_plus1 < 0) {
 					updated_coeff_plus1  = present_coeff_plus1;
 					updated_status_plus1 = 2;//minimum
 				} else {
 					updated_coeff_plus1  = temp_coeff27_plus1;
 					updated_status_plus1 = 1;
-				} 
+				}
 			} else {
 				updated_coeff_plus1 = present_coeff_plus1;
 				updated_status_plus1 = 0;
@@ -2274,13 +2274,13 @@ static void  __netsoc_bkpl_program_tx_driver(nae_t *nae, uint32_t block, uint32_
 		}
 		//nlm_print("program_tx_driver:  lane:%d updated_coeff_minus1:%d updated_coeff_zero:%d updated_coeff_plus1:%d\n",  lane_no,updated_coeff_minus1,updated_coeff_zero,updated_coeff_plus1 );
 
-		mod_updated_coeff_minus1 =  mod(updated_coeff_minus1); 
+		mod_updated_coeff_minus1 =  mod(updated_coeff_minus1);
 		mod_updated_coeff_zero   =  mod(updated_coeff_zero);
 		mod_updated_coeff_plus1  =  mod(updated_coeff_plus1);
 
 		//Write TX DRV registers
 		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 87);
-		rd_data &= ~(1<<5); 
+		rd_data &= ~(1<<5);
 		__netsoc_write_pma2p0_reg(base, lane_no, 87, rd_data);
 
 		//calculate register fields (txdrv_levn, txdrv_nm1, txdev_np1)
@@ -2337,7 +2337,7 @@ static void  __netsoc_bkpl_program_tx_driver(nae_t *nae, uint32_t block, uint32_
 		//nlm_print("program_tx_driver: lane:%d Value of LP coefficient update register is 0x%x -2\n", lane_no, rd_data);
 		//Set LD Status to not updated
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
-		rd_data &= 0xFFC0 ; // set 5:0 to 0 (not updated) 
+		rd_data &= 0xFFC0 ; // set 5:0 to 0 (not updated)
 		__netsoc_write_kr_reg(base , lane_no, KR_LD_STAT, rd_data);
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
 		//nlm_print("program_tx_driver:  lane:%d Value of LD status register is 0x%x\n", lane_no, rd_data);
@@ -2348,7 +2348,7 @@ static void  __netsoc_bkpl_program_tx_driver(nae_t *nae, uint32_t block, uint32_
 
 }
 
-uint32_t __netsoc_bkpl_get_eyediag_figure_of_merit(nae_t *nae, uint32_t block, uint32_t lane_no) 
+uint32_t __netsoc_bkpl_get_eyediag_figure_of_merit(nae_t *nae, uint32_t block, uint32_t lane_no)
 {
 
 	volatile uint32_t rd_data;
@@ -2374,14 +2374,14 @@ uint32_t __netsoc_bkpl_get_eyediag_figure_of_merit(nae_t *nae, uint32_t block, u
 	while ((rd_data & BIT(3)) != BIT(3)) {
 		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 32);
 	}
-	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 29); 
-	eye_value1 = rd_data & 0xFF; 
-	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 30); 
-	eye_value0 = rd_data & 0x3F; 
-	figure_of_merit_value = ((eye_value1 << 6) | (eye_value0)); 
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 29);
+	eye_value1 = rd_data & 0xFF;
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 30);
+	eye_value0 = rd_data & 0x3F;
+	figure_of_merit_value = ((eye_value1 << 6) | (eye_value0));
 	//nlm_print(" get_eyediag_figure_of_merit:  lane:%d updated figure of merit for eye opening:0x%x\n",  lane_no, figure_of_merit_value);
 
-	//4. reset the EQ start signal 
+	//4. reset the EQ start signal
 	//PCSRXEQ_START	31[0:0] 1'b0
 	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 31);
 	bit_clear(rd_data, BIT(0));
@@ -2395,7 +2395,7 @@ void __netsoc_bkpl_link_device_training(nae_t *nae, uint32_t block, uint32_t lan
 {
 	volatile uint32_t rd_data;
 	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-	uint32_t phymode = get_phy_mode(nae, block); 
+	uint32_t phymode = get_phy_mode(nae, block);
 	uint32_t count=0;
 
 	//MTIP step1: Keep polling PMD Status until it indicates frame lock
@@ -2411,7 +2411,7 @@ void __netsoc_bkpl_link_device_training(nae_t *nae, uint32_t block, uint32_t lan
 	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
 	//nlm_print("link_device_training:  lane:%d Value of LP status register is 0x%x\n", lane_no, rd_data);
 	while ((rd_data & BIT(15)) == 0) {
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF); 
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF);
 		if((rd_data & 0x3F)!= 0x0) __netsoc_bkpl_program_tx_driver(nae, block, lane_no);
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
 	}
@@ -2442,7 +2442,7 @@ void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t la
 {
 	volatile uint32_t rd_data;
 	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-	uint32_t phymode = get_phy_mode(nae, block); 
+	uint32_t phymode = get_phy_mode(nae, block);
 
 	volatile uint32_t eye_value, updated_eye_value=0;
 	volatile uint32_t pre_tap_coeff, post_tap_coeff, main_tap_coeff;
@@ -2454,11 +2454,11 @@ void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t la
 	//start_perfctr();
 	//1
 	//rd_data = read_kr_reg( lane_no, KR_LD_COEFF);
-	//rd_data |= (0x1 << 12); //initialize 
+	//rd_data |= (0x1 << 12); //initialize
 	//write_kr_reg( lane_no, KR_LD_COEFF, rd_data);
 	//nlm_print(" link_partner_training:  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
 
-	//2 
+	//2
 	//rd_data = read_kr_reg( lane_no, KR_PMD_STATUS);
 	//nlm_print("link_partner_training : complex_no:%d: PMD STATUS value:0x%x\n", rd_data);
 
@@ -2476,20 +2476,20 @@ void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t la
 		//i   Send DEC C(0)
 		send_maintap_update(nae, block, lane_no, 0x2); //decrement
 
-		updated_eye_value =__netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no); 
+		updated_eye_value =__netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
 		//nlm_print("link_partner_training:  lane:%d  After step 4i updated_eye_value:0x%x\n",  lane_no, updated_eye_value);
 		//ii   Send INC(-1)
 		send_pretap_update(nae, block, lane_no, 0x1); //increment
 
-		//iii  
-		//iv  
+		//iii
+		//iv
 		updated_eye_value = __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);;
 		//nlm_print("link_partner_training:  lane:%d  After step 4ii updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
 		//nlm_print("link_partner_training:  lane:%d  updated_eye_value: 0x%x eye_value:0x%x\n",  lane_no, updated_eye_value, eye_value);
 		//nlm_print("link_partner_training:  lane:%d  After step 4ii Read rx equalization register values\n", lane_no);
 		//read_vsemi_rxequalization_registers( lane_no);
 		count++;
-	} while (updated_eye_value > eye_value); 
+	} while (updated_eye_value > eye_value);
 
 	//v   Send DEC(-1)
 	send_pretap_update(nae, block, lane_no, 0x2); //decrement
@@ -2514,8 +2514,8 @@ void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t la
 		//ii  Send INC C(+1)
 		send_posttap_update(nae, block, lane_no, 0x1); //increment
 
-		//iii  
-		//iv  
+		//iii
+		//iv
 		updated_eye_value = __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
 		//nlm_print("link_partner_training:  lane:%d  After step 5ii updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
 		//nlm_print("link_partner_training:  lane:%d  After step 5ii Read rx equalization register values\n",  lane_no);
@@ -2526,7 +2526,7 @@ void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t la
 
 	//6  Send DEC C(+1)
 	send_posttap_update(nae, block, lane_no, 0x2); //decrement
-	updated_eye_value =  __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);  
+	updated_eye_value =  __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
 	//nlm_print("link_partner_training:  lane:%d  After step 6: updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
 	//nlm_print("link_partner_training:  lane:%d  After step 6 Read rx equalization register values\n",  lane_no);
 	//read_vsemi_rxequalization_registers( lane_no);
@@ -2561,7 +2561,7 @@ void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t la
 		nlm_print("link_partner_training:  lane:%d Reached lt_done value:0x%x\n",  lane_no, rd_data);
 	}
 
-	if(block==0) { 
+	if(block==0) {
 		//Read LP status
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
 		while ((rd_data & BIT(15)) == 0) {
@@ -2575,14 +2575,14 @@ void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t la
 void __netsoc_bkpl_auneg_complete(nae_t *nae, uint32_t block, uint32_t lane_no)
 {
 	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-	uint32_t phymode = get_phy_mode(nae, block); 
+	uint32_t phymode = get_phy_mode(nae, block);
 	volatile uint32_t rd_data;
 	uint32_t count;
 	if(nae->bkpl_cfg[block].link_training_enable)
 	{
 		//Disable LT
 		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_CONTROL);
-		rd_data |= (0x1 << 0); // restart training 
+		rd_data |= (0x1 << 0); // restart training
 		rd_data |= (0x0 << 1); // training enable
 		__netsoc_write_kr_reg(base, lane_no, KR_PMD_CONTROL, rd_data);
 		nlm_print("wait_for_an_complete:  lane:%d Disabled link training\n",  lane_no);
@@ -2595,8 +2595,8 @@ void __netsoc_bkpl_auneg_complete(nae_t *nae, uint32_t block, uint32_t lane_no)
 		nlm_print(" AN_STATUS: complex: %d lane: %d Waiting for an_done. value:0x%x\n", block, lane_no, rd_data);
 		nlm_mdelay(50);
 			rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
-		
-		//if(count++ == 100) break; 
+
+		//if(count++ == 100) break;
 	}
 	nlm_print(" complex: %d lane: %d AN process completed value:0x%x\n", block, lane_no,rd_data);
 }
@@ -2654,65 +2654,65 @@ void __netsoc_kr_init_an(nae_t *nae, int block)
 
 	uint32_t lane_ctrl, max_kr_lanes=4, lane_no;
 	uint32_t cplx_mask = nae->xlgmac_complex_map | nae->xfi_complex_map;
-#define NUM_LANES_PER_COMPLEX 4	
-	static volatile int lt_done_nae0_c0[NUM_LANES_PER_COMPLEX]; 
-	static volatile int lt_done_nae0_c1[NUM_LANES_PER_COMPLEX]; 
-	static volatile int lt_done_nae1_c0[NUM_LANES_PER_COMPLEX]; 
-	static volatile int lt_done_nae1_c1[NUM_LANES_PER_COMPLEX]; 
+#define NUM_LANES_PER_COMPLEX 4
+	static volatile int lt_done_nae0_c0[NUM_LANES_PER_COMPLEX];
+	static volatile int lt_done_nae0_c1[NUM_LANES_PER_COMPLEX];
+	static volatile int lt_done_nae1_c0[NUM_LANES_PER_COMPLEX];
+	static volatile int lt_done_nae1_c1[NUM_LANES_PER_COMPLEX];
 
 	//for( block = 0; block < 2; block++)
         //{
-		uint32_t phymode = get_phy_mode(nae, block); 
-		
+		uint32_t phymode = get_phy_mode(nae, block);
+
 		if(!(phymode==XLAUI_IF || phymode==XFI_IF))
 		 	return;
 //		 	continue;
-		
+
 		//if(!(nae->bkpl_cfg[block].kr_en))
 		//	continue;
 
                 for( lane_ctrl = 0; lane_ctrl < max_kr_lanes; lane_ctrl++){
-			__netsoc_setup_bkpl_link_training(nae, block, lane_ctrl);		
+			__netsoc_setup_bkpl_link_training(nae, block, lane_ctrl);
 		}
-	
+
 	//}
 
 	//for( block = 0; block < 2; block++)
         //{
-	//	uint32_t phymode = get_phy_mode(nae, block); 
-		
+	//	uint32_t phymode = get_phy_mode(nae, block);
+
 	//	if(!(phymode==XLAUI_IF || phymode==XFI_IF))
 	//	 	continue;
-	//	max_kr_lanes = (phymode==XFI_IF) ? 4:0; 
-		
+	//	max_kr_lanes = (phymode==XFI_IF) ? 4:0;
+
 	//	if(!(nae->bkpl_cfg[block].kr_en))
 	//		continue;
 
                 for( lane_ctrl = 0; lane_ctrl <=0; lane_ctrl++){
-			__netsoc_clause_173_enable(nae, block, lane_ctrl);		
+			__netsoc_clause_173_enable(nae, block, lane_ctrl);
 		}
-	
+
 	//}
 	//for( block = 0; block < 2; block++)
         //{
-	//	uint32_t phymode = get_phy_mode(nae, block); 
-	
+	//	uint32_t phymode = get_phy_mode(nae, block);
+
 	//	if(!(phymode==XLAUI_IF || phymode==XFI_IF))
 	//	 	continue;
-	//	max_kr_lanes = (phymode==XFI_IF) ? 4:0; 
-		
+	//	max_kr_lanes = (phymode==XFI_IF) ? 4:0;
+
 	//	if(!(nae->bkpl_cfg[block].kr_en))
 	//		continue;
 
                 for( lane_ctrl = 0; lane_ctrl <= 0; lane_ctrl++){
-			__netsoc_perform_clause_173_base_page(nae, block, lane_ctrl);		
+			__netsoc_perform_clause_173_base_page(nae, block, lane_ctrl);
 		}
-                
+
 		for( lane_ctrl = 0; lane_ctrl < max_kr_lanes; lane_ctrl++){
-			__netsoc_bkpl_enable_link_training(nae, block, lane_ctrl);		
+			__netsoc_bkpl_enable_link_training(nae, block, lane_ctrl);
 		}
 		nlm_print("Done with enable link with block = 0x%x\n", block);
-	
+
 	//}
 		if (block==1){
 			for(lane_no=0; lane_no<4; lane_no++){
@@ -2739,7 +2739,7 @@ void __netsoc_kr_init_an(nae_t *nae, int block)
 #if 0
 	for( block = 0; block < 2; block++)
         {
-		uint32_t phymode = get_phy_mode(nae, block); 
+		uint32_t phymode = get_phy_mode(nae, block);
 		if(!(phymode==XLAUI_IF || phymode==XFI_IF))
 		 	continue;
 		if(!(nae->bkpl_cfg[block].kr_en))
@@ -2747,7 +2747,7 @@ void __netsoc_kr_init_an(nae_t *nae, int block)
 
                 for( lane_ctrl = 0; lane_ctrl <= 0; lane_ctrl++){ /*AN on only one lane*/
 			//if((phymode==PHYMODE_XLAUI && lane_ctrl==0) || (phymode==PHYMODE_XFI)){
-				__netsoc_bkpl_auneg_complete(nae, block, lane_ctrl);		
+				__netsoc_bkpl_auneg_complete(nae, block, lane_ctrl);
 			//}
 		}
 	}
@@ -2755,7 +2755,7 @@ endif
 
 #endif
 #endif
-	
+
 }
 
 int __netsoc_interlaken_pcs_init(nae_t *nae, uint32_t ilk_complex_map)
@@ -2801,22 +2801,22 @@ int __netsoc_interlaken_pcs_init(nae_t *nae, uint32_t ilk_complex_map)
 				while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_STCS)) != PHY_LANE_STAT_STCS) {
 					count++;
 					if (count == timeout) {
-						netsoc_api_print(NETSOC_APIDBG_ERROR,"%s TX clock not stable", __func__);
+						netsoc_api_print(NETSOC_APIDBG_ERROR,"TX clock not stable");
 						break;
 					}
 				}
-				nlm_print("%s Blk%d lane%d got TX clock stable\n", __func__, block, lane_status);
+				nlm_print("Blk%d lane%d got TX clock stable\n",block, lane_status);
 
 				/* Wait for RX clock to be set */
 				count = 0;
 				while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_SRCS)) != PHY_LANE_STAT_SRCS) {
 					count++;
 					if (count == timeout) {
-						netsoc_api_print(NETSOC_APIDBG_ERROR,"%s RX clock not stable", __func__);
+						netsoc_api_print(NETSOC_APIDBG_ERROR,"RX clock not stable");
 						break;
 					}
 				}
-				nlm_print("%s Blk%d lane%d got RX clock stable\n", __func__, block, lane_status);
+				nlm_print("Blk%d lane%d got RX clock stable\n",block, lane_status);
 			}
 			if (nae->num_lanes[block/2] <= 4)
 				block++;
-- 
1.9.1

