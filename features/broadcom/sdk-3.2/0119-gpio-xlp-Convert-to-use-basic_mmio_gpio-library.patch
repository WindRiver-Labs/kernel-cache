From dd33bb39fe6988d51ce4a2f510277d8fea989eda Mon Sep 17 00:00:00 2001
From: Kamlakant Patel <kamlakant.patel@broadcom.com>
Date: Wed, 8 Oct 2014 15:03:40 +0530
Subject: [PATCH 0119/1532] gpio/xlp: Convert to use basic_mmio_gpio library

This converts gpio-xlp driver to use basic_mmio_gpio library.
Other updates:
* Added XLP5xx support
* Clean unnecessary variables

Signed-off-by: Kamlakant Patel <kamlakant.patel@broadcom.com>
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/gpio/Kconfig    |   1 +
 drivers/gpio/gpio-xlp.c | 129 +++++++++++++++++++++++-------------------------
 2 files changed, 62 insertions(+), 68 deletions(-)

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index b509590..bcdc304 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -249,6 +249,7 @@ config GPIO_XILINX_PS
 config GPIO_XLP
 	tristate "Netlogic XLP series GPIO support"
 	depends on CPU_XLP
+	select GPIO_GENERIC
 	help
 	  This driver provides basic support (configure as input or output,
 	  read and write pin state) for the GPIO interface on Netlogic XLP
diff --git a/drivers/gpio/gpio-xlp.c b/drivers/gpio/gpio-xlp.c
index 98bab66..fcbcb7f 100644
--- a/drivers/gpio/gpio-xlp.c
+++ b/drivers/gpio/gpio-xlp.c
@@ -42,12 +42,13 @@
 #include <linux/irqreturn.h>
 #include <linux/spinlock.h>
 #include <linux/bitops.h>
+#include <linux/basic_mmio_gpio.h>
 
-#include <asm/netlogic/haldefs.h>
-#include <asm/netlogic/common.h>
-#include <asm/netlogic/xlp-hal/iomap.h>
-#include <asm/netlogic/xlp-hal/sys.h>
-#include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm-generic/bitops/non-atomic.h>
+
+#define	SYS_EFUSE_DEVICE_CFG_STATUS0	0x8
+#define	NR_IRQS_PER_NODE		1024
+#define NLM_GPIO_VEC_BASE		768
 
 #define GPIO_OUTPUT_EN		0x00
 #define GPIO_PADDRV		0x08
@@ -84,8 +85,11 @@
 #define GPIO_3XX_INT_TYPE	0x80
 #define GPIO_3XX_INT_STAT	0x88
 
+#define BGPIO_MAX		3
+
 struct xlp_gpio_priv {
 	void __iomem *gpio_base;
+	struct bgpio_chip bgc[BGPIO_MAX];
 	int gpio_irq;
 	int ngpio;
 	DECLARE_BITMAP(gpio_enabled_mask, 66);
@@ -224,45 +228,13 @@ irqreturn_t xlp_gpio_generic_handler(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-static int xlp_gpio_dir_output(struct gpio_chip *gc, unsigned gpio, int state)
-{
-	struct platform_device *pdev = to_platform_device(gc->dev);
-	struct xlp_gpio_priv *priv = platform_get_drvdata(pdev);
-
-	BUG_ON(gpio >= gc->ngpio);
-	xlp_gpio_set_reg(priv, priv->gpio_output_enbl, gpio, 1);
-	return 0;
-}
-
-static int xlp_gpio_dir_input(struct gpio_chip *gc, unsigned gpio)
-{
-	return 0;
-}
-
-static int xlp_gpio_get(struct gpio_chip *gc, unsigned gpio)
-{
-	struct platform_device *pdev = to_platform_device(gc->dev);
-	struct xlp_gpio_priv *priv = platform_get_drvdata(pdev);
-
-	BUG_ON(gpio >= gc->ngpio);
-	return xlp_gpio_get_reg(priv, priv->gpio_padsmpl, gpio);
-}
-
-static void xlp_gpio_set(struct gpio_chip *gc, unsigned gpio, int state)
-{
-	struct platform_device *pdev = to_platform_device(gc->dev);
-	struct xlp_gpio_priv *priv = platform_get_drvdata(pdev);
-
-	BUG_ON(gpio >= gc->ngpio);
-	xlp_gpio_set_reg(priv, priv->gpio_paddrv, gpio, state);
-}
-
 static int xlp_gpio_probe(struct platform_device *pdev)
 {
-	struct gpio_chip *gc;
 	struct resource *iores;
 	struct xlp_gpio_priv *priv;
 	int irq_base, gpio_irq, g_pin, ret, rev, node;
+	int i, idx, reg_off;
+	void __iomem *sys_base;
 
 	iores = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!iores)
@@ -273,10 +245,6 @@ static int xlp_gpio_probe(struct platform_device *pdev)
 	if (!priv)
 		return -ENOMEM;
 
-	gc = devm_kzalloc(&pdev->dev, sizeof(struct gpio_chip), GFP_KERNEL);
-	if (!gc)
-		return -ENOMEM;
-
 	priv->gpio_base = devm_request_and_ioremap(&pdev->dev, iores);
 	if (!priv->gpio_base)
 		return -ENOMEM;
@@ -284,14 +252,13 @@ static int xlp_gpio_probe(struct platform_device *pdev)
 	gpio_irq = platform_get_irq(pdev, 0);
 	if (gpio_irq < 0)
 		return gpio_irq;
-	node = gpio_irq * NLM_NR_NODES / NR_IRQS;
+	node = gpio_irq / NR_IRQS_PER_NODE;
 
 	priv->prid = read_c0_prid() & 0xff00;
 	/* Set the no. of gpios according to the XLP chip */
 	switch (priv->prid) {
 	case PRID_IMP_NETLOGIC_XLP8XX:
-		gc->ngpio = 41;
-		priv->ngpio = gc->ngpio;
+		priv->ngpio = 41;
 		priv->gpio_output_enbl = GPIO_OUTPUT_EN;
 		priv->gpio_paddrv = GPIO_PADDRV;
 		priv->gpio_padsmpl = GPIO_PADSMPL;
@@ -300,12 +267,20 @@ static int xlp_gpio_probe(struct platform_device *pdev)
 		priv->intr_polarity_reg = GPIO_INT_POL;
 		priv->intr_enable_reg = GPIO_INT_EN00;
 		break;
-	case PRID_IMP_NETLOGIC_XLP2XX:
 	case PRID_IMP_NETLOGIC_XLP3XX:
-		rev = nlm_read_sys_reg(nlm_get_sys_regbase(0),
-					SYS_EFUSE_DEVICE_CFG_STATUS0);
-		gc->ngpio = (rev & 0xf0) ? 44 : 57;
-		priv->ngpio = gc->ngpio;
+		iores = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+		if (!iores)
+			return -ENODEV;
+		sys_base = devm_ioremap(&pdev->dev, iores->start,
+				resource_size(iores));
+		if (!sys_base)
+			return -ENOMEM;
+		rev = readl(sys_base + SYS_EFUSE_DEVICE_CFG_STATUS0);
+		devm_iounmap(&pdev->dev, sys_base);
+		priv->ngpio = (rev & 0xf0) ? 44 : 57;
+	case PRID_IMP_NETLOGIC_XLP2XX:
+		if (priv->prid == PRID_IMP_NETLOGIC_XLP2XX)
+			priv->ngpio = 42;
 		priv->gpio_output_enbl = GPIO_OUTPUT_EN;
 		priv->gpio_paddrv = GPIO_PADDRV;
 		priv->gpio_padsmpl = GPIO_PADSMPL;
@@ -315,8 +290,8 @@ static int xlp_gpio_probe(struct platform_device *pdev)
 		priv->intr_enable_reg = GPIO_3XX_INT_EN00;
 		break;
 	case PRID_IMP_NETLOGIC_XLP9XX:
-		gc->ngpio = 66;
-		priv->ngpio = gc->ngpio;
+	case PRID_IMP_NETLOGIC_XLP5XX:
+		priv->ngpio = 66;
 		priv->gpio_output_enbl = GPIO_9XX_OUTPUT_EN;
 		priv->gpio_paddrv = GPIO_9XX_PADDRV;
 		priv->gpio_padsmpl = GPIO_9XX_PADSMPL;
@@ -330,19 +305,37 @@ static int xlp_gpio_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
-	gc->base = -1;
-	gc->dev = &pdev->dev;
-	gc->of_node = pdev->dev.of_node;
-	gc->direction_output = xlp_gpio_dir_output;
-	gc->direction_input = xlp_gpio_dir_input;
-	gc->set = xlp_gpio_set;
-	gc->get = xlp_gpio_get;
-	gc->owner = THIS_MODULE;
+	pr_info("Node %d: registering %d XLP GPIOs\n", node, priv->ngpio);
+
+	idx = priv->ngpio / 32 + ((priv->ngpio % 32) ? 1 : 0);
 
-	spin_lock_init(&priv->spin_lock);
-	pr_info("Node %d: registering %d XLP GPIOs\n", node, gc->ngpio);
-	if (gpiochip_add(gc) < 0)
-		return -EINVAL;
+	for (i = 0; i < idx; i++) {
+		reg_off = i * 4;
+		if (i > (BGPIO_MAX - 1)) {
+			pr_warn("Too many GPIOs!!\n");
+			break;
+		}
+		ret = bgpio_init(&priv->bgc[i], &pdev->dev, 4,
+			priv->gpio_base + priv->gpio_padsmpl + reg_off,
+			priv->gpio_base + priv->gpio_paddrv + reg_off, NULL,
+			priv->gpio_base + priv->gpio_output_enbl + reg_off,
+			NULL, 0);
+		if (ret < 0) {
+			pr_info("%s bgpio_init failed!\n", __func__);
+			return ret;
+		}
+
+		priv->bgc[i].gc.base = i * 32;
+		priv->bgc[i].gc.label = "gpio-xlp";
+		priv->bgc[i].gc.ngpio = ((i + 1) < idx) ? 32 :
+						priv->ngpio - (i * 32);
+		priv->bgc[i].gc.of_node = pdev->dev.of_node;
+		priv->bgc[i].gc.owner = THIS_MODULE;
+
+		spin_lock_init(&priv->spin_lock);
+		if (gpiochip_add(&priv->bgc[i].gc) < 0)
+			return -EINVAL;
+	}
 
 	ret = devm_request_irq(&pdev->dev, gpio_irq, xlp_gpio_generic_handler,
 			0, pdev->name, priv);
@@ -355,17 +348,17 @@ static int xlp_gpio_probe(struct platform_device *pdev)
 
 	/* Map gpio irqs from NLM_GPIO_VEC_BASE + (node * node_base_irq) */
 	irq_base = irq_alloc_descs(-1,
-		nlm_irq_to_xirq(node, NLM_GPIO_VEC_BASE), gc->ngpio, 0);
+		(node * NR_IRQS_PER_NODE + NLM_GPIO_VEC_BASE), priv->ngpio, 0);
 	if (irq_base < 0) {
 		dev_err(&pdev->dev, "Couldn't allocate IRQ numbers\n");
 		return -ENODEV;
 	}
 
 	priv->domain = irq_domain_add_legacy(pdev->dev.of_node,
-			gc->ngpio, irq_base, 0,
+			priv->ngpio, irq_base, 0,
 			&irq_domain_simple_ops, NULL);
 
-	for (g_pin = 0; g_pin < gc->ngpio; g_pin++) {
+	for (g_pin = 0; g_pin < priv->ngpio; g_pin++) {
 		irq_set_chip_and_handler(irq_base + g_pin, &xlp_gpio_irq_chip,
 				handle_level_irq);
 		irq_set_chip_data(irq_base + g_pin, priv);
-- 
1.9.1

