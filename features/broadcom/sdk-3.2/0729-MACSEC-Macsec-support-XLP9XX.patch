From 4261b4ea0bc7664f25a3ad1e45393da6d4830949 Mon Sep 17 00:00:00 2001
From: Alok Agrawat <alok@broadcom.com>
Date: Tue, 18 Jun 2013 18:16:13 -0700
Subject: [PATCH 0729/1532] MACSEC: Macsec support XLP9XX

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/netlib/include/netsoc_dev.h |  4 +-
 arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c     | 14 ++++-
 arch/mips/netlogic/lib/netlib/src/netsoc_nae.c     | 68 +++++++++++++++++-----
 3 files changed, 69 insertions(+), 17 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
index e6a4a9a..0cdcdc5 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
@@ -297,11 +297,13 @@ RX_MSEC_SCI_MASK6_LO         	= 0x417,
 RX_MSEC_SCI_MASK6_HI         	= 0x418,
 RX_MSEC_SCI_MASK7_LO         	= 0x419,
 RX_MSEC_SCI_MASK7_HI		= 0x41a,
-
+RX_MSEC_SEC_TAG2		= 0x409,
 };
 
 #define RX_MSEC_SCI_MASK_LO(i) (0x40b + i *2)
 #define RX_MSEC_SCI_MASK_HI(i) (0x40c + i *2)
+#define RX_MSEC_SCI_MASK_LO_9xx(i) (0x40c + i *2)
+#define RX_MSEC_SCI_MASK_HI_9xx(i) (0x40d + i *2)
 
 /*
  *  POE
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index 1465d88..a1afad3 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -909,7 +909,11 @@ static void extract_complex_params(void *fdt, int intf_type, char *nae_port_str,
 
         if (GET_PORT_PROP("msec-port-enable",&cmplx->msec_port_enable, sizeof(cmplx->msec_port_enable)) < 0) {
 		for(i=0; i<sizeof(cmplx->msec_port_enable)/sizeof(uint32_t); i++)
+		{
 			cmplx->msec_port_enable[i] = get_msec_port_enable(intf_type);
+printk("%s  cmplx->msec_port_enable[i] = %x\n", __FUNCTION__,  cmplx->msec_port_enable[i]);
+		}	
+		
 	}
 
         if (GET_PORT_PROP("submode",&cmplx->rxaui_submode, sizeof(cmplx->rxaui_submode)) < 0) {
@@ -969,6 +973,7 @@ static void extract_complex_params(void *fdt, int intf_type, char *nae_port_str,
 	netsoc_api_print(NETSOC_APIDBG_FDT,"Extracted complex configuration\n");
 }
 
+#define MACSEC_DEBUG 1
 
 static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
 {
@@ -1117,16 +1122,18 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
 
                 num_ports = get_num_ports(block, intf_type);
                 extract_complex_params(fdt, intf_type, nae_port_str, &cmplx_cfg);
+printk("%s cmplx_cfg.msec_port_enable = %x\n",__FUNCTION__, cmplx_cfg.msec_port_enable);
 
                 if(intf_type == XAUI_IF || intf_type == RXAUI_IF)
                 {
  //                       if(cmplx_cfg.msec_port_enable)
-   //                             nae_cfg->msec_port_enable |=  0xf << (4 * block);
+                                nae_cfg->msec_port_enable |=  0xf << (4 * block);
                         nae_cfg->higig_mode[block]=cmplx_cfg.higig_mode;
                         nae_cfg->xgmii_speed[block]=cmplx_cfg.xgmii_speed;
                 }
                 else{
-    //                    nae_cfg->msec_port_enable |= cmplx_cfg.msec_port_enable << (4 * block);
+                        //nae_cfg->msec_port_enable |= cmplx_cfg.msec_port_enable << (4 * block);
+                        nae_cfg->msec_port_enable |= 0xf << (4 * block);
                         nae_cfg->higig_mode[block]=0;
                         nae_cfg->xgmii_speed[block]=1; /*1G SGMII*/
                 }
@@ -1150,7 +1157,8 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
                         nae_port->ext_phy_bus = cmplx_cfg.ext_phy_bus[offset];
                         nae_port->loopback = cmplx_cfg.loopback[offset];
                         nae_port->rxaui_mode = cmplx_cfg.rxaui_submode[offset];;
-                        nae_port->msec_enable = cmplx_cfg.msec_port_enable[offset];;
+                        //nae_port->msec_enable = cmplx_cfg.msec_port_enable[offset];;
+                        nae_port->msec_enable = 1;
 
                         if (is_nlm_xlp9xx()|| is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
                                 nae_port->ext_phy_bus = 0;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 7556592..39a2647 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -3020,19 +3020,20 @@ void __netsoc_msec_tx_mem_config(nae_t *nae, int context, int tci, uint64_t sci,
 
 void __netsoc_msec_tx_config(nae_t *nae, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int pn_thrshld)
 {
-	unsigned int sec_tag_offset[2], i = 0, port = 0, param, icv_len = 16, sectag_len = 0x8;
+	unsigned int sec_tag_offset[3], i = 0, port = 0, param, icv_len = 16, sectag_len = 0x8, num_ports = 0;
 	uint64_t sec_tag_preamble;
         uint64_t nae_base = nae->nae_base;
 
 	sec_tag_offset[0] = 0x0c0c0c0c;
 	sec_tag_offset[1] = 0x0c0c0c0c;
+	sec_tag_offset[2] = 0x0c;
 #ifdef MACSEC_DEBUG
 	netsoc_api_print(NETSOC_APIDBG_TRACE, "%s node = %d port_enable = %x preamble_len = %x packet_num = %d pn_thrshld = %d\n", __FUNCTION__, nae->node, port_enable, preamble_len, packet_num, pn_thrshld);
 #endif
 	netsoc_write_nae_reg(nae_base, TX_MSEC_BYPASS, 0x0);
 	netsoc_write_nae_reg(nae_base, TX_MSEC_ETHER_TYPE, 0x88e5);
 	/* Enable port and pramble len for each port */
-	netsoc_write_nae_reg(nae_base, TX_MSEC_PORT_EN, port_enable & 0xff);
+	netsoc_write_nae_reg(nae_base, TX_MSEC_PORT_EN, port_enable & 0x1ff);
 
 
 	netsoc_write_nae_reg(nae_base, TX_MSEC_INIT_PN, packet_num);
@@ -3050,7 +3051,13 @@ void __netsoc_msec_tx_config(nae_t *nae, unsigned int port_enable, unsigned int
 	}
 	sec_tag_preamble = ((uint64_t)(sec_tag_offset[1]) << 32) | sec_tag_offset[0];
 
-	for(i = 0; i < 8/*Num_ports*/;i++)
+	if(is_nlm_xlp9xx())
+               num_ports = 9;
+        else
+               num_ports = 8;
+       
+	//for(i = 0; i < 8/*Num_ports*/;i++)
+        for(i = 0; i < num_ports;i++) 
 	{
 		nae->sectag_offset[i] = (sec_tag_offset[i/4] >> (i *8)) &0xff;
 		nae->icv_len[i] = icv_len;
@@ -3064,7 +3071,8 @@ void __netsoc_msec_tx_config(nae_t *nae, unsigned int port_enable, unsigned int
 	{
 		if(port_enable & 0x1)
 		{
-			param = ((sec_tag_preamble >> (port * 8)) & 0xff) << 16 | (((sec_tag_preamble >>(port * 8)) & 0xff) + sectag_len) << 8 | icv_len;
+		//	param = ((sec_tag_preamble >> (port * 8)) & 0xff) << 16 | (((sec_tag_preamble >>(port * 8)) & 0xff) + sectag_len) << 8 | icv_len;
+ 			param = ((sec_tag_offset[port/4] >> ((port%4) * 8)) & 0xff) << 16 | (((sec_tag_offset[port/4] >>((port%4) * 8)) & 0xff) + sectag_len) << 8 | icv_len;
 			__netsoc_msec_set_tx_param(nae, port, param);
 #ifdef MACSEC_DEBUG
         		netsoc_api_print(NETSOC_APIDBG_TRACE, "%s param = %x\n", __FUNCTION__, param);
@@ -3177,11 +3185,22 @@ void __netsoc_msec_set_rx_cam(nae_t *nae, int index, int port_num, uint64_t sci,
 	
 	netsoc_write_nae_reg(nae_base, RX_MSEC_MEM_DATAREG_0, sci & 0xffffffff);
 	netsoc_write_nae_reg(nae_base, RX_MSEC_MEM_DATAREG_1, (sci>>32) & 0xffffffff);
-	netsoc_write_nae_reg(nae_base, RX_MSEC_MEM_DATAREG_2, (port_num & 0x7)|0x0000);
+ 	if(is_nlm_xlp9xx())
+ 		netsoc_write_nae_reg(nae_base, RX_MSEC_MEM_DATAREG_2, (port_num & 0x7)|0x0000);
+ 	else
+ 		netsoc_write_nae_reg(nae_base, RX_MSEC_MEM_DATAREG_2, (port_num & 0xf)|0x0000ffff);
 
 	netsoc_write_nae_reg(nae_base, RX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
-	netsoc_write_nae_reg(nae_base, RX_MSEC_SCI_MASK_LO(port_num), sci_mask & 0xffffffff);
-	netsoc_write_nae_reg(nae_base, RX_MSEC_SCI_MASK_HI(port_num), (sci_mask >> 32) & 0xffffffff);
+ 	if(is_nlm_xlp9xx())
+ 	{
+ 		netsoc_write_nae_reg(nae_base, RX_MSEC_SCI_MASK_LO(port_num), sci_mask & 0xffffffff);
+ 		netsoc_write_nae_reg(nae_base, RX_MSEC_SCI_MASK_HI(port_num), (sci_mask >> 32) & 0xffffffff);
+ 	}
+ 	else
+ 	{
+ 		netsoc_write_nae_reg(nae_base, RX_MSEC_SCI_MASK_LO(port_num), sci_mask & 0xffffffff);
+ 		netsoc_write_nae_reg(nae_base, RX_MSEC_SCI_MASK_HI(port_num), (sci_mask >> 32) & 0xffffffff);
+ 	}
 }
 
 unsigned int __netsoc_msec_get_rx_cam(nae_t *nae, int index)
@@ -3344,19 +3363,20 @@ static void dump_rx_mem_config(nae_t *nae)
  
 void __netsoc_msec_rx_config(nae_t *nae, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int replay_win_size)
 {
-	unsigned int sec_tag_offset[2], i = 0, port, param;
+	unsigned int sec_tag_offset[3], i = 0, port, param;
 	uint64_t sec_tag_preamble;
         uint64_t nae_base = nae->nae_base;
 
 	sec_tag_offset[0] = 0x0c0c0c0c;
 	sec_tag_offset[1] = 0x0c0c0c0c;
+ 	sec_tag_offset[2] = 0x0c;
 #ifdef MACSEC_DEBUG
         netsoc_api_print(NETSOC_APIDBG_TRACE, "%s node = %d, port_enable = %x, preamble_len = %x, packet_num = %x, replay_win_size = %d\n", __FUNCTION__, nae->node, port_enable, preamble_len, packet_num, replay_win_size);
 #endif
-	/* Anti reply mode is not working. Always bypass anti reply check*/
+ 	/* Anti reply mode is not working. Always bypass anti reply check*/ /* TBD- add code for ICV removal */
 	netsoc_write_nae_reg(nae_base, RX_MSEC_BYPASS, 0x2);
 	/* Enable port and pramble len for each port */
-	netsoc_write_nae_reg(nae_base, RX_MSEC_PORT_EN, (preamble_len | port_enable) & 0xffffff);
+ 	netsoc_write_nae_reg(nae_base, RX_MSEC_PORT_EN, (preamble_len | port_enable) & 0x7ffffff);
 
 	while(preamble_len)
 	{	
@@ -3371,8 +3391,19 @@ void __netsoc_msec_rx_config(nae_t *nae, unsigned int port_enable, unsigned int
 	netsoc_write_nae_reg(nae_base, RX_MSEC_SEC_TAG0, sec_tag_offset[0]);
 	netsoc_write_nae_reg(nae_base, RX_MSEC_SEC_TAG1, sec_tag_offset[1]);
 
-	netsoc_write_nae_reg(nae_base, RX_MSEC_INIT_PN, packet_num);
-	netsoc_write_nae_reg(nae_base, RX_MSEC_REPLAY_WIN_SIZE, replay_win_size);
+ 	if(is_nlm_xlp9xx())
+ 	{
+ 		netsoc_write_nae_reg(nae_base, RX_MSEC_SEC_TAG2, sec_tag_offset[2]);
+ 		netsoc_write_nae_reg(nae_base, RX_MSEC_INIT_PN + 1, packet_num);
+ 		netsoc_write_nae_reg(nae_base, RX_MSEC_REPLAY_WIN_SIZE + 1, replay_win_size);
+ 		//sec_tag_preamble = (((uint64_t)sec_tag_offset[1]) << 64) | (((uint64_t)sec_tag_offset[1]) << 32) | sec_tag_offset[0];
+ 	}
+ 	else
+ 	{
+ 		netsoc_write_nae_reg(nae_base, RX_MSEC_INIT_PN, packet_num);
+ 		netsoc_write_nae_reg(nae_base, RX_MSEC_REPLAY_WIN_SIZE, replay_win_size);
+ 		//sec_tag_preamble = (((uint64_t)sec_tag_offset[1]) << 32) | sec_tag_offset[0];
+ 	}
 
 	sec_tag_preamble = (((uint64_t)sec_tag_offset[1]) << 32) | sec_tag_offset[0];
 
@@ -3382,7 +3413,8 @@ void __netsoc_msec_rx_config(nae_t *nae, unsigned int port_enable, unsigned int
 		if(port_enable & 0x1)
 		{
 			/* ci offset = sectag_preamble + 16 (sectag header length)*/
-			param = (((sec_tag_preamble >> (port * 8)) & 0xff) + 8/*16*/) << 8 | 0x10;
+		//	param = (((sec_tag_preamble >> (port * 8)) & 0xff) + 8/*16*/) << 8 | 0x10;
+ 			param = (((sec_tag_offset[port/4] >> ((port%4) * 8)) & 0xff) + 8/*16*/) << 8 | 0x10;
 			
 #ifdef MACSEC_DEBUG
 			netsoc_api_print(NETSOC_APIDBG_TRACE, "%s param = %x\n", __FUNCTION__, param);
@@ -3827,6 +3859,16 @@ int __netsoc_init_nae(nae_t *nae)
                       __netsoc_config_ale_enable(nae);
                 else 
                       __netsoc_config_ale_disable(nae);
+
+		printk("%s %d nae->msec_port_enable = %d\n",__FUNCTION__, __LINE__, nae->msec_port_enable);
+ 
+ 		if((is_nlm_xlp9xx() | is_nlm_xlp2xx()) && nae->msec_port_enable)
+ 		{
+ 			__netsoc_msec_tx_default_config(nae,/* port_enable0xff*/nae->msec_port_enable, /*unsigned int preamble_len*//*0x5555*/0, /*packet_num*/ 0x1, /*pn_thrshld*/0x7fffffff);
+                         __netsoc_msec_rx_default_config(nae, /*port_enable0xff*/nae->msec_port_enable, /*preamble_len*//*0xaaaa*/0, /*packet_num*/0x1, /*replay_win_size*/0x64);
+                 }
+                 else
+                         nae->msec_port_enable = 0;
 	}
 	return NETSOC_API_SUCCESS;
 }
-- 
1.9.1

