From 7f0d230a938e54a056b16b34fbb33979d088da82 Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikas.gupta@broadcom.com>
Date: Fri, 17 Jan 2014 22:42:54 +0530
Subject: [PATCH 0880/1532] xlp9xx-nae: Added KR/KR4 auto negotiation support.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../netlogic/lib/netlib/include/netsoc_common.h    |   17 +
 arch/mips/netlogic/lib/netlib/include/netsoc_dev.h |   55 ++
 .../netlogic/lib/netlib/include/netsoc_haliface.h  |   11 +
 arch/mips/netlogic/lib/netlib/include/netsoc_nae.h |   30 +
 .../mips/netlogic/lib/netlib/include/nlm_hal_nae.h |    1 +
 arch/mips/netlogic/lib/netlib/include/nlm_nae.h    |   18 +
 arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c     |   31 +
 arch/mips/netlogic/lib/netlib/src/netsoc_nae.c     |   37 +-
 arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c     | 1043 +++++++++++++++++++-
 9 files changed, 1226 insertions(+), 17 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
index 4b3076d..18acc3e 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
@@ -477,4 +477,21 @@ static inline int get_intf_hw_port_id(int block, int intf_type, int offset)
 		return (base_blk_id + offset);	
 }
 
+static inline int get_phy_mode(nae_t* nae, int block)
+{
+	block = 1<<block;
+	if(nae->sgmii_complex_map & block)
+		return PHYMODE_SGMII;
+	if(nae->xaui_complex_map & block)
+		return PHYMODE_XAUI;
+	if(nae->rxaui_complex_map & block)
+		return PHYMODE_RXAUI;
+	if(nae->xfi_complex_map & block)
+		return PHYMODE_XFI;
+	if(nae->xlgmac_complex_map & block)
+		return PHYMODE_XLAUI;
+	if(nae->ilk_complex_map & block)
+		return PHYMODE_IL;
+	return 0;
+}
 #endif
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
index 52a53f3..eae0fc6 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
@@ -193,9 +193,15 @@ enum xaui_cfg_regs {
 //
 enum netior_regs {
 	NETIOR_SOFTRESET = 3,
+	NETIOR_INT0 = 0x33,
+	NETIOR_INT0_MASK = 0x34,
+	NETIOR_INT1 = 0x35,
+	NETIOR_INT1_MASK = 0x36,
 	NETIOR_MISC_REG1_ADDR = 0x39,
 	NETIOR_MISC_REG2_ADDR = 0x3a,
 	NETIOR_MISC_REG3_ADDR = 0x3d,
+	NETIOR_INT2 = 0x3B,
+	NETIOR_INT2_MASK = 0x3C
 
 };
 enum NAE_TX_TYPE {
@@ -1170,6 +1176,55 @@ enum {
 #define XLAUI_CBFC_PAUSE_RECEIVED_0       0x1d8
 #define XLAUI_MAC_CTL_FRAME_TRANSMITTED   0x218
 #define XLAUI_MAC_CTL_FRAME_RECEIVED      0x220
+/*KR/KR4 related registers*/
+#define KR_CMD                           0x10
+#define KR_DATA                          0x11
+#define KR_CTRL                          0x12
+#define KR_STATUS                        0x13
+
+	#define KR_RX_CLK_EN            (1<<4)
+	#define KR_TX_CLK_EN            (1<<5)
+	#define KR_PHY_STATUS           (1<<6)
+	#define KR_UNBYPASS             (1<<7)
+	#define KR_CMD_PENDING          (1<<31)
+//Indirect registers for backplane autonegotiation
+//KR AN registers
+#define KXAN_CONTROL                0x00
+#define KXAN_STATUS                 0x01
+#define KXAN_ABILITY_0              0x02
+#define KXAN_ABILITY_1              0x03
+#define KXAN_ABILITY_2              0x04
+#define KXAN_REM_ABILITY_0          0x05
+#define KXAN_REM_ABILITY_1          0x06
+#define KXAN_REM_ABILITY_2          0x07
+#define KXAN_MS_COUNT               0x08
+#define AN_XNP_0                    0x09
+#define AN_XNP_1                    0x0a
+#define AN_XNP_2                    0x0b
+#define LP_AN_XNP_0                 0x0c
+#define LP_AN_XNP_1                 0x0d
+#define LP_AN_XNP_2                 0x0e
+#define BP_ETH_STATUS               0x0f
+//LT and FEC registers
+#define KR_PMD_CONTROL              0x100
+#define KR_PMD_STATUS               0x101
+#define KR_LP_COEFF                 0x102
+#define KR_LP_STAT                  0x103
+#define KR_LD_COEFF                 0x104
+#define KR_LD_STAT                  0x105
+#define FEC_CERR_CNT0               0x109
+#define FEC_CERR_CNT1               0x10a
+#define FEC_NCERR_CNT0              0x10b
+#define FEC_NCERR_CNT1              0x10c
+//XLAUI FEC registers for lane0
+#define XLAUI_FEC_ABILITY           0xC0
+#define XLAUI_FEC_CONTROL           0xC1
+#define XLAUI_FEC_STATUS            0xC2
+#define XLAUI_FEC_CERR_CNT_0        0xC3
+#define XLAUI_FEC_CERR_CNT_1        0xC4
+#define XLAUI_FEC_NCERR_CNT_0       0xC5
+#define XLAUI_FEC_NCERR_CNT_1       0xC6
+
 
 
 #endif /*__ASSEMBLY__*/
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
index 09baa0b..04b01fd 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
@@ -80,10 +80,21 @@ extern int __netsoc_init_ucore(nae_t *nae);
 extern int __netsoc_init_nae(nae_t *nae);
 extern int __netsoc_init_poe(poe_t *poe);
 
+extern void __netsoc_setup_bkpl_link_training(nae_t *nae, uint32_t block, uint32_t lane_no);
+extern void __netsoc_clause_173_enable(nae_t *nae, uint32_t block, uint32_t lane_no);
+extern void __netsoc_perform_clause_173_base_page(nae_t *nae, uint32_t block, uint32_t lane_no);
+extern void __netsoc_clause_173_next_page(nae_t *nae, uint32_t block, uint32_t lane_no);
+extern void __netsoc_perform_clause_173_next_page(nae_t *nae, uint32_t block, uint32_t lane_no);
+extern void __netsoc_enable_bkpl_link_training(nae_t *nae, uint32_t block, uint32_t lane_no);
+extern void __netsoc_bkpl_link_device_training(nae_t *nae, uint32_t block, uint32_t lane_no);
+extern void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t lane_no);
+extern void __netsoc_bkpl_auneg_complete(nae_t *nae, uint32_t block, uint32_t lane_no);
+
 extern void __netsoc_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask);
 extern void __netsoc_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phymode);
 extern void __netsoc_xfi_pcs_init(nae_t *nae, uint32_t xfi_cplx_mask, uint32_t phymode);
 extern void __netsoc_xlaui_pcs_init(nae_t *nae, uint32_t xlaui_cplx_mask, uint32_t phymode);
+extern void __netsoc_bkpl_ether_init(nae_t *nae);
 extern int __netsoc_interlaken_pcs_init(nae_t *nae, uint32_t ilk_complex_map);
 extern int register_marvell_phy(void);
 extern int register_broadcom_phy(void);
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
index 74a4bdf..dfdbf04 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
@@ -246,6 +246,36 @@ static int __netsoc_pma2p0_cmd_poll_pend(uint64_t mac_base)
         return (pma2p0_cmd&0xff);
 }
 
+static inline void __netsoc_write_kr_reg(uint64_t mac_base, uint32_t lane_no, uint32_t addr, uint32_t data)
+{
+	volatile uint32_t tmp_data, cmd_data;
+
+	netsoc_write_mac_reg(mac_base, KR_DATA, data & 0xFFFF);
+	cmd_data = (0x0 << 29) | (0x1 << 30) | ((addr + (lane_no * 0x10)) & 0x1FF);
+	netsoc_write_mac_reg(mac_base, KR_CMD, cmd_data);
+	tmp_data = netsoc_read_mac_reg(mac_base, KR_CMD);
+	while ((tmp_data & KR_CMD_PENDING) == KR_CMD_PENDING) {
+		tmp_data = netsoc_read_mac_reg(mac_base, KR_CMD);
+	}
+
+}
+
+static inline uint32_t __netsoc_read_kr_reg(uint64_t mac_base, uint32_t lane_no, uint32_t addr)
+{
+	volatile uint32_t cmd_data;
+	uint32_t data;
+
+	addr &= 0x1FF; 
+	cmd_data = (0x1 << 29) | (0x1 << 30) | (addr + (lane_no * 0x10));
+	netsoc_write_mac_reg(mac_base, KR_CMD, cmd_data);	
+	cmd_data = KR_CMD_PENDING; 
+	while ((cmd_data & KR_CMD_PENDING) == KR_CMD_PENDING) {
+		cmd_data = netsoc_read_mac_reg(mac_base, KR_CMD);
+	}
+	data = netsoc_read_mac_reg(mac_base, KR_DATA);
+	return (data & 0xFFFF);
+}
+
 static inline void __netsoc_write_pma2p0_reg(uint64_t base, uint32_t lane_no, uint32_t addr, uint32_t data)
 {
     uint32_t tmp_data;
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
index 3e58996..f627645 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
@@ -136,6 +136,7 @@ struct nae_complex_config {
 	uint32_t higig_mode;
 	uint32_t xgmii_speed;
 	uint32_t vlan_pri_en[MAX_PORTS_PERBLOCK];
+	bkpl_ether_t bkpl_cfg;
 	//uint32_t msec_port_enable[MAX_PORTS_PERBLOCK];
 	uint32_t msec_port_enable;
 	uint32_t rxaui_submode[MAX_PORTS_PERBLOCK];
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
index aa40503..b4322d5 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -188,6 +188,23 @@ typedef enum{
         L2_PROTO_FIXEDHDR = 2,
 }l2_proto_t;
 
+typedef enum {
+	BKPL_TYPE_NONE,
+	BKPL_TYPE_KR,
+	BKPL_TYPE_KR4,
+} kr_type_t; 
+
+typedef struct{
+	uint32_t kr_en; 
+	uint32_t kr_lpbk;
+	uint32_t auto_neg_en;
+	uint32_t next_page_an;
+	uint32_t message_page;	
+	uint32_t link_training_enable;
+	uint32_t read_rem_ability_registers;
+
+}bkpl_ether_t;
+
 typedef struct {
         uint32_t l2_extract_len;  /* Layer 2 Extract length */
         uint32_t l2_extract_off;  /* Layer 2 Extract offset */
@@ -357,6 +374,7 @@ struct nlm_hal_nae_config {
 	uint32_t xaui_complex_map;
 	uint32_t higig_mode[MAX_NAE_CPLX_PER_NODE];
 	uint32_t xgmii_speed[MAX_NAE_CPLX_PER_NODE];
+	bkpl_ether_t bkpl_cfg[MAX_NAE_CPLX_PER_NODE];
 	uint32_t rxaui_complex_map;
 	uint32_t xfi_complex_map;
 	uint32_t xlgmac_complex_map;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index 159c0db..6429fbd 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -814,6 +814,27 @@ static void extract_complex_params(void *fdt, int intf_type, char *nae_port_str,
         if (GET_PORT_PROP("xgmii-speed",&cmplx->xgmii_speed, sizeof(cmplx->xgmii_speed)) < 0) {
 			cmplx->xgmii_speed = get_xgmii_speed(intf_type);
 	}
+        if (GET_PORT_PROP("kr-en",&cmplx->bkpl_cfg.kr_en, sizeof(cmplx->bkpl_cfg.kr_en)) < 0) {
+		cmplx->bkpl_cfg.kr_en = 0;	
+	}
+        if (GET_PORT_PROP("kr-lpbk",&cmplx->bkpl_cfg.kr_lpbk, sizeof(cmplx->bkpl_cfg.kr_lpbk)) < 0) {
+		cmplx->bkpl_cfg.kr_lpbk = 0;	
+	}
+        if (GET_PORT_PROP("auto-neg-en",&cmplx->bkpl_cfg.auto_neg_en, sizeof(cmplx->bkpl_cfg.auto_neg_en)) < 0) {
+		cmplx->bkpl_cfg.auto_neg_en = 0;	
+	}
+        if (GET_PORT_PROP("next-page-en",&cmplx->bkpl_cfg.next_page_an, sizeof(cmplx->bkpl_cfg.next_page_an)) < 0) {
+		cmplx->bkpl_cfg.next_page_an = 0;	
+	}
+        if (GET_PORT_PROP("message-page",&cmplx->bkpl_cfg.message_page, sizeof(cmplx->bkpl_cfg.message_page)) < 0) {
+		cmplx->bkpl_cfg.message_page = 0;	
+	}
+        if (GET_PORT_PROP("link-training-enable",&cmplx->bkpl_cfg.link_training_enable, sizeof(cmplx->bkpl_cfg.link_training_enable)) < 0) {
+		cmplx->bkpl_cfg.link_training_enable = 0;	
+	}
+        if (GET_PORT_PROP("read-rem-ability-registers",&cmplx->bkpl_cfg.read_rem_ability_registers, sizeof(cmplx->bkpl_cfg.read_rem_ability_registers)) < 0) {
+		cmplx->bkpl_cfg.read_rem_ability_registers= 0;	
+	}
 
         GET_PORT_PROP("msec-port-enable",&cmplx->msec_port_enable, sizeof(cmplx->msec_port_enable));
 
@@ -1037,6 +1058,16 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
                 num_ports = get_num_ports(block, intf_type);
                 extract_complex_params(fdt, intf_type, nae_port_str, &cmplx_cfg);
 
+                if(intf_type == XFI_IF || intf_type == XLAUI_IF)
+		{
+                        nae_cfg->bkpl_cfg[block].kr_en =cmplx_cfg.bkpl_cfg.kr_en;
+                        nae_cfg->bkpl_cfg[block].kr_lpbk =cmplx_cfg.bkpl_cfg.kr_lpbk;
+                        nae_cfg->bkpl_cfg[block].auto_neg_en =cmplx_cfg.bkpl_cfg.auto_neg_en;
+                        nae_cfg->bkpl_cfg[block].next_page_an =cmplx_cfg.bkpl_cfg.next_page_an;
+                        nae_cfg->bkpl_cfg[block].message_page =cmplx_cfg.bkpl_cfg.message_page;
+                        nae_cfg->bkpl_cfg[block].link_training_enable =cmplx_cfg.bkpl_cfg.link_training_enable;
+                        nae_cfg->bkpl_cfg[block].read_rem_ability_registers =cmplx_cfg.bkpl_cfg.read_rem_ability_registers;
+		}
                 if(intf_type == XAUI_IF || intf_type == RXAUI_IF)
                 {
                         if(cmplx_cfg.msec_port_enable)
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index a94ad39..657876f 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -1976,6 +1976,22 @@ void __netsoc_mdio_init(nae_t *nae)
 	nlm_mdelay(3);
 }
 
+#define XLGMAC_FEC_CRTL0_REG              0x304
+
+void __netsoc_xlgmac_fec_enable(net_port_t *netport)
+{
+	nae_t *nae = netport->nae;
+    	uint32_t lane_no;
+    	volatile uint32_t data;
+        uint64_t mac_base = netsoc_get_macreg_base_for_xlgmac(nae->mac_base, netport->hw_port_id);
+        for (lane_no=0; lane_no<4; lane_no++) {
+		data = __netsoc_read_xlgmac_reg(netport, XLGMAC_FEC_CRTL0_REG+(32*lane_no));
+            	data &= 0xfffffffc;
+	        data |= 0x3;
+        	__netsoc_write_xlgmac_reg(netport,  XLGMAC_FEC_CRTL0_REG+(32*lane_no), data);
+	}
+}
+
 void __netsoc_set_xlgmac_enable(net_port_t *netport)
 {
 	volatile uint32_t val;
@@ -2328,13 +2344,14 @@ static void __netsoc_config_xlgmac(net_port_t *netport)
 {
 	nae_t *nae = netport->nae;
         uint64_t mac_base = netsoc_get_macreg_base_for_xlgmac(nae->mac_base, netport->hw_port_id);
-
 	__netsoc_xlgmac_softreset(mac_base, 0x3);
 	__netsoc_xlgmac_softreset(mac_base, 0x0);
 	__netsoc_xlgmac_threshold(mac_base, 0xf);
+	//__netsoc_xlgmac_fec_enable(netport);
 	__netsoc_set_xlgmac_enable(netport);
 	__netsoc_set_xlgmac_pause_config(netport);
 
+
 	netsoc_api_print(NETSOC_APIDBG_PORT,"XLAUI Rd XLGMAC3_CTL : 0x%x\n",  netsoc_read_mac_reg(mac_base, XLGMAC3_CTL));
 	netsoc_api_print(NETSOC_APIDBG_PORT,"XLAUI Rd XLGMAC_STATUS : 0x%x\n",  netsoc_read_mac_reg(mac_base, XLGMAC_STATUS));
 	netsoc_api_print(NETSOC_APIDBG_PORT,"XLAUI Rd XLGMAC1_CTL : 0x%x\n",  netsoc_read_mac_reg(mac_base, XLGMAC1_CTL));
@@ -4208,6 +4225,9 @@ static uint32_t membar_fixup(uint32_t l)
 #define membar_fixup(x) (x)
 #endif
 
+extern void __netsoc_perform_clause_173_base_page(nae_t *nae, uint32_t block, uint32_t lane_no);
+extern void __netsoc_bkpl_auneg_complete(nae_t *nae, uint32_t block, uint32_t lane_no);
+//extern void enable_autoneg(nae_t* nae);
 int __netsoc_init_nae(nae_t *nae)
 {
 	uint64_t bar0;
@@ -4215,10 +4235,10 @@ int __netsoc_init_nae(nae_t *nae)
         int retval = 0, frin_q;
 
 	if (nae->owned) {
-		 	if(!is_nlm_xlp9xx()){
-				bar0 = netsoc_api_readl(nae->pcie_base, PCI_MEM_BAR_0);
-				bar0 = membar_fixup(bar0);
-	     	}
+		 if(!is_nlm_xlp9xx()){
+			bar0 = netsoc_api_readl(nae->pcie_base, PCI_MEM_BAR_0);
+			bar0 = membar_fixup(bar0);
+	   	}
         	/* frin_fifo represents the 20 pools of free-in descriptor fifos */
 	        __netsoc_drain_allfrin_fifo_descs(nae);
                 __netsoc_deflate_frin_fifo_carving(nae);
@@ -4230,9 +4250,9 @@ int __netsoc_init_nae(nae_t *nae)
                 __netsoc_reset_nae(nae);
                 nae->flags |= NAE_RESET_DONE;
 #endif
-				if(!is_nlm_xlp9xx()){
+		if(!is_nlm_xlp9xx()){
                 	nlm_hal_write_32bit_reg(nae->pcie_base, 0x4, bar0);
-				}
+		}
 		// Load ucore code
                 netsoc_api_print(NETSOC_APIDBG_GLOBAL, "Configuring ucore...\n");
                 __netsoc_init_ucore(nae);
@@ -4285,6 +4305,9 @@ int __netsoc_init_nae(nae_t *nae)
                 __netsoc_init_netior(nae);
 
 		__netsoc_init_all_ports(nae);
+		
+		if(is_nlm_xlp9xx())
+			__netsoc_bkpl_ether_init(nae); /*do KR/KR4 lane configuration*/	
 
 		if (nae->freein_uniq_sz) {
 		        for (frin_q = 0; frin_q < __netsoc_get_max_frinqs(); frin_q++) {
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
index 8977d2b..e68a283 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
@@ -38,6 +38,9 @@
 
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
 
+
+/*KR/KR4 related functions.*/
+
 void xlp2xx_nae_program_pma2p0(uint64_t mac_base, int block, int xaui_speed, int phy_mode)
 {
         uint32_t reg_addr, lane_no;
@@ -360,10 +363,11 @@ static void xlp9xx_lane_reset(nae_t *nae, int block, int lane_ctrl, int mode)
 	}	
 	val |= (mode << PHY_LANE_CTRL_PHYMODE_POS);
 	if(lane_ctrl != 0){ //TODO: Verify for XLP9XX
-        	netsoc_write_mac_reg(mac_base, lane_ctrl, val);
-        	val = netsoc_read_mac_reg(mac_base, lane_ctrl);
-        	netsoc_api_print(NETSOC_APIDBG_PORT,"%s Bit 20 reg reset removed val =0x%x\n",__func__, val);
-	}
+                netsoc_write_mac_reg(mac_base, lane_ctrl, val);
+                val = netsoc_read_mac_reg(mac_base, lane_ctrl);
+                netsoc_api_print(NETSOC_APIDBG_PORT,"%s Bit 20 reg reset removed val =0x%x\n",__func__, val);
+        }   
+
         if ((mode == PHYMODE_RXAUI) || (mode == PHYMODE_IL)) {
         	val = netsoc_read_mac_reg(mac_base, lane_ctrl);
 		val |= 1<<30;
@@ -602,7 +606,7 @@ static void vsemi_configure_loopback(uint64_t mac_base)
 	}
 }
 
-void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed, int phy_mode)
+void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed, int phy_mode, int kr_lpbk)
 {
         uint32_t reg_addr, lane_no, max_lanes =4;  
         uint32_t pma2p0_cmd=0;
@@ -714,10 +718,17 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 	
 	if((phy_mode == PHYMODE_XLAUI) || (phy_mode == PHYMODE_XFI) || (phy_mode == PHYMODE_IL)){ 
 		for (lane_no=0; lane_no<max_lanes; lane_no++) {
-			__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x15, 0xd9);
+			if (kr_lpbk)
+				__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x15, 0xdf);
+			else
+				__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x15, 0xd9);
+					
 			__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x16, 0x07);
-//			__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x1c, 0xc0);
-			__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x1c, 0x00);
+			if (kr_lpbk)
+				__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x1c, 0x50);
+			else
+				__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x1c, 0xc0);
+				
 			__netsoc_write_pma2p0_reg(mac_base, lane_no, 0x1b, 0x70);
              }
 	}
@@ -769,6 +780,7 @@ static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t pma
 	uint32_t delay, pma2p0_config;
 	uint64_t mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
         int lane_enable = 0;
+	nlm_print("xlp9xx_config_pma2p0_serdes phymode= 0x%x\n", phymode);
 
 	       	if(!pma2p0_por){
                         pma2p0_config = netsoc_read_mac_reg(netsoc_get_macreg_base_for_phy(nae->mac_base, 2), PMA2P0_CTL0);
@@ -817,7 +829,7 @@ static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t pma
 
                 netsoc_write_mac_reg(mac_base, PMA2P0_CTL1, pma2p0_config);
 
-                xlp9xx_nae_write_pma2p0_mem(mac_base, block, speed, phymode);
+                xlp9xx_nae_write_pma2p0_mem(mac_base, block, speed, phymode, nae->bkpl_cfg[block].kr_lpbk);
 #ifdef PMA2P0_DEBUG
 		__netsoc_display_pma2p0_indirect_reg(mac_base, block);	
 #endif
@@ -1450,7 +1462,7 @@ static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t ph
 #endif
                 }
         }
-
+		
 }
 
 static void xlp_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phymode)
@@ -1539,6 +1551,959 @@ static void xlp_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phym
 
 #endif
 
+void __netsoc_setup_bkpl_link_training(nae_t *nae, uint32_t block, uint32_t lane_no)
+{
+	volatile uint32_t rd_data;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+	rd_data  |= (0x0 << 0); // to push state machine into ( mr_trained ) remote training state
+	__netsoc_write_kr_reg(base, lane_no, KR_PMD_STATUS, rd_data);
+}
+
+void __netsoc_clause_173_enable(nae_t *nae, uint32_t block, uint32_t lane_no)
+{
+	volatile uint32_t data;
+	volatile uint32_t rd_data;
+	uint32_t port_no;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	uint32_t phymode = get_phy_mode(nae, block); 
+
+
+	//DEBUG: Read DME VSEMI register bit
+	//rd_data = read_vsemi_reg( lane_no, 0x28);
+	//nlm_print("DEBUG:PCSRX_DME_EN register value is 0x%x\n", rd_data);
+
+	//Step1:
+	//configure KR ability 0-1-2 registers
+	//ability 0
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_0);
+	//TODO; NEXT PAGE ENABLED
+	//if(nae->bkpl_cfg[block].next_page == 1) {
+		//rd_data |= (0x1 << 15); // Next Page 
+	//}
+	__netsoc_write_kr_reg(base, lane_no, KXAN_ABILITY_0, rd_data);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_0);
+	//nlm_print("AN_ABILITY0:  lane:%d value is 0x%x\n",  lane_no, rd_data);
+
+	//ability 1
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_1);
+	//if(block==0 && nae->nae_id==0) {
+	if(block==0) {
+		rd_data &= 0xFFE0; //Transmitted nonce [4:0]
+		rd_data |= 0x1F;
+	}  
+	if(block==1) {
+		rd_data &= 0xFFE0; //Transmitted nonce
+		rd_data |= 0x07;
+	}
+
+	if(phymode==PHYMODE_XFI){
+		rd_data |= (0x1 << 7); // technology ability is 10g-KR
+	}else if(phymode==PHYMODE_XLAUI){
+		rd_data |= (0x1 << 8) | (0x1 << 7) | (0x1 << 6) | (0x1 << 5);  
+	}
+	__netsoc_write_kr_reg(base, lane_no, KXAN_ABILITY_1, rd_data);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_1);
+	nlm_print("AN_ABILITY1:  lane:%d value is %x\n",  lane_no, rd_data);
+
+	//ability 2
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_2);
+	nlm_print("Data read from ability 2 is 0x%x\n", rd_data);
+	nlm_print("AN_ABILITY2: complex: %d: lane: %d value is %x\n",block, lane_no, rd_data);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
+	nlm_print("AN_STATUS: complex: %d lane :%d read value is %x\n",block, lane_no, rd_data);
+	__netsoc_write_kr_reg(base, lane_no, KXAN_MS_COUNT, 0xffff);
+
+	//Step2:
+	//Enable auto-negotiation
+	//enable the AN first
+	data = netsoc_read_mac_reg(base, KR_CTRL);
+	if((phymode==PHYMODE_XLAUI && lane_no==0) || (phymode==PHYMODE_XFI)){
+		data |= (0x1 << lane_no);
+		nlm_print("KR enabled for complex: %d lane 0\n", block, lane_no);
+	}
+
+	data &= (~0xF0); 
+	data |= (KR_PHY_STATUS | KR_UNBYPASS); 
+	netsoc_write_mac_reg(base, KR_CTRL, data);
+	data = netsoc_read_mac_reg(base, KR_CTRL);
+	
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_CONTROL);
+	if(nae->bkpl_cfg[block].kr_lpbk){
+		/*restart the AN on one of the block*/
+		if((block==1))  	
+			rd_data |= (0x1 << 9); // an-restart
+	}
+	rd_data |= (0x1 << 12); // an-enable
+	//TODO:next page
+	//if(netior_config.next_page_an == 1) {
+		//if(block==0) rd_data |= (0x1 << 13); // extended NP
+		//rd_data |= (0x1 << 13); // extended NP
+	//}
+	__netsoc_write_kr_reg(base, lane_no, KXAN_CONTROL, rd_data);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_CONTROL);
+	nlm_print(" AN_CONTROL:  lane:%d value is 0x%x\n",  lane_no, rd_data); 
+
+	//DEBUG: Read DME VSEMI register bit
+	//rd_data = read_vsemi_reg( lane_no, 0x28);
+	//nlm_print("DEBUG:PCSRX_DME_EN register value is 0x%x\n", rd_data);
+
+}
+
+void __netsoc_perform_clause_173_base_page(nae_t *nae, uint32_t block, uint32_t lane_no)
+{
+
+	volatile uint32_t rd_data;
+	uint32_t count=0;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	//Step3:
+	//check for base page exchange completion
+	//status register
+#if 0	
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_CONTROL);
+	if((block==1))  	
+		rd_data |= (0x1 << 9); // an-restart
+	__netsoc_write_kr_reg(base, lane_no, KXAN_CONTROL, rd_data);
+	return;
+#endif
+
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
+
+	while((rd_data & (1<<6)) == 0 ) {
+		nlm_print(" AN_STATUS: complex: %d lane: %d Waiting for base page exchange completion value:0x%x\n",block, lane_no, rd_data);
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
+		nlm_mdelay(10);
+		//if(count++ == 50) break; 
+	}
+	nlm_print(" AN_STATUS: complex: %d lane: %d Base page exchange completed value:0x%x\n",block, lane_no, rd_data);
+	//TODO:
+	//if(netior_config.read_rem_ability_registers == 1) {
+	//Read rem_ability registers:
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_REM_ABILITY_0);
+	nlm_print("AN_REM_ABILITY0: value is 0x%x\n",rd_data);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_REM_ABILITY_1);
+	nlm_print("AN_REM_ABILITY1: value is 0x%x\n",rd_data);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_REM_ABILITY_2);
+	nlm_print("AN_REM_ABILITY2: value is 0x%x\n",rd_data);
+	//}
+
+	//If remote device does not have AN capability, AN process will be stuck at this stage,timeout to be implemented in this state to exit - MTIP spec
+}
+
+void __netsoc_clause_173_next_page(nae_t *nae, uint32_t block, uint32_t lane_no)
+{
+
+	volatile uint32_t rd_data;
+	uint32_t count;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	//Step 4 (optional)
+	//configure NP ability registers
+	//ability 0
+	rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_0);
+	if(nae->bkpl_cfg[block].message_page == 1) {
+		rd_data |= (0x1 << 13); // set MP
+		rd_data &= 0xFFFFF800; //10:0 //Refer to NextPage Message code field definitions (IEEE Std 802.3-2005 Annex28C)
+		rd_data |= (0x1 << 0); 
+	} else {
+		rd_data |= (0x0 << 13); // set MP
+		rd_data &= 0xFFFFF800; //10:0 
+		rd_data |= (0xAB + block); 
+	}
+	rd_data |= (0x0 << 15); // Next page (XNP)
+	__netsoc_write_kr_reg(base, lane_no, AN_XNP_0, rd_data);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_0);
+	nlm_print("XNP_ABILITY0: complex: %d: lane: %d value is %x\n", block, lane_no, rd_data);
+
+	//ability 1
+	rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_1);
+	rd_data &= 0xFFFF0000;
+	rd_data |= ( 0xABCD + block) ;//15:0
+	__netsoc_write_kr_reg(base, lane_no, AN_XNP_1, rd_data);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_1);
+	nlm_print("XNP_ABILITY1: complex: %d: lane: %d value is %x\n", block, lane_no, rd_data);
+
+	//ability 2
+	rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_2);
+	rd_data &= 0xFFFF0000;
+	rd_data |= (0xBBBB + block);//15:0
+	__netsoc_write_kr_reg(base, lane_no, AN_XNP_2, rd_data);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_2);
+	nlm_print("XNP_ABILITY2: complex: %d: lane: %d value is %x\n", block, lane_no, rd_data);
+}
+
+void __netsoc_perform_clause_173_next_page(nae_t *nae, uint32_t block, uint32_t lane_no)
+{
+	volatile uint32_t rd_data;
+	uint32_t count;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	//check for next page exchange completion
+	//status register
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
+	// looping on status until an complete or page received
+	while((rd_data & (1<<6)) == 0 ) { 
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);;
+	}
+	nlm_print(" AN_STATUS: complex: %d: Next page exchange completed value:0x%x\n", block, rd_data);
+
+	//Read remote next page ability registers:
+	rd_data = __netsoc_read_kr_reg(base, lane_no, LP_AN_XNP_0);
+	nlm_print("AN_NP_REM_ABILITY0: value is %x\n", rd_data);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, LP_AN_XNP_1);
+	nlm_print("AN_NP_REM_ABILITY1: value is %x\n",rd_data);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, LP_AN_XNP_2);
+	nlm_print("AN_NP_REM_ABILITY2: value is %x\n",rd_data);
+
+	//disable XNP in control register
+	//control register
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_CONTROL);
+	rd_data |= (0x0 << 13); // extended NP
+	__netsoc_write_kr_reg(base, lane_no, KXAN_CONTROL,  rd_data);
+
+}
+
+#define BIT(n)  (1<<n)
+#define  bit_clear(data, n)  data &= ~(n)
+#define bit_set(data, n)     data |= (n)       
+# if 0
+void __netsoc_bkpl_write_pma2p0_txdriver_registers(nae_t *nae, uint32_t block, uint32_t lane_no) {
+	volatile uint32_t rd_data;
+	//Read TX DRV registers
+	// TXDRV_HLEV    21[2:0]    0 1 2 3  3'h7
+	// TXDRV_LEVN    21[7:3]    0 1 2 3  5'h1B
+	// TXDRV_LEVNM1  22[3:0]    0 1 2 3  4'h7
+	// TXDRV_LEVNM2  22[5:4]    0 1 2 3  2'h0
+	// TXDRV_LEVNP1  23[2:0]    0 1 2 3  3'h0
+	// TXDRV_SLEW    23[4:3]    0 1 2 3  2'h0
+	// TXDRV_LOCWREN 87[6:6]    0 1 2 3  
+	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 87);
+	bit_clear(rd_data, BIT(5)); 
+	__netsoc_write_pma2p0_reg(mac_base, lane_no, 87, rd_data);
+	__netsoc_write_pma2p0_reg(mac_base, lane_no, 21, 0xdf);
+	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 21);
+	nlm_print("write_vsemi_txdriver_registers:  lane:%d 21:0x%x\n",  lane_no, rd_data);
+	__netsoc_write_pma2p0_reg(mac_base, lane_no, 22, 0x7);
+	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 22);
+	nlm_print("write_vsemi_txdriver_registers:  lane:%d 22:0x%x\n",  lane_no, rd_data);
+	__netsoc_write_pma2p0_reg(mac_base, lane_no, 23, 0);
+	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 23);
+	nlm_print("write_vsemi_txdriver_registers:  lane:%d 23:0x%x\n",  lane_no, rd_data);
+
+}
+void __netsoc_bkpl_read_vsemi_rxequalization_registers(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t rd_data;
+	volatile uint32_t rxcaleq_dcgain, rxcaleq_dfepstapf3db, rxcaleq_dfepstapgain, rxcaleq_dfetap1gain, rxcaleq_dfetap2gain, rxcaleq_dfetap3gain, rxcaleq_dfetap4gain, rxcaleq_lofreqagcgain, rxcaleq_hifreqagccap, rxcaleq_locwren;
+
+	// RXCALEQ_DCGAIN         24[2:0]    0 1 2 3 3'h0 // 3'h2
+	// RXCALEQ_DFEPSTAPF3DB   24[5:3]    0 1 2 3 3'h0
+	// RXCALEQ_DFEPSTAPGAIN   25[2:0]    0 1 2 3 3'h0
+	// RXCALEQ_DFETAP1GAIN    25[6:3]    0 1 2 3 4'h0
+	// RXCALEQ_DFETAP2GAIN    26[3:0]    0 1 2 3 4'h8
+	// RXCALEQ_DFETAP3GAIN    26[7:4]    0 1 2 3 4'h0
+	// RXCALEQ_DFETAP4GAIN    27[3:0]    0 1 2 3 4'h8
+	// RXCALEQ_LOFREQAGCGAIN  27[6:4]    0 1 2 3 3'h7
+	// RXCALEQ_HIFREQAGCCAP   28[7:3]    0 1 2 3 5'h0
+	// RXCALEQ_LOCWREN        86[3:3]    0 1 2 3 1'b0
+	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 24);
+	rxcaleq_dcgain = (rd_data & 0x7);
+	rxcaleq_dfepstapf3db = ((rd_data >> 3) & 0x7);
+	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_DCGAIN=0x%x\n", rxcaleq_dcgain);
+	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_DFEPSTAPF3DB=0x%x\n", rxcaleq_dfepstapf3db);
+	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 25);
+	rxcaleq_dfepstapgain = (rd_data & 0x7);
+	rxcaleq_dfetap1gain = ((rd_data >> 3) & 0xF);
+	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_DFEPSTAPGAIN=0x%x\n", rxcaleq_dfepstapgain);
+	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_DFETAP1GAIN=0x%x\n", rxcaleq_dfetap1gain);
+	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 26);
+	rxcaleq_dfetap2gain = (rd_data & 0xF);
+	rxcaleq_dfetap3gain = ((rd_data >> 4) & 0xF);
+	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_DFETAP2GAIN=0x%x\n", rxcaleq_dfetap2gain);
+	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_DFETAP3GAIN=0x%x\n", rxcaleq_dfetap3gain);
+	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 27);
+	rxcaleq_dfetap4gain = (rd_data & 0xF);
+	rxcaleq_lofreqagcgain = ((rd_data >>4) & 0xF);
+	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_DFETAP4GAIN=0x%x\n", rxcaleq_dfetap4gain);
+	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_LOFREQAGCGAIN=0x%x\n", rxcaleq_lofreqagcgain);
+	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 28);
+	rxcaleq_hifreqagccap = ((rd_data >> 3) & 0x1F);
+	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_HIFREQAGCCAP=0x%x\n", rxcaleq_hifreqagccap);
+	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 86);
+	rxcaleq_locwren = ((rd_data & BIT(3)) >> 3) ;
+	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_LOCWREN=0x%x\n", rxcaleq_locwren);
+	bit_clear(rd_data, BIT(3));
+	__netsoc_write_pma2p0_reg(mac_base, lane_no, 86, rd_data);
+}
+
+#endif 
+static inline uint32_t mod(int32_t value){
+	volatile uint32_t mod_value;
+
+	if (value < 0) {
+		mod_value = -value;
+	} else {
+		mod_value = value;    
+	}
+	return(mod_value);
+}
+
+static inline uint32_t update_coefficient(uint32_t update, int32_t present_coeff)
+{
+	volatile int32_t updated_coeff;
+	uint32_t step = 1;
+
+	switch (update) {
+		case 0 : updated_coeff = present_coeff;        break;  
+		case 1 : updated_coeff = present_coeff + step; break;
+		case 2 : updated_coeff = present_coeff - step; break;
+	}
+	return(updated_coeff);
+}
+#if 0
+static inline void __netsoc_bkpl_wait_for_lt_done(uint64_t base, uint32_t lane_no)
+{
+	//wait for lt_done
+	nlm_print(" LINK_TRAINING: %d: Waiting for signal_detection signal to go high - lt_done\n",block);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+	while((rd_data & (1<<15)) == 0) { //signal detection - indicates training process is complete
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+	}
+	nlm_print("Wait for Link Training done\n");	
+}
+
+void __netsoc_bkpl_wait_for_lt_int(nae_t *nae, uint32_t block, uint32_t lane_no uint32_t update) { 
+	volatile uint32_t rd_data;
+	uint64_t cnt=0,cnt1=0;
+
+	uint64_t nae_base = netsoc_get_iface_base(nae->nae_base, 0xf);
+
+	if(block==1) {
+		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1_MASK);
+		rd_data |= (0x1 << 22); 
+		netsoc_write_nae_iface_reg(nae_base, NETIOR_INT1_MASK, rd_data);
+		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
+		while((rd_data & BIT(22)) == 0) {
+			rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
+		}  
+		nlm_print("wait_for_lt_int:  lane:%d NetiorINT1 interrupt status after polling value: 0x%x\n",  lane_no, rd_data);
+		rd_data |= (0x1 << 22); //write 1 to clear 
+		netsoc_write_nae_iface_reg(nae_base, NETIOR_INT1, rd_data);
+		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
+	}
+	if(block==0) {
+		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1_MASK);
+		rd_data |= (0x1 << 23); 
+		netsoc_write_nae_iface_reg(nae_base, NETIOR_INT1_MASK, rd_data);
+		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
+		while((rd_data & BIT(23)) == 0) {
+			rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
+		}  
+		nlm_print("wait_for_lt_int:  lane:%d NetiorINT1 interrupt status after polling value: 0x%x\n",  lane_no, rd_data);
+		rd_data |= (0x1 << 23); //write 1 to clear 
+		netsoc_write_nae_iface_reg(nae_base, NETIOR_INT1, rd_data);
+		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
+	}
+}
+
+#endif 
+
+void __netsoc_bkpl_enable_link_training(nae_t *nae, uint32_t block, uint32_t lane_no)
+{
+	volatile uint32_t rd_data;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	uint32_t phymode = get_phy_mode(nae, block); 
+
+	rd_data = __netsoc_read_kr_reg(base, lane_no, BP_ETH_STATUS);
+	if(phymode == PHYMODE_XLAUI) {
+		while((rd_data & (1<<5)) == 0) { //40GKR4
+			rd_data = __netsoc_read_kr_reg(base, lane_no, BP_ETH_STATUS);
+		}
+	} else if (phymode == PHYMODE_XFI) {
+		while((rd_data & (1<<3)) == 0) { //10GKR
+			rd_data = __netsoc_read_kr_reg(base, lane_no, BP_ETH_STATUS);
+		}
+	}
+	nlm_print(" complex: %d: lane: %d :AN_GOOD_CHECK state reached on DUT\n", block,lane_no);
+
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_CONTROL);
+	rd_data |= (0x1 << 0); // restart training
+	rd_data |= (0x1 << 1); // training enable
+	__netsoc_write_kr_reg(base, lane_no, KR_PMD_CONTROL,  rd_data);
+	nlm_print(" complex: %d: lane: %d :restart training and training enable set on DUT\n", block,lane_no);
+
+
+}
+
+static void __netsoc_bkpl_restart_link_training(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{ 
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	volatile uint32_t rd_data;
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_CONTROL);
+	rd_data |= (0x1 << 0); // restart training
+	rd_data |= (0x1 << 1); // training enable
+	__netsoc_write_kr_reg(base, lane_no, KR_PMD_CONTROL, rd_data);
+	nlm_print("restart_link_training: lane:%d restart training \n",lane_no);
+}
+
+void send_maintap_update (nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t update) 
+{
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	volatile uint32_t main_tap_coeff, main_tap_status;
+	volatile uint32_t rd_data;
+
+	main_tap_coeff = update; 
+	rd_data = (main_tap_coeff << 2); 
+	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
+	nlm_print("send_maintap_update: SEND C(0) update  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
+
+	//Read LP status register
+	do {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		main_tap_status = ((rd_data & 0xC) >> 2);
+		if((main_tap_status == 0x3) || (main_tap_status == 0x2) || (main_tap_status == 0x1)) { //if maximum or minimum or updated, set LD coeff to hold
+			main_tap_coeff = 0x0; // hold 
+			rd_data = (main_tap_coeff << 2); 
+			__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_COEFF);
+			nlm_print("send_maintap_update: Set C(0) to HOLD  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
+		} 
+	} while (main_tap_status == 0x0);
+	do {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		main_tap_status = ((rd_data & 0xC) >> 2);
+	} while(main_tap_status != 0x0);
+	nlm_print("send_maintap_update:  lane:%d Value of LP status register is 0x%x -2\n",  lane_no, rd_data);
+}
+
+void send_pretap_update(nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t update)
+{
+	volatile uint32_t pre_tap_coeff, pre_tap_status;
+	volatile uint32_t rd_data;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	pre_tap_coeff = update; 
+	rd_data = pre_tap_coeff; 
+	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
+	nlm_print("send_pretap_update: SEND C(-1) update  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
+
+	//Read LP status register
+	do {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		nlm_print("send_pretap_update:  lane:%d Value of LP status register is 0x%x\n",  lane_no, rd_data);
+		pre_tap_status = (rd_data & 0x3);
+		if((pre_tap_status == 0x3) || (pre_tap_status == 0x2) || (pre_tap_status == 0x1)) { //if maximum or minimum or updated, set LD coeff to hold
+			pre_tap_coeff = 0x0; // hold 
+			rd_data = pre_tap_coeff; 
+			__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
+			nlm_print("send_pretap_update: Set C(-1) to HOLD  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
+		}
+	} while (pre_tap_status == 0x0);
+	do {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+		if((rd_data & BIT(2)) != BIT(2)) {
+			__netsoc_bkpl_restart_link_training(nae, block, lane_no);
+		}
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		pre_tap_status = (rd_data & 0x3);
+	} while(pre_tap_status != 0x0);
+	nlm_print("send_pretap_update:  lane:%d Value of LP status register is 0x%x -2\n",  lane_no, rd_data);
+}
+
+void send_posttap_update( nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t update){
+	volatile uint32_t post_tap_coeff, post_tap_status;
+	volatile uint32_t rd_data;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	post_tap_coeff = update; 
+	rd_data = (post_tap_coeff << 4); 
+	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
+	nlm_print("send_posttap_update: SEND C(+1) update  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
+
+	//Read LP status register
+	do {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		nlm_print("send_posttap_update:  lane:%d Value of LP status register is 0x%x \n",  lane_no, rd_data);
+		post_tap_status = ((rd_data & 0x30) >> 4);
+		if((post_tap_status == 0x3) || (post_tap_status == 0x2) || (post_tap_status == 0x1)) { //if maximum or minimum or updated, set LD coeff to hold
+			post_tap_coeff = 0x0; // hold 
+			rd_data = (post_tap_coeff << 4); 
+			__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_COEFF);
+			nlm_print("send_posttap_update: Set C(+1) to HOLD  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
+		} 
+	} while (post_tap_status == 0x0);
+	do {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		post_tap_status = ((rd_data & 0x30) >> 4);
+	} while(post_tap_status != 0x0);
+	nlm_print("send_posttap_update:  lane:%d Value of LP status register is 0x%x -2\n",  lane_no, rd_data);
+}
+
+
+static void  __netsoc_bkpl_program_tx_driver(nae_t *nae, uint32_t block, uint32_t lane_no)
+{
+	volatile uint32_t rd_data,rd_data1;
+	volatile int32_t  coeff27_minus1, coeff27, coeff27_plus1;
+	volatile uint32_t mod_coeff27_minus1, mod_coeff27, mod_coeff27_plus1;
+	volatile int32_t  present_coeff_minus1, present_coeff_zero, present_coeff_plus1;
+	volatile uint32_t coeff_minus1_update, coeff_zero_update, coeff_plus1_update;
+	volatile int32_t  temp_coeff27_minus1, temp_coeff27_zero, temp_coeff27_plus1;
+	volatile uint32_t mod_temp_coeff27_zero, mod_temp_coeff27_minus1, mod_temp_coeff27_plus1;
+	volatile int32_t  updated_coeff_minus1, updated_coeff_zero,updated_coeff_plus1;
+	volatile uint32_t  updated_status_minus1, updated_status_zero,updated_status_plus1;
+	volatile uint32_t mod_updated_coeff_minus1, mod_updated_coeff_zero,mod_updated_coeff_plus1;
+	volatile uint32_t txdrv_hlev, txdrv_levn, txdrv_levnm1, txdrv_levnm2, txdrv_levnp1, txdrv_slew;
+	uint32_t cnt=0;
+	uint64_t  instr = 0, cycles = 0;
+
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	//reset_perfctr();
+	//start_perfctr();
+	//Read TX DRV registers
+	// TXDRV_HLEV    21[2:0]    0 1 2 3  3'h7
+	// TXDRV_LEVN    21[7:3]    0 1 2 3  5'h1B
+	// TXDRV_LEVNM1  22[3:0]    0 1 2 3  4'h7
+	// TXDRV_LEVNM2  22[5:4]    0 1 2 3  2'h0
+	// TXDRV_LEVNP1  23[2:0]    0 1 2 3  3'h0
+	// TXDRV_SLEW    23[4:3]    0 1 2 3  2'h0
+	// TXDRV_LOCWREN 87[6:6]    0 1 2 3  
+
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 21);
+	//txdrv_hlev = (rd_data & 0x7);        //21[2:0] 
+	txdrv_levn = ((rd_data >> 3) & 0x1F);//21[7:3]
+	//nlm_print("program_tx_driver:  lane:%d 21:0x%x\n",  lane_no, rd_data);
+	rd_data =  __netsoc_read_pma2p0_reg(base, lane_no, 22);
+	txdrv_levnm1 = (rd_data & 0xF);       //22[3:0]
+	//txdrv_levnm2 = ((rd_data >> 4) & 0xF);//22[7:4] 
+	//nlm_print("program_tx_driver:  lane:%d 22:0x%x\n",  lane_no, rd_data);
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 23);
+	txdrv_levnp1 = (rd_data & 0x7);      //23[2:0]
+	//txdrv_slew = ((rd_data >> 3) & 0x3); //23[4:3]
+	//nlm_print("program_tx_driver: inst:%d complex
+
+	//Get initial coefficients 
+	coeff27_minus1 = ((txdrv_levnp1));
+	coeff27_plus1  = ((txdrv_levnm1));
+	mod_coeff27_minus1 = mod(coeff27_minus1);
+	mod_coeff27_plus1 = mod(coeff27_plus1);
+	coeff27 = ((txdrv_levn) - mod_coeff27_minus1 - mod_coeff27_plus1);
+	mod_coeff27= mod(coeff27);
+
+	if(((mod_coeff27_minus1 + mod_coeff27 + mod_coeff27_plus1) <= 27) && ((mod_coeff27 - mod_coeff27_minus1 - mod_coeff27_plus1) >= 6)) {
+		present_coeff_minus1 = coeff27_minus1;
+		present_coeff_zero   = coeff27;
+		present_coeff_plus1  = coeff27_plus1;
+	}
+	nlm_print("program_tx_driver: lane:%d  present_coeff_minus1:%d present_coeff_zero:%d present_coeff_plus1:%d\n", lane_no,present_coeff_minus1, present_coeff_zero,present_coeff_plus1);
+
+
+	//Read LP coefficient update
+	do {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF); 
+		nlm_print("program_tx_driver:  lane:%d Value of LP coefficient update register is 0x%x --1\n", lane_no, rd_data);
+		//Get coeff updates
+		coeff_minus1_update = (rd_data & 0x3);
+		coeff_zero_update   = ((rd_data >> 2) & 0x3);
+		coeff_plus1_update  = ((rd_data >> 4) & 0x3);
+
+		if(coeff_minus1_update == 0) updated_status_minus1 = 0;
+		if(coeff_zero_update == 0)  updated_status_zero   = 0;
+		if(coeff_plus1_update == 0)  updated_status_plus1  = 0;
+
+		//calculate updated coeffs
+		temp_coeff27_minus1 = update_coefficient(coeff_minus1_update, present_coeff_minus1);
+		temp_coeff27_zero   = update_coefficient(coeff_zero_update, present_coeff_zero);
+		temp_coeff27_plus1  = update_coefficient(coeff_plus1_update, present_coeff_plus1);
+
+		mod_temp_coeff27_minus1 =  mod(temp_coeff27_minus1); 
+		mod_temp_coeff27_zero   =  mod(temp_coeff27_zero);
+		mod_temp_coeff27_plus1  =  mod(temp_coeff27_plus1);
+
+		if(((mod_temp_coeff27_minus1 + mod_temp_coeff27_zero + mod_temp_coeff27_plus1) <= 27) && ( mod_temp_coeff27_zero - mod_temp_coeff27_minus1 - mod_updated_coeff_plus1 >= 6)) {
+			//max values
+			if(coeff_minus1_update != 0) {
+				if(mod_temp_coeff27_minus1 > 0x6) {
+					updated_status_minus1 = 3;//maximum
+					updated_coeff_minus1 = present_coeff_minus1;
+				} else if(mod_temp_coeff27_minus1 < 0) {
+					updated_status_minus1 = 2;//minimum
+					updated_coeff_minus1 = present_coeff_minus1;
+				} else {
+					updated_coeff_minus1 = temp_coeff27_minus1;
+					updated_status_minus1 = 1;
+				}
+			} else {
+				updated_coeff_minus1 = present_coeff_minus1;
+				updated_status_minus1 = 0;
+			}
+			if(coeff_zero_update != 0) {
+				if(mod_temp_coeff27_zero > 0x1B) { 
+					updated_status_zero = 3;//maximum
+					updated_coeff_zero = present_coeff_zero;
+					//} else if(mod_temp_coeff27_zero < 0) { //FIXME
+					//  updated_coeff_zero = present_coeff_zero;
+					//  updated_status_zero = 2;//minimum
+			} else {
+				updated_coeff_zero   = temp_coeff27_zero;
+				updated_status_zero = 1;
+			}
+			} else {
+				updated_coeff_zero = present_coeff_zero;
+				updated_status_zero = 0;
+			}
+			if(coeff_plus1_update != 0) {
+				if(mod_temp_coeff27_plus1 > 0x9) {
+					updated_coeff_plus1  = present_coeff_plus1;
+					updated_status_plus1 = 3;//maximum
+				} else if(mod_temp_coeff27_plus1 < 0) { 
+					updated_coeff_plus1  = present_coeff_plus1;
+					updated_status_plus1 = 2;//minimum
+				} else {
+					updated_coeff_plus1  = temp_coeff27_plus1;
+					updated_status_plus1 = 1;
+				} 
+			} else {
+				updated_coeff_plus1 = present_coeff_plus1;
+				updated_status_plus1 = 0;
+			}
+		} else {
+			updated_coeff_minus1 = present_coeff_minus1;
+			updated_coeff_zero = present_coeff_zero;
+			updated_coeff_plus1 = present_coeff_plus1;
+			updated_status_minus1 = 0;
+			updated_status_zero = 0;
+			updated_status_plus1 = 0;
+		}
+		nlm_print("program_tx_driver:  lane:%d updated_coeff_minus1:%d updated_coeff_zero:%d updated_coeff_plus1:%d\n",  lane_no,updated_coeff_minus1,updated_coeff_zero,updated_coeff_plus1 );
+
+		mod_updated_coeff_minus1 =  mod(updated_coeff_minus1); 
+		mod_updated_coeff_zero   =  mod(updated_coeff_zero);
+		mod_updated_coeff_plus1  =  mod(updated_coeff_plus1);
+
+		//Write TX DRV registers
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 87);
+		rd_data &= ~(1<<5); 
+		__netsoc_write_pma2p0_reg(base, lane_no, 87, rd_data);
+
+		//calculate register fields (txdrv_levn, txdrv_nm1, txdev_np1)
+		txdrv_levnm1 =   (updated_coeff_plus1);
+		txdrv_levnp1 =   (updated_coeff_minus1);
+		txdrv_levn = ((updated_coeff_zero + mod_updated_coeff_minus1 + mod_updated_coeff_plus1));
+
+
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 21);
+		rd_data &= 0x07; //[7:3]
+		rd_data |= (txdrv_levn << 3);
+		__netsoc_write_pma2p0_reg(base, lane_no, 21, rd_data);
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 21);
+		//nlm_print("program_tx_driver:  lane:%d reg:21 rd_data:0x%x\n",  lane_no, rd_data);
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 22);
+		rd_data &= 0xF0;
+		rd_data |= txdrv_levnm1;
+		__netsoc_write_pma2p0_reg(base, lane_no, 22, rd_data);
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 22);
+		//nlm_print("program_tx_driver:  lane:%d reg:22 rd_data:0x%x\n",  lane_no, rd_data);
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 23);
+		rd_data &= 0xF8;
+		rd_data |= txdrv_levnp1;
+		__netsoc_write_pma2p0_reg(base, lane_no, 23, rd_data);
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 23);
+		//nlm_print("program_tx_driver:  lane:%d reg:23 rd_data:0x%x\n",  lane_no, rd_data);
+
+		// Write LD Status registers
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
+		rd_data &= 0xFFFC;
+		rd_data |= updated_status_minus1;
+		rd_data &= 0xFFF3;
+		rd_data |= (updated_status_zero << 2);
+		rd_data &= 0xFFCF;
+		rd_data |= (updated_status_plus1 << 4);
+		__netsoc_write_kr_reg(base, lane_no, KR_LD_STAT, rd_data);
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
+		nlm_print("program_tx_driver :  lane:%d Value of LD status register is 0x%x\n", lane_no, rd_data);
+
+		present_coeff_minus1 = updated_coeff_minus1;
+		present_coeff_zero   = updated_coeff_zero;
+		present_coeff_plus1  = updated_coeff_plus1;
+
+		//stop_perfctr();
+		/*TODO: call perf code*/
+		//instr  = read_64bit_cp0_register($25,  1);
+		//cycles = read_64bit_cp0_register($25,  3);
+		//nlm_print("total instr = %llu cycles = %llu \n", (unsigned long long)instr, (unsigned long long)cycles);
+
+		//Read LP coeff update till LP coeff is set to hold
+		do {
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF);
+		} while (rd_data != 0x0);
+		nlm_print("program_tx_driver: lane:%d Value of LP coefficient update register is 0x%x -2\n", lane_no, rd_data);
+		//Set LD Status to not updated
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
+		rd_data &= 0xFFC0 ; // set 5:0 to 0 (not updated) 
+		__netsoc_write_kr_reg(base , lane_no, KR_LD_STAT, rd_data);
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
+		nlm_print("program_tx_driver:  lane:%d Value of LD status register is 0x%x\n", lane_no, rd_data);
+
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF);
+
+	}while (rd_data != 0x0);
+
+}
+
+uint32_t __netsoc_bkpl_get_eyediag_figure_of_merit(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+
+	volatile uint32_t rd_data;
+	volatile uint32_t eye_value0, eye_value1, figure_of_merit_value;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	//0. Initialize the locwrens
+	//PCSRXEQ_LOCWREN
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 85);
+	bit_clear(rd_data, BIT(6));
+	__netsoc_write_pma2p0_reg(base, lane_no, 85, rd_data);
+
+	//2. Start RX EQ
+	//PCSRXEQ_START	31[0:0] 1'b1
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 31);
+	bit_set(rd_data, BIT(0));
+	__netsoc_write_pma2p0_reg(base, lane_no, 31, rd_data);
+
+	//3, Wait for done and read figure of merit:
+	//RXEQ_DONE	32[3:3] (should be 1'b1)
+	//RXEQ_BEST_EYE_VAL	29[7:0],30[5:0]
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 32);
+	while ((rd_data & BIT(3)) != BIT(3)) {
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 32);
+	}
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 29); 
+	eye_value1 = rd_data & 0xFF; 
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 30); 
+	eye_value0 = rd_data & 0x3F; 
+	figure_of_merit_value = ((eye_value1 << 6) | (eye_value0)); 
+	//nlm_print(" get_eyediag_figure_of_merit:  lane:%d updated figure of merit for eye opening:0x%x\n",  lane_no, figure_of_merit_value);
+
+	//4. reset the EQ start signal 
+	//PCSRXEQ_START	31[0:0] 1'b0
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 31);
+	bit_clear(rd_data, BIT(0));
+	__netsoc_write_pma2p0_reg(base, lane_no, 31, rd_data);
+
+	return (figure_of_merit_value);
+
+}
+
+void __netsoc_bkpl_link_device_training(nae_t *nae, uint32_t block, uint32_t lane_no)
+{
+	volatile uint32_t rd_data;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	uint32_t phymode = get_phy_mode(nae, block); 
+	uint32_t count=0;
+
+	//MTIP step1: Keep polling PMD Status until it indicates frame lock
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+	while((rd_data & BIT(1)) != BIT(1)) {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+	}
+	nlm_print("link_device_training:  lane:%d PMD STATUS value:0x%x\n",  lane_no, rd_data);
+
+	//program_tx_driver( lane_no);
+
+	//Read LP status
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+	nlm_print("link_device_training:  lane:%d Value of LP status register is 0x%x\n", lane_no, rd_data);
+	while ((rd_data & BIT(15)) == 0) {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF); 
+		if((rd_data & 0x3F)!= 0x0) __netsoc_bkpl_program_tx_driver(nae, block, lane_no);
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+	}
+	nlm_print("link_device_training:  lane:%d Value of LP status register is 0x%x\n",  lane_no, rd_data);
+
+
+	if(block==1) {
+		// PMD status
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+		rd_data |= (0x1 << 0); // to push state machine into ( mr_trained ) remote training state
+		__netsoc_write_kr_reg(base,  lane_no, KR_PMD_STATUS, rd_data);
+		nlm_print("link_device_training:  lane:%d Pushed state machine into remote training state\n",  lane_no);
+	}
+
+	//wait for lt_done
+	if(block==1) {
+		nlm_print("link_device_training:  lane:%d Waiting for signal_detection signal to go high - lt_done\n",  lane_no);
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+		while((rd_data & BIT(15)) == 0) { //signal detection - indicates training process is complete
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+		}
+		nlm_print("link_device_training:  lane:%d Reached lt_done value 0x%x\n",  lane_no, rd_data);
+	}
+
+}
+
+void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t lane_no)
+{
+	volatile uint32_t rd_data;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	uint32_t phymode = get_phy_mode(nae, block); 
+
+	volatile uint32_t eye_value, updated_eye_value=0;
+	volatile uint32_t pre_tap_coeff, post_tap_coeff, main_tap_coeff;
+	volatile uint32_t pre_tap_status, post_tap_status, main_tap_status;
+	uint64_t count=0, cnt=0;
+	uint32_t reg_addr, mask, exp_value;
+
+	//reset_perfctr();
+	//start_perfctr();
+	//1
+	//rd_data = read_kr_reg( lane_no, KR_LD_COEFF);
+	//rd_data |= (0x1 << 12); //initialize 
+	//write_kr_reg( lane_no, KR_LD_COEFF, rd_data);
+	//nlm_print(" link_partner_training:  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
+
+	//2 
+	//rd_data = read_kr_reg( lane_no, KR_PMD_STATUS);
+	//nlm_print("link_partner_training : complex_no:%d: PMD STATUS value:0x%x\n", rd_data);
+
+	//3 Record the figure of merit
+	//Assert Start and wait for done and then record figure of merit
+	eye_value = __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
+	nlm_print("link_partner_training:  lane:%d  Initial eye_value: 0x%x\n",  lane_no, eye_value);
+	//nlm_print("link_partner_training:  lane:%d  Read initial rx equalization register values\n",  lane_no);
+	//read_vsemi_rxequalization_registers( lane_no);
+	//clear_netior_interrupts(inst_no);
+
+	//4 while figure of merit is improved
+	do {
+		if(count > 0) eye_value = updated_eye_value;
+		//i   Send DEC C(0)
+		send_maintap_update(nae, block, lane_no, 0x2); //decrement
+
+		updated_eye_value =__netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no); 
+		nlm_print("link_partner_training:  lane:%d  After step 4i updated_eye_value:0x%x\n",  lane_no, updated_eye_value);
+		//ii   Send INC(-1)
+		send_maintap_update(nae, block, lane_no, 0x1); //increment
+
+		//iii  
+		//iv  
+		updated_eye_value = __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);;
+		nlm_print("link_partner_training:  lane:%d  After step 4ii updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
+		nlm_print("link_partner_training:  lane:%d  updated_eye_value: 0x%x eye_value:0x%x\n",  lane_no, updated_eye_value, eye_value);
+		//nlm_print("link_partner_training:  lane:%d  After step 4ii Read rx equalization register values\n", lane_no);
+		//read_vsemi_rxequalization_registers( lane_no);
+		count++;
+	} while (updated_eye_value > eye_value); 
+
+	//v   Send DEC(-1)
+	send_pretap_update(nae, block, lane_no, 0x2); //decrement
+
+	updated_eye_value =  __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
+	nlm_print("link_partner_training:  lane:%d  After step 4v updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
+	//nlm_print("link_partner_training:  lane:%d  After step 4v Read rx equalization register values\n", lane_no);
+	//read_vsemi_rxequalization_registers( lane_no);
+
+	count = 0;
+
+	//5 while figure of merit is improved
+	do {
+		//i   Send DEC C(0)
+		eye_value = updated_eye_value;
+		send_maintap_update(nae, block, lane_no, 0x2); //decrement
+		updated_eye_value = __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
+		nlm_print("link_partner_training:  lane:%d  After step 5i updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
+		//nlm_print("link_partner_training:  lane:%d  After step 5i Read rx equalization register values\n",  lane_no);
+		//read_vsemi_rxequalization_registers( lane_no);
+
+		//ii  Send INC C(+1)
+		send_posttap_update(nae, block, lane_no, 0x1); //increment
+
+		//iii  
+		//iv  
+		updated_eye_value = __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
+		nlm_print("link_partner_training:  lane:%d  After step 5ii updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
+		//nlm_print("link_partner_training:  lane:%d  After step 5ii Read rx equalization register values\n",  lane_no);
+		//read_vsemi_rxequalization_registers( lane_no);
+		nlm_print("link_partner_training:  lane:%d  updated_eye_value: 0x%x eye_value:0x%x\n",  lane_no, updated_eye_value, eye_value);
+		count++;
+	} while (updated_eye_value > eye_value);
+
+	//6  Send DEC C(+1)
+	send_posttap_update(nae, block, lane_no, 0x2); //decrement
+	updated_eye_value =  __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);  
+	nlm_print("link_partner_training:  lane:%d  After step 6: updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
+	//nlm_print("link_partner_training:  lane:%d  After step 6 Read rx equalization register values\n",  lane_no);
+	//read_vsemi_rxequalization_registers( lane_no);
+
+	//7   Send INC C(0)
+	send_maintap_update(nae, block, lane_no, 0x1); //increment
+
+	updated_eye_value = __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
+	nlm_print("link_partner_training:  lane:%d  After step 7 updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
+	//nlm_print("link_partner_training:  lane:%d  After step 7 Read rx equalization register values\n",  lane_no);
+	//read_vsemi_rxequalization_registers( lane_no);
+
+	//LD status
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+	rd_data &= 0xFFC0 ; //[5:0] = 6'h0
+	rd_data |= (0x1 << 15); // receiver ready
+	__netsoc_write_kr_reg(base,  lane_no, KR_LD_STAT, rd_data);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
+	nlm_print("link_partner_training:  lane:%d Set receiver ready Value of LD status register is 0x%x\n", lane_no, rd_data);
+
+	if(block==0) {
+		//PMD status
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+		rd_data |= (0x1 << 0); // to push state machine into ( mr_trained ) remote training state
+		__netsoc_write_kr_reg(base,  lane_no, KR_PMD_STATUS, rd_data);
+		nlm_print("link_partner_training:  lane:%d Pushed state machine into remote training state\n",  lane_no);
+		nlm_print("link_partner_training:  lane:%d Waiting for signal_detection signal to go high - lt_done\n", lane_no);
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+		while((rd_data & BIT(15)) == 0) { //signal detection - indicates training process is complete
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+		}
+		nlm_print("link_partner_training:  lane:%d Reached lt_done value:0x%x\n",  lane_no, rd_data);
+	}
+
+	if(block==0) { 
+		//Read LP status
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		while ((rd_data & BIT(15)) == 0) {
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		}
+		nlm_print("link_partner_training:  lane:%d Value of LP status register is 0x%x\n", lane_no, rd_data);
+	}
+
+}
+
+void __netsoc_bkpl_auneg_complete(nae_t *nae, uint32_t block, uint32_t lane_no)
+{
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	uint32_t phymode = get_phy_mode(nae, block); 
+	volatile uint32_t rd_data;
+	uint32_t count;
+	if(nae->bkpl_cfg[block].link_training_enable)
+	{
+		//Disable LT
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_CONTROL);
+		rd_data |= (0x1 << 0); // restart training 
+		rd_data |= (0x0 << 1); // training enable
+		__netsoc_write_kr_reg(base, lane_no, KR_PMD_CONTROL, rd_data);
+		nlm_print("wait_for_an_complete:  lane:%d Disabled link training\n",  lane_no);
+
+	}
+
+	count=0;
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
+	while((rd_data & (1<<5)) == 0) {
+		nlm_print(" AN_STATUS: complex: %d lane: %d Waiting for an_done. value:0x%x\n", block, lane_no, rd_data);
+		nlm_mdelay(50);
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
+		
+		//if(count++ == 100) break; 
+	}
+	nlm_print(" complex: %d lane: %d AN process completed value:0x%x\n", block, lane_no,rd_data);
+}
+
 void __netsoc_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask)
 {
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
@@ -1586,6 +2551,64 @@ void __netsoc_xlaui_pcs_init(nae_t *nae, uint32_t xlaui_cplx_mask, uint32_t phym
 #endif
 }
 
+void __netsoc_bkpl_ether_init(nae_t *nae)
+{
+#if !defined(XLP_SIM) || defined(NLM_BOARD)
+
+	uint32_t block, lane_ctrl, max_kr_lanes=0;
+	uint32_t cplx_mask = nae->xlgmac_complex_map | nae->xfi_complex_map;
+
+	for( block = 0; block < 2; block++)
+        {
+		uint32_t phymode = get_phy_mode(nae, block); 
+		
+		if(!(phymode==XLAUI_IF || phymode==XFI_IF))
+		 	continue;
+		max_kr_lanes = (phymode==XFI_IF) ? 3:0; 
+		
+		if(!(nae->bkpl_cfg[block].kr_en))
+			continue;
+
+                for( lane_ctrl = 0; lane_ctrl <= max_kr_lanes; lane_ctrl++){
+			__netsoc_clause_173_enable(nae, block, lane_ctrl);		
+		}
+	
+	}
+	for( block = 0; block < 2; block++)
+        {
+		uint32_t phymode = get_phy_mode(nae, block); 
+		
+		if(!(phymode==XLAUI_IF || phymode==XFI_IF))
+		 	continue;
+		max_kr_lanes = (phymode==XFI_IF) ? 3:0; 
+		
+		if(!(nae->bkpl_cfg[block].kr_en))
+			continue;
+
+                for( lane_ctrl = 0; lane_ctrl <= max_kr_lanes; lane_ctrl++){
+			__netsoc_perform_clause_173_base_page(nae, block, lane_ctrl);		
+		}
+	
+	}
+	for( block = 0; block < 2; block++)
+        {
+		uint32_t phymode = get_phy_mode(nae, block); 
+		if(!(phymode==XLAUI_IF || phymode==XFI_IF))
+		 	continue;
+		if(!(nae->bkpl_cfg[block].kr_en))
+			continue;
+
+                for( lane_ctrl = 0; lane_ctrl <= 0; lane_ctrl++){ /*AN on only one lane*/
+			//if((phymode==PHYMODE_XLAUI && lane_ctrl==0) || (phymode==PHYMODE_XFI)){
+				__netsoc_bkpl_auneg_complete(nae, block, lane_ctrl);		
+			//}
+		}
+	}
+
+#endif
+	
+}
+
 int __netsoc_interlaken_pcs_init(nae_t *nae, uint32_t ilk_complex_map)
 {
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
-- 
1.9.1

