From ce656dcf455e42d1ff1ed1ec9ee90a223fbfea0a Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Thu, 30 Sep 2010 13:57:49 -0700
Subject: [PATCH 1301/1532] turn off hardware init to run on silicon

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/init_nae.c |  22 ++-
 drivers/net/ethernet/broadcom/nae/xlp_nae.c  | 215 ++++++---------------------
 2 files changed, 64 insertions(+), 173 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/init_nae.c b/drivers/net/ethernet/broadcom/nae/init_nae.c
index 236dd65..9ed891e 100644
--- a/drivers/net/ethernet/broadcom/nae/init_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/init_nae.c
@@ -203,21 +203,41 @@ static void parse_fdt_nae_config(void)
 		kfree(nae_regs);
 		kfree(intf_regs);
 
+#if 0
 		if (nlm_hal_open_if(port_type, hw_port_id) < 0) {
 			printk("[%s] Unable to open port %d\n", __func__, i);
 			continue;
 		}
-
+#endif
 		printk("Initialized port@%d\n", i);
 	}
 }
 
 void initialize_nae(void)
 {
+	uint32_t val = 0;
+	int i = 0;
+
 	if (check_header()) {
 		printk("Sanity check on FDT blob failed! Aborting\n");
 		return;
 	}
+
+#if 0
+	/* Before doing anything, reset crap left over by firmware in the nae */
+	nlm_hal_write_nae_reg(0x62, (1 << 16));
+	for (i = 0; i < 10000000; i++) {
+		val = nlm_hal_read_nae_reg(0x62);
+		if (val) break;
+	}
+	if (val) {
+		printk("[%s] reset of port 16 successful!\n", __func__);
+	}
+	else {
+		printk("[%s] reset of port 16 failed!\n", __func__);
+	}
+#endif
+
 	printk("Configuring ucore...\n");
 	parse_ucore_config();
 
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index a8d133c..c691faf 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -66,7 +66,6 @@
 #define PCI_DEVID_OFF_NET		0
 
 #define MIN_FRIN_DESC_THRESHD		16
-#define FREE_DESC_POOL_WIDTH		20
 
 #define MAX_NET_INF             	1
 #define MAX_GMAC_PORT               	18
@@ -85,7 +84,7 @@
         printk(" %s \n", str);                  \
         for(i = 0; i < y; i++)			\
         {					\
-                printk("%02x ", x[i]);		\
+                printk("%02x ", (x)[i]);		\
                 if( i % 16 == 15)		\
                         printk("\n");		\
         }					\
@@ -95,6 +94,9 @@
 int debug = 0;
 module_param(debug, int, 0);
 
+static int drop_uboot_pkt = 1;
+module_param(drop_uboot_pkt, int, 0);
+
 extern int hwemul;
 module_param(hwemul, int, 0);
 
@@ -142,7 +144,6 @@ static struct pci_device_id soc_pci_table[] __devinitdata = {
 extern void xlp_set_ethtool_ops(struct net_device *netdev);
 extern void xlp_get_mac_stats(struct net_device* dev, struct net_device_stats* stats);
 spinlock_t  nlm_xlp_nae_lock;
-static void nlm_xlp_sgmii_setcontext(void);
 static void nlm_xlp_nae_init(void);
 static int xlp_mac_proc_read(char *page, char **start, off_t off,int count, int *eof, void *data);
 static int  nlm_xlp_nae_open (struct net_device *dev);
@@ -186,31 +187,29 @@ static const struct net_device_ops nlm_xlp_nae_ops = {
 	.ndo_get_stats = nlm_xlp_mac_get_stats,
 };
 
-static __inline__ void print_fmn_send_error(uint32_t send_result, uint32_t status1)
+static __inline__ void cpu_halt(void)
+{
+	__asm__ volatile (".set push\n"
+			  ".set noreorder\n"
+			  "   wait\n"
+			  "1: b    1b\n"
+			  "   nop\n"
+			  ".set pop\n"
+		);
+}
+
+static __inline__ void print_fmn_send_error(const char *str, uint32_t send_result)
 {
 	if(send_result & MSG_DST_FC_FAIL)
 	{
-		status1 = xlp_read_status1();
-		if( status1 & (1 << 31))
-		{
-			printk("CPU receive queue written when Full\n");
-
-		}
-		else if (status1 & (1 << 30))
-		{
-			printk("Fmn input credit overflow hardware error\n");
-		}
-		else if (status1 & (1 << 29))
-		{
-			printk("Fmn output credit overflow error, Outq ID: %d\n", status1 & 0xfff);
-		}
-		printk("TX message destination flow control credit fail\n");
+		printk("[%s] Msg Destination flow control credit fail(send_result=%08x)\n",
+		       str, send_result);
 	}
 	else if (send_result & MSG_INFLIGHT_MSG_EX) {
-		printk("[%s] MSG_INFLIGHT_MSG_EX\n", __func__);
+		printk("[%s] MSG_INFLIGHT_MSG_EX(send_result=%08x)\n", __func__, send_result);
 	}
 	else if (send_result & MSG_TXQ_FULL) {
-		printk("TX message Q fulll\n");
+		printk("[%s] TX message Q full(send_result=%08x)\n", __func__, send_result);
 	}
 }
 
@@ -304,75 +303,6 @@ static inline void nlm_xlp_free_skb(struct xlp_msg *msg)
 	dev_kfree_skb_any(skb);
 }
 
-#if 0
-/**********************************************************************
- * mac_send_one_desc -  refill one freein buffer for a device
- * @dev -  this is per device based function
- *
- **********************************************************************/
-static void mac_send_one_desc(unsigned long dev)
-{
-        struct dev_data* priv;
-        struct net_device *ndev;
-        int ret, mflags, code;
-        struct xlp_msg msg;
-        struct sk_buff * skb;
-
-        ndev = (struct net_device *) dev;
-        priv = netdev_priv(ndev);
-        ret = 0;
-
-	skb = nlm_xlp_alloc_skb();
-        if(!skb)
-	{
-		printk("[%s] alloc skb failed\n",__FUNCTION__);
-                        return;
-	}
-
-	skb->dev = ndev;
-
-        /* Send the free Rx desc to the MAC */
-	mac_put_skb_back_ptr(skb);
-	code = 0;
-
-	msgrng_access_enable(mflags);
-        msg.entry[0] = (unsigned long long)virt_to_bus(skb->data) & 0xffffffffffULL;
-        /* Send the packet to nae rx  */
-	__sync();
-retry_send:
-        if((ret = nlm_hal_send_msg1( priv->nae_rx_qid, code, msg.entry[0])))
-        {
-		if(ret & MSG_DST_FC_FAIL)
-		{
-			ret = xlp_read_status1();
-			if( ret & (1 << 31))
-                        {
-				printk("CPU receive queue written when Full\n");
-                        }
-                        else if(ret & (1 << 30))
-                        {
-				printk("Fmn input credit overflow hardware error\n");
-                        }
-                        else if( ret & (1 << 29))
-                        {
-				printk("Fmn output credit overflow error, Outq ID: %d\n", ret & 0xfff);
-                        }
-			printk("TX message destination flow control credit fail\n");
-			msgrng_access_disable(mflags);
-		}
-		else if(ret & MSG_INFLIGHT_MSG_EX)
-			goto retry_send;
-		else if(ret & MSG_TXQ_FULL)
-			printk("TX message Q fulll\n");
-		dev_kfree_skb(skb);
-		msgrng_access_disable(mflags);
-	}
-	msgrng_access_disable(mflags);
-        priv->num_desc += 1;
-        return;
-}
-#endif
-
 /**********************************************************************
  * mac_refill_frin_desc -  refill rx freein buffer for a device
  * @dev -  this is per device based function
@@ -419,7 +349,7 @@ static void mac_refill_frin_desc(unsigned long dev)
 	retry_send:
                 if ( (ret = nlm_hal_send_msg1(priv->nae_rx_qid, code, msg.entry[0])) )
 		{
-			print_fmn_send_error(ret, xlp_read_status1());
+			print_fmn_send_error(__func__, ret);
 			if (debug) printk("[%s]: retrying...\n", __func__);
 			goto retry_send;
                 }
@@ -441,11 +371,10 @@ static void nlm_xlp_nae_init(void)
 	struct dev_data *priv;
 	int i;
 	struct proc_dir_entry *entry;
-	uint32_t val;
 
 	printk("======= Module Parameters =========\n");
-	printk("debug = %d, hwemul=%d, naecfg_hack=%d\n",
-	       debug, hwemul, naecfg_hack);
+	printk("debug = %d, hwemul=%d, naecfg_hack=%d drop_uboot_pkt=%d\n",
+	       debug, hwemul, naecfg_hack, drop_uboot_pkt);
 #if 0
 	if (hwemul) {
 		unsigned long mflags = 0;
@@ -499,71 +428,6 @@ static void nlm_xlp_nae_init(void)
 		printk("[%s]: Unable to create proc read entry for xlp_mac!\n",
 		       __FUNCTION__);
 	}
-
-	/*config free fifo context mapping*/
-	spin_lock_irq(&nlm_xlp_nae_lock);
-
-	for(i = 0; i < FREE_DESC_POOL_WIDTH; i++)
-	{
-		val = nlm_hal_read_nae_reg(FREE_IN_FIFO_CFG);
-
-		val = (1 << 31)|(26<<20) |((i*26) << 8) | i*26;
-		nlm_hal_write_nae_reg(FREE_IN_FIFO_CFG, val );
-
-	}
-	nlm_xlp_sgmii_setcontext();
-
-	spin_unlock_irq(&nlm_xlp_nae_lock);
-}
-
-/**********************************************************************
- * nlm_xlp_sgmii_setcontext -  setup context info for RX interface
- * so cpu can identify the which port the message is from
- *
- **********************************************************************/
-static void nlm_xlp_sgmii_setcontext(void)
-{
-	int i = 0;
-	uint32_t val;
-
-	/* XLP_SGMII_RCV_CONTEXT_NUM = 8 */
-
-	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM) << 16) |i;
-	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_0, val );
-	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
-
-	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
-	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_1, val );
-	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
-
-	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
-	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_2, val );
-	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
-
-	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
-	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_3, val );
-	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
-
-	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
-	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_4, val );
-	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
-
-	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
-	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_5, val );
-	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
-
-	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
-	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_6, val );
-	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
-
-	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
-	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_7, val );
-	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
-
-	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
-	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_8, val );
-	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
-
 }
 
 /**********************************************************************
@@ -702,9 +566,11 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 				      msg.entry[0],
 				      msg.entry[1])) )
         {
-		print_fmn_send_error(ret, xlp_read_status1());
+		print_fmn_send_error(__func__, ret);
 		if (debug) printk("[%s]: retrying message send...\n", __func__);
-		goto retry_send;
+		printk("[%s] HACK ALERT! dropping packet(skb=%p)!\n", __func__, skb);
+		dev_kfree_skb_any(skb);
+		//goto retry_send;
         }
 
 	msgrng_access_disable(mflags);
@@ -865,7 +731,6 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
         struct net_device *pdev;
         struct dev_data *priv;
 	unsigned int len, port = 0, context;
-        unsigned char* buf;
         uint64_t addr , vaddr;
 	struct sk_buff* skb;
 	int cpu = 0;
@@ -915,7 +780,8 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			priv->cpu_stats[cpu].txc_packets++;
 		}
 		else {
-			printk("[%s]: [txc] wrong addr = %llx\n", __func__, addr);
+			printk("[%s]: [txc] Null skb? paddr = %llx\n", __func__, addr);
+			cpu_halt();
 		}
 	}
 	else if(vc == nae_rx_vc && size == 2)
@@ -925,6 +791,13 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		len	= (msg1 >> 40) & 0x3fff;
 		context = msg1 >> 54;
 
+		if (drop_uboot_pkt) {
+			if ( (addr >= (192<<20)) && (addr < (256 << 20)) ) {
+				printk("Dropping firmware network packet (addr=%llx)!\n", addr);
+				return;
+			}
+		}
+
 		/*context is XLP_SGMII_RCV_CONTEXT_NUM + three bit vlan type or vlan priority*/
 		port = 0; //context / XLP_SGMII_RCV_CONTEXT_NUM;
 
@@ -941,14 +814,13 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		priv = netdev_priv(pdev);
 
 		vaddr = (uint64_t)bus_to_virt(addr);
-		buf = (unsigned char *)vaddr;
 
 		if (debug) {
-			printk("[%s][RX] addr=%llx, len=%d, context=%d, port=%d, vaddr=%llx, buf=%p\n",
-			       __func__, addr, len, context, port, vaddr, buf);
+			printk("[%s][RX] addr=%llx, len=%d, context=%d, port=%d, vaddr=%llx\n",
+			       __func__, addr, len, context, port, vaddr);
 		}
 
-		DUMP_PKT("RX Packet: ", buf , len);
+		DUMP_PKT("RX Packet: ", (unsigned char *)vaddr, len);
 
 		len = len  - MAC_CRC_LEN;
 
@@ -981,11 +853,13 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 				tasklet_schedule(&mac_refill_task[port]);
 			}
 		}
-		else if(!skb)
+		else
 		{
 			priv->stats.rx_errors++;
 			priv->stats.rx_dropped++;
-			printk("[%s] wrong skb addr %llx, drop it!",__FUNCTION__,(uint64_t)skb);
+			printk("[%s] Null skb? addr=%llx, vaddr=%llx, drop it!\n",
+			       __func__, addr, vaddr);
+			cpu_halt();
 			return;
 		}
 	}
@@ -1060,9 +934,6 @@ static void nlm_xlp_mac_timer(unsigned long data)
         struct dev_data *priv = netdev_priv(dev);
         int next_tick = HZ;
 
-        spin_lock_irq(&priv->lock);
-
-        spin_unlock_irq(&priv->lock);
         priv->link_timer.expires = jiffies + next_tick/10;
         add_timer(&priv->link_timer);
 }
-- 
1.9.1

