From 3208f09124a17737fb68ec15073e6c9826348b6e Mon Sep 17 00:00:00 2001
From: Xiaoyi Liu <xiaoyi@broadcom.com>
Date: Mon, 23 Sep 2013 16:30:19 -0400
Subject: [PATCH 0798/1532] syslib: add xlp9xx to nlm_hal_set_sae_freq; change
 set_sae_frequency to set_crypto_block_frequency to handle both sae and rsa.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h | 104 +++++++++++++++++++++
 arch/mips/netlogic/lib/syslib/src/nlm_hal.c        |  13 +--
 2 files changed, 111 insertions(+), 6 deletions(-)

diff --git a/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h b/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
index d1da0d2..92dbcae 100644
--- a/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
+++ b/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
@@ -252,6 +252,106 @@ static inline int set_nae_frequency(int node, uint64_t freq)
     return 0;
 }
 
+static inline uint64_t get_crypto_block_frequency(int node, int dev_id)
+{
+    uint32_t sel, div, pll_out, dev_shift;
+    uint32_t clk_freq;
+    uint64_t sys_base = SYS_CLKDEV_BASE(node);
+
+    if (dev_id == XLP9XX_CLKDEV_SEC) 
+        dev_shift = XLP9XX_CLKDEV_SEC * 2;
+    else 
+        dev_shift = XLP9XX_CLKDEV_RSA * 2;
+
+    sel = (syssoc_read_reg(sys_base, CLK_DEVSEL) >> dev_shift) & 0x3;
+    div = (syssoc_read_reg(sys_base, CLK_DEVDIV) >> dev_shift) & 0x3;
+
+    switch (sel) {
+        case 0: pll_out = 133; break;
+        case 1: pll_out = 500; break;
+        case 2: pll_out = 667; break;
+        case 3: pll_out = 767; break;
+    }
+
+    switch (div) {
+        case 0: clk_freq = pll_out; break;
+        case 1: clk_freq = pll_out/2; break;
+        case 2: clk_freq = pll_out/4; break;
+        case 3: clk_freq = pll_out/8; break;
+    }
+
+    nlm_print("sel:%d div:%d %s_FREQUENCY :%d MHz\n", sel, div, 
+               dev_id == XLP9XX_CLKDEV_SEC? "SAE":"RSA", clk_freq);
+    return (uint64_t) (clk_freq * 1000000);
+}
+
+static inline int set_crypto_block_frequency(int node, int dev_id, uint64_t freq)
+{
+    int sel, div, dev_shift, i;
+    const uint64_t mhz = 1000000;
+    int dev_freq = freq / mhz;
+    uint32_t val;
+    uint64_t sys_base = SYS_CLKDEV_BASE(node);
+    char* block_name;
+
+    if (dev_id == XLP9XX_CLKDEV_SEC)
+        block_name = "SAE";
+    else
+        block_name = "RSA";
+
+    nlm_print("%s frequency %lld MHz\n", block_name,  
+              get_crypto_block_frequency(node, dev_id) / mhz);
+
+    if (freq == get_crypto_block_frequency(node, dev_id))
+        return 0;
+    switch (dev_freq) {
+        case 133: sel = 0; div = 0; break;
+        case 500: sel = 1; div = 0; break;
+        case 250: sel = 1; div = 1; break;
+        case 125: sel = 1; div = 2; break;
+        case 667: sel = 2; div = 0; break;
+        case 767: sel = 3; div = 0; break;
+        default: // Set it to 333 MHz
+            nlm_print("Can't set freq to given MHz. Setting Freq to 667 MHz instead.\n");
+            sel = 2; div = 0;
+        break;
+    }
+    dev_shift = dev_id * 2;
+    // Write the div and select register
+    val = ((sel & 0x3) << dev_shift);
+    syssoc_write_reg(sys_base, CLK_DEVSEL, val);
+
+    val = ((div & 0x3) << dev_shift);
+    syssoc_write_reg(sys_base, CLK_DEVDIV, val);
+
+    // Poll Change register
+    syssoc_write_reg(sys_base, CLK_DEVCHG, 0x1 << dev_id);
+
+    i=0;
+    while (i++ < 10) {
+      val = syssoc_read_reg(sys_base, CLK_DEVCHG);
+
+      if ((i==10) || ((val & (1 << dev_id)) == 0)) {
+          // Check the status
+          val = (syssoc_read_reg(sys_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
+          if (val != sel) {
+              nlm_print(" %s CLKSELDEV val 0x%x select bit is not correct exp:%d got:%d\n",
+                          block_name, syssoc_read_reg(sys_base, CLK_DEVSEL_STAT), sel, val);
+          }
+          val = (syssoc_read_reg(sys_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
+          if (val != div) {
+              nlm_print("%s CLKSELDEV val 0x%x divide bit is not correct exp:%d got:%d\n",
+                         block_name, syssoc_read_reg(sys_base, CLK_DEVDIV_STAT), div, val);
+          }
+          break;
+      }
+    }
+
+    nlm_print("%s frequency changed to %lld MHz\n",block_name, 
+              get_crypto_block_frequency(node, dev_id) / mhz);
+    return 0;
+}
+
 
 static inline int set_soc_frequency(int node, int dev_id, uint64_t freq)
 {
@@ -260,6 +360,10 @@ static inline int set_soc_frequency(int node, int dev_id, uint64_t freq)
 		case XLP9XX_CLKDEV_NET:
 			set_nae_frequency(node, freq);
 			break;
+                case XLP9XX_CLKDEV_SEC:
+		case XLP9XX_CLKDEV_RSA:
+                        set_crypto_block_frequency(node, dev_id, freq);
+                        break;
 		default:
 			nlm_print("%s error\n",__func__);
 			break;
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
index 73842b8..e9e5bb6 100644
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
@@ -66,6 +66,7 @@
 #include "nlm_hal_sys.h"
 #include "libfdt.h"
 #include "fdt_helper.h"
+#include "xlp9xx_sys.h"
 
 /* These addresses are computed by the nlm_hal_init() */
 unsigned long xlp_io_base;
@@ -1000,8 +1001,9 @@ void nlm_hal_set_sae_freq(int node, int freq)
 	nlm_print("-- SAE Frequency set to %d\n", freq);
 	if(is_nlm_xlp2xx()) {
 		nlm_hal_xlp2xx_set_clkdev_frq(node, XLP2XX_CLKDEVICE_SAE, freq * mhz);
-	}
-	else {
+	} else if (is_nlm_xlp9xx()) {
+            set_soc_frequency(node, XLP9XX_CLKDEV_SEC, freq * mhz);
+        } else {
 		uint64_t set_freq = nlm_hal_set_soc_freq(node, DFS_DEVICE_SAE, freq * mhz);
 		NLM_HAL_DO_DIV(set_freq, mhz);
 		nlm_print("SAE Frequency set to %lluMHz\n", (unsigned long long)set_freq);
@@ -1025,16 +1027,15 @@ void nlm_hal_set_rsa_freq(int node, int freq)
 	nlm_print("--RSA Frequency set to %d\n", freq);
 	if(is_nlm_xlp2xx()) {
 		nlm_hal_xlp2xx_set_clkdev_frq(node, XLP2XX_CLKDEVICE_RSA, freq * mhz);
-	}
-	else {
+	} if (is_nlm_xlp9xx()) {
+            set_soc_frequency(node, XLP9XX_CLKDEV_RSA, freq*mhz);
+        } else {
 		uint64_t set_freq = nlm_hal_set_soc_freq(0, DFS_DEVICE_RSA, freq * mhz);
 		NLM_HAL_DO_DIV(set_freq, mhz);
 		nlm_print("RSA Frequency set to %lluMHz\n", (unsigned long long)set_freq);
 	}
 }
 
-
-
 void  nlm_hal_sata_firmware_init(void)
 {
 	volatile uint32_t readdata, i;
-- 
1.9.1

