From b21f28444d4d79d1e044223299103b1c39bfaad0 Mon Sep 17 00:00:00 2001
From: Jayachandran C <jchandra@broadcom.com>
Date: Mon, 15 Apr 2013 19:57:04 +0530
Subject: [PATCH 1136/1532] linux-3.7: Changes for compiling linux-userspace
 against linux-3.7.

1. Add soc_interface

   a. Imported the following files from SDK Linux-3.0

      arch/mips/netlogic/common/on_chip.c -> on_chip.c
      arch/mips/include/asm/netlogic/debug.h -> nlm_debug.h
      arch/mips/include/asm/netlogic/cpumask.h -> nlm_cpumask.h
      arch/mips/netlogic/boot/ops.h -> ops.h
      arch/mips/netlogic/boot/libfdt-wrapper.c -> libfdt-wrapper.c

   b. Build a module around on_chip.c

      Convert on_chip.c to a module that does FMN and other initialization
      which was done in kernel bootup.

      The changes are:
      	  * Add Makefile for building soc_interface module
	  * Remove most of cpu_proc.c and debug.h and add only needed stubs
	  * Update libfdt-wrapper.c to comment out the memory alloc code, this
	    is not needed in our implementation
	    * Update ops.h to take out unneeded headers
	    * Update nlm_cpumask.h and nlm_debug.h to use the correct defines
	      for XLP
	  * Many updates for on_chip.c :
	    - updated add_timer API use
	    - derive phys_cpu_present_map bitmask using cpu_logical_map()
	    - import parse_fmn_config() and parse_fdt_sae_vc_config() from
	      SDK linux codebase
	    - import other SDK specific code, nlm_proc_setup(), fmn_config()
	        nlm_fmn_init() from SDK linux codebase
	    - move from cpu map to cpumask interface
	    - export symbols needed for accelerator modules

    c. soc_interface: Read dts and assign xlp_napi_vc_mask.

       Also add cop2 access as CONFIG_NLM_ENABLE_COP2 is not yet
       supported. msgrng_flags_save/restore does nothing if
       CONFIG_NLM_ENABLE_COP2 is defined. so no need to put it
       under CONFIG_32BIT

2.nae : Changes for linux-3.7

      * Makefile updated for updated HAL and nlm_sdklib
      * Header files are no longer in kernel, use the HAL paths
      * Comment out code which needs update e.g MacSec
      * use cpumask methods instead of cpumap
      * in tso_xmit_skb, use skb_frag_page()

3. linux-3.7: Build framework updates.

   The kmod/Makefile no longer builds the libraries.
   The libraries are to be built separately.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/soc_interface/cpu_proc.c     |   11 +
 .../misc/netlogic/soc_interface/libfdt-wrapper.c   |  230 +++++
 drivers/misc/netlogic/soc_interface/nlm_cpumask.h  |   59 ++
 drivers/misc/netlogic/soc_interface/nlm_debug.h    |  119 +++
 drivers/misc/netlogic/soc_interface/on_chip.c      | 1032 ++++++++++++++++++++
 drivers/misc/netlogic/soc_interface/ops.h          |  265 +++++
 6 files changed, 1716 insertions(+)
 create mode 100644 drivers/misc/netlogic/soc_interface/cpu_proc.c
 create mode 100644 drivers/misc/netlogic/soc_interface/libfdt-wrapper.c
 create mode 100644 drivers/misc/netlogic/soc_interface/nlm_cpumask.h
 create mode 100644 drivers/misc/netlogic/soc_interface/nlm_debug.h
 create mode 100644 drivers/misc/netlogic/soc_interface/on_chip.c
 create mode 100644 drivers/misc/netlogic/soc_interface/ops.h

diff --git a/drivers/misc/netlogic/soc_interface/cpu_proc.c b/drivers/misc/netlogic/soc_interface/cpu_proc.c
new file mode 100644
index 0000000..c4c0a46
--- /dev/null
+++ b/drivers/misc/netlogic/soc_interface/cpu_proc.c
@@ -0,0 +1,11 @@
+#include <linux/kernel.h>
+
+void nlm_cpu_stat_update_msgring_pic_int(void)
+{
+}
+void nlm_cpu_stat_update_msgring_cycles(__u32 cycles)
+{
+}
+void nlm_cpu_stat_update_msgring_int(void)
+{
+}
diff --git a/drivers/misc/netlogic/soc_interface/libfdt-wrapper.c b/drivers/misc/netlogic/soc_interface/libfdt-wrapper.c
new file mode 100644
index 0000000..0716db0
--- /dev/null
+++ b/drivers/misc/netlogic/soc_interface/libfdt-wrapper.c
@@ -0,0 +1,230 @@
+/*
+ * This file does the necessary interface mapping between the bootwrapper
+ * device tree operations and the interface provided by shared source
+ * files flatdevicetree.[ch].
+ *
+ * Copyright 2007 David Gibson, IBM Corporation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <stddef.h>
+#include <libfdt.h>
+#include "ops.h"
+
+#if 0
+(BAD_ERROR(err) || ((err < 0) && DEBUG)) 
+	printf("%s():%d  %s\n\r", __func__, __LINE__, fdt_strerror(err)); 
+#endif
+
+#define min(x,y) ({ \
+		typeof(x) _x = (x); \
+		typeof(y) _y = (y); \
+		(void) (&_x == &_y);    \
+		_x < _y ? _x : _y; })
+
+
+#define DEBUG	0
+#define BAD_ERROR(err)	(((err) < 0) \
+			 && ((err) != -FDT_ERR_NOTFOUND) \
+			 && ((err) != -FDT_ERR_EXISTS))
+
+#define check_err(err) \
+	({ \
+		if (BAD_ERROR(err)) \
+			exit(); \
+		(err < 0) ? -1 : 0; \
+	})
+
+#define offset_devp(off)	\
+	({ \
+		int _offset = (off); \
+		check_err(_offset) ? NULL : (void *)(unsigned long)(_offset+1); \
+	})
+
+#define devp_offset_find(devp)	(((int)(unsigned long)(devp))-1)
+#define devp_offset(devp)	(devp ? ((int)(unsigned long)(devp))-1 : 0)
+
+void *fdt;
+#if 0
+static void *buf; /* = NULL */
+#endif
+
+#define EXPAND_GRANULARITY	1024
+
+struct platform_ops platform_ops;
+struct dt_ops dt_ops;
+
+
+static void expand_buf(int minexpand)
+{
+#if 0
+	int size = fdt_totalsize(fdt);
+	int rc;
+
+	size = _ALIGN(size + minexpand, EXPAND_GRANULARITY);
+	buf = platform_ops.realloc(buf, size);
+	rc = fdt_open_into(fdt, buf, size);
+	fdt = buf;
+#endif
+}
+
+static void *fdt_wrapper_finddevice(const char *path)
+{
+	return offset_devp(fdt_path_offset(fdt, path));
+}
+
+static int fdt_wrapper_getprop(const void *devp, const char *name,
+			       void *buf, const int buflen)
+{
+	const void *p;
+	int len;
+
+	p = fdt_getprop(fdt, devp_offset(devp), name, &len);
+	if (!p)
+		return check_err(len);
+	memcpy(buf, p, min(len, buflen));
+	return len;
+}
+
+static int fdt_wrapper_setprop(const void *devp, const char *name,
+			       const void *buf, const int len)
+{
+	int rc;
+
+	rc = fdt_setprop(fdt, devp_offset(devp), name, buf, len);
+	if (rc == -FDT_ERR_NOSPACE) {
+		expand_buf(len + 16);
+		rc = fdt_setprop(fdt, devp_offset(devp), name, buf, len);
+	}
+
+	return check_err(rc);
+}
+
+static int fdt_wrapper_del_node(const void *devp)
+{
+	return fdt_del_node(fdt, devp_offset(devp));
+}
+
+static void *fdt_wrapper_get_parent(const void *devp)
+{
+	return offset_devp(fdt_parent_offset(fdt, devp_offset(devp)));
+}
+
+static void *fdt_wrapper_create_node(const void *devp, const char *name)
+{
+	int offset;
+
+	offset = fdt_add_subnode(fdt, devp_offset(devp), name);
+	if (offset == -FDT_ERR_NOSPACE) {
+		expand_buf(strlen(name) + 16);
+		offset = fdt_add_subnode(fdt, devp_offset(devp), name);
+	}
+
+	return offset_devp(offset);
+}
+
+static void *fdt_wrapper_find_node_by_prop_value(const void *prev,
+						 const char *name,
+						 const char *val,
+						 int len)
+{
+	int offset = fdt_node_offset_by_prop_value(fdt, devp_offset_find(prev),
+	                                           name, val, len);
+	return offset_devp(offset);
+}
+
+static void *fdt_wrapper_find_node_by_compatible(const void *prev,
+						 const char *val)
+{
+	int offset = fdt_node_offset_by_compatible(fdt, devp_offset_find(prev),
+	                                           val);
+	return offset_devp(offset);
+}
+
+static char *fdt_wrapper_get_path(const void *devp, char *buf, int len)
+{
+	int rc;
+
+	rc = fdt_get_path(fdt, devp_offset(devp), buf, len);
+	if (check_err(rc))
+		return NULL;
+	return buf;
+}
+
+static unsigned long fdt_wrapper_finalize(void)
+{
+	int rc;
+
+	rc = fdt_pack(fdt);
+#if 0
+	if (rc != 0)
+		fatal("Couldn't pack flat tree: %s\n\r",
+		      fdt_strerror(rc));
+#endif
+	return (unsigned long)fdt;
+}
+
+static int fdt_wrapper_check_header(void)
+{
+	int err;
+
+	if ((err = fdt_check_header(fdt)) != 0)
+		return err;
+
+	return 0;
+}
+
+void *fdt_init(void *blob)
+{
+	dt_ops.finddevice = fdt_wrapper_finddevice;
+	dt_ops.getprop = fdt_wrapper_getprop;
+	dt_ops.setprop = fdt_wrapper_setprop;
+	dt_ops.get_parent = fdt_wrapper_get_parent;
+	dt_ops.create_node = fdt_wrapper_create_node;
+	dt_ops.find_node_by_prop_value = fdt_wrapper_find_node_by_prop_value;
+	dt_ops.find_node_by_compatible = fdt_wrapper_find_node_by_compatible;
+	dt_ops.del_node = fdt_wrapper_del_node;
+	dt_ops.get_path = fdt_wrapper_get_path;
+	dt_ops.finalize = fdt_wrapper_finalize;
+	dt_ops.check_header = fdt_wrapper_check_header;
+
+	/* Make sure the dt blob is the right version and so forth */
+	fdt = blob;
+
+	/* Don't use local copy as Kernel claims this memory after mem init
+	 * As a result, FDT can not be parsed in kernel modules
+	 */
+#ifdef USE_LOCAL_FDT_COPY
+	{
+		int err;
+		int bufsize;
+
+		bufsize = fdt_totalsize(fdt) + EXPAND_GRANULARITY;
+		buf = malloc(bufsize);
+		//if(!buf)
+		//	fatal("malloc failed. can't relocate the device tree\n\r");
+
+		err = fdt_open_into(fdt, buf, bufsize);
+
+		//if (err != 0)
+		//	fatal("fdt_init(): %s\n\r", fdt_strerror(err));
+
+		fdt = buf;
+	}
+#endif
+	return fdt;
+}
diff --git a/drivers/misc/netlogic/soc_interface/nlm_cpumask.h b/drivers/misc/netlogic/soc_interface/nlm_cpumask.h
new file mode 100644
index 0000000..e6b542f
--- /dev/null
+++ b/drivers/misc/netlogic/soc_interface/nlm_cpumask.h
@@ -0,0 +1,59 @@
+#ifndef CONFIG_CPU_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
+#ifndef _ASM_NETLOGIC_CPUMASK_H
+#define _ASM_NETLOGIC_CPUMASK_H
+
+#include <linux/cpumask.h>
+#include <linux/sched.h>
+
+#define CPUMASK_BUF 256
+
+static __inline__ unsigned int cpumask_to_uint32(cpumask_t *cpumask)
+{
+	unsigned int mask = 0;
+	int i;
+
+	for (i = 0; i < 32; i++) {
+		if (cpumask_test_cpu(i, cpumask)) {
+			mask |= (1 << i);
+		}
+	}
+	return mask;
+}
+
+static __inline__ void uint32_to_cpumask(cpumask_t *cpumask, unsigned int mask)
+{
+	int i;
+
+	for (i = 0; i < 32; i++) {
+		if (mask & (1 << i)) {
+			cpumask_set_cpu(i, cpumask);
+		}
+		else {
+			cpumask_clear_cpu(i, cpumask);
+		}
+	}
+}
+
+static __inline__ void sched_bindto_save_affinity(int cpu, struct cpumask *mask)
+{
+	struct cpumask node0cpu0mask;
+
+	/* Save the current affinity mask */
+	sched_getaffinity(0, mask);
+
+	/* Force the process to run on the specified cpu */
+	cpumask_clear(&node0cpu0mask);
+	cpumask_set_cpu(cpu, &node0cpu0mask);
+
+	sched_setaffinity(0, &node0cpu0mask);
+}
+
+static __inline__ void sched_bindto_restore_affinity(struct cpumask *mask)
+{
+	sched_setaffinity(0, mask);
+}
+
+
+#endif /* _ASM_NETLOGIC_CPUMASK_H */
diff --git a/drivers/misc/netlogic/soc_interface/nlm_debug.h b/drivers/misc/netlogic/soc_interface/nlm_debug.h
new file mode 100644
index 0000000..6acdd4a
--- /dev/null
+++ b/drivers/misc/netlogic/soc_interface/nlm_debug.h
@@ -0,0 +1,119 @@
+#ifndef CONFIG_CPU_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
+/*-
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#ifndef _ASM_NLM_DEBUG_H
+#define _ASM_NLM_DEBUG_H
+
+/*Enable below macro to enable net stats. */
+//#define CONFIG_NLM_STATS
+extern void prom_printf(char *fmt, ...);
+#include <linux/threads.h>
+#include <asm/atomic.h>
+
+enum {
+  //cacheline 0
+  MSGRNG_INT,
+  MSGRNG_PIC_INT,
+  MSGRNG_MSG,
+  MSGRNG_EXIT_STATUS,
+  MSGRNG_MSG_CYCLES,
+  //cacheline 1
+  NETIF_TX = 8,
+  NETIF_RX,
+  NETIF_TX_COMPLETE,
+  NETIF_TX_COMPLETE_TX,
+  NETIF_RX_CYCLES,
+  NETIF_TX_COMPLETE_CYCLES,
+  NETIF_TX_CYCLES,
+  NETIF_TIMER_START_Q,
+  //NETIF_REG_FRIN,
+  //NETIF_INT_REG,
+  //cacheline 2
+  REPLENISH_ENTER = 16,
+  REPLENISH_ENTER_COUNT,
+  REPLENISH_CPU,
+  REPLENISH_FRIN,
+  REPLENISH_CYCLES,
+  NETIF_STACK_TX,
+  NETIF_START_Q,
+  NETIF_STOP_Q,
+  //cacheline 3
+  USER_MAC_START = 24,
+  USER_MAC_INT   = 24,
+  USER_MAC_TX_COMPLETE,
+  USER_MAC_RX,
+  USER_MAC_POLL,
+  USER_MAC_TX,
+  USER_MAC_TX_FAIL,
+  USER_MAC_TX_COUNT,
+  USER_MAC_FRIN,
+  //cacheline 4
+  USER_MAC_TX_FAIL_GMAC_CREDITS = 32,
+  USER_MAC_DO_PAGE_FAULT,
+  USER_MAC_UPDATE_TLB,
+  USER_MAC_UPDATE_TLB_PFN0,
+  USER_MAC_UPDATE_TLB_PFN1,
+  
+  NLM_MAX_COUNTERS = 40
+};
+extern atomic_t nlm_common_counters[NR_CPUS][NLM_MAX_COUNTERS];
+extern __u32 msgrng_msg_cycles;
+
+#ifdef CONFIG_NLM_STATS 
+#define xlr_inc_counter(x) atomic_inc(&nlm_common_counters[0][(x)])
+#define nlm_common_dec_counter(x) atomic_dec(&nlm_common_counters[0][(x)])
+#define xlr_set_counter(x, value) atomic_set(&nlm_common_counters[0][(x)], (value))
+#define nlm_common_get_counter(x) atomic_read(&nlm_common_counters[0][(x)])
+#else
+#define xlr_inc_counter(x) //atomic_inc(&nlm_common_counters[0][(x)])
+#define nlm_common_dec_counter(x) //atomic_dec(&nlm_common_counters[0][(x)])
+#define xlr_set_counter(x, value) //atomic_set(&nlm_common_counters[0][(x)], (value))
+#define nlm_common_get_counter(x) //atomic_read(&nlm_common_counters[0][(x)])
+#endif
+#if 0
+#define dbg_msg(fmt, args...) printk("[%s@%d|%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __FUNCTION__,  smp_processor_id(), ##args)
+
+#define dbg_panic(fmt, args...) panic("[%s@%d|:%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __FUNCTION__, smp_processor_id(), ##args)
+
+#define prom_dbg_msg(fmt, args...) prom_printf("[%s@%d|%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __FUNCTION__,  smp_processor_id(), ##args)
+#else
+#define dbg_msg(fmt, args...)
+
+#define dbg_panic(fmt, args...) panic(fmt, ##args)
+
+#define prom_dbg_msg(fmt, args...) printk(fmt, ##args)
+#endif
+
+#endif
diff --git a/drivers/misc/netlogic/soc_interface/on_chip.c b/drivers/misc/netlogic/soc_interface/on_chip.c
new file mode 100644
index 0000000..169cc57
--- /dev/null
+++ b/drivers/misc/netlogic/soc_interface/on_chip.c
@@ -0,0 +1,1032 @@
+/*-
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/hardirq.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/timer.h>
+
+#include "nlm_msgring.h"
+#include "nlm_xlp.h"
+#include "nlm_debug.h"
+#include "nlm_hal.h"
+#include "libfdt.h"   /*fdt*/
+#include "ops.h"   /*fdt*/
+
+#ifdef CONFIG_XLP_FMN_SUPPORT
+#include "nlm_hal_fmn.h"
+#endif
+
+#include <linux/netdevice.h>
+
+#define MAX_VC	4096
+
+static int is_cpu_core_xlp_ii = 0;
+unsigned int xlp_napi_vc_mask = 0;
+
+cpumask_t phys_cpu_present_map;
+EXPORT_SYMBOL(phys_cpu_present_map);
+
+atomic_t nlm_common_counters[NR_CPUS][NLM_MAX_COUNTERS] __cacheline_aligned;
+
+extern int xlp_rvec_from_irt(int);
+extern int xlp_rvec_from_irq(int);
+unsigned long netlogic_io_base = (unsigned long)(DEFAULT_NETLOGIC_IO_BASE);
+EXPORT_SYMBOL(netlogic_io_base);
+
+extern void nlm_cpu_stat_update_msgring_int(void);
+extern void nlm_cpu_stat_update_msgring_cycles(__u32 cycles);
+extern void nlm_cpu_stat_update_msgring_pic_int(void);
+extern void *fdt;
+EXPORT_SYMBOL(fdt);
+
+uint32_t msgring_global_thread_mask = 0;
+uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE] = {0};
+
+uint32_t nlm_l1_lock[NR_CPUS/4] = {0};
+
+#ifdef CONFIG_XLP_FMN_SUPPORT
+typedef int (*vchandler)(int vc, int budget);
+static vchandler xlp_napi_vc_handlers[NLM_MAX_VC_PER_THREAD];
+
+typedef int (*intr_vchandler)(int vc);
+static intr_vchandler xlp_intr_vc_handler;
+unsigned int intr_vc_mask[NR_CPUS];
+
+/* make this a read/write spinlock */
+spinlock_t msgrng_lock;
+static nlm_common_atomic_t msgring_registered;
+
+struct msgstn_handler {
+        void (*action)(uint32_t, uint32_t, uint32_t, uint32_t, uint64_t, uint64_t, uint64_t, uint64_t, void *);
+        void *dev_id;
+	void (*napi_final)(void *arg);
+	void *napi_final_arg;
+};
+
+static int napi_final_needed[NR_CPUS][XLP_MSG_HANDLE_MAX];
+struct net_device xlp_napi_fmn_dummy_dev;
+DEFINE_PER_CPU(struct napi_struct, xlp_napi_fmn_poll_struct);
+DEFINE_PER_CPU(unsigned long long, xlp_napi_fmn_rx_count);
+static int xlp_napi_vc_count = 0;
+static int xlp_fmn_init_done = 0;
+extern unsigned int xlp_napi_vc_mask;
+
+static uint16_t vc_to_handle_map[MAX_VC] = {
+	[0 ... 15] = XLP_MSG_HANDLE_CPU0,
+	[16 ... 31] = XLP_MSG_HANDLE_CPU1,
+	[32 ... 47] = XLP_MSG_HANDLE_CPU2,
+	[48 ... 63] = XLP_MSG_HANDLE_CPU3,
+	[64 ... 79] = XLP_MSG_HANDLE_CPU4,
+	[80 ... 95] = XLP_MSG_HANDLE_CPU5,
+	[96 ... 111] = XLP_MSG_HANDLE_CPU6,
+	[112 ... 127] = XLP_MSG_HANDLE_CPU7,
+	[128 ... 143] = XLP_MSG_HANDLE_CPU0,
+	[144 ... 159] = XLP_MSG_HANDLE_CPU1,
+	[160 ... 175] = XLP_MSG_HANDLE_CPU2,
+	[176 ... 191] = XLP_MSG_HANDLE_CPU3,
+	[192 ... 207] = XLP_MSG_HANDLE_CPU4,
+	[208 ... 223] = XLP_MSG_HANDLE_CPU5,
+	[224 ... 239] = XLP_MSG_HANDLE_CPU6,
+	[240 ... 255] = XLP_MSG_HANDLE_CPU7,
+	[256 ... 257] = XLP_MSG_HANDLE_PCIE0,
+	[258 ... 259] = XLP_MSG_HANDLE_PCIE1,
+	[260 ... 261] = XLP_MSG_HANDLE_PCIE2,
+	[262 ... 263] = XLP_MSG_HANDLE_PCIE3,
+	[264 ... 267] = XLP_MSG_HANDLE_DTRE,
+	[268 ... 271] = XLP_MSG_HANDLE_GDX,
+	[272 ... 280] = XLP_MSG_HANDLE_RSA_ECC,
+	[281 ... 296] = XLP_MSG_HANDLE_CRYPTO,
+	[297 ... 304] = XLP_MSG_HANDLE_CMP,
+	[305 ... 383] = XLP_MSG_HANDLE_INVALID,
+	[384 ... 391] = XLP_MSG_HANDLE_NAE_0,
+	[392 ... 475] = XLP_MSG_HANDLE_INVALID,
+	[476 ... 1019] = XLP_MSG_HANDLE_NAE_0,
+	[1020 ... 1023] = XLP_MSG_HANDLE_INVALID,
+	//NODE-1
+	[1024 ... 1039] = XLP_MSG_HANDLE_CPU0,
+	[1040 ... 1055] = XLP_MSG_HANDLE_CPU1,
+	[1056 ... 1071] = XLP_MSG_HANDLE_CPU2,
+	[1072 ... 1087] = XLP_MSG_HANDLE_CPU3,
+	[1088 ... 1103] = XLP_MSG_HANDLE_CPU4,
+	[1104 ... 1119] = XLP_MSG_HANDLE_CPU5,
+	[1120 ... 1135] = XLP_MSG_HANDLE_CPU6,
+	[1136 ... 1151] = XLP_MSG_HANDLE_CPU7,
+	[1158 ... 1279] = XLP_MSG_HANDLE_INVALID,
+	[1280 ... 1281] = XLP_MSG_HANDLE_PCIE0,
+	[1282 ... 1283] = XLP_MSG_HANDLE_PCIE1,
+	[1284 ... 1285] = XLP_MSG_HANDLE_PCIE2,
+	[1286 ... 1287] = XLP_MSG_HANDLE_PCIE3,
+	[1288 ... 1291] = XLP_MSG_HANDLE_DTRE,
+	[1292 ... 1295] = XLP_MSG_HANDLE_GDX,
+	[1296 ... 1304] = XLP_MSG_HANDLE_RSA_ECC,
+	[1305 ... 1320] = XLP_MSG_HANDLE_CRYPTO,
+	[1321 ... 1328] = XLP_MSG_HANDLE_CMP,
+	[1329 ... 1407] = XLP_MSG_HANDLE_INVALID,
+	[1408 ... 1415] = XLP_MSG_HANDLE_NAE_0,
+	[1416 ... 1499] = XLP_MSG_HANDLE_INVALID,
+	[1500 ... 2043] = XLP_MSG_HANDLE_NAE_0,
+	[2044 ... 2047] = XLP_MSG_HANDLE_INVALID,
+	// NODE-2	
+	[2048 ... 2063] = XLP_MSG_HANDLE_CPU0,
+	[2064 ... 2079] = XLP_MSG_HANDLE_CPU1,
+	[2080 ... 2095] = XLP_MSG_HANDLE_CPU2,
+	[2096 ... 2111] = XLP_MSG_HANDLE_CPU3,
+	[2112 ... 2127] = XLP_MSG_HANDLE_CPU4,
+	[2128 ... 2143] = XLP_MSG_HANDLE_CPU5,
+	[2144 ... 2159] = XLP_MSG_HANDLE_CPU6,
+	[2160 ... 2175] = XLP_MSG_HANDLE_CPU7,
+	[2176 ... 2303] = XLP_MSG_HANDLE_INVALID,
+	[2304 ... 2305] = XLP_MSG_HANDLE_PCIE0,
+	[2306 ... 2307] = XLP_MSG_HANDLE_PCIE1,
+	[2308 ... 2309] = XLP_MSG_HANDLE_PCIE2,
+	[2310 ... 2311] = XLP_MSG_HANDLE_PCIE3,
+	[2312 ... 2315] = XLP_MSG_HANDLE_DTRE,
+	[2316 ... 2319] = XLP_MSG_HANDLE_GDX,
+	[2320 ... 2328] = XLP_MSG_HANDLE_RSA_ECC,
+	[2329 ... 2344] = XLP_MSG_HANDLE_CRYPTO,
+	[2345 ... 2352] = XLP_MSG_HANDLE_CMP, 
+	[2353 ... 2431] = XLP_MSG_HANDLE_INVALID,
+	[2432 ... 2439] = XLP_MSG_HANDLE_NAE_0,
+	[2440 ... 2523] = XLP_MSG_HANDLE_INVALID,
+	[2524 ... 3067] = XLP_MSG_HANDLE_NAE_0,
+	[3068 ... 3071] = XLP_MSG_HANDLE_INVALID,
+
+	// NODE-3
+	[3072 ... 3087] = XLP_MSG_HANDLE_CPU0,
+	[3088 ... 3103] = XLP_MSG_HANDLE_CPU1,
+	[3104 ... 3119] = XLP_MSG_HANDLE_CPU2,
+	[3120 ... 3135] = XLP_MSG_HANDLE_CPU3,
+	[3136 ... 3151] = XLP_MSG_HANDLE_CPU4,
+	[3152 ... 3167] = XLP_MSG_HANDLE_CPU5,
+	[3168 ... 3183] = XLP_MSG_HANDLE_CPU6,
+	[3184 ... 3199] = XLP_MSG_HANDLE_CPU7,
+	[3200 ... 3327] = XLP_MSG_HANDLE_INVALID,
+	[3328 ... 3329] = XLP_MSG_HANDLE_PCIE0,
+	[3330 ... 3331] = XLP_MSG_HANDLE_PCIE1,
+	[3332 ... 3333] = XLP_MSG_HANDLE_PCIE2,
+	[3334 ... 3335] = XLP_MSG_HANDLE_PCIE3,
+	[3336 ... 3339] = XLP_MSG_HANDLE_DTRE,
+	[3340 ... 3343] = XLP_MSG_HANDLE_GDX,
+	[3344 ... 3352] = XLP_MSG_HANDLE_RSA_ECC,
+	[3353 ... 3368] = XLP_MSG_HANDLE_CRYPTO,
+	[3369 ... 3376] = XLP_MSG_HANDLE_CMP,
+	[3377 ... 3455] = XLP_MSG_HANDLE_INVALID,
+	[3456 ... 3463] = XLP_MSG_HANDLE_NAE_0,
+	[3464 ... 3547] = XLP_MSG_HANDLE_INVALID,
+	[3548 ... 4091] = XLP_MSG_HANDLE_NAE_0,
+	[4092 ... 4095] = XLP_MSG_HANDLE_INVALID,
+};
+
+static uint16_t xlp3xx_vc_to_handle_map[MAX_VC] = {
+	[0 ... 15] = XLP_MSG_HANDLE_CPU0,
+	[16 ... 31] = XLP_MSG_HANDLE_CPU1,
+	[32 ... 47] = XLP_MSG_HANDLE_CPU2,
+	[48 ... 63] = XLP_MSG_HANDLE_CPU3,
+	[64 ... 79] = XLP_MSG_HANDLE_INVALID,
+	[80 ... 95] = XLP_MSG_HANDLE_INVALID,
+	[96 ... 111] = XLP_MSG_HANDLE_INVALID,
+	[112 ... 127] = XLP_MSG_HANDLE_INVALID,
+	[128 ... 143] = XLP_MSG_HANDLE_CPU0,
+	[144 ... 159] = XLP_MSG_HANDLE_CPU1,
+	[160 ... 175] = XLP_MSG_HANDLE_CPU2,
+	[176 ... 191] = XLP_MSG_HANDLE_CPU3,
+	[192 ... 207] = XLP_MSG_HANDLE_INVALID,
+	[208 ... 223] = XLP_MSG_HANDLE_INVALID,
+	[224 ... 239] = XLP_MSG_HANDLE_INVALID,
+	[240 ... 255] = XLP_MSG_HANDLE_INVALID,
+	[256 ... 257] = XLP_MSG_HANDLE_PCIE0,
+	[258 ... 259] = XLP_MSG_HANDLE_PCIE1,
+	[260 ... 261] = XLP_MSG_HANDLE_PCIE2,
+	[262 ... 263] = XLP_MSG_HANDLE_PCIE3,
+	[264 ... 267] = XLP_MSG_HANDLE_DTRE,
+	[268 ... 271] = XLP_MSG_HANDLE_REGX,
+	[272 ... 275] = XLP_MSG_HANDLE_RSA_ECC,
+	[276 ... 279] = XLP_MSG_HANDLE_CRYPTO,
+	[280 ... 288] = XLP_MSG_HANDLE_SRIO,
+	[289 ... 383] = XLP_MSG_HANDLE_INVALID,
+	[384 ... 391] = XLP_MSG_HANDLE_NAE_0,
+	[392 ... 431] = XLP_MSG_HANDLE_INVALID,
+	[432 ... 511] = XLP_MSG_HANDLE_NAE_0,
+	[512 ... 4095]= XLP_MSG_HANDLE_INVALID
+};
+
+static uint16_t xlp2xx_vc_to_handle_map[MAX_VC] = {
+	[0 ... 15] = XLP_MSG_HANDLE_CPU0,
+	[16 ... 31] = XLP_MSG_HANDLE_CPU1,
+	[32 ... 127] = XLP_MSG_HANDLE_INVALID,
+	[128 ... 143] = XLP_MSG_HANDLE_CPU0,
+	[144 ... 159] = XLP_MSG_HANDLE_CPU1,
+	[160 ... 255] = XLP_MSG_HANDLE_INVALID,
+	[256 ... 257] = XLP_MSG_HANDLE_PCIE0,
+	[258 ... 259] = XLP_MSG_HANDLE_PCIE1,
+	[260 ... 261] = XLP_MSG_HANDLE_PCIE2,
+	[262 ... 263] = XLP_MSG_HANDLE_PCIE3,
+	[264 ... 265] = XLP_MSG_HANDLE_DTRE,
+	[266 ... 267] = XLP_MSG_HANDLE_CMP,
+	[268 ... 271] = XLP_MSG_HANDLE_REGX,
+	[272 ... 272] = XLP_MSG_HANDLE_RSA_ECC,
+	[273 ... 275] = XLP_MSG_HANDLE_INVALID,
+	[276 ... 276] = XLP_MSG_HANDLE_CRYPTO,
+	[277 ... 383] = XLP_MSG_HANDLE_INVALID,
+	[384 ... 391] = XLP_MSG_HANDLE_NAE_0,
+	[392 ... 431] = XLP_MSG_HANDLE_INVALID,
+	[432 ... 503] = XLP_MSG_HANDLE_NAE_0,
+	[504 ... 4095]= XLP_MSG_HANDLE_INVALID
+
+};
+
+static uint16_t *vc_to_handle = vc_to_handle_map;
+
+/******************************************************************************************
+ *  dummy_handler 
+ *
+ *  @vc		cpu vc number
+ *  @src_id	msg sender station vc
+ *  @size	msg_size-1
+ *  @code	software code nae or poe can put in
+ *  @msg0	64 bit msg0 structure 
+ *  @msg1	64 bit msg1 structure 
+ *  @msg2	64 bit msg2 structure 
+ *  @msg3	64 bit msg3 structure 
+ *  @dev_id	driver write can save a device id here
+ *
+ ******************************************************************************************/
+void dummy_handler(uint32_t vc, uint32_t src_id, uint32_t size, uint32_t code, 
+		   uint64_t msg0, uint64_t msg1, uint64_t msg2, uint64_t msg3, void *dev_id)
+{
+#if 0
+	printk("[%s]: No Handler for message from stn_id=%d, bucket=%d, "
+	       "size=%d, msg0=%llx, msg1=%llx dropping message\n",
+	       __FUNCTION__, src_id, vc, size,
+	       (unsigned long long)msg0, (unsigned long long)msg1);
+#endif
+}
+
+/******************************************************************************************
+ *
+ * intial msg_hander_map with dummy_handler, when real driver msgring handler registered
+ * it will override the entry with hander driver writer provided
+ *
+ ******************************************************************************************/
+struct msgstn_handler msg_handler_map[XLP_MSG_HANDLE_MAX] = {
+	[0 ... (XLP_MSG_HANDLE_MAX-1)] = {dummy_handler, NULL, NULL, NULL},
+};
+
+
+int nlm_xlp_register_napi_vc_handler(int vc, int (*handler)(int vc, int budget))
+{
+	if(vc < 0 || vc >= NLM_MAX_VC_PER_THREAD) {
+		printk("%s, Error, invalid VC Passed %d\n", __FUNCTION__, vc);
+		return -1;
+	}
+
+	if(!((1 << vc) & xlp_napi_vc_mask)) {
+		printk("%s , Error, VC is not specified in napi vc mask\n", __FUNCTION__);
+		return -1;
+	}
+
+	if(!xlp_fmn_init_done)
+		xlp_fmn_init_done = 1;
+	
+	xlp_napi_vc_handlers[vc] = handler;
+	return 0;
+}
+EXPORT_SYMBOL(nlm_xlp_register_napi_vc_handler);
+
+
+int nlm_xlp_unregister_napi_vc_handler(int vc)
+{
+	if(vc < 0 || vc >= NLM_MAX_VC_PER_THREAD) {
+		printk("%s, Error, invalid VC Passed %d\n", __FUNCTION__, vc);
+		return -1;
+	}
+	xlp_napi_vc_handlers[vc] = NULL;
+	return 0;
+}
+EXPORT_SYMBOL(nlm_xlp_unregister_napi_vc_handler);
+
+int nlm_xlp_register_intr_vc_handler(int (*handler)(int vc))
+{
+	xlp_intr_vc_handler = handler;
+	return 0;
+}
+EXPORT_SYMBOL(nlm_xlp_register_intr_vc_handler);
+
+int nlm_xlp_register_intr_vc(int cpu, int vc)
+{
+	int node;
+	unsigned long flags;
+
+	if(vc < 0 || vc >= NLM_MAX_VC_PER_THREAD) {
+		printk("%s, Error, invalid VC Passed %d\n", __FUNCTION__, vc);
+		return -1;
+	}
+
+	if(!xlp_fmn_init_done)
+		xlp_fmn_init_done = 1;
+	
+	node = cpu / 32;
+	nlm_hal_enable_vc_intr(node, (cpu*4 + vc) & 0x7f);
+
+	spin_lock_irqsave(&msgrng_lock, flags);
+	intr_vc_mask[cpu] |= (1 << vc);
+	spin_unlock_irqrestore(&msgrng_lock, flags);
+	
+	/*printk("%s in, cpu %d intr_vc_mask %x\n", __FUNCTION__, cpu, intr_vc_mask[cpu]);*/
+	return 0;
+}
+EXPORT_SYMBOL(nlm_xlp_register_intr_vc);
+
+int nlm_xlp_unregister_intr_vc(int cpu, int vc)
+{
+	unsigned long flags;
+
+	if(vc < 0 || vc >= NLM_MAX_VC_PER_THREAD) {
+		printk("%s, Error, invalid VC Passed %d\n", __FUNCTION__, vc);
+		return -1;
+	}
+
+	spin_lock_irqsave(&msgrng_lock, flags);
+	intr_vc_mask[cpu] &= (~(1 << vc));
+	spin_unlock_irqrestore(&msgrng_lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL(nlm_xlp_unregister_intr_vc);
+
+/*********************************************************************
+ * nlm_xlp_msgring_int_handler 
+ *
+ *  @irq	msgring irq number
+ *  @regs	linux systems call back function provide struct pt_regs 
+ *  
+ ********************************************************************/
+void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
+{
+	unsigned long mflags;
+	int vc = 0;
+	uint32_t size = 0, code = 0, src_id = 0, cycles = 0;
+	struct msgstn_handler *handler = 0;
+	unsigned int status = 0;
+	uint64_t msg0, msg1, msg2, msg3;
+	unsigned int msg_status1 = 0, vc_empty_status = 0;
+	int cpu = hard_smp_processor_id();
+	int pop_vc_mask = nlm_cpu_vc_mask[cpu];
+	uint32_t napi_vc_mask = xlp_napi_vc_mask & pop_vc_mask;
+	unsigned int vcmask;
+
+	msg0 = msg1 = msg2 = msg3 = 0;
+	
+	if (irq == XLP_IRQ_MSGRING_RVEC) {
+                /* normal message ring interrupt */
+                /* xlr_inc_counter(MSGRNG_INT);  */
+                nlm_cpu_stat_update_msgring_int();
+        } else {
+                nlm_cpu_stat_update_msgring_pic_int();
+        }
+
+
+        msgrng_access_enable(mflags);
+	cycles = read_c0_count();
+
+	for (;;) {
+
+		/* Read latest VC empty mask */
+		msg_status1 = xlp_read_status1();
+
+		vcmask = (~(msg_status1>>24) & intr_vc_mask[cpu]);
+		if(vcmask && xlp_intr_vc_handler) {
+			for(vc = 0; vc < 4; vc++) {
+				if(!(vcmask & (1<<vc)))
+					continue;
+				xlp_intr_vc_handler(vc);
+			}
+		}
+
+		if((~(msg_status1>>24) & napi_vc_mask) && xlp_fmn_init_done) {
+			struct napi_struct *napi;
+
+			/*Schedule napi routine to process messages from napi vc*/
+		        napi = &__get_cpu_var(xlp_napi_fmn_poll_struct);
+		        napi_schedule(napi);
+			pop_vc_mask = pop_vc_mask & ~napi_vc_mask;
+		}
+
+		vc_empty_status = (msg_status1 >> 24) & pop_vc_mask;
+		if (vc_empty_status == pop_vc_mask) break;  
+
+		for( vc = 0; vc < 4; vc++)
+		{
+			if(!(pop_vc_mask & (1<<vc)))
+				continue;
+			status = xlp_message_receive( vc, &src_id, &size, &code, &msg0, &msg1, &msg2, &msg3);
+			if(status != 0)
+				continue;
+
+			handler = &msg_handler_map[vc_to_handle[src_id]];
+
+			/* Execute device driver fmn handler */
+			(handler->action)(vc, src_id, size, code,
+					  msg0, msg1, msg2, msg3, handler->dev_id);
+
+		}
+	}
+	nlm_cpu_stat_update_msgring_cycles(read_c0_count() - cycles);
+
+	/* Clear VC interrupt status by writing 1s */
+        if (is_cpu_core_xlp_ii) {
+                xlp_write_msg_int((pop_vc_mask));
+        } else {
+                xlp_write_status1( (msg_status1 | (pop_vc_mask << 16)) );
+        }
+
+        msgrng_access_disable(mflags);
+}
+
+EXPORT_SYMBOL(nlm_xlp_msgring_int_handler);
+
+static DEFINE_PER_CPU(struct timer_list, msg_int_bkup_timer);
+static int msg_handler_timer_enabled=0;
+static void msg_timer_handler(unsigned long data)
+{
+	int cpu = smp_processor_id();
+	struct timer_list *timer = &per_cpu(msg_int_bkup_timer, cpu);
+
+
+	nlm_xlp_msgring_int_handler(XLP_IRQ_MSGRING_RVEC, NULL);
+
+	mod_timer_pinned(timer, jiffies + (HZ/100));
+}
+void init_msg_bkp_timer(void *data)
+{
+	int cpu = smp_processor_id();
+	struct timer_list *timer = &per_cpu(msg_int_bkup_timer, cpu);
+
+	init_timer(timer);
+	timer->expires = jiffies + 10;
+	timer->data = 0;
+	timer->function = msg_timer_handler;
+	add_timer_on(timer, cpu);
+}
+
+void xlp_poll_vc0_messages(void)
+{
+        int vc = 0;
+        uint32_t size = 0, code = 0, src_id = 0;
+        struct msgstn_handler *handler = 0;
+        unsigned int status = 0;
+        uint64_t msg0, msg1, msg2, msg3;
+        unsigned int msg_status1 = 0, vc_empty_status = 0;
+        int loop = 0;
+        int pop_vc_mask = 0x1;
+	unsigned long mflags;
+#if 0
+	if (hard_smp_processor_id() != 0)
+		printk("Called handler on cpu %d from %s msgstatus: 0x%x\n",
+			       hard_smp_processor_id(),
+			       __FUNCTION__,xlp_read_status1());
+#endif
+        msg0 = msg1 = msg2 = msg3 = 0;
+        msgrng_access_enable(mflags);
+        for (loop = 0; loop < 16; loop++) {
+                /* Read latest VC empty mask */
+                msg_status1 = xlp_read_status1();
+                vc_empty_status = (msg_status1 >> 24) & pop_vc_mask;
+                if (vc_empty_status == pop_vc_mask)
+                        break;
+                status = xlp_message_receive( vc, &src_id, &size, &code, &msg0, &msg1, &msg2, &msg3);
+                if(status != 0)
+                        continue;
+                handler = &msg_handler_map[vc_to_handle_map[src_id]];
+                /* Execute device driver fmn handler */
+                (handler->action)(vc, src_id, size, code,
+                                msg0, msg1, msg2, msg3, handler->dev_id);
+        }
+        msgrng_access_disable(mflags);
+}
+EXPORT_SYMBOL(xlp_poll_vc0_messages);
+
+/*******************************************************************************************
+ *  register_xlp_msgring_handler 
+ *
+ *  @major      handler id number, each type handler has an ID
+ *  @action     handler callback function (see dummy_handler above for detail)
+ *  @dev_id	optional dev_id paramter for driver write to save device id
+ *******************************************************************************************/
+int register_xlp_msgring_handler(int major,
+			     void (*action) (uint32_t, uint32_t, uint32_t, uint32_t,
+					     uint64_t, uint64_t, uint64_t, uint64_t, void *),
+			     void *dev_id)
+{
+	int ret = 1;
+	unsigned long flags = 0;
+
+	if (major >= XLP_MSG_HANDLE_MAX || action == NULL) {
+		printk(KERN_ALERT "%s:%d  Invalid parameter: major=%d, "
+		       "XLP_MAX_TX_STN=%d action=%p",
+		       __FUNCTION__, __LINE__, major, XLP_MAX_TX_STNS, action);
+		return ret;
+	}
+
+	/* Check if the message station is valid, if not return error */
+	spin_lock_irqsave(&msgrng_lock, flags);
+
+	if(!xlp_fmn_init_done)
+		xlp_fmn_init_done = 1;
+
+	if (is_nlm_xlp8xx_ax()) {
+		if(msg_handler_timer_enabled == 0) {
+			msg_handler_timer_enabled = 1;
+			spin_unlock_irqrestore(&msgrng_lock, flags);
+			// init_msg_bkp_timer(0);	Not required, taken care by on_each_cpu()
+			on_each_cpu(init_msg_bkp_timer, 0, 1);
+			spin_lock_irqsave(&msgrng_lock, flags);
+		}
+	}
+
+	msg_handler_map[major].action = action;
+	msg_handler_map[major].dev_id = dev_id;
+
+	ret = 0;
+	msgring_registered.value = 1;
+
+	spin_unlock_irqrestore(&msgrng_lock, flags);
+
+	return ret;
+}
+
+EXPORT_SYMBOL(register_xlp_msgring_handler);
+
+int unregister_xlp_msgring_handler(int major, void *dev_id)
+{
+	unsigned long flags;
+
+	if(major >= XLP_MSG_HANDLE_MAX){
+		printk(KERN_ALERT "%s:%d  Invalid parameter: major=%d, "
+		       "XLP_MAX_TX_STN=%d", __FUNCTION__, __LINE__, major,
+		       XLP_MAX_TX_STNS);
+		return -1;
+	}
+	spin_lock_irqsave(&msgrng_lock, flags);
+	if(msg_handler_map[major].dev_id == dev_id){
+		msg_handler_map[major].action = dummy_handler;
+		msg_handler_map[major].dev_id = NULL;
+		msg_handler_map[major].napi_final = NULL;
+		msg_handler_map[major].napi_final_arg = NULL;
+	}
+	spin_unlock_irqrestore(&msgrng_lock, flags);
+	return 0;
+}
+
+EXPORT_SYMBOL(unregister_xlp_msgring_handler);
+
+int nlm_xlp_register_napi_final_handler(int major, void (*napi_final)(void *arg), void *arg)
+{
+      if(major >= XLP_MSG_HANDLE_MAX){
+              printk(KERN_ALERT "%s:%d  Invalid parameter: major=%d, "
+                    "XLP_MAX_TX_STN=%d", __FUNCTION__, __LINE__, major,
+                     XLP_MAX_TX_STNS);
+              return -1;
+      }
+      msg_handler_map[major].napi_final = napi_final;
+      msg_handler_map[major].napi_final_arg = arg;
+      return 0;
+}
+
+EXPORT_SYMBOL(nlm_xlp_register_napi_final_handler);
+
+
+#include "nlm_cpumask.h"
+
+/*********************************************************************
+ * enable_msgconfig_int 
+ *
+ ********************************************************************/
+void enable_msgconfig_int(void *data)
+{
+	unsigned long flags  = 0;
+
+	/* Need write interrupt vector to cp2 msgconfig register */
+	msgrng_access_enable(flags);
+	nlm_hal_set_fmn_interrupt(XLP_IRQ_MSGRING_RVEC);
+	msgrng_access_disable(flags);
+}
+
+/*********************************************************************
+ * nlm_enable_vc_intr
+ *********************************************************************/
+void nlm_enable_vc_intr(void)
+{
+	int cpu, node;
+	int vc_index = 0;
+	int i = 0;
+
+	for(cpu=0; cpu<NR_CPUS; cpu++){
+                if(!cpumask_test_cpu(cpu, &phys_cpu_present_map))
+                        continue;
+		node = cpu / 32;
+		for(i=0; i<NLM_MAX_VC_PER_THREAD; i++)
+		{
+			vc_index = (i + cpu*NLM_MAX_VC_PER_THREAD) & 0x7f;
+			if(nlm_cpu_vc_mask[cpu] & (1<<i)){
+				/*enable interrupts*/
+				nlm_hal_enable_vc_intr(node, vc_index);
+			}else{
+				nlm_hal_disable_vc_intr(node, vc_index);
+			}
+		}
+	}
+}
+
+
+int xlp_fmn_poll(struct napi_struct *napi, int budget)
+{
+	int vc = 0;
+	uint32_t size = 0, code = 0, src_id = 0;
+	struct msgstn_handler *handler = 0;
+	unsigned int status = 0;
+	uint64_t msg0=0, msg1=0, msg2=0, msg3=0;
+	int cpu = hard_smp_processor_id();
+	int count = 0;
+	int no_msg = 0;
+	uint32_t napi_vc_mask = xlp_napi_vc_mask & nlm_cpu_vc_mask[cpu];
+	unsigned long mflags;
+	unsigned long napi_final_hndlr[XLP_MSG_HANDLE_MAX];
+	int hndlr_cnt = 0, hndlr_id, i, rv;
+
+	while(count < budget){
+		for( no_msg = 0, vc = 0; vc < 4; vc++)
+		{
+			
+			if(!(napi_vc_mask & (1<<vc)))
+				continue;
+	
+			/* Explicit per vc napi handlers. Here the vc handler does the polling of
+			 all the packets */
+			if(xlp_napi_vc_handlers[vc]) {
+				rv = (xlp_napi_vc_handlers)[vc](vc, budget);
+				count += rv;
+				if(rv == 0)
+					no_msg++;
+				continue;
+			}
+			
+			msgrng_access_enable(mflags);
+			status = xlp_message_receive( vc, &src_id, &size, &code, &msg0, &msg1, &msg2, &msg3);
+			msgrng_access_disable(mflags);
+			if(status != 0){
+				no_msg++;
+				continue;
+			}
+			count++;
+			hndlr_id = vc_to_handle[src_id];
+			handler = &msg_handler_map[hndlr_id];
+
+			/* Execute device driver fmn handler */
+			(handler->action)(vc, src_id, size, code,
+				  msg0, msg1, msg2, msg3, handler->dev_id);
+
+			if(handler->napi_final && (napi_final_needed[cpu][hndlr_id] == 0)) {
+				napi_final_needed[cpu][hndlr_id] = 1;
+				napi_final_hndlr[hndlr_cnt] = (unsigned long)handler;
+				hndlr_cnt++;
+			}
+		}
+		if(no_msg == xlp_napi_vc_count)
+			break;
+	}
+
+	for(i = 0; i < hndlr_cnt; i++) {
+		handler = (struct msgstn_handler *)napi_final_hndlr[i];
+		handler->napi_final(handler->napi_final_arg);
+		hndlr_id = handler - &msg_handler_map[0];
+		napi_final_needed[cpu][hndlr_id] = 0;
+	}
+	
+
+	/*Ack fmn interrupts.*/
+	if(count < budget) {
+		uint32_t val;
+		unsigned long flags;
+		local_irq_save(flags);
+		msgrng_access_enable(mflags);
+                napi_complete(napi);
+		
+		if (is_cpu_core_xlp_ii) {
+                	xlp_write_msg_int(napi_vc_mask);
+		}
+		else {
+			/* Need write vc into the register */
+			val =  _read_32bit_cp2_register(XLP_MSG_STATUS1_REG);
+			//val |= ((1 << vc) << 16);
+			val |= (napi_vc_mask << 16);
+			_write_32bit_cp2_register(XLP_MSG_STATUS1_REG, val);
+		}
+		msgrng_access_disable(mflags);
+		local_irq_restore(flags);
+		return count;
+	}
+	return budget;
+}
+
+static inline int num_ones(unsigned int mask)
+{
+	int ret = 0;
+
+	if (!mask) return 0;
+	while ((mask &= (mask - 1))) ret++;
+	return (ret + 1);
+}
+
+static int xlp_napi_fmn_setup(void)
+{
+	int i, cpu_count;
+	struct napi_struct *napi;
+	int weight_p = 300;
+
+	xlp_napi_vc_count = num_ones(xlp_napi_vc_mask);
+	printk("MSGRING_NAPI: Initializing NLM NAPI subsystem\n");
+
+	init_dummy_netdev(&xlp_napi_fmn_dummy_dev);
+
+	for (cpu_count = 0; cpu_count < NR_CPUS; cpu_count++)
+	{
+		napi = &per_cpu(xlp_napi_fmn_poll_struct, cpu_count);
+		memset(napi, 0, sizeof(*napi));
+		netif_napi_add(&xlp_napi_fmn_dummy_dev, napi, xlp_fmn_poll, weight_p);
+		napi_enable(napi);
+	}
+
+	for (i = 0; i < NR_CPUS; i++) {
+		per_cpu(xlp_napi_fmn_rx_count, i) = 0;
+	}
+	return 0;
+}
+
+static irqreturn_t msgring_irq_handler(int irq, void *dev_id)
+{
+	nlm_xlp_msgring_int_handler(irq, NULL);
+	return IRQ_HANDLED;
+}
+
+void msgring_irq_init(void)
+{
+	if (request_irq(XLP_IRQ_MSGRING_RVEC, msgring_irq_handler,
+			IRQF_PERCPU | IRQF_NO_THREAD,
+			"FMN", NULL)) {
+		panic("Cannot request_irq(XLP_IRQ_MSGRING_RVEC)\n");
+	}
+}
+EXPORT_SYMBOL(msgring_irq_init);
+#endif
+
+
+/*********************************************************************
+ * on_chip_init
+ *  
+ ********************************************************************/
+struct proc_dir_entry *nlm_root_proc;
+EXPORT_SYMBOL(nlm_root_proc);
+static int __init nlm_proc_setup(void)
+{
+        nlm_root_proc = proc_mkdir("netlogic", 0);
+        if (!nlm_root_proc)
+                return -ENOMEM;
+
+	pr_info("proc setup done\n");
+        return 0;
+}
+
+static void parse_fmn_config(void)
+{
+        uint32_t node_vc_mask[NLM_MAX_CPU_NODE] = {0};
+        unsigned char buf[30];
+        int i, j, id=0, k, tmp;
+	void *node;
+	uint32_t onlinemask[4] = {~0u};
+
+
+	node = finddevice("/doms/dom@0/fmn");
+	if (node) {
+		for (i = 0; i < NLM_MAX_CPU_NODE; i++) {
+			sprintf(buf, "node_%d_vc_mask",i);
+			memset(&node_vc_mask, 0, sizeof(node_vc_mask));
+			if (getprop(node, buf, &node_vc_mask, sizeof(node_vc_mask)) < 0) {
+				/* If no mask is passed, derive it from cpu online mask */
+				if (onlinemask[i]) {
+					for (j = 0; j < NLM_MAX_CPU_PER_NODE; j++, id++) {
+						if (onlinemask[i] & (1 << j))
+							nlm_cpu_vc_mask[id] = 0xf;
+					}
+				}
+			}
+			else {	/* Get vc mask from the fdt */
+				for (j = 3; j >= 0; j--) {
+					tmp = fdt32_to_cpu(node_vc_mask[j]);
+					for (k = 0; k < 8; k++) {
+						nlm_cpu_vc_mask[id++] = (tmp >> (k * 4)) & 0xf;
+					}
+				}
+			}
+		}
+	}
+	else {	/* Derive vc mask from cpu online map */
+		for (i = 0; i < NLM_MAX_CPU_NODE; i++) {
+			if (onlinemask[i]) {
+				for (j = 0; j < NLM_MAX_CPU_PER_NODE; j++, id++) {
+					if (onlinemask[i] & (1 << j))
+						nlm_cpu_vc_mask[id] = 0xf;
+				}
+			}
+		}
+	}
+}
+
+int nae_rx_vc = -1, nae_fb_vc = -1;
+int sae_rx_vc = -1, sae_rx_sync_vc = -1;
+int ipsec_async_vc = -1, ipsec_sync_vc = -1;
+static void parse_fdt_sae_vc_config(void)
+{
+	void *node;
+	void * valid_node;
+	int i;
+	int num_nodes = 1;
+	extern uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE];
+
+	node = finddevice("/doms/dom@0/cpu");
+	if(node) {
+		if (getprop(node, "nae-rx-vc", &nae_rx_vc, 4) > 0)
+                        nae_rx_vc = fdt32_to_cpu(nae_rx_vc);
+
+		if (getprop(node, "nae-fb-vc", &nae_fb_vc, 4) > 0)
+                        nae_fb_vc = fdt32_to_cpu(nae_fb_vc);
+
+		if (getprop(node, "napi-vc-mask", &xlp_napi_vc_mask, 4) > 0)
+			xlp_napi_vc_mask = fdt32_to_cpu(xlp_napi_vc_mask);
+
+		if (getprop(node, "sae-rx-vc", &sae_rx_vc, 4) > 0)
+			sae_rx_vc = fdt32_to_cpu(sae_rx_vc);
+
+		if (getprop(node, "sae-rx-sync-vc", &sae_rx_sync_vc, 4) > 0)
+			sae_rx_sync_vc = fdt32_to_cpu(sae_rx_sync_vc);
+
+		if (getprop(node, "ipsec-async-vc", &ipsec_async_vc, 4) > 0)
+			ipsec_async_vc = fdt32_to_cpu(ipsec_async_vc);
+
+		if (getprop(node, "ipsec-sync-vc", &ipsec_sync_vc, 4) > 0)
+			ipsec_sync_vc = fdt32_to_cpu(ipsec_sync_vc);
+
+		valid_node  = finddevice("/soc/nodes");
+
+		if (getprop(valid_node, "num-nodes", &num_nodes, 4) > 0 )
+			num_nodes = fdt32_to_cpu(num_nodes);
+
+		for(i =0 ; i < num_nodes*NLM_MAX_CPU_PER_NODE; i++) {
+			if(nlm_cpu_vc_mask[i] & (1 << ipsec_sync_vc)) {
+				ipsec_sync_vc = -1;
+			}
+
+		}
+	}
+	pr_info("parse fdt node %p\n", node);
+
+	return;
+}
+/* from smp.c */
+
+static long fmn_config(void *arg)
+{
+        pr_info("Doing fmn init from cpu %d for node %d fdt %p\n", hard_smp_processor_id(), (int)(long)arg, fdt);
+        nlm_hal_fmn_init(fdt, (int)(long)arg);
+        return 0;
+}
+
+static int __init nlm_fmn_init(void)
+{
+        int node, rv;
+	int node_exist[4] = {1, 0, 0, 0};
+
+        /* Better to do node level fmn initialization */
+        if(get_dom_fmn_node_ownership(fdt, 0)) {
+                for(node = 0; node < NLM_MAX_NODES; node++) {
+                        if(!node_exist[node])
+                                continue;
+                        rv = work_on_cpu(node_exist[node] >> 16, fmn_config, (void *)(long)node);
+                        if(rv < 0)
+                                panic("Fmn init failed\n");
+                }
+        } else
+                printk("Skipping FMN initialization due to lack of ownership\n");
+
+        /* Enable vc interupts for the online cpus */
+        nlm_enable_vc_intr();
+
+        return 0;
+
+}
+
+EXPORT_SYMBOL(nae_rx_vc);
+EXPORT_SYMBOL(nae_fb_vc);
+EXPORT_SYMBOL(sae_rx_vc);
+EXPORT_SYMBOL(sae_rx_sync_vc);
+EXPORT_SYMBOL(ipsec_async_vc);
+EXPORT_SYMBOL(ipsec_sync_vc);
+
+extern void *initial_boot_params;
+static int __init on_chip_init(void)
+{
+	int i = 0, j = 0;
+	u8 node;
+
+	fdt = initial_boot_params;
+	if (fdt == NULL) {
+		pr_err("Null FDT blob\n");
+		return -ENODEV;
+	}
+	pr_info("Init at %p\n", fdt);
+	fdt_init(fdt);
+
+	cpumask_clear(&phys_cpu_present_map);
+	for_each_possible_cpu(i)
+		cpumask_set_cpu(cpu_logical_map(i), &phys_cpu_present_map);
+
+	is_cpu_core_xlp_ii = is_nlm_xlp2xx();	
+	node = hard_smp_processor_id() / NLM_MAX_CPU_PER_NODE;
+	nlm_proc_setup();
+
+	parse_fmn_config();
+	pr_info("parse done\n");
+
+	parse_fdt_sae_vc_config();
+	pr_info("parse vc done\n");
+
+	/* Set netlogic_io_base to the run time value */
+#ifdef CONFIG_XLP_FMN_SUPPORT
+	spin_lock_init(&msgrng_lock);
+
+	msgring_registered.value = 0;
+#endif
+
+	nlm_hal_init();
+
+	for (i = 0; i < NR_CPUS; i++)
+		for (j = 0; j < NLM_MAX_COUNTERS; j++)
+			atomic_set(&nlm_common_counters[i][j], 0);
+
+#ifdef CONFIG_XLP_FMN_SUPPORT
+	on_each_cpu(enable_msgconfig_int, 0, 1);
+
+	if (is_nlm_xlp2xx())
+		vc_to_handle = xlp2xx_vc_to_handle_map;
+	else if (is_nlm_xlp3xx())
+		vc_to_handle = xlp3xx_vc_to_handle_map;
+	else
+		vc_to_handle = vc_to_handle_map;
+		
+	if(xlp_napi_vc_mask)
+		xlp_napi_fmn_setup();
+#endif
+	
+	nlm_fmn_init();
+
+	msgring_irq_init();
+	return 0;
+}
+
+module_init(on_chip_init);
+MODULE_AUTHOR("Broadcom ");
+MODULE_DESCRIPTION("NAE driver advanced features ");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("0.1");
+
diff --git a/drivers/misc/netlogic/soc_interface/ops.h b/drivers/misc/netlogic/soc_interface/ops.h
new file mode 100644
index 0000000..c58c196
--- /dev/null
+++ b/drivers/misc/netlogic/soc_interface/ops.h
@@ -0,0 +1,265 @@
+/*
+ * Global definition of all the bootwrapper operations.
+ *
+ * Author: Mark A. Greer <mgreer@mvista.com>
+ *
+ * 2006 (c) MontaVista Software, Inc.  This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef _PPC_BOOT_OPS_H_
+#define _PPC_BOOT_OPS_H_
+
+
+//#define	COMMAND_LINE_SIZE	512
+#define	MAX_PATH_LEN		256
+#define	MAX_PROP_LEN		256 /* What should this be? */
+
+typedef void (*kernel_entry_t)(unsigned long r3, unsigned long r4, void *r5);
+
+/* Platform specific operations */
+struct platform_ops {
+	void	(*fixups)(void);
+	void	(*image_hdr)(const void *);
+	void *	(*malloc)(unsigned long size);
+	void	(*free)(void *ptr);
+	void *	(*realloc)(void *ptr, unsigned long size);
+	void	(*exit)(void);
+	void *	(*vmlinux_alloc)(unsigned long size);
+};
+extern struct platform_ops platform_ops;
+
+/* Device Tree operations */
+struct dt_ops {
+	void *	(*finddevice)(const char *name);
+	int	(*getprop)(const void *phandle, const char *name, void *buf,
+			const int buflen);
+	int	(*setprop)(const void *phandle, const char *name,
+			const void *buf, const int buflen);
+	int (*del_node)(const void *phandle);
+	void *(*get_parent)(const void *phandle);
+	/* The node must not already exist. */
+	void *(*create_node)(const void *parent, const char *name);
+	void *(*find_node_by_prop_value)(const void *prev,
+	                                 const char *propname,
+	                                 const char *propval, int proplen);
+	void *(*find_node_by_compatible)(const void *prev,
+	                                 const char *compat);
+	unsigned long (*finalize)(void);
+	char *(*get_path)(const void *phandle, char *buf, int len);
+	int (*check_header)(void);
+};
+extern struct dt_ops dt_ops;
+
+/* Console operations */
+struct console_ops {
+	int		(*open)(void);
+	void	(*write)(const char *buf, int len);
+	void	(*edit_cmdline)(char *buf, int len);
+	void	(*close)(void);
+	void	*data;
+};
+extern struct console_ops console_ops;
+
+/* Serial console operations */
+struct serial_console_data {
+	int		(*open)(void);
+	void	(*putc)(unsigned char c);
+	unsigned char	(*getc)(void);
+	unsigned char		(*tstc)(void);
+	void	(*close)(void);
+};
+
+struct loader_info {
+	void *promptr;
+	unsigned long initrd_addr, initrd_size;
+	char *cmdline;
+	int cmdline_len;
+};
+extern struct loader_info loader_info;
+
+void start(void);
+void *fdt_init(void *blob);
+//int serial_console_init(void);
+int ns16550_console_init(void *devp, struct serial_console_data *scdp);
+void *simple_alloc_init(char *base, unsigned long heap_size,
+			unsigned long granularity, unsigned long max_allocs);
+extern void flush_cache(void *, unsigned long);
+int dt_xlate_reg(void *node, int res, unsigned long *addr, unsigned long *size);
+int dt_xlate_addr(void *node, unsigned int *buf, int buflen, unsigned long *xlated_addr);
+int dt_is_compatible(void *node, const char *compat);
+void dt_get_reg_format(void *node, unsigned int *naddr, unsigned int *nsize);
+int dt_get_virtual_reg(void *node, void **addr, int nres);
+
+
+static inline void *finddevice(const char *name)
+{
+	return (dt_ops.finddevice) ? dt_ops.finddevice(name) : NULL;
+}
+
+static inline int getprop(void *devp, const char *name, void *buf, int buflen)
+{
+	return (dt_ops.getprop) ? dt_ops.getprop(devp, name, buf, buflen) : -1;
+}
+
+static inline int setprop(void *devp, const char *name,
+                          const void *buf, int buflen)
+{
+	return (dt_ops.setprop) ? dt_ops.setprop(devp, name, buf, buflen) : -1;
+}
+#define setprop_val(devp, name, val) \
+	do { \
+		typeof(val) x = (val); \
+		setprop((devp), (name), &x, sizeof(x)); \
+	} while (0)
+
+static inline int setprop_str(void *devp, const char *name, const char *buf)
+{
+	if (dt_ops.setprop)
+		return dt_ops.setprop(devp, name, buf, strlen(buf) + 1);
+
+	return -1;
+}
+
+static inline int del_node(const void *devp)
+{
+	return dt_ops.del_node ? dt_ops.del_node(devp) : -1;
+}
+
+static inline void *get_parent(const char *devp)
+{
+	return dt_ops.get_parent ? dt_ops.get_parent(devp) : NULL;
+}
+
+static inline void *create_node(const void *parent, const char *name)
+{
+	return dt_ops.create_node ? dt_ops.create_node(parent, name) : NULL;
+}
+
+
+static inline void *find_node_by_prop_value(const void *prev,
+                                            const char *propname,
+                                            const char *propval, int proplen)
+{
+	if (dt_ops.find_node_by_prop_value)
+		return dt_ops.find_node_by_prop_value(prev, propname,
+		                                      propval, proplen);
+
+	return NULL;
+}
+
+static inline void *find_node_by_prop_value_str(const void *prev,
+                                                const char *propname,
+                                                const char *propval)
+{
+	return find_node_by_prop_value(prev, propname, propval,
+	                               strlen(propval) + 1);
+}
+
+static inline void *find_node_by_devtype(const void *prev,
+                                         const char *type)
+{
+	return find_node_by_prop_value_str(prev, "device_type", type);
+}
+
+static inline void *find_node_by_alias(const char *alias)
+{
+	void *devp = finddevice("/aliases");
+
+	if (devp) {
+		char path[MAX_PATH_LEN];
+		if (getprop(devp, alias, path, MAX_PATH_LEN) > 0)
+			return finddevice(path);
+	}
+
+	return NULL;
+}
+
+static inline void *find_node_by_compatible(const void *prev,
+                                            const char *compat)
+{
+	if (dt_ops.find_node_by_compatible)
+		return dt_ops.find_node_by_compatible(prev, compat);
+
+	return NULL;
+}
+
+static inline int check_header(void)
+{
+	if (dt_ops.check_header)
+		return dt_ops.check_header();
+	return -1;
+}
+
+void dt_fixup_memory(unsigned long long start, unsigned long long size);
+void dt_fixup_cpu_clocks(unsigned int cpufreq, unsigned int tbfreq, unsigned int busfreq);
+void dt_fixup_clock(const char *path, unsigned int freq);
+void dt_fixup_mac_address_by_alias(const char *alias, const unsigned char *addr);
+void dt_fixup_mac_address(unsigned int index, const unsigned char *addr);
+void __dt_fixup_mac_addresses(unsigned int startindex, ...);
+#define dt_fixup_mac_addresses(...) \
+	__dt_fixup_mac_addresses(0, __VA_ARGS__, NULL)
+
+
+static inline void *find_node_by_linuxphandle(const unsigned int linuxphandle)
+{
+	return find_node_by_prop_value(NULL, "linux,phandle",
+			(char *)&linuxphandle, sizeof(unsigned int));
+}
+
+static inline char *get_path(const void *phandle, char *buf, int len)
+{
+	if (dt_ops.get_path)
+		return dt_ops.get_path(phandle, buf, len);
+
+	return NULL;
+}
+
+static inline void *malloc(unsigned long size)
+{
+	return (platform_ops.malloc) ? platform_ops.malloc(size) : NULL;
+}
+
+static inline void free(void *ptr)
+{
+	if (platform_ops.free)
+		platform_ops.free(ptr);
+}
+
+static inline void exit(void)
+{
+	if (platform_ops.exit)
+		platform_ops.exit();
+	for(;;);
+}
+#define fatal(args...) { printf(args); exit(); }
+
+
+#define BSS_STACK(size) \
+	static char _bss_stack[size]; \
+	void *_platform_stack_top = _bss_stack + sizeof(_bss_stack);
+
+extern unsigned long timebase_period_ns;
+//void udelay(long delay);
+#if 0
+extern char _start[];
+extern char __bss_start[];
+extern char _end[];
+extern char _vmlinux_start[];
+extern char _vmlinux_end[];
+extern char _initrd_start[];
+extern char _initrd_end[];
+extern char _dtb_start[];
+extern char _dtb_end[];
+
+static inline __attribute__((const))
+int __ilog2_u32(unsigned int n)
+{
+	int bit;
+	asm ("cntlzw %0,%1" : "=r" (bit) : "r" (n));
+	return 31 - bit;
+}
+#endif
+
+#endif /* _PPC_BOOT_OPS_H_ */
-- 
1.9.1

