From 9b6d79082c280fd7f3745ea6bb79438ddc1232fb Mon Sep 17 00:00:00 2001
From: Virendra Pathak <vpathak@broadcom.com>
Date: Thu, 22 Aug 2013 17:27:16 +0530
Subject: [PATCH 1175/1532] fmn: making cpu vc mask structure generic to all
 chip type.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/soc_interface/on_chip.c | 18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

diff --git a/drivers/misc/netlogic/soc_interface/on_chip.c b/drivers/misc/netlogic/soc_interface/on_chip.c
index d170b57..9694377 100644
--- a/drivers/misc/netlogic/soc_interface/on_chip.c
+++ b/drivers/misc/netlogic/soc_interface/on_chip.c
@@ -74,8 +74,8 @@ extern void *fdt;
 EXPORT_SYMBOL(fdt);
 
 uint32_t msgring_global_thread_mask = 0;
-uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE] = {0};
-uint32_t nlm_cpu_vc_mask_9xx[NLM_MAX_CPU_NODE_9XX*NLM_MAX_CPU_PER_NODE_9XX] = {0};
+uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE_9XX*NLM_MAX_CPU_PER_NODE_9XX] = {0}; 
+/* nlm_cpu_vc_mask is superset and will work in other chip type too. for eg in xlp8xx case it will use just 4x32 fields */
 
 uint32_t nlm_l1_lock[NR_CPUS/4] = {0};
 
@@ -737,7 +737,7 @@ void nlm_enable_vc_intr_9xx(void)
                 node = cpu / NLM_MAX_CPU_PER_NODE_9XX;
                 for(i = 0; i < NLM_MAX_VC_PER_THREAD_9XX; i++) {
                         vc_index = (i + cpu * NLM_MAX_VC_PER_THREAD_9XX) & NLM_MAX_VC_MASK_9XX;
-                        if(nlm_cpu_vc_mask_9xx[cpu] & (1<<i)){
+                        if(nlm_cpu_vc_mask[cpu] & (1<<i)){
                                 /*enable interrupts*/
                                 nlm_hal_enable_vc_intr(node, vc_index);
 #ifdef ONCHIP_DEBUG
@@ -986,11 +986,11 @@ static void parse_fmn_config_9xx(void)
 					for (j = 0; j < NLM_MAX_CPU_PER_NODE_9XX; j++, id++) {
 						if(j < 64) {
 							if (onlinemask.map[i][0] & (1 << j))
-								nlm_cpu_vc_mask_9xx[id] = 0xf;
+								nlm_cpu_vc_mask[id] = 0xf;
 						}
 						else {
 							if (onlinemask.map[i][1] & (1 << j))
-								nlm_cpu_vc_mask_9xx[id] = 0xf;
+								nlm_cpu_vc_mask[id] = 0xf;
 						}
 					}
 				}
@@ -999,7 +999,7 @@ static void parse_fmn_config_9xx(void)
 				for (j = (NLM_MAX_COREPAIR_PER_NODE_9XX - 1); j >= 0; j--) {
 					tmp = fdt32_to_cpu(node_vc_mask[j]);
 					for (k = 0; k < 8; k++) {
-						nlm_cpu_vc_mask_9xx[id++] = (tmp >> (k * 4)) & 0xf;
+						nlm_cpu_vc_mask[id++] = (tmp >> (k * 4)) & 0xf;
 					}
 				}
 			}
@@ -1011,11 +1011,11 @@ static void parse_fmn_config_9xx(void)
 				for (j = 0; j < NLM_MAX_CPU_PER_NODE_9XX; j++, id++) {
 					if(j < 64) {
 						if (onlinemask.map[i][0] & (1 << j))
-							nlm_cpu_vc_mask_9xx[id] = 0xf;
+							nlm_cpu_vc_mask[id] = 0xf;
 					}
 					else {
 						if (onlinemask.map[i][1] & (1 << j))
-							nlm_cpu_vc_mask_9xx[id] = 0xf;
+							nlm_cpu_vc_mask[id] = 0xf;
 					}
 				}
 			}
@@ -1032,7 +1032,7 @@ static void parse_fdt_sae_vc_config(void)
 	void * valid_node;
 	int i;
 	int num_nodes = 1;
-	extern uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE];
+	extern uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE_9XX*NLM_MAX_CPU_PER_NODE_9XX];
 
 	node = finddevice("/doms/dom@0/cpu");
 	if(node) {
-- 
1.9.1

