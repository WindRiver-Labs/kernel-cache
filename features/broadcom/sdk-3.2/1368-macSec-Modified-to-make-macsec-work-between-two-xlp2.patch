From d347250e5510e3b94e1d365e7c7d94c878e09770 Mon Sep 17 00:00:00 2001
From: Alok Agrawat <alok@broadcom.com>
Date: Fri, 14 Sep 2012 12:03:05 -0700
Subject: [PATCH 1368/1532] macSec: Modified to make macsec work between two
 xlp2xx boards

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/net_common.h |   3 +-
 drivers/net/ethernet/broadcom/nae/xlp_nae.c    | 192 +++++++++++++++++++------
 2 files changed, 151 insertions(+), 44 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/net_common.h b/drivers/net/ethernet/broadcom/nae/net_common.h
index 539d8d0..5470f94 100644
--- a/drivers/net/ethernet/broadcom/nae/net_common.h
+++ b/drivers/net/ethernet/broadcom/nae/net_common.h
@@ -59,7 +59,8 @@
 #define MAX_TSO_SKB_PEND_REQS	200
 #define MAX_PACKET_SZ_PER_MSG	16384
 #define P2P_EXTRA_DESCS		((PAGE_SIZE / MAX_PACKET_SZ_PER_MSG) + 4)
-#define P2P_SKB_OFF		(MAX_SKB_FRAGS + P2P_EXTRA_DESCS - 1)
+#define MSEC_EXTRA_MEM		(8) /* 8 * 64 bit = 512bits=64bytes. for sectag another one for icv */
+#define P2P_SKB_OFF		(MAX_SKB_FRAGS + P2P_EXTRA_DESCS + MSEC_EXTRA_MEM - 1)
 #define tso_dbg(fmt, args...)	//printk(fmt, ##args);
 #define RX_UNCLASSIFIED_PKT 	(1<<5)
 #define RX_IP_CSUM_VALID 	(1<<3)
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index 514bf9c..569fe7b 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -177,6 +177,24 @@ static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id);
 //#define Message(fmt, args...) printk(fmt, ##args)
 
 
+#define MAC_HEADER_LEN		12
+#define MAC_ADDR_LEN		6
+#define MACSEC_ETHER_TYPE	0x88e5
+#define PROTOCOL_TYPE_IP 	0x0800
+#define MAC_SEC_PADDING		(12+16+16+16) /* !2 byte DA and SA, 16 byte preamble len, 16 byte sectag hear, 16 byte ICV len*/
+
+void dump_buffer(unsigned char *buf, unsigned int len, unsigned char *msg)
+{
+    int k = 0;
+    printk("\n%s\n",msg);
+    for(k = 0; k < len; k++)
+    {
+        printk("%.2x ",buf[k]);
+        if((k+1) % 16 == 0)
+            printk("\n");
+    }
+    printk("\n");
+}
 static unsigned short  nlm_select_queue(struct net_device *dev, struct sk_buff *skb)
 {
 	        return (unsigned short)smp_processor_id();
@@ -240,6 +258,7 @@ static void gen_mac_address(void)
 
 	eeprom_get_magic_bytes(nlm_eeprom,buf0_read,0);/* signature*/
 	eeprom_get_magic_bytes(nlm_eeprom,buf1_read,1);
+	
 
 	if((buf0_read[0]==buf_write[0]) && (buf0_read[1]==buf_write[1]))/*match the signature*/
 	{
@@ -260,8 +279,18 @@ static void gen_mac_address(void)
 		}
 	}
 	if( ((mac0_set | mac1_set) && if_mac_set) == 0){
-		random_ether_addr(mac_base);
-	}
+		//random_ether_addr(mac_base);
+	}
+	/* Temporarily added for MACSec. MACSec needs to know the correct MAC Address.
+ 	   This function is broken. It is assigning MAC Address randomly
+	*/
+	mac_base[0]= 0x11;
+	mac_base[1]= 0x22;
+	mac_base[2]= 0x33;
+	mac_base[3]= 0x44;
+	mac_base[4]= 0x55;
+	mac_base[5]= 0x67;
+
 	for(i=0 ; i<NLM_MAX_NODES; i++){ /*poppulate the eth_hw_add array according to the get mac address*/
 		for(j=0;j<18;j++){
 			memcpy(eth_hw_addr[i][j], mac_base, 6);
@@ -319,7 +348,7 @@ static int p2p_desc_mem_init(void)
 	int dsize, tsize;
 	void *buf;
 	/* MAX_SKB_FRAGS + 4.  Out of 4, 2 will be used for skb and freeback storage */
-	dsize = ((((MAX_SKB_FRAGS + P2P_EXTRA_DESCS) * sizeof(uint64_t)) + CACHELINE_SIZE - 1) & (~((CACHELINE_SIZE)-1)));
+	dsize = ((((MAX_SKB_FRAGS + P2P_EXTRA_DESCS + MSEC_EXTRA_MEM) * sizeof(uint64_t)) + CACHELINE_SIZE - 1) & (~((CACHELINE_SIZE)-1)));
 	tsize = dsize * MAX_TSO_SKB_PEND_REQS;
 
 	printk("%s in, dsize %d tsize %d \n", __FUNCTION__, dsize, tsize);
@@ -396,6 +425,7 @@ static __inline__ uint64_t nae_tso_desc0(
 		unsigned int type,
 		unsigned int subtype,
 		unsigned int opcode,
+		unsigned int param_index,
 		unsigned int l3hdroff,
 		unsigned int l4hdroff,
 		unsigned int l3chksumoff,
@@ -407,6 +437,7 @@ static __inline__ uint64_t nae_tso_desc0(
 	return ((uint64_t)(type & 0x3) << 62) |
 		((uint64_t)(subtype & 3) << 60) |
 		((uint64_t)(opcode & 0xf) << 56) |
+		((uint64_t)(param_index & 0xf) << 49) |
 		((uint64_t)(l3hdroff & 0x3f) << 43) |
 		((uint64_t)(l4hdroff & 0x7f) << 36) |
 		((uint64_t)(l3chksumoff & 0x1f) << 31) |
@@ -744,6 +775,9 @@ static inline void process_rx_packets(int cpu, unsigned int src_id,
 	uint64_t ns;
 	struct skb_shared_hwtstamps *shhwtstamps;
 #endif
+	uint32_t msec_port;
+	nlm_nae_config_ptr nae_cfg;
+
 
 	err = (msg1 >> 4) & 0x1;
 
@@ -822,6 +856,35 @@ static inline void process_rx_packets(int cpu, unsigned int src_id,
 	skb_reserve(skb, PREPAD_LEN);
 #endif
 
+	if(priv->index == XGMAC)
+		msec_port = (priv->port | 0xf) << (4 * priv->block) ;
+	else
+		msec_port = 1 << port;
+	nae_cfg = nlm_node_cfg.nae_cfg[node];
+
+#ifdef MACSEC_DEBUG
+	printk("%s nae_cfg->sectag_offset = %d sectag_len = %d icv_len = %d\n",
+	__FUNCTION__, nae_cfg->sectag_offset[port], nae_cfg->sectag_len[port], nae_cfg->icv_len[port]);
+	dump_buffer(skb->data, len, "RX skb pkt:");		
+	printk("msec_port = %x port = %d len = %d nae_cfg->msec_port_enable = %x\n",msec_port, port, len, nae_cfg->msec_port_enable);
+#endif
+	//if(1/*nae_cfg->msec_port_enable & msec_port*/)/* check if port is tx port is enabled for msec else bypass MACSec*/
+	if(nae_cfg->msec_port_enable & msec_port)/* check if port is tx port is enabled for msec else bypass MACSec*/
+	{
+		short ether_type = *(short*)(((char*)skb->data) + MAC_HEADER_LEN);
+
+		if((ether_type & 0xffff) == MACSEC_ETHER_TYPE)/*Enable MACSEc processing*/			
+		{
+			memcpy((char*)(skb->data + MAC_HEADER_LEN + nae_cfg->sectag_len[port] - MAC_ADDR_LEN /*DST MAC LEN*/),(((char*)skb->data)+MAC_ADDR_LEN), MAC_ADDR_LEN);
+			memcpy((char*)(skb->data + MAC_HEADER_LEN + nae_cfg->sectag_len[port] - (MAC_ADDR_LEN * 2) /*SRC MAC LEN*/),((char*)skb->data), MAC_ADDR_LEN);
+			len = len - nae_cfg->sectag_len[port] - nae_cfg->icv_len[port];
+			skb_reserve(skb, nae_cfg->sectag_len[port]);
+#ifdef MACSEC_DEBUG
+			dump_buffer(skb->data, len, "RX mod skb pkt:");		
+#endif
+		}
+	}
+
 	skb->dev = pdev;
 	skb_put(skb, len);
 	skb->protocol = eth_type_trans(skb, pdev);
@@ -1447,6 +1510,7 @@ do { \
 	shinfo->frag_list = NULL; \
 } while (0)
 
+
 static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 {
 	int mss  = 0, idx = 0, len, i ;
@@ -1464,6 +1528,47 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 	union skb_shared_tx *shtx;
 	int is_skbts = skb->sk && sock_flag(skb->sk, SOCK_TIMESTAMPING_TX_HARDWARE);
 #endif
+	uint32_t msec_port, send_msec = 0, msec_bypass = 0, pad_len, icv_len, param_index = 0;
+
+#ifdef MACSEC_DEBUF
+	printk("nae_cfg->sectag_offset = %d sectag_len = %d icv_len = %d\n",
+	nae_cfg->sectag_offset[priv->port], nae_cfg->sectag_len[priv->port], nae_cfg->icv_len[priv->port]);
+#endif
+	if(priv->index == XGMAC)
+		msec_port = (priv->port | 0xf) << (4 * priv->block) ;
+	else
+		msec_port = 1 << priv->port;
+
+#ifdef MACSEC_DEBUF
+	dump_buffer(skb->data, skb->len, "Org skb pkt:");		
+	printk("msec_port = %x priv->port = %d priv->block = %d priv->index = %d skb->len = %d nae_cfg->msec_port_enable = %x\n",
+	msec_port, priv->port, priv->block, priv->index, skb->len, nae_cfg->msec_port_enable);
+#endif
+	//if(1/*nae_cfg->msec_port_enable & msec_port*/)/* check if port is tx port is enabled for msec else bypass MACSec*/
+	if(nae_cfg->msec_port_enable & msec_port)/* check if port is tx port is enabled for msec else bypass MACSec*/
+	{
+		short ether_type = *(short*)(((char*)skb->data) + MAC_HEADER_LEN);
+
+#ifdef MACSEC_DEBUF
+	printk("skb->len = %d ether_type = %x\n", skb->len, ether_type);
+#endif
+		//if(1/*(ether_type & 0xffff) == PROTOCOL_TYPE_IP*/)/*Enable MACSEc processing*/			
+		if((ether_type & 0xffff) == PROTOCOL_TYPE_IP)/*Enable MACSEc processing*/			
+		{
+			send_msec = 1;
+			param_index = (priv->port)?priv->port:1;/* it should be between 1 -7 */
+
+			pad_len =  nae_cfg->sectag_offset[priv->port] + nae_cfg->sectag_len[priv->port]; //12 + 8;
+			icv_len = nae_cfg->icv_len[priv->port];
+
+#ifdef MACSEC_DEBUF
+	printk("pad_len = %d icv_len = %d ether_type = %x\n", pad_len, icv_len, ether_type);
+#endif
+		}
+		else
+			msec_bypass = 1;
+		
+	}
 
 	p2pdesc = alloc_p2p_desc_mem(cpu);
 	if(p2pdesc == NULL) {
@@ -1502,27 +1607,44 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 		if(mss) {
 			iph->check = 0;
 			iph->tot_len = 0;
-			mscmsg0 = nae_tso_desc0(MSC, 1, TSO_IP_TCP_CHKSUM,
+			mscmsg0 = nae_tso_desc0(MSC, 1, TSO_IP_TCP_CHKSUM, param_index,
 				iphdroff, tcphdroff, (iphdroff + 10),
 				pcsum, tcphdroff + 16, pyldoff);
 			mscmsg1 = nae_tso_desc1(MSC, 2, 0, mss, 0, 0);
 		} else if(tcp_packet) {
-			mscmsg0 = nae_tso_desc0(MSC, 0, TCP_CHKSUM,
+			mscmsg0 = nae_tso_desc0(MSC, 0, TCP_CHKSUM, param_index,
 				iphdroff, tcphdroff, (iphdroff + 10),
 				pcsum, tcphdroff + 16, pyldoff);
 		} else {
-			mscmsg0 = nae_tso_desc0(MSC, 0, UDP_CHKSUM,
+			mscmsg0 = nae_tso_desc0(MSC, 0, UDP_CHKSUM, param_index,
 				iphdroff, tcphdroff, (iphdroff + 10),
 				pcsum, tcphdroff + 6, pyldoff);
 		}
 
 	}
+	else if(send_msec || msec_bypass)
+	{
+		mscmsg0 = nae_tso_desc0(MSC, 0, 0, param_index,
+	              	  0, 0, 0, 0, 0, 0);
+	}
 
 	if(((len = skb_headlen(skb)) != 0)) {
+		if(send_msec)
+		{
+			memcpy((char*)&p2pdesc[P2P_SKB_OFF-8], skb->data, MAC_HEADER_LEN);		
+			idx = create_p2p_desc(virt_to_bus((char *)&p2pdesc[P2P_SKB_OFF-8]), pad_len, p2pdesc, idx);
+
+			idx = create_p2p_desc(virt_to_bus((((char *)skb->data)+ MAC_HEADER_LEN)), (len - MAC_HEADER_LEN), p2pdesc, idx);
+#ifdef MACSEC_DEBUF
+			dump_buffer((char *)&p2pdesc[P2P_SKB_OFF-8], pad_len, "first_seg:");		
+			printk(" len = %d pad_len = %d icv_len = %d param_index = %d\n", len, pad_len, icv_len, param_index);
+#endif
+		}
+		else
 #ifdef IEEE_1588_PTP_ENABLED	
 		if(!is_skbts)
 #endif
-		idx = create_p2p_desc(virt_to_bus((char *)skb->data), len, p2pdesc, idx);
+			idx = create_p2p_desc(virt_to_bus((char *)skb->data), len, p2pdesc, idx);
 	}
 
 	for (i = 0; i < sp->nr_frags; i++)  {
@@ -1533,6 +1655,11 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 				fp->size, p2pdesc, idx);
 	}
 
+	if(send_msec)
+	{
+		if(!param_index)
+			idx = create_p2p_desc(virt_to_bus((char *)&p2pdesc[P2P_SKB_OFF-2]), icv_len, p2pdesc, idx);
+	}
 
 	qid = nae_cfg->vfbtbl_sw_offset + (cpu % NLM_NCPUS_PER_NODE);
 #ifdef IEEE_1588_PTP_ENABLED
@@ -1565,8 +1692,14 @@ retry_send:
 		ret = nlm_hal_send_msg2(priv->nae_tx_qid, 0, msg, msg1);	
 	} 
 #endif
+	else if(send_msec || msec_bypass)
+	{
+		ret = nlm_hal_send_msg2(priv->nae_tx_qid, 0, mscmsg0, msg);
+	}
 	else
+	{
 		ret = nlm_hal_send_msg1(priv->nae_tx_qid, 0, msg);
+	}
 	msgrng_access_disable(mflags);
 	if(ret)	{
 		xlp_poll_upper(cpu);
@@ -1591,22 +1724,6 @@ out_unlock:
 	return NETDEV_TX_OK;
 }
 
-#define MAC_HEADER_LEN		12
-#define PROTOCOL_TYPE_IP 	0x0800
-#define MAC_SEC_PADDING		(12+16+16+16) /* !2 byte DA and SA, 16 byte preamble len, 16 byte sectag hear, 16 byte ICV len*/
-
-void dump_buffer(unsigned char *buf, unsigned int len, unsigned char *msg)
-{
-    int k = 0;
-    printk("\n%s\n",msg);
-    for(k = 0; k < len; k++)
-    {
-        printk("%.2x ",buf[k]);
-        if((k+1) % 16 == 0)
-            printk("\n");
-    }
-    printk("\n");
-}
 
 /**********************************************************************
  * nlm_xlp_nae_start_xmit -  transmit a packet from buffer
@@ -1617,7 +1734,7 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct dev_data *priv = netdev_priv(dev);
 	int cpu = hard_smp_processor_id(), ret = 0;
-	uint64_t msg0, msg1, msg2, msg3;
+	uint64_t msg0, msg1;
 	int retry_count = 128;
 	volatile int hw_repl = 0;
 	int  offset, qid;
@@ -1625,10 +1742,10 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 #ifdef IEEE_1588_PTP_ENABLED	
 	union skb_shared_tx *shtx;
 #endif
+	nlm_nae_config_ptr nae_cfg = nlm_node_cfg.nae_cfg[priv->node];
+#if 0
 	uint32_t msec_port, send_msec = 0, pad_len, icv_len;
-	unsigned char *msec_pad_mem, *msec_icv_mem;
 
-	nlm_nae_config_ptr nae_cfg = nlm_node_cfg.nae_cfg[priv->node];
 
 printk("nae_cfg->sectag_offset = %d sectag_len = %d icv_len = %d\n",nae_cfg->sectag_offset[priv->port], nae_cfg->sectag_len[priv->port], nae_cfg->icv_len[priv->port]);
 printk("size of skb end = %llx head = %llx\n", (unsigned long)skb->end, (unsigned long)skb->head);
@@ -1647,21 +1764,23 @@ printk("skb->len = %d ether_type = %x\n", skb->len, ether_type);
 		if((ether_type & 0xffff) == PROTOCOL_TYPE_IP)/*Enable MACSEc processing*/			
 		{
 			send_msec = 1;
-			msec_pad_mem = (unsigned char*)cacheline_aligned_kmalloc(MAC_SEC_PADDING, GFP_KERNEL);
+		/*	msec_pad_mem = (unsigned char*)cacheline_aligned_kmalloc(MAC_SEC_PADDING, GFP_KERNEL);
 			msec_icv_mem = (unsigned char*)cacheline_aligned_kmalloc(nae_cfg->sectag_len[priv->port], GFP_KERNEL);
+			*/
 
 			pad_len = 12 + 8;
 			icv_len = nae_cfg->icv_len[priv->port];
 
 			memcpy(msec_pad_mem, skb->data, MAC_HEADER_LEN);		
-			skb_reserve(skb, MAC_HEADER_LEN);
+			//skb_reserve(skb, MAC_HEADER_LEN);
 			//skb_push(skb, nae_cfg->sectag_offset[priv->port]);
 printk("skb->len = %d ether_type = %x\n", skb->len, ether_type);
-dump_buffer(skb->data, skb->len, "mod skb pkt:");		
+dump_buffer(msec_pad_mem, pad_len, "first_seg:");		
 		}
 //		skb->len +=  nae_cfg->icv_len[priv->port];
 		
 	}
+#endif
 
 #ifdef ENABLE_SANITY_CHECKS
 	if(!skb)
@@ -1717,16 +1836,6 @@ dump_buffer(skb->data, skb->len, "mod skb pkt:");
 	else
 #endif
 	{
-		/*if(send_msec)
-		{
-			msg1 = nae_tx_desc(P2D_NEOP, 0, NULL_VFBID, pad_len,
-			       virt_to_bus(msec_pad_mem));
-			msg2 = nae_tx_desc(P2D_NEOP, 0, NULL_VFBID, skb->len,
-			       virt_to_bus(skb->data));
-			msg3 = nae_tx_desc(P2D_EOP, 0, NULL_VFBID, icv_len,
-			       msec_icv_mem);
-		}
-		else*/
 			msg1 = nae_tx_desc(P2D_EOP, 0, NULL_VFBID, skb->len,
 			       virt_to_bus(skb->data));
 	}
@@ -1750,10 +1859,7 @@ dump_buffer(skb->data, skb->len, "mod skb pkt:");
 
 retry_send:
 	msgrng_access_enable(mflags);
-	if(send_msec)
-		ret = nlm_hal_send_msg4(priv->nae_tx_qid, 0, msg0, msg1, msg2, msg3);
-	else
-		ret = nlm_hal_send_msg2(priv->nae_tx_qid, 0, msg0, msg1);
+	ret = nlm_hal_send_msg2(priv->nae_tx_qid, 0, msg0, msg1);
 	msgrng_access_disable(mflags);
 	if (ret)
 	{
-- 
1.9.1

