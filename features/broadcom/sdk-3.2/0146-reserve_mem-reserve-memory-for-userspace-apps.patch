From a87497159aeac1b5ca2b9cef072cde687be4bca5 Mon Sep 17 00:00:00 2001
From: Tanmay Jagdale <tanmayj@broadcom.com>
Date: Fri, 6 Jun 2014 12:25:54 +0530
Subject: [PATCH 0146/1532] reserve_mem: reserve memory for userspace apps

Introduced netlogic,reserve-mem and netlogic,frin-fifo-mem parameters
in chosen section of dts files.
These parameters indicate the size of memory to be allocated for the apps.
This memory is allocated using alloc_bootmem().
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/xlp/dt.c | 55 +++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 55 insertions(+)

diff --git a/arch/mips/netlogic/xlp/dt.c b/arch/mips/netlogic/xlp/dt.c
index acfd697..eef60df8 100644
--- a/arch/mips/netlogic/xlp/dt.c
+++ b/arch/mips/netlogic/xlp/dt.c
@@ -89,6 +89,58 @@ EXPORT_SYMBOL(nlm_fdt_blob);
 
 EXPORT_SYMBOL(initial_boot_params); /* deprecated */
 
+unsigned long pktmem_start_address;
+EXPORT_SYMBOL(pktmem_start_address);
+unsigned long pktmem_size;
+EXPORT_SYMBOL(pktmem_size);
+unsigned long frin_fifo_address;
+EXPORT_SYMBOL(frin_fifo_address);
+unsigned long frin_fifo_size;
+EXPORT_SYMBOL(frin_fifo_size);
+
+static int __init xlp_reserve_memory(unsigned long node, const char *uname,
+					int depth, void *data)
+{
+	const __be32 *p;
+	unsigned long size;
+	unsigned long val;
+	void *addr;
+
+	if (depth != 1 || strcmp(uname, "chosen") != 0)
+		return 0;
+
+	/* Reserve memory for packet mem kernel module */
+	p = of_get_flat_dt_prop(node, "netlogic,reserve-mem", &size);
+	if (p == NULL)
+		return 0;
+
+	val = be32_to_cpup(p);
+	pktmem_size = val * 1024 * 1024;
+	addr = alloc_bootmem(pktmem_size);
+	if (addr == NULL) {
+		pr_err("Alloc bootmem failed for %ld MB\n", val);
+		return 0;
+	}
+	pktmem_start_address = virt_to_phys(addr);
+	pr_info("Reserved %ld MB at %p for pktmem\n", val, addr);
+
+	/* Reserve memory for NAE FIFO usage */
+	p = of_get_flat_dt_prop(node, "netlogic,frfifo-mem", &size);
+	if (p == NULL)
+		return 0;
+
+	val = be32_to_cpup(p);
+	frin_fifo_size = val * 1024 * 1024;
+	addr = alloc_bootmem(frin_fifo_size);
+	if (addr == NULL) {
+		pr_err("Alloc freein fifo failed for %ld MB\n", val);
+		return 0;
+	}
+	frin_fifo_address = virt_to_phys(addr);
+	pr_info("Reserved %ld MB at %p for freein_fifo\n", val, addr);
+	return 0;
+}
+
 #ifdef CONFIG_SMP
 static int __init xlp_dt_scan_chosen(unsigned long node, const char *uname,
 				     int depth, void *data)
@@ -159,6 +211,9 @@ void __init device_tree_init(void)
 	pr_info("fdt copied to %p, size %ld\n", blob, dt_size);
 
 	unflatten_device_tree();
+
+	/* Resevere memory */
+	of_scan_flat_dt(xlp_reserve_memory, NULL);
 }
 
 static struct of_device_id __initdata xlp_ids[] = {
-- 
1.9.1

