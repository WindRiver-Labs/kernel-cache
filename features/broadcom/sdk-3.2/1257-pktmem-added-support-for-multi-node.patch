From 4c57631cda035ff1ef5d3fa20187ac05f99317a0 Mon Sep 17 00:00:00 2001
From: Tanmay Jagdale <tanmayj@broadcom.com>
Date: Thu, 4 Dec 2014 11:29:27 +0530
Subject: [PATCH 1257/1532] pktmem: added support for multi-node

Use memory allocated by linux kernel in a multi-node setup.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c | 24 ++++++++++++++---------
 1 file changed, 15 insertions(+), 9 deletions(-)

diff --git a/drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c b/drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c
index fd5fd78..061eb57 100644
--- a/drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c
+++ b/drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c
@@ -10,6 +10,7 @@
 #include "libfdt.h"
 #include "pkt_pool_kern_iface.h"
 
+#include <asm/mach-netlogic/multi-node.h>
 
 #define MAX_NODES 	8
 #define MB(x) 		(x*1024*1024)
@@ -298,7 +299,8 @@ static inline int get_fdt_prop(void *fdt, const char* node_path,
 }
 
 extern void *initial_boot_params;
-extern unsigned long pktmem_start_address;
+
+extern unsigned long pktmem_start_address[NLM_NR_NODES];
 extern unsigned long pktmem_size;
 
 /* see "pktmem" section in DTS file for providing memory */
@@ -341,18 +343,13 @@ static int __init brcm_xlp_ppm_init (void)
 	}
 	else
 	{
-		if (pktmem_start_address == 0) {
+
+		if (pktmem_start_address[0] == NULL) {
 			printk(KERN_ERR "brcm_pktmem: unable to read pktmem from DTB.\n");
 			return -1;
 		}
-		printk("Using memory allocated by linux kernel\n");
-		mem_pool_data[0].next = NULL;
-		memset(mem_pool_data[node].shr_id, '\0', 64);
-		mem_pool_data[0].in_use = 0;
-
-		mem_pool_data[node].start = pktmem_start_address;
-		mem_pool_data[node].size = pktmem_size;
 
+		printk("Using memory allocated by linux kernel\n");
 		for (i = 1; i < MAX_NODES; i++) {
 			mem_pool_data[i].next = NULL;
 			memset(mem_pool_data[i].shr_id, '\0', 64);
@@ -361,6 +358,15 @@ static int __init brcm_xlp_ppm_init (void)
 			mem_pool_data[i].start = 0x0;
 			mem_pool_data[i].size = 0x0;
 		}
+
+		for (i = 0; i < NLM_NR_NODES; i++) {
+			mem_pool_data[i].next = NULL;
+			memset(mem_pool_data[i].shr_id, '\0', 64);
+			mem_pool_data[i].in_use = 0;
+
+			mem_pool_data[i].start = pktmem_start_address[i]; /* Address */
+			mem_pool_data[i].size = pktmem_size; /* Size */
+		}
 	}
 
 
-- 
1.9.1

