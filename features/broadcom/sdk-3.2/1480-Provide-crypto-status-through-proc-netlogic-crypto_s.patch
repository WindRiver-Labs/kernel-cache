From fd8f4b3531e3e887233a07363e6a57e1d567769a Mon Sep 17 00:00:00 2001
From: Alok Agrawat <aagrawat@netlogicmicro.com>
Date: Wed, 7 Sep 2011 20:20:57 +0530
Subject: [PATCH 1480/1532] Provide crypto status through
 /proc/netlogic/crypto_stats. Fixed the following issues:

1. Error message " Error _ FreeBack message is not received".
   Replaced 'polling' with timer based message retrieval.

2. setkey failure for DES/3DES/AES.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/crypto/sae/nlm_aead.c   |  28 ++++---
 drivers/crypto/sae/nlm_crypto.c | 159 ++++++++++++++++++++++++----------------
 drivers/crypto/sae/nlm_enc.c    |  24 +++---
 3 files changed, 125 insertions(+), 86 deletions(-)

diff --git a/drivers/crypto/sae/nlm_aead.c b/drivers/crypto/sae/nlm_aead.c
index c47317a..af47ab8 100755
--- a/drivers/crypto/sae/nlm_aead.c
+++ b/drivers/crypto/sae/nlm_aead.c
@@ -80,7 +80,7 @@ aead_setauthsize(struct crypto_aead *authenc, unsigned int authsize)
     ctx = ctx + NLM_CRYPTO_MAX_NONCE_SIZE;
     session = (struct crypto_session*)ctx;
 
-    session->aip = (struct crypto_auth_init_param*)((unsigned char*)session) + sizeof(struct crypto_session);
+    session->aip = (struct crypto_auth_init_param*)(((unsigned char*)ctx) + sizeof(struct crypto_session));
     session->aip->tag_len = authsize;
 
     return 0;
@@ -254,7 +254,6 @@ authenc_setkey(struct crypto_aead *tfm, const u8 * key, unsigned int keylen, uin
     if (!RTA_OK(rta, keylen)) {
 	goto badkey;
     }
-
     if (rta->rta_type != CRYPTO_AUTHENC_KEYA_PARAM) {
 	goto badkey;
     }
@@ -679,7 +678,7 @@ aead_4106_crypt(struct aead_request *req, unsigned int enc, uint32_t tag_len)
 	{
 	    if(memcmp((unsigned char *) &sd->dst[i].buf[sd->dst[i].iov_len], sd->hash_dst_address, session->aip->tag_len))
 	    {
-		printk(KERN_ERR "\n Digest do not match");
+		//printk(KERN_ERR "\n Digest do not match");
 		err = -EBADMSG;
 	    }
 	    /*	else
@@ -719,7 +718,6 @@ aead_crypt(struct aead_request *req, unsigned int enc, uint32_t tag_len)
     unsigned char *temp_ptr[20];
     ctx = ctx + NLM_CRYPTO_MAX_NONCE_SIZE;
     session = (struct crypto_session*)ctx;
-
     sd = malloc(sizeof (struct crypto_param));
     if (!sd) {
 	printk(KERN_ERR
@@ -736,6 +734,17 @@ aead_crypt(struct aead_request *req, unsigned int enc, uint32_t tag_len)
     sd->auth_offset = 0;
     sd->cipher_offset = 0;
 
+    if(!enc && (session->cip->cipher_alg == NLM_CIPHER_3DES))
+    {
+	unsigned char temp_c;
+	unsigned int pos = ((DES3_EDE_KEY_SIZE / 3) *2);
+	for(i = 0; i < (DES3_EDE_KEY_SIZE / 3); i++)
+	{	
+	  temp_c = session->cip->cipher_key->buf[i];
+	  session->cip->cipher_key->buf[i] = session->cip->cipher_key->buf[pos + i];
+	  session->cip->cipher_key->buf[pos + i] = temp_c;
+	}	
+    }
     ret = crypto_setup_cipher_auth_session(session);
     if (ret) {
 	printk(KERN_ERR
@@ -743,7 +752,6 @@ aead_crypt(struct aead_request *req, unsigned int enc, uint32_t tag_len)
 		ret, __FUNCTION__);
 	return -EINVAL;
     }
-
     if(enc)
 	nbytes = cipher_len = req->cryptlen;
     else
@@ -889,6 +897,7 @@ aead_crypt(struct aead_request *req, unsigned int enc, uint32_t tag_len)
     sd->hash_dst_address = (unsigned char *)malloc(tag_len+1);
 
     ret = crypto_cipher_auth_op(session, sd);
+
     if (ret) {
 	printk(KERN_ERR
 		"\nError: Error in cipher auth operation ret = %x. Returning from %s",
@@ -906,14 +915,15 @@ aead_crypt(struct aead_request *req, unsigned int enc, uint32_t tag_len)
     }
     else
     {
+
 	if(len < sg_len)
 	{
 	    if(memcmp((unsigned char *) &sd->dst[i].buf[sd->dst[i].iov_len], sd->hash_dst_address, session->aip->tag_len))
 	    {
-		//		printk(KERN_ERR "\n Digest do not match");
+		//printk(KERN_ERR "\n Digest do not match");
 		err = -EBADMSG;
 	    }
-	    /*	else
+	    /*else
 		printk(KERN_ERR "\n Digest Matched");*/
 	}
     }
@@ -1149,7 +1159,7 @@ aead_3686_crypt(struct aead_request *req, unsigned int enc, uint32_t tag_len)
 	{
 	    if(memcmp((unsigned char *) &sd->dst[i].buf[sd->dst[i].iov_len], sd->hash_dst_address, session->aip->tag_len))
 	    {
-		printk(KERN_ERR "\n Digest do not match");
+		//printk(KERN_ERR "\n Digest do not match");
 		err = -EBADMSG;
 	    }
 	    /*else
@@ -1443,7 +1453,7 @@ aead_4309_crypt(struct aead_request *req, unsigned int enc, uint32_t tag_len)
 	{
 	    if(memcmp((unsigned char *) (&sd->dst[i].buf[sd->dst[i].iov_len]), sd->hash_dst_address, session->aip->tag_len))
 	    {
-		printk(KERN_ERR "\n Digest do not match");
+		//printk(KERN_ERR "\n Digest do not match");
 		err = -EBADMSG;
 	    }
 	    /*else
diff --git a/drivers/crypto/sae/nlm_crypto.c b/drivers/crypto/sae/nlm_crypto.c
index 4064566..7155038 100644
--- a/drivers/crypto/sae/nlm_crypto.c
+++ b/drivers/crypto/sae/nlm_crypto.c
@@ -26,7 +26,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 //#define DEBUG 
 
 #include <linux/module.h>
-
+//#include <sys/ptrace.h>
 //#define KERNEL
 #include <linux/types.h>
 #include <linux/fs.h>
@@ -41,6 +41,8 @@ THE POSSIBILITY OF SUCH DAMAGE.
 //#include <linux/wait.h>		/* for wait_queue */
 #include <linux/init.h>		/* for __init, module_{init,exit} */
 #include <linux/poll.h>		/* for POLLIN, etc. */
+#include <linux/proc_fs.h>
+
 #include <asm/netlogic/msgring.h>
 
 #include <asm/netlogic/hal/nlm_hal_fmn.h>
@@ -72,9 +74,14 @@ static int xlp_sae_major;
 static int xlp_sae_open(struct inode *, struct file *);
 static int xlp_sae_release(struct inode *, struct file *);
 static int nlm_fb_vc;
-static int volatile crypto_status;
 static uint64_t nlm_tx_id, nlm_err_msg;
-//wait_queue_head_t wait;
+struct semaphore sem;
+volatile int msg_hdl = 0;
+
+extern struct proc_dir_entry *nlm_root_proc;
+//static const char *versionstr = "XLP2.0";
+
+#define DRIVER_NAME "nlmsae"
 
 #define NLM_CRYPTO_OP_IN_PROGRESS 0
 #define NLM_CRYPTO_OP_DONE	  1
@@ -108,9 +115,9 @@ extern int xlp_crypt_alg_init(void);
 extern void xlp_crypt_alg_fini(void);
 extern int xlp_auth_alg_init(void);
 extern void xlp_auth_alg_fini(void);
+static void xlp_sae_cleanup(void);
 /********************* H/W Counters  *******************************/
 
-#if 0
 struct crypto_hw_cntrs {
     uint64_t ingress_msg_cntr;
     uint64_t egress_msg_cntr;
@@ -164,10 +171,33 @@ nlm_crypto_print_hw_cntrs(struct crypto_hw_cntrs *hw_cnt)
     static uint64_t
 nlm_crypto_read_reg_lo_hi(int regnum_lo, int regnum_hi)
 {
-    return ((unsigned long long) read_crypto_reg(regnum_lo) |
-	    ((unsigned long long) read_crypto_reg(regnum_hi) << 32));
+    return ((unsigned long long) nlm_hal_read_sae_reg(regnum_lo) |
+	    ((unsigned long long) nlm_hal_read_sae_reg(regnum_hi) << 32));
 }
 
+#define NLM_CRYPTO_REG_ING_MSG_CNTR_LOW		0x87//0x21c
+#define NLM_CRYPTO_REG_ING_MSG_CNTR_HIGH	0x88//0x220
+#define NLM_CRYPTO_REG_EGR_MSG_CNTR_LOW		0x89//0x224
+#define NLM_CRYPTO_REG_EGR_MSG_CNTR_HIGH	0x8a//0x228
+#define NLM_CRYPTO_REG_EGR_ERR_MSG_CNTR_LOW	0x8b//0x22c
+#define NLM_CRYPTO_REG_EGR_ERR_MSG_CNTR_HIGH	0x8c//0x230
+#define NLM_CRYPTO_REG_DMA_RD_LOW_BYTES(i)	(0x8d + i * 0x10)//(0x234 + i * 0x40)
+#define NLM_CRYPTO_REG_DMA_RD_HIGH_BYTES(i)	(0x8e + i * 0x10)//(0x238 + i * 0x40)
+#define NLM_CRYPTO_REG_DMA_WR_LOW_BYTES(i)	(0x8f + i * 0x10)//(0x23c + i * 0x40)
+#define NLM_CRYPTO_REG_DMA_WR_HIGH_BYTES(i)	(0x90 + i * 0x10)//(0x240 + i * 0x40)
+#define NLM_CRYPTO_REG_CIPHER_LOW_BYTES(i)	(0x91 + i * 0x10)//(0x244 + i * 0x40)
+#define NLM_CRYPTO_REG_CIPHER_HIGH_BYTES(i)	(0x92 + i * 0x10)//(0x248 + i * 0x40)
+#define NLM_CRYPTO_REG_HASH_LOW_BYTES(i)	(0x93 + i * 0x10)//(0x24c + i * 0x40)
+#define NLM_CRYPTO_REG_HASH_HIGH_BYTES(i)	(0x94 + i * 0x10)//(0x250 + i * 0x40)
+#define NLM_CRYPTO_REG_OP_CNTR_0_LOW_BYTES(i)	(0x95 + i * 0x10)//(0x254 + i * 0x40)
+#define NLM_CRYPTO_REG_OP_CNTR_0_HIGH_BYTES(i)	(0x96 + i * 0x10)//(0x258 + i * 0x40)
+#define NLM_CRYPTO_REG_OP_CNTR_1_LOW_BYTES(i)	(0x97 + i * 0x10)//(0x25c + i * 0x40)
+#define NLM_CRYPTO_REG_OP_CNTR_1_HIGH_BYTES(i)	(0x98 + i * 0x10)//(0x260 + i * 0x40)
+#define NLM_CRYPTO_REG_OP_CNTR_2_LOW_BYTES(i)	(0x99 + i * 0x10)//(0x264 + i * 0x40)
+#define NLM_CRYPTO_REG_OP_CNTR_2_HIGH_BYTES(i)	(0x9a + i * 0x10)//(0x268 + i * 0x40)
+#define NLM_CRYPTO_REG_OP_CNTR_3_LOW_BYTES(i)	(0x9b + i * 0x10)//(0x26c + i * 0x40)
+#define NLM_CRYPTO_REG_OP_CNTR_3_HIGH_BYTES(i)	(0x9c + i * 0x10)//(0x270 + i * 0x40)
+
     static void
 nlm_crypto_read_hw_counters(struct crypto_hw_cntrs *hw_cnt)
 {
@@ -236,6 +266,7 @@ nlm_crypto_read_hw_counters(struct crypto_hw_cntrs *hw_cnt)
     }
 }
 
+#if 0
 /********************* S/W Counters  *******************************/
 uint64_t crypto_cntr_crypt_ops[NLM_CIPHER_MAX][NLM_CIPHER_MODE_MAX];
 uint64_t crypto_cntr_crypt_bytes[NLM_CIPHER_MAX][NLM_CIPHER_MODE_MAX];
@@ -784,12 +815,9 @@ crypto_cipher_auth_op(struct crypto_session *session, struct crypto_param *cop)
     cprm.designer_fb[2] = cop->designer_fb[2];
     cprm.designer_fb[3] = cop->designer_fb[3];
 
-
-    get_cpu();
     nlm_fb_vc = crypto_get_fb_vc();
     nlm_tx_id = (uint64_t) cop;
 
-    //msgrng_access_enable(mflags);
     ret = nlm_hal_crypto_send_request(crypto_get_vc(), nlm_fb_vc,
 	    (void *) session->cntrl_desc,
 	    virt_to_phys(session->cntrl_desc),
@@ -797,47 +825,11 @@ crypto_cipher_auth_op(struct crypto_session *session, struct crypto_param *cop)
 	    virt_to_phys(session->pkt_desc),
 	    &cprm, nlm_tx_id);
 
-    crypto_status = NLM_CRYPTO_OP_IN_PROGRESS;
-    {
-	uint64_t nlm_rx_id = 0;
-	i = 0;
-	do{
-	    nlm_rx_id = nlm_hal_crypto_receive_response(nlm_fb_vc, &nlm_err_msg);
-	    i++;
-	}while (!nlm_err_msg && nlm_tx_id != nlm_rx_id && i < 500000);
-
-	if (i < 500000 || nlm_err_msg)
-	    ret = crypto_fb_msg_print_err(nlm_err_msg);
-	else
-	{
-	    ret = NLM_ERR_FREEBACK_NOT_RECEIVED;
-	    printf("\n Error _ FreeBack message is not received");
-	}
-	nlm_err_msg = 0;
-    }
-    //msgrng_access_disable(mflags);
-    
-    put_cpu();
-#if 0
-    {
-	init_waitqueue_head (&wait);
-	i = 0;
-	while (crypto_status != NLM_CRYPTO_OP_DONE  && i < 10000) {
-	    i++;
-	    //udelay(1);
-	    wait_event_interruptible_timeout(wait, 0, 1);
-	}
-    }
-    if (!ret) {
-	if (crypto_status == NLM_CRYPTO_OP_DONE)
-	    ret = crypto_fb_msg_print_err(nlm_err_msg);
-	else {
-	    ret = NLM_ERR_FREEBACK_NOT_RECEIVED;
-	    printk(KERN_ERR "\nError: Freeback messgae not received");
-	}
-    }
-#endif
-    //#endif
+    msg_hdl = 0;
+    while(msg_hdl == 0);/*Wait till message ring handler is invoked by freeback message*/
+
+    ret = crypto_fb_msg_print_err(nlm_err_msg);
+
     if (session->flag == 0 && session->pkt_desc)
     {
 	free_cache_aligned_mem(session->pkt_desc);
@@ -919,30 +911,64 @@ nlm_xlp_sae_msgring_handler(uint32_t vc, uint32_t src_id,
 	uint64_t msg0, uint64_t msg1,
 	uint64_t msg2, uint64_t msg3, void *data)
 {
-
-    if (vc == nlm_fb_vc && size == 2) {
+    if (size == 2) {
 	if (nlm_tx_id ==
 		nlm_hal_crypto_process_response(vc, code, src_id, msg0,
 		    msg1, &nlm_err_msg)) {
-	    crypto_status = NLM_CRYPTO_OP_DONE;
-	    nlm_err_msg = 1 | nlm_err_msg;
-	    //printk(KERN_ERR "\n nlm_xlp_sae_msgring_handler nlm_err_msg = %llx", nlm_err_msg);
-	    //		wake_up(&wait);
+	    msg_hdl = 1;
 	}
     }
 }
 
-    int
+
+static struct device_info {
+        int version;
+        dev_t device;
+	struct proc_dir_entry *pdir;
+	struct proc_dir_entry *pstats;
+} dev_info;
+
+static int
+nlm_crypto_read_stats_proc(char *page, char **start, off_t offset, int count,
+                       int *eof, void *data)
+{
+        int len = 0;
+	struct crypto_hw_cntrs hw_cnt;
+
+	nlm_crypto_read_hw_counters(&hw_cnt);
+	nlm_crypto_print_hw_cntrs(&hw_cnt);
+
+	*start = page + offset;
+        len = 0;
+        *eof = 1;
+        return len;
+}
+
+
+int
 nlm_crypto_init(void)
 {
+    int ret = 0;
+    struct proc_dir_entry *entry;
+
     init_crypto_vc();
-#if 1
+
+    entry = create_proc_read_entry("crypto_stats", 0, nlm_root_proc,
+		    nlm_crypto_read_stats_proc,
+		    0);
+
+    if(entry == NULL) {
+	    printk("%s:%d failed creating proc stats entry.\n",
+			    __FUNCTION__, __LINE__);
+	    ret = -EINVAL;
+    }
+
     if (register_xlp_msgring_handler
-	    (XLP_MSG_HANDLE_CRYPTO, nlm_xlp_sae_msgring_handler, NULL)) {
-	panic("can't register msgring handler for TX_STN_GMAC0");
+		    (XLP_MSG_HANDLE_CRYPTO, nlm_xlp_sae_msgring_handler, NULL)) {
+	    panic("can't register msgring handler for TX_STN_GMAC0");
     }
-#endif
-    return 0;
+    sema_init(&sem, 0);
+    return ret;
 }
 
     static int __init
@@ -969,12 +995,15 @@ xlp_sae_init(void)
 xlp_sae_cleanup(void)
 {
     xlp_crypt_alg_fini();
-    xlp_aead_alg_fini();
     xlp_auth_alg_fini();
-    unregister_chrdev(xlp_sae_major, "XLP_SAE");
+    xlp_aead_alg_fini();
+    unregister_chrdev(xlp_sae_major, "NLM_XLP_SAE");
+
+    if(dev_info.pdir)
+    	remove_proc_entry("crypto_stats", nlm_root_proc);
 }
 
-EXPORT_SYMBOL(nlm_crypto_init);
+//EXPORT_SYMBOL(nlm_crypto_init);
 EXPORT_SYMBOL(crypto_cleanup_session);
 EXPORT_SYMBOL(crypto_session_reset_key);
 EXPORT_SYMBOL(crypto_setup_cipher_auth_session);
diff --git a/drivers/crypto/sae/nlm_enc.c b/drivers/crypto/sae/nlm_enc.c
index 4628703..d12e9b1 100755
--- a/drivers/crypto/sae/nlm_enc.c
+++ b/drivers/crypto/sae/nlm_enc.c
@@ -240,6 +240,18 @@ xlp_crypt(struct blkcipher_desc *desc,
     sd->iv = NULL;
 
     session->cip->cipher_mode = mode;
+    if(!enc && (session->cip->cipher_alg == NLM_CIPHER_3DES))
+    {
+	unsigned char temp_c;
+	unsigned int pos = ((DES3_EDE_KEY_SIZE / 3) *2);
+	for(i = 0; i < (DES3_EDE_KEY_SIZE / 3); i++)
+	{	
+	  temp_c = session->cip->cipher_key->buf[i];
+	  session->cip->cipher_key->buf[i] = session->cip->cipher_key->buf[pos + i];
+	  session->cip->cipher_key->buf[pos + i] = temp_c;
+	}	
+    }
+
     ret = crypto_setup_cipher_auth_session(session);
     if (ret) {
 	printk(KERN_ERR
@@ -390,7 +402,6 @@ xlp_ctr_rfc3686_decrypt(struct blkcipher_desc *desc,
 	struct scatterlist *dst, struct scatterlist *src,
 	unsigned int nbytes)
 {
-    //printk(KERN_ERR "\n enc: xlp_ctr_rfc3686_decrypt"); 
     return crypto_rfc3686_crypt(desc, dst, src, nbytes, 0, NLM_CIPHER_MODE_CTR);
 }
 
@@ -399,7 +410,6 @@ xlp_ctr_rfc3686_encrypt(struct blkcipher_desc *desc,
 	struct scatterlist *dst, struct scatterlist *src,
 	unsigned int nbytes)
 {
-    //printk(KERN_ERR "\n enc: xlp_ctr_rfc3686_encrypt"); 
     return crypto_rfc3686_crypt(desc, dst, src, nbytes, 1, NLM_CIPHER_MODE_CTR);
 }
 
@@ -409,8 +419,6 @@ xlp_cbc_decrypt(struct blkcipher_desc *desc,
 	struct scatterlist *dst, struct scatterlist *src,
 	unsigned int nbytes)
 {
-    //printk(KERN_ERR "\n enc: xlp_cbc_decrypt"); 
-    //return 0;
     return xlp_crypt(desc, dst, src, nbytes, 0, NLM_CIPHER_MODE_CBC);
 }
 
@@ -419,8 +427,6 @@ xlp_cbc_encrypt(struct blkcipher_desc *desc,
 	struct scatterlist *dst, struct scatterlist *src,
 	unsigned int nbytes)
 {
-    //printk(KERN_ERR "\n enc: xlp_cbc_encrypt   -------------3");
-    //return 0; 
     return xlp_crypt(desc, dst, src, nbytes, 1, NLM_CIPHER_MODE_CBC);
 }
 
@@ -530,13 +536,11 @@ xlp_crypt_alg_init(void)
 	printk(KERN_ERR "\n Modlue not registred");
 	goto err3;
     }
-#if 1
     ret = crypto_register_alg(&xlp_ctr_aes_alg);
     if (ret) {
 	printk(KERN_ERR "\n Modlue not registred");
 	goto err2;
     }
-#endif
     ret = crypto_register_alg(&xlp_cbc_aes_alg);
     if (ret) {
 	printk(KERN_ERR "\n Modlue not registred");
@@ -548,10 +552,8 @@ err4:
     crypto_unregister_alg(&xlp_cbc_des3_alg);
 err3:
     crypto_unregister_alg(&xlp_cbc_des_alg);
-#if 1
 err2:
     crypto_unregister_alg(&xlp_ctr_aes_alg);
-#endif
 err1:
     crypto_unregister_alg(&xlp_cbc_aes_alg);
 
@@ -565,9 +567,7 @@ xlp_crypt_alg_fini(void)
 {
     crypto_unregister_alg(&xlp_cbc_des3_alg);
     crypto_unregister_alg(&xlp_cbc_des_alg);
-#if 1
     crypto_unregister_alg(&xlp_ctr_aes_alg);
-#endif
     crypto_unregister_alg(&xlp_cbc_aes_alg);
 }
 
-- 
1.9.1

