From 26d4004133a63d3dd1bf61a0c3c1636dc0034ff4 Mon Sep 17 00:00:00 2001
From: Xiaoyi Liu <xiaoyi@broadcom.com>
Date: Wed, 27 Nov 2013 01:46:40 -0500
Subject: [PATCH 0860/1532] fmnlib: support CRYPTO entry in fmn dts file.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c | 53 ++++++++++++++++++++++
 1 file changed, 53 insertions(+)

diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
index 534f552..43311af 100644
--- a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
@@ -344,6 +344,32 @@ static int get_num_naetx_queues(void *fdt, int node, int station)
         return num_queues;
 }
 
+static int get_num_sae_queues(void *fdt, int node, int station)
+{
+        char prop_str[10];
+        int plen, nodeoffset;
+        char fmn_cfg_str[80];
+        uint32_t *pval;
+        int num_queues = -1;
+        struct fmn_qsize_credit_config *fmn_q_config;
+
+        if ((station > max_msg_blks) || (station != XLP_MSG_BLK_CRYPTO))
+                return -1;
+
+        fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+        sprintf(fmn_cfg_str, "/soc/fmn@node-%d/q-config/%s", node, fmn_q_config[station].q_name);
+        nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
+        if(nodeoffset < 0)
+                return -1;
+
+        pval = (uint32_t *)fdt_getprop(fdt, nodeoffset,"num-sae-queues", &plen);
+        if(pval != NULL) {
+                num_queues = fdt32_to_cpu(*(uint32_t *)pval);
+        }
+        return num_queues;
+}
+
+
 
 static int get_fmn_dts_version(void *fdt, int node)
 {
@@ -1152,6 +1178,7 @@ int nlm_hal_setup_outq(void *fdt, int node, int max_nodes)
 	const uint32_t q_ram_page_entries_9xx = 64; /* entries, not bytes */
 	int cnt =0, oq_num32pages = 0, oq_num32pages_stn , num_valid_queues;
 	struct fmn_qsize_credit_config *fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+	int single_sae_vc = 0;
 	
 
 	if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
@@ -1190,6 +1217,16 @@ int nlm_hal_setup_outq(void *fdt, int node, int max_nodes)
 				if (num_valid_queues < 0)
 					num_valid_queues = 64;
 			}
+
+                        if (station == XLP_MSG_BLK_CRYPTO) {
+                                num_valid_queues = get_num_sae_queues(fdt, node, station);
+                                if (num_valid_queues <0) {
+                                        num_valid_queues = 8; /* default number of SAE queues on 9xx */
+                                } else if (num_valid_queues == 1) {
+                                        single_sae_vc = 1;
+                                }
+                        }
+
 		
 			for (; qid <= fmn_q_config[station].e_stid; qid++) {
 				q_enable = 1ULL;
@@ -1214,6 +1251,15 @@ int nlm_hal_setup_outq(void *fdt, int node, int max_nodes)
 					q_enable = 0ULL;
 					oq_num32pages = 2;
 				}
+                                else if ((station == XLP_MSG_BLK_CRYPTO) && ((qid >= (XLP_9XX_SEC_VC_BASE + num_valid_queues)) && (qid <= XLP_9XX_SEC_VC_LIMIT))) {
+#ifdef FMN_DEBUG
+                                        nlm_print("Disabling SAE queue qid %d\n", qid);
+#endif
+                                        fmn_cfg_value[qid] = 0;
+                                        q_enable = 0ULL;
+                                        oq_num32pages = 2;
+                                }
+
 				/* enable output queue and setup on-chip output queue */
 				val = q_enable << 63; /* enable */
 
@@ -1255,6 +1301,13 @@ int nlm_hal_setup_outq(void *fdt, int node, int max_nodes)
 
 				val |= 1ULL << 62; /* enable spill */
 
+                                if (station == XLP_MSG_BLK_CRYPTO && q_enable && single_sae_vc) {
+#ifdef FMN_DEBUG
+                                        nlm_print("Enabling RxQDepth for SAE qid %d\n", qid);
+#endif
+                                        val |= 1ULL << 51;
+                                }
+
 				/* carve the total fmn_spill area into all 32 VC's here */
 				q_spill_pages = fmn_cfg_value[qid] / (FMN_Q_PAGE_SIZE);
 				/* if spill_start + qsize crosses 256MB boundary, configuration will be wrong as
-- 
1.9.1

