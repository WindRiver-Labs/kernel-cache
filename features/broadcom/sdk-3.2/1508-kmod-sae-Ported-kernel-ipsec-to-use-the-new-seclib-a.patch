From f43907292f78640479f05c8c138ad174d4cd49c5 Mon Sep 17 00:00:00 2001
From: reshmic <reshmic@broadcom.com>
Date: Wed, 12 Jun 2013 19:44:02 +0530
Subject: [PATCH 1508/1532] kmod/sae : Ported kernel ipsec to use the new
 seclib api

[Based on SDK 3.2]
Delete the function "nlm_hal_get_sae_chip_feature" because it's unused and
conflicts with the same function in "syslib/src/nlm_hal.c"

Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/crypto/sae/nlm_aead.c   | 1360 ++++++++++++++++++---------------------
 drivers/crypto/sae/nlm_async.h  |    7 +-
 drivers/crypto/sae/nlm_auth.c   |  624 +++++++++---------
 drivers/crypto/sae/nlm_crypto.c |  500 ++++----------
 drivers/crypto/sae/nlm_enc.c    |  295 +++++----
 5 files changed, 1184 insertions(+), 1602 deletions(-)

diff --git a/drivers/crypto/sae/nlm_aead.c b/drivers/crypto/sae/nlm_aead.c
index 67d481a..c6c042d 100755
--- a/drivers/crypto/sae/nlm_aead.c
+++ b/drivers/crypto/sae/nlm_aead.c
@@ -20,10 +20,16 @@
 #include <crypto/sha.h>
 #include <crypto/aead.h>
 #include <crypto/authenc.h>
+#include <crypto/algapi.h>
 
-#include <asm/netlogic/hal/nlm_hal_fmn.h>
-#include <asm/netlogic/msgring.h>
+#include <nlm_hal_fmn.h>
+#include "saesoc_lib.h"
 #include "nlm_async.h"
+#include <nlm_xlp.h>
+#include <linux/module.h>
+#include <nlm_msgring.h>
+
+
 
 #undef NLM_CRYPTO_DEBUG
 #define Message(a, b...) //printk("[%s @ %d] "a"\n",__FUNCTION__,__LINE__, ##b)
@@ -52,10 +58,13 @@
 
 struct nlm_aead_ctx
 {
-	struct nlm_crypto_pkt_ctrl ctrl;
+	struct saesoc_session_desc enc_s_desc;
+	unsigned long long key[20];
+	struct saesoc_session_desc dec_s_desc;
+	unsigned long long d_key[20];
+	struct saesoc_session_init_params initp;
 	uint8_t iv_buf[16];
 	uint32_t iv_len;
-	int cbc;
 	uint16_t stat;
 	struct crypto_aead  * fallback;
 };
@@ -64,7 +73,7 @@ struct nlm_aead_ctx
 #define CTRL_DESC_SIZE		(sizeof(struct nlm_aead_ctx) + 128)
 #define DES3_CTRL_DESC_SIZE	(2*CTRL_DESC_SIZE + 2*64)	//Allocate 2 separate control desc for encryption and decryption
 #define CACHE_ALIGN		64
-#define IV_AEAD_PADDING         128
+#define IV_AEAD_PADDING         128 
 #define TAG_LEN			64
 
 /*
@@ -74,9 +83,9 @@ struct nlm_aead_ctx
 	|  for alignment | 18 * (2*64)			  | for alignment |			    | for hash |
 	 ------------------------------------------------------------------------------------------------------
  */
-#define PACKET_DESC_SIZE	(CACHE_ALIGN + sizeof(struct nlm_crypto_pkt_param) + (MAX_FRAGS*(2*8)) + 64 + sizeof(struct nlm_async_crypto) + 64 + IV_AEAD_PADDING + TAG_LEN)
-#define NLM_CRYPTO_PKT_PARAM_OFFSET(addr)	(((unsigned long)addr + CACHE_ALIGN ) & ~0x3fUL)
-#define NLM_ASYNC_PTR_PARAM_OFFSET(addr)	((unsigned long)addr + CACHE_ALIGN + sizeof(struct nlm_crypto_pkt_param) + (MAX_FRAGS*(2*8)) + 64 + ~0x3fUL) 
+#define PACKET_DESC_SIZE        (64 + sizeof(struct saesoc_data_desc) + (MAX_FRAGS*8) + sizeof(struct nlm_async_crypto) + TAG_LEN + IV_AEAD_PADDING + 128)
+#define NLM_CRYPTO_DATA_DESC(addr)  (struct saesoc_data_desc *) (((unsigned long)addr + 63) & ~0x3fUL)
+#define NLM_ASYNC_PTR_PARAM_OFFSET(addr)        (((unsigned long)addr +  sizeof(struct saesoc_data_desc) + (MAX_FRAGS*8) + 63) & ~0x3fUL)
 #define NLM_HASH_OFFSET(addr)			((unsigned long)addr + (PACKET_DESC_SIZE - TAG_LEN))
 #define NLM_IV_OFFSET(addr)			((unsigned long)addr + (PACKET_DESC_SIZE - TAG_LEN - IV_AEAD_PADDING ))
 
@@ -88,21 +97,12 @@ struct nlm_aead_ctx
 
 #define PKT_DESC_OFF 64
 
-#ifdef NLM_CRYPTO_DEBUG
-extern void print_crypto_msg_desc(uint64_t entry1, uint64_t entry2, uint64_t entry3);
-extern void print_cntl_instr(uint64_t cntl_desc);
-extern void print_pkt_desc(struct nlm_crypto_pkt_param  *pkt_desc, int index);
-#endif
 extern struct nlm_crypto_stat crypto_stat[MAX_CPU];
 
 
 /*
    All extern declaration goes here.
  */
-extern uint32_t nlm_hal_send_msg3(uint32_t dst, uint32_t code, uint64_t data0, uint64_t data1, uint64_t data2);
-extern uint32_t nlm_hal_recv_msg2(uint32_t dst, uint32_t *src, uint32_t *size, uint32_t *code, uint64_t *data0, uint64_t *data1);
-extern int auth_mode_key_len[NLM_HASH_MAX][NLM_HASH_MODE_MAX];
-extern int cipher_mode_iv_len[NLM_CIPHER_MAX][NLM_CIPHER_MODE_MAX];
 extern int alloc_pkt_param( struct nlm_async_crypto * async,struct nlm_crypto_pkt_param ** pkt_param, int max_frags );
 
 
@@ -155,11 +155,8 @@ static int aead_setauthsize(struct crypto_aead *tfm, unsigned int authsize)
 static void aead_session_cleanup(struct crypto_tfm *tfm)
 {
 }
-
 static int aead_cra_cbc_init(struct crypto_tfm *tfm)
 {
-	struct nlm_aead_ctx *nlm_ctx = (struct nlm_aead_ctx *)nlm_crypto_tfm_ctx(tfm);
-	nlm_ctx->cbc = 1;
 	tfm->crt_aead.reqsize = PACKET_DESC_SIZE; 
 	return 0;
 }
@@ -167,29 +164,22 @@ static int aead_cra_cbc_init(struct crypto_tfm *tfm)
 static int aead_cra_init_ccm(struct crypto_tfm *tfm)
 {
 	struct nlm_aead_ctx *nlm_ctx = (struct nlm_aead_ctx *)nlm_crypto_tfm_ctx(tfm);
-	nlm_ctx->cbc = 0;
 	tfm->crt_aead.reqsize = PACKET_DESC_SIZE; 
 	nlm_ctx->fallback = crypto_alloc_aead("rfc4309(ccm(aes-generic))",CRYPTO_ALG_TYPE_AEAD ,0) ;
 	return 0;
 }
-
 static int aead_cra_init_gcm(struct crypto_tfm *tfm)
 {
 	struct nlm_aead_ctx *nlm_ctx = (struct nlm_aead_ctx *)nlm_crypto_tfm_ctx(tfm);
-	nlm_ctx->cbc = 0;
 	tfm->crt_aead.reqsize = PACKET_DESC_SIZE; 
 	nlm_ctx->fallback = crypto_alloc_aead("rfc4106(gcm(aes-generic))",CRYPTO_ALG_TYPE_AEAD ,0) ;
 	return 0;
 }
-
 static int aead_cra_init(struct crypto_tfm *tfm)
 {
-	struct nlm_aead_ctx *nlm_ctx = (struct nlm_aead_ctx *)nlm_crypto_tfm_ctx(tfm);
-	nlm_ctx->cbc = 0;
 	tfm->crt_aead.reqsize = PACKET_DESC_SIZE; 
 	return 0;
 }
-
 static int get_cipher_auth_keylen(const u8 *key, unsigned int keylen, int *cipher_keylen,
 			     int *auth_keylen)
 {
@@ -228,13 +218,13 @@ static int get_cipher_aes_algid(unsigned int cipher_keylen)
 
 	switch (cipher_keylen) {
 	case 16:
-		return NLM_CIPHER_AES128;
+		return SAESOC_CIPHER_TYPE_AES_128;
 		break;
 	case 24:
-		return NLM_CIPHER_AES192;
+		return SAESOC_CIPHER_TYPE_AES_192;
 		break;
 	case 32:
-		return NLM_CIPHER_AES256;
+		return SAESOC_CIPHER_TYPE_AES_256;
 		break;
 	default:
 		printk(KERN_WARNING "[%s]: Cannot handle keylen = %d\n",
@@ -249,13 +239,13 @@ static int get_auth_aes_algid(unsigned int hash_keylen)
 
 	switch (hash_keylen) {
 	case 16:
-		return NLM_HASH_AES128;
+		return SAESOC_HASH_TYPE_AES_128;
 		break;
 	case 24:
-		return NLM_HASH_AES192;
+		return SAESOC_HASH_TYPE_AES_192;
 		break;
 	case 32:
-		return NLM_HASH_AES256;
+		return SAESOC_HASH_TYPE_AES_256;
 		break;
 	default:
 		printk(KERN_WARNING "[%s]: Cannot handle keylen = %d\n",
@@ -263,23 +253,24 @@ static int get_auth_aes_algid(unsigned int hash_keylen)
 	    return -EINVAL;
 	}
 }
-
 /*
    All Setkey goes here.
  */
 
 static int xlp_aes_cbc_setkey( struct crypto_aead *tfm, uint8_t *key, unsigned int keylen,
-				int hash, int mode,uint16_t h_stat )
+				int hash_type, int hash_mode,uint16_t h_stat , int expected_keylen)
 { 
 	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
-	struct nlm_crypto_pkt_ctrl *ctrl = &ctx->ctrl;
+	struct saesoc_session_init_params *initp = &ctx->initp;
 	unsigned int cipher_keylen=0, auth_keylen=0;
 	int ret;
 	int cipher_alg;
 	uint8_t auth_key[128];
 	uint8_t *cipher_key;
 	struct rtattr *rta = (struct rtattr *)key;
-	int hmac = ((mode == NLM_HASH_MODE_XCBC) ? 0: 1);
+	int nsdescs ;
+	struct saesoc_session_desc *s_desc ;
+
 	if ((ret = get_cipher_auth_keylen(key, keylen, &cipher_keylen,
 					  &auth_keylen)) < 0) {
 		crypto_aead_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
@@ -299,99 +290,71 @@ static int xlp_aes_cbc_setkey( struct crypto_aead *tfm, uint8_t *key, unsigned i
 	key += RTA_ALIGN(rta->rta_len);
 	cipher_key = key + auth_keylen;
 	memcpy(auth_key, key, auth_keylen);
-	if(auth_mode_key_len[hash][mode] > auth_keylen)
-		memset(auth_key + auth_keylen, 0,  auth_mode_key_len[hash][mode] - auth_keylen);
-
-	if(cipher_mode_iv_len[cipher_alg][NLM_CIPHER_MODE_CBC] > 0)
-		ctx->iv_len = cipher_mode_iv_len[cipher_alg][NLM_CIPHER_MODE_CBC];
+	if(expected_keylen > auth_keylen)
+		memset(auth_key + auth_keylen, 0,  expected_keylen - auth_keylen);
 
-	auth_keylen = auth_mode_key_len[hash][mode];
+	ctx->iv_len = 16;
 
-	#ifdef 	NLM_CRYPTO_DEBUG
-	printk("Initial authkeylen %d, cipherkeylen %d\n", cipher_keylen, auth_keylen);
-	print_buf("ENC_KEY:", cipher_key, cipher_keylen);
-	print_buf("AUTH_KEY:", auth_key, auth_keylen);
-	#endif
+	auth_keylen = expected_keylen;
 
-	ret =  nlm_crypto_fill_pkt_ctrl(ctrl, hmac, hash, 
-			mode, cipher_alg, NLM_CIPHER_MODE_CBC, 0, cipher_key, 
-			cipher_keylen, auth_key, auth_keylen,1);
-
-	return ret;
-}
 
-static int xlp_aes_ctr_setkey( struct crypto_aead *tfm, u8 *key,
-					unsigned int keylen, int hash, int mode, uint16_t h_stat)
-{
-	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
-	struct nlm_crypto_pkt_ctrl *ctrl = &ctx->ctrl;
-	unsigned int cipher_keylen=0, auth_keylen=0;
-	int ret;
-	int nonce_len = CTR_RFC3686_NONCE_SIZE;
-	int cipher_alg;
-	uint8_t auth_key[128];
-	uint8_t *cipher_key;
-	struct rtattr *rta = (struct rtattr *)key;
-	int hmac = ((mode == NLM_HASH_MODE_XCBC) ? 0: 1);
+	/* assoc | iv | payload 
+	  |----auth offset
+	         |------iv offset
+		      |--->cipher offset 
+		      */
 
-	if ((ret = get_cipher_auth_keylen(key, keylen, &cipher_keylen,
-					  &auth_keylen)) < 0) {
-		crypto_aead_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
-		printk("ERR: Bad key len\n");
-		return ret;
-	}
+	initp->cipher.type = cipher_alg;
+        initp->cipher.mode = SAESOC_CIPHER_MODE_CBC;	
+	initp->cipher.iv_offset = 8;
+	initp->cipher.iv_mode = 0;
+	initp->cipher.key = (char *)cipher_key;
+	initp->cipher.key_len = cipher_keylen;
+	initp->cipher.cfb_mask = 0;
+	initp->cipher.flags = SAESOC_CF_ENCRYPT;
+	initp->hash.type = hash_type;
+	initp->hash.mode = hash_mode;
+	initp->hash.iv_offset = 8;
+	initp->hash.key = auth_key;
+	initp->hash.key_len = auth_keylen;
+	initp->hash.mute_mask_sel = 0;
+	initp->hash.tag_len = saesoc_gen1_tag_len[hash_type];
+	initp->hash.tagin_offset = 0;
+	initp->hash.aad_offset = 0;
+	initp->hash.addl_hash_len = 16; /* iv len */ 
+	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC | SAESOC_HF_HASHINP_IS_CIPHEROUT;
+	initp->payload_offset = 8 + 16 ; /* assoc len + ivlen */
+	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
 
-	cipher_keylen -= nonce_len;
+	nsdescs = saesoc_calc_sdesc_cnt(&ctx->initp,NULL);
+	s_desc = &ctx->enc_s_desc;
 
-	cipher_alg = get_cipher_aes_algid(cipher_keylen);
-	if (cipher_alg < 0) {
-		crypto_aead_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
-		//sandip: check return val
-		printk("ERR: Bad aes key len\n");
-		return -EINVAL;
-	}
-	ctx->stat = cipher_alg - 1 + 3;
-	ctx->stat = ctx->stat | (h_stat << 8);
-	key += RTA_ALIGN(rta->rta_len);
-	memcpy(auth_key, key, auth_keylen);
-	cipher_key = key + auth_keylen;
-	memcpy(ctx->iv_buf,key+auth_keylen+cipher_keylen, nonce_len);
-	#ifdef 	NLM_CRYPTO_DEBUG
-	printk("Initial authkeylen %d, cipherkeylen %d\n", cipher_keylen, auth_keylen);
-	print_buf ( "key",key,128);
-	print_buf("NONCE:", &ctx->iv_buf[0] , nonce_len);
-	#endif
 
-	if ( auth_mode_key_len[hash][mode] > auth_keylen)
-		memset(auth_key + auth_keylen, 0,  auth_mode_key_len[hash][mode] - auth_keylen);
-	if(cipher_mode_iv_len[cipher_alg][NLM_CIPHER_MODE_CTR] > 0)
-		ctx->iv_len = cipher_mode_iv_len[cipher_alg][NLM_CIPHER_MODE_CTR];
+	if(saesoc_new_session(&ctx->initp,&s_desc,nsdescs, NULL) < 0)
+		 printk("%s,%d Error \n", __FUNCTION__, __LINE__); 
 
-	auth_keylen = auth_mode_key_len[hash][mode];
+	initp->cipher.flags = 0;
+	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC; 
 
-	#ifdef 	NLM_CRYPTO_DEBUG
-	print_buf("ENC_KEY:", cipher_key, cipher_keylen);
-	print_buf("AUTH_KEY:", auth_key, auth_keylen);
-	#endif
+	s_desc = &ctx->dec_s_desc;
 
-	ret =  nlm_crypto_fill_pkt_ctrl(ctrl, hmac, hash,
-		mode, cipher_alg, NLM_CIPHER_MODE_CTR, 0, cipher_key,
-		cipher_keylen, auth_key, auth_keylen,1);
+	if(saesoc_new_session(&ctx->initp,&s_desc,nsdescs, NULL) < 0)
+		 printk("%s,%d Error \n", __FUNCTION__, __LINE__); 
 
 	return ret;
 }
-static int  xlp_3des_setkey(struct crypto_aead *tfm, u8 *key, unsigned int keylen, int hash, int mode,uint16_t h_stat )
+
+static int  xlp_3des_setkey(struct crypto_aead *tfm, u8 *key, unsigned int keylen, int hash_type, int hash_mode,uint16_t h_stat, int expected_keylen )
 {
 	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
-	struct nlm_aead_ctx * nlm_ctx = (struct  nlm_aead_ctx *)(( unsigned long )(( uint8_t *)ctx + CTRL_DESC_SIZE + 64) & ~(0x3fUL));
+	struct saesoc_session_init_params *initp = &ctx->initp;
         unsigned int cipher_keylen=0, auth_keylen=0;
-	struct nlm_crypto_pkt_ctrl *ctrl = &ctx->ctrl;
         int ret;
 	uint8_t auth_key[128];
-	int cipher_alg = NLM_CIPHER_3DES;
 	struct rtattr *rta = (struct rtattr *)key;
 	uint8_t *cipher_key;
-	int hmac = ((mode == NLM_HASH_MODE_XCBC) ? 0: 1);
+	int nsdescs ;
+	struct saesoc_session_desc *s_desc ;
 
         if ((ret = get_cipher_auth_keylen(key, keylen, &cipher_keylen,
                                           &auth_keylen)) < 0) {
@@ -403,43 +366,70 @@ static int  xlp_3des_setkey(struct crypto_aead *tfm, u8 *key, unsigned int keyle
 	key += RTA_ALIGN(rta->rta_len);
 	memcpy(auth_key, key, auth_keylen);
 	cipher_key = key + auth_keylen;
-	if ( auth_mode_key_len[hash][mode] > auth_keylen)
-		memset(auth_key + auth_keylen, 0,  auth_mode_key_len[hash][mode] - auth_keylen);
+	if ( expected_keylen > auth_keylen)
+		memset(auth_key + auth_keylen, 0,   expected_keylen -  auth_keylen);
 	
-	if(cipher_mode_iv_len[cipher_alg][NLM_CIPHER_MODE_CBC] > 0) {
-		ctx->iv_len = cipher_mode_iv_len[cipher_alg][NLM_CIPHER_MODE_CBC];
-		nlm_ctx->iv_len = cipher_mode_iv_len[cipher_alg][NLM_CIPHER_MODE_CBC];
-	}
-	auth_keylen = auth_mode_key_len[hash][mode];
+	ctx->iv_len = 8;
+	auth_keylen = expected_keylen;
+
+
+	/* assoc | iv | payload 
+	  |----auth offset
+	         |------iv offset
+		      |--->cipher offset 
+		      */
+
+	initp->cipher.type = SAESOC_CIPHER_TYPE_TDES;
+        initp->cipher.mode = SAESOC_CIPHER_MODE_CBC;	
+	initp->cipher.iv_offset = 8;
+	initp->cipher.iv_mode = 0;
+	initp->cipher.key = (char *)cipher_key;
+	initp->cipher.key_len = cipher_keylen;
+	initp->cipher.cfb_mask = 0;
+	initp->cipher.flags = SAESOC_CF_ENCRYPT;
+	initp->hash.type = hash_type;
+	initp->hash.mode = hash_mode;
+	initp->hash.iv_offset = 8;
+	initp->hash.key = auth_key;
+	initp->hash.key_len = auth_keylen;
+	initp->hash.mute_mask_sel = 0;
+	initp->hash.tag_len = saesoc_gen1_tag_len[hash_type];
+	initp->hash.tagin_offset = 0;
+	initp->hash.aad_offset = 0;
+	initp->hash.addl_hash_len = 8; /* iv len */ 
+	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC | SAESOC_HF_HASHINP_IS_CIPHEROUT;
+	initp->payload_offset = 8 + 8 ; /* assoc len + ivlen */
+	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
+
+	nsdescs = saesoc_calc_sdesc_cnt(&ctx->initp,NULL);
+	s_desc = &ctx->enc_s_desc;
+
+
+	if(saesoc_new_session(&ctx->initp,&s_desc,nsdescs, NULL) < 0)
+		 printk("%s,%d Error \n", __FUNCTION__, __LINE__); 
+
+	initp->cipher.flags = 0;
+	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC; 
+
+	s_desc = &ctx->dec_s_desc;
+
+	if(saesoc_new_session(&ctx->initp,&s_desc,nsdescs, NULL) < 0)
+		 printk("%s,%d Error \n", __FUNCTION__, __LINE__); 
 
-	ret =  nlm_crypto_fill_pkt_ctrl(ctrl, hmac, hash,
-		mode, cipher_alg,NLM_CIPHER_MODE_CBC,0,cipher_key,
-		 cipher_keylen, auth_key, auth_keylen,1);
-	
-	nlm_ctx->stat = TDES_CBC_STAT | h_stat << 8;;
-	ret =  nlm_crypto_fill_pkt_ctrl(&nlm_ctx->ctrl, hmac, hash,
-			mode, cipher_alg, NLM_CIPHER_MODE_CBC, 0, cipher_key,
-			cipher_keylen, auth_key, auth_keylen,0);
-	#ifdef NLM_CRYPTO_DEBUG 
-	print_buf("ENC_KEY:", cipher_key, cipher_keylen);
-	print_buf("AUTH_KEY:", auth_key, auth_keylen);
-	print_buf("DECRY_KEY",(unsigned char * )&d_key[0],cipher_keylen);
-	#endif
 
         return ret;
 }
-
-static int xlp_des_setkey( struct crypto_aead *tfm, uint8_t  *key, unsigned int keylen, int hash, int mode, uint16_t h_stat)
+static int xlp_des_setkey( struct crypto_aead *tfm, uint8_t  *key, unsigned int keylen, int hash_type, int hash_mode, uint16_t h_stat, int expected_keylen)
 {
 	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
+	struct saesoc_session_init_params *initp = &ctx->initp;
         unsigned int cipher_keylen=0, auth_keylen=0;
-	struct nlm_crypto_pkt_ctrl *ctrl = &ctx->ctrl;
         int ret;
 	uint8_t auth_key[128];
-	int cipher_alg = NLM_CIPHER_DES;
 	struct rtattr *rta = (struct rtattr *)key;
 	uint8_t *cipher_key;
-	int hmac = ((mode == NLM_HASH_MODE_XCBC) ? 0: 1);
+	int nsdescs ;
+	struct saesoc_session_desc *s_desc ;
 	ctx->stat = DES_CBC_STAT | h_stat << 8;
 	
 
@@ -452,22 +442,54 @@ static int xlp_des_setkey( struct crypto_aead *tfm, uint8_t  *key, unsigned int
 	key += RTA_ALIGN(rta->rta_len);
 	memcpy(auth_key, key, auth_keylen);
 	cipher_key = key + auth_keylen;
-	if ( auth_mode_key_len[hash][mode] > auth_keylen)
-		memset(auth_key + auth_keylen, 0,  auth_mode_key_len[hash][mode] - auth_keylen);
-	
-	if(cipher_mode_iv_len[cipher_alg][NLM_CIPHER_MODE_CBC] > 0) {
-		ctx->iv_len = cipher_mode_iv_len[cipher_alg][NLM_CIPHER_MODE_CBC];
-	}
-	auth_keylen = auth_mode_key_len[hash][mode];
-
-	ret =  nlm_crypto_fill_pkt_ctrl(ctrl, hmac, hash,
-		mode, cipher_alg,NLM_CIPHER_MODE_CBC,0,cipher_key,
-		 cipher_keylen, auth_key, auth_keylen,1);
+	if ( expected_keylen > auth_keylen)
+		memset(auth_key + auth_keylen, 0,  expected_keylen - auth_keylen);
 	
-	#ifdef NLM_CRYPTO_DEBUG 
-	print_buf("ENC_KEY:", cipher_key, cipher_keylen);
-	print_buf("AUTH_KEY:", auth_key, auth_keylen);
-	#endif
+	ctx->iv_len = 8;
+
+	auth_keylen = expected_keylen;
+
+	/* assoc | iv | payload 
+	  |----auth offset
+	         |------iv offset
+		      |--->cipher offset 
+		      */
+
+	initp->cipher.type = SAESOC_CIPHER_TYPE_DES;
+        initp->cipher.mode = SAESOC_CIPHER_MODE_CBC;	
+	initp->cipher.iv_offset = 8;
+	initp->cipher.iv_mode = 0;
+	initp->cipher.key = (char *)cipher_key;
+	initp->cipher.key_len = cipher_keylen;
+	initp->cipher.cfb_mask = 0;
+	initp->cipher.flags = SAESOC_CF_ENCRYPT;
+	initp->hash.type = hash_type;
+	initp->hash.mode = hash_mode;
+	initp->hash.iv_offset = 8;
+	initp->hash.key = auth_key;
+	initp->hash.key_len = auth_keylen;
+	initp->hash.mute_mask_sel = 0;
+	initp->hash.tag_len = saesoc_gen1_tag_len[hash_type];
+	initp->hash.tagin_offset = 0;
+	initp->hash.aad_offset = 0;
+	initp->hash.addl_hash_len = 8; /* iv len */ 
+	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC | SAESOC_HF_HASHINP_IS_CIPHEROUT;
+	initp->payload_offset = 8 + 8 ; /* assoc len + ivlen */
+	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
+
+	nsdescs = saesoc_calc_sdesc_cnt(&ctx->initp,NULL);
+	s_desc = &ctx->enc_s_desc;
+
+	if(saesoc_new_session(&ctx->initp,&s_desc,nsdescs, NULL) < 0)
+		 printk("%s,%d Error \n", __FUNCTION__, __LINE__); 
+
+	initp->cipher.flags = 0;
+	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC; 
+
+	s_desc = &ctx->dec_s_desc;
+
+	if(saesoc_new_session(&ctx->initp,&s_desc,nsdescs, NULL) < 0)
+		 printk("%s,%d Error \n", __FUNCTION__, __LINE__); 
 
         return ret;
 
@@ -477,11 +499,15 @@ static int aead_gcm_rfc4106_setkey( struct crypto_aead *tfm, const u8 *key,
 						unsigned int keylen)
 {
 	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
+	struct saesoc_session_init_params *initp = &ctx->initp;
 	int cipher_alg;
 	unsigned int cipher_keylen=0;
 	int auth_alg;
-	int ret;
-	struct nlm_crypto_pkt_ctrl *ctrl = &ctx->ctrl;
+	int ret = 0;
+	struct saesoc_session_desc *s_desc = &ctx->enc_s_desc;
+	int assoc_len = 8;
+	int nsdescs ;
+
 	if (keylen < GCM_RFC4106_NONCE_SIZE)
                 return -EINVAL;
 	cipher_keylen = keylen - GCM_RFC4106_NONCE_SIZE;
@@ -501,13 +527,49 @@ static int aead_gcm_rfc4106_setkey( struct crypto_aead *tfm, const u8 *key,
 		printk("ERR: Bad aes key len\n");
 		return -EINVAL;
 	}
-	
-	ret = nlm_crypto_fill_pkt_ctrl(ctrl,0,auth_alg,NLM_HASH_MODE_GCM,cipher_alg,
-		NLM_CIPHER_MODE_GCM,0,(u8*)key,cipher_keylen,(u8*)key,cipher_keylen,1);
-	ctx->iv_len = cipher_mode_iv_len[cipher_alg][NLM_HASH_MODE_GCM];
-#ifdef	NLM_CRYPTO_DEBUG
-	print_buf("KEY\n",key,cipher_keylen);	
-#endif
+	ctx->iv_len = 8;
+	/*iv | assoc| payload 
+             |------> auth offset
+                    |---->cipher_off */
+	initp->cipher.type = cipher_alg;
+        initp->cipher.mode = SAESOC_CIPHER_MODE_GCM;	
+	initp->cipher.iv_offset = 0;
+	initp->cipher.iv_mode = 0;
+	initp->cipher.key = (char *)key;
+	initp->cipher.key_len = keylen;
+	initp->cipher.cfb_mask = 0;
+	initp->cipher.flags = SAESOC_CF_ENCRYPT;
+	initp->hash.type = auth_alg;
+	initp->hash.mode = SAESOC_HASH_MODE_GCM;
+	initp->hash.iv_offset = 0;
+	initp->hash.key = (char *)key;
+	initp->hash.key_len = keylen;
+	initp->hash.mute_mask_sel = 0;
+	initp->hash.tag_len = 128;
+	initp->hash.tagin_offset = 0;
+	initp->hash.aad_offset = 16; /* auth offset */
+	/* req->assoclen */
+	initp->hash.addl_hash_len = 0;
+	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC;
+	initp->payload_offset = 16 + assoc_len;
+	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
+
+	nsdescs = saesoc_calc_sdesc_cnt(&ctx->initp,NULL);
+	s_desc = &ctx->enc_s_desc;
+
+
+
+	if(saesoc_new_session(&ctx->initp,&s_desc,nsdescs, NULL) < 0)
+		 printk("%s,%d Error \n", __FUNCTION__, __LINE__); 
+
+	initp->cipher.flags = 0;
+	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC | SAESOC_HF_HASHINP_IS_CIPHEROUT;
+
+	s_desc = &ctx->dec_s_desc;
+
+	if(saesoc_new_session(&ctx->initp,&s_desc,nsdescs, NULL) < 0)
+		 printk("%s,%d Error \n", __FUNCTION__, __LINE__); 
+
 	
 	/*copy by nonce*/
 	memcpy(ctx->iv_buf, key + cipher_keylen, GCM_RFC4106_NONCE_SIZE);
@@ -516,17 +578,17 @@ static int aead_gcm_rfc4106_setkey( struct crypto_aead *tfm, const u8 *key,
 	return ret ;
 
 }
-
 static int aead_ccm_rfc4309_setkey(struct crypto_aead *tfm, const u8 *key, 
 				   unsigned int keylen)
 {
 	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
+	struct saesoc_session_init_params *initp = &ctx->initp;
 	unsigned int cipher_keylen=0;
-	int ret;
 	int nonce_len = CCM_RFC4309_NONCE_SIZE;
 	int cipher_alg;
 	int auth_alg;
-	struct nlm_crypto_pkt_ctrl *ctrl = &ctx->ctrl;
+	struct saesoc_session_desc *s_desc = &ctx->enc_s_desc;
+	int nsdescs ;
 	if (keylen < CCM_RFC4309_NONCE_SIZE)
                 return -EINVAL;
 
@@ -538,7 +600,6 @@ static int aead_ccm_rfc4309_setkey(struct crypto_aead *tfm, const u8 *key,
 	cipher_alg = get_cipher_aes_algid(cipher_keylen);
 	if (cipher_alg < 0) {
 		crypto_aead_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
-		//sandip: check return val
 		printk("ERR: Bad aes key len\n");
 		return -EINVAL;
 	}
@@ -551,109 +612,236 @@ static int aead_ccm_rfc4309_setkey(struct crypto_aead *tfm, const u8 *key,
 	
 
 	
-	ret = nlm_crypto_fill_pkt_ctrl(ctrl,0,auth_alg,NLM_HASH_MODE_CCM,cipher_alg,NLM_CIPHER_MODE_CCM,0,(u8*)key,cipher_keylen,(u8*)key,cipher_keylen,1);
-	ctx->iv_len = cipher_mode_iv_len[cipher_alg][NLM_HASH_MODE_GCM];
-#ifdef	NLM_CRYPTO_DEBUG
-	print_buf("KEY\n",key,cipher_keylen);	
-#endif
-	
+	ctx->iv_len = 8;
+
+	/* | en_iv| auth_iv |[2byte for assoc len storage] | assoc [blcok aligned with zero | 
+	   | ---iv offset
+                  |----auth offset
+		                                                                             |----cipher offset
+		  */
+	initp->cipher.type = cipher_alg;
+        initp->cipher.mode = SAESOC_CIPHER_MODE_CCM;	
+	initp->cipher.iv_offset = 0;
+	initp->cipher.iv_mode = 0;
+	initp->cipher.key = (char *)key;
+	initp->cipher.key_len = cipher_keylen;
+	initp->cipher.cfb_mask = 0;
+	initp->cipher.flags = SAESOC_CF_ENCRYPT;
+	initp->hash.type = auth_alg;
+	initp->hash.mode = SAESOC_HASH_MODE_CCM;
+	initp->hash.iv_offset = 0;
+	initp->hash.key = (char *)key;
+	initp->hash.key_len = cipher_keylen;
+	initp->hash.mute_mask_sel = 0;
+	initp->hash.tag_len = 128;
+	initp->hash.tagin_offset = 0;
+	initp->hash.aad_offset = 16; /* auth offset */
+	initp->hash.addl_hash_len = 16; 
+	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC;
+	initp->payload_offset = 16 + 16 + 16; /* env IV, auth IV, 2 extra for assoc len storage + assoc + zero*/
+	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
+
+	nsdescs = saesoc_calc_sdesc_cnt(&ctx->initp,NULL);
+	s_desc = &ctx->enc_s_desc;
+
+	if(saesoc_new_session(&ctx->initp,&s_desc,nsdescs, NULL) < 0)
+		 printk("%s,%d Error \n", __FUNCTION__, __LINE__); 
+
+	initp->cipher.flags = 0;
+	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC | SAESOC_HF_HASHINP_IS_CIPHEROUT;
+
+	s_desc = &ctx->dec_s_desc;
+
+	if(saesoc_new_session(&ctx->initp,&s_desc,nsdescs, NULL) < 0)
+		 printk("%s,%d Error \n", __FUNCTION__, __LINE__); 
 	/*copy by nonce*/
 	memcpy(ctx->iv_buf, key + cipher_keylen, nonce_len);
 	crypto_aead_setkey(ctx->fallback, key, keylen);
-	return ret;
+	return 0;
 }
 
+
+static int xlp_aes_ctr_setkey( struct crypto_aead *tfm, u8 *key,
+					unsigned int keylen, int hash_type, int hash_mode, uint16_t h_stat, int expected_keylen)
+{
+	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
+	struct saesoc_session_init_params *initp = &ctx->initp;
+	unsigned int cipher_keylen=0, auth_keylen=0;
+	int ret;
+	int nonce_len = CTR_RFC3686_NONCE_SIZE;
+	int cipher_alg;
+	uint8_t auth_key[128];
+	uint8_t *cipher_key;
+	struct rtattr *rta = (struct rtattr *)key;
+	int nsdescs ;
+	struct saesoc_session_desc *s_desc ;
+
+	if ((ret = get_cipher_auth_keylen(key, keylen, &cipher_keylen,
+					  &auth_keylen)) < 0) {
+		crypto_aead_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
+		printk("ERR: Bad key len\n");
+		return ret;
+	}
+
+	cipher_keylen -= nonce_len;
+
+	cipher_alg = get_cipher_aes_algid(cipher_keylen);
+	if (cipher_alg < 0) {
+		crypto_aead_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
+		//sandip: check return val
+		printk("ERR: Bad aes key len\n");
+		return -EINVAL;
+	}
+	ctx->stat = cipher_alg - 1 + 3;
+	ctx->stat = ctx->stat | (h_stat << 8);
+	key += RTA_ALIGN(rta->rta_len);
+	memcpy(auth_key, key, auth_keylen);
+	cipher_key = key + auth_keylen;
+	memcpy(ctx->iv_buf,key+auth_keylen+cipher_keylen, nonce_len);
+
+	if ( expected_keylen > auth_keylen)
+		memset(auth_key + auth_keylen, 0,  expected_keylen - auth_keylen);
+	ctx->iv_len = 8;
+
+	auth_keylen = expected_keylen;
+
+	/* iv | assoc | iv[nonce ... 12][means 8]| payload 
+	   |----->iv offset
+	      |----auth offset
+	                                         |--> cipher offset */ 
+
+	initp->cipher.type = cipher_alg;
+        initp->cipher.mode = SAESOC_CIPHER_MODE_CTR;	
+	initp->cipher.iv_offset = 0;
+	initp->cipher.iv_mode = 0;
+	initp->cipher.key = (char *)cipher_key;
+	initp->cipher.key_len = cipher_keylen;
+	initp->cipher.cfb_mask = 0;
+	initp->cipher.flags = SAESOC_CF_ENCRYPT;
+	initp->hash.type = hash_type;
+	initp->hash.mode = hash_mode;
+	initp->hash.iv_offset = 0;
+	initp->hash.key = auth_key;
+	initp->hash.key_len = auth_keylen;
+	initp->hash.mute_mask_sel = 0;
+	initp->hash.tag_len = saesoc_gen1_tag_len[hash_type];
+	initp->hash.tagin_offset = 0;
+	initp->hash.aad_offset = CTR_RFC3686_BLOCK_SIZE;
+	initp->hash.addl_hash_len =  CTR_RFC3686_IV_SIZE; /* iv len */ 
+	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC | SAESOC_HF_HASHINP_IS_CIPHEROUT;
+	initp->payload_offset = CTR_RFC3686_BLOCK_SIZE + 8 + CTR_RFC3686_IV_SIZE;  
+	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
+
+	nsdescs = saesoc_calc_sdesc_cnt(&ctx->initp,NULL);
+	s_desc = &ctx->enc_s_desc;
+
+	if(saesoc_new_session(&ctx->initp,&s_desc,nsdescs, NULL) < 0)
+		 printk("%s,%d Error \n", __FUNCTION__, __LINE__); 
+
+	initp->cipher.flags = 0;
+	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC;
+
+	s_desc = &ctx->dec_s_desc;
+
+	if(saesoc_new_session(&ctx->initp,&s_desc,nsdescs, NULL) < 0)
+		 printk("%s,%d Error \n", __FUNCTION__, __LINE__); 
+
+
+
+	return ret;
+}
 static int xlp_aes_cbc_hmac_sha256_setkey( struct crypto_aead *tfm, const u8 *key, unsigned int keylen)
 {
-	return xlp_aes_cbc_setkey(tfm, (uint8_t *)key, keylen,NLM_HASH_SHA,NLM_HASH_MODE_SHA256,H_SHA256_STAT);
+	return xlp_aes_cbc_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_SHA_256,0,H_SHA256_STAT,64);
 
 }
 
 static int xlp_aes_cbc_hmac_sha1_setkey(struct crypto_aead *tfm, const u8 *key, unsigned int keylen)
 {
-	return xlp_aes_cbc_setkey(tfm, (uint8_t *)key, keylen,NLM_HASH_SHA,NLM_HASH_MODE_SHA1,H_SHA1_STAT);
+	return xlp_aes_cbc_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_SHA_1,0,H_SHA1_STAT,64);
 }
 
 static int xlp_aes_cbc_aes_xcbc_mac_setkey(struct crypto_aead *tfm, const u8 *key, unsigned int keylen)
 {
-	return xlp_aes_cbc_setkey(tfm, (uint8_t *)key, keylen,NLM_HASH_AES128,NLM_HASH_MODE_XCBC,AES128_XCBC_STAT);
+	return xlp_aes_cbc_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_AES_128,SAESOC_HASH_MODE_XCBC,AES128_XCBC_STAT,16);
 }
 
 static int xlp_aes_cbc_hmac_md5_setkey(struct crypto_aead *tfm, const u8 *key, unsigned int keylen)
 {
-	return xlp_aes_cbc_setkey(tfm, (uint8_t *)key, keylen,NLM_HASH_MD5,0,MD5_STAT);
+	return xlp_aes_cbc_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_MD5,0,MD5_STAT,64);
 }
 
-static int xlp_3des_cbc_hmac_md5_setkey(struct crypto_aead *tfm, const u8 *key,
-                                        unsigned int keylen)
-{
-	return xlp_3des_setkey(tfm,(uint8_t *)key,keylen,NLM_HASH_MD5,0,MD5_STAT);
-
-}
 static int xlp_3des_cbc_hmac_sha256_setkey(struct crypto_aead *tfm, const u8 *key,
                                         unsigned int keylen)
 {
-	return xlp_3des_setkey(tfm,(uint8_t *)key,keylen,NLM_HASH_SHA,NLM_HASH_MODE_SHA256,H_SHA256_STAT);
+	return xlp_3des_setkey(tfm,(uint8_t *)key,keylen,SAESOC_HASH_TYPE_SHA_256,0,H_SHA256_STAT,64);
         
 }
 static int xlp_3des_cbc_hmac_sha1_setkey(struct crypto_aead *tfm, const u8 *key,
                                         unsigned int keylen)
 {
-	return xlp_3des_setkey(tfm,(uint8_t *)key,keylen,NLM_HASH_SHA,NLM_HASH_MODE_SHA1,H_SHA1_STAT);
+	return xlp_3des_setkey(tfm,(uint8_t *)key,keylen,SAESOC_HASH_TYPE_SHA_1,0,H_SHA1_STAT,64);
 }
 static int xlp_3des_cbc_aes_xcbc_mac_setkey(struct crypto_aead *tfm, const u8 *key,
                                         unsigned int keylen)
 {
-	return xlp_3des_setkey(tfm,(uint8_t *)key,keylen,NLM_HASH_AES128,NLM_HASH_MODE_XCBC,AES128_XCBC_STAT);
+	return xlp_3des_setkey(tfm,(uint8_t *)key,keylen,SAESOC_HASH_TYPE_AES_128,SAESOC_HASH_MODE_XCBC,AES128_XCBC_STAT,16);
 }
-static int xlp_des_cbc_aes_xcbc_mac_setkey( struct crypto_aead *tfm, const u8 *key,
-					unsigned int keylen)
+
+static int xlp_3des_cbc_hmac_md5_setkey(struct crypto_aead *tfm, const u8 *key,
+                                        unsigned int keylen)
 {
-	return xlp_des_setkey(tfm,(uint8_t *)key,keylen,NLM_HASH_AES128,NLM_HASH_MODE_XCBC,AES128_XCBC_STAT);
+	return xlp_3des_setkey(tfm,(uint8_t *)key,keylen,SAESOC_HASH_TYPE_MD5,0,MD5_STAT,64);
+
 }
 static int xlp_des_cbc_hmac_sha1_setkey(struct crypto_aead *tfm, const u8 *key,
 						 unsigned int keylen)
 {
-	return xlp_des_setkey(tfm,(uint8_t *)key,keylen, NLM_HASH_SHA,NLM_HASH_MODE_SHA1,H_SHA1_STAT);
+	return xlp_des_setkey(tfm,(uint8_t *)key,keylen, SAESOC_HASH_TYPE_SHA_1,0,H_SHA1_STAT,64);
 
 }
 static int xlp_des_cbc_hmac_sha256_setkey(struct crypto_aead *tfm, const u8 *key,
 							unsigned int keylen)
 {
-	return xlp_des_setkey(tfm,(uint8_t *)key,keylen, NLM_HASH_SHA,NLM_HASH_MODE_SHA256,H_SHA256_STAT);
+	return xlp_des_setkey(tfm,(uint8_t *)key,keylen, SAESOC_HASH_TYPE_SHA_256,0,H_SHA256_STAT,64);
 
 }
+static int xlp_des_cbc_aes_xcbc_mac_setkey( struct crypto_aead *tfm, const u8 *key,
+					unsigned int keylen)
+{
+	return xlp_des_setkey(tfm,(uint8_t *)key,keylen,SAESOC_HASH_TYPE_AES_128,SAESOC_HASH_MODE_XCBC,AES128_XCBC_STAT,16);
+}
 static int xlp_des_cbc_hmac_md5_setkey( struct crypto_aead *tfm, const u8 *key,
 						unsigned int keylen)
 {
-	return xlp_des_setkey(tfm,(uint8_t *)key,keylen,NLM_HASH_MD5,0,MD5_STAT);
+	return xlp_des_setkey(tfm,(uint8_t *)key,keylen,SAESOC_HASH_TYPE_MD5,0,MD5_STAT,64);
 
 }
-
 static  int xlp_aes_ctr_hmac_sha256_setkey ( struct crypto_aead *tfm, const u8 *key,
 					unsigned int keylen)
 {
-	return xlp_aes_ctr_setkey(tfm, (uint8_t *)key, keylen,NLM_HASH_SHA,NLM_HASH_MODE_SHA256,H_SHA256_STAT);
+	return xlp_aes_ctr_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_SHA_256,0,H_SHA256_STAT,64);
 }
 static  int xlp_aes_ctr_hmac_sha1_setkey ( struct crypto_aead *tfm, const u8 *key,
 					unsigned int keylen)
 {
-	return xlp_aes_ctr_setkey(tfm, (uint8_t *)key, keylen,NLM_HASH_SHA,NLM_HASH_MODE_SHA1,H_SHA1_STAT);
+	return xlp_aes_ctr_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_SHA_1,0,H_SHA1_STAT,64);
 
 }
 static  int xlp_aes_ctr_aes_xcbc_mac_setkey ( struct crypto_aead *tfm, const u8 *key,
 					unsigned int keylen)
 {
-	return xlp_aes_ctr_setkey(tfm, (uint8_t *)key, keylen,NLM_HASH_AES128,NLM_HASH_MODE_XCBC,AES128_XCBC_STAT);
+	return xlp_aes_ctr_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_AES_128,SAESOC_HASH_MODE_XCBC,AES128_XCBC_STAT,16);
 }
 
 static int xlp_aes_ctr_hmac_md5_setkey(struct crypto_aead *tfm, const u8 *key,
 					unsigned int keylen)
 {
-	return xlp_aes_ctr_setkey(tfm, (uint8_t *)key, keylen,NLM_HASH_MD5,0,MD5_STAT);
+	return xlp_aes_ctr_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_MD5,0,MD5_STAT,64);
 }
+
 //returns nr_aad_frags... -1 for error
-unsigned int fill_aead_aad(struct nlm_crypto_pkt_param *param, struct aead_request *req, unsigned int aad_len,int seg,int max_frags)
+unsigned int fill_aead_aad(struct saesoc_data_desc   *d_desc, struct aead_request *req, unsigned int aad_len,int seg,int max_frags)
 {
 	struct scatterlist *sg;
 	struct scatter_walk walk;
@@ -667,11 +855,8 @@ unsigned int fill_aead_aad(struct nlm_crypto_pkt_param *param, struct aead_reque
 		scatterwalk_start(&walk, sg);
 		//virt = scatterwalk_map(&walk, 1);
 		virt = page_address(scatterwalk_page(&walk)) + offset_in_page(walk.offset);
-		rv = nlm_crypto_fill_src_dst_seg(param, seg, max_frags, virt, len);
-		if ( rv <= seg ) 
-			return nlm_crypto_calc_rem_len(sg,aad_len) + max_frags;
-		else 
-			seg = rv;
+		if ( len > 0)
+		rv = saesoc_add_frags(d_desc,virt,len,virt,len);
 		aad_len -= len;
 	}
 	return seg;
@@ -686,9 +871,6 @@ static void aead_request_callback(struct nlm_async_crypto *async, uint64_t msg1)
 {
 	struct crypto_async_request *base = (struct crypto_async_request *)async->args;
 	int err = 0;
-	int cpu = hard_smp_processor_id();
-	int enc = async->stat & 0xff;
-	int auth = (async->stat >> 8 ) & 0xff;
 
 	if (msg1 & 0x7ff80) {
 		printk("\n Error: entry1 is %llx",msg1);
@@ -705,50 +887,130 @@ static void aead_request_callback(struct nlm_async_crypto *async, uint64_t msg1)
 			err = -EBADMSG;
 		}
 	}
+#if 0
+	int cpu = hard_smp_processor_id();
+	int enc = async->stat & 0xff;
+	int auth = (async->stat >> 8 ) & 0xff;
 	crypto_stat[cpu].enc[enc]++;
 	crypto_stat[cpu].auth[auth]++;	
 	crypto_stat[cpu].enc_tbytes[enc] += async->bytes;
 	crypto_stat[cpu].auth_tbytes[auth] += async->bytes;
+#endif
 	if ( async->pkt_param)
 		kfree(async->pkt_param);
 	base->complete(base, err);
 	return;
 }
 
-static int aead_crypt_gcm(struct aead_request *req, unsigned int op)
+static int aead_crypt(struct aead_request *req, unsigned int op)
 {
+	struct saesoc_data_desc    *d_desc = NLM_CRYPTO_DATA_DESC(aead_request_ctx(req));
 	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
 	struct crypto_alg *alg = tfm->base.__crt_alg;
 	struct aead_alg *aead= &alg->cra_aead;
 	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
-	struct nlm_crypto_pkt_param *param;
-	unsigned int cipher_off, auth_off, iv_off;
-	unsigned int auth_len, cipher_len;
-	int seg = 0,iv_size =16;
-	unsigned int hash_source;
-	uint64_t entry0, entry1, tx_id=0x12345678;
+	unsigned int cipher_len;
+	struct saesoc_session_desc *s_desc ;
+	int ivsize;
 	struct nlm_async_crypto *async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET(aead_request_ctx(req));
 	uint8_t *hash_addr;
 	int fb_vc; 
-	int err=0;
 	unsigned int authsize,maxauthsize;
-	struct nlm_crypto_pkt_ctrl *ctrl = &ctx->ctrl;
-	char * iv = (uint8_t *)NLM_IV_OFFSET(aead_request_ctx(req)); 
-	uint8_t *tmp_iv = iv;
-#ifdef CONFIG_32BIT
 	unsigned long msgrng_flags;
-#endif
 	unsigned int max_frags  = MAX_FRAGS;
 	int node_sae_base;
 	int node;
+	struct saesoc_extra_req_send_params mparam;
+
+	ivsize = crypto_aead_ivsize(crypto_aead_reqtfm(req));
 
 	authsize = crypto_aead_authsize(tfm);
 	maxauthsize= aead->maxauthsize;
 	async->pkt_param = NULL;
 	async->src = req->src;
 	async->dst = req->dst;
+	if ( op )
+		s_desc = &ctx->enc_s_desc; 
+	else
+		s_desc = &ctx->dec_s_desc;
+	saesoc_new_data_desc(s_desc, &d_desc, MAX_FRAGS , NULL);
+
+	hash_addr = (uint8_t *)NLM_HASH_OFFSET(aead_request_ctx(req));
+
+	//check if it should be aip->tag_len or can be taken from tfm
+	cipher_len = op ? req->cryptlen:req->cryptlen - authsize;
+	saesoc_set_aad_len(d_desc,req->assoclen);
+	fill_aead_aad(d_desc, req, req->assoclen,0,max_frags);
+	if (ivsize) 
+		saesoc_add_frags(d_desc,req->iv,ivsize,req->iv,ivsize);
+	d_desc = fill_src_dst_sg(s_desc,d_desc,async,req->src,req->dst,&max_frags,cipher_len);
+
+	saesoc_set_payload_len(d_desc,cipher_len);
+	saesoc_set_tag_dstaddr(d_desc,hash_addr);
+	preempt_disable();
+
+	async->callback =  aead_request_callback;
+	async->args = (void *)&req->base; 
+	async->op  = op;
+	async->hash_addr = hash_addr;
+	async->authsize = authsize;
+	async->stat = ctx->stat; 
+	async->bytes = req->cryptlen; 
+	mparam.async_rsp_arg = (uint64_t)async;
+	mparam.arc4_load_state = 0;
+
+	//construct pkt, send to engine and receive reply
+	msgrng_access_enable(msgrng_flags);
+	fb_vc = crypto_get_fb_vc(&node);
+	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
+
+	if (saesoc_process_request(NULL,d_desc,node_sae_base,fb_vc,0,1,&mparam,NULL) != 0 ) {
+		msgrng_access_disable(msgrng_flags);
+		preempt_enable();
+		return -EAGAIN;
+	}
+
+	msgrng_access_disable(msgrng_flags);
+	preempt_enable();
+
+	return -EINPROGRESS;
+
+
+}
+static int aead_crypt_gcm(struct aead_request *req, unsigned int op)
+{
+	struct saesoc_data_desc    *d_desc = NLM_CRYPTO_DATA_DESC(aead_request_ctx(req));
+	struct nlm_async_crypto *async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET(aead_request_ctx(req));
+	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
+	unsigned long msgrng_flags;
+	unsigned int max_frags  = MAX_FRAGS;
+	int node_sae_base;
+	int node;
+	int fb_vc; 
+	struct saesoc_extra_req_send_params mparam;
+	unsigned int authsize,maxauthsize;
+	char * hash_addr = (uint8_t *)NLM_HASH_OFFSET(aead_request_ctx(req));
+	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
+	char * iv = (uint8_t *)NLM_IV_OFFSET(aead_request_ctx(req)); 
+	uint8_t *tmp_iv = iv;
+	unsigned int cipher_len;
+	struct crypto_alg *alg = tfm->base.__crt_alg;
+	struct aead_alg *aead= &alg->cra_aead;
+	struct saesoc_session_desc *s_desc ;
+	authsize = crypto_aead_authsize(tfm);
+	maxauthsize= aead->maxauthsize;
+	async->pkt_param = NULL; 
+	async->src = req->src;
+	async->dst = req->dst; 
+	if ( op )
+		s_desc = &ctx->enc_s_desc;
+	else
+		s_desc = &ctx->dec_s_desc;
+	saesoc_new_data_desc(s_desc, &d_desc, MAX_FRAGS , NULL);
 
-	if ( (op &&  (req->cryptlen == 0 )) || (!op && req->cryptlen <= aead->maxauthsize))
+
+	if ( (op &&  (req->cryptlen == 0 )) || (!op && req->cryptlen <= aead->maxauthsize) ||
+			(req->assoclen != 8))
 	{
 		int ret =0;
 		ret = crypto_aead_setauthsize(ctx->fallback, authsize);
@@ -762,8 +1024,6 @@ static int aead_crypt_gcm(struct aead_request *req, unsigned int op)
 		return ret;
 	}
 	
-	
-
 	/*Copy nonce*/
 	memcpy(tmp_iv,  ctx->iv_buf, GCM_RFC4106_NONCE_SIZE);
 	tmp_iv += GCM_RFC4106_NONCE_SIZE;
@@ -775,56 +1035,18 @@ static int aead_crypt_gcm(struct aead_request *req, unsigned int op)
 	/*Set counter*/
 	*((uint32_t*)tmp_iv) = cpu_to_be32((uint32_t)1);
 
-	param = (struct nlm_crypto_pkt_param *)NLM_CRYPTO_PKT_PARAM_OFFSET(aead_request_ctx(req));
-	hash_addr = (uint8_t *)NLM_HASH_OFFSET(aead_request_ctx(req));
-
-	iv_off = 0;
-	auth_off = iv_size;
-	cipher_off = req->assoclen + iv_size;
+	saesoc_add_frags(d_desc,iv,16,iv,16);
 
-	//check if it should be aip->tag_len or can be taken from tfm
 	cipher_len = op ? req->cryptlen: req->cryptlen - authsize;
-	auth_len = req->assoclen + cipher_len; 
-	hash_source = (op) ? 0 : 1;
-
-	/*Setup NONCE_IV_CTR COMBO*/
-	seg = nlm_crypto_fill_src_dst_seg(param, seg, max_frags, iv, iv_size);
-
-	do { 
-	
-	/*Setup AAD - SPI/SEQ Number*/
-	seg = fill_aead_aad(param, req, req->assoclen,seg,max_frags);
-	seg = fill_src_dst_sg(req->src,req->dst, cipher_len, param, seg, max_frags,op);
-
-	if ( seg > max_frags) {
-		max_frags = seg;
-		seg = alloc_pkt_param(async,&param,max_frags);
-		if ( seg == -1 )
-			return -1;
-		seg =1 ;
-	}
-	}while(seg == 1);  
 
-	nlm_crypto_fill_cipher_auth_pkt_param(ctrl, param, op, hash_source, iv_off, 
-		iv_size, auth_off, auth_len, 0, cipher_off, cipher_len, hash_addr);
+	saesoc_set_aad_len(d_desc,req->assoclen);
 	
-	fb_vc = crypto_get_fb_vc(&node);
-
-	entry0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, ctrl->cipherkeylen, virt_to_phys(ctrl));
-	entry1 = nlm_crypto_form_pkt_fmn_entry1(0, ctrl->hashkeylen, (seg + 2)<<4, virt_to_phys(param));
-
-
-#ifdef NLM_CRYPTO_DEBUG
-	printk("*****ctrl descriptor phys addr %#lx\n",virt_to_phys(ctrl));
-	print_crypto_msg_desc(entry0, entry1, tx_id);
-	print_cntl_instr(ctrl->desc0);
-	print_buf("ENC_KEY:", (uint8_t *)ctrl->key, ctrl->cipherkeylen);
-	print_buf("AUTH_KEY:", (uint8_t *)ctrl->key + ctrl->cipherkeylen, ctrl->hashkeylen);
-	print_pkt_desc(param,seg);
-	printk("iv_off: %d, cipher_off: %d, auth_off: %d\n",iv_off, cipher_off, auth_off);
-	printk("auth_len: %d, cipher_len: %d\n", auth_len, cipher_len);
-#endif
+	fill_aead_aad(d_desc, req, req->assoclen,0,max_frags);
+	d_desc = fill_src_dst_sg(s_desc,d_desc,async,req->src,req->dst,&max_frags,cipher_len);
+	saesoc_set_payload_len(d_desc,cipher_len);
+	saesoc_set_tag_dstaddr(d_desc,hash_addr);
 
+	preempt_disable();
 	async->callback =  aead_request_callback;
 	async->args = (void *)&req->base; 
 	async->op  = op;
@@ -832,58 +1054,53 @@ static int aead_crypt_gcm(struct aead_request *req, unsigned int op)
 	async->authsize = authsize;
 	async->stat = ctx->stat; 
 	async->bytes = req->cryptlen; 
-	tx_id = (uint64_t)(unsigned long)async;
+	mparam.async_rsp_arg = (uint64_t)async;
+	mparam.arc4_load_state = 0;
 
 	//construct pkt, send to engine and receive reply
-#ifdef CONFIG_32BIT
 	msgrng_access_enable(msgrng_flags);
-#endif
+	fb_vc = crypto_get_fb_vc(&node);
 	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
-	err = nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id);
-#ifdef CONFIG_32BIT
-	msgrng_access_disable(msgrng_flags);
-#endif
-	if(err){
+
+	if (saesoc_process_request(NULL,d_desc,node_sae_base,fb_vc,0,1,&mparam,NULL) != 0 ) {
+		msgrng_access_disable(msgrng_flags);
+		preempt_enable();
 		return -EAGAIN;
 	}
-
+	msgrng_access_disable(msgrng_flags);
+	preempt_enable();
 
 	return -EINPROGRESS;
 
 }
 
+
 static int aead_crypt_ccm(struct aead_request *req, unsigned int op)
 {
+	struct saesoc_data_desc    *d_desc = NLM_CRYPTO_DATA_DESC(aead_request_ctx(req));
+	struct nlm_async_crypto *async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET(aead_request_ctx(req));
 	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
 	struct crypto_alg *alg = tfm->base.__crt_alg;
 	struct aead_alg *aead= &alg->cra_aead;
 	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
-	struct nlm_crypto_pkt_param *param;
-	unsigned int cipher_off, auth_off, iv_off;
+	unsigned int cipher_off, auth_off;
 	unsigned int auth_len, cipher_len;
-	unsigned int hash_source;
-	uint64_t entry0, entry1, tx_id=0x12345678;
-	struct nlm_async_crypto *async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET(aead_request_ctx(req));
 	uint8_t *hash_addr;
 	int fb_vc; 
-	int err=0;
 	unsigned int authsize,maxauthsize;
-	struct nlm_crypto_pkt_ctrl *ctrl = &ctx->ctrl;
 	char * iv = (uint8_t *)NLM_IV_OFFSET(aead_request_ctx(req));
 	int iv_size = 16;
 	uint8_t *auth_iv = (uint8_t *)iv + iv_size;
 	unsigned int auth_iv_frag_len = iv_size; 
 	unsigned int extralen = 0, cipher_extralen =0;
-	int seg = 0;
 	uint8_t *tmp_iv = &iv[1];
-#ifdef CONFIG_32BIT
 	unsigned long msgrng_flags;
-#endif
 	unsigned int max_frags  = MAX_FRAGS;
 	int node_sae_base;
 	int node;
+	struct saesoc_extra_req_send_params mparam;
+	struct saesoc_session_desc *s_desc ;
 
-	param = (struct nlm_crypto_pkt_param *)NLM_CRYPTO_PKT_PARAM_OFFSET(aead_request_ctx(req));
 	hash_addr = (uint8_t *)NLM_HASH_OFFSET(aead_request_ctx(req));
 
 	authsize = crypto_aead_authsize(tfm);
@@ -892,7 +1109,14 @@ static int aead_crypt_ccm(struct aead_request *req, unsigned int op)
 	async->src = req->src;
 	async->dst = req->dst;
 
-	if ( (op &&  (req->cryptlen == 0 )) || (!op && req->cryptlen <= aead->maxauthsize))
+	if ( op )
+		s_desc = &ctx->enc_s_desc;
+	else
+		s_desc = &ctx->dec_s_desc;
+
+	saesoc_new_data_desc(s_desc, &d_desc, MAX_FRAGS , NULL);
+
+	if ( (op &&  (req->cryptlen == 0 )) || (!op && req->cryptlen <= aead->maxauthsize) || (req->assoclen != 8))
 	{
 		int ret =0;
 		ret = crypto_aead_setauthsize(ctx->fallback, authsize);
@@ -927,10 +1151,7 @@ static int aead_crypt_ccm(struct aead_request *req, unsigned int op)
 
 	iv[0] = 3;
 
-	iv_off = 0;
-	auth_off = iv_size;
 	cipher_len = op ? req->cryptlen: req->cryptlen - authsize;
-	hash_source = (op) ? 0 : 1;
 
 
 	/*Setup ENCRYPTION IV*/
@@ -941,107 +1162,50 @@ static int aead_crypt_ccm(struct aead_request *req, unsigned int op)
 		2 ... 0      L' */
 
 	auth_iv[0] = ((req->assoclen?1 : 0 ) << 6 )| ((authsize - 2 )/2) << 3 | 3;
-
-	auth_iv_frag_len = iv_size; 
-	extralen = req->assoclen;
-	if ( req->assoclen ) {
-
-
-		if ( req->assoclen  < 65280) { 
-			*(short*)(auth_iv + 16) = cpu_to_be16((short)req->assoclen);
-			extralen += 2;
-			auth_iv_frag_len = 18;
-		}
-		else
-		{
-			*(short*)(auth_iv+ 16) = cpu_to_be16((short)0xfffe);
-			*(short*)(auth_iv + 16) = cpu_to_be16((short)0xfffe);
-			*(uint32_t*)(auth_iv + 18) = cpu_to_be32((uint32_t)req->assoclen);
-			*(uint32_t*)(auth_iv + 18) = cpu_to_be32((uint32_t)req->assoclen);
-			auth_iv_frag_len = 22;
-			extralen += 6;
-		}
-	}
 	/*Setup AUTH IV*/
 	*(uint32_t*)&auth_iv[12] |= cpu_to_be32((uint32_t )cipher_len);
-
-
-	//one for cipher iv one for auth iv
-	cipher_off = iv_size + iv_size + extralen;  
+	*(short*)(auth_iv + 16) = cpu_to_be16((short)req->assoclen);
 
 	if ( req->assoclen ) {
-		/* AAD has to be block aligned */
+		extralen = req->assoclen;
+		extralen += 2;
 		extralen = extralen % 16;
+		auth_iv_frag_len = 18;
 		if ( extralen ) {
 			extralen = AES_BLOCK_SIZE - extralen;
-			memset(auth_iv + 22,0,extralen);
-			cipher_off += extralen;
+			memset(auth_iv + auth_iv_frag_len,0,extralen);
 		}
 	}
 
-	cipher_extralen = cipher_len % 16;
+	saesoc_add_frags(d_desc,iv,16,iv,16);
+	saesoc_add_frags(d_desc,auth_iv,auth_iv_frag_len,auth_iv,auth_iv_frag_len);
 
-	if ( cipher_extralen ) {
-		cipher_extralen = AES_BLOCK_SIZE - cipher_extralen;
-		memset(auth_iv + 38,0,cipher_extralen);
-	}
-	auth_len = cipher_off + cipher_len + cipher_extralen - auth_off; 
+	fill_aead_aad(d_desc, req, req->assoclen,0,max_frags);
 
-	seg = nlm_crypto_fill_src_dst_seg(param, seg, max_frags, iv, iv_size);
 
-	do {
-	auth_iv = (uint8_t *)iv + iv_size;
-	seg = nlm_crypto_fill_src_dst_seg(param, seg,max_frags, auth_iv,auth_iv_frag_len);
-	if ( req->assoclen ) {
-		/*Setup AAD - SPI/SEQ Number*/
-		seg = fill_aead_aad(param, req, req->assoclen,seg,max_frags);
-		if ( extralen ) 
-			seg = nlm_crypto_fill_src_dst_seg(param,seg,max_frags, (auth_iv+22),extralen);
-		
-	}
-	seg = fill_src_dst_sg(req->src,req->dst, cipher_len, param,seg, max_frags,op);
+	saesoc_add_frags(d_desc,auth_iv+ auth_iv_frag_len, extralen, auth_iv + auth_iv_frag_len, extralen);
+
 
+	auth_len = cipher_off + cipher_len + cipher_extralen - auth_off; 
+
+	d_desc= fill_src_dst_sg(s_desc,d_desc,async,req->src,req->dst,&max_frags,cipher_len);
+
+	cipher_extralen = cipher_len % 16;
 
 	if ( cipher_extralen ) {
-		if ( seg >= max_frags ){
-			seg+=  nlm_crypto_sae_num_seg_reqd(auth_iv+38, cipher_extralen);
-		}
-		else 
-			seg = nlm_crypto_fill_src_dst_seg(param,seg,max_frags, (auth_iv+38),cipher_extralen);
+		cipher_extralen = AES_BLOCK_SIZE - cipher_extralen;
+		memset(auth_iv + 38,0,cipher_extralen);
+		saesoc_add_frags(d_desc,(auth_iv+38),cipher_extralen,(auth_iv+38),cipher_extralen);
 	}
-	
 
-	if ( seg > max_frags) {
-		max_frags = seg;
-		seg = alloc_pkt_param(async,&param,max_frags);
-		if ( seg == -1 ) {
-			return -1;
-		}
-	}
-	}while(seg == 1);  
+	/* add all those extra bytes for auth excluding assoc */
+	saesoc_set_aad_len(d_desc,req->assoclen + cipher_extralen +  2 + 6);
 
-	nlm_crypto_fill_cipher_auth_pkt_param(ctrl, param, op, hash_source, iv_off,
-			iv_size, auth_off, auth_len, 0, cipher_off, cipher_len, hash_addr);
-
-	fb_vc = crypto_get_fb_vc(&node);
-	entry0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, ctrl->cipherkeylen, virt_to_phys(ctrl))
-;
-	entry1 = nlm_crypto_form_pkt_fmn_entry1(0, ctrl->hashkeylen, (seg + 2)<<4, virt_to_phys(param));
-
-
-
-#ifdef NLM_CRYPTO_DEBUG
-	printk("*****ctrl descriptor phys addr %#lx\n",virt_to_phys(ctrl));
-	print_crypto_msg_desc(entry0, entry1, tx_id);
-	print_cntl_instr(ctrl->desc0);
-	print_buf("ENC_KEY:", (uint8_t *)ctrl->key, ctrl->cipherkeylen);
-	print_buf("AUTH_KEY:", (uint8_t *)ctrl->key + ctrl->cipherkeylen, ctrl->hashkeylen);
-	print_pkt_desc(param,seg);
-	printk("iv_off: %d, cipher_off: %d, auth_off: %d\n",iv_off, cipher_off, auth_off);
-	printk("auth_len: %d, cipher_len: %d\n", auth_len, cipher_len);
-#endif
+	saesoc_set_payload_len(d_desc,cipher_len);
+	saesoc_set_tag_dstaddr(d_desc,hash_addr);
 
 
+	preempt_disable();
 	async->callback =  aead_request_callback;
 	async->args = (void *)&req->base; 
 	async->op  = op;
@@ -1049,25 +1213,23 @@ static int aead_crypt_ccm(struct aead_request *req, unsigned int op)
 	async->authsize = authsize;
 	async->stat = ctx->stat; 
 	async->bytes = req->cryptlen; 
-	tx_id = (uint64_t)(unsigned long)async;
+	mparam.async_rsp_arg = (uint64_t)async;
+	mparam.arc4_load_state = 0;
 
 	//construct pkt, send to engine and receive reply
-#ifdef CONFIG_32BIT
 	msgrng_access_enable(msgrng_flags);
-#endif
+	fb_vc = crypto_get_fb_vc(&node);
 	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
-	err = nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id);
-#ifdef CONFIG_32BIT
-	msgrng_access_disable(msgrng_flags);
-#endif
-	if(err){
+
+	if (saesoc_process_request(NULL,d_desc,node_sae_base,fb_vc,0,1,&mparam,NULL) != 0 ) {
+		msgrng_access_disable(msgrng_flags);
+		preempt_enable();
 		return -EAGAIN;
 	}
-
+	msgrng_access_disable(msgrng_flags);
+	preempt_enable();
 
 	return -EINPROGRESS;
-
-
 }
 static int aead_crypt_ctr(struct aead_request *req, unsigned int op)
 {
@@ -1075,34 +1237,33 @@ static int aead_crypt_ctr(struct aead_request *req, unsigned int op)
 	struct crypto_alg *alg = tfm->base.__crt_alg;
 	struct aead_alg *aead= &alg->cra_aead;
 	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
-	struct nlm_crypto_pkt_param *param;
-	unsigned int cipher_off, iv_off;
-	unsigned int auth_len, cipher_len, auth_off;
-	int seg = 0,ivsize;
-	unsigned int hash_source;
-	uint64_t entry0, entry1;
-	uint64_t tx_id=0x12345678;
+	struct saesoc_data_desc    *d_desc = NLM_CRYPTO_DATA_DESC(aead_request_ctx(req));
+	unsigned int cipher_len;
+	int ivsize;
 	void  * addr = aead_request_ctx(req);
 	struct nlm_async_crypto *async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET(aead_request_ctx(req));
 	uint8_t *hash_addr;
 	int fb_vc; 
-	int err=0;
 	unsigned int authsize,maxauthsize;
 	uint8_t *iv = NULL; 
-	struct nlm_crypto_pkt_ctrl *ctrl = &ctx->ctrl;
-#ifdef CONFIG_32BIT
 	unsigned long msgrng_flags;
-#endif
 	unsigned int max_frags  = MAX_FRAGS;
 	int node_sae_base;
 	int node;
+	struct saesoc_extra_req_send_params mparam;
+	struct saesoc_session_desc *s_desc ;
+	async->pkt_param = NULL;
+	if ( op )
+		s_desc = &ctx->enc_s_desc;
+	else
+		s_desc = &ctx->dec_s_desc;
 
 	authsize = crypto_aead_authsize(tfm);
 	maxauthsize= aead->maxauthsize;
 	async->pkt_param = NULL;
 	async->src = req->src;
 	async->dst = req->dst;
-	param = (struct nlm_crypto_pkt_param *)NLM_CRYPTO_PKT_PARAM_OFFSET(addr);
+	saesoc_new_data_desc(s_desc, &d_desc, MAX_FRAGS , NULL);
 
 	iv = (uint8_t *)NLM_IV_OFFSET(addr);
 	if ( !op ) {
@@ -1121,55 +1282,22 @@ static int aead_crypt_ctr(struct aead_request *req, unsigned int op)
 	hash_addr = (uint8_t *)NLM_HASH_OFFSET(addr);
 
 	ivsize = crypto_aead_ivsize(crypto_aead_reqtfm(req));
-
-	auth_off = CTR_RFC3686_BLOCK_SIZE;
-	cipher_off = auth_off + req->assoclen + ivsize;
-	iv_off = 0;
-
-	//check if it should be aip->tag_len or can be taken from tfm
 	cipher_len = op ? req->cryptlen:req->cryptlen - authsize;
-	auth_len = cipher_off - auth_off + cipher_len;
-	hash_source = op;
-	seg = nlm_crypto_fill_src_dst_seg(param, seg, max_frags, iv, CTR_RFC3686_BLOCK_SIZE);
-
 
-	do {
-	seg = fill_aead_aad(param, req, req->assoclen,seg,max_frags);
+	saesoc_add_frags(d_desc,iv,CTR_RFC3686_BLOCK_SIZE,iv,CTR_RFC3686_BLOCK_SIZE);
+	saesoc_set_aad_len(d_desc,req->assoclen);
+	fill_aead_aad(d_desc, req, req->assoclen,0,max_frags);
 
-	seg = 	nlm_crypto_fill_src_dst_seg(param, seg, max_frags, iv+CTR_RFC3686_NONCE_SIZE, ivsize);
+	saesoc_add_frags(d_desc,iv + CTR_RFC3686_NONCE_SIZE,ivsize,iv+CTR_RFC3686_NONCE_SIZE,ivsize);
 
-	seg = fill_src_dst_sg(req->src,req->dst, cipher_len, param, seg, max_frags,op);
+	d_desc = fill_src_dst_sg(s_desc,d_desc,async,req->src,req->dst,&max_frags,cipher_len);
 
-	if ( seg > max_frags) {
-		max_frags = seg;
-		seg = alloc_pkt_param(async,&param,max_frags);
-		if ( seg == -1 )
-			return -1;
-		seg = 1;
-	}
-	}while(seg == 1);  
+	saesoc_set_tag_dstaddr(d_desc,hash_addr);
+	saesoc_set_payload_len(d_desc,cipher_len);
 
-	nlm_crypto_fill_cipher_auth_pkt_param(ctrl, param, op, op, iv_off, 
-			CTR_RFC3686_BLOCK_SIZE, auth_off, auth_len, 0, cipher_off, cipher_len, hash_addr);
-	
-	fb_vc = crypto_get_fb_vc(&node);
 
-	entry0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, ctrl->cipherkeylen, virt_to_phys(ctrl));
-	entry1 = nlm_crypto_form_pkt_fmn_entry1(0, ctrl->hashkeylen, (seg + 2)<<4, virt_to_phys(param));
-
-
-#ifdef NLM_CRYPTO_DEBUG
-	printk("*****ctrl descriptor phys addr %#lx\n",virt_to_phys(ctrl));
-	print_crypto_msg_desc(entry0, entry1, tx_id);
-	print_pkt_desc(param,seg);
-	print_cntl_instr(ctrl->desc0);
-	print_buf("ENC_KEY:", (uint8_t *)ctrl->key, ctrl->cipherkeylen);
-	print_buf("AUTH_KEY:", (uint8_t *)ctrl->key + ctrl->cipherkeylen, ctrl->hashkeylen);
-	print_buf("IV ",iv,16);
-	printk("iv_off: %d, cipher_off: %d, auth_off: %d\n",iv_off, cipher_off, auth_off);
-	printk("auth_len: %d, cipher_len: %d\n", auth_len, cipher_len);
-#endif
 
+	preempt_disable();
 	async->callback =  aead_request_callback;
 	async->args = (void *)&req->base; 
 	async->op  = op;
@@ -1177,246 +1305,29 @@ static int aead_crypt_ctr(struct aead_request *req, unsigned int op)
 	async->authsize = authsize;
 	async->stat = ctx->stat;
 	async->bytes = req->cryptlen;
-	tx_id = (uint64_t)(unsigned long)async;
-
-	//construct pkt, send to engine and receive reply
-#ifdef CONFIG_32BIT
-	msgrng_access_enable(msgrng_flags);
-#endif
-	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
-	err = nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id);
-#ifdef CONFIG_32BIT
-	msgrng_access_disable(msgrng_flags);
-#endif
-	if(err){
-		return -EAGAIN;
-	}
+	mparam.async_rsp_arg = (uint64_t)async;
+	mparam.arc4_load_state = 0;
 
-	return -EINPROGRESS;
-}
-
-static int aead_crypt_3des(struct aead_request *req, unsigned int op)
-{
-	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
-	struct crypto_alg *alg = tfm->base.__crt_alg;
-	struct aead_alg *aead= &alg->cra_aead;
-	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
-	struct nlm_crypto_pkt_param *param;
-	unsigned int cipher_off, iv_off;
-	unsigned int auth_len, cipher_len, auth_off;
-	int seg =0,  ivsize;
-	unsigned int hash_source;
-	uint64_t entry0, entry1;
-	uint64_t tx_id=0x12345678;
-	struct nlm_async_crypto *async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET(aead_request_ctx(req));
-	uint8_t *hash_addr;
-	int fb_vc; 
-	int err=0;
-	unsigned int authsize,maxauthsize;
-	struct nlm_crypto_pkt_ctrl *ctrl = NULL;
-#ifdef CONFIG_32BIT
-	unsigned long msgrng_flags;
-#endif
-	unsigned int max_frags  = MAX_FRAGS;
-	int node_sae_base;
-	int node;
-
-	ctx = (struct  nlm_aead_ctx *)(( unsigned long )(( uint8_t *)ctx + CTRL_DESC_SIZE + 64) & ~(0x3fUL));
-	ctrl = &ctx->ctrl;
-	
-	authsize = crypto_aead_authsize(tfm);
-	maxauthsize= aead->maxauthsize;
-	async->pkt_param = NULL;
-	async->src = req->src;
-	async->dst = req->dst;
-
-	param = (struct nlm_crypto_pkt_param *)NLM_CRYPTO_PKT_PARAM_OFFSET(aead_request_ctx(req));
-	hash_addr = (uint8_t *)NLM_HASH_OFFSET(aead_request_ctx(req));
-
-	ivsize = crypto_aead_ivsize(crypto_aead_reqtfm(req));
-	auth_off = 0;
-	cipher_off = req->assoclen + ivsize;
-	iv_off = req->assoclen;
-	//check if it should be aip->tag_len or can be taken from tfm
-	cipher_len = op ? req->cryptlen:req->cryptlen - authsize;
-	auth_len = cipher_off + cipher_len;
-	hash_source = op;
-	do {
-
-	seg = fill_aead_aad(param, req, req->assoclen,seg,max_frags);
-
-	if (ivsize) 
-		seg = nlm_crypto_fill_src_dst_seg(param, seg, max_frags, req->iv, ivsize);
-
-	seg = fill_src_dst_sg(req->src,req->dst, cipher_len, param, seg, max_frags,op);
-
-	if ( seg > max_frags) {
-		max_frags = seg;
-		seg = alloc_pkt_param(async,&param,max_frags);
-		if ( seg == -1 )
-			return -1;
-		seg = 0;
-	}
-	}while(seg == 0);  
-
-	nlm_crypto_fill_cipher_auth_pkt_param(ctrl, param, op, op, iv_off, 
-			ivsize, auth_off, auth_len, 0, cipher_off, cipher_len, hash_addr);
-	
-	fb_vc = crypto_get_fb_vc(&node);
-
-	entry0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, ctrl->cipherkeylen, virt_to_phys(ctrl));
-	entry1 = nlm_crypto_form_pkt_fmn_entry1(0, ctrl->hashkeylen, (seg + 2)<<4, virt_to_phys(param));
-
-
-#ifdef NLM_CRYPTO_DEBUG
-	printk("*****ctrl descriptor phys addr %#lx\n",virt_to_phys(ctrl));
-	print_crypto_msg_desc(entry0, entry1, tx_id);
-	print_cntl_instr(ctrl->desc0);
-	print_buf("ENC_KEY:", (uint8_t *)ctrl->key, ctrl->cipherkeylen);
-	print_buf("AUTH_KEY:", (uint8_t *)ctrl->key + ctrl->cipherkeylen, ctrl->hashkeylen);
-	print_pkt_desc(param,seg);
-	printk("iv_off: %d, cipher_off: %d, auth_off: %d\n",iv_off, cipher_off, auth_off);
-	printk("auth_len: %d, cipher_len: %d\n", auth_len, cipher_len);
-#endif
-
-	async->callback =  aead_request_callback;
-	async->args = (void *)&req->base; 
-	async->op  = op;
-	async->hash_addr = hash_addr;
-	async->authsize = authsize;
-	async->stat = ctx->stat; 
-	async->bytes = req->cryptlen; 
-	tx_id = (uint64_t)(unsigned long)async;
 
 	//construct pkt, send to engine and receive reply
-#ifdef CONFIG_32BIT
 	msgrng_access_enable(msgrng_flags);
-#endif
-	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
-	err = nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id);
-#ifdef CONFIG_32BIT
-	msgrng_access_disable(msgrng_flags);
-#endif
-	if(err){
-		return -EAGAIN;
-	}
-
-
-	return -EINPROGRESS;
-}
-static int aead_crypt(struct aead_request *req, unsigned int op)
-{
-	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
-	struct crypto_alg *alg = tfm->base.__crt_alg;
-	struct aead_alg *aead= &alg->cra_aead;
-	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
-	struct nlm_crypto_pkt_param *param;
-	unsigned int cipher_off, iv_off;
-	unsigned int auth_len, cipher_len, auth_off;
-	int seg =0, ivsize;
-	unsigned int hash_source;
-	uint64_t entry0, entry1;
-	uint64_t tx_id=0x12345678;
-	struct nlm_async_crypto *async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET(aead_request_ctx(req));
-	uint8_t *hash_addr;
-	int fb_vc; 
-	int err=0;
-	unsigned int authsize,maxauthsize;
-	struct nlm_crypto_pkt_ctrl *ctrl = &ctx->ctrl;
-#ifdef CONFIG_32BIT
-	unsigned long msgrng_flags;
-#endif
-	unsigned int max_frags  = MAX_FRAGS;
-	int node_sae_base;
-	int node;
-
-	authsize = crypto_aead_authsize(tfm);
-	maxauthsize= aead->maxauthsize;
-	async->pkt_param = NULL;
-	async->src = req->src;
-	async->dst = req->dst;
-
-	param = (struct nlm_crypto_pkt_param *)NLM_CRYPTO_PKT_PARAM_OFFSET(aead_request_ctx(req));
-	hash_addr = (uint8_t *)NLM_HASH_OFFSET(aead_request_ctx(req));
-
-	ivsize = crypto_aead_ivsize(crypto_aead_reqtfm(req));
-	auth_off = 0;
-	cipher_off = req->assoclen + ivsize;
-	iv_off = req->assoclen;
-	//check if it should be aip->tag_len or can be taken from tfm
-	cipher_len = op ? req->cryptlen:req->cryptlen - authsize;
-	auth_len = cipher_off + cipher_len;
-	hash_source = op;
-
-	do { 
-
-	seg = fill_aead_aad(param, req, req->assoclen,seg,max_frags);
-
-	if (ivsize) 
-		seg = nlm_crypto_fill_src_dst_seg(param, seg, max_frags, req->iv, ivsize);
-
-	seg = fill_src_dst_sg(req->src,req->dst, cipher_len, param, seg, max_frags,op);
-
-	if ( seg > max_frags) {
-		max_frags = seg;
-		seg = alloc_pkt_param(async,&param,max_frags);
-		if ( seg == -1 )
-			return -1;
-		seg = 0;
-	}
-	}while(seg == 0);  
-
-	nlm_crypto_fill_cipher_auth_pkt_param(ctrl, param, op, op, iv_off, 
-			ivsize, auth_off, auth_len, 0, cipher_off, cipher_len, hash_addr);
-	
 	fb_vc = crypto_get_fb_vc(&node);
-
-	entry0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, ctrl->cipherkeylen, virt_to_phys(ctrl));
-	entry1 = nlm_crypto_form_pkt_fmn_entry1(0, ctrl->hashkeylen, (seg + 2)<<4, virt_to_phys(param));
-
-
-#ifdef NLM_CRYPTO_DEBUG
-	printk("*****ctrl descriptor phys addr %#lx\n",virt_to_phys(ctrl));
-	print_crypto_msg_desc(entry0, entry1, tx_id);
-	print_cntl_instr(ctrl->desc0);
-	print_buf("ENC_KEY:", (uint8_t *)ctrl->key, ctrl->cipherkeylen);
-	print_buf("AUTH_KEY:", (uint8_t *)ctrl->key + ctrl->cipherkeylen, ctrl->hashkeylen);
-	print_pkt_desc(param,seg);
-	printk("iv_off: %d, cipher_off: %d, auth_off: %d\n",iv_off, cipher_off, auth_off);
-	printk("auth_len: %d, cipher_len: %d\n", auth_len, cipher_len);
-#endif
-
-	async->callback =  aead_request_callback;
-	async->args = (void *)&req->base; 
-	async->op  = op;
-	async->hash_addr = hash_addr;
-	async->authsize = authsize;
-	async->stat = ctx->stat; 
-	async->bytes = req->cryptlen; 
-	tx_id = (uint64_t)(unsigned long)async;
-
-
-	//construct pkt, send to engine and receive reply
-#ifdef CONFIG_32BIT
-	msgrng_access_enable(msgrng_flags);
-#endif
 	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
-	err = nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id);
-#ifdef CONFIG_32BIT
-	msgrng_access_disable(msgrng_flags);
-#endif
-	if(err){
+
+	if (saesoc_process_request(NULL,d_desc,node_sae_base,fb_vc,0,1,&mparam,NULL) != 0 ) {
+		msgrng_access_disable(msgrng_flags);
+		preempt_enable();
 		return -EAGAIN;
 	}
-
+	msgrng_access_disable(msgrng_flags);
+	preempt_enable();
+	//construct pkt, send to engine and receive reply
 	return -EINPROGRESS;
 }
 
-
 /*
  *  All Encrypt Functions goes here.
  */
-
 static int 
 xlp_aes_cbc_encrypt(struct aead_request *req)
 {
@@ -1433,20 +1344,17 @@ xlp_des_cbc_encrypt(struct aead_request *req)
 {
 	return aead_crypt(req, NETL_OP_ENCRYPT);
 }
-
 static int
 xlp_aes_gcm_encrypt(struct aead_request *req)
 {
 	return aead_crypt_gcm(req, NETL_OP_ENCRYPT);
 }
-
 static int
 xlp_aes_ccm_encrypt(struct aead_request *req)
 {
 	return aead_crypt_ccm(req, NETL_OP_ENCRYPT);
 }
 
-
 static int 
 xlp_aes_ctr_encrypt(struct aead_request *req)
 {
@@ -1456,7 +1364,6 @@ xlp_aes_ctr_encrypt(struct aead_request *req)
 /*
  *  All Decrypt Functions goes here.
  */
-
 static int xlp_aes_cbc_decrypt(struct aead_request *req)
 {
 	return aead_crypt(req, NETL_OP_DECRYPT);
@@ -1464,18 +1371,16 @@ static int xlp_aes_cbc_decrypt(struct aead_request *req)
 
 static int xlp_3des_cbc_decrypt( struct aead_request *req)
 {
-	return aead_crypt_3des(req, NETL_OP_DECRYPT);
+	return aead_crypt(req, NETL_OP_DECRYPT);
 }
 static int xlp_des_cbc_decrypt(struct aead_request *req)
 {
 	return aead_crypt(req, NETL_OP_DECRYPT);
 }
-
 static int xlp_aes_gcm_decrypt(struct aead_request *req)
 {
 	return aead_crypt_gcm(req, NETL_OP_DECRYPT);
 }
-
 static int xlp_aes_ccm_decrypt(struct aead_request *req)
 {
 	return aead_crypt_ccm(req, NETL_OP_DECRYPT);
@@ -1487,7 +1392,6 @@ static int xlp_aes_ctr_decrypt(struct aead_request *req)
 /*
  *  All Givencrypt Functions goes here.
  */
-
 int xlp_aes_cbc_givencrypt(struct aead_givcrypt_request *req)
 {
 	struct crypto_aead *tfm = crypto_aead_reqtfm(&req->areq);
@@ -1525,7 +1429,6 @@ static int xlp_des_cbc_givencrypt(struct aead_givcrypt_request *req)
 	return xlp_des_cbc_encrypt(&req->areq);
 }
 
-
 static int xlp_aes_gcm_givencrypt(struct aead_givcrypt_request *req)
 {
 	struct crypto_aead *tfm = crypto_aead_reqtfm(&req->areq);
@@ -1543,7 +1446,6 @@ static int xlp_aes_gcm_givencrypt(struct aead_givcrypt_request *req)
 	return ret;
 
 }
-
 static int xlp_aes_ccm_givencrypt(struct aead_givcrypt_request *req)
 {
 	struct crypto_aead *tfm = crypto_aead_reqtfm(&req->areq);
@@ -1561,14 +1463,13 @@ static int xlp_aes_ccm_givencrypt(struct aead_givcrypt_request *req)
 	return ret;
 
 }
-
 int xlp_aes_ctr_givencrypt(struct aead_givcrypt_request *req)
 {
 	struct crypto_aead *tfm = crypto_aead_reqtfm(&req->areq);
 	struct nlm_aead_ctx *nlm_ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
 	void *iv = (uint8_t *)NLM_IV_OFFSET(aead_request_ctx(&req->areq));
 	memcpy(req->giv, nlm_ctx->iv_buf+CTR_RFC3686_NONCE_SIZE, nlm_ctx->iv_len);
-	*(uint64_t *)req->giv += req->seq;
+	*(uint64_t *)req->giv += ccpu_to_be64(req->seq);
 
 	memcpy(iv,  nlm_ctx->iv_buf, CTR_RFC3686_NONCE_SIZE);
 	iv += CTR_RFC3686_NONCE_SIZE;
@@ -1600,7 +1501,6 @@ static struct crypto_alg xlp_aes_cbc_hmac_sha256_cipher_auth = {
 		     .encrypt = xlp_aes_cbc_encrypt,
 		     .decrypt = xlp_aes_cbc_decrypt,
 		     .givencrypt = xlp_aes_cbc_givencrypt,
-		     .geniv = "<built-in>",
 		     .ivsize = AES_BLOCK_SIZE,
 		     .maxauthsize = SHA256_DIGEST_SIZE,
 		     }
@@ -1675,29 +1575,6 @@ static struct crypto_alg xlp_aes_cbc_hmac_md5_cipher_auth = {
 		     }
 };
 
-static struct crypto_alg xlp_3des_cbc_hmac_md5_cipher_auth = {
-	/* AEAD algorithms.  These use a single-pass ipsec_esp descriptor */
-	.cra_name = "authenc(hmac(md5),cbc(des3_ede))",
-	.cra_driver_name = "authenc-hmac-md5-cbc-des3-xlp",
-	.cra_priority = XLP_CRYPT_PRIORITY,
-	.cra_blocksize = DES3_EDE_BLOCK_SIZE,
-	.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
-	.cra_ctxsize = DES3_CTRL_DESC_SIZE, 
-	.cra_type = &crypto_aead_type,
-	.cra_init = aead_cra_init,
-	.cra_exit = aead_session_cleanup,
-	.cra_aead = {
-		     .setkey = xlp_3des_cbc_hmac_md5_setkey,
-		     .setauthsize = aead_setauthsize,
-		     .encrypt = xlp_3des_cbc_encrypt,
-		     .decrypt = xlp_3des_cbc_decrypt,
-		     .givencrypt = xlp_3des_cbc_givencrypt,
-		     .geniv = "<built-in>",
-		     .ivsize = DES3_EDE_BLOCK_SIZE,
-		     .maxauthsize = MD5_DIGEST_SIZE,
-		     }
-};
-
 static struct crypto_alg xlp_3des_cbc_hmac_sha256_cipher_auth = {
 	/* AEAD algorithms.  These use a single-pass ipsec_esp descriptor */
 	.cra_name = "authenc(hmac(sha256),cbc(des3_ede))",
@@ -1767,100 +1644,121 @@ static struct crypto_alg xlp_3des_cbc_aes_xcbc_mac_cipher_auth = {
 		     }
 };
 
+static struct crypto_alg xlp_3des_cbc_hmac_md5_cipher_auth = {
+	/* AEAD algorithms.  These use a single-pass ipsec_esp descriptor */
+	.cra_name = "authenc(hmac(md5),cbc(des3_ede))",
+	.cra_driver_name = "authenc-hmac-md5-cbc-des3-xlp",
+	.cra_priority = XLP_CRYPT_PRIORITY,
+	.cra_blocksize = DES3_EDE_BLOCK_SIZE,
+	.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
+	.cra_ctxsize = DES3_CTRL_DESC_SIZE, 
+	.cra_type = &crypto_aead_type,
+	.cra_init = aead_cra_init,
+	.cra_exit = aead_session_cleanup,
+	.cra_aead = {
+		     .setkey = xlp_3des_cbc_hmac_md5_setkey,
+		     .setauthsize = aead_setauthsize,
+		     .encrypt = xlp_3des_cbc_encrypt,
+		     .decrypt = xlp_3des_cbc_decrypt,
+		     .givencrypt = xlp_3des_cbc_givencrypt,
+		     .geniv = "<built-in>",
+		     .ivsize = DES3_EDE_BLOCK_SIZE,
+		     .maxauthsize = MD5_DIGEST_SIZE,
+		     }
+};
 
-static struct crypto_alg xlp_des_cbc_aes_xcbc_mac_cipher_auth = {
+static struct crypto_alg xlp_des_cbc_hmac_sha256_cipher_auth = {
         /* AEAD algorithms.  These use a single-pass ipsec_esp descriptor */
-        .cra_name = "authenc(xcbc(aes),cbc(des))",
-        .cra_driver_name = "authenc-xcbc-mac-aes-cbc-des-xlp",
+        .cra_name = "authenc(hmac(sha256),cbc(des))",
+        .cra_driver_name = "authenc-hmac-sha256-cbc-des-xlp",
         .cra_priority = XLP_CRYPT_PRIORITY,
         .cra_blocksize = DES_BLOCK_SIZE,
+	.cra_alignmask = 0,
         .cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
         .cra_ctxsize = CTRL_DESC_SIZE,
         .cra_type = &crypto_aead_type,
         .cra_init = aead_cra_cbc_init,
         .cra_exit = aead_session_cleanup,
         .cra_aead = {
-                     .setkey = xlp_des_cbc_aes_xcbc_mac_setkey,
+                     .setkey = xlp_des_cbc_hmac_sha256_setkey,
                      .setauthsize = aead_setauthsize,
                      .encrypt = xlp_des_cbc_encrypt,
                      .decrypt = xlp_des_cbc_decrypt,
                      .givencrypt = xlp_des_cbc_givencrypt,
                      .geniv = "<built-in>",
                      .ivsize = DES_BLOCK_SIZE,
-                     .maxauthsize = MD5_DIGEST_SIZE,
+                     .maxauthsize = SHA256_DIGEST_SIZE,
                      }
 };
-static struct crypto_alg xlp_des_cbc_hmac_md5_cipher_auth = {
+static struct crypto_alg xlp_des_cbc_hmac_sha1_cipher_auth = {
         /* AEAD algorithms.  These use a single-pass ipsec_esp descriptor */
-        .cra_name = "authenc(hmac(md5),cbc(des))",
-        .cra_driver_name = "authenc-hmac-md5-cbc-des-xlp",
+        .cra_name = "authenc(hmac(sha1),cbc(des))",
+        .cra_driver_name = "authenc-hmac-sha1-cbc-des-xlp",
         .cra_priority = XLP_CRYPT_PRIORITY,
-	.cra_alignmask = 0,
         .cra_blocksize = DES_BLOCK_SIZE,
+	.cra_alignmask = 0,
         .cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
         .cra_ctxsize = CTRL_DESC_SIZE,
         .cra_type = &crypto_aead_type,
-        .cra_init = aead_cra_cbc_init,
         .cra_exit = aead_session_cleanup,
+        .cra_init = aead_cra_cbc_init,
         .cra_aead = {
-                     .setkey = xlp_des_cbc_hmac_md5_setkey,
+                     .setkey = xlp_des_cbc_hmac_sha1_setkey,
                      .setauthsize = aead_setauthsize,
                      .encrypt = xlp_des_cbc_encrypt,
                      .decrypt = xlp_des_cbc_decrypt,
                      .givencrypt = xlp_des_cbc_givencrypt,
                      .geniv = "<built-in>",
                      .ivsize = DES_BLOCK_SIZE,
-                     .maxauthsize = MD5_DIGEST_SIZE,
+                     .maxauthsize = SHA1_DIGEST_SIZE,
                      }
 };
 
-static struct crypto_alg xlp_des_cbc_hmac_sha256_cipher_auth = {
+static struct crypto_alg xlp_des_cbc_aes_xcbc_mac_cipher_auth = {
         /* AEAD algorithms.  These use a single-pass ipsec_esp descriptor */
-        .cra_name = "authenc(hmac(sha256),cbc(des))",
-        .cra_driver_name = "authenc-hmac-sha256-cbc-des-xlp",
+        .cra_name = "authenc(xcbc(aes),cbc(des))",
+        .cra_driver_name = "authenc-xcbc-mac-aes-cbc-des-xlp",
         .cra_priority = XLP_CRYPT_PRIORITY,
         .cra_blocksize = DES_BLOCK_SIZE,
-	.cra_alignmask = 0,
         .cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
         .cra_ctxsize = CTRL_DESC_SIZE,
         .cra_type = &crypto_aead_type,
         .cra_init = aead_cra_cbc_init,
         .cra_exit = aead_session_cleanup,
         .cra_aead = {
-                     .setkey = xlp_des_cbc_hmac_sha256_setkey,
+                     .setkey = xlp_des_cbc_aes_xcbc_mac_setkey,
                      .setauthsize = aead_setauthsize,
                      .encrypt = xlp_des_cbc_encrypt,
                      .decrypt = xlp_des_cbc_decrypt,
                      .givencrypt = xlp_des_cbc_givencrypt,
                      .geniv = "<built-in>",
                      .ivsize = DES_BLOCK_SIZE,
-                     .maxauthsize = SHA256_DIGEST_SIZE,
+                     .maxauthsize = MD5_DIGEST_SIZE,
                      }
 };
-static struct crypto_alg xlp_des_cbc_hmac_sha1_cipher_auth = {
+static struct crypto_alg xlp_des_cbc_hmac_md5_cipher_auth = {
         /* AEAD algorithms.  These use a single-pass ipsec_esp descriptor */
-        .cra_name = "authenc(hmac(sha1),cbc(des))",
-        .cra_driver_name = "authenc-hmac-sha1-cbc-des-xlp",
+        .cra_name = "authenc(hmac(md5),cbc(des))",
+        .cra_driver_name = "authenc-hmac-md5-cbc-des-xlp",
         .cra_priority = XLP_CRYPT_PRIORITY,
-        .cra_blocksize = DES_BLOCK_SIZE,
 	.cra_alignmask = 0,
+        .cra_blocksize = DES_BLOCK_SIZE,
         .cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
         .cra_ctxsize = CTRL_DESC_SIZE,
         .cra_type = &crypto_aead_type,
-        .cra_exit = aead_session_cleanup,
         .cra_init = aead_cra_cbc_init,
+        .cra_exit = aead_session_cleanup,
         .cra_aead = {
-                     .setkey = xlp_des_cbc_hmac_sha1_setkey,
+                     .setkey = xlp_des_cbc_hmac_md5_setkey,
                      .setauthsize = aead_setauthsize,
                      .encrypt = xlp_des_cbc_encrypt,
                      .decrypt = xlp_des_cbc_decrypt,
                      .givencrypt = xlp_des_cbc_givencrypt,
                      .geniv = "<built-in>",
                      .ivsize = DES_BLOCK_SIZE,
-                     .maxauthsize = SHA1_DIGEST_SIZE,
+                     .maxauthsize = MD5_DIGEST_SIZE,
                      }
 };
-
 static struct crypto_alg xlp_aes_gcm_cipher_auth = {
 	/* AEAD algorithms.  These use a single-pass ipsec_esp descriptor */
 	.cra_name = "rfc4106(gcm(aes))",
@@ -1884,7 +1782,6 @@ static struct crypto_alg xlp_aes_gcm_cipher_auth = {
 		.maxauthsize = GCM_RFC4106_DIGEST_SIZE,
 	}
 };
-
 static struct crypto_alg xlp_aes_ccm_cipher_auth = {
 	/* AEAD algorithms.  These use a single-pass ipsec_esp descriptor */
 	.cra_name = "rfc4309(ccm(aes))",
@@ -1908,10 +1805,10 @@ static struct crypto_alg xlp_aes_ccm_cipher_auth = {
 	}
 };
 
-static struct crypto_alg xlp_aes_ctr_hmac_sha1_cipher_auth = {
+static struct crypto_alg xlp_aes_ctr_hmac_sha256_cipher_auth = {
 	/* AEAD algorithms.  These use a single-pass ipsec_esp descriptor */
-	.cra_name = "authenc(hmac(sha1),rfc3686(ctr(aes)))",
-	.cra_driver_name = "authenc-hmac-sha1-ctr-aes-xlp",
+	.cra_name = "authenc(hmac(sha256),rfc3686(ctr(aes)))",
+	.cra_driver_name = "authenc-hmac-sha256-ctr-aes-xlp",
 	.cra_priority = XLP_CRYPT_PRIORITY,
 	.cra_blocksize = 1,
 	.cra_alignmask = 0,
@@ -1921,21 +1818,21 @@ static struct crypto_alg xlp_aes_ctr_hmac_sha1_cipher_auth = {
 	.cra_init = aead_cra_init,
 	.cra_exit = aead_session_cleanup,
 	.cra_aead = {
-		     .setkey = xlp_aes_ctr_hmac_sha1_setkey,
+		     .setkey = xlp_aes_ctr_hmac_sha256_setkey,
 		     .setauthsize = aead_setauthsize,
 		     .encrypt = xlp_aes_ctr_encrypt,
 		     .decrypt = xlp_aes_ctr_decrypt,
 		     .givencrypt = xlp_aes_ctr_givencrypt,
 		     .geniv = "seqiv", 
 		     .ivsize = CTR_RFC3686_IV_SIZE,
-		     .maxauthsize = SHA1_DIGEST_SIZE,
+		     .maxauthsize = SHA256_DIGEST_SIZE,
 		     }
 };
 
-static struct crypto_alg xlp_aes_ctr_hmac_sha256_cipher_auth = {
+static struct crypto_alg xlp_aes_ctr_hmac_sha1_cipher_auth = {
 	/* AEAD algorithms.  These use a single-pass ipsec_esp descriptor */
-	.cra_name = "authenc(hmac(sha256),rfc3686(ctr(aes)))",
-	.cra_driver_name = "authenc-hmac-sha256-ctr-aes-xlp",
+	.cra_name = "authenc(hmac(sha1),rfc3686(ctr(aes)))",
+	.cra_driver_name = "authenc-hmac-sha1-ctr-aes-xlp",
 	.cra_priority = XLP_CRYPT_PRIORITY,
 	.cra_blocksize = 1,
 	.cra_alignmask = 0,
@@ -1945,14 +1842,14 @@ static struct crypto_alg xlp_aes_ctr_hmac_sha256_cipher_auth = {
 	.cra_init = aead_cra_init,
 	.cra_exit = aead_session_cleanup,
 	.cra_aead = {
-		     .setkey = xlp_aes_ctr_hmac_sha256_setkey,
+		     .setkey = xlp_aes_ctr_hmac_sha1_setkey,
 		     .setauthsize = aead_setauthsize,
 		     .encrypt = xlp_aes_ctr_encrypt,
 		     .decrypt = xlp_aes_ctr_decrypt,
 		     .givencrypt = xlp_aes_ctr_givencrypt,
 		     .geniv = "seqiv", 
 		     .ivsize = CTR_RFC3686_IV_SIZE,
-		     .maxauthsize = SHA256_DIGEST_SIZE,
+		     .maxauthsize = SHA1_DIGEST_SIZE,
 		     }
 };
 static struct crypto_alg xlp_aes_ctr_aes_xcbc_mac_cipher_auth = {
@@ -2000,11 +1897,9 @@ static struct crypto_alg xlp_aes_ctr_hmac_md5_cipher_auth = {
 		     .maxauthsize = MD5_DIGEST_SIZE,
 		     }
 };
-
 int xlp_aead_alg_init(void)
 {
 	int ret = 0;
-
 	if ((ret = crypto_register_alg(&xlp_aes_cbc_hmac_sha256_cipher_auth)))
 		goto end;
 	no_of_alg_registered++;
@@ -2035,6 +1930,7 @@ int xlp_aead_alg_init(void)
 
 	if ((ret = crypto_register_alg(&xlp_3des_cbc_aes_xcbc_mac_cipher_auth)))
 		goto end;
+
 	no_of_alg_registered++;
 	if (( ret = crypto_register_alg(&xlp_des_cbc_hmac_md5_cipher_auth)))
 		goto end;
diff --git a/drivers/crypto/sae/nlm_async.h b/drivers/crypto/sae/nlm_async.h
index 6b9cb26..235aa2c 100644
--- a/drivers/crypto/sae/nlm_async.h
+++ b/drivers/crypto/sae/nlm_async.h
@@ -76,7 +76,8 @@ extern int nlm_crypto_sae_num_seg_reqd(void *data, unsigned int buflen);
 extern int nlm_crypto_calc_rem_len(struct scatterlist *sg, unsigned int cipher_len);
 extern int alloc_pkt_param( struct nlm_async_crypto * async,struct nlm_crypto_pkt_param ** pkt_param , int max_frags);
 
-extern int fill_src_dst_sg(struct scatterlist *src_sg, struct scatterlist *dst_sg, unsigned int cipher_len, 
-		struct nlm_crypto_pkt_param *param, 
-		int seg, unsigned int max_frags, int op);
+extern struct saesoc_data_desc    * fill_src_dst_sg(struct saesoc_session_desc *s_desc,
+		struct saesoc_data_desc    *d_desc,struct nlm_async_crypto *async, 
+		struct scatterlist *src_sg,         struct scatterlist * dst_sg,
+		unsigned int * nfrags,unsigned int cipher_len);
 #endif
diff --git a/drivers/crypto/sae/nlm_auth.c b/drivers/crypto/sae/nlm_auth.c
index d30d2f6..caf6aaf 100644
--- a/drivers/crypto/sae/nlm_auth.c
+++ b/drivers/crypto/sae/nlm_auth.c
@@ -16,9 +16,25 @@
 #include <nlm_hal_fmn.h>
 #include <crypto/aes.h>
 #include <crypto/internal/hash.h>
+#include "saesoc_lib.h"
 #include "nlm_async.h"
-#include <asm/netlogic/msgring.h>
+//#include <asm/netlogic/msgring.h>
 #include <crypto/scatterwalk.h>
+#include <nlm_xlp.h>
+#include <linux/module.h>
+#include <nlm_msgring.h>
+
+
+#include <linux/proc_fs.h>
+#include <nlm_hal_fmn.h>
+#include <nlm_hal_macros.h>
+#include <linux/module.h>
+#include <nlm_hal.h>
+#include <nlm_xlp.h>
+#include <linux/crypto.h>
+#include <nlm_msgring.h>
+#include "saesoc_lib.h"
+#include "nlm_async.h"
 
 #define XLP_AUTH_PRIORITY      300
 #define XLP_HMAC_PRIORITY      300
@@ -35,28 +51,14 @@
 extern void hex_dump(char * description,unsigned char *in, int num);
 #endif
 
-int auth_mode_key_len[NLM_HASH_MAX][NLM_HASH_MODE_MAX] = {
-/*	               SHA1 SHA224 SHA256 SHA384 SHA512  CMAC  XCBC CBC_MAC CCM  GCM*/
-/* BYPASS */		{0,    0,     0,     0,     0,     0,   0,    0,     0,    0, },
-/* MD5 */		{64,   64,    64,   64,    64,    64,  64,   64,    64,   64, },
-/* SHA */		{64,   64,    64,   128,   128,    0,   0,    0,     0,    0, },
-/* 3 */			{0,    0,     0,     0,     0,     0,   0,    0,     0,    0, },
-/* AES128 */		{0,    0,     0,     0,     0,    16,  16,   16,    16,   16, },
-/* AES192 */		{0,    0,     0,     0,     0,    24,  24,   24,    24,   24, },
-/* AES256 */		{0,    0,     0,     0,     0,    32,  32,   32,    32,   32, },
-/* KASUMI_F9 */		{16,  16,    16,    16,    16,    16,  16,   16,    16,   16, },
-/* SNOW3G_F9 */		{16,  16,    16,    16,    16,    16,  16,   16,    16,   16, }, //sandip -> verify
-/* CAMELLIA128 */	{0,    0,     0,     0,     0,    16,  16,   16,    16,   16, },
-/* CAMELLIA192 */	{0,    0,     0,     0,     0,    24,  24,   24,    24,   24, },
-/* CAMELLIA256 */	{0,    0,     0,     0,     0,    32,  32,   32,    32,   32, },
-/* GHASH */		{0,    0,     0,     0,     0,    32,  32,   32,    32,   32, }, //todo:
-};
-
 struct nlm_auth_ctx
 {
-	struct nlm_crypto_pkt_ctrl ctrl;
+	struct saesoc_session_desc s_desc;
+	unsigned long long key[16];
+	struct saesoc_session_init_params initp;
 	uint16_t stat;
 	uint8_t hashed_key[128]; // can be replace by a local varibale */
+
 	struct crypto_ahash * fallback_tfm;
 	/*Don't change the order of this strucutre*/
 };
@@ -64,30 +66,28 @@ struct nlm_auth_ctx
 #define MAX_FRAGS               18
 #define CTRL_DESC_SIZE          (sizeof(struct nlm_auth_ctx) + 64)
 
-struct auth_pkt_desc
+struct app_data_priv 
 {
 	uint32_t total_len;
-	uint32_t index;
-	uint16_t max_frags;
+	unsigned int nfrags;
 	struct ahash_request * fallback_req;
-	struct nlm_crypto_pkt_param * pkt_param; /* maintain at the end */ 
 };
 
-#define PACKET_DESC_SIZE   (64+sizeof(struct auth_pkt_desc) + MAX_FRAGS*(2*8) + sizeof(struct nlm_async_crypto) + 128 ) /* should be less than PAGE_SIZE/8 */ 
-#define NLM_CRYPTO_PKT_PARAM_OFFSET(addr)       (((unsigned long)addr + 64) & ~0x3fUL)
-#define NLM_ASYNC_PTR_PARAM_OFFSET(addr)        ((unsigned long)(addr + 64 + sizeof(struct auth_pkt_desc) + MAX_FRAGS*(2*8) + 64) & ~0x3fUL)
+
+#define PACKET_DESC_SIZE   (64+sizeof(struct saesoc_data_desc) + sizeof(struct app_data_priv) + (MAX_FRAGS*8) + sizeof(struct nlm_async_crypto) + 128 ) /* should be less than PAGE_SIZE/8 */ 
+#define NLM_CRYPTO_DATA_DESC(addr)       (((unsigned long)addr + 64) & ~0x3fUL)
+#define NLM_ASYNC_PTR_PARAM_OFFSET(addr)        ((unsigned long)(addr + 64 + sizeof(struct saesoc_data_desc) + sizeof(struct app_data_priv) + (MAX_FRAGS*8) + 64) & ~0x3fUL)
 #define NLM_CRYPTO_CTRL_DESC(addr ) ( ((unsigned long)addr + 64) & ~(0x3fUL))
 /*
    All extern declaration goes here.
  */
-extern uint32_t nlm_hal_send_msg3(uint32_t dst, uint32_t code, uint64_t data0, uint64_t data1, uint64_t data2);
-extern uint32_t nlm_hal_recv_msg2(uint32_t dst, uint32_t *src, uint32_t *size, uint32_t *code, uint64_t *data0, uint64_t *data1);
 extern void print_cntl_instr(uint64_t cntl_desc);
 extern void print_crypto_msg_desc(uint64_t entry1, uint64_t entry2, uint64_t entry3);
 extern void print_pkt_desc(struct nlm_crypto_pkt_param * pkt_param, int index);
 extern struct nlm_crypto_stat crypto_stat[MAX_CPU];
 
 
+static void auth_request_callback(struct nlm_async_crypto *async, uint64_t msg1);
 static inline void print_info(const char *func)
 {
 	extern void dump_stack(void);
@@ -109,13 +109,6 @@ static struct nlm_auth_ctx * ctrl_desc_req_ahash_ctx(struct ahash_request * req)
 	struct crypto_ahash * ahash = crypto_ahash_reqtfm(req);
 	return ctrl_desc_crypto_ahash_ctx(ahash);
 }
-
-struct auth_pkt_desc *pkt_desc_req_ctx(struct ahash_request *req) 
-{
-	struct auth_pkt_desc *auth_pkt_desc = (struct auth_pkt_desc * )NLM_CRYPTO_PKT_PARAM_OFFSET(ahash_request_ctx(req));
-	return auth_pkt_desc; 
-}
-
 static int
 xlp_cra_xcbc_init(struct crypto_tfm *tfm)
 {
@@ -124,7 +117,6 @@ xlp_cra_xcbc_init(struct crypto_tfm *tfm)
 	crypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),PACKET_DESC_SIZE);
 	return 0;
 }
-
 static int
 xlp_cra_hmac_sha1_init(struct crypto_tfm *tfm)
 {
@@ -151,163 +143,123 @@ xlp_cra_md5_init(struct crypto_tfm *tfm)
 	return 0;
 }
 static int
-xlp_auth_init(struct ahash_request *req)
+xlp_auth_init(struct ahash_request *areq)
 {
-	struct auth_pkt_desc *auth_pkt_desc = pkt_desc_req_ctx(req);
-	struct nlm_async_crypto * async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET((unsigned long)auth_pkt_desc);;
-	auth_pkt_desc->total_len = 0;
-	async->stat = 0;
-	auth_pkt_desc->fallback_req = NULL;
-	auth_pkt_desc->max_frags = MAX_FRAGS;
-	auth_pkt_desc->index = 0;
-	auth_pkt_desc->pkt_param = ( struct nlm_crypto_pkt_param  * )NLM_CRYPTO_PKT_PARAM_OFFSET((unsigned long )auth_pkt_desc + sizeof(struct auth_pkt_desc ));
-	async->pkt_param = NULL;
+
+	struct saesoc_data_desc    *d_desc = (struct saesoc_data_desc    *)NLM_CRYPTO_DATA_DESC(ahash_request_ctx(areq));
+	struct app_data_priv * d_priv = (struct app_data_priv *)((unsigned long)d_desc + sizeof(struct saesoc_data_desc)+(MAX_FRAGS*16)) ;
+	struct nlm_auth_ctx  * auth_ctx   = ctrl_desc_req_ahash_ctx(areq);	
+
+	saesoc_new_data_desc(&auth_ctx->s_desc, &d_desc, MAX_FRAGS , NULL);
+	d_priv->total_len = 0;
+	d_priv->fallback_req = NULL;
+	d_priv->nfrags = MAX_FRAGS;
 	return 0;
 }
 extern 
 int nlm_crypto_calc_rem_len(struct scatterlist *sg, unsigned int cipher_len);
-extern int fill_src_dst_sg(struct scatterlist *src_sg, struct scatterlist *dst_sg, unsigned int cipher_len,
-                struct nlm_crypto_pkt_param *param, 
-                int seg, unsigned int max_frags, int op);
 static int
 xlp_auth_update(struct ahash_request *areq)
 {
-	struct auth_pkt_desc *auth_pkt_desc = pkt_desc_req_ctx(areq);
-	struct nlm_crypto_pkt_param  *pkt_param  = auth_pkt_desc->pkt_param;
-	int max_frags = auth_pkt_desc->max_frags;
-	int index = auth_pkt_desc->index;
-	unsigned int auth_len;
-	struct nlm_async_crypto * async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET((unsigned long)auth_pkt_desc);;
-
-	if ( areq->nbytes == 0 )
+	struct saesoc_data_desc    *d_desc = (struct saesoc_data_desc    *)NLM_CRYPTO_DATA_DESC(ahash_request_ctx(areq));
+	struct app_data_priv * d_priv = (struct app_data_priv *)((unsigned long)d_desc + sizeof(struct saesoc_data_desc)+(MAX_FRAGS*16)) ;
+	struct nlm_async_crypto * async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET((unsigned long)d_desc);
+	struct nlm_auth_ctx  * auth_ctx   = ctrl_desc_req_ahash_ctx(areq);	
+	struct saesoc_session_desc *s_desc = &auth_ctx->s_desc;
+	unsigned int nfrags = d_priv->nfrags;
+
+	if ( areq->nbytes == 0 ) 
 		return 0;
-	do {
-		auth_len = areq->nbytes;
-		index = fill_src_dst_sg(areq->src,areq->src,auth_len,pkt_param,index,max_frags,0);
-
-		if ( index > max_frags ) {
-			struct nlm_crypto_pkt_param * param  = auth_pkt_desc->pkt_param;
-			int filled_index = auth_pkt_desc->index;
-			int i;
-			alloc_pkt_param(async,&pkt_param,index);
-			for(i = 0; i < filled_index; i++) {
-				pkt_param->segment[i][0] =  param->segment[i][0];
-				pkt_param->segment[i][1] =  param->segment[i][1];
-			}
-			max_frags = index;
-			index = auth_pkt_desc->index;
-			auth_pkt_desc->pkt_param = pkt_param;
-		}
-	}while(index == auth_pkt_desc->index );
-
-
-	auth_pkt_desc->total_len += areq->nbytes;
-	auth_pkt_desc->index = index;
-	auth_pkt_desc->max_frags = max_frags;
+	fill_src_dst_sg(s_desc,d_desc,async,areq->src,areq->src,&nfrags,areq->nbytes);
+	d_priv->nfrags = nfrags;
 
+	d_priv->total_len += areq->nbytes;
 	return 0;
 }
-static void auth_request_callback(struct nlm_async_crypto *async, uint64_t msg1)
-{
-	struct crypto_async_request *base = (struct crypto_async_request *)async->args;
-	int err = 0;
-	int cpu = hard_smp_processor_id();
-	int stat = async->stat & 0xff;
-
-	if (msg1 & 0x7ff80) {
-		printk("\n Error: entry1 is %llx",msg1);
-		err = -EIO;
-		base->complete(base, err);
-		return ;
-	}
-	crypto_stat[cpu].auth[stat] ++;
-	crypto_stat[cpu].auth_tbytes[stat] += async->bytes;
-
-	if ( async->pkt_param)
-		kfree(async->pkt_param);
-	base->complete(base, err);
-	return;
-}
-
-
-
-
 
 static int
 xlp_auth_final(struct ahash_request *areq)
 {
-	struct auth_pkt_desc *auth_pkt_desc = pkt_desc_req_ctx(areq); 
+
+	struct saesoc_data_desc    *d_desc = (struct saesoc_data_desc    *)NLM_CRYPTO_DATA_DESC(ahash_request_ctx(areq));
+	struct app_data_priv * d_priv = (struct app_data_priv *)((unsigned long)d_desc + sizeof(struct saesoc_data_desc)+(MAX_FRAGS*16)) ;
 	struct nlm_auth_ctx  * auth_ctx   = ctrl_desc_req_ahash_ctx(areq);	
-	struct nlm_crypto_pkt_param  *pkt_param  = auth_pkt_desc->pkt_param;
 	int fb_vc ;
-	int index = auth_pkt_desc->index ;
-	uint64_t entry0, entry1, tx_id=0x12345678ULL;
-	struct nlm_crypto_pkt_ctrl *ctrl = &auth_ctx->ctrl;
-#ifdef CONFIG_32BIT
 	unsigned long msgrng_flags;
-#endif
 	int node_sae_base;
 	int node;
-	int err;
-	struct nlm_async_crypto * async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET((unsigned long)auth_pkt_desc);;
+	struct nlm_async_crypto * async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET((unsigned long)d_desc);
+	struct saesoc_extra_req_send_params mparam;
 
-	if ( auth_pkt_desc->total_len == 0 )  { 
+	if ( d_priv->total_len == 0 )  { 
 
 
-		auth_pkt_desc->fallback_req = ahash_request_alloc(auth_ctx->fallback_tfm,GFP_KERNEL);
-		auth_pkt_desc->fallback_req->nbytes = areq->nbytes;
-		auth_pkt_desc->fallback_req->src = areq->src;
-		auth_pkt_desc->fallback_req->result = areq->result;
-		auth_pkt_desc->fallback_req->base.flags =  areq->base.flags;
+		d_priv->fallback_req = ahash_request_alloc(auth_ctx->fallback_tfm,GFP_KERNEL);
+		d_priv->fallback_req->nbytes = areq->nbytes;
+		d_priv->fallback_req->src = areq->src;
+		d_priv->fallback_req->result = areq->result;
+		d_priv->fallback_req->base.flags =  areq->base.flags;
 		
-		crypto_ahash_init(auth_pkt_desc->fallback_req);
-		crypto_ahash_final(auth_pkt_desc->fallback_req);
-		kfree(auth_pkt_desc->fallback_req);
-		auth_pkt_desc->fallback_req = NULL;
+		crypto_ahash_init(d_priv->fallback_req);
+		crypto_ahash_final(d_priv->fallback_req);
+		kfree(d_priv->fallback_req);
+		d_priv->fallback_req = NULL;
 		return 0;
 	}
-		
-	nlm_crypto_fill_auth_pkt_param(ctrl,pkt_param,
-			0,auth_pkt_desc->total_len,0,areq->result); 
-
-
-	fb_vc = crypto_get_fb_vc(&node);
-	entry0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, 0, virt_to_phys(ctrl));
-	entry1 = nlm_crypto_form_pkt_fmn_entry1(0, ctrl->hashkeylen, (32 + index * 16 ), virt_to_phys(pkt_param));
-
 
+	saesoc_set_payload_len(d_desc,d_priv->total_len);
+	saesoc_set_tag_dstaddr(d_desc,areq->result);
+	async->pkt_param = NULL;
+		
+	preempt_disable();
 	async->callback =  auth_request_callback;
 	async->args = (void *)&areq->base; 
 	async->hash_addr = areq->result;
 	async->stat = auth_ctx->stat; 
-	async->bytes = auth_pkt_desc->total_len + ctrl->taglen; 
-	tx_id = (uint64_t)(unsigned long)async;
-
+	async->bytes = d_priv->total_len ; 
 
-#ifdef NLM_CRYPTO_DEBUG
-	print_crypto_msg_desc(entry0, entry1, tx_id);
-	print_cntl_instr(ctrl->desc0);
-	hex_dump("key",ctrl->key,16);
-	print_pkt_desc(pkt_param,index);
-#endif
 
+	mparam.async_rsp_arg = (uint64_t)async;
+	mparam.arc4_load_state = 0;
 
-#ifdef CONFIG_32BIT
 	msgrng_access_enable(msgrng_flags);
-#endif
+	fb_vc = crypto_get_fb_vc(&node);
 	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
-	err = nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id);
-#ifdef CONFIG_32BIT
-	msgrng_access_disable(msgrng_flags);
-#endif
-	if(err){
-		printk("error\n");
-		return -EAGAIN;
+	if ( saesoc_process_request(NULL,d_desc,node_sae_base,fb_vc,0,1,&mparam,NULL) !=  CRYPTOSOC_OK ) {
+		msgrng_access_disable(msgrng_flags);
+		preempt_enable();
+		return -EAGAIN; 
 	}
 
+	msgrng_access_disable(msgrng_flags);
+
  	return -EINPROGRESS;
 
 }
+static void auth_request_callback(struct nlm_async_crypto *async, uint64_t msg1)
+{
+	struct crypto_async_request *base = (struct crypto_async_request *)async->args;
+	int err = 0;
+
+	if (msg1 & 0x7ff80) {
+		printk("\n Error: entry1 is %llx",msg1);
+		err = -EIO;
+		base->complete(base, err);
+		return ;
+	}
+#if 0
+	int cpu = hard_smp_processor_id();
+	int stat = async->stat & 0xff;
+	crypto_stat[cpu].auth[stat] ++;
+	crypto_stat[cpu].auth_tbytes[stat] += async->bytes;
+#endif
+
+	if ( async->pkt_param)
+		kfree(async->pkt_param);
+	base->complete(base, err);
+	return;
+}
+
 /*
    All Setkey goes here.
  */
@@ -317,7 +269,7 @@ crypto_get_sync_fb_vc(int * node)
 {
     int cpu;
     int node_id;
-    extern int ipsec_sync_vc;
+    extern int ipsec_sync_vc ;
 
     cpu = hard_smp_processor_id();      //processor_id();
     node_id = (cpu >> NODE_ID_SHIFT_BIT);
@@ -326,83 +278,165 @@ crypto_get_sync_fb_vc(int * node)
 
     return cpu;
 }
-int hash_key(int alg, int mode, const uint8_t * key, unsigned int keylen, uint8_t * new_key)
+int hash_key(int type, int mode, const uint8_t * key, unsigned int keylen, uint8_t * new_key)
 {
-
+	struct saesoc_session_init_params initp;
 	int fb_vc;
-	uint64_t entry0,entry1;
-	uint32_t size,code,src;
-        extern int ipsec_sync_vc;
-	uint64_t tx_id=0x12345678ULL;
-	uint64_t  timeout = 0;
-#ifdef CONFIG_32BIT
-	unsigned long msgrng_flags;
-#endif
+	int node ;
 	int node_sae_base;
-	int node;
-	char * tmp = kmalloc(keylen + sizeof(struct nlm_crypto_pkt_ctrl) + sizeof( struct nlm_crypto_pkt_param ) 
-											+ 128, GFP_KERNEL);
-	struct nlm_crypto_pkt_ctrl * ctrl = (struct nlm_crypto_pkt_ctrl * ) ((((unsigned long)tmp + 63)) & ~(0x3fUL)); 
-	struct nlm_crypto_pkt_param * pkt_param = (struct nlm_crypto_pkt_param * )
-		(((unsigned long) ctrl + sizeof(struct nlm_crypto_pkt_ctrl) + 63) & ~(0x3fUL));
-	char *tmp_key = (char *)(((unsigned long) pkt_param + 
-			sizeof(struct nlm_crypto_pkt_param ) + 63)  & ~(0x3fUL));
-
-	memcpy(tmp_key,key,keylen);
-        nlm_crypto_fill_pkt_ctrl(ctrl,0,alg,mode,0,0,0,NULL,0,NULL,0,0);
-        nlm_crypto_fill_auth_pkt_param(ctrl,pkt_param,0,keylen,0,new_key);
-        nlm_crypto_fill_src_dst_seg(pkt_param,0,MAX_FRAGS,tmp_key,keylen);
-
+	uint64_t entry0 = 0, entry1;
+	unsigned long msgrng_flags;
+	int src,size,code,timeout,nsdescs;
+	char * tmp;
+	struct saesoc_session_desc *s_desc;
+	struct saesoc_extra_req_send_params mparam;
+	struct saesoc_data_desc    *d_desc;
+    	extern int ipsec_sync_vc ;
+
+	initp.cipher.type = SAESOC_CIPHER_BYPASS;
+	initp.cipher.key_len = 0;
+	initp.cipher.iv_offset = 0;
+	initp.hash.type = type;
+	initp.hash.mode = mode;
+	initp.hash.iv_offset = 0;
+	initp.hash.iv_mode = 0;
+	initp.hash.key = NULL;
+	initp.hash.key_len = 0;
+	initp.hash.mute_mask_sel = 0;
+	initp.hash.tag_len = saesoc_gen1_tag_len[type]; 
+	initp.hash.tagin_offset = 0;
+	initp.hash.aad_offset =0;
+	initp.hash.addl_hash_len = 0;
+	initp.hash.flags = SAESOC_HF_HASH_L3_ALLOC;
+	initp.payload_offset = 0;
+	initp.flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
+
+	nsdescs = saesoc_calc_sdesc_cnt(&initp,NULL);
+	tmp = kmalloc(  sizeof(struct saesoc_session_desc) + (nsdescs * sizeof(_uint64_t))+ 64 + sizeof(struct saesoc_data_desc) + (6 * sizeof(_uint64_t) + 64 + keylen),GFP_KERNEL );
+	s_desc = (struct saesoc_session_desc *)(((unsigned long )tmp + 64UL ) &  ~(0x3fUL));
+	d_desc = (struct saesoc_data_desc    *)(((unsigned long )s_desc + sizeof(struct saesoc_session_desc) + (nsdescs * sizeof(_uint64_t)) + 64UL) & ~(0x3fUL));
+
+	if(saesoc_new_session(&initp,&s_desc,nsdescs, NULL) < 0) 
+		printk("%s,%d Error \n", __FUNCTION__, __LINE__);
+
+	if(saesoc_new_session(&initp,&s_desc,nsdescs, NULL) < 0)
+		printk("%s,%d Error \n", __FUNCTION__, __LINE__);
+
+	if(saesoc_new_data_desc(s_desc, &d_desc, 6,NULL) < 0) 
+		printk("%s,%d Error \n", __FUNCTION__, __LINE__);
+	saesoc_add_frags(d_desc, (char *)key,keylen,(char *)key,keylen);
+	saesoc_set_tag_dstaddr(d_desc,new_key);
+	saesoc_set_payload_len(d_desc, keylen); 
 
-#ifdef CONFIG_32BIT
 	msgrng_access_enable(msgrng_flags);
-#endif
         fb_vc = crypto_get_sync_fb_vc(&node);
-        entry0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, 0, virt_to_phys(ctrl));
-        entry1 = nlm_crypto_form_pkt_fmn_entry1(0, 0, (32 + 16 ), virt_to_phys(pkt_param));
-
-
-#ifdef NLM_CRYPTO_DEBUG
-       print_crypto_msg_desc(entry0, entry1, tx_id);
-       print_cntl_instr(ctrl->desc0);
-       print_pkt_desc(pkt_param,1);
-#endif
 
+	mparam.async_rsp_arg = 0xdeadbeef;
+	mparam.arc4_load_state = 0;
         //construct pkt, send to engine and receive reply
 	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
+	saesoc_process_request(NULL,d_desc,node_sae_base,fb_vc,0,9000,&mparam,NULL);
 
-	while (nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id) != 0 );
         timeout = 0;
         do {
                 timeout++;
-                nlm_hal_recv_msg2(ipsec_sync_vc, &src, &size, &code, &entry0, &entry1);
-        } while(entry0 != tx_id && timeout < 0xfffffUL) ;
+                xlp_message_receive_2(ipsec_sync_vc, &src, &size, &code, &entry0, &entry1);
+
+        } while(entry0 != 0xdeadbeef && timeout < 0xfffffUL) ;
 	kfree(tmp);
-#ifdef CONFIG_32BIT
 	msgrng_access_disable(msgrng_flags);
-#endif
 	return 0;
 
 	
 
 }
 
+static int auth_setkey(struct crypto_ahash *tfm, const u8 * key, unsigned int keylen, int blocksize,int type, int stat)
+{
+	struct nlm_auth_ctx * nlm_ctx = ctrl_desc_crypto_ahash_ctx(tfm);
+	struct saesoc_session_init_params * initp = &nlm_ctx->initp;
+	int nsdescs;
+	char * final_key = (char *)key;
+	int final_keylen = keylen;
+	struct saesoc_session_desc *s_desc = &nlm_ctx->s_desc;
+
+
+	nlm_ctx->stat = stat;
+	if ( keylen > blocksize ) {
+
+		hash_key(type,0,key,keylen,&nlm_ctx->hashed_key[0]);
+		crypto_ahash_setkey(nlm_ctx->fallback_tfm,nlm_ctx->hashed_key,64);
+		final_key = &nlm_ctx->hashed_key[0];
+		final_keylen = blocksize;
+	}
+	else
+		crypto_ahash_setkey(nlm_ctx->fallback_tfm,key,keylen);
+
+	if ( keylen == blocksize ) {
+		initp->hash.key = final_key;
+		initp->hash.key_len = final_keylen;
+	}
+	if( keylen < blocksize ) {
+		memset(&nlm_ctx->hashed_key[0],0,blocksize);
+		memcpy(&nlm_ctx->hashed_key[0],key,keylen);
+		initp->hash.key =&nlm_ctx->hashed_key[0];
+		initp->hash.key_len = blocksize ;
+	}
+
+	initp->cipher.type = SAESOC_CIPHER_BYPASS;
+	initp->cipher.key_len = 0;
+	initp->hash.type = type;
+	initp->hash.mode = 0;
+	initp->hash.iv_offset = 0;
+	initp->hash.mute_mask_sel = 0;
+	initp->hash.tag_len = saesoc_gen1_tag_len[type];
+	initp->hash.tagin_offset = 0;
+	initp->hash.aad_offset =0;
+	initp->hash.addl_hash_len = 0;
+	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC;
+	initp->payload_offset = 0;
+	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
+
+	nsdescs = saesoc_calc_sdesc_cnt(&nlm_ctx->initp,NULL);
+
+	if(  ((unsigned long)nlm_ctx + sizeof(struct saesoc_session_desc) + (nsdescs * sizeof(_uint64_t))) > (unsigned long)&nlm_ctx->initp) {
+		printk("MEMORY OVERFLOW\n"); 
+		return -1;
+	}
+
+
+	if(saesoc_new_session(&nlm_ctx->initp,&s_desc,nsdescs, NULL) < 0)
+		printk("%s,%d Error \n", __FUNCTION__, __LINE__);
+
+
+	nlm_ctx->stat = H_SHA1_STAT;
+
+	return 0;
+	 
+	
+}
+
+
+
 static int xlp_auth_aes_xcbc_setkey(struct crypto_ahash *tfm, const u8 * key, unsigned int keylen)
 {
 	struct nlm_auth_ctx * nlm_ctx = ctrl_desc_crypto_ahash_ctx(tfm);
-	uint32_t hash_alg = NLM_HASH_AES128;
+	uint32_t hash_alg = SAESOC_HASH_TYPE_AES_128;
+	struct saesoc_session_init_params * initp = &nlm_ctx->initp;
+	struct saesoc_session_desc *s_desc = &nlm_ctx->s_desc;
+	int nsdescs;
 
         switch (keylen) {
         case 16:
-                hash_alg = NLM_HASH_AES128;
+                hash_alg = SAESOC_HASH_TYPE_AES_128;
 		nlm_ctx->stat = AES128_XCBC_STAT;
                 break;
         case 24:
-                hash_alg = NLM_HASH_AES192;
+                hash_alg = SAESOC_HASH_TYPE_AES_192;
 		nlm_ctx->stat = AES192_XCBC_STAT;
                 break;
         case 32:
-                hash_alg = NLM_HASH_AES256;
+                hash_alg = SAESOC_HASH_TYPE_AES_256;
 		nlm_ctx->stat = AES256_XCBC_STAT;
                 break;
         default:
@@ -411,8 +445,28 @@ static int xlp_auth_aes_xcbc_setkey(struct crypto_ahash *tfm, const u8 * key, un
 	}
 
 	/*setup ctrl descriptor*/
-	nlm_crypto_fill_pkt_ctrl(&nlm_ctx->ctrl,0,hash_alg,NLM_HASH_MODE_XCBC,
-		NLM_CIPHER_BYPASS,NLM_CIPHER_MODE_ECB,0,NULL,0,(unsigned char *)key,keylen,0);
+
+	initp->hash.key = (char *)key;
+	initp->hash.key_len = keylen ;
+	initp->cipher.type = SAESOC_CIPHER_BYPASS;
+	initp->cipher.key_len = 0;
+	initp->hash.type = hash_alg;
+	initp->hash.mode = SAESOC_HASH_MODE_XCBC;
+	initp->hash.iv_offset = 0;
+	initp->hash.mute_mask_sel = 0;
+	initp->hash.tag_len = saesoc_gen1_tag_len[hash_alg];
+	initp->hash.tagin_offset = 0;
+	initp->hash.aad_offset =0;
+	initp->hash.addl_hash_len = 0;
+	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC;
+	initp->payload_offset = 0;
+	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
+
+	nsdescs = saesoc_calc_sdesc_cnt(&nlm_ctx->initp,NULL);
+
+	if(saesoc_new_session(&nlm_ctx->initp,&s_desc,nsdescs, NULL) < 0)
+		printk("%s,%d Error \n", __FUNCTION__, __LINE__);
+
 	
 	crypto_ahash_setkey(nlm_ctx->fallback_tfm,key,keylen);
 
@@ -423,180 +477,82 @@ static int xlp_auth_aes_xcbc_setkey(struct crypto_ahash *tfm, const u8 * key, un
 
 
 static int
-xlp_auth_hmac_sha256_setkey(struct crypto_ahash *tfm, const u8 * key, unsigned int keylen)
+xlp_auth_hmac_md5_setkey(struct crypto_ahash *tfm, const u8 * key, unsigned int keylen)
 {
-	struct nlm_auth_ctx * nlm_ctx = ctrl_desc_crypto_ahash_ctx(tfm);
-	struct nlm_crypto_pkt_ctrl * ctrl = &nlm_ctx->ctrl; 
-	
-	nlm_ctx->stat = H_SHA256_STAT;
-	if ( keylen > 64 ) {
-		hash_key(NLM_HASH_SHA,NLM_HASH_MODE_SHA256,key,keylen,&nlm_ctx->hashed_key[0]);
-		nlm_crypto_fill_pkt_ctrl(ctrl,1,NLM_HASH_SHA,NLM_HASH_MODE_SHA256,
-			NLM_CIPHER_BYPASS,NLM_CIPHER_MODE_ECB,0,NULL,0,(unsigned char*)nlm_ctx->hashed_key,64,0);
-		crypto_ahash_setkey(nlm_ctx->fallback_tfm,nlm_ctx->hashed_key,64);
-		return 0;
-	}
-
-	/*setup ctrl descriptor*/
-	nlm_crypto_fill_pkt_ctrl(ctrl,1,NLM_HASH_SHA,NLM_HASH_MODE_SHA256,
-		NLM_CIPHER_BYPASS,NLM_CIPHER_MODE_ECB,0,NULL,0,(unsigned char*)key,keylen,0);
-	if ( ctrl->hashkeylen < auth_mode_key_len[NLM_HASH_SHA][NLM_HASH_MODE_SHA256]) 
-		ctrl->hashkeylen = auth_mode_key_len[NLM_HASH_SHA][NLM_HASH_MODE_SHA256];
-	crypto_ahash_setkey(nlm_ctx->fallback_tfm,key,keylen);
-	return 0;
-	
+	return auth_setkey(tfm,key,keylen,MD5_BLOCK_SIZE,SAESOC_HASH_TYPE_MD5,MD5_STAT);
 }
-
-
 static int
-xlp_auth_hmac_md5_setkey(struct crypto_ahash *tfm, const u8 * key, unsigned int keylen)
+xlp_auth_hmac_sha256_setkey(struct crypto_ahash *tfm, const u8 * key, unsigned int keylen)
 {
-	struct nlm_auth_ctx * nlm_ctx = ctrl_desc_crypto_ahash_ctx(tfm);
-	struct nlm_crypto_pkt_ctrl * ctrl = &nlm_ctx->ctrl; 
-
-	nlm_ctx->stat = MD5_STAT;
-	if ( keylen > 64 ) {
-		hash_key(NLM_HASH_MD5,NLM_HASH_MODE_SHA1,key,keylen,&nlm_ctx->hashed_key[0]);
-		nlm_crypto_fill_pkt_ctrl(ctrl,1,NLM_HASH_MD5,NLM_HASH_MODE_SHA1,
-			NLM_CIPHER_BYPASS,NLM_CIPHER_MODE_ECB,0,NULL,0,(unsigned char *)nlm_ctx->hashed_key,64,0);
-		crypto_ahash_setkey(nlm_ctx->fallback_tfm,nlm_ctx->hashed_key,64);
-		return 0;
-	}
-
-	/*setup ctrl descriptor*/
-	nlm_crypto_fill_pkt_ctrl(ctrl,1,NLM_HASH_MD5,NLM_HASH_MODE_SHA1,
-		NLM_CIPHER_BYPASS,NLM_CIPHER_MODE_ECB,0,NULL,0,(unsigned char *)key,keylen,0);
-	if ( ctrl->hashkeylen < auth_mode_key_len[NLM_HASH_MD5][NLM_HASH_MODE_SHA1]) 
-		ctrl->hashkeylen = auth_mode_key_len[NLM_HASH_MD5][NLM_HASH_MODE_SHA1];
-	crypto_ahash_setkey(nlm_ctx->fallback_tfm,key,keylen);
-	return 0;
-	
+	return auth_setkey(tfm,key,keylen,SHA256_BLOCK_SIZE,SAESOC_HASH_TYPE_SHA_256,H_SHA256_STAT);
 }
 
 static int
 xlp_auth_hmac_sha1_setkey(struct crypto_ahash *tfm, const u8 * key, unsigned int keylen)
 {
-	struct nlm_auth_ctx * nlm_ctx = ctrl_desc_crypto_ahash_ctx(tfm);
-	struct nlm_crypto_pkt_ctrl * ctrl = &nlm_ctx->ctrl; 
-
-	nlm_ctx->stat = H_SHA1_STAT;
-	if ( keylen > 64 ) {
-
-		hash_key(NLM_HASH_SHA,NLM_HASH_MODE_SHA1,key,keylen,&nlm_ctx->hashed_key[0]);
-		nlm_crypto_fill_pkt_ctrl(ctrl,1,NLM_HASH_SHA,NLM_HASH_MODE_SHA1,
-			NLM_CIPHER_BYPASS,NLM_CIPHER_MODE_ECB,0,NULL,0,(unsigned char *)nlm_ctx->hashed_key,64,0);
-		crypto_ahash_setkey(nlm_ctx->fallback_tfm,nlm_ctx->hashed_key,64);
-		return 0;
-	}
-
-	/*setup ctrl descriptor*/
-	nlm_crypto_fill_pkt_ctrl(ctrl,1,NLM_HASH_SHA,NLM_HASH_MODE_SHA1,
-		NLM_CIPHER_BYPASS,NLM_CIPHER_MODE_ECB,0,NULL,0,(unsigned char *)key,keylen,0);
-	if ( ctrl->hashkeylen < auth_mode_key_len[NLM_HASH_SHA][NLM_HASH_MODE_SHA1]) 
-		ctrl->hashkeylen = auth_mode_key_len[NLM_HASH_SHA][NLM_HASH_MODE_SHA1];
-	crypto_ahash_setkey(nlm_ctx->fallback_tfm,key,keylen);
-	return 0;
-	 
-	
+	return auth_setkey(tfm,key,keylen,SHA1_BLOCK_SIZE,SAESOC_HASH_TYPE_SHA_1,H_SHA1_STAT);
 }
+
 static int xlp_auth_digest(struct ahash_request *areq)
 {
-	unsigned int auth_len;
+	struct saesoc_data_desc    *d_desc = (struct saesoc_data_desc    *)NLM_CRYPTO_DATA_DESC(ahash_request_ctx(areq));
+	struct app_data_priv * d_priv = (struct app_data_priv *)((unsigned long)d_desc + sizeof(struct saesoc_data_desc)+(MAX_FRAGS*16)) ;
 	int fb_vc ;
+	unsigned long msgrng_flags;
 	int node_sae_base;
 	int node;
-	int err;
-	uint64_t entry0, entry1;
-	int max_frags = MAX_FRAGS;
-	int index = 0;
-	uint64_t tx_id=0x12345678ULL;
-	struct nlm_crypto_pkt_param  *pkt_param  = NULL;
-	struct auth_pkt_desc *auth_pkt_desc = pkt_desc_req_ctx(areq);
+	struct nlm_async_crypto * async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET((unsigned long)d_desc);
+	struct saesoc_extra_req_send_params mparam;
 	struct nlm_auth_ctx  * auth_ctx   = ctrl_desc_req_ahash_ctx(areq);	
-	struct nlm_crypto_pkt_ctrl *ctrl = &auth_ctx->ctrl;
-	struct nlm_async_crypto * async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET((unsigned long)auth_pkt_desc);;
-
-	auth_pkt_desc->max_frags = MAX_FRAGS;
+	struct saesoc_session_desc *s_desc = &auth_ctx->s_desc;
+	unsigned int nfrags = MAX_FRAGS;
 
 	if ( areq->nbytes == 0 )  { 
 
-		auth_pkt_desc->fallback_req = ahash_request_alloc(auth_ctx->fallback_tfm,GFP_KERNEL);
-		auth_pkt_desc->fallback_req->nbytes = areq->nbytes;
-		auth_pkt_desc->fallback_req->src = areq->src;
-		auth_pkt_desc->fallback_req->result = areq->result;
-		auth_pkt_desc->fallback_req->base.flags =  areq->base.flags;
+
+		d_priv->fallback_req = ahash_request_alloc(auth_ctx->fallback_tfm,GFP_KERNEL);
+		d_priv->fallback_req->nbytes = areq->nbytes;
+		d_priv->fallback_req->src = areq->src;
+		d_priv->fallback_req->result = areq->result;
+		d_priv->fallback_req->base.flags =  areq->base.flags;
 		
-		crypto_ahash_init(auth_pkt_desc->fallback_req);
-		crypto_ahash_final(auth_pkt_desc->fallback_req);
-		kfree(auth_pkt_desc->fallback_req);
-		auth_pkt_desc->fallback_req = NULL;
+		crypto_ahash_init(d_priv->fallback_req);
+		crypto_ahash_final(d_priv->fallback_req);
+		kfree(d_priv->fallback_req);
+		d_priv->fallback_req = NULL;
 		return 0;
 	}
-
-	async->stat = 0;
-	auth_pkt_desc->pkt_param = ( struct nlm_crypto_pkt_param  * )NLM_CRYPTO_PKT_PARAM_OFFSET((unsigned long )auth_pkt_desc + sizeof(struct auth_pkt_desc ));
-	pkt_param  = auth_pkt_desc->pkt_param;
+	saesoc_new_data_desc(&auth_ctx->s_desc, &d_desc, MAX_FRAGS , NULL);
 	async->pkt_param = NULL;
 
-	do {
-		auth_len = areq->nbytes;
-		index = fill_src_dst_sg(areq->src,areq->src,auth_len,pkt_param,index,max_frags,0);
-
-		if ( index > max_frags ) {
-			max_frags = index;
-			index = alloc_pkt_param(async,&pkt_param,max_frags);
-			index = 0;
-		}
-	}while(index == 0 );
-
-	auth_pkt_desc->max_frags = max_frags;
-
-#ifdef CONFIG_32BIT
-	unsigned long msgrng_flags;
-#endif
-		
-	nlm_crypto_fill_auth_pkt_param(ctrl,pkt_param,
-			0,areq->nbytes,0,areq->result); 
-
-
-	fb_vc = crypto_get_fb_vc(&node);
-	entry0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, 0, virt_to_phys(ctrl));
-	entry1 = nlm_crypto_form_pkt_fmn_entry1(0, ctrl->hashkeylen, (32 + index * 16 ), virt_to_phys(pkt_param));
-
+	d_desc= fill_src_dst_sg(s_desc,d_desc,async,areq->src,areq->src,&nfrags,areq->nbytes);
+	saesoc_set_payload_len(d_desc,areq->nbytes);
+	saesoc_set_tag_dstaddr(d_desc,areq->result);
 
+	preempt_disable();
 	async->callback =  auth_request_callback;
 	async->args = (void *)&areq->base; 
 	async->hash_addr = areq->result;
 	async->stat = auth_ctx->stat; 
-	async->bytes = areq->nbytes + ctrl->taglen; 
-	tx_id = (uint64_t)(unsigned long)async;
-
-
-#ifdef NLM_CRYPTO_DEBUG
-	print_crypto_msg_desc(entry0, entry1, tx_id);
-	print_cntl_instr(ctrl->desc0);
-	hex_dump("key",ctrl->key,16);
-	print_pkt_desc(pkt_param,index);
-#endif
+	async->bytes = areq->nbytes ; 
 
+	mparam.async_rsp_arg = (uint64_t)async;
+	mparam.arc4_load_state = 0;
 
-#ifdef CONFIG_32BIT
 	msgrng_access_enable(msgrng_flags);
-#endif
+	fb_vc = crypto_get_fb_vc(&node);
 	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
-	err = nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id);
-#ifdef CONFIG_32BIT
-	msgrng_access_disable(msgrng_flags);
-#endif
-	if(err){
-		printk("failed\n");
-		return -EAGAIN;
+	if ( saesoc_process_request(NULL,d_desc,node_sae_base,fb_vc,0,1,&mparam,NULL) !=  CRYPTOSOC_OK ) {
+		msgrng_access_disable(msgrng_flags);
+		preempt_enable();
+		return -EAGAIN; 
 	}
+	msgrng_access_disable(msgrng_flags);
+	preempt_enable();
 
  	return -EINPROGRESS;
 }
 
-
 static struct ahash_alg xcbc_mac_alg = {
 	.init = xlp_auth_init,
 	.update = xlp_auth_update,
diff --git a/drivers/crypto/sae/nlm_crypto.c b/drivers/crypto/sae/nlm_crypto.c
index f66777b..ea0c711 100644
--- a/drivers/crypto/sae/nlm_crypto.c
+++ b/drivers/crypto/sae/nlm_crypto.c
@@ -11,19 +11,19 @@
  * License (GPL) Version 2, available from the file 
  * http://www.gnu.org/licenses/gpl-2.0.txt
  */
-#include <asm/netlogic/xlp.h>
-#include <asm/netlogic/msgring.h>
 #include <linux/proc_fs.h>
-#include <asm/netlogic/proc.h>
-
-#include <asm/netlogic/hal/nlm_hal_fmn.h>
-#include <asm/netlogic/hal/nlm_hal_macros.h>
-#include <asm/netlogic/hal/nlm_hal_xlp_dev.h>
-#include <asm/netlogic/hal/nlm_hal.h>
+#include <nlm_hal_fmn.h>
+#include <nlm_hal_macros.h>
+#include <linux/module.h>
+#include <nlm_hal.h>
+#include <nlm_xlp.h>
 #include <linux/crypto.h>
+#include <nlm_msgring.h>
+#include "saesoc_lib.h"
 #include "nlm_async.h"
 
 
+
 #ifdef TRACING
 #define TRACE_TEXT(str) printk(str);
 #define TRACE_RET printk(")")
@@ -34,6 +34,20 @@
 #undef NLM_CRYPTO_DEBUG
 #define NETL_OP_ENCRYPT 1
 #define NETL_OP_DECRYPT 0
+int cryptosoc_lib_priv_init(void)
+{
+	return 0;
+}
+int cryptosoc_lib_priv_finish(void){
+	return 0;
+}
+int crypto_get_soc_vc_numbers(enum cryptosoc_soc_type soc, int *base_vc, int *lmt_vc)
+{
+	*base_vc = 276;
+	*lmt_vc = 279;
+	return 0;
+}
+
 
 
 /**
@@ -45,7 +59,6 @@
 
 #define xtract_bits(x, bitpos, numofbits) ((x) >> (bitpos) & ((1ULL << (numofbits)) - 1))
 
-
 extern struct proc_dir_entry *nlm_root_proc;
 extern int xlp_aead_alg_init(void);
 extern void xlp_aead_alg_fini(void);
@@ -53,7 +66,7 @@ extern int xlp_crypt_alg_init(void);
 extern void xlp_crypt_alg_fini(void);
 extern int xlp_auth_alg_init(void);
 extern void xlp_auth_alg_fini(void);
-static void xlp_sae_cleanup(void);
+static void  xlp_sae_cleanup(void);
 
 static int xlp_sae_major;
 static int xlp_sae_open(struct inode *, struct file *);
@@ -64,322 +77,21 @@ int crypto_vc_base;
 int crypto_vc_limit;
 int nlm_crypto_chip_features = 0 ;
 
-
-
-/*
- * is the following table needed for all modes?
-Cipher            keylen           iv_len
-*/
-
-//-1 indicates variable length IV
-// In case of AES/Camelia cipher and CBC-MAC auth, IV is not needed.
-// In case of AES/Camelia cipher and XCBC-MAC auth, IV is needed only for 
-//CBC, CFB, OFB and CTR modes..
-int cipher_mode_iv_len[NLM_CIPHER_MAX][NLM_CIPHER_MODE_MAX] = {
-/*		       ECB  CBC   CFB   OFB   CTR  AESF8    GCM  CCM    8   9  LRW   XTS */
-/* BYPASS */       {   0,    0,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
-/* DES */          {   0,    8,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
-/* 3DES */         {   0,    8,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
-/* AES128 */       {   0,    16,   16,   16,   8,   16,     8,   8,   0,  0,  16,   16,},
-/* AES192 */       {   0,    16,   16,   16,   8,   16,     8,   8,   0,  0,  16,   16,},
-/* AES256 */       {   0,    16,   16,   16,   8,   16,     8,   8,   0,  0,  16,   16,},
-/* ARC4 */         {   0,    0,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
-/* KASUMI F8 */    {   0,    0,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
-/* SNOW3G F8 */    {   0,    0,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
-/* CAMELLIA128 */  {   0,    16,   16,   16,   16,   16,     -1,   0,   0,  0,  16,   16,},
-/* CAMELLIA192 */  {   0,    16,   16,   16,   16,   16,     -1,   0,   0,  0,  16,   16,}, 
-/* CAMELLIA256 */  {   0,    16,   16,   16,   16,   16      -1,   0,   0,  0,  16,   16,},
-};
-
 #define NLM_CRYPTO_MAX_STR_LEN 200
-#ifdef NLM_CRYPTO_DEBUG
-static char str_cipher_alg[NLM_CIPHER_MAX + 1][NLM_CRYPTO_MAX_STR_LEN] = {
-"bypass",       // NLM_CIPHER_BYPASS
-"des",          // NLM_CIPHER_DES
-"3des",         // NLM_CIPHER_3DES
-"aes 128",      // NLM_CIPHER_AES128
-"aes 192",      // NLM_CIPHER_AES192
-"aes 256",      // NLM_CIPHER_AES256
-"arc4",         // NLM_CIPHER_ARC4
-"Kasumi f8",    // NLM_CIPHER_KASUMI_F8
-"snow3g f8",    // NLM_CIPHER_SNOW3G_F8
-"camellia 128", // NLM_CIPHER_CAMELLIA128
-"camelia 192",  // NLM_CIPHER_CAMELLIA192
-"camelia 256",  // NLM_CIPHER_CAMELLIA256
-"undefined",  // > max
-};
-static char str_cipher_mode[NLM_CIPHER_MODE_MAX+ 1][NLM_CRYPTO_MAX_STR_LEN] = {
-"ecb",          // NLM_CIPHER_MODE_ECB
-"cbc",          // NLM_CIPHER_MODE_CBC
-"cfb",          // NLM_CIPHER_MODE_CFB
-"ofb",          // NLM_CIPHER_MODE_OFB
-"ctr",          // NLM_CIPHER_MODE_CTR
-"aes f8",       // NLM_CIPHER_MODE_AES_F8
-"gcm",          // NLM_CIPHER_MODE_GCM
-"ccm",          // NLM_CIPHER_MODE_CCM
-"undefined",    // NLM_CIPHER_MODE_UNDEFINED1
-"undefined",    // NLM_CIPHER_MODE_UNDEFINED2
-"lrw",          // NLM_CIPHER_MODE_LRW
-"xts",          // NLM_CIPHER_MODE_XTS
-"undefined", // > max
-};
-static char str_auth_alg[NLM_HASH_MAX + 1][NLM_CRYPTO_MAX_STR_LEN] = {
-"bypass",       // NLM_AUTH_BYPASS
-"md5",          // NLM_AUTH_MD5
-"sha",          // NLM_AUTH_SHA
-"invalid",       // NLM_AUTH_UNDEFINED
-"aes 128",      // NLM_AUTH_AES128
-"aes 192",      // NLM_AUTH_AES192
-"aes 256",      // NLM_AUTH_AES256
-"kasumi f9",    // NLM_AUTH_KASUMI_F9
-"snow3g f9",    // NLM_AUTH_SNOW3G_F9
-"camellia 128", // NLM_AUTH_CAMELLIA128
-"camellia 192", // NLM_AUTH_CAMELLIA192
-"camellia 256", // NLM_AUTH_CAMELLIA256
-"ghash",        // NLM_AUTH_GHASH
-"undefined",    // > max
-};
-static char str_auth_mode[NLM_HASH_MODE_MAX + 1][NLM_CRYPTO_MAX_STR_LEN] = {
-"sha1",         // NLM_AUTH_MODE_SHA1
-"sha 224",      // NLM_AUTH_MODE_SHA224
-"sha 256",      // NLM_AUTH_MODE_SHA256
-"sha 384",      // NLM_AUTH_MODE_SHA384
-"sha 512",      // NLM_AUTH_MODE_SHA512
-"cmac",         // NLM_AUTH_MODE_CMAC
-"xcbc",         // NLM_AUTH_MODE_XCBC
-"cbc mac",      // NLM_AUTH_MODE_CBC_MAC
-"undefined", // > max
-};
-void hex_dump(char * description,unsigned char *in, int num)
-{
-        int i, j;
-        char buf[50];
-        char *buf_ptr;
-        printk("%s\n",description);
-
-        for (i = 0; i < num; i+= 16) {
-                if (i + 16 > num) {
-                        buf_ptr = buf;
-                        sprintf(buf_ptr, "    ");
-                        buf_ptr += 4;
-                        for (j = 0 ; j < num - i ; j++) {
-                                sprintf(buf_ptr, "%02x ", in[j + i]);
-                                buf_ptr += 3;
-                        }
-                        *buf_ptr = '\0';
-                        printk("%s\n",buf);
-                        break;
-                }
-                printk("    %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
-                        in[i + 0 ],
-                        in[i + 1 ],
-                        in[i + 2 ],
-                        in[i + 3 ],
-                        in[i + 4 ],
-                        in[i + 5 ],
-                        in[i + 6 ],
-                        in[i + 7 ],
-                        in[i + 8 ],
-                        in[i + 9 ],
-                        in[i + 10],
-                        in[i + 11],
-                        in[i + 12],
-                        in[i + 13],
-                        in[i + 14],
-                        in[i + 15]
-              );
-        }
-}
 
-char *nlm_crypto_cipher_alg_get_name(unsigned int cipher_alg)
+int alloc_data_desc( struct nlm_async_crypto * async,struct saesoc_data_desc  ** d_desc,struct saesoc_session_desc *s_desc, int max_frags)
 {
-	if (cipher_alg >= NLM_CIPHER_MAX)
-		return str_cipher_alg[NLM_CIPHER_MAX];
-	else 
-		return str_cipher_alg[cipher_alg];
-}
+	uint8_t * new_data_desc = NULL;
 
-char *nlm_crypto_cipher_mode_get_name(unsigned int cipher_mode)
-{
-	if (cipher_mode >= NLM_CIPHER_MODE_MAX)
-		return str_cipher_mode[NLM_CIPHER_MODE_MAX];
-	else 
-		return str_cipher_mode[cipher_mode];
-}
-
-char *nlm_crypto_auth_alg_get_name(unsigned int auth_alg)
-{
-	if (auth_alg >= NLM_HASH_MAX)
-		return str_auth_alg[NLM_HASH_MAX];
-	else 
-		return str_auth_alg[auth_alg];
-}
-
-char *nlm_crypto_auth_mode_get_name(unsigned int auth_mode)
-{
-	if (auth_mode >= NLM_HASH_MODE_MAX)
-		return str_auth_mode[NLM_HASH_MODE_MAX];
-	else 
-		return str_auth_mode[auth_mode];
-}
-
-void print_crypto_msg_desc(uint64_t entry1, uint64_t entry2, uint64_t entry3)
-{
-        printk("Security Message Descriptor 0: 0x%llx\n", entry1);
-        printk("Security Message Descriptor 1: 0x%llx\n", entry2);
-        printk("Security Message Descriptor 2: 0x%llx\n", entry3);
-
-
-        printk("Free descriptor response destination : 0x%llx  \n", xtract_bits(entry1, 48, 16));
-        printk("Use designer freeback : 0x%llx  \n", xtract_bits(entry1, 45, 1));
-        printk("cipher key length (in dwords) : 0x%llx  \n", xtract_bits(entry1, 40, 5));
-        printf("Control desc cacheline addr : 0x%llx  \n", xtract_bits(entry1, 0, 34));
-        if (xtract_bits(entry1, 45, 1)) {
-                printf("Designer freeback length (actual len - 1): 0x%llx  \n", xtract_bits(entry1, 46, 2));
-        }
-
-
-        printf("Arc4 load state : 0x%llx  \n", xtract_bits(entry2, 63, 1));
-        printf("Hash key length (in dwords) : 0x%llx  \n", xtract_bits(entry2, 56, 5));
-        printf("Pkt desc length (in multiple of 16 bytes - 1): 0x%llx  \n", xtract_bits(entry2, 43, 12));
-        printf("Pkt desc cacheline addr : 0x%llx  \n", xtract_bits(entry2, 0, 34));
-
-        printf("Software Scratch Pad : 0x%llx  \n", xtract_bits(entry3, 0, 34));
-}
-void print_cntl_instr(uint64_t cntl_desc)
-{
-	unsigned int tmp;
-	char *x;
-	char s[NLM_CRYPTO_MAX_STR_LEN];
-	cntl_desc = ccpu_to_be64(cntl_desc);
-
-	printf("control description: 0x%016llx\n", (unsigned long long)cntl_desc);
-	printf("HMac = 0x%llx  \n", xtract_bits(cntl_desc, 61, 1));
-//	printk("Pad Hash = 0x%llx  \n", xtract_bits(cntl_desc, 62, 1));
-	/* Check cipher, hash type and mode b4 printing */
-	tmp = xtract_bits(cntl_desc, 52, 8);
-	x = nlm_crypto_auth_alg_get_name(tmp);
-	strncpy(s, x, NLM_CRYPTO_MAX_STR_LEN);
-	printf("Hash Type = 0x%llx(%s)  \n", xtract_bits(cntl_desc, 52, 8), s);
-	tmp = xtract_bits(cntl_desc, 43, 8);
-	x = nlm_crypto_auth_mode_get_name(tmp);
-	strncpy(s, x, NLM_CRYPTO_MAX_STR_LEN);
-	printf("Hash Mode = 0x%llx(%s)  \n", xtract_bits(cntl_desc, 43, 8), s);
-	tmp = xtract_bits(cntl_desc, 34, 8);
-	x = nlm_crypto_cipher_alg_get_name(tmp);
-	strncpy(s, x, NLM_CRYPTO_MAX_STR_LEN);
-	printf("Cipher Type = 0x%llx(%s)  \n", xtract_bits(cntl_desc, 34, 8), s);
-	tmp = xtract_bits(cntl_desc, 25, 8);
-	x = nlm_crypto_cipher_mode_get_name(tmp);
-	strncpy(s, x, NLM_CRYPTO_MAX_STR_LEN);
-	printf("Cipher Mode = 0x%llx(%s)  \n", xtract_bits(cntl_desc, 25, 8), s);
-
-
-	if (xtract_bits(cntl_desc, 34, 8) == NLM_CIPHER_ARC4) {
-		printf("Arc4 cipher key byte count= 0x%llx  \n", xtract_bits(cntl_desc, 18, 5));
-		printf("Arc4 key init = 0x%llx  \n", xtract_bits(cntl_desc, 17, 1));
+	if ( async->pkt_param ) {
+		kfree(async->pkt_param);
 	}
 
-}
-struct pkt_desc_src_dst {
-	uint64_t pkt_desc4;
-	uint64_t pkt_desc5;
-};
+	async->pkt_param = kmalloc((sizeof (struct saesoc_data_desc) + ( max_frags * 8 )+ 64),GFP_KERNEL);
 
-struct designer_desc{
-	uint64_t desc0;
-	uint64_t desc1;
-	uint64_t desc2;
-	uint64_t desc3;
-};
+	new_data_desc = (uint8_t * )(((unsigned long)async->pkt_param + 64) & ~0x3fUL);
 
-
-void print_pkt_desc(struct nlm_crypto_pkt_param  *pkt_desc1, int index)
-{
-	int i;
-	unsigned long  phys;
-	void * virt;
-	
-	struct nlm_crypto_pkt_param * pkt_desc = kmalloc(sizeof(struct nlm_crypto_pkt_param) + 256 ,GFP_KERNEL);;
-	pkt_desc->desc0 = ccpu_to_be64(pkt_desc1->desc0); 
-	pkt_desc->desc1 = ccpu_to_be64(pkt_desc1->desc1); 
-	pkt_desc->desc2 = ccpu_to_be64(pkt_desc1->desc2); 
-	pkt_desc->desc3 = ccpu_to_be64(pkt_desc1->desc3); 
-	
-
-	printf("Packet desc address = %p\n",pkt_desc);
-	printf("Packet Descriptor 0: 0x%016llx\n", (unsigned long long)pkt_desc->desc0);
-	printf("Packet Descriptor 1: 0x%016llx\n", (unsigned long long)pkt_desc->desc1);
-	printf("Packet Descriptor 2: 0x%016llx\n", (unsigned long long)pkt_desc->desc2);
-	printf("Packet Descriptor 3: 0x%016llx\n", (unsigned long long)pkt_desc->desc3);
-
-	printf("\nPacket Descriptor 0\n");
-	printf("TLS protocol = 0x%llx  \n", xtract_bits(pkt_desc->desc0, 63, 1));
-	printf("Hash source(0-plain, 1-encrypted text) = 0x%llx  \n", xtract_bits(pkt_desc->desc0, 62, 1));
-	printf("Hash output l3 alloc = 0x%llx  \n", xtract_bits(pkt_desc->desc0, 60, 1));
-	printf("Encrypt(1)/Decrypt(0)= 0x%llx  \n", xtract_bits(pkt_desc->desc0, 59, 1));
-	printf("IV length = 0x%llx  \n", xtract_bits(pkt_desc->desc0, 41, 16));
-	printf("Hash Dest addr = 0x%llx \n", xtract_bits(pkt_desc->desc0, 0, 39));
-
-	printf("\nPacket Descriptor 1\n");
-	printf("Cipher length = 0x%llx \n", xtract_bits(pkt_desc->desc1, 32, 32));
-	printf("Hash length = 0x%llx  \n", xtract_bits(pkt_desc->desc1, 0, 32));
-	printf("IV Offset = 0x%llx  \n", xtract_bits(pkt_desc->desc2, 45, 17));
-
-	printf("\nPacket Descriptor 2\n");
-	printf("Cipher bit count = 0x%llx  \n", xtract_bits(pkt_desc->desc2, 42, 3));
-	printf("Cipher Offset = 0x%llx  \n", xtract_bits(pkt_desc->desc2, 22, 16));
-	printf("Hash bit count = 0x%llx  \n", xtract_bits(pkt_desc->desc2, 19, 3));
-	printf("Hash clobber = 0x%llx  \n", xtract_bits(pkt_desc->desc2, 18, 1));
-	printf("Hash Offset = 0x%llx  \n", xtract_bits(pkt_desc->desc2, 0, 16));
-
-
-	printf("\nPacket Descriptor 3\n");
-	printf("designer fb dest id = 0x%llx  \n", xtract_bits(pkt_desc->desc3, 48, 16));
-	printf("tag length = 0x%llx  \n", xtract_bits(pkt_desc->desc3, 11, 16));
-
-	printf("arc4 sbox l3 alloc = 0x%llx  \n", xtract_bits(pkt_desc->desc3, 8, 1));
-	printf("arc4 save box = 0x%llx  \n", xtract_bits(pkt_desc->desc3, 6, 1));
-	printf("hmac ext pad key = 0x%llx  \n", xtract_bits(pkt_desc->desc3, 5, 1));
-	int len;
-
-        for (i=0; i < index; i++) {
-		pkt_desc->segment[i][0] = ccpu_to_be64(pkt_desc1->segment[i][0]); 
-		pkt_desc->segment[i][1] = ccpu_to_be64(pkt_desc1->segment[i][1]);
-		printf("Packet Descriptor frag src %d: 0x%016llx\n", i, (unsigned long long)pkt_desc->segment[i][0]);
-		printf("Packet Descriptor frag dst %d: 0x%016llx\n", i, (unsigned long long)pkt_desc->segment[i][1]);
-
-		phys = xtract_bits(pkt_desc->segment[i][0], 0,40);
-		virt = phys_to_virt(phys);
-		len = xtract_bits(pkt_desc->segment[i][0], 48, 16); 
-		len = (len > 64 ) ? 64 : len;
-		hex_dump("src",virt,len);
-
-
-                printf("frag src length = 0x%llx  \n", xtract_bits(pkt_desc->segment[i][0], 48, 16));
-                printf("frag src = 0x%llx \n", xtract_bits(pkt_desc->segment[i][0], 0, 40));
-
-                printf("frag dest length = 0x%llx \n", xtract_bits(pkt_desc->segment[i][1], 48, 16));
-                printf("cipher output l3 alloc = 0x%llx \n", xtract_bits(pkt_desc->segment[i][1], 46, 1));
-                printf("cipher output write clobber = 0x%llx \n", xtract_bits(pkt_desc->segment[i][1], 41, 1));
-                printf("frag dest = 0x%llx \n", xtract_bits(pkt_desc->segment[i][1], 0, 40));
-        }
-}
-#endif
-
-int alloc_pkt_param( struct nlm_async_crypto * async,struct nlm_crypto_pkt_param ** pkt_param , int max_frags)
-{
-	uint8_t * new_pkt_param = NULL;
-	async->pkt_param = kmalloc((sizeof (struct nlm_crypto_pkt_param) +( max_frags * 2 * 8 )+ 64),GFP_KERNEL);
-
-	if ( !async->pkt_param) {
-		return -1;
-	}
-
-	new_pkt_param = (uint8_t * )(((unsigned long)async->pkt_param + 64) & ~0x3fUL);
-
-	memcpy(new_pkt_param,*pkt_param,sizeof(struct nlm_crypto_pkt_param));
-	*pkt_param = (struct nlm_crypto_pkt_param *)new_pkt_param;
+	*d_desc = (struct saesoc_data_desc  *)new_data_desc;
 
 	
 	return 1;
@@ -387,7 +99,7 @@ int alloc_pkt_param( struct nlm_async_crypto * async,struct nlm_crypto_pkt_param
 
 int nlm_crypto_sae_num_seg_reqd(void *data, unsigned int buflen)
 {
-	return nlm_crypto_num_segs_reqd(buflen);
+	return saesoc_calc_frags_desc_cnt(NULL,data,buflen,data,buflen);
 }
 
 int nlm_crypto_calc_rem_len(struct scatterlist *sg, unsigned int cipher_len)
@@ -395,89 +107,79 @@ int nlm_crypto_calc_rem_len(struct scatterlist *sg, unsigned int cipher_len)
 	int len,seg = 0;
 	for (;cipher_len > 0;sg = scatterwalk_sg_next(sg)){
 		len = min(cipher_len, sg->length);
-		seg += nlm_crypto_sae_num_seg_reqd(NULL,len);
+		seg += nlm_crypto_sae_num_seg_reqd(sg,len);
 		cipher_len -= len;
 	}
 	return seg;
 }
 
-int fill_src_dst_sg(struct scatterlist *src_sg, struct scatterlist *dst_sg, unsigned int cipher_len, 
-		struct nlm_crypto_pkt_param *param, 
-		int seg, unsigned int max_frags, int op)
+struct saesoc_data_desc  *  fill_src_dst_sg(struct saesoc_session_desc *s_desc,
+		struct saesoc_data_desc    *d_desc ,struct nlm_async_crypto *async, 
+		struct scatterlist *src_sg,         struct scatterlist * dst_sg,
+		unsigned int * nfrags, unsigned int cipher_len)
 {
-	struct scatterlist *sg;
-	struct scatter_walk walk;
-	unsigned int len = 0;
-	uint8_t *virt = NULL;
+	struct scatterlist *sg, *sg_s,*sg_d;
+	unsigned int len;
+	uint8_t *virt = NULL, *src, *dst;
 	int rv = 0;
-	int i;
+	unsigned long dest_paddr, src_paddr;
+	struct scatter_walk walk;
+	unsigned int max_frags = *nfrags;
+	
 
 	if (src_sg == dst_sg ) {
 		for( sg = src_sg; sg != NULL ; sg = scatterwalk_sg_next(sg)) {
 			len = min(cipher_len, sg->length);
 			scatterwalk_start(&walk, sg);
-			virt = page_address(scatterwalk_page(&walk)) + offset_in_page(walk.offset);
+			src_paddr = page_to_phys(scatterwalk_page(&walk)) + offset_in_page(walk.offset);
+			virt = phys_to_virt(src_paddr);
 			if ( cipher_len > 0 ) {
-				rv = nlm_crypto_fill_src_dst_seg(param, seg, max_frags, virt, len);
-				if ( rv < seg ) {
-					return nlm_crypto_calc_rem_len(sg,cipher_len) + max_frags; 
+				struct saesoc_data_desc * ddesc_new;
+				rv = saesoc_add_frags(d_desc,virt,len,virt,len);
+				if ( rv != CRYPTOSOC_OK ) {
+					rv = nlm_crypto_calc_rem_len(sg,cipher_len);
+				        rv = rv + max_frags + 4 + 2 /* ccm extra cipher len */; 
+					alloc_data_desc(async,&ddesc_new, s_desc,rv);
+					* nfrags = rv + max_frags;
+					saesoc_copy_ddesc(d_desc,&ddesc_new,rv,NULL);
+					d_desc = ddesc_new;
+					saesoc_add_frags(d_desc,virt,len,virt,len);
+
 				}
-				else
-					seg = rv;
 			}
 			cipher_len -= len;
 		}
-		return seg;
+		return d_desc;
 	}
-	else {
-		int nr_src_frags = 0;
-		int nr_dst_frags = 0;
-		int index = seg;
-		int nbytes = cipher_len;
-		for (sg = src_sg,seg;cipher_len > 0; sg = scatterwalk_sg_next(sg)) {
-			len = min(cipher_len, sg->length);
-			scatterwalk_start(&walk, sg);
-			virt = page_address(scatterwalk_page(&walk)) + offset_in_page(walk.offset);
-			rv = nlm_crypto_fill_src_seg(param,seg,max_frags,virt,len);
-			if ( rv <= seg )
-				return nlm_crypto_calc_rem_len(sg,cipher_len) + max_frags;
-			else
-				seg = rv;
-			cipher_len -= len;
-		}
-		nr_src_frags = seg;
-		cipher_len = nbytes;
-		for (sg = dst_sg,seg = index ;cipher_len > 0; sg = scatterwalk_sg_next(sg)) {
-			len = min(cipher_len, sg->length);
-			scatterwalk_start(&walk, sg);
-			virt = page_address(scatterwalk_page(&walk)) + offset_in_page(walk.offset);
-			rv = nlm_crypto_fill_dst_seg(param,seg,max_frags,virt,len);
-			if ( rv <= seg )
-				return nlm_crypto_calc_rem_len(sg,cipher_len) + max_frags;
-			else
-				seg = rv;
-			cipher_len -= len;
+	else
+	{
+		struct scatter_walk walk1,walk2;
+
+
+		for( sg_s = src_sg, sg_d = dst_sg; 
+				sg_s != NULL && sg_d != NULL; 
+				sg_s = scatterwalk_sg_next(sg_s),
+				sg_d = scatterwalk_sg_next(sg_d)) {
+		scatterwalk_start(&walk1, sg_s);
+		scatterwalk_start(&walk2, sg_d);
+		src_paddr = page_to_phys(scatterwalk_page(&walk1)) + offset_in_page(walk1.offset);
+		src = phys_to_virt(src_paddr);
+		dest_paddr = page_to_phys(scatterwalk_page(&walk2)) + offset_in_page(walk2.offset);
+		dst = phys_to_virt(dest_paddr);
+
+		len = min(cipher_len, sg_s->length);
+		saesoc_add_frags(d_desc,src,len,dst,len);
+		cipher_len -= len;
 		}
 
-		nr_dst_frags = seg;
 
-		if ((nr_src_frags > nr_dst_frags) && (nr_src_frags < max_frags)) {
-			for (i = 0; i < nr_src_frags - nr_dst_frags; i++)
-				param->segment[index + nr_dst_frags + i][1] = 0ULL;
-			seg = nr_src_frags;
-		}
-		else  { 
-			if ((nr_src_frags < nr_dst_frags) && (nr_dst_frags < max_frags )){
-				for (i = 0; i < nr_dst_frags - nr_src_frags; i++)
-					param->segment[index + nr_src_frags + i][0] = 0ULL;
-			}
-			seg = nr_dst_frags;
-		}
-		return seg;
+		
 	}
-
+	return d_desc;
 }
 
+
+
     static void
 reset_crypto_stats(void)
 {
@@ -544,7 +246,7 @@ nlm_xlp_sae_msgring_handler(uint32_t vc, uint32_t src_id,
 	if(async)	
 		async->callback(async, msg1);
 }
-
+#if 0
 static int
 nlm_crypto_read_stats_proc(char *page, char **start, off_t off, int count,
                        int *eof, void *data)
@@ -626,6 +328,7 @@ nlm_crypto_read_stats_proc(char *page, char **start, off_t off, int count,
         return len;
 
 }
+#endif
 int nlm_crypto_clear_stat_proc(struct file *file, const char __user *buffer, 
 		unsigned long count, void *data)
 {
@@ -641,11 +344,11 @@ int nlm_crypto_clear_stat_proc(struct file *file, const char __user *buffer,
 	return 1;
 
 }
-
 int
 nlm_crypto_init(void)
 {
     int ret = 0;
+#if 0
     struct proc_dir_entry *entry = NULL;
     struct proc_dir_entry *clear_entry  = NULL;
 
@@ -665,7 +368,9 @@ nlm_crypto_init(void)
 	   clear_entry->write_proc = nlm_crypto_clear_stat_proc;
     }
 
+#endif
    nlm_hal_get_crypto_vc_nums(&crypto_vc_base, &crypto_vc_limit); 
+   printf("crypto vc base %d\n",crypto_vc_base);
 
     if (register_xlp_msgring_handler
 		    (XLP_MSG_HANDLE_CRYPTO, nlm_xlp_sae_msgring_handler, NULL)) {
@@ -677,7 +382,6 @@ nlm_crypto_init(void)
 
     return ret;
 }
-
 static void  init_sae(void)
 {
 	extern void *fdt;
@@ -689,17 +393,36 @@ static void  init_sae(void)
 	for_each_node(node) {
 
 		nlm_hal_set_sae_freq(node, freq);
-		nlm_hal_set_sae_engine_sel(node);
+		//nlm_hal_set_sae_engine_sel(node);
 	}
 
 }
 
+
+void *mem_alloc(size_t align, size_t size)
+{
+	printf("%s called free \n", __FUNCTION__);
+	return NULL;
+}
+
+void mem_free(void *addr) 
+{
+	printf("%s called free \n", __FUNCTION__);
+}
+
+struct cryptosoc_lib_params lparam;
+/*int nlm_hal_get_sae_chip_feature()
+{
+	return 0;
+}*/
     static int __init
 xlp_sae_init(void)
 {
     extern int ipsec_sync_vc;
     extern int ipsec_async_vc;
+
     printk(KERN_ERR ",\n XLP SAE/Crypto Initialization \n");
+    printk("ipsec_sync_vc %d ipsec_async_vc %d\n",ipsec_sync_vc,ipsec_async_vc);
 
     xlp_sae_major = register_chrdev(0, "NLM_XLP_SAE", &xlp_sae_fops);
     if (xlp_sae_major < 0) {
@@ -713,7 +436,13 @@ xlp_sae_init(void)
     }
     nlm_crypto_init();
     init_sae();
-    nlm_crypto_chip_features = nlm_hal_get_sae_chip_feature();
+    //nlm_crypto_chip_features = nlm_hal_get_sae_chip_feature();
+    /* Initialize the library */
+    if(cryptosoc_lib_init(&lparam, &mem_alloc, &mem_free, NULL) < 0) {
+	    printf("%s,%d Error \n", __FUNCTION__, __LINE__);
+	    return 0;
+    }
+
     if(ipsec_async_vc != -1){
     	xlp_crypt_alg_init();
     	xlp_aead_alg_init();
@@ -722,6 +451,7 @@ xlp_sae_init(void)
     }
     if(ipsec_sync_vc != -1){
     	xlp_auth_alg_init();
+	    ;
     }else{
 	printk(KERN_ERR "Cannot perform auth operation, Please exclude ipsec_sync_vc from the node-vc-mask in dts\n");	
 	return 0;
@@ -730,13 +460,14 @@ xlp_sae_init(void)
     return 0;
 }
 
-    static void __exit
+    static void  __exit
 xlp_sae_cleanup(void)
 {
     xlp_crypt_alg_fini();
     xlp_auth_alg_fini();
     xlp_aead_alg_fini();
     unregister_chrdev(xlp_sae_major, "NLM_XLP_SAE");
+    return ;
 }
 
 module_init(xlp_sae_init);
@@ -744,4 +475,3 @@ module_exit(xlp_sae_cleanup);
 MODULE_DESCRIPTION("XLP Hardware crypto support for AES/DES/3DES/SHA/MD5 .");
 MODULE_LICENSE("GPL");
 MODULE_VERSION("0.1");
-MODULE_AUTHOR("Alok Agrawat");
diff --git a/drivers/crypto/sae/nlm_enc.c b/drivers/crypto/sae/nlm_enc.c
index 7510859..735aa88 100755
--- a/drivers/crypto/sae/nlm_enc.c
+++ b/drivers/crypto/sae/nlm_enc.c
@@ -17,9 +17,11 @@
 #include <crypto/des.h>
 #include <crypto/ctr.h>
 #include <nlm_hal_fmn.h>
-#include <asm/netlogic/hal/nlm_hal.h>
-#include <asm/netlogic/msgring.h>
+#include <linux/module.h>
 
+#include <nlm_xlp.h>
+#include <nlm_msgring.h>
+#include "saesoc_lib.h"
 #include "nlm_async.h"
 #undef NLM_CRYPTO_DEBUG
 
@@ -27,44 +29,39 @@
 #define XLP_CRYPT_PRIORITY	300
 
 
+
 struct nlm_enc_ctx {
-	struct nlm_crypto_pkt_ctrl ctrl; 
+	struct saesoc_session_desc enc_s_desc;
+	/* max key length is 256 bits */
+	unsigned long long key[16];
+	struct saesoc_session_desc dec_s_desc;
+	/* max key length is 256 bits */
+	unsigned long long dec_key[16];
+	struct saesoc_session_init_params initp;
+	/* to be removed*/
 	uint16_t stat;
 	char nonce[4];
 };
 /* mem utilisation of CTX_SIZE */
 #define MAX_FRAGS               18 
 #define CTRL_DESC_SIZE          (sizeof(struct nlm_enc_ctx) + 64)
-#define DES3_CTRL_DESC_SIZE     (2*CTRL_DESC_SIZE + 2*64)
+#define IV_SIZE  	 	64	
 
 
 /* mem utilisation of req mem */
 
-#define PACKET_DESC_SIZE        (64 + sizeof(struct nlm_crypto_pkt_param) + (MAX_FRAGS*16) + 64 + sizeof(struct nlm_async_crypto) + 64)
-#define NLM_CRYPTO_PKT_PARAM_OFFSET(addr)       (((unsigned long)addr + 64) & ~0x3fUL)
-#define NLM_ASYNC_PTR_PARAM_OFFSET(addr)        (((unsigned long)addr + 64 + sizeof(struct nlm_crypto_pkt_param) + (MAX_FRAGS*16) + 64) & ~0x3fUL)
-#define NLM_IV_OFFSET(addr)			((unsigned long)addr + (PACKET_DESC_SIZE - 64))
-
-
-static int no_of_alg_registered = 0;
-
 
+/* mem utilisation of req mem */
 
-extern uint32_t nlm_hal_send_msg3(uint32_t dst, uint32_t code, uint64_t data0, uint64_t data1, uint64_t data2);
-extern __inline__ uint32_t nlm_hal_recv_msg2(uint32_t dst, uint32_t *src, uint32_t *size, uint32_t *code, uint64_t *data0, uint64_t *data1);
+#define PACKET_DESC_SIZE        (128 + sizeof(struct saesoc_data_desc) + (MAX_FRAGS*8) + sizeof(struct nlm_async_crypto) + IV_SIZE + 64)
+#define NLM_CRYPTO_DATA_DESC(addr)  (struct saesoc_data_desc *) (((unsigned long)addr + 64) & ~0x3fUL)
+#define NLM_ASYNC_PTR_PARAM_OFFSET(addr)        (((unsigned long)addr +  sizeof(struct saesoc_data_desc) + (MAX_FRAGS*8) + 128) & ~0x3fUL)
+#define NLM_IV_OFFSET(addr)			((unsigned long)addr + (PACKET_DESC_SIZE - IV_SIZE))
 
-#ifdef NLM_CRYPTO_DEBUG
-extern void print_cntl_instr(uint64_t cntl_desc);
-extern void print_crypto_msg_desc(uint64_t entry1, uint64_t entry2, uint64_t entry3);
-extern void print_pkt_desc(struct nlm_crypto_pkt_param * pkt_param, int index);
-#endif
+static int no_of_alg_registered = 0;
 
-extern int cipher_mode_iv_len[NLM_CIPHER_MAX][NLM_CIPHER_MODE_MAX];
 extern struct nlm_crypto_stat crypto_stat[MAX_CPU];
 
-
-
-
 static int enc_cra_init(struct crypto_tfm *tfm)
 { 
 	tfm->crt_ablkcipher.reqsize = PACKET_DESC_SIZE; //reqsize of 512 bytes for packet desc
@@ -73,49 +70,52 @@ static int enc_cra_init(struct crypto_tfm *tfm)
 
 static struct nlm_enc_ctx * nlm_crypto_ablkcipher_ctx(struct crypto_ablkcipher *tfm)
 {
-	return (struct  nlm_enc_ctx *)(((unsigned long)((uint8_t *)crypto_ablkcipher_ctx(tfm) + 63 )) & ~(0x3fUL));
+	return (struct  nlm_enc_ctx *)(((unsigned long)((uint8_t *)crypto_ablkcipher_ctx(tfm) + 64 )) & ~(0x3fUL));
 } 
-
-static struct nlm_enc_ctx * nlm_crypto_ablkcipher_ctx_2(struct crypto_ablkcipher *tfm)
-{
-	return (struct  nlm_enc_ctx *)(( unsigned long )(( uint8_t *)nlm_crypto_ablkcipher_ctx(tfm) + CTRL_DESC_SIZE + 63) & ~(0x3fUL));
-}
-
 static int
-xlp_setkey(struct crypto_ablkcipher *tfm, const u8 * in_key, unsigned int len, uint32_t cipher_alg, uint32_t cipher_mode,uint16_t stat)
+xlp_setkey(struct crypto_ablkcipher *tfm, uint16_t stat)
 {
-	struct nlm_enc_ctx * nlm_ctx = nlm_crypto_ablkcipher_ctx(tfm); 
-	
-	nlm_crypto_fill_pkt_ctrl(&nlm_ctx->ctrl,0,0,0,cipher_alg,cipher_mode,0,(unsigned char*)in_key,len,0,0,1);
-	crypto_ablkcipher_crt(tfm)->ivsize = cipher_mode_iv_len[cipher_alg][ cipher_mode];
+
+
+	struct nlm_enc_ctx *nlm_ctx = nlm_crypto_ablkcipher_ctx(tfm); 
+	int nsdescs = saesoc_calc_sdesc_cnt(&nlm_ctx->initp,NULL);
+	struct saesoc_session_desc *s_desc = &nlm_ctx->enc_s_desc;
 	nlm_ctx->stat = stat;
 
-	return 0;
+	if(saesoc_new_session(&nlm_ctx->initp,&s_desc,nsdescs, NULL) < 0)
+		 printk("%s,%d Error \n", __FUNCTION__, __LINE__); 
 
-}
+	nlm_ctx->initp.cipher.flags = 0;
 
-static int
-xlp_setkey_des3(struct crypto_ablkcipher *tfm, const u8 * in_key, unsigned int len, uint32_t cipher_alg, uint32_t cipher_mode, uint16_t stat)
-{
-	struct nlm_enc_ctx * nlm_ctx = nlm_crypto_ablkcipher_ctx_2(tfm); 
+	s_desc = &nlm_ctx->dec_s_desc;
 
-	nlm_crypto_fill_pkt_ctrl(&nlm_ctx->ctrl,0,0,0,cipher_alg,cipher_mode,0,(unsigned char *)in_key,len,0,0,0);
-	crypto_ablkcipher_crt(tfm)->ivsize = cipher_mode_iv_len[cipher_alg][ cipher_mode];
-	nlm_ctx->stat = stat;
+	if(saesoc_new_session(&nlm_ctx->initp,&s_desc,nsdescs, NULL) < 0)
+		 printk("%s,%d Error \n", __FUNCTION__, __LINE__); 
 
 	return 0;
-
 }
 
 static int
 xlp_des3_setkey(struct crypto_ablkcipher *tfm, const u8 * in_key, unsigned int len)
 {
-	uint32_t cipher_alg;
 	u32 flags = 0;
+	struct nlm_enc_ctx *nlm_ctx = nlm_crypto_ablkcipher_ctx(tfm); 
+	struct saesoc_session_init_params * initp = &nlm_ctx->initp;
+        initp->cipher.mode = SAESOC_CIPHER_MODE_CBC;	
+	initp->cipher.iv_offset = 0;
+	initp->cipher.iv_mode = 0;
+	initp->cipher.key = (char *)in_key;
+	initp->cipher.key_len = len;
+	initp->cipher.cfb_mask = 0;
+	initp->cipher.flags = SAESOC_CF_ENCRYPT;
+	initp->hash.type = SAESOC_HASH_BYPASS;
+	initp->hash.key_len = 0;
+	initp->payload_offset = DES_BLOCK_SIZE; 
+	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC | SAESOC_IF_DATA_OUT_CLOBBER;
 
 	switch (len) {
 	case DES3_EDE_KEY_SIZE:
-	        cipher_alg = NLM_CIPHER_3DES;
+		initp->cipher.type = SAESOC_CIPHER_TYPE_TDES;
 		break;
 	default:
 		printk(KERN_WARNING "[%s]: Cannot handle keylen = %d\n",
@@ -124,19 +124,31 @@ xlp_des3_setkey(struct crypto_ablkcipher *tfm, const u8 * in_key, unsigned int l
 		crypto_ablkcipher_set_flags(tfm,flags);
 		return -EINVAL;
 	}
-	xlp_setkey(tfm, in_key, len, cipher_alg, NLM_CIPHER_MODE_CBC,TDES_CBC_STAT);
-	return xlp_setkey_des3(tfm, in_key, len, cipher_alg, NLM_CIPHER_MODE_CBC, TDES_CBC_STAT);
+	xlp_setkey(tfm,TDES_CBC_STAT);
+	return 0;
 }
 
 static int
 xlp_des_setkey(struct crypto_ablkcipher *tfm, const u8 * in_key, unsigned int len)
 {
-	uint32_t cipher_alg;
 	u32 flags = 0;
+	struct nlm_enc_ctx *nlm_ctx = nlm_crypto_ablkcipher_ctx(tfm); 
+	struct saesoc_session_init_params * initp = &nlm_ctx->initp;
+        initp->cipher.mode = SAESOC_CIPHER_MODE_CBC;	
+	initp->cipher.iv_offset = 0;
+	initp->cipher.iv_mode = 0;
+	initp->cipher.key = (char *)in_key;
+	initp->cipher.key_len = len;
+	initp->cipher.cfb_mask = 0;
+	initp->cipher.flags = SAESOC_CF_ENCRYPT;
+	initp->hash.type = SAESOC_HASH_BYPASS;
+	initp->hash.key_len = 0;
+	initp->payload_offset = DES_BLOCK_SIZE; 
+	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC | SAESOC_IF_DATA_OUT_CLOBBER;
 
 	switch (len) {
 	case DES_KEY_SIZE:
-	        cipher_alg = NLM_CIPHER_DES;
+		initp->cipher.type = SAESOC_CIPHER_TYPE_DES;
 		break;
 	default:
 		printk(KERN_WARNING "[%s]: Cannot handle keylen = %d\n",
@@ -145,28 +157,42 @@ xlp_des_setkey(struct crypto_ablkcipher *tfm, const u8 * in_key, unsigned int le
 		crypto_ablkcipher_set_flags(tfm, flags);
 		return -EINVAL;
 	}
-	return xlp_setkey(tfm, in_key, len, cipher_alg,NLM_CIPHER_MODE_CBC,DES_CBC_STAT);
+	return xlp_setkey(tfm,DES_CBC_STAT);
 }
-
 static int
 xlp_aes_setkey(struct crypto_ablkcipher *tfm, const u8 *in_key, 
-		unsigned int len, uint32_t mode)
+		unsigned int len, uint32_t mode, int iv_size)
 {
-	uint32_t cipher_alg;
+
+	struct nlm_enc_ctx *nlm_ctx = nlm_crypto_ablkcipher_ctx(tfm); 
+	struct saesoc_session_init_params * initp = &nlm_ctx->initp;
 	uint16_t stat;
 	u32 flags = 0;
+        initp->cipher.mode = mode;	
+	initp->cipher.iv_offset = 0;
+	initp->cipher.iv_mode = 0;
+	initp->cipher.key = (char *)in_key;
+	initp->cipher.key_len = len;
+	initp->cipher.cfb_mask = 0;
+	initp->cipher.flags = SAESOC_CF_ENCRYPT;
+	initp->hash.type = SAESOC_HASH_BYPASS;
+	initp->hash.key_len = 0;
+	initp->payload_offset = iv_size; 
+	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC | SAESOC_IF_DATA_OUT_CLOBBER;
+
+
 
 	switch (len) {
 	case 16:
-	        cipher_alg = NLM_CIPHER_AES128;
+		initp->cipher.type = SAESOC_CIPHER_TYPE_AES_128;
 		stat = AES128_CBC_STAT;
 		break;
 	case 24:
-		cipher_alg = NLM_CIPHER_AES192;
+		initp->cipher.type = SAESOC_CIPHER_TYPE_AES_192;
 		stat = AES192_CBC_STAT;
 		break;
 	case 32:
-		cipher_alg = NLM_CIPHER_AES256;
+		initp->cipher.type = SAESOC_CIPHER_TYPE_AES_256;
 		stat = AES256_CBC_STAT;
 		break;
 	default:
@@ -179,15 +205,14 @@ xlp_aes_setkey(struct crypto_ablkcipher *tfm, const u8 *in_key,
 	if ( mode == NLM_CIPHER_MODE_CTR )
 		stat += 3;
 
-	return xlp_setkey(tfm, in_key, len, cipher_alg, mode, stat);
+	return xlp_setkey(tfm, stat);
 }
 
 static int xlp_cbc_aes_setkey(struct crypto_ablkcipher *tfm, const u8 *key,
 					unsigned int keylen)
 {
-	return xlp_aes_setkey(tfm,key,keylen,NLM_CIPHER_MODE_CBC);
+	return xlp_aes_setkey(tfm,key,keylen,SAESOC_CIPHER_MODE_CBC,AES_BLOCK_SIZE);
 }
-
 static int xlp_ctr_rfc3686_setkey(struct crypto_ablkcipher *tfm, const u8 *key,
                                  unsigned int keylen)
 {
@@ -201,17 +226,18 @@ static int xlp_ctr_rfc3686_setkey(struct crypto_ablkcipher *tfm, const u8 *key,
         memcpy(nonce, key + (keylen - CTR_RFC3686_NONCE_SIZE),
                CTR_RFC3686_NONCE_SIZE);
         keylen -= CTR_RFC3686_NONCE_SIZE;
-        err = xlp_aes_setkey(tfm, key, keylen, NLM_CIPHER_MODE_CTR );
+        err = xlp_aes_setkey(tfm, key, keylen,SAESOC_CIPHER_MODE_CTR,AES_BLOCK_SIZE);
 
         return err;
 }
-
 void enc_request_callback(struct nlm_async_crypto *async, uint64_t msg1 )
 {
 	struct crypto_async_request * base = (struct crypto_async_request *)async->args; 
 	int err =0;
+#ifdef NOT_IMPLEMETNERED
 	int cpu = hard_smp_processor_id();
 	int stat = async->stat;
+#endif
 
 	if (msg1 & 0x7ff80) {
 		printk("\n Error: entry1 is %llx",msg1);
@@ -219,120 +245,87 @@ void enc_request_callback(struct nlm_async_crypto *async, uint64_t msg1 )
 		base->complete(base, err);
 		return;
 	}
+#ifdef NOT_IMPLEMETNERED
 	crypto_stat[cpu].enc[stat]++;
 	crypto_stat[cpu].enc_tbytes[stat]+= async->bytes;
+#endif
 	if ( async->pkt_param)
 		kfree(async->pkt_param);
-	
 	base->complete(base, err);
 }
 
 static int
-xlp_crypt(struct ablkcipher_request *req, unsigned int enc, int iv_size, struct nlm_crypto_pkt_ctrl *ctrl, uint16_t stat)
+xlp_crypt(struct ablkcipher_request *req, unsigned int enc, int iv_size, uint16_t stat)
 {
-	int seg = 0;
-	uint64_t msg0, msg1;
-	int pktdescsize = 0;
+
+
+	struct saesoc_data_desc	   *d_desc = NLM_CRYPTO_DATA_DESC(ablkcipher_request_ctx(req));
+	unsigned int cipher_len = req->nbytes;
+	struct nlm_async_crypto * async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET(ablkcipher_request_ctx(req));
+	struct saesoc_extra_req_send_params mparam;
 	int fb_vc;
-#ifdef CONFIG_32BIT
+	int node ;
 	unsigned long msgrng_flags;
-#endif
 	int node_sae_base;
-	int node ;
-	unsigned int max_frags= MAX_FRAGS;
-	unsigned int cipher_len = req->nbytes;
-	int ret = -EINPROGRESS; 
-	int try = 0;
-	struct nlm_crypto_pkt_param * pkt_param = (struct nlm_crypto_pkt_param *) NLM_CRYPTO_PKT_PARAM_OFFSET(ablkcipher_request_ctx(req));
-	struct nlm_async_crypto * async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET(ablkcipher_request_ctx(req));
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);
+	struct nlm_enc_ctx *nlm_ctx = nlm_crypto_ablkcipher_ctx(tfm); 
+	struct saesoc_session_desc *s_desc;
+	int max_frags = MAX_FRAGS;
+	if ( enc )
+		s_desc = &nlm_ctx->enc_s_desc;
+	else
+		s_desc = &nlm_ctx->dec_s_desc; 
 
 	async->pkt_param = NULL;
+	saesoc_add_frags(d_desc,req->info,iv_size,req->info,iv_size);
 
-	nlm_crypto_fill_cipher_pkt_param(ctrl, pkt_param, enc,0,iv_size,iv_size ,req->nbytes); 
-
-	nlm_crypto_fill_src_dst_seg(pkt_param,seg,MAX_FRAGS,(unsigned char *)req->info,iv_size);
-	seg++;
 
-	do {
-		cipher_len = req->nbytes;
-		seg = fill_src_dst_sg(req->src,req->dst,cipher_len,pkt_param,seg,max_frags,0);
+	cipher_len = req->nbytes;
 
-		if ( seg > max_frags ) {
-			max_frags = seg; 
-			seg = alloc_pkt_param(async,&pkt_param,max_frags);
-		}
-	}while(seg == 1 ); 
+	d_desc = fill_src_dst_sg(s_desc,d_desc,async,req->src, req->dst,&max_frags,cipher_len);
 
-	pktdescsize = 32 + seg * 16;
+	saesoc_set_payload_len(d_desc,cipher_len);
 
 	preempt_disable();
-	fb_vc = crypto_get_fb_vc(&node); 
-
-	msg0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, ctrl->cipherkeylen,
-			virt_to_phys(ctrl));
-	msg1 = nlm_crypto_form_pkt_fmn_entry1(0,ctrl->hashkeylen, pktdescsize,
-				virt_to_phys(pkt_param));
-#ifdef NLM_CRYPTO_DEBUG
-	print_crypto_msg_desc(msg0,msg1,0xdeadbeef);
-	print_pkt_desc(pkt_param,seg);
-	print_cntl_instr(ctrl->desc0);
-#endif
 	async->callback = &enc_request_callback;
 	async->args = &req->base;
 	async->stat = stat; 
 	async->bytes = req->nbytes; 
+	mparam.async_rsp_arg = (uint64_t)async;
+	mparam.arc4_load_state = 0;
+
 	mb();
-#ifdef CONFIG_32BIT
 	msgrng_access_enable(msgrng_flags);
-#endif
+	fb_vc = crypto_get_fb_vc(&node); 
 	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
-	while( nlm_hal_send_msg3(node_sae_base, 0 /*code */ , msg0, msg1, (unsigned long )async) != 0 ){
-		if ( try++ > 16) {
-			ret = -EAGAIN;
-			break;
-		}
-	}
-#ifdef CONFIG_32BIT
+	saesoc_process_request(NULL,d_desc,node_sae_base,fb_vc,0,1,&mparam,NULL);
 	msgrng_access_disable(msgrng_flags);
-#endif
 	preempt_enable();
-	return ret;
+	return -EINPROGRESS; 
 }
-
-static int
-xlp_3des_cbc_decrypt( struct ablkcipher_request *req)
-{
-      	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);
-	struct nlm_enc_ctx * nlm_ctx = nlm_crypto_ablkcipher_ctx_2(tfm); 
-	return xlp_crypt(req, 0, DES3_EDE_BLOCK_SIZE,&nlm_ctx->ctrl,nlm_ctx->stat);
-}
-
-static int
-xlp_3des_cbc_encrypt( struct ablkcipher_request *req )
-{
-      	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);
-	struct nlm_enc_ctx *nlm_ctx = nlm_crypto_ablkcipher_ctx(tfm); 
-	return xlp_crypt(req, 1, DES3_EDE_BLOCK_SIZE,&nlm_ctx->ctrl,nlm_ctx->stat);
-}
-
 static int
 xlp_cbc_decrypt( struct ablkcipher_request *req )
 {
 	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);
-	int iv_size = crypto_ablkcipher_ivsize(tfm);
 	struct nlm_enc_ctx *nlm_ctx = nlm_crypto_ablkcipher_ctx(tfm); 
-	return xlp_crypt(req, 0, iv_size,&nlm_ctx->ctrl,nlm_ctx->stat);
+	struct saesoc_session_desc *s_desc = &nlm_ctx->dec_s_desc;
+	struct saesoc_data_desc	   *d_desc = NLM_CRYPTO_DATA_DESC(ablkcipher_request_ctx(req));
+	int iv_size = crypto_ablkcipher_ivsize(tfm);
+	saesoc_new_data_desc(s_desc, &d_desc, MAX_FRAGS , NULL);
+	return xlp_crypt(req, 0, iv_size,nlm_ctx->stat);
 }
 
 static int
 xlp_cbc_encrypt( struct ablkcipher_request *req )
 {
 	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);
-	int iv_size = crypto_ablkcipher_ivsize(tfm);
 	struct nlm_enc_ctx *nlm_ctx = nlm_crypto_ablkcipher_ctx(tfm); 
-	return xlp_crypt(req, 1, iv_size,&nlm_ctx->ctrl, nlm_ctx->stat);
+	struct saesoc_session_desc *s_desc = &nlm_ctx->enc_s_desc;
+	struct saesoc_data_desc	   *d_desc = NLM_CRYPTO_DATA_DESC(ablkcipher_request_ctx(req));
+	int iv_size = crypto_ablkcipher_ivsize(tfm);
+	saesoc_new_data_desc(s_desc, &d_desc, MAX_FRAGS , NULL);
+	return xlp_crypt(req, 1, iv_size, nlm_ctx->stat);
 }
-
 static int crypto_rfc3686_crypt(struct ablkcipher_request *req,
 		unsigned int enc )
 {
@@ -340,18 +333,27 @@ static int crypto_rfc3686_crypt(struct ablkcipher_request *req,
 	struct nlm_enc_ctx  *nlm_ctx = ( struct nlm_enc_ctx  * )nlm_crypto_ablkcipher_ctx(tfm);
 	u8 *iv = (uint8_t *)NLM_IV_OFFSET(ablkcipher_request_ctx(req));
 	int ret = 0;
-
-	/*  uniqueness is maintained by the req->info */
+	struct saesoc_session_desc *s_desc;
+	struct saesoc_data_desc	   *d_desc;
 	u8 *info = req->info;
 	unsigned char * nonce = &(nlm_ctx->nonce[0]); 
 
+	if ( enc)
+		s_desc = &nlm_ctx->enc_s_desc;
+	else
+		s_desc = &nlm_ctx->dec_s_desc;
+	d_desc = NLM_CRYPTO_DATA_DESC(ablkcipher_request_ctx(req));
+	saesoc_new_data_desc(s_desc, &d_desc, MAX_FRAGS , NULL);
+
+	/*  uniqueness is maintained by the req->info */
+
 	memcpy(iv, nonce, CTR_RFC3686_NONCE_SIZE);
 	memcpy(iv + CTR_RFC3686_NONCE_SIZE, info, CTR_RFC3686_IV_SIZE);
 
 	*(__be32 *)(iv + CTR_RFC3686_NONCE_SIZE + CTR_RFC3686_IV_SIZE) =
 				cpu_to_be32(1);
 	req->info = iv;
-	ret = xlp_crypt(req, enc, 16,&nlm_ctx->ctrl, nlm_ctx->stat);
+	ret = xlp_crypt(req, enc, 16,nlm_ctx->stat);
 	req->info = info;
 	return ret;
 }
@@ -367,7 +369,6 @@ xlp_ctr_rfc3686_encrypt(struct ablkcipher_request *req)
 {
 	return crypto_rfc3686_crypt(req,1);
 }
-
 static struct crypto_alg xlp_cbc_aes_alg = {
 	.cra_name = "cbc(aes)",
 	.cra_driver_name = "cbc-aes-xlp",
@@ -375,7 +376,6 @@ static struct crypto_alg xlp_cbc_aes_alg = {
 	.cra_flags = CRYPTO_ALG_TYPE_ABLKCIPHER|CRYPTO_ALG_ASYNC,
 	.cra_blocksize = AES_BLOCK_SIZE,
 	.cra_ctxsize = CTRL_DESC_SIZE,
-	.cra_alignmask = 15,
 	.cra_type = &crypto_ablkcipher_type,
 	.cra_module = THIS_MODULE,
 	.cra_init = enc_cra_init,
@@ -388,10 +388,10 @@ static struct crypto_alg xlp_cbc_aes_alg = {
 			.encrypt = xlp_cbc_encrypt,
 			.decrypt = xlp_cbc_decrypt,
 			.ivsize = AES_BLOCK_SIZE,
+			.geniv          = "eseqiv",
 		}
 	}
 };
-
 static struct crypto_alg xlp_cbc_des_alg = {
 	.cra_name = "cbc(des)",
 	.cra_driver_name = "cbc-des-xlp",
@@ -399,7 +399,6 @@ static struct crypto_alg xlp_cbc_des_alg = {
 	.cra_flags = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
 	.cra_blocksize = DES_BLOCK_SIZE,
 	.cra_ctxsize = CTRL_DESC_SIZE,
-	.cra_alignmask = 15,
 	.cra_type = &crypto_ablkcipher_type,
 	.cra_module = THIS_MODULE,
 	.cra_init = enc_cra_init,
@@ -412,6 +411,7 @@ static struct crypto_alg xlp_cbc_des_alg = {
 			.encrypt = xlp_cbc_encrypt,
 			.decrypt = xlp_cbc_decrypt,
 			.ivsize = DES_BLOCK_SIZE,
+			.geniv          = "eseqiv",
 		}
 	}
 };
@@ -422,8 +422,7 @@ static struct crypto_alg xlp_cbc_des3_alg = {
 	.cra_priority = XLP_CRYPT_PRIORITY,
 	.cra_flags = CRYPTO_ALG_TYPE_ABLKCIPHER|CRYPTO_ALG_ASYNC,
 	.cra_blocksize = DES3_EDE_BLOCK_SIZE,
-	.cra_ctxsize = DES3_CTRL_DESC_SIZE,
-	.cra_alignmask = 15,
+	.cra_ctxsize = CTRL_DESC_SIZE,
 	.cra_type = &crypto_ablkcipher_type,
 	.cra_module = THIS_MODULE,
 	.cra_init = enc_cra_init,
@@ -433,9 +432,10 @@ static struct crypto_alg xlp_cbc_des3_alg = {
 			.min_keysize = DES3_EDE_KEY_SIZE,
 			.max_keysize = DES3_EDE_KEY_SIZE,
 			.setkey = xlp_des3_setkey,
-			.encrypt = xlp_3des_cbc_encrypt,
-			.decrypt = xlp_3des_cbc_decrypt,
+			.encrypt = xlp_cbc_encrypt,
+			.decrypt = xlp_cbc_decrypt,
 			.ivsize = DES3_EDE_BLOCK_SIZE,
+			.geniv          = "eseqiv",
 		}
 	}
 };
@@ -447,7 +447,6 @@ static struct crypto_alg xlp_ctr_aes_alg = {
 	.cra_flags = CRYPTO_ALG_TYPE_ABLKCIPHER|CRYPTO_ALG_ASYNC,
 	.cra_blocksize = 1,
 	.cra_ctxsize = CTRL_DESC_SIZE,
-	.cra_alignmask = 0,
 	.cra_type = &crypto_ablkcipher_type,
 	.cra_module = THIS_MODULE,
 	.cra_init = enc_cra_init,
@@ -464,7 +463,6 @@ static struct crypto_alg xlp_ctr_aes_alg = {
 		}
 	}
 };
-
 int xlp_crypt_alg_init(void)
 {
 	int ret = 0;
@@ -493,12 +491,13 @@ end:
 	return 0;
 }
 
-void
+int
 xlp_crypt_alg_fini(void) {
 	crypto_unregister_alg(&xlp_cbc_des3_alg);
 	crypto_unregister_alg(&xlp_cbc_des_alg);
 	crypto_unregister_alg(&xlp_cbc_aes_alg);
 	crypto_unregister_alg(&xlp_ctr_aes_alg);
+	return 0;
 }
 
 EXPORT_SYMBOL(xlp_crypt_alg_init);
-- 
1.9.1

