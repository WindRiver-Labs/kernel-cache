From 3c3ed0901e911a7ca63cafa4c80556ca972ab001 Mon Sep 17 00:00:00 2001
From: kopal <kopal@broadcom.com>
Date: Fri, 31 Jan 2014 16:58:33 +0530
Subject: [PATCH 1434/1532] nae: Add timer based Autonegotiation

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/xlpge_main.c |  2 +-
 drivers/net/ethernet/broadcom/nae/xlpge_nae.c  | 31 +++++++++++++++++++-------
 2 files changed, 24 insertions(+), 9 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_main.c b/drivers/net/ethernet/broadcom/nae/xlpge_main.c
index 415444e..358d7b1 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_main.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_main.c
@@ -69,7 +69,7 @@ static int __init brcmxlp_nae_init(void)
 	xlpge_eeprom_init();
 	/* TODO:XXX Move to pci init? */
 	nlm_xlp_nae_init();
-	//init_phy_state_timer(NULL);
+	init_phy_state_timer(NULL);
 
 	return pci_register_driver(&brcmxlp_nae_driver);
 }
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_nae.c b/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
index 72c96e8..1e2247f 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
@@ -705,7 +705,7 @@ int replenish_freein_fifos(void)
 	int max_descs_pqueue, num_descs, max_nae_units;
 	unsigned int blk_cmplx_map, cmplx;
 	unsigned int ndescs_nq, ndescs_jq;
-
+	
 	/*get max nae*/
 	max_nae_units = get_num_nae_pernode();
 	for (node = 0; node < NLM_MAX_NODES; node++) {
@@ -790,18 +790,34 @@ void nlm_xlp_nae_remove(void)
 	nlm_nae_remove_procentries();
 }
 
-#if 0
 static void phy_st_timer_handler(unsigned long data)
 {
         struct timer_list *timer = &phy_int_timer;
-        nlm_hal_restart_an(0, 0);
-
+	uint32_t i,num_ports,maxnae,node,speed,duplex;
+	nae_t *nae_cfg;
+	static int arr[18];
+	maxnae = get_num_nae_pernode();
+        for (node = 0; node < NLM_MAX_NODES; node++) {
+                int num_nae, tmp;
+                for(num_nae=0; num_nae<maxnae; num_nae++){
+                        nae_cfg = get_nae(node, num_nae);
+                        if (nae_cfg == NULL)
+                                continue;
+				for(i=0;i<nae_cfg->num_ports;i++){
+					tmp=arr[i];
+					arr[i]=netsoc_get_phy_status(&nae_cfg->ports[i],&speed,&duplex);
+					if((arr[i]>-1)&&(arr[i]<tmp))
+						netsoc_start_autoneg(&nae_cfg->ports[i]);
+					else
+						continue;	
+					}
+		}
+	}
         timer->expires = jiffies + (HZ * 2);
         add_timer(timer);
 }
 void init_phy_state_timer(void *data)
 {
-
         struct timer_list *timer = &phy_int_timer;
         init_timer(timer);
         timer->expires = jiffies + 10;
@@ -809,7 +825,6 @@ void init_phy_state_timer(void *data)
         timer->function = phy_st_timer_handler;
         add_timer(timer);
 }
-#endif
 
 #if 0
 void nlm_xlp_mac_set_enable(struct dev_data *priv, int flag)
@@ -1367,7 +1382,7 @@ static int nlm_per_port_nae_init(nae_t* nae_cfg, int port, int maxnae)
 	int cpu;
 	int node = nae_cfg->node;
 	static int port_index = 0;
-
+	
 	if (!nae_cfg->ports[port].valid)
 		return -1;
 
@@ -1400,7 +1415,7 @@ static int nlm_per_port_nae_init(nae_t* nae_cfg, int port, int maxnae)
 	priv->type	= nae_cfg->ports[port].iftype;
 	priv->mgmt_port	= nae_cfg->ports[port].mgmt;
 	priv->port_index = port_index++;
-
+	
 	switch(nae_cfg->ports[port].iftype) {
 	case SGMII_IF:
 		priv->index = nae_cfg->ports[port].hw_port_id & 0x3;
-- 
1.9.1

