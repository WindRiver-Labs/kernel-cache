From 68d1a09ac4848f26c29b4396c557637cb85336b2 Mon Sep 17 00:00:00 2001
From: Jayanthi A <jayanthi.annadurai@broadcom.com>
Date: Wed, 6 Nov 2013 16:47:04 -0800
Subject: [PATCH 0847/1532] netlib: Added workaround for parser sequence fifo
 threshold.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/netlib/src/netsoc_nae.c | 117 ++++++++++++++++++-------
 1 file changed, 86 insertions(+), 31 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 6a51a99..ec3b0d4 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -1311,10 +1311,10 @@ void __netsoc_config_rxbuffer(nae_t *nae, int context_base, int num_channels, ui
 	}
 }
 
-void __netsoc_config_parserfifo(nae_t *nae, int hw_port_id, uint32_t start, uint32_t size)
+void __netsoc_config_parserfifo(nae_t *nae, int hw_port_id, uint32_t start, uint32_t size, int smallest_pkt_len, int iftype)
 {
 	volatile uint32_t val;
-	uint32_t xon, xoff;
+	uint32_t xon, xoff, inflight_len;
         static uint32_t prev_size = 0;
 
 	if (nae->ptp1588_enabled) { 
@@ -1338,13 +1338,37 @@ void __netsoc_config_parserfifo(nae_t *nae, int hw_port_id, uint32_t start, uint
 	else
 		prev_size = size;
 
-	if (size != 0)
-	{
-		xoff = size - 30 ;
-		xon = (size/4) * 2;
-		val = (xoff<<12) | (xon);
+        /*
+           FIFO xoff threshold: high. When #entries used rises to this specified number.
+           FIFO xon threshold: low.  When #entries used fall to this specified number.
+
+           formula from PRM:
+           xoff = ((fifosize) - (504/size of smallest pkt) -1 -R);
+           xon = xoff - separation;
+
+           inflight bytes = 504 (for XAUI) and 108 (for SGMII)
+           */
+
+        if (iftype == SGMII_IF)
+                inflight_len = NAE_INFLIGHT_LEN_SGMII;
+        else
+                inflight_len = NAE_INFLIGHT_LEN_XAUI;
+
+        if (size != 0)
+        {
+		if (is_nlm_xlp9xx()) {
+                        xoff = size - 30 ;
+                        xon = (size/4) * 2;
+                        val = (xoff<<12) | (xon);
+                }
+                else {
+                	xoff = size - (inflight_len/smallest_pkt_len) - 1 - NAE_REACTION_LEN_PARSER;
+	                xon = xoff - NAE_THR_SEPARATION;
+
+        	        val = (xoff<<12) | (xon);
+		}
 		netsoc_write_nae_reg(nae->nae_base, PARSER_SEQ_FIFOTH_CFG, val);
-	}
+        }
 
 	if (nae->ptp1588_enabled) {
 		// MD is zero, 1024 entries
@@ -1467,7 +1491,7 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 			if ((is_nlm_xlp9xx()) && (nae->ptp1588_enabled == 0) && size)
 				update_prsr_seq_fifo_size(nae, &size);
 
-			__netsoc_config_parserfifo(nae, nae->ports[port].hw_port_id + lane, cur_parser_base, size);
+			__netsoc_config_parserfifo(nae, nae->ports[port].hw_port_id + lane, cur_parser_base, size, 64, nae->ports[port].iftype);
 			cur_parser_base += size;
 		}
 		hw_port += offset;
@@ -1479,7 +1503,7 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "carving intf fifo;rx buffer: lane:%d n:%d port:%d\n", lane, nae->node, hw_port);
 		__netsoc_write_interface_fifo(nae, hw_port, cur_iface_start, 0, 0 );
 		__netsoc_write_rxbase(nae, hw_port, context_base);
-		__netsoc_config_parserfifo(nae, hw_port, cur_parser_base, 0);
+		__netsoc_config_parserfifo(nae, hw_port, cur_parser_base, 0, 64, nae->ports[port].iftype);
 		hw_port++;
 	    }
         }
@@ -2101,7 +2125,8 @@ static void __netsoc_config_sgmii(net_port_t *netport)
 */
 static void __netsoc_config_xaui(net_port_t *netport)
 {
-        uint32_t val = 0, higig_type;
+        uint32_t val = 0, higig_type, val1=0, val2 = 0, minval= 0;
+	uint32_t xon1 = 0 , xon2 = 0;
 	nae_t *nae = netport->nae;
         int rxaui_en = ((netport->rxaui_mode == NLP1042_PHY_10G_RXAUI_MODE1) ||
                         (netport->rxaui_mode == NLP1042_PHY_10G_RXAUI_MODE2)) ? 1 : 0;
@@ -2141,7 +2166,7 @@ static void __netsoc_config_xaui(net_port_t *netport)
         netsoc_write_mac_reg(mac_base, XAUI_CONFIG_0, 0x0);
 
         /* Enable tx/rx frame */
-        val = 0xA00000A8;
+        val = 0xA10000A8;
         val |= (XAUI_CONFIG_LENCHK | XAUI_CONFIG_GENFCS | XAUI_CONFIG_PAD_64);
         netsoc_write_mac_reg(mac_base, XAUI_CONFIG_1, val );
         /* write max frame len*/
@@ -2175,7 +2200,7 @@ static void __netsoc_config_xaui(net_port_t *netport)
                 val |= 1 << NETIOR_XGMAC_TX_PAUSE_POS;
                 val |= 1 << NETIOR_XGMAC_VLAN_DC_POS;
         } else {
-		netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_PAUSE_OPC, 0x1);
+		netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_PAUSE_OPC, 0x101);
                 val &= ~(1 << NETIOR_XGMAC_TX_PFC_EN_POS);
                 val &= ~(1<<NETIOR_XGMAC_RX_PFC_EN_POS);
                 val |= (1 << NETIOR_XGMAC_TX_PAUSE_POS);
@@ -2183,19 +2208,56 @@ static void __netsoc_config_xaui(net_port_t *netport)
         }
         netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL1, val);
 
+	if (is_nlm_xlp9xx()) {
                 /*
                  * Configuring the OFF/ON timer
                  * 31:16  - In PFC mode is used as the Xoff value
                  * 15:0   - In PFC mode is used as the Xon value
                  *        - in Link level FC mode, is used as the Xoff value.
                  */
-        if (netport->vlan_pri_en) {
-                val = 0xF1230000;          // PFC mode:  OffTimer = 0xF123  OnTimer = 0x0000
-        } else {
-                val = 0x0000F123;          // Link level FC: OffTimer = 0xF123
-        }
-        netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL2, val);
+	        if (netport->vlan_pri_en) {
+        	        val = 0xF1230000;          // PFC mode:  OffTimer = 0xF123  OnTimer = 0x0000
+	        } else {
+        	        val = 0x0000F123;          // Link level FC: OffTimer = 0xF123
+	        }
+        	netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL2, val);
+	}
+	else {
+           /*
+           1. calculate xoff timer for rx buf = ((rx_buf xon threshold in bytes)/64) -32
+           2. calcualte xoff timer for parser seq = parser sequencer xon threshold -32
+           3. minimum timer value of step 1 & 2
+           */
+
+           /* read the xon value from RX_BUFFER_XONOFF_THR reg, thgrp = 1 */
+           netsoc_write_nae_reg(nae->nae_base, RX_BUFFER_XONOFF_THR, (1 << 31) | NAE_XAUI_THR_GROUP);
+           val1 = netsoc_read_nae_reg(nae->nae_base, RX_BUFFER_XONOFF_THR);
+           xon1 = (((val1 >> 17) & 0x3fff) * NAE_RX_THR_BYTE_UNIT/64) - NAE_PAUSE_TIMER_DELTA;
+
+           /* read the xon value from PARSER_SEQ_FIFOTH_CFG */
+           val2 = netsoc_read_nae_reg(nae->nae_base, PARSER_SEQ_FIFOTH_CFG);
+           xon2 = (val2 & 0xfff) - NAE_PAUSE_TIMER_DELTA;
 
+           minval = (xon1<xon2)?xon1:xon2;
+
+           if (!minval)
+                minval = 0x17; /* failsafe */
+
+                /*
+                 * Configuring the OFF/ON timer
+                 * 31:16  - In PFC mode is used as the Xoff value                                     
+                 * 15:0   - In PFC mode is used as the Xon value                                      
+                 *        - in Link level FC mode, is used as the Xoff value.                         
+                 */
+           if (netport->vlan_pri_en) {
+                /* PFC mode:  OffTimer = minval,  OnTimer = 0x0000 */
+                val = ((minval<<16) & 0xffff0000);
+           } else {
+                /* Link level FC: OffTimer = minval */
+                val = (minval & 0x0000ffff);
+           }
+           netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL2, val);
+	}		
 
         /* set xaui tx threshold */
         val = netsoc_read_mac_reg(mac_base, NETIOR_XGMAC_CTRL3);
@@ -2516,7 +2578,7 @@ static int __netsoc_init_netior(nae_t *nae)
 			ifcredit |= (ifcredit_val << (block * 8));
 			complex_mask |= (0xf << (block * 4));
 		}
-		else {
+		else if (nae->ilk_complex_map & (1 << block)){
 			ifcredit |= (ilk_ifcredit << (block * 8));
 			complex_mask |= (0xf << (block * 4));
 		}
@@ -2533,8 +2595,10 @@ static int __netsoc_init_netior(nae_t *nae)
 
 	netsoc_api_print(NETSOC_APIDBG_GLOBAL, "ifcredit_cmplx<0..3> 0x%x ifcredit_cmplx4 0x%x complex_mask 0x%x\n",ifcredit, ifcredit_1, complex_mask);
 	// initialize credit and reset
-        netsoc_write_nae_iface_reg(nae_base, NETIOR_MISC_REG3_ADDR , ifcredit_1);
-        netsoc_write_nae_iface_reg(nae_base, NETIOR_MISC_REG2_ADDR , ifcredit );
+	if (ifcredit_1)
+	        netsoc_write_nae_iface_reg(nae_base, NETIOR_MISC_REG3_ADDR , ifcredit_1);
+	if (ifcredit)
+	        netsoc_write_nae_iface_reg(nae_base, NETIOR_MISC_REG2_ADDR , ifcredit );
         netsoc_write_nae_iface_reg(nae_base, NETIOR_MISC_REG1_ADDR , complex_mask);
 
 	// Clear credit reset
@@ -4217,15 +4281,6 @@ int __netsoc_init_nae(nae_t *nae)
                  else
                          nae->msec_rx_port_enable =  nae->msec_tx_port_enable = 0;
 
-		if (is_nlm_xlp9xx()) {
-			if (nae->xlgmac_complex_map) {
-				if (nae->nae_id == 0)
-					nlm_hal_enable_rxqdepth(nae->node, XLP_9XX_NET0_TX_VC_BASE);
-				else
-					nlm_hal_enable_rxqdepth(nae->node, XLP_9XX_NET1_TX_VC_BASE);
-			}
-		}
-
 	}
 	return NETSOC_API_SUCCESS;
 }
-- 
1.9.1

