From b4ed6f71b590a0299cf149a6b969d3017f12d69e Mon Sep 17 00:00:00 2001
From: Hareesh R <hareeshr@broadcom.com>
Date: Tue, 11 Dec 2012 18:42:32 +0530
Subject: [PATCH 1384/1532] nae: Port rx fifo support

if port fifo mode enabled, the linux nae driver selects the port
fifos for the replenishment instead of the pcpu fifo.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/xlpge.h     |  6 +--
 drivers/net/ethernet/broadcom/nae/xlpge_nae.c | 77 +++++++++++++++++----------
 drivers/net/ethernet/broadcom/nae/xlpge_rx.c  | 26 ++++-----
 drivers/net/ethernet/broadcom/nae/xlpge_tx.c  |  4 +-
 4 files changed, 64 insertions(+), 49 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/xlpge.h b/drivers/net/ethernet/broadcom/nae/xlpge.h
index d0be7fc..fb5c6b7 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge.h
+++ b/drivers/net/ethernet/broadcom/nae/xlpge.h
@@ -80,7 +80,8 @@
 #define	MSG_TXQ_FULL			0x04
 #define	NLM_TCP_MODE			1
 #define	NLM_RT_MODE			2
-#define	NLM_TCP_LOAD_BALANCE_MODE	3
+#define	NLM_TCP_LOAD_BALANCE_MODE	4
+#define NLM_PORT_FIFO_EN		8 // can co-exist with any of the above 3 modes 
 #define	TSO_ENABLED			1
 #define	R_TX_CONTROL			0x0a0
 #define	TX_PACKET_COUNTER		0x39
@@ -451,7 +452,7 @@ int nae_proc_read(char *, char **, off_t , int , int *, void *);
 int nlm_xlp_disable_napi(void);
 void nlm_spawn_kthread(void);
 int nlm_xlp_enable_napi(void);
-int mac_refill_frin_skb(int , int , uint64_t , uint32_t);
+int mac_refill_frin_skb(int , int , uint64_t , uint32_t, int);
 int mac_refill_frin_one_buffer(struct net_device *, int , uint32_t);
 void xlp_napi_lro_flush(void *);
 void nlm_xlp_mac_set_enable(struct dev_data *priv, int flag);
@@ -479,7 +480,6 @@ extern uint64_t slow_replenish_count[NR_CPUS * 8] __cacheline_aligned;
 extern uint64_t err_replenish_count[NR_CPUS * 8] __cacheline_aligned;
 extern uint64_t p2p_dynamic_alloc_cnt[NR_CPUS * 8] __cacheline_aligned;
 extern struct net_device *xlp_dev_mac[NLM_MAX_NODES][MAX_GMAC_PORT];
-extern uint64_t dummy_pktdata_addr[NLM_MAX_NODES];
 extern struct net_device *
 	per_cpu_netdev[NLM_MAX_NODES][NR_CPUS][24] __cacheline_aligned;
 extern int lro_flush_priv_cnt[NR_CPUS];
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_nae.c b/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
index bb65344..afdd801 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
@@ -49,7 +49,6 @@ uint64_t nlm_mode[NR_CPUS*8] ____cacheline_aligned;
 struct nlm_nae_linux_shinfo lnx_shinfo[NLM_NAE_MAX_SHARED_DOMS + 1];
 uint64_t p2p_dynamic_alloc_cnt[NR_CPUS * 8] __cacheline_aligned;
 struct net_device *xlp_dev_mac[NLM_MAX_NODES][MAX_GMAC_PORT];
-uint64_t dummy_pktdata_addr[NLM_MAX_NODES];
 struct net_device *
 	per_cpu_netdev[NLM_MAX_NODES][NR_CPUS][24] __cacheline_aligned;
 int exclusive_vc = 0;
@@ -67,8 +66,8 @@ module_param(num_descs_per_normalq, int, 0);
 int num_descs_per_jumboq = 32;
 module_param(num_descs_per_jumboq, int, 0);
 
-static uint32_t lnx_normal_mask;
-static uint32_t lnx_jumbo_mask;
+static uint32_t lnx_normal_mask[NLM_MAX_NODES];
+static uint32_t lnx_jumbo_mask[NLM_MAX_NODES];
 static int enable_jumbo = 0;
 module_param(enable_jumbo, int, 0);
 static struct p2p_desc_mem p2p_desc_mem[NR_CPUS] __cacheline_aligned;
@@ -128,6 +127,10 @@ static int init_dummy_entries_for_port_fifos(int node,
 		if((1 << i) & fifo_mask)
 			continue;
 
+		/* if it doesnt have any onchip space */
+		if(nae_cfg->freein_fifo_onchip_num_descs[i] == 0)
+			continue;
+
 		vc_index = i + nae_cfg->frin_queue_base;
 
 		for (j = 0; j < 4; j++) {
@@ -352,7 +355,7 @@ static int initialize_nae_per_node(int node, uint32_t *phys_cpu_map, int mode,
 			sizeof(nae_cfg->shinfo[i].cpu_2_freeinfifo_map));
 	}
 
-	lnx_normal_mask = nae_cfg->freein_fifo_dom_mask;
+	lnx_normal_mask[node] = nae_cfg->freein_fifo_dom_mask;
 
 	/* if jumbo enabled , we use half of the linux owned freein fifos
 	 * for jumbo skbs */
@@ -364,18 +367,18 @@ static int initialize_nae_per_node(int node, uint32_t *phys_cpu_map, int mode,
 					mine = 0;
 					continue;
 				}
-				lnx_normal_mask &= (~(1 << i));
-				lnx_jumbo_mask |= (1 << i);
+				lnx_normal_mask[node] &= (~(1 << i));
+				lnx_jumbo_mask[node] |= (1 << i);
 				mine = 1;
 			}
 		}
 
-		if (lnx_jumbo_mask) {
+		if (lnx_jumbo_mask[node]) {
 			nlm_hal_derive_cpu_to_freein_fifo_map(node,
-				phys_cpu_map[node], lnx_normal_mask,
+				phys_cpu_map[node], lnx_normal_mask[node],
 				cpu_2_normal_frfifo[node]);
 			nlm_hal_derive_cpu_to_freein_fifo_map(node,
-				phys_cpu_map[node], lnx_jumbo_mask,
+				phys_cpu_map[node], lnx_jumbo_mask[node],
 				cpu_2_jumbo_frfifo[node]);
 			memset(lnx_shinfo[0].cpu_2_freeinfifo_map,
 				0, sizeof(lnx_shinfo[0].cpu_2_freeinfifo_map));
@@ -407,12 +410,13 @@ static int initialize_nae_per_node(int node, uint32_t *phys_cpu_map, int mode,
 		}
 	}
 
+	lnx_shinfo[0].mode = nae_cfg->port_fifo_en ? NLM_PORT_FIFO_EN : 0; 
 #ifdef CONFIG_NLM_ENABLE_LOAD_BALANCING
 	if(mode == NLM_TCP_MODE)
-		lnx_shinfo[0].mode = NLM_TCP_LOAD_BALANCE_MODE;
+		lnx_shinfo[0].mode |= NLM_TCP_LOAD_BALANCE_MODE;
 	else
 #endif
-	lnx_shinfo[0].mode = mode;
+	lnx_shinfo[0].mode |= mode;
 	lnx_shinfo[0].jumbo_enabled = *jumbo_enabled;
 	lnx_shinfo[0].node = node;
 	if (nae_cfg->owned) {
@@ -497,7 +501,7 @@ static int nlm_replenish_per_cpu_buffer(int node, nlm_nae_config_ptr nae_cfg,
 	int ret = 0;
 	int size = NLM_RX_ETH_BUF_SIZE;
 
-	if ((1 << qindex) & lnx_jumbo_mask)
+	if ((1 << qindex) & lnx_jumbo_mask[node])
 		size = NLM_RX_JUMBO_BUF_SIZE;
 
 	/* For queue index 16 and 17, we still use  the port level descriptor info */
@@ -563,16 +567,29 @@ int replenish_freein_fifos(void)
 
 		/* configure the descs */
 		for (i = 0; i < nae_cfg->frin_total_queue; i++) {
+			/* if no onchip space. when port fifo is enabled, 
+			 we will unset all the unused fifo size */
+			if(nae_cfg->freein_fifo_onchip_num_descs[i] == 0)
+				continue;
+
 			max_descs_pqueue =
 				nae_cfg->freein_fifo_onchip_num_descs[i] +
 					nae_cfg->freein_fifo_spill_num_descs;
 
-			if ((1 << i) & lnx_normal_mask)
+			/* if jumbo enabled and port fifo is enabled, all the fifos
+			 will be filled with jumbo packets as the ucore cannot select
+			 the fifos */
+			if(lnx_jumbo_mask[node] && nae_cfg->port_fifo_en) {
+				lnx_jumbo_mask[node] |= lnx_normal_mask[node];
+				lnx_normal_mask[node] = 0;
+			}
+
+			if ((1 << i) & lnx_normal_mask[node])
 				num_descs = (num_descs_per_normalq <=
 					max_descs_pqueue) ?
 					num_descs_per_normalq :
 					max_descs_pqueue;
-			else if ((1 << i) & lnx_jumbo_mask)
+			else if ((1 << i) & lnx_jumbo_mask[node])
 				num_descs = (num_descs_per_jumboq <=
 					max_descs_pqueue) ?
 					num_descs_per_jumboq :
@@ -803,7 +820,7 @@ static void nlm_enable_l3_l4_parser(int node)
 #ifdef CONFIG_NLM_NET_OPTS
 /* Get the hardware replenishment queue id */
 static int get_hw_frfifo_queue_id(int rxnode, nlm_nae_config_ptr nae_cfg,
-				  int cpu, uint32_t truesize)
+				  int cpu, uint32_t truesize, int hw_port_id)
 {
 	/*
 	 * We have to use the logical map here as the below arrays are
@@ -812,11 +829,15 @@ static int get_hw_frfifo_queue_id(int rxnode, nlm_nae_config_ptr nae_cfg,
 	int qid;
 	int node_cpu = __cpu_number_map[cpu] % NLM_NCPUS_PER_NODE;
 
-	qid = cpu_2_normal_frfifo[rxnode][node_cpu];
+	if(nae_cfg->port_fifo_en) {
+		qid = hw_port_id;
+	} else {
+		qid = cpu_2_normal_frfifo[rxnode][node_cpu];
 
-	if (enable_jumbo)
-		if(truesize > NLM_RX_JUMBO_BUF_SIZE)
-			qid = cpu_2_jumbo_frfifo[rxnode][node_cpu];
+		if (enable_jumbo)
+			if(truesize > NLM_RX_JUMBO_BUF_SIZE)
+				qid = cpu_2_jumbo_frfifo[rxnode][node_cpu];
+	}
 	/*
 	 * all the nodes vfbtable should be filled with starting node of
 	 * 0 to ending node with 20 entries each
@@ -827,7 +848,7 @@ static int get_hw_frfifo_queue_id(int rxnode, nlm_nae_config_ptr nae_cfg,
 #endif
 
 int mac_refill_frin_skb(int node, int cpu, uint64_t paddr,
-			       uint32_t bufsize)
+			       uint32_t bufsize, int hw_port_id)
 {
 	/*
 	 * We have to use the logical map here as the below arrays are
@@ -838,16 +859,19 @@ int mac_refill_frin_skb(int node, int cpu, uint64_t paddr,
 	int node_cpu = __cpu_number_map[cpu] % NLM_NCPUS_PER_NODE;
 	ulong __attribute__ ((unused)) mflags;
 
-
-	qid = (bufsize >= NLM_RX_JUMBO_BUF_SIZE) ?
-		cpu_2_jumbo_frfifo[node][node_cpu] :
-		cpu_2_normal_frfifo[node][node_cpu];
-
 	nae_cfg = nlm_node_cfg.nae_cfg[node];
 	if (nae_cfg == NULL) {
 		printk("%s Error, Invalid node id %d\n", __FUNCTION__, node);
 		return -1;
 	}
+
+	if(nae_cfg->port_fifo_en) 
+		qid = hw_port_id;
+	else
+		qid = (bufsize >= NLM_RX_JUMBO_BUF_SIZE) ?
+		cpu_2_jumbo_frfifo[node][node_cpu] :
+		cpu_2_normal_frfifo[node][node_cpu];
+
 	Message("%s in cpu %d bufsize %d node %d qid %d qbase %d\n",
 		__FUNCTION__, cpu, bufsize, node, qid,
 		nae_cfg->frin_queue_base);
@@ -893,7 +917,7 @@ int mac_refill_frin_one_buffer(struct net_device *dev, int cpu,
 	mac_put_skb_back_ptr(skb);
 
 	return mac_refill_frin_skb(priv->node, cpu,
-		(uint64_t)virt_to_bus(skb->data), buf_size);
+		(uint64_t)virt_to_bus(skb->data), buf_size, priv->hw_port_id);
 }
 
 /**********************************************************************
@@ -1301,7 +1325,6 @@ static int nlm_per_port_nae_init(int node, int port,
 	xlp_dev_mac[node][port] = dev;
 	xlp_mac_setup_hwaddr(priv);
 
-	dummy_pktdata_addr[node] = nae_cfg->dummy_pktdata_addr;
 
 	for (cpu = 0; cpu < NR_CPUS; cpu++)
 		per_cpu_netdev[node][cpu][port] = dev;
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_rx.c b/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
index 7b3cec6..2523438 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
@@ -72,10 +72,6 @@ inline void process_tx_complete(int cpu, uint32_t src_id, uint64_t msg0)
         node = (src_id >> 10) & 0x3;
         port = *(cntx2port[node] + context);
 
-        if (addr == dummy_pktdata_addr[node]){
-                printk("Dropping firmware RX packet (addr=%llx)!\n", addr);
-                return;
-        }
 
 #ifdef TSO_ENABLED
         if(nlm_mode[CPU_INDEX(cpu)] == NLM_TCP_MODE){
@@ -599,19 +595,7 @@ static inline void process_rx_packets(int cpu, unsigned int src_id,
 	Message("%s in cpu %d src_id %d len %d context %d node %d err %d\n",
 		__func__, cpu, src_id, len, context, node, err);
 
-	if (err) {
-
-		vaddr = (uint64_t)(unsigned long)bus_to_virt(addr);
-		skb = mac_get_skb_back_ptr(vaddr);
-		mac_refill_frin_skb(node, cpu, addr, skb->truesize);
-		err_replenish_count[CPU_INDEX(cpu)]++;
-		return;
-	}
 
-	if (addr == dummy_pktdata_addr[node]) {
-		printk("Dropping firmware RX packet (addr=%llx)!\n", addr);
-		return;
-	}
 	port = *(cntx2port[node] + context);
 
 #ifdef ENABLE_SANITY_CHECKS
@@ -632,6 +616,16 @@ static inline void process_rx_packets(int cpu, unsigned int src_id,
 #endif
 	priv = netdev_priv(pdev);
 
+	if (err) {
+
+		vaddr = (uint64_t)(unsigned long)bus_to_virt(addr);
+		skb = mac_get_skb_back_ptr(vaddr);
+		mac_refill_frin_skb(node, cpu, addr, skb->truesize, priv->hw_port_id);
+		err_replenish_count[CPU_INDEX(cpu)]++;
+		return;
+	}
+
+
 	vaddr = (uint64_t)(unsigned long)bus_to_virt(addr);
 	
 	len = len  - ETH_FCS_LEN - nlm_prepad_len;
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_tx.c b/drivers/net/ethernet/broadcom/nae/xlpge_tx.c
index 42d7bf9..326f038 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_tx.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_tx.c
@@ -45,8 +45,6 @@ uint64_t fast_replenish_count[NR_CPUS * 8] __cacheline_aligned;
 uint64_t slow_replenish_count[NR_CPUS * 8] __cacheline_aligned;
 uint64_t err_replenish_count[NR_CPUS * 8] __cacheline_aligned;
 
-extern uint64_t dummy_pktdata_addr[NLM_MAX_NODES];
-
 /**********************************************************************
  * nlm_xlp_nae_start_xmit -  transmit a packet from buffer
  * @dev  -  this is per device based function
@@ -92,7 +90,7 @@ int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		last_rcvd_len[CPU_INDEX(cpu)] = 0;
 
 		qid = get_hw_frfifo_queue_id(last_rcvd_node[CPU_INDEX(cpu)],
-			nae_cfg, cpu, skb->truesize);
+			nae_cfg, cpu, skb->truesize, priv->hw_port_id);
 		msg0 = nae_tx_desc(P2D_NEOP, 0, qid,
 				0, last_rcvd_skb_phys[CPU_INDEX(cpu)]);
 		hw_repl = 1;
-- 
1.9.1

