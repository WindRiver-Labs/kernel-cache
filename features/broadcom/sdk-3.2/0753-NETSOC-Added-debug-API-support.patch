From 0fbf3a186a8b0fbc7d73d271998f643248742de7 Mon Sep 17 00:00:00 2001
From: Jayanthi A <jayanthi.annadurai@broadcom.com>
Date: Mon, 22 Jul 2013 17:33:35 -0700
Subject: [PATCH 0753/1532] NETSOC: Added debug API support

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/netlib/include/netsoc_dbg.h | 1195 ++++++++++++++++++++
 arch/mips/netlogic/lib/netlib/src/netsoc_dbg.c     |  104 +-
 2 files changed, 1266 insertions(+), 33 deletions(-)
 create mode 100644 arch/mips/netlogic/lib/netlib/include/netsoc_dbg.h

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_dbg.h b/arch/mips/netlogic/lib/netlib/include/netsoc_dbg.h
new file mode 100644
index 0000000..792f051
--- /dev/null
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_dbg.h
@@ -0,0 +1,1195 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+/*
+  ================================================================================
+  NAE debug api
+  ================================================================================
+*/
+#include "netsoc_dev.h"
+#include "nlm_hal_macros.h"
+#include "netsoc_haliface.h"
+#include "netsoc_libiface.h"
+#include "netsoc_poe.h"
+#include "netsoc_nae.h"
+
+const char *nae_rxperf_events[];
+const char *nae_txperf_events[];
+/*
+ * poe statistic registers 0xa8 - 0xb3
+ *
+ */
+static inline uint32_t get_poe_statistic_reg_num(void)
+{
+    return EXT_BUF_ALLOC_CNT_HI - OO_MSG_CNT_LO + 1;
+}
+
+static inline const char* get_poe_statistic_reg_name(uint32_t idx)
+{
+    static const char* poe_statistic_regs[] =
+    { "OOO_MSG_CNT_LO",
+      "IN_ORDER_MSG_CNT_LO",
+      "LOC_BUF_STOR_CNT_LO",
+      "EXT_BUF_STOR_CNT_LO",
+      "LOC_BUF_ALLOC_CNT_LO",
+      "EXT_BUF_ALLOC_CNT_LO",
+      "OOO_MSG_CNT_HI",
+      "IN_ORDER_MSG_CNT_HI",
+      "LOC_BUF_STOR_CNT_HI",
+      "EXT_BUF_STOR_CNT_HI",
+      "LOC_BUF_ALLOC_CNT_HI",
+      "EXT_BUF_ALLOC_CNT_HI",
+      "MODE_ERR_FLOW_ID",
+      "POE_STATISTICS_EN",
+      "POE_MAX_SIZE_FLOW",
+      "POE_MAX_SIZE",
+    };
+    return poe_statistic_regs[idx-OO_MSG_CNT_LO];
+}
+
+/**
+* @brief netsoc_get_num_naerxcounters function returns the number of ingress counters in NAE  
+* @param [in] nae pointer to nae_t 
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_get_num_naerxcounters(nae_t *nae)
+{
+    /* how to get naerxcounters? */
+    return 8;
+}
+
+/*
+ * distribution vector drop counter registers 0x100 - 0x10F
+ *
+ */
+static inline uint32_t get_poe_drop_cnt_reg_num(void)
+{
+    return 16;
+}
+
+static uint32_t get_poe_err_cnt_reg_base(void)
+{
+    return 0x186;
+}
+
+static uint32_t get_poe_err_cnt_reg_num(void)
+{
+    return 0x191 - get_poe_err_cnt_reg_base();
+}
+
+static const char* get_poe_err_cnt_reg_name(uint32_t idx)
+{
+    static const char* poe_err_cnt_regs[] =
+    {
+        "FBP Ecc error count",
+        "Msg store Ecc error count",
+        "Flow info Ecc error count",
+        "Msg info Ecc error count",
+        "Linked list Ecc error count",
+        "Size Ecc error count",
+        "FMN Tx Ecc error count",
+        "Enq spill input Ecc error count",
+        "Enq spill output Ecc error count",
+        "Deq spill output Ecc error count",
+        "Enq message sent",
+        "Enq message count"
+    };
+    return poe_err_cnt_regs[idx-0x186];
+}
+
+
+typedef uint32_t (*nae_reg_read)(nae_t* nae, int idx);
+
+/**
+* @brief netsoc_get_naerx_counter function returns the NAE ingress counter value   
+* @param [in] nae pointer to nae_t
+* @param [in] counter_num ingress counter number
+* @param [in] val uint64_t pointer to return the counter value 
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_get_naerx_counter(nae_t *nae, uint32_t counter_num, uint32_t *val)
+{
+    /* 64 or 32 bit result? */
+    netsoc_write_nae_reg(nae->nae_base, RX_PERF_CTR_CFG, ((1 << 31) | (counter_num << 1)));
+    *val = netsoc_read_nae_reg(nae->nae_base, RX_PERF_CTR_VAL);
+    return NETSOC_API_SUCCESS;
+}
+
+static int netsoc_get_naerx_counter_setting(nae_t *nae, uint32_t counter_num, uint32_t *val)
+{
+    /* 64 or 32 bit result? */
+    netsoc_write_nae_reg(nae->nae_base, RX_PERF_CTR_CFG, ((1 << 31) | (counter_num << 1) | 1));
+    *val = netsoc_read_nae_reg(nae->nae_base, RX_PERF_CTR_VAL);
+    return NETSOC_API_SUCCESS;
+}
+
+/*
+ * Generic routine to read NAE config and print to designated buf
+ */
+static int netsoc_printbuf_config(nae_t *nae, 
+                                  uint32_t ix_bgn,
+                                  uint32_t ix_end,
+                                  nae_reg_read read_op,
+                                  char *buf,
+                                  unsigned int len, char *config_str)
+{
+    char loc_buf[32];
+    int num_printed = 0;
+    int total_printed = 0;
+
+    uint32_t reg_ix;
+    uint32_t value = 0;
+
+    for(reg_ix = ix_bgn; reg_ix < ix_end; ++reg_ix) {
+        value = read_op(nae, reg_ix);
+        /* may consider using snprintf, and not use loc_buf*/
+        num_printed = sprintf(loc_buf, "%s %d : %d\n", config_str, reg_ix, value);
+        if (num_printed <= (len - total_printed)) {
+            strcpy(buf + total_printed, loc_buf);
+            total_printed += num_printed;
+        } else {
+            return -1; /* result is not complete due to buffer size*/
+        }
+    }
+    return total_printed;
+}
+
+/*
+ * Generic routine to read NAE config and print to stdout
+ */
+static int netsoc_print_config(nae_t *nae, 
+                               uint32_t ix_bgn,
+                               uint32_t ix_end,
+                               nae_reg_read read_op, char *config_str)
+{
+    uint32_t reg_ix;
+    uint32_t value = 0;
+
+    for(reg_ix = ix_bgn; reg_ix < ix_end; ++reg_ix) {
+        value = read_op(nae, reg_ix);
+        netsoc_api_print(NETSOC_APIDBG_CONFIG, "%s %d : %d\n", config_str, reg_ix, value);
+    }
+    return NETSOC_API_SUCCESS;
+}
+
+/*
+ * Routines to read NAE registers
+ */
+static uint32_t vfbid_read(nae_t *nae, int vfbid)
+{
+    uint32_t rval, i = 1000;
+    netsoc_write_nae_reg(nae->nae_base, VFBID_TO_DEST_MAP_CMD, (vfbid << 4)); 
+    while (i) {
+	rval = netsoc_read_nae_reg(nae->nae_base, VFBID_TO_DEST_MAP_STATUS);
+	if (rval & 0x1)
+	   break;
+        i--;	
+    }
+    if (!i) {
+        netsoc_api_print(NETSOC_APIDBG_DEFAULT, "VFBID_DESTMAP_STATUS returned Invalid data 0x%x for vfbid %d\n", rval, vfbid);
+        return -1;
+    }
+    return ((rval >> 4) & 0xfff);
+}
+
+
+static uint32_t rx_if_slot_cal_read(nae_t *nae, int slot)
+{
+    uint32_t val;
+
+    netsoc_write_nae_reg(nae->nae_base, RX_IFACE_SLOT_CAL, (1<<31) | ((nae->rx_cal_slots - 1) << 16) | (slot & 0x3f));
+    val = netsoc_read_nae_reg(nae->nae_base, RX_IFACE_SLOT_CAL);
+    return ((val >> 8) & 0x1f);
+}
+
+
+static uint32_t tx_if_slot_cal_read(nae_t *nae, int slot)
+{
+    uint32_t rval, i = 1000;
+    netsoc_write_nae_reg(nae->nae_base, EGR_NIOR_CRDT_CAL_PROG,  (slot << 1) | 0x0);
+
+    while(i) {
+         rval = netsoc_read_nae_reg(nae->nae_base, EGR_NIOR_CRDT_STATUS);
+         if (rval & 0x1) 
+            break;
+         i--;
+    }
+    if (!i) {
+        netsoc_api_print(NETSOC_APIDBG_DEFAULT, "EGR_NIOR_CRDT_STATUS returned Invalid data 0x%x for intf %d\n", rval, slot); 
+        return -1;
+    }
+
+    return ((rval >>1) & 0x1f);
+}
+
+static uint32_t freein_lifo_onchip_read(nae_t *nae, int lifo_num)
+{
+	return __netsoc_get_free_desc(nae, lifo_num/2);
+}
+
+static uint32_t freein_lifo_spill_read(nae_t *nae, int lifo_num)
+{
+	return __netsoc_get_free_spill_desc(nae, lifo_num);
+}
+
+static int netsoc_set_naerx_counter_util(nae_t *nae, uint32_t counter_num, uint32_t event, uint32_t index, uint32_t ena)
+{
+    /* TODO: add 0xa0, 0xa1 definition to "netsoc_dev.h" */
+    uint32_t val = 0;
+    netsoc_write_nae_reg(nae->nae_base, RX_PERF_CTR_CFG, ((counter_num << 1) | 1)); 
+    val = event & 0x1f;
+    val |= (index << 8);
+    val |= (ena << 21);
+    netsoc_write_nae_reg(nae->nae_base, RX_PERF_CTR_VAL, val);
+    return NETSOC_API_SUCCESS;
+}
+
+/*
+ * given event_num and index, find the corresponding counter_num 
+ */
+static int get_naerx_counter_num(nae_t* nae, uint32_t event_num, uint32_t index, uint32_t* counter_num)
+{
+    int ret = -1;
+    uint32_t ix, num = netsoc_get_num_naerxcounters(nae);
+    uint32_t val, event, eidx;
+    for(ix = 0; ix < num; ++ix) {
+        netsoc_get_naerx_counter_setting(nae, ix, &val);
+        event = val & 0x1f;
+        eidx = (val >> 8) & 0x1fff;
+        if ((event == event_num) && (eidx == index)) {
+            *counter_num = ix;
+            ret = NETSOC_API_SUCCESS;
+            break;
+        }
+    }
+    return ret;
+}
+
+static int netsoc_set_naetx_counter_util(nae_t *nae, uint32_t counter, uint32_t event, uint32_t index, uint32_t ena)
+{
+    uint32_t val = ena; 
+
+    if (event == 6)
+        index = 0x3ff;
+
+    netsoc_write_nae_reg(nae->nae_base, (TX_PERF_CNTR_0 + counter * 2), 0xffffffff);
+    val = ((event & 0x1f) << 4);
+    val |= ((index & 0x3ff) << 16) | ena;
+    netsoc_write_nae_reg(nae->nae_base, (TX_PERF_CTRL_0 + counter * 2), val);
+    return NETSOC_API_SUCCESS;
+}
+
+/**
+* @brief netsoc_printbuf_vfbid_config function prints the destination ids configured in VFBID table
+* into a buffer passed to this function
+* @param [in] nae pointer to nae_t 
+* @param [in] buf pointer to buffer
+* @param [in] len buffer length
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_printbuf_vfbid_config(nae_t *nae, char *buf, unsigned int len)
+{
+    return netsoc_printbuf_config(nae,  0, MAX_VFBID_ENTRIES, vfbid_read, buf, len ,"VFBID entry ");
+}
+
+/**
+* @brief netsoc_printbuf_rxcal_config function prints the receive calendar configuration into a buffer passed to this function
+* @param [in] nae pointer to nae_t  
+* @param [in] buf pointer to buffer
+* @param [in] len buffer length
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_printbuf_rxcal_config(nae_t *nae, char *buf, unsigned int len)
+{
+    return netsoc_printbuf_config(nae, 0, nae->rx_cal_slots, rx_if_slot_cal_read, buf, len, "Rxcal mapping for slot ");
+}
+
+
+/**
+* @brief  netsoc_printbuf_txcal_config function prints the transmit calendar configuration into a buffer passed to this function
+* @param [in] nae pointer to nae_t  
+* @param [in] buf pointer to buffer
+* @param [in] len buffer length
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_printbuf_txcal_config(nae_t *nae, char *buf, unsigned int len)
+{
+    uint32_t val = netsoc_read_nae_reg(nae->nae_base, EGR_NIOR_CAL_LEN_REG);
+    uint32_t cal_len = (val & 0x3f) + 1;
+    return netsoc_printbuf_config(nae, 0, cal_len, tx_if_slot_cal_read, buf, len, "Txcal mapping for slot ");
+}
+
+/**
+* @brief netsoc_printbuf_freein_lifostatus function prints the number of on chip descriptors and spill descriptors in FRIN LIFO into a buffer passed to this function
+* @param [in] nae pointer to nae_t  
+* @param [in] buf pointer to buffer
+* @param [in] len buffer length
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_printbuf_freein_lifostatus(nae_t *nae, char *buf, unsigned int len)
+{
+    int total_printed;
+
+    total_printed = netsoc_printbuf_config(nae, 0, nae->frin_total_queue, freein_lifo_onchip_read, buf, len, "onchip descs count-LIFO");
+    if (total_printed < 0)
+	return -1;
+    return netsoc_printbuf_config(nae, 0, nae->frin_total_queue, freein_lifo_spill_read,
+				buf+total_printed, len - total_printed, "spill desc count-LIFO"); 
+}
+
+
+/**
+* @brief netsoc_print_vfbid_config function prints the vfbid table 
+* @param [in]  nae pointer to nae_t
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_print_vfbid_config(nae_t *nae)
+{
+    return netsoc_print_config(nae,  0, MAX_VFBID_ENTRIES, vfbid_read, "VFBID entry ");
+}
+
+
+/**
+* @brief netsoc_print_rxcal_config function prints the receive calendar configuration 
+* @param [in] nae pointer to nae_t  *
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_print_rxcal_config(nae_t *nae)
+{
+    return netsoc_print_config(nae, 0, nae->rx_cal_slots, rx_if_slot_cal_read, "Rxcal mapping for slot ");
+}
+
+/**
+* @brief netsoc_print_txcal_config function prints the transmit calendar configuration
+* @param [in] nae pointer to nae_t  
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_print_txcal_config(nae_t *nae)
+{
+    uint32_t val = netsoc_read_nae_reg(nae->nae_base, EGR_NIOR_CAL_LEN_REG);
+    uint32_t cal_len = (val & 0x3f) + 1;
+    return netsoc_print_config(nae, 0, cal_len, tx_if_slot_cal_read, "Txcal mapping for slot ");
+}
+
+/**
+* @brief netsoc_print_freein_lifostatus function prints the number of on chip descriptors and spill descriptors in FRIN LIFO
+* @param [in] nae pointer to nae_t  
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_print_freein_lifostatus(nae_t *nae)
+{
+    netsoc_print_config(nae, 0, nae->frin_total_queue, freein_lifo_onchip_read, "onchip descs count-LIFO");
+    netsoc_print_config(nae, 0, nae->frin_total_queue, freein_lifo_spill_read, "spill desc count-LIFO");
+
+    return NETSOC_API_SUCCESS;	
+}
+
+/**
+* @brief netsoc_set_naerx_counter functions sets the event to be counted 
+* @param [in] nae pointer to nae_t
+* @param [in] counter_num ingress counter number
+* @param [in] event Indicates the event to be counted
+* @param [in] index Indicates the event occurring on given index(example: event to be counted based on a context
+*                   number or interface number passed in this param)
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_set_naerx_counter(nae_t *nae, uint32_t counter_num, uint32_t event, uint32_t index)
+{
+    return netsoc_set_naerx_counter_util(nae, counter_num, event, index, 1);
+}
+
+
+/**
+* @brief netsoc_config_naerx_dbgpath function configures the ingress counters with the list of events passed to 
+*        this function. 
+* @param [in] nae pointer to nae_t
+* @param [in] event_num pointer to array of events
+* @param [in] max_events maximum number of events in the event_num array. This must not exceed the maximum number
+*             of ingress counters  
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_config_naerx_dbgpath(nae_t *nae, uint32_t *event_num, uint32_t max_events)
+{
+    uint32_t event, max_counter = netsoc_get_num_naerxcounters(nae);
+    
+    if (max_events > max_counter)
+	max_events = max_counter;
+		
+    for(event = 0; event < max_events; ++event) {
+        /* config the counter (with eventIx as the counterNum), but not enabled it yet */
+        netsoc_set_naerx_counter_util(nae, event, event_num[event], 0, 0); 
+    }
+    return NETSOC_API_SUCCESS;
+}
+
+/**
+* @brief netsoc_enable_naerx_dbgpath function enables the ingress counters to count the configured events  
+* @param [in] nae pointer to nae_t 
+* @param [in] index Ingress events are indexed by this param. The same index is applied to all the events configured
+*             using netsoc_config_naerx_dbgpath 
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_enable_naerx_dbgpath(nae_t *nae, uint32_t index)
+{
+    uint32_t cnt_setting, event;
+    int ix;
+
+    for(ix=0; ix < netsoc_get_num_naerxcounters(nae); ix++) {   	
+    	netsoc_get_naerx_counter_setting(nae, ix, &cnt_setting);
+	event = cnt_setting & 0x1f;
+        netsoc_set_naerx_counter_util(nae, ix, event, index, 1);
+    }	
+    return NETSOC_API_SUCCESS;
+}
+
+/**
+* @brief netsoc_printbuf_naerx_dbgpath function prints the ingress event numbers and counter values into a buffer 
+*        passed to this function.
+* @param [in] nae pointer to nae_t
+* @param [in] buf pointer to char buffer to return the debug dump
+* @param [in] len buffer length 
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_printbuf_naerx_dbgpath(nae_t *nae, char *buf, int len)
+{
+    char loc_buf[128];
+    int num_printed = 0;
+    int total_printed = 0, event;
+    
+    /* if s/w maintain a mapping between counter_num and <event, index>, simply do a loop to print*/
+    int ret;
+    uint32_t ix = 0, cnt_setting = 0, cnt_val = 0;
+    uint32_t num_counters = netsoc_get_num_naerxcounters(nae);    
+
+    for(; ix < num_counters; ++ix) {
+        if ((ret = netsoc_get_naerx_counter_setting(nae, ix, &cnt_setting)) != NETSOC_API_SUCCESS) {
+            return ret;
+        }
+	if (!((cnt_setting >> 21) & 0x1))
+		continue;
+        if ((ret = netsoc_get_naerx_counter(nae, ix, &cnt_val)) != NETSOC_API_SUCCESS) {
+            return ret;
+        }
+
+	event = cnt_setting & 0x1F;   
+        num_printed = sprintf(loc_buf, "%s : %d\n", nae_rxperf_events[event], cnt_val);
+        if (num_printed <= (len - total_printed)) {
+            strncpy(buf + total_printed, loc_buf, num_printed);
+            total_printed += num_printed;
+        } else {
+            return -1; /* result is not complete due to buffer size*/
+        }
+    }
+    return NETSOC_API_SUCCESS;
+}
+
+/**
+* @brief netsoc_print_naerx_dbgpath function prints the ingress event numbers and counter values   
+* @param [in] nae pointer to nae_t 
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_print_naerx_dbgpath(nae_t *nae)
+{
+    char loc_buf[512];
+    int ret = netsoc_printbuf_naerx_dbgpath(nae, loc_buf, sizeof(loc_buf));
+    netsoc_api_print(NETSOC_APIDBG_CONFIG, "%s\n", loc_buf);
+    return ret;
+}
+
+/**
+* @brief netsoc_disable_naerx_counter function disables the NAE ingress counter
+* @param [in] nae pointer to nae_t 
+* @param [in] counter_num NAE ingress counter number
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_disable_naerx_counter(nae_t *nae, uint32_t counter_num)
+{
+    uint32_t val, event, index;
+    netsoc_get_naerx_counter_setting(nae, counter_num, &val);
+    event = val & 0x1f;
+    index = (val >> 8) & 0x1fff;
+    netsoc_set_naerx_counter_util(nae, counter_num, event, index, 0);
+    return NETSOC_API_SUCCESS;
+}
+
+
+/**
+* @brief netsoc_get_num_naetxcounters function returns the number of egress counters in NAE  
+* @param [in] nae pointer to nae_t 
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_get_num_naetxcounters(nae_t *nae)
+{
+    return 5;
+}
+
+/**
+* @brief netsoc_set_naetx_counter functions sets the event to be counted 
+* @param [in] nae pointer to nae_t
+* @param [in] counter_num egress counter number
+* @param [in] event Indicates the event to be counted
+* @param [in] index Indicates the event occurring on given index(example: event to be counted based on a context
+*                   number or interface number passed in this param)
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_set_naetx_counter(nae_t *nae, uint32_t counter, uint32_t event, uint32_t index)
+{
+    return netsoc_set_naetx_counter_util(nae, counter, event, index, 1);
+}
+
+/**
+* @brief netsoc_get_naetx_counter function returns the NAE egress counter value   
+* @param [in] nae pointer to nae_t
+* @param [in] counter_num ingress counter number
+* @param [in] val uint64_t pointer to return the counter value 
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_get_naetx_counter(nae_t *nae, uint32_t counter_num, uint64_t *val)
+{
+    uint32_t counter_ix = TX_PERF_CNTR_0 + counter_num * 2;
+    *val = netsoc_read_nae_reg(nae->nae_base, counter_ix);
+    return NETSOC_API_SUCCESS;
+    
+}
+
+/**
+* @brief netsoc_config_naetx_dbgpath function configures the egress counters with the list of events passed to 
+*        this function. 
+* @param [in] nae pointer to nae_t
+* @param [in] event_num pointer to array of events
+* @param [in] max_events maximum number of events in the event_num array. This must not exceed the maximum number
+*             of egress counters  
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_config_naetx_dbgpath(nae_t *nae, uint32_t *event_num, uint32_t max_events)
+{
+    uint32_t ix, ret = NETSOC_API_SUCCESS, tmpret;
+
+    if (max_events > 5)
+	max_events = 5;
+
+    for(ix = 0; ix < max_events; ++ix) {
+        tmpret = netsoc_set_naetx_counter_util(nae, ix, event_num[ix], 0, 0);
+        if (tmpret != NETSOC_API_SUCCESS) {
+            ret = tmpret;            
+        }
+    }
+    return ret;
+}
+
+
+
+/**
+* @brief netsoc_enable_naetx_dbgpath function enables the egress counters to count the configured events  
+* @param [in] nae pointer to nae_t 
+* @param [in] index egress events are indexed by this param. The same index is applied to all the events configured
+*             using netsoc_config_naetx_dbgpath 
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_enable_naetx_dbgpath(nae_t *nae, uint32_t index)
+{
+    uint32_t counter_ix =  TX_PERF_CTRL_0;    
+    uint32_t val;
+    int i;
+
+    for(i=0; i < 5; i++, counter_ix+=2) {	 	
+ 	val = netsoc_read_nae_reg(nae->nae_base, counter_ix);
+	val &= ~(0x3ff << 16);
+    	val |= (index << 16) | 1; 
+    	netsoc_write_nae_reg(nae->nae_base, counter_ix, val);
+    }
+    
+    return NETSOC_API_SUCCESS;
+}
+
+    
+/**
+* @brief netsoc_printbuf_naetx_dbgpath function prints the egress event numbers and counter values into a buffer 
+*        passed to this function.
+* @param [in] nae pointer to nae_t
+* @param [in] buf pointer to char buffer to return the debug dump
+* @param [in] len buffer length 
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_printbuf_naetx_dbgpath(nae_t *nae, char *buf, int len)
+{
+    char loc_buf[80];
+    int num_printed = 0, event;
+    int total_printed = 0;
+    
+    int max_counter = netsoc_get_num_naetxcounters(nae);
+    uint32_t ix, ret = NETSOC_API_SUCCESS, setting, val;
+
+    for(ix = 0; ix < max_counter; ++ix) {
+        setting = netsoc_read_nae_reg(nae->nae_base, (TX_PERF_CTRL_0 + ix * 2));
+	if (!(setting & 0x1))
+		continue;
+	event = (setting >> 4) & 0x1f;
+        val = netsoc_read_nae_reg(nae->nae_base, (TX_PERF_CNTR_0 + ix * 2));
+
+        num_printed = sprintf(loc_buf, "%s : %d\n",nae_txperf_events[event], val);
+    
+        if (num_printed <= (len - total_printed)) {
+            strncpy(buf + total_printed, loc_buf,num_printed);
+            total_printed += num_printed;
+        } else {
+            return -1; /* result is not complete due to buffer size*/
+        }
+    }
+    return ret;
+}
+
+/**
+* @brief netsoc_print_naetx_dbgpath function prints the egress event numbers and counter values   
+* @param [in] nae pointer to nae_t 
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_print_naetx_dbgpath(nae_t *nae)
+{
+    char loc_buf[256];
+    int ret = netsoc_printbuf_naetx_dbgpath(nae, loc_buf, sizeof(loc_buf));
+    netsoc_api_print(NETSOC_APIDBG_CONFIG, "%s\n", loc_buf);
+    return ret;
+}
+
+/**
+* @brief netsoc_disable_naetx_counter function disables NAE egress counter 
+* @param [in]  nae Pointer to nae_t
+
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_disable_naetx_counter(nae_t *nae, uint32_t counter_num)
+{
+    uint32_t counter_ix = TX_PERF_CTRL_0 + (counter_num * 2);
+    uint32_t val = netsoc_read_nae_reg(nae->nae_base, counter_ix);
+    
+    val &= ~(0x1); 
+    netsoc_write_nae_reg(nae->nae_base, counter_ix, val);
+    
+    return NETSOC_API_SUCCESS;
+}
+
+
+/**
+* @brief netsoc_print_port_stats function prints the MAC statistics
+* @param [in] netport Pointer to net_port_t
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+
+static int netsoc_print_port_stats(net_port_t *netport)
+{
+    /* TODO */
+    return NETSOC_API_SUCCESS;
+}
+
+/*
+  ================================================================================
+  POE debug api
+  ================================================================================
+*/
+
+/**
+* @brief netsoc_enable_poe_statistics function enables POE statistics counters  
+* @param [in] poe pointer to poe_t 
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static inline int netsoc_enable_poe_statistics(poe_t *poe)
+{
+    return __netsoc_enable_poe_statistics(poe);
+}
+
+static inline int netsoc_disable_poe_statistics(poe_t *poe)
+{
+    return __netsoc_disable_poe_statistics(poe);	
+}
+
+/**
+* @brief netsoc_enable_poe_drop function enables packet drop at POE level 
+* @param [in] poe pointer to poe_t 
+* @param [in] drop_mode Distribution vector drop or class drop
+* @param [in] index - distribution vector number or class number
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_enable_poe_drop(poe_t *poe, poe_drop_type_t drop_mode, int index)
+{
+    uint64_t poebase = poe->pcie_base;
+    uint32_t val;
+    
+    switch(drop_mode)
+    {
+	case POE_DISTR_DROP:
+		if (index >= MAX_POE_DV)
+			return -1;
+		val = netsoc_read_poe_pcie_reg(poebase, POE_STATISTICS_EN);
+		val |= 1;
+		netsoc_write_poe_pcie_reg(poebase, POE_STATISTICS_EN, val);
+		val = netsoc_read_poe_pcie_reg(poebase, POE_DISTR_VEC_DROP_EN);
+		val |= (1<<index);
+		netsoc_write_poe_pcie_reg(poebase, POE_DISTR_VEC_DROP_EN, val);
+		break;
+	case POE_CLASS_DROP:
+		if (index >= MAX_POE_CLASS)
+			return -1;
+		val = netsoc_read_poe_pcie_reg(poebase, POE_DISTR_CLASS_DROP_EN);
+		val |= (1<<index);
+		netsoc_write_poe_pcie_reg(poebase, POE_DISTR_CLASS_DROP_EN, val);
+		break;
+	case POE_CPU_DROP:
+		//DROP using FMN message
+		break;
+	case POE_MAXFLOW_SZ_DROP:
+		val = netsoc_read_poe_pcie_reg(poebase, POE_FID_WDATA);
+		val &= ~(0x7);
+		val |= (1<<3) | (index & 0x7);
+		netsoc_write_poe_pcie_reg(poebase, POE_FID_WDATA, val); 
+		break;
+    }	
+    return  NETSOC_API_SUCCESS;
+
+}
+
+/**
+* @brief netsoc_printbuf_poe_statistics function prints POE statistics counter values into a buffer passed to this function
+* @param [in] poe pointer to poe_t
+* @param [in] buf pointer to buffer
+* @param [in] len buffer length
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_printbuf_poe_statistics(poe_t *poe, char *buf, int len)
+{
+    char loc_buf[64];
+    int num_printed = 0;
+    int total_printed = 0;
+    uint64_t poebase = poe->pcie_base;
+    uint32_t ix = 0, num = get_poe_statistic_reg_num();
+    uint32_t reg_ix = OO_MSG_CNT_LO, val;
+
+    for(reg_ix = OO_MSG_CNT_LO; ix < num; ++ix, ++reg_ix) {
+	if (reg_ix == POE_STATISTICS_EN)
+                     continue;
+        val = netsoc_read_poe_pcie_reg(poebase, reg_ix);                
+        num_printed = sprintf(loc_buf, "  %s: %d\n", get_poe_statistic_reg_name(reg_ix), val);        
+        if (num_printed <= (len - total_printed)) {
+            strcpy(buf + total_printed, loc_buf);
+            total_printed += num_printed;
+        } else {
+            return -1; /* result is not complete due to buffer size*/
+        }
+    }
+    return NETSOC_API_SUCCESS;
+}
+
+/**
+* @brief netsoc_print_poe_statistics function prints POE statistics counter values
+* @param [in] poe pointer to poe_t
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_print_poe_statistics(poe_t *poe)
+{
+    char loc_buf[1024];
+    int ret = netsoc_printbuf_poe_statistics(poe, loc_buf, sizeof(loc_buf));
+    netsoc_api_print(NETSOC_APIDBG_CONFIG, "%s\n", loc_buf);
+    return ret;
+}
+
+/**
+* @brief netsoc_printbuf_poe_dropcounters function prints POE drop counter values into a buffer passed to this function
+* @param [in] poe pointer to poe_t
+* @param [in] buf pointer to buffer
+* @param [in] len buffer length
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_printbuf_poe_dropcounters(poe_t *poe, char *buf, int len)
+{
+    char loc_buf[64];
+    int num_printed = 0;
+    int total_printed = 0;
+    uint64_t poebase = poe->pcie_base;
+    uint32_t ix = 0, num = get_poe_drop_cnt_reg_num();
+    uint32_t reg_ix = 0x100, val;
+
+    for(reg_ix = 0x100; ix < num; ++ix, ++reg_ix) {
+        val = netsoc_read_poe_pcie_reg(poebase, reg_ix);;
+        num_printed = sprintf(loc_buf, "  DISTR_%d_DROP_CNT: %d\n", ix, val);
+        if (num_printed <= (len - total_printed)) {
+            strncpy(buf + total_printed, loc_buf, num_printed);
+            total_printed += num_printed;
+        } else {
+            return -1; /* result is not complete due to buffer size*/
+        }
+    }
+    return NETSOC_API_SUCCESS;
+
+}
+
+
+/**
+* @brief  netsoc_print_poe_dropcounters function prints POE drop counter values
+* @param [in] poe pointer to poe_t 
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_print_poe_dropcounters(poe_t *poe)
+{
+    char loc_buf[1024];
+    int ret = netsoc_printbuf_poe_dropcounters(poe, loc_buf, sizeof(loc_buf));
+    netsoc_api_print(NETSOC_APIDBG_CONFIG, "%s\n", loc_buf);
+    return ret;
+}
+
+/**
+* @brief  netsoc_clear_poe_statistics function clears POE counter
+* @param [in] poe pointer to poe_t
+* @param [in] poe_stats_reg_t enum to identify the counter type
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_clear_poe_statistics(poe_t *poe, poe_stats_t counter)
+{
+    uint64_t poebase = poe->pcie_base;
+    uint32_t reg;
+
+    switch(counter)
+    {
+       	case POE_LOCBUF_STATS:
+	     netsoc_write_poe_pcie_reg(poebase, LOC_BUF_STOR_CNT_LO, 0);
+	     netsoc_write_poe_pcie_reg(poebase, LOC_BUF_STOR_CNT_HI, 0);
+	     netsoc_write_poe_pcie_reg(poebase, LOC_BUF_ALLOC_CNT_LO, 0);
+	     netsoc_write_poe_pcie_reg(poebase, LOC_BUF_ALLOC_CNT_HI, 0);
+	     break;
+       	case POE_EXTBUF_STATS:
+	     netsoc_write_poe_pcie_reg(poebase, EXT_BUF_STOR_CNT_LO, 0);
+	     netsoc_write_poe_pcie_reg(poebase, EXT_BUF_STOR_CNT_HI, 0);
+	     netsoc_write_poe_pcie_reg(poebase, EXT_BUF_ALLOC_CNT_LO, 0);
+	     netsoc_write_poe_pcie_reg(poebase, EXT_BUF_ALLOC_CNT_HI, 0);
+	     break;
+	case POE_INORD_MSGCNT_STATS:
+	     netsoc_write_poe_pcie_reg(poebase, IN_ORDER_MSG_CNT_LO, 0);
+	     netsoc_write_poe_pcie_reg(poebase, IN_ORDER_MSG_CNT_HI, 0);
+	     break;
+        case POE_OUTORD_MSGCNT_STATS:
+	     netsoc_write_poe_pcie_reg(poebase, OO_MSG_CNT_LO, 0);
+	     netsoc_write_poe_pcie_reg(poebase, OO_MSG_CNT_HI, 0);
+	     break;
+     	case POE_ALL_STATS:
+	     for(reg=OO_MSG_CNT_LO; reg <= POE_MAX_SIZE; reg++) {
+		if (reg == POE_STATISTICS_EN)
+		     continue;
+                netsoc_write_poe_pcie_reg(poebase, reg, 0);
+	     } 
+             break;
+	default:
+		return -1;
+    }
+    return NETSOC_API_SUCCESS;
+}
+
+/**
+* @brief netsoc_printbuf_poe_msgcount function prints the POE TX and RX FMN message counter
+	into a buffer passed to this function
+* @param [in] pointer to poe_t
+* @param [in] buf pointer to buffer
+* @param [in] len buffer length
+*
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_printbuf_poe_msgcount(poe_t *poe, char *buf, int len)
+{
+    char loc_buf[64];
+    int num_printed = 0;
+    int total_printed = 0;
+    uint64_t poebase = poe->pcie_base;
+    uint32_t val;
+
+    val = netsoc_read_poe_pcie_reg(poebase, POE_FMN_TX_CNTR);
+    num_printed = sprintf(loc_buf, "POE FMN-Tx count %d\n",val);
+    if (num_printed <= (len - total_printed)) {
+          strcpy(buf + total_printed, loc_buf);
+          total_printed += num_printed;
+    } else {
+          return -1; /* result is not complete due to buffer size*/
+    }	
+    val = netsoc_read_poe_pcie_reg(poebase, POE_FMN_RX_CNTR);   
+    num_printed = sprintf(loc_buf, "POE FMN-Rx count %d\n",val);
+    if (num_printed <= (len - total_printed)) {
+          strncpy(buf + total_printed, loc_buf, num_printed);
+          total_printed += num_printed;
+    } else {
+          return -1; /* result is not complete due to buffer size*/
+    }  
+    return NETSOC_API_SUCCESS;
+}
+
+/**
+* @brief netsoc_printbuf_poe_errcount function prints the POE ECC error counters
+	 into a buffer passed to this function
+* @param [in] poe pointer to poe_t
+* @param [in] buf pointer to buffer
+* @param [in] len buffer length
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_printbuf_poe_errcount(poe_t *poe, char *buf, int len)
+{
+    char loc_buf[64];
+    int num_printed = 0;
+    int total_printed = 0;
+    uint64_t poebase = poe->pcie_base;
+    uint32_t ix = 0, num = get_poe_err_cnt_reg_num();
+    uint32_t reg_ix = get_poe_err_cnt_reg_base(), val;
+
+    for(; ix < num; ++ix, ++reg_ix) {
+        val = netsoc_read_poe_pcie_reg(poebase, reg_ix);                
+        num_printed = sprintf(loc_buf, " %s: %d\n", get_poe_err_cnt_reg_name(reg_ix), val);        
+        if (num_printed <= (len - total_printed)) {
+            strncpy(buf + total_printed, loc_buf, num_printed);
+            total_printed += num_printed;
+        } else {
+            return -1; /* result is not complete due to buffer size*/
+        }
+    }
+    return NETSOC_API_SUCCESS;
+}
+
+/**
+*   @brief netsoc_printbuf_poe_errcount function prints the POE ECC error counters
+* @param [in] poe pointer to poe_t
+* @return
+* - NETSOC_API_SUCCESS on success
+* - < 0 on error
+*
+* @ingroup hal_nae
+*
+*/
+static int netsoc_print_poe_errcount(poe_t *poe)
+{
+    char loc_buf[1024];
+    int ret = netsoc_printbuf_poe_errcount(poe, loc_buf, sizeof(loc_buf));
+    netsoc_api_print(NETSOC_APIDBG_CONFIG, "%s\n", loc_buf);
+    return ret;
+}
+
+
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_dbg.c b/arch/mips/netlogic/lib/netlib/src/netsoc_dbg.c
index 449f3bd..8d9a0dd 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_dbg.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_dbg.c
@@ -29,40 +29,78 @@
 
 #include "nlm_hal.h"
 #include "nlm_nae.h"
-
-void netsoc_dump_vfbid_config(nae_t *nae, char *buf, unsigned int len)
-{
-
-}
-
-void netsoc_dump_rxcal_config(nae_t *nae, char *buf, unsigned int len)
-{
-
-
-}
-
-void netsoc_dump_txcal_config(nae_t *nae, char *buf, unsigned int len)
-{
-
-}
-
-void netsoc_dump_freein_lifoconfig(nae_t *nae, char *buf, unsigned int len)
+#include "netsoc_dbg.h"
+
+const char *nae_rxperf_events[] = {
+[0] = "NetIOR receive SOP(by port)",
+[1] = "NetIOR receive EOP(by port)",
+[2] = "NetIOR receive SOP(by {channel,port})",
+[3] = "NetIOR receive EOP(by {channel,port})",
+[4] = "NetIOR CrcErr {by channel,port}",
+[5] = "FMN receive (by msg src)",
+[6] = "FMN receive (by msg dst)",
+[7] = "FreeSpill by FRIN lifo number",
+[8] = "FreeFill by FRIN lifo number",
+[9] = "POE message read by class",
+[10] = "POE message read by context",
+[11] = "POE message discard (based on FRIN lifo number)",
+[12] = "POE message discard (by context)",
+[13] = "Ucore allocate (by context)",
+[14] = "Ucore de-alloc (by context)",
+[15] = "RxDpEOP by context",
+[16] = "Ucore allocate (by Ucore number)",
+[17] = "Ucore de-allocate (by Ucore number)",
+[18] = "UcoreAlloc by (row)",
+[19] = "Ucore de-alloc (by row)",
+[20] = "UcoreDrop by context",
+[21] = "RxDescFormEop by port",
+[22] = "Parser Sequence fifo write (by port)",
+[23] = "Parser Sequence fifo write (by context)",
+[24] = "ParserSeqFifoLtEq16Wr by port",
+[25] = "ParserSeqFifoLtEq48Wr by port",
+};
+
+const char *nae_txperf_events[] = {
+"Commands issued by STG1 scheduler",
+"DMA commands issued by STG1",
+"Descriptors leaving STG1",
+"Credits returned by STG1",
+"Credits returned by STG1 from STG2",
+"Descriptors leaving the receive FIFO",
+"Credits returned by rxReturn FIFO",
+"DMA commands issued by STG2",
+"Descriptors sent from STG2 to EhFIFO",
+"Descriptors sent from STG2 to MsFIFO",
+"Credit updates rcvd by STG2 from EhFIFO",
+"Credit updates rcvd by STG2 from free FIFO",
+"Credit updates rcvd by STG2 from MsFIFO",
+"Descriptors leaving EhFIFO",
+"Descriptors written to the FreeFIFO memory",
+"Descriptors leaving free FIFO",
+"Descriptors rejected by FMN",
+"POP commands received by MsFIFO",
+"Pkt lengths written to pktLenFIFO",
+"Words written to PktFIFO",
+"Burst scheduled by MDRR - context",
+"Burst scheduled by MDRR - port",
+"Last Burst scheduled by MDRR - context",
+"Last Burst scheduled by MDRR - port",
+"Words read from the PktFIFO",
+"Packets transmitted to interface-context",
+"Packets transmitted to interface-port",
+"Status update rcvd from interface-context",
+"Status update rcvd from interface-port",
+"PktFIFO credits returned to netDMA",
+"PktLenFIFO credits returned to netDMA",
+};
+
+
+int netsoc_print_nae_config(nae_t *nae)
 {
-
+	netsoc_print_vfbid_config(nae);
+	netsoc_print_rxcal_config(nae);
+	netsoc_print_txcal_config(nae);
+	netsoc_print_freein_lifostatus(nae);
 }
 
-void netsoc_dump_ingress_config(nae_t *nae, char *buf, unsigned int len)
-{
-
-}
-
-void netsoc_dump_egress_config(nae_t *nae, char *buf, unsigned int len)
-{
 
-}
-
-
-void netsoc_set_rx_dbg_path(nae_t *nae, unsigned int context)
-{
-
-}
-- 
1.9.1

