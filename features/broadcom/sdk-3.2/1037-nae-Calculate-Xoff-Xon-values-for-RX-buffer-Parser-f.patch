From f8e016202d4b8a97d90bab5afffb282d58e8fb05 Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikas.gupta@broadcom.com>
Date: Wed, 26 Nov 2014 13:01:33 +0530
Subject: [PATCH 1037/1532] nae: Calculate Xoff/Xon values for RX-buffer/Parser
 fifos based on formulae.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../netlogic/lib/netlib/include/netsoc_common.h    |   2 +-
 arch/mips/netlogic/lib/netlib/include/netsoc_dev.h |   8 +-
 .../netlogic/lib/netlib/include/netsoc_libiface.h  |   1 +
 arch/mips/netlogic/lib/netlib/include/nlm_nae.h    |   1 +
 arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c     |   5 +
 arch/mips/netlogic/lib/netlib/src/netsoc_nae.c     | 113 ++++++++++-----------
 arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c    |   4 +
 7 files changed, 67 insertions(+), 67 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
index 8601be8..a94dbcb 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
@@ -73,7 +73,7 @@
 #define DEFAULT_XLAUI_CAL_SLOTS         13
 
 #define DEFAULT_XLP9XX_XAUI_IFACEFIFO_SZ	120
-#define DEFAULT_XLP9XX_XAUI_RXFIFO_SZ         2032	
+#define DEFAULT_XLP9XX_XAUI_RXFIFO_SZ         1968	
 #define DEFAULT_XLP9XX_XAUI_PARSERSEQFIFO_SZ	1008 
 #define DEFAULT_XLP9XX_XAUI_NUM_FREEDESC	300
 
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
index ede061d..b681ce4 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
@@ -926,13 +926,13 @@ enum {
 #define NAE_REACTION_LEN_XAUI           1463
 #define NAE_REACTION_LEN_SGMII          1126
 #define NAE_REACTION_LEN_PARSER           14
+
 #define NAE_INFLIGHT_LEN_XAUI            504
 #define NAE_INFLIGHT_LEN_SGMII           108
+#define NAE_INFLIGHT_LEN_XLAUI          1759
+
+
 #define NAE_SMALLEST_PKT_LEN              64
-#define NAE_XAUI_THR_GROUP                 1
-#define NAE_SGMII_THR_GROUP                2
-#define NAE_RXAUI_THR_GROUP                3
-#define NAE_ILK_THR_GROUP                  4
 #define NAE_RX_THR_BYTE_UNIT              16
 #define NAE_PAUSE_TIMER_DELTA             32
 
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
index 351853a..f4ac796 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
@@ -133,6 +133,7 @@ struct netsoc_lib_param {
 	/*library params */
 	int kr_en;
 	int netsoc_debug_level;
+	uint32_t mtu_len;
 };
 
 static inline void *netsoc_api_contig_malloc(uint32_t align, uint32_t size)
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
index ef44a31..de3bc29 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -446,6 +446,7 @@ struct nlm_hal_nae_config {
 	uint32_t freein_uniq_sz;
 	uint32_t ptp1588_enabled;
 	uint32_t str_fwd_enabled;
+	uint32_t mtu_config;
         /* POE */
 	poe_t *poe;
 };
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index ae323dd..5ddf8d8 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -1172,6 +1172,11 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg, struct netsoc_lib_pa
         nae_cfg->rx_cal_slots = rx_slots;
         nae_cfg->tx_cal_slots = tx_slots;
         nae_cfg->num_contexts = max_context;
+	if(libparam->mtu_len)
+		nae_cfg->mtu_config = libparam->mtu_len;
+	else
+		 nae_cfg->mtu_config = NAE_MTU_LEN;
+	
 
 	netsoc_api_print(NETSOC_APIDBG_DEFAULT, "%s numports %d numcontexts %d\n",__func__, nae_cfg->num_ports, nae_cfg->num_contexts);
         return nae_cfg->num_ports;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index ca3513c..fca6526 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -1231,45 +1231,35 @@ void __netsoc_config_context_xoff_thr(nae_t *nae, net_port_t *netport, int thgrp
          send xoff when rx_data_buffer_used >= xoff threshold */
         int xoff, xon, val, reaction_len, inflight_len;
 
-	if(is_nlm_xlp9xx()){
-		if(netport->vlan_pri_en){
-			if(netport->iftype == XLAUI_IF){
-				val = maxbuf / 16 ;
-				xoff = ((val * 8) << 2);
-				xon = ((val * 4) << 2);
-			}else if(netport->iftype == XFI_IF){
-				val = maxbuf / 16 ;
-				xoff = ((val * 4) << 2);
-				xon = ((val * 2) << 2);
-			}else if(netport->iftype == RXAUI_IF){
-				val = maxbuf / 16 ;
-				xoff = ((val * 8) << 2);
-				xon = ((val * 4) << 2);
-			}else if(netport->iftype == SGMII_IF){
-				val = maxbuf / 16 ;
-				xoff = ((val * 4) << 2);
-				xon = ((val * 2) << 2);
-			}
-		}else{
-			val = maxbuf / 4;
-			xoff = ((val * 3) << 2);
+	if(netport->vlan_pri_en){
+		if(netport->iftype == XLAUI_IF){
+			val = maxbuf / 16 ;
+			xoff = ((val * 8) << 2);
+			xon = ((val * 4) << 2);
+		}else if(netport->iftype == XFI_IF){
+			val = maxbuf / 16 ;
+			xoff = ((val * 4) << 2);
+			xon = ((val * 2) << 2);
+		}else if(netport->iftype == RXAUI_IF){
+			val = maxbuf / 16 ;
+			xoff = ((val * 8) << 2);
+			xon = ((val * 4) << 2);
+		}else if(netport->iftype == SGMII_IF){
+			val = maxbuf / 16 ;
+			xoff = ((val * 4) << 2);
 			xon = ((val * 2) << 2);
 		}
-		val = (xoff << 3) | (xon << 17) | thgrp;
-	}
+	}else {
 
-	else {
-		maxbuf=maxbuf<<2;
-		if (netport->iftype == SGMII_IF)
-		{
-			reaction_len = NAE_REACTION_LEN_SGMII;
+		if (netport->iftype == SGMII_IF){
 			inflight_len = NAE_INFLIGHT_LEN_SGMII;
 		}
-		else
-		{
-			reaction_len = NAE_REACTION_LEN_XAUI;
-			inflight_len = NAE_INFLIGHT_LEN_XAUI;
+		else if (netport->iftype == XLAUI_IF){
+			inflight_len = NAE_INFLIGHT_LEN_XLAUI;
 		}
+		else{
+			inflight_len = NAE_INFLIGHT_LEN_XAUI;
+		}	
 
 		/*
 		   formula from PRM:
@@ -1278,13 +1268,18 @@ void __netsoc_config_context_xoff_thr(nae_t *nae, net_port_t *netport, int thgrp
 
 		   (maxbuf<<2) is reqd since same is done for RX_BUFFER_BASE_DEPTH_REG also.
 		   16 is required 16k entries of 16 bytes each
-		 */
-
+		   */
+		maxbuf=maxbuf<<2;
+		reaction_len = inflight_len + mtu_len;	
 		xoff = ((maxbuf * NAE_RX_THR_BYTE_UNIT) - reaction_len - inflight_len - mtu_len) / NAE_RX_THR_BYTE_UNIT;
 		xon = xoff - NAE_THR_SEPARATION;
-
-		val = (xoff << 3) | (xon << 17) | thgrp;
+		if (xoff < 2*NAE_THR_SEPARATION) {
+			val = maxbuf / 16 ;
+			xoff = ((val * 3) << 2);
+			xon = ((val * 2) << 2);
+		}
 	}
+	val = (xoff << 3) | (xon << 17) | thgrp;
 	netsoc_write_nae_reg(nae->nae_base, RX_BUFFER_XONOFF_THR, thgrp);
 	netsoc_write_nae_reg(nae->nae_base, RX_BUFFER_XONOFF_THR, val);
 
@@ -1360,7 +1355,7 @@ void __netsoc_config_rxbuffer(nae_t *nae, int context_base, int num_channels, ui
 void __netsoc_config_parserfifo(nae_t *nae, int hw_port_id, uint32_t start, uint32_t size, int smallest_pkt_len, int iftype)
 {
 	volatile uint32_t val;
-	uint32_t xon, xoff, inflight_len;
+	int xon, xoff, inflight_len;
         static uint32_t prev_size = 0;
 
 	if (nae->ptp1588_enabled) {
@@ -1395,25 +1390,26 @@ void __netsoc_config_parserfifo(nae_t *nae, int hw_port_id, uint32_t start, uint
            inflight bytes = 504 (for XAUI) and 108 (for SGMII)
            */
 
-        if (iftype == SGMII_IF)
+        if (iftype == SGMII_IF){
                 inflight_len = NAE_INFLIGHT_LEN_SGMII;
-        else
+	}
+        else if (iftype == XLAUI_IF){
+                inflight_len = NAE_INFLIGHT_LEN_XLAUI;
+	}
+        else{
                 inflight_len = NAE_INFLIGHT_LEN_XAUI;
+	}	
 
         if (size != 0)
         {
-		if (IS_NLM_XLP9XX_FAMILY) {
-                        xoff = size - 30 ;
+		int line_delay = nae->mtu_config/smallest_pkt_len;
+		xoff = size - 2*(inflight_len/smallest_pkt_len) - line_delay; /*assuming other side is also having similar inflight delay*/
+	        xon = xoff - NAE_THR_SEPARATION;
+		if (xoff < 2*NAE_THR_SEPARATION) {
+                        xoff = size - 30;
                         xon = xoff/2;
-
-                        val = (xoff<<12) | (xon);
                 }
-                else {
-                	xoff = size - (inflight_len/smallest_pkt_len) - 1 - NAE_REACTION_LEN_PARSER;
-	                xon = xoff - NAE_THR_SEPARATION;
-
-        	        val = (xoff<<12) | (xon);
-		}
+                val = (xoff<<12) | (xon);
 		netsoc_write_nae_reg(nae->nae_base, PARSER_SEQ_FIFOTH_CFG, val);
         }
 
@@ -1447,7 +1443,7 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
         int port, lane = 0, hw_port = 0, max_lanes, offset = 0;
 	int cur_iface_start = 0, max_ports;
 	uint32_t cur_parser_base = 0, context_base = 0, rx_buf_base = 0, size = 0;
-	int thrgrp = 0, rx_buf_size;
+	int thrgrp,  rx_buf_size;
 	static int xonxoff_done[NLM_MAX_NODES][XLP9XX_MAX_NAE_PERNODE][NLM_NAE_MAX_XONOFF_THR_GRPS];
 
 	max_ports = __netsoc_get_max_ports();
@@ -1456,38 +1452,31 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 	    if (hw_port == nae->ports[port].hw_port_id) {
 
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "port:%d iftype:%d\n", port, nae->ports[port].iftype);
-		thrgrp = 0;
+		thrgrp = nae->ports[port].block_id; /*select thrgp on the block id*/
 		rx_buf_size = 0;
 		switch(nae->ports[port].iftype) {
 		   case RXAUI_IF:
 			fifo_xoff_thresh = 12;
-			thrgrp = 2;
 			rx_buf_size = nae->ports[port].rx_buf_size;
 			break;
 		   case XLAUI_IF:
 			fifo_xoff_thresh = 12;
-			thrgrp = 1;
 			rx_buf_size = nae->ports[port].rx_buf_size;
 			break;
 		   case XAUI_IF:
 			fifo_xoff_thresh = 12;
-			thrgrp = 1;
 			rx_buf_size = nae->ports[port].rx_buf_size;
 			break;
 		//TODO: Verify the values
 		   case XFI_IF:
 			fifo_xoff_thresh = 12;
 			rx_buf_size = nae->ports[port].rx_buf_size;
-			//TODO: check thgrp
-			thrgrp = 3;
 			break;
 		   case SGMII_IF:
-			thrgrp = 0;
 			fifo_xoff_thresh = 6;
 			rx_buf_size = nae->ports[port].rx_buf_size;
 			break;
 		   case INTERLAKEN_IF:
-			thrgrp = 4;
 			if(IS_NLM_XLP9XX_FAMILY)
 				fifo_xoff_thresh = 12*2;
 			else
@@ -1516,7 +1505,7 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
                 {
   			if(!(xonxoff_done[nae->node][nae->nae_id][thrgrp])){
 				xonxoff_done[nae->node][nae->nae_id][thrgrp] = 1;
-				__netsoc_config_context_xoff_thr(nae, &nae->ports[port], thrgrp,  rx_buf_size/nae->ports[port].num_channels, NAE_MTU_LEN);
+				__netsoc_config_context_xoff_thr(nae, &nae->ports[port], thrgrp,  rx_buf_size/nae->ports[port].num_channels, nae->mtu_config);
 			}
 		}
 
@@ -2309,8 +2298,8 @@ static void __netsoc_config_xaui(net_port_t *netport)
            3. minimum timer value of step 1 & 2
            */
 
-           /* read the xon value from RX_BUFFER_XONOFF_THR reg, thgrp = 1 */
-           netsoc_write_nae_reg(nae->nae_base, RX_BUFFER_XONOFF_THR, (1 << 31) | NAE_XAUI_THR_GROUP);
+           /* read the xon value from RX_BUFFER_XONOFF_THR reg, thgrp s based on block number */
+           netsoc_write_nae_reg(nae->nae_base, RX_BUFFER_XONOFF_THR, (1 << 31) | netport->block_id);
            val1 = netsoc_read_nae_reg(nae->nae_base, RX_BUFFER_XONOFF_THR);
            xon1 = (((val1 >> 17) & 0x3fff) * NAE_RX_THR_BYTE_UNIT/64) - NAE_PAUSE_TIMER_DELTA;
 
diff --git a/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c b/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
index d7d4163..790f423 100644
--- a/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
@@ -2706,6 +2706,10 @@ static inline void config_context_xoff_thr(int node, int thgrp, int maxbuf)
 * @ingroup hal_nae
 *
 */
+#define NAE_XAUI_THR_GROUP 1
+#define NAE_SGMII_THR_GROUP 0
+#define NAE_RXAUI_THR_GROUP 2
+#define NAE_ILK_THR_GROUP 3
 void nlm_hal_set_context_xon_xoff_threshold(int node, int mtu_len)
 {
 	int i, xon_xoff_done[NLM_NAE_MAX_XONOFF_THR_GRPS];
-- 
1.9.1

