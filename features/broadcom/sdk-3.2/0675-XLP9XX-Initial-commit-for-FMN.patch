From 57a9fb75368978616eee4ebe0e6bc1e980c404e5 Mon Sep 17 00:00:00 2001
From: Prasanna Mumbai <prasanna.mumbai@broadcom.com>
Date: Tue, 30 Apr 2013 16:34:48 +0530
Subject: [PATCH 0675/1532] XLP9XX: Initial commit for FMN

Signed-off-by: Prasanna Mumbai <prasanna.mumbai@broadcom.com>
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c | 327 ++++++++++++++++-----
 .../netlogic/lib/syslib/include/nlm_hal_xlp_dev.h  |  88 ++++++
 2 files changed, 341 insertions(+), 74 deletions(-)

diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
index e6237d6..201644c 100644
--- a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
@@ -44,10 +44,10 @@
 #include "nlm_hal_sys.h"
 
 #define CPU		1
-#define PCIE	2
+#define PCIE		2
 #define GDX		3
 #define CMP		4
-#define CRYPTO	5
+#define CRYPTO		5
 #define POE		6
 #define NAE		7
 #define RSA		8
@@ -60,15 +60,6 @@
 #define UP52MASK        	0xfffffffffffff000ULL
 #define LOW18MASK       	0x000000000003ffffULL
 #define LOW4KMASK       	0x00000000000003ffULL
-#define OUTQ_SIZE		32
-#define NUM_SGMII_PORT		18
-#define MAX_TXVC		524
-#define FMN_OUTQ		1024
-#define NUM_CORES		8
-#define NUM_CPU_VC		128
-#define NUM_CPU_POPQ		256
-#define NUM_THREADS		4
-#define NUM_VC_PER_THREAD	4
 
 
 nlm_fmn_config_t xlp3xx_fmn_config[] = {
@@ -81,15 +72,25 @@ nlm_fmn_config_t xlp3xx_fmn_config[] = {
 [XLP_MSG_HANDLE_CPU5] = {XLP_3XX_INVALID_STATION, 0},
 [XLP_MSG_HANDLE_CPU6] = {XLP_3XX_INVALID_STATION, 0},
 [XLP_MSG_HANDLE_CPU7] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU8] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU9] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU10] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU11] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU12] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU13] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU14] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU15] = {XLP_3XX_INVALID_STATION, 0},
 
 [XLP_MSG_HANDLE_PCIE0] = {XLP_PCIE0_VC_BASE, XLP_PCIE0_VC_LIMIT},
 [XLP_MSG_HANDLE_PCIE1] = {XLP_PCIE1_VC_BASE, XLP_PCIE1_VC_LIMIT},
 [XLP_MSG_HANDLE_PCIE2] = {XLP_PCIE2_VC_BASE, XLP_PCIE2_VC_LIMIT},
 [XLP_MSG_HANDLE_PCIE3] = {XLP_PCIE3_VC_BASE, XLP_PCIE3_VC_LIMIT},
 
+/* duplication? DTRE and GDX */
 [XLP_MSG_HANDLE_DTRE] = {XLP_GDX_VC_BASE, XLP_GDX_VC_LIMIT},
 
 [XLP_MSG_HANDLE_GDX]  = {XLP_GDX_VC_BASE, XLP_GDX_VC_LIMIT},
+[XLP_MSG_HANDLE_GDX_1]  = {XLP_3XX_INVALID_STATION, 0},
 [XLP_MSG_HANDLE_REGX] = {XLP_3XX_REGEX_VC_BASE, XLP_3XX_REGEX_VC_LIMIT},
 [XLP_MSG_HANDLE_RSA_ECC] = {XLP_3XX_RSA_ECC_VC_BASE, XLP_3XX_RSA_ECC_VC_LIMIT},
 [XLP_MSG_HANDLE_CRYPTO] = {XLP_3XX_CRYPTO_VC_BASE, XLP_3XX_CRYPTO_VC_LIMIT},
@@ -97,9 +98,15 @@ nlm_fmn_config_t xlp3xx_fmn_config[] = {
 [XLP_MSG_HANDLE_SRIO] = {XLP_3XX_SRIO_VC_BASE, XLP_3XX_SRIO_VC_LIMIT},
 
 [XLP_MSG_HANDLE_CMP] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_LZS] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_KBP] = {XLP_3XX_INVALID_STATION, 0},
 
 [XLP_MSG_HANDLE_POE] = {XLP_3XX_POE_VC_BASE, XLP_3XX_POE_VC_LIMIT},
 [XLP_MSG_HANDLE_NAE_0] = {XLP_3XX_NET_TX_VC_BASE, XLP_3XX_NET_TX_VC_LIMIT},
+[XLP_MSG_HANDLE_NAE_1] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_POE_1] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_ALE]   = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_POPQ]  = {XLP_3XX_INVALID_STATION, 0},
 
 [XLP_MSG_HANDLE_INVALID] = {XLP_3XX_INVALID_STATION, 0},
 [XLP_MSG_HANDLE_MAX] = {XLP_3XX_INVALID_STATION, 0},
@@ -116,15 +123,25 @@ nlm_fmn_config_t xlp2xx_fmn_config[] = {
 [XLP_MSG_HANDLE_CPU5] = {XLP_2XX_INVALID_STATION, 0},
 [XLP_MSG_HANDLE_CPU6] = {XLP_2XX_INVALID_STATION, 0},
 [XLP_MSG_HANDLE_CPU7] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU8] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU9] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU10] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU11] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU12] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU13] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU14] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU15] = {XLP_2XX_INVALID_STATION, 0},
 
 [XLP_MSG_HANDLE_PCIE0] = {XLP_PCIE0_VC_BASE, XLP_PCIE0_VC_LIMIT},
 [XLP_MSG_HANDLE_PCIE1] = {XLP_PCIE1_VC_BASE, XLP_PCIE1_VC_LIMIT},
 [XLP_MSG_HANDLE_PCIE2] = {XLP_PCIE2_VC_BASE, XLP_PCIE2_VC_LIMIT},
 [XLP_MSG_HANDLE_PCIE3] = {XLP_PCIE3_VC_BASE, XLP_PCIE3_VC_LIMIT},
 
+/* duplication? DTRE and GDX */
 [XLP_MSG_HANDLE_DTRE] = {XLP_GDX_VC_BASE, XLP_GDX_VC_LIMIT},
 
 [XLP_MSG_HANDLE_GDX]  = {XLP_GDX_VC_BASE, XLP_GDX_VC_LIMIT},
+[XLP_MSG_HANDLE_GDX_1]  = {XLP_2XX_INVALID_STATION, 0},
 [XLP_MSG_HANDLE_REGX] = {XLP_2XX_REGEX_VC_BASE, XLP_2XX_REGEX_VC_LIMIT},
 [XLP_MSG_HANDLE_RSA_ECC] = {XLP_2XX_RSA_ECC_VC_BASE, XLP_2XX_RSA_ECC_VC_LIMIT},
 [XLP_MSG_HANDLE_CRYPTO] = {XLP_2XX_CRYPTO_VC_BASE, XLP_2XX_CRYPTO_VC_LIMIT},
@@ -132,13 +149,64 @@ nlm_fmn_config_t xlp2xx_fmn_config[] = {
 [XLP_MSG_HANDLE_SRIO] = {XLP_2XX_INVALID_STATION,0},
 
 [XLP_MSG_HANDLE_CMP] = {XLP_2XX_CDE_VC_BASE, XLP_2XX_CDE_VC_BASE},
+[XLP_MSG_HANDLE_LZS] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_KBP] = {XLP_2XX_INVALID_STATION, 0},
 
 [XLP_MSG_HANDLE_POE] = {XLP_2XX_POE_VC_BASE, XLP_2XX_POE_VC_LIMIT},
 [XLP_MSG_HANDLE_NAE_0] = {XLP_2XX_NET_TX_VC_BASE, XLP_2XX_NET_VC_LIMIT},
+[XLP_MSG_HANDLE_POE_1] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_NAE_1] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_ALE]   = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_POPQ]  = {XLP_2XX_INVALID_STATION, 0},
 
 [XLP_MSG_HANDLE_INVALID] = {XLP_2XX_INVALID_STATION, 0},
 [XLP_MSG_HANDLE_MAX] = {XLP_2XX_INVALID_STATION, 0},
 };
+
+nlm_fmn_config_t xlp9xx_fmn_config[] = {
+[XLP_MSG_HANDLE_CPU0]  = {XLP_STNID_CPU0,  XLP_CPU0_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU1]  = {XLP_STNID_CPU1,  XLP_CPU1_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU2]  = {XLP_STNID_CPU2,  XLP_CPU2_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU3]  = {XLP_STNID_CPU3,  XLP_CPU3_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU4]  = {XLP_STNID_CPU4,  XLP_CPU4_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU5]  = {XLP_STNID_CPU5,  XLP_CPU5_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU6]  = {XLP_STNID_CPU6,  XLP_CPU6_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU7]  = {XLP_STNID_CPU7,  XLP_CPU7_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU8]  = {XLP_STNID_CPU8,  XLP_CPU8_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU9]  = {XLP_STNID_CPU9,  XLP_CPU9_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU10] = {XLP_STNID_CPU10, XLP_CPU10_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU11] = {XLP_STNID_CPU11, XLP_CPU11_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU12] = {XLP_STNID_CPU12, XLP_CPU12_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU13] = {XLP_STNID_CPU13, XLP_CPU13_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU14] = {XLP_STNID_CPU14, XLP_CPU14_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU15] = {XLP_STNID_CPU15, XLP_CPU15_VC_LIMIT},
+
+[XLP_MSG_HANDLE_PCIE0]   = {XLP_9XX_PCIE0_VC_BASE, XLP_9XX_PCIE0_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE1]   = {XLP_9XX_PCIE1_VC_BASE, XLP_9XX_PCIE1_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE2]   = {XLP_9XX_PCIE2_VC_BASE, XLP_9XX_PCIE2_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE3]   = {XLP_9XX_PCIE3_VC_BASE, XLP_9XX_PCIE3_VC_LIMIT},
+[XLP_MSG_HANDLE_DTRE]    = {XLP_9XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_GDX_0]   = {XLP_9XX_GDX0_VC_BASE, XLP_9XX_GDX0_VC_LIMIT},
+[XLP_MSG_HANDLE_GDX_1]   = {XLP_9XX_GDX1_VC_BASE, XLP_9XX_GDX1_VC_LIMIT},
+[XLP_MSG_HANDLE_REGX]    = {XLP_9XX_RGX_VC_BASE, XLP_9XX_RGX_VC_LIMIT},
+[XLP_MSG_HANDLE_RSA_ECC] = {XLP_9XX_RSA_VC_BASE, XLP_9XX_RSA_VC_LIMIT},
+[XLP_MSG_HANDLE_CRYPTO]  = {XLP_9XX_SEC_VC_BASE, XLP_9XX_SEC_VC_LIMIT},
+[XLP_MSG_HANDLE_SRIO]    = {XLP_9XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CMP]    = {XLP_9XX_CMP_VC_BASE, XLP_9XX_CMP_VC_LIMIT},
+[XLP_MSG_HANDLE_LZS]    = {XLP_9XX_LZS_VC_BASE, XLP_9XX_LZS_VC_LIMIT},
+[XLP_MSG_HANDLE_KBP]    = {XLP_9XX_KBP_VC_BASE, XLP_9XX_KBP_VC_LIMIT},
+
+[XLP_MSG_HANDLE_POE_0] = {XLP_9XX_POE0_VC_BASE, XLP_9XX_POE0_VC_LIMIT},
+[XLP_MSG_HANDLE_NAE_0] = {XLP_9XX_NET0_VC_BASE, XLP_9XX_NET0_VC_LIMIT},
+[XLP_MSG_HANDLE_POE_1] = {XLP_9XX_POE1_VC_BASE, XLP_9XX_POE1_VC_LIMIT},
+[XLP_MSG_HANDLE_NAE_1] = {XLP_9XX_NET1_VC_BASE, XLP_9XX_NET1_VC_LIMIT},
+[XLP_MSG_HANDLE_ALE]   = {XLP_9XX_ALE_VC_BASE,  XLP_9XX_ALE_VC_LIMIT},
+[XLP_MSG_HANDLE_POPQ]   = {XLP_9XX_POPQ_VC_BASE,  XLP_9XX_POPQ_VC_LIMIT},
+
+[XLP_MSG_HANDLE_INVALID] = {XLP_9XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_MAX] = {XLP_9XX_INVALID_STATION, 0},
+};
+
 extern struct nlm_node_config nlm_node_cfg;
 
 /*#define FMN_DEBUG 1 */
@@ -494,10 +562,15 @@ unsigned long long stids[16];
 void nlm_hal_enable_vc_intr(int node, int vc)
 {
 	uint64_t val = 0;
-	val = nlm_hal_read_outq_config(node, vc);
-	val &= ~((0x7ULL<<56) | (0x3ULL<<54) | (0x7ULL<<51) | (0x3ULL<<49));
-	val |=  (0ULL<<56)|(0x2ULL<<54)|(0x0ULL<<51)|(0x1ULL<<49);
-	nlm_hal_write_outq_config(node, vc, val);
+	if (is_nlm_xlp9xx()) {
+		val =  (0ULL << 7) | (0x2ULL << 5) | (0x0ULL << 2) | (0x1ULL << 0);
+		*(uint64_t *)(xlp_fmn_base[node] + (1 << 13) + (vc << 3)) = val;
+	} else {
+		val = nlm_hal_read_outq_config(node, vc);
+		val &= ~((0x7ULL<<56) | (0x3ULL<<54) | (0x7ULL<<51) | (0x3ULL<<49));
+		val |=  (0ULL<<56)|(0x2ULL<<54)|(0x0ULL<<51)|(0x1ULL<<49);
+		nlm_hal_write_outq_config(node, vc, val);
+	}
 }
 
 /*********************************************************************
@@ -506,9 +579,13 @@ void nlm_hal_enable_vc_intr(int node, int vc)
 void nlm_hal_disable_vc_intr(int node, int vc)
 {
 	uint64_t val = 0;
-	val = nlm_hal_read_outq_config(node, vc);
-	val = val & ~((0x3ULL<<54) | (0x3ULL<<49));
-	nlm_hal_write_outq_config(node, vc, val);
+	if (is_nlm_xlp9xx()) {
+		*(uint64_t *)(xlp_fmn_base[node] + (1 << 13) + (vc << 3)) = 0x0;
+	} else {
+		val = nlm_hal_read_outq_config(node, vc);
+		val = val & ~((0x3ULL<<54) | (0x3ULL<<49));
+		nlm_hal_write_outq_config(node, vc, val);
+	}
 }
 
 /*********************************************************************
@@ -525,6 +602,11 @@ void nlm_hal_set_fmn_interrupt(int irq)
 	val =  _read_32bit_cp2_register(XLP_MSG_CONFIG_REG);
 	val &= ~(0x1f << 16);
 	val |= (irq << 16);
+
+	/* Enable VC Interrupt for all 4 VC's */
+	if (is_nlm_xlp2xx() || is_nlm_xlp9xx())
+		val |= (0xf << 22);
+
 	_write_32bit_cp2_register(XLP_MSG_CONFIG_REG, val);
 
 }
@@ -639,7 +721,45 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 	volatile int index;
 	uint32_t credits, cfgrd;
 
-        if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
+	if (is_nlm_xlp9xx()) {
+		/* XLP9XX / XLP7XX */
+		nlm_print(" XLP9XX/XLP7XX FMN credit configuration \n");
+
+		fmn_config = &xlp9xx_fmn_config[0];
+		/* go through each valid station */
+		for(hndl = 0; hndl < XLP_MSG_HANDLE_MAX; hndl++) {
+			int base_vc = fmn_config->base_vc;
+			if (base_vc != XLP_9XX_INVALID_STATION) {
+				int station;
+
+				/* configure credits from this base station to all other appropriate VC's */
+				for(dst_node = 0 ;dst_node < max_nodes; dst_node++) {
+					fmn_update_credit(node, base_vc, dst_node);
+
+					/* go through all valid stations and all valid vc's */
+					for (station = 0; station < XLP_MSG_HANDLE_MAX; station++) {
+						qid = xlp9xx_fmn_config[station].base_vc;
+						if (qid == XLP_9XX_INVALID_STATION)
+							continue;
+						for (; qid <= xlp9xx_fmn_config[station].vc_limit; qid++) {
+							/* FIXME: define/config fmn_cfg_value properly for XLP9XX */
+#if 0
+							credits = fmn_cfg_value[qid] - 1;
+#else
+							credits = 50;
+#endif
+							*(uint64_t *)(xlp_fmn_base[0] + (1 << 14)) =
+								(0ULL << 42) /* type, credit value + 1 */
+								| (credits << 26) /* credit count */
+								| ((qid | (dst_node << 10)) << 13) /* destination */
+								| (base_vc | (node << 10)); /* source */
+						}
+					}
+				}
+			}
+			fmn_config++;
+		}
+	} else if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
 		nlm_print(" XLP3XX/XLP2XX FMN configuration \n");
 		if(is_nlm_xlp316()){
 			nlm_print(" XLP316 FMN configuration \n");
@@ -680,8 +800,7 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 
 			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 1, XLP_CPU0_VC_BASE, XLP_CPU0_VC_LIMIT);
 		}
-		else {
-		}
+		else { }
 
 		if (is_nlm_xlp3xx()) {
 			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_RSA_ECC, 1, XLP_3XX_RSA_ECC_VC_BASE, XLP_3XX_RSA_ECC_VC_LIMIT);
@@ -697,6 +816,14 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 		if (is_nlm_xlp3xx_ax() == 0)
 			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_SRIO, 1, XLP_3XX_SRIO_VC_BASE, XLP_3XX_B0_SRIO_VC_LIMIT);
 
+		/* 3xx does not have compression engine */
+		if(is_nlm_xlp3xx())
+			fmn_invalidate_blocks(node, XLP_MSG_BLK_CMP);
+
+		/* 2xx does not have SRIO engine */
+		if(is_nlm_xlp2xx())
+			fmn_invalidate_blocks(node, XLP_MSG_BLK_SRIO);
+
 		fmn_config = (is_nlm_xlp3xx())? &xlp3xx_fmn_config[0] : &xlp2xx_fmn_config[0];
                 for(hndl = 0; hndl < XLP_MSG_HANDLE_MAX; hndl++) {
                         if (fmn_config->base_vc != XLP_INVALID_STATION) {
@@ -788,6 +915,13 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
  * Total spill size for each Q is 16KB
  * This allows for 1024 q entries with 16B of entry size
  * This assumes credits across all sending agents to this queue is < 1024
+ *
+ * For xlp9xx, the total capacity of output buffer is 64K entry. Each output queue
+ * can be sized from 32 entry to 2048 entry in increments of 32 entry. So
+ * index[15:0] is to identified a particular entry.
+ *
+ * For xlp9xx, each node has 1024 output queues, total 8 nodes.
+ * So globally addressable qid's are 1024 * 8.
  ********************************************************************/
 int nlm_hal_setup_outq(int node, int max_nodes)
 {
@@ -819,74 +953,119 @@ int nlm_hal_setup_outq(int node, int max_nodes)
 	if(fmn_update_qsize(node) < 0)
 		return -1;
 
-	for( qid = 0; qid <= max_qs; qid++ )
-	{
-		/* Enable all output queues and spill on all queues.
-		   Disable spill for u-boot as the spill memory will be enabled by the os 
-		   loading time with the specified address */
+	if (is_nlm_xlp9xx()) {
+		int station;
+
+		/* XLP9XX / XLP7XX */
+		nlm_print(" XLP9XX/XLP7XX FMN output queue configuration \n");
+
+		for (station = 0; station < XLP_MSG_HANDLE_MAX; station++) {
+			qid = xlp9xx_fmn_config[station].base_vc;
+			if (qid == XLP_9XX_INVALID_STATION)
+				continue;
+			for (; qid <= xlp9xx_fmn_config[station].vc_limit; qid++) {
+				/* enable output queue and setup on-chip output queue */
+				val = (1ULL << 63) | (qid << 6) | (qid << 0);
+
+#if !defined(NLM_HAL_UBOOT) && !defined(NLM_HAL_NETLBOOT)
+				/* spills, maximum spill per VC: 64 * 4KB = 256KB,
+				 * In our configuration, each VC: 4KB
+				 */
+				if (nlm_node_cfg.fmn_cfg[node]->fmn_spill_base != 0ULL) {
+					uint64_t base = (spill_base >> 18) + (qid >> 6);
+					/* carve the total fmn_spill area into all 32 VC's here */
+					val |= (1ULL << 62)       /* enable spill */
+						| (base << 29)    /* fmn base */
+						| (qid << 23) /* the last 64 cache line chunk */
+						| (qid << 17)  /* the first 64 cache line chunk */
+						;
+				}
+#endif
+
+				/* RxQ depth: 0 means default value, 1 means: NAE 8 -> 16, SEC 8 -> 64,
+				 * All other components stays the same. This is good for NAE/SEC perf.
+				 */
+				val = val | (1ULL << 51);
+
+				/* configure */
+				*(uint64_t *)(xlp_fmn_base[node] + (qid << 3)) = val;
+
+				/* disable interrupt by default, interrupt will be
+				 * enabled by respective OS configuration if needed.
+				 */
+				*(uint64_t *)(xlp_fmn_base[node] + (1 << 13) + (qid << 3)) = 0x0;
+			}
+		}
+	} else {
+		for( qid = 0; qid <= max_qs; qid++ )
+		{
+			/* Enable all output queues and spill on all queues.
+			   Disable spill for u-boot as the spill memory will be enabled by the os
+			   loading time with the specified address */
 #if defined(NLM_HAL_UBOOT) || defined(NLM_HAL_NETLBOOT)
-		val = OUTQ_EN;
+			val = OUTQ_EN;
 #else
-		val = OUTQ_EN;
-		if (nlm_node_cfg.fmn_cfg[node]->fmn_spill_base != 0ULL) 
-			val |= SPILL_EN;
+			val = OUTQ_EN;
+			if (nlm_node_cfg.fmn_cfg[node]->fmn_spill_base != 0ULL)
+				val |= SPILL_EN;
 #endif
 
-		/* Enable interrupts for cpu Queues */
-		if ( (qid >= 0) && (qid < 128))
-			val |= OUT_Q_INIT ;
+			/* Enable interrupts for cpu Queues */
+			if ( (qid >= 0) && (qid < 128))
+				val |= OUT_Q_INIT ;
 
 			/*val |= INT_EN|(0ULL<<56)|(0x2ULL<<54)|(0x0ULL<<51)|(0x1ULL<<49); */
 
-		/***************************************************************
-		 * Configuration of on-chip RAM area
-		 **************************************************************
-		 */
-		/* As 2xx has only 8k onchip memory skip all the invalid stations */
-		if(is_nlm_xlp2xx()) {
-			if(!station_exist_in_2xx(qid))
-				continue;
-			q_ram_base = ram_base + (cnt * q_ram_pages * q_ram_page_entries);
-			cnt++;
-		} else 
-			q_ram_base = ram_base + (qid * q_ram_pages * q_ram_page_entries);
+			/***************************************************************
+			 * Configuration of on-chip RAM area
+			 **************************************************************
+			 */
+			/* As 2xx has only 8k onchip memory skip all the invalid stations */
+			if(is_nlm_xlp2xx()) {
+				if(!station_exist_in_2xx(qid))
+					continue;
+				q_ram_base = ram_base + (cnt * q_ram_pages * q_ram_page_entries);
+				cnt++;
+			} else
+				q_ram_base = ram_base + (qid * q_ram_pages * q_ram_page_entries);
 
-		val |= ( ((q_ram_base >> 10) & 0x1f) << 10); /* [14:10] of q_ram_base */
+			val |= ( ((q_ram_base >> 10) & 0x1f) << 10); /* [14:10] of q_ram_base */
 
-		q_ram_start_page = (q_ram_base >> 5) & 0x1f; /* [9:5] of q_ram_base */
-		val |= (q_ram_start_page << 0);
-		val |= ( (q_ram_start_page + q_ram_pages - 1) << 5) ;
+			q_ram_start_page = (q_ram_base >> 5) & 0x1f; /* [9:5] of q_ram_base */
+			val |= (q_ram_start_page << 0);
+			val |= ( (q_ram_start_page + q_ram_pages - 1) << 5) ;
 
-		if (nlm_node_cfg.fmn_cfg[node]->fmn_spill_base != 0ULL) {
+			if (nlm_node_cfg.fmn_cfg[node]->fmn_spill_base != 0ULL) {
 
-			/***************************************************************
-			 * Configuration of spill area
-			 **************************************************************
-			 */
-			/* pages in 4K units */
-			q_spill_pages = fmn_cfg_value[qid] / (FMN_Q_PAGE_SIZE);
-		
-			/* if spill_start + qsize crosses 256MB boundary, configuration will be wrong as 
-			 only 17-12 bits only considered for spill last */
-			if(((spill_base & (FMN_MAX_Q_SIZE - 1)) +  fmn_cfg_value[qid]) > FMN_MAX_Q_SIZE)
-				spill_base = (spill_base + FMN_MAX_Q_SIZE - 1) & (~(FMN_MAX_Q_SIZE - 1));
-		
-			val |= ( ((spill_base >> 18) & 0x3fffff) << 27); /* [39:18] of q_spill_base */
+				/***************************************************************
+				 * Configuration of spill area
+				 **************************************************************
+				 */
+				/* pages in 4K units */
+				q_spill_pages = fmn_cfg_value[qid] / (FMN_Q_PAGE_SIZE);
+
+				/* if spill_start + qsize crosses 256MB boundary, configuration will be wrong as
+				   only 17-12 bits only considered for spill last */
+				if(((spill_base & (FMN_MAX_Q_SIZE - 1)) +  fmn_cfg_value[qid]) > FMN_MAX_Q_SIZE)
+					spill_base = (spill_base + FMN_MAX_Q_SIZE - 1) & (~(FMN_MAX_Q_SIZE - 1));
 
-			q_spill_start_page = (spill_base >> 12) & 0x3f; /* [17:12] of q_spill_base */
-			val |= (q_spill_start_page << 15);
-			val |= ( (q_spill_start_page + q_spill_pages - 1) << 21);
+				val |= ( ((spill_base >> 18) & 0x3fffff) << 27); /* [39:18] of q_spill_base */
+
+				q_spill_start_page = (spill_base >> 12) & 0x3f; /* [17:12] of q_spill_base */
+				val |= (q_spill_start_page << 15);
+				val |= ( (q_spill_start_page + q_spill_pages - 1) << 21);
 
 #ifdef FMN_DEBUG
-		nlm_print("Fmn q config %d sqbase %lx sqsize %d sqpages %d\n", 
-				qid, (long)spill_base, fmn_cfg_value[qid], (int)q_spill_pages);
+				nlm_print("Fmn q config %d sqbase %lx sqsize %d sqpages %d\n",
+						qid, (long)spill_base, fmn_cfg_value[qid], (int)q_spill_pages);
 #endif
-		
-			spill_base +=  fmn_cfg_value[qid];
+
+				spill_base +=  fmn_cfg_value[qid];
+			}
+
+			/* Write to the configuration register */
+			nlm_hal_write_outq_config(node, qid, val);
 		}
-		
-		/* Write to the configuration register */
-		nlm_hal_write_outq_config(node, qid, val);
 	}
 
         nlm_node_cfg.fmn_cfg[node]->spill_base_cur = spill_base;
@@ -1121,7 +1300,7 @@ void nlm_hal_fmn_init(void *fdt, int node)
 		while(1);
 	}
 
-	if(!is_nlm_xlp2xx()) {
+	if(!is_nlm_xlp2xx() && !is_nlm_xlp9xx()) {
 		nlm_hal_soc_clock_enable(node, DFS_DEVICE_RSA);
 	}
 
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
index 2d0ffd6..f985a78 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
@@ -328,6 +328,68 @@ extern int is_nlm_xlp(unsigned int chipid, unsigned int rev,  unsigned int ext);
 
 #define XLP_2XX_INVALID_STATION		XLP_INVALID_STATION
 
+// XLP9XX
+
+#define XLP_STNID_CPU8          0x80
+#define XLP_STNID_CPU9          0x90
+#define XLP_STNID_CPU10         0xA0
+#define XLP_STNID_CPU11         0xB0
+#define XLP_STNID_CPU12         0xC0
+#define XLP_STNID_CPU13         0xD0
+#define XLP_STNID_CPU14         0xE0
+#define XLP_STNID_CPU15         0xF0
+
+#define XLP_CPU8_VC_LIMIT       0x8F
+#define XLP_CPU9_VC_LIMIT       0x9F
+#define XLP_CPU10_VC_LIMIT      0xAF
+#define XLP_CPU11_VC_LIMIT      0xBF
+#define XLP_CPU12_VC_LIMIT      0xCF
+#define XLP_CPU13_VC_LIMIT      0xDF
+#define XLP_CPU14_VC_LIMIT      0xEF
+#define XLP_CPU15_VC_LIMIT      0xFF
+
+#define XLP_9XX_PCIE0_VC_BASE	0x180
+#define XLP_9XX_PCIE0_VC_LIMIT	0x181
+#define XLP_9XX_PCIE1_VC_BASE	0x182
+#define XLP_9XX_PCIE1_VC_LIMIT	0x183
+#define XLP_9XX_PCIE2_VC_BASE	0x184
+#define XLP_9XX_PCIE2_VC_LIMIT	0x185
+#define XLP_9XX_PCIE3_VC_BASE	0x186
+#define XLP_9XX_PCIE3_VC_LIMIT	0x187
+
+#define XLP_9XX_GDX0_VC_BASE	0x188
+#define XLP_9XX_GDX0_VC_LIMIT	0x189
+#define XLP_9XX_GDX1_VC_BASE	0x18A
+#define XLP_9XX_GDX1_VC_LIMIT	0x18B
+#define XLP_9XX_CMP_VC_BASE	0x190
+#define XLP_9XX_CMP_VC_LIMIT	0x196
+#define XLP_9XX_LZS_VC_BASE	0x19C
+#define XLP_9XX_LZS_VC_LIMIT	0x1A2
+#define XLP_9XX_SEC_VC_BASE	0x1A8
+#define XLP_9XX_SEC_VC_LIMIT	0x1AF
+#define XLP_9XX_RSA_VC_BASE	0x1C0
+#define XLP_9XX_RSA_VC_LIMIT	0x1C3
+#define XLP_9XX_RGX_VC_BASE	0x1CC
+#define XLP_9XX_RGX_VC_LIMIT	0x1CF
+#define XLP_9XX_KBP_VC_BASE	0x1DC
+#define XLP_9XX_KBP_VC_LIMIT	0x1DF
+
+#define XLP_9XX_POE0_VC_BASE	0x200
+#define XLP_9XX_POE0_VC_LIMIT	0x207
+#define XLP_9XX_NET0_VC_BASE	0x208
+#define XLP_9XX_NET0_VC_LIMIT	0x257
+#define XLP_9XX_POE1_VC_BASE	0x280
+#define XLP_9XX_POE1_VC_LIMIT	0x287
+#define XLP_9XX_NET1_VC_BASE	0x288
+#define XLP_9XX_NET1_VC_LIMIT	0x2D7
+#define XLP_9XX_ALE_VC_BASE	0x2DA
+#define XLP_9XX_ALE_VC_LIMIT	0x2DB
+
+#define XLP_9XX_POPQ_VC_BASE	0x300
+#define XLP_9XX_POPQ_VC_LIMIT	0x3FF
+
+#define XLP_9XX_INVALID_STATION		0x2FF
+
 /*Sw Code */
 #define XLP_CODE_MAC		0
 #define XLP_CODE_SEC		1
@@ -405,6 +467,9 @@ extern int is_nlm_xlp(unsigned int chipid, unsigned int rev,  unsigned int ext);
 #define XLP_SYS_DEVICE			0x6
 #define XLP_SYS_FUNC			0x5
 
+#define XLP9XX_SYS_DEVICE		0x6
+#define XLP9XX_SYS_FUNC			0x0
+
 #define XLP_MAXDEV_PERNODE		8
 
 #define XLP_CFG_BASE(node, SOC)		((((node * XLP_MAXDEV_PERNODE) + SOC##_DEVICE) << 15) | (SOC##_FUNC << 12))
@@ -443,6 +508,7 @@ enum NLH_DEV_ID {
 };
 
 enum XLP_MSG_HANDLES  {
+	/* cpus */
         XLP_MSG_HANDLE_CPU0,
         XLP_MSG_HANDLE_CPU1,
         XLP_MSG_HANDLE_CPU2,
@@ -451,19 +517,41 @@ enum XLP_MSG_HANDLES  {
         XLP_MSG_HANDLE_CPU5,
         XLP_MSG_HANDLE_CPU6,
         XLP_MSG_HANDLE_CPU7,
+        XLP_MSG_HANDLE_CPU8,
+        XLP_MSG_HANDLE_CPU9,
+        XLP_MSG_HANDLE_CPU10,
+        XLP_MSG_HANDLE_CPU11,
+        XLP_MSG_HANDLE_CPU12,
+        XLP_MSG_HANDLE_CPU13,
+        XLP_MSG_HANDLE_CPU14,
+        XLP_MSG_HANDLE_CPU15,
+
+	/* io */
         XLP_MSG_HANDLE_PCIE0,
         XLP_MSG_HANDLE_PCIE1,
         XLP_MSG_HANDLE_PCIE2,
         XLP_MSG_HANDLE_PCIE3,
 	XLP_MSG_HANDLE_DTRE,
         XLP_MSG_HANDLE_GDX,
+        XLP_MSG_HANDLE_GDX_0 = XLP_MSG_HANDLE_GDX,
+        XLP_MSG_HANDLE_GDX_1,
         XLP_MSG_HANDLE_REGX,
         XLP_MSG_HANDLE_RSA_ECC,
         XLP_MSG_HANDLE_CRYPTO,
         XLP_MSG_HANDLE_SRIO,
         XLP_MSG_HANDLE_CMP,
+        XLP_MSG_HANDLE_LZS,
+        XLP_MSG_HANDLE_KBP,
+
+	/* net and popq */
         XLP_MSG_HANDLE_POE,
+        XLP_MSG_HANDLE_POE_0 = XLP_MSG_HANDLE_POE,
         XLP_MSG_HANDLE_NAE_0,
+        XLP_MSG_HANDLE_POE_1,
+        XLP_MSG_HANDLE_NAE_1,
+        XLP_MSG_HANDLE_ALE,
+        XLP_MSG_HANDLE_POPQ,
+
         XLP_MSG_HANDLE_INVALID,
         XLP_MSG_HANDLE_MAX,
 };
-- 
1.9.1

