From 0e2af671637c91d799ef4cd08917dd01489b1b21 Mon Sep 17 00:00:00 2001
From: Lakshman Garlapati <kumarga@broadcom.com>
Date: Mon, 11 Aug 2014 19:05:03 +0530
Subject: [PATCH 1240/1532] DTRE: Encoded cpu bucket id (to receive return
 message) at correct location in fmn message

Removed redundant dtr api file
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/dtre/nlm_adma.c | 59 +++++++++++++++++++++++++----------
 1 file changed, 43 insertions(+), 16 deletions(-)

diff --git a/drivers/misc/netlogic/dtre/nlm_adma.c b/drivers/misc/netlogic/dtre/nlm_adma.c
index 05bae25..4447ade 100644
--- a/drivers/misc/netlogic/dtre/nlm_adma.c
+++ b/drivers/misc/netlogic/dtre/nlm_adma.c
@@ -49,6 +49,7 @@
 #include "libfdt.h"
 
 uint64_t nlm_dtre_debug = 0;
+uint32_t is_nlm_9xx_family;
 static unsigned int nlm_dtre_min_vc = 0;
 
 #define shift_lower_bits(x, bitshift, numofbits) \
@@ -121,13 +122,23 @@ uint64_t gen_dtr_raid_msg_format_1 (const uint32_t raid_type,
 		const uint32_t disks,
 		const uint32_t freeback_msg_dest_id)
 {
-	return 0ULL << 63
-		| shift_lower_bits (1, 56, 1) /* Inform Source */
-		| shift_lower_bits (freeback_msg_dest_id, 44, 12)
-		| shift_lower_bits (DTRE_NLM_Q_POLY, 12, 8) /* Q polynomial*/
-		| shift_lower_bits (raid_type, 10, 2)
-		| shift_lower_bits (operation, 9, 1)
-		| shift_lower_bits (disks, 0, 5);
+	if (is_nlm_9xx_family){
+		return 0ULL << 63
+			| shift_lower_bits (1, 56, 1) /* Inform Source */
+			| shift_lower_bits (freeback_msg_dest_id, 43, 13)
+			| shift_lower_bits (DTRE_NLM_Q_POLY, 12, 8) /* Q polynomial*/
+			| shift_lower_bits (raid_type, 10, 2)
+			| shift_lower_bits (operation, 9, 1)
+			| shift_lower_bits (disks, 0, 5);
+	} else {
+		return 0ULL << 63
+			| shift_lower_bits (1, 56, 1) /* Inform Source */
+			| shift_lower_bits (freeback_msg_dest_id, 44, 12)
+			| shift_lower_bits (DTRE_NLM_Q_POLY, 12, 8) /* Q polynomial*/
+			| shift_lower_bits (raid_type, 10, 2)
+			| shift_lower_bits (operation, 9, 1)
+			| shift_lower_bits (disks, 0, 5);	
+	}
 }
 
 static __inline__
@@ -150,10 +161,17 @@ uint64_t gen_dtr_xfer_msg_format_0 (const unsigned long len, const volatile uint
 static __inline__
 uint64_t gen_dtr_xfer_msg_format_1 (const uint32_t dest_id)
 {
-	return (0ULL << 63)
-		| shift_lower_bits (1, 59, 1) /* write control */
-		| shift_lower_bits (1, 56, 1) /* Inform Source */
-		| shift_lower_bits (dest_id, 44, 12);
+	if (is_nlm_9xx_family) {
+		return (0ULL << 63)
+			| shift_lower_bits (1, 59, 1) /* write control */
+			| shift_lower_bits (1, 56, 1) /* Inform Source */
+			| shift_lower_bits (dest_id, 43, 13);
+	} else {
+		return (0ULL << 63)	
+			| shift_lower_bits (1, 59, 1) /* write control */
+			| shift_lower_bits (1, 56, 1) /* Inform Source */
+			| shift_lower_bits (dest_id, 44, 12);	
+	}
 }
 
 static __inline__
@@ -183,10 +201,17 @@ uint64_t gen_dtr_xfer_p2pmsg_format_0 (const uint32_t len, const volatile uint64
 static __inline__
 uint64_t gen_dtr_xfer_p2pmsg_format_1 (const uint32_t dest_id)
 {
-	return (0ULL << 63)
-		| shift_lower_bits (0, 62, 1)  /* i/o data interconnect */
-		| shift_lower_bits (1, 56, 1) /* Inform Source */
-		| shift_lower_bits (dest_id, 44, 12);
+	if (is_nlm_9xx_family) {
+		return (0ULL << 63)
+			| shift_lower_bits (0, 62, 1)  /* i/o data interconnect */
+			| shift_lower_bits (1, 56, 1) /* Inform Source */
+			| shift_lower_bits (dest_id, 43, 13);
+	} else {
+		return (0ULL << 63)
+			| shift_lower_bits (0, 62, 1)  /* i/o data interconnect */
+			| shift_lower_bits (1, 56, 1) /* Inform Source */
+			| shift_lower_bits (dest_id, 44, 12);
+	}
 }
 
 static __inline__
@@ -1480,6 +1505,7 @@ static int nlm_adma_probe(struct platform_device *pdev)
 	if (is_nlm_xlp9xx())
 	{
 		nlm_dtre_min_vc = DTRE_9XX_MIN_VC;
+		is_nlm_9xx_family = 1;
 
 		/* for xlp9xx, register station IDs of both engines */
 		if (register_xlp_msgring_handler(XLP_MSG_HANDLE_GDX_0, nlm_dtre_msgring_handler, NULL))
@@ -1495,6 +1521,7 @@ static int nlm_adma_probe(struct platform_device *pdev)
 		}
 	} else if (is_nlm_xlp5xx()) {
 		nlm_dtre_min_vc = DTRE_XLP5XX_MIN_VC;
+		is_nlm_9xx_family = 1;
 
 		if (register_xlp_msgring_handler(XLP_MSG_HANDLE_GDX_0, nlm_dtre_msgring_handler, NULL))
 		{
@@ -1503,7 +1530,7 @@ static int nlm_adma_probe(struct platform_device *pdev)
 		}
 	} else {
 		nlm_dtre_min_vc = DTRE_MIN_VC;
-
+		is_nlm_9xx_family = 0;
 		if (register_xlp_msgring_handler(XLP_MSG_HANDLE_DTRE, nlm_dtre_msgring_handler, NULL)){
 			printk("Error: NLM-ADMA unable to register for msgring handler\n");
 			return -1;
-- 
1.9.1

