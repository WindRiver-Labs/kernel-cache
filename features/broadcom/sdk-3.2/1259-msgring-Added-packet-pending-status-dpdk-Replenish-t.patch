From e994fe5198127402fd6c1847e3262656fcb9330e Mon Sep 17 00:00:00 2001
From: Hareesh R <hareeshr@broadcom.com>
Date: Tue, 2 Dec 2014 16:46:33 +0530
Subject: [PATCH 1259/1532] msgring : Added packet pending status dpdk :
 Replenish the received packet when alloc fails

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../misc/netlogic/nlm_msgring/nlm_msgring_main.c   | 86 ++++++++++++++++++++--
 1 file changed, 79 insertions(+), 7 deletions(-)

diff --git a/drivers/misc/netlogic/nlm_msgring/nlm_msgring_main.c b/drivers/misc/netlogic/nlm_msgring/nlm_msgring_main.c
index 0fdb6bb..678c836 100644
--- a/drivers/misc/netlogic/nlm_msgring/nlm_msgring_main.c
+++ b/drivers/misc/netlogic/nlm_msgring/nlm_msgring_main.c
@@ -67,6 +67,9 @@ static struct device *msgring_device;
 static dev_t msgring_devt;
 static int xlp8xx_family, xlp9xx_family;
 
+static struct page *page;
+static unsigned long long page_paddr;
+static unsigned int  *page_addr;
  
 #define NLM_MSGRING_WAIT_IOC 'm'
 #define NLM_MSGRING_WAIT_VC   _IOWR(NLM_MSGRING_WAIT_IOC, 1, unsigned int *)
@@ -84,8 +87,10 @@ static int msgring_event(int vc)
 	*  we got the interrrupt. */
 	int cpu = hard_smp_processor_id();
 //	printk("%s in vc %d cpu %d\n", __FUNCTION__, vc, cpu);
-	if(msgring_status[cpu] != 1) 
+	if(msgring_status[cpu] != 1) {
+		page_addr[cpu] = 1;
 		return 0;
+	}
 	msgring_status[cpu] = 0;
 	wake_up_interruptible(&msgring_wq[cpu]);
 	return 0;
@@ -172,18 +177,56 @@ void msgring_func(void *info)
 		return;
 	msgring_status[cpu] = 0;
 	wake_up_interruptible(&msgring_wq[cpu]);
-	return 0;
+	return;
 }
 
 static ssize_t msgring_write(struct file *fp, 
 		const char __user *buf, size_t length, loff_t *offset)
 {
-	unsigned int cpu;
+	unsigned long long data;
+	int cmd, val;
+	int my_cpu = hard_smp_processor_id();
+	unsigned long flags;
+#ifdef CONFIG_32BIT
+	unsigned long mflags;
+#endif
+
 //	printk("%s in\n", __FUNCTION__);
 	if(buf) {
-		copy_from_user(&cpu, buf, sizeof(cpu));
-		/* No need to wait here */
-		smp_call_function_single(cpu, msgring_func, (void *)(long)cpu, 0);
+		copy_from_user(&data, buf, sizeof(data));
+		
+		cmd = data >> 32;
+		val = data & 0xffffffffULL;
+
+		if(cmd == 0) {
+			int cpu = val;
+			/* No need to wait here */
+			smp_call_function_single(cpu, msgring_func, (void *)(long)cpu, 0);
+		} else if(cmd == 1) {
+
+			local_irq_save(flags);
+#ifdef CONFIG_32BIT
+			msgrng_access_enable(mflags);
+#endif
+
+			/* Enable intr on the vcs */
+			/* Need write vcmask into the register */
+			if (xlp8xx_family) {
+				val =  _read_32bit_cp2_register(XLP_MSG_STATUS1_REG);
+				val |= (intr_vc_mask[my_cpu] << 16);
+				_write_32bit_cp2_register(XLP_MSG_STATUS1_REG, val);
+			} else if (xlp9xx_family) {
+				/* works for xlp9xx_family- 9xx RC and 5xx RC*/
+				/*TODO: Check for newer chips*/
+				val = 0xf;
+				_write_32bit_cp2_register(XLP_MSG_INT_REG, val);
+			}
+			page_addr[my_cpu] = 0;
+#ifdef CONFIG_32BIT
+			msgrng_access_disable(mflags);
+#endif
+			local_irq_restore(flags);
+		}
 	}
 	return 0;
 }
@@ -198,6 +241,20 @@ static int msgring_release (struct inode *inode, struct file *filp)
 	return 0;
 }
 
+static int msgring_mmap(struct file * filp, struct vm_area_struct * vma)
+{
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	unsigned long size = vma->vm_end - vma->vm_start;
+
+	/* only one page, offset should be zero */
+	if(offset || (size > PAGE_SIZE))
+		return -EINVAL;
+
+	if(remap_pfn_range(vma, vma->vm_start, page_paddr >> PAGE_SHIFT, 
+				size, vma->vm_page_prot))
+		return -EAGAIN;
+	return 0;
+}
 
 
 static long msgring_ioctl(struct file *filp, unsigned int cmd,
@@ -256,6 +313,7 @@ static struct file_operations msgring_fops = {
 	read:		msgring_read,
 	write:		msgring_write,
 	open:  		msgring_open,
+	mmap:		msgring_mmap,
 	unlocked_ioctl:	msgring_ioctl,
 	compat_ioctl:   msgring_compat_ioctl,
 	release:        msgring_release,
@@ -306,6 +364,19 @@ static int msgring_init(void)
 	    xlp9xx_family = 1;
 	if (is_nlm_xlp8xx())
 	    xlp8xx_family = 1;
+
+	page = alloc_pages(GFP_KERNEL, 1);
+	if(!page) {
+		printk("Page allocation failed in msgring driver\n");
+		return -ENOMEM;	
+	}
+	page_paddr = page_to_phys(page);
+	page_addr = (unsigned int *)page_address(page);
+
+	for(i = 0; i < NR_CPUS; i++){
+		page_addr[i] = 1;	
+	}
+
 	printk("returning from mgsring_init\n");
 
 	return 0;
@@ -313,11 +384,12 @@ static int msgring_init(void)
 
 static void msgring_exit(void)
 {
+	if(page)
+		free_pages((unsigned long)page_addr, 1);
 	device_destroy(msgring_class, msgring_devt);
 	class_unregister(msgring_class);
 	class_destroy(msgring_class);
 	unregister_chrdev(msgring_major, MSGRING_WAIT_CHRDEV_NAME);
-
 }
 
 module_init(msgring_init);
-- 
1.9.1

