From f9f4142ed7a24553758decbc2371c41c70989f30 Mon Sep 17 00:00:00 2001
From: PUNYA BHEEMESH <bheemesh@broadcom.com>
Date: Fri, 17 Oct 2014 17:28:02 +0530
Subject: [PATCH 1029/1532] netlib: DPDK porting to DM, MAC filtering. Added
 APIs for configuring shared CAM entries.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/netlib/include/export_sym.h |  1 +
 .../netlogic/lib/netlib/include/netsoc_haliface.h  |  1 +
 .../netlogic/lib/netlib/include/netsoc_libiface.h  |  7 +++
 arch/mips/netlogic/lib/netlib/include/nlm_nae.h    |  9 +++-
 arch/mips/netlogic/lib/netlib/src/netsoc_api.c     | 20 ++++++++
 arch/mips/netlogic/lib/netlib/src/netsoc_nae.c     | 57 ++++++++++++++++++----
 6 files changed, 83 insertions(+), 12 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/include/export_sym.h b/arch/mips/netlogic/lib/netlib/include/export_sym.h
index da812b8..45c6326 100644
--- a/arch/mips/netlogic/lib/netlib/include/export_sym.h
+++ b/arch/mips/netlogic/lib/netlib/include/export_sym.h
@@ -27,6 +27,7 @@ EXPORT_SYMBOL(netsoc_restart_ucore_using_fdt);
 EXPORT_SYMBOL(netsoc_modify_ucore_sram);
 EXPORT_SYMBOL(netsoc_read_ucore_sram);
 EXPORT_SYMBOL(netsoc_config_cpubypass);
+EXPORT_SYMBOL(netsoc_set_shcam_entry);
 EXPORT_SYMBOL(netsoc_write_ucore_shmem);
 EXPORT_SYMBOL(netsoc_prepad_enable);
 EXPORT_SYMBOL(netsoc_config_vfbid_table);
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
index 80627d5..2df0809 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
@@ -69,6 +69,7 @@ extern int __netsoc_restart_ucore_using_fdt(nae_t *nae, void *fdt);
 extern void __netsoc_modify_nae_ucore_sram_mem(nae_t *nae, unsigned int *data, uint32_t off, uint32_t words);
 extern void __netsoc_read_nae_ucore_sram_mem(nae_t *nae, unsigned int *data, uint32_t off, uint32_t words);
 extern int __netsoc_write_ucore_shared_mem(nae_t *nae, unsigned int *data, uint32_t words);
+extern int __netsoc_set_shcam_entry(nae_t *nae, uint32_t index, uint16_t *data);
 extern void __netsoc_init_ingress(nae_t *nae, uint32_t desc_size);
 extern int __netsoc_config_vfbid_table(nae_t *nae, uint32_t start, uint32_t num_entries, uint32_t *vfbid_tbl);
 extern int __netsoc_drain_frin_fifo_descs(nae_t *nae, uint32_t frin_q);
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
index e5aa3ca..351853a 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
@@ -299,6 +299,12 @@ static inline void netsoc_api_writeq(uint64_t base, uint32_t index, uint64_t val
 #define netsoc_write_ucode(base, ucore, offset, val) \
   nlh_write_cfg_reg32((base + 0x10000 + (ucore * CODE_SIZE_PER_UCORE) + offset), (val))
 
+#define netsoc_write_shcam(base, offset, val) \
+  nlh_write_cfg_reg16((base + 0x18000 + offset), (val))
+
+#define netsoc_read_shcam(base, offset) \
+  nlh_read_cfg_reg16((base + 0x18000 + offset))
+
 #define netsoc_read_ucode(base, ucore, offset) \
   nlh_read_cfg_reg32((base + 0x10000 + (ucore * CODE_SIZE_PER_UCORE) + offset))
 
@@ -524,6 +530,7 @@ extern int netsoc_get_total_frinq(nae_t *nae);
 extern int netsoc_config_vfbid_table(nae_t *nae, uint32_t start, uint32_t num_entries, uint32_t *vdbid_table);
 extern int netsoc_init_ingress(nae_t *nae, uint32_t desc_size);
 extern int netsoc_prepad_enable(nae_t *nae, uint32_t size);
+extern int netsoc_set_shcam_entry(nae_t *nae, uint32_t index, uint16_t *data);
 extern int netsoc_write_ucore_shmem(nae_t *nae, uint32_t *data, uint32_t words);
 extern void netsoc_read_ucore_sram(nae_t *nae, uint32_t *data,uint32_t off, uint32_t words);
 extern void netsoc_modify_ucore_sram(nae_t *nae, uint32_t *data,uint32_t off, uint32_t words);
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
index 2cdaaa9..ef44a31 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -45,11 +45,16 @@
 #define XLP_MAX_INTERLAKEN_IF		2
 
 #define MAX_UCORE_SRCS		16
-#define NLM_MAX_NODES           4
+#define NLM_MAX_NODES       4
 #define MAX_NAE_PERNODE		2
 #define MAX_NAE_BLOCKS		2
 #define MAX_POE_BLOCKS		2
-#define MAX_NAE_CPLX_PER_NODE   8
+#define MAX_NAE_CPLX_PER_NODE   	8
+
+#define SHCAM_MAX_FOLD_CFG	1536
+#define SHCAM_FOLD_CFG		384
+#define SHCAM_NUM_FOLDS		(SHCAM_MAX_FOLD_CFG/SHCAM_FOLD_CFG)
+#define SHCAM_MAX_16_DATA_UNITS_PER_ENTRY SHCAM_NUM_FOLDS
 
 #define FREEBACK_TO_NAE		0x01
 #define VFBID_FROM_FDT		0x02
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
index 4847d1d..ab38898 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
@@ -621,6 +621,26 @@ void netsoc_config_cpubypass(nae_t *nae, uint32_t vfbid_base)
 }
 
 /**
+* @brief netsoc_set_shcam_entry function is used to update the UCORE CAM
+* 
+* @param [in] nae pointer to nae_t
+* @param [in] index into ucore
+* @param [in] data Pointer to 16 bit data  
+*
+* @return
+*       - NETSOC_API_SUCCESS on success
+*       - < 0 on error
+* 
+* @ingroup hal_nae
+*
+*/
+
+int netsoc_set_shcam_entry(nae_t *nae, uint32_t index, uint16_t *data)
+{
+        return __netsoc_set_shcam_entry(nae, index, data);
+}
+
+/**
 * @brief netsoc_write_ucore_shmem function is used to update the scratch pad
 * 
 * @param [in] nae pointer to nae_t
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 10c3e59..6a746af 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -44,10 +44,8 @@ module_param(cl45_div, int, 0);
 
 
 
-
 static unsigned int ucore_shared_scratch[NLM_MAX_NODES][XLP9XX_MAX_NAE_PERNODE][256];
 static unsigned int ucore_shared_scratch_words[NLM_MAX_NODES][XLP9XX_MAX_NAE_PERNODE];
-
 extern net_port_t **cntx2netport[NLM_MAX_NODES][MAX_POE_BLOCKS];
 
 
@@ -475,6 +473,29 @@ int __netsoc_load_ucore(nae_t *nae, int ucore_mask, unsigned int *opcodes, int n
 	return NETSOC_API_SUCCESS;
 }
 
+int __netsoc_set_shcam_entry(nae_t *nae, uint32_t index, uint16_t *data)
+{
+	uint32_t entry_size = 2;
+	int i,j;
+
+	if(SHCAM_FOLD_CFG >= 384){
+		entry_size *= SHCAM_NUM_FOLDS;
+	} else if(SHCAM_FOLD_CFG == 256){
+		entry_size *= 6;
+	} else{
+		entry_size *= 8;
+	}
+	if(SHCAM_MAX_16_DATA_UNITS_PER_ENTRY != (entry_size/2))
+		return -1;
+
+	j=0;
+	for(i=SHCAM_MAX_16_DATA_UNITS_PER_ENTRY-1; i >= 0; i--){
+		netsoc_write_shcam(nae->mac_base, (((i * SHCAM_FOLD_CFG) + index)*2), data[j]);
+		j++;
+	}
+	return NETSOC_API_SUCCESS;
+}
+
 int __netsoc_write_ucore_shared_mem(nae_t *nae, unsigned int *data, uint32_t words)
 {
 	uint32_t i = 0, node, nae_id;
@@ -518,6 +539,7 @@ int __netsoc_reset_and_load_ucore(nae_t *nae, uint32_t ucore_mask, unsigned int
 	unsigned int id = 0, node = nae->node, nae_id = nae->nae_id;
 	int i, max_ucore = current_netsoc->max_ucores;
 	volatile uint32_t ucore_cfg = 0;
+	uint32_t shift=0;
 
 	netsoc_api_print(NETSOC_APIDBG_TRACE, " %p %x\n",opcodes, *opcodes);
 
@@ -526,19 +548,34 @@ int __netsoc_reset_and_load_ucore(nae_t *nae, uint32_t ucore_mask, unsigned int
 
 		ucore_cfg = netsoc_read_nae_reg(nae->nae_base, RX_UCORE_CFG);
 		ucore_cfg &= (~VAL_UCORE_RESET(ucore_mask));
-                ucore_cfg |= (1<<7);
+		ucore_cfg |= (1<<7);
+
+#ifdef MAC_FILTERING	
+		if(SHCAM_FOLD_CFG >= 384){
+			shift = (SHCAM_NUM_FOLDS)-1;
+		} else if(SHCAM_FOLD_CFG == 256){
+			shift = 4;;
+		} else{
+			shift = 5;
+		}
+
+		ucore_cfg |= (1<<shift);
+#endif
 		if (!is_nlm_xlp8xx_ax())
 			ucore_cfg |= (1<<28);
 
-                if (nae->cpu_bypass_mode) {
-                       netsoc_write_nae_reg(nae->nae_base, RX_UCORE_CFG, ucore_cfg | (1 << 24) | (1<<28));
-                }
-                else {
-		       netsoc_write_nae_reg(nae->nae_base, RX_UCORE_CFG, ucore_cfg | (1 << 24));
-                }
+		if (nae->cpu_bypass_mode) {
+			netsoc_write_nae_reg(nae->nae_base, RX_UCORE_CFG, ucore_cfg | (1 << 24) | (1<<28));
+		}
+		else {
+			netsoc_write_nae_reg(nae->nae_base, RX_UCORE_CFG, ucore_cfg | (1 << 24));
+		}
+#ifdef MAC_FILTERING
+		netsoc_write_nae_reg(nae->nae_base, RX_UCORE_CAM_MASK0_CFG, 0xffffffff);
+		netsoc_write_nae_reg(nae->nae_base, RX_UCORE_CAM_MASK1_CFG, 0xffffffff);
+#endif
 		netsoc_api_print(NETSOC_APIDBG_DEFAULT, "Ucore Reset Complete\n");
 	}
-
 	netsoc_api_print(NETSOC_APIDBG_DEFAULT, "Loading ucores (mask = 0x%04x)\n", mask);
 
 	while (id < max_ucore) {
-- 
1.9.1

