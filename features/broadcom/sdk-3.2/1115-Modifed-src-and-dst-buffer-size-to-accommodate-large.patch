From 8bb34e489f7e1feb81e11d9bbfbd28e419fbdfee Mon Sep 17 00:00:00 2001
From: Alok Agrawat <alok@broadcom.com>
Date: Fri, 23 Mar 2012 16:58:39 +0530
Subject: [PATCH 1115/1532] - Modifed src and dst buffer size to accommodate
 large chunck of data from small compressed input.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/nlm_cde/nlm_cde.c | 209 ++++++++++++++++++++++----------
 drivers/misc/netlogic/nlm_cde/nlm_cde.h |  15 ++-
 2 files changed, 154 insertions(+), 70 deletions(-)

diff --git a/drivers/misc/netlogic/nlm_cde/nlm_cde.c b/drivers/misc/netlogic/nlm_cde/nlm_cde.c
index aecfd3b..76593a6 100644
--- a/drivers/misc/netlogic/nlm_cde/nlm_cde.c
+++ b/drivers/misc/netlogic/nlm_cde/nlm_cde.c
@@ -61,8 +61,8 @@ int xlp_cde_ioctl(struct inode *inode, struct file *fptr, unsigned int type, uns
 ssize_t xlp_cde_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);
 ssize_t xlp_cde_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);
 static int xlp_cde_mmap(struct file * filp, struct vm_area_struct * vma);
-static unsigned char* cde_mem_start, *cde_input_mem, *cde_output_mem, *cde_inf_input_mem, *cde_inf_output_mem, *cde_inf_mem_start;
-static unsigned int cde_mem_size;
+static unsigned char* cde_mem_start = NULL, *cde_mem_start_1, *cde_mem_start_2, *cde_mem_start_3, *cde_mem_start_4, *cde_mem_start_5, *cde_input_mem, *cde_output_mem, *cde_inf_input_mem, *cde_inf_output_mem, *cde_inf_mem_start;
+static unsigned int cde_mem_size, cde_mem_size_1, cde_mem_size_2, cde_mem_size_3, cde_mem_size_4, cde_mem_size_5;
 
 struct nlm_cde_op
 {
@@ -175,8 +175,8 @@ static int config_cmp(void)
 #ifdef CDE_DEBUG
 	printk("config_cmp i = %d scratch_reg val = %x\n", i, val);
 #endif
-    nlm_hal_write_cde_reg(CMP_REG_CTRL_REG(i), ((0x0012 << 16) | CMP_PAGE_SIZE)); //16'h{CMP_PAGE_SIZE}
-    nlm_hal_write_cde_reg(CMP_REG_SCRATCH_PAGE(i), 0x801000); //16'h{CMP_PAGE_SIZE}
+    nlm_hal_write_cde_reg(CMP_REG_CTRL_REG(i), ((0x0012 << 16) | FD_CMP_PAGE_SIZE)); //16'h{CMP_PAGE_SIZE}
+    nlm_hal_write_cde_reg(CMP_REG_SCRATCH_PAGE(i), ((SCRATCH_SIZE/64 << 17) | (16 << 9)));
   }
   return 0;
 }
@@ -185,16 +185,10 @@ static int send_message(int stid, struct msgrng_msg *msg)
 {
   int ret = 0;
 
-	//printk("send_message = stid = %x msg = %llx\n",stid, msg->msg0);
 #ifdef CDE_DEBUG
 	printk("send_message = stid = %x msg = %llx\n",stid, msg->msg0);
 #endif
   nlm_hal_cde_send_request(stid, msg->msg0);
-#if 0
-  msgrng_flags_save(mflags);
-  ret = message_send_retry(1, 0, stid, msg);
-  msgrng_flags_restore(mflags);
-#endif
   return ret;
 }
 
@@ -209,7 +203,7 @@ static int send_free_desc(void)
   // send free descriptors to cmp block
   for (i = 0; i < NUM_FREE_DESCRIPTORS; i++) {
     if (!page_array[i].data_array)	  
-	page_array[i].data_array = get_cache_aligned_mem(CMP_PAGE_SIZE);
+	page_array[i].data_array = get_cache_aligned_mem(FD_CMP_PAGE_SIZE);
     if (!page_array[i].data_array)	{
 	    printk("cacheline_aligned_kmalloc returmed error\n");
 	    return -1;
@@ -266,14 +260,13 @@ int create_inf_message(cmp_data_t *cmp_data, int type, int start_of_file, int en
   div = num_blk * num_desc;
 
   rtn_bkt = cde_get_fb_vc();
-  type = 3;
-  if(cmp_data->src_size > MAX_BUFFER_SIZE)
+  type = 1;
+  if(cmp_data->src_size > MAX_INPUT_BUFFER_SIZE)
   {
-	  printk("ERROR:src_size if more than %d. No space to store\n", MAX_BUFFER_SIZE);
+	  printk("ERROR:src_size = %d if more than %d. No space to store\n", cmp_data->src_size, MAX_INPUT_BUFFER_SIZE);
 	  return 0;
   }
-  num_desc = (cmp_data->src_size/PAGE_SIZE) + ((cmp_data->src_size %PAGE_SIZE)?1:0);
-
+  num_desc = (cmp_data->src_size/CMP_PAGE_SIZE) + ((cmp_data->src_size %CMP_PAGE_SIZE)?1:0);
   for (i = 0; i < num_messages; i++) {
     //create scratch page descriptor
     cur_desc = 0;
@@ -287,10 +280,9 @@ int create_inf_message(cmp_data_t *cmp_data, int type, int start_of_file, int en
 #endif
     cur_desc++;
 
-    for (j = 0; j < num_blk/num_messages; j++) {
+    for (j = 0; j < num_blk; j++) {
       for (k = 0; k < num_desc; k++) {
-	eof = 1;//end_of_file;
-//	eof = end_of_file;
+	eof = end_of_file;
 
 	sod = 1;//(start == 0);
 	sob = (k == 0);
@@ -298,7 +290,7 @@ int create_inf_message(cmp_data_t *cmp_data, int type, int start_of_file, int en
 	save = ((eob == 1) & (end_of_file == 0)); //((eof == 0) & (eob == 1));
 	restore = 0; //restore only can be 1 on scratch descriptor
 //save = 0;
-	length = ((cmp_data->src_size - start)> PAGE_SIZE)?PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
+	length = ((cmp_data->src_size - start)> CMP_PAGE_SIZE)?CMP_PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
 
 	cmp_data->src_desc[cur_desc] =
 	  cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (unsigned long)virt_to_phys(cmp_data->src + start)));
@@ -322,7 +314,6 @@ int create_inf_message(cmp_data_t *cmp_data, int type, int start_of_file, int en
 
     stid = nlm_hal_cde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0, 0, cmp_data->op, rtn_bkt,
 			cur_desc, (unsigned long)virt_to_phys(cmp_data->src_desc + desc_idx));
-//printk("cmp_msg = %llx\n", cmp_msg[i].msg0);
 #ifdef CDE_DEBUG
       printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx\n", __FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0); 
 #endif
@@ -361,18 +352,16 @@ int create_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of
 
   rtn_bkt = cde_get_fb_vc();
 
-  if(cmp_data->src_size > MAX_BUFFER_SIZE)
+  if(cmp_data->src_size > MAX_INPUT_BUFFER_SIZE)
   {
-	  printk("ERROR:src_size if more than %d. No space to store\n", MAX_BUFFER_SIZE);
+	  printk("ERROR:src_size if more than %d. No space to store\n", MAX_INPUT_BUFFER_SIZE);
 	  return 0;
   }
-  num_desc = (cmp_data->src_size/PAGE_SIZE) + ((cmp_data->src_size %PAGE_SIZE)?1:0);
-
+  num_desc = (cmp_data->src_size/CMP_PAGE_SIZE) + ((cmp_data->src_size %CMP_PAGE_SIZE)?1:0);
   for (i = 0; i < num_messages; i++) {
     //create scratch page descriptor
     cur_desc = 0;
     restore = (start_of_file == 0);//((num_messages > 1) & (cur_blk != 0));
-//restore = 0;
     length = SCRATCH_SIZE ;
 
     cmp_data->src_desc[desc_idx] =
@@ -389,13 +378,13 @@ int create_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of
       for (k = 0; k < num_desc; k++) {
 	eof = end_of_file;
 
-	sod = (start == 0);
+	sod = 1;//(start == 0);
 	sob = (k == 0);
 	eob = (k == num_desc-1);
 	save = ((type == CDE_STATIC) & (eof == 0) & (eob == 1));
 	restore = 0; //restore only can be 1 on scratch descriptor
 
-	length = ((cmp_data->src_size - start)> PAGE_SIZE)?PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
+	length = ((cmp_data->src_size - start)> CMP_PAGE_SIZE)?CMP_PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
 	cmp_data->src_desc[cur_desc] =
 	  cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (unsigned long)virt_to_phys(cmp_data->src + start)));
 
@@ -488,7 +477,6 @@ static int nlm_hal_cde_read_cmp_msg(char *buffer, uint64_t payload)
   uint64_t *desc, dest_addr;
   int num_desc = (payload >> 40) & 0x3fff;
   char * tmp_ptr;
-
   for (i = 0; i < num_desc; i++) {
     desc = phys_to_virt(payload & 0xffffffffffUll) + i*8; //64 byte descriptors //dliao: why i*8??
 
@@ -556,7 +544,7 @@ cmp_data_t* nlm_cde_init()
     return NULL;
   memset(cmp_data, 0, sizeof(cmp_data_t));
 
-  cmp_data->src = kmalloc(MAX_BUFFER_SIZE, GFP_KERNEL);
+  cmp_data->src = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(MAX_INPUT_BUFFER_SIZE));
   if (! cmp_data->src)	{
 	  printk("kmalloc returns Error : cmp_data->src\n");
 	  kfree(cmp_data);
@@ -564,14 +552,14 @@ cmp_data_t* nlm_cde_init()
 	  return NULL;
   }
 	  
-  cmp_data->target = kmalloc(MAX_BUFFER_SIZE, GFP_KERNEL);
+  cmp_data->target = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(MAX_BUFFER_SIZE));
   if (! cmp_data->target)	{
 	  printk("kmalloc returns Error : cmp_data->target\n");
 	  kfree(cmp_data->src);
 	  kfree(cmp_data);
 	  return NULL;
   }
-  cmp_data->src_desc = kmalloc(sizeof(unsigned long long) * CMP_PAGE_SIZE , GFP_KERNEL);
+  cmp_data->src_desc = kmalloc(CMP_PAGE_SIZE , GFP_KERNEL);
   if (! cmp_data->src_desc)	{
 	  printk("kmalloc returns Error : cmp_data->src_desc\n");
 	  kfree(cmp_data->src);
@@ -579,8 +567,8 @@ cmp_data_t* nlm_cde_init()
 	  kfree(cmp_data);
 	  return NULL;
   }
-  cmp_data->scratch = kmalloc(sizeof(unsigned long long) * SCRATCH_SIZE , GFP_KERNEL);
-  cmp_data->scratch_inf = kmalloc(sizeof(unsigned long long) * SCRATCH_SIZE , GFP_KERNEL);
+  cmp_data->scratch = kmalloc( SCRATCH_SIZE , GFP_KERNEL);
+  cmp_data->scratch_inf = kmalloc( SCRATCH_SIZE , GFP_KERNEL);
   if (! cmp_data->scratch || !cmp_data->scratch_inf)	{
 	  printk("kmalloc returns Error : cmp_data->scratch\n");
 	  kfree(cmp_data->src);
@@ -590,25 +578,51 @@ cmp_data_t* nlm_cde_init()
 	  return NULL;
   }
 
-  size = sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int) + MAX_BUFFER_SIZE * 2;/*struct cde + input size + output size + input buf + output buf */
-  cde_mem_start = kmalloc(size * 2, GFP_KERNEL);
-  cde_mem_size = size * 2;
-  if (!cde_mem_start)	
-	 printk("kmalloc returns Error : cde_mem_start\n");
- 
-  cde_input_mem = cde_mem_start + sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int);
-  cde_output_mem = cde_input_mem + MAX_BUFFER_SIZE;
-
-  cde_inf_mem_start = cde_output_mem + MAX_BUFFER_SIZE;
-  cde_inf_input_mem = cde_inf_mem_start + sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int);
-  cde_inf_output_mem = cde_inf_input_mem + MAX_BUFFER_SIZE;
-
-  memset(cde_mem_start, 0, size); 
-  memset(cmp_data->src, 0, MAX_BUFFER_SIZE);
+  cde_mem_size_1 = cde_mem_size_3 = MAX_INPUT_BUFFER_SIZE;
+  cde_mem_size_2 = cde_mem_size_4 = MAX_BUFFER_SIZE;
+  cde_mem_size_5 = (sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int)) * 2;
+  cde_mem_size = cde_mem_size_5 + cde_mem_size_1 + cde_mem_size_2 + cde_mem_size_3 + cde_mem_size_4;
+
+  if(cde_mem_size_5 < PAGE_SIZE) cde_mem_size_5 = PAGE_SIZE;
+
+  cde_input_mem = cde_mem_start_1 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_1));
+  if(cde_mem_start_1 == NULL) 
+  {
+    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_1);
+    return NULL;
+  }
+  cde_output_mem = cde_mem_start_2 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_2));
+  if(cde_mem_start_2 == NULL) 
+  {
+    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_2);
+    return NULL;
+  }
+  cde_inf_input_mem = cde_mem_start_3 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_3));
+  if(cde_mem_start_3 == NULL) 
+  {
+    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_3);
+    return NULL;
+  }
+  cde_inf_output_mem = cde_mem_start_4 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_4));
+  if(cde_mem_start_4 == NULL)
+  {
+    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_4);
+    return NULL;
+  }
+  cde_mem_start = cde_mem_start_5 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_5));
+  if(cde_mem_start_5 == NULL) 
+  {
+    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_5);
+    return NULL;
+  }
+  cde_inf_mem_start = cde_mem_start + sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int);
+  
+  memset(cmp_data->src, 0, MAX_INPUT_BUFFER_SIZE);
   memset(cmp_data->target, 0, MAX_BUFFER_SIZE);
-  memset(cmp_data->src_desc, 0, sizeof(unsigned long long) * CMP_PAGE_SIZE);
-  memset(cmp_data->scratch, 0, sizeof(unsigned long long) *SCRATCH_SIZE);
-  memset(cmp_data->scratch_inf, 0, sizeof(unsigned long long) *SCRATCH_SIZE);
+
+  memset(cmp_data->src_desc, 0, CMP_PAGE_SIZE);
+  memset(cmp_data->scratch, 0, SCRATCH_SIZE);
+  memset(cmp_data->scratch_inf, 0, SCRATCH_SIZE);
 
   if (config_cmp() == -1)
 	return NULL;
@@ -634,9 +648,9 @@ void nlm_cde_cleanup(cmp_data_t *cmp_data)
   int i;
 
   if (cmp_data->src)  
-	  kfree(cmp_data->src);
+	free_pages ((ulong)cmp_data->src, get_order (MAX_INPUT_BUFFER_SIZE));
   if (cmp_data->target)  
-	  kfree(cmp_data->target);
+	free_pages ((ulong)cmp_data->target, get_order (MAX_BUFFER_SIZE));
   if (cmp_data->src_desc)  
 	  kfree(cmp_data->src_desc);
   if (cmp_data->scratch)  
@@ -645,6 +659,12 @@ void nlm_cde_cleanup(cmp_data_t *cmp_data)
 	  kfree(cmp_data->scratch_inf);
   if (cmp_data)
     kfree(cmp_data);
+  free_pages(cde_mem_start_1, get_order(cde_mem_size_1));
+  free_pages(cde_mem_start_2, get_order(cde_mem_size_2));
+  free_pages(cde_mem_start_3, get_order(cde_mem_size_3));
+  free_pages(cde_mem_start_4, get_order(cde_mem_size_4));
+  free_pages(cde_mem_start_5, get_order(cde_mem_size_5));
+
     cmp_data->src = NULL;
     cmp_data->target = NULL;
     cmp_data->src_desc = NULL; 
@@ -665,8 +685,8 @@ static int xlp_cde_mmap(struct file * filp, struct vm_area_struct * vma)
 {
 	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
 	unsigned long size = 0;
-	int result = 0;
-	unsigned long cde_pfn_addr = 0;
+	int result = 0, result_t = 0;
+	unsigned long cde_pfn_addr = 0, vm_start = vma->vm_start;
 	if (cde_mem_size <= 0) return -ENXIO;
 
 	if (offset >= cde_mem_size) return -ESPIPE;
@@ -677,9 +697,30 @@ static int xlp_cde_mmap(struct file * filp, struct vm_area_struct * vma)
 	pgprot_val (vma->vm_page_prot) &= ~_CACHE_MASK;
 	pgprot_val (vma->vm_page_prot) |= _CACHE_CACHABLE_COW;
 
-	cde_pfn_addr = ((uint64_t)cde_mem_start >> PAGE_SHIFT);
-	result = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, size, 
+	
+	cde_pfn_addr = ((uint64_t)cde_mem_start_1 >> PAGE_SHIFT);
+	result = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_1, 
 								vma->vm_page_prot);
+	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_1);
+
+	cde_pfn_addr = ((uint64_t)cde_mem_start_2 >> PAGE_SHIFT);
+	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_2, 
+								vma->vm_page_prot);
+
+	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_2);
+	cde_pfn_addr = ((uint64_t)cde_mem_start_3 >> PAGE_SHIFT);
+	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_3, 
+								vma->vm_page_prot);
+	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_3);
+	cde_pfn_addr = ((uint64_t)cde_mem_start_4 >> PAGE_SHIFT);
+	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_4, 
+								vma->vm_page_prot);
+
+	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_4);
+	cde_pfn_addr = ((uint64_t)cde_mem_start_5 >> PAGE_SHIFT);
+	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_5, 
+								vma->vm_page_prot);
+	vma->vm_start = vm_start;
 	if (result) return -EAGAIN;
 
 	return 0;
@@ -689,8 +730,8 @@ int xlp_cde_release(struct inode *inode, struct file *filp)
 { 
   cmp_data->target_size = 0;
   cmp_data->offset = 0;
-  memset(cmp_data->scratch, 0,  sizeof(unsigned long long) *SCRATCH_SIZE);
-  memset(cmp_data->scratch_inf, 0, sizeof(unsigned long long) *SCRATCH_SIZE);
+  memset(cmp_data->scratch, 0,  SCRATCH_SIZE);
+  memset(cmp_data->scratch_inf, 0, SCRATCH_SIZE);
   return 0;
 }
 
@@ -703,7 +744,7 @@ unsigned int nlm_cde_receive_response(cmp_data_t *cmp_data, unsigned char *buf,
 
 	memcpy(buf, &cmp_data->target[cmp_data->offset], size);
 #ifdef CDE_DEBUG
-	printk("xlp_cde_read cmp_data->target_size = %d size = %d\n",cmp_data->target_size, size);
+	printk("xlp_cde_read cmp_data->target_size = %d size = %d\n",cmp_data->Target_size, size);
 	dump_buffer(cmp_data->target, size, "Output:");
 #endif
 	cmp_data->offset += size;
@@ -792,6 +833,7 @@ int xlp_cde_ioctl(struct inode *inode, struct file *filp,
 	      unsigned int cmd, unsigned long arg)
 {
   int err = 0, i = 0;
+  static int k = 0;
   struct nlm_cde_op *cde;
   unsigned int input_size = 0, output_size = 0, size;
   unsigned char *input_mem, *output_mem, *mem_start;
@@ -814,7 +856,6 @@ int xlp_cde_ioctl(struct inode *inode, struct file *filp,
     output_mem = cde_output_mem;
     mem_start = cde_mem_start;
     break;
-
   default:
 	printk("xlp_cde_ioctl: default\n");
     return -ENOTTY;
@@ -830,7 +871,7 @@ int xlp_cde_ioctl(struct inode *inode, struct file *filp,
   cmp_data->sof = cde->sof;
   cmp_data->eof = cde->eof;
   size = nlm_cde_send_request(cmp_data, cmp_data->op, cmp_data->compression_type, cmp_data->sof, cmp_data->eof, (unsigned char*)input_mem, input_size);
-//printk("written %d byte of data\n", size);
+//printk("#%d written %d byte of data\n", k++, size);
   size = 0;
   do{
     size = nlm_cde_receive_response(cmp_data, (unsigned char*)output_mem, output_size);
@@ -838,10 +879,49 @@ int xlp_cde_ioctl(struct inode *inode, struct file *filp,
   }while(size == 0 && i < 0xffffff); 
   *(unsigned int*)(mem_start + sizeof(struct nlm_cde_op) + sizeof(unsigned int)) = size;
 //printk("Read %d byte of data\n", size);
-
+//dump_buffer(cmp_data->scratch_inf, SCRATCH_SIZE, "Inf Scratch:");
   return err;
 }
+static unsigned strtonum(char c)
+{
+        if(c >= '0' && c <= '9')
+                return (c - '0');
+
+        if(c >= 'A' && c <= 'F')
+                return (c - 'A' + 10);
+
+        if(c >= 'a' && c <= 'f')
+                return (c - 'a' + 10);
+}
+
+static void test()
+{
+  int err = 0, i = 0;
+  unsigned int input_size = 0, output_size = 0, size;
+  unsigned char *input_mem, *output_mem, *mem_start;
+  
+  input_mem = cde_inf_input_mem;
+  output_mem = cde_inf_output_mem;
+  mem_start = cde_inf_mem_start;
+  
+  input_size = sizeof(src_gz_data)/2;//200;
+  output_size = MAX_BUFFER_SIZE;
+  for(i = 0; i < (input_size*2); i=i+2)
+  {
+    input_mem[i/2] = (strtonum(src_gz_data[i]) << 4) | strtonum(src_gz_data[i+1]);
+  }
+//dump_buffer(input_mem, input_size, "input:");
+  size = nlm_cde_send_request(cmp_data, 0, 1, 1, 1, (unsigned char*)input_mem, input_size);
+  printk("written %d byte of data\n", size);
+  size = 0;
+  do{
+    size = nlm_cde_receive_response(cmp_data, (unsigned char*)output_mem, output_size);
+    i++;
+  }while(size == 0 && i < 0xffffff); 
+  printk("Read %d byte of data\n", size);
+//dump_buffer(output_mem, size, "output:");
 
+}
 
 static int __init xlp_cde_init(void)
 {
@@ -884,6 +964,7 @@ static int __init xlp_cde_init(void)
   /*TEMP*/
   nlm_cde_init();
 }
+ //test();
 
     return 0;
 }
diff --git a/drivers/misc/netlogic/nlm_cde/nlm_cde.h b/drivers/misc/netlogic/nlm_cde/nlm_cde.h
index 3cec0e2..77922161 100644
--- a/drivers/misc/netlogic/nlm_cde/nlm_cde.h
+++ b/drivers/misc/netlogic/nlm_cde/nlm_cde.h
@@ -46,13 +46,16 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 #define RTN_BKT 1
 #define FD_BURST_SIZE 1
-#define NUM_FREE_DESCRIPTORS 100 //must be less or equal to MAX_NUM_PAGES
-#define MAX_NUM_PAGES 100
-#define MAX_BUFFER_SIZE 1024*64
-#define CMP_PAGE_SIZE   2048//1024
-#define SCRATCH_SIZE    (1024)
-#define MAX_NUM_MESSAGES 20
+#define NUM_FREE_DESCRIPTORS 2048 //must be less or equal to MAX_NUM_PAGES
+#define MAX_NUM_PAGES 2048
+#define MAX_BUFFER_SIZE (1024*2048)
+#define MAX_INPUT_BUFFER_SIZE (1024*64)
+#define CMP_PAGE_SIZE   (2*1024)
+#define FD_CMP_PAGE_SIZE   (32*1024)
+#define SCRATCH_SIZE    (8*1024)
+#define MAX_NUM_MESSAGES 100
 
+unsigned char src_gz_data[] = {"edc13101000000c2a0f54f6d085fa000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e03"};
 
 typedef struct cmp_data_structure {
   char *src;    // source data
-- 
1.9.1

