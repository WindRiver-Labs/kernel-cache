From 3573f652c5ac32fcad6318f917b4eb7a2622d090 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Wed, 20 Oct 2010 18:04:49 -0700
Subject: [PATCH 1312/1532] NAE: Recarve free-in desc fifos when relying on
 firmware config, drop packets with errors in rx message desc

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/init_nae.c | 58 ++++++++++++++++++++-
 drivers/net/ethernet/broadcom/nae/xlp_nae.c  | 78 ++++++++++++++++++----------
 2 files changed, 106 insertions(+), 30 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/init_nae.c b/drivers/net/ethernet/broadcom/nae/init_nae.c
index 17818d7..8084886 100644
--- a/drivers/net/ethernet/broadcom/nae/init_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/init_nae.c
@@ -285,6 +285,15 @@ static void parse_fdt_nae_config(void)
 			/* Configure per port NAE registers */
 			nlm_hal_init_nae_regs(port_type, nae_regs, num_nae_regs);
 		}
+		else {
+			int reg = 0;
+
+			/* don't rely on firmware for free-in desc carving */
+			for (reg = 0; reg < num_nae_regs; reg++) {
+				if (nae_regs[reg * 2] != FREE_IN_FIFO_CFG) continue;
+				nlm_hal_write_nae_reg(FREE_IN_FIFO_CFG, nae_regs[reg * 2 + 1]);
+			}
+		}
 
 		kfree(nae_regs);
 		kfree(intf_regs);
@@ -310,7 +319,7 @@ static void config_fmn(void)
 	msgrng_access_disable(mflags);
 }
 
-static void zap_nae_frin_fifo(void)
+static void drain_nae_frin_fifo_descs(void)
 {
 	int i = 0;
 	uint32_t value = 0;
@@ -330,6 +339,46 @@ static void zap_nae_frin_fifo(void)
 	nlm_hal_write_nae_reg(RX_FREE_FIFO_POP, 0);
 }
 
+static void print_frin_desc_carving(void)
+{
+	int intf;
+
+	if (!debug) return;
+
+	for (intf = 0; intf < 20; intf++) {
+		uint32_t value = 0;
+		int start = 0, size = 0;
+
+		nlm_hal_write_nae_reg(FREE_IN_FIFO_CFG, (0x80000000 | intf));
+
+		value = nlm_hal_read_nae_reg(FREE_IN_FIFO_CFG);
+		size = (value >> 20) & 0x3ff;
+		start = (value >> 8) & 0x1ff;
+
+		printk("intf@%02d=0x%08x, start=%d, size=%d\n", intf, value, start, size);
+	}
+}
+
+static void deflate_frin_fifo_carving(void)
+{
+	int intf = 0;
+	const int minimum_size = 8; /* this represents entries, each entry holds 2 descriptors */
+	int start = 0;
+	uint32_t value = 0;
+
+	printk("FRIN desc carving before resetting...\n");
+	print_frin_desc_carving();
+
+	for (intf = 0; intf < 20; intf++) {
+		start = minimum_size * intf;
+		value = (minimum_size << 20) | (start << 8) | (intf);
+		nlm_hal_write_nae_reg(FREE_IN_FIFO_CFG, value);
+	}
+
+	printk("FRIN desc carving after resetting...\n");
+	print_frin_desc_carving();
+}
+
 int initialize_nae(void)
 {
 	int i = 0;
@@ -352,7 +401,9 @@ int initialize_nae(void)
 		cntx2port[i] = 18;
 	}
 
-	zap_nae_frin_fifo();
+	/* frin_fifo represents the 20 pools of free-in descriptor fifos */
+	drain_nae_frin_fifo_descs();
+	deflate_frin_fifo_carving();
 
 	config_fmn();
 
@@ -389,5 +440,8 @@ int initialize_nae(void)
 
 	}
 
+	printk("FRIN desc carving after HAL initialization...\n");
+	print_frin_desc_carving();
+
 	return 0;
 }
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index 2000793..7ffcd2b 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -46,6 +46,9 @@
 #include <linux/mman.h>
 #include <linux/mm.h>
 #include <linux/pci.h>
+
+#include <net/ip.h>
+
 #include <asm/current.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -809,11 +812,18 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 	}
 	else if(vc == nae_rx_vc && size == 2)
 	{
+		int bad_pkt = 0;
+		int err = (msg1 >> 4) & 0x1;
+		int ip_csum_valid = (msg1 >> 3) & 0x1;
+		int tcp_csum_valid = (msg1 >> 2) & 0x1;
+
 		/* Rx packet */
 		addr	= msg1 & 0xffffffffc0ULL;
 		len	= (msg1 >> 40) & 0x3fff;
 		context = (msg1 >> 54) & 0x3ff;
 
+		if (err) bad_pkt = 1;
+
 		if (drop_uboot_pkt) {
 			if ( (addr >= (192<<20)) && (addr < (256 << 20)) ) {
 				printk("Dropping firmware RX packet (addr=%llx)!\n", addr);
@@ -847,44 +857,56 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 
 		len = len  - MAC_CRC_LEN;
 
-		if(len > ETH_MTU_SIZE)
-		{
+		skb = mac_get_skb_back_ptr(vaddr);
+		if (!skb) {
 			priv->stats.rx_errors++;
 			priv->stats.rx_dropped++;
-			printk("[%s] packet too long %d, drop it!\n",__FUNCTION__,len);
-			return ;
+			printk("[%s] Null skb? addr=%llx, vaddr=%llx, drop it!\n",
+			       __func__, addr, vaddr);
+			cpu_halt();
+			return;
 		}
 
-		skb = mac_get_skb_back_ptr(vaddr);
-		if (skb) {
-                        skb_put(skb, len);
-                        skb->dev = dev_mac[port];
-                        skb->protocol = eth_type_trans(skb, dev_mac[port]);
-                        skb->dev->last_rx = jiffies;
-
-			/* Pass the packet to Network stack */
-			netif_rx (skb);
-
-			/* Update Stats */
-			priv->stats.rx_bytes += len;
-			priv->stats.rx_packets++;
-			priv->cpu_stats[cpu].rx_packets++;
-
-			if (atomic64_inc_return(&priv->frin_to_be_sent) > frin_desc_thres);
-			{
-				tasklet_schedule(&mac_refill_task[port]);
-				//mac_refill_frin_desc((unsigned long) skb->dev) ;
+		if (debug) {
+			struct iphdr *iph = (struct iphdr *)(vaddr + 14);
+			int net_pkt_len = iph->tot_len + 14;
+			int eth_proto = *(unsigned short *)(vaddr + 12);
+
+			if ((eth_proto == 0x800) && (net_pkt_len != len)) bad_pkt = 1;
+
+			if (bad_pkt) {
+				printk("[%s]: vaddr=%llx (len:%d/%d) (ip:proto=%d) (%d/%d/%d))\n",
+				       __func__, vaddr, net_pkt_len, len, iph->protocol,
+				       err, ip_csum_valid, tcp_csum_valid);
 			}
 		}
-		else
-		{
+
+		if (bad_pkt) {
 			priv->stats.rx_errors++;
 			priv->stats.rx_dropped++;
-			printk("[%s] Null skb? addr=%llx, vaddr=%llx, drop it!\n",
-			       __func__, addr, vaddr);
-			cpu_halt();
+
+			dev_kfree_skb_any(skb);
 			return;
 		}
+
+		skb_put(skb, len);
+		skb->dev = dev_mac[port];
+		skb->protocol = eth_type_trans(skb, dev_mac[port]);
+		skb->dev->last_rx = jiffies;
+
+		/* Pass the packet to Network stack */
+		netif_rx (skb);
+
+		/* Update Stats */
+		priv->stats.rx_bytes += len;
+		priv->stats.rx_packets++;
+		priv->cpu_stats[cpu].rx_packets++;
+
+		if (atomic64_inc_return(&priv->frin_to_be_sent) > frin_desc_thres);
+		{
+			tasklet_schedule(&mac_refill_task[port]);
+			//mac_refill_frin_desc((unsigned long) skb->dev) ;
+		}
 	} else {
 		printk("[%s]: wrong vc=%d or size=%d?\n", __func__, vc, size);
 	}
-- 
1.9.1

