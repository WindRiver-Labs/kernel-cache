From 8ce3e3df21eb7c6a1e202cf2f40e55b1a8de3491 Mon Sep 17 00:00:00 2001
From: Sandip Matte <sandipm@broadcom.com>
Date: Fri, 20 Sep 2013 08:47:28 -0700
Subject: [PATCH 1514/1532] sae_module: Make changes in gcm and ccm algos to
 run on 9xx. 1. Fixed wrong offset calculation which causes different fields
 to overlap when more than 7 fragments were present. 2. GCM, CCM changes so
 that algos work on 9xx.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/crypto/sae/nlm_aead.c | 84 +++++++++++++++++++++++++++++--------------
 1 file changed, 58 insertions(+), 26 deletions(-)

diff --git a/drivers/crypto/sae/nlm_aead.c b/drivers/crypto/sae/nlm_aead.c
index d473ffa..8d65d59 100755
--- a/drivers/crypto/sae/nlm_aead.c
+++ b/drivers/crypto/sae/nlm_aead.c
@@ -76,9 +76,9 @@ struct nlm_aead_ctx
 #define IV_AEAD_PADDING         128 
 #define TAG_LEN			64
 
-#define PACKET_DESC_SIZE        (64 + sizeof(struct saesoc_data_desc) + (MAX_FRAGS*8) + sizeof(struct nlm_async_crypto) + TAG_LEN + IV_AEAD_PADDING + 128)
+#define PACKET_DESC_SIZE        (128 + sizeof(struct saesoc_data_desc) + (MAX_FRAGS*8) + sizeof(struct nlm_async_crypto) + TAG_LEN + IV_AEAD_PADDING + 128)
 #define NLM_CRYPTO_DATA_DESC(addr)  (struct saesoc_data_desc *) (((unsigned long)addr + 63) & ~0x3fUL)
-#define NLM_ASYNC_PTR_PARAM_OFFSET(addr)        (((unsigned long)addr +  sizeof(struct saesoc_data_desc) + (MAX_FRAGS*8) + 63) & ~0x3fUL)
+#define NLM_ASYNC_PTR_PARAM_OFFSET(addr)        (((unsigned long)addr +  sizeof(struct saesoc_data_desc) + (MAX_FRAGS*8) + 64 + 63) & ~0x3fUL)
 #define NLM_HASH_OFFSET(addr)			((unsigned long)addr + (PACKET_DESC_SIZE - TAG_LEN))
 #define NLM_IV_OFFSET(addr)			((unsigned long)addr + (PACKET_DESC_SIZE - TAG_LEN - IV_AEAD_PADDING ))
 
@@ -541,13 +541,19 @@ static int aead_gcm_rfc4106_setkey( struct crypto_aead *tfm, const u8 *key,
 	initp->cipher.iv_mode = 0;
 	initp->cipher.key = (char *)key;
 	initp->cipher.key_len = keylen;
+        if (cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2)
+		initp->cipher.key_len = cipher_keylen;
 	initp->cipher.cfb_mask = 0;
 	initp->cipher.flags = SAESOC_CF_ENCRYPT;
 	initp->hash.type = auth_alg;
+        if (cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2)
+		initp->hash.type = SAESOC_HASH_TYPE_GHASH;
 	initp->hash.mode = SAESOC_HASH_MODE_GCM;
 	initp->hash.iv_offset = 0;
 	initp->hash.key = (char *)key;
 	initp->hash.key_len = keylen;
+        if (cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2)
+		initp->hash.key_len = cipher_keylen;
 	initp->hash.mute_mask_sel = 0;
 	initp->hash.tag_len = 128 / 8;
 	initp->hash.tagin_offset = 0;
@@ -556,13 +562,16 @@ static int aead_gcm_rfc4106_setkey( struct crypto_aead *tfm, const u8 *key,
 	initp->hash.addl_hash_len = 0;
 	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC;
 	initp->payload_offset = 16 + assoc_len;
+        if (cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2)
+		initp->payload_offset = 16 + 16;
 	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
 
 	nsdescs = saesoc_calc_sdesc_cnt(&ctx->initp,NULL);
 	s_desc = &ctx->enc_s_desc;
 
-	if (lparam.saesoc_feature_set & SAESOC_FF_EXPLICIT_IV_SUPPORT) {
-		initp->hash.flags |= SAESOC_HF_TAGOUT_EOP;
+        if (cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2) {
+		initp->hash.flags |= SAESOC_HF_TAGOUT_EOP |
+			SAESOC_HF_HASHINP_IS_CIPHEROUT;
 	}
 
 
@@ -572,6 +581,9 @@ static int aead_gcm_rfc4106_setkey( struct crypto_aead *tfm, const u8 *key,
 	initp->cipher.flags = 0;
 	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC | SAESOC_HF_HASHINP_IS_CIPHEROUT;
 
+        if (cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2)
+		initp->hash.flags = SAESOC_HF_TAGOUT_EOP | SAESOC_HF_HASH_L3_ALLOC;
+
 	s_desc = &ctx->dec_s_desc;
 
 	if(saesoc_new_session(&ctx->initp,&s_desc,nsdescs, NULL) < 0)
@@ -643,9 +655,9 @@ static int aead_ccm_rfc4309_setkey(struct crypto_aead *tfm, const u8 *key,
 	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC;
 	initp->payload_offset = 16 + 16 + 16; /* env IV, auth IV, 2 extra for assoc len storage + assoc + zero*/
 	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
-
-	initp->hash.aad_offset = 32; /* auth offset */
-	if (lparam.saesoc_feature_set & SAESOC_FF_EXPLICIT_IV_SUPPORT) {
+	
+	initp->hash.aad_offset = 16; /* auth offset */
+        if (cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2) {
 		initp->hash.flags |= SAESOC_HF_TAGOUT_EOP;
 		initp->hash.aad_offset = 34; /* auth offset */
 	}
@@ -657,11 +669,13 @@ static int aead_ccm_rfc4309_setkey(struct crypto_aead *tfm, const u8 *key,
 		 printk("%s,%d Error \n", __FUNCTION__, __LINE__); 
 
 	initp->cipher.flags = 0;
-	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC | SAESOC_HF_HASHINP_IS_CIPHEROUT;
 
-	if (lparam.saesoc_feature_set & SAESOC_FF_EXPLICIT_IV_SUPPORT) {
+	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC;
+        if (cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2)
+		initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC | SAESOC_HF_HASHINP_IS_CIPHEROUT;
+
+        if (cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2)
 		initp->hash.flags |= SAESOC_HF_TAGOUT_EOP;
-	}
 
 	s_desc = &ctx->dec_s_desc;
 
@@ -723,12 +737,6 @@ static int xlp_aes_ctr_setkey( struct crypto_aead *tfm, u8 *key,
 	      |----auth offset
 	                                         |--> cipher offset */ 
 
-	//TODO: We can give IV in packet descriptor if that feature is enabled
-	//in chip... Might improve performance.
-	if (lparam.saesoc_feature_set & SAESOC_FF_EXPLICIT_IV_SUPPORT) {
-		//initp->hash.iv_mode = SAESOC_IV_FROM_PKT_DESC;
-		//initp->cipher.iv_mode = SAESOC_IV_FROM_PKT_DESC;
-	}
 	initp->cipher.type = cipher_alg;
         initp->cipher.mode = SAESOC_CIPHER_MODE_CTR;	
 	initp->cipher.iv_offset = 0;
@@ -1021,6 +1029,8 @@ static int aead_crypt_gcm(struct aead_request *req, unsigned int op)
 	struct crypto_alg *alg = tfm->base.__crt_alg;
 	struct aead_alg *aead= &alg->cra_aead;
 	struct saesoc_session_desc *s_desc ;
+	int rem;
+
 	authsize = crypto_aead_authsize(tfm);
 	maxauthsize= aead->maxauthsize;
 	async->ddesc = NULL; 
@@ -1066,7 +1076,29 @@ static int aead_crypt_gcm(struct aead_request *req, unsigned int op)
 	saesoc_set_aad_len(d_desc,req->assoclen);
 	
 	fill_aead_aad(d_desc, req, req->assoclen,0,max_frags);
+
+	//frag for aad padding
+        if (cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2) {
+		int rem;
+		rem = req->assoclen % 16;
+		
+		if (rem) {
+			rem = 16 - rem;
+			saesoc_add_frags(d_desc,iv + 16,rem,iv + 16,rem);
+		}
+	}
+
 	d_desc = fill_src_dst_sg(s_desc,d_desc,async,req->src,req->dst,&max_frags,cipher_len);
+	//Frag for 
+	//1. cipher padding to block size
+	//2. (aadlen + payloadlen = 16 bytes)
+	//3. hash output = 16 bytes.
+        if (cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2) {
+		rem = cipher_len % 16;
+		if (rem)
+			rem = 16 - rem;
+		saesoc_add_frags(d_desc,iv + 48,32 + rem,iv + 48,32 + rem);
+	}
 	saesoc_set_payload_len(d_desc,cipher_len);
 	saesoc_set_tag_dstaddr(d_desc,hash_addr);
 
@@ -1075,6 +1107,12 @@ static int aead_crypt_gcm(struct aead_request *req, unsigned int op)
 	async->args = (void *)&req->base; 
 	async->op  = op;
 	async->hash_addr = hash_addr;
+        if (cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2) {
+		if (op)
+			async->hash_addr = iv + 48 + rem;
+		else
+			async->hash_addr = iv + 48;
+	}
 	async->authsize = authsize;
 	async->stat = ctx->stat; 
 	async->bytes = req->cryptlen; 
@@ -1124,7 +1162,6 @@ static int aead_crypt_ccm(struct aead_request *req, unsigned int op)
 	int node;
 	struct saesoc_extra_req_send_params mparam;
 	struct saesoc_session_desc *s_desc ;
-	uint8_t *last_dst;
 
 	hash_addr = (uint8_t *)NLM_HASH_OFFSET(aead_request_ctx(req));
 
@@ -1216,27 +1253,22 @@ static int aead_crypt_ccm(struct aead_request *req, unsigned int op)
 	cipher_extralen = cipher_len % 16;
 
 	d_desc= fill_src_dst_sg(s_desc,d_desc,async,req->src,req->dst,&max_frags,cipher_len);
-	last_dst = req->dst + cipher_len;
 
 	if ( cipher_extralen ) {
 		cipher_extralen = AES_BLOCK_SIZE - cipher_extralen;
 		memset(auth_iv + 38,0,cipher_extralen);
+		if (op)
 		saesoc_add_frags(d_desc,(auth_iv+38),cipher_extralen,(auth_iv+38),cipher_extralen);
-		last_dst = auth_iv + 38 + cipher_extralen;
 	}
 
-	if (lparam.saesoc_feature_set & SAESOC_FF_EXPLICIT_IV_SUPPORT) {
-		saesoc_add_frags(d_desc,last_dst,16,last_dst,16);
-		if (!op)
-			scatterwalk_map_and_copy(hash_addr, req->src, req->cryptlen-authsize, authsize, 0);
-	}
+        if (cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2)
+		saesoc_add_frags(d_desc,hash_addr,16,hash_addr,16);
 
 	/* add all those extra bytes for auth excluding assoc */
 	
 	saesoc_set_aad_len(d_desc,req->assoclen + cipher_extralen +  2 + 6 );
-	if (lparam.saesoc_feature_set & SAESOC_FF_EXPLICIT_IV_SUPPORT) {
+        if (cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2)
 		saesoc_set_aad_len(d_desc,req->assoclen);
-	}
 
 	saesoc_set_payload_len(d_desc,cipher_len);
 	saesoc_set_tag_dstaddr(d_desc,hash_addr);
-- 
1.9.1

