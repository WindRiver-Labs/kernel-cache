From 61268f43bc0741d06f0b9af76619f30b998edb4b Mon Sep 17 00:00:00 2001
From: Pavani Reddy <pavani@broadcom.com>
Date: Tue, 16 Dec 2014 19:02:00 +0530
Subject: [PATCH 1473/1532] Nae : Fix for multinode ip forwarding

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/xlpge.h     |  3 +++
 drivers/net/ethernet/broadcom/nae/xlpge_rx.c  | 24 +++++++++++++++--
 drivers/net/ethernet/broadcom/nae/xlpge_tso.h | 38 ++++++++++++++++++++++++---
 3 files changed, 60 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/xlpge.h b/drivers/net/ethernet/broadcom/nae/xlpge.h
index da97546..a201d7d 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge.h
+++ b/drivers/net/ethernet/broadcom/nae/xlpge.h
@@ -60,6 +60,9 @@
 #define	MSEC_EXTRA_MEM			(8)
 #define	P2P_SKB_OFF			(MAX_SKB_FRAGS + P2P_EXTRA_DESCS + \
 						MSEC_EXTRA_MEM - 1)
+#define	P2P_LCPU_OFF			(MAX_SKB_FRAGS + P2P_EXTRA_DESCS + \
+						MSEC_EXTRA_MEM - 2)
+#define NAE_P2P_MEM_FREE		0xAD
 #define	RX_IP_CSUM_VALID		(1 << 3)
 #define	RX_TCP_CSUM_VALID		(1 << 2)
 #define CPU_INDEX(cpu)			((cpu) * 8)
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_rx.c b/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
index 31bbd74..6baca68 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
@@ -988,7 +988,10 @@ inline void xlp_poll_upper(int cpu)
 			if(status) break;
 			__sync();
 
-			process_tx_complete(cpu, src_id, msg0);
+			if(code == NAE_P2P_MEM_FREE)
+				rem_free_p2p_desc_mem((void *)(unsigned long)msg0);
+			else
+				process_tx_complete(cpu, src_id, msg0);
 	}
 }
 
@@ -1056,6 +1059,8 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 
 	if (vc == nae_rx_vc && size >= 2)
 		 process_rx_packets(NULL, cpu, src_id, msg0, msg1, msg2);
+	else if (vc == nae_fb_vc && size == 1 && code == NAE_P2P_MEM_FREE)
+		rem_free_p2p_desc_mem((void *)(unsigned long)msg0);
 	else if (vc == nae_fb_vc && size == 1)
 		process_tx_complete(cpu, src_id, msg0);
 	else {
@@ -1156,6 +1161,7 @@ extern int nlm_xlp_register_napi_final_handler(int major,
 
 int nlm_xlp_enable_napi(void)
 {
+	int base_station, end;
 	if (exclusive_vc) {
 		nae_print(NAE_DBG_TRACE, "Registering exclusive napi vc handler....\n");
 		nlm_xlp_register_napi_vc_handler(nae_rx_vc, xlp_nae_napi_poll);
@@ -1163,7 +1169,20 @@ int nlm_xlp_enable_napi(void)
 
 		return 0;
 	}
-
+	if(is_nlm_xlp9xx())
+		end = XLP_MSG_HANDLE_CPU19;
+	else 
+		end = XLP_MSG_HANDLE_CPU7;
+	/* register for p2p freeback handler */
+	printk("Registering P2P freeback vc handler....\n");
+	for(base_station=XLP_MSG_HANDLE_CPU0; base_station<=end; base_station++){
+		if (register_xlp_msgring_handler(base_station, nlm_xlp_nae_msgring_handler, NULL)) {
+			nae_print(NAE_DBG_ERROR, "Fatal error! Can't register msgring handler "
+		       	"for b_stan = %d\n", base_station);
+			return -1;
+		}
+	}
+			
 	nae_print(NAE_DBG_TRACE, "Registering  poe0->cpu msgring handler\n");
 	if (register_xlp_msgring_handler(XLP_MSG_HANDLE_POE_0,
 		nlm_xlp_nae_msgring_handler, NULL)) {
@@ -1194,6 +1213,7 @@ int nlm_xlp_enable_napi(void)
 		       	"for XLP_MSG_HANDLE_NAE_0\n");
 			return -1;
 		}
+
 	}
 
 #ifdef CONFIG_INET_LRO
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_tso.h b/drivers/net/ethernet/broadcom/nae/xlpge_tso.h
index 0f53755..04c711f 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_tso.h
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_tso.h
@@ -93,24 +93,56 @@ static __inline__ uint64_t nae_tso_desc1(
 static inline void *alloc_p2p_desc_mem(int cpu)
 {
 	void *buf;
+
 	buf = p2p_desc_mem[cpu].mem;
 	if (buf)
 		p2p_desc_mem[cpu].mem = (void *)*(ulong *)(buf);
 	else {
 		buf = cacheline_aligned_kmalloc(p2p_desc_mem[cpu].dsize,
-			GFP_KERNEL);
+			GFP_ATOMIC);
 		p2p_dynamic_alloc_cnt[CPU_INDEX(cpu)]++;
 	}
+	if(buf) {
+		uint64_t *p2pmsg = (uint64_t *)(unsigned long)buf;
+		p2pmsg[P2P_LCPU_OFF] = (uint64_t)(ulong)cpu ;
+	}
 	return buf;
 }
 
+static inline void rem_free_p2p_desc_mem(void *buf);
+
 static inline void free_p2p_desc_mem(int cpu, void *buf)
 {
-	*(ulong *)buf = (ulong)p2p_desc_mem[cpu].mem;
-	p2p_desc_mem[cpu].mem = buf;
+	uint64_t *ptr = (uint64_t *)buf;
+	int hcpu; 
+	int node, stn;
+	uint64_t msg;
+	hcpu = ptr[P2P_LCPU_OFF] ;
+
+	/* If the buffer was allocated on this cpu, free it now.
+	  Else, call the free the free function on that CPU
+	 */ 
+
+	if(hcpu == hard_smp_processor_id()) {
+		*(ulong *)buf = (ulong)p2p_desc_mem[cpu].mem;
+		p2p_desc_mem[cpu].mem = buf;
+	} else {
+		node = nlm_cpuid_to_node(hcpu);
+		/* TBD: Change this 1024 to macro */
+		stn = (node * 1024) + ((hcpu % nlm_threads_per_node()) * 4) + nae_fb_vc;
+		msg = (uint64_t)(unsigned long)buf;
+		while(xlp_message_send_1(stn, NAE_P2P_MEM_FREE, msg));
+	}
 
 }
 
+/* Called via smp_call_function() */
+static inline void rem_free_p2p_desc_mem(void *buf)
+{
+	int pcpu = hard_smp_processor_id();
+	free_p2p_desc_mem(pcpu, buf);
+}
+
 static inline int create_p2p_desc(uint64_t paddr, uint64_t len,
 				  uint64_t *p2pmsg, int idx)
 {
-- 
1.9.1

