From fdc02feeaf656b8a160e3e57d55223de6b9b8cc2 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Tue, 17 Aug 2010 23:33:05 -0700
Subject: [PATCH 1281/1532] NAE: clean up xlp_nae.c xlp_hw.c network driver
 files

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/ucore_loader.h |  4 --
 drivers/net/ethernet/broadcom/nae/xlp_hw.c       |  2 +-
 drivers/net/ethernet/broadcom/nae/xlp_nae.c      | 81 +++++++-----------------
 drivers/net/ethernet/broadcom/nae/xlp_nae.h      |  9 +++
 4 files changed, 32 insertions(+), 64 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/ucore_loader.h b/drivers/net/ethernet/broadcom/nae/ucore_loader.h
index f0a3dab..e9d9bc4 100644
--- a/drivers/net/ethernet/broadcom/nae/ucore_loader.h
+++ b/drivers/net/ethernet/broadcom/nae/ucore_loader.h
@@ -8,10 +8,6 @@ typedef struct {
 	uint32_t array_size;
 } ucore_array_info_t;
 
-
-/* This OS dependent function must be provided by the application. */
-//extern void WRITE_NAE_UCODE(int ucore, uint32_t offset, uint32_t code);
-
 /* This is the only function that should be called by the application. */
 extern int ucore_load_apps(uint32_t mask);
 
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_hw.c b/drivers/net/ethernet/broadcom/nae/xlp_hw.c
index 2f71b07..c5f51fa 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_hw.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_hw.c
@@ -1,6 +1,6 @@
 /*********************************************************************
 
-  Copyright 2003-2010 Netlogic Microsystem, Inc. (NLM). All rights
+  Copyright 2003-2010 Netlogic Microsystem, Inc. ("Netlogic"). All rights
   reserved.
 
   Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index 2e6f8ae..8cf2d84 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -1,6 +1,6 @@
 /********************************************************************
 
-  Copyright 2003-2010 Netlogic Microsystem, Inc. (NLM). All rights
+  Copyright 2003-2010 Netlogic Microsystem, Inc. ("Netlogic"). All rights
   reserved.
 
   Redistribution and use in source and binary forms, with or without
@@ -45,20 +45,16 @@
 #include <linux/mman.h>
 #include <linux/mm.h>
 #include <linux/pci.h>
-
 #include <asm/current.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
-
 #include <asm/netlogic/msgring.h>
 
 #include <asm/netlogic/hal/nlm_hal_fmn.h>
 #include <asm/netlogic/hal/nlm_hal_nae.h>
 #include <asm/netlogic/hal/nlm_hal_pic.h>
 #include "net_common.h"
-#include "fmn_credit.h"
 #include "ucore_loader.h"
-#include "common.h"
 #include "xlp_nae.h"
 
 #define XLP_SOC_MAC_DRIVER "XLP Mac Driver"
@@ -268,7 +264,7 @@ static inline void nlm_xlp_free_skb(struct xlp_msg *msg)
 
 
 	netif_tx_wake_all_queues(skb->dev);
-	//nlm_netif_queue_tx_complete(skb->dev);
+	/* nlm_netif_queue_tx_complete(skb->dev);*/
 
 	dev_kfree_skb_any(skb);
 }
@@ -461,45 +457,30 @@ static void nlm_xlp_nae_init(void)
 
 	spin_lock_init(&nlm_xlp_nae_lock);
 
-	//initial base address for nae, gmac, fmn ...
+	/* initial base address for nae, gmac, fmn ...*/
 
 	spin_lock_irq(&nlm_xlp_nae_lock);
-#if 0
-        spill_addr = ( uint64_t*) kmalloc(129*16*1024, GFP_KERNEL);
-        if(!spill_addr)
-        {
-                printk("kmalloc spill address failed\n");
-        }
-        else
-	{
-		spill_addr = virt_to_phys(spill_addr);
-	//	printk("[%s] spill_addr: 0x%llx \n", __func__,spill_addr);
-                config_outq_spill((uint64_t)spill_addr);
 
-	}
-#endif
-
-	//initial 18 gmac block
-        for(i = 0; i < MAX_NET_INF; i++)
+	/* initial 18 gmac block */
+        for(i = 0; i < 1/*MAX_NET_INF*/; i++)
 	{
 		init_gmac(i);
 	}
 
 
-	//init fmn
 
-	//init tx if credit
+	/* init tx if credit */
 	init_tx_if_credit( 0, 0x7FFFF );
 
 
-	for (i = 0; i < 1/* MAX_NET_INF*/; i++ )
+	for (i = 0; i < 1 /*MAX_NET_INF*/; i++ )
 	{
 		init_ucore(0xffffUL, i);
 	}
 
 	ucore_load_apps(0xffffUL);
 
-	// init egress and igress interface
+	/*  init egress and igress interface */
 	init_ingress();
 	init_egress();
 	spin_unlock_irq(&nlm_xlp_nae_lock);
@@ -515,10 +496,10 @@ static void nlm_xlp_nae_init(void)
 		tp = netdev_priv(dev);
 		tp->dev 	= dev;
 		dev->netdev_ops = &nlm_xlp_nae_ops;
-		//set ethtool_ops which is inside xlp_ethtool.c file
+		/* set ethtool_ops which is inside xlp_ethtool.c file*/
 		xlp_set_ethtool_ops(dev);
 
-		//netif_napi_add(dev, &tp->napi, nlm_xlp_napi_poll, 16);
+		/*netif_napi_add(dev, &tp->napi, nlm_xlp_napi_poll, 16);*/
 
 		dev->dev_addr = eth_hw_addr[i];
 		tp->port	= i;
@@ -553,8 +534,6 @@ static void nlm_xlp_nae_init(void)
 		val = (1 << 31)|(26<<20) |((i*26) << 8) | i*26;
 		nlm_hal_write_nae_reg(FREE_IN_FIFO_CFG, val );
 
-	//	val = nlm_hal_read_nae_reg(FREE_IN_FIFO_CFG );
-	//	printk("After FREE_IN_FIFO_CFG: %d, val: %x\n", i, val);
 	}
 	nlm_xlp_sgmii_setcontext();
 
@@ -649,10 +628,9 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 #ifdef RUN_ON_SIM_ONLY
 	add_timer(&priv->link_timer);
 #endif
-//	napi_enable(&priv->napi);
+/*	napi_enable(&priv->napi);*/
 
 
-//	nlm_xlp_mac_set_enable(priv, 1);
 
 	priv->stats.tx_packets	= 0;
 	priv->stats.tx_errors	= 0;
@@ -745,7 +723,6 @@ retry_send:
         {
                 if(ret & MSG_DST_FC_FAIL)
 		{
-                        //printk("TX message destination flow control credit fail: flow control count: %d\n", ret & (0x3fff8));
 			ret = xlp_read_status1();
 			if( ret & (1 << 31))
 			{
@@ -781,7 +758,7 @@ retry_send:
 
 	if(priv->num_desc <= MIN_FRIN_DESC_THRESHD)
 	{
-//		netif_stop_queue(dev);
+		netif_stop_queue(dev);
 	}
 	return NETDEV_TX_OK;
 }
@@ -914,7 +891,7 @@ static void  nlm_xlp_nae_rx(struct sk_buff* skb, struct net_device *dev)
 	msgrng_access_enable(mflags);
 
 
-	// process packet message at cpu vc 1
+	/* process packet message at cpu vc 1 */
 	if (nlm_hal_recv_msg1(1,
 			  &src_id,
 			  &size,
@@ -939,11 +916,11 @@ static void  nlm_xlp_nae_rx(struct sk_buff* skb, struct net_device *dev)
 		}
 		else if(addr == 0)
 		{
-			//case tx queue is stopped
+			/* case tx queue is stopped */
 			netif_tx_wake_all_queues(dev);
 		}
 	}
-	// process packet message at cpu vc 0
+	/* process packet message at cpu vc 0 */
 	if ((rx_status = nlm_hal_recv_msg2(cpu_qid,
                                 &src_id,
 				&size,
@@ -978,14 +955,13 @@ static void  nlm_xlp_nae_rx(struct sk_buff* skb, struct net_device *dev)
 	addr = (rx_msg.entry[1]) & 0xfffffffff0ULL;
 	len = (rx_msg.entry[1] >> 40) & 0x3fff;
 
-	//update dev and port to be accurate
+	/* update dev and port to be accurate*/
 	dev = dev_mac[port];
 	priv = netdev_priv(dev);
 	if(!len || addr == 0)
 	{
 		if( priv->num_desc < MIN_FRIN_DESC_THRESHD)
 			tasklet_schedule(&mac_refill_task[priv->port]);
-		//goto fill_desc;
 		return;
 	}
 	vaddr = (uint64_t)bus_to_virt(addr);
@@ -993,7 +969,6 @@ static void  nlm_xlp_nae_rx(struct sk_buff* skb, struct net_device *dev)
 
 	if(len  - BYTE_OFFSET -MAC_CRC_LEN - MAC_PREPAD< 0)
 	{
-		//
 		priv->stats.rx_errors++;
 		priv->stats.rx_dropped++;
 		printk("[%s] wrong packet len %d, drop it!",__FUNCTION__,len);
@@ -1014,7 +989,6 @@ static void  nlm_xlp_nae_rx(struct sk_buff* skb, struct net_device *dev)
 	skb = mac_get_skb_back_ptr(vaddr);
         if (skb) {
 			src = *((unsigned long *)(skb->data-20));
-//			skb_reserve(skb, MAC_PREPAD+BYTE_OFFSET );
 			skb_put(skb, len);
 			skb->dev = dev_mac[port];
 			skb->protocol = eth_type_trans(skb, dev_mac[port]);
@@ -1094,7 +1068,6 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 	if( vc == 1)
 	{
 		port = msg0 & 0x0f;
-	//	printk("port: %d got src_id: %d msg %llx \n\n",port, src_id, msg0);
                 addr = msg0 & 0xfffffffff0ULL;
                 len = (msg0 >> 40) & 0x3fff;
 #ifdef RUN_ON_SIM_ONLY
@@ -1121,13 +1094,12 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
                         }
 			if( priv->num_desc < MIN_FRIN_DESC_THRESHD)
 			{
-		//	printk("num_desc:%d refill_task[%d]:%x \n", priv->num_desc, priv->port, mac_refill_task[port]);
 				tasklet_schedule(&mac_refill_task[port]);
 			}
                 }
                 else if(addr == 0)
                 {
-                        //case tx queue is stopped
+                        /* case tx queue is stopped */
                         netif_tx_wake_all_queues(pdev);
                 }
 	}
@@ -1140,7 +1112,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		/*context is XLP_SGMII_RCV_CONTEXT_NUM + three bit vlan type or vlan priority*/
 		port = context / XLP_SGMII_RCV_CONTEXT_NUM;
 
-		//update dev and port to be accurate
+		/* update dev and port to be accurate */
 		if(port < 0 || port >= MAX_GMAC_PORT)
 		{
 			port = 0;
@@ -1161,8 +1133,6 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		vaddr = (uint64_t)bus_to_virt(addr);
 		buf = (unsigned char *)vaddr;
 
-		//RUN_ON_SIM()
-
 #if DUMP_RCV_PKT
 		printk("RX: port:%d src_id: %d context: %d recv buf: 0x%llx len:%d addr:0x%010llx  \n",
 					priv->port,src_id,context,(uint64_t)buf, len, vaddr);
@@ -1179,7 +1149,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		else
 		{
 			len = len  - MAC_CRC_LEN;
-			//printk("len: %d, BYTE_OFFSET: %d, MAC_CRC_LEN: %d, MAC_PREPAD: %d \n", len, BYTE_OFFSET, MAC_CRC_LEN, MAC_PREPAD);
+			/* printk("len: %d, BYTE_OFFSET: %d, MAC_CRC_LEN: %d, MAC_PREPAD: %d \n", len, BYTE_OFFSET, MAC_CRC_LEN, MAC_PREPAD);*/
 			if(len >= 2048)
 			{
 				priv->stats.rx_errors++;
@@ -1297,12 +1267,10 @@ static void nlm_xlp_mac_timer(unsigned long data)
 #ifdef RUN_ON_SIM_ONLY
 	if( priv->num_desc <= MIN_FRIN_DESC_THRESHD)
 	{
-	//	printk("num_desc:%d refill_task[%d]:%x \n", priv->num_desc, priv->port, mac_refill_task[port]);
 		mac_refill_frin_desc(dev);
 	}
 #endif
 
-//	nlm_xlp_nae_rx(priv->skb, dev);
         spin_unlock_irq(&priv->lock);
         priv->link_timer.expires = jiffies + next_tick/10;
         add_timer(&priv->link_timer);
@@ -1335,20 +1303,18 @@ static void  nlm_xlp_napi_poll(struct napi_struct *napi, int* budget)
 	msgrng_access_enable(mflags);
 
 
-	// process packet message at cpu vc 1
+	/* process packet message at cpu vc 1 */
 	if (nlm_hal_recv_msg1(1,
 			  &src_id,
 			  &size,
 			  &code,
 			  &fr_msg.entry[0])){
 		rx_print(fr_msg.entry[0]);
-//		printk("got a fr_msg \n\n");
 		addr = (fr_msg.entry[0]) & 0xffffffffffULL;
 		len = (fr_msg.entry[0] >> 40) & 0x3fff;
 		if(addr && (len==0))
 		{
 			skb = (struct sk_buff *)bus_to_virt(addr);
-//			log_dbg("\nfree addr:0x%010llx \n",(uint64_t)bus_to_virt(addr));
 			if(skb)
 			{
 				priv->stats.rx_packets++;
@@ -1361,11 +1327,11 @@ static void  nlm_xlp_napi_poll(struct napi_struct *napi, int* budget)
 		}
 		else if(addr == 0)
 		{
-			//case tx queue is stopped
+			/* case tx queue is stopped */
 			netif_tx_wake_all_queues(dev);
 		}
 	}
-	// process packet message at cpu vc 0
+	/* process packet message at cpu vc 0 */
 	if (!nlm_hal_recv_msg2(cpu_qid,
                                   &src_id,
 				&size,
@@ -1396,11 +1362,9 @@ static void  nlm_xlp_napi_poll(struct napi_struct *napi, int* budget)
 	}
 	vaddr = (uint64_t)bus_to_virt(addr);
 	buf = (unsigned char *)vaddr;
-	log_dbg("recv buf: 0x%llx len:%d addr:0x%llx  \n",(uint64_t)buf, len, vaddr);
 
 	if(len  - BYTE_OFFSET -MAC_CRC_LEN - MAC_PREPAD< 0)
 	{
-		//
 		priv->stats.rx_errors++;
 		priv->stats.rx_dropped++;
 		printk("[%s] wrong packet len %d, drop it!",__FUNCTION__,len);
@@ -1421,7 +1385,6 @@ static void  nlm_xlp_napi_poll(struct napi_struct *napi, int* budget)
 	skb = mac_get_skb_back_ptr(vaddr);
         if (skb) {
 			src = *((unsigned long *)(skb->data-20));
-//			skb_reserve(skb, MAC_PREPAD+BYTE_OFFSET );
 			skb_put(skb, len);
 			skb->dev = dev;
 			skb->protocol = eth_type_trans(skb, dev);
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.h b/drivers/net/ethernet/broadcom/nae/xlp_nae.h
index f85af9a..8c4528e 100644
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.h
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.h
@@ -10,6 +10,15 @@
 #define BYTE_OFFSET             2
 #define NLM_RX_BUF_SIZE (MAC_MAX_FRAME_SIZE+BYTE_OFFSET+MAC_PREPAD+MAC_SKB_BACK_PTR_SIZE+SMP_CACHE_BYTES)
 #define MAC_CRC_LEN             4
+#define CACHELINE_SIZE          (1ULL << 6)
+#define CACHELINE_ALIGNED(addr) ( ((addr) + (CACHELINE_SIZE-1)) & ~(CACHELINE_SIZE-1) )
+#define PHYS_TO_VIRT(paddr) (uint64_t)((paddr) - (netlib_paddrb) + (netlib_vaddrb))
+#define VIRT_TO_PHYS(vaddr) (uint64_t)((vaddr) - (netlib_vaddrb) + (netlib_paddrb))
+extern  unsigned long long netlib_vaddrb;
+extern unsigned long long netlib_paddrb;
+#define PADDR_BASE 0x100000ULL
+#define PADDR_SIZE 0x200000
+#define INIT_VBASE( vbase, pbase) {netlib_vaddrb = vbase ; netlib_paddrb = pbase;}
 
 struct cpu_stat {
         unsigned long tx_packets;
-- 
1.9.1

