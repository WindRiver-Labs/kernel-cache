From 488601a6256ddcbcec975c7063c0c889b930bf19 Mon Sep 17 00:00:00 2001
From: Alok Agrawat <alok@broadcom.com>
Date: Mon, 10 Jun 2013 19:14:42 -0700
Subject: [PATCH 1160/1532] CDE: Modified cde code and cde test application for
 xlp9xx. Modified on_chip.c to have interrupt handler for xlp9xx.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/nlm_cde/cdetest.c       |   12 +-
 drivers/misc/netlogic/nlm_cde/nlm_cde.c       | 1451 ++++++++++++++-----------
 drivers/misc/netlogic/nlm_cde/nlm_cde.h       |    5 +-
 drivers/misc/netlogic/soc_interface/on_chip.c |   37 +-
 4 files changed, 835 insertions(+), 670 deletions(-)

diff --git a/drivers/misc/netlogic/nlm_cde/cdetest.c b/drivers/misc/netlogic/nlm_cde/cdetest.c
index 27e5b9b..f4fb307 100644
--- a/drivers/misc/netlogic/nlm_cde/cdetest.c
+++ b/drivers/misc/netlogic/nlm_cde/cdetest.c
@@ -106,6 +106,7 @@ int main(int argc, char *argv[])
 	char buf1[LEN];
         char buf2[LEN];
 	unsigned char *cde_mmap_mem = NULL;
+        int size = 0;
 
 	int tfd = open(argv[1], O_RDONLY);
         int vfd = open("out.txt",O_WRONLY);
@@ -132,8 +133,11 @@ int main(int argc, char *argv[])
 	}
 //        test();
   //      return 0;
-#if 1
-       cde_mmap_mem = mmap (0, 2048, PROT_READ | PROT_WRITE, MAP_SHARED, dfd, 0);
+printf("\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n CDE TEST APPLICATION >>>>>>>>>>>>>>>>>\n");
+#if 0
+	size = ((1024 + 65) * 1024 ) *2;
+printf("\n size = %d\n", size);
+       cde_mmap_mem = mmap (0, size, PROT_READ | PROT_WRITE, MAP_SHARED, dfd, 0);
        if(cde_mmap_mem)
                strcpy(cde_mmap_mem, "HelloWorld\n");
 #endif
@@ -194,7 +198,7 @@ int main(int argc, char *argv[])
         
 	do 
         {
-		ret = cde_op(2, buf, data_len);//deflate
+		ret = cde_op(0xf0002, buf, data_len);//deflate
 	        //if (ret < 0) break;
 
 	        usleep(sleep_usec);
@@ -206,7 +210,7 @@ int main(int argc, char *argv[])
 	        usleep(sleep_usec);
 //                printf("read buf = %s ret = %d\n",buf1, ret );
 
-		ret = cde_op(1, buf1, ret); //inflate
+		ret = cde_op(0xf0001, buf1, ret); //inflate
 	        if (ret < 0) break;
 	
 	        usleep(sleep_usec);
diff --git a/drivers/misc/netlogic/nlm_cde/nlm_cde.c b/drivers/misc/netlogic/nlm_cde/nlm_cde.c
index 2319df8..6fbda52 100644
--- a/drivers/misc/netlogic/nlm_cde/nlm_cde.c
+++ b/drivers/misc/netlogic/nlm_cde/nlm_cde.c
@@ -63,10 +63,10 @@
 #define VC_MODE_ROUND_ROBIN 1
 
 struct msgrng_msg {
-  __u64 msg0;
-  __u64 msg1;
-  __u64 msg2;
-  __u64 msg3;
+		__u64 msg0;
+		__u64 msg1;
+		__u64 msg2;
+		__u64 msg3;
 };
 
 static int xlp_cde_major;
@@ -81,15 +81,16 @@ static unsigned int cde_mem_size, cde_mem_size_1, cde_mem_size_2, cde_mem_size_3
 //static void test(void);
 
 int num_cde_engine;
+static cmp_data_t *cmp_data = NULL;
 
 struct nlm_cde_op
 {
-  unsigned int compression_type;
-  unsigned int sof;
-  unsigned int eof;
+		unsigned int compression_type;
+		unsigned int sof;
+		unsigned int eof;
 };
 typedef struct free_page_structure {
-	  char *data_array;
+		char *data_array;
 } fr_page;
 
 volatile msg cmp_msg[MAX_NUM_MESSAGES]    __attribute__((aligned(32)));
@@ -100,575 +101,644 @@ volatile char *(page_array_tmp_data_array[MAX_NUM_PAGES])__attribute__((aligned(
 #ifdef CDE_DEBUG
 static void dump_buffer(unsigned char *buf, unsigned int len, unsigned char *msg)
 {
-    int k = 0;
-    printk("\n %s", msg);
-    for(k = 0; k < len; k++)
-    {
-	printk(" %.2x",buf[k]);
-	if((k+1) % 16 == 0)
-	    printk("\n");
-    }
-    printk("\n");
+	int k = 0;
+	//printk("\n %s", msg);
+	for(k = 0; k < len; k++)
+	{
+		printk(" %.2x",buf[k]);
+		if((k+1) % 16 == 0)
+		printk("\n");
+	}
+	printk("\n");
 }
 #endif
 
 static void *
 get_cache_aligned_mem(size_t size)
 {
-    void *addr, **tmp;
-    uint64_t loc;
-    addr = malloc(size + L3_CACHELINE_SIZE * 2);
+	void *addr, **tmp;
+	uint64_t loc;
+	addr = malloc(size + L3_CACHELINE_SIZE * 2);
 
-    if (addr == NULL) {
-	printk(KERN_ERR
+	if (addr == NULL) {
+		printk(KERN_ERR
 		"\n Malloc failed for cache aligned memory allocation");
-	return NULL;    //NLM_ERR_NO_MEM;
-    }
-    loc = (uint64_t) addr;
-    loc = (loc + L3_CACHELINE_SIZE - 1) & ~L3_CACHELINE_MASK;
+		return NULL;    //NLM_ERR_NO_MEM;
+	}
+	loc = (uint64_t) addr;
+	loc = (loc + L3_CACHELINE_SIZE - 1) & ~L3_CACHELINE_MASK;
 
-    tmp = (void **) loc;
+	tmp = (void **) loc;
 
-    *tmp = addr;
+	*tmp = addr;
 
-    loc += L3_CACHELINE_SIZE;
+	loc += L3_CACHELINE_SIZE;
 
-    addr = (void *) loc;
+	addr = (void *) loc;
 
-    return addr;
+	return addr;
 }
 
 static void
 free_cache_aligned_mem(void *addr)
 {
-    uint64_t loc;
+	uint64_t loc;
 
-    loc = (uint64_t) addr;
+	loc = (uint64_t) addr;
 
-    loc -= 64;
+	loc -= 64;
 
-    addr = (void *) loc;
+	addr = (void *) loc;
 
-    addr = (void *) *(uint64_t*) addr;
+	addr = (void *) *(uint64_t*) addr;
 
-    free(addr);
+	free(addr);
 }
 
 static int
 cde_get_fb_vc(void)
 {
-    int vc, cpu;
+	int vc, cpu;
 
-    vc = RTN_BKT;
-    cpu = hard_smp_processor_id();
-    cpu = cpu * 4 + vc;
-    return cpu;
+	vc = RTN_BKT;
+	cpu = hard_smp_processor_id();
+	cpu = cpu * 4 + vc;
+	return cpu;
 }
 
 static const struct file_operations xlp_cde_fops = {
-    .owner = THIS_MODULE,
-    .open = xlp_cde_open,
-    .read = xlp_cde_read,
-    .write = xlp_cde_write,
-    .compat_ioctl = xlp_cde_ioctl,
-    .mmap = xlp_cde_mmap,
-    .release = xlp_cde_release,
+	.owner = THIS_MODULE,
+	.open = xlp_cde_open,
+	.read = xlp_cde_read,
+	.write = xlp_cde_write,
+	.compat_ioctl = xlp_cde_ioctl,
+	.mmap = xlp_cde_mmap,
+	.release = xlp_cde_release,
 };
 
 
 static int config_cmp(void)
 {
-  int i;
+	int i;
 
 #ifdef CDE_DEBUG
 	printk("config_cmp \n");
 #endif
-  for(i = 0; i < num_cde_engine; i++)
-  {
-    unsigned int val = nlm_hal_read_cde_reg(CMP_REG_CTRL_REG(i));
+	for(i = 0; i < num_cde_engine; i++)
+	{
+		unsigned int val;
+		if(is_nlm_xlp9xx())
+			val = nlm_hal_9xx_read_cde_reg(CMP_REG_CTRL_REG(i));
+		else
+			val = nlm_hal_read_cde_reg(CMP_REG_CTRL_REG(i));
+#ifdef CDE_DEBUG
+		printk("config_cmp i = %d cntrl_reg val = %x\n", i, val);
+#endif
+		if(is_nlm_xlp9xx())
+			val = nlm_hal_9xx_read_cde_reg(CMP_REG_SCRATCH_PAGE(i));
+		else
+			val = nlm_hal_read_cde_reg(CMP_REG_SCRATCH_PAGE(i));
 #ifdef CDE_DEBUG
-	printk("config_cmp i = %d cntrl_reg val = %x\n", i, val);
+		printk("config_cmp i = %d scratch_reg val = %x\n", i, val);
 #endif
-    val = nlm_hal_read_cde_reg(CMP_REG_SCRATCH_PAGE(i));
+		if(is_nlm_xlp9xx()){
+			nlm_hal_9xx_write_cde_reg(CMP_REG_CTRL_REG(i), ((0x0012 << 16) | FD_CMP_PAGE_SIZE)); //16'h{CMP_PAGE_SIZE}
+			nlm_hal_9xx_write_cde_reg(CMP_REG_SCRATCH_PAGE(i), ((SCRATCH_SIZE/64 << 17) | (16 << 9)));
+		}
+		else
+		{
+			nlm_hal_write_cde_reg(CMP_REG_CTRL_REG(i), ((0x0012 << 16) | FD_CMP_PAGE_SIZE)); //16'h{CMP_PAGE_SIZE}
+			nlm_hal_write_cde_reg(CMP_REG_SCRATCH_PAGE(i), ((SCRATCH_SIZE/64 << 17) | (16 << 9)));
+		}
+	}
+	return 0;
+}
+
+static int send_message_1(int stid, struct msgrng_msg *msg)
+{
+	int ret = 0;
+	unsigned long __attribute__ ((unused)) mflags;
+
 #ifdef CDE_DEBUG
-	printk("config_cmp i = %d scratch_reg val = %x\n", i, val);
+	printk("send_message = stid = 0x%x msg0 %llx\n",stid, msg->msg0);
 #endif
-    nlm_hal_write_cde_reg(CMP_REG_CTRL_REG(i), ((0x0012 << 16) | FD_CMP_PAGE_SIZE)); //16'h{CMP_PAGE_SIZE}
-    nlm_hal_write_cde_reg(CMP_REG_SCRATCH_PAGE(i), ((SCRATCH_SIZE/64 << 17) | (16 << 9)));
-  }
-  return 0;
+	msgrng_access_enable(mflags);
+	nlm_hal_cde_send_request_1(stid, msg->msg0);
+	msgrng_access_disable(mflags);
+
+	return ret;
 }
 
-static int send_message(int stid, struct msgrng_msg *msg)
+static int send_message_2(int stid, struct msgrng_msg *msg)
 {
-  int ret = 0;
-  unsigned long __attribute__ ((unused)) mflags;
+	int ret = 0;
+	unsigned long __attribute__ ((unused)) mflags;
 
 #ifdef CDE_DEBUG
-	printk("send_message = stid = %x msg = %llx\n",stid, msg->msg0);
+	printk("send_message = stid = 0x%x msg = %llx msg1 %llx\n",stid, msg->msg0, msg->msg1);
 #endif
-  msgrng_access_enable(mflags);
-  nlm_hal_cde_send_request(stid, msg->msg0, msg->msg1);
-  msgrng_access_disable(mflags);
+	msgrng_access_enable(mflags);
+	nlm_hal_cde_send_request_2(stid, msg->msg0, msg->msg1);
+	msgrng_access_disable(mflags);
 
-  return ret;
+	return ret;
 }
 
 
 static int send_free_desc(void)
 {
-  int i;
-  int status = 0;
-  int stid;
-  struct msgrng_msg fd_msg;
-
-  // send free descriptors to cmp block
-  for (i = 0; i < NUM_FREE_DESCRIPTORS; i++) {
-    if (!page_array[i].data_array)
-	page_array[i].data_array = get_cache_aligned_mem(FD_CMP_PAGE_SIZE);
-    if (!page_array[i].data_array)	{
-	    printk("cacheline_aligned_kmalloc returmed error desc_num = %d\n", i);
-	    return -1;
-    }
-
-    stid = nlm_hal_cde_make_fd_msg((uint64_t*)&fd_msg.msg0, (uint64_t)virt_to_phys(page_array[i].data_array));
+	int i;
+	int status = 0;
+	int stid;
+	struct msgrng_msg fd_msg;
+
+	// send free descriptors to cmp block
+	for (i = 0; i < NUM_FREE_DESCRIPTORS; i++) {
+		if (!page_array[i].data_array)
+			page_array[i].data_array = get_cache_aligned_mem(FD_CMP_PAGE_SIZE);
+		if (!page_array[i].data_array)	{
+			printk("cacheline_aligned_kmalloc returmed error desc_num = %d\n", i);
+			return -1;
+		}
+
+		stid = nlm_hal_cde_make_fd_msg((uint64_t*)&fd_msg.msg0, (uint64_t)virt_to_phys(page_array[i].data_array));
 #ifdef CDE_DEBUG
-    	printk("Free descriptor message [%0d] = 0x%016llx\n", i, fd_msg.msg0);
+		printk("Free descriptor message [%0d] = 0x%016llx\n", i, fd_msg.msg0);
 #endif
 
-    if(is_nlm_xlp2xx())
-    	status = send_message(MSGRNG_2XX_STNID_CMP1, &fd_msg);
-    else
-      	status = send_message(MSGRNG_STNID_CMP1, &fd_msg);
-
-    if (status != 0) {
-      printk("[%s@%d]: Free descriptor (%d) didnt not reach cmpm status=%0d\n",
-	     __FUNCTION__, __LINE__, i, status);
-      return -1;
-    }
-  }
+		if(is_nlm_xlp2xx())
+			status = send_message_1(MSGRNG_2XX_STNID_CMP1, &fd_msg);
+		else if(is_nlm_xlp9xx())	
+			status = send_message_1(MSGRNG_9XX_STNID_CMP1, &fd_msg);
+		else
+			status = send_message_1(MSGRNG_STNID_CMP1, &fd_msg);
+
+		if (status != 0) {
+			printk("[%s@%d]: Free descriptor (%d) didnt not reach cmpm status=%0d\n",
+					__FUNCTION__, __LINE__, i, status);
+			return -1;
+		}
+	}
 
 #ifdef CDE_DEBUG
-    printk("[%s@%d]: Sent %d free desc to comp engine\n",
-	   __FUNCTION__, __LINE__, i);
+	printk("[%s@%d]: Sent %d free desc to comp engine\n",
+			__FUNCTION__, __LINE__, i);
 #endif
 
-  return 0;
+	return 0;
 }
 
 
 int create_inf_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of_file)
 {
-  int num_messages, num_desc, num_blk;
-  int i,j,k,stid;
-
-  int rtn_bkt;
-
-  int cur_blk = 0;
-  int cur_desc = 0;
-
-  int eof  = 0;
-  int sod  = 0;
-  int sob  = 0;
-  int eob  = 0;
-  int save = 0;
-  int restore = 0;
-
-  int desc_idx = 0;
-  int length = 0;
-  int start = 0;
-  int div;
-
- /* Number of block and number of messages are always 1.
-    User is expected to send one block at a time */
-  num_blk = num_desc = num_messages = 1;
-  div = num_blk * num_desc;
-
-  rtn_bkt = cde_get_fb_vc();
-  type = 1;
-  if(cmp_data->src_size > MAX_INPUT_BUFFER_SIZE)
-  {
-	  printk("ERROR:src_size = %d if more than %d. No space to store\n", (int)cmp_data->src_size, (int)MAX_INPUT_BUFFER_SIZE);
-	  return 0;
-  }
-  num_desc = (cmp_data->src_size/CMP_PAGE_SIZE) + ((cmp_data->src_size %CMP_PAGE_SIZE)?1:0);
-  for (i = 0; i < num_messages; i++) {
-    //create scratch page descriptor
-    cur_desc = 0;
-    restore = (start_of_file == 0);//((num_messages > 1) & (cur_blk != 0));
-    length = SCRATCH_SIZE ;
-    cmp_data->src_desc[desc_idx] =
-      cpu_to_be64(nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (uint64_t)virt_to_phys(cmp_data->scratch_inf)));
+	int num_messages, num_desc, num_blk;
+	int i,j,k,stid;
+
+	int rtn_bkt;
+
+	int cur_blk = 0;
+	int cur_desc = 0;
+
+	int eof  = 0;
+	int sod  = 0;
+	int sob  = 0;
+	int eob  = 0;
+	int save = 0;
+	int restore = 0;
+
+	int desc_idx = 0;
+	int length = 0;
+	int start = 0;
+	int div;
+
+	/* Number of block and number of messages are always 1.
+	   User is expected to send one block at a time */
+	num_blk = num_desc = num_messages = 1;
+	div = num_blk * num_desc;
+
+	rtn_bkt = cde_get_fb_vc();
+	type = 1;
+	if(cmp_data->src_size > MAX_INPUT_BUFFER_SIZE)
+	{
+		printk("ERROR:src_size = %d if more than %d. No space to store\n", (int)cmp_data->src_size, (int)MAX_INPUT_BUFFER_SIZE);
+		return 0;
+	}
+	num_desc = (cmp_data->src_size/CMP_PAGE_SIZE) + ((cmp_data->src_size %CMP_PAGE_SIZE)?1:0);
+	for (i = 0; i < num_messages; i++) {
+		//create scratch page descriptor
+		cur_desc = 0;
+		restore = (start_of_file == 0);//((num_messages > 1) & (cur_blk != 0));
+		length = SCRATCH_SIZE ;
+		cmp_data->src_desc[desc_idx] =
+			cpu_to_be64(nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (uint64_t)virt_to_phys(cmp_data->scratch_inf)));
 #ifdef CDE_DEBUG
-      printk("scratch=0x%p, v2p=0x%lx, scratch_desc = 0x%016llx &scratch_desc=0x%p\n",
-	     cmp_data->scratch_inf, virt_to_phys(cmp_data->scratch_inf), cmp_data->src_desc[desc_idx], &(cmp_data->src_desc[0]));
+		printk("scratch=0x%p, v2p=0x%lx, scratch_desc = 0x%016llx &scratch_desc=0x%p\n",
+				cmp_data->scratch_inf, virt_to_phys(cmp_data->scratch_inf), cmp_data->src_desc[desc_idx], &(cmp_data->src_desc[0]));
 #endif
-    cur_desc++;
+		cur_desc++;
 
-    for (j = 0; j < num_blk; j++) {
-      for (k = 0; k < num_desc; k++) {
-	eof = end_of_file;
+		for (j = 0; j < num_blk; j++) {
+			for (k = 0; k < num_desc; k++) {
+				eof = end_of_file;
 
-	sod = 1;//(start == 0);
-	sob = (k == 0);
-	eob = (k == num_desc-1);
-	save = ((eob == 1) & (end_of_file == 0)); //((eof == 0) & (eob == 1));
-	restore = 0; //restore only can be 1 on scratch descriptor
-//save = 0;
-	length = ((cmp_data->src_size - start)> CMP_PAGE_SIZE)?CMP_PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
+				sod = 1;//(start == 0);
+				sob = (k == 0);
+				eob = (k == num_desc-1);
+				save = ((eob == 1) & (end_of_file == 0)); //((eof == 0) & (eob == 1));
+				restore = 0; //restore only can be 1 on scratch descriptor
+				//save = 0;
+				length = ((cmp_data->src_size - start)> CMP_PAGE_SIZE)?CMP_PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
 
-	cmp_data->src_desc[cur_desc] =
-	  cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (uint64_t)virt_to_phys(cmp_data->src + start)));
-//printk("data_desc_1 = %llx\n",cmp_data->src_desc[cur_desc]);
+				cmp_data->src_desc[cur_desc] =
+					cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (uint64_t)virt_to_phys(cmp_data->src + start)));
+				//printk("data_desc_1 = %llx\n",cmp_data->src_desc[cur_desc]);
 
 #ifdef CDE_DEBUG
-	  printk("[%s@%d]: eof=%d, sod=%d, sob=%d, eob=%d, save=%d, restore=0, length=%d\n",
-		 __FUNCTION__, __LINE__, eof, sod, sob, eob, save, length);
+				printk("[%s@%d]: eof=%d, sod=%d, sob=%d, eob=%d, save=%d, restore=0, length=%d\n",
+						__FUNCTION__, __LINE__, eof, sod, sob, eob, save, length);
 
-	  printk("[%s@%d]: cur_desc=%d, i=%d, j=%d, k=%d, &(cmp_data->src)=0x%p, src_desc[1]=0x%llx &(src_desc[1])=0x%p\n",
-		 __FUNCTION__, __LINE__,
-		 cur_desc, i, j, k, cmp_data->src, cmp_data->src_desc[cur_desc], &(cmp_data->src_desc[cur_desc]));
+				printk("[%s@%d]: cur_desc=%d, i=%d, j=%d, k=%d, &(cmp_data->src)=0x%p, src_desc[1]=0x%llx &(src_desc[1])=0x%p\n",
+						__FUNCTION__, __LINE__,
+						cur_desc, i, j, k, cmp_data->src, cmp_data->src_desc[cur_desc], &(cmp_data->src_desc[cur_desc]));
 #endif
 
-	start = start + length;
-	cur_desc++;
-      }
+				start = start + length;
+				cur_desc++;
+			}
 
-      cur_blk++;
-    }
+			cur_blk++;
+		}
 
-    if (cpu_is_xlp9xx())
-    stid = nlm_hal_9xxcde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0, (uint64_t*)&cmp_msg[i].msg1, 0, cmp_data->op, rtn_bkt,
-			cur_desc, (uint64_t)virt_to_phys(cmp_data->src_desc + desc_idx));
-    else
-    stid = nlm_hal_cde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0, 0, cmp_data->op, rtn_bkt,
-			cur_desc, (uint64_t)virt_to_phys(cmp_data->src_desc + desc_idx));
+		//if (cpu_is_xlp9xx())
+		if (is_nlm_xlp9xx())
+		{	
+			stid = nlm_hal_9xxcde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0, (uint64_t*)&cmp_msg[i].msg1, 0, cmp_data->op, rtn_bkt,
+					cur_desc, (uint64_t)virt_to_phys(cmp_data->src_desc + desc_idx));
+#ifdef CDE_DEBUG
+			printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx  cmp_msg.msg1 = 0x%016llx\n", __FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0, cmp_msg[i].msg1);
+#endif
+		}
+		else
+		{
+			stid = nlm_hal_cde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0, 0, cmp_data->op, rtn_bkt,
+					cur_desc, (uint64_t)virt_to_phys(cmp_data->src_desc + desc_idx));
 #ifdef CDE_DEBUG
-      printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx\n", __FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0);
+			printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx\n", __FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0);
 #endif
+		}
+		desc_idx = desc_idx + cur_desc;
+	}
 
-    desc_idx = desc_idx + cur_desc;
-  }
 
-  // returns the number of messages created
-  return (num_messages);
+	//    if (is_nlm_xlp9xx())
+	//	num_messages = 2;
+	// returns the number of messages created
+	return (num_messages);
 }
 
 int create_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of_file)
 {
-  int num_messages, num_desc, num_blk;
-  int i,j,k,stid;
-
-  int rtn_bkt;
-
-  int cur_blk = 0;
-  int cur_desc = 0;
-
-  int eof  = 0;
-  int sod  = 0;
-  int sob  = 0;
-  int eob  = 0;
-  int save = 0;
-  int restore = 0;
-
-  int desc_idx = 0;
-  int length = 0;
-  int start = 0;
-  int div;
-
-  num_blk = num_desc = num_messages = 1;
-  div = num_blk * num_desc;
-
-  rtn_bkt = cde_get_fb_vc();
-
-  if(cmp_data->src_size > MAX_INPUT_BUFFER_SIZE)
-  {
-	  printk("ERROR:src_size if more than %d. No space to store\n", MAX_INPUT_BUFFER_SIZE);
-	  return 0;
-  }
-  num_desc = (cmp_data->src_size/CMP_PAGE_SIZE) + ((cmp_data->src_size %CMP_PAGE_SIZE)?1:0);
-  for (i = 0; i < num_messages; i++) {
-    //create scratch page descriptor
-    cur_desc = 0;
-    restore = (start_of_file == 0);//((num_messages > 1) & (cur_blk != 0));
-    length = SCRATCH_SIZE ;
-
-    cmp_data->src_desc[desc_idx] =
-      cpu_to_be64(nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (uint64_t)virt_to_phys(cmp_data->scratch)));
+	int num_messages, num_desc, num_blk;
+	int i,j,k,stid;
+
+	int rtn_bkt;
+
+	int cur_blk = 0;
+	int cur_desc = 0;
+
+	int eof  = 0;
+	int sod  = 0;
+	int sob  = 0;
+	int eob  = 0;
+	int save = 0;
+	int restore = 0;
+
+	int desc_idx = 0;
+	int length = 0;
+	int start = 0;
+	int div;
+
+	num_blk = num_desc = num_messages = 1;
+	div = num_blk * num_desc;
+
+	rtn_bkt = cde_get_fb_vc();
+
+	if(cmp_data->src_size > MAX_INPUT_BUFFER_SIZE)
+	{
+		printk("ERROR:src_size if more than %d. No space to store\n", MAX_INPUT_BUFFER_SIZE);
+		return 0;
+	}
+	num_desc = (cmp_data->src_size/CMP_PAGE_SIZE) + ((cmp_data->src_size %CMP_PAGE_SIZE)?1:0);
+	for (i = 0; i < num_messages; i++) {
+		//create scratch page descriptor
+		cur_desc = 0;
+		restore = (start_of_file == 0);//((num_messages > 1) & (cur_blk != 0));
+		length = SCRATCH_SIZE ;
+
+		cmp_data->src_desc[desc_idx] =
+			cpu_to_be64(nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (uint64_t)virt_to_phys(cmp_data->scratch)));
 
 #ifdef CDE_DEBUG
-      printk("scratch=0x%p, v2p=0x%lx, scratch_desc = 0x%016llx &scratch_desc=0x%p\n",
-	     cmp_data->scratch, virt_to_phys(cmp_data->scratch), cmp_data->src_desc[desc_idx], &(cmp_data->src_desc[0]));
+		printk("scratch=0x%p, v2p=0x%lx, scratch_desc = 0x%016llx &scratch_desc=0x%p\n",
+				cmp_data->scratch, virt_to_phys(cmp_data->scratch), cmp_data->src_desc[desc_idx], &(cmp_data->src_desc[0]));
 #endif
 
-    cur_desc++;
+		cur_desc++;
 
-    for (j = 0; j < num_blk/num_messages; j++) {
-      for (k = 0; k < num_desc; k++) {
-	eof = end_of_file;
+		for (j = 0; j < num_blk/num_messages; j++) {
+			for (k = 0; k < num_desc; k++) {
+				eof = end_of_file;
 
-	sod = 1;//(start == 0);
-	sob = (k == 0);
-	eob = (k == num_desc-1);
-	save = ((type == CDE_STATIC) & (eof == 0) & (eob == 1));
-	restore = 0; //restore only can be 1 on scratch descriptor
+				sod = 1;//(start == 0);
+				sob = (k == 0);
+				eob = (k == num_desc-1);
+				save = ((type == CDE_STATIC) & (eof == 0) & (eob == 1));
+				restore = 0; //restore only can be 1 on scratch descriptor
 
-	length = ((cmp_data->src_size - start)> CMP_PAGE_SIZE)?CMP_PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
-	cmp_data->src_desc[cur_desc] =
-	  cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (uint64_t)virt_to_phys(cmp_data->src + start)));
+				length = ((cmp_data->src_size - start)> CMP_PAGE_SIZE)?CMP_PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
+				cmp_data->src_desc[cur_desc] =
+					cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (uint64_t)virt_to_phys(cmp_data->src + start)));
 
-	if (type == CDE_DYNAMIC) {//for dynamic duplicate desc and set type to 3
-		save = ( (eob == 1) & (eof == 0)) ;
-		cmp_data->src_desc[cur_desc+num_desc] = cpu_to_be64(nlm_hal_cde_make_data_desc ( eof, 3, 1/*sod*/, sob, save, 0, eob, length, (uint64_t)virt_to_phys(cmp_data->src + start)));
+				if (type == CDE_DYNAMIC) {//for dynamic duplicate desc and set type to 3
+					save = ( (eob == 1) & (eof == 0)) ;
+					cmp_data->src_desc[cur_desc+num_desc] = cpu_to_be64(nlm_hal_cde_make_data_desc ( eof, 3, 1/*sod*/, sob, save, 0, eob, length, (uint64_t)virt_to_phys(cmp_data->src + start)));
 #ifdef CDE_DEBUG
-	  printf("cur_desc = %0d, i = %0d, j = %0d, k = %0d, src_desc[%0d] = 0x%016llx \n",
-		cur_desc, i, j, k, cur_desc+num_desc, (long long unsigned int)cmp_data->src_desc[cur_desc+num_desc]);
+					printf("cur_desc = %0d, i = %0d, j = %0d, k = %0d, src_desc[%0d] = 0x%016llx \n",
+							cur_desc, i, j, k, cur_desc+num_desc, (long long unsigned int)cmp_data->src_desc[cur_desc+num_desc]);
 #endif
-	}
+				}
 
 #ifdef CDE_DEBUG
-	  printk("[%s@%d]: eof=%d, sod=%d, sob=%d, eob=%d, save=%d, restore=0, length=%d\n",
-		 __FUNCTION__, __LINE__, eof, sod, sob, eob, save, length);
+				printk("[%s@%d]: eof=%d, sod=%d, sob=%d, eob=%d, save=%d, restore=0, length=%d\n",
+						__FUNCTION__, __LINE__, eof, sod, sob, eob, save, length);
 
-	  printk("[%s@%d]: cur_desc=%d, i=%d, j=%d, k=%d, &(cmp_data->src)=0x%p, src_desc[1]=0x%llx &(src_desc[1])=0x%p\n",
-		 __FUNCTION__, __LINE__,
-		 cur_desc, i, j, k, cmp_data->src, cmp_data->src_desc[cur_desc], &(cmp_data->src_desc[cur_desc]));
+				printk("[%s@%d]: cur_desc=%d, i=%d, j=%d, k=%d, &(cmp_data->src)=0x%p, src_desc[1]=0x%llx &(src_desc[1])=0x%p\n",
+						__FUNCTION__, __LINE__,
+						cur_desc, i, j, k, cmp_data->src, cmp_data->src_desc[cur_desc], &(cmp_data->src_desc[cur_desc]));
 #endif
-	start = start + length;
-	cur_desc++;
-      }
-
-      if (type == CDE_DYNAMIC) {//dynamic has 2x descriptors
-	cur_desc = cur_desc + num_desc;
-      }
-
-      cur_blk++;
-    }
-
-    if (cpu_is_xlp9xx())
-    stid = nlm_hal_9xxcde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0,(uint64_t*)&cmp_msg[i].msg1, 0, cmp_data->op, rtn_bkt,
-			cur_desc, (uint64_t)virt_to_phys(cmp_data->src_desc + desc_idx));
-    else
-    stid = nlm_hal_cde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0, 0, cmp_data->op, rtn_bkt,
-			cur_desc, (uint64_t)virt_to_phys(cmp_data->src_desc + desc_idx));
+				start = start + length;
+				cur_desc++;
+			}
+
+			if (type == CDE_DYNAMIC) {//dynamic has 2x descriptors
+				cur_desc = cur_desc + num_desc;
+			}
+
+			cur_blk++;
+		}
+
+		//if (cpu_is_xlp9xx())
+		if (is_nlm_xlp9xx())
+		{
+			stid = nlm_hal_9xxcde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0,(uint64_t*)&cmp_msg[i].msg1, 0, cmp_data->op, rtn_bkt,
+					cur_desc, (uint64_t)virt_to_phys(cmp_data->src_desc + desc_idx));
 #ifdef CDE_DEBUG
-    printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx\n",
-	 __FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0);
+			printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx cmp_msg.msg1 = 0x%016llx\n",
+					__FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0, cmp_msg[i].msg1);
 #endif
+		}
+		else
+		{
+			stid = nlm_hal_cde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0, 0, cmp_data->op, rtn_bkt,
+					cur_desc, (uint64_t)virt_to_phys(cmp_data->src_desc + desc_idx));
+#ifdef CDE_DEBUG
+			printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx\n",
+					__FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0);
+#endif
+		}
+		desc_idx = desc_idx + cur_desc;
+	}
 
-    desc_idx = desc_idx + cur_desc;
-  }
-
-  // returns the number of messages created
-  return (num_messages);
+	//if (is_nlm_xlp9xx())
+	//	num_messages = 2;
+	// returns the number of messages created
+	return (num_messages);
 }
 
 
 volatile uint64_t used_fd[NUM_FREE_DESCRIPTORS] __attribute__((aligned(32)));
 void return_free_descriptors(msg *msg_list, int msg_index)
 {
-  int i, j, k, status, num_desc;
-  msg return_msg, fd_msg;
-  uint64_t * temp_desc;
-  uint64_t dest_desc;
-  int used_fd_index = 0;
-
-
-  for (i = 0; i < msg_index; i++) {
-
-    memcpy ((void *) &return_msg, (void *)(msg_list+i), sizeof(msg));
-    used_fd[used_fd_index++] = ((uint64_t) return_msg.msg1 & 0xffffffffffUll);
-
-    num_desc = (return_msg.msg1>>40 & 0xffff);
-
-    temp_desc = (uint64_t *) phys_to_virt(return_msg.msg1 & 0xffffffffffUll);
-
-    for (j = 0; j< num_desc; j++) {
-      dest_desc = temp_desc[j];
-      used_fd[used_fd_index++] = ((uint64_t) dest_desc & 0xffffffffffUll);
-    }
-
-
-    if (used_fd_index > FD_BURST_SIZE) {
-      for (k = 0; k < used_fd_index; k++) {
-	fd_msg.msg0 = ((uint64_t) used_fd[k]);
-    	if(is_nlm_xlp2xx())
-    		status = send_message(MSGRNG_2XX_STNID_CMP1, &fd_msg);
-    	else
-		status = send_message(MSGRNG_STNID_CMP1, &fd_msg);
-	if (status != 0)
-	  printk("Return free descriptor didnt not reach cmp! status=%0d\n", status);
+	int i, j, k, status, num_desc;
+	msg return_msg, fd_msg;
+	uint64_t * temp_desc;
+	uint64_t dest_desc;
+	int used_fd_index = 0;
+
+
+	for (i = 0; i < msg_index; i++) {
+
+		memcpy ((void *) &return_msg, (void *)(msg_list+i), sizeof(msg));
+
+		if(is_nlm_xlp9xx())
+		{
+			used_fd[used_fd_index++] = ((uint64_t) return_msg.msg0 & 0xffffffffffUll);
+			num_desc = (return_msg.msg0>>40 & 0xffff);
+		}
+		else
+		{
+			used_fd[used_fd_index++] = ((uint64_t) return_msg.msg1 & 0xffffffffffUll);
+			num_desc = (return_msg.msg1>>40 & 0xffff);
+		}
+
+		if(is_nlm_xlp9xx())
+			temp_desc = (uint64_t *) phys_to_virt(return_msg.msg0 & 0xffffffffffUll);
+		else
+			temp_desc = (uint64_t *) phys_to_virt(return_msg.msg1 & 0xffffffffffUll);
+
+		for (j = 0; j< num_desc; j++) {
+			dest_desc = temp_desc[j];
+			used_fd[used_fd_index++] = ((uint64_t) dest_desc & 0xffffffffffUll);
+		}
+
+
+		if (used_fd_index > FD_BURST_SIZE) {
+			for (k = 0; k < used_fd_index; k++) {
+				fd_msg.msg0 = ((uint64_t) used_fd[k]);
+				if(is_nlm_xlp2xx())
+					status = send_message_1(MSGRNG_2XX_STNID_CMP1, &fd_msg);
+				else if(is_nlm_xlp9xx())
+					status = send_message_1(MSGRNG_9XX_STNID_CMP1, &fd_msg);
+				else
+					status = send_message_1(MSGRNG_STNID_CMP1, &fd_msg);
+				if (status != 0)
+					printk("Return free descriptor didnt not reach cmp! status=%0d\n", status);
+			}
+			used_fd_index = 0;
+		}
 	}
-        used_fd_index = 0;
-    }
-  }
 }
 
-static cmp_data_t *cmp_data = 0;
 
 static int nlm_hal_cde_read_cmp_msg(char *buffer, uint64_t payload)
 {
-  uint64_t i,j,num_bytes;
-  int offset = 0;
-  uint64_t *desc, dest_addr;
-  int num_desc = (payload >> 40) & 0x1fff;
-  char * tmp_ptr;
-  for (i = 0; i < num_desc; i++) {
-    desc = phys_to_virt(payload & 0xffffffffffUll) + i*8; //64 byte descriptors //dliao: why i*8??
-
-    *desc = cpu_to_be64(*desc);
-    num_bytes = (*desc >> 40) & 0xffff;
-    dest_addr = *desc & 0xffffffffffUll;
-    tmp_ptr = (char *) phys_to_virt(dest_addr & 0xffffffffffUll);
-
-    for (j = 0; j < num_bytes; j++) {
-      buffer[offset+j] = tmp_ptr[j]; //AGN: make it Memcpy, and need to check perf difference
-    }
-    offset = offset + num_bytes;
-  }
-  return offset;
+	uint64_t i,j,num_bytes;
+	int offset = 0;
+	uint64_t *desc, dest_addr;
+	int num_desc = (payload >> 40) & 0x1fff;
+	char * tmp_ptr;
+	for (i = 0; i < num_desc; i++) {
+		desc = phys_to_virt(payload & 0xffffffffffUll) + i*8; //64 byte descriptors //dliao: why i*8??
+		*desc = cpu_to_be64(*desc);
+		num_bytes = (*desc >> 40) & 0xffff;
+		dest_addr = *desc & 0xffffffffffUll;
+		tmp_ptr = (char *) phys_to_virt(dest_addr & 0xffffffffffUll);
+
+#if CDE_DEBUG
+		printk(" desc addr = %llx\n",desc);
+		printk("\n num_bytes = %d\n",num_bytes);
+		printk("\n num_desc = %d\n",num_desc);
+		printk("\n tmp_ptr = %llx\n",tmp_ptr);
+		dump_buffer(tmp_ptr, num_bytes, "output:");
+#endif
+		for (j = 0; j < num_bytes; j++) {
+			buffer[offset+j] = tmp_ptr[j]; //AGN: make it Memcpy, and need to check perf difference
+		}
+		offset = offset + num_bytes;
+	}
+	return offset;
 }
 
 /* Due compiler warning it is declraed globally */
 struct msgrng_msg msg_list_g[MAX_NUM_MESSAGES];
-static void
+		static void
 nlm_xlp_cde_msgring_handler(uint32_t vc, uint32_t src_id,
-        uint32_t size, uint32_t code,
-        uint64_t msg0, uint64_t msg1,
-        uint64_t msg2, uint64_t msg3, void *data)
+				uint32_t size, uint32_t code,
+				uint64_t msg0, uint64_t msg1,
+				uint64_t msg2, uint64_t msg3, void *data)
 {
-  struct msgrng_msg *msg, temp_msg;
-  int last = 0;
-  int msg_index = 0;
-  int offset = cmp_data->target_size;
+	struct msgrng_msg *msg, temp_msg;
+	int last = 0;
+	int msg_index = 0;
+	int offset = cmp_data->target_size;
 
 #ifdef CDE_DEBUG
-  printk("nlm_xlp_cde_msgring_handler = vc = %d, src_id = %d size = %d code = %d msg0 = %llx, msg1 = %llx msg2 = %llx\n", vc, src_id, size, code, msg0, msg1, msg2);
+	printk("nlm_xlp_cde_msgring_handler = vc = %d, src_id = %d size = %d code = %d msg0 = %llx, msg1 = %llx msg2 = %llx\n", vc, src_id, size, code, msg0, msg1, msg2);
 #endif
 
-  msg = (struct msgrng_msg *)&temp_msg;
-  msg->msg0 = msg0;
-  msg->msg1 = msg1;
+	msg = (struct msgrng_msg *)&temp_msg;
+	msg->msg0 = msg0;
+	msg->msg1 = msg1;
 
-  last = ((msg->msg0 >> 63) & 0x1ULL);
+	last = ((msg->msg0 >> 63) & 0x1ULL);
 
 #ifdef CDE_DEBUG
-  printk("[%s@%d]: last = %d offset = %d target_size = %d\n", __FUNCTION__, __LINE__, last, offset, cmp_data->target_size);
+	printk("[%s@%d]: last = %d offset = %d target_size = %d\n", __FUNCTION__, __LINE__, last, offset, cmp_data->target_size);
 #endif
 
-  offset = cmp_data->target_size;
-  if (cpu_is_xlp9xx())
-  cmp_data->target_size += nlm_hal_cde_read_cmp_msg((char *) cmp_data->target + offset, msg->msg0);
-  else
-  cmp_data->target_size += nlm_hal_cde_read_cmp_msg((char *) cmp_data->target + offset, msg->msg1);
+	offset = cmp_data->target_size;
+	if (cpu_is_xlp9xx())
+		cmp_data->target_size += nlm_hal_cde_read_cmp_msg((char *) cmp_data->target + offset, msg->msg0);
+	else
+		cmp_data->target_size += nlm_hal_cde_read_cmp_msg((char *) cmp_data->target + offset, msg->msg1);
 
 #ifdef CDE_DEBUG
-  printk("cmp_data->target_size = %d\n",cmp_data->target_size);
-  dump_buffer((char *) (cmp_data->target + offset), cmp_data->target_size, "returned data:");
+	printk("cmp_data->target_size = %d\n",cmp_data->target_size);
+	dump_buffer((char *) (cmp_data->target + offset), cmp_data->target_size, "returned data:");
 #endif
 
-  memcpy((void *)&msg_list_g[msg_index++],(void *)msg, sizeof(struct msgrng_msg));
+	memcpy((void *)&msg_list_g[msg_index++],(void *)msg, sizeof(struct msgrng_msg));
 
-  return_free_descriptors(msg_list_g, msg_index);
+	return_free_descriptors(msg_list_g, msg_index);
 #ifdef CDE_DEBUG
-  printk("[\n%s@%d]:end of phnx_msgring_comp_int_handler\n", __FUNCTION__, __LINE__);
+	printk("[\n%s@%d]:end of phnx_msgring_comp_int_handler\n", __FUNCTION__, __LINE__);
 #endif
 }
 
 cmp_data_t* nlm_cde_init()
 {
-  cmp_data = (cmp_data_t *) kmalloc(sizeof(cmp_data_t), GFP_KERNEL);
-  if (!cmp_data)
-    return NULL;
-  memset(cmp_data, 0, sizeof(cmp_data_t));
-
-  cmp_data->src = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(MAX_INPUT_BUFFER_SIZE));
-  if (! cmp_data->src)	{
-	  printk("kmalloc returns Error : cmp_data->src\n");
-	  kfree(cmp_data);
-
-	  return NULL;
-  }
-
-  cmp_data->target = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(MAX_BUFFER_SIZE));
-  if (! cmp_data->target)	{
-	  printk("kmalloc returns Error : cmp_data->target\n");
-	  kfree(cmp_data->src);
-	  kfree(cmp_data);
-	  return NULL;
-  }
-  cmp_data->src_desc = kmalloc(CMP_PAGE_SIZE , GFP_KERNEL);
-  if (! cmp_data->src_desc)	{
-	  printk("kmalloc returns Error : cmp_data->src_desc\n");
-	  kfree(cmp_data->src);
-	  kfree(cmp_data->target);
-	  kfree(cmp_data);
-	  return NULL;
-  }
-  cmp_data->scratch = kmalloc( SCRATCH_SIZE , GFP_KERNEL);
-  cmp_data->scratch_inf = kmalloc( SCRATCH_SIZE , GFP_KERNEL);
-  if (! cmp_data->scratch || !cmp_data->scratch_inf)	{
-	  printk("kmalloc returns Error : cmp_data->scratch\n");
-	  kfree(cmp_data->src);
-	  kfree(cmp_data->target);
-	  kfree(cmp_data->src_desc);
-	  kfree(cmp_data);
-	  return NULL;
-  }
-
-  cde_mem_size_1 = cde_mem_size_3 = MAX_INPUT_BUFFER_SIZE;
-  cde_mem_size_2 = cde_mem_size_4 = MAX_BUFFER_SIZE;
-  cde_mem_size_5 = (sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int)) * 2;
-  cde_mem_size = cde_mem_size_5 + cde_mem_size_1 + cde_mem_size_2 + cde_mem_size_3 + cde_mem_size_4;
-
-  if(cde_mem_size_5 < PAGE_SIZE) cde_mem_size_5 = PAGE_SIZE;
-
-  cde_input_mem = cde_mem_start_1 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_1));
-  if(cde_mem_start_1 == NULL)
-  {
-    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_1);
-    return NULL;
-  }
-  cde_output_mem = cde_mem_start_2 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_2));
-  if(cde_mem_start_2 == NULL)
-  {
-    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_2);
-    return NULL;
-  }
-  cde_inf_input_mem = cde_mem_start_3 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_3));
-  if(cde_mem_start_3 == NULL)
-  {
-    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_3);
-    return NULL;
-  }
-  cde_inf_output_mem = cde_mem_start_4 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_4));
-  if(cde_mem_start_4 == NULL)
-  {
-    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_4);
-    return NULL;
-  }
-  cde_mem_start = cde_mem_start_5 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_5));
-  if(cde_mem_start_5 == NULL)
-  {
-    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_5);
-    return NULL;
-  }
-  cde_inf_mem_start = cde_mem_start + sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int);
-
-  memset(cmp_data->src, 0, MAX_INPUT_BUFFER_SIZE);
-  memset(cmp_data->target, 0, MAX_BUFFER_SIZE);
-
-  memset(cmp_data->src_desc, 0, CMP_PAGE_SIZE);
-  memset(cmp_data->scratch, 0, SCRATCH_SIZE);
-  memset(cmp_data->scratch_inf, 0, SCRATCH_SIZE);
-
-  if (config_cmp() == -1)
-	return NULL;
-
-  if (send_free_desc() == -1)
-	return NULL;
-
-  return cmp_data;
+	cmp_data = (cmp_data_t *) kmalloc(sizeof(cmp_data_t), GFP_KERNEL);
+	if (!cmp_data)
+		return NULL;
+	memset(cmp_data, 0, sizeof(cmp_data_t));
+
+	cmp_data->src = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(MAX_INPUT_BUFFER_SIZE));
+	if (! cmp_data->src)	{
+		printk("kmalloc returns Error : cmp_data->src\n");
+		kfree(cmp_data);
+
+		return NULL;
+	}
+
+	cmp_data->target = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(MAX_BUFFER_SIZE));
+	if (! cmp_data->target)	{
+		printk("kmalloc returns Error : cmp_data->target\n");
+		kfree(cmp_data->src);
+		kfree(cmp_data);
+		return NULL;
+	}
+	cmp_data->src_desc = kmalloc(CMP_PAGE_SIZE , GFP_KERNEL);
+	if (! cmp_data->src_desc)	{
+		printk("kmalloc returns Error : cmp_data->src_desc\n");
+		kfree(cmp_data->src);
+		kfree(cmp_data->target);
+		kfree(cmp_data);
+		return NULL;
+	}
+	cmp_data->scratch = kmalloc( SCRATCH_SIZE , GFP_KERNEL);
+	cmp_data->scratch_inf = kmalloc( SCRATCH_SIZE , GFP_KERNEL);
+	if (! cmp_data->scratch || !cmp_data->scratch_inf)	{
+		printk("kmalloc returns Error : cmp_data->scratch\n");
+		kfree(cmp_data->src);
+		kfree(cmp_data->target);
+		kfree(cmp_data->src_desc);
+		kfree(cmp_data);
+		return NULL;
+	}
+
+	cde_mem_size_1 = cde_mem_size_3 = MAX_INPUT_BUFFER_SIZE;
+	cde_mem_size_2 = cde_mem_size_4 = MAX_BUFFER_SIZE;
+	cde_mem_size_5 = (sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int)) * 2;
+	cde_mem_size = cde_mem_size_5 + cde_mem_size_1 + cde_mem_size_2 + cde_mem_size_3 + cde_mem_size_4;
+
+	if(cde_mem_size_5 < PAGE_SIZE) cde_mem_size_5 = PAGE_SIZE;
+
+	cde_input_mem = cde_mem_start_1 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_1));
+	if(cde_mem_start_1 == NULL)
+	{
+		printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_1);
+		return NULL;
+	}
+	cde_output_mem = cde_mem_start_2 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_2));
+	if(cde_mem_start_2 == NULL)
+	{
+		printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_2);
+		return NULL;
+	}
+	cde_inf_input_mem = cde_mem_start_3 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_3));
+	if(cde_mem_start_3 == NULL)
+	{
+		printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_3);
+		return NULL;
+	}
+	cde_inf_output_mem = cde_mem_start_4 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_4));
+	if(cde_mem_start_4 == NULL)
+	{
+		printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_4);
+		return NULL;
+	}
+	cde_mem_start = cde_mem_start_5 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_5));
+	if(cde_mem_start_5 == NULL)
+	{
+		printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_5);
+		return NULL;
+	}
+	cde_inf_mem_start = cde_mem_start + sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int);
+
+	memset(cmp_data->src, 0, MAX_INPUT_BUFFER_SIZE);
+	memset(cmp_data->target, 0, MAX_BUFFER_SIZE);
+
+	memset(cmp_data->src_desc, 0, CMP_PAGE_SIZE);
+	memset(cmp_data->scratch, 0, SCRATCH_SIZE);
+	memset(cmp_data->scratch_inf, 0, SCRATCH_SIZE);
+
+	if (config_cmp() == -1)
+		return NULL;
+
+	if (send_free_desc() == -1)
+		return NULL;
+
+	return cmp_data;
 }
 
 int xlp_cde_open(struct inode *inode, struct file *filp)
@@ -677,45 +747,45 @@ int xlp_cde_open(struct inode *inode, struct file *filp)
 	printk("xlp_cde_open \n");
 #endif
 
-  return 0;
+		return 0;
 }
 
 
 void nlm_cde_cleanup(cmp_data_t *cmp_data)
 {
-  int i;
-  if (cmp_data->src)
-	free_pages ((ulong)cmp_data->src, get_order (MAX_INPUT_BUFFER_SIZE));
-  if (cmp_data->target)
-	free_pages ((ulong)cmp_data->target, get_order (MAX_BUFFER_SIZE));
-  if (cmp_data->src_desc)
-	  kfree(cmp_data->src_desc);
-  if (cmp_data->scratch)
-	  kfree(cmp_data->scratch);
-  if (cmp_data->scratch_inf)
-	  kfree(cmp_data->scratch_inf);
-
-  free_pages((ulong)cde_mem_start_1, get_order(cde_mem_size_1));
-  free_pages((ulong)cde_mem_start_2, get_order(cde_mem_size_2));
-  free_pages((ulong)cde_mem_start_3, get_order(cde_mem_size_3));
-  free_pages((ulong)cde_mem_start_4, get_order(cde_mem_size_4));
-  free_pages((ulong)cde_mem_start_5, get_order(cde_mem_size_5));
-
-  cmp_data->src = NULL;
-  cmp_data->target = NULL;
-  cmp_data->src_desc = NULL;
-  cmp_data->scratch = NULL;
-  cmp_data->scratch_inf = NULL;
-
-  if (cmp_data)
-    kfree(cmp_data);
-
-  for (i = 0; i < NUM_FREE_DESCRIPTORS; i++) {
-    if (page_array[i].data_array)	{
-	free_cache_aligned_mem((void*)page_array[i].data_array);
-	page_array[i].data_array = NULL;
-    }
-  }
+	int i;
+	if (cmp_data->src)
+		free_pages ((ulong)cmp_data->src, get_order (MAX_INPUT_BUFFER_SIZE));
+	if (cmp_data->target)
+		free_pages ((ulong)cmp_data->target, get_order (MAX_BUFFER_SIZE));
+	if (cmp_data->src_desc)
+		kfree(cmp_data->src_desc);
+	if (cmp_data->scratch)
+		kfree(cmp_data->scratch);
+	if (cmp_data->scratch_inf)
+		kfree(cmp_data->scratch_inf);
+
+	free_pages((ulong)cde_mem_start_1, get_order(cde_mem_size_1));
+	free_pages((ulong)cde_mem_start_2, get_order(cde_mem_size_2));
+	free_pages((ulong)cde_mem_start_3, get_order(cde_mem_size_3));
+	free_pages((ulong)cde_mem_start_4, get_order(cde_mem_size_4));
+	free_pages((ulong)cde_mem_start_5, get_order(cde_mem_size_5));
+
+	cmp_data->src = NULL;
+	cmp_data->target = NULL;
+	cmp_data->src_desc = NULL;
+	cmp_data->scratch = NULL;
+	cmp_data->scratch_inf = NULL;
+
+	if (cmp_data)
+		kfree(cmp_data);
+
+	for (i = 0; i < NUM_FREE_DESCRIPTORS; i++) {
+		if (page_array[i].data_array)	{
+			free_cache_aligned_mem((void*)page_array[i].data_array);
+			page_array[i].data_array = NULL;
+		}
+	}
 }
 
 
@@ -732,32 +802,38 @@ static int xlp_cde_mmap(struct file * filp, struct vm_area_struct * vma)
 	if (vma->vm_flags & VM_LOCKED) return -EPERM;
 
 	size = vma->vm_end - vma->vm_start;
+	printk("\n %s size = %d cde_mem_size = %d", __FUNCTION__, size, cde_mem_size);
 	pgprot_val (vma->vm_page_prot) &= ~_CACHE_MASK;
 	pgprot_val (vma->vm_page_prot) |= _CACHE_CACHABLE_COW;
 
-
+	printk("\n %s  %d", __FUNCTION__, __LINE__);
 	cde_pfn_addr = ((uint64_t)cde_mem_start_1 >> PAGE_SHIFT);
 	result = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_1,
-								vma->vm_page_prot);
+			vma->vm_page_prot);
+	printk("\n %s  %d", __FUNCTION__, __LINE__);
 	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_1);
 
 	cde_pfn_addr = ((uint64_t)cde_mem_start_2 >> PAGE_SHIFT);
 	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_2,
-								vma->vm_page_prot);
+			vma->vm_page_prot);
+	printk("\n %s  %d", __FUNCTION__, __LINE__);
 
 	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_2);
 	cde_pfn_addr = ((uint64_t)cde_mem_start_3 >> PAGE_SHIFT);
 	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_3,
-								vma->vm_page_prot);
+			vma->vm_page_prot);
+	printk("\n %s  %d", __FUNCTION__, __LINE__);
 	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_3);
 	cde_pfn_addr = ((uint64_t)cde_mem_start_4 >> PAGE_SHIFT);
 	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_4,
-								vma->vm_page_prot);
+			vma->vm_page_prot);
+	printk("\n %s  %d", __FUNCTION__, __LINE__);
 
 	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_4);
 	cde_pfn_addr = ((uint64_t)cde_mem_start_5 >> PAGE_SHIFT);
 	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_5,
-								vma->vm_page_prot);
+			vma->vm_page_prot);
+	printk("\n %s  %d", __FUNCTION__, __LINE__);
 	vma->vm_start = vm_start;
 	if (result) return -EAGAIN;
 
@@ -766,41 +842,41 @@ static int xlp_cde_mmap(struct file * filp, struct vm_area_struct * vma)
 
 int xlp_cde_release(struct inode *inode, struct file *filp)
 {
-  cmp_data->target_size = 0;
-  cmp_data->offset = 0;
-  memset(cmp_data->scratch, 0,  SCRATCH_SIZE);
-  memset(cmp_data->scratch_inf, 0, SCRATCH_SIZE);
-  return 0;
+	cmp_data->target_size = 0;
+	cmp_data->offset = 0;
+	memset(cmp_data->scratch, 0,  SCRATCH_SIZE);
+	memset(cmp_data->scratch_inf, 0, SCRATCH_SIZE);
+	return 0;
 }
 
 unsigned int nlm_cde_receive_response(cmp_data_t *cmp_data, unsigned char *buf, unsigned int count)
 {
-  int size = 0;
-  if(cmp_data->target_size)
-  {
-	size = (count < cmp_data->target_size) ? count : cmp_data->target_size;
+	int size = 0;
+	if(cmp_data->target_size)
+	{
+		size = (count < cmp_data->target_size) ? count : cmp_data->target_size;
 
-	memcpy(buf, &cmp_data->target[cmp_data->offset], size);
+		memcpy(buf, &cmp_data->target[cmp_data->offset], size);
 #ifdef CDE_DEBUG
-	printk("xlp_cde_read cmp_data->target_size = %d size = %d\n",cmp_data->Target_size, size);
-	dump_buffer(cmp_data->target, size, "Output:");
+		printk("xlp_cde_read cmp_data->target_size = %d size = %d\n",cmp_data->target_size, size);
+		dump_buffer(cmp_data->target, size, "Output:");
 #endif
-	cmp_data->offset += size;
-	cmp_data->target_size = cmp_data->target_size - size;
-	if(cmp_data->target_size == 0)
-		cmp_data->offset = 0;
+		cmp_data->offset += size;
+		cmp_data->target_size = cmp_data->target_size - size;
+		if(cmp_data->target_size == 0)
+			cmp_data->offset = 0;
 
-	return size;
-  }
-  else
-  {
-	cmp_data->offset = 0;
-	return 0;
-  }
+		return size;
+	}
+	else
+	{
+		cmp_data->offset = 0;
+		return 0;
+	}
 }
 
 ssize_t xlp_cde_read(struct file *filp, char __user *buf,
-		 size_t count, loff_t *f_pos)
+				size_t count, loff_t *f_pos)
 {
 	unsigned char temp_buf[count+1];
 	int size;
@@ -808,228 +884,277 @@ ssize_t xlp_cde_read(struct file *filp, char __user *buf,
 	if(count >= size)
 	{
 		if (copy_to_user(buf, temp_buf, size)) {
-                  printk("copy_to_user failed\n");
-                  size = -EFAULT;
-        	}
+			printk("copy_to_user failed\n");
+			size = -EFAULT;
+		}
 	}
 	return size;
 }
 
 unsigned int nlm_cde_send_request(cmp_data_t *cmp_data, unsigned int op,
-			unsigned int type,
-			unsigned int sof,
-			unsigned int eof,
-			unsigned char *src_buf,
-			unsigned int size)
+		unsigned int type,
+		unsigned int sof,
+		unsigned int eof,
+		unsigned char *src_buf,
+		unsigned int size)
 {
-  int i;
-  int num_messages = 0;
+	int i;
+	int num_messages = 0;
 
-  memcpy(cmp_data->src, src_buf, size);
-  cmp_data->src_size = size;
+	memcpy(cmp_data->src, src_buf, size);
+	cmp_data->src_size = size;
 
 #ifdef CDE_DEBUG
 	printk("xlp_cde_write count = %d\n", size);
- 	dump_buffer(cmp_data->src, cmp_data->src_size, "\nInput Buf:");
+	dump_buffer(cmp_data->src, cmp_data->src_size, "\nInput Buf:");
 	printk("write: cmp_data->compression_type = %d cmp_data->sof = %d, cmp_data->eof = %d\n",cmp_data->compression_type, cmp_data->sof, cmp_data->eof);
 #endif
 
-  if(cmp_data->op == 0/*CDE_INFLATE*/)
-    num_messages = create_inf_message(cmp_data, cmp_data->compression_type, cmp_data->sof, cmp_data->eof);
-  else
-    num_messages = create_message(cmp_data, cmp_data->compression_type, cmp_data->sof, cmp_data->eof);
-
-  // send message
-  for (i = 0; i < num_messages; i++) {
-
-    int status;
-    if(is_nlm_xlp2xx())
-	status =  send_message(MSGRNG_2XX_STNID_CMP0, (struct msgrng_msg *) (cmp_msg + i));
-    else
-	status =  send_message(MSGRNG_STNID_CMP0, (struct msgrng_msg *) (cmp_msg + i));
+	if(cmp_data->op == 0/*CDE_INFLATE*/)
+		num_messages = create_inf_message(cmp_data, cmp_data->compression_type, cmp_data->sof, cmp_data->eof);
+	else
+		num_messages = create_message(cmp_data, cmp_data->compression_type, cmp_data->sof, cmp_data->eof);
+
+	// send message
+	for (i = 0; i < num_messages; i++) {
+
+		int status;
+		if(is_nlm_xlp2xx())
+			status =  send_message_1(MSGRNG_2XX_STNID_CMP0, (struct msgrng_msg *) (cmp_msg + i));
+		else
+			if(is_nlm_xlp9xx())
+				status =  send_message_2(MSGRNG_9XX_STNID_CMP0, (struct msgrng_msg *) (cmp_msg + i));
+			else
+				status =  send_message_1(MSGRNG_STNID_CMP0, (struct msgrng_msg *) (cmp_msg + i));
 #ifdef CDE_DEBUG
-    printk("write: status = %x\n", status);
+		printk("write: status = %x\n", status);
 #endif
-    if (status != 0) {
-	    printk("Cmp Message didnt not reach cmp, status=%0d\n", status);
-    }
-  }
+		if (status != 0) {
+			printk("Cmp Message didnt not reach cmp, status=%0d\n", status);
+		}
+	}
 
-  return size;
+	return size;
 }
 
 ssize_t xlp_cde_write(struct file *filp, const char __user *buf,
 		size_t count, loff_t *f_pos)
 {
-  unsigned char temp_buf[count+1];
-  if (copy_from_user(temp_buf, buf, count)) {
-        printk("copy from user failed \n");
-          return -EFAULT;
-  }
+	unsigned char temp_buf[count+1];
+	if (copy_from_user(temp_buf, buf, count)) {
+		printk("copy from user failed \n");
+		return -EFAULT;
+	}
 
-  return nlm_cde_send_request(cmp_data, cmp_data->op, cmp_data->compression_type, cmp_data->sof, cmp_data->eof, (unsigned char*)temp_buf, count);
+	return nlm_cde_send_request(cmp_data, cmp_data->op, cmp_data->compression_type, cmp_data->sof, cmp_data->eof, (unsigned char*)temp_buf, count);
 }
 
 
 static long xlp_cde_ioctl(struct file *filp,
-	      unsigned int cmd, unsigned long arg)
+		unsigned int cmd, unsigned long arg)
 {
-  int err = 0, i = 0;
-  struct nlm_cde_op *cde;
-  unsigned int input_size = 0, output_size = 0, size;
-  unsigned char *input_mem, *output_mem, *mem_start;
+	int err = 0, i = 0, sanity_test = 0;
+	struct nlm_cde_op *cde;
+	unsigned int input_size = 0, output_size = 0, size;
+	unsigned char *input_mem, *output_mem, *mem_start;
+
+#ifdef CDE_DEBUG
+	printk("xlp_cde_ioctl: cmd = %x\n", cmd);
+#endif
+	if(cmd &0xf0000)
+	{
+		cmd = cmd & 0xf;
+		sanity_test = 1;
+	}
+	switch(cmd) {
+
+		case CDE_INFLATE:
+			cmp_data->op = 0;
+			input_mem = cde_inf_input_mem;
+			output_mem = cde_inf_output_mem;
+			mem_start = cde_inf_mem_start;
+			break;
+
+		case CDE_DEFLATE:
+			cmp_data->op = 1;
+			input_mem = cde_input_mem;
+			output_mem = cde_output_mem;
+			mem_start = cde_mem_start;
+			break;
+		default:
+			printk("xlp_cde_ioctl: default\n");
+			return -ENOTTY;
+	}
+	cde = (struct nlm_cde_op*)mem_start;
+	input_size = *(unsigned int*)(mem_start + sizeof(struct nlm_cde_op));
+	output_size = *(unsigned int*)(mem_start + sizeof(struct nlm_cde_op) + sizeof(unsigned int));
+
+	cde = (struct nlmcde*)arg;
 
+	cmp_data->compression_type = cde->compression_type;
+	cmp_data->sof = cde->sof;
+	cmp_data->eof = cde->eof;
 #ifdef CDE_DEBUG
-  printk("xlp_cde_ioctl: cmd = %d\n", cmd);
+	printk("cde.compression_type = %d cde.sof = %d, cde.eof = %d\n",cde->compression_type, cde->sof, cde->eof);
 #endif
-  switch(cmd) {
-
-  case CDE_INFLATE:
-    cmp_data->op = 0;
-    input_mem = cde_inf_input_mem;
-    output_mem = cde_inf_output_mem;
-    mem_start = cde_inf_mem_start;
-    break;
-
-  case CDE_DEFLATE:
-    cmp_data->op = 1;
-    input_mem = cde_input_mem;
-    output_mem = cde_output_mem;
-    mem_start = cde_mem_start;
-    break;
-  default:
-	printk("xlp_cde_ioctl: default\n");
-    return -ENOTTY;
-  }
-
-  cde = (struct nlm_cde_op*)mem_start;
-  input_size = *(unsigned int*)(mem_start + sizeof(struct nlm_cde_op));
-  output_size = *(unsigned int*)(mem_start + sizeof(struct nlm_cde_op) + sizeof(unsigned int));
+	if(!sanity_test)
+	{
+		size = nlm_cde_send_request(cmp_data, cmp_data->op, cmp_data->compression_type, cmp_data->sof, cmp_data->eof, (unsigned char*)input_mem, input_size);
+#ifdef CDE_DEBUG
+		printk("#written %d byte of data\n", size);
+#endif
+		size = 0;
+		do{
+			size = nlm_cde_receive_response(cmp_data, (unsigned char*)output_mem, output_size);
+			i++;
+		}while(size == 0 && i < 0xffffff);
+		*(unsigned int*)(mem_start + sizeof(struct nlm_cde_op) + sizeof(unsigned int)) = size;
 #ifdef CDE_DEBUG
-  printk("cde.compression_type = %d cde.sof = %d, cde.eof = %d\n",cde->compression_type, cde->sof, cde->eof, input_size, output_size);
+		printk("Read %d byte of data\n", size);
+		dump_buffer(cmp_data->scratch_inf, SCRATCH_SIZE, "Inf Scratch:");
 #endif
-  cmp_data->compression_type = cde->compression_type;
-  cmp_data->sof = cde->sof;
-  cmp_data->eof = cde->eof;
-  size = nlm_cde_send_request(cmp_data, cmp_data->op, cmp_data->compression_type, cmp_data->sof, cmp_data->eof, (unsigned char*)input_mem, input_size);
-//printk("#%d written %d byte of data\n", k++, size);
-  size = 0;
-  do{
-    size = nlm_cde_receive_response(cmp_data, (unsigned char*)output_mem, output_size);
-    i++;
-  }while(size == 0 && i < 0xffffff);
-  *(unsigned int*)(mem_start + sizeof(struct nlm_cde_op) + sizeof(unsigned int)) = size;
-//printk("Read %d byte of data\n", size);
-//dump_buffer(cmp_data->scratch_inf, SCRATCH_SIZE, "Inf Scratch:");
-  return err;
+	}
+
+	return err;
 }
 
 
 #if 0
 static unsigned strtonum(char c)
 {
-        if(c >= '0' && c <= '9')
-                return (c - '0');
+	if(c >= '0' && c <= '9')
+		return (c - '0');
 
-        if(c >= 'A' && c <= 'F')
-                return (c - 'A' + 10);
+	if(c >= 'A' && c <= 'F')
+		return (c - 'A' + 10);
 
-        if(c >= 'a' && c <= 'f')
-                return (c - 'a' + 10);
+	if(c >= 'a' && c <= 'f')
+		return (c - 'a' + 10);
 }
 static void test()
 {
-  int i = 0;
-  unsigned int input_size = 0, output_size = 0, size;
-  unsigned char *input_mem, *output_mem, *mem_start;
-
-  input_mem = cde_inf_input_mem;
-  output_mem = cde_inf_output_mem;
-  mem_start = cde_inf_mem_start;
-
-  input_size = sizeof(src_gz_data)/2;//200;
-  output_size = MAX_BUFFER_SIZE;
-  for(i = 0; i < (input_size*2); i=i+2)
-  {
-    input_mem[i/2] = (strtonum(src_gz_data[i]) << 4) | strtonum(src_gz_data[i+1]);
-  }
-//dump_buffer(input_mem, input_size, "input:");
-  size = nlm_cde_send_request(cmp_data, 0, 1, 1, 1, (unsigned char*)input_mem, input_size);
-  printk("written %d byte of data\n", size);
-  size = 0;
-  do{
-    size = nlm_cde_receive_response(cmp_data, (unsigned char*)output_mem, output_size);
-    i++;
-  }while(size == 0 && i < 0xffffff);
-  printk("Read %d byte of data\n", size);
-//dump_buffer(output_mem, size, "output:");
+	int i = 0;
+	unsigned int input_size = 0, output_size = 0, size;
+	unsigned char *input_mem, *output_mem, *mem_start;
+
+	input_mem = cde_inf_input_mem;
+	output_mem = cde_inf_output_mem;
+	mem_start = cde_inf_mem_start;
+
+	input_size = sizeof(src_gz_data)/2;//200;
+	output_size = MAX_BUFFER_SIZE;
+	for(i = 0; i < (input_size*2); i=i+2)
+	{
+		input_mem[i/2] = (strtonum(src_gz_data[i]) << 4) | strtonum(src_gz_data[i+1]);
+	}
+	//dump_buffer(input_mem, input_size, "input:");
+	size = nlm_cde_send_request(cmp_data, 0, 1, 1, 1, (unsigned char*)input_mem, input_size);
+	printk("written %d byte of data\n", size);
+	size = 0;
+	do{
+		size = nlm_cde_receive_response(cmp_data, (unsigned char*)output_mem, output_size);
+		i++;
+	}while(size == 0 && i < 0xffffff);
+	printk("Read %d byte of data\n", size);
+	//dump_buffer(output_mem, size, "output:");
 
 }
 #endif
-
-static int __init xlp_cde_init(void)
-{
-    printk(KERN_ERR ",\n XLP CDE Initialization \n");
-
-    xlp_cde_major = register_chrdev(0, "NLM_XLP_CDE", &xlp_cde_fops);
-    if (xlp_cde_major < 0) {
-	printk(KERN_ERR "XLP_CDE - cannot register device\n");
-	return xlp_cde_major;
-    }
-    printk (KERN_ERR ",XLP CDE MAJOR %d\n", xlp_cde_major);
-
-    if (register_xlp_msgring_handler
-	    (XLP_MSG_HANDLE_CMP, nlm_xlp_cde_msgring_handler, NULL)) {
-	panic("can't register msgring handler for XLP_MSG_HANDLE_CMP");
-    }
-    printk("xlp_cde_init done\n\n");
-    if(is_nlm_xlp2xx())
-  	num_cde_engine = NUM_CDE_ENGINE_XLP2XX;
-    else if (cpu_is_xlp9xx())
-  	num_cde_engine = NUM_CDE_ENGINE_XLP9XX;
-    else
-  	num_cde_engine = NUM_CDE_ENGINE;
+void xlp_cde_dev_initialize(void) 
 {
-  int i =0;
-  unsigned int ret;
-  int frequency = 0;
-  int node = 0;
-
-  for(i = 0; i < num_cde_engine; i++)
-  {
-    ret = nlm_hal_read_cde_reg(CMP_REG_RESET_REG(i));
+	int i =0;
+	unsigned int ret;
+	int frequency = 0;
+	int node = 0;
+
+	for(i = 0; i < num_cde_engine; i++)
+	{
+		if(is_nlm_xlp9xx())
+			ret = nlm_hal_9xx_read_cde_reg(CMP_REG_RESET_REG(i));
+		else	
+			ret = nlm_hal_read_cde_reg(CMP_REG_RESET_REG(i));
 #ifdef CDE_DEBUG
-    printk("reset_reg = ret = %x\n", ret);
+		printk("reset_reg = ret = %x\n", ret);
 #endif
-    nlm_hal_write_cde_reg(CMP_REG_RESET_REG(i), 0x8);
-    do {
-    ret = nlm_hal_read_cde_reg(CMP_REG_RESET_REG(i));
+		if(is_nlm_xlp9xx())
+			nlm_hal_9xx_write_cde_reg(CMP_REG_RESET_REG(i), 0x8);
+		else
+			nlm_hal_write_cde_reg(CMP_REG_RESET_REG(i), 0x8);
+		do {
+			if(is_nlm_xlp9xx())
+				ret = nlm_hal_9xx_read_cde_reg(CMP_REG_RESET_REG(i));
+			else
+				ret = nlm_hal_read_cde_reg(CMP_REG_RESET_REG(i));
 #ifdef CDE_DEBUG
-    printk("reset_reg = ret = %x\n", ret);
+			printk("reset_reg = ret = %x\n", ret);
 #endif
-    if (((ret >> 4) & 0x1) == 1)
-      break;
-    } while (1);
-
-    frequency = nlm_hal_get_fdt_freq(fdt, NLM_CDE);
-    nlm_hal_set_cde_freq(node, frequency);
-
-    nlm_hal_write_cde_reg(CMP_REG_RESET_REG(i), 0x01);
-    nlm_hal_write_cde_reg(CMP_REG_RESET_REG(i), 0x00);
-  }
-  /*TEMP*/
-  nlm_cde_init();
+			if (((ret >> 4) & 0x1) == 1)
+				break;
+		} while (1);
+
+		/* TBD: commented for time being as there is no entry in FDT for cde frequency*/
+		frequency = nlm_hal_get_fdt_freq(fdt, NLM_CDE);
+		//printk("\n CDE Frequency = %d\n",frequency);
+		//nlm_hal_set_cde_freq(node, frequency);
+
+		if(is_nlm_xlp9xx())
+		{
+			nlm_hal_9xx_write_cde_reg(CMP_REG_RESET_REG(i), 0x01);
+			nlm_hal_9xx_write_cde_reg(CMP_REG_RESET_REG(i), 0x00);
+		}
+		else
+		{
+			nlm_hal_write_cde_reg(CMP_REG_RESET_REG(i), 0x01);
+			nlm_hal_write_cde_reg(CMP_REG_RESET_REG(i), 0x00);
+		}
+	}
+	nlm_cde_init();
 }
- //test();
 
-    return 0;
+//static struct class *dev_class;
+static int __init xlp_cde_init(void)
+{
+	printk(KERN_ERR ",\n XLP CDE Initialization \n");
+
+	xlp_cde_major = register_chrdev(0, "NLM_XLP_CDE", &xlp_cde_fops);
+	if (xlp_cde_major < 0) {
+		printk(KERN_ERR "XLP_CDE - cannot register device\n");
+		return xlp_cde_major;
+	}
+	printk (KERN_ERR ",XLP CDE MAJOR %d\n", xlp_cde_major);
+#if 0
+	if(0){
+		dev_t dev = MKDEV(xlp_cde_major, 0);
+		dev_class = class_create(THIS_MODULE, "chardrv");
+		if(dev_class == NULL)
+			printk("\n Class creation failed\n");
+		if(device_create(dev_class, NULL, dev, NULL, "nlm_cde") == NULL)
+			printk("\n Device creation failed\n");
+	}
+#endif
+
+	if (register_xlp_msgring_handler
+			(XLP_MSG_HANDLE_CMP, nlm_xlp_cde_msgring_handler, NULL)) {
+		panic("can't register msgring handler for XLP_MSG_HANDLE_CMP");
+	}
+	printk("xlp_cde_init done\n\n");
+	if(is_nlm_xlp2xx())
+		num_cde_engine = NUM_CDE_ENGINE_XLP2XX;
+	else if (cpu_is_xlp9xx())
+		num_cde_engine = NUM_CDE_ENGINE_XLP9XX;
+	else
+		num_cde_engine = NUM_CDE_ENGINE;
+
+	xlp_cde_dev_initialize();
+
+	return 0;
 }
 
 static void __exit xlp_cde_cleanup(void)
 {
-  /*TEMP*/
-    nlm_cde_cleanup(cmp_data);
-    unregister_chrdev(xlp_cde_major, "NLM_XLP_CDE");
+	/*TEMP*/
+	nlm_cde_cleanup(cmp_data);
+	unregister_chrdev(xlp_cde_major, "NLM_XLP_CDE");
 }
 
 module_init(xlp_cde_init);
@@ -1037,4 +1162,4 @@ module_exit(xlp_cde_cleanup);
 MODULE_DESCRIPTION("XLP Hardware CDE Support.");
 MODULE_LICENSE("GPL");
 MODULE_VERSION("0.1");
-MODULE_AUTHOR("Alok Agrawat");
+MODULE_AUTHOR("Broadcom");
diff --git a/drivers/misc/netlogic/nlm_cde/nlm_cde.h b/drivers/misc/netlogic/nlm_cde/nlm_cde.h
index 11264e8..a35a7b6 100644
--- a/drivers/misc/netlogic/nlm_cde/nlm_cde.h
+++ b/drivers/misc/netlogic/nlm_cde/nlm_cde.h
@@ -51,10 +51,13 @@
 #define MSGRNG_STNID_CMP0 XLP_STNID_CMP
 #define MSGRNG_STNID_CMP1 (XLP_STNID_CMP + 4)
 
+#define MSGRNG_9XX_STNID_CMP0 XLP_9XX_CMP_VC_BASE 
+#define MSGRNG_9XX_STNID_CMP1 (MSGRNG_9XX_STNID_CMP0 + 3)
+
 #define MSGRNG_2XX_STNID_CMP0 XLP_2XX_CDE_VC_BASE
 #define MSGRNG_2XX_STNID_CMP1 (XLP_2XX_CDE_VC_BASE + 1)
 
-#define RTN_BKT 1
+#define RTN_BKT 3
 #define FD_BURST_SIZE 1
 #define NUM_FREE_DESCRIPTORS 256 //must be less or equal to MAX_NUM_PAGES
 #define MAX_NUM_PAGES 256
diff --git a/drivers/misc/netlogic/soc_interface/on_chip.c b/drivers/misc/netlogic/soc_interface/on_chip.c
index eebca1d..142185b 100644
--- a/drivers/misc/netlogic/soc_interface/on_chip.c
+++ b/drivers/misc/netlogic/soc_interface/on_chip.c
@@ -104,6 +104,41 @@ static int xlp_napi_vc_count = 0;
 static int xlp_fmn_init_done = 0;
 extern unsigned int xlp_napi_vc_mask;
 
+/* This structure will work for CDE. It will work for NAE also but it is not correfcft.
+   Need to fill all valid station numbers*/ 
+static uint16_t xlp9xx_vc_to_handle_map[MAX_VC] = {
+	[0 ... 15] = XLP_MSG_HANDLE_CPU0,
+	[16 ... 31] = XLP_MSG_HANDLE_CPU1,
+	[32 ... 47] = XLP_MSG_HANDLE_CPU2,
+	[48 ... 63] = XLP_MSG_HANDLE_CPU3,
+	[64 ... 79] = XLP_MSG_HANDLE_CPU4,
+	[80 ... 95] = XLP_MSG_HANDLE_CPU5,
+	[96 ... 111] = XLP_MSG_HANDLE_CPU6,
+	[112 ... 127] = XLP_MSG_HANDLE_CPU7,
+	[128 ... 143] = XLP_MSG_HANDLE_CPU0,
+	[144 ... 159] = XLP_MSG_HANDLE_CPU1,
+	[160 ... 175] = XLP_MSG_HANDLE_CPU2,
+	[176 ... 191] = XLP_MSG_HANDLE_CPU3,
+	[192 ... 207] = XLP_MSG_HANDLE_CPU4,
+	[208 ... 223] = XLP_MSG_HANDLE_CPU5,
+	[224 ... 239] = XLP_MSG_HANDLE_CPU6,
+	[240 ... 255] = XLP_MSG_HANDLE_CPU7,
+	[256 ... 257] = XLP_MSG_HANDLE_PCIE0,
+	[258 ... 259] = XLP_MSG_HANDLE_PCIE1,
+	[260 ... 261] = XLP_MSG_HANDLE_PCIE2,
+	[262 ... 263] = XLP_MSG_HANDLE_PCIE3,
+	[264 ... 267] = XLP_MSG_HANDLE_DTRE,
+	[268 ... 271] = XLP_MSG_HANDLE_GDX,
+	[272 ... 280] = XLP_MSG_HANDLE_RSA_ECC,
+	[281 ... 296] = XLP_MSG_HANDLE_CRYPTO,
+	[400 ... 406] = XLP_MSG_HANDLE_CMP,
+	[305 ... 383] = XLP_MSG_HANDLE_INVALID,
+	[384 ... 391] = XLP_MSG_HANDLE_NAE_0,
+//	[392 ... 475] = XLP_MSG_HANDLE_INVALID,
+	[476 ... 1019] = XLP_MSG_HANDLE_NAE_0,
+	[1020 ... 1023] = XLP_MSG_HANDLE_INVALID,
+};
+
 static uint16_t vc_to_handle_map[MAX_VC] = {
 	[0 ... 15] = XLP_MSG_HANDLE_CPU0,
 	[16 ... 31] = XLP_MSG_HANDLE_CPU1,
@@ -538,7 +573,6 @@ static void msg_timer_handler(unsigned long data)
 	int cpu = smp_processor_id();
 	struct timer_list *timer = &per_cpu(msg_int_bkup_timer, cpu);
 
-
 	nlm_xlp_msgring_int_handler(XLP_IRQ_MSGRING_RVEC, NULL);
 
 	mod_timer_pinned(timer, jiffies + (HZ/100));
@@ -613,7 +647,6 @@ int register_xlp_msgring_handler(int major,
 		       __FUNCTION__, __LINE__, major, XLP_MAX_TX_STNS, action);
 		return ret;
 	}
-
 	/* Check if the message station is valid, if not return error */
 	spin_lock_irqsave(&msgrng_lock, flags);
 
-- 
1.9.1

