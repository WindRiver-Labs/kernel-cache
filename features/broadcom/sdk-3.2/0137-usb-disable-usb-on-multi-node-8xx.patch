From 08eefec34217590ac081bc42f9abace72354cc1c Mon Sep 17 00:00:00 2001
From: Jayachandran C <jchandra@broadcom.com>
Date: Wed, 11 Jun 2014 13:15:22 +0530
Subject: [PATCH 0137/1532] usb: disable usb on multi node 8xx

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/xlp/usb-init.c | 75 ++++++++++++++++++++++++++++-----------
 1 file changed, 54 insertions(+), 21 deletions(-)

diff --git a/arch/mips/netlogic/xlp/usb-init.c b/arch/mips/netlogic/xlp/usb-init.c
index f811798..aeb449f 100644
--- a/arch/mips/netlogic/xlp/usb-init.c
+++ b/arch/mips/netlogic/xlp/usb-init.c
@@ -39,6 +39,7 @@
 #include <linux/pci.h>
 #include <linux/platform_device.h>
 
+#include <asm/netlogic/common.h>
 #include <asm/netlogic/haldefs.h>
 #include <asm/netlogic/xlp-hal/iomap.h>
 #include <asm/netlogic/xlp-hal/xlp.h>
@@ -67,6 +68,8 @@
 #define nlm_get_usb_regbase(node, inst)		\
 	(nlm_get_usb_pcibase(node, inst) + XLP_IO_PCI_HDRSZ)
 
+static int disable_usb;
+
 static void nlm_usb_intr_en(int node, int port)
 {
 	uint32_t val;
@@ -99,51 +102,81 @@ static void nlm_usb_hw_reset(int node, int port)
 
 static int __init nlm_platform_usb_init(void)
 {
+	int nr_nodes = 0;
+	int node;
+
 	if (cpu_is_xlpii())
 		return 0;
 
+	for (node = 0; node < NLM_NR_NODES; node++) {
+		if (nlm_node_present(node))
+			nr_nodes++;
+	}
+
+	/* on 8XX multinode, USB is broken */
+	if (nr_nodes != 1) {
+		disable_usb = 1;
+		pr_err("Multinode configuration - USB skipped!\n");
+		return 0;
+	}
+
 	pr_info("Initializing USB Interface\n");
-	nlm_usb_hw_reset(0, 0);
-	nlm_usb_hw_reset(0, 3);
+	node = 0;
+	nlm_usb_hw_reset(node, 0);
+	nlm_usb_hw_reset(node, 3);
 
 	/* Enable PHY interrupts */
-	nlm_usb_intr_en(0, 0);
-	nlm_usb_intr_en(0, 3);
+	nlm_usb_intr_en(node, 0);
+	nlm_usb_intr_en(node, 3);
 
 	return 0;
 }
 
 arch_initcall(nlm_platform_usb_init);
 
-static u64 xlp_usb_dmamask = ~(u32)0;
-
 /* Fixup the IRQ for USB devices which is exist on XLP SOC PCIE bus */
 static void nlm_usb_fixup_final(struct pci_dev *dev)
 {
-	dev->dev.dma_mask		= &xlp_usb_dmamask;
-	dev->dev.coherent_dma_mask	= DMA_BIT_MASK(32);
-	switch (dev->devfn) {
-	case 0x10:
-		dev->irq = PIC_EHCI_0_IRQ;
+	int node, irq;
+
+	irq = 0;
+	node = xlp_socdev_to_node(dev);
+	switch (PCI_FUNC(dev->devfn)) {
+	case 0x0:
+		irq = PIC_EHCI_0_IRQ;
 		break;
-	case 0x11:
-		dev->irq = PIC_OHCI_0_IRQ;
+	case 0x1:
+		irq = PIC_OHCI_0_IRQ;
 		break;
-	case 0x12:
-		dev->irq = PIC_OHCI_1_IRQ;
+	case 0x2:
+		irq = PIC_OHCI_1_IRQ;
 		break;
-	case 0x13:
-		dev->irq = PIC_EHCI_1_IRQ;
+	case 0x3:
+		irq = PIC_EHCI_1_IRQ;
 		break;
-	case 0x14:
-		dev->irq = PIC_OHCI_2_IRQ;
+	case 0x4:
+		irq = PIC_OHCI_2_IRQ;
 		break;
-	case 0x15:
-		dev->irq = PIC_OHCI_3_IRQ;
+	case 0x5:
+		irq = PIC_OHCI_3_IRQ;
 		break;
 	}
+	if (irq)
+		dev->irq = nlm_irq_to_xirq(node, irq);
 }
+
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_NETLOGIC, PCI_DEVICE_ID_NLM_EHCI,
 		nlm_usb_fixup_final);
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_NETLOGIC, PCI_DEVICE_ID_NLM_OHCI,
 		nlm_usb_fixup_final);
+
+static void nlm_usb_fixup_early(struct pci_dev *dev)
+{
+	/* force PCI to ignore device */
+	if (disable_usb)
+		dev->hdr_type = 0x7f;
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_NETLOGIC, PCI_DEVICE_ID_NLM_EHCI,
+		nlm_usb_fixup_early);
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_NETLOGIC, PCI_DEVICE_ID_NLM_OHCI,
+		nlm_usb_fixup_early);
-- 
1.9.1

