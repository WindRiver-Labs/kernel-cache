From 3ecfd022be53cd5d8ac954bd96775aefa76deec0 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Tue, 11 May 2010 19:24:24 -0700
Subject: [PATCH 1266/1532] NAE: import of svn/xlp branch -r2449:2640

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/common.h       |   16 +
 drivers/net/ethernet/broadcom/nae/fmn_credit.h   |  385 +++++++
 drivers/net/ethernet/broadcom/nae/init_fmn.c     |   95 ++
 drivers/net/ethernet/broadcom/nae/init_nae.c     |  222 ++++
 drivers/net/ethernet/broadcom/nae/net_common.h   |  170 +++
 drivers/net/ethernet/broadcom/nae/reg.h          |   40 +
 drivers/net/ethernet/broadcom/nae/ucore_apps.c   |   77 ++
 drivers/net/ethernet/broadcom/nae/ucore_loader.c |   78 ++
 drivers/net/ethernet/broadcom/nae/ucore_loader.h |   18 +
 drivers/net/ethernet/broadcom/nae/xlp_hw.c       |  496 +++++++++
 drivers/net/ethernet/broadcom/nae/xlp_nae.c      | 1197 ++++++++++++++++++++++
 drivers/net/ethernet/broadcom/nae/xlp_nae.h      |   60 ++
 12 files changed, 2854 insertions(+)
 create mode 100644 drivers/net/ethernet/broadcom/nae/common.h
 create mode 100644 drivers/net/ethernet/broadcom/nae/fmn_credit.h
 create mode 100644 drivers/net/ethernet/broadcom/nae/init_fmn.c
 create mode 100644 drivers/net/ethernet/broadcom/nae/init_nae.c
 create mode 100644 drivers/net/ethernet/broadcom/nae/net_common.h
 create mode 100644 drivers/net/ethernet/broadcom/nae/reg.h
 create mode 100644 drivers/net/ethernet/broadcom/nae/ucore_apps.c
 create mode 100644 drivers/net/ethernet/broadcom/nae/ucore_loader.c
 create mode 100644 drivers/net/ethernet/broadcom/nae/ucore_loader.h
 create mode 100755 drivers/net/ethernet/broadcom/nae/xlp_hw.c
 create mode 100755 drivers/net/ethernet/broadcom/nae/xlp_nae.c
 create mode 100644 drivers/net/ethernet/broadcom/nae/xlp_nae.h

diff --git a/drivers/net/ethernet/broadcom/nae/common.h b/drivers/net/ethernet/broadcom/nae/common.h
new file mode 100644
index 0000000..6fd2138
--- /dev/null
+++ b/drivers/net/ethernet/broadcom/nae/common.h
@@ -0,0 +1,16 @@
+#ifndef _COMMON_H
+#define _COMMON_H
+
+extern  unsigned long long netlib_vaddrb;
+extern unsigned long long netlib_paddrb;
+#define PADDR_BASE 0x100000ULL
+#define PADDR_SIZE 0x200000
+#define INIT_VBASE( vbase, pbase) {netlib_vaddrb = vbase ; netlib_paddrb = pbase;}
+//#define PHYS_TO_VIRT(paddr) (uint64_t)((paddr) - (PADDR_BASE) + (vaddr_base))
+//#define VIRT_TO_PHYS(vaddr) (uint64_t)((vaddr) - (vaddr_base) + (PADDR_BASE))
+#define PHYS_TO_VIRT(paddr) (uint64_t)((paddr) - (netlib_paddrb) + (netlib_vaddrb))
+#define VIRT_TO_PHYS(vaddr) (uint64_t)((vaddr) - (netlib_vaddrb) + (netlib_paddrb))
+#define CACHELINE_SIZE          (1ULL << 6)
+#define CACHELINE_ALIGNED(addr) ( ((addr) + (CACHELINE_SIZE-1)) & ~(CACHELINE_SIZE-1) )
+
+#endif
diff --git a/drivers/net/ethernet/broadcom/nae/fmn_credit.h b/drivers/net/ethernet/broadcom/nae/fmn_credit.h
new file mode 100644
index 0000000..811e037
--- /dev/null
+++ b/drivers/net/ethernet/broadcom/nae/fmn_credit.h
@@ -0,0 +1,385 @@
+#ifndef FMN_CREDIT_H
+#define FMN_CREDIT_H
+
+const fmn_credit_type g_credit[] = {
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+0,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+1,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+2,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+3,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+4,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+5,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+6,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+7,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+8,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+9,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+10,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+11,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+12,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+13,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+14,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+15,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+16,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* CPU0 -->  TX*/
+{
+       CPU_Q_ID(0, 0, 0),
+        XLP_NET_TX_VC_BASE+17,
+        SET_UP_CREDITS|SET_UP_QUEUE,
+        FMN_QLEN_USE_DEFAULT,
+        FMN_CREDIT_DEFAULT
+ },
+
+
+/* TX -->  CPU FREE out*/
+{
+      XLP_NET_TX_VC_BASE,
+      CPU_Q_ID(0, 0, 1),
+      SET_UP_CREDITS|SET_UP_QUEUE,
+      18*FMN_QLEN_USE_DEFAULT,
+      18*FMN_CREDIT_DEFAULT,
+  },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+0,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+1,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+2,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+3,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+4,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+5,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+6,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+7,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+8,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+9,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+10,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+11,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+12,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+13,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+14,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+15,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+16,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+/* CPU --> RX FREE IN */
+ {
+     CPU_Q_ID( 0, 0, 0),
+      XLP_NET_RX_VC_BASE+17,
+      SET_UP_QUEUE|SET_UP_CREDITS,
+      FMN_QLEN_USE_DEFAULT,
+      FMN_CREDIT_DEFAULT
+      },
+
+
+{
+XLP_POE_VC_BASE,
+      CPU_Q_ID( 0, 0, 0),
+      SET_UP_CREDITS|SET_UP_QUEUE,
+      FMN_QLEN_USE_DEFAULT *18,
+      FMN_POE_CREDIT_DEFAULT *18
+ },
+
+
+{ MAX_FMN_CODE,      MAX_FMN_CODE,     MAX_FMN_CODE,     MAX_FMN_CODE,     MAX_FMN_CODE} };
+#endif
diff --git a/drivers/net/ethernet/broadcom/nae/init_fmn.c b/drivers/net/ethernet/broadcom/nae/init_fmn.c
new file mode 100644
index 0000000..a1025c2
--- /dev/null
+++ b/drivers/net/ethernet/broadcom/nae/init_fmn.c
@@ -0,0 +1,95 @@
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/netlogic/hal/nlm_hal_fmn.h>
+#include "net_common.h"
+#include "common.h"
+
+/*
+ * Egress :
+ *          [CPU]->[NA_TX]
+ * Ingress
+ *          [NA_RX]->[POE]->[CPU]
+ * */
+
+int fmn_init(const fmn_credit_type *credit)
+{
+  int i = 0;
+  uint64_t q_cfg = 0;
+
+     while(credit[i].s_qid != MAX_FMN_CODE)
+     {
+
+        if( credit[i].q_len == FMN_CREDIT_DEFAULT ) {
+
+            q_cfg = OUTQ_ENABLE;
+
+        } else {
+
+            /*TODO:
+             * do the spill configuration and queue information
+             * do the input validation
+             *  */
+
+            q_cfg = OUTQ_ENABLE;
+
+         }
+
+/*
+        log_dbg("config sqid %d dqid %d with credit %d\n", credit[i].s_qid,
+                                                              credit[i].d_qid,
+                                                              credit[i].credit);
+*/
+        if(credit[i].flag & SET_UP_QUEUE )
+	   nlm_hal_write_outq_config(credit[i].d_qid, q_cfg);
+
+        if(credit[i].flag & SET_UP_CREDITS)
+		nlm_hal_write_credit( credit[i].s_qid, credit[i].d_qid, credit[i].credit);
+
+        i++;
+
+     }
+
+ return SUCCESS;
+}
+
+
+void *init_nae_free_pool(int num_queue, unsigned char *pktmem , int num_bytes, int num_desc)
+{
+	struct xlp_msg msg0 = { {0, 0, 0, 0} };
+    unsigned char  *buf = pktmem;
+    int nae_rx_qid = XLP_NET_RX_VC_BASE;
+    int q = 0, i = 0;
+    int  code = 0;
+
+//	msgrng_access_enable();
+    for( q = 0 ; q < num_queue ; q++)
+    {
+
+//             log_dbg("%s queue num %d %d\n", __FUNCTION__, nae_rx_qid, q);
+	   for( i= 0; i < num_desc ; i ++ )
+        {
+
+//             msg0.entry[0] = VIRT_TO_PHYS((unsigned long)buf &0xffffffffc0ULL);
+             msg0.entry[0] = (unsigned long long)buf &0xffffffffc0ULL;
+//             log_dbg("%s free desc %llx\n", __FUNCTION__, msg0.entry[0]);
+             msg_print(1, 0, nae_rx_qid, &msg0);
+
+//	xlp_message_send(nae_rx_qid, 1, code, &msg0);
+#if 1
+             if (nlm_hal_send_msg1( nae_rx_qid,
+                                    code,
+                                    msg0.entry[0])) {
+
+                   log_err("send failed!\n");
+                   return NULL;
+               }
+#endif
+                buf += num_bytes;
+        }
+//        getchar();
+        nae_rx_qid ++;
+    }
+//	msgrng_access_disable();
+
+return (void *)buf;
+}
diff --git a/drivers/net/ethernet/broadcom/nae/init_nae.c b/drivers/net/ethernet/broadcom/nae/init_nae.c
new file mode 100644
index 0000000..18cb5d3
--- /dev/null
+++ b/drivers/net/ethernet/broadcom/nae/init_nae.c
@@ -0,0 +1,222 @@
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/netlogic/hal/nlm_hal_nae.h>
+#include "reg.h"
+#include "net_common.h"
+#include "common.h"
+
+#define XLP_NAE_UCODE_IO_OFFSET		0x90000000d0010000ULL
+#define CODESIZE_PER_UCORE (4<<10)
+
+
+   /*
+    *  Incantation from Verification code(Anand's)
+    *
+    *  (black magic follows )
+    */
+
+        /*
+         * reset netior softreset
+         * GMAC reset
+         * RX interface Credit
+         */
+#define read_gmac_reg(idx, reg) nlm_hal_read_mac_reg( ((idx&0xff)>>2), (idx& 0x3), reg)
+#define write_gmac_reg(idx, reg, val) nlm_hal_write_mac_reg( ((idx&0xff)>>2), (idx& 0x3), reg, val)
+int init_gmac(unsigned int  inf)
+{
+    unsigned int mac_cfg1 = 0 ;
+    unsigned int  mac_cfg2 = 0 ;
+    unsigned int netwk_inf  = 0;
+//    log_dbg("init inf %d block %d\n", inf& 0x3, (inf&0xff)>>2);
+
+    mac_cfg1 = read_gmac_reg( inf  , INF_MAC_CONFIG1);
+    mac_cfg2 = read_gmac_reg( inf, INF_MAC_CONFIG2);
+   netwk_inf  = read_gmac_reg( inf, INF_NETWK_INF_CTRL_REG);
+
+	nlm_hal_write_nae_iface_reg( 0xf, NETIOR_SOFTRESET, 0);
+
+    //write_gmac_reg( XLP_NAE_NAE_IO_OFFSET(  );
+    //Sofreset set bit 11 to 0
+
+    write_gmac_reg( inf , INF_NETWK_INF_CTRL_REG,  netwk_inf & 0xfffff7ff);
+
+
+    // TODO rewrite NAE registers
+    // Donnt ask me some undocumented hack in Validation script
+
+    //RX interface  NETIOR interface credit counter
+	nlm_hal_write_nae_iface_reg( 0xf, NETIOR_MISC_REG2_ADDR , 0x0421084 );
+	nlm_hal_write_nae_iface_reg( 0xf, NETIOR_MISC_REG1_ADDR , 0x00fffff );
+	nlm_hal_write_nae_iface_reg( 0xf, NETIOR_MISC_REG1_ADDR , 0x0);
+
+    // set softreset
+    write_gmac_reg( inf , INF_MAC_CONFIG1, INF_SOFTRESET(1)|
+	                                       /*  INF_LOOP_BACK(1)|*/
+                                                 INF_RX_ENABLE(1)|
+                                                 INF_TX_ENABLE(1) );
+
+    mac_cfg1 = read_gmac_reg( inf, INF_MAC_CONFIG1);
+    write_gmac_reg( inf , INF_MAC_CONFIG2, mac_cfg2|
+                                                 INF_PREMBL_LEN(0x7)|
+                                                 INF_IFMODE(0x2)|
+                                                 INF_FULLDUP(1)
+                                    );
+
+    // reset softreset
+//    log_dbg("tst1 mac_cfg %x\n", mac_cfg1);
+    write_gmac_reg( inf , INF_MAC_CONFIG1, mac_cfg1 & ~(INF_SOFTRESET(1)));
+
+    netwk_inf  = read_gmac_reg( inf, INF_NETWK_INF_CTRL_REG);
+
+    write_gmac_reg( inf , INF_NETWK_INF_CTRL_REG,  netwk_inf|
+                                                         STATS_EN(1)|
+                                                         TX_EN(1)|
+                                                        SPEED(0));
+
+/*
+    log_dbg("%d :inf %d MAC_CONFIG1: %x  val %x\n" , __LINE__, inf,
+                                                       read_gmac_reg( 0 , INF_MAC_CONFIG1),
+                                                     ( INF_SOFTRESET(1)|
+                                                       INF_LOOP_BACK(1)|
+                                                       INF_RX_ENABLE(1)|
+                                                       INF_TX_ENABLE(1) ));
+
+*/
+	return 0;
+}
+/*
+*   (black magic ends)
+*/
+
+
+// make sure the pktmem is cache aligned (64 byte)
+// & the num_byts is multiple of 64
+//
+ /* Free Queue Config
+     *
+     *  20 queues (1000  - 1019 ) form the ingress free pool
+     *  Size of the descriptor can be configured the following ways
+     *    a.Each Fifo has a unique size
+     *    b. ALL Fifo desc will have the same size
+     *  RX_CONFIG has sets the necessary bits to set the size
+     *
+      Default size is Desc 256 Byte (NEED TO VERIFY)
+     *
+     * */
+
+
+  /* EGRESS -> IOR credit configuration
+   *
+   *
+   *
+   * */
+
+int init_tx_if_credit( uint32_t credit_val, uint32_t if_bmask)
+{
+int tx_config = 0;
+
+    nlm_hal_write_nae_reg( TX_IORCRDT_INIT, credit_val);
+    tx_config = nlm_hal_read_nae_reg(TX_CONFIG);
+    //nlm_hal_write_nae_reg(TX_CONFIG, txconfig|1);
+    // need to toggle these bits for credits to be loaded
+    nlm_hal_write_nae_reg(TX_CONFIG, tx_config | ( TXINITIORCR(0x7ffff & if_bmask)));
+    nlm_hal_write_nae_reg(TX_CONFIG, tx_config & ~( TXINITIORCR(0x7ffff & if_bmask)));
+
+    return 0;
+}
+
+
+
+ /*
+  * uCore code
+  * configure Interface to ucore
+  * Load ucode
+  * Reset Ucore
+  *
+  * */
+
+#if 1  //disable init_ucore for now
+#define     VAL_UCORE_RESET(x)              ((x&0xffff)<<8)
+int init_ucore(uint32_t ucore_mask, int if_num)
+{
+	uint32_t ucore_cfg = 0;
+	nlm_hal_write_nae_reg(UCORE_IFACE_MASK_CFG,
+                          ucore_spray_config(if_num, ucore_mask, CMD_WRITE));
+/*	ucore_load_apps(ucore_mask);*/
+	ucore_cfg = nlm_hal_read_nae_reg(RX_UCORE_CFG);
+	nlm_hal_write_nae_reg(RX_UCORE_CFG, ucore_cfg & (~VAL_UCORE_RESET(ucore_mask)));
+
+    return 0;
+}
+#endif
+
+    /* Egress Config
+     *      Configure Qvc to interface mapping
+     *       524 queue (476 - 999)
+     *       VFBID to Destination Station ID
+     *       Credit Configuration between stages
+     *       Credit Configuration between interface N Egress bock
+     *       Context(NAE parlance ,means Queue in FMN)Memory
+     *          Setup to carve the Entry to Queue .
+     *       (Note Stage 1 configuration is obsolete .)
+     *       Trasmit Drr (reg 0x44 to 0x4d are  scheduler configuration)
+     *
+     *       Defaults:
+     *              Queue: 0 to 17 queue map to corresponding interface
+     *              VFBID: Dest Station ID = VFBID
+     *              Context memory setup : NOT CLEAR NO NUMBERS available
+     *              Scheduler : round robin
+     * */
+
+    /*
+     *                      40 - 23b|15 - 13| 12 - 9|
+     *                      bar addr|block |interface
+     * */
+
+
+init_ingress(void)
+{
+    unsigned int rx_cfg = 0;
+
+    rx_cfg = nlm_hal_read_nae_reg(RX_CONFIG);
+
+    //log_dbg("nae rxcfg %x txcfg %x\n", rx_cfg, tx_cfg);
+    #define NAE_MAX_MESSAGE_SIZE(x)                 ((x&0x1)<<1)
+    #define RESET_MAX_MESSAGE_SIZE                   ~(0x1<<1)
+    #define NAE_FRINDESCCLSIZE(x)                   ((x&0xff)<< 4 )
+    #define RESET_FRINDESCCLSIZE                   ~((0xff)<< 4)
+    #define NAE_RX_STATUS_MASK(x)                   ((x&0x3f) << 24)
+    #define RESET_RX_STATUS_MASK                   ~((0x3f) << 24)
+
+	nlm_hal_write_nae_reg( RX_CONFIG,(rx_cfg &
+                                      RESET_MAX_MESSAGE_SIZE &
+                                      RESET_FRINDESCCLSIZE &
+                                      RESET_RX_STATUS_MASK
+                                     ) |
+                                     NAE_RX_ENABLE|
+                                     NAE_MAX_MESSAGE_SIZE(0x3)|
+                                     NAE_RX_STATUS_MASK(0x3f)|
+                                     NAE_FRINDESCCLSIZE(4)
+                                    );
+
+}
+ /* Ingress Config
+  *      20 queue (1000 - 1019)
+  *      RxConfig : set the Free in desc default
+  *      Interface to context mapping
+  *      set valid active interface
+  *      calendar slots
+  *      parser configuration
+  *      Parser se
+  *
+  *
+  * */
+
+
+init_egress(void)
+{
+    uint32_t tx_cfg =  nlm_hal_read_nae_reg(TX_CONFIG);
+
+	nlm_hal_write_nae_reg( TX_CONFIG, tx_cfg|NAE_TX_ENABLE);
+
+}
diff --git a/drivers/net/ethernet/broadcom/nae/net_common.h b/drivers/net/ethernet/broadcom/nae/net_common.h
new file mode 100644
index 0000000..5706de7
--- /dev/null
+++ b/drivers/net/ethernet/broadcom/nae/net_common.h
@@ -0,0 +1,170 @@
+#ifndef NET_COMMON_H
+#define NET_COMMON_H
+
+#define MAX_FMN_CODE            -1
+#define FMN_CREDIT_DEFAULT      8
+#define FMN_POE_CREDIT_DEFAULT      9
+#define MAX_FMN_ARRAY               50
+#define SUCCESS                 0
+#define FAIL                    -1
+#define CPU0_VC                 0
+
+#define CPU_Q_ID(cpu, tid, vid) (cpu<<4|tid<<2|vid)
+#define QID_2_CPU(qid)          ((qid & 0x7F)>> 4)
+#define QID_2_TID(qid)          ((qid & 0xc)>>2 )
+#define QID_2_QID(qid)          (qid & 0x3)
+#define MAX_DEST_QID            50
+typedef struct fmn_credit_struct {
+   unsigned int   s_qid;
+   unsigned int   d_qid;
+   unsigned int   flag;
+   #define SET_UP_QUEUE         0x1
+   #define SET_UP_CREDITS       0x2
+   #define SET_UP_MULTI_DEST    0x4
+   #define SET_UP_MULTI_SRC     0x8
+   unsigned int   q_len;
+#define FMN_QLEN_USE_DEFAULT      0
+   unsigned int   credit;
+} fmn_credit_type;
+extern int init_gmac(unsigned int inf);
+extern int init_tx_if_credit( /*uint32_t*/__u32 credit_val, unsigned int if_bmask);
+extern int init_ucore(uint32_t ucore_mask, int if_num);
+extern int init_ingress(void);
+extern int init_egress(void);
+extern int fmn_init(const fmn_credit_type *credit);
+extern void *xlp_init_buffer( size_t size,
+                   size_t pbase ,
+                   uint64_t *vaddr_base
+                           );
+
+extern void *init_nae_free_pool(int num_queue,
+                              unsigned char *pktmem ,
+                              int num_bytes,
+                              int num_desc);
+extern void print_netreg(void);
+#define DBG        1
+#ifdef DBG
+    #define log_dbg     printk
+    #define log_pkt     printk
+#else
+    #define log_dbg(...)
+    #define log_pkt(...)
+//    #define log_err(...)
+#endif
+#define log_err
+#define log_info   printk
+
+#ifdef DBG
+static __inline__ void press_key_to_continue(void) {
+	log_dbg("press <enter> to continue...\n");
+/*	getchar();*/
+}
+#else
+#define press_key_to_continue()
+#endif
+
+#define CPU_Q_ID(cpu, tid, vid) (cpu<<4|tid<<2|vid)
+//TO BE changed
+#define XKPHYS_UNCACHED 0x9000000000000000ULL
+#define XLP_NAE_IO_OFFSET        (XKPHYS_UNCACHED | 0xd000e000)
+
+
+#define OUTQ_ENABLE 0x8000000000000000ULL
+
+enum NAE_REG_CMD {
+	CMD_READ = 0,
+	CMD_WRITE
+};
+
+#define NAE_RX_ENABLE 0x1
+#define NAE_TX_ENABLE 0x1
+
+#define CPU_Q_ID(cpu, tid, vid) (cpu<<4|tid<<2|vid)
+struct xlp_msg {
+	uint64_t entry[4];
+};
+
+static __inline__ void msg_print(uint32_t size, uint32_t code, uint32_t dest, struct xlp_msg *msg) {
+	int i;
+	log_dbg("  size = %u\n"
+	       "  code = %u (0x%x)\n"
+	       "  dest = %u (0x%x)\n",
+	       size, code, code, dest, dest);
+	for (i = 0; i < size && size <= 4; ++i) {
+		log_dbg("  msg.entry%d = 0x%016llx\n",
+		       i, msg->entry[i]);
+	}
+}
+
+static __inline__ void poe_print(uint64_t msg0) {
+	log_dbg("POE nextfid  = %llu (0x%llx)\n"
+	       "    nextdist = %llu (0x%llx)\n"
+	       "    nextdest = %llu (0x%llx)\n"
+	       "    msgaddr  = 0x%llx\n"
+	       "    fid      = %llu (0x%llx)\n",
+	       (msg0 >> 48) & 0xffff, (msg0 >> 48) & 0xffff,
+	       (msg0 >> 44) & 0xf, (msg0 >> 44) & 0xf,
+	       (msg0 >> 32) & 0xfff, (msg0 >> 32) & 0xfff,
+	       (msg0 >> 16) & 0xffff,
+	       (msg0) & 0xffff, (msg0) & 0xffff);
+}
+
+static __inline__ void rx_print(uint64_t msg0) {
+	log_dbg("RX  context = %llu\n"
+	       "    length  = %llu (0x%llx)\n"
+	       "    address = 0x%010llx\n"
+	       "    unclass = %llu\n"
+	       "    err     = %llu\n"
+	       "    IPcksm  = %llu\n"
+	       "    TCPcksm = %llu\n"
+	       "    prepad  = %llu\n"
+	       "    p2p     = %llu\n",
+	       (msg0 >> 54) & 0x3ff,
+	       (msg0 >> 40) & 0x3fff, (msg0 >> 40) & 0x3fff,
+	       (msg0) & 0xffffffffc0ULL,
+	       (msg0 >> 5) & 0x1,
+	       (msg0 >> 4) & 0x1,
+	       (msg0 >> 3) & 0x1,
+	       (msg0 >> 2) & 0x1,
+	       (msg0 >> 1) & 0x1,
+	       (msg0) & 0x1);
+}
+
+static __inline__ void buf_print(unsigned char *buf, unsigned long len) {
+	unsigned long i;
+	for (i = 0; i < len; ++i) {
+		log_dbg(" %02x", buf[i]);
+		if (i % 8 == 7) log_dbg(" ");
+		if (i % 32 == 31) log_dbg("\n");
+	}
+	log_dbg("\n");
+}
+
+#define CRC_LEN 4
+#define BYTE_OFFSET 2
+
+#define NULL_VFBID 127
+
+static __inline__ uint64_t nae_tx_desc(unsigned int type,
+	unsigned int rdex, unsigned int fbid, unsigned int len, uint64_t addr) {
+	return ((uint64_t)(type & 0x3) << 62) |
+	       ((uint64_t)(rdex & 0x1) << 61) |
+	       ((uint64_t)(fbid & 0x7f) << 54) |
+	       ((uint64_t)(len & 0x3fff) << 40) |
+	       (addr&0xffffffffffULL);
+}
+
+static __inline__ void tx_print(uint64_t msg0) {
+	log_dbg("TX  type    = %llu\n"
+	       "    rdex    = %llu\n"
+	       "    vfbid   = %llu\n"
+	       "    length  = %llu (0x%llx)\n"
+	       "    address = 0x%010llx\n",
+	       ((msg0 >> 62) & 0x3),
+	       ((msg0 >> 61) & 0x1),
+	       ((msg0 >> 54) & 0x7f),
+	       ((msg0 >> 40) & 0x3fff), ((msg0 >> 40) & 0x3fff),
+	       (msg0) & 0xffffffffffULL);
+}
+
+#endif
diff --git a/drivers/net/ethernet/broadcom/nae/reg.h b/drivers/net/ethernet/broadcom/nae/reg.h
new file mode 100644
index 0000000..d97fa53
--- /dev/null
+++ b/drivers/net/ethernet/broadcom/nae/reg.h
@@ -0,0 +1,40 @@
+#ifndef REG_H
+#define REG_H
+
+// Reg info
+#define INF_MAC_CONFIG1                     0
+#define INF_MAC_CONFIG2                     1
+#define INF_NETWK_INF_CTRL_REG              0x7f
+
+#define NETIOR_MISC_REG1_ADDR       0x39
+/* BAR address          */
+
+#define NAE_BAR_ADDRESS             0
+#define NETIOR_SOFTRESET            0x3
+    //NETWORK INF CTRL REG(non of the values match PRM)
+#define SOFTRESET(x)                        (x<<11)
+#define STATS_EN(x)                         (x<<16)
+#define TX_EN(x)                            (x<<2)
+#define SPEED(x)                            (x&0x3)
+    //MAC_CONFIG1
+#define INF_SOFTRESET(x)                    (x<< 31)
+#define INF_LOOP_BACK(x)                    (x<< 8)
+#define INF_RX_ENABLE(x)                    (x<< 2)
+#define INF_TX_ENABLE(x)                    (0x1)
+    //MAC_CONFIG2
+
+#define INF_PREMBL_LEN(x)                   ((x & 0xf)<<12)
+#define INF_IFMODE(x)                       ((x & 0x3) << 8)
+#define INF_LENCHK(x)                       (((x & 0x1)) << 4)
+#define INF_PADCRCEN(x)                     ((x&0x1)<<2)
+#define INF_PADCRC(x)                       ((x&0x1)<<1)
+#define INF_FULLDUP(x)                      (x&0x1)
+#define NETIOR_MISC_REG2_ADDR               (0x3a)
+#define NAE_REG_ADDRS(r)              (NAE_BAR_ADDRESS&(0xffffff00000)|0x7<<13| ((r &0x3ff)<<2))
+#define NAE_REG_TX_CONFIG              0x11
+#define NAE_REG_TXIORCRDT_INIT         0x59
+#define TXINITIORCR(x)                 (x & 0x7ffff) << 8
+
+
+
+#endif
diff --git a/drivers/net/ethernet/broadcom/nae/ucore_apps.c b/drivers/net/ethernet/broadcom/nae/ucore_apps.c
new file mode 100644
index 0000000..aad326d
--- /dev/null
+++ b/drivers/net/ethernet/broadcom/nae/ucore_apps.c
@@ -0,0 +1,77 @@
+#include "ucore_loader.h"
+
+uint32_t sample_array[] = {
+	0x0,
+	0x32,
+	0x3c1c0010,
+	0x279cf808,
+	0x3c020010,
+	0x2442f808,
+	0x3c030010,
+	0x2463f808,
+	0xac400000,
+	0x43082b,
+	0x1420fffd,
+	0x24420004,
+	0x3c1d0010,
+	0x27bdf9c0,
+	0x27a50020,
+	0x27a60028,
+	0xaca00000,
+	0xacc00000,
+	0xc000029,
+	0x2021,
+	0x1000ffff,
+	0x0,
+	0x3c020000,
+	0x8c4200fc,
+	0x27bdffe0,
+	0x2403ffff,
+	0xafbf001c,
+	0xafb10018,
+	0x10430009,
+	0xafb00014,
+	0x3c100000,
+	0x261000fc,
+	0x2411ffff,
+	0x40f809,
+	0x2610fffc,
+	0x8e020000,
+	0x1451fffc,
+	0x0,
+	0x8fbf001c,
+	0x8fb10018,
+	0x8fb00014,
+	0x3e00008,
+	0x27bd0020,
+	0x24030001,
+	0x1021,
+	0x34088004,
+	0x8d040000,
+	0x34088030,
+	0xad030000,
+	0x34088000,
+	0x800002b,
+	0xad020000,
+	0x0,
+	0x0,
+};
+#define sample_array_size 54
+ucore_array_info_t ucore_array_info[] = {
+	{ sample_array, sample_array_size },
+	{ sample_array, sample_array_size },
+	{ sample_array, sample_array_size },
+	{ sample_array, sample_array_size },
+	{ sample_array, sample_array_size },
+	{ sample_array, sample_array_size },
+	{ sample_array, sample_array_size },
+	{ sample_array, sample_array_size },
+	{ sample_array, sample_array_size },
+	{ sample_array, sample_array_size },
+	{ sample_array, sample_array_size },
+	{ sample_array, sample_array_size },
+	{ sample_array, sample_array_size },
+	{ sample_array, sample_array_size },
+	{ sample_array, sample_array_size },
+	{ sample_array, sample_array_size }
+};
diff --git a/drivers/net/ethernet/broadcom/nae/ucore_loader.c b/drivers/net/ethernet/broadcom/nae/ucore_loader.c
new file mode 100644
index 0000000..3c26d47
--- /dev/null
+++ b/drivers/net/ethernet/broadcom/nae/ucore_loader.c
@@ -0,0 +1,78 @@
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <asm/netlogic/hal/nlm_hal_nae.h>
+#include "ucore_loader.h"
+#include "ucore_apps.c"
+
+ucore_array_info_t ucore_array_info[MAX_UCORE];
+#if 0
+void WRITE_NAE_UCODE(int ucore, uint32_t offset, uint32_t code) {
+	xlp_write_nae_ucode(ucore, offset, code);
+}
+#endif
+static __inline__ void ucore_load_app(int ucore, uint32_t **array, uint32_t array_size) {
+	int k = 0, j;
+	uint32_t offset, size, code;
+	uint32_t *p = *array;
+//printk("array: %x, point2array %x\n",array,p);
+	if ((ucore < 0) || (ucore >= MAX_UCORE) ||
+	    (p == NULL) || (array_size == 0)) {
+		return;
+	}
+
+	while (k < array_size) {
+		offset = p[k];
+		size   = p[k + 1];
+//	printk("k: %d offset %d size %d\n",k, offset, size);
+
+	if(size >= array_size||size==0){
+
+//		printk("array_size wrong\n");
+		return;
+	}
+		for (j = 0; j < size; ++j) {
+			code = p[k + 2 + j];
+			nlm_hal_write_ucode(ucore, offset, code);
+//			WRITE_NAE_UCODE(ucore, offset, code);
+//			 printk("writeUcode idx: %d ucore:%d offset:%d code: %x\n", (k+2+j),ucore,offset, code);
+			offset += 4;
+		}
+		k += (2 + size);
+	}
+}
+
+int ucore_load_apps(uint32_t mask)
+{
+	int i=0,j=0,k=0,t, count = 0;
+	uint32_t *array, asize, offset, size, code;
+	printk("ucore_load_apps\n");
+	asize  = ucore_array_info[i].array_size;
+	array = kmalloc(sizeof(uint32_t)*asize, GFP_KERNEL);
+	if(!array)
+	{
+		printk("kmalloc failed\n");
+		return 0;
+	}
+	for (i = 0; i < MAX_UCORE; ++i) {
+		if (!(mask & (1 << i))) {
+			continue;
+		}
+//		array = ucore_array_info[i].array;
+		asize  = ucore_array_info[i].array_size;
+
+		for(t = 0; t < asize; t++)
+		{
+			array[t] = ucore_array_info[i].array[t];
+//			printk("%x ",array[t]);
+		}
+
+		if ((array == NULL) || (asize == 0)) {
+			continue;
+		}
+//	printk("\n\nucore_load_app( %d, %x, %x, %d)\n", i, &array,array, asize);
+		ucore_load_app(i, &array, asize);
+		count++;
+	}
+	kfree(array);
+	return count;
+}
diff --git a/drivers/net/ethernet/broadcom/nae/ucore_loader.h b/drivers/net/ethernet/broadcom/nae/ucore_loader.h
new file mode 100644
index 0000000..f0a3dab
--- /dev/null
+++ b/drivers/net/ethernet/broadcom/nae/ucore_loader.h
@@ -0,0 +1,18 @@
+#ifndef __UCORE_LOADER_H__
+#define __UCORE_LOADER_H__
+
+#define MAX_UCORE 16
+
+typedef struct {
+	uint32_t *array;
+	uint32_t array_size;
+} ucore_array_info_t;
+
+
+/* This OS dependent function must be provided by the application. */
+//extern void WRITE_NAE_UCODE(int ucore, uint32_t offset, uint32_t code);
+
+/* This is the only function that should be called by the application. */
+extern int ucore_load_apps(uint32_t mask);
+
+#endif /* __UCORE_LOADER_H__ */
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_hw.c b/drivers/net/ethernet/broadcom/nae/xlp_hw.c
new file mode 100755
index 0000000..2f71b07
--- /dev/null
+++ b/drivers/net/ethernet/broadcom/nae/xlp_hw.c
@@ -0,0 +1,496 @@
+/*********************************************************************
+
+  Copyright 2003-2010 Netlogic Microsystem, Inc. (NLM). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#NLM_2#**********************************/
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/mii.h>
+
+#include <asm/netlogic/xlr_mac.h>
+#include <asm/netlogic/hal/nlm_hal_nae.h>
+#include "xlp_nae.h"
+
+
+#define NLM_NUM_REG_DUMP 9 /* Register 0xa0 to 0xa8 */
+#define NLM_ETHTOOL_REG_LEN (NLM_NUM_REG_DUMP * 4)
+#define PHY_STATUS_RETRIES 25000
+
+#define DRV_NAME	"xlp_nae"
+#define DRV_VERSION     "0.1"
+
+static void nlm_xlp_mac_mii_write(struct dev_data *priv, int phyaddr, int regidx, unsigned int regval);
+static unsigned int nlm_xlp_mac_mii_read(struct dev_data *priv, int phyaddr, int regidx);
+void nlm_xlp_mac_set_enable(struct dev_data *priv, int flag);
+static int xlp_enable_autoneg(struct net_device *dev, u32 adv);
+static int xlp_set_link_speed(struct net_device *dev, int speed, int duplex);
+
+static int xlp_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct dev_data *priv = netdev_priv(dev);
+	int mii_status;
+
+	if ((priv->type == TYPE_XGMAC) || (priv->phy.mode == PHY_MODE_XAUI)){
+		cmd->supported = SUPPORTED_FIBRE|SUPPORTED_10000baseT_Full;
+		cmd->advertising = SUPPORTED_FIBRE|SUPPORTED_10000baseT_Full;
+		cmd->speed = SPEED_10000;
+		cmd->port = PORT_FIBRE;
+		cmd->duplex = DUPLEX_FULL;
+		cmd->phy_address = priv->port;
+		cmd->autoneg = AUTONEG_DISABLE;
+		cmd->maxtxpkt = 0;
+		cmd->maxrxpkt = 0;
+
+	}else{
+
+		cmd->supported = SUPPORTED_10baseT_Full |
+			SUPPORTED_10baseT_Half |
+			SUPPORTED_100baseT_Full | SUPPORTED_100baseT_Half |
+			SUPPORTED_1000baseT_Full | SUPPORTED_MII |
+			SUPPORTED_Autoneg | SUPPORTED_TP;
+
+		cmd->advertising = priv->advertising;
+
+		mii_status = nlm_xlp_mac_mii_read(priv, priv->phy.addr, MII_NCONFIG);
+		priv->speed = (mii_status >> 3) & 0x03;
+
+		cmd->speed = (priv->speed == xlp_mac_speed_1000) ? SPEED_1000 :
+		(priv->speed == xlp_mac_speed_100) ? SPEED_100: SPEED_10;
+
+		cmd->duplex = (mii_status >> 5) & 0x1;
+		cmd->port = PORT_TP;
+		cmd->phy_address = priv->port;
+		cmd->transceiver = XCVR_INTERNAL;
+		cmd->autoneg = (~(mii_status >> 14)) & 0x1;
+		cmd->maxtxpkt = 0;
+		cmd->maxrxpkt = 0;
+	}
+
+	return 0;
+}
+static int xlp_enable_autoneg(struct net_device *dev, u32 adv)
+{
+	struct dev_data *priv = netdev_priv(dev);
+	int mii_status;
+	u32 adv1, adv2;
+    unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	nlm_xlp_mac_set_enable(priv, 0);
+	/* advertising for 10/100 Mbps */
+	adv1 = nlm_xlp_mac_mii_read(priv, priv->phy.addr, MII_ADVERTISE);
+	adv1 &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4);
+	/* advertising for 1000 Mbps */
+	adv2 = nlm_xlp_mac_mii_read(priv, priv->phy.addr, 0x9);
+	adv2 &= ~(0x300);
+
+	if(adv & ADVERTISED_10baseT_Half)
+		adv1 |= ADVERTISE_10HALF;
+	if(adv & ADVERTISED_10baseT_Full)
+		adv1 |= ADVERTISE_10FULL;
+	if(adv & ADVERTISED_100baseT_Full)
+		adv1 |= ADVERTISE_100FULL;
+	if(adv & ADVERTISED_100baseT_Half)
+		adv1 |= ADVERTISE_100HALF;
+
+	if(adv & ADVERTISED_1000baseT_Full)
+		adv2 |= 0x200;
+	if(adv & ADVERTISED_1000baseT_Half)
+		adv2 |= 0x100;
+
+	/* Set the advertising parameters */
+	nlm_xlp_mac_mii_write(priv, priv->phy.addr, MII_ADVERTISE, adv1);
+	nlm_xlp_mac_mii_write(priv, priv->phy.addr, 0x9, adv2);
+
+	priv->advertising = adv1 | adv2;
+
+	mii_status = nlm_xlp_mac_mii_read(priv, priv->phy.addr, MII_BMCR);
+	/* enable autoneg and force restart autoneg */
+	mii_status |= (BMCR_ANENABLE | BMCR_ANRESTART);
+	nlm_xlp_mac_mii_write(priv, priv->phy.addr, MII_BMCR, mii_status);
+
+	nlm_xlp_mac_set_enable(priv, 1);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+
+static int xlp_set_link_speed(struct net_device *dev, int speed, int duplex)
+{
+	u32 adv;
+	int ret =0;
+
+	switch(speed) {
+		case SPEED_10:
+			if ( duplex == DUPLEX_FULL )
+				adv = ADVERTISED_10baseT_Full;
+			else
+				adv = ADVERTISED_10baseT_Half;
+			break;
+		case SPEED_100:
+			if ( duplex == DUPLEX_FULL )
+				adv = ADVERTISED_100baseT_Full;
+			else
+				adv = ADVERTISED_100baseT_Half;
+			break;
+		case SPEED_1000:
+			if ( duplex == DUPLEX_FULL )
+				adv = ADVERTISED_1000baseT_Full;
+			else
+				adv = ADVERTISED_1000baseT_Half;
+			break;
+		default:
+			ret = -EINVAL;
+			return ret;
+	}
+	ret = xlp_enable_autoneg( dev,adv);
+	return ret;
+
+}
+
+static int xlp_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	int ret;
+	struct dev_data *priv = netdev_priv(dev);
+
+	if ((priv->type == TYPE_XGMAC) || (priv->phy.mode == PHY_MODE_XAUI)){
+		return -EIO;
+	}
+	if (cmd->autoneg == AUTONEG_ENABLE) {
+		ret = xlp_enable_autoneg(dev, cmd->advertising);
+	}else {
+		ret = xlp_set_link_speed(dev, cmd->speed, cmd->duplex);
+	}
+	return ret;
+}
+
+static void xlp_get_drvinfo(struct net_device *dev,
+				struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, DRV_NAME);
+	strcpy(info->version, DRV_VERSION);
+}
+
+static int xlp_get_regs_len(struct net_device *dev)
+{
+	return NLM_ETHTOOL_REG_LEN;
+}
+static void xlp_get_regs(struct net_device *dev,
+				struct ethtool_regs *regs, void *p)
+{
+	u32 *data = (u32 *)p;
+	int i;
+	struct dev_data *priv = netdev_priv(dev);
+	unsigned long flags;
+
+	memset((void *)data, 0, NLM_ETHTOOL_REG_LEN);
+
+	spin_lock_irqsave(&priv->lock, flags);
+	for(i=0; i <= NLM_NUM_REG_DUMP; i++)
+		*(data + i) = nlm_hal_read_mac_reg(priv->block, priv->index,  R_TX_CONTROL + i);
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+static u32 xlp_get_msglevel(struct net_device *dev)
+{
+	return 0; //mac_debug;
+}
+static void xlp_set_msglevel(struct net_device *dev, u32 value)
+{
+//	mac_debug = value;
+}
+
+static int xlp_nway_reset(struct net_device *dev)
+{
+	struct dev_data *priv = netdev_priv(dev);
+	int mii_status;
+	unsigned long flags;
+	int ret = -EINVAL;
+
+   if ((priv->type == TYPE_XGMAC) || (priv->phy.mode == PHY_MODE_XAUI))
+    return -EIO;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	mii_status = nlm_xlp_mac_mii_read(priv, priv->phy.addr, MII_BMCR);
+	if(mii_status & BMCR_ANENABLE)
+	{
+		nlm_xlp_mac_mii_write(priv, priv->phy.addr,
+				MII_BMCR, BMCR_ANRESTART | mii_status);
+		ret = 0;
+	}
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return ret;
+}
+static u32 xlp_get_link(struct net_device *dev)
+{
+	struct dev_data *priv = netdev_priv(dev);
+	int mii_status;
+	unsigned long flags;
+
+   if ((priv->type == TYPE_XGMAC) || (priv->phy.mode == PHY_MODE_XAUI))
+    return -EIO;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	mii_status = nlm_xlp_mac_mii_read(priv, priv->phy.addr, MII_BMSR);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	if(mii_status & BMSR_LSTATUS)
+		return 1;
+	return 0;
+}
+#define NLM_STATS_KEY_LEN  \
+		(sizeof(struct net_device_stats) / sizeof(unsigned long))
+static struct {
+	        const char string[ETH_GSTRING_LEN];
+} xlp_ethtool_stats_keys[NLM_STATS_KEY_LEN] = {
+	{ "rx_packets" },
+	{ "tx_packets" },
+	{ "rx_bytes" },
+	{ "tx_bytes" },
+	{ "rx_errors" },
+	{ "tx_errors" },
+	{ "rx_dropped" },
+	{ "tx_dropped" },
+	{ "multicast" },
+	{ "collisions" },
+	{ "rx_length_errors" },
+	{ "rx_over_errors" },
+	{ "rx_crc_errors" },
+	{ "rx_frame_errors" },
+	{ "rx_fifo_errors" },
+	{ "rx_missed_errors" },
+	{ "tx_aborted_errors" },
+	{ "tx_carrier_errors" },
+	{ "tx_fifo_errors" },
+	{ "tx_heartbeat_errors" },
+	{ "tx_window_errors" },
+	{ "rx_compressed" },
+	{ "tx_compressed" }
+};
+static int xlp_get_stats_count (struct net_device *dev)
+{
+	return NLM_STATS_KEY_LEN;
+}
+
+static void xlp_get_strings (struct net_device *dev, u32 stringset, u8 *buf)
+{
+	switch (stringset) {
+	case ETH_SS_STATS:
+		memcpy(buf, &xlp_ethtool_stats_keys,
+				sizeof(xlp_ethtool_stats_keys));
+		break;
+	default:
+		printk(KERN_WARNING "%s: Invalid stringset %d\n",
+				__FUNCTION__, stringset);
+		break;
+	}
+}
+
+
+/**********************************************************************
+ * xlp_get_mac_stats -  collect stats info from Mac stats register
+ * @dev   -  this is per device based function
+ * @stats -  net device stats structure
+ **********************************************************************/
+void xlp_get_mac_stats(struct net_device *dev, struct net_device_stats *stats)
+{
+	struct dev_data *priv = netdev_priv(dev);
+
+	stats->tx_errors = nlm_hal_read_mac_reg( priv->block, priv->index, TX_FCS_ERROR_COUNTER);
+	stats->rx_dropped = nlm_hal_read_mac_reg( priv->block, priv->index, RX_DROP_PACKET_COUNTER);
+	stats->tx_dropped = nlm_hal_read_mac_reg( priv->block, priv->index, TX_DROP_FRAME_COUNTER);
+	stats->multicast = nlm_hal_read_mac_reg( priv->block, priv->index, RX_MULTICAST_PACKET_COUNTER);
+	stats->collisions = nlm_hal_read_mac_reg( priv->block, priv->index, TX_TOTAL_COLLISION_COUNTER);
+	stats->rx_length_errors = nlm_hal_read_mac_reg( priv->block, priv->index, RX_FRAME_LENGTH_ERROR_COUNTER);
+	stats->rx_over_errors = nlm_hal_read_mac_reg( priv->block, priv->index, RX_DROP_PACKET_COUNTER);
+	stats->rx_crc_errors = nlm_hal_read_mac_reg( priv->block, priv->index, RX_FCS_ERROR_COUNTER);
+	stats->rx_frame_errors = nlm_hal_read_mac_reg( priv->block, priv->index, RX_ALIGNMENT_ERROR_COUNTER);
+	stats->rx_fifo_errors = nlm_hal_read_mac_reg( priv->block, priv->index,RX_DROP_PACKET_COUNTER);
+	stats->rx_missed_errors = nlm_hal_read_mac_reg( priv->block, priv->index,RX_CARRIER_SENSE_ERROR_COUNTER);
+	stats->rx_errors = (stats->rx_over_errors + stats->rx_crc_errors + stats->rx_frame_errors + stats->rx_fifo_errors +stats->rx_missed_errors);
+	stats->tx_aborted_errors = nlm_hal_read_mac_reg( priv->block, priv->index, TX_EXCESSIVE_COLLISION_PACKET_COUNTER);
+	stats->tx_carrier_errors = nlm_hal_read_mac_reg( priv->block, priv->index, TX_DROP_FRAME_COUNTER);
+	stats->tx_fifo_errors = nlm_hal_read_mac_reg( priv->block, priv->index, TX_DROP_FRAME_COUNTER);
+	return;
+}
+
+/**********************************************************************
+ * xlp_get_ethtool_stats -  part of ethtool_ops member function
+ * @dev   -  this is per device based function
+ * @stats -  net device stats structure
+ **********************************************************************/
+static void xlp_get_ethtool_stats (struct net_device *dev,
+			struct ethtool_stats *estats, u64 *stats)
+{
+	int i;
+	struct dev_data *priv = netdev_priv(dev);
+	unsigned long flags;
+	unsigned long *tmp_stats;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	xlp_get_mac_stats(dev, &priv->stats);
+
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	tmp_stats = (unsigned long *)&priv->stats;
+	for(i=0; i < NLM_STATS_KEY_LEN; i++) {
+		*stats = (u64)*tmp_stats;
+		stats++;
+		tmp_stats++;
+	}
+}
+
+/**********************************************************************
+ *  nlm_xlp_mac_mii_read - Read mac mii phy register
+ *
+ *  Input parameters:
+ *  	   priv - priv structure
+ *  	   phyaddr - PHY's address
+ *  	   regidx = index of register to read
+ *
+ *  Return value:
+ *  	   value read (16 bits), or 0xffffffff if an error occurred.
+ ********************************************************************* */
+static unsigned int nlm_xlp_mac_mii_read(struct dev_data *priv, int phyaddr, int regidx)
+{
+	int i;
+
+	/* setup the phy reg to be used */
+	nlm_hal_write_mac_reg(priv->block, priv->index, R_MII_MGMT_ADDRESS,(phyaddr << 8) | (regidx << 0));
+
+	/* Issue the read command */
+	nlm_hal_write_mac_reg(priv->block, priv->index, R_MII_MGMT_COMMAND,(1 << O_MII_MGMT_COMMAND__rstat));
+
+	/* poll for the read cycle to complete */
+	for (i = 0; i < PHY_STATUS_RETRIES; i++) {
+		if (nlm_hal_read_mac_reg(priv->block, priv->index, R_MII_MGMT_INDICATORS) == 0)
+			break;
+	}
+
+	/* clear the read cycle */
+	nlm_hal_write_mac_reg(priv->block, priv->index, R_MII_MGMT_COMMAND, 0);
+
+	if (i == PHY_STATUS_RETRIES) {
+		return 0xffffffff;
+	}
+
+	/* Read the data back */
+	return nlm_hal_read_mac_reg(priv->block, priv->index, R_MII_MGMT_STATUS);
+}
+
+/**********************************************************************
+ *  nlm_xlp_mac_mii_write -Write mac mii PHY register.
+ *
+ *  Input parameters:
+ *  	   priv - priv structure
+ *  	   phyaddr - PHY to use
+ *  	   regidx - register within the PHY
+ *  	   regval - data to write to register
+ *
+ *  Return value:
+ *  	   nothing
+ ********************************************************************* */
+static void nlm_xlp_mac_mii_write(struct dev_data *priv, int phyaddr, int regidx, unsigned int regval)
+{
+	int i = 0;
+
+	nlm_hal_write_mac_reg(priv->block, priv->index, R_MII_MGMT_ADDRESS,(phyaddr << 8) | (regidx << 0));
+
+	/* Write the data which starts the write cycle */
+	nlm_hal_write_mac_reg(priv->block, priv->index, R_MII_MGMT_WRITE_DATA, regval);
+
+	/* poll for the write cycle to complete */
+	for (i = 0; i < PHY_STATUS_RETRIES; i++) {
+		if (nlm_hal_read_mac_reg(priv->block, priv->index, R_MII_MGMT_INDICATORS) == 0)
+			break;
+	}
+
+	return;
+}
+
+
+static struct ethtool_ops xlp_ethtool_ops= {
+        .get_settings           = xlp_get_settings,
+        .set_settings           = xlp_set_settings,
+        .get_drvinfo            = xlp_get_drvinfo,
+        .get_regs_len           = xlp_get_regs_len,
+        .get_regs               = xlp_get_regs,
+        .get_msglevel           = xlp_get_msglevel,
+        .set_msglevel           = xlp_set_msglevel,
+        .nway_reset             = xlp_nway_reset,
+        .get_link               = xlp_get_link,
+        .get_strings            = xlp_get_strings,
+        .get_stats_count        = xlp_get_stats_count,
+        .get_ethtool_stats      = xlp_get_ethtool_stats,
+};
+
+void xlp_set_ethtool_ops(struct net_device *netdev)
+{
+	SET_ETHTOOL_OPS(netdev, &xlp_ethtool_ops);
+}
+
+
+/**********************************************************************
+ **********************************************************************/
+void nlm_xlp_mac_set_enable(struct dev_data *priv, int flag)
+{
+	uint32_t regval;
+	int tx_threshold = 512;
+
+	if (flag) {
+		regval = nlm_hal_read_mac_reg(priv->block, priv->index, R_TX_CONTROL);
+		regval &= ~(0x3fff);
+		regval |= (1 << O_TX_CONTROL__TxEnable) |
+			(tx_threshold << O_TX_CONTROL__TxThreshold);
+
+		nlm_hal_write_mac_reg(priv->block, priv->index, R_TX_CONTROL, regval);
+
+		regval = nlm_hal_read_mac_reg(priv->block, priv->index, R_RX_CONTROL);
+		regval |= 1 << O_RX_CONTROL__RxEnable;
+		if (priv->phy.serdes_addr != 0 && (priv->phy.mode & PHY_MODE_RGMII))
+			regval |= 1 << O_RX_CONTROL__RGMII;
+		nlm_hal_write_mac_reg(priv->block, priv->index, R_RX_CONTROL, regval);
+	} else {
+		regval = nlm_hal_read_mac_reg(priv->block, priv->index, R_TX_CONTROL);
+		regval &= ~((1 << O_TX_CONTROL__TxEnable) |
+			    (tx_threshold << O_TX_CONTROL__TxThreshold));
+
+		nlm_hal_write_mac_reg(priv->block, priv->index, R_TX_CONTROL, regval);
+
+		regval = nlm_hal_read_mac_reg(priv->block, priv->index, R_RX_CONTROL);
+		regval &= ~(1 << O_RX_CONTROL__RxEnable);
+		nlm_hal_write_mac_reg(priv->block, priv->index, R_RX_CONTROL, regval);
+	}
+}
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
new file mode 100755
index 0000000..b2b067a
--- /dev/null
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -0,0 +1,1197 @@
+/********************************************************************
+
+  Copyright 2003-2010 Netlogic Microsystem, Inc. (NLM). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#NLM_2#**********************************/
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/fcntl.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+
+#include <asm/current.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+#include <asm/netlogic/msgring.h>
+#include <asm/netlogic/xlr_mac.h>
+
+#include <asm/netlogic/hal/nlm_hal_fmn.h>
+#include <asm/netlogic/hal/nlm_hal_nae.h>
+#include <asm/netlogic/hal/nlm_hal_pic.h>
+#include "net_common.h"
+#include "fmn_credit.h"
+#include "ucore_loader.h"
+#include "common.h"
+#include "xlp_nae.h"
+
+#define XLP_SOC_MAC_DRIVER "XLP Mac Driver"
+#define MAX_NUM_MACS 1
+#define PCI_NETL_VENDOR			0xfecc
+#define PCI_DEVID_BASE			0
+#define PCI_DEVID_OFF_NET		0
+#define MAX_NUM_UARTS			2
+#define FREE_DEFAULT_SIZE		256
+#define NUM_FREE_DESC			18
+#define NUM_FREEIN_QUEUE		18
+#define MIN_FRIN_DESC_THRESHD		8
+#define MAX_NET_INF             	18
+unsigned char icmp_pck[200] = {0x00,0x22,0x19,0x05,0xf0,0xb8,0x00,
+                      0xd0,0xd3,0x3a,0xbd,0x50,0x08,0x00,0x45,0x00,0x00,
+                      0x3c,0x92,0x42,0x00,0x00,0x7f,0x01,0x06,0xb4,0x0a,
+                      0x1a,0x72,0x18,0xc0,0xa8,0x65,0xf0,0x08,0x00,0x0b,
+                      0x12,0x04,0x00,0x3e,0x4a,0x61,0x62,0x63,0x64,0x65,
+                      0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
+                      0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x61,0x62,
+                      0x63,0x64,0x65,0x66,0x67,0x68,0x69  };
+
+
+#define MSG_DST_FC_FAIL                 0x01
+#define MSG_INFLIGHT_MSG_EX             0x02
+#define MSG_TXQ_FULL                    0x04
+#define ICMP_LEN                     	74
+#define MAX_GMAC_PORT               	18
+
+unsigned char eth_hw_addr[18][6] = {
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xE1},
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xE2},
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xE3},
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xE4},
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xE5},
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xE6},
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xE7},
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xE8},
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xE9},
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xEA},
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xEB},
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xEC},
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xED},
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xEE},
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xEF},
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xF1},
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xF2},
+					{0xB6,0x75,0x8E,0xDC,0x2F,0xF3}
+				   };
+
+static struct pci_device_id soc_pci_table[] __devinitdata = {
+        {PCI_NETL_VENDOR, PCI_DEVID_BASE + PCI_DEVID_OFF_NET,
+         PCI_ANY_ID, PCI_ANY_ID, 0},
+        {}
+};
+
+extern int  xlp_with_mac_driver;
+extern void xlp_set_ethtool_ops(struct net_device *netdev);
+extern void xlp_get_mac_stats(struct net_device* dev, struct net_device_stats* stats);
+
+static int xlp_mac_proc_read(char *page, char **start, off_t off,int count, int *eof, void *data);
+static int nlm_xlp_nae_fill_rxfr(struct net_device *dev, unsigned int intf);
+static int  nlm_xlp_nae_open (struct net_device *dev);
+static int  nlm_xlp_nae_stop (struct net_device *dev);
+static int  nlm_xlp_nae_start_xmit (struct sk_buff *skb, struct net_device *dev);
+static void  nlm_xlp_set_multicast_list (struct net_device *dev);
+static int  nlm_xlp_nae_ioctl (struct net_device *dev, struct ifreq *rq, int cmd);
+static int  nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu);
+static void  nlm_xlp_nae_tx_timeout (struct net_device *dev);
+static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id);
+static void nlm_xlp_msgring_handler(int bucket, int size, int code, int stid, struct msgrng_msg *msg, void* data);
+static void nlm_xlp_mac_timer(unsigned long data);
+static void  nlm_xlp_nae_rx(struct sk_buff* skb, struct net_device *dev);
+static struct net_device_stats *nlm_xlp_mac_get_stats(struct net_device *dev);
+
+static void  nlm_xlp_napi_poll(struct napi_struct *napi, int* budget);
+
+static struct net_device *dev_mac[MAX_GMAC_PORT];
+struct net_device *dev_mac_type[MAX_NET_TYPES][MAX_GMAC_PORT];
+
+
+extern struct proc_dir_entry *nlm_root_proc;
+static struct tasklet_struct mac_refill_task[MAX_GMAC_PORT];
+
+extern void nlm_xlp_mac_set_enable(struct dev_data *priv, int flag);
+
+static const struct net_device_ops nlm_xlp_nae_ops = {
+	.ndo_open	= nlm_xlp_nae_open,
+	.ndo_stop	= nlm_xlp_nae_stop,
+	.ndo_start_xmit	= nlm_xlp_nae_start_xmit,
+	.ndo_set_multicast_list	= nlm_xlp_set_multicast_list,
+	.ndo_do_ioctl	= nlm_xlp_nae_ioctl,
+	.ndo_tx_timeout = nlm_xlp_nae_tx_timeout,
+	.ndo_change_mtu	= nlm_xlp_nae_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_get_stats = nlm_xlp_mac_get_stats,
+};
+
+static __inline__ struct sk_buff *mac_get_skb_back_ptr(uint64_t addr)
+{
+        uint64_t *back_ptr =
+                (uint64_t *)(addr - CACHELINE_SIZE);
+//        printk("%s: addr = %llx,  back_ptr = %llx, skb = %llx\n", __FUNCTION__, addr, (uint64_t)back_ptr, *back_ptr);
+        /* this function should be used only for newly allocated packets. It assumes
+         * the first cacheline is for the back pointer related book keeping info
+         */
+        return (struct sk_buff *)(*back_ptr);
+}
+
+static __inline__ void mac_put_skb_back_ptr(struct sk_buff *skb)
+{
+        uint64_t *back_ptr = (uint64_t *)skb->data;
+
+        /* this function should be used only for newly allocated packets. It assumes
+         * the first cacheline is for the back pointer related book keeping info
+         */
+        skb_reserve(skb, CACHELINE_SIZE);
+        *back_ptr = (uint64_t)skb;
+//        printk("%s: skb->data=%llx, backptr:%llx  skb=%llx\n",__FUNCTION__, skb->data,*back_ptr, skb);
+}
+
+#define CACHELINE_ALIGNED_ADDR(addr) (((unsigned long)(addr)) & ~(CACHELINE_SIZE-1))
+
+/**********************************************************************
+ * cacheline_aligned_kmalloc -  64 bits cache aligned kmalloc
+ * return -  buffer address
+ *
+ **********************************************************************/
+static __inline__ void *cacheline_aligned_kmalloc(int size, int gfp_mask)
+{
+        void *buf = kmalloc(size + CACHELINE_SIZE, gfp_mask);
+        if (buf)
+                buf =
+                        (void
+                         *)(CACHELINE_ALIGNED_ADDR((unsigned long)buf +
+                                                   CACHELINE_SIZE));
+        return buf;
+}
+
+/**********************************************************************
+ * nlm_xlp_alloc_skb -  64 bits cache aligned skb buffer allocate
+ * return - skb buffer address
+ *
+ **********************************************************************/
+static __inline__ struct sk_buff *nlm_xlp_alloc_skb(void)
+{
+        int offset = 0;
+        struct sk_buff *skb = __dev_alloc_skb(NLM_RX_BUF_SIZE, GFP_KERNEL);
+
+        if (!skb) {
+                return NULL;
+        }
+        /* align the data to the next cache line */
+        offset = ((unsigned long)skb->data + CACHELINE_SIZE) &
+                ~(CACHELINE_SIZE - 1);
+        skb_reserve(skb, (offset - (unsigned long)skb->data));
+
+        return skb;
+}
+
+
+/**********************************************************************
+ * nlm_xlp_free_skb -  change msg into skb buffer address, free it
+ * @msg - freeback msg that sent to cpu vc
+ *
+ **********************************************************************/
+static inline void nlm_xlp_free_skb(struct xlp_msg *msg)
+{
+	struct sk_buff *skb;
+	struct dev_data *priv;
+	int cpu = hard_smp_processor_id();
+	unsigned long tmp;
+	tmp = (unsigned long)(msg->entry[0] & 0xffffffffffULL);
+	skb = (struct sk_buff *)bus_to_virt(tmp);
+
+	if(!skb)
+		return;
+	/* Tx Complete */
+//	xlr_inc_counter(NETIF_TX_COMPLETE);
+
+	dbg_msg("skb = %p\n", skb);
+	/* release the skb and update statistics outside the spinlock */
+	priv = netdev_priv(skb->dev);
+	priv->stats.tx_packets++;
+	priv->stats.tx_bytes += skb->len;
+	priv->cpu_stats[cpu].txc_packets++;
+
+
+	netif_tx_wake_all_queues(skb->dev);
+	//nlm_netif_queue_tx_complete(skb->dev);
+
+	dev_kfree_skb_any(skb);
+}
+/**********************************************************************
+ * mac_refill_frin_desc -  refill rx freein buffer for a device
+ * @dev -  this is per device based function
+ *
+ **********************************************************************/
+static  int mac_refill_frin_desc(struct net_device *dev)
+{
+	struct dev_data* priv = netdev_priv(dev);
+        int ret = 0, mflags = 0, i, code;
+        struct xlp_msg msg;
+	struct sk_buff * skb;
+	uint64_t *idx_ptr;
+
+	for(i=1; i <= MIN_FRIN_DESC_THRESHD*2; i++)
+	{
+		 skb = nlm_xlp_alloc_skb();
+		if(!skb)
+		{
+			printk("[%s] alloc skb failed\n",__FUNCTION__);
+			return -ENOMEM;
+		}
+
+		skb->dev = dev;
+
+		/* Send the free Rx desc to the MAC */
+		mac_put_skb_back_ptr(skb);
+		code = 0;
+		idx_ptr = (uint64_t*)((unsigned long)skb->data-20);
+		*idx_ptr = i;
+
+		msgrng_access_enable(mflags);
+		msg.entry[0] = (unsigned long long)virt_to_bus(skb->data) & 0xffffffffffULL;
+		msg.entry[1]= msg.entry[2] = msg.entry[3] = 0;
+
+		/* Send the packet to nae rx  */
+		__sync();
+retry_send:
+                if (ret = nlm_hal_send_msg1( priv->nae_rx_qid, code, msg.entry[0])){
+                        if(ret & MSG_DST_FC_FAIL)
+                                printk("TX message destination flow control credit fail\n");
+                        else if(ret & MSG_INFLIGHT_MSG_EX)
+                                goto retry_send;
+                        else if(ret & MSG_TXQ_FULL)
+                                printk("TX message Q fulll\n");
+                        dev_kfree_skb(skb);
+                        msgrng_access_disable(mflags);
+                        break;
+                }
+
+		msgrng_access_disable(mflags);
+		priv->num_desc++;
+/*
+ *		 printk("mac_%d: Sending freein %llx  to vc %d, num %d\n",priv->port, msg.entry[0], priv->nae_rx_qid, (int)priv->num_desc);
+*/
+	}
+
+        return ret;
+}
+
+/**********************************************************************
+ * nlm_xlp_nae_fill_rxfr -  create rx freein buffer for one interface
+ * @dev  -  this is per device based function
+ * @intf -  interface number
+ **********************************************************************/
+static int nlm_xlp_nae_fill_rxfr(struct net_device *dev, unsigned int intf)
+{
+        struct dev_data *priv = netdev_priv(dev);
+        struct sk_buff *skb = 0;
+        unsigned long mflags;
+        int i,code;
+        int ret = 1;
+        struct xlp_msg msg = { {0, 0, 0, 0} };
+	uint64_t* idx_ptr;
+
+	for (i = 1; i <= NUM_FREEIN_QUEUE ; i++) {
+		skb = nlm_xlp_alloc_skb();
+		if (!skb) {
+			printk("[%s] alloc skb failed\n",__FUNCTION__);
+			return -ENOMEM;
+		}
+
+		skb->dev = dev_mac[intf];
+
+		/* Send the free Rx desc*/
+		msgrng_access_enable(mflags);
+		mac_put_skb_back_ptr(skb);
+
+		code = 0;
+		idx_ptr = (uint64_t*)((uint64_t)skb->data-20);
+		*idx_ptr = i;
+
+		msg.entry[0] = (unsigned long long)virt_to_bus(skb->data) & 0xffffffffffULL;
+		msg.entry[1]= msg.entry[2] = msg.entry[3] = 0;
+retry_send:
+                if (ret = nlm_hal_send_msg1( priv->nae_rx_qid,
+                                        code,
+                                        msg.entry[0])){
+                        if(ret & MSG_DST_FC_FAIL)
+                                printk("TX message destination flow control credit fail\n");
+                        else if(ret & MSG_INFLIGHT_MSG_EX)
+                                goto retry_send;
+                        else if(ret & MSG_TXQ_FULL)
+                                printk("TX message Q fulll\n");
+                        dev_kfree_skb(skb);
+                        msgrng_access_disable(mflags);
+                        break;
+                }
+
+
+
+		msgrng_access_disable(mflags);
+		priv->num_desc++;
+/*
+ * 	printk("[%s] intf %d  freein %d    %llx  num_desc: %d\n", __FUNCTION__,intf, i, msg.entry[0],(int)priv->num_desc);
+*/
+        }
+
+        return ret;
+}
+
+static int __devinit mac_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+        int result = 0;
+
+        /*static atmoic_t int  num_macs = ATOMIC_INIT(0);*/
+        static int  num_macs = 1;
+        int instance = atomic_inc_return(&num_macs) - 1;
+
+        if (instance < 0 || instance >= (MAX_NUM_UARTS - 1)) {
+                printk("Found an Invalid mac pci device instance_%d!\n", instance);
+                return -1 ;
+        }
+        result = pci_enable_device(pdev);
+	return result;
+
+}
+
+/**********************************************************************
+ * nlm_xlp_nae_init -  xlp_nae device driver init function
+ * @dev  -  this is per device based function
+ *
+ **********************************************************************/
+
+static void nlm_xlp_nae_init(void)
+{
+	struct net_device *dev = NULL;
+	struct dev_data *tp;
+	int i;
+	unsigned long mflags;
+	struct proc_dir_entry *entry;
+
+/*
+	if(xlp_with_mac_driver == 0)
+	{
+		printk("NET: [%s] driver init is diabled. xlp_with_mac_driver=0\n",__FUNCTION__);
+		return;
+	}
+*/
+	//initial base address for nae, gmac, fmn ...
+	nlm_hal_init();
+
+	//initial 18 gmac block
+        for(i = 0; i < MAX_NET_INF; i++)
+	{
+		init_gmac(i);
+	}
+
+	//init fmn
+	fmn_init(g_credit);
+
+	msgrng_access_enable(mflags);
+
+	//init tx if credit
+	init_tx_if_credit( 0, 0x7FFFF );
+
+	for (i = 0; i < MAX_NET_INF; i++ )
+	{
+		init_ucore(0xffffUL, i);
+	}
+
+	ucore_load_apps(0xffffUL);
+
+	// init egress and igress interface
+	init_ingress();
+	init_egress();
+
+	for(i = 0; i< MAX_GMAC_PORT; i++)
+	{
+		dev = alloc_etherdev(sizeof(*tp));
+		if(!dev)
+			return ;
+
+		ether_setup(dev);
+
+		tp = netdev_priv(dev);
+		tp->dev 	= dev;
+		dev->netdev_ops = &nlm_xlp_nae_ops;
+		//set ethtool_ops which is inside xlp_ethtool.c file
+		xlp_set_ethtool_ops(dev);
+
+		netif_napi_add(dev, &tp->napi, nlm_xlp_napi_poll, 16);
+
+//		random_ether_addr(dev->dev_addr);
+		dev->dev_addr = eth_hw_addr[i];
+		tp->port	= i;
+		tp->inited	= 0;
+		tp->block 	=(i&0xff)>>2;
+		tp->index 	= i&0x3;
+		tp->nae_tx_qid 	= XLP_NET_TX_VC_BASE+i;
+		tp->nae_rx_qid 	= XLP_NET_RX_VC_BASE+i;
+		register_netdev(dev);
+
+		dev_mac_type[tp->type][tp->port] = dev;
+		dev_mac[i] = dev;
+
+	}
+
+	entry = create_proc_read_entry("nlm_mac_stats", 0 /* def mode */ ,
+				       nlm_root_proc /* parent */ ,
+				       xlp_mac_proc_read /* proc read function */ ,
+				       0	/* no client data */
+					);
+	if (!entry) {
+		printk("[%s]: Unable to create proc read entry for xlp_mac!\n",
+		       __FUNCTION__);
+	}
+
+	if(register_msgring_handler( 0 /*TX_STN_GMAC08*/, nlm_xlp_msgring_handler, NULL))
+	{
+		panic("can't register msgring handler for TX_STN_GMAC0");
+	}
+
+}
+
+/**********************************************************************
+ * nlm_xlp_nae_open -  called when bring up a device interface
+ * @dev  -  this is per device based function
+ *
+ **********************************************************************/
+
+static int  nlm_xlp_nae_open (struct net_device *dev)
+{
+	struct dev_data *priv = netdev_priv(dev);
+	int port = priv->port;
+	int ret  = 0, i;
+	int irq  = irt_irq_table[PIC_IRT_NA_INDEX(port)][0];
+
+	if(priv->inited)
+		return ret;
+
+	nlm_xlp_nae_fill_rxfr(dev,  port );
+
+	if(request_irq( irq, nlm_xlp_nae_int_handler, IRQF_SHARED,dev->name, dev)){
+		ret = -EBUSY;
+		printk("can't get mac interrupt line (%d)\n",dev->irq);
+	}
+	dump_irt_entry(PIC_IRT_NA_INDEX(port));
+	printk("PIC_CTRL: %x\n", nlm_hal_read_pic_reg((pic_reg_t*)XLP_IO_PIC_OFFSET, PIC_CTRL ));
+	printk("PIC_STATUS: %x\n", nlm_hal_read_pic_reg((pic_reg_t*)XLP_IO_PIC_OFFSET,PIC_STATUS ));
+	printk("PIC_INT_PENDING0: %x\n", nlm_hal_read_pic_reg((pic_reg_t*)XLP_IO_PIC_OFFSET, PIC_INT_PENDING0 ));
+	printk("PIC_INT_PENDING1: %x\n", nlm_hal_read_pic_reg((pic_reg_t*)XLP_IO_PIC_OFFSET, PIC_INT_PENDING1 ));
+	printk("PIC_INT_PENDING2: %x\n", nlm_hal_read_pic_reg((pic_reg_t*)XLP_IO_PIC_OFFSET, PIC_INT_PENDING2 ));
+	printk("PIC_IPI_CTL: %x\n", nlm_hal_read_pic_reg((pic_reg_t*)XLP_IO_PIC_OFFSET,PIC_IPI_CTL ));
+	/* set timer to test rx routine */
+	init_timer(&priv->link_timer);
+	priv->link_timer.expires = jiffies + HZ/100 ;
+	priv->link_timer.data    = (unsigned long) priv->port;
+	priv->link_timer.function = &nlm_xlp_mac_timer;
+	priv->phy_oldlinkstat = -1;
+/*
+	add_timer(&priv->link_timer);
+*/
+//	napi_enable(&priv->napi);
+
+
+//	nlm_xlp_mac_set_enable(priv, 1);
+
+	priv->stats.tx_packets	= 0;
+	priv->stats.tx_errors	= 0;
+	priv->stats.tx_bytes	= 0;
+	priv->stats.tx_dropped	= 0;
+	priv->stats.rx_packets	= 0;
+	priv->stats.rx_errors	= 0;
+	priv->stats.rx_bytes	= 0;
+	priv->stats.rx_dropped	= 0;
+	priv->stats.multicast	= 0;
+	priv->stats.collisions	= 0;
+
+	for(i = 0; i < 8; i++)
+	{
+		priv->cpu_stats[i].tx_packets	= 0;
+		priv->cpu_stats[i].txc_packets	= 0;
+		priv->cpu_stats[i].rx_packets	= 0;
+		priv->cpu_stats[i].interrupts	= 0;
+
+	}
+	tasklet_init(&mac_refill_task[port],mac_refill_frin_desc,(unsigned long) dev);
+	priv->inited = 1;
+
+	return 0;
+}
+
+/**********************************************************************
+ * nlm_xlp_nae_stop -  called when bring down the interface
+ * @dev  -  this is per device based function
+ *
+ **********************************************************************/
+static int  nlm_xlp_nae_stop (struct net_device *dev)
+{
+	struct dev_data *priv = netdev_priv(dev);
+
+	spin_lock_irq(&priv->lock);
+	nlm_xlp_mac_set_enable(priv, 0);
+
+	del_timer_sync(&priv->link_timer);
+	netif_tx_stop_all_queues(dev);
+
+	napi_disable(&priv->napi);
+	spin_unlock_irq(&priv->lock);
+	return 0;
+}
+
+
+/**********************************************************************
+ * nlm_xlp_nae_start_xmit -  transmit a packet from buffer
+ * @dev  -  this is per device based function
+ * @skb  -  data buffer to send
+ **********************************************************************/
+static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct dev_data *priv = netdev_priv(dev);
+	int port = priv->port;
+	unsigned long mflags = 0;
+	int cpu = 0, ret = 0;
+	struct xlp_msg msg =  { {0, 0, 0, 0} };
+
+	if(!skb)
+	{
+		printk("[%s] skb is NULL\n",__FUNCTION__);
+		return -1;
+	}
+	if(skb->len == 0)
+	{
+		printk("[%s] skb empty packet\n",__FUNCTION__);
+//		skb->len = 0x4e;
+		return -1;
+	}
+	mac_put_skb_back_ptr(skb);
+	msg.entry[0] = nae_tx_desc(P2D_NEOP, 0, CPU_Q_ID( 0, 0, 1), 0, virt_to_bus(skb));
+	msg.entry[1] = nae_tx_desc(P2D_EOP,
+							 0,
+							 NULL_VFBID,
+							 skb->len,
+							 virt_to_bus(skb->data+(port&0xf)));
+
+	msg.entry[2] = msg.entry[3] = 0;
+
+//	log_info("port:%d send %d skb %llx skb->data %llx len %d to qid %d \n", priv->port,(int)priv->stats.tx_packets, (uint64_t)skb, (uint64_t)skb->data,skb->len, nae_tx_qid);
+
+	__sync();
+	msgrng_access_enable(mflags);
+retry_send:
+        if (ret = nlm_hal_send_msg2( priv->nae_tx_qid,
+                           0,
+                           msg.entry[0],
+                           msg.entry[1]))
+        {
+                if(ret & MSG_DST_FC_FAIL)
+                        printk("TX message destination flow control credit fail\n");
+                else if(ret & MSG_INFLIGHT_MSG_EX)
+                        goto retry_send;
+                else if(ret & MSG_TXQ_FULL)
+                        printk("TX message Q fulll\n");
+                priv->stats.tx_errors++;
+                msgrng_access_disable(mflags);
+                return NETDEV_TX_BUSY;
+        }
+
+	msgrng_access_disable(mflags);
+	dev->trans_start = jiffies;
+
+	priv->stats.tx_bytes += skb->len;
+	priv->stats.tx_packets++;
+	priv->cpu_stats[cpu].tx_packets++;
+
+	if(priv->num_desc <= MIN_FRIN_DESC_THRESHD)
+	{
+		netif_stop_queue(dev);
+	}
+	return NETDEV_TX_OK;
+}
+
+
+static void  nlm_xlp_set_multicast_list (struct net_device *dev)
+{
+	if (dev->flags & IFF_ALLMULTI) {
+		/*
+		 * Enable ALL multicasts.  Do this by inverting the
+		 * multicast enable bit.
+		 */
+		return;
+	}
+	return;
+}
+
+static int  nlm_xlp_nae_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	int rc = 0;
+	switch (cmd) {
+	default:
+		rc = -EOPNOTSUPP;
+		break;
+	}
+
+	return rc;
+}
+
+/**********************************************************************
+ **********************************************************************/
+static int nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct dev_data *priv = netdev_priv(dev);
+	unsigned long flags;
+
+	if ((new_mtu > 1500) || (new_mtu < 64)) {
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	dev->mtu = new_mtu;
+
+	if (netif_running(dev)) {
+		/* Disable MAC TX/RX */
+		nlm_xlp_mac_set_enable(priv, 0);
+
+		/* Flush RX FR IN */
+		/* Flush TX IN */
+		nlm_xlp_mac_set_enable(priv, 1);
+	}
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return 0;
+}
+
+/**********************************************************************
+ * nlm_xlp_mac_get_stats - wrap function for xlp_get_mac_stats
+ * @dev   -  this is per device based function
+ **********************************************************************/
+static struct net_device_stats *nlm_xlp_mac_get_stats(struct net_device *dev)
+{
+	struct dev_data *priv = netdev_priv(dev);
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	xlp_get_mac_stats(dev, &priv->stats);
+
+	/* XXX update other stats here */
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return &priv->stats;
+}
+
+/**********************************************************************
+ * nlm_xlp_nae_tx_timeout -  called when transmiter timeout
+ * @dev  -  this is per device based function
+ *
+ **********************************************************************/
+static void  nlm_xlp_nae_tx_timeout (struct net_device *dev)
+{
+	struct dev_data *priv = netdev_priv(dev);
+
+	spin_lock_irq(&priv->lock);
+
+	priv->stats.tx_errors++;
+
+	spin_unlock_irq(&priv->lock);
+
+	netif_tx_wake_all_queues(dev);
+
+	printk(KERN_WARNING "%s: Transmit timed out\n", dev->name);
+	return;
+}
+
+/**********************************************************************
+ * nlm_xlp_nae_rx -  main receive function
+ * @skb  -  skb buffer address
+ * @dev  -  this device
+ *
+ **********************************************************************/
+static void  nlm_xlp_nae_rx(struct sk_buff* skb, struct net_device *dev)
+{
+	unsigned long mflags;
+	struct dev_data * priv = netdev_priv(dev);
+	unsigned int len, size,src_id, code, src;
+	unsigned char* buf;
+	uint64_t addr , vaddr;
+	uint32_t rx_status = 0;
+	struct xlp_msg fr_msg =  {{0, 0, 0, 0}} ;
+	struct xlp_msg rx_msg =  {{0, 0, 0, 0}} ;
+	unsigned short port;
+
+	int cpu_qid = CPU_Q_ID( 0, 0, 0); /* core0 thread0 vc0 */
+	int cpu = 0;
+
+	priv->cpu_stats[cpu].interrupts++;
+
+	msgrng_access_enable(mflags);
+
+
+	// process packet message at cpu vc 1
+	if (nlm_hal_recv_msg1(1,
+			  &src_id,
+			  &size,
+			  &code,
+			  &fr_msg.entry[0])){
+		rx_print(fr_msg.entry[0]);
+		printk("port: %d got src_id: %d fr_msg %llx \n\n",priv->port, src_id, fr_msg.entry[0]);
+		addr = (fr_msg.entry[0]) & 0xffffffffffULL;
+		len = (fr_msg.entry[0] >> 40) & 0x3fff;
+		if(addr && (len==0))
+		{
+			skb = (struct sk_buff *)bus_to_virt(addr);
+//			log_dbg("\nTX: port %d free addr:0x%llx \n",priv->port,(uint64_t)bus_to_virt(addr));
+			if(skb)
+			{
+				priv->stats.rx_packets++;
+				if(priv->stats.rx_packets % MIN_FRIN_DESC_THRESHD == 15)
+				{
+					netif_tx_wake_all_queues(dev);
+				}
+				dev_kfree_skb_any(skb);
+			}
+		}
+		else if(addr == 0)
+		{
+			//case tx queue is stopped
+			netif_tx_wake_all_queues(dev);
+		}
+	}
+	// process packet message at cpu vc 0
+	if (rx_status = nlm_hal_recv_msg2(cpu_qid,
+                                &src_id,
+				&size,
+				&code,
+				&rx_msg.entry[0],
+				&rx_msg.entry[1]))
+	{
+               if(rx_status & 0x01)
+                {
+                        priv->stats.rx_errors++;
+                        printk("[%s] RX Load msg failed\n",__FUNCTION__);
+			msgrng_access_disable(mflags);
+			return;
+                }
+                else if(rx_status & 0x02)
+                {
+                        priv->stats.rx_errors++;
+                        printk("[%s] RX pop msg request failed\n",__FUNCTION__);
+			msgrng_access_disable(mflags);
+			return;
+                }
+                else if(rx_status>>28)
+                {
+                        printk("[%s] RX queue %x empty, no msg\n",__FUNCTION__,(rx_status>>28));
+                        netif_tx_wake_all_queues(dev);
+			msgrng_access_disable(mflags);
+                        goto fill_desc;
+                }
+	}
+	msgrng_access_disable(mflags);
+
+	addr = (rx_msg.entry[1]) & 0xfffffffff0ULL;
+	len = (rx_msg.entry[1] >> 40) & 0x3fff;
+
+	//update dev and port to be accurate
+	port = rx_msg.entry[1]  & 0x0f;
+	dev = dev_mac[port];
+	priv = netdev_priv(dev);
+	if(!len || addr == 0)
+	{
+		if( priv->num_desc < MIN_FRIN_DESC_THRESHD)
+			tasklet_schedule(&mac_refill_task[priv->port]);
+		//goto fill_desc;
+		return;
+	}
+	vaddr = (uint64_t)bus_to_virt(addr);
+	buf = (unsigned char *)vaddr;
+//	log_dbg("RX: port:%d src_id: %d recv buf: 0x%llx len:%d addr:0x%010llx  \n",priv->port,src_id,(uint64_t)buf, len, vaddr);
+
+	if(len  - BYTE_OFFSET -MAC_CRC_LEN - MAC_PREPAD< 0)
+	{
+		//
+		priv->stats.rx_errors++;
+		priv->stats.rx_dropped++;
+		printk("[%s] wrong packet len %d, drop it!",__FUNCTION__,len);
+		return ;
+	}
+	else
+	{
+		len = len  - BYTE_OFFSET -MAC_CRC_LEN - MAC_PREPAD;
+
+		if(len >=2048)
+		{
+			priv->stats.rx_errors++;
+			priv->stats.rx_dropped++;
+			printk("[%s] packet too long %d, drop it!\n",__FUNCTION__,len);
+			return ;
+		}
+       }
+	skb = mac_get_skb_back_ptr(vaddr);
+        if (skb) {
+			src = *((unsigned long *)(skb->data-20));
+//			skb_reserve(skb, MAC_PREPAD+BYTE_OFFSET );
+//			printk("%s : addr :%llx  len:%d  skb: %llx src: %d  num_desc: %d\n", __FUNCTION__, addr, len, (uint64_t)skb,src,(int) priv->num_desc);
+			skb_put(skb, len);
+			skb->dev = dev_mac[port];
+			skb->protocol = eth_type_trans(skb, dev_mac[port]);
+//			printk("\n[%s] port: %d  dev %llx  protocol %d\n",__FUNCTION__, priv->port, (uint64_t)dev_mac[port], skb->protocol);
+			skb->dev->last_rx = jiffies;
+//		netif_receive_skb(skb);
+		netif_rx (skb);
+		priv->stats.rx_bytes += len;
+		priv->stats.rx_packets++;
+		priv->cpu_stats[cpu].rx_packets++;
+		priv->num_desc--;
+        }
+	else if(!skb)
+	{
+		priv->stats.rx_errors++;
+		priv->stats.rx_dropped++;
+		printk("[%s] wrong skb addr %llx, drop it!",__FUNCTION__,(uint64_t)skb);
+		return;
+	}
+
+fill_desc:
+	if(priv->num_desc < MIN_FRIN_DESC_THRESHD)
+	{
+		tasklet_schedule(&mac_refill_task[priv->port]);
+	}
+
+	return;
+
+}
+
+/**********************************************************************
+ * nlm_xlp_nae_int_handler -  interrupt handler
+ * @irq     -  irq number
+ * @dev_id  -  this device
+ *
+ **********************************************************************/
+static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id)
+{
+	if(!dev_id)
+	{
+		printk("[%s]: NULL dev_id \n", __FUNCTION__ );
+		return IRQ_HANDLED;
+	}
+	struct net_device * dev = (struct net_device*)dev_id;
+	struct dev_data *priv = netdev_priv(dev);
+	int i;
+
+	i = find_irt_from_irq(irq);
+
+	nlm_xlp_nae_rx(priv->skb, dev);
+
+	return IRQ_HANDLED;
+}
+
+/**********************************************************************
+ * nlm_xlp_msgring_handler -  message ring interrupt handler
+ * @irq     -  irq number
+ * @dev_id  -  this device
+ *
+ **********************************************************************/
+static void nlm_xlp_msgring_handler(int vc, int size, int code, int stid, struct msgrng_msg *msg, void* data)
+{
+	printk("%s : stid:%d \n", __FUNCTION__,stid );
+}
+
+/**********************************************************************
+ * xlp_mac_proc_read -  proc file system read routine
+ * @page     -  buffer address
+ * @dev_id  -  this device
+ *
+ **********************************************************************/
+static int xlp_mac_proc_read(char *page, char **start, off_t off,
+			     int count, int *eof, void *data)
+{
+	int len = 0;
+	off_t begin = 0;
+	int i = 0, cpu = 0;
+	struct net_device *dev = 0;
+	struct dev_data *priv = 0;
+
+
+	for(i=0; i< MAX_GMAC_PORT; i++) {
+		dev = dev_mac[i];
+		if(dev == 0)
+			continue;
+
+		priv = netdev_priv(dev);
+
+
+		len += sprintf(page + len,
+			       "per port:  %d %lx %lx %lx %lx\n",
+			       i,
+			       priv->stats.rx_packets, priv->stats.rx_bytes,
+			       priv->stats.tx_packets, priv->stats.tx_bytes);
+	}
+	for(cpu=0;cpu<8;cpu++) {
+			len += sprintf(page + len, "per cpu:  %d %lx %lx %lx %lx\n",
+				        cpu,
+				       priv->cpu_stats[cpu].tx_packets,
+				       priv->cpu_stats[cpu].txc_packets,
+				       priv->cpu_stats[cpu].rx_packets,
+				       priv->cpu_stats[cpu].interrupts);
+		}
+
+	*eof = 1;
+
+	*start = page + (off - begin);
+	len -= (off - begin);
+	if (len > count)
+		len = count;
+	if (len < 0)
+		len = 0;
+
+	return len;
+}
+
+
+/**********************************************************************
+ * nlm_xlp_mac_timer - interrupt handler routine
+ * @data - parameter passed in when timer interrupt handler is called.
+ **********************************************************************/
+static void nlm_xlp_mac_timer(unsigned long data)
+{
+	unsigned port = data;
+        struct net_device *dev = (struct net_device *)dev_mac[port];
+        struct dev_data *priv = netdev_priv(dev);
+        int next_tick = HZ;
+
+        spin_lock_irq(&priv->lock);
+	nlm_xlp_nae_rx(priv->skb, dev);
+        spin_unlock_irq(&priv->lock);
+        priv->link_timer.expires = jiffies + next_tick/10;
+        add_timer(&priv->link_timer);
+}
+
+/**********************************************************************
+ * nlm_xlp_napi_poll - net device napi callback handler
+ * @napi - structure for parameter
+ * @budget - max number buffer can be processed per call.
+ **********************************************************************/
+static void  nlm_xlp_napi_poll(struct napi_struct *napi, int* budget)
+{
+	unsigned long mflags;
+	struct net_device * dev = napi->dev;
+	struct dev_data * priv = netdev_priv(dev);
+	unsigned int len, size,src_id, code, src;
+	unsigned char* buf;
+	uint64_t addr , vaddr;
+	uint32_t rx_status = 0;
+	struct xlp_msg fr_msg =  {{0, 0, 0, 0}} ;
+	struct xlp_msg rx_msg =  {{0, 0, 0, 0}} ;
+	struct sk_buff* skb;
+
+	int cpu_qid = CPU_Q_ID( 0, 0, 0); /* core0 thread0 vc0 */
+	int cpu = 0;
+	printk("[%s] \n", __FUNCTION__);
+
+	priv->cpu_stats[cpu].interrupts++;
+
+	msgrng_access_enable(mflags);
+
+
+	// process packet message at cpu vc 1
+	if (nlm_hal_recv_msg1(1,
+			  &src_id,
+			  &size,
+			  &code,
+			  &fr_msg.entry[0])){
+		rx_print(fr_msg.entry[0]);
+//		printk("got a fr_msg \n\n");
+		addr = (fr_msg.entry[0]) & 0xffffffffffULL;
+		len = (fr_msg.entry[0] >> 40) & 0x3fff;
+		if(addr && (len==0))
+		{
+			skb = (struct sk_buff *)bus_to_virt(addr);
+//			log_dbg("\nfree addr:0x%010llx \n",(uint64_t)bus_to_virt(addr));
+			if(skb)
+			{
+				priv->stats.rx_packets++;
+				if(priv->stats.rx_packets % MIN_FRIN_DESC_THRESHD == 15)
+				{
+					netif_tx_wake_all_queues(dev);
+				}
+				dev_kfree_skb_any(skb);
+			}
+		}
+		else if(addr == 0)
+		{
+			//case tx queue is stopped
+			netif_tx_wake_all_queues(dev);
+		}
+	}
+	// process packet message at cpu vc 0
+	if (!nlm_hal_recv_msg2(cpu_qid,
+                                  &src_id,
+				&size,
+				&code,
+				&rx_msg.entry[0],
+				&rx_msg.entry[1]))
+	{
+	        rx_status = xlp_read_rx_status();
+		if(rx_status == 0)
+		{
+			netif_tx_wake_all_queues(dev);
+			return;
+		}
+		if (!((rx_status >> 28) & (1 << cpu_qid))) {
+			priv->stats.rx_errors++;
+			return;
+		}
+	}
+	msgrng_access_disable(mflags);
+
+	addr = (rx_msg.entry[1]) & 0xffffffffffULL;
+	len = (rx_msg.entry[1] >> 40) & 0x3fff;
+	if(!len || addr == 0)
+	{
+		if( priv->num_desc < MIN_FRIN_DESC_THRESHD)
+			tasklet_schedule(&mac_refill_task);
+		return;
+	}
+	vaddr = (uint64_t)bus_to_virt(addr);
+	buf = (unsigned char *)vaddr;
+	log_dbg("recv buf: 0x%llx len:%d addr:0x%llx  \n",(uint64_t)buf, len, vaddr);
+
+	if(len  - BYTE_OFFSET -MAC_CRC_LEN - MAC_PREPAD< 0)
+	{
+		//
+		priv->stats.rx_errors++;
+		priv->stats.rx_dropped++;
+		printk("[%s] wrong packet len %d, drop it!",__FUNCTION__,len);
+		return ;
+	}
+	else
+	{
+		len = len  - BYTE_OFFSET -MAC_CRC_LEN - MAC_PREPAD;
+
+		if(len >=2048)
+		{
+		priv->stats.rx_errors++;
+			priv->stats.rx_dropped++;
+			printk("[%s] packet too long %d, drop it!\n",__FUNCTION__,len);
+			return ;
+		}
+       }
+	skb = mac_get_skb_back_ptr(vaddr);
+        if (skb) {
+			src = *((unsigned long *)(skb->data-20));
+//			skb_reserve(skb, MAC_PREPAD+BYTE_OFFSET );
+//			printk("%s : addr :%llx  len:%d  skb: %llx src: %d  num_desc: %d\n", __FUNCTION__, addr, len, (uint64_t)skb,src, (int)priv->num_desc);
+			skb_put(skb, len);
+			skb->dev = dev;
+			skb->protocol = eth_type_trans(skb, dev);
+//	printk("\n[%s] port: %d  dev %llx  protocol %d\n",__FUNCTION__, priv->port, (uint64_t)dev, skb->protocol);
+			skb->dev->last_rx = jiffies;
+			netif_receive_skb(skb);
+			priv->stats.rx_bytes += len;
+			priv->stats.rx_packets++;
+			priv->cpu_stats[cpu].rx_packets++;
+        }
+	else if(!skb)
+	{
+		priv->stats.rx_errors++;
+		priv->stats.rx_dropped++;
+		printk("[%s] wrong skb addr %llx, drop it!",__FUNCTION__,(uint64_t)skb);
+		return;
+	}
+	if( -- priv->num_desc < MIN_FRIN_DESC_THRESHD)
+	{
+		tasklet_schedule(&mac_refill_task);
+	}
+
+	return;
+}
+
+
+/**********************************************************************
+ * nlm_xlp_remove - driver remove routine
+ * @pdev - pci device.
+ **********************************************************************/
+static void nlm_xlp_remove(struct pci_dev *pdev)
+{
+	int i;
+	struct net_device *dev;
+        struct dev_data *priv;
+
+	for (i = 0; i < MAX_GMAC_PORT; i++)
+	{
+		dev = dev_mac[i];
+		priv = netdev_priv(dev);
+		netif_napi_del(&priv->napi);
+		unregister_netdev(dev);
+		free_netdev(dev);
+	}
+
+	remove_proc_entry("nlm_mac_stats", nlm_root_proc /* parent dir*/ );
+
+}
+
+static struct pci_driver soc_driver = {
+	.name             = XLP_SOC_MAC_DRIVER,
+	.id_table         = soc_pci_table,
+	.probe            = mac_pci_probe,
+	.remove		  = nlm_xlp_remove,
+};
+
+static int __init nlm_xlp_mac_init(void)
+{
+
+	nlm_xlp_nae_init();
+
+	return pci_register_driver(&soc_driver);
+}
+
+static void __exit nlm_xlp_mac_exit(void)
+{
+	pci_unregister_driver(&soc_driver);
+}
+
+module_init(nlm_xlp_mac_init);
+module_exit(nlm_xlp_mac_exit);
+
+MODULE_AUTHOR("Netlogic Microsystems");
+MODULE_DESCRIPTION("Netlogic XLP SoC Network driver ");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.1");
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.h b/drivers/net/ethernet/broadcom/nae/xlp_nae.h
new file mode 100644
index 0000000..b4c18e5
--- /dev/null
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.h
@@ -0,0 +1,60 @@
+#ifndef _XLP_NAE_H
+#define _XLP_NAE_H
+
+#define MAX_CPUS	8
+
+struct cpu_stat {
+        unsigned long tx_packets;
+        unsigned long txc_packets;
+        unsigned long rx_packets;
+        unsigned long interrupts;
+};
+
+typedef enum { xlp_mac_speed_10, xlp_mac_speed_100,
+               xlp_mac_speed_1000, xlp_mac_speed_rsvd
+} xlp_mac_speed_t;
+
+typedef enum { xlp_mac_duplex_auto, xlp_mac_duplex_half,
+               xlp_mac_duplex_full
+} xlp_mac_duplex_t;
+
+typedef enum { xlp_mac_fc_auto, xlp_mac_fc_disabled, xlp_mac_fc_frame,
+               xlp_mac_fc_collision, xlp_mac_fc_carrier
+} xlp_mac_fc_t;
+
+struct phy_info {
+        int addr;
+        int mode;
+        uint32_t *mii_addr;
+        uint32_t *pcs_addr;
+        uint32_t *serdes_addr;
+};
+
+struct dev_data
+{
+        struct net_device *dev;
+        struct net_device_stats stats;
+        struct cpu_stat cpu_stats[MAX_CPUS];
+        struct timer_list link_timer;
+        struct napi_struct napi;
+        spinlock_t lock;
+        unsigned short port;
+	unsigned short inited;
+        unsigned short block;
+        unsigned short index;
+        unsigned short type;
+        struct sk_buff* skb;
+        int phy_oldlinkstat;
+        unsigned long num_desc;
+        __u8 hwaddr[6];
+
+        xlp_mac_speed_t speed;  /* current speed */
+        xlp_mac_duplex_t duplex;        /* current duplex */
+        xlp_mac_fc_t flow_ctrl; /* current flow control setting */
+        int advertising;
+        struct phy_info phy;
+        int nae_rx_qid;
+        int nae_tx_qid;
+};
+
+#endif
-- 
1.9.1

