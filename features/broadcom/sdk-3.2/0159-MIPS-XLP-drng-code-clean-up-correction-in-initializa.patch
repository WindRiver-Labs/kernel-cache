From 205a314549be93c1076e64229b2dba3f528f1c5f Mon Sep 17 00:00:00 2001
From: Subhendu Sekhar Behera <sbehera@broadcom.com>
Date: Tue, 18 Nov 2014 20:01:55 +0530
Subject: [PATCH 0159/1532] MIPS: XLP: drng: code clean-up, correction in
 initialization.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/char/hw_random/Kconfig        |   6 +-
 drivers/char/hw_random/Makefile       |   2 +-
 drivers/char/hw_random/netlogic-rng.c | 304 ----------------------------------
 drivers/char/hw_random/xlp-rng.c      | 303 +++++++++++++++++++++++++++++++++
 4 files changed, 307 insertions(+), 308 deletions(-)
 delete mode 100644 drivers/char/hw_random/netlogic-rng.c
 create mode 100644 drivers/char/hw_random/xlp-rng.c

diff --git a/drivers/char/hw_random/Kconfig b/drivers/char/hw_random/Kconfig
index 220c1f2..a5dc2ba 100644
--- a/drivers/char/hw_random/Kconfig
+++ b/drivers/char/hw_random/Kconfig
@@ -99,13 +99,13 @@ config HW_RANDOM_BCM2835
 
 	  If unsure, say Y.
 
-config HW_RANDOM_NETLOGIC
-	tristate "NetLogic Deterministic RNG Support"
+config HW_RANDOM_XLP
+	tristate "XLP Deterministic RNG Support"
 	depends on HW_RANDOM && NLM_XLP_BOARD
 	default HW_RANDOM
 	---help---
 	  This driver provides kernel-side support for the Random Number
-	  Generator on the Broadcom XLP-II Processors.
+	  Generator on the Broadcom XLP Processors.
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called netlogic-rng
diff --git a/drivers/char/hw_random/Makefile b/drivers/char/hw_random/Makefile
index eb38758..31e6ef0 100644
--- a/drivers/char/hw_random/Makefile
+++ b/drivers/char/hw_random/Makefile
@@ -9,7 +9,7 @@ obj-$(CONFIG_HW_RANDOM_INTEL) += intel-rng.o
 obj-$(CONFIG_HW_RANDOM_AMD) += amd-rng.o
 obj-$(CONFIG_HW_RANDOM_ATMEL) += atmel-rng.o
 obj-$(CONFIG_HW_RANDOM_BCM63XX)	+= bcm63xx-rng.o
-obj-$(CONFIG_HW_RANDOM_NETLOGIC) += netlogic-rng.o
+obj-$(CONFIG_HW_RANDOM_XLP) += xlp-rng.o
 obj-$(CONFIG_HW_RANDOM_GEODE) += geode-rng.o
 obj-$(CONFIG_HW_RANDOM_N2RNG) += n2-rng.o
 n2-rng-y := n2-drv.o n2-asm.o
diff --git a/drivers/char/hw_random/netlogic-rng.c b/drivers/char/hw_random/netlogic-rng.c
deleted file mode 100644
index 30878e7..0000000
--- a/drivers/char/hw_random/netlogic-rng.c
+++ /dev/null
@@ -1,304 +0,0 @@
-/*
- * Deterministic Random number generator for Netlogic XLP processors
- *
- * Copyright (C) 2014, Broadcom Corporation
- */
-
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/io.h>
-#include <linux/err.h>
-#include <linux/clk.h>
-#include <linux/platform_device.h>
-#include <linux/hw_random.h>
-#include <linux/delay.h>
-
-#include <asm/netlogic/common.h>
-#include <asm/netlogic/haldefs.h>
-#include <asm/netlogic/mips-extns.h>
-
-#include <asm/netlogic/xlp-hal/iomap.h>
-#include <asm/netlogic/xlp-hal/xlp.h>
-
-#define XLP_DRNG_BASE		0x5c
-#define XLP_DRNG_CFG		(XLP_DRNG_BASE + 0)
-#define XLP_DRNG_RESEED_TIME	(XLP_DRNG_BASE + 1)
-#define XLP_DRNG_PERSONAL_STR0	(XLP_DRNG_BASE + 2)
-#define XLP_DRNG_PERSONAL_STR1	(XLP_DRNG_BASE + 3)
-#define XLP_DRNG_DATA(n)	(XLP_DRNG_BASE + 0x4 + (n))
-
-#define XLP9XX_DRNG_BASE		0x25
-#define XLP9XX_DRNG_CFG			((XLP9XX_DRNG_BASE + 0)*2)
-#define XLP9XX_DRNG_SWM			((XLP9XX_DRNG_BASE + 1)*2)
-#define XLP9XX_DRNG_RESEED_TIME		((XLP9XX_DRNG_BASE + 2)*2)
-#define XLP9XX_DRNG_PERSONAL_STR	((XLP9XX_DRNG_BASE + 3)*2)
-#define XLP9XX_DRNG_DATA(n)		((XLP9XX_DRNG_BASE + 0x4 + (n))*2)
-
-#define XLP_DRNG_CFG_ENABLE	0
-#define XLP_DRNG_CFG_RAWMODE	1
-#define XLP_DRNG_CFG_RESET	2
-#define XLP_DRNG_CFG_RESEED	3
-#define XLP_DRNG_CFG_BUSY	4
-#define XLP_DRNG_CFG_VALID	5
-#define XLP_DRNG_CFG_DRAW	6
-#define XLP_DRNG_CFG_ERR0	7
-#define XLP_DRNG_CFG_ERR1	8
-#define XLP_DRNG_CFG_ERR2	9
-
-/* Raw mode bypasses the Deterministic logic */
-static unsigned int global_raw_mode;
-module_param(global_raw_mode, int, S_IRUGO);
-MODULE_PARM_DESC(global_raw_mode,
-		"Raw mode, bypass the deterministic generator (Default="
-		__MODULE_STRING(0) ")");
-
-static int is_9xx;
-
-static inline uint32_t drng_get_data(uint32_t);
-static inline uint32_t drng_get_data_9xx(uint32_t);
-
-struct xlp_rng_data_priv {
-	uint64_t rsa_regbase;
-	uint32_t drng_base;
-	uint32_t drng_cfg;
-	uint32_t drng_swm;
-	uint32_t drng_reseed_time;
-	uint32_t drng_personal_str0;
-	uint32_t drng_personal_str1;
-	uint32_t max_data;
-	uint32_t (*rng_data) (uint32_t);
-	struct hwrng drng;
-} xlp_rng_data_list[] = {
-	[0] = { 0, XLP_DRNG_BASE, XLP_DRNG_CFG, -1,
-		XLP_DRNG_RESEED_TIME, XLP_DRNG_PERSONAL_STR0,
-		XLP_DRNG_PERSONAL_STR1, 8, drng_get_data },
-	[1] = { 0, XLP9XX_DRNG_BASE, XLP9XX_DRNG_CFG,
-		XLP9XX_DRNG_SWM, XLP9XX_DRNG_RESEED_TIME,
-		XLP9XX_DRNG_PERSONAL_STR, -1, 4, drng_get_data_9xx },
-};
-
-
-static inline void drng_write_reg(struct xlp_rng_data_priv *priv,
-			uint32_t reg, uint64_t val)
-{
-	is_9xx ? nlm_write_reg64(priv->rsa_regbase, reg, val) :
-		nlm_write_reg(priv->rsa_regbase, reg, (uint32_t)val);
-}
-
-static inline uint64_t drng_read_reg(struct xlp_rng_data_priv *priv,
-			uint32_t reg)
-{
-	return is_9xx ? nlm_read_reg64(priv->rsa_regbase, reg) :
-		(uint64_t)nlm_read_reg(priv->rsa_regbase, reg);
-}
-
-static inline uint32_t drng_get_data(uint32_t index)
-{
-	return XLP_DRNG_DATA(index);
-}
-
-static inline uint32_t drng_get_data_9xx(uint32_t index)
-{
-	return XLP9XX_DRNG_DATA(index);
-}
-
-static int nlm_drng_init(struct hwrng *rng)
-{
-	uint64_t errors, cfg;
-	struct xlp_rng_data_priv *priv =
-		container_of(rng, struct xlp_rng_data_priv, drng);
-
-	/* if already enabled then exit */
-	cfg = drng_read_reg(priv, priv->drng_cfg);
-	if (cfg & (1 << XLP_DRNG_CFG_ENABLE))
-		return 0;
-
-	/* Reset the device */
-	cfg = drng_read_reg(priv, priv->drng_cfg);
-	drng_write_reg(priv, priv->drng_cfg, cfg & ~(1 << XLP_DRNG_CFG_RESET));
-	drng_write_reg(priv, priv->drng_cfg, cfg | (1 << XLP_DRNG_CFG_RESET));
-
-	/* min 2 cycles for h/w to settle down */
-	udelay(10);
-
-	/* Ask the generator to reseed after every request */
-	drng_write_reg(priv, priv->drng_reseed_time, 100);
-
-	errors = (cfg >> XLP_DRNG_CFG_ERR0) & 0x7; /* 3 err bits */
-
-	if (errors || global_raw_mode) {
-		pr_crit("RNG Health Not good: 0x%lx\n", (unsigned long)errors);
-		pr_info("Using DRNG in raw mode");
-		cfg |= (1 << XLP_DRNG_CFG_RAWMODE);
-	}
-	cfg |= (1 << XLP_DRNG_CFG_ENABLE);
-
-	/* Enable now */
-	drng_write_reg(priv, priv->drng_cfg, cfg);
-
-	return 0;
-}
-
-static void nlm_drng_cleanup(struct hwrng *rng)
-{
-	/* just disable the device */
-	struct xlp_rng_data_priv *priv =
-		container_of(rng, struct xlp_rng_data_priv, drng);
-	uint64_t cfg = drng_read_reg(priv, priv->drng_cfg);
-	cfg &= ~1;
-	drng_write_reg(priv, priv->drng_cfg, cfg);
-}
-
-static inline int nlm_drng_data_valid(struct xlp_rng_data_priv *priv)
-{
-	uint64_t cfg;
-	cfg = drng_read_reg(priv, priv->drng_cfg);
-	return (cfg >> XLP_DRNG_CFG_VALID) & 1;
-}
-
-static int nlm_drng_data_present(struct hwrng *rng, int wait)
-{
-	int i = 20;
-	struct xlp_rng_data_priv *priv =
-		container_of(rng, struct xlp_rng_data_priv, drng);
-
-	/* check the data vaild bit is set or not */
-	while (!nlm_drng_data_valid(priv)) {
-		/* delay of 2us as capacity is 2M 256-bit data per sec. */
-		if (wait)
-			udelay(2);
-		if (i--)
-			break;
-	}
-
-	return nlm_drng_data_valid(priv);
-}
-
-static int nlm_drng_read(struct hwrng *rng, void *buffer,
-				size_t size, bool wait)
-{
-	int i;
-	int count = 0;
-	uint64_t cfg;
-	struct xlp_rng_data_priv *priv =
-		container_of(rng, struct xlp_rng_data_priv, drng);
-
-	/* check if data is available or not */
-	if (!rng->data_present(rng, wait))
-		return 0;
-
-	/* From manual, 0-7 registers must be read in-order */
-	if (is_9xx) {
-		uint64_t *val = (uint64_t *)buffer;
-		for (i = 0; (i < priv->max_data) && (count < size); i++) {
-			*val++ = drng_read_reg(priv, priv->rng_data(i));
-			count += sizeof(*val);
-		}
-	} else {
-		uint32_t *val = (uint32_t *)buffer;
-		for (i = 0; (i < priv->max_data) && (count < size); i++) {
-			*val++ = drng_read_reg(priv, priv->rng_data(i));
-			count += sizeof(*val);
-		}
-	}
-
-	/* set the reseed bit */
-	cfg = drng_read_reg(priv, priv->drng_cfg);
-	drng_write_reg(priv, priv->drng_cfg, cfg | (1 << XLP_DRNG_CFG_RESEED));
-
-	return count;
-}
-
-static int __devinit nlm_drng_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-	struct xlp_rng_data_priv *priv;
-	struct resource *res;
-
-	priv = devm_kzalloc(&pdev->dev,
-		sizeof(struct xlp_rng_data_priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		pr_info("Couldn't get resource !!!\n");
-		return -ENOMEM;
-	}
-
-	*priv = cpu_is_xlp9xx() ? xlp_rng_data_list[1] : xlp_rng_data_list[0];
-	if (cpu_is_xlp9xx())
-		is_9xx = 1;
-	else
-		is_9xx = 0;
-
-	priv->rsa_regbase =
-		(unsigned long)devm_request_and_ioremap(&pdev->dev, res);
-	if (!priv->rsa_regbase) {
-		dev_err(&pdev->dev, "device io remap failed !!!\n");
-		return -ENOMEM;
-	}
-
-	priv->drng.priv = 0;
-	priv->drng.name = pdev->name;
-	priv->drng.init = nlm_drng_init;
-	priv->drng.cleanup = nlm_drng_cleanup;
-	priv->drng.data_present = nlm_drng_data_present;
-	priv->drng.read = nlm_drng_read;
-
-	ret = hwrng_register(&priv->drng);
-	if (ret) {
-		dev_err(&pdev->dev, "Failed to register RNG\n");
-		goto out;
-	}
-
-	platform_set_drvdata(pdev, priv);
-
-	/* Reset the device */
-	{
-		uint64_t cfg = drng_read_reg(priv, priv->drng_cfg);
-		drng_write_reg(priv,
-			priv->drng_cfg, cfg & ~(1 << XLP_DRNG_CFG_RESET));
-		drng_write_reg(priv,
-			priv->drng_cfg, cfg | (1 << XLP_DRNG_CFG_RESET));
-	}
-
-	dev_info(&pdev->dev, "Registered Nlm_Drng RNG\n");
-
-	return 0;
-out:
-	devm_kfree(&pdev->dev, priv);
-	return ret;
-
-}
-
-static int __devexit nlm_drng_remove(struct platform_device *pdev)
-{
-	struct xlp_rng_data_priv *priv = platform_get_drvdata(pdev);
-	devm_kfree(&pdev->dev, priv);
-	return 0;
-}
-
-static const struct of_device_id nlm_drng_match[] = {
-	{ .compatible = "netlogic,nlm-drng" },
-	{},
-};
-
-static struct platform_driver nlm_drng_driver = {
-	.probe		= nlm_drng_probe,
-	.remove		= __devexit_p(nlm_drng_remove),
-	.driver		= {
-		.name	= "nlm-drng",
-		.owner	= THIS_MODULE,
-		.of_match_table = nlm_drng_match,
-	},
-};
-
-module_platform_driver(nlm_drng_driver);
-
-MODULE_AUTHOR("Prem Mallappa <prem.mallappa@broadcom.com>");
-MODULE_AUTHOR("Subhendu Sekhar Behera <sbehera@broadcom.com>");
-MODULE_DESCRIPTION("Netlogic XLP Random Number Generator");
-MODULE_LICENSE("GPL");
diff --git a/drivers/char/hw_random/xlp-rng.c b/drivers/char/hw_random/xlp-rng.c
new file mode 100644
index 0000000..c78112d
--- /dev/null
+++ b/drivers/char/hw_random/xlp-rng.c
@@ -0,0 +1,303 @@
+/*
+ * Copyright (c) 2003-2014 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/hw_random.h>
+#include <linux/delay.h>
+
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+
+#define XLP_DRNG_BASE		0x5c
+#define XLP_DRNG_CFG		(XLP_DRNG_BASE + 0)
+#define XLP_DRNG_RESEED_TIME	(XLP_DRNG_BASE + 1)
+#define XLP_DRNG_PERSONAL_STR0	(XLP_DRNG_BASE + 2)
+#define XLP_DRNG_PERSONAL_STR1	(XLP_DRNG_BASE + 3)
+#define XLP_DRNG_DATA(n)	(XLP_DRNG_BASE + 0x4 + (n))
+#define XLP_DRNG_MAXDATA	8
+
+#define XLP9XX_DRNG_BASE		0x25
+#define XLP9XX_DRNG_CFG			((XLP9XX_DRNG_BASE + 0)*2)
+#define XLP9XX_DRNG_SWM			((XLP9XX_DRNG_BASE + 1)*2)
+#define XLP9XX_DRNG_RESEED_TIME		((XLP9XX_DRNG_BASE + 2)*2)
+#define XLP9XX_DRNG_PERSONAL_STR	((XLP9XX_DRNG_BASE + 3)*2)
+#define XLP9XX_DRNG_DATA(n)		((XLP9XX_DRNG_BASE + 0x4 + (n))*2)
+#define XLP9XX_DRNG_MAXDATA		4
+
+#define XLP_DRNG_RESEED_COUNT	100
+
+#define XLP_DRNG_CFG_ENABLE	BIT(0)
+#define XLP_DRNG_CFG_RAWMODE	BIT(1)
+#define XLP_DRNG_CFG_RESET	BIT(2)
+#define XLP_DRNG_CFG_RESEED	BIT(3)
+#define XLP_DRNG_CFG_BUSY	BIT(4)
+#define XLP_DRNG_CFG_VALID	BIT(5)
+#define XLP_DRNG_CFG_DRAW	BIT(6)
+#define XLP_DRNG_CFG_ERR0	BIT(7)
+#define XLP_DRNG_CFG_ERR1	BIT(8)
+#define XLP_DRNG_CFG_ERR2	BIT(9)
+
+/*
+ * xlp9xx & xlp5xx processor have 64-bit registers. Rest have 32-bit
+ */
+#define is_xlp9xx()		(cpu_is_xlp9xx() || cpu_is_xlp5xx())
+
+/* Raw mode bypasses the Deterministic logic */
+static unsigned int global_raw_mode;
+module_param(global_raw_mode, int, S_IRUGO);
+MODULE_PARM_DESC(global_raw_mode,
+		"Raw mode, bypass the deterministic generator (Default="
+		__MODULE_STRING(0) ")");
+
+/* Reseed time count*/
+static unsigned int reseed_count = XLP_DRNG_RESEED_COUNT;
+module_param(reseed_count, int, S_IRUGO);
+MODULE_PARM_DESC(reseed_count,
+		"Reseed time, No. of requests to reseed (Default="
+		__MODULE_STRING(0) ")");
+
+struct xlp_rng_data {
+	void __iomem *base;
+	struct hwrng drng;
+	struct device *dev;
+	u32 drng_cfg;
+};
+
+static inline void drng_write_reg(struct xlp_rng_data *priv, u32 reg, u64 val)
+{
+	u64 base = (u64)priv->base;
+
+	if (is_xlp9xx())
+		nlm_write_reg64(base, reg, val);
+	else
+		nlm_write_reg(base, reg, (u32)val);
+}
+
+static inline u64 drng_read_reg(struct xlp_rng_data *priv, u32 reg)
+{
+	u64 val;
+	u64 base = (u64)priv->base;
+
+	if (is_xlp9xx())
+		val = nlm_read_reg64(base, reg);
+	else
+		val = (u64)nlm_read_reg(base, reg);
+	return val;
+}
+
+static inline int xlp_drng_data_valid(struct xlp_rng_data *priv)
+{
+	u64 cfg = drng_read_reg(priv, priv->drng_cfg);
+
+	return cfg & XLP_DRNG_CFG_VALID;
+}
+
+static inline void xlp_drng_reset(struct xlp_rng_data *priv)
+{
+	u64 cfg = drng_read_reg(priv, priv->drng_cfg);
+
+	drng_write_reg(priv, priv->drng_cfg, cfg | XLP_DRNG_CFG_RESET);
+}
+
+static void xlp_drng_cleanup(struct hwrng *rng)
+{
+	u64 cfg;
+	struct xlp_rng_data *priv =
+		container_of(rng, struct xlp_rng_data, drng);
+
+	/* just disable the device */
+	cfg = drng_read_reg(priv, priv->drng_cfg) & ~(XLP_DRNG_CFG_ENABLE);
+	drng_write_reg(priv, priv->drng_cfg, cfg);
+}
+
+static int xlp_drng_data_present(struct hwrng *rng, int wait)
+{
+	int i = 20;
+	int val;
+	struct xlp_rng_data *priv =
+		container_of(rng, struct xlp_rng_data, drng);
+
+	val = xlp_drng_data_valid(priv);
+	if (!wait)
+		return val;
+
+	/* check the data vaild bit is set or not */
+	for (i = 0; i < 20 && !val; i++) {
+		/* delay of 2us as capacity is 2M 256-bit data per sec. */
+		udelay(2);
+		val = xlp_drng_data_valid(priv);
+	}
+	return val;
+}
+
+static int xlp_drng_read(struct hwrng *rng, void *buffer,
+	size_t size, bool wait)
+{
+	int i;
+	int count = 0;
+	struct xlp_rng_data *priv =
+		container_of(rng, struct xlp_rng_data, drng);
+
+	/* check if data is available or not */
+	if (!rng->data_present(rng, wait))
+		return 0;
+
+	/* From manual, 0-7 registers must be read in-order */
+	if (is_xlp9xx()) {
+		u64 *val = (u64 *)buffer;
+		for (i = 0; (i < XLP9XX_DRNG_MAXDATA) && (count < size); i++) {
+			*val++ = drng_read_reg(priv, XLP9XX_DRNG_DATA(i));
+			count += sizeof(*val);
+		}
+	} else {
+		u32 *val = (u32 *)buffer;
+		for (i = 0; (i < XLP_DRNG_MAXDATA) && (count < size); i++) {
+			*val++ = drng_read_reg(priv, XLP_DRNG_DATA(i));
+			count += sizeof(*val);
+		}
+	}
+	return count;
+}
+
+static int xlp_drng_init(struct hwrng *rng)
+{
+	u64 cfg;
+	struct xlp_rng_data *priv =
+		container_of(rng, struct xlp_rng_data, drng);
+
+	/* Reset the device */
+	xlp_drng_reset(priv);
+
+	/* min 2 cycles for h/w to settle down */
+	udelay(10);
+
+	/* Ask the generator to reseed after every request */
+	if (is_xlp9xx())
+		drng_write_reg(priv, XLP9XX_DRNG_RESEED_TIME, reseed_count);
+	else
+		drng_write_reg(priv, XLP_DRNG_RESEED_TIME, reseed_count);
+
+	cfg = drng_read_reg(priv, priv->drng_cfg);
+
+	if (cfg & (XLP_DRNG_CFG_ERR1 | XLP_DRNG_CFG_ERR2))
+		return -EINVAL;
+
+	if ((cfg & XLP_DRNG_CFG_ERR0) && global_raw_mode) {
+		cfg |= XLP_DRNG_CFG_RAWMODE;
+		dev_info(priv->dev, "Switching to RAW mode\n");
+	}
+
+	cfg |= XLP_DRNG_CFG_ENABLE;
+
+	/* Enable now */
+	drng_write_reg(priv, priv->drng_cfg, cfg);
+	return 0;
+}
+
+static int xlp_drng_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct xlp_rng_data *priv;
+	struct resource *res;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "Couldn't get mem resource!\n");
+		return -EINVAL;
+	}
+
+	priv->base = devm_request_and_ioremap(&pdev->dev, res);
+	if (!priv->base) {
+		dev_err(&pdev->dev, "device io remap failed !!!\n");
+		return -EIO;
+	}
+
+	priv->drng_cfg = is_xlp9xx() ? XLP9XX_DRNG_CFG : XLP_DRNG_CFG;
+
+	priv->drng.priv = 0;
+	priv->drng.name = pdev->name;
+	priv->drng.init = xlp_drng_init;
+	priv->drng.cleanup = xlp_drng_cleanup;
+	priv->drng.data_present = xlp_drng_data_present;
+	priv->drng.read = xlp_drng_read;
+	priv->dev = &pdev->dev;
+
+	ret = hwrng_register(&priv->drng);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register RNG\n");
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, priv);
+
+	dev_info(&pdev->dev, "Registered xlp_drng RNG\n");
+	return 0;
+}
+
+static int xlp_drng_remove(struct platform_device *pdev)
+{
+	struct xlp_rng_data *priv = platform_get_drvdata(pdev);
+
+	hwrng_unregister(&priv->drng);
+	return 0;
+}
+
+static const struct of_device_id xlp_drng_match[] = {
+	{ .compatible = "netlogic,xlp-drng" },
+	{},
+};
+
+static struct platform_driver xlp_drng_driver = {
+	.probe		= xlp_drng_probe,
+	.remove		= xlp_drng_remove,
+	.driver		= {
+		.name	= "xlp-drng",
+		.owner	= THIS_MODULE,
+		.of_match_table = xlp_drng_match,
+	},
+};
+
+module_platform_driver(xlp_drng_driver);
+
+MODULE_AUTHOR("Prem Mallappa <prem.mallappa@broadcom.com>");
+MODULE_AUTHOR("Subhendu Sekhar Behera <sbehera@broadcom.com>");
+MODULE_DESCRIPTION("Netlogic XLP Random Number Generator");
+MODULE_LICENSE("GPL");
-- 
1.9.1

