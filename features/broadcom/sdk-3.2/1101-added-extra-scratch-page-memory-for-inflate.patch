From dc2379defbf8fd76af84b38aa3fb8468dc6ed8b2 Mon Sep 17 00:00:00 2001
From: Alok Agrawat <aagrawat@netlogicmicro.com>
Date: Wed, 28 Dec 2011 17:07:34 +0530
Subject: [PATCH 1101/1532] added extra scratch page memory for inflate.

When inflate and deflate are working in parallel, the common scratch page
memory gets overwritten. Hence, adding extra page.

increased wait time for graceful exit
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/nlm_cde/nlm_cde.c | 175 ++++++++++++++++++++++----------
 drivers/misc/netlogic/nlm_cde/nlm_cde.h |  10 +-
 2 files changed, 130 insertions(+), 55 deletions(-)

diff --git a/drivers/misc/netlogic/nlm_cde/nlm_cde.c b/drivers/misc/netlogic/nlm_cde/nlm_cde.c
index 968f11f..aecfd3b 100644
--- a/drivers/misc/netlogic/nlm_cde/nlm_cde.c
+++ b/drivers/misc/netlogic/nlm_cde/nlm_cde.c
@@ -60,7 +60,16 @@ int xlp_cde_release(struct inode *, struct file *);
 int xlp_cde_ioctl(struct inode *inode, struct file *fptr, unsigned int type, unsigned long val);
 ssize_t xlp_cde_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);
 ssize_t xlp_cde_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);
+static int xlp_cde_mmap(struct file * filp, struct vm_area_struct * vma);
+static unsigned char* cde_mem_start, *cde_input_mem, *cde_output_mem, *cde_inf_input_mem, *cde_inf_output_mem, *cde_inf_mem_start;
+static unsigned int cde_mem_size;
 
+struct nlm_cde_op
+{
+  unsigned int compression_type;
+  unsigned int sof;
+  unsigned int eof;
+};
 typedef struct free_page_structure {
 	  char *data_array;
 } fr_page;
@@ -69,8 +78,8 @@ volatile msg cmp_msg[MAX_NUM_MESSAGES]    __attribute__((aligned(32)));
 volatile fr_page page_array[MAX_NUM_PAGES]    __attribute__((aligned(32)));
 volatile char *(page_array_tmp_data_array[MAX_NUM_PAGES])__attribute__((aligned(32)));
 
-//#define CDE_DEBUG 0
-#ifdef CDE_DEBUG
+//#define CDE_DEBUG 1
+//#ifdef CDE_DEBUG
 static void dump_buffer(unsigned char *buf, unsigned int len, unsigned char *msg)
 {
     int k = 0;
@@ -83,7 +92,7 @@ static void dump_buffer(unsigned char *buf, unsigned int len, unsigned char *msg
     }
     printk("\n");
 }
-#endif
+//#endif
 
 static void *
 get_cache_aligned_mem(size_t size)
@@ -144,6 +153,7 @@ static const struct file_operations xlp_cde_fops = {
     .read = xlp_cde_read,
     .write = xlp_cde_write,
     .ioctl = xlp_cde_ioctl,
+    .mmap = xlp_cde_mmap,
     .release = xlp_cde_release,
 };
 
@@ -175,6 +185,7 @@ static int send_message(int stid, struct msgrng_msg *msg)
 {
   int ret = 0;
 
+	//printk("send_message = stid = %x msg = %llx\n",stid, msg->msg0);
 #ifdef CDE_DEBUG
 	printk("send_message = stid = %x msg = %llx\n",stid, msg->msg0);
 #endif
@@ -267,31 +278,31 @@ int create_inf_message(cmp_data_t *cmp_data, int type, int start_of_file, int en
     //create scratch page descriptor
     cur_desc = 0;
     restore = (start_of_file == 0);//((num_messages > 1) & (cur_blk != 0));
-    length = SCRATCH_SIZE;
-
+    length = SCRATCH_SIZE ;
     cmp_data->src_desc[desc_idx] =
-      cpu_to_be64(nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (unsigned long)virt_to_phys(cmp_data->scratch)));
-
+      cpu_to_be64(nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (unsigned long)virt_to_phys(cmp_data->scratch_inf)));
 #ifdef CDE_DEBUG
       printk("scratch=0x%p, v2p=0x%lx, scratch_desc = 0x%016llx &scratch_desc=0x%p\n", 
-	     cmp_data->scratch, virt_to_phys(cmp_data->scratch), cmp_data->src_desc[desc_idx], &(cmp_data->src_desc[0])); 
+	     cmp_data->scratch_inf, virt_to_phys(cmp_data->scratch_inf), cmp_data->src_desc[desc_idx], &(cmp_data->src_desc[0])); 
 #endif
     cur_desc++;
 
     for (j = 0; j < num_blk/num_messages; j++) {
       for (k = 0; k < num_desc; k++) {
 	eof = 1;//end_of_file;
+//	eof = end_of_file;
 
 	sod = 1;//(start == 0);
 	sob = (k == 0);
 	eob = (k == num_desc-1);
 	save = ((eob == 1) & (end_of_file == 0)); //((eof == 0) & (eob == 1));
 	restore = 0; //restore only can be 1 on scratch descriptor
-
+//save = 0;
 	length = ((cmp_data->src_size - start)> PAGE_SIZE)?PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
 
 	cmp_data->src_desc[cur_desc] =
 	  cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (unsigned long)virt_to_phys(cmp_data->src + start)));
+//printk("data_desc_1 = %llx\n",cmp_data->src_desc[cur_desc]);
 
 #ifdef CDE_DEBUG
 	  printk("[%s@%d]: eof=%d, sod=%d, sob=%d, eob=%d, save=%d, restore=0, length=%d\n",
@@ -311,6 +322,7 @@ int create_inf_message(cmp_data_t *cmp_data, int type, int start_of_file, int en
 
     stid = nlm_hal_cde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0, 0, cmp_data->op, rtn_bkt,
 			cur_desc, (unsigned long)virt_to_phys(cmp_data->src_desc + desc_idx));
+//printk("cmp_msg = %llx\n", cmp_msg[i].msg0);
 #ifdef CDE_DEBUG
       printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx\n", __FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0); 
 #endif
@@ -360,7 +372,8 @@ int create_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of
     //create scratch page descriptor
     cur_desc = 0;
     restore = (start_of_file == 0);//((num_messages > 1) & (cur_blk != 0));
-    length = SCRATCH_SIZE;
+//restore = 0;
+    length = SCRATCH_SIZE ;
 
     cmp_data->src_desc[desc_idx] =
       cpu_to_be64(nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (unsigned long)virt_to_phys(cmp_data->scratch)));
@@ -382,9 +395,7 @@ int create_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of
 	save = ((type == CDE_STATIC) & (eof == 0) & (eob == 1));
 	restore = 0; //restore only can be 1 on scratch descriptor
 
-	//	length = (cmp_data->src_size - start) / div;
 	length = ((cmp_data->src_size - start)> PAGE_SIZE)?PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
-
 	cmp_data->src_desc[cur_desc] =
 	  cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (unsigned long)virt_to_phys(cmp_data->src + start)));
 
@@ -478,7 +489,6 @@ static int nlm_hal_cde_read_cmp_msg(char *buffer, uint64_t payload)
   int num_desc = (payload >> 40) & 0x3fff;
   char * tmp_ptr;
 
-
   for (i = 0; i < num_desc; i++) {
     desc = phys_to_virt(payload & 0xffffffffffUll) + i*8; //64 byte descriptors //dliao: why i*8??
 
@@ -540,7 +550,7 @@ nlm_xlp_cde_msgring_handler(uint32_t vc, uint32_t src_id,
 
 cmp_data_t* nlm_cde_init()
 {
-
+  unsigned int size;
   cmp_data = (cmp_data_t *) kmalloc(sizeof(cmp_data_t), GFP_KERNEL);
   if (!cmp_data)
     return NULL;
@@ -570,7 +580,8 @@ cmp_data_t* nlm_cde_init()
 	  return NULL;
   }
   cmp_data->scratch = kmalloc(sizeof(unsigned long long) * SCRATCH_SIZE , GFP_KERNEL);
-  if (! cmp_data->scratch)	{
+  cmp_data->scratch_inf = kmalloc(sizeof(unsigned long long) * SCRATCH_SIZE , GFP_KERNEL);
+  if (! cmp_data->scratch || !cmp_data->scratch_inf)	{
 	  printk("kmalloc returns Error : cmp_data->scratch\n");
 	  kfree(cmp_data->src);
 	  kfree(cmp_data->target);
@@ -578,10 +589,26 @@ cmp_data_t* nlm_cde_init()
 	  kfree(cmp_data);
 	  return NULL;
   }
+
+  size = sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int) + MAX_BUFFER_SIZE * 2;/*struct cde + input size + output size + input buf + output buf */
+  cde_mem_start = kmalloc(size * 2, GFP_KERNEL);
+  cde_mem_size = size * 2;
+  if (!cde_mem_start)	
+	 printk("kmalloc returns Error : cde_mem_start\n");
+ 
+  cde_input_mem = cde_mem_start + sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int);
+  cde_output_mem = cde_input_mem + MAX_BUFFER_SIZE;
+
+  cde_inf_mem_start = cde_output_mem + MAX_BUFFER_SIZE;
+  cde_inf_input_mem = cde_inf_mem_start + sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int);
+  cde_inf_output_mem = cde_inf_input_mem + MAX_BUFFER_SIZE;
+
+  memset(cde_mem_start, 0, size); 
   memset(cmp_data->src, 0, MAX_BUFFER_SIZE);
   memset(cmp_data->target, 0, MAX_BUFFER_SIZE);
   memset(cmp_data->src_desc, 0, sizeof(unsigned long long) * CMP_PAGE_SIZE);
-  memset(cmp_data->scratch, 0, sizeof(unsigned long long) * SCRATCH_SIZE);
+  memset(cmp_data->scratch, 0, sizeof(unsigned long long) *SCRATCH_SIZE);
+  memset(cmp_data->scratch_inf, 0, sizeof(unsigned long long) *SCRATCH_SIZE);
 
   if (config_cmp() == -1)
 	return NULL;
@@ -598,7 +625,6 @@ int xlp_cde_open(struct inode *inode, struct file *filp)
 	printk("xlp_cde_open \n");
 #endif
 
-  nlm_cde_init();
   return 0;
 }
 
@@ -615,12 +641,15 @@ void nlm_cde_cleanup(cmp_data_t *cmp_data)
 	  kfree(cmp_data->src_desc);
   if (cmp_data->scratch)  
 	  kfree(cmp_data->scratch);
+  if (cmp_data->scratch_inf)  
+	  kfree(cmp_data->scratch_inf);
   if (cmp_data)
     kfree(cmp_data);
     cmp_data->src = NULL;
     cmp_data->target = NULL;
     cmp_data->src_desc = NULL; 
     cmp_data->scratch = NULL;
+    cmp_data->scratch_inf = NULL;
     cmp_data = NULL;
 
   for (i = 0; i < NUM_FREE_DESCRIPTORS; i++) {
@@ -631,32 +660,64 @@ void nlm_cde_cleanup(cmp_data_t *cmp_data)
   }
 }
 
+
+static int xlp_cde_mmap(struct file * filp, struct vm_area_struct * vma)
+{
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	unsigned long size = 0;
+	int result = 0;
+	unsigned long cde_pfn_addr = 0;
+	if (cde_mem_size <= 0) return -ENXIO;
+
+	if (offset >= cde_mem_size) return -ESPIPE;
+
+	if (vma->vm_flags & VM_LOCKED) return -EPERM;
+
+	size = vma->vm_end - vma->vm_start;
+	pgprot_val (vma->vm_page_prot) &= ~_CACHE_MASK;
+	pgprot_val (vma->vm_page_prot) |= _CACHE_CACHABLE_COW;
+
+	cde_pfn_addr = ((uint64_t)cde_mem_start >> PAGE_SHIFT);
+	result = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, size, 
+								vma->vm_page_prot);
+	if (result) return -EAGAIN;
+
+	return 0;
+}
+
 int xlp_cde_release(struct inode *inode, struct file *filp)
 { 
-  nlm_cde_cleanup(cmp_data);
+  cmp_data->target_size = 0;
+  cmp_data->offset = 0;
+  memset(cmp_data->scratch, 0,  sizeof(unsigned long long) *SCRATCH_SIZE);
+  memset(cmp_data->scratch_inf, 0, sizeof(unsigned long long) *SCRATCH_SIZE);
   return 0;
 }
 
 unsigned int nlm_cde_receive_response(cmp_data_t *cmp_data, unsigned char *buf, unsigned int count)
 {
   int size = 0;
-
   if(cmp_data->target_size)
   {
-	size = count < cmp_data->target_size ? count : cmp_data->target_size;
+	size = (count < cmp_data->target_size) ? count : cmp_data->target_size;
 
-	memcpy(buf, cmp_data->target, size);
+	memcpy(buf, &cmp_data->target[cmp_data->offset], size);
 #ifdef CDE_DEBUG
 	printk("xlp_cde_read cmp_data->target_size = %d size = %d\n",cmp_data->target_size, size);
 	dump_buffer(cmp_data->target, size, "Output:");
-	//printk("Read: cmp_data->target = %s size = %d\n", cmp_data->target, size);
 #endif
+	cmp_data->offset += size;
 	cmp_data->target_size = cmp_data->target_size - size;
+	if(cmp_data->target_size == 0)
+		cmp_data->offset = 0;
 
 	return size;
   }
   else
+  {
+	cmp_data->offset = 0;
 	return 0;
+  }
 }
 
 ssize_t xlp_cde_read(struct file *filp, char __user *buf,
@@ -664,11 +725,14 @@ ssize_t xlp_cde_read(struct file *filp, char __user *buf,
 {
 	unsigned char temp_buf[count+1];
 	int size;
-	size = nlm_cde_receive_response(cmp_data, (unsigned char*)&temp_buf, count);
-	if (copy_to_user(buf, &temp_buf, size)) {
+	size = nlm_cde_receive_response(cmp_data, (unsigned char*)temp_buf, count);
+	if(count >= size)
+	{
+		if (copy_to_user(buf, temp_buf, size)) {
                   printk("copy_to_user failed\n");
                   size = -EFAULT;
-        }
+        	}
+	}
 	return size;
 }
 
@@ -715,39 +779,22 @@ ssize_t xlp_cde_write(struct file *filp, const char __user *buf,
 		size_t count, loff_t *f_pos)
 {
   unsigned char temp_buf[count+1];
-  if (copy_from_user(&temp_buf, buf, count)) {
+  if (copy_from_user(temp_buf, buf, count)) {
         printk("copy from user failed \n");
           return -EFAULT;
   }
 
-  return nlm_cde_send_request(cmp_data, cmp_data->op, cmp_data->compression_type, cmp_data->sof, cmp_data->eof, (unsigned char*)&temp_buf, count);
+  return nlm_cde_send_request(cmp_data, cmp_data->op, cmp_data->compression_type, cmp_data->sof, cmp_data->eof, (unsigned char*)temp_buf, count);
 }
 
-struct nlm_cde_op
-{
-  unsigned int compression_type;
-  unsigned int sof;
-  unsigned int eof;
-};
 
 int xlp_cde_ioctl(struct inode *inode, struct file *filp,
 	      unsigned int cmd, unsigned long arg)
 {
-  int err = 0;
-  struct nlm_cde_op cde;
- 
-  if (copy_from_user(&cde, (unsigned char*)arg, sizeof(struct nlm_cde_op))) 
-  {
-        printk("copy from user failed \n");
-          return -EFAULT;
-  }
-
-#ifdef CDE_DEBUG
-  printk("cde.compression_type = %d cde.sof = %d, cde.eof = %d\n",cde.compression_type, cde.sof, cde.eof);
-#endif
-  cmp_data->compression_type = cde.compression_type;
-  cmp_data->sof = cde.sof;
-  cmp_data->eof = cde.eof;
+  int err = 0, i = 0;
+  struct nlm_cde_op *cde;
+  unsigned int input_size = 0, output_size = 0, size;
+  unsigned char *input_mem, *output_mem, *mem_start;
 
 #ifdef CDE_DEBUG
   printk("xlp_cde_ioctl: cmd = %d\n", cmd);
@@ -756,10 +803,16 @@ int xlp_cde_ioctl(struct inode *inode, struct file *filp,
 
   case CDE_INFLATE:
     cmp_data->op = 0;
+    input_mem = cde_inf_input_mem;
+    output_mem = cde_inf_output_mem;
+    mem_start = cde_inf_mem_start;
     break;
 
   case CDE_DEFLATE:
     cmp_data->op = 1;
+    input_mem = cde_input_mem;
+    output_mem = cde_output_mem;
+    mem_start = cde_mem_start;
     break;
 
   default:
@@ -767,12 +820,28 @@ int xlp_cde_ioctl(struct inode *inode, struct file *filp,
     return -ENOTTY;
   }
 
+  cde = (struct nlm_cde_op*)mem_start;
+  input_size = *(unsigned int*)(mem_start + sizeof(struct nlm_cde_op));
+  output_size = *(unsigned int*)(mem_start + sizeof(struct nlm_cde_op) + sizeof(unsigned int));
+#ifdef CDE_DEBUG
+  printk("cde.compression_type = %d cde.sof = %d, cde.eof = %d\n",cde->compression_type, cde->sof, cde->eof, input_size, output_size);
+#endif
+  cmp_data->compression_type = cde->compression_type;
+  cmp_data->sof = cde->sof;
+  cmp_data->eof = cde->eof;
+  size = nlm_cde_send_request(cmp_data, cmp_data->op, cmp_data->compression_type, cmp_data->sof, cmp_data->eof, (unsigned char*)input_mem, input_size);
+//printk("written %d byte of data\n", size);
+  size = 0;
+  do{
+    size = nlm_cde_receive_response(cmp_data, (unsigned char*)output_mem, output_size);
+    i++;
+  }while(size == 0 && i < 0xffffff); 
+  *(unsigned int*)(mem_start + sizeof(struct nlm_cde_op) + sizeof(unsigned int)) = size;
+//printk("Read %d byte of data\n", size);
+
   return err;
 }
 
-/* ##################################
-   ##################################*/
-
 
 static int __init xlp_cde_init(void)
 {
@@ -812,6 +881,8 @@ static int __init xlp_cde_init(void)
     nlm_hal_write_cde_reg(CMP_REG_RESET_REG(i), 0x01);
     nlm_hal_write_cde_reg(CMP_REG_RESET_REG(i), 0x00);
   }  
+  /*TEMP*/
+  nlm_cde_init();
 }
 
     return 0;
@@ -819,6 +890,8 @@ static int __init xlp_cde_init(void)
 
 static void __exit xlp_cde_cleanup(void)
 {
+  /*TEMP*/
+    nlm_cde_cleanup(cmp_data);
     unregister_chrdev(xlp_cde_major, "NLM_XLP_CDE");
 }
 
diff --git a/drivers/misc/netlogic/nlm_cde/nlm_cde.h b/drivers/misc/netlogic/nlm_cde/nlm_cde.h
index 8d7488f..3cec0e2 100644
--- a/drivers/misc/netlogic/nlm_cde/nlm_cde.h
+++ b/drivers/misc/netlogic/nlm_cde/nlm_cde.h
@@ -44,13 +44,13 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define MSGRNG_STNID_CMP0 XLP_STNID_CMP
 #define MSGRNG_STNID_CMP1 (XLP_STNID_CMP + 4)
 
-#define RTN_BKT 2
+#define RTN_BKT 1
 #define FD_BURST_SIZE 1
 #define NUM_FREE_DESCRIPTORS 100 //must be less or equal to MAX_NUM_PAGES
 #define MAX_NUM_PAGES 100
-#define MAX_BUFFER_SIZE 1024*16
-#define CMP_PAGE_SIZE   1024
-#define SCRATCH_SIZE    1024
+#define MAX_BUFFER_SIZE 1024*64
+#define CMP_PAGE_SIZE   2048//1024
+#define SCRATCH_SIZE    (1024)
 #define MAX_NUM_MESSAGES 20
 
 
@@ -59,6 +59,7 @@ typedef struct cmp_data_structure {
   char *target; // inflated or deflated result
   unsigned long long *src_desc;  // source descriptors
   unsigned long long *scratch;    // scratch page
+  unsigned long long *scratch_inf;    // scratch page
   unsigned long long src_size;    //size of source data
   unsigned long long target_size; // size of result
   unsigned long long num_desc;    // number of source descriptors including scratch desc
@@ -66,6 +67,7 @@ typedef struct cmp_data_structure {
   unsigned int compression_type;
   unsigned int sof;
   unsigned int eof;
+  unsigned int offset;
 } cmp_data_t;
 
 typedef enum {
-- 
1.9.1

