From 5f536445af487670643396996411723de0542cea Mon Sep 17 00:00:00 2001
From: Tanmay Jagdale <tanmayj@broadcom.com>
Date: Mon, 4 Aug 2014 18:31:52 +0530
Subject: [PATCH 1237/1532] fdtconf: fixes

- Fixed the compilation warnings.
- Ucode buffer is allocated through malloc rather than using
  an array of 1024.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/fdtconf/fdtconf.c | 104 ++++++++++++++++++++++++--------
 1 file changed, 80 insertions(+), 24 deletions(-)

diff --git a/drivers/misc/netlogic/fdtconf/fdtconf.c b/drivers/misc/netlogic/fdtconf/fdtconf.c
index 326b6f5..3f1310a 100644
--- a/drivers/misc/netlogic/fdtconf/fdtconf.c
+++ b/drivers/misc/netlogic/fdtconf/fdtconf.c
@@ -53,6 +53,12 @@
 #define	UCORE_1		"/soc/net@node-0/nae-1/ucore/src@1"
 #define	UCORE		"/soc/nae@node-0/ucore/src@1"
 
+/*
+ * Max no of instructions x size of an instruction
+ *	1024	x	4
+ */
+#define	UCODE_SZ	(1024 * 4)
+
 void *fdt;
 EXPORT_SYMBOL(fdt);
 extern void *initial_boot_params;
@@ -70,7 +76,8 @@ extern unsigned long frin_fifo_size;
 #define CPUMASK_WORDS	((NR_CPUS + 31) / 32)
 static void parse_and_fill_kern_params(void)
 {
-	uint32_t	mask[CPUMASK_WORDS] = {0}, *prop;
+	uint32_t	mask[CPUMASK_WORDS] = {0}, frin[5];
+	const uint32_t	*prop;
 	int		err, node, i, pcpu, word, bit, plen;
 
 	node = fdt_path_offset(fdt, "/kernel-params");
@@ -111,6 +118,9 @@ static void parse_and_fill_kern_params(void)
 	 * free-in fifos.
 	 */
 	if (is_nlm_xlp9xx()) {
+		/*
+		 * Setup Freein Fifo memory address for NAE-0.
+		 */
 		node = fdt_path_offset(fdt, "/doms/dom@1/nae-0");
 		if (node < 0)
 			return;
@@ -120,14 +130,25 @@ static void parse_and_fill_kern_params(void)
 		if (prop == NULL)
 			return;
 
+		/* Node */
+		frin[0] = prop[0];
+
 		/* Freein Fifo start address */
-		prop[1] = (frin_fifo_address >> 32) & 0xffffffff;
-		prop[2] = frin_fifo_address & 0xffffffff;
+		frin[1] = (frin_fifo_address >> 32) & 0xffffffff;
+		frin[2] = frin_fifo_address & 0xffffffff;
 
 		/* Freein Fifo size */
-		prop[3] = ((frin_fifo_size / 2) >> 32) & 0xffffffff;
-		prop[4] = (frin_fifo_size / 2) & 0xffffffff;
+		frin[3] = ((frin_fifo_size / 2) >> 32) & 0xffffffff;
+		frin[4] = (frin_fifo_size / 2) & 0xffffffff;
+
+		if (fdt_setprop(fdt, node, "freein-fifo-replenish-addr-info",
+				frin, sizeof(frin)))
+			dev_err(&fdtdev->dev, "Could not set "
+				"freein-fifo-replenish-addr-info\n");
 
+		/*
+		 * Setup Freein Fifo memory address for NAE-1.
+		 */
 		node = fdt_path_offset(fdt, "/doms/dom@1/nae-1");
 		if (node < 0)
 			return;
@@ -137,15 +158,27 @@ static void parse_and_fill_kern_params(void)
 		if (prop == NULL)
 			return;
 
+		/*
+		 * Provide the next half of allocated memory for NAE-1.
+		 */
 		frin_fifo_size -= (frin_fifo_size / 2);
 		frin_fifo_address += frin_fifo_size;
+
+		/* Node */
+		frin[0] = prop[0];
+
 		/* Freein Fifo start address */
-		prop[1] = (frin_fifo_address >> 32) & 0xffffffff;
-		prop[2] = frin_fifo_address & 0xffffffff;
+		frin[1] = (frin_fifo_address >> 32) & 0xffffffff;
+		frin[2] = frin_fifo_address & 0xffffffff;
 
 		/* Freein Fifo size */
-		prop[3] = (frin_fifo_size >> 32) & 0xffffffff;/* High 32-bits */
-		prop[4] = frin_fifo_size & 0xffffffff;	/* Low 32-bits */
+		frin[3] = (frin_fifo_size >> 32) & 0xffffffff;/* High 32-bits */
+		frin[4] = frin_fifo_size & 0xffffffff;	/* Low 32-bits */
+
+		if (fdt_setprop(fdt, node, "freein-fifo-replenish-addr-info",
+				frin, sizeof(frin)))
+			dev_err(&fdtdev->dev, "Could not set "
+				"freein-fifo-replenish-addr-info\n");
 
 		return;
 	}
@@ -162,13 +195,21 @@ static void parse_and_fill_kern_params(void)
 	if (prop == NULL)
 		return;
 
+	/* Node */
+	frin[0] = prop[0];
+
 	/* Freein Fifo start address */
-	prop[1] = (frin_fifo_address >> 32) & 0xffffffff; /* High 32-bits */
-	prop[2] = frin_fifo_address & 0xffffffff;	/* Low 32-bits */
+	frin[1] = (frin_fifo_address >> 32) & 0xffffffff; /* High 32-bits */
+	frin[2] = frin_fifo_address & 0xffffffff;	/* Low 32-bits */
 
 	/* Freein Fifo size */
-	prop[3] = (frin_fifo_size >> 32) & 0xffffffff;	/* High 32-bits */
-	prop[4] = frin_fifo_size & 0xffffffff;		/* Low 32-bits */
+	frin[3] = (frin_fifo_size >> 32) & 0xffffffff;	/* High 32-bits */
+	frin[4] = frin_fifo_size & 0xffffffff;		/* Low 32-bits */
+
+	if (fdt_setprop(fdt, node, "freein-fifo-replenish-addr-info",
+			frin, sizeof(frin)))
+		dev_err(&fdtdev->dev, "Could not set "
+			"freein-fifo-replenish-addr-info\n");
 }
 
 /*
@@ -177,8 +218,10 @@ static void parse_and_fill_kern_params(void)
 static int handle_opcodes(int node, char *file)
 {
 	const struct firmware	*fw;
-	char		*next, *ucode, *end_of_code;
-	uint32_t	ucode_buf[1024], ncodes, *umask;
+	char		*next;
+	uint32_t	*ucode_buf, ncodes, umask;
+	const uint32_t	*prop;
+	const char	*ucode, *end_of_ucode;
 	int		err;
 	/*
 	 * 1. Open the file through request_firmware().
@@ -190,14 +233,21 @@ static int handle_opcodes(int node, char *file)
 	if (request_firmware(&fw, file, &fdtdev->dev))
 		return -ENOENT;
 
+	ucode_buf = (uint32_t *)kmalloc(UCODE_SZ, GFP_KERNEL);
+	if (ucode_buf == NULL) {
+		dev_err(&fdtdev->dev, "kmalloc failed for %dbytes\n", UCODE_SZ);
+		err = -ENOMEM;
+		goto out;
+	}
+
 	/*
 	 * Loop from beginning of code upto end of code file.
 	 * Opcodes are stored as hex values followed by space (' ').
 	 */
 	ncodes = 0;
 	ucode = fw->data;
-	end_of_code = ucode + fw->size;
-	while (ucode < end_of_code) {
+	end_of_ucode = ucode + fw->size;
+	while (ucode < end_of_ucode) {
 		if (isspace(*ucode)) {
 			ucode++;
 			continue;
@@ -209,21 +259,27 @@ static int handle_opcodes(int node, char *file)
 
 	err = fdt_setprop(fdt, node, "num-opcodes", &ncodes, sizeof(ncodes));
 	if (err)
-		goto out;
+		goto free;
 
-	err = fdt_setprop(fdt, node, "opcodes", &ucode_buf,
+	err = fdt_setprop(fdt, node, "opcodes", ucode_buf,
 			(ncodes * sizeof(ncodes)));
 	if (err)
-		goto out;
+		goto free;
 
 	/* Fix/check ucore mask based on board type */
-	umask = fdt_getprop(fdt, node, "mask", &ncodes);
-	if (umask == NULL)
-		goto out;
+	prop = fdt_getprop(fdt, node, "mask", &ncodes);
+	if (prop == NULL)
+		goto free;
 
+	umask = prop[0];
 	if (is_nlm_xlp3xx() || is_nlm_xlp2xx())
-		*umask &= 0xff;
+		umask &= 0xff;
+
+	if (fdt_setprop(fdt, node, "mask", &umask, sizeof(umask)))
+		dev_err(&fdtdev->dev, "Could not set ucore mask");
 
+free:
+	kfree(ucode_buf);
 out:
 	release_firmware(fw);
 	return err;
-- 
1.9.1

