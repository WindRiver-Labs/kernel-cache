From 842df86ffac28e372a3210ad5c6799998260f180 Mon Sep 17 00:00:00 2001
From: ajesh <ajesh@broadcom.com>
Date: Mon, 7 Jul 2014 16:43:05 +0530
Subject: [PATCH 0153/1532] XLP5xx: PCIe EP support.

Conflicts:
	arch/mips/netlogic/xlp/pci-hot-reset.c
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/include/asm/netlogic/xlp-hal/pcibus.h |   1 +
 arch/mips/netlogic/xlp/pci-hot-reset.c          | 159 ++++++++++++++++++------
 2 files changed, 121 insertions(+), 39 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/xlp-hal/pcibus.h b/arch/mips/include/asm/netlogic/xlp-hal/pcibus.h
index 27cc50e..566af58 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/pcibus.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/pcibus.h
@@ -79,6 +79,7 @@
 #define PCIE_9XX_MSIX_STATUSX(n)	(n + 0x286)
 #define PCIE_9XX_MSIX_VEC		0x296
 #define PCIE_9XX_MSIX_VECX(n)		(n + 0x296)
+#define PCIE_9XX_LTSSM_STATE        0x396
 #define PCIE_9XX_INT_STATUS0		0x397
 #define PCIE_9XX_INT_STATUS1		0x398
 #define PCIE_9XX_INT_EN0		0x399
diff --git a/arch/mips/netlogic/xlp/pci-hot-reset.c b/arch/mips/netlogic/xlp/pci-hot-reset.c
index 69e289c..97e3733 100644
--- a/arch/mips/netlogic/xlp/pci-hot-reset.c
+++ b/arch/mips/netlogic/xlp/pci-hot-reset.c
@@ -52,7 +52,7 @@
 #include <asm/netlogic/xlp-hal/pcibus.h>
 #include <asm/netlogic/xlp-hal/bridge.h>
 
-static void modify_def_value(void)
+static void xlp2xx_modify_def_value(void)
 {
 	uint64_t sysbase = nlm_get_sys_regbase(0);
 	uint32_t sysreg = nlm_read_sys_reg(sysbase, SYS_POWER_ON_RESET_CFG);
@@ -86,34 +86,82 @@ static void modify_def_value(void)
 	nlm_write_pci_reg(pciebase, 0x240, (pcicontrol & ~(1 << 21)));
 }
 
+static void xlp5xx_modify_def_value(void)
+{
+	uint64_t sysbase = nlm_get_sys_regbase(0);
+	uint32_t sysreg = nlm_read_sys_reg(sysbase, SYS_9XX_POWER_ON_RESET_CFG);
+	uint32_t pcfg = (sysreg >> 15) & 0x3;
+	uint64_t pciebase = nlm_get_pcie_base(0, 0);
+	uint32_t pcicontrol, link;
+
+	switch (pcfg) {
+	case 0:
+	case 2:
+		link = nlm_read_pci_reg(pciebase, 0x1f);
+		nlm_write_pci_reg(pciebase, 0x1f, ((link & 0xfffffc0f) | 0x80));
+		break;
+	case 1:
+	case 3:
+		link = nlm_read_pci_reg(pciebase, 0x1f);
+		nlm_write_pci_reg(pciebase, 0x1f, ((link & 0xfffffc0f) | 0x40));
+		break;
+	default:
+		break;
+	}
+
+	nlm_write_pci_reg(pciebase, 0x61, 0x00000000);
+
+	pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
+	nlm_write_pci_reg(pciebase, 0x240, (pcicontrol | (1 << 21)));
+
+	pcicontrol = nlm_read_pci_reg(pciebase, 0x67);
+	nlm_write_pci_reg(pciebase, 0x67, ((pcicontrol & 0xf) | 0x3ff1));
+
+	pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
+	nlm_write_pci_reg(pciebase, 0x240, (pcicontrol & ~(1 << 21)));
+}
+
 static irqreturn_t xlp_pcie_hot_reset_handler(int irq, void *dev_id)
 {
 	uint64_t pciebase;
-	uint32_t pciint, pcicontrol, pcistate;
+	uint32_t pciint, pcicontrol, pcistate, pcilinkcap;
+	uint32_t ltssmreg, intstatreg, cntrlreg;
+
+	if (cpu_is_xlp2xx()) {
+		ltssmreg = PCIE_LTSSM_STATE;
+		intstatreg = PCIE_INT_STATUS1;
+		cntrlreg = 0x241;
+	} else if (cpu_is_xlp5xx()) {
+		ltssmreg = PCIE_9XX_LTSSM_STATE;
+		intstatreg = PCIE_9XX_INT_STATUS1;
+		cntrlreg = 0x243;
+	} else {
+		ltssmreg = 0;
+		intstatreg = 0;
+		cntrlreg = 0;
+		pr_err("Invalid PCIe Hot Reset \n");
+		return IRQ_HANDLED;
+	}
 
 	pr_err("Hot Reset Int Handler\n");
 	pciebase = nlm_get_pcie_base(0, 0);
 
-	pcistate = nlm_read_pci_reg(pciebase, PCIE_LTSSM_STATE);
+	pcistate = nlm_read_pci_reg(pciebase, ltssmreg);
 
 	if ((pcistate & 0xfc6000) == 0x446000) {
-		/* read the pci ltssm state again to comfirm the L0 state */
-		pcistate = nlm_read_pci_reg(pciebase, PCIE_LTSSM_STATE);
+		pcistate = nlm_read_pci_reg(pciebase, ltssmreg);
 		if ((pcistate & 0xfc6000) == 0x446000) {
-			pciint = nlm_read_pci_reg(pciebase, PCIE_INT_STATUS1);
+			pciint = nlm_read_pci_reg(pciebase, intstatreg);
 
 			if (pciint & 0x1) {
-				/* clear the interrupt */
-				nlm_write_pci_reg(pciebase, PCIE_INT_STATUS1,
-						  0x1);
+				nlm_write_pci_reg(pciebase, intstatreg, 0x1);
 			}
-			/* return without handling the interrupt as the link is already up */
 			pr_err("Link already up \n");
 			return IRQ_HANDLED;
 		}
 	}
 
-	pciint = nlm_read_pci_reg(pciebase, PCIE_INT_STATUS1);
+	pciint = nlm_read_pci_reg(pciebase, intstatreg);
 
 	if (pciint & 0x1) {
 		if (((nlm_read_pci_reg(pciebase, 0x1e)) & (0x1 << 21)) != 0) {
@@ -127,26 +175,33 @@ static irqreturn_t xlp_pcie_hot_reset_handler(int irq, void *dev_id)
 		nlm_write_pci_reg(pciebase, 0x240, (pcicontrol & ~(0x1 << 3)));
 
 		while (((nlm_read_pci_reg(pciebase, 0x1e)) & (0x1 << 21)) != 0) {
-			//udelay(200);
 		}
 		pr_err("Transaction Cleared\n");
 
 		pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
 		nlm_write_pci_reg(pciebase, 0x240, pcicontrol & ~(0x1));
 
-		pcicontrol = nlm_read_pci_reg(pciebase, 0x241);
-		nlm_write_pci_reg(pciebase, 0x241, pcicontrol | (0x1 << 17));
+		pcicontrol = nlm_read_pci_reg(pciebase, cntrlreg);
+		nlm_write_pci_reg(pciebase, cntrlreg, pcicontrol | (0x1 << 17));
 		udelay(1000);
 
-		nlm_write_pci_reg(pciebase, 0x241, pcicontrol & ~(0x1 << 17));
+		nlm_write_pci_reg(pciebase, cntrlreg,
+				  pcicontrol & ~(0x1 << 17));
 
 		pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
 		nlm_write_pci_reg(pciebase, 0x240, pcicontrol | (0x9));
 
-		pciint = nlm_read_pci_reg(pciebase, PCIE_INT_STATUS1);
-		nlm_write_pci_reg(pciebase, PCIE_INT_STATUS1, pciint | 0x1);
+		pciint = nlm_read_pci_reg(pciebase, intstatreg);
+		nlm_write_pci_reg(pciebase, intstatreg, pciint | 0x1);
 
-		modify_def_value();
+		if (cpu_is_xlp2xx()) {
+			xlp2xx_modify_def_value();
+		} else if (cpu_is_xlp5xx()) {
+			pcilinkcap = nlm_read_pci_reg(pciebase, 0x1f);
+			nlm_write_pci_reg(pciebase, 0x1f,
+					  (pcilinkcap & ~(0x3 << 10)));
+			xlp5xx_modify_def_value();
+		}
 
 		pr_info("Hot Reset Interrupt handled \n");
 	} else {
@@ -158,40 +213,66 @@ static irqreturn_t xlp_pcie_hot_reset_handler(int irq, void *dev_id)
 static int __init xlp_pci_hot_reset_init(void)
 {
 	uint64_t sysbase = nlm_get_sys_regbase(0);
-	uint32_t sysreg = nlm_read_sys_reg(sysbase, SYS_POWER_ON_RESET_CFG);
+	uint32_t sysreg;
 	uint64_t pciebase = nlm_get_pcie_base(0, 0);
 	uint64_t picbase, picreg;
 	uint32_t irq, pciintenable;
 
-	if (!cpu_is_xlp2xx()) {
+	if (!(cpu_is_xlp2xx() || cpu_is_xlp5xx())) {
 		pr_err("Hot Reset not handled\n");
 		return 0;
 	}
-	pr_info("Sysreg is 0x%x \n", sysreg);
-	if (((sysreg >> 8) & 0xf) & 0x1) {
-		pr_err("PCIE in RC Mode \n");
-		return 0;
-	}
-	pr_info("PCIE in EP mode 0x%x\n", sysreg);
-	pciintenable = nlm_read_pci_reg(pciebase, PCIE_INT_EN1);
-	pciintenable |= 0x1;
-	nlm_write_pci_reg(pciebase, PCIE_INT_EN1, pciintenable);
 
-	pciintenable = nlm_read_pci_reg(pciebase, PCIE_INT_EN1);
 	picbase = nlm_get_pic_pcibase(0);
-	/* enable the link interrupt */
-	picreg = nlm_read_pic_reg(picbase, PIC_IRT(PIC_IRT_PCIE_LINK_0_INDEX));
-	nlm_write_pic_reg(picbase, PIC_IRT(PIC_IRT_PCIE_LINK_0_INDEX),
-			  picreg | (1u << 31));
+
+	if (cpu_is_xlp2xx()) {
+		sysreg = nlm_read_sys_reg(sysbase, SYS_POWER_ON_RESET_CFG);
+
+		pr_info("XLP2xx Sysreg is 0x%x \n", sysreg);
+		if (((sysreg >> 8) & 0xf) & 0x1) {
+			pr_err("PCIE in RC Mode \n");
+			return 0;
+		}
+
+		pr_info("XLP2xx PCIE in EP mode 0x%x\n", sysreg);
+
+		pciintenable = nlm_read_pci_reg(pciebase, PCIE_INT_EN1);
+		pciintenable |= 0x1;
+		nlm_write_pci_reg(pciebase, PCIE_INT_EN1, pciintenable);
+		pciintenable = nlm_read_pci_reg(pciebase, PCIE_INT_EN1);
+
+		picreg = nlm_read_pic_reg(picbase,
+					  PIC_IRT(PIC_IRT_PCIE_LINK_0_INDEX));
+		nlm_write_pic_reg(picbase, PIC_IRT(PIC_IRT_PCIE_LINK_0_INDEX),
+				  picreg | (1u << 31));
+	} else if (cpu_is_xlp5xx()) {
+		sysreg = nlm_read_sys_reg(sysbase, SYS_9XX_POWER_ON_RESET_CFG);
+
+		pr_info("XLP5xx Sysreg is 0x%x \n", sysreg);
+		if (((sysreg >> 12) & 0x7) & 0x1) {
+			pr_err("PCIE in RC Mode \n");
+			return 0;
+		}
+
+		pr_info("XLP5xx PCIE in EP mode 0x%x\n", sysreg);
+
+		pciintenable = nlm_read_pci_reg(pciebase, PCIE_9XX_INT_EN1);
+		pciintenable |= 0x1;
+		nlm_write_pci_reg(pciebase, PCIE_9XX_INT_EN1, pciintenable);
+		pciintenable = nlm_read_pci_reg(pciebase, PCIE_9XX_INT_EN1);
+
+		picreg = nlm_read_pic_reg(picbase,
+					  PIC_9XX_IRT(PIC_9XX_IRT_PCIE_LINK_0_INDEX));
+		nlm_write_pic_reg(picbase,
+				  PIC_9XX_IRT(PIC_9XX_IRT_PCIE_LINK_0_INDEX),
+				  picreg | (1u << 22));
+	}
 
 	irq = PIC_PCIE_LINK_LEGACY_IRQ_BASE;
-	if (request_irq
-	    (irq, xlp_pcie_hot_reset_handler, 0, "PCIE_HOTRESET", NULL)) {
-		pr_info
-		    ("Could not register PCIe hot Reset interrupt handler \n");
+	if (request_irq(irq, xlp_pcie_hot_reset_handler, 0, "PCIE_HOTRESET", NULL)) {
+		pr_info("Could not register PCIe hot Reset interrupt handler \n");
 		return 0;
 	}
-	//pr_err("PCIE in Mode 2\n");
 	return 0;
 }
 
-- 
1.9.1

