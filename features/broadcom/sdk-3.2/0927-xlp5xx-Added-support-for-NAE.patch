From efbae1bfa2d2ff077e54eda8280da75ababbdbe3 Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikas.gupta@broadcom.com>
Date: Fri, 7 Feb 2014 17:16:43 +0530
Subject: [PATCH 0927/1532] xlp5xx: Added support for NAE.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../external/cortina_cs34x7/nlm_cortina_cs34x7.c   |  13 +-
 .../netlogic/lib/netlib/include/netsoc_common.h    |  34 +--
 arch/mips/netlogic/lib/netlib/include/netsoc_dev.h |  53 ++++-
 arch/mips/netlogic/lib/netlib/include/netsoc_nae.h |  42 ++--
 arch/mips/netlogic/lib/netlib/include/netsoc_poe.h |   2 +-
 arch/mips/netlogic/lib/netlib/src/netsoc_api.c     |  12 +-
 arch/mips/netlogic/lib/netlib/src/netsoc_config.c  |  20 +-
 arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c     |  20 +-
 arch/mips/netlogic/lib/netlib/src/netsoc_nae.c     |  51 ++--
 arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c     | 260 ++++++++++++++-------
 arch/mips/netlogic/lib/netlib/src/netsoc_poe.c     |  14 +-
 arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c    |   4 +-
 .../netlogic/lib/syslib/include/nlm_hal_xlp_dev.h  |   2 +
 .../netlogic/lib/syslib/src/nlm_hal_cpu_info.c     |   3 +-
 14 files changed, 349 insertions(+), 181 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7.c b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7.c
index 94a265f..a9b9436 100644
--- a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7.c
+++ b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7.c
@@ -166,7 +166,7 @@ void cortina_cs34x7_init(int cs, int num_lanes, int lane_rate)
 //INFO: Write 0xf280     to   MONZA_IM_SPAC dev 0 : 0x0009a (UNNAMED)
 //	**** MON2(Monza2) Driver loaded ****
 //	MON2 Driver - Lab Release.
-	 if(is_nlm_xlp9xx())
+	 if(IS_NLM_XLP9XX_FAMILY)
 	 {
 		 cortina_cs34x7_init_p1_9xx(cs,num_lanes,lane_rate);
 		 cortina_cs34x7_init_p2_9xx(cs,num_lanes,lane_rate);
@@ -354,7 +354,7 @@ int nlm_hal_init_cs34x7(int hwport,int num_lanes, int lane_rate, int nae_id)
 	int physport = 0;
 	nlm_print("nlm_hal_init_cs34x7 port %d lanes %d\n",hwport, num_lanes);
 
-	if (!is_nlm_xlp8xx() && !is_nlm_xlp9xx()) {
+	if (!is_nlm_xlp8xx() && !IS_NLM_XLP9XX_FAMILY) {
 		nlm_print("Interlaken is not supported\n");
 		return -1;
 	}
@@ -375,9 +375,12 @@ int nlm_hal_init_cs34x7(int hwport,int num_lanes, int lane_rate, int nae_id)
 	if(nae_id == 1)
 		hwport += 8;
 
-	if (!is_ilk_card_onslot(hwport/4)) {
-		nlm_print("No interlaken card on slot %d\n",hwport/4);
-		return -1;
+	if(!IS_NLM_XLP9XX_FAMILY)	
+	{	
+		if (!is_ilk_card_onslot(hwport/4)) {
+			nlm_print("No interlaken card on slot %d\n",hwport/4);
+			return -1;
+		}
 	}
 
 	switch(hwport) {
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
index 4834559..41a12986 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
@@ -178,7 +178,7 @@ extern struct netsoc_info *current_netsoc;
 
 static inline uint32_t __netsoc_get_features(void)
 {
-	if (is_nlm_xlp9xx()) {
+	if (IS_NLM_XLP9XX_FAMILY) {
 		return XLP9XX_NETSOC_FEATURES;
 	}
 	else if (is_nlm_xlp2xx()) {
@@ -218,7 +218,7 @@ static inline uint32_t __netsoc_get_max_poe(void)
 
 static inline uint32_t __netsoc_get_max_ale(void)
 {
-        if (is_nlm_xlp9xx()) {
+        if (IS_NLM_XLP9XX_FAMILY) {
                 return MAX_ALE_PERNODE;
         }
         else {
@@ -244,7 +244,7 @@ static inline uint32_t get_numfree_desc(uint32_t intf_type)
 	case XAUI_IF:
         case XLAUI_IF:
 	case RXAUI_IF:
-		if (is_nlm_xlp9xx())
+		if (IS_NLM_XLP9XX_FAMILY)
 			return DEFAULT_XLP9XX_XAUI_NUM_FREEDESC;
 
 		return DEFAULT_XAUI_NUM_FREEDESC;
@@ -301,7 +301,7 @@ static inline uint32_t get_intf_fifo_size(uint32_t intf_type)
         case XLAUI_IF:
                 return (current_netsoc->ingress.max_if_fifo / current_netsoc->max_ports)*4;
         case RXAUI_IF:
-		if(is_nlm_xlp9xx())
+		if(IS_NLM_XLP9XX_FAMILY)
                 	return (current_netsoc->ingress.max_if_fifo / current_netsoc->max_ports)*2;
                 return (current_netsoc->ingress.max_if_fifo / current_netsoc->max_ports)*4;
         case INTERLAKEN_IF:
@@ -321,21 +321,21 @@ static inline uint32_t get_prsr_seq_fifo_size(uint32_t intf_type)
 {
         switch(intf_type) {
 	case XFI_IF:
-		if (is_nlm_xlp9xx())
+		if (IS_NLM_XLP9XX_FAMILY)
 			return DEFAULT_XLP9XX_XAUI_PARSERSEQFIFO_SZ/4;
                 return DEFAULT_XAUI_PARSERSEQFIFO_SZ/4;
         case SGMII_IF:
                 return DEFAULT_SGMII_PARSERSEQFIFO_SZ;
         case XAUI_IF:
         case XLAUI_IF:
-		if (is_nlm_xlp9xx())
+		if (IS_NLM_XLP9XX_FAMILY)
 			return DEFAULT_XLP9XX_XAUI_PARSERSEQFIFO_SZ;
 		if (is_nlm_xlp2xx())
 			return DEFAULT_XLP2XX_XAUI_PARSERSEQFIFO_SZ;
 
                 return DEFAULT_XAUI_PARSERSEQFIFO_SZ;
         case RXAUI_IF:
-		if(is_nlm_xlp9xx())
+		if(IS_NLM_XLP9XX_FAMILY)
                 	return DEFAULT_XLP9XX_XAUI_PARSERSEQFIFO_SZ/2;
                 return DEFAULT_XAUI_PARSERSEQFIFO_SZ;
         case INTERLAKEN_IF:
@@ -368,21 +368,21 @@ static inline uint32_t get_rx_buf_size(uint32_t intf_type)
 {
         switch(intf_type) {
 	case XFI_IF:
- 		if (is_nlm_xlp9xx())
+ 		if (IS_NLM_XLP9XX_FAMILY)
  			return DEFAULT_XLP9XX_XAUI_RXFIFO_SZ/4;
                 return DEFAULT_XAUI_RXFIFO_SZ/4;
         case SGMII_IF:
                 return DEFAULT_SGMII_RXFIFO_SZ;
         case XAUI_IF:
         case XLAUI_IF:
- 		if (is_nlm_xlp9xx())
+ 		if (IS_NLM_XLP9XX_FAMILY)
  			return DEFAULT_XLP9XX_XAUI_RXFIFO_SZ;
 		if (is_nlm_xlp2xx())
 			return DEFAULT_XLP2XX_XAUI_RXFIFO_SZ;
 
                 return DEFAULT_XAUI_RXFIFO_SZ;
         case RXAUI_IF:
-		if(is_nlm_xlp9xx())
+		if(IS_NLM_XLP9XX_FAMILY)
                 	return DEFAULT_XLP9XX_XAUI_RXFIFO_SZ/2;
                 return DEFAULT_XAUI_RXFIFO_SZ;
         case INTERLAKEN_IF:
@@ -395,7 +395,7 @@ static inline uint32_t get_rx_buf_size(uint32_t intf_type)
 static inline uint32_t get_max_lanes(uint32_t intf_type)
 {
 	if(RXAUI_IF==intf_type){
-		if(is_nlm_xlp9xx()) 
+		if(IS_NLM_XLP9XX_FAMILY) 
 			return 2;
 		return 4;
 	}else if(XAUI_IF==intf_type || XLAUI_IF==intf_type){
@@ -438,7 +438,7 @@ static inline void update_default_config(int intf_type, uint32_t *config, uint32
                 for(iface = 0; iface < 4; iface++) {
                         *config++ = val;
                 }
-        }else if((intf_type == RXAUI_IF) && is_nlm_xlp9xx()){
+        }else if((intf_type == RXAUI_IF) && IS_NLM_XLP9XX_FAMILY){
                 for(iface = 0; iface < 2; iface++) {
                         *config++ = val;
                 }
@@ -451,17 +451,17 @@ static inline void update_default_config(int intf_type, uint32_t *config, uint32
 static inline int get_num_ports(int block, int intf_type)
 {
 	if (intf_type == SGMII_IF) {
-		if(is_nlm_xlp9xx() && block==2){
+		if(IS_NLM_XLP9XX_FAMILY && block==2){
 			return 1;
 		}else if (block < 4)
 			return 4;
 		else
 			return 2;
-	} else if (is_nlm_xlp9xx() && intf_type == XFI_IF) {
+	} else if (IS_NLM_XLP9XX_FAMILY && intf_type == XFI_IF) {
                return 4;
-	}else if (is_nlm_xlp9xx() && intf_type == XLAUI_IF) {
+	}else if (IS_NLM_XLP9XX_FAMILY && intf_type == XLAUI_IF) {
 		return 1;
-	}else if (is_nlm_xlp9xx() && intf_type == RXAUI_IF) {
+	}else if (IS_NLM_XLP9XX_FAMILY && intf_type == RXAUI_IF) {
 		return 2;
 	}
 	else
@@ -471,7 +471,7 @@ static inline int get_num_ports(int block, int intf_type)
 static inline int get_intf_hw_port_id(int block, int intf_type, int offset)
 {
 	int base_blk_id = block*MAX_PORTS_PERBLOCK;
-	if (is_nlm_xlp9xx() && intf_type == RXAUI_IF) {
+	if (IS_NLM_XLP9XX_FAMILY && intf_type == RXAUI_IF) {
 		return (base_blk_id + (offset*get_num_ports(block, intf_type)));
 	}
 	else
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
index eae0fc6..860307e 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
@@ -563,6 +563,7 @@ enum {
 #define PMA2P0_CMD 			0x9
 #define PMA2P0_CTL0			0xA
 	#define PMA2P0_CTL_POR			(1<<9)
+	#define XLP5XX_PMA2P0_CTL_POR		(1<<31)
 	#define PMA2P0_CTL_SYNTH_RST		(1<<10)
 	#define PMA2P0_CTL_RTHR			(0xf<<12)	
 #define PMA2P0_CTL1			0xB
@@ -589,12 +590,62 @@ enum {
         #define PMA2P0_CTL_XLAUI_DW      (0x5<<4)
         #define PMA2P0_CTL_ILK_DW        (0x3<<4)
 
+	#define PMA2P0_DATA_RATE_MASK                      (0x7)
+	#define PMA2P0_DATA_RATE_LT_1P25G                  (0x0)
+	#define PMA2P0_DATA_RATE_GTE_1P25G_LT_2P5G         (0x1)
+	#define PMA2P0_DATA_RATE_GTE_2P5G_LT_5G            (0x2)
+	#define PMA2P0_DATA_RATE_GTE_5G                    (0x3)
+
+	#define PMA2P0_DATA_WIDTH_MASK                     (0x70)
+	#define PMA2P0_DATA_WIDTH_8BIT                     (0x00)
+	#define PMA2P0_DATA_WIDTH_10BIT                    (0x10)
+	#define PMA2P0_DATA_WIDTH_16BIT                    (0x20)
+	#define PMA2P0_DATA_WIDTH_20BIT                    (0x30)
+	#define PMA2P0_DATA_WIDTH_32BIT                    (0x40)
+	#define PMA2P0_DATA_WIDTH_40BIT                    (0x50)
+
+
+
 	
 #define PMA2P0_STATUS			0xC
 #define PMA2P0_PINCTRL			0xD
 #define PMA2P0_PIN_STS			0XE
+
+#define PMA2P0_COMMON_LANE0                  4
+#define PMA2P0_COMMON_LANE1                  5
+#define PMA2P0_COMMON_LANE2                  6
+#define PMA2P0_COMMON_LANE3                  7
 		
- 
+#define PMA2P0_LANE0_TX_POWER_DOWN           (1<<0)
+#define PMA2P0_LANE1_TX_POWER_DOWN           (1<<1)
+#define PMA2P0_LANE2_TX_POWER_DOWN           (1<<2)
+#define PMA2P0_LANE3_TX_POWER_DOWN           (1<<3)
+#define PMA2P0_LANE0_RX_POWER_DOWN           (1<<4)
+#define PMA2P0_LANE1_RX_POWER_DOWN           (1<<5)
+#define PMA2P0_LANE2_RX_POWER_DOWN           (1<<6)
+#define PMA2P0_LANE3_RX_POWER_DOWN           (1<<7)
+#define PMA2P0_LANE0_RXTX_HARD_RESET         (1<<12)
+#define PMA2P0_LANE1_RXTX_HARD_RESET         (1<<13)
+#define PMA2P0_LANE2_RXTX_HARD_RESET         (1<<14)
+#define PMA2P0_LANE3_RXTX_HARD_RESET         (1<<15)
+#define PMA2P0_LANE0_REG_RESET               (1<<16)
+#define PMA2P0_LANE1_REG_RESET               (1<<17)
+#define PMA2P0_LANE2_REG_RESET               (1<<18)
+#define PMA2P0_LANE3_REG_RESET               (1<<19)
+#define PMA2P0_LANE0_SYNTH_POWER_DOWN        (1<<20)
+#define PMA2P0_LANE1_SYNTH_POWER_DOWN        (1<<21)
+#define PMA2P0_LANE2_SYNTH_POWER_DOWN        (1<<22)
+#define PMA2P0_LANE3_SYNTH_POWER_DOWN        (1<<23)
+#define PMA2P0_LANE0_SYNTH_HARD_RESET        (1<<24)
+#define PMA2P0_LANE1_SYNTH_HARD_RESET        (1<<25)
+#define PMA2P0_LANE2_SYNTH_HARD_RESET        (1<<26)
+#define PMA2P0_LANE3_SYNTH_HARD_RESET        (1<<27)
+#define PMA2P0_LANE0_POWER_ON_RESET          (1<<28)
+#define PMA2P0_LANE1_POWER_ON_RESET          (1<<29)
+#define PMA2P0_LANE2_POWER_ON_RESET          (1<<30)
+#define PMA2P0_LANE3_POWER_ON_RESET          (1<<31)
+
+
 
 /*
  * PRM: 11.10.2 PHY and PMA Controller Registers
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
index 08bb0b0..4ec3bdf 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
@@ -122,7 +122,7 @@ static inline void __netsoc_set_frin_total_queue(nae_t *nae)
 
 static inline int __netsoc_set_frin_queue_base(nae_t *nae)
 {
-	if (is_nlm_xlp9xx()) {
+	if (IS_NLM_XLP9XX_FAMILY) {
 		if (nae->nae_id == 0)
 			nae->frin_queue_base = (nae->node <<10) | XLP_9XX_NET0_RX_VC_BASE;
 		else
@@ -139,7 +139,7 @@ static inline int __netsoc_set_frin_queue_base(nae_t *nae)
 
 static inline int __netsoc_get_tx_queue_base(nae_t *nae)
 {
-        if (is_nlm_xlp9xx()) {
+        if (IS_NLM_XLP9XX_FAMILY) {
                 if (nae->nae_id == 0)
                         return ((nae->node <<10) | XLP_9XX_NET0_TX_VC_BASE);
                 else
@@ -247,8 +247,8 @@ static inline void __netsoc_reset_nae(nae_t *nae)
 {
         int reset_bit = 9;
         /* Reset NAE */
-
-	if (is_nlm_xlp9xx()) {
+	
+	if (IS_NLM_XLP9XX_FAMILY) {
                 if (nae->nae_id == 0)
                     reset_bit = 21;
                 else
@@ -333,19 +333,29 @@ static inline uint32_t __netsoc_read_kr_reg(uint64_t mac_base, uint32_t lane_no,
 
 static inline void __netsoc_write_pma2p0_reg(uint64_t base, uint32_t lane_no, uint32_t addr, uint32_t data)
 {
-    uint32_t tmp_data;
-    tmp_data = (0x2 << 29) | (lane_no << 21) | ((addr & 0x1fff) << 8) | (data & 0xff);
-    netsoc_write_mac_reg(base, PMA2P0_CMD, tmp_data);
-    __netsoc_pma2p0_cmd_poll_pend(base);
+	uint32_t tmp_data;
+	if(is_nlm_xlp5xx()){
+		//          commad         lane#                      common lane                     addr                    data
+		tmp_data = (0x2 << 29) | ((lane_no & 0x3) << 24) | (((lane_no >> 2) & 0x1) << 23) | ((addr & 0x1fff) << 8) | (data & 0xff);
+	}else{
+		tmp_data = (0x2 << 29) | (lane_no << 21) | ((addr & 0x1fff) << 8) | (data & 0xff);
+	}
+	netsoc_write_mac_reg(base, PMA2P0_CMD, tmp_data);
+	__netsoc_pma2p0_cmd_poll_pend(base);
 }
 
 static inline uint32_t __netsoc_read_pma2p0_reg(uint64_t base, uint32_t lane_no, uint32_t addr)
 {
-    uint32_t tmp_data, rd_data;
-    tmp_data = (0x3 << 29) | (lane_no << 21) | ((addr & 0x1fff) << 8);
-    netsoc_write_mac_reg(base, PMA2P0_CMD, tmp_data);
-    rd_data = __netsoc_pma2p0_cmd_poll_pend(base);
-    return (rd_data & 0xFF);
+	uint32_t tmp_data, rd_data;
+	if(is_nlm_xlp5xx()){
+		//          commad         lane#                     common lane                      addr
+		tmp_data = (0x3 << 29) | ((lane_no & 0x3) << 24) | (((lane_no >> 2) & 0x1) << 23) | ((addr & 0x1fff) << 8);
+	}else{
+		tmp_data = (0x3 << 29) | (lane_no << 21) | ((addr & 0x1fff) << 8);
+	}
+	netsoc_write_mac_reg(base, PMA2P0_CMD, tmp_data);
+	rd_data = __netsoc_pma2p0_cmd_poll_pend(base);
+	return (rd_data & 0xFF);
 }
 
 #ifdef PMA2P0_DEBUG
@@ -711,7 +721,7 @@ static inline int __netsoc_config_wred_perclass(nae_t *nae, uint32_t class_num,
 {
 	uint32_t val;
 
-	if (is_nlm_xlp9xx() == 0)
+	if (IS_NLM_XLP9XX_FAMILY == 0)
 		return -NETSOC_API_NOT_SUPPORTED;
 
 	if (enable) {
@@ -733,7 +743,7 @@ static inline int __netsoc_config_wred_perclass(nae_t *nae, uint32_t class_num,
 static inline int __netsoc_config_wred_enable(nae_t *nae, uint32_t thres_lo, uint32_t thres_hi)
 {
 	uint32_t class_num;
-        if (is_nlm_xlp9xx() == 0)
+        if (IS_NLM_XLP9XX_FAMILY == 0)
                 return -NETSOC_API_NOT_SUPPORTED;
 
 	for(class_num=0; class_num < 8; class_num++) {
@@ -745,7 +755,7 @@ static inline int __netsoc_config_wred_enable(nae_t *nae, uint32_t thres_lo, uin
 static inline int __netsoc_config_wred_disable(nae_t *nae)
 {
         uint32_t class_num;
-        if (is_nlm_xlp9xx() == 0)
+        if (IS_NLM_XLP9XX_FAMILY == 0)
                 return -NETSOC_API_NOT_SUPPORTED;
 
         for(class_num=0; class_num < 8; class_num++) {
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_poe.h b/arch/mips/netlogic/lib/netlib/include/netsoc_poe.h
index f4c6da3..db59378 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_poe.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_poe.h
@@ -297,7 +297,7 @@ static inline void __netsoc_reset_poe(poe_t *poe)
         if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
                 reset_bit = 7;
         }
-        else if (is_nlm_xlp9xx()) {
+        else if (IS_NLM_XLP9XX_FAMILY) {
                 if (poe->poe_id == 0)
                     reset_bit = 19;
                 else
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
index cbc026d..86b8183 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
@@ -1336,7 +1336,7 @@ void netsoc_print_poe_stats(poe_t *poe)
 
 int netsoc_config_poe_distvec(poe_t *poe, uint32_t vec, cpu_mask_t *cpumap, uint32_t vc)
 {
-	if (!is_nlm_xlp9xx())
+	if (!IS_NLM_XLP9XX_FAMILY)
 		return __netsoc_init_poe_distvec(poe, vec, cpumap->mask[0], cpumap->mask[1], cpumap->mask[2], cpumap->mask[3], (1<<vc));
         else
                 return __netsoc_v1_init_poe_distvec(poe, vec, cpumap, vc);    
@@ -1360,7 +1360,7 @@ int netsoc_config_poe_distvec(poe_t *poe, uint32_t vec, cpu_mask_t *cpumap, uint
 
 int netsoc_config_poe_distgroup(poe_t *poe, cpu_mask_t *cpumap, uint32_t vc_sel_groupid)
 {
-        if (!is_nlm_xlp9xx())
+        if (!IS_NLM_XLP9XX_FAMILY)
            return -NETSOC_API_NOT_SUPPORTED;
 
         __netsoc_disable_distribution(poe);  
@@ -1386,7 +1386,7 @@ int netsoc_config_poe_distgroup(poe_t *poe, cpu_mask_t *cpumap, uint32_t vc_sel_
 
 int netsoc_enable_poedist_tocore(poe_t *poe, uint32_t vec, uint32_t core)
 {
-        if (!is_nlm_xlp9xx())
+        if (!IS_NLM_XLP9XX_FAMILY)
            return -NETSOC_API_NOT_SUPPORTED;
 
         __netsoc_disable_distribution(poe);
@@ -1412,7 +1412,7 @@ int netsoc_enable_poedist_tocore(poe_t *poe, uint32_t vec, uint32_t core)
 
 int netsoc_disable_poedist_tocore(poe_t *poe, uint32_t vec, uint32_t core)
 {
-        if (!is_nlm_xlp9xx())
+        if (!IS_NLM_XLP9XX_FAMILY)
            return -NETSOC_API_NOT_SUPPORTED;
 
         __netsoc_disable_distribution(poe);
@@ -1438,7 +1438,7 @@ int netsoc_disable_poedist_tocore(poe_t *poe, uint32_t vec, uint32_t core)
 
 int netsoc_config_poe_vcsel(poe_t *poe, uint32_t vc_sel_groupid, uint32_t val)
 {
-        if (!is_nlm_xlp9xx())
+        if (!IS_NLM_XLP9XX_FAMILY)
            return -NETSOC_API_NOT_SUPPORTED;
 
         __netsoc_disable_distribution(poe);
@@ -1466,7 +1466,7 @@ int netsoc_config_poe_vcsel(poe_t *poe, uint32_t vc_sel_groupid, uint32_t val)
 
 int netsoc_configure_poeclass_spill(poe_t *poe, uint32_t class_num, uint64_t spillbase, uint64_t spillsize)
 {
-        if (!is_nlm_xlp9xx())
+        if (!IS_NLM_XLP9XX_FAMILY)
            return -NETSOC_API_NOT_SUPPORTED;
 
 	__netsoc_v1_config_poedin_spill(poe, class_num, spillbase, spillsize);
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
index e4123cb..3e13693 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
@@ -235,7 +235,7 @@ void update_netsoc_info(void)
 {
 	int node, id;
 
-	if (is_nlm_xlp9xx()) {
+	if (IS_NLM_XLP9XX_FAMILY) {
 		socnet_version_v0 = 0;
 		current_netsoc = &xlp9xx_netsoc;
 		netsoc_api_print(NETSOC_APIDBG_DEFAULT,"BRCM HAL net confgured for xlp9xx\n");
@@ -378,7 +378,7 @@ static int __netsoc_update_context_mapping(nae_t *nae, net_port_t **cntx)
 	uint32_t txq_base;
 #endif
 
-        if (is_nlm_xlp9xx()) {
+        if (IS_NLM_XLP9XX_FAMILY) {
                 if (nae->nae_id == 0)
                         poe_queue_base = (nae->node <<10) | XLP_9XX_POE0_VC_BASE;
                 else
@@ -396,7 +396,7 @@ static int __netsoc_update_context_mapping(nae_t *nae, net_port_t **cntx)
 	txq_base = nae->ports[0].txq;
         for(i = 0 ; i < max_ports; i++) {
                 nae->ports[i].txq = txq_base;
-                if (is_nlm_xlp9xx() && (nae->num_contexts == current_netsoc->max_contexts) && (nae->num_ports == current_netsoc->max_ports))
+                if (IS_NLM_XLP9XX_FAMILY && (nae->num_contexts == current_netsoc->max_contexts) && (nae->num_ports == current_netsoc->max_ports))
                         txq_base  += nae->ports[i].num_channels;
                 else
                         txq_base += 8;
@@ -464,7 +464,7 @@ static int __netsoc_update_context_mapping(nae_t *nae, net_port_t **cntx)
 #ifdef CONTEXT_NUMBER_INSEQ
                context += ctxsize;
 #else
-                if (is_nlm_xlp9xx() && (nae->num_contexts == current_netsoc->max_contexts) && (nae->num_ports == current_netsoc->max_ports))
+                if (IS_NLM_XLP9XX_FAMILY && (nae->num_contexts == current_netsoc->max_contexts) && (nae->num_ports == current_netsoc->max_ports))
                         context += ctxsize;
                 else
                         context += 8;
@@ -506,7 +506,7 @@ static void __netsoc_update_nae_defaultconfig(nae_t *nae)
 
 static void __netsoc_update_poe_defaultconfig(poe_t *poe)
 {
-        if (is_nlm_xlp9xx()) {
+        if (IS_NLM_XLP9XX_FAMILY) {
                 if (poe->poe_id == 0)
                         poe->poe_queue_base = (poe->node <<10) | XLP_9XX_POE0_VC_BASE;
                 else
@@ -587,7 +587,7 @@ int __netsoc_parse_and_init(void *fdt, int dom_id, struct netsoc_lib_param* libp
         max_poe = __netsoc_get_max_poe();
 //        max_ale = __netsoc_get_max_ale();
 
-	bus = (is_nlm_xlp9xx()) ? 1 : 0 ;
+	bus = 0;
 
 	for(node = 0; node < max_nodes; node++) {
 		// Parset nae configuration from fdt
@@ -612,12 +612,12 @@ int __netsoc_parse_and_init(void *fdt, int dom_id, struct netsoc_lib_param* libp
 			
 			if (id == 0){
 				nae->pcie_base = nlm_hal_get_dev_base(node, bus, XLP_NAE_DEVICE, XLP_NAE_FUNC);
-				if(is_nlm_xlp9xx())
+				if(IS_NLM_XLP9XX_FAMILY)
 					nae->pcie_base = xlp9xx_mac0_base[node];
 			}
 			else{
 				nae->pcie_base = nlm_hal_get_dev_base(node, bus, XLP9XX_NAE1_DEVICE, XLP9XX_NAE1_FUNC);
-				if(is_nlm_xlp9xx())
+				if(IS_NLM_XLP9XX_FAMILY)
 					nae->pcie_base = xlp9xx_mac1_base[node];
 			}
 
@@ -660,13 +660,13 @@ int __netsoc_parse_and_init(void *fdt, int dom_id, struct netsoc_lib_param* libp
 	
 			if (id == 0){
 				poe->pcie_base = nlm_hal_get_dev_base(node, bus, XLP_POE_DEVICE, XLP_POE_FUNC);
-				if(is_nlm_xlp9xx())
+				if(IS_NLM_XLP9XX_FAMILY)
 					poe->pcie_base = xlp9xx_poe0_base[node];
 				
 			}
 			else{
 				poe->pcie_base = nlm_hal_get_dev_base(node, bus, XLP9XX_POE1_DEVICE, XLP9XX_POE1_FUNC);
-				if(is_nlm_xlp9xx())
+				if(IS_NLM_XLP9XX_FAMILY)
 					poe->pcie_base = xlp9xx_poe1_base[node];
 			}
 
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index afbdd21..e273073 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -179,7 +179,7 @@ static int fdt_get_interface_type(void *fdt, char *nae_port_str, int block, int
                                 return -1;
                         }
                         netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Complex %d in interlaken mode\n", block);
-                        if (is_nlm_xlp8xx() || is_nlm_xlp9xx()) {
+                        if (is_nlm_xlp8xx() || IS_NLM_XLP9XX_FAMILY) {
                                 nae_cfg->ports[port].iftype = INTERLAKEN_IF;
                         }
                         else {
@@ -444,7 +444,7 @@ start_for_dom:
 		/* Ownes all fifos by default, only 1 entry is considered now */
         fifo_mask[node] = (1 << frin_total_queue) - 1;
 
-	if (is_nlm_xlp9xx()) {
+	if (IS_NLM_XLP9XX_FAMILY) {
 		sprintf(dom_node_str, "/doms/dom@0/nae-%d", nae_cfg->nae_id);
 	} else {
 		sprintf(dom_node_str, "/doms/dom@%d/nae", domid);
@@ -930,7 +930,7 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg, struct netsoc_lib_pa
         uint32_t txq, max_context = 0, tx_slots = 0, rx_slots = 0;
 	uint32_t node = nae_cfg->node;
 
-	if (is_nlm_xlp9xx()) {
+	if (IS_NLM_XLP9XX_FAMILY) {
 		if (nae_cfg->nae_id == 0) {
 			txq = (node <<10) | XLP_9XX_NET0_TX_VC_BASE;
 		}
@@ -1134,7 +1134,7 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg, struct netsoc_lib_pa
                         nae_port->msec_enable = (cmplx_cfg.msec_port_enable >> offset) & 0x1;
                         //nae_port->msec_enable = 1;
 
-                        if (is_nlm_xlp9xx()|| is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
+                        if (IS_NLM_XLP9XX_FAMILY|| is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
                                 nae_port->ext_phy_bus = 0;
                         }
 			nae_port->ucore_mask &= current_netsoc->ucore_mask;
@@ -1264,7 +1264,7 @@ int fdt_parse_netsoc_poe_config(void *fdt,poe_t *poe)
                         netsoc_api_print(NETSOC_APIDBG_FDT,"FDT spill_base 0x%llx spill_size 0x%x\n",(unsigned long long)poe->poe_address_map, poe->poe_address_len);
                 }
 
-		if (is_nlm_xlp9xx()) {
+		if (IS_NLM_XLP9XX_FAMILY) {
 		        p_addr_map = (uint64_t *)fdt_getprop(fdt, nodeoffset, "din-spill-address", &addr_map_len);
                         p_addr_len = (uint32_t *)fdt_getprop(fdt, nodeoffset, "din-spill-size", &plen);
 
@@ -1296,7 +1296,7 @@ int fdt_parse_netsoc_poe_config(void *fdt,poe_t *poe)
 					poe->dist_threshold[i] = POE_DIST_THRESHOLD_VAL;
 			}
 
-                        if (is_nlm_xlp9xx()) {
+                        if (IS_NLM_XLP9XX_FAMILY) {
                              sprintf(path_str, "/soc/net@node-%d/poe-%d/distribution", poe->node, poe->poe_id);
                              nodeoffset = fdt_path_offset(fdt, path_str);
                              if (nodeoffset >= 0) {
@@ -1492,7 +1492,7 @@ void nlm_hal_retrieve_nae_rx_cpu_mask(void *fdt, int dom_id, nae_t *nae)
 
  	memset(nae->nae_rx_cpu_mask, 0, sizeof(uint8_t) * 80);
 	
-	if (is_nlm_xlp9xx()) {
+	if (IS_NLM_XLP9XX_FAMILY) {
 	        sprintf(dom_node_str, "/doms/dom@%d/nae-%d", dom_id, nae->nae_id);
 	} else {
 		sprintf(dom_node_str, "/doms/dom@%d/nae", dom_id);
@@ -1517,7 +1517,7 @@ void nlm_hal_retrieve_nae_rx_cpu_mask(void *fdt, int dom_id, nae_t *nae)
 				for (index = 0; index < ONLINEMASK_INDEX_NUM; index++) {
 					sub_mask_word = (mask_word >> (index * ONLINEMASK_PER_INDEX_SZ)) & ONLINEMASK_INDEX_MASK;
 					nae->nae_rx_cpu_mask[j--] = sub_mask_word;
-					if (is_nlm_xlp9xx()) {
+					if (IS_NLM_XLP9XX_FAMILY) {
 						bit_count += ONLINEMASK_PER_INDEX_SZ;
 						if (bit_count >= XLP9XX_MAX_CPU_PER_NODE) {
 							bit_count = 0;
@@ -1538,12 +1538,12 @@ void nlm_hal_retrieve_nae_rx_cpu_mask(void *fdt, int dom_id, nae_t *nae)
 
 int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae, struct netsoc_lib_param *libparam)
 {
-        if (is_nlm_xlp9xx()) {
+        if (IS_NLM_XLP9XX_FAMILY) {
 		if(!fdt_get_nae(fdt, nae))
              		return 1;
 	}
 
-        if (is_nlm_xlp9xx()) {
+        if (IS_NLM_XLP9XX_FAMILY) {
              fdt_get_nae_frequency(fdt, nae);
 	     fdt_get_nae_strfwd_config(fdt, nae);
         }
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 8328ba2..3e073b1 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -91,7 +91,7 @@ static uint32_t nae_get_EXT_G_MDIO_DIV(void)
 	return (
 	       is_nlm_xlp3xx_ax() ||
 	       is_nlm_xlp8xx_ax() ||
-	       is_nlm_xlp8xx_b0() || is_nlm_xlp9xx()) ?  EXT_G_MDIO_DIV : EXT_G_MDIO_DIV_WITH_HW_DIV64_11;
+	       is_nlm_xlp8xx_b0() || IS_NLM_XLP9XX_FAMILY) ?  EXT_G_MDIO_DIV : EXT_G_MDIO_DIV_WITH_HW_DIV64_11;
 }
 
 /* INT_MDIO_CTRL, block7, 0x799
@@ -823,7 +823,7 @@ uint32_t __netsoc_context_to_port_channel(nae_t *nae, uint32_t context)
 	else if (is_nlm_xlp2xx()) {
 		ctxt  = context - XLP_2XX_NET_TX_VC_BASE;
 	}
-	else if (is_nlm_xlp9xx()) {
+	else if (IS_NLM_XLP9XX_FAMILY) {
 		if(nae->nae_id==0)
 			ctxt  = context - XLP_9XX_NET0_VC_BASE;
 		else
@@ -1010,7 +1010,7 @@ void __netsoc_config_flow_base(nae_t *nae)
         uint32_t reg, cur_flow_base = 0;
 	uint32_t per_port_num_flows;
 
-	if (is_nlm_xlp9xx())
+	if (IS_NLM_XLP9XX_FAMILY)
 		per_port_num_flows = XLP9XX_MAX_FLOWS / nae->num_ports;
 	else	
 		per_port_num_flows = XLP_MAX_FLOWS / nae->num_ports;
@@ -1283,7 +1283,7 @@ void __netsoc_config_rxbuffer(nae_t *nae, int context_base, int num_channels, ui
 				context_base + offset, base, size, thrgrp);
 		val = 0x80000000 | ((base << 2) & 0x3fff); /* base */
                 val |= (((size << 2)  & 0x3fff) << 16); /* size */
-		if ((is_nlm_xlp9xx()) && (nae->str_fwd_enabled)) 
+		if ((IS_NLM_XLP9XX_FAMILY) && (nae->str_fwd_enabled)) 
 			val |= (1<<15);
                 netsoc_write_nae_reg(nae_base, RX_BUFFER_BASE_DEPTH_REG, val);
 
@@ -1346,7 +1346,7 @@ void __netsoc_config_parserfifo(nae_t *nae, int hw_port_id, uint32_t start, uint
 
         if (size != 0)
         {
-		if (is_nlm_xlp9xx()) {
+		if (IS_NLM_XLP9XX_FAMILY) {
                         xoff = size - 30 ;
                         xon = (size/4) * 2;
                         val = (xoff<<12) | (xon);
@@ -1470,7 +1470,7 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 #ifdef CONTEXT_NUMBER_INSEQ
                 		context_base += nae->ports[port].num_channels;
 #else
-                		if (is_nlm_xlp9xx() && (nae->num_contexts == current_netsoc->max_contexts) && (nae->num_ports == current_netsoc->max_ports))
+                		if (IS_NLM_XLP9XX_FAMILY && (nae->num_contexts == current_netsoc->max_contexts) && (nae->num_ports == current_netsoc->max_ports))
                         		context_base += nae->ports[port].num_channels;
                 		else
                         		context_base += 8;
@@ -1478,7 +1478,7 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 			}
 
 			size = ((lane == 0) ? nae->ports[port].prsr_seq_fifo_size : 0);
-			if ((is_nlm_xlp9xx()) && (nae->ptp1588_enabled == 0) && size)
+			if ((IS_NLM_XLP9XX_FAMILY) && (nae->ptp1588_enabled == 0) && size)
 				update_prsr_seq_fifo_size(nae, &size);
 
 			__netsoc_config_parserfifo(nae, nae->ports[port].hw_port_id + lane, cur_parser_base, size, 64, nae->ports[port].iftype);
@@ -1574,7 +1574,7 @@ void __netsoc_set_frequency(nae_t *nae, uint32_t frequency)
 		netsoc_api_print(NETSOC_APIDBG_DEFAULT, "NAE frequncy set to = %lluMhz", (unsigned long long)set_freq_d);
 		return;
 	}
-	else if (is_nlm_xlp9xx()) {
+	else if (IS_NLM_XLP9XX_FAMILY) {
 		xlp9xx_set_soc_frequency(nae->node, XLP9XX_CLKDEV_NET, (frequency * mhz));
 	}
 	else{
@@ -2233,7 +2233,7 @@ static void __netsoc_config_xaui(net_port_t *netport)
         }
         netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL1, val);
 
-	if (is_nlm_xlp9xx()) {
+	if (IS_NLM_XLP9XX_FAMILY) {
                 /*
                  * Configuring the OFF/ON timer
                  * 31:16  - In PFC mode is used as the Xoff value
@@ -2288,7 +2288,7 @@ static void __netsoc_config_xaui(net_port_t *netport)
         val = netsoc_read_mac_reg(mac_base, NETIOR_XGMAC_CTRL3);
 
         val &= ~(0x1f << 10);
-	if(is_nlm_xlp9xx())
+	if(IS_NLM_XLP9XX_FAMILY)
         	val |= (7 << 10);
 	else{
         	val |= (15 << 10);
@@ -2772,7 +2772,7 @@ void __netsoc_init_egress(nae_t *nae)
 	uint64_t nae_base = nae->nae_base;
         uint32_t tx_cfg =  netsoc_read_nae_reg(nae_base, TX_CONFIG);
 
-        if ((is_nlm_xlp3xx()) || is_nlm_xlp2xx() || is_nlm_xlp9xx() || (is_nlm_xlp8xx_bx())) {
+        if ((is_nlm_xlp3xx()) || is_nlm_xlp2xx() || IS_NLM_XLP9XX_FAMILY || (is_nlm_xlp8xx_bx())) {
                 netsoc_write_nae_reg(nae_base, TX_CONFIG, tx_cfg | NAE_TX_ENABLE | NAE_TX_ACE  | NAE_TX_COMPATIBLE | (1 << 3) );
         }
         else {
@@ -2807,7 +2807,7 @@ int __netsoc_config_port(net_port_t *netport)
 			//ifmask = 0xf << netport->hw_port_id;
 			ifmask = 0x1 << netport->hw_port_id;
 			tx_ior_credit = netsoc_read_nae_reg(nae_base, TX_IORCRDT_INIT);
-			if(is_nlm_xlp9xx()){
+			if(IS_NLM_XLP9XX_FAMILY){
 				netsoc_write_nae_reg(nae_base, TX_IORCRDT_INIT,  tx_ior_credit & (~ (1<<netport->hw_port_id)));
 			}else{
 				netsoc_write_nae_reg(nae_base, TX_IORCRDT_INIT, tx_ior_credit | ifmask);
@@ -3451,7 +3451,7 @@ void __netsoc_msec_tx_config(nae_t *nae, unsigned int port_enable, unsigned int
 	}
 	sec_tag_preamble = ((uint64_t)(sec_tag_offset[1]) << 32) | sec_tag_offset[0];
 
-	if(is_nlm_xlp9xx())
+	if(IS_NLM_XLP9XX_FAMILY)
                num_ports = 9;
         else
                num_ports = 8;
@@ -3585,13 +3585,13 @@ void __netsoc_msec_set_rx_cam(nae_t *nae, int index, int port_num, uint64_t sci,
 
 	netsoc_write_nae_reg(nae_base, RX_MSEC_MEM_DATAREG_0, sci & 0xffffffff);
 	netsoc_write_nae_reg(nae_base, RX_MSEC_MEM_DATAREG_1, (sci>>32) & 0xffffffff);
- 	if(is_nlm_xlp9xx())
+ 	if(IS_NLM_XLP9XX_FAMILY)
  		netsoc_write_nae_reg(nae_base, RX_MSEC_MEM_DATAREG_2, (port_num & 0x7)|0x0000);
  	else
  		netsoc_write_nae_reg(nae_base, RX_MSEC_MEM_DATAREG_2, (port_num & 0xf)|0x0000ffff);
 
 	netsoc_write_nae_reg(nae_base, RX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
- 	if(is_nlm_xlp9xx())
+ 	if(IS_NLM_XLP9XX_FAMILY)
  	{
  		netsoc_write_nae_reg(nae_base, RX_MSEC_SCI_MASK_LO_9XX(port_num), sci_mask & 0xffffffff);
  		netsoc_write_nae_reg(nae_base, RX_MSEC_SCI_MASK_HI_9XX(port_num), (sci_mask >> 32) & 0xffffffff);
@@ -3781,7 +3781,7 @@ void __netsoc_msec_rx_config(nae_t *nae, unsigned int port_enable, unsigned int
 	else
 		netsoc_write_nae_reg(nae_base, RX_MSEC_BYPASS, 0x2);
 
- 	if(is_nlm_xlp9xx())
+ 	if(IS_NLM_XLP9XX_FAMILY)
 		/* Enable port and pramble len for each port */
 		netsoc_write_nae_reg(nae_base, RX_MSEC_PORT_EN, (preamble_len << 9| port_enable) & 0x7ffffff);
 	else
@@ -3802,7 +3802,7 @@ void __netsoc_msec_rx_config(nae_t *nae, unsigned int port_enable, unsigned int
 	netsoc_write_nae_reg(nae_base, RX_MSEC_SEC_TAG0, sec_tag_offset[0]);
 	netsoc_write_nae_reg(nae_base, RX_MSEC_SEC_TAG1, sec_tag_offset[1]);
 
- 	if(is_nlm_xlp9xx())
+ 	if(IS_NLM_XLP9XX_FAMILY)
  	{
  		netsoc_write_nae_reg(nae_base, RX_MSEC_SEC_TAG2, sec_tag_offset[2]);
  		netsoc_write_nae_reg(nae_base, RX_MSEC_INIT_PN + 1, packet_num);
@@ -3990,7 +3990,7 @@ static int __netsoc_config_freein_fifo(nae_t *nae)
                                 nae->freein_fifo_onchip_num_descs[fifo] = 0;
                         }
                 }
-		if (is_nlm_xlp9xx()) {
+		if (IS_NLM_XLP9XX_FAMILY) {
 			/*rxaui has two physical ports in a quad*/
 			blk_cmplx_map = nae->rxaui_complex_map;
 			for(i = 0; blk_cmplx_map; i++) {
@@ -4095,7 +4095,7 @@ static int __netsoc_config_freein_fifo(nae_t *nae)
 	minsz /= 2;
 
         if(spillsz) {
-		if (is_nlm_xlp9xx()) {
+		if (IS_NLM_XLP9XX_FAMILY) {
 			th_hi = minsz / 4;
 			th_hi = minsz / 2;
 		}
@@ -4201,7 +4201,7 @@ static int __netsoc_init_net_port(net_port_t *netport, uint32_t context)
 #ifdef CONTEXT_NUMBER_INSEQ
 	return netport->num_channels;
 #else
-	if (is_nlm_xlp9xx() && (nae->num_contexts == current_netsoc->max_contexts) && (nae->num_ports == current_netsoc->max_ports))
+	if (IS_NLM_XLP9XX_FAMILY && (nae->num_contexts == current_netsoc->max_contexts) && (nae->num_ports == current_netsoc->max_ports))
           	return netport->num_channels;
         else
                 return 8;
@@ -4254,7 +4254,7 @@ int __netsoc_init_nae(nae_t *nae)
         int retval = 0, frin_q;
 
 	if (nae->owned) {
-		 if(!is_nlm_xlp9xx()){
+		 if(!IS_NLM_XLP9XX_FAMILY){
 			bar0 = netsoc_api_readl(nae->pcie_base, PCI_MEM_BAR_0);
 			bar0 = membar_fixup(bar0);
 	   	}
@@ -4269,7 +4269,7 @@ int __netsoc_init_nae(nae_t *nae)
                 __netsoc_reset_nae(nae);
                 nae->flags |= NAE_RESET_DONE;
 #endif
-		if(!is_nlm_xlp9xx()){
+		if(!IS_NLM_XLP9XX_FAMILY){
                 	nlm_hal_write_32bit_reg(nae->pcie_base, 0x4, bar0);
 		}
 		// Load ucore code
@@ -4312,7 +4312,7 @@ int __netsoc_init_nae(nae_t *nae)
                 	__netsoc_config_vfbid_table(nae, 0 , MAX_VFBID_ENTRIES, nae_vfbid_tbl[nae->node][nae->nae_id]);
         	}
 
-		if (is_nlm_xlp9xx()) {
+		if (IS_NLM_XLP9XX_FAMILY) {
 		      /* Configured for default MTU. This may not work for ports with different MTU size. */
 		       if (nae->str_fwd_enabled)
 		       		netsoc_write_nae_reg(nae->nae_base, RX_ST_FWD_MODE, (1<<10) | (1536/16));
@@ -4328,6 +4328,9 @@ int __netsoc_init_nae(nae_t *nae)
 
 		__netsoc_init_all_ports(nae);
 		
+//		if(IS_NLM_XLP9XX_FAMILY)
+//			__netsoc_bkpl_ether_init(nae); /*do KR/KR4 lane configuration*/	
+
 		if (nae->freein_uniq_sz) {
 		        for (frin_q = 0; frin_q < __netsoc_get_max_frinqs(); frin_q++) {
                 		__netsoc_write_fifo_size(nae, frin_q, nae->frin_desc_size[frin_q]);
@@ -4345,7 +4348,7 @@ int __netsoc_init_nae(nae_t *nae)
                       __netsoc_config_ale_disable(nae);
 
 
- 		if((is_nlm_xlp9xx() | is_nlm_xlp2xx()) && (nae->msec_tx_port_enable || nae->msec_rx_port_enable))
+ 		if((IS_NLM_XLP9XX_FAMILY | is_nlm_xlp2xx()) && (nae->msec_tx_port_enable || nae->msec_rx_port_enable))
  		{
  			__netsoc_msec_tx_default_config(nae,/* port_enable0xff*/nae->msec_tx_port_enable, /*unsigned int preamble_len*//*0x5555*/0, /*packet_num*/ 0x1, /*pn_thrshld*/0x7fffffff);
                          __netsoc_msec_rx_default_config(nae, /*port_enable0xff*/nae->msec_rx_port_enable, /*preamble_len*//*0xaaaa*/0, /*packet_num*/0x1, /*replay_win_size*/0x64);
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
index 6ccfb1a..470ef7e 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
@@ -590,19 +590,19 @@ static void xlp8xx_ilk_reset_pll(nae_t *nae, int ilk_block_base, int ilk_num_lan
 	}
 }
 
-#define VSEMI_INDIRECT_ADDRESS_0055         0x0055
-#define VSEMI_INDIRECT_ADDRESS_0007         0x0007
+#define PMA2P0_INDIRECT_ADDRESS_0055         0x0055
+#define PMA2P0_INDIRECT_ADDRESS_0007         0x0007
 
-#define VSEMI_INTERNAL_BUFF_TXRX_LOOPBACK   0x20
-#define VSEMI_UNTIMED_RXTX_LOOPBACK         0x10
+#define PMA2P0_INTERNAL_BUFF_TXRX_LOOPBACK   0x20
+#define PMA2P0_UNTIMED_RXTX_LOOPBACK         0x10
 
 static void vsemi_configure_loopback(uint64_t mac_base)
 {
         uint32_t reg_addr, lane_no, max_lanes =4;  
         for (lane_no=0; lane_no<max_lanes; lane_no++) {
 	
-                __netsoc_write_pma2p0_reg(mac_base, lane_no, VSEMI_INDIRECT_ADDRESS_0055, 0xFD);
-                __netsoc_write_pma2p0_reg(mac_base, lane_no, VSEMI_INDIRECT_ADDRESS_0007,VSEMI_INTERNAL_BUFF_TXRX_LOOPBACK);
+                __netsoc_write_pma2p0_reg(mac_base, lane_no, PMA2P0_INDIRECT_ADDRESS_0055, 0xFD);
+                __netsoc_write_pma2p0_reg(mac_base, lane_no, PMA2P0_INDIRECT_ADDRESS_0007,PMA2P0_INTERNAL_BUFF_TXRX_LOOPBACK);
 	}
 }
 
@@ -649,45 +649,75 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
                 }
         }
         /*configure only page 4*/
-        for (reg_addr=101; reg_addr <165; reg_addr++){
-                pma2p0_cmd=0;
-                if((xgmii_speed==16 ) && (lane_speed ==XAUI_TYPE_LANE)){
-                        pma2p0_cmd |= pma2p0_mem_16G[reg_addr];
-                }
-                if((xgmii_speed==12 ) && (lane_speed ==XAUI_TYPE_LANE)){
-                        pma2p0_cmd |= pma2p0_mem_12G[reg_addr];
-                }
-		if((xgmii_speed==10 ) && (lane_speed ==XAUI_TYPE_LANE) && (phy_mode == PHYMODE_RXAUI)){
-                        pma2p0_cmd |= pma2p0_mem_rxaui[reg_addr];
-		}else if((xgmii_speed==10 ) && (lane_speed ==XAUI_TYPE_LANE)){
-                        pma2p0_cmd |= pma2p0_mem_xaui[reg_addr];
-                }
-                if((xgmii_speed==10 ) && (lane_speed ==XFI_TYPE_LANE)){
-			pma2p0_cmd |= pma2p0_mem_10G_lane[reg_addr];	
+	for (reg_addr=101; reg_addr <165; reg_addr++){
+		int extra_common_lanes = max_lanes;
+		if(!(is_nlm_xlp5xx())){
+			extra_common_lanes = 1;	
+			nlm_print("MAX extra_common_lanes is one \n");
 		}
-                if(phy_mode==PHYMODE_SGMII){
-                        pma2p0_cmd |= pma2p0_mem_sgmii[reg_addr];
-                }
-                if(phy_mode==PHYMODE_IL){
-                        pma2p0_cmd = pma2p0_mem_rxaui[reg_addr];
+
+		for (lane_no=0; lane_no<extra_common_lanes; lane_no++) {
+			pma2p0_cmd=0;
+			if((xgmii_speed==16 ) && (lane_speed ==XAUI_TYPE_LANE)){
+				pma2p0_cmd |= pma2p0_mem_16G[reg_addr];
+			}
+			if((xgmii_speed==12 ) && (lane_speed ==XAUI_TYPE_LANE)){
+				pma2p0_cmd |= pma2p0_mem_12G[reg_addr];
+			}
+			if((xgmii_speed==10 ) && (lane_speed ==XAUI_TYPE_LANE) && (phy_mode == PHYMODE_RXAUI)){
+				pma2p0_cmd |= pma2p0_mem_rxaui[reg_addr];
+			}else if((xgmii_speed==10 ) && (lane_speed ==XAUI_TYPE_LANE)){
+				pma2p0_cmd |= pma2p0_mem_xaui[reg_addr];
+			}
+			if((xgmii_speed==10 ) && (lane_speed ==XFI_TYPE_LANE)){
+				pma2p0_cmd |= pma2p0_mem_10G_lane[reg_addr];	
+			}
+			if(phy_mode==PHYMODE_SGMII){
+				pma2p0_cmd |= pma2p0_mem_sgmii[reg_addr];
+			}
+			if(phy_mode==PHYMODE_IL){
+				pma2p0_cmd = pma2p0_mem_rxaui[reg_addr];
+			}
+			__netsoc_write_pma2p0_reg(mac_base, 4 + lane_no, reg_addr, pma2p0_cmd);
 		}
-                __netsoc_write_pma2p0_reg(mac_base, 4, reg_addr, pma2p0_cmd);
-        }
+	}
 
 	// Extra configuration for XFI
 	if(phy_mode == PHYMODE_XFI){
-		pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, 4, 0x37);
-		pma2p0_cmd &= 0x80;
-		pma2p0_cmd |= 0x15;
-		 __netsoc_write_pma2p0_reg(mac_base, 4, 0x37, pma2p0_cmd);
+		if(is_nlm_xlp5xx()){
+			for (lane_no=0; lane_no<max_lanes; lane_no++){
+				pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, PMA2P0_COMMON_LANE0 + lane_no, 0x37);
+				pma2p0_cmd &= 0x80;
+				pma2p0_cmd |= 0x15;
+				__netsoc_write_pma2p0_reg(mac_base, PMA2P0_COMMON_LANE0 + lane_no, 0x37, pma2p0_cmd);
+			}
+
+		}
+		else {
+			pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, 4, 0x37);
+			pma2p0_cmd &= 0x80;
+			pma2p0_cmd |= 0x15;
+			__netsoc_write_pma2p0_reg(mac_base, 4, 0x37, pma2p0_cmd);
+		}
 	}
 	
 	// Extra configuration for XLAUI
 	if(phy_mode == PHYMODE_XLAUI){ 
-		pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, 4, 0x37);
-		pma2p0_cmd &= 0x80;
-		pma2p0_cmd |= 0x10;
-		 __netsoc_write_pma2p0_reg(mac_base, 4, 0x37, pma2p0_cmd);
+		if(is_nlm_xlp5xx()){
+			for (lane_no=0; lane_no<max_lanes; lane_no++){
+				pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, PMA2P0_COMMON_LANE0 + lane_no, 0x37);
+				pma2p0_cmd &= 0x80;
+				pma2p0_cmd |= 0x10;
+				__netsoc_write_pma2p0_reg(mac_base, PMA2P0_COMMON_LANE0 + lane_no, 0x37, pma2p0_cmd);
+
+			}
+
+		}else{	
+			pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, 4, 0x37);
+			pma2p0_cmd &= 0x80;
+			pma2p0_cmd |= 0x10;
+			__netsoc_write_pma2p0_reg(mac_base, 4, 0x37, pma2p0_cmd);
+		}
 	}
 	
         for (lane_no=0; lane_no<max_lanes; lane_no++) {
@@ -738,7 +768,15 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 
     	// De-assert hard reset
 	pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
-	pma2p0_config &= ~(PMA2P0_CTL_POR | PMA2P0_CTL_SYNTH_RST | PMA2P0_CTL_RTHR);
+	if(is_nlm_xlp5xx()){
+			
+    		pma2p0_config &= ~(PMA2P0_LANE0_RXTX_HARD_RESET | PMA2P0_LANE0_SYNTH_HARD_RESET);
+		 pma2p0_config  &= ~(PMA2P0_LANE1_RXTX_HARD_RESET | PMA2P0_LANE1_SYNTH_HARD_RESET);
+		pma2p0_config &= ~(PMA2P0_LANE2_RXTX_HARD_RESET | PMA2P0_LANE2_SYNTH_HARD_RESET);
+		pma2p0_config &= ~(PMA2P0_LANE3_RXTX_HARD_RESET | PMA2P0_LANE3_SYNTH_HARD_RESET);
+	}else{
+		pma2p0_config &= ~(PMA2P0_CTL_POR | PMA2P0_CTL_SYNTH_RST | PMA2P0_CTL_RTHR);
+	}
 	netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
     
 	for(delay=0; delay<10000; delay++);
@@ -769,7 +807,7 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 #if 0
 	vsemi_configure_loopback(mac_base);
 	for (lane_no=0; lane_no<max_lanes; lane_no++) {
-		pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, lane_no, VSEMI_INDIRECT_ADDRESS_0055);
+		pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, lane_no, PMA2P0_INDIRECT_ADDRESS_0055);
 	}
 #endif 
 }
@@ -777,61 +815,121 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t pma2p0_por , uint32_t speed, uint32_t phymode)
 {
 
-	uint32_t delay, pma2p0_config;
+	uint32_t delay, pma2p0_config, lane_no, max_lanes;
 	uint64_t mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-        int lane_enable = 0;
 	nlm_print("xlp9xx_config_pma2p0_serdes phymode= 0x%x\n", phymode);
+	if(block==2 && (phymode == PHYMODE_SGMII)){
+		max_lanes =1;
+	}
 
-	       	if(!pma2p0_por){
-                        pma2p0_config = netsoc_read_mac_reg(netsoc_get_macreg_base_for_phy(nae->mac_base, 2), PMA2P0_CTL0);
-                        pma2p0_config &= ~PMA2P0_CTL_POR;
-                        netsoc_write_mac_reg(netsoc_get_macreg_base_for_phy(nae->mac_base, 2), PMA2P0_CTL0, pma2p0_config);
-               	}
-               
-		pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
-                pma2p0_config &= 0xFFFF01FF;
-                pma2p0_config |= PMA2P0_CTL_POR | PMA2P0_CTL_SYNTH_RST | PMA2P0_CTL_RTHR | (1<<16);
-                netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
+	if(!pma2p0_por){
+		if(is_nlm_xlp5xx()){
+			
+			pma2p0_config = netsoc_read_mac_reg(netsoc_get_macreg_base_for_phy(nae->mac_base, 0), PMA2P0_CTL0);
+			pma2p0_config &= ~XLP5XX_PMA2P0_CTL_POR;
+			netsoc_write_mac_reg(netsoc_get_macreg_base_for_phy(nae->mac_base, 0), PMA2P0_CTL0, pma2p0_config);
+
+		}else{
+			pma2p0_config = netsoc_read_mac_reg(netsoc_get_macreg_base_for_phy(nae->mac_base, 2), PMA2P0_CTL0);
+			pma2p0_config &= ~PMA2P0_CTL_POR;
+			netsoc_write_mac_reg(netsoc_get_macreg_base_for_phy(nae->mac_base, 2), PMA2P0_CTL0, pma2p0_config);
+		}
+	}
 
-                for(delay=0; delay<1000000; delay++);
+	pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
+	if(is_nlm_xlp5xx()){
+		pma2p0_config |= (PMA2P0_LANE0_RXTX_HARD_RESET | PMA2P0_LANE0_SYNTH_HARD_RESET | PMA2P0_LANE0_POWER_ON_RESET | PMA2P0_LANE0_REG_RESET);
+		pma2p0_config |= (PMA2P0_LANE1_RXTX_HARD_RESET | PMA2P0_LANE1_SYNTH_HARD_RESET | PMA2P0_LANE1_POWER_ON_RESET | PMA2P0_LANE1_REG_RESET);
+		pma2p0_config |= (PMA2P0_LANE2_RXTX_HARD_RESET | PMA2P0_LANE2_SYNTH_HARD_RESET | PMA2P0_LANE2_POWER_ON_RESET | PMA2P0_LANE2_REG_RESET);
+		pma2p0_config |= (PMA2P0_LANE3_RXTX_HARD_RESET | PMA2P0_LANE3_SYNTH_HARD_RESET | PMA2P0_LANE3_POWER_ON_RESET | PMA2P0_LANE3_REG_RESET);
 
-                pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
-                pma2p0_config &= ~(PMA2P0_CTL_POR | (1<<16));
-                pma2p0_config &= 0xFFFFFE00;
-                netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
+	}else{
+		pma2p0_config &= 0xFFFF01FF;
+		pma2p0_config |= PMA2P0_CTL_POR | PMA2P0_CTL_SYNTH_RST | PMA2P0_CTL_RTHR | (1<<16);
+	}
+	netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
 
-                for(delay=0; delay<1000000; delay++);
- 
-                pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL1);
-                pma2p0_config &= ~((0x7<<4) | 0x7);
+	for(delay=0; delay<1000000; delay++);
+
+	pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
+	if(is_nlm_xlp5xx()){
+		pma2p0_config &= ~(PMA2P0_LANE0_TX_POWER_DOWN | PMA2P0_LANE0_RX_POWER_DOWN | PMA2P0_LANE0_SYNTH_POWER_DOWN | PMA2P0_LANE0_POWER_ON_RESET | PMA2P0_LANE0_REG_RESET);
+		pma2p0_config &= ~(PMA2P0_LANE1_TX_POWER_DOWN | PMA2P0_LANE1_RX_POWER_DOWN | PMA2P0_LANE1_SYNTH_POWER_DOWN | PMA2P0_LANE1_POWER_ON_RESET | PMA2P0_LANE1_REG_RESET);
+		pma2p0_config &= ~(PMA2P0_LANE2_TX_POWER_DOWN | PMA2P0_LANE2_RX_POWER_DOWN | PMA2P0_LANE2_SYNTH_POWER_DOWN | PMA2P0_LANE2_POWER_ON_RESET | PMA2P0_LANE2_REG_RESET);
+		pma2p0_config &= ~(PMA2P0_LANE3_TX_POWER_DOWN | PMA2P0_LANE3_RX_POWER_DOWN | PMA2P0_LANE3_SYNTH_POWER_DOWN | PMA2P0_LANE3_POWER_ON_RESET | PMA2P0_LANE3_REG_RESET);
+
+	}else{
+		pma2p0_config &= ~(PMA2P0_CTL_POR | (1<<16));
+		pma2p0_config &= 0xFFFFFE00;
+	}
+	netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
+
+	for(delay=0; delay<1000000; delay++);
+
+	if(is_nlm_xlp5xx()){
+		for (lane_no=0; lane_no<max_lanes; lane_no++) {
+			uint32_t data_rate_width = 0;
+			if (phymode == PHYMODE_SGMII){
+				data_rate_width = (PMA2P0_DATA_RATE_GTE_1P25G_LT_2P5G | PMA2P0_DATA_WIDTH_10BIT);
+			}else if (PHYMODE_XAUI==phymode){
+				if(16==speed){
+					data_rate_width = (PMA2P0_DATA_RATE_GTE_5G | PMA2P0_DATA_WIDTH_10BIT);
+				}else if (12==speed){
+					data_rate_width = (PMA2P0_DATA_RATE_GTE_5G | PMA2P0_DATA_WIDTH_10BIT);
+				}else{
+					data_rate_width = (PMA2P0_DATA_RATE_GTE_2P5G_LT_5G | PMA2P0_DATA_WIDTH_10BIT);
+				}		
+			}else if(PHYMODE_RXAUI==phymode){
+				if(16==speed){
+					data_rate_width = (PMA2P0_DATA_RATE_GTE_5G | PMA2P0_DATA_WIDTH_20BIT);
+				}else if (12==speed){
+					data_rate_width = (PMA2P0_DATA_RATE_GTE_5G | PMA2P0_DATA_WIDTH_20BIT);
+				}else{
+					data_rate_width = (PMA2P0_DATA_RATE_GTE_5G | PMA2P0_DATA_WIDTH_20BIT);
+				}
+			}else if(PHYMODE_XLAUI==phymode){
+				data_rate_width = (PMA2P0_DATA_RATE_GTE_5G | PMA2P0_DATA_WIDTH_40BIT);		
+			}else if(PHYMODE_XFI==phymode){
+				data_rate_width = (PMA2P0_DATA_RATE_GTE_5G | PMA2P0_DATA_WIDTH_40BIT);
+			}else if(PHYMODE_IL==phymode){
+				data_rate_width = (PMA2P0_DATA_RATE_GTE_5G | PMA2P0_DATA_WIDTH_20BIT);
+			}
+			pma2p0_config |= (data_rate_width << (8 * lane_no));
+		}	
+
+	}else{
+
+		pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL1);
+		pma2p0_config &= ~((0x7<<4) | 0x7);
 
 		if (phymode == PHYMODE_SGMII)
-	                pma2p0_config |= PMA2P0_CTL_SGMII_DR | PMA2P0_CTL_SGMII_DW;
+			pma2p0_config |= PMA2P0_CTL_SGMII_DR | PMA2P0_CTL_SGMII_DW;
 		else if((PHYMODE_RXAUI==phymode) || (PHYMODE_XAUI==phymode)){
 			if(speed==16)
-                                 pma2p0_config |= PMA2P0_CTL_XAUI_16G_DR | PMA2P0_CTL_XAUI_16G_DW;
-                        else if(speed==12)
-                                 pma2p0_config |= PMA2P0_CTL_XAUI_12G_DR | PMA2P0_CTL_XAUI_12G_DW;
-                        else if((PHYMODE_RXAUI==phymode) && (speed==10)) {
-                                 pma2p0_config |= PMA2P0_CTL_RXAUI_10G_DR | PMA2P0_CTL_RXAUI_10G_DW;
-                        }
-                        else //XAUII/10G
-                                 pma2p0_config = PMA2P0_CTL_XAUI_DR | PMA2P0_CTL_XAUI_DW;
+				pma2p0_config |= PMA2P0_CTL_XAUI_16G_DR | PMA2P0_CTL_XAUI_16G_DW;
+			else if(speed==12)
+				pma2p0_config |= PMA2P0_CTL_XAUI_12G_DR | PMA2P0_CTL_XAUI_12G_DW;
+			else if((PHYMODE_RXAUI==phymode) && (speed==10)) {
+				pma2p0_config |= PMA2P0_CTL_RXAUI_10G_DR | PMA2P0_CTL_RXAUI_10G_DW;
+			}
+			else //XAUII/10G
+				pma2p0_config = PMA2P0_CTL_XAUI_DR | PMA2P0_CTL_XAUI_DW;
 		}else if(PHYMODE_XFI==phymode){
 			pma2p0_config |= PMA2P0_CTL_XFI_DR | PMA2P0_CTL_XFI_DW;	
 		}else if(PHYMODE_XLAUI==phymode){
 			pma2p0_config |= PMA2P0_CTL_XLAUI_DW | PMA2P0_CTL_XLAUI_DR;	
 		}else if (PHYMODE_IL==phymode){
-			 pma2p0_config |= PMA2P0_CTL_XLAUI_ILK | PMA2P0_CTL_ILK_DW;	
+			pma2p0_config |= PMA2P0_CTL_XLAUI_ILK | PMA2P0_CTL_ILK_DW;	
 		}
-		
-		for(delay=0; delay<1000000; delay++);
+	}	
 
-                netsoc_write_mac_reg(mac_base, PMA2P0_CTL1, pma2p0_config);
+	for(delay=0; delay<1000000; delay++);
+
+	netsoc_write_mac_reg(mac_base, PMA2P0_CTL1, pma2p0_config);
 
-                xlp9xx_nae_write_pma2p0_mem(mac_base, block, speed, phymode, nae->bkpl_cfg[block].kr_en);
+        xlp9xx_nae_write_pma2p0_mem(mac_base, block, speed, phymode, nae->bkpl_cfg[block].kr_en);
 #ifdef PMA2P0_DEBUG
-		__netsoc_display_pma2p0_indirect_reg(mac_base, block);	
+	__netsoc_display_pma2p0_indirect_reg(mac_base, block);	
 #endif
 
 }
@@ -964,7 +1062,7 @@ static void __netsoc_xlp_nae_config_lane_gmac(nae_t *nae, int cplx_mask)
 			xlp2xx_config_block_pma2p0(nae, block, nae->serdes_init_cnt, 0, PHYMODE_SGMII);
 			nae->serdes_init_cnt++; 
                 }
-		if(is_nlm_xlp9xx()){
+		if(IS_NLM_XLP9XX_FAMILY){
 			xlp9xx_config_pma2p0_serdes(nae, block, nae->serdes_init_cnt, 0, PHYMODE_SGMII);
 			nae->serdes_init_cnt++;	
 		}
@@ -976,7 +1074,7 @@ static void __netsoc_xlp_nae_config_lane_gmac(nae_t *nae, int cplx_mask)
                         }else if(is_nlm_xlp2xx()){
                                 xlp2xx_lane_reset_txpll(nae, block, lane_ctrl, PHYMODE_SGMII);
 			}	
-			else if(is_nlm_xlp9xx()){
+			else if(IS_NLM_XLP9XX_FAMILY){
 				xlp9xx_lane_reset(nae, block, lane_ctrl, PHYMODE_SGMII);
 			}else{  
                                 xlp8xx_ax_lane_reset_txpll(nae, block, lane_ctrl, PHYMODE_SGMII);
@@ -1084,7 +1182,7 @@ static void config_lanes_for_xgmac(nae_t *nae, uint32_t xgmac_cplx_mask, uint32_
                 netsoc_api_delay(1);
         }
 
-	if((phymode==PHYMODE_RXAUI) && is_nlm_xlp9xx()){
+	if((phymode==PHYMODE_RXAUI) && IS_NLM_XLP9XX_FAMILY){
 		lane_enable = netsoc_read_mac_reg(mac_base, LANE_CFG_CPLX_4); 
 		if(xgmac_cplx_mask & 0x1){
 			lane_enable |= (1<< 16); 
@@ -2503,7 +2601,7 @@ void __netsoc_bkpl_auneg_complete(nae_t *nae, uint32_t block, uint32_t lane_no)
 void __netsoc_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask)
 {
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
-	if (is_nlm_xlp9xx())
+	if (IS_NLM_XLP9XX_FAMILY)
 	{
 		xlp9xx_sgmii_pcs_init(nae, sgmii_cplx_mask);
         }
@@ -2521,7 +2619,7 @@ void __netsoc_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask)
 void __netsoc_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phymode)
 {
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
-	if (is_nlm_xlp9xx()) {
+	if (IS_NLM_XLP9XX_FAMILY) {
 		xlp9xx_xaui_pcs_init(nae, xaui_cplx_mask, phymode);
 	}
 	else if (is_nlm_xlp2xx()) {
@@ -2664,7 +2762,7 @@ int __netsoc_interlaken_pcs_init(nae_t *nae, uint32_t ilk_complex_map)
         int block;
 	uint64_t mac_base;
 
-        if (!(is_nlm_xlp8xx() || is_nlm_xlp9xx())) {
+        if (!(is_nlm_xlp8xx() || IS_NLM_XLP9XX_FAMILY)) {
                 nlm_print("Internlaken is not supported \n");
                 return -1;
         }
@@ -2674,7 +2772,7 @@ int __netsoc_interlaken_pcs_init(nae_t *nae, uint32_t ilk_complex_map)
                 return -1;
         }
 
-	if(is_nlm_xlp9xx())
+	if(IS_NLM_XLP9XX_FAMILY)
 	{
 		xlp9xx_ilk_pcs_init(nae, ilk_complex_map);
 	}
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c b/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c
index 189f461..f790472 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c
@@ -76,7 +76,7 @@ int __netsoc_alloc_poe_enq_storage(poe_t *poe)
 
         netsoc_api_print (1, " POE Free Buffer Pool config ...\n");
 
-        if (is_nlm_xlp3xx() || is_nlm_xlp2xx() || is_nlm_xlp9xx()) {
+        if (is_nlm_xlp3xx() || is_nlm_xlp2xx() || IS_NLM_XLP9XX_FAMILY) {
                 a = (uint64_t)XLP3XX_EXT_FBP_START_ADDR;
                 num_messages = XLP3XX_MAX_POE_EXT_MSG_STORAGE;
                 fbp_sp_init = XLP3XX_POE_FBP_SP_INIT;
@@ -215,7 +215,7 @@ int __netsoc_init_poe_ext_storage(poe_t *poe, uint64_t fbp_base_phys,
         /* Free Buffer Pool config */
         nlm_print (" POE Free Buffer Pool config ...\n");
 
-        if (is_nlm_xlp3xx() || is_nlm_xlp2xx() || is_nlm_xlp9xx()) {
+        if (is_nlm_xlp3xx() || is_nlm_xlp2xx() || IS_NLM_XLP9XX_FAMILY) {
                 a = (uint64_t)XLP3XX_EXT_FBP_START_ADDR;
                 num_messages = XLP3XX_MAX_POE_EXT_MSG_STORAGE;
                 fbp_sp_init = XLP3XX_POE_FBP_SP_INIT;
@@ -294,7 +294,7 @@ int __netsoc_init_poe_distvec(poe_t *poe,int vec, uint32_t cm0, uint32_t cm1,
         int i; 
         int cpu;
 
-	if (is_nlm_xlp9xx())
+	if (IS_NLM_XLP9XX_FAMILY)
 		return -NETSOC_API_PARAM_INVALID;
 
         if (vec < MIN_DIST_VEC || vec >= MAX_DIST_VEC)
@@ -460,7 +460,7 @@ int __netsoc_v1_init_poe_distvec(poe_t *poe, uint32_t vec, cpu_mask_t *cpumap, u
     uint32_t thread_vc_sel = 0, node, coremask, maskindex, cpumask;
     uint32_t dvreg, core, thread;
 
-    if (is_nlm_xlp9xx() == 0)
+    if (IS_NLM_XLP9XX_FAMILY == 0)
           return -NETSOC_API_PARAM_INVALID;
 
     __netsoc_disable_distribution(poe);
@@ -515,12 +515,12 @@ int __netsoc_init_poe(poe_t *poe)
 	if (poe->poe_address_map > 0ULL && poe->poe_address_len > 0) 
         	__netsoc_init_poe_enq_deq_spill(poe, poe->poe_address_map, poe->poe_address_len);
 
-	if (is_nlm_xlp9xx()) {
+	if (IS_NLM_XLP9XX_FAMILY) {
 		__netsoc_init_poe_din_spill(poe, poe->din_spill_base, poe->din_spill_size, 0x8);  //0x28
 	}
 
         if (poe->dist_en == 1) {
-		if (is_nlm_xlp9xx()) {
+		if (IS_NLM_XLP9XX_FAMILY) {
                         for(index = 0; index <4; index++) { /*thr sel index 0 .. 3 */
                         __netsoc_v1_config_thrsel(poe, index, 0);      
                         }
@@ -559,7 +559,7 @@ int __netsoc_init_poe(poe_t *poe)
         netsoc_write_poe_pcie_reg(poe_pcie_base, POE_FBP_SP_EN, 0x1);
         netsoc_write_poe_pcie_reg(poe_pcie_base, POE_EXT_ALLOC_EN, 1);
 
-	if (is_nlm_xlp9xx()) {
+	if (IS_NLM_XLP9XX_FAMILY) {
 	        netsoc_write_poe_pcie_reg(poe_pcie_base, POE_TX_TIMER, 0x2);
 		netsoc_write_poe_pcie_reg(poe_pcie_base, 0x184, 0x300);
 		netsoc_write_poe_pcie_reg(poe_pcie_base, 0x183, 0x10);
diff --git a/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c b/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
index ced23a0..427fe6f 100644
--- a/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
@@ -80,7 +80,7 @@ extern unsigned char pma2p0_mem_16G [256];
 extern void pma2p0_mem_init_sgmii_125Mhzrefclk(void);
 extern void nlm_hal_config_pma2p0_mem_sgmii_4page_125Mhz(void);
 
-#define CHECK_SOC_VERSION	if (is_nlm_xlp9xx())
+#define CHECK_SOC_VERSION	if (IS_NLM_XLP9XX_FAMILY)
 
 //#define MACSEC_DEBUG 1
 //#define INCLUDE_NAE_DEBUG 1
@@ -3149,7 +3149,7 @@ static int parse_vfbid_config(void *fdt, int node)
 static inline int get_num_ports(int block, int intf_type)
 {
 	if (intf_type == SGMII_IF) {
-		if(is_nlm_xlp9xx() && block==2){
+		if(IS_NLM_XLP9XX_FAMILY && block==2){
 			return 1;
 		}else if (block < 4)
 			return 4;
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
index e253218..f86cafd7 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
@@ -229,6 +229,8 @@ extern int is_nlm_xlp(unsigned int chipid, unsigned int rev,  unsigned int ext);
 #define is_nlm_xlp516() is_nlm_xlp516_rev(XLP_REVISION_ANY)
 #define is_nlm_xlp5xx()	     is_nlm_xlp5xx_rev(XLP_REVISION_ANY)
 
+#define IS_NLM_XLP9XX_FAMILY   (is_nlm_xlp9xx() || is_nlm_xlp5xx())
+
 #endif /*__XLP_CHIPID_MACROS__ */
 
 #endif /* __ASSEMBLY__ */
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal_cpu_info.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal_cpu_info.c
index db7d1d6..e41dbdf 100644
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal_cpu_info.c
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal_cpu_info.c
@@ -339,7 +339,7 @@ static inline int is_xlp5xx(uint8_t num_cores, uint8_t num_threads, uint32_t rev
 	{
 		return 1;
 	}
-
+	return 0;
 }
 
 static inline int is_xlp3xx(uint8_t num_cores, uint8_t num_threads, uint32_t rev, uint32_t exttype)
@@ -566,6 +566,7 @@ static const char*  nlm_hal_get_chipid_str(void)
 	if(is_nlm_xlp101()) return "XLP101";
 
 	if(is_nlm_xlp9xx()) return "XLP9XX";
+	if(is_nlm_xlp5xx()) return "XLP5XX";
 
 	return "XLP???";
 }
-- 
1.9.1

