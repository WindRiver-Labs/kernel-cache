From 3ea0773069460c333c2388b78c1ba61c9eb10daf Mon Sep 17 00:00:00 2001
From: Mehul Vora <vmehul@netlogicmicro.com>
Date: Tue, 4 Oct 2011 04:42:25 -0700
Subject: [PATCH 1077/1532] Fix nae-perf driver for little endian mode.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/nae-perf/xlp_nae.c | 39 ++++++++++++++++++++++----------
 1 file changed, 27 insertions(+), 12 deletions(-)

diff --git a/drivers/misc/netlogic/nae-perf/xlp_nae.c b/drivers/misc/netlogic/nae-perf/xlp_nae.c
index 0f956dc..31eed4c 100755
--- a/drivers/misc/netlogic/nae-perf/xlp_nae.c
+++ b/drivers/misc/netlogic/nae-perf/xlp_nae.c
@@ -143,6 +143,8 @@ module_param(enable_lro, int, 0);
 int frin_desc_thres = 24;
 module_param(frin_desc_thres, int, 0);
 
+static uint32_t frin_queue_base = 1000;
+static uint32_t frin_total_queue = 18;
 static uint32_t nae_rx_vc = 0;
 static uint32_t nae_fb_vc = 0;
 /***************************************************************/
@@ -486,18 +488,17 @@ static inline int create_p2p_desc(uint64_t paddr, uint64_t len, uint64_t *p2pmsg
 	int plen;
 	do {
 		plen = len >= MAX_PACKET_SZ_PER_MSG ? (MAX_PACKET_SZ_PER_MSG - 64): len;
-		p2pmsg[idx] = nae_tx_desc(P2D_NEOP, 0, NULL_VFBID, plen, paddr);
+		p2pmsg[idx] = cpu_to_be64(nae_tx_desc(P2D_NEOP, 0, NULL_VFBID, plen, paddr));
 		len -= plen;
 		paddr += plen;
 		idx++;
-
 	} while(len > 0);
 	return idx;
 }
 
 static inline void create_last_p2p_desc(uint64_t *p2pmsg, struct sk_buff *skb, int idx)
 {
-	p2pmsg[idx - 1] |= ((uint64_t)P2D_EOP << 62);
+	p2pmsg[idx -1 ] = cpu_to_be64(be64_to_cpu(p2pmsg[idx - 1]) | ((uint64_t)P2D_EOP << 62));
 	p2pmsg[P2P_SKB_OFF] = (uint64_t)skb;
 }
 
@@ -834,7 +835,7 @@ static int mac_refill_frin_one_buffer(struct net_device *dev, int cpu)
 	skb->dev = ndev;
 	mac_put_skb_back_ptr(skb);
 	if(nlm_mode[LAST_RCVD_INDEX(cpu)] == NLM_RT_MODE)
-		return mac_refill_frin_skb((unsigned long long)virt_to_bus(skb->data), 1000 + (cpu/2));
+		return mac_refill_frin_skb((unsigned long long)virt_to_bus(skb->data), frin_queue_base + (cpu/2));
 	else
 		return mac_refill_frin_skb((unsigned long long)virt_to_bus(skb->data), priv->nae_rx_qid);
 }
@@ -978,10 +979,10 @@ xlp_poll_lower(int budget, int cpu)
 
 		if (err) {
 			if(nlm_mode[LAST_RCVD_INDEX(cpu)] == NLM_RT_MODE){
-				mac_refill_frin_skb(addr, 1000 + (cpu/2));
+				mac_refill_frin_skb(addr, frin_queue_base + (cpu/2));
 			}
 			else{
-				int qid = 1000 + context * 4;
+					int qid = frin_queue_base + context * 4;
 			        if(context >= 4)
 					qid = 1016 + context - 4;
 				mac_refill_frin_skb(addr, qid);
@@ -1269,16 +1270,16 @@ static void nlm_replenish_per_cpu_buffer(void)
 {
 	int i;
 	int vc_index = 0;
-        int mflags, code;
-        struct xlp_msg msg;
+	int mflags, code;
+	struct xlp_msg msg;
 	struct sk_buff * skb;
 	int ret = 0;
 
 	/*Using 16 rx_free_in_fifo (1 per 2 cpu)
 	  Allocate 16 buffers per queue.*/
-	for(i = 0; i < 18*16; i++)
+	for(i = 0; i < frin_total_queue*16; i++)
 	{
-		vc_index = (i/16) + 1000;
+		vc_index = (i/16) + frin_queue_base;
 		skb = nlm_xlp_alloc_skb_atomic();
 		if(!skb)
 		{
@@ -1343,8 +1344,13 @@ static void nlm_xlp_nae_init(void)
 		nlm_mode[LAST_RCVD_INDEX(i)] = perf_mode;
 
 	/*Disable interrupts for VC - 0-127*/
-	for(vc=0; vc<128; vc++)
-		nlm_hal_disable_vc_intr(vc);
+
+	for(i=0; i<NR_CPUS; i++){
+		if(!cpu_isset(i, cpu_online_map))
+			continue;
+		for(vc=0; vc<4; vc++)
+			nlm_hal_disable_vc_intr(i*4 + vc);
+	}
 
 	nlm_update_ucore_shared_memory();
 
@@ -1357,6 +1363,15 @@ static void nlm_xlp_nae_init(void)
 	nae_fb_vc = nae_cfg.fb_vc;
 	nae_rx_vc = nae_cfg.rx_vc;
 
+
+	if(nae_cfg.frin_queue_base != 0)
+		frin_queue_base = nae_cfg.frin_queue_base;
+
+	if(nae_cfg.frin_total_queue != 0)
+		frin_total_queue = nae_cfg.frin_total_queue;
+
+	printk("nae_cfg: frin_queue_base %d, frin_total_queue %d\n",nae_cfg.frin_queue_base, nae_cfg.frin_total_queue);
+
 	for(i = 0; i < nae_cfg.num_ports; i++)
 	{
 		/* Register only valid ports which are management */
-- 
1.9.1

