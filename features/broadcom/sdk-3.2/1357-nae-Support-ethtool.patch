From 59900ac5ed58a8f99d6c319c7891941ea9659256 Mon Sep 17 00:00:00 2001
From: Kopal <kopal@broadcom.com>
Date: Thu, 3 May 2012 15:12:56 +0530
Subject: [PATCH 1357/1532] nae: Support ethtool.

Added support to read and set mac address using ethtool.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/xlp_hw.c | 55 ++++++++++++++++++++++++++++--
 1 file changed, 53 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/xlp_hw.c b/drivers/net/ethernet/broadcom/nae/xlp_hw.c
index 6406810..8cfc051 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_hw.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_hw.c
@@ -40,12 +40,15 @@
 
 #include <asm/netlogic/xlr_mac.h>
 #include <asm/netlogic/hal/nlm_hal_nae.h>
+#include <asm/netlogic/hal/nlm_eeprom.h>
 #include "xlp_nae.h"
 
-
+#define FACTOR             3
 #define NLM_NUM_REG_DUMP 9 /* Register 0xa0 to 0xa8 */
+#define NLM_EEPROM_DUMP    16
 #define NLM_ETHTOOL_REG_LEN (NLM_NUM_REG_DUMP * 4)
 #define PHY_STATUS_RETRIES 25000
+#define NLM_EEPROM_LEN (NLM_EEPROM_DUMP * FACTOR)
 
 #define DRV_NAME	"xlp_nae"
 #define DRV_VERSION     "0.1"
@@ -55,7 +58,7 @@ static unsigned int nlm_xlp_mac_mii_read(struct dev_data *priv, int regidx);
 void nlm_xlp_mac_set_enable(struct dev_data *priv, int flag);
 static int xlp_enable_autoneg(struct net_device *dev, u32 adv);
 static int xlp_set_link_speed(struct net_device *dev, int speed, int duplex);
-
+extern struct eeprom_data *get_nlm_eeprom(void);
 static int xlp_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
 	struct dev_data *priv = netdev_priv(dev);
@@ -206,6 +209,50 @@ static int xlp_get_regs_len(struct net_device *dev)
 {
 	return NLM_ETHTOOL_REG_LEN;
 }
+
+static int xlp_get_eeprom_len(struct net_device *dev)
+{
+        return NLM_EEPROM_LEN;
+}
+
+static int xlp_get_eeprom(struct net_device *dev,
+                                struct ethtool_eeprom *eeprom, u8* temp)
+{
+        int i=0;
+        struct eeprom_data *nlm_eeprom=NULL;
+        struct dev_data *priv = netdev_priv(dev);
+        unsigned long flags;
+        u8 buff[50];
+        nlm_eeprom = get_nlm_eeprom();
+
+        spin_lock_irqsave(&priv->lock, flags);
+
+        eeprom_dump(nlm_eeprom, buff, eeprom->offset,eeprom->len);
+
+        for(i=0;i<eeprom->len;i++)
+        {
+                temp[i] = buff[i];
+        }
+        spin_unlock_irqrestore(&priv->lock, flags);
+
+        return 0;
+}
+
+static int xlp_set_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom, u8* temp)
+{
+        u8 data[6];
+        struct eeprom_data *nlm_eeprom=NULL;
+        nlm_eeprom = get_nlm_eeprom();
+        eeprom_get_mac_addr(nlm_eeprom,data,0);
+        if(eeprom->magic==0xAA){
+
+                data[eeprom->offset]= *temp;
+                eeprom_set_mac_addr(nlm_eeprom, data, 0);
+        }
+
+        return 0;
+}
+
 static void xlp_get_regs(struct net_device *dev,
 				struct ethtool_regs *regs, void *p)
 {
@@ -457,6 +504,10 @@ static struct ethtool_ops xlp_ethtool_ops= {
         .get_strings            = xlp_get_strings,
         .get_stats_count        = xlp_get_stats_count,
         .get_ethtool_stats      = xlp_get_ethtool_stats,
+	.get_eeprom_len         = xlp_get_eeprom_len,
+        .get_eeprom             = xlp_get_eeprom,
+        .set_eeprom             = xlp_set_eeprom,
+
 };
 
 void xlp_set_ethtool_ops(struct net_device *netdev)
-- 
1.9.1

