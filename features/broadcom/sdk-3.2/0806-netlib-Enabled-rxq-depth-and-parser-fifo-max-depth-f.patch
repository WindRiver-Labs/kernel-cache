From 33d9d7e6082f096f91580c44791098188b57ff99 Mon Sep 17 00:00:00 2001
From: Jayanthi A <jayanthi.annadurai@broadcom.com>
Date: Wed, 9 Oct 2013 01:50:55 -0700
Subject: [PATCH 0806/1532] netlib: Enabled rxq depth and parser fifo max depth
 for xlaui interface

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../netlogic/lib/netlib/include/netsoc_common.h    | 14 +++-
 .../netlogic/lib/netlib/include/netsoc_haliface.h  |  5 ++
 .../mips/netlogic/lib/netlib/include/nlm_hal_nae.h |  2 +
 arch/mips/netlogic/lib/netlib/include/nlm_nae.h    |  1 +
 arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c     | 21 ++++++
 arch/mips/netlogic/lib/netlib/src/netsoc_nae.c     | 84 +++++++++++++++++++---
 arch/mips/netlogic/lib/netlib/src/netsoc_poe.c     | 11 ++-
 7 files changed, 124 insertions(+), 14 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
index fc99f91..4d798a1 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
@@ -80,7 +80,6 @@
 #define DEFAULT_XLP2XX_XAUI_PARSERSEQFIFO_SZ    480
 
 
-
 typedef struct {
         uint32_t iftype[5];
         union {
@@ -343,6 +342,19 @@ static inline uint32_t get_prsr_seq_fifo_size(uint32_t intf_type)
         }
 }
 
+static inline uint32_t update_prsr_seq_fifo_size(nae_t *nae, uint32_t *size)
+{
+
+	*size = (current_netsoc->ingress.max_parseq_fifo / nae->num_ports);
+	return 0;
+}
+
+static inline uint32_t update_rx_buf_size(nae_t *nae, uint32_t *size)
+{
+	*size = (((current_netsoc->ingress.max_rx_fifo / 16) / nae->num_contexts) >> 2);
+	return 0;
+}
+
 static inline uint32_t get_rx_buf_size(uint32_t intf_type)
 {
         switch(intf_type) {
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
index 491169b..644d22e 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
@@ -32,7 +32,11 @@
 #define __BRCM_NETSOC_HALIFACE_H
 
 #include "nlm_hal.h"
+#ifndef NLM_HAL_UBOOT
 #include "xlp9xx_sys.h"
+#else
+#include <asm/arch/xlp_sys.h>
+#endif
 #include "netsoc_dev.h"
 #include "nlm_nae.h"
 #include "nlm_hal_nae.h"
@@ -42,6 +46,7 @@
 #include "xlp9xx_netsoc.h"
 #include "netsoc_common.h"
 #include "ext_phy.h"
+#include "nlm_hal_fmn.h"
 
 extern uint32_t socnet_version_v0;
 extern struct netsoc_info *current_netsoc;
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
index 6e28f31..d460725 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
@@ -57,6 +57,8 @@
 
 #define XLP_MAX_FLOWS       (64 << 10)
 
+#define XLP9XX_MAX_FLOWS    (32 << 10)
+
 #define SGMII_CAL_SLOTS         3
 //#define XAUI_CAL_SLOTS          13
 #define XAUI_CAL_SLOTS          5
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
index 645eb9f..cd5414c 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -392,6 +392,7 @@ struct nlm_hal_nae_config {
         uint32_t ale_enable;
 	uint32_t parser_enable;
 	uint32_t freein_uniq_sz;
+	uint32_t ptp1588_enabled;
         /* POE */
 	poe_t *poe;
 };
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index 3177fc0..145cf9f 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -1342,6 +1342,26 @@ int fdt_get_nae_parser_config(void *fdt, nae_t *nae)
         return 0;
 }
 
+int fdt_get_nae_ptp_config(void *fdt, nae_t *nae)
+{
+        int nodeoffset, plen;
+        char path_str[50];
+        uint32_t *pval;
+
+        sprintf(path_str, "/soc/net@node-%d/nae-%d", nae->node, nae->nae_id);
+        nodeoffset = fdt_path_offset(fdt, path_str);
+        if (nodeoffset >= 0) {
+              pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "ptp1588-enable", &plen);
+              if (pval != NULL) {
+                      nae->ptp1588_enabled = fdt32_to_cpu(*(uint32_t *)(pval));
+              }
+              else {  
+                      nae->ptp1588_enabled = 1;
+              }
+        }
+        return 0;
+}
+
 int fdt_get_nae_frindesc_mode(void *fdt, nae_t *nae)
 {
         int nodeoffset, plen;
@@ -1387,6 +1407,7 @@ int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae)
             fdt_get_nae_ale_config(fdt, nae);
 
 	fdt_get_nae_parser_config(fdt, nae);
+	fdt_get_nae_ptp_config(fdt, nae);
 	fdt_get_nae_frindesc_mode(fdt, nae);
 
 	fdt_get_dom_nae_node_ownership(fdt, dom_id, nae);
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index bbf2384..c574c3f 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -35,7 +35,11 @@
 #include "netsoc_haliface.h"
 #include "netsoc_libiface.h"
 #include "ext_phy.h"
+#ifndef NLM_HAL_UBOOT
 #include "xlp9xx_sys.h"
+#else
+#include <asm/arch/xlp_sys.h>
+#endif
 
 static unsigned int ucore_shared_scratch[NLM_MAX_NODES][XLP9XX_MAX_NAE_PERNODE][256];
 static unsigned int ucore_shared_scratch_words[NLM_MAX_NODES][XLP9XX_MAX_NAE_PERNODE];
@@ -994,7 +998,12 @@ void __netsoc_config_flow_base(nae_t *nae)
         int port = 0, hw_port = 0;
         int flow_mask = __netsoc_get_flow_mask(nae->num_ports);
         uint32_t reg, cur_flow_base = 0;
-	uint32_t per_port_num_flows = XLP_MAX_FLOWS / nae->num_ports;
+	uint32_t per_port_num_flows;
+
+	if (is_nlm_xlp9xx())
+		per_port_num_flows = XLP9XX_MAX_FLOWS / nae->num_ports;
+	else	
+		per_port_num_flows = XLP_MAX_FLOWS / nae->num_ports;
 
 	for (port = 0, hw_port = 0 ; port < nae->num_ports; hw_port++) {
             if (hw_port == nae->ports[port].hw_port_id) {
@@ -1139,6 +1148,15 @@ void __netsoc_config_context_xoff_thr(nae_t *nae, net_port_t *netport, int thgrp
          send xoff when rx_data_buffer_used >= xoff threshold */
         int xoff, xon, val, reaction_len, inflight_len;
 
+	if (netport->iftype == XLAUI_IF) {
+		maxbuf /= 4;
+		val = maxbuf / 4;
+                xoff = ((val * 3) << 2);
+		xon = ((val * 2) << 2);
+		val = (xoff << 3) | (xon << 17) | thgrp;
+	}else {
+
+ 
         if (netport->iftype == SGMII_IF)
         {
                 reaction_len = NAE_REACTION_LEN_SGMII;
@@ -1163,6 +1181,7 @@ void __netsoc_config_context_xoff_thr(nae_t *nae, net_port_t *netport, int thgrp
         xon = xoff - NAE_THR_SEPARATION;
 
 	val = (xoff << 3) | (xon << 17) | thgrp;
+	}
 	netsoc_write_nae_reg(nae->nae_base, RX_BUFFER_XONOFF_THR, thgrp);
 	netsoc_write_nae_reg(nae->nae_base, RX_BUFFER_XONOFF_THR, val);
 
@@ -1237,24 +1256,46 @@ void __netsoc_config_parserfifo(nae_t *nae, int hw_port_id, uint32_t start, uint
 {
 	volatile uint32_t val;
 	uint32_t xon, xoff;
+        static uint32_t prev_size = 0;
+
+	if (nae->ptp1588_enabled) { 
+                // MD is zero, 1024 entries
+                val = 0;
+        }
+        else {
+                // MD is one, 2048 entries
+                val = (1<<30);
+        }
 
-	val = ((size & 0x1fff) << 17) | ((start & 0xfff) << 5) | (hw_port_id & 0x1f);
+	val |= ((size & 0x1fff) << 17) | ((start & 0xfff) << 5) | (hw_port_id & 0x1f);
         netsoc_write_nae_reg(nae->nae_base, PARSER_SEQ_FIFO_CFG, val);
 
 	/*
 	   FIFO xoff threshold: high. When #entries used rises to this specified number.
 	   FIFO xon threshold: low.  When #entries used fall to this specified number.
 	   */
+        if (size == 0)
+		size = prev_size;
+	else
+		prev_size = size;
+
 	if (size != 0)
 	{
-		xoff = (size/4) - 2;
-		xon = (size/8) - 1;
+		xoff = size - 30 ;
+		xon = (size/4) * 2;
 		val = (xoff<<12) | (xon);
 		netsoc_write_nae_reg(nae->nae_base, PARSER_SEQ_FIFOTH_CFG, val);
 	}
 
-	// MD is zero, 1024 entries
-	val = (1<<31) | (hw_port_id & 0x1f);
+	if (nae->ptp1588_enabled) {
+		// MD is zero, 1024 entries
+		val = (1<<31) | (hw_port_id & 0x1f);
+	}
+	else {
+		// MD is one, 2048 entries
+		val = (1<<31) | (1<<30) | (hw_port_id & 0x1f);
+	}
+
 	netsoc_write_nae_reg(nae->nae_base, PARSER_SEQ_FIFO_CFG, val);
 	val = netsoc_read_nae_reg(nae->nae_base, PARSER_SEQ_FIFO_CFG);
 	netsoc_api_print(NETSOC_APIDBG_CONFIG,"PARSER_SEQ_FIFO_CFG port %d fcsz %d fcstart %d\n", hw_port_id,
@@ -1275,7 +1316,7 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 
 	max_ports = __netsoc_get_max_ports();
         netsoc_api_print(NETSOC_APIDBG_CONFIG, "Interface FIFO carving max_ports:%d \n", max_ports);
-        for (port = 0, hw_port = 0 ; hw_port <= max_ports; ) {
+        for (port = 0, hw_port = 0 ; hw_port < max_ports; ) {
 	    if (hw_port == nae->ports[port].hw_port_id) {
 
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "port:%d iftype:%d\n", port, nae->ports[port].iftype);
@@ -1304,6 +1345,7 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 			thrgrp = 3;
 			break;
 		   case SGMII_IF:
+			thrgrp = 0;
 			fifo_xoff_thresh = 6;
 			rx_buf_size = nae->ports[port].rx_buf_size;
 			break;
@@ -1314,7 +1356,11 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 			fifo_xoff_thresh = 0;
 			break;
                 }
-		 offset = max_lanes = get_max_lanes(nae->ports[port].iftype);
+
+		if (nae->sgmii_complex_map == 0)
+			update_rx_buf_size(nae, &rx_buf_size);
+
+		offset = max_lanes = get_max_lanes(nae->ports[port].iftype);
 
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "cfg rxbuffer n:%d port:%d ctx_base:%d ch:%d rx_buf_base:%X buf_sz:%d\n",
 			nae->node, hw_port, context_base, nae->ports[port].num_channels,
@@ -1327,9 +1373,6 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 			xonxoff_done[nae->node][nae->nae_id][thrgrp] = 1;
 			__netsoc_config_context_xoff_thr(nae, &nae->ports[port], thrgrp,  (rx_buf_size << 2) / nae->ports[port].num_channels, NAE_MTU_LEN);
 		}
-		else
-			thrgrp = 0;
-
 
 		__netsoc_config_rxbuffer(nae, context_base,nae->ports[port].num_channels,
                                         rx_buf_base, nae->ports[port].rx_buf_size, thrgrp);
@@ -1358,6 +1401,9 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 			}
 
 			size = ((lane == 0) ? nae->ports[port].prsr_seq_fifo_size : 0);
+			if ((is_nlm_xlp9xx()) && (nae->ptp1588_enabled == 0) && size)
+				update_prsr_seq_fifo_size(nae, &size);
+
 			__netsoc_config_parserfifo(nae, nae->ports[port].hw_port_id + lane, cur_parser_base, size);
 			cur_parser_base += size;
 		}
@@ -3732,6 +3778,12 @@ static int __netsoc_config_freein_fifo(nae_t *nae)
                                 nae->freein_fifo_onchip_num_descs[fifo] = 0;
                         }
                 }
+		if (is_nlm_xlp9xx()) {
+			sfifo = current_netsoc->max_ports;
+			for(fifo = sfifo; fifo < freein_fifo_total_queues; fifo++) {
+                                nae->freein_fifo_onchip_num_descs[fifo] = 0;
+                        }
+		}
         }
 
 	spill_mem_addr = nae->freein_spill_base;
@@ -4041,6 +4093,16 @@ int __netsoc_init_nae(nae_t *nae)
                  }
                  else
                          nae->msec_rx_port_enable =  nae->msec_tx_port_enable = 0;
+
+		if (is_nlm_xlp9xx()) {
+			if (nae->xlgmac_complex_map) {
+				if (nae->nae_id == 0)
+					nlm_hal_enable_rxqdepth(nae->node, XLP_9XX_NET0_TX_VC_BASE);
+				else
+					nlm_hal_enable_rxqdepth(nae->node, XLP_9XX_NET1_TX_VC_BASE);
+			}
+		}
+
 	}
 	return NETSOC_API_SUCCESS;
 }
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c b/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c
index 773f51a..7fb3ff2 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c
@@ -378,7 +378,7 @@ int __netsoc_init_poe(poe_t *poe)
         	__netsoc_init_poe_enq_deq_spill(poe, poe->poe_address_map, poe->poe_address_len);
 
 	if (is_nlm_xlp9xx()) {
-		__netsoc_init_poe_din_spill(poe, poe->din_spill_base, poe->din_spill_size, 0x28); 
+		__netsoc_init_poe_din_spill(poe, poe->din_spill_base, poe->din_spill_size, 0x8);  //0x28
 	}
 
         if (poe->dist_en == 1) {
@@ -421,7 +421,14 @@ int __netsoc_init_poe(poe_t *poe)
         netsoc_write_poe_pcie_reg(poe_pcie_base, POE_FBP_SP_EN, 0x1);
         netsoc_write_poe_pcie_reg(poe_pcie_base, POE_EXT_ALLOC_EN, 1);
 
-        netsoc_write_poe_pcie_reg(poe_pcie_base, POE_TX_TIMER, 0x2);
+	if (is_nlm_xlp9xx()) {
+	        netsoc_write_poe_pcie_reg(poe_pcie_base, POE_TX_TIMER, 0x2);
+		netsoc_write_poe_pcie_reg(poe_pcie_base, 0x184, 0x300);
+		netsoc_write_poe_pcie_reg(poe_pcie_base, 0x183, 0x11);
+	}
+	else {
+		netsoc_write_poe_pcie_reg(poe_pcie_base, POE_TX_TIMER, 0x3);
+	}
 
 	return NETSOC_API_SUCCESS;
 }
-- 
1.9.1

