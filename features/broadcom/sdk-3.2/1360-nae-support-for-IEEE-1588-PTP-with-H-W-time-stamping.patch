From acc3f74d58aa605d4b62e2fe3f38aa0ba74422ad Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikas.gupta@broadcom.com>
Date: Thu, 10 May 2012 12:41:59 +0530
Subject: [PATCH 1360/1532] nae: support for IEEE-1588 PTP with H/W time
 stamping

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/init_nae.c |   9 ++
 drivers/net/ethernet/broadcom/nae/xlp_hw.c   |   3 +
 drivers/net/ethernet/broadcom/nae/xlp_nae.c  | 185 +++++++++++++++++++++++++--
 drivers/net/ethernet/broadcom/nae/xlp_nae.h  |  16 ++-
 4 files changed, 197 insertions(+), 16 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/init_nae.c b/drivers/net/ethernet/broadcom/nae/init_nae.c
index 4ef64d9..658ea69 100644
--- a/drivers/net/ethernet/broadcom/nae/init_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/init_nae.c
@@ -5,6 +5,9 @@
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
+#include <linux/net_tstamp.h>
+#include <linux/clocksource.h>
+#include <linux/timecompare.h>
 #include <linux/inet_lro.h>
 #include <asm/netlogic/msgring.h>
 #include <asm/netlogic/cpumask.h>
@@ -113,6 +116,9 @@ static int nlm_initialize_vfbid(int node, nlm_nae_config_ptr nae_cfg)
 	/* NULL FBID Should map to cpu0 to detect NAE send message errors*/
 	vfbid_tbl[127] = 0;
 	nlm_config_vfbid_table(node, 127, 1, &vfbid_tbl[127]);
+	/*IEEE-1588 timestamp*/
+	vfbid_tbl[126] = 0;
+	nlm_config_vfbid_table(node, 126, 1, &vfbid_tbl[126]);
 	return 0;
 }
 
@@ -222,6 +228,9 @@ int initialize_nae(unsigned int *phys_cpu_map, int mode, int *jumbo_enabled)
 		}
 
 		dump_lnx_shinfo(node);
+#ifdef IEEE_1588_PTP_ENABLED
+		nlm_hal_prepad_enable(node, 3);
+#endif
 	}
 
 	for(node = 0; node < NLM_MAX_NODES; node++) {
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_hw.c b/drivers/net/ethernet/broadcom/nae/xlp_hw.c
index 70fe001..09ac1b2 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_hw.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_hw.c
@@ -37,6 +37,9 @@
 #include <linux/etherdevice.h>
 #include <linux/mii.h>
 #include <linux/inet_lro.h>
+#include <linux/net_tstamp.h>
+#include <linux/clocksource.h>
+#include <linux/timecompare.h>
 
 #include <asm/netlogic/xlr_mac.h>
 #include <asm/netlogic/hal/nlm_hal_nae.h>
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index 2dae935..25ec751 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -48,6 +48,9 @@
 #include <linux/pci.h>
 #include <linux/kthread.h>
 #include <linux/inet_lro.h>
+#include <linux/net_tstamp.h>
+#include <linux/clocksource.h>
+#include <linux/timecompare.h>
 
 #include <net/ip.h>
 
@@ -69,8 +72,7 @@
 #define NLM_TCP_MODE	1
 #define NLM_RT_MODE	2
 
-/* Applicable only in tcp mode */
-#define TSO_ENABLED 	1
+#define TSO_ENABLED	1 
 
 /*Enable sanity checks while receiving or transmitting buffer */
 #undef ENABLE_SANITY_CHECKS
@@ -141,6 +143,9 @@ static struct p2p_desc_mem p2p_desc_mem[NR_CPUS] __cacheline_aligned;
 static struct net_device_stats *nlm_xlp_mac_get_stats(struct net_device *dev);
 static struct net_device *dev_mac[NLM_MAX_NODES][MAX_GMAC_PORT];
 
+/*1588 ptp cycle counter */
+static uint64_t acc_1588[NLM_MAX_NODES];	
+
 extern void xlp_set_ethtool_ops(struct net_device *netdev);
 extern void xlp_get_mac_stats(struct net_device* dev, struct net_device_stats* stats);
 static void nlm_xlp_nae_init(void);
@@ -154,6 +159,13 @@ static int  nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu);
 static void  nlm_xlp_nae_tx_timeout (struct net_device *dev);
 static void xlp_mac_setup_hwaddr(struct dev_data *priv);
 static int nlm_xlp_nae_set_hwaddr(struct net_device *dev, void *p);
+#ifdef IEEE_1588_PTP_ENABLED	
+static void nlm_1588_ptp_hwtstamp_tx(struct sk_buff *skb);
+#endif
+static cycle_t nlm_1588_read_clock0(const struct cyclecounter *tc);
+static cycle_t nlm_1588_read_clock1(const struct cyclecounter *tc);
+static cycle_t nlm_1588_read_clock2(const struct cyclecounter *tc);
+static cycle_t nlm_1588_read_clock3(const struct cyclecounter *tc);
 extern void nlm_xlp_mac_set_enable(struct dev_data *priv, int flag);
 extern struct proc_dir_entry *nlm_root_proc;
 extern struct eeprom_data * get_nlm_eeprom(void);
@@ -194,6 +206,26 @@ static __inline__ void cpu_halt(void)
 		);
 }
 
+static cycle_t nlm_1588_read_clock0(const struct cyclecounter *tc)
+{
+	return acc_1588[0];
+}
+
+static cycle_t nlm_1588_read_clock1(const struct cyclecounter *tc)
+{
+	return acc_1588[1];
+}
+
+static cycle_t nlm_1588_read_clock2(const struct cyclecounter *tc)
+{
+	return acc_1588[2];
+}
+
+static cycle_t nlm_1588_read_clock3(const struct cyclecounter *tc)
+{
+	return acc_1588[3];
+}
+
 static void gen_mac_address(void)
 {
 	struct eeprom_data *nlm_eeprom=NULL;
@@ -619,10 +651,34 @@ static int nae_proc_read(char *page, char **start, off_t off,
 	return len;
 }
 
+#ifdef IEEE_1588_PTP_ENABLED	
+static void nlm_1588_ptp_hwtstamp_tx(struct sk_buff *skb)
+{
+	struct skb_shared_hwtstamps shhwtstamps;
+	uint64_t regval;
+	uint64_t ns;
+	
+	
+	struct dev_data *priv = netdev_priv(skb->dev);
+	int if_num = priv->hw_port_id;
+	int node = priv->node;
+
+	memset(&shhwtstamps, 0, sizeof(shhwtstamps));
+	regval = nlm_hal_ptp_timer_lo(node, if_num);
+	regval |= (uint64_t)nlm_hal_ptp_timer_hi(node, if_num)<<32;
+	acc_1588[node] = regval;
+	ns = timecounter_cyc2time(&priv->clock, regval);
+	timecompare_update(&priv->compare, ns);
+	shhwtstamps.hwtstamp = ns_to_ktime(ns);
+	shhwtstamps.syststamp =	timecompare_transform(&priv->compare, ns);
+	skb_tstamp_tx(skb, &shhwtstamps);
+	Message("nlm_1588_ptp_hwtstamp_tx regval=0x%llx ns=0x%llx node=0x%x \n", regval, ns, node);	
+}
+#endif 
+
 static inline void process_tx_complete(int cpu, unsigned int src_id, unsigned long long msg0)
 {
 	struct sk_buff* skb;
-	struct dev_data *priv;
 #ifdef TSO_ENABLED
 	uint64_t *p2pfbdesc;
 #endif
@@ -655,7 +711,12 @@ static inline void process_tx_complete(int cpu, unsigned int src_id, unsigned lo
 
 	if(skb)
 	{
-		priv = netdev_priv(skb->dev);
+#ifdef IEEE_1588_PTP_ENABLED	
+		if(skb->sk && sock_flag(skb->sk, SOCK_TIMESTAMPING_TX_HARDWARE)) { 
+			nlm_1588_ptp_hwtstamp_tx(skb);
+		}
+#endif
+		
 		dev_kfree_skb_any(skb);
 	}
 	else {
@@ -674,6 +735,11 @@ static inline void process_rx_packets(int cpu, unsigned int src_id,
 	struct dev_data *priv = NULL;
 	uint64_t vaddr;
 	struct sk_buff* skb;
+#ifdef IEEE_1588_PTP_ENABLED
+	char *prepad = NULL;
+	uint64_t ns;
+	struct skb_shared_hwtstamps *shhwtstamps;
+#endif
 
 	err = (msg1 >> 4) & 0x1;
 
@@ -723,8 +789,8 @@ static inline void process_rx_packets(int cpu, unsigned int src_id,
 	priv = netdev_priv(pdev);
 
 	vaddr = (uint64_t)(unsigned long)bus_to_virt(addr);
-
-	len = len  - ETH_FCS_LEN;
+	
+	len = len  - ETH_FCS_LEN - PREPAD_LEN;
 
 	skb = mac_get_skb_back_ptr(vaddr);
 
@@ -739,6 +805,19 @@ static inline void process_rx_packets(int cpu, unsigned int src_id,
 	}
 #endif
 
+#ifdef IEEE_1588_PTP_ENABLED
+	prepad = (char *)skb->data + 56; /*ieee-1588 timestamp in prepad*/
+	shhwtstamps = skb_hwtstamps(skb);
+	ns = timecounter_cyc2time(&priv->clock, be64_to_cpu (*(unsigned long*)prepad));
+	acc_1588[node] = (be64_to_cpu (*(unsigned long*)prepad));
+	//Message("Node %d port %d prepad=0x%llx skb=%p ns=0x%llx\n", node, port, acc_1588[node], skb, ns);
+	timecompare_update(&priv->compare, ns);
+	memset(shhwtstamps, 0, sizeof(*shhwtstamps));
+	shhwtstamps->hwtstamp = ns_to_ktime(ns);
+	shhwtstamps->syststamp = timecompare_transform(&priv->compare, ns);
+	skb_reserve(skb, PREPAD_LEN);
+#endif
+
 	skb->dev = pdev;
 	skb_put(skb, len);
 	skb->protocol = eth_type_trans(skb, pdev);
@@ -813,6 +892,7 @@ static void xlp_napi_lro_flush(void *arg)
 }
 #endif
 
+
 /*
  * NAE poll function on freeback only if rx and freeback vcs are different
 */
@@ -835,6 +915,9 @@ static void xlp_poll_upper(int cpu)
 			if(status) break;
 			__sync();
 
+			if(msg0 & (0x200000000000000ULL)) /*IEEE-1588 timestamp*/
+				return;				
+
 			Message("poll upper cpu %d src_id %d size %d\n", cpu, src_id, size);
 			process_tx_complete(cpu, src_id, msg0);
 
@@ -870,7 +953,9 @@ static int xlp_poll_lower(int budget, int cpu)
 			continue;
 		}
 #endif
-		if(size == 2)
+		if(msg0 & (0x200000000000000ULL))
+			continue;
+		else if(size == 2)
 			process_rx_packets(cpu, src_id, msg0, msg1);
 		else if(size == 1)
 			process_tx_complete(cpu, src_id, msg0);
@@ -905,6 +990,9 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		 process_rx_packets(cpu, src_id, msg0, msg1);
 	else if(vc == nae_fb_vc && size == 1)
 		process_tx_complete(cpu, src_id, msg0);
+	else if(msg0 & (0x200000000000000ULL)){
+		return;
+	}
 	else {
 		printk("%s , Error invalid message, vc %d size %d\n", __FUNCTION__, vc, size);
 	}	
@@ -1153,8 +1241,34 @@ static void nlm_xlp_nae_init(void)
 			for(cpu = 0; cpu<NR_CPUS; cpu++){
 				per_cpu_netdev[node][cpu][i] = dev;
 			}
-
+			printk("configuring PTP realted params\n");
+		
+			if(node==0)
+				 priv->cycles.read = nlm_1588_read_clock0;
+			if(node==1)
+				 priv->cycles.read = nlm_1588_read_clock1;
+			if(node==2)
+				 priv->cycles.read = nlm_1588_read_clock2;
+			if(node==3)
+				 priv->cycles.read = nlm_1588_read_clock3;
+
+			priv->cycles.mask = CLOCKSOURCE_MASK(64);
+			priv->cycles.mult = 0x3; /*333MHz*/
+			priv->cycles.shift = 0; 
+		
+			timecounter_init(&priv->clock, &priv->cycles, ktime_to_ns(ktime_get_real()));
+			
+			memset(&priv->compare, 0, sizeof(priv->compare)); 	 
+			priv->compare.source = &priv->clock;
+			priv->compare.target = ktime_get_real;
+			priv->compare.num_samples = 0; /*we dont have a cyclecounter register so can't afford more samples */
+			timecompare_update(&priv->compare,0);
 		}
+		
+		nlm_hal_1588_ptp_clk_sel(node, NET_SYS_CLK);
+		nlm_hal_reset_1588_accum(node);
+		nlm_hal_1588_ld_user_val(node, 0, 0);
+		nlm_hal_1588_ld_freq_mul(node, 0x1, 0x0, 0x1);
 	}
 
 	entry = create_proc_read_entry("mac_stats", 0 /* def mode */ ,
@@ -1336,6 +1450,11 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 	int  ret, retry_cnt = 0, qid;
 	nlm_nae_config_ptr nae_cfg = nlm_node_cfg.nae_cfg[priv->node];
 	unsigned long __attribute__ ((unused)) mflags;
+#ifdef IEEE_1588_PTP_ENABLED
+	uint64_t msg1;
+	union skb_shared_tx *shtx;
+	int is_skbts = skb->sk && sock_flag(skb->sk, SOCK_TIMESTAMPING_TX_HARDWARE);
+#endif
 
 	p2pdesc = alloc_p2p_desc_mem(cpu);
 	if(p2pdesc == NULL) {
@@ -1390,7 +1509,10 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 
 	}
 
-	if((len = skb_headlen(skb)) != 0) {
+	if(((len = skb_headlen(skb)) != 0)) {
+#ifdef IEEE_1588_PTP_ENABLED	
+		if(!is_skbts)
+#endif
 		idx = create_p2p_desc(virt_to_bus((char *)skb->data), len, p2pdesc, idx);
 	}
 
@@ -1402,10 +1524,22 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 				fp->size, p2pdesc, idx);
 	}
 
-	create_last_p2p_desc(p2pdesc, skb, idx);
 
 	qid = nae_cfg->vfbtbl_sw_offset + (cpu % NLM_NCPUS_PER_NODE);
-	msg = nae_tx_desc(P2P, 0, qid, idx, virt_to_bus(p2pdesc));
+#ifdef IEEE_1588_PTP_ENABLED
+	if(is_skbts) {
+                p2pdesc[P2P_SKB_OFF] = (uint64_t)skb;
+                msg = nae_tx_desc (P2D_NEOP, 0, qid, 0, virt_to_bus(p2pdesc));
+                msg1 = nae_tx_desc (P2D_EOP, 0, 126, len, virt_to_bus((char *)skb->data));
+		shtx = skb_tx(skb);
+		shtx->in_progress = 1;
+	}else
+#endif
+	{
+		create_last_p2p_desc(p2pdesc, skb, idx);
+		msg = nae_tx_desc(P2P, 0, qid, idx, virt_to_bus(p2pdesc));
+	}
+	
 
 	tso_dbg("msg0 %llx p2pdesc0 %llx p2pdesc1 %llx p2pdesc2 %llx idx %d\n",
 			msg, p2pdesc[0], p2pdesc[1], p2pdesc[2], idx);
@@ -1417,6 +1551,11 @@ retry_send:
 		ret = nlm_hal_send_msg3(priv->nae_tx_qid, 0, mscmsg0, mscmsg1, msg);
 	else if(skb->ip_summed == CHECKSUM_PARTIAL)
 		ret = nlm_hal_send_msg2(priv->nae_tx_qid, 0, mscmsg0, msg);
+#ifdef IEEE_1588_PTP_ENABLED	
+	else if(is_skbts){
+		ret = nlm_hal_send_msg2(priv->nae_tx_qid, 0, msg, msg1);	
+	} 
+#endif
 	else
 		ret = nlm_hal_send_msg1(priv->nae_tx_qid, 0, msg);
 	msgrng_access_disable(mflags);
@@ -1459,6 +1598,10 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	volatile int hw_repl = 0;
 	int  offset, qid;
 	unsigned long __attribute__ ((unused)) mflags;
+#ifdef IEEE_1588_PTP_ENABLED	
+	union skb_shared_tx *shtx;
+#endif
+
 	nlm_nae_config_ptr nae_cfg = nlm_node_cfg.nae_cfg[priv->node];
 
 
@@ -1505,8 +1648,20 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 		Message("Tx, tx complete to cpu, cpu %d len %d qid %d\n", cpu, skb->len, qid);
 	}
-	msg1 = nae_tx_desc(P2D_EOP, 0, NULL_VFBID, skb->len,
-		       virt_to_bus(skb->data));
+	
+#ifdef IEEE_1588_PTP_ENABLED
+	if(skb->sk && sock_flag(skb->sk, SOCK_TIMESTAMPING_TX_HARDWARE)) {
+		msg1 = nae_tx_desc (P2D_EOP, 0, 126, skb->len, virt_to_bus((char *)skb->data));
+		shtx = skb_tx(skb);
+		shtx->in_progress = 1;
+		
+	}
+	else
+#endif
+	{
+		msg1 = nae_tx_desc(P2D_EOP, 0, NULL_VFBID, skb->len,
+			       virt_to_bus(skb->data));
+	}
 	if(hw_repl) {
 		/* reset the skb for next rx */
 
@@ -1588,7 +1743,11 @@ static void xlp_mac_setup_hwaddr(struct dev_data *priv)
 static int  nlm_xlp_nae_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int rc = 0;
+	printk("nlm_xlp_nae_ioctl called \n");
 	switch (cmd) {
+	case SIOCSHWTSTAMP:
+		printk("HW time stamping supported by HW\n");
+		return 0;
 	default:
 		rc = -EOPNOTSUPP;
 		break;
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.h b/drivers/net/ethernet/broadcom/nae/xlp_nae.h
index f299dd2..5a83408 100644
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.h
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.h
@@ -15,7 +15,12 @@
 #define ETH_FCS_LEN     4               /* Octets in the FCS             */
 #endif
 
-#define MAC_PREPAD		0
+
+#ifdef IEEE_1588_PTP_ENABLED
+#define PREPAD_LEN		64
+#else
+#define PREPAD_LEN   		0
+#endif
 #define BYTE_OFFSET		2
 #define ETH_JUMBO_DATA_LEN	16000
 
@@ -24,8 +29,8 @@
 
 #define SKB_BACK_PTR_SIZE	CACHELINE_SIZE
 
-#define NLM_RX_ETH_BUF_SIZE	(ETH_DATA_LEN+ETH_HLEN+ETH_FCS_LEN+BYTE_OFFSET+MAC_PREPAD+SKB_BACK_PTR_SIZE+CACHELINE_SIZE)
-#define NLM_RX_JUMBO_BUF_SIZE	(ETH_JUMBO_DATA_LEN+ETH_HLEN+ETH_FCS_LEN+BYTE_OFFSET+MAC_PREPAD+SKB_BACK_PTR_SIZE+CACHELINE_SIZE)
+#define NLM_RX_ETH_BUF_SIZE	(ETH_DATA_LEN+ETH_HLEN+ETH_FCS_LEN+BYTE_OFFSET+PREPAD_LEN+SKB_BACK_PTR_SIZE+CACHELINE_SIZE)
+#define NLM_RX_JUMBO_BUF_SIZE	(ETH_JUMBO_DATA_LEN+ETH_HLEN+ETH_FCS_LEN+BYTE_OFFSET+PREPAD_LEN+SKB_BACK_PTR_SIZE+CACHELINE_SIZE)
 
 extern unsigned long long netlib_vaddrb;
 extern unsigned long long netlib_paddrb;
@@ -94,6 +99,11 @@ struct dev_data
 	int hw_port_id;
 	struct net_lro_mgr lro_mgr[NR_CPUS];
 	struct net_lro_desc lro_arr[NR_CPUS][LRO_MAX_DESCS];
+	
+	/*1588 ptp timer*/
+	struct cyclecounter cycles;
+	struct timecounter clock;
+	struct timecompare compare;
 };
 
 static inline void prefetch_local(const void *addr)
-- 
1.9.1

