From 04421e2b8e735a33560dd0da0cc378c16c736309 Mon Sep 17 00:00:00 2001
From: Ganesan Ramalingam <ganesanr@broadcom.com>
Date: Fri, 4 Oct 2013 20:11:34 +0530
Subject: [PATCH 1188/1532] kmod: NMIprof: Fixes and improvements

Added following changes:

* Module get and put, to prevent unload while profiler is running.
* Resource free in proper order
* Return correct error message
* Help print depends on operation
* clear profiler buffer at start of each run
* write() returns the correct number of bytes.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/nmiprof/nmiprof-sys.c | 208 +++++++++++++++-------------
 1 file changed, 112 insertions(+), 96 deletions(-)

diff --git a/drivers/misc/netlogic/nmiprof/nmiprof-sys.c b/drivers/misc/netlogic/nmiprof/nmiprof-sys.c
index 6299afd..07c64e0 100644
--- a/drivers/misc/netlogic/nmiprof/nmiprof-sys.c
+++ b/drivers/misc/netlogic/nmiprof/nmiprof-sys.c
@@ -8,7 +8,7 @@
 #include <linux/device.h>
 #include <linux/platform_device.h>
 
-#include <asm-generic/getorder.h>
+#include <asm/page.h>
 
 #include "nmiprof.h"
 
@@ -20,9 +20,10 @@ struct nlm_nmiprof_dev {
 	struct bin_attribute binnmiprof_attr;
 	u64 *base;
 	int nlm_cpu;
+	int state;
 };
 
-struct nlm_nmiprof_dev *jdev;
+struct nlm_nmiprof_dev *ndev;
 
 static ssize_t nlm_nmiprof_read(struct file *filp, struct kobject *kobj,
 		struct bin_attribute *bin_attr,
@@ -35,7 +36,7 @@ static ssize_t nlm_nmiprof_read(struct file *filp, struct kobject *kobj,
 	if ((pos) + size > log_size)
 		size = log_size - (pos/8);
 	memcpy((void __force *) buf,
-			(void __force *) ((char *)jdev->base + pos), size);
+			(void __force *) ((char *)ndev->base + pos), size);
 	return size;
 }
 
@@ -52,7 +53,7 @@ static ssize_t nlm_nmiprofcontrol_read(struct file *filp, struct kobject *kobj,
 {
 	int count = 0;
 	if (!pos)
-		count = scnprintf(buf, size, "%d\n", jdev->nlm_cpu);
+		count = scnprintf(buf, size, "%d\n", ndev->nlm_cpu);
 	return count;
 }
 
@@ -65,145 +66,160 @@ static ssize_t nlm_nmiprofcontrol_write(struct file *filp, struct kobject *kobj,
 		struct bin_attribute *bin_attr,
 		char *buf, loff_t pos, size_t size)
 {
-	char *reset_data;
 	u32 *write_asm;
-	uint64_t xlp_pic_base;
-	int ret;
-	int use_cpu;
+	int ret, use_cpu;
+	char *reset_data = (char *)CKSEG1ADDR(RESET_VEC_PHYS);
+	uint64_t xlp_pic_base = nlm_get_pic_regbase(0); /* Node 0 */
 
-	pr_debug("nmiprof control jdev->nlm_cpu %d\n", jdev->nlm_cpu);
+	dev_dbg(&ndev->dev->dev, "Run nmiprof control on CPU %d\n", ndev->nlm_cpu);
 
 	/* Get cpu */
 	use_cpu = simple_strtol(buf, NULL, 0);
 
-	if (jdev->nlm_cpu >= 0 && jdev->nlm_cpu < NLM_NR_CPUS && use_cpu >= 0) {
-		pr_info("nmiprof running on cpu %d\n", jdev->nlm_cpu);
-		pr_info("Help : cpu mask on XLP8xx 0-31 and on XLP9xx 0-79\n");
-		pr_info("	To stop nmiprof -1\n");
-		return -EINVAL;
+	if (use_cpu >= NLM_NR_CPUS || use_cpu  < -1) {
+		dev_info(&ndev->dev->dev, "Invalid CPU %d\n"
+			"Help - cpu mask on XLP8xx 0-31 and on XLP9xx 0-79\n", use_cpu);
+		return size;
 	}
 
-	jdev->nlm_cpu = use_cpu;
-	xlp_pic_base = nlm_get_pic_regbase(0); /* Node 0 */
-	reset_data = (char *)CKSEG1ADDR(RESET_VEC_PHYS);
-
-	if (jdev->nlm_cpu >= 0 && jdev->nlm_cpu < NLM_NR_CPUS) {
-		/* Setting scratch reg of requested cpu
-		 * with the memory address */
-		ret = smp_call_function_single(jdev->nlm_cpu, nlm_config_cpu,
-				jdev->base, 1);
-		if (ret) {
-			pr_info("smp call function error\n");
-			return ret;
-		}
-
-		pr_info("nmiprof: start tracing on cpu %d\n", jdev->nlm_cpu);
-		memcpy((void *)nmiprofsave, reset_data,
-				(nlm_nmiprof_end - nlm_nmiprof));
-		memcpy(reset_data, nlm_nmiprof, (nlm_nmiprof_end - nlm_nmiprof));
-
-		write_asm = (u32 *) (reset_data + (&pic_entry - nlm_nmiprof));
-		*write_asm |= (xlp_pic_base & 0xffff0000) >> 16;
-		write_asm++;
-		*write_asm |= 0x400;
-		write_asm++;
-		*write_asm |= ((xlp_pic_base & 0xffff) + (PIC_STATUS << 2));
-		write_asm++;
-		*write_asm |= 0xa;
-		write_asm++;
-		*write_asm |= ((xlp_pic_base & 0xffff) + (PIC_INT_ACK << 2));
-
-		nlm_pic_set_timer(xlp_pic_base, 6, 509 * 1499ull, -3,
-				jdev->nlm_cpu);
-	} else if (jdev->nlm_cpu < 0) {
+	if (!ndev->state || use_cpu == -1) {
+		dev_info(&ndev->dev->dev, "Not running on any cpu\n");
+		return size;
+	}
+
+	/* Stop the profiler */
+	if (use_cpu == -1) {
 		nlm_pic_set_timer(xlp_pic_base, 6, ~0ULL, 0, 0);
 		memcpy(reset_data, (void *)nmiprofsave,
 				(nlm_nmiprof_end - nlm_nmiprof));
-		pr_info("nmiprof: stopped tracing\n");
+		ndev->state = 0;
+		dev_info(&ndev->dev->dev, "Stopped tracing on cpu %d\n", ndev->nlm_cpu);
+		ndev->nlm_cpu = NLM_NR_CPUS;
+		module_put(THIS_MODULE);
+		return size;
+	}
+
+	if (ndev->state) {
+		dev_info(&ndev->dev->dev, "Running on cpu %d\n" 
+			"To stop nmiprof: echo -1 > nmiprofcontrol\n", ndev->nlm_cpu);
+		return size;
+	}
+
+	/* Start the profiler on use_cpu */
+	ndev->nlm_cpu = use_cpu;
+
+	memset(ndev->base, 0xa5, NMIPROF_LOG_SIZE);
+	/* Setting scratch reg of requested cpu
+	 * with the memory address */
+	ret = smp_call_function_single(ndev->nlm_cpu, nlm_config_cpu,
+			ndev->base, 1);
+	if (ret) {
+		dev_info(&ndev->dev->dev, "smp call function error\n");
+		return ret;
 	}
 
-	return size + 1;
+	dev_info(&ndev->dev->dev, "nmiprof: start tracing on cpu %d\n", ndev->nlm_cpu);
+	memcpy((void *)nmiprofsave, reset_data,
+			(nlm_nmiprof_end - nlm_nmiprof));
+	memcpy(reset_data, nlm_nmiprof, (nlm_nmiprof_end - nlm_nmiprof));
+
+	write_asm = (u32 *) (reset_data + (&pic_entry - nlm_nmiprof));
+	*write_asm |= (xlp_pic_base & 0xffff0000) >> 16;
+	write_asm++;
+	*write_asm |= 0x400;
+	write_asm++;
+	*write_asm |= ((xlp_pic_base & 0xffff) + (PIC_STATUS << 2));
+	write_asm++;
+	*write_asm |= 0xa;
+	write_asm++;
+	*write_asm |= ((xlp_pic_base & 0xffff) + (PIC_INT_ACK << 2));
+
+	nlm_pic_set_timer(xlp_pic_base, 6, 509 * 1499ull, -3,
+			ndev->nlm_cpu);
+	ndev->state = 1;
+	if (!try_module_get(THIS_MODULE))
+		printk(KERN_WARNING "%s:cannot get module\n", __func__);
+
+	return size;
 }
 
 static int __init nlm_init_sys(void)
 {
-	int err = 0;
+	unsigned long err = 0;
 
-	jdev = kzalloc(sizeof(*jdev), GFP_KERNEL);
-	if (!jdev)
+	ndev = kzalloc(sizeof(*ndev), GFP_KERNEL);
+	if (!ndev)
 		return ENOMEM;
 
-	jdev->nlm_cpu = NLM_NR_CPUS;
+	ndev->nlm_cpu = NLM_NR_CPUS;
+
+	ndev->dev = platform_device_register_simple("nmiprof", -1, NULL, 0);
+	if (IS_ERR(ndev->dev)) {
+		printk(KERN_ERR
+		"nl_pf_fs:%s:platform_device_register_simple "
+		"failed\n", __func__);
+		err = EBUSY;
+		goto platform_err;
+	}
 	/* Allocate memory for dumping the statistic collected */
-	jdev->base = (u64 *) __get_free_pages(GFP_ATOMIC,
+	ndev->base = (u64 *) __get_free_pages(GFP_ATOMIC,
 			get_order(NMIPROF_LOG_SIZE));
-	if (!jdev->base) {
+	if (!ndev->base) {
 		pr_info("Allocation of free pages failed\n");
-		return -ENOMEM;
+		err = ENOMEM;
+		goto page_err;
 	}
 
-	memset(jdev->base, 0xa5, NMIPROF_LOG_SIZE);
-
 	/* Setup the nmiprofdata entry,
 	 * which will be used for read/write */
-	jdev->bindata_attr.attr.name = "nmiprofdata";
-	jdev->bindata_attr.attr.mode = S_IRUSR | S_IWUSR;
-	jdev->bindata_attr.read = nlm_nmiprof_read;
-	jdev->bindata_attr.write = nlm_nmiprof_write;
-	jdev->bindata_attr.size = NMIPROF_LOG_SIZE;
-	jdev->bindata_attr.private = jdev;
+	ndev->bindata_attr.attr.name = "nmiprofdata";
+	ndev->bindata_attr.attr.mode = S_IRUSR | S_IWUSR;
+	ndev->bindata_attr.read = nlm_nmiprof_read;
+	ndev->bindata_attr.write = nlm_nmiprof_write;
+	ndev->bindata_attr.size = NMIPROF_LOG_SIZE;
+	ndev->bindata_attr.private = ndev;
 
 	/* Setup nmiprofcontrol entry to control
 	 * profiling start or stop */
-	jdev->binnmiprof_attr.attr.name = "nmiprofcontrol";
-	jdev->binnmiprof_attr.attr.mode = S_IRUSR | S_IWUSR;
-	jdev->binnmiprof_attr.read = nlm_nmiprofcontrol_read;
-	jdev->binnmiprof_attr.write = nlm_nmiprofcontrol_write;
-	jdev->binnmiprof_attr.size = 4;
-	jdev->binnmiprof_attr.private = jdev;
-
-	jdev->dev = platform_device_register_simple("nmiprof", -1, NULL, 0);
-	if (IS_ERR(jdev->dev)) {
-		printk(KERN_ERR
-		"nl_pf_fs:%s:platform_device_register_simple "
-		"failed\n", __func__);
-		goto platform_err;
-	}
-
-	err = sysfs_create_bin_file(&jdev->dev->dev.kobj, &jdev->bindata_attr);
+	ndev->binnmiprof_attr.attr.name = "nmiprofcontrol";
+	ndev->binnmiprof_attr.attr.mode = S_IRUSR | S_IWUSR;
+	ndev->binnmiprof_attr.read = nlm_nmiprofcontrol_read;
+	ndev->binnmiprof_attr.write = nlm_nmiprofcontrol_write;
+	ndev->binnmiprof_attr.size = 4;
+	ndev->binnmiprof_attr.private = ndev;
+
+	err = sysfs_create_bin_file(&ndev->dev->dev.kobj, &ndev->bindata_attr);
 	if (err) {
-		pr_info("can't create attribute file\n");
+		dev_info(&ndev->dev->dev, "can't create attribute file\n");
 		goto sys_err1;
 	}
 
-	err = sysfs_create_bin_file(&jdev->dev->dev.kobj, &jdev->binnmiprof_attr);
+	err = sysfs_create_bin_file(&ndev->dev->dev.kobj, &ndev->binnmiprof_attr);
 	if (err) {
-		pr_info("can't create attribute file\n");
+		dev_info(&ndev->dev->dev, "can't create attribute file\n");
 		goto sys_err;
 	}
 	return 0;
 
 sys_err:
-	sysfs_remove_bin_file(&jdev->dev->dev.kobj, &jdev->bindata_attr);
+	sysfs_remove_bin_file(&ndev->dev->dev.kobj, &ndev->bindata_attr);
 sys_err1:
-	platform_device_unregister(jdev->dev);
+	if (ndev->base)
+		__free_pages((struct page *)ndev->base, get_order(NMIPROF_LOG_SIZE));
+page_err:
+	platform_device_unregister(ndev->dev);
 platform_err:
-	if (jdev) {
-		if (jdev->base)
-			iounmap(jdev->base);
-		kfree(jdev);
-	}
+	kfree(ndev);
 	return err;
 }
 
 static void __exit nlm_exit_sys(void)
 {
-	sysfs_remove_bin_file(&jdev->dev->dev.kobj, &jdev->binnmiprof_attr);
-	sysfs_remove_bin_file(&jdev->dev->dev.kobj, &jdev->bindata_attr);
-	platform_device_unregister(jdev->dev);
-	iounmap(jdev->base);
-
-	return;
+	sysfs_remove_bin_file(&ndev->dev->dev.kobj, &ndev->binnmiprof_attr);
+	sysfs_remove_bin_file(&ndev->dev->dev.kobj, &ndev->bindata_attr);
+	platform_device_unregister(ndev->dev);
+	__free_pages((struct page *)ndev->base, get_order(NMIPROF_LOG_SIZE));
+	kfree(ndev);
 }
 
 module_init(nlm_init_sys);
-- 
1.9.1

