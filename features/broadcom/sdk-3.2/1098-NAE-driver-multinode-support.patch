From f940e79bc0e429a5e1504384a8c248df1fbfea16 Mon Sep 17 00:00:00 2001
From: Jayanthi A <jayanthia@netlogicmicro.com>
Date: Fri, 27 Jan 2012 22:13:51 +0530
Subject: [PATCH 1098/1532] NAE driver multinode support

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/nae-perf/init_nae.c |   3 +-
 drivers/misc/netlogic/nae-perf/xlp_hw.c   |  72 +++++++--------
 drivers/misc/netlogic/nae-perf/xlp_nae.c  | 145 ++++++++++++++++--------------
 drivers/misc/netlogic/nae-perf/xlp_nae.h  |   1 +
 4 files changed, 116 insertions(+), 105 deletions(-)

diff --git a/drivers/misc/netlogic/nae-perf/init_nae.c b/drivers/misc/netlogic/nae-perf/init_nae.c
index ec31ad9..bca9840 100644
--- a/drivers/misc/netlogic/nae-perf/init_nae.c
+++ b/drivers/misc/netlogic/nae-perf/init_nae.c
@@ -20,12 +20,13 @@ int initialize_nae(uint32_t cm0, uint32_t cm1, uint32_t cm2, uint32_t cm3)
 {
 	int dom_id = 0;
 	unsigned long mflags;
+	int node = 0;
 
 	msgrng_access_enable(mflags);
 	nlm_hal_init_nae(fdt, dom_id);
 
 	printk("Overriding HAL POE configuration based on current active cpumask\n");
-	nlm_hal_init_poe_distvec(0, cm0, cm1, cm2, cm3, (1 << nae_cfg.rx_vc));
+	nlm_hal_init_poe_distvec(node, 0, cm0, cm1, cm2, cm3, (1 << nlm_node_cfg.nae_cfg[node]->rx_vc));	//FIXME for multinode
 
 	msgrng_access_disable(mflags);
 	return 0;
diff --git a/drivers/misc/netlogic/nae-perf/xlp_hw.c b/drivers/misc/netlogic/nae-perf/xlp_hw.c
index 2772576..a0fb6e2 100755
--- a/drivers/misc/netlogic/nae-perf/xlp_hw.c
+++ b/drivers/misc/netlogic/nae-perf/xlp_hw.c
@@ -218,7 +218,7 @@ static void xlp_get_regs(struct net_device *dev,
 
 	spin_lock_irqsave(&priv->lock, flags);
 	for(i=0; i <= NLM_NUM_REG_DUMP; i++)
-		*(data + i) = nlm_hal_read_mac_reg(priv->block, priv->index,  R_TX_CONTROL + i);
+		*(data + i) = nlm_hal_read_mac_reg(priv->node, priv->block, priv->index,  R_TX_CONTROL + i);
 	spin_unlock_irqrestore(&priv->lock, flags);
 }
 static u32 xlp_get_msglevel(struct net_device *dev)
@@ -328,52 +328,52 @@ void xlp_get_mac_stats(struct net_device *dev, struct net_device_stats *stats)
 	struct dev_data *priv = netdev_priv(dev);
 	unsigned long long val;
 
-	stats->tx_packets = nlm_hal_read_mac_reg( priv->block, priv->index, TX_PACKET_COUNTER);
+	stats->tx_packets = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, TX_PACKET_COUNTER);
 #ifdef CONFIG_64BIT
-	val = nlm_hal_read_mac_reg( priv->block, priv->index, 0x1f);
+	val = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, 0x1f);
 	stats->tx_packets |= ( val << 32);
 #endif
 
-	stats->rx_packets = nlm_hal_read_mac_reg( priv->block, priv->index, RX_PACKET_COUNTER);
+	stats->rx_packets = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, RX_PACKET_COUNTER);
 #ifdef CONFIG_64BIT
-	val = nlm_hal_read_mac_reg( priv->block, priv->index, 0x1f);
+	val = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, 0x1f);
 	stats->rx_packets |= ( val << 32);
 #endif
 
-	stats->tx_bytes = nlm_hal_read_mac_reg( priv->block, priv->index, TX_BYTE_COUNTER);
+	stats->tx_bytes = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, TX_BYTE_COUNTER);
 #ifdef CONFIG_64BIT
-	val = nlm_hal_read_mac_reg( priv->block, priv->index, 0x1f);
+	val = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, 0x1f);
 	stats->tx_bytes |= ( val << 32);
 #endif
 
-	stats->rx_bytes = nlm_hal_read_mac_reg( priv->block, priv->index, RX_BYTE_COUNTER);
+	stats->rx_bytes = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, RX_BYTE_COUNTER);
 #ifdef CONFIG_64BIT
-	val = nlm_hal_read_mac_reg( priv->block, priv->index, 0x1f);
+	val = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, 0x1f);
 	stats->rx_bytes |= ( val << 32);
 #endif
 
-	stats->tx_errors = nlm_hal_read_mac_reg( priv->block, priv->index, TX_FCS_ERROR_COUNTER);
-	stats->rx_dropped = nlm_hal_read_mac_reg( priv->block, priv->index, RX_DROP_PACKET_COUNTER);
-	stats->tx_dropped = nlm_hal_read_mac_reg( priv->block, priv->index, TX_DROP_FRAME_COUNTER);
+	stats->tx_errors = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, TX_FCS_ERROR_COUNTER);
+	stats->rx_dropped = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, RX_DROP_PACKET_COUNTER);
+	stats->tx_dropped = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, TX_DROP_FRAME_COUNTER);
 
-	stats->multicast = nlm_hal_read_mac_reg( priv->block, priv->index, RX_MULTICAST_PACKET_COUNTER);
+	stats->multicast = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, RX_MULTICAST_PACKET_COUNTER);
 #ifdef CONFIG_64BIT
-	val = nlm_hal_read_mac_reg( priv->block, priv->index, 0x1f);
+	val = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, 0x1f);
 	stats->multicast |= ( val << 32);
 #endif
 
-	stats->collisions = nlm_hal_read_mac_reg( priv->block, priv->index, TX_TOTAL_COLLISION_COUNTER);
-	stats->rx_length_errors = nlm_hal_read_mac_reg( priv->block, priv->index, RX_FRAME_LENGTH_ERROR_COUNTER);
-	stats->rx_over_errors = nlm_hal_read_mac_reg( priv->block, priv->index, RX_DROP_PACKET_COUNTER);
-	stats->rx_crc_errors = nlm_hal_read_mac_reg( priv->block, priv->index, RX_FCS_ERROR_COUNTER);
-	stats->rx_frame_errors = nlm_hal_read_mac_reg( priv->block, priv->index, RX_ALIGNMENT_ERROR_COUNTER);
-	stats->rx_fifo_errors = nlm_hal_read_mac_reg( priv->block, priv->index,RX_DROP_PACKET_COUNTER);
-	stats->rx_missed_errors = nlm_hal_read_mac_reg( priv->block, priv->index,RX_CARRIER_SENSE_ERROR_COUNTER);
+	stats->collisions = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, TX_TOTAL_COLLISION_COUNTER);
+	stats->rx_length_errors = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, RX_FRAME_LENGTH_ERROR_COUNTER);
+	stats->rx_over_errors = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, RX_DROP_PACKET_COUNTER);
+	stats->rx_crc_errors = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, RX_FCS_ERROR_COUNTER);
+	stats->rx_frame_errors = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, RX_ALIGNMENT_ERROR_COUNTER);
+	stats->rx_fifo_errors = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index,RX_DROP_PACKET_COUNTER);
+	stats->rx_missed_errors = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index,RX_CARRIER_SENSE_ERROR_COUNTER);
 	stats->rx_errors = (stats->rx_over_errors + stats->rx_crc_errors + stats->rx_frame_errors + stats->rx_fifo_errors +stats->rx_missed_errors);
-	stats->tx_aborted_errors = nlm_hal_read_mac_reg( priv->block, priv->index, TX_EXCESSIVE_COLLISION_PACKET_COUNTER);
+	stats->tx_aborted_errors = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, TX_EXCESSIVE_COLLISION_PACKET_COUNTER);
 	/*
-	stats->tx_carrier_errors = nlm_hal_read_mac_reg( priv->block, priv->index, TX_DROP_FRAME_COUNTER);
-	stats->tx_fifo_errors = nlm_hal_read_mac_reg( priv->block, priv->index, TX_DROP_FRAME_COUNTER);
+	stats->tx_carrier_errors = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, TX_DROP_FRAME_COUNTER);
+	stats->tx_fifo_errors = nlm_hal_read_mac_reg(priv->node,  priv->block, priv->index, TX_DROP_FRAME_COUNTER);
 	*/
 	return;
 }
@@ -419,7 +419,7 @@ static void xlp_get_ethtool_stats (struct net_device *dev,
  ********************************************************************* */
 static unsigned int nlm_xlp_mac_mii_read(struct dev_data *priv, int regidx)
 {
-        return nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, regidx);
+        return nlm_hal_mdio_read(priv->node, NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, regidx);
 }
 
 /**********************************************************************
@@ -435,7 +435,7 @@ static unsigned int nlm_xlp_mac_mii_read(struct dev_data *priv, int regidx)
  ********************************************************************* */
 static void nlm_xlp_mac_mii_write(struct dev_data *priv, int regidx, uint16_t regval)
 {
-	nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, regidx, regval);
+	nlm_hal_mdio_write(priv->node, NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, regidx, regval);
 	return;
 }
 
@@ -485,22 +485,22 @@ void nlm_xlp_mac_set_enable(struct dev_data *priv, int flag)
 
 	if (flag) {
 		if (priv->type == SGMII_IF) {
-			if (nlm_hal_get_phy_status(inf, &speed, &duplex)) {
+			if (nlm_hal_get_phy_status(priv->node, inf, &speed, &duplex)) {
 				//nlm_print("mac set enable speed %d duplex %d\n",speed, duplex);
 				ifmode = ((speed == 2) ? 2: 1);
-				nlm_hal_mac_disable(inf, priv->type);
-			        netwk_inf  = read_gmac_reg(inf, NETWK_INF_CTRL_REG);
+				nlm_hal_mac_disable(priv->node, inf, priv->type);
+			        netwk_inf  = read_gmac_reg(priv->node, inf, NETWK_INF_CTRL_REG);
 				netwk_inf &= (~(0x3));
-				write_gmac_reg(inf , NETWK_INF_CTRL_REG, netwk_inf | speed);
-				mac_cfg2 = read_gmac_reg(inf, MAC_CONF2);
+				write_gmac_reg(priv->node, inf , NETWK_INF_CTRL_REG, netwk_inf | speed);
+				mac_cfg2 = read_gmac_reg(priv->node, inf, MAC_CONF2);
 				mac_cfg2 &= (~((0x3 << 8) | 1));
-				write_gmac_reg(inf , MAC_CONF2,
+				write_gmac_reg(priv->node, inf , MAC_CONF2,
 					              mac_cfg2 | (ifmode << 8) | duplex);
 			}
 		}
-		nlm_hal_mac_enable(inf, priv->type);
+		nlm_hal_mac_enable(priv->node, inf, priv->type);
 	} else {
-		nlm_hal_mac_disable(inf, priv->type);
+		nlm_hal_mac_disable(priv->node, inf, priv->type);
 	}
 }
 
@@ -510,7 +510,7 @@ int nlm_xlp_link_up(struct dev_data *priv, int phy)
 
 	if (priv->type != SGMII_IF)
                 return -EIO;
-        nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, 22, 0);
-        extstatus = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, 17);
+        nlm_hal_mdio_write(priv->node, NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, 22, 0);
+        extstatus = nlm_hal_mdio_read(priv->node, NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, 17);
         return ((extstatus & 0x0400) ? 1 : 0 );
 }
diff --git a/drivers/misc/netlogic/nae-perf/xlp_nae.c b/drivers/misc/netlogic/nae-perf/xlp_nae.c
index 9c51b15..63fd23e 100755
--- a/drivers/misc/netlogic/nae-perf/xlp_nae.c
+++ b/drivers/misc/netlogic/nae-perf/xlp_nae.c
@@ -516,7 +516,7 @@ static __inline__ uint64_t nae_tso_desc1(
 #define RX_PARSER_EN 	1
 #define RX_PPAD_EN 	0 
 #define RX_PPAD_SZ	3
-static void nlm_enable_l3_l4_parser(void)
+static void nlm_enable_l3_l4_parser(int node)
 {
 	int l2proto = 1; //ethernet
 	int port = 0, i, ipchk = 1;
@@ -527,24 +527,24 @@ static void nlm_enable_l3_l4_parser(void)
 	int crcpoly = 0xffff;//0xbaad; //0xbb3d;
 
 	//enabling hardware parser
-	naereg = nlm_hal_read_nae_reg(RX_CONFIG);
-	nlm_hal_write_nae_reg(RX_CONFIG, (naereg | RX_PARSER_EN << 12 | RX_PPAD_EN << 13 | RX_PPAD_SZ << 22)); 
-	printk("Enabling parser, reg content = %x\n", nlm_hal_read_nae_reg(RX_CONFIG));
+	naereg = nlm_hal_read_nae_reg(node, RX_CONFIG);
+	nlm_hal_write_nae_reg(node, RX_CONFIG, (naereg | RX_PARSER_EN << 12 | RX_PPAD_EN << 13 | RX_PPAD_SZ << 22)); 
+	printk("Enabling parser, reg content = %x\n", nlm_hal_read_nae_reg(node, RX_CONFIG));
 
 	/* enabling extraction of data */
 	for(i=0; i<16;i++)
-		nlm_hal_write_nae_reg(L2_TYPE_0 + i, l2proto);
+		nlm_hal_write_nae_reg(node, L2_TYPE_0 + i, l2proto);
 
-	nlm_hal_write_nae_reg(L3_CTABLE_MASK_0, port | 0 << 5 | 1 << 6); // l2proto and ethtype included
+	nlm_hal_write_nae_reg(node, L3_CTABLE_MASK_0, port | 0 << 5 | 1 << 6); // l2proto and ethtype included
 
 	val = ((0 << 26) | (9 << 20) | (ipchk << 18) | (1 << 16) | (0x800));
-	nlm_hal_write_nae_reg(L3_CTABLE_0_0, val);
+	nlm_hal_write_nae_reg(node, L3_CTABLE_0_0, val);
 	val =   (12 << 26) | (4 << 21) | (16 << 15) | (4 << 10); /* extract sourceip and dstip */
-	nlm_hal_write_nae_reg(L3_CTABLE_0_1, val);
+	nlm_hal_write_nae_reg(node, L3_CTABLE_0_1, val);
 
-	nlm_hal_write_nae_reg(L4_CTABLE_0_0, 1 << 17 | 0x6); /* ip_proto = tcp */
+	nlm_hal_write_nae_reg(node, L4_CTABLE_0_0, 1 << 17 | 0x6); /* ip_proto = tcp */
 	val = ((0 << 21) | (2 << 17) | (2 << 11) | (2 << 7)); /* extract source and dst port*/
-	nlm_hal_write_nae_reg(L4_CTABLE_0_1, val);
+	nlm_hal_write_nae_reg(node, L4_CTABLE_0_1, val);
 
 	/* Configure flow table 1 to the num cpus as the modular */
 	for(i = 0; i < NR_CPUS; i++) {
@@ -552,8 +552,8 @@ static void nlm_enable_l3_l4_parser(void)
 			num_cpus++;
 	}
 	for(i = 0; i < 20; i++) {
-		nlm_hal_write_nae_reg(0x84, i);
-		nlm_hal_write_nae_reg(0x84, (num_cpus << 20)| i);
+		nlm_hal_write_nae_reg(node, 0x84, i);
+		nlm_hal_write_nae_reg(node, 0x84, (num_cpus << 20)| i);
 	}
 
 	
@@ -563,17 +563,17 @@ static void nlm_enable_l3_l4_parser(void)
 	for(i = 0; i < 512;) {
 		cpu = dstvc / NUM_VC_PER_THREAD;
 		if(cpu_isset(cpu, cpu_present_map)) {
-			nlm_hal_write_nae_reg(FLOW_TABLE3_CFG, 0 << 31 | i);
-			nlm_hal_write_nae_reg(FLOW_TABLE3_CFG, dstvc << 12 | i);
+			nlm_hal_write_nae_reg(node, FLOW_TABLE3_CFG, 0 << 31 | i);
+			nlm_hal_write_nae_reg(node, FLOW_TABLE3_CFG, dstvc << 12 | i);
 			i++;
 		}
 		dstvc += NUM_VC_PER_THREAD;
 		if(dstvc >= NUM_CPU_VC) /* max vcs in a core */
 			dstvc = nae_rx_vc;
 	}
-	val = nlm_hal_read_nae_reg(0x2f);
+	val = nlm_hal_read_nae_reg(node, 0x2f);
 	val &= (~0x3fffff) ;
-	nlm_hal_write_nae_reg(0x2f, (max_key_size << 16) | crcpoly | val);
+	nlm_hal_write_nae_reg(node, 0x2f, (max_key_size << 16) | crcpoly | val);
 
 }
 
@@ -594,27 +594,27 @@ static int lro_get_skb_hdr(struct sk_buff *skb, void **iphdr, void **tcph,
 	return 0;
 }
 
-void dump_parser_config(void)
+void dump_parser_config(int node)
 {
 	int i; 
 	uint32_t val;
 
-	val = nlm_hal_read_nae_reg(0x2f);
+	val = nlm_hal_read_nae_reg(node, 0x2f);
 	printk("Crc config %x crc %x keysize %d Flowidx %d Dstidx %d\n", val,
 			(val & 0xffff), (val >> 16) & 0x3f, (val >> 22) & 0x01, (val >> 23) & 0x01);
 
 	printk("Flow table 1 cfg\n");
 	for(i = 0; i < 20; i++) {
-		nlm_hal_write_nae_reg(0x84, 1 << 31 | i);
-		val = nlm_hal_read_nae_reg(0x84);
+		nlm_hal_write_nae_reg(node, 0x84, 1 << 31 | i);
+		val = nlm_hal_read_nae_reg(node, 0x84);
 		printk("reg %x val %x index %d (%x:%x)\n",
 				0x84, val, i, (val >> 8) & 0x1ff, (val >> 20) & 0x1ff);
 	}
 
 	printk("Flow table 3 cfg\n");
 	for(i = 0; i < 50; i++) {
-		nlm_hal_write_nae_reg(0x86, 1 << 31 | i);
-		val = nlm_hal_read_nae_reg(0x86);
+		nlm_hal_write_nae_reg(node, 0x86, 1 << 31 | i);
+		val = nlm_hal_read_nae_reg(node, 0x86);
 		printk("reg %x val %x index %d (%x:%x)\n",
 				0x86, val, i, (val >> 12) & 0x1ff, (val >> 22) & 0x1ff);
 	}
@@ -649,8 +649,8 @@ void lro_init(struct net_device *dev)
 #endif
 	if(!done) {
 		done = 1;
-		nlm_enable_l3_l4_parser();
-		//dump_parser_config();
+		nlm_enable_l3_l4_parser(priv->node);
+		//dump_parser_config(priv->node);
 	}
 }
 
@@ -764,13 +764,14 @@ xlp_poll_upper(int cpu)
 {
 	unsigned int status;
 	uint64_t msg0 = 0, addr;
-	uint32_t src_id, size, code, context, port;
+	uint32_t src_id, size, code, context, port, node;
 	struct sk_buff* skb;
 	struct dev_data *priv;
 	uint64_t *p2pfbdesc;
 
 	while (1) {
 			status = xlp_message_receive_1(nae_fb_vc, &src_id, &size, &code, &msg0);
+
 			if(status) break;
 			__sync();
 
@@ -785,7 +786,8 @@ xlp_poll_upper(int cpu)
 
 			/* context field is currently unused */
 			context = (msg0 >> 40) & 0x3fff;
-			port = cntx2port[context];
+			node = (src_id >> 10) & 0x3;
+			port = *(cntx2port[node] + context);
 #ifdef TSO_ENABLED
 			if(nlm_mode[LAST_RCVD_INDEX(cpu)] == NLM_TCP_MODE){
 				p2pfbdesc = bus_to_virt(addr);
@@ -824,7 +826,7 @@ static int xlp_poll_lower(int budget, int cpu)
 	int no_rx_pkt_rcvd = 0;
 	uint64_t addr;
 	uint32_t len, context;
-	int port;
+	int port, node;
 	struct net_device *pdev;
 	struct dev_data *priv = NULL;
 	uint64_t vaddr;
@@ -839,7 +841,7 @@ static int xlp_poll_lower(int budget, int cpu)
 	while (budget--) {
 
 		status = xlp_message_receive_2(nae_rx_vc, &src_id, &size, &code, &msg0, &msg1);
-
+		
 		if(status) {
 			if(enable_napi) 
 				break;
@@ -873,8 +875,8 @@ static int xlp_poll_lower(int budget, int cpu)
 			printk("Dropping firmware RX packet (addr=%llx)!\n", addr);
 			continue;
 		}
-
-		port = cntx2port[context];
+		node = (src_id >> 10) & 0x3;
+		port = *(cntx2port[node] + context);
 
 #ifdef ENABLE_SANITY_CHECKS
 		if(port >= MAX_GMAC_PORT)
@@ -1030,7 +1032,7 @@ void nlm_spawn_kthread(void)
 
 }
 
-static void nlm_update_ucore_shared_memory(void)
+static void nlm_update_ucore_shared_memory(int node)
 {
 	uint32_t data[33] = {0};
 	int i = 0;
@@ -1040,7 +1042,7 @@ static void nlm_update_ucore_shared_memory(void)
 		for(j=0; j<NR_CPUS && i<32; j++){
 			if(!cpu_isset(j, cpu_present_map))
 				continue;
-			data[i] = j*4 + nae_cfg.rx_vc;
+			data[i] = j*4 + nae_rx_vc;
 			i++;
 		}
 	}
@@ -1163,11 +1165,12 @@ static void nlm_xlp_nae_init(void)
 {
 	struct net_device *dev = NULL;
 	struct dev_data *priv;
-	int i;
+	int i, node = 0;
 	struct proc_dir_entry *entry;
 	int cpu = 0;
 	int vc = 0;
 	unsigned char *mode_str[3] = {"INVALID","TCP_PERF","ROUTE_PERF"};
+	nlm_nae_config_ptr nae_cfg;
 
 	if(!(perf_mode == NLM_TCP_MODE || perf_mode == NLM_RT_MODE)){
 		printk("Invalid perf mode passed -- Using TCP_PERF mode\n");
@@ -1191,10 +1194,10 @@ static void nlm_xlp_nae_init(void)
 		if(!cpu_isset(i, cpu_present_map))
 			continue;
 		for(vc=0; vc<4; vc++)
-			nlm_hal_disable_vc_intr(i*4 + vc);
+			nlm_hal_disable_vc_intr((i/32), ((i*4 + vc) & 0x7f));
 	}
 
-	nlm_update_ucore_shared_memory();
+	nlm_update_ucore_shared_memory(node);
 
 	if(perf_mode == NLM_TCP_MODE)
 		p2p_desc_mem_init();
@@ -1202,22 +1205,27 @@ static void nlm_xlp_nae_init(void)
 	if (initialize_nae(cpumask_to_uint32(&cpu_present_map), 0, 0, 0))
 		return;
 
-	nae_fb_vc = nae_cfg.fb_vc;
-	nae_rx_vc = nae_cfg.rx_vc;
+	nae_cfg = nlm_node_cfg.nae_cfg[node];		//FIXME for multinode
+	if (nae_cfg == NULL) {
+		printk("Node %d NAE configuration is NULL \n",node);
+		return;
+	}	
+	nae_fb_vc = nae_cfg->fb_vc;
+	nae_rx_vc = nae_cfg->rx_vc;
 
 
-	if(nae_cfg.frin_queue_base != 0)
-		frin_queue_base = nae_cfg.frin_queue_base;
+	if(nae_cfg->frin_queue_base != 0)
+		frin_queue_base = nae_cfg->frin_queue_base;
 
-	if(nae_cfg.frin_total_queue != 0)
-		frin_total_queue = nae_cfg.frin_total_queue;
+	if(nae_cfg->frin_total_queue != 0)
+		frin_total_queue = nae_cfg->frin_total_queue;
 
-	printk("nae_cfg: frin_queue_base %d, frin_total_queue %d\n",nae_cfg.frin_queue_base, nae_cfg.frin_total_queue);
+	printk("nae_cfg frin_queue_base %d, frin_total_queue %d\n",nae_cfg->frin_queue_base, nae_cfg->frin_total_queue);
 
-	for(i = 0; i < nae_cfg.num_ports; i++)
+	for(i = 0; i < nae_cfg->num_ports; i++)
 	{
 		/* Register only valid ports which are management */
-		if (!nae_cfg.ports[i].valid)
+		if (!nae_cfg->ports[i].valid)
 			continue;
 
 		dev = alloc_etherdev_mq(sizeof(struct dev_data), 32);
@@ -1237,18 +1245,19 @@ static void nlm_xlp_nae_init(void)
 
 		dev->dev_addr = eth_hw_addr[i];
 		priv->port	= i;
-		priv->hw_port_id = nae_cfg.ports[i].hw_port_id;
+		priv->hw_port_id = nae_cfg->ports[i].hw_port_id;
 
 		priv->inited	= 0;
-		priv->block 	= nae_cfg.ports[i].hw_port_id / 4;
-		priv->type = nae_cfg.ports[i].iftype;
-		switch(nae_cfg.ports[i].iftype) {
+		priv->node = node;
+		priv->block 	= nae_cfg->ports[i].hw_port_id / 4;
+		priv->type = nae_cfg->ports[i].iftype;
+		switch(nae_cfg->ports[i].iftype) {
 			case SGMII_IF:
-				priv->index = nae_cfg.ports[i].hw_port_id & 0x3;
-				priv->phy.addr = nae_cfg.ports[i].hw_port_id;
+				priv->index = nae_cfg->ports[i].hw_port_id & 0x3;
+				priv->phy.addr = nae_cfg->ports[i].hw_port_id;
 				break;
 			case XAUI_IF:
-				nlm_hal_write_mac_reg((nae_cfg.ports[i].hw_port_id / 4), 
+				nlm_hal_write_mac_reg(priv->node, (nae_cfg->ports[i].hw_port_id / 4), 
 						XGMAC, XAUI_MAX_FRAME_LEN , 0x01800600);
 				priv->index = XGMAC;
 				break;
@@ -1259,10 +1268,10 @@ static void nlm_xlp_nae_init(void)
 				priv->index=0;
 				break;
 		}
-		//nlm_print("port%d hw %d block %d index %d type %d \n",i, nae_cfg.ports[i].hw_port_id,
+		//nlm_print("port%d hw %d block %d index %d type %d \n",i, nae_cfg->ports[i].hw_port_id,
 		//							priv->block, priv->index, priv->type);
-		priv->nae_tx_qid 	= nae_cfg.ports[i].txq_range[0];
-		priv->nae_rx_qid 	= nae_cfg.ports[i].rxq;
+		priv->nae_tx_qid 	= nae_cfg->ports[i].txq;
+		priv->nae_rx_qid 	= nae_cfg->ports[i].rxq;
 		dev->features |= NETIF_F_LLTX;
 
 		register_netdev(dev);
@@ -1296,9 +1305,9 @@ static void nlm_xlp_nae_init(void)
 	}
 
 	/* configure the descs */
-	if(nae_cfg.freein_fifo_shared) {
+	if(nae_cfg->freein_fifo_shared) {
 		int max_descs_pqueue, num_descs;
-		max_descs_pqueue = nae_cfg.freein_fifo_onchip_num_descs +  nae_cfg.freein_fifo_spill_num_descs;
+		max_descs_pqueue = nae_cfg->freein_fifo_onchip_num_descs +  nae_cfg->freein_fifo_spill_num_descs;
 		num_descs = num_descs_perq <= max_descs_pqueue ? num_descs_perq : max_descs_pqueue;
 
 		for(i = 0; i < frin_total_queue; i++) {
@@ -1306,18 +1315,18 @@ static void nlm_xlp_nae_init(void)
 				nlm_replenish_per_cpu_buffer(i, num_descs);
 		}
 		/* configure the mgmt port, for mgmt ports take it from the port config */
-		for(i = 0; i < nae_cfg.num_ports; i++) {
-			if(!nae_cfg.ports[i].mgmt)
+		for(i = 0; i < nae_cfg->num_ports; i++) {
+			if(!nae_cfg->ports[i].mgmt)
 				continue;
-			nlm_replenish_per_cpu_buffer(nae_cfg.ports[i].rxq - frin_queue_base, 
-					nae_cfg.ports[i].num_free_desc);
+			nlm_replenish_per_cpu_buffer(nae_cfg->ports[i].rxq - frin_queue_base, 
+					nae_cfg->ports[i].num_free_desc);
 		}
 
 	} else {
-		for(i = 0; i < nae_cfg.num_ports; i++)
+		for(i = 0; i < nae_cfg->num_ports; i++)
 		{
-			nlm_replenish_per_cpu_buffer(nae_cfg.ports[i].rxq - frin_queue_base, 
-					nae_cfg.ports[i].num_free_desc);
+			nlm_replenish_per_cpu_buffer(nae_cfg->ports[i].rxq - frin_queue_base, 
+					nae_cfg->ports[i].num_free_desc);
 		}
 	}
 }
@@ -1693,16 +1702,16 @@ static void xlp_mac_setup_hwaddr(struct dev_data *priv)
 {
         struct net_device *dev = priv->dev;
 
-        nlm_hal_write_mac_reg(priv->block, priv->index, MAC_ADDR0_LO, (dev->dev_addr[5] << 24) |
+        nlm_hal_write_mac_reg(priv->node, priv->block, priv->index, MAC_ADDR0_LO, (dev->dev_addr[5] << 24) |
 				(dev->dev_addr[4] << 16) | (dev->dev_addr[3] << 8) | (dev->dev_addr[2]));
 
-	nlm_hal_write_mac_reg(priv->block, priv->index, MAC_ADDR0_HI, (dev->dev_addr[1] << 24) |
+	nlm_hal_write_mac_reg(priv->node, priv->block, priv->index, MAC_ADDR0_HI, (dev->dev_addr[1] << 24) |
 				(dev->dev_addr[0] << 16));
 
-	nlm_hal_write_mac_reg(priv->block, priv->index, MAC_ADDR0_MASK_LO, 0xFFFFFFFF);
-	nlm_hal_write_mac_reg(priv->block, priv->index, MAC_ADDR0_MASK_HI, 0xFFFFFFFF);
+	nlm_hal_write_mac_reg(priv->node, priv->block, priv->index, MAC_ADDR0_MASK_LO, 0xFFFFFFFF);
+	nlm_hal_write_mac_reg(priv->node, priv->block, priv->index, MAC_ADDR0_MASK_HI, 0xFFFFFFFF);
 
-        nlm_hal_write_mac_reg(priv->block, priv->index, MAC_FILTER_CONFIG, (1 << MAC_FILTER_BCAST_EN_POS) |
+        nlm_hal_write_mac_reg(priv->node, priv->block, priv->index, MAC_FILTER_CONFIG, (1 << MAC_FILTER_BCAST_EN_POS) |
 						 (1 << MAC_FILTER_MCAST_EN_POS) | (1 << MAC_FILTER_ADDR0_VALID_POS) );
 
 }
diff --git a/drivers/misc/netlogic/nae-perf/xlp_nae.h b/drivers/misc/netlogic/nae-perf/xlp_nae.h
index f10f3cd..75df364 100644
--- a/drivers/misc/netlogic/nae-perf/xlp_nae.h
+++ b/drivers/misc/netlogic/nae-perf/xlp_nae.h
@@ -60,6 +60,7 @@ struct dev_data
         spinlock_t lock;
         unsigned short port;
 	unsigned short inited;
+	unsigned short node;
         unsigned short block;
         unsigned short index;
         unsigned short type;
-- 
1.9.1

