From 84beb4f66ac7eb325d7d695d9cd2e65a4bdd7f5f Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Fri, 3 May 2013 14:52:56 -0700
Subject: [PATCH 0136/1532] boot: increase COUNTON during boot-time
 count/compare synchronization

  o During boot time, to synchronise count/compare register,
    for slave cpus, the following code sequence will be executed:

      ......
      mfc0  <reg>, CP0_COUNT
      addiu <reg>, <reg>, COUNTON
      mtc0  <reg>, CP0_COMPARE

    The default COUNTON is 100.
  o The idea is shortly after CP0_COMPARE is written, an interrupt should
    be generated.
  o This seems not true in certain cases. The reason is:
      "mfc0 <reg, CP0_COUNT" insn can be executed speculatively,
      while "mtc0 <reg>, CP0_COMPARE" can only be executed non-speculatively.
    For example, at cycle x, "mfc0 <reg>, CP0_COUNT" is executed.
    However, maybe due to some previous load (missed in the cache) to be finished,
    or due to in unmapped space, insn fetching for new cache line won't happen
    until all previous insns are retired,
    at cycle (x + 300), "mtc0 <reg>, CP0_COMPARE" gets executed.
    The time interrupt will not be generated in this case.
  o To fix the issue, increase COUNTON to 500.

[Make it unconditional - jchandra@broadcom.com]
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/kernel/sync-r4k.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/arch/mips/kernel/sync-r4k.c b/arch/mips/kernel/sync-r4k.c
index 1ff43d5..123510f 100644
--- a/arch/mips/kernel/sync-r4k.c
+++ b/arch/mips/kernel/sync-r4k.c
@@ -25,7 +25,7 @@ static atomic_t __cpuinitdata count_count_start = ATOMIC_INIT(0);
 static atomic_t __cpuinitdata count_count_stop = ATOMIC_INIT(0);
 static atomic_t __cpuinitdata count_reference = ATOMIC_INIT(0);
 
-#define COUNTON 100
+#define COUNTON 500
 #define NR_LOOPS 5
 
 void __cpuinit synchronise_count_master(int cpu)
-- 
1.9.1

