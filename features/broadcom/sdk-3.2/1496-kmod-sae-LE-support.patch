From a3ceda917b852b9bf0f966f7b9608244cb2c2b7a Mon Sep 17 00:00:00 2001
From: reshmic <reshmic@broadcom.com>
Date: Mon, 7 May 2012 17:40:37 +0530
Subject: [PATCH 1496/1532] kmod/sae: LE support

Using cpu_to_beXX instead of direct assignment.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/crypto/sae/nlm_aead.c      | 28 ++++++++++++++--------------
 drivers/crypto/sae/nlm_crypto.c    | 15 ++++++++++++---
 drivers/crypto/sae/nlmcrypto_ifc.h |  8 ++++----
 3 files changed, 30 insertions(+), 21 deletions(-)

diff --git a/drivers/crypto/sae/nlm_aead.c b/drivers/crypto/sae/nlm_aead.c
index bd9153e..df3c09f 100755
--- a/drivers/crypto/sae/nlm_aead.c
+++ b/drivers/crypto/sae/nlm_aead.c
@@ -786,7 +786,7 @@ static int aead_crypt_gcm(struct aead_request *req, unsigned int op)
 	tmp_iv += GCM_RFC4106_IV_SIZE;
 
 	/*Set counter*/
-	*((uint32_t*)tmp_iv) = (uint32_t)1;
+	*((uint32_t*)tmp_iv) = cpu_to_be32((uint32_t)1);
 
 	param = (struct nlm_crypto_pkt_param *)NLM_CRYPTO_PKT_PARAM_OFFSET(aead_request_ctx(req));
 	hash_addr = (uint8_t *)NLM_HASH_OFFSET(aead_request_ctx(req));
@@ -961,22 +961,22 @@ static int aead_crypt_ccm(struct aead_request *req, unsigned int op)
 
 
 		if ( req->assoclen  < 65280) { 
-			*(short*)(auth_iv + 16) = (short)req->assoclen;
+			*(short*)(auth_iv + 16) = cpu_to_be16((short)req->assoclen);
 			extralen += 2;
 			auth_iv_frag_len = 18;
 		}
 		else
 		{
-			*(short*)(auth_iv+ 16) = (short)0xfffe;
-			*(short*)(auth_iv + 16) = (short)0xfffe;;
-			*(uint32_t*)(auth_iv + 18) = (uint32_t)req->assoclen;
-			*(uint32_t*)(auth_iv + 18) = (uint32_t)req->assoclen;
+			*(short*)(auth_iv+ 16) = cpu_to_be16((short)0xfffe);
+			*(short*)(auth_iv + 16) = cpu_to_be16((short)0xfffe);
+			*(uint32_t*)(auth_iv + 18) = cpu_to_be32((uint32_t)req->assoclen);
+			*(uint32_t*)(auth_iv + 18) = cpu_to_be32((uint32_t)req->assoclen);
 			auth_iv_frag_len = 22;
 			extralen += 6;
 		}
 	}
 	/*Setup AUTH IV*/
-	*(uint32_t*)&auth_iv[12] |= (uint32_t )cipher_len;
+	*(uint32_t*)&auth_iv[12] |= cpu_to_be32((uint32_t )cipher_len);
 
 
 	//one for cipher iv one for auth iv
@@ -1128,7 +1128,7 @@ static int aead_crypt_ctr(struct aead_request *req, unsigned int op)
 		tmp_iv += CTR_RFC3686_IV_SIZE;
 
 		/*Set counter*/
-		*((uint32_t *)tmp_iv) = (uint32_t)1;
+		*((uint32_t *)tmp_iv) = cpu_to_be32((uint32_t)1);
 	}
 
 	hash_addr = (uint8_t *)NLM_HASH_OFFSET(addr);
@@ -1508,7 +1508,7 @@ int xlp_aes_cbc_givencrypt(struct aead_givcrypt_request *req)
 
 	//TODO: Get the IV from random pool
 	memcpy(req->giv, nlm_ctx->iv_buf, nlm_ctx->iv_len);
-	*(uint64_t *)req->giv += req->seq;
+	*(uint64_t *)req->giv += ccpu_to_be64(req->seq);
 	memcpy(req->areq.iv, req->giv, nlm_ctx->iv_len);
 
 	return xlp_aes_cbc_encrypt(&req->areq);
@@ -1520,7 +1520,7 @@ static int xlp_3des_cbc_givencrypt(struct aead_givcrypt_request *req)
 	struct nlm_aead_ctx *nlm_ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
 
 	memcpy(req->giv, nlm_ctx->iv_buf, nlm_ctx->iv_len);
-	*(uint64_t *)req->giv += req->seq;
+	*(uint64_t *)req->giv += ccpu_to_be64(req->seq);
 	memcpy(req->areq.iv, req->giv, nlm_ctx->iv_len);
 
 	return xlp_3des_cbc_encrypt(&req->areq);
@@ -1532,7 +1532,7 @@ static int xlp_des_cbc_givencrypt(struct aead_givcrypt_request *req)
 	struct nlm_aead_ctx *nlm_ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
 	
 	memcpy(req->giv, nlm_ctx->iv_buf, nlm_ctx->iv_len);
-	*(uint64_t *)req->giv += req->seq;
+	*(uint64_t *)req->giv += ccpu_to_be64(req->seq);
 	memcpy(req->areq.iv, req->giv, nlm_ctx->iv_len);
 
 	return xlp_des_cbc_encrypt(&req->areq);
@@ -1548,7 +1548,7 @@ static int xlp_aes_gcm_givencrypt(struct aead_givcrypt_request *req)
 	int ret;
 
 	memcpy(req->giv, nlm_ctx->iv_buf + GCM_RFC4106_NONCE_SIZE,nlm_ctx->iv_len);
-	*(uint64_t *)req->giv += req->seq;
+	*(uint64_t *)req->giv += ccpu_to_be64(req->seq);
 
 	areq->iv = req->giv;
 	ret = xlp_aes_gcm_encrypt(&req->areq);
@@ -1566,7 +1566,7 @@ static int xlp_aes_ccm_givencrypt(struct aead_givcrypt_request *req)
 	int ret;
 
 	memcpy(req->giv, nlm_ctx->iv_buf + CCM_RFC4309_NONCE_SIZE, nlm_ctx->iv_len);
-	*(uint64_t *)req->giv += req->seq;
+	*(uint64_t *)req->giv += ccpu_to_be64(req->seq);
 
 	areq->iv = req->giv;
 	ret = xlp_aes_ccm_encrypt(&req->areq);
@@ -1591,7 +1591,7 @@ int xlp_aes_ctr_givencrypt(struct aead_givcrypt_request *req)
 	iv += CTR_RFC3686_IV_SIZE;
 
 	/*Set counter*/
-	*((uint32_t *)iv) = (uint32_t)1;
+	*((uint32_t *)iv) = cpu_to_be32((uint32_t)1);
 	
 	return xlp_aes_ctr_encrypt(&req->areq);
 }
diff --git a/drivers/crypto/sae/nlm_crypto.c b/drivers/crypto/sae/nlm_crypto.c
index 354be9f..da6ece3 100644
--- a/drivers/crypto/sae/nlm_crypto.c
+++ b/drivers/crypto/sae/nlm_crypto.c
@@ -277,6 +277,7 @@ void print_cntl_instr(uint64_t cntl_desc)
 	unsigned int tmp;
 	char *x;
 	char s[NLM_CRYPTO_MAX_STR_LEN];
+	cntl_desc = ccpu_to_be64(cntl_desc);
 
 	printf("control description: 0x%016llx\n", (unsigned long long)cntl_desc);
 	printf("HMac = 0x%llx  \n", xtract_bits(cntl_desc, 61, 1));
@@ -319,11 +320,18 @@ struct designer_desc{
 };
 
 
-void print_pkt_desc(struct nlm_crypto_pkt_param  *pkt_desc, int index)
+void print_pkt_desc(struct nlm_crypto_pkt_param  *pkt_desc1, int index)
 {
 	int i;
 	unsigned long  phys;
 	void * virt;
+	
+	struct nlm_crypto_pkt_param * pkt_desc = kmalloc(sizeof(struct nlm_crypto_pkt_param) + 256 ,GFP_KERNEL);;
+	pkt_desc->desc0 = ccpu_to_be64(pkt_desc1->desc0); 
+	pkt_desc->desc1 = ccpu_to_be64(pkt_desc1->desc1); 
+	pkt_desc->desc2 = ccpu_to_be64(pkt_desc1->desc2); 
+	pkt_desc->desc3 = ccpu_to_be64(pkt_desc1->desc3); 
+	
 
 	printf("Packet desc address = %p\n",pkt_desc);
 	printf("Packet Descriptor 0: 0x%016llx\n", (unsigned long long)pkt_desc->desc0);
@@ -362,15 +370,16 @@ void print_pkt_desc(struct nlm_crypto_pkt_param  *pkt_desc, int index)
 	int len;
 
         for (i=0; i < index; i++) {
+		pkt_desc->segment[i][0] = ccpu_to_be64(pkt_desc1->segment[i][0]); 
+		pkt_desc->segment[i][1] = ccpu_to_be64(pkt_desc1->segment[i][1]);
 		printf("Packet Descriptor frag src %d: 0x%016llx\n", i, (unsigned long long)pkt_desc->segment[i][0]);
 		printf("Packet Descriptor frag dst %d: 0x%016llx\n", i, (unsigned long long)pkt_desc->segment[i][1]);
 
 		phys = xtract_bits(pkt_desc->segment[i][0], 0,40);
 		virt = phys_to_virt(phys);
 		len = xtract_bits(pkt_desc->segment[i][0], 48, 16); 
-		len = (len > 32 ) ? 32 : len;
+		len = (len > 64 ) ? 64 : len;
 		hex_dump("src",virt,len);
-		printk("virtual is %p and phys is %lx\n",virt,phys);
 
 
                 printf("frag src length = 0x%llx  \n", xtract_bits(pkt_desc->segment[i][0], 48, 16));
diff --git a/drivers/crypto/sae/nlmcrypto_ifc.h b/drivers/crypto/sae/nlmcrypto_ifc.h
index 843c547..e5dd44d 100644
--- a/drivers/crypto/sae/nlmcrypto_ifc.h
+++ b/drivers/crypto/sae/nlmcrypto_ifc.h
@@ -53,11 +53,11 @@ static inline int crypto_fill_pkt_seg_paddr_len(void *vaddr, unsigned int inlen,
 			
 		len = remlen > NLM_CRYPTO_MAX_SEG_LEN ? NLM_CRYPTO_MAX_SEG_LEN : remlen;
 		if(fillsrc)
-			segs[sg].src = ccpu_to_be64(virt_to_phys(vaddr) | 
-					((unsigned long long)(len - 1) << NLM_CRYPTO_SEGS_LEN_OFF) | sinitval);
+			segs[sg].src = ccpu_to_be64((virt_to_phys(vaddr) | 
+					((unsigned long long)(len - 1) << NLM_CRYPTO_SEGS_LEN_OFF) | sinitval));
 		if(filldst)
-			segs[sg].dst = ccpu_to_be64(virt_to_phys(vaddr) | 
-					((unsigned long long)(len - 1) << NLM_CRYPTO_SEGS_LEN_OFF) | dinitval);
+			segs[sg].dst = ccpu_to_be64((virt_to_phys(vaddr) | 
+					((unsigned long long)(len - 1) << NLM_CRYPTO_SEGS_LEN_OFF) | dinitval));
 		remlen -= len;
 		vaddr += len;
 		sg++;
-- 
1.9.1

