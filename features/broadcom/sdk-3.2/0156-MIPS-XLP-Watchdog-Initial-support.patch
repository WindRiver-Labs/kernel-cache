From 95eeeab8da978ff8f0cae70745245bae015858d7 Mon Sep 17 00:00:00 2001
From: Prem Mallappa <pmallapp@broadcom.com>
Date: Fri, 7 Feb 2014 16:40:14 +0530
Subject: [PATCH 0156/1532] MIPS:XLP:Watchdog Initial support

Signed-off-by: Prem Mallappa <pmallapp@broadcom.com>
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/watchdog/Kconfig          |   8 +
 drivers/watchdog/Makefile         |   1 +
 drivers/watchdog/nlm_common_wdt.c | 347 ++++++++++++++++++++++++++++++++++++++
 3 files changed, 356 insertions(+)
 create mode 100644 drivers/watchdog/nlm_common_wdt.c

diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 9debff3..cd68603 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -1079,6 +1079,14 @@ config TXX9_WDT
 	help
 	  Hardware driver for the built-in watchdog timer on TXx9 MIPS SoCs.
 
+config NLM_WATCHDOG
+	tristate "Netlogic XL* Hardware Watchdog"
+	depends on WATCHDOG_CORE && NLM_COMMON
+	help
+	  Hardware driver for the XL* watchdog. This is a watchdog timer
+	  that will reboot the machine after a 60 second timer expired
+	  and no process has written to /dev/watchdog during that time.
+
 config OCTEON_WDT
 	tristate "Cavium OCTEON SOC family Watchdog Timer"
 	depends on CPU_CAVIUM_OCTEON
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index e5165ab..8367303 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -135,6 +135,7 @@ obj-$(CONFIG_TXX9_WDT) += txx9wdt.o
 obj-$(CONFIG_OCTEON_WDT) += octeon-wdt.o
 octeon-wdt-y := octeon-wdt-main.o octeon-wdt-nmi.o
 obj-$(CONFIG_LANTIQ_WDT) += lantiq_wdt.o
+obj-$(CONFIG_NLM_WATCHDOG) += nlm_common_wdt.o
 
 # PARISC Architecture
 
diff --git a/drivers/watchdog/nlm_common_wdt.c b/drivers/watchdog/nlm_common_wdt.c
new file mode 100644
index 0000000..73cf2ea
--- /dev/null
+++ b/drivers/watchdog/nlm_common_wdt.c
@@ -0,0 +1,347 @@
+/*
+ * Copyright (c) 2014 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+
+/* 
+ * TODO:
+ * 2. Move from RESET to NMI, dump regs on NMI
+ *
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/types.h>
+#include <linux/timer.h>
+#include <linux/miscdevice.h> /* for MODULE_ALIAS_MISCDEV */
+#include <linux/watchdog.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/cpufreq.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/spinlock.h>
+#include <linux/cpu.h>
+#include <linux/smp.h>
+#include <linux/platform_device.h>
+
+#include <asm/netlogic/common.h>
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/mips-extns.h>
+
+#include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/xlp-hal/pic.h>
+#include <asm/netlogic/xlp-hal/sys.h>
+#include <asm/mach-netlogic/multi-node.h>
+
+#define WDOG_TIMEOUT	10
+#define WDOG_INDEX	0
+
+#define WDOG_RST_WRAP_CNT 3
+#define WDOG_NMI_WRAP_CNT 1
+
+struct nlm_wdt_data {
+	spinlock_t lock;
+};
+
+/* (secs) Default is 1 minute */
+static unsigned int heartbeat = WDOG_TIMEOUT;
+module_param(heartbeat, int, S_IRUGO);
+MODULE_PARM_DESC(heartbeat,
+	"Watchdog heartbeat in seconds. (0 < heartbeat, default="
+				__MODULE_STRING(WDOG_TIMEOUT) ")");
+
+/* There are 2 watchdog timers, specify or '0' as default */
+static unsigned int wd_index = WDOG_INDEX;
+module_param(wd_index, int, S_IRUGO);
+MODULE_PARM_DESC(wd_index,
+	"Watchdog to use, 0 and 1 are valid inputs (default="
+				__MODULE_STRING(WDOG_INDEX) ")");
+
+static struct watchdog_info nlm_wdt_ident = {
+	.options =	WDIOF_MAGICCLOSE |
+			WDIOF_SETTIMEOUT |
+			WDIOF_KEEPALIVEPING,
+	.identity	= "XLP Watchdog",
+};
+
+#define get_pic_base_current() nlm_get_node(nlm_cpuid_to_node(smp_processor_id()))->picbase
+
+#define get_pic_base_cpu(c) nlm_get_node(nlm_cpuid_to_node((c)))->picbase
+
+static void nlm_wdt_cpu_setup(int cpu)
+{
+	u64 val;
+	int base;
+	int cpuid = cpu_logical_map(cpu);
+
+	base = get_pic_base_cpu(cpu);
+
+	/* Enable0 can configure upto 64 threads, for more use Enable1 */
+	if (cpuid < 64) {
+	     val = nlm_read_pic_reg(base, PIC_WDOG_ENABLE0(wd_index));
+	     val |= 1ULL << cpuid;
+	     nlm_write_pic_reg(base, PIC_WDOG_ENABLE0(wd_index), val);
+	} else	{
+		val = nlm_read_pic_reg(base, PIC_WDOG_ENABLE1(wd_index));
+	     val |= 1ULL << (cpuid - 64);
+	     nlm_write_pic_reg(base, PIC_WDOG_ENABLE1(wd_index), val);
+	}
+	/* Set the Beat for this cpu */
+	nlm_write_pic_reg(base, PIC_WDOG_BEATCMD(wd_index), cpuid);
+}
+
+static void nlm_wdt_cpu_cleanup(int cpu)
+{
+	u64 val;
+	int base;
+	int cpuid = cpu_logical_map(cpu);
+
+	base = get_pic_base_cpu(cpu);
+
+	/* Enable0 can configure upto 64 threads, for more use Enable1 */
+	if (cpuid < 64) {
+	     val = nlm_read_pic_reg(base, PIC_WDOG_ENABLE0(wd_index));
+	     val &= ~(1ULL << cpuid);
+	     nlm_write_pic_reg(base, PIC_WDOG_ENABLE0(wd_index), val);
+	} else	{
+	     val = nlm_read_pic_reg(base, PIC_WDOG_ENABLE1(wd_index));
+	     val &= ~(1ULL << (cpuid - 64));
+	     nlm_write_pic_reg(base, PIC_WDOG_ENABLE1(wd_index), val);
+       }
+}
+
+static int nlm_wdt_hotplug_notify(struct notifier_block *this,
+			      unsigned long code,
+			      void *hotcpu)
+{
+	unsigned int cpu = (unsigned long)hotcpu;
+	switch (code) {
+	case CPU_ONLINE:
+		nlm_wdt_cpu_setup(cpu);
+		break;
+	case CPU_DOWN_PREPARE:
+		nlm_wdt_cpu_cleanup(cpu);
+		break;
+	default:
+		break;
+	}
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block nlm_notifier = {
+	.notifier_call = nlm_wdt_hotplug_notify,
+};
+
+static int nlm_wdt_keepalive(struct watchdog_device *wdt_dev)
+{
+	int lcpu;
+	u64 base;
+	struct nlm_wdt_data *wdt = watchdog_get_drvdata(wdt_dev);
+	base = get_pic_base_current();
+
+	spin_lock(&wdt->lock);
+	for_each_online_cpu(lcpu) {
+		u64 base = get_pic_base_cpu(lcpu);
+		int cpu = cpu_logical_map(lcpu);
+
+		/*
+		 * BEATCMD should be written ((4 * cpuno) + threadno),
+		 * cpu is exactly that
+		 */
+		nlm_write_pic_reg(base, PIC_WDOG_BEATCMD(wd_index), cpu);
+
+	}
+	spin_unlock(&wdt->lock);
+
+	return 0;
+}
+
+static int nlm_wdt_start(struct watchdog_device *wdt_dev) 
+{
+	int cpu;
+	u64 base = get_pic_base_current();
+
+	/*
+	 * Program max value, once watchdog reaches 0,
+	 * value in this register is used to reload
+	 */
+	nlm_write_pic_reg(base, PIC_WDOG_MAXVAL(wd_index),
+				(pic_timer_freq() * heartbeat) >> 2);
+
+	for_each_online_cpu(cpu)
+		nlm_wdt_cpu_setup(cpu);
+
+	/* TODO: This should be changed to NMI */
+	/* Enable watchdog[0/1], also set wraparound count */
+	nlm_write_pic_reg(base, PIC_CTRL,
+			  nlm_read_pic_reg(base, PIC_CTRL) |
+			  WDOG_RST_WRAP_CNT << PIC_CTRL_WWR0 |
+			  WDOG_RST_WRAP_CNT << PIC_CTRL_WWR1 |
+			  //WDOG_NMI_WRAP_CNT << PIC_CTRL_WWN0 |
+			  //WDOG_NMI_WRAP_CNT << PIC_CTRL_WWN1 |
+			  1 << wd_index);
+
+	return 0;
+}
+
+static int nlm_wdt_stop(struct watchdog_device *wdt_dev)
+{
+	int cpu;
+	u64 base = get_pic_base_current();
+	u64 val = nlm_read_pic_reg(base, PIC_CTRL);
+
+	val &= ~(1 << wd_index);
+	nlm_write_pic_reg(base, PIC_CTRL, val);
+			  
+	for_each_online_cpu(cpu)
+		nlm_wdt_cpu_cleanup(cpu);
+
+	return 0;
+}
+
+static int nlm_wdt_set_timeout(struct watchdog_device *wdt_dev, unsigned int t)
+{
+	u64 base = get_pic_base_current();
+
+	heartbeat = t;
+	nlm_write_pic_reg(base, PIC_WDOG_MAXVAL(wd_index),
+				(pic_timer_freq() * t) >> 2);
+        
+	return 0;
+}
+
+static struct watchdog_ops nlm_wdt_ops = {
+	.owner = THIS_MODULE,
+	.start = nlm_wdt_start,
+	.stop = nlm_wdt_stop,
+	.ping = nlm_wdt_keepalive,
+	.set_timeout = nlm_wdt_set_timeout,
+};
+
+static struct watchdog_device nlm_wdt_wdd = {
+	.info = &nlm_wdt_ident,
+	.ops = &nlm_wdt_ops,
+};
+
+/* hotplug */
+
+static int __devinit nlm_wdt_probe(struct platform_device *pdev)
+{
+
+	struct nlm_wdt_data *wdt;
+	struct resource *res;
+	int ret;
+
+	/* set index to sane value */
+	wd_index = wd_index ? 1: 0;
+
+	/*
+	 * Global watchdog, disabling percpu instances
+	 */
+	if (pdev->id != -1)
+		return -EINVAL;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (unlikely(!res))
+		ret = -EINVAL;
+
+	wdt = devm_kzalloc(&pdev->dev, sizeof(struct nlm_wdt_data),
+			   GFP_KERNEL);
+	if (unlikely(!wdt))
+		return -ENOMEM;
+
+	watchdog_set_drvdata(&nlm_wdt_wdd, wdt);
+
+	ret = watchdog_register_device(&nlm_wdt_wdd);
+	if (ret) {
+		pr_err("Can't register watchdog(ret=%d)\n", ret);
+		goto free_out;
+	}
+
+	ret = register_hotcpu_notifier(&nlm_notifier);
+	if (ret) {
+		pr_err("Can't register notifier (err=%d)\n", ret);
+		goto unreg_wdd;
+	}
+
+	platform_set_drvdata(pdev, wdt);
+
+	dev_info(&pdev->dev, "initialized.\n");
+
+	return 0;
+
+unreg_wdd:
+	watchdog_unregister_device(&nlm_wdt_wdd);
+free_out:
+	devm_kfree(&pdev->dev, wdt);
+	
+	return ret;
+
+}
+
+static int __devexit nlm_wdt_remove(struct platform_device *pdev)
+{
+	struct nlm_wdt_data *wdt = dev_get_drvdata(&pdev->dev);
+
+	watchdog_unregister_device(&nlm_wdt_wdd);
+
+	unregister_hotcpu_notifier(&nlm_notifier);
+
+	devm_kfree(&pdev->dev, wdt);
+
+	return 0;
+}
+
+static const struct of_device_id nlm_wdt_match[] = {
+	{ .compatible = "netlogic,nlm-wdt" },
+	{},
+};
+
+
+
+static struct platform_driver nlm_wdt_driver = {
+	.probe = nlm_wdt_probe,
+	.remove = __devexit_p(nlm_wdt_remove),
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "nlm-wdt",
+		.of_match_table = nlm_wdt_match,
+	},
+};
+
+module_platform_driver(nlm_wdt_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Prem Mallappa <prem.mallappa@broadcom.com>");
+MODULE_AUTHOR("Subhendu Sekhar Behera <sbehera@broadcom.com>");
+MODULE_DESCRIPTION("Broadcom XL* Processor Watchdog");
+MODULE_ALIAS("platform:nlm-wdt");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
-- 
1.9.1

