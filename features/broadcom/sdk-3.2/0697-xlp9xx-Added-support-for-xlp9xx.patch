From 30a922b32490f3d72d1a9ef7cb893336e1bd7259 Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikas.gupta@broadcom.com>
Date: Fri, 24 May 2013 16:51:58 +0530
Subject: [PATCH 0697/1532] xlp9xx: Added support for xlp9xx.

	1) support for netior support for XFI.
	2) support for pcs layer, lane configuration for XFI.
	3) lane reset for SGMII, XAUI, RXAUI and XFI.
	4) pma2p0 configuration for XFI/XLAUI 10G/lane speed.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../netlogic/lib/netlib/include/netsoc_common.h    |  32 +-
 arch/mips/netlogic/lib/netlib/include/netsoc_dev.h |  42 +-
 .../netlogic/lib/netlib/include/netsoc_haliface.h  |   5 +
 .../netlogic/lib/netlib/include/netsoc_libiface.h  |  13 +-
 arch/mips/netlogic/lib/netlib/include/netsoc_nae.h |  19 +-
 .../lib/netlib/include/nlm_hal_vsemi_data.h        |   5 +
 arch/mips/netlogic/lib/netlib/include/nlm_nae.h    |   7 +-
 arch/mips/netlogic/lib/netlib/src/netsoc_config.c  |   4 +-
 arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c     |  21 +
 arch/mips/netlogic/lib/netlib/src/netsoc_nae.c     | 154 ++++++-
 arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c     | 463 ++++++++++++++++++++-
 arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c    |  64 +--
 .../netlogic/lib/netlib/src/nlm_hal_vsemi_config.c |  93 +++++
 .../netlogic/lib/syslib/include/nlm_evp_cpld.h     |   2 +
 .../lib/syslib/include/nlm_hal_vsemi_data.h        |  56 ---
 15 files changed, 842 insertions(+), 138 deletions(-)
 delete mode 100644 arch/mips/netlogic/lib/syslib/include/nlm_hal_vsemi_data.h

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
index 77f4513..b99e796 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
@@ -67,6 +67,10 @@
 #define DEFAULT_SGMII_CAL_SLOTS         3
 #define DEFAULT_XAUI_CAL_SLOTS          13
 #define DEFAULT_ILK_CAL_SLOTS           26
+#define DEFAULT_XFI_CAL_SLOTS          7
+#define DEFAULT_XLAUI_CAL_SLOTS                13
+
+
 
 
 typedef struct {
@@ -247,6 +251,10 @@ static inline int get_slots_required(int intf_type)
                 return DEFAULT_XAUI_CAL_SLOTS;
         else if (intf_type == INTERLAKEN_IF)
                 return DEFAULT_ILK_CAL_SLOTS;
+        else if (intf_type == XFI_IF)
+                return DEFAULT_XFI_CAL_SLOTS;
+        else if (intf_type == XLAUI_IF)
+                return DEFAULT_XLAUI_CAL_SLOTS;
         else
                 return 0;
 }
@@ -352,17 +360,21 @@ static inline void update_default_config(int intf_type, uint32_t *config, uint32
 
 static inline int get_num_ports(int block, int intf_type)
 {
-        if (intf_type == SGMII_IF) {
-                if ((is_nlm_xlp9xx()) && block == 2)
-                        return 1;
+	if (intf_type == SGMII_IF) {
+		if(is_nlm_xlp9xx() && block==2){
+			return 1;
+		}else if (block < 4)
+			return 4;
+		else
+			return 2;
+	} else if (is_nlm_xlp9xx() && intf_type == XFI_IF) {
+               return 4;
+	}else if (is_nlm_xlp9xx() && intf_type == XLAUI_IF) {
+		return 1;
+	}
+	else
+		return 1;	
 
-                if (block < 4)
-                        return 4;
-                else
-                        return 2;
-        }
-        else
-                return 1;
 }
 
 #endif
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
index 41196b1..c224230 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
@@ -203,8 +203,17 @@ enum NAE_INTF_TYPE {
 	GMAC_1 = 1,
 	GMAC_2 = 2,
 	GMAC_3 = 3,
-	XGMAC  = 4,
+	
+	XGMAC0  = 4,
+	
 	INTERLAKEN = 5,
+	
+	XLGMAC = 0x7,
+	
+	XGMAC1 =  0xA,
+	XGMAC2 = 0xB,
+	XGMAC3 = 0xC,
+	
 	PHY	 = 0xE,
 	LANE_CFG = 0xF,
 };      
@@ -506,16 +515,20 @@ enum {
 	PHYMODE_XAUI = 1,
 	PHYMODE_SGMII = 2,
 	PHYMODE_IL = 3,
-        PHYMODE_RXAUI = 6,
 
-        /* NET Version 1 
-        PHYMODE_XLAUI = 4,
-        */
-        /* submodes */
-        PHYMODE_XFI,
+       PHYMODE_XLAUI = 4,
+       PHYMODE_RXAUI = 6,
+       PHYMODE_XFI = 7,
+
 };
 
 enum {
+       XAUI_TYPE_LANE =0,      /* 10G/4lane */
+       XFI_TYPE_LANE = 1       /* 10G/lane */
+};
+
+
+enum {
 	LM_UNCONNECTED = 0,
 	LM_SGMII = 1,
 	LM_XAUI = 2,
@@ -541,12 +554,21 @@ enum {
 	#define VSEMI_CTL_XAUI_DR	(0x2)
 	#define VSEMI_CTL_SGMII_DR	(0x1)
 
+       #define VSEMI_CTL_XFI_DR        (3)
+       #define VSEMI_CTL_XLAUI_DR      (3)
+       #define VSEMI_CTL_XLAUI_ILK     (3)
+
+
 	#define VSEMI_CTL_MASK_DW	(0x70)
 	#define VSEMI_CTL_RXAUI_10G_DW	(0x30)
 	#define VSEMI_CTL_XAUI_16G_DW	(0x10)
 	#define VSEMI_CTL_XAUI_12G_DW	(0x10)
 	#define VSEMI_CTL_XAUI_DW	(0x10)
 	#define VSEMI_CTL_SGMII_DW	(0x10)
+        #define VSEMI_CTL_XFI_DW        (0x5<<4)
+        #define VSEMI_CTL_XLAUI_DW      (0x5<<4)
+        #define VSEMI_CTL_ILK_DW        (0x3<<4)
+
 	
 #define VSEMI_STATUS			0xC
 #define VSEMI_PINCTRL			0xD
@@ -598,6 +620,12 @@ enum {
     #define LANE_CFG_LANE_2_POS         8
     #define LANE_CFG_LANE_3_POS         12
 
+    #define COMPLEX0_RXAUI_EN           16
+    #define COMPLEX1_RXAUI_EN           18
+    #define COMPLEX0_XFI_EN             17
+    #define COMPLEX1_XFI_EN             19
+
+
     #define LANE_CFG_DISCONNECT         0
     #define LANE_CFG_GMAC               1
     #define LANE_CFG_XGMAC              2
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
index 6210559..574a5a4 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
@@ -79,6 +79,7 @@ extern int __netsoc_init_poe(poe_t *poe);
 
 extern void __netsoc_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask);
 extern void __netsoc_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phymode);
+extern void __netsoc_xfi_pcs_init(nae_t *nae, uint32_t xfi_cplx_mask, uint32_t phymode);
 extern int __netsoc_interlaken_pcs_init(nae_t *nae, uint32_t ilk_complex_map);
 extern int register_marvell_phy(void);
 extern int register_broadcom_phy(void);
@@ -103,6 +104,10 @@ extern unsigned char vsemi_mem_12G [256];
 
 extern unsigned char vsemi_mem_16G_4page [256];
 extern unsigned char vsemi_mem_16G [256];
+
+extern unsigned char vsemi_mem_10G_lane[256];
+extern unsigned char vsemi_mem_10G_lane_4page[256];
+
 extern void vsemi_mem_init_sgmii_125Mhzrefclk(void);
 extern void nlm_hal_config_vsemi_mem_sgmii_4page_125Mhz(void);
 
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
index f789f0f..b4c15fe 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
@@ -238,8 +238,17 @@ static inline void netsoc_api_writel(uint64_t base, uint32_t index, uint32_t val
 #define netsoc_get_macreg_base_for_ilk(mac_base, hwport) \
 	NETSOC_MAC_OFFSET(mac_base, (hwport / XLP_ILK_MAX_LANES), INTERLAKEN)
  	
-#define netsoc_get_macreg_base_for_xgmac(mac_base, hwport) \
-        NETSOC_MAC_OFFSET(mac_base, (hwport / MAX_PORTS_PERBLOCK), XGMAC)
+#define netsoc_get_macreg_base_for_xgmac0(mac_base, hwport) \
+        NETSOC_MAC_OFFSET(mac_base, (hwport / MAX_PORTS_PERBLOCK), XGMAC0)
+
+#define netsoc_get_macreg_base_for_xgmac1(mac_base, hwport) \
+        NETSOC_MAC_OFFSET(mac_base, (hwport / MAX_PORTS_PERBLOCK), XGMAC1)
+
+#define netsoc_get_macreg_base_for_xgmac2(mac_base, hwport) \
+        NETSOC_MAC_OFFSET(mac_base, (hwport / MAX_PORTS_PERBLOCK), XGMAC2)
+
+#define netsoc_get_macreg_base_for_xgmac3(mac_base, hwport) \
+        NETSOC_MAC_OFFSET(mac_base, (hwport / MAX_PORTS_PERBLOCK), XGMAC3)
 
 #define netsoc_get_macreg_base_for_gmac(mac_base, hwport) \
         NETSOC_MAC_OFFSET(mac_base, (hwport / MAX_PORTS_PERBLOCK), (hwport % MAX_PORTS_PERBLOCK))
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
index 0471dd2..dd653de 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
@@ -826,6 +826,21 @@ static inline int __netsoc_config_burstmax(net_port_t *netport, uint32_t max)
         return 0;
 }
 
+static inline uint64_t __netsoc_get_xgmac_base(net_port_t *netport)
+{
+	nae_t *nae = netport->nae;
+	uint64_t mac_base;
+	switch (netport->hw_port_id/MAX_PORTS_PERBLOCK) {
+            case 0: mac_base = netsoc_get_macreg_base_for_xgmac0(nae->mac_base, netport->hw_port_id); break;
+            case 1: mac_base = netsoc_get_macreg_base_for_xgmac1(nae->mac_base, netport->hw_port_id); break;
+            case 2: mac_base = netsoc_get_macreg_base_for_xgmac2(nae->mac_base, netport->hw_port_id); break;
+            case 3: mac_base = netsoc_get_macreg_base_for_xgmac3(nae->mac_base, netport->hw_port_id); break;
+	    default:
+		return 0; 	
+        }
+	return mac_base;
+}
+
 static inline int __netsoc_get_burstmax(net_port_t *netport)
 {
 	uint64_t nae_base = netport->nae->nae_base;
@@ -881,7 +896,7 @@ static inline int  __netsoc_config_macen(net_port_t *netport, uint32_t enable, u
                         break;
                 case XAUI_IF:
                 case RXAUI_IF:
-                        mac_base = netsoc_get_macreg_base_for_xgmac(nae->mac_base, netport->hw_port_id);
+                        mac_base = netsoc_get_macreg_base_for_xgmac0(nae->mac_base, netport->hw_port_id);
                         xaui_cfg=netsoc_read_mac_reg(mac_base, XAUI_CONFIG_1);
                         if (enable) {
                              if (path == EGRESS_PATH) {
@@ -1105,7 +1120,7 @@ static inline int __netsoc_get_frame_size(net_port_t *netport)
                         break;
                 case XAUI_IF:
                 case RXAUI_IF:
-                        mac_base = netsoc_get_macreg_base_for_xgmac(nae->mac_base, netport->hw_port_id);
+                        mac_base = netsoc_get_macreg_base_for_xgmac0(nae->mac_base, netport->hw_port_id);
                         size = (netsoc_read_mac_reg(mac_base, XAUI_MAX_FRAME_LEN) >> 16) * 4;
                         break;
                 default:
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_hal_vsemi_data.h b/arch/mips/netlogic/lib/netlib/include/nlm_hal_vsemi_data.h
index 5030dfa..77765b6 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_hal_vsemi_data.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_hal_vsemi_data.h
@@ -10,6 +10,11 @@ extern void nlm_hal_config_vsemi_mem_12G(void);
 extern void nlm_hal_config_vsemi_mem_xaui(void);
 extern void nlm_hal_config_vsemi_mem_xaui_4page(void);
 
+void nlm_hal_config_vsemi_mem_10G_lane(void);   
+void nlm_hal_config_vsemi_mem_10G_lane_4page(void);     
+
+
+
 /*125 Mhz related functions*/
 void nlm_hal_config_vsemi_mem_16G_4page_125(void);
 void nlm_hal_config_vsemi_mem_16G_125(void);
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
index ec2f7f3..0ffe66e 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -318,6 +318,8 @@ struct nlm_hal_nae_config {
 	uint32_t higig_mode[MAX_NAE_CPLX_PER_NODE];
 	uint32_t xgmii_speed[MAX_NAE_CPLX_PER_NODE];
 	uint32_t rxaui_complex_map;
+	uint32_t xfi_complex_map;
+	uint32_t xlgmac_complex_map;
 	uint32_t ilk_complex_map;
 	// total queues used = num_contexts
 	uint32_t num_contexts;
@@ -363,9 +365,10 @@ enum if_type {
         SGMII_IF      = 1,
         XAUI_IF       = 2,
         INTERLAKEN_IF = 3,
+        /* Net version 1 */
+	XFI_IF	=	5,
+        XLAUI_IF      = 4 ,
         RXAUI_IF      = 6,
-        /* Net version 1 
-        XLAUI_IF      = 4 , */
 };
 
 extern nae_t *xlp_nae[NLM_MAX_NODES][MAX_NAE_PERNODE];
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
index 417322b..287e09e 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
@@ -289,8 +289,8 @@ static void dump_nae_config(nae_t *nae)
 					(unsigned long long)nae->pcie_base, nae->frequency, nae->fb_vc, nae->rx_vc, nae->frin_queue_base, nae->frin_total_queue);
 	netsoc_api_print(NETSOC_APIDBG_CONFIG, "num_ports %d flags 0x%x rx_cal_slots %d tx_cal_slots %d \n",nae->num_ports, nae->flags, nae->rx_cal_slots, nae->tx_cal_slots);
 	netsoc_api_print(NETSOC_APIDBG_CONFIG, "MDIO Mac base 0x%llx\n",(unsigned long long)netsoc_get_macreg_base_for_mdio(nae->mac_base));
-	netsoc_api_print(NETSOC_APIDBG_CONFIG, "netsoc_get_macreg_base_for_xgmac 0 0x%llx \n",(unsigned long long)netsoc_get_macreg_base_for_xgmac(nae->mac_base, 0));
-	netsoc_api_print(NETSOC_APIDBG_CONFIG, "netsoc_get_macreg_base_for_xgmac 4 0x%llx \n",(unsigned long long)netsoc_get_macreg_base_for_xgmac(nae->mac_base, 4));
+	netsoc_api_print(NETSOC_APIDBG_CONFIG, "netsoc_get_macreg_base_for_xgmac 0 0x%llx \n",(unsigned long long)netsoc_get_macreg_base_for_xgmac0(nae->mac_base, 0));
+	netsoc_api_print(NETSOC_APIDBG_CONFIG, "netsoc_get_macreg_base_for_xgmac 4 0x%llx \n",(unsigned long long)netsoc_get_macreg_base_for_xgmac0(nae->mac_base, 4));
 	
 	for(i=0; i < 8;i++){
 		netsoc_api_print(NETSOC_APIDBG_CONFIG, "netsoc_get_macreg_base_for_gmac %d 0x%llx \n", i, (unsigned long long)netsoc_get_macreg_base_for_gmac(nae->mac_base, i));
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index a38f668..5930451 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -167,6 +167,9 @@ static int fdt_get_interface_type(void *fdt, char *nae_port_str, int block, int
                 else if (!strcmp(port_type_str, "xaui")) {
                         intf_type = DC_XAUI;
                 }
+                else if (!strcmp(port_type_str, "xfi")) {
+                        intf_type = DC_XFI;
+                }
                 else if (!strcmp(port_type_str, "rxaui")) {
                         intf_type = DC_RXAUI;
                 }
@@ -226,6 +229,12 @@ static int fdt_get_interface_type(void *fdt, char *nae_port_str, int block, int
                         netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Complex %d in rxaui mode\n", block);
                         nae_cfg->ports[port].iftype = RXAUI_IF;
                         break;
+                case DC_XFI:
+                        netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Complex %d in XFI mode\n", block);
+                        for(offset = 0; offset < MAX_PORTS_PERBLOCK; offset++) {
+                                nae_cfg->ports[port+offset].iftype = XFI_IF;
+                        }
+                        break;
 #endif
                 default:
                         nae_cfg->ports[port].iftype = UNKNOWN_IF;
@@ -1024,6 +1033,18 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
                         nae_cfg->xaui_complex_map |= (1 << block);
 			nae_cfg->ports[port].rxaui_mode = NLM_NAE_XAUI_MODE_XAUI;
                 }
+                else if (intf_type == XFI_IF) {
+                        if (!socnet_version_v0) {
+                              sprintf(nae_port_str, "/soc/net@node-%d/nae-%d/complex@%d/xfi", node, nae_cfg->nae_id, block);
+                        }
+
+                        fdt_cmplx_offset = fdt_path_offset(fdt, nae_port_str);
+                        if (fdt_cmplx_offset < 0) {
+                                netsoc_api_print(NETSOC_APIDBG_FDT,"Complex %d XFI configuration missing in FDT \n", block);
+                                continue;
+                        }
+                        nae_cfg->xfi_complex_map |= (1 << block);
+                }
                 else if (intf_type == RXAUI_IF) {
                         if (socnet_version_v0) {
                                 sprintf(nae_port_str, "/soc/nae@node-%d/complex@%d/rxaui", node, block);
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 9d73cb98..fa1bd7b 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -1270,6 +1270,12 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 			thrgrp = 1;
 			rx_buf_size = nae->ports[port].rx_buf_size;
 			break;
+		//TODO: Verify the values	
+		   case XFI_IF:
+			fifo_xoff_thresh = 6;
+			max_lanes = 1;
+			offset = 1;
+			break;
 		   case SGMII_IF:
 			fifo_xoff_thresh = 6;
 			max_lanes = 1;
@@ -1794,6 +1800,40 @@ void __netsoc_mdio_init(nae_t *nae)
 	nlm_mdelay(3);
 }
 
+static void __netsoc_xfi_softreset(uint64_t mac_base,  uint32_t rst_val)
+{
+	uint32_t val;
+	val =  netsoc_read_mac_reg(mac_base, XGMAC_CTL_REG1);
+	val &= ~(0x3 << 11);
+	val |= ((rst_val & 0x3) << 11);
+        netsoc_write_mac_reg(mac_base, XGMAC_CTL_REG1, val);
+#if 0
+	// Lane 0
+	val =  netsoc_read_mac_reg(mac_base0, XGMAC_CTL_REG1);
+	val &= ~(0x3 << 11);
+	val |= ((rst_val & 0x3) << 11);
+        netsoc_write_mac_reg(mac_base0, XGMAC_CTL_REG1, val);
+	// Lane 1
+	val =  netsoc_read_mac_reg(mac_base1, XGMAC_CTL_REG1);
+	val &= ~(0x3 << 11);
+	val |= ((rst_val & 0x3) << 11);
+        netsoc_write_mac_reg(mac_base1, XGMAC_CTL_REG1, val);
+	// Lane 2
+	val =  netsoc_read_mac_reg(mac_base2, XGMAC_CTL_REG1);
+	val &= ~(0x3 << 11);
+	val |= ((rst_val & 0x3) << 11);
+        netsoc_write_mac_reg(mac_base2, XGMAC_CTL_REG1, val);
+	// Lane 3
+	val =  netsoc_read_mac_reg(mac_base3, XGMAC_CTL_REG1);
+	val &= ~(0x3 << 11);
+	val |= ((rst_val & 0x3) << 11);
+        netsoc_write_mac_reg(mac_base3, XGMAC_CTL_REG1, val);
+#endif
+	 
+	netsoc_api_print(NETSOC_APIDBG_PORT, "%s All XFI ports in a Quad resetted\n", __func__);
+
+}
+
 static void __netsoc_config_sgmii(net_port_t *netport)
 {
         unsigned int mac_cfg1 = 0, mac_cfg2 = 0;
@@ -1860,7 +1900,7 @@ static void __netsoc_config_xaui(net_port_t *netport)
         int rxaui_en = ((netport->rxaui_mode == NLM_NAE_RXAUI_MODE_MARVELL) ||
                         (netport->rxaui_mode == NLM_NAE_RXAUI_MODE_BROADCOM)) ? 1 : 0;
 	nae_t *nae = netport->nae;
-	uint64_t mac_base = netsoc_get_macreg_base_for_xgmac(nae->mac_base, netport->hw_port_id);
+	uint64_t mac_base = netsoc_get_macreg_base_for_xgmac0(nae->mac_base, netport->hw_port_id);
 
 	higig_type = nae->higig_mode[netport->hw_port_id >> 2];
         if(higig_type){
@@ -1959,6 +1999,68 @@ static void __netsoc_config_xaui(net_port_t *netport)
         netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL3, val); netsoc_api_print(NETSOC_APIDBG_PORT, "%s XAUI Config Complete block %d \n", __func__, netport->hw_port_id >> 2); return;
 }
 
+/*
+* @brief __netsoc_config_xfi initializes a XAUI port at the MAC level.
+*
+*
+* @return
+*       - none
+* 
+* @ingroup hal_nae
+*
+*/
+static void __netsoc_config_xfi(net_port_t *netport)
+{
+	/*Reset the XGMAC : reset all ports in quad */
+        uint32_t val = 0;
+	uint64_t mac_base = __netsoc_get_xgmac_base(netport);
+        
+	// Apply a soft reset.
+	__netsoc_xfi_softreset(mac_base, 0x2);
+	__netsoc_xfi_softreset(mac_base, 0x0);
+        
+	netsoc_write_mac_reg(mac_base, XAUI_CONFIG_0, 0xFFFFFFFF);
+        netsoc_write_mac_reg(mac_base, XAUI_CONFIG_0, 0x00000000);
+
+	/* Enable tx/rx frame */
+        val = 0xA00010A8;
+        val |= (XAUI_CONFIG_LENCHK | XAUI_CONFIG_GENFCS | XAUI_CONFIG_PAD_64);
+        netsoc_write_mac_reg(mac_base, XAUI_CONFIG_1, val );
+        /* write max frame len*/
+        netsoc_write_mac_reg(mac_base, XAUI_MAX_FRAME_LEN , 0x01800600);
+
+        /* set stats counter*/
+        val = netsoc_read_mac_reg(mac_base, NETIOR_XGMAC_CTRL1);
+        val |= 1 << NETIOR_XGMAC_STATS_EN_POS;
+
+        if (netport->vlan_pri_en) {  /*TODO: Add a condition for HIGIG*/
+                val |= 1 << NETIOR_XGMAC_TX_PFC_EN_POS;
+                val |= 1 << NETIOR_XGMAC_RX_PFC_EN_POS;
+                val |= 1 << NETIOR_XGMAC_TX_PAUSE_POS;
+                val |= 1 << NETIOR_XGMAC_VLAN_DC_POS;
+        } else {
+                val &= ~(1 << NETIOR_XGMAC_TX_PFC_EN_POS);
+                val &= ~(1<<NETIOR_XGMAC_RX_PFC_EN_POS);
+                val |= (1 << NETIOR_XGMAC_TX_PAUSE_POS);
+                val &= ~(1 << NETIOR_XGMAC_VLAN_DC_POS);
+        }
+        netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL1, val);
+
+                /*
+                 * Configuring the OFF/ON timer
+                 * 31:16  - In PFC mode is used as the Xoff value                                     
+                 * 15:0   - In PFC mode is used as the Xon value                                      
+                 *        - in Link level FC mode, is used as the Xoff value.                         
+                 */
+        if (netport->vlan_pri_en) {
+                val = 0xF1230000;          // PFC mode:  OffTimer = 0xF123  OnTimer = 0x0000  
+        } else {
+                val = 0x0000F123;          // Link level FC: OffTimer = 0xF123    
+        }
+        netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL2, val);
+}
+
+
 static void __netsoc_config_interlaken(net_port_t *netport, int num_lanes)
 {
         volatile uint32_t rxctrl = 0;
@@ -2108,7 +2210,7 @@ static int __netsoc_init_netior(nae_t *nae)
 			ifcredit |= (sgmii_ifcredit << (block * 8));
 			complex_mask |= (0xF << (block * 4));		//FIXME 
 		}
-		else if ((nae->xaui_complex_map & (1 << block)) || (nae->rxaui_complex_map & (1 << block))) {
+		else if ((nae->xaui_complex_map & (1 << block)) || (nae->rxaui_complex_map & (1 << block)) || (nae->xfi_complex_map & (1 << block))) {
 			ifcredit |= (xaui_ifcredit << (block * 8));
 			complex_mask |= (0xf << (block * 4));
 		}
@@ -2276,14 +2378,15 @@ int __netsoc_config_port(net_port_t *netport)
 	unsigned int netior_ctrl3 = 0;
 	uint32_t block = netport->hw_port_id >> 2;
 	nae_t *nae = netport->nae;
-	uint64_t mac_base, nae_base = nae->nae_base;
+	uint64_t mac_base =0; 
+	uint64_t nae_base = nae->nae_base;
 
 	netsoc_api_print(NETSOC_APIDBG_PORT, "%s: %d node %d ",__func__,block , nae->node);
 	switch(netport->iftype) {
 		case XAUI_IF:
 		case RXAUI_IF:
 			// block is a complex number
-			mac_base = netsoc_get_macreg_base_for_xgmac(nae->mac_base, netport->hw_port_id);
+			mac_base = netsoc_get_macreg_base_for_xgmac0(nae->mac_base, netport->hw_port_id);
 
 			netwk_inf = netsoc_read_mac_reg(mac_base, NETIOR_XGMAC_CTRL1);
 			netwk_inf |= (1 << NETIOR_XGMAC_STATS_CLR_POS);
@@ -2298,6 +2401,26 @@ int __netsoc_config_port(net_port_t *netport)
 		 	netsoc_write_nae_reg(nae_base, TX_CONFIG, tx_config | ( TXINITIORCR(ifmask)));
 		        netsoc_write_nae_reg(nae_base, TX_CONFIG, tx_config & ~( TXINITIORCR(ifmask)));
 			break;
+		case XFI_IF:
+			/*Clear all statistics */
+			switch (netport->hw_port_id/MAX_PORTS_PERBLOCK) {
+        	    		case 0: mac_base = netsoc_get_macreg_base_for_xgmac0(nae->mac_base, netport->hw_port_id); break;
+		        	case 1: mac_base = netsoc_get_macreg_base_for_xgmac1(nae->mac_base, netport->hw_port_id); break;
+			        case 2: mac_base = netsoc_get_macreg_base_for_xgmac2(nae->mac_base, netport->hw_port_id); break;
+			        case 3: mac_base = netsoc_get_macreg_base_for_xgmac3(nae->mac_base, netport->hw_port_id); break;
+        		}
+			netwk_inf = netsoc_read_mac_reg(mac_base, NETIOR_XGMAC_CTRL1);
+			netwk_inf |= (1 << NETIOR_XGMAC_STATS_CLR_POS);
+			netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL1, netwk_inf);
+
+			/*TODO: verify tx_ior_credit */	
+                        tx_ior_credit = netsoc_read_nae_reg(nae_base, TX_IORCRDT_INIT);
+			netsoc_write_nae_reg(nae_base, TX_IORCRDT_INIT, tx_ior_credit & (~ (1<<netport->hw_port_id)));
+			tx_config = netsoc_read_nae_reg(nae_base, TX_CONFIG);
+			// need to toggle these bits for credits to be loaded
+			netsoc_write_nae_reg(nae_base, TX_CONFIG, tx_config | ( TXINITIORCR(1<<netport->hw_port_id)));
+			netsoc_write_nae_reg(nae_base, TX_CONFIG, tx_config & (~( TXINITIORCR(1<<netport->hw_port_id))));
+
 		case INTERLAKEN_IF:
 			// block is a complex number
 			ifmask = 0xff << block;   //based on number of lanes
@@ -2386,7 +2509,7 @@ void __netsoc_mac_disable(net_port_t *netport)
 			break;
 		case XAUI_IF:
 		case RXAUI_IF:
-			mac_base = netsoc_get_macreg_base_for_xgmac(nae->mac_base, netport->hw_port_id);
+			mac_base = netsoc_get_macreg_base_for_xgmac0(nae->mac_base, netport->hw_port_id);
 			xaui_cfg=netsoc_read_mac_reg(mac_base, XAUI_CONFIG_1);
 			netsoc_write_mac_reg(mac_base, XAUI_CONFIG_1, xaui_cfg &
                                                         (~(XAUI_CONFIG_TFEN | XAUI_CONFIG_RFEN)));
@@ -2430,7 +2553,7 @@ void __netsoc_mac_enable(net_port_t *netport)
                         break;
                 case XAUI_IF:
                 case RXAUI_IF:
-			mac_base = netsoc_get_macreg_base_for_xgmac(nae->mac_base, netport->hw_port_id);
+			mac_base = netsoc_get_macreg_base_for_xgmac0(nae->mac_base, netport->hw_port_id);
 			xaui_cfg=netsoc_read_mac_reg(mac_base, XAUI_CONFIG_1);
 	                netsoc_write_mac_reg(mac_base, XAUI_CONFIG_1, xaui_cfg |
 							XAUI_CONFIG_TFEN | XAUI_CONFIG_RFEN);                           
@@ -2483,7 +2606,7 @@ int __netsoc_config_frame_size(net_port_t *netport, uint32_t size)
 			break;
 		case XAUI_IF:
                 case RXAUI_IF:
-                        mac_base = netsoc_get_macreg_base_for_xgmac(nae->mac_base, netport->hw_port_id);
+                        mac_base = netsoc_get_macreg_base_for_xgmac0(nae->mac_base, netport->hw_port_id);
 			netsoc_write_mac_reg(mac_base, XAUI_MAX_FRAME_LEN , ((size/4) << 16) | size);
 			break;
 		default:
@@ -2524,7 +2647,7 @@ int __netsoc_config_flow_control(net_port_t *netport, uint32_t enable)
 			break;
 		case XAUI_IF:
 		case RXAUI_IF:		
-			mac_base = netsoc_get_macreg_base_for_xgmac(nae->mac_base, netport->hw_port_id);
+			mac_base = netsoc_get_macreg_base_for_xgmac0(nae->mac_base, netport->hw_port_id);
 		
 			if (enable) {
 				val = netsoc_read_mac_reg(mac_base, NETIOR_XGMAC_CTRL1);
@@ -3209,6 +3332,11 @@ int __netsoc_pcs_init(nae_t *nae)
                 netsoc_api_print(NETSOC_APIDBG_GLOBAL, "node %d XAUI PCS init 0x%x \n", node, nae->xaui_complex_map);
                 __netsoc_xaui_pcs_init(nae, nae->xaui_complex_map, PHYMODE_XAUI );
         }
+        
+	if (nae->xfi_complex_map) {
+                netsoc_api_print(NETSOC_APIDBG_GLOBAL, "node %d XFI PCS init 0x%x \n", node, nae->xaui_complex_map);
+		__netsoc_xfi_pcs_init(nae, nae->xfi_complex_map, PHYMODE_XFI);
+        }
 
         if (nae->rxaui_complex_map) {
                 netsoc_api_print(NETSOC_APIDBG_GLOBAL, "node %d RXAUI PCS init 0x%x\n", node, nae->rxaui_complex_map);
@@ -3369,15 +3497,17 @@ static int is_ilk_lanealigned(nae_t *nae , int blk)
 static int __netsoc_init_net_port(net_port_t *netport, uint32_t context)
 {
 	uint32_t hw_port;
-	nae_t *nae;
-
-	nae = netport->nae;
-
+	nae_t *nae = netport->nae;
 	hw_port = netport->hw_port_id;
+
         if (netport->iftype == XAUI_IF) {
                 netsoc_api_print(NETSOC_APIDBG_PORT, "Cfg XAUI mode for port %d with higig type = %d \n", hw_port, nae->higig_mode[hw_port>>2]);
                 __netsoc_config_xaui(netport);
         }
+	else if (netport->iftype == XFI_IF) {
+                //netsoc_api_print(NETSOC_APIDBG_PORT, "Cfg XFI mode:%d \n", netport->xfi_mode);
+                __netsoc_config_xfi(netport);
+        }
 	else if (netport->iftype == RXAUI_IF) {
                 netsoc_api_print(NETSOC_APIDBG_PORT, "Cfg RXAUI mode:%d scrambler:%d\n",
                         netport->rxaui_mode, netport->rxaui_scrambler);
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
index 2325c9a..2d05846 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
@@ -338,6 +338,50 @@ static int xlp3xx_8xxb0_lane_reset_txpll(nae_t *nae, uint32_t block, uint32_t la
     return 0;
 }
 
+static void xlp9xx_lane_reset(nae_t *nae, int block, int lane_ctrl, int mode)
+{
+        uint32_t val = 0;
+	uint64_t mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+        netsoc_api_print(NETSOC_APIDBG_PORT,"%s: block %d lane_ctrl %x \n",__func__,block,lane_ctrl);
+	/*TODO: XLP9XX RXAUI check*/
+
+	if(mode==PHYMODE_SGMII && block==2 && lane_ctrl !=PHY_LANE_0_CTRL){
+		return; /*Only one lane in complex 2 */
+	}
+	
+	if(mode==PHYMODE_SGMII || mode==PHYMODE_HS_SGMII){
+        	val = (1<<20) | (1<<29) | (1<<31);
+	}else{
+        	val = (1<<20) | (1<<29);
+	}
+	if(mode==PHYMODE_XFI){
+		mode = PHYMODE_XAUI;
+	}	
+	val = (mode << PHY_LANE_CTRL_PHYMODE_POS);
+	if(lane_ctrl != 0){ //TODO: Verify for XLP9XX
+        	netsoc_write_mac_reg(mac_base, lane_ctrl, val);
+        	val = netsoc_read_mac_reg(mac_base, lane_ctrl);
+        	netsoc_api_print(NETSOC_APIDBG_PORT,"%s Bit 20 reg reset removed val =0x%x\n",__func__, val);
+	}
+        if (mode == PHYMODE_RXAUI) {
+        	val = netsoc_read_mac_reg(mac_base, lane_ctrl);
+		val |= 1<<30;
+        	netsoc_write_mac_reg(mac_base, lane_ctrl, val);
+        	netsoc_api_print(NETSOC_APIDBG_PORT,"%s Bit 30 epcs removed val =0x%x\n",__func__, val);
+	}else{
+		val = netsoc_read_mac_reg(mac_base, lane_ctrl); 
+		val &=~(1<<29);
+		val = val & 0xfff80000;
+        	netsoc_write_mac_reg(mac_base, lane_ctrl, val);
+        	netsoc_api_print(NETSOC_APIDBG_PORT,"%s Bit 29 power down  removed val =0x%x\n",__func__, val);
+		val = netsoc_read_mac_reg(mac_base, lane_ctrl); 
+		val |= 1<<30;
+        	netsoc_write_mac_reg(mac_base, lane_ctrl, val);
+        	netsoc_api_print(NETSOC_APIDBG_PORT,"%s Bit 30 epcs removed val =0x%x\n",__func__, val);
+	}
+	return;
+}
 
 /**********************************************************************
  *  nae_lane_reset_txpll
@@ -534,6 +578,194 @@ static void xlp8xx_ilk_reset_pll(nae_t *nae, int ilk_block_base, int ilk_num_lan
 	}
 }
 
+void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed, int phy_mode)
+{
+        uint32_t reg_addr, lane_no;
+        uint32_t vsemi_cmd=0;
+	uint32_t delay, vsemi_config;
+	uint32_t lwidth = 0;
+	
+	uint32_t lane_speed = XAUI_TYPE_LANE;
+	
+	if((phy_mode == PHYMODE_XFI) || (phy_mode == PHYMODE_XLAUI))
+		lane_speed = XFI_TYPE_LANE;	
+	
+	if(phy_mode == PHYMODE_RXAUI){
+		lwidth =1; /*TODO: Verify for XLP9XX*/
+	}
+
+        for (reg_addr=101; reg_addr <111; reg_addr++){
+                for (lane_no=0; lane_no<4; lane_no++) {
+                        vsemi_cmd=0;
+                        if((xgmii_speed==16 ) && (lane_speed ==XAUI_TYPE_LANE)){
+                                vsemi_cmd |= vsemi_mem_16G_4page[reg_addr];
+                        }
+                        if((xgmii_speed==12 ) && (lane_speed ==XAUI_TYPE_LANE)){
+                                vsemi_cmd |= vsemi_mem_12G_4page[reg_addr];
+                        }
+                        if((xgmii_speed==10 ) && (lane_speed ==XAUI_TYPE_LANE)){
+                                vsemi_cmd |= vsemi_mem_xaui_4page[reg_addr];
+                                //nlm_print("vsemi cmd: xaui 4page: [%X]:%X\n", reg_addr, vsemi_cmd);
+                        }
+                        if((xgmii_speed==10 ) && (lane_speed ==XFI_TYPE_LANE)){
+				 vsemi_cmd |= vsemi_mem_10G_lane_4page[reg_addr];	
+			}
+                        if(phy_mode==PHYMODE_SGMII){
+                                vsemi_cmd |= vsemi_mem_sgmii_4page[reg_addr];
+                        }
+                        __netsoc_write_vsemi_reg(mac_base, lane_no, reg_addr, vsemi_cmd);
+                }
+        }
+        /*configure only page 4*/
+        for (reg_addr=101; reg_addr <165; reg_addr++){
+                vsemi_cmd=0;
+                if((xgmii_speed==16 ) && (lane_speed ==XAUI_TYPE_LANE)){
+                        vsemi_cmd |= vsemi_mem_16G[reg_addr];
+                }
+                if((xgmii_speed==12 ) && (lane_speed ==XAUI_TYPE_LANE)){
+                        vsemi_cmd |= vsemi_mem_12G[reg_addr];
+                }
+                if((xgmii_speed==10 ) && (lane_speed ==XFI_TYPE_LANE)){
+                        vsemi_cmd |= vsemi_mem_xaui[reg_addr];
+                        //nlm_print("vsemi cmd: mem xaui [%X]:%X\n", reg_addr, vsemi_cmd);
+                }
+                if((xgmii_speed==10 ) && (lane_speed ==XFI_TYPE_LANE)){
+			vsemi_cmd |= vsemi_mem_10G_lane[reg_addr];	
+		}
+                if(phy_mode==PHYMODE_SGMII){
+                        vsemi_cmd |= vsemi_mem_sgmii[reg_addr];
+                }
+                __netsoc_write_vsemi_reg(mac_base, 4, reg_addr, vsemi_cmd);
+        }
+
+	// Extra configuration for XFI
+	if(phy_mode == PHYMODE_XFI){
+		vsemi_cmd = __netsoc_read_vsemi_reg(mac_base, 4, 0x37);
+		vsemi_cmd &= 0x80;
+		vsemi_cmd |= 0x15;
+		 __netsoc_write_vsemi_reg(mac_base, 4, 0x37, vsemi_cmd);
+	}
+	
+	// Extra configuration for XLAUI
+	if(phy_mode == PHYMODE_XLAUI){ 
+		vsemi_cmd = __netsoc_read_vsemi_reg(mac_base, 4, 0x37);
+		vsemi_cmd &= 0x80;
+		vsemi_cmd |= 0x10;
+		 __netsoc_write_vsemi_reg(mac_base, 4, 0x37, vsemi_cmd);
+	}
+	
+
+        for (lane_no=0; lane_no<4; lane_no++) {
+                __netsoc_write_vsemi_reg(mac_base, lane_no, 21, 0xd9);
+                __netsoc_write_vsemi_reg(mac_base, lane_no, 22, 0x0);
+                __netsoc_write_vsemi_reg(mac_base, lane_no, 23, 0x0);
+                __netsoc_write_vsemi_reg(mac_base, lane_no, 87, 0x1f);
+        }
+
+        for (lane_no=0; lane_no<4; lane_no++) {
+                __netsoc_write_vsemi_reg(mac_base, lane_no, 24, 0x2);
+                __netsoc_write_vsemi_reg(mac_base, lane_no, 25, 0x0);
+                __netsoc_write_vsemi_reg(mac_base, lane_no, 26, 0x08);
+                __netsoc_write_vsemi_reg(mac_base, lane_no, 27, 0x78);
+                __netsoc_write_vsemi_reg(mac_base, lane_no, 28, 0x0);
+                vsemi_cmd = __netsoc_read_vsemi_reg(mac_base, lane_no, 86);
+                vsemi_cmd &= ~(1<<3);
+                __netsoc_write_vsemi_reg(mac_base, lane_no, 86, vsemi_cmd);
+        }
+
+	for(delay=0; delay<10000; delay++);
+
+    	// De-assert hard reset
+	vsemi_config = netsoc_read_mac_reg(mac_base, VSEMI_CTL0);
+	vsemi_config &= ~(VSEMI_CTL_POR | VSEMI_CTL_SYNTH_RST | VSEMI_CTL_RTHR);
+	netsoc_write_mac_reg(mac_base, VSEMI_CTL0, vsemi_config);
+    
+	for(delay=0; delay<10000; delay++);
+	
+	netsoc_api_print(NETSOC_APIDBG_PORT,"Waiting for block %d PCSOUTSYNTH_READY\n", block);
+	
+	vsemi_cmd = __netsoc_read_vsemi_reg(mac_base, 0x4, 0x4);
+	while((vsemi_cmd& 0x1) != 0x1){
+		vsemi_cmd = __netsoc_read_vsemi_reg(mac_base, 0x4, 0x4);
+	}
+	
+    	for (lane_no=0; lane_no<4; lane_no=lane_no+lwidth) {
+		netsoc_api_print(NETSOC_APIDBG_PORT,"VSEMI: Waiting for block %d lane %d PCSOUT_RX_READY\n", block, lane_no);
+		vsemi_cmd = __netsoc_read_vsemi_reg(mac_base, lane_no, 11);
+		while((vsemi_cmd & 0x1) != 0x1){
+			vsemi_cmd = __netsoc_read_vsemi_reg(mac_base, lane_no, 11);
+		}
+	}	
+    	
+	for (lane_no=0; lane_no<4; lane_no=lane_no+lwidth) {
+		netsoc_api_print(NETSOC_APIDBG_PORT,"VSEMI: Waiting for block %d lane %d PCSOUT_TX_READY\n", block, lane_no);
+		vsemi_cmd = __netsoc_read_vsemi_reg(mac_base, lane_no, 11);
+		while((vsemi_cmd & 0x4) != 0x4){
+			vsemi_cmd = __netsoc_read_vsemi_reg(mac_base, lane_no, 11);
+		}
+	}	
+        nlm_print("VSEMI configuration is OK \n");
+}
+
+static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t vsemi_por , uint32_t speed, uint32_t phymode)
+{
+
+	uint32_t delay, vsemi_config;
+	uint64_t mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	       	if(!vsemi_por){
+                        vsemi_config = netsoc_read_mac_reg(netsoc_get_macreg_base_for_phy(nae->mac_base, block+1), VSEMI_CTL0);
+                        vsemi_config &= ~VSEMI_CTL_POR;
+                        netsoc_write_mac_reg(netsoc_get_macreg_base_for_phy(nae->mac_base, block+1), VSEMI_CTL0, vsemi_config);
+               	}
+               
+		vsemi_config = netsoc_read_mac_reg(mac_base, VSEMI_CTL0);
+                vsemi_config &= 0xFFFF01FF;
+                vsemi_config |= VSEMI_CTL_POR | VSEMI_CTL_SYNTH_RST | VSEMI_CTL_RTHR;
+                netsoc_write_mac_reg(mac_base, VSEMI_CTL0, vsemi_config);
+
+                for(delay=0; delay<1000000; delay++);
+
+                vsemi_config = netsoc_read_mac_reg(mac_base, VSEMI_CTL0);
+                vsemi_config &= ~VSEMI_CTL_POR;
+                vsemi_config &= 0xFFFFFE00;
+                netsoc_write_mac_reg(mac_base, VSEMI_CTL0, vsemi_config);
+
+                for(delay=0; delay<1000000; delay++);
+ 
+                vsemi_config = netsoc_read_mac_reg(mac_base, VSEMI_CTL1);
+                vsemi_config &= ~((0x7<<4) | 0x7);
+
+		if (phymode == PHYMODE_SGMII)
+	                vsemi_config |= VSEMI_CTL_SGMII_DR | VSEMI_CTL_SGMII_DW;
+		else if((PHYMODE_RXAUI==phymode) || (PHYMODE_XAUI==phymode)){
+			if(speed==16)
+                                 vsemi_config = VSEMI_CTL_XAUI_16G_DR | VSEMI_CTL_XAUI_16G_DW;
+                        else if(speed==12)
+                                 vsemi_config = VSEMI_CTL_XAUI_12G_DR | VSEMI_CTL_XAUI_12G_DW;
+                        else if((PHYMODE_RXAUI==phymode) && (speed==10)) {
+                                 vsemi_config = VSEMI_CTL_RXAUI_10G_DR | VSEMI_CTL_RXAUI_10G_DW;
+                        }
+                        else //XAUII/10G
+                                 vsemi_config = VSEMI_CTL_XAUI_DR | VSEMI_CTL_XAUI_DW;
+		}else if(PHYMODE_XFI==phymode){
+			vsemi_config = VSEMI_CTL_XFI_DR | VSEMI_CTL_XFI_DW;	
+		}else if(PHYMODE_XLAUI==phymode){
+			vsemi_config = VSEMI_CTL_XLAUI_DW | VSEMI_CTL_XLAUI_DR;	
+		}else if (PHYMODE_IL==phymode){
+			 vsemi_config =VSEMI_CTL_XLAUI_ILK | VSEMI_CTL_ILK_DW;	
+		}
+		
+		for(delay=0; delay<1000000; delay++);
+
+                netsoc_write_mac_reg(mac_base, VSEMI_CTL1, vsemi_config);
+
+                xlp9xx_nae_write_pma2p0_mem(mac_base, block, speed, phymode);
+#ifdef VSEMI_DEBUG
+                display_vsemi_indirect_reg(node, block);
+#endif
+
+}
 
 static void xlp2xx_config_block_vsemi(nae_t *nae, uint32_t block, uint32_t vsemi_por , uint32_t speed, uint32_t phymode)
 {
@@ -666,6 +898,11 @@ static void __netsoc_xlp_nae_config_lane_gmac(nae_t *nae, int cplx_mask)
 			if (!vsemi_por)
 				vsemi_por++;
                 }
+		if(is_nlm_xlp9xx()){
+			xlp9xx_config_pma2p0_serdes(nae, block, vsemi_por, 0, PHYMODE_SGMII);
+			if (!vsemi_por)
+				vsemi_por++;
+		}
 
                 for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++){
                         if ((is_nlm_xlp3xx()) || (is_nlm_xlp8xx_bx())) {
@@ -673,7 +910,10 @@ static void __netsoc_xlp_nae_config_lane_gmac(nae_t *nae, int cplx_mask)
                                 nlm_hal_PMFF_ALL_workaround(nae, block, lane_ctrl);
                         }else if(is_nlm_xlp2xx()){
                                 xlp2xx_lane_reset_txpll(nae, block, lane_ctrl, PHYMODE_SGMII);
-                        }else{  
+			}	
+			else if(is_nlm_xlp9xx()){
+				xlp9xx_lane_reset(nae, block, lane_ctrl, PHYMODE_SGMII);
+			}else{  
                                 xlp8xx_ax_lane_reset_txpll(nae, block, lane_ctrl, PHYMODE_SGMII);
                         }
                 }
@@ -688,23 +928,25 @@ static void xlp2xx_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask)
         nlm_hal_config_vsemi_mem_sgmii_4page_125Mhz();
 
         __netsoc_xlp_nae_config_lane_gmac(nae, sgmii_cplx_mask);
-        netsoc_api_print(NETSOC_APIDBG_PORT,"Net:   Completed PCS Configuration\n");
+        netsoc_api_print(NETSOC_APIDBG_PORT,"Net:   Completed XLP2XX SGMII PCS Configuration\n");
 }
 
-
-static void xlp_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask)
+static void xlp9xx_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask)
 {
+	vsemi_mem_init_sgmii_125Mhzrefclk();
+        nlm_hal_config_vsemi_mem_sgmii_4page_125Mhz();
 
         __netsoc_xlp_nae_config_lane_gmac(nae, sgmii_cplx_mask);
-        netsoc_api_print(NETSOC_APIDBG_PORT,"Net:   Completed PCS Configuration\n");
+        netsoc_api_print(NETSOC_APIDBG_PORT,"Net: Completed XLP9XX SGMII PCS Configuration\n");
 }
 
-static void xlp9xx_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask)
+static void xlp_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask)
 {
 
+        __netsoc_xlp_nae_config_lane_gmac(nae, sgmii_cplx_mask);
+        netsoc_api_print(NETSOC_APIDBG_PORT,"Net: Completed PCS Configuration\n");
 }
 
-
 static void config_lanes_for_xaui(nae_t *nae, uint32_t xaui_cplx_mask)
 {
 	uint64_t mac_base = netsoc_get_macreg_base_for_lanecfg(nae->mac_base);
@@ -740,6 +982,21 @@ static void config_lanes_for_xaui(nae_t *nae, uint32_t xaui_cplx_mask)
         }
 }
 
+static void config_lanes_for_xfi(nae_t *nae, uint32_t xfi_cplx_mask)
+{
+	uint32_t val;
+	uint64_t mac_base = netsoc_get_macreg_base_for_lanecfg(nae->mac_base);
+	val = netsoc_read_mac_reg(mac_base, LANE_CFG_CPLX_4); 
+	if(xfi_cplx_mask & 0x1){
+		val |= (1<< COMPLEX0_XFI_EN); 
+	}
+	if(xfi_cplx_mask & 0x2){
+		val |= (1<< COMPLEX1_XFI_EN); 
+	}
+	netsoc_write_mac_reg(mac_base, LANE_CFG_CPLX_4, val);
+	
+	config_lanes_for_xaui(nae, xfi_cplx_mask);/*same lane mode as XAUI*/
+}
 
 static void xlp2xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phymode)
 {
@@ -772,18 +1029,20 @@ static void xlp2xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
                         nlm_hal_config_vsemi_mem_xaui_4page_125();
                         nlm_hal_config_vsemi_mem_xaui_125();
                 }
-
-                xlp2xx_config_block_vsemi(nae, block, vsemi_por, xaui_speed, 0);
-                if (!vsemi_por){
+		
+		xlp2xx_config_block_vsemi(nae, block, vsemi_por, xaui_speed, 0);
+                
+		if (!vsemi_por){
                         vsemi_por++;
                 }
 
                 for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++){
+			//TODO: XLP9XX all four lanes used for RXAUI
 			if(phymode == PHYMODE_RXAUI && (lane_ctrl%2))
                                 continue;
 			xlp2xx_lane_reset_txpll(nae, block, lane_ctrl, phymode);
-                }
-        }
+		}
+	}
 
 //        netsoc_api_print(NETSOC_APIDBG_PORT, "%s all blocks & lanes out of TXPLL\n", __func__);
 
@@ -842,10 +1101,180 @@ static void xlp2xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
 
 }
 
-
 static void xlp9xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phymode)
 {
+	uint32_t block, lane_status, lane_ctrl, count, timeout = 10000;
+	static int vsemi_por=0;
+	uint64_t mac_base;
+	
+	config_lanes_for_xaui(nae, xaui_cplx_mask);
+
+	for( block = 0; block < 4; block++)
+        {
+		int xaui_speed = nae->xgmii_speed[block];
+
+                if ((xaui_cplx_mask & (1 << block)) == 0) {
+                        continue;
+                }
+
+		if(xaui_speed==16){
+       	 	        netsoc_api_print(NETSOC_APIDBG_PORT,"VSEMI: config data for 16G XAUI \n");
+                        nlm_hal_config_vsemi_mem_16G_4page_125();
+                        nlm_hal_config_vsemi_mem_16G_125();
+                }
+                else if(xaui_speed==12){
+                        netsoc_api_print(NETSOC_APIDBG_PORT,"VSEMI: config data for 12G XAUI \n");
+                        nlm_hal_config_vsemi_mem_12G_4page_125();
+                        nlm_hal_config_vsemi_mem_12G_125();
+                }
+                else {
+                        netsoc_api_print(NETSOC_APIDBG_PORT,"VSEMI: config data for 10G XAUI/RXAUI \n");
+                        nlm_hal_config_vsemi_mem_xaui_4page_125();
+                        nlm_hal_config_vsemi_mem_xaui_125();
+                }
+		
+		/*config PMA2P0 block */
+		xlp9xx_config_pma2p0_serdes(nae, block, vsemi_por, xaui_speed, phymode);
+                
+		if (!vsemi_por){
+                        vsemi_por++;
+                }
+
+                for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++){
+			//TODO: XLP9XX all four lanes used for RXAUI
+			if(phymode == PHYMODE_RXAUI && (lane_ctrl%2))
+                                continue;
+			xlp9xx_lane_reset(nae, block, lane_ctrl, phymode);
+		}
+	}
+
+//        netsoc_api_print(NETSOC_APIDBG_PORT, "%s all blocks & lanes out of TXPLL\n", __func__);
 
+        netsoc_api_delay(10);
+        /* Wait for Rx & TX clock stable */
+        for( block = 0; block < 4; block++)
+        {
+                if ((xaui_cplx_mask & (1 << block)) == 0) {
+                        continue;
+                }
+		mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+                for( lane_status = PHY_LANE_0_STATUS; lane_status <= PHY_LANE_3_STATUS; lane_status++) {
+
+                        if(phymode == PHYMODE_RXAUI && (lane_status%2))
+                                continue;
+
+                        /* Wait for TX clock to be set */
+                        netsoc_api_print(NETSOC_APIDBG_PORT,"Blk:%d lane%d wait TX clock stable\n", block, lane_status);
+			count = 0;
+                        while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_STCS)) != PHY_LANE_STAT_STCS) {
+				count++;
+				if (count == timeout) {
+					netsoc_api_print(NETSOC_APIDBG_ERROR,"%s TX clock not stable", __func__);
+					break;
+				}
+                        }
+
+                        /* Wait for RX clock to be set */
+                        netsoc_api_print(NETSOC_APIDBG_PORT,"Blk:%d lane%d wait RX clock stable\n", block, lane_status);
+			count = 0;
+                        while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_SRCS)) != PHY_LANE_STAT_SRCS) {
+				count++;
+                                if (count == timeout) {   
+                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s RX clock not stable", __func__);
+					break;
+                                }
+                        }
+
+                        netsoc_api_print(NETSOC_APIDBG_PORT,"Blk:%d lane%d wait lane fault cleared\n", block, lane_status);
+			count = 0;
+                        while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_XLF)) != 0) {
+                                /* Wait for XAUI Lane fault to be cleared */
+				count++;
+                                if (count == timeout) {   
+                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s XAUI lane fault not cleared", __func__);
+					break;
+                                }
+                        }
+                }
+        }
+}
+
+static void xlp9xx_xfi_pcs_init(nae_t *nae, uint32_t xfi_cplx_mask, uint32_t phymode)
+{
+	uint32_t block, lane_status, lane_ctrl, count, timeout = 10000;
+	static int vsemi_por=0;
+	uint64_t mac_base;
+	
+	config_lanes_for_xfi(nae, xfi_cplx_mask);
+
+	for( block = 0; block < 4; block++)
+        {
+
+                if ((xfi_cplx_mask & (1 << block)) == 0) {
+                        continue;
+                }
+		nlm_hal_config_vsemi_mem_10G_lane_4page();
+		nlm_hal_config_vsemi_mem_10G_lane();
+		//TODO: If HIGIG pass XGMII speed.
+		xlp9xx_config_pma2p0_serdes(nae, block, vsemi_por, 10, phymode);
+                
+		if (!vsemi_por){
+                        vsemi_por++;
+                }
+
+                for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++){
+			xlp9xx_lane_reset(nae, block, lane_ctrl, phymode);
+		}
+	}
+
+//        netsoc_api_print(NETSOC_APIDBG_PORT, "%s all blocks & lanes out of TXPLL\n", __func__);
+
+        netsoc_api_delay(10);
+        /* Wait for Rx & TX clock stable */
+        for( block = 0; block < 4; block++)
+        {
+                if ((xfi_cplx_mask & (1 << block)) == 0) {
+                        continue;
+                }
+		mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+                for( lane_status = PHY_LANE_0_STATUS; lane_status <= PHY_LANE_3_STATUS; lane_status++) {
+
+                        /* Wait for TX clock to be set */
+                        netsoc_api_print(NETSOC_APIDBG_PORT,"Blk:%d lane%d wait TX clock stable\n", block, lane_status);
+			count = 0;
+                        while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_STCS)) != PHY_LANE_STAT_STCS) {
+				count++;
+				if (count == timeout) {
+					netsoc_api_print(NETSOC_APIDBG_ERROR,"%s TX clock not stable", __func__);
+					break;
+				}
+                        }
+
+                        /* Wait for RX clock to be set */
+                        netsoc_api_print(NETSOC_APIDBG_PORT,"Blk:%d lane%d wait RX clock stable\n", block, lane_status);
+			count = 0;
+                        while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_SRCS)) != PHY_LANE_STAT_SRCS) {
+				count++;
+                                if (count == timeout) {   
+                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s RX clock not stable", __func__);
+					break;
+                                }
+                        }
+
+                        netsoc_api_print(NETSOC_APIDBG_PORT,"Blk:%d lane%d wait lane fault cleared\n", block, lane_status);
+			count = 0;
+                        while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_XLF)) != 0) {
+                                /* Wait for XAUI Lane fault to be cleared */
+				count++;
+                                if (count == timeout) {   
+                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s XFI lane fault not cleared", __func__);
+					break;
+                                }
+                        }
+                }
+        }
 
 }
 
@@ -931,7 +1360,6 @@ static void xlp_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phym
         nlm_xaui_phy_scan();
 #endif /*CONFIG_N511*/
 
-
 }
 
 #endif
@@ -969,6 +1397,13 @@ void __netsoc_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phymod
 #endif
 }
 
+void __netsoc_xfi_pcs_init(nae_t *nae, uint32_t xfi_cplx_mask, uint32_t phymode)
+{
+#if !defined(XLP_SIM) || defined(NLM_BOARD)
+	xlp9xx_xfi_pcs_init(nae, xfi_cplx_mask, phymode);
+#endif
+}
+
 int __netsoc_interlaken_pcs_init(nae_t *nae, uint32_t ilk_complex_map)
 {
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
diff --git a/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c b/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
index 295b539..522533f 100644
--- a/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
@@ -3087,11 +3087,13 @@ static int parse_vfbid_config(void *fdt, int node)
 static inline int get_num_ports(int block, int intf_type)
 {
 	if (intf_type == SGMII_IF) {
-		if (block < 4)
+		if(is_nlm_xlp9xx() && block==2){
+			return 1;
+		}else if (block < 4)
 			return 4;
 		else
 			return 2;
-	}
+	} 
 	else
 		return 1;	
 }
@@ -4675,39 +4677,39 @@ static void xlp_nae_config_xaui(int node, int block, int port, int vlan_pri_en,
 		if(higig_type==HIGIG2){
 			higig_cfg |= (1<<10);
 		}
-		nlm_hal_write_mac_reg(node, block, XGMAC, NETIOR_HIGIG2_CTRL0, higig_cfg);  
+		nlm_hal_write_mac_reg(node, block, XGMAC0, NETIOR_HIGIG2_CTRL0, higig_cfg);  
 		
-		higig_cfg =  nlm_hal_read_mac_reg(node, block, XGMAC, NETIOR_HIGIG2_CTRL1);
+		higig_cfg =  nlm_hal_read_mac_reg(node, block, XGMAC0, NETIOR_HIGIG2_CTRL1);
 		higig_cfg |= (0x20) | (0x80<<8) | (0x10<<16) | (0x20<<24); //RX/TX threshold
-		nlm_hal_write_mac_reg(node, block, XGMAC, NETIOR_HIGIG2_CTRL1, higig_cfg);  
+		nlm_hal_write_mac_reg(node, block, XGMAC0, NETIOR_HIGIG2_CTRL1, higig_cfg);  
 
-		higig_cfg =  nlm_hal_read_mac_reg(node, block, XGMAC, NETIOR_HIGIG2_CTRL2);
+		higig_cfg =  nlm_hal_read_mac_reg(node, block, XGMAC0, NETIOR_HIGIG2_CTRL2);
 		higig_cfg |= (0x3fff<<16);  /*set frame len*/
-		nlm_hal_write_mac_reg(node, block, XGMAC, NETIOR_HIGIG2_CTRL2, higig_cfg);
+		nlm_hal_write_mac_reg(node, block, XGMAC0, NETIOR_HIGIG2_CTRL2, higig_cfg);
 	}
 
-	val = 	nlm_hal_read_mac_reg(node, block, XGMAC, XGMAC_CTL_REG1);
+	val = 	nlm_hal_read_mac_reg(node, block, XGMAC0, XGMAC_CTL_REG1);
 	val &= ~(0x1 << 11); /* Reset xgmac soft reset(bit 11) xaui soft reset (bit 12) */
-	nlm_hal_write_mac_reg(node, block, XGMAC, XGMAC_CTL_REG1, val);
+	nlm_hal_write_mac_reg(node, block, XGMAC0, XGMAC_CTL_REG1, val);
 	NAE_DEBUG("%s Cleared XGMAC soft reset\n", __func__);
 
-	val = 	nlm_hal_read_mac_reg(node, block, XGMAC, XGMAC_CTL_REG1);
+	val = 	nlm_hal_read_mac_reg(node, block, XGMAC0, XGMAC_CTL_REG1);
 	val &= ~(0x3 << 11); /* Reset xgmac soft reset(bit 11) xaui soft reset (bit 12) */
-	nlm_hal_write_mac_reg(node, block, XGMAC, XGMAC_CTL_REG1, val);
+	nlm_hal_write_mac_reg(node, block, XGMAC0, XGMAC_CTL_REG1, val);
 	NAE_DEBUG("%s Cleared XAUI reset\n", __func__);
 	
-	nlm_hal_write_mac_reg(node, block, XGMAC, XAUI_CONFIG_0, 0xffffffff);
-	nlm_hal_write_mac_reg(node, block, XGMAC, XAUI_CONFIG_0, 0x0);
+	nlm_hal_write_mac_reg(node, block, XGMAC0, XAUI_CONFIG_0, 0xffffffff);
+	nlm_hal_write_mac_reg(node, block, XGMAC0, XAUI_CONFIG_0, 0x0);
 
 	/* Enable tx/rx frame */
 	val = 0xA00010A8;
 	val |= (XAUI_CONFIG_LENCHK | XAUI_CONFIG_GENFCS | XAUI_CONFIG_PAD_64);
-	nlm_hal_write_mac_reg(node, block, XGMAC, XAUI_CONFIG_1, val );
+	nlm_hal_write_mac_reg(node, block, XGMAC0, XAUI_CONFIG_1, val );
 	/* write max frame len*/
-	nlm_hal_write_mac_reg(node, block, XGMAC, XAUI_MAX_FRAME_LEN , 0x01800600);
+	nlm_hal_write_mac_reg(node, block, XGMAC0, XAUI_MAX_FRAME_LEN , 0x01800600);
 
 	/* set stats counter*/
-	val = nlm_hal_read_mac_reg(node, block, XGMAC, NETIOR_XGMAC_CTRL1);
+	val = nlm_hal_read_mac_reg(node, block, XGMAC0, NETIOR_XGMAC_CTRL1);
 	val |= 1 << NETIOR_XGMAC_STATS_EN_POS;
 
 	if (rxaui_en)
@@ -4739,7 +4741,7 @@ static void xlp_nae_config_xaui(int node, int block, int port, int vlan_pri_en,
 		val |= (1 << NETIOR_XGMAC_TX_PAUSE_POS); 
 		val &= ~(1 << NETIOR_XGMAC_VLAN_DC_POS);
 	}
-	nlm_hal_write_mac_reg(node, block, XGMAC, NETIOR_XGMAC_CTRL1, val);
+	nlm_hal_write_mac_reg(node, block, XGMAC0, NETIOR_XGMAC_CTRL1, val);
 
 		/*
 		 * Configuring the OFF/ON timer
@@ -4752,23 +4754,23 @@ static void xlp_nae_config_xaui(int node, int block, int port, int vlan_pri_en,
 	} else {
 		val = 0x0000F123;          // Link level FC: OffTimer = 0xF123    
 	}
-	nlm_hal_write_mac_reg(node, block, XGMAC, NETIOR_XGMAC_CTRL2, val);
+	nlm_hal_write_mac_reg(node, block, XGMAC0, NETIOR_XGMAC_CTRL2, val);
 
 
 	/* set xaui tx threshold */
-	val = nlm_hal_read_mac_reg(node, block, XGMAC, NETIOR_XGMAC_CTRL3);
+	val = nlm_hal_read_mac_reg(node, block, XGMAC0, NETIOR_XGMAC_CTRL3);
 
 	val &= ~(0x1f << 10);  
 	val |= (15 << 10);  
 
-	nlm_hal_write_mac_reg(node, block, XGMAC, NETIOR_XGMAC_CTRL3, val); NAE_DEBUG("%s XAUI Config Complete block %d swport %d \n", __func__,block, port); return;
+	nlm_hal_write_mac_reg(node, block, XGMAC0, NETIOR_XGMAC_CTRL3, val); NAE_DEBUG("%s XAUI Config Complete block %d swport %d \n", __func__,block, port); return;
 }
 
 int nlm_hal_set_xaui_framesize(int node, int block, uint32_t tx_size, uint32_t rx_size)
 {
-       nlm_hal_write_mac_reg(node, block, XGMAC, XAUI_MAX_FRAME_LEN , ((tx_size/4) << 16) | rx_size);
-       NAE_DEBUG("Max frame len set for RX= %d bytes\n", nlm_hal_read_mac_reg(node, block, XGMAC, XAUI_MAX_FRAME_LEN) & (0xffff));
-       NAE_DEBUG("Max frame len set for TX= %d bytes\n",  4*((nlm_hal_read_mac_reg(node, block, XGMAC, XAUI_MAX_FRAME_LEN) >>16) & (0xffff)));
+       nlm_hal_write_mac_reg(node, block, XGMAC0, XAUI_MAX_FRAME_LEN , ((tx_size/4) << 16) | rx_size);
+       NAE_DEBUG("Max frame len set for RX= %d bytes\n", nlm_hal_read_mac_reg(node, block, XGMAC0, XAUI_MAX_FRAME_LEN) & (0xffff));
+       NAE_DEBUG("Max frame len set for TX= %d bytes\n",  4*((nlm_hal_read_mac_reg(node, block, XGMAC0, XAUI_MAX_FRAME_LEN) >>16) & (0xffff)));
        return 0;
 }
 
@@ -5433,9 +5435,9 @@ int nlm_hal_open_if(int node, int intf_type, int block)
 		case XAUI_IF:
 		case RXAUI_IF:
 			// block is a complex number
-			netwk_inf = nlm_hal_read_mac_reg(node, block, XGMAC, NETIOR_XGMAC_CTRL1);
+			netwk_inf = nlm_hal_read_mac_reg(node, block, XGMAC0, NETIOR_XGMAC_CTRL1);
 			netwk_inf |= (1 << NETIOR_XGMAC_STATS_CLR_POS);
-			nlm_hal_write_mac_reg(node, block, XGMAC, NETIOR_XGMAC_CTRL1, netwk_inf);
+			nlm_hal_write_mac_reg(node, block, XGMAC0, NETIOR_XGMAC_CTRL1, netwk_inf);
 			ifmask = 0xf << (block);
 			tx_ior_credit = nlm_hal_read_nae_reg(node, TX_IORCRDT_INIT);
 			nlm_hal_write_nae_reg(node, TX_IORCRDT_INIT, tx_ior_credit | ifmask);
@@ -5555,8 +5557,8 @@ void nlm_hal_mac_disable(int node, int block, int intf_type)
 			break;
 		case XAUI_IF:
 		case RXAUI_IF:
-			xaui_cfg=nlm_hal_read_mac_reg(node, block, XGMAC, XAUI_CONFIG_1);
-			nlm_hal_write_mac_reg(node, block, XGMAC, XAUI_CONFIG_1, xaui_cfg &
+			xaui_cfg=nlm_hal_read_mac_reg(node, block, XGMAC0, XAUI_CONFIG_1);
+			nlm_hal_write_mac_reg(node, block, XGMAC0, XAUI_CONFIG_1, xaui_cfg &
                                                         (~(XAUI_CONFIG_TFEN | XAUI_CONFIG_RFEN)));
 			break;
 		case INTERLAKEN_IF:
@@ -5591,8 +5593,8 @@ void nlm_hal_mac_enable(int node, int block, int intf_type)
                         break;
                 case XAUI_IF:
                 case RXAUI_IF:
-			xaui_cfg=nlm_hal_read_mac_reg(node, block, XGMAC, XAUI_CONFIG_1);
-	                nlm_hal_write_mac_reg(node, block, XGMAC, XAUI_CONFIG_1, xaui_cfg |
+			xaui_cfg=nlm_hal_read_mac_reg(node, block, XGMAC0, XAUI_CONFIG_1);
+	                nlm_hal_write_mac_reg(node, block, XGMAC0, XAUI_CONFIG_1, xaui_cfg |
 							XAUI_CONFIG_TFEN | XAUI_CONFIG_RFEN | XAUI_CONFIG_TCTLEN | XAUI_CONFIG_RCTLEN);                               
 
                         break;
@@ -6108,9 +6110,9 @@ void nlm_hal_read_nae_ucore_sram_mem(int node, int ucoreid, unsigned int *data,
 void nlm_hal_disable_xaui_flow_control(int node, int block)
 {
 	unsigned int xaui_cfg;
-	xaui_cfg = nlm_hal_read_mac_reg(node, block, XGMAC, XAUI_CONFIG_1);
+	xaui_cfg = nlm_hal_read_mac_reg(node, block, XGMAC0, XAUI_CONFIG_1);
 	xaui_cfg &= (~(XAUI_CONFIG_TCTLEN | XAUI_CONFIG_RCTLEN));
-	nlm_hal_write_mac_reg(node, block, XGMAC, XAUI_CONFIG_1, xaui_cfg);
+	nlm_hal_write_mac_reg(node, block, XGMAC0, XAUI_CONFIG_1, xaui_cfg);
 }
 
 
diff --git a/arch/mips/netlogic/lib/netlib/src/nlm_hal_vsemi_config.c b/arch/mips/netlogic/lib/netlib/src/nlm_hal_vsemi_config.c
index 0b0716e..81386ac 100644
--- a/arch/mips/netlogic/lib/netlib/src/nlm_hal_vsemi_config.c
+++ b/arch/mips/netlogic/lib/netlib/src/nlm_hal_vsemi_config.c
@@ -40,6 +40,10 @@ unsigned char vsemi_mem_12G [256];
 unsigned char vsemi_mem_16G_4page [256];
 unsigned char vsemi_mem_16G [256];
 
+/* For 10G/lane configuration*/
+unsigned char vsemi_mem_10G_lane_4page[256];
+unsigned char vsemi_mem_10G_lane[256];
+
 void nlm_hal_config_vsemi_mem_16G_4page(void)
 {
 
@@ -722,6 +726,91 @@ void nlm_hal_config_vsemi_mem_sgmii_4page_125Mhz(void)
 	vsemi_mem_sgmii_4page[110] = 0xF;
 }
 
+/*Ref CLK is 156.25 MHz for XLAUI and XFI*/
+void nlm_hal_config_vsemi_mem_10G_lane_4page(void)
+{
+	vsemi_mem_10G_lane_4page[101] = 0xBD;
+	vsemi_mem_10G_lane_4page[102] = 0xBD;
+	vsemi_mem_10G_lane_4page[103] = 0x6;
+	vsemi_mem_10G_lane_4page[104] = 0x6;
+	vsemi_mem_10G_lane_4page[105] = 0x1B;
+	vsemi_mem_10G_lane_4page[106] = 0x1B;
+	vsemi_mem_10G_lane_4page[107] = 0x1;
+	vsemi_mem_10G_lane_4page[108] = 0x1;
+	vsemi_mem_10G_lane_4page[109] = 0x77;
+	vsemi_mem_10G_lane_4page[110] = 0x0;
+	return;
+}
+
+void nlm_hal_config_vsemi_mem_10G_lane(void)
+{
+	vsemi_mem_10G_lane[101] = 0xAA;
+	vsemi_mem_10G_lane[102] = 0x0;
+	vsemi_mem_10G_lane[103] = 0x6C;
+	vsemi_mem_10G_lane[104] = 0xBD;
+	vsemi_mem_10G_lane[105] = 0xBD;
+	vsemi_mem_10G_lane[106] = 0x6;
+	vsemi_mem_10G_lane[107] = 0x6;
+	vsemi_mem_10G_lane[108] = 0x1B;
+	vsemi_mem_10G_lane[109] = 0x1B;
+	vsemi_mem_10G_lane[110] = 0x7;
+	vsemi_mem_10G_lane[111] = 0xC;
+	vsemi_mem_10G_lane[112] = 0x10;
+	vsemi_mem_10G_lane[113] = 0x0;
+	vsemi_mem_10G_lane[114] = 0x10;
+	vsemi_mem_10G_lane[115] = 0x0;
+	vsemi_mem_10G_lane[116] = 0xFF;
+	vsemi_mem_10G_lane[117] = 0xB3;
+	vsemi_mem_10G_lane[118] = 0xF6;
+	vsemi_mem_10G_lane[119] = 0xD0;
+	vsemi_mem_10G_lane[120] = 0xEF;
+	vsemi_mem_10G_lane[121] = 0xFB;
+	vsemi_mem_10G_lane[122] = 0xFF;
+	vsemi_mem_10G_lane[123] = 0xFF;
+	vsemi_mem_10G_lane[124] = 0xFF;
+	vsemi_mem_10G_lane[125] = 0xFF;
+	vsemi_mem_10G_lane[126] = 0xFF;
+	vsemi_mem_10G_lane[127] = 0xD3;
+	vsemi_mem_10G_lane[128] = 0xD3;
+	vsemi_mem_10G_lane[129] = 0xE2;
+	vsemi_mem_10G_lane[130] = 0xEF;
+	vsemi_mem_10G_lane[131] = 0xFB;
+	vsemi_mem_10G_lane[132] = 0xFB;
+	vsemi_mem_10G_lane[133] = 0xFF;
+	vsemi_mem_10G_lane[134] = 0xEF;
+	vsemi_mem_10G_lane[135] = 0xFF;
+	vsemi_mem_10G_lane[136] = 0xFF;
+	vsemi_mem_10G_lane[137] = 0xD3;
+	vsemi_mem_10G_lane[138] = 0xD3;
+	vsemi_mem_10G_lane[139] = 0xE2;
+	vsemi_mem_10G_lane[140] = 0xEF;
+	vsemi_mem_10G_lane[141] = 0xFB;
+	vsemi_mem_10G_lane[142] = 0xFB;
+	vsemi_mem_10G_lane[143] = 0xFF;
+	vsemi_mem_10G_lane[144] = 0xEF;
+	vsemi_mem_10G_lane[145] = 0xFF;
+	vsemi_mem_10G_lane[146] = 0xFF;
+	vsemi_mem_10G_lane[147] = 0xFB;
+	vsemi_mem_10G_lane[148] = 0xFF;
+	vsemi_mem_10G_lane[149] = 0x3F;
+	vsemi_mem_10G_lane[150] = 0x0;
+	vsemi_mem_10G_lane[151] = 0x19;
+	vsemi_mem_10G_lane[152] = 0x11;
+	vsemi_mem_10G_lane[153] = 0x2;
+	vsemi_mem_10G_lane[154] = 0x1;
+	vsemi_mem_10G_lane[155] = 0x0;
+	vsemi_mem_10G_lane[156] = 0x0;
+	vsemi_mem_10G_lane[157] = 0x4;
+	vsemi_mem_10G_lane[158] = 0x0;
+	vsemi_mem_10G_lane[159] = 0x0;
+	vsemi_mem_10G_lane[160] = 0x8;
+	vsemi_mem_10G_lane[161] = 0x4;
+	vsemi_mem_10G_lane[162] = 0x0;
+	vsemi_mem_10G_lane[163] = 0x0;
+	vsemi_mem_10G_lane[164] = 0x4;
+	return;
+}
+
 #ifdef NLM_HAL_LINUX_KERNEL
 #include <linux/types.h>
 #include <linux/module.h>
@@ -741,6 +830,8 @@ EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_sgmii);
 EXPORT_SYMBOL(vsemi_mem_init_sgmii_125Mhzrefclk);
 EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_sgmii_4page);
 EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_sgmii_4page_125Mhz);
+EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_10G_lane_4page);
+EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_10G_lane);
 EXPORT_SYMBOL(vsemi_mem_xaui_4page);
 EXPORT_SYMBOL(vsemi_mem_16G);
 EXPORT_SYMBOL(vsemi_mem_sgmii);
@@ -749,4 +840,6 @@ EXPORT_SYMBOL(vsemi_mem_12G_4page);
 EXPORT_SYMBOL(vsemi_mem_sgmii_4page);
 EXPORT_SYMBOL(vsemi_mem_16G_4page);
 EXPORT_SYMBOL(vsemi_mem_xaui);
+EXPORT_SYMBOL(vsemi_mem_10G_lane);
+EXPORT_SYMBOL(vsemi_mem_10G_lane_4page);
 #endif
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_evp_cpld.h b/arch/mips/netlogic/lib/syslib/include/nlm_evp_cpld.h
index 969c1a2..64f235b 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_evp_cpld.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_evp_cpld.h
@@ -70,6 +70,8 @@ typedef struct {
 #define DC_XAUI         2
 #define DC_NOT_PRSNT    3
 #define DC_RXAUI        6 /*not support by CPLD : Defined for software using only */
+#define DC_XFI		7
+#define DC_XLAUI	8 
 
 #define DC_TYPE(val,slot)       ((val >> (slot * 2)) & 0x3)
 #define EVP_VER(val)            (val & 0x8)
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_vsemi_data.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_vsemi_data.h
deleted file mode 100644
index abc0b07..0000000
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal_vsemi_data.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*-
- * Copyright (c) 2003-2012 Broadcom Corporation
- * All Rights Reserved
- *
- * This software is available to you under a choice of one of two
- * licenses.  You may choose to be licensed under the terms of the GNU
- * General Public License (GPL) Version 2, available from the file
- * http://www.gnu.org/licenses/gpl-2.0.txt
- * or the Broadcom license below:
-
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_4# */
-#ifndef _NLM_HAL_VESMI_DATA_H_
-#define _NLM_HAL_VSEMI_DATA_H_
-
-
-/*156 Mhz related functions*/
-extern void nlm_hal_config_vsemi_mem_16G_4page(void);
-extern void nlm_hal_config_vsemi_mem_16G(void);
-extern void nlm_hal_config_vsemi_mem_12G_4page(void);
-extern void nlm_hal_config_vsemi_mem_12G(void);
-extern void nlm_hal_config_vsemi_mem_xaui(void);
-extern void nlm_hal_config_vsemi_mem_xaui_4page(void);
-
-/*125 Mhz related functions*/
-void nlm_hal_config_vsemi_mem_16G_4page_125(void);
-void nlm_hal_config_vsemi_mem_16G_125(void);
-void nlm_hal_config_vsemi_mem_12G_4page_125(void);
-void nlm_hal_config_vsemi_mem_12G_125(void);
-void nlm_hal_config_vsemi_mem_xaui_4page_125(void);
-void nlm_hal_config_vsemi_mem_xaui_125(void);	
-#endif
-
-
-- 
1.9.1

