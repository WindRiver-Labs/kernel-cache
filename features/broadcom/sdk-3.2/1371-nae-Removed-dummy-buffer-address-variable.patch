From 9968d4e639677670891bb3e49ea6ccf27d9c5cb2 Mon Sep 17 00:00:00 2001
From: Hareesh R <hareeshr@broadcom.com>
Date: Mon, 10 Sep 2012 16:51:24 +0530
Subject: [PATCH 1371/1532] nae : Removed dummy buffer address variable

Added support to initialize the nae rx lifos not owned by the linux
domain. Removed the dummy buffer usage.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/init_nae.c | 167 +++++++++++++++++++++++++--
 1 file changed, 156 insertions(+), 11 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/init_nae.c b/drivers/net/ethernet/broadcom/nae/init_nae.c
index d739414..a27c3ba 100644
--- a/drivers/net/ethernet/broadcom/nae/init_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/init_nae.c
@@ -26,6 +26,8 @@ static unsigned int lnx_jumbo_mask;
 extern int num_descs_per_normalq; 	
 extern int num_descs_per_jumboq; 	
 
+int nlm_configure_shared_freein_fifo(int node, nlm_nae_config_ptr nae_cfg);
+
 /* This strucutre has been referenced in templates/hybrid_nae and ucore/hybrid_nae. 
  So whenever you modify, modify the above places also. */
 
@@ -46,31 +48,44 @@ struct nlm_nae_linux_shinfo {
 
 struct nlm_nae_linux_shinfo lnx_shinfo[NLM_NAE_MAX_SHARED_DOMS + 1]; //1 extra for owned domain
 
-
 /* As there is a port level fifo checkup done in NAE h/w, we need to fill up the port
- fifos ( 0, 4, 8, 12 & 16) with some dummy entries if it is not owned by linux. 
- If these owned by an app, these dummy entries need to be cleared by the app before reinitializing it
+ fifos ( 0, 4, 8, 12 & 16) with some dummy entries if it is not owned by anyone. 
  */
-static int init_dummy_entries_for_port_fifos(int node, nlm_nae_config_ptr nae_cfg, int jumbo_enabled)
+static int init_dummy_entries_for_unused_fifos(int node, nlm_nae_config_ptr nae_cfg)
 {
 	static unsigned long long msg;
 	unsigned long __attribute__ ((unused)) mflags;
-	int rv = 0, vc_index, i, j, ret, code;
+	int rv = 0, vc_index = 0, i, j, ret, code;
+	unsigned int fifo_mask = 0;
+	struct sk_buff * skb;
+	int size = NLM_RX_JUMBO_BUF_SIZE, shdom;
+
+	skb = nlm_xlp_alloc_skb_atomic(size, node);
+	if(!skb) {
+		printk("[%s] alloc skb failed\n",__FUNCTION__);
+		panic("panic...");
+		return -ENOMEM;
+	}
+	msg = (unsigned long long)virt_to_bus(skb->data) & 0xffffffffffULL;
 
-	if(!nae_cfg->dummy_pktdata_addr)
-		return 0;
+	for(shdom = 0; shdom <= NLM_NAE_MAX_SHARED_DOMS; shdom++) {
+		if(!nae_cfg->shinfo[shdom].valid)
+			continue;
 
-	msg = (unsigned long long)nae_cfg->dummy_pktdata_addr & 0xffffffffffULL;
+		fifo_mask |= nlm_hal_retrieve_freein_fifo_mask(fdt, node, 
+				nae_cfg->shinfo[shdom].domid);
+	}
 
 	msgrng_access_enable(mflags);
 	for(i = 0; i < nae_cfg->frin_total_queue; i++) {
-		/* nothing to do, if it is owned by linux */
-		if((1 << i) & nae_cfg->freein_fifo_dom_mask) 
+		/* nothing to do, if it is owned by some domain */
+		if((1 << i) & fifo_mask) 
 			continue;
 
 		vc_index = i + nae_cfg->frin_queue_base;
 
 		for(j = 0; j < 4; j++) {
+			__sync();
 			if ( (ret = nlm_hal_send_msg1(vc_index, code, msg)) & 0x7) {
 				print_fmn_send_error(__func__, ret);
 				printk("Unable to send configured free desc, check freein carving (qid=%d)\n", vc_index);
@@ -78,9 +93,15 @@ static int init_dummy_entries_for_port_fifos(int node, nlm_nae_config_ptr nae_cf
 				goto err;
 			}
 		}
+		printk("Send %d dummy descriptors for queue %d(vc %d) of length %d\n", 
+				j, i, vc_index, size);
 	}
 err:
 	msgrng_access_disable(mflags);
+
+	/* if not used */
+	if(!vc_index)
+		dev_kfree_skb_any(skb);
 	return rv;
 }
 
@@ -251,9 +272,12 @@ int initialize_nae(unsigned int *phys_cpu_map, int mode, int *jumbo_enabled)
 		else
 			nlm_hal_init_ingress (node, (ETH_DATA_LEN+ETH_HLEN+ETH_FCS_LEN+SMP_CACHE_BYTES) & ~(SMP_CACHE_BYTES - 1));
 
-		if(init_dummy_entries_for_port_fifos(node, nae_cfg, *jumbo_enabled) != 0)
+		if(nlm_configure_shared_freein_fifo(node, nae_cfg) != 0)
 			goto err;
+
+		init_dummy_entries_for_unused_fifos(node, nae_cfg);
 #if 0	
+
 		if(is_nlm_xlp2xx())
 		{
 			nlm_hal_msec_tx_default_config(node,/* port_enable*/0xff, /*unsigned int preamble_len*/0x5555, /*packet_num*/ 0x0, /*pn_thrshld*/0x7fffffff);
@@ -355,3 +379,124 @@ int replenish_freein_fifos(void)
 	}
 	return rv;
 }
+
+static inline unsigned int fdt32_to_cpu(unsigned int x)
+{
+	#define _BYT(n)	((unsigned long long)((unsigned char *)&x)[n])
+#ifdef __MIPSEL__
+	return (_BYT(0) << 24) | (_BYT(1) << 16) | (_BYT(2) << 8) | _BYT(3);
+#else
+	return x;
+#endif
+}
+
+int nlm_configure_shared_freein_fifo(int node, nlm_nae_config_ptr nae_cfg)
+{
+	unsigned int cnode, fmask, dsize, dppadsz, ndescs;
+	unsigned long long paddr, psize, epaddr;
+	unsigned int *t;
+	int len = 0, i = 0;
+	unsigned int owner_replenish = 0, paddr_info_len, desc_info_len;
+	char *paddr_info, *desc_info;
+	unsigned long long msg;
+	unsigned long __attribute__ ((unused)) mflags;
+	int vc_index, rv = 0, code = 0, descs, fifo;
+	int shdom, err = 0;
+
+	for(shdom = 0; shdom <= NLM_NAE_MAX_SHARED_DOMS; shdom++) {
+		if(!nae_cfg->shinfo[shdom].valid)
+			continue;
+		/* ignore my own domain id */
+		if(nae_cfg->shinfo[shdom].domid == 0)
+			continue;
+
+		rv = nlm_hal_retrieve_shared_freein_fifo_info(fdt,
+				nae_cfg->shinfo[shdom].domid,
+				&owner_replenish,
+				&paddr_info, &paddr_info_len,
+				&desc_info, &desc_info_len);
+		if(rv != 0) 
+			continue;
+
+		if(!owner_replenish)
+			continue;
+
+		t = (unsigned int *)paddr_info;
+		i = 0;
+		do {
+			/* extract the config */
+			cnode = fdt32_to_cpu(t[i]);
+			paddr = ((unsigned long long)fdt32_to_cpu(t[i + 1])) << 32;
+			paddr |= ((unsigned long long)fdt32_to_cpu(t[i + 2]));
+			psize = ((unsigned long long)fdt32_to_cpu(t[i + 3])) << 32;
+			psize |= ((unsigned long long)fdt32_to_cpu(t[i + 4]));
+		
+			i += 5;
+			len = i * 4;
+			if(cnode == node)
+				break;
+		} while(len < paddr_info_len);
+
+		printk("domid %d node %d addr %llx size %llx\n", 
+					nae_cfg->shinfo[shdom].domid, cnode, paddr, psize); 
+
+		epaddr = paddr + psize;
+		t = (unsigned int *)desc_info;
+		i = 0;
+		do {
+
+			/* extract the config */
+			cnode = fdt32_to_cpu(t[i]);
+			fmask = fdt32_to_cpu(t[i + 1]);
+			dsize = fdt32_to_cpu(t[i + 2]);
+			dppadsz = fdt32_to_cpu(t[i + 3]);
+			ndescs = fdt32_to_cpu(t[i + 4]);
+		 
+			i += 5;
+			len = i * 4;
+
+			if(cnode != node)
+				continue;
+
+			printk("node %d fmask %x dsize %d dppadsz %d ndescs %d \n",
+					cnode, fmask, dsize, dppadsz, ndescs);
+
+			for(fifo = 0; fifo < NLM_NAE_MAX_FREEIN_FIFOS_PER_NODE; fifo++) {
+				if(!((1 << fifo) & fmask)) 
+					continue;
+				msgrng_access_enable(mflags);
+				vc_index = fifo + nae_cfg->frin_queue_base;
+				for(descs = 0; descs < ndescs; descs++) {
+					if((paddr + dsize) > epaddr) {
+						msgrng_access_disable(mflags);
+						printk("Error, descriptors buffer overflow \n");
+						err = -1;
+						goto err_exit;
+					}
+					msg = paddr + dppadsz;
+
+					__sync();
+					rv = nlm_hal_send_msg1(vc_index, code, msg);
+					if(rv & 0x7) {
+						msgrng_access_disable(mflags);
+						printk("Unable to send configured free desc, \
+							check freein carving (qid=%d)\n", vc_index);
+						err = -1;
+						goto err_exit;
+					}
+
+					paddr += dsize;
+
+				}
+				msgrng_access_disable(mflags);
+				printk("Send %d descriptors for queue %d(%d) of length %d\n", 
+						ndescs, fifo, vc_index, dsize); 
+
+			}
+		} while(len < desc_info_len);
+
+	}
+
+err_exit:
+	return err;
+}
-- 
1.9.1

