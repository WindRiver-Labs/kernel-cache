From 5c739006d2fbffe06a8fff7097edcfd774ca949d Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikasg@netlogicmicro.com>
Date: Thu, 6 Oct 2011 20:15:55 +0530
Subject: [PATCH 1080/1532] 1) LE mode fixes. 2) using work queue instead
 tasklet.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/nae_jumbo/xlp_nae_jumbo.c | 44 +++++++++++++------------
 1 file changed, 23 insertions(+), 21 deletions(-)

diff --git a/drivers/misc/netlogic/nae_jumbo/xlp_nae_jumbo.c b/drivers/misc/netlogic/nae_jumbo/xlp_nae_jumbo.c
index 5c75c8e..d5314ca 100755
--- a/drivers/misc/netlogic/nae_jumbo/xlp_nae_jumbo.c
+++ b/drivers/misc/netlogic/nae_jumbo/xlp_nae_jumbo.c
@@ -139,7 +139,8 @@ struct jumbo_rx_cookie {
 };
 
 jumbo_rx_info_t  jumbo_rx_buff[NR_CPUS];
-static struct tasklet_struct mac_frin_replenish_task[MAC_FRIN_WORK_NUM];
+//static struct tasklet_struct mac_frin_replenish_task[MAC_FRIN_WORK_NUM];
+static struct work_struct mac_frin_replenish_work[MAC_FRIN_WORK_NUM];
 static void mac_frin_replenish(unsigned long arg /* ignored */);
 
 #define MAX_PACKET_SZ_PER_MSG	16384
@@ -172,10 +173,11 @@ enum msc_opcodes { IP_CHKSUM = 1,
 uint16_t tcp_pseuodo_chksum(uint16_t *ipsrc)
 {
 	uint32_t sum = 0;
-	sum += ipsrc[0];
-	sum += ipsrc[1];
-	sum += ipsrc[2];
-	sum += ipsrc[3];
+	//*ipsrc = cpu_to_be16p(ipsrc);
+	sum += cpu_to_be16(ipsrc[0]);
+	sum += cpu_to_be16(ipsrc[1]);
+	sum += cpu_to_be16(ipsrc[2]);
+	sum += cpu_to_be16(ipsrc[3]);
 	sum += 6;
 	while(sum >> 16)
 		sum = (sum & 0xffff)  + (sum >> 16);
@@ -186,10 +188,10 @@ uint16_t tcp_pseuodo_chksum(uint16_t *ipsrc)
 uint16_t udp_pseuodo_chksum(uint16_t *ipsrc)
 {
 	uint32_t sum = 0;
-	sum += ipsrc[0];
-	sum += ipsrc[1];
-	sum += ipsrc[2];
-	sum += ipsrc[3];
+	sum += cpu_to_be16(ipsrc[0]);
+	sum += cpu_to_be16(ipsrc[1]);
+	sum += cpu_to_be16(ipsrc[2]);
+	sum += cpu_to_be16(ipsrc[3]);
 	sum += 0x11;
 	while(sum >> 16)
 		sum = (sum & 0xffff)  + (sum >> 16);
@@ -454,6 +456,7 @@ static __inline__ int mac_send_fr(struct dev_data *priv, unsigned long addr, int
 		printk("Unable to send configured free desc, check freein carving (qid=%d)\n", priv->nae_rx_qid);			 
 		return ret;
 	}
+	return ret;		
 	
 }
 
@@ -572,8 +575,8 @@ static int mac_frin_replenish_msgs(struct net_device *dev, int num)
 
 	rx = &jumbo_rx_buff[cpu];
 	atomic_add(num, &rx->alloc_fails[priv->port]);
-	//schedule_work(&mac_frin_replenish_work[cpu]);
-	tasklet_schedule(&mac_frin_replenish_task[cpu]);
+	schedule_work(&mac_frin_replenish_work[cpu]);
+	//tasklet_schedule(&mac_frin_replenish_task[cpu]);
 	return 0;
 }
 
@@ -726,7 +729,8 @@ static void nlm_xlp_nae_init(void)
 	p2p_desc_mem_init();
 		
 	for (i = 0; i < MAC_FRIN_WORK_NUM; i++) {
-		tasklet_init(&mac_frin_replenish_task[i], mac_frin_replenish, 0UL);		  
+		//tasklet_init(&mac_frin_replenish_task[i], mac_frin_replenish, 0UL);		  
+		INIT_WORK(&mac_frin_replenish_work[i], mac_frin_replenish);
 	}
 
 	nae_fb_vc = nae_cfg.fb_vc;
@@ -1001,7 +1005,7 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	//		sp->gso_size, sp->nr_frags, skb->len, (uint64_t)p2pdesc, (uint64_t)skb, skb_headlen(skb), cpu);
 
 	if (((mss = sp->gso_size) != 0) || (skb->ip_summed == CHECKSUM_PARTIAL)) {
-		u32 iphdroff, tcphdroff, pyldoff, tcppcsum, udppcsum, l4hoff;
+		u32 iphdroff, pyldoff, tcppcsum, udppcsum, l4hoff;
 
 		if (skb_header_cloned(skb) &&
 				pskb_expand_head(skb, 0, 0, GFP_ATOMIC)) {
@@ -1016,14 +1020,14 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 		if(ip_hdr(skb)->protocol == IPPROTO_UDP){
 			pyldoff = iphdroff + ip_hdrlen(skb) + sizeof(struct udphdr);	
+			//printk("iphdroff %d udphdroff %d pyldoff %d\n", iphdroff, l4hoff, pyldoff);
 			udppcsum = udp_pseuodo_chksum((uint16_t *)((char *)iph + 12));
 			udp_hdr(skb)->check = 0;
-			//printk("iphdroff %d udphdroff %d pyldoff %d\n", iphdroff, l4hoff, pyldoff);
 		}else{
 			pyldoff = iphdroff + ip_hdrlen(skb) + sizeof(struct tcphdr) + tcp_optlen(skb);
-			tcppcsum = tcp_pseuodo_chksum((uint16_t *)((char *)iph + 12));
-			tcp_hdr(skb)->check = 0;
 			//printk("iphdroff %d tcphdroff %d pyldoff %d\n", iphdroff, l4hoff, pyldoff);
+			tcppcsum = tcp_pseuodo_chksum(((uint16_t *)((char *)iph + 12)));
+			tcp_hdr(skb)->check = 0;
 		}
 
 		if(mss) {
@@ -1414,7 +1418,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			/*Get actual length*/
 			for(idx=0; idx<num_p2d; idx++){
 				vaddr = (uint64_t)bus_to_virt(addr + (8*idx)); //got p2d virt addr
-				p2d = *(uint64_t*)vaddr;
+				p2d = be64_to_cpu(*(uint64_t*)vaddr);
 				p2d_addr[idx] = p2d & 0xffffffffe0ULL;
 				p2d_len[idx] = (p2d >> 40) & 0x3fff;
 				bad_pkt = (p2d >> 4) & 0x1;
@@ -1430,7 +1434,6 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			p2d_addr[0] = addr;
 			p2d_len[0] = len - MAC_CRC_LEN; 
 			len = len - MAC_CRC_LEN;
-			rx_cookie = get_rx_cookie(addr);
 			num_p2d = 1;
 			tot_desc = 1;
 			//printk("P2D  len = %d\n", len);
@@ -1459,7 +1462,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		}
 
 		/* allocate an skb for header */
-		skb = netdev_alloc_skb(pdev, NETL_JUMBO_SKB_HDR_LEN + 16);
+		skb = dev_alloc_skb(NETL_JUMBO_SKB_HDR_LEN + 16);
 		if(skb == NULL) {
 			printk("FAILED TO ALLOCATE skb\n");
 			STATS_INC(priv->stats.rx_errors);
@@ -1467,6 +1470,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			recycle_rx_desc(addr, pdev);
 			return;
 		}
+		mac_frin_replenish_msgs(dev_mac[port], tot_desc);
 		skb->dev = dev_mac[port];
 		hlen = (len > NETL_JUMBO_SKB_HDR_LEN) ? 
 				NETL_JUMBO_SKB_HDR_LEN: len;
@@ -1479,9 +1483,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		}
 		skb->protocol = eth_type_trans(skb, skb->dev);
 		skb->dev->last_rx = jiffies;
-		//netif_receive_skb(skb);
 		netif_rx(skb);
-		mac_frin_replenish_msgs(dev_mac[port], tot_desc);
 		/* Update Stats */
 		STATS_ADD(priv->stats.rx_bytes, len);
 		STATS_INC(priv->stats.rx_packets);
-- 
1.9.1

