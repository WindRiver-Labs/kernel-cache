From 5517fad347362aa16d424707f7718dc4decdd1aa Mon Sep 17 00:00:00 2001
From: Hareesh R <hareeshr@broadcom.com>
Date: Thu, 8 Mar 2012 17:29:15 +0530
Subject: [PATCH 1527/1532] Openssl and lib changes for tcmalloc library

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/seclib/nlmcrypto_ifc.h | 63 +++++++++++++++++++++++----
 1 file changed, 54 insertions(+), 9 deletions(-)

diff --git a/arch/mips/netlogic/lib/seclib/nlmcrypto_ifc.h b/arch/mips/netlogic/lib/seclib/nlmcrypto_ifc.h
index c552bb3..6880b2f 100644
--- a/arch/mips/netlogic/lib/seclib/nlmcrypto_ifc.h
+++ b/arch/mips/netlogic/lib/seclib/nlmcrypto_ifc.h
@@ -30,24 +30,69 @@
 #ifndef _NLM_CRYPTO_IFC_H
 #define _NLM_CRYPTO_IFC_H
 
-extern void *linuxu_shvaddr;
-extern unsigned long long linuxu_shoff;
-extern unsigned long long linuxu_shsize;
-extern void *contig_mem_align(size_t align, size_t size);
-extern void *contig_mem_free(void *ptr);
+#include "nlm_cmem.h"
+extern void **cmem_pgd;
+extern void *nlm_cmem_alloc(size_t size);
+extern void *nlm_cmem_align(size_t align, size_t size);
+extern void nlm_cmem_free(void *ptr);
 
+/* for control, packet descriptors and rsa request and result */
 static inline unsigned long long crypto_virt_to_phys(void *vaddr)
 {
-	return (unsigned long long)((vaddr - linuxu_shvaddr) + linuxu_shoff);
+	struct nlm_cmem_seg sg[1];
+	int rv;
+	rv = nlm_cmem_va_to_pa(cmem_pgd, (unsigned long)vaddr, 1, &sg[0], 1);
+	assert(rv == 1);
+	return sg[0].pa;
 }
 
+/* for control, packet descriptors and rsa request and result */
 static inline void *crypto_phys_to_virt(unsigned long long paddr)
 {
-	return (void *)((paddr - linuxu_shoff) + linuxu_shvaddr);
+	return (void *)nlm_cmem_pa_to_va(cmem_pgd, paddr);
 }
 
-#define crypto_malign(align, size) contig_mem_align(align, size)
-#define crypto_mfree(p) contig_mem_free(p)
+/* for packet data, assert if the number of segs exceeds maximum segments ,
+ The offsets are matching with the crypto pktdesc4 and pktdesc5 offsets */
+static inline int crypto_fill_pkt_seg_paddr_len(void *vaddr, unsigned int inlen,
+	       struct nlm_crypto_pkt_seg_desc *segs, unsigned int s_seg, unsigned int max_segs,
+	       int fillsrc, int filldst, unsigned long long sinitval, unsigned long long dinitval)
+{
+	unsigned int rv, len = 0, i;
+	unsigned int remlen = inlen;
+	unsigned long e = ((unsigned long)vaddr + inlen);
+	struct nlm_cmem_seg sg[16];
+
+	for (; remlen > 0;) {
+		rv = nlm_cmem_va_to_pa(cmem_pgd, (unsigned long)vaddr, e - (unsigned long)vaddr, &sg[0], 16);
+		for (i = 0; i < rv; ) {
+			len = sg[i].len > NLM_CRYPTO_MAX_SEG_LEN ? NLM_CRYPTO_MAX_SEG_LEN : sg[i].len;
+			/* fprintf(stderr, "i %d rv %d inlen %d remlen %d vaddr %lx s_seg %d max_segs %d len %d pa %llx\n",
+					i, rv, inlen, remlen, (long)vaddr, s_seg, max_segs, len, sg[i].pa);*/
+			assert(s_seg < max_segs);
+			if (fillsrc)
+				segs[s_seg].src = ccpu_to_be64(sg[i].pa |
+						(((unsigned long long)len - 1) << NLM_CRYPTO_SEGS_LEN_OFF) | sinitval);
+			if (filldst)
+				segs[s_seg].dst = ccpu_to_be64(sg[i].pa |
+						(((unsigned long long)len - 1) << NLM_CRYPTO_SEGS_LEN_OFF) | dinitval);
+			remlen -= len;
+			vaddr += len;
+			s_seg++;
+			sg[i].len   -= len;
+			if (!sg[i].len) {
+				i++;
+				continue;
+			}
+			sg[i].pa += len;
+		}
+	}
+	return s_seg;
+}
+
+
+#define crypto_malign(align, size) nlm_cmem_align(align, size)
+#define crypto_mfree(p) nlm_cmem_free(p)
 
 
 #endif
-- 
1.9.1

