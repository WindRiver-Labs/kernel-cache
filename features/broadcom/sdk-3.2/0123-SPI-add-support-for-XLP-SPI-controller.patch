From 57638250da3ccd352c1cd889d60183ae141f2204 Mon Sep 17 00:00:00 2001
From: Jayachandran C <jchandra@broadcom.com>
Date: Fri, 2 May 2014 14:56:11 +0530
Subject: [PATCH 0123/1532] SPI: add support for XLP SPI controller

Add interrupt based driver for the SPI interface on XLP 8xx/3xx/2xx/9xx
family of MIPS64 processors.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/spi/Kconfig   |  10 +
 drivers/spi/Makefile  |   1 +
 drivers/spi/spi-xlp.c | 520 ++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 531 insertions(+)
 create mode 100644 drivers/spi/spi-xlp.c

diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index ce0655b..3eccbfc 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -500,6 +500,16 @@ config SPI_XILINX_PS_SPI
 	help
 	  This selects the PS SPI controller master driver from the Xilinx.
 
+config SPI_XLP
+	tristate "Netlogic XLP SPI controller driver"
+	depends on CPU_XLP
+	help
+	  Enable support for the SPI controller on the Netlogic XLP SoCs.
+	  This driver provides basic support for SPI master controller.
+	  If you have a Netlogic XLP platform say Y here.
+
+	  If unsure, say N.
+
 config SPI_NUC900
 	tristate "Nuvoton NUC900 series SPI"
 	depends on ARCH_W90X900
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index bf7e8dc..99dfadd 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -76,3 +76,4 @@ obj-$(CONFIG_SPI_XCOMM)		+= spi-xcomm.o
 obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
 obj-$(CONFIG_SPI_XILINX_PS_SPI)	+= spi-xilinx-ps.o
 obj-$(CONFIG_SPI_XILINX_PS_QSPI)	+= spi-xilinx-qps.o
+obj-$(CONFIG_SPI_XLP)		+= spi-xlp.o
diff --git a/drivers/spi/spi-xlp.c b/drivers/spi/spi-xlp.c
new file mode 100644
index 0000000..6077373
--- /dev/null
+++ b/drivers/spi/spi-xlp.c
@@ -0,0 +1,520 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/of.h>
+#include <linux/interrupt.h>
+
+#define XLP_SPI_CONFIG			0x40
+#define XLP_SPI_CPHA			BIT(0)
+#define XLP_SPI_CPOL			BIT(1)
+#define XLP_SPI_CS_POL			BIT(2)
+#define XLP_SPI_TXMISO_EN		BIT(3)
+#define XLP_SPI_TXMOSI_EN		BIT(4)
+#define XLP_SPI_RXMISO_EN		BIT(5)
+#define XLP_SPI_CS_LSBFE		BIT(10)
+#define XLP_SPI_RXCAP_EN		BIT(11)
+
+#define XLP_SPI_FDIV			0x41
+#define XLP_SPI_CMD			0x42
+#define XLP_SPI_CMD_IDLE_MASK		0x0
+#define XLP_SPI_CMD_TX_MASK		0x1
+#define XLP_SPI_CMD_RX_MASK		0x2
+#define XLP_SPI_CMD_TXRX_MASK		0x3
+#define XLP_SPI_CMD_CONT		BIT(4)
+#define XLP_SPI_XFR_BITCNT_SHIFT	16
+
+#define XLP_SPI_STATUS			0x43
+#define XLP_SPI_XFR_PENDING		BIT(0)
+#define XLP_SPI_XFR_DONE		BIT(1)
+#define XLP_SPI_TX_TH_OV		BIT(2)
+#define XLP_SPI_RX_TH_OV		BIT(3)
+#define XLP_SPI_TX_UF			BIT(4)
+#define XLP_SPI_RX_OF			BIT(5)
+
+#define XLP_SPI_INTR_EN			0x44
+#define XLP_SPI_INTR_DONE		BIT(0)
+#define XLP_SPI_INTR_MASK		0x1f
+
+#define XLP_SPI_FIFO_THRESH		0x45
+#define XLP_SPI_RXFIFO_THRESH_SHIFT	0
+#define XLP_SPI_TXFIFO_THRESH_SHIFT	4
+
+#define XLP_SPI_FIFO_WCNT		0x46
+#define XLP_SPI_RXFIFO_WCNT_SHIFT	0
+#define XLP_SPI_TXFIFO_WCNT_SHIFT	4
+#define XLP_SPI_FIFO_WCNT_MASK		0xf
+
+#define XLP_SPI_TXDATA_FIFO		0x47
+#define XLP_SPI_RXDATA_FIFO		0x48
+#define XLP_SPI_SYSCTRL			0x80
+#define XLP_SPI_SYS_RESET		BIT(0)
+#define XLP_SPI_SYS_CLKDIS		BIT(1)
+#define XLP_SPI_SYS_PMEN		BIT(8)
+
+#define XLP_SPI_XFER_SIZE		0x1c
+#define SPI_CHAN_OFFSET			0x10
+#define DEFAULT_CS_FDIV			0x4
+#define XLP_SPI_TXRXTH			0x80
+#define XLP_SPI_FIFO_SIZE		8
+#define XLP_SPI_MAX_CS			4
+
+struct xlp_spi_priv {
+	void __iomem		*base;
+	/* data buffers */
+	unsigned char		*rx_buf;
+	const unsigned char	*tx_buf;
+	int			tx_len;
+	int			rx_len;
+	int			txerrors;
+	int			rxerrors;
+	struct device		*dev;
+	int			cs;
+	bool			cmd_cont;
+	struct completion	done;
+};
+
+static inline int xlp_spi_reg_read(struct xlp_spi_priv *priv,
+					int cs, int regidx)
+{
+	void __iomem *addr;
+
+	regidx += cs * SPI_CHAN_OFFSET;
+	addr = priv->base + (regidx << 2);
+	return readl(addr);
+}
+
+static inline void xlp_spi_reg_write(struct xlp_spi_priv *priv, int cs,
+		int regidx, u32 val)
+{
+	void __iomem *addr;
+
+	regidx += cs * SPI_CHAN_OFFSET;
+	addr = priv->base + (regidx << 2);
+	writel(val, addr);
+}
+
+/* reset all spi channels */
+static void xlp_spi_slave_reset(struct xlp_spi_priv *xspi)
+{
+	int cs;
+
+	for (cs = 0; cs < XLP_SPI_MAX_CS; cs++)
+		xlp_spi_reg_write(xspi, 0, XLP_SPI_SYSCTRL,
+				(XLP_SPI_SYS_RESET << cs));
+}
+
+static int xlp_spi_check_transfer(struct spi_device *spi,
+		struct spi_transfer *t)
+{
+	u8 bits_per_word;
+
+	bits_per_word = spi->bits_per_word;
+	if (t && t->bits_per_word)
+		bits_per_word = t->bits_per_word;
+
+	if (bits_per_word != 8) {
+		dev_err(&spi->dev, "unsupported bits_per_word %d\n",
+				bits_per_word);
+		return -EINVAL;
+	}
+
+	if (spi->chip_select > spi->master->num_chipselect) {
+		dev_err(&spi->dev, "unsupported slave %d\n", spi->chip_select);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int xlp_spi_setup(struct spi_device *spi)
+{
+	struct xlp_spi_priv *xspi;
+	int cfg, cs;
+
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
+
+	if (xlp_spi_check_transfer(spi, NULL) < 0)
+		return -EINVAL;
+
+	xspi = spi_master_get_devdata(spi->master);
+	cs = spi->chip_select;
+
+	/* Enable pin muxing. In this mode, the GPIO[28:22] external pins
+	 * are configured for SPI operations.
+	 */
+	xlp_spi_reg_write(xspi, 0, XLP_SPI_SYSCTRL, XLP_SPI_SYS_PMEN);
+	xlp_spi_reg_write(xspi, cs, XLP_SPI_FDIV, DEFAULT_CS_FDIV);
+	xlp_spi_reg_write(xspi, cs, XLP_SPI_FIFO_THRESH, XLP_SPI_TXRXTH);
+
+	cfg = xlp_spi_reg_read(xspi, cs, XLP_SPI_CONFIG);
+	if (spi->mode & XLP_SPI_CPHA)
+		cfg |= XLP_SPI_CPHA;
+	if (spi->mode & XLP_SPI_CPOL)
+		cfg |= XLP_SPI_CPOL;
+	if (!(spi->mode & SPI_CS_HIGH))
+		cfg |= XLP_SPI_CS_POL;
+	if (spi->mode & SPI_LSB_FIRST)
+		cfg |= XLP_SPI_CS_LSBFE;
+
+	cfg |= XLP_SPI_TXMOSI_EN | XLP_SPI_RXMISO_EN | XLP_SPI_RXCAP_EN;
+	xlp_spi_reg_write(xspi, cs, XLP_SPI_CONFIG, cfg);
+
+	return 0;
+}
+
+static void xlp_spi_read_rxfifo(struct xlp_spi_priv *xspi)
+{
+	uint32_t rx_data;
+	int i, j, limit, rxfifo_cnt;
+
+	rxfifo_cnt = xlp_spi_reg_read(xspi, xspi->cs,
+			XLP_SPI_FIFO_WCNT);
+	rxfifo_cnt &= XLP_SPI_FIFO_WCNT_MASK;
+
+	while (rxfifo_cnt) {
+		rx_data = xlp_spi_reg_read(xspi, xspi->cs,
+				XLP_SPI_RXDATA_FIFO);
+		j = 0;
+		limit = xspi->rx_len > 4 ? 4 : xspi->rx_len;
+		for (i = limit - 1; i >= 0; i--) {
+			xspi->rx_buf[i] = (rx_data >> (j * 8)) & 0xff;
+			j++;
+		}
+
+		xspi->rx_len -= limit;
+		xspi->rx_buf += limit;
+		rxfifo_cnt--;
+	}
+}
+
+static void xlp_spi_fill_txfifo(struct xlp_spi_priv *xspi)
+{
+	uint32_t tx_data;
+	int i, j, txfifo_cnt, limit;
+
+	txfifo_cnt = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_FIFO_WCNT);
+	txfifo_cnt >>= XLP_SPI_TXFIFO_WCNT_SHIFT;
+	txfifo_cnt &= XLP_SPI_FIFO_WCNT_MASK;
+
+	while ((xspi->tx_len) && (txfifo_cnt < XLP_SPI_FIFO_SIZE)) {
+		j = 0;
+		tx_data = 0;
+
+		limit = xspi->tx_len > 4 ? 4 : xspi->tx_len;
+		for (i = limit - 1; i >= 0; i--) {
+			tx_data |= xspi->tx_buf[i] << (j * 8);
+			j++;
+		}
+
+		xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_TXDATA_FIFO, tx_data);
+
+		xspi->tx_len -= limit;
+		xspi->tx_buf += limit;
+		txfifo_cnt++;
+	}
+}
+
+static irqreturn_t xlp_spi_interrupt(int irq, void *dev_id)
+{
+	struct xlp_spi_priv *xspi = dev_id;
+	u32 stat;
+
+	stat = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_STATUS);
+
+	if (xspi->tx_len) {
+		if (stat & XLP_SPI_TX_TH_OV) {
+			xlp_spi_fill_txfifo(xspi);
+			if (xspi->tx_len == 0) {
+				xlp_spi_reg_write(xspi, xspi->cs,
+						XLP_SPI_INTR_EN, 0x15);
+			}
+		}
+
+		if (stat & XLP_SPI_TX_UF)
+			xspi->txerrors++;
+	}
+
+	if (xspi->rx_len) {
+		if (stat & XLP_SPI_RX_TH_OV)
+			xlp_spi_read_rxfifo(xspi);
+
+		if (stat & XLP_SPI_RX_OF)
+			xspi->rxerrors++;
+	}
+
+	if (stat & XLP_SPI_XFR_DONE)
+		complete(&xspi->done);
+
+	xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_STATUS, (stat & 0x3f));
+
+	return IRQ_HANDLED;
+}
+
+static void xlp_spi_send_cmd(struct xlp_spi_priv *xspi, int xfer_len,
+		int cmd_cont)
+{
+	int val = 0;
+
+	if (xspi->tx_buf)
+		val |= XLP_SPI_CMD_TX_MASK;
+	if (xspi->rx_buf)
+		val |= XLP_SPI_CMD_RX_MASK;
+	if (cmd_cont)
+		val |= XLP_SPI_CMD_CONT;
+	if (xfer_len) {
+		val |= ((xfer_len * 8 - 1) << XLP_SPI_XFR_BITCNT_SHIFT);
+		xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_CMD, val);
+	}
+}
+
+static int xlp_spi_xfer_block(struct  xlp_spi_priv *xs,
+		const unsigned char *tx_buf,
+		unsigned char *rx_buf, int xfer_len, int cmd_cont)
+{
+	int timeout;
+
+	xs->tx_buf = tx_buf;
+	xs->rx_buf = rx_buf;
+	xs->tx_len = (xs->tx_buf == NULL) ? 0 : xfer_len;
+	xs->rx_len = (xs->rx_buf == NULL) ? 0 : xfer_len;
+	xs->txerrors = xs->rxerrors = 0;
+
+	init_completion(&xs->done);
+
+	/* fill TXDATA_FIFO, then send the CMD */
+	if (xs->tx_len)
+		xlp_spi_fill_txfifo(xs);
+
+	xlp_spi_send_cmd(xs, xfer_len, cmd_cont);
+
+	if (xs->tx_len)
+		xlp_spi_reg_write(xs, xs->cs, XLP_SPI_INTR_EN, 0x1f);
+	else
+		xlp_spi_reg_write(xs, xs->cs, XLP_SPI_INTR_EN, 0x15);
+
+	timeout = wait_for_completion_timeout(&xs->done,
+			msecs_to_jiffies(1000));
+	if (!timeout) {
+		pr_info("%s: cs %d xfer timedout !!!\n", __func__, xs->cs);
+		goto out;
+	}
+	if (xs->txerrors || xs->rxerrors)
+		pr_info("Under/Overflow rx %d tx %d xfer %d!!\n",
+				xs->rxerrors, xs->txerrors, xfer_len);
+
+	/* Disable interrupts */
+	xlp_spi_reg_write(xs, xs->cs, XLP_SPI_INTR_EN, 0x0);
+
+	return xfer_len;
+out:
+	return -ETIMEDOUT;
+}
+
+static int xlp_spi_txrx_bufs(struct xlp_spi_priv *xs, struct spi_transfer *t)
+{
+	int ret, len, total_len;
+	unsigned char *rx_buf;
+	const unsigned char *tx_buf;
+
+	ret = 0;
+	total_len = 0;
+	len = t->len;
+	tx_buf = t->tx_buf;
+	rx_buf = t->rx_buf;
+
+	while (len > XLP_SPI_XFER_SIZE) {
+		ret = xlp_spi_xfer_block(xs, tx_buf, rx_buf,
+				XLP_SPI_XFER_SIZE, 1);
+		if (ret < 0)
+			return ret;
+		else
+			total_len += ret;
+
+		len = len - XLP_SPI_XFER_SIZE;
+		if (tx_buf)
+			tx_buf = tx_buf + XLP_SPI_XFER_SIZE;
+		if (rx_buf)
+			rx_buf = rx_buf + XLP_SPI_XFER_SIZE;
+	}
+	if (len) {
+		ret = xlp_spi_xfer_block(xs, tx_buf, rx_buf, len, xs->cmd_cont);
+		if (ret < 0)
+			return ret;
+		else
+			total_len += ret;
+	}
+
+	return total_len;
+}
+
+static int xlp_spi_transfer_one(struct spi_master *master,
+					struct spi_message *msg)
+{
+	struct spi_transfer *t;
+	struct spi_device *spi = msg->spi;
+	struct xlp_spi_priv *xspi = spi_master_get_devdata(spi->master);
+	int status, r;
+
+	status = 0;
+	r = 0;
+	xspi->cs = spi->chip_select;
+	list_for_each_entry(t, &msg->transfers, transfer_list) {
+		status = xlp_spi_check_transfer(spi, t);
+		if (status)
+			goto err;
+
+		xspi->cmd_cont = 0;
+		if (t->len) {
+			if (!(t->transfer_list.next == &msg->transfers))
+				xspi->cmd_cont = 1;
+			r = xlp_spi_txrx_bufs(xspi, t);
+		}
+
+		if (r != t->len || r < 0) {
+			status = -EREMOTEIO;
+			goto err;
+		} else {
+			msg->actual_length += r;
+		}
+	}
+err:
+	msg->status = status;
+	spi_finalize_current_message(master);
+
+	return status;
+}
+
+static int xlp_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct xlp_spi_priv *xspi;
+	struct resource *res;
+	const __be32 *prop;
+	int irq, ret = 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	prop = of_get_property(pdev->dev.of_node, "interrupts", NULL);
+	if (prop == NULL) {
+		dev_err(&pdev->dev, "No \"interrupts\" property!\n");
+		return -ENXIO;
+	}
+
+	irq = be32_to_cpu(*prop);
+	if (!irq) {
+		dev_err(&pdev->dev, "no irq\n");
+		return -ENXIO;
+	}
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*xspi));
+	if (!master) {
+		dev_err(&pdev->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	xspi = spi_master_get_devdata(master);
+	platform_set_drvdata(pdev, xspi);
+
+	master->bus_num = 0;
+	master->num_chipselect = XLP_SPI_MAX_CS;
+	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
+	master->setup = xlp_spi_setup;
+	master->transfer_one_message = xlp_spi_transfer_one;
+	master->dev.of_node = pdev->dev.of_node;
+
+	xspi->base = devm_request_and_ioremap(&pdev->dev, res);
+	if (xspi->base == NULL) {
+		ret = -ENOMEM;
+		goto put_master;
+	}
+
+	ret = devm_request_irq(&pdev->dev, irq, xlp_spi_interrupt,
+			IRQF_NO_THREAD, pdev->name, xspi);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request irq %d\n", irq);
+		goto put_master;
+	}
+
+	spi_master_set_devdata(master, xspi);
+	xlp_spi_slave_reset(xspi);
+	/* register our spi controller */
+	ret = spi_register_master(master);
+	if (ret) {
+		dev_err(&pdev->dev, "spi register master failed!\n");
+		goto put_master;
+	}
+
+	return 0;
+
+put_master:
+	spi_master_put(master);
+	return ret;
+}
+
+static int xlp_spi_remove(struct platform_device *pdev)
+{
+	struct spi_master *master;
+
+	master = platform_get_drvdata(pdev);
+	platform_set_drvdata(pdev, 0);
+	spi_unregister_master(master);
+	spi_master_put(master);
+
+	return 0;
+}
+
+static struct of_device_id xlp_spi_dt_id[] = {
+	{ .compatible = "netlogic,xlp-spi" },
+};
+
+static struct platform_driver xlp_spi_driver = {
+	.probe	= xlp_spi_probe,
+	.remove	= xlp_spi_remove,
+	.driver = {
+		.name	= "xlp-spi",
+		.owner	= THIS_MODULE,
+		.of_match_table = xlp_spi_dt_id,
+	},
+};
+module_platform_driver(xlp_spi_driver);
+
+MODULE_AUTHOR("Kamlakant Patel <kamlakant.patel@broadcom.com>");
+MODULE_DESCRIPTION("Netlogic XLP SPI controller driver");
+MODULE_LICENSE("GPL v2");
-- 
1.9.1

