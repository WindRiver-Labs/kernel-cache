From 0e59421b7a4c3e3949ed7c510d0a52b1a62c11c6 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Wed, 11 Aug 2010 20:40:45 -0700
Subject: [PATCH 1280/1532] NAE: add RUN_ON_SIM_ONLY workarround to solve
 simulator hanging issue, nfs now work over simualtor

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/xlp_nae.c | 108 ++++++++++++++++++++++------
 1 file changed, 87 insertions(+), 21 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index 4862f9d..2e6f8ae 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -70,7 +70,7 @@
 #define FREE_DEFAULT_SIZE		256
 #define NUM_FREE_DESC			18
 #define NUM_FREEIN_QUEUE		18
-#define MIN_FRIN_DESC_THRESHD		8
+#define MIN_FRIN_DESC_THRESHD		10
 #define MAX_NET_INF             	18
 #define XLP_SGMII_RCV_CONTEXT_NUM	8
 
@@ -93,6 +93,7 @@
         }					\
 	printk("\n");
 
+#define RUN_ON_SIM_ONLY		1
 
 unsigned char eth_hw_addr[18][6] = {
 					{0x00,0x01,0x02,0x03,0x04,0x05},
@@ -289,7 +290,7 @@ static void mac_refill_frin_desc(unsigned long dev)
 	priv = netdev_priv(ndev);
 	ret = 0;
 
-	limit = priv->inited ? MIN_FRIN_DESC_THRESHD*4: MIN_FRIN_DESC_THRESHD*4*10;
+	limit = priv->inited ? MIN_FRIN_DESC_THRESHD*2: MIN_FRIN_DESC_THRESHD*4;
 
 	for(i=1; i <= limit; i++)
 	{
@@ -311,13 +312,31 @@ static void mac_refill_frin_desc(unsigned long dev)
 		msgrng_access_enable(mflags);
 		msg.entry[0] = (unsigned long long)virt_to_bus(skb->data) & 0xffffffffffULL;
 		msg.entry[1]= msg.entry[2] = msg.entry[3] = 0;
-
 		/* Send the packet to nae rx  */
 		__sync();
 retry_send:
-                if ((ret = nlm_hal_send_msg1( priv->nae_rx_qid, code, msg.entry[0]))){
-                        if(ret & MSG_DST_FC_FAIL)
+                if ((ret = nlm_hal_send_msg1( priv->nae_rx_qid, code, msg.entry[0])))
+		{
+			if(ret & MSG_DST_FC_FAIL)
+			{
+				ret = xlp_read_status1();
+				if( ret & (1 << 31))
+				{
+					printk("CPU receive queue written when Full\n");
+
+				}
+				else if(ret & (1 << 30))
+				{
+					printk("Fmn input credit overflow hardware error\n");
+				}
+				else if( ret & (1 << 29))
+				{
+					printk("Fmn output credit overflow error, Outq ID: %d\n", ret & 0xfff);
+				}
                                 printk("TX message destination flow control credit fail\n");
+				msgrng_access_disable(mflags);
+				break;
+			}
                         else if(ret & MSG_INFLIGHT_MSG_EX)
                                 goto retry_send;
                         else if(ret & MSG_TXQ_FULL)
@@ -328,7 +347,7 @@ retry_send:
                 }
 
 		msgrng_access_disable(mflags);
-		priv->num_desc++;
+		priv->num_desc += 1;
 	}
 
         return;
@@ -373,8 +392,27 @@ retry_send:
                                         code,
                                         msg.entry[0]))){
                         if(ret & MSG_DST_FC_FAIL)
+                        {
+                                ret = xlp_read_status1();
+                                if( ret & (1 << 31))
+                                {
+                                        printk("CPU receive queue written when Full\n");
+
+                                }
+                                else if(ret & (1 << 30))
+                                {
+                                        printk("Fmn input credit overflow hardware error\n");
+                                }
+                                else if( ret & (1 << 29))
+                                {
+                                        printk("Fmn output credit overflow error, Outq ID: %d\n", ret & 0xfff);
+                                }
                                 printk("TX message destination flow control credit fail\n");
-                        else if(ret & MSG_INFLIGHT_MSG_EX)
+                                msgrng_access_disable(mflags);
+                                break;
+                        }
+
+			else if(ret & MSG_INFLIGHT_MSG_EX)
                                 goto retry_send;
                         else if(ret & MSG_TXQ_FULL)
                                 printk("TX message Q fulll\n");
@@ -386,7 +424,7 @@ retry_send:
 
 
 		msgrng_access_disable(mflags);
-		priv->num_desc++;
+		priv->num_desc += 1;
         }
 
         return ret;
@@ -412,6 +450,7 @@ static void nlm_xlp_nae_init(void)
 	struct dev_data *tp;
 	int i;
 	struct proc_dir_entry *entry;
+        uint64_t* spill_addr;
 	uint32_t val;
 
 	if(xlp_sgmii_ports <= 0 || xlp_sgmii_ports > MAX_GMAC_PORT)
@@ -425,6 +464,20 @@ static void nlm_xlp_nae_init(void)
 	//initial base address for nae, gmac, fmn ...
 
 	spin_lock_irq(&nlm_xlp_nae_lock);
+#if 0
+        spill_addr = ( uint64_t*) kmalloc(129*16*1024, GFP_KERNEL);
+        if(!spill_addr)
+        {
+                printk("kmalloc spill address failed\n");
+        }
+        else
+	{
+		spill_addr = virt_to_phys(spill_addr);
+	//	printk("[%s] spill_addr: 0x%llx \n", __func__,spill_addr);
+                config_outq_spill((uint64_t)spill_addr);
+
+	}
+#endif
 
 	//initial 18 gmac block
         for(i = 0; i < MAX_NET_INF; i++)
@@ -577,6 +630,7 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 		panic("can't register msgring handler for TX_STN_GMAC0");
 	}
 	nlm_xlp_nae_fill_rxfr(dev,  port );
+	mac_refill_frin_desc(dev);
 /*
 	irq  = irt_irq_table[PIC_IRT_NA_INDEX(port)][0];
 	if(request_irq( irq, nlm_xlp_nae_int_handler, IRQF_SHARED,dev->name, dev)){
@@ -592,8 +646,9 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 	priv->link_timer.function = &nlm_xlp_mac_timer;
 	priv->phy_oldlinkstat = -1;
 
-//	add_timer(&priv->link_timer);
-
+#ifdef RUN_ON_SIM_ONLY
+	add_timer(&priv->link_timer);
+#endif
 //	napi_enable(&priv->napi);
 
 
@@ -620,7 +675,6 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 	}
 
 	priv->inited = 1;
-
 	return 0;
 }
 
@@ -969,7 +1023,7 @@ static void  nlm_xlp_nae_rx(struct sk_buff* skb, struct net_device *dev)
 		priv->stats.rx_bytes += len;
 		priv->stats.rx_packets++;
 		priv->cpu_stats[cpu].rx_packets++;
-		priv->num_desc--;
+		priv->num_desc -= 1;
         }
 	else if(!skb)
 	{
@@ -1029,28 +1083,32 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 {
         struct net_device *pdev;
         struct dev_data *priv;
-	unsigned int len, port = 0, src, cpu, context;
+	unsigned int len, port = 0, freedesc, src, cpu, context;
         unsigned char* buf;
         uint64_t addr , vaddr;
 	struct sk_buff* skb;
 
-	cpu = vc % 16;
+	cpu = vc >> 4;
 	vc = vc % 4;
 
 	if( vc == 1)
 	{
 		port = msg0 & 0x0f;
-		//printk("port: %d got src_id: %d msg %llx \n\n",port, src_id, msg0);
+	//	printk("port: %d got src_id: %d msg %llx \n\n",port, src_id, msg0);
                 addr = msg0 & 0xfffffffff0ULL;
                 len = (msg0 >> 40) & 0x3fff;
-
-
+#ifdef RUN_ON_SIM_ONLY
+		freedesc = len;
+		len = 0;
+#endif
                 if(addr && (len==0))
                 {
 			pdev = (struct net_device*)dev_mac[port];
 			if(!pdev)
 				return;
 			priv = netdev_priv(pdev);
+			if(priv->num_desc > freedesc)
+				priv->num_desc = freedesc;
 
                         skb = (struct sk_buff *)bus_to_virt(addr);
                         if(skb)
@@ -1063,8 +1121,8 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
                         }
 			if( priv->num_desc < MIN_FRIN_DESC_THRESHD)
 			{
-			//printk("num_desc:%d refill_task[%d]:%x \n", priv->num_desc, priv->port, mac_refill_task[port]);
-				tasklet_schedule(&mac_refill_task[0]);
+		//	printk("num_desc:%d refill_task[%d]:%x \n", priv->num_desc, priv->port, mac_refill_task[port]);
+				tasklet_schedule(&mac_refill_task[port]);
 			}
                 }
                 else if(addr == 0)
@@ -1154,7 +1212,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			priv->stats.rx_bytes += len;
 			priv->stats.rx_packets++;
 			priv->cpu_stats[cpu].rx_packets++;
-			priv->num_desc--;
+			priv->num_desc -= 1;
 #if DUMP_RCV_PKT
 			DUMP_PKT(skb->data, skb->len)
 #endif
@@ -1236,7 +1294,15 @@ static void nlm_xlp_mac_timer(unsigned long data)
         int next_tick = HZ;
 
         spin_lock_irq(&priv->lock);
-	nlm_xlp_nae_rx(priv->skb, dev);
+#ifdef RUN_ON_SIM_ONLY
+	if( priv->num_desc <= MIN_FRIN_DESC_THRESHD)
+	{
+	//	printk("num_desc:%d refill_task[%d]:%x \n", priv->num_desc, priv->port, mac_refill_task[port]);
+		mac_refill_frin_desc(dev);
+	}
+#endif
+
+//	nlm_xlp_nae_rx(priv->skb, dev);
         spin_unlock_irq(&priv->lock);
         priv->link_timer.expires = jiffies + next_tick/10;
         add_timer(&priv->link_timer);
-- 
1.9.1

