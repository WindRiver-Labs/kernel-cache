From 914e4b0b0403e0a99b7eee271677530ef890c8c4 Mon Sep 17 00:00:00 2001
From: Ashwin Sekhar T K <ashwin@broadcom.com>
Date: Tue, 30 Sep 2014 15:56:35 +0530
Subject: [PATCH 1247/1532] kmod/dtre: Enable removal of DTRE module

DTRE module can be removed by th following commands.
echo 0 > /sys/class/nlm_adma/enable
modprobe -r dtre
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/dtre/nlm_adma.c | 218 ++++++++++++++++++++++++++++++----
 1 file changed, 193 insertions(+), 25 deletions(-)

diff --git a/drivers/misc/netlogic/dtre/nlm_adma.c b/drivers/misc/netlogic/dtre/nlm_adma.c
index 4447ade..4d57f59 100644
--- a/drivers/misc/netlogic/dtre/nlm_adma.c
+++ b/drivers/misc/netlogic/dtre/nlm_adma.c
@@ -37,7 +37,7 @@
 #include <linux/interrupt.h>
 #include <linux/dmaengine.h>
 #include <linux/timer.h>
-
+#include <linux/device.h>
 #include <asm/netlogic/mips-extns.h>
 
 #include "nlm_adma.h"
@@ -47,6 +47,7 @@
 #include "nlm_hal_fmn.h"
 #include "nlm_hal_fmn_dp.h"
 #include "libfdt.h"
+#include "nlm_msgring.h"
 
 uint64_t nlm_dtre_debug = 0;
 uint32_t is_nlm_9xx_family;
@@ -57,19 +58,37 @@ static unsigned int nlm_dtre_min_vc = 0;
 
 extern void *fdt;
 extern void nlm_hal_dtr_init(void *fdt);
-extern int register_xlp_msgring_handler(int major,
-				void (*action) (uint32_t, uint32_t, uint32_t, uint32_t,
-						uint64_t, uint64_t, uint64_t, uint64_t, void *),
-				void *dev_id);
 
 struct nlm_adma_device nlm_adma_raid_device;
 struct page * nlm_dtre_null_page;
 
+static struct nlm_adma_device **nlm_adma_raid_devices;
+static struct platform_device *nlm_dma_device;
+static struct class *nlm_dma_class_ptr;
+static unsigned int nlm_dma_enabled;
+
 static int dtre_init_only = 0;
 
 #define CACHELINE_SIZE 64
 #define CACHELINE_ALIGNED_ADDR(addr) (((unsigned long)(addr)) & ~(CACHELINE_SIZE-1))
 
+#define NLM_ADMA_DEVICE_NAME	"NLM-ADMA"
+#define NLM_ADMA_CLASS_NAME	"nlm_adma"
+
+#define DTRE_DEBUG_CONTROL0_OFFSET	0x4C
+#define DTRE_DEBUG_CONTROL1_OFFSET	0x4D
+#define CC_BIT_SHIFT			0x0
+#define CCD_BIT_SHIFT			0x1
+#define DTRE_CLEAR_CHANNEL(base, dbgCtrl) {\
+	uint32_t value; \
+\
+	nlm_hal_write_32bit_reg((base), (dbgCtrl), (0x1 << CC_BIT_SHIFT)); \
+	value = nlm_hal_read_32bit_reg((base), (dbgCtrl)); \
+	while (!(value & (0x1 << CCD_BIT_SHIFT))) \
+		value = nlm_hal_read_32bit_reg((base), (dbgCtrl)); \
+	nlm_hal_write_32bit_reg((base), (dbgCtrl), (0x1 << CC_BIT_SHIFT)); \
+}
+
 static __inline__ void *cacheline_aligned_kzalloc(int size, int gfp_mask)
 {
 	void *buf, **mem = NULL;
@@ -1545,6 +1564,12 @@ static int nlm_adma_probe(struct platform_device *pdev)
 		num_channels = DTRE_NUM_CHANNELS;
 	}
 
+	nlm_adma_raid_devices = kzalloc(sizeof(struct nlm_adma_device *) *
+					num_channels,
+					GFP_KERNEL);
+	if (!nlm_adma_raid_devices)
+		return -ENOMEM;
+
 	for (loop = 0; loop < num_channels; loop++)
 	{
 		/* assume current channel is DMA (not raid)
@@ -1554,6 +1579,7 @@ static int nlm_adma_probe(struct platform_device *pdev)
 		adev = kzalloc(sizeof(*adev), GFP_KERNEL);
 		if (!adev)
 			return -ENOMEM;
+		nlm_adma_raid_devices[loop] = adev;
 		dma_dev = &(adev->common);
 
 		/*
@@ -1722,65 +1748,205 @@ static int nlm_adma_probe(struct platform_device *pdev)
 
 static int nlm_adma_remove(struct platform_device *dev)
 {
-	return 0;
-}
+	int num_channels, loop;
+	uint64_t base;
 
+	if (is_nlm_xlp2xx())
+		num_channels = DTRE_2XX_NUM_CHANNELS;
+	else if (is_nlm_xlp5xx())
+		num_channels = DTRE_5XX_NUM_CHANNELS;
+	else
+		num_channels = DTRE_NUM_CHANNELS;
 
-MODULE_ALIAS("platform:nlm-adma");
+	/* Undo all the actions done by probe */
+
+	for (loop = 0; loop < num_channels; loop++) {
+		struct nlm_adma_device *adev = nlm_adma_raid_devices[loop];
+		struct dma_device *dma_dev = &(adev->common);
+		struct list_head *cur, *next;
+
+		list_for_each_safe(cur, next, &dma_dev->channels) {
+			struct dma_chan *chan;
+			struct nlm_adma_chan *nlm_chan;
+
+			chan = list_entry(cur, struct dma_chan, device_node);
+			nlm_chan = to_nlm_adma_chan(chan);
+			tasklet_kill(&nlm_chan->irq_tasklet);
+			dma_release_channel(chan);
+			free_initial_tx_desc_pool(nlm_chan);
+		}
+		dma_async_device_unregister(dma_dev);
+		list_for_each_safe(cur, next, &dma_dev->channels) {
+			struct dma_chan *chan;
+			struct nlm_adma_chan *nlm_chan;
+
+			chan = list_entry(cur, struct dma_chan, device_node);
+			list_del(cur);
+			nlm_chan = to_nlm_adma_chan(chan);
+			kfree(nlm_chan);
+		}
+
+		kfree(adev);
+	}
+	kfree(nlm_adma_raid_devices);
+
+	__free_page(nlm_dtre_null_page);
+
+	if (is_nlm_xlp9xx()) {
+		unregister_xlp_msgring_handler(XLP_MSG_HANDLE_GDX_0, NULL);
+		unregister_xlp_msgring_handler(XLP_MSG_HANDLE_GDX_1, NULL);
+	} else if (is_nlm_xlp5xx())
+		unregister_xlp_msgring_handler(XLP_MSG_HANDLE_GDX_0, NULL);
+	else
+		unregister_xlp_msgring_handler(XLP_MSG_HANDLE_DTRE, NULL);
+
+	/* Clear and reset the channels */
+	if (is_nlm_xlp9xx()) {
+		/* For DTRE0, B/D/F = 1/5/0 */
+		base = nlm_hal_get_dev_base(0, 1, 5, 0);
+		DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL0_OFFSET);
+		DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL1_OFFSET);
+
+		/* For DTRE1, B/D/F = 1/5/6 */
+		base = nlm_hal_get_dev_base(0, 1, 5, 6);
+		DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL0_OFFSET);
+		DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL1_OFFSET);
+	} else if (is_nlm_xlp5xx()) {
+		/* For DTRE, B/D/F = 1/5/0 */
+		base = nlm_hal_get_dev_base(0, 1, 5, 0);
+		DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL0_OFFSET);
+		DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL1_OFFSET);
+	} else if (!is_nlm_xlp2xx()) {
+		/* For DTRE, B/D/F = 0/5/0 */
+		base = nlm_hal_get_dev_base(0, 0, 5, 0);
+		DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL0_OFFSET);
+		DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL1_OFFSET);
+	}
+
+	pr_info("NLM ASYNC Device Unregistered\n");
+
+	return 0;
+}
 
 static struct platform_driver nlm_adma_driver = {
 	.probe		= nlm_adma_probe,
 	.remove		= nlm_adma_remove,
 	.driver		= {
 		.owner	= THIS_MODULE,
-		.name	= "NLM-ADMA",
+		.name	= NLM_ADMA_DEVICE_NAME,
 	},
 };
 
-static int __init nlm_add_dma_dev(void)
+static int nlm_add_dma_dev(void)
+{
+	struct platform_device *pd;
+	int ret;
+
+	pd = platform_device_alloc(NLM_ADMA_DEVICE_NAME, -1);
+	if (!pd)
+		return -ENOMEM;
+
+	ret = platform_device_add(pd);
+	if (ret) {
+		platform_device_put(pd);
+		pd = NULL;
+	}
+
+	nlm_dma_device = pd;
+
+	return ret;
+}
+
+static void nlm_remove_dma_dev(void)
+{
+	if (nlm_dma_device) {
+		platform_device_del(nlm_dma_device);
+		platform_device_put(nlm_dma_device);
+	}
+}
+
+static ssize_t nlm_dma_enable_show(struct class *class,
+		struct class_attribute *attr,
+		char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", nlm_dma_enabled);
+}
+
+static ssize_t nlm_dma_enable_store(struct class *class,
+		struct class_attribute *attr,
+		const char *buf, size_t count)
 {
-        struct platform_device *pd;
-        int ret;
+	int rc;
+	u64 value;
 
-        pd = platform_device_alloc("NLM-ADMA", -1);
-        if (!pd)
-                return -ENOMEM;
+	rc = kstrtoull(buf, 0, &value);
+	if (rc)
+		return 0;
 
-        ret = platform_device_add(pd);
-        if (ret)
-                platform_device_put(pd);
+	if (value == 1 && nlm_dma_enabled == 0) {
+		nlm_dma_enabled = 1;
+		nlm_add_dma_dev();
+	} else if (value == 0 && nlm_dma_enabled == 1) {
+		nlm_remove_dma_dev();
+		nlm_dma_enabled = 0;
+	}
 
-        return ret;
+	return count;
 }
 
+static struct class_attribute nlm_dma_class_attr[] = {
+	__ATTR(enable,
+		   S_IRUGO | S_IWUSR,
+		   nlm_dma_enable_show,
+		   nlm_dma_enable_store),
+	__ATTR_NULL
+};
+
+static struct class nlm_dma_class = {
+	.name = NLM_ADMA_CLASS_NAME,
+	.owner = THIS_MODULE,
+	.class_attrs = nlm_dma_class_attr
+};
+
 static int __init is_dtre_init_only(void)
 {
 	int prop_len;
 	const void *pbuf;
 	int node;
 
-        node = fdt_path_offset(fdt, "/doms/dom@0/dtre");
-        if (node < 0)
-                return 0;
+	node = fdt_path_offset(fdt, "/doms/dom@0/dtre");
+	if (node < 0)
+		return 0;
 
-        pbuf = (char *)fdt_getprop(fdt, node, "dtre_init_only", &prop_len);
-        if (pbuf == NULL)
-                return 0;
+	pbuf = (char *)fdt_getprop(fdt, node, "dtre_init_only", &prop_len);
+	if (pbuf == NULL)
+		return 0;
 
 	return *(int *)pbuf;
 }
 
 static int __init nlm_adma_init (void)
 {
+	int ret;
+
 	if (is_dtre_init_only()) {
 		printk("DTRE Driver: Initialization only\n");
 		dtre_init_only = 1;
 		nlm_hal_dtr_init(fdt);
 		return 0;
 	}
+	ret = class_register(&nlm_dma_class);
+	if (ret) {
+		pr_err("Failed to register nlm_dma class\n");
+		return -ENOMEM;
+	}
+	nlm_dma_class_ptr = &nlm_dma_class;
 
 	platform_driver_register(&nlm_adma_driver);
+
+	nlm_dma_enabled = 1;
 	nlm_add_dma_dev();
+
 	return 0;
 }
 
@@ -1790,12 +1956,14 @@ static void __exit nlm_adma_exit (void)
 		return;
 
 	platform_driver_unregister(&nlm_adma_driver);
+	class_destroy(nlm_dma_class_ptr);
 	return;
 }
 
 module_init(nlm_adma_init);
 module_exit(nlm_adma_exit);
 
+MODULE_ALIAS("platform:nlm-adma");
 MODULE_AUTHOR("Netlogic");
 MODULE_DESCRIPTION("Netlogic ADMA Engine Driver");
 MODULE_LICENSE("GPL");
-- 
1.9.1

