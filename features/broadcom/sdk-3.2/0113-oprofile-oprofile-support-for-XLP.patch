From 6e3b168a8c569598abce0a498fcd896391903dd0 Mon Sep 17 00:00:00 2001
From: Madhusudan Bhat <mbhat@broadcom.com>
Date: Fri, 24 May 2013 15:14:29 +0530
Subject: [PATCH 0113/1532] oprofile: oprofile support for XLP

Support for 64-bit perf counter registers on XLP.

Conflicts:

	arch/mips/netlogic/common/irq.c
	arch/mips/oprofile/Makefile
	arch/mips/oprofile/op_model_mipsxx.c
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/include/asm/netlogic/interrupt.h |   1 +
 arch/mips/netlogic/common/irq.c            |   5 +-
 arch/mips/oprofile/Makefile                |   1 +
 arch/mips/oprofile/common.c                |   1 +
 arch/mips/oprofile/op_model_mipsxx.c       | 108 ++++++++++++++++++++++-------
 5 files changed, 89 insertions(+), 27 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/interrupt.h b/arch/mips/include/asm/netlogic/interrupt.h
index ed5993d..3354f1e 100644
--- a/arch/mips/include/asm/netlogic/interrupt.h
+++ b/arch/mips/include/asm/netlogic/interrupt.h
@@ -40,6 +40,7 @@
 #define IRQ_IPI_SMP_FUNCTION	3
 #define IRQ_IPI_SMP_RESCHEDULE	4
 #define IRQ_FMN			5
+#define IRQ_PERF		6
 #define IRQ_TIMER		7
 
 #endif
diff --git a/arch/mips/netlogic/common/irq.c b/arch/mips/netlogic/common/irq.c
index c100b9a..03957118 100644
--- a/arch/mips/netlogic/common/irq.c
+++ b/arch/mips/netlogic/common/irq.c
@@ -73,8 +73,9 @@
 #else
 #define SMP_IRQ_MASK	0
 #endif
-#define PERCPU_IRQ_MASK (SMP_IRQ_MASK | (1ull << IRQ_TIMER) | \
-				(1ull << IRQ_FMN))
+#define PERCPU_IRQ_MASK	(SMP_IRQ_MASK | (1ull << IRQ_TIMER) | \
+				(1ull << IRQ_FMN) | \
+				(1ull << IRQ_PERF))
 
 struct nlm_pic_irq {
 	void	(*extra_ack)(struct irq_data *);
diff --git a/arch/mips/oprofile/Makefile b/arch/mips/oprofile/Makefile
index 9c0a678..cec4653 100644
--- a/arch/mips/oprofile/Makefile
+++ b/arch/mips/oprofile/Makefile
@@ -13,4 +13,5 @@ oprofile-$(CONFIG_CPU_MIPS64)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_R10000)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_SB1)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_XLR)		+= op_model_mipsxx.o
+oprofile-$(CONFIG_CPU_XLP)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_LOONGSON2)	+= op_model_loongson2.o
diff --git a/arch/mips/oprofile/common.c b/arch/mips/oprofile/common.c
index af763e8..16c2f8e 100644
--- a/arch/mips/oprofile/common.c
+++ b/arch/mips/oprofile/common.c
@@ -92,6 +92,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	case CPU_R12000:
 	case CPU_R14000:
 	case CPU_XLR:
+	case CPU_XLP:
 		lmodel = &op_model_mipsxx_ops;
 		break;
 
diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index e4b1140..dd70539 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -13,6 +13,7 @@
 #include <asm/irq_regs.h>
 
 #include "op_impl.h"
+#include <asm/mipsregs.h>
 
 #define M_PERFCTL_EXL			(1UL	  <<  0)
 #define M_PERFCTL_KERNEL		(1UL	  <<  1)
@@ -30,10 +31,14 @@
 #define M_PERFCTL_MORE			(1UL	  << 31)
 
 #define M_COUNTER_OVERFLOW		(1UL	  << 31)
+#define M_COUNTER_OVERFLOW_64		(1UL	  << 63)
 
 /* Netlogic XLR specific, count events in all threads in a core */
 #define M_PERFCTL_COUNT_ALL_THREADS	(1UL	  << 13)
 
+/* BROADCOM XLP specific, count events in all threads in a core */
+#define M_XLP_PERFCTL_COUNT_ALL_THREADS	(1UL	  << 25)
+
 static int (*save_perf_irq)(void);
 
 /*
@@ -41,7 +46,7 @@ static int (*save_perf_irq)(void);
  * first hardware thread in the core for setup and init.
  * Skip CPUs with non-zero hardware thread id (4 hwt per core)
  */
-#if defined(CONFIG_CPU_XLR) && defined(CONFIG_SMP)
+#if defined(CONFIG_CPU_XLR)
 #define oprofile_skip_cpu(c)	((cpu_logical_map(c) & 0x3) != 0)
 #else
 #define oprofile_skip_cpu(c)	0
@@ -136,11 +141,48 @@ __define_perf_accessors(perfctrl, 1, 3)
 __define_perf_accessors(perfctrl, 2, 0)
 __define_perf_accessors(perfctrl, 3, 1)
 
+#define r_c0_perfcntr0_64()	read_c0_perfcntr0_64()
+#define r_c0_perfcntr1_64()	read_c0_perfcntr1_64()
+#define r_c0_perfcntr2_64()	read_c0_perfcntr2_64()
+#define r_c0_perfcntr3_64()	read_c0_perfcntr3_64()
+
+#define w_c0_perfcntr0_64(n)	write_c0_perfcntr0_64(n)
+#define w_c0_perfcntr1_64(n)	write_c0_perfcntr1_64(n)
+#define w_c0_perfcntr2_64(n)	write_c0_perfcntr2_64(n)
+#define w_c0_perfcntr3_64(n)	write_c0_perfcntr3_64(n)
+
+#ifdef CONFIG_CPU_XLP
+#define cpu_has_64bit_perfcntr()	1
+#else
+#define cpu_has_64bit_perfcntr()	0
+#endif
+
+#define init_c0_perfcntr(n, reg)					\
+{									\
+	do {								\
+		if (cpu_has_64bit_perfcntr())				\
+			w_c0_perfcntr ## n ## _64(reg.counter64[n]);	\
+		else							\
+			w_c0_perfcntr ## n(reg.counter[n]);		\
+	} while (0);							\
+}
+
+#define setup_c0_perfcntr(n)						\
+{									\
+	do {								\
+		if (cpu_has_64bit_perfcntr())				\
+			w_c0_perfcntr ## n ## _64(reg.counter64[n]);	\
+		else							\
+			w_c0_perfcntr ## n(reg.counter[n]);		\
+	} while (0);							\
+}
+
 struct op_mips_model op_model_mipsxx_ops;
 
 static struct mipsxx_register_config {
 	unsigned int control[4];
 	unsigned int counter[4];
+	uint64_t     counter64[4];
 } reg;
 
 /* Compute all of the registers in preparation for enabling profiling.	*/
@@ -154,6 +196,7 @@ static void mipsxx_reg_setup(struct op_counter_config *ctr)
 	for (i = 0; i < counters; i++) {
 		reg.control[i] = 0;
 		reg.counter[i] = 0;
+		reg.counter64[i] = 0;
 
 		if (!ctr[i].enabled)
 			continue;
@@ -168,7 +211,12 @@ static void mipsxx_reg_setup(struct op_counter_config *ctr)
 			reg.control[i] |= M_PERFCTL_EXL;
 		if (current_cpu_type() == CPU_XLR)
 			reg.control[i] |= M_PERFCTL_COUNT_ALL_THREADS;
-		reg.counter[i] = 0x80000000 - ctr[i].count;
+		if (current_cpu_type() == CPU_XLP)
+			reg.control[i] |= M_XLP_PERFCTL_COUNT_ALL_THREADS;
+		if (cpu_has_64bit_perfcntr())
+			reg.counter64[i] = 0x8000000000000000 - ctr[i].count;
+		else
+			reg.counter[i] = 0x80000000 - ctr[i].count;
 	}
 }
 
@@ -184,16 +232,16 @@ static void mipsxx_cpu_setup(void *args)
 	switch (counters) {
 	case 4:
 		w_c0_perfctrl3(0);
-		w_c0_perfcntr3(reg.counter[3]);
+		setup_c0_perfcntr(3);
 	case 3:
 		w_c0_perfctrl2(0);
-		w_c0_perfcntr2(reg.counter[2]);
+		setup_c0_perfcntr(2);
 	case 2:
 		w_c0_perfctrl1(0);
-		w_c0_perfcntr1(reg.counter[1]);
+		setup_c0_perfcntr(1);
 	case 1:
 		w_c0_perfctrl0(0);
-		w_c0_perfcntr0(reg.counter[0]);
+		setup_c0_perfcntr(0);
 	}
 }
 
@@ -241,8 +289,7 @@ static int mipsxx_perfcount_handler(void)
 {
 	unsigned int counters = op_model_mipsxx_ops.num_counters;
 	unsigned int control;
-	unsigned int counter;
-	int handled = IRQ_NONE;
+	int ovf,  handled = IRQ_NONE;
 
 	if (cpu_has_mips_r2 && !(read_c0_cause() & (1 << 26)))
 		return handled;
@@ -251,12 +298,16 @@ static int mipsxx_perfcount_handler(void)
 #define HANDLE_COUNTER(n)						\
 	case n + 1:							\
 		control = r_c0_perfctrl ## n();				\
-		counter = r_c0_perfcntr ## n();				\
-		if ((control & M_PERFCTL_INTERRUPT_ENABLE) &&		\
-		    (counter & M_COUNTER_OVERFLOW)) {			\
-			oprofile_add_sample(get_irq_regs(), n);		\
-			w_c0_perfcntr ## n(reg.counter[n]);		\
-			handled = IRQ_HANDLED;				\
+		if (control & M_PERFCTL_INTERRUPT_ENABLE) {		\
+			if (cpu_has_64bit_perfcntr())			\
+				ovf = (((r_c0_perfcntr ## n ## _64()) & M_COUNTER_OVERFLOW_64) >> 63);\
+			else						\
+				ovf = r_c0_perfcntr ## n() & M_COUNTER_OVERFLOW;\
+			if (ovf) {					\
+				oprofile_add_sample(get_irq_regs(), n);	\
+				setup_c0_perfcntr(n);			\
+				handled = IRQ_HANDLED;			\
+			}						\
 		}
 	HANDLE_COUNTER(3)
 	HANDLE_COUNTER(2)
@@ -330,7 +381,7 @@ static irqreturn_t mipsxx_perfcount_int(int irq, void *dev_id)
 
 static int __init mipsxx_init(void)
 {
-	int counters;
+	int counters, perfirq;
 
 	counters = n_counters();
 	if (counters == 0) {
@@ -401,6 +452,10 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx_ops.cpu_type = "mips/loongson1";
 		break;
 
+	 case CPU_XLP:
+		op_model_mipsxx_ops.cpu_type = "mips/xlp";
+		break;
+
 	case CPU_XLR:
 		op_model_mipsxx_ops.cpu_type = "mips/xlr";
 		break;
@@ -411,12 +466,15 @@ static int __init mipsxx_init(void)
 		return -ENODEV;
 	}
 
-	save_perf_irq = perf_irq;
-	perf_irq = mipsxx_perfcount_handler;
-
-	if ((cp0_perfcount_irq >= 0) && (cp0_compare_irq != cp0_perfcount_irq))
-		return request_irq(cp0_perfcount_irq, mipsxx_perfcount_int,
-			0, "Perfcounter", save_perf_irq);
+	if (cpu_has_mips_r2) {
+		perfirq = MIPS_CPU_IRQ_BASE + cp0_perfcount_irq;
+		if (request_irq(perfirq, mipsxx_perfcount_int,
+				IRQF_PERCPU, "mips_oprofile", NULL))
+			printk(KERN_ERR "Unable to request IRQ%d for MIPS", perfirq);
+	} else {
+		save_perf_irq = perf_irq;
+		perf_irq = mipsxx_perfcount_handler;
+	}
 
 	return 0;
 }
@@ -425,13 +483,13 @@ static void mipsxx_exit(void)
 {
 	int counters = op_model_mipsxx_ops.num_counters;
 
-	if ((cp0_perfcount_irq >= 0) && (cp0_compare_irq != cp0_perfcount_irq))
-		free_irq(cp0_perfcount_irq, save_perf_irq);
-
 	counters = counters_per_cpu_to_total(counters);
 	on_each_cpu(reset_counters, (void *)(long)counters, 1);
 
-	perf_irq = save_perf_irq;
+	if (cpu_has_mips_r2)
+		free_irq(MIPS_CPU_IRQ_BASE + cp0_perfcount_irq, NULL);
+	else
+		perf_irq = save_perf_irq;
 }
 
 struct op_mips_model op_model_mipsxx_ops = {
-- 
1.9.1

