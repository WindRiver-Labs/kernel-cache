From 70a902b327b487c077c1f51a799291a2e3556841 Mon Sep 17 00:00:00 2001
From: Li Zhou <li.zhou@windriver.com>
Date: Thu, 16 Apr 2015 10:26:29 +0800
Subject: [PATCH] mtd/nand/xlp_nand: move init_completion to protect
 completion data between cpus

When flash_erase task is running, it sometimes will be scheduled to
different cpu from the cpu on which the interrupt thread runs.
While both flash_erase task and interrupt thread will operate on the
completion data. Sometimes conflict occurs and causes "spinlock
 wrong owner" or "spinlock already unlocked" error.

Move init_completion from cmdfunc to driver probe function to avoid
flash_erase task initializes the completion data while the interrupt is
using it.

Why not simply protect the initialization with a spinlock_irqsave ?
->This way should work, but it is not as good as just moving the init.
No need to initialize the completion every time nand command is sent to
driver after checking about how the completion is used.

Why not alternatively disable migration when the command is running to
prevent the thread from being migrated/scheduled to another cpu ?
->There should be more tasks other than flash_erase to use xlp_nand
functions. It is hard to find them all.

Signed-off-by: Li Zhou <li.zhou@windriver.com>
---
 drivers/mtd/nand/xlp_nand.c |    3 +--
 1 files changed, 1 insertions(+), 2 deletions(-)

diff --git a/drivers/mtd/nand/xlp_nand.c b/drivers/mtd/nand/xlp_nand.c
index a7acbe9..dd8c214 100644
--- a/drivers/mtd/nand/xlp_nand.c
+++ b/drivers/mtd/nand/xlp_nand.c
@@ -449,8 +449,6 @@ static void xlp_nand_cmdfunc(struct mtd_info *mtd,
 	struct xlp_nand_data *data = container_of(mtd,
 					struct xlp_nand_data, mtd);
 
-	init_completion(&data->cmd_complete);
-
 	if (state->cs < 0)
 		return;
 
@@ -774,6 +772,7 @@ static int of_xlp_nand_devices(void __iomem *io_base,
 		dev_err(&pdev->dev, "request_irq failed!!\n");
 		return ret;
 	}
+	init_completion(&data->cmd_complete);
 
 	platform_set_drvdata(pdev, data);
 
-- 
1.7.5.4

