From 3f2dd95a0fd02a1c178ff71fa55a67d675104592 Mon Sep 17 00:00:00 2001
From: Sandip Matte <sandipm@broadcom.com>
Date: Tue, 17 Sep 2013 17:10:46 +0530
Subject: [PATCH 1513/1532] sae_module: Get hw crypto algos working with seclib
 on xlp9xx 1. All authentication only algos working. 2. All encryption only
 algos working. 3. All AEAD algos except gcm, ccm working.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/crypto/sae/nlm_aead.c | 113 ++++++++++++++++++++++++++++++------------
 drivers/crypto/sae/nlm_auth.c |   8 +--
 drivers/crypto/sae/nlm_enc.c  |   6 +--
 3 files changed, 87 insertions(+), 40 deletions(-)

diff --git a/drivers/crypto/sae/nlm_aead.c b/drivers/crypto/sae/nlm_aead.c
index a8a1506..d473ffa 100755
--- a/drivers/crypto/sae/nlm_aead.c
+++ b/drivers/crypto/sae/nlm_aead.c
@@ -304,15 +304,18 @@ static int xlp_aes_cbc_setkey( struct crypto_aead *tfm, uint8_t *key, unsigned i
 	initp->cipher.flags = SAESOC_CF_ENCRYPT;
 	initp->hash.type = hash_type;
 	initp->hash.mode = hash_mode;
-	initp->hash.iv_offset = 8;
+	initp->hash.iv_offset = 0;
 	initp->hash.key = auth_key;
 	initp->hash.key_len = auth_keylen;
 	initp->hash.mute_mask_sel = 0;
 	initp->hash.tag_len = saesoc_gen1_tag_len[hash_type] / 8;
 	initp->hash.tagin_offset = 0;
 	initp->hash.aad_offset = 0;
-	initp->hash.addl_hash_len = 16; /* iv len */ 
+	initp->hash.addl_hash_len = 0; /* iv len */ 
+	//initp->hash.add_len = 24; /* iv len */ 
 	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC | SAESOC_HF_HASHINP_IS_CIPHEROUT;
+	if (initp->hash.mode == SAESOC_HASH_MODE_HMAC)
+		initp->hash.flags |= SAESOC_HF_HMAC_KEY_PAD_EN;
 	initp->payload_offset = 8 + 16 ; /* assoc len + ivlen */
 	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
 
@@ -325,6 +328,8 @@ static int xlp_aes_cbc_setkey( struct crypto_aead *tfm, uint8_t *key, unsigned i
 
 	initp->cipher.flags = 0;
 	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC; 
+	if (initp->hash.mode == SAESOC_HASH_MODE_HMAC)
+		initp->hash.flags |= SAESOC_HF_HMAC_KEY_PAD_EN;
 
 	s_desc = &ctx->dec_s_desc;
 
@@ -379,15 +384,17 @@ static int  xlp_3des_setkey(struct crypto_aead *tfm, u8 *key, unsigned int keyle
 	initp->cipher.flags = SAESOC_CF_ENCRYPT;
 	initp->hash.type = hash_type;
 	initp->hash.mode = hash_mode;
-	initp->hash.iv_offset = 8;
+	initp->hash.iv_offset = 0;
 	initp->hash.key = auth_key;
 	initp->hash.key_len = auth_keylen;
 	initp->hash.mute_mask_sel = 0;
 	initp->hash.tag_len = saesoc_gen1_tag_len[hash_type] / 8;
 	initp->hash.tagin_offset = 0;
 	initp->hash.aad_offset = 0;
-	initp->hash.addl_hash_len = 8; /* iv len */ 
+	initp->hash.addl_hash_len = 0; /* iv len */ 
 	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC | SAESOC_HF_HASHINP_IS_CIPHEROUT;
+	if (initp->hash.mode == SAESOC_HASH_MODE_HMAC)
+		initp->hash.flags |= SAESOC_HF_HMAC_KEY_PAD_EN;
 	initp->payload_offset = 8 + 8 ; /* assoc len + ivlen */
 	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
 
@@ -400,6 +407,8 @@ static int  xlp_3des_setkey(struct crypto_aead *tfm, u8 *key, unsigned int keyle
 
 	initp->cipher.flags = 0;
 	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC; 
+	if (initp->hash.mode == SAESOC_HASH_MODE_HMAC)
+		initp->hash.flags |= SAESOC_HF_HMAC_KEY_PAD_EN;
 
 	s_desc = &ctx->dec_s_desc;
 
@@ -455,15 +464,17 @@ static int xlp_des_setkey( struct crypto_aead *tfm, uint8_t  *key, unsigned int
 	initp->cipher.flags = SAESOC_CF_ENCRYPT;
 	initp->hash.type = hash_type;
 	initp->hash.mode = hash_mode;
-	initp->hash.iv_offset = 8;
+	initp->hash.iv_offset = 0;
 	initp->hash.key = auth_key;
 	initp->hash.key_len = auth_keylen;
 	initp->hash.mute_mask_sel = 0;
 	initp->hash.tag_len = saesoc_gen1_tag_len[hash_type] / 8;
 	initp->hash.tagin_offset = 0;
 	initp->hash.aad_offset = 0;
-	initp->hash.addl_hash_len = 8; /* iv len */ 
+	initp->hash.addl_hash_len = 0; /* iv len */ 
 	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC | SAESOC_HF_HASHINP_IS_CIPHEROUT;
+	if (initp->hash.mode == SAESOC_HASH_MODE_HMAC)
+		initp->hash.flags |= SAESOC_HF_HMAC_KEY_PAD_EN;
 	initp->payload_offset = 8 + 8 ; /* assoc len + ivlen */
 	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
 
@@ -475,6 +486,8 @@ static int xlp_des_setkey( struct crypto_aead *tfm, uint8_t  *key, unsigned int
 
 	initp->cipher.flags = 0;
 	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC; 
+	if (initp->hash.mode == SAESOC_HASH_MODE_HMAC)
+		initp->hash.flags |= SAESOC_HF_HMAC_KEY_PAD_EN;
 
 	s_desc = &ctx->dec_s_desc;
 
@@ -485,6 +498,7 @@ static int xlp_des_setkey( struct crypto_aead *tfm, uint8_t  *key, unsigned int
 
 
 }
+extern struct cryptosoc_lib_params lparam;
 static int aead_gcm_rfc4106_setkey( struct crypto_aead *tfm, const u8 *key,
 						unsigned int keylen)
 {
@@ -547,6 +561,9 @@ static int aead_gcm_rfc4106_setkey( struct crypto_aead *tfm, const u8 *key,
 	nsdescs = saesoc_calc_sdesc_cnt(&ctx->initp,NULL);
 	s_desc = &ctx->enc_s_desc;
 
+	if (lparam.saesoc_feature_set & SAESOC_FF_EXPLICIT_IV_SUPPORT) {
+		initp->hash.flags |= SAESOC_HF_TAGOUT_EOP;
+	}
 
 
 	if(saesoc_new_session(&ctx->initp,&s_desc,nsdescs, NULL) < 0)
@@ -584,15 +601,14 @@ static int aead_ccm_rfc4309_setkey(struct crypto_aead *tfm, const u8 *key,
 
 	cipher_keylen = keylen - nonce_len;
 	cipher_alg = get_cipher_aes_algid(cipher_keylen);
-	ctx->stat = cipher_alg - 1;
-	ctx->stat = ctx->stat | (CCM_STAT << 8);
-
-	cipher_alg = get_cipher_aes_algid(cipher_keylen);
 	if (cipher_alg < 0) {
 		crypto_aead_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
 		printk("ERR: Bad aes key len\n");
 		return -EINVAL;
 	}
+	ctx->stat = cipher_alg - 1;
+	ctx->stat = ctx->stat | (CCM_STAT << 8);
+
 	auth_alg = get_auth_aes_algid(cipher_keylen);
 	if ( auth_alg < 0) {
 		crypto_aead_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
@@ -600,8 +616,6 @@ static int aead_ccm_rfc4309_setkey(struct crypto_aead *tfm, const u8 *key,
 		return -EINVAL;
 	}
 	
-
-	
 	ctx->iv_len = 8;
 
 	/* | en_iv| auth_iv |[2byte for assoc len storage] | assoc [blcok aligned with zero | 
@@ -619,18 +633,23 @@ static int aead_ccm_rfc4309_setkey(struct crypto_aead *tfm, const u8 *key,
 	initp->cipher.flags = SAESOC_CF_ENCRYPT;
 	initp->hash.type = auth_alg;
 	initp->hash.mode = SAESOC_HASH_MODE_CCM;
-	initp->hash.iv_offset = 0;
+	initp->hash.iv_offset = 16;
 	initp->hash.key = (char *)key;
 	initp->hash.key_len = cipher_keylen;
 	initp->hash.mute_mask_sel = 0;
 	initp->hash.tag_len = 128 / 8;
 	initp->hash.tagin_offset = 0;
-	initp->hash.aad_offset = 16; /* auth offset */
-	initp->hash.addl_hash_len = 16; 
+	initp->hash.addl_hash_len = 0; 
 	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC;
 	initp->payload_offset = 16 + 16 + 16; /* env IV, auth IV, 2 extra for assoc len storage + assoc + zero*/
 	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
 
+	initp->hash.aad_offset = 32; /* auth offset */
+	if (lparam.saesoc_feature_set & SAESOC_FF_EXPLICIT_IV_SUPPORT) {
+		initp->hash.flags |= SAESOC_HF_TAGOUT_EOP;
+		initp->hash.aad_offset = 34; /* auth offset */
+	}
+
 	nsdescs = saesoc_calc_sdesc_cnt(&ctx->initp,NULL);
 	s_desc = &ctx->enc_s_desc;
 
@@ -640,6 +659,10 @@ static int aead_ccm_rfc4309_setkey(struct crypto_aead *tfm, const u8 *key,
 	initp->cipher.flags = 0;
 	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC | SAESOC_HF_HASHINP_IS_CIPHEROUT;
 
+	if (lparam.saesoc_feature_set & SAESOC_FF_EXPLICIT_IV_SUPPORT) {
+		initp->hash.flags |= SAESOC_HF_TAGOUT_EOP;
+	}
+
 	s_desc = &ctx->dec_s_desc;
 
 	if(saesoc_new_session(&ctx->initp,&s_desc,nsdescs, NULL) < 0)
@@ -700,6 +723,12 @@ static int xlp_aes_ctr_setkey( struct crypto_aead *tfm, u8 *key,
 	      |----auth offset
 	                                         |--> cipher offset */ 
 
+	//TODO: We can give IV in packet descriptor if that feature is enabled
+	//in chip... Might improve performance.
+	if (lparam.saesoc_feature_set & SAESOC_FF_EXPLICIT_IV_SUPPORT) {
+		//initp->hash.iv_mode = SAESOC_IV_FROM_PKT_DESC;
+		//initp->cipher.iv_mode = SAESOC_IV_FROM_PKT_DESC;
+	}
 	initp->cipher.type = cipher_alg;
         initp->cipher.mode = SAESOC_CIPHER_MODE_CTR;	
 	initp->cipher.iv_offset = 0;
@@ -717,8 +746,11 @@ static int xlp_aes_ctr_setkey( struct crypto_aead *tfm, u8 *key,
 	initp->hash.tag_len = saesoc_gen1_tag_len[hash_type] / 8;
 	initp->hash.tagin_offset = 0;
 	initp->hash.aad_offset = CTR_RFC3686_BLOCK_SIZE;
-	initp->hash.addl_hash_len =  CTR_RFC3686_IV_SIZE; /* iv len */ 
+	//initp->hash.addl_hash_len =  CTR_RFC3686_IV_SIZE; /* iv len */ 
+	initp->hash.addl_hash_len =  0; /* iv len */ 
 	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC | SAESOC_HF_HASHINP_IS_CIPHEROUT;
+	if (initp->hash.mode == SAESOC_HASH_MODE_HMAC)
+		initp->hash.flags |= SAESOC_HF_HMAC_KEY_PAD_EN;
 	initp->payload_offset = CTR_RFC3686_BLOCK_SIZE + 8 + CTR_RFC3686_IV_SIZE;  
 	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
 
@@ -730,6 +762,8 @@ static int xlp_aes_ctr_setkey( struct crypto_aead *tfm, u8 *key,
 
 	initp->cipher.flags = 0;
 	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC;
+	if (initp->hash.mode == SAESOC_HASH_MODE_HMAC)
+		initp->hash.flags |= SAESOC_HF_HMAC_KEY_PAD_EN;
 
 	s_desc = &ctx->dec_s_desc;
 
@@ -742,13 +776,13 @@ static int xlp_aes_ctr_setkey( struct crypto_aead *tfm, u8 *key,
 }
 static int xlp_aes_cbc_hmac_sha256_setkey( struct crypto_aead *tfm, const u8 *key, unsigned int keylen)
 {
-	return xlp_aes_cbc_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_SHA_256,0,H_SHA256_STAT,64);
+	return xlp_aes_cbc_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_SHA_256, SAESOC_HASH_MODE_HMAC ,H_SHA256_STAT,64);
 
 }
 
 static int xlp_aes_cbc_hmac_sha1_setkey(struct crypto_aead *tfm, const u8 *key, unsigned int keylen)
 {
-	return xlp_aes_cbc_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_SHA_1,0,H_SHA1_STAT,64);
+	return xlp_aes_cbc_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_SHA_1, SAESOC_HASH_MODE_HMAC,H_SHA1_STAT,64);
 }
 
 static int xlp_aes_cbc_aes_xcbc_mac_setkey(struct crypto_aead *tfm, const u8 *key, unsigned int keylen)
@@ -758,19 +792,19 @@ static int xlp_aes_cbc_aes_xcbc_mac_setkey(struct crypto_aead *tfm, const u8 *ke
 
 static int xlp_aes_cbc_hmac_md5_setkey(struct crypto_aead *tfm, const u8 *key, unsigned int keylen)
 {
-	return xlp_aes_cbc_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_MD5,0,MD5_STAT,64);
+	return xlp_aes_cbc_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_MD5, SAESOC_HASH_MODE_HMAC ,MD5_STAT,64);
 }
 
 static int xlp_3des_cbc_hmac_sha256_setkey(struct crypto_aead *tfm, const u8 *key,
                                         unsigned int keylen)
 {
-	return xlp_3des_setkey(tfm,(uint8_t *)key,keylen,SAESOC_HASH_TYPE_SHA_256,0,H_SHA256_STAT,64);
+	return xlp_3des_setkey(tfm,(uint8_t *)key,keylen,SAESOC_HASH_TYPE_SHA_256, SAESOC_HASH_MODE_HMAC ,H_SHA256_STAT,64);
         
 }
 static int xlp_3des_cbc_hmac_sha1_setkey(struct crypto_aead *tfm, const u8 *key,
                                         unsigned int keylen)
 {
-	return xlp_3des_setkey(tfm,(uint8_t *)key,keylen,SAESOC_HASH_TYPE_SHA_1,0,H_SHA1_STAT,64);
+	return xlp_3des_setkey(tfm,(uint8_t *)key,keylen,SAESOC_HASH_TYPE_SHA_1, SAESOC_HASH_MODE_HMAC,H_SHA1_STAT,64);
 }
 static int xlp_3des_cbc_aes_xcbc_mac_setkey(struct crypto_aead *tfm, const u8 *key,
                                         unsigned int keylen)
@@ -781,19 +815,19 @@ static int xlp_3des_cbc_aes_xcbc_mac_setkey(struct crypto_aead *tfm, const u8 *k
 static int xlp_3des_cbc_hmac_md5_setkey(struct crypto_aead *tfm, const u8 *key,
                                         unsigned int keylen)
 {
-	return xlp_3des_setkey(tfm,(uint8_t *)key,keylen,SAESOC_HASH_TYPE_MD5,0,MD5_STAT,64);
+	return xlp_3des_setkey(tfm,(uint8_t *)key,keylen,SAESOC_HASH_TYPE_MD5, SAESOC_HASH_MODE_HMAC,MD5_STAT,64);
 
 }
 static int xlp_des_cbc_hmac_sha1_setkey(struct crypto_aead *tfm, const u8 *key,
 						 unsigned int keylen)
 {
-	return xlp_des_setkey(tfm,(uint8_t *)key,keylen, SAESOC_HASH_TYPE_SHA_1,0,H_SHA1_STAT,64);
+	return xlp_des_setkey(tfm,(uint8_t *)key,keylen, SAESOC_HASH_TYPE_SHA_1, SAESOC_HASH_MODE_HMAC,H_SHA1_STAT,64);
 
 }
 static int xlp_des_cbc_hmac_sha256_setkey(struct crypto_aead *tfm, const u8 *key,
 							unsigned int keylen)
 {
-	return xlp_des_setkey(tfm,(uint8_t *)key,keylen, SAESOC_HASH_TYPE_SHA_256,0,H_SHA256_STAT,64);
+	return xlp_des_setkey(tfm,(uint8_t *)key,keylen, SAESOC_HASH_TYPE_SHA_256, SAESOC_HASH_MODE_HMAC,H_SHA256_STAT,64);
 
 }
 static int xlp_des_cbc_aes_xcbc_mac_setkey( struct crypto_aead *tfm, const u8 *key,
@@ -804,18 +838,18 @@ static int xlp_des_cbc_aes_xcbc_mac_setkey( struct crypto_aead *tfm, const u8 *k
 static int xlp_des_cbc_hmac_md5_setkey( struct crypto_aead *tfm, const u8 *key,
 						unsigned int keylen)
 {
-	return xlp_des_setkey(tfm,(uint8_t *)key,keylen,SAESOC_HASH_TYPE_MD5,0,MD5_STAT,64);
+	return xlp_des_setkey(tfm,(uint8_t *)key,keylen,SAESOC_HASH_TYPE_MD5, SAESOC_HASH_MODE_HMAC,MD5_STAT,64);
 
 }
 static  int xlp_aes_ctr_hmac_sha256_setkey ( struct crypto_aead *tfm, const u8 *key,
 					unsigned int keylen)
 {
-	return xlp_aes_ctr_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_SHA_256,0,H_SHA256_STAT,64);
+	return xlp_aes_ctr_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_SHA_256, SAESOC_HASH_MODE_HMAC,H_SHA256_STAT,64);
 }
 static  int xlp_aes_ctr_hmac_sha1_setkey ( struct crypto_aead *tfm, const u8 *key,
 					unsigned int keylen)
 {
-	return xlp_aes_ctr_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_SHA_1,0,H_SHA1_STAT,64);
+	return xlp_aes_ctr_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_SHA_1, SAESOC_HASH_MODE_HMAC ,H_SHA1_STAT,64);
 
 }
 static  int xlp_aes_ctr_aes_xcbc_mac_setkey ( struct crypto_aead *tfm, const u8 *key,
@@ -827,7 +861,7 @@ static  int xlp_aes_ctr_aes_xcbc_mac_setkey ( struct crypto_aead *tfm, const u8
 static int xlp_aes_ctr_hmac_md5_setkey(struct crypto_aead *tfm, const u8 *key,
 					unsigned int keylen)
 {
-	return xlp_aes_ctr_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_MD5,0,MD5_STAT,64);
+	return xlp_aes_ctr_setkey(tfm, (uint8_t *)key, keylen,SAESOC_HASH_TYPE_MD5,SAESOC_HASH_MODE_HMAC,MD5_STAT,64);
 }
 
 //returns nr_aad_frags... -1 for error
@@ -929,7 +963,7 @@ static int aead_crypt(struct aead_request *req, unsigned int op)
 
 	//check if it should be aip->tag_len or can be taken from tfm
 	cipher_len = op ? req->cryptlen:req->cryptlen - authsize;
-	saesoc_set_aad_len(d_desc,req->assoclen);
+	saesoc_set_aad_len(d_desc,req->assoclen + ivsize);
 	fill_aead_aad(d_desc, req, req->assoclen,0,max_frags);
 	if (ivsize) 
 		saesoc_add_frags(d_desc,req->iv,ivsize,req->iv,ivsize);
@@ -1090,6 +1124,7 @@ static int aead_crypt_ccm(struct aead_request *req, unsigned int op)
 	int node;
 	struct saesoc_extra_req_send_params mparam;
 	struct saesoc_session_desc *s_desc ;
+	uint8_t *last_dst;
 
 	hash_addr = (uint8_t *)NLM_HASH_OFFSET(aead_request_ctx(req));
 
@@ -1178,18 +1213,30 @@ static int aead_crypt_ccm(struct aead_request *req, unsigned int op)
 
 	auth_len = cipher_off + cipher_len + cipher_extralen - auth_off; 
 
-	d_desc= fill_src_dst_sg(s_desc,d_desc,async,req->src,req->dst,&max_frags,cipher_len);
-
 	cipher_extralen = cipher_len % 16;
 
+	d_desc= fill_src_dst_sg(s_desc,d_desc,async,req->src,req->dst,&max_frags,cipher_len);
+	last_dst = req->dst + cipher_len;
+
 	if ( cipher_extralen ) {
 		cipher_extralen = AES_BLOCK_SIZE - cipher_extralen;
 		memset(auth_iv + 38,0,cipher_extralen);
 		saesoc_add_frags(d_desc,(auth_iv+38),cipher_extralen,(auth_iv+38),cipher_extralen);
+		last_dst = auth_iv + 38 + cipher_extralen;
+	}
+
+	if (lparam.saesoc_feature_set & SAESOC_FF_EXPLICIT_IV_SUPPORT) {
+		saesoc_add_frags(d_desc,last_dst,16,last_dst,16);
+		if (!op)
+			scatterwalk_map_and_copy(hash_addr, req->src, req->cryptlen-authsize, authsize, 0);
 	}
 
 	/* add all those extra bytes for auth excluding assoc */
-	saesoc_set_aad_len(d_desc,req->assoclen + cipher_extralen +  2 + 6);
+	
+	saesoc_set_aad_len(d_desc,req->assoclen + cipher_extralen +  2 + 6 );
+	if (lparam.saesoc_feature_set & SAESOC_FF_EXPLICIT_IV_SUPPORT) {
+		saesoc_set_aad_len(d_desc,req->assoclen);
+	}
 
 	saesoc_set_payload_len(d_desc,cipher_len);
 	saesoc_set_tag_dstaddr(d_desc,hash_addr);
@@ -1275,7 +1322,7 @@ static int aead_crypt_ctr(struct aead_request *req, unsigned int op)
 	cipher_len = op ? req->cryptlen:req->cryptlen - authsize;
 
 	saesoc_add_frags(d_desc,iv,CTR_RFC3686_BLOCK_SIZE,iv,CTR_RFC3686_BLOCK_SIZE);
-	saesoc_set_aad_len(d_desc,req->assoclen);
+	saesoc_set_aad_len(d_desc,req->assoclen + CTR_RFC3686_IV_SIZE);
 	fill_aead_aad(d_desc, req, req->assoclen,0,max_frags);
 
 	saesoc_add_frags(d_desc,iv + CTR_RFC3686_NONCE_SIZE,ivsize,iv+CTR_RFC3686_NONCE_SIZE,ivsize);
diff --git a/drivers/crypto/sae/nlm_auth.c b/drivers/crypto/sae/nlm_auth.c
index 6cc06b0..40b147d 100644
--- a/drivers/crypto/sae/nlm_auth.c
+++ b/drivers/crypto/sae/nlm_auth.c
@@ -307,15 +307,13 @@ int hash_key(int type, int mode, const uint8_t * key, unsigned int keylen, uint8
 	initp.hash.flags = SAESOC_HF_HASH_L3_ALLOC;
 	initp.payload_offset = 0;
 	initp.flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
+	initp.flags |= SAESOC_HF_HMAC_KEY_PAD_EN;
 
 	nsdescs = saesoc_calc_sdesc_cnt(&initp,NULL);
 	tmp = kmalloc(  sizeof(struct saesoc_session_desc) + (nsdescs * sizeof(_uint64_t))+ 64 + sizeof(struct saesoc_data_desc) + (6 * sizeof(_uint64_t) + 64 + keylen),GFP_KERNEL );
 	s_desc = (struct saesoc_session_desc *)(((unsigned long )tmp + 64UL ) &  ~(0x3fUL));
 	d_desc = (struct saesoc_data_desc    *)(((unsigned long )s_desc + sizeof(struct saesoc_session_desc) + (nsdescs * sizeof(_uint64_t)) + 64UL) & ~(0x3fUL));
 
-	if(saesoc_new_session(&initp,&s_desc,nsdescs, NULL) < 0) 
-		printk("%s,%d Error \n", __FUNCTION__, __LINE__);
-
 	if(saesoc_new_session(&initp,&s_desc,nsdescs, NULL) < 0)
 		printk("%s,%d Error \n", __FUNCTION__, __LINE__);
 
@@ -383,7 +381,7 @@ static int auth_setkey(struct crypto_ahash *tfm, const u8 * key, unsigned int ke
 	initp->cipher.type = SAESOC_CIPHER_BYPASS;
 	initp->cipher.key_len = 0;
 	initp->hash.type = type;
-	initp->hash.mode = 0;
+	initp->hash.mode = SAESOC_HASH_MODE_HMAC;
 	initp->hash.iv_offset = 0;
 	initp->hash.mute_mask_sel = 0;
 	initp->hash.tag_len = saesoc_gen1_tag_len[type] / 8;
@@ -391,6 +389,8 @@ static int auth_setkey(struct crypto_ahash *tfm, const u8 * key, unsigned int ke
 	initp->hash.aad_offset =0;
 	initp->hash.addl_hash_len = 0;
 	initp->hash.flags = SAESOC_HF_HASH_L3_ALLOC;
+	initp->hash.key_len = blocksize;
+	initp->hash.flags |= SAESOC_HF_HMAC_KEY_PAD_EN;
 	initp->payload_offset = 0;
 	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
 
diff --git a/drivers/crypto/sae/nlm_enc.c b/drivers/crypto/sae/nlm_enc.c
index 602ba54..0afefb1 100755
--- a/drivers/crypto/sae/nlm_enc.c
+++ b/drivers/crypto/sae/nlm_enc.c
@@ -111,7 +111,7 @@ xlp_des3_setkey(struct crypto_ablkcipher *tfm, const u8 * in_key, unsigned int l
 	initp->hash.type = SAESOC_HASH_BYPASS;
 	initp->hash.key_len = 0;
 	initp->payload_offset = DES_BLOCK_SIZE; 
-	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC | SAESOC_IF_DATA_OUT_CLOBBER;
+	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
 
 	switch (len) {
 	case DES3_EDE_KEY_SIZE:
@@ -144,7 +144,7 @@ xlp_des_setkey(struct crypto_ablkcipher *tfm, const u8 * in_key, unsigned int le
 	initp->hash.type = SAESOC_HASH_BYPASS;
 	initp->hash.key_len = 0;
 	initp->payload_offset = DES_BLOCK_SIZE; 
-	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC | SAESOC_IF_DATA_OUT_CLOBBER;
+	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
 
 	switch (len) {
 	case DES_KEY_SIZE:
@@ -178,7 +178,7 @@ xlp_aes_setkey(struct crypto_ablkcipher *tfm, const u8 *in_key,
 	initp->hash.type = SAESOC_HASH_BYPASS;
 	initp->hash.key_len = 0;
 	initp->payload_offset = iv_size; 
-	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC | SAESOC_IF_DATA_OUT_CLOBBER;
+	initp->flags = SAESOC_IF_DATA_OUT_L3_ALLOC ;
 
 
 
-- 
1.9.1

