From 5f2936875e8f8dc8a48aac8c6194aff29dfd4fe3 Mon Sep 17 00:00:00 2001
From: Saswat Dash <saswat.dash@broadcom.com>
Date: Fri, 25 Oct 2013 21:11:15 +0530
Subject: [PATCH 0882/1532] NAE: Added nae-rx-cpu-mask extraction function

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/netlib/include/nlm_nae.h |  10 +++
 arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c  | 107 +++++++++++++++++++++---
 arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c |   1 -
 3 files changed, 104 insertions(+), 14 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
index d92bf98..18a854e 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -85,6 +85,10 @@
 #define NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_JF_OFF 16 //Jumbo fifo offset
 #define NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_JF_MASK 0xff
 
+#define ONLINEMASK_WORD_SIZE	80
+#define ONLINEMASK_PER_INDEX_SZ	8
+#define ONLINEMASK_INDEX_MASK	0xff
+#define ONLINEMASK_INDEX_NUM	4
 
 struct nlm_nae_shinfo {
 	int valid;
@@ -391,6 +395,10 @@ struct nlm_hal_nae_config {
 	of rx-fifos. */
 	uint32_t freein_fifo_dom_mask;
 
+	/* nae-rx-cpu-mask */
+	uint8_t nae_rx_cpu_mask[ONLINEMASK_WORD_SIZE];
+	int is_nae_rx_cpu_mask_set;
+
 	/* vfbtable id offset, software freeback and hardware freebaack */
 	uint32_t vfbtbl_sw_offset;
 	uint32_t vfbtbl_sw_nentries;
@@ -504,6 +512,8 @@ extern void nlm_hal_read_nae_ucore_sram_mem(int node, int ucoreid, unsigned int
 
 extern void nlm_hal_disable_xaui_flow_control(int node, int block);
 
+extern void nlm_hal_retrieve_nae_rx_cpu_mask(void *fdt, int dom_id, struct nlm_hal_nae_config *nae_cfg);
+
 typedef struct { uint32_t mask[24]; } cpu_mask_t;
 #endif
 #endif
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index 2e052ba..6aa533b 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -36,6 +36,7 @@
 #include <libfdt.h>
 #include <contrib/fdt_helper.h>
 
+/* #define NAE_RX_MASK_PRINT_DBG */
 #define NAE_SH_INFO_DBG
 #define UCORE_SRC_NODE(id) "/soc/nae-cfg/ucore/src@"#id
 
@@ -443,13 +444,26 @@ start_for_dom:
 		/* Ownes all fifos by default, only 1 entry is considered now */
         fifo_mask[node] = (1 << frin_total_queue) - 1;
 
-        sprintf(dom_node_str, "/doms/dom@%d/cpu", domid);
+	if (is_nlm_xlp9xx()) {
+		sprintf(dom_node_str, "/doms/dom@0/nae-%d", nae_cfg->nae_id);
+	} else {
+		sprintf(dom_node_str, "/doms/dom@%d/nae", domid);
+	}
         nodeoffset = fdt_path_offset(fdt, dom_node_str);
 
-        if(nodeoffset >= 0) {
-				int max;
-                pval = (unsigned int *)fdt_getprop(fdt, nodeoffset, "onlinemask", &plen);
-                if(pval != NULL) {
+	if (nodeoffset >= 0) {
+		pval = (unsigned int *)fdt_getprop(fdt, nodeoffset, "nae-rx-cpu-mask", &plen);
+	}
+        if ((nodeoffset < 0) || (!plen)) {
+		sprintf(dom_node_str, "/doms/dom@%d/cpu", domid);
+		nodeoffset = fdt_path_offset(fdt, dom_node_str);
+		if (nodeoffset >= 0) {
+                	pval = (unsigned int *)fdt_getprop(fdt, nodeoffset, "onlinemask", &plen);
+		}
+	}
+         if(pval != NULL) {
+					int max;
+
 					if(plen < ((max_cpu_idx + 1) * NLM_MAX_NODES * sizeof(unsigned int)))
 						max = (max_cpu_idx + 1) * NLM_MAX_NODES * sizeof(unsigned int);
 					else
@@ -466,14 +480,17 @@ start_for_dom:
 						cpu_mask[i] = fdt32_to_cpu(pval[max]);
 					right_shift_int_array(cpu_mask, node * num_cpus_per_node, num_cpus_per_node);
 				}
-                pval = (unsigned int *)fdt_getprop(fdt, nodeoffset, "nae-rx-vc", &plen);
-                if(pval)
-                        shinfo.rxvc = fdt32_to_cpu(pval[0]);
-                else {
-						netsoc_api_print(NETSOC_APIDBG_ERROR, "Error : nae-rx-vc get failed, plen %d\n", plen);
-                        goto err;
-				}
-        }
+		sprintf(dom_node_str, "/doms/dom@%d/cpu, domid");
+		nodeoffset = fdt_path_offset(fdt, dom_node_str);
+		if (nodeoffset >= 0) {
+             		pval = (unsigned int *)fdt_getprop(fdt, nodeoffset, "nae-rx-vc", &plen);
+                	if(pval)
+                        	shinfo.rxvc = fdt32_to_cpu(pval[0]);
+                	else {
+				netsoc_api_print(NETSOC_APIDBG_ERROR, "Error : nae-rx-vc get failed, plen %d\n", plen);
+                        	goto err;
+			}
+        	}
 
         /* Extract free in fifo mask mask */
         get_dom_nae_property(fdt, domid, nae_cfg->nae_id, "freein-fifo-mask", 
@@ -766,6 +783,7 @@ int fdt_parse_vfbid_config(void *fdt, nae_t *nae_cfg)
                 }
         }
 
+
         return 0;
 }
 
@@ -1498,6 +1516,67 @@ int fdt_get_nae_frindesc_mode(void *fdt, nae_t *nae)
         return 0;
 }
 
+void nlm_hal_retrieve_nae_rx_cpu_mask(void *fdt, int dom_id, nae_t *nae)
+{
+	
+	void *app_fdt;
+        char dom_node_str[32];
+        int node_offset;
+        unsigned int *parameter_val;
+        int parameter_len = 0;
+        int i = 0, j = 0;
+        uint32_t mask_word = 0;
+       	uint8_t sub_mask_word = 0;
+        int index = 0, bit_count = 0;
+	
+	app_fdt = fdt;
+	nae->is_nae_rx_cpu_mask_set = 0;
+
+ 	memset(nae->nae_rx_cpu_mask, 0, sizeof(uint8_t) * 80);
+	
+	if (is_nlm_xlp9xx()) {
+	        sprintf(dom_node_str, "/doms/dom@%d/nae-%d", dom_id, nae->nae_id);
+	} else {
+		sprintf(dom_node_str, "/doms/dom@%d/nae", dom_id);
+	}
+
+        node_offset = fdt_path_offset(app_fdt, dom_node_str);
+      
+	if (node_offset >= 0) {
+        	parameter_val = (unsigned int *)fdt_getprop(app_fdt, node_offset, "nae-rx-cpu-mask", &parameter_len);
+	
+                if (parameter_val != NULL) {
+			parameter_len /= sizeof(unsigned int);
+			if (parameter_len) {
+				nae->is_nae_rx_cpu_mask_set = 1;
+			}
+			
+			j = ONLINEMASK_WORD_SIZE - 1;
+
+			for (i = parameter_len - 1; i >= 0; i--) {
+				mask_word = fdt32_to_cpu(parameter_val[i]);
+	
+				for (index = 0; index < ONLINEMASK_INDEX_NUM; index++) {
+					sub_mask_word = (mask_word >> (index * ONLINEMASK_PER_INDEX_SZ)) & ONLINEMASK_INDEX_MASK;
+					nae->nae_rx_cpu_mask[j--] = sub_mask_word;
+					if (is_nlm_xlp9xx()) {
+						bit_count += ONLINEMASK_PER_INDEX_SZ;
+						if (bit_count >= XLP9XX_MAX_CPU_PER_NODE) {
+							bit_count = 0;
+							break;
+						}
+					}
+				}
+			}
+		}
+	}
+#ifdef NAE_RX_MASK_PRINT_DBG
+	netsoc_api_print(NETSOC_APIDBG_FDT, "nae_rx_cpu_mask :");
+	for (i = 0; i < ONLINEMASK_WORD_SIZE; i++) {
+		netsoc_api_print(NETSOC_APIDBG_FDT, "%x", nae->nae_rx_cpu_mask[i]);
+	}
+#endif
+}
 
 int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae)
 {
@@ -1545,6 +1624,8 @@ int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae)
               fdt_parse_freein_fifo_cfg(fdt, nae);
         }
 
+	nlm_hal_retrieve_nae_rx_cpu_mask(fdt, dom_id, nae);
+
 	fdt_parse_port_config(fdt, nae);
 	return 0;
 }
diff --git a/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c b/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
index f27ba3d..ced23a0 100644
--- a/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
@@ -6846,7 +6846,6 @@ unsigned int nlm_hal_retrieve_freein_fifo_mask(void *fdt, int node, int dom_id)
 
 	get_dom_nae_property(fdt, dom_id, "freein-fifo-mask", 
 			freein_fifo_mask, sizeof(freein_fifo_mask));
-
 	return freein_fifo_mask[node];
 }
 
-- 
1.9.1

