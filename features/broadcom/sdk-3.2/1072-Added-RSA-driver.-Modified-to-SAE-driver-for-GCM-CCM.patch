From d2c065a641ed16fb7c4d6615a5cf5fa36ee1bcf1 Mon Sep 17 00:00:00 2001
From: Alok Agrawat <aagrawat@netlogicmicro.com>
Date: Thu, 28 Jul 2011 18:57:03 +0530
Subject: [PATCH 1072/1532] - Added RSA driver. - Modified to SAE driver for
 GCM, CCM. - Fixed all open issues

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/misc/netlogic/nlm_rsa/Makefile       |   13 +
 drivers/misc/netlogic/nlm_rsa/nlm_rsa.c      | 1308 ++++++++++++++++++++++++++
 drivers/misc/netlogic/nlm_rsa/nlm_rsa.h      |   76 ++
 drivers/misc/netlogic/nlm_rsa/nlm_rsa_api.h  |   90 ++
 drivers/misc/netlogic/nlm_rsa/nlm_rsa_data.h |  158 ++++
 drivers/misc/netlogic/nlm_rsa/ucode_load.h   |  922 ++++++++++++++++++
 6 files changed, 2567 insertions(+)
 create mode 100644 drivers/misc/netlogic/nlm_rsa/Makefile
 create mode 100644 drivers/misc/netlogic/nlm_rsa/nlm_rsa.c
 create mode 100644 drivers/misc/netlogic/nlm_rsa/nlm_rsa.h
 create mode 100644 drivers/misc/netlogic/nlm_rsa/nlm_rsa_api.h
 create mode 100755 drivers/misc/netlogic/nlm_rsa/nlm_rsa_data.h
 create mode 100644 drivers/misc/netlogic/nlm_rsa/ucode_load.h

diff --git a/drivers/misc/netlogic/nlm_rsa/Makefile b/drivers/misc/netlogic/nlm_rsa/Makefile
new file mode 100644
index 0000000..9f50365
--- /dev/null
+++ b/drivers/misc/netlogic/nlm_rsa/Makefile
@@ -0,0 +1,13 @@
+
+################################################################################
+
+#
+# Makefile for xlp_rsa driver
+#
+
+#EXTRA_CFLAGS := -Werror
+EXTRA_CFLAGS := -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogic/hal
+EXTRA_CFLAGS += -Iarch/mips/netlogic/boot
+
+obj-m 		+= nlm_rsa.o
+#nae-objs 	:= nlm_rsa.c
diff --git a/drivers/misc/netlogic/nlm_rsa/nlm_rsa.c b/drivers/misc/netlogic/nlm_rsa/nlm_rsa.c
new file mode 100644
index 0000000..8c3cc61
--- /dev/null
+++ b/drivers/misc/netlogic/nlm_rsa/nlm_rsa.c
@@ -0,0 +1,1308 @@
+/*************************************************************************
+  Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+  reserved.
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are
+  met:
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+  THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NLMOGIC OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+ *******************************#NLM_2#**********************************/
+
+#include <linux/module.h>
+
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/errno.h>	/* for -EBUSY */
+#include <linux/ioport.h>	/* for request_region */
+#include <linux/delay.h>	/* for loops_per_jiffy */
+#include <linux/sched.h>
+#include <linux/smp_lock.h>	/* cycle_kernel_lock() */
+#include <asm/io.h>		/* for inb_p, outb_p, inb, outb, etc. */
+#include <asm/uaccess.h>	/* for get_user, etc. */
+#include <linux/init.h>		/* for __init, module_{init,exit} */
+#include <linux/poll.h>		/* for POLLIN, etc. */
+#include <asm/netlogic/msgring.h>
+#include <asm/mutex.h>
+
+#include <asm/netlogic/hal/nlm_hal_fmn.h>
+#include <asm/netlogic/hal/nlm_hal_macros.h>
+#include <asm/netlogic/hal/nlm_hal_rsa.h>
+
+#include "nlm_rsa.h"
+#include "nlm_rsa_api.h"
+#include "ucode_load.h"
+
+
+
+/**
+ * @file_name rsa.c
+ */
+/**
+ * @defgroup rsa Crypto API
+ * @brief Description about the rsa apis
+ */
+
+#define printf(a, b...) printk(KERN_ERR a, ##b)
+#define malloc(a) kmalloc(a, GFP_ATOMIC)
+#define free kfree
+
+#define HAS_REMINDER(x, y)  (((uint64_t)(x) & ((1ULL << (y)) - 1))?1:0)
+
+
+#define L3_CACHELINE_SIZE 64
+#define L3_CACHELINE_MASK 0x3fULL
+#define VC_MODE_ROUND_ROBIN 1
+#define NUM_VC 9
+#define NLM_RSA_VC_BASE 272
+
+#define CMD_RSA_ECC_POINT_MULTIPLICATION        0x1
+#define CMD_RSA_ECC_POINT_ADDITION              0x2
+#define CMD_RSA_ECC_POINT_DOUBLE                0x3
+#define CMD_RSA_ECC_POINT_VERIFICATION          0x4
+#define CMD_RSA_ECC_MODULAR_ADDITION            0x5
+#define CMD_RSA_ECC_MODULAR_SUBTRACTION         0x6
+#define CMD_RSA_ECC_MODULAR_MULTIPLICATION      0x7
+#define CMD_RSA_ECC_MODULAR_DIVISION            0x8
+#define CMD_RSA_ECC_MODULAR_INVERSION           0x9
+#define CMD_RSA_ECC_MODULAR_REDUCTION           0xa
+#define CMD_RSA_ME_MODULAR_EXPONENTIATION       0xb
+#define CMD_RSA_ME_MODULAR_MULTIPLICATION       0xc
+
+static int xlp_rsa_major;
+static int xlp_rsa_open(struct inode *, struct file *);
+static int xlp_rsa_release(struct inode *, struct file *);
+static int xlp_rsa_ioctl(struct inode *inode, struct file *fptr, unsigned int type, unsigned long val);
+
+struct semaphore sem;
+int flag = 0;
+struct dev_data {
+    void *rsa_vc;
+    int rsa_fb_vc_base;
+};
+
+static struct dev_data dd;
+
+uint64_t src_data[] = {
+    0x96f8aedd37e66ffdULL,
+    0x4164d176953045fbULL,
+    0x143e85ef652e4c17ULL,
+    0xce8a1bf99f8bdddbULL,
+    0xcf7a241aef8068a8ULL,
+    0xd048c2bb35409ac1ULL,
+    0x59eea204e49e7307ULL,
+    0x0abb6dbdc69dd25fULL,
+    0xced2fe6e1aee87ebULL,
+    0x69ddf39bf7647c34ULL,
+    0xf36b29dd40bc0af6ULL,
+    0x589581e0af45b44cULL,
+    0x7141ddd7c6a88a2cULL,
+    0x70dc3ab93faad3dbULL,
+    0xa7ce476812f1c993ULL,
+    0xebf9fb54ff98df6aULL,
+    0x919545cf6e40a7dbULL,
+    0x4b3680fa4e29b226ULL,
+    0xd2ddae2612a3a750ULL,
+    0x483d3f2035492c78ULL,
+    0x764b95f2b249d6a1ULL,
+    0x0551b37a66fa61daULL,
+    0x18893c2013a52658ULL,
+    0xba1f069ebb913b65ULL,
+};
+
+uint64_t dst_data[32];
+
+uint64_t exp_dst_data[] = {
+    0x5e6635ecc12b6fe2ULL,
+    0x1c7ee5c7151493ffULL,
+    0x780801153e8c80b3ULL,
+    0x05a77b6cadabfca5ULL,
+    0xc273c8f98316959bULL,
+    0x287bb43eb8f95b0bULL,
+    0xb73d4aa67ba768c7ULL,
+    0x2ed7083365326a10ULL,
+};
+
+int dword_data_copy(uint64_t *dst, uint64_t *src, int len, int dlen)
+{
+    int idx = len >> 3;
+    int dword_size, i, ret = (idx + HAS_REMINDER(len, 3));
+    char *tmp;
+
+    if(len & 0x7) {
+	tmp = (char *)(dst + idx);
+	tmp += (8 - (len & 0x7));
+	memcpy(tmp, src, (len & 0x7));
+
+	tmp = (char *)src;
+	src = (uint64_t *)(tmp + (len & 0x7));
+    }
+
+    dword_size = idx;
+    idx --;
+
+    for(i = 0; i < dword_size; ++i) {
+	dst[idx--] = src[i];
+    }
+
+    if(ret < dlen) {
+	ret = dlen;
+    }
+
+    return ret;
+}
+
+#ifdef RSA_DEBUG
+static void dump_buffer(unsigned char *buf, unsigned int len, unsigned char *msg)
+{
+    int k = 0;
+    printk("\n %s", msg);
+    for(k = 0; k < len; k++)
+    {
+	printk(" %.2x",buf[k]);
+	if((k+1) % 16 == 0)
+	    printk("\n");
+    }
+    printk("\n");
+}
+#endif
+
+static void *
+get_cache_aligned_mem(size_t size)
+{
+    void *addr, **tmp;
+    unsigned long loc;
+    addr = malloc(size + L3_CACHELINE_SIZE * 2);
+
+    if (addr == NULL) {
+	printk(KERN_ERR
+		"\n Malloc failed for cache aligned memory allocation");
+	return NULL;    //NLM_ERR_NO_MEM;
+    }
+    loc = (unsigned long) addr;
+    loc = (loc + L3_CACHELINE_SIZE - 1) & ~L3_CACHELINE_MASK;
+
+    tmp = (void **) loc;
+
+    *tmp = addr;
+
+    loc += L3_CACHELINE_SIZE;
+
+    addr = (void *) loc;
+
+    return addr;
+}
+
+static void
+free_cache_aligned_mem(void *addr)
+{
+    unsigned long loc;
+
+    loc = (unsigned long) addr;
+
+    loc -= 64;
+
+    addr = (void *) loc;
+
+    addr = (void *) *(unsigned long *) addr;
+
+    free(addr);
+}
+
+
+static void
+init_rsa_vc(void)
+{
+    dd.rsa_fb_vc_base = 3;
+}
+
+
+static int
+rsa_get_vc(void)
+{
+    return NLM_RSA_VC_BASE;
+}
+
+static int
+rsa_get_fb_vc(void)
+{
+    int vc, cpu;
+
+    vc = dd.rsa_fb_vc_base;
+
+    cpu = hard_smp_processor_id();
+    cpu = cpu * 4 + vc;
+    return cpu;
+}
+
+/****************** Validate input, fill fields, alloc mem***************************/
+
+static int
+rsa_fb_msg_print_err(uint64_t msg)
+{
+    uint32_t err, ret = 0;
+    err = (uint32_t) (msg >> 32) & 0xFFFFFFFF;
+    if (err & NLM_RSA_FB_ERR_MASK)
+	printf("\nERROR: Security Freeback Data Error: ");
+    else
+	return ret;
+
+    if (err & NLM_RSA_FB_BIU_TIMEOUT_ERR) {
+	ret |= NLM_RSA_FB_BIU_TIMEOUT_ERR;
+	printf("        BIU timeout error \n");
+    }
+    if (err & NLM_RSA_FB_MICROCODE_ERR) {
+	ret |= NLM_RSA_FB_MICROCODE_ERR;
+	printf("        Microcode error \n");
+    }
+    if (err & NLM_RSA_FB_MEMORY_READ_ERR) {
+	ret |= NLM_RSA_FB_MEMORY_READ_ERR;
+	printf("        Memory read error \n");
+    }
+    if (err & NLM_RSA_FB_UNDEFINED_TYPE_ERR) {
+	ret |= NLM_RSA_FB_UNDEFINED_TYPE_ERR;
+	printf("        Undefined Type error \n");
+    }
+    if (err & NLM_RSA_FB_UNDEFINED_FUNCTION_ERR) {
+	ret |= NLM_RSA_FB_UNDEFINED_FUNCTION_ERR;
+	printf("        Undefined Function Error \n");
+    }
+    return ret;
+}
+
+uint64_t nlm_err_msg = 0, nlm_tx_id = 0;
+uint32_t nlm_fb_vc = 0;
+int wait_for_freeback(uint64_t tx_id, uint32_t rx_vc)
+{
+    uint64_t err_msg;
+    int i = 0, ret = 0;
+    while (!nlm_err_msg && (tx_id != nlm_hal_rsa_receive_response(rx_vc, &err_msg))
+	    && i < 100)
+    {
+	i++;
+    }
+    nlm_err_msg = 0;
+    if (i < 100)
+	ret = rsa_fb_msg_print_err(err_msg);
+    else
+    {
+	ret = NLM_ERR_FREEBACK_NOT_RECEIVED;
+	printf("\n Error _ FreeBack message is not received");
+    }
+    return ret;
+}
+
+static void
+nlm_xlp_rsa_msgring_handler(uint32_t vc, uint32_t src_id,
+	uint32_t size, uint32_t code,
+	uint64_t msg0, uint64_t msg1,
+	uint64_t msg2, uint64_t msg3, void *data)
+{
+    if (vc == nlm_fb_vc && size == 2) {
+	if (nlm_tx_id ==
+		nlm_hal_rsa_process_response(vc, code, src_id, msg0,
+		    msg1, &nlm_err_msg)) {
+	    up(&sem);
+	}
+    }
+}
+
+int
+nlm_rsa_init(void)
+{
+    int ret = 0, i, size;
+    struct nlm_rsa_param rprm;
+    uint32_t rx_vc;
+    uint64_t tx_id = 0x1234;
+    unsigned char *src = NULL, *dst = NULL;
+
+    sema_init(&sem, 0);
+    if (register_xlp_msgring_handler
+	    (XLP_MSG_HANDLE_RSA_ECC, nlm_xlp_rsa_msgring_handler, NULL)) {
+	panic("can't register msgring handler for TX_STN_GMAC0");
+    }
+
+    init_rsa_vc();
+    memset(&rprm, 0, sizeof (struct nlm_rsa_param));
+
+    size = sizeof(ucode_data);
+    src = (unsigned char*)get_cache_aligned_mem(size);
+    dst = (unsigned char*)get_cache_aligned_mem(size); 
+    if(src == NULL || dst == NULL)
+    {
+	printk("\n Memory allocation failed for nlm_rsa_init");	
+	return 0;
+    }
+    memcpy(src, (unsigned char*)ucode_data, size);
+    rx_vc = rsa_get_fb_vc();
+    rprm.type = 0x70;
+    rprm.src_phy = (uint64_t)virt_to_phys(src);//src);
+    rprm.dst_phy = (uint64_t)virt_to_phys(dst);
+    nlm_fb_vc = rprm.freeback_id =  rx_vc = 3;
+    rprm.sw_scratch_pad = tx_id;
+    nlm_tx_id = tx_id ;
+
+    i = 0;
+    while( i < NUM_VC)
+    {
+	ret = nlm_hal_rsa_send_request((rsa_get_vc() + i), &rprm);
+	if(ret)
+	    printf(" nlm_rsa_init failed for nlm_hal_rsa_send_request ret = %d\n", ret);
+
+	if(down_interruptible(&sem))
+	    return -ERESTARTSYS;
+	rsa_fb_msg_print_err(nlm_err_msg);
+#if 0
+	ret = wait_for_freeback(tx_id, rx_vc);
+	if(ret)
+	    printf(" wait_for_freeback failed ret = %d\n", ret);
+#endif
+	i++;
+    }
+
+    free_cache_aligned_mem(src);
+    free_cache_aligned_mem(dst);
+    return 0;
+}
+
+int
+nlm_rsa_operation(struct rsa_param *rop)
+{
+    int ret = 0;
+    struct nlm_rsa_param rprm;
+    uint32_t rx_vc;
+    uint64_t tx_id;
+    static int rsa_rr_vc = 0;
+
+    nlm_err_msg = 0;
+    if (!rop)
+	return NLM_ERR_RSA_PARAM_NULL;
+
+    memset(&rprm, 0, sizeof (struct nlm_rsa_param));
+
+    nlm_fb_vc = rx_vc = rsa_get_fb_vc();
+    tx_id = (uint64_t) rop;
+
+    rprm.src_l3_alloc = rop->src_l3_alloc;
+    rprm.type = rop->type;
+    rprm.function = rop->function;
+    rprm.src_phy = virt_to_phys(rop->src_addr);
+
+    rprm.dst_clobber = rop->dst_clobber;
+    rprm.dst_l3_alloc = rop->dst_l3_alloc;
+    rprm.freeback_id = rx_vc;
+    rprm.dst_phy = virt_to_phys(rop->dst_addr);
+    nlm_tx_id = rprm.sw_scratch_pad = tx_id;
+    ret = nlm_hal_rsa_send_request(rsa_get_vc() + rsa_rr_vc, &rprm);
+    if(ret)
+	printk("ERROR - nlm_rsa_operation failed ret = %x\n",ret);
+
+    if(down_interruptible(&sem))
+	return -ERESTARTSYS;
+    rsa_fb_msg_print_err(nlm_err_msg);
+#if 0
+    if (!ret) 
+	ret = wait_for_freeback(tx_id, rx_vc);
+#endif
+    rsa_rr_vc++;
+    if(rsa_rr_vc % NUM_VC == 0)
+	rsa_rr_vc = 0;
+
+    return ret;
+}
+
+int nlmrsa_ecc_point_add (
+	unsigned char *x1, unsigned int x1_len,
+	unsigned char *y1, unsigned int y1_len,
+	unsigned char *x2, unsigned int x2_len,
+	unsigned char *y2, unsigned int y2_len,
+	unsigned char *a, unsigned int a_len,
+	unsigned char *m, unsigned int m_len,
+	unsigned int is_prime,
+	unsigned char *out, unsigned int aligned_m_len)
+{
+    struct rsa_param sd;
+    uint32_t data_size, num_inputs, unit_len, num_outputs;
+    uint64_t *src, *dst;
+    int i, index, k;
+
+    memset(&sd, 0, sizeof(struct rsa_param));
+    data_size = aligned_m_len/8; /* In unit64_t */
+    num_inputs = 6;
+    num_outputs = 3;
+    unit_len = aligned_m_len;//8 * data_size;
+    switch(aligned_m_len)
+    {
+	case 8:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_64:NLM_RSA_ECC_BINARY_64;
+	    break;
+	case 16:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_128:NLM_RSA_ECC_BINARY_128;
+	    break;
+	case 24:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_192:NLM_RSA_ECC_BINARY_192;
+	    break;
+	case 32:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_256:NLM_RSA_ECC_BINARY_256;
+	    break;
+	case 40:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_320:NLM_RSA_ECC_BINARY_320;
+	    break;
+	case 48:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_384:NLM_RSA_ECC_BINARY_384;
+	    break;
+	case 56:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_448:NLM_RSA_ECC_BINARY_448;
+	    break;
+	case 64:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_512:NLM_RSA_ECC_BINARY_512;
+	    break;
+	case 72:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_576:NLM_RSA_ECC_BINARY_576;
+	    break;
+    }
+    sd.function = NLM_RSA_ECC_POINT_ADDITION;
+    sd.src_addr = get_cache_aligned_mem(unit_len * num_inputs);/* 64 = 512 bits*/
+    sd.dst_addr = get_cache_aligned_mem(unit_len * num_outputs);/* 64 = 512 bits*/
+
+    memset(sd.src_addr, 0, (unit_len * num_inputs));
+    memset(sd.dst_addr, 0, (unit_len * num_outputs));
+
+    src = (uint64_t*)sd.src_addr;
+
+    {
+	int k=0;
+
+	dst = (uint64_t*)x1;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+	dst = (uint64_t*)y1;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+	dst = (uint64_t*)x2;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+	dst = (uint64_t*)y2;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+	dst = (uint64_t*)a;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+	dst = (uint64_t*)m;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+    }
+    dst = (uint64_t*)out;
+
+    nlm_rsa_operation(&sd);
+    for(i =0; i < 100000; i++);
+    k = 0;
+    index = 0;
+    for(k = 0; k < num_outputs; k++)
+    {
+	for(i = 0; i < data_size; i++)
+	{
+	    dst[index] = sd.dst_addr[index];
+	    index++;
+	}
+    }
+
+    free_cache_aligned_mem(sd.src_addr);	
+    free_cache_aligned_mem(sd.dst_addr);	
+
+    return 0;
+}
+
+int nlmrsa_ecc_point_double(
+	unsigned char *x, unsigned int x_len,
+	unsigned char *y, unsigned int y_len,
+	unsigned char *a, unsigned int a_len,
+	unsigned char *m, unsigned int m_len,
+	unsigned int is_prime,
+	unsigned char *out, unsigned int aligned_m_len)
+{
+    struct rsa_param sd;
+    uint32_t data_size, num_inputs, unit_len, num_outputs;
+    uint64_t *src, *dst;
+    int i, index, k;
+
+    memset(&sd, 0, sizeof(struct rsa_param));
+    data_size = aligned_m_len/8; /* In unit64_t */
+    num_inputs = 4;
+    num_outputs = 3;
+    unit_len = aligned_m_len;//8 * data_size;
+    switch(aligned_m_len)
+    {
+	case 8:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_64:NLM_RSA_ECC_BINARY_64;
+	    break;
+	case 16:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_128:NLM_RSA_ECC_BINARY_128;
+	    break;
+	case 24:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_192:NLM_RSA_ECC_BINARY_192;
+	    break;
+	case 32:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_256:NLM_RSA_ECC_BINARY_256;
+	    break;
+	case 40:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_320:NLM_RSA_ECC_BINARY_320;
+	    break;
+	case 48:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_384:NLM_RSA_ECC_BINARY_384;
+	    break;
+	case 56:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_448:NLM_RSA_ECC_BINARY_448;
+	    break;
+	case 64:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_512:NLM_RSA_ECC_BINARY_512;
+	    break;
+	case 72:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_576:NLM_RSA_ECC_BINARY_576;
+	    break;
+    }
+    sd.function = NLM_RSA_ECC_POINT_DOUBLE;
+    sd.src_addr = get_cache_aligned_mem(unit_len * num_inputs);/* 64 = 512 bits*/
+    sd.dst_addr = get_cache_aligned_mem(unit_len * num_outputs);/* 64 = 512 bits*/
+
+    memset(sd.src_addr, 0, (unit_len * num_inputs));
+    memset(sd.dst_addr, 0, (unit_len * num_outputs));
+
+    src = (uint64_t*)sd.src_addr;
+
+    {
+	int k=0;
+
+	dst = (uint64_t*)x;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+	dst = (uint64_t*)y;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+	dst = (uint64_t*)a;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+	dst = (uint64_t*)m;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+    }
+    dst = (uint64_t*)out;
+
+
+    //	dump_buffer(sd.src_addr, m_len*3, "RSA_BUF:");
+    nlm_rsa_operation(&sd);
+    //	for(i =0; i < 100000; i++);
+    k = 0;
+    index = 0;
+    for(k = 0; k < num_outputs; k++)
+    {
+	for(i = 0; i < data_size; i++)
+	{
+	    dst[index] = sd.dst_addr[index];
+	    index++;
+	}
+    }
+
+    free_cache_aligned_mem(sd.src_addr);	
+    free_cache_aligned_mem(sd.dst_addr);	
+
+    return 0;
+}
+
+int
+nlmrsa_ecc_point_mul (
+	unsigned char *x, unsigned int x_len,
+	unsigned char *y, unsigned int y_len,
+	unsigned char *a, unsigned int a_len,
+	unsigned char *p, unsigned int p_len,
+	unsigned char *m, unsigned int m_len,
+	unsigned int is_prime,
+	unsigned char *out, unsigned int aligned_m_len)
+{
+    struct rsa_param sd;
+    uint32_t data_size, num_inputs, unit_len, num_outputs;
+    uint64_t *src, *dst;
+    int i, index, k;
+
+    memset(&sd, 0, sizeof(struct rsa_param));
+    data_size = aligned_m_len/8; /* In unit64_t */
+    num_inputs = 5;
+    num_outputs = 3;
+    unit_len = aligned_m_len;//8 * data_size;
+    switch(aligned_m_len)
+    {
+	case 8:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_64:NLM_RSA_ECC_BINARY_64;
+	    break;
+	case 16:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_128:NLM_RSA_ECC_BINARY_128;
+	    break;
+	case 24:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_192:NLM_RSA_ECC_BINARY_192;
+	    break;
+	case 32:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_256:NLM_RSA_ECC_BINARY_256;
+	    break;
+	case 40:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_320:NLM_RSA_ECC_BINARY_320;
+	    break;
+	case 48:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_384:NLM_RSA_ECC_BINARY_384;
+	    break;
+	case 56:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_448:NLM_RSA_ECC_BINARY_448;
+	    break;
+	case 64:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_512:NLM_RSA_ECC_BINARY_512;
+	    break;
+	case 72:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_576:NLM_RSA_ECC_BINARY_576;
+	    break;
+    }
+    sd.function = NLM_RSA_ECC_POINT_MULTIPLICATION;
+    sd.src_addr = get_cache_aligned_mem(unit_len * num_inputs);/* 64 = 512 bits*/
+    sd.dst_addr = get_cache_aligned_mem(unit_len * num_outputs);/* 64 = 512 bits*/
+
+    memset(sd.src_addr, 0, (unit_len * num_inputs));
+    memset(sd.dst_addr, 0, (unit_len * num_outputs));
+
+    src = (uint64_t*)sd.src_addr;
+    {
+	int k=0;
+
+	dst = (uint64_t*)x;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+	dst = (uint64_t*)y;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+	dst = (uint64_t*)a;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+	dst = (uint64_t*)p;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+	dst = (uint64_t*)m;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+    }
+    dst = (uint64_t*)out;
+
+
+    nlm_rsa_operation(&sd);
+    k = 0;
+    index = 0;
+    for(k = 0; k < num_outputs; k++)
+
+	nlm_rsa_operation(&sd);
+    for(i=0; i < 10000; i++);
+    k = 0;
+    index = 0;
+    for(k = 0; k < num_outputs; k++)
+    {
+	for(i = 0; i < data_size; i++)
+	{
+	    dst[index] = sd.dst_addr[index];
+	    index++;
+	}
+    }
+
+    free_cache_aligned_mem(sd.src_addr);	
+    free_cache_aligned_mem(sd.dst_addr);	
+
+    return 0;
+}
+
+int nlmrsa_ecc_point_verification(
+	unsigned char *x, unsigned int x_len,
+	unsigned char *y, unsigned int y_len,
+	unsigned char *a, unsigned int a_len,
+	unsigned char *p, unsigned int p_len,
+	unsigned char *m, unsigned int m_len,
+	unsigned int is_prime,
+	unsigned char *out, unsigned int aligned_m_len)
+{
+    struct rsa_param sd;
+    uint32_t data_size, num_inputs, unit_len, num_outputs;
+    uint64_t *src, *dst;
+    int i, index, k;
+
+    memset(&sd, 0, sizeof(struct rsa_param));
+    data_size = aligned_m_len/8; /* In unit64_t */
+    num_inputs = 5;
+    num_outputs = 1;
+    unit_len = aligned_m_len;//8 * data_size;
+    switch(aligned_m_len)
+    {
+	case 8:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_64:NLM_RSA_ECC_BINARY_64;
+	    break;
+	case 16:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_128:NLM_RSA_ECC_BINARY_128;
+	    break;
+	case 24:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_192:NLM_RSA_ECC_BINARY_192;
+	    break;
+	case 32:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_256:NLM_RSA_ECC_BINARY_256;
+	    break;
+	case 40:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_320:NLM_RSA_ECC_BINARY_320;
+	    break;
+	case 48:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_384:NLM_RSA_ECC_BINARY_384;
+	    break;
+	case 56:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_448:NLM_RSA_ECC_BINARY_448;
+	    break;
+	case 64:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_512:NLM_RSA_ECC_BINARY_512;
+	    break;
+	case 72:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_576:NLM_RSA_ECC_BINARY_576;
+	    break;
+    }
+    sd.function = NLM_RSA_ECC_POINT_VERIFICATION;
+    sd.src_addr = get_cache_aligned_mem(unit_len * num_inputs);/* 64 = 512 bits*/
+    sd.dst_addr = get_cache_aligned_mem(unit_len * num_outputs);/* 64 = 512 bits*/
+
+    memset(sd.src_addr, 0, (unit_len * num_inputs));
+
+    src = (uint64_t*)sd.src_addr;
+
+    {
+	int k=0;
+
+	dst = (uint64_t*)x;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+	dst = (uint64_t*)y;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+	dst = (uint64_t*)a;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+	dst = (uint64_t*)p;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+	dst = (uint64_t*)m;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+    }
+    dst = (uint64_t*)out;
+
+    nlm_rsa_operation(&sd);
+    k = 0;
+    index = 0;
+    for(k = 0; k < num_outputs; k++)
+    {
+	for(i = 0; i < data_size; i++)
+	{
+	    dst[(data_size -i -1)] = sd.dst_addr[index];
+	    index++;
+	}
+    }
+
+    free_cache_aligned_mem(sd.src_addr);	
+    free_cache_aligned_mem(sd.dst_addr);	
+
+    return 0;
+}
+
+
+int nlmrsa_ecc_mod_mul( unsigned char *x, unsigned int x_len,
+	unsigned char *p, unsigned int p_len,
+	unsigned char *m, unsigned int m_len,
+	unsigned char *y, unsigned int y_len,
+	unsigned int is_prime)
+{
+    struct rsa_param sd;
+    uint32_t data_size, num_inputs, unit_len, num_outputs;
+    uint64_t *src, *dst;
+    int i;
+
+    memset(&sd, 0, sizeof(struct rsa_param));
+    data_size = y_len/8; /* In unit64_t */
+    num_inputs = 3;
+    num_outputs = 1;
+    unit_len = y_len;//8 * data_size;
+    switch(y_len)
+    {
+	case 8:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_64:NLM_RSA_ECC_BINARY_64;
+	    break;
+	case 16:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_128:NLM_RSA_ECC_BINARY_128;
+	    break;
+	case 24:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_192:NLM_RSA_ECC_BINARY_192;
+	    break;
+	case 32:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_256:NLM_RSA_ECC_BINARY_256;
+	    break;
+	case 40:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_320:NLM_RSA_ECC_BINARY_320;
+	    break;
+	case 48:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_384:NLM_RSA_ECC_BINARY_384;
+	    break;
+	case 56:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_448:NLM_RSA_ECC_BINARY_448;
+	    break;
+	case 64:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_512:NLM_RSA_ECC_BINARY_512;
+	    break;
+	case 72:
+	    sd.type = (is_prime)?NLM_RSA_ECC_PRIME_576:NLM_RSA_ECC_BINARY_576;
+	    break;
+    }
+    sd.function = NLM_RSA_ECC_MODULAR_MULTIPLICATION;
+    sd.src_addr = get_cache_aligned_mem(unit_len * num_inputs);/* 64 = 512 bits*/
+    sd.dst_addr = get_cache_aligned_mem(unit_len * num_outputs);/* 64 = 512 bits*/
+
+    memset(sd.src_addr, 0, (unit_len * num_inputs));
+    memset(sd.dst_addr, 0, (unit_len * num_outputs));
+
+    src = (uint64_t*)sd.src_addr;
+
+    {
+	int k=0;
+
+	dst = (uint64_t*)x;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+	dst = (uint64_t*)p;
+
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+	dst = (uint64_t*)m;
+	for(i = 0; i < data_size; i++)
+	    src[k++] = dst[i];
+
+    }
+    dst = (uint64_t*)y;
+
+    nlm_rsa_operation(&sd);
+    for(i=0; i<100000; i++);
+    data_size--;
+    for(i = 0; i <= data_size; i++)
+    {
+	dst[i] = sd.dst_addr[i];
+    }
+
+    free_cache_aligned_mem(sd.src_addr);	
+    free_cache_aligned_mem(sd.dst_addr);	
+
+    return 0;
+}
+
+
+int rmisec_mod_exp (
+	unsigned char *x, int x_len,
+	unsigned char *p, int p_len,
+	unsigned char *m, int m_len,
+	unsigned char *y)
+{
+    struct rsa_param sd;
+    uint32_t data_size, num_inputs, unit_len, num_outputs;
+    uint64_t *src, *dst;
+    int i;
+
+    memset(&sd, 0, sizeof(struct rsa_param));
+    data_size = m_len/8; /* In unit64_t */
+    num_inputs = 3;
+    num_outputs = 1;
+    unit_len = m_len;//8 * data_size;
+    switch(m_len)
+    {
+	case 64:
+	    sd.type = NLM_RSA_ME_512;
+	    break;
+	case 128:
+	    sd.type = NLM_RSA_ME_1024;
+	    break;
+	case 256:
+	    sd.type = NLM_RSA_ME_2048;
+	    break;
+	case 512:
+	    sd.type = NLM_RSA_ME_4096;
+	    break;
+	case 1024:
+	    sd.type = NLM_RSA_ME_8192;
+	    break;
+    }
+    sd.function = NLM_RSA_ME_MODULAR_EXPONENTIATION;
+    sd.src_addr = get_cache_aligned_mem(unit_len * num_inputs);/* 64 = 512 bits*/
+    sd.dst_addr = get_cache_aligned_mem(unit_len * num_outputs);/* 64 = 512 bits*/
+
+    memset(sd.src_addr, 0, (unit_len * num_inputs));
+    dst = (uint64_t*)y;
+    src = (uint64_t*)sd.src_addr;
+    dword_data_copy(src, (uint64_t *)x, x_len, -1);
+    src += (m_len>>3);
+    dword_data_copy(src, (uint64_t *)p, p_len, -1);
+    src += (m_len>>3);
+
+    dword_data_copy(src, (uint64_t *)m, m_len, -1);	
+
+    nlm_rsa_operation(&sd);
+    data_size--;
+    for(i = 0; i <= data_size; i++)
+    {
+	dst[data_size-i] = sd.dst_addr[i];
+    }
+
+    free_cache_aligned_mem(sd.src_addr);	
+    free_cache_aligned_mem(sd.dst_addr);	
+
+    return 0;
+}
+
+static const struct file_operations xlp_rsa_fops = {
+    .owner = THIS_MODULE,
+    .open = xlp_rsa_open,
+    .ioctl = xlp_rsa_ioctl,
+    .release = xlp_rsa_release,
+};
+struct ec_RSA_op{
+    unsigned int y_len;
+    unsigned int x1_len;
+    unsigned int y1_len;
+    unsigned int x2_len;
+    unsigned int y2_len;
+    unsigned int a_len;
+    unsigned int k_len;
+    unsigned int m_len;
+    unsigned int is_prime;
+};
+
+struct RSA_op{
+    unsigned int y_len;
+    unsigned int x_len;
+    unsigned int p_len;
+    unsigned int m_len;
+    unsigned int is_prime;
+};
+
+
+static int
+xlp_rsa_ioctl(struct inode *inode, struct file *fptr, unsigned int type, unsigned long val)
+{
+    unsigned char *ptr = NULL, *user_p, *org_ptr = NULL;
+    unsigned int size, header_size, data_len, num_inputs, num_outputs;
+    struct RSA_op *rsa_sd;
+    struct ec_RSA_op *ec_rsa_sd;
+
+    data_len = (type >> 16) & 0xffff;/* In bytes */
+    type = (type & 0xffff);
+    switch(type)
+    {
+	case CMD_RSA_ECC_POINT_MULTIPLICATION:
+	    num_inputs = 5;
+	    num_outputs = 3;
+	    header_size = sizeof(struct ec_RSA_op);
+	    size = header_size + data_len * (num_inputs + num_outputs);
+	    org_ptr = ptr = malloc(size); 
+	    copy_from_user(ptr, (unsigned char*)val, size);
+	    ec_rsa_sd = (struct ec_RSA_op*)ptr;
+	    ptr = ptr + sizeof(struct ec_RSA_op);
+
+	    nlmrsa_ecc_point_mul (&ptr[0], ec_rsa_sd->x1_len, 
+		    &ptr[data_len], ec_rsa_sd->y1_len, 
+		    &ptr[data_len*2], ec_rsa_sd->a_len, 
+		    &ptr[data_len*3], ec_rsa_sd->k_len, 
+		    &ptr[data_len*4], ec_rsa_sd->m_len,
+		    ec_rsa_sd->is_prime, &ptr[data_len*num_inputs], ec_rsa_sd->y_len);
+
+	    user_p = (unsigned char*)val;
+	    copy_to_user((unsigned char*)&user_p[(sizeof(struct ec_RSA_op)+data_len*num_inputs)], &ptr[data_len*num_inputs], (data_len*num_outputs));
+	    break;
+	case CMD_RSA_ECC_POINT_ADDITION:       
+	    num_inputs = 6;
+	    num_outputs = 3;
+	    header_size = sizeof(struct ec_RSA_op);
+	    size = header_size + data_len * (num_inputs + num_outputs);
+	    org_ptr = ptr = malloc(size); 
+	    copy_from_user(ptr, (unsigned char*)val, size);
+	    ec_rsa_sd = (struct ec_RSA_op*)ptr;
+	    ptr = ptr + sizeof(struct ec_RSA_op);
+
+	    nlmrsa_ecc_point_add (&ptr[0], ec_rsa_sd->x1_len, 
+		    &ptr[data_len], ec_rsa_sd->y1_len, 
+		    &ptr[data_len*2], ec_rsa_sd->x2_len, 
+		    &ptr[data_len*3], ec_rsa_sd->y2_len, 
+		    &ptr[data_len*4], ec_rsa_sd->a_len,
+		    &ptr[data_len*5], ec_rsa_sd->m_len,
+		    ec_rsa_sd->is_prime, &ptr[data_len*num_inputs], ec_rsa_sd->y_len);
+
+	    user_p = (unsigned char*)val;
+	    copy_to_user((unsigned char*)&user_p[(sizeof(struct ec_RSA_op)+data_len*num_inputs)], &ptr[data_len*num_inputs], (data_len*num_outputs));
+	    break;
+	case CMD_RSA_ECC_POINT_DOUBLE:           
+	    num_inputs = 4;
+	    num_outputs = 3;
+	    header_size = sizeof(struct ec_RSA_op);
+	    size = header_size + data_len * (num_inputs + num_outputs);
+	    org_ptr = ptr = malloc(size); 
+	    copy_from_user(ptr, (unsigned char*)val, size);
+	    ec_rsa_sd = (struct ec_RSA_op*)ptr;
+	    ptr = ptr + sizeof(struct ec_RSA_op);
+
+	    nlmrsa_ecc_point_double (&ptr[0], ec_rsa_sd->x1_len, 
+		    &ptr[data_len], ec_rsa_sd->y1_len, 
+		    &ptr[data_len*2], ec_rsa_sd->a_len, 
+		    &ptr[data_len*3], ec_rsa_sd->m_len, 
+		    ec_rsa_sd->is_prime, &ptr[data_len*num_inputs], ec_rsa_sd->y_len);
+
+	    user_p = (unsigned char*)val;
+	    copy_to_user((unsigned char*)&user_p[(sizeof(struct ec_RSA_op)+(data_len*num_inputs))], &ptr[data_len*num_inputs], (data_len*num_outputs));
+	    break;
+	case CMD_RSA_ECC_POINT_VERIFICATION:    
+	    num_inputs = 5;
+	    num_outputs = 1;
+	    header_size = sizeof(struct ec_RSA_op);
+	    size = header_size + data_len * (num_inputs + num_outputs);
+	    org_ptr = ptr = malloc(size); 
+	    copy_from_user(ptr, (unsigned char*)val, size);
+	    ec_rsa_sd = (struct ec_RSA_op*)ptr;
+	    ptr = ptr + sizeof(struct ec_RSA_op);
+
+	    nlmrsa_ecc_point_verification (&ptr[0], ec_rsa_sd->x1_len, 
+		    &ptr[data_len], ec_rsa_sd->y1_len, 
+		    &ptr[data_len*2], ec_rsa_sd->a_len, 
+		    &ptr[data_len*3], ec_rsa_sd->k_len, 
+		    &ptr[data_len*4], ec_rsa_sd->m_len,
+		    ec_rsa_sd->is_prime, &ptr[data_len*num_inputs], ec_rsa_sd->y_len);
+
+	    user_p = (unsigned char*)val;
+	    copy_to_user((unsigned char*)&user_p[(sizeof(struct ec_RSA_op)+data_len*num_inputs)], &ptr[data_len*num_inputs], (data_len*num_outputs));
+	    break;
+	case CMD_RSA_ECC_MODULAR_ADDITION:
+	    num_inputs = 3;
+	    num_outputs = 1;
+	    header_size = sizeof(struct RSA_op);
+	    break;
+	case CMD_RSA_ECC_MODULAR_SUBTRACTION:    
+	    num_inputs = 3;
+	    num_outputs = 1;
+	    header_size = sizeof(struct RSA_op);
+	    break;
+	case CMD_RSA_ECC_MODULAR_MULTIPLICATION:
+	    num_inputs = 3;
+	    num_outputs = 1;
+	    header_size = sizeof(struct RSA_op);
+	    size = header_size + data_len * (num_inputs + num_outputs);
+	    org_ptr = ptr = malloc(size); 
+	    copy_from_user(ptr, (unsigned char*)val, size);
+	    rsa_sd = (struct RSA_op*)ptr;
+	    ptr = ptr + sizeof(struct RSA_op);
+
+	    nlmrsa_ecc_mod_mul(&ptr[0], rsa_sd->x_len, &ptr[data_len], rsa_sd->p_len, &ptr[data_len*2], rsa_sd->m_len, &ptr[data_len*num_inputs], rsa_sd->y_len, rsa_sd->is_prime);
+
+	    user_p = (unsigned char*)val;
+	    copy_to_user((unsigned char*)&user_p[sizeof(struct RSA_op)+data_len*num_inputs], &ptr[data_len*num_inputs], data_len);
+	    break;
+	case CMD_RSA_ECC_MODULAR_DIVISION:
+	    num_inputs = 3;
+	    num_outputs = 1;
+	    header_size = sizeof(struct RSA_op);
+	    break;
+	case CMD_RSA_ECC_MODULAR_INVERSION:   
+	    num_inputs = 2;
+	    num_outputs = 1;
+	    header_size = sizeof(struct RSA_op);
+	    break;
+	case CMD_RSA_ECC_MODULAR_REDUCTION: 
+	    num_inputs = 2;
+	    num_outputs = 1;
+	    header_size = sizeof(struct RSA_op);
+	    break;
+	case CMD_RSA_ME_MODULAR_EXPONENTIATION:
+	    num_inputs = 3;
+	    num_outputs = 1;
+	    header_size = sizeof(struct RSA_op);
+	    size = header_size + data_len * (num_inputs + num_outputs);
+	    org_ptr = ptr = malloc(size); 
+	    copy_from_user(ptr, (unsigned char*)val, size);
+	    rsa_sd = (struct RSA_op*)ptr;
+	    ptr = ptr + sizeof(struct RSA_op);
+
+	    rmisec_mod_exp(&ptr[0], rsa_sd->x_len, &ptr[data_len], rsa_sd->p_len, &ptr[data_len*2], rsa_sd->m_len, &ptr[data_len*3]);
+
+	    user_p = (unsigned char*)val;
+	    copy_to_user((unsigned char*)&user_p[sizeof(struct RSA_op)+data_len*3], &ptr[data_len*3], data_len);
+	    break;
+	case CMD_RSA_ME_MODULAR_MULTIPLICATION:
+	    num_inputs = 3;
+	    num_outputs = 1;
+	    header_size = sizeof(struct RSA_op);
+	    break;
+    }
+
+    if(org_ptr)
+	free(org_ptr);
+    return 0;
+}
+
+static int
+xlp_rsa_open(struct inode *inode, struct file *file)
+{
+    printk("\n=============================xlp_rsa_open\n");
+    return 0;
+}
+
+static int
+xlp_rsa_release(struct inode *inode, struct file *file)
+{
+    printk("xlp_rsa_release\n");
+
+    return 0;
+}
+
+int nlmrsa_ecc_mod_substraction(uint64_t handle, unsigned char *x, int x_len, unsigned char *y, int y_len, unsigned char *z, int z_len)
+{
+    struct rsa_param sd;
+    uint32_t data_size, num_inputs, num_outputs, unit_len;
+
+    memset(&sd, 0, sizeof(struct rsa_param));
+    data_size = 1; /* In unit64_t */
+    num_inputs = 3;
+    num_outputs = 1;
+    unit_len = 8 * data_size;
+
+    sd.type = NLM_RSA_ECC_PRIME_64;
+    sd.function = NLM_RSA_ECC_MODULAR_SUBTRACTION;	
+
+    sd.src_addr = get_cache_aligned_mem(unit_len * num_inputs);/* 64 = 512 bits*/
+    sd.dst_addr = get_cache_aligned_mem(unit_len * num_outputs);/* 64 = 512 bits*/
+    memset(sd.src_addr, 0, (unit_len * num_inputs));
+    memset(sd.dst_addr, 0, (unit_len * num_outputs));
+
+    sd.src_addr[0] = 78ULL;
+    sd.src_addr[1] = 45ULL;
+    sd.src_addr[2] = 7ULL;
+
+    nlm_rsa_operation(&sd);
+    printk("output = %lld\n",sd.dst_addr[0]);
+
+    free_cache_aligned_mem(sd.src_addr);	
+    free_cache_aligned_mem(sd.dst_addr);	
+
+    return 0;
+}
+
+
+#define C_XLP_IO_RSA_REG_BASE  0xFFFFFFFFb802a100
+void nlm_drng_test(void)
+{
+
+    int i ;
+    int drng_valid ;
+    int drng_busy ;
+    static volatile    int data[8] ;
+    static volatile    int status[8] ;
+    static volatile    uint64_t c_xlp_io_rsa_reg_base = 0xFFFFFFFFb802a100ULL ;
+    static volatile    uint32_t *mmio_rsa_reg ;
+
+    mmio_rsa_reg = (uint32_t *) c_xlp_io_rsa_reg_base;
+    for ( i = 0 ; i < 9 ; i ++ ) {
+	// printf("value = 0x%x\n",get_rand_num());
+	data[0] =  read_32bit_cfg_reg((uint32_t *)mmio_rsa_reg,0x20+0);
+	data[1] =  read_32bit_cfg_reg((uint32_t *)mmio_rsa_reg,0x20+1);
+	data[2] =  read_32bit_cfg_reg((uint32_t *)mmio_rsa_reg,0x20+2);
+	data[3] =  read_32bit_cfg_reg((uint32_t *)mmio_rsa_reg,0x20+3);
+	data[4] =  read_32bit_cfg_reg((uint32_t *)mmio_rsa_reg,0x20+4);
+	data[5] =  read_32bit_cfg_reg((uint32_t *)mmio_rsa_reg,0x20+5);
+	data[6] =  read_32bit_cfg_reg((uint32_t *)mmio_rsa_reg,0x20+6);
+	data[7] =  read_32bit_cfg_reg((uint32_t *)mmio_rsa_reg,0x20+7);
+	// status[i] =  read_32bit_cfg_reg((uint32_t *)mmio_rsa_reg,0x1c);
+	while (1) {
+	    status[i]  =  read_32bit_cfg_reg((uint32_t *)mmio_rsa_reg,0x1c);
+	    drng_valid = ( status[i] >> 5 ) & 0x1 ;
+	    drng_busy  = ( status[i] >> 4 ) & 0x1 ;
+	    if ( ( drng_valid == 1 ) && ( drng_busy == 0 ) ) {
+		break ;
+	    } 
+	}
+	printk("Data = %x %x %x %x %x %x %x %x\n", data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]);
+#if 0
+	if(i> 4)
+	{
+	    uint32_t *mmio_rsa_reg_7 = (uint32_t *) C_XLP_IO_RSA_REG_BASE;
+	    write_32bit_cfg_reg(mmio_rsa_reg_7, 0x1c, 0x00000009ULL);            
+	    uint32_t *mmio_rsa_reg_8 = (uint32_t *) C_XLP_IO_RSA_REG_BASE;
+	    write_32bit_cfg_reg(mmio_rsa_reg_8, 0x1e, 0x12345678ULL);
+	    uint32_t *mmio_rsa_reg_9 = (uint32_t *) C_XLP_IO_RSA_REG_BASE;
+	    write_32bit_cfg_reg(mmio_rsa_reg_9, 0x1f, 0x0000ffffULL);
+	}
+#endif
+    }
+
+}
+
+static int __init xlp_rsa_init(void)
+{
+    printk(KERN_ERR ",\n XLP RSA Initialization \n");
+
+    xlp_rsa_major = register_chrdev(0, "NLM_XLP_RSA", &xlp_rsa_fops);
+    if (xlp_rsa_major < 0) {
+	printk(KERN_ERR "XLP_RSA - cannot register device\n");
+	return xlp_rsa_major;
+    }
+    printk (KERN_ERR ",XLP RSA MAJOR %d\n", xlp_rsa_major);
+
+    nlm_rsa_init();
+    printk("nlm_rsa_init done\n\n");
+    nlmrsa_ecc_mod_substraction(1, NULL, 2, NULL, 3, NULL, 4);
+    printk("nlmrsa_ecc_mod_substraction done\n\n");
+    //	nlm_drng_test();
+    return 0;
+}
+
+static void __exit xlp_rsa_cleanup(void)
+{
+    unregister_chrdev(xlp_rsa_major, "XLP_RSA");
+}
+
+module_init(xlp_rsa_init);
+module_exit(xlp_rsa_cleanup);
+MODULE_DESCRIPTION("XLP Hardware RSA Support.");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.1");
+MODULE_AUTHOR("Alok Agrawat");
diff --git a/drivers/misc/netlogic/nlm_rsa/nlm_rsa.h b/drivers/misc/netlogic/nlm_rsa/nlm_rsa.h
new file mode 100644
index 0000000..8555c2b
--- /dev/null
+++ b/drivers/misc/netlogic/nlm_rsa/nlm_rsa.h
@@ -0,0 +1,76 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+#ifndef _NLM_RSA_H_
+#define _NLM_RSA_H_
+
+
+/* Explicitly assigned numbers for readability */
+typedef enum encoding_type 
+{
+  NLM_RSA_ECC_PRIME_64 = 0,
+  NLM_RSA_ECC_PRIME_128 = 1,
+  NLM_RSA_ECC_PRIME_192 = 2,
+  NLM_RSA_ECC_PRIME_256 = 3,
+  NLM_RSA_ECC_PRIME_320 = 4,
+  NLM_RSA_ECC_PRIME_384 = 5,
+  NLM_RSA_ECC_PRIME_448 = 6,
+  NLM_RSA_ECC_PRIME_512 = 7,
+  NLM_RSA_ECC_PRIME_576 = 8,
+  NLM_RSA_ECC_BINARY_64 = 0x20,
+  NLM_RSA_ECC_BINARY_128 = 0x21,
+  NLM_RSA_ECC_BINARY_192 = 0x22,
+  NLM_RSA_ECC_BINARY_256 = 0x23,
+  NLM_RSA_ECC_BINARY_320 = 0x24,
+  NLM_RSA_ECC_BINARY_384 = 0x25,
+  NLM_RSA_ECC_BINARY_448 = 0x26,
+  NLM_RSA_ECC_BINARY_512 = 0x27,
+  NLM_RSA_ECC_BINARY_576 = 0x28,
+  NLM_RSA_ME_512 = 0x40,
+  NLM_RSA_ME_1024 = 0x41,
+  NLM_RSA_ME_2048 = 0x42,
+  NLM_RSA_ME_4096 = 0x43,
+  NLM_RSA_ME_8192 = 0x44,
+  NLM_RSA_MICROCODE_LOAD = 0x70,
+  NLM_RSA_ECNCODING_TYPE_MAX = 0xFF,
+} encoding_type_t;
+
+typedef enum encoding_function 
+{
+  NLM_RSA_ECC_POINT_MULTIPLICATION = 0,
+  NLM_RSA_ECC_POINT_ADDITION = 1,
+  NLM_RSA_ECC_POINT_DOUBLE = 2,
+  NLM_RSA_ECC_POINT_VERIFICATION = 3,
+  NLM_RSA_ECC_MODULAR_ADDITION = 4,
+  NLM_RSA_ECC_MODULAR_SUBTRACTION = 5,
+  NLM_RSA_ECC_MODULAR_MULTIPLICATION = 6,
+  NLM_RSA_ECC_MODULAR_DIVISION = 7,
+  NLM_RSA_ECC_MODULAR_INVERSION = 8,
+  NLM_RSA_ECC_MODULAR_REDUCTION = 9,
+  NLM_RSA_ME_MODULAR_EXPONENTIATION = 0,
+  NLM_RSA_ME_MODULAR_MULTIPLICATION= 1,
+  NLM_RSA_ENCODING_FUNCTION_MAX= 0xA
+} encoding_function_t;
+
+#endif
diff --git a/drivers/misc/netlogic/nlm_rsa/nlm_rsa_api.h b/drivers/misc/netlogic/nlm_rsa/nlm_rsa_api.h
new file mode 100644
index 0000000..c6f6c82
--- /dev/null
+++ b/drivers/misc/netlogic/nlm_rsa/nlm_rsa_api.h
@@ -0,0 +1,90 @@
+/***********************************************************************
+  Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+  reserved.
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are
+  met:
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+  THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+ *****************************#NETL_2#********************************/
+#ifndef _NLM_RSA_API_H_
+#define _NLM_RSA_API_H_
+
+/**
+ * @file_name nlm_rsa_api.h
+ */
+
+/**
+ * @defgroup rsa Crypto API
+ * @brief Description about the rsa apis supported in NETOS.
+ */
+
+
+#define NLM_RSA_FB_ERR_MASK 0x3E00000
+
+#define NLM_RSA_FB_BIU_TIMEOUT_ERR 		(1 << 25)
+#define NLM_RSA_FB_MICROCODE_ERR		(1 << 24)
+#define NLM_RSA_FB_MEMORY_READ_ERR		(1 << 23)
+#define NLM_RSA_FB_UNDEFINED_TYPE_ERR		(1 << 22)
+#define NLM_RSA_FB_UNDEFINED_FUNCTION_ERR 	(1 << 21)
+
+#define NLM_ERR_BASE				0xEAE0000
+#define NLM_ERR_RSA_PARAM_NULL 			(NLM_ERR_BASE | 1)
+#define NLM_ERR_INVALID_PARAM 			(NLM_ERR_BASE | 2)
+#define NLM_ERR_NO_MEM 				(NLM_ERR_BASE | 3)
+#define NLM_ERR_UNSPECIFIED 			(NLM_ERR_BASE | 4)
+#define	NLM_ERR_SEND_TIMEOUT 			(NLM_ERR_BASE | 5)
+#define NLM_ERR_IN_PROGRESS 			(NLM_ERR_BASE | 6)
+
+#define NLM_ERR_FREEBACK_NOT_RECEIVED 		(NLM_ERR_BASE | 256)
+
+
+struct rsa_param
+{
+    uint32_t src_l3_alloc;
+    uint32_t type;
+    uint32_t function;
+    uint64_t *src_addr;
+
+    uint32_t dst_clobber;
+    uint32_t dst_l3_alloc;
+    uint64_t *dst_addr;
+};
+
+
+/**
+ * @brief This API performs cipher and/or authentication operation. It will use preallocated session for algorithm type and mode of operation.
+ *	  Authentication output will be written in the hash_dst_address and cipher output will be written in dst of the cprm structure.
+ *        Source data can be fragmented and cprm->nr_frags represents number of fragments.
+ * @param[in] session  Specifies the session which is setup by calling
+ *                     rsa_setup_cipher_auth_session. 
+ * @param[in] cprm     This structure contains input parameters for  cipher and authentication. 
+ * 
+ * @param[out] cprm->hash_dst_address For authentication output.
+ * @param[out] cprm->dst For cipher output.
+ *
+ * @return Return value of 0 indicates success.
+ * Returns error code, in case of failure.
+ *
+ * @ingroup rsa
+ *
+ */
+extern int nlm_rsa_operation(struct rsa_param *rprm);
+
+
+#endif
diff --git a/drivers/misc/netlogic/nlm_rsa/nlm_rsa_data.h b/drivers/misc/netlogic/nlm_rsa/nlm_rsa_data.h
new file mode 100755
index 0000000..c8ade08
--- /dev/null
+++ b/drivers/misc/netlogic/nlm_rsa/nlm_rsa_data.h
@@ -0,0 +1,158 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+#ifndef NLM_CRYPTO_DATA_H
+#define NLM_CRYPTO_DATA_H
+
+#define NLM_CRYPTO_VC_BASE 281
+/*
+ * is the following table needed for all modes?
+Cipher            keylen           iv_len
+*/
+
+//Ciphers ====> NLM_CIPHER_AES128	
+static int cipher_mode_key_len[NLM_CIPHER_MAX][NLM_CIPHER_MODE_MAX] = {
+/*		      ECB    CBC   CFB   OFB   CTR   AESF8    GCM   CCM    8   9   LRW   XTS */
+/* BYPASS */       {   0,     0,    0,    0,    0,     0,      0,    0,    0,  0,   0,    0,},
+/* DES */          {   8,     8,    0,    0,    0,     0,      0,    0,    0,  0,   0,    0,},
+/* 3DES */         {   24,    24,   0,    0,    0,     0,      0,    0,    0,  0,   0,    0,},
+/* AES128 */       {   16,    16,   16,   16,   16,    16,     16,   16,   0,  0,   32,   32,},
+/* AES192 */       {   24,    24,   24,   24,   24,    24,     24,   24,   0,  0,   40,   48,},
+/* AES256 */	   {   32,    32,   32,   32,   32,    32,     32,   32,   0,  0,   48,   64,},
+/* There is no mode associated with ARC4 ... probably ignored... */
+/* ARC4 */         {   32,    32,   32,   32,   32,    32,     32,   32,   0,  0, 32,   32,}, 
+/* SBOX for ARC4 comes in the next cacheline... So, if SBOX is used, few bytes
+ * of random padding is done to the key to make the SBOX cacheline aligned*/
+/* There is no mode associated with Kasumi F8... probably ignored... */
+/* KASUMI F8 */    {   16,    16,   16,   16,   16,    16,     16,   16,   0,  0,  16,   16,},
+/* There is no mode associated with Snow3G F8... probably ignored... */
+/* SNOW3G F8 */    {   16,    16,   16,   16,   16,    16,     16,   16,   0,  0,  16,   16,},
+/* CAMELLIA128*/   {   16,    16,   16,   16,   16,    16,     16,   16,   0,  0,  32,   32,},
+/* CAMELLIA192*/   {   24,    24,   24,   24,   24,    24,     24,   24,   0,  0,  40,   48,},
+/* CAMELLIA256*/   {   32,    32,   32,   32,   32,    32,     32,   32,   0,  0,  48,   64,},
+};
+
+//-1 indicates variable length IV
+// In case of AES/Camelia cipher and CBC-MAC auth, IV is not needed.
+// In case of AES/Camelia cipher and XCBC-MAC auth, IV is needed only for 
+//CBC, CFB, OFB and CTR modes..
+static int cipher_mode_iv_len[NLM_CIPHER_MAX][NLM_CIPHER_MODE_MAX] = {
+/*		       ECB  CBC   CFB   OFB   CTR  AESF8    GCM  CCM    8   9  LRW   XTS */
+/* BYPASS */       {   0,    0,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
+/* DES */          {   0,    8,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
+/* 3DES */         {   0,    8,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
+/* AES128 */       {   0,    16,   16,   16,   16,   16,     -1,   0,   0,  0,  16,   16,},
+/* AES192 */       {   0,    16,   16,   16,   16,   16,     -1,   0,   0,  0,  16,   16,},
+/* AES256 */       {   0,    16,   16,   16,   16,   16,     -1,   0,   0,  0,  16,   16,},
+/* ARC4 */         {   0,    0,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
+/* KASUMI F8 */    {   0,    0,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
+/* SNOW3G F8 */    {   0,    0,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
+/* CAMELLIA128 */  {   0,    16,   16,   16,   16,   16,     -1,   0,   0,  0,  16,   16,},
+/* CAMELLIA192 */  {   0,    16,   16,   16,   16,   16,     -1,   0,   0,  0,  16,   16,}, 
+/* CAMELLIA256 */  {   0,    16,   16,   16,   16,   16      -1,   0,   0,  0,  16,   16,},
+};
+
+
+static int cipher_alg_needs_mode[NLM_CIPHER_MAX] = {
+0, //NLM_CIPHER_BYPASS
+1, //NLM_CIPHER_DES
+1, //NLM_CIPHER_3DES
+1, //NLM_CIPHER_AES128
+1, //NLM_CIPHER_AES192
+1, //NLM_CIPHER_AES256
+0, //NLM_CIPHER_ARC4
+0, //NLM_CIPHER_KASUMI_F8
+0, //NLM_CIPHER_SNOW3G_F8 
+1, //NLM_CIPHER_CAMELLIA128
+1, //NLM_CIPHER_CAMELLIA192
+1, //NLM_CIPHER_CAMELLIA256
+};
+
+static int cipher_mode_valid[NLM_CIPHER_MAX][NLM_CIPHER_MODE_MAX] = {
+	/* Mode numbers 8 and 9 are undefined.. LRW comes after that */
+/*		       ECB  CBC  CFB  OFB  CTR  AESF8  GCM  CCM  8   9  LRW  XTS */
+/* BYPASS */       {   0,    0,   0,   0,   0,    0,    0,   0,  0,  0,  0,   0,},
+/* DES */          {   1,    1,   0,   0,   0,    0,    0,   0,  0,  0,  0,   0,},
+/* 3DES */         {   1,    1,   0,   0,   0,    0,    0,   0,  0,  0,  0,   0,},
+/* AES128 */       {   1,    1,   1,   1,   1,    1,    1,   1,  0,  0,  1,   1,},
+/* AES192 */       {   1,    1,   1,   1,   1,    1,    1,   1,  0,  0,  1,   1,},
+/* AES256 */       {   1,    1,   1,   1,   1,    1,    1,   1,  0,  0,  1,   1,},
+/* ARC4 */         {   0,    0,   0,   0,   0,    0,    0,   0,  0,  0,  0,   0,},
+/* KASUMI F8 */    {   0,    0,   0,   0,   0,    0,    0,   0,  0,  0,  0,   0,},
+/* SNOW3G F8 */    {   0,    0,   0,   0,   0,    0,    0,   0,  0,  0,  0,   0,},
+/* CAMELLIA128*/   {   1,    1,   0,   0,   1,    0,    0,   1,  0,  0,  0,   0,},
+/* CAMELLIA192*/   {   1,    1,   0,   0,   1,    0,    0,   1,  0,  0,  0,   0,},
+/* CAMELLIA256*/   {   1,    1,   0,   0,   1,    0,    0,   1,  0,  0,  0,   0,},
+};
+
+static int auth_alg_needs_mode[NLM_AUTH_MAX] = {
+0,	// NLM_AUTH_BYPASS
+0,	// NLM_AUTH_MD5
+1,	// NLM_AUTH_SHA
+0,	// NLM_AUTH_UNDEFINED
+1,	// NLM_AUTH_AES128
+1,	// NLM_AUTH_AES192
+1,	// NLM_AUTH_AES256
+0,	// NLM_AUTH_KASUMI_F9
+0,	// NLM_AUTH_SNOW3G_F9
+1,	// NLM_AUTH_CAMELLIA128
+1,	// NLM_AUTH_CAMELLIA192
+1,	// NLM_AUTH_CAMELLIA256
+};
+
+static int auth_mode_key_len[NLM_AUTH_MAX][NLM_AUTH_MODE_MAX] = {
+/*	               SHA1 SHA224 SHA256 SHA384 SHA512  CMAC  XCBC CBC_MAC CCM  GCM*/
+/* BYPASS */		{0,    0,     0,     0,     0,     0,   0,    0,     0,    0, },
+/* MD5 */		{64,   64,    64,   64,    64,    64,  64,   64,    64,   64, },
+/* SHA */		{64,   64,    64,   128,   128,    0,   0,    0,     0,    0, },
+/* 3 */			{0,    0,     0,     0,     0,     0,   0,    0,     0,    0, },
+/* AES128 */		{0,    0,     0,     0,     0,    16,  16,   16,    16,   16, },
+/* AES192 */		{0,    0,     0,     0,     0,    24,  24,   24,    24,   24, },
+/* AES256 */		{0,    0,     0,     0,     0,    32,  32,   32,    32,   32, },
+/* KASUMI_F9 */		{16,  16,    16,    16,    16,    16,  16,   16,    16,   16, },
+/* SNOW3G_F9 */		{16,  16,    16,    16,    16,    16,  16,   16,    16,   16, }, //sandip -> verify
+/* CAMELLIA128 */	{0,    0,     0,     0,     0,    16,  16,   16,    16,   16, },
+/* CAMELLIA192 */	{0,    0,     0,     0,     0,    24,  24,   24,    24,   24, },
+/* CAMELLIA256 */	{0,    0,     0,     0,     0,    32,  32,   32,    32,   32, },
+/* GHASH */		{0,    0,     0,     0,     0,    32,  32,   32,    32,   32, }, //todo:
+};
+
+static int auth_mode_valid[NLM_AUTH_MAX][NLM_AUTH_MODE_MAX] = {
+/*	               SHA1 SHA224 SHA256 SHA384 SHA512  CMAC  XCBC CBC_MAC CCM GCM */
+/* BYPASS */		{0,   0,     0,     0,     0,     0,   0,    0,      0,  0,  },
+/* MD5 */		{1,   1,     1,     1,     1,     1,   1,    1,      1,  1,  }, /* dont care */
+/* SHA */		{1,   1,     1,     1,     1,     0,   0,    0,      0,  0,  },
+/* 3 */			{0,   0,     0,     0,     0,     0,   0,    0,      0,  0,  },
+/* AES128 */		{0,   0,     0,     0,     0,     1,   1,    1,      1,  1,  },
+/* AES192 */		{0,   0,     0,     0,     0,     1,   1,    1,      1,  1,  },
+/* AES256 */		{0,   0,     0,     0,     0,     1,   1,    1,      1,  1,  },
+/* KASUMI_F9 */		{1,   1,     1,     1,     1,     1,   1,    1,      1,  1,  }, /* dont care */
+/* SNOW3G_F9 */		{1,   1,     1,     1,     1,     1,   1,    1,      1,  1,  }, /* dont care */
+/* CAMELLIA128 */	{0,   0,     0,     0,     0,     1,   1,    1,      1,  1,  },
+/* CAMELLIA192 */	{0,   0,     0,     0,     0,     1,   1,    1,      1,  1,  },
+/* CAMELLIA256 */	{0,   0,     0,     0,     0,     1,   1,    1,      1,  1,  },
+/* GHASH */		{1,   1,     1,     1,     1,     1,   1,    1,      1,  1,  }, //todo
+};
+
+#endif
diff --git a/drivers/misc/netlogic/nlm_rsa/ucode_load.h b/drivers/misc/netlogic/nlm_rsa/ucode_load.h
new file mode 100644
index 0000000..3e401a9
--- /dev/null
+++ b/drivers/misc/netlogic/nlm_rsa/ucode_load.h
@@ -0,0 +1,922 @@
+uint64_t  ucode_data [] = {
+    0x0000000000000000ULL,
+    0x00000000503840ecULL,
+    0x00000001903800ecULL,
+    0x00000002c03820ecULL,
+    0x0000003760000044ULL,
+    0x0000000000000014ULL,
+    0x000000071000000cULL,
+    0x00000007d000010cULL,
+    0x0000001b80000c0cULL,
+    0x00000000e03fc0ecULL,
+    0x00000001103fc1ecULL,
+    0x00000001403f42ecULL,
+    0x00000001403fc4ecULL,
+    0x0000003760000044ULL,
+    0x000000001800003cULL,
+    0x0000000d8000030cULL,
+    0x0000000630000044ULL,
+    0x000000002800003cULL,
+    0x0000000ef000030cULL,
+    0x0000000630000044ULL,
+    0x00000000503fc23cULL,
+    0x00000000a03fc33cULL,
+    0x00000001403fc43cULL,
+    0x00000010c000030cULL,
+    0x0000000630000044ULL,
+    0x0000000000000014ULL,
+    0x000000071000000cULL,
+    0x0000001c1000070cULL,
+    0x0000002500000d0cULL,
+    0x00000027c0000e0cULL,
+    0x0000002d60000f0cULL,
+    0x00000002603f00ecULL,
+    0x00000002603f82ecULL,
+    0x00000002803f83ecULL,
+    0x00000002803f04ecULL,
+    0x00000002a03f06ecULL,
+    0x00000002a03f88ecULL,
+    0x0000003760000044ULL,
+    0x000000086000010cULL,
+    0x00000003f0000044ULL,
+    0x00000008d000010cULL,
+    0x00000004b0000044ULL,
+    0x00000008d000010cULL,
+    0x0000000570000044ULL,
+    0x000000000000001cULL,
+    0x000000076000000cULL,
+    0x0000001c1000070cULL,
+    0x0000002690000d0cULL,
+    0x0000002990000e0cULL,
+    0x0000002e10000f0cULL,
+    0x00000003903f20ecULL,
+    0x00000003903fa2ecULL,
+    0x00000003b03fa3ecULL,
+    0x00000003b03f24ecULL,
+    0x00000003d03f26ecULL,
+    0x00000003d03fa8ecULL,
+    0x0000003760000044ULL,
+    0x000000096000010cULL,
+    0x00000003f0000044ULL,
+    0x0000000a0000010cULL,
+    0x00000004b0000044ULL,
+    0x0000000a0000010cULL,
+    0x0000000570000044ULL,
+    0x000000000800003cULL,
+    0x0000000af000020cULL,
+    0x0000000bc000030cULL,
+    0x000000129000040cULL,
+    0x000000178000050cULL,
+    0x000000191000060cULL,
+    0x0000001ff000080cULL,
+    0x000000205000090cULL,
+    0x00000022c0000a0cULL,
+    0x00000020b0000b0cULL,
+    0x0000001ac0000c0cULL,
+    0x0000000680000044ULL,
+    0x000000001000003cULL,
+    0x0000000b5000020cULL,
+    0x0000000c5000030cULL,
+    0x000000137000040cULL,
+    0x00000017e000050cULL,
+    0x000000197000060cULL,
+    0x000000200000080cULL,
+    0x000000206000090cULL,
+    0x0000002340000a0cULL,
+    0x0000002110000b0cULL,
+    0x0000001b10000c0cULL,
+    0x0000000680000044ULL,
+    0x000000001800003cULL,
+    0x0000000b5000020cULL,
+    0x0000000d8000030cULL,
+    0x000000154000040cULL,
+    0x000000187000050cULL,
+    0x0000001a0000060cULL,
+    0x000000202000080cULL,
+    0x000000208000090cULL,
+    0x0000002410000a0cULL,
+    0x00000021c0000b0cULL,
+    0x0000001b80000c0cULL,
+    0x0000000680000044ULL,
+    0x000000000000000aULL,
+    0x0000000000000024ULL,
+    0x0000002ed01f80e4ULL,
+    0x00000030101f81e4ULL,
+    0x0000003760000044ULL,
+    0x000000000000000aULL,
+    0x0000000000000024ULL,
+    0x00000030d01f00e4ULL,
+    0x00000030d01f82e4ULL,
+    0x00000034801f83e4ULL,
+    0x00000035401e04e4ULL,
+    0x00000037101f88e4ULL,
+    0x00000035401f89e4ULL,
+    0x0000003760000044ULL,
+    0x0000000000000074ULL,
+    0x0000000f0000008cULL,
+    0x00000008000000a4ULL,
+    0x000000080400007bULL,
+    0x00000000000000c4ULL,
+    0x0000000000000074ULL,
+    0x0000000c000000a4ULL,
+    0x0000000004004071ULL,
+    0x0000000b0000008cULL,
+    0x00000008000000a4ULL,
+    0x000000080400007bULL,
+    0x00000000000000c4ULL,
+    0x000000034c0b4091ULL,
+    0x0000000b040b0093ULL,
+    0x0000000000000000ULL,
+    0x0000000004000802ULL,
+    0x00000002c88b0021ULL,
+    0x0000000a828b0423ULL,
+    0x00000010000000a4ULL,
+    0x000000081000006cULL,
+    0x00000000000000c4ULL,
+    0x000000004c0b4091ULL,
+    0x00000008000000a4ULL,
+    0x0000000002000402ULL,
+    0x000000004a8b0021ULL,
+    0x00000010000000a4ULL,
+    0x000000089000006cULL,
+    0x00000000000000c4ULL,
+    0x000000034c0b4091ULL,
+    0x0000000b040b0093ULL,
+    0x00000008000000a4ULL,
+    0x0000000002000402ULL,
+    0x00000002c88b0021ULL,
+    0x0000000a828b0423ULL,
+    0x00000010000000a4ULL,
+    0x000000091000006cULL,
+    0x00000000000000c4ULL,
+    0x000000004c0b4091ULL,
+    0x00000008000000a4ULL,
+    0x0000000002000402ULL,
+    0x000000004a8b0021ULL,
+    0x00000010000000a4ULL,
+    0x0000000990000064ULL,
+    0x000000004a8b0021ULL,
+    0x0000000000898611ULL,
+    0x0000000c000000a4ULL,
+    0x00000000000000c4ULL,
+    0x000000034c0b4091ULL,
+    0x0000000b040b0093ULL,
+    0x00000008000000a4ULL,
+    0x0000000002000402ULL,
+    0x00000002c88b0021ULL,
+    0x0000000a828b0423ULL,
+    0x00000010000000a4ULL,
+    0x0000000a40000064ULL,
+    0x0000000088800021ULL,
+    0x0000000880800423ULL,
+    0x00000000001004a1ULL,
+    0x0000000c000000a4ULL,
+    0x00000002c88b0061ULL,
+    0x0000000a808b0463ULL,
+    0x00000000000000c4ULL,
+    0x00000000058f0011ULL,
+    0x0000000001860002ULL,
+    0x00000010000000a4ULL,
+    0x00000000000000ccULL,
+    0x000000004d8f0021ULL,
+    0x0000000b10000044ULL,
+    0x00000007058f0013ULL,
+    0x0000000001860002ULL,
+    0x00000010000000a4ULL,
+    0x00000000000000ccULL,
+    0x000000034c0f0021ULL,
+    0x0000000b058f0423ULL,
+    0x0000000b70000044ULL,
+    0x0000000000180001ULL,
+    0x000000000b600031ULL,
+    0x00000008000000a4ULL,
+    0x0000000004800041ULL,
+    0x00000008000000a4ULL,
+    0x0000000007c03f41ULL,
+    0x00000000440ac491ULL,
+    0x00000004000000a4ULL,
+    0x00000000000000c4ULL,
+    0x0000000010180001ULL,
+    0x0000000088a00031ULL,
+    0x00000002c3430431ULL,
+    0x00000004000000a4ULL,
+    0x0000000204938041ULL,
+    0x00000008000000a4ULL,
+    0x000000012c002b41ULL,
+    0x0000000117982861ULL,
+    0x0000000088a03631ULL,
+    0x00000002c3430c31ULL,
+    0x00000004000000a4ULL,
+    0x0000000204938041ULL,
+    0x00000008000000a4ULL,
+    0x000000012c002b41ULL,
+    0x0000000347cb2861ULL,
+    0x000000034c09f691ULL,
+    0x00000003040a8491ULL,
+    0x0000000000000000ULL,
+    0x00000000000000c4ULL,
+    0x0000000010180001ULL,
+    0x0000000088a00031ULL,
+    0x00000002c0830431ULL,
+    0x0000000283430431ULL,
+    0x000000080000009cULL,
+    0x0000000204938041ULL,
+    0x00000008000000a4ULL,
+    0x000000012c002b41ULL,
+    0x0000000104202861ULL,
+    0x0000000117d82861ULL,
+    0x0000000088a02f31ULL,
+    0x00000002c0833c31ULL,
+    0x0000002283430c3bULL,
+    0x0000000000000000ULL,
+    0x0000000204938041ULL,
+    0x00000008000000a4ULL,
+    0x000000012c002b41ULL,
+    0x00000003442b2861ULL,
+    0x0000000307cb2861ULL,
+    0x000000034c09ef91ULL,
+    0x000000030409bc91ULL,
+    0x00000003040a8491ULL,
+    0x00000000000000c4ULL,
+    0x0000000010180001ULL,
+    0x0000000088a00031ULL,
+    0x00000002c0830431ULL,
+    0x0000000280830431ULL,
+    0x0000000280c30431ULL,
+    0x0000000004900041ULL,
+    0x0000000283430531ULL,
+    0x0000000a00038007ULL,
+    0x0000000000000000ULL,
+    0x000000012c002b41ULL,
+    0x0000000344202861ULL,
+    0x0000001304032863ULL,
+    0x0000000317db2861ULL,
+    0x00000000b8a02b31ULL,
+    0x00000002c0832831ULL,
+    0x0000000280832831ULL,
+    0x0000000280c33c31ULL,
+    0x0000000004900041ULL,
+    0x0000002e83430d3bULL,
+    0x0000000200038000ULL,
+    0x0000000000000000ULL,
+    0x000000012c002b41ULL,
+    0x00000003442b2861ULL,
+    0x00000013040b2863ULL,
+    0x0000000307cb2861ULL,
+    0x000000037c09eb91ULL,
+    0x000000130409a893ULL,
+    0x000000030409bc91ULL,
+    0x00000003040a849dULL,
+    0x0000000010180001ULL,
+    0x0000000088a00031ULL,
+    0x00000002c0830431ULL,
+    0x0000000280830431ULL,
+    0x0000000280c30431ULL,
+    0x0000000004900041ULL,
+    0x0000000280830531ULL,
+    0x0000001e80830433ULL,
+    0x0000000283430431ULL,
+    0x0000000b2c03ab67ULL,
+    0x0000000344202861ULL,
+    0x0000001304032863ULL,
+    0x0000000317db2861ULL,
+    0x00000002b8a3ab31ULL,
+    0x00000002c0832831ULL,
+    0x0000000280832831ULL,
+    0x0000000280c32831ULL,
+    0x0000000004900041ULL,
+    0x0000000280832931ULL,
+    0x0000001e80832833ULL,
+    0x0000002e83430c3bULL,
+    0x000000032c03ab61ULL,
+    0x00000003442b2861ULL,
+    0x00000013040b2863ULL,
+    0x0000000307cb2861ULL,
+    0x000000037c09eb91ULL,
+    0x000000130409a893ULL,
+    0x000000030409bc91ULL,
+    0x00000003040a849dULL,
+    0x0000000000140001ULL,
+    0x0000004000140001ULL,
+    0x000000000b600061ULL,
+    0x000000400b600061ULL,
+    0x00000004000000a4ULL,
+    0x0000000004800041ULL,
+    0x0000004004800041ULL,
+    0x00000004000000a4ULL,
+    0x0000000007c03f41ULL,
+    0x0000004007c03f41ULL,
+    0x00000000440ac591ULL,
+    0x00000040440ac591ULL,
+    0x0000000000000000ULL,
+    0x00000000000000c4ULL,
+    0x0000000010140001ULL,
+    0x0000004010140001ULL,
+    0x0000000088e00061ULL,
+    0x0000004088e00061ULL,
+    0x00000002c3430561ULL,
+    0x00000042c3430561ULL,
+    0x0000000204938041ULL,
+    0x0000004204938041ULL,
+    0x00000004000000a4ULL,
+    0x000000012c402b41ULL,
+    0x000000412c402b41ULL,
+    0x0000000117f42961ULL,
+    0x0000004117f42961ULL,
+    0x0000000088e03f61ULL,
+    0x0000004088e03f61ULL,
+    0x00000002c3430d61ULL,
+    0x00000042c3430d61ULL,
+    0x0000000204938041ULL,
+    0x0000004204938041ULL,
+    0x00000004000000a4ULL,
+    0x000000012c402b41ULL,
+    0x000000412c402b41ULL,
+    0x0000000347eb2961ULL,
+    0x0000004347eb2961ULL,
+    0x000000034c7dff91ULL,
+    0x000000434c7dff91ULL,
+    0x00000003040a0591ULL,
+    0x00000043040a0591ULL,
+    0x00000000000000c4ULL,
+    0x0000000010140001ULL,
+    0x0000004010140001ULL,
+    0x0000000088e00061ULL,
+    0x0000004088e00061ULL,
+    0x00000002c0c30561ULL,
+    0x00000042c0c30561ULL,
+    0x0000000004900041ULL,
+    0x0000004004900041ULL,
+    0x0000000283430561ULL,
+    0x0000004283430561ULL,
+    0x0000000b2c43ab47ULL,
+    0x000000432c43ab41ULL,
+    0x0000000344602961ULL,
+    0x0000004344602961ULL,
+    0x0000000317d72961ULL,
+    0x0000004317d72961ULL,
+    0x00000002b8e3ab61ULL,
+    0x00000042b8e3ab61ULL,
+    0x00000002c0c32961ULL,
+    0x00000042c0c32961ULL,
+    0x0000000004900041ULL,
+    0x0000004004900041ULL,
+    0x0000000283430d61ULL,
+    0x0000007683430d6bULL,
+    0x000000032c43ab41ULL,
+    0x000000432c43ab41ULL,
+    0x00000003446b2961ULL,
+    0x00000043446b2961ULL,
+    0x0000000307cb2961ULL,
+    0x0000004307cb2961ULL,
+    0x000000037c7de791ULL,
+    0x000000437c7de791ULL,
+    0x0000000304499d91ULL,
+    0x0000004304499d91ULL,
+    0x00000003040a0591ULL,
+    0x00000043040a059dULL,
+    0x0000000048840011ULL,
+    0x00000000028b3691ULL,
+    0x000000000e09c691ULL,
+    0x000000000c09c691ULL,
+    0x0000000000000000ULL,
+    0x00000000000000c4ULL,
+    0x00000000c8840011ULL,
+    0x0000000212ab3691ULL,
+    0x0000000080800411ULL,
+    0x0000000002cb3691ULL,
+    0x000000034c29ef91ULL,
+    0x0000000006098491ULL,
+    0x000000034c09ef91ULL,
+    0x0000000004098491ULL,
+    0x00000000000000c4ULL,
+    0x00000000e8840011ULL,
+    0x0000000210ab3a91ULL,
+    0x0000000880800415ULL,
+    0x00000006128b3699ULL,
+    0x000000034c29eb91ULL,
+    0x0000000f0409a893ULL,
+    0x0000000026098891ULL,
+    0x000000034c09eb91ULL,
+    0x0000000f0409a893ULL,
+    0x000000000409849dULL,
+    0x0000000048841011ULL,
+    0x00000000068b7691ULL,
+    0x000000000e099611ULL,
+    0x000000000c098611ULL,
+    0x0000000000000000ULL,
+    0x00000000000000c4ULL,
+    0x00000000c8840011ULL,
+    0x0000000216ab7691ULL,
+    0x0000000080801411ULL,
+    0x0000000006cb3691ULL,
+    0x000000034c29af11ULL,
+    0x0000000006099411ULL,
+    0x000000034c09af11ULL,
+    0x0000000004098411ULL,
+    0x00000000000000c4ULL,
+    0x00000000e8840011ULL,
+    0x0000000214ab7a91ULL,
+    0x0000000c80800415ULL,
+    0x00000006168b3699ULL,
+    0x0000000080801411ULL,
+    0x00000002168b3691ULL,
+    0x000000034c29ab11ULL,
+    0x0000000f0409a813ULL,
+    0x0000000026099811ULL,
+    0x000000034c09ab11ULL,
+    0x0000000f0409a813ULL,
+    0x000000000409841dULL,
+    0x0000000c000000d4ULL,
+    0x0000000000000000ULL,
+    0x000000004a801011ULL,
+    0x000000000e004691ULL,
+    0x000000000009800dULL,
+    0x0000000c000000d4ULL,
+    0x000000004a801011ULL,
+    0x000000018c004691ULL,
+    0x0000000000800411ULL,
+    0x0000000006003691ULL,
+    0x0000000200098001ULL,
+    0x000000000009800dULL,
+    0x0000000c000000d4ULL,
+    0x000000004a801011ULL,
+    0x000000018c004691ULL,
+    0x0000000c00800415ULL,
+    0x0000000584003699ULL,
+    0x0000000000800411ULL,
+    0x0000000006003691ULL,
+    0x0000000a00098003ULL,
+    0x000000000009800dULL,
+    0x000000200000302aULL,
+    0x00000000000e0012ULL,
+    0x0000000000100211ULL,
+    0x0000000002000002ULL,
+    0x00000006000b0003ULL,
+    0x0000000000000000ULL,
+    0x00000000000000ccULL,
+    0x0000000006000302ULL,
+    0x00000002810b0011ULL,
+    0x0000000a808b0013ULL,
+    0x0000000002010002ULL,
+    0x00000006108b0093ULL,
+    0x0000000002800002ULL,
+    0x00000007040b0013ULL,
+    0x0000000006800002ULL,
+    0x00000007040b0013ULL,
+    0x0000000003000002ULL,
+    0x0000000000090101ULL,
+    0x0000000200098001ULL,
+    0x0000000a000b0003ULL,
+    0x0000000007000302ULL,
+    0x0000000400890015ULL,
+    0x0000000784098019ULL,
+    0x0000000007800002ULL,
+    0x0000000000090001ULL,
+    0x0000000000098101ULL,
+    0x0000001dd000006cULL,
+    0x000000280300060aULL,
+    0x0000000000000000ULL,
+    0x0000000000000e02ULL,
+    0x0000000001000011ULL,
+    0x00000010000000a4ULL,
+    0x0000001dc0000064ULL,
+    0x0000000000000f02ULL,
+    0x0000000001000011ULL,
+    0x0000000002000602ULL,
+    0x0000000680890013ULL,
+    0x0000000002806002ULL,
+    0x0000000004000011ULL,
+    0x000000031489f691ULL,
+    0x0000000804000415ULL,
+    0x000000071489b699ULL,
+    0x0000000006000e02ULL,
+    0x0000000680890013ULL,
+    0x0000000006800e02ULL,
+    0x0000000680898013ULL,
+    0x0000002c0300540aULL,
+    0x0000000007800012ULL,
+    0x00000000000b8000ULL,
+    0x000000000700cd42ULL,
+    0x0000000000800011ULL,
+    0x000000029489f691ULL,
+    0x0000000800800415ULL,
+    0x000000069489b699ULL,
+    0x000000200000e02aULL,
+    0x00000000000000fcULL,
+    0x0000000c000000a4ULL,
+    0x0000001dc0000064ULL,
+    0x000000240000c02aULL,
+    0x0000000002000012ULL,
+    0x0000000600090003ULL,
+    0x00000000000000c4ULL,
+    0x000000001680409dULL,
+    0x0000000014804091ULL,
+    0x000000001680049dULL,
+    0x0000000014804091ULL,
+    0x0000000014800491ULL,
+    0x000000001680049dULL,
+    0x000000001680419dULL,
+    0x0000000014804191ULL,
+    0x000000001680049dULL,
+    0x0000000014804191ULL,
+    0x0000000014800491ULL,
+    0x000000001680049dULL,
+    0x0000000000800011ULL,
+    0x00000000068b5691ULL,
+    0x0000000004098611ULL,
+    0x000000000700dc22ULL,
+    0x0000000000800011ULL,
+    0x0000000296cb569dULL,
+    0x0000000000800011ULL,
+    0x0000000294ab7691ULL,
+    0x0000000000801411ULL,
+    0x00000000068b3691ULL,
+    0x000000034409af11ULL,
+    0x0000000004098411ULL,
+    0x000000000700dc22ULL,
+    0x0000000000800011ULL,
+    0x00000002948b7691ULL,
+    0x0000000000801411ULL,
+    0x0000000296cb369dULL,
+    0x0000000000800011ULL,
+    0x0000000294ab7691ULL,
+    0x0000000000800411ULL,
+    0x00000002948b3691ULL,
+    0x0000000000801411ULL,
+    0x00000000068b3a91ULL,
+    0x000000034409ab11ULL,
+    0x000000030409a411ULL,
+    0x0000000004098411ULL,
+    0x000000000700dc22ULL,
+    0x0000000000800011ULL,
+    0x00000002948b7691ULL,
+    0x0000000000800411ULL,
+    0x00000002948b3691ULL,
+    0x0000000000801411ULL,
+    0x0000000296cb369dULL,
+    0x0000000001000011ULL,
+    0x0000000006098611ULL,
+    0x0000000000000000ULL,
+    0x0000000007000e02ULL,
+    0x0000000000888061ULL,
+    0x0000000003000602ULL,
+    0x0000000000888061ULL,
+    0x00000000000984edULL,
+    0x0000000001000011ULL,
+    0x0000000b8409b615ULL,
+    0x0000000400800419ULL,
+    0x000000000609b611ULL,
+    0x0000000007000e02ULL,
+    0x0000000080800061ULL,
+    0x0000000200cb0461ULL,
+    0x00000000000b8000ULL,
+    0x0000000003000602ULL,
+    0x0000000080800061ULL,
+    0x0000000200cb0461ULL,
+    0x00000000000b8001ULL,
+    0x00000000000985edULL,
+    0x0000000001000011ULL,
+    0x0000000b8409b615ULL,
+    0x0000000400800419ULL,
+    0x000000000609b611ULL,
+    0x0000000007000e02ULL,
+    0x0000000080800061ULL,
+    0x00000002808b0461ULL,
+    0x0000000200cb0461ULL,
+    0x00000000000b8000ULL,
+    0x0000000003000602ULL,
+    0x0000000080800061ULL,
+    0x00000002808b0461ULL,
+    0x0000000200cb0461ULL,
+    0x00000000000b8001ULL,
+    0x00000000000985edULL,
+    0x0000000002800002ULL,
+    0x000000500220220aULL,
+    0x000000140606550aULL,
+    0x000000140606c50aULL,
+    0x0000000002a01202ULL,
+    0x000000500680100aULL,
+    0x000000140286550aULL,
+    0x000000000300d502ULL,
+    0x000000500220340aULL,
+    0x000000140306660aULL,
+    0x000000140686c40aULL,
+    0x000000140206660aULL,
+    0x000000000600dd02ULL,
+    0x000000500720550aULL,
+    0x0000001806064c0aULL,
+    0x000000180306c60aULL,
+    0x0000000002001102ULL,
+    0x000000500020c50aULL,
+    0x000000000600e402ULL,
+    0x000000500220440aULL,
+    0x000000140606cc0aULL,
+    0x000000000320d602ULL,
+    0x000000500100e50aULL,
+    0x000000180086c60aULL,
+    0x00000000000000c4ULL,
+    0x0000000002000002ULL,
+    0x0000005002a0210aULL,
+    0x000000140280540aULL,
+    0x0000000003005502ULL,
+    0x000000500620200aULL,
+    0x000000140680c50aULL,
+    0x0000000002004402ULL,
+    0x0000005003a0cc0aULL,
+    0x0000000002a03702ULL,
+    0x000000500700c50aULL,
+    0x000000140280650aULL,
+    0x000000140280e50aULL,
+    0x000000000000c502ULL,
+    0x000000500120c70aULL,
+    0x000000000200c402ULL,
+    0x0000005000a0d50aULL,
+    0x0000000000000000ULL,
+    0x000000140080410aULL,
+    0x00000000000000c4ULL,
+    0x0000000006009202ULL,
+    0x000000500220a10aULL,
+    0x0000001806064c0aULL,
+    0x0000000002808202ULL,
+    0x0000005006a0a00aULL,
+    0x000000180706d50aULL,
+    0x000000000320cc02ULL,
+    0x000000500280ee0aULL,
+    0x0000000006a0d502ULL,
+    0x000000500780a20aULL,
+    0x000000140386dd0aULL,
+    0x000000000300f602ULL,
+    0x0000005002a0e50aULL,
+    0x000000180306560aULL,
+    0x0000000000000000ULL,
+    0x000000180306760aULL,
+    0x0000001806866d0aULL,
+    0x000000000380f502ULL,
+    0x0000005007a0450aULL,
+    0x000000300281070aULL,
+    0x000000200000502aULL,
+    0x00000000000000fcULL,
+    0x0000000c000000a4ULL,
+    0x0000002bc000006cULL,
+    0x000000000600dc02ULL,
+    0x000000500020e60aULL,
+    0x000000180086fc0aULL,
+    0x000000140107170aULL,
+    0x00000000000000c4ULL,
+    0x000000000200a102ULL,
+    0x000000500620920aULL,
+    0x000000140600c40aULL,
+    0x000000000200a002ULL,
+    0x0000005006a0820aULL,
+    0x000000140680d40aULL,
+    0x000000140200dc0aULL,
+    0x000000000700a202ULL,
+    0x0000005002a0dd0aULL,
+    0x000000000300c402ULL,
+    0x0000005003a0350aULL,
+    0x0000000000000000ULL,
+    0x000000140300670aULL,
+    0x000000000380d502ULL,
+    0x0000005007a0e60aULL,
+    0x0000000000000000ULL,
+    0x0000001407807f0aULL,
+    0x000000000380d102ULL,
+    0x000000500320c00aULL,
+    0x0000000000000000ULL,
+    0x000000140380760aULL,
+    0x0000000003007502ULL,
+    0x0000005002a0d50aULL,
+    0x000000000200f402ULL,
+    0x0000005003a0e50aULL,
+    0x000000300281070aULL,
+    0x000000200000502aULL,
+    0x00000000000000fcULL,
+    0x0000000c000000a4ULL,
+    0x0000002bc000006cULL,
+    0x000000000000df02ULL,
+    0x0000005000a0a60aULL,
+    0x000000140101170aULL,
+    0x000000140080410aULL,
+    0x00000000000000c4ULL,
+    0x000000300281020aULL,
+    0x0000003006810a0aULL,
+    0x0000003006010c0aULL,
+    0x000000200000202aULL,
+    0x00000000000000fcULL,
+    0x0000000c000000a4ULL,
+    0x0000002d1000006cULL,
+    0x000000200000a02aULL,
+    0x00000000000000fcULL,
+    0x0000000c000000a4ULL,
+    0x0000002d5000006cULL,
+    0x000000200000c02aULL,
+    0x00000000000000fcULL,
+    0x0000000c000000a4ULL,
+    0x0000002cd0000064ULL,
+    0x00000034000000d4ULL,
+    0x00000000000000c4ULL,
+    0x0000000001000002ULL,
+    0x00000006000b0003ULL,
+    0x0000000000000000ULL,
+    0x00000000000000c4ULL,
+    0x000000140001180aULL,
+    0x000000140081190aULL,
+    0x0000001401011a0aULL,
+    0x00000000000000c4ULL,
+    0x00000000000000c4ULL,
+    0x0000000001810302ULL,
+    0x0000005005a10b0aULL,
+    0x0000000002000002ULL,
+    0x000000500620110aULL,
+    0x000000140206340aULL,
+    0x000000180606cb0aULL,
+    0x0000000002000402ULL,
+    0x0000005006210c0aULL,
+    0x000000140206c40aULL,
+    0x000000300201040aULL,
+    0x00000000000000c4ULL,
+    0x0000000002801002ULL,
+    0x0000005005a10b0aULL,
+    0x000000140286b50aULL,
+    0x000000140186300aULL,
+    0x0000000002000002ULL,
+    0x000000500620110aULL,
+    0x000000140606c50aULL,
+    0x0000000002003402ULL,
+    0x0000005006210c0aULL,
+    0x000000140206c40aULL,
+    0x000000300201040aULL,
+    0x00000000000000c4ULL,
+    0x000000040400000aULL,
+    0x000000000000002cULL,
+    0x0000000c0000800eULL,
+    0x0000000c0400880aULL,
+    0x000000080000007cULL,
+    0x0000000004000002ULL,
+    0x00000006808b0013ULL,
+    0x0000000000000034ULL,
+    0x0000000000000002ULL,
+    0x0000002ff000005cULL,
+    0x0000002f4000004cULL,
+    0x00000002000b0101ULL,
+    0x0000000a000b0003ULL,
+    0x0000003760000044ULL,
+    0x0000000000000034ULL,
+    0x0000000c0000000aULL,
+    0x0000002ff0000054ULL,
+    0x0000000c0000800aULL,
+    0x0000002fb000004cULL,
+    0x0000003640000044ULL,
+    0x0000000c0000800aULL,
+    0x000000040400000aULL,
+    0x000000000000002cULL,
+    0x0000000c0000800eULL,
+    0x0000000c0400880aULL,
+    0x000000080000007cULL,
+    0x000000040400000aULL,
+    0x000000000000002cULL,
+    0x0000000c0000800eULL,
+    0x0000000c0400880aULL,
+    0x000000080000007cULL,
+    0x0000003640000044ULL,
+    0x000000080180000aULL,
+    0x0000000001820002ULL,
+    0x00000007040b0013ULL,
+    0x000000040200000aULL,
+    0x000000000000002cULL,
+    0x0000000c0180430eULL,
+    0x0000000c0200440aULL,
+    0x000000080000007cULL,
+    0x0000000001010002ULL,
+    0x00000006108b0093ULL,
+    0x0000000005010002ULL,
+    0x00000006108b0093ULL,
+    0x0000000000000000ULL,
+    0x00000032e01f80e4ULL,
+    0x00000034401f81e4ULL,
+    0x00000034601f82e4ULL,
+    0x0000000c0181020aULL,
+    0x0000000c0181030aULL,
+    0x0000001c000000d4ULL,
+    0x0000000000004002ULL,
+    0x0000005000a0410aULL,
+    0x0000000001004202ULL,
+    0x000000500021000aULL,
+    0x0000000000810102ULL,
+    0x000000500121020aULL,
+    0x000000200000202aULL,
+    0x00000000000000fcULL,
+    0x0000000c000000a4ULL,
+    0x0000000000000002ULL,
+    0x0000000600098003ULL,
+    0x0000000000810002ULL,
+    0x0000000610898093ULL,
+    0x0000003760000044ULL,
+    0x0000000004000002ULL,
+    0x00000006808b0013ULL,
+    0x0000000004800102ULL,
+    0x00000006808b0013ULL,
+    0x0000000005000202ULL,
+    0x00000006808b0013ULL,
+    0x0000000000000034ULL,
+    0x0000000000000002ULL,
+    0x000000342000005cULL,
+    0x000000334000004cULL,
+    0x0000001000000084ULL,
+    0x00000006000b0009ULL,
+    0x00000002000b0101ULL,
+    0x0000002000000084ULL,
+    0x00000006000b0009ULL,
+    0x0000003760000044ULL,
+    0x0000000000000034ULL,
+    0x00000034000000d4ULL,
+    0x0000003420000054ULL,
+    0x00000038000000d4ULL,
+    0x00000033e000004cULL,
+    0x00000031d0000044ULL,
+    0x00000038000000d4ULL,
+    0x00000031d0000044ULL,
+    0x00000034000000d4ULL,
+    0x00000031d0000044ULL,
+    0x000000080180000aULL,
+    0x0000000001820002ULL,
+    0x00000007040b0013ULL,
+    0x0000000005840002ULL,
+    0x00000007040b0013ULL,
+    0x0000003c000000d4ULL,
+    0x00000004000000a4ULL,
+    0x000000200000402aULL,
+    0x0000000000000012ULL,
+    0x00000000000b0001ULL,
+    0x0000000000098101ULL,
+    0x0000003760000044ULL,
+    0x000000040200000aULL,
+    0x000000000000002cULL,
+    0x0000000c0000400eULL,
+    0x0000000c0200440aULL,
+    0x000000080000007cULL,
+    0x00000036c01f87e4ULL,
+    0x00000036401f89e4ULL,
+    0x000000040200000aULL,
+    0x000000000000002cULL,
+    0x0000000c0400480eULL,
+    0x0000000c0200440aULL,
+    0x000000080000007cULL,
+    0x00000036a01f86e4ULL,
+    0x000000080180000aULL,
+    0x00000036601f84e4ULL,
+    0x00000036801f85e4ULL,
+    0x000000300001000aULL,
+    0x0000003760000044ULL,
+    0x000000140006800aULL,
+    0x0000003640000044ULL,
+    0x000000180006800aULL,
+    0x0000003640000044ULL,
+    0x0000000c0000800aULL,
+    0x0000003640000044ULL,
+    0x0000000c0181080aULL,
+    0x0000001c000000d4ULL,
+    0x00000004000000a4ULL,
+    0x0000000c0000400aULL,
+    0x0000003640000044ULL,
+    0x0000000c0181000aULL,
+    0x0000001c000000d4ULL,
+    0x00000004000000a4ULL,
+    0x000000140001140aULL,
+    0x0000003640000044ULL,
+    0x0000000c000000a4ULL,
+    0x0000000000000044ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+    0x0000000000000000ULL,
+};
-- 
1.9.1

