From 594de4b87824adbafccd1de8fb56105601483758 Mon Sep 17 00:00:00 2001
From: Jayanthi Annadurai <jayanthia@netlogicmicro.com>
Date: Sun, 20 Mar 2011 12:48:34 -0700
Subject: [PATCH 1321/1532] NAE: Bug fix for mac config and ifconfig crash

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/xlp_hw.c  | 145 ++++++++++++----------------
 drivers/net/ethernet/broadcom/nae/xlp_nae.c |  38 ++++++--
 2 files changed, 93 insertions(+), 90 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/xlp_hw.c b/drivers/net/ethernet/broadcom/nae/xlp_hw.c
index fc0c681..729859b 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_hw.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_hw.c
@@ -49,8 +49,8 @@
 #define DRV_NAME	"xlp_nae"
 #define DRV_VERSION     "0.1"
 
-static void nlm_xlp_mac_mii_write(struct dev_data *priv, int phyaddr, int regidx, unsigned int regval);
-static unsigned int nlm_xlp_mac_mii_read(struct dev_data *priv, int phyaddr, int regidx);
+static void nlm_xlp_mac_mii_write(struct dev_data *priv, int regidx, uint16_t regval);
+static unsigned int nlm_xlp_mac_mii_read(struct dev_data *priv, int regidx);
 void nlm_xlp_mac_set_enable(struct dev_data *priv, int flag);
 static int xlp_enable_autoneg(struct net_device *dev, u32 adv);
 static int xlp_set_link_speed(struct net_device *dev, int speed, int duplex);
@@ -60,7 +60,7 @@ static int xlp_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 	struct dev_data *priv = netdev_priv(dev);
 	int mii_status;
 
-	if ((priv->type == TYPE_XGMAC) || (priv->phy.mode == PHY_MODE_XAUI)){
+	if (priv->type != SGMII_IF) {
 		cmd->supported = SUPPORTED_FIBRE|SUPPORTED_10000baseT_Full;
 		cmd->advertising = SUPPORTED_FIBRE|SUPPORTED_10000baseT_Full;
 		cmd->speed = SPEED_10000;
@@ -81,7 +81,7 @@ static int xlp_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 
 		cmd->advertising = priv->advertising;
 
-		mii_status = nlm_xlp_mac_mii_read(priv, priv->phy.addr, MII_NCONFIG);
+		mii_status = nlm_xlp_mac_mii_read(priv, MII_NCONFIG);
 		priv->speed = (mii_status >> 3) & 0x03;
 
 		cmd->speed = (priv->speed == xlp_mac_speed_1000) ? SPEED_1000 :
@@ -103,15 +103,15 @@ static int xlp_enable_autoneg(struct net_device *dev, u32 adv)
 	struct dev_data *priv = netdev_priv(dev);
 	int mii_status;
 	u32 adv1, adv2;
-    unsigned long flags;
+	unsigned long flags;
 
 	spin_lock_irqsave(&priv->lock, flags);
 	nlm_xlp_mac_set_enable(priv, 0);
 	/* advertising for 10/100 Mbps */
-	adv1 = nlm_xlp_mac_mii_read(priv, priv->phy.addr, MII_ADVERTISE);
+	adv1 = nlm_xlp_mac_mii_read(priv, MII_ADVERTISE);
 	adv1 &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4);
 	/* advertising for 1000 Mbps */
-	adv2 = nlm_xlp_mac_mii_read(priv, priv->phy.addr, 0x9);
+	adv2 = nlm_xlp_mac_mii_read(priv, 0x9);
 	adv2 &= ~(0x300);
 
 	if(adv & ADVERTISED_10baseT_Half)
@@ -129,15 +129,15 @@ static int xlp_enable_autoneg(struct net_device *dev, u32 adv)
 		adv2 |= 0x100;
 
 	/* Set the advertising parameters */
-	nlm_xlp_mac_mii_write(priv, priv->phy.addr, MII_ADVERTISE, adv1);
-	nlm_xlp_mac_mii_write(priv, priv->phy.addr, 0x9, adv2);
+	nlm_xlp_mac_mii_write(priv, MII_ADVERTISE, adv1);
+	nlm_xlp_mac_mii_write(priv, 0x9, adv2);
 
 	priv->advertising = adv1 | adv2;
 
-	mii_status = nlm_xlp_mac_mii_read(priv, priv->phy.addr, MII_BMCR);
+	mii_status = nlm_xlp_mac_mii_read(priv, MII_BMCR);
 	/* enable autoneg and force restart autoneg */
 	mii_status |= (BMCR_ANENABLE | BMCR_ANRESTART);
-	nlm_xlp_mac_mii_write(priv, priv->phy.addr, MII_BMCR, mii_status);
+	nlm_xlp_mac_mii_write(priv, MII_BMCR, mii_status);
 
 	nlm_xlp_mac_set_enable(priv, 1);
 	spin_unlock_irqrestore(&priv->lock, flags);
@@ -183,7 +183,7 @@ static int xlp_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 	int ret;
 	struct dev_data *priv = netdev_priv(dev);
 
-	if ((priv->type == TYPE_XGMAC) || (priv->phy.mode == PHY_MODE_XAUI)){
+	if (priv->type != SGMII_IF) {
 		return -EIO;
 	}
 	if (cmd->autoneg == AUTONEG_ENABLE) {
@@ -236,31 +236,31 @@ static int xlp_nway_reset(struct net_device *dev)
 	unsigned long flags;
 	int ret = -EINVAL;
 
-   if ((priv->type == TYPE_XGMAC) || (priv->phy.mode == PHY_MODE_XAUI))
-    return -EIO;
+	if (priv->type != SGMII_IF)
+		return -EIO;
 
 	spin_lock_irqsave(&priv->lock, flags);
-	mii_status = nlm_xlp_mac_mii_read(priv, priv->phy.addr, MII_BMCR);
+	mii_status = nlm_xlp_mac_mii_read(priv, MII_BMCR);
 	if(mii_status & BMCR_ANENABLE)
 	{
-		nlm_xlp_mac_mii_write(priv, priv->phy.addr,
+		nlm_xlp_mac_mii_write(priv,
 				MII_BMCR, BMCR_ANRESTART | mii_status);
 		ret = 0;
 	}
 	spin_unlock_irqrestore(&priv->lock, flags);
 	return ret;
 }
+
 static u32 xlp_get_link(struct net_device *dev)
 {
 	struct dev_data *priv = netdev_priv(dev);
 	int mii_status;
 	unsigned long flags;
-
-   if ((priv->type == TYPE_XGMAC) || (priv->phy.mode == PHY_MODE_XAUI))
-    return -EIO;
+	if (priv->type != SGMII_IF)
+		return -EIO;
 
 	spin_lock_irqsave(&priv->lock, flags);
-	mii_status = nlm_xlp_mac_mii_read(priv, priv->phy.addr, MII_BMSR);
+	mii_status = nlm_xlp_mac_mii_read(priv, MII_BMSR);
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 
@@ -311,7 +311,7 @@ static void xlp_get_strings (struct net_device *dev, u32 stringset, u8 *buf)
 		break;
 	default:
 		printk(KERN_WARNING "%s: Invalid stringset %d\n",
-				__FUNCTION__, stringset);
+				__func__, stringset);
 		break;
 	}
 }
@@ -326,6 +326,9 @@ void xlp_get_mac_stats(struct net_device *dev, struct net_device_stats *stats)
 {
 	struct dev_data *priv = netdev_priv(dev);
 
+	if (priv->type != SGMII_IF)
+		return;
+
 	stats->tx_errors = nlm_hal_read_mac_reg( priv->block, priv->index, TX_FCS_ERROR_COUNTER);
 	stats->rx_dropped = nlm_hal_read_mac_reg( priv->block, priv->index, RX_DROP_PACKET_COUNTER);
 	stats->tx_dropped = nlm_hal_read_mac_reg( priv->block, priv->index, TX_DROP_FRAME_COUNTER);
@@ -339,8 +342,10 @@ void xlp_get_mac_stats(struct net_device *dev, struct net_device_stats *stats)
 	stats->rx_missed_errors = nlm_hal_read_mac_reg( priv->block, priv->index,RX_CARRIER_SENSE_ERROR_COUNTER);
 	stats->rx_errors = (stats->rx_over_errors + stats->rx_crc_errors + stats->rx_frame_errors + stats->rx_fifo_errors +stats->rx_missed_errors);
 	stats->tx_aborted_errors = nlm_hal_read_mac_reg( priv->block, priv->index, TX_EXCESSIVE_COLLISION_PACKET_COUNTER);
+	/*
 	stats->tx_carrier_errors = nlm_hal_read_mac_reg( priv->block, priv->index, TX_DROP_FRAME_COUNTER);
 	stats->tx_fifo_errors = nlm_hal_read_mac_reg( priv->block, priv->index, TX_DROP_FRAME_COUNTER);
+	*/
 	return;
 }
 
@@ -356,7 +361,7 @@ static void xlp_get_ethtool_stats (struct net_device *dev,
 	struct dev_data *priv = netdev_priv(dev);
 	unsigned long flags;
 	unsigned long *tmp_stats;
-
+	
 	spin_lock_irqsave(&priv->lock, flags);
 
 	xlp_get_mac_stats(dev, &priv->stats);
@@ -383,31 +388,9 @@ static void xlp_get_ethtool_stats (struct net_device *dev,
  *  Return value:
  *  	   value read (16 bits), or 0xffffffff if an error occurred.
  ********************************************************************* */
-static unsigned int nlm_xlp_mac_mii_read(struct dev_data *priv, int phyaddr, int regidx)
+static unsigned int nlm_xlp_mac_mii_read(struct dev_data *priv, int regidx)
 {
-	int i;
-
-	/* setup the phy reg to be used */
-	nlm_hal_write_mac_reg(priv->block, priv->index, R_MII_MGMT_ADDRESS,(phyaddr << 8) | (regidx << 0));
-
-	/* Issue the read command */
-	nlm_hal_write_mac_reg(priv->block, priv->index, R_MII_MGMT_COMMAND,(1 << O_MII_MGMT_COMMAND__rstat));
-
-	/* poll for the read cycle to complete */
-	for (i = 0; i < PHY_STATUS_RETRIES; i++) {
-		if (nlm_hal_read_mac_reg(priv->block, priv->index, R_MII_MGMT_INDICATORS) == 0)
-			break;
-	}
-
-	/* clear the read cycle */
-	nlm_hal_write_mac_reg(priv->block, priv->index, R_MII_MGMT_COMMAND, 0);
-
-	if (i == PHY_STATUS_RETRIES) {
-		return 0xffffffff;
-	}
-
-	/* Read the data back */
-	return nlm_hal_read_mac_reg(priv->block, priv->index, R_MII_MGMT_STATUS);
+        return nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, regidx);
 }
 
 /**********************************************************************
@@ -415,28 +398,15 @@ static unsigned int nlm_xlp_mac_mii_read(struct dev_data *priv, int phyaddr, int
  *
  *  Input parameters:
  *  	   priv - priv structure
- *  	   phyaddr - PHY to use
  *  	   regidx - register within the PHY
  *  	   regval - data to write to register
  *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
-static void nlm_xlp_mac_mii_write(struct dev_data *priv, int phyaddr, int regidx, unsigned int regval)
+static void nlm_xlp_mac_mii_write(struct dev_data *priv, int regidx, uint16_t regval)
 {
-	int i = 0;
-
-	nlm_hal_write_mac_reg(priv->block, priv->index, R_MII_MGMT_ADDRESS,(phyaddr << 8) | (regidx << 0));
-
-	/* Write the data which starts the write cycle */
-	nlm_hal_write_mac_reg(priv->block, priv->index, R_MII_MGMT_WRITE_DATA, regval);
-
-	/* poll for the write cycle to complete */
-	for (i = 0; i < PHY_STATUS_RETRIES; i++) {
-		if (nlm_hal_read_mac_reg(priv->block, priv->index, R_MII_MGMT_INDICATORS) == 0)
-			break;
-	}
-
+	nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, regidx, regval);
 	return;
 }
 
@@ -465,31 +435,38 @@ void xlp_set_ethtool_ops(struct net_device *netdev)
  **********************************************************************/
 void nlm_xlp_mac_set_enable(struct dev_data *priv, int flag)
 {
-	uint32_t regval;
-	int tx_threshold = 512;
+	int inf;
+	uint32_t speed = 0, duplex = 0, ifmode = 0;
+	uint32_t netwk_inf = 0, mac_cfg2 = 0;
+	
+
+	if (priv->type != SGMII_IF)
+		return;
+	inf = (priv->block * 4) + priv->index;
 
 	if (flag) {
-		regval = nlm_hal_read_mac_reg(priv->block, priv->index, R_TX_CONTROL);
-		regval &= ~(0x3fff);
-		regval |= (1 << O_TX_CONTROL__TxEnable) |
-			(tx_threshold << O_TX_CONTROL__TxThreshold);
-
-		nlm_hal_write_mac_reg(priv->block, priv->index, R_TX_CONTROL, regval);
-
-		regval = nlm_hal_read_mac_reg(priv->block, priv->index, R_RX_CONTROL);
-		regval |= 1 << O_RX_CONTROL__RxEnable;
-		if (priv->phy.serdes_addr != 0 && (priv->phy.mode & PHY_MODE_RGMII))
-			regval |= 1 << O_RX_CONTROL__RGMII;
-		nlm_hal_write_mac_reg(priv->block, priv->index, R_RX_CONTROL, regval);
+		if (nlm_hal_get_phy_status(inf, &speed, &duplex)) {
+			//nlm_print("mac set enable speed %d duplex %d\n",speed, duplex);
+			ifmode = ((speed == 2) ? 2: 1);
+			nlm_hal_mac_disable(inf, priv->type);
+		        netwk_inf  = read_gmac_reg(inf, NETWK_INF_CTRL_REG);
+	        	netwk_inf &= (~(0x3));
+	        	write_gmac_reg(inf , NETWK_INF_CTRL_REG, netwk_inf | speed);
+		        mac_cfg2 = read_gmac_reg(inf, MAC_CONF2);
+        		mac_cfg2 &= (~((0x3 << 8) | 1));
+	        	write_gmac_reg(inf , MAC_CONF2,
+                               mac_cfg2 | (ifmode << 8) | duplex);
+		}
+		nlm_hal_mac_enable(inf, priv->type);
 	} else {
-		regval = nlm_hal_read_mac_reg(priv->block, priv->index, R_TX_CONTROL);
-		regval &= ~((1 << O_TX_CONTROL__TxEnable) |
-			    (tx_threshold << O_TX_CONTROL__TxThreshold));
-
-		nlm_hal_write_mac_reg(priv->block, priv->index, R_TX_CONTROL, regval);
-
-		regval = nlm_hal_read_mac_reg(priv->block, priv->index, R_RX_CONTROL);
-		regval &= ~(1 << O_RX_CONTROL__RxEnable);
-		nlm_hal_write_mac_reg(priv->block, priv->index, R_RX_CONTROL, regval);
+		nlm_hal_mac_disable(inf, priv->type);
 	}
 }
+
+int nlm_xlp_link_up(struct dev_data *priv, int phy)
+{
+        uint16_t extstatus;
+        nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, 22, 0);
+        extstatus = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, 17);
+        return ((extstatus & 0x0400) ? 1 : 0 );
+}
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index 57064dd..a95a785 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -432,6 +432,7 @@ static void nlm_xlp_nae_init(void)
 		ether_setup(dev);
 
 		priv = netdev_priv(dev);
+		spin_lock_init(&priv->lock);
 		priv->dev 	= dev;
 		dev->netdev_ops = &nlm_xlp_nae_ops;
 
@@ -448,9 +449,25 @@ static void nlm_xlp_nae_init(void)
 		atomic64_set(&priv->total_frin_sent, 0);
 
 		priv->inited	= 0;
-		priv->block 	=(i & 0xff) >> 2;
-		priv->index 	= i & 0x3;
-
+		priv->block 	= nae_cfg.ports[i].hw_port_id / 4;
+		priv->type = nae_cfg.ports[i].iftype;
+		switch(nae_cfg.ports[i].iftype) {
+			case SGMII_IF:
+				priv->index = nae_cfg.ports[i].hw_port_id & 0x3;
+				priv->phy.addr = nae_cfg.ports[i].hw_port_id;
+				break;
+			case XAUI_IF:
+				priv->index = XGMAC;
+				break;	
+			case INTERLAKEN_IF:
+				priv->index = INTERLAKEN;
+				break;
+			default:
+				priv->index=0;
+				break;
+		}
+		//nlm_print("port%d hw %d block %d index %d type %d \n",i, nae_cfg.ports[i].hw_port_id, 
+		//							priv->block, priv->index, priv->type);
 		priv->nae_tx_qid 	= nae_cfg.ports[i].txq_range[0];
 		priv->nae_rx_qid 	= nae_cfg.ports[i].rxq;
 
@@ -516,6 +533,7 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 	priv->link_timer.function = &nlm_xlp_mac_timer;
 	priv->phy_oldlinkstat = -1;
 
+	netif_tx_start_all_queues(dev);
 	add_timer(&priv->link_timer);
 
 /*	napi_enable(&priv->napi);*/
@@ -539,8 +557,8 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 		priv->cpu_stats[i].interrupts	= 0;
 
 	}
-
 	priv->inited = 1;
+	nlm_xlp_mac_set_enable(priv, 1);
 
  out:
 	return ret;
@@ -557,11 +575,12 @@ static int  nlm_xlp_nae_stop (struct net_device *dev)
 
 	spin_lock_irq(&priv->lock);
 	nlm_xlp_mac_set_enable(priv, 0);
-
+	priv->inited = 0;
 	del_timer_sync(&priv->link_timer);
+
 	netif_tx_stop_all_queues(dev);
 
-	napi_disable(&priv->napi);
+//	napi_disable(&priv->napi);
 	spin_unlock_irq(&priv->lock);
 	return 0;
 }
@@ -838,6 +857,12 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		len	= (msg1 >> 40) & 0x3fff;
 		context = (msg1 >> 54) & 0x3ff;
 
+		if (addr == 0) {
+			printk("Rcvd pkt address NULL !!!\n");
+			printk("[%s] src_id=%d vc = %d, size = %d, entry0=%llx entry1=%llx\n", __func__,
+                       src_id, vc, size, msg0, msg1);
+			return;	
+		}
 		if (err) bad_pkt = 1;
 
 		if (drop_uboot_pkt) {
@@ -1008,6 +1033,7 @@ static void nlm_xlp_mac_timer(unsigned long data)
         int next_tick = HZ / 1000; /* 1ms */
 
 	/* printk("[%s] A0 Workaround, forcing FMN int handling \n",__func__); */
+	if (priv->inited)
 	{
 		uint32_t cpumask = cpumask_to_uint32(&cpu_present_map); /* doesn't handle non-n0 nodes */
 		uint32_t cpumask_lo;
-- 
1.9.1

