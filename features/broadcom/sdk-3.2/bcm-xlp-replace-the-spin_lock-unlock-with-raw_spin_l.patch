From b359562871240cba2d901a373aeb1dd05fe5f2a7 Mon Sep 17 00:00:00 2001
From: Quanyang Wang <quanyang.wang@windriver.com>
Date: Mon, 30 Mar 2015 22:08:41 +0800
Subject: [PATCH 06/14] bcm-xlp: replace the spin_lock/unlock with
 raw_spin_lock/unlock

If use the old one we may get the following errors:

CPU: 0 PID: 854 Comm: rc Tainted: G        W    3.10.62-ltsi-rt55-WR6.0.0.0_preempt-rt #14^M
Stack : c0000007f3f80000 ffffffffc02b84b0 0000000000000000 ffffffffc0e90000
  0000000000000000 000000000000005a 0000000000000006 0000000000000000
  c0000007f4c8f968 ffffffffc032b964 0000000000000000 ffffffffc0e90000
  c0000007f4c8f988 ffffffffc02b84b0 0000000000000000 0000000000000000
  0000000000000000 0000000000000000 ffffffffc1290000 ffffffffc1290000
  ffffffffc0c91808 ffffffffc0e83c97 ffffffffc128ca98 c0000007f3f803a8
  0000000000000356 0000000000000000 c0000007edc03000 0000000000000000
  c0000007f4c8fa08 c0000007f4c8f918 c0000007f4c8fa30 ffffffffc0aee230
  c0000007f4c8fa68 ffffffffc02ba3b0 c0000007f3f80000 ffffffffc0c91808
  0000000000000000 ffffffffc0288438 0000000000000000 0000000000000000
  ...
Call Trace:^M
[<ffffffffc0288438>] show_stack+0xd8/0xf8
[<ffffffffc0aee230>] rt_spin_lock+0x40/0xb8
[<ffffffffc0100d38>] xlp_pic_disable+0x40/0xf8
[<ffffffffc0371080>] irq_shutdown+0x50/0x90
[<ffffffffc036d788>] __free_irq+0x1e8/0x238
[<ffffffffc036d8f4>] free_irq+0x74/0x118
[<ffffffffc07124d0>] serial8250_shutdown+0x278/0x2b8
[<ffffffffc070a828>] uart_port_shutdown+0x48/0x68
[<ffffffffc070a944>] uart_shutdown+0xfc/0x160
[<ffffffffc070c8ac>] uart_close+0x84/0x270
[<ffffffffc06e8a5c>] tty_release+0x174/0x630
[<ffffffffc0435a34>] __fput+0xdc/0x2a0
[<ffffffffc02eb6b4>] task_work_run+0x10c/0x178
[<ffffffffc02be1f4>] do_exit+0x31c/0xc08
[<ffffffffc02beba0>] do_group_exit+0x60/0xd8
[<ffffffffc02bec40>] __wake_up_parent+0x0/0x40

Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/include/asm/mach-netlogic/multi-node.h |    2 +-
 arch/mips/netlogic/common/irq.c                  |   17 +++++++++--------
 arch/mips/netlogic/xlp/nlm_hal.c                 |    2 +-
 3 files changed, 11 insertions(+), 10 deletions(-)

diff --git a/arch/mips/include/asm/mach-netlogic/multi-node.h b/arch/mips/include/asm/mach-netlogic/multi-node.h
index 9ed8dac..d157bc0 100644
--- a/arch/mips/include/asm/mach-netlogic/multi-node.h
+++ b/arch/mips/include/asm/mach-netlogic/multi-node.h
@@ -64,7 +64,7 @@ struct nlm_soc_info {
 	uint64_t	irqmask;	/* EIMR for the node */
 	uint64_t	sysbase;	/* only for XLP - sys block base */
 	uint64_t	picbase;	/* PIC block base */
-	spinlock_t	piclock;	/* lock for PIC access */
+	raw_spinlock_t	piclock;	/* lock for PIC access */
 	cpumask_t	cpumask;	/* logical cpu mask for node */
 	unsigned int	socbus;
 };
diff --git a/arch/mips/netlogic/common/irq.c b/arch/mips/netlogic/common/irq.c
index 26532b9..2e5099e 100644
--- a/arch/mips/netlogic/common/irq.c
+++ b/arch/mips/netlogic/common/irq.c
@@ -92,9 +92,9 @@ static void xlp_pic_enable(struct irq_data *d)
 	struct nlm_pic_irq *pd = irq_data_get_irq_handler_data(d);
 
 	BUG_ON(!pd);
-	spin_lock_irqsave(&pd->node->piclock, flags);
+	raw_spin_lock_irqsave(&pd->node->piclock, flags);
 	nlm_pic_enable_irt(pd->node->picbase, pd->irt);
-	spin_unlock_irqrestore(&pd->node->piclock, flags);
+	raw_spin_unlock_irqrestore(&pd->node->piclock, flags);
 }
 
 static void xlp_pic_disable(struct irq_data *d)
@@ -103,9 +103,9 @@ static void xlp_pic_disable(struct irq_data *d)
 	unsigned long flags;
 
 	BUG_ON(!pd);
-	spin_lock_irqsave(&pd->node->piclock, flags);
+	raw_spin_lock_irqsave(&pd->node->piclock, flags);
 	nlm_pic_disable_irt(pd->node->picbase, pd->irt);
-	spin_unlock_irqrestore(&pd->node->piclock, flags);
+	raw_spin_unlock_irqrestore(&pd->node->piclock, flags);
 }
 
 static void xlp_pic_mask_ack(struct irq_data *d)
@@ -113,24 +113,25 @@ static void xlp_pic_mask_ack(struct irq_data *d)
 	struct nlm_pic_irq *pd = irq_data_get_irq_handler_data(d);
 	unsigned long flags;
 
-	spin_lock_irqsave(&pd->node->piclock, flags);
+	raw_spin_lock_irqsave(&pd->node->piclock, flags);
 	nlm_pic_disable_irt(pd->node->picbase, pd->irt);
-	spin_unlock_irqrestore(&pd->node->piclock, flags);
+	raw_spin_unlock_irqrestore(&pd->node->piclock, flags);
 	ack_c0_eirr(pd->picirq);
 }
 
 static void xlp_pic_unmask(struct irq_data *d)
 {
 	struct nlm_pic_irq *pd = irq_data_get_irq_handler_data(d);
+	unsigned long flags;
 
 	BUG_ON(!pd);
 
 	if (pd->extra_ack)
 		pd->extra_ack(d);
 
-	spin_lock_irqsave(&pd->node->piclock, flags);
+	raw_spin_lock_irqsave(&pd->node->piclock, flags);
 	nlm_pic_enable_irt(pd->node->picbase, pd->irt);
-	spin_unlock_irqrestore(&pd->node->piclock, flags);
+	raw_spin_unlock_irqrestore(&pd->node->piclock, flags);
 
 	/* Ack is a single write, no need to lock */
 	nlm_pic_ack(pd->node->picbase, pd->irt);
diff --git a/arch/mips/netlogic/xlp/nlm_hal.c b/arch/mips/netlogic/xlp/nlm_hal.c
index a84f563..e750fb1 100644
--- a/arch/mips/netlogic/xlp/nlm_hal.c
+++ b/arch/mips/netlogic/xlp/nlm_hal.c
@@ -63,7 +63,7 @@ void nlm_node_init(int node)
 		nodep->socbus = xlp9xx_get_socbus(node);
 	else
 		nodep->socbus = 0;
-	spin_lock_init(&nodep->piclock);
+	raw_spin_lock_init(&nodep->piclock);
 }
 
 static int xlp9xx_irq_to_irt(int irq)
-- 
1.7.5.4

