From 36eecc33da880b71a85e6e3195c4b613d1732a1c Mon Sep 17 00:00:00 2001
From: Hareesh R <hareeshr@broadcom.com>
Date: Wed, 19 Nov 2014 19:31:46 +0530
Subject: [PATCH 1252/1532] xlp9xx:Change in interrupt ack

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../misc/netlogic/nlm_msgring/nlm_msgring_main.c   | 66 +++++++++++++++++++++-
 drivers/misc/netlogic/soc_interface/on_chip.c      |  6 +-
 2 files changed, 67 insertions(+), 5 deletions(-)

diff --git a/drivers/misc/netlogic/nlm_msgring/nlm_msgring_main.c b/drivers/misc/netlogic/nlm_msgring/nlm_msgring_main.c
index 66137ec..0fdb6bb 100644
--- a/drivers/misc/netlogic/nlm_msgring/nlm_msgring_main.c
+++ b/drivers/misc/netlogic/nlm_msgring/nlm_msgring_main.c
@@ -56,6 +56,8 @@
 static int msgring_major;
 static wait_queue_head_t msgring_wq[NR_CPUS];
 static int msgring_status[NR_CPUS];
+static int msgring_genid[NR_CPUS];
+static int msgring_genid_rd[NR_CPUS];
 static DEFINE_MUTEX(msgrng_mutex);
 static int msgring_timeout[NR_CPUS];
 
@@ -77,8 +79,12 @@ extern int nlm_xlp_register_intr_vc(int cpu, int vc);
 
 static int msgring_event(int vc)
 {
+	/* Msgring timeout will make sure the corner case
+	*  where the msgring_status is about to set 1 but
+	*  we got the interrrupt. */
 	int cpu = hard_smp_processor_id();
-	if(msgring_status[cpu] != 1)
+//	printk("%s in vc %d cpu %d\n", __FUNCTION__, vc, cpu);
+	if(msgring_status[cpu] != 1) 
 		return 0;
 	msgring_status[cpu] = 0;
 	wake_up_interruptible(&msgring_wq[cpu]);
@@ -91,6 +97,12 @@ static ssize_t msgring_read (struct file *filp, char __user *buf, size_t count,
 	unsigned int val;
 	unsigned long flags;
 
+	unsigned int timeout = -1;
+	if(buf) {
+		copy_from_user(&timeout, buf, sizeof(timeout));
+		msgring_timeout[cpu] = timeout;
+	}
+
 #ifdef CONFIG_32BIT
 	unsigned long mflags;
 #endif
@@ -100,6 +112,21 @@ static ssize_t msgring_read (struct file *filp, char __user *buf, size_t count,
 	msgrng_access_enable(mflags);
 #endif
 
+//	printk("%s in cpu %d gen %d : %d, timeout %d\n", __FUNCTION__, cpu, 
+//			msgring_genid[cpu], msgring_genid_rd[cpu], msgring_timeout[cpu]);
+
+	/* There was a request just before disabling the interrupt
+	*  on this cpu */
+	if(msgring_genid[cpu] != msgring_genid_rd[cpu]) {
+
+		msgring_genid_rd[cpu] = msgring_genid[cpu];
+#ifdef CONFIG_32BIT
+		msgrng_access_disable(mflags);
+#endif
+		local_irq_restore(flags);
+		return 1;
+	}
+	
 	msgring_status[cpu] = 1;
 
 	/* Enable intr on the vcs */
@@ -112,25 +139,55 @@ static ssize_t msgring_read (struct file *filp, char __user *buf, size_t count,
 	else if (xlp9xx_family) {
 	    /* works for xlp9xx_family- 9xx RC and 5xx RC*/
 	    /*TODO: Check for newer chips*/
-	    val =  _read_32bit_cp2_register(XLP_MSG_INT_REG);
-	    val |= (intr_vc_mask[cpu]);
+		val = 0xf;
 	    _write_32bit_cp2_register(XLP_MSG_INT_REG, val);
 	}
 	else {
 	    printk("xlp_nlm_msgring driver: Error Unknown chip");
 	}
 
+	msgring_genid_rd[cpu] = msgring_genid[cpu];
 #ifdef CONFIG_32BIT
 	msgrng_access_disable(mflags);
 #endif
 	local_irq_restore(flags);
+
 	if(msgring_timeout[cpu] < 0)
 		 wait_event_interruptible(msgring_wq[cpu], (msgring_status[cpu] == 0));
 	else
 		 wait_event_interruptible_timeout(msgring_wq[cpu], (msgring_status[cpu] == 0), msgring_timeout[cpu]);
+//	printk("%s out cpu %d gen %d : %d, timeout %d\n", __FUNCTION__, cpu, 
+//			msgring_genid[cpu], msgring_genid_rd[cpu], msgring_timeout[cpu]);
+
 	return 1;
 }
 
+void msgring_func(void *info)
+{
+	/* Called in interrupt context */
+	int cpu = (long)info;
+//	printk("%s in cpu %d\n", __FUNCTION__, cpu);
+	msgring_genid[cpu]++;
+	if(msgring_status[cpu] != 1)
+		return;
+	msgring_status[cpu] = 0;
+	wake_up_interruptible(&msgring_wq[cpu]);
+	return 0;
+}
+
+static ssize_t msgring_write(struct file *fp, 
+		const char __user *buf, size_t length, loff_t *offset)
+{
+	unsigned int cpu;
+//	printk("%s in\n", __FUNCTION__);
+	if(buf) {
+		copy_from_user(&cpu, buf, sizeof(cpu));
+		/* No need to wait here */
+		smp_call_function_single(cpu, msgring_func, (void *)(long)cpu, 0);
+	}
+	return 0;
+}
+
 static int msgring_open (struct inode *inode, struct file *filp)
 {
 	return 0;
@@ -141,6 +198,8 @@ static int msgring_release (struct inode *inode, struct file *filp)
 	return 0;
 }
 
+
+
 static long msgring_ioctl(struct file *filp, unsigned int cmd,
 		   unsigned long arg)
 {
@@ -195,6 +254,7 @@ static long msgring_compat_ioctl(struct file *filp, unsigned int cmd, unsigned l
 static struct file_operations msgring_fops = {
 	owner:		THIS_MODULE,
 	read:		msgring_read,
+	write:		msgring_write,
 	open:  		msgring_open,
 	unlocked_ioctl:	msgring_ioctl,
 	compat_ioctl:   msgring_compat_ioctl,
diff --git a/drivers/misc/netlogic/soc_interface/on_chip.c b/drivers/misc/netlogic/soc_interface/on_chip.c
index 7f2251a..c7647c4 100644
--- a/drivers/misc/netlogic/soc_interface/on_chip.c
+++ b/drivers/misc/netlogic/soc_interface/on_chip.c
@@ -863,6 +863,7 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	int pop_vc_mask = nlm_cpu_vc_mask[cpu];
 	uint32_t napi_vc_mask = xlp_napi_vc_mask & pop_vc_mask;
 	unsigned int vcmask;
+	unsigned int intr_vc_pend_mask = intr_vc_mask[cpu];
 
 	msg0 = msg1 = msg2 = msg3 = 0;
 
@@ -890,6 +891,7 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 					continue;
 				/*Don't acknowledge MSG RING interrupt when
 				  intr_vc_handler returns 1*/
+				intr_vc_pend_mask &= (~(1 << vc));
 				if(xlp_intr_vc_handler(vc) == 1){
 					pop_vc_mask = pop_vc_mask & ~(1<<vc);
 				}
@@ -928,7 +930,7 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 
 	/* Clear VC interrupt status by writing 1s */
         if (is_cpu_core_xlp_ii) {
-                xlp_write_msg_int((pop_vc_mask));
+                xlp_write_msg_int((pop_vc_mask | intr_vc_pend_mask));
         } else {
                 xlp_write_status1( (msg_status1 | (pop_vc_mask << 16)) );
         }
@@ -1263,7 +1265,7 @@ int xlp_fmn_poll(struct napi_struct *napi, int budget)
 		msgrng_access_enable(mflags);
 
 		if (is_cpu_core_xlp_ii) {
-                	xlp_write_msg_int(napi_vc_mask);
+                	xlp_write_msg_int(napi_vc_mask | intr_vc_mask[cpu]);
 		}
 		else {
 			/* Need write vc into the register */
-- 
1.9.1

