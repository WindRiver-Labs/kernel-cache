From ca35ceea45b14c7122645fe28356e9e07ac616fb Mon Sep 17 00:00:00 2001
From: "P. Sadik" <psadik@broadcom.com>
Date: Fri, 13 Dec 2013 17:26:05 +0530
Subject: [PATCH 1433/1532] nae: Jumbo support for XFI.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/xlpge_nae.c | 26 +++++++++++++-------------
 1 file changed, 13 insertions(+), 13 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_nae.c b/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
index 39ef4c4..72c96e8 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
@@ -389,7 +389,7 @@ static int initialize_nae_per_node(nae_t * nae_cfg, uint32_t *phys_cpu_map, int
 	for (i = 0; i <= NLM_NAE_MAX_SHARED_DOMS; i++) {
 		 cpus += nae_cfg->shinfo[i].num_cpus;
 	}
-	size = ((NLM_NAE_MAX_SHARED_DOMS + 1) * (sizeof(struct nlm_nae_linux_shinfo))) + 
+	size = ((NLM_NAE_MAX_SHARED_DOMS + 1) * (sizeof(struct nlm_nae_linux_shinfo))) +
 		(sizeof(unsigned int) * cpus);
 	mem = kmalloc(size, GFP_KERNEL);
 	if(!mem)
@@ -442,29 +442,29 @@ static int initialize_nae_per_node(nae_t * nae_cfg, uint32_t *phys_cpu_map, int
 
 		if (lnx_frfifo_jumbo_mask[node][nae_id]) {
 			for(cpus = 0; cpus < lnx_shinfo[0]->num_cpus; cpus++) {
-				lcpu_2_pcpu[cpus] = (lnx_shinfo[0]->fwd_info[cpus] >> 
+				lcpu_2_pcpu[cpus] = (lnx_shinfo[0]->fwd_info[cpus] >>
 					NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_PCPU_OFF) &
 					NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_PCPU_MASK;
 			}
 			memset(fmem, 0, sizeof(fmem));
-			if(derive_cpu_to_freein_fifo_map(nae_cfg->frin_total_queue, 
+			if(derive_cpu_to_freein_fifo_map(nae_cfg->frin_total_queue,
 						   lnx_shinfo[0]->num_cpus,
 						   fmem, sizeof(fmem),
-			               lcpu_2_pcpu, lnx_frfifo_normal_mask[node][nae_id], 
+			               lcpu_2_pcpu, lnx_frfifo_normal_mask[node][nae_id],
 						   cpu_2_normal_frfifo[node][nae_id]) != 0) {
 				goto err;
 			}
 			memset(fmem, 0, sizeof(fmem));
-			if(derive_cpu_to_freein_fifo_map(nae_cfg->frin_total_queue, 
+			if(derive_cpu_to_freein_fifo_map(nae_cfg->frin_total_queue,
 						   lnx_shinfo[0]->num_cpus,
 						   fmem, sizeof(fmem),
-			               lcpu_2_pcpu, lnx_frfifo_jumbo_mask[node][nae_id], 
+			               lcpu_2_pcpu, lnx_frfifo_jumbo_mask[node][nae_id],
 						   cpu_2_jumbo_frfifo[node][nae_id]) != 0) {
 				goto err;
 			}
 
 			for(cpus = 0; cpus < lnx_shinfo[0]->num_cpus; cpus++) {
-				lnx_shinfo[0]->fwd_info[cpus] =  
+				lnx_shinfo[0]->fwd_info[cpus] =
 					(lcpu_2_pcpu[cpus] << NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_PCPU_OFF) |
 					(cpu_2_normal_frfifo[node][nae_id][cpus] << NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_RF_OFF)|
 					(cpu_2_jumbo_frfifo[node][nae_id][cpus] << NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_JF_OFF);
@@ -497,7 +497,7 @@ static int initialize_nae_per_node(nae_t * nae_cfg, uint32_t *phys_cpu_map, int
 		if(netsoc_write_ucore_shmem(nae_cfg,
 			(uint32_t *)lnx_shinfo[0],  size/sizeof(uint32_t)) != 0) {
 			printk("Error, Write ucore sram failed!!!, size %d\n", size);
-		} else 
+		} else
 			printk("Write ucore sram success, size %d\n", size);
 
 		netsoc_restart_ucore_using_fdt(nae_cfg, fdt);
@@ -539,7 +539,7 @@ static int initialize_nae_per_node(nae_t * nae_cfg, uint32_t *phys_cpu_map, int
 
 #if 1
 	for (i = 0; i <= NLM_NAE_MAX_SHARED_DOMS; i++) {
-		printk("naeid %d domid %d node %d flag %x\n", nae_id, 
+		printk("naeid %d domid %d node %d flag %x\n", nae_id,
 				lnx_shinfo[i]->domid, lnx_shinfo[i]->node, lnx_shinfo[i]->flags);
 		for(cpus = 0; cpus < lnx_shinfo[i]->num_cpus; cpus++) {
 			printk("lcpu %d value %08x (pcpu %d rxfifo %d jfifo %d)\n",
@@ -926,7 +926,7 @@ static void nlm_enable_l3_l4_parser(nae_t *nae)
 	l3.l3_hdr_off1=16;
 	l3.l3_hdr_len1=4;
 	netsoc_config_nae_l3parser(nae, &l3, 0);
-	
+
 	l4.l4_proto_mask = 1;
 	l4.l4_proto = 0x6;
 	l4.l4_hdr_off0 = 0;
@@ -980,7 +980,7 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 	int i, flow_ctrl;
 	int ret = 0;
 	nae_t* nae_cfg = priv->nae;
-	static int done[NLM_MAX_NODES][MAX_NAE_PERNODE] = { 
+	static int done[NLM_MAX_NODES][MAX_NAE_PERNODE] = {
 		{0,0}, {0,0}, {0,0}, {0,0} };
 	if (perf_mode == NLM_TCP_MODE) {
 #ifdef TSO_ENABLED
@@ -1040,7 +1040,7 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 		flow_ctrl= netsoc_flow_control_status(nae_cfg, priv->port);
 		if(flow_ctrl)
 			priv->flow_ctrl=1;
-		else 
+		else
 			priv->flow_ctrl=0;
 		//nlm_xlp_mac_set_enable(priv, 1);
 		netsoc_disable_flow_control(priv->nae_port);
@@ -1218,7 +1218,7 @@ static int nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu)
 			//nlm_xlp_mac_set_enable(priv, 0); /* Disable MAC TX/RX */
 	}
 
-	if (priv->type==SGMII_IF || priv->type==XAUI_IF || priv->type== XLAUI_IF)
+	if (priv->type==SGMII_IF || priv->type==XAUI_IF || priv->type== XLAUI_IF || priv->type== XFI_IF)
 		netsoc_set_framesize(nae_port, local_mtu);
 	else if (priv->type==INTERLAKEN_IF){
 		/*TODO: Add IL frame set in brcm_netsoc */
-- 
1.9.1

