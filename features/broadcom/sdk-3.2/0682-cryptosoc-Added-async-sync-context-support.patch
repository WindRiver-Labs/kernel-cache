From a1f1e08a1aae65f4e2c356a3cd45db64b4d4e23c Mon Sep 17 00:00:00 2001
From: Hareesh R <hareeshr@broadcom.com>
Date: Fri, 3 May 2013 16:20:47 +0530
Subject: [PATCH 0682/1532] cryptosoc: Added async/sync context support

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/seclib/Makefile             |   18 -
 arch/mips/netlogic/lib/seclib/cryptosoc_ctx.h      |  209 +++
 arch/mips/netlogic/lib/seclib/cryptosoc_lib.c      | 1088 +++++++++++++
 arch/mips/netlogic/lib/seclib/cryptosoc_lib.h      |  248 +++
 arch/mips/netlogic/lib/seclib/eccsoc_defs.h        |  144 ++
 .../netlogic/lib/seclib/eccsoc_gen1_hal_defs.h     |  173 ++
 arch/mips/netlogic/lib/seclib/eccsoc_lib.h         | 1644 ++++++++++++++++++++
 arch/mips/netlogic/lib/seclib/rsaecc_soc_common.h  |  311 ++++
 arch/mips/netlogic/lib/seclib/rsasoc_defs.h        |  122 ++
 .../netlogic/lib/seclib/rsasoc_gen1_hal_defs.h     |  172 ++
 arch/mips/netlogic/lib/seclib/rsasoc_gen1_ucode.h  |  962 ++++++++++++
 arch/mips/netlogic/lib/seclib/rsasoc_lib.h         |  745 +++++++++
 arch/mips/netlogic/lib/seclib/saesoc_defs.h        |  380 +++--
 .../netlogic/lib/seclib/saesoc_gen1_hal_defs.h     |  214 ++-
 .../netlogic/lib/seclib/saesoc_gen2_hal_defs.h     |  178 ++-
 arch/mips/netlogic/lib/seclib/saesoc_lib.c         |  206 ---
 arch/mips/netlogic/lib/seclib/saesoc_lib.h         |  743 ++++-----
 arch/mips/netlogic/lib/seclib/sample_app/Makefile  |   22 -
 arch/mips/netlogic/lib/seclib/sample_app/build.sh  |    3 -
 .../lib/seclib/sample_app/saesoc_lib_ifc.h         |   64 -
 .../lib/seclib/sample_app/saesoc_sample_app.c      |  249 ---
 21 files changed, 6650 insertions(+), 1245 deletions(-)
 delete mode 100644 arch/mips/netlogic/lib/seclib/Makefile
 create mode 100644 arch/mips/netlogic/lib/seclib/cryptosoc_ctx.h
 create mode 100644 arch/mips/netlogic/lib/seclib/cryptosoc_lib.c
 create mode 100644 arch/mips/netlogic/lib/seclib/cryptosoc_lib.h
 create mode 100644 arch/mips/netlogic/lib/seclib/eccsoc_defs.h
 create mode 100644 arch/mips/netlogic/lib/seclib/eccsoc_gen1_hal_defs.h
 create mode 100644 arch/mips/netlogic/lib/seclib/eccsoc_lib.h
 create mode 100644 arch/mips/netlogic/lib/seclib/rsaecc_soc_common.h
 create mode 100644 arch/mips/netlogic/lib/seclib/rsasoc_defs.h
 create mode 100644 arch/mips/netlogic/lib/seclib/rsasoc_gen1_hal_defs.h
 create mode 100644 arch/mips/netlogic/lib/seclib/rsasoc_gen1_ucode.h
 create mode 100644 arch/mips/netlogic/lib/seclib/rsasoc_lib.h
 delete mode 100644 arch/mips/netlogic/lib/seclib/saesoc_lib.c
 delete mode 100644 arch/mips/netlogic/lib/seclib/sample_app/Makefile
 delete mode 100755 arch/mips/netlogic/lib/seclib/sample_app/build.sh
 delete mode 100644 arch/mips/netlogic/lib/seclib/sample_app/saesoc_lib_ifc.h
 delete mode 100644 arch/mips/netlogic/lib/seclib/sample_app/saesoc_sample_app.c

diff --git a/arch/mips/netlogic/lib/seclib/Makefile b/arch/mips/netlogic/lib/seclib/Makefile
deleted file mode 100644
index 0d3c2fc..0000000
--- a/arch/mips/netlogic/lib/seclib/Makefile
+++ /dev/null
@@ -1,18 +0,0 @@
-SAESOC_LIB_DIR = $(SDK_ROOT)/libraries/brcm_saesoc
-SAESOC_LIB_OBJS=saesoc_lib.o
-SAESOC_LIB=libsaesoc.a
-
-include $(SDK_ROOT)/linux-userspace/Makefile.mk
-
-$(SAESOC_LIB): $(SAESOC_LIB_OBJS)
-	echo "Build saesoc library"
-	$(AR) -rcsP $(SAESOC_LIB) $(SAESOC_LIB_OBJS)
-all: $(SAESOC_LIB)
-
-
-clean:
-	$(RM) *.a *.o
-
-install:
-
-.PHONY: all clean install $(SAESOC_LIB)
diff --git a/arch/mips/netlogic/lib/seclib/cryptosoc_ctx.h b/arch/mips/netlogic/lib/seclib/cryptosoc_ctx.h
new file mode 100644
index 0000000..f26a670
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/cryptosoc_ctx.h
@@ -0,0 +1,209 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _CRYPTOSOC_CTX_H
+#define _CRYPTOSOC_CTX_H
+
+#include "cryptosoc_lib.h"
+#include "cryptosoc_lib_ifc.h"
+
+/** 
+ * enum cryptosoc_ctx_mode - Possible modes of the context
+ * @CRYPTOSOC_CTX_MODE_SYNC_EXCL : Session is synchronous exclusive
+ * @CRYPTOSOC_CTX_MODE_SYNC_SHRD : Session is synchronous shared
+ * @CRYPTOSOC_CTX_MODE_ASYNC : Session is asynchronous
+ */
+enum cryptosoc_ctx_mode {
+	CRYPTOSOC_CTX_MODE_SYNC_EXCL,
+	CRYPTOSOC_CTX_MODE_SYNC_SHRD,
+	CRYPTOSOC_CTX_MODE_ASYNC
+};
+
+#define  fifo_full(t, nentries, h) (((t+1) % nentries) == h)
+#define  fifo_empty(t, h) (t == h)
+
+/* In async when max_msgs > 1, the message send id is specified in 52nd bit onwards
+ int the msg2 
+ 0-31(32 bits) - session id
+ 32-51(20 bits) - rsp index 
+ 52-63(12 bits) - msg index */
+
+#define CRYPTOSOC_SESSION_ID_OFF 0
+#define CRYPTOSOC_GET_SESSION_ID(x) ((unsigned long long)x & ((1ULL << 32) - 1))
+
+#define CRYPTOSOC_RSP_ID_OFF 32
+#define CRYPTOSOC_GET_RSP_ID(x) (((unsigned long long)x >> 32) & ((1ULL << 20) - 1))
+
+#define CRYPTOSOC_ASYNC_MSG_OUT_OFF 52
+#define CRYPTOSOC_GET_ASYNC_MSG_OUT_ID(x) ((unsigned long long)x >> 52)
+
+/* increment the 16 bits of the session id portion. Not used during the 
+*  response */
+#define CRYPTOSOC_CTX_RSP_GEN_ID_MODIFY(x, val) \
+	((x & ~0xffffULL) | ((val) & 0xffff));
+
+
+
+/**
+* defines ctx_param_flags - Context specific flags
+* @CRYPTOSOC_CTX_ASYNC_RSP_IN_ORDER : Async response mode(1/0). 
+* If it is set,the response will be given to the application in the  order 
+* the request has been sent to the soc even if the result are  out of order. 
+* If it is unset, the respose will be given to the application in the order 
+* the respose has been received
+*  This is ignored if RSP_POP_BY_APP is set
+* @CRYPTOSOC_CTX_ASYNC_RSP_POP_BY_APP: If this is set, the response from the 
+* engine is poped by the application instead of the interrupt handler. 
+* Interrupt on this vc should not be enabled if this is set.
+*/
+/*!defines ctx_param_flags < */
+#define CRYPTOSOC_CTX_ASYNC_RSP_IN_ORDER 	0x1
+#define CRYPTOSOC_CTX_ASYNC_RSP_POP_BY_APP	0x2
+/*!defines ctx_param_flags > */
+
+/**
+* struct cryptosoc_ctx_params - Crypto(sae,rsa,ecc) soc context creation
+*  parameters 
+* @mode: Mode of the context, see cryptosoc_context_mode . 
+* @max_pending_reqs: Maximum pending requests per context for 
+*   async/sync-shared mode. If the number of requests exceeds this limit, 
+*   the call will be returned with the error codes(EAGAIN).
+* @flags : See ctx_param_flags
+*/
+struct cryptosoc_ctx_params {
+	enum cryptosoc_ctx_mode mode;
+	int max_pending_reqs;
+	unsigned int flags;
+};
+
+struct cryptosoc_rsp_msg {
+	/* operation result message from the engine */
+	volatile _uint64_t res_val;
+	/* rsp_message given in the send request time. Interrupt handler should 
+	*  increment the gen-id portion before writing this value */
+	volatile _uint64_t rsp_val;
+};	
+
+struct cryptosoc_req_msg {
+	/* rsp_usr_arg is what is user has given during the send request. 
+	*  The rsp_msg is what we send to the engine. Before the interrupt
+	*  handler writes this message, it should increment the generation id
+	*  portion of rsp_msg. We read this from the rsp before sending 
+	*  this request to assure that this entry is modified */
+	volatile _uint64_t async_rsp_usr_arg;
+	volatile _uint64_t rsp_val; 
+};
+
+
+struct cryptosoc_rsp {
+	/* Used to save responses from the engine, used in async and shared-vc 
+	*  mode */
+	struct cryptosoc_rsp_msg rsp_msg[CRYPTOSOC_MAX_PENDING_REQS_PER_CTX]; 
+	unsigned int nrcvd; /* number of messages received by kernel */
+	unsigned int index; 
+	unsigned int sessionid;
+	unsigned int owner; /* pid, Only it can delete the context */
+	unsigned int allocated; /* whether it is allocated or not */
+	/* head & tail are pointing to the rsp_msg, 
+	*  used only if response in_order == false */
+	unsigned int head;
+	unsigned int tail;
+#ifdef NLM_HAL_LINUX_KERNEL
+	atomic_t used_by_intr; /* used by interrupt */
+#else
+	unsigned int used_by_intr;
+#endif
+	unsigned long long fdctxt;
+	char priv_data[16]; /* used by kernel*/
+};
+
+
+struct cryptosoc_ctx_priv_data {
+	unsigned int mode;
+
+	unsigned int max_pending_reqs;
+	unsigned int num_rsp_pend; /* number of pending responses */
+
+	cryptosoc_lock_t lock; /* */
+	unsigned int req_send_failure;
+
+	unsigned int req_head; /* head and tail for async operation */
+	unsigned int req_tail;
+
+	unsigned int flags;
+
+	/* used in async out-of-order processing or sync-shared mode */
+	int free_req_index[CRYPTOSOC_MAX_PENDING_REQS_PER_CTX]; 
+
+	struct cryptosoc_req_msg req_msg[CRYPTOSOC_MAX_PENDING_REQS_PER_CTX];
+	struct cryptosoc_rsp *rsp; /* mmaped to userspace and written by the 
+								  kernel */
+};
+
+/**
+* struct cryptosoc_ctx_params - Crypto(sae,rsa,ecc) soc context parameters 
+* @lib_priv: Space to store the private data by the library. 
+* 	Application should not modify this area
+* @app_priv: Application private memory.
+* @fd: Event file descriptor associated with this context. 
+*   Used only in async/sync-shared mode
+*/
+struct cryptosoc_ctx {
+	char lib_priv[sizeof(struct cryptosoc_ctx_priv_data)];
+	char app_priv[CRYPTOSOC_CTX_APP_PRIV_SZ];
+	int fd; 
+};
+
+extern int cryptosoc_new_context(
+		struct cryptosoc_ctx_params *cparam, 
+		struct cryptosoc_ctx **ctxt);
+extern int cryptosoc_close_ctx(struct cryptosoc_ctx *ctx);
+extern int cryptosoc_get_response(struct cryptosoc_ctx  *ctx, 
+		_uint64_t *rsp_usr_arg, struct cryptosoc_rsp_result *res);
+extern int cryptosoc_process_response(
+		struct cryptosoc_ctx  *ctx, 
+		enum cryptosoc_soc_type soc, 
+		_uint64_t msg0, _uint64_t msg1,
+		_uint64_t *rsp_usr_arg, struct cryptosoc_rsp_result *res);
+extern int cryptosoc_process_ctx_request(int gen1, 
+		struct cryptosoc_ctx *ctx, 
+		enum cryptosoc_soc_type soc,
+		int txvc,
+		int fbvc,
+		int code,
+		int retry_count,
+		_uint64_t msg0,	_uint64_t msg1, _uint64_t req_usr_arg,
+		_uint64_t *rx_msg, _uint64_t *rsp_msg);
+#endif
diff --git a/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c
new file mode 100644
index 0000000..38959b0
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c
@@ -0,0 +1,1088 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+/**
+* DOC: Crypto Library API Design approach
+* 
+* The library has been implemented as 3 layers: Crypto-HAL, Crypto Abstraction
+*  and Crypto Protocol Specific library.  Also this library provides context
+*  APIs by which the linux-userspace application can implement a scalable 
+*  sync/async implementation. .
+*
+* The details of these API layers are described below.
+*/
+
+/**
+* DOC: Crypto HAL Library
+*
+* Crypto HAL library provides SAE engine direct interface APIs. Here the API 
+* definitions will differ depending on the processor type. Applications that 
+* are going to work only on a particular processor type can make use these 
+* APIs.
+*/
+
+/**
+* DOC: Crypto Abstraction Library
+*
+* This layer will abstract the SAE/RSA/ECC engine. This will internally calls
+*  the Crypto hal library depending on the processor type.
+*
+* These APIs support generic crypto operations and will not change from one 
+* chip to another. Applications should use this layer extensively
+*
+* Some of the APIs to support a few chip features in software (for older chips)
+* can be part of this layer
+*
+* Session and data descriptor formation will be handled transparently
+*
+* Most of the crypto operation input parameters will be taken during session 
+* creation which is one time operation. 
+*
+* Per operation parameters will be taken in the fast path APIs. These fast 
+* path APIs will take few most common input parameters and modify APIs will be 
+* provided for other parameters that can be modified for each operation 
+* (Note: Griffin and Eagle vary here a lot)
+*
+* During init time, a bitmask of all fields that can be modified on a per 
+* packet (operation) basis will be returned based on the chip type. 
+* Ex: for griffin, AAD length, payload bit count etc. For eagle, this will be 
+* IV length, IV offset etc.
+*
+* Another bit mask of all the CHIP capabilities will be returned: Following 
+* are examples of some chip capabilities:
+*  ZUC
+*  3DES Key swap
+*  Tag Compare result
+*  Tag truncation
+*  HASH muting 
+*
+* Applications that intend to be generic should make use of these flags and 
+* call appropriate APIs only if the feature is supported
+*/
+
+/**
+* DOC: Crypto Abstraction Library Application defines
+*
+* The library code is kept under GEN1(ex : xlp, storm) or GEN2(Ex:Griffin)
+* macros. This can be specified at compile time. 
+*
+* The library can be compiled for all the processor versions(GEN_ALL) or for a 
+* specified version(GEN1, GEN2). 
+*
+* If the library is compiled for (GEN_ALL), then it internally read the 
+*  processor type and calls the appropriate HAL apis.  
+*
+* If the library is compiled  only for GEN1/GEN2, then only those specific 
+* code will be executed.(No runtime checks)
+*
+*
+* This library is expecting the following macros to be defined by the 
+* application. The library code includes an application provided file named 
+* cryptosoc_lib_ifc.h. User should define the following parameters in that. 
+* 
+* _uint64_t cryptosoc_virt_to_phys(unsigned long vaddr): 
+*   Return the physical address corresponding to the given virtual address.
+*
+* unsigned long cryptosoc_phys_to_virt(_uint64_t paddr):
+*   Return the virtual address corresponding to the given physical address.
+*
+
+*
+* Also the application should register the following callback routines using 
+* the api cryptosoc_lib_init()
+*
+* a. mem_alloc:  Returns physically contiguous memory 
+*
+* b. mem_free: To free the memory allocated using mem_alloc routine             
+* 
+*/
+
+/**
+* DOC: Crypto Protocol Specific Library
+*
+* This layer provides helper functions which are protocol specific such as 
+* IPSEC, SSL etc. For example, the CCM implementation requires the B0, B1 
+* blocks to be created by the application before giving to the engine, 
+* so that any applications can make use of that instead of duplicating the 
+* code. 
+*
+* Similarly SSL specific padding which is not supported by the engine can make use of the APIs 
+* implemented as part of this library
+*
+*/
+
+#include "cryptosoc_ctx.h"
+#include "saesoc_defs.h"
+#include "cryptosoc_lib_priv.h"
+#include "nlm_hal_fmn.h"
+
+int cryptosoc_ptype_gen;
+static int cryptosoc_base_vc[CRYPTOSOC_TYPE_MAX];
+static int cryptosoc_lmt_vc[CRYPTOSOC_TYPE_MAX];
+
+cryptosoc__mem_alloc *cryptosoc_mem_alloc;
+cryptosoc__mem_free *cryptosoc_mem_free;
+
+static int cryptosoc_get_ptype_gen()
+{
+	/* TODO , Look at the processor type and return the value */
+	return CRYPTOSOC_PTYPE_IS_GEN1;
+}
+
+/**
+* cryptosoc_lib_init - Initialize the sae/rsa/ecc soc library parameters 
+*  based on the processor type.
+* @params: Pointer to lib param structure(output) 
+* @mem_alloc: Function pointer to allocate physically contiguous memory
+*    This should return memory pointer in success.(input)
+* @mem_free: Function to free the memory.(input)
+* @arg: For future use
+*
+* This should be called once from every application which is intended 
+* to use this library. This function fills the params struct and returned
+* to the user. 
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+int cryptosoc_lib_init(struct cryptosoc_lib_params *params, 
+		void *(mem_alloc)(size_t align, size_t size),
+		void (mem_free)(void *ptr),
+		void *arg)
+{
+	int i;
+
+	/* return error if callbacks are not provided */
+	if(!mem_alloc  || !mem_free) {
+			cryptosoc_err_print("%s:%d, Lib callbacks are not registered\n", 
+					__FUNCTION__, __LINE__);
+			return -CRYPTOSOC_EINVAL;
+	}
+	cryptosoc_mem_alloc = mem_alloc;
+	cryptosoc_mem_free	= mem_free;
+
+	cryptosoc_ptype_gen = cryptosoc_get_ptype_gen();
+	if(cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2) {
+		/* for griffin and associated versions */
+		params->saesoc_feature_set = SAESOC_FF_GEN2_PTYPE;
+		params->saesoc_per_pkt_update_set = 0;
+	} else { 
+		/* For eagle and associated versions */
+		//params->saesoc_feature_set = SAESOC_FF_GEN1_PTYPE | 
+		  //SAESOC_FF_3DES_KEY_SWAP_SUPPORT | SAESOC_FF_CIPHER_ZUC_SUPPORT;
+		params->saesoc_feature_set = SAESOC_FF_GEN1_PTYPE;
+		/* TODO : If xlp 3xx add zuc support */
+		params->saesoc_per_pkt_update_set = SAESOC_PER_PKT_UF_GEN1_PTYPE;
+	}
+
+	for(i = 0; i < CRYPTOSOC_TYPE_MAX; i++)
+		cryptosoc_get_basevc_limitvc(i,
+			&cryptosoc_base_vc[i], &cryptosoc_lmt_vc[i]);
+
+	/* implementation specific init routine */
+	return cryptosoc_lib_priv_init();
+
+}
+
+/**
+* cryptosoc_lib_finish - Crypto library finish function 
+* This should be called when the process is done with the 
+* current crypto library contexts.
+*/
+int cryptosoc_lib_finish(struct cryptosoc_lib_params *params)
+{
+	return cryptosoc_lib_priv_finish();
+}	
+
+/**
+* cryptosoc_get_basevc_limitvc - Retrieve the SAE/RSA/ECC base vc and limit vc
+* @soc : Soc type, see enum cryptosoc_soc_type
+* @base_vc : Base vc
+* @lmt_vc  : End vc
+*/ 
+int cryptosoc_get_basevc_limitvc(enum cryptosoc_soc_type soc, int *base_vc, int *lmt_vc)
+{
+	/* Look at the processor type and return the value,
+	*  Need to call the kernel driver */
+	return crypto_get_soc_vc_numbers(soc, base_vc, lmt_vc);
+}
+
+/**
+* cryptosoc_get_single_channel_vcmask - Retrieve the SAE/RSA/ECC single 
+* channel vc mask.
+* The single channel vc mask is that those vcs are mapped to only single engine,
+* so that requests send to this vc id will be processed in order only.
+* The application need to add the base_vc with the set-bits positon 
+* in the mask to get the vc-id. 
+* @soc : Soc type, see enum cryptosoc_soc_type
+* @vc_mask : Engine vc mask
+*/ 
+int cryptosoc_get_single_channel_vcmask(enum cryptosoc_soc_type soc, 
+		unsigned int *vc_mask)
+{
+	/* TODO , Look at the processor type and return the value,
+	*  Need to call teh kernel driver */
+	/* right now return for xlp8xx */
+	*vc_mask = 0x1; 
+	return CRYPTOSOC_OK;
+}
+
+/**
+* cryptosoc_get_multi_channel_vcmask - Retrieve the SAE/RSA/ECC  
+* multi channel vc mask.
+* The multi channel vc mask is that those vcs are mapped to multiple engines,
+* so that requests send to this vc id will be processed in by one of the free 
+* engines.
+* The application need to add the base_vc with the set-bits positon 
+* in the mask to get the vc-id
+* @soc : Soc type, see enum cryptosoc_soc_type
+* @vc_mask : Engine vc mask
+*/ 
+int cryptosoc_get_multi_channel_vcmask(enum cryptosoc_soc_type soc, 
+		unsigned int *vc_mask)
+{
+	/* TODO , Look at the processor type and return the value,
+	*  Need to call teh kernel driver */
+	/* right now return for xlp8xx */
+	*vc_mask = 0x2; 
+	return CRYPTOSOC_OK;
+}
+
+/**
+* cryptosoc_get_highpri_channel_vcmask - Retrieve the SAE/RSA/ECC  
+* high priority channel vc mask.
+* The high priority vc mask is that those vcs have high priority
+* in processing the requests compared to normal vcs,
+* The application need to add the base_vc with the set-bits positon 
+* in the mask to get the vc-id
+* @soc : Soc type, see enum cryptosoc_soc_type
+* @vc_mask : Engine vc mask
+*/ 
+int cryptosoc_get_highpri_channel_vcmask(enum cryptosoc_soc_type soc, 
+		unsigned int *vc_mask)
+{
+	/* TODO , Look at the processor type and return the value,
+	*  Need to call teh kernel driver */
+	/* right now return for xlp8xx */
+	*vc_mask = 0x4; 
+	return CRYPTOSOC_OK;
+}
+
+/**
+* DOC: Crypto Sync/Async Context Implementation Details
+* 
+* This section describes the implementation of Crypto context APIs 
+* which can be used from a Linux userspace application or a hyperexec 
+* application. Broadcom GEN1/GEN2 processor architecture allows Linux 
+* userspace  applications to directly send messages to the sae and perform 
+* various crypto operations and receive the response directly from the sae. 
+* This implementation will have a userspace and a small kernel driver 
+* component. 
+*
+* It is not mandatory that application should always use the contexts. In
+* some cases where the application takes care of receiving the responses
+* can still use all the library functions without using the contexts.
+*/
+
+/**
+* DOC: Async Model
+*
+* In the async model, the calling task can sleep after sending a crypto 
+* operation request to the sae. Application should open an async context 
+* for each connection. Async model supports 2 ways of handling the responses. 
+*
+* a. Driver pops the messages:
+*
+* In this case  the library is depends on a userspace and a small 
+* kernel driver component. The kernel driver is mainly used in this model
+* for implementing the select-wakeup semantics. The context is associated 
+* with a context memory and an eventfd. Here the message_send is done from 
+* userspace but the  message_recv is done by the linux interrupt handler 
+* and the response will be passed to the corresponding process through the 
+* context memory.  
+* 
+* The process that sent the message can block on the eventfd using 
+* select/epoll. The kernel driver will wake up the eventfd after copying the 
+* response to the context memory. The application should call the 
+* get_response() function to get the response. Eventfd is based on a 64
+* bit counter. The select/read will be successfull as long as the counter
+* value is > 0. When the application reads from the fd, the counter value
+* reset to 0. The argument to the read should be a 64 bit variable. So the 
+* application should call the get_response() function till it returns 
+* "no result". Otherwise the application may hang forever if there are
+* no further results.
+*
+* a.1 In-order & Out-of-order Processing
+*
+* In this model, the process can send multiple requests and the response will 
+* be delivered in request-sequence(in-order processing) or in 
+* response-sequence(out-of-order processing). 
+*
+* In the in-order processing, even if the second requests completes before 
+* first one, event will be delivered to the process, but the get_response()
+* function fails to retrieve any message. Whenever the head response arrives,
+* the application should POP all the responses by calling get_response() 
+* until it returns an error. 
+*
+* But in the out-of-order processing, the process can receive the response
+* whenever a response comes for any of the pending requests.
+*
+* b. Application pops the message:
+*
+* In this case the kernel driver component will not be used. Here
+* the application should continuously poll for the responses from the 
+* rx_vc and should call the process_response() function to extract
+* the context and user_args associated with the response.
+*
+* In this model, there is no concept of in-order or out-of-order processing.
+*/
+
+/**
+* DOC: Sync Model Exclusive VC
+*
+* In sync model, application will submit a crypto request and the 
+* library api will be continuously polling for the response. Here both 
+* message_send and message_recv are done from userspace. This requires a 
+* specific receive VC (for each CPU) and it cannot be shared with any 
+* other msgring stations (for ex. NAE). 
+*
+* The cpu set_affinity should be set for each application requesting sync 
+* operations. Otherwise if the message_send task is scheduled out of the 
+* called cpu, then the return message will be lost or will be received by 
+* some other task.
+*
+* As there is no way to order the request/response, only one outstanding 
+* SAE requests will  be allowed per cpu. For example if cpu 0 has 2 processes 
+* running , and if process-A is  waiting for a SAE response then process-B 
+* request can be sent only after receiving the response from process-A. 
+* This should be taken care by application if multiple sync-contexts are 
+* running on the same cpu.
+*/
+
+/**
+* DOC: Sync Model Shared VC
+*
+* This model is almost similar to Async model, but the crypto api will go to 
+* the sleep mode, and it will be woken up once the message reply arrives.
+* The message response will be copied to the context memory by the interrupt
+* handler. he advantage of this model compared to the sync-exclusive model is 
+* that there is no need for the explicit VC and cpu_set_affinity. 
+* The VC can be shared with other message ring stations
+*
+* This is not supported in helinux mode. Use sync-exclusive instead.
+*/
+
+/**
+* DOC: Application given macros
+*
+* CRYPTOSOC_MAX_PENDING_REQS_PER_CTX : This configures the maximum 
+* pending requests per context for async/sync-shared contexts. 
+* The memory consumption  per context will be more if it is set to a 
+* large value. Default can be set to 64.  Maximum of is is 4K.
+* The actual number of pending requests can be specified in 
+* the context creation time. When the number of pending requests exceeds 
+* this limit, the library returns EAGAIN, and then the application should 
+* pop atleast one response before sending  any more requests.
+*
+* CRYPTOSOC_CTX_APP_PRIV_SZ: Application private data size in the context 
+* structure.
+*/
+
+/**
+* DOC: Note
+* 
+* Contexts should not be shared with multiple forked processes. Result is 
+* unpredictable if the context created by one process used by another. 
+* Child process cannot use the same context created by parent because the
+* state of the context will not be valid for the child process(locks, 
+* outstanding requests, eventfd etc). 
+*
+* Also, as there is a kernel memory + application memory associated with the 
+* context, it cannot be shared with multiple processes.  If the kernel memory
+* is shared by 2 processes, the library cannot differentiate the request 
+* sending process. 
+*
+* Context can be shared with multiple threads(posix threads). 
+* 
+*/
+
+
+
+#define cryptosoc_gen_msg2(cpriv, rv)  \
+	(((_uint64_t)cpriv->rsp->sessionid << CRYPTOSOC_SESSION_ID_OFF) | \
+	((_uint64_t)cpriv->rsp->index << CRYPTOSOC_RSP_ID_OFF) | \
+	((_uint64_t)rv << CRYPTOSOC_ASYNC_MSG_OUT_OFF)) 
+
+
+#define CRYPTOSOC__MAX_PENDING_REQS_PER_CTX  \
+	(1 << (64 - CRYPTOSOC_ASYNC_MSG_OUT_OFF))
+
+static inline int cryptosoc_async_inorder_push_req(
+		struct cryptosoc_ctx_priv_data *cpriv, _uint64_t rsp_usr_arg)
+{
+
+	if(fifo_full(cpriv->req_tail, cpriv->max_pending_reqs, cpriv->req_head))
+		return -CRYPTOSOC_EAGAIN;
+	cpriv->req_tail = (cpriv->req_tail + 1) % cpriv->max_pending_reqs;
+
+	cpriv->req_msg[cpriv->req_tail].rsp_val = 
+					cpriv->rsp->rsp_msg[cpriv->req_tail].rsp_val;
+	cpriv->req_msg[cpriv->req_tail].async_rsp_usr_arg = rsp_usr_arg;
+	cpriv->num_rsp_pend++;
+
+	return cpriv->req_tail;
+}
+
+static inline int cryptosoc_async_inorder_pop_rsp(
+		struct cryptosoc_ctx_priv_data *cpriv, 
+		_uint64_t *rsp_usr_arg, struct cryptosoc_rsp_result *res)
+{
+	int tmp;
+
+	if(fifo_empty(cpriv->req_tail, cpriv->req_head))
+		return 0;
+
+	tmp = (cpriv->req_head + 1) % cpriv->max_pending_reqs;
+
+	/* no change in the response msg with generator id . 
+	*  TODO generator id implementation */
+	if(cpriv->req_msg[tmp].rsp_val == cpriv->rsp->rsp_msg[tmp].rsp_val)
+	       return 0;	
+
+	cpriv->req_head = tmp;
+	if(res) {
+		/* all the results are uint64_t size. */
+		res->sae_res.result = cpriv->rsp->rsp_msg[tmp].res_val;
+	}
+	if(rsp_usr_arg)
+		*rsp_usr_arg = cpriv->req_msg[tmp].async_rsp_usr_arg;
+
+	cpriv->num_rsp_pend--;
+	return 1;
+}
+
+static inline void cryptosoc_async_inorder_pop_send_failure_reqs(
+		struct cryptosoc_ctx_priv_data *cpriv)
+{
+	int i = 0, tmp;
+
+	tmp = (cpriv->req_head + 1) % cpriv->max_pending_reqs;
+	for(;i < cpriv->max_pending_reqs; i++) {
+			if(cpriv->req_msg[tmp].rsp_val != 0xdeadbeefULL)
+				break;
+			cpriv->req_head = tmp;
+			tmp = (tmp + 1) % cpriv->max_pending_reqs;
+			cpriv->req_send_failure--;
+			cpriv->num_rsp_pend--;
+			if(!cpriv->req_send_failure)
+				break;
+	}
+}
+
+static inline void cryptosoc_async_inorder_mark_send_failure_reqs(
+		struct cryptosoc_ctx_priv_data *cpriv, int req_id)
+{
+	/* if tail is not moved. Basically no other requests 
+	*  are not sent out from other shared threads */
+	if(cpriv->req_tail == req_id) {
+		if(req_id == 0)
+			cpriv->req_tail = cpriv->max_pending_reqs - 1;
+		else
+			 cpriv->req_tail--;
+		cpriv->num_rsp_pend--;
+		return;
+	}
+	cpriv->req_msg[req_id].rsp_val = 0xdeadbeefULL;
+	cpriv->req_send_failure++;
+}
+
+/* no-order pop response */
+static inline int cryptosoc_async_pop_rsp(
+		struct cryptosoc_ctx_priv_data *cpriv, 
+		_uint64_t *rsp_usr_arg, struct cryptosoc_rsp_result *res)
+{
+	_uint64_t msg;
+	int req_id;
+
+	if(cpriv->rsp->head == cpriv->req_head) {
+		return 0;
+	}
+	msg = cpriv->rsp->rsp_msg[cpriv->req_head].rsp_val;	 
+	req_id = CRYPTOSOC_GET_ASYNC_MSG_OUT_ID(msg);
+	if(rsp_usr_arg)
+		*rsp_usr_arg = cpriv->req_msg[req_id].async_rsp_usr_arg;
+	/* as all the results are of same size, we can use sae_res.
+	*  The application should read it based on the soc type */
+	if(res)
+		res->sae_res.result = cpriv->rsp->rsp_msg[cpriv->req_head].res_val;
+	cpriv->free_req_index[cpriv->req_tail] = req_id;
+	cpriv->req_tail++;
+	cpriv->req_head = (cpriv->req_head + 1) % cpriv->max_pending_reqs;
+	cpriv->num_rsp_pend--;
+	return 1;
+}
+
+
+/**
+* cryptosoc_new_context - The crypto new context function create a 
+*  context memory for the sync/async session. The context memory is 
+*  allocated from the heap. It will have userspace component and 
+*  kernel component depending on the context mode. 
+*
+* @cparam : Context init parameter(input)
+* @req_ctx : Pointer to the new context created(output)
+*
+* Return : CRYPTOSOC_OK for success, CRYPTOSOC_EINVAL for invalid argument, 
+*	  
+*/
+int cryptosoc_new_context(
+		struct cryptosoc_ctx_params *cparam, 
+		struct cryptosoc_ctx **req_ctx)
+{
+	int size, i;
+	struct cryptosoc_ctx *ctx = NULL;
+	struct cryptosoc_ctx_priv_data *cpriv;
+
+
+	if(!cparam || !req_ctx)
+		return -CRYPTOSOC_EINVAL;
+
+	/* In sync, as there is no way to order the requests and response, only one 
+	 outstanding request is allowed. */
+	size =  sizeof(struct cryptosoc_ctx);
+	if((ctx = malloc(size)) == NULL) 
+		goto err_exit;
+
+	cpriv = (struct cryptosoc_ctx_priv_data *)(ctx->lib_priv);
+	
+	cpriv->mode = cparam->mode;
+	cpriv->max_pending_reqs = 1;
+	cpriv->num_rsp_pend = 0;
+	cryptosoc_lock_init(&cpriv->lock);
+	ctx->fd = -1;
+
+	if(cpriv->mode == CRYPTOSOC_CTX_MODE_SYNC_EXCL) {
+		cryptosoc_dbg_print("Created exclusive session\n");
+
+	} else if(cpriv->mode == CRYPTOSOC_CTX_MODE_SYNC_SHRD) {
+
+		if(cparam->max_pending_reqs > CRYPTOSOC_MAX_PENDING_REQS_PER_CTX) {
+			cryptosoc_err_print(
+					"%s, Error, Number of requests exceeded the max limit\n",
+					__FUNCTION__); 
+			goto err_exit;
+		}
+		cpriv->max_pending_reqs = cparam->max_pending_reqs;
+
+		if(crypto_ctxt_alloc(ctx) < 0) {
+			cryptosoc_err_print("%s, Error, Context creation failed\n",
+					__FUNCTION__); 
+			goto err_exit;
+		}
+
+		for(i = 0; i < cpriv->max_pending_reqs ; i++)
+			cpriv->free_req_index[i] = i;
+		cpriv->req_head = 0;
+		cpriv->req_tail = i;
+
+		cryptosoc_dbg_print("Created sync-shared session, fd %d\n", ctx->fd);
+	} else if(cpriv->mode == CRYPTOSOC_CTX_MODE_ASYNC) {
+		if(cparam->max_pending_reqs > CRYPTOSOC_MAX_PENDING_REQS_PER_CTX) {
+			cryptosoc_err_print(
+					"%s, Error, Number of requests exceeded the max limit\n",
+					__FUNCTION__); 
+			goto err_exit;
+		}
+		cpriv->max_pending_reqs = cparam->max_pending_reqs;
+
+		/* actual number of requests will be one less than the original, 
+		*  take care of it here */
+		if(cparam->max_pending_reqs < CRYPTOSOC_MAX_PENDING_REQS_PER_CTX)
+			 cpriv->max_pending_reqs++;
+
+		if(crypto_ctxt_alloc(ctx) < 0) {
+			cryptosoc_err_print("%s, Error, Context creation failed\n",
+					__FUNCTION__); 
+			goto err_exit;
+		}
+
+		cpriv->flags = cparam->flags;
+
+		/* initialize the head and tail pointers based on the response mode*/
+		if(cpriv->flags & CRYPTOSOC_CTX_ASYNC_RSP_IN_ORDER) {
+			cpriv->req_head = 0;
+			cpriv->req_tail = 0;
+			cpriv->req_send_failure = 0;
+		} else {
+			for(i = 0; i < cpriv->max_pending_reqs ; i++)
+				cpriv->free_req_index[i] = i;
+			cpriv->req_head = 0; 
+			cpriv->req_tail = i;
+		}
+
+		cryptosoc_dbg_print("Created async session, fd %d\n", ctx->fd);
+	} else {
+		cryptosoc_err_print("%s in, Invalid mode\n", __FUNCTION__);
+		goto err_exit;
+	}
+	*req_ctx = ctx;
+	return CRYPTOSOC_OK;
+err_exit:
+		
+	if(ctx) {
+		if(ctx->fd >= 0)
+			close(ctx->fd);
+		free(ctx);
+	}
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* cryptosoc_close_ctx - The close context function closes the fd and 
+*  removes the ctxt mem allocated. Returns error(EAGAIN) if the context 
+*  has any pending responses from the security engine. When the call
+*  returns EAGAIN, it should wait for sometime and call the function
+*  again.
+*
+* @ctx : Pointer to the ctx structure. 
+*
+* Return : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_EAGAIN
+*
+* Note :  It is the application responsibility that this function should 
+* be called only after all the threads sharing this context came 
+* to a done state. None of the threads should be using this context
+* during this call.
+*
+*/
+int cryptosoc_close_ctx(struct cryptosoc_ctx *ctx)
+{
+	int rv;
+	struct cryptosoc_ctx_priv_data *cpriv;
+
+	if(!ctx)
+		return -CRYPTOSOC_EINVAL;
+
+	cpriv = (struct cryptosoc_ctx_priv_data *)(ctx->lib_priv);
+
+	if(cpriv->mode == CRYPTOSOC_CTX_MODE_ASYNC) {
+		cryptosoc_lock(&cpriv->lock);
+		if(cpriv->num_rsp_pend > 0) {
+			if(cpriv->flags & CRYPTOSOC_CTX_ASYNC_RSP_IN_ORDER)
+				cryptosoc_async_inorder_pop_rsp(cpriv, NULL, NULL);
+			else
+				cryptosoc_async_pop_rsp(cpriv, NULL, NULL);
+			if(cpriv->num_rsp_pend > 0) {
+				cryptosoc_unlock(&cpriv->lock);
+				return -CRYPTOSOC_EAGAIN;
+			}
+		}
+		cryptosoc_unlock(&cpriv->lock);
+	}
+	if(ctx->fd >= 0) {
+		if((rv = crypto_ctxt_free(ctx)) < 0)
+			return rv;
+		if(close(ctx->fd) < 0)
+			return -CRYPTOSOC_EINVAL;
+	}
+
+	free(ctx);
+	return CRYPTOSOC_OK;
+}
+
+/*local function, not exported */
+static int cryptosoc_process_sync_excl_request(int gen_type2, 
+		struct cryptosoc_ctx_priv_data *cpriv,
+		enum cryptosoc_soc_type soc,
+		int req_vc,
+		int rsp_vc,
+		int code,
+		int retry_count,
+		_uint64_t msg0,	_uint64_t msg1,
+		_uint64_t *res_msg, _uint64_t *rsp_msg)
+{
+	unsigned int src, size;
+	uint64_t rx_msg0, rx_msg1;
+
+	cryptosoc_dbg_print("Mode is exclusive\n");
+
+	while(retry_count > 0 ) {
+		if(gen_type2) {
+			if(xlp_message_send_2(req_vc, code, msg0, msg1) == 0)
+				break;
+		} else {
+			if(xlp_message_send_3(req_vc, code, msg0, msg1, 0ULL) == 0)
+				break;
+		}
+		retry_count--;
+	}
+	if ( retry_count == 0)
+		return -CRYPTOSOC_EAGAIN;
+
+cont_rcv:
+	while(xlp_message_receive_2(rsp_vc, &src, &size, (unsigned int *)&code, 
+				&rx_msg0, &rx_msg1) != 0);
+
+	if(!(src >= cryptosoc_base_vc[soc] && src <= cryptosoc_lmt_vc[soc])) {
+		cryptosoc_err_print(
+				"Error : Msg recved from unknown src %d, continuing the loop\n", 
+				src);
+		goto cont_rcv;
+	}
+
+	cryptosoc_dbg_print( "Msg rcvd msg0 %llx msg1 %llx\n", 
+			(unsigned long long)rx_msg0, (unsigned long long)rx_msg1);
+
+	/* rsa result is at msg0 and crypto is at msg1 */
+	if(res_msg) 
+		*res_msg = soc == CRYPTOSOC_SAE ? rx_msg1 : rx_msg0;
+
+	return CRYPTOSOC_OK;
+}
+
+static int cryptosoc_process_sync_shrd_request(int gen_type2, 
+		struct cryptosoc_ctx_priv_data *cpriv,
+		int fd,
+		enum cryptosoc_soc_type soc,
+		int req_vc,
+		int rsp_vc,
+		int code,
+		int retry_count,
+		_uint64_t msg0,	_uint64_t msg1, 
+		_uint64_t *res_msg, _uint64_t *rsp_msg)
+{
+
+	_uint64_t msg2;
+	int req_id, rv;
+
+	cryptosoc_lock(&cpriv->lock);
+	if(cpriv->req_tail == 0) {
+		cryptosoc_unlock(&cpriv->lock);
+		return -CRYPTOSOC_EAGAIN;
+	}
+	cpriv->req_tail--;
+	req_id = cpriv->free_req_index[cpriv->req_tail];
+	cryptosoc_unlock(&cpriv->lock);
+
+	cpriv->req_msg[req_id].rsp_val = cpriv->rsp->rsp_msg[req_id].rsp_val;
+	msg2 = cryptosoc_gen_msg2(cpriv, req_id);
+
+	cryptosoc_dbg_print("Mode is shared-vc ,msg2 %llx\n", (unsigned long long)msg2);
+
+	while(retry_count > 0 ) {
+		if(gen_type2) {
+			if(rsp_msg)
+				*rsp_msg = msg2;
+			if(xlp_message_send_2(req_vc, code, msg0, msg1) == 0)
+				break;
+		} else {
+			if(xlp_message_send_3(req_vc, code, msg0, msg1, msg2) == 0)
+				break;
+		}
+		retry_count--;
+	}
+	if (retry_count == 0)  {
+		rv = -CRYPTOSOC_EAGAIN;
+		goto shrd_exit;
+	}
+
+retry:
+	if((rv = crypto_ctxt_shrd_wait_for_response(fd)) < 0)
+		return rv;
+		
+	/* if no change in the response generator id */
+	if(cpriv->req_msg[req_id].rsp_val == cpriv->rsp->rsp_msg[req_id].rsp_val)
+		goto retry;
+
+	if(res_msg)
+		*res_msg = cpriv->rsp->rsp_msg[req_id].res_val;
+	rv = CRYPTOSOC_OK;
+
+shrd_exit:
+	cryptosoc_lock(&cpriv->lock);
+	cpriv->free_req_index[cpriv->req_tail] = req_id;
+	cpriv->req_tail++;
+	cryptosoc_unlock(&cpriv->lock);
+	return rv;
+
+}
+
+static int cryptosoc_process_async_request(int gen_type2, 
+		struct cryptosoc_ctx_priv_data *cpriv,
+		enum cryptosoc_soc_type soc,
+		int req_vc,
+		int rsp_vc,
+		int code,
+		int retry_count,
+		_uint64_t msg0,	_uint64_t msg1, _uint64_t rsp_usr_arg,
+		 _uint64_t *rsp_msg)
+{
+	int req_id;
+	_uint64_t msg2;
+
+	cryptosoc_lock(&cpriv->lock);
+	if(cpriv->flags & CRYPTOSOC_CTX_ASYNC_RSP_IN_ORDER) {
+		if((req_id = cryptosoc_async_inorder_push_req(cpriv, rsp_usr_arg)) < 0) {
+			cryptosoc_unlock(&cpriv->lock);
+			return req_id;
+		}
+	} else {
+		/* we cannot use 1 slot */
+		if(cpriv->req_tail == 1) {
+			cryptosoc_unlock(&cpriv->lock);
+			return -CRYPTOSOC_EAGAIN;
+		}
+		cpriv->req_tail--;
+		req_id = cpriv->free_req_index[cpriv->req_tail];
+		cpriv->num_rsp_pend++;
+	}
+	cryptosoc_unlock(&cpriv->lock);
+
+	/* save the per request user argument */
+	cpriv->req_msg[req_id].async_rsp_usr_arg = rsp_usr_arg;
+
+	msg2 = cryptosoc_gen_msg2(cpriv, req_id);
+	cryptosoc_dbg_print("Mode is async ,msg2 %llx\n", 
+			(unsigned long long)msg2);
+
+	while(retry_count > 0 ) {
+		if(gen_type2) {
+			if(rsp_msg)
+				*rsp_msg = msg2;
+			if(xlp_message_send_2(req_vc, code, msg0, msg1) == 0)
+				break;
+		} else {
+			if(xlp_message_send_3(req_vc, code, msg0, msg1, msg2) == 0)
+				break;
+		}
+		retry_count--;
+	}
+	if (retry_count == 0)  {
+		cryptosoc_lock(&cpriv->lock);
+		if(cpriv->flags & CRYPTOSOC_CTX_ASYNC_RSP_IN_ORDER) {
+			cryptosoc_async_inorder_mark_send_failure_reqs(cpriv, req_id);
+		} else  {
+			cpriv->free_req_index[cpriv->req_tail] = req_id;
+			cpriv->req_tail++;
+			cpriv->num_rsp_pend--;
+		}
+		cryptosoc_unlock(&cpriv->lock);
+		return -CRYPTOSOC_EAGAIN;
+	}
+
+	return CRYPTOSOC_OK;
+}
+
+/* local function not exported */
+int cryptosoc_process_ctx_request(int gen_type2, 
+		struct cryptosoc_ctx *ctx, 
+		enum cryptosoc_soc_type soc,
+		int req_vc,
+		int rsp_vc,
+		int code,
+		int retry_count,
+		_uint64_t msg0,	_uint64_t msg1, _uint64_t rsp_usr_arg,
+		_uint64_t *res_msg, _uint64_t *rsp_msg)
+{
+	struct cryptosoc_ctx_priv_data *cpriv;
+
+	if(!ctx)
+		return -CRYPTOSOC_EINVAL;
+
+	cpriv = (struct cryptosoc_ctx_priv_data *)(ctx->lib_priv);
+
+	if(cpriv->mode == CRYPTOSOC_CTX_MODE_SYNC_EXCL) 
+		return cryptosoc_process_sync_excl_request(
+				gen_type2, cpriv, soc, req_vc, rsp_vc,
+				code, retry_count, msg0, msg1, 
+				res_msg, rsp_msg);
+
+	else if(cpriv->mode == CRYPTOSOC_CTX_MODE_SYNC_SHRD) 
+		return cryptosoc_process_sync_shrd_request(
+				gen_type2, cpriv, ctx->fd, soc, req_vc, rsp_vc,
+				code, retry_count, msg0, msg1, 
+				res_msg, rsp_msg);
+
+	else if(cpriv->mode == CRYPTOSOC_CTX_MODE_ASYNC) 
+		return cryptosoc_process_async_request(
+				gen_type2, cpriv, soc, req_vc, rsp_vc,
+				code, retry_count, msg0, msg1, rsp_usr_arg, rsp_msg);
+	else
+		return  -CRYPTOSOC_EINVAL;
+}
+
+/* local function not exported */
+int cryptosoc_process_request(int gen_type2, 
+		enum cryptosoc_soc_type soc,
+		int req_vc, int rsp_vc, 
+		int code, int retry_count,
+		_uint64_t msg0, _uint64_t msg1, _uint64_t msg2,
+		_uint64_t *res_msg)
+{
+	unsigned int src, size;
+
+	while(retry_count > 0 ) {
+		if (gen_type2) {
+		   if(xlp_message_send_2(req_vc, code, msg0, msg1) == 0)
+				break;
+		} else {
+		   if(xlp_message_send_3(req_vc, code, msg0, msg1, msg2) == 0)
+				break;
+		}
+		retry_count--;
+	}
+	if(retry_count == 0)
+		return -CRYPTOSOC_EAGAIN;
+
+	if(res_msg) {
+cont_rcv:
+		while(xlp_message_receive_2(rsp_vc, &src, &size, (unsigned int *)&code, 
+					(uint64_t *)&msg0, (uint64_t *)&msg1) != 0);
+		if(!(src >= cryptosoc_base_vc[soc] && src <= cryptosoc_lmt_vc[soc])) {
+			cryptosoc_err_print(
+			"Error : Msg recved from unknown src %d, continuing the loop\n", 
+					src);
+			goto cont_rcv;
+		}
+
+		/* rsa result is at msg0 and crypto is at msg1 */
+		*res_msg = soc == CRYPTOSOC_SAE ? msg1 : msg0;
+	}
+	return CRYPTOSOC_OK;
+}
+
+
+/**
+* cryptosoc_get_response - Get the response from the context if any.
+* Used only in async case.
+* @ctx: Pointer to the context(input)
+* @rsp_usr_arg: Value given as part of request send(output)
+* @res : Engine result response(output)
+*
+* Return: Number of messages read(0/1), or CRYPTOSOC_EINVAL
+*
+* Note : As multiple responses might have been queued up for 
+* this context, when the process wokeup, it should call the 
+* this routine till it returns "no-message(0)". See the async-
+* model session for details.
+*/
+
+int cryptosoc_get_response(struct cryptosoc_ctx  *ctx, 
+		_uint64_t *rsp_usr_arg, struct cryptosoc_rsp_result *res)
+{
+	struct cryptosoc_ctx_priv_data *cpriv;
+	int rv = 1;
+
+	if(!ctx)
+		return -CRYPTOSOC_EINVAL;
+
+	cpriv = (struct cryptosoc_ctx_priv_data *)(ctx->lib_priv);
+
+	if(cpriv->flags & CRYPTOSOC_CTX_ASYNC_RSP_POP_BY_APP)
+		return  -CRYPTOSOC_EINVAL;
+
+	if(cpriv->flags & CRYPTOSOC_CTX_ASYNC_RSP_IN_ORDER) {
+		cryptosoc_lock(&cpriv->lock);
+		if(cpriv->req_send_failure)
+			cryptosoc_async_inorder_pop_send_failure_reqs(cpriv);
+		rv = cryptosoc_async_inorder_pop_rsp(cpriv, rsp_usr_arg, res);
+		cryptosoc_unlock(&cpriv->lock);
+	} else {
+		/* In this mode, the kernel fills the responses from start to end 
+		*  in circular way irrespective of the request id. We should maintain
+		*  the last read index. This should  be ok, as we read the responses 
+		*  from the head to make an empty slot  for the responses */
+		cryptosoc_lock(&cpriv->lock);
+		rv = cryptosoc_async_pop_rsp(cpriv, rsp_usr_arg, res);
+		cryptosoc_unlock(&cpriv->lock);
+	}
+	return rv;
+}
+
+/**
+* cryptosoc_process_response - Get the rsp arg and result from 
+* the received message. This will be called when the application receives
+* the messages directly. Here the kernel driver component is not used 
+* in receiving the messages.
+*
+* @ctx: Pointer to the context(output)
+* @soc : Soc type, see cryptosoc_soc_type enum
+* @msg0: Received message 0
+* @msg1: Received message 1
+* @rsp_usr_arg: Value given as part of request send(output)
+* @res : Engine result response(output)
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*
+* Note:
+* This can be called with a valid ctx or ctxt=null. When ctx is null
+* the rsp_usr_arg will be copied with the recieved arg. Otherwise
+* it will be copied with usr arg given during the request sent.
+*/
+
+int cryptosoc_process_response(
+		struct cryptosoc_ctx  *ctx, 
+		enum cryptosoc_soc_type soc, 
+		_uint64_t msg0, _uint64_t msg1,
+		_uint64_t *rsp_usr_arg, struct cryptosoc_rsp_result *res)
+{
+	struct cryptosoc_ctx_priv_data *cpriv;
+	int req_id;
+	_uint64_t res_msg, rsp_msg;
+
+
+	/* rsa result is at msg0 and crypto is at msg1 */
+	res_msg = soc == CRYPTOSOC_SAE ? msg1 : msg0;
+	rsp_msg = soc == CRYPTOSOC_SAE ? msg0 : msg1;
+	
+	if(res)
+		res->sae_res.result = res_msg;
+
+	if(rsp_usr_arg)
+		*rsp_usr_arg = rsp_msg;
+
+	/* override the rsp_usr_arg if context is supported */
+
+	if(ctx) {
+		cpriv = (struct cryptosoc_ctx_priv_data *)(ctx->lib_priv);
+
+		req_id = CRYPTOSOC_GET_ASYNC_MSG_OUT_ID(rsp_msg);
+		if(req_id >= cpriv->max_pending_reqs)
+			return  -CRYPTOSOC_EINVAL;
+
+		if(rsp_usr_arg)
+			*rsp_usr_arg = cpriv->req_msg[req_id].async_rsp_usr_arg;
+	}
+
+	return CRYPTOSOC_OK;
+}
diff --git a/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h
new file mode 100644
index 0000000..acae211
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h
@@ -0,0 +1,248 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _CRYPTOSOC_LIB_H
+#define _CRYPTOSOC_LIB_H
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <string.h>
+
+/* This should be included in the top before lib.h */
+
+#ifndef _UINT64_T
+#define _UINT64_T
+typedef  unsigned long long   _uint64_t;
+#endif
+
+#define CRYPTOSOC_CACHELINE_SZ		64ULL
+#define CRYPTOSOC_CACHELINE_SHIFT  6
+#define ___cryptosoc_cacheline_aligned __attribute__((__aligned__(CRYPTOSOC_CACHELINE_SZ)))
+#define cryptosoc_is_cache_aligned(x) (((_uint64_t)x & (CRYPTOSOC_CACHELINE_SZ - 1)) == 0)
+#define cryptosoc_align(x, y)     ((x) & (~((y)-1)))
+#define cryptosoc_roundup(x, y)   (cryptosoc_align((x)+(y)-1, (y)))
+#define cryptosoc_dbg_print(fmt, args...) printf(fmt, ##args)
+#define cryptosoc_err_print(fmt, args...) printf(fmt, ##args)
+
+
+#define CRYPTOSOC_PTYPE_IS_GEN1 0x1
+#define CRYPTOSOC_PTYPE_IS_GEN2 0x2
+
+/** 
+ * enum cryptosoc_err - Possible error codes returned by the APIs
+ *
+ * @CRYPTOSOC_OK: The API executed successfully.
+ * @CRYPTOSOC_EPERM: Operation not permitted.
+ * @CRYPTOSOC_ENOENT: Object look up failed
+ * @CRYPTOSOC_EIO: I/O Error
+ * @CRYPTOSOC_EAGAIN: Try again
+ * @CRYPTOSOC_ENOMEM: Out of memory
+ * @CRYPTOSOC_EINVAL: Invalid argument
+ * @CRYPTOSOC_ENOSPC: No space left on device
+ * @CRYPTOSOC_ETIMEDOUT: Operation timed out
+ */
+ 
+enum cryptosoc_err { 
+	CRYPTOSOC_OK = 0, 
+	CRYPTOSOC_EPERM    = 1,
+	CRYPTOSOC_ENOENT   = 2,
+	CRYPTOSOC_EIO      = 5,
+	CRYPTOSOC_EAGAIN	=11,
+	CRYPTOSOC_ENOMEM   = 12,
+	CRYPTOSOC_EINVAL   = 22,
+	CRYPTOSOC_ENOSPC   = 28,
+	CRYPTOSOC_ETIMEDOUT = 60,
+};
+
+/** 
+ * enum cryptosoc_soc_type - Crypto soc types
+ * @CRYPTOSOC_RSA : RSA engine
+ * @CRYPTOSOC_ECC : ECC engine
+ * @CRYPTOSOC_SAE : SAE engine
+ * @CRYPTOSOC_TYPE_MAX : End of crypto soc type
+ */
+enum cryptosoc_soc_type {
+	CRYPTOSOC_RSA,
+	CRYPTOSOC_ECC,
+	CRYPTOSOC_SAE,
+	CRYPTOSOC_TYPE_MAX
+};
+
+/**
+* struct cryptosoc_lib_params - Crypto(sae,rsa,ecc) soc library params based on 
+*  the processor type
+* @saesoc_feature_set: Feature set variable and associated flags for SAE engine. 
+* 	See the feature set flag(output)
+* @saesoc_per_pkt_update_set: SAE parameters that are modifiable on every packet 
+* 	depending on the processor type. See the uf_flag above(output)
+*/
+struct cryptosoc_lib_params {
+	unsigned int saesoc_feature_set ; 
+	unsigned int saesoc_per_pkt_update_set ; 
+};
+
+
+/**
+* struct saesoc_rsp_result - Crypto engine result 
+* @result: Result value is copied here 
+*/
+struct saesoc_rsp_result {
+	_uint64_t result;
+};
+
+/**
+* struct rsasoc_rsp_result - RSA engine result 
+* @result: Result value is copied here 
+*/
+struct rsasoc_rsp_result {
+	_uint64_t result;
+};
+
+/**
+* struct esssoc_rsp_result - ECC engine result 
+* @result: Result value is copied here 
+*/
+struct eccsoc_rsp_result {
+	_uint64_t result;
+};
+
+/*
+* struct cryptosoc_rsp_result - Union of sae/rsa/ecc result.
+* The application should look in to the appropriate values, 
+* based on the station from which the response has been
+* received.
+* @sae_res: SAE Result value is copied here 
+* @rsa_res: RSA Result value is copied here 
+* @ecc_res: ECC Result value is copied here 
+*/
+
+struct cryptosoc_rsp_result {
+	union {
+		struct saesoc_rsp_result sae_res;
+		struct rsasoc_rsp_result rsa_res;
+		struct eccsoc_rsp_result ecc_res;
+	};
+};
+
+typedef struct {
+	volatile unsigned int lock;
+} cryptosoc_lock_t;
+
+static inline void cryptosoc_lock_init(cryptosoc_lock_t *lock)
+{
+	lock->lock = 0;
+}
+
+
+
+typedef void *cryptosoc__mem_alloc(size_t align, size_t size);
+typedef void cryptosoc__mem_free(void *ptr);
+
+extern cryptosoc__mem_alloc *cryptosoc_mem_alloc;
+extern cryptosoc__mem_free *cryptosoc_mem_free;
+extern int cryptosoc_ptype_gen;
+extern int cryptosoc_lib_init(struct cryptosoc_lib_params *params, 
+		void *(mem_alloc)(size_t align, size_t size),
+		void (mem_free)(void *ptr),
+		void *arg);
+extern int cryptosoc_get_basevc_limitvc(enum cryptosoc_soc_type soc, 
+		int *base_vc, int *lmt_vc);
+extern int cryptosoc_get_single_channel_vcmask(enum cryptosoc_soc_type soc, 
+		unsigned int *vc_mask);
+extern int cryptosoc_get_multi_channel_vcmask(enum cryptosoc_soc_type soc, 
+		unsigned int *vc_mask);
+int cryptosoc_get_highpri_channel_vcmask(enum cryptosoc_soc_type soc, 
+		unsigned int *vc_mask);
+extern int cryptosoc_process_request(int gen_type2, 
+		enum cryptosoc_soc_type soc,
+		int req_vc, int fbvc, 
+		int code, int retry_count,
+		_uint64_t msg0, _uint64_t msg1, _uint64_t msg2,
+		_uint64_t *rx_msg);
+
+#if defined(__mips__)
+/* last bit set indication - from lsb to msb ,
+*  clz instruction looks for number of cleared bit from msb to lsb
+*  get_lbs(0) = 0, get_lbs(1) = 1, get_lbs(0x80000000) = 32
+*/
+static inline unsigned int cryptosoc_get_lbs(unsigned int x)
+{
+	__asm__(".set push      \n"
+			".set mips32    \n"
+			"clz %0, %1     \n"
+			".set pop       \n"
+			:"=r" (x)
+			:"r" (x));
+	return 32 - x;
+}
+
+static inline void cryptosoc_lock(cryptosoc_lock_t *lock)
+{
+	unsigned int tmp, pid;
+	pid = getpid();
+
+	__asm__ __volatile__(
+			".set 	push\n"
+			".set	noreorder\n"
+			"1:	ll %1, %2\n"
+			"bgtz	%1, 1b\n"
+			"move	%1, %3\n"
+			"sc	%1, %0\n"
+			"beqz	%1, 1b\n"
+			" sync	\n"
+			".set	pop\n"
+			: "=m" (lock->lock), "=&r" (tmp)
+			: "m" (lock->lock), "r" (pid)
+			: "memory");
+}
+
+static inline void cryptosoc_unlock(cryptosoc_lock_t *lock)
+{
+	__asm__ __volatile__(
+			".set 	push\n"
+			".set	noreorder\n"
+			"sync	\n"
+			"sw	$0, %0\n"
+			".set	pop\n"
+			: "=m" (lock->lock)
+			: "m" (lock->lock)
+			: "memory");
+}
+
+#endif //__mips__
+
+#endif
diff --git a/arch/mips/netlogic/lib/seclib/eccsoc_defs.h b/arch/mips/netlogic/lib/seclib/eccsoc_defs.h
new file mode 100644
index 0000000..fe88495
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/eccsoc_defs.h
@@ -0,0 +1,144 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _ECCSOC_DEFS_H
+#define _ECCSOC_DEFS_H
+
+/**
+* enum eccsoc_data_format - RSA Data input/output format
+*
+* @ECCSOC_DATA_WSZ_64BIT_MSW_FIRST: Individual unit size is 64bit and 
+* 		most significant word is first. Memory should be dword aligned,
+* 		and total allocated size should be multiple of dword size.
+* @ECCSOC_DATA_WSZ_64BIT_LSW_FIRST: Individual unit size is 64bit and 
+* 		least significant word is first. Memory should be dword aligned,
+* 		and total allocated size should be multiple of dword size
+* @ECCSOC_DATA_WSZ_32BIT_MSW_FIRST: Individual unit size is 32bit and 
+* 		most significant word is first. Memory should be word aligned
+* 		and total allocated size should be multiple of word size.
+* @ECCSOC_DATA_WSZ_32BIT_LSW_FIRST: Individual unit size is 32bit and 
+* 		least significant word is first. Memory should be word aligned
+* 		and total allocated size should be multiple of word size.
+* @ECCSOC_DATA_WSZ_8BIT_MSW_FIRST: Individual unit size is 8bit and 
+* 		most significant word is first
+* @ECCSOC_DATA_WSZ_8BIT_LSW_FIRST: Individual unit size is 8bit and 
+* 		least significant word is first
+* @ECCSOC_DATA_FMT_MAX: End of data format type
+*/
+enum eccsoc_data_format {
+	ECCSOC_DATA_WSZ_64BIT_MSW_FIRST=0,
+	ECCSOC_DATA_WSZ_64BIT_LSW_FIRST,
+	ECCSOC_DATA_WSZ_32BIT_MSW_FIRST,
+	ECCSOC_DATA_WSZ_32BIT_LSW_FIRST,
+	ECCSOC_DATA_WSZ_8BIT_MSW_FIRST,
+	ECCSOC_DATA_WSZ_8BIT_LSW_FIRST,
+	ECCSOC_DATA_FMT_MAX
+};
+
+#define ECCSOC_DATA_FORMAT_SET
+
+/**
+* enum eccsoc_op_type - ECC Operation type
+* @ECCSOC_TYPE_64  : 64 bits  operation
+* @ECCSOC_TYPE_128  : 128 bits operation
+* @ECCSOC_TYPE_192  : 192 bits operation
+* @ECCSOC_TYPE_256  : 256 bits operation
+* @ECCSOC_TYPE_320  : 320 bits operation
+* @ECCSOC_TYPE_384  : 384 bits operation
+* @ECCSOC_TYPE_448  : 448 bits operation
+* @ECCSOC_TYPE_512  : 512 bits operation
+* @ECCSOC_TYPE_576  : 576 bits operation
+*/
+enum eccsoc_op_type {
+	ECCSOC_TYPE_64=0x0,
+	ECCSOC_TYPE_128,
+	ECCSOC_TYPE_192,
+	ECCSOC_TYPE_256,
+	ECCSOC_TYPE_320,
+	ECCSOC_TYPE_384,
+	ECCSOC_TYPE_448,
+	ECCSOC_TYPE_512,
+	ECCSOC_TYPE_576
+};
+
+/**
+* enum eccsoc_op - ECC Operation
+* @ECCSOC_POINT_MUL  : Point multiplication
+* @ECCSOC_POINT_ADD  : Point addition 
+* @ECCSOC_POINT_DBL : Point double 
+* @ECCSOC_POINT_VERIFY : Point verification 
+* @ECCSOC_MOD_ADD : Modular addition 
+* @ECCSOC_MOD_SUB : Modular subtraction 
+* @ECCSOC_MOD_MUL : Modular multiplication 
+* @ECCSOC_MOD_DIV : Modular division 
+* @ECCSOC_MOD_INV : Modular inversion 
+* @ECCSOC_MOD_RED : Modular reduction 
+* @ECCSOC_OP_MAX : End of operation 
+*/
+enum eccsoc_op {
+	ECCSOC_POINT_MUL = 0x0,
+	ECCSOC_POINT_ADD,
+	ECCSOC_POINT_DBL,
+	ECCSOC_POINT_VERIFY,
+	ECCSOC_MOD_ADD,
+	ECCSOC_MOD_SUB,
+	ECCSOC_MOD_MUL,
+	ECCSOC_MOD_DIV,
+	ECCSOC_MOD_INV,
+	ECCSOC_MOD_RED,
+	ECCSOC_OP_MAX
+	
+};
+
+/**
+* defines ecc_req_flags - Rsa operation request flags
+* @RSASOC_SRC_L3_ALLOC: Casuses source data to transit through L3 cache
+* @RSASOC_DST_L3_ALLOC: Causes data written to the dram is also copied to l3 cache
+* @RSASOC_DST_CLOBBER: Causes data to be written as 64byte cacheline, 
+*   no read modify write
+* @ECCSOC_ARGS_MEM_REGION_CRYPTOSOC: All the arguments are allocated 
+*    using cryptosoc_mem_alloc. So that virt_to_phys conversion can be done.
+*/
+
+/*!defines ecc_req_flags < */
+#define ECCSOC_SRC_L3_ALLOC 0x01
+#define ECCSOC_DST_L3_ALLOC 0x02
+#define ECCSOC_DST_CLOBBER  0x04
+#define ECCSOC_ARGS_MEM_REGION_CRYPTOSOC 0x8
+/*!defines ecc_req_flags > */
+
+
+#endif
+
diff --git a/arch/mips/netlogic/lib/seclib/eccsoc_gen1_hal_defs.h b/arch/mips/netlogic/lib/seclib/eccsoc_gen1_hal_defs.h
new file mode 100644
index 0000000..4989c0d
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/eccsoc_gen1_hal_defs.h
@@ -0,0 +1,173 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+#ifndef _ECCSOC_GEN1_HAL_DEFS_H_
+#define _ECCSOC_GEN1_HAL_DEFS_H_
+
+#include "cryptosoc_lib.h"
+
+#define ECCSOC_GEN1_SET_BITS(X,PARAM) \
+	(((_uint64_t)X & ECCSOC_GEN1_##PARAM##_MASK) << ECCSOC_GEN1_##PARAM##_SHIFT)
+
+#define ECCSOC_GEN1_GET_BITS(X,PARAM) \
+	 ((_uint64_t)(( (_uint64_t)X >> ECCSOC_GEN1_##PARAM##_SHIFT) & \
+		 ECCSOC_GEN1_##PARAM##_MASK)) 
+	
+
+#define ECCSOC_GEN1_SRC_L3_ALLOC_MASK 0x1ULL
+#define ECCSOC_GEN1_SRC_L3_ALLOC_SHIFT 61
+
+#define ECCSOC_GEN1_TYPE_MASK 0x7fULL
+#define ECCSOC_GEN1_TYPE_SHIFT 46
+
+#define ECCSOC_GEN1_FUNC_MASK 0x3fULL
+#define ECCSOC_GEN1_FUNC_SHIFT 40
+
+#define ECCSOC_GEN1_SRC_ADDR_MASK 0xffffffffffULL
+#define ECCSOC_GEN1_SRC_ADDR_SHIFT 0
+
+
+#define ECCSOC_GEN1_DST_CLOBBER_MASK 0x1ULL
+#define ECCSOC_GEN1_DST_CLOBBER_SHIFT 62
+
+#define ECCSOC_GEN1_DST_L3_ALLOC_MASK 0x1ULL
+#define ECCSOC_GEN1_DST_L3_ALLOC_SHIFT 61
+
+#define ECCSOC_GEN1_FBVC_MASK 0xfffULL
+#define ECCSOC_GEN1_FBVC_SHIFT 40
+
+#define ECCSOC_GEN1_DST_ADDR_MASK 0xffffffffffULL
+#define ECCSOC_GEN1_DST_ADDR_SHIFT 0
+
+
+
+/**
+* eccsoc_gen1_form_fmn_entry0 - Generate crypto rsa fmn message entry 0
+* @src_l3_alloc: 1/0, 1 casuses source data to transit through l3 cache
+* @type: type of the operation, see rsasoc_op_type
+* @func: operation function, see rsasoc_op
+* @src_addr : source address
+*
+* Returns: Filled fmn entry0
+*/
+
+static inline _uint64_t  eccsoc_gen1_form_fmn_entry0(unsigned int src_l3_alloc, 
+		unsigned int type, 
+		unsigned int func, _uint64_t src_addr)
+{
+	return( ECCSOC_GEN1_SET_BITS(src_l3_alloc, SRC_L3_ALLOC) |
+		ECCSOC_GEN1_SET_BITS(type, TYPE) | 
+		ECCSOC_GEN1_SET_BITS(func, FUNC) |
+		ECCSOC_GEN1_SET_BITS(src_addr, SRC_ADDR));
+}
+
+/**
+* eccsoc_gen1_form_fmn_entry1 -  Generate crypto rsa fmn message entry 1
+* 
+* @dst_clobber: 1/0, 1 causes data to be written as 64byte cacheline
+* @dst_l3_alloc: 1/0, 1 causes data written to the dram is also copied to l3 cache
+* @fbvc: freeback message vc
+* @dst_addr : destination address where result will be copied
+*
+* Returns: Filled fmn entry1
+*/
+
+
+static inline _uint64_t  eccsoc_gen1_form_fmn_entry1(unsigned int dst_clobber, 
+		unsigned int dst_l3_alloc, 
+		unsigned int fbvc, _uint64_t dst_addr)
+{
+
+	return( ECCSOC_GEN1_SET_BITS(dst_clobber, DST_CLOBBER) |
+		ECCSOC_GEN1_SET_BITS(dst_l3_alloc, DST_L3_ALLOC) | 
+		ECCSOC_GEN1_SET_BITS(fbvc, FBVC) |
+		ECCSOC_GEN1_SET_BITS(dst_addr, DST_ADDR));
+
+}
+
+static inline char *eccsoc_get_op_type(int val, char *buf)
+{
+	strcpy(buf, "Reserved");
+
+	if(val <= 8)
+		sprintf(buf, "P%d", (val + 1) * 64);
+	else if(val >= 0x20 && val <= 0x28)
+		sprintf(buf, "B%d", ((val - 0x20) + 1) * 64);
+	return buf;
+}
+
+static inline char *eccsoc_get_op_func(int val, char *buf)
+{
+	char op[][16] = { 
+		"PointMul", "PointAdd", "PointDbl", "PointVerify",
+		"ModAdd", "ModSub", "ModMul", 
+		"ModDiv", "ModInv", "ModRed" };
+
+	strcpy(buf, "Reserved");
+	if(val <= 9)
+		 strcpy(buf, op[val]);
+	return buf;
+}
+
+
+
+static inline void eccsoc_gen1_dump_fmnentry(_uint64_t entry0, _uint64_t entry1)
+{
+	char buf[32], buf1[32];
+	cryptosoc_dbg_print("\nFmn Info entry0 %llx entry1 %llx\n",entry0, entry1);
+	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s\n",
+			"SrcL3Alloc","Type", "Func", "SrcAddr");
+
+	cryptosoc_dbg_print("  %-16lld %-16s %-16s %-16llx\n",
+			ECCSOC_GEN1_GET_BITS(entry0, SRC_L3_ALLOC),
+			eccsoc_get_op_type(ECCSOC_GEN1_GET_BITS(entry0, TYPE), buf),
+			eccsoc_get_op_func(ECCSOC_GEN1_GET_BITS(entry0, FUNC), buf1),
+			ECCSOC_GEN1_GET_BITS(entry0, SRC_ADDR));
+
+	cryptosoc_dbg_print("\n  %-16s %-16s %-16s %-16s\n",
+			"DstClobber","DstL3Alloc", "FbVC", "DstAddr");
+
+	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16llx\n",
+			ECCSOC_GEN1_GET_BITS(entry1, DST_CLOBBER),
+			ECCSOC_GEN1_GET_BITS(entry1, DST_L3_ALLOC),
+			ECCSOC_GEN1_GET_BITS(entry1, FBVC),
+			ECCSOC_GEN1_GET_BITS(entry1, DST_ADDR));
+
+	cryptosoc_dbg_print("\n");
+
+}
+
+
+#endif
diff --git a/arch/mips/netlogic/lib/seclib/eccsoc_lib.h b/arch/mips/netlogic/lib/seclib/eccsoc_lib.h
new file mode 100644
index 0000000..c295664
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/eccsoc_lib.h
@@ -0,0 +1,1644 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _ECCSOC_LIB_H
+#define _ECCSOC_LIB_H
+
+/* Include file for application specific macros */
+#include "cryptosoc_lib.h"
+#include "cryptosoc_lib_ifc.h"
+#include "cryptosoc_ctx.h"
+
+#ifdef ECCSOC_PTYPE_GEN_ALL_SUPPORT
+#define ECCSOC_PTYPE_GEN2_SUPPORT
+#define ECCSOC_PTYPE_GEN1_SUPPORT
+#endif
+
+#include "eccsoc_defs.h"
+#include "rsaecc_soc_common.h"
+
+/* Include file for processor specific macros to set the descriptors. 
+*  hal macros should be after _ifc.h(Because of -GEN2- en/dis */
+#ifdef ECCSOC_PTYPE_GEN2_SUPPORT
+#include "eccsoc_gen1_hal_defs.h"
+#endif
+
+#ifdef ECCSOC_PTYPE_GEN1_SUPPORT
+#include "eccsoc_gen1_hal_defs.h"
+#endif
+
+
+#ifdef ECCSOC_PTYPE_GEN_ALL_SUPPORT
+#define IF_ECCSOC_PTYPE_IS_GEN1 if(cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN1)
+#define IF_ECCSOC_PTYPE_IS_GEN2 if(cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2)
+#else
+#define IF_ECCSOC_PTYPE_IS_GEN1
+#define IF_ECCSOC_PTYPE_IS_GEN2 
+#endif
+
+#include "nlm_hal_fmn.h"
+
+#define ECCSOC_BINARY_TYPE_SVALUE 0x20
+
+/**
+* DOC: ECCSOC
+*
+* These APIs abstract the ECC SOC present in the processor.
+*
+* The below macros should be defined by the application. 
+* 
+* ECCSOC_REQ_DESC_APP_PRIV_SZ:
+*   Application private data size in the request descriptor. Should be 
+*   multiple of cachelines.
+*
+* Processor type : Either ECCSOC_PTYPE_GEN_ALL_SUPPORT or 
+*  ECCSOC_PTYPE_GEN2_SUPPORT/ECCSOC_PTYPE_GEN1_SUPPORT
+*/
+
+
+struct eccsoc_req_desc_priv_data {
+	/* number of operations to perform. The application can fill
+	*  multiple operations in one structure and can send to the engine 
+	*  in parallel or serial. 
+	*  */
+	int num_reqs; 
+	/* To save the input/return data address,
+	num_reqs size, dynamically allocated */
+	int max_reqs;
+	struct eccsoc_req_info *req_info; 
+};
+
+
+/* This should be aligned to 8 bytes, as the engine 
+*  data starts after this and that should be aligned 
+*  to 8 bytes */
+struct eccsoc_req_info {
+	void *inp; /* data memory - allocated by the library */
+	void *res; /* result memory - allocated by the library */
+
+	int inp_alloc; /* if inp is separately allocated */
+	int res_alloc; /* if res is separately allocated */
+
+	int inp_size; /* size of input mem */
+	int res_size; /* size of result mem */
+
+	void *eng_inp; /* input data memory, either inp or input-args */
+	void *eng_res; /* result data memory, either res or result-args  */
+
+	void *usr_res_x; /* user given result memory */
+	void *usr_res_y; /* user given result memory */
+
+	int rxlen_in_bits; /* user given result memory bitlen */
+	int rylen_in_bits; /* user given result memory bitlen */
+
+	int blksz_in_bits;
+	int out_word_bigendian;
+
+	int op; /* operation */
+	int type; /* type */
+
+	int flags;
+	int out_data_fmt;
+
+};
+
+
+#define ECCSOC_DATA_DESC_LIB_PRIV_SZ \
+	 (((sizeof(struct eccsoc_req_desc_priv_data) / CRYPTOSOC_CACHELINE_SZ) + 1) * \
+	          CRYPTOSOC_CACHELINE_SZ)
+
+#define ECCSOC_MAX_BLOCK_SZ_IN_BITS 	576
+
+/**
+* struct eccsoc_arg - Operation data argument type
+* @v: Pointer to the value
+* @len_in_bits : Data length in bits
+*/
+struct eccsoc_arg {
+	void *v;
+	int  len_in_bits;
+};
+
+/**
+* struct eccsoc_point_arg - Operation point argument type
+* @x: Pointer to the x access value
+* @xlen_in_bits : x access data length in bits
+* @y: Pointer to the y access value
+* @ylen_in_bits : y access data length in bits
+*/
+struct eccsoc_point_arg {
+	void *x;
+	int  xlen_in_bits;
+	void *y;
+	int  ylen_in_bits;
+};
+
+
+/**
+* struct eccsoc_pmul_args - Point multiplication operation argument (r(x,y)=k*p(x,y))
+* @p : Point input
+* @a : Curve paramter
+* @k : Scalar
+* @n : Modulus
+* @r : Result point
+*/
+struct eccsoc_pmul_args {
+	struct eccsoc_point_arg p;
+	struct eccsoc_arg a;
+	struct eccsoc_arg k;
+	struct eccsoc_arg n;
+	struct eccsoc_point_arg r;
+};
+
+/**
+* struct eccsoc_padd_args - Point addition operation argument (r(x,y)=p(x,y)+q(x,y))
+* @p : Point input-1
+* @q : Point input-2
+* @a : Curve paramter
+* @n : Modulus
+* @r : Result point
+*/
+struct eccsoc_padd_args {
+	struct eccsoc_point_arg p;
+	struct eccsoc_point_arg q;
+	struct eccsoc_arg a;
+	struct eccsoc_arg n;
+	struct eccsoc_point_arg r;
+};
+
+/**
+* struct eccsoc_pdbl_args - Point double operation argument (r(x,y)=2*p(x,y)))
+* @p : Point input
+* @a : Curve paramter
+* @n : Modulus
+* @r : Result point
+*/
+struct eccsoc_pdbl_args {
+	struct eccsoc_point_arg p;
+	struct eccsoc_arg a;
+	struct eccsoc_arg n;
+	struct eccsoc_point_arg r;
+};
+
+/**
+* struct eccsoc_pverify_args - Point verify operation argument 
+*   (r(x,y)=1 when p(x,y) is on curve, 0 otherwise)
+* @p : Point input
+* @a : Curve paramter
+* @b : Curve paramter
+* @n : Modulus
+* @r : Result pointer
+*/
+struct eccsoc_pverify_args {
+	struct eccsoc_point_arg p;
+	struct eccsoc_arg a;
+	struct eccsoc_arg b;
+	struct eccsoc_arg n;
+	struct eccsoc_arg r;
+};
+
+/**
+* struct eccsoc_madd_args -  Modular addition operation argument(r= x+y mod n)
+* @x : Parameter 1
+* @y : Parameter 2
+* @n : Modulus
+* @r : Result 
+*/
+struct eccsoc_madd_args {
+	struct eccsoc_arg x;
+	struct eccsoc_arg y;
+	struct eccsoc_arg n;
+	struct eccsoc_arg r;
+};
+
+/**
+* struct eccsoc_msub_args -  Modular subtraction operation argument(r= x-y mod n)
+* @x : Parameter 1
+* @y : Parameter 2
+* @n : Modulus
+* @r : Result 
+*/
+struct eccsoc_msub_args {
+	struct eccsoc_arg x;
+	struct eccsoc_arg y;
+	struct eccsoc_arg n;
+	struct eccsoc_arg r;
+};
+
+
+/**
+* struct eccsoc_mmul_args -  Modular multiplication operation argument(r= x*y mod n)
+* @x : Parameter 1
+* @y : Parameter 2
+* @n : Modulus
+* @r : Result 
+*/
+struct eccsoc_mmul_args {
+	struct eccsoc_arg x;
+	struct eccsoc_arg y;
+	struct eccsoc_arg n;
+	struct eccsoc_arg r;
+};
+
+/**
+* struct eccsoc_mdiv_args -  Modular divition operation argument(r= x/y mod n)
+* @x : Parameter 1
+* @y : Parameter 2
+* @n : Modulus
+* @r : Result 
+*/
+struct eccsoc_mdiv_args {
+	struct eccsoc_arg x;
+	struct eccsoc_arg y;
+	struct eccsoc_arg n;
+	struct eccsoc_arg r;
+};
+
+/**
+* struct eccsoc_minv_args -  Modular inverse operation argument(r= 1/x mod n)
+* @x : Parameter 1
+* @n : Modulus
+* @r : Result 
+*/
+struct eccsoc_minv_args {
+	struct eccsoc_arg x;
+	struct eccsoc_arg n;
+	struct eccsoc_arg r;
+};
+
+/**
+* struct eccsoc_mred_args -  Modular reduction operation argument(r= x mod n)
+* @x : Parameter 1
+* @n : Modulus
+* @r : Result 
+*/
+struct eccsoc_mred_args {
+	struct eccsoc_arg x;
+	struct eccsoc_arg n;
+	struct eccsoc_arg r;
+};
+
+/**
+* struct eccsoc_request_params - Each operation request parameters
+* @inp_data_fmt: Input data format, see enum rsasoc_data_format
+* @out_data_fmt: Output data format, see enum rsasoc_data_format
+* @req_num: Request number
+* @word_bigendian: 1/0, Depending on the data word is big endian/little endian
+* @prime: 1/0, Set to 1 when the operation is prime, 0 for binary
+* @flags: Request flags, see define ecc_req_flags
+*/
+struct eccsoc_request_params {
+	enum eccsoc_data_format inp_data_fmt;
+	enum eccsoc_data_format out_data_fmt;
+	int req_num;
+	int word_bigendian;
+	int prime;
+	int flags; 
+};
+
+/**
+* struct eccsoc_request_desc - Data descriptor parameters
+* @lib_priv: Space to store the private data by the library. 
+* 	Application should not modify this area
+* @app_priv: Application private memory.
+* @data: Data storage space. Dynamic sized depending on the block size.
+*/
+struct eccsoc_request_desc {
+	char lib_priv[ECCSOC_DATA_DESC_LIB_PRIV_SZ];
+	char app_priv[RSASOC_REQ_DESC_APP_PRIV_SZ];
+	char data[0];
+}___cryptosoc_cacheline_aligned;
+
+
+/**
+* struct eccsoc_extra_req_send_params - RSA send request options
+* @send_all_requests : 1/0, Send all the requests present in the data descriptor
+* @sreq_num : Starting request number, Ignored 
+*    if the send_all_requests is true.
+* @num_reqs : Number of requests from sreq_num, Ignored 
+*    if the send_all_requests is true.
+*  @async_rsp_arg: User given callback argument, used in async mode only
+*/
+struct eccsoc_extra_req_send_params {
+	int send_all_requests;
+	int sreq_num;
+	int num_reqs;
+	_uint64_t async_rsp_arg;
+};
+
+
+static int eccsoc_max_req_args[] =  {
+	[ECCSOC_POINT_MUL] = 5,
+	[ECCSOC_POINT_ADD] = 6,
+	[ECCSOC_POINT_DBL] = 4,
+	[ECCSOC_POINT_VERIFY] = 5,
+	[ECCSOC_MOD_ADD] = 3,
+	[ECCSOC_MOD_SUB] = 3,
+	[ECCSOC_MOD_MUL] = 3,
+	[ECCSOC_MOD_DIV] = 3,
+	[ECCSOC_MOD_INV] = 2,
+	[ECCSOC_MOD_RED] = 2
+};
+
+static int eccsoc_max_rsp_args[] =  {
+	[ECCSOC_POINT_MUL] = 2,
+	[ECCSOC_POINT_ADD] = 2,
+	[ECCSOC_POINT_DBL] = 2,
+	[ECCSOC_POINT_VERIFY] = 1,
+	[ECCSOC_MOD_ADD] = 1,
+	[ECCSOC_MOD_SUB] = 1,
+	[ECCSOC_MOD_MUL] = 1,
+	[ECCSOC_MOD_DIV] = 1,
+	[ECCSOC_MOD_INV] = 1,
+	[ECCSOC_MOD_RED] = 1
+};
+
+static inline int eccsoc_validate_input(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc *desc, void *margs)
+{
+
+	struct eccsoc_req_desc_priv_data *dpriv;
+
+	if(!req_p || !margs)
+		return -CRYPTOSOC_EINVAL;
+
+
+	if(desc) {
+		dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+	   	if(dpriv->max_reqs < req_p->req_num) {
+			cryptosoc_err_print("%s:%d, Error - Request overflow \n", 
+					__FUNCTION__, __LINE__);
+			return -CRYPTOSOC_EINVAL;
+		}
+	} else if(req_p->req_num != 1 || max_reqs <= 0) {
+		/* request number should be one for the new descriptor 
+		*  creation */
+		cryptosoc_err_print("%s:%d, Error - Invalid request number \n", 
+					__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+	return CRYPTOSOC_OK;
+}
+
+
+
+static inline int eccsoc_get_blksz_in_bits(int max_len_in_bits)
+{
+	int rv = max_len_in_bits;
+	/* block size starts from 64, roundup the size to the next one supported
+	*  by the engine */
+	if((rv % 64) != 0) 
+		rv = (rv + 63) & (~63); 
+	return rv;
+}
+
+static inline void eccsoc_save_res_info(
+		 struct eccsoc_req_desc_priv_data *dpriv, 
+		 int req_num, int res_size, 
+		 char *res,  char *rx, int rxlen_in_bits, 
+		 char *ry,  int rylen_in_bits, int out_data_fmt)
+{
+	if(res_size) {
+		 dpriv->req_info[req_num].eng_res =  res;
+		 dpriv->req_info[req_num].usr_res_x =  rx;
+		 dpriv->req_info[req_num].usr_res_y =  ry;
+		 dpriv->req_info[req_num].rxlen_in_bits = rxlen_in_bits;
+		 dpriv->req_info[req_num].rylen_in_bits = rylen_in_bits;
+		 dpriv->req_info[req_num].out_data_fmt = out_data_fmt;
+	} else {
+		 dpriv->req_info[req_num].eng_res =  rx;
+		 dpriv->req_info[req_num].usr_res_x = NULL;
+		 dpriv->req_info[req_num].usr_res_y = NULL;
+	}
+}
+
+static inline void	eccsoc_save_req_info(
+		 struct eccsoc_req_desc_priv_data *dpriv, int prime, int op,
+		 int req_num, int blksz_in_bits, int req_flags, int word_bigendian)
+{
+	int type = (blksz_in_bits / 64) - 1;
+	if(!prime)
+		type += ECCSOC_BINARY_TYPE_SVALUE;
+
+	dpriv->req_info[req_num].type = type;
+	dpriv->req_info[req_num].op = op;
+	dpriv->req_info[req_num].blksz_in_bits = blksz_in_bits;
+
+	dpriv->req_info[req_num].flags = req_flags;
+	dpriv->req_info[req_num].out_word_bigendian = word_bigendian;
+	/* request number is decremented above */
+	if(req_num >= dpriv->num_reqs)
+		dpriv->num_reqs++;
+}
+
+
+
+static inline struct eccsoc_request_desc *eccsoc_create_new_desc(
+		struct eccsoc_request_desc *desc,
+		int req_num, 
+		int max_reqs, int inp_size, int res_size)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int idx= 0;
+
+	if(desc) {
+		dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+		/* check the input */
+		if(inp_size && (dpriv->req_info[req_num].inp_size < inp_size)) {
+			cryptosoc_dbg_print("%s, reqnum %d input prevsize %d required %d\n", 
+					__FUNCTION__, req_num,
+					dpriv->req_info[req_num].inp_size, inp_size);
+			if(dpriv->req_info[req_num].inp_alloc)
+				cryptosoc_mem_free(dpriv->req_info[req_num].inp);
+			dpriv->req_info[req_num].inp = cryptosoc_mem_alloc(8, inp_size);
+			if(!dpriv->req_info[req_num].inp)
+				return NULL;
+			dpriv->req_info[req_num].inp_alloc = 1;
+		  	dpriv->req_info[req_num].inp_size = inp_size;
+		}
+
+		/* check the result */
+		if(res_size && (dpriv->req_info[req_num].res_size < res_size)) {
+			cryptosoc_dbg_print("%s, reqnum %d result  prevsize %d required %d\n", 
+					__FUNCTION__, req_num,
+					dpriv->req_info[req_num].res_size, res_size);
+			if(dpriv->req_info[req_num].res_alloc)
+				cryptosoc_mem_free(dpriv->req_info[req_num].res);
+			dpriv->req_info[req_num].res = cryptosoc_mem_alloc(8, res_size);
+			if(!dpriv->req_info[req_num].res)
+				return NULL;
+			dpriv->req_info[req_num].res_alloc = 1;
+		  	dpriv->req_info[req_num].res_size = res_size;
+		}
+	} else {
+		int req_info_sz = max_reqs * sizeof(struct eccsoc_req_info);
+		int size = inp_size + res_size + req_info_sz;
+		void *mbase;
+		desc = cryptosoc_mem_alloc(CRYPTOSOC_CACHELINE_SZ, sizeof(*desc) + size);
+		if(!desc)
+			return NULL; 
+		dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+		dpriv->num_reqs = 0;
+		dpriv->max_reqs = max_reqs;
+		dpriv->req_info =  (struct eccsoc_req_info *)&desc->data[0];
+	
+		mbase = (void *)((unsigned long)dpriv->req_info + req_info_sz);
+
+		/* part of desc */
+		dpriv->req_info[0].inp_alloc= 0;
+		dpriv->req_info[0].res_alloc= 0;
+		dpriv->req_info[0].op = -1;
+
+		if(inp_size) {
+			dpriv->req_info[0].inp = mbase;
+			dpriv->req_info[0].inp_size = inp_size;
+			mbase += inp_size;
+		} else
+			dpriv->req_info[0].inp_size = 0;
+
+		if(res_size) {
+			dpriv->req_info[0].res = mbase;
+			dpriv->req_info[0].res_size = res_size;
+		} else
+			 dpriv->req_info[0].res_size = 0;
+
+		for(idx = 1; idx < max_reqs; idx++) {
+			dpriv->req_info[idx].inp_alloc= 0;
+			dpriv->req_info[idx].res_alloc= 0;
+			dpriv->req_info[idx].inp_size = 0;
+			dpriv->req_info[idx].res_size = 0;
+		}
+	}
+	return desc;
+}
+
+/**
+* eccsoc_create_point_mul_request - Create point multiplication request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to point multiplication args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_point_mul_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_pmul_args *margs)
+{
+
+	int blksz_in_bits, blk, max_len_in_bits;
+	int inp_size = 0, res_size = 0;
+    int op, req_num;	
+	struct eccsoc_req_desc_priv_data *dpriv;
+	struct eccsoc_request_desc *desc = NULL;
+	
+	if(req_desc)
+		desc = *req_desc;
+
+	if(eccsoc_validate_input(req_p, max_reqs, desc, (void *)margs) < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	req_num = req_p->req_num;
+
+	/* result length should be greater or equal to the 
+	*  modulus length */
+	if(margs->r.xlen_in_bits < margs->n.len_in_bits || 
+			margs->r.ylen_in_bits < margs->n.len_in_bits) {
+		cryptosoc_err_print("%s:%d, Error - Result size  < modsize \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	/* find the block size */
+	max_len_in_bits = rsa_ecc_soc_find_max5(
+			margs->p.xlen_in_bits, margs->p.ylen_in_bits, 
+			margs->a.len_in_bits, margs->k.len_in_bits, margs->n.len_in_bits);
+
+	if(max_len_in_bits > ECCSOC_MAX_BLOCK_SZ_IN_BITS) {
+		cryptosoc_err_print("%s:%d, Error - Invalid block size \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	blksz_in_bits = eccsoc_get_blksz_in_bits(max_len_in_bits);
+	blk = blksz_in_bits / 8;
+	op = ECCSOC_POINT_MUL;
+
+	/* check whether input copy required */
+	if(!(req_p->flags & ECCSOC_ARGS_MEM_REGION_CRYPTOSOC))  {
+		inp_size =  eccsoc_max_req_args[op] * blk;
+		res_size = eccsoc_max_rsp_args[op] * blk;
+	} else  {
+		if(((margs->p.x + blk) != margs->p.y) ||
+			((margs->p.y + blk) != margs->a.v) ||
+			((margs->a.v + blk) != margs->k.v) ||
+			((margs->k.v + blk) != margs->n.v) ||
+			(margs->n.len_in_bits != blksz_in_bits) ||
+			(req_p->inp_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+		  		inp_size =  eccsoc_max_req_args[op] * blk;
+
+		if(((margs->r.x + blk) != margs->r.y) ||
+			(margs->r.xlen_in_bits != blksz_in_bits) ||
+			(margs->r.ylen_in_bits != blksz_in_bits) ||
+			(req_p->out_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+				res_size = eccsoc_max_rsp_args[op] * blk;
+	}
+
+	req_num--;
+
+	desc = eccsoc_create_new_desc(desc, req_num, 
+			max_reqs, inp_size, res_size);
+	if(!desc)
+		return -CRYPTOSOC_ENOMEM;
+	dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+
+	if(inp_size) {
+		void *mem = dpriv->req_info[req_num].inp;
+		dpriv->req_info[req_num].eng_inp = mem;
+
+		if(rsa_ecc_soc_input_copy_5(req_p->inp_data_fmt,
+					 req_p->word_bigendian, mem, blksz_in_bits,
+					 margs->p.x, margs->p.xlen_in_bits,
+					 margs->p.y, margs->p.ylen_in_bits,
+					 margs->a.v, margs->a.len_in_bits,
+					 margs->k.v, margs->k.len_in_bits,
+					 margs->n.v, margs->n.len_in_bits) < 0)
+			goto err_exit;
+	} else
+		dpriv->req_info[req_num].eng_inp = margs->p.x;
+
+	eccsoc_save_res_info(dpriv, req_num, res_size, 
+			dpriv->req_info[req_num].res, 
+			margs->r.x, margs->r.xlen_in_bits, 
+			margs->r.y,  margs->r.ylen_in_bits, req_p->out_data_fmt);
+
+	eccsoc_save_req_info(dpriv, req_p->prime, op, req_num, 
+			blksz_in_bits, req_p->flags, req_p->word_bigendian);
+
+	*req_desc = desc;
+	return CRYPTOSOC_OK;
+err_exit:
+	cryptosoc_err_print("%s:%d, Error - Data copy failed \n", 
+		__FUNCTION__, __LINE__);
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* eccsoc_create_point_add_request - Create point addition request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to point addition args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_point_add_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_padd_args *margs)
+{
+
+	int blksz_in_bits, blk, max_len_in_bits;
+	int inp_size = 0, res_size = 0;
+    int op, req_num;	
+	struct eccsoc_req_desc_priv_data *dpriv;
+	struct eccsoc_request_desc *desc = NULL;
+
+	if(req_desc)
+		desc = *req_desc;
+
+	if(eccsoc_validate_input(req_p, max_reqs, desc, (void *)margs) < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	req_num = req_p->req_num;
+
+	/* result length should be greater or equal to the 
+	*  modulus length */
+	if(margs->r.xlen_in_bits < margs->n.len_in_bits || 
+			margs->r.ylen_in_bits < margs->n.len_in_bits) {
+		cryptosoc_err_print("%s:%d, Error - Result size  < modsize \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	/* find the block size */
+	max_len_in_bits = rsa_ecc_soc_find_max6(
+			margs->p.xlen_in_bits, margs->p.ylen_in_bits, 
+			margs->q.xlen_in_bits,margs->q.ylen_in_bits, 
+			margs->a.len_in_bits, margs->n.len_in_bits);
+
+	if(max_len_in_bits > ECCSOC_MAX_BLOCK_SZ_IN_BITS) {
+		cryptosoc_err_print("%s:%d, Error - Invalid block size \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	blksz_in_bits = eccsoc_get_blksz_in_bits(max_len_in_bits);
+	blk = blksz_in_bits / 8;
+	op = ECCSOC_POINT_ADD;
+
+	/* check whether input copy required */
+	if(!(req_p->flags & ECCSOC_ARGS_MEM_REGION_CRYPTOSOC))  {
+		inp_size =  eccsoc_max_req_args[op] * blk;
+		res_size = eccsoc_max_rsp_args[op] * blk;
+	} else  {
+		if(((margs->p.x + blk) != margs->p.y) ||
+			((margs->p.y + blk) != margs->q.x) ||
+			((margs->q.y + blk) != margs->a.v) ||
+			((margs->a.v + blk) != margs->n.v) ||
+			(margs->n.len_in_bits != blksz_in_bits) ||
+			(req_p->inp_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+		  		inp_size =  eccsoc_max_req_args[op] * blk;
+
+		if(((margs->r.x + blk) != margs->r.y) ||
+			(margs->r.xlen_in_bits != blksz_in_bits) ||
+			(margs->r.ylen_in_bits != blksz_in_bits) ||
+			(req_p->out_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+				res_size = eccsoc_max_rsp_args[op] * blk;
+	}
+
+	req_num--;
+
+	desc = eccsoc_create_new_desc(desc, req_num, 
+			max_reqs, inp_size, res_size);
+	if(!desc)
+		return -CRYPTOSOC_ENOMEM;
+	dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+
+	if(inp_size) {
+		void *mem = dpriv->req_info[req_num].inp;
+		dpriv->req_info[req_num].eng_inp = mem;
+
+		if(rsa_ecc_soc_input_copy_6(req_p->inp_data_fmt,
+					 req_p->word_bigendian, mem, blksz_in_bits,
+					 margs->p.x, margs->p.xlen_in_bits,
+					 margs->p.y, margs->p.ylen_in_bits,
+					 margs->q.x, margs->q.xlen_in_bits,
+					 margs->q.y, margs->q.ylen_in_bits,
+					 margs->a.v, margs->a.len_in_bits,
+					 margs->n.v, margs->n.len_in_bits) < 0)
+			goto err_exit;
+	} else
+		dpriv->req_info[req_num].eng_inp = margs->p.x;
+
+	eccsoc_save_res_info(dpriv, req_num, res_size, 
+			dpriv->req_info[req_num].res, 
+			margs->r.x, margs->r.xlen_in_bits, 
+			margs->r.y,  margs->r.ylen_in_bits, req_p->out_data_fmt);
+
+	eccsoc_save_req_info(dpriv, req_p->prime, op, req_num, 
+			blksz_in_bits, req_p->flags, req_p->word_bigendian);
+
+	*req_desc = desc;
+	return CRYPTOSOC_OK;
+err_exit:
+	cryptosoc_err_print("%s:%d, Error - Data copy failed \n", 
+		__FUNCTION__, __LINE__);
+	return -CRYPTOSOC_EINVAL;
+}
+
+
+/**
+* eccsoc_create_point_dbl_request - Create point double request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to point double args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_point_dbl_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_pdbl_args *margs)
+{
+
+	int blksz_in_bits, blk, max_len_in_bits;
+	int inp_size = 0, res_size = 0;
+    int op, req_num;	
+	struct eccsoc_req_desc_priv_data *dpriv;
+	struct eccsoc_request_desc *desc = NULL;
+
+	if(req_desc)
+		desc = *req_desc;
+
+	if(eccsoc_validate_input(req_p, max_reqs, desc, (void *)margs) < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	req_num = req_p->req_num;
+
+	/* result length should be greater or equal to the 
+	*  modulus length */
+	if(margs->r.xlen_in_bits < margs->n.len_in_bits || 
+			margs->r.ylen_in_bits < margs->n.len_in_bits) {
+		cryptosoc_err_print("%s:%d, Error - Result size  < modsize \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	/* find the block size */
+	max_len_in_bits = rsa_ecc_soc_find_max4(
+			margs->p.xlen_in_bits, margs->p.ylen_in_bits, 
+			margs->a.len_in_bits, margs->n.len_in_bits);
+
+	if(max_len_in_bits > ECCSOC_MAX_BLOCK_SZ_IN_BITS) {
+		cryptosoc_err_print("%s:%d, Error - Invalid block size \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	blksz_in_bits = eccsoc_get_blksz_in_bits(max_len_in_bits);
+	blk = blksz_in_bits / 8;
+	op = ECCSOC_POINT_DBL;
+
+	/* check whether input copy required */
+	if(!(req_p->flags & ECCSOC_ARGS_MEM_REGION_CRYPTOSOC))  {
+		inp_size =  eccsoc_max_req_args[op] * blk;
+		res_size = eccsoc_max_rsp_args[op] * blk;
+	} else  {
+		if(((margs->p.x + blk) != margs->p.y) ||
+			((margs->p.y + blk) != margs->a.v) ||
+			((margs->a.v + blk) != margs->n.v) ||
+			(margs->n.len_in_bits != blksz_in_bits) ||
+			(req_p->inp_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+		  		inp_size =  eccsoc_max_req_args[op] * blk;
+
+		if(((margs->r.x + blk) != margs->r.y) ||
+			(margs->r.xlen_in_bits != blksz_in_bits) ||
+			(margs->r.ylen_in_bits != blksz_in_bits) ||
+			(req_p->out_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+				res_size = eccsoc_max_rsp_args[op] * blk;
+	}
+
+	req_num--;
+
+	desc = eccsoc_create_new_desc(desc, req_num, 
+			max_reqs, inp_size, res_size);
+	if(!desc)
+		return -CRYPTOSOC_ENOMEM;
+	dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+
+	if(inp_size) {
+		void *mem = dpriv->req_info[req_num].inp;
+		dpriv->req_info[req_num].eng_inp = mem;
+
+		if(rsa_ecc_soc_input_copy_4(req_p->inp_data_fmt,
+					 req_p->word_bigendian, mem, blksz_in_bits,
+					 margs->p.x, margs->p.xlen_in_bits,
+					 margs->p.y, margs->p.ylen_in_bits,
+					 margs->a.v, margs->a.len_in_bits,
+					 margs->n.v, margs->n.len_in_bits) < 0)
+			goto err_exit;
+	} else
+		dpriv->req_info[req_num].eng_inp = margs->p.x;
+
+	eccsoc_save_res_info(dpriv, req_num, res_size, 
+			dpriv->req_info[req_num].res, 
+			margs->r.x, margs->r.xlen_in_bits, 
+			margs->r.y,  margs->r.ylen_in_bits, req_p->out_data_fmt);
+
+	eccsoc_save_req_info(dpriv, req_p->prime, op, req_num, 
+			blksz_in_bits, req_p->flags, req_p->word_bigendian);
+
+	*req_desc = desc;
+	return CRYPTOSOC_OK;
+err_exit:
+	cryptosoc_err_print("%s:%d, Error - Data copy failed \n", 
+		__FUNCTION__, __LINE__);
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* eccsoc_create_point_verify_request - Create point verification request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to point verification args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_point_verify_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_pverify_args *margs)
+{
+
+	int blksz_in_bits, blk, max_len_in_bits;
+	int inp_size = 0, res_size = 0;
+    int op, req_num;	
+	struct eccsoc_req_desc_priv_data *dpriv;
+	struct eccsoc_request_desc *desc = NULL;
+
+	if(req_desc)
+		desc = *req_desc;
+
+	if(eccsoc_validate_input(req_p, max_reqs, desc, (void *)margs) < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	req_num = req_p->req_num;
+
+	/* result length should be greater or equal to the 
+	*  modulus length */
+	if(margs->r.len_in_bits < margs->n.len_in_bits) {
+		cryptosoc_err_print("%s:%d, Error - Result size  < modsize \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	/* find the block size */
+	max_len_in_bits = rsa_ecc_soc_find_max5(
+			margs->p.xlen_in_bits, margs->p.ylen_in_bits, 
+			margs->a.len_in_bits, margs->b.len_in_bits, margs->n.len_in_bits);
+
+	if(max_len_in_bits > ECCSOC_MAX_BLOCK_SZ_IN_BITS) {
+		cryptosoc_err_print("%s:%d, Error - Invalid block size \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	blksz_in_bits = eccsoc_get_blksz_in_bits(max_len_in_bits);
+	blk = blksz_in_bits / 8;
+	op = ECCSOC_POINT_VERIFY;
+
+	/* check whether input copy required */
+	if(!(req_p->flags & ECCSOC_ARGS_MEM_REGION_CRYPTOSOC))  {
+		inp_size =  eccsoc_max_req_args[op] * blk;
+		res_size = eccsoc_max_rsp_args[op] * blk;
+	} else  {
+		if(((margs->p.x + blk) != margs->p.y) ||
+			((margs->p.y + blk) != margs->a.v) ||
+			((margs->a.v + blk) != margs->b.v) ||
+			((margs->b.v + blk) != margs->n.v) ||
+			(margs->n.len_in_bits != blksz_in_bits) ||
+			(req_p->inp_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+		  		inp_size =  eccsoc_max_req_args[op] * blk;
+
+			if((margs->r.len_in_bits != blksz_in_bits) ||
+				(req_p->out_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+				res_size = eccsoc_max_rsp_args[op] * blk;
+	}
+
+	req_num--;
+
+	desc = eccsoc_create_new_desc(desc, req_num, 
+			max_reqs, inp_size, res_size);
+	if(!desc)
+		return -CRYPTOSOC_ENOMEM;
+	dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+
+	if(inp_size) {
+		void *mem = dpriv->req_info[req_num].inp;
+		dpriv->req_info[req_num].eng_inp = mem;
+
+		if(rsa_ecc_soc_input_copy_5(req_p->inp_data_fmt,
+					 req_p->word_bigendian, mem, blksz_in_bits,
+					 margs->p.x, margs->p.xlen_in_bits,
+					 margs->p.y, margs->p.ylen_in_bits,
+					 margs->a.v, margs->a.len_in_bits,
+					 margs->b.v, margs->b.len_in_bits,
+					 margs->n.v, margs->n.len_in_bits) < 0)
+			goto err_exit;
+	} else
+		dpriv->req_info[req_num].eng_inp = margs->p.x;
+
+	eccsoc_save_res_info(dpriv, req_num, res_size, 
+			dpriv->req_info[req_num].res, 
+			margs->r.v, margs->r.len_in_bits, 
+			NULL,  0, req_p->out_data_fmt);
+
+	eccsoc_save_req_info(dpriv, req_p->prime, op, req_num, 
+			blksz_in_bits, req_p->flags, req_p->word_bigendian);
+
+	*req_desc = desc;
+	return CRYPTOSOC_OK;
+err_exit:
+	cryptosoc_err_print("%s:%d, Error - Data copy failed \n", 
+		__FUNCTION__, __LINE__);
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* eccsoc_create_mod_add_request - Create modular addition request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to mod addition args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_mod_add_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_madd_args *margs)
+{
+
+	int blksz_in_bits, blk, max_len_in_bits;
+	int inp_size = 0, res_size = 0;
+    int op, req_num;	
+	struct eccsoc_req_desc_priv_data *dpriv;
+	struct eccsoc_request_desc *desc = NULL;
+
+	if(req_desc)
+		desc = *req_desc;
+
+	if(eccsoc_validate_input(req_p, max_reqs, desc, (void *)margs) < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	req_num = req_p->req_num;
+
+	/* result length should be greater or equal to the 
+	*  modulus length */
+	if(margs->r.len_in_bits < margs->n.len_in_bits) {
+		cryptosoc_err_print("%s:%d, Error - Result size  < modsize \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	/* find the block size */
+	max_len_in_bits = rsa_ecc_soc_find_max3(
+			margs->x.len_in_bits, margs->y.len_in_bits, margs->n.len_in_bits);
+
+	if(max_len_in_bits > ECCSOC_MAX_BLOCK_SZ_IN_BITS) {
+		cryptosoc_err_print("%s:%d, Error - Invalid block size \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	blksz_in_bits = eccsoc_get_blksz_in_bits(max_len_in_bits);
+	blk = blksz_in_bits / 8;
+	op = ECCSOC_MOD_ADD;
+
+	/* check whether input copy required */
+	if(!(req_p->flags & ECCSOC_ARGS_MEM_REGION_CRYPTOSOC))  {
+		inp_size =  eccsoc_max_req_args[op] * blk;
+		res_size = eccsoc_max_rsp_args[op] * blk;
+	} else  {
+		if(((margs->x.v + blk) != margs->y.v) ||
+			((margs->y.v + blk) != margs->n.v) ||
+			(margs->n.len_in_bits != blksz_in_bits) ||
+			(req_p->inp_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+		  		inp_size =  eccsoc_max_req_args[op] * blk;
+
+			if((margs->r.len_in_bits != blksz_in_bits) ||
+				(req_p->out_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+				res_size = eccsoc_max_rsp_args[op] * blk;
+	}
+
+	req_num--;
+
+	desc = eccsoc_create_new_desc(desc, req_num, 
+			max_reqs, inp_size, res_size);
+	if(!desc)
+		return -CRYPTOSOC_ENOMEM;
+	dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+
+	if(inp_size) {
+		void *mem = dpriv->req_info[req_num].inp;
+		dpriv->req_info[req_num].eng_inp = mem;
+
+		if(rsa_ecc_soc_input_copy_3(req_p->inp_data_fmt,
+					 req_p->word_bigendian, mem, blksz_in_bits,
+					 margs->x.v, margs->x.len_in_bits,
+					 margs->y.v, margs->y.len_in_bits,
+					 margs->n.v, margs->n.len_in_bits) < 0)
+			goto err_exit;
+	} else
+		dpriv->req_info[req_num].eng_inp = margs->x.v;
+
+	eccsoc_save_res_info(dpriv, req_num, res_size, 
+			dpriv->req_info[req_num].res, 
+			margs->r.v, margs->r.len_in_bits, 
+			NULL,  0, req_p->out_data_fmt);
+
+	eccsoc_save_req_info(dpriv, req_p->prime, op, req_num, 
+			blksz_in_bits, req_p->flags, req_p->word_bigendian);
+
+	*req_desc = desc;
+	return CRYPTOSOC_OK;
+err_exit:
+	cryptosoc_err_print("%s:%d, Error - Data copy failed \n", 
+		__FUNCTION__, __LINE__);
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* eccsoc_create_mod_sub_request - Create modular subtraction request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to mod subtraction args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_mod_sub_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_msub_args *margs)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int rv;
+	/* parameter passing is the same for both mod-exp and mod-mul */
+	rv = eccsoc_create_mod_add_request(req_p, max_reqs, req_desc, 
+			(struct eccsoc_madd_args *)margs);
+	if(rv == CRYPTOSOC_OK) {
+		int req_num = req_p->req_num;
+		dpriv = (struct eccsoc_req_desc_priv_data *)((*req_desc)->lib_priv);
+		dpriv->req_info[req_num - 1].op = ECCSOC_MOD_SUB;
+	}
+	return rv;
+}
+
+/**
+* eccsoc_create_mod_mul_request - Create modular multiplication request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to mod multiplication args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_mod_mul_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_mmul_args *margs)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int rv;
+	/* parameter passing is the same for both mod-exp and mod-mul */
+	rv = eccsoc_create_mod_add_request(req_p, max_reqs, req_desc, 
+			(struct eccsoc_madd_args *)margs);
+	if(rv == CRYPTOSOC_OK) {
+		int req_num = req_p->req_num;
+		dpriv = (struct eccsoc_req_desc_priv_data *)((*req_desc)->lib_priv);
+		dpriv->req_info[req_num - 1].op = ECCSOC_MOD_MUL;
+	}
+	return rv;
+}
+
+/**
+* eccsoc_create_mod_div_request - Create modular division request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to mod division args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_mod_div_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_mdiv_args *margs)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int rv;
+	/* parameter passing is the same for both mod-exp and mod-mul */
+	rv = eccsoc_create_mod_add_request(req_p, max_reqs, req_desc, 
+			(struct eccsoc_madd_args *)margs);
+	if(rv == CRYPTOSOC_OK) {
+		int req_num = req_p->req_num;
+		dpriv = (struct eccsoc_req_desc_priv_data *)((*req_desc)->lib_priv);
+		dpriv->req_info[req_num - 1].op = ECCSOC_MOD_DIV;
+	}
+	return rv;
+}
+
+/**
+* eccsoc_create_mod_inv_request - Create modular inversion request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to mod inversion args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_mod_inv_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_minv_args *margs)
+{
+
+	int blksz_in_bits, blk, max_len_in_bits;
+	int inp_size = 0, res_size = 0;
+    int op, req_num;	
+	struct eccsoc_req_desc_priv_data *dpriv;
+	struct eccsoc_request_desc *desc = NULL;
+
+	if(req_desc)
+		desc = *req_desc;
+
+	if(eccsoc_validate_input(req_p, max_reqs, desc, (void *)margs) < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	req_num = req_p->req_num;
+
+	/* result length should be greater or equal to the 
+	*  modulus length */
+	if(margs->r.len_in_bits < margs->n.len_in_bits) {
+		cryptosoc_err_print("%s:%d, Error - Result size  < modsize \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	/* find the block size */
+	max_len_in_bits = rsa_ecc_soc_find_max2(
+			margs->x.len_in_bits, margs->n.len_in_bits);
+
+	if(max_len_in_bits > ECCSOC_MAX_BLOCK_SZ_IN_BITS) {
+		cryptosoc_err_print("%s:%d, Error - Invalid block size \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	blksz_in_bits = eccsoc_get_blksz_in_bits(max_len_in_bits);
+	blk = blksz_in_bits / 8;
+	op = ECCSOC_MOD_INV;
+
+	/* check whether input copy required */
+	if(!(req_p->flags & ECCSOC_ARGS_MEM_REGION_CRYPTOSOC))  {
+		inp_size =  eccsoc_max_req_args[op] * blk;
+		res_size = eccsoc_max_rsp_args[op] * blk;
+	} else  {
+		if(((margs->x.v + blk) != margs->n.v) ||
+			(margs->n.len_in_bits != blksz_in_bits) ||
+			(req_p->inp_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+		  		inp_size =  eccsoc_max_req_args[op] * blk;
+
+			if((margs->r.len_in_bits != blksz_in_bits) ||
+				(req_p->out_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+				res_size = eccsoc_max_rsp_args[op] * blk;
+	}
+
+	req_num--;
+
+	desc = eccsoc_create_new_desc(desc, req_num, 
+			max_reqs, inp_size, res_size);
+	if(!desc)
+		return -CRYPTOSOC_ENOMEM;
+	dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+
+	if(inp_size) {
+		void *mem = dpriv->req_info[req_num].inp;
+		dpriv->req_info[req_num].eng_inp = mem;
+
+		if(rsa_ecc_soc_input_copy_2(req_p->inp_data_fmt,
+					 req_p->word_bigendian, mem, blksz_in_bits,
+					 margs->x.v, margs->x.len_in_bits,
+					 margs->n.v, margs->n.len_in_bits) < 0)
+			goto err_exit;
+	} else
+		dpriv->req_info[req_num].eng_inp = margs->x.v;
+
+	eccsoc_save_res_info(dpriv, req_num, res_size, 
+			dpriv->req_info[req_num].res, 
+			margs->r.v, margs->r.len_in_bits, 
+			NULL,  0, req_p->out_data_fmt);
+
+	eccsoc_save_req_info(dpriv, req_p->prime, op, req_num, 
+			blksz_in_bits, req_p->flags, req_p->word_bigendian);
+
+	*req_desc = desc;
+	return CRYPTOSOC_OK;
+err_exit:
+	cryptosoc_err_print("%s:%d, Error - Data copy failed \n", 
+		__FUNCTION__, __LINE__);
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* eccsoc_create_mod_red_request - Create modular reduction request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to mod reduction args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_mod_red_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_mred_args *margs)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int rv;
+	/* parameter passing is the same for both mod-exp and mod-mul */
+	rv = eccsoc_create_mod_inv_request(req_p, max_reqs, req_desc, 
+			(struct eccsoc_minv_args *)margs);
+	if(rv == CRYPTOSOC_OK) {
+		int req_num = req_p->req_num;
+		dpriv = (struct eccsoc_req_desc_priv_data *)((*req_desc)->lib_priv);
+		dpriv->req_info[req_num - 1].op = ECCSOC_MOD_RED;
+	}
+	return rv;
+}
+
+/**
+* eccsoc_process_request - Send/Receive the descriptor info to/from 
+* the engine
+* @ctx : Pointer to the context(input). 
+* @req_desc : Pointer to the request descriptor(input)
+* @req_vc: Transmit vc id.
+* @rsp_vc: Freeback vc id. 
+* @code: Message send code.
+* @retry_count: How many times the send should be retried before
+* 	telling it is failed
+* @mparam: Extra parameters for the send request(input)
+*   Functions sends out all the requests if mparam==NULL
+* @sync_res: Engine result response if mode is sync(output). 
+* Rsp should be allocated for the number of requests that
+* are going to be sent out.
+*
+* Returns: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*
+* Note: 
+* if ctx != null, it does the operation as per the ctx mode
+* If ctx == null &  rsp != null, function sends the message
+* and wait for the response. 
+* if ctx == null & rsp == null, the function just send the message
+*/
+static inline int eccsoc_process_request(
+		struct cryptosoc_ctx *ctx,
+		struct eccsoc_request_desc *req_desc, 
+		int req_vc,
+		int rsp_vc,
+		int code,
+		int retry_count,
+		struct eccsoc_extra_req_send_params *mparam,
+		struct eccsoc_rsp_result *sync_res)
+{
+
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int idx, gen_type2=0;
+	_uint64_t fmn_entry0, fmn_entry1, fmn_entry2 = 0ULL;
+	void *mem, *rmem;
+	int sreq_num, ereq_num;
+	int rv = -CRYPTOSOC_EINVAL;
+
+	if(!req_desc)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct eccsoc_req_desc_priv_data *)req_desc->lib_priv;
+
+	if(mparam == NULL || mparam->send_all_requests) {
+		sreq_num = 0;
+		ereq_num = dpriv->num_reqs;
+	} else {
+		sreq_num = mparam->sreq_num - 1;
+		ereq_num = sreq_num  +  mparam->num_reqs;
+
+		if((sreq_num >= dpriv->num_reqs) || (ereq_num >  dpriv->num_reqs)) 
+			return -CRYPTOSOC_EINVAL;
+	}
+
+	fmn_entry2 = mparam != NULL ? mparam->async_rsp_arg : 0ULL;
+
+	for(idx = sreq_num; idx < ereq_num; idx++) {
+		mem = dpriv->req_info[idx].eng_inp;
+		rmem = dpriv->req_info[idx].eng_res;
+
+		if(dpriv->req_info[idx].op < 0)
+			return -CRYPTOSOC_EINVAL;
+
+		fmn_entry0 = eccsoc_gen1_form_fmn_entry0( 
+				dpriv->req_info[idx].flags & ECCSOC_SRC_L3_ALLOC ? 1 : 0, 
+				dpriv->req_info[idx].type, dpriv->req_info[idx].op, 
+				cryptosoc_virt_to_phys((unsigned long)mem));
+		fmn_entry1 = eccsoc_gen1_form_fmn_entry1( 
+				dpriv->req_info[idx].flags & ECCSOC_DST_CLOBBER ? 1: 0,
+				dpriv->req_info[idx].flags & ECCSOC_DST_L3_ALLOC ? 1 : 0,
+				rsp_vc, 
+				cryptosoc_virt_to_phys((unsigned long)rmem));
+
+		cryptosoc_dbg_print("ECC process req, req_num %d type %d func %d\n",
+			idx, dpriv->req_info[idx].type, dpriv->req_info[idx].op);
+
+		if(!ctx) {
+			rv = cryptosoc_process_request(gen_type2, CRYPTOSOC_ECC, 
+					req_vc, rsp_vc, code, retry_count,
+					fmn_entry0, fmn_entry1, fmn_entry2,
+					sync_res ? &sync_res->result : NULL);
+		} else {
+			rv = cryptosoc_process_ctx_request(gen_type2, ctx, CRYPTOSOC_ECC,
+					req_vc, rsp_vc, code, retry_count, 
+					fmn_entry0, fmn_entry1, fmn_entry2, 
+					sync_res ? &sync_res->result : NULL, NULL);
+		}
+		if(sync_res)
+			sync_res++;
+		if(rv < 0)
+			break;
+
+	}
+	return rv;
+}
+
+/**
+* eccsoc_result_valid - Check the whether the result from the engine is 
+* valid or not
+* @res: Engine result response
+*
+* Return: 1 if it is valid, 0 otherwise
+*/
+static inline int eccsoc_result_valid(struct eccsoc_rsp_result *res)
+{
+	/* TODO */
+	return 1;
+}
+
+/**
+* eccsoc_copy_result - Copy the result from the engine to the user
+*   given argument during the operation request. This should be called
+*   by the application after getting back the valid response from the 
+*   given request
+* @req_desc: Pointer to the request data descriptor
+* @req_num: Request index
+*
+* Returns: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+static inline int eccsoc_copy_result(struct eccsoc_request_desc *req_desc, int req_num)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	void *rmem;
+	int blk;
+
+	if(!req_desc)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct eccsoc_req_desc_priv_data *)req_desc->lib_priv;
+
+	req_num--;
+	if(req_num >= dpriv->num_reqs)
+		return -CRYPTOSOC_EINVAL;
+
+	/* Nothing to do if application already passed the 
+	*  data in the required format */
+	if(!dpriv->req_info[req_num].usr_res_x)
+		return  CRYPTOSOC_OK;
+
+	if(dpriv->req_info[req_num].op < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	rmem = dpriv->req_info[req_num].eng_res;
+
+	if(rsa_ecc_soc_result_copy_1(dpriv->req_info[req_num].out_data_fmt,
+				dpriv->req_info[req_num].out_word_bigendian,
+				dpriv->req_info[req_num].usr_res_x, 
+				dpriv->req_info[req_num].rxlen_in_bits, 
+				rmem, dpriv->req_info[req_num].blksz_in_bits) < 0) 
+		return -CRYPTOSOC_EINVAL;
+
+	if(dpriv->req_info[req_num].rylen_in_bits) {
+		rmem += blk;
+		if(rsa_ecc_soc_result_copy_1(dpriv->req_info[req_num].out_data_fmt,
+					dpriv->req_info[req_num].out_word_bigendian,
+					dpriv->req_info[req_num].usr_res_y, 
+					dpriv->req_info[req_num].rylen_in_bits, 
+					rmem, dpriv->req_info[req_num].blksz_in_bits) < 0) 
+			return -CRYPTOSOC_EINVAL;
+	}
+
+	return CRYPTOSOC_OK;
+}
+
+/**
+* eccsoc_reset_request_desc - Reset the request descriptor. 
+* Application should call this function if  this descriptor 
+* was used for more than one request  and to start from the req_num=1
+* again.
+* @req_desc: Pointer to the request descriptor. 
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL;
+*/
+static inline int eccsoc_reset_request_desc(struct eccsoc_request_desc *req_desc)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int req_num;
+
+	if(!req_desc)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct eccsoc_req_desc_priv_data *)req_desc->lib_priv;
+	for(req_num = 0; req_num < dpriv->num_reqs; req_num++) {
+		if(dpriv->req_info[req_num].inp_alloc && 
+				dpriv->req_info[req_num].inp) {
+			cryptosoc_mem_free(dpriv->req_info[req_num].inp);
+			dpriv->req_info[req_num].inp_alloc = 0;
+			dpriv->req_info[req_num].inp_size = 0;
+		}
+		if(dpriv->req_info[req_num].res_alloc && 
+				dpriv->req_info[req_num].res) {
+			cryptosoc_mem_free(dpriv->req_info[req_num].res);
+			dpriv->req_info[req_num].res_alloc = 0;
+			dpriv->req_info[req_num].res_size = 0;
+		}
+		dpriv->req_info[req_num].op = -1;
+	}
+
+	dpriv->num_reqs = 0;
+
+	return CRYPTOSOC_OK;
+}
+
+/**
+* eccsoc_free_request_desc - Free the request descriptor
+* @req_desc: Pointer to the request descriptor
+*
+*/
+static inline void eccsoc_free_request_desc(struct eccsoc_request_desc *req_desc)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int req_num;
+
+	if(!req_desc)
+		return;
+
+	dpriv = (struct eccsoc_req_desc_priv_data *)req_desc->lib_priv;
+	for(req_num = 0; req_num < dpriv->num_reqs; req_num++) {
+		if(dpriv->req_info[req_num].inp_alloc && 
+				dpriv->req_info[req_num].inp)
+			cryptosoc_mem_free(dpriv->req_info[req_num].inp);
+		if(dpriv->req_info[req_num].res_alloc && 
+				dpriv->req_info[req_num].res)
+			cryptosoc_mem_free(dpriv->req_info[req_num].res);
+	}
+	cryptosoc_mem_free(req_desc);
+}
+
+/**
+* eccsoc_dump_request_data - Dump the input data in the engine format
+* @req_desc: Pointer to the request data descriptor
+* @req_num: Request index
+*
+*/
+static inline void eccsoc_dump_request_data(
+		struct eccsoc_request_desc *req_desc, int req_num)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int blk, i, arg, max_args;
+	char *mem;
+	char (*tmp)[4];
+	/* names in the order of operation */
+	char names[][4]={
+		"px", "py", "a",  "k",  "n",  "",  /* pmul*/
+		"px", "py", "qx", "qy",  "a", "n",  /* padd */
+		"px", "py", "a",  "n",   "",   "", /* pdbl */
+		"px", "py", "a",   "b",  "n",  "", /* pver */
+		"x",   "y",  "n",  "",   "",   "", /* madd */
+		"x",   "y",  "n",  "",   "",   "", /* msub */
+		"x",   "y",  "n",  "",   "",   "", /* mmul */
+		"x",   "y",  "n",  "",   "",   "", /* mdiv */
+		"x",   "n",  "",   "",   "",   "", /* mod-inv*/
+		"x",   "n",  "",   "",   "",   ""  /* mod-red */
+	};
+
+	if(!req_desc)
+		return;
+
+	dpriv = (struct eccsoc_req_desc_priv_data *)req_desc->lib_priv;
+
+	req_num--;
+	if(req_num >= dpriv->num_reqs)
+		return;
+
+	blk = dpriv->req_info[req_num].blksz_in_bits / 8;
+
+	cryptosoc_dbg_print("BlkszInBits %d  MaxReqs %d NumReqs %d InpSize %d ResSize %d\n", 
+			dpriv->req_info[req_num].blksz_in_bits,
+			dpriv->max_reqs, dpriv->num_reqs, 
+			dpriv->req_info[req_num].inp_size, 
+			dpriv->req_info[req_num].res_size);
+
+	mem = dpriv->req_info[req_num].eng_inp;
+	max_args =  eccsoc_max_req_args[dpriv->req_info[req_num].op];
+	tmp =  &names[dpriv->req_info[req_num].op * 6];
+
+	for(arg=0; arg < max_args; arg++) {
+		cryptosoc_dbg_print("%s\n", tmp[arg]);
+		for(i = 0; i < blk; ) {
+			cryptosoc_dbg_print(" <%016llx>", *(_uint64_t *)(mem + i));
+			i += 8;
+			if((i % 32) == 0)
+				cryptosoc_dbg_print("\n");
+		}
+		cryptosoc_dbg_print("\n");
+		mem = mem + blk;
+	}
+	return;
+}
+
+#endif
+
diff --git a/arch/mips/netlogic/lib/seclib/rsaecc_soc_common.h b/arch/mips/netlogic/lib/seclib/rsaecc_soc_common.h
new file mode 100644
index 0000000..cfe9046
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/rsaecc_soc_common.h
@@ -0,0 +1,311 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _RSAECC_SOC_COMMON_H
+#define _RSAECC_SOC_COMMON_H
+
+/* engine request and result data format conversion routine */
+typedef int (*rsa_ecc_soc_data_copy)(int,  char *, int, char *, int);
+
+/* input copy : src format is dword and most significant dword first */
+static int rsa_ecc_soc_input_copy_fmt_dword_msdwf(int src_big_endian, 
+		char *dst, int d_nbits, char *src, int s_nbits)
+{
+
+	int i;
+	int dlen = d_nbits / 8;
+	int slen = (s_nbits + 7) / 8;
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if src is not  dword aligned, 
+	*  Engine dst and dlen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+		   		__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)src & 0x7UL || (unsigned long)dst & 0x7UL || (dlen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+		
+
+	/* return error if source length is greater than engine length */
+	if(slen > dlen)
+		return -CRYPTOSOC_EINVAL;
+
+	/* goto the end of the source to get the lsword */
+	slen = cryptosoc_roundup(slen, 8);
+	src += (slen - 8);
+	for(i = 0; i < slen; i+=8)  {
+		*(_uint64_t *)(dst + i) = *(_uint64_t *)src;
+		src -= 8;
+	}
+	/* clear the extra memory in the last */
+	if(i < dlen)
+		memset((dst + i), 0, (dlen - i));
+
+	return CRYPTOSOC_OK;
+}
+
+/* result copy : dst format is dword and most significant dword first */
+static int rsa_ecc_soc_result_copy_fmt_dword_msdwf(int dst_big_endian, 
+		char *dst, int d_nbits, char *src, int s_nbits)
+{
+	char *odst = dst;
+	int i, min;
+	int dlen = (d_nbits + 7) / 8;
+	int slen = s_nbits / 8;
+
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if dst is not dword aligned, 
+	   Engine src and slen should always be dword aligned */
+
+	if((unsigned long)dst & 0x7UL || (unsigned long)src & 0x7UL || (slen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	/* goto the end of the dest */
+	dlen = cryptosoc_roundup(dlen, 8);
+	dst += (dlen - 8);
+	/* copy only the mininum of slen & dlen */
+	min = slen > dlen ? dlen : slen;
+	for(i = 0; i < min; i+=8) {
+		*(_uint64_t *)dst =  *(_uint64_t *)(src + i);
+		dst -= 8;
+	}
+	/* clear the extra memory in the beginning */
+	if(i < dlen)
+		memset(odst, 0, dlen - i);
+
+	return CRYPTOSOC_OK;
+}
+
+static inline int rsa_ecc_soc_find_max2(int a, int b)
+{	
+	if(a < b)
+		return b;
+	return a;
+}
+
+static inline int rsa_ecc_soc_find_max3(int a, int b, int c)
+{
+	int max = a;
+	if(max < b)
+		max = b;
+	if(max < c)
+		max = c;
+	return max;
+}
+
+static inline int rsa_ecc_soc_find_max4(int a, int b, int c, int d)
+{
+	int max = rsa_ecc_soc_find_max3(a, b, c);
+	if(max < d)
+		max = d;
+	return max;
+}
+
+static inline int rsa_ecc_soc_find_max5(int a, int b, int c, int d, int e)
+{
+	int max = rsa_ecc_soc_find_max4(a, b, c, d);
+	if(max < e)
+		max = e;
+	return max;
+}
+
+static inline int rsa_ecc_soc_find_max6(int a, int b, int c, int d, int e, int f)
+{
+	int max = rsa_ecc_soc_find_max5(a, b, c, d, e);
+	if(max < f)
+		max = f;
+	return max;
+}
+
+/* RSA & ECC both have the same type of conversion routines */
+#ifdef ECCSOC_DATA_FORMAT_SET
+/* engine request and result data format conversion routine */
+static rsa_ecc_soc_data_copy rsa_ecc_soc_input_copy_func[] = {
+	[ECCSOC_DATA_WSZ_64BIT_MSW_FIRST] = rsa_ecc_soc_input_copy_fmt_dword_msdwf,
+};
+
+static rsa_ecc_soc_data_copy rsa_ecc_soc_result_copy_func[] = {
+	[ECCSOC_DATA_WSZ_64BIT_MSW_FIRST] = rsa_ecc_soc_result_copy_fmt_dword_msdwf,
+};
+#else
+/* engine request and result data format conversion routine */
+static rsa_ecc_soc_data_copy rsa_ecc_soc_input_copy_func[] = {
+	[RSASOC_DATA_WSZ_64BIT_MSW_FIRST] = rsa_ecc_soc_input_copy_fmt_dword_msdwf,
+};
+
+static rsa_ecc_soc_data_copy rsa_ecc_soc_result_copy_func[] = {
+	[RSASOC_DATA_WSZ_64BIT_MSW_FIRST] = rsa_ecc_soc_result_copy_fmt_dword_msdwf,
+};
+#endif
+
+static inline int rsa_ecc_soc_input_copy_2(int inp_data_fmt, 
+		int word_bigendian, char *mem, int blksz_in_bits,
+		char *a, int alen_in_bits, char *b, int blen_in_bits)
+{
+	int rv;
+	int blk = blksz_in_bits / 8;
+
+	if((rv = rsa_ecc_soc_input_copy_func[inp_data_fmt](
+			word_bigendian, mem, blksz_in_bits, a, alen_in_bits)) < 0)
+		return rv;
+
+	mem += blk;
+
+	rsa_ecc_soc_input_copy_func[inp_data_fmt](
+			word_bigendian, mem, blksz_in_bits, b, blen_in_bits);
+	return rv;
+
+}
+
+static inline int rsa_ecc_soc_input_copy_3(int inp_data_fmt, 
+		int word_bigendian, char *mem, int blksz_in_bits,
+		char *a, int alen_in_bits, char *b, int blen_in_bits,
+		char *c, int clen_in_bits)
+{
+	int rv;
+	int blk = blksz_in_bits / 8;
+
+	if((rv = rsa_ecc_soc_input_copy_2(inp_data_fmt, word_bigendian, mem, 
+			blksz_in_bits, a, alen_in_bits, b, blen_in_bits)) < 0)
+		return rv;
+
+	mem  = mem + blk * 2;
+
+	rv = rsa_ecc_soc_input_copy_func[inp_data_fmt](
+			word_bigendian, mem, blksz_in_bits, c, clen_in_bits);
+	return rv;
+}
+
+static inline int rsa_ecc_soc_input_copy_4(int inp_data_fmt, 
+		int word_bigendian, char *mem, int blksz_in_bits,
+		char *a, int alen_in_bits, char *b, int blen_in_bits,
+		char *c, int clen_in_bits, char *d, int dlen_in_bits)
+{
+	int rv;
+	int blk = blksz_in_bits / 8;
+
+	if((rv = rsa_ecc_soc_input_copy_3(inp_data_fmt, word_bigendian, mem, 
+			blksz_in_bits, a, alen_in_bits, b, blen_in_bits,
+			c, clen_in_bits)) < 0)
+		return rv;
+
+	mem  = mem + blk * 3;
+
+	rv = rsa_ecc_soc_input_copy_func[inp_data_fmt](
+			word_bigendian, mem, blksz_in_bits, d, dlen_in_bits);
+	return rv;
+}
+
+static inline int rsa_ecc_soc_input_copy_5(int inp_data_fmt, 
+		int word_bigendian, char *mem, int blksz_in_bits,
+		char *a, int alen_in_bits, char *b, int blen_in_bits,
+		char *c, int clen_in_bits, char *d, int dlen_in_bits,
+		char *e, int elen_in_bits)
+{
+	int rv;
+	int blk = blksz_in_bits / 8;
+
+	if((rv = rsa_ecc_soc_input_copy_4(inp_data_fmt, word_bigendian, mem, 
+			blksz_in_bits, a, alen_in_bits, b, blen_in_bits,
+			c, clen_in_bits, d, dlen_in_bits)) < 0)
+		return rv;
+
+	mem  = mem + blk * 4;
+
+	rv = rsa_ecc_soc_input_copy_func[inp_data_fmt](
+			word_bigendian, mem, blksz_in_bits, e, elen_in_bits);
+	return rv;
+}
+
+static inline int rsa_ecc_soc_input_copy_6(int inp_data_fmt, 
+		int word_bigendian, char *mem, int blksz_in_bits,
+		char *a, int alen_in_bits, char *b, int blen_in_bits,
+		char *c, int clen_in_bits, char *d, int dlen_in_bits,
+		char *e, int elen_in_bits, char *f, int flen_in_bits)
+{
+	int rv;
+	int blk = blksz_in_bits / 8;
+
+	if((rv = rsa_ecc_soc_input_copy_5(inp_data_fmt, word_bigendian, mem, 
+			blksz_in_bits, a, alen_in_bits, b, blen_in_bits,
+			c, clen_in_bits, d, dlen_in_bits, e, elen_in_bits)) < 0)
+		return rv;
+
+	mem  = mem + blk * 5;
+
+	rv = rsa_ecc_soc_input_copy_func[inp_data_fmt](
+			word_bigendian, mem, blksz_in_bits, f, flen_in_bits);
+	return rv;
+}
+	
+static inline int rsa_ecc_soc_result_copy_1(int res_data_fmt, 
+		int word_bigendian, char *a, int alen_in_bits,
+		char *mem, int blksz_in_bits)
+{
+	int rv;
+
+	rv = rsa_ecc_soc_result_copy_func[res_data_fmt](
+			word_bigendian, a, alen_in_bits, mem, blksz_in_bits);
+	return rv;
+}
+
+static inline int rsa_ecc_soc_result_copy_2(int res_data_fmt, 
+		int word_bigendian, 
+		char *a, int alen_in_bits, char *b, int blen_in_bits, 
+		char *mem, int blksz_in_bits)
+{
+
+	int rv;
+	int blk = blksz_in_bits / 8;
+
+	if((rv = rsa_ecc_soc_result_copy_func[res_data_fmt](
+			word_bigendian, a, alen_in_bits, mem, blksz_in_bits)) < 0)
+		return rv;
+
+	mem += blk;
+
+	rv = rsa_ecc_soc_result_copy_func[res_data_fmt](
+			word_bigendian, b, blen_in_bits, mem, blksz_in_bits);
+	return rv;
+}
+
+#endif
+
diff --git a/arch/mips/netlogic/lib/seclib/rsasoc_defs.h b/arch/mips/netlogic/lib/seclib/rsasoc_defs.h
new file mode 100644
index 0000000..2088838
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/rsasoc_defs.h
@@ -0,0 +1,122 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _RSASOC_DEFS_H
+#define _RSASOC_DEFS_H
+
+/**
+* enum rsasoc_data_format - RSA Data input/output format
+*
+* @RSASOC_DATA_WSZ_64BIT_MSW_FIRST: Individual unit size is 64bit and 
+* 		most significant word is first. Memory should be dword aligned,
+*		and total allocated size should be multiple of dword size.
+* @RSASOC_DATA_WSZ_64BIT_LSW_FIRST: Individual unit size is dword and 
+* 		least significant dword is first. Memory should be dword aligned,
+*       and total allocated size should be multiple of dword size
+* @RSASOC_DATA_WSZ_32BIT_MSW_FIRST: Individual unit size is 32bit and 
+* 		most significant word is first. Memory should be word aligned
+* 		and total allocated size should be multiple of word size.
+* @RSASOC_DATA_WSZ_32BIT_LSW_FIRST: Individual unit size is 32bit and 
+* 		least significant word is first. Memory should be word aligned
+*       and total allocated size should be multiple of word size.
+* @RSASOC_DATA_WSZ_8BIT_MSW_FIRST: Individual unit size is 8bit and 
+* 		most significant word is first. 
+* @RSASOC_DATA_WSZ_8BIT_LSW_FIRST: Individual unit size is 8bit and 
+* 		least significant word is first
+* @RSASOC_DATA_FMT_MAX: End of data format type
+*/
+enum rsasoc_data_format {
+	RSASOC_DATA_WSZ_64BIT_MSW_FIRST=0,
+	RSASOC_DATA_WSZ_64BIT_LSW_FIRST,
+	RSASOC_DATA_WSZ_32BIT_MSW_FIRST,
+	RSASOC_DATA_WSZ_32BIT_LSW_FIRST,
+	RSASOC_DATA_WSZ_8BIT_MSW_FIRST,
+	RSASOC_DATA_WSZ_8BIT_LSW_FIRST,
+	RSASOC_DATA_FMT_MAX
+};
+
+#define RSASOC_DATA_FORMAT_SET
+
+/**
+* enum rsasoc_op_type - RSA Operation type
+* @RSASOC_TYPE_512  : 512 bits operation
+* @RSASOC_TYPE_1024  : 1024 bits operation
+* @RSASOC_TYPE_2048  : 2048 bits operation
+* @RSASOC_TYPE_4096  : 4096 bits operation
+* @RSASOC_TYPE_8192  : 8192 bits operation
+* @RSASOC_TYPE_MICROCODE_LOAD  : Microcode load operation
+*/
+enum rsasoc_op_type {
+	RSASOC_TYPE_512=0x40,
+	RSASOC_TYPE_1024=0x41,
+	RSASOC_TYPE_2048=0x42,
+	RSASOC_TYPE_4096=0x43,
+	RSASOC_TYPE_8192=0x44,
+	RSASOC_TYPE_MICROCODE_LOAD=0x70
+};
+
+/**
+* enum rsasoc_op - RSA Operation
+* @RSASOC_MOD_EXP  : Mod exponentiation
+* @RSASOC_MOD_MUL  : Mod multiplication 
+* @RSASOC_OP_MAX : End of operation
+*/
+enum rsasoc_op {
+	RSASOC_MOD_EXP = 0x0,
+	RSASOC_MOD_MUL,
+	RSASOC_OP_MAX
+	
+};
+
+/**
+* defines rsa_req_flags - Rsa operation request flags
+* @RSASOC_SRC_L3_ALLOC: Casuses source data to transit through L3 cache
+* @RSASOC_DST_L3_ALLOC: Causes data written to the dram is also copied to l3 cache
+* @RSASOC_DST_CLOBBER: Causes data to be written as 64byte cacheline, 
+*   no read modify write
+* @RSASOC_ARGS_MEM_REGION_CRYPTOSOC: All the arguments are allocated 
+*    using cryptosoc_mem_alloc. So that virt_to_phys conversion can be done.
+
+*/
+
+/*!defines rsa_req_flags < */
+#define RSASOC_SRC_L3_ALLOC 0x01
+#define RSASOC_DST_L3_ALLOC 0x02
+#define RSASOC_DST_CLOBBER  0x04
+#define RSASOC_ARGS_MEM_REGION_CRYPTOSOC 0x8
+/*!defines rsa_req_flags > */
+
+#endif
+
diff --git a/arch/mips/netlogic/lib/seclib/rsasoc_gen1_hal_defs.h b/arch/mips/netlogic/lib/seclib/rsasoc_gen1_hal_defs.h
new file mode 100644
index 0000000..5a58042
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/rsasoc_gen1_hal_defs.h
@@ -0,0 +1,172 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+#ifndef _RSASOC_GEN1_HAL_DEFS_H_
+#define _RSASOC_GEN1_HAL_DEFS_H_
+
+#include "cryptosoc_lib.h"
+
+#define RSASOC_GEN1_SET_BITS(X,PARAM) \
+	(((_uint64_t)X & RSASOC_GEN1_##PARAM##_MASK) << RSASOC_GEN1_##PARAM##_SHIFT)
+
+#define RSASOC_GEN1_GET_BITS(X,PARAM) \
+	 ((_uint64_t)(( (_uint64_t)X >> RSASOC_GEN1_##PARAM##_SHIFT) & \
+		 RSASOC_GEN1_##PARAM##_MASK)) 
+	
+
+#define RSASOC_GEN1_SRC_L3_ALLOC_MASK 0x1ULL
+#define RSASOC_GEN1_SRC_L3_ALLOC_SHIFT 61
+
+#define RSASOC_GEN1_TYPE_MASK 0x7fULL
+#define RSASOC_GEN1_TYPE_SHIFT 46
+
+#define RSASOC_GEN1_FUNC_MASK 0x3fULL
+#define RSASOC_GEN1_FUNC_SHIFT 40
+
+#define RSASOC_GEN1_SRC_ADDR_MASK 0xffffffffffULL
+#define RSASOC_GEN1_SRC_ADDR_SHIFT 0
+
+
+#define RSASOC_GEN1_DST_CLOBBER_MASK 0x1ULL
+#define RSASOC_GEN1_DST_CLOBBER_SHIFT 62
+
+#define RSASOC_GEN1_DST_L3_ALLOC_MASK 0x1ULL
+#define RSASOC_GEN1_DST_L3_ALLOC_SHIFT 61
+
+#define RSASOC_GEN1_FBVC_MASK 0xfffULL
+#define RSASOC_GEN1_FBVC_SHIFT 40
+
+#define RSASOC_GEN1_DST_ADDR_MASK 0xffffffffffULL
+#define RSASOC_GEN1_DST_ADDR_SHIFT 0
+
+
+
+/**
+* rsasoc_gen1_form_fmn_entry0 - Generate crypto rsa fmn message entry 0
+* @src_l3_alloc: 1/0, 1 casuses source data to transit through l3 cache
+* @type: type of the operation, see rsasoc_op_type
+* @func: operation function, see rsasoc_op_func
+* @src_addr : source address
+*
+* Returns: Filled fmn entry0
+*/
+
+static inline _uint64_t  rsasoc_gen1_form_fmn_entry0(unsigned int src_l3_alloc, 
+		unsigned int type, 
+		unsigned int func, _uint64_t src_addr)
+{
+	return( RSASOC_GEN1_SET_BITS(src_l3_alloc, SRC_L3_ALLOC) |
+		RSASOC_GEN1_SET_BITS(type, TYPE) | 
+		RSASOC_GEN1_SET_BITS(func, FUNC) |
+		RSASOC_GEN1_SET_BITS(src_addr, SRC_ADDR));
+}
+
+/**
+* rsasoc_gen1_form_fmn_entry1 -  Generate crypto rsa fmn message entry 1
+* 
+* @dst_clobber: 1/0, 1 causes data to be written as 64byte cacheline
+* @dst_l3_alloc: 1/0, 1 causes data written to the dram is also copied to l3 cache
+* @fbvc: freeback message vc
+* @dst_addr : destination address where result will be copied
+*
+* Returns: Filled fmn entry1
+*/
+
+
+static inline _uint64_t  rsasoc_gen1_form_fmn_entry1(unsigned int dst_clobber, 
+		unsigned int dst_l3_alloc, 
+		unsigned int fbvc, _uint64_t dst_addr)
+{
+
+	return( RSASOC_GEN1_SET_BITS(dst_clobber, DST_CLOBBER) |
+		RSASOC_GEN1_SET_BITS(dst_l3_alloc, DST_L3_ALLOC) | 
+		RSASOC_GEN1_SET_BITS(fbvc, FBVC) |
+		RSASOC_GEN1_SET_BITS(dst_addr, DST_ADDR));
+
+}
+
+static inline char *rsasoc_get_op_type(int val, char *buf)
+{
+	char op_type[][16] = {
+		"Mod512", "Mod1024", "Mod2048",
+		"Mod4096", "Mod8192", "MicroLoad" };
+
+	strcpy(buf, "Reserved");
+	if(val >= 0x40 && val <= 0x44)
+		strcpy(buf, op_type[val - 0x40]);
+	if(val == 0x70)
+		strcpy(buf, op_type[5]);
+	return buf;
+}
+
+static inline char *rsasoc_get_op_func(int val, char *buf)
+{
+	char op[][16] = { "ModExp",  "ModMul" };
+	strcpy(buf, "Reserved");
+	if(val <= 1)
+		strcpy(buf, op[val]);
+	return buf;
+}
+
+
+
+static inline void rsasoc_gen1_dump_fmnentry(_uint64_t entry0, _uint64_t entry1)
+{
+	char buf[32], buf1[32];
+	cryptosoc_dbg_print("\nFmn Info entry0 %llx entry1 %llx\n",entry0, entry1);
+	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s\n",
+			"SrcL3Alloc","Type", "Func", "SrcAddr");
+
+	cryptosoc_dbg_print("  %-16lld %-16s %-16s %-16llx\n",
+			RSASOC_GEN1_GET_BITS(entry0, SRC_L3_ALLOC),
+			rsasoc_get_op_type(RSASOC_GEN1_GET_BITS(entry0, TYPE), buf),
+			rsasoc_get_op_func(RSASOC_GEN1_GET_BITS(entry0, FUNC), buf1),
+			RSASOC_GEN1_GET_BITS(entry0, SRC_ADDR));
+
+	cryptosoc_dbg_print("\n  %-16s %-16s %-16s %-16s\n",
+			"DstClobber","DstL3Alloc", "FbVC", "DstAddr");
+
+	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16llx\n",
+			RSASOC_GEN1_GET_BITS(entry1, DST_CLOBBER),
+			RSASOC_GEN1_GET_BITS(entry1, DST_L3_ALLOC),
+			RSASOC_GEN1_GET_BITS(entry1, FBVC),
+			RSASOC_GEN1_GET_BITS(entry1, DST_ADDR));
+
+	cryptosoc_dbg_print("\n");
+
+}
+
+
+#endif
diff --git a/arch/mips/netlogic/lib/seclib/rsasoc_gen1_ucode.h b/arch/mips/netlogic/lib/seclib/rsasoc_gen1_ucode.h
new file mode 100644
index 0000000..f22dd10
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/rsasoc_gen1_ucode.h
@@ -0,0 +1,962 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _RSASOC_GEN1_UCODE_H
+#define _RSASOC_GEN1_UCODE_H
+static uint64_t  rsasoc_ucode_data [] = {
+0x0000000000000000ULL,
+0x00000000503840ecULL,
+0x00000001903800ecULL,
+0x00000002c03820ecULL,
+0x0000003760000044ULL,
+0x0000000000000014ULL,
+0x000000071000000cULL,
+0x00000007d000010cULL,
+0x0000001b80000c0cULL,
+0x00000000e03fc0ecULL,
+0x00000001103fc1ecULL,
+0x00000001403f42ecULL,
+0x00000001403fc4ecULL,
+0x0000003760000044ULL,
+0x000000001800003cULL,
+0x0000000d8000030cULL,
+0x0000000630000044ULL,
+0x000000002800003cULL,
+0x0000000ef000030cULL,
+0x0000000630000044ULL,
+0x00000000503fc23cULL,
+0x00000000a03fc33cULL,
+0x00000001403fc43cULL,
+0x00000010c000030cULL,
+0x0000000630000044ULL,
+0x0000000000000014ULL,
+0x000000071000000cULL,
+0x0000001c1000070cULL,
+0x0000002500000d0cULL,
+0x00000027c0000e0cULL,
+0x0000002d60000f0cULL,
+0x00000002603f00ecULL,
+0x00000002603f82ecULL,
+0x00000002803f83ecULL,
+0x00000002803f04ecULL,
+0x00000002a03f06ecULL,
+0x00000002a03f88ecULL,
+0x0000003760000044ULL,
+0x000000086000010cULL,
+0x00000003f0000044ULL,
+0x00000008d000010cULL,
+0x00000004b0000044ULL,
+0x00000008d000010cULL,
+0x0000000570000044ULL,
+0x000000000000001cULL,
+0x000000076000000cULL,
+0x0000001c1000070cULL,
+0x0000002690000d0cULL,
+0x0000002990000e0cULL,
+0x0000002e10000f0cULL,
+0x00000003903f20ecULL,
+0x00000003903fa2ecULL,
+0x00000003b03fa3ecULL,
+0x00000003b03f24ecULL,
+0x00000003d03f26ecULL,
+0x00000003d03fa8ecULL,
+0x0000003760000044ULL,
+0x000000096000010cULL,
+0x00000003f0000044ULL,
+0x0000000a0000010cULL,
+0x00000004b0000044ULL,
+0x0000000a0000010cULL,
+0x0000000570000044ULL,
+0x000000000800003cULL,
+0x0000000af000020cULL,
+0x0000000bc000030cULL,
+0x000000129000040cULL,
+0x000000178000050cULL,
+0x000000191000060cULL,
+0x0000001ff000080cULL,
+0x000000205000090cULL,
+0x00000022c0000a0cULL,
+0x00000020b0000b0cULL,
+0x0000001ac0000c0cULL,
+0x0000000680000044ULL,
+0x000000001000003cULL,
+0x0000000b5000020cULL,
+0x0000000c5000030cULL,
+0x000000137000040cULL,
+0x00000017e000050cULL,
+0x000000197000060cULL,
+0x000000200000080cULL,
+0x000000206000090cULL,
+0x0000002340000a0cULL,
+0x0000002110000b0cULL,
+0x0000001b10000c0cULL,
+0x0000000680000044ULL,
+0x000000001800003cULL,
+0x0000000b5000020cULL,
+0x0000000d8000030cULL,
+0x000000154000040cULL,
+0x000000187000050cULL,
+0x0000001a0000060cULL,
+0x000000202000080cULL,
+0x000000208000090cULL,
+0x0000002410000a0cULL,
+0x00000021c0000b0cULL,
+0x0000001b80000c0cULL,
+0x0000000680000044ULL,
+0x000000000000000aULL,
+0x0000000000000024ULL,
+0x0000002ed01f80e4ULL,
+0x00000030101f81e4ULL,
+0x0000003760000044ULL,
+0x000000000000000aULL,
+0x0000000000000024ULL,
+0x00000030d01f00e4ULL,
+0x00000030d01f82e4ULL,
+0x00000034801f83e4ULL,
+0x00000035401e04e4ULL,
+0x00000037101f88e4ULL,
+0x00000035401f89e4ULL,
+0x0000003760000044ULL,
+0x0000000000000074ULL,
+0x0000000f0000008cULL,
+0x00000008000000a4ULL,
+0x000000080400007bULL,
+0x00000000000000c4ULL,
+0x0000000000000074ULL,
+0x0000000c000000a4ULL,
+0x0000000004004071ULL,
+0x0000000b0000008cULL,
+0x00000008000000a4ULL,
+0x000000080400007bULL,
+0x00000000000000c4ULL,
+0x000000034c0b4091ULL,
+0x0000000b040b0093ULL,
+0x0000000000000000ULL,
+0x0000000004000802ULL,
+0x00000002c88b0021ULL,
+0x0000000a828b0423ULL,
+0x00000010000000a4ULL,
+0x000000081000006cULL,
+0x00000000000000c4ULL,
+0x000000004c0b4091ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x000000004a8b0021ULL,
+0x00000010000000a4ULL,
+0x000000089000006cULL,
+0x00000000000000c4ULL,
+0x000000034c0b4091ULL,
+0x0000000b040b0093ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x00000002c88b0021ULL,
+0x0000000a828b0423ULL,
+0x00000010000000a4ULL,
+0x000000091000006cULL,
+0x00000000000000c4ULL,
+0x000000004c0b4091ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x000000004a8b0021ULL,
+0x00000010000000a4ULL,
+0x0000000990000064ULL,
+0x000000004a8b0021ULL,
+0x0000000000898611ULL,
+0x0000000c000000a4ULL,
+0x00000000000000c4ULL,
+0x000000034c0b4091ULL,
+0x0000000b040b0093ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x00000002c88b0021ULL,
+0x0000000a828b0423ULL,
+0x00000010000000a4ULL,
+0x0000000a40000064ULL,
+0x0000000088800021ULL,
+0x0000000880800423ULL,
+0x00000000001004a1ULL,
+0x0000000c000000a4ULL,
+0x00000002c88b0061ULL,
+0x0000000a808b0463ULL,
+0x00000000000000c4ULL,
+0x00000000058f0011ULL,
+0x0000000001860002ULL,
+0x00000010000000a4ULL,
+0x00000000000000ccULL,
+0x000000004d8f0021ULL,
+0x0000000b10000044ULL,
+0x00000007058f0013ULL,
+0x0000000001860002ULL,
+0x00000010000000a4ULL,
+0x00000000000000ccULL,
+0x000000034c0f0021ULL,
+0x0000000b058f0423ULL,
+0x0000000b70000044ULL,
+0x0000000000180001ULL,
+0x000000000b600031ULL,
+0x00000008000000a4ULL,
+0x0000000004800041ULL,
+0x00000008000000a4ULL,
+0x0000000007c03f41ULL,
+0x00000000440ac491ULL,
+0x00000004000000a4ULL,
+0x00000000000000c4ULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c3430431ULL,
+0x00000004000000a4ULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x0000000117982861ULL,
+0x0000000088a03631ULL,
+0x00000002c3430c31ULL,
+0x00000004000000a4ULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x0000000347cb2861ULL,
+0x000000034c09f691ULL,
+0x00000003040a8491ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c0830431ULL,
+0x0000000283430431ULL,
+0x000000080000009cULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x0000000104202861ULL,
+0x0000000117d82861ULL,
+0x0000000088a02f31ULL,
+0x00000002c0833c31ULL,
+0x0000002283430c3bULL,
+0x0000000000000000ULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x00000003442b2861ULL,
+0x0000000307cb2861ULL,
+0x000000034c09ef91ULL,
+0x000000030409bc91ULL,
+0x00000003040a8491ULL,
+0x00000000000000c4ULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c0830431ULL,
+0x0000000280830431ULL,
+0x0000000280c30431ULL,
+0x0000000004900041ULL,
+0x0000000283430531ULL,
+0x0000000a00038007ULL,
+0x0000000000000000ULL,
+0x000000012c002b41ULL,
+0x0000000344202861ULL,
+0x0000001304032863ULL,
+0x0000000317db2861ULL,
+0x00000000b8a02b31ULL,
+0x00000002c0832831ULL,
+0x0000000280832831ULL,
+0x0000000280c33c31ULL,
+0x0000000004900041ULL,
+0x0000002e83430d3bULL,
+0x0000000200038000ULL,
+0x0000000000000000ULL,
+0x000000012c002b41ULL,
+0x00000003442b2861ULL,
+0x00000013040b2863ULL,
+0x0000000307cb2861ULL,
+0x000000037c09eb91ULL,
+0x000000130409a893ULL,
+0x000000030409bc91ULL,
+0x00000003040a849dULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c0830431ULL,
+0x0000000280830431ULL,
+0x0000000280c30431ULL,
+0x0000000004900041ULL,
+0x0000000280830531ULL,
+0x0000001e80830433ULL,
+0x0000000283430431ULL,
+0x0000000b2c03ab67ULL,
+0x0000000344202861ULL,
+0x0000001304032863ULL,
+0x0000000317db2861ULL,
+0x00000002b8a3ab31ULL,
+0x00000002c0832831ULL,
+0x0000000280832831ULL,
+0x0000000280c32831ULL,
+0x0000000004900041ULL,
+0x0000000280832931ULL,
+0x0000001e80832833ULL,
+0x0000002e83430c3bULL,
+0x000000032c03ab61ULL,
+0x00000003442b2861ULL,
+0x00000013040b2863ULL,
+0x0000000307cb2861ULL,
+0x000000037c09eb91ULL,
+0x000000130409a893ULL,
+0x000000030409bc91ULL,
+0x00000003040a849dULL,
+0x0000000000140001ULL,
+0x0000004000140001ULL,
+0x000000000b600061ULL,
+0x000000400b600061ULL,
+0x00000004000000a4ULL,
+0x0000000004800041ULL,
+0x0000004004800041ULL,
+0x00000004000000a4ULL,
+0x0000000007c03f41ULL,
+0x0000004007c03f41ULL,
+0x00000000440ac591ULL,
+0x00000040440ac591ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x0000000010140001ULL,
+0x0000004010140001ULL,
+0x0000000088e00061ULL,
+0x0000004088e00061ULL,
+0x00000002c3430561ULL,
+0x00000042c3430561ULL,
+0x0000000204938041ULL,
+0x0000004204938041ULL,
+0x00000004000000a4ULL,
+0x000000012c402b41ULL,
+0x000000412c402b41ULL,
+0x0000000117f42961ULL,
+0x0000004117f42961ULL,
+0x0000000088e03f61ULL,
+0x0000004088e03f61ULL,
+0x00000002c3430d61ULL,
+0x00000042c3430d61ULL,
+0x0000000204938041ULL,
+0x0000004204938041ULL,
+0x00000004000000a4ULL,
+0x000000012c402b41ULL,
+0x000000412c402b41ULL,
+0x0000000347eb2961ULL,
+0x0000004347eb2961ULL,
+0x000000034c7dff91ULL,
+0x000000434c7dff91ULL,
+0x00000003040a0591ULL,
+0x00000043040a0591ULL,
+0x00000000000000c4ULL,
+0x0000000010140001ULL,
+0x0000004010140001ULL,
+0x0000000088e00061ULL,
+0x0000004088e00061ULL,
+0x00000002c0c30561ULL,
+0x00000042c0c30561ULL,
+0x0000000004900041ULL,
+0x0000004004900041ULL,
+0x0000000283430561ULL,
+0x0000004283430561ULL,
+0x0000000b2c43ab47ULL,
+0x000000432c43ab41ULL,
+0x0000000344602961ULL,
+0x0000004344602961ULL,
+0x0000000317d72961ULL,
+0x0000004317d72961ULL,
+0x00000002b8e3ab61ULL,
+0x00000042b8e3ab61ULL,
+0x00000002c0c32961ULL,
+0x00000042c0c32961ULL,
+0x0000000004900041ULL,
+0x0000004004900041ULL,
+0x0000000283430d61ULL,
+0x0000007683430d6bULL,
+0x000000032c43ab41ULL,
+0x000000432c43ab41ULL,
+0x00000003446b2961ULL,
+0x00000043446b2961ULL,
+0x0000000307cb2961ULL,
+0x0000004307cb2961ULL,
+0x000000037c7de791ULL,
+0x000000437c7de791ULL,
+0x0000000304499d91ULL,
+0x0000004304499d91ULL,
+0x00000003040a0591ULL,
+0x00000043040a059dULL,
+0x0000000048840011ULL,
+0x00000000028b3691ULL,
+0x000000000e09c691ULL,
+0x000000000c09c691ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x00000000c8840011ULL,
+0x0000000212ab3691ULL,
+0x0000000080800411ULL,
+0x0000000002cb3691ULL,
+0x000000034c29ef91ULL,
+0x0000000006098491ULL,
+0x000000034c09ef91ULL,
+0x0000000004098491ULL,
+0x00000000000000c4ULL,
+0x00000000e8840011ULL,
+0x0000000210ab3a91ULL,
+0x0000000880800415ULL,
+0x00000006128b3699ULL,
+0x000000034c29eb91ULL,
+0x0000000f0409a893ULL,
+0x0000000026098891ULL,
+0x000000034c09eb91ULL,
+0x0000000f0409a893ULL,
+0x000000000409849dULL,
+0x0000000048841011ULL,
+0x00000000068b7691ULL,
+0x000000000e099611ULL,
+0x000000000c098611ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x00000000c8840011ULL,
+0x0000000216ab7691ULL,
+0x0000000080801411ULL,
+0x0000000006cb3691ULL,
+0x000000034c29af11ULL,
+0x0000000006099411ULL,
+0x000000034c09af11ULL,
+0x0000000004098411ULL,
+0x00000000000000c4ULL,
+0x00000000e8840011ULL,
+0x0000000214ab7a91ULL,
+0x0000000c80800415ULL,
+0x00000006168b3699ULL,
+0x0000000080801411ULL,
+0x00000002168b3691ULL,
+0x000000034c29ab11ULL,
+0x0000000f0409a813ULL,
+0x0000000026099811ULL,
+0x000000034c09ab11ULL,
+0x0000000f0409a813ULL,
+0x000000000409841dULL,
+0x0000000c000000d4ULL,
+0x0000000000000000ULL,
+0x000000004a801011ULL,
+0x000000000e004691ULL,
+0x000000000009800dULL,
+0x0000000c000000d4ULL,
+0x000000004a801011ULL,
+0x000000018c004691ULL,
+0x0000000000800411ULL,
+0x0000000006003691ULL,
+0x0000000200098001ULL,
+0x000000000009800dULL,
+0x0000000c000000d4ULL,
+0x000000004a801011ULL,
+0x000000018c004691ULL,
+0x0000000c00800415ULL,
+0x0000000584003699ULL,
+0x0000000000800411ULL,
+0x0000000006003691ULL,
+0x0000000a00098003ULL,
+0x000000000009800dULL,
+0x000000200000302aULL,
+0x00000000000e0012ULL,
+0x0000000000100211ULL,
+0x0000000002000002ULL,
+0x00000006000b0003ULL,
+0x0000000000000000ULL,
+0x00000000000000ccULL,
+0x0000000006000302ULL,
+0x00000002810b0011ULL,
+0x0000000a808b0013ULL,
+0x0000000002010002ULL,
+0x00000006108b0093ULL,
+0x0000000002800002ULL,
+0x00000007040b0013ULL,
+0x0000000006800002ULL,
+0x00000007040b0013ULL,
+0x0000000003000002ULL,
+0x0000000000090101ULL,
+0x0000000200098001ULL,
+0x0000000a000b0003ULL,
+0x0000000007000302ULL,
+0x0000000400890015ULL,
+0x0000000784098019ULL,
+0x0000000007800002ULL,
+0x0000000000090001ULL,
+0x0000000000098101ULL,
+0x0000001dd000006cULL,
+0x000000280300060aULL,
+0x0000000000000000ULL,
+0x0000000000000e02ULL,
+0x0000000001000011ULL,
+0x00000010000000a4ULL,
+0x0000001dc0000064ULL,
+0x0000000000000f02ULL,
+0x0000000001000011ULL,
+0x0000000002000602ULL,
+0x0000000680890013ULL,
+0x0000000002806002ULL,
+0x0000000004000011ULL,
+0x000000031489f691ULL,
+0x0000000804000415ULL,
+0x000000071489b699ULL,
+0x0000000006000e02ULL,
+0x0000000680890013ULL,
+0x0000000006800e02ULL,
+0x0000000680898013ULL,
+0x0000002c0300540aULL,
+0x0000000007800012ULL,
+0x00000000000b8000ULL,
+0x000000000700cd42ULL,
+0x0000000000800011ULL,
+0x000000029489f691ULL,
+0x0000000800800415ULL,
+0x000000069489b699ULL,
+0x000000200000e02aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000001dc0000064ULL,
+0x000000240000c02aULL,
+0x0000000002000012ULL,
+0x0000000600090003ULL,
+0x00000000000000c4ULL,
+0x000000001680409dULL,
+0x0000000014804091ULL,
+0x000000001680049dULL,
+0x0000000014804091ULL,
+0x0000000014800491ULL,
+0x000000001680049dULL,
+0x000000001680419dULL,
+0x0000000014804191ULL,
+0x000000001680049dULL,
+0x0000000014804191ULL,
+0x0000000014800491ULL,
+0x000000001680049dULL,
+0x0000000000800011ULL,
+0x00000000068b5691ULL,
+0x0000000004098611ULL,
+0x000000000700dc22ULL,
+0x0000000000800011ULL,
+0x0000000296cb569dULL,
+0x0000000000800011ULL,
+0x0000000294ab7691ULL,
+0x0000000000801411ULL,
+0x00000000068b3691ULL,
+0x000000034409af11ULL,
+0x0000000004098411ULL,
+0x000000000700dc22ULL,
+0x0000000000800011ULL,
+0x00000002948b7691ULL,
+0x0000000000801411ULL,
+0x0000000296cb369dULL,
+0x0000000000800011ULL,
+0x0000000294ab7691ULL,
+0x0000000000800411ULL,
+0x00000002948b3691ULL,
+0x0000000000801411ULL,
+0x00000000068b3a91ULL,
+0x000000034409ab11ULL,
+0x000000030409a411ULL,
+0x0000000004098411ULL,
+0x000000000700dc22ULL,
+0x0000000000800011ULL,
+0x00000002948b7691ULL,
+0x0000000000800411ULL,
+0x00000002948b3691ULL,
+0x0000000000801411ULL,
+0x0000000296cb369dULL,
+0x0000000001000011ULL,
+0x0000000006098611ULL,
+0x0000000000000000ULL,
+0x0000000007000e02ULL,
+0x0000000000888061ULL,
+0x0000000003000602ULL,
+0x0000000000888061ULL,
+0x00000000000984edULL,
+0x0000000001000011ULL,
+0x0000000b8409b615ULL,
+0x0000000400800419ULL,
+0x000000000609b611ULL,
+0x0000000007000e02ULL,
+0x0000000080800061ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8000ULL,
+0x0000000003000602ULL,
+0x0000000080800061ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8001ULL,
+0x00000000000985edULL,
+0x0000000001000011ULL,
+0x0000000b8409b615ULL,
+0x0000000400800419ULL,
+0x000000000609b611ULL,
+0x0000000007000e02ULL,
+0x0000000080800061ULL,
+0x00000002808b0461ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8000ULL,
+0x0000000003000602ULL,
+0x0000000080800061ULL,
+0x00000002808b0461ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8001ULL,
+0x00000000000985edULL,
+0x0000000002800002ULL,
+0x000000500220220aULL,
+0x000000140606550aULL,
+0x000000140606c50aULL,
+0x0000000002a01202ULL,
+0x000000500680100aULL,
+0x000000140286550aULL,
+0x000000000300d502ULL,
+0x000000500220340aULL,
+0x000000140306660aULL,
+0x000000140686c40aULL,
+0x000000140206660aULL,
+0x000000000600dd02ULL,
+0x000000500720550aULL,
+0x0000001806064c0aULL,
+0x000000180306c60aULL,
+0x0000000002001102ULL,
+0x000000500020c50aULL,
+0x000000000600e402ULL,
+0x000000500220440aULL,
+0x000000140606cc0aULL,
+0x000000000320d602ULL,
+0x000000500100e50aULL,
+0x000000180086c60aULL,
+0x00000000000000c4ULL,
+0x0000000002000002ULL,
+0x0000005002a0210aULL,
+0x000000140280540aULL,
+0x0000000003005502ULL,
+0x000000500620200aULL,
+0x000000140680c50aULL,
+0x0000000002004402ULL,
+0x0000005003a0cc0aULL,
+0x0000000002a03702ULL,
+0x000000500700c50aULL,
+0x000000140280650aULL,
+0x000000140280e50aULL,
+0x000000000000c502ULL,
+0x000000500120c70aULL,
+0x000000000200c402ULL,
+0x0000005000a0d50aULL,
+0x0000000000000000ULL,
+0x000000140080410aULL,
+0x00000000000000c4ULL,
+0x0000000006009202ULL,
+0x000000500220a10aULL,
+0x0000001806064c0aULL,
+0x0000000002808202ULL,
+0x0000005006a0a00aULL,
+0x000000180706d50aULL,
+0x000000000320cc02ULL,
+0x000000500280ee0aULL,
+0x0000000006a0d502ULL,
+0x000000500780a20aULL,
+0x000000140386dd0aULL,
+0x000000000300f602ULL,
+0x0000005002a0e50aULL,
+0x000000180306560aULL,
+0x0000000000000000ULL,
+0x000000180306760aULL,
+0x0000001806866d0aULL,
+0x000000000380f502ULL,
+0x0000005007a0450aULL,
+0x000000300281070aULL,
+0x000000200000502aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002bc000006cULL,
+0x000000000600dc02ULL,
+0x000000500020e60aULL,
+0x000000180086fc0aULL,
+0x000000140107170aULL,
+0x00000000000000c4ULL,
+0x000000000200a102ULL,
+0x000000500620920aULL,
+0x000000140600c40aULL,
+0x000000000200a002ULL,
+0x0000005006a0820aULL,
+0x000000140680d40aULL,
+0x000000140200dc0aULL,
+0x000000000700a202ULL,
+0x0000005002a0dd0aULL,
+0x000000000300c402ULL,
+0x0000005003a0350aULL,
+0x0000000000000000ULL,
+0x000000140300670aULL,
+0x000000000380d502ULL,
+0x0000005007a0e60aULL,
+0x0000000000000000ULL,
+0x0000001407807f0aULL,
+0x000000000380d102ULL,
+0x000000500320c00aULL,
+0x0000000000000000ULL,
+0x000000140380760aULL,
+0x0000000003007502ULL,
+0x0000005002a0d50aULL,
+0x000000000200f402ULL,
+0x0000005003a0e50aULL,
+0x000000300281070aULL,
+0x000000200000502aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002bc000006cULL,
+0x000000000000df02ULL,
+0x0000005000a0a60aULL,
+0x000000140101170aULL,
+0x000000140080410aULL,
+0x00000000000000c4ULL,
+0x000000300281020aULL,
+0x0000003006810a0aULL,
+0x0000003006010c0aULL,
+0x000000200000202aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002d1000006cULL,
+0x000000200000a02aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002d5000006cULL,
+0x000000200000c02aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002cd0000064ULL,
+0x00000034000000d4ULL,
+0x00000000000000c4ULL,
+0x0000000001000002ULL,
+0x00000006000b0003ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x000000140001180aULL,
+0x000000140081190aULL,
+0x0000001401011a0aULL,
+0x00000000000000c4ULL,
+0x00000000000000c4ULL,
+0x0000000001810302ULL,
+0x0000005005a10b0aULL,
+0x0000000002000002ULL,
+0x000000500620110aULL,
+0x000000140206340aULL,
+0x000000180606cb0aULL,
+0x0000000002000402ULL,
+0x0000005006210c0aULL,
+0x000000140206c40aULL,
+0x000000300201040aULL,
+0x00000000000000c4ULL,
+0x0000000002801002ULL,
+0x0000005005a10b0aULL,
+0x000000140286b50aULL,
+0x000000140186300aULL,
+0x0000000002000002ULL,
+0x000000500620110aULL,
+0x000000140606c50aULL,
+0x0000000002003402ULL,
+0x0000005006210c0aULL,
+0x000000140206c40aULL,
+0x000000300201040aULL,
+0x00000000000000c4ULL,
+0x000000040400000aULL,
+0x000000000000002cULL,
+0x0000000c0000800eULL,
+0x0000000c0400880aULL,
+0x000000080000007cULL,
+0x0000000004000002ULL,
+0x00000006808b0013ULL,
+0x0000000000000034ULL,
+0x0000000000000002ULL,
+0x0000002ff000005cULL,
+0x0000002f4000004cULL,
+0x00000002000b0101ULL,
+0x0000000a000b0003ULL,
+0x0000003760000044ULL,
+0x0000000000000034ULL,
+0x0000000c0000000aULL,
+0x0000002ff0000054ULL,
+0x0000000c0000800aULL,
+0x0000002fb000004cULL,
+0x0000003640000044ULL,
+0x0000000c0000800aULL,
+0x000000040400000aULL,
+0x000000000000002cULL,
+0x0000000c0000800eULL,
+0x0000000c0400880aULL,
+0x000000080000007cULL,
+0x000000040400000aULL,
+0x000000000000002cULL,
+0x0000000c0000800eULL,
+0x0000000c0400880aULL,
+0x000000080000007cULL,
+0x0000003640000044ULL,
+0x000000080180000aULL,
+0x0000000001820002ULL,
+0x00000007040b0013ULL,
+0x000000040200000aULL,
+0x000000000000002cULL,
+0x0000000c0180430eULL,
+0x0000000c0200440aULL,
+0x000000080000007cULL,
+0x0000000001010002ULL,
+0x00000006108b0093ULL,
+0x0000000005010002ULL,
+0x00000006108b0093ULL,
+0x0000000000000000ULL,
+0x00000032e01f80e4ULL,
+0x00000034401f81e4ULL,
+0x00000034601f82e4ULL,
+0x0000000c0181020aULL,
+0x0000000c0181030aULL,
+0x0000001c000000d4ULL,
+0x0000000000004002ULL,
+0x0000005000a0410aULL,
+0x0000000001004202ULL,
+0x000000500021000aULL,
+0x0000000000810102ULL,
+0x000000500121020aULL,
+0x000000200000202aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000000000000002ULL,
+0x0000000600098003ULL,
+0x0000000000810002ULL,
+0x0000000610898093ULL,
+0x0000003760000044ULL,
+0x0000000004000002ULL,
+0x00000006808b0013ULL,
+0x0000000004800102ULL,
+0x00000006808b0013ULL,
+0x0000000005000202ULL,
+0x00000006808b0013ULL,
+0x0000000000000034ULL,
+0x0000000000000002ULL,
+0x000000342000005cULL,
+0x000000334000004cULL,
+0x0000001000000084ULL,
+0x00000006000b0009ULL,
+0x00000002000b0101ULL,
+0x0000002000000084ULL,
+0x00000006000b0009ULL,
+0x0000003760000044ULL,
+0x0000000000000034ULL,
+0x00000034000000d4ULL,
+0x0000003420000054ULL,
+0x00000038000000d4ULL,
+0x00000033e000004cULL,
+0x00000031d0000044ULL,
+0x00000038000000d4ULL,
+0x00000031d0000044ULL,
+0x00000034000000d4ULL,
+0x00000031d0000044ULL,
+0x000000080180000aULL,
+0x0000000001820002ULL,
+0x00000007040b0013ULL,
+0x0000000005840002ULL,
+0x00000007040b0013ULL,
+0x0000003c000000d4ULL,
+0x00000004000000a4ULL,
+0x000000200000402aULL,
+0x0000000000000012ULL,
+0x00000000000b0001ULL,
+0x0000000000098101ULL,
+0x0000003760000044ULL,
+0x000000040200000aULL,
+0x000000000000002cULL,
+0x0000000c0000400eULL,
+0x0000000c0200440aULL,
+0x000000080000007cULL,
+0x00000036c01f87e4ULL,
+0x00000036401f89e4ULL,
+0x000000040200000aULL,
+0x000000000000002cULL,
+0x0000000c0400480eULL,
+0x0000000c0200440aULL,
+0x000000080000007cULL,
+0x00000036a01f86e4ULL,
+0x000000080180000aULL,
+0x00000036601f84e4ULL,
+0x00000036801f85e4ULL,
+0x000000300001000aULL,
+0x0000003760000044ULL,
+0x000000140006800aULL,
+0x0000003640000044ULL,
+0x000000180006800aULL,
+0x0000003640000044ULL,
+0x0000000c0000800aULL,
+0x0000003640000044ULL,
+0x0000000c0181080aULL,
+0x0000001c000000d4ULL,
+0x00000004000000a4ULL,
+0x0000000c0000400aULL,
+0x0000003640000044ULL,
+0x0000000c0181000aULL,
+0x0000001c000000d4ULL,
+0x00000004000000a4ULL,
+0x000000140001140aULL,
+0x0000003640000044ULL,
+0x0000000c000000a4ULL,
+0x0000000000000044ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+};
+
+#endif				/**/
diff --git a/arch/mips/netlogic/lib/seclib/rsasoc_lib.h b/arch/mips/netlogic/lib/seclib/rsasoc_lib.h
new file mode 100644
index 0000000..a9affc6
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/rsasoc_lib.h
@@ -0,0 +1,745 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _RSASOC_LIB_H
+#define _RSASOC_LIB_H
+
+/* Include file for application specific macros */
+#include "cryptosoc_lib.h"
+#include "cryptosoc_lib_ifc.h"
+#include "cryptosoc_ctx.h"
+
+#ifdef RSASOC_PTYPE_GEN_ALL_SUPPORT
+#define RSASOC_PTYPE_GEN2_SUPPORT
+#define RSASOC_PTYPE_GEN1_SUPPORT
+#endif
+
+#include "rsasoc_defs.h"
+#include "rsaecc_soc_common.h"
+
+/* Include file for processor specific macros to set the descriptors. 
+*  hal macros should be after _ifc.h(Because of -GEN2- en/dis */
+#ifdef RSASOC_PTYPE_GEN2_SUPPORT
+#include "rsasoc_gen1_hal_defs.h"
+#endif
+
+#ifdef RSASOC_PTYPE_GEN1_SUPPORT
+#include "rsasoc_gen1_hal_defs.h"
+#endif
+
+
+#ifdef RSASOC_PTYPE_GEN_ALL_SUPPORT
+#define IF_RSASOC_PTYPE_IS_GEN1 if(cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN1)
+#define IF_RSASOC_PTYPE_IS_GEN2 if(cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2)
+#else
+#define IF_RSASOC_PTYPE_IS_GEN1
+#define IF_RSASOC_PTYPE_IS_GEN2 
+#endif
+
+#include "nlm_hal_fmn.h"
+
+/**
+* DOC: RSASOC
+*
+* These APIs abstract the RSA SOC present in the processor.
+*
+* The below macros should be defined by the application. 
+* 
+* RSASOC_REQ_DESC_APP_PRIV_SZ:
+*   Application private data size in the request descriptor. Should be 
+*   multiple of cachelines.
+*
+* Processor type : Either RSASOC_PTYPE_GEN_ALL_SUPPORT or 
+*  RSASOC_PTYPE_GEN2_SUPPORT/RSASOC_PTYPE_GEN1_SUPPORT
+*/
+
+
+struct rsasoc_req_desc_priv_data {
+	/* number of operations to perform. The application can fill
+	*  multiple operations in one structure and can send to the engine 
+	*  in parallel or serial. 
+	*  */
+	int num_reqs; 
+	/* To save the input/return data address,
+	num_reqs size, dynamically allocated */
+	int max_reqs;
+	struct rsasoc_req_info *req_info; 
+};
+
+/* This should be aligned to 8 bytes, as the engine 
+*  data starts after this and that should be aligned 
+*  to 8 bytes */
+struct rsasoc_req_info {
+	void *inp; /* data memory - allocated by the library */
+	void *res; /* result memory - allocated by the library */
+
+	int inp_alloc; /* if inp is separately allocated */
+	int res_alloc; /* if res is separately allocated */
+
+	int inp_size; /* size of input mem */
+	int res_size; /* size of result mem */
+
+	void *eng_inp; /* input data memory, either inp or input-args */
+	void *eng_res; /* result data memory, either res or result-args  */
+
+	void *usr_res; /* user given result memory */
+	void *pad;
+
+	int rlen_in_bits; /* user given result memory bitlen */
+	int blksz_in_bits;
+
+	int op; /* operation */
+	int type; /* type */
+
+	int flags;
+	int out_data_fmt;
+
+	int out_word_bigendian;
+	int pad1;
+	
+};
+
+
+#define RSASOC_REQ_DESC_LIB_PRIV_SZ \
+	 (((sizeof(struct rsasoc_req_desc_priv_data) / CRYPTOSOC_CACHELINE_SZ) + 1) * \
+	          CRYPTOSOC_CACHELINE_SZ)
+
+#define RSASOC_MAX_BLOCK_SZ_IN_BITS 	8192
+#define RSASOC_MAX_DATA_ARGS			4
+#define RSASOC_TYPE_SVALUE				0x40
+
+/**
+* struct rsasoc_arg - Operation data argument type
+* @v: Input value
+* @len_in_bits : Value length in bits
+*/
+struct rsasoc_arg {
+	void *v;
+	int  len_in_bits;
+};
+
+/**
+* struct rsasoc_mexp_args - Mod exponentiation data arguments(r = x^y mod n)
+* @x : Input parameter-1
+* @y : Input parameter-2
+* @n : Modulus
+* @r : Result
+*/
+struct rsasoc_mexp_args {
+	struct rsasoc_arg x;
+	struct rsasoc_arg y;
+	struct rsasoc_arg n;
+	struct rsasoc_arg r;
+};
+
+/**
+* struct rsasoc_mmul_args - Mod multiplication data arguments(r = x*n mod n)
+* @x : Input parameter-1
+* @y : Input parameter-2
+* @n : Modulus
+* @r : Result
+*/
+struct rsasoc_mmul_args {
+	struct rsasoc_arg x;
+	struct rsasoc_arg y;
+	struct rsasoc_arg n;
+	struct rsasoc_arg r;
+};
+
+
+/**
+* struct rsasoc_request_params - Each operation request parameters
+* @inp_data_fmt: Input data format, see enum rsasoc_data_format
+* @out_data_fmt: Output data format, see enum rsasoc_data_format
+* @word_bigendian: 1/0, Depending on the data word is big endian/little endian
+* @req_num : Request number
+* @flags: Request flags, see define rsa_req_flags
+*/
+struct rsasoc_request_params {
+	enum rsasoc_data_format inp_data_fmt;
+	enum rsasoc_data_format out_data_fmt;
+	int word_bigendian;
+	int req_num;
+	int flags; 
+};
+
+
+
+/**
+* struct rsasoc_request_desc - Operation request descriptor parameters
+* @lib_priv: Space to store the private data by the library. 
+* 	Application should not modify this area
+* @app_priv: Application private memory.
+* @data: Data storage space. Dynamic sized depending on the block size.
+*/
+struct rsasoc_request_desc {
+	char lib_priv[RSASOC_REQ_DESC_LIB_PRIV_SZ];
+	char app_priv[RSASOC_REQ_DESC_APP_PRIV_SZ];
+	char data[0];
+}___cryptosoc_cacheline_aligned;
+
+/**
+* struct rsasoc_extra_req_send_params - RSA send request options
+* @send_all_requests : 1/0, Send all the requests present in the data descriptor
+* @sreq_num : Starting request number, Ignored 
+*    if the send_all_requests is true.
+* @num_reqs : Number of request from sreq_num, Ignored 
+*    if the send_all_requests is true.
+*  @async_rsp_arg: User given callback argument, used in async mode only
+*/
+struct rsasoc_extra_req_send_params {
+	int send_all_requests;
+	int sreq_num;
+	int num_reqs;
+	_uint64_t async_rsp_arg;
+};
+
+static inline struct rsasoc_request_desc *rsasoc_create_new_desc(
+		struct rsasoc_request_desc *desc,
+		int req_num, 
+		int max_reqs, int inp_size, int res_size)
+{
+	struct rsasoc_req_desc_priv_data *dpriv;
+	int idx= 0;
+
+	if(desc) {
+		dpriv = (struct rsasoc_req_desc_priv_data *)desc->lib_priv;
+		/* check the input */
+		if(inp_size && (dpriv->req_info[req_num].inp_size < inp_size)) {
+			if(dpriv->req_info[req_num].inp_alloc)
+				cryptosoc_mem_free(dpriv->req_info[req_num].inp);
+			dpriv->req_info[req_num].inp = cryptosoc_mem_alloc(8, inp_size);
+			if(!dpriv->req_info[req_num].inp)
+				return NULL;
+			dpriv->req_info[req_num].inp_alloc = 1;
+		  	dpriv->req_info[req_num].inp_size = inp_size;
+		}
+
+		/* check the result */
+		if(res_size && (dpriv->req_info[req_num].res_size < res_size)) {
+			if(dpriv->req_info[req_num].res_alloc)
+				cryptosoc_mem_free(dpriv->req_info[req_num].res);
+			dpriv->req_info[req_num].res = cryptosoc_mem_alloc(8, res_size);
+			if(!dpriv->req_info[req_num].res)
+				return NULL;
+			dpriv->req_info[req_num].res_alloc = 1;
+		  	dpriv->req_info[req_num].res_size = res_size;
+		}
+	} else {
+		int req_info_sz = max_reqs * sizeof(struct rsasoc_req_info);
+		int size = inp_size + res_size + req_info_sz;
+		void *mbase;
+		desc = cryptosoc_mem_alloc(CRYPTOSOC_CACHELINE_SZ, sizeof(*desc) + size);
+		if(!desc)
+			return NULL; 
+		dpriv = (struct rsasoc_req_desc_priv_data *)desc->lib_priv;
+		dpriv->num_reqs = 0;
+		dpriv->max_reqs = max_reqs;
+		dpriv->req_info =  (struct rsasoc_req_info *)&desc->data[0];
+	
+		mbase = (void *)((unsigned long)dpriv->req_info + req_info_sz);
+
+		/* part of desc */
+		dpriv->req_info[0].inp_alloc= 0;
+		dpriv->req_info[0].res_alloc= 0;
+		dpriv->req_info[0].op = -1;
+
+		if(inp_size) {
+			dpriv->req_info[0].inp = mbase;
+			dpriv->req_info[0].inp_size = inp_size;
+			mbase += inp_size;
+		} else
+			dpriv->req_info[0].inp_size = 0;
+
+		if(res_size) {
+			dpriv->req_info[0].res = mbase;
+			dpriv->req_info[0].res_size = res_size;
+		} else
+			 dpriv->req_info[0].res_size = 0;
+
+		for(idx = 1; idx < max_reqs; idx++) {
+			dpriv->req_info[idx].inp_alloc= 0;
+			dpriv->req_info[idx].res_alloc= 0;
+			dpriv->req_info[idx].inp_size = 0;
+			dpriv->req_info[idx].res_size = 0;
+		}
+	}
+	return desc;
+}
+
+
+/**
+* rsasoc_create_mod_exp_request - Create mod-exponentiation request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to mod exponentiation args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int rsasoc_create_mod_exp_request(
+		struct rsasoc_request_params *req_p,
+		int max_reqs,
+		struct rsasoc_request_desc **req_desc,
+		struct rsasoc_mexp_args *margs)
+{
+	int blksz_in_bits, blk, max_len_in_bits;
+	int inp_size = 0, res_size = 0;
+    int bitset, type;	
+	struct rsasoc_req_desc_priv_data *dpriv;
+	struct rsasoc_request_desc *desc = NULL;
+	int req_num;
+
+	if(!req_p || !margs )
+		return -CRYPTOSOC_EINVAL;
+
+	if(req_desc)
+		desc = *req_desc;
+
+	req_num = req_p->req_num;
+	if(desc) {
+		dpriv = (struct rsasoc_req_desc_priv_data *)desc->lib_priv;
+	   	if(dpriv->max_reqs < req_num) {
+			cryptosoc_err_print("%s:%d, Error - Request overflow \n", 
+					__FUNCTION__, __LINE__);
+			return -CRYPTOSOC_EINVAL;
+		}
+	} else if(req_num != 1 || max_reqs <= 0) {
+		/* request number should be one for the new descriptor 
+		*  creation */
+		cryptosoc_err_print("%s:%d, Error - Invalid request number \n", 
+					__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	/* result length should be greater or equal to the 
+	*  modulus length */
+	if(margs->r.len_in_bits < margs->n.len_in_bits) {
+		cryptosoc_err_print("%s:%d, Error - Result size  < modsize \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+
+	max_len_in_bits = rsa_ecc_soc_find_max3(margs->x.len_in_bits,
+		   margs->y.len_in_bits, margs->n.len_in_bits);
+
+	if(max_len_in_bits > RSASOC_MAX_BLOCK_SZ_IN_BITS) {
+		cryptosoc_err_print("%s:%d, Error - Invalid block size \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	/* block size starts from 512, roundup the size to the next one supported
+	*  by the engine */
+	bitset = cryptosoc_get_lbs(max_len_in_bits) - 1;
+	if(bitset < 9) 
+		bitset = 9;
+	else if ((max_len_in_bits - (1 << bitset)) > 0)
+		bitset++;
+
+	blksz_in_bits = 1 << bitset;
+	blk = blksz_in_bits / 8;
+
+
+	/* check whether input copy required */
+	if(!(req_p->flags & RSASOC_ARGS_MEM_REGION_CRYPTOSOC))  {
+		inp_size =  (RSASOC_MAX_DATA_ARGS - 1) * blk;
+		res_size = blk;
+	} else  {
+		if(((margs->x.v + blk) != margs->y.v) ||
+				((margs->y.v + blk) != margs->n.v) ||
+				(margs->n.len_in_bits != blksz_in_bits) ||
+				(req_p->inp_data_fmt !=  RSASOC_DATA_WSZ_64BIT_LSW_FIRST))
+			inp_size =  (RSASOC_MAX_DATA_ARGS - 1) * blk;
+
+		if((margs->r.len_in_bits != blksz_in_bits) || 
+				(req_p->out_data_fmt !=  RSASOC_DATA_WSZ_64BIT_LSW_FIRST))
+			res_size = blk;
+	}
+
+	req_num--;
+
+	desc = rsasoc_create_new_desc(desc, req_num, 
+			max_reqs, inp_size, res_size);
+	if(!desc)
+		return -CRYPTOSOC_ENOMEM;
+	dpriv = (struct rsasoc_req_desc_priv_data *)desc->lib_priv;
+
+	if(inp_size) {
+		void *mem = dpriv->req_info[req_num].inp;
+		dpriv->req_info[req_num].eng_inp = mem;
+
+		if(rsa_ecc_soc_input_copy_3(req_p->inp_data_fmt,
+					 req_p->word_bigendian, mem, blksz_in_bits,
+					  margs->x.v, margs->x.len_in_bits,
+					  margs->y.v, margs->y.len_in_bits,
+					  margs->n.v, margs->n.len_in_bits) < 0)
+			goto err_exit;
+	} else
+		dpriv->req_info[req_num].eng_inp = margs->x.v;
+	
+	if(res_size) {
+		 dpriv->req_info[req_num].eng_res =  dpriv->req_info[req_num].res;
+		 dpriv->req_info[req_num].usr_res =  margs->r.v;
+		 dpriv->req_info[req_num].rlen_in_bits = margs->r.len_in_bits;
+		 dpriv->req_info[req_num].out_data_fmt = req_p->out_data_fmt;
+		 dpriv->req_info[req_num].out_word_bigendian = req_p->word_bigendian;
+		 dpriv->req_info[req_num].flags = req_p->flags;
+	} else {
+		 dpriv->req_info[req_num].eng_res =  margs->r.v;
+		 dpriv->req_info[req_num].usr_res = NULL;
+	}
+
+	bitset = cryptosoc_get_lbs(blksz_in_bits) - 1;
+	type = bitset - 9 + RSASOC_TYPE_SVALUE;
+
+	dpriv->req_info[req_num].type = type;
+	dpriv->req_info[req_num].op = RSASOC_MOD_EXP;
+	dpriv->req_info[req_num].blksz_in_bits = blksz_in_bits;
+
+	/* request number is decremented above */
+	if(req_num >= dpriv->num_reqs)
+		dpriv->num_reqs++;
+	*req_desc = desc;
+	return CRYPTOSOC_OK;
+err_exit:
+	cryptosoc_err_print("%s:%d, Error - Data copy failed \n", 
+		__FUNCTION__, __LINE__);
+	return -CRYPTOSOC_EINVAL;
+}
+
+
+/**
+* rsasoc_create_mod_mul_request - Create mod-multiplication request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to mod multiplication args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int rsasoc_create_mod_mul_request(
+		struct rsasoc_request_params *req_p,
+		int max_reqs,
+		struct rsasoc_request_desc **req_desc,
+		struct rsasoc_mmul_args *margs)
+{
+	struct rsasoc_req_desc_priv_data *dpriv;
+	int rv;
+	/* parameter passing is the same for both mod-exp and mod-mul */
+	rv = rsasoc_create_mod_exp_request(req_p, max_reqs, req_desc, 
+			(struct rsasoc_mexp_args *)margs);
+	if(rv == CRYPTOSOC_OK) {
+		int req_num = req_p->req_num;
+		dpriv = (struct rsasoc_req_desc_priv_data *)((*req_desc)->lib_priv);
+		dpriv->req_info[req_num - 1].op = RSASOC_MOD_MUL;
+	}
+	return rv;
+}
+
+/**
+* rsasoc_process_request - Send/Receive the descriptor info to/from 
+* the engine
+* @ctx : Pointer to the context(input). 
+* @req_desc : Pointer to the request descriptor(input)
+* @req_vc: Transmit vc id.
+* @rsp_vc: Freeback vc id. 
+* @code: Message send code.
+* @retry_count: How many times the send should be retried before
+* 	telling it is failed
+* @mparam: Extra parameters for the send request(input)
+*   Functions sends out all the requests if mparam==NULL
+* @sync_res: Engine result response if mode is sync(output)
+* Rsp should be allocated for the number of requests that
+* are going to be sent out
+*
+* Returns: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*
+* Note: 
+* if ctx != null, it does the operation as per the ctx mode
+* If ctx == null &  rsp != null, function sends the message
+* and wait for the response. 
+* if ctx == null & rsp == null, the function just send the message
+*
+*/
+static inline int rsasoc_process_request(
+		struct cryptosoc_ctx *ctx,
+		struct rsasoc_request_desc *req_desc, 
+		int req_vc,
+		int rsp_vc,
+		int code,
+		int retry_count,
+		struct rsasoc_extra_req_send_params *mparam,
+		struct rsasoc_rsp_result *sync_res)
+{
+	struct rsasoc_req_desc_priv_data *dpriv;
+	int idx, gen_type2 = 0;
+	_uint64_t fmn_entry0, fmn_entry1, fmn_entry2 = 0ULL;
+	void *mem, *rmem;
+	int sreq_num, ereq_num;
+	int rv = -CRYPTOSOC_EINVAL;
+
+	if(!req_desc)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct rsasoc_req_desc_priv_data *)req_desc->lib_priv;
+
+	if(mparam == NULL || mparam->send_all_requests) {
+		sreq_num = 0;
+		ereq_num = dpriv->num_reqs;
+	} else {
+		sreq_num = mparam->sreq_num - 1;
+		ereq_num = sreq_num  +  mparam->num_reqs;
+
+		if((sreq_num >= dpriv->num_reqs) || (ereq_num >  dpriv->num_reqs)) 
+			return -CRYPTOSOC_EINVAL;
+	}
+
+	fmn_entry2 = mparam != NULL ? mparam->async_rsp_arg : 0ULL;
+
+	for(idx = sreq_num; idx < ereq_num; idx++) {
+		mem = dpriv->req_info[idx].eng_inp;
+		rmem = dpriv->req_info[idx].eng_res;
+
+		if(dpriv->req_info[idx].op < 0)
+			return -CRYPTOSOC_EINVAL;
+
+		fmn_entry0 = rsasoc_gen1_form_fmn_entry0(
+				dpriv->req_info[idx].flags & RSASOC_SRC_L3_ALLOC ? 1 : 0, 
+				dpriv->req_info[idx].type, dpriv->req_info[idx].op, 
+				cryptosoc_virt_to_phys((unsigned long)mem));
+
+		fmn_entry1 = rsasoc_gen1_form_fmn_entry1(
+				dpriv->req_info[idx].flags & RSASOC_DST_CLOBBER ? 1: 0,
+				dpriv->req_info[idx].flags & RSASOC_DST_L3_ALLOC ? 1 : 0,
+				rsp_vc, 
+				cryptosoc_virt_to_phys((unsigned long)rmem));
+
+
+		if(!ctx) {
+			rv = cryptosoc_process_request(gen_type2, CRYPTOSOC_RSA, 
+					req_vc, rsp_vc, code, retry_count,
+					fmn_entry0, fmn_entry1, fmn_entry2,
+					sync_res ? &sync_res->result : NULL);
+		} else {
+			rv =  cryptosoc_process_ctx_request(gen_type2, ctx, CRYPTOSOC_RSA,
+					req_vc, rsp_vc, code, retry_count, 
+					fmn_entry0, fmn_entry1, fmn_entry2, 
+					sync_res ? &sync_res->result : NULL, NULL);
+		}
+		if(sync_res)
+			sync_res++;
+
+		if(rv < 0)
+			break;
+	}
+	return rv;
+}
+
+/**
+* rsasoc_result_valid - Check the whether the result from the engine is 
+* valid or not
+* @res: Engine result response
+*
+* Return: 1 if it is valid, 0 otherwise
+*/
+static inline int rsasoc_result_valid(struct rsasoc_rsp_result *res)
+{
+	/* TODO */
+	return 1;
+}
+
+/**
+* rsasoc_copy_result - Copy the result from the engine to the user
+*   given argument during operation request. This should be called
+*   by the application after getting back the valid response from the 
+*   given request.
+* @req_desc: Pointer to the request descriptor
+* @req_num: Request number
+*
+* Returns: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+static inline int rsasoc_copy_result(struct rsasoc_request_desc *req_desc, int req_num)
+{
+	struct rsasoc_req_desc_priv_data *dpriv;
+	void *rmem;
+
+	if(!req_desc)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct rsasoc_req_desc_priv_data *)req_desc->lib_priv;
+
+	req_num--;
+	if(req_num >= dpriv->num_reqs)
+		return -CRYPTOSOC_EINVAL;
+
+	/* Nothing to do if application already passed the 
+	*  data in the required format */
+	if(!dpriv->req_info[req_num].usr_res)
+		return  CRYPTOSOC_OK;
+
+	if(dpriv->req_info[req_num].op < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	rmem = dpriv->req_info[req_num].eng_res;
+
+	if(rsa_ecc_soc_result_copy_1(dpriv->req_info[req_num].out_data_fmt,
+			dpriv->req_info[req_num].out_word_bigendian,
+			dpriv->req_info[req_num].usr_res,
+			dpriv->req_info[req_num].rlen_in_bits,
+			rmem, dpriv->req_info[req_num].blksz_in_bits) < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	return CRYPTOSOC_OK;
+}
+
+/**
+* rsasoc_reset_request_desc - Reset the request descriptor. 
+* Application should call this function if  this descriptor 
+* was used for more than one request,  and to start from the req_num=1
+* again.
+* @req_desc: Pointer to the request descriptor. 
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL;
+*/
+static inline int rsasoc_reset_request_desc(struct rsasoc_request_desc *req_desc)
+{
+	struct rsasoc_req_desc_priv_data *dpriv;
+	int req_num;
+
+	if(!req_desc)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct rsasoc_req_desc_priv_data *)req_desc->lib_priv;
+	for(req_num = 0; req_num < dpriv->num_reqs; req_num++) {
+		if(dpriv->req_info[req_num].inp_alloc && 
+				dpriv->req_info[req_num].inp) {
+			cryptosoc_mem_free(dpriv->req_info[req_num].inp);
+			dpriv->req_info[req_num].inp_alloc = 0;
+			dpriv->req_info[req_num].inp_size = 0;
+		}
+		if(dpriv->req_info[req_num].res_alloc && 
+				dpriv->req_info[req_num].res) {
+			cryptosoc_mem_free(dpriv->req_info[req_num].res);
+			dpriv->req_info[req_num].res_alloc = 0;
+			 dpriv->req_info[req_num].res_size = 0;
+		}
+		dpriv->req_info[req_num].op = -1;
+	}
+
+	dpriv->num_reqs = 0;
+
+	return CRYPTOSOC_OK;
+}
+
+/**
+* rsasoc_free_request_desc - Free the request descriptor
+* @req_desc: Pointer to the request descriptor
+*
+*/
+static inline void rsasoc_free_request_desc(struct rsasoc_request_desc *req_desc)
+{
+	struct rsasoc_req_desc_priv_data *dpriv;
+	int req_num;
+	if(!req_desc)
+		return;
+
+	dpriv = (struct rsasoc_req_desc_priv_data *)req_desc->lib_priv;
+	for(req_num = 0; req_num < dpriv->num_reqs; req_num++) {
+		if(dpriv->req_info[req_num].inp_alloc && 
+				dpriv->req_info[req_num].inp)
+			cryptosoc_mem_free(dpriv->req_info[req_num].inp);
+		if(dpriv->req_info[req_num].res_alloc && 
+				dpriv->req_info[req_num].res)
+			cryptosoc_mem_free(dpriv->req_info[req_num].res);
+	}
+	cryptosoc_mem_free(req_desc);
+}
+
+/**
+* rsasoc_dump_request_data - Dump the input data in the engine format
+* @req_desc: Pointer to the request descriptor
+* @req_num: Request number
+*
+*/
+static inline void rsasoc_dump_request_data(
+		struct rsasoc_request_desc *req_desc, int req_num)
+{
+	struct rsasoc_req_desc_priv_data *dpriv;
+	int blk, i, arg;
+	char *mem;
+	char p[][4]={"x", "y", "n"};
+
+	if(!req_desc)
+		return;
+	dpriv = (struct rsasoc_req_desc_priv_data *)req_desc->lib_priv;
+
+	req_num--;
+	if(req_num >= dpriv->num_reqs)
+		return;
+
+	blk = dpriv->req_info[req_num].blksz_in_bits / 8;
+
+	cryptosoc_dbg_print("BlkszInBits %d  MaxReqs %d NumReqs %d InpSize %d ResSize %d\n", 
+			dpriv->req_info[req_num].blksz_in_bits,
+			dpriv->max_reqs, dpriv->num_reqs, 
+			dpriv->req_info[req_num].inp_size, 
+			dpriv->req_info[req_num].res_size);
+
+	mem = dpriv->req_info[req_num].eng_inp;
+
+	for(arg=0; arg < 3; arg++) {
+		cryptosoc_dbg_print("%s\n", p[arg]);
+		for(i = 0; i < blk; ) {
+			cryptosoc_dbg_print(" <%016llx>", *(_uint64_t *)(mem + i));
+			i += 8;
+			if((i % 32) == 0)
+				cryptosoc_dbg_print("\n");
+		}
+		cryptosoc_dbg_print("\n");
+		mem = mem + blk;
+	}
+	return;
+}
+
+#endif
+
diff --git a/arch/mips/netlogic/lib/seclib/saesoc_defs.h b/arch/mips/netlogic/lib/seclib/saesoc_defs.h
index cdfe8fc..5b4ce21 100644
--- a/arch/mips/netlogic/lib/seclib/saesoc_defs.h
+++ b/arch/mips/netlogic/lib/seclib/saesoc_defs.h
@@ -36,143 +36,6 @@
 #ifndef _SAESOC_DEFS_H
 #define _SAESOC_DEFS_H
 
-#include "stdio.h"
-#include "stdlib.h"
-#include "stddef.h"
-
-/* This should be included in the top before lib.h */
-
-#ifndef _UINT64_T
-#define _UINT64_T
-typedef  unsigned long long   _uint64_t;
-#endif
-
-#define SAESOC_CACHELINE_SZ		64ULL
-#define SAESOC_CACHELINE_SHIFT  6
-#define ___saesoc_cacheline_aligned __attribute__((__aligned__(SAESOC_CACHELINE_SZ)))
-#define saesoc_is_cache_aligned(x) (((_uint64_t)x & (SAESOC_CACHELINE_SZ - 1)) == 0)
-#define saesoc_align(x, y)     ((x) & (~((y)-1)))
-#define saesoc_roundup(x, y)   (saesoc_align((x)+(y)-1, (y)))
-#define saesoc_dbg_print(fmt, args...) printf(fmt, ##args)
-#define saesoc_err_print(fmt, args...) printf(fmt, ##args)
-
-
-#define SAESOC_PTYPE_IS_GEN1 0x1
-#define SAESOC_PTYPE_IS_GEN2 0x2
-
-/**
-* enum saesoc_iv_mode - Cipher & Hash IV mode values
-*
-* @SAESOC_IV_FROM_PKT_SRC: IV value is taken from the packet source
-* @SAESOC_IV_FROM_PKT_DESC: IV value is taken from the packet descriptor
-* 					Valid only if PKT_DESC in the feature flag is set
-*/
-enum saesoc_iv_mode {
-	SAESOC_IV_FROM_PKT_SRC = 0,
-	SAESOC_IV_FROM_PKT_DESC = 1
-};
-
-/** 
- * enum saesoc_err - Possible error codes returned by the APIs
- *
- * @SAESOC_OK: The API executed successfully.
- * @SAESOC_EPERM: Operation not permitted.
- * @SAESOC_ENOENT: Object look up failed
- * @SAESOC_ENOMEM: Out of memory
- * @SAESOC_EINVAL: Invalid argument
- * @SAESOC_ETIMEDOUT: Operation timed out
- */
- 
-enum saesoc_err { 
-	SAESOC_OK = 0, 
-	SAESOC_EPERM    = 1,
-	SAESOC_ENOENT   = 2,
-	SAESOC_ENOMEM   = 12,
-	SAESOC_EINVAL   = 22,
-	SAESOC_ETIMEDOUT = 60,
-};
-
-/** 
- * enum saesoc_ddesc_reset_op - Possible types to reset the data descriptor
- *
- * @SAESOC_DDESC_RESET_ALL_FRAGS: Reset all the frags. Keep IV and other 
- * 		msg informations.
- * @SAESOC_DDESC_RESET_FRAGIDX: Reset till the given fragments.
- */
-
-enum saesoc_ddesc_reset_op {
-	SAESOC_DDESC_RESET_ALL_FRAGS = 1,
-	SAESOC_DDESC_RESET_FRAGIDX
-};
-	
-
-/**
-* defines sess_init_flags : Session initialization flags 
-*
-* @SAESOC_IF_RFP_OUT_ON: Enable Rabin finger print output along with 
-*  	chunk size and hash output. 
-*  	Valid only if RABIN in the feature flags is set 
-* @SAESOC_IF_TLS_ON: Generate tag & encrypt. Used in SSL/TLS mode.
-* @SAESOC_IF_DATA_OUT_L3_ALLOC:	Alloc l3 cache for while writing the op result
-* @SAESOC_IF_DATA_OUT_CLOBBER: 	No read-modify-write while writing the op result
-* @SAESOC_IF_DATA_WR_MOD_ONLY_EN: Write only the modified data while writing 
-* 	the op result. Ignored if the processor does not support this feature.
-*
-*/
-/*!defines sess_init_flags < */
-#define SAESOC_IF_RFP_OUT_ON	0x1   
-#define SAESOC_IF_TLS_ON 		0x4
-#define SAESOC_IF_DATA_OUT_L3_ALLOC 0x8
-#define SAESOC_IF_DATA_OUT_CLOBBER  0x10
-#define SAESOC_IF_DATA_WR_MOD_ONLY_EN 0x20
-/*!defines sess_init_flags > */
-
-/**
-* defines ciph_init_flags - Cipher initialization flags
-* @SAESOC_CF_ENCRYPT: 	Session is for encryption.
-* @SAESOC_CF_ARC4_STATE_OUT_L3_ALLOC: Alloc l3 cache while writing the 
-* 	arc4 state. Ignored if the processor does not support this feature
-* @SAESOC_CF_CIPHER_PAD_ON: Cipher padding is enabled
-*	Valid only if CIPHER_PAD in the feature flag is set
-* @SAESOC_CF_ARC4_KEY_INIT: arc4 key is initted for the first time, for the next
-*	from next time init key has to be reseted to 0.
-*/
-
-/*!defines ciph_init_flags < */
-#define	SAESOC_CF_ENCRYPT 	0x1
-#define SAESOC_CF_ARC4_STATE_OUT_L3_ALLOC 0x2
-#define SAESOC_CF_CIPHER_PAD_ON	 0x4
-#define SAESOC_CF_ARC4_KEY_INIT 0x8
-/*!defines ciph_init_flags > */
-
-/**
-* defines hash_init_flags - Hash initialization flags
-* @SAESOC_HF_HASHINP_IS_CIPHEROUT: Cipher output is given to hash input 
-* @SAESOC_HF_CHKTAG_ON: Engine compares the tag result with the tag value 
-* 	present in the packet. Valid only if CHK_TAG in the feature flag is set 
-* @SAESOC_HF_TAGIN_EOP: Specify that the tag input is at the End of packet.
-*	Valid only if TAG_LOC_EOP in the feature flag is set 
-* @SAESOC_HF_TAGOUT_EOP: Specify that copy the tag output to end of packet.
-* 							Valid only if TAG_LOC_EOP in the feature flag is set 
-* @SAESOC_HF_HMAC_KEY_PAD_EN: Hmac key padding will be done by the engine.
-* @SAESOC_HF_HASH_L3_ALLOC: Alloc l3 cache while writing the tag output
-* @SAESOC_HF_HASH_CLOBBER: No read-modify-write while writing the tag output
-* @SAESOC_HF_HASH_MUTE_MASK_EN: Enable hash mutable option
-* 	Valid only if HASH_MUTE in the feature flag is set
-*
-*/
-
-/*!defines hash_init_flags < */
-#define SAESOC_HF_HASHINP_IS_CIPHEROUT 0x01
-#define SAESOC_HF_CHKTAG_ON 		0x02		
-#define SAESOC_HF_TAGIN_EOP 	0x04
-#define SAESOC_HF_TAGOUT_EOP	0x08
-#define SAESOC_HF_HMAC_KEY_PAD_EN	0x10
-#define SAESOC_HF_HASH_L3_ALLOC		0x20
-#define SAESOC_HF_HASH_CLOBBER		0x40
-#define SAESOC_HF_HASH_MUTE_MASK_EN		0x80
-/*!defines hash_init_flags > */
-
 /**
 * defines saesoc_feature_flags - Feature definitions
 * @SAESOC_FF_RABIN_SUPPORT: Rabin finger print support exist or not.
@@ -231,6 +94,7 @@ enum saesoc_ddesc_reset_op {
 * @SAESOC_FF_CIPHER_ZUC_SUPPORT: Zuc support is exist or not.
 * @SAESOC_FF_HASH_RABIN_SUPPORT: Rabin hash support exist or not
 * @SAESOC_FF_DIS_WR_FRAG_SUPPORT: Disable the fragment write 
+* @SAESOC_FF_3DES_KEY_SWAP_SUPPORT: 2xx and  griffin supports ZUC
 */
 
 /*!defines saesoc_feature_flags < */
@@ -247,6 +111,7 @@ enum saesoc_ddesc_reset_op {
 #define SAESOC_FF_CIPHER_ZUC_SUPPORT 0x400
 #define SAESOC_FF_HASH_RABIN_SUPPORT 0x800
 #define SAESOC_FF_DIS_WR_FRAG_SUPPORT 0x1000
+#define SAESOC_FF_3DES_KEY_SWAP_SUPPORT 0x2000
 /*!defines saesoc_feature_flags > */
 
 /* for generation 1 like eagle, storm, the below 1 is a must */
@@ -291,20 +156,239 @@ enum saesoc_ddesc_reset_op {
 		SAESOC_PER_PKT_UF_IVOFF_SUPPORT | SAESOC_PER_PKT_UF_PYLDOFF_SUPPORT)
 
 
+
+/**
+* enum saesoc_iv_mode - Cipher & Hash IV mode values
+*
+* @SAESOC_IV_FROM_PKT_SRC: IV value is taken from the packet source
+* @SAESOC_IV_FROM_PKT_DESC: IV value is taken from the packet descriptor
+* 					Valid only if PKT_DESC in the feature flag is set
+*/
+enum saesoc_iv_mode {
+	SAESOC_IV_FROM_PKT_SRC = 0,
+	SAESOC_IV_FROM_PKT_DESC = 1
+};
+
+/** 
+ * enum saesoc_ddesc_reset_op - Possible types to reset the data descriptor
+ *
+ * @SAESOC_DDESC_RESET_ALL_FRAGS: Reset all the frags. Keep IV and other 
+ * 		msg informations.
+ * @SAESOC_DDESC_RESET_FRAGIDX: Reset till the given fragments.
+ */
+
+enum saesoc_ddesc_reset_op {
+	SAESOC_DDESC_RESET_ALL_FRAGS = 1,
+	SAESOC_DDESC_RESET_FRAGIDX
+};
+	
+/**
+* defines sess_init_flags : Session initialization flags 
+*
+* @SAESOC_IF_RFP_OUT_ON: Enable Rabin finger print output along with 
+*  	chunk size and hash output. 
+*  	Valid only if RABIN in the feature flags is set 
+* @SAESOC_IF_TLS_ON: Generate tag & encrypt. Used in SSL/TLS mode.
+* @SAESOC_IF_DATA_OUT_L3_ALLOC:	Alloc l3 cache for while writing the op result
+* @SAESOC_IF_DATA_OUT_CLOBBER: 	No read-modify-write while writing the op result
+* @SAESOC_IF_DATA_WR_MOD_ONLY_EN: Write only the modified data while writing 
+* 	the op result. Ignored if the processor does not support this feature.
+*
+*/
+/*!defines sess_init_flags < */
+#define SAESOC_IF_RFP_OUT_ON	0x1   
+#define SAESOC_IF_TLS_ON 		0x4
+#define SAESOC_IF_DATA_OUT_L3_ALLOC 0x8
+#define SAESOC_IF_DATA_OUT_CLOBBER  0x10
+#define SAESOC_IF_DATA_WR_MOD_ONLY_EN 0x20
+/*!defines sess_init_flags > */
+
+/**
+* defines ciph_init_flags - Cipher initialization flags
+* @SAESOC_CF_ENCRYPT: 	Session is for encryption.
+* @SAESOC_CF_ARC4_STATE_OUT_L3_ALLOC: Alloc l3 cache while writing the 
+* 	arc4 state. Ignored if the processor does not support this feature
+* @SAESOC_CF_CIPHER_PAD_ON: Cipher padding is enabled
+*	Valid only if CIPHER_PAD in the feature flag is set
+* @SAESOC_CF_ARC4_KEY_INIT: Arc4 key is initted for the first time, for the next
+*	from next time init key has to be reseted to 0.
+* @SAESOC_CF_DES3_KEYSWAP_DONE: DES3 key swap is already done by the application
+*/
+
+/*!defines ciph_init_flags < */
+#define	SAESOC_CF_ENCRYPT 	0x1
+#define SAESOC_CF_ARC4_STATE_OUT_L3_ALLOC 0x2
+#define SAESOC_CF_CIPHER_PAD_ON	 0x4
+#define SAESOC_CF_ARC4_KEY_INIT 0x8
+#define SAESOC_CF_DES3_KEYSWAP_DONE 0x10
+/*!defines ciph_init_flags > */
+
 /**
-* struct saesoc_lib_params - Sae soc library params based on the processor type
-* @feature_set: Feature set variable and associated flags. See the feature 
-* 	set flag(output)
-* @per_pkt_update_set: Parameters that are modifiable on every packet 
-* 	depending on the processor type. See the uf_flag above(output)
+* defines hash_init_flags - Hash initialization flags
+* @SAESOC_HF_HASHINP_IS_CIPHEROUT: Cipher output is given to hash input 
+* @SAESOC_HF_CHKTAG_ON: Engine compares the tag result with the tag value 
+* 	present in the packet. Valid only if CHK_TAG in the feature flag is set 
+* @SAESOC_HF_TAGIN_EOP: Specify that the tag input is at the End of packet.
+*	Valid only if TAG_LOC_EOP in the feature flag is set 
+* @SAESOC_HF_TAGOUT_EOP: Specify that copy the tag output to end of packet.
+* 							Valid only if TAG_LOC_EOP in the feature flag is set 
+* @SAESOC_HF_HMAC_KEY_PAD_EN: Hmac key padding will be done by the engine.
+* @SAESOC_HF_HASH_L3_ALLOC: Alloc l3 cache while writing the tag output
+* @SAESOC_HF_HASH_CLOBBER: No read-modify-write while writing the tag output
+* @SAESOC_HF_HASH_MUTE_MASK_EN: Enable hash mutable option
+* 	Valid only if HASH_MUTE in the feature flag is set
+*
 */
-struct saesoc_lib_params {
-	unsigned int feature_set ; 
-	unsigned int per_pkt_update_set ; 
+
+/*!defines hash_init_flags < */
+#define SAESOC_HF_HASHINP_IS_CIPHEROUT 0x01
+#define SAESOC_HF_CHKTAG_ON 		0x02		
+#define SAESOC_HF_TAGIN_EOP 	0x04
+#define SAESOC_HF_TAGOUT_EOP	0x08
+#define SAESOC_HF_HMAC_KEY_PAD_EN	0x10
+#define SAESOC_HF_HASH_L3_ALLOC		0x20
+#define SAESOC_HF_HASH_CLOBBER		0x40
+#define SAESOC_HF_HASH_MUTE_MASK_EN		0x80
+/*!defines hash_init_flags > */
+
+/**
+* enum saesoc_cipher_type - Supported cipher types
+* @SAESOC_CIPHER_TYPE_AES_128: Cipher type is AES 128
+* @SAESOC_CIPHER_TYPE_AES_192: Cipher type is AES 192
+* @SAESOC_CIPHER_TYPE_AES_256: Cipher type is AES 256
+* @SAESOC_CIPHER_TYPE_CAMELLIA_128: Cipher type is Camellia 128
+* @SAESOC_CIPHER_TYPE_CAMELLIA_192: Cipher type is Camellia 192
+* @SAESOC_CIPHER_TYPE_CAMELLIA_256: Cipher type is Camellia 256
+* @SAESOC_CIPHER_BYPASS: No Cipher operation
+* @SAESOC_CIPHER_TYPE_KASUMI: Cipher type is Kasumi
+* @SAESOC_CIPHER_TYPE_SNOW3G: Cipher type is Snow3G
+* @SAESOC_CIPHER_TYPE_ZUC: Cipher type is ZUC
+* @SAESOC_CIPHER_TYPE_DES: Cipher type is DES
+* @SAESOC_CIPHER_TYPE_TDES: Cipher type is TDES
+* @SAESOC_CIPHER_TYPE_ARC4: Cipher type is ARC4
+* @SAESOC_CIPHER_TYPE_MAX: End of cipher type
+*/
+
+enum saesoc_cipher_type {
+	SAESOC_CIPHER_TYPE_AES_128 = 0x00,
+	SAESOC_CIPHER_TYPE_AES_192 = 0x01,
+	SAESOC_CIPHER_TYPE_AES_256 = 0x02,
+	SAESOC_CIPHER_TYPE_CAMELLIA_128 = 0x04,
+	SAESOC_CIPHER_TYPE_CAMELLIA_192 = 0x05,
+	SAESOC_CIPHER_TYPE_CAMELLIA_256 = 0x06,
+	SAESOC_CIPHER_BYPASS = 0x08,
+	SAESOC_CIPHER_TYPE_KASUMI = 0x09,
+	SAESOC_CIPHER_TYPE_SNOW3G = 0x0a,
+	SAESOC_CIPHER_TYPE_ZUC = 0x0b,
+	SAESOC_CIPHER_TYPE_DES = 0x0c,
+	SAESOC_CIPHER_TYPE_TDES = 0x0d,
+	SAESOC_CIPHER_TYPE_ARC4 = 0x0e,
+	SAESOC_CIPHER_TYPE_MAX
+};
+
+/*
+* enum saesoc_cipher_modes - Supported cipher modes
+* @SAESOC_CIPHER_MODE_ECB: Cipher mode is ECB
+* @SAESOC_CIPHER_MODE_CBC: Cipher mode is CBC
+* @SAESOC_CIPHER_MODE_CFB: Cipher mode is CFB
+* @SAESOC_CIPHER_MODE_OFB: Cipher mode is OFB
+* @SAESOC_CIPHER_MODE_CTR: Cipher mode is Counter
+* @SAESOC_CIPHER_MODE_AES_F8: Cipher mode is AES F8
+* @SAESOC_CIPHER_MODE_LRW: Cipher mode is LRW
+* @SAESOC_CIPHER_MODE_XTS: Cipher mode is XTS
+* @SAESOC_CIPHER_MODE_CCM: Cipher mode is CCM
+* @SAESOC_CIPHER_MODE_GCM: Cipher mode is GCM
+* @SAESOC_CIPHER_MODE_MAX: End of cipher mode
+*/
+
+enum saesoc_cipher_mode {
+	SAESOC_CIPHER_MODE_ECB = 0x00,
+	SAESOC_CIPHER_MODE_CBC = 0x01,
+	SAESOC_CIPHER_MODE_CFB = 0x02,
+	SAESOC_CIPHER_MODE_OFB = 0x03,
+	SAESOC_CIPHER_MODE_CTR = 0x04,
+	SAESOC_CIPHER_MODE_AES_F8 = 0x05,
+	SAESOC_CIPHER_MODE_LRW = 0x06,
+	SAESOC_CIPHER_MODE_XTS = 0x07,
+	SAESOC_CIPHER_MODE_CCM = 0x08,
+	SAESOC_CIPHER_MODE_GCM = 0x09,
+	SAESOC_CIPHER_MODE_MAX
+};
+
+
+/*
+* enum saesoc_hash_type - Supported hash types
+*
+* @SAESOC_HASH_TYPE_AES_128: Hash type is AES 128
+* @SAESOC_HASH_TYPE_AES_192: Hash type is AES 192
+* @SAESOC_HASH_TYPE_AES_256: Hash type is AES 256
+* @SAESOC_HASH_TYPE_CAMELLIA_128: Hash type is Camellia 128
+* @SAESOC_HASH_TYPE_CAMELLIA_192: Hash type is Camellia 192
+* @SAESOC_HASH_TYPE_CAMELLIA_256: Hash type is Camellia 256
+* @SAESOC_HASH_BYPASS: No hash operation
+* @SAESOC_HASH_TYPE_KASUMI: Hash type is Kasumi
+* @SAESOC_HASH_TYPE_SNOW3G: Hash type is Snow3G
+* @SAESOC_HASH_TYPE_ZUC: Hash type is ZUC
+* @SAESOC_HASH_TYPE_RABIN: Hash type is RABIN
+* @SAESOC_HASH_TYPE_GHASH: Hash type is GHASH
+* @SAESOC_HASH_TYPE_MD5: Hash type is MD5
+* @SAESOC_HASH_TYPE_SHA_1: Hash type is SHA-1
+* @SAESOC_HASH_TYPE_SHA_224: Hash type is SHA-224
+* @SAESOC_HASH_TYPE_SHA_256: Hash type is SHA-256
+* @SAESOC_HASH_TYPE_SHA_384: Hash type is SHA-384
+* @SAESOC_HASH_TYPE_SHA_512: Hash type is SHA-512
+* @SAESOC_HASH_TYPE_SHA_512_224: Hash type is SHA-512/224
+* @SAESOC_HASH_TYPE_SHA_512_256: Hash type is SHAR-512/256
+* @SAESOC_HASH_TYPE_MAX : End of Hash type 
+*/
+
+enum saesoc_hash_type {
+	SAESOC_HASH_TYPE_AES_128 = 0x00,
+	SAESOC_HASH_TYPE_AES_192 = 0x01,
+	SAESOC_HASH_TYPE_AES_256 = 0x02,
+	SAESOC_HASH_TYPE_CAMELLIA_128 = 0x04,
+	SAESOC_HASH_TYPE_CAMELLIA_192 = 0x05,
+	SAESOC_HASH_TYPE_CAMELLIA_256 = 0x06,
+	SAESOC_HASH_BYPASS = 0x08,
+	SAESOC_HASH_TYPE_KASUMI = 0x09,
+	SAESOC_HASH_TYPE_SNOW3G = 0x0a,
+	SAESOC_HASH_TYPE_ZUC = 0x0b,
+	SAESOC_HASH_TYPE_RABIN = 0x0c,
+	SAESOC_HASH_TYPE_GHASH = 0x0d,
+	SAESOC_HASH_TYPE_MD5 = 0x10,
+	SAESOC_HASH_TYPE_SHA_1 = 0x11, 
+	SAESOC_HASH_TYPE_SHA_224 = 0x12,
+	SAESOC_HASH_TYPE_SHA_256 = 0x13,
+	SAESOC_HASH_TYPE_SHA_384 = 0x14,
+	SAESOC_HASH_TYPE_SHA_512 = 0x15,
+	SAESOC_HASH_TYPE_SHA_512_224 = 0x16,
+	SAESOC_HASH_TYPE_SHA_512_256 = 0x17,
+	SAESOC_HASH_TYPE_MAX
+};
+
+/*
+* enum saesoc_hash_mode - Supported hash modes
+*
+* @SAESOC_HASH_MODE_CMAC: Hash mode is CMAC 
+* @SAESOC_HASH_MODE_CBC: Hash mode is CBC
+* @SAESOC_HASH_MODE_XCBC: Hash mode is XCBC
+* @SAESOC_HASH_MODE_HMAC: Hash mode is HMAC
+* @SAESOC_HASH_MODE_RABIN_TERMINATION: Hash mode is RABIN TERMINATION
+* @SAESOC_HASH_MODE_CCM: Hash mode is CCM
+* @SAESOC_HASH_MODE_GCM: Hash mode is GCM
+* @SAESOC_HASH_MODE_MAX: End of hash mode
+*/
+enum saesoc_hash_mode {
+	SAESOC_HASH_MODE_CMAC = 0x00,
+	SAESOC_HASH_MODE_CBC = 0x01,
+	SAESOC_HASH_MODE_XCBC = 0x02,
+	SAESOC_HASH_MODE_HMAC = 0x04,
+	SAESOC_HASH_MODE_RABIN_TERMINATION = 0x05,
+	SAESOC_HASH_MODE_CCM = 0x08,
+	SAESOC_HASH_MODE_GCM = 0x09,
+	SAESOC_HASH_MODE_MAX
 };
 
-typedef int saesoc__app_lib_init(struct saesoc_lib_params *);
-typedef void *saesoc__mem_alloc(size_t align, size_t size);
-typedef void saesoc__mem_free(void *ptr);
 
 #endif
+
diff --git a/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h b/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h
index cd8b434..8931412 100644
--- a/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h
+++ b/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h
@@ -36,7 +36,7 @@
 #ifndef _SAESOC_GEN1_HAL_DEFS_H_
 #define _SAESOC_GEN1_HAL_DEFS_H_
 
-#include "saesoc_defs.h"
+#include "cryptosoc_lib.h"
 
 #define SAESOC_GEN1_SET_MASK(PARAM) \
 	(SAESOC_GEN1_##PARAM##_MASK) << (SAESOC_GEN1_##PARAM##_SHIFT)
@@ -125,7 +125,7 @@
 #define SAESOC_GEN1_FB_DEST_ID_SHIFT 48
 
 #define SAESOC_GEN1_TAGLEN_MASK 0xffffULL
-#define SAESOC_GEN1_TAGLEN_SHIFT 16
+#define SAESOC_GEN1_TAGLEN_SHIFT 11
 
 #define SAESOC_GEN1_ARC4_L3_ALLOC_MASK 0x1ULL
 #define SAESOC_GEN1_ARC4_L3_ALLOC_SHIFT 8 
@@ -199,6 +199,8 @@ static char saesoc_gen1_cipher_type[][32] = {
 "camelia 192",  // NLM_CIPHER_CAMELLIA192
 "camelia 256",  // NLM_CIPHER_CAMELLIA256
 "undefined",  // > max
+"zuc",
+"undefined",
 };
 static char saesoc_gen1_cipher_mode[][32] = {
 "ecb",          // NLM_CIPHER_MODE_ECB
@@ -229,6 +231,7 @@ static char saesoc_gen1_hash_type[][32] = {
 "camellia 192", // NLM_AUTH_CAMELLIA192
 "camellia 256", // NLM_AUTH_CAMELLIA256
 "ghash",        // NLM_AUTH_GHASH
+"zuc",
 "undefined",    // > max
 };
 static char saesoc_gen1_hashmode[][32] = {
@@ -240,40 +243,81 @@ static char saesoc_gen1_hashmode[][32] = {
 "cmac",         // NLM_AUTH_MODE_CMAC
 "xcbc",         // NLM_AUTH_MODE_XCBC
 "cbc mac",      // NLM_AUTH_MODE_CBC_MAC
+"gcm",
+"ccm",
 "undefined", // > max
 };
 
-static void saesoc_gen1_dump_fmnentry(_uint64_t entry0, _uint64_t entry1)
+enum saesoc_gen1_hash_type {
+	SAESOC_GEN1_HASH_TYPE_AES_128 = 0x4,
+	SAESOC_GEN1_HASH_TYPE_AES_192 = 0x5,
+	SAESOC_GEN1_HASH_TYPE_AES_256 = 0x6,
+    SAESOC_GEN1_HASH_TYPE_CAMELLIA_128 = 0x09,
+	SAESOC_GEN1_HASH_TYPE_CAMELLIA_192 = 0x0a,
+	SAESOC_GEN1_HASH_TYPE_CAMELLIA_256 = 0x0b,	
+	SAESOC_GEN1_HASH_BYPASS = 0x00,
+	SAESOC_GEN1_HASH_TYPE_KASUMI = 0x07,
+	SAESOC_GEN1_HASH_TYPE_SNOW3G = 0x08,
+	SAESOC_GEN1_HASH_TYPE_ZUC = 0x0d,
+	SAESOC_GEN1_HASH_TYPE_RABIN = 0x0,
+	SAESOC_GEN1_HASH_TYPE_GHASH = 0x0c,
+	SAESOC_GEN1_HASH_TYPE_MD5 = 0x01,
+	SAESOC_GEN1_HASH_TYPE_SHA_1 = 0x02,
+	SAESOC_GEN1_HASH_TYPE_SHA_224 = 0x12,
+	SAESOC_GEN1_HASH_TYPE_SHA_256 = 0x22,
+	SAESOC_GEN1_HASH_TYPE_SHA_384 = 0x32,
+	SAESOC_GEN1_HASH_TYPE_SHA_512 = 0x42,
+	SAESOC_GEN1_HASH_TYPE_MAX = 0xff
+};
+
+enum saesoc_gen1_cipher_type {
+	SAESOC_GEN1_CIPHER_TYPE_AES_128 = 0x3,
+	SAESOC_GEN1_CIPHER_TYPE_AES_192 = 0x4,
+	SAESOC_GEN1_CIPHER_TYPE_AES_256 = 0x5,
+	SAESOC_GEN1_CIPHER_TYPE_CAMELLIA_128 = 0x9,
+	SAESOC_GEN1_CIPHER_TYPE_CAMELLIA_192 = 0xa,
+	SAESOC_GEN1_CIPHER_TYPE_CAMELLIA_256 = 0xb,
+	SAESOC_GEN1_CIPHER_BYPASS = 0x0,
+	SAESOC_GEN1_CIPHER_TYPE_KASUMI = 0x7,
+	SAESOC_GEN1_CIPHER_TYPE_SNOW3G = 0x8,
+	SAESOC_GEN1_CIPHER_TYPE_ZUC =0xd,
+	SAESOC_GEN1_CIPHER_TYPE_DES =0x1,
+	SAESOC_GEN1_CIPHER_TYPE_TDES = 0x2,
+	SAESOC_GEN1_CIPHER_TYPE_ARC4 = 0x6,
+	SAESOC_GEN1_CIPHER_TYPE_MAX = 0xf
+};
+
+static inline void saesoc_gen1_dump_fmnentry(_uint64_t entry0, _uint64_t entry1)
 {
 
-	saesoc_dbg_print("\nFmn Info entry0 %llx entry1 %llx\n",entry0, entry1);
-	saesoc_dbg_print("  %-16s %-16s %-16s %-16s %-16s \n",
-			"RegFb","DesFbEn", "DesFbLen", "CtrlDescLen", "CtrlDescAddr");
+	cryptosoc_dbg_print("\nFmn Info entry0 %llx entry1 %llx\n",entry0, entry1);
+	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s %-16s \n",
+			"RegFb","DesFbEn", "DesFbLen", "KeyLenInDw", "CtrlDescAddr");
 
-	saesoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld %-16llx\n",
+	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld %-16llx\n",
 			SAESOC_GEN1_GET_BITS(entry0, REG_FB_DEST_ID),
 			SAESOC_GEN1_GET_BITS(entry0, DESIGN_FB_EN),
 			SAESOC_GEN1_GET_BITS(entry0, DESIGN_FB_LEN),
 			SAESOC_GEN1_GET_BITS(entry0, CIPHER_KEY_LEN),
-			SAESOC_GEN1_GET_BITS(entry0, CTRL_DESC_ADDR));
-
+			(SAESOC_GEN1_GET_BITS(entry0, CTRL_DESC_ADDR) << 
+			 		CRYPTOSOC_CACHELINE_SHIFT));
 
 
-
-	saesoc_dbg_print("  %-16s %-16s %-16s %-16s \n", 
+	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s \n", 
 			"Arc4StateLdEn", "Hashkeylen", "PktDescLen", "PktDescAddr");
-	saesoc_dbg_print("  %-16lld %-16lld %-16lld %-16llx \n",
+	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16llx \n",
 			SAESOC_GEN1_GET_BITS(entry1, ARC4_STATE_LD_EN), 
 			SAESOC_GEN1_GET_BITS(entry1, HASH_KEY_LEN),
 			SAESOC_GEN1_GET_BITS(entry1, PKT_DESC_LEN), 
-			SAESOC_GEN1_GET_BITS(entry1, PKT_DESC_ADDR));
+			(SAESOC_GEN1_GET_BITS(entry1, PKT_DESC_ADDR) << 
+			 			CRYPTOSOC_CACHELINE_SHIFT));
 
 }
 
 /**
  * saesoc_gen1_dump_cdesc - Extract the control descriptors and dump the
  * 	 values
- * @cdesc: Pointer to the control descriptor
+ * @cdescs: Pointer to the control descriptor
  * @ndescs: Number of descriptors present
  */
 static void saesoc_gen1_dump_cdesc(_uint64_t *cdescs, int ndescs)
@@ -281,38 +325,38 @@ static void saesoc_gen1_dump_cdesc(_uint64_t *cdescs, int ndescs)
 	unsigned int type,mode;
 	_uint64_t cdesc = cdescs[0];
 
-	saesoc_dbg_print("\ncontrol description info:\n");
-       	saesoc_dbg_print("%-16s \n", "Desc");
-	saesoc_dbg_print("%-16llx\n", (unsigned long long)cdesc);
+	cryptosoc_dbg_print("\ncontrol description info:\n");
+       	cryptosoc_dbg_print(" %-16s \n", "Desc");
+	cryptosoc_dbg_print(" %-16llx\n", (unsigned long long)cdesc);
 
 	type = SAESOC_GEN1_GET_BITS(cdesc, HASH_TYPE); 
 	mode = SAESOC_GEN1_GET_BITS(cdesc, HASH_MODE);
 
-	saesoc_dbg_print("%-16s %-16s %-16s \n","Hmac","HashType","HashMode");
-	saesoc_dbg_print("%-16llx %-16s %-16s\n",
+	cryptosoc_dbg_print(" %-16s %-16s %-16s \n","Hmac","HashType","HashMode");
+	cryptosoc_dbg_print(" %-16llx %-16s %-16s\n",
 			SAESOC_GEN1_GET_BITS(cdesc, HMAC),
 			saesoc_gen1_hash_type[type],saesoc_gen1_hashmode[mode]);
 
 	type =  SAESOC_GEN1_GET_BITS(cdesc,CIPHER_TYPE );
 	mode = SAESOC_GEN1_GET_BITS(cdesc,CIPHER_MODE );
 
-	saesoc_dbg_print("%-16s %-16s\n","CipherType","CipherMode");
-	saesoc_dbg_print("%-16s %-16s\n",saesoc_gen1_cipher_type[type],
+	cryptosoc_dbg_print(" %-16s %-16s\n","CipherType","CipherMode");
+	cryptosoc_dbg_print(" %-16s %-16s\n",saesoc_gen1_cipher_type[type],
 			saesoc_gen1_cipher_mode[mode]);
 
-	saesoc_dbg_print("%-16s %-16s %-16s\n",
-			"KeyLen","KeyInit","cfb mask");
-	saesoc_dbg_print("%-16lld %-16lld %-16llx\n",
+	cryptosoc_dbg_print(" %-16s %-16s %-16s\n",
+			"Arc4KeyLen","Arc4KeyInit","CfbMask");
+	cryptosoc_dbg_print(" %-16lld %-16lld %-16llx\n",
 			SAESOC_GEN1_GET_BITS(cdesc, ARC4_KEY_LEN),
 			SAESOC_GEN1_GET_BITS(cdesc, ARC4_KEY_INIT),
 			SAESOC_GEN1_GET_BITS(cdesc, CFB_MASK));
 
 	if(ndescs > 1) {
 		int i;
-		saesoc_dbg_print("\nKey info:\n");
+		cryptosoc_dbg_print("\nKey info:\n");
 		for(i = 1; i < ndescs; i++)
-			saesoc_dbg_print("  <%-16llx>", cdescs[i]);
-		saesoc_dbg_print("\n");
+			cryptosoc_dbg_print("  <%-16llx>", cdescs[i]);
+		cryptosoc_dbg_print("\n");
 	}
 }
 
@@ -320,6 +364,7 @@ static void saesoc_gen1_dump_cdesc(_uint64_t *cdescs, int ndescs)
  * saesoc_gen1_dump_ddesc - Extract the data descriptors and dump the values
  * @ddesc: Pointer to the data descriptor array
  * @ndescs: Number of descriptors present
+ * @ndesfb_descs: Number of designer freeback descriptors present
  */
 static void saesoc_gen1_dump_ddesc(_uint64_t *ddesc, int ndescs, int ndesfb_descs)
 {
@@ -332,85 +377,86 @@ static void saesoc_gen1_dump_ddesc(_uint64_t *ddesc, int ndescs, int ndesfb_desc
 	desc2 = ddesc[nd++];
 	desc3 = ddesc[nd++];
 
-	saesoc_dbg_print("\nData Descriptor info:\n");
-	saesoc_dbg_print("%-16s %-16s %-16s %-16s\n",
+	cryptosoc_dbg_print("\nData Descriptor info:\n");
+	cryptosoc_dbg_print(" %-16s %-16s %-16s %-16s\n",
 			"Desc0","Desc1","Desc2","Desc3");
 
-	saesoc_dbg_print("%-16llx %-16llx %-16llx %-16llx\n",
+	cryptosoc_dbg_print(" %-16llx %-16llx %-16llx %-16llx\n",
 			desc0, desc1, desc2,desc3);	
 
-	saesoc_dbg_print("%-16s %-16s\n","TLS proto","Hash Source");
-	saesoc_dbg_print("%-16lld %-16lld\n",
+	cryptosoc_dbg_print(" %-16s %-16s\n","TLSProto","HashSource");
+	cryptosoc_dbg_print(" %-16lld %-16lld\n",
 			SAESOC_GEN1_GET_BITS(desc0,TLS_ENABLE),
 			SAESOC_GEN1_GET_BITS(desc0, HASH_SRC_SEL));
 
-	saesoc_dbg_print("%-16s %-16s %-16s\n","HashL3","HashAddr","HashLen");
-	saesoc_dbg_print("%-16lld %-16llx %-16lld\n",
+	cryptosoc_dbg_print(" %-16s %-16s %-16s\n","HashL3","HashAddr","HashLen");
+	cryptosoc_dbg_print(" %-16lld %-16llx %-16lld\n",
 			SAESOC_GEN1_GET_BITS(desc0,HASH_L3_ALLOCATE ),
 			SAESOC_GEN1_GET_BITS(desc0,HASH_DEST_ADDR ),
 			SAESOC_GEN1_GET_BITS(desc1,HASH_LEN));
 
-	saesoc_dbg_print("%-16s %-16s %-16s \n","HashBitCnt","HashClobber",
+	cryptosoc_dbg_print(" %-16s %-16s %-16s \n","HashBitCnt","HashClobber",
 			"HashOffset");
-	saesoc_dbg_print("%-16lld %-16lld %-16lld\n",
+	cryptosoc_dbg_print(" %-16lld %-16lld %-16lld\n",
 		SAESOC_GEN1_GET_BITS(desc2,HASH_BIT_CNT ),
 		SAESOC_GEN1_GET_BITS(desc2,HASH_CLOBBER ),
 		SAESOC_GEN1_GET_BITS(desc2,HASH_OFFSET ));
 
-	saesoc_dbg_print("%-16s %-16s\n","Tag len","Ext pad key");
-	saesoc_dbg_print("%-16lld %-16lld\n",
+	cryptosoc_dbg_print(" %-16s %-16s\n","TagLen","ExtPadKey");
+	cryptosoc_dbg_print(" %-16lld %-16lld\n",
 		SAESOC_GEN1_GET_BITS(desc3, TAGLEN),
 		SAESOC_GEN1_GET_BITS(desc3,HMAC_EXTPAD_KEY ));
 
-	saesoc_dbg_print("%-16s %-16s %-16s\n","Encrypt","IV length",
-			"IV Offset");
-	saesoc_dbg_print("%-16lld %-16lld %-16lld\n",
+	cryptosoc_dbg_print(" %-16s %-16s %-16s\n","Encrypt","IVLength",
+			"IVOffset");
+	cryptosoc_dbg_print(" %-16lld %-16lld %-16lld\n",
 			SAESOC_GEN1_GET_BITS(desc0,CIPHER_ENCRYPT ),	
 			SAESOC_GEN1_GET_BITS(desc0,IVLEN ),
 			SAESOC_GEN1_GET_BITS(desc2,IV_OFFSET ));
 
-	saesoc_dbg_print("%-16s %-16s %-16s\n","CipherLen","CipherBitCnt",
+	cryptosoc_dbg_print(" %-16s %-16s %-16s\n","CipherLen","CipherBitCnt",
 			"CipherOffset");
-	saesoc_dbg_print("%-16lld %-16lld %-16lld\n",
+	cryptosoc_dbg_print(" %-16lld %-16lld %-16lld\n",
 		SAESOC_GEN1_GET_BITS(desc1, CIPHER_LEN),
 		SAESOC_GEN1_GET_BITS(desc2, CIPHER_BIT_CNT),
 		SAESOC_GEN1_GET_BITS(desc2, CIPHER_OFFSET));
 
-	saesoc_dbg_print("%-16s %-16s %-16s\n","Designer fb","arc4 l3",
-			"arc4 save state");
-	saesoc_dbg_print("%-16lld %-16lld %-16lld\n",
+	cryptosoc_dbg_print(" %-16s %-16s %-16s\n","DesignerFb","Arc4L3",
+			"Arc4SaveState");
+	cryptosoc_dbg_print(" %-16lld %-16lld %-16lld\n",
 		SAESOC_GEN1_GET_BITS(desc3, FB_DEST_ID),
 		SAESOC_GEN1_GET_BITS(desc3, ARC4_L3_ALLOC),
 		SAESOC_GEN1_GET_BITS(desc3, ARC4_SAVE_SATE_EN));
 
-	for (i=0; i < ndescs - ndesfb_descs; i++) {
-		desc0 = ddesc[nd++];
-		desc1 = ddesc[nd++];
+	for (i=nd; i < ndescs - ndesfb_descs; ) {
+		desc0 = ddesc[i++];
+		desc1 = ddesc[i++];
 
-		saesoc_dbg_print("%-16s %-16s\n","src frag","dst frag");
-		saesoc_dbg_print("%-16llx %-16llx\n",desc0, desc1);
+		cryptosoc_dbg_print(
+				"\nPacket Fragment info: Srcfrag %-16llx DstFrag %-16llx\n",
+				desc0, desc1);
 
-		saesoc_dbg_print("%-16s %-16s \n",
-				"src frag len","src frag paddr");
-		saesoc_dbg_print("%-16lld %-16llx\n",
+		cryptosoc_dbg_print(" %-16s %-16s \n",
+				"SrcFragLen","SrcFragPaddr");
+		cryptosoc_dbg_print(" %-16lld %-16llx\n",
                 	SAESOC_GEN1_GET_BITS(desc0, PAYLOEAD_LEN),
                		SAESOC_GEN1_GET_BITS(desc0, PAYLOEAD_SRC_ADDR));
 
-		saesoc_dbg_print("%-16s %-16s %-16s %-16s\n",
-				"dst frag len","dst frag paddr", "cipher l3", "cipher clobber");
-		saesoc_dbg_print("%-16lld %-16llx %-16lld %-16lld \n",
+		cryptosoc_dbg_print(" %-16s %-16s %-16s %-16s\n",
+				"DstFragLen","DstFragPaddr", "CipherL3", "CipherClobber");
+		cryptosoc_dbg_print(" %-16lld %-16llx %-16lld %-16lld \n",
                 	SAESOC_GEN1_GET_BITS(desc1, DEST_PAYLOAD_LEN),
                 	SAESOC_GEN1_GET_BITS(desc1, CIPHER_DEST_ADDR),
                 	SAESOC_GEN1_GET_BITS(desc1, CIPHER_L3_ALLOC),
                 	SAESOC_GEN1_GET_BITS(desc1, CIPHER_CLOBBER));
 	}
 	if(ndesfb_descs) {
-		saesoc_dbg_print("\nDesigner Fb descs:\n");
+		cryptosoc_dbg_print("\nDesigner Fb descs:\n");
 		for(; (i < ndescs); i++) 
-			saesoc_dbg_print("  %-16llx", ddesc[i]);
-		saesoc_dbg_print("\n");
+			cryptosoc_dbg_print("  %-16llx", ddesc[i]);
+		cryptosoc_dbg_print("\n");
 	}
-	saesoc_dbg_print("\n");
+	cryptosoc_dbg_print("\n");
 }
 
 /**
@@ -453,6 +499,27 @@ static void saesoc_gen1_dump_ddesc(_uint64_t *ddesc, int ndescs, int ndesfb_desc
 	    SAESOC_GEN1_SET_BITS(mode, CIPHER_MODE) ;		\
 	}
 
+/**
+ * saesoc_gen1_set_hash_bypass - Set the control descriptor with 
+ * 	Hash bypass
+ * @cdesc        : ctrl Descriptor 
+ */
+#define saesoc_gen1_set_hash_bypass(cdesc) {	\
+	 _uint64_t mask = SAESOC_GEN1_SET_MASK(HASH_TYPE); \
+	cdesc = cdesc & ~mask;					\
+	cdesc = cdesc | SAESOC_GEN1_SET_BITS(SAESOC_GEN1_HASH_BYPASS, HASH_TYPE); \
+}
+
+/**
+ * saesoc_gen1_set_cipher_bypass - Set the control descriptor with 
+ *  Cipher bypass
+ * @cdesc        : ctrl Descriptor 
+ */
+#define saesoc_gen1_set_cipher_bypass(cdesc) {	\
+	 _uint64_t mask = SAESOC_GEN2_SET_MASK(CIPHER_TYPE); \
+	cdesc = cdesc & ~mask;					\
+	cdesc = cdesc | SAESOC_GEN1_SET_BITS(SAESOC_GEN1_CIPHER_BYPASS, CIPHER_TYPE); \
+}
 
 /**
  * saesoc_gen1_set_arc4_param - Set the control descriptor with arc4 
@@ -568,8 +635,13 @@ static void saesoc_gen1_dump_ddesc(_uint64_t *ddesc, int ndescs, int ndesfb_desc
 	_uint64_t mask = SAESOC_GEN1_SET_MASK(CIPHER_ENCRYPT)|        \
 		SAESOC_GEN1_SET_MASK(IVLEN);				\
 	ddesc0 = ddesc0 & ~mask;					\
-	ddesc0 = ddesc0 |SAESOC_GEN1_SET_BITS(encrypt,CIPHER_ENCRYPT) |	\
-		SAESOC_GEN1_SET_BITS(iv_len,IVLEN);			\
+	if( iv_len ) {							\
+		ddesc0 = ddesc0 |					\
+			 SAESOC_GEN1_SET_BITS(encrypt,CIPHER_ENCRYPT) | \
+		SAESOC_GEN1_SET_BITS((iv_len-1),IVLEN);  		\
+	}else								\
+		ddesc0 = ddesc0 | 					\
+			 SAESOC_GEN1_SET_BITS(encrypt,CIPHER_ENCRYPT);  \
 	}
 
 /**
@@ -583,7 +655,7 @@ static void saesoc_gen1_dump_ddesc(_uint64_t *ddesc, int ndescs, int ndesfb_desc
 #define saesoc_gen1_set_cipher_len( ddesc1, cipher_len) {			\
 	 _uint64_t mask=SAESOC_GEN1_SET_MASK(CIPHER_LEN);		\
 	ddesc1 = ddesc1 & ~mask;					\
-	ddesc1 = ddesc1 | SAESOC_GEN1_SET_BITS(cipher_len,CIPHER_LEN);	\
+	ddesc1 = ddesc1 | SAESOC_GEN1_SET_BITS((cipher_len-1),CIPHER_LEN);	\
 	}
 
 /**
@@ -596,7 +668,7 @@ static void saesoc_gen1_dump_ddesc(_uint64_t *ddesc, int ndescs, int ndesfb_desc
 #define saesoc_gen1_set_hash_len( ddesc1, hash_len) {				\
 	_uint64_t mask=SAESOC_GEN1_SET_MASK(HASH_LEN);		\
 	ddesc1 = ddesc1 & ~mask;					\
-	ddesc1 = ddesc1 | SAESOC_GEN1_SET_BITS(hash_len,HASH_LEN);	\
+	ddesc1 = ddesc1 | SAESOC_GEN1_SET_BITS((hash_len-1),HASH_LEN);	\
 	}
 
 /**
@@ -749,14 +821,14 @@ static void saesoc_gen1_dump_ddesc(_uint64_t *ddesc, int ndescs, int ndesfb_desc
 /**
  * saesoc_gen1_set_src_frag - sets the payload length and src addr  
  * @ddesc4  	:  data Descriptor 4
+ * @frag_len 	:  A value of 0 in this field indicates length of 1 byte. 
  * @src_addr     :  Byte aligned read address for fetching security
  *                 payload
- * @frag_len 	:  A value of 0 in this field indicates length of 1 byte. 
  *
  * Sets the length and src address for payload.
  */
-#define saesoc_gen1_set_src_frag( ddesc4, src_addr, frag_len) {	\
-	ddesc4 = SAESOC_GEN1_SET_BITS( frag_len, PAYLOEAD_LEN) |	\
+#define saesoc_gen1_set_src_frag( ddesc4, frag_len, src_addr) {	\
+	ddesc4 = SAESOC_GEN1_SET_BITS( (frag_len-1), PAYLOEAD_LEN) |	\
 		SAESOC_GEN1_SET_BITS( src_addr, PAYLOEAD_SRC_ADDR);	\
 	}
 
@@ -764,16 +836,16 @@ static void saesoc_gen1_dump_ddesc(_uint64_t *ddesc, int ndescs, int ndesfb_desc
 /**
  * saesoc_gen1_set_dst_frag - sets the dst payload length and addr
  * @ddesc5	: data Descriptor 5
- * @dst_addr 	: Bytealigned write address for encrypted/decrypted data
  * @frag_len  : A value of 0 in this field indicates a length of 1 byte
+ * @dst_addr 	: Bytealigned write address for encrypted/decrypted data
  *
  * Clears and sets payload destination length and address 
  */
-#define saesoc_gen1_set_dst_frag(ddesc5, dst_addr, frag_len) { \
+#define saesoc_gen1_set_dst_frag(ddesc5, frag_len, dst_addr) { \
 	_uint64_t mask = SAESOC_GEN1_SET_MASK(DEST_PAYLOAD_LEN) |	\
 			SAESOC_GEN1_SET_MASK(CIPHER_DEST_ADDR);		\
 	ddesc5 = ddesc5 & ~mask;					\
-	ddesc5 = SAESOC_GEN1_SET_BITS(frag_len,DEST_PAYLOAD_LEN) | \
+	ddesc5 = ddesc5 |SAESOC_GEN1_SET_BITS((frag_len-1),DEST_PAYLOAD_LEN) | \
 		SAESOC_GEN1_SET_BITS(dst_addr, CIPHER_DEST_ADDR);		\
 	}
 
diff --git a/arch/mips/netlogic/lib/seclib/saesoc_gen2_hal_defs.h b/arch/mips/netlogic/lib/seclib/saesoc_gen2_hal_defs.h
index b8043df..855a7b7 100644
--- a/arch/mips/netlogic/lib/seclib/saesoc_gen2_hal_defs.h
+++ b/arch/mips/netlogic/lib/seclib/saesoc_gen2_hal_defs.h
@@ -37,7 +37,7 @@
 #define _SAESOC_GEN2_HAL_DEFS_H
 
 /* Common definitions are given in the below file */
-#include "saesoc_defs.h"
+#include "cryptosoc_lib.h"
 
 #ifdef SAESOC_PTYPE_GEN2_SUPPORT
 
@@ -303,6 +303,49 @@ static char saesoc_gen2_ivmode_name[][32] = {
 	"RESERVED"
 };
 
+enum saesoc_gen2_cipher_type {
+    SAESOC_GEN2_CIPHER_TYPE_AES_128 = 0x00,
+	SAESOC_GEN2_CIPHER_TYPE_AES_192 = 0x01,
+	SAESOC_GEN2_CIPHER_TYPE_AES_256 = 0x02,
+	SAESOC_GEN2_CIPHER_TYPE_CAMELLIA_128 = 0x04,
+	SAESOC_GEN2_CIPHER_TYPE_CAMELLIA_192 = 0x05,
+	SAESOC_GEN2_CIPHER_TYPE_CAMELLIA_256 = 0x06,
+	SAESOC_GEN2_CIPHER_BYPASS = 0x08,
+	SAESOC_GEN2_CIPHER_TYPE_KASUMI = 0x09,
+	SAESOC_GEN2_CIPHER_TYPE_SNOW3G = 0x0a,
+	SAESOC_GEN2_CIPHER_TYPE_ZUC = 0x0b,
+	SAESOC_GEN2_CIPHER_TYPE_DES = 0x0c,
+	SAESOC_GEN2_CIPHER_TYPE_TDES = 0x0d,
+	SAESOC_GEN2_CIPHER_TYPE_ARC4 = 0x0e,
+	SAESOC_GEN2_CIPHER_TYPE_MAX
+};
+
+enum saesoc_gen2_hash_type {
+	SAESOC_GEN2_HASH_TYPE_AES_128 = 0x00,
+	SAESOC_GEN2_HASH_TYPE_AES_192 = 0x01,
+	SAESOC_GEN2_HASH_TYPE_AES_256 = 0x02,
+	SAESOC_GEN2_HASH_TYPE_CAMELLIA_128 = 0x04,
+	SAESOC_GEN2_HASH_TYPE_CAMELLIA_192 = 0x05,
+	SAESOC_GEN2_HASH_TYPE_CAMELLIA_256 = 0x06,
+	SAESOC_GEN2_HASH_BYPASS = 0x08,
+	SAESOC_GEN2_HASH_TYPE_KASUMI = 0x09,
+	SAESOC_GEN2_HASH_TYPE_SNOW3G = 0x0a,
+	SAESOC_GEN2_HASH_TYPE_ZUC = 0x0b,
+	SAESOC_GEN2_HASH_TYPE_RABIN = 0x0c,
+	SAESOC_GEN2_HASH_TYPE_GHASH = 0x0d,
+	SAESOC_GEN2_HASH_TYPE_MD5 = 0x10,
+	SAESOC_GEN2_HASH_TYPE_SHA_1 = 0x11, 
+	SAESOC_GEN2_HASH_TYPE_SHA_224 = 0x12,
+	SAESOC_GEN2_HASH_TYPE_SHA_256 = 0x13,
+	SAESOC_GEN2_HASH_TYPE_SHA_384 = 0x14,
+	SAESOC_GEN2_HASH_TYPE_SHA_512 = 0x15,
+	SAESOC_GEN2_HASH_TYPE_SHA_512_224 = 0x16,
+	SAESOC_GEN2_HASH_TYPE_SHA_512_256 = 0x17,
+	SAESOC_GEN2_HASH_TYPE_MAX
+};
+
+
+
 /**
  * saesoc_gen2_dump_cdesc - Extract the control descriptors and dump the
  * 	 values
@@ -317,98 +360,98 @@ static void  saesoc_gen2_dump_cdesc(_uint64_t *cdescs, int ndescs)
 	_uint64_t cdesc1 = cdescs[1];
 
 
-	saesoc_dbg_print("\nCtrl Descriptor info:\n");
-	saesoc_dbg_print("  %-16s %-16s \n", "Desc0", "Desc1");
-	saesoc_dbg_print("  %-16llx %-16llx \n", cdesc0, cdesc1);
+	cryptosoc_dbg_print("\nCtrl Descriptor info:\n");
+	cryptosoc_dbg_print("  %-16s %-16s \n", "Desc0", "Desc1");
+	cryptosoc_dbg_print("  %-16llx %-16llx \n", cdesc0, cdesc1);
 
-	saesoc_dbg_print("\nHASH info:\n");
+	cryptosoc_dbg_print("\nHASH info:\n");
 
 	type = SAESOC_GEN2_GET_BITS(cdesc0, HASH_TYPE);
 	mode = SAESOC_GEN2_GET_BITS(cdesc0, HASH_MODE);
 	ivmode = SAESOC_GEN2_GET_BITS(cdesc0, HASH_IV_MODE);
 
-	saesoc_dbg_print("  %-16s %-16s %-16s \n", 
+	cryptosoc_dbg_print("  %-16s %-16s %-16s \n", 
 			"HashType", "HashMode", "HashIvMode");
-	saesoc_dbg_print("  %-4d%-8s     %-4d%-8s     %-4d%-8s \n",
+	cryptosoc_dbg_print("  %-4d%-8s     %-4d%-8s     %-4d%-8s \n",
 			type, saesoc_gen2_hash_type_name[type], 
 			mode, saesoc_gen2_hash_mode_name[mode], 
 			ivmode, saesoc_gen2_ivmode_name[ivmode]);
 
-	saesoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
+	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
 			"HashIvOff", "AadOff",  "HashMuteEn", "HashMuteSel");
-	saesoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld\n",
+	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld\n",
 			SAESOC_GEN2_GET_BITS(cdesc0, HASH_IV_OFFSET), 
 			SAESOC_GEN2_GET_BITS(cdesc0, AAD_OFFSET),
 			SAESOC_GEN2_GET_BITS(cdesc0, HASH_MUTE_MASK_ENABLE),
 			SAESOC_GEN2_GET_BITS(cdesc0, HASH_MUTE_MASK_SEL));
 
-	saesoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
+	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
 			"AddlHashLen","HashSrcSel", "HmacKeyLen", "HmacKeyPad");
-	saesoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld\n",
+	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld\n",
 			SAESOC_GEN2_GET_BITS(cdesc0, ADDL_HASH_LEN),
 			SAESOC_GEN2_GET_BITS(cdesc0, HASH_SRC_SEL), 
 			SAESOC_GEN2_GET_BITS(cdesc0, HMAC_KEY_LEN),
 			SAESOC_GEN2_GET_BITS(cdesc0, HMAC_HW_KEY_PAD_ENABLE));
 
-	saesoc_dbg_print("  %-16s %-16s\n", "HashL3Alloc", "HashClobber");
-	saesoc_dbg_print("  %-16lld %-16lld\n",
+	cryptosoc_dbg_print("  %-16s %-16s\n", "HashL3Alloc", "HashClobber");
+	cryptosoc_dbg_print("  %-16lld %-16lld\n",
 			SAESOC_GEN2_GET_BITS(cdesc0, HASH_L3_ALLOCATE), 
 			SAESOC_GEN2_GET_BITS(cdesc0, HASH_CLOBBER));
 
-	saesoc_dbg_print("  %-16s %-16s %-16s %-16s %-16s\n", 
+	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s %-16s\n", 
 			"Chktag", "TaginLoc", "TagoutLoc", "TagLen", "TagInoff");
-	saesoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld %-16lld\n",
+	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld %-16lld\n",
 			SAESOC_GEN2_GET_BITS(cdesc1, CHECK_TAG_ENABLE),  
 			SAESOC_GEN2_GET_BITS(cdesc1, TAG_IN_LOC_SEL),
 			SAESOC_GEN2_GET_BITS(cdesc1, TAG_OUT_LOC_SEL), 
 			SAESOC_GEN2_GET_BITS(cdesc1, TAG_LEN),
 			SAESOC_GEN2_GET_BITS(cdesc1, TAGIN_OFFSET));
 
-	saesoc_dbg_print("\nCIPHER info:\n");
+	cryptosoc_dbg_print("\nCIPHER info:\n");
 
 	type = SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_TYPE);
 	mode = SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_MODE);
 	ivmode = SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_IV_MODE);
 
-	saesoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
+	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
 			"CipherType", "CipherMode", "CipherIvMode", "CipherPadEn");
-	saesoc_dbg_print("  %-4d%-8s     %-4d%-8s     %-4d%-8s    %-16lld\n",
+	cryptosoc_dbg_print("  %-4d%-8s     %-4d%-8s     %-4d%-8s    %-16lld\n",
 			type, saesoc_gen2_cipher_type_name[type], 
 			mode, saesoc_gen2_cipher_mode_name[mode], 
 			ivmode, saesoc_gen2_ivmode_name[ivmode], 
 			SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_PAD_ENABLE));
 
-	saesoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
+	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
 			"CipherIvOff", "Encrypt", "Cfbmask", "Arc4Keylen");
-	saesoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld\n",
+	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld\n",
 			SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_IV_OFFSET),
 			SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_ENCRYPT),
 			SAESOC_GEN2_GET_BITS(cdesc1, CFB_MASK),
 			SAESOC_GEN2_GET_BITS(cdesc0, ARC4_KEY_LEN));
 
-	saesoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
+	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
 			"Arc4L3Alloc", "Pktl3Alloc", "PktClobber", "WrModify");
-	saesoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld\n",
+	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld\n",
 			SAESOC_GEN2_GET_BITS(cdesc0, ARC4_L3_ALLOCATE),	
 			SAESOC_GEN2_GET_BITS(cdesc0, DATA_OUT_L3_ALLOCATE),	
 			SAESOC_GEN2_GET_BITS(cdesc0, DATA_OUT_CLOBBER), 
 			SAESOC_GEN2_GET_BITS(cdesc0, WR_MODI_ONLY_EN));
 
-	saesoc_dbg_print("\nCOMMON info:\n");
+	cryptosoc_dbg_print("\nCOMMON info:\n");
 
-	saesoc_dbg_print("  %-16s %-16s %-16s\n", 
+	cryptosoc_dbg_print("  %-16s %-16s %-16s\n", 
 			"PayloadOff", "Rabin", "TLS");
-	saesoc_dbg_print("  %-16lld %-16lld %-16lld\n",
+	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld\n",
 			SAESOC_GEN2_GET_BITS(cdesc1, PAYLOAD_OFFSET), 
 			SAESOC_GEN2_GET_BITS(cdesc0, RABIN_FINGERPRINT),
 			SAESOC_GEN2_GET_BITS(cdesc0, TLS_ENABLE));
 	
 	if(ndescs > 2) {
 		int i;
-		saesoc_dbg_print("\nKey info:\n");
+		cryptosoc_dbg_print("\nKey info:\n");
 		for(i = 2; i < ndescs; i++)
-			saesoc_dbg_print("  <%-16llx>", cdescs[i]);
-		saesoc_dbg_print("\n");
+			cryptosoc_dbg_print("  <%-16llx>", cdescs[i]);
+		cryptosoc_dbg_print("\n");
 	}
 }
 
@@ -430,45 +473,45 @@ static void saesoc_gen2_dump_ddesc(_uint64_t *ddesc, int ndescs,
 
 	desc0 = ddesc[nd++];
 	desc1 = ddesc[nd++];
-	saesoc_dbg_print("\nData Descriptor info:\n");
-	saesoc_dbg_print("  %-16s %-16s \n", "Desc0", "Desc1");
-	saesoc_dbg_print("  %-16llx %-16llx \n", desc0, desc1);
+	cryptosoc_dbg_print("\nData Descriptor info:\n");
+	cryptosoc_dbg_print("  %-16s %-16s \n", "Desc0", "Desc1");
+	cryptosoc_dbg_print("  %-16llx %-16llx \n", desc0, desc1);
 
-	saesoc_dbg_print("  %-16s %-16s %-16s\n", 
+	cryptosoc_dbg_print("  %-16s %-16s %-16s\n", 
 			"PayloadLen", "CipherPadVal", "AadLen");
-	saesoc_dbg_print("  %-16lld %-16lld %-16lld\n",
+	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld\n",
 			SAESOC_GEN2_GET_BITS(desc0, PAYLOAD_LEN), 
 			SAESOC_GEN2_GET_BITS(desc0, CIPHER_PAD_VAL),
 			SAESOC_GEN2_GET_BITS(desc0, AADLEN));
 
-	saesoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
+	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
 			"Arc4SaveState", "PayloadBitCnt", "DesFbDst", "Tagaddr");
-	saesoc_dbg_print("  %-16lld %-16lld %-16lld %-16llx\n",
+	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16llx\n",
 			SAESOC_GEN2_GET_BITS(desc1, ARC4_SAVE_SATE_EN), 
 			SAESOC_GEN2_GET_BITS(desc1, PAY_LOAD_BIT_CNT),
 			SAESOC_GEN2_GET_BITS(desc1, DESC_FB_DEST_ID), 
 			SAESOC_GEN2_GET_BITS(desc1, TAG_DEST_ADDR));
 
 	if(hash_iv_mode == 1) {
-		saesoc_dbg_print("\nHash IV info:\n");
-		saesoc_dbg_print("  %-16s %-16s \n", "Desc0", "Desc1");
-		saesoc_dbg_print("  %-16llx %-16llx \n", ddesc[nd], ddesc[nd + 1]);
+		cryptosoc_dbg_print("\nHash IV info:\n");
+		cryptosoc_dbg_print("  %-16s %-16s \n", "Desc0", "Desc1");
+		cryptosoc_dbg_print("  %-16llx %-16llx \n", ddesc[nd], ddesc[nd + 1]);
 		nd += 2;
 	}
 
 	if(cipher_iv_mode == 1)  {
-		saesoc_dbg_print("\nCipher IV info:\n");
-		saesoc_dbg_print("  %-16s %-16s \n", "Desc0", "Desc1");
-		saesoc_dbg_print("  %-16llx %-16llx \n", ddesc[nd], ddesc[nd + 1]);
+		cryptosoc_dbg_print("\nCipher IV info:\n");
+		cryptosoc_dbg_print("  %-16s %-16s \n", "Desc0", "Desc1");
+		cryptosoc_dbg_print("  %-16llx %-16llx \n", ddesc[nd], ddesc[nd + 1]);
 		nd += 2;
 	}
 
 	for(i = nd; i<ndescs-ndesfb_descs; i++) {	
 		desc = ddesc[i];
-		saesoc_dbg_print("\nPacket Fragment info (ind %d Entry %llx):\n", i, desc);
-		saesoc_dbg_print("  %-16s %-16s %-16s %-16s %-16s\n", 
+		cryptosoc_dbg_print("\nPacket Fragment info (ind %d Entry %llx):\n", i, desc);
+		cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s %-16s\n", 
 				"DstFrag", "WriteFragDis", "LastFrag", "FragLen", "FragAddr");
-		saesoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld %-16llx\n",
+		cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld %-16llx\n",
 				SAESOC_GEN2_GET_BITS(desc, FRAG_TYPE), 
 				SAESOC_GEN2_GET_BITS(desc, WR_FRAG_DIS),
 				SAESOC_GEN2_GET_BITS(desc, LAST_SRC_DESC), 
@@ -476,12 +519,12 @@ static void saesoc_gen2_dump_ddesc(_uint64_t *ddesc, int ndescs,
 				SAESOC_GEN2_GET_BITS(desc, FRAG_ADDR));
 	}
 	if(ndesfb_descs) {
-		saesoc_dbg_print("\nDesigner Fb descs:\n");
+		cryptosoc_dbg_print("\nDesigner Fb descs:\n");
 		for(; (i < ndescs); i++) 
-			saesoc_dbg_print("  %-16llx", ddesc[i]);
-		saesoc_dbg_print("\n");
+			cryptosoc_dbg_print("  %-16llx", ddesc[i]);
+		cryptosoc_dbg_print("\n");
 	}
-	saesoc_dbg_print("\n");
+	cryptosoc_dbg_print("\n");
 }
 
 /**
@@ -490,25 +533,27 @@ static void saesoc_gen2_dump_ddesc(_uint64_t *ddesc, int ndescs,
  * @entry1: fmn entry1 message
  */
 
-static void saesoc_gen2_dump_fmnentry(_uint64_t entry0, _uint64_t entry1) 
+static inline void saesoc_gen2_dump_fmnentry(_uint64_t entry0, _uint64_t entry1) 
 {
-	saesoc_dbg_print("\nFmn Info entry0 %llx entry1 %llx\n",entry0, entry1);
-	saesoc_dbg_print("  %-16s %-16s %-16s %-16s %-16s \n", 
+	cryptosoc_dbg_print("\nFmn Info entry0 %llx entry1 %llx\n",entry0, entry1);
+	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s %-16s \n", 
 			"RegFb","DesFbEn", "DesFbLen", "CtrlDescLen", "CtrlDescAddr");
-	saesoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld %-16llx\n",
+	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld %-16llx\n",
 			SAESOC_GEN2_GET_BITS(entry0, REG_FB_DEST_ID), 
 			SAESOC_GEN2_GET_BITS(entry0, DESIGN_FB_EN),
 			SAESOC_GEN2_GET_BITS(entry0, DESIGN_FB_LEN), 
 			SAESOC_GEN2_GET_BITS(entry0, CTRL_DESC_LEN),
-			SAESOC_GEN2_GET_BITS(entry0, CTRL_DESC_ADDR));
+			(SAESOC_GEN2_GET_BITS(entry0, CTRL_DESC_ADDR) << 
+			 		CRYPTOSOC_CACHELINE_SHIFT));
 
-	saesoc_dbg_print("  %-16s %-16s %-16s %-16s \n", 
+	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s \n", 
 			"Arc4StateLdEn", "PktIvLenDW", "PktDescLen", "PktDescAddr");
-	saesoc_dbg_print("  %-16lld %-16lld %-16lld %-16llx \n",
+	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16llx \n",
 			SAESOC_GEN2_GET_BITS(entry1, ARC4_STATE_LD_EN), 
 			SAESOC_GEN2_GET_BITS(entry1, PKT_IV_LEN),
 			SAESOC_GEN2_GET_BITS(entry1, PKT_DESC_LEN), 
-			SAESOC_GEN2_GET_BITS(entry1, PKT_DESC_ADDR));
+			(SAESOC_GEN2_GET_BITS(entry1, PKT_DESC_ADDR) << 
+			 CRYPTOSOC_CACHELINE_SHIFT));
 
 }
 
@@ -589,6 +634,27 @@ static void saesoc_gen2_dump_fmnentry(_uint64_t entry0, _uint64_t entry1)
 	    SAESOC_GEN2_SET_BITS(iv_mode, CIPHER_IV_MODE);	\
 	}
 
+/**
+ * saesoc_gen2_set_hash_bypass - Set the control descriptor with 
+ * 	Hash bypass
+ * @cdesc0        : ctrl Descriptor 0 
+ */
+#define saesoc_gen2_set_hash_bypass(cdesc0) {	\
+	 _uint64_t mask = SAESOC_GEN2_SET_MASK(HASH_TYPE); \
+	cdesc0 = cdesc0 & ~mask;					\
+	cdesc0 = cdesc0 | SAESOC_GEN2_SET_BITS(SAESOC_GEN2_HASH_BYPASS, HASH_TYPE); \
+}
+
+/**
+ * saesoc_gen2_set_cipher_bypass - Set the control descriptor with 
+ *  Cipher bypass
+ * @cdesc0        : ctrl Descriptor 0 
+ */
+#define saesoc_gen2_set_cipher_bypass(cdesc1) {	\
+	 _uint64_t mask = SAESOC_GEN2_SET_MASK(CIPHER_TYPE); \
+	cdesc1 = cdesc1 & ~mask;					\
+	cdesc1 = cdesc1 | SAESOC_GEN2_SET_BITS(SAESOC_GEN2_CIPHER_BYPASS, CIPHER_TYPE); \
+}
 
 /**
  * saesoc_gen2_set_arc4_param - Set the control descriptor with ARC4 
diff --git a/arch/mips/netlogic/lib/seclib/saesoc_lib.c b/arch/mips/netlogic/lib/seclib/saesoc_lib.c
deleted file mode 100644
index c99064a..0000000
--- a/arch/mips/netlogic/lib/seclib/saesoc_lib.c
+++ /dev/null
@@ -1,206 +0,0 @@
-/*-
- * Copyright (c) 2003-2012 Broadcom Corporation
- * All Rights Reserved
- *
- * This software is available to you under a choice of one of two
- * licenses.  You may choose to be licensed under the terms of the GNU
- * General Public License (GPL) Version 2, available from the file
- * http://www.gnu.org/licenses/gpl-2.0.txt  
- * or the Broadcom license below:
-
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_4# */
-
-/**
-* DOC: Crypto Library API Design approach
-* 
-* The library has been implemented as 3 layers: Crypto-HAL, Crypto Abstraction and
-* Crypto Protocol Specific library.  
-*
-* The details of these API layers are described below.
-*/
-
-/**
-* DOC: Crypto HAL Library
-*
-* Crypto HAL library provides SAE engine direct interface APIs. Here the API 
-* definitions will differ depending on the processor type. Applications that 
-* are going to work only on a particular processor type can make use these APIs.
-*/
-
-/**
-* DOC: Crypto Abstraction Library
-*
-* This layer will abstract the crypto engine. This will internally calls the 
-* Crypto hal library depending on the processor type.
-*
-* These APIs support generic crypto operations and will not change from one 
-* chip to another. Applications should use this layer extensively
-*
-* Some of the APIs to support a few chip features in software (for older chips)
-* can be part of this layer
-*
-* Session and data descriptor formation will be handled transparently
-*
-* Most of the crypto operation input parameters will be taken during session 
-* creation which is one time operation. 
-*
-* Per operation parameters will be taken in the fast path APIs. These fast 
-* path APIs will take few most common input parameters and modify APIs will be 
-* provided for other parameters that can be modified for each operation 
-* (Note: Griffin and Eagle vary here a lot)
-*
-* During init time, a bitmask of all fields that can be modified on a per 
-* packet (operation) basis will be returned based on the chip type. 
-* Ex: for griffin, AAD length, payload bit count etc. For eagle, this will be 
-* IV length, IV offset etc.
-*
-* Another bit mask of all the CHIP capabilities will be returned: Following 
-* are examples of some chip capabilities:
-*  ZUC
-*  3DES Key swap
-*  Tag Compare result
-*  Tag truncation
-*  HASH muting 
-*
-* Applications that intend to be generic should make use of these flags and 
-* call appropriate APIs only if the feature is supported
-*/
-
-/**
-* DOC: Crypto Abstraction Library User defines
-*
-* The library code is kept under GEN1(ex : xlp, storm) or GEN2(Ex:Griffin)
-* macros. This can be specified at compile time. 
-*
-* The library can be compiled for all the processor versions(GEN_ALL) or for a 
-* specified version(GEN1, GEN2). 
-*
-* If the library is compiled for (GEN_ALL), then it internally read the 
-*  processor type and calls the appropriate HAL apis.  
-*
-* If the library is compiled  only for GEN1/GEN2, then only those specific code 
-* will be executed.(No runtime checks)
-*
-*
-* This library is expecting the following macros to be defined by the 
-* application. The library code includes an application provided file named 
-* saesoc_lib_ifc.h. User should define the following parameters in that. 
-* 
-* _uint64_t saesoc_virt_to_phys(unsigned long vaddr): 
-*   Return the physical address corresponding to the given virtual address.
-*
-* unsigned long saesoc_phys_to_virt(_uint64_t paddr):
-*   Return the virtual address corresponding to the given physical address.
-*
-* SAESOC_SESSION_DESC_APP_PRIV_SZ:
-*   Application private data size in the session descriptor. Should be 
-*   multiple of cachelines.
-*
-* SAESOC_DATA_DESC_APP_PRIV_SZ:
-*   Application private data size in the data descriptor. Should be 
-*   multiple of cachelines.
-*
-* Also the application should register the following callback routines using 
-* the api saesoc_lib_init()
-*
-* a. mem_alloc:  Returns physically contiguous memory 
-*
-* b. mem_free: To free the memory allocated using mem_alloc routine             
-* 
-*/
-
-/**
-* DOC: Crypto Protocol Specific Library
-*
-* This layer provides helper functions which are protocol specific such as IPSEC, SSL etc. 
-* For example, the CCM implementation requires the B0, B1 blocks to be created by the 
-* application before giving to the engine, so that any applications can make use of that 
-* instead of duplicating the code. 
-*
-* Similarly SSL specific padding which is not supported by the engine can make use of the APIs 
-* implemented as part of this library
-*
-*/
-
-
-#include "saesoc_defs.h"
-
-int saesoc_ptype_gen;
-int saesoc_base_vc;
-saesoc__app_lib_init *saesoc_app_lib_init;
-saesoc__mem_alloc *saesoc_mem_alloc;
-saesoc__mem_free *saesoc_mem_free;
-
-
-static int saesoc_get_ptype_gen()
-{
-	/* TODO , Look at the processor type and return the value */
-	saesoc_base_vc = 0;
-	return SAESOC_PTYPE_IS_GEN2;
-}
-
-/**
-* saesoc_lib_init - Initialize the sae soc library params based on the 
-* 	processor type.
-* @params: Pointer to lib param structure(output) 
-* @mem_alloc: Function pointer to allocate physically contiguous memory
-*    This should return memory pointer in success.(input)
-* @mem_free: Function to free the memory.(input)
-* @arg: For future use
-*
-* This should be called once from every application which is intended 
-* to use this library. This function fills the params struct and returned
-* to the user. 
-*
-* Return: SAESOC_OK, SAESOC_EINVAL
-*/
-int saesoc_lib_init(struct saesoc_lib_params *params, 
-		void *(mem_alloc)(size_t align, size_t size),
-		void (mem_free)(void *ptr),
-		void *arg)
-{
-	/* return error if callbacks are not provided */
-	if(!mem_alloc  || !mem_free) {
-			saesoc_err_print("%s:%d, Lib callbacks are not registered\n", 
-					__FUNCTION__, __LINE__);
-			return -SAESOC_EINVAL;
-	}
-	saesoc_mem_alloc = mem_alloc;
-	saesoc_mem_free	= mem_free;
-
-	saesoc_ptype_gen = saesoc_get_ptype_gen();
-	if(saesoc_ptype_gen == SAESOC_PTYPE_IS_GEN2) {
-		/* for griffin and associated versions */
-		params->feature_set = SAESOC_FF_GEN2_PTYPE;
-		params->per_pkt_update_set = 0;
-	} else { 
-		/* For eagle and associated versions */
-		params->feature_set = SAESOC_FF_GEN1_PTYPE;
-		/* TODO : If xlp 3xx add zuc support */
-		params->per_pkt_update_set = SAESOC_PER_PKT_UF_GEN1_PTYPE;
-	}
-	return SAESOC_OK;
-}
diff --git a/arch/mips/netlogic/lib/seclib/saesoc_lib.h b/arch/mips/netlogic/lib/seclib/saesoc_lib.h
index 0ff8300..dbf81f8 100644
--- a/arch/mips/netlogic/lib/seclib/saesoc_lib.h
+++ b/arch/mips/netlogic/lib/seclib/saesoc_lib.h
@@ -36,17 +36,18 @@
 #ifndef _SAESOC_LIB_H
 #define _SAESOC_LIB_H
 
-#include <string.h>
-
 /* Include file for application specific macros */
-#include "saesoc_defs.h"
-#include "saesoc_lib_ifc.h"
+#include "cryptosoc_lib.h"
+#include "cryptosoc_lib_ifc.h"
+#include "cryptosoc_ctx.h"
 
 #ifdef SAESOC_PTYPE_GEN_ALL_SUPPORT
-#define SAESOC_PTYPE_GEN2_SUPPORT	 1
-#define SAESOC_PTYPE_GEN1_SUPPORT	 1
+#define SAESOC_PTYPE_GEN2_SUPPORT
+#define SAESOC_PTYPE_GEN1_SUPPORT
 #endif
 
+#include "saesoc_defs.h"
+
 /* Include file for processor specific macros to set the descriptors. 
 *  hal macros should be after _ifc.h(Because of -GEN2- en/dis */
 #ifdef SAESOC_PTYPE_GEN2_SUPPORT
@@ -59,16 +60,33 @@
 
 
 #ifdef SAESOC_PTYPE_GEN_ALL_SUPPORT
-#define IF_SAESOC_PTYPE_IS_GEN1 if(saesoc_ptype_gen == SAESOC_PTYPE_IS_GEN1)
-#define IF_SAESOC_PTYPE_IS_GEN2 if(saesoc_ptype_gen == SAESOC_PTYPE_IS_GEN2)
+#define IF_SAESOC_PTYPE_IS_GEN1 if(cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN1)
+#define IF_SAESOC_PTYPE_IS_GEN2 if(cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2)
 #else
 #define IF_SAESOC_PTYPE_IS_GEN1
 #define IF_SAESOC_PTYPE_IS_GEN2 
 #endif
 
-#if defined(__mips__)
 #include "nlm_hal_fmn.h"
-#endif
+
+/**
+* DOC: SAESOC
+*
+* These APIs abstract the SAE SOC present in the processor.
+*
+* The below macros should be defined by the application. 
+* 
+* SAESOC_SESSION_DESC_APP_PRIV_SZ:
+*   Application private data size in the session descriptor. Should be 
+*   multiple of cachelines.
+*
+* SAESOC_DATA_DESC_APP_PRIV_SZ:
+*   Application private data size in the data descriptor. Should be 
+*   multiple of cachelines.
+*
+* Processor type : Either SAESOC_PTYPE_GEN_ALL_SUPPORT or 
+*  SAESOC_PTYPE_GEN2_SUPPORT/SAESOC_PTYPE_GEN1_SUPPORT
+*/
 
 /* local session, data private info. The structure size 
 *  should be below the PRIV_SZ macros. */
@@ -83,13 +101,13 @@ struct saesoc_sdesc_priv_data {
 	/* data descriptor starting fragment index - 
 	*  based on the ivdescs count */
 	int frag_idx;
-	int aad_len;
+	int addl_hash_len;
 	_uint64_t ddesc[6]; /* valid for gen1 only */
 };
 
 #define SAESOC_SESSION_DESC_LIB_PRIV_SZ \
-	(((sizeof(struct saesoc_sdesc_priv_data) / SAESOC_CACHELINE_SZ) + 1) * \
-		SAESOC_CACHELINE_SZ)
+	(((sizeof(struct saesoc_sdesc_priv_data) / CRYPTOSOC_CACHELINE_SZ) + 1) * \
+		CRYPTOSOC_CACHELINE_SZ)
 
 
 struct saesoc_ddesc_priv_data {
@@ -103,59 +121,13 @@ struct saesoc_ddesc_priv_data {
 };
 
 #define SAESOC_DATA_DESC_LIB_PRIV_SZ \
-	 (((sizeof(struct saesoc_ddesc_priv_data) / SAESOC_CACHELINE_SZ) + 1) * \
-	          SAESOC_CACHELINE_SZ)
-
-
-extern saesoc__mem_alloc *saesoc_mem_alloc;
-extern saesoc__mem_free *saesoc_mem_free;
-extern int saesoc_ptype_gen;
-extern int saesoc_base_vc;
-extern int saesoc_lib_init(struct saesoc_lib_params *params, 
-		void *(mem_alloc)(size_t align, size_t size),
-		void (mem_free)(void *ptr),
-		void *arg);
-
-#if !defined(__mips__)
-extern int saesoc_gen2_msg_send(_uint64_t fmnentry0, 
-		_uint64_t fmnentry1, _uint64_t fmnentry2);
-extern int saesoc_gen1_msg_send(_uint64_t fmnentry0, 
-		_uint64_t fmnentry1, _uint64_t fmnentry2);
-#endif
-/**
-* enum saesoc_cipher_type - Supported cipher types
-* @SAESOC_CIPHER_TYPE_AES_128: Cipher type is AES 128
-* @SAESOC_CIPHER_TYPE_AES_192: Cipher type is AES 192
-* @SAESOC_CIPHER_TYPE_AES_256: Cipher type is AES 256
-* @SAESOC_CIPHER_TYPE_CAMELLIA_128: Cipher type is Camellia 128
-* @SAESOC_CIPHER_TYPE_CAMELLIA_192: Cipher type is Camellia 192
-* @SAESOC_CIPHER_TYPE_CAMELLIA_256: Cipher type is Camellia 256
-* @SAESOC_CIPHER_BYPASS: No Cipher operation
-* @SAESOC_CIPHER_TYPE_KASUMI: Cipher type is Kasumi
-* @SAESOC_CIPHER_TYPE_SNOW3G: Cipher type is Snow3G
-* @SAESOC_CIPHER_TYPE_ZUC: Cipher type is ZUC
-* @SAESOC_CIPHER_TYPE_DES: Cipher type is DES
-* @SAESOC_CIPHER_TYPE_TDES: Cipher type is TDES
-* @SAESOC_CIPHER_TYPE_ARC4: Cipher type is ARC4
-* @SAESOC_CIPHER_TYPE_MAX: End of cipher type
-*/
+	 (((sizeof(struct saesoc_ddesc_priv_data) / CRYPTOSOC_CACHELINE_SZ) + 1) * \
+	          CRYPTOSOC_CACHELINE_SZ)
+
+#define saesoc_get_cacheline_phys_addr(x) \
+	(cryptosoc_virt_to_phys((_uint64_t)(unsigned long)x) >> CRYPTOSOC_CACHELINE_SHIFT)
+
 
-enum saesoc_cipher_type {
-	SAESOC_CIPHER_TYPE_AES_128 = 0x00,
-	SAESOC_CIPHER_TYPE_AES_192 = 0x01,
-	SAESOC_CIPHER_TYPE_AES_256 = 0x02,
-	SAESOC_CIPHER_TYPE_CAMELLIA_128 = 0x04,
-	SAESOC_CIPHER_TYPE_CAMELLIA_192 = 0x05,
-	SAESOC_CIPHER_TYPE_CAMELLIA_256 = 0x06,
-	SAESOC_CIPHER_BYPASS = 0x08,
-	SAESOC_CIPHER_TYPE_KASUMI = 0x09,
-	SAESOC_CIPHER_TYPE_SNOW3G = 0x0a,
-	SAESOC_CIPHER_TYPE_ZUC = 0x0b,
-	SAESOC_CIPHER_TYPE_DES = 0x0c,
-	SAESOC_CIPHER_TYPE_TDES = 0x0d,
-	SAESOC_CIPHER_TYPE_ARC4 = 0x0e,
-	SAESOC_CIPHER_TYPE_MAX
-};
 
 #ifdef SAESOC_PTYPE_GEN1_SUPPORT
 /* saesoc_gen1_cipher_table_map for generation 1 chip sets */
@@ -175,38 +147,7 @@ static int saesoc_gen1_cipher_table_map[SAESOC_CIPHER_TYPE_MAX+1] = {
 	[SAESOC_CIPHER_TYPE_ARC4] = 0x6,
 	[SAESOC_CIPHER_TYPE_MAX] = 0xf
 };
-#endif
-
-/*
-* enum saesoc_cipher_modes - Supported cipher modes
-* @SAESOC_CIPHER_MODE_ECB: Cipher mode is ECB
-* @SAESOC_CIPHER_MODE_CBC: Cipher mode is CBC
-* @SAESOC_CIPHER_MODE_CFB: Cipher mode is CFB
-* @SAESOC_CIPHER_MODE_OFB: Cipher mode is OFB
-* @SAESOC_CIPHER_MODE_CTR: Cipher mode is Counter
-* @SAESOC_CIPHER_MODE_AES_F8: Cipher mode is AES F8
-* @SAESOC_CIPHER_MODE_LRW: Cipher mode is LRW
-* @SAESOC_CIPHER_MODE_XTS: Cipher mode is XTS
-* @SAESOC_CIPHER_MODE_CCM: Cipher mode is CCM
-* @SAESOC_CIPHER_MODE_GCM: Cipher mode is GCM
-* @SAESOC_CIPHER_MODE_MAX: End of cipher mode
-*/
-
-enum saesoc_cipher_mode {
-	SAESOC_CIPHER_MODE_ECB = 0x00,
-	SAESOC_CIPHER_MODE_CBC = 0x01,
-	SAESOC_CIPHER_MODE_CFB = 0x02,
-	SAESOC_CIPHER_MODE_OFB = 0x03,
-	SAESOC_CIPHER_MODE_CTR = 0x04,
-	SAESOC_CIPHER_MODE_AES_F8 = 0x05,
-	SAESOC_CIPHER_MODE_LRW = 0x06,
-	SAESOC_CIPHER_MODE_XTS = 0x07,
-	SAESOC_CIPHER_MODE_CCM = 0x08,
-	SAESOC_CIPHER_MODE_GCM = 0x09,
-	SAESOC_CIPHER_MODE_MAX
-};
 
-#ifdef SAESOC_PTYPE_GEN1_SUPPORT
 /* saesoc_gen1_cipher_mode_map for generation 1 chip sets */
 static int saesoc_gen1_cipher_mode_map[SAESOC_CIPHER_MODE_MAX+1] ={
 	[SAESOC_CIPHER_MODE_ECB] = 0x0,
@@ -221,59 +162,7 @@ static int saesoc_gen1_cipher_mode_map[SAESOC_CIPHER_MODE_MAX+1] ={
 	[SAESOC_CIPHER_MODE_GCM] = 0x6,
 	[SAESOC_CIPHER_MODE_MAX] = 0xc,
 };
-#endif
-
-/*
-* enum saesoc_hash_type - Supported hash types
-*
-* @SAESOC_HASH_TYPE_AES_128: Hash type is AES 128
-* @SAESOC_HASH_TYPE_AES_192: Hash type is AES 192
-* @SAESOC_HASH_TYPE_AES_256: Hash type is AES 256
-* @SAESOC_HASH_TYPE_CAMELLIA_128: Hash type is Camellia 128
-* @SAESOC_HASH_TYPE_CAMELLIA_192: Hash type is Camellia 192
-* @SAESOC_HASH_TYPE_CAMELLIA_256: Hash type is Camellia 256
-* @SAESOC_HASH_BYPASS: No hash operation
-* @SAESOC_HASH_TYPE_KASUMI: Hash type is Kasumi
-* @SAESOC_HASH_TYPE_SNOW3G: Hash type is Snow3G
-* @SAESOC_HASH_TYPE_ZUC: Hash type is ZUC
-* @SAESOC_HASH_TYPE_RABIN: Hash type is RABIN
-* @SAESOC_HASH_TYPE_GHASH: Hash type is GHASH
-* @SAESOC_HASH_TYPE_MD5: Hash type is MD5
-* @SAESOC_HASH_TYPE_SHA_1: Hash type is SHA-1
-* @SAESOC_HASH_TYPE_SHA_224: Hash type is SHA-224
-* @SAESOC_HASH_TYPE_SHA_256: Hash type is SHA-256
-* @SAESOC_HASH_TYPE_SHA_384: Hash type is SHA-384
-* @SAESOC_HASH_TYPE_SHA_512: Hash type is SHA-512
-* @SAESOC_HASH_TYPE_SHA_512_224: Hash type is SHA-512/224
-* @SAESOC_HASH_TYPE_SHA_512_256: Hash type is SHAR-512/256
-* @SAESOC_HASH_TYPE_MAX : End of Hash type 
-*/
-
-enum saesoc_hash_type {
-	SAESOC_HASH_TYPE_AES_128 = 0x00,
-	SAESOC_HASH_TYPE_AES_192 = 0x01,
-	SAESOC_HASH_TYPE_AES_256 = 0x02,
-	SAESOC_HASH_TYPE_CAMELLIA_128 = 0x04,
-	SAESOC_HASH_TYPE_CAMELLIA_192 = 0x05,
-	SAESOC_HASH_TYPE_CAMELLIA_256 = 0x06,
-	SAESOC_HASH_BYPASS = 0x08,
-	SAESOC_HASH_TYPE_KASUMI = 0x09,
-	SAESOC_HASH_TYPE_SNOW3G = 0x0a,
-	SAESOC_HASH_TYPE_ZUC = 0x0b,
-	SAESOC_HASH_TYPE_RABIN = 0x0c,
-	SAESOC_HASH_TYPE_GHASH = 0x0d,
-	SAESOC_HASH_TYPE_MD5 = 0x10,
-	SAESOC_HASH_TYPE_SHA_1 = 0x11, 
-	SAESOC_HASH_TYPE_SHA_224 = 0x12,
-	SAESOC_HASH_TYPE_SHA_256 = 0x13,
-	SAESOC_HASH_TYPE_SHA_384 = 0x14,
-	SAESOC_HASH_TYPE_SHA_512 = 0x15,
-	SAESOC_HASH_TYPE_SHA_512_224 = 0x16,
-	SAESOC_HASH_TYPE_SHA_512_256 = 0x17,
-	SAESOC_HASH_TYPE_MAX
-};
 
-#ifdef SAESOC_PTYPE_GEN1_SUPPORT
 /* saesoc_gen1_hash_type_map for generation 1 chip sets */
 static int saesoc_gen1_hash_type_map[SAESOC_HASH_TYPE_MAX +1] = {
 	[SAESOC_HASH_TYPE_AES_128] = 0x4,
@@ -298,41 +187,22 @@ static int saesoc_gen1_hash_type_map[SAESOC_HASH_TYPE_MAX +1] = {
 	[SAESOC_HASH_TYPE_SHA_512_256] = 0x00,
 	[SAESOC_HASH_TYPE_MAX] = 0xff,
 };
-#endif
 
-/*
-* enum saesoc_gen2_hash_mode - Supported hash modes
-*
-* @SAESOC_HASH_MODE_CMAC: Hash mode is CMAC 
-* @SAESOC_HASH_MODE_CBC: Hash mode is CBC
-* @SAESOC_HASH_MODE_XCBC: Hash mode is XCBC
-* @SAESOC_HASH_MODE_HMAC: Hash mode is HMAC
-* @SAESOC_HASH_MODE_RABIN_TERMINATION: Hash mode is RABIN TERMINATION
-* @SAESOC_HASH_MODE_CCM: Hash mode is CCM
-* @SAESOC_HASH_MODE_GCM: Hash mode is GCM
-* @SAESOC_HASH_MODE_MAX: End of hash mode
-*/
-enum saesoc_hash_mode {
-	SAESOC_HASH_MODE_CMAC = 0x00,
-	SAESOC_HASH_MODE_CBC = 0x01,
-	SAESOC_HASH_MODE_XCBC = 0x02,
-	SAESOC_HASH_MODE_HMAC = 0x04,
-	SAESOC_HASH_MODE_RABIN_TERMINATION = 0x05,
-	SAESOC_HASH_MODE_CCM = 0x08,
-	SAESOC_HASH_MODE_GCM = 0x09,
-	SAESOC_HASH_MODE_MAX
-};
-
-#ifdef SAESOC_PTYPE_GEN1_SUPPORT
 /* saesoc_gen1_hash_mode for generation 1 chip sets */
-static int saesoc_gen1_hash_mode[SAESOC_HASH_MODE_MAX+1] = {
+static int saesoc_gen1_hash_mode[SAESOC_HASH_TYPE_MAX+1] = {
 	[SAESOC_HASH_MODE_CMAC] = 0x05,
 	[SAESOC_HASH_MODE_CBC] = 0x07,
 	[SAESOC_HASH_MODE_XCBC] = 0x06,
 	[SAESOC_HASH_MODE_RABIN_TERMINATION] = 0x0a,
 	[SAESOC_HASH_MODE_CCM] = 0x08,
 	[SAESOC_HASH_MODE_GCM] = 0x09,
-	[SAESOC_HASH_MODE_MAX] = 0x0a
+	[SAESOC_HASH_TYPE_ZUC] = 0x00, 
+	[SAESOC_HASH_TYPE_MD5] = 0x00,
+	[SAESOC_HASH_TYPE_SHA_1] = 0x00,
+	[SAESOC_HASH_TYPE_SHA_224] = 0x01,
+	[SAESOC_HASH_TYPE_SHA_256] = 0x02,
+	[SAESOC_HASH_TYPE_SHA_384] = 0x03,
+	[SAESOC_HASH_TYPE_SHA_512] = 0x04,
 };
 
 /* max iv size */
@@ -342,16 +212,18 @@ static int saesoc_iv_size[0xf][0xf] =
 	/* AES128 */	{   0,    16,   16,  16,    6,   16,     16,  16,   0,   0,  16,   16},
 	/* AES192 */	{   0,    16,   16,  16,    16,  16,     16,  16,   0,   0,  16,   16},
 	/* AES256 */	{   0,    16,   16,  16,    16,  16,     16,  16,   0,   0,  16,   16},
+	/* NONE */	{   0,     0,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
 	/* CAMELLIA128*/{   0,    16,   16,  16,    16,  16,     16,  16,   0,   0,  -1,   16},
 	/* CAMELLIA192*/{   0,    16,   16,  16,    16,  16,     15,  16,   0,   0,  -1,   16},
 	/* CAMELLIA256*/{   0,    16,   16,  16,    16,  16,     16,  16,   0,   0,  -1,   16},
-	/* BYPASS */	{   0,    0,     0,   0,    0,   0,      0,   0,    0,   0,   0,    0},
-	/* KASUMIF8*/  	{   0,    0,     0,   0,    0,   0,      0,   0,    0,   0,   0,    0},
-	/* SNOW3G F8 */ {   0,    0,     0,   0,    0,   0,      0,   0,    0,   0,   0,    0},
-	/* BYPASS */	{   0,    0,     0,   0,    0,   0,      0,   0,    0,   0,   0,    0},
-	/* DES */   	{   0,    8,     0,   0,    0,   0,      0,   0,    0,   0,   0,    0},
-	/* 3DES */  	{   0,    8,     0,   0,    0,   0,      0,   0,    0,   0,   0,    0},
-	/* ARC4 */  	{   0,    0,     0,   0,    0,   0,      0,   0,    0,   0,   0,    0},
+	/* NONE */	{   0,     0,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
+	/* BYPASS */	{   0,     0,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
+	/* KASUMIF8*/  	{   0,     0,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
+	/* SNOW3G F8 */ {   0,     0,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
+	/* ZUC */	{  16,     0,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
+	/* DES */   	{   0,     8,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
+	/* 3DES */  	{   0,     8,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
+	/* ARC4 */  	{   0,     0,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
 };
 
 /* max tag size */
@@ -360,21 +232,25 @@ static int saesoc_gen1_tag_len[SAESOC_HASH_TYPE_MAX]= {
 /* AES128 */		16,
 /* AES192 */		24,
 /* AES256 */		32,
+/* BYPASS */		0, 
 /* CAMELLIA128 */	16,
 /* CAMELLIA192 */	24,
 /* CAMELLIA256 */	32,
 /* BYPASS */		0, 
-/* KASUMI_F9 */		16,
-/* SNOW3G_F9 */		16,
 /* BYPASS */		0,
+/* KASUMI_F9 */		32,
+/* SNOW3G_F9 */		32,
+/* ZUC */		32,
+/* RABIN */		0,
+/* GHASH */		0,
 /* BYPASS */		0,
 /* BYPASS */		0,
-/* MD5 */		64,
-/* SHA_1 */		64,
-/* SHA_224 */		64, 
+/* MD5 */		128,
+/* SHA_1 */		160,
+/* SHA_224 */		224, 
 /* SHA_256 */		64,
-/* SHA_384 */		128,
-/* SHA_512 */		128,
+/* SHA_384 */		384,
+/* SHA_512 */		512,
 /* 3 */			0, 
 /* GHASH */		0,  //todo:
 };
@@ -465,7 +341,7 @@ struct saesoc_session_desc {
 		char lib_priv[SAESOC_SESSION_DESC_LIB_PRIV_SZ]; 
 		char app_priv[SAESOC_SESSION_DESC_APP_PRIV_SZ];
 		_uint64_t descs[0]; 
-} ___saesoc_cacheline_aligned;
+} ___cryptosoc_cacheline_aligned;
 
 
 /**
@@ -483,24 +359,17 @@ struct saesoc_data_desc {
 		char lib_priv[SAESOC_DATA_DESC_LIB_PRIV_SZ]; 
 		char app_priv[SAESOC_DATA_DESC_APP_PRIV_SZ]; 
 		_uint64_t descs[0]; 
-} ___saesoc_cacheline_aligned;
+} ___cryptosoc_cacheline_aligned;
 
-/**
-* struct saesoc_rsp_value - Crypto engine result 
-* @rsp: Result value is copied here 
-*/
-struct saesoc_rsp_value {
-	int rsp;
-};
 
 /**
 *  struct saesoc_extra_req_send_params:Extra parameters during request send 
 *  @arc4_load_state: Load the ARC4 state before the operation
-*  @arg: User given freeback argument
+*  @async_rsp_arg: User given callback argument, used in async mode only
 */
 struct saesoc_extra_req_send_params {
 	int arc4_load_state; /* 1 or 0 */
-	_uint64_t arg;
+	_uint64_t async_rsp_arg;
 };
 
 
@@ -511,7 +380,7 @@ struct saesoc_extra_req_send_params {
 * @initp: Initialization parameters filled(input)
 * @arg: For future use
 *
-* Return: Descriptor count, SAESOC_EINVAL
+* Return: Descriptor count, CRYPTOSOC_EINVAL
 */
 
 static inline int saesoc_calc_sdesc_cnt(
@@ -520,18 +389,18 @@ static inline int saesoc_calc_sdesc_cnt(
 {
 	int ndescs;
 	if(!initp)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 	
 #ifdef SAESOC_PTYPE_GEN2_SUPPORT
 	IF_SAESOC_PTYPE_IS_GEN2
 	{
 		ndescs = 2; /* initial descriptors */
 		if(initp->cipher.type != SAESOC_CIPHER_BYPASS) {
-			ndescs += (saesoc_roundup(initp->cipher.key_len, 
+			ndescs += (cryptosoc_roundup(initp->cipher.key_len, 
 						sizeof(_uint64_t))) / sizeof(_uint64_t);
 		}
 		if(initp->hash.type != SAESOC_HASH_BYPASS) {
-			ndescs += (saesoc_roundup(initp->hash.key_len, 
+			ndescs += (cryptosoc_roundup(initp->hash.key_len, 
 						sizeof(_uint64_t))) / sizeof(_uint64_t);
 		}
 		return ndescs;
@@ -542,18 +411,18 @@ static inline int saesoc_calc_sdesc_cnt(
 	{
 		ndescs = 1; /* initial descriptors */
 		if(initp->cipher.type != SAESOC_CIPHER_BYPASS) {
-			ndescs += (saesoc_roundup(initp->cipher.key_len, 
+			ndescs += (cryptosoc_roundup(initp->cipher.key_len, 
 						sizeof(_uint64_t))) / sizeof(_uint64_t);
 		}
 		if(initp->hash.type != SAESOC_HASH_BYPASS) {
-			ndescs += (saesoc_roundup(initp->hash.key_len, 
+			ndescs += (cryptosoc_roundup(initp->hash.key_len, 
 						sizeof(_uint64_t))) / sizeof(_uint64_t);
 		}
 		return ndescs;
 	
 	}
 #endif
-	return -SAESOC_EINVAL;
+	return -CRYPTOSOC_EINVAL;
 }
 
 /**
@@ -568,7 +437,7 @@ static inline int saesoc_calc_sdesc_cnt(
 * Note: Freeing of the session descriptor after use should be taken care by the 
 * application even if it is allocated by the API. 
 *
-* Returns: SAESOC_OK, SAESOC_EINVAL, SAESOC_ENOMEM, SAESOC_ENOSPACE
+* Returns: CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM, CRYPTOSOC_ENOSPACE
 */
 
 static inline int saesoc_new_session(
@@ -583,11 +452,11 @@ static inline int saesoc_new_session(
 	struct saesoc_session_desc  *sd;
 
 	if(!initp || !sdesc)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 
 	dcnt = saesoc_calc_sdesc_cnt(initp, NULL);
 	if(dcnt < 0) {
-		saesoc_err_print("%s:%d, Error - New session failed, err %d\n", 
+		cryptosoc_err_print("%s:%d, Error - New session failed, err %d\n", 
 				__FUNCTION__, __LINE__, dcnt);
 		return dcnt;
 	}
@@ -595,26 +464,26 @@ static inline int saesoc_new_session(
 	/* The number of descriptors given is less than what 
 	*  is required for the specified hash/cipher type */
 	if((*sdesc != NULL) && (dcnt > ndescs)) {
-		saesoc_err_print("%s:%d, Error - New session failed, err %d\n", 
+		cryptosoc_err_print("%s:%d, Error - New session failed, err %d\n", 
 				__FUNCTION__, __LINE__, dcnt);
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 	}
 
 	if(*sdesc == NULL) {
 		/* take the maximum of it*/
 		dcnt = ndescs > dcnt ? ndescs : dcnt;
 
-		*sdesc = saesoc_mem_alloc(SAESOC_CACHELINE_SZ,
+		*sdesc = cryptosoc_mem_alloc(CRYPTOSOC_CACHELINE_SZ,
 				sizeof(struct saesoc_session_desc) + dcnt * sizeof(_uint64_t));
 		if(*sdesc == NULL)
-			return -SAESOC_ENOMEM;
+			return -CRYPTOSOC_ENOMEM;
 		allocated = 1;
 	}
 	sd = *sdesc;
 
 	/* return error if descriptor is not cache aligned */
-	if(!saesoc_is_cache_aligned((unsigned long)sd->descs)) {
-		saesoc_err_print("%s:%d, Error - Session descriptor is not cache aligned\n", 
+	if(!cryptosoc_is_cache_aligned((unsigned long)sd->descs)) {
+		cryptosoc_err_print("%s:%d, Error - Session descriptor is not cache aligned\n", 
 				__FUNCTION__, __LINE__);
 		goto err_exit;
 	}
@@ -632,6 +501,10 @@ static inline int saesoc_new_session(
 		*  we will calculate this here based on the iv_mode */
 		frag_idx = 2;
 
+		/* clear the memory */
+		sd->descs[0] = 0x0ULL;
+		sd->descs[1] = 0x0ULL;
+
 		if(initp->hash.type != SAESOC_HASH_BYPASS) {
 			saesoc_gen2_set_hash_type_mode_offset(sd->descs[0],
 				initp->hash.type, initp->hash.mode,
@@ -657,7 +530,7 @@ static inline int saesoc_new_session(
 			/* copy the key , hash key first then cipher key*/
 			memcpy((char *)(long)&sd->descs[keyidx], 
 					initp->hash.key, initp->hash.key_len);
-			keyidx += ((saesoc_roundup(initp->hash.key_len, 
+			keyidx += ((cryptosoc_roundup(initp->hash.key_len, 
 						sizeof(_uint64_t))) / sizeof(_uint64_t));
 
 			/* copy the init info to the private structure */
@@ -668,7 +541,8 @@ static inline int saesoc_new_session(
 				frag_idx += spriv->hash_iv_descs;
 			} else
 				 spriv->hash_iv_descs = 0;
-		}
+		} else
+			saesoc_gen2_set_hash_bypass(sd->descs[0]);
 
 		if(initp->cipher.type != SAESOC_CIPHER_BYPASS) {
 			saesoc_gen2_set_cipher_type_mode_offset(sd->descs[1], 
@@ -691,7 +565,7 @@ static inline int saesoc_new_session(
 			memcpy((char *)(long)&sd->descs[keyidx], 
 					initp->cipher.key, initp->cipher.key_len);
 
-			keyidx += ((saesoc_roundup(initp->cipher.key_len, 
+			keyidx += ((cryptosoc_roundup(initp->cipher.key_len, 
 						sizeof(_uint64_t))) / sizeof(_uint64_t));
 
 			/* copy the init info to the private structure */
@@ -702,10 +576,8 @@ static inline int saesoc_new_session(
 				frag_idx += spriv->cipher_iv_descs;
 			} else
 				spriv->cipher_iv_descs = 0;
-		} else {
-                       saesoc_gen2_set_cipher_type_mode_offset(sd->descs[1],
-                                        0, initp->cipher.type, 0, 0, 0);
-                }
+		} else
+			saesoc_gen2_set_cipher_bypass(sd->descs[1]);
 
 
 		saesoc_gen2_set_l3param(sd->descs[0],
@@ -728,13 +600,17 @@ static inline int saesoc_new_session(
 	{
 		/* session descriptor index where key should be copied */
 		keyidx = 1;
+		/* clear the memory */
+		sd->descs[0] = 0ULL;
+		spriv->ddesc[0]= spriv->ddesc[1] = 0ULL;
+		spriv->ddesc[2]= spriv->ddesc[3] = 0ULL;
+		spriv->ddesc[4] = spriv->ddesc[5] = 0ULL;
+		spriv->hash_key_len_in_dw = 0; 
+		spriv->cipher_key_len_in_dw = 0;  
 
 		saesoc_gen1_set_cipher_l3param(spriv->ddesc[5],
 				(initp->flags & SAESOC_IF_DATA_OUT_L3_ALLOC) == 0 ? 0:1,
 				(initp->flags & SAESOC_IF_DATA_OUT_CLOBBER ) == 0 ? 0:1);
-		saesoc_gen1_set_cipher_enc_ivlen(spriv->ddesc[0],
-				(initp->cipher.flags & SAESOC_CF_ENCRYPT)==0?0:1,
-				saesoc_iv_size[initp->cipher.type][initp->cipher.mode]);
 		saesoc_gen1_set_hash_srcsel(spriv->ddesc[0],
 				(initp->hash.flags & SAESOC_HF_HASHINP_IS_CIPHEROUT)==0?0:1);
 		saesoc_gen1_set_hash_l3allocate(spriv->ddesc[0],
@@ -744,17 +620,19 @@ static inline int saesoc_new_session(
 				initp->hash.aad_offset,
 				((initp->hash.flags & SAESOC_HF_HASH_CLOBBER) == 0 ? 0:1));
 
-		saesoc_gen1_set_tag_len(spriv->ddesc[3], saesoc_gen1_tag_len[initp->hash.type]);
 		saesoc_gen1_set_hmac_extkeypad( spriv->ddesc[3],
 				(initp->hash.flags & SAESOC_HF_HMAC_KEY_PAD_EN)==0?0:1);
 
-		saesoc_gen1_set_cipher_offset_clobber( spriv->ddesc[1],
+		saesoc_gen1_set_cipher_offset_clobber( spriv->ddesc[2],
 				initp->payload_offset,initp->cipher.iv_offset);
 
 		if( initp->cipher.type != SAESOC_CIPHER_BYPASS) {
 			saesoc_gen1_set_cipher_type_mode(sd->descs[0],
 					saesoc_gen1_cipher_table_map[initp->cipher.type],
 					saesoc_gen1_cipher_mode_map[initp->cipher.mode]);
+			saesoc_gen1_set_cipher_enc_ivlen(spriv->ddesc[0],
+					(initp->cipher.flags & SAESOC_CF_ENCRYPT)==0?0:1,
+					saesoc_iv_size[initp->cipher.type][initp->cipher.mode]);
 
 			if(initp->cipher.type == SAESOC_CIPHER_TYPE_ARC4) {
 				saesoc_gen1_set_arc4_param(sd->descs[0],
@@ -766,38 +644,71 @@ static inline int saesoc_new_session(
 			if(initp->cipher.mode == SAESOC_CIPHER_MODE_CFB) {
 				saesoc_gen1_set_cfbmask(sd->descs[0],initp->cipher.cfb_mask);
 			}	
-			memcpy((char *)(long)&sd->descs[keyidx],initp->cipher.key, 
+			if ( (saesoc_gen1_cipher_table_map[initp->cipher.type] == 0x2) && 
+					!(initp->cipher.flags & SAESOC_CF_ENCRYPT) &&
+					!(initp->cipher.flags & SAESOC_CF_DES3_KEYSWAP_DONE) )
+			{	
+				unsigned long long  * key = (unsigned long long  *)initp->cipher.key;
+				sd->descs[keyidx] = key[2];
+				sd->descs[keyidx+1] = key[1];
+				sd->descs[keyidx+2] = key[0];
+			}
+			else
+				memcpy((char *)(long)&sd->descs[keyidx],initp->cipher.key, 
 					initp->cipher.key_len);
-			spriv->cipher_key_len_in_dw = 	((saesoc_roundup(initp->cipher.key_len,
+			spriv->cipher_key_len_in_dw = 	((cryptosoc_roundup(initp->cipher.key_len,
 							sizeof(_uint64_t))) / sizeof(_uint64_t)); 
 			keyidx += spriv->cipher_key_len_in_dw;
 
-		}
+		} else
+			saesoc_gen1_set_cipher_bypass(sd->descs[0]);
+		spriv->addl_hash_len = 0;
+
 		if(initp->hash.type != SAESOC_HASH_BYPASS) {
+			spriv->hash_en = 1;
+			spriv->addl_hash_len = initp->hash.addl_hash_len;
 			int hmac = initp->hash.key_len?1:0;
-			int mode = (saesoc_gen1_hash_type_map[initp->hash.type] & 0xf);
-			if ( mode == 0x02)
-				mode = (saesoc_gen1_hash_type_map[initp->hash.type] & 0xf0) >> 4;
+			int mode ;
+			if ( SAESOC_HASH_TYPE_ZUC == initp->hash.type )
+				hmac = 0;
+
+
+			if ( initp->hash.type > SAESOC_HASH_TYPE_SNOW3G)
+
+				mode =  saesoc_gen1_hash_mode[initp->hash.type];
 			else
-				mode = saesoc_gen1_hash_mode[initp->hash.mode];
+				mode =  saesoc_gen1_hash_mode[initp->hash.mode];
+
+			/* Gen1 does not support truncated tag length. The auth-buffer
+			*  should have space for the tag length */
+			if(initp->hash.tag_len <  saesoc_gen1_tag_len[initp->hash.type]) {
+				cryptosoc_err_print("%s:%d, Error - Tag length is less than required\n", 
+				__FUNCTION__, __LINE__);
+				goto err_exit;
+			}
 
+			saesoc_gen1_set_tag_len(spriv->ddesc[3], saesoc_gen1_tag_len[initp->hash.type]);
 			saesoc_gen1_set_hash_type_mode(sd->descs[0],hmac,
 					saesoc_gen1_hash_type_map[initp->hash.type],
 					mode );
 			memcpy((char *)(long)&sd->descs[keyidx], 
 					initp->hash.key, initp->hash.key_len);
 
-			spriv->hash_key_len_in_dw = ((saesoc_roundup(initp->hash.key_len, 
+			spriv->hash_key_len_in_dw = ((cryptosoc_roundup(initp->hash.key_len, 
 							sizeof(_uint64_t))) / sizeof(_uint64_t));
-		}
+			 keyidx += spriv->hash_key_len_in_dw;
+		} else
+			saesoc_gen1_set_hash_bypass(sd->descs[0]);
+		spriv->ldesc = keyidx;
+		spriv->frag_idx = 4;
 	}
 #endif	
-	return SAESOC_OK;
+	return CRYPTOSOC_OK;
 
 err_exit:
 	if(allocated && sd)
-		saesoc_mem_free(sd);
-	return -SAESOC_EINVAL;
+		cryptosoc_mem_free(sd);
+	return -CRYPTOSOC_EINVAL;
 }
 
 
@@ -806,7 +717,7 @@ err_exit:
 * saesoc_get_sdesc_cnt - Get the number of descriptors allocated for a  session
 * @sdesc: Pointer to the session descriptor(input)
 *
-* Return: Descriptor count, SAESOC_EINVAL
+* Return: Descriptor count, CRYPTOSOC_EINVAL
 */
 
 static inline int saesoc_get_sdesc_cnt(struct saesoc_session_desc *sdesc)
@@ -831,7 +742,7 @@ static inline int saesoc_get_sdesc_cnt(struct saesoc_session_desc *sdesc)
 * the api should add its size also to the required size.
 * if the AAD is not part of the packet, pass this in "nexdescs" 
 *
-* Return: Descriptor count, SAESOC_EINVAL
+* Return: Descriptor count, CRYPTOSOC_EINVAL
 */
 
 static inline int saesoc_calc_ddesc_desc_cnt(
@@ -844,7 +755,7 @@ static inline int saesoc_calc_ddesc_desc_cnt(
 	int ndescs = ndesfb_descs + nextra_descs;
 
 	if(!sdesc)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 
 	/* For gen2, the freeback descriptor should be copied to the last descriptor */
 #ifdef SAESOC_PTYPE_GEN2_SUPPORT
@@ -905,7 +816,7 @@ static inline int saesoc_calc_frags_desc_cnt(struct saesoc_session_desc *sdesc,
 * Note: Freeing of the data descriptor after use should be taken care by the 
 * application even if it is allocated by the API.
 * 
-* Return: SAESOC_OK, SAESOC_EINVAL, SAESOC_ENOMEM, SAESOC_ENOSPACE
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM, CRYPTOSOC_ENOSPACE
 */
 
 static inline int saesoc_new_data_desc(
@@ -920,7 +831,7 @@ static inline int saesoc_new_data_desc(
 	struct saesoc_sdesc_priv_data *spriv;
 
 	if(!sdesc || !ddesc)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 
 #ifdef SAESOC_PTYPE_GEN2_SUPPORT
 	IF_SAESOC_PTYPE_IS_GEN2
@@ -928,26 +839,26 @@ static inline int saesoc_new_data_desc(
 		spriv = (struct saesoc_sdesc_priv_data *)sdesc->lib_priv;
 		/* TOTO : Should find out the minimun required, assuming 1 fragment now */
 		if(ndescs < (spriv->frag_idx + 1)) {
-			saesoc_err_print(
+			cryptosoc_err_print(
 				"%s:%d, Error-Data descriptor size is < minimum required\n", 
 				__FUNCTION__, __LINE__);
-			return -SAESOC_EINVAL;
+			return -CRYPTOSOC_EINVAL;
 		}
 	}
 #endif
 
 	if(*ddesc == NULL) {
-		*ddesc = saesoc_mem_alloc(SAESOC_CACHELINE_SZ,
+		*ddesc = cryptosoc_mem_alloc(CRYPTOSOC_CACHELINE_SZ,
 				sizeof(struct saesoc_data_desc) + ndescs * sizeof(_uint64_t));
 		if(*ddesc == NULL)
-			return -SAESOC_ENOMEM;
+			return -CRYPTOSOC_ENOMEM;
 		allocated = 1;
 	}
 	
 	dd = *ddesc;
 
-	if(!saesoc_is_cache_aligned((unsigned long)dd->descs)) {
-		saesoc_err_print("%s:%d, Error-Data descriptor is not cache aligned\n", 
+	if(!cryptosoc_is_cache_aligned((unsigned long)dd->descs)) {
+		cryptosoc_err_print("%s:%d, Error-Data descriptor is not cache aligned\n", 
 				__FUNCTION__, __LINE__);
 		goto err_exit;
 	}
@@ -972,12 +883,12 @@ static inline int saesoc_new_data_desc(
 	dd->descs[5] = spriv->ddesc[5];
 #endif
 
-	return SAESOC_OK;
+	return CRYPTOSOC_OK;
 
 err_exit:
 	if(allocated && dd)
-		saesoc_mem_free(dd);
-	return -SAESOC_EINVAL;
+		cryptosoc_mem_free(dd);
+	return -CRYPTOSOC_EINVAL;
 }
 
 /**
@@ -995,7 +906,7 @@ err_exit:
 * But for Eagle it should be alternate and the number of source & destination 
 * segments should be the same. See FEATURE_SRC_DST_FRAG_STRIC_ORDER flag
 *
-* Return: SAESOC_OK, SAESOC_EINVAL, SAESOC_ENOSPACE
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOSPACE
 *
 */
 
@@ -1012,10 +923,10 @@ static inline int saesoc_add_frags(
 	unsigned int sl, dl, max, i;
 
 	if(!ddesc || (!src && !dst))
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 
 	if((!src && slen) || (!dst && dlen))
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 
 	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
 
@@ -1026,10 +937,10 @@ static inline int saesoc_add_frags(
 	IF_SAESOC_PTYPE_IS_GEN2
 	{
 		if((nf + dpriv->nfrag_idx) > dpriv->max_descs) {
-			saesoc_err_print(
+			cryptosoc_err_print(
 				"%s:%d, Error - Fragments overflow max %d cur %d more %d\n", 
 				__FUNCTION__, __LINE__,dpriv->max_descs, dpriv->nfrag_idx, nf);
-			return -SAESOC_EINVAL;
+			return -CRYPTOSOC_EINVAL;
 		}
 		nf = dpriv->nfrag_idx;
 
@@ -1046,14 +957,14 @@ static inline int saesoc_add_frags(
 				if(slen > i) {
 					sl = slen - i > maxfraglen ? maxfraglen : slen - i;
 					saesoc_gen2_set_src_frag(ddesc->descs[nf], 0, sl, 
-							saesoc_virt_to_phys((unsigned long)src + i));
+							cryptosoc_virt_to_phys((unsigned long)src + i));
 					dpriv->lsrc_frag_idx = nf;
 					nf++;
 				} 
 				if(dlen > i) {
 					dl = dlen - i > maxfraglen ? maxfraglen : dlen - i;
 					saesoc_gen2_set_dst_frag(ddesc->descs[nf], 0, dl, 
-							saesoc_virt_to_phys((unsigned long)dst + i), 0);
+							cryptosoc_virt_to_phys((unsigned long)dst + i), 0);
 					dpriv->ldst_frag_idx = nf;
 					nf++;
 				}
@@ -1062,7 +973,7 @@ static inline int saesoc_add_frags(
 		}
 		/* update the last fragment index */
 		dpriv->nfrag_idx = nf;
-		return SAESOC_OK;
+		return CRYPTOSOC_OK;
 	}
 #endif
 #ifdef SAESOC_PTYPE_GEN1_SUPPORT
@@ -1072,16 +983,16 @@ static inline int saesoc_add_frags(
 	struct saesoc_sdesc_priv_data *spriv;
 
 	if(!ddesc)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
 	spriv = (struct saesoc_sdesc_priv_data *)dpriv->sdesc->lib_priv;
 
 
 		if((nf + dpriv->nfrag_idx) > dpriv->max_descs) {
-			saesoc_err_print(
+			cryptosoc_err_print(
 				"%s:%d, Error - Fragments overflow max %d cur %d more %d\n", 
 				__FUNCTION__, __LINE__,dpriv->max_descs, dpriv->nfrag_idx, nf);
-			return -SAESOC_EINVAL;
+			return -CRYPTOSOC_EINVAL;
 		}
 		nf = dpriv->nfrag_idx;
 
@@ -1100,7 +1011,7 @@ static inline int saesoc_add_frags(
 					sl = slen - i > maxfraglen ? maxfraglen : slen - i;
 					saesoc_gen1_set_src_frag(
 							ddesc->descs[nf], sl, 
-							saesoc_virt_to_phys((unsigned long)src + i));
+							cryptosoc_virt_to_phys((unsigned long)src + i));
 					dpriv->lsrc_frag_idx = nf;
 					nf++;
 				} 
@@ -1109,7 +1020,7 @@ static inline int saesoc_add_frags(
 					ddesc->descs[nf] = spriv->ddesc[5];
 					saesoc_gen1_set_dst_frag( 
 						ddesc->descs[nf], dl, 
-						saesoc_virt_to_phys((unsigned long)dst + i));
+						cryptosoc_virt_to_phys((unsigned long)dst + i));
 					dpriv->ldst_frag_idx = nf;
 					nf++;
 				}
@@ -1118,10 +1029,10 @@ static inline int saesoc_add_frags(
 			}
 		/* update the last fragment index */
 		dpriv->nfrag_idx = nf;
-		return SAESOC_OK;
+		return CRYPTOSOC_OK;
 	}
 #endif
-	return -SAESOC_EINVAL;
+	return -CRYPTOSOC_EINVAL;
 }
 
 /**
@@ -1132,7 +1043,7 @@ static inline int saesoc_add_frags(
 * @ndesfb_descs:Number of designer descriptors
 * @desfb_vc: Designer freeback vc
 *
-* Return: SAESOC_OK, SAESOC_EINVAL, SAESOC_ENOSPACE
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOSPACE
 *
 * This should be called only after all the fragment are filled in. 
 * Otherwise this info might be overwritten with the fragments.
@@ -1147,16 +1058,16 @@ static inline int saesoc_add_desfb_descs(
 {
 	int nf, i;
 	if(!ddesc || !desfb_descs)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 
 	struct saesoc_ddesc_priv_data *dpriv;
 	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
 		nf = dpriv->nfrag_idx;
 		if((nf + ndesfb_descs) > dpriv->max_descs) {
-			saesoc_err_print(
+			cryptosoc_err_print(
 				"%s:%d, Error - Fragments overflow max %d cur %d reqd %d\n", 
 				__FUNCTION__, __LINE__,  dpriv->max_descs, nf, ndesfb_descs);
-			return -SAESOC_EINVAL;
+			return -CRYPTOSOC_EINVAL;
 		}
 		for(i = 0; i < ndesfb_descs; i++)
 			ddesc->descs[nf + i] = desfb_descs[i];
@@ -1166,17 +1077,17 @@ static inline int saesoc_add_desfb_descs(
 	IF_SAESOC_PTYPE_IS_GEN2
 	{
 		saesoc_gen2_set_desfb(ddesc->descs[1], desfb_vc);
-		return SAESOC_OK;
+		return CRYPTOSOC_OK;
 	}
 #endif
 #ifdef SAESOC_PTYPE_GEN1_SUPPORT
 	IF_SAESOC_PTYPE_IS_GEN1
 	{
 		saesoc_gen1_set_desfb(ddesc->descs[3], desfb_vc);
-		return SAESOC_OK;
+		return CRYPTOSOC_OK;
 	}
 #endif
-	return -SAESOC_EINVAL;
+	return -CRYPTOSOC_EINVAL;
 }
 
 /**
@@ -1190,7 +1101,7 @@ static inline int saesoc_add_desfb_descs(
 * This can be called only if EXPLICIT_IV is set in the chip feature. 
 * IV length is extracted from the session descriptor.
 *
-* Return: SAESOC_OK, SAESOC_EINVAL, SAESOC_ENOSPACE
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOSPACE
 */
 
 static inline int saesoc_set_explicit_iv(
@@ -1205,7 +1116,7 @@ static inline int saesoc_set_explicit_iv(
 	struct saesoc_ddesc_priv_data *dpriv;
 
 	if(!ddesc)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 
 	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
 	spriv = (struct saesoc_sdesc_priv_data *)dpriv->sdesc->lib_priv;
@@ -1222,21 +1133,21 @@ static inline int saesoc_set_explicit_iv(
 		*/
 		if(spriv->hash_iv_descs) {
 			if((hash_iv_len / sizeof(_uint64_t)) > spriv->hash_iv_descs)
-				return -SAESOC_EINVAL;
+				return -CRYPTOSOC_EINVAL;
 			memcpy((char *)(long)&ddesc->descs[sseg], hash_iv, hash_iv_len);
 			/* iv area is always for 128 bits */
 			sseg += 2;
 		}
 		if(spriv->cipher_iv_descs) {
 			if((cipher_iv_len / sizeof(_uint64_t)) > spriv->cipher_iv_descs)
-				return -SAESOC_EINVAL;
+				return -CRYPTOSOC_EINVAL;
 			memcpy((char *)(long)&ddesc->descs[sseg], cipher_iv, cipher_iv_len);
 		}
-		return SAESOC_OK;
+		return CRYPTOSOC_OK;
 	}
 #endif
 
-	return -SAESOC_EINVAL;
+	return -CRYPTOSOC_EINVAL;
 }
 
 /**
@@ -1251,7 +1162,7 @@ static inline int saesoc_set_explicit_iv(
 * But for Griffin, as the source and destination can be anywhere. So in griffin,
 * the above call returns the same value for srcidx & dstidx. 
 *
-* Return: SAESOC_OK, SAESOC_EINVAL
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
 */
 
 static inline int saesoc_get_frag_index(
@@ -1263,18 +1174,18 @@ static inline int saesoc_get_frag_index(
 	struct saesoc_ddesc_priv_data *dpriv;
 
 	if(!ddesc || !src_idx || !dst_idx || !max_descs)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 
 	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
 
 	*src_idx = dpriv->lsrc_frag_idx;
 	*dst_idx = dpriv->ldst_frag_idx;
 	*max_descs = dpriv->max_descs;
-	return SAESOC_OK;
+	return CRYPTOSOC_OK;
 }
 
 /**
-* saesoc_reset_ddesc(): Reset the data descriptor 
+* saesoc_reset_ddesc - Reset the data descriptor 
 * @ddesc: Pointer to the data descriptor(input)
 * @op: Reset operation type
 * @src_idx: Source fragment index
@@ -1286,7 +1197,7 @@ static inline int saesoc_get_frag_index(
 *
 * Note: 
 *
-* Return: SAESOC_OK, SAESOC_EINVAL
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
 */
 
 static inline int saesoc_reset_ddesc(
@@ -1299,7 +1210,7 @@ static inline int saesoc_reset_ddesc(
 	struct saesoc_sdesc_priv_data *spriv;
 
 	if(!ddesc)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
 	spriv = (struct saesoc_sdesc_priv_data *)dpriv->sdesc->lib_priv;
 
@@ -1317,11 +1228,11 @@ static inline int saesoc_reset_ddesc(
 			dpriv->nfrag_idx = src_idx > dst_idx ? src_idx : dst_idx;
 			dpriv->nfrag_idx++; /* it is the next availabe slot */
 		} else
-			return -SAESOC_EINVAL;
+			return -CRYPTOSOC_EINVAL;
 	} else
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 
-	return SAESOC_OK;
+	return CRYPTOSOC_OK;
 };
 
 
@@ -1329,7 +1240,7 @@ static inline int saesoc_reset_ddesc(
 * saesoc_get_ddesc_cnt - Get the descriptor used count
 * @ddesc: Pointer to the data descriptor(input)
 *
-* Return: Desciptor count, SAESOC_EINVAL
+* Return: Desciptor count, CRYPTOSOC_EINVAL
 */
 
 static inline int saesoc_get_ddesc_cnt(struct saesoc_data_desc *ddesc)
@@ -1337,7 +1248,7 @@ static inline int saesoc_get_ddesc_cnt(struct saesoc_data_desc *ddesc)
 	struct saesoc_ddesc_priv_data *dpriv;
 
 	if(!ddesc)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
 	return (dpriv->nfrag_idx + dpriv->ndesfb_descs);
 }
@@ -1353,7 +1264,7 @@ static inline int saesoc_get_ddesc_cnt(struct saesoc_data_desc *ddesc)
 *
 * The old/new descriptor should be freed by the application.
 *
-* Return: SAESOC_OK, SAESOC_EINVAL, SAESOC_ENOMEM, SAESOC_ENOSPACE
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM, CRYPTOSOC_ENOSPACE
 */
 
 static inline int saesoc_copy_ddesc(
@@ -1369,25 +1280,25 @@ static inline int saesoc_copy_ddesc(
 
 
 	if(!ddesc || !ddesc_new)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 
 	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
 
 	fragsused = dpriv->nfrag_idx + dpriv->ndesfb_descs;
 
 	if(fragsused > ndescs_new) {
-			saesoc_err_print(
+			cryptosoc_err_print(
 				"%s:%d, Error - Copy failed cur-frags %d given %d\n", 
 				__FUNCTION__, __LINE__,  fragsused, ndescs_new);
-			return -SAESOC_EINVAL;
+			return -CRYPTOSOC_EINVAL;
 	}
 
 
 	if(*ddesc_new == NULL) {
-		*ddesc_new = saesoc_mem_alloc(SAESOC_CACHELINE_SZ,
+		*ddesc_new = cryptosoc_mem_alloc(CRYPTOSOC_CACHELINE_SZ,
 			sizeof(struct saesoc_data_desc) + ndescs_new * sizeof(_uint64_t));
 		if(*ddesc_new == NULL)
-			return -SAESOC_ENOMEM;
+			return -CRYPTOSOC_ENOMEM;
 	}
 	
 	dd_n = *ddesc_new;
@@ -1403,7 +1314,7 @@ static inline int saesoc_copy_ddesc(
 	for(i = 0; i < fragsused; i++) 
 		dd_n->descs[i] = ddesc->descs[i];
 
-	return SAESOC_OK;
+	return CRYPTOSOC_OK;
 }
 
 /**
@@ -1411,7 +1322,7 @@ static inline int saesoc_copy_ddesc(
 * @ddesc: Pointer to the data descriptor(input)
 * @payload_len: Payload length
 *
-* Return: SAESOC_OK, SAESOC_EINVAL
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
 */
 
 static inline int saesoc_set_payload_len (
@@ -1419,13 +1330,13 @@ static inline int saesoc_set_payload_len (
 		unsigned int payload_len)
 {
 	if(!ddesc)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 
 #ifdef SAESOC_PTYPE_GEN2_SUPPORT
 	IF_SAESOC_PTYPE_IS_GEN2
 	{
 		saesoc_gen2_set_payload_len(ddesc->descs[0], payload_len);
-		return SAESOC_OK;
+		return CRYPTOSOC_OK;
 	}
 #endif
 #ifdef SAESOC_PTYPE_GEN1_SUPPORT
@@ -1435,16 +1346,18 @@ static inline int saesoc_set_payload_len (
 		struct saesoc_sdesc_priv_data *spriv;
 
 		if(!ddesc)
-			return -SAESOC_EINVAL;
+			return -CRYPTOSOC_EINVAL;
 		dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
 		spriv = (struct saesoc_sdesc_priv_data *)dpriv->sdesc->lib_priv;
 
-		saesoc_gen1_set_cipher_len(ddesc->descs[1], payload_len);
-		saesoc_gen1_set_hash_len(ddesc->descs[1], (payload_len+spriv->aad_len));
-		return SAESOC_OK;
+		if ( spriv->cipher_key_len_in_dw )
+			saesoc_gen1_set_cipher_len(ddesc->descs[1], payload_len);
+		if ( spriv->hash_en ) 
+			saesoc_gen1_set_hash_len(ddesc->descs[1], (payload_len+spriv->addl_hash_len));
+		return CRYPTOSOC_OK;
 	}
 #endif
-	return -SAESOC_EINVAL;
+	return -CRYPTOSOC_EINVAL;
 }
 
 /**
@@ -1452,7 +1365,7 @@ static inline int saesoc_set_payload_len (
 * @ddesc: Pointer to the data descriptor(input)
 * @payload_bitcnt: Number of valid bits in the last byte of the input
 *
-* Return: SAESOC_OK, SAESOC_EINVAL
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
 */
 
 static inline int  saesoc_set_payload_bitcnt(
@@ -1460,24 +1373,24 @@ static inline int  saesoc_set_payload_bitcnt(
 		int payload_bitcnt)
 {
 	if(!ddesc)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 
 #ifdef SAESOC_PTYPE_GEN2_SUPPORT
 	IF_SAESOC_PTYPE_IS_GEN2
 	{
 		saesoc_gen2_set_payload_bitcnt(ddesc->descs[1], payload_bitcnt);
-		return SAESOC_OK;
+		return CRYPTOSOC_OK;
 	}
 #endif
 #ifdef SAESOC_PTYPE_GEN1_SUPPORT
 	IF_SAESOC_PTYPE_IS_GEN1
 	{
 		saesoc_gen1_set_hash_bitcnt(ddesc->descs[2],payload_bitcnt);
-		saesoc_gen1_set_cipher_bitcnt(ddesc->descs[1],payload_bitcnt);
-		return SAESOC_OK;
+		saesoc_gen1_set_cipher_bitcnt(ddesc->descs[2],payload_bitcnt);
+		return CRYPTOSOC_OK;
 	}
 #endif
-	return -SAESOC_EINVAL;
+	return -CRYPTOSOC_EINVAL;
 }
 
 /**
@@ -1485,7 +1398,7 @@ static inline int  saesoc_set_payload_bitcnt(
 * @ddesc: Pointer to the data descriptor(input)
 * @tag_dst_addr: Tag destination address
 *
-* Return: SAESOC_OK, SAESOC_EINVAL
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
 */
 
 static inline int saesoc_set_tag_dstaddr(
@@ -1494,25 +1407,25 @@ static inline int saesoc_set_tag_dstaddr(
 {
 
 	if(!ddesc)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 
 #ifdef SAESOC_PTYPE_GEN2_SUPPORT
 	IF_SAESOC_PTYPE_IS_GEN2
 	{
 		saesoc_gen2_set_tag_dstaddr(ddesc->descs[1], 
-				saesoc_virt_to_phys((unsigned long)tag_dst_addr));
-		return SAESOC_OK;
+				cryptosoc_virt_to_phys((unsigned long)tag_dst_addr));
+		return CRYPTOSOC_OK;
 	}
 #endif
 #ifdef SAESOC_PTYPE_GEN1_SUPPORT
 	IF_SAESOC_PTYPE_IS_GEN1
 	{
 		saesoc_gen1_set_tag_dstaddr(ddesc->descs[0],
-				saesoc_virt_to_phys((unsigned long)tag_dst_addr));
-		return SAESOC_OK;
+				cryptosoc_virt_to_phys((unsigned long)tag_dst_addr));
+		return CRYPTOSOC_OK;
 	}
 #endif
-	return -SAESOC_EINVAL;
+	return -CRYPTOSOC_EINVAL;
 }
 
 /**
@@ -1520,7 +1433,7 @@ static inline int saesoc_set_tag_dstaddr(
 * @ddesc: Pointer to the data descriptor(input)
 * @save_state: boolean, enable/disable
 *
-* Return: SAESOC_OK, SAESOC_EINVAL
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
 */
 
 static inline int saesoc_set_arc4_savestate(
@@ -1529,23 +1442,23 @@ static inline int saesoc_set_arc4_savestate(
 {
 
 	if(!ddesc)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 
 #ifdef SAESOC_PTYPE_GEN2_SUPPORT
 	IF_SAESOC_PTYPE_IS_GEN2
 	{
 		saesoc_gen2_set_arc4_savestate(ddesc->descs[1], save_state);
-		return SAESOC_OK;
+		return CRYPTOSOC_OK;
 	}
 #endif
 #ifdef SAESOC_PTYPE_GEN1_SUPPORT
 	IF_SAESOC_PTYPE_IS_GEN1
 	{
 		saesoc_gen1_set_arc4_savestate(ddesc->descs[3],save_state);
-		return SAESOC_OK; 
+		return CRYPTOSOC_OK; 
 	}
 #endif
-	return -SAESOC_EINVAL;
+	return -CRYPTOSOC_EINVAL;
 }
 
 /**
@@ -1553,7 +1466,7 @@ static inline int saesoc_set_arc4_savestate(
 * @ddesc: Pointer to the data descriptor(input)
 * @aad_len: AAD length
 *
-* Return: SAESOC_OK, SAESOC_EINVAL
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
 */
 
 static inline int saesoc_set_aad_len(
@@ -1561,13 +1474,13 @@ static inline int saesoc_set_aad_len(
 		int aad_len)
 {
 	if(!ddesc)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 
 #ifdef SAESOC_PTYPE_GEN2_SUPPORT
 	IF_SAESOC_PTYPE_IS_GEN2
 	{
 		saesoc_gen2_set_aadlen(ddesc->descs[0], aad_len);
-		return SAESOC_OK;
+		return CRYPTOSOC_OK;
 	}
 #endif
 #ifdef SAESOC_PTYPE_GEN1_SUPPORT
@@ -1577,14 +1490,14 @@ static inline int saesoc_set_aad_len(
 		struct saesoc_sdesc_priv_data *spriv;
 
 		if(!ddesc)
-			return -SAESOC_EINVAL;
+			return -CRYPTOSOC_EINVAL;
 		dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
 		spriv = (struct saesoc_sdesc_priv_data *)dpriv->sdesc->lib_priv;
-		spriv->aad_len = aad_len;
-		return SAESOC_OK;
+		spriv->addl_hash_len += aad_len;
+		return CRYPTOSOC_OK;
 	}
 #endif
-	return -SAESOC_EINVAL;
+	return -CRYPTOSOC_EINVAL;
 }
 
 /**
@@ -1606,14 +1519,14 @@ static inline int saesoc_disable_wr_fragment(
 
 		struct saesoc_ddesc_priv_data *dpriv;
 		if(!ddesc)
-			return -SAESOC_EINVAL;
+			return -CRYPTOSOC_EINVAL;
 		dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
 		if(dpriv->ldst_frag_idx)
 			saesoc_gen2_disble_wrfrag(ddesc->descs[dpriv->ldst_frag_idx]);
-		return SAESOC_OK;
+		return CRYPTOSOC_OK;
 	}
 #endif
-	return -SAESOC_EINVAL;
+	return -CRYPTOSOC_EINVAL;
 }
 
 /**
@@ -1623,7 +1536,7 @@ static inline int saesoc_disable_wr_fragment(
 *
 * Note: This can be called only if PAD_ option is set in the feature set
 *
-* Return: SAESOC_OK, SAESOC_EINVAL
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
 */
 
 static inline int  saesoc_set_cipher_padval(
@@ -1631,33 +1544,47 @@ static inline int  saesoc_set_cipher_padval(
 		int pad_val)
 {
 	if(!ddesc)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 
 #ifdef SAESOC_PTYPE_GEN2_SUPPORT
 	IF_SAESOC_PTYPE_IS_GEN2
 	{
 		saesoc_gen2_set_cipher_padval(ddesc->descs[0], pad_val);
-		return SAESOC_OK;
+		return CRYPTOSOC_OK;
 	}
 #endif
-	return -SAESOC_EINVAL;
+	return -CRYPTOSOC_EINVAL;
 }
 
 
 
 /**
 * saesoc_chk_tag_compare_result - Check the ICV values are matching or not
-* @rsp: Pointer to the response value
+* @res: Engine result response
 *
 * Note: Can be called only if CHK_TAG is enabled in the feature set
 *
 * Return: 1 if it is matching, 0 otherwise
 */
 
-static inline int saesoc_chk_tag_compare_result(struct saesoc_rsp_value *rsp)
+static inline int saesoc_chk_tag_compare_result(struct saesoc_rsp_result *res)
+{
+	/* TODO */
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_result_valid - Check the whether the result from the engine is 
+* valid or not
+* @res: Engine result response
+*
+*
+* Return: 1 if it is valid, 0 otherwise
+*/
+static inline int saesoc_result_valid(struct saesoc_rsp_result *res)
 {
 	/* TODO */
-	return -SAESOC_EINVAL;
+	return 1;
 }
 
 /**
@@ -1667,13 +1594,13 @@ static inline int saesoc_chk_tag_compare_result(struct saesoc_rsp_value *rsp)
 *
 * Note: Can be called only if HASH_MUTE is set on the feature set
 *
-* Return: SAESOC_OK, SAESOC_EINVAL
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
 */
 
 static inline int saesoc_set_hash_mutemask(int index, unsigned int mask[8])
 {
 	/* TODO */
-	return -SAESOC_EINVAL;
+	return -CRYPTOSOC_EINVAL;
 }
 
 /**
@@ -1732,37 +1659,49 @@ static inline void saesoc_dump_desc_info(
 
 }
 
-
 /**
-* saesoc_send_request(): Send the descriptor info to the engine
+* saesoc_process_request - Send/Receive the descriptor info to/from
+* the engine
+* @ctx : Pointer to the context(input). 
 * @ddesc:Pointer to the data descriptor(input)
-* @sync: The api should wait for the response or not
+* @req_vc: Transmit vc id.
+* @rsp_vc: Freeback vc id. This should be the error freeback vc 
+* 	if designer freeback is enabled.
+* @code: Message send code.
 * @retry_count: How many times the send should be retried before
 * 	telling it is failed
-* @fbvc: Freeback vc id. This should be the error freeback vc 
-* 	if designer freeback is enabled.
 * @mparam: Extra parameters for the send request
-* @rsp: Response message in sync(output)
+* @sync_res: Engine result response if mode is sync(output). 
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EAGAIN, CRYPTOSOC_EINVAL
 *
-* Return: SAESOC_OK, SAESOC_ETIMEOUT
+* Note: 
+* if ctx != null, it does the operation as per the ctx mode
+* If ctx == null &  rsp != null, function sends the message
+* and wait for the response. 
+* if ctx == null & rsp == null, the function just send the message
 */
 
-static inline int saesoc_send_request(
+static inline int saesoc_process_request(
+		struct cryptosoc_ctx *ctx,
 		struct saesoc_data_desc *ddesc,
-		int sync,
+		int req_vc,
+		int rsp_vc,
+		int code,
 		int retry_count,
-		int fbvc,
 		struct saesoc_extra_req_send_params *mparam,
-		struct saesoc_rsp_value *rsp)
+		struct saesoc_rsp_result *sync_res)
 {
 	struct saesoc_sdesc_priv_data *spriv;
 	struct saesoc_ddesc_priv_data *dpriv;
 	struct saesoc_session_desc    *sdesc;
 	int nddescs;
-	_uint64_t fmnentry0, fmnentry1, fmnentry3;
+	_uint64_t fmnentry0, fmnentry1, fmnentry2;
+	_uint64_t *rsp_msg_ptr = NULL;
+	int gen_type2 = 0;
 
 	if(!ddesc)
-		return -SAESOC_EINVAL;
+		return -CRYPTOSOC_EINVAL;
 
 #ifdef SAESOC_PTYPE_GEN2_SUPPORT
 	IF_SAESOC_PTYPE_IS_GEN2
@@ -1780,25 +1719,24 @@ static inline int saesoc_send_request(
 
 		/* for gen2 the freeback entry should be copied to the last */
 		if((nddescs + 1) > dpriv->max_descs) {
-			saesoc_err_print(
+			cryptosoc_err_print(
 				"%s:%d, Error - Fragments overflow max %d cur %d \n", 
 				__FUNCTION__, __LINE__,  dpriv->max_descs, nddescs);
-			return -SAESOC_EINVAL;
+			return -CRYPTOSOC_EINVAL;
 		}
 
-		fmnentry3 = mparam != NULL ? mparam->arg : 0ULL;
-		ddesc->descs[nddescs] = fmnentry3;
+		fmnentry2 = mparam != NULL ? mparam->async_rsp_arg : 0ULL;
+		ddesc->descs[nddescs] = fmnentry2;
 		nddescs++;
 
-		fmnentry0 = saesoc_gen2_form_fmn_entry0(fbvc, dpriv->ndesfb_descs, 
-				dpriv->ndesfb_descs == 0 ? 0:1, nsdescs, 
-				((_uint64_t)(unsigned long)&sdesc->descs) >> SAESOC_CACHELINE_SHIFT);
+		fmnentry0 = saesoc_gen2_form_fmn_entry0(rsp_vc, dpriv->ndesfb_descs, 
+			dpriv->ndesfb_descs == 0 ? 0:1, nsdescs, 
+			saesoc_get_cacheline_phys_addr(&sdesc->descs));
 
 		fmnentry1 = saesoc_gen2_form_fmn_entry1(
-				mparam != NULL ? mparam->arc4_load_state : 0, 
-				ivdescs, nddescs, 
-				((_uint64_t)(unsigned long)&ddesc->descs) >> SAESOC_CACHELINE_SHIFT);
-
+			mparam != NULL ? mparam->arc4_load_state : 0, 
+			ivdescs, nddescs, 
+			saesoc_get_cacheline_phys_addr(&ddesc->descs));
 
 		/* Set the last frag bits */
 		if(dpriv->lsrc_frag_idx)
@@ -1806,13 +1744,10 @@ static inline int saesoc_send_request(
 		if(dpriv->ldst_frag_idx)
 			saesoc_gen2_set_last_frag(ddesc->descs[dpriv->ldst_frag_idx]);
 
-		/* TODO : Need to check the return code, and retry if 
-		*  retry count is specified */
-#if defined(__mips__)
-		return xlp_message_send_2(saesoc_base_vc, 0, fmnentry0, fmnentry1);
-#else
-		return saesoc_gen2_msg_send(fmnentry0, fmnentry1, fmnentry3);
-#endif
+		rsp_msg_ptr = &ddesc->descs[nddescs];
+		gen_type2 = 1;
+
+		goto send_req;
 	}
 #endif
 #ifdef SAESOC_PTYPE_GEN1_SUPPORT
@@ -1822,51 +1757,43 @@ static inline int saesoc_send_request(
 		dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
 		sdesc = (struct saesoc_session_desc    *)dpriv->sdesc;
 		spriv = (struct saesoc_sdesc_priv_data *)sdesc->lib_priv;
+		nddescs = (dpriv->nfrag_idx + dpriv->ndesfb_descs)/2;
 
-		fmnentry0 = saesoc_gen1_form_fmn_entry0(fbvc, dpriv->ndesfb_descs, 
-				dpriv->ndesfb_descs == 0 ? 0:1, spriv->cipher_key_len_in_dw, 
-				((_uint64_t)(unsigned long)&sdesc->descs) >> SAESOC_CACHELINE_SHIFT);
+		fmnentry0 = saesoc_gen1_form_fmn_entry0(rsp_vc, dpriv->ndesfb_descs, 
+			dpriv->ndesfb_descs == 0 ? 0:1, spriv->cipher_key_len_in_dw, 
+			saesoc_get_cacheline_phys_addr(&sdesc->descs));
 
 		fmnentry1 = saesoc_gen1_form_fmn_entry1(
 				mparam != NULL ? mparam->arc4_load_state : 0, 
 				spriv->hash_key_len_in_dw, nddescs, 
-				((_uint64_t)(unsigned long)&ddesc->descs) >> SAESOC_CACHELINE_SHIFT);
+				saesoc_get_cacheline_phys_addr(&ddesc->descs[0]));
 
-		fmnentry3 = mparam != NULL ? mparam->arg : 0ULL;
+		fmnentry2 = mparam != NULL ? mparam->async_rsp_arg : 0ULL;
+
+		goto send_req;
 
-		/* TODO : Need to check the return code, and retry if 
-		*  retry count is specified */
-#if defined(__mips__)
-		return xlp_message_send_3(saesoc_base_vc, 0, fmnentry0, fmnentry1, fmnentry3);
-#else
-		return saesoc_gen1_msg_send(fmnentry0, fmnentry1, fmnentry3);
-#endif
 	}
 #endif
-	return -SAESOC_EINVAL;
-}
-
-/**
-* saesoc_post_response_rcv(): Post response receive api for async request
-* @desc0: message 0 received from the engine
-* @desc1: message 1 received from the engine
-* @arg: Freeback message value given as part of request send(output)
-* @rsp : request result in bitmasks(output)
-*
-* Return: SAESOC_OK, SAESOC_EINVAL
-*
-*/
-
-static inline int saesoc_post_response_rcv(_uint64_t desc0, _uint64_t desc1,
-		_uint64_t *arg, struct saesoc_rsp_value *rsp)
-{
-	/* TODO */
-	return -SAESOC_EINVAL;
+	return -CRYPTOSOC_EINVAL;
+
+send_req:
+
+	if(!ctx) {
+		return cryptosoc_process_request(gen_type2, CRYPTOSOC_SAE, 
+				req_vc, rsp_vc, code, retry_count,
+				fmnentry0, fmnentry1, fmnentry2,
+				sync_res ? &sync_res->result : NULL);
+	} else {
+		return cryptosoc_process_ctx_request(gen_type2, ctx, CRYPTOSOC_SAE,
+				req_vc, rsp_vc, code, retry_count, 
+				fmnentry0, fmnentry1, fmnentry2, 
+				sync_res ? &sync_res->result : NULL,
+				rsp_msg_ptr);
+	}
 }
 
 
 
 
-
 #endif
 
diff --git a/arch/mips/netlogic/lib/seclib/sample_app/Makefile b/arch/mips/netlogic/lib/seclib/sample_app/Makefile
deleted file mode 100644
index d6fc188..0000000
--- a/arch/mips/netlogic/lib/seclib/sample_app/Makefile
+++ /dev/null
@@ -1,22 +0,0 @@
-#Makefile to test the apis on mips(eagle/griffin) from linux userspace.
-
-HYPEREXEC_DIR =$(SDK_ROOT)/hyperexec
-SAESOC_OBJS=../saesoc_lib.o saesoc_sample_app.o
-
-ABI=64
-
-include $(SDK_ROOT)/linux-userspace/Makefile.mk
-
-CFLAGS += -I. -I.. -I../../hal 
-CFLAGS += -DNLM_HAL_LINUX_USER -I$(HYPEREXEC_DIR)/srcs/linuxu/
-
-all: $(SAESOC_OBJS)
-	$(CC) $(CFLAGS) $(SAESOC_OBJS) -o saesoc_sample_app
-
-clean:
-	$(RM) $(SAESOC_OBJS) saesoc_sample_app
-
-install:
-
-.PHONY: all clean install $(SAESOC_LIB)
-
diff --git a/arch/mips/netlogic/lib/seclib/sample_app/build.sh b/arch/mips/netlogic/lib/seclib/sample_app/build.sh
deleted file mode 100755
index 1c9eab2..0000000
--- a/arch/mips/netlogic/lib/seclib/sample_app/build.sh
+++ /dev/null
@@ -1,3 +0,0 @@
-#!/tools/bin/bash
-#build script to test the apis on x86
-gcc saesoc_sample_app.c ../saesoc_lib.c -g -I .. -I . -Wall -o a.out
diff --git a/arch/mips/netlogic/lib/seclib/sample_app/saesoc_lib_ifc.h b/arch/mips/netlogic/lib/seclib/sample_app/saesoc_lib_ifc.h
deleted file mode 100644
index 63db256..0000000
--- a/arch/mips/netlogic/lib/seclib/sample_app/saesoc_lib_ifc.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*-
- * Copyright (c) 2003-2012 Broadcom Corporation
- * All Rights Reserved
- *
- * This software is available to you under a choice of one of two
- * licenses.  You may choose to be licensed under the terms of the GNU
- * General Public License (GPL) Version 2, available from the file
- * http://www.gnu.org/licenses/gpl-2.0.txt  
- * or the Broadcom license below:
-
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_4# */
-
-#ifndef _SAESOC_LIB_IFC_H
-#define _SAESOC_LIB_IFC_H
-
-/* This app is going to support on all the processor varients */
-#define SAESOC_PTYPE_GEN_ALL_SUPPORT 1
-
-#ifndef SAESOC_PTYPE_GEN_ALL_SUPPORT
-/* Otherwise declare the specific ones here */
-#define SAESOC_PTYPE_GEN2_SUPPORT 1
-#endif
-
-/* Application specific private size for lib-params, 
-*  session & data descriptors */
-#define SAESOC_SESSION_DESC_APP_PRIV_SZ 64
-#define SAESOC_DATA_DESC_APP_PRIV_SZ	64
-
-static inline _uint64_t saesoc_virt_to_phys(unsigned long vaddr) 
-{
-		/* for test purpose, set bit 39 to get phys */
-		return ((1ULL << 39) | (_uint64_t)vaddr);
-}
-
-static inline unsigned long saesoc_phys_to_virt(_uint64_t paddr) 
-{ 
-		/* for test purpose, remove bit 39 to get virt */
-		return ((unsigned long)(paddr & ~(1ULL << 39)));
-}
-
-#endif
diff --git a/arch/mips/netlogic/lib/seclib/sample_app/saesoc_sample_app.c b/arch/mips/netlogic/lib/seclib/sample_app/saesoc_sample_app.c
deleted file mode 100644
index ac62de9..0000000
--- a/arch/mips/netlogic/lib/seclib/sample_app/saesoc_sample_app.c
+++ /dev/null
@@ -1,249 +0,0 @@
-/*-
- * Copyright (c) 2003-2012 Broadcom Corporation
- * All Rights Reserved
- *
- * This software is available to you under a choice of one of two
- * licenses.  You may choose to be licensed under the terms of the GNU
- * General Public License (GPL) Version 2, available from the file
- * http://www.gnu.org/licenses/gpl-2.0.txt  
- * or the Broadcom license below:
-
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_4# */
-
-#include <malloc.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "saesoc_lib.h"
-
-struct saesoc_lib_params lparam;
-char cipher_key[16] = {1,1,2,3,4,5,6,7,8,9,1,1,2,3,4,5};
-char hash_key[16] =   {1,1,2,3,4,5,6,7,8,9,2,1,2,3,4,5};
-char cipheriv[16] = {1,1,2,3,4,5,6,7,8,9,2,1,2,3,4,5};
-
-/* Test routine for mem_alloc and free. This should return a physically 
-*  contiguous region. Right now it is not */
-
-int app_lib_init(struct saesoc_lib_params *params)
-{
-	printf("%s called\n", __FUNCTION__);
-	return 0;
-}
-void *mem_alloc(size_t align, size_t size)
-{
-	void *mem;
-	mem = memalign(align, size);	
-	printf("%s called align %d size %lld mem %lx\n", 
-			__FUNCTION__, (int)align, (long long)size, (long)mem);
-	return mem;
-}
-
-void mem_free(void *addr) 
-{
-	printf("%s called free %lx\n", __FUNCTION__, (long)addr);
-	return free(addr);
-}
-
-#ifdef SAESOC_PTYPE_GEN2_SUPPORT
-int saesoc_gen2_msg_send(_uint64_t fmnentry0, 
-		_uint64_t fmnentry1, _uint64_t fmnentry2)
-{
-	saesoc_gen2_dump_fmnentry(fmnentry0, fmnentry1);
-	return SAESOC_OK;
-}
-#endif
-
-#ifdef SAESOC_PTYPE_GEN1_SUPPORT
-int saesoc_gen1_msg_send(_uint64_t fmnentry0, 
-		_uint64_t fmnentry1, _uint64_t fmnentry2)
-{
-	saesoc_gen1_dump_fmnentry(fmnentry0, fmnentry1);
-	return SAESOC_OK;
-}
-#endif
-
-
-
-int main(int argc, char **argv)
-{
-	struct saesoc_session_desc *sdesc = NULL;
-	struct saesoc_data_desc	   *ddesc = NULL;
-	struct saesoc_session_init_params sinit;
-	int err = -1;
-	int nsdescs, nddescs, nfrags;
-	char *pkt = NULL;
-	int pktlen = 64;
-	int aadoff = 14 + 20; /* mac + ip*/
-	int aad_len = 8; /* esp header */
-	int payloadoff = 42;
-	int payloadlen = 22; /* 64 - 42 */
-	int addl_hash_len = 4; /* ecn */
-	_uint64_t desfb_descs = 0x100000000ULL;
-	int ndesfbs = 1, nexdescs = 0;
-
-	printf("Allocate the packet memory\n");
-	/* Allocate packets */
-	if((pkt = mem_alloc(8, pktlen + 32)) == NULL) {
-		printf("%s,%d Error \n", __FUNCTION__, __LINE__);
-		goto err_exit;
-	}
-
-	/* Initialize the library */
-	if(saesoc_lib_init(&lparam, &mem_alloc, &mem_free, NULL) < 0) {
-		printf("%s,%d Error \n", __FUNCTION__, __LINE__);
-		goto err_exit;
-	}
-
-	/* Here we should check the chip feature and decide the 
-	*  algorithm is supported or not */
-	sinit.cipher.type = SAESOC_CIPHER_TYPE_AES_256;
-	sinit.cipher.mode = SAESOC_CIPHER_MODE_CBC;
-	sinit.cipher.iv_offset = 0;
-	/* PKT_DESC iv is not supported in all the variants */
-	if(lparam.feature_set & SAESOC_FF_EXPLICIT_IV_SUPPORT)
-		sinit.cipher.iv_mode = SAESOC_IV_FROM_PKT_DESC;
-	else
-		sinit.cipher.iv_mode = SAESOC_IV_FROM_PKT_SRC;
-	sinit.cipher.key = cipher_key;
-	sinit.cipher.key_len = 16;
-	sinit.cipher.cfb_mask = 0;
-	sinit.cipher.flags = SAESOC_CF_ENCRYPT; 
-
-	sinit.hash.type = SAESOC_HASH_TYPE_AES_192;
-	sinit.hash.mode = SAESOC_HASH_MODE_XCBC;
-	sinit.hash.iv_offset = 0;
-	sinit.hash.iv_mode = SAESOC_IV_FROM_PKT_SRC;
-	sinit.hash.key = hash_key;
-	sinit.hash.key_len = 16;
-	/* hash mute is not supported in all the variants */
-	if(lparam.feature_set & SAESOC_FF_HASHMUTE_SUPPORT)
-		sinit.hash.mute_mask_sel = 1;
-	/* truncated tag is not supported in all the variants */
-	if(lparam.feature_set & SAESOC_FF_TRUNC_TAG_SUPPORT)
-		sinit.hash.tag_len = 12;
-	else
-		sinit.hash.tag_len = 16;
-	/* tag offset is not supported in all the variants */
-	if(lparam.feature_set & SAESOC_FF_TAGIN_OFF_SUPPORT)
-		sinit.hash.tagin_offset = 64; /* Assuming 64 byte input packet, 
-										 tag is present in the end */
-	sinit.hash.aad_offset = aadoff; /* after mac + ip */
-	sinit.hash.addl_hash_len = addl_hash_len; /* IPSEC ECN is enabled */
-	sinit.hash.flags = SAESOC_HF_HASHINP_IS_CIPHEROUT | SAESOC_HF_HMAC_KEY_PAD_EN;
-
-	sinit.payload_offset = payloadoff; /* afte esp header */
-	sinit.flags = SAESOC_IF_DATA_OUT_L3_ALLOC;
-
-	/* find the number of descriptors required for the session */
-	nsdescs = saesoc_calc_sdesc_cnt(&sinit, NULL);
-	if(nsdescs < 0) {
-		printf("%s,%d Error \n", __FUNCTION__, __LINE__);
-		return err;
-	}
-	printf("Ndescs required for sdesc is %d\n", nsdescs);
-
-	/* alloc descriptors for the session */
-	sdesc = (struct saesoc_session_desc *)mem_alloc(SAESOC_CACHELINE_SZ,
-			sizeof(struct saesoc_session_desc) + nsdescs * sizeof(_uint64_t));
-	if(!sdesc) {
-		printf("%s,%d Error \n", __FUNCTION__, __LINE__);
-		return err;
-	}
-
-	/* Initiate the session */
-	if(saesoc_new_session(&sinit, &sdesc, nsdescs, NULL) < 0) {
-		printf("%s,%d Error \n", __FUNCTION__, __LINE__);
-		goto err_exit;
-	}
-
-
-	/* Find the number of descriptors required for the data descriptor */
-	nddescs = saesoc_calc_ddesc_desc_cnt(sdesc, ndesfbs, nexdescs, NULL);
-	if(nddescs < 0) {
-		printf("%s,%d Error \n", __FUNCTION__, __LINE__);
-		goto err_exit;
-	}
-	printf("Ndescs required for ddesc is %d \n", nddescs);
-
-	/* Find the number of descriptors required for the data */
-	nfrags = saesoc_calc_frags_desc_cnt(sdesc, pkt, pktlen, pkt, pktlen);
-	if(nfrags < 0) {
-		printf("%s,%d Error \n", __FUNCTION__, __LINE__);
-		goto err_exit;
-	}
-	printf("Ndescs required for dfrags is %d\n", nfrags);
-
-	/* Initiate the data descriptor, allocate using the library */
-	if(saesoc_new_data_desc(sdesc, &ddesc, nddescs + nfrags, NULL) < 0) {
-		printf("%s,%d Error \n", __FUNCTION__, __LINE__);
-		goto err_exit;
-	}
-
-	/* Set the pkt fragments */
-	if(saesoc_add_frags(ddesc, pkt, pktlen, pkt, pktlen) < 0) {
-		printf("%s,%d Error \n", __FUNCTION__, __LINE__);
-		goto err_exit;
-	}
-
-	/* set the explicit iv */
-	if(saesoc_set_explicit_iv(ddesc, cipheriv, 16, NULL, 0) < 0) {
-		printf("%s,%d Error \n", __FUNCTION__, __LINE__);
-		goto err_exit;
-	}
-	
-	if(saesoc_add_desfb_descs(ddesc, &desfb_descs, 1, 10) < 0) {
-		printf("%s,%d Error \n", __FUNCTION__, __LINE__);
-		goto err_exit;
-	}
-
-	if(saesoc_set_cipher_padval(ddesc, 11) < 0) {
-		printf("%s,%d Error \n", __FUNCTION__, __LINE__);
-		goto err_exit;
-	}
-
-	/* Set the payload length & other required parameters */
-	saesoc_set_payload_len(ddesc, payloadlen); 
-	saesoc_set_tag_dstaddr(ddesc, pkt + pktlen + addl_hash_len);
-	saesoc_set_aad_len(ddesc, aad_len);
-
-	saesoc_send_request(ddesc, 0, 16, 4, NULL, NULL);
-
-	/* Dump the descriptor info */
-	saesoc_dump_desc_info(sdesc, ddesc);
-
-	printf("Test is done..\n");
-
-	err = 0;
-err_exit:
-	if(sdesc)
-		mem_free(sdesc);
-	if(ddesc)
-		mem_free(ddesc);
-	if(pkt)
-		mem_free(pkt);
-
-	return err;
-}
-
-- 
1.9.1

