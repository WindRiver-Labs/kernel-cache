From edb84adf7570f06f8a9a5d57d3afd714ac787d4c Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikas.gupta@broadcom.com>
Date: Tue, 18 Jun 2013 16:45:30 -0700
Subject: [PATCH 0727/1532] xlp9xx: nae fix.

	1) TX threshold change.
	2) lane configuration function modified.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/netlib/src/netsoc_nae.c | 12 +++++++-
 arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c | 39 ++++++++++++++------------
 2 files changed, 32 insertions(+), 19 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index a8f3f90..7556592 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -819,6 +819,12 @@ uint32_t __netsoc_context_to_port_channel(nae_t *nae, uint32_t context)
 	else if (is_nlm_xlp2xx()) {
 		ctxt  = context - XLP_2XX_NET_TX_VC_BASE;
 	}
+	else if (is_nlm_xlp9xx()) {
+		if(nae->nae_id==0)
+			ctxt  = context - XLP_9XX_NET0_VC_BASE;
+		else
+			ctxt  = context - XLP_9XX_NET1_VC_BASE;
+	}
 	else {
 		ctxt  = context - XLP_NET_TX_VC_BASE;
 	}
@@ -2050,7 +2056,11 @@ static void __netsoc_config_xaui(net_port_t *netport)
         val = netsoc_read_mac_reg(mac_base, NETIOR_XGMAC_CTRL3);
 
         val &= ~(0x1f << 10);
-        val |= (15 << 10);
+	if(is_nlm_xlp9xx())
+        	val |= (7 << 10);
+	else{
+        	val |= (15 << 10);
+	}
 
         netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL3, val); netsoc_api_print(NETSOC_APIDBG_PORT, "%s XAUI Config Complete block %d \n", __func__, netport->hw_port_id >> 2); return;
 }
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
index 6540fb1..2289af2 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
@@ -959,19 +959,19 @@ static void xlp_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask)
         netsoc_api_print(NETSOC_APIDBG_PORT,"Net: Completed PCS Configuration\n");
 }
 
-static void config_lanes_for_xaui(nae_t *nae, uint32_t xaui_cplx_mask)
+static void config_lanes_for_xgmac(nae_t *nae, uint32_t xgmac_cplx_mask, uint32_t phymode)
 {
 	uint64_t mac_base = netsoc_get_macreg_base_for_lanecfg(nae->mac_base);
 	uint32_t lane_enable;
 	uint32_t cplx_lane_enable = LM_XAUI | (LM_XAUI << 4) | (LM_XAUI << 8) | (LM_XAUI << 12);
 
-        if (xaui_cplx_mask & 0x3) { /* Complexes 0, 1 */
+        if (xgmac_cplx_mask & 0x3) { /* Complexes 0, 1 */
                 lane_enable = netsoc_read_mac_reg(mac_base, LANE_CFG_CPLX_0_1);
-                if (xaui_cplx_mask & 0x1) { /* Complex 0 */
+                if (xgmac_cplx_mask & 0x1) { /* Complex 0 */
                         lane_enable &= ~(0xFFFF);
                         lane_enable |= cplx_lane_enable;
                 }
-                if (xaui_cplx_mask & 0x2) {/* Complex 1 */
+                if (xgmac_cplx_mask & 0x2) {/* Complex 1 */
                         lane_enable &= ~(0xFFFF<<16);
                         lane_enable |= (cplx_lane_enable << 16);
                 }
@@ -979,27 +979,30 @@ static void config_lanes_for_xaui(nae_t *nae, uint32_t xaui_cplx_mask)
                 netsoc_api_delay(1);
         }
         lane_enable = 0;
-        if (xaui_cplx_mask & 0xc) { /* Complexes 2, 3 */
+        if (xgmac_cplx_mask & 0xc) { /* Complexes 2, 3 */
                 lane_enable = netsoc_read_mac_reg(mac_base, LANE_CFG_CPLX_2_3);
-                if (xaui_cplx_mask & 0x4) { /* Complex 2 */
+                if (xgmac_cplx_mask & 0x4) { /* Complex 2 */
                         lane_enable &= ~(0xFFFF);
                         lane_enable |= cplx_lane_enable;
                 }
-                if (xaui_cplx_mask & 0x8) {/* Complex 3 */
+                if (xgmac_cplx_mask & 0x8) {/* Complex 3 */
                         lane_enable &= ~(0xFFFF<<16);
                         lane_enable |= (cplx_lane_enable << 16);
                 }
                 netsoc_write_mac_reg(mac_base, LANE_CFG_CPLX_2_3,   lane_enable);
                 netsoc_api_delay(1);
         }
-	lane_enable = netsoc_read_mac_reg(mac_base, LANE_CFG_CPLX_4); 
-	if(xaui_cplx_mask & 0x1){
-		lane_enable |= (1<< 16); 
-	}
-	if(xaui_cplx_mask & 0x2){
-		lane_enable |= (1<< 18); 
+
+	if((phymode==PHYMODE_RXAUI) && is_nlm_xlp9xx()){
+		lane_enable = netsoc_read_mac_reg(mac_base, LANE_CFG_CPLX_4); 
+		if(xgmac_cplx_mask & 0x1){
+			lane_enable |= (1<< 16); 
+		}
+		if(xgmac_cplx_mask & 0x2){
+			lane_enable |= (1<< 18); 
+		}
+		netsoc_write_mac_reg(mac_base, LANE_CFG_CPLX_4, lane_enable);
 	}
-	netsoc_write_mac_reg(mac_base, LANE_CFG_CPLX_4, lane_enable);
 
 }
 
@@ -1016,7 +1019,7 @@ static void config_lanes_for_xfi(nae_t *nae, uint32_t xfi_cplx_mask)
 	}
 	netsoc_write_mac_reg(mac_base, LANE_CFG_CPLX_4, val);
 	
-	config_lanes_for_xaui(nae, xfi_cplx_mask);/*same lane mode as XAUI*/
+	config_lanes_for_xgmac(nae, xfi_cplx_mask, PHYMODE_XFI);/*same lane mode as XAUI*/
 }
 
 static void xlp2xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phymode)
@@ -1024,7 +1027,7 @@ static void xlp2xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
 	uint32_t block, lane_status, lane_ctrl, count, timeout = 10000;
 	uint64_t mac_base;
 	
-	config_lanes_for_xaui(nae, xaui_cplx_mask);
+	config_lanes_for_xgmac(nae, xaui_cplx_mask, phymode);
 
 	for( block = 0; block < 4; block++)
         {
@@ -1123,7 +1126,7 @@ static void xlp9xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
 	uint32_t block, lane_status, lane_ctrl, count, timeout = 10000;
 	uint64_t mac_base;
 	
-	config_lanes_for_xaui(nae, xaui_cplx_mask);
+	config_lanes_for_xgmac(nae, xaui_cplx_mask, phymode);
 
 	for( block = 0; block < 4; block++)
         {
@@ -1304,7 +1307,7 @@ static void xlp_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phym
         uint32_t block, lane_status, lane_ctrl, count , timeout = 10000;
         uint64_t mac_base;
 
-        config_lanes_for_xaui(nae, xaui_cplx_mask);
+        config_lanes_for_xgmac(nae, xaui_cplx_mask, phymode);
 
         /* Bring txpll out of reset */
         for( block = 0; block < 4; block++)
-- 
1.9.1

