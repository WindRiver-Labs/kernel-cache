From 9806803dff29988d77c6366fc34b90fab0c9e25b Mon Sep 17 00:00:00 2001
From: Virendra Pathak <vpathak@broadcom.com>
Date: Fri, 24 Jan 2014 10:12:07 +0530
Subject: [PATCH 0891/1532] poe: added cpu enqueue & cpu re-enqueue API's

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/netlogic/lib/netlib/include/lib_hdrs.h   |   2 +
 arch/mips/netlogic/lib/netlib/include/netsoc_msg.h |  50 +++++++-
 .../netlogic/lib/netlib/include/netsoc_msgiface.h  |   6 +
 arch/mips/netlogic/lib/netlib/include/netsoc_poe.h |   8 ++
 arch/mips/netlogic/lib/netlib/src/netsoc_api.c     |  17 +++
 arch/mips/netlogic/lib/netlib/src/netsoc_msg.c     | 141 +++++++++++++++++++++
 arch/mips/netlogic/lib/netlib/src/netsoc_v1_msg.c  | 101 +++++++++++++++
 .../netlogic/lib/syslib/include/brcm_xlp_cpu.h     |   6 +
 arch/mips/netlogic/lib/syslib/src/brcm_xlp_cpu.c   |  95 ++++++++++++++
 9 files changed, 425 insertions(+), 1 deletion(-)

diff --git a/arch/mips/netlogic/lib/netlib/include/lib_hdrs.h b/arch/mips/netlogic/lib/netlib/include/lib_hdrs.h
index c6c65b8..5bd7bbc 100644
--- a/arch/mips/netlogic/lib/netlib/include/lib_hdrs.h
+++ b/arch/mips/netlogic/lib/netlib/include/lib_hdrs.h
@@ -29,8 +29,10 @@
 
 
 #ifdef NLM_HAL_LINUX_USER
+#include <stdio.h>
 #include <stdlib.h>
 #include <stdint.h>
 #else
+#include <linux/kernel.h>
 #include <linux/types.h>
 #endif
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_msg.h b/arch/mips/netlogic/lib/netlib/include/netsoc_msg.h
index bfcf2af..f5a5832 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_msg.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_msg.h
@@ -270,6 +270,9 @@ typedef struct {
         uint32_t next_fid16;    /* 16 bit flow id to be used in re-enqueue mode */
         uint32_t channel;       /* logical channel number within the port */
         uint32_t re_enq;        /* set this to one if forward mode is one of the re-enqueue modes*/
+        uint32_t fwd_mode;	/* forward mode : used in cpu enqueue mode */
+        uint32_t rx_class;	/* POE rx class : used in cpu enqueue mode */
+        uint32_t enq_fid;	/* flow id : used in cpu enqueue mode */
         uint32_t next_fid32;    /* 32 bit flow id to be used in forward mode, valid in soc net version 1 */
         send_pkt_req_t *txreq;  /* Fill this to send packets along with poe response*/
         send_pkt_egop_t *eg_op; /* Fill this to complete any egress operation before transmitting the packet */
@@ -432,7 +435,7 @@ typedef enum {
 	POE_DROP_PKT_INPOE = 5,
 	POE_FWD_SERI_DIST_REENQ = 6,
 	POE_FWD_SERI_DEST_REENQ = 7,
-	POW_ENQUEUE = 8,	//CPU can use this mode to enqueue pkts not received from nae
+	POE_ENQUEUE = 8,	/*CPU can use this mode to enqueue pkts not received from nae*/
 }poe_fwd_mode_t;
 
 #define POE_RXDESC0_CLASS_MASK		0x7
@@ -471,6 +474,21 @@ typedef enum {
 #define POE_TXDESC0_MSGADDR_POS		16	
 #define POE_TXDESC0_FLOWID16_POS	0
 
+#define NUM_POE_DESCRIPTORS       	1
+#define XLP9XX_NUM_POE_DESCRIPTORS	2
+#define MIN_MAPPED_ENQ_CLASS_INCR	3
+
+/* For Alternative Packet Ingress: CPU Enqueue */
+#define POE_TXDESC0_CPU_ENQ_FWDMODE_MASK	0x7
+#define POE_TXDESC0_CPU_ENQ_DIST_MASK		0xF
+#define POE_TXDESC0_CPU_ENQ_DEST_MASK		0xFFF
+#define POE_TXDESC0_CPU_ENQ_FLOWID16_MASK	0xFFFF
+
+#define POE_TXDESC0_CPU_ENQ_FWDMODE_POS 	32
+#define POE_TXDESC0_CPU_ENQ_DIST_POS		28
+#define POE_TXDESC0_CPU_ENQ_DEST_POS		16
+#define POE_TXDESC0_CPU_ENQ_FLOWID16_POS	0
+
 
 /* xlp9xx */
 /* POE RX descriptor 0 */
@@ -518,6 +536,15 @@ typedef enum {
 #define NETV1_POE_TXDESC1_FLOWID32_MASK	0xFFFFFFFF
 #define NETV1_POE_TXDESC1_FLOWID32_POS	0
 
+/* For xlp9xx Alternative Packet Ingress: CPU Enqueue */
+#define NETV1_POE_TXDESC0_CPU_ENQ_FWDMODE_MASK	0x7
+#define NETV1_POE_TXDESC0_CPU_ENQ_DEST_MASK	0x1FFF
+#define NETV1_POE_TXDESC0_CPU_ENQ_FLOWID_MASK	0xFFFFFFFF
+
+#define NETV1_POE_TXDESC0_CPU_ENQ_FWDMODE_POS	45
+#define NETV1_POE_TXDESC0_CPU_ENQ_DEST_POS	32
+#define NETV1_POE_TXDESC0_CPU_ENQ_FLOWID_POS	0
+
 /* -------------- */
 
 //FBID Desc : Available in xlp9xx(soc net version 1)
@@ -745,6 +772,20 @@ static inline uint64_t poe_txdesc_fwd(uint32_t msgaddr, uint32_t fid16, uint32_t
 			((uint64_t)(next_fid16 & POE_TXDESC0_NEXTFID_MASK) << POE_TXDESC0_NEXTFID_POS));
 }
 
+static inline uint64_t poe_txdesc_cpu_enq_dest(uint32_t fwdmode, uint32_t dest, uint32_t fid16)
+{
+        return (uint64_t) (((uint64_t)(fwdmode & POE_TXDESC0_CPU_ENQ_FWDMODE_MASK) << POE_TXDESC0_CPU_ENQ_FWDMODE_POS) |
+                        ((uint64_t)(dest & POE_TXDESC0_CPU_ENQ_DEST_MASK) << POE_TXDESC0_CPU_ENQ_DEST_POS) |
+                        ((uint64_t)(fid16 & POE_TXDESC0_CPU_ENQ_FLOWID16_MASK) << POE_TXDESC0_CPU_ENQ_FLOWID16_POS));
+}
+
+static inline uint64_t poe_txdesc_cpu_enq_dist(uint32_t fwdmode, uint32_t dist, uint32_t fid16)
+{
+        return (uint64_t) (((uint64_t)(fwdmode & POE_TXDESC0_CPU_ENQ_FWDMODE_MASK) << POE_TXDESC0_CPU_ENQ_FWDMODE_POS) |
+                        ((uint64_t)(dist & POE_TXDESC0_CPU_ENQ_DIST_MASK) << POE_TXDESC0_CPU_ENQ_DIST_POS) |
+                        ((uint64_t)(fid16 & POE_TXDESC0_CPU_ENQ_FLOWID16_MASK) << POE_TXDESC0_CPU_ENQ_FLOWID16_POS));
+}
+
 
 static inline void netv1_nae_decode_rxpktinfo(uint64_t naerxdesc, nae_rx_info_t *rxpkt_info)
 {
@@ -787,6 +828,13 @@ static inline uint64_t netv1_poe_txdesc_0(uint32_t msgaddr, uint32_t fid16, uint
                         ((uint64_t)(fwdmode & NETV1_POE_TXDESC0_FWDMODE_MASK) << NETV1_POE_TXDESC0_FWDMODE_POS));
 }
 
+static inline uint64_t netv1_poe_txdesc_cpu_enq(uint32_t fid, uint32_t dest, uint32_t fwdmode)
+{
+	return (uint64_t) (((uint64_t)(fid & NETV1_POE_TXDESC0_CPU_ENQ_FLOWID_MASK) << NETV1_POE_TXDESC0_CPU_ENQ_FLOWID_POS) |
+			((uint64_t)(dest & NETV1_POE_TXDESC0_CPU_ENQ_DEST_MASK) << NETV1_POE_TXDESC0_CPU_ENQ_DEST_POS) |
+			((uint64_t)(fwdmode & NETV1_POE_TXDESC0_CPU_ENQ_FWDMODE_MASK) << NETV1_POE_TXDESC0_CPU_ENQ_FWDMODE_POS));
+}
+
 static inline uint64_t netv1_poe_txdesc_1(uint32_t nextfid32)
 {
         return (uint64_t) ((uint64_t)(nextfid32 & NETV1_POE_TXDESC1_FLOWID32_MASK) << NETV1_POE_TXDESC1_FLOWID32_POS);
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_msgiface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_msgiface.h
index 7752d7c..7de26a3 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_msgiface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_msgiface.h
@@ -46,6 +46,9 @@ extern int (*poe_send_deq2nae)(net_port_t *port, poe_enq_info_t *rcvd_enq_info,
 extern int (*poe_send_deq)(net_port_t *port, poe_enq_info_t *rcvd_enq_info);
 extern int (*poe_send_resp)(net_port_t *port, poe_fwd_mode_t fwd_mode, poe_enq_info_t *rcvd_enq_info, poe_resp_t *resp);
 
+extern int (*poe_send_resp_cpu_enq)(net_port_t *port, poe_resp_t *resp, uint64_t *fwdmsg, int size);
+extern int (*poe_send_resp_reenq_fwd)(net_port_t *port, poe_fwd_mode_t fwd_mode, poe_enq_info_t *rcvd_enq_info, poe_resp_t *resp, uint64_t *fwdmsg, int size);
+
 #define netsoc_enq_pkt_recv         enq_pkt_recv
 #define netsoc_noenq_pkt_recv       noenq_pkt_recv
 #define netsoc_nae_recv             pkt_recv
@@ -53,6 +56,9 @@ extern int (*poe_send_resp)(net_port_t *port, poe_fwd_mode_t fwd_mode, poe_enq_i
 #define netsoc_poe_send_deq         poe_send_deq
 #define netsoc_poe_send_resp        poe_send_resp
 
+#define netsoc_poe_send_resp_cpu_enq		poe_send_resp_cpu_enq
+#define netsoc_poe_send_resp_reenq_fwd		poe_send_resp_reenq_fwd
+
 /**
 * @brief netsoc_nae_send_freein_buf function is used to send a freein buffer to NAE free in descriptor queue
 * 
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_poe.h b/arch/mips/netlogic/lib/netlib/include/netsoc_poe.h
index c58e7ea..cb71934 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_poe.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_poe.h
@@ -268,6 +268,14 @@ static inline int __netsoc_poe_config_class_map(poe_t *poe, class_map_t mode)
         return 0; 
 }
 
+static inline int __netsoc_poe_read_class_map(poe_t *poe)
+{
+	uint32_t mode;
+
+	mode = netsoc_read_poe_pcie_reg (poe->pcie_base, POE_CPUENQ_CLASS_MAP_MODE);
+	return (mode & 0xf);
+}
+
 /**
  * @brief reset_poe function resets the POE.
  *
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
index 661d863..2a0bb3b 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
@@ -1461,6 +1461,23 @@ int netsoc_poe_map_cpuclass(poe_t *poe, class_map_t mode)
 	return __netsoc_poe_config_class_map(poe, mode);
 }
 
+/**
+* @brief netsoc_get_poe_cpuclass_map function is used to read mapped class for cpu enqueue mode operation.
+* 	Classes that are mapped to CPU can not be be used by NAE
+* 
+* @param [in] poe Pointer to poe
+*
+* @return
+*       - mapped class number of cpu enqueue mode
+* 
+* @ingroup hal_nae
+*
+*/
+int netsoc_get_poe_cpuclass_map(poe_t *poe)
+{
+	return __netsoc_poe_read_class_map(poe);
+}
+
 /* ALE specific configuration in NAE */
 /**
 * @brief netsoc_config_string_offset function is used to configure the offset to destination
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_msg.c b/arch/mips/netlogic/lib/netlib/src/netsoc_msg.c
index 93dbfa8..1020b9e 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_msg.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_msg.c
@@ -32,6 +32,7 @@
 #include "nlm_nae.h"
 #include "nlm_hal_fmn_dp.h"
 #include "netsoc_msgiface.h"
+#include "netsoc_poe.h"
 
 int (*enq_pkt_recv)(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_recv_info_t *pkt_info, poe_enq_info_t *rcvd_enq_info);
 int (*noenq_pkt_recv)(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_recv_info_t *pkt_info);
@@ -40,12 +41,18 @@ int (*poe_send_deq2nae)(net_port_t *port, poe_enq_info_t *rcvd_enq_info, uint32_
 int (*poe_send_deq)(net_port_t *port, poe_enq_info_t *rcvd_enq_info);
 int (*poe_send_resp)(net_port_t *port, poe_fwd_mode_t fwd_mode, poe_enq_info_t *rcvd_enq_info, poe_resp_t *resp);
 
+int (*poe_send_resp_cpu_enq)(net_port_t *port, poe_resp_t *resp, uint64_t *fwdmsg, int size);
+int (*poe_send_resp_reenq_fwd)(net_port_t *port, poe_fwd_mode_t fwd_mode, poe_enq_info_t *rcvd_enq_info, poe_resp_t *resp, uint64_t *fwdmsg, int size);
+
 extern int netsoc_v1_noenq_pkt_recv(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_recv_info_t *pkt_info);
 extern int netsoc_v1_enq_pkt_recv(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_recv_info_t *pkt_info, poe_enq_info_t *rcvd_enq_info);
 extern int netsoc_v1_nae_recv(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_recv_info_t *pkt_info, poe_enq_info_t *rcvd_enq_info);
 extern int netsoc_v1_poe_send_deq2nae(net_port_t *port, poe_enq_info_t *rcvd_enq_info, uint32_t rxmsg);
 extern int netsoc_v1_poe_send_deq(net_port_t *port, poe_enq_info_t *rcvd_enq_info);
 extern int netsoc_v1_poe_send_resp(net_port_t *port, poe_fwd_mode_t fwd_mode, poe_enq_info_t *rcvd_enq_info, poe_resp_t *resp);
+extern int netsoc_v1_poe_send_resp_cpu_enq(net_port_t *port, poe_resp_t *resp, uint64_t *fwdmsg, int size);
+extern int netsoc_v1_poe_send_resp_reenq_fwd(net_port_t *port, poe_fwd_mode_t fwd_mode, poe_enq_info_t *rcvd_enq_info, poe_resp_t *resp, uint64_t *fwdmsg, int size);
+extern int netsoc_get_poe_cpuclass_map(poe_t *poe);
 
 
 /**
@@ -595,6 +602,136 @@ int netsoc_poe_send_resp_fwddist_1(net_port_t *port, poe_enq_info_t *rcvd_enq_in
 }
 
 /**
+ * @brief netsoc_v0_poe_send_resp_cpu_enq function is used to enqueue a packet into the POE from CPU
+ * (Alternate Packet Ingress - CPU Enqueue) 
+ * 
+ * @param [in] port Pointer to net_port_t
+ * @param [in] resp Pointer to poe_resp_t
+ * @param [in] fwdmsg pointer to NAE descriptor to be sent to NAE 
+ * @param [in] size number of nae descriptors
+ * 
+ * @return   
+ *       - 0 
+ * 
+ * @ingroup hal_nae
+ * 
+ */
+
+int netsoc_v0_poe_send_resp_cpu_enq(net_port_t *port, poe_resp_t *resp, uint64_t *fwdmsg, int size)
+{
+	uint64_t msg0;
+
+	switch (resp->fwd_mode)
+	{
+		case POE_FWD_PARA_DEST_REENQ:
+		case POE_FWD_SERI_DEST_REENQ:
+			msg0 = poe_txdesc_cpu_enq_dest(resp->fwd_mode, resp->next_dest, resp->enq_fid);
+			break;
+		case POE_FWD_PARA_DIST_REENQ:
+		case POE_FWD_SERI_DIST_REENQ:
+			msg0 = poe_txdesc_cpu_enq_dist(resp->fwd_mode, resp->next_dist, resp->enq_fid);
+			break;
+		default:
+			fmndbg("%s: Invalid poe enq mode %d\n", __func__, resp->fwd_mode);
+			return -1;
+	}
+#ifdef NETSOC_MSG_DEBUG
+	fmndbg("%s msg0 0x%llx Q: %d, size %d, map %d\n",__func__, msg0, (port->poe_queue_base + resp->rx_class), 
+		size, netsoc_get_poe_cpuclass_map(port->nae->poe));
+#endif
+	
+	switch (size + NUM_POE_DESCRIPTORS)
+	{
+		case 4:
+			xlp_message_send_block_fast((size + NUM_POE_DESCRIPTORS), POE_ENQUEUE,
+				(port->poe_queue_base + resp->rx_class + MIN_MAPPED_ENQ_CLASS_INCR + netsoc_get_poe_cpuclass_map(port->nae->poe)),
+				msg0, fwdmsg[0], fwdmsg[1], fwdmsg[2]);
+			break;
+		case 3:
+			xlp_message_send_block_fast_3(POE_ENQUEUE,
+				(port->poe_queue_base + resp->rx_class + MIN_MAPPED_ENQ_CLASS_INCR + netsoc_get_poe_cpuclass_map(port->nae->poe)),
+				msg0, fwdmsg[0], fwdmsg[1]);
+			break;
+		case 2:
+			xlp_message_send_block_fast_2(POE_ENQUEUE,
+				(port->poe_queue_base + resp->rx_class + MIN_MAPPED_ENQ_CLASS_INCR + netsoc_get_poe_cpuclass_map(port->nae->poe)),
+				msg0, fwdmsg[0]);
+			break;
+		case 1:
+			xlp_message_send_block_fast_1(POE_ENQUEUE,
+				(port->poe_queue_base + resp->rx_class + MIN_MAPPED_ENQ_CLASS_INCR + netsoc_get_poe_cpuclass_map(port->nae->poe)), msg0);
+			break;
+		default:
+			fmndbg("Invalid size number. size %d\n", size);
+			return -1;
+	}
+	return 0;
+}
+
+/**
+ * @brief netsoc_v0_poe_send_resp_reenq_fwd function is used to re-enqueue packet to different destination.
+ * Both destination or distribution vector mode can be used
+ * 
+ * @param [in] port Pointer to net_port_t
+ * @param [in] fwd_mode  POE forward mode
+ * @param [in] rcvd_enq_info Pointer to poe_enq_info_t.  
+ * @param [in] resp Pointer to poe_resp_t
+ * @param [in] fwdmsg NAE descriptor to be sent to NAE 
+ * @param [in] size number nae of descriptors
+ * 
+ * @return   
+ *       - 0 
+ * 
+ * @ingroup hal_nae
+ * 
+ */
+
+int netsoc_v0_poe_send_resp_reenq_fwd(net_port_t *port, poe_fwd_mode_t fwd_mode, poe_enq_info_t *rcvd_enq_info, poe_resp_t *resp, uint64_t *fwdmsg, int size)
+{
+	uint64_t msg0;
+
+	switch (fwd_mode)
+	{
+		case POE_FWD_PARA_DEST_REENQ:
+		case POE_FWD_SERI_DEST_REENQ:
+			msg0 = poe_txdesc_dest(resp->next_fid16, resp->next_dest,
+					rcvd_enq_info->descaddr, rcvd_enq_info->fid16);
+			break;
+		case POE_FWD_PARA_DIST_REENQ:
+		case POE_FWD_SERI_DIST_REENQ:
+			msg0 = poe_txdesc_dist(resp->next_fid16, resp->next_dist,
+					rcvd_enq_info->descaddr, rcvd_enq_info->fid16);
+			break;
+		default:
+			fmndbg("%s: Invalid poe enq mode %d\n", __func__, fwd_mode);
+			return -1;
+	}
+#ifdef NETSOC_MSG_DEBUG
+	fmndbg("%s msg0 0x%llx Q: %d, size %d\n",__func__, msg0, (port->poe_queue_base + rcvd_enq_info->rxclass), size);
+#endif
+	switch (size + NUM_POE_DESCRIPTORS)
+	{
+		case 4:
+			xlp_message_send_block_fast((size + NUM_POE_DESCRIPTORS), fwd_mode, (port->poe_queue_base + rcvd_enq_info->rxclass), msg0,
+				fwdmsg[0], fwdmsg[1], fwdmsg[2]);
+			break;
+		case 3:
+			xlp_message_send_block_fast_3(fwd_mode, (port->poe_queue_base + rcvd_enq_info->rxclass), msg0, fwdmsg[0], fwdmsg[1]);
+			break;
+		case 2:
+			xlp_message_send_block_fast_2(fwd_mode, (port->poe_queue_base + rcvd_enq_info->rxclass), msg0, fwdmsg[0]);
+			break;
+		case 1:
+			xlp_message_send_block_fast_1(fwd_mode, (port->poe_queue_base + rcvd_enq_info->rxclass), msg0);
+			break;
+		default:
+			fmndbg("Invalid size number. size %d\n", size);
+			return -1;
+	} 
+	return 0;
+}
+
+/**
 * @brief netsoc_poe_send_resp_fwddest_2 function is used to forward enqueued packet to different destination using 
 *        fixed destination method  
 * 
@@ -776,6 +913,8 @@ void update_netsoc_msgiface(int version)
         poe_send_deq2nae = netsoc_v0_poe_send_deq2nae;
         poe_send_deq = netsoc_v0_poe_send_deq;
         poe_send_resp = netsoc_v0_poe_send_resp;        
+        poe_send_resp_cpu_enq = netsoc_v0_poe_send_resp_cpu_enq;
+        poe_send_resp_reenq_fwd = netsoc_v0_poe_send_resp_reenq_fwd;
      }
      else {
         enq_pkt_recv = netsoc_v1_enq_pkt_recv;
@@ -784,6 +923,8 @@ void update_netsoc_msgiface(int version)
         poe_send_deq2nae = netsoc_v1_poe_send_deq2nae;
         poe_send_deq = netsoc_v1_poe_send_deq;
         poe_send_resp = netsoc_v1_poe_send_resp;
+        poe_send_resp_cpu_enq = netsoc_v1_poe_send_resp_cpu_enq;
+        poe_send_resp_reenq_fwd = netsoc_v1_poe_send_resp_reenq_fwd;
      }
 
 }
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_v1_msg.c b/arch/mips/netlogic/lib/netlib/src/netsoc_v1_msg.c
index ebe1b43..edb8f9d3 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_v1_msg.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_v1_msg.c
@@ -31,6 +31,9 @@
 #include "netsoc_msg.h"
 #include "nlm_nae.h"
 #include "nlm_hal_fmn_dp.h"
+#include "netsoc_poe.h"
+
+extern int netsoc_get_poe_cpuclass_map(poe_t *poe);
 
 /**
 * @brief netsoc_nae_send_p2d_and_rtn2dest function is used to send a packet and configures NAE to return the 40 bit
@@ -434,6 +437,104 @@ int netsoc_v1_poe_send_resp_fwddist_1(net_port_t *port, poe_enq_info_t *rcvd_enq
 }
 
 /**
+ * @brief netsoc_v1_poe_send_resp_cpu_enq function is used to enqueue a packet into the POE from CPU
+ * (Alternate Packet Ingress - CPU Enqueue)
+ * 
+ * @param [in] port Pointer to net_port_t
+ * @param [in] resp Pointer to poe_resp_t
+ * @param [in] fwdmsg pointer to NAE descriptor to be sent to NAE 
+ * @param [in] size number of nae descriptors
+ * 
+ * @return   
+ *       - 0 
+ * 
+ * @ingroup hal_nae
+ * 
+ */
+
+int netsoc_v1_poe_send_resp_cpu_enq(net_port_t *port, poe_resp_t *resp, uint64_t *fwdmsg, int size)
+{
+	uint64_t msg0, msg1;
+
+	msg0 = netv1_poe_txdesc_cpu_enq(resp->fwd_mode, resp->next_dest, resp->enq_fid);
+	msg1 = 0;
+#ifdef NETSOC_MSG_DEBUG
+	fmndbg("%s msg0 0x%llx Q: %d, size %d, dest %d fwd_mode %d\n",__func__, msg0,
+		(port->poe_queue_base + resp->rx_class), size, resp->next_dest, resp->fwd_mode);
+#endif
+	switch (size + XLP9XX_NUM_POE_DESCRIPTORS)
+	{
+		case 4:
+			xlp_message_send_block_fast((size + XLP9XX_NUM_POE_DESCRIPTORS), POE_ENQUEUE,
+				(port->poe_queue_base + resp->rx_class + MIN_MAPPED_ENQ_CLASS_INCR + netsoc_get_poe_cpuclass_map(port->nae->poe)),
+				msg0, msg1, fwdmsg[0], fwdmsg[1]);
+			break;
+		case 3:
+			xlp_message_send_block_fast_3(POE_ENQUEUE,
+				(port->poe_queue_base + resp->rx_class + MIN_MAPPED_ENQ_CLASS_INCR + netsoc_get_poe_cpuclass_map(port->nae->poe)),
+				msg0, msg1, fwdmsg[0]);
+			break;
+		case 2:
+			xlp_message_send_block_fast_2(POE_ENQUEUE,
+				(port->poe_queue_base + resp->rx_class + MIN_MAPPED_ENQ_CLASS_INCR + netsoc_get_poe_cpuclass_map(port->nae->poe)),
+				msg0, msg1);
+			break;
+		default:
+			fmndbg("Invalid size number. size %d\n", size);
+			return -1;
+	} 
+	return 0;
+}
+
+/**
+ * @brief netsoc_v1_poe_send_resp_reenq_fwd function is used to re-enqueue packet to different destination.
+ * Both destination or distribution vector mode can be used
+ * 
+ * @param [in] port Pointer to net_port_t
+ * @param [in] fwd_mode  POE forward mode
+ * @param [in] rcvd_enq_info Pointer to poe_enq_info_t.  
+ * @param [in] resp Pointer to poe_resp_t
+ * @param [in] fwdmsg NAE descriptor to be sent to NAE 
+ * @param [in] size number of nae descriptors
+ * 
+ * @return   
+ *       - 0 
+ * 
+ * @ingroup hal_nae
+ * 
+ */
+
+int netsoc_v1_poe_send_resp_reenq_fwd(net_port_t *port, poe_fwd_mode_t fwd_mode, poe_enq_info_t *rcvd_enq_info, poe_resp_t *resp, uint64_t *fwdmsg, int size)
+{
+	uint64_t msg0, msg1;
+	uint32_t dest;
+
+	msg0 = netv1_poe_txdesc_0(rcvd_enq_info->descaddr, rcvd_enq_info->fid16, resp->next_dest, fwd_mode);
+	msg1 = netv1_poe_txdesc_1(resp->next_fid32);
+#ifdef NETSOC_MSG_DEBUG
+	fmndbg("%s msg0 0x%llx msg1 0x%llx Q: %d, size %d, dest %d fwd_mode %d\n",__func__, msg0, msg1,
+		(port->poe_queue_base + rcvd_enq_info->rxclass), size, resp->next_dest, fwd_mode);
+#endif
+	switch (size + XLP9XX_NUM_POE_DESCRIPTORS)
+	{
+		case 4:
+			xlp_message_send_block_fast((size + XLP9XX_NUM_POE_DESCRIPTORS), fwd_mode, (port->poe_queue_base + rcvd_enq_info->rxclass),
+				msg0, msg1, fwdmsg[0], fwdmsg[1]);
+			break;
+		case 3:
+			xlp_message_send_block_fast_3(fwd_mode, (port->poe_queue_base + rcvd_enq_info->rxclass), msg0, msg1, fwdmsg[0]);
+			break;
+		case 2:
+			xlp_message_send_block_fast_2(fwd_mode, (port->poe_queue_base + rcvd_enq_info->rxclass), msg0, msg1);
+			break;
+		default:
+			fmndbg("Invalid size number. size %d\n", size);
+			return -1;
+	} 
+	return 0;
+}
+
+/**
 * @brief netsoc_v1_poe_send_resp_fwddest_2 function is used to forward enqueued packet to different destination using 
 *        fixed destination method  
 * 
diff --git a/arch/mips/netlogic/lib/syslib/include/brcm_xlp_cpu.h b/arch/mips/netlogic/lib/syslib/include/brcm_xlp_cpu.h
index 674d1f2..cbce7e4 100644
--- a/arch/mips/netlogic/lib/syslib/include/brcm_xlp_cpu.h
+++ b/arch/mips/netlogic/lib/syslib/include/brcm_xlp_cpu.h
@@ -51,10 +51,16 @@
 #define XLP3XX_MAX_CPU_PER_NODE 	16
 #define XLP2XX_MAX_CPU_PER_NODE 	8
 
+#define XLP_MAX_POE_PERNODE        	1
+#define XLP9XX_MAX_POE_PERNODE          2
+
 #ifndef __ASSEMBLY__
 
 inline int brcm_get_max_cpu_num(void);
 inline int brcm_get_max_node_num(void);
+inline int brcm_get_popq_vc_base(void);
+inline int brcm_get_poe_vc_base(int poe_blk);
+inline uint64_t brcm_get_poe_pcie_base(int node, int poe_block);
 
 #endif /* __ASSEMBLY__ */
 
diff --git a/arch/mips/netlogic/lib/syslib/src/brcm_xlp_cpu.c b/arch/mips/netlogic/lib/syslib/src/brcm_xlp_cpu.c
index c023ad2..0d5fa1e 100644
--- a/arch/mips/netlogic/lib/syslib/src/brcm_xlp_cpu.c
+++ b/arch/mips/netlogic/lib/syslib/src/brcm_xlp_cpu.c
@@ -34,8 +34,10 @@
  *
  * #BRCM_4# */
 
+#include <nlm_hal.h>
 #include <brcm_xlp_cpu.h>
 #include <nlm_hal_xlp_dev.h>
+#include <nlm_hal_macros.h>
 
 /**
  * @brief brcm_get_max_cpu_num - return the total number of cpus on a chip
@@ -90,3 +92,96 @@ inline int brcm_get_max_node_num(void)
 	}
 	return max_node;
 }
+
+/**
+ * @brief brcm_get_popq_vc_base- return the popq vc base
+ *
+ * @param [in]	- none
+ *
+ * @return
+ * 	  - POPQ vc base id
+ *
+ * @see brcm_get_poe_vc_base 
+ **/
+
+inline int brcm_get_popq_vc_base(void)
+{
+	if (is_nlm_xlp9xx()) {
+		return XLP_9XX_POPQ_VC_BASE;
+	} else {
+		return XLP_POPQ_VC_BASE;
+	}
+}
+
+/**
+ * @brief brcm_get_poe_vc_base- return the pop vc base
+ *
+ * @param poe_blk - poe block number
+ *
+ * @return
+ * 	  - POE vc base id
+ *
+ * @see brcm_get_popq_vc_base 
+ **/
+
+inline int brcm_get_poe_vc_base(int poe_blk)
+{
+	if(is_nlm_xlp9xx()) {
+		if (poe_blk == 0) {
+			return XLP_9XX_POE0_VC_BASE;
+		} else {
+			if (poe_blk > (XLP9XX_MAX_POE_PERNODE - 1)) {
+				nlm_print("invalid poe block number\n");
+				return -1;
+			}
+			return XLP_9XX_POE1_VC_BASE;
+		}
+	} else {
+		if (poe_blk > (XLP_MAX_POE_PERNODE - 1)) {
+			nlm_print("invalid poe block number\n");
+			return -1;
+		}
+		return XLP_POE_VC_BASE;
+	}
+}
+
+/**
+ * @brief brcm_get_poe_pcie_base- return the poe pcie base address
+ *
+ * @param [in] node: node number
+ * @param [in] poe_blk: poe block number (0/1)
+ *
+ * @return
+ * 	- success: poe pcie base address
+ * 	- failure: < 0
+ *
+ * @note - nlm_hal_init() should be called before calling this function
+ **/
+
+inline uint64_t brcm_get_poe_pcie_base(int node, int poe_block)
+{
+	uint32_t bus;
+	uint64_t poe_pcie_base;
+
+	if (node > (brcm_get_max_node_num() - 1)) {
+		nlm_print("%s invalid node number %d\n", __func__, node);
+		return -1;
+	}
+	bus = (is_nlm_xlp9xx()) ? 1 : 0 ;
+	if (poe_block == 0) {
+		if (is_nlm_xlp9xx()) {
+			poe_pcie_base = xlp9xx_poe0_base[node];
+		} else {
+			poe_pcie_base = nlm_hal_get_dev_base(node, bus, XLP_POE_DEVICE, XLP_POE_FUNC);
+		}
+	}
+	else {
+		if ((!is_nlm_xlp9xx()) || (poe_block > (XLP9XX_MAX_POE_PERNODE - 1))) {
+			nlm_print("%s invalid poe block number %d\n", __func__, poe_block);
+			return -1;
+		}
+		poe_pcie_base = xlp9xx_poe1_base[node];
+	}
+	return poe_pcie_base;
+}
+
-- 
1.9.1

