From 25cb28c1fa6bf5f5ac570b2e41ef9afeba312127 Mon Sep 17 00:00:00 2001
From: kopal <kopal@broadcom.com>
Date: Fri, 22 Aug 2014 15:46:30 +0530
Subject: [PATCH 1458/1532] nae: fix to report correct ifconfig FLAGS.

provided a fix for the issue where ifconfig output for an interface used to
show RUNNING flag even when there was no network cable connected.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/xlpge_init.h |  2 +-
 drivers/net/ethernet/broadcom/nae/xlpge_nae.c  | 27 ++++++++++++++++----------
 2 files changed, 18 insertions(+), 11 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_init.h b/drivers/net/ethernet/broadcom/nae/xlpge_init.h
index 59892f9..342f853 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_init.h
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_init.h
@@ -45,7 +45,7 @@ extern int replenish_freein_fifos(void);
 extern int nlm_xlp_enable_napi(void);
 extern void  get_mac_address(char * const);
 extern int xlpge_eeprom_init(void);
-extern int nlm_per_port_nae_init(nae_t* nae_cfg, int port, int maxnae, char * const);
+extern int nlm_per_port_nae_init(nae_t* nae_cfg, int port, int maxnae, char * const,int port_index);
 extern int initialize_nae_per_node(nae_t * nae_cfg, uint32_t *phys_cpu_map,
                                 int mode, int *jumbo_enabled);
 
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_nae.c b/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
index af3cc24..0ba1e28 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
@@ -846,10 +846,20 @@ static int nlm_xlp_port_poll(void *buff)
 				for(i=0; i < nae_cfg->num_ports; i++, port_index++) {
 					tmp=arr[node][port_index];
 					arr[node][port_index]=netsoc_get_phy_status(&nae_cfg->ports[i],&speed,&duplex);
-					if ((arr[node][port_index]>-1)&&(arr[node][port_index] > tmp))
+					if ((arr[node][port_index]>-1)&&(arr[node][port_index] > tmp)){
 						netsoc_start_autoneg(&nae_cfg->ports[i]);
-					else
+						if(nae_cfg->ports[i].link_stat==1)
+							netif_carrier_on(xlp_dev_mac[node][port_index]);
+						else
+							netif_carrier_off(xlp_dev_mac[node][port_index]);
+					}
+					else {
+						if(nae_cfg->ports[i].link_stat==1)
+                                                        netif_carrier_on(xlp_dev_mac[node][port_index]);
+                                                else
+                                                        netif_carrier_off(xlp_dev_mac[node][port_index]);
 						continue;
+					}
 				}
 			}
 		}
@@ -1422,14 +1432,12 @@ static const struct net_device_ops nlm_xlp_nae_ops = {
 	.ndo_select_queue		= nlm_select_queue,
 };
 
-int nlm_per_port_nae_init(nae_t* nae_cfg, int port, int maxnae, char * const mac_addr)
+int nlm_per_port_nae_init(nae_t* nae_cfg, int port, int num_nae, char * const mac_addr,int port_index)
 {
 	struct net_device *dev;
 	struct dev_data *priv;
 	int cpu;
 	int node = nae_cfg->node;
-	static int port_index = 0;
-
 	if (!nae_cfg->ports[port].valid)
 		return -1;
 
@@ -1462,7 +1470,6 @@ int nlm_per_port_nae_init(nae_t* nae_cfg, int port, int maxnae, char * const mac
 	priv->block	= nae_cfg->ports[port].hw_port_id / 4;
 	priv->type	= nae_cfg->ports[port].iftype;
 	priv->mgmt_port	= nae_cfg->ports[port].mgmt;
-	priv->port_index = port_index++;
 
 	switch(nae_cfg->ports[port].iftype) {
 	case SGMII_IF:
@@ -1499,8 +1506,8 @@ int nlm_per_port_nae_init(nae_t* nae_cfg, int port, int maxnae, char * const mac
 	dev->features |= NETIF_F_LLTX;
 
 	register_netdev(dev);
+	xlp_dev_mac[node][port_index] = dev;
 
-	//xlp_dev_mac[node][port] = dev;
 	//xlp_mac_setup_hwaddr(priv);
 
 #ifdef IEEE_1588_PTP_ENABLED
@@ -1607,7 +1614,7 @@ void nlm_xlp_nae_init(void)
 	get_mac_address(hw_mac_addr);
 	maxnae = get_num_nae_pernode();
 	for (node = 0; node < NLM_MAX_NODES; node++) {
-		int num_nae;
+		int num_nae,port_index=0;;
 		for(num_nae=0; num_nae<maxnae; num_nae++){
 			nae_cfg = get_nae(node, num_nae);
 			if (nae_cfg == NULL)
@@ -1621,8 +1628,8 @@ void nlm_xlp_nae_init(void)
                 __netsoc_prepad_enable(nae_cfg, 64);
 #endif
 
-			for(i = 0; i < nae_cfg->num_ports; i++) {
-				nlm_per_port_nae_init(nae_cfg, i, maxnae, hw_mac_addr);
+			for(i = 0; i < nae_cfg->num_ports; i++, port_index++) {
+				nlm_per_port_nae_init(nae_cfg, i, num_nae, hw_mac_addr,port_index);
 				hw_mac_addr[5]++;
 				if(!(nae_cfg->port_fifo_en))
 					netsoc_map_interface_to_lifo(nae_cfg, i, 0xffff);
-- 
1.9.1

