From 4b28ff45a0203140b0d8683500c27c3acc7d03b3 Mon Sep 17 00:00:00 2001
From: kopal <kopal@broadcom.com>
Date: Fri, 28 Nov 2014 11:47:42 +0530
Subject: [PATCH 0155/1532] max6653: added temperature sensor driver for XLP9XX

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/hwmon/Kconfig   |   8 +
 drivers/hwmon/Makefile  |   1 +
 drivers/hwmon/max6653.c | 412 ++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 421 insertions(+)
 create mode 100644 drivers/hwmon/max6653.c

diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 6352ec2..ddde821 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -728,6 +728,14 @@ config SENSORS_LM90
 	  This driver can also be built as a module.  If so, the module
 	  will be called lm90.
 
+config SENSORS_MAX6653
+	tristate "max6653 sensor/fan driver"
+	depends on I2C
+	help
+          If you say yes here you get support for max6653 sensor and fan.
+	  This driver can also be built as a module.  If so, the module
+          will be called max6653.
+
 config SENSORS_LM92
 	tristate "National Semiconductor LM92 and compatibles"
 	depends on I2C
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index 486f02a..fc2a593 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -88,6 +88,7 @@ obj-$(CONFIG_SENSORS_LM83)	+= lm83.o
 obj-$(CONFIG_SENSORS_LM85)	+= lm85.o
 obj-$(CONFIG_SENSORS_LM87)	+= lm87.o
 obj-$(CONFIG_SENSORS_LM90)	+= lm90.o
+obj-$(CONFIG_SENSORS_MAX6653)   += max6653.o
 obj-$(CONFIG_SENSORS_LM92)	+= lm92.o
 obj-$(CONFIG_SENSORS_LM93)	+= lm93.o
 obj-$(CONFIG_SENSORS_LM95234)	+= lm95234.o
diff --git a/drivers/hwmon/max6653.c b/drivers/hwmon/max6653.c
new file mode 100644
index 0000000..103c62a
--- /dev/null
+++ b/drivers/hwmon/max6653.c
@@ -0,0 +1,412 @@
+/*
+   max6653.c driver.
+
+   Based on lm90.c and
+      http://lists.lm-sensors.org/pipermail/lm-sensors/attachments/20040910/409a6435/attachment.bin
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+
+/*
+ * MAX 6653/6663/6664 registers
+ */
+
+#define MAX6653_REG_CFG1        0x00
+#define MAX6653_REG_CFG2        0x01
+#define MAX6653_REG_STAT1       0x02
+#define MAX6653_REG_STAT2       0x03
+#define MAX6653_REG_EXTTMP      0x06
+#define MAX6653_REG_LCLTMP    	0x0A
+#define MAX6653_REG_REMTMP    	0x0B
+#define MAX6653_REG_LCLTMP_OFF  0x0D
+#define MAX6653_REG_REMTMP_OFF  0x0E
+#define MAX6653_REG_LCLTMP_HI   0x14
+#define MAX6653_REG_LCLTMP_LO   0x15
+#define MAX6653_REG_LCLTMP_THRM 0x16
+#define MAX6653_REG_REMTMP_HI   0x18
+#define MAX6653_REG_REMTMP_LO   0x19
+#define MAX6653_REG_REMTMP_THRM 0x1A
+#define MAX6653_REG_LCLTMP_SD   0x1B
+#define MAX6653_REG_REMTMP_SD   0x1C
+#define MAX6653_REG_DEVID       0x3D
+#define MAX6653_REG_MANID       0x3E
+#define MAX6653_REG_THRMREV     0x3F
+
+#define MAX6653_CFG1_MONITOR_ENABLE 0x01
+#define TEMP_LIMIT_TO_REG(val)  clamp_val((val) / 1000, 0, 255)
+/*
+ * Config register 2 bits
+ */
+#define MAX6653_CFG2_RESET          0x80
+#define MAX6653_CFG2_RSVD           0x40
+#define MAX6653_CFG2_REM_TMP_ENABLE 0x20
+#define MAX6653_CFG2_LCL_TMP_ENABLE 0x10
+#define MAX6653_CFG2_INT_INPUT_FUNC 0x08
+#define MAX6653_CFG2_TACH_ENABLE    0x04
+#define MAX6653_CFG2_SMB_TO_ENABLE  0x02
+#define MAX6653_CFG2_PWM_OUT_ENABLE 0x01
+
+
+static int max6653_probe(struct i2c_client *client,
+                         const struct i2c_device_id *id);
+static int max6653_init_client(struct i2c_client *client);
+static struct max6653_data *max6653_update_device(struct device *dev);
+static int max6653_read(struct i2c_client *client, u8 reg);
+static int max6653_write(struct i2c_client *client, u8 reg, u8 value);
+static int max6653_remove(struct i2c_client *client);
+
+static const struct i2c_device_id max6653_id[] = {
+        { "max6653", 1},
+        { }
+};
+
+MODULE_DEVICE_TABLE(i2c, max6653_id);
+
+static struct i2c_driver max6653_driver = {
+        .class          = I2C_CLASS_HWMON,
+	.driver = {
+                .name   = "max6653",
+        },
+        .probe          = max6653_probe,
+        .remove         = max6653_remove,
+        .id_table       = max6653_id,
+};
+
+struct max6653_data {
+        struct device *hwmon_dev;
+        struct mutex update_lock;
+        int nr_fans;
+        char valid; /* zero until following fields are valid */
+        unsigned long last_updated; /* in jiffies */
+
+	/* register values */
+        u8 config1;
+        u8 config2;
+        u8 extbits;
+        u8 temp_input[2];
+        u8 temp_min[2];
+        u8 temp_max[2];
+        u8 temp_crit[2];
+	u8 alarm;
+};
+
+static ssize_t show_temp_min(struct device *dev, struct device_attribute *devattr,
+                          char *buf)
+{
+	long temp;
+        struct max6653_data *data = max6653_update_device(dev);
+        struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+
+        if (IS_ERR(data))
+                return PTR_ERR(data);
+
+        temp = data->temp_min[attr->index] * 1000;
+        return sprintf(buf, "%ld\n", temp);
+
+}
+
+static ssize_t show_temp_max(struct device *dev, struct device_attribute *devattr,
+                          char *buf)
+{
+	long temp;
+        struct max6653_data *data = max6653_update_device(dev);
+        struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+
+        if (IS_ERR(data))
+                return PTR_ERR(data);
+
+        temp = data->temp_max[attr->index] * 1000;
+        return sprintf(buf, "%ld\n", temp);
+
+}
+
+static ssize_t show_temp_input(struct device *dev, struct device_attribute *devattr,
+                          char *buf)
+{
+	long temp;
+        struct max6653_data *data = max6653_update_device(dev);
+        struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+        if (IS_ERR(data))
+                return PTR_ERR(data);
+
+        temp = data->temp_input[attr->index] *1000 ;
+	return sprintf(buf, "%ld\n", temp);
+
+}
+
+static ssize_t show_temp_crit(struct device *dev, struct device_attribute *devattr,
+                          char *buf)
+{
+	long temp;
+        struct max6653_data *data = max6653_update_device(dev);
+        struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+
+        if (IS_ERR(data))
+                return PTR_ERR(data);
+
+        temp = data->temp_crit[attr->index] * 1000;
+        return sprintf(buf, "%ld\n", temp);
+
+}
+
+static ssize_t show_alarm(struct device *dev, struct device_attribute
+                          *devattr, char *buf)
+{
+        struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+        struct max6653_data *data = max6653_update_device(dev);
+        int bitnr = attr->index;
+
+        return sprintf(buf, "%d\n", (data->alarm >> bitnr) & 1);
+}
+
+static ssize_t set_temp_min(struct device *dev,
+                            struct device_attribute *devattr,
+                            const char *buf, size_t count)
+{
+        static const u8 reg[2] = {
+		MAX6653_REG_LCLTMP_LO,
+		MAX6653_REG_REMTMP_LO,
+        };
+        struct i2c_client *client = to_i2c_client(dev);
+        struct max6653_data *data = i2c_get_clientdata(client);
+        struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+        unsigned long val;
+        int res;
+        int nr = attr->index;
+        res = kstrtoul(buf, 10, &val);
+        if (res)
+                return res;
+
+        mutex_lock(&data->update_lock);
+        data->temp_min[nr] = TEMP_LIMIT_TO_REG(val);
+        max6653_write(client,reg[nr],
+                                data->temp_min[nr]);
+        mutex_unlock(&data->update_lock);
+        return count;
+}
+
+static ssize_t set_temp_max(struct device *dev,
+                            struct device_attribute *devattr,
+                            const char *buf, size_t count)
+{
+        static const u8 reg[2] = {
+		MAX6653_REG_LCLTMP_HI,
+		MAX6653_REG_REMTMP_HI,
+        };
+        struct i2c_client *client = to_i2c_client(dev);
+        struct max6653_data *data = i2c_get_clientdata(client);
+        struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+        unsigned long val;
+        int res;
+        int nr = attr->index;
+        res = kstrtoul(buf, 10, &val);
+        if (res)
+                return res;
+
+        mutex_lock(&data->update_lock);
+        data->temp_max[nr] = TEMP_LIMIT_TO_REG(val);
+        max6653_write(client,reg[nr],
+                                data->temp_max[nr]);
+        mutex_unlock(&data->update_lock);
+        return count;
+}
+
+static ssize_t set_temp_crit(struct device *dev,
+                            struct device_attribute *devattr,
+                            const char *buf, size_t count)
+{
+        static const u8 reg[2] = {
+		MAX6653_REG_LCLTMP_THRM,
+		MAX6653_REG_REMTMP_THRM	,
+	};		
+	struct i2c_client *client = to_i2c_client(dev);
+        struct max6653_data *data = i2c_get_clientdata(client);
+        struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+        unsigned long val;
+        int res;
+	int nr = attr->index;	
+        res = kstrtoul(buf, 10, &val);
+        if (res)
+                return res;
+
+        mutex_lock(&data->update_lock);
+        data->temp_crit[nr] = TEMP_LIMIT_TO_REG(val);
+        max6653_write(client,reg[nr],
+                                data->temp_crit[nr]);
+        mutex_unlock(&data->update_lock);
+        return count;
+}
+
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_temp_input, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp2_input, S_IRUGO, show_temp_input, NULL, 1);
+static SENSOR_DEVICE_ATTR(temp1_min, S_IWUGO | S_IRUGO, show_temp_min, set_temp_min, 0);
+static SENSOR_DEVICE_ATTR(temp2_min, S_IWUGO | S_IRUGO, show_temp_min, set_temp_min, 1);
+static SENSOR_DEVICE_ATTR(temp1_max, S_IWUGO | S_IRUGO, show_temp_max, set_temp_max, 0);
+static SENSOR_DEVICE_ATTR(temp2_max, S_IWUGO | S_IRUGO, show_temp_max, set_temp_max, 1);
+static SENSOR_DEVICE_ATTR(temp1_crit, S_IWUGO | S_IRUGO, show_temp_crit, set_temp_crit, 0);
+static SENSOR_DEVICE_ATTR(temp2_crit, S_IWUGO | S_IRUGO, show_temp_crit, set_temp_crit, 1);
+/*ALARMS*/
+
+static SENSOR_DEVICE_ATTR(temp2_max_alarm, S_IRUGO, show_alarm, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp2_min_alarm, S_IRUGO, show_alarm, NULL, 3);
+static SENSOR_DEVICE_ATTR(temp2_crit_alarm, S_IRUGO, show_alarm, NULL, 4);
+static SENSOR_DEVICE_ATTR(temp2_fault, S_IRUGO, show_alarm, NULL, 5);
+static SENSOR_DEVICE_ATTR(temp1_max_alarm, S_IRUGO, show_alarm, NULL, 6);
+static SENSOR_DEVICE_ATTR(temp1_min_alarm, S_IRUGO, show_alarm, NULL, 7);
+
+static struct attribute *max6653_attrs[] = {
+        &sensor_dev_attr_temp1_input.dev_attr.attr,
+        &sensor_dev_attr_temp2_input.dev_attr.attr,
+        &sensor_dev_attr_temp1_min.dev_attr.attr,
+        &sensor_dev_attr_temp2_min.dev_attr.attr,
+        &sensor_dev_attr_temp1_max.dev_attr.attr,
+        &sensor_dev_attr_temp2_max.dev_attr.attr,
+        &sensor_dev_attr_temp1_crit.dev_attr.attr,
+        &sensor_dev_attr_temp2_crit.dev_attr.attr,
+
+        &sensor_dev_attr_temp2_crit_alarm.dev_attr.attr,
+        &sensor_dev_attr_temp2_fault.dev_attr.attr,
+        &sensor_dev_attr_temp2_min_alarm.dev_attr.attr,
+        &sensor_dev_attr_temp2_max_alarm.dev_attr.attr,
+        &sensor_dev_attr_temp1_min_alarm.dev_attr.attr,
+        &sensor_dev_attr_temp1_max_alarm.dev_attr.attr,
+        NULL
+};
+
+
+static const struct attribute_group max6653_attr_grp = {
+        .attrs = max6653_attrs,
+};
+
+static int max6653_probe(struct i2c_client *client,
+                         const struct i2c_device_id *id)
+{
+	struct max6653_data *data;
+        int err;
+	struct device *dev = &client->dev;
+
+        data = devm_kzalloc(&client->dev, sizeof(struct max6653_data),
+                            GFP_KERNEL);
+        if (!data) {
+                dev_err(&client->dev, "out of memory.\n");
+                return -ENOMEM;
+        }
+
+	i2c_set_clientdata(client, data);
+        mutex_init(&data->update_lock);
+
+	/* Initialize the chipset */
+	err = max6653_init_client(client);
+        if (err)
+                return err;
+
+	/* Register sysfs hooks */
+        err = sysfs_create_group(&dev->kobj, &max6653_attr_grp);
+        if (err)
+                return err;
+
+	data->hwmon_dev = hwmon_device_register(dev);
+	if (IS_ERR(data->hwmon_dev)) {
+                err = PTR_ERR(data->hwmon_dev);
+                goto exit_remove;
+        }
+
+        return 0;
+
+exit_remove:
+        sysfs_remove_group(&dev->kobj, &max6653_attr_grp);
+        return err;
+}
+
+static int max6653_init_client(struct i2c_client *client)
+{
+	u8 cfg2;
+
+        /* Reset the chip */
+        max6653_write(client, MAX6653_REG_CFG2, MAX6653_CFG2_RESET);
+
+	/*ebnable the temperature monitoring*/
+	max6653_write(client, MAX6653_REG_CFG1,MAX6653_CFG1_MONITOR_ENABLE);
+	cfg2=max6653_read(client, MAX6653_REG_CFG2);
+	/* disable INT input function */
+	cfg2 &= ~(1<<4);
+	max6653_write(client, MAX6653_REG_CFG2, cfg2);
+	max6653_write(client, MAX6653_REG_REMTMP_OFF,0x80);
+	return 0;
+}
+static int max6653_remove(struct i2c_client *client)
+{
+        struct max6653_data *data = i2c_get_clientdata(client);
+        struct device *dev = &client->dev;
+	hwmon_device_unregister(data->hwmon_dev);
+	sysfs_remove_group(&dev->kobj, &max6653_attr_grp);
+
+        return 0;
+}
+
+static int max6653_read(struct i2c_client *client, u8 reg)
+{
+    return i2c_smbus_read_byte_data(client, reg);
+}
+
+static int max6653_write(struct i2c_client *client, u8 reg, u8 value)
+{
+    return i2c_smbus_write_byte_data(client, reg, value);
+}
+
+static struct max6653_data *max6653_update_device(struct device *dev)
+{
+        struct i2c_client *client = to_i2c_client(dev);
+        struct max6653_data *data = i2c_get_clientdata(client);
+
+        mutex_lock(&data->update_lock);
+
+        if (time_after(jiffies, data->last_updated + HZ) || !data->valid) {
+		data->config1 		= max6653_read (client, MAX6653_REG_CFG1);
+	        data->config2 		= max6653_read (client, MAX6653_REG_CFG2);
+	        data->extbits  		= max6653_read (client, MAX6653_REG_EXTTMP);
+	        data->temp_input[0] 	= max6653_read (client, MAX6653_REG_LCLTMP);
+	        data->temp_input[1]	= max6653_read (client, MAX6653_REG_REMTMP);
+        	data->temp_max[0] 	= max6653_read (client, MAX6653_REG_LCLTMP_HI);
+        	data->temp_min[0] 	= max6653_read (client, MAX6653_REG_LCLTMP_LO);
+        	data->temp_max[1] 	= max6653_read (client, MAX6653_REG_REMTMP_HI);
+        	data->temp_min[1] 	= max6653_read (client, MAX6653_REG_REMTMP_LO);
+        	data->temp_crit[0] 	= max6653_read (client, MAX6653_REG_LCLTMP_THRM);
+        	data->temp_crit[1] 	= max6653_read (client, MAX6653_REG_REMTMP_THRM);
+        	data->alarm		= max6653_read (client, MAX6653_REG_STAT1);
+
+        	data->last_updated 	= jiffies;
+        	data->valid 		= 1;
+        }
+
+	mutex_unlock(&data->update_lock);
+        return data;
+}
+
+module_i2c_driver(max6653_driver);
+MODULE_AUTHOR("Broadcom");
+MODULE_DESCRIPTION("MAX6653 sensor driver");
+MODULE_LICENSE("GPL");
+
-- 
1.9.1

