From 886d58964e8232ed2e490c79546793874caeb95a Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Thu, 1 Jul 2010 18:44:13 -0700
Subject: [PATCH 1276/1532] NAE: use xlp_sgmii_ports replace
 xlp_with_mac_driver, cleanup on debug issue, turn of RUN_ON_SIM macro

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/broadcom/nae/xlp_nae.c | 65 ++++++++++++-----------------
 1 file changed, 26 insertions(+), 39 deletions(-)

diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index a1c44d6..f74e330 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -131,8 +131,7 @@ uint8_t myip[4]	     = {10,26,112,214};			\
 		if(memcmp(&buf[MYIP_OFFSET],myip,4)==0)	\
 			memcpy(buf,&eth_hw_addr[0],6);
 
-uint8_t myeth[6]     = {0x00,0x01,0x02,0x03,0x04,0x05};
-extern int  xlp_with_mac_driver;
+extern int  xlp_sgmii_ports;
 extern void xlp_set_ethtool_ops(struct net_device *netdev);
 extern void xlp_get_mac_stats(struct net_device* dev, struct net_device_stats* stats);
 spinlock_t  nlm_xlp_nae_lock;
@@ -410,13 +409,13 @@ static void nlm_xlp_nae_init(void)
 	int i;
 	struct proc_dir_entry *entry;
 	uint32_t val;
-/*
-	if(xlp_with_mac_driver == 0)
+
+	if(xlp_sgmii_ports <= 0 || xlp_sgmii_ports > MAX_GMAC_PORT)
 	{
-		printk("NET: [%s] driver init is diabled. xlp_with_mac_driver=0\n",__FUNCTION__);
+		printk("NET: [%s] driver init is diabled. xlp_sgmii_ports=0\n",__FUNCTION__, xlp_sgmii_ports);
 		return;
 	}
-*/
+
 	spin_lock_init(&nlm_xlp_nae_lock);
 
 	//initial base address for nae, gmac, fmn ...
@@ -449,7 +448,7 @@ static void nlm_xlp_nae_init(void)
 	init_egress();
 	spin_unlock_irq(&nlm_xlp_nae_lock);
 
-	for(i = 0; i< 1 /*MAX_GMAC_PORT*/; i++)
+	for(i = 0; i< xlp_sgmii_ports /*MAX_GMAC_PORT*/; i++)
 	{
 		dev = alloc_etherdev(sizeof(struct dev_data));
 		if(!dev)
@@ -463,9 +462,8 @@ static void nlm_xlp_nae_init(void)
 		//set ethtool_ops which is inside xlp_ethtool.c file
 		xlp_set_ethtool_ops(dev);
 
-//		netif_napi_add(dev, &tp->napi, nlm_xlp_napi_poll, 16);
+		//netif_napi_add(dev, &tp->napi, nlm_xlp_napi_poll, 16);
 
-//		random_ether_addr(dev->dev_addr);
 		dev->dev_addr = eth_hw_addr[i];
 		tp->port	= i;
 		tp->inited	= 0;
@@ -507,6 +505,11 @@ static void nlm_xlp_nae_init(void)
 	spin_unlock_irq(&nlm_xlp_nae_lock);
 }
 
+/**********************************************************************
+ * nlm_xlp_sgmii_setcontext -  setup context info for RX interface
+ * so cpu can identify the which port the message is from
+ *
+ **********************************************************************/
 static void nlm_xlp_sgmii_setcontext(void)
 {
 	int i = 0;
@@ -516,73 +519,52 @@ static void nlm_xlp_sgmii_setcontext(void)
 
 	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM) << 16) |i;
 	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_0, val );
-	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_0 );
-	//printk("RX_IF_BASE_CONFIG_0,: %d, val: %x\n", 0, val);
 	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
 
 	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
 	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_1, val );
-	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_1 );
-	//printk("RX_IF_BASE_CONFIG_1: %d, val: %x\n", 1, val);
 	 i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
 
 	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
 	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_2, val );
-	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_2 );
-	//printk("RX_IF_BASE_CONFIG_2: %d, val: %x\n", 2, val);
 	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
 
 	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
 	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_3, val );
-	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_3 );
-	//printk("RX_IF_BASE_CONFIG_3: %d, val: %x\n", 3, val);
 	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
 
 	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
 	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_4, val );
-	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_4 );
-	//printk("RX_IF_BASE_CONFIG_4: %d, val: %x\n", 4, val);
 	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
 
 	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
 	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_5, val );
-	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_5 );
-	//printk("RX_IF_BASE_CONFIG_5: %d, val: %x\n", 5, val);
 	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
 
 	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
 	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_6, val );
-	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_6 );
-	//printk("RX_IF_BASE_CONFIG_6: %d, val: %x\n", 6, val);
 	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
 
 	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
 	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_7, val );
-	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_7 );
-	//printk("RX_IF_BASE_CONFIG_7: %d, val: %x\n", 7, val);
 	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
 
 	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
 	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_8, val );
-	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_8 );
-	//printk("RX_IF_BASE_CONFIG_6: %d, val: %x\n", 8, val);
 	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
 
-
-
 }
+
 /**********************************************************************
  * nlm_xlp_nae_open -  called when bring up a device interface
  * @dev  -  this is per device based function
  *
  **********************************************************************/
-
 static int  nlm_xlp_nae_open (struct net_device *dev)
 {
 	struct dev_data *priv = netdev_priv(dev);
 	int port = priv->port;
 	int ret  = 0, i;
-//	int irq;
 
 	if(priv->inited)
 		return ret;
@@ -693,7 +675,6 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	msg.entry[2] = msg.entry[3] = 0;
 
-//	printk("[nlm_xlp_nae_start_xmit] port:%d send %d skb %llx skb->data %llx len %d to qid %d \n", priv->port,(int)priv->stats.tx_packets, (uint64_t)skb, (uint64_t)skb->data,skb->len, priv->nae_tx_qid);
 #if DUMP_XMIT_PKT
 	//DUMP_PKT(skb->data, skb->len)
 #endif
@@ -707,7 +688,7 @@ retry_send:
         {
                 if(ret & MSG_DST_FC_FAIL)
 		{
-                        printk("TX message destination flow control credit fail: flow control count: %d\n", ret & (0x3fff8));
+                        //printk("TX message destination flow control credit fail: flow control count: %d\n", ret & (0x3fff8));
 			ret = xlp_read_status1();
 			if( ret & (1 << 31))
 			{
@@ -748,7 +729,10 @@ retry_send:
 	return NETDEV_TX_OK;
 }
 
-
+/**********************************************************************
+ * nlm_xlp_set_multicast_list
+ *
+ **********************************************************************/
 static void  nlm_xlp_set_multicast_list (struct net_device *dev)
 {
 	if (dev->flags & IFF_ALLMULTI) {
@@ -761,6 +745,10 @@ static void  nlm_xlp_set_multicast_list (struct net_device *dev)
 	return;
 }
 
+/**********************************************************************
+ * nlm_xlp_nae_ioctl
+ *
+ **********************************************************************/
 static int  nlm_xlp_nae_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int rc = 0;
@@ -774,6 +762,8 @@ static int  nlm_xlp_nae_ioctl (struct net_device *dev, struct ifreq *rq, int cmd
 }
 
 /**********************************************************************
+ * nlm_xlp_nae_change_mtu
+ *
  **********************************************************************/
 static int nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu)
 {
@@ -1022,6 +1012,7 @@ static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id)
 
 	return IRQ_HANDLED;
 }
+
 /**********************************************************************
  * nlm_xlp_nae_msgring_handler -  message ring interrupt handler
  * @vc-  virtual channel number
@@ -1040,8 +1031,6 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
         uint64_t addr , vaddr;
 	struct sk_buff* skb;
 
-
-
 	cpu = vc % 16;
 	vc = vc % 4;
 
@@ -1111,7 +1100,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		vaddr = (uint64_t)bus_to_virt(addr);
 		buf = (unsigned char *)vaddr;
 
-		RUN_ON_SIM()
+		//RUN_ON_SIM()
 
 #if DUMP_RCV_PKT
 		printk("RX: port:%d src_id: %d context: %d recv buf: 0x%llx len:%d addr:0x%010llx  \n",
@@ -1364,11 +1353,9 @@ static void  nlm_xlp_napi_poll(struct napi_struct *napi, int* budget)
         if (skb) {
 			src = *((unsigned long *)(skb->data-20));
 //			skb_reserve(skb, MAC_PREPAD+BYTE_OFFSET );
-//			printk("%s : addr :%llx  len:%d  skb: %llx src: %d  num_desc: %d\n", __FUNCTION__, addr, len, (uint64_t)skb,src, (int)priv->num_desc);
 			skb_put(skb, len);
 			skb->dev = dev;
 			skb->protocol = eth_type_trans(skb, dev);
-//	printk("\n[%s] port: %d  dev %llx  protocol %d\n",__FUNCTION__, priv->port, (uint64_t)dev, skb->protocol);
 			skb->dev->last_rx = jiffies;
 			netif_receive_skb(skb);
 			priv->stats.rx_bytes += len;
-- 
1.9.1

