From d708c10618c3377fca866e623fe8f9f247bfeced Mon Sep 17 00:00:00 2001
From: GengFei <fei.geng@windriver.com>
Date: Mon, 23 Mar 2009 15:10:56 +0800
Subject: [PATCH] Fix a bug for yaffs2 mount.

Because current version yaffs API in yaffs_fs.c isn't
matched with mtd driver of kernel 2.6.27,
so yaffs filesystem mount will fail.

Yaffs revision 1.71 updated this API and
this patch is got from this version of yaffs source codes.

Please reference cvs log for 1.71:
----------------------------
revision 1.71
date: 2009-01-22 08:45:54 +0800;  author: charles;  state: Exp;  lines: +175 -3;  commitid: qh5VbQshQqeZGnzt;
Change Linux glue code to work with 2.6.28
----------------------------

Signed-off-by: GengFei <fei.geng@windriver.com>
---
 fs/yaffs2/yaffs_fs.c |  478 +++++++++++++++++++++++++++++++++++++++----------
 1 files changed, 380 insertions(+), 98 deletions(-)

diff --git a/fs/yaffs2/yaffs_fs.c b/fs/yaffs2/yaffs_fs.c
index b6de5ef..955551c 100644
--- a/fs/yaffs2/yaffs_fs.c
+++ b/fs/yaffs2/yaffs_fs.c
@@ -32,7 +32,7 @@
  */
 
 const char *yaffs_fs_c_version =
-    "$Id: yaffs_fs.c,v 1.66 2008-05-05 07:58:58 charles Exp $";
+    "$Id: yaffs_fs.c,v 1.75 2009-03-05 01:45:28 charles Exp $";
 extern const char *yaffs_guts_c_version;
 
 #include <linux/version.h>
@@ -43,7 +43,6 @@ extern const char *yaffs_guts_c_version;
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/init.h>
-#include <linux/list.h>
 #include <linux/fs.h>
 #include <linux/proc_fs.h>
 #include <linux/smp_lock.h>
@@ -78,6 +77,12 @@ extern const char *yaffs_guts_c_version;
 
 #endif
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#define YPROC_ROOT  &proc_root
+#else
+#define YPROC_ROOT  NULL
+#endif
+
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))
 #define WRITE_SIZE_STR "writesize"
 #define WRITE_SIZE(mtd) (mtd)->writesize
@@ -86,6 +91,23 @@ extern const char *yaffs_guts_c_version;
 #define WRITE_SIZE(mtd) (mtd)->oobblock
 #endif
 
+#if(LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27))
+#define YAFFS_USE_WRITE_BEGIN_END 1
+#else
+#define YAFFS_USE_WRITE_BEGIN_END 0
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
+static uint32_t YCALCBLOCKS(uint64_t partition_size, uint32_t block_size)
+{
+	uint64_t result = partition_size;
+	do_div(result,block_size);
+	return (uint32_t)result;
+}
+#else
+#define YCALCBLOCKS(s,b) ((s)/(b))
+#endif
+
 #include <asm/uaccess.h>
 
 #include "yportenv.h"
@@ -98,14 +120,30 @@ extern const char *yaffs_guts_c_version;
 
 unsigned int yaffs_traceMask = YAFFS_TRACE_BAD_BLOCKS;
 unsigned int yaffs_wr_attempts = YAFFS_WR_ATTEMPTS;
+unsigned int yaffs_auto_checkpoint = 1;
 
 /* Module Parameters */
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 module_param(yaffs_traceMask,uint,0644);
 module_param(yaffs_wr_attempts,uint,0644);
+module_param(yaffs_auto_checkpoint,uint,0644);
 #else
 MODULE_PARM(yaffs_traceMask,"i");
 MODULE_PARM(yaffs_wr_attempts,"i");
+MODULE_PARM(yaffs_auto_checkpoint,"i");
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25))
+/* use iget and read_inode */
+#define Y_IGET(sb,inum) iget((sb),(inum))
+static void yaffs_read_inode(struct inode *inode);
+
+#else
+/* Call local equivalent */
+#define YAFFS_USE_OWN_IGET
+#define Y_IGET(sb,inum) yaffs_iget((sb),(inum))
+
+static struct inode * yaffs_iget(struct super_block *sb, unsigned long ino);
 #endif
 
 /*#define T(x) printk x */
@@ -129,6 +167,8 @@ static void yaffs_put_super(struct super_block *sb);
 
 static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
 				loff_t * pos);
+static ssize_t yaffs_hold_space(struct file *f);
+static void yaffs_release_space(struct file *f);
 
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))
 static int yaffs_file_flush(struct file *file, fl_owner_t id);
@@ -183,9 +223,11 @@ static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf);
 #else
 static int yaffs_statfs(struct super_block *sb, struct statfs *buf);
 #endif
-static void yaffs_read_inode(struct inode *inode);
 
+#ifdef YAFFS_HAS_PUT_INODE
 static void yaffs_put_inode(struct inode *inode);
+#endif
+
 static void yaffs_delete_inode(struct inode *);
 static void yaffs_clear_inode(struct inode *);
 
@@ -195,10 +237,22 @@ static int yaffs_writepage(struct page *page, struct writeback_control *wbc);
 #else
 static int yaffs_writepage(struct page *page);
 #endif
+
+
+#if (YAFFS_USE_WRITE_BEGIN_END != 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+                             loff_t pos, unsigned len, unsigned flags,
+                          struct page **pagep, void **fsdata);
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *pg, void *fsdadata);
+#else
 static int yaffs_prepare_write(struct file *f, struct page *pg,
 			       unsigned offset, unsigned to);
 static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
 			      unsigned to);
+                                                                                                
+#endif
 
 static int yaffs_readlink(struct dentry *dentry, char __user * buffer,
 			  int buflen);
@@ -211,8 +265,13 @@ static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);
 static struct address_space_operations yaffs_file_address_operations = {
 	.readpage = yaffs_readpage,
 	.writepage = yaffs_writepage,
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+	.write_begin = yaffs_write_begin,
+	.write_end = yaffs_write_end,
+#else
 	.prepare_write = yaffs_prepare_write,
 	.commit_write = yaffs_commit_write,
+#endif
 };
 
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
@@ -226,6 +285,7 @@ static struct file_operations yaffs_file_operations = {
 	.fsync = yaffs_sync_object,
 	.splice_read = generic_file_splice_read,
 	.splice_write = generic_file_splice_write,
+	.llseek = generic_file_llseek,
 };
 
 #elif (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))
@@ -286,12 +346,13 @@ static struct file_operations yaffs_dir_operations = {
 
 static struct super_operations yaffs_super_ops = {
 	.statfs = yaffs_statfs,
-	/* removed by commit 12debc4248a4a7f1873e47cda2cdd7faca80b099
-         * .read_inode = yaffs_read_inode,
-         */
-        /* removed by commit 33dcdac2df54e66c447ae03f58c95c7251aa5649
-         * .put_inode = yaffs_put_inode,
-         */
+
+#ifndef YAFFS_USE_OWN_IGET
+	.read_inode = yaffs_read_inode,
+#endif
+#ifdef YAFFS_HAS_PUT_INODE
+	.put_inode = yaffs_put_inode,
+#endif
 	.put_super = yaffs_put_super,
 	.delete_inode = yaffs_delete_inode,
 	.clear_inode = yaffs_clear_inode,
@@ -301,14 +362,16 @@ static struct super_operations yaffs_super_ops = {
 
 static void yaffs_GrossLock(yaffs_Device * dev)
 {
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs locking\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs locking %p\n",current));
 
 	down(&dev->grossLock);
+        T(YAFFS_TRACE_OS, ( "yaffs locked %p\n",current));
+	
 }
 
 static void yaffs_GrossUnlock(yaffs_Device * dev)
 {
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs unlocking\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs unlocking %p\n",current));
 	up(&dev->grossLock);
 
 }
@@ -389,7 +452,7 @@ static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry)
 	yaffs_GrossLock(dev);
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_lookup for %d:%s\n",
+	  ( "yaffs_lookup for %d:%s\n",
 	   yaffs_InodeToObject(dir)->objectId, dentry->d_name.name));
 
 	obj =
@@ -403,13 +466,13 @@ static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry)
 
 	if (obj) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_lookup found %d\n", obj->objectId));
+		  ( "yaffs_lookup found %d\n", obj->objectId));
 
 		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
 
 		if (inode) {
 			T(YAFFS_TRACE_OS,
-			  (KERN_DEBUG "yaffs_loookup dentry \n"));
+			  ( "yaffs_loookup dentry \n"));
 /* #if 0 asserted by NCB for 2.5/6 compatability - falls through to
  * d_add even if NULL inode */
 #if 0
@@ -422,7 +485,7 @@ static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry)
 		}
 
 	} else {
-		T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_lookup not found\n"));
+		T(YAFFS_TRACE_OS, ( "yaffs_lookup not found\n"));
 
 	}
 
@@ -435,6 +498,9 @@ static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry)
 
 }
 
+
+#ifdef YAFFS_HAS_PUT_INODE
+
 /* For now put inode is just for debugging
  * Put inode is called when the inode **structure** is put.
  */
@@ -445,6 +511,7 @@ static void yaffs_put_inode(struct inode *inode)
 	   atomic_read(&inode->i_count)));
 
 }
+#endif
 
 /* clear is called to tell the fs to release any per-inode data it holds */
 static void yaffs_clear_inode(struct inode *inode)
@@ -519,7 +586,7 @@ static int yaffs_file_flush(struct file *file)
 	yaffs_Device *dev = obj->myDev;
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_file_flush object %d (%s)\n", obj->objectId,
+	  ( "yaffs_file_flush object %d (%s)\n", obj->objectId,
 	   obj->dirty ? "dirty" : "clean"));
 
 	yaffs_GrossLock(dev);
@@ -541,7 +608,7 @@ static int yaffs_readpage_nolock(struct file *f, struct page *pg)
 
 	yaffs_Device *dev;
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_readpage at %08x, size %08x\n",
+	T(YAFFS_TRACE_OS, ( "yaffs_readpage at %08x, size %08x\n",
 			   (unsigned)(pg->index << PAGE_CACHE_SHIFT),
 			   (unsigned)PAGE_CACHE_SIZE));
 
@@ -581,7 +648,7 @@ static int yaffs_readpage_nolock(struct file *f, struct page *pg)
 	flush_dcache_page(pg);
 	kunmap(pg);
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_readpage done\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_readpage done\n"));
 	return ret;
 }
 
@@ -622,12 +689,12 @@ static int yaffs_writepage(struct page *page)
 
 	if (offset > inode->i_size) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG
+		  (
 		   "yaffs_writepage at %08x, inode size = %08x!!!\n",
 		   (unsigned)(page->index << PAGE_CACHE_SHIFT),
 		   (unsigned)inode->i_size));
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "                -> don't care!!\n"));
+		  ( "                -> don't care!!\n"));
 		unlock_page(page);
 		return 0;
 	}
@@ -649,10 +716,10 @@ static int yaffs_writepage(struct page *page)
 	yaffs_GrossLock(obj->myDev);
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_writepage at %08x, size %08x\n",
+	  ( "yaffs_writepage at %08x, size %08x\n",
 	   (unsigned)(page->index << PAGE_CACHE_SHIFT), nBytes));
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "writepag0: obj = %05x, ino = %05x\n",
+	  ( "writepag0: obj = %05x, ino = %05x\n",
 	   (int)obj->variant.fileVariant.fileSize, (int)inode->i_size));
 
 	nWritten =
@@ -660,7 +727,7 @@ static int yaffs_writepage(struct page *page)
 				  nBytes, 0);
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "writepag1: obj = %05x, ino = %05x\n",
+	  ( "writepag1: obj = %05x, ino = %05x\n",
 	   (int)obj->variant.fileVariant.fileSize, (int)inode->i_size));
 
 	yaffs_GrossUnlock(obj->myDev);
@@ -673,39 +740,148 @@ static int yaffs_writepage(struct page *page)
 	return (nWritten == nBytes) ? 0 : -ENOSPC;
 }
 
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+                             loff_t pos, unsigned len, unsigned flags,
+                          struct page **pagep, void **fsdata)
+
+{
+	struct page *pg = NULL;
+        pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+        uint32_t offset = pos & (PAGE_CACHE_SIZE - 1);
+        uint32_t to = offset + len;
+        
+        int ret = 0;
+        int space_held = 0;
+        
+	T(YAFFS_TRACE_OS, ( "start yaffs_write_begin\n"));
+	/* Get a page */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+	pg = grab_cache_page_write_begin(mapping,index,flags);
+#else
+	pg = __grab_cache_page(mapping,index);
+#endif
+
+	*pagep = pg;	
+	if(!pg){
+		ret =  -ENOMEM;
+		goto out;
+	}
+	/* Get fs space */
+	space_held = yaffs_hold_space(filp);
+	
+	if(!space_held){
+		ret = -ENOSPC;
+		goto out;
+	}
+		
+	/* Update page if required */
+	
+	if (!Page_Uptodate(pg) && (offset || to < PAGE_CACHE_SIZE))
+		ret = yaffs_readpage_nolock(filp, pg);
+	
+	if(ret)
+		goto out;
+
+	/* Happy path return */
+	T(YAFFS_TRACE_OS, ( "end yaffs_write_begin - ok\n"));
+		
+	return 0;
+		
+out:
+	T(YAFFS_TRACE_OS, ( "end yaffs_write_begin fail returning %d\n",ret));
+	if(space_held){
+		yaffs_release_space(filp);
+	}
+	if(pg) {
+		unlock_page(pg);
+		page_cache_release(pg);
+	}
+	return ret;
+}
+
+#else
+
 static int yaffs_prepare_write(struct file *f, struct page *pg,
 			       unsigned offset, unsigned to)
 {
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_prepair_write\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_prepair_write\n"));
 	if (!Page_Uptodate(pg) && (offset || to < PAGE_CACHE_SIZE))
 		return yaffs_readpage_nolock(f, pg);
-
 	return 0;
 
 }
+#endif
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *pg, void *fsdadata)
+{
+	int ret = 0;
+	void *addr, *kva;
+        uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE -1); 
+
+
+	
+	kva=kmap(pg);
+	addr = kva + offset_into_page;
+
+	T(YAFFS_TRACE_OS,
+	  ( "yaffs_write_end addr %x pos %x nBytes %d\n", (unsigned) addr,
+	   (int)pos, copied));
+
+	ret = yaffs_file_write(filp, addr, copied, &pos);
+
+	if (ret != copied) {
+		T(YAFFS_TRACE_OS,
+		  (
+		   "yaffs_write_end not same size ret %d  copied %d\n",
+		   ret, copied ));
+		SetPageError(pg);
+		ClearPageUptodate(pg);
+	} else {
+		SetPageUptodate(pg);
+	}
+
+	kunmap(pg);
+
+	yaffs_release_space(filp);
+	unlock_page(pg);
+	page_cache_release(pg);
+	return ret;
+}
+#else
 
 static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
 			      unsigned to)
 {
 
-	void *addr = page_address(pg) + offset;
+	void *addr, *kva;
+	
 	loff_t pos = (((loff_t) pg->index) << PAGE_CACHE_SHIFT) + offset;
 	int nBytes = to - offset;
 	int nWritten;
 
 	unsigned spos = pos;
-	unsigned saddr = (unsigned)addr;
+	unsigned saddr;
+	
+	kva=kmap(pg);
+	addr = kva + offset;
+
+	saddr = (unsigned) addr;
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_commit_write addr %x pos %x nBytes %d\n", saddr,
+	  ( "yaffs_commit_write addr %x pos %x nBytes %d\n", saddr,
 	   spos, nBytes));
 
 	nWritten = yaffs_file_write(f, addr, nBytes, &pos);
 
 	if (nWritten != nBytes) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG
+		  (
 		   "yaffs_commit_write not same size nWritten %d  nBytes %d\n",
 		   nWritten, nBytes));
 		SetPageError(pg);
@@ -714,13 +890,17 @@ static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
 		SetPageUptodate(pg);
 	}
 
+	kunmap(pg);
+
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_commit_write returning %d\n",
+	  ( "yaffs_commit_write returning %d\n",
 	   nWritten == nBytes ? 0 : nWritten));
 
 	return nWritten == nBytes ? 0 : nWritten;
 
 }
+#endif
+
 
 static void yaffs_FillInodeFromObject(struct inode *inode, yaffs_Object * obj)
 {
@@ -789,7 +969,7 @@ static void yaffs_FillInodeFromObject(struct inode *inode, yaffs_Object * obj)
 		inode->i_nlink = yaffs_GetObjectLinkCount(obj);
 
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG
+		  (
 		   "yaffs_FillInode mode %x uid %d gid %d size %d count %d\n",
 		   inode->i_mode, inode->i_uid, inode->i_gid,
 		   (int)inode->i_size, atomic_read(&inode->i_count)));
@@ -825,7 +1005,7 @@ static void yaffs_FillInodeFromObject(struct inode *inode, yaffs_Object * obj)
 
 	} else {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_FileInode invalid parameters\n"));
+		  ( "yaffs_FileInode invalid parameters\n"));
 	}
 
 }
@@ -837,22 +1017,24 @@ struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
 
 	if (!sb) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_get_inode for NULL super_block!!\n"));
+		  ( "yaffs_get_inode for NULL super_block!!\n"));
 		return NULL;
 
 	}
 
 	if (!obj) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_get_inode for NULL object!!\n"));
+		  ( "yaffs_get_inode for NULL object!!\n"));
 		return NULL;
 
 	}
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_get_inode for object %d\n", obj->objectId));
+	  ( "yaffs_get_inode for object %d\n", obj->objectId));
 
-	inode = iget_locked(sb, obj->objectId);
+	inode = Y_IGET(sb, obj->objectId);
+	if(IS_ERR(inode))
+	  return NULL;
 
 	/* NB Side effect: iget calls back to yaffs_read_inode(). */
 	/* iget also increments the inode's i_count */
@@ -885,11 +1067,11 @@ static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
 
 	if (!obj) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_file_write: hey obj is null!\n"));
+		  ( "yaffs_file_write: hey obj is null!\n"));
 	} else {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG
-		   "yaffs_file_write about to write writing %d bytes"
+		  (
+		   "yaffs_file_write about to write writing %zu bytes"
 		   "to object %d at %d\n",
 		   n, obj->objectId, ipos));
 	}
@@ -897,7 +1079,7 @@ static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
 	nWritten = yaffs_WriteDataToFile(obj, buf, ipos, n, 0);
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_file_write writing %d bytes, %d written at %d\n",
+	  ( "yaffs_file_write writing %zu bytes, %d written at %d\n",
 	   n, nWritten, ipos));
 	if (nWritten > 0) {
 		ipos += nWritten;
@@ -907,7 +1089,7 @@ static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
 			inode->i_blocks = (ipos + 511) >> 9;
 
 			T(YAFFS_TRACE_OS,
-			  (KERN_DEBUG
+			  (
 			   "yaffs_file_write size updated to %d bytes, "
 			   "%d blocks\n",
 			   ipos, (int)(inode->i_blocks)));
@@ -918,13 +1100,55 @@ static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
 	return nWritten == 0 ? -ENOSPC : nWritten;
 }
 
+/* Space holding and freeing is done to ensure we have space available for write_begin/end */
+/* For now we just assume few parallel writes and check against a small number. */
+/* Todo: need to do this with a counter to handle parallel reads better */
+
+static ssize_t yaffs_hold_space(struct file *f)
+{
+	yaffs_Object *obj;
+	yaffs_Device *dev;
+	
+	int nFreeChunks;
+
+	
+	obj = yaffs_DentryToObject(f->f_dentry);
+
+	dev = obj->myDev;
+
+	yaffs_GrossLock(dev);
+
+	nFreeChunks = yaffs_GetNumberOfFreeChunks(dev);
+	
+	yaffs_GrossUnlock(dev);
+
+	return (nFreeChunks > 20) ? 1 : 0;
+}
+
+static void yaffs_release_space(struct file *f)
+{
+	yaffs_Object *obj;
+	yaffs_Device *dev;
+	
+	
+	obj = yaffs_DentryToObject(f->f_dentry);
+
+	dev = obj->myDev;
+
+	yaffs_GrossLock(dev);
+
+	
+	yaffs_GrossUnlock(dev);
+
+}
+
 static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
 {
 	yaffs_Object *obj;
 	yaffs_Device *dev;
 	struct inode *inode = f->f_dentry->d_inode;
 	unsigned long offset, curoffs;
-	struct list_head *i;
+	struct ylist_head *i;
 	yaffs_Object *l;
 
 	char name[YAFFS_MAX_NAME_LENGTH + 1];
@@ -940,7 +1164,7 @@ static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
 
 	if (offset == 0) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_readdir: entry . ino %d \n",
+		  ( "yaffs_readdir: entry . ino %d \n",
 		   (int)inode->i_ino));
 		if (filldir(dirent, ".", 1, offset, inode->i_ino, DT_DIR)
 		    < 0) {
@@ -951,7 +1175,7 @@ static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
 	}
 	if (offset == 1) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_readdir: entry .. ino %d \n",
+		  ( "yaffs_readdir: entry .. ino %d \n",
 		   (int)f->f_dentry->d_parent->d_inode->i_ino));
 		if (filldir
 		    (dirent, "..", 2, offset,
@@ -973,15 +1197,15 @@ static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
 		f->f_version = inode->i_version;
 	}
 
-	list_for_each(i, &obj->variant.directoryVariant.children) {
+	ylist_for_each(i, &obj->variant.directoryVariant.children) {
 		curoffs++;
 		if (curoffs >= offset) {
-			l = list_entry(i, yaffs_Object, siblings);
+			l = ylist_entry(i, yaffs_Object, siblings);
 
 			yaffs_GetObjectName(l, name,
 					    YAFFS_MAX_NAME_LENGTH + 1);
 			T(YAFFS_TRACE_OS,
-			  (KERN_DEBUG "yaffs_readdir: %s inode %d\n", name,
+			  ( "yaffs_readdir: %s inode %d\n", name,
 			   yaffs_GetObjectInode(l)));
 
 			if (filldir(dirent,
@@ -1010,6 +1234,13 @@ static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
 /*
  * File creation. Allocate an inode, and we're done..
  */
+ 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+#define YCRED(x) x
+#else
+#define YCRED(x) x->cred
+#endif
+
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
 		       dev_t rdev)
@@ -1026,19 +1257,19 @@ static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
 	yaffs_Object *parent = yaffs_InodeToObject(dir);
 
 	int error = -ENOSPC;
-	uid_t uid = current->fsuid;
-	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : current->fsgid;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
 
 	if((dir->i_mode & S_ISGID) && S_ISDIR(mode))
 		mode |= S_ISGID;
 
 	if (parent) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_mknod: parent object %d type %d\n",
+		  ( "yaffs_mknod: parent object %d type %d\n",
 		   parent->objectId, parent->variantType));
 	} else {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_mknod: could not get parent object\n"));
+		  ( "yaffs_mknod: could not get parent object\n"));
 		return -EPERM;
 	}
 
@@ -1053,7 +1284,7 @@ static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
 	switch (mode & S_IFMT) {
 	default:
 		/* Special (socket, fifo, device...) */
-		T(YAFFS_TRACE_OS, (KERN_DEBUG
+		T(YAFFS_TRACE_OS, (
 				   "yaffs_mknod: making special\n"));
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 		obj =
@@ -1066,20 +1297,20 @@ static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
 #endif
 		break;
 	case S_IFREG:		/* file          */
-		T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_mknod: making file\n"));
+		T(YAFFS_TRACE_OS, ( "yaffs_mknod: making file\n"));
 		obj =
 		    yaffs_MknodFile(parent, dentry->d_name.name, mode, uid,
 				    gid);
 		break;
 	case S_IFDIR:		/* directory */
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_mknod: making directory\n"));
+		  ( "yaffs_mknod: making directory\n"));
 		obj =
 		    yaffs_MknodDirectory(parent, dentry->d_name.name, mode,
 					 uid, gid);
 		break;
 	case S_IFLNK:		/* symlink */
-		T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_mknod: making file\n"));
+		T(YAFFS_TRACE_OS, ( "yaffs_mknod: making symlink\n"));
 		obj = NULL;	/* Do we ever get here? */
 		break;
 	}
@@ -1091,12 +1322,12 @@ static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
 		inode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);
 		d_instantiate(dentry, inode);
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_mknod created object %d count = %d\n",
+		  ( "yaffs_mknod created object %d count = %d\n",
 		   obj->objectId, atomic_read(&inode->i_count)));
 		error = 0;
 	} else {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_mknod failed making object\n"));
+		  ( "yaffs_mknod failed making object\n"));
 		error = -ENOMEM;
 	}
 
@@ -1106,7 +1337,7 @@ static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
 static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
 	int retVal;
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_mkdir\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_mkdir\n"));
 	retVal = yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);
 #if 0
 	/* attempt to fix dir bug - didn't work */
@@ -1124,7 +1355,7 @@ static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
 static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode)
 #endif
 {
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_create\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_create\n"));
 	return yaffs_mknod(dir, dentry, mode | S_IFREG, 0);
 }
 
@@ -1135,7 +1366,7 @@ static int yaffs_unlink(struct inode *dir, struct dentry *dentry)
 	yaffs_Device *dev;
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_unlink %d:%s\n", (int)(dir->i_ino),
+	  ( "yaffs_unlink %d:%s\n", (int)(dir->i_ino),
 	   dentry->d_name.name));
 
 	dev = yaffs_InodeToObject(dir)->myDev;
@@ -1166,7 +1397,7 @@ static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
 	yaffs_Object *link = NULL;
 	yaffs_Device *dev;
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_link\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_link\n"));
 
 	obj = yaffs_InodeToObject(inode);
 	dev = obj->myDev;
@@ -1185,7 +1416,7 @@ static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
 		d_instantiate(dentry, old_dentry->d_inode);
 		atomic_inc(&old_dentry->d_inode->i_count);
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_link link count %d i_count %d\n",
+		  ( "yaffs_link link count %d i_count %d\n",
 		   old_dentry->d_inode->i_nlink,
 		   atomic_read(&old_dentry->d_inode->i_count)));
 
@@ -1206,10 +1437,10 @@ static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
 {
 	yaffs_Object *obj;
 	yaffs_Device *dev;
-	uid_t uid = current->fsuid;
-	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : current->fsgid;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_symlink\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_symlink\n"));
 
 	dev = yaffs_InodeToObject(dir)->myDev;
 	yaffs_GrossLock(dev);
@@ -1223,10 +1454,10 @@ static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
 
 		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
 		d_instantiate(dentry, inode);
-		T(YAFFS_TRACE_OS, (KERN_DEBUG "symlink created OK\n"));
+		T(YAFFS_TRACE_OS, ( "symlink created OK\n"));
 		return 0;
 	} else {
-		T(YAFFS_TRACE_OS, (KERN_DEBUG "symlink not created\n"));
+		T(YAFFS_TRACE_OS, ( "symlink not created\n"));
 
 	}
 
@@ -1244,7 +1475,7 @@ static int yaffs_sync_object(struct file *file, struct dentry *dentry,
 
 	dev = obj->myDev;
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_sync_object\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_sync_object\n"));
 	yaffs_GrossLock(dev);
 	yaffs_FlushFile(obj, 1);
 	yaffs_GrossUnlock(dev);
@@ -1263,7 +1494,7 @@ static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
 	int retVal = YAFFS_FAIL;
 	yaffs_Object *target;
 
-        T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_rename\n"));
+        T(YAFFS_TRACE_OS, ( "yaffs_rename\n"));
 	dev = yaffs_InodeToObject(old_dir)->myDev;
 
 	yaffs_GrossLock(dev);
@@ -1277,15 +1508,15 @@ static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
 
 	if (target &&
 	    target->variantType == YAFFS_OBJECT_TYPE_DIRECTORY &&
-	    !list_empty(&target->variant.directoryVariant.children)) {
+	    !ylist_empty(&target->variant.directoryVariant.children)) {
 
-	        T(YAFFS_TRACE_OS, (KERN_DEBUG "target is non-empty dir\n"));
+	        T(YAFFS_TRACE_OS, ( "target is non-empty dir\n"));
 
 		retVal = YAFFS_FAIL;
 	} else {
 
 		/* Now does unlinking internally using shadowing mechanism */
-	        T(YAFFS_TRACE_OS, (KERN_DEBUG "calling yaffs_RenameObject\n"));
+	        T(YAFFS_TRACE_OS, ( "calling yaffs_RenameObject\n"));
 
 		retVal =
 		    yaffs_RenameObject(yaffs_InodeToObject(old_dir),
@@ -1316,7 +1547,7 @@ static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)
 	yaffs_Device *dev;
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_setattr of object %d\n",
+	  ( "yaffs_setattr of object %d\n",
 	   yaffs_InodeToObject(inode)->objectId));
 
 	if ((error = inode_change_ok(inode, attr)) == 0) {
@@ -1351,7 +1582,7 @@ static int yaffs_statfs(struct super_block *sb, struct statfs *buf)
 	yaffs_Device *dev = yaffs_SuperToDevice(sb);
 #endif
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_statfs\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_statfs\n"));
 
 	yaffs_GrossLock(dev);
 
@@ -1408,18 +1639,19 @@ static int yaffs_statfs(struct super_block *sb, struct statfs *buf)
 }
 
 
-/**
 static int yaffs_do_sync_fs(struct super_block *sb)
 {
 
 	yaffs_Device *dev = yaffs_SuperToDevice(sb);
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_do_sync_fs\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_do_sync_fs\n"));
 
 	if(sb->s_dirt) {
 		yaffs_GrossLock(dev);
 
-		if(dev)
+		if(dev){
+			yaffs_FlushEntireDeviceCache(dev);
 			yaffs_CheckpointSave(dev);
+		}
 
 		yaffs_GrossUnlock(dev);
 
@@ -1427,7 +1659,7 @@ static int yaffs_do_sync_fs(struct super_block *sb)
 	}
 	return 0;
 }
-**/
+
 
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))
 static void yaffs_write_super(struct super_block *sb)
@@ -1436,9 +1668,11 @@ static int yaffs_write_super(struct super_block *sb)
 #endif
 {
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_write_super\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_write_super\n"));
+	if (yaffs_auto_checkpoint >= 2)
+		yaffs_do_sync_fs(sb);
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))
-	return 0; /* yaffs_do_sync_fs(sb);*/
+	return 0; 
 #endif
 }
 
@@ -1450,12 +1684,50 @@ static int yaffs_sync_fs(struct super_block *sb)
 #endif
 {
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_sync_fs\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_sync_fs\n"));
 
-	return 0; /* yaffs_do_sync_fs(sb);*/
+	if (yaffs_auto_checkpoint >= 1)
+		yaffs_do_sync_fs(sb);
+	
+	return 0; 
 
 }
 
+#ifdef YAFFS_USE_OWN_IGET
+
+static struct inode * yaffs_iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode *inode;
+	yaffs_Object *obj;
+	yaffs_Device *dev = yaffs_SuperToDevice(sb);
+
+	T(YAFFS_TRACE_OS,
+	  ( "yaffs_iget for %lu\n", ino));
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+       /* NB This is called as a side effect of other functions, but
+	* we had to release the lock to prevent deadlocks, so
+	* need to lock again.
+	*/
+    
+	yaffs_GrossLock(dev);
+
+	obj = yaffs_FindObjectByNumber(dev, inode->i_ino);
+
+	yaffs_FillInodeFromObject(inode, obj);
+
+	yaffs_GrossUnlock(dev);
+	
+	unlock_new_inode(inode);
+	return inode;
+}
+
+#else
 
 static void yaffs_read_inode(struct inode *inode)
 {
@@ -1468,7 +1740,7 @@ static void yaffs_read_inode(struct inode *inode)
 	yaffs_Device *dev = yaffs_SuperToDevice(inode->i_sb);
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_read_inode for %d\n", (int)inode->i_ino));
+	  ( "yaffs_read_inode for %d\n", (int)inode->i_ino));
 
 	yaffs_GrossLock(dev);
 
@@ -1479,6 +1751,8 @@ static void yaffs_read_inode(struct inode *inode)
 	yaffs_GrossUnlock(dev);
 }
 
+#endif
+
 static LIST_HEAD(yaffs_dev_list);
 
 #if 0 // not used
@@ -1490,7 +1764,7 @@ static int yaffs_remount_fs(struct super_block *sb, int *flags, char *data)
 		struct mtd_info *mtd = yaffs_SuperToDevice(sb)->genericDevice;
 
 		T(YAFFS_TRACE_OS,
-			(KERN_DEBUG "yaffs_remount_fs: %s: RO\n", dev->name ));
+			( "yaffs_remount_fs: %s: RO\n", dev->name ));
 
 		yaffs_GrossLock(dev);
 
@@ -1505,7 +1779,7 @@ static int yaffs_remount_fs(struct super_block *sb, int *flags, char *data)
 	}
 	else {
 		T(YAFFS_TRACE_OS,
-			(KERN_DEBUG "yaffs_remount_fs: %s: RW\n", dev->name ));
+			( "yaffs_remount_fs: %s: RW\n", dev->name ));
 	}
 
 	return 0;
@@ -1516,7 +1790,7 @@ static void yaffs_put_super(struct super_block *sb)
 {
 	yaffs_Device *dev = yaffs_SuperToDevice(sb);
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_put_super\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_put_super\n"));
 
 	yaffs_GrossLock(dev);
 
@@ -1533,7 +1807,7 @@ static void yaffs_put_super(struct super_block *sb)
 	yaffs_GrossUnlock(dev);
 
 	/* we assume this is protected by lock_kernel() in mount/umount */
-	list_del(&dev->devList);
+	ylist_del(&dev->devList);
 
 	if(dev->spareBuffer){
 		YFREE(dev->spareBuffer);
@@ -1561,9 +1835,9 @@ static void yaffs_MarkSuperBlockDirty(void *vsb)
 {
 	struct super_block *sb = (struct super_block *)vsb;
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_MarkSuperBlockDirty() sb = %p\n",sb));
-//	if(sb)
-//		sb->s_dirt = 1;
+	T(YAFFS_TRACE_OS, ( "yaffs_MarkSuperBlockDirty() sb = %p\n",sb));
+	if(sb)
+		sb->s_dirt = 1;
 }
 
 typedef struct {
@@ -1704,7 +1978,11 @@ static struct super_block *yaffs_internal_read_super(int yaffsVersion,
 	T(YAFFS_TRACE_OS, (" %s %d\n", WRITE_SIZE_STR, WRITE_SIZE(mtd)));
 	T(YAFFS_TRACE_OS, (" oobsize %d\n", mtd->oobsize));
 	T(YAFFS_TRACE_OS, (" erasesize %d\n", mtd->erasesize));
-	T(YAFFS_TRACE_OS, (" size %d\n", mtd->size));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+	T(YAFFS_TRACE_OS, (" size %u\n", mtd->size));
+#else
+	T(YAFFS_TRACE_OS, (" size %lld\n", mtd->size));
+#endif
 
 #ifdef CONFIG_YAFFS_AUTO_YAFFS2
 
@@ -1801,7 +2079,8 @@ static struct super_block *yaffs_internal_read_super(int yaffsVersion,
 
 	/* Set up the memory size parameters.... */
 
-	nBlocks = mtd->size / (YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK);
+	nBlocks = YCALCBLOCKS(mtd->size ,(YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK));
+
 	dev->startBlock = 0;
 	dev->endBlock = nBlocks - 1;
 	dev->nChunksPerBlock = YAFFS_CHUNKS_PER_BLOCK;
@@ -1827,7 +2106,7 @@ static struct super_block *yaffs_internal_read_super(int yaffsVersion,
 		dev->totalBytesPerChunk = mtd->oobblock;
 		dev->nChunksPerBlock = mtd->erasesize / mtd->oobblock;
 #endif
-		nBlocks = mtd->size / mtd->erasesize;
+		nBlocks = YCALCBLOCKS(mtd->size,mtd->erasesize);
 
 		dev->startBlock = 0;
 		dev->endBlock = nBlocks - 1;
@@ -1905,6 +2184,9 @@ static struct super_block *yaffs_internal_read_super(int yaffsVersion,
 		return NULL;
 	}
 	sb->s_root = root;
+	sb->s_dirt = !dev->isCheckpointed;
+	T(YAFFS_TRACE_ALWAYS,
+	  ("yaffs_read_super: isCheckpointed %d\n", dev->isCheckpointed));
 
 	T(YAFFS_TRACE_OS, ("yaffs_read_super: done\n"));
 	return sb;
@@ -2053,7 +2335,7 @@ static int yaffs_proc_read(char *page,
 			   char **start,
 			   off_t offset, int count, int *eof, void *data)
 {
-	struct list_head *item;
+	struct ylist_head *item;
 	char *buf = page;
 	int step = offset;
 	int n = 0;
@@ -2077,8 +2359,8 @@ static int yaffs_proc_read(char *page,
 	lock_kernel();
 
 	/* Locate and print the Nth entry.  Order N-squared but N is small. */
-	list_for_each(item, &yaffs_dev_list) {
-		yaffs_Device *dev = list_entry(item, yaffs_Device, devList);
+	ylist_for_each(item, &yaffs_dev_list) {
+		yaffs_Device *dev = ylist_entry(item, yaffs_Device, devList);
 		if (n < step) {
 			n++;
 			continue;
@@ -2251,7 +2533,7 @@ static int __init init_yaffs_fs(void)
 	/* Install the proc_fs entry */
 	my_proc_entry = create_proc_entry("yaffs",
 					       S_IRUGO | S_IFREG,
-					       &proc_root_kcore);
+					       YPROC_ROOT);
 
 	if (my_proc_entry) {
 		my_proc_entry->write_proc = yaffs_proc_write;
@@ -2297,7 +2579,7 @@ static void __exit exit_yaffs_fs(void)
 	T(YAFFS_TRACE_ALWAYS, ("yaffs " __DATE__ " " __TIME__
 			       " removing. \n"));
 
-	remove_proc_entry("yaffs", &proc_root_kcore);
+	remove_proc_entry("yaffs", YPROC_ROOT);
 
 	fsinst = fs_to_install;
 
-- 
1.6.3.3

