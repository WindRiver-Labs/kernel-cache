From 373ddb3524228841462f002782156c0607a22e5d Mon Sep 17 00:00:00 2001
From: Bruce Ashfield <bruce.ashfield@windriver.com>
Date: Sat, 31 Aug 2013 01:10:23 -0400
Subject: [PATCH 1/3] yaffs2: restore multi-kernel version functionality

The initial integration of yaffs2 was via the single kernel version variant
of the code. That code has some fundamental issues, and isn't a suitable
base.

With this commit, we restore the multi kernel functionality and with it all
required include files.

Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 fs/yaffs2/Kconfig       |  147 +-
 fs/yaffs2/yaffs_mtdif.c |  118 +-
 fs/yaffs2/yaffs_vfs.c   | 3668 +++++++++++++++++++++++++++++------------------
 fs/yaffs2/yportenv.h    |   34 +-
 4 files changed, 2559 insertions(+), 1408 deletions(-)

diff --git a/fs/yaffs2/Kconfig b/fs/yaffs2/Kconfig
index bd6e8df..408570f 100644
--- a/fs/yaffs2/Kconfig
+++ b/fs/yaffs2/Kconfig
@@ -20,11 +20,152 @@ config YAFFS_FS
 	  Further information on yaffs2 is available at
 	  <http://www.aleph1.co.uk/yaffs/>.
 
-config YAFFS_DEBUG
-	bool "Enable yaffs debugging"
+config YAFFS_YAFFS1
+	bool "512 byte / page devices"
 	depends on YAFFS_FS
+	default y
+	help
+	  Enable yaffs1 support -- yaffs for 512 byte / page devices
+
+	  Not needed for 2K-page devices.
+
+	  If unsure, say Y.
+
+config YAFFS_9BYTE_TAGS
+	bool "Use older-style on-NAND data format with pageStatus byte"
+	depends on YAFFS_YAFFS1
+	default n
+	help
+
+	  Older-style on-NAND data format has a "pageStatus" byte to record
+	  chunk/page state.  This byte is zero when the page is discarded.
+	  Choose this option if you have existing on-NAND data using this
+	  format that you need to continue to support.  New data written
+	  also uses the older-style format.  Note: Use of this option
+	  generally requires that MTD's oob layout be adjusted to use the
+	  older-style format.  See notes on tags formats and MTD versions
+	  in yaffs_mtdif1.c.
+
+	  If unsure, say N.
+
+config YAFFS_DOES_ECC
+	bool "Lets yaffs do its own ECC"
+	depends on YAFFS_FS && YAFFS_YAFFS1 && !YAFFS_9BYTE_TAGS
+	default n
+	help
+	  This enables yaffs to use its own ECC functions instead of using
+	  the ones from the generic MTD-NAND driver.
+
+	  If unsure, say N.
+
+config YAFFS_ECC_WRONG_ORDER
+	bool "Use the same ecc byte order as Steven Hill's nand_ecc.c"
+	depends on YAFFS_FS && YAFFS_DOES_ECC && !YAFFS_9BYTE_TAGS
 	default n
 	help
-	  Enable the yaffs debugging tracing.
+	  This makes yaffs_ecc.c use the same ecc byte order as Steven
+	  Hill's nand_ecc.c. If not set, then you get the same ecc byte
+	  order as SmartMedia.
 
 	  If unsure, say N.
+
+config YAFFS_YAFFS2
+	bool "2048 byte (or larger) / page devices"
+	depends on YAFFS_FS
+	default y
+	help
+	  Enable yaffs2 support -- yaffs for >= 2K bytes per page devices
+
+	  If unsure, say Y.
+
+config YAFFS_AUTO_YAFFS2
+	bool "Autoselect yaffs2 format"
+	depends on YAFFS_YAFFS2
+	default y
+	help
+	  Without this, you need to explicitely use yaffs2 as the file
+	  system type. With this, you can say "yaffs" and yaffs or yaffs2
+	  will be used depending on the device page size (yaffs on
+	  512-byte page devices, yaffs2 on 2K page devices).
+
+	  If unsure, say Y.
+
+config YAFFS_DISABLE_TAGS_ECC
+	bool "Disable yaffs from doing ECC on tags by default"
+	depends on YAFFS_FS && YAFFS_YAFFS2
+	default n
+	help
+	  This defaults yaffs to using its own ECC calculations on tags instead of
+	  just relying on the MTD.
+	  This behavior can also be overridden with tags_ecc_on and
+	  tags_ecc_off mount options.
+
+	  If unsure, say N.
+
+config YAFFS_ALWAYS_CHECK_CHUNK_ERASED
+	bool "Force chunk erase check"
+	depends on YAFFS_FS
+	default n
+	help
+          Normally yaffs only checks chunks before writing until an erased
+	  chunk is found. This helps to detect any partially written
+	  chunks that might have happened due to power loss.
+
+	  Enabling this forces on the test that chunks are erased in flash
+	  before writing to them. This takes more time but is potentially
+	  a bit more secure.
+
+	  Suggest setting Y during development and ironing out driver
+	  issues etc. Suggest setting to N if you want faster writing.
+
+	  If unsure, say Y.
+
+config YAFFS_EMPTY_LOST_AND_FOUND
+	bool "Empty lost and found on boot"
+	depends on YAFFS_FS
+	default n
+	help
+	  If this is enabled then the contents of lost and found is
+	  automatically dumped at mount.
+
+	  If unsure, say N.
+
+config YAFFS_DISABLE_BLOCK_REFRESHING
+	bool "Disable yaffs2 block refreshing"
+	depends on YAFFS_FS
+	default n
+	help
+	 If this is set, then block refreshing is disabled.
+	 Block refreshing infrequently refreshes the oldest block in
+	 a yaffs2 file system. This mechanism helps to refresh flash to
+	 mitigate against data loss. This is particularly useful for MLC.
+
+	  If unsure, say N.
+
+config YAFFS_DISABLE_BACKGROUND
+	bool "Disable yaffs2 background processing"
+	depends on YAFFS_FS
+	default n
+	help
+	 If this is set, then background processing is disabled.
+	 Background processing makes many foreground activities faster.
+
+	 If unsure, say N.
+
+config YAFFS_DISABLE_BAD_BLOCK_MARKING
+	bool "Disable yaffs2 bad block marking"
+	depends on YAFFS_FS
+	default n
+	help
+	 Useful during early flash bring up to prevent problems causing
+	 lots of bad block marking.
+
+	 If unsure, say N.
+
+config YAFFS_XATTR
+	bool "Enable yaffs2 xattr support"
+	depends on YAFFS_FS
+	default y
+	help
+	 If this is set then yaffs2 will provide xattr support.
+	 If unsure, say Y.
diff --git a/fs/yaffs2/yaffs_mtdif.c b/fs/yaffs2/yaffs_mtdif.c
index 7b2ac36..7ae63c5 100644
--- a/fs/yaffs2/yaffs_mtdif.c
+++ b/fs/yaffs2/yaffs_mtdif.c
@@ -28,6 +28,21 @@
 #include "yaffs_linux.h"
 
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0))
+#define MTD_OPS_AUTO_OOB MTD_OOB_AUTO
+#endif
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0))
+#define mtd_erase(m, ei) (m)->erase(m, ei)
+#define mtd_write_oob(m, addr, pops) (m)->write_oob(m, addr, pops)
+#define mtd_read_oob(m, addr, pops) (m)->read_oob(m, addr, pops)
+#define mtd_block_isbad(m, offs) (m)->block_isbad(m, offs)
+#define mtd_block_markbad(m, offs) (m)->block_markbad(m, offs)
+#endif
+
+
+
 int nandmtd_erase_block(struct yaffs_dev *dev, int block_no)
 {
 	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
@@ -45,7 +60,7 @@ int nandmtd_erase_block(struct yaffs_dev *dev, int block_no)
 	ei.callback = NULL;
 	ei.priv = (u_long) dev;
 
-	retval = mtd->erase(mtd, &ei);
+	retval = mtd_erase(mtd, &ei);
 
 	if (retval == 0)
 		return YAFFS_OK;
@@ -63,6 +78,20 @@ static 	int yaffs_mtd_write(struct yaffs_dev *dev, int nand_chunk,
 	struct mtd_oob_ops ops;
 	int retval;
 
+	yaffs_trace(YAFFS_TRACE_MTD,
+			"yaffs_mtd_write(%p, %d, %p, %d, %p, %d)\n",
+			dev, nand_chunk, data, data_len, oob, oob_len);
+
+	if (!data || !data_len) {
+		data = NULL;
+		data_len = 0;
+	}
+
+	if (!oob || !oob_len) {
+		oob = NULL;
+		oob_len = 0;
+	}
+
 	addr = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
 	memset(&ops, 0, sizeof(ops));
 	ops.mode = MTD_OPS_AUTO_OOB;
@@ -71,7 +100,7 @@ static 	int yaffs_mtd_write(struct yaffs_dev *dev, int nand_chunk,
 	ops.datbuf = (u8 *)data;
 	ops.oobbuf = (u8 *)oob;
 
-	retval = mtd->write_oob(mtd, addr, &ops);
+	retval = mtd_write_oob(mtd, addr, &ops);
 	if (retval) {
 		yaffs_trace(YAFFS_TRACE_MTD,
 			"write_oob failed, chunk %d, mtd error %d",
@@ -90,7 +119,7 @@ static int yaffs_mtd_read(struct yaffs_dev *dev, int nand_chunk,
 	struct mtd_oob_ops ops;
 	int retval;
 
-	addr = ((loff_t) nand_chunk) * dev->data_bytes_per_chunk;
+	addr = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
 	memset(&ops, 0, sizeof(ops));
 	ops.mode = MTD_OPS_AUTO_OOB;
 	ops.len = (data) ? data_len : 0;
@@ -98,10 +127,16 @@ static int yaffs_mtd_read(struct yaffs_dev *dev, int nand_chunk,
 	ops.datbuf = data;
 	ops.oobbuf = oob;
 
+#if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 20))
+	/* In MTD 2.6.18 to 2.6.19 nand_base.c:nand_do_read_oob() has a bug;
+	 * help it out with ops.len = ops.ooblen when ops.datbuf == NULL.
+	 */
+	ops.len = (ops.datbuf) ? ops.len : ops.ooblen;
+#endif
 	/* Read page and oob using MTD.
 	 * Check status and determine ECC result.
 	 */
-	retval = mtd->read_oob(mtd, addr, &ops);
+	retval = mtd_read_oob(mtd, addr, &ops);
 	if (retval)
 		yaffs_trace(YAFFS_TRACE_MTD,
 			"read_oob failed, chunk %d, mtd error %d",
@@ -154,7 +189,7 @@ static 	int yaffs_mtd_erase(struct yaffs_dev *dev, int block_no)
 	ei.callback = NULL;
 	ei.priv = (u_long) dev;
 
-	retval = mtd->erase(mtd, &ei);
+	retval = mtd_erase(mtd, &ei);
 
 	if (retval == 0)
 		return YAFFS_OK;
@@ -165,24 +200,24 @@ static 	int yaffs_mtd_erase(struct yaffs_dev *dev, int block_no)
 static int yaffs_mtd_mark_bad(struct yaffs_dev *dev, int block_no)
 {
 	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
-	int blocksize = dev->param.chunks_per_block * dev->data_bytes_per_chunk;
+	int blocksize = dev->param.chunks_per_block * dev->param.total_bytes_per_chunk;
 	int retval;
 
 	yaffs_trace(YAFFS_TRACE_BAD_BLOCKS, "marking block %d bad", block_no);
 
-	retval = mtd->block_markbad(mtd, (loff_t) blocksize * block_no);
+	retval = mtd_block_markbad(mtd, (loff_t) blocksize * block_no);
 	return (retval) ? YAFFS_FAIL : YAFFS_OK;
 }
 
 static int yaffs_mtd_check_bad(struct yaffs_dev *dev, int block_no)
 {
 	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
-	int blocksize = dev->param.chunks_per_block * dev->data_bytes_per_chunk;
+	int blocksize = dev->param.chunks_per_block * dev->param.total_bytes_per_chunk;
 	int retval;
 
-	yaffs_trace(YAFFS_TRACE_BAD_BLOCKS, "checking block %d bad", block_no);
+	yaffs_trace(YAFFS_TRACE_MTD, "checking block %d bad", block_no);
 
-	retval = mtd->block_isbad(mtd, (loff_t) blocksize * block_no);
+	retval = mtd_block_isbad(mtd, (loff_t) blocksize * block_no);
 	return (retval) ? YAFFS_FAIL : YAFFS_OK;
 }
 
@@ -197,7 +232,6 @@ static int yaffs_mtd_deinitialise(struct yaffs_dev *dev)
 }
 
 
-
 void yaffs_mtd_drv_install(struct yaffs_dev *dev)
 {
 	struct yaffs_driver *drv = &dev->drv;
@@ -210,3 +244,65 @@ void yaffs_mtd_drv_install(struct yaffs_dev *dev)
 	drv->drv_initialise_fn = yaffs_mtd_initialise;
 	drv->drv_deinitialise_fn = yaffs_mtd_deinitialise;
 }
+
+
+struct mtd_info * yaffs_get_mtd_device(dev_t sdev)
+{
+	struct mtd_info *mtd;
+
+	mtd = yaffs_get_mtd_device(sdev);
+
+	/* Check it's an mtd device..... */
+	if (MAJOR(sdev) != MTD_BLOCK_MAJOR)
+		return NULL;	/* This isn't an mtd device */
+
+	/* Check it's NAND */
+	if (mtd->type != MTD_NANDFLASH) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs: MTD device is not NAND it's type %d",
+			mtd->type);
+		return NULL;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS, " %s %d", WRITE_SIZE_STR, WRITE_SIZE(mtd));
+	yaffs_trace(YAFFS_TRACE_OS, " oobsize %d", mtd->oobsize);
+	yaffs_trace(YAFFS_TRACE_OS, " erasesize %d", mtd->erasesize);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+	yaffs_trace(YAFFS_TRACE_OS, " size %u", mtd->size);
+#else
+	yaffs_trace(YAFFS_TRACE_OS, " size %lld", mtd->size);
+#endif
+
+	return mtd;
+}
+
+int yaffs_verify_mtd(struct mtd_info *mtd, int yaffs_version, int inband_tags)
+{
+	if (yaffs_version == 2) {
+		if ((WRITE_SIZE(mtd) < YAFFS_MIN_YAFFS2_CHUNK_SIZE ||
+		     mtd->oobsize < YAFFS_MIN_YAFFS2_SPARE_SIZE) &&
+		    !inband_tags) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not have the right page sizes"
+			);
+			return -1;
+		}
+	} else {
+		if (WRITE_SIZE(mtd) < YAFFS_BYTES_PER_CHUNK ||
+		    mtd->oobsize != YAFFS_BYTES_PER_SPARE) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support have the right page sizes"
+			);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+
+void yaffs_put_mtd_device(struct mtd_info *mtd)
+{
+	if(mtd)
+		put_mtd_device(mtd);
+}
diff --git a/fs/yaffs2/yaffs_vfs.c b/fs/yaffs2/yaffs_vfs.c
index 145517b..67050d4 100644
--- a/fs/yaffs2/yaffs_vfs.c
+++ b/fs/yaffs2/yaffs_vfs.c
@@ -32,28 +32,139 @@
  */
 
 /*
- * NB There are two variants of Linux VFS glue code. This variant supports
- * a single version and should not include any multi-version code.
+ * There are two variants of the VFS glue code. This variant should compile
+ * for any version of Linux.
  */
 #include <linux/version.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 10))
+#define YAFFS_COMPILE_BACKGROUND
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23))
+#define YAFFS_COMPILE_FREEZER
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28))
+#define YAFFS_COMPILE_EXPORTFS
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#define YAFFS_USE_SETATTR_COPY
+#define YAFFS_USE_TRUNCATE_SETSIZE
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#define YAFFS_HAS_EVICT_INODE
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+#define YAFFS_NEW_FOLLOW_LINK 1
+#else
+#define YAFFS_NEW_FOLLOW_LINK 0
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
+#define YAFFS_HAS_WRITE_SUPER
+#endif
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/fs.h>
 #include <linux/proc_fs.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 39))
+#include <linux/smp_lock.h>
+#endif
 #include <linux/pagemap.h>
 #include <linux/mtd/mtd.h>
 #include <linux/interrupt.h>
 #include <linux/string.h>
 #include <linux/ctype.h>
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
 #include <linux/namei.h>
+#endif
+
+#ifdef YAFFS_COMPILE_EXPORTFS
 #include <linux/exportfs.h>
+#endif
+
+#ifdef YAFFS_COMPILE_BACKGROUND
 #include <linux/kthread.h>
 #include <linux/delay.h>
+#endif
+#ifdef YAFFS_COMPILE_FREEZER
 #include <linux/freezer.h>
+#endif
+
 #include <asm/div64.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
 #include <linux/statfs.h>
+
+#define UnlockPage(p) unlock_page(p)
+#define Page_Uptodate(page)	test_bit(PG_uptodate, &(page)->flags)
+
+/* FIXME: use sb->s_id instead ? */
+#define yaffs_devname(sb, buf)	bdevname(sb->s_bdev, buf)
+
+#else
+
+#include <linux/locks.h>
+#define	BDEVNAME_SIZE		0
+#define	yaffs_devname(sb, buf)	kdevname(sb->s_dev)
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0))
+/* added NCB 26/5/2006 for 2.4.25-vrs2-tcl1 kernel */
+#define __user
+#endif
+
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#define YPROC_ROOT  (&proc_root)
+#else
+#define YPROC_ROOT  NULL
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#define Y_INIT_TIMER(a)	init_timer(a)
+#else
+#define Y_INIT_TIMER(a)	init_timer_on_stack(a)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27))
+#define YAFFS_USE_WRITE_BEGIN_END 1
+#else
+#define YAFFS_USE_WRITE_BEGIN_END 0
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
+#define YAFFS_SUPER_HAS_DIRTY
+#endif
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0))
+#define set_nlink(inode, count)  do { (inode)->i_nlink = (count); } while(0)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 28))
+static uint32_t YCALCBLOCKS(uint64_t partition_size, uint32_t block_size)
+{
+	uint64_t result = partition_size;
+	do_div(result, block_size);
+	return (uint32_t) result;
+}
+#else
+#define YCALCBLOCKS(s, b) ((s)/(b))
+#endif
+
 #include <linux/uaccess.h>
 #include <linux/mtd/mtd.h>
 
@@ -61,51 +172,78 @@
 #include "yaffs_trace.h"
 #include "yaffs_guts.h"
 #include "yaffs_attribs.h"
+
 #include "yaffs_linux.h"
+
 #include "yaffs_mtdif.h"
-#include "yaffs_mtdif1.h"
-#include "yaffs_mtdif2.h"
+#include "yaffs_packedtags2.h"
+#include "yaffs_getblockinfo.h"
+
+unsigned int yaffs_trace_mask =
+		YAFFS_TRACE_BAD_BLOCKS |
+		YAFFS_TRACE_ALWAYS |
+		0;
 
-unsigned int yaffs_trace_mask = YAFFS_TRACE_BAD_BLOCKS | YAFFS_TRACE_ALWAYS;
 unsigned int yaffs_wr_attempts = YAFFS_WR_ATTEMPTS;
 unsigned int yaffs_auto_checkpoint = 1;
 unsigned int yaffs_gc_control = 1;
 unsigned int yaffs_bg_enable = 1;
 unsigned int yaffs_auto_select = 1;
-
 /* Module Parameters */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
 module_param(yaffs_trace_mask, uint, 0644);
 module_param(yaffs_wr_attempts, uint, 0644);
 module_param(yaffs_auto_checkpoint, uint, 0644);
 module_param(yaffs_gc_control, uint, 0644);
 module_param(yaffs_bg_enable, uint, 0644);
-module_param(yaffs_auto_select, uint, 0644);
+#else
+MODULE_PARM(yaffs_trace_mask, "i");
+MODULE_PARM(yaffs_wr_attempts, "i");
+MODULE_PARM(yaffs_auto_checkpoint, "i");
+MODULE_PARM(yaffs_gc_control, "i");
+#endif
 
-#define yaffs_devname(sb, buf)	bdevname(sb->s_bdev, buf)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+/* use iget and read_inode */
+#define Y_IGET(sb, inum) iget((sb), (inum))
 
-static uint32_t YCALCBLOCKS(uint64_t partition_size, uint32_t block_size)
-{
-	uint64_t result = partition_size;
+#else
+/* Call local equivalent */
+#define YAFFS_USE_OWN_IGET
+#define Y_IGET(sb, inum) yaffs_iget((sb), (inum))
 
-	do_div(result, block_size);
-	return (uint32_t) result;
-}
+#endif
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
 #define yaffs_inode_to_obj_lv(iptr) ((iptr)->i_private)
-#define yaffs_inode_to_obj(iptr)\
+#else
+#define yaffs_inode_to_obj_lv(iptr) ((iptr)->u.generic_ip)
+#endif
+
+#define yaffs_inode_to_obj(iptr) \
 	((struct yaffs_obj *)(yaffs_inode_to_obj_lv(iptr)))
 #define yaffs_dentry_to_obj(dptr) yaffs_inode_to_obj((dptr)->d_inode)
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
 #define yaffs_super_to_dev(sb)	((struct yaffs_dev *)sb->s_fs_info)
+#else
+#define yaffs_super_to_dev(sb)	((struct yaffs_dev *)sb->u.generic_sbp)
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0))
+#define Y_CLEAR_INODE(i) clear_inode(i)
+#else
+#define Y_CLEAR_INODE(i) end_writeback(i)
+#endif
+
 
 #define update_dir_time(dir) do {\
 			(dir)->i_ctime = (dir)->i_mtime = CURRENT_TIME; \
 		} while (0)
 
+static void yaffs_fill_inode_from_obj(struct inode *inode,
+				      struct yaffs_obj *obj);
 
-static unsigned yaffs_gc_control_callback(struct yaffs_dev *dev)
-{
-	return yaffs_gc_control;
-}
 
 static void yaffs_gross_lock(struct yaffs_dev *dev)
 {
@@ -120,519 +258,1290 @@ static void yaffs_gross_unlock(struct yaffs_dev *dev)
 	mutex_unlock(&(yaffs_dev_to_lc(dev)->gross_lock));
 }
 
-static void yaffs_fill_inode_from_obj(struct inode *inode,
-				      struct yaffs_obj *obj);
 
-static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino)
+static int yaffs_readpage_nolock(struct file *f, struct page *pg)
 {
-	struct inode *inode;
-	struct yaffs_obj *obj;
-	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
-
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_iget for %lu", ino);
+	/* Lifted from jffs2 */
 
-	inode = iget_locked(sb, ino);
-	if (!inode)
-		return ERR_PTR(-ENOMEM);
-	if (!(inode->i_state & I_NEW))
-		return inode;
+	struct yaffs_obj *obj;
+	unsigned char *pg_buf;
+	int ret;
+	loff_t pos = ((loff_t) pg->index) << PAGE_CACHE_SHIFT;
+	struct yaffs_dev *dev;
 
-	/* NB This is called as a side effect of other functions, but
-	 * we had to release the lock to prevent deadlocks, so
-	 * need to lock again.
-	 */
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_readpage_nolock at %lld, size %08x",
+		(long long)pos,
+		(unsigned)PAGE_CACHE_SIZE);
 
-	yaffs_gross_lock(dev);
+	obj = yaffs_dentry_to_obj(f->f_dentry);
 
-	obj = yaffs_find_by_number(dev, inode->i_ino);
-	yaffs_fill_inode_from_obj(inode, obj);
+	dev = obj->my_dev;
 
-	yaffs_gross_unlock(dev);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	BUG_ON(!PageLocked(pg));
+#else
+	if (!PageLocked(pg))
+		PAGE_BUG(pg);
+#endif
 
-	unlock_new_inode(inode);
-	return inode;
-}
+	pg_buf = kmap(pg);
+	/* FIXME: Can kmap fail? */
 
-struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
-			      struct yaffs_obj *obj)
-{
-	struct inode *inode;
+	yaffs_gross_lock(dev);
 
-	if (!sb) {
-		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_get_inode for NULL super_block!!");
-		return NULL;
+	ret = yaffs_file_rd(obj, pg_buf, pos, PAGE_CACHE_SIZE);
 
-	}
+	yaffs_gross_unlock(dev);
 
-	if (!obj) {
-		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_get_inode for NULL object!!");
-		return NULL;
+	if (ret >= 0)
+		ret = 0;
 
+	if (ret) {
+		ClearPageUptodate(pg);
+		SetPageError(pg);
+	} else {
+		SetPageUptodate(pg);
+		ClearPageError(pg);
 	}
 
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_get_inode for object %d",
-		obj->obj_id);
-
-	inode = yaffs_iget(sb, obj->obj_id);
-	if (IS_ERR(inode))
-		return NULL;
-
-	/* NB Side effect: iget calls back to yaffs_read_inode(). */
-	/* iget also increments the inode's i_count */
-	/* NB You can't be holding gross_lock or deadlock will happen! */
+	flush_dcache_page(pg);
+	kunmap(pg);
 
-	return inode;
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage_nolock done");
+	return ret;
 }
 
-static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
-		       dev_t rdev)
+static int yaffs_readpage_unlock(struct file *f, struct page *pg)
 {
-	struct inode *inode;
-	struct yaffs_obj *obj = NULL;
-	struct yaffs_dev *dev;
-	struct yaffs_obj *parent = yaffs_inode_to_obj(dir);
-	int error;
-	uid_t uid = current->cred->fsuid;
-	gid_t gid =
-	    (dir->i_mode & S_ISGID) ? dir->i_gid : current->cred->fsgid;
-
-	if ((dir->i_mode & S_ISGID) && S_ISDIR(mode))
-		mode |= S_ISGID;
-
-	if (!parent) {
-		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_mknod: could not get parent object");
-		return -EPERM;
-	}
+	int ret = yaffs_readpage_nolock(f, pg);
+	UnlockPage(pg);
+	return ret;
+}
 
-	yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_mknod: parent object %d type %d",
-			parent->obj_id, parent->variant_type);
+static int yaffs_readpage(struct file *f, struct page *pg)
+{
+	int ret;
 
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_mknod: making oject for %s, mode %x dev %x",
-		dentry->d_name.name, mode, rdev);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage");
+	ret = yaffs_readpage_unlock(f, pg);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage done");
+	return ret;
+}
 
-	dev = parent->my_dev;
 
-	yaffs_gross_lock(dev);
+static void yaffs_set_super_dirty_val(struct yaffs_dev *dev, int val)
+{
+	struct yaffs_linux_context *lc = yaffs_dev_to_lc(dev);
 
-	if (yaffs_get_n_free_chunks(dev) < 1) {
-		error = -ENOSPC;
-		goto err_out;
-	}
+	if (lc)
+		lc->dirty = val;
 
-	switch (mode & S_IFMT) {
-	default:
-		/* Special (socket, fifo, device...) */
-		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making special");
-		obj =
-		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
-					 gid, old_encode_dev(rdev));
-		break;
-	case S_IFREG:		/* file          */
-		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making file");
-		obj = yaffs_create_file(parent, dentry->d_name.name, mode, uid,
-					gid);
-		break;
-	case S_IFDIR:		/* directory */
-		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making directory");
-		obj = yaffs_create_dir(parent, dentry->d_name.name, mode,
-				       uid, gid);
-		break;
-	case S_IFLNK:		/* symlink */
-		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making symlink");
-		obj = NULL;	/* Do we ever get here? */
-		break;
-	}
+# ifdef YAFFS_SUPER_HAS_DIRTY
+	{
+		struct super_block *sb = lc->super;
 
-	if (!obj) {
-		error = -ENOMEM;
-		goto err_out;
+		if (sb)
+			sb->s_dirt = val;
 	}
-
-	/* Can not call yaffs_get_inode() with gross lock held */
-	yaffs_gross_unlock(dev);
-
-
-	inode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);
-	d_instantiate(dentry, inode);
-	update_dir_time(dir);
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_mknod created object %d count = %d",
-		obj->obj_id, atomic_read(&inode->i_count));
-	yaffs_fill_inode_from_obj(dir, parent);
-	return 0;
-
-err_out:
-	yaffs_gross_unlock(dev);
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod error %d", error);
-	return error;
+#endif
 
 }
 
-static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+static void yaffs_set_super_dirty(struct yaffs_dev *dev)
 {
-	return yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);
+	yaffs_set_super_dirty_val(dev, 1);
 }
 
-static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
-			struct nameidata *n)
+static void yaffs_clear_super_dirty(struct yaffs_dev *dev)
 {
-	return yaffs_mknod(dir, dentry, mode | S_IFREG, 0);
+	yaffs_set_super_dirty_val(dev, 0);
 }
 
-static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
-		      struct dentry *dentry)
+static int yaffs_check_super_dirty(struct yaffs_dev *dev)
 {
-	struct inode *inode = old_dentry->d_inode;
-	struct yaffs_obj *obj = NULL;
-	struct yaffs_obj *link = NULL;
-	struct yaffs_dev *dev;
-
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_link");
-
-	obj = yaffs_inode_to_obj(inode);
-	dev = obj->my_dev;
-
-	yaffs_gross_lock(dev);
-
-	if (!S_ISDIR(inode->i_mode))	/* Don't link directories */
-		link =
-		    yaffs_link_obj(yaffs_inode_to_obj(dir), dentry->d_name.name,
-				   obj);
+	struct yaffs_linux_context *lc = yaffs_dev_to_lc(dev);
 
-	if (link) {
-		set_nlink(old_dentry->d_inode, yaffs_get_obj_link_count(obj));
-		d_instantiate(dentry, old_dentry->d_inode);
-		atomic_inc(&old_dentry->d_inode->i_count);
-		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_link link count %d i_count %d",
-			old_dentry->d_inode->i_nlink,
-			atomic_read(&old_dentry->d_inode->i_count));
-	}
+	if (lc && lc->dirty)
+		return 1;
 
-	yaffs_gross_unlock(dev);
+# ifdef YAFFS_SUPER_HAS_DIRTY
+	{
+		struct super_block *sb = lc->super;
 
-	if (link) {
-		update_dir_time(dir);
-		return 0;
+		if (sb && sb->s_dirt)
+			return 1;
 	}
+#endif
+	return 0;
 
-	return -EPERM;
 }
 
-static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
-			 const char *symname)
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc)
+#else
+static int yaffs_writepage(struct page *page)
+#endif
 {
-	struct yaffs_obj *obj;
 	struct yaffs_dev *dev;
+	struct address_space *mapping = page->mapping;
 	struct inode *inode;
-	uid_t uid = current->cred->fsuid;
-	gid_t gid =
-	    (dir->i_mode & S_ISGID) ? dir->i_gid : current->cred->fsgid;
+	unsigned long end_index;
+	char *buffer;
+	struct yaffs_obj *obj;
+	int n_written = 0;
+	unsigned n_bytes;
+	loff_t i_size;
 
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_symlink");
+	if (!mapping)
+		BUG();
+	inode = mapping->host;
+	if (!inode)
+		BUG();
+	i_size = i_size_read(inode);
 
-	if (strnlen(dentry->d_name.name, YAFFS_MAX_NAME_LENGTH + 1) >
-				YAFFS_MAX_NAME_LENGTH)
-		return -ENAMETOOLONG;
+	end_index = i_size >> PAGE_CACHE_SHIFT;
 
-	if (strnlen(symname, YAFFS_MAX_ALIAS_LENGTH + 1) >
-				YAFFS_MAX_ALIAS_LENGTH)
-		return -ENAMETOOLONG;
+	if (page->index < end_index)
+		n_bytes = PAGE_CACHE_SIZE;
+	else {
+		n_bytes = i_size & (PAGE_CACHE_SIZE - 1);
 
-	dev = yaffs_inode_to_obj(dir)->my_dev;
-	yaffs_gross_lock(dev);
-	obj = yaffs_create_symlink(yaffs_inode_to_obj(dir), dentry->d_name.name,
-				   S_IFLNK | S_IRWXUGO, uid, gid, symname);
-	yaffs_gross_unlock(dev);
+		if (page->index > end_index || !n_bytes) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_writepage at %lld, inode size = %lld!!",
+				((loff_t)page->index) << PAGE_CACHE_SHIFT,
+				inode->i_size);
+			yaffs_trace(YAFFS_TRACE_OS,
+				"                -> don't care!!");
 
-	if (!obj) {
-		yaffs_trace(YAFFS_TRACE_OS, "symlink not created");
-		return -ENOMEM;
+			zero_user_segment(page, 0, PAGE_CACHE_SIZE);
+			set_page_writeback(page);
+			unlock_page(page);
+			end_page_writeback(page);
+			return 0;
+		}
 	}
 
-	inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
-	d_instantiate(dentry, inode);
-	update_dir_time(dir);
-	yaffs_trace(YAFFS_TRACE_OS, "symlink created OK");
+	if (n_bytes != PAGE_CACHE_SIZE)
+		zero_user_segment(page, n_bytes, PAGE_CACHE_SIZE);
 
-	return 0;
-}
+	get_page(page);
 
-static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
-				   struct nameidata *n)
-{
-	struct yaffs_obj *obj;
-	struct inode *inode = NULL;
-	struct yaffs_dev *dev = yaffs_inode_to_obj(dir)->my_dev;
+	buffer = kmap(page);
 
-	if (current != yaffs_dev_to_lc(dev)->readdir_process)
-		yaffs_gross_lock(dev);
+	obj = yaffs_inode_to_obj(inode);
+	dev = obj->my_dev;
+	yaffs_gross_lock(dev);
 
 	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_lookup for %d:%s",
-		yaffs_inode_to_obj(dir)->obj_id, dentry->d_name.name);
-
-	obj = yaffs_find_by_name(yaffs_inode_to_obj(dir), dentry->d_name.name);
-
-	obj = yaffs_get_equivalent_obj(obj);	/* in case it was a hardlink */
-
-	/* Can't hold gross lock when calling yaffs_get_inode() */
-	if (current != yaffs_dev_to_lc(dev)->readdir_process)
-		yaffs_gross_unlock(dev);
-
-	if (obj) {
-		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_lookup found %d", obj->obj_id);
+		"yaffs_writepage at %lld, size %08x",
+		((loff_t)page->index) << PAGE_CACHE_SHIFT, n_bytes);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag0: obj = %lld, ino = %lld",
+		obj->variant.file_variant.file_size, inode->i_size);
 
-		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+	n_written = yaffs_wr_file(obj, buffer,
+				  ((loff_t)page->index) << PAGE_CACHE_SHIFT, n_bytes, 0);
 
-		if (inode) {
-			yaffs_trace(YAFFS_TRACE_OS, "yaffs_loookup dentry");
-			d_add(dentry, inode);
-			/* return dentry; */
-			return NULL;
-		}
+	yaffs_set_super_dirty(dev);
 
-	} else {
-		yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup not found");
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag1: obj = %lld, ino = %lld",
+		obj->variant.file_variant.file_size, inode->i_size);
 
-	}
+	yaffs_gross_unlock(dev);
 
-	d_add(dentry, inode);
+	kunmap(page);
+	set_page_writeback(page);
+	unlock_page(page);
+	end_page_writeback(page);
+	put_page(page);
 
-	return NULL;
+	return (n_written == n_bytes) ? 0 : -ENOSPC;
 }
 
-static int yaffs_unlink(struct inode *dir, struct dentry *dentry)
+/* Space holding and freeing is done to ensure we have space available for write_begin/end */
+/* For now we just assume few parallel writes and check against a small number. */
+/* Todo: need to do this with a counter to handle parallel reads better */
+
+static ssize_t yaffs_hold_space(struct file *f)
 {
-	int ret_val;
-	struct yaffs_dev *dev;
 	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	int n_free_chunks;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
 
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_unlink %d:%s",
-		(int)(dir->i_ino), dentry->d_name.name);
-	obj = yaffs_inode_to_obj(dir);
 	dev = obj->my_dev;
 
 	yaffs_gross_lock(dev);
 
-	ret_val = yaffs_unlinker(obj, dentry->d_name.name);
+	n_free_chunks = yaffs_get_n_free_chunks(dev);
 
-	if (ret_val == YAFFS_OK) {
-		inode_dec_link_count(dentry->d_inode);
-		dir->i_version++;
-		yaffs_gross_unlock(dev);
-		update_dir_time(dir);
-		return 0;
-	}
 	yaffs_gross_unlock(dev);
-	return -ENOTEMPTY;
+
+	return (n_free_chunks > 20) ? 1 : 0;
 }
 
-static int yaffs_sync_object(struct file *file,
-				loff_t start, loff_t end, int datasync)
+static void yaffs_release_space(struct file *f)
 {
-
 	struct yaffs_obj *obj;
 	struct yaffs_dev *dev;
-	struct dentry *dentry = file->f_path.dentry;
 
-	obj = yaffs_dentry_to_obj(dentry);
+	obj = yaffs_dentry_to_obj(f->f_dentry);
 
 	dev = obj->my_dev;
 
-	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC, "yaffs_sync_object");
 	yaffs_gross_lock(dev);
-	yaffs_flush_file(obj, 1, datasync);
+
 	yaffs_gross_unlock(dev);
-	return 0;
 }
-/*
- * The VFS layer already does all the dentry stuff for rename.
- *
- * NB: POSIX says you can rename an object over an old object of the same name
- */
-static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
-			struct inode *new_dir, struct dentry *new_dentry)
-{
-	struct yaffs_dev *dev;
-	int ret_val = YAFFS_FAIL;
-	struct yaffs_obj *target;
-
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_rename");
-	dev = yaffs_inode_to_obj(old_dir)->my_dev;
 
-	yaffs_gross_lock(dev);
-
-	/* Check if the target is an existing directory that is not empty. */
-	target = yaffs_find_by_name(yaffs_inode_to_obj(new_dir),
-				    new_dentry->d_name.name);
-
-	if (target && target->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY &&
-	    !list_empty(&target->variant.dir_variant.children)) {
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+			     loff_t pos, unsigned len, unsigned flags,
+			     struct page **pagep, void **fsdata)
+{
+	struct page *pg = NULL;
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
 
-		yaffs_trace(YAFFS_TRACE_OS, "target is non-empty dir");
+	int ret = 0;
+	int space_held = 0;
 
-		ret_val = YAFFS_FAIL;
-	} else {
-		/* Now does unlinking internally using shadowing mechanism */
-		yaffs_trace(YAFFS_TRACE_OS, "calling yaffs_rename_obj");
+	/* Get a page */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+	pg = grab_cache_page_write_begin(mapping, index, flags);
+#else
+	pg = __grab_cache_page(mapping, index);
+#endif
 
-		ret_val = yaffs_rename_obj(yaffs_inode_to_obj(old_dir),
-					   old_dentry->d_name.name,
-					   yaffs_inode_to_obj(new_dir),
-					   new_dentry->d_name.name);
+	*pagep = pg;
+	if (!pg) {
+		ret = -ENOMEM;
+		goto out;
 	}
-	yaffs_gross_unlock(dev);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"start yaffs_write_begin index %d(%x) uptodate %d",
+		(int)index, (int)index, Page_Uptodate(pg) ? 1 : 0);
 
-	if (ret_val == YAFFS_OK) {
-		if (target)
-			inode_dec_link_count(new_dentry->d_inode);
+	/* Get fs space */
+	space_held = yaffs_hold_space(filp);
 
-		update_dir_time(old_dir);
-		if (old_dir != new_dir)
-			update_dir_time(new_dir);
-		return 0;
-	} else {
-		return -ENOTEMPTY;
+	if (!space_held) {
+		ret = -ENOSPC;
+		goto out;
 	}
-}
 
-static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)
-{
-	struct inode *inode = dentry->d_inode;
-	int error = 0;
-	struct yaffs_dev *dev;
-	int result;
+	/* Update page if required */
 
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_setattr of object %d",
-		yaffs_inode_to_obj(inode)->obj_id);
+	if (!Page_Uptodate(pg))
+		ret = yaffs_readpage_nolock(filp, pg);
 
-	/* Fail if a requested resize >= 2GB */
-	if (attr->ia_valid & ATTR_SIZE && (attr->ia_size >> 31))
-		error = -EINVAL;
+	if (ret)
+		goto out;
 
-	if (!error)
-		error = inode_change_ok(inode, attr);
+	/* Happy path return */
+	yaffs_trace(YAFFS_TRACE_OS, "end yaffs_write_begin - ok");
 
-	if (!error) {
-		setattr_copy(inode, attr);
-		yaffs_trace(YAFFS_TRACE_OS, "inode_setattr called");
-		if (attr->ia_valid & ATTR_SIZE) {
-			truncate_setsize(inode, attr->ia_size);
-			inode->i_blocks = (inode->i_size + 511) >> 9;
-		}
-		dev = yaffs_inode_to_obj(inode)->my_dev;
-		if (attr->ia_valid & ATTR_SIZE) {
-			yaffs_trace(YAFFS_TRACE_OS, "resize to %d(%x)",
-					   (int)(attr->ia_size),
-					   (int)(attr->ia_size));
-		}
+	return 0;
 
-		yaffs_gross_lock(dev);
-		result = yaffs_set_attribs(yaffs_inode_to_obj(inode), attr);
-		if (result != YAFFS_OK)
-			error = -EPERM;
-		yaffs_gross_unlock(dev);
+out:
+	yaffs_trace(YAFFS_TRACE_OS,
+		"end yaffs_write_begin fail returning %d", ret);
+	if (space_held)
+		yaffs_release_space(filp);
+	if (pg) {
+		unlock_page(pg);
+		page_cache_release(pg);
 	}
+	return ret;
+}
 
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setattr done returning %d", error);
+#else
 
-	return error;
+static int yaffs_prepare_write(struct file *f, struct page *pg,
+			       unsigned offset, unsigned to)
+{
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_prepair_write");
+
+	if (!Page_Uptodate(pg))
+		return yaffs_readpage_nolock(f, pg);
+	return 0;
 }
+#endif
 
-static int yaffs_setxattr(struct dentry *dentry, const char *name,
-		   const void *value, size_t size, int flags)
+
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t * pos)
 {
-	struct inode *inode = dentry->d_inode;
-	int error;
+	struct yaffs_obj *obj;
+	int n_written;
+	loff_t ipos;
+	struct inode *inode;
 	struct yaffs_dev *dev;
-	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
 
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr of object %d", obj->obj_id);
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_file_write: hey obj is null!");
+                return -EINVAL;
+        }
 
 	dev = obj->my_dev;
-	yaffs_gross_lock(dev);
-	error = yaffs_set_xattrib(obj, name, value, size, flags);
-	yaffs_gross_unlock(dev);
 
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr done returning %d", error);
+	yaffs_gross_lock(dev);
 
-	return error;
-}
+	inode = f->f_dentry->d_inode;
 
-static ssize_t yaffs_getxattr(struct dentry *dentry, const char *name,
-				void *buff, size_t size)
-{
-	struct inode *inode = dentry->d_inode;
-	int error;
-	struct yaffs_dev *dev;
-	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+	if (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND)
+		ipos = inode->i_size;
+	else
+		ipos = *pos;
 
 	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_getxattr \"%s\" from object %d",
-		name, obj->obj_id);
+		"yaffs_file_write about to write writing %u(%x) bytes to object %d at %lld",
+		(unsigned)n, (unsigned)n, obj->obj_id, ipos);
 
-	dev = obj->my_dev;
-	yaffs_gross_lock(dev);
-	error = yaffs_get_xattrib(obj, name, buff, size);
-	yaffs_gross_unlock(dev);
+	n_written = yaffs_wr_file(obj, buf, ipos, n, 0);
 
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_getxattr done returning %d", error);
+	yaffs_set_super_dirty(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_write: %d(%x) bytes written",
+		(unsigned)n, (unsigned)n);
+
+	if (n_written > 0) {
+		ipos += n_written;
+		*pos = ipos;
+		if (ipos > inode->i_size) {
+			inode->i_size = ipos;
+			inode->i_blocks = (ipos + 511) >> 9;
+
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_file_write size updated to %lld bytes, %d blocks",
+				ipos, (int)(inode->i_blocks));
+		}
+
+	}
+	yaffs_gross_unlock(dev);
+	return (n_written == 0) && (n > 0) ? -ENOSPC : n_written;
+}
+
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *pg, void *fsdadata)
+{
+	int ret = 0;
+	void *addr, *kva;
+	uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE - 1);
+
+	kva = kmap(pg);
+	addr = kva + offset_into_page;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_write_end addr %p pos %lld n_bytes %d",
+		addr, pos, copied);
+
+	ret = yaffs_file_write(filp, addr, copied, &pos);
+
+	if (ret != copied) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_write_end not same size ret %d  copied %d",
+			ret, copied);
+		SetPageError(pg);
+	}
+
+	kunmap(pg);
+
+	yaffs_release_space(filp);
+	unlock_page(pg);
+	page_cache_release(pg);
+	return ret;
+}
+#else
+
+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+			      unsigned to)
+{
+	void *addr, *kva;
+
+	loff_t pos = (((loff_t) pg->index) << PAGE_CACHE_SHIFT) + offset;
+	int n_bytes = to - offset;
+	int n_written;
+
+	kva = kmap(pg);
+	addr = kva + offset;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_commit_write addr %p pos %lld n_bytes %d",
+		addr, pos, n_bytes);
+
+	n_written = yaffs_file_write(f, addr, n_bytes, &pos);
+
+	if (n_written != n_bytes) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_commit_write not same size n_written %d  n_bytes %d",
+			n_written, n_bytes);
+		SetPageError(pg);
+	}
+	kunmap(pg);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_commit_write returning %d",
+		n_written == n_bytes ? 0 : n_written);
+
+	return n_written == n_bytes ? 0 : n_written;
+}
+#endif
+
+static struct address_space_operations yaffs_file_address_operations = {
+	.readpage = yaffs_readpage,
+	.writepage = yaffs_writepage,
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+	.write_begin = yaffs_write_begin,
+	.write_end = yaffs_write_end,
+#else
+	.prepare_write = yaffs_prepare_write,
+	.commit_write = yaffs_commit_write,
+#endif
+};
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_file_flush(struct file *file, fl_owner_t id)
+#else
+static int yaffs_file_flush(struct file *file)
+#endif
+{
+	struct yaffs_obj *obj = yaffs_dentry_to_obj(file->f_dentry);
+
+	struct yaffs_dev *dev = obj->my_dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_flush object %d (%s)",
+		obj->obj_id,
+		obj->dirty ? "dirty" : "clean");
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_file(obj, 1, 0);
+
+	yaffs_gross_unlock(dev);
+
+	return 0;
+}
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static int yaffs_sync_object(struct file *file, loff_t start, loff_t end, int datasync)
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+static int yaffs_sync_object(struct file *file, int datasync)
+#else
+static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+			     int datasync)
+#endif
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+	struct dentry *dentry = file->f_path.dentry;
+#endif
+
+	obj = yaffs_dentry_to_obj(dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+		"yaffs_sync_object");
+	yaffs_gross_lock(dev);
+	yaffs_flush_file(obj, 1, datasync);
+	yaffs_gross_unlock(dev);
+	return 0;
+}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22))
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.splice_read = generic_file_splice_read,
+	.splice_write = generic_file_splice_write,
+	.llseek = generic_file_llseek,
+};
+
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.sendfile = generic_file_sendfile,
+};
+
+#else
+
+static const struct file_operations yaffs_file_operations = {
+	.read = generic_file_read,
+	.write = generic_file_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	.sendfile = generic_file_sendfile,
+#endif
+};
+#endif
+
+
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+static void zero_user_segment(struct page *page, unsigned start, unsigned end)
+{
+	void *kaddr = kmap_atomic(page, KM_USER0);
+	memset(kaddr + start, 0, end - start);
+	kunmap_atomic(kaddr, KM_USER0);
+	flush_dcache_page(page);
+}
+#endif
+
+
+static int yaffs_vfs_setsize(struct inode *inode, loff_t newsize)
+{
+#ifdef YAFFS_USE_TRUNCATE_SETSIZE
+	truncate_setsize(inode, newsize);
+	return 0;
+#else
+	truncate_inode_pages(&inode->i_data, newsize);
+	return 0;
+#endif
+
+}
+
+
+static int yaffs_vfs_setattr(struct inode *inode, struct iattr *attr)
+{
+#ifdef YAFFS_USE_SETATTR_COPY
+	setattr_copy(inode, attr);
+	return 0;
+#else
+	return inode_setattr(inode, attr);
+#endif
+
+}
+
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_setattr of object %d",
+		yaffs_inode_to_obj(inode)->obj_id);
+#if 0
+	/* Fail if a requested resize >= 2GB */
+	if (attr->ia_valid & ATTR_SIZE && (attr->ia_size >> 31))
+		error = -EINVAL;
+#endif
+
+	if (error == 0)
+		error = inode_change_ok(inode, attr);
+	if (error == 0) {
+		int result;
+		if (!error) {
+			error = yaffs_vfs_setattr(inode, attr);
+			yaffs_trace(YAFFS_TRACE_OS, "inode_setattr called");
+			if (attr->ia_valid & ATTR_SIZE) {
+				yaffs_vfs_setsize(inode, attr->ia_size);
+				inode->i_blocks = (inode->i_size + 511) >> 9;
+			}
+		}
+		dev = yaffs_inode_to_obj(inode)->my_dev;
+		if (attr->ia_valid & ATTR_SIZE) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"resize to %d(%x)",
+				(int)(attr->ia_size),
+				(int)(attr->ia_size));
+		}
+		yaffs_gross_lock(dev);
+		result = yaffs_set_attribs(yaffs_inode_to_obj(inode), attr);
+		if (result == YAFFS_OK) {
+			error = 0;
+		} else {
+			error = -EPERM;
+		}
+		yaffs_gross_unlock(dev);
+
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setattr done returning %d", error);
+
+	return error;
+}
+
+static int yaffs_setxattr(struct dentry *dentry, const char *name,
+		   const void *value, size_t size, int flags)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		int result;
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		result = yaffs_set_xattrib(obj, name, value, size, flags);
+		if (result == YAFFS_OK)
+			error = 0;
+		else if (result < 0)
+			error = result;
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr done returning %d", error);
+
+	return error;
+}
+
+static ssize_t yaffs_getxattr(struct dentry * dentry, const char *name,
+			void *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_getxattr \"%s\" from object %d",
+		name, obj->obj_id);
+
+	if (error == 0) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		error = yaffs_get_xattrib(obj, name, buff, size);
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_getxattr done returning %d", error);
+
+	return error;
+}
+
+static int yaffs_removexattr(struct dentry *dentry, const char *name)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_removexattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		int result;
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		result = yaffs_remove_xattrib(obj, name);
+		if (result == YAFFS_OK)
+			error = 0;
+		else if (result < 0)
+			error = result;
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_removexattr done returning %d", error);
+
+	return error;
+}
+
+static ssize_t yaffs_listxattr(struct dentry * dentry, char *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_listxattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		error = yaffs_list_xattrib(obj, buff, size);
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_listxattr done returning %d", error);
+
+	return error;
+}
+
+
+static const struct inode_operations yaffs_file_inode_operations = {
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+
+static int yaffs_readlink(struct dentry *dentry, char __user * buffer,
+			  int buflen)
+{
+	unsigned char *alias;
+	int ret;
+
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+
+	yaffs_gross_unlock(dev);
+
+	if (!alias)
+		return -ENOMEM;
+
+	ret = vfs_readlink(dentry, buffer, buflen, alias);
+	kfree(alias);
+	return ret;
+}
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	void *ret;
+#else
+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	int ret
+#endif
+	unsigned char *alias;
+	int ret_int = 0;
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+	yaffs_gross_unlock(dev);
+
+	if (!alias) {
+		ret_int = -ENOMEM;
+		goto out;
+	}
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+	nd_set_link(nd, alias);
+	ret = alias;
+out:
+	if (ret_int)
+		ret = ERR_PTR(ret_int);
+	return ret;
+#else
+	ret = vfs_follow_link(nd, alias);
+	kfree(alias);
+out:
+	if (ret_int)
+		ret = ret_int;
+	return ret;
+#endif
+}
+
+
+#ifdef YAFFS_HAS_PUT_INODE
+
+/* For now put inode is just for debugging
+ * Put inode is called when the inode **structure** is put.
+ */
+static void yaffs_put_inode(struct inode *inode)
+{
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_put_inode: ino %d, count %d"),
+		(int)inode->i_ino, atomic_read(&inode->i_count);
+
+}
+#endif
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+void yaffs_put_link(struct dentry *dentry, struct nameidata *nd, void *alias)
+{
+	kfree(alias);
+}
+#endif
+
+static const struct inode_operations yaffs_symlink_inode_operations = {
+	.readlink = yaffs_readlink,
+	.follow_link = yaffs_follow_link,
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+	.put_link = yaffs_put_link,
+#endif
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+#ifdef YAFFS_USE_OWN_IGET
+
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode *inode;
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_iget for %lu", ino);
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	yaffs_gross_lock(dev);
+
+	obj = yaffs_find_by_number(dev, inode->i_ino);
+
+	yaffs_fill_inode_from_obj(inode, obj);
+
+	yaffs_gross_unlock(dev);
+
+	unlock_new_inode(inode);
+	return inode;
+}
+
+#else
+
+static void yaffs_read_inode(struct inode *inode)
+{
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev = yaffs_super_to_dev(inode->i_sb);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_inode for %d", (int)inode->i_ino);
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_lock(dev);
+
+	obj = yaffs_find_by_number(dev, inode->i_ino);
+
+	yaffs_fill_inode_from_obj(inode, obj);
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_unlock(dev);
+}
+
+#endif
+
+
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+			      struct yaffs_obj *obj)
+{
+	struct inode *inode;
+
+	if (!sb) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_get_inode for NULL super_block!!");
+		return NULL;
+
+	}
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_get_inode for NULL object!!");
+		return NULL;
+
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_get_inode for object %d", obj->obj_id);
+
+	inode = Y_IGET(sb, obj->obj_id);
+	if (IS_ERR(inode))
+		return NULL;
+
+	/* NB Side effect: iget calls back to yaffs_read_inode(). */
+	/* iget also increments the inode's i_count */
+	/* NB You can't be holding gross_lock or deadlock will happen! */
+
+	return inode;
+}
+
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+#define YCRED(x) x
+#else
+#define YCRED(x) (x->cred)
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,
+		       dev_t rdev)
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       dev_t rdev)
+#else
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       int rdev)
+#endif
+{
+	struct inode *inode;
+
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_dev *dev;
+
+	struct yaffs_obj *parent = yaffs_inode_to_obj(dir);
+
+	int error = -ENOSPC;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
+
+	if ((dir->i_mode & S_ISGID) && S_ISDIR(mode))
+		mode |= S_ISGID;
+
+	if (parent) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: parent object %d type %d",
+			parent->obj_id, parent->variant_type);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: could not get parent object");
+		return -EPERM;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_mknod: making oject for %s, mode %x dev %x",
+		dentry->d_name.name, mode, rdev);
+
+	dev = parent->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	switch (mode & S_IFMT) {
+	default:
+		/* Special (socket, fifo, device...) */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making special");
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+		obj =
+		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+					 gid, old_encode_dev(rdev));
+#else
+		obj =
+		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+					 gid, rdev);
+#endif
+		break;
+	case S_IFREG:		/* file          */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making file");
+		obj = yaffs_create_file(parent, dentry->d_name.name, mode, uid,
+					gid);
+		break;
+	case S_IFDIR:		/* directory */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making directory");
+		obj = yaffs_create_dir(parent, dentry->d_name.name, mode,
+				       uid, gid);
+		break;
+	case S_IFLNK:		/* symlink */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making symlink");
+		obj = NULL;	/* Do we ever get here? */
+		break;
+	}
+
+	/* Can not call yaffs_get_inode() with gross lock held */
+	yaffs_gross_unlock(dev);
+
+	if (obj) {
+		inode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod created object %d count = %d",
+			obj->obj_id, atomic_read(&inode->i_count));
+		error = 0;
+		yaffs_fill_inode_from_obj(dir, parent);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod failed making object");
+		error = -ENOMEM;
+	}
 
 	return error;
 }
 
-static int yaffs_removexattr(struct dentry *dentry, const char *name)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
+#else
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+#endif
+{
+	int ret_val;
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_mkdir");
+	ret_val = yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);
+	return ret_val;
+}
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
+			bool dummy)
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
+			struct nameidata *n)
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n)
+#else
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode)
+#endif
+{
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_create");
+	return yaffs_mknod(dir, dentry, mode | S_IFREG, 0);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				   unsigned int dummy)
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				   struct nameidata *n)
+#else
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry)
+#endif
+{
+	struct yaffs_obj *obj;
+	struct inode *inode = NULL;	/* NCB 2.5/2.6 needs NULL here */
+
+	struct yaffs_dev *dev = yaffs_inode_to_obj(dir)->my_dev;
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_lock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup for %d:%s",
+		yaffs_inode_to_obj(dir)->obj_id, dentry->d_name.name);
+
+	obj = yaffs_find_by_name(yaffs_inode_to_obj(dir), dentry->d_name.name);
+
+	obj = yaffs_get_equivalent_obj(obj);	/* in case it was a hardlink */
+
+	/* Can't hold gross lock when calling yaffs_get_inode() */
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_unlock(dev);
+
+	if (obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_lookup found %d", obj->obj_id);
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup not found");
+
+	}
+
+/* added NCB for 2.5/6 compatability - forces add even if inode is
+ * NULL which creates dentry hash */
+	d_add(dentry, inode);
+
+	return NULL;
+}
+
+/*
+ * Create a link...
+ */
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+		      struct dentry *dentry)
+{
+	struct inode *inode = old_dentry->d_inode;
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_obj *link = NULL;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_link");
+
+	obj = yaffs_inode_to_obj(inode);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	if (!S_ISDIR(inode->i_mode))	/* Don't link directories */
+		link =
+		    yaffs_link_obj(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   obj);
+
+	if (link) {
+		set_nlink(old_dentry->d_inode, yaffs_get_obj_link_count(obj));
+		d_instantiate(dentry, old_dentry->d_inode);
+		atomic_inc(&old_dentry->d_inode->i_count);
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_link link count %d i_count %d",
+			old_dentry->d_inode->i_nlink,
+			atomic_read(&old_dentry->d_inode->i_count));
+	}
+
+	yaffs_gross_unlock(dev);
+
+	if (link) {
+		update_dir_time(dir);
+		return 0;
+	}
+
+	return -EPERM;
+}
+
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+			 const char *symname)
 {
-	struct inode *inode = dentry->d_inode;
-	int error;
+	struct yaffs_obj *obj;
 	struct yaffs_dev *dev;
-	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
 
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_removexattr of object %d", obj->obj_id);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_symlink");
 
-	dev = obj->my_dev;
+	if (strnlen(dentry->d_name.name, YAFFS_MAX_NAME_LENGTH + 1) >
+				YAFFS_MAX_NAME_LENGTH)
+		return -ENAMETOOLONG;
+
+	if (strnlen(symname, YAFFS_MAX_ALIAS_LENGTH + 1) >
+				YAFFS_MAX_ALIAS_LENGTH)
+		return -ENAMETOOLONG;
+
+	dev = yaffs_inode_to_obj(dir)->my_dev;
 	yaffs_gross_lock(dev);
-	error = yaffs_remove_xattrib(obj, name);
+	obj = yaffs_create_symlink(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   S_IFLNK | S_IRWXUGO, uid, gid, symname);
 	yaffs_gross_unlock(dev);
 
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_removexattr done returning %d", error);
+	if (obj) {
+		struct inode *inode;
 
-	return error;
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		yaffs_trace(YAFFS_TRACE_OS, "symlink created OK");
+		return 0;
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "symlink not created");
+	}
+
+	return -ENOMEM;
 }
 
-static ssize_t yaffs_listxattr(struct dentry *dentry, char *buff, size_t size)
+/*
+ * The VFS layer already does all the dentry stuff for rename.
+ *
+ * NB: POSIX says you can rename an object over an old object of the same name
+ */
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry)
 {
-	struct inode *inode = dentry->d_inode;
-	int error;
 	struct yaffs_dev *dev;
-	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+	int ret_val = YAFFS_FAIL;
+	struct yaffs_obj *target;
 
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_listxattr of object %d", obj->obj_id);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_rename");
+	dev = yaffs_inode_to_obj(old_dir)->my_dev;
 
-	dev = obj->my_dev;
 	yaffs_gross_lock(dev);
-	error = yaffs_list_xattrib(obj, buff, size);
+
+	/* Check if the target is an existing directory that is not empty. */
+	target = yaffs_find_by_name(yaffs_inode_to_obj(new_dir),
+				    new_dentry->d_name.name);
+
+	if (target && target->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY &&
+	    !list_empty(&target->variant.dir_variant.children)) {
+
+		yaffs_trace(YAFFS_TRACE_OS, "target is non-empty dir");
+
+		ret_val = YAFFS_FAIL;
+	} else {
+		/* Now does unlinking internally using shadowing mechanism */
+		yaffs_trace(YAFFS_TRACE_OS, "calling yaffs_rename_obj");
+
+		ret_val = yaffs_rename_obj(yaffs_inode_to_obj(old_dir),
+					   old_dentry->d_name.name,
+					   yaffs_inode_to_obj(new_dir),
+					   new_dentry->d_name.name);
+	}
 	yaffs_gross_unlock(dev);
 
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_listxattr done returning %d", error);
+	if (ret_val == YAFFS_OK) {
+		if (target)
+			inode_dec_link_count(new_dentry->d_inode);
 
-	return error;
+		update_dir_time(old_dir);
+		if (old_dir != new_dir)
+			update_dir_time(new_dir);
+		return 0;
+	} else {
+		return -ENOTEMPTY;
+	}
+}
+
+
+
+
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int ret_val;
+
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_unlink %d:%s",
+		(int)(dir->i_ino), dentry->d_name.name);
+	obj = yaffs_inode_to_obj(dir);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	ret_val = yaffs_unlinker(obj, dentry->d_name.name);
+
+	if (ret_val == YAFFS_OK) {
+		inode_dec_link_count(dentry->d_inode);
+		dir->i_version++;
+		yaffs_gross_unlock(dev);
+		update_dir_time(dir);
+		return 0;
+	}
+	yaffs_gross_unlock(dev);
+	return -ENOTEMPTY;
 }
 
+
+
 static const struct inode_operations yaffs_dir_inode_operations = {
 	.create = yaffs_create,
 	.lookup = yaffs_lookup,
@@ -649,6 +1558,7 @@ static const struct inode_operations yaffs_dir_inode_operations = {
 	.listxattr = yaffs_listxattr,
 	.removexattr = yaffs_removexattr,
 };
+
 /*-----------------------------------------------------------------*/
 /* Directory search context allows us to unlock access to yaffs during
  * filldir without causing problems with the directory being modified.
@@ -686,21 +1596,18 @@ static struct yaffs_search_context *yaffs_new_search(struct yaffs_obj *dir)
 	struct yaffs_dev *dev = dir->my_dev;
 	struct yaffs_search_context *sc =
 	    kmalloc(sizeof(struct yaffs_search_context), GFP_NOFS);
-
-	if (!sc)
-		return NULL;
-
-	sc->dir_obj = dir;
-	sc->dev = dev;
-	if (list_empty(&sc->dir_obj->variant.dir_variant.children))
-		sc->next_return = NULL;
-	else
-		sc->next_return =
-		    list_entry(dir->variant.dir_variant.children.next,
-			       struct yaffs_obj, siblings);
-	INIT_LIST_HEAD(&sc->others);
-	list_add(&sc->others, &(yaffs_dev_to_lc(dev)->search_contexts));
-
+	if (sc) {
+		sc->dir_obj = dir;
+		sc->dev = dev;
+		if (list_empty(&sc->dir_obj->variant.dir_variant.children))
+			sc->next_return = NULL;
+		else
+			sc->next_return =
+			    list_entry(dir->variant.dir_variant.children.next,
+				       struct yaffs_obj, siblings);
+		INIT_LIST_HEAD(&sc->others);
+		list_add(&sc->others, &(yaffs_dev_to_lc(dev)->search_contexts));
+	}
 	return sc;
 }
 
@@ -764,6 +1671,9 @@ static void yaffs_remove_obj_callback(struct yaffs_obj *obj)
 
 }
 
+
+/*-----------------------------------------------------------------*/
+
 static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
 {
 	struct yaffs_obj *obj;
@@ -773,6 +1683,7 @@ static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
 	unsigned long offset, curoffs;
 	struct yaffs_obj *l;
 	int ret_val = 0;
+
 	char name[YAFFS_MAX_NAME_LENGTH + 1];
 
 	obj = yaffs_dentry_to_obj(f->f_dentry);
@@ -877,555 +1788,560 @@ static const struct file_operations yaffs_dir_operations = {
 	.llseek = generic_file_llseek,
 };
 
-
-
-static int yaffs_file_flush(struct file *file, fl_owner_t id)
-{
-	struct yaffs_obj *obj = yaffs_dentry_to_obj(file->f_dentry);
-	struct yaffs_dev *dev = obj->my_dev;
-
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_file_flush object %d (%s)",
-		obj->obj_id, obj->dirty ? "dirty" : "clean");
-
-	yaffs_gross_lock(dev);
-
-	yaffs_flush_file(obj, 1, 0);
-
-	yaffs_gross_unlock(dev);
-
-	return 0;
-}
-
-static const struct file_operations yaffs_file_operations = {
-	.read = do_sync_read,
-	.write = do_sync_write,
-	.aio_read = generic_file_aio_read,
-	.aio_write = generic_file_aio_write,
-	.mmap = generic_file_mmap,
-	.flush = yaffs_file_flush,
-	.fsync = yaffs_sync_object,
-	.splice_read = generic_file_splice_read,
-	.splice_write = generic_file_splice_write,
-	.llseek = generic_file_llseek,
-};
-
-
-/* ExportFS support */
-static struct inode *yaffs2_nfs_get_inode(struct super_block *sb, uint64_t ino,
-					  uint32_t generation)
-{
-	return yaffs_iget(sb, ino);
-}
-
-static struct dentry *yaffs2_fh_to_dentry(struct super_block *sb,
-					  struct fid *fid, int fh_len,
-					  int fh_type)
-{
-	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
-				    yaffs2_nfs_get_inode);
-}
-
-static struct dentry *yaffs2_fh_to_parent(struct super_block *sb,
-					  struct fid *fid, int fh_len,
-					  int fh_type)
-{
-	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
-				    yaffs2_nfs_get_inode);
-}
-
-struct dentry *yaffs2_get_parent(struct dentry *dentry)
-{
-
-	struct super_block *sb = dentry->d_inode->i_sb;
-	struct dentry *parent = ERR_PTR(-ENOENT);
-	struct inode *inode;
-	unsigned long parent_ino;
-	struct yaffs_obj *d_obj;
-	struct yaffs_obj *parent_obj;
-
-	d_obj = yaffs_inode_to_obj(dentry->d_inode);
-
-	if (d_obj) {
-		parent_obj = d_obj->parent;
-		if (parent_obj) {
-			parent_ino = yaffs_get_obj_inode(parent_obj);
-			inode = yaffs_iget(sb, parent_ino);
-
-			if (IS_ERR(inode)) {
-				parent = ERR_CAST(inode);
-			} else {
-				parent = d_obtain_alias(inode);
-				if (!IS_ERR(parent)) {
-					parent = ERR_PTR(-ENOMEM);
-					iput(inode);
-				}
-			}
-		}
-	}
-	return parent;
-}
-
-/* Just declare a zero structure as a NULL value implies
- * using the default functions of exportfs.
- */
-
-static struct export_operations yaffs_export_ops = {
-	.fh_to_dentry = yaffs2_fh_to_dentry,
-	.fh_to_parent = yaffs2_fh_to_parent,
-	.get_parent = yaffs2_get_parent,
-};
-
-
-/*-----------------------------------------------------------------*/
-
-static int yaffs_readlink(struct dentry *dentry, char __user * buffer,
-			  int buflen)
+static void yaffs_fill_inode_from_obj(struct inode *inode,
+				      struct yaffs_obj *obj)
 {
-	unsigned char *alias;
-	int ret;
-	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+	if (inode && obj) {
 
-	yaffs_gross_lock(dev);
+		/* Check mode against the variant type and attempt to repair if broken. */
+		u32 mode = obj->yst_mode;
+		switch (obj->variant_type) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			if (!S_ISREG(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFREG;
+			}
 
-	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			if (!S_ISLNK(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFLNK;
+			}
 
-	yaffs_gross_unlock(dev);
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			if (!S_ISDIR(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFDIR;
+			}
 
-	if (!alias)
-		return -ENOMEM;
+			break;
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+		default:
+			/* TODO? */
+			break;
+		}
 
-	ret = vfs_readlink(dentry, buffer, buflen, alias);
-	kfree(alias);
-	return ret;
-}
+		inode->i_flags |= S_NOATIME;
+
+		inode->i_ino = obj->obj_id;
+		inode->i_mode = obj->yst_mode;
+		inode->i_uid = obj->yst_uid;
+		inode->i_gid = obj->yst_gid;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+		inode->i_blksize = inode->i_sb->s_blocksize;
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+		inode->i_rdev = old_decode_dev(obj->yst_rdev);
+		inode->i_atime.tv_sec = (time_t) (obj->yst_atime);
+		inode->i_atime.tv_nsec = 0;
+		inode->i_mtime.tv_sec = (time_t) obj->yst_mtime;
+		inode->i_mtime.tv_nsec = 0;
+		inode->i_ctime.tv_sec = (time_t) obj->yst_ctime;
+		inode->i_ctime.tv_nsec = 0;
+#else
+		inode->i_rdev = obj->yst_rdev;
+		inode->i_atime = obj->yst_atime;
+		inode->i_mtime = obj->yst_mtime;
+		inode->i_ctime = obj->yst_ctime;
+#endif
+		inode->i_size = yaffs_get_obj_length(obj);
+		inode->i_blocks = (inode->i_size + 511) >> 9;
+
+		set_nlink(inode, yaffs_get_obj_link_count(obj));
 
-static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
-{
-	unsigned char *alias;
-	void *ret;
-	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_fill_inode mode %x uid %d gid %d size %lld count %d",
+			inode->i_mode, inode->i_uid, inode->i_gid,
+			inode->i_size, atomic_read(&inode->i_count));
+
+		switch (obj->yst_mode & S_IFMT) {
+		default:	/* fifo, device or socket */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+			init_special_inode(inode, obj->yst_mode,
+					   old_decode_dev(obj->yst_rdev));
+#else
+			init_special_inode(inode, obj->yst_mode,
+					   (dev_t) (obj->yst_rdev));
+#endif
+			break;
+		case S_IFREG:	/* file */
+			inode->i_op = &yaffs_file_inode_operations;
+			inode->i_fop = &yaffs_file_operations;
+			inode->i_mapping->a_ops =
+			    &yaffs_file_address_operations;
+			break;
+		case S_IFDIR:	/* directory */
+			inode->i_op = &yaffs_dir_inode_operations;
+			inode->i_fop = &yaffs_dir_operations;
+			break;
+		case S_IFLNK:	/* symlink */
+			inode->i_op = &yaffs_symlink_inode_operations;
+			break;
+		}
 
-	yaffs_gross_lock(dev);
+		yaffs_inode_to_obj_lv(inode) = obj;
 
-	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
-	yaffs_gross_unlock(dev);
+		obj->my_inode = inode;
 
-	if (!alias) {
-		ret = ERR_PTR(-ENOMEM);
-		goto out;
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_fill_inode invalid parameters");
 	}
 
-	nd_set_link(nd, alias);
-	ret = (void *)alias;
-out:
-	return ret;
-}
-
-void yaffs_put_link(struct dentry *dentry, struct nameidata *nd, void *alias)
-{
-	kfree(alias);
 }
 
 
-static void yaffs_unstitch_obj(struct inode *inode, struct yaffs_obj *obj)
-{
-	/* Clear the association between the inode and
-	 * the struct yaffs_obj.
-	 */
-	obj->my_inode = NULL;
-	yaffs_inode_to_obj_lv(inode) = NULL;
-
-	/* If the object freeing was deferred, then the real
-	 * free happens now.
-	 * This should fix the inode inconsistency problem.
-	 */
-	yaffs_handle_defered_free(obj);
-}
 
-/* yaffs_evict_inode combines into one operation what was previously done in
- * yaffs_clear_inode() and yaffs_delete_inode()
+/*
+ * yaffs background thread functions .
+ * yaffs_bg_thread_fn() the thread function
+ * yaffs_bg_start() launches the background thread.
+ * yaffs_bg_stop() cleans up the background thread.
  *
+ * NB:
+ * The thread should only run after the yaffs is initialised
+ * The thread should be stopped before yaffs is unmounted.
+ * The thread should not do any writing while the fs is in read only.
  */
-static void yaffs_evict_inode(struct inode *inode)
-{
-	struct yaffs_obj *obj;
-	struct yaffs_dev *dev;
-	int deleteme = 0;
-
-	obj = yaffs_inode_to_obj(inode);
-
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_evict_inode: ino %d, count %d %s",
-		(int)inode->i_ino,
-		atomic_read(&inode->i_count),
-		obj ? "object exists" : "null object");
 
-	if (!inode->i_nlink && !is_bad_inode(inode))
-		deleteme = 1;
-	truncate_inode_pages(&inode->i_data, 0);
-	end_writeback(inode);
+static unsigned yaffs_bg_gc_urgency(struct yaffs_dev *dev)
+{
+	unsigned erased_chunks =
+	    dev->n_erased_blocks * dev->param.chunks_per_block;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+	unsigned scattered = 0;	/* Free chunks not in an erased block */
 
-	if (deleteme && obj) {
-		dev = obj->my_dev;
-		yaffs_gross_lock(dev);
-		yaffs_del_obj(obj);
-		yaffs_gross_unlock(dev);
-	}
-	if (obj) {
-		dev = obj->my_dev;
-		yaffs_gross_lock(dev);
-		yaffs_unstitch_obj(inode, obj);
-		yaffs_gross_unlock(dev);
-	}
+	if (erased_chunks < dev->n_free_chunks)
+		scattered = (dev->n_free_chunks - erased_chunks);
 
+	if (!context->bg_running)
+		return 0;
+	else if (scattered < (dev->param.chunks_per_block * 2))
+		return 0;
+	else if (erased_chunks > dev->n_free_chunks / 2)
+		return 0;
+	else if (erased_chunks > dev->n_free_chunks / 4)
+		return 1;
+	else
+		return 2;
 }
 
-static void yaffs_touch_super(struct yaffs_dev *dev)
-{
-	struct super_block *sb = yaffs_dev_to_lc(dev)->super;
+#ifdef YAFFS_COMPILE_BACKGROUND
 
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_touch_super() sb = %p", sb);
-	if (sb)
-		sb->s_dirt = 1;
+void yaffs_background_waker(unsigned long data)
+{
+	wake_up_process((struct task_struct *)data);
 }
 
-static int yaffs_readpage_nolock(struct file *f, struct page *pg)
+static int yaffs_bg_thread_fn(void *data)
 {
-	/* Lifted from jffs2 */
-
-	struct yaffs_obj *obj;
-	unsigned char *pg_buf;
-	int ret;
-	struct yaffs_dev *dev;
-	loff_t pos = ((loff_t) pg->index) << PAGE_CACHE_SHIFT;
-
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_readpage_nolock at %lld, size %08x",
-		(long long)pos,
-		(unsigned)PAGE_CACHE_SIZE);
+	struct yaffs_dev *dev = (struct yaffs_dev *)data;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+	unsigned long now = jiffies;
+	unsigned long next_dir_update = now;
+	unsigned long next_gc = now;
+	unsigned long expires;
+	unsigned int urgency;
 
+	int gc_result;
+	struct timer_list timer;
 
-	obj = yaffs_dentry_to_obj(f->f_dentry);
+	yaffs_trace(YAFFS_TRACE_BACKGROUND,
+		"yaffs_background starting for dev %p", (void *)dev);
 
-	dev = obj->my_dev;
+#ifdef YAFFS_COMPILE_FREEZER
+	set_freezable();
+#endif
+	while (context->bg_running) {
+		yaffs_trace(YAFFS_TRACE_BACKGROUND, "yaffs_background");
 
-	BUG_ON(!PageLocked(pg));
+		if (kthread_should_stop())
+			break;
 
-	pg_buf = kmap(pg);
-	/* FIXME: Can kmap fail? */
+#ifdef YAFFS_COMPILE_FREEZER
+		if (try_to_freeze())
+			continue;
+#endif
+		yaffs_gross_lock(dev);
 
-	yaffs_gross_lock(dev);
+		now = jiffies;
 
-	ret = yaffs_file_rd(obj, pg_buf, pos, PAGE_CACHE_SIZE);
+		if (time_after(now, next_dir_update) && yaffs_bg_enable) {
+			yaffs_update_dirty_dirs(dev);
+			next_dir_update = now + HZ;
+		}
 
-	yaffs_gross_unlock(dev);
+		if (time_after(now, next_gc) && yaffs_bg_enable) {
+			if (!dev->is_checkpointed) {
+				urgency = yaffs_bg_gc_urgency(dev);
+				gc_result = yaffs_bg_gc(dev, urgency);
+				if (urgency > 1)
+					next_gc = now + HZ / 20 + 1;
+				else if (urgency > 0)
+					next_gc = now + HZ / 10 + 1;
+				else
+					next_gc = now + HZ * 2;
+			} else	{
+			        /*
+				 * gc not running so set to next_dir_update
+				 * to cut down on wake ups
+				 */
+				next_gc = next_dir_update;
+                        }
+		}
+		yaffs_gross_unlock(dev);
+#if 1
+		expires = next_dir_update;
+		if (time_before(next_gc, expires))
+			expires = next_gc;
+		if (time_before(expires, now))
+			expires = now + HZ;
 
-	if (ret >= 0)
-		ret = 0;
+		Y_INIT_TIMER(&timer);
+		timer.expires = expires + 1;
+		timer.data = (unsigned long)current;
+		timer.function = yaffs_background_waker;
 
-	if (ret) {
-		ClearPageUptodate(pg);
-		SetPageError(pg);
-	} else {
-		SetPageUptodate(pg);
-		ClearPageError(pg);
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_timer(&timer);
+		schedule();
+		del_timer_sync(&timer);
+#else
+		msleep(10);
+#endif
 	}
 
-	flush_dcache_page(pg);
-	kunmap(pg);
-
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage_nolock done");
-	return ret;
+	return 0;
 }
 
-static int yaffs_readpage_unlock(struct file *f, struct page *pg)
+static int yaffs_bg_start(struct yaffs_dev *dev)
 {
-	int ret = yaffs_readpage_nolock(f, pg);
+	int retval = 0;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
 
-	unlock_page(pg);
-	return ret;
-}
+	if (dev->read_only)
+		return -1;
 
-static int yaffs_readpage(struct file *f, struct page *pg)
-{
-	int ret;
+	context->bg_running = 1;
 
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage");
-	ret = yaffs_readpage_unlock(f, pg);
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage done");
-	return ret;
+	context->bg_thread = kthread_run(yaffs_bg_thread_fn,
+					 (void *)dev, "yaffs-bg-%d",
+					 context->mount_id);
+
+	if (IS_ERR(context->bg_thread)) {
+		retval = PTR_ERR(context->bg_thread);
+		context->bg_thread = NULL;
+		context->bg_running = 0;
+	}
+	return retval;
 }
 
-/* writepage inspired by/stolen from smbfs */
+static void yaffs_bg_stop(struct yaffs_dev *dev)
+{
+	struct yaffs_linux_context *ctxt = yaffs_dev_to_lc(dev);
+
+	ctxt->bg_running = 0;
 
-static int yaffs_writepage(struct page *page, struct writeback_control *wbc)
+	if (ctxt->bg_thread) {
+		kthread_stop(ctxt->bg_thread);
+		ctxt->bg_thread = NULL;
+	}
+}
+#else
+static int yaffs_bg_thread_fn(void *data)
 {
-	struct yaffs_dev *dev;
-	struct address_space *mapping = page->mapping;
-	struct inode *inode;
-	unsigned long end_index;
-	char *buffer;
-	struct yaffs_obj *obj;
-	int n_written = 0;
-	unsigned n_bytes;
-	loff_t i_size;
+	return 0;
+}
 
-	if (!mapping)
-		BUG();
-	inode = mapping->host;
-	if (!inode)
-		BUG();
-	i_size = i_size_read(inode);
+static int yaffs_bg_start(struct yaffs_dev *dev)
+{
+	return 0;
+}
 
-	end_index = i_size >> PAGE_CACHE_SHIFT;
+static void yaffs_bg_stop(struct yaffs_dev *dev)
+{
+}
+#endif
 
-	if (page->index < end_index)
-		n_bytes = PAGE_CACHE_SIZE;
-	else {
-		n_bytes = i_size & (PAGE_CACHE_SIZE - 1);
 
-		if (page->index > end_index || !n_bytes) {
-			yaffs_trace(YAFFS_TRACE_OS,
-				"yaffs_writepage at %08x, inode size = %08x!!!",
-				(unsigned)(page->index << PAGE_CACHE_SHIFT),
-				(unsigned)inode->i_size);
-			yaffs_trace(YAFFS_TRACE_OS,
-			  "                -> don't care!!");
+static void yaffs_flush_inodes(struct super_block *sb)
+{
+	struct inode *iptr;
+	struct yaffs_obj *obj;
 
-			zero_user_segment(page, 0, PAGE_CACHE_SIZE);
-			set_page_writeback(page);
-			unlock_page(page);
-			end_page_writeback(page);
-			return 0;
+	list_for_each_entry(iptr, &sb->s_inodes, i_sb_list) {
+		obj = yaffs_inode_to_obj(iptr);
+		if (obj) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"flushing obj %d",
+				obj->obj_id);
+			yaffs_flush_file(obj, 1, 0);
 		}
 	}
+}
 
-	if (n_bytes != PAGE_CACHE_SIZE)
-		zero_user_segment(page, n_bytes, PAGE_CACHE_SIZE);
+static void yaffs_flush_super(struct super_block *sb, int do_checkpoint)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	if (!dev)
+		return;
 
-	get_page(page);
+	yaffs_flush_inodes(sb);
+	yaffs_update_dirty_dirs(dev);
+	yaffs_flush_whole_cache(dev);
+	if (do_checkpoint)
+		yaffs_checkpoint_save(dev);
+}
 
-	buffer = kmap(page);
+static LIST_HEAD(yaffs_context_list);
+struct mutex yaffs_context_lock;
 
-	obj = yaffs_inode_to_obj(inode);
-	dev = obj->my_dev;
-	yaffs_gross_lock(dev);
+static void yaffs_put_super(struct super_block *sb)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
 
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_writepage at %08x, size %08x",
-		(unsigned)(page->index << PAGE_CACHE_SHIFT), n_bytes);
-	yaffs_trace(YAFFS_TRACE_OS,
-		"writepag0: obj = %05x, ino = %05x",
-		(int)obj->variant.file_variant.file_size, (int)inode->i_size);
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_ALWAYS,
+			"yaffs_put_super");
 
-	n_written = yaffs_wr_file(obj, buffer,
-				  ((loff_t)page->index) << PAGE_CACHE_SHIFT,
-				  n_bytes, 0);
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		"Shutting down yaffs background thread");
+	yaffs_bg_stop(dev);
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		"yaffs background thread shut down");
 
-	yaffs_touch_super(dev);
+	yaffs_gross_lock(dev);
 
-	yaffs_trace(YAFFS_TRACE_OS,
-		"writepag1: obj = %05x, ino = %05x",
-		(int)obj->variant.file_variant.file_size, (int)inode->i_size);
+	yaffs_flush_super(sb, 1);
+
+	yaffs_deinitialise(dev);
 
 	yaffs_gross_unlock(dev);
 
-	kunmap(page);
-	set_page_writeback(page);
-	unlock_page(page);
-	end_page_writeback(page);
-	put_page(page);
+	mutex_lock(&yaffs_context_lock);
+	list_del_init(&(yaffs_dev_to_lc(dev)->context_list));
+	mutex_unlock(&yaffs_context_lock);
 
-	return (n_written == n_bytes) ? 0 : -ENOSPC;
-}
+	if (yaffs_dev_to_lc(dev)->spare_buffer) {
+		kfree(yaffs_dev_to_lc(dev)->spare_buffer);
+		yaffs_dev_to_lc(dev)->spare_buffer = NULL;
+	}
 
-/* Space holding and freeing is done to ensure we have space available for
- * write_begin/end.
- * For now we just assume few parallel writes and check against a small
- * number.
- * Todo: need to do this with a counter to handle parallel reads better
- */
+	kfree(dev);
 
-static ssize_t yaffs_hold_space(struct file *f)
-{
-	struct yaffs_obj *obj;
-	struct yaffs_dev *dev;
-	int n_free_chunks;
+	yaffs_put_mtd_device(mtd);
 
-	obj = yaffs_dentry_to_obj(f->f_dentry);
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_ALWAYS,
+			"yaffs_put_super done");
+}
 
-	dev = obj->my_dev;
 
-	yaffs_gross_lock(dev);
+static unsigned yaffs_gc_control_callback(struct yaffs_dev *dev)
+{
+	return yaffs_gc_control;
+}
 
-	n_free_chunks = yaffs_get_n_free_chunks(dev);
 
-	yaffs_gross_unlock(dev);
+#ifdef YAFFS_COMPILE_EXPORTFS
 
-	return (n_free_chunks > 20) ? 1 : 0;
+static struct inode *yaffs2_nfs_get_inode(struct super_block *sb, uint64_t ino,
+					  uint32_t generation)
+{
+	return Y_IGET(sb, ino);
 }
 
-static void yaffs_release_space(struct file *f)
+static struct dentry *yaffs2_fh_to_dentry(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
 {
-	struct yaffs_obj *obj;
-	struct yaffs_dev *dev;
-
-	obj = yaffs_dentry_to_obj(f->f_dentry);
-
-	dev = obj->my_dev;
-
-	yaffs_gross_lock(dev);
+	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
+}
 
-	yaffs_gross_unlock(dev);
+static struct dentry *yaffs2_fh_to_parent(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
+{
+	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
 }
 
-static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
-			     loff_t pos, unsigned len, unsigned flags,
-			     struct page **pagep, void **fsdata)
+struct dentry *yaffs2_get_parent(struct dentry *dentry)
 {
-	struct page *pg = NULL;
-	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
-	int ret = 0;
-	int space_held = 0;
 
-	/* Get a page */
-	pg = grab_cache_page_write_begin(mapping, index, flags);
+	struct super_block *sb = dentry->d_inode->i_sb;
+	struct dentry *parent = ERR_PTR(-ENOENT);
+	struct inode *inode;
+	unsigned long parent_ino;
+	struct yaffs_obj *d_obj;
+	struct yaffs_obj *parent_obj;
 
-	*pagep = pg;
-	if (!pg) {
-		ret = -ENOMEM;
-		goto out;
-	}
-	yaffs_trace(YAFFS_TRACE_OS,
-		"start yaffs_write_begin index %d(%x) uptodate %d",
-		(int)index, (int)index, PageUptodate(pg) ? 1 : 0);
+	d_obj = yaffs_inode_to_obj(dentry->d_inode);
 
-	/* Get fs space */
-	space_held = yaffs_hold_space(filp);
+	if (d_obj) {
+		parent_obj = d_obj->parent;
+		if (parent_obj) {
+			parent_ino = yaffs_get_obj_inode(parent_obj);
+			inode = Y_IGET(sb, parent_ino);
 
-	if (!space_held) {
-		ret = -ENOSPC;
-		goto out;
+			if (IS_ERR(inode)) {
+				parent = ERR_CAST(inode);
+			} else {
+				parent = d_obtain_alias(inode);
+				if (!IS_ERR(parent)) {
+					parent = ERR_PTR(-ENOMEM);
+					iput(inode);
+				}
+			}
+		}
 	}
 
-	/* Update page if required */
+	return parent;
+}
 
-	if (!PageUptodate(pg))
-		ret = yaffs_readpage_nolock(filp, pg);
+/* Just declare a zero structure as a NULL value implies
+ * using the default functions of exportfs.
+ */
 
-	if (ret)
-		goto out;
+static struct export_operations yaffs_export_ops = {
+	.fh_to_dentry = yaffs2_fh_to_dentry,
+	.fh_to_parent = yaffs2_fh_to_parent,
+	.get_parent = yaffs2_get_parent,
+};
 
-	/* Happy path return */
-	yaffs_trace(YAFFS_TRACE_OS, "end yaffs_write_begin - ok");
+#endif
 
-	return 0;
+static void yaffs_unstitch_obj(struct inode *inode, struct yaffs_obj *obj)
+{
+	/* Clear the association between the inode and
+	 * the struct yaffs_obj.
+	 */
+	obj->my_inode = NULL;
+	yaffs_inode_to_obj_lv(inode) = NULL;
 
-out:
-	yaffs_trace(YAFFS_TRACE_OS,
-		"end yaffs_write_begin fail returning %d", ret);
-	if (space_held)
-		yaffs_release_space(filp);
-	if (pg) {
-		unlock_page(pg);
-		page_cache_release(pg);
-	}
-	return ret;
+	/* If the object freeing was deferred, then the real
+	 * free happens now.
+	 * This should fix the inode inconsistency problem.
+	 */
+	yaffs_handle_defered_free(obj);
 }
 
-static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
-				loff_t *pos)
+#ifdef YAFFS_HAS_EVICT_INODE
+/* yaffs_evict_inode combines into one operation what was previously done in
+ * yaffs_clear_inode() and yaffs_delete_inode()
+ *
+ */
+static void yaffs_evict_inode(struct inode *inode)
 {
 	struct yaffs_obj *obj;
-	int n_written, ipos;
-	struct inode *inode;
 	struct yaffs_dev *dev;
+	int deleteme = 0;
 
-	obj = yaffs_dentry_to_obj(f->f_dentry);
-
-	if (!obj) {
-		/* This should not happen */
-		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_file_write: hey obj is null!");
-		return -EINVAL;
-	}
-
-	dev = obj->my_dev;
+	obj = yaffs_inode_to_obj(inode);
 
-	yaffs_gross_lock(dev);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_evict_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
 
-	inode = f->f_dentry->d_inode;
+	if (!inode->i_nlink && !is_bad_inode(inode))
+		deleteme = 1;
+	truncate_inode_pages(&inode->i_data, 0);
+	Y_CLEAR_INODE(inode);
 
-	if (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND)
-		ipos = inode->i_size;
-	else
-		ipos = *pos;
+	if (deleteme && obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
+	}
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode, obj);
+		yaffs_gross_unlock(dev);
+	}
+}
+#else
 
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_file_write about to write writing %u(%x) bytes to object %d at %d(%x)",
-		(unsigned)n, (unsigned)n, obj->obj_id, ipos, ipos);
+/* clear is called to tell the fs to release any per-inode data it holds.
+ * The object might still exist on disk and is just being thrown out of the cache
+ * or else the object has actually been deleted and we're being called via
+ * the chain
+ *   yaffs_delete_inode() -> clear_inode()->yaffs_clear_inode()
+ */
 
-	n_written = yaffs_wr_file(obj, buf, ipos, n, 0);
+static void yaffs_clear_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
 
-	yaffs_touch_super(dev);
+	obj = yaffs_inode_to_obj(inode);
 
 	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_file_write: %d(%x) bytes written",
-		(unsigned)n, (unsigned)n);
-
-	if (n_written > 0) {
-		ipos += n_written;
-		*pos = ipos;
-		if (ipos > inode->i_size) {
-			inode->i_size = ipos;
-			inode->i_blocks = (ipos + 511) >> 9;
+		"yaffs_clear_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
 
-			yaffs_trace(YAFFS_TRACE_OS,
-				"yaffs_file_write size updated to %d bytes, %d blocks",
-				ipos, (int)(inode->i_blocks));
-		}
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode, obj);
+		yaffs_gross_unlock(dev);
 	}
-	yaffs_gross_unlock(dev);
-	return (n_written == 0) && (n > 0) ? -ENOSPC : n_written;
+
 }
 
-static int yaffs_write_end(struct file *filp, struct address_space *mapping,
-			   loff_t pos, unsigned len, unsigned copied,
-			   struct page *pg, void *fsdadata)
+/* delete is called when the link count is zero and the inode
+ * is put (ie. nobody wants to know about it anymore, time to
+ * delete the file).
+ * NB Must call clear_inode()
+ */
+static void yaffs_delete_inode(struct inode *inode)
 {
-	int ret = 0;
-	void *addr, *kva;
-	uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE - 1);
-
-	kva = kmap(pg);
-	addr = kva + offset_into_page;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+	struct yaffs_dev *dev;
 
 	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_write_end addr %p pos %x n_bytes %d",
-		addr, (unsigned)pos, copied);
-
-	ret = yaffs_file_write(filp, addr, copied, &pos);
+		"yaffs_delete_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
 
-	if (ret != copied) {
-		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_write_end not same size ret %d  copied %d",
-			ret, copied);
-		SetPageError(pg);
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
 	}
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+	truncate_inode_pages(&inode->i_data, 0);
+#endif
+	clear_inode(inode);
+}
+#endif
 
-	kunmap(pg);
 
-	yaffs_release_space(filp);
-	unlock_page(pg);
-	page_cache_release(pg);
-	return ret;
-}
 
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
 static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
 	struct super_block *sb = dentry->d_sb;
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+#else
+static int yaffs_statfs(struct super_block *sb, struct statfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+#endif
 
 	yaffs_trace(YAFFS_TRACE_OS, "yaffs_statfs");
 
@@ -1443,12 +2359,11 @@ static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf)
 
 		bytes_in_dev =
 		    ((uint64_t)
-		     ((dev->param.end_block - dev->param.start_block + 1))) *
-		     ((uint64_t) (dev->param.chunks_per_block *
+		     ((dev->param.end_block - dev->param.start_block +
+		       1))) * ((uint64_t) (dev->param.chunks_per_block *
 					   dev->data_bytes_per_chunk));
 
-		do_div(bytes_in_dev, sb->s_blocksize);
-			/* bytes_in_dev becomes the number of blocks */
+		do_div(bytes_in_dev, sb->s_blocksize);	/* bytes_in_dev becomes the number of blocks */
 		buf->f_blocks = bytes_in_dev;
 
 		bytes_free = ((uint64_t) (yaffs_get_n_free_chunks(dev))) *
@@ -1480,230 +2395,72 @@ static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf)
 
 	buf->f_files = 0;
 	buf->f_ffree = 0;
-	buf->f_bavail = buf->f_bfree;
-
-	yaffs_gross_unlock(dev);
-	return 0;
-}
-
-static void yaffs_flush_inodes(struct super_block *sb)
-{
-	struct inode *iptr;
-	struct yaffs_obj *obj;
-
-	list_for_each_entry(iptr, &sb->s_inodes, i_sb_list) {
-		obj = yaffs_inode_to_obj(iptr);
-		if (obj) {
-			yaffs_trace(YAFFS_TRACE_OS,
-				"flushing obj %d", obj->obj_id);
-			yaffs_flush_file(obj, 1, 0);
-		}
-	}
-}
-
-static void yaffs_flush_super(struct super_block *sb, int do_checkpoint)
-{
-	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
-
-	if (!dev)
-		return;
-
-	yaffs_flush_inodes(sb);
-	yaffs_update_dirty_dirs(dev);
-	yaffs_flush_whole_cache(dev);
-	if (do_checkpoint)
-		yaffs_checkpoint_save(dev);
-}
-
-static unsigned yaffs_bg_gc_urgency(struct yaffs_dev *dev)
-{
-	unsigned erased_chunks =
-	    dev->n_erased_blocks * dev->param.chunks_per_block;
-	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
-	unsigned scattered = 0;	/* Free chunks not in an erased block */
-
-	if (erased_chunks < dev->n_free_chunks)
-		scattered = (dev->n_free_chunks - erased_chunks);
-
-	if (!context->bg_running)
-		return 0;
-	else if (scattered < (dev->param.chunks_per_block * 2))
-		return 0;
-	else if (erased_chunks > dev->n_free_chunks / 2)
-		return 0;
-	else if (erased_chunks > dev->n_free_chunks / 4)
-		return 1;
-	else
-		return 2;
-}
-
-static int yaffs_do_sync_fs(struct super_block *sb, int request_checkpoint)
-{
-
-	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
-	unsigned int oneshot_checkpoint = (yaffs_auto_checkpoint & 4);
-	unsigned gc_urgent = yaffs_bg_gc_urgency(dev);
-	int do_checkpoint;
-
-	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
-		"yaffs_do_sync_fs: gc-urgency %d %s %s%s",
-		gc_urgent,
-		sb->s_dirt ? "dirty" : "clean",
-		request_checkpoint ? "checkpoint requested" : "no checkpoint",
-		oneshot_checkpoint ? " one-shot" : "");
-
-	yaffs_gross_lock(dev);
-	do_checkpoint = ((request_checkpoint && !gc_urgent) ||
-			 oneshot_checkpoint) && !dev->is_checkpointed;
-
-	if (sb->s_dirt || do_checkpoint) {
-		yaffs_flush_super(sb, !dev->is_checkpointed && do_checkpoint);
-		sb->s_dirt = 0;
-		if (oneshot_checkpoint)
-			yaffs_auto_checkpoint &= ~4;
-	}
-	yaffs_gross_unlock(dev);
-
-	return 0;
-}
-
-/*
- * yaffs background thread functions .
- * yaffs_bg_thread_fn() the thread function
- * yaffs_bg_start() launches the background thread.
- * yaffs_bg_stop() cleans up the background thread.
- *
- * NB:
- * The thread should only run after the yaffs is initialised
- * The thread should be stopped before yaffs is unmounted.
- * The thread should not do any writing while the fs is in read only.
- */
-
-void yaffs_background_waker(unsigned long data)
-{
-	wake_up_process((struct task_struct *)data);
-}
-
-static int yaffs_bg_thread_fn(void *data)
-{
-	struct yaffs_dev *dev = (struct yaffs_dev *)data;
-	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
-	unsigned long now = jiffies;
-	unsigned long next_dir_update = now;
-	unsigned long next_gc = now;
-	unsigned long expires;
-	unsigned int urgency;
-	int gc_result;
-	struct timer_list timer;
-
-	yaffs_trace(YAFFS_TRACE_BACKGROUND,
-		"yaffs_background starting for dev %p", (void *)dev);
-
-	set_freezable();
-	while (context->bg_running) {
-		yaffs_trace(YAFFS_TRACE_BACKGROUND, "yaffs_background");
-
-		if (kthread_should_stop())
-			break;
-
-		if (try_to_freeze())
-			continue;
-
-		yaffs_gross_lock(dev);
-
-		now = jiffies;
-
-		if (time_after(now, next_dir_update) && yaffs_bg_enable) {
-			yaffs_update_dirty_dirs(dev);
-			next_dir_update = now + HZ;
-		}
-
-		if (time_after(now, next_gc) && yaffs_bg_enable) {
-			if (!dev->is_checkpointed) {
-				urgency = yaffs_bg_gc_urgency(dev);
-				gc_result = yaffs_bg_gc(dev, urgency);
-				if (urgency > 1)
-					next_gc = now + HZ / 20 + 1;
-				else if (urgency > 0)
-					next_gc = now + HZ / 10 + 1;
-				else
-					next_gc = now + HZ * 2;
-			} else	{
-				/*
-				 * gc not running so set to next_dir_update
-				 * to cut down on wake ups
-				 */
-				next_gc = next_dir_update;
-			}
-		}
-		yaffs_gross_unlock(dev);
-		expires = next_dir_update;
-		if (time_before(next_gc, expires))
-			expires = next_gc;
-		if (time_before(expires, now))
-			expires = now + HZ;
-
-		init_timer_on_stack(&timer);
-		timer.expires = expires + 1;
-		timer.data = (unsigned long)current;
-		timer.function = yaffs_background_waker;
-
-		set_current_state(TASK_INTERRUPTIBLE);
-		add_timer(&timer);
-		schedule();
-		del_timer_sync(&timer);
-	}
-
-	return 0;
-}
-
-static int yaffs_bg_start(struct yaffs_dev *dev)
-{
-	int retval = 0;
-	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
-
-	if (dev->read_only)
-		return -1;
-
-	context->bg_running = 1;
-
-	context->bg_thread = kthread_run(yaffs_bg_thread_fn,
-					 (void *)dev, "yaffs-bg-%d",
-					 context->mount_id);
-
-	if (IS_ERR(context->bg_thread)) {
-		retval = PTR_ERR(context->bg_thread);
-		context->bg_thread = NULL;
-		context->bg_running = 0;
-	}
-	return retval;
+	buf->f_bavail = buf->f_bfree;
+
+	yaffs_gross_unlock(dev);
+	return 0;
 }
 
-static void yaffs_bg_stop(struct yaffs_dev *dev)
+
+
+static int yaffs_do_sync_fs(struct super_block *sb, int request_checkpoint)
 {
-	struct yaffs_linux_context *ctxt = yaffs_dev_to_lc(dev);
 
-	ctxt->bg_running = 0;
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	unsigned int oneshot_checkpoint = (yaffs_auto_checkpoint & 4);
+	unsigned gc_urgent = yaffs_bg_gc_urgency(dev);
+	int do_checkpoint;
+	int dirty = yaffs_check_super_dirty(dev);
 
-	if (ctxt->bg_thread) {
-		kthread_stop(ctxt->bg_thread);
-		ctxt->bg_thread = NULL;
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+		"yaffs_do_sync_fs: gc-urgency %d %s %s%s",
+		gc_urgent,
+		dirty ? "dirty" : "clean",
+		request_checkpoint ? "checkpoint requested" : "no checkpoint",
+		oneshot_checkpoint ? " one-shot" : "");
+
+	yaffs_gross_lock(dev);
+	do_checkpoint = ((request_checkpoint && !gc_urgent) ||
+			 oneshot_checkpoint) && !dev->is_checkpointed;
+
+	if (dirty || do_checkpoint) {
+		yaffs_flush_super(sb, !dev->is_checkpointed && do_checkpoint);
+		yaffs_clear_super_dirty(dev);
+		if (oneshot_checkpoint)
+			yaffs_auto_checkpoint &= ~4;
 	}
+	yaffs_gross_unlock(dev);
+
+	return 0;
 }
 
+
+#ifdef YAFFS_HAS_WRITE_SUPER
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
 static void yaffs_write_super(struct super_block *sb)
+#else
+static int yaffs_write_super(struct super_block *sb)
+#endif
 {
 	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 2);
 
 	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
-		"yaffs_write_super%s",
+		"yaffs_write_super %s",
 		request_checkpoint ? " checkpt" : "");
 
 	yaffs_do_sync_fs(sb, request_checkpoint);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+	return 0;
+#endif
 }
+#endif
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
 static int yaffs_sync_fs(struct super_block *sb, int wait)
+#else
+static int yaffs_sync_fs(struct super_block *sb)
+#endif
 {
 	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 1);
 
@@ -1715,8 +2472,29 @@ static int yaffs_sync_fs(struct super_block *sb, int wait)
 	return 0;
 }
 
-static LIST_HEAD(yaffs_context_list);
-struct mutex yaffs_context_lock;
+
+
+static const struct super_operations yaffs_super_ops = {
+	.statfs = yaffs_statfs,
+
+#ifndef YAFFS_USE_OWN_IGET
+	.read_inode = yaffs_read_inode,
+#endif
+#ifdef YAFFS_HAS_PUT_INODE
+	.put_inode = yaffs_put_inode,
+#endif
+	.put_super = yaffs_put_super,
+#ifdef YAFFS_HAS_EVICT_INODE
+	.evict_inode = yaffs_evict_inode,
+#else
+	.delete_inode = yaffs_delete_inode,
+	.clear_inode = yaffs_clear_inode,
+#endif
+	.sync_fs = yaffs_sync_fs,
+#ifdef YAFFS_HAS_WRITE_SUPER
+	.write_super = yaffs_write_super,
+#endif
+};
 
 struct yaffs_options {
 	int inband_tags;
@@ -1729,11 +2507,12 @@ struct yaffs_options {
 	int lazy_loading_overridden;
 	int empty_lost_and_found;
 	int empty_lost_and_found_overridden;
+	int disable_summary;
 };
 
 #define MAX_OPT_LEN 30
 static int yaffs_parse_options(struct yaffs_options *options,
-				const char *options_str)
+			       const char *options_str)
 {
 	char cur_opt[MAX_OPT_LEN + 1];
 	int p;
@@ -1770,6 +2549,8 @@ static int yaffs_parse_options(struct yaffs_options *options,
 		} else if (!strcmp(cur_opt, "lazy-loading-on")) {
 			options->lazy_loading_enabled = 1;
 			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "disable-summary")) {
+			options->disable_summary = 1;
 		} else if (!strcmp(cur_opt, "empty-lost-and-found-off")) {
 			options->empty_lost_and_found = 0;
 			options->empty_lost_and_found_overridden = 1;
@@ -1791,174 +2572,27 @@ static int yaffs_parse_options(struct yaffs_options *options,
 			error = 1;
 		}
 	}
+
 	return error;
 }
 
-static const struct address_space_operations yaffs_file_address_operations = {
-	.readpage = yaffs_readpage,
-	.writepage = yaffs_writepage,
-	.write_begin = yaffs_write_begin,
-	.write_end = yaffs_write_end,
-};
-
-
-
-static const struct inode_operations yaffs_file_inode_operations = {
-	.setattr = yaffs_setattr,
-	.setxattr = yaffs_setxattr,
-	.getxattr = yaffs_getxattr,
-	.listxattr = yaffs_listxattr,
-	.removexattr = yaffs_removexattr,
-};
-
-static const struct inode_operations yaffs_symlink_inode_operations = {
-	.readlink = yaffs_readlink,
-	.follow_link = yaffs_follow_link,
-	.put_link = yaffs_put_link,
-	.setattr = yaffs_setattr,
-	.setxattr = yaffs_setxattr,
-	.getxattr = yaffs_getxattr,
-	.listxattr = yaffs_listxattr,
-	.removexattr = yaffs_removexattr,
-};
 
-static void yaffs_fill_inode_from_obj(struct inode *inode,
-				      struct yaffs_obj *obj)
+static struct dentry *yaffs_make_root(struct inode *inode)
 {
-	u32 mode;
-
-	if (!inode || !obj)  {
-		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_fill_inode invalid parameters");
-		return;
-	}
-
-	/* Check mode against the variant type
-	 * and attempt to repair if broken. */
-	mode = obj->yst_mode;
-
-	switch (obj->variant_type) {
-	case YAFFS_OBJECT_TYPE_FILE:
-		if (!S_ISREG(mode)) {
-			obj->yst_mode &= ~S_IFMT;
-			obj->yst_mode |= S_IFREG;
-		}
-		break;
-	case YAFFS_OBJECT_TYPE_SYMLINK:
-		if (!S_ISLNK(mode)) {
-			obj->yst_mode &= ~S_IFMT;
-			obj->yst_mode |= S_IFLNK;
-		}
-		break;
-	case YAFFS_OBJECT_TYPE_DIRECTORY:
-		if (!S_ISDIR(mode)) {
-			obj->yst_mode &= ~S_IFMT;
-			obj->yst_mode |= S_IFDIR;
-		}
-		break;
-	case YAFFS_OBJECT_TYPE_UNKNOWN:
-	case YAFFS_OBJECT_TYPE_HARDLINK:
-	case YAFFS_OBJECT_TYPE_SPECIAL:
-	default:
-		/* TODO? */
-		break;
-	}
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0))
+	struct dentry *root = d_alloc_root(inode);
 
-	inode->i_flags |= S_NOATIME;
-	inode->i_ino = obj->obj_id;
-	inode->i_mode = obj->yst_mode;
-	inode->i_uid = obj->yst_uid;
-	inode->i_gid = obj->yst_gid;
-
-	inode->i_rdev = old_decode_dev(obj->yst_rdev);
-
-	inode->i_atime.tv_sec = (time_t) (obj->yst_atime);
-	inode->i_atime.tv_nsec = 0;
-	inode->i_mtime.tv_sec = (time_t) obj->yst_mtime;
-	inode->i_mtime.tv_nsec = 0;
-	inode->i_ctime.tv_sec = (time_t) obj->yst_ctime;
-	inode->i_ctime.tv_nsec = 0;
-	inode->i_size = yaffs_get_obj_length(obj);
-	inode->i_blocks = (inode->i_size + 511) >> 9;
-	set_nlink(inode, yaffs_get_obj_link_count(obj));
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_fill_inode mode %x uid %d gid %d size %d count %d",
-		inode->i_mode, inode->i_uid, inode->i_gid,
-		(int)inode->i_size, atomic_read(&inode->i_count));
-
-	switch (obj->yst_mode & S_IFMT) {
-	default:	/* fifo, device or socket */
-		init_special_inode(inode, obj->yst_mode,
-				   old_decode_dev(obj->yst_rdev));
-		break;
-	case S_IFREG:	/* file */
-		inode->i_op = &yaffs_file_inode_operations;
-		inode->i_fop = &yaffs_file_operations;
-		inode->i_mapping->a_ops = &yaffs_file_address_operations;
-		break;
-	case S_IFDIR:	/* directory */
-		inode->i_op = &yaffs_dir_inode_operations;
-		inode->i_fop = &yaffs_dir_operations;
-		break;
-	case S_IFLNK:	/* symlink */
-		inode->i_op = &yaffs_symlink_inode_operations;
-		break;
-	}
+	if (!root)
+		iput(inode);
 
-	yaffs_inode_to_obj_lv(inode) = obj;
-	obj->my_inode = inode;
+        return root;
+#else
+        return d_make_root(inode);
+#endif
 }
 
-static void yaffs_put_super(struct super_block *sb)
-{
-	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
-	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
-
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_put_super");
-
-	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
-		"Shutting down yaffs background thread");
-	yaffs_bg_stop(dev);
-	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
-		"yaffs background thread shut down");
-
-	yaffs_gross_lock(dev);
-
-	yaffs_flush_super(sb, 1);
-
-	if (yaffs_dev_to_lc(dev)->put_super_fn)
-		yaffs_dev_to_lc(dev)->put_super_fn(sb);
-
-	yaffs_deinitialise(dev);
-
-	yaffs_gross_unlock(dev);
-	mutex_lock(&yaffs_context_lock);
-	list_del_init(&(yaffs_dev_to_lc(dev)->context_list));
-	mutex_unlock(&yaffs_context_lock);
-
-	if (yaffs_dev_to_lc(dev)->spare_buffer) {
-		kfree(yaffs_dev_to_lc(dev)->spare_buffer);
-		yaffs_dev_to_lc(dev)->spare_buffer = NULL;
-	}
-
-	kfree(dev);
-
 
 
-	if (mtd && mtd->sync)
-		mtd->sync(mtd);
-
-	if (mtd)
-		put_mtd_device(mtd);
-}
-
-static const struct super_operations yaffs_super_ops = {
-	.statfs = yaffs_statfs,
-	.put_super = yaffs_put_super,
-	.evict_inode = yaffs_evict_inode,
-	.sync_fs = yaffs_sync_fs,
-	.write_super = yaffs_write_super,
-};
 
 static struct super_block *yaffs_internal_read_super(int yaffs_version,
 						     struct super_block *sb,
@@ -1974,8 +2608,12 @@ static struct super_block *yaffs_internal_read_super(int yaffs_version,
 	char *data_str = (char *)data;
 	struct yaffs_linux_context *context = NULL;
 	struct yaffs_param *param;
+
 	int read_only = 0;
+	int inband_tags = 0;
+
 	struct yaffs_options options;
+
 	unsigned mount_id;
 	int found;
 	struct yaffs_linux_context *context_iterator;
@@ -1984,7 +2622,7 @@ static struct super_block *yaffs_internal_read_super(int yaffs_version,
 	if (!sb) {
 		printk(KERN_INFO "yaffs: sb is NULL\n");
 		return NULL;
-	}
+        }
 
 	sb->s_magic = YAFFS_MAGIC;
 	sb->s_op = &yaffs_super_ops;
@@ -1992,7 +2630,9 @@ static struct super_block *yaffs_internal_read_super(int yaffs_version,
 
 	read_only = ((sb->s_flags & MS_RDONLY) != 0);
 
+#ifdef YAFFS_COMPILE_EXPORTFS
 	sb->s_export_op = &yaffs_export_ops;
+#endif
 
 	if (!sb->s_dev)
 		printk(KERN_INFO "yaffs: sb->s_dev is NULL\n");
@@ -2010,9 +2650,10 @@ static struct super_block *yaffs_internal_read_super(int yaffs_version,
 
 	memset(&options, 0, sizeof(options));
 
-	if (yaffs_parse_options(&options, data_str))
+	if (yaffs_parse_options(&options, data_str)) {
 		/* Option parsing failed */
 		return NULL;
+	}
 
 	sb->s_blocksize = PAGE_CACHE_SIZE;
 	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
@@ -2023,89 +2664,37 @@ static struct super_block *yaffs_internal_read_super(int yaffs_version,
 		"yaffs_read_super: block size %d", (int)(sb->s_blocksize));
 
 	yaffs_trace(YAFFS_TRACE_ALWAYS,
-		"Attempting MTD mount of %u.%u,\"%s\"",
+		"yaffs: Attempting MTD mount of %u.%u,\"%s\"",
 		MAJOR(sb->s_dev), MINOR(sb->s_dev),
 		yaffs_devname(sb, devname_buf));
 
-	/* Check it's an mtd device..... */
-	if (MAJOR(sb->s_dev) != MTD_BLOCK_MAJOR)
-		return NULL;	/* This isn't an mtd device */
-
 	/* Get the device */
 	mtd = get_mtd_device(NULL, MINOR(sb->s_dev));
 	if (!mtd) {
 		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"MTD device #%u doesn't appear to exist",
+			"yaffs: MTD device %u either not valid or unavailable",
 			MINOR(sb->s_dev));
 		return NULL;
 	}
-	/* Check it's NAND */
-	if (mtd->type != MTD_NANDFLASH) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"MTD device is not NAND it's type %d",
-			mtd->type);
-		return NULL;
-	}
-
-	yaffs_trace(YAFFS_TRACE_OS, " erase %p", mtd->erase);
-	yaffs_trace(YAFFS_TRACE_OS, " read %p", mtd->read);
-	yaffs_trace(YAFFS_TRACE_OS, " write %p", mtd->write);
-	yaffs_trace(YAFFS_TRACE_OS, " readoob %p", mtd->read_oob);
-	yaffs_trace(YAFFS_TRACE_OS, " writeoob %p", mtd->write_oob);
-	yaffs_trace(YAFFS_TRACE_OS, " block_isbad %p", mtd->block_isbad);
-	yaffs_trace(YAFFS_TRACE_OS, " block_markbad %p", mtd->block_markbad);
-	yaffs_trace(YAFFS_TRACE_OS, " writesize %d", mtd->writesize);
-	yaffs_trace(YAFFS_TRACE_OS, " oobsize %d", mtd->oobsize);
-	yaffs_trace(YAFFS_TRACE_OS, " erasesize %d", mtd->erasesize);
-	yaffs_trace(YAFFS_TRACE_OS, " size %lld", mtd->size);
 
-	if (yaffs_auto_select && yaffs_version == 1 && mtd->writesize >= 2048) {
+	if (yaffs_auto_select && yaffs_version == 1 && WRITE_SIZE(mtd) >= 2048) {
 		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs2");
 		yaffs_version = 2;
 	}
 
-	if (yaffs_auto_select && yaffs_version == 2 && !options.inband_tags &&
-		mtd->writesize == 512) {
+	/* Added NCB 26/5/2006 for completeness */
+	if (yaffs_version == 2 && !options.inband_tags
+	    && WRITE_SIZE(mtd) == 512) {
 		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs1");
 		yaffs_version = 1;
 	}
 
-	if (yaffs_version == 2) {
-		/* Check for version 2 style functions */
-		if (!mtd->erase ||
-		    !mtd->block_isbad ||
-		    !mtd->block_markbad ||
-		    !mtd->read ||
-		    !mtd->write || !mtd->read_oob || !mtd->write_oob) {
-			yaffs_trace(YAFFS_TRACE_ALWAYS,
-				"MTD device does not support required functions");
-			return NULL;
-		}
-
-		if ((mtd->writesize < YAFFS_MIN_YAFFS2_CHUNK_SIZE ||
-		     mtd->oobsize < YAFFS_MIN_YAFFS2_SPARE_SIZE) &&
-		    !options.inband_tags) {
-			yaffs_trace(YAFFS_TRACE_ALWAYS,
-				"MTD device does not have the right page sizes");
-			return NULL;
-		}
-	} else {
-		/* Check for V1 style functions */
-		if (!mtd->erase ||
-		    !mtd->read ||
-		    !mtd->write || !mtd->read_oob || !mtd->write_oob) {
-			yaffs_trace(YAFFS_TRACE_ALWAYS,
-				"MTD device does not support required functions");
-			return NULL;
-		}
+	if (mtd->oobavail < sizeof(struct yaffs_packed_tags2) ||
+	    options.inband_tags)
+		inband_tags = 1;
 
-		if (mtd->writesize < YAFFS_BYTES_PER_CHUNK ||
-		    mtd->oobsize != YAFFS_BYTES_PER_SPARE) {
-			yaffs_trace(YAFFS_TRACE_ALWAYS,
-				"MTD device does not support have the right page sizes");
-			return NULL;
-		}
-	}
+	if(yaffs_verify_mtd(mtd, yaffs_version, inband_tags) < 0)
+		return NULL;
 
 	/* OK, so if we got here, we have an MTD that's NAND and looks
 	 * like it has the right capabilities
@@ -2115,7 +2704,8 @@ static struct super_block *yaffs_internal_read_super(int yaffs_version,
 	if (!read_only && !(mtd->flags & MTD_WRITEABLE)) {
 		read_only = 1;
 		printk(KERN_INFO
-		       "yaffs: mtd is read only, setting superblock read only");
+		       "yaffs: mtd is read only, setting superblock read only\n"
+		);
 		sb->s_flags |= MS_RDONLY;
 	}
 
@@ -2123,8 +2713,10 @@ static struct super_block *yaffs_internal_read_super(int yaffs_version,
 	context = kmalloc(sizeof(struct yaffs_linux_context), GFP_KERNEL);
 
 	if (!dev || !context) {
-		kfree(dev);
-		kfree(context);
+		if (dev)
+			kfree(dev);
+		if (context)
+			kfree(context);
 		dev = NULL;
 		context = NULL;
 	}
@@ -2132,7 +2724,8 @@ static struct super_block *yaffs_internal_read_super(int yaffs_version,
 	if (!dev) {
 		/* Deep shit could not allocate device structure */
 		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"yaffs_read_super failed trying to allocate yaffs_dev");
+			"yaffs_read_super: Failed trying to allocate struct yaffs_dev."
+		);
 		return NULL;
 	}
 	memset(dev, 0, sizeof(struct yaffs_dev));
@@ -2146,26 +2739,23 @@ static struct super_block *yaffs_internal_read_super(int yaffs_version,
 
 	dev->read_only = read_only;
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
 	sb->s_fs_info = dev;
+#else
+	sb->u.generic_sbp = dev;
+#endif
+
 
 	dev->driver_context = mtd;
 	param->name = mtd->name;
 
 	/* Set up the memory size parameters.... */
 
-	n_blocks =
-	    YCALCBLOCKS(mtd->size,
-			(YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK));
 
-	param->start_block = 0;
-	param->end_block = n_blocks - 1;
-	param->chunks_per_block = YAFFS_CHUNKS_PER_BLOCK;
-	param->total_bytes_per_chunk = YAFFS_BYTES_PER_CHUNK;
 	param->n_reserved_blocks = 5;
 	param->n_caches = (options.no_cache) ? 0 : 10;
-	param->inband_tags = options.inband_tags;
+	param->inband_tags = inband_tags;
 
-	param->disable_lazy_load = 1;
 	param->enable_xattr = 1;
 	if (options.lazy_loading_overridden)
 		param->disable_lazy_load = !options.lazy_loading_enabled;
@@ -2176,42 +2766,45 @@ static struct super_block *yaffs_internal_read_super(int yaffs_version,
 		param->no_tags_ecc = !options.tags_ecc_on;
 
 	param->empty_lost_n_found = 1;
-
 	param->refresh_period = 500;
+	param->disable_summary = options.disable_summary;
+
 
+#ifdef CONFIG_YAFFS_DISABLE_BAD_BLOCK_MARKING
+	param->disable_bad_block_marking  = 1;
+#endif
 	if (options.empty_lost_and_found_overridden)
 		param->empty_lost_n_found = options.empty_lost_and_found;
 
 	/* ... and the functions. */
 	if (yaffs_version == 2) {
-		param->write_chunk_tags_fn = nandmtd2_write_chunk_tags;
-		param->read_chunk_tags_fn = nandmtd2_read_chunk_tags;
-		param->bad_block_fn = nandmtd2_mark_block_bad;
-		param->query_block_fn = nandmtd2_query_block;
-		yaffs_dev_to_lc(dev)->spare_buffer =
-				kmalloc(mtd->oobsize, GFP_NOFS);
 		param->is_yaffs2 = 1;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
 		param->total_bytes_per_chunk = mtd->writesize;
 		param->chunks_per_block = mtd->erasesize / mtd->writesize;
+#else
+		param->total_bytes_per_chunk = mtd->oobblock;
+		param->chunks_per_block = mtd->erasesize / mtd->oobblock;
+#endif
 		n_blocks = YCALCBLOCKS(mtd->size, mtd->erasesize);
 
 		param->start_block = 0;
 		param->end_block = n_blocks - 1;
 	} else {
-		/* use the MTD interface in yaffs_mtdif1.c */
-		param->write_chunk_tags_fn = nandmtd1_write_chunk_tags;
-		param->read_chunk_tags_fn = nandmtd1_read_chunk_tags;
-		param->bad_block_fn = nandmtd1_mark_block_bad;
-		param->query_block_fn = nandmtd1_query_block;
 		param->is_yaffs2 = 0;
+		n_blocks = YCALCBLOCKS(mtd->size,
+			     YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK);
+
+		param->chunks_per_block = YAFFS_CHUNKS_PER_BLOCK;
+		param->total_bytes_per_chunk = YAFFS_BYTES_PER_CHUNK;
 	}
-	/* ... and common functions */
-	param->erase_fn = nandmtd_erase_block;
-	param->initialise_flash_fn = nandmtd_initialise;
 
-	yaffs_dev_to_lc(dev)->put_super_fn = yaffs_mtd_put_super;
+	param->start_block = 0;
+	param->end_block = n_blocks - 1;
+
+	yaffs_mtd_drv_install(dev);
 
-	param->sb_dirty_fn = yaffs_touch_super;
+	param->sb_dirty_fn = yaffs_set_super_dirty;
 	param->gc_control_fn = yaffs_gc_control_callback;
 
 	yaffs_dev_to_lc(dev)->super = sb;
@@ -2223,12 +2816,13 @@ static struct super_block *yaffs_internal_read_super(int yaffs_version,
 
 	mutex_lock(&yaffs_context_lock);
 	/* Get a mount id */
-	for (mount_id = 0, found = 0; !found; mount_id++) {
+	found = 0;
+	for (mount_id = 0; !found; mount_id++) {
 		found = 1;
 		list_for_each(l, &yaffs_context_list) {
 			context_iterator =
-				list_entry(l, struct yaffs_linux_context,
-					context_list);
+			    list_entry(l, struct yaffs_linux_context,
+				       context_list);
 			if (context_iterator->mount_id == mount_id)
 				found = 0;
 		}
@@ -2276,16 +2870,15 @@ static struct super_block *yaffs_internal_read_super(int yaffs_version,
 
 	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: got root inode");
 
-	root = d_alloc_root(inode);
-
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: d_alloc_root done");
+	root = yaffs_make_root(inode);
 
-	if (!root) {
-		iput(inode);
+	if (!root)
 		return NULL;
-	}
+
 	sb->s_root = root;
-	sb->s_dirt = !dev->is_checkpointed;
+	if(!dev->is_checkpointed)
+		yaffs_set_super_dirty(dev);
+
 	yaffs_trace(YAFFS_TRACE_ALWAYS,
 		"yaffs_read_super: is_checkpointed %d",
 		dev->is_checkpointed);
@@ -2294,48 +2887,115 @@ static struct super_block *yaffs_internal_read_super(int yaffs_version,
 	return sb;
 }
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
 static int yaffs_internal_read_super_mtd(struct super_block *sb, void *data,
 					 int silent)
 {
 	return yaffs_internal_read_super(1, sb, data, silent) ? 0 : -EINVAL;
 }
 
-static struct dentry *yaffs_mount(struct file_system_type *fs,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static struct dentry *yaffs_mount(struct file_system_type *fs_type, int flags,
+        const char *dev_name, void *data)
+{
+    return mount_bdev(fs_type, flags, dev_name, data, yaffs_internal_read_super_mtd);
+}
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_read_super(struct file_system_type *fs,
 			    int flags, const char *dev_name,
-			    void *data)
+			    void *data, struct vfsmount *mnt)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs_read_super(struct file_system_type *fs,
+					    int flags, const char *dev_name,
+					    void *data)
 {
-	return mount_bdev(fs, flags, dev_name, data,
+
+	return get_sb_bdev(fs, flags, dev_name, data,
 			   yaffs_internal_read_super_mtd);
 }
+#endif
 
 static struct file_system_type yaffs_fs_type = {
 	.owner = THIS_MODULE,
 	.name = "yaffs",
-	.mount = yaffs_mount,
-	.kill_sb = kill_block_super,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+        .mount = yaffs_mount,
+#else
+        .get_sb = yaffs_read_super,
+#endif
+     	.kill_sb = kill_block_super,
 	.fs_flags = FS_REQUIRES_DEV,
 };
+#else
+static struct super_block *yaffs_read_super(struct super_block *sb, void *data,
+					    int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent);
+}
 
+static DECLARE_FSTYPE(yaffs_fs_type, "yaffs", yaffs_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
 static int yaffs2_internal_read_super_mtd(struct super_block *sb, void *data,
 					  int silent)
 {
 	return yaffs_internal_read_super(2, sb, data, silent) ? 0 : -EINVAL;
 }
 
-static struct dentry *yaffs2_mount(struct file_system_type *fs,
-			     int flags, const char *dev_name, void *data)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static struct dentry *yaffs2_mount(struct file_system_type *fs_type, int flags,
+        const char *dev_name, void *data)
+{
+        return mount_bdev(fs_type, flags, dev_name, data, yaffs2_internal_read_super_mtd);
+}
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs2_read_super(struct file_system_type *fs,
+			     int flags, const char *dev_name, void *data,
+			     struct vfsmount *mnt)
 {
-	return mount_bdev(fs, flags, dev_name, data,
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs2_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs2_read_super(struct file_system_type *fs,
+					     int flags, const char *dev_name,
+					     void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
 			   yaffs2_internal_read_super_mtd);
 }
+#endif
 
 static struct file_system_type yaffs2_fs_type = {
 	.owner = THIS_MODULE,
 	.name = "yaffs2",
-	.mount = yaffs2_mount,
-	.kill_sb = kill_block_super,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+        .mount = yaffs2_mount,
+#else
+        .get_sb = yaffs2_read_super,
+#endif
+     	.kill_sb = kill_block_super,
 	.fs_flags = FS_REQUIRES_DEV,
 };
+#else
+static struct super_block *yaffs2_read_super(struct super_block *sb,
+					     void *data, int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs2_fs_type, "yaffs2", yaffs2_read_super,
+		      FS_REQUIRES_DEV);
+#endif
 
 
 static struct proc_dir_entry *my_proc_entry;
@@ -2343,78 +3003,86 @@ static struct proc_dir_entry *my_proc_entry;
 static char *yaffs_dump_dev_part0(char *buf, struct yaffs_dev *dev)
 {
 	struct yaffs_param *param = &dev->param;
-
-	buf += sprintf(buf, "start_block........... %d\n", param->start_block);
-	buf += sprintf(buf, "end_block............. %d\n", param->end_block);
-	buf += sprintf(buf, "total_bytes_per_chunk. %d\n",
-			param->total_bytes_per_chunk);
-	buf += sprintf(buf, "use_nand_ecc.......... %d\n",
-			param->use_nand_ecc);
-	buf += sprintf(buf, "no_tags_ecc........... %d\n", param->no_tags_ecc);
-	buf += sprintf(buf, "is_yaffs2............. %d\n", param->is_yaffs2);
-	buf += sprintf(buf, "inband_tags........... %d\n", param->inband_tags);
-	buf += sprintf(buf, "empty_lost_n_found.... %d\n",
-			param->empty_lost_n_found);
-	buf += sprintf(buf, "disable_lazy_load..... %d\n",
-			param->disable_lazy_load);
-	buf += sprintf(buf, "refresh_period........ %d\n",
-			param->refresh_period);
-	buf += sprintf(buf, "n_caches.............. %d\n", param->n_caches);
-	buf += sprintf(buf, "n_reserved_blocks..... %d\n",
-			param->n_reserved_blocks);
-	buf += sprintf(buf, "always_check_erased... %d\n",
-			param->always_check_erased);
+	int bs[10];
+
+	yaffs_count_blocks_by_state(dev,bs);
+
+	buf += sprintf(buf, "start_block.......... %d\n", param->start_block);
+	buf += sprintf(buf, "end_block............ %d\n", param->end_block);
+	buf += sprintf(buf, "total_bytes_per_chunk %d\n",
+				param->total_bytes_per_chunk);
+	buf += sprintf(buf, "use_nand_ecc......... %d\n", param->use_nand_ecc);
+	buf += sprintf(buf, "no_tags_ecc.......... %d\n", param->no_tags_ecc);
+	buf += sprintf(buf, "is_yaffs2............ %d\n", param->is_yaffs2);
+	buf += sprintf(buf, "inband_tags.......... %d\n", param->inband_tags);
+	buf += sprintf(buf, "empty_lost_n_found... %d\n",
+				param->empty_lost_n_found);
+	buf += sprintf(buf, "disable_lazy_load.... %d\n",
+				param->disable_lazy_load);
+	buf += sprintf(buf, "disable_bad_block_mrk %d\n",
+				param->disable_bad_block_marking);
+	buf += sprintf(buf, "refresh_period....... %d\n",
+				param->refresh_period);
+	buf += sprintf(buf, "n_caches............. %d\n", param->n_caches);
+	buf += sprintf(buf, "n_reserved_blocks.... %d\n",
+				param->n_reserved_blocks);
+	buf += sprintf(buf, "always_check_erased.. %d\n",
+				param->always_check_erased);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "block count by state\n");
+	buf += sprintf(buf, "0:%d 1:%d 2:%d 3:%d 4:%d\n",
+				bs[0], bs[1], bs[2], bs[3], bs[4]);
+	buf += sprintf(buf, "5:%d 6:%d 7:%d 8:%d 9:%d\n",
+				bs[5], bs[6], bs[7], bs[8], bs[9]);
 
 	return buf;
 }
 
 static char *yaffs_dump_dev_part1(char *buf, struct yaffs_dev *dev)
 {
-	buf += sprintf(buf, "max file size......... %lld\n",
-			(long long) yaffs_max_file_size(dev));
-	buf += sprintf(buf, "data_bytes_per_chunk.. %d\n",
-			dev->data_bytes_per_chunk);
-	buf += sprintf(buf, "chunk_grp_bits........ %d\n", dev->chunk_grp_bits);
-	buf += sprintf(buf, "chunk_grp_size........ %d\n", dev->chunk_grp_size);
-	buf +=
-	    sprintf(buf, "n_erased_blocks....... %d\n", dev->n_erased_blocks);
-	buf +=
-	    sprintf(buf, "blocks_in_checkpt..... %d\n", dev->blocks_in_checkpt);
+	buf += sprintf(buf, "max file size....... %lld\n",
+				(long long) yaffs_max_file_size(dev));
+	buf += sprintf(buf, "data_bytes_per_chunk. %d\n",
+				dev->data_bytes_per_chunk);
+	buf += sprintf(buf, "chunk_grp_bits....... %d\n", dev->chunk_grp_bits);
+	buf += sprintf(buf, "chunk_grp_size....... %d\n", dev->chunk_grp_size);
+	buf += sprintf(buf, "n_erased_blocks...... %d\n", dev->n_erased_blocks);
+	buf += sprintf(buf, "blocks_in_checkpt.... %d\n",
+				dev->blocks_in_checkpt);
 	buf += sprintf(buf, "\n");
-	buf += sprintf(buf, "n_tnodes.............. %d\n", dev->n_tnodes);
-	buf += sprintf(buf, "n_obj................. %d\n", dev->n_obj);
-	buf += sprintf(buf, "n_free_chunks......... %d\n", dev->n_free_chunks);
+	buf += sprintf(buf, "n_tnodes............. %d\n", dev->n_tnodes);
+	buf += sprintf(buf, "n_obj................ %d\n", dev->n_obj);
+	buf += sprintf(buf, "n_free_chunks........ %d\n", dev->n_free_chunks);
 	buf += sprintf(buf, "\n");
-	buf += sprintf(buf, "n_page_writes......... %u\n", dev->n_page_writes);
-	buf += sprintf(buf, "n_page_reads.......... %u\n", dev->n_page_reads);
-	buf += sprintf(buf, "n_erasures............ %u\n", dev->n_erasures);
-	buf += sprintf(buf, "n_gc_copies........... %u\n", dev->n_gc_copies);
-	buf += sprintf(buf, "all_gcs............... %u\n", dev->all_gcs);
-	buf +=
-	    sprintf(buf, "passive_gc_count...... %u\n", dev->passive_gc_count);
-	buf +=
-	    sprintf(buf, "oldest_dirty_gc_count. %u\n",
-		    dev->oldest_dirty_gc_count);
-	buf += sprintf(buf, "n_gc_blocks........... %u\n", dev->n_gc_blocks);
-	buf += sprintf(buf, "bg_gcs................ %u\n", dev->bg_gcs);
-	buf +=
-	    sprintf(buf, "n_retried_writes...... %u\n", dev->n_retried_writes);
-	buf +=
-	    sprintf(buf, "n_retired_blocks...... %u\n", dev->n_retired_blocks);
-	buf += sprintf(buf, "n_ecc_fixed........... %u\n", dev->n_ecc_fixed);
-	buf += sprintf(buf, "n_ecc_unfixed......... %u\n", dev->n_ecc_unfixed);
-	buf +=
-	    sprintf(buf, "n_tags_ecc_fixed...... %u\n", dev->n_tags_ecc_fixed);
-	buf +=
-	    sprintf(buf, "n_tags_ecc_unfixed.... %u\n",
-		    dev->n_tags_ecc_unfixed);
-	buf += sprintf(buf, "cache_hits............ %u\n", dev->cache_hits);
-	buf +=
-	    sprintf(buf, "n_deleted_files....... %u\n", dev->n_deleted_files);
-	buf +=
-	    sprintf(buf, "n_unlinked_files...... %u\n", dev->n_unlinked_files);
-	buf += sprintf(buf, "refresh_count......... %u\n", dev->refresh_count);
-	buf += sprintf(buf, "n_bg_deletions........ %u\n", dev->n_bg_deletions);
+	buf += sprintf(buf, "n_page_writes........ %u\n", dev->n_page_writes);
+	buf += sprintf(buf, "n_page_reads......... %u\n", dev->n_page_reads);
+	buf += sprintf(buf, "n_erasures........... %u\n", dev->n_erasures);
+	buf += sprintf(buf, "n_gc_copies.......... %u\n", dev->n_gc_copies);
+	buf += sprintf(buf, "all_gcs.............. %u\n", dev->all_gcs);
+	buf += sprintf(buf, "passive_gc_count..... %u\n",
+				dev->passive_gc_count);
+	buf += sprintf(buf, "oldest_dirty_gc_count %u\n",
+				dev->oldest_dirty_gc_count);
+	buf += sprintf(buf, "n_gc_blocks.......... %u\n", dev->n_gc_blocks);
+	buf += sprintf(buf, "bg_gcs............... %u\n", dev->bg_gcs);
+	buf += sprintf(buf, "n_retried_writes..... %u\n",
+				dev->n_retried_writes);
+	buf += sprintf(buf, "n_retired_blocks..... %u\n",
+				dev->n_retired_blocks);
+	buf += sprintf(buf, "n_ecc_fixed.......... %u\n", dev->n_ecc_fixed);
+	buf += sprintf(buf, "n_ecc_unfixed........ %u\n", dev->n_ecc_unfixed);
+	buf += sprintf(buf, "n_tags_ecc_fixed..... %u\n",
+				dev->n_tags_ecc_fixed);
+	buf += sprintf(buf, "n_tags_ecc_unfixed... %u\n",
+				dev->n_tags_ecc_unfixed);
+	buf += sprintf(buf, "cache_hits........... %u\n", dev->cache_hits);
+	buf += sprintf(buf, "n_deleted_files...... %u\n", dev->n_deleted_files);
+	buf += sprintf(buf, "n_unlinked_files..... %u\n",
+				dev->n_unlinked_files);
+	buf += sprintf(buf, "refresh_count........ %u\n", dev->refresh_count);
+	buf += sprintf(buf, "n_bg_deletions....... %u\n", dev->n_bg_deletions);
+	buf += sprintf(buf, "tags_used............ %u\n", dev->tags_used);
+	buf += sprintf(buf, "summary_used......... %u\n", dev->summary_used);
 
 	return buf;
 }
@@ -2438,7 +3106,10 @@ static int yaffs_proc_read(char *page,
 
 	/* Print header first */
 	if (step == 0)
-		buf += sprintf(buf, "YAFFS built:" __DATE__ " " __TIME__ "\n");
+		buf +=
+		    sprintf(buf,
+			    "Multi-version YAFFS built:" __DATE__ " " __TIME__
+			    "\n");
 	else if (step == 1)
 		buf += sprintf(buf, "\n");
 	else {
@@ -2446,8 +3117,7 @@ static int yaffs_proc_read(char *page,
 
 		mutex_lock(&yaffs_context_lock);
 
-		/* Locate and print the Nth entry.
-		 * Order N-squared but N is small. */
+		/* Locate and print the Nth entry.  Order N-squared but N is small. */
 		list_for_each(item, &yaffs_context_list) {
 			struct yaffs_linux_context *dc =
 			    list_entry(item, struct yaffs_linux_context,
@@ -2465,7 +3135,7 @@ static int yaffs_proc_read(char *page,
 				buf = yaffs_dump_dev_part0(buf, dev);
 			} else {
 				buf = yaffs_dump_dev_part1(buf, dev);
-			}
+                        }
 
 			break;
 		}
@@ -2475,7 +3145,232 @@ static int yaffs_proc_read(char *page,
 	return buf - page < count ? buf - page : count;
 }
 
+/**
+ * Set the verbosity of the warnings and error messages.
+ *
+ * Note that the names can only be a..z or _ with the current code.
+ */
+
+static struct {
+	char *mask_name;
+	unsigned mask_bitfield;
+} mask_flags[] = {
+	{"allocate", YAFFS_TRACE_ALLOCATE},
+	{"always", YAFFS_TRACE_ALWAYS},
+	{"background", YAFFS_TRACE_BACKGROUND},
+	{"bad_blocks", YAFFS_TRACE_BAD_BLOCKS},
+	{"buffers", YAFFS_TRACE_BUFFERS},
+	{"bug", YAFFS_TRACE_BUG},
+	{"checkpt", YAFFS_TRACE_CHECKPOINT},
+	{"deletion", YAFFS_TRACE_DELETION},
+	{"erase", YAFFS_TRACE_ERASE},
+	{"error", YAFFS_TRACE_ERROR},
+	{"gc_detail", YAFFS_TRACE_GC_DETAIL},
+	{"gc", YAFFS_TRACE_GC},
+	{"lock", YAFFS_TRACE_LOCK},
+	{"mtd", YAFFS_TRACE_MTD},
+	{"nandaccess", YAFFS_TRACE_NANDACCESS},
+	{"os", YAFFS_TRACE_OS},
+	{"scan_debug", YAFFS_TRACE_SCAN_DEBUG},
+	{"scan", YAFFS_TRACE_SCAN},
+	{"mount", YAFFS_TRACE_MOUNT},
+	{"tracing", YAFFS_TRACE_TRACING},
+	{"sync", YAFFS_TRACE_SYNC},
+	{"write", YAFFS_TRACE_WRITE},
+	{"verify", YAFFS_TRACE_VERIFY},
+	{"verify_nand", YAFFS_TRACE_VERIFY_NAND},
+	{"verify_full", YAFFS_TRACE_VERIFY_FULL},
+	{"verify_all", YAFFS_TRACE_VERIFY_ALL},
+	{"all", 0xffffffff},
+	{"none", 0},
+	{NULL, 0},
+};
+
+#define MAX_MASK_NAME_LENGTH 40
+static int yaffs_proc_write_trace_options(struct file *file, const char *buf,
+					  unsigned long count, void *data)
+{
+	unsigned rg = 0, mask_bitfield;
+	char *end;
+	char *mask_name;
+	const char *x;
+	char substring[MAX_MASK_NAME_LENGTH + 1];
+	int i;
+	int done = 0;
+	int add, len = 0;
+	int pos = 0;
+
+	rg = yaffs_trace_mask;
+
+	while (!done && (pos < count)) {
+		done = 1;
+		while ((pos < count) && isspace(buf[pos]))
+			pos++;
+
+		switch (buf[pos]) {
+		case '+':
+		case '-':
+		case '=':
+			add = buf[pos];
+			pos++;
+			break;
+
+		default:
+			add = ' ';
+			break;
+		}
+		mask_name = NULL;
+
+		mask_bitfield = simple_strtoul(buf + pos, &end, 0);
+
+		if (end > buf + pos) {
+			mask_name = "numeral";
+			len = end - (buf + pos);
+			pos += len;
+			done = 0;
+		} else {
+			for (x = buf + pos, i = 0;
+			     (*x == '_' || (*x >= 'a' && *x <= 'z')) &&
+			     i < MAX_MASK_NAME_LENGTH; x++, i++, pos++)
+				substring[i] = *x;
+			substring[i] = '\0';
+
+			for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+				if (strcmp(substring, mask_flags[i].mask_name)
+				    == 0) {
+					mask_name = mask_flags[i].mask_name;
+					mask_bitfield =
+					    mask_flags[i].mask_bitfield;
+					done = 0;
+					break;
+				}
+			}
+		}
+
+		if (mask_name != NULL) {
+			done = 0;
+			switch (add) {
+			case '-':
+				rg &= ~mask_bitfield;
+				break;
+			case '+':
+				rg |= mask_bitfield;
+				break;
+			case '=':
+				rg = mask_bitfield;
+				break;
+			default:
+				rg |= mask_bitfield;
+				break;
+			}
+		}
+	}
+
+	yaffs_trace_mask = rg | YAFFS_TRACE_ALWAYS;
+
+	printk(KERN_DEBUG "new trace = 0x%08X\n", yaffs_trace_mask);
+
+	if (rg & YAFFS_TRACE_ALWAYS) {
+		for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+			char flag;
+			flag = ((rg & mask_flags[i].mask_bitfield) ==
+				mask_flags[i].mask_bitfield) ? '+' : '-';
+			printk(KERN_DEBUG "%c%s\n", flag,
+			       mask_flags[i].mask_name);
+		}
+	}
+
+	return count;
+}
+
+/* Debug strings are of the form:
+ * .bnnn         print info on block n
+ * .cobjn,chunkn print nand chunk id for objn:chunkn
+ */
+
+static int yaffs_proc_debug_write(struct file *file, const char *buf,
+					  unsigned long count, void *data)
+{
+
+	char str[100];
+	char *p0;
+	char *p1;
+	long p1_val;
+	long p0_val;
+	char cmd;
+	struct list_head *item;
+
+	memset(str, 0, sizeof(str));
+	memcpy(str, buf, min(count, sizeof(str) -1));
+
+	cmd = str[1];
+
+	p0 = str + 2;
+
+	p1 = p0;
+
+	while (*p1 && *p1 != ',') {
+		p1++;
+	}
+	*p1 = '\0';
+	p1++;
+
+	p0_val = simple_strtol(p0, NULL, 0);
+	p1_val = simple_strtol(p1, NULL, 0);
+
+
+	mutex_lock(&yaffs_context_lock);
+
+	/* Locate and print the Nth entry.  Order N-squared but N is small. */
+	list_for_each(item, &yaffs_context_list) {
+		struct yaffs_linux_context *dc =
+		    list_entry(item, struct yaffs_linux_context,
+			       context_list);
+		struct yaffs_dev *dev = dc->dev;
 
+		if (cmd == 'b') {
+			struct yaffs_block_info *bi;
+
+			bi = yaffs_get_block_info(dev,p0_val);
+
+			if(bi) {
+				printk("Block %d: state %d, retire %d, use %d, seq %d\n",
+					(int)p0_val, bi->block_state,
+					bi->needs_retiring, bi->pages_in_use,
+					bi->seq_number);
+			}
+		} else if (cmd == 'c') {
+			struct yaffs_obj *obj;
+			int nand_chunk;
+
+			obj = yaffs_find_by_number(dev, p0_val);
+			if (!obj)
+				printk("No obj %d\n", (int)p0_val);
+			else {
+				if(p1_val == 0)
+					nand_chunk = obj->hdr_chunk;
+				else
+					nand_chunk =
+						yaffs_find_chunk_in_file(obj,
+							p1_val, NULL);
+				printk("Nand chunk for %d:%d is %d\n",
+					(int)p0_val, (int)p1_val, nand_chunk);
+			}
+		}
+	}
+
+	mutex_unlock(&yaffs_context_lock);
+
+	return count;
+}
+
+static int yaffs_proc_write(struct file *file, const char *buf,
+			    unsigned long count, void *data)
+{
+	if (buf[0] == '.')
+		return yaffs_proc_debug_write(file, buf, count, data);
+	return yaffs_proc_write_trace_options(file, buf, count, data);
+}
 
 /* Stuff to handle installation of file systems */
 struct file_system_to_install {
@@ -2501,16 +3396,15 @@ static int __init init_yaffs_fs(void)
 
 	/* Install the proc_fs entries */
 	my_proc_entry = create_proc_entry("yaffs",
-					  S_IRUGO | S_IFREG, NULL);
+					  S_IRUGO | S_IFREG, YPROC_ROOT);
 
 	if (my_proc_entry) {
-		my_proc_entry->write_proc = NULL;
+		my_proc_entry->write_proc = yaffs_proc_write;
 		my_proc_entry->read_proc = yaffs_proc_read;
 		my_proc_entry->data = NULL;
 	} else {
 		return -ENOMEM;
-	}
-
+        }
 
 	/* Now add the file system entries */
 
@@ -2547,7 +3441,7 @@ static void __exit exit_yaffs_fs(void)
 	yaffs_trace(YAFFS_TRACE_ALWAYS,
 		"yaffs built " __DATE__ " " __TIME__ " removing.");
 
-	remove_proc_entry("yaffs", NULL);
+	remove_proc_entry("yaffs", YPROC_ROOT);
 
 	fsinst = fs_to_install;
 
@@ -2561,8 +3455,8 @@ static void __exit exit_yaffs_fs(void)
 }
 
 module_init(init_yaffs_fs)
-module_exit(exit_yaffs_fs)
+    module_exit(exit_yaffs_fs)
 
-MODULE_DESCRIPTION("YAFFS2 - a NAND specific flash file system");
+    MODULE_DESCRIPTION("YAFFS2 - a NAND specific flash file system");
 MODULE_AUTHOR("Charles Manning, Aleph One Ltd., 2002-2011");
 MODULE_LICENSE("GPL");
diff --git a/fs/yaffs2/yportenv.h b/fs/yaffs2/yportenv.h
index 76a7914..8975af3 100644
--- a/fs/yaffs2/yportenv.h
+++ b/fs/yaffs2/yportenv.h
@@ -13,9 +13,27 @@
  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
  */
 
-#ifndef __YPORTENV_LINUX_H__
-#define __YPORTENV_LINUX_H__
+#ifndef __YPORTENV_H__
+#define __YPORTENV_H__
 
+/*
+ * Define the MTD version in terms of Linux Kernel versions
+ * This allows yaffs to be used independantly of the kernel
+ * as well as with it.
+ */
+
+#define MTD_VERSION(a, b, c) (((a) << 16) + ((b) << 8) + (c))
+
+#ifdef YAFFS_OUT_OF_TREE
+#include "moduleconfig.h"
+#endif
+
+#include <linux/version.h>
+#define MTD_VERSION_CODE LINUX_VERSION_CODE
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
 #include <linux/version.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
@@ -43,23 +61,25 @@
 #define YAFFS_ROOT_MODE			0755
 #define YAFFS_LOSTNFOUND_MODE		0700
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
 #define Y_CURRENT_TIME CURRENT_TIME.tv_sec
 #define Y_TIME_CONVERT(x) (x).tv_sec
+#else
+#define Y_CURRENT_TIME CURRENT_TIME
+#define Y_TIME_CONVERT(x) (x)
+#endif
 
 #define compile_time_assertion(assertion) \
 	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
 
+
 #define yaffs_printf(msk, fmt, ...) \
 	printk(KERN_DEBUG "yaffs: " fmt "\n", ##__VA_ARGS__)
 
-#ifdef CONFIG_YAFFS_DEBUG
 #define yaffs_trace(msk, fmt, ...) do { \
 	if (yaffs_trace_mask & (msk)) \
 		printk(KERN_DEBUG "yaffs: " fmt "\n", ##__VA_ARGS__); \
 } while (0)
-#else
-#define yaffs_trace(msk, fmt, ...) do { \
-} while (0)
-#endif
+
 
 #endif
-- 
1.7.10.4

