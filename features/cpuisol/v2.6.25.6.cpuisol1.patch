From 194de54a089ddf8fd157cd97c61f9e1d432eb88a Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Mon, 23 Jun 2008 11:37:34 -0400
Subject: [PATCH] auto_msg: importing v2.6.25.6.cpuisol1.patch

This is an automatic import of patch v2.6.25.6.cpuisol1.patch, no headers were
detected and a default message was constructed
---
 Documentation/IRQ-affinity.txt |    3 +-
 include/linux/irq.h            |    5 +++
 include/linux/sysctl.h         |    2 +
 kernel/cpuset.c                |    6 +++
 kernel/irq/manage.c            |   21 +++++++++++
 kernel/irq/proc.c              |   17 +++++++++
 kernel/sched.c                 |    4 ++-
 kernel/sysctl.c                |   74 ++++++++++++++++++++++++++++++++++++++++
 8 files changed, 130 insertions(+), 2 deletions(-)

diff --git a/Documentation/IRQ-affinity.txt b/Documentation/IRQ-affinity.txt
index b4a615b..a97b362 100644
--- a/Documentation/IRQ-affinity.txt
+++ b/Documentation/IRQ-affinity.txt
@@ -1,4 +1,4 @@
-ChangeLog:
+ChangeLog:ChangeLog:
 	Started by Ingo Molnar <mingo@redhat.com>
 	Update by Max Krasnyansky <maxk@qualcomm.com>
 
@@ -47,6 +47,7 @@ PING hell (195.4.7.3): 56 data bytes
 --- hell ping statistics ---
 2779 packets transmitted, 2777 packets received, 0% packet loss
 round-trip min/avg/max = 0.1/0.5/585.4 ms
+
 [root@moon 44]# cat /proc/interrupts |  'CPU\|44:'
            CPU0       CPU1       CPU2       CPU3      CPU4       CPU5        CPU6       CPU7
  44:       1068       1785       1785       1783      1784       1069        1070       1069   IO-APIC-level  eth1
diff --git a/include/linux/irq.h b/include/linux/irq.h
index 8ccb462..b3fcdac 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -234,6 +234,8 @@ static inline void set_pending_irq(unsigned int irq, cpumask_t mask)
 #define move_native_irq(x)
 #define move_masked_irq(x)
 
+static inline int irq_select_affinity(unsigned int irq)  { return 0; }
+
 #endif /* CONFIG_SMP */
 
 #ifdef CONFIG_IRQBALANCE
@@ -348,8 +350,11 @@ set_irq_chained_handler(unsigned int irq,
 	__set_irq_handler(irq, handle, 1, NULL);
 }
 
+extern cpumask_t irq_default_affinity;
+
 extern void set_irq_noprobe(unsigned int irq);
 extern void set_irq_probe(unsigned int irq);
+extern int irq_select_affinity(unsigned int irq);
 
 /* Handle dynamic irq creation and destruction */
 extern int create_irq(void);
diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h
index d0437f3..367883b 100644
--- a/include/linux/sysctl.h
+++ b/include/linux/sysctl.h
@@ -995,6 +995,8 @@ extern int proc_doulongvec_minmax(struct ctl_table *, int, struct file *,
 				  void __user *, size_t *, loff_t *);
 extern int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int,
 				      struct file *, void __user *, size_t *, loff_t *);
+extern int proc_docpumask(struct ctl_table *, int, struct file *,
+			 void __user *, size_t *, loff_t *);
 
 extern int do_sysctl (int __user *name, int nlen,
 		      void __user *oldval, size_t __user *oldlenp,
diff --git a/kernel/cpuset.c b/kernel/cpuset.c
index d5ab79c..3a02ac1 100644
--- a/kernel/cpuset.c
+++ b/kernel/cpuset.c
@@ -1928,6 +1928,12 @@ static void common_cpu_mem_hotplug_unplug(int rebuild_sd)
 	if (rebuild_sd)
 		rebuild_sched_domains();
 
+	/*
+	 * Scheduler destroys domains on hotplug events.
+	 * Rebuild them based on the current settings.
+	 */
+	rebuild_sched_domains();
+
 	cgroup_unlock();
 }
 
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 0314074..c230fdf 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -118,6 +118,27 @@ int irq_select_affinity(unsigned int irq)
 }
 #endif
 
+#ifndef CONFIG_AUTO_IRQ_AFFINITY
+/*
+ * Generic version of the affinity autoselector.
+ */
+int irq_select_affinity(unsigned int irq)
+{
+	cpumask_t mask;
+
+	if (!irq_can_set_affinity(irq))
+		return 0;
+
+	cpus_and(mask, cpu_online_map, irq_default_affinity);
+
+	irq_desc[irq].affinity = mask;
+	irq_desc[irq].chip->set_affinity(irq, mask);
+
+	set_balance_irq_affinity(irq, mask);
+	return 0;
+}
+#endif
+
 #endif
 
 /**
diff --git a/kernel/irq/proc.c b/kernel/irq/proc.c
index 6c6d35d..4f47ff6 100644
--- a/kernel/irq/proc.c
+++ b/kernel/irq/proc.c
@@ -220,6 +220,21 @@ void register_default_affinity_proc(void)
 #endif
 }
 
+void register_default_affinity_proc(void)
+{
+#ifdef CONFIG_SMP
+	struct proc_dir_entry *entry;
+
+	/* create /proc/irq/default_smp_affinity */
+	entry = create_proc_entry("default_smp_affinity", 0600, root_irq_dir);
+	if (entry) {
+		entry->data = NULL;
+		entry->read_proc  = default_affinity_read;
+		entry->write_proc = default_affinity_write;
+	}
+#endif
+}
+
 void init_irq_proc(void)
 {
 	int i;
@@ -231,6 +246,8 @@ void init_irq_proc(void)
 
 	register_default_affinity_proc();
 
+	register_default_affinity_proc();
+
 	/*
 	 * Create entries for all existing IRQs.
 	 */
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index fe47133..47d622e 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -87,6 +87,8 @@ extern int sysctl_nr_open_min, sysctl_nr_open_max;
 extern int rcutorture_runnable;
 #endif /* #ifdef CONFIG_RCU_TORTURE_TEST */
 
+extern cpumask_t sysctl_stopmachine_cpus;
+
 /* Constants used for minimum and  maximum */
 #if defined(CONFIG_HIGHMEM) || defined(CONFIG_DETECT_SOFTLOCKUP)
 static int one = 1;
@@ -396,6 +398,17 @@ static struct ctl_table kern_table[] = {
 		.proc_handler	= &proc_dointvec,
 	},
 #endif
+
+#ifdef CONFIG_STOP_MACHINE
+	{
+		.procname	= "stopmachine_cpus",
+		.data		= &sysctl_stopmachine_cpus,
+		.maxlen		= sizeof(cpumask_t),
+		.mode		= 0644,
+		.proc_handler	= &proc_docpumask,
+	},
+#endif
+
 #ifdef CONFIG_BLK_DEV_INITRD
 	{
 		.ctl_name	= KERN_REALROOTDEV,
@@ -2664,6 +2677,61 @@ static int proc_do_cad_pid(struct ctl_table *table, int write, struct file *filp
 	return 0;
 }
 
+static int _proc_do_cpumask(void* data, int maxlen, int write,
+			   struct file *filp, void __user *buffer,
+			   size_t *lenp, loff_t *ppos)
+{
+	cpumask_t *mask = (cpumask_t *) data;
+	ssize_t len;
+	int err;
+
+	if (!data || !maxlen || !*lenp) {
+		*lenp = 0;
+		return 0;
+	}
+
+	if (write) {
+		err = cpumask_parse_user(buffer, *lenp, *mask);
+		if (err)
+			return err;
+		*ppos += *lenp;
+	} else {
+		char *page = (char *) __get_free_page(GFP_TEMPORARY);
+		if (!page)
+			return -ENOMEM;
+
+		len = cpumask_scnprintf(page, PAGE_SIZE, *mask);
+		len = simple_read_from_buffer(buffer, *lenp, ppos, page, len);
+
+		free_page((unsigned long) page);
+
+		if (len < 0)
+			return len;
+		*lenp = len;
+	}
+	return 0;
+}
+
+/**
+ * proc_docpumask - read/write a cpumask sysctl
+ * @table: the sysctl table
+ * @write: %TRUE if this is a write to the sysctl file
+ * @filp: the file structure
+ * @buffer: the user buffer
+ * @lenp: the size of the user buffer
+ * @ppos: file position
+ *
+ * Reads/writes a cpumask from/to the user buffer. 
+ *
+ * Returns 0 on success.
+ */
+int proc_docpumask(struct ctl_table *table, int write, struct file *filp,
+		  void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	return _proc_do_cpumask(table->data, table->maxlen, write, filp,
+			       buffer, lenp, ppos);
+}
+
 #else /* CONFIG_PROC_FS */
 
 int proc_dostring(struct ctl_table *table, int write, struct file *filp,
@@ -2716,6 +2784,12 @@ int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,
     return -ENOSYS;
 }
 
+int proc_docpumask(struct ctl_table *table, int write, struct file *filp,
+		  void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+
+	return -ENOSYS;
+}
 
 #endif /* CONFIG_PROC_FS */
 
-- 
1.5.5.1

