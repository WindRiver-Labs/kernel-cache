From 090b7bddae8ba2b48c39a91ce9378c596d392036 Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Mon, 25 Aug 2008 10:59:44 +0800
Subject: [PATCH] revoke special mmap handling V7 From: Pekka Enberg <penberg@cs.helsinki.fi>

This adds special handling for revoked shared memory mappings.  We want to
raise SIGBUS if someone accesses a revoked mapping and return ENODEV if
somebody tries to remap one with mmap(2).

Cc: Alan Cox <alan@redhat.com>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Christoph Hellwig <hch@infradead.org>
Cc: Peter Zijlstra <peterz@infradead.org>
Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
Integrated-by: Yongli he   <yongli.he@windriver.com>
---
 include/linux/mm.h |    1 +
 mm/memory.c        |    3 +++
 mm/mmap.c          |   12 ++++++++----
 3 files changed, 12 insertions(+), 4 deletions(-)

diff --git a/include/linux/mm.h b/include/linux/mm.h
index 341d396..757194b 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -114,6 +114,7 @@ extern unsigned int kobjsize(const void *objp);
 #define VM_MIXEDMAP	0x10000000	/* Can contain "struct page" and pure PFN pages */
 #define VM_SAO		0x20000000	/* Strong Access Ordering (powerpc) */
 #define VM_XIP		0x40000000	/* Execute In Place from ROM/flash */
+#define VM_REVOKED	0x80000000	/* Mapping has been revoked */
 
 #ifdef CONFIG_PAX_PAGEEXEC
 #define VM_PAGEEXEC	0x40000000	/* vma->vm_page_prot needs special handling */
diff --git a/mm/memory.c b/mm/memory.c
index 89aa04d..462d9e2 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -3030,6 +3030,9 @@ int handle_mm_fault(struct mm_struct *mm, struct vm_area_struct *vma,
 	}
 #endif
 
+	if (unlikely(vma->vm_flags & VM_REVOKED))
+		return VM_FAULT_SIGBUS;
+
 	pgd = pgd_offset(mm, address);
 	pud = pud_alloc(mm, pgd, address);
 	if (!pud) {
diff --git a/mm/mmap.c b/mm/mmap.c
index c6f3e78..764d3ff 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -1217,11 +1217,15 @@ unsigned long mmap_region(struct file *file, unsigned long addr,
 	error = -ENOMEM;
 munmap_back:
 	vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
-	if (vma && vma->vm_start < addr + len) {
-		if (do_munmap(mm, addr, len))
-			return -ENOMEM;
-		vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
+	if (vma) {
+		if (unlikely(vma->vm_flags & VM_REVOKED))
+			return -ENODEV;
+		if (vma->vm_start < addr + len) {
+			if (do_munmap(mm, addr, len))
+				return -ENOMEM;
+			vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
 			BUG_ON(vma && vma->vm_start < addr + len);
+		}
 	}
 
 	/* Check against address space limit. */
-- 
1.5.5.1

