From a54f1ee77b9eecaede7469c1c36d54a844d1ba51 Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Mon, 25 Aug 2008 10:59:44 +0800
Subject: [PATCH] revoke special mmap handling V7 From: Pekka Enberg <penberg@cs.helsinki.fi>

This adds special handling for revoked shared memory mappings.  We want to
raise SIGBUS if someone accesses a revoked mapping and return ENODEV if
somebody tries to remap one with mmap(2).

Cc: Alan Cox <alan@redhat.com>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Christoph Hellwig <hch@infradead.org>
Cc: Peter Zijlstra <peterz@infradead.org>
Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
Integrated-by: Yongli he   <yongli.he@windriver.com>
---
 include/linux/mm.h |    1 +
 mm/memory.c        |    3 +++
 mm/mmap.c          |   12 ++++++++----
 3 files changed, 12 insertions(+), 4 deletions(-)

diff --git a/include/linux/mm.h b/include/linux/mm.h
index a712a6c..b81aa90 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -114,6 +114,7 @@ extern unsigned int kobjsize(const void *objp);
 #define VM_MIXEDMAP	0x10000000	/* Can contain "struct page" and pure PFN pages */
 #define VM_SAO		0x20000000	/* Strong Access Ordering (powerpc) */
 #define VM_XIP		0x40000000	/* Execute In Place from ROM/flash */
+#define VM_REVOKED	0x80000000	/* Mapping has been revoked */
 
 #ifndef VM_STACK_DEFAULT_FLAGS		/* arch can override this */
 #define VM_STACK_DEFAULT_FLAGS VM_DATA_DEFAULT_FLAGS
diff --git a/mm/memory.c b/mm/memory.c
index cb85279..de65037 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -2765,6 +2765,9 @@ int handle_mm_fault(struct mm_struct *mm, struct vm_area_struct *vma,
 		goto end;
 	}
 
+	if (unlikely(vma->vm_flags & VM_REVOKED))
+		return VM_FAULT_SIGBUS;
+
 	pgd = pgd_offset(mm, address);
 	pud = pud_alloc(mm, pgd, address);
 	if (!pud) {
diff --git a/mm/mmap.c b/mm/mmap.c
index e7a5a68..c8b4bbd 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -1105,10 +1105,14 @@ unsigned long mmap_region(struct file *file, unsigned long addr,
 	error = -ENOMEM;
 munmap_back:
 	vma = find_vma_prepare(mm, addr, &prev, &rb_link, &rb_parent);
-	if (vma && vma->vm_start < addr + len) {
-		if (do_munmap(mm, addr, len))
-			return -ENOMEM;
-		goto munmap_back;
+	if (vma) {
+		if (unlikely(vma->vm_flags & VM_REVOKED))
+			return -ENODEV;
+		if (vma->vm_start < addr + len) {
+			if (do_munmap(mm, addr, len))
+				return -ENOMEM;
+			goto munmap_back;
+		}
 	}
 
 	/* Check against address space limit. */
-- 
1.5.5.1

