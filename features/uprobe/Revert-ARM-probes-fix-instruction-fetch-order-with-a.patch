From 97784a11c0b1af6f4705a70fe05ef3370eeb234e Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Mon, 15 Dec 2014 17:48:20 -0500
Subject: [PATCH] Revert "ARM: probes: fix instruction fetch order with
 <asm/opcodes.h>"

This reverts commit 592339d9a7509a252324dade00b73e5024a572d7.

It was a modified version of mainline commit
888be25402021a425da3e85e2d5a954d7509286e upstream.  However we
can see this in the commit log:

    [wangnan: backport to 3.10 and 3.14:
     - adjust context
     - backport all changes on arch/arm/kernel/probes.c to
       arch/arm/kernel/kprobes-common.c since we don't have
       commit c18377c303787ded44b7decd7dee694db0f205e9.
     - After the above adjustments, becomes same to Taras Kondratiuk's
       original patch:
         http://lists.linaro.org/pipermail/linaro-kernel/2014-January/010346.html
    ]
    Signed-off-by: Wang Nan <wangnan0@huawei.com>

Since we _do_ have c18377c303787ded4 (file move/creation) pending in the
ARM backport queue, we revert the stable version that has been modified
extensively, and then queue the unmodified mainline version after the
file move/creation commit.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/arm/kernel/kprobes-common.c b/arch/arm/kernel/kprobes-common.c
index 380c20fb9c85..18a76282970e 100644
--- a/arch/arm/kernel/kprobes-common.c
+++ b/arch/arm/kernel/kprobes-common.c
@@ -14,7 +14,6 @@
 #include <linux/kernel.h>
 #include <linux/kprobes.h>
 #include <asm/system_info.h>
-#include <asm/opcodes.h>
 
 #include "kprobes.h"
 
@@ -306,8 +305,7 @@ kprobe_decode_ldmstm(kprobe_opcode_t insn, struct arch_specific_insn *asi)
 
 	if (handler) {
 		/* We can emulate the instruction in (possibly) modified form */
-		asi->insn[0] = __opcode_to_mem_arm((insn & 0xfff00000) |
-						   (rn << 16) | reglist);
+		asi->insn[0] = (insn & 0xfff00000) | (rn << 16) | reglist;
 		asi->insn_handler = handler;
 		return INSN_GOOD;
 	}
@@ -336,14 +334,13 @@ prepare_emulated_insn(kprobe_opcode_t insn, struct arch_specific_insn *asi,
 #ifdef CONFIG_THUMB2_KERNEL
 	if (thumb) {
 		u16 *thumb_insn = (u16 *)asi->insn;
-		/* Thumb bx lr */
-		thumb_insn[1] = __opcode_to_mem_thumb16(0x4770);
-		thumb_insn[2] = __opcode_to_mem_thumb16(0x4770);
+		thumb_insn[1] = 0x4770; /* Thumb bx lr */
+		thumb_insn[2] = 0x4770; /* Thumb bx lr */
 		return insn;
 	}
-	asi->insn[1] = __opcode_to_mem_arm(0xe12fff1e); /* ARM bx lr */
+	asi->insn[1] = 0xe12fff1e; /* ARM bx lr */
 #else
-	asi->insn[1] = __opcode_to_mem_arm(0xe1a0f00e); /* mov pc, lr */
+	asi->insn[1] = 0xe1a0f00e; /* mov pc, lr */
 #endif
 	/* Make an ARM instruction unconditional */
 	if (insn < 0xe0000000)
@@ -363,12 +360,12 @@ set_emulated_insn(kprobe_opcode_t insn, struct arch_specific_insn *asi,
 	if (thumb) {
 		u16 *ip = (u16 *)asi->insn;
 		if (is_wide_instruction(insn))
-			*ip++ = __opcode_to_mem_thumb16(insn >> 16);
-		*ip++ = __opcode_to_mem_thumb16(insn);
+			*ip++ = insn >> 16;
+		*ip++ = insn;
 		return;
 	}
 #endif
-	asi->insn[0] = __opcode_to_mem_arm(insn);
+	asi->insn[0] = insn;
 }
 
 /*
diff --git a/arch/arm/kernel/kprobes-thumb.c b/arch/arm/kernel/kprobes-thumb.c
index 241222c66a13..6123daf397a7 100644
--- a/arch/arm/kernel/kprobes-thumb.c
+++ b/arch/arm/kernel/kprobes-thumb.c
@@ -11,7 +11,6 @@
 #include <linux/kernel.h>
 #include <linux/kprobes.h>
 #include <linux/module.h>
-#include <asm/opcodes.h>
 
 #include "kprobes.h"
 
@@ -164,9 +163,9 @@ t32_decode_ldmstm(kprobe_opcode_t insn, struct arch_specific_insn *asi)
 	enum kprobe_insn ret = kprobe_decode_ldmstm(insn, asi);
 
 	/* Fixup modified instruction to have halfwords in correct order...*/
-	insn = __mem_to_opcode_arm(asi->insn[0]);
-	((u16 *)asi->insn)[0] = __opcode_to_mem_thumb16(insn >> 16);
-	((u16 *)asi->insn)[1] = __opcode_to_mem_thumb16(insn & 0xffff);
+	insn = asi->insn[0];
+	((u16 *)asi->insn)[0] = insn >> 16;
+	((u16 *)asi->insn)[1] = insn & 0xffff;
 
 	return ret;
 }
@@ -1154,7 +1153,7 @@ t16_decode_hiregs(kprobe_opcode_t insn, struct arch_specific_insn *asi)
 {
 	insn &= ~0x00ff;
 	insn |= 0x001; /* Set Rdn = R1 and Rm = R0 */
-	((u16 *)asi->insn)[0] = __opcode_to_mem_thumb16(insn);
+	((u16 *)asi->insn)[0] = insn;
 	asi->insn_handler = t16_emulate_hiregs;
 	return INSN_GOOD;
 }
@@ -1183,10 +1182,8 @@ t16_decode_push(kprobe_opcode_t insn, struct arch_specific_insn *asi)
 	 * and call it with R9=SP and LR in the register list represented
 	 * by R8.
 	 */
-	/* 1st half STMDB R9!,{} */
-	((u16 *)asi->insn)[0] = __opcode_to_mem_thumb16(0xe929);
-	/* 2nd half (register list) */
-	((u16 *)asi->insn)[1] = __opcode_to_mem_thumb16(insn & 0x1ff);
+	((u16 *)asi->insn)[0] = 0xe929;		/* 1st half STMDB R9!,{} */
+	((u16 *)asi->insn)[1] = insn & 0x1ff;	/* 2nd half (register list) */
 	asi->insn_handler = t16_emulate_push;
 	return INSN_GOOD;
 }
@@ -1235,10 +1232,8 @@ t16_decode_pop(kprobe_opcode_t insn, struct arch_specific_insn *asi)
 	 * and call it with R9=SP and PC in the register list represented
 	 * by R8.
 	 */
-	/* 1st half LDMIA R9!,{} */
-	((u16 *)asi->insn)[0] = __opcode_to_mem_thumb16(0xe8b9);
-	/* 2nd half (register list) */
-	((u16 *)asi->insn)[1] = __opcode_to_mem_thumb16(insn & 0x1ff);
+	((u16 *)asi->insn)[0] = 0xe8b9;		/* 1st half LDMIA R9!,{} */
+	((u16 *)asi->insn)[1] = insn & 0x1ff;	/* 2nd half (register list) */
 	asi->insn_handler = insn & 0x100 ? t16_emulate_pop_pc
 					 : t16_emulate_pop_nopc;
 	return INSN_GOOD;
diff --git a/arch/arm/kernel/kprobes.c b/arch/arm/kernel/kprobes.c
index 49a87b6d0bf3..a7b621ece23d 100644
--- a/arch/arm/kernel/kprobes.c
+++ b/arch/arm/kernel/kprobes.c
@@ -26,7 +26,6 @@
 #include <linux/stop_machine.h>
 #include <linux/stringify.h>
 #include <asm/traps.h>
-#include <asm/opcodes.h>
 #include <asm/cacheflush.h>
 
 #include "kprobes.h"
@@ -63,10 +62,10 @@ int __kprobes arch_prepare_kprobe(struct kprobe *p)
 #ifdef CONFIG_THUMB2_KERNEL
 	thumb = true;
 	addr &= ~1; /* Bit 0 would normally be set to indicate Thumb code */
-	insn = __mem_to_opcode_thumb16(((u16 *)addr)[0]);
+	insn = ((u16 *)addr)[0];
 	if (is_wide_instruction(insn)) {
-		u16 inst2 = __mem_to_opcode_thumb16(((u16 *)addr)[1]);
-		insn = __opcode_thumb32_compose(insn, inst2);
+		insn <<= 16;
+		insn |= ((u16 *)addr)[1];
 		decode_insn = thumb32_kprobe_decode_insn;
 	} else
 		decode_insn = thumb16_kprobe_decode_insn;
@@ -74,7 +73,7 @@ int __kprobes arch_prepare_kprobe(struct kprobe *p)
 	thumb = false;
 	if (addr & 0x3)
 		return -EINVAL;
-	insn = __mem_to_opcode_arm(*p->addr);
+	insn = *p->addr;
 	decode_insn = arm_kprobe_decode_insn;
 #endif
 
-- 
2.1.2

