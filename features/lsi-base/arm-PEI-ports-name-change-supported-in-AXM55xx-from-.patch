From e71d001b1d2cd7f1df159fbae5de284546997382 Mon Sep 17 00:00:00 2001
From: SangeethaRao <sangeetha.rao@lsi.com>
Date: Fri, 10 May 2013 16:07:13 -0700
Subject: [PATCH 052/159] arm: PEI ports name change supported in AXM55xx from
 PEI2 to PEI1.

git.yoctoproject.org/git/linux-yocto-3.10
commit b18eb1aa445cc43d345e67c2f952c9ff1fe067a1 standard/axxia/base.

Also, fixed compile time warnings and removed legacy interrupt coder
for endpoint interrupts.

Signed-off-by: SangeethaRao <sangeetha.rao@lsi.com>
---
 arch/arm/boot/dts/axm55xxsim.dts |   38 +----------
 arch/arm/mach-axxia/pci.c        |  145 ++++++++++---------------------------
 2 files changed, 40 insertions(+), 143 deletions(-)

diff --git a/arch/arm/boot/dts/axm55xxsim.dts b/arch/arm/boot/dts/axm55xxsim.dts
index 1fc63c1..ac1fa92 100644
--- a/arch/arm/boot/dts/axm55xxsim.dts
+++ b/arch/arm/boot/dts/axm55xxsim.dts
@@ -321,7 +321,7 @@
                 >;
         };
 
-        PCIE1: pciex@0x3040000000 {
+        PCIE1: pciex@0x3080000000 {
                 compatible = "lsi,plb-pciex";
                 device_type = "pci";
                 enabled = <0>;
@@ -332,42 +332,6 @@
                 #size-cells = <2>;
                 #address-cells = <3>;
                 /* config space access MPAGE7 registers*/
-                reg = <0x30 0x78000000 0x0 0x01000000
-                       0x20 0x20128000 0x0 0x00008000 >;
-                bus-range = <0 0x0f>;
-                /* Outbound ranges */
-                /* < <3-cell PCI addr> <2-cell CPU (PLB) addr> <2-cell size> > */
-                ranges = <0x03000000 0x00000000 0xa0000000
-                          0x30 0x40000000
-                          0x00 0x10000000>;
-                /* Inbound ranges */
-                /* < <3-cell PCI addr> <2-cell CPU addr> <2-cell size> > */
-                dma-ranges = <0x03000000 0x00000000 0x00000000
-                             0x00 0x00000000
-                              0x00 0x40000000>;
-                interrupt-parent = <&gic>;
-                interrupts = <72 2>;
-                interrupt-map-mask = <0000 0 0 7>;
-                interrupt-map = <
-                        /* <3-cell dev> <irq#> <prnt> <2-cell prnt IRQ/sense> */
-                        0000 0 0 1 &gic 72 2
-                        0000 0 0 2 &gic 72 2
-                        0000 0 0 3 &gic 72 2
-                        0000 0 0 4 &gic 72 2
-                >;
-        };
-
-        PCIE2: pciex@0x3080000000 {
-                compatible = "lsi,plb-pciex";
-                device_type = "pci";
-                enabled = <0>;
-                plx = <0>;
-                primary;
-                port = <2>;
-                #interrupt-cells = <1>;
-                #size-cells = <2>;
-                #address-cells = <3>;
-                /* config space access MPAGE7 registers*/
                 reg = <0x30 0xb8000000 0x0 0x01000000
                        0x20 0x20130000 0x0 0x00008000 >;
                 bus-range = <0 0x0f>;
diff --git a/arch/arm/mach-axxia/pci.c b/arch/arm/mach-axxia/pci.c
index c1d930d..2e159e7 100644
--- a/arch/arm/mach-axxia/pci.c
+++ b/arch/arm/mach-axxia/pci.c
@@ -27,8 +27,6 @@
 
 #include <linux/msi.h>
 
-#define AXXIA55xx_NUM_MSI_IRQS 256
-
 #undef PRINT_CONFIG_ACCESSES
 /*#define PRINT_CONFIG_ACCESSES*/
 
@@ -57,7 +55,7 @@ struct axxia_pciex_port {
 };
 
 static struct axxia_pciex_port *axxia_pciex_ports;
-static unsigned int axxia_pciex_port_count = 3;
+static unsigned int axxia_pciex_port_count = 2;
 
 static void axxia_probe_pciex_bridge(struct device_node *np);
 
@@ -72,8 +70,8 @@ fixup_axxia_pci_bridge(struct pci_dev *dev)
 	 * Set the class appropriately for a bridge device
 	 */
 	printk(KERN_INFO
-	       "PCI: Setting PCI Class to PCI_CLASS_BRIDGE_HOST for %04x:%04x\n",
-	       dev->vendor, dev->device);
+	       "PCI: Setting PCI Class to PCI_CLASS_BRIDGE_HOST for "
+		"%04x:%04x\n", dev->vendor, dev->device);
 	dev->class = PCI_CLASS_BRIDGE_HOST << 8;
 	/*
 	 * Make the bridge transparent
@@ -238,7 +236,8 @@ arm_pciex_axxia_read_config(struct pci_bus *bus, unsigned int devfn,
 
 #ifdef PRINT_CONFIG_ACCESSES
 	printk(KERN_INFO
-		"acp_read_config for PEI%d: %3d  fn=0x%04x o=0x%04x l=%d a=0x%08x v=0x%08x, dev=%d\n",
+		"acp_read_config for PEI%d: %3d  fn=0x%04x o=0x%04x l=%d "
+		"a=0x%08x v=0x%08x, dev=%d\n",
 			port->index, bus->number, devfn, offset, len,
 			bus_addr, *val, PCI_SLOT(devfn));
 #endif
@@ -297,7 +296,8 @@ static int arm_pciex_axxia_write_config(struct pci_bus *bus, unsigned int devfn,
 
 #ifdef PRINT_CONFIG_ACCESSES
 	printk(KERN_INFO
-		"acp_write_config: bus=%3d devfn=0x%04x offset=0x%04x len=%d addr=0x%08x val=0x%08x\n",
+		"acp_write_config: bus=%3d devfn=0x%04x offset=0x%04x len=%d"
+		"addr=0x%08x val=0x%08x\n",
 		bus->number, devfn, offset, len, bus_addr, val);
 #endif
 
@@ -325,8 +325,6 @@ static irqreturn_t
 acp_pcie_isr(int irq, void *arg)
 {
 	u32 intr_status;
-	u32 msg_fifo_stat;
-	u32 msg_fifo_info;
 	u8  externalPciIntr = 0;
 	struct axxia_pciex_port *port = (struct axxia_pciex_port *)arg;
 	void __iomem *mbase = (void __iomem *)port->cfg_addr;
@@ -334,72 +332,8 @@ acp_pcie_isr(int irq, void *arg)
 	/* read the PEI interrupt status register */
 	intr_status = readl(mbase+0x10c0);
 
-	/* check if this is a PCIe message from an external device */
-	if (intr_status & 0x00000010) {
-		externalPciIntr = 1;
-
-		msg_fifo_stat = readl(mbase+0x10b4);
-
-		/* loop until the message fifo is empty */
-		while ((msg_fifo_stat & 0x01) == 0)  {
-			u8 bus, dev, fn;
-			u8 msg_type;
-			msg_fifo_info = readl(mbase+0x10b0);
-
-			bus = (msg_fifo_info >> 16) & 0xff;
-			dev = (msg_fifo_info >> 11) & 0x1f;
-			fn  = (msg_fifo_info >>  8) & 0x07;
-			msg_type = msg_fifo_info & 0xff;
-
-			/* print out the BDF and message type.
-			 * We ignore the common message types.
-			 */
-			switch (msg_type) {
-			case 0x20:  /*    assert_INTa */
-				printk(KERN_INFO "PEI%d --> INTa asserted\n",
-					port->index);
-				break;
-			case 0x21:  /*    assert_INTb */
-				printk(KERN_INFO "PEI%d --> INTb asserted\n",
-					port->index);
-				break;
-			case 0x22:  /*    assert_INTc */
-				printk(KERN_INFO "PEI%d --> INTc asserted\n",
-					port->index);
-				break;
-			case 0x23:  /*    assert_INTd */
-				printk(KERN_INFO "PEI%d --> INTd asserted\n",
-					port->index);
-				break;
-			case 0x24:  /* de-assert_INTa */
-				printk(KERN_INFO "PEI%d --> INTa de-asserted\n",
-					port->index);
-				break;
-			case 0x25:  /* de-assert_INTb */
-				printk(KERN_INFO "PEI%d --> INTb de-asserted\n",
-					port->index);
-				break;
-			case 0x26:  /* de-assert_INTc */
-				printk(KERN_INFO "PEI%d --> INTc de-asserted\n",
-					port->index);
-				break;
-			case 0x27:  /* de-assert_INTd */
-				printk(KERN_INFO "PEI%d --> INTd de-asserted\n",
-					port->index);
-				break;
-			default:
-				printk(KERN_INFO "BDF %02x:%02x.%x sent msgtype 0x%02x\n",
-						bus, dev, fn, msg_type);
-				break;
-			}
-
-			/* re-read fifo status */
-			msg_fifo_stat = readl(mbase+0x10b4);
-		}
-	} else {
-		/* Ignore the common interrupts, still need to figure out what
-		 * they all mean.*/
-		if (intr_status & 0xf3ffffab) {
+	/* check if this is a PCIe message not from an external device */
+	if (intr_status & 0xf3ffffab) {
 			u32 t2a_err_stat;
 			u32 t2a_other_err_stat;
 			u32 int_enb;
@@ -407,8 +341,8 @@ acp_pcie_isr(int irq, void *arg)
 			u32 offset;
 
 			printk(KERN_ERR
-				"ACP_PCIE_ISR: got PEI%d error interrupt 0x%08x\n",
-				intr_status, port->index);
+				"ACP_PCIE_ISR: got PEI%d error interrupt "
+				"0x%08x\n", intr_status, port->index);
 
 			linkStatus = readl(mbase+0x117c);
 			printk(KERN_ERR "link_status (0x117c) = 0x%08x\n",
@@ -449,7 +383,6 @@ acp_pcie_isr(int irq, void *arg)
 				printk(KERN_INFO "  0x%04x : 0x%08x\n", offset,
 					readl(mbase + offset));
 			}
-		}
 	}
 
 	/*
@@ -508,9 +441,7 @@ int axxia_pcie_setup(int portno, struct pci_sys_data *sys)
 	int i, num_pages, err;
 	u32 mpage_lower, pciah, pcial;
 	u64 size, bar0_size;
-	void __iomem *cfg_addr = NULL;
-	void __iomem *cfg_data = NULL;
-	void __iomem *tpage_base;
+	void __iomem *cfg_addr = NULL, *cfg_data = NULL, *tpage_base = NULL;
 	int mappedIrq;
 	u32 inbound_size;
 
@@ -556,7 +487,7 @@ int axxia_pcie_setup(int portno, struct pci_sys_data *sys)
 		goto fail;
 	}
 	port->cfg_addr = cfg_addr;
-	printk(KERN_INFO "cfg_addr for port %d = 0x%8x\n", port->index,
+	printk("cfg_addr for port %d = 0x%8x\n", port->index,
 		(unsigned int)port->cfg_addr);
 	pci_config = readl(cfg_addr);
 #ifdef PRINT_CONFIG_ACCESSES
@@ -570,8 +501,8 @@ int axxia_pcie_setup(int portno, struct pci_sys_data *sys)
 	if (sys->domain == 0) {
 		/* IRQ# 68 for PEI0 */
 		mappedIrq = 100;
-	} else if (sys->domain == 2) {
-		/* IRQ# 70 for PEI2 */
+	} else if (sys->domain == 1) {
+		/* IRQ# 70 for PEI1 */
 		mappedIrq = 102;
 	}
 	printk(KERN_INFO "Requesting irq#%d for PEI%d Legacy INTs\n",
@@ -595,8 +526,8 @@ int axxia_pcie_setup(int portno, struct pci_sys_data *sys)
 				IRQF_SHARED, "acp_pcie_MSI", port);
 			if (err) {
 				printk(KERN_ERR
-					"request_irq failed!!!! for IRQ# %d err = %d\n",
-					mappedIrq+32, err);
+				"request_irq failed!!!! for IRQ# %d err = %d\n",
+				mappedIrq+32, err);
 				goto fail;
 			}
 		}
@@ -721,7 +652,7 @@ axxia_pcie_scan_bus(int nr, struct pci_sys_data *sys)
 			&axxia_pciex_pci_ops, sys, &sys->resources);
 	} else {
 		bus = NULL;
-		BUG();
+		printk(KERN_WARNING "PCIE: exceeded number of supported PEI ports\n");
 	}
 
 	return bus;
@@ -762,7 +693,8 @@ static void __devinit axxia_pcie_msi_enable(struct pci_dev *dev)
 					1024, &(port->msi_phys), GFP_KERNEL);
 			} else {
 				printk(KERN_INFO
-					"No suitable DMA available. MSI cannot be supported\n");
+					"No suitable DMA available. MSI cannot"
+					"be supported\n");
 				return;
 			}
 			msi_lower = (u32)port->msi_phys;
@@ -777,7 +709,9 @@ static void __devinit axxia_pcie_msi_enable(struct pci_dev *dev)
 		bus_num = dev->bus->number;
 
 		printk(KERN_INFO
-			"PEI%d axxia_pcie_msi_enable Found MSI%d, msi_lower = 0x%x for bus_num = %d, dev = %d, fn = %d\n",
+			"PEI%d axxia_pcie_msi_enable Found MSI%d"
+			", msi_lower = 0x%x"
+			"for bus_num = %d, dev = %d, fn = %d\n",
 			port->index, msi_count, msi_lower,
 			bus_num, device, fn);
 		pci_write_config_dword(dev, pos + PCI_MSI_ADDRESS_LO,
@@ -803,7 +737,7 @@ DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, axxia_pcie_msi_enable);
 
 /* Port definition struct
  * Please note: PEI core#1 is not used in AXM5500 */
-static struct hw_pci __refdata axxia_pcie_hw[] = {
+static struct hw_pci axxia_pcie_hw[] = {
 	[0] = {
 		.nr_controllers = 1,
 		.domain = 0,
@@ -812,12 +746,8 @@ static struct hw_pci __refdata axxia_pcie_hw[] = {
 		.scan = axxia_pcie_scan_bus
 	},
 	[1] = {
-		.nr_controllers = 0,
-		.domain = 1
-	},
-	[2] = {
 		.nr_controllers = 1,
-		.domain = 2,
+		.domain = 1,
 		.swizzle = pci_std_swizzle,
 		.setup = axxia_pcie_setup,
 		.scan = axxia_pcie_scan_bus
@@ -828,6 +758,8 @@ static struct hw_pci __refdata axxia_pcie_hw[] = {
 void __init axxia_pcie_init(void)
 {
 	struct device_node *np;
+	int found_a_port = 0;
+
 	/* allocate memory */
 	axxia_pciex_ports = kzalloc(axxia_pciex_port_count
 		* sizeof(struct axxia_pciex_port), GFP_KERNEL);
@@ -836,12 +768,16 @@ void __init axxia_pcie_init(void)
 		printk(KERN_WARNING "PCIE: failed to allocate ports array\n");
 		return;
 	}
-	for_each_compatible_node(np, NULL, "lsi,plb-pciex")
+
+	for_each_compatible_node(np, NULL, "lsi,plb-pciex") {
+		++found_a_port;
 		axxia_probe_pciex_bridge(np);
+	}
 
-	pci_common_init(&axxia_pcie_hw[0]);
-	pci_common_init(&axxia_pcie_hw[1]);
-	pci_common_init(&axxia_pcie_hw[2]);
+	if (0 != found_a_port) {
+		pci_common_init(&axxia_pcie_hw[0]);
+		pci_common_init(&axxia_pcie_hw[1]);
+	}
 
 	return;
 }
@@ -856,16 +792,12 @@ static void axxia_probe_pciex_bridge(struct device_node *np)
 	int rlen;
 	int pna = of_n_addr_cells(np);
 	int num = pna + 5;
-	u64 size;
-	u64 pci_addr;
+	u64 size, pci_addr;
 
 	/* Get the port number from the device-tree */
 	if (!of_property_read_u32(np, "port", &pval)) {
 		portno = pval;
-		if (portno == 1) {
-			/* only PCIe0 and PCIe2 are supported in AXM5500 */
-			return;
-		}
+
 		printk(KERN_INFO "PCIE Port %d found\n", portno);
 	} else {
 		printk(KERN_ERR "PCIE: Can't find port number for %s\n",
@@ -957,7 +889,8 @@ static void axxia_probe_pciex_bridge(struct device_node *np)
 		 */
 		if (cpu_addr != 0 || pci_addr > 0xffffffff) {
 			printk(KERN_WARNING
-			       "%s: Ignored unsupported dma range 0x%016llx...0x%016llx -> 0x%016llx\n",
+			       "%s: Ignored unsupported dma range"
+					"0x%016llx...0x%016llx -> 0x%016llx\n",
 				np->full_name, pci_addr,
 				pci_addr + size - 1, cpu_addr);
 			continue;
-- 
1.7.5.4

