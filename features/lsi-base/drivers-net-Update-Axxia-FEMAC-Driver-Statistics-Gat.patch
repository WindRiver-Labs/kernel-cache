From e685c3d51197664728f56f1e5eaafa0f0688b2fa Mon Sep 17 00:00:00 2001
From: John Jacques <john.jacques@intel.com>
Date: Wed, 7 Dec 2016 13:24:29 +0800
Subject: [PATCH 2/2] drivers/net: Update Axxia FEMAC Driver Statistics
 Gathering

commit daacab0d92853601533d531d317c50c1648931a8 from
http://git.yoctoproject.org/cgit/cgit.cgi/linux-yocto-4.1
branch: standard/axxia/base

Some errors were getting counted multiple times.

Signed-off-by: John Jacques <john.jacques@intel.com>
Signed-off-by: Zhixiong Chi <zhixiong.chi@windriver.com>
---
 drivers/net/ethernet/lsi/lsi_acp_net.c |   74 +++++++++++++++++---------------
 1 files changed, 39 insertions(+), 35 deletions(-)

diff --git a/drivers/net/ethernet/lsi/lsi_acp_net.c b/drivers/net/ethernet/lsi/lsi_acp_net.c
index 67bd0cf..dff523d 100644
--- a/drivers/net/ethernet/lsi/lsi_acp_net.c
+++ b/drivers/net/ethernet/lsi/lsi_acp_net.c
@@ -472,6 +472,9 @@ static void clear_statistics(struct appnic_device *pdata)
 static void get_hw_statistics(struct appnic_device *pdata)
 {
 	unsigned long flags;
+	u32 rx_under;
+	u32 rx_over;
+	u32 tx_under;
 
 	/* stats.tx_packets */
 	pdata->stats.tx_packets += read_mac(APPNIC_TX_STAT_PACKET_OK);
@@ -484,14 +487,17 @@ static void get_hw_statistics(struct appnic_device *pdata)
 	pdata->stats.collisions +=
 		read_mac(APPNIC_TX_STATUS_EXCESSIVE_COLLISION);
 	pdata->stats.collisions +=
-	read_mac(APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK);
+		read_mac(APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK);
 
 	/* stats.rx_length_errors */
-	pdata->stats.rx_length_errors += read_mac(APPNIC_RX_STAT_UNDERSIZE);
-	pdata->stats.rx_length_errors += read_mac(APPNIC_RX_STAT_OVERSIZE);
+	rx_under = read_mac(APPNIC_RX_STAT_UNDERSIZE);
+	pdata->stats.rx_length_errors += rx_under;
+	rx_over = read_mac(APPNIC_RX_STAT_OVERSIZE);
+	pdata->stats.rx_length_errors += rx_over;
 
 	/* stats.tx_fifo_errors */
-	pdata->stats.tx_fifo_errors += read_mac(APPNIC_TX_STAT_UNDERRUN);
+	tx_under = read_mac(APPNIC_TX_STAT_UNDERRUN);
+	pdata->stats.tx_fifo_errors += tx_under;
 
 	/* Lock this section out so the statistics maintained by the driver
 	 * don't get clobbered.
@@ -499,21 +505,17 @@ static void get_hw_statistics(struct appnic_device *pdata)
 
 	spin_lock_irqsave(&pdata->dev_lock, flags);
 
-	pdata->stats.rx_errors +=
-		(pdata->stats.rx_length_errors +
-		 pdata->stats.rx_crc_errors +
-		 pdata->stats.rx_frame_errors +
-		 pdata->stats.rx_fifo_errors +
-		 pdata->stats.rx_dropped +
-		 pdata->stats.rx_over_errors);
-
 	pdata->stats.rx_dropped = 0;
 	pdata->stats.rx_over_errors = 0;
 
-	pdata->stats.tx_errors += (pdata->stats.tx_fifo_errors +
-				   pdata->stats.tx_aborted_errors);
+	/* Update the cumulative rx_errors. */
+	pdata->stats.rx_errors += (rx_under + rx_over);
+
 	pdata->stats.tx_aborted_errors = 0;
 
+	/* Update the cumulative tx_errors. */
+	pdata->stats.tx_errors += tx_under;
+
 	spin_unlock_irqrestore(&pdata->dev_lock, flags);
 
 	return;
@@ -795,30 +797,32 @@ static void lsinet_rx_packet(struct net_device *dev)
 		BUG();
 		dev_kfree_skb(sk_buff);
 
-	} else {
-		if (0 == error_num) {
-			struct ethhdr *ethhdr = (struct ethhdr *) sk_buff->data;
-			if (mac_addr_valid(dev, &ethhdr->h_dest[0])) {
-				pdata->stats.rx_bytes += bytes_copied;
-				pdata->stats.rx_packets++;
-				sk_buff->dev = dev;
-				sk_buff->protocol = eth_type_trans(sk_buff,
-								   dev);
-				if (netif_receive_skb(sk_buff) == NET_RX_DROP)
-					pdata->dropped_by_stack++;
-			} else {
-				dev_kfree_skb(sk_buff);
-			}
+	} else if (0 == error_num) {
+		struct ethhdr *ethhdr = (struct ethhdr *)sk_buff->data;
+
+		if (mac_addr_valid(dev, &ethhdr->h_dest[0])) {
+			pdata->stats.rx_bytes += bytes_copied;
+			++pdata->stats.rx_packets;
+			sk_buff->dev = dev;
+			sk_buff->protocol = eth_type_trans(sk_buff, dev);
+
+			if (netif_receive_skb(sk_buff) == NET_RX_DROP)
+				++pdata->dropped_by_stack;
 		} else {
 			dev_kfree_skb(sk_buff);
-
-			if (0 != overflow_stat)
-				pdata->stats.rx_fifo_errors++;
-			else if (0 != crc_stat)
-				pdata->stats.rx_crc_errors++;
-			else if (0 != align_stat)
-				pdata->stats.rx_frame_errors++;
 		}
+	} else {
+		dev_kfree_skb(sk_buff);
+
+		pdata->stats.rx_errors +=
+			(overflow_stat + crc_stat + align_stat);
+
+		if (0 != overflow_stat)
+			pdata->stats.rx_fifo_errors += overflow_stat;
+		else if (0 != crc_stat)
+			pdata->stats.rx_crc_errors += crc_stat;
+		else if (0 != align_stat)
+			pdata->stats.rx_frame_errors += align_stat;
 	}
 
 	return;
-- 
1.7.5.4

