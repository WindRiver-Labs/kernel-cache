From 77640b46ac293cec84da6f52d9601f347d3b54dc Mon Sep 17 00:00:00 2001
From: Charlie Paul <cpaul.windriver@gmail.com>
Date: Thu, 11 Jun 2015 16:46:59 +0300
Subject: [PATCH 20/82] arm/axxia/vmfs fixed vmfs compile and run errors

commit 77640b46ac293cec84da6f52d9601f347d3b54dc from
git://git.yoctoproject.org/linux-yocto-3.14

The VMFS was not compiling or running. The VMFS was fixed
using the working version of VMFS in LSI 3.18 kernel.

Signed-off-by: Charlie Paul <cpaul.windriver@gmail.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 fs/vmfs/cache.c   | 10 +++++-----
 fs/vmfs/dir.c     | 33 ++++++++++-----------------------
 fs/vmfs/file.c    | 17 ++++++-----------
 fs/vmfs/inode.c   | 31 ++++++++++++++++++-------------
 fs/vmfs/ioctl.c   |  8 --------
 fs/vmfs/proc.c    |  6 +++---
 fs/vmfs/proto.h   |  2 +-
 fs/vmfs/vmfs_fs.h |  2 +-
 8 files changed, 44 insertions(+), 65 deletions(-)

diff --git a/fs/vmfs/cache.c b/fs/vmfs/cache.c
index 23fbf36..8b09098 100644
--- a/fs/vmfs/cache.c
+++ b/fs/vmfs/cache.c
@@ -140,7 +140,7 @@ out_unlock:
  * Create dentry/inode for this file and add it to the dircache.
  */
 int
-vmfs_fill_cache(struct file *filp, void *dirent, filldir_t filldir,
+vmfs_fill_cache(struct file *filp, struct dir_context *dirent,
 		struct vmfs_cache_control *ctrl, struct qstr *qname,
 		struct vmfs_fattr *entry)
 {
@@ -216,13 +216,13 @@ vmfs_fill_cache(struct file *filp, void *dirent, filldir_t filldir,
 end_advance:
 	if (!valid)
 		ctl.valid = 0;
-	if (!ctl.filled && (ctl.fpos == filp->f_pos)) {
+	if (!ctl.filled && (ctl.fpos == dirent->pos)) {
 		if (!ino)
 			ino = iunique(inode->i_sb, 2);
-		ctl.filled = filldir(dirent, qname->name, qname->len,
-				     filp->f_pos, ino, DT_UNKNOWN);
+		ctl.filled = !dir_emit(dirent, qname->name, qname->len,
+				ino, DT_UNKNOWN);
 		if (!ctl.filled)
-			filp->f_pos += 1;
+			dirent->pos += 1;
 	}
 	ctl.fpos += 1;
 	ctl.idx += 1;
diff --git a/fs/vmfs/dir.c b/fs/vmfs/dir.c
index ccda867..ad7989d 100644
--- a/fs/vmfs/dir.c
+++ b/fs/vmfs/dir.c
@@ -24,7 +24,6 @@
 #include "vmfs_debug.h"
 #include "proto.h"
 
-/* ORIG - TBD static int vmfs_readdir(struct file *, void *, filldir_t); */
 static int vmfs_readdir(struct file *, struct dir_context *ctx);
 static int vmfs_dir_open(struct inode *, struct file *);
 
@@ -78,11 +77,9 @@ const struct inode_operations vmfs_dir_inode_operations_unix = {
  *
  * The cache code is almost directly taken from ncpfs
  */
-/* ORIG - TBD static int vmfs_readdir(struct file *filp, void *dirent, filldir_t filldir) */
 static int vmfs_readdir(struct file *filp, struct dir_context *ctx)
 {
 	int result;
-#if 0 /* Needs to be ported */
 	struct dentry *dentry = filp->f_path.dentry;
 	struct inode *dir = dentry->d_inode;
 	struct vmfs_sb_info *server = server_from_dentry(dentry);
@@ -100,17 +97,8 @@ static int vmfs_readdir(struct file *filp, struct dir_context *ctx)
 
 	mutex_lock(&vmfs_mutex);
 
-	switch ((unsigned int)filp->f_pos) {
-	case 0:
-		if (filldir(dirent, ".", 1, 0, dir->i_ino, DT_DIR) < 0)
-			goto out;
-		filp->f_pos = 1;
-		/* fallthrough */
-	case 1:
-	       if (filldir(dirent, "..", 2, 1, parent_ino(dentry), DT_DIR) < 0)
-			goto out;
-		filp->f_pos = 2;
-	}
+	if (!dir_emit_dots(filp, ctx))
+		return 0;
 
 	/*
 	 * Make sure our inode is up-to-date.
@@ -132,7 +120,7 @@ static int vmfs_readdir(struct file *filp, struct dir_context *ctx)
 		goto init_cache;
 	}
 
-	if (filp->f_pos == 2) {
+	if (ctx->pos == 2) {
 		if (jiffies - ctl.head.time >= VMFS_MAX_AGE(server))
 			goto init_cache;
 
@@ -147,10 +135,10 @@ static int vmfs_readdir(struct file *filp, struct dir_context *ctx)
 		 */
 	}
 
-	if (filp->f_pos > ctl.head.end)
+	if (ctx->pos > ctl.head.end)
 		goto finished;
 
-	ctl.fpos = filp->f_pos + (VMFS_DIRCACHE_START - 2);
+	ctl.fpos = ctx->pos + (VMFS_DIRCACHE_START - 2);
 	ctl.ofs = ctl.fpos / VMFS_DIRCACHE_SIZE;
 	ctl.idx = ctl.fpos % VMFS_DIRCACHE_SIZE;
 
@@ -172,15 +160,15 @@ static int vmfs_readdir(struct file *filp, struct dir_context *ctx)
 			if (!dent)
 				goto invalid_cache;
 
-			res = filldir(dirent, dent->d_name.name,
-				      dent->d_name.len, filp->f_pos,
+			res = !dir_emit(ctx, dent->d_name.name,
+					dent->d_name.len,
 				      dent->d_inode->i_ino, DT_UNKNOWN);
 			dput(dent);
 			if (res)
 				goto finished;
-			filp->f_pos += 1;
+			ctx->pos += 1;
 			ctl.idx += 1;
-			if (filp->f_pos > ctl.head.end)
+			if (ctx->pos > ctl.head.end)
 				goto finished;
 		}
 		if (ctl.page) {
@@ -211,7 +199,7 @@ init_cache:
 	ctl.filled = 0;
 	ctl.valid = 1;
 read_really:
-	result = server->ops->readdir(filp, dirent, filldir, &ctl);
+	result = server->ops->readdir(filp, ctx, &ctl);
 	if (result == -ERESTARTSYS && page)
 		ClearPageUptodate(page);
 	if (ctl.idx == -1)
@@ -235,7 +223,6 @@ finished:
 	}
 out:
 	mutex_unlock(&vmfs_mutex);
-#endif
 	return result;
 }
 
diff --git a/fs/vmfs/file.c b/fs/vmfs/file.c
index b80bac0..6e9030a 100644
--- a/fs/vmfs/file.c
+++ b/fs/vmfs/file.c
@@ -19,7 +19,7 @@
 #include <linux/aio.h>
 
 #include <linux/uaccess.h>
-#include <asm/system.h>
+/* #include <asm/system.h> */
 #include <linux/version.h>
 
 #include "vmfsno.h"
@@ -381,17 +381,12 @@ vmfs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 	if (result)
 		goto out;
 
-	if (iocb->ki_left > 0) {
-		DEBUG1("1\n");
+	result = generic_file_aio_write(iocb, iov, nr_segs, pos);
+	VERBOSE("pos=%ld, size=%ld, mtime=%ld, atime=%ld\n",
+		(long)file->f_pos, (long)dentry->d_inode->i_size,
+		dentry->d_inode->i_mtime.tv_sec,
+		dentry->d_inode->i_atime.tv_sec);
 
-		result = generic_file_aio_write(iocb, iov, nr_segs, pos);
-		VERBOSE("pos=%ld, size=%ld, mtime=%ld, atime=%ld\n",
-			(long)file->f_pos, (long)dentry->d_inode->i_size,
-			dentry->d_inode->i_mtime.tv_sec,
-			dentry->d_inode->i_atime.tv_sec);
-
-		DEBUG1("2\n");
-	}
 out:
 	DEBUG1("return\n");
 	return result;
diff --git a/fs/vmfs/inode.c b/fs/vmfs/inode.c
index 492dc8a..63d1dcb 100644
--- a/fs/vmfs/inode.c
+++ b/fs/vmfs/inode.c
@@ -26,6 +26,8 @@
 #include <linux/highuid.h>
 #include <linux/sched.h>
 #include <linux/version.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 #include "vmfs_fs.h"
 #include "vmfsno.h"
 #include "vmfs_mount.h"
@@ -326,6 +328,7 @@ static void vmfs_delete_inode(struct inode *ino)
 {
 	DEBUG1("ino=%ld\n", ino->i_ino);
 	truncate_inode_pages(&ino->i_data, 0);
+	clear_inode(ino);
 	mutex_lock(&vmfs_mutex);
 	if (vmfs_close(ino))
 		PARANOIA("could not close inode %ld\n", ino->i_ino);
@@ -486,25 +489,13 @@ int vmfs_notify_change(struct dentry *dentry, struct iattr *attr)
 		goto out;
 
 	error = -EPERM;
-#ifdef CONFIG_UIDGID_STRICT_TYPE_CHECKS
 	if ((attr->ia_valid & ATTR_UID) &&
 	    (attr->ia_uid.val != (server->mnt->uid).val))
 		goto out;
-#else
-	if ((attr->ia_valid & ATTR_UID) &&
-	    (attr->ia_uid != server->mnt->uid))
-		goto out;
-#endif
 
-#ifdef CONFIG_UIDGID_STRICT_TYPE_CHECKS
 	if ((attr->ia_valid & ATTR_GID) &&
 	    ((attr->ia_gid).val != (server->mnt->gid).val))
 		goto out;
-#else
-	if ((attr->ia_valid & ATTR_GID) &&
-	    (attr->ia_gid != server->mnt->gid))
-		goto out;
-#endif
 
 	if ((attr->ia_valid & ATTR_MODE) && (attr->ia_mode & ~mask))
 		goto out;
@@ -616,6 +607,8 @@ static struct file_system_type vmfs_fs_type = {
 
 static int __init init_vmfs_fs(void)
 {
+	phys_addr_t dev_base = CONFIG_VMFS_DEV_BASE;
+	uint32_t dev_irq = -1;
 	int err;
 	DEBUG1("registering ...\n");
 
@@ -623,9 +616,21 @@ static int __init init_vmfs_fs(void)
 	if (err)
 		goto out_inode;
 
+	if (IS_ENABLED(CONFIG_OF)) {
+		struct device_node *np;
+
+		np = of_find_compatible_node(NULL, NULL, "arm,messagebox");
+		if (np) {
+			struct resource res;
+
+			if (of_address_to_resource(np, 0, &res) == 0)
+				dev_base = res.start;
+		}
+	}
+
 	/* map the message box device into memory */
 
-	mbox = mb_new(CONFIG_VMFS_DEV_BASE, CONFIG_VMFS_IRQ);
+	mbox = mb_new(dev_base, dev_irq);
 
 	if (mbox == NULL) {
 		err = -1;
diff --git a/fs/vmfs/ioctl.c b/fs/vmfs/ioctl.c
index baec528..ece7ad8 100644
--- a/fs/vmfs/ioctl.c
+++ b/fs/vmfs/ioctl.c
@@ -34,19 +34,11 @@ long vmfs_unlocked_ioctl(struct file *filp, unsigned int cmd,
 		uid16_t uid16;
 		uid_t uid32;
 	case VMFS_IOC_GETMOUNTUID:
-#ifdef CONFIG_UIDGID_STRICT_TYPE_CHECKS
 		SET_UID(uid16, (server->mnt->mounted_uid).val);
-#else
-		SET_UID(uid16, server->mnt->mounted_uid);
-#endif
 		result = put_user(uid16, (uid16_t __user *) arg);
 		break;
 	case VMFS_IOC_GETMOUNTUID32:
-#ifdef CONFIG_UIDGID_STRICT_TYPE_CHECKS
 		SET_UID(uid32, (server->mnt->mounted_uid).val);
-#else
-		SET_UID(uid32, server->mnt->mounted_uid);
-#endif
 		result = put_user(uid32, (uid_t __user *) arg);
 		break;
 	default:
diff --git a/fs/vmfs/proc.c b/fs/vmfs/proc.c
index 7866391..07e3256 100644
--- a/fs/vmfs/proc.c
+++ b/fs/vmfs/proc.c
@@ -25,7 +25,7 @@
 #include "vmfsno.h"
 #include "vmfs_mount.h"
 
-#include <asm/string.h>
+#include <linux/string.h>
 #include <asm/div64.h>
 
 #include "vmfs_debug.h"
@@ -688,7 +688,7 @@ vmfs_init_root_dirent(struct vmfs_sb_info *server, struct vmfs_fattr *fattr,
  * read in directory entries into the dentry cache
  */
 static int
-vmfs_proc_readdir_long(struct file *filp, void *dirent, filldir_t filldir,
+vmfs_proc_readdir_long(struct file *filp, void *dirent,
 		       struct vmfs_cache_control *ctl)
 {
 	struct dentry *dir = filp->f_path.dentry;
@@ -793,7 +793,7 @@ vmfs_proc_readdir_long(struct file *filp, void *dirent, filldir_t filldir,
 		vmfs_finish_dirent(server, &fattr);
 
 		if (!vmfs_fill_cache
-		    (filp, dirent, filldir, ctl, &qname, &fattr)) {
+				(filp, dirent, ctl, &qname, &fattr)) {
 			/* smbfs carries on here... */
 		}
 	}
diff --git a/fs/vmfs/proto.h b/fs/vmfs/proto.h
index 01ea8ed..e02803d 100644
--- a/fs/vmfs/proto.h
+++ b/fs/vmfs/proto.h
@@ -40,7 +40,7 @@ extern const struct inode_operations vmfs_dir_inode_operations_unix;
 extern void vmfs_new_dentry(struct dentry *dentry);
 extern void vmfs_renew_times(struct dentry *dentry);
 /* cache.c */
-extern int vmfs_fill_cache(struct file *filp, void *dirent, filldir_t filldir,
+extern int vmfs_fill_cache(struct file *filp, struct dir_context *dirent,
 			   struct vmfs_cache_control *ctrl, struct qstr *qname,
 			   struct vmfs_fattr *entry);
 extern void vmfs_invalid_dir_cache(struct inode *dir);
diff --git a/fs/vmfs/vmfs_fs.h b/fs/vmfs/vmfs_fs.h
index 2e072a1..7c7d0f1 100644
--- a/fs/vmfs/vmfs_fs.h
+++ b/fs/vmfs/vmfs_fs.h
@@ -87,7 +87,7 @@ struct vmfs_ops {
 		     char *data);
 	int (*write)(struct inode *inode, loff_t offset, int count, const
 		      char *data);
-	int (*readdir)(struct file *filp, void *dirent, filldir_t filldir,
+	int (*readdir)(struct file *filp, void *dirent,
 			struct vmfs_cache_control *ctl);
 
 	int (*getattr)(struct vmfs_sb_info *server, struct dentry *dir,
-- 
1.9.1

