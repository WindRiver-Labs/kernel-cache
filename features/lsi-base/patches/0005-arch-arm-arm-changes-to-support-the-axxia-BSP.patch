From 166bd8bc71bdd29efac3a3fe23be41dd4a2f6b9e Mon Sep 17 00:00:00 2001
From: Charlie Paul <cpaul.windriver@gmail.com>
Date: Thu, 11 Jun 2015 16:46:44 +0300
Subject: [PATCH 05/82] arch/arm: arm changes to support the axxia BSP

commit 166bd8bc71bdd29efac3a3fe23be41dd4a2f6b9e from
git://git.yoctoproject.org/linux-yocto-3.14

These changes are changes to the kernel that
are needed to support the AXXIA 5500 board.

Signed-off-by: Charlie Paul <cpaul.windriver@gmail.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 arch/arm/Kconfig                  | 87 ++++++++++++++++++++++++++++++++++++++-
 arch/arm/Kconfig.debug            |  4 ++
 arch/arm/Makefile                 |  2 +
 arch/arm/include/asm/futex.h      | 39 ++++++++++++++----
 arch/arm/include/asm/kmap_types.h |  5 +++
 arch/arm/include/asm/spinlock.h   |  5 +++
 arch/arm/kernel/head.S            |  8 ++++
 arch/arm/kernel/irq.c             |  8 ++--
 arch/arm/kernel/perf_event_v7.c   | 21 +++++-----
 arch/arm/mm/mmap.c                |  4 +-
 arch/arm/tools/mach-types         |  1 +
 init/Kconfig                      |  3 ++
 init/do_mounts.c                  | 55 +++++++++++++------------
 init/main.c                       | 19 +++++++--
 14 files changed, 204 insertions(+), 57 deletions(-)

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 751747e..99ff039 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -373,6 +373,29 @@ config ARCH_VERSATILE
 	help
 	  This enables support for ARM Ltd Versatile board.
 
+config ARCH_AXXIA
+	bool "LSI Axxia family"
+	select ARCH_PHYS_ADDR_T_64BIT
+	select ARCH_DMA_ADDR_T_64BIT
+	select ARCH_WANT_OPTIONAL_GPIOLIB
+	select ARM_AMBA
+	select COMMON_CLK
+	select CLKDEV_LOOKUP
+	select CLKSRC_MMIO
+	select GENERIC_CLOCKEVENTS
+	select HAVE_CLK
+	select HAVE_PATA_PLATFORM
+	select ARM_TIMER_SP804
+	select ICST
+	select NEED_MACH_IO_H
+	select ZONE_DMA
+	select PCI
+	select PCI_DOMAINS if PCI
+	select ARCH_SUPPORTS_MSI if PCI
+	select HAS_RAPIDIO
+	help
+	  This enables support for the LSI Axxia boards.
+
 config ARCH_AT91
 	bool "Atmel AT91"
 	select ARCH_REQUIRE_GPIOLIB
@@ -1051,6 +1074,8 @@ source "arch/arm/mach-ux500/Kconfig"
 
 source "arch/arm/mach-versatile/Kconfig"
 
+source "arch/arm/mach-axxia/Kconfig"
+
 source "arch/arm/mach-vexpress/Kconfig"
 source "arch/arm/plat-versatile/Kconfig"
 
@@ -1455,6 +1480,19 @@ source "drivers/pci/pcie/Kconfig"
 
 source "drivers/pcmcia/Kconfig"
 
+config HAS_RAPIDIO
+	bool
+	default n
+
+config RAPIDIO
+	bool "RapidIO support"
+	depends on HAS_RAPIDIO || PCI
+	help
+          If you say Y here, the kernel will include drivers and
+          infrastructure code to support RapidIO interconnect devices.
+
+source "drivers/rapidio/Kconfig"
+
 endmenu
 
 menu "Kernel Features"
@@ -1613,13 +1651,50 @@ config NR_CPUS
 	depends on SMP
 	default "4"
 
+menu "Support for hot-pluggable CPUs"
+
 config HOTPLUG_CPU
 	bool "Support for hot-pluggable CPUs"
-	depends on SMP
+	depends on SMP && HOTPLUG
 	help
 	  Say Y here to experiment with turning CPUs off and on.  CPUs
 	  can be controlled through /sys/devices/system/cpu.
 
+choice
+	prompt "CPU Power Down Mode"
+	default HOTPLUG_CPU_COMPLETE_POWER_DOWN
+	help
+		This is used to select how the CPU is going to be powered down. If LOW POWER
+		is selected then the CPU enters a WFI state and waits for an interrupt to
+		wake up. If COMPLETE POWER down is selected the CPU power is turned off. The only
+		way to power on the CPU is to execute a command.
+
+config HOTPLUG_CPU_COMPLETE_POWER_DOWN
+	bool "Power off the CPU"
+	help
+		This will power off the CPU completely. The irqs are migrated
+		to another CPU.
+
+config HOTPLUG_CPU_LOW_POWER
+	bool "Low Power CPU (wfi)"
+	help
+		This will put the CPU into a low power mode wfi mode. When an interrupt
+		is received the CPU will power on again.
+
+endchoice
+
+config HOTPLUG_CPU_L2_POWER_DOWN
+	bool "Power Off L2 Cache"
+	depends on HOTPLUG_CPU_COMPLETE_POWER_DOWN
+	default n if HOTPLUG_CPU_LOW_POWER
+	help
+		Select this if you want to power down the L2 cache when
+		all CPUS of a cluster have been powered off.
+
+endmenu
+
+
+
 config ARM_PSCI
 	bool "Support for the ARM Power State Coordination Interface (PSCI)"
 	depends on CPU_V7
@@ -1630,6 +1705,16 @@ config ARM_PSCI
 	  0022A ("Power State Coordination Interface System Software on
 	  ARM processors").
 
+config LOCAL_TIMERS
+	bool "Use local timer interrupts"
+	depends on SMP
+	default y
+	help
+	  Enable support for local timers on SMP platforms, rather then the
+	  legacy IPI broadcast method.  Local timers allows the system
+	  accounting to be spread across the timer interval, preventing a
+	  "thundering herd" at every timer tick.
+
 # The GPIO number here must be sorted by descending number. In case of
 # a multiplatform kernel, we just want the highest value required by the
 # selected platforms.
diff --git a/arch/arm/Kconfig.debug b/arch/arm/Kconfig.debug
index 0531da8..21667a3 100644
--- a/arch/arm/Kconfig.debug
+++ b/arch/arm/Kconfig.debug
@@ -101,6 +101,10 @@ choice
 		bool "Kernel low-level debugging on 9263 and 9g45"
 		depends on HAVE_AT91_DBGU1
 
+	config DEBUG_LL_AXXIA_UART0
+		bool "Kernel low-level debugging via UART0"
+		depends on ARCH_AXXIA
+
 	config DEBUG_BCM2835
 		bool "Kernel low-level debugging on BCM2835 PL011 UART"
 		depends on ARCH_BCM2835
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 9b247a1..3e28fe9 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -138,6 +138,7 @@ endif
 textofs-$(CONFIG_ARCH_MSM7X30) := 0x00208000
 textofs-$(CONFIG_ARCH_MSM8X60) := 0x00208000
 textofs-$(CONFIG_ARCH_MSM8960) := 0x00208000
+textofs-$(CONFIG_ARCH_AXXIA)   := 0x00408000
 
 # Machine directory name.  This list is sorted alphanumerically
 # by CONFIG_* macro name.
@@ -199,6 +200,7 @@ machine-$(CONFIG_ARCH_U300)		+= u300
 machine-$(CONFIG_ARCH_U8500)		+= ux500
 machine-$(CONFIG_ARCH_VERSATILE)	+= versatile
 machine-$(CONFIG_ARCH_VEXPRESS)		+= vexpress
+machine-$(CONFIG_ARCH_AXXIA)		:= axxia
 machine-$(CONFIG_ARCH_VIRT)		+= virt
 machine-$(CONFIG_ARCH_VT8500)		+= vt8500
 machine-$(CONFIG_ARCH_W90X900)		+= w90x900
diff --git a/arch/arm/include/asm/futex.h b/arch/arm/include/asm/futex.h
index 2aff798..cf5a6ea 100644
--- a/arch/arm/include/asm/futex.h
+++ b/arch/arm/include/asm/futex.h
@@ -3,6 +3,12 @@
 
 #ifdef __KERNEL__
 
+#if defined(CONFIG_CPU_USE_DOMAINS) && defined(CONFIG_SMP)
+/* ARM doesn't provide unprivileged exclusive memory accessors */
+#include <asm-generic/futex.h>
+#else
+
+
 #include <linux/futex.h>
 #include <linux/uaccess.h>
 #include <asm/errno.h>
@@ -44,7 +50,7 @@ futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr,
 
 	if (!access_ok(VERIFY_WRITE, uaddr, sizeof(u32)))
 		return -EFAULT;
-
+	/* Setup memory barrier */
 	smp_mb();
 	__asm__ __volatile__("@futex_atomic_cmpxchg_inatomic\n"
 	"1:	ldrex	%1, [%4]\n"
@@ -58,6 +64,7 @@ futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr,
 	: "=&r" (ret), "=&r" (val)
 	: "r" (oldval), "r" (newval), "r" (uaddr), "Ir" (-EFAULT)
 	: "cc", "memory");
+	/* Setup memory barrier */
 	smp_mb();
 
 	*uval = val;
@@ -107,7 +114,7 @@ futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr,
 #endif /* !SMP */
 
 static inline int
-futex_atomic_op_inuser (int encoded_op, u32 __user *uaddr)
+futex_atomic_op_inuser(int encoded_op, u32 __user *uaddr)
 {
 	int op = (encoded_op >> 28) & 7;
 	int cmp = (encoded_op >> 24) & 15;
@@ -147,17 +154,31 @@ futex_atomic_op_inuser (int encoded_op, u32 __user *uaddr)
 
 	if (!ret) {
 		switch (cmp) {
-		case FUTEX_OP_CMP_EQ: ret = (oldval == cmparg); break;
-		case FUTEX_OP_CMP_NE: ret = (oldval != cmparg); break;
-		case FUTEX_OP_CMP_LT: ret = (oldval < cmparg); break;
-		case FUTEX_OP_CMP_GE: ret = (oldval >= cmparg); break;
-		case FUTEX_OP_CMP_LE: ret = (oldval <= cmparg); break;
-		case FUTEX_OP_CMP_GT: ret = (oldval > cmparg); break;
-		default: ret = -ENOSYS;
+		case FUTEX_OP_CMP_EQ:
+			ret = (oldval == cmparg);
+			break;
+		case FUTEX_OP_CMP_NE:
+			ret = (oldval != cmparg);
+			break;
+		case FUTEX_OP_CMP_LT:
+			ret = (oldval < cmparg);
+			break;
+		case FUTEX_OP_CMP_GE:
+			ret = (oldval >= cmparg);
+			break;
+		case FUTEX_OP_CMP_LE:
+			ret = (oldval <= cmparg);
+			break;
+		case FUTEX_OP_CMP_GT:
+			ret = (oldval > cmparg);
+			break;
+		default:
+			ret = -ENOSYS;
 		}
 	}
 	return ret;
 }
 
+#endif /* !(CPU_USE_DOMAINS && SMP) */
 #endif /* __KERNEL__ */
 #endif /* _ASM_ARM_FUTEX_H */
diff --git a/arch/arm/include/asm/kmap_types.h b/arch/arm/include/asm/kmap_types.h
index 83eb2f7..3e527f9 100644
--- a/arch/arm/include/asm/kmap_types.h
+++ b/arch/arm/include/asm/kmap_types.h
@@ -4,6 +4,11 @@
 /*
  * This is the "bare minimum".  AIO seems to require this.
  */
+#if (NR_CPUS > 15)
+/* Prevent overlap between fixmap mapping and CPU vector page for 16th core */
+#define KM_TYPE_NR 15
+#else
 #define KM_TYPE_NR 16
+#endif
 
 #endif
diff --git a/arch/arm/include/asm/spinlock.h b/arch/arm/include/asm/spinlock.h
index ac4bfae..08cca7e 100644
--- a/arch/arm/include/asm/spinlock.h
+++ b/arch/arm/include/asm/spinlock.h
@@ -73,7 +73,12 @@ static inline void arch_spin_lock(arch_spinlock_t *lock)
 	: "cc");
 
 	while (lockval.tickets.next != lockval.tickets.owner) {
+#ifdef CONFIG_ARCH_AXXIA
+		extern void __axxia_arch_wfe(void);
+		__axxia_arch_wfe();
+#else
 		wfe();
+#endif
 		lockval.tickets.owner = ACCESS_ONCE(lock->tickets.owner);
 	}
 
diff --git a/arch/arm/kernel/head.S b/arch/arm/kernel/head.S
index f5f381d..9864a0f 100644
--- a/arch/arm/kernel/head.S
+++ b/arch/arm/kernel/head.S
@@ -52,8 +52,13 @@
 	.equ	swapper_pg_dir, KERNEL_RAM_VADDR - PG_DIR_SIZE
 
 	.macro	pgtbl, rd, phys
+#ifdef CONFIG_ARCH_AXXIA
+	ldr	\rd, =(TEXT_OFFSET - PG_DIR_SIZE)
+	add	\rd, \rd, \phys
+#else
 	add	\rd, \phys, #TEXT_OFFSET
 	sub	\rd, \rd, #PG_DIR_SIZE
+#endif
 	.endm
 
 /*
@@ -301,6 +306,9 @@ __create_page_tables:
 #endif
 #else
 	orr	r3, r3, #PMD_SECT_XN
+#ifdef CONFIG_ARCH_AXXIA
+	orr	r7, r7, #0x20
+#endif
 	str	r3, [r0], #4
 #endif
 
diff --git a/arch/arm/kernel/irq.c b/arch/arm/kernel/irq.c
index 1e782bd..f394eed 100644
--- a/arch/arm/kernel/irq.c
+++ b/arch/arm/kernel/irq.c
@@ -74,7 +74,7 @@ void handle_IRQ(unsigned int irq, struct pt_regs *regs)
 	 */
 	if (unlikely(irq >= nr_irqs)) {
 		if (printk_ratelimit())
-			printk(KERN_WARNING "Bad IRQ%u\n", irq);
+			pr_warn("Bad IRQ%u\n", irq);
 		ack_bad_irq(irq);
 	} else {
 		generic_handle_irq(irq);
@@ -98,7 +98,7 @@ void set_irq_flags(unsigned int irq, unsigned int iflags)
 	unsigned long clr = 0, set = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;
 
 	if (irq >= nr_irqs) {
-		printk(KERN_ERR "Trying to set irq flags for IRQ%d\n", irq);
+		pr_err("Trying to set irq flags for IRQ%d\n", irq);
 		return;
 	}
 
@@ -163,7 +163,7 @@ static bool migrate_one_irq(struct irq_desc *desc)
 	c = irq_data_get_irq_chip(d);
 	if (!c->irq_set_affinity)
 		pr_debug("IRQ%u: unable to set affinity\n", d->irq);
-	else if (c->irq_set_affinity(d, affinity, false) == IRQ_SET_MASK_OK && ret)
+	else if (c->irq_set_affinity(d, affinity, true) == IRQ_SET_MASK_OK && ret)
 		cpumask_copy(d->affinity, affinity);
 
 	return ret;
@@ -193,7 +193,7 @@ void migrate_irqs(void)
 		raw_spin_unlock(&desc->lock);
 
 		if (affinity_broken && printk_ratelimit())
-			pr_warning("IRQ%u no longer affine to CPU%u\n", i,
+			pr_warn("IRQ%u no longer affine to CPU%u\n", i,
 				smp_processor_id());
 	}
 
diff --git a/arch/arm/kernel/perf_event_v7.c b/arch/arm/kernel/perf_event_v7.c
index 039cffb..68738b5 100644
--- a/arch/arm/kernel/perf_event_v7.c
+++ b/arch/arm/kernel/perf_event_v7.c
@@ -93,6 +93,7 @@ enum armv7_a5_perf_types {
 
 /* ARMv7 Cortex-A15 specific event types */
 enum armv7_a15_perf_types {
+	ARMV7_A15_PERFCTR_CPU_CYCLES				= 0x11,
 	ARMV7_A15_PERFCTR_L1_DCACHE_ACCESS_READ		= 0x40,
 	ARMV7_A15_PERFCTR_L1_DCACHE_ACCESS_WRITE	= 0x41,
 	ARMV7_A15_PERFCTR_L1_DCACHE_REFILL_READ		= 0x42,
@@ -487,7 +488,7 @@ static const unsigned armv7_a5_perf_cache_map[PERF_COUNT_HW_CACHE_MAX]
  * Cortex-A15 HW events mapping
  */
 static const unsigned armv7_a15_perf_map[PERF_COUNT_HW_MAX] = {
-	[PERF_COUNT_HW_CPU_CYCLES]		= ARMV7_PERFCTR_CPU_CYCLES,
+	[PERF_COUNT_HW_CPU_CYCLES]		= ARMV7_A15_PERFCTR_CPU_CYCLES,
 	[PERF_COUNT_HW_INSTRUCTIONS]		= ARMV7_PERFCTR_INSTR_EXECUTED,
 	[PERF_COUNT_HW_CACHE_REFERENCES]	= ARMV7_PERFCTR_L1_DCACHE_ACCESS,
 	[PERF_COUNT_HW_CACHE_MISSES]		= ARMV7_PERFCTR_L1_DCACHE_REFILL,
@@ -917,34 +918,34 @@ static void armv7_pmnc_dump_regs(struct arm_pmu *cpu_pmu)
 	u32 val;
 	unsigned int cnt;
 
-	printk(KERN_INFO "PMNC registers dump:\n");
+	pr_info("PMNC registers dump:\n");
 
 	asm volatile("mrc p15, 0, %0, c9, c12, 0" : "=r" (val));
-	printk(KERN_INFO "PMNC  =0x%08x\n", val);
+	pr_info("PMNC  =0x%08x\n", val);
 
 	asm volatile("mrc p15, 0, %0, c9, c12, 1" : "=r" (val));
-	printk(KERN_INFO "CNTENS=0x%08x\n", val);
+	pr_info("CNTENS=0x%08x\n", val);
 
 	asm volatile("mrc p15, 0, %0, c9, c14, 1" : "=r" (val));
-	printk(KERN_INFO "INTENS=0x%08x\n", val);
+	pr_info("INTENS=0x%08x\n", val);
 
 	asm volatile("mrc p15, 0, %0, c9, c12, 3" : "=r" (val));
-	printk(KERN_INFO "FLAGS =0x%08x\n", val);
+	pr_info("FLAGS =0x%08x\n", val);
 
 	asm volatile("mrc p15, 0, %0, c9, c12, 5" : "=r" (val));
-	printk(KERN_INFO "SELECT=0x%08x\n", val);
+	pr_info("SELECT=0x%08x\n", val);
 
 	asm volatile("mrc p15, 0, %0, c9, c13, 0" : "=r" (val));
-	printk(KERN_INFO "CCNT  =0x%08x\n", val);
+	pr_info("CCNT  =0x%08x\n", val);
 
 	for (cnt = ARMV7_IDX_COUNTER0;
 			cnt <= ARMV7_IDX_COUNTER_LAST(cpu_pmu); cnt++) {
 		armv7_pmnc_select_counter(cnt);
 		asm volatile("mrc p15, 0, %0, c9, c13, 2" : "=r" (val));
-		printk(KERN_INFO "CNT[%d] count =0x%08x\n",
+		pr_info("CNT[%d] count =0x%08x\n",
 			ARMV7_IDX_TO_COUNTER(cnt), val);
 		asm volatile("mrc p15, 0, %0, c9, c13, 1" : "=r" (val));
-		printk(KERN_INFO "CNT[%d] evtsel=0x%08x\n",
+		pr_info("CNT[%d] evtsel=0x%08x\n",
 			ARMV7_IDX_TO_COUNTER(cnt), val);
 	}
 }
diff --git a/arch/arm/mm/mmap.c b/arch/arm/mm/mmap.c
index 5e85ed3..d5bb480 100644
--- a/arch/arm/mm/mmap.c
+++ b/arch/arm/mm/mmap.c
@@ -11,7 +11,7 @@
 #include <linux/random.h>
 #include <asm/cachetype.h>
 
-#define COLOUR_ALIGN(addr,pgoff)		\
+#define COLOUR_ALIGN(addr, pgoff)		\
 	((((addr)+SHMLBA-1)&~(SHMLBA-1)) +	\
 	 (((pgoff)<<PAGE_SHIFT) & (SHMLBA-1)))
 
@@ -146,7 +146,7 @@ arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,
 
 	info.flags = VM_UNMAPPED_AREA_TOPDOWN;
 	info.length = len;
-	info.low_limit = FIRST_USER_ADDRESS;
+	info.low_limit = PAGE_SIZE;
 	info.high_limit = mm->mmap_base;
 	info.align_mask = do_align ? (PAGE_MASK & (SHMLBA - 1)) : 0;
 	info.align_offset = pgoff << PAGE_SHIFT;
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index a10297d..1794ad4 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1007,3 +1007,4 @@ eco5_bx2		MACH_ECO5_BX2		ECO5_BX2		4572
 eukrea_cpuimx28sd	MACH_EUKREA_CPUIMX28SD	EUKREA_CPUIMX28SD	4573
 domotab			MACH_DOMOTAB		DOMOTAB			4574
 pfla03			MACH_PFLA03		PFLA03			4575
+axxia			MACH_AXXIA		AXXIA			4173
diff --git a/init/Kconfig b/init/Kconfig
index a62b42d..8a3a4a4 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1281,6 +1281,9 @@ config SYSCTL_ARCH_UNALIGN_ALLOW
 	  the unaligned access emulation.
 	  see arch/parisc/kernel/unaligned.c for reference
 
+config HOTPLUG
+	def_bool y
+
 config HAVE_PCSPKR_PLATFORM
 	bool
 
diff --git a/init/do_mounts.c b/init/do_mounts.c
index 91e5a21..57c5fbb 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -46,7 +46,7 @@ dev_t ROOT_DEV;
 
 static int __init load_ramdisk(char *str)
 {
-	rd_doload = simple_strtol(str,NULL,0) & 3;
+	rd_doload = simple_strtol(str, NULL, 0) & 3;
 	return 1;
 }
 __setup("load_ramdisk=", load_ramdisk);
@@ -366,7 +366,7 @@ static int __init do_mount_root(char *name, char *fs, int flags, void *data)
 	sys_chdir("/root");
 	s = current->fs->pwd.dentry->d_sb;
 	ROOT_DEV = s->s_dev;
-	printk(KERN_INFO
+	pr_info(
 	       "VFS: Mounted root (%s filesystem)%s on device %u:%u.\n",
 	       s->s_type->name,
 	       s->s_flags & MS_RDONLY ?  " readonly" : "",
@@ -391,15 +391,15 @@ retry:
 	for (p = fs_names; *p; p += strlen(p)+1) {
 		int err = do_mount_root(name, p, flags, root_mount_data);
 		switch (err) {
-			case 0:
-				goto out;
-			case -EACCES:
-				flags |= MS_RDONLY;
-				goto retry;
-			case -EINVAL:
-				continue;
+		case 0:
+			goto out;
+		case -EACCES:
+			flags |= MS_RDONLY;
+			goto retry;
+		case -EINVAL:
+			continue;
 		}
-	        /*
+		/*
 		 * Allow the user to distinguish between failed sys_open
 		 * and bad superblock on root device.
 		 * and give them a list of the available devices
@@ -407,36 +407,36 @@ retry:
 #ifdef CONFIG_BLOCK
 		__bdevname(ROOT_DEV, b);
 #endif
-		printk("VFS: Cannot open root device \"%s\" or %s: error %d\n",
+		pr_info("VFS: Cannot open root device \"%s\" or %s: error %d\n",
 				root_device_name, b, err);
-		printk("Please append a correct \"root=\" boot option; here are the available partitions:\n");
+		pr_info("Please append a correct \"root=\" boot option; here are the available partitions:\n");
 
 		printk_all_partitions();
 #ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
-		printk("DEBUG_BLOCK_EXT_DEVT is enabled, you need to specify "
+		pr_info("DEBUG_BLOCK_EXT_DEVT is enabled, you need to specify "
 		       "explicit textual name for \"root=\" boot option.\n");
 #endif
-		printk(KERN_EMERG "VFS: Unable to mount root fs on %s\n", b);
-		printk(KERN_EMERG "User configuration error - no valid root filesystem found\n");
+		pr_emerg("VFS: Unable to mount root fs on %s\n", b);
+		pr_emerg("User configuration error - no valid root filesystem found\n");
 		panic("Invalid configuration from end user prevents continuing");
 	}
 
-	printk("List of all partitions:\n");
+	pr_info("List of all partitions:\n");
 	printk_all_partitions();
-	printk("No filesystem could mount root, tried: ");
+	pr_info("No filesystem could mount root, tried: ");
 	for (p = fs_names; *p; p += strlen(p)+1)
-		printk(" %s", p);
-	printk("\n");
+		pr_info(" %s", p);
+	pr_info("\n");
 #ifdef CONFIG_BLOCK
 	__bdevname(ROOT_DEV, b);
 #endif
-	printk(KERN_EMERG "VFS: Unable to mount root fs on %s\n", b);
-	printk(KERN_EMERG "User configuration error - no valid root filesystem found\n");
+	pr_emerg("VFS: Unable to mount root fs on %s\n", b);
+	pr_emerg("User configuration error - no valid root filesystem found\n");
 	panic("Invalid configuration from end user prevents continuing");
 out:
 	put_page(page);
 }
- 
+
 #ifdef CONFIG_ROOT_NFS
 
 #define NFSROOT_TIMEOUT_MIN	5
@@ -493,7 +493,7 @@ void __init change_floppy(char *fmt, ...)
 		sys_ioctl(fd, FDEJECT, 0);
 		sys_close(fd);
 	}
-	printk(KERN_NOTICE "VFS: Insert %s and press ENTER\n", buf);
+	pr_notice("VFS: Insert %s and press ENTER\n", buf);
 	fd = sys_open("/dev/console", O_RDWR, 0);
 	if (fd >= 0) {
 		sys_ioctl(fd, TCGETS, (long)&termios);
@@ -514,14 +514,14 @@ void __init mount_root(void)
 		if (mount_nfs_root())
 			return;
 
-		printk(KERN_ERR "VFS: Unable to mount root fs via NFS, trying floppy.\n");
+		pr_err("VFS: Unable to mount root fs via NFS, trying floppy.\n");
 		ROOT_DEV = Root_FD0;
 	}
 #endif
 #ifdef CONFIG_BLK_DEV_FD
 	if (MAJOR(ROOT_DEV) == FLOPPY_MAJOR) {
 		/* rd_doload is 2 for a dual initrd/ramload setup */
-		if (rd_doload==2) {
+		if (rd_doload == 2) {
 			if (rd_load_disk(1)) {
 				ROOT_DEV = Root_RAM1;
 				root_device_name = NULL;
@@ -544,7 +544,7 @@ void __init prepare_namespace(void)
 	int is_floppy;
 
 	if (root_delay) {
-		printk(KERN_INFO "Waiting %d sec before mounting root device...\n",
+		pr_info("Waiting %d sec before mounting root device...\n",
 		       root_delay);
 		ssleep(root_delay);
 	}
@@ -577,7 +577,7 @@ void __init prepare_namespace(void)
 
 	/* wait for any asynchronous scanning to complete */
 	if ((ROOT_DEV == 0) && root_wait) {
-		printk(KERN_INFO "Waiting for root device %s...\n",
+		pr_info("Waiting for root device %s...\n",
 			saved_root_name);
 		while (driver_probe_done() != 0 ||
 			(ROOT_DEV = name_to_dev_t(saved_root_name)) == 0)
@@ -637,5 +637,6 @@ int __init init_rootfs(void)
 	if (err)
 		unregister_filesystem(&rootfs_fs_type);
 
+
 	return err;
 }
diff --git a/init/main.c b/init/main.c
index a8f9911..0ea5865 100644
--- a/init/main.c
+++ b/init/main.c
@@ -354,8 +354,8 @@ static void __init setup_command_line(char *command_line)
 	initcall_command_line =
 		memblock_virt_alloc(strlen(boot_command_line) + 1, 0);
 	static_command_line = memblock_virt_alloc(strlen(command_line) + 1, 0);
-	strcpy (saved_command_line, boot_command_line);
-	strcpy (static_command_line, command_line);
+	strcpy(saved_command_line, boot_command_line);
+	strcpy(static_command_line, command_line);
 }
 
 /*
@@ -423,7 +423,7 @@ void __init parse_early_options(char *cmdline)
 /* Arch code calls this early on, or if not, just before other parsing. */
 void __init parse_early_param(void)
 {
-	static __initdata int done = 0;
+	static __initdata int done;
 	static __initdata char tmp_cmdline[COMMAND_LINE_SIZE];
 
 	if (done)
@@ -478,9 +478,20 @@ static void __init mm_init(void)
 
 asmlinkage void __init start_kernel(void)
 {
-	char * command_line;
+	char *command_line;
 	extern const struct kernel_param __start___param[], __stop___param[];
 
+#if defined(CONFIG_ARCH_AXXIA) && defined(DEBUG_LL)
+	{
+		*(unsigned long *)(0xf0080000 + 0x24) = 13;
+		*(unsigned long *)(0xf0080000 + 0x28) = 1;
+		*(unsigned long *)(0xf0080000 + 0x2c) = 0x70;
+		*(unsigned long *)(0xf0080000 + 0x30) = 0x301;
+		*(unsigned long *)(0xf0080000 + 0x34) = 0;
+		*(unsigned long *)(0xf0080000 + 0x38) = 0x700;
+	}
+#endif	/* CONFIG_ARCH_AXXIA && DEBUG_LL */
+
 	/*
 	 * Need to run as early as possible, to initialize the
 	 * lockdep hash:
-- 
1.9.1

