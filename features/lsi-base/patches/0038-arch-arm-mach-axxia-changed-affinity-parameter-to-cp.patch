From eb529d8092242725dc2da47a1f60106f56ae78a1 Mon Sep 17 00:00:00 2001
From: Charlie Paul <cpaul.windriver@gmail.com>
Date: Thu, 11 Jun 2015 16:47:17 +0300
Subject: [PATCH 38/82] arch/arm/mach-axxia: changed affinity parameter to cpu

commit eb529d8092242725dc2da47a1f60106f56ae78a1 from
git://git.yoctoproject.org/linux-yocto-3.14

Signed-off-by: Charlie Paul <cpaul.windriver@gmail.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 arch/arm/mach-axxia/axxia-gic.c | 47 +++++++++++++++++++++++------------------
 1 file changed, 27 insertions(+), 20 deletions(-)

diff --git a/arch/arm/mach-axxia/axxia-gic.c b/arch/arm/mach-axxia/axxia-gic.c
index a7656a7..27e0111 100644
--- a/arch/arm/mach-axxia/axxia-gic.c
+++ b/arch/arm/mach-axxia/axxia-gic.c
@@ -192,12 +192,14 @@ static struct gic_rpc_data gic_rpc_data = {NULL, 0, 0, 0, 0, NULL};
 static inline void __iomem *gic_dist_base(struct irq_data *d)
 {
 	struct gic_chip_data *gic_data = irq_data_get_irq_chip_data(d);
+
 	return gic_data_dist_base(gic_data);
 }
 
 static inline void __iomem *gic_cpu_base(struct irq_data *d)
 {
 	struct gic_chip_data *gic_data = irq_data_get_irq_chip_data(d);
+
 	return gic_data_cpu_base(gic_data);
 }
 
@@ -279,11 +281,13 @@ static void _gic_mask_irq(struct irq_data *d, bool do_mask)
 static void gic_mask_remote(void *info)
 {
 	struct irq_data *d = (struct irq_data *)info;
+
 	_gic_mask_irq(d, 1);
 }
 static void gic_unmask_remote(void *info)
 {
 	struct irq_data *d = (struct irq_data *)info;
+
 	_gic_mask_irq(d, 0);
 }
 
@@ -401,6 +405,7 @@ static int _gic_set_type(struct irq_data *d, unsigned int type)
 static void gic_set_type_remote(void *info)
 {
 	struct gic_rpc_data *rpc = (struct gic_rpc_data *)info;
+
 	_gic_set_type(rpc->d, rpc->type);
 }
 
@@ -442,13 +447,12 @@ static int gic_retrigger(struct irq_data *d)
 }
 
 static int _gic_set_affinity(struct irq_data *d,
-			     const struct cpumask *mask_val,
-			     bool do_clear)
+		unsigned int cpu,
+		bool do_clear)
 {
 	void __iomem *reg  = gic_dist_base(d) + GIC_DIST_TARGET +
 			     (gic_irq(d) & ~3);
 	unsigned int shift = (gic_irq(d) % 4) * 8;
-	unsigned int cpu = cpumask_any_and(mask_val, cpu_online_mask);
 	u32 val, mask, bit;
 	u32 enable_mask, enable_offset;
 
@@ -489,12 +493,16 @@ static int _gic_set_affinity(struct irq_data *d,
 static void gic_set_affinity_remote(void *info)
 {
 	struct gic_rpc_data *rpc = (struct gic_rpc_data *)info;
-	_gic_set_affinity(rpc->d, rpc->mask_val, false);
+
+	_gic_set_affinity(rpc->d, rpc->cpu, false);
+
 }
 static void gic_clr_affinity_remote(void *info)
 {
 	struct gic_rpc_data *rpc = (struct gic_rpc_data *)info;
-	_gic_set_affinity(rpc->d, rpc->mask_val, true);
+
+	_gic_set_affinity(rpc->d, rpc->oldcpu, true);
+
 }
 
 static bool on_same_cluster(u32 pcpu1, u32 pcpu2)
@@ -540,7 +548,7 @@ static int gic_set_affinity(struct irq_data *d,
 	BUG_ON(!irqs_disabled());
 
 	if (cpu >= nr_cpu_ids)
-		return -EINVAL;
+			return -EINVAL;
 
 	if (irqid >= MAX_GIC_INTERRUPTS)
 		return -EINVAL;
@@ -550,9 +558,9 @@ static int gic_set_affinity(struct irq_data *d,
 		return IRQ_SET_MASK_OK;
 
 	/*
-	 * If the new IRQ affinity is the same as current, then
-	 * there's no need to update anything.
-	 */
+	* If the new IRQ affinity is the same as current, then
+	* there's no need to update anything.
+	*/
 	if (cpu_logical_map(cpu) == irq_cpuid[irqid])
 		return IRQ_SET_MASK_OK;
 
@@ -562,10 +570,9 @@ static int gic_set_affinity(struct irq_data *d,
 	 * affinity directly. Otherwise, use the RPC mechanism.
 	 */
 	if (on_same_cluster(cpu_logical_map(cpu), pcpu))
-		_gic_set_affinity(d, mask_val, false);
+		_gic_set_affinity(d, cpu_logical_map(cpu), false);
 	else{
-		ret = exec_remote_set_affinity(false, cpu, d, mask_val,
-					       force);
+		ret = exec_remote_set_affinity(false, cpu_logical_map(cpu), d, mask_val, force);
 
 		if (ret != IRQ_SET_MASK_OK)
 			return ret;
@@ -583,19 +590,18 @@ static int gic_set_affinity(struct irq_data *d,
 		 * the cpu we're currently running on, clear the IRQ affinity
 		 * directly. Otherwise, use RPC mechanism.
 		 */
-		if (on_same_cluster(irq_cpuid[irqid], pcpu))
-			_gic_set_affinity(d, mask_val, true);
-		else
+		if (on_same_cluster(irq_cpuid[irqid], pcpu)) {
+			_gic_set_affinity(d, irq_cpuid[irqid], true);
+		} else {
 			ret = exec_remote_set_affinity(true,
-				      get_logical_index(irq_cpuid[irqid]), d,
-				      mask_val, force);
+					get_logical_index(irq_cpuid[irqid]), d, mask_val, force);
+		}
 		if (ret != IRQ_SET_MASK_OK) {
 			/* Need to back out the set operation */
 			if (on_same_cluster(cpu_logical_map(cpu), pcpu))
-				_gic_set_affinity(d, mask_val, true);
+				_gic_set_affinity(d, irq_cpuid[irqid], true);
 			else
-				exec_remote_set_affinity(true, cpu, d,
-							 mask_val, force);
+				exec_remote_set_affinity(true, cpu, d, mask_val, force);
 
 			return ret;
 		}
-- 
1.9.1

