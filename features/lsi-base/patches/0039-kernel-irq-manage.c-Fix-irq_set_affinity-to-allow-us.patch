From 0cf89668ebe0da116fcea03ca7f6d548f38bb57f Mon Sep 17 00:00:00 2001
From: David Mercado <david.mercado@windriver.com>
Date: Thu, 11 Jun 2015 16:47:18 +0300
Subject: [PATCH 39/82] kernel/irq/manage.c: Fix irq_set_affinity to allow use
 with buslocks

commit 0cf89668ebe0da116fcea03ca7f6d548f38bb57f from
git://git.yoctoproject.org/linux-yocto-3.14

Modify irq_set_affinity() to allow usage of bus locks with "slow bus" IRQ
controllers.  This only affects those BSPs that use bus locks in their IRQ
controllers, such as the LSI Axxia GIC.  The recommendation for this
change originated from Thomax Gleixner at Linutronix.

Signed-off-by: David Mercado <david.mercado@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 kernel/irq/manage.c | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index ebb8a9e..dec28ef 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -190,16 +190,16 @@ int irq_set_affinity_locked(struct irq_data *data, const struct cpumask *mask,
 
 int __irq_set_affinity(unsigned int irq, const struct cpumask *mask, bool force)
 {
-	struct irq_desc *desc = irq_to_desc(irq);
 	unsigned long flags;
+	struct irq_desc *desc = irq_get_desc_buslock(irq, &flags,
+			IRQ_GET_DESC_CHECK_GLOBAL);
 	int ret;
 
 	if (!desc)
 		return -EINVAL;
 
-	raw_spin_lock_irqsave(&desc->lock, flags);
 	ret = irq_set_affinity_locked(irq_desc_get_irq_data(desc), mask, force);
-	raw_spin_unlock_irqrestore(&desc->lock, flags);
+	irq_put_desc_busunlock(desc, flags);
 	return ret;
 }
 
@@ -1097,8 +1097,8 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 				goto out_mask;
 		}
 
-		desc->istate &= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \
-				  IRQS_ONESHOT | IRQS_WAITING);
+		desc->istate &= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED |
+				IRQS_ONESHOT | IRQS_WAITING);
 		irqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);
 
 		if (new->flags & IRQF_PERCPU) {
@@ -1130,7 +1130,7 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 
 		if (nmsk != omsk)
 			/* hope the handler works with current  trigger mode */
-			pr_warning("irq %d uses trigger mode %u; requested %u\n",
+			pr_warn("irq %d uses trigger mode %u; requested %u\n",
 				   irq, nmsk, omsk);
 	}
 
@@ -1309,7 +1309,7 @@ void remove_irq(unsigned int irq, struct irqaction *act)
 	struct irq_desc *desc = irq_to_desc(irq);
 
 	if (desc && !WARN_ON(irq_settings_is_per_cpu_devid(desc)))
-	    __free_irq(irq, act->dev_id);
+		__free_irq(irq, act->dev_id);
 }
 EXPORT_SYMBOL_GPL(remove_irq);
 
@@ -1591,7 +1591,7 @@ void remove_percpu_irq(unsigned int irq, struct irqaction *act)
 	struct irq_desc *desc = irq_to_desc(irq);
 
 	if (desc && irq_settings_is_per_cpu_devid(desc))
-	    __free_percpu_irq(irq, act->percpu_dev_id);
+		__free_percpu_irq(irq, act->percpu_dev_id);
 }
 
 /**
-- 
1.9.1

