From 39349ab4d5500b03149a10614134b97ca6e6bd31 Mon Sep 17 00:00:00 2001
From: Yong Zhang <yong.zhang@windriver.com>
Date: Wed, 12 Nov 2014 16:55:25 +0800
Subject: [PATCH] ARM: vgic: move vgic behind IPI in dts

To make the dts compatible with old kernel.
For example, a kernel which assumes that the index of IPI mask
is 2 and 3 will not work with the dtb in which the index 2
and 3 is now for vgic. So move the vgic behind IPI to make
it backward compatible.

Signed-off-by: Yong Zhang <yong.zhang@windriver.com>
---
 arch/arm/boot/dts/axm55xx.dtsi    |    6 +++---
 arch/arm/boot/dts/axm55xxemu7.dts |    6 +++---
 arch/arm/kvm/vgic.c               |    6 +++---
 arch/arm/mach-axxia/axxia-gic.c   |    4 ++--
 4 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/arch/arm/boot/dts/axm55xx.dtsi b/arch/arm/boot/dts/axm55xx.dtsi
index 92347d8..801f50e 100644
--- a/arch/arm/boot/dts/axm55xx.dtsi
+++ b/arch/arm/boot/dts/axm55xx.dtsi
@@ -51,10 +51,10 @@
 		interrupt-controller;
 		reg = <0x20 0x01001000 0 0x1000>,  /* gic dist base */
 		      <0x20 0x01002000 0 0x1000>,  /* gic cpu base */
-		      <0x20 0x01004000 0 0x2000>,  /* vgic control */
-		      <0x20 0x01006000 0 0x2000>,  /* vgic cpu base */
 		      <0x20 0x10030000 0 0x1000>,  /* axm IPI mask reg base */
-		      <0x20 0x10040000 0 0x20000>; /* axm IPI send reg base */
+		      <0x20 0x10040000 0 0x20000>, /* axm IPI send reg base */
+		      <0x20 0x01004000 0 0x2000>,  /* vgic control */
+		      <0x20 0x01006000 0 0x2000>;  /* vgic cpu base */
 	};
 
 	timer {
diff --git a/arch/arm/boot/dts/axm55xxemu7.dts b/arch/arm/boot/dts/axm55xxemu7.dts
index 56375c1..283b052 100644
--- a/arch/arm/boot/dts/axm55xxemu7.dts
+++ b/arch/arm/boot/dts/axm55xxemu7.dts
@@ -127,10 +127,10 @@
 		interrupt-controller;
 		reg = <0x20 0x01001000 0 0x1000>,  /* gic dist base */
 		      <0x20 0x01002000 0 0x100>,   /* gic cpu base */
-		      <0x20 0x01004000 0 0x2000>,  /* vgic control */
-		      <0x20 0x01006000 0 0x2000>,  /* vgic cpu base */
 		      <0x20 0x10030000 0 0x100>,   /* axm IPI mask reg base */
-		      <0x20 0x10040000 0 0x20000>; /* axm IPI send reg base */
+		      <0x20 0x10040000 0 0x20000>, /* axm IPI send reg base */
+		      <0x20 0x01004000 0 0x2000>,  /* vgic control */
+		      <0x20 0x01006000 0 0x2000>;  /* vgic cpu base */
 	};
 
 	timer {
diff --git a/arch/arm/kvm/vgic.c b/arch/arm/kvm/vgic.c
index 17c5ac7..4471572 100644
--- a/arch/arm/kvm/vgic.c
+++ b/arch/arm/kvm/vgic.c
@@ -1339,13 +1339,13 @@ int kvm_vgic_hyp_init(void)
 		goto out_free_irq;
 	}
 
-	ret = of_address_to_resource(vgic_node, 2, &vctrl_res);
+	ret = of_address_to_resource(vgic_node, 4, &vctrl_res);
 	if (ret) {
 		kvm_err("Cannot obtain VCTRL resource\n");
 		goto out_free_irq;
 	}
 
-	vgic_vctrl_base = of_iomap(vgic_node, 2);
+	vgic_vctrl_base = of_iomap(vgic_node, 4);
 	if (!vgic_vctrl_base) {
 		kvm_err("Cannot ioremap VCTRL\n");
 		ret = -ENOMEM;
@@ -1367,7 +1367,7 @@ int kvm_vgic_hyp_init(void)
 		 vctrl_res.start, vgic_maint_irq);
 	on_each_cpu(vgic_init_maintenance_interrupt, NULL, 1);
 
-	if (of_address_to_resource(vgic_node, 3, &vcpu_res)) {
+	if (of_address_to_resource(vgic_node, 5, &vcpu_res)) {
 		kvm_err("Cannot obtain VCPU resource\n");
 		ret = -ENXIO;
 		goto out_unmap;
diff --git a/arch/arm/mach-axxia/axxia-gic.c b/arch/arm/mach-axxia/axxia-gic.c
index 53e525a..a885a48 100644
--- a/arch/arm/mach-axxia/axxia-gic.c
+++ b/arch/arm/mach-axxia/axxia-gic.c
@@ -1379,10 +1379,10 @@ int __init axxia_gic_of_init(struct device_node *node,
 	cpu_base = of_iomap(node, 1);
 	WARN(!cpu_base, "unable to map gic cpu registers\n");
 
-	ipi_mask_reg_base = of_iomap(node, 4);
+	ipi_mask_reg_base = of_iomap(node, 2);
 	WARN(!ipi_mask_reg_base, "unable to map Axxia IPI mask registers\n");
 
-	ipi_send_reg_base = of_iomap(node, 5);
+	ipi_send_reg_base = of_iomap(node, 3);
 	WARN(!ipi_send_reg_base, "unable to map Axxia IPI send registers\n");
 
 	axxia_gic_init_bases(-1, dist_base, cpu_base, node);
-- 
1.7.5.4

