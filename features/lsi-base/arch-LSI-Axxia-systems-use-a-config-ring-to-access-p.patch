From 57c02baa7ba2cc35d95c8e61b350131fd784a04c Mon Sep 17 00:00:00 2001
From: John Jacques <john.jacques@lsi.com>
Date: Wed, 25 Sep 2013 19:11:28 -0500
Subject: [PATCH 110/159] arch: LSI Axxia systems use a config ring to access
 parts of the hardware.

git.yoctoproject.org/git/linux-yocto-3.10
commit ccc55a99754a4350fc4e3754af27388bff312c2d standard/axxia/base.

For various reasons, the config ring access code has been moved, deleted, etc.
This patch adds ncr access back to ARM and PowerPC platforms. It also removes
invalid accesses to previous methods to access hardware using the ncr buss.

Change the file permissions from 755 to 644.

Signed-off-by: John Jacques <john.jacques@lsi.com>
---
 arch/powerpc/include/asm/lsi/acp_ncr.h  |   45 ----
 arch/powerpc/sysdev/Makefile            |    2 +-
 arch/powerpc/sysdev/lsi_acp_ncr.c       |  377 --------------------------
 arch/powerpc/sysdev/lsi_pci.c           |    2 +-
 drivers/misc/Kconfig                    |    6 +
 drivers/misc/Makefile                   |    1 +
 drivers/misc/lsi-ncr.c                  |  439 +++++++++++++++++++++++++++++++
 drivers/misc/lsi-ncr.h                  |   40 +++
 drivers/net/ethernet/lsi/lsi_acp_mdio.c |    1 -
 drivers/net/ethernet/lsi/lsi_acp_net.c  |    4 +-
 drivers/tty/serial/lsi_acp_serial.c     |    2 -
 11 files changed, 491 insertions(+), 428 deletions(-)
 delete mode 100644 arch/powerpc/include/asm/lsi/acp_ncr.h
 delete mode 100644 arch/powerpc/sysdev/lsi_acp_ncr.c
 create mode 100644 drivers/misc/lsi-ncr.c
 create mode 100644 drivers/misc/lsi-ncr.h
 mode change 100755 => 100644 drivers/net/ethernet/lsi/lsi_acp_mdio.c

diff --git a/arch/powerpc/include/asm/lsi/acp_ncr.h b/arch/powerpc/include/asm/lsi/acp_ncr.h
deleted file mode 100644
index 114a36b..0000000
--- a/arch/powerpc/include/asm/lsi/acp_ncr.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * asm/lsi/acp_ncr.h
- *
- * Copyright (C) 2010 LSI
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
- */
-
-#ifndef __DRIVERS_LSI_ACP_NCR_H
-#define __DRIVERS_LSI_ACP_NCR_H
-
-#ifndef NCP_REGION_ID
-#define NCP_REGION_ID(node, target) \
-(unsigned long)((((node) & 0xffff) << 16) | ((target) & 0xffff))
-#endif
-
-#ifndef NCP_NODE_ID
-#define NCP_NODE_ID(region) (((region) >> 16) & 0xffff)
-#endif
-
-#ifndef NCP_TARGET_ID
-#define NCP_TARGET_ID(region) ((region) & 0xffff)
-#endif
-
-int ncr_read(unsigned long, unsigned long, int, void *);
-int ncr_write(unsigned long, unsigned long, int, void *);
-
-int is_asic(void);
-
-extern int acp_mdio_read(unsigned long, unsigned long, unsigned short *, int);
-extern int acp_mdio_write(unsigned long, unsigned long, unsigned short, int);
-
-#endif /*  __DRIVERS_LSI_ACP_NCR_H */
diff --git a/arch/powerpc/sysdev/Makefile b/arch/powerpc/sysdev/Makefile
index 87682a0..66b6b08 100644
--- a/arch/powerpc/sysdev/Makefile
+++ b/arch/powerpc/sysdev/Makefile
@@ -75,4 +75,4 @@ obj-$(CONFIG_PPC_XICS)		+= xics/
 
 obj-$(CONFIG_GE_FPGA)		+= ge/
 
-obj-$(CONFIG_ACP)		+= lsi_acp_ncr.o lsi_acp_wrappers.o
+obj-$(CONFIG_ACP)		+= lsi_acp_wrappers.o
diff --git a/arch/powerpc/sysdev/lsi_acp_ncr.c b/arch/powerpc/sysdev/lsi_acp_ncr.c
deleted file mode 100644
index 736ca5d..0000000
--- a/arch/powerpc/sysdev/lsi_acp_ncr.c
+++ /dev/null
@@ -1,377 +0,0 @@
-/*
- *  Copyright (C) 2009 LSI Corporation
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <linux/io.h>
-#include <linux/module.h>
-
-#include <include/asm/lsi/acp_ncr.h>
-
-static void __iomem *nca_address;
-
-#define WFC_TIMEOUT (400000)
-
-#define LOCK_DOMAIN 0
-
-union command_data_register_0 {
-	unsigned long raw;
-	struct {
-		unsigned long start_done:1;
-		unsigned long unused:6;
-		unsigned long local_bit:1;
-		unsigned long status:2;
-		unsigned long byte_swap_enable:1;
-		unsigned long cfg_cmpl_int_enable:1;
-		unsigned long cmd_type:4;
-		unsigned long dbs:16;
-	} __packed bits;
-} __packed;
-
-union command_data_register_1 {
-	unsigned long raw;
-	struct {
-		unsigned long target_address:32;
-	} __packed bits;
-} __packed;
-
-union command_data_register_2 {
-	unsigned long raw;
-	struct {
-		unsigned long unused:16;
-		unsigned long target_node_id:8;
-		unsigned long target_id_address_upper:8;
-	} __packed bits;
-} __packed;
-
-/*
-  ----------------------------------------------------------------------
-  ncr_register_read
-*/
-
-static inline unsigned long
-ncr_register_read(unsigned *address)
-{
-	unsigned long value;
-
-	value = in_be32(address);
-
-	return value;
-}
-
-/*
-  ----------------------------------------------------------------------
-  ncr_register_write
-*/
-
-static inline void
-ncr_register_write(const unsigned value, unsigned *address)
-{
-	out_be32(address, value);
-}
-
-/*
-  ------------------------------------------------------------------------------
-  ncr_lock
-*/
-
-static int
-ncr_lock(int domain)
-{
-	unsigned long offset;
-	unsigned long value;
-	int loops = 10000;
-
-	offset = (0xff80 + (domain * 4));
-
-	do {
-		value = ncr_register_read((unsigned *)(nca_address + offset));
-	} while ((0 != value) && (0 < --loops));
-
-	if (0 == loops)
-		return -1;
-
-	return 0;
-}
-
-/*
-  ------------------------------------------------------------------------------
-  ncr_unlock
-*/
-
-static void
-ncr_unlock(int domain)
-{
-	unsigned long offset;
-
-	offset = (0xff80 + (domain * 4));
-	ncr_register_write(0, (unsigned *)(nca_address + offset));
-
-	return;
-}
-
-/*
-  ======================================================================
-  ======================================================================
-  Public Interface
-  ======================================================================
-  ======================================================================
-*/
-
-/*
-  ----------------------------------------------------------------------
-  ncr_read
-*/
-
-int
-ncr_read(unsigned long region, unsigned long address, int number, void *buffer)
-{
-	union command_data_register_0 cdr0;
-	union command_data_register_1 cdr1;
-	union command_data_register_2 cdr2;
-	int wfc_timeout = WFC_TIMEOUT;
-
-	if (NULL == nca_address)
-		nca_address = ioremap(0x002000520000ULL, 0x20000);
-
-	if (0 != ncr_lock(LOCK_DOMAIN))
-		return -1;
-
-	/*
-	  Set up the read command.
-	*/
-
-	cdr2.raw = 0;
-	cdr2.bits.target_node_id = NCP_NODE_ID(region);
-	cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
-	ncr_register_write(cdr2.raw, (unsigned *) (nca_address + 0xf8));
-
-	cdr1.raw = 0;
-	cdr1.bits.target_address = (address >> 2);
-	ncr_register_write(cdr1.raw, (unsigned *) (nca_address + 0xf4));
-
-	cdr0.raw = 0;
-	cdr0.bits.start_done = 1;
-
-	if (0xff == cdr2.bits.target_id_address_upper)
-		cdr0.bits.local_bit = 1;
-
-	cdr0.bits.cmd_type = 4;
-	/* TODO: Verify number... */
-	cdr0.bits.dbs = (number - 1);
-	ncr_register_write(cdr0.raw, (unsigned *) (nca_address + 0xf0));
-	mb();
-
-	/*
-	  Wait for completion.
-	*/
-
-	do {
-		--wfc_timeout;
-	} while ((0x80000000UL ==
-		  ncr_register_read((unsigned *)(nca_address + 0xf0))) &&
-		 0 < wfc_timeout);
-
-	if (0 == wfc_timeout) {
-		ncr_unlock(LOCK_DOMAIN);
-		return -1;
-	}
-
-	/*
-	  Copy data words to the buffer.
-	*/
-
-	address = (unsigned long)(nca_address + 0x1000);
-	while (4 <= number) {
-		*((unsigned long *) buffer) =
-			ncr_register_read((unsigned *) address);
-		address += 4;
-		number -= 4;
-	}
-
-	if (0 < number) {
-		unsigned long temp = ncr_register_read((unsigned *) address);
-		memcpy((void *) buffer, &temp, number);
-	}
-
-	ncr_unlock(LOCK_DOMAIN);
-
-	return 0;
-}
-EXPORT_SYMBOL(ncr_read);
-/*
-  ------------------------------------------------------------------------------
-  is_asic
-*/
-
-int
-is_asic(void)
-{
-#ifdef CONFIG_ACPISS
-	return 0;
-#else
-	unsigned long nca_config;
-
-	if (0 == ncr_read(NCP_REGION_ID(0x16, 0xff), 0x10, 4, &nca_config))
-		return (0 == (nca_config & 0x80000000));
-
-	return -1;
-#endif
-}
-EXPORT_SYMBOL(is_asic);
-
-/*
-  ----------------------------------------------------------------------
-  ncr_write
-*/
-
-int
-ncr_write(unsigned long region, unsigned long address, int number, void *buffer)
-{
-	union command_data_register_0 cdr0;
-	union command_data_register_1 cdr1;
-	union command_data_register_2 cdr2;
-	unsigned long data_word_base;
-	int dbs = (number - 1);
-	int wfc_timeout = WFC_TIMEOUT;
-
-	if (NULL == nca_address)
-		nca_address = ioremap(0x002000520000ULL, 0x20000);
-
-	if (0 != ncr_lock(LOCK_DOMAIN))
-		return -1;
-
-	/*
-	  Set up the write.
-	*/
-
-	cdr2.raw = 0;
-	cdr2.bits.target_node_id = NCP_NODE_ID(region);
-	cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
-	ncr_register_write(cdr2.raw, (unsigned *) (nca_address + 0xf8));
-
-	cdr1.raw = 0;
-	cdr1.bits.target_address = (address >> 2);
-	ncr_register_write(cdr1.raw, (unsigned *) (nca_address + 0xf4));
-
-	/*
-	  Copy from buffer to the data words.
-	*/
-
-	data_word_base = (unsigned long)(nca_address + 0x1000);
-
-	while (4 <= number) {
-		ncr_register_write(*((unsigned long *) buffer),
-				   (unsigned *) data_word_base);
-		data_word_base += 4;
-		buffer += 4;
-		number -= 4;
-	}
-
-	if (0 < number) {
-		unsigned long temp = 0;
-
-		memcpy((void *) &temp, (void *) buffer, number);
-		ncr_register_write(temp, (unsigned *) data_word_base);
-		data_word_base += number;
-		buffer += number;
-		number = 0;
-	}
-
-	cdr0.raw = 0;
-	cdr0.bits.start_done = 1;
-
-	if (0xff == cdr2.bits.target_id_address_upper)
-		cdr0.bits.local_bit = 1;
-
-	cdr0.bits.cmd_type = 5;
-	/* TODO: Verify number... */
-	cdr0.bits.dbs = dbs;
-	ncr_register_write(cdr0.raw, (unsigned *) (nca_address + 0xf0));
-	mb();
-
-	/*
-	  Wait for completion.
-	*/
-
-	do {
-		--wfc_timeout;
-	} while ((0x80000000UL ==
-		  ncr_register_read((unsigned *)(nca_address + 0xf0))) &&
-		 0 < wfc_timeout);
-
-	if (0 == wfc_timeout) {
-		ncr_unlock(LOCK_DOMAIN);
-		return -1;
-	}
-
-	/*
-	  Check status.
-	*/
-
-	if (0x3 !=
-	    ((ncr_register_read((unsigned *) (nca_address + 0xf0)) &
-		0x00c00000) >> 22)) {
-		unsigned long status;
-
-		status = ncr_register_read((unsigned *)(nca_address + 0xe4));
-		ncr_unlock(LOCK_DOMAIN);
-
-		return status;
-	}
-
-	ncr_unlock(LOCK_DOMAIN);
-
-	return 0;
-}
-EXPORT_SYMBOL(ncr_write);
-
-/*
-  ----------------------------------------------------------------------
-  ncr_init
-*/
-
-int
-ncr_init(void)
-{
-	/* We need this to be a module so that the functions can be exported
-	 * as module symbols.
-	 */
-	return 0;
-}
-
-postcore_initcall(ncr_init);
-
-/*
-  ----------------------------------------------------------------------
-  ncr_exit
-*/
-
-void __exit
-ncr_exit(void)
-{
-	/* Unmap the NCA. */
-	iounmap(nca_address);
-}
-
-module_exit(ncr_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("Register Ring access for LSI's ACP board");
diff --git a/arch/powerpc/sysdev/lsi_pci.c b/arch/powerpc/sysdev/lsi_pci.c
index 439d9e1..a25d396 100644
--- a/arch/powerpc/sysdev/lsi_pci.c
+++ b/arch/powerpc/sysdev/lsi_pci.c
@@ -22,7 +22,7 @@
 #include "ppc4xx_pci.h"
 
 #include <linux/interrupt.h>
-#include <asm/lsi/acp_ncr.h>
+
 static int acp_plx;
 
 #undef PRINT_CONFIG_ACCESSES
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index f25ff11..29d6c10 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -535,6 +535,12 @@ config LSI_MTC
 	  compliant with IEEE 1149.1 and can run JTAG test sequences on
 	  external devices.
 
+config LSI_NCR
+	tristate "LSI NCR Access"
+	depends on ARCH_AXXIA || ACP
+	help
+	  Provides access to the LSI Axxia NCR bus.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 0dfbcdd..41b9de8 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -53,4 +53,5 @@ obj-$(CONFIG_INTEL_MEI)		+= mei/
 obj-$(CONFIG_VMWARE_VMCI)	+= vmw_vmci/
 obj-$(CONFIG_LATTICE_ECP3_CONFIG)	+= lattice-ecp3-config.o
 obj-$(CONFIG_SRAM)		+= sram.o
+obj-$(CONFIG_LSI_NCR)           += lsi-ncr.o
 obj-$(CONFIG_LSI_MTC)		+= lsi-mtc.o
diff --git a/drivers/misc/lsi-ncr.c b/drivers/misc/lsi-ncr.c
new file mode 100644
index 0000000..acb8e8f
--- /dev/null
+++ b/drivers/misc/lsi-ncr.c
@@ -0,0 +1,439 @@
+/*
+ *  Copyright (C) 2009 LSI Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+
+#include <asm/io.h>
+
+#include "lsi-ncr.h"
+
+static void __iomem *nca_address = NULL;
+
+#ifdef CONFIG_ARCH_AXXIA
+#define NCA_PHYS_ADDRESS 0x002020100000ULL
+#else
+#define NCA_PHYS_ADDRESS 0x002000520000ULL
+#endif
+
+#define WFC_TIMEOUT (400000)
+
+#define LOCK_DOMAIN 0
+
+typedef union {
+	unsigned long raw;
+	struct {
+#ifdef __BIG_ENDIAN
+		unsigned long start_done              :1;
+		unsigned long unused                  :6;
+		unsigned long local_bit               :1;
+		unsigned long status                  :2;
+		unsigned long byte_swap_enable        :1;
+		unsigned long cfg_cmpl_int_enable     :1;
+		unsigned long cmd_type                :4;
+		unsigned long dbs                     :16;
+#else
+		unsigned long dbs                     :16;
+		unsigned long cmd_type                :4;
+		unsigned long cfg_cmpl_int_enable     :1;
+		unsigned long byte_swap_enable        :1;
+		unsigned long status                  :2;
+		unsigned long local_bit               :1;
+		unsigned long unused                  :6;
+		unsigned long start_done              :1;
+#endif
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed)) command_data_register_0_t;
+
+typedef union {
+	unsigned long raw;
+	struct {
+		unsigned long target_address          :32;
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed)) command_data_register_1_t;
+
+typedef union {
+	unsigned long raw;
+	struct {
+#ifdef __BIG_ENDIAN
+		unsigned long unused                  :16;
+		unsigned long target_node_id          :8;
+		unsigned long target_id_address_upper :8;
+#else
+		unsigned long target_id_address_upper :8;
+		unsigned long target_node_id          :8;
+		unsigned long unused                  :16;
+#endif
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed)) command_data_register_2_t;
+
+#ifdef CONFIG_ARM
+
+/*
+  ----------------------------------------------------------------------
+  ncr_register_read
+*/
+
+static __inline__ unsigned long
+ncr_register_read(unsigned *address)
+{
+	unsigned long value;
+
+	value = ioread32be(address);
+	printk("%s: value=0x%x address=0x%p\n", __FUNCTION__, value, address);
+
+	return value;
+}
+
+/*
+  ----------------------------------------------------------------------
+  ncr_register_write
+*/
+
+static __inline__ void
+ncr_register_write(const unsigned value, unsigned *address)
+{
+	printk("%s: value=0x%x address=0x%p\n", __FUNCTION__, value, address);
+	iowrite32be(value, address);
+
+	return;
+}
+
+#else
+
+/*
+  ----------------------------------------------------------------------
+  ncr_register_read
+*/
+
+static __inline__ unsigned long
+ncr_register_read(unsigned *address)
+{
+	return in_be32((unsigned *)address);
+}
+
+/*
+  ----------------------------------------------------------------------
+  ncr_register_write
+*/
+
+static __inline__ void
+ncr_register_write(const unsigned value, unsigned *address)
+{
+	out_be32(address, value);
+}
+
+#endif
+
+/*
+  ------------------------------------------------------------------------------
+  ncr_lock
+*/
+
+static int
+ncr_lock(int domain)
+{
+	unsigned long offset;
+	unsigned long value;
+	int loops = 10000;
+
+	offset=(0xff80 + (domain * 4));
+
+	do {
+		value = ncr_register_read((unsigned *)(nca_address + offset));
+	} while ((0 != value) && (0 < --loops));
+
+	if (0 == loops)
+		return -1;
+
+	return 0;
+}
+
+/*
+  ------------------------------------------------------------------------------
+  ncr_unlock
+*/
+
+static void
+ncr_unlock(int domain)
+{
+	unsigned long offset;
+
+	offset=(0xff80 + (domain * 4));
+	ncr_register_write(0, (unsigned *)(nca_address + offset));
+
+	return;
+}
+
+/*
+  ======================================================================
+  ======================================================================
+  Public Interface
+  ======================================================================
+  ======================================================================
+*/
+
+/*
+  ----------------------------------------------------------------------
+  ncr_read
+*/
+
+int
+ncr_read(unsigned long region, unsigned long address, int number,
+	void *buffer)
+{
+	command_data_register_0_t cdr0;
+	command_data_register_1_t cdr1;
+	command_data_register_2_t cdr2;
+	int wfc_timeout = WFC_TIMEOUT;
+
+	if (NULL == nca_address)
+		nca_address = ioremap(NCA_PHYS_ADDRESS, 0x20000);
+
+	if (0 != ncr_lock(LOCK_DOMAIN))
+		return -1;
+
+	/*
+	  Set up the read command.
+	*/
+
+	cdr2.raw = 0;
+	cdr2.bits.target_node_id = NCP_NODE_ID(region);
+	cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
+	ncr_register_write(cdr2.raw, (unsigned *) (nca_address + 0xf8));
+
+	cdr1.raw = 0;
+	cdr1.bits.target_address = (address >> 2);
+	ncr_register_write(cdr1.raw, (unsigned *) (nca_address + 0xf4));
+
+	cdr0.raw = 0;
+	cdr0.bits.start_done = 1;
+
+	if (0xff == cdr2.bits.target_id_address_upper)
+		cdr0.bits.local_bit = 1;
+
+	cdr0.bits.cmd_type = 4;
+	/* TODO: Verify number... */
+	cdr0.bits.dbs = (number - 1);
+	ncr_register_write(cdr0.raw, (unsigned *) (nca_address + 0xf0));
+	mb();
+
+	/*
+	  Wait for completion.
+	*/
+
+	do {
+		--wfc_timeout;
+	} while ((0x80000000UL ==
+		  ncr_register_read((unsigned *)(nca_address + 0xf0))) &&
+		 0 < wfc_timeout);
+
+	if (0 == wfc_timeout) {
+		ncr_unlock(LOCK_DOMAIN);
+		return -1;
+	}
+
+	/*
+	  Copy data words to the buffer.
+	*/
+
+	address = (unsigned long)(nca_address + 0x1000);
+	while (4 <= number) {
+		*((unsigned long *) buffer) =
+			ncr_register_read((unsigned *) address);
+		address += 4;
+		number -= 4;
+	}
+
+	if (0 < number) {
+		unsigned long temp =
+			ncr_register_read((unsigned *) address);
+		memcpy((void *) buffer, &temp, number);
+	}
+
+	ncr_unlock(LOCK_DOMAIN);
+
+	return 0;
+}
+
+/*
+  ----------------------------------------------------------------------
+  ncr_write
+*/
+
+int
+ncr_write(unsigned long region, unsigned long address, int number,
+	  void *buffer)
+{
+	command_data_register_0_t cdr0;
+	command_data_register_1_t cdr1;
+	command_data_register_2_t cdr2;
+	unsigned long data_word_base;
+	int dbs = (number - 1);
+	int wfc_timeout = WFC_TIMEOUT;
+
+	if (NULL == nca_address)
+		nca_address = ioremap(NCA_PHYS_ADDRESS, 0x20000);
+
+	if (0 != ncr_lock(LOCK_DOMAIN))
+		return -1;
+
+	/*
+	  Set up the write.
+	*/
+
+	cdr2.raw = 0;
+	cdr2.bits.target_node_id = NCP_NODE_ID(region);
+	cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
+	ncr_register_write(cdr2.raw, (unsigned *) (nca_address + 0xf8));
+
+	cdr1.raw = 0;
+	cdr1.bits.target_address = (address >> 2);
+	ncr_register_write(cdr1.raw, (unsigned *) (nca_address + 0xf4));
+
+	/*
+	  Copy from buffer to the data words.
+	*/
+
+	data_word_base = (unsigned long)(nca_address + 0x1000);
+
+	while (4 <= number) {
+		ncr_register_write(*((unsigned long *) buffer),
+				   (unsigned *) data_word_base);
+		data_word_base += 4;
+		buffer += 4;
+		number -= 4;
+	}
+
+	if (0 < number) {
+		unsigned long temp = 0;
+
+		memcpy((void *) &temp, (void *) buffer, number);
+		ncr_register_write(temp, (unsigned *) data_word_base);
+		data_word_base += number;
+		buffer += number;
+		number = 0;
+	}
+
+	cdr0.raw = 0;
+	cdr0.bits.start_done = 1;
+
+	if (0xff == cdr2.bits.target_id_address_upper) {
+		cdr0.bits.local_bit = 1;
+	}
+
+	cdr0.bits.cmd_type = 5;
+	/* TODO: Verify number... */
+	cdr0.bits.dbs = dbs;
+	ncr_register_write(cdr0.raw, (unsigned *) (nca_address + 0xf0));
+	mb();
+
+	/*
+	  Wait for completion.
+	*/
+
+	do {
+		--wfc_timeout;
+	} while ((0x80000000UL ==
+		  ncr_register_read((unsigned *)(nca_address + 0xf0))) &&
+		 0 < wfc_timeout);
+
+	if (0 == wfc_timeout) {
+		ncr_unlock(LOCK_DOMAIN);
+		return -1;
+	}
+
+	/*
+	  Check status.
+	*/
+
+	if( 0x3 !=
+	    ( ( ncr_register_read( ( unsigned * ) ( nca_address + 0xf0 ) ) &
+		0x00c00000 ) >> 22 ) ) {
+		unsigned long status;
+
+		status = ncr_register_read((unsigned *)(nca_address + 0xe4));
+		ncr_unlock(LOCK_DOMAIN);
+
+		return status;
+	}
+
+	ncr_unlock(LOCK_DOMAIN);
+
+	return 0;
+}
+
+/*
+  ----------------------------------------------------------------------
+  ncr_init
+*/
+
+int
+ncr_init(void)
+{
+#if 1
+	{
+		unsigned long value;
+
+#ifdef CONFIG_ARCH_AXXIA
+		if (0 != ncr_read(NCP_REGION_ID(0x22, 0), 0x694, 4, &value))
+			printk(KERN_CRIT
+			       "%s: ncr_read() failed!\n", __FUNCTION__);
+		else
+			printk(KERN_CRIT
+			       "%s: value is 0x%x\n", __FUNCTION__, value);
+#else
+		if (0 != ncr_read(NCP_REGION_ID(0x22, 0), 0x50, 4, &value))
+			printk(KERN_CRIT
+			       "%s: ncr_read() failed!\n", __FUNCTION__);
+		else
+			printk(KERN_CRIT
+			       "%s: value is 0x%x\n", __FUNCTION__, value);
+#endif
+	}
+#endif
+
+	return 0;
+}
+
+module_init(ncr_init);
+
+/*
+  ----------------------------------------------------------------------
+  ncr_exit
+*/
+
+void __exit
+ncr_exit(void)
+{
+	/* Unmap the NCA. */
+	iounmap(nca_address);
+
+	return;
+}
+
+module_exit( ncr_exit );
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Register Ring access for LSI's ACP board");
+
+EXPORT_SYMBOL(ncr_read);
+EXPORT_SYMBOL(ncr_write);
diff --git a/drivers/misc/lsi-ncr.h b/drivers/misc/lsi-ncr.h
new file mode 100644
index 0000000..f102df5
--- /dev/null
+++ b/drivers/misc/lsi-ncr.h
@@ -0,0 +1,40 @@
+/*
+ * drivers/lsi/common/version.h
+ *
+ * Copyright (C) 2010 LSI
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ */
+
+#ifndef __DRIVERS_LSI_ACP_NCR_H
+#define __DRIVERS_LSI_ACP_NCR_H
+
+#ifndef NCP_REGION_ID
+#define NCP_REGION_ID(node, target) \
+(unsigned long) ((((node) & 0xffff) << 16) | ((target) & 0xffff))
+#endif
+
+#ifndef NCP_NODE_ID
+#define NCP_NODE_ID(region) (((region) >> 16) & 0xffff)
+#endif
+
+#ifndef NCP_TARGET_ID
+#define NCP_TARGET_ID(region) ((region) & 0xffff)
+#endif
+
+int ncr_read(unsigned long, unsigned long, int, void *);
+int ncr_write(unsigned long, unsigned long, int, void *);
+
+#endif /*  __DRIVERS_LSI_ACP_NCR_H */
diff --git a/drivers/net/ethernet/lsi/lsi_acp_mdio.c b/drivers/net/ethernet/lsi/lsi_acp_mdio.c
old mode 100755
new mode 100644
index d1213b9..07643fc
--- a/drivers/net/ethernet/lsi/lsi_acp_mdio.c
+++ b/drivers/net/ethernet/lsi/lsi_acp_mdio.c
@@ -21,7 +21,6 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <asm/irq.h>
-#include <asm/lsi/acp_ncr.h>
 #include <linux/io.h>
 #include <linux/of_address.h>
 #include <linux/irqdomain.h>
diff --git a/drivers/net/ethernet/lsi/lsi_acp_net.c b/drivers/net/ethernet/lsi/lsi_acp_net.c
index 5698f59..8854948 100644
--- a/drivers/net/ethernet/lsi/lsi_acp_net.c
+++ b/drivers/net/ethernet/lsi/lsi_acp_net.c
@@ -87,9 +87,11 @@
 #include <linux/io.h>
 #include <asm/dma.h>
 
-#include <asm/lsi/acp_ncr.h>
 #include "lsi_acp_net.h"
 
+extern int acp_mdio_read(unsigned long, unsigned long, unsigned short *, int);
+extern int acp_mdio_write(unsigned long, unsigned long, unsigned short, int);
+
 /* Define to disable full duplex mode on Amarillo boards */
 #undef AMARILLO_WA
 /*#define AMARILLO_WA*/
diff --git a/drivers/tty/serial/lsi_acp_serial.c b/drivers/tty/serial/lsi_acp_serial.c
index 49ffd30..a41eab2 100644
--- a/drivers/tty/serial/lsi_acp_serial.c
+++ b/drivers/tty/serial/lsi_acp_serial.c
@@ -52,8 +52,6 @@
 #include <linux/of.h>
 #include <linux/io.h>
 
-#include <asm/lsi/acp_ncr.h>
-
 #define SZ_4K (4*1024)
 #define UART_NR			2
 #define SERIAL_AMBA_MAJOR	204
-- 
1.7.5.4

