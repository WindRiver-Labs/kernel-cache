From c27597519054e6608c3a67a3b872f4aa98fc39da Mon Sep 17 00:00:00 2001
From: Li Wang <li.wang@windriver.com>
Date: Tue, 25 Aug 2015 14:50:36 +0800
Subject: [PATCH 17/68] drivers/misc/lsi-smmon.c: Updated smmon driver

the patch comes from:
git://git.yoctoproject.org/linux-yocto-3.10
commit 2a03a72c34a95251dca48982f7c139c6a1d6a97a upstream

Updated smmon driver such that uncorrectable errors causes
machine_restart instead of kernel panic. Also, setting
persistent register (0xdc) bit 3 to indicate
uncorrectable errors. Updated kconfig such that if EDAC
driver is enabled in Kernel config then smmon driver will
be disabled by default.

Signed-off-by: SangeethaRao <sangeetha.rao@lsi.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
Signed-off-by: Li Wang <li.wang@windriver.com>
---
 drivers/misc/Kconfig     |    1 +
 drivers/misc/lsi-smmon.c |   32 +++++++++++++++++++++++++++-----
 2 files changed, 28 insertions(+), 5 deletions(-)

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index a33da06..a3adf3d 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -554,6 +554,7 @@ config LSI_NCR
 config LSI_SMMON
 	tristate "LSI System Memory Monitor"
 	depends on ARCH_AXXIA || ACP
+	depends on !EDAC_AXXIA
 	help
 	  Monitor the system memory controllers for errors.
 
diff --git a/drivers/misc/lsi-smmon.c b/drivers/misc/lsi-smmon.c
index f20857a..10e19ac 100644
--- a/drivers/misc/lsi-smmon.c
+++ b/drivers/misc/lsi-smmon.c
@@ -17,13 +17,22 @@
 #include <linux/platform_device.h>
 #include <linux/ratelimit.h>
 #include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/reboot.h>
 
 #include <mach/ncr.h>
 
+#define APB2_SER3_PHY_ADDR        0x002010030000ULL
+#define APB2_SER3_PHY_SIZE   0x1000
+
 static int log = 1;
 module_param(log, int, S_IRUGO|S_IWUSR);
 MODULE_PARM_DESC(log, "Log each error to kernel log.");
 
+static int machineRestart = 1;
+module_param(machineRestart, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(machineRestart, "Machine restart on fatal error.");
 /*
   iAXM55xx memory controller interrupt status bits:
 
@@ -96,6 +105,7 @@ static const u32 event_mask[NR_EVENTS] = {
 };
 
 static const struct event_logging {
+	int         fatal;
 	const char *level;
 	const char *name;
 } event_logging[NR_EVENTS] = {
@@ -124,6 +134,7 @@ struct smmon_attr {
 struct sm_dev {
 	struct platform_device *pdev;
 	u32 region; /* NCR region address */
+	void __iomem *apb2ser3_region;
 	u32 counter[NR_EVENTS];
 };
 
@@ -171,6 +182,7 @@ smmon_isr(int interrupt, void *device)
 {
 	struct sm_dev *sm = device;
 	u32 status;
+	unsigned long setVal;
 	int i;
 
 	if (ncr_read(sm->region, 0x410, 4, &status)) {
@@ -182,11 +194,14 @@ smmon_isr(int interrupt, void *device)
 	for (i = 0; i < NR_EVENTS; ++i) {
 		if ((status & event_mask[i]) != 0) {
 			++sm->counter[i];
-			if (log)
-				printk_ratelimited("%s%s: %s\n",
-						   event_logging[i].level,
-						   dev_name(&sm->pdev->dev),
-						   event_logging[i].name);
+			if (machineRestart && event_logging[i].fatal) {
+				setVal = readl(sm->apb2ser3_region + 0xdc);
+				/* set bit 3 in pscratch reg */
+				setVal = (setVal) | (0x1 << 3);
+				writel(setVal, sm->apb2ser3_region + 0xdc);
+				pr_info("CPU uncorrectable error\n");
+				machine_restart(NULL);
+			}
 		}
 	}
 
@@ -204,6 +219,8 @@ smmon_probe(struct platform_device *pdev)
 	struct resource *irq;
 	u32 mask = SM_INT_MASK;
 	int rc = 0;
+	struct device_node *np = pdev->dev.of_node;
+
 
 	sm = devm_kzalloc(&pdev->dev, sizeof *sm, GFP_KERNEL);
 	if (!sm) {
@@ -219,6 +236,11 @@ smmon_probe(struct platform_device *pdev)
 	}
 	sm->region = io->start;
 
+	sm->apb2ser3_region = of_iomap(np, 1);
+	if (!sm->apb2ser3_region)
+		sm->apb2ser3_region = ioremap(APB2_SER3_PHY_ADDR,
+				APB2_SER3_PHY_SIZE);
+
 	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (!irq) {
 		rc = -EINVAL;
-- 
1.7.5.4

