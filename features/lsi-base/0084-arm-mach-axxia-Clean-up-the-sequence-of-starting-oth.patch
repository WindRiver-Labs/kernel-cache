From 82cd34885b879e81828dbc5076aa5c69be022800 Mon Sep 17 00:00:00 2001
From: John Jacques <john.jacques@lsi.com>
Date: Wed, 4 Sep 2013 15:03:15 -0500
Subject: [PATCH 084/175] arm/mach-axxia: Clean up the sequence of starting other cores.

git.yoctoproject.org/git/linux-yocto-3.10
commit 789571a7484e2d16151a6446f1023702b05633fa standard/axxia/base.

Signed-off-by: John Jacques <john.jacques@lsi.com>
---
 arch/arm/mach-axxia/platsmp.c |   47 ++++++++++++++++++++++++++--------------
 1 files changed, 30 insertions(+), 17 deletions(-)

diff --git a/arch/arm/mach-axxia/platsmp.c b/arch/arm/mach-axxia/platsmp.c
index 8d6dbd8..a382cb2 100644
--- a/arch/arm/mach-axxia/platsmp.c
+++ b/arch/arm/mach-axxia/platsmp.c
@@ -191,7 +191,7 @@ platform_smp_prepare_cpus(unsigned int max_cpus)
 	int i;
 	void __iomem *apb2_ser3_base;
 	unsigned long resetVal;
-	int phys_cpu, cpu_count=0;
+	int phys_cpu, cpu_count = 0;
 	struct device_node *np;
 	unsigned long release_addr[NR_CPUS] = {0};
 	unsigned long release;
@@ -216,25 +216,33 @@ platform_smp_prepare_cpus(unsigned int max_cpus)
 		 * actually populated at the present time.
 		 */
 
-		apb2_ser3_base = ioremap(APB2_SER3_PHY_ADDR, APB2_SER3_ADDR_SIZE);
+		apb2_ser3_base =
+			ioremap(APB2_SER3_PHY_ADDR, APB2_SER3_ADDR_SIZE);
 
-		for (i = 0; i < NR_CPUS; i++) {	
+		for (i = 0; i < NR_CPUS; i++) {
 			/* check if this is a possible CPU and
 			   it is within max_cpus range */
 			if ((cpu_possible(i)) &&
 			    (cpu_count < max_cpus) &&
 			    (0 != release_addr[i])) {
-				resetVal = readl(apb2_ser3_base + 0x1010);
-				phys_cpu = cpu_logical_map(i);
 				set_cpu_present(cpu_count, true);
-				if (phys_cpu != 0) {
-					writel(0xab, apb2_ser3_base+0x1000);
-					resetVal &= ~(1 << phys_cpu);
-					writel(resetVal, apb2_ser3_base+0x1010);
-					udelay(1000);
-				}
 				cpu_count++;
 			}
+
+			/* Release all physical cpu:s since we might want to
+			 * bring them online later. Also we need to get the
+			 * execution into kernel code (it's currently executing
+			 * in u-boot).
+			 */
+			phys_cpu = cpu_logical_map(i);
+
+			if (phys_cpu != 0) {
+				resetVal = readl(apb2_ser3_base + 0x1010);
+				writel(0xab, apb2_ser3_base+0x1000);
+				resetVal &= ~(1 << phys_cpu);
+				writel(resetVal, apb2_ser3_base+0x1010);
+				udelay(1000);
+			}
 		}
 
 		iounmap(apb2_ser3_base);
@@ -244,14 +252,19 @@ platform_smp_prepare_cpus(unsigned int max_cpus)
 		 * cores will execute once they are released from their
 		 * "holding pen".
 		 */
-		*(u32 *)phys_to_virt(release) =
-			virt_to_phys(axxia_secondary_startup);
-		smp_wmb();
-		__cpuc_flush_dcache_area((void *)phys_to_virt(release),
-					 sizeof(u32));
+		for (i = 0; i < NR_CPUS; i++) {
+			if (release_addr[i] != 0) {
+				u32 *vrel_addr =
+					(u32 *)phys_to_virt(release_addr[i]);
+				*vrel_addr =
+					virt_to_phys(axxia_secondary_startup);
+				smp_wmb();
+				__cpuc_flush_dcache_area(vrel_addr, sizeof(u32));
+			}
+		}
 	} else if (of_find_compatible_node(NULL, NULL, "lsi,axm5516-sim")) {
 		for (i = 0; i < max_cpus; i++)
-                	set_cpu_present(i, true);
+			set_cpu_present(i, true);
 
 		/*
 		 * This is the entry point of the routine that the secondary
-- 
1.7.1

