From 9c1e263a4d247aaa342c44ad148c2876d4151618 Mon Sep 17 00:00:00 2001
From: SangeethaRao <sangeetha.rao@lsi.com>
Date: Tue, 6 May 2014 11:53:10 -0700
Subject: [PATCH 68/71] LSI nand: Enables support for 3500 NAND

git://git.yoctoproject.org/linux-yocto-3.10 standard/axxia/base
commit 7ecaba47af3357b33be2cd84534875d062965056

Until this patch NAND driver was disabled for 3500.
This patch, enables the  NAND driver for 3500.

Signed-off-by: SangeethaRao <sangeetha.rao@lsi.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/mtd/nand/lsi_acp_nand.c |   43 +++++++++++++++++++++++++++-----------
 1 files changed, 30 insertions(+), 13 deletions(-)

diff --git a/drivers/mtd/nand/lsi_acp_nand.c b/drivers/mtd/nand/lsi_acp_nand.c
index 4a4f48a..7acaa55 100644
--- a/drivers/mtd/nand/lsi_acp_nand.c
+++ b/drivers/mtd/nand/lsi_acp_nand.c
@@ -601,6 +601,18 @@ lsi_nand_command(struct mtd_info *mtd, unsigned int command,
 	register struct nand_chip *chip = mtd->priv;
 	unsigned int status = 0;
 	struct lsi_nand_private *priv = &lsi_nand_private;
+	struct device_node *np = NULL;
+	void *busy_reg;
+	unsigned long busy_mask;
+
+	np = of_find_compatible_node(NULL, NULL, "lsi,acp3500");
+	if (NULL != np) {
+		busy_reg = (gpreg_base + 0x80);
+		busy_mask = (1 << 20);
+	} else {
+		busy_reg = LSI_NAND_PECC_BUSY_REGISTER;
+		busy_mask = LSI_NAND_PECC_BUSY_MASK;
+	}
 
 	DEBUG_PRINT("command=0x%x\n", command);
 	command &= 0xff;
@@ -705,8 +717,8 @@ lsi_nand_command(struct mtd_info *mtd, unsigned int command,
 			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
 		do {
 			udelay(chip->chip_delay);
-			status = READL((void *)LSI_NAND_PECC_BUSY_REGISTER);
-		} while (0 != (status & LSI_NAND_PECC_BUSY_MASK));
+			status = READL((void *)busy_reg);
+		} while (0 != (status & busy_mask));
 
 		/* wait until CHIP_BUSY goes low */
 		do {
@@ -802,6 +814,18 @@ static int lsi_nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 {
 	unsigned long status = 0;
 	loff_t offset = 0;
+	struct device_node *np = NULL;
+	void *busy_reg;
+	unsigned long busy_mask;
+
+	np = of_find_compatible_node(NULL, NULL, "lsi,acp3500");
+	if (NULL != np) {
+		busy_reg = (gpreg_base + 0x80);
+		busy_mask = (1 << 20);
+	} else {
+		busy_reg = LSI_NAND_PECC_BUSY_REGISTER;
+		busy_mask = LSI_NAND_PECC_BUSY_MASK;
+	}
 
 	/*
 	  When reading or writing, wait for the
@@ -810,9 +834,9 @@ static int lsi_nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 #ifdef NOT_USED
 	if (FL_READING == chip->state || FL_WRITING == chip->state) {
 		for (;;) {
-			status = READL((void *)LSI_NAND_PECC_BUSY_REGISTER);
+			status = READL((void *)busy_reg);
 
-			if (0 == (status & LSI_NAND_PECC_BUSY_MASK))
+			if (0 == (status & busy_mask))
 				break;
 
 			udelay(chip->chip_delay);
@@ -820,9 +844,9 @@ static int lsi_nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 	}
 #else
 	for (;;) {
-		status = READL((void *)LSI_NAND_PECC_BUSY_REGISTER);
+		status = READL((void *)busy_reg);
 
-		if (0 == (status & LSI_NAND_PECC_BUSY_MASK))
+		if (0 == (status & busy_mask))
 			break;
 
 		udelay(chip->chip_delay);
@@ -3433,13 +3457,6 @@ lsi_nand_init(void)
 	static const char *part_probe_types[]
 	= { "cmdlinepart", "ofpart", NULL };
 
-	np = of_find_compatible_node(NULL, NULL, "lsi,acp3500");
-
-	if (NULL != np) {
-		pr_err("NAND Support is Not Yet Available on 3500\n");
-		return -1;
-	}
-
 	memset(&ppdata, 0, sizeof(ppdata));
 
 	np = of_find_node_by_type(np, "nand");
-- 
1.7.5.4

