From 1b6500caa746a84af6a67328ef017f66dd25283e Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Thu, 2 Jan 2014 14:35:25 +0800
Subject: [PATCH 159/175] LSI:Acp34xx:Drop 'enabled' field in device-tree

Using the standard 'status' field to replace 'enabled' field in
device-tree.

1.Drop the "enabled" attribute from the device trees.
2.In perpherial drivers, invoke of_device_is_available() to
check device availability.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/powerpc/boot/dts/ACP344xV2.dts    |   11 ------
 drivers/i2c/busses/acp3400-i2c.c       |    4 +--
 drivers/mtd/nand/lsi_acp_nand.c        |    5 +--
 drivers/net/ethernet/lsi/lsi_acp_net.c |    8 ++---
 drivers/spi/spi-pl022.c                |    4 ++-
 drivers/tty/serial/lsi_acp_serial.c    |   61 +++++++++++---------------------
 6 files changed, 29 insertions(+), 64 deletions(-)

diff --git a/arch/powerpc/boot/dts/ACP344xV2.dts b/arch/powerpc/boot/dts/ACP344xV2.dts
index 1a4040f..cccaf09 100644
--- a/arch/powerpc/boot/dts/ACP344xV2.dts
+++ b/arch/powerpc/boot/dts/ACP344xV2.dts
@@ -136,7 +136,6 @@
                         UART0: serial@00404000 {
                                 device_type = "serial";
                                 compatible = "acp-uart0";
-                                enabled = <0>;
                                 reg = <0x00404000 0x1000>;
                                 clock-reg = <0x00408040 0x20>;
                                 clock-frequency = <200000000>;
@@ -147,7 +146,6 @@
                         UART1: serial@00405000 {
                                 device_type = "serial";
                                 compatible = "acp-uart1";
-                                enabled = <0>;
                                 reg = <0x00405000 0x1000>;
                                 clock-reg = <0x00408060 0x20>;
                                 clock-frequency = <200000000>;
@@ -158,7 +156,6 @@
                         USB0: usb@004a4000 {
                                 device_type = "usb";
                                 compatible = "acp-usb";
-                                enabled = <0>;
                                 reg = <0x004a0000 0x00020000
 				       0x0040c000 0x00001000>;
                                 interrupt-parent = <&MPIC>;
@@ -168,7 +165,6 @@
 				#address-cells = <1>;
 				#size-cells = <0>;
                                 compatible = "acp-i2c";
-                                enabled = <0>;
 				reg = <0x403000 0x1000 0x408020 0x1000>;
                                 interrupt-parent = <&MPIC>;
                                 interrupts = <21 2>;
@@ -184,7 +180,6 @@
 				cell-index = <0>;
                                 compatible = "acp-ssp";
 				clock-frequency = <25000000>;
-                                enabled = <1>;
                                 reg = <0x00402000 0x00001000>;
                                 interrupt-parent = <&MPIC>;
                                 interrupts = <20 2>;
@@ -208,7 +203,6 @@
 				#size-cells = <1>;
                                 device_type = "nand";
                                 compatible = "acp-nand";
-                                enabled = <0>;
                                 reg = <0x00440000 0x20000
                                        0x0040c000 0x1000>;
 
@@ -280,7 +274,6 @@
                         FEMAC: femac@00480000 {
                                 device_type = "network";
                                 compatible = "acp-femac";
-                                enabled = <0>;
                                 reg = <0x00480000 0x1000
                                        0x00481000 0x1000
                                        0x00482000 0x1000>;
@@ -355,7 +348,6 @@
         PCIE0: pciex@f00c0000 {
                 compatible = "lsi,plb-pciex";
                 device_type = "pci";
-                enabled = <0>;
                 plx = <0>;
                 primary;
                 port = <0>;
@@ -391,7 +383,6 @@
         PCIE1: pciex@f00c8000 {
                 compatible = "lsi,plb-pciex";
                 device_type = "pci";
-                enabled = <0>;
                 plx = <0>;
                 primary;
                 port = <1>;
@@ -427,7 +418,6 @@
         PCIE2: pciex@f00d0000 {
                 compatible = "lsi,plb-pciex";
                 device_type = "pci";
-                enabled = <0>;
                 plx = <0>;
                 primary;
                 port = <2>;
@@ -464,7 +454,6 @@
         rio0: rapidio@f0020000 {
                 compatible = "acp,rapidio-delta";
                 device_type = "rapidio";
-                enabled = <0>;
                 #size = <0>;    /* 0 = (256, small system)
                                  * 1 = (65536, large system) */
 /*
diff --git a/drivers/i2c/busses/acp3400-i2c.c b/drivers/i2c/busses/acp3400-i2c.c
index de4eff6..85f673b 100644
--- a/drivers/i2c/busses/acp3400-i2c.c
+++ b/drivers/i2c/busses/acp3400-i2c.c
@@ -427,13 +427,11 @@ static int acp34xx_i2c_probe(struct platform_device *dev)
 
 	struct acp3400_i2c *i2c;
 	int result = -ENODEV;
-	const u32 *field;
 
 	if (!np)
 		return -ENODEV;
 
-	field = of_get_property(np, "enabled", NULL);
-	if (!field || (field && (0 == *field)))
+	if (!of_device_is_available(np))
 		return -EINVAL;
 
 	i2c = kzalloc(sizeof(*i2c), GFP_KERNEL);
diff --git a/drivers/mtd/nand/lsi_acp_nand.c b/drivers/mtd/nand/lsi_acp_nand.c
index ddc58e3..0379021 100644
--- a/drivers/mtd/nand/lsi_acp_nand.c
+++ b/drivers/mtd/nand/lsi_acp_nand.c
@@ -3447,11 +3447,8 @@ lsi_nand_init(void)
 		unsigned long nand_length;
 		u64 gpreg_address;
 		unsigned long gpreg_length;
-		const u32 *enabled;
 
-		enabled = of_get_property(np, "enabled", NULL);
-
-		if (!enabled || (enabled && (0 == *enabled))) {
+		if (!of_device_is_available(np)) {
 			pr_err("ACP NAND Controller Isn't Enabled.\n");
 			return -ENODEV;
 		}
diff --git a/drivers/net/ethernet/lsi/lsi_acp_net.c b/drivers/net/ethernet/lsi/lsi_acp_net.c
index 03bb287..0fb6cc1 100644
--- a/drivers/net/ethernet/lsi/lsi_acp_net.c
+++ b/drivers/net/ethernet/lsi/lsi_acp_net.c
@@ -1677,16 +1677,14 @@ static int appnic_probe_config_dt(struct net_device *dev,
 	if (!np)
 		return -ENODEV;
 
+	if (!of_device_is_available(np))
+		return -EINVAL;
+
 #ifdef CONFIG_ARM
 	rx_base = of_iomap(np, 0);
 	tx_base = of_iomap(np, 1);
 	dma_base = of_iomap(np, 2);
 #else
-	field = of_get_property(np, "enabled", NULL);
-
-	if (!field || (field && (0 == *field)))
-		return -EINVAL;
-
 	field = of_get_property(np, "reg", NULL);
 
 	if (!field) {
diff --git a/drivers/spi/spi-pl022.c b/drivers/spi/spi-pl022.c
index b8746e5..ee4fff0 100644
--- a/drivers/spi/spi-pl022.c
+++ b/drivers/spi/spi-pl022.c
@@ -2527,7 +2527,9 @@ pl022_of_probe(struct platform_device *ofdev)
 	int len;
 	struct device_node *of_node = ofdev->dev.of_node;
 	const struct of_device_id *id = of_match_node(pl022_match, of_node);
-	const int *enabled;
+
+	if (!of_device_is_available(of_node))
+		return -ENODEV;
 
 	platform_info = kmalloc(sizeof(struct pl022_ssp_controller),
 		GFP_KERNEL);
diff --git a/drivers/tty/serial/lsi_acp_serial.c b/drivers/tty/serial/lsi_acp_serial.c
index f9676ca..9501273 100644
--- a/drivers/tty/serial/lsi_acp_serial.c
+++ b/drivers/tty/serial/lsi_acp_serial.c
@@ -1017,7 +1017,6 @@ acp_serial_add_ports(struct uart_driver *driver)
 	u64 addr = 0;
 	const u32 *reg, *interrupts, *clk, *speed;
 	int baud_rate = 9600;
-	const int *enabled = NULL;
 
 	for (i = 0; i < ARRAY_SIZE(acp_ports); ++i) {
 		if (acp_ports[i] == NULL)
@@ -1036,59 +1035,41 @@ acp_serial_add_ports(struct uart_driver *driver)
 		goto out;
 	}
 
-	np = of_find_node_by_type(np, "serial");
-
-	while (np && !of_device_is_compatible(np, "acp-uart0"))
+	do {
 		np = of_find_node_by_type(np, "serial");
+	} while (np &&
+		(!of_device_is_compatible(np, "acp-uart0")
+		|| !of_device_is_available(np)));
 
-	if (np)
-		enabled = of_get_property(np, "enabled", NULL);
-
-	if (!enabled) {
-		/*
-		  Older LSI U-Boot package (prior to 4.8.1.36).
-
-		  Only use UART0.  The timer registers are defined
-		  differently in the device tree.
-		*/
-		uap->timer_base = ioremap(0x002000408040ULL, 0x20);
-	} else {
+	if (!np) {
 		/*
 		  Newer LSI U-Boot package (4.8.1.36 on).
 
 		  Only use a serial port if it is enabled.
 		*/
-
-		if (!np || (0 == *enabled)) {
-			np = NULL;
+		do {
 			np = of_find_node_by_type(np, "serial");
+		} while (np &&
+			(!of_device_is_compatible(np, "acp-uart1")
+			 || !of_device_is_available(np)));
+	}
 
-			while (np && !of_device_is_compatible(np, "acp-uart1"))
-				np = of_find_node_by_type(np, "serial");
+	if (np) {
+		reg = of_get_property(np, "clock-reg", NULL);
 
-			if (np)
-				enabled = of_get_property(np, "enabled", NULL);
+		if (reg) {
+			addr = of_translate_address(np, reg);
+			if (addr == OF_BAD_ADDR)
+				addr = 0;
 		}
 
-		if (np && (0 != *enabled)) {
-			reg = of_get_property(np, "clock-reg", NULL);
-
-			if (reg) {
-				addr = of_translate_address(np, reg);
-				if (addr == OF_BAD_ADDR)
-					addr = 0;
-			}
-
-			if (addr)
-				uap->timer_base = ioremap(addr, reg[1]);
-			else {
-				pr_err("timer io address not found\n");
-				ret = -ENOMEM;
-			}
+		if (addr)
+			uap->timer_base = ioremap(addr, reg[1]);
+		else {
+			pr_err(KERN_ERR "timer io address not found\n");
+			ret = -ENOMEM;
 		}
-	}
 
-	if (np) {
 		reg = of_get_property(np, "reg", NULL);
 
 		if (reg) {
-- 
1.7.1

