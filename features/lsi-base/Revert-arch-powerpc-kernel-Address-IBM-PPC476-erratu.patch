From 0ef58cf8b1dc9b49823ae74d2949442a6e44fabd Mon Sep 17 00:00:00 2001
From: Li Wang <li.wang@windriver.com>
Date: Fri, 24 Apr 2015 15:22:34 +0800
Subject: [PATCH 4/9] Revert "arch/powerpc/kernel: Address IBM PPC476 erratum
 48"

git://git.yoctoproject.org/linux-yocto-3.4
commit 8b53093ab022bc4b4c949ee7219425ee834755d0

This reverts commit be12b74ad8fae321bc039e386deb1f4579451546.

Signed-off-by: Li Wang <li.wang@windriver.com>
---
 arch/powerpc/kernel/head_44x.S |   41 +++++-----------------------------
 arch/powerpc/kernel/traps.c    |   47 ----------------------------------------
 2 files changed, 6 insertions(+), 82 deletions(-)

diff --git a/arch/powerpc/kernel/head_44x.S b/arch/powerpc/kernel/head_44x.S
index 459646b..9f16b78 100644
--- a/arch/powerpc/kernel/head_44x.S
+++ b/arch/powerpc/kernel/head_44x.S
@@ -632,8 +632,8 @@ finish_tlb_load_44x:
 
 	andc.	r13,r13,r12		/* Check permission */
 
-	 /* Jump to tlb data load */
-	beq	finish_tlb_load_data_47x
+	 /* Jump to common tlb load */
+	beq	finish_tlb_load_47x
 
 2:	/* The bailout.  Restore registers to pre-exception conditions
 	 * and call the heavyweights to help us out.
@@ -652,7 +652,6 @@ finish_tlb_load_44x:
 	 * information from different registers and bailout
 	 * to a different point.
 	 */
-	.globl InstructionTLBError47x
 	START_EXCEPTION(InstructionTLBError47x)
 	mtspr	SPRN_SPRG_WSCRATCH0,r10	/* Save some working registers */
 	mtspr	SPRN_SPRG_WSCRATCH1,r11
@@ -716,8 +715,8 @@ finish_tlb_load_44x:
 
 	andc.	r13,r13,r12		/* Check permission */
 
-	/* Jump to TLB instruction load point */
-	beq	finish_tlb_load_instruction_47x
+	/* Jump to common TLB load point */
+	beq	finish_tlb_load_47x
 
 2:	/* The bailout.  Restore registers to pre-exception conditions
 	 * and call the heavyweights to help us out.
@@ -731,8 +730,7 @@ finish_tlb_load_44x:
 	b	InstructionStorage
 
 /*
- * The instruction data TLB miss gets to finish_tlb_load_instruction_47x
- * and data TLB miss gets to finish_tlb_load_data_47x
+ * Both the instruction and data TLB miss get to this
  * point to load the TLB.
  * 	r10 - free to use
  * 	r11 - PTE high word value
@@ -741,34 +739,7 @@ finish_tlb_load_44x:
  *	MMUCR - loaded with proper value when we get here
  *	Upon exit, we reload everything and RFI.
  */
-finish_tlb_load_data_47x:
-	/* Combine RPN & ERPN an write WS 1 */
-	rlwimi	r11,r12,0,0,31-PAGE_SHIFT
-	tlbwe	r11,r13,1
-
-	/* And make up word 2 */
-	li	r10,0xf85			/* Mask to apply from PTE */
-	rlwimi	r10,r12,29,30,30		/* DIRTY -> SW position */
-	and	r11,r12,r10			/* Mask PTE bits to keep */
-	andi.	r10,r12,_PAGE_USER		/* User page ? */
-	beq	1f				/* nope, leave U bits empty */
-	rlwimi	r11,r11,3,26,28			/* yes, copy S bits to U */
-1:	tlbwe	r11,r13,2
-
-	mfspr   r10,SPRN_DEAR
-	dcbt    0,r10
-
-	/* Done...restore registers and get out of here.
-	*/
-	mfspr	r11, SPRN_SPRG_RSCRATCH4
-	mtcr	r11
-	mfspr	r13, SPRN_SPRG_RSCRATCH3
-	mfspr	r12, SPRN_SPRG_RSCRATCH2
-	mfspr	r11, SPRN_SPRG_RSCRATCH1
-	mfspr	r10, SPRN_SPRG_RSCRATCH0
-	rfi
-	.globl finish_tlb_load_instruction_47x
-finish_tlb_load_instruction_47x:
+finish_tlb_load_47x:
 	/* Combine RPN & ERPN an write WS 1 */
 	rlwimi	r11,r12,0,0,31-PAGE_SHIFT
 	tlbwe	r11,r13,1
diff --git a/arch/powerpc/kernel/traps.c b/arch/powerpc/kernel/traps.c
index 096cb20..3eb03b7 100644
--- a/arch/powerpc/kernel/traps.c
+++ b/arch/powerpc/kernel/traps.c
@@ -37,10 +37,6 @@
 #include <linux/ratelimit.h>
 #include <linux/context_tracking.h>
 
-#include <asm/mmu.h>
-#include <asm/page.h>
-#include <asm/dcr-native.h>
-
 #include <asm/emulated_ops.h>
 #include <asm/pgtable.h>
 #include <asm/uaccess.h>
@@ -669,56 +665,13 @@ int machine_check_generic(struct pt_regs *regs)
 }
 #endif /* everything else */
 
-extern unsigned int finish_tlb_load_instruction_47x;
-extern unsigned int InstructionTLBError47x;
-
 void machine_check_exception(struct pt_regs *regs)
 {
 	enum ctx_state prev_state = exception_enter();
 	int recover = 0;
-	unsigned int cpu;
-	unsigned int p2a_status;
-	unsigned int p2a_address;
-	unsigned int l2plbstats1;
-	unsigned int mcsr;
-	unsigned int mcsr0;
 
 	__get_cpu_var(irq_stat).mce_exceptions++;
 
-	mcsr = mfspr(SPRN_MCSR);
-	mcsr0 = mfspr(SPRN_MCSRR0);
-	p2a_status = mfdcr(0x100C) & 0x00000010;
-	p2a_address = mfdcr(0x1045);
-	p2a_address = (p2a_address << 4) & 0x000FFFF0;
-	cpu = smp_processor_id();
-	if (cpu < 4) {
-		mtdcr((cpu + 3) * 256, 0x304);
-		l2plbstats1 = mfdcr((cpu + 3) * 256 + 4);
-	} else {
-		mtdcr((cpu + 9)*256, 0x304);
-		l2plbstats1 = mfdcr((cpu + 9) * 256 + 4);
-	}
-
-	if (((mcsr & 0x80200000) == 0x80200000) &&
-		(InstructionTLBError47x < mcsr0) &&
-		(mcsr0 < finish_tlb_load_instruction_47x) &&
-		(p2a_status == 0x00000010) &&
-		(l2plbstats1 == 0x000C0000)) {
-		if (cpu < 4) {
-			mtdcr((cpu + 3) * 256 + 4,
-				0x000C0000);
-		} else {
-			mtdcr((cpu + 9) * 256 + 4,
-				0x000C0000);
-		}
-		printk(KERN_INFO "machine_check_exception: Core %d: MCSR=0x%x l2plbstats1=0x%x",
-		cpu, mcsr, l2plbstats1);
-		mtdcr(0x100C, 0xFFFFFFFF);
-		mtspr(SPRN_MCSR, 0);
-		recover = 1;
-		return;
-	}
-
 	/* See if any machine dependent calls. In theory, we would want
 	 * to call the CPU first, and call the ppc_md. one if the CPU
 	 * one returns a positive number. However there is existing code
-- 
1.7.5.4

