From 733654225e412ae3bbd7015018e95d5acfc92df1 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Fri, 4 Apr 2014 03:01:40 +0000
Subject: [PATCH 165/175] gpio:pl061:allow working without irq support

Allow pl061 driver working without irq support.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/gpio/gpio-pl061.c |   13 +++++++------
 1 files changed, 7 insertions(+), 6 deletions(-)

diff --git a/drivers/gpio/gpio-pl061.c b/drivers/gpio/gpio-pl061.c
index 4c8b4b7..116af90 100644
--- a/drivers/gpio/gpio-pl061.c
+++ b/drivers/gpio/gpio-pl061.c
@@ -283,8 +283,6 @@ static int pl061_probe(struct device *dev,
 	if (pdata) {
 		chip->gc.base = pdata->gpio_base;
 		irq_base = pdata->irq_base;
-		if (irq_base <= 0)
-			return -ENODEV;
 	} else if (dev->of_node) {
 		chip->gc.base = -1;
 		irq_base = 0;
@@ -336,6 +334,8 @@ static int pl061_probe(struct device *dev,
 	/*
 	 * irq_chip support
 	 */
+	if (irq_base <= 0)
+		return 0;
 	writeb(0, chip->base + GPIOIE); /* disable irqs */
 	if (irq < 0) {
 		if (retchip)
@@ -345,11 +345,12 @@ static int pl061_probe(struct device *dev,
 
 	irq_set_chained_handler(irq, pl061_irq_handler);
 	irq_set_handler_data(irq, chip);
-
-	chip->domain = irq_domain_add_simple(dev->of_node, PL061_GPIO_NR,
+	if (irq_base > 0) {
+		chip->domain = irq_domain_add_simple(dev->of_node, PL061_GPIO_NR,
 					     irq_base, &pl061_domain_ops, chip);
-	if (!chip->domain)
-		return -ENODEV;
+		if (!chip->domain)
+			return -ENODEV;
+	}
 
 	for (i = 0; i < PL061_GPIO_NR; i++) {
 		if (pdata) {
-- 
1.7.1

