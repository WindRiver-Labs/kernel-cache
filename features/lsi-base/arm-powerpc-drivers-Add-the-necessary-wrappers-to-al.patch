From 212fd5dd06eca76452107b6a5ee7b428bead496c Mon Sep 17 00:00:00 2001
From: John Jacques <john.jacques@lsi.com>
Date: Fri, 13 Sep 2013 18:00:31 -0500
Subject: [PATCH 100/159] arm-powerpc-drivers: Add the necessary wrappers to
 all architectures.

git.yoctoproject.org/git/linux-yocto-3.10
commit ce0fd9f4c9fbe16699934f9c91b956cf44535b7e standard/axxia/base.

Signed-off-by: John Jacques <john.jacques@lsi.com>
---
 arch/arm/include/asm/lsi/acp_ncr.h      |    4 +-
 arch/arm/mach-axxia/Makefile            |    1 -
 arch/arm/mach-axxia/wrappers.c          |   80 ------------
 arch/powerpc/include/asm/lsi/acp_ncr.h  |    4 +-
 drivers/net/ethernet/lsi/lsi_acp_mdio.c |  203 +++++++++++++++++++++++++++++--
 drivers/net/ethernet/lsi/lsi_acp_net.c  |   18 ++--
 6 files changed, 203 insertions(+), 107 deletions(-)
 delete mode 100644 arch/arm/mach-axxia/wrappers.c

diff --git a/arch/arm/include/asm/lsi/acp_ncr.h b/arch/arm/include/asm/lsi/acp_ncr.h
index 1a08f07..114a36b 100644
--- a/arch/arm/include/asm/lsi/acp_ncr.h
+++ b/arch/arm/include/asm/lsi/acp_ncr.h
@@ -39,7 +39,7 @@ int ncr_write(unsigned long, unsigned long, int, void *);
 
 int is_asic(void);
 
-extern int acp_mdio_read(unsigned long, unsigned long, unsigned short *);
-extern int acp_mdio_write(unsigned long, unsigned long, unsigned short);
+extern int acp_mdio_read(unsigned long, unsigned long, unsigned short *, int);
+extern int acp_mdio_write(unsigned long, unsigned long, unsigned short, int);
 
 #endif /*  __DRIVERS_LSI_ACP_NCR_H */
diff --git a/arch/arm/mach-axxia/Makefile b/arch/arm/mach-axxia/Makefile
index e2f59cb..6282d36 100644
--- a/arch/arm/mach-axxia/Makefile
+++ b/arch/arm/mach-axxia/Makefile
@@ -1,7 +1,6 @@
 #
 # Makefile for the linux kernel.
 #
-obj-y					:= wrappers.o
 obj-y					+= axxia.o
 obj-y					+= clock.o
 obj-y                                   += io.o
diff --git a/arch/arm/mach-axxia/wrappers.c b/arch/arm/mach-axxia/wrappers.c
deleted file mode 100644
index 54d2021..0000000
--- a/arch/arm/mach-axxia/wrappers.c
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * arch/arm/mach-axxia/wrappers.c
- *
- * Copyright (C) 2013 LSI
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
- */
-
-/*
-  ==============================================================================
-  ==============================================================================
-  Platform Device Registration
-  ==============================================================================
-  ==============================================================================
-*/
-
-#include <linux/platform_device.h>
-
-/*
-  ------------------------------------------------------------------------------
-  acp_platform_device_register
-*/
-
-int
-acp_platform_device_register(struct platform_device *pdev)
-{
-	return platform_device_register(pdev);
-}
-
-EXPORT_SYMBOL(acp_platform_device_register);
-
-/*
-  ------------------------------------------------------------------------------
-  acp_platform_device_unregister
-*/
-
-void
-acp_platform_device_unregister(struct platform_device *pdev)
-{
-	platform_device_unregister(pdev);
-
-	return;
-}
-
-EXPORT_SYMBOL(acp_platform_device_unregister);
-
-/*
-  ==============================================================================
-  ==============================================================================
-  Interrupts
-  ==============================================================================
-  ==============================================================================
-*/
-
-#include <linux/irqdomain.h>
-
-/*
-  ------------------------------------------------------------------------------
-  acp_irq_create_mapping
-*/
-
-unsigned int
-acp_irq_create_mapping(struct irq_domain *host, irq_hw_number_t hwirq)
-{
-        return irq_create_mapping(host, hwirq);
-}
-
-EXPORT_SYMBOL(acp_irq_create_mapping);
diff --git a/arch/powerpc/include/asm/lsi/acp_ncr.h b/arch/powerpc/include/asm/lsi/acp_ncr.h
index 1a08f07..114a36b 100644
--- a/arch/powerpc/include/asm/lsi/acp_ncr.h
+++ b/arch/powerpc/include/asm/lsi/acp_ncr.h
@@ -39,7 +39,7 @@ int ncr_write(unsigned long, unsigned long, int, void *);
 
 int is_asic(void);
 
-extern int acp_mdio_read(unsigned long, unsigned long, unsigned short *);
-extern int acp_mdio_write(unsigned long, unsigned long, unsigned short);
+extern int acp_mdio_read(unsigned long, unsigned long, unsigned short *, int);
+extern int acp_mdio_write(unsigned long, unsigned long, unsigned short, int);
 
 #endif /*  __DRIVERS_LSI_ACP_NCR_H */
diff --git a/drivers/net/ethernet/lsi/lsi_acp_mdio.c b/drivers/net/ethernet/lsi/lsi_acp_mdio.c
index ef78adcd..85c02bc 100644
--- a/drivers/net/ethernet/lsi/lsi_acp_mdio.c
+++ b/drivers/net/ethernet/lsi/lsi_acp_mdio.c
@@ -25,6 +25,8 @@
 #include <linux/io.h>
 #include <linux/of_address.h>
 #include <linux/irqdomain.h>
+#include <linux/skbuff.h>
+#include <linux/platform_device.h>
 
 /*
   ==============================================================================
@@ -61,7 +63,7 @@ static DEFINE_SPINLOCK(mdio_lock);
 
 int
 acp_mdio_read(unsigned long address, unsigned long offset,
-	      unsigned short *value)
+	      unsigned short *value, int clause45)
 {
 	unsigned long command = 0;
 	unsigned long status;
@@ -75,11 +77,53 @@ acp_mdio_read(unsigned long address, unsigned long offset,
 	WRITE(MDIO_STATUS_RD_DATA, status);
 #endif				/* BZ33327_WA */
 
-	/* Write the command. */
-	command |= 0x10000000;	/* op_code: read */
-	command |= (address & 0x1f) << 16;	/* port_addr (target device) */
-	command |= (offset & 0x1f) << 21;/* device_addr (target register) */
-	WRITE(MDIO_CONTROL_RD_DATA, command);
+    if(clause45 == 0) {
+    	/* Write the command. */
+    	command |= 0x10000000;	/* op_code: read */
+    	command |= (address & 0x1f) << 16;	/* port_addr (target device) */
+    	command |= (offset & 0x1f) << 21;/* device_addr (target register) */
+    	WRITE(MDIO_CONTROL_RD_DATA, command);
+    } else {
+        /* 
+         * Step 1: Write the address. 
+         */
+         
+    	/* Write the address */
+        command |= 0x20000000; /* clause_45 = 1 */
+    	command |= 0x00000000;	/* op_code: write */
+        command |= 0x04000000; /* interface_select = 1 */
+        command |= ((offset & 0x001f0000) >> 3); /* device_addr (target device_type) */
+    	command |= (address & 0x1f) << 16; /* port_addr (target device) */
+        command |= (offset & 0xffff); /*  	addr_or_data (target register) */
+    	WRITE(MDIO_CONTROL_RD_DATA, command);
+
+    	/* Wait for the mdio_busy (status) bit to clear. */
+    	do {
+    		status = READ(MDIO_STATUS_RD_DATA);
+    	} while (0 != (status & 0x40000000));
+
+    	/* Wait for the mdio_busy (control) bit to clear. */
+    	do {
+    		command = READ(MDIO_CONTROL_RD_DATA);
+    	} while (0 != (command & 0x80000000));
+
+        /* 
+         * Step 2: Read the value. 
+         */
+
+        /* Set the mdio_busy (status) bit. */
+    	status = READ(MDIO_STATUS_RD_DATA);
+    	status |= 0x40000000;
+    	WRITE(MDIO_STATUS_RD_DATA, status);
+
+        command = 0;
+        command |= 0x20000000; /* clause_45 = 1 */
+        command |= 0x10000000;	/* op_code: read */
+        command |= 0x04000000; /* interface_select = 1 */
+        command |= ((offset & 0x001f0000) >> 3); /* device_addr (target device_type) */
+        command |= (address & 0x1f) << 16; /* port_addr (target device) */
+        WRITE(MDIO_CONTROL_RD_DATA, command);
+    }
 
 #if defined(BZ33327_WA)
 	/* Wait for the mdio_busy (status) bit to clear. */
@@ -107,7 +151,7 @@ EXPORT_SYMBOL(acp_mdio_read);
 
 int
 acp_mdio_write(unsigned long address, unsigned long offset,
-	       unsigned short value)
+	       unsigned short value, int clause45)
 {
 	unsigned long command = 0;
 	unsigned long status;
@@ -127,12 +171,55 @@ acp_mdio_write(unsigned long address, unsigned long offset,
 	WRITE(MDIO_STATUS_RD_DATA, status);
 #endif				/* BZ33327_WA */
 
-	/* Write the command. */
-	command = 0x08000000;	/* op_code: write */
-	command |= (address & 0x1f) << 16;	/* port_addr (target device) */
-	command |= (offset & 0x1f) << 21;/* device_addr (target register) */
-	command |= (value & 0xffff);	/* value */
-	WRITE(MDIO_CONTROL_RD_DATA, command);
+    if(clause45 == 0) {
+    	/* Write the command. */
+    	command = 0x08000000;	/* op_code: write */
+    	command |= (address & 0x1f) << 16;	/* port_addr (target device) */
+    	command |= (offset & 0x1f) << 21;/* device_addr (target register) */
+    	command |= (value & 0xffff);	/* value */
+    	WRITE(MDIO_CONTROL_RD_DATA, command);
+    } else {
+        /* 
+         * Step 1: Write the address. 
+         */
+         
+    	/* Write the address */
+        command |= 0x20000000; /* clause_45 = 1 */
+    	command |= 0x08000000;	/* op_code: write */
+        command |= 0x04000000; /* interface_select = 1 */
+        command |= ((offset & 0x001f0000) >> 3); /* device_addr (target device_type) */
+    	command |= (address & 0x1f) << 16; /* port_addr (target device) */
+        command |= (offset & 0xffff); /*  	addr_or_data (target register) */
+    	WRITE(MDIO_CONTROL_RD_DATA, command);
+
+    	/* Wait for the mdio_busy (status) bit to clear. */
+    	do {
+    		status = READ(MDIO_STATUS_RD_DATA);
+    	} while (0 != (status & 0x40000000));
+
+    	/* Wait for the mdio_busy (control) bit to clear. */
+    	do {
+    		command = READ(MDIO_CONTROL_RD_DATA);
+    	} while (0 != (command & 0x80000000));
+
+        /* 
+         * Step 2: Write the value. 
+         */
+
+        /* Set the mdio_busy (status) bit. */
+    	status = READ(MDIO_STATUS_RD_DATA);
+    	status |= 0x40000000;
+    	WRITE(MDIO_STATUS_RD_DATA, status);
+
+        command = 0;
+        command |= 0x20000000; /* clause_45 = 1 */
+        command |= 0x08000000;	/* op_code: write */
+        command |= 0x04000000; /* interface_select = 1 */
+        command |= ((offset & 0x001f0000) >> 3); /* device_addr (target device_type) */
+        command |= (address & 0x1f) << 16; /* port_addr (target device) */
+        command |= (value & 0xffff); /*  	addr_or_data = value */
+        WRITE(MDIO_CONTROL_RD_DATA, command);
+    }
 
 #if defined(BZ33327_WA)
 	/* Wait for the mdio_busy (status) bit to clear. */
@@ -174,6 +261,96 @@ acp_mdio_initialize(void)
 #endif /* ! CONFIG_ACPISS */
 
 /*
+  ==============================================================================
+  ==============================================================================
+  Platform Device Registration
+  ==============================================================================
+  ==============================================================================
+*/
+
+/*
+  ------------------------------------------------------------------------------
+  acp_platform_device_register
+*/
+
+int
+acp_platform_device_register(struct platform_device *pdev)
+{
+	return platform_device_register(pdev);
+}
+
+EXPORT_SYMBOL(acp_platform_device_register);
+
+/*
+  ------------------------------------------------------------------------------
+  acp_platform_device_unregister
+*/
+
+void
+acp_platform_device_unregister(struct platform_device *pdev)
+{
+	platform_device_unregister(pdev);
+
+	return;
+}
+
+EXPORT_SYMBOL(acp_platform_device_unregister);
+
+/*
+  ============================================================================
+  ============================================================================
+  SKB
+  ============================================================================
+  ============================================================================
+*/
+
+/*
+  ----------------------------------------------------------------------------
+  acp_skb_tstamp_tx
+*/
+
+void
+acp_skb_tstamp_tx(struct sk_buff *orig_skb,
+		  struct skb_shared_hwtstamps *hwtstamps) {
+	skb_tstamp_tx(orig_skb, hwtstamps);
+}
+
+EXPORT_SYMBOL(acp_skb_tstamp_tx);
+
+/*
+  ============================================================================
+  ============================================================================
+  Interrupts
+  ============================================================================
+  ============================================================================
+*/
+
+/*
+ * -------------------------------------------------------------------------
+ * acp_irq_create_mapping
+ */
+unsigned int acp_irq_create_mapping(struct irq_domain *host,
+				    irq_hw_number_t hwirq)
+{
+	unsigned int mapped_irq;
+
+	preempt_disable();
+	mapped_irq = irq_create_mapping(host, hwirq);
+	preempt_enable();
+
+	return mapped_irq;
+}
+EXPORT_SYMBOL(acp_irq_create_mapping);
+
+/*
+  ==============================================================================
+  ==============================================================================
+  Linux Stuff
+  ==============================================================================
+  ==============================================================================
+*/
+
+/*
   ------------------------------------------------------------------------------
   acp_wrappers_init
 */
diff --git a/drivers/net/ethernet/lsi/lsi_acp_net.c b/drivers/net/ethernet/lsi/lsi_acp_net.c
index 5244040..0fe090e 100644
--- a/drivers/net/ethernet/lsi/lsi_acp_net.c
+++ b/drivers/net/ethernet/lsi/lsi_acp_net.c
@@ -123,7 +123,7 @@ static int appnic_mii_read(struct mii_bus *bus, int phy, int reg)
 	unsigned short value;
 
 	/* Always returns success, so no need to check return status. */
-	acp_mdio_read(phy, reg, &value);
+	acp_mdio_read(phy, reg, &value, 0);
 
 	return (int)value;
 }
@@ -135,7 +135,7 @@ static int appnic_mii_read(struct mii_bus *bus, int phy, int reg)
 
 static int appnic_mii_write(struct mii_bus *bus, int phy, int reg, u16 val)
 {
-	return acp_mdio_write(phy, reg, val);
+	return acp_mdio_write(phy, reg, val, 0);
 }
 
 /*
@@ -277,27 +277,27 @@ skip_first:
 
 #ifdef AMARILLO_WA
 	/*
-	 * For Amarillo, without the auto-negotiate ecn.
+	 * For the Amarillo, without the auto-negotiate ecn.
 	 */
 	{
 		u16 val;
 		int rc;
 
 		/* Enable access to shadow register @ 0x1d */
-		rc = acp_mdio_read(phydev->addr, PHY_BCM_TEST_REG, &val);
+		rc = acp_mdio_read(phydev->addr, PHY_BCM_TEST_REG, &val, 0);
 		val |= 0x80;
-		rc |= acp_mdio_write(phydev->addr, PHY_BCM_TEST_REG, val);
+		rc |= acp_mdio_write(phydev->addr, PHY_BCM_TEST_REG, val, 0);
 
 		/* Set RX FIFO size to 0x7 */
-		rc |= acp_mdio_read(phydev->addr, PHY_AUXILIARY_MODE3, &val);
+		rc |= acp_mdio_read(phydev->addr, PHY_AUXILIARY_MODE3, &val, 0);
 		val &= 0xf;
 		val |= 0x7;
-		rc |= acp_mdio_write(phydev->addr, PHY_AUXILIARY_MODE3, val);
+		rc |= acp_mdio_write(phydev->addr, PHY_AUXILIARY_MODE3, val, 0);
 
 		/* Disable access to shadow register @ 0x1d */
-		rc |= acp_mdio_read(phydev->addr, PHY_BCM_TEST_REG, &val);
+		rc |= acp_mdio_read(phydev->addr, PHY_BCM_TEST_REG, &val, 0);
 		val &= ~0x80;
-		rc |= acp_mdio_write(phydev->addr, PHY_BCM_TEST_REG, val);
+		rc |= acp_mdio_write(phydev->addr, PHY_BCM_TEST_REG, val, 0);
 
 		if (0 != rc)
 			return -EIO;
-- 
1.7.5.4

