From 8cdd283c9f8cda67eaf869696952aa48e1e0c6f7 Mon Sep 17 00:00:00 2001
From: David Mercado <david.mercado@windriver.com>
Date: Wed, 20 Nov 2013 14:07:48 -0500
Subject: [PATCH 141/159] LSI AXM55XX SIM: Update VMFS for 3.10

git.yoctoproject.org/git/linux-yocto-3.10
commit 8d840966199aad4e237f281ddd9129bbc03c44b7 standard/axxia/base.

Signed-off-by: David Mercado <david.mercado@windriver.com>
---
 fs/vmfs/dir.c        |   24 ++++++++++++------------
 fs/vmfs/file.c       |    4 ++--
 fs/vmfs/getopt.c     |    2 +-
 fs/vmfs/inode.c      |   12 ++++++------
 fs/vmfs/ioctl.c      |    4 ++--
 fs/vmfs/vmfs.h       |    5 +++--
 fs/vmfs/vmfs_mount.h |    6 +++---
 7 files changed, 29 insertions(+), 28 deletions(-)

diff --git a/fs/vmfs/dir.c b/fs/vmfs/dir.c
index d8df11b..23162a7 100644
--- a/fs/vmfs/dir.c
+++ b/fs/vmfs/dir.c
@@ -28,15 +28,15 @@ static int vmfs_readdir(struct file *, void *, filldir_t);
 static int vmfs_dir_open(struct inode *, struct file *);
 
 static struct dentry *vmfs_lookup(struct inode *, struct dentry *,
-				  struct nameidata *);
-static int vmfs_create(struct inode *, struct dentry *, int,
-		       struct nameidata *);
-static int vmfs_mkdir(struct inode *, struct dentry *, int);
+				  unsigned int flags);
+static int vmfs_create(struct inode *, struct dentry *, umode_t,
+		       bool excl);
+static int vmfs_mkdir(struct inode *, struct dentry *, umode_t);
 static int vmfs_rmdir(struct inode *, struct dentry *);
 static int vmfs_unlink(struct inode *, struct dentry *);
 static int vmfs_rename(struct inode *, struct dentry *,
 		       struct inode *, struct dentry *);
-static int vmfs_make_node(struct inode *, struct dentry *, int, dev_t);
+static int vmfs_make_node(struct inode *, struct dentry *, umode_t, dev_t);
 static int vmfs_link(struct dentry *, struct inode *, struct dentry *);
 
 const struct file_operations vmfs_dir_operations = {
@@ -256,7 +256,7 @@ static int vmfs_dir_open(struct inode *dir, struct file *file)
 /*
  * Dentry operations routines
  */
-static int vmfs_lookup_validate(struct dentry *, struct nameidata *);
+static int vmfs_lookup_validate(struct dentry *, unsigned int flags);
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 38)
 static int vmfs_delete_dentry(struct dentry *);
 #else
@@ -272,7 +272,7 @@ static struct dentry_operations vmfs__dentry_operations_case = {
 /*
  * This is the callback when the dcache has a lookup hit.
  */
-static int vmfs_lookup_validate(struct dentry *dentry, struct nameidata *nd)
+static int vmfs_lookup_validate(struct dentry *dentry, unsigned int flags)
 {
 	struct vmfs_sb_info *server = server_from_dentry(dentry);
 	struct inode *inode = dentry->d_inode;
@@ -377,7 +377,7 @@ void vmfs_renew_times(struct dentry *dentry)
 }
 
 static struct dentry *vmfs_lookup(struct inode *dir, struct dentry *dentry,
-				  struct nameidata *nd)
+				  unsigned int flags)
 {
 	struct vmfs_fattr finfo;
 	struct inode *inode;
@@ -469,8 +469,8 @@ out_close:
 
 /* N.B. How should the mode argument be used? */
 static int
-vmfs_create(struct inode *dir, struct dentry *dentry, int mode,
-	    struct nameidata *nd)
+vmfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
+	    bool excl)
 {
 	int32_t fileid;
 	int error;
@@ -492,7 +492,7 @@ vmfs_create(struct inode *dir, struct dentry *dentry, int mode,
 }
 
 /* N.B. How should the mode argument be used? */
-static int vmfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+static int vmfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 {
 	int error;
 
@@ -596,7 +596,7 @@ out:
  * matches the connection credentials (and we don't know which those are ...)
  */
 static int
-vmfs_make_node(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
+vmfs_make_node(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)
 {
 	return -EINVAL;
 }
diff --git a/fs/vmfs/file.c b/fs/vmfs/file.c
index 833e7a7..18a403f 100644
--- a/fs/vmfs/file.c
+++ b/fs/vmfs/file.c
@@ -33,7 +33,7 @@ static int
 vmfs_fsync(struct file *file, struct dentry *dentry, int datasync)
 {
 #else
-vmfs_fsync(struct file *file, int datasync)
+vmfs_fsync(struct file *file, loff_t start, loff_t end, int datasync)
 {
 	struct dentry *dentry = file->f_path.dentry;
 #endif
@@ -456,7 +456,7 @@ vmfs_file_permission(struct inode *inode, int mask, struct nameidata *nd)
 #elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 38)
 vmfs_file_permission(struct inode *inode, int mask)
 #else
-vmfs_file_permission(struct inode *inode, int mask, unsigned int flags)
+vmfs_file_permission(struct inode *inode, int mask)
 #endif
 {
 	int mode = inode->i_mode;
diff --git a/fs/vmfs/getopt.c b/fs/vmfs/getopt.c
index d5a76c8..7fa20e5 100644
--- a/fs/vmfs/getopt.c
+++ b/fs/vmfs/getopt.c
@@ -43,7 +43,7 @@ int vmfs_getopt(char *caller, char **options, struct option *opts,
 	if (val != NULL) {
 		*val++ = 0;
 		if (value)
-			*value = kstrtoul(val, NULL, 0);
+			*value = kstrtoul(val, 0, NULL);
 		*optarg = val;
 	}
 
diff --git a/fs/vmfs/inode.c b/fs/vmfs/inode.c
index 2d92cf2..713da0d 100644
--- a/fs/vmfs/inode.c
+++ b/fs/vmfs/inode.c
@@ -54,7 +54,7 @@ DEFINE_MUTEX(vmfs_mutex);
 static void vmfs_delete_inode(struct inode *);
 static void vmfs_put_super(struct super_block *);
 static int vmfs_statfs(struct dentry *, struct kstatfs *);
-static int vmfs_show_options(struct seq_file *, struct vfsmount *);
+static int vmfs_show_options(struct seq_file *, struct dentry *);
 
 static struct kmem_cache *vmfs_inode_cachep;
 
@@ -337,7 +337,7 @@ static void vmfs_delete_inode(struct inode *ino)
  * It tries to avoid showing settings that were not changed from their
  * defaults.
  */
-static int vmfs_show_options(struct seq_file *s, struct vfsmount *m)
+static int vmfs_show_options(struct seq_file *s, struct dentry *m)
 {
 
 	return 0;
@@ -486,10 +486,10 @@ int vmfs_notify_change(struct dentry *dentry, struct iattr *attr)
 		goto out;
 
 	error = -EPERM;
-	if ((attr->ia_valid & ATTR_UID) && (attr->ia_uid != server->mnt->uid))
+	if ((attr->ia_valid & ATTR_UID) && ((attr->ia_uid).val != (server->mnt->uid).val))
 		goto out;
 
-	if ((attr->ia_valid & ATTR_GID) && (attr->ia_uid != server->mnt->gid))
+	if ((attr->ia_valid & ATTR_GID) && ((attr->ia_gid).val != (server->mnt->gid).val))
 		goto out;
 
 	if ((attr->ia_valid & ATTR_MODE) && (attr->ia_mode & ~mask))
@@ -508,9 +508,9 @@ int vmfs_notify_change(struct dentry *dentry, struct iattr *attr)
 		error = server->ops->truncate(inode, attr->ia_size);
 		if (error)
 			goto out;
-		error = vmtruncate(inode, attr->ia_size);
+		/*error = vmtruncate(inode, attr->ia_size);
 		if (error)
-			goto out;
+			goto out;*/
 		refresh = 1;
 	}
 
diff --git a/fs/vmfs/ioctl.c b/fs/vmfs/ioctl.c
index b08531e..988e69c 100644
--- a/fs/vmfs/ioctl.c
+++ b/fs/vmfs/ioctl.c
@@ -34,11 +34,11 @@ long vmfs_unlocked_ioctl(struct file *filp, unsigned int cmd,
 		uid16_t uid16;
 		uid_t uid32;
 	case VMFS_IOC_GETMOUNTUID:
-		SET_UID(uid16, server->mnt->mounted_uid);
+		SET_UID(uid16, (server->mnt->mounted_uid).val);
 		result = put_user(uid16, (uid16_t __user *) arg);
 		break;
 	case VMFS_IOC_GETMOUNTUID32:
-		SET_UID(uid32, server->mnt->mounted_uid);
+		SET_UID(uid32, (server->mnt->mounted_uid).val);
 		result = put_user(uid32, (uid_t __user *) arg);
 		break;
 	default:
diff --git a/fs/vmfs/vmfs.h b/fs/vmfs/vmfs.h
index 82a5c64..ed01b51 100644
--- a/fs/vmfs/vmfs.h
+++ b/fs/vmfs/vmfs.h
@@ -11,6 +11,7 @@
 
 #include <linux/types.h>
 #include <linux/magic.h>
+#include <linux/uidgid.h>
 
 #ifdef __KERNEL__
 
@@ -26,8 +27,8 @@ struct vmfs_fattr {
 	unsigned long f_ino;
 	umode_t f_mode;
 	nlink_t f_nlink;
-	uid_t f_uid;
-	gid_t f_gid;
+	kuid_t f_uid;
+	kgid_t f_gid;
 	dev_t f_rdev;
 	loff_t f_size;
 	struct timespec f_atime;
diff --git a/fs/vmfs/vmfs_mount.h b/fs/vmfs/vmfs_mount.h
index 2dc784d..56123cc 100644
--- a/fs/vmfs/vmfs_mount.h
+++ b/fs/vmfs/vmfs_mount.h
@@ -45,9 +45,9 @@ struct vmfs_mount_data {
 struct vmfs_mount_data_kernel {
 	int version;
 
-	uid_t mounted_uid;	/* Who may umount() this filesystem? */
-	uid_t uid;
-	gid_t gid;
+	kuid_t mounted_uid;	/* Who may umount() this filesystem? */
+	kuid_t uid;
+	kgid_t gid;
 	mode_t file_mode;
 	mode_t dir_mode;
 
-- 
1.7.5.4

