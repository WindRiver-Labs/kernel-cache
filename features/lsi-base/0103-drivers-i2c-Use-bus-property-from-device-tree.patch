From 314c96752ca3c88dba7349d0b9177cbfaf5fad9a Mon Sep 17 00:00:00 2001
From: Anders Berg <anders.berg@lsi.com>
Date: Tue, 17 Sep 2013 21:34:28 +0200
Subject: [PATCH 103/175] drivers/i2c: Use 'bus' property from device tree.

git.yoctoproject.org/git/linux-yocto-3.10
commit 9eb76312dd9b06a631cd65e95b0206cca6c8f5d1 standard/axxia/base.

The i2c-axxia driver uses the 'bus' property on the device node when assigning
the I2C adapters bus number. If the property is omitted, the buses will be
assigned consecutive numbers starting with 0.

Signed-off-by: Anders Berg <anders.berg@lsi.com>
---
 arch/arm/boot/dts/axm55xx.dts  |   17 ++++++++---------
 drivers/i2c/busses/i2c-axxia.c |   13 ++++++-------
 2 files changed, 14 insertions(+), 16 deletions(-)

diff --git a/arch/arm/boot/dts/axm55xx.dts b/arch/arm/boot/dts/axm55xx.dts
index 5f71254..14d2470 100644
--- a/arch/arm/boot/dts/axm55xx.dts
+++ b/arch/arm/boot/dts/axm55xx.dts
@@ -372,22 +372,22 @@
 		};
 	};
 
-	I2C0: i2c@0x02010084000 {
+	i2c@0x02010084000 {
 		#address-cells = <1>;
 		#size-cells = <0>;
 		compatible = "lsi,api2c";
 		device_type = "i2c";
-		port = <0>;
+		bus = <0>;
 		reg = <0x20 0x10084000 0x00 0x1000>;
 		interrupts = <0 19 4>;
 	};
 
-	I2C1: i2c@0x02010085000 {
+	i2c@0x02010085000 {
 		#address-cells = <1>;
 		#size-cells = <0>;
 		compatible = "lsi,api2c";
 		device_type = "i2c";
-		port = <1>;
+		bus = <1>;
 		reg = <0x20 0x10085000 0x00 0x1000>;
 		interrupts = <0 20 4>;
 
@@ -398,23 +398,22 @@
 		};
 	};
 
-	I2C2: i2c@0x02010086000 {
+	i2c@0x02010086000 {
 		#address-cells = <1>;
 		#size-cells = <0>;
 		compatible = "lsi,api2c";
 		device_type = "i2c";
-		port = <2>;
+		bus = <2>;
 		reg = <0x20 0x10086000 0x00 0x1000>;
 		interrupts = <0 21 4>;
 	};
 
-	SMB: i2c@0x02010087000 {
+	i2c@0x02010087000 {
 		#address-cells = <1>;
 		#size-cells = <0>;
 		compatible = "lsi,api2c";
 		device_type = "i2c";
-		port = <3>;
-		bus_name = "smb";
+		bus = <3>;
 		reg = <0x20 0x10087000 0x00 0x1000>;
 		interrupts = <0 22 4>;
 	};
diff --git a/drivers/i2c/busses/i2c-axxia.c b/drivers/i2c/busses/i2c-axxia.c
index c71f521..8061998 100644
--- a/drivers/i2c/busses/i2c-axxia.c
+++ b/drivers/i2c/busses/i2c-axxia.c
@@ -197,14 +197,13 @@ axxia_i2c_init(struct axxia_i2c_dev *idev)
 	/*
 	   Find the prescaler value that makes tmo_clk fit in 15-bits counter.
 	 */
-	for (prescale=0; prescale < 15; ++prescale) {
+	for (prescale = 0; prescale < 15; ++prescale) {
 		if (tmo_clk <= 0x7fff)
 			break;
 		tmo_clk >>= 1;
 	}
-	if (tmo_clk > 0x7fff) {
+	if (tmo_clk > 0x7fff)
 		tmo_clk = 0x7fff;
-	}
 
 	/* Prescale divider (log2) */
 	writel(prescale, &idev->regs->timer_clock_div);
@@ -444,7 +443,7 @@ axxia_i2c_probe(struct platform_device *pdev)
 	struct axxia_i2c_dev *idev = NULL;
 	struct clk *i2c_clk = NULL;
 	void __iomem *base = NULL;
-	u32 port = 0;
+	u32 bus = pdev->id;
 	int irq = 0;
 	int ret = 0;
 
@@ -481,7 +480,7 @@ axxia_i2c_probe(struct platform_device *pdev)
 	idev->dev          = &pdev->dev;
 	init_completion(&idev->msg_complete);
 
-	of_property_read_u32(np, "port", &port);
+	of_property_read_u32(np, "bus", &bus);
 
 	of_property_read_u32(np, "clock-frequency", &idev->bus_clk_rate);
 
@@ -509,10 +508,10 @@ axxia_i2c_probe(struct platform_device *pdev)
 	idev->adapter.owner = THIS_MODULE;
 	idev->adapter.class = I2C_CLASS_HWMON;
 	snprintf(idev->adapter.name, sizeof(idev->adapter.name),
-		 "Axxia I2C%u", port);
+		 "Axxia I2C%u", bus);
 	idev->adapter.algo = &axxia_i2c_algo;
 	idev->adapter.dev.parent = &pdev->dev;
-	idev->adapter.nr = pdev->id;
+	idev->adapter.nr = bus;
 	idev->adapter.dev.of_node = pdev->dev.of_node;
 
 	ret = i2c_add_numbered_adapter(&idev->adapter);
-- 
1.7.1

