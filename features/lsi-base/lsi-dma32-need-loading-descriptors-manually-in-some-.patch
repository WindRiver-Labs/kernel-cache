From 9c71ff9fde25d27bdbc3e272dd22c982266126d0 Mon Sep 17 00:00:00 2001
From: Ming Liu <ming.liu@windriver.com>
Date: Mon, 21 Oct 2013 10:18:00 +0800
Subject: [PATCH] lsi-dma32: need loading descriptors manually in some cases

When read from devices, highest bits of source addresses are stored in
GPREG register while it's also used by loading descriptors, this causes the
descriptors in external memory fail to be loaded.

Signed-off-by: Ming Liu <ming.liu@windriver.com>
---
 drivers/dma/lsi-dma32.c |   45 ++++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 44 insertions(+), 1 deletions(-)

diff --git a/drivers/dma/lsi-dma32.c b/drivers/dma/lsi-dma32.c
index ec3ea42..6386ecd 100644
--- a/drivers/dma/lsi-dma32.c
+++ b/drivers/dma/lsi-dma32.c
@@ -38,6 +38,9 @@
 #include <linux/atomic.h>
 #include "lsi-dma32.h"
 
+#ifdef CONFIG_ACP
+#define rd16(_addr)         readw((_addr))
+#endif
 #define rd32(_addr)         readl((_addr))
 #define wr32(_value, _addr) writel((_value), (_addr))
 
@@ -243,11 +246,51 @@ static int gpdma_start_job(struct gpdma_channel *dmac)
 	} else {
 		unsigned int seg_src = (desc->src >> 32) & 0x3f;
 		unsigned int seg_dst = (desc->dst >> 32) & 0x3f;
+#ifdef CONFIG_ACP
+		if(seg_src != 0) {
+			u32 reg;
+			ch_dbg(dmac, "Loading dma registers manually\n");
+			reg = rd16(&d->src_x_ctr);
+			wr32(reg, base + DMA_X_SRC_COUNT);
+			reg = rd16(&d->src_y_ctr);
+			wr32(reg, base + DMA_Y_SRC_COUNT);
+			*(volatile u32 *)(base + DMA_X_MODIF_SRC) = d->src_x_mod;
+			*(volatile u32 *)(base + DMA_Y_MODIF_SRC) = d->src_y_mod;
+			*(volatile u32 *)(base + DMA_SRC_CUR_ADDR) = d->src_addr;
+			*(volatile u32 *)(base + DMA_SRC_MASK) = d->src_data_mask;
+
+			reg = rd16(&d->src_access);
+			wr32(reg, base + DMA_SRC_ACCESS);
+			reg = rd16(&d->dst_access);
+			wr32(reg, base + DMA_DST_ACCESS);
+
+			*(volatile u32 *)(base + DMA_NXT_DESCR) = d->next_ptr;
+
+			reg = rd16(&d->dst_x_ctr);
+			wr32(reg, base + DMA_X_DST_COUNT);
+			reg = rd16(&d->dst_y_ctr);
+			wr32(reg, base + DMA_Y_DST_COUNT);
+
+			*(volatile u32 *)(base + DMA_X_MODIF_DST) = d->dst_x_mod;
+			*(volatile u32 *)(base + DMA_Y_MODIF_DST) = d->dst_y_mod;
+			*(volatile u32 *)(base + DMA_DST_CUR_ADDR) = d->dst_addr;
+		}
+		ch_dbg(dmac, "Setting gpreg=%x\n", (seg_dst << 8) | seg_src);
+#endif
 		wr32((seg_dst << 8) | seg_src, dmac->engine->gpreg);
 	}
 	wmb();
+#ifdef CONFIG_ACP
+	if(((desc->src >> 32) & 0x3f) != 0) {
+		ch_dbg(dmac, "Starting manually transfer\n");
+		*(volatile u32 *)(base + DMA_CHANNEL_CONFIG) = d->ch_config;
+	}
+	else {
+		wr32(DMA_CONFIG_DSC_LOAD, base+DMA_CHANNEL_CONFIG);
+	}
+#else
 	wr32(DMA_CONFIG_DSC_LOAD, base+DMA_CHANNEL_CONFIG);
-
+#endif
 	return 0;
 }
 
-- 
1.7.5.4

