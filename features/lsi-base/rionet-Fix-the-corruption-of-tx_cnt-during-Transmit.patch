From d5d08e0fb6b9dcba84fa0731ae8fdbd5e446e8be Mon Sep 17 00:00:00 2001
From: Li Wang <li.wang@windriver.com>
Date: Wed, 26 Aug 2015 10:38:29 +0800
Subject: [PATCH 60/68] rionet: Fix the corruption of tx_cnt during Transmit.

the patch comes from:
git://git.yoctoproject.org/linux-yocto-3.10
commit 56931ec20398bc30d5f556e7229af5c661fdbea9 upstream

The non-atomic variable "tx_cnt" can be updated simultaneously
from different threads using "rionet_start_xmit" (Tx) and the
"rionet_outb_msg_event" (callback) functions. These functions
use different locks: "tx_lock" for the Tx and "lock" for the
callback function. This corruption of tx_cnt results in a kernel
crash, particularly visible during high throughput data trasfers.

Fixed to use the same lock "tx_lock" so as to avoid corruption
of tx_cnt.

Signed-off-by: Palani <palaniappan.ramanathan@lsi.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
Signed-off-by: Li Wang <li.wang@windriver.com>
---
 drivers/net/rionet.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/net/rionet.c b/drivers/net/rionet.c
index f433b59..00a8128 100644
--- a/drivers/net/rionet.c
+++ b/drivers/net/rionet.c
@@ -269,7 +269,7 @@ static void rionet_outb_msg_event(struct rio_mport *mport, void *dev_id, int mbo
 	struct net_device *ndev = dev_id;
 	struct rionet_private *rnet = netdev_priv(ndev);
 
-	spin_lock(&rnet->lock);
+	spin_lock(&rnet->tx_lock);
 
 	if (netif_msg_intr(rnet))
 		printk(KERN_INFO
@@ -288,7 +288,7 @@ static void rionet_outb_msg_event(struct rio_mport *mport, void *dev_id, int mbo
 	if (rnet->tx_cnt < RIONET_TX_RING_SIZE)
 		netif_wake_queue(ndev);
 
-	spin_unlock(&rnet->lock);
+	spin_unlock(&rnet->tx_lock);
 }
 
 static int rionet_open(struct net_device *ndev)
-- 
1.7.5.4

