From 6b87694c5d550c89f47580842e69df06e44c57b0 Mon Sep 17 00:00:00 2001
From: David Mercado <david.mercado@windriver.com>
Date: Tue, 19 Nov 2013 17:52:18 -0500
Subject: [PATCH 135/159] LSI AXM55XX: Port of LSI drivers to 3.10 kernel

git.yoctoproject.org/git/linux-yocto-3.10
commit f8e6479d13bce233ff4f9ef58a522a4225ff651d standard/axxia/base.

Port LSI drivers from 3.4.x to 3.10.x kernel.

Signed-off-by: David Mercado <david.mercado@windriver.com>
---
 drivers/dma/lsi-dma32.c                |   11 +-
 drivers/dma/pl330.c                    |    2 +-
 drivers/gpio/gpio-pl061.c              |   35 +++-
 drivers/i2c/busses/i2c-axxia.c         |   42 +---
 drivers/misc/lsi-mtc.c                 |  112 +++++-----
 drivers/misc/lsi-smmon.c               |  166 +++++++-------
 drivers/net/ethernet/lsi/lsi_acp_net.c |  380 +++++++++---------------------
 drivers/spi/spi-pl022.c                |  395 +++++++-------------------------
 8 files changed, 374 insertions(+), 769 deletions(-)

diff --git a/drivers/dma/lsi-dma32.c b/drivers/dma/lsi-dma32.c
index f2ec6c6..b16df68 100644
--- a/drivers/dma/lsi-dma32.c
+++ b/drivers/dma/lsi-dma32.c
@@ -3,6 +3,7 @@
  *
  * The driver is based on:
  *
+ * lsi-dma32.c -
  * lsi-dma.c - Copyright 2011 Mentor Graphics
  * acp_gpdma.c - Copyright (c) 2011, Ericsson AB
  *               Niclas Bengtsson <niklas.x.bengtsson@ericsson.com>
@@ -45,14 +46,14 @@
 	do { \
 		struct gpdma_engine *_e = engine; \
 		(void)_e; \
-		printk(KERN_DEBUG "dma0: " fmt, ##__VA_ARGS__); \
+		pr_debug("dma0: " fmt, ##__VA_ARGS__); \
 	} while (0)
 
 #define ch_dbg(dmac, fmt, ...) \
 	do { \
 		struct gpdma_channel *_c = dmac; \
 		(void)_c; \
-		printk(KERN_DEBUG "dma0ch%d: [%s] " fmt, \
+		pr_debug("dma0ch%d: [%s] " fmt, \
 			dmac->channel, __func__, ##__VA_ARGS__); \
 	} while (0)
 #else
@@ -754,7 +755,7 @@ static const struct of_device_id gpdma_of_ids[] = {
  *
  *
  */
-static int __devinit gpdma_of_probe(struct platform_device *op)
+static int gpdma_of_probe(struct platform_device *op)
 {
 	struct gpdma_engine *engine;
 	struct dma_device   *dma;
@@ -767,7 +768,7 @@ static int __devinit gpdma_of_probe(struct platform_device *op)
 	if (!match)
 		return -EINVAL;
 
-	engine = kzalloc(sizeof *engine, GFP_KERNEL);
+	engine = kzalloc(sizeof(*engine), GFP_KERNEL);
 	if (!engine)
 		return -ENOMEM;
 
@@ -776,7 +777,7 @@ static int __devinit gpdma_of_probe(struct platform_device *op)
 	kref_init(&engine->kref);
 	raw_spin_lock_init(&engine->lock);
 	engine->dev = &op->dev;
-	engine->chip = match->data;
+	engine->chip = (struct lsidma_hw *)match->data;
 
 	/* Initialize dma_device struct */
 	dma = &engine->dma_device;
diff --git a/drivers/dma/pl330.c b/drivers/dma/pl330.c
index 4c2f465..d418c30 100644
--- a/drivers/dma/pl330.c
+++ b/drivers/dma/pl330.c
@@ -2055,7 +2055,7 @@ static int dmac_alloc_resources(struct pl330_dmac *pl330)
 	 */
 	pl330->mcode_cpu = dma_alloc_coherent(pi->dev,
 				chans * pi->mcbufsz,
-				&pl330->mcode_bus, GFP_KERNEL);
+				(dma_addr_t *)&pl330->mcode_bus, GFP_KERNEL);
 	if (!pl330->mcode_cpu) {
 		dev_err(pi->dev, "%s:%d Can't allocate memory!\n",
 			__func__, __LINE__);
diff --git a/drivers/gpio/gpio-pl061.c b/drivers/gpio/gpio-pl061.c
index c434f23..4a939e8 100644
--- a/drivers/gpio/gpio-pl061.c
+++ b/drivers/gpio/gpio-pl061.c
@@ -33,6 +33,13 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/pm.h>
 
+#ifdef CONFIG_PPC
+#define readb(addr) ((char)readl(addr))
+#define writeb(b, addr) writel(b, addr)
+
+#define GPIO_AFSEL 0x420
+#endif
+
 #define GPIODIR 0x400
 #define GPIOIS  0x404
 #define GPIOIBE 0x408
@@ -60,7 +67,7 @@ static inline void chained_irq_enter(struct irq_chip *chip,
 				     struct irq_desc *desc) {}
 
 static inline void chained_irq_exit(struct irq_chip *chip,
-				   struct irq_desc *desc)
+				    struct irq_desc *desc)
 {
 	if (chip->irq_eoi)
 		chip->irq_eoi(&desc->irq_data);
@@ -290,9 +297,13 @@ static int pl061_probe(struct device *dev,
 		irq_base = pdata->irq_base;
 		if (irq_base <= 0)
 			return -ENODEV;
-	} else {
+	} else if (dev->of_node) {
 		chip->gc.base = -1;
 		irq_base = 0;
+	} else {
+		if (retchip)
+			*retchip = NULL;
+		return -ENODEV;
 	}
 
 	if (!devm_request_mem_region(dev, res->start,
@@ -304,13 +315,13 @@ static int pl061_probe(struct device *dev,
 
 	chip->base = devm_ioremap(dev, res->start,
 				  resource_size(res));
-	if (!chip->base) {
+	if (chip->base == NULL) {
 		if (retchip)
 			*retchip = NULL;
 		return -ENOMEM;
 	}
 
-	chip->domain = irq_domain_add_simple(adev->dev.of_node, PL061_GPIO_NR,
+	chip->domain = irq_domain_add_simple(dev->of_node, PL061_GPIO_NR,
 					     irq_base, &pl061_domain_ops, chip);
 	if (!chip->domain)
 		return -ENODEV;
@@ -362,7 +373,7 @@ static int pl061_probe(struct device *dev,
 		}
 	}
 
-	drv_set_drvdata(dev, chip);
+	dev_set_drvdata(dev, chip);
 
 	return 0;
 }
@@ -420,7 +431,7 @@ static const struct dev_pm_ops pl061_dev_pm_ops = {
 #endif
 
 #ifdef CONFIG_ARM_AMBA
-static int pl061_amba_probe(struct amba_device *dev, struct amba_id *id)
+static int pl061_amba_probe(struct amba_device *dev, const struct amba_id *id)
 {
 	return pl061_probe(&dev->dev, &dev->res, dev->irq[0], NULL);
 }
@@ -477,6 +488,13 @@ static int pl061_of_probe(struct platform_device *ofdev)
 
 	if (ret < 0)
 		return ret;
+
+	prop = of_get_property(ofdev->dev.of_node, "pins-map", &len);
+	if (!prop || len < sizeof(*prop))
+		dev_warn(&ofdev->dev, "no 'pins-map' property\n");
+	else
+		writeb(*prop, chip->base + GPIO_AFSEL);
+
 	return 0;
 }
 
@@ -498,7 +516,12 @@ static struct platform_driver pl061_gpio_driver = {
 
 static int __init pl061_gpio_init(void)
 {
+#ifdef CONFIG_ARM_AMBA
 	return amba_driver_register(&pl061_gpio_driver);
+#else
+	return platform_driver_register(&pl061_gpio_driver);
+#endif
+
 }
 module_init(pl061_gpio_init);
 
diff --git a/drivers/i2c/busses/i2c-axxia.c b/drivers/i2c/busses/i2c-axxia.c
index 8061998..4f86418 100644
--- a/drivers/i2c/busses/i2c-axxia.c
+++ b/drivers/i2c/busses/i2c-axxia.c
@@ -195,7 +195,7 @@ axxia_i2c_init(struct axxia_i2c_dev *idev)
 	tmo_clk = ns_to_clk(SCL_WAIT_TIMEOUT_NS, clk_mhz);
 
 	/*
-	   Find the prescaler value that makes tmo_clk fit in 15-bits counter.
+	 * Find the prescaler value that makes tmo_clk fit in 15-bits counter.
 	 */
 	for (prescale = 0; prescale < 15; ++prescale) {
 		if (tmo_clk <= 0x7fff)
@@ -255,36 +255,6 @@ axxia_i2c_fill_tx_fifo(struct axxia_i2c_dev *idev)
 	return 0;
 }
 
-#ifdef DEBUG
-static char *
-status_str(u32 status)
-{
-	static char buf[128];
-
-	buf[0] = '\0';
-
-	if (status & MST_STATUS_RFL)
-		strcat(buf, "RFL ");
-	if (status & MST_STATUS_TFL)
-		strcat(buf, "TFL ");
-	if (status & MST_STATUS_SNS)
-		strcat(buf, "SNS ");
-	if (status & MST_STATUS_SS)
-		strcat(buf, "SS ");
-	if (status & MST_STATUS_SCC)
-		strcat(buf, "SCC ");
-	if (status & MST_STATUS_TSS)
-		strcat(buf, "TSS ");
-	if (status & MST_STATUS_AL)
-		strcat(buf, "AL ");
-	if (status & MST_STATUS_ND)
-		strcat(buf, "ND ");
-	if (status & MST_STATUS_NA)
-		strcat(buf, "NA ");
-	return buf;
-}
-#endif
-
 static irqreturn_t
 axxia_i2c_isr(int irq, void *_dev)
 {
@@ -436,7 +406,7 @@ static const struct i2c_algorithm axxia_i2c_algo = {
 	.functionality	= axxia_i2c_func,
 };
 
-static int __devinit
+static int
 axxia_i2c_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
@@ -475,7 +445,7 @@ axxia_i2c_probe(struct platform_device *pdev)
 	}
 
 	idev->base         = base;
-	idev->regs         = (struct __iomem i2c_regs *) base;
+	idev->regs         = (struct __iomem i2c_regs*)base;
 	idev->i2c_clk      = i2c_clk;
 	idev->dev          = &pdev->dev;
 	init_completion(&idev->msg_complete);
@@ -536,7 +506,7 @@ err_cleanup:
 	return ret;
 }
 
-static int __devexit
+static int
 axxia_i2c_remove(struct platform_device *pdev)
 {
 	struct axxia_i2c_dev *idev = platform_get_drvdata(pdev);
@@ -564,7 +534,7 @@ static int axxia_i2c_resume(struct platform_device *pdev)
 #endif
 
 /* Match table for of_platform binding */
-static const struct of_device_id axxia_i2c_of_match[] __devinitconst = {
+static const struct of_device_id axxia_i2c_of_match[] = {
 	{ .compatible = "lsi,api2c", },
 	{},
 };
@@ -572,7 +542,7 @@ MODULE_DEVICE_TABLE(of, axxia_i2c_of_match);
 
 static struct platform_driver axxia_i2c_driver = {
 	.probe   = axxia_i2c_probe,
-	.remove  = __devexit_p(axxia_i2c_remove),
+	.remove  = axxia_i2c_remove,
 	.suspend = axxia_i2c_suspend,
 	.resume  = axxia_i2c_resume,
 	.driver  = {
diff --git a/drivers/misc/lsi-mtc.c b/drivers/misc/lsi-mtc.c
index ebbdac8..b8f81c4 100644
--- a/drivers/misc/lsi-mtc.c
+++ b/drivers/misc/lsi-mtc.c
@@ -84,9 +84,7 @@ struct mtc_regs {
 #ifdef __MTC_SIMULATION
 struct mtc_regs _mtc_regs;
 u32 _mtc_tdomem[256] = { 0x11110000, 0x22221111, 0x33332222 };
-
 u32 *_mtc_prgmem = _mtc_tdomem;
-
 #endif
 
 /******************************************************/
@@ -198,7 +196,7 @@ struct ncp_axis_mtc_MTC_INST_PARAMS0_REG_ADDR_r_t {
 	unsigned tdo_memory_size:10;
 	unsigned reserved1:6;
 	unsigned tst_prgm_memory_size:10;
-#else				/* Little Endian */
+#else	/* Little Endian */
 	unsigned tst_prgm_memory_size:10;
 	unsigned reserved1:6;
 	unsigned tdo_memory_size:10;
@@ -2471,8 +2469,8 @@ mtc_dev_read(struct file *filp, char __user *data, size_t len, loff_t *ppose)
 
 	tdo_size_word = (tdo_size_bit + 31) / 32;
 #ifdef DEBUG
-	printk(KERN_DEBUG "mtc_dev_read(), tdo_bit=%d tdo_word=%d\n",
-	       tdo_size_bit, tdo_size_word);
+	pr_debug("mtc_dev_read(), tdo_bit=%d tdo_word=%d\n",
+		 tdo_size_bit, tdo_size_word);
 #endif
 	/* copy tdo data to user space, always read from location 0
 	   because we reset tdomem after each read */
@@ -2496,7 +2494,9 @@ mtc_dev_read(struct file *filp, char __user *data, size_t len, loff_t *ppose)
 
 static ssize_t
 mtc_dev_write(struct file *filp,
-	      const char __user *data, size_t len, loff_t *ppose)
+	      const char __user *data,
+	      size_t len,
+	      loff_t *ppose)
 {
 
 	struct miscdevice *misc = filp->private_data;
@@ -2528,7 +2528,7 @@ mtc_dev_write(struct file *filp,
 
 	/* TEST CODE when mtc sim is used */
 	/* status1Reg.prgm_mem_rd_addr = 253; */
-	/* printk(KERN_DEBUG"buf offset=%d\n",status1Reg.prgm_mem_rd_addr ); */
+	/* pr_debug("buf offset=%d\n",status1Reg.prgm_mem_rd_addr ); */
 	/*END OF TEST CODE */
 
 	/* find starting location of the write */
@@ -2541,19 +2541,18 @@ mtc_dev_write(struct file *filp,
 		size1 = 256 - status1Reg.prgm_mem_rd_addr;
 		/*number of words load from location 0 will be size-size1 */
 #ifdef DEBUG
-		printk(KERN_DEBUG
-		       "Wraparound size=%d, size1=%d size-size1=%d\n", size,
-		       size1, size - size1);
+		pr_debug("Wraparound size=%d, size1=%d size-size1=%d\n", size,
+			 size1, size - size1);
 #endif
 	}
 #ifdef DEBUG
-	printk(KERN_DEBUG "Appending buff size1=%d\n", size1);
+	pr_debug("Appending buff size1=%d\n", size1);
 #endif
 
 	for (i = 0; i < size1; i++) {
 #ifdef DEBUG
-		printk(KERN_DEBUG "i=%d mtc_buf[i]=%d pprg=0x%x\n",
-		       i, mtc_buf[i], (u32) pprg);
+		pr_debug("i=%d mtc_buf[i]=%d pprg=0x%x\n",
+			 i, mtc_buf[i], (u32) pprg);
 #endif
 		*pprg = mtc_buf[i];
 		pprg++;
@@ -2563,14 +2562,13 @@ mtc_dev_write(struct file *filp,
 	if (isWraparound) {
 		pprg = dev->prgmem;	/* reset write pointer to location 0 */
 #ifdef DEBUG
-		printk(KERN_DEBUG "\n\nWraparound buff size=%d\n",
-		       size - size1);
+		pr_debug("\n\nWraparound buff size=%d\n",
+			 size - size1);
 #endif
 		for (i = 0; i < (size - size1); i++) {
 #ifdef DEBUG
-			printk(KERN_DEBUG
-			       "i=%d mtc_buf[size1+i]=%d pprg=0x%x\n", i,
-			       mtc_buf[size1 + i], (u32) pprg);
+			pr_debug("i=%d mtc_buf[size1+i]=%d pprg=0x%x\n", i,
+				 mtc_buf[size1 + i], (u32) pprg);
 #endif
 			*pprg = mtc_buf[size1 + i];
 			pprg++;
@@ -2605,7 +2603,7 @@ mtc_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		    copy_from_user((void *)&addr, (void *)arg,
 				   sizeof(unsigned int));
 		if (numByteCopied) {
-			printk(KERN_DEBUG "MTC Error ioctl\n");
+			pr_debug("MTC Error ioctl\n");
 			return -EFAULT;
 		}
 		tmp2 = *((u32 *) dev->regs + addr / 4);
@@ -2620,7 +2618,7 @@ mtc_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 			struct lsi_mtc_cfg_t mtc_cfg;
 			if (copy_from_user
 			    ((void *)&mtc_cfg, (void *)arg, sizeof(mtc_cfg))) {
-				printk(KERN_DEBUG "MTC Error ioctl\n");
+				pr_debug("MTC Error ioctl\n");
 				return -EFAULT;
 			}
 
@@ -2630,11 +2628,12 @@ mtc_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 
 	case MTC_SINGLESTEP_ENABLE:
 		{
-			struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t cfg0 = { 0 };
+			struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t cfg0 = {0};
 			int single_step;
+
 			if (copy_from_user
 			    ((void *)&single_step, (void *)arg, sizeof(int))) {
-				printk(KERN_DEBUG "MTC Error ioctl\n");
+				pr_debug("MTC Error ioctl\n");
 				return -EFAULT;
 			}
 
@@ -2647,9 +2646,9 @@ mtc_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 			cfg0.single_step_en = single_step;
 			dev->regs->config0 = *((u32 *) &cfg0);
 #ifdef DEBUG
-			printk(KERN_DEBUG
-			       "MTC_SINGLESTEP_ENABLE: dev->regs->config0=0x%x\n",
-			       dev->regs->config0);
+			pr_debug(
+			    "MTC_SINGLESTEP_ENABLE: dev->regs->config0=0x%x\n",
+			    dev->regs->config0);
 #endif
 		}
 
@@ -2657,11 +2656,11 @@ mtc_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 
 	case MTC_LOOPMODE_ENABLE:
 		{
-			struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t cfg0 = { 0 };
+			struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t cfg0 = {0};
 			int loop_mode;
 			if (copy_from_user
 			    ((void *)&loop_mode, (void *)arg, sizeof(int))) {
-				printk(KERN_DEBUG "MTC Error ioctl\n");
+				pr_debug("MTC Error ioctl\n");
 				return -EFAULT;
 			}
 
@@ -2674,7 +2673,7 @@ mtc_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 			cfg0.loop_en = loop_mode;
 			dev->regs->config0 = *((u32 *) &cfg0);
 #ifdef DEBUG
-			printk(KERN_DEBUG
+			pr_debug(
 			       "MTC_LOOPMODE_ENABLE dev->regs->config0=0x%x\n",
 			       dev->regs->config0);
 #endif
@@ -2684,12 +2683,13 @@ mtc_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 
 	case MTC_RESET:
 		{
-			struct ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t exec1 = { 0 };
+			struct
+			 ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t exec1 = {0};
 			exec1.sw_reset = 1;
 			dev->regs->execute = *((u32 *) &exec1);
 #ifdef DEBUG
-			printk(KERN_DEBUG "dev->regs->execute=0x%x\n",
-				dev->regs->execute);
+			pr_debug("dev->regs->execute=0x%x\n",
+				 dev->regs->execute);
 #endif
 		}
 
@@ -2698,11 +2698,11 @@ mtc_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 	case MTC_TCKCLK_GATE:
 		{
 			struct lsi_mtc_tckclk_gate_t tckGate;
-			struct ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t cfg1 = { 0 };
+			struct ncp_axis_mtc_MTC_CONFIG1_REG_ADDR_r_t cfg1 = {0};
 
 			if (copy_from_user
 			    ((void *)&tckGate, (void *)arg, sizeof(tckGate))) {
-				printk(KERN_DEBUG "MTC Error ioctl\n");
+				pr_debug("MTC Error ioctl\n");
 				return -EFAULT;
 			}
 
@@ -2720,8 +2720,8 @@ mtc_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 			cfg1.sw_gate_tck = tckGate.gate_tck;
 			dev->regs->config1 = *((u32 *) &cfg1);
 #ifdef DEBUG
-			printk(KERN_DEBUG "dev->regs->config1=0x%x\n",
-			       dev->regs->config1);
+			pr_debug("dev->regs->config1=0x%x\n",
+				 dev->regs->config1);
 #endif
 		}
 
@@ -2729,11 +2729,11 @@ mtc_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 
 	case MTC_STARTSTOP_EXEC:
 		{
-			struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t cfg0 = { 0 };
+			struct ncp_axis_mtc_MTC_CONFIG0_REG_ADDR_r_t cfg0 = {0};
 			int start_stop;
 			if (copy_from_user
 			    ((void *)&start_stop, (void *)arg, sizeof(int))) {
-				printk(KERN_DEBUG "MTC Error ioctl\n");
+				pr_debug("MTC Error ioctl\n");
 				return -EFAULT;
 			}
 
@@ -2746,8 +2746,8 @@ mtc_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 			cfg0.start_stopn = start_stop;
 			dev->regs->config0 = *((u32 *) &cfg0);
 #ifdef DEBUG
-			printk(KERN_DEBUG "dev->regs->config0=0x%x\n",
-			       dev->regs->config0);
+			pr_debug("dev->regs->config0=0x%x\n",
+				 dev->regs->config0);
 #endif
 		}
 
@@ -2755,7 +2755,8 @@ mtc_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 
 	case MTC_SINGLESTEP_EXEC:
 		{
-			struct ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t exec1 = { 0 };
+			struct
+			 ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t exec1 = {0};
 			exec1.single_step = 1;
 			dev->regs->execute = *((u32 *) &exec1);
 			pr_debug("dev->regs->execute=0x%x\n",
@@ -2766,7 +2767,8 @@ mtc_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 
 	case MTC_CONTINUE_EXEC:
 		{
-			struct ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t exec1 = { 0 };
+			struct
+			 ncp_axis_mtc_MTC_EXECUTE1_REG_ADDR_r_t exec1 = {0};
 			exec1.cont_after_pause = 1;
 			dev->regs->execute = *((u32 *) &exec1);
 			pr_debug("dev->regs->execute=0x%x\n",
@@ -2807,8 +2809,8 @@ mtc_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		break;
 
 	default:
-		printk(KERN_DEBUG "Invalid ioctl cmd=%d MTC_DEBUG_OP=%d\n",
-		       cmd, MTC_DEBUG_OP);
+		pr_debug("Invalid ioctl cmd=%d MTC_DEBUG_OP=%d\n",
+			 cmd, MTC_DEBUG_OP);
 		ret = -EINVAL;
 
 	}
@@ -2847,16 +2849,16 @@ static irqreturn_t mtc_isr(int irq_no, void *arg)
  *
  * Initialize device.
  */
-static int __devinit mtc_probe(struct platform_device *pdev)
+static int mtc_probe(struct platform_device *pdev)
 {
 	static struct mtc_device *dev;
 	void __iomem *regs;
 	int rc;
 	u32 *pRegs;
 
-	printk(KERN_DEBUG"!!!!MTC: mtc_probe()\n");
+	pr_debug("!!!!MTC: mtc_probe()\n");
 	/* Allocate space for device private data */
-	dev = kzalloc(sizeof *dev, GFP_KERNEL);
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev) {
 		rc = -ENOMEM;
 		goto err;
@@ -2916,7 +2918,7 @@ static int __devinit mtc_probe(struct platform_device *pdev)
 /**
  * mtc_remove
  */
-static int __devexit mtc_remove(struct platform_device *pdev)
+static int mtc_remove(struct platform_device *pdev)
 {
 	struct mtc_device *dev = dev_get_drvdata(&pdev->dev);
 	kref_put(&dev->ref, mtc_destroy);
@@ -2980,9 +2982,9 @@ MODULE_DESCRIPTION("Master Test Controller driver");
 MODULE_LICENSE("GPL");
 
 /* MTC operating mode. */
-#define  LSI_MTC_BOARDTEST_MODE 0	/* MTC Board Test Mode.  */
-#define  LSI_MTC_EXTTEST_MODE 1	/* MTC External Test Mode DBC3 excluded. */
-#define  LSI_MTC_SYSTTEST_MODE   2	/* MTC System Test Mode DBC3 excluded.   */
+#define  LSI_MTC_BOARDTEST_MODE 0  /* MTC Board Test Mode.  */
+#define  LSI_MTC_EXTTEST_MODE   1  /* MTC External Test Mode DBC3 excluded. */
+#define  LSI_MTC_SYSTTEST_MODE  2  /* MTC System Test Mode DBC3 excluded. */
 
 /* Test data output recording mode. */
 /* Do not save TDO data during shiftir and shiftdr. */
@@ -3072,13 +3074,11 @@ static long _mtc_config(struct mtc_device *dev, struct lsi_mtc_cfg_t *pMTCCfg)
 	dev->regs->config1 = *((u32 *) &cfg1);
 
 #ifdef DEBUG
-	printk(KERN_DEBUG "buffmode=%d,rate=%d dev->regs->config0 =0x%x\n",
-	       pMTCCfg->buffMode, pMTCCfg->clkSpeed, dev->regs->config0);
-
-	printk(KERN_DEBUG
-	       "dev->regs->config1 =0x%x, dev->regs-> execute=0x%x\n",
-	       dev->regs->config1, dev->regs->execute);
+	pr_debug("buffmode=%d,rate=%d dev->regs->config0 =0x%x\n",
+		 pMTCCfg->buffMode, pMTCCfg->clkSpeed, dev->regs->config0);
 
+	pr_debug("dev->regs->config1 =0x%x, dev->regs-> execute=0x%x\n",
+		 dev->regs->config1, dev->regs->execute);
 #endif
 	/* test */
 	return 0;
diff --git a/drivers/misc/lsi-smmon.c b/drivers/misc/lsi-smmon.c
index 33c52cf..0c0db5d 100644
--- a/drivers/misc/lsi-smmon.c
+++ b/drivers/misc/lsi-smmon.c
@@ -15,7 +15,7 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/spinlock.h>
-#include <linux/proc_fs.h>
+#include <linux/slab.h>
 
 #include "lsi-ncr.h"
 
@@ -24,7 +24,7 @@
 #endif
 
 static int log = 1;
-module_param(log, int, 0755);
+module_param(log, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 MODULE_PARM_DESC(log, "Log each error on the console.");
 
 /*
@@ -86,14 +86,62 @@ struct smmon_counts {
 
 static struct smmon_counts counts;
 
-DEFINE_SPINLOCK(counts_lock);
+DEFINE_RAW_SPINLOCK(counts_lock);
+
+#define SUMMARY_SIZE 512
+static char *summary;
+module_param(summary, charp, S_IRUGO);
+MODULE_PARM_DESC(summary, "A Summary of the Current Error Counts.");
+
+/*
+  ------------------------------------------------------------------------------
+  update_summary
+*/
+
+static void
+update_summary(void)
+{
+	memset(summary, 0, SUMMARY_SIZE);
+	sprintf(summary,
+		"------------ Counts for SM0/SM1 ----------\n"
+		"                   Illegal Access: %lu/%lu\n"
+		"        Multiple Illegal Accesses: %lu/%lu\n"
+		"            Correctable ECC Error: %lu/%lu\n"
+		"  Multiple Correctable ECC Errors: %lu/%lu\n"
+		"          Uncorrectable ECC Error: %lu/%lu\n"
+		"Multiple Uncorrectable ECC Errors: %lu/%lu\n"
+		"                      Port Errors: %lu/%lu\n"
+		"                      Wrap Errors: %lu/%lu\n"
+		"                    Parity Errors: %lu/%lu\n",
+		counts.illegal_access[0],
+		counts.illegal_access[1],
+		counts.multiple_illegal_access[0],
+		counts.multiple_illegal_access[1],
+		counts.correctable_ecc[0],
+		counts.correctable_ecc[1],
+		counts.multiple_correctable_ecc[0],
+		counts.multiple_correctable_ecc[1],
+		counts.uncorrectable_ecc[0],
+		counts.uncorrectable_ecc[1],
+		counts.multiple_uncorrectable_ecc[0],
+		counts.multiple_uncorrectable_ecc[1],
+		counts.port_error[0],
+		counts.port_error[1],
+		counts.wrap_error[0],
+		counts.wrap_error[1],
+		counts.parity_error[0],
+		counts.parity_error[1]);
+
+	return;
+}
 
 /*
   ------------------------------------------------------------------------------
   smmon_isr
 */
 
-static irqreturn_t smmon_isr(int interrupt, void *device)
+static irqreturn_t
+smmon_isr(int interrupt, void *device)
 {
 	unsigned long status;
 	unsigned long region;
@@ -113,17 +161,14 @@ static irqreturn_t smmon_isr(int interrupt, void *device)
 	rc = ncr_read(region, 0x410, 4, &status);
 
 	if (0 != rc) {
-		printk(KERN_ERR
-		       "smmon(%d): Error reading interrupt status!\n", sm);
-
+		pr_err("smmon(%d): Error reading interrupt status!\n", sm);
 		return IRQ_NONE;
 	}
 
-	spin_lock(&counts_lock);
+	raw_spin_lock(&counts_lock);
 
 	if (0 != (0x00000002 & status) || 0 != (0x00000004 & status))
-		printk(KERN_ERR
-		       "smmon(%d): Illegal Access!\n", sm);
+		pr_err("smmon(%d): Illegal Access!\n", sm);
 
 	if (0 != (0x00000002 & status))
 		++counts.illegal_access[sm];
@@ -131,11 +176,9 @@ static irqreturn_t smmon_isr(int interrupt, void *device)
 	if (0 != (0x00000004 & status))
 		++counts.multiple_illegal_access[sm];
 
-	if ((0 != (0x00000008 & status) ||
-	     0 != (0x00000010 & status)) &&
+	if ((0 != (0x00000008 & status) || 0 != (0x00000010 & status)) &&
 	    0 != log)
-		printk(KERN_NOTICE
-		       "smmon(%d): Correctable ECC Error!\n", sm);
+		pr_notice("smmon(%d): Correctable ECC Error!\n", sm);
 
 	if (0 != (0x00000008 & status))
 		++counts.correctable_ecc[sm];
@@ -146,8 +189,7 @@ static irqreturn_t smmon_isr(int interrupt, void *device)
 	if ((0 != (0x00000020 & status) ||
 	     0 != (0x00000040 & status)) &&
 	    0 != log)
-		printk(KERN_CRIT
-		       "smmon(%d): Uncorrectable ECC Error!\n", sm);
+		pr_crit("smmon(%d): Uncorrectable ECC Error!\n", sm);
 
 	if (0 != (0x00000020 & status))
 		++counts.uncorrectable_ecc[sm];
@@ -159,27 +201,26 @@ static irqreturn_t smmon_isr(int interrupt, void *device)
 		++counts.port_error[sm];
 
 		if (0 != log)
-			printk(KERN_CRIT
-			       "smmon(%d): Port Error!\n", sm);
+			pr_crit("smmon(%d): Port Error!\n", sm);
 	}
 
 	if (0 != (0x00000800 & status)) {
 		++counts.wrap_error[sm];
 
 		if (0 != log)
-			printk(KERN_CRIT
-			       "smmon(%d): Wrap Error!\n", sm);
+			pr_crit("smmon(%d): Wrap Error!\n", sm);
 	}
 
 	if (0 != (0x00080000 & status)) {
 		++counts.parity_error[sm];
 
 		if (0 != log)
-			printk(KERN_CRIT
-			       "smmon(%d): Parity Error!\n", sm);
+			pr_crit("smmon(%d): Parity Error!\n", sm);
 	}
 
-	spin_unlock(&counts_lock);
+	update_summary();
+
+	raw_spin_unlock(&counts_lock);
 
 	ncr_write(region, 0x548, 4, &status);
 
@@ -187,56 +228,6 @@ static irqreturn_t smmon_isr(int interrupt, void *device)
 }
 
 /*
-  ------------------------------------------------------------------------------
-  smmon_read_proc
-*/
-
-static int
-smmon_read_proc(char *page, char **start, off_t offset, int count,
-		int *eof, void *data)
-{
-	int length;
-	unsigned long flags;
-
-	spin_lock_irqsave(&counts_lock, flags);
-
-	length = sprintf(page,
-			 "------------ Counts for SM0/SM1 ----------\n"
-			 "		     Illegal Access: %lu/%lu\n"
-			 "	  Multiple Illegal Accesses: %lu/%lu\n"
-			 "	      Correctable ECC Error: %lu/%lu\n"
-			 "  Multiple Correctable ECC Errors: %lu/%lu\n"
-			 "	    Uncorrectable ECC Error: %lu/%lu\n"
-			 "Multiple Uncorrectable ECC Errors: %lu/%lu\n"
-			 "			Port Errors: %lu/%lu\n"
-			 "			Wrap Errors: %lu/%lu\n"
-			 "		      Parity Errors: %lu/%lu\n",
-			 counts.illegal_access[0],
-			 counts.illegal_access[1],
-			 counts.multiple_illegal_access[0],
-			 counts.multiple_illegal_access[1],
-			 counts.correctable_ecc[0],
-			 counts.correctable_ecc[1],
-			 counts.multiple_correctable_ecc[0],
-			 counts.multiple_correctable_ecc[1],
-			 counts.uncorrectable_ecc[0],
-			 counts.uncorrectable_ecc[1],
-			 counts.multiple_uncorrectable_ecc[0],
-			 counts.multiple_uncorrectable_ecc[1],
-			 counts.port_error[0],
-			 counts.port_error[1],
-			 counts.wrap_error[0],
-			 counts.wrap_error[1],
-			 counts.parity_error[0], counts.parity_error[1]);
-
-	spin_unlock_irqrestore(&counts_lock, flags);
-
-	*eof = 1;
-
-	return length;
-}
-
-/*
   ==============================================================================
   ==============================================================================
   Linux Interface
@@ -249,13 +240,19 @@ smmon_read_proc(char *page, char **start, off_t offset, int count,
   smmon_init
 */
 
-static int __init smmon_init(void)
+static int __init
+smmon_init(void)
 {
 	int rc;
 	int mask;
 
-	printk("smmon: log=%d\n", log);
-	create_proc_read_entry("smmon", 0, NULL, smmon_read_proc, NULL);
+	summary = kmalloc(SUMMARY_SIZE, GFP_KERNEL);
+
+	if (NULL == summary)
+		return -ENOMEM;
+
+	update_summary();
+
 	memset(&counts, 0, sizeof(struct smmon_counts));
 
 	/*
@@ -267,16 +264,14 @@ static int __init smmon_init(void)
 	ncr_write(NCP_REGION_ID(0xf, 0), 0x414, 4, &mask);
 
 	rc = request_irq(32 + 161, smmon_isr, IRQF_ONESHOT,
-			"smmon_0", NULL);
+			 "smmon_0", NULL);
 	rc |= request_irq(32 + 160, smmon_isr, IRQF_ONESHOT,
-			"smmon_1", NULL);
+			  "smmon_1", NULL);
 
-	if (0 != rc) {
-		printk(KERN_ERR "smmon: Couldn't connect interrupt handler!\n");
+	if (0 != rc)
 		return -EBUSY;
-	}
 
-	printk(KERN_INFO "smmon: Monitoring System Memory\n");
+	pr_info("lsi_smmon: Monitoring System Memory\n");
 
 	return 0;
 }
@@ -288,14 +283,15 @@ module_init(smmon_init);
   smmon_exit
 */
 
-static void __exit smmon_exit(void)
+static void __exit
+smmon_exit(void)
 {
 	free_irq(32 + 161, NULL);
 	free_irq(32 + 160, NULL);
 
-	remove_proc_entry("smmon", NULL);
+	kfree(summary);
 
-	printk(KERN_INFO "smmon: Not Monitoring System Memory\n");
+	pr_info("lsi_smmon: Not Monitoring System Memory\n");
 
 	return;
 }
diff --git a/drivers/net/ethernet/lsi/lsi_acp_net.c b/drivers/net/ethernet/lsi/lsi_acp_net.c
index 188c196..c868797 100644
--- a/drivers/net/ethernet/lsi/lsi_acp_net.c
+++ b/drivers/net/ethernet/lsi/lsi_acp_net.c
@@ -86,13 +86,11 @@
 #include <linux/uaccess.h>
 #include <linux/io.h>
 #include <asm/dma.h>
+#include <asm/lsi/acp_ncr.h>
 
 #include "lsi_acp_net.h"
 #include "../../../misc/lsi-ncr.h"
 
-extern int acp_mdio_read(unsigned long, unsigned long, unsigned short *, int);
-extern int acp_mdio_write(unsigned long, unsigned long, unsigned short, int);
-
 /* Define to disable full duplex mode on Amarillo boards */
 #undef AMARILLO_WA
 /*#define AMARILLO_WA*/
@@ -118,8 +116,7 @@ static void *gpreg_base;
 #define PHY_BCM_TEST_REG	0x1f
 #define PHY_AUXILIARY_MODE3	0x1d
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_mii_read
  *
  * Returns -EBUSY if unsuccessful, the (short) value otherwise.
@@ -135,8 +132,7 @@ static int appnic_mii_read(struct mii_bus *bus, int phy, int reg)
 	return (int)value;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_mii_write
  */
 
@@ -145,8 +141,7 @@ static int appnic_mii_write(struct mii_bus *bus, int phy, int reg, u16 val)
 	return acp_mdio_write(phy, reg, val, 0);
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_handle_link_change
  *
  * Called periodically when PHY is in polling mode.
@@ -230,8 +225,7 @@ static void appnic_handle_link_change(struct net_device *dev)
 	return;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_mii_probe
  */
 
@@ -257,8 +251,7 @@ static int appnic_mii_probe(struct net_device *dev)
 
 skip_first:
 
-	/*
-	 * Allow the option to disable auto negotiation and manually specify
+	/* Allow the option to disable auto negotiation and manually specify
 	 * the link speed and duplex setting with the use of a environment
 	 * setting.
 	 */
@@ -274,7 +267,7 @@ skip_first:
 	}
 
 	ret = phy_connect_direct(dev, phydev,
-				 &appnic_handle_link_change, 0,
+				 &appnic_handle_link_change,
 				 PHY_INTERFACE_MODE_MII);
 
 	if (ret) {
@@ -330,13 +323,12 @@ skip_first:
 	return 0;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_mii_init
  */
 
-static int __devinit appnic_mii_init(struct platform_device *pdev,
-				     struct net_device *dev)
+static int appnic_mii_init(struct platform_device *pdev,
+			   struct net_device *dev)
 {
 	struct appnic_device *pdata = netdev_priv(dev);
 	int i, err = -ENXIO;
@@ -377,10 +369,9 @@ err_out_1:
 	return err;
 }
 
-/*
-  ======================================================================
-  NIC Interface
-  ======================================================================
+/* ======================================================================
+   NIC Interface
+   ======================================================================
 */
 
 #define DESCRIPTOR_GRANULARITY 64
@@ -392,8 +383,7 @@ err_out_1:
 #define ALIGN64B_OFFSET(address) \
 	(ALIGN64B(address) - (unsigned long) (address))
 
-/*
- *  ----- Note On Buffer Space -----
+/*  ----- Note On Buffer Space -----
  *
  *  Minimum number of descriptors is 64 for the receiver and 64 for the
  *  transmitter; therefore, 2048 bytes (16 bytes each).
@@ -412,9 +402,7 @@ err_out_1:
  *    descriptor.
  */
 
-/*
- * Receiver
- */
+/* Receiver */
 
 int rx_num_desc = (CONFIG_LSI_NET_NUM_RX_DESC * DESCRIPTOR_GRANULARITY);
 module_param(rx_num_desc, int, 0);
@@ -424,9 +412,7 @@ int rx_buf_sz = CONFIG_LSI_NET_RX_BUF_SZ;
 module_param(rx_buf_sz, int, 0);
 MODULE_PARM_DESC(rx_buf_sz, "appnic : Receive buffer size");
 
-/*
- * Transmitter
- */
+/* Transmitter */
 
 int tx_num_desc = (CONFIG_LSI_NET_NUM_TX_DESC * DESCRIPTOR_GRANULARITY);
 module_param(tx_num_desc, int, 0);
@@ -441,30 +427,24 @@ static unsigned long out_of_tx_descriptors;
 static unsigned long transmit_interrupts;
 static unsigned long receive_interrupts;
 
-/*
-  ======================================================================
-  Utility Functions
-  ======================================================================
+/* ======================================================================
+   Utility Functions
+   ======================================================================
 */
 
-/*
-  ----------------------------------------------------------------------
-  clear_statistics
-*/
+/* ----------------------------------------------------------------------
+ * clear_statistics
+ */
 
 static void clear_statistics(struct appnic_device *pdata)
 {
 	int waste;
 
-	/*
-	 * Clear memory.
-	 */
+	/* Clear memory. */
 
 	memset((void *) &(pdata->stats), 0, sizeof(struct net_device_stats));
 
-	/*
-	 * Clear counters.
-	 */
+	/* Clear counters. */
 
 	waste = read_mac(APPNIC_RX_STAT_PACKET_OK); /* rx_packets */
 	waste = read_mac(APPNIC_TX_STAT_PACKET_OK); /* tx_packets */
@@ -517,15 +497,11 @@ static void clear_statistics(struct appnic_device *pdata)
 	/* rx_compressed will not be maintained. */
 	/* tx_compressed will not be maintained. */
 
-	/*
-	 * That's all.
-	 */
-
+	/* That's all. */
 	return;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * get_hw_statistics
  *
  *  -- NOTES --
@@ -538,15 +514,12 @@ static void get_hw_statistics(struct appnic_device *pdata)
 	unsigned long flags;
 
 	/* tx_packets */
-
 	pdata->stats.tx_packets += read_mac(APPNIC_TX_STAT_PACKET_OK);
 
 	/* multicast */
-
 	pdata->stats.multicast += read_mac(APPNIC_RX_STAT_MULTICAST);
 
 	/* collision */
-
 	pdata->stats.collisions += read_mac(APPNIC_TX_STATUS_LATE_COLLISION);
 	pdata->stats.collisions +=
 		read_mac(APPNIC_TX_STATUS_EXCESSIVE_COLLISION);
@@ -554,19 +527,15 @@ static void get_hw_statistics(struct appnic_device *pdata)
 	read_mac(APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK);
 
 	/* rx_length_errors */
-
 	pdata->stats.rx_length_errors += read_mac(APPNIC_RX_STAT_UNDERSIZE);
 	pdata->stats.rx_length_errors += read_mac(APPNIC_RX_STAT_OVERSIZE);
 
 	/* tx_fifo_errors */
-
 	pdata->stats.tx_fifo_errors += read_mac(APPNIC_TX_STAT_UNDERRUN);
 
-	/*
-	 * Lock this section out so the statistics maintained by the driver
+	/* Lock this section out so the statistics maintained by the driver
 	 * don't get clobbered.
 	 */
-
 	spin_lock_irqsave(&pdata->dev_lock, flags);
 
 	pdata->stats.rx_errors +=
@@ -586,15 +555,11 @@ static void get_hw_statistics(struct appnic_device *pdata)
 
 	spin_unlock_irqrestore(&pdata->dev_lock, flags);
 
-	/*
-	 * That's all.
-	 */
-
+	/* That's all. */
 	return;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * queue_initialized
  *
  * Returns the number of descriptors that are ready to receive packets
@@ -624,8 +589,7 @@ static int queue_initialized(union appnic_queue_pointer head,
 	return initialized;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * queue_uninitialzed
  *
  * Returns the number of unused/uninitialized descriptors. (from head to tail).
@@ -653,8 +617,7 @@ static int queue_uninitialized(union appnic_queue_pointer head,
 	return allocated;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * queue_increment
  */
 
@@ -674,8 +637,7 @@ static void queue_increment(union appnic_queue_pointer *queue,
 	return;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * queue_decrement
  */
 
@@ -695,8 +657,7 @@ static void queue_decrement(union appnic_queue_pointer *queue,
 	return;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * disable_rx_tx
  */
 
@@ -721,14 +682,12 @@ static void disable_rx_tx(void)
 }
 
 
-/*
-  ======================================================================
-  Linux Network Driver Interface
-  ======================================================================
+/* ======================================================================
+   Linux Network Driver Interface
+   ======================================================================
 */
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * handle_transmit_interrupt
  */
 
@@ -736,8 +695,7 @@ static void handle_transmit_interrupt(struct net_device *dev)
 {
 	struct appnic_device *pdata = netdev_priv(dev);
 
-	/*
-	 * The hardware's tail pointer should be one descriptor (or more)
+	/* The hardware's tail pointer should be one descriptor (or more)
 	 * ahead of software's copy.
 	 */
 
@@ -749,8 +707,7 @@ static void handle_transmit_interrupt(struct net_device *dev)
 	return;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * lsinet_rx_packet
  */
 
@@ -783,9 +740,7 @@ static void lsinet_rx_packet(struct net_device *dev)
 	crc_stat = read_mac(APPNIC_RX_STAT_CRC_ERROR);
 	align_stat = read_mac(APPNIC_RX_STAT_ALIGN_ERROR);
 
-	/*
-	 * Copy the received packet into the skb.
-	 */
+	/* Copy the received packet into the skb. */
 
 	while (0 < queue_initialized(SWAB_QUEUE_POINTER(pdata->rx_tail),
 				pdata->rx_tail_copy, pdata->rx_num_desc)) {
@@ -874,8 +829,7 @@ static void lsinet_rx_packet(struct net_device *dev)
 	return;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * lsinet_rx_packets
  */
 
@@ -888,8 +842,7 @@ static int lsinet_rx_packets(struct net_device *dev, int max)
 
 	queue.raw = pdata->rx_tail_copy.raw;
 
-	/* Receive Packets */
-
+	/* Receive Packets. */
 	while (0 < queue_initialized(SWAB_QUEUE_POINTER(pdata->rx_tail),
 				     queue, pdata->rx_num_desc)) {
 		struct appnic_dma_descriptor descriptor;
@@ -910,8 +863,7 @@ static int lsinet_rx_packets(struct net_device *dev, int max)
 		}
 	}
 
-	/* Update the Head Pointer */
-
+	/* Update the Head Pointer. */
 	while (1 < queue_uninitialized(pdata->rx_head,
 				       pdata->rx_tail_copy,
 				       pdata->rx_num_desc)) {
@@ -939,8 +891,7 @@ static int lsinet_rx_packets(struct net_device *dev, int max)
 	return packets;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * lsinet_poll
  */
 
@@ -971,8 +922,7 @@ static int lsinet_poll(struct napi_struct *napi, int budget)
 
 	napi_complete(napi);
 
-	/*
-	 * Re-enable receive interrupts (and preserve
+	/* Re-enable receive interrupts (and preserve
 	 * the already enabled TX interrupt).
 	 */
 	write_mac((APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE |
@@ -982,8 +932,7 @@ static int lsinet_poll(struct napi_struct *napi, int budget)
 	return 0;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_isr
  */
 
@@ -994,17 +943,17 @@ static irqreturn_t appnic_isr(int irq, void *device_id)
 	unsigned long dma_interrupt_status;
 	unsigned long flags;
 
-	/* Acquire the lock */
+	/* Acquire the lock. */
 	spin_lock_irqsave(&pdata->dev_lock, flags);
 
 	/* Get the status. */
 	dma_interrupt_status = read_mac(APPNIC_DMA_INTERRUPT_STATUS);
 
-	/* NAPI - don't ack RX interrupt */
+	/* NAPI - don't ack RX interrupt. */
 	write_mac(APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE,
 		  APPNIC_DMA_INTERRUPT_STATUS);
 
-	/* Handle interrupts */
+	/* Handle interrupts. */
 	if (TX_INTERRUPT(dma_interrupt_status)) {
 		/* transmition complete */
 		++transmit_interrupts;
@@ -1015,9 +964,8 @@ static irqreturn_t appnic_isr(int irq, void *device_id)
 		++receive_interrupts;
 		if (napi_schedule_prep(&pdata->napi)) {
 
-			/*
-			 * Disable RX interrupts and tell the
-			 * system we've got work
+			/* Disable RX interrupts and tell the
+			 * system we've got work.
 			 */
 			write_mac(APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT,
 				  APPNIC_DMA_INTERRUPT_ENABLE);
@@ -1028,7 +976,7 @@ static irqreturn_t appnic_isr(int irq, void *device_id)
 		}
 	}
 
-	/* Release the lock */
+	/* Release the lock. */
 	spin_unlock_irqrestore(&pdata->dev_lock, flags);
 
 	return IRQ_HANDLED;
@@ -1036,8 +984,7 @@ static irqreturn_t appnic_isr(int irq, void *device_id)
 
 #ifdef CONFIG_NET_POLL_CONTROLLER
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_poll_controller
  *
  * Polling receive - used by netconsole and other diagnostic tools
@@ -1054,8 +1001,7 @@ static void appnic_poll_controller(struct net_device *dev)
 #endif
 
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_open
  *
  * Opens the interface.  The interface is opened whenever ifconfig
@@ -1069,13 +1015,13 @@ static int appnic_open(struct net_device *dev)
 	struct appnic_device *pdata = netdev_priv(dev);
 	int return_code = 0;
 
-	/* Bring the PHY up */
+	/* Bring the PHY up. */
 	phy_start(pdata->phy_dev);
 
-	/* Enable NAPI */
+	/* Enable NAPI. */
 	napi_enable(&pdata->napi);
 
-	/* Install the interrupt handlers */
+	/* Install the interrupt handlers. */
 	return_code = request_irq(dev->irq, appnic_isr, IRQF_DISABLED,
 				   LSI_DRV_NAME, dev);
 	if (0 != return_code) {
@@ -1084,20 +1030,19 @@ static int appnic_open(struct net_device *dev)
 		return return_code;
 	}
 
-	/* Enable interrupts */
+	/* Enable interrupts. */
 	write_mac((APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE |
 		   APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT),
 		   APPNIC_DMA_INTERRUPT_ENABLE);
 
-	/* Let the OS know we are ready to send packets */
+	/* Let the OS know we are ready to send packets. */
 	netif_start_queue(dev);
 
-	/* That's all */
+	/* That's all. */
 	return 0;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_stop
  *
  * Stops the interface.  The interface is stopped when it is brought
@@ -1110,7 +1055,7 @@ static int appnic_stop(struct net_device *dev)
 
 	pr_info("%s: Stopping the interface.\n", LSI_DRV_NAME);
 
-	/* Disable all device interrupts */
+	/* Disable all device interrupts. */
 	write_mac(0, APPNIC_DMA_INTERRUPT_ENABLE);
 	free_irq(dev->irq, dev);
 
@@ -1129,8 +1074,7 @@ static int appnic_stop(struct net_device *dev)
 	return 0;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_hard_start_xmit
  *
  * The method initiates the transmission of a packet.  The full packet
@@ -1152,9 +1096,7 @@ static int appnic_hard_start_xmit(struct sk_buff *skb,
 	length = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
 	buf_per_desc = pdata->tx_buf_sz / pdata->tx_num_desc;
 
-	/*
-	 * If enough transmit descriptors are available, copy and transmit.
-	 */
+	/* If enough transmit descriptors are available, copy and transmit. */
 
 	while (((length / buf_per_desc) + 1) >=
 		queue_uninitialized(pdata->tx_head,
@@ -1218,7 +1160,7 @@ static int appnic_hard_start_xmit(struct sk_buff *skb,
 		}
 
 #ifdef CONFIG_ARM
-		/* ARM Data sync barrier */
+		/* ARM Data sync barrier. */
 		asm volatile ("mcr p15,0,%0,c7,c10,4" : : "r" (0));
 #endif
 		write_mac(pdata->tx_head.raw, APPNIC_DMA_TX_HEAD_POINTER);
@@ -1229,14 +1171,13 @@ static int appnic_hard_start_xmit(struct sk_buff *skb,
 		       LSI_DRV_NAME);
 	}
 
-	/* Free the socket buffer */
+	/* Free the socket buffer. */
 	dev_kfree_skb(skb);
 
 	return 0;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_net_device_stats
  *
  * Whenever an application needs to get statistics for the interface,
@@ -1248,21 +1189,16 @@ static struct net_device_stats *appnic_get_stats(struct net_device *dev)
 {
 	struct appnic_device *pdata = netdev_priv(dev);
 
-	/*
-	 * Update the statistics structure.
-	 */
+	/* Update the statistics structure. */
 
 	get_hw_statistics(pdata);
 
-	/*
-	 * That's all.
-	 */
+	/* That's all. */
 
 	return &pdata->stats;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_set_mac_address
  */
 
@@ -1291,14 +1227,12 @@ static int appnic_set_mac_address(struct net_device *dev, void *data)
 	return 0;
 }
 
-/*
-  ======================================================================
-  ETHTOOL Operations
-  ======================================================================
+/* ======================================================================
+   ETHTOOL Operations
+   ======================================================================
 */
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_get_drvinfo
  */
 
@@ -1309,8 +1243,7 @@ static void appnic_get_drvinfo(struct net_device *dev,
 	strcpy(info->version, LSI_DRV_VERSION);
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_get_settings
  */
 
@@ -1326,20 +1259,16 @@ static int appnic_get_settings(struct net_device *dev,
 	return phy_ethtool_gset(phydev, cmd);
 }
 
-/*
- * Fill in the struture...
- */
-
+/* Fill in the struture... */
 static const struct ethtool_ops appnic_ethtool_ops = {
 	.get_drvinfo = appnic_get_drvinfo,
 	.get_settings = appnic_get_settings
 };
 
 
-/*
-  ======================================================================
-  Linux Module Interface.
-  ======================================================================
+/* ======================================================================
+   Linux Module Interface.
+   ======================================================================
 */
 
 static const struct net_device_ops appnic_netdev_ops = {
@@ -1354,8 +1283,7 @@ static const struct net_device_ops appnic_netdev_ops = {
 
 };
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_init
  */
 
@@ -1375,22 +1303,12 @@ int appnic_init(struct net_device *dev)
 	writel(0x0, gpreg_base+0x78);
 #endif
 
-
-	/*
-	 * Reset the MAC
-	 */
-
+	/* Reset the MAC. */
 	write_mac(0x80000000, APPNIC_DMA_PCI_CONTROL);
 
-	/*
-	 * Allocate memory and initialize the descriptors
-	 */
-
-
-	/*
-	 * fixup num_[rt]x_desc
-	 */
+	/* Allocate memory and initialize the descriptors. */
 
+	/* fixup num_[rt]x_desc */
 	if (0 != (rx_num_desc % DESCRIPTOR_GRANULARITY)) {
 		pr_warn("%s: rx_num_desc was not a multiple of %d.\n",
 			LSI_DRV_NAME, DESCRIPTOR_GRANULARITY);
@@ -1409,11 +1327,9 @@ int appnic_init(struct net_device *dev)
 
 	pdata->tx_num_desc = tx_num_desc;
 
-	/*
-	 * up [rt]x_buf_sz. Must be some multiple of 64 bytes
+	/* up [rt]x_buf_sz. Must be some multiple of 64 bytes
 	 * per descriptor.
 	 */
-
 	if (0 != (rx_buf_sz % (BUFFER_ALIGNMENT * rx_num_desc))) {
 		pr_warn("%s: rx_buf_sz was not a multiple of %d.\n",
 			LSI_DRV_NAME, (BUFFER_ALIGNMENT * rx_num_desc));
@@ -1432,18 +1348,17 @@ int appnic_init(struct net_device *dev)
 
 	pdata->tx_buf_sz = tx_buf_sz;
 
-	/*
-	 * Allocate dma-able memory. Broken into smaller parts to keep
+	/* Allocate dma-able memory. Broken into smaller parts to keep
 	 * from allocating a single large chunk of memory, but not too
 	 * small since mappings obtained from dma_alloc_coherent() have
 	 * a minimum size of one page.
 	 */
-
 	pdata->dma_alloc_size =
 		/* The tail pointers (rx and tx) */
 		(sizeof(union appnic_queue_pointer) * 2) +
 		/* The RX descriptor ring (and padding to allow
-		 * 64 byte alignment) */
+		 * 64 byte alignment)
+		 */
 		(sizeof(struct appnic_dma_descriptor) * pdata->rx_num_desc) +
 		(DESCRIPTOR_GRANULARITY) +
 		/* The TX descriptor ring (and padding...) */
@@ -1458,9 +1373,8 @@ int appnic_init(struct net_device *dev)
 		/* The TX buffer (and padding...) */
 		(pdata->tx_buf_sz) + (BUFFER_ALIGNMENT);
 
-	/*
-	 * This needs to be set to something sane for
-	 * dma_alloc_coherent()
+	/* This needs to be set to something sane for
+	 * dma_alloc_coherent().
 	 */
 
 #if defined(CONFIG_ARM)
@@ -1533,10 +1447,7 @@ int appnic_init(struct net_device *dev)
 	pdata->dma_alloc_offset_tx = (int)pdata->dma_alloc_tx -
 					(int)pdata->dma_alloc_dma_tx;
 
-	/*
-	 * Initialize the tail pointers
-	 */
-
+	/* Initialize the tail pointers. */
 	dma_offset = pdata->dma_alloc;
 
 	pdata->rx_tail = (union appnic_queue_pointer *)dma_offset;
@@ -1552,10 +1463,7 @@ int appnic_init(struct net_device *dev)
 	memset((void *)pdata->tx_tail, 0, sizeof(union appnic_queue_pointer));
 
 
-	/*
-	 * Initialize the descriptor pointers
-	 */
-
+	/* Initialize the descriptor pointers. */
 	pdata->rx_desc = (struct appnic_dma_descriptor *)ALIGN64B(dma_offset);
 	pdata->rx_desc_dma = (int)pdata->rx_desc - (int)pdata->dma_alloc_offset;
 	dma_offset += (sizeof(struct appnic_dma_descriptor) *
@@ -1570,10 +1478,7 @@ int appnic_init(struct net_device *dev)
 	memset((void *)pdata->tx_desc, 0,
 	       (sizeof(struct appnic_dma_descriptor) * pdata->tx_num_desc));
 
-	/*
-	 * Initialize the buffer pointers
-	 */
-
+	/* Initialize the buffer pointers. */
 	dma_offset = pdata->dma_alloc_rx;
 
 	pdata->rx_buf = (void *)ALIGN64B(dma_offset);
@@ -1588,10 +1493,7 @@ int appnic_init(struct net_device *dev)
 				(int)pdata->dma_alloc_offset_tx;
 	pdata->tx_buf_per_desc = pdata->tx_buf_sz / pdata->tx_num_desc;
 
-	/*
-	 * Initialize the descriptors
-	 */
-
+	/* Initialize the descriptors. */
 	buf = (unsigned long)pdata->rx_buf_dma;
 	for (index = 0; index < pdata->rx_num_desc; ++index) {
 		memset((void *) &descriptor, 0,
@@ -1624,26 +1526,17 @@ int appnic_init(struct net_device *dev)
 		buf += pdata->tx_buf_per_desc;
 	}
 
-	/*
-	 * Initialize the spinlocks.
-	 */
-
+	/* Initialize the spinlocks. */
 	spin_lock_init(&pdata->dev_lock);
 	spin_lock_init(&pdata->extra_lock);
 
-	/*
-	 * Take MAC out of reset
-	 */
-
+	/* Take MAC out of reset. */
 	write_mac(0x0, APPNIC_RX_SOFT_RESET);
 	write_mac(0x1, APPNIC_RX_MODE);
 	write_mac(0x0, APPNIC_TX_SOFT_RESET);
 	write_mac(0x1, APPNIC_TX_MODE);
 
-        /*
-	 * Set the watermark.
-	 */
-
+	/* Set the watermark. */
 	ncr_read(NCP_REGION_ID(0x16, 0xff), 0x10, 4, &node_cfg);
 
 	if (0 == (0x80000000 & node_cfg))
@@ -1667,9 +1560,7 @@ int appnic_init(struct net_device *dev)
 	out_le32(dma_base + 0x64, 0xc0);
 #endif
 
-	/*
-	 * Set the MAC address
-	 */
+	/* Set the MAC address */
 	pr_info("%s: MAC %02x:%02x:%02x:%02x:%02x:%02x\n", LSI_DRV_NAME,
 		dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
 		dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
@@ -1677,14 +1568,9 @@ int appnic_init(struct net_device *dev)
 	memcpy(&(address.sa_data[0]), dev->dev_addr, 6);
 	appnic_set_mac_address(dev, &address);
 
-	/*
-	 * Initialize the queue pointers.
-	 */
-
-	/*
-	 * Receiver
-	 */
+	/* Initialize the queue pointers. */
 
+	/* Receiver */
 	memset((void *)&pdata->rx_tail_copy, 0,
 	       sizeof(union appnic_queue_pointer));
 	memset((void *)&pdata->rx_head, 0,
@@ -1695,23 +1581,19 @@ int appnic_init(struct net_device *dev)
 		   sizeof(struct appnic_dma_descriptor)) / 1024,
 		  APPNIC_DMA_RX_QUEUE_SIZE);
 
-	/*
-	 * Indicate that all of the receive descriptors
-	 * are ready
+	/* Indicate that all of the receive descriptors
+	 * are ready.
 	 */
-
 	pdata->rx_head.bits.offset = (pdata->rx_num_desc - 1) *
 					sizeof(struct appnic_dma_descriptor);
 	write_mac(pdata->rx_tail_dma, APPNIC_DMA_RX_TAIL_POINTER_ADDRESS);
 
-	/*
-	 * N.B.
+	/* N.B.
 	 *
 	 * The boot loader may have used the NIC.  If so, the
 	 * tail pointer must be read and the head pointer (and
 	 * local copy of the tail) based on it.
 	 */
-
 	pdata->rx_tail->raw =
 		  read_mac(APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY);
 	pdata->rx_tail_copy.raw = pdata->rx_tail->raw;
@@ -1721,10 +1603,7 @@ int appnic_init(struct net_device *dev)
 		  (0 == pdata->rx_head.bits.generation_bit) ? 1 : 0;
 	write_mac(pdata->rx_head.raw, APPNIC_DMA_RX_HEAD_POINTER);
 
-	/*
-	 * Transmitter
-	 */
-
+	/* Transmitter */
 	memset((void *) &pdata->tx_tail_copy, 0,
 	       sizeof(union appnic_queue_pointer));
 	memset((void *) &pdata->tx_head, 0,
@@ -1736,25 +1615,21 @@ int appnic_init(struct net_device *dev)
 		  APPNIC_DMA_TX_QUEUE_SIZE);
 	write_mac(pdata->tx_tail_dma, APPNIC_DMA_TX_TAIL_POINTER_ADDRESS);
 
-	/*
-	 * N.B.
+	/* N.B.
 	 *
 	 * The boot loader may have used the NIC.  If so, the
 	 * tail pointer must be read and the head pointer (and
 	 * local copy of the tail) based on it.
 	 */
-
 	pdata->tx_tail->raw = read_mac(APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY);
 	pdata->tx_tail_copy.raw = pdata->tx_tail->raw;
 	pdata->tx_head.raw = pdata->tx_tail->raw;
 	write_mac(pdata->tx_head.raw, APPNIC_DMA_TX_HEAD_POINTER);
 
 	/* Clear statistics */
-
 	clear_statistics(pdata);
 
 	/* Fill in the net_device structure */
-
 	ether_setup(dev);
 #ifdef CONFIG_ARM
 	dev->irq = pdata->dma_interrupt;
@@ -1783,31 +1658,13 @@ int appnic_init(struct net_device *dev)
 	return 0;
 }
 
-/*
- * ----------------------------------------------------------------------
- * appnic_read_proc
- */
-
-static int
-appnic_read_proc(char *page, char **start, off_t offset,
-		 int count, int *eof, void *data)
-{
-	int length;
-
-	length = sprintf(page, "-- appnic.c -- Profiling is disabled\n");
-
-	/* That's all */
-	return length;
-}
-
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_probe_config_dt
  */
 
 #ifdef CONFIG_OF
-static int __devinit appnic_probe_config_dt(struct net_device *dev,
-					    struct device_node *np)
+static int appnic_probe_config_dt(struct net_device *dev,
+				  struct device_node *np)
 {
 	struct appnic_device *pdata = netdev_priv(dev);
 	const u32 *field;
@@ -1953,12 +1810,11 @@ static inline int appnic_probe_config_dt(struct net_device *dev,
 }
 #endif /* CONFIG_OF */
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_drv_probe
  */
 
-static int __devinit appnic_drv_probe(struct platform_device *pdev)
+static int appnic_drv_probe(struct platform_device *pdev)
 {
 	int rc = 0;
 	struct device_node *np = pdev->dev.of_node;
@@ -1982,8 +1838,7 @@ static int __devinit appnic_drv_probe(struct platform_device *pdev)
 
 	pdata = netdev_priv(dev);
 
-	/*
-	 * Get the physical addresses, interrupt number, etc. from the
+	/* Get the physical addresses, interrupt number, etc. from the
 	 * device tree.  If no entry exists (older boot loader...) just
 	 * use the pre-devicetree method.
 	 */
@@ -1996,8 +1851,7 @@ static int __devinit appnic_drv_probe(struct platform_device *pdev)
 
 #ifdef CONFIG_MTD_NAND_EP501X_UBOOTENV
 
-		/*
-		 * Attempt to get device settings from the DTB failed, so
+		/* Attempt to get device settings from the DTB failed, so
 		 * try to grab the ethernet MAC from the u-boot environment
 		 * and use hard-coded values for device base addresses.
 		 */
@@ -2091,21 +1945,15 @@ static int __devinit appnic_drv_probe(struct platform_device *pdev)
 		rc = -ENODEV;
 		goto out;
 	}
-
-	/* Create the /proc entry. */
-	create_proc_read_entry("driver/appnic", 0, NULL,
-				appnic_read_proc, NULL);
-
 out:
 	return rc;
 }
 
-/*
- * ----------------------------------------------------------------------
+/* ----------------------------------------------------------------------
  * appnic_drv_remove
  */
 
-static int __devexit appnic_drv_remove(struct platform_device *pdev)
+static int appnic_drv_remove(struct platform_device *pdev)
 {
 	struct net_device *dev = platform_get_drvdata(pdev);
 	struct appnic_device *pdata;
@@ -2149,7 +1997,7 @@ MODULE_DEVICE_TABLE(of, appnic_dt_ids);
 
 static struct platform_driver appnic_driver = {
 	.probe = appnic_drv_probe,
-	.remove = __devexit_p(appnic_drv_remove),
+	.remove = appnic_drv_remove,
 	.driver = {
 		.name   = LSI_DRV_NAME,
 		.owner  = THIS_MODULE,
diff --git a/drivers/spi/spi-pl022.c b/drivers/spi/spi-pl022.c
index f52be3e..b8746e5 100644
--- a/drivers/spi/spi-pl022.c
+++ b/drivers/spi/spi-pl022.c
@@ -1,7 +1,7 @@
 /*
  * A driver for the ARM PL022 PrimeCell SSP/SPI bus master.
  *
- * Copyright (C) 2008-2012 ST-Ericsson AB
+ * Copyright (C) 2008-2009 ST-Ericsson AB
  * Copyright (C) 2006 STMicroelectronics Pvt. Ltd.
  *
  * Author: Linus Walleij <linus.walleij@stericsson.com>
@@ -46,9 +46,6 @@
 #include <linux/dma-mapping.h>
 #include <linux/scatterlist.h>
 #include <linux/pm_runtime.h>
-#include <linux/gpio.h>
-#include <linux/of_gpio.h>
-#include <linux/pinctrl/consumer.h>
 
 #ifndef CONFIG_ARM_AMBA
 #define writew(b, addr) writel(b, addr)
@@ -337,7 +334,7 @@ struct vendor_data {
 
 /**
  * struct pl022 - This is the private SSP driver data structure
- * @dev: AMBA device model hookup
+ * @adev: AMBA device model hookup
  * @vendor: vendor data for the IP block
  * @phybase: the physical memory where the SSP device resides
  * @virtbase: the virtual memory where the SSP is mapped
@@ -371,24 +368,17 @@ struct vendor_data {
  * @sgt_rx: scattertable for the RX transfer
  * @sgt_tx: scattertable for the TX transfer
  * @dummypage: a dummy page used for driving data on the bus with DMA
- * @cur_cs: current chip select (gpio)
- * @chipselects: list of chipselects (gpios)
  */
 struct pl022 {
 #ifdef CONFIG_ARM_AMBA
 	struct amba_device		*dev;
 #else
-	struct platform_device          *dev;
+	struct platform_device		*dev;
 #endif
 	struct vendor_data		*vendor;
 	resource_size_t			phybase;
 	void __iomem			*virtbase;
 	struct clk			*clk;
-	/* Two optional pin states - default & sleep */
-	struct pinctrl			*pinctrl;
-	struct pinctrl_state		*pins_default;
-	struct pinctrl_state		*pins_idle;
-	struct pinctrl_state		*pins_sleep;
 	struct spi_master		*master;
 	struct pl022_ssp_controller	*master_info;
 	/* Message per-transfer pump */
@@ -415,8 +405,6 @@ struct pl022 {
 	char				*dummypage;
 	bool				dma_running;
 #endif
-	int cur_cs;
-	int *chipselects;
 };
 
 /**
@@ -461,14 +449,6 @@ static void null_cs_control(u32 command)
 	pr_debug("pl022: dummy chip select control, CS=0x%x\n", command);
 }
 
-static void pl022_cs_control(struct pl022 *pl022, u32 command)
-{
-	if (gpio_is_valid(pl022->cur_cs))
-		gpio_set_value(pl022->cur_cs, command);
-	else
-		pl022->cur_chip->cs_control(command);
-}
-
 /**
  * giveback - current spi_message is over, schedule next message and call
  * callback of this message. Assumes that caller already
@@ -515,7 +495,7 @@ static void giveback(struct pl022 *pl022)
 		if (next_msg && next_msg->spi != pl022->cur_msg->spi)
 			next_msg = NULL;
 		if (!next_msg || pl022->cur_msg->state == STATE_ERROR)
-			pl022_cs_control(pl022, SSP_CHIP_DESELECT);
+			pl022->cur_chip->cs_control(SSP_CHIP_DESELECT);
 		else
 			pl022->next_msg_cs_active = true;
 
@@ -584,8 +564,7 @@ static void restore_state(struct pl022 *pl022)
 /* ST versions have slightly different bit layout */
 #define DEFAULT_SSP_REG_CR0_ST ( \
 	GEN_MASK_BITS(SSP_DATA_BITS_12, SSP_CR0_MASK_DSS_ST, 0)	| \
-	GEN_MASK_BITS(SSP_MICROWIRE_CHANNEL_FULL_DUPLEX, \
-		SSP_CR0_MASK_HALFDUP_ST, 5) | \
+	GEN_MASK_BITS(SSP_MICROWIRE_CHANNEL_FULL_DUPLEX, SSP_CR0_MASK_HALFDUP_ST, 5) | \
 	GEN_MASK_BITS(SSP_CLK_POL_IDLE_LOW, SSP_CR0_MASK_SPO, 6) | \
 	GEN_MASK_BITS(SSP_CLK_SECOND_EDGE, SSP_CR0_MASK_SPH, 7) | \
 	GEN_MASK_BITS(SSP_DEFAULT_CLKRATE, SSP_CR0_MASK_SCR, 8) | \
@@ -615,8 +594,7 @@ static void restore_state(struct pl022 *pl022)
 	GEN_MASK_BITS(SSP_TX_MSB, SSP_CR1_MASK_TENDN_ST, 5) | \
 	GEN_MASK_BITS(SSP_MWIRE_WAIT_ZERO, SSP_CR1_MASK_MWAIT_ST, 6) |\
 	GEN_MASK_BITS(SSP_RX_1_OR_MORE_ELEM, SSP_CR1_MASK_RXIFLSEL_ST, 7) | \
-	GEN_MASK_BITS(SSP_TX_1_OR_MORE_EMPTY_LOC, \
-		SSP_CR1_MASK_TXIFLSEL_ST, 10) \
+	GEN_MASK_BITS(SSP_TX_1_OR_MORE_EMPTY_LOC, SSP_CR1_MASK_TXIFLSEL_ST, 10)\
 )
 
 /*
@@ -630,10 +608,8 @@ static void restore_state(struct pl022 *pl022)
 	GEN_MASK_BITS(SSP_RX_MSB, SSP_CR1_MASK_RENDN_ST, 4) | \
 	GEN_MASK_BITS(SSP_TX_MSB, SSP_CR1_MASK_TENDN_ST, 5) | \
 	GEN_MASK_BITS(SSP_RX_1_OR_MORE_ELEM, SSP_CR1_MASK_RXIFLSEL_ST, 7) | \
-	GEN_MASK_BITS(SSP_TX_1_OR_MORE_EMPTY_LOC, \
-		SSP_CR1_MASK_TXIFLSEL_ST, 10) | \
-	GEN_MASK_BITS(SSP_FEEDBACK_CLK_DELAY_NONE, \
-		SSP_CR1_MASK_FBCLKDEL_ST, 13) \
+	GEN_MASK_BITS(SSP_TX_1_OR_MORE_EMPTY_LOC, SSP_CR1_MASK_TXIFLSEL_ST, 10) | \
+	GEN_MASK_BITS(SSP_FEEDBACK_CLK_DELAY_NONE, SSP_CR1_MASK_FBCLKDEL_ST, 13) \
 )
 
 #define DEFAULT_SSP_REG_CPSR ( \
@@ -858,7 +834,8 @@ static void dma_callback(void *data)
 	/* Update total bytes transferred */
 	msg->actual_length += pl022->cur_transfer->len;
 	if (pl022->cur_transfer->cs_change)
-		pl022_cs_control(pl022, SSP_CHIP_DESELECT);
+		pl022->cur_chip->
+			cs_control(SSP_CHIP_DESELECT);
 
 	/* Move to next transfer */
 	msg->state = next_transfer(pl022);
@@ -1159,40 +1136,6 @@ err_no_rxchan:
 	return -ENODEV;
 }
 
-#ifdef CONFIG_ARM_AMBA
-static int pl022_dma_autoprobe(struct pl022 *pl022)
-{
-	struct device *dev = &pl022->adev->dev;
-
-	/*
-	 * automatically configure DMA channels from platform,
-	 * normally using DT
-	 */
-	pl022->dma_rx_channel = dma_request_slave_channel(dev, "rx");
-	if (!pl022->dma_rx_channel)
-		goto err_no_rxchan;
-
-	pl022->dma_tx_channel = dma_request_slave_channel(dev, "tx");
-	if (!pl022->dma_tx_channel)
-		goto err_no_txchan;
-
-	pl022->dummypage = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	if (!pl022->dummypage)
-		goto err_no_dummypage;
-
-	return 0;
-
-err_no_dummypage:
-	dma_release_channel(pl022->dma_tx_channel);
-	pl022->dma_tx_channel = NULL;
-err_no_txchan:
-	dma_release_channel(pl022->dma_rx_channel);
-	pl022->dma_rx_channel = NULL;
-err_no_rxchan:
-	return -ENODEV;
-}
-#endif
-
 static void terminate_dma(struct pl022 *pl022)
 {
 	struct dma_chan *rxchan = pl022->dma_rx_channel;
@@ -1221,13 +1164,6 @@ static inline int configure_dma(struct pl022 *pl022)
 	return -ENODEV;
 }
 
-#ifdef CONFIG_ARM_AMBA
-static inline int pl022_dma_autoprobe(struct pl022 *pl022)
-{
-	return 0;
-}
-#endif
-
 static inline int pl022_dma_probe(struct pl022 *pl022)
 {
 	return 0;
@@ -1324,14 +1260,16 @@ static irqreturn_t pl022_interrupt_handler(int irq, void *dev_id)
 		       SSP_IMSC(pl022->virtbase));
 		writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));
 		if (unlikely(pl022->rx > pl022->rx_end)) {
-			dev_warn(&pl022->dev->dev,
-			"read %u surplus bytes (did you request an odd number of bytes on a 16bit bus?)\n",
+			dev_warn(&pl022->dev->dev, "read %u surplus "
+				 "bytes (did you request an odd "
+				 "number of bytes on a 16bit bus?)\n",
 				 (u32) (pl022->rx - pl022->rx_end));
 		}
 		/* Update total bytes transferred */
 		msg->actual_length += pl022->cur_transfer->len;
 		if (pl022->cur_transfer->cs_change)
-			pl022_cs_control(pl022, SSP_CHIP_DESELECT);
+			pl022->cur_chip->
+				cs_control(SSP_CHIP_DESELECT);
 		/* Move to next transfer */
 		msg->state = next_transfer(pl022);
 		tasklet_schedule(&pl022->pump_transfers);
@@ -1416,7 +1354,7 @@ static void pump_transfers(unsigned long data)
 
 		/* Reselect chip select only if cs_change was requested */
 		if (previous->cs_change)
-			pl022_cs_control(pl022, SSP_CHIP_SELECT);
+			pl022->cur_chip->cs_control(SSP_CHIP_SELECT);
 	} else {
 		/* STATE_START */
 		message->state = STATE_RUNNING;
@@ -1443,7 +1381,7 @@ static void pump_transfers(unsigned long data)
 err_config_dma:
 	/* enable all interrupts except RX */
 	writew(ENABLE_ALL_INTERRUPTS & ~SSP_IMSC_MASK_RXIM,
-		SSP_IMSC(pl022->virtbase));
+	       SSP_IMSC(pl022->virtbase));
 }
 
 static void do_interrupt_dma_transfer(struct pl022 *pl022)
@@ -1456,7 +1394,7 @@ static void do_interrupt_dma_transfer(struct pl022 *pl022)
 
 	/* Enable target chip, if not already active */
 	if (!pl022->next_msg_cs_active)
-		pl022_cs_control(pl022, SSP_CHIP_SELECT);
+		pl022->cur_chip->cs_control(SSP_CHIP_SELECT);
 
 	if (set_up_next_transfer(pl022, pl022->cur_transfer)) {
 		/* Error path */
@@ -1508,12 +1446,12 @@ static void do_polling_transfer(struct pl022 *pl022)
 			if (previous->delay_usecs)
 				udelay(previous->delay_usecs);
 			if (previous->cs_change)
-				pl022_cs_control(pl022, SSP_CHIP_SELECT);
+				pl022->cur_chip->cs_control(SSP_CHIP_SELECT);
 		} else {
 			/* STATE_START */
 			message->state = STATE_RUNNING;
 			if (!pl022->next_msg_cs_active)
-				pl022_cs_control(pl022, SSP_CHIP_SELECT);
+				pl022->cur_chip->cs_control(SSP_CHIP_SELECT);
 		}
 
 		/* Configuration Changing Per Transfer */
@@ -1545,7 +1483,7 @@ static void do_polling_transfer(struct pl022 *pl022)
 		/* Update total byte transferred */
 		message->actual_length += pl022->cur_transfer->len;
 		if (pl022->cur_transfer->cs_change)
-			pl022_cs_control(pl022, SSP_CHIP_DESELECT);
+			pl022->cur_chip->cs_control(SSP_CHIP_DESELECT);
 		/* Move to next transfer */
 		message->state = next_transfer(pl022);
 	}
@@ -1574,7 +1512,6 @@ static int pl022_transfer_one_message(struct spi_master *master,
 
 	/* Setup the SPI using the per chip configuration */
 	pl022->cur_chip = spi_get_ctldata(msg->spi);
-	pl022->cur_cs = pl022->chipselects[msg->spi->chip_select];
 
 	restore_state(pl022);
 	flush(pl022);
@@ -1723,9 +1660,11 @@ static int verify_controller_parameters(struct pl022 *pl022,
 			}
 		} else {
 			if (chip_info->duplex !=
-			   SSP_MICROWIRE_CHANNEL_FULL_DUPLEX)
+			    SSP_MICROWIRE_CHANNEL_FULL_DUPLEX)
 				dev_err(&pl022->dev->dev,
-					"Microwire half duplex mode requested, but this is only available in the ST version of PL022\n");
+					"Microwire half duplex mode requested,"
+					" but this is only available in the"
+					" ST version of PL022\n");
 			return -EINVAL;
 		}
 	}
@@ -1845,14 +1784,12 @@ static const struct pl022_config_chip pl022_default_chip_info = {
 static int pl022_setup(struct spi_device *spi)
 {
 	struct pl022_config_chip const *chip_info;
-	struct pl022_config_chip chip_info_dt;
 	struct chip_data *chip;
 	struct ssp_clock_params clk_freq = { .cpsdvsr = 0, .scr = 0};
 	int status = 0;
 	struct pl022 *pl022 = spi_master_get_devdata(spi->master);
 	unsigned int bits = spi->bits_per_word;
 	u32 tmp;
-	struct device_node *np = spi->dev.of_node;
 
 	if (!spi->max_speed_hz)
 		return -EINVAL;
@@ -1875,32 +1812,10 @@ static int pl022_setup(struct spi_device *spi)
 	chip_info = spi->controller_data;
 
 	if (chip_info == NULL) {
-		if (np) {
-			chip_info_dt = pl022_default_chip_info;
-
-			chip_info_dt.hierarchy = SSP_MASTER;
-			of_property_read_u32(np, "pl022,interface",
-				&chip_info_dt.iface);
-			of_property_read_u32(np, "pl022,com-mode",
-				&chip_info_dt.com_mode);
-			of_property_read_u32(np, "pl022,rx-level-trig",
-				&chip_info_dt.rx_lev_trig);
-			of_property_read_u32(np, "pl022,tx-level-trig",
-				&chip_info_dt.tx_lev_trig);
-			of_property_read_u32(np, "pl022,ctrl-len",
-				&chip_info_dt.ctrl_len);
-			of_property_read_u32(np, "pl022,wait-state",
-				&chip_info_dt.wait_state);
-			of_property_read_u32(np, "pl022,duplex",
-				&chip_info_dt.duplex);
-
-			chip_info = &chip_info_dt;
-		} else {
-			chip_info = &pl022_default_chip_info;
-			/* spi_board_info.controller_data not is supplied */
-			dev_dbg(&spi->dev,
-				"using default controller_data settings\n");
-		}
+		chip_info = &pl022_default_chip_info;
+		/* spi_board_info.controller_data not is supplied */
+		dev_dbg(&spi->dev,
+			"using default controller_data settings\n");
 	} else
 		dev_dbg(&spi->dev,
 			"using user supplied controller_data settings\n");
@@ -1943,9 +1858,8 @@ static int pl022_setup(struct spi_device *spi)
 	chip->xfer_type = chip_info->com_mode;
 	if (!chip_info->cs_control) {
 		chip->cs_control = null_cs_control;
-		if (!gpio_is_valid(pl022->chipselects[spi->chip_select]))
-			dev_warn(&spi->dev,
-				 "invalid chip select\n");
+		dev_warn(&spi->dev,
+			 "chip select function is NULL for this chip\n");
 	} else
 		chip->cs_control = chip_info->cs_control;
 
@@ -2090,36 +2004,6 @@ static void pl022_cleanup(struct spi_device *spi)
 	kfree(chip);
 }
 
-#ifdef CONFIG_ARM_AMBA
-static struct pl022_ssp_controller *
-pl022_platform_data_dt_get(struct device *dev)
-{
-	struct device_node *np = dev->of_node;
-	struct pl022_ssp_controller *pd;
-	u32 tmp;
-
-	if (!np) {
-		dev_err(dev, "no dt node defined\n");
-		return NULL;
-	}
-
-	pd = devm_kzalloc(dev, sizeof(struct pl022_ssp_controller), GFP_KERNEL);
-	if (!pd) {
-		dev_err(dev, "cannot allocate platform data memory\n");
-		return NULL;
-	}
-
-	pd->bus_id = -1;
-	of_property_read_u32(np, "num-cs", &tmp);
-	pd->num_chipselect = tmp;
-	of_property_read_u32(np, "pl022,autosuspend-delay",
-			     &pd->autosuspend_delay);
-	pd->rt = of_property_read_bool(np, "pl022,rt");
-
-	return pd;
-}
-#endif
-
 static int pl022_probe(
 	struct device *dev,
 	struct vendor_data *vendor,
@@ -2128,114 +2012,40 @@ static int pl022_probe(
 {
 	struct pl022_ssp_controller *platform_info = dev->platform_data;
 	struct spi_master *master;
-	struct pl022 *pl022 = NULL;	/* Data for this driver */
-	int status = 0, i, num_cs;
-#ifdef CONFIG_ARM_AMBA
-	struct device_node *np = dev->dev.of_node;
-
-	if (!platform_info && IS_ENABLED(CONFIG_OF))
-		platform_info = pl022_platform_data_dt_get(dev);
-#endif
-
-	if (!platform_info) {
-		dev_err(dev, "probe: no platform data defined\n");
-		return -ENODEV;
-	}
+	struct pl022 *pl022 = NULL;	/*Data for this driver */
+	int status = 0;
 
-	if (platform_info->num_chipselect) {
-		num_cs = platform_info->num_chipselect;
-	} else {
-		dev_err(dev, "probe: no chip select defined\n");
-		return -ENODEV;
+	if (platform_info == NULL) {
+		dev_err(dev, "probe - no platform data supplied\n");
+		status = -ENODEV;
+		goto err_no_pdata;
 	}
 
 	/* Allocate master with space for data */
 	master = spi_alloc_master(dev, sizeof(struct pl022));
 	if (master == NULL) {
 		dev_err(dev, "probe - cannot alloc SPI master\n");
-		return -ENOMEM;
+		status = -ENOMEM;
+		goto err_no_master;
 	}
 
 	pl022 = spi_master_get_devdata(master);
 	pl022->master = master;
 	pl022->master_info = platform_info;
 	pl022->vendor = vendor;
-	pl022->chipselects = devm_kzalloc(dev, num_cs * sizeof(int),
-					  GFP_KERNEL);
-
-#ifdef CONFIG_ARM_AMBA
-	pl022->pinctrl = devm_pinctrl_get(dev);
-	if (IS_ERR(pl022->pinctrl)) {
-		status = PTR_ERR(pl022->pinctrl);
-		goto err_no_pinctrl;
-	}
-
-	pl022->pins_default = pinctrl_lookup_state(pl022->pinctrl,
-						 PINCTRL_STATE_DEFAULT);
-	/* enable pins to be muxed in and configured */
-	if (!IS_ERR(pl022->pins_default)) {
-		status = pinctrl_select_state(pl022->pinctrl,
-				pl022->pins_default);
-		if (status)
-			dev_err(dev, "could not set default pins\n");
-	} else
-		dev_err(dev, "could not get default pinstate\n");
-
-	pl022->pins_idle = pinctrl_lookup_state(pl022->pinctrl,
-					      PINCTRL_STATE_IDLE);
-	if (IS_ERR(pl022->pins_idle))
-		dev_dbg(dev, "could not get idle pinstate\n");
-
-	pl022->pins_sleep = pinctrl_lookup_state(pl022->pinctrl,
-					       PINCTRL_STATE_SLEEP);
-	if (IS_ERR(pl022->pins_sleep))
-		dev_dbg(dev, "could not get sleep pinstate\n");
-#endif
 
 	/*
 	 * Bus Number Which has been Assigned to this SSP controller
 	 * on this board
 	 */
 	master->bus_num = platform_info->bus_id;
-	master->num_chipselect = num_cs;
+	master->num_chipselect = platform_info->num_chipselect;
 	master->cleanup = pl022_cleanup;
 	master->setup = pl022_setup;
 	master->prepare_transfer_hardware = pl022_prepare_transfer_hardware;
 	master->transfer_one_message = pl022_transfer_one_message;
 	master->unprepare_transfer_hardware = pl022_unprepare_transfer_hardware;
 	master->rt = platform_info->rt;
-#ifdef CONFIG_ARM_AMBA
-	master->dev.of_node = dev->of_node;
-#endif
-
-	if (platform_info->num_chipselect && platform_info->chipselects) {
-		for (i = 0; i < num_cs; i++)
-			pl022->chipselects[i] = platform_info->chipselects[i];
-#ifdef CONFIG_ARM_AMBA
-	} else if (IS_ENABLED(CONFIG_OF)) {
-		for (i = 0; i < num_cs; i++) {
-			int cs_gpio = of_get_named_gpio(np, "cs-gpios", i);
-
-			if (cs_gpio == -EPROBE_DEFER) {
-				status = -EPROBE_DEFER;
-				goto err_no_gpio;
-			}
-
-			pl022->chipselects[i] = cs_gpio;
-
-			if (gpio_is_valid(cs_gpio)) {
-				if (devm_gpio_request(dev, cs_gpio, "ssp-pl022"))
-					dev_err(&adev->dev,
-						"could not request %d gpio\n",
-						cs_gpio);
-				else if (gpio_direction_output(cs_gpio, 1))
-					dev_err(&adev->dev,
-						"could set gpio %d as output\n",
-						cs_gpio);
-			}
-		}
-#endif
-	}
 
 	/*
 	 * Supports mode 0-3, loopback, and active low CS. Transfers are
@@ -2251,13 +2061,13 @@ static int pl022_probe(
 			dev->driver->name))
 		goto err_no_ioregion;
 
-	pl022->phybase = dev->res.start;
+	pl022->phybase = res->start;
 	pl022->virtbase = ioremap(res->start, resource_size(res));
 	if (pl022->virtbase == NULL) {
 		status = -ENOMEM;
 		goto err_no_ioremap;
 	}
-	pr_info("pl022: mapped registers from 0x%08x to %p\n",
+	pr_info("pl022: mapped registers from 0x%llx to %p\n",
 		res->start, pl022->virtbase);
 
 	pl022->clk = clk_get(dev, NULL);
@@ -2288,24 +2098,15 @@ static int pl022_probe(
 	       SSP_CR1(pl022->virtbase));
 	load_ssp_default_config(pl022);
 
-	status = devm_request_irq(dev, irq, pl022_interrupt_handler,
-				  0, "pl022", pl022);
+	status = request_irq(irq, pl022_interrupt_handler, 0, "pl022",
+			     pl022);
 	if (status < 0) {
 		dev_err(dev, "probe - cannot get IRQ (%d)\n", status);
 		goto err_no_irq;
 	}
 
-#ifdef CONFIG_ARM_AMBA
-	/* Get DMA channels, try autoconfiguration first */
-	status = pl022_dma_autoprobe(pl022);
-
-	/* If that failed, use channels from platform_info */
-	if (status == 0)
-		platform_info->enable_dma = 1;
-	else if (platform_info->enable_dma) {
-#else
+	/* Get DMA channels */
 	if (platform_info->enable_dma) {
-#endif
 		status = pl022_dma_probe(pl022);
 		if (status != 0)
 			platform_info->enable_dma = 0;
@@ -2332,31 +2133,35 @@ static int pl022_probe(
 		pm_runtime_set_autosuspend_delay(dev,
 			platform_info->autosuspend_delay);
 		pm_runtime_use_autosuspend(dev);
+		pm_runtime_put_autosuspend(dev);
+	} else {
+		pm_runtime_put(dev);
 	}
-	pm_runtime_put(dev);
-
 	return 0;
 
  err_spi_register:
 	if (platform_info->enable_dma)
 		pl022_dma_remove(pl022);
+
+	free_irq(irq, pl022);
  err_no_irq:
 	clk_disable(pl022->clk);
  err_no_clk_en:
 	clk_unprepare(pl022->clk);
  err_clk_prep:
+	clk_put(pl022->clk);
  err_no_clk:
+	iounmap(pl022->virtbase);
  err_no_ioremap:
 	release_mem_region(res->start, resource_size(res));
  err_no_ioregion:
- err_no_gpio:
- err_no_pinctrl:
 	spi_master_put(master);
+ err_no_master:
+ err_no_pdata:
 	return status;
 }
 
-static int
-pl022_remove(struct device *dev, struct resource *res, int irq)
+static int pl022_remove(struct device *dev, struct resource *res, int irq)
 {
 	struct pl022 *pl022 = dev_get_drvdata(dev);
 
@@ -2367,72 +2172,25 @@ pl022_remove(struct device *dev, struct resource *res, int irq)
 	 * undo pm_runtime_put() in probe.  I assume that we're not
 	 * accessing the primecell here.
 	 */
-	pm_runtime_get_noresume(&dev->dev);
+	pm_runtime_get_noresume(dev);
 
 	load_ssp_default_config(pl022);
 	if (pl022->master_info->enable_dma)
 		pl022_dma_remove(pl022);
 
+	free_irq(irq, pl022);
 	clk_disable(pl022->clk);
 	clk_unprepare(pl022->clk);
+	clk_put(pl022->clk);
+	iounmap(pl022->virtbase);
 	release_mem_region(res->start, resource_size(res));
 	tasklet_disable(&pl022->pump_transfers);
 	spi_unregister_master(pl022->master);
+	spi_master_put(pl022->master);
 	dev_set_drvdata(dev, NULL);
 	return 0;
 }
 
-#if defined(CONFIG_SUSPEND) || defined(CONFIG_PM_RUNTIME)
-/*
- * These two functions are used from both suspend/resume and
- * the runtime counterparts to handle external resources like
- * clocks, pins and regulators when going to sleep.
- */
-static void pl022_suspend_resources(struct pl022 *pl022, bool runtime)
-{
-	int ret;
-	struct pinctrl_state *pins_state;
-
-	clk_disable(pl022->clk);
-
-	pins_state = runtime ? pl022->pins_idle : pl022->pins_sleep;
-	/* Optionally let pins go into sleep states */
-	if (!IS_ERR(pins_state)) {
-		ret = pinctrl_select_state(pl022->pinctrl, pins_state);
-		if (ret)
-			dev_err(&pl022->dev->dev, "could not set %s pins\n",
-				runtime ? "idle" : "sleep");
-	}
-}
-
-static void pl022_resume_resources(struct pl022 *pl022, bool runtime)
-{
-	int ret;
-
-	/* Optionaly enable pins to be muxed in and configured */
-	/* First go to the default state */
-	if (!IS_ERR(pl022->pins_default)) {
-		ret = pinctrl_select_state(pl022->pinctrl, pl022->pins_default);
-		if (ret)
-			dev_err(&pl022->dev->dev,
-				"could not set default pins\n");
-	}
-
-	if (!runtime) {
-		/* Then let's idle the pins until the next transfer happens */
-		if (!IS_ERR(pl022->pins_idle)) {
-			ret = pinctrl_select_state(pl022->pinctrl,
-					pl022->pins_idle);
-		if (ret)
-			dev_err(&pl022->dev->dev,
-				"could not set idle pins\n");
-		}
-	}
-
-	clk_enable(pl022->clk);
-}
-#endif
-
 #ifdef CONFIG_SUSPEND
 static int pl022_suspend(struct device *dev)
 {
@@ -2445,9 +2203,6 @@ static int pl022_suspend(struct device *dev)
 		return ret;
 	}
 
-	pm_runtime_get_sync(dev);
-	pl022_suspend_resources(pl022, false);
-
 	dev_dbg(dev, "suspended\n");
 	return 0;
 }
@@ -2457,9 +2212,6 @@ static int pl022_resume(struct device *dev)
 	struct pl022 *pl022 = dev_get_drvdata(dev);
 	int ret;
 
-	pl022_resume_resources(pl022, false);
-	pm_runtime_put(dev);
-
 	/* Start the queue running */
 	ret = spi_master_resume(pl022->master);
 	if (ret)
@@ -2476,7 +2228,8 @@ static int pl022_runtime_suspend(struct device *dev)
 {
 	struct pl022 *pl022 = dev_get_drvdata(dev);
 
-	pl022_suspend_resources(pl022, true);
+	clk_disable(pl022->clk);
+
 	return 0;
 }
 
@@ -2484,7 +2237,8 @@ static int pl022_runtime_resume(struct device *dev)
 {
 	struct pl022 *pl022 = dev_get_drvdata(dev);
 
-	pl022_resume_resources(pl022, true);
+	clk_enable(pl022->clk);
+
 	return 0;
 }
 #endif
@@ -2522,13 +2276,21 @@ static struct vendor_data vendor_st_pl023 = {
 	.loopback = false,
 };
 
-static int
-pl022_amba_probe(struct amba_device *adev, struct amba_id *id)
+static struct vendor_data vendor_db5500_pl023 = {
+	.fifodepth = 32,
+	.max_bpw = 32,
+	.unidir = false,
+	.extended_cr = true,
+	.pl023 = true,
+	.loopback = true,
+};
+
+static int pl022_amba_probe(struct amba_device *adev, const struct amba_id *id)
 {
 	struct pl022 *pl022 = NULL;
 	int ret;
 	dev_info(&adev->dev,
-		"ARM PL022 driver, device ID: 0x%08x\n", adev->periphid);
+		 "ARM PL022 driver, device ID: 0x%08x\n", adev->periphid);
 	ret = pl022_probe(&adev->dev, id->data,
 		&adev->res, adev->irq[0], &pl022);
 
@@ -2538,6 +2300,7 @@ pl022_amba_probe(struct amba_device *adev, struct amba_id *id)
 	return 0;
 }
 
+static int __exit
 pl022_amba_remove(struct amba_device *adev)
 {
 	return  pl022_remove(&adev->dev, &adev->res, adev->irq[0]);
@@ -2574,6 +2337,11 @@ static struct amba_id pl022_ids[] = {
 		.mask	= 0xffffffff,
 		.data	= &vendor_st_pl023,
 	},
+	{
+		.id	= 0x10080023,
+		.mask	= 0xffffffff,
+		.data	= &vendor_db5500_pl023,
+	},
 	{ 0, 0 },
 };
 
@@ -2849,7 +2617,6 @@ static struct platform_driver pl022_driver = {
 	.remove = __exit_p(pl022_of_remove),
 };
 #endif
-
 static int __init pl022_init(void)
 {
 	pr_info("--> %s:%d -\n", __FILE__, __LINE__);
-- 
1.7.5.4

