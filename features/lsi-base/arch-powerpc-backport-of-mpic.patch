From 33f1693f0ec6d94455672da90dddc87b9dadd5f4 Mon Sep 17 00:00:00 2001
From: John Jacques <john.jacques@lsi.com>
Date: Wed, 18 Dec 2013 16:13:24 -0600
Subject: [PATCH 10/71] arch/powerpc: backport of mpic

git://git.yoctoproject.org/linux-yocto-3.10 standard/axxia/base
commit 119aed6548648bc75592313597d6c18c6419c465

Backport of 32dda05f4ec2b854b594bd91590c46c5197d77e1

Otherwise, we get a debug traceback due to the use of
smp_processor_id() (or get_paca()) inside hard_smp_processor_id().
mpic_host_map() is just looking for a default CPU, so it doesn't matter
if we migrate after getting the CPU ID.

This is signed off by Scott Wood <scottwood@freescale.com>

Signed-off-by: John Jacques <john.jacques@lsi.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/powerpc/sysdev/mpic.c |  148 ++++++++++++++++++++++++--------------------
 1 files changed, 81 insertions(+), 67 deletions(-)

diff --git a/arch/powerpc/sysdev/mpic.c b/arch/powerpc/sysdev/mpic.c
index 3cc2f91..f9a26d8 100644
--- a/arch/powerpc/sysdev/mpic.c
+++ b/arch/powerpc/sysdev/mpic.c
@@ -142,7 +142,7 @@ static u32 mpic_infos[][MPIC_IDX_END] = {
 	},
 };
 
-#define MPIC_INFO(name) mpic->hw_set[MPIC_IDX_##name]
+#define MPIC_INFO(name) (mpic->hw_set[MPIC_IDX_##name])
 
 #else /* CONFIG_MPIC_WEIRD */
 
@@ -166,10 +166,10 @@ static inline unsigned int mpic_processor_id(struct mpic *mpic)
 
 
 static inline u32 _mpic_read(enum mpic_reg_type type,
-			     struct mpic_reg_bank *rb,
-			     unsigned int reg)
+		struct mpic_reg_bank *rb,
+		unsigned int reg)
 {
-	switch(type) {
+	switch (type) {
 #ifdef CONFIG_PPC_DCR
 	case mpic_access_dcr:
 		return dcr_read(rb->dhost, reg);
@@ -183,10 +183,10 @@ static inline u32 _mpic_read(enum mpic_reg_type type,
 }
 
 static inline void _mpic_write(enum mpic_reg_type type,
-			       struct mpic_reg_bank *rb,
- 			       unsigned int reg, u32 value)
+		struct mpic_reg_bank *rb,
+		unsigned int reg, u32 value)
 {
-	switch(type) {
+	switch (type) {
 #ifdef CONFIG_PPC_DCR
 	case mpic_access_dcr:
 		dcr_write(rb->dhost, reg, value);
@@ -213,7 +213,8 @@ static inline u32 _mpic_ipi_read(struct mpic *mpic, unsigned int ipi)
 	return _mpic_read(type, &mpic->gregs, offset);
 }
 
-static inline void _mpic_ipi_write(struct mpic *mpic, unsigned int ipi, u32 value)
+static inline void _mpic_ipi_write(struct mpic *mpic,
+		unsigned int ipi, u32 value)
 {
 	unsigned int offset = MPIC_INFO(GREG_IPI_VECTOR_PRI_0) +
 			      (ipi * MPIC_INFO(GREG_IPI_STRIDE));
@@ -250,14 +251,16 @@ static inline u32 _mpic_cpu_read(struct mpic *mpic, unsigned int reg)
 	return _mpic_read(mpic->reg_type, &mpic->cpuregs[cpu], reg);
 }
 
-static inline void _mpic_cpu_write(struct mpic *mpic, unsigned int reg, u32 value)
+static inline void _mpic_cpu_write(struct mpic *mpic,
+		unsigned int reg, u32 value)
 {
 	unsigned int cpu = mpic_processor_id(mpic);
 
 	_mpic_write(mpic->reg_type, &mpic->cpuregs[cpu], reg, value);
 }
 
-static inline u32 _mpic_irq_read(struct mpic *mpic, unsigned int src_no, unsigned int reg)
+static inline u32 _mpic_irq_read(struct mpic *mpic,
+		unsigned int src_no, unsigned int reg)
 {
 	unsigned int	isu = src_no >> mpic->isu_shift;
 	unsigned int	idx = src_no & mpic->isu_mask;
@@ -289,16 +292,16 @@ static inline void _mpic_irq_write(struct mpic *mpic, unsigned int src_no,
 #endif
 }
 
-#define mpic_read(b,r)		_mpic_read(mpic->reg_type,&(b),(r))
-#define mpic_write(b,r,v)	_mpic_write(mpic->reg_type,&(b),(r),(v))
-#define mpic_ipi_read(i)	_mpic_ipi_read(mpic,(i))
-#define mpic_ipi_write(i,v)	_mpic_ipi_write(mpic,(i),(v))
-#define mpic_tm_read(i)		_mpic_tm_read(mpic,(i))
-#define mpic_tm_write(i,v)	_mpic_tm_write(mpic,(i),(v))
-#define mpic_cpu_read(i)	_mpic_cpu_read(mpic,(i))
-#define mpic_cpu_write(i,v)	_mpic_cpu_write(mpic,(i),(v))
-#define mpic_irq_read(s,r)	_mpic_irq_read(mpic,(s),(r))
-#define mpic_irq_write(s,r,v)	_mpic_irq_write(mpic,(s),(r),(v))
+#define mpic_read(b, r)		_mpic_read(mpic->reg_type, &(b), (r))
+#define mpic_write(b, r, v)	_mpic_write(mpic->reg_type, &(b), (r), (v))
+#define mpic_ipi_read(i)	_mpic_ipi_read(mpic, (i))
+#define mpic_ipi_write(i, v)	_mpic_ipi_write(mpic, (i), (v))
+#define mpic_tm_read(i)		_mpic_tm_read(mpic, (i))
+#define mpic_tm_write(i, v)	_mpic_tm_write(mpic, (i), (v))
+#define mpic_cpu_read(i)	_mpic_cpu_read(mpic, (i))
+#define mpic_cpu_write(i, v)	_mpic_cpu_write(mpic, (i), (v))
+#define mpic_irq_read(s, r)	_mpic_irq_read(mpic, (s), (r))
+#define mpic_irq_write(s, r, v)	_mpic_irq_write(mpic, (s), (r), (v))
 
 
 /*
@@ -333,7 +336,7 @@ static inline void mpic_map(struct mpic *mpic,
 		_mpic_map_mmio(mpic, phys_addr, rb, offset, size);
 }
 #else /* CONFIG_PPC_DCR */
-#define mpic_map(m,p,b,o,s)	_mpic_map_mmio(m,p,b,o,s)
+#define mpic_map(m, p, b, o, s)	_mpic_map_mmio(m, p, b, o, s)
 #endif /* !CONFIG_PPC_DCR */
 
 
@@ -345,11 +348,12 @@ static void __init mpic_test_broken_ipi(struct mpic *mpic)
 {
 	u32 r;
 
-	mpic_write(mpic->gregs, MPIC_INFO(GREG_IPI_VECTOR_PRI_0), MPIC_VECPRI_MASK);
+	mpic_write(mpic->gregs, MPIC_INFO(GREG_IPI_VECTOR_PRI_0),
+			MPIC_VECPRI_MASK);
 	r = mpic_read(mpic->gregs, MPIC_INFO(GREG_IPI_VECTOR_PRI_0));
 
 	if (r == le32_to_cpu(MPIC_VECPRI_MASK)) {
-		printk(KERN_INFO "mpic: Detected reversed IPI registers\n");
+		pr_info("mpic: Detected reversed IPI registers\n");
 		mpic->flags |= MPIC_BROKEN_IPI;
 	}
 }
@@ -467,7 +471,7 @@ static void __init mpic_scan_ht_msi(struct mpic *mpic, u8 __iomem *devbase,
 		addr = addr | ((u64)readl(base + HT_MSI_ADDR_HI) << 32);
 	}
 
-	printk(KERN_DEBUG "mpic:   - HT:%02x.%x %s MSI mapping found @ 0x%llx\n",
+	pr_debug("mpic:   - HT:%02x.%x %s MSI mapping found @ 0x%llx\n",
 		PCI_SLOT(devfn), PCI_FUNC(devfn),
 		flags & HT_MSI_FLAGS_ENABLE ? "enabled" : "disabled", addr);
 
@@ -506,9 +510,8 @@ static void __init mpic_scan_ht_pic(struct mpic *mpic, u8 __iomem *devbase,
 	writeb(0x01, base + 2);
 	n = (readl(base + 4) >> 16) & 0xff;
 
-	printk(KERN_INFO "mpic:   - HT:%02x.%x [0x%02x] vendor %04x device %04x"
-	       " has %d irqs\n",
-	       devfn >> 3, devfn & 0x7, pos, vdid & 0xffff, vdid >> 16, n + 1);
+	pr_info("mpic:   - HT:%02x.%x [0x%02x] vendor %04x device %04x has %d irqs\n",
+			devfn >> 3, devfn & 0x7, pos, vdid & 0xffff, vdid >> 16, n + 1);
 
 	for (i = 0; i <= n; i++) {
 		writeb(0x10 + 2 * i, base + 2);
@@ -529,14 +532,14 @@ static void __init mpic_scan_ht_pic(struct mpic *mpic, u8 __iomem *devbase,
 		mpic->fixups[irq].data = readl(base + 4) | 0x80000000;
 	}
 }
- 
+
 
 static void __init mpic_scan_ht_pics(struct mpic *mpic)
 {
 	unsigned int devfn;
 	u8 __iomem *cfgspace;
 
-	printk(KERN_INFO "mpic: Setting up HT PICs workarounds for U3/U4\n");
+	pr_info("mpic: Setting up HT PICs workarounds for U3/U4\n");
 
 	/* Allocate fixups array */
 	mpic->fixups = kzalloc(128 * sizeof(*mpic->fixups), GFP_KERNEL);
@@ -574,7 +577,7 @@ static void __init mpic_scan_ht_pics(struct mpic *mpic)
 		mpic_scan_ht_pic(mpic, devbase, devfn, l);
 		mpic_scan_ht_msi(mpic, devbase, devfn);
 
-	next:
+next:
 		/* next device, if function 0 */
 		if (PCI_FUNC(devfn) == 0 && (hdr_type & 0x80) == 0)
 			devfn += 7;
@@ -628,20 +631,20 @@ static inline u32 mpic_physmask(u32 cpumask)
 
 #ifdef CONFIG_SMP
 /* Get the mpic structure from the IPI number */
-static inline struct mpic * mpic_from_ipi(struct irq_data *d)
+static inline struct mpic *mpic_from_ipi(struct irq_data *d)
 {
 	return irq_data_get_irq_chip_data(d);
 }
 #endif
 
 /* Get the mpic structure from the irq number */
-static inline struct mpic * mpic_from_irq(unsigned int irq)
+static inline struct mpic *mpic_from_irq(unsigned int irq)
 {
 	return irq_get_chip_data(irq);
 }
 
 /* Get the mpic structure from the irq data */
-static inline struct mpic * mpic_from_irq_data(struct irq_data *d)
+static inline struct mpic *mpic_from_irq_data(struct irq_data *d)
 {
 	return irq_data_get_irq_chip_data(d);
 }
@@ -672,11 +675,12 @@ void mpic_unmask_irq(struct irq_data *d)
 	/* make sure mask gets to controller before we return to user */
 	do {
 		if (!loops--) {
-			printk(KERN_ERR "%s: timeout on hwirq %u\n",
+			pr_err("%s: timeout on hwirq %u\n",
 			       __func__, src);
 			break;
 		}
-	} while(mpic_irq_read(src, MPIC_INFO(IRQ_VECTOR_PRI)) & MPIC_VECPRI_MASK);
+	} while (mpic_irq_read(src, MPIC_INFO(IRQ_VECTOR_PRI)) &
+			MPIC_VECPRI_MASK);
 }
 
 void mpic_mask_irq(struct irq_data *d)
@@ -694,11 +698,12 @@ void mpic_mask_irq(struct irq_data *d)
 	/* make sure mask gets to controller before we return to user */
 	do {
 		if (!loops--) {
-			printk(KERN_ERR "%s: timeout on hwirq %u\n",
+			pr_err("%s: timeout on hwirq %u\n",
 			       __func__, src);
 			break;
 		}
-	} while(!(mpic_irq_read(src, MPIC_INFO(IRQ_VECTOR_PRI)) & MPIC_VECPRI_MASK));
+	} while (!(mpic_irq_read(src, MPIC_INFO(IRQ_VECTOR_PRI)) &
+			MPIC_VECPRI_MASK));
 }
 
 void mpic_end_irq(struct irq_data *d)
@@ -842,7 +847,7 @@ int mpic_set_affinity(struct irq_data *d, const struct cpumask *cpumask,
 static unsigned int mpic_type_to_vecpri(struct mpic *mpic, unsigned int type)
 {
 	/* Now convert sense value */
-	switch(type & IRQ_TYPE_SENSE_MASK) {
+	switch (type & IRQ_TYPE_SENSE_MASK) {
 	case IRQ_TYPE_EDGE_RISING:
 		return MPIC_INFO(VECPRI_SENSE_EDGE) |
 		       MPIC_INFO(VECPRI_POLARITY_POSITIVE);
@@ -880,7 +885,7 @@ int mpic_set_irq_type(struct irq_data *d, unsigned int flow_type)
 
 	/* Default: read HW settings */
 	if (flow_type == IRQ_TYPE_DEFAULT) {
-		switch(vold & (MPIC_INFO(VECPRI_POLARITY_MASK) |
+		switch (vold & (MPIC_INFO(VECPRI_POLARITY_MASK) |
 			       MPIC_INFO(VECPRI_SENSE_MASK))) {
 			case MPIC_INFO(VECPRI_SENSE_EDGE) |
 			     MPIC_INFO(VECPRI_POLARITY_POSITIVE):
@@ -1002,9 +1007,8 @@ static int mpic_host_map(struct irq_domain *h, unsigned int virq,
 	if (hw == mpic->spurious_vec)
 		return -EINVAL;
 	if (mpic->protected && test_bit(hw, mpic->protected)) {
-		pr_warning("mpic: Mapping of source 0x%x failed, "
-			   "source protected by firmware !\n",\
-			   (unsigned int)hw);
+		pr_warn("mpic: Mapping of source 0x%x failed, source protected by firmware !\n",
+				(unsigned int)hw);
 		return -EPERM;
 	}
 
@@ -1034,9 +1038,8 @@ static int mpic_host_map(struct irq_domain *h, unsigned int virq,
 		return 0;
 
 	if (hw >= mpic->num_sources) {
-		pr_warning("mpic: Mapping of source 0x%x failed, "
-			   "source out of range !\n",\
-			   (unsigned int)hw);
+		pr_warn("mpic: Mapping of source 0x%x failed, source out of range !\n",
+				(unsigned int)hw);
 		return -EINVAL;
 	}
 
@@ -1064,8 +1067,14 @@ static int mpic_host_map(struct irq_domain *h, unsigned int virq,
 	 * is done here.
 	 */
 	if (!mpic_is_ipi(mpic, hw) && (mpic->flags & MPIC_NO_RESET)) {
+		int cpu;
+
+		preempt_disable();
+		cpu = mpic_processor_id(mpic);
+		preempt_enable();
+
 		mpic_set_vector(virq, hw);
-		mpic_set_destination(virq, mpic_processor_id(mpic));
+		mpic_set_destination(virq, cpu);
 		mpic_irq_set_priority(virq, 8);
 	}
 
@@ -1319,8 +1328,10 @@ struct mpic * __init mpic_alloc(struct device_node *node,
 #endif
 
 	/* Map the global registers */
-	mpic_map(mpic, mpic->paddr, &mpic->gregs, MPIC_INFO(GREG_BASE), 0x1000);
-	mpic_map(mpic, mpic->paddr, &mpic->tmregs, MPIC_INFO(TIMER_BASE), 0x1000);
+	mpic_map(mpic, mpic->paddr, &mpic->gregs,
+			MPIC_INFO(GREG_BASE), 0x1000);
+	mpic_map(mpic, mpic->paddr, &mpic->tmregs,
+			MPIC_INFO(TIMER_BASE), 0x1000);
 
 	if (mpic->flags & MPIC_FSL) {
 		u32 brr1;
@@ -1383,11 +1394,11 @@ struct mpic * __init mpic_alloc(struct device_node *node,
 	 * is allowed to reset.
 	 */
 	if (!(mpic->flags & MPIC_NO_RESET)) {
-		printk(KERN_DEBUG "mpic: Resetting\n");
+		pr_debug("mpic: Resetting\n");
 		mpic_write(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0),
 			   mpic_read(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0))
 			   | MPIC_GREG_GCONF_RESET);
-		while( mpic_read(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0))
+		while (mpic_read(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0))
 		       & MPIC_GREG_GCONF_RESET)
 			mb();
 	}
@@ -1431,7 +1442,7 @@ struct mpic * __init mpic_alloc(struct device_node *node,
 	 * as a default instead of the value read from the HW.
 	 */
 	last_irq = (greg_feature & MPIC_GREG_FEATURE_LAST_SRC_MASK)
-				>> MPIC_GREG_FEATURE_LAST_SRC_SHIFT;	
+				>> MPIC_GREG_FEATURE_LAST_SRC_SHIFT;
 	if (isu_size)
 		last_irq = isu_size  * MPIC_MAX_ISU - 1;
 	of_property_read_u32(mpic->node, "last-interrupt-source", &last_irq);
@@ -1477,10 +1488,9 @@ struct mpic * __init mpic_alloc(struct device_node *node,
 		vers = "<unknown>";
 		break;
 	}
-	printk(KERN_INFO "mpic: Setting up MPIC \"%s\" version %s at %llx,"
-	       " max %d CPUs\n",
+	pr_info("mpic: Setting up MPIC \"%s\" version %s at %llx, max %d CPUs\n",
 	       name, vers, (unsigned long long)mpic->paddr, num_possible_cpus());
-	printk(KERN_INFO "mpic: ISU size: %d, shift: %d, mask: %x\n",
+	pr_info("mpic: ISU size: %d, shift: %d, mask: %x\n",
 	       mpic->isu_size, mpic->isu_shift, mpic->isu_mask);
 
 	mpic->next = mpics;
@@ -1520,7 +1530,7 @@ void __init mpic_init(struct mpic *mpic)
 
 	BUG_ON(mpic->num_sources == 0);
 
-	printk(KERN_INFO "mpic: Initializing for %d sources\n", mpic->num_sources);
+	pr_info("mpic: Initializing for %d sources\n", mpic->num_sources);
 
 	/* Set current processor priority to max */
 	mpic_cpu_write(MPIC_INFO(CPU_CURRENT_TASK_PRI), 0xf);
@@ -1558,7 +1568,10 @@ void __init mpic_init(struct mpic *mpic)
 			   (mpic->timer_vecs[0] + i));
 	}
 
-	/* Initialize IPIs to our reserved vectors and mark them disabled for now */
+	/*
+	 * Initialize IPIs to our reserved vectors
+	 * and mark them disabled for now
+	 */
 	mpic_test_broken_ipi(mpic);
 	for (i = 0; i < 4; i++) {
 		mpic_ipi_write(i,
@@ -1569,7 +1582,8 @@ void __init mpic_init(struct mpic *mpic)
 
 	/* Do the HT PIC fixups on U3 broken mpic */
 	DBG("MPIC flags: %x\n", mpic->flags);
-	if ((mpic->flags & MPIC_U3_HT_IRQS) && !(mpic->flags & MPIC_SECONDARY)) {
+	if ((mpic->flags & MPIC_U3_HT_IRQS) &&
+			!(mpic->flags & MPIC_SECONDARY)) {
 		mpic_scan_ht_pics(mpic);
 		mpic_u3msi_init(mpic);
 	}
@@ -1583,7 +1597,7 @@ void __init mpic_init(struct mpic *mpic)
 			/* start with vector = source number, and masked */
 			u32 vecpri = MPIC_VECPRI_MASK | i |
 				(8 << MPIC_VECPRI_PRIORITY_SHIFT);
-		
+
 			/* check if protected */
 			if (mpic->protected && test_bit(i, mpic->protected))
 				continue;
@@ -1592,7 +1606,7 @@ void __init mpic_init(struct mpic *mpic)
 			mpic_irq_write(i, MPIC_INFO(IRQ_DESTINATION), 1 << cpu);
 		}
 	}
-	
+
 	/* Init spurious vector */
 	mpic_write(mpic->gregs, MPIC_INFO(GREG_SPURIOUS), mpic->spurious_vec);
 
@@ -1621,7 +1635,7 @@ void __init mpic_init(struct mpic *mpic)
 	if (mpic->flags & MPIC_SECONDARY) {
 		int virq = irq_of_parse_and_map(mpic->node, 0);
 		if (virq != NO_IRQ) {
-			printk(KERN_INFO "%s: hooking up to IRQ %d\n",
+			pr_info("%s: hooking up to IRQ %d\n",
 					mpic->node->full_name, virq);
 			irq_set_handler_data(virq, mpic);
 			irq_set_chained_handler(virq, &mpic_cascade);
@@ -1698,13 +1712,13 @@ void mpic_setup_this_cpu(void)
 
 	raw_spin_lock_irqsave(&mpic_lock, flags);
 
- 	/* let the mpic know we want intrs. default affinity is 0xffffffff
+	/* let the mpic know we want intrs. default affinity is 0xffffffff
 	 * until changed via /proc. That's how it's done on x86. If we want
 	 * it differently, then we should make sure we also change the default
 	 * values of irq_desc[].affinity in irq.c.
- 	 */
+	 */
 	if (distribute_irqs && !(mpic->flags & MPIC_SINGLE_DEST_CPU)) {
-	 	for (i = 0; i < mpic->num_sources ; i++)
+		for (i = 0; i < mpic->num_sources; i++)
 			mpic_irq_write(i, MPIC_INFO(IRQ_DESTINATION),
 				mpic_irq_read(i, MPIC_INFO(IRQ_DESTINATION)) | msk);
 	}
@@ -1744,7 +1758,7 @@ void mpic_teardown_this_cpu(int secondary)
 	raw_spin_lock_irqsave(&mpic_lock, flags);
 
 	/* let the mpic know we don't want intrs.  */
-	for (i = 0; i < mpic->num_sources ; i++)
+	for (i = 0; i < mpic->num_sources; i++)
 		mpic_irq_write(i, MPIC_INFO(IRQ_DESTINATION),
 			mpic_irq_read(i, MPIC_INFO(IRQ_DESTINATION)) & ~msk);
 
@@ -1839,13 +1853,13 @@ void mpic_request_ipis(void)
 	int i;
 	BUG_ON(mpic == NULL);
 
-	printk(KERN_INFO "mpic: requesting IPIs...\n");
+	pr_info("mpic: requesting IPIs...\n");
 
 	for (i = 0; i < 4; i++) {
 		unsigned int vipi = irq_create_mapping(mpic->irqhost,
 						       mpic->ipi_vecs[0] + i);
 		if (vipi == NO_IRQ) {
-			printk(KERN_ERR "Failed to map %s\n", smp_ipi_name[i]);
+			pr_err("Failed to map %s\n", smp_ipi_name[i]);
 			continue;
 		}
 		smp_request_message_ipi(vipi, i);
@@ -1861,7 +1875,7 @@ void smp_mpic_message_pass(int cpu, int msg)
 
 	/* make sure we're sending something that translates to an IPI */
 	if ((unsigned int)msg > 3) {
-		printk("SMP %d: smp_message_pass: unknown msg %d\n",
+		pr_info("SMP %d: smp_message_pass: unknown msg %d\n",
 		       smp_processor_id(), msg);
 		return;
 	}
-- 
1.7.5.4

