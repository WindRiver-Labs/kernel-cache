From 8672e83a7fd317a5c8cc1ed094573ffe433e1ccc Mon Sep 17 00:00:00 2001
From: Li Wang <li.wang@windriver.com>
Date: Thu, 18 May 2017 10:52:51 +0800
Subject: [PATCH 3/6] axxia: Clean Up Axxia NCR Driver

the patch comes from:
http://git.yoctoproject.org/cgit/cgit.cgi/linux-yocto-3.14/commit/?h=standard/axxia/base&id=837f4f4cbe47ee2cd2f54b4c9e0f2623bbb00954

Remove unused copies and only lock when necessary.

Signed-off-by: John Jacques <john.jacques@intel.com>
Signed-off-by: Li Wang <li.wang@windriver.com>
---
 arch/arm/include/asm/lsi/acp_ncr.h     |   45 ----
 arch/arm/mach-axxia/include/mach/ncr.h |   44 ----
 arch/powerpc/include/asm/lsi/acp_ncr.h |   45 ----
 arch/powerpc/sysdev/lsi_acp_ncr.c      |  377 --------------------------------
 drivers/misc/lsi-ncr.c                 |  239 +++++++++++++++------
 drivers/misc/lsi-ncr.h                 |    1 -
 6 files changed, 171 insertions(+), 580 deletions(-)
 delete mode 100644 arch/arm/include/asm/lsi/acp_ncr.h
 delete mode 100644 arch/arm/mach-axxia/include/mach/ncr.h
 delete mode 100644 arch/powerpc/include/asm/lsi/acp_ncr.h
 delete mode 100644 arch/powerpc/sysdev/lsi_acp_ncr.c

diff --git a/arch/arm/include/asm/lsi/acp_ncr.h b/arch/arm/include/asm/lsi/acp_ncr.h
deleted file mode 100644
index 114a36b..0000000
--- a/arch/arm/include/asm/lsi/acp_ncr.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * asm/lsi/acp_ncr.h
- *
- * Copyright (C) 2010 LSI
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
- */
-
-#ifndef __DRIVERS_LSI_ACP_NCR_H
-#define __DRIVERS_LSI_ACP_NCR_H
-
-#ifndef NCP_REGION_ID
-#define NCP_REGION_ID(node, target) \
-(unsigned long)((((node) & 0xffff) << 16) | ((target) & 0xffff))
-#endif
-
-#ifndef NCP_NODE_ID
-#define NCP_NODE_ID(region) (((region) >> 16) & 0xffff)
-#endif
-
-#ifndef NCP_TARGET_ID
-#define NCP_TARGET_ID(region) ((region) & 0xffff)
-#endif
-
-int ncr_read(unsigned long, unsigned long, int, void *);
-int ncr_write(unsigned long, unsigned long, int, void *);
-
-int is_asic(void);
-
-extern int acp_mdio_read(unsigned long, unsigned long, unsigned short *, int);
-extern int acp_mdio_write(unsigned long, unsigned long, unsigned short, int);
-
-#endif /*  __DRIVERS_LSI_ACP_NCR_H */
diff --git a/arch/arm/mach-axxia/include/mach/ncr.h b/arch/arm/mach-axxia/include/mach/ncr.h
deleted file mode 100644
index 926d366..0000000
--- a/arch/arm/mach-axxia/include/mach/ncr.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * arch/arm/mach-axxia/include/mach/ncr.h
- *
- * Copyright (C) 2010 LSI
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
- */
-
-#ifndef __ARCH_ARM_MACH_AXXIA_NCR_H
-#define __ARCH_ARM_MACH_AXXIA_NCR_H
-
-#ifndef NCP_REGION_ID
-#define NCP_REGION_ID(node, target) \
-((unsigned long) ((((node) & 0xffff) << 16) | ((target) & 0xffff)))
-#endif
-
-#ifndef NCP_NODE_ID
-#define NCP_NODE_ID(region) (((region) >> 16) & 0xffff)
-#endif
-
-#ifndef NCP_TARGET_ID
-#define NCP_TARGET_ID(region) ((region) & 0xffff)
-#endif
-
-unsigned long ncr_register_read(unsigned *);
-void ncr_register_write(const unsigned, unsigned *);
-int ncr_read(unsigned long, unsigned long, int, void *);
-int ncr_write(unsigned long, unsigned long, int, void *);
-int ncr_init(void);
-void ncr_exit(void);
-
-#endif /* __ARCH_ARM_MACH_AXXIA_NCR_H */
diff --git a/arch/powerpc/include/asm/lsi/acp_ncr.h b/arch/powerpc/include/asm/lsi/acp_ncr.h
deleted file mode 100644
index 1a08f07..0000000
--- a/arch/powerpc/include/asm/lsi/acp_ncr.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * asm/lsi/acp_ncr.h
- *
- * Copyright (C) 2010 LSI
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
- */
-
-#ifndef __DRIVERS_LSI_ACP_NCR_H
-#define __DRIVERS_LSI_ACP_NCR_H
-
-#ifndef NCP_REGION_ID
-#define NCP_REGION_ID(node, target) \
-(unsigned long)((((node) & 0xffff) << 16) | ((target) & 0xffff))
-#endif
-
-#ifndef NCP_NODE_ID
-#define NCP_NODE_ID(region) (((region) >> 16) & 0xffff)
-#endif
-
-#ifndef NCP_TARGET_ID
-#define NCP_TARGET_ID(region) ((region) & 0xffff)
-#endif
-
-int ncr_read(unsigned long, unsigned long, int, void *);
-int ncr_write(unsigned long, unsigned long, int, void *);
-
-int is_asic(void);
-
-extern int acp_mdio_read(unsigned long, unsigned long, unsigned short *);
-extern int acp_mdio_write(unsigned long, unsigned long, unsigned short);
-
-#endif /*  __DRIVERS_LSI_ACP_NCR_H */
diff --git a/arch/powerpc/sysdev/lsi_acp_ncr.c b/arch/powerpc/sysdev/lsi_acp_ncr.c
deleted file mode 100644
index 48fe809..0000000
--- a/arch/powerpc/sysdev/lsi_acp_ncr.c
+++ /dev/null
@@ -1,377 +0,0 @@
-/*
- *  Copyright (C) 2009 LSI Corporation
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <linux/io.h>
-#include <linux/module.h>
-
-#include <include/asm/lsi/acp_ncr.h>
-
-static void __iomem *nca_address;
-
-#define WFC_TIMEOUT (400000)
-
-#define LOCK_DOMAIN 0
-
-union command_data_register_0 {
-	unsigned long raw;
-	struct {
-		unsigned long start_done:1;
-		unsigned long unused:6;
-		unsigned long local_bit:1;
-		unsigned long status:2;
-		unsigned long byte_swap_enable:1;
-		unsigned long cfg_cmpl_int_enable:1;
-		unsigned long cmd_type:4;
-		unsigned long dbs:16;
-	} __packed bits;
-} __packed;
-
-union command_data_register_1 {
-	unsigned long raw;
-	struct {
-		unsigned long target_address:32;
-	} __packed bits;
-} __packed;
-
-union command_data_register_2 {
-	unsigned long raw;
-	struct {
-		unsigned long unused:16;
-		unsigned long target_node_id:8;
-		unsigned long target_id_address_upper:8;
-	} __packed bits;
-} __packed;
-
-/*
-  ----------------------------------------------------------------------
-  ncr_register_read
-*/
-
-static inline unsigned long
-ncr_register_read(unsigned *address)
-{
-	unsigned long value;
-
-	value = in_be32(address);
-
-	return value;
-}
-
-/*
-  ----------------------------------------------------------------------
-  ncr_register_write
-*/
-
-static inline void
-ncr_register_write(const unsigned value, unsigned *address)
-{
-	out_be32(address, value);
-}
-
-/*
-  ------------------------------------------------------------------------------
-  ncr_lock
-*/
-
-static int
-ncr_lock(int domain)
-{
-	unsigned long offset;
-	unsigned long value;
-	int loops = 10000;
-
-	offset = (0xff80 + (domain * 4));
-
-	do {
-		value = ncr_register_read((unsigned *)(nca_address + offset));
-	} while ((0 != value) && (0 < --loops));
-
-	if (0 == loops)
-		return -1;
-
-	return 0;
-}
-
-/*
-  ------------------------------------------------------------------------------
-  ncr_unlock
-*/
-
-static void
-ncr_unlock(int domain)
-{
-	unsigned long offset;
-
-	offset = (0xff80 + (domain * 4));
-	ncr_register_write(0, (unsigned *)(nca_address + offset));
-
-	return;
-}
-
-/*
-  ======================================================================
-  ======================================================================
-  Public Interface
-  ======================================================================
-  ======================================================================
-*/
-
-/*
-  ----------------------------------------------------------------------
-  ncr_read
-*/
-
-int
-ncr_read(unsigned long region, unsigned long address, int number, void *buffer)
-{
-	union command_data_register_0 cdr0;
-	union command_data_register_1 cdr1;
-	union command_data_register_2 cdr2;
-	int wfc_timeout = WFC_TIMEOUT;
-
-	if (NULL == nca_address)
-		nca_address = ioremap(0x002000520000ULL, 0x20000);
-
-	if (0 != ncr_lock(LOCK_DOMAIN))
-		return -1;
-
-	/*
-	  Set up the read command.
-	*/
-
-	cdr2.raw = 0;
-	cdr2.bits.target_node_id = NCP_NODE_ID(region);
-	cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
-	ncr_register_write(cdr2.raw, (unsigned *) (nca_address + 0xf8));
-
-	cdr1.raw = 0;
-	cdr1.bits.target_address = (address >> 2);
-	ncr_register_write(cdr1.raw, (unsigned *) (nca_address + 0xf4));
-
-	cdr0.raw = 0;
-	cdr0.bits.start_done = 1;
-
-	if (0xff == cdr2.bits.target_id_address_upper)
-		cdr0.bits.local_bit = 1;
-
-	cdr0.bits.cmd_type = 4;
-	/* TODO: Verify number... */
-	cdr0.bits.dbs = (number - 1);
-	ncr_register_write(cdr0.raw, (unsigned *) (nca_address + 0xf0));
-	mb();
-
-	/*
-	  Wait for completion.
-	*/
-
-	do {
-		--wfc_timeout;
-	} while ((0x80000000UL ==
-		  ncr_register_read((unsigned *)(nca_address + 0xf0))) &&
-		 0 < wfc_timeout);
-
-	if (0 == wfc_timeout) {
-		ncr_unlock(LOCK_DOMAIN);
-		return -1;
-	}
-
-	/*
-	  Copy data words to the buffer.
-	*/
-
-	address = (unsigned long)(nca_address + 0x1000);
-	while (4 <= number) {
-		*((unsigned long *) buffer) =
-			ncr_register_read((unsigned *) address);
-		address += 4;
-		number -= 4;
-	}
-
-	if (0 < number) {
-		unsigned long temp = ncr_register_read((unsigned *) address);
-		memcpy((void *) buffer, &temp, number);
-	}
-
-	ncr_unlock(LOCK_DOMAIN);
-
-	return 0;
-}
-EXPORT_SYMBOL(ncr_read);
-/*
-  ------------------------------------------------------------------------------
-  is_asic
-*/
-
-int
-is_asic(void)
-{
-#ifdef CONFIG_ACPISS
-	return 0;
-#else
-	unsigned long nca_config;
-
-	if (0 == ncr_read(NCP_REGION_ID(0x16, 0xff), 0x10, 4, &nca_config))
-		return 0 == (nca_config & 0x80000000);
-
-	return -1;
-#endif
-}
-EXPORT_SYMBOL(is_asic);
-
-/*
-  ----------------------------------------------------------------------
-  ncr_write
-*/
-
-int
-ncr_write(unsigned long region, unsigned long address, int number, void *buffer)
-{
-	union command_data_register_0 cdr0;
-	union command_data_register_1 cdr1;
-	union command_data_register_2 cdr2;
-	unsigned long data_word_base;
-	int dbs = (number - 1);
-	int wfc_timeout = WFC_TIMEOUT;
-
-	if (NULL == nca_address)
-		nca_address = ioremap(0x002000520000ULL, 0x20000);
-
-	if (0 != ncr_lock(LOCK_DOMAIN))
-		return -1;
-
-	/*
-	  Set up the write.
-	*/
-
-	cdr2.raw = 0;
-	cdr2.bits.target_node_id = NCP_NODE_ID(region);
-	cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
-	ncr_register_write(cdr2.raw, (unsigned *) (nca_address + 0xf8));
-
-	cdr1.raw = 0;
-	cdr1.bits.target_address = (address >> 2);
-	ncr_register_write(cdr1.raw, (unsigned *) (nca_address + 0xf4));
-
-	/*
-	  Copy from buffer to the data words.
-	*/
-
-	data_word_base = (unsigned long)(nca_address + 0x1000);
-
-	while (4 <= number) {
-		ncr_register_write(*((unsigned long *) buffer),
-				   (unsigned *) data_word_base);
-		data_word_base += 4;
-		buffer += 4;
-		number -= 4;
-	}
-
-	if (0 < number) {
-		unsigned long temp = 0;
-
-		memcpy((void *) &temp, (void *) buffer, number);
-		ncr_register_write(temp, (unsigned *) data_word_base);
-		data_word_base += number;
-		buffer += number;
-		number = 0;
-	}
-
-	cdr0.raw = 0;
-	cdr0.bits.start_done = 1;
-
-	if (0xff == cdr2.bits.target_id_address_upper)
-		cdr0.bits.local_bit = 1;
-
-	cdr0.bits.cmd_type = 5;
-	/* TODO: Verify number... */
-	cdr0.bits.dbs = dbs;
-	ncr_register_write(cdr0.raw, (unsigned *) (nca_address + 0xf0));
-	mb();
-
-	/*
-	  Wait for completion.
-	*/
-
-	do {
-		--wfc_timeout;
-	} while ((0x80000000UL ==
-		  ncr_register_read((unsigned *)(nca_address + 0xf0))) &&
-		 0 < wfc_timeout);
-
-	if (0 == wfc_timeout) {
-		ncr_unlock(LOCK_DOMAIN);
-		return -1;
-	}
-
-	/*
-	  Check status.
-	*/
-
-	if (0x3 !=
-	    ((ncr_register_read((unsigned *) (nca_address + 0xf0)) &
-		0x00c00000) >> 22)) {
-		unsigned long status;
-
-		status = ncr_register_read((unsigned *)(nca_address + 0xe4));
-		ncr_unlock(LOCK_DOMAIN);
-
-		return status;
-	}
-
-	ncr_unlock(LOCK_DOMAIN);
-
-	return 0;
-}
-EXPORT_SYMBOL(ncr_write);
-
-/*
-  ----------------------------------------------------------------------
-  ncr_init
-*/
-
-int
-ncr_init(void)
-{
-	/* We need this to be a module so that the functions can be exported
-	 * as module symbols.
-	 */
-	return 0;
-}
-
-postcore_initcall(ncr_init);
-
-/*
-  ----------------------------------------------------------------------
-  ncr_exit
-*/
-
-void __exit
-ncr_exit(void)
-{
-	/* Unmap the NCA. */
-	iounmap(nca_address);
-}
-
-module_exit(ncr_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("Register Ring access for LSI's ACP board");
diff --git a/drivers/misc/lsi-ncr.c b/drivers/misc/lsi-ncr.c
index bfcb32d..0f3d48f 100644
--- a/drivers/misc/lsi-ncr.c
+++ b/drivers/misc/lsi-ncr.c
@@ -22,14 +22,13 @@
 
 #include <linux/module.h>
 #include <linux/io.h>
+#include <linux/of.h>
 #include "lsi-ncr.h"
-#ifdef CONFIG_ARM
-#include <../../arch/arm/mach-axxia/axxia.h>
-#endif
 
 #ifdef CONFIG_ARCH_AXXIA
 #define NCA_PHYS_ADDRESS 0x002020100000ULL
 #define APB2SER_PHY_PHYS_ADDRESS 0x002010000000ULL
+#define SYSCON_PHYS_ADDR 0x002010030000ULL
 #else
 #define NCA_PHYS_ADDRESS 0x002000520000ULL
 #endif
@@ -41,13 +40,33 @@ static void __iomem *apb2ser0_address;
 
 #define WFC_TIMEOUT (400000)
 
-/* Protect NCA PIO registers from concurrent use. */
+/*
+ * We provide both 'normal' and 'nolock' versions of the
+ * ncr_read/write functions. For normal operation we use
+ * locking to provide thread-safe operation.
+ * There are two levels of locking.
+ *
+ * 1. ncr_spin_lock -
+ *      This is a high-level lock that protects the NCA PIO
+ *      registers from concurrent use. The NCA PIO mechanism
+ *      only supports a single thread of execution.
+ *
+ * 2. nca_access_lock -
+ *       This is a low-level lock that protects each individual
+ *       register read/write to the NCA registers. This is a
+ *       workaround for a bug in rev 1.0 silicon where the bus
+ *       interface may hang if the NCA is subjected to simultaneous
+ *       requests from multiple masters.
+ *
+ * The 'nolock' versions of ncr_read/write should only be used in
+ * special cases where the caller can guarantee there will be no
+ * other threads of execution.
+ */
+
+/* Lock #1 : Protect NCA PIO registers from concurrent use. */
 static DEFINE_RAW_SPINLOCK(ncr_spin_lock);
 
-/* This lock protect each individual register read/write to the NCA registers
- * due to a bug in rev 1.0 silicon where the bus interface may hang if the NCA
- * is subjected to simultaneous requests from multiple masters
- */
+/* Lock #2 : Protect each individual NCA register access. */
 DEFINE_RAW_SPINLOCK(nca_access_lock);
 EXPORT_SYMBOL(nca_access_lock);
 
@@ -120,6 +139,13 @@ union command_data_register_2 {
 	} __packed bits;
 } __packed;
 
+
+/*
+ * ncr_register_read/write
+ *   low-level access functions to Axxia registers,
+ *   with checking to ensure device is not currently
+ *   held in reset.
+ */
 unsigned long
 ncr_register_read(unsigned *address)
 {
@@ -139,12 +165,14 @@ ncr_register_write(const unsigned value, unsigned *address)
 }
 
 /*
-  ----------------------------------------------------------------------
-  nca_register_read
-*/
-
+ * ncr_register_read/write_lock
+ *   access functions for Axxia NCA block.
+ *   These functions protect the register access with a spinlock.
+ *   This is needed to workaround an AXM55xx v1.0 h/w bug.
+ *
+ */
 static unsigned long
-nca_register_read(unsigned *address)
+ncr_register_read_lock(unsigned *address)
 {
 	unsigned long value, flags;
 
@@ -155,13 +183,8 @@ nca_register_read(unsigned *address)
 	return value;
 }
 
-/*
-  ----------------------------------------------------------------------
-  nca_register_write
-*/
-
 static void
-nca_register_write(const unsigned value, unsigned *address)
+ncr_register_write_lock(const unsigned value, unsigned *address)
 {
 	unsigned long flags;
 
@@ -170,6 +193,28 @@ nca_register_write(const unsigned value, unsigned *address)
 	raw_spin_unlock_irqrestore(&nca_access_lock, flags);
 }
 
+/*
+ * define two sets of function pointers for low-level register
+ * access - one with locking and one without.
+ */
+struct ncr_io_fns {
+	unsigned long (*rd)(unsigned *address);
+	void (*wr)(const unsigned value, unsigned *address);
+};
+
+struct ncr_io_fns ncr_io_fn_lock = {
+	ncr_register_read_lock,
+	ncr_register_write_lock
+};
+
+struct ncr_io_fns ncr_io_fn_nolock = {
+	ncr_register_read,
+	ncr_register_write
+};
+
+struct ncr_io_fns *default_io_fn;
+
+
 /* These are only needed on platforms there AMP mode of operation is supported
  * (currently only on PowerPC based Axxia platforms). In AMP mode, multiple OS
  * instances may be accessing the NCA registers, thus requiring a hardware
@@ -181,7 +226,7 @@ ncr_amp_lock(int domain)
 {
 	unsigned long offset = (0xff80 + (domain * 4));
 
-	while (nca_register_read((unsigned *)(nca_address + offset)) != 0)
+	while (ncr_register_read_lock((unsigned *)(nca_address + offset)) != 0)
 		cpu_relax();
 }
 
@@ -190,16 +235,16 @@ ncr_amp_unlock(int domain)
 {
 	unsigned long offset = (0xff80 + (domain * 4));
 
-	nca_register_write(0, (unsigned *)(nca_address + offset));
+	ncr_register_write_lock(0, (unsigned *)(nca_address + offset));
 }
 #else
-	static void ncr_amp_lock(int domain) {}
-	static void ncr_amp_unlock(int domain) {}
+static void ncr_amp_lock(int domain) {}
+static void ncr_amp_unlock(int domain) {}
 #endif
 
 /**
-* Used to serialize all access to NCA PIO interface.
-*/
+ * Used to serialize all access to NCA PIO interface.
+ */
 int
 ncr_lock(int domain)
 {
@@ -227,17 +272,17 @@ EXPORT_SYMBOL(ncr_unlock);
 */
 
 static void
-ncr_pio_error_dump(char *str)
+ncr_pio_error_dump(struct ncr_io_fns *io_fn, char *str)
 {
 	unsigned long cdr0, cdr1, cdr2;
 	unsigned long stat0, stat1;
 
-	cdr0 = nca_register_read((unsigned *)(nca_address + 0xf0));
-	cdr1 = nca_register_read((unsigned *)(nca_address + 0xf4));
-	cdr2 = nca_register_read((unsigned *)(nca_address + 0xf8));
+	cdr0 = io_fn->rd((unsigned *)(nca_address + 0xf0));
+	cdr1 = io_fn->rd((unsigned *)(nca_address + 0xf4));
+	cdr2 = io_fn->rd((unsigned *)(nca_address + 0xf8));
 
-	stat0 = nca_register_read((unsigned *)(nca_address + 0xe4));
-	stat1 = nca_register_read((unsigned *)(nca_address + 0xe8));
+	stat0 = io_fn->rd((unsigned *)(nca_address + 0xe4));
+	stat1 = io_fn->rd((unsigned *)(nca_address + 0xe8));
 
 	pr_err("lsi-ncr: %8s failed, error status : 0x%08lx 0x%08lx\n",
 	       str, stat0, stat1);
@@ -251,7 +296,7 @@ ncr_pio_error_dump(char *str)
 */
 
 static int
-ncr_check_pio_status(char *str)
+ncr_check_pio_status(struct ncr_io_fns *io_fn, char *str)
 {
 	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
 	union command_data_register_0 cdr0;
@@ -262,24 +307,24 @@ ncr_check_pio_status(char *str)
 
 	do {
 		cdr0.raw =
-				nca_register_read((unsigned *)(nca_address + 0xf0));
-		} while ((0x1 == cdr0.bits.start_done) &&
-				(time_before(jiffies, timeout)));
-
-		if (0x1 == cdr0.bits.start_done) {
-			/* timed out without completing */
-			pr_err("lsi-ncr: PIO operation timeout cdr0=0x%08lx!\n",
-					cdr0.raw);
-			ncr_pio_error_dump(str);
+			io_fn->rd((unsigned *)(nca_address + 0xf0));
+	} while ((0x1 == cdr0.bits.start_done) &&
+		 (time_before(jiffies, timeout)));
+
+	if (0x1 == cdr0.bits.start_done) {
+		/* timed out without completing */
+		pr_err("lsi-ncr: PIO operation timeout cdr0=0x%08lx!\n",
+		       cdr0.raw);
+		ncr_pio_error_dump(io_fn, str);
 		BUG();
 		return -1;
 	}
 
 	if (cdr0.raw && (0x3 != cdr0.bits.status)) {
 		/* completed with non-success status */
-		ncr_pio_error_dump(str);
+		ncr_pio_error_dump(io_fn, str);
 		/* clear CDR0 to allow subsequent commands to complete */
-		nca_register_write(0, (unsigned *) (nca_address + 0xf0));
+		io_fn->wr(0, (unsigned *) (nca_address + 0xf0));
 
 		/*
 		 * we now treat any config ring error as a BUG().
@@ -310,9 +355,10 @@ ncr_check_pio_status(char *str)
   ncr_read
 */
 
-int
-ncr_read_nolock(unsigned long region, unsigned long address, int number,
-		void *buffer)
+static int
+__ncr_read(struct ncr_io_fns *io_fn,
+	unsigned long region, unsigned long address, int number,
+	void *buffer)
 {
 	union command_data_register_0 cdr0;
 	union command_data_register_1 cdr1;
@@ -320,7 +366,7 @@ ncr_read_nolock(unsigned long region, unsigned long address, int number,
 
 	if ((NCP_NODE_ID(region) != 0x0153) && (NCP_NODE_ID(region) != 0x115)) {
 		/* make sure any previous command has completed */
-		if (0 != ncr_check_pio_status("previous"))
+		if (0 != ncr_check_pio_status(io_fn, "previous"))
 			return -1;
 
 		/*
@@ -330,11 +376,11 @@ ncr_read_nolock(unsigned long region, unsigned long address, int number,
 		cdr2.raw = 0;
 		cdr2.bits.target_node_id = NCP_NODE_ID(region);
 		cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
-		nca_register_write(cdr2.raw, (unsigned *) (nca_address + 0xf8));
+		io_fn->wr(cdr2.raw, (unsigned *) (nca_address + 0xf8));
 
 		cdr1.raw = 0;
 		cdr1.bits.target_address = (address >> 2);
-		nca_register_write(cdr1.raw, (unsigned *) (nca_address + 0xf4));
+		io_fn->wr(cdr1.raw, (unsigned *) (nca_address + 0xf4));
 
 		cdr0.raw = 0;
 		cdr0.bits.start_done = 1;
@@ -345,15 +391,13 @@ ncr_read_nolock(unsigned long region, unsigned long address, int number,
 		cdr0.bits.cmd_type = 4;
 		/* TODO: Verify number... */
 		cdr0.bits.dbs = (number - 1);
-		nca_register_write(cdr0.raw, (unsigned *) (nca_address + 0xf0));
-		/* Memory barrier */
+		io_fn->wr(cdr0.raw, (unsigned *) (nca_address + 0xf0));
 		mb();
 
 		/*
 		  Wait for completion.
 		*/
-
-		if (0 != ncr_check_pio_status("read"))
+		if (0 != ncr_check_pio_status(io_fn, "read"))
 			return -1;
 
 		/*
@@ -363,7 +407,7 @@ ncr_read_nolock(unsigned long region, unsigned long address, int number,
 		address = (unsigned long)(nca_address + 0x1000);
 		while (4 <= number) {
 			*((unsigned long *) buffer) =
-				nca_register_read((unsigned *) address);
+				io_fn->rd((unsigned *) address);
 			address += 4;
 			buffer += 4;
 			number -= 4;
@@ -371,7 +415,7 @@ ncr_read_nolock(unsigned long region, unsigned long address, int number,
 
 		if (0 < number) {
 			unsigned long temp =
-				nca_register_read((unsigned *) address);
+				io_fn->rd((unsigned *) address);
 			memcpy((void *) buffer, &temp, number);
 		}
 	} else {
@@ -452,6 +496,15 @@ ncr_read_nolock(unsigned long region, unsigned long address, int number,
 
 	return 0;
 }
+
+
+int
+ncr_read_nolock(unsigned long region, unsigned long address,
+		 int number, void *buffer)
+{
+	return __ncr_read(&ncr_io_fn_nolock,
+		region, address, number, buffer);
+}
 EXPORT_SYMBOL(ncr_read_nolock);
 
 
@@ -471,7 +524,8 @@ ncr_read(unsigned long region, unsigned long address, int number,
 
 	ncr_lock(LOCK_DOMAIN);
 
-	rc = ncr_read_nolock(region, address, number, buffer);
+	/* call __ncr_read with chip version dependent io_fn */
+	rc = __ncr_read(default_io_fn, region, address, number, buffer);
 
 	ncr_unlock(LOCK_DOMAIN);
 
@@ -484,9 +538,10 @@ EXPORT_SYMBOL(ncr_read);
   ncr_write
 */
 
-int
-ncr_write_nolock(unsigned long region, unsigned long address, int number,
-		 void *buffer)
+static int
+__ncr_write(struct ncr_io_fns *io_fn,
+	unsigned long region, unsigned long address, int number,
+	void *buffer)
 {
 	union command_data_register_0 cdr0;
 	union command_data_register_1 cdr1;
@@ -496,7 +551,7 @@ ncr_write_nolock(unsigned long region, unsigned long address, int number,
 
 	if ((NCP_NODE_ID(region) != 0x0153) && (NCP_NODE_ID(region) != 0x115)) {
 		/* make sure any previous command has completed */
-		if (0 != ncr_check_pio_status("previous"))
+		if (0 != ncr_check_pio_status(io_fn, "previous"))
 			return -1;
 
 		/*
@@ -506,11 +561,11 @@ ncr_write_nolock(unsigned long region, unsigned long address, int number,
 		cdr2.raw = 0;
 		cdr2.bits.target_node_id = NCP_NODE_ID(region);
 		cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
-		nca_register_write(cdr2.raw, (unsigned *) (nca_address + 0xf8));
+		io_fn->wr(cdr2.raw, (unsigned *) (nca_address + 0xf8));
 
 		cdr1.raw = 0;
 		cdr1.bits.target_address = (address >> 2);
-		nca_register_write(cdr1.raw, (unsigned *) (nca_address + 0xf4));
+		io_fn->wr(cdr1.raw, (unsigned *) (nca_address + 0xf4));
 
 		/*
 		  Copy from buffer to the data words.
@@ -519,7 +574,7 @@ ncr_write_nolock(unsigned long region, unsigned long address, int number,
 		data_word_base = (unsigned long)(nca_address + 0x1000);
 
 		while (4 <= number) {
-			nca_register_write(*((unsigned long *) buffer),
+			io_fn->wr(*((unsigned long *) buffer),
 					   (unsigned *) data_word_base);
 			data_word_base += 4;
 			buffer += 4;
@@ -530,7 +585,7 @@ ncr_write_nolock(unsigned long region, unsigned long address, int number,
 			unsigned long temp = 0;
 
 			memcpy((void *) &temp, (void *) buffer, number);
-			nca_register_write(temp, (unsigned *) data_word_base);
+			io_fn->wr(temp, (unsigned *) data_word_base);
 			data_word_base += number;
 			buffer += number;
 			number = 0;
@@ -545,15 +600,14 @@ ncr_write_nolock(unsigned long region, unsigned long address, int number,
 		cdr0.bits.cmd_type = 5;
 		/* TODO: Verify number... */
 		cdr0.bits.dbs = dbs;
-		nca_register_write(cdr0.raw, (unsigned *) (nca_address + 0xf0));
-		/* Memory barrier */
+		io_fn->wr(cdr0.raw, (unsigned *) (nca_address + 0xf0));
 		mb();
 
 		/*
 		  Wait for completion.
 		*/
 
-		if (0 != ncr_check_pio_status("write"))
+		if (0 != ncr_check_pio_status(io_fn, "write"))
 			return -1;
 
 	} else {
@@ -625,6 +679,16 @@ ncr_write_nolock(unsigned long region, unsigned long address, int number,
 
 	return 0;
 }
+
+
+int
+ncr_write_nolock(unsigned long region, unsigned long address, int number,
+	  void *buffer)
+{
+	/* call the __ncr_write function with nolock io_fn */
+	return __ncr_write(&ncr_io_fn_nolock,
+			region, address, number, buffer);
+}
 EXPORT_SYMBOL(ncr_write_nolock);
 
 
@@ -642,10 +706,13 @@ ncr_write(unsigned long region, unsigned long address, int number,
 		return -1;
 #endif /* APB2SER_PHY_PHYS_ADDRESS */
 
+	/* grab the ncr_lock */
 	ncr_lock(LOCK_DOMAIN);
 
-	rc = ncr_write_nolock(region, address, number, buffer);
+	/* call the __ncr_write function with chip-version dependent io_fn */
+	rc = __ncr_write(default_io_fn, region, address, number, buffer);
 
+	/* free the ncr_lock */
 	ncr_unlock(LOCK_DOMAIN);
 
 	return rc;
@@ -660,6 +727,42 @@ EXPORT_SYMBOL(ncr_write);
 static int
 ncr_init(void)
 {
+#ifdef CONFIG_ARCH_AXXIA
+	u32 pfuse;
+	u32 chip_type;
+	u32 chip_ver;
+	void __iomem *syscon;
+
+	syscon = ioremap(SYSCON_PHYS_ADDR, SZ_64K);
+
+	if (WARN_ON(!syscon))
+		return -ENODEV;
+
+	/*
+	 * read chip type/revision to determine if low-level locking
+	 * is required and select the appropriate io_fns.
+	 */
+	pfuse = readl(syscon + 0x34);
+	chip_type = pfuse & 0x1f;
+	chip_ver  = (pfuse >> 8) & 0x7;
+
+	if ((chip_type == 0 || chip_type == 9) && (chip_ver == 0)) {
+		/* AXM5516v1.0 needs low-level locking */
+		default_io_fn = &ncr_io_fn_lock;
+	} else {
+		/* no low-level locking needed */
+		default_io_fn = &ncr_io_fn_nolock;
+	}
+
+	iounmap(syscon);
+#else
+	/* 3500 doesn't need the lock, 3400 does. */
+	if (of_find_compatible_node(NULL, NULL, "lsi,acp3500"))
+		default_io_fn = &ncr_io_fn_nolock;
+	else
+		default_io_fn = &ncr_io_fn_lock;
+#endif
+
 	nca_address = ioremap(NCA_PHYS_ADDRESS, 0x20000);
 
 #ifdef APB2SER_PHY_PHYS_ADDRESS
diff --git a/drivers/misc/lsi-ncr.h b/drivers/misc/lsi-ncr.h
index d639dbb..3c1e676 100644
--- a/drivers/misc/lsi-ncr.h
+++ b/drivers/misc/lsi-ncr.h
@@ -41,5 +41,4 @@ int ncr_write(unsigned long, unsigned long, int, void *);
 int ncr_read_nolock(unsigned long, unsigned long, int, void *);
 int ncr_write_nolock(unsigned long, unsigned long, int, void *);
 
-
 #endif /*  __DRIVERS_LSI_ACP_NCR_H */
-- 
1.7.5.4

