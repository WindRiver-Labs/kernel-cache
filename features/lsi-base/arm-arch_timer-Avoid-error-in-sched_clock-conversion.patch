From ad1d4cbc6edb75d61b4f820b926a4a4f1d8bf6c0 Mon Sep 17 00:00:00 2001
From: Li Wang <li.wang@windriver.com>
Date: Wed, 26 Aug 2015 10:28:01 +0800
Subject: [PATCH 55/68] arm: arch_timer: Avoid error in sched_clock conversion

the patch comes from:
git://git.yoctoproject.org/linux-yocto-3.10
commit d500a6da5741752aab4ba8d1b11f4e2d9b2c0af7 upstream

Fix sched_clock setup to handle conversions of sched_clock when the frequency
of the clock doesn't evenly divide NSEC_PER_SEC.

To handle this, the conversion from clock ticks to nanoseconds must be done via
a multiplication and a shift (to avoid divide). The appropriate multiplication
and shift factors are computed using the helper from kernel/clocksource.c

Signed-off-by: Anders Berg <anders.berg@intel.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
Signed-off-by: Li Wang <li.wang@windriver.com>
---
 arch/arm/kernel/arch_timer.c |   21 ++++++++++++++-------
 1 files changed, 14 insertions(+), 7 deletions(-)

diff --git a/arch/arm/kernel/arch_timer.c b/arch/arm/kernel/arch_timer.c
index 1f4c260..d3867dd 100644
--- a/arch/arm/kernel/arch_timer.c
+++ b/arch/arm/kernel/arch_timer.c
@@ -27,8 +27,8 @@ static u32 sched_clock_shift __read_mostly;
 
 static unsigned long long notrace arch_timer_sched_clock(void)
 {
-	return (arch_timer_read_counter() * sched_clock_mult) >>
-					sched_clock_shift;
+	unsigned long long tmp = arch_timer_read_counter();
+	return (tmp * sched_clock_mult) >> sched_clock_shift;
 }
 
 static struct delay_timer arch_delay_timer;
@@ -43,18 +43,25 @@ static void __init arch_timer_delay_timer_register(void)
 
 int __init arch_timer_arch_init(void)
 {
-        u32 arch_timer_rate = arch_timer_get_rate();
-	/* 56 bits minimum, so we assume worst case rollover */
-	u64 max_cyc = (1ULL << 56) - 1;
+	u32 arch_timer_rate = arch_timer_get_rate();
+	u64 maxsec;
 
 	if (arch_timer_rate == 0)
 		return -ENXIO;
 
 	arch_timer_delay_timer_register();
 
+	/* Select maxsec so we get a large conversion range (56 bits) for the
+	 * mult/shift while making sure the resulting maxsec fits in 32 bits.
+	 */
+	maxsec = 1ULL << 56;
+	do_div(maxsec, arch_timer_rate);
+	if ((maxsec >> 32) != 0)
+		maxsec = 0xffffffff;
+
+	/* Cache the multiplier and shift to save a divide in the hot path. */
 	clocks_calc_mult_shift(&sched_clock_mult, &sched_clock_shift,
-				arch_timer_rate, NSEC_PER_SEC,
-				do_div(max_cyc, arch_timer_rate));
+			       arch_timer_rate, NSEC_PER_SEC, (u32)maxsec);
 	sched_clock_func = arch_timer_sched_clock;
 	pr_info("sched_clock: ARM arch timer >56 bits at %ukHz, resolution %uns\n",
 		arch_timer_rate / 1000, sched_clock_mult>>sched_clock_shift);
-- 
1.7.5.4

