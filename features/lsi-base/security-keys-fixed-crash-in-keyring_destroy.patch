From 3a986a1b8aef09beabdd35224efe1a0113d0c909 Mon Sep 17 00:00:00 2001
From: lwang1 <li.wang@windriver.com>
Date: Thu, 15 Jun 2017 09:12:09 +0800
Subject: [PATCH] security/keys: fixed crash in keyring_destroy

the patch comes from:
http://git.yoctoproject.org/cgit/cgit.cgi/linux-yocto-3.14/commit/?h=standard/axxia/base&id=3292fabb1de9e50bcd3a459f57b97d61fbd2cb89

*For 3.14 standard/(preempt-rt)/axxia/base branches.

When the ltp add_key01 was run the kernel was crashing,
the list_del initializes the next pointer to LIST_POISON1.
When subsequent keyring destroy events happened, the system would
check for NULL and it would be false and try to call list_del
with the pointer pointing to LIST_POISON1 causing the
memory fault. This patch adds checking for LIST_POISON1
instead of NULL.

Signed-off-by: Charlie Paul <cpaul.windriver@gmail.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
Signed-off-by: lwang1 <li.wang@windriver.com>
---
 security/keys/keyring.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/security/keys/keyring.c b/security/keys/keyring.c
index 79fb9f4..f571cad 100644
--- a/security/keys/keyring.c
+++ b/security/keys/keyring.c
@@ -376,8 +376,8 @@ static void keyring_destroy(struct key *keyring)
 	if (keyring->description) {
 		write_lock(&keyring_name_lock);
 
-		if (keyring->type_data.link.next != NULL &&
-		    !list_empty(&keyring->type_data.link))
+		if (keyring->type_data.link.next != LIST_POISON1 &&
+				!list_empty(&keyring->type_data.link))
 			list_del(&keyring->type_data.link);
 
 		write_unlock(&keyring_name_lock);
-- 
1.7.5.4

