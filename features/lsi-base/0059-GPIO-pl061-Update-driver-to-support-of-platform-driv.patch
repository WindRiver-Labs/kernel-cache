From 139704114498c11a979891d63d8c4cc74d4c2cc8 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Fri, 4 Apr 2014 02:25:35 +0000
Subject: [PATCH 059/175] GPIO:pl061: Update driver to support of-platform drivers

git.yoctoproject.org/git/linux-yocto-3.10
commit e55efc6bb06c1d70aaf7040c4dd753fa18a36f62 standard/axxia/base.

Since the PPC LSI ACP34xx board implements two pl061 gpio controllers,
update driver register interface to support ppc of-platform style
driver register interface.

This patch abstracts the common code of probe routine between
ARM_AMBA style driver and of-platform driver, then forks a new driver
for ppc of-platform.

The OF style driver extracts device information from device-tree, including
gpio base, io address & irq.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/gpio/Kconfig      |    2 +-
 drivers/gpio/gpio-pl061.c |  114 +++++++++++++++++++++++++++++++++++++++-----
 2 files changed, 102 insertions(+), 14 deletions(-)

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 573c449..3f356e5 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -192,7 +192,7 @@ config GPIO_MXS
 
 config GPIO_PL061
 	bool "PrimeCell PL061 GPIO support"
-	depends on ARM && ARM_AMBA
+	depends on ARM && ARM_AMBA || ACP
 	select GENERIC_IRQ_CHIP
 	help
 	  Say yes here to support the PrimeCell PL061 GPIO device
diff --git a/drivers/gpio/gpio-pl061.c b/drivers/gpio/gpio-pl061.c
index 4fbe12d..177ebd1 100644
--- a/drivers/gpio/gpio-pl061.c
+++ b/drivers/gpio/gpio-pl061.c
@@ -21,7 +21,13 @@
 #include <linux/workqueue.h>
 #include <linux/gpio.h>
 #include <linux/device.h>
+#ifdef CONFIG_ARM_AMBA
 #include <linux/amba/bus.h>
+#include <asm/mach/irq.h>
+#else
+#include <linux/of_platform.h>
+#include <linux/of.h>
+#endif
 #include <linux/amba/pl061.h>
 #include <linux/slab.h>
 #include <linux/pinctrl/consumer.h>
@@ -49,6 +55,18 @@ struct pl061_context_save_regs {
 };
 #endif
 
+#ifdef CONFIG_PPC
+static inline void chained_irq_enter(struct irq_chip *chip,
+				     struct irq_desc *desc) {}
+
+static inline void chained_irq_exit(struct irq_chip *chip,
+				   struct irq_desc *desc)
+{
+	if (chip->irq_eoi)
+		chip->irq_eoi(&desc->irq_data);
+}
+#endif
+
 struct pl061_gpio {
 	spinlock_t		lock;
 
@@ -256,12 +274,12 @@ static const struct irq_domain_ops pl061_domain_ops = {
 	.xlate	= irq_domain_xlate_twocell,
 };
 
-static int pl061_probe(struct amba_device *adev, const struct amba_id *id)
+static int pl061_probe(struct device *dev,
+		struct resource *res, int irq, struct pl061_gpio **retchip)
 {
-	struct device *dev = &adev->dev;
 	struct pl061_platform_data *pdata = dev->platform_data;
 	struct pl061_gpio *chip;
-	int ret, irq, i, irq_base;
+	int ret, i, irq_base;
 
 	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
 	if (chip == NULL)
@@ -277,14 +295,20 @@ static int pl061_probe(struct amba_device *adev, const struct amba_id *id)
 		irq_base = 0;
 	}
 
-	if (!devm_request_mem_region(dev, adev->res.start,
-				     resource_size(&adev->res), "pl061"))
+	if (!devm_request_mem_region(dev, res->start,
+				     resource_size(res), "pl061")) {
+		if (retchip)
+			*retchip = NULL;
 		return -EBUSY;
+	}
 
-	chip->base = devm_ioremap(dev, adev->res.start,
-				  resource_size(&adev->res));
-	if (!chip->base)
+	chip->base = devm_ioremap(dev, res->start,
+				  resource_size(res));
+	if (!chip->base) {
+		if (retchip)
+			*retchip = NULL;
 		return -ENOMEM;
+	}
 
 	spin_lock_init(&chip->lock);
 
@@ -301,16 +325,24 @@ static int pl061_probe(struct amba_device *adev, const struct amba_id *id)
 	chip->gc.owner = THIS_MODULE;
 
 	ret = gpiochip_add(&chip->gc);
-	if (ret)
+	if (ret) {
+		if (retchip)
+			*retchip = NULL;
 		return ret;
+	}
+
+	if (retchip)
+		*retchip = chip;
 
 	/*
 	 * irq_chip support
 	 */
 	writeb(0, chip->base + GPIOIE); /* disable irqs */
-	irq = adev->irq[0];
-	if (irq < 0)
+	if (irq < 0) {
+		if (retchip)
+			*retchip = NULL;
 		return -ENODEV;
+	}
 
 	irq_set_chained_handler(irq, pl061_irq_handler);
 	irq_set_handler_data(irq, chip);
@@ -330,7 +362,7 @@ static int pl061_probe(struct amba_device *adev, const struct amba_id *id)
 		}
 	}
 
-	amba_set_drvdata(adev, chip);
+	drv_set_drvdata(dev, chip);
 
 	return 0;
 }
@@ -387,6 +419,12 @@ static const struct dev_pm_ops pl061_dev_pm_ops = {
 };
 #endif
 
+#ifdef CONFIG_ARM_AMBA
+static int pl061_amba_probe(struct amba_device *dev, struct amba_id *id)
+{
+	return pl061_probe(&dev->dev, &dev->res, dev->irq[0], NULL);
+}
+
 static struct amba_id pl061_ids[] = {
 	{
 		.id	= 0x00041061,
@@ -405,9 +443,59 @@ static struct amba_driver pl061_gpio_driver = {
 #endif
 	},
 	.id_table	= pl061_ids,
-	.probe		= pl061_probe,
+	.probe		= pl061_amba_probe,
+};
+#else
+static int pl061_of_probe(struct platform_device *ofdev)
+{
+	struct resource r_mem;
+	struct pl061_platform_data pl061_data = {0};
+	int irq;
+	const u32 *prop;
+	int len;
+	struct pl061_gpio *chip = NULL;
+	int ret;
+
+	if (of_address_to_resource(ofdev->dev.of_node, 0, &r_mem))
+		return -ENODEV;
+
+	pl061_data.gpio_base = 0;
+	prop = of_get_property(ofdev->dev.of_node, "cell-index", &len);
+	if (!prop || len < sizeof(*prop))
+		dev_warn(&ofdev->dev, "no 'cell-index' property\n");
+	else
+		pl061_data.gpio_base = *prop;
+
+	irq = of_irq_to_resource(ofdev->dev.of_node, 0, NULL);
+	pl061_data.irq_base = irq;
+	if (irq == NO_IRQ)
+		pl061_data.irq_base = (unsigned) -1;
+
+	ofdev->dev.platform_data = &pl061_data;
+
+	ret = pl061_probe(&ofdev->dev, &r_mem, irq, &chip);
+
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static struct of_device_id pl061_match[] = {
+	{
+		.compatible = "amba_pl061",
+	},
+	{ /* end of list */ },
 };
 
+static struct platform_driver pl061_gpio_driver = {
+	.driver = {
+		.name = "gpio-pl061",
+		.of_match_table = pl061_match,
+	},
+	.probe = pl061_of_probe,
+};
+#endif
+
 static int __init pl061_gpio_init(void)
 {
 	return amba_driver_register(&pl061_gpio_driver);
-- 
1.7.1

