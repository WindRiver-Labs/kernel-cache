From d94cbdc1950aaaa3172f2cdb5253958940520de8 Mon Sep 17 00:00:00 2001
From: David Mercado <david.mercado@windriver.com>
Date: Wed, 20 Nov 2013 16:41:36 -0500
Subject: [PATCH 147/175] LSI ACP34XX: mtd nand: 3.10 updates

git.yoctoproject.org/git/linux-yocto-3.10
commit 3f2b7d1c8f9ad65a67e293b78f205e9660d9d2fe standard/axxia/base.

The read_page, write_page, and read_oob callbacks need to be updated
to be consistent with nand_ecc_ctrl.

Also, MTD_NAND_VERIFY_WRITE has been removed in commit
657f28f8811c92724db10d18bbbec70d540147d6 "mtd: kill MTD_NAND_VERIFY_WRITE".

Remove the nand_ecc_ctrl.verify_buf method in the LSI nand driver.

Signed-off-by: Hong H. Pham <hong.pham@windriver.com>
---
 drivers/mtd/nand/lsi_acp_nand.c |  165 ++++++++++++++------------------------
 1 files changed, 61 insertions(+), 104 deletions(-)

diff --git a/drivers/mtd/nand/lsi_acp_nand.c b/drivers/mtd/nand/lsi_acp_nand.c
index c3165d9..23b9bd1 100644
--- a/drivers/mtd/nand/lsi_acp_nand.c
+++ b/drivers/mtd/nand/lsi_acp_nand.c
@@ -53,7 +53,7 @@ _READL(const char *file, int line, unsigned long address)
 	value = readl(address);
 
 	if (0 != enable_logio)
-		printk(KERN_INFO "%s:%d - Read 0x%08lx from 0x%08lx\n",
+		pr_info("%s:%d - Read 0x%08lx from 0x%08lx\n",
 		       file, line, value, address);
 
 	return value;
@@ -66,7 +66,7 @@ _WRITEL(const char *file, int line, unsigned long value, unsigned long address)
 	writel(value, address);
 
 	if (0 != enable_logio)
-		printk(KERN_ERR "%s:%d - Wrote 0x%08lx to 0x%08lx\n",
+		pr_err("%s:%d - Wrote 0x%08lx to 0x%08lx\n",
 		       file, line, value, address);
 
 	return;
@@ -621,8 +621,7 @@ lsi_nand_command(struct mtd_info *mtd, unsigned int command,
 	    command != NAND_CMD_START_ECC_READ &&
 	    command != NAND_CMD_PAGEPROG &&
 	    command != NAND_CMD_ERASE2) {
-		printk(KERN_ERR
-		       "lsi_nand_command(): WARN: Unhandled command 0x%x "
+		pr_err("lsi_nand_command(): WARN: Unhandled command 0x%x "
 		       "issued for page=0x%x, column=0x%x.\n",
 		       command, page_addr, column);
 		return;
@@ -745,7 +744,7 @@ static void lsi_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
 
 #if defined(LOGIO)
 	if (0 != enable_logio)
-		printk("KERN_NOTICE Reading NAND Buffer (len=%d)...\n", len);
+		pr_notice("Reading NAND Buffer (len=%d)...\n", len);
 #endif
 
 	for (i = 0; i < (len >> 2); i++)
@@ -771,7 +770,7 @@ lsi_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
 
 #if defined(LOGIO)
 	if (0 != enable_logio)
-		printk(KERN_NOTICE "Writing NAND Buffer (len=%d)...\n", len);
+		pr_notice("Writing NAND Buffer (len=%d)...\n", len);
 #endif
 
 	for (i = 0; i < (len >> 2); i++)
@@ -780,30 +779,6 @@ lsi_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
 	return;
 }
 
-/**
- * lsi_nand_verify_buf - [DEFAULT] Verify chip data against buffer
- * @mtd:	MTD device structure
- * @buf:	buffer containing the data to compare
- * @len:	number of bytes to compare
- *
- * Default verify function for 8bit buswith
- */
-static int lsi_nand_verify_buf(struct mtd_info *mtd,
-			       const uint8_t *buf, int len)
-{
-	int i;
-	struct nand_chip *chip = mtd->priv;
-	uint32_t *p = (uint32_t *)buf;
-
-	for (i = 0; i < (len >> 2); i++) {
-		udelay(chip->chip_delay);
-		if (p[i] != readl((uint32_t *)chip->IO_ADDR_R))
-			return -EFAULT;
-	}
-
-	return 0;
-}
-
 static int lsi_nand_read_status(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
@@ -885,8 +860,7 @@ static int lsi_nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 	if (status & NAND_STATUS_FAIL) {
 		offset = (READL(chip->IO_ADDR_R + NAND_INDEX_REG) /
 			  mtd->writesize) * mtd->writesize;
-		printk(KERN_ERR
-		       "lsi_nand_wait(): Action %d failed for "
+		pr_err("lsi_nand_wait(): Action %d failed for "
 		       "Offset: 0x%llx, status 0x%lx\n",
 		       chip->state, offset, status);
 	}
@@ -958,26 +932,23 @@ report_ecc_errors_ep501(struct mtd_info *mtd, struct nand_chip *chip,
 		column = (i << 9) + ecc_status_reg->column;
 
 		if (1 == ecc_status_reg->status) {
-			printk(KERN_NOTICE
-			       "Single ECC Error: "
-			       "Page=0x%x Column=0x%x Bit=0x%x\n",
-			       page, column, ecc_status_reg->err_bit);
+			pr_notice("Single ECC Error: "
+				  "Page=0x%x Column=0x%x Bit=0x%x\n",
+				  page, column, ecc_status_reg->err_bit);
 
 			if (column < mtd->writesize) {
 				buffer[column] ^=
 					(1 << ecc_status_reg->err_bit);
 				++mtd->ecc_stats.corrected;
 			} else {
-				printk(KERN_ERR
-				       "Single ECC Error Not Corrected: "
+				pr_err("Single ECC Error Not Corrected: "
 				       "Column 0x%x not in "
 				       "Page Size 0x%x\n",
 				       column, mtd->writesize);
 				rc = -1;
 			}
 		} else if ((ecc_status & 0x3000) == 2) {
-			printk(KERN_ERR
-			       "Uncorrectable ECC Error: "
+			pr_err("Uncorrectable ECC Error: "
 			       "Page=0x%x Column=0x%x\n",
 			       page, column);
 			rc = -1;
@@ -2701,12 +2672,12 @@ fix_section(unsigned long offset, void *data, int *syndromes_in)
 
 			for (i = 0; i <= Matrix_a[temp_index]; i++) {
 				if (err_loc_ply[temp_index][i] != 0)
-					err_loc_ply[alpha + 2][i + \
+					err_loc_ply[alpha + 2][i +
 						alpha - temp_index] =
-					a_to_i[(Matrix_c[alpha] + \
-						block_length - \
-						Matrix_c[temp_index] + \
-						i_to_a[err_loc_ply[temp_index] \
+					a_to_i[(Matrix_c[alpha] +
+						block_length -
+						Matrix_c[temp_index] +
+						i_to_a[err_loc_ply[temp_index]
 						[i]]) % block_length];
 			}
 
@@ -2736,7 +2707,7 @@ fix_section(unsigned long offset, void *data, int *syndromes_in)
 					(err_loc_ply[alpha + 2][i] != 0))
 					Matrix_c[alpha + 2] ^=
 						a_to_i[(syndromes[alpha + 1 - i]
-						+ i_to_a[err_loc_ply[alpha + 2]\
+						+ i_to_a[err_loc_ply[alpha + 2]
 						[i]]) % block_length];
 			}
 			Matrix_c[alpha + 2] = i_to_a[Matrix_c[alpha + 2]];
@@ -2749,24 +2720,24 @@ fix_section(unsigned long offset, void *data, int *syndromes_in)
 		for (i = 1; i <= Matrix_a[7]; i++)
 			Element[i] = i_to_a[err_loc_ply[alpha][i]];
 
-		err_count = 0 ;
+		err_count = 0;
 		for (i = 1; i <= block_length; i++) {
-			elp_sum = 1 ;
+			elp_sum = 1;
 			for (j = 1; j <= Matrix_a[7]; j++)
 				if (Element[j] != -1) {
 					Element[j] = (Element[j] + j) %
-						block_length ;
-					elp_sum ^= a_to_i[Element[j]] ;
+						block_length;
+					elp_sum ^= a_to_i[Element[j]];
 				}
 
 			if (!elp_sum) {
-				err_location[err_count] = block_length - i ;
-				err_count++ ;
+				err_location[err_count] = block_length - i;
+				err_count++;
 			}
 		}
 
 		if (err_count == Matrix_a[7])
-			d_flg = 1 ;
+			d_flg = 1;
 	}
 
 	if (d_flg == 0) {
@@ -2783,10 +2754,9 @@ fix_section(unsigned long offset, void *data, int *syndromes_in)
 				result_bit = rev_location % 8;
 				result_byte = (rev_location - result_bit) / 8;
 
-				printk(KERN_NOTICE
-				       "Corrected ECC Error: "
-				       "offset 0x%lx byte 0x%x bit %d\n",
-				       offset, result_byte, result_bit);
+				pr_notice("Corrected ECC Error: "
+					  "offset 0x%lx byte 0x%x bit %d\n",
+					  offset, result_byte, result_bit);
 
 				result_byte =
 					(result_byte & 0xfffffffc) |
@@ -2798,8 +2768,7 @@ fix_section(unsigned long offset, void *data, int *syndromes_in)
 				rev_location = 4147 - data_location;
 				result_bit = rev_location % 8;
 				result_byte = (rev_location - result_bit) / 8;
-				printk(KERN_ERR
-				       "BCH byte = %d, bit = %d\n",
+				pr_err("BCH byte = %d, bit = %d\n",
 				       result_byte, result_bit);
 			}
 		}
@@ -2829,13 +2798,11 @@ report_ecc_errors_ep501g1(struct mtd_info *mtd, struct nand_chip *chip,
 
 		switch (ecc_status & (3 << 12)) {
 		case 01:
-			printk(KERN_ERR
-			       "Correctable ECC Error: %d:0x%lx\n",
+			pr_err("Correctable ECC Error: %d:0x%lx\n",
 			       i, ecc_status);
 			break;
 		case 02:
-			printk(KERN_ERR
-			       "Uncorrectable ECC Error: %d:0x%lx\n",
+			pr_err("Uncorrectable ECC Error: %d:0x%lx\n",
 			       i, ecc_status);
 			break;
 		}
@@ -2867,7 +2834,7 @@ report_ecc_errors_ep501g3(struct mtd_info *mtd, struct nand_chip *chip,
 	value = (READL(chip->IO_ADDR_R + EP501_NAND_CONFIG_REG) & 0x1800) >> 11;
 
 	if (1 != value) {
-		printk("Only 4-Bit ECC is supported.\n");
+		pr_err("Only 4-Bit ECC is supported.\n");
 		rc = -1;
 		goto report_ecc_errors_ep501g3_end;
 	}
@@ -2889,7 +2856,7 @@ report_ecc_errors_ep501g3(struct mtd_info *mtd, struct nand_chip *chip,
 		bch_status &= 0xff;
 		break;
 	default:
-		printk(KERN_ERR "Unexpected Page Size!\n");
+		pr_err("Unexpected Page Size!\n");
 		rc = -1;
 		goto report_ecc_errors_ep501g3_end;
 		break;
@@ -2927,15 +2894,15 @@ report_ecc_errors_ep501g3(struct mtd_info *mtd, struct nand_chip *chip,
 
 #ifdef NOT_USED
 	/* Debug output (BCH status register and syndromes). */
-	printk(KERN_INFO "BCH Status Register: 0x%02lx\n", bch_status);
+	pr_info("BCH Status Register: 0x%02lx\n", bch_status);
 
 	for (section = 0; section < 8; ++section) {
-		printk(KERN_INFO "Syndromes, Section %d: ", section);
+		pr_info("Syndromes, Section %d: ", section);
 
 		for (syndrome = 0; syndrome < 8; ++syndrome)
-			printk(KERN_INFO "0x%04lx ",
+			pr_info("0x%04lx ",
 
-		printk(KERN_INFO "\n");
+		pr_info("\n");
 	}
 #endif
 
@@ -2946,8 +2913,7 @@ report_ecc_errors_ep501g3(struct mtd_info *mtd, struct nand_chip *chip,
 					 (int *)&syndromes[i]);
 
 			if (-1 == rc)
-				printk(KERN_ERR
-				       "Uncorrectable ECC Error: Page %d\n",
+				pr_err("Uncorrectable ECC Error: Page %d\n",
 				       page);
 		}
 	}
@@ -2998,7 +2964,7 @@ report_ecc_errors(struct mtd_info *mtd, struct nand_chip *chip,
 
 static int
 lsi_nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
-			 uint8_t *buf, int page)
+			 uint8_t *buf, int oob_required, int page)
 {
 	int rc;
 	/*int page = 0;*/
@@ -3031,7 +2997,7 @@ lsi_nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
  */
 static int
 lsi_nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
-			  const uint8_t *buf)
+			   const uint8_t *buf, int oob_required)
 {
 	/* write the page data */
 	chip->write_buf(mtd, buf, mtd->writesize);
@@ -3056,16 +3022,17 @@ lsi_nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
 
 static int
 lsi_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
-		    const uint8_t *buf, int page, int cached, int raw)
+		    uint32_t offset, int data_len, const uint8_t *buf,
+		    int oob_required, int page, int cached, int raw)
 {
 	int status;
 
 	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
 
 	if (unlikely(raw))
-		chip->ecc.write_page_raw(mtd, chip, buf);
+		chip->ecc.write_page_raw(mtd, chip, buf, 0);
 	else
-		chip->ecc.write_page(mtd, chip, buf);
+		chip->ecc.write_page(mtd, chip, buf, 0);
 
 	/* calculate ECC */
 	status = chip->ecc.calculate(mtd, NULL, NULL);
@@ -3078,7 +3045,7 @@ lsi_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
 	 * available
 	 */
 	if (status & NAND_STATUS_FAIL) {
-		printk(KERN_ERR "ERROR: Page write failed for page 0x%x\n",
+		pr_err("ERROR: Page write failed for page 0x%x\n",
 		       page);
 
 		if (chip->errstat)
@@ -3088,14 +3055,6 @@ lsi_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
 		return -EIO;
 	}
 
-#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
-	/* Send command to read back the data */
-	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
-
-	if (chip->verify_buf(mtd, buf, mtd->writesize))
-		return -EIO;
-#endif
-
 	return 0;
 }
 
@@ -3110,7 +3069,7 @@ lsi_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
 
 static int
 lsi_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
-		  int page, int sndcmd)
+		  int page)
 {
 	int rc;
 
@@ -3129,7 +3088,7 @@ lsi_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
 	/* cmd to controller to turn off CE */
 	chip->cmd_ctrl(mtd, nand_cmd_ce_off, 0);
 
-	return sndcmd;
+	return 0;
 }
 
 /**
@@ -3331,7 +3290,7 @@ lsi_nand_set_config(struct mtd_info *mtd, struct nand_chip *chip)
 			config |= 2;
 			break;
 		default:
-			printk(KERN_ERR "Invalid Device Size: 0x%lx\n", mbits);
+			pr_err("Invalid Device Size: 0x%lx\n", mbits);
 			return -1;
 			break;
 		}
@@ -3368,8 +3327,7 @@ lsi_nand_set_config(struct mtd_info *mtd, struct nand_chip *chip)
 		*/
 
 		if (mtd->oobsize < chip->ecc.layout->eccbytes) {
-			printk(KERN_ERR
-			       "ECC requires %d bytes, only %d are available.\n",
+			pr_err("ECC requires %d bytes, only %d are available\n",
 			       chip->ecc.layout->eccbytes, mtd->oobsize);
 			return -1;
 		}
@@ -3490,7 +3448,7 @@ lsi_nand_init(void)
 		enabled = of_get_property(np, "enabled", NULL);
 
 		if (!enabled || (enabled && (0 == *enabled))) {
-			printk("ACP NAND Controller Isn't Enabled.\n");
+			pr_err("ACP NAND Controller Isn't Enabled.\n");
 			return -ENODEV;
 		}
 
@@ -3502,10 +3460,10 @@ lsi_nand_init(void)
 			reg += 2;
 			gpreg_address = of_translate_address(np, reg);
 			gpreg_length = reg[1];
-			printk(KERN_INFO "nand_address=0x%08llx nand_length=0x%lx\n"
-			       "gpreg_address=0x%08llx gpreg_length=0x%lx\n",
-			       nand_address, nand_length,
-			       gpreg_address, gpreg_length);
+			pr_info("nand_address=0x%08llx nand_length=0x%lx\n"
+				"gpreg_address=0x%08llx gpreg_length=0x%lx\n",
+				nand_address, nand_length,
+				gpreg_address, gpreg_length);
 			nand_base = ioremap(nand_address, nand_length);
 			gpreg_base = ioremap(gpreg_address, gpreg_length);
 		} else {
@@ -3514,7 +3472,7 @@ lsi_nand_init(void)
 
 		ppdata.of_node = np;
 	} else {
-		printk(KERN_INFO "ACP NAND: Using Static Addresses.\n");
+		pr_info("ACP NAND: Using Static Addresses.\n");
 		nand_base = ioremap(0x002000440000ULL, 0x20000);
 		gpreg_base = ioremap(0x00200040c000ULL, 0x1000);
 	}
@@ -3549,19 +3507,19 @@ lsi_nand_init(void)
 
 	switch (lsi_nand_type) {
 	case LSI_NAND_EP501:
-		printk(KERN_INFO "EP501 NAND Controller.\n");
+		pr_info("EP501 NAND Controller.\n");
 		nand_cmd_ce_off = NAND_CMD_CE_OFF_501;
 		break;
 	case LSI_NAND_EP501G1:
-		printk(KERN_INFO "EP501G1 NAND Controller.\n");
+		pr_info("EP501G1 NAND Controller.\n");
 		nand_cmd_ce_off = NAND_CMD_CE_OFF_501G1;
 		break;
 	case LSI_NAND_EP501G3:
-		printk(KERN_INFO "EP501G3 NAND Controller.\n");
+		pr_info("EP501G3 NAND Controller.\n");
 		nand_cmd_ce_off = NAND_CMD_CE_OFF_501G3;
 		break;
 	default:
-		printk(KERN_INFO "Unknown NAND Controller!\n");
+		pr_info("Unknown NAND Controller!\n");
 		return -1;
 		break;
 	}
@@ -3580,7 +3538,6 @@ lsi_nand_init(void)
 	lsi_nand_chip.IO_ADDR_W = (void *) nand_base;
 	lsi_nand_chip.write_buf = lsi_nand_write_buf;
 	lsi_nand_chip.read_buf = lsi_nand_read_buf;
-	lsi_nand_chip.verify_buf = lsi_nand_verify_buf;
 	lsi_nand_chip.write_page = lsi_nand_write_page;
 	lsi_nand_chip.cmd_ctrl = lsi_nand_hwcontrol;
 	lsi_nand_chip.dev_ready = lsi_nand_device_ready;
@@ -3606,7 +3563,7 @@ lsi_nand_init(void)
 	lsi_nand_chip.ecc.read_oob = lsi_nand_read_oob;
 	lsi_nand_chip.ecc.write_oob = lsi_nand_write_oob;
 
-	printk(KERN_ERR "Enabling NAND ECC...\n");
+	pr_err("Enabling NAND ECC...\n");
 	/* clear any existing ECC status */
 	WRITEL(0x0, lsi_nand_chip.IO_ADDR_W + NAND_INTR_STATUS_REG);
 	/* enable ECC */
@@ -3680,10 +3637,10 @@ lsi_nand_init(void)
 		       (lsi_nand_chip.IO_ADDR_W + EP501G3_NAND_TIMING2_REG));
 	}
 
-	printk(KERN_ERR "Searching for NAND flash...\n");
+	pr_err("Searching for NAND flash...\n");
 	/* Scan to find existence of the device */
 	if (nand_scan(&lsi_nand_mtd, 1)) {
-		printk(KERN_ERR "nand_scan failure...\n");
+		pr_err("nand_scan failure...\n");
 		return -ENXIO;
 	}
 
-- 
1.7.1

