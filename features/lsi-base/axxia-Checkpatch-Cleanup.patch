From 969f1d6f01610c8b255dda70a866e6795aa87422 Mon Sep 17 00:00:00 2001
From: Li Wang <li.wang@windriver.com>
Date: Thu, 18 May 2017 10:45:20 +0800
Subject: [PATCH 1/6] axxia: Checkpatch Cleanup

the patch comes from:
http://git.yoctoproject.org/cgit/cgit.cgi/linux-yocto-3.14/commit/?h=standard/axxia/base&id=4da19a8e4c713e684b08513e1b701f03ac6b07cd

Signed-off-by: John Jacques <john.jacques@intel.com>
Signed-off-by: Li Wang <li.wang@windriver.com>
---
 arch/arm/mach-axxia/axxia.c         |   26 ++++++++--------
 arch/arm/mach-axxia/axxia.h         |    2 +
 arch/arm/mach-axxia/ddr_retention.c |   56 ++++++++++++++++------------------
 drivers/misc/lsi-ncr.c              |   28 ++++++++---------
 4 files changed, 54 insertions(+), 58 deletions(-)

diff --git a/arch/arm/mach-axxia/axxia.c b/arch/arm/mach-axxia/axxia.c
index 72f7a5c..446ab13 100644
--- a/arch/arm/mach-axxia/axxia.c
+++ b/arch/arm/mach-axxia/axxia.c
@@ -12,12 +12,12 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
  */
 
 #include <linux/amba/bus.h>
@@ -36,14 +36,14 @@
 #include <linux/smsc911x.h>
 #include <linux/clk-provider.h>
 #include <linux/clkdev.h>
+#include <linux/sizes.h>
+#include <linux/pmu.h>
+#include <linux/kexec.h>
 #ifdef CONFIG_ARM_ARCH_TIMER
 #include <asm/arch_timer.h>
 #endif
-#include <asm/sizes.h>
-#include <asm/pmu.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
-#include <asm/kexec.h>
 #include <asm/mach/time.h>
 #include <asm/hardware/cache-l2x0.h>
 #include <mach/hardware.h>
@@ -118,7 +118,7 @@ void __init axxia_dt_map_io(void)
 
 void __init axxia_dt_init_early(void)
 {
-	 init_dma_coherent_pool_size(SZ_1M);
+	init_dma_coherent_pool_size(SZ_1M);
 }
 
 static struct of_device_id axxia_irq_match[] __initdata = {
@@ -155,21 +155,21 @@ static struct mmci_platform_data mmc_plat_data = {
 
 static struct of_dev_auxdata axxia_auxdata_lookup[] __initdata = {
 	OF_DEV_AUXDATA("arm,primecell", 0x20101E0000ULL,
-		       "mmci",  &mmc_plat_data),
+		       "mmci",	&mmc_plat_data),
 	{}
 };
 
 static struct resource axxia_pmu_resources[] = {
 	[0] = {
-		.start  = IRQ_PMU,
-		.end    = IRQ_PMU,
-		.flags  = IORESOURCE_IRQ,
+		.start	= IRQ_PMU,
+		.end	= IRQ_PMU,
+		.flags	= IORESOURCE_IRQ,
 	},
 };
 
 static struct platform_device pmu_device = {
 	.name			= "arm-pmu",
-	.id                     = -1,
+	.id			= -1,
 	.num_resources		= ARRAY_SIZE(axxia_pmu_resources),
 	.resource		= axxia_pmu_resources,
 };
@@ -235,7 +235,7 @@ static void axxia_restart(enum reboot_mode reboot, const char *cmd)
 }
 
 DT_MACHINE_START(AXXIA_DT, "LSI Axxia")
-	.dt_compat	= axxia_dt_match,
+.dt_compat	= axxia_dt_match,
 	.smp		= smp_ops(axxia_smp_ops),
 	.map_io		= axxia_dt_map_io,
 	.init_early	= axxia_dt_init_early,
@@ -246,4 +246,4 @@ DT_MACHINE_START(AXXIA_DT, "LSI Axxia")
 #if defined(CONFIG_ZONE_DMA) && defined(CONFIG_ARM_LPAE)
 	.dma_zone_size	= (4ULL * SZ_1G) - 1,
 #endif
-MACHINE_END
+	MACHINE_END
diff --git a/arch/arm/mach-axxia/axxia.h b/arch/arm/mach-axxia/axxia.h
index c46b76d..3b8fb0c 100644
--- a/arch/arm/mach-axxia/axxia.h
+++ b/arch/arm/mach-axxia/axxia.h
@@ -5,6 +5,8 @@ void axxia_ddr_retention_init(void);
 void axxia_platform_cpu_die(unsigned int cpu);
 int axxia_platform_cpu_kill(unsigned int cpu);
 
+void ncp_ddr_shutdown(void *, void *, unsigned long);
+
 extern void axxia_secondary_startup(void);
 
 extern struct smp_operations axxia_smp_ops;
diff --git a/arch/arm/mach-axxia/ddr_retention.c b/arch/arm/mach-axxia/ddr_retention.c
index bd03156..5a9b0e2 100644
--- a/arch/arm/mach-axxia/ddr_retention.c
+++ b/arch/arm/mach-axxia/ddr_retention.c
@@ -143,11 +143,11 @@ flush_l3(void)
 }
 
 static void
-quiesce_vp_engine(int engineType)
+quiesce_vp_engine(int engine_type)
 {
-	unsigned long *pEngineRegions;
-	unsigned long ortOff, owtOff;
-	unsigned long *pRegion;
+	unsigned long *engine_regions;
+	unsigned long ort_off, owt_off;
+	unsigned long *region;
 	unsigned ort, owt;
 	unsigned long buf = 0;
 	unsigned short node, target;
@@ -155,53 +155,53 @@ quiesce_vp_engine(int engineType)
 
 	pr_info("quiescing VP engines...\n");
 
-	switch (engineType) {
+	switch (engine_type) {
 	case AXXIA_ENGINE_CNAL:
-		pEngineRegions = ncp_cnal_regions_acp55xx;
-		ortOff = 0x1c0;
-		owtOff = 0x1c4;
+		engine_regions = ncp_cnal_regions_acp55xx;
+		ort_off = 0x1c0;
+		owt_off = 0x1c4;
 		break;
 
 	case AXXIA_ENGINE_CAAL:
-		pEngineRegions = ncp_caal_regions_acp55xx;
-		ortOff = 0xf8;
-		owtOff = 0xfc;
+		engine_regions = ncp_caal_regions_acp55xx;
+		ort_off = 0xf8;
+		owt_off = 0xfc;
 		break;
 
 	default:
 		return;
 	}
 
-	pRegion = pEngineRegions;
+	region = engine_regions;
 
-	while (*pRegion != NCP_REGION_ID(0xff, 0xff)) {
+	while (*region != NCP_REGION_ID(0xff, 0xff)) {
 		/* set read/write transaction limits to zero */
-		ncr_write(*pRegion, 0x8, 4, &buf);
-		ncr_write(*pRegion, 0xc, 4, &buf);
-		pRegion++;
+		ncr_write(*region, 0x8, 4, &buf);
+		ncr_write(*region, 0xc, 4, &buf);
+		region++;
 	}
 
-	pRegion = pEngineRegions;
+	region = engine_regions;
 	loop = 0;
 
-	while (*pRegion != NCP_REGION_ID(0xff, 0xff)) {
-		node = (*pRegion & 0xffff0000) >> 16;
-		target = *pRegion & 0x0000ffff;
+	while (*region != NCP_REGION_ID(0xff, 0xff)) {
+		node = (*region & 0xffff0000) >> 16;
+		target = *region & 0x0000ffff;
 		/* read the number of outstanding read/write transactions */
-		ncr_read(*pRegion, ortOff, 4, &ort);
-		ncr_read(*pRegion, owtOff, 4, &owt);
+		ncr_read(*region, ort_off, 4, &ort);
+		ncr_read(*region, owt_off, 4, &owt);
 
 		if ((ort == 0) && (owt == 0)) {
 			/* this engine has been quiesced, move on to the next */
 			pr_info("quiesced region 0x%02x.0x%02x\n",
 					node, target);
-			pRegion++;
+			region++;
 		} else {
 			if (loop++ > 10000) {
 				pr_info(
 						"Unable to quiesce region 0x%02x.0x%02x ort=0x%x, owt=0x%x\n",
 						node, target, ort, owt);
-				pRegion++;
+				region++;
 				loop = 0;
 				continue;
 			}
@@ -247,18 +247,14 @@ reset_elm_trace(void)
 	ncr_register_write(htonl(0x000fff01), (unsigned *) (apb + 0x78000));
 }
 
-
-extern void ncp_ddr_shutdown(void *, void *,  unsigned long);
-
-
 void
 initiate_retention_reset(void)
 {
 	unsigned long ctl_244 = 0;
 	unsigned long value;
 	unsigned cpu_id;
-	volatile long tmp;
-	volatile long *ptmp;
+	long tmp;
+	long *ptmp;
 
 	if (0 == ddr_retention_enabled) {
 		pr_info("DDR Retention Reset is Not Enabled\n");
diff --git a/drivers/misc/lsi-ncr.c b/drivers/misc/lsi-ncr.c
index d65ec00..45e6741 100644
--- a/drivers/misc/lsi-ncr.c
+++ b/drivers/misc/lsi-ncr.c
@@ -47,13 +47,12 @@ static DEFINE_RAW_SPINLOCK(ncr_spin_lock);
  * is subjected to simultaneous requests from multiple masters
  */
 DEFINE_RAW_SPINLOCK(nca_access_lock);
-EXPORT_SYMBOL(nca_access_lock);
 
 static unsigned long ncr_spin_flags;
 
 #define LOCK_DOMAIN 0
 
-typedef union {
+union command_data_register_0 {
 	unsigned long raw;
 	struct {
 #ifdef __BIG_ENDIAN
@@ -76,16 +75,16 @@ typedef union {
 		unsigned long start_done:1;
 #endif
 	} __packed bits;
-} __packed command_data_register_0_t;
+} __packed;
 
-typedef union {
+union command_data_register_1 {
 	unsigned long raw;
 	struct {
 		unsigned long target_address:32;
 	} __packed bits;
-} __packed command_data_register_1_t;
+} __packed;
 
-typedef union {
+union command_data_register_2 {
 	unsigned long raw;
 	struct {
 #ifdef __BIG_ENDIAN
@@ -98,8 +97,7 @@ typedef union {
 		unsigned long unused:16;
 #endif
 	} __packed bits;
-} __packed command_data_register_2_t;
-
+} __packed;
 
 unsigned long
 ncr_register_read(unsigned *address)
@@ -231,7 +229,7 @@ static int
 ncr_check_pio_status(char *str)
 {
 	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
-	command_data_register_0_t cdr0;
+	union command_data_register_0 cdr0;
 
 	/*
 	  Make sure any previous commands completed, and check for errors.
@@ -279,9 +277,9 @@ int
 ncr_read_nolock(unsigned long region, unsigned long address, int number,
 	void *buffer)
 {
-	command_data_register_0_t cdr0;
-	command_data_register_1_t cdr1;
-	command_data_register_2_t cdr2;
+	union command_data_register_0 cdr0;
+	union command_data_register_1 cdr1;
+	union command_data_register_2 cdr2;
 
 	if ((NCP_NODE_ID(region) != 0x0153) && (NCP_NODE_ID(region) != 0x115)) {
 		/* make sure any previous command has completed */
@@ -453,9 +451,9 @@ int
 ncr_write_nolock(unsigned long region, unsigned long address, int number,
 		 void *buffer)
 {
-	command_data_register_0_t cdr0;
-	command_data_register_1_t cdr1;
-	command_data_register_2_t cdr2;
+	union command_data_register_0 cdr0;
+	union command_data_register_1 cdr1;
+	union command_data_register_2 cdr2;
 	unsigned long data_word_base;
 	int dbs = (number - 1);
 
-- 
1.7.5.4

