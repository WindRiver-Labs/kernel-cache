From c8f58e1b41fa04c9b93fb6b17672027ff8178c98 Mon Sep 17 00:00:00 2001
From: David Mercado <david.mercado@windriver.com>
Date: Wed, 23 Oct 2013 16:27:49 -0400
Subject: [PATCH 058/159] SPI: pl022: Update driver to support of-platform
 drivers

git.yoctoproject.org/git/linux-yocto-3.10
commit 7d4b18ba687b7f22569b415796aaed18aa8b5f85 standard/axxia/base.

Since the PPC LSI ACP34xx board implements a pl022 spi controller,
update driver register interface to support ppc of-platform style
driver register interface.

The patch abstracts the common code of probe, remove & PM routines
between ARM_AMBA style driver and of-platform driver, then forks
a new driver for ppc of-platform. This patch also adds support for
SPI at25 eeprom.

The OF style driver extract device information from device-tree, including
"cell-index", "num-ss-bits", "enalbe-dma", io address & irq.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/spi/Kconfig     |    2 +-
 drivers/spi/spi-pl022.c |  511 ++++++++++++++++++++++++++++++++++++++---------
 2 files changed, 422 insertions(+), 91 deletions(-)

diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 92a9345..027762d 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -299,7 +299,7 @@ config SPI_ORION
 
 config SPI_PL022
 	tristate "ARM AMBA PL022 SSP controller"
-	depends on ARM_AMBA
+	depends on ARM_AMBA || OF_DEVICE
 	default y if MACH_U300
 	default y if ARCH_REALVIEW
 	default y if INTEGRATOR_IMPD1
diff --git a/drivers/spi/spi-pl022.c b/drivers/spi/spi-pl022.c
index 371cc66f..90ca19d 100644
--- a/drivers/spi/spi-pl022.c
+++ b/drivers/spi/spi-pl022.c
@@ -32,7 +32,13 @@
 #include <linux/delay.h>
 #include <linux/clk.h>
 #include <linux/err.h>
+#ifdef CONFIG_ARM_AMBA
 #include <linux/amba/bus.h>
+#else
+#include <linux/of_platform.h>
+#include <linux/of.h>
+#include <linux/spi/eeprom.h>
+#endif
 #include <linux/amba/pl022.h>
 #include <linux/io.h>
 #include <linux/slab.h>
@@ -44,13 +50,18 @@
 #include <linux/of_gpio.h>
 #include <linux/pinctrl/consumer.h>
 
+#ifndef CONFIG_ARM_AMBA
+#define writew(b, addr) writel(b, addr)
+#define readw(addr) readl(addr)
+#endif
+
 /*
  * This macro is used to define some register default values.
  * reg is masked with mask, the OR:ed with an (again masked)
  * val shifted sb steps to the left.
  */
 #define SSP_WRITE_BITS(reg, val, mask, sb) \
- ((reg) = (((reg) & ~(mask)) | (((val)<<(sb)) & (mask))))
+	((reg) = (((reg) & ~(mask)) | (((val)<<(sb)) & (mask))))
 
 /*
  * This macro is also used to define some default values.
@@ -58,7 +69,7 @@
  * the result with mask.
  */
 #define GEN_MASK_BITS(val, mask, sb) \
- (((val)<<(sb)) & (mask))
+	(((val)<<(sb)) & (mask))
 
 #define DRIVE_TX		0
 #define DO_NOT_DRIVE_TX		1
@@ -82,6 +93,7 @@
 #define SSP_MIS(r)	(r + 0x01C)
 #define SSP_ICR(r)	(r + 0x020)
 #define SSP_DMACR(r)	(r + 0x024)
+#define SSP_CSR(r)	(r + 0x030)
 #define SSP_ITCR(r)	(r + 0x080)
 #define SSP_ITIP(r)	(r + 0x084)
 #define SSP_ITOP(r)	(r + 0x088)
@@ -325,7 +337,7 @@ struct vendor_data {
 
 /**
  * struct pl022 - This is the private SSP driver data structure
- * @adev: AMBA device model hookup
+ * @dev: AMBA device model hookup
  * @vendor: vendor data for the IP block
  * @phybase: the physical memory where the SSP device resides
  * @virtbase: the virtual memory where the SSP is mapped
@@ -363,7 +375,11 @@ struct vendor_data {
  * @chipselects: list of chipselects (gpios)
  */
 struct pl022 {
-	struct amba_device		*adev;
+#ifdef CONFIG_ARM_AMBA
+	struct amba_device		*dev;
+#else
+	struct platform_device          *dev;
+#endif
 	struct vendor_data		*vendor;
 	resource_size_t			phybase;
 	void __iomem			*virtbase;
@@ -524,7 +540,7 @@ static int flush(struct pl022 *pl022)
 {
 	unsigned long limit = loops_per_jiffy << 1;
 
-	dev_dbg(&pl022->adev->dev, "flush\n");
+	dev_dbg(&pl022->dev->dev, "flush\n");
 	do {
 		while (readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)
 			readw(SSP_DR(pl022->virtbase));
@@ -664,7 +680,7 @@ static void readwriter(struct pl022 *pl022)
 	 * unused RX FIFO fill length, regardless of what the TX
 	 * FIFO status flag indicates.
 	 */
-	dev_dbg(&pl022->adev->dev,
+	dev_dbg(&pl022->dev->dev,
 		"%s, rx: %p, rxend: %p, tx: %p, txend: %p\n",
 		__func__, pl022->rx, pl022->rx_end, pl022->tx, pl022->tx_end);
 
@@ -805,13 +821,13 @@ static void dma_callback(void *data)
 		struct scatterlist *sg;
 		unsigned int i;
 
-		dma_sync_sg_for_cpu(&pl022->adev->dev,
+		dma_sync_sg_for_cpu(&pl022->dev->dev,
 				    pl022->sgt_rx.sgl,
 				    pl022->sgt_rx.nents,
 				    DMA_FROM_DEVICE);
 
 		for_each_sg(pl022->sgt_rx.sgl, sg, pl022->sgt_rx.nents, i) {
-			dev_dbg(&pl022->adev->dev, "SPI RX SG ENTRY: %d", i);
+			dev_dbg(&pl022->dev->dev, "SPI RX SG ENTRY: %d", i);
 			print_hex_dump(KERN_ERR, "SPI RX: ",
 				       DUMP_PREFIX_OFFSET,
 				       16,
@@ -821,7 +837,7 @@ static void dma_callback(void *data)
 				       1);
 		}
 		for_each_sg(pl022->sgt_tx.sgl, sg, pl022->sgt_tx.nents, i) {
-			dev_dbg(&pl022->adev->dev, "SPI TX SG ENTRY: %d", i);
+			dev_dbg(&pl022->dev->dev, "SPI TX SG ENTRY: %d", i);
 			print_hex_dump(KERN_ERR, "SPI TX: ",
 				       DUMP_PREFIX_OFFSET,
 				       16,
@@ -872,7 +888,7 @@ static void setup_dma_scatter(struct pl022 *pl022,
 				    mapbytes, offset_in_page(bufp));
 			bufp += mapbytes;
 			bytesleft -= mapbytes;
-			dev_dbg(&pl022->adev->dev,
+			dev_dbg(&pl022->dev->dev,
 				"set RX/TX target page @ %p, %d bytes, %d left\n",
 				bufp, mapbytes, bytesleft);
 		}
@@ -886,7 +902,7 @@ static void setup_dma_scatter(struct pl022 *pl022,
 			sg_set_page(sg, virt_to_page(pl022->dummypage),
 				    mapbytes, 0);
 			bytesleft -= mapbytes;
-			dev_dbg(&pl022->adev->dev,
+			dev_dbg(&pl022->dev->dev,
 				"set RX/TX to dummy page %d bytes, %d left\n",
 				mapbytes, bytesleft);
 
@@ -1015,7 +1031,7 @@ static int configure_dma(struct pl022 *pl022)
 
 	/* Create sglists for the transfers */
 	pages = DIV_ROUND_UP(pl022->cur_transfer->len, PAGE_SIZE);
-	dev_dbg(&pl022->adev->dev, "using %d pages for transfer\n", pages);
+	dev_dbg(&pl022->dev->dev, "using %d pages for transfer\n", pages);
 
 	ret = sg_alloc_table(&pl022->sgt_rx, pages, GFP_ATOMIC);
 	if (ret)
@@ -1104,7 +1120,7 @@ static int pl022_dma_probe(struct pl022 *pl022)
 					    pl022->master_info->dma_filter,
 					    pl022->master_info->dma_rx_param);
 	if (!pl022->dma_rx_channel) {
-		dev_dbg(&pl022->adev->dev, "no RX DMA channel!\n");
+		dev_dbg(&pl022->dev->dev, "no RX DMA channel!\n");
 		goto err_no_rxchan;
 	}
 
@@ -1112,17 +1128,17 @@ static int pl022_dma_probe(struct pl022 *pl022)
 					    pl022->master_info->dma_filter,
 					    pl022->master_info->dma_tx_param);
 	if (!pl022->dma_tx_channel) {
-		dev_dbg(&pl022->adev->dev, "no TX DMA channel!\n");
+		dev_dbg(&pl022->dev->dev, "no TX DMA channel!\n");
 		goto err_no_txchan;
 	}
 
 	pl022->dummypage = kmalloc(PAGE_SIZE, GFP_KERNEL);
 	if (!pl022->dummypage) {
-		dev_dbg(&pl022->adev->dev, "no DMA dummypage!\n");
+		dev_dbg(&pl022->dev->dev, "no DMA dummypage!\n");
 		goto err_no_dummypage;
 	}
 
-	dev_info(&pl022->adev->dev, "setup for DMA on RX %s, TX %s\n",
+	dev_info(&pl022->dev->dev, "setup for DMA on RX %s, TX %s\n",
 		 dma_chan_name(pl022->dma_rx_channel),
 		 dma_chan_name(pl022->dma_tx_channel));
 
@@ -1134,16 +1150,20 @@ err_no_txchan:
 	dma_release_channel(pl022->dma_rx_channel);
 	pl022->dma_rx_channel = NULL;
 err_no_rxchan:
-	dev_err(&pl022->adev->dev,
+	dev_err(&pl022->dev->dev,
 			"Failed to work in dma mode, work without dma!\n");
 	return -ENODEV;
 }
 
+#ifdef CONFIG_ARM_AMBA
 static int pl022_dma_autoprobe(struct pl022 *pl022)
 {
 	struct device *dev = &pl022->adev->dev;
 
-	/* automatically configure DMA channels from platform, normally using DT */
+	/*
+	 * automatically configure DMA channels from platform,
+	 * normally using DT
+	 */
 	pl022->dma_rx_channel = dma_request_slave_channel(dev, "rx");
 	if (!pl022->dma_rx_channel)
 		goto err_no_rxchan;
@@ -1167,7 +1187,8 @@ err_no_txchan:
 err_no_rxchan:
 	return -ENODEV;
 }
-		
+#endif
+
 static void terminate_dma(struct pl022 *pl022)
 {
 	struct dma_chan *rxchan = pl022->dma_rx_channel;
@@ -1196,10 +1217,12 @@ static inline int configure_dma(struct pl022 *pl022)
 	return -ENODEV;
 }
 
+#ifdef CONFIG_ARM_AMBA
 static inline int pl022_dma_autoprobe(struct pl022 *pl022)
 {
 	return 0;
 }
+#endif
 
 static inline int pl022_dma_probe(struct pl022 *pl022)
 {
@@ -1230,7 +1253,7 @@ static irqreturn_t pl022_interrupt_handler(int irq, void *dev_id)
 	u16 flag = 0;
 
 	if (unlikely(!msg)) {
-		dev_err(&pl022->adev->dev,
+		dev_err(&pl022->dev->dev,
 			"bad message state in interrupt handler");
 		/* Never fail */
 		return IRQ_HANDLED;
@@ -1252,12 +1275,12 @@ static irqreturn_t pl022_interrupt_handler(int irq, void *dev_id)
 		 * Overrun interrupt - bail out since our Data has been
 		 * corrupted
 		 */
-		dev_err(&pl022->adev->dev, "FIFO overrun\n");
+		dev_err(&pl022->dev->dev, "FIFO overrun\n");
 		if (readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RFF)
-			dev_err(&pl022->adev->dev,
+			dev_err(&pl022->dev->dev,
 				"RXFIFO is full\n");
 		if (readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_TNF)
-			dev_err(&pl022->adev->dev,
+			dev_err(&pl022->dev->dev,
 				"TXFIFO is full\n");
 
 		/*
@@ -1297,7 +1320,7 @@ static irqreturn_t pl022_interrupt_handler(int irq, void *dev_id)
 		       SSP_IMSC(pl022->virtbase));
 		writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));
 		if (unlikely(pl022->rx > pl022->rx_end)) {
-			dev_warn(&pl022->adev->dev, "read %u surplus "
+			dev_warn(&pl022->dev->dev, "read %u surplus "
 				 "bytes (did you request an odd "
 				 "number of bytes on a 16bit bus?)\n",
 				 (u32) (pl022->rx - pl022->rx_end));
@@ -1327,12 +1350,12 @@ static int set_up_next_transfer(struct pl022 *pl022,
 	/* Sanity check the message for this bus width */
 	residue = pl022->cur_transfer->len % pl022->cur_chip->n_bytes;
 	if (unlikely(residue != 0)) {
-		dev_err(&pl022->adev->dev,
+		dev_err(&pl022->dev->dev,
 			"message of %u bytes to transmit but the current "
 			"chip bus has a data width of %u bytes!\n",
 			pl022->cur_transfer->len,
 			pl022->cur_chip->n_bytes);
-		dev_err(&pl022->adev->dev, "skipping this message\n");
+		dev_err(&pl022->dev->dev, "skipping this message\n");
 		return -EIO;
 	}
 	pl022->tx = (void *)transfer->tx_buf;
@@ -1407,7 +1430,7 @@ static void pump_transfers(unsigned long data)
 
 	if (pl022->cur_chip->enable_dma) {
 		if (configure_dma(pl022)) {
-			dev_dbg(&pl022->adev->dev,
+			dev_dbg(&pl022->dev->dev,
 				"configuration of DMA failed, fall back to interrupt mode\n");
 			goto err_config_dma;
 		}
@@ -1442,7 +1465,7 @@ static void do_interrupt_dma_transfer(struct pl022 *pl022)
 	if (pl022->cur_chip->enable_dma) {
 		/* Configure DMA transfer */
 		if (configure_dma(pl022)) {
-			dev_dbg(&pl022->adev->dev,
+			dev_dbg(&pl022->dev->dev,
 				"configuration of DMA failed, fall back to interrupt mode\n");
 			goto err_config_dma;
 		}
@@ -1500,14 +1523,14 @@ static void do_polling_transfer(struct pl022 *pl022)
 		writew((readw(SSP_CR1(pl022->virtbase)) | SSP_CR1_MASK_SSE),
 		       SSP_CR1(pl022->virtbase));
 
-		dev_dbg(&pl022->adev->dev, "polling transfer ongoing ...\n");
+		dev_dbg(&pl022->dev->dev, "polling transfer ongoing ...\n");
 
 		timeout = jiffies + msecs_to_jiffies(SPI_POLLING_TIMEOUT);
 		while (pl022->tx < pl022->tx_end || pl022->rx < pl022->rx_end) {
 			time = jiffies;
 			readwriter(pl022);
 			if (time_after(time, timeout)) {
-				dev_warn(&pl022->adev->dev,
+				dev_warn(&pl022->dev->dev,
 				"%s: timeout!\n", __func__);
 				message->state = STATE_ERROR;
 				goto out;
@@ -1568,7 +1591,7 @@ static int pl022_prepare_transfer_hardware(struct spi_master *master)
 	 * Just make sure we have all we need to run the transfer by syncing
 	 * with the runtime PM framework.
 	 */
-	pm_runtime_get_sync(&pl022->adev->dev);
+	pm_runtime_get_sync(&pl022->dev->dev);
 	return 0;
 }
 
@@ -1581,10 +1604,10 @@ static int pl022_unprepare_transfer_hardware(struct spi_master *master)
 		(~SSP_CR1_MASK_SSE)), SSP_CR1(pl022->virtbase));
 
 	if (pl022->master_info->autosuspend_delay > 0) {
-		pm_runtime_mark_last_busy(&pl022->adev->dev);
-		pm_runtime_put_autosuspend(&pl022->adev->dev);
+		pm_runtime_mark_last_busy(&pl022->dev->dev);
+		pm_runtime_put_autosuspend(&pl022->dev->dev);
 	} else {
-		pm_runtime_put(&pl022->adev->dev);
+		pm_runtime_put(&pl022->dev->dev);
 	}
 
 	return 0;
@@ -1595,27 +1618,27 @@ static int verify_controller_parameters(struct pl022 *pl022,
 {
 	if ((chip_info->iface < SSP_INTERFACE_MOTOROLA_SPI)
 	    || (chip_info->iface > SSP_INTERFACE_UNIDIRECTIONAL)) {
-		dev_err(&pl022->adev->dev,
+		dev_err(&pl022->dev->dev,
 			"interface is configured incorrectly\n");
 		return -EINVAL;
 	}
 	if ((chip_info->iface == SSP_INTERFACE_UNIDIRECTIONAL) &&
 	    (!pl022->vendor->unidir)) {
-		dev_err(&pl022->adev->dev,
+		dev_err(&pl022->dev->dev,
 			"unidirectional mode not supported in this "
 			"hardware version\n");
 		return -EINVAL;
 	}
 	if ((chip_info->hierarchy != SSP_MASTER)
 	    && (chip_info->hierarchy != SSP_SLAVE)) {
-		dev_err(&pl022->adev->dev,
+		dev_err(&pl022->dev->dev,
 			"hierarchy is configured incorrectly\n");
 		return -EINVAL;
 	}
 	if ((chip_info->com_mode != INTERRUPT_TRANSFER)
 	    && (chip_info->com_mode != DMA_TRANSFER)
 	    && (chip_info->com_mode != POLLING_TRANSFER)) {
-		dev_err(&pl022->adev->dev,
+		dev_err(&pl022->dev->dev,
 			"Communication mode is configured incorrectly\n");
 		return -EINVAL;
 	}
@@ -1627,20 +1650,20 @@ static int verify_controller_parameters(struct pl022 *pl022,
 		break;
 	case SSP_RX_16_OR_MORE_ELEM:
 		if (pl022->vendor->fifodepth < 16) {
-			dev_err(&pl022->adev->dev,
+			dev_err(&pl022->dev->dev,
 			"RX FIFO Trigger Level is configured incorrectly\n");
 			return -EINVAL;
 		}
 		break;
 	case SSP_RX_32_OR_MORE_ELEM:
 		if (pl022->vendor->fifodepth < 32) {
-			dev_err(&pl022->adev->dev,
+			dev_err(&pl022->dev->dev,
 			"RX FIFO Trigger Level is configured incorrectly\n");
 			return -EINVAL;
 		}
 		break;
 	default:
-		dev_err(&pl022->adev->dev,
+		dev_err(&pl022->dev->dev,
 			"RX FIFO Trigger Level is configured incorrectly\n");
 		return -EINVAL;
 		break;
@@ -1653,20 +1676,20 @@ static int verify_controller_parameters(struct pl022 *pl022,
 		break;
 	case SSP_TX_16_OR_MORE_EMPTY_LOC:
 		if (pl022->vendor->fifodepth < 16) {
-			dev_err(&pl022->adev->dev,
+			dev_err(&pl022->dev->dev,
 			"TX FIFO Trigger Level is configured incorrectly\n");
 			return -EINVAL;
 		}
 		break;
 	case SSP_TX_32_OR_MORE_EMPTY_LOC:
 		if (pl022->vendor->fifodepth < 32) {
-			dev_err(&pl022->adev->dev,
+			dev_err(&pl022->dev->dev,
 			"TX FIFO Trigger Level is configured incorrectly\n");
 			return -EINVAL;
 		}
 		break;
 	default:
-		dev_err(&pl022->adev->dev,
+		dev_err(&pl022->dev->dev,
 			"TX FIFO Trigger Level is configured incorrectly\n");
 		return -EINVAL;
 		break;
@@ -1674,13 +1697,13 @@ static int verify_controller_parameters(struct pl022 *pl022,
 	if (chip_info->iface == SSP_INTERFACE_NATIONAL_MICROWIRE) {
 		if ((chip_info->ctrl_len < SSP_BITS_4)
 		    || (chip_info->ctrl_len > SSP_BITS_32)) {
-			dev_err(&pl022->adev->dev,
+			dev_err(&pl022->dev->dev,
 				"CTRL LEN is configured incorrectly\n");
 			return -EINVAL;
 		}
 		if ((chip_info->wait_state != SSP_MWIRE_WAIT_ZERO)
 		    && (chip_info->wait_state != SSP_MWIRE_WAIT_ONE)) {
-			dev_err(&pl022->adev->dev,
+			dev_err(&pl022->dev->dev,
 				"Wait State is configured incorrectly\n");
 			return -EINVAL;
 		}
@@ -1690,13 +1713,13 @@ static int verify_controller_parameters(struct pl022 *pl022,
 			     SSP_MICROWIRE_CHANNEL_FULL_DUPLEX)
 			    && (chip_info->duplex !=
 				SSP_MICROWIRE_CHANNEL_HALF_DUPLEX)) {
-				dev_err(&pl022->adev->dev,
+				dev_err(&pl022->dev->dev,
 					"Microwire duplex mode is configured incorrectly\n");
 				return -EINVAL;
 			}
 		} else {
 			if (chip_info->duplex != SSP_MICROWIRE_CHANNEL_FULL_DUPLEX)
-				dev_err(&pl022->adev->dev,
+				dev_err(&pl022->dev->dev,
 					"Microwire half duplex mode requested,"
 					" but this is only available in the"
 					" ST version of PL022\n");
@@ -1726,12 +1749,12 @@ static int calculate_effective_freq(struct pl022 *pl022, int freq, struct
 	min_tclk = spi_rate(rate, CPSDVR_MAX, SCR_MAX);
 
 	if (freq > max_tclk)
-		dev_warn(&pl022->adev->dev,
+		dev_warn(&pl022->dev->dev,
 			"Max speed that can be programmed is %d Hz, you requested %d\n",
 			max_tclk, freq);
 
 	if (freq < min_tclk) {
-		dev_err(&pl022->adev->dev,
+		dev_err(&pl022->dev->dev,
 			"Requested frequency: %d Hz is less than minimum possible %d Hz\n",
 			freq, min_tclk);
 		return -EINVAL;
@@ -1778,10 +1801,10 @@ static int calculate_effective_freq(struct pl022 *pl022, int freq, struct
 
 	clk_freq->cpsdvsr = (u8) (best_cpsdvsr & 0xFF);
 	clk_freq->scr = (u8) (best_scr & 0xFF);
-	dev_dbg(&pl022->adev->dev,
+	dev_dbg(&pl022->dev->dev,
 		"SSP Target Frequency is: %u, Effective Frequency is %u\n",
 		freq, best_freq);
-	dev_dbg(&pl022->adev->dev, "SSP cpsdvsr = %d, scr = %d\n",
+	dev_dbg(&pl022->dev->dev, "SSP cpsdvsr = %d, scr = %d\n",
 		clk_freq->cpsdvsr, clk_freq->scr);
 
 	return 0;
@@ -2064,6 +2087,7 @@ static void pl022_cleanup(struct spi_device *spi)
 	kfree(chip);
 }
 
+#ifdef CONFIG_ARM_AMBA
 static struct pl022_ssp_controller *
 pl022_platform_data_dt_get(struct device *dev)
 {
@@ -2091,20 +2115,24 @@ pl022_platform_data_dt_get(struct device *dev)
 
 	return pd;
 }
+#endif
 
-static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
+static int pl022_probe(
+	struct device *dev,
+	struct vendor_data *vendor,
+	struct resource *res,
+	int irq, struct pl022 **retpl022)
 {
-	struct device *dev = &adev->dev;
-	struct pl022_ssp_controller *platform_info = adev->dev.platform_data;
+	struct pl022_ssp_controller *platform_info = dev->platform_data;
 	struct spi_master *master;
-	struct pl022 *pl022 = NULL;	/*Data for this driver */
-	struct device_node *np = adev->dev.of_node;
+	struct pl022 *pl022 = NULL;	/* Data for this driver */
 	int status = 0, i, num_cs;
+#ifdef CONFIG_ARM_AMBA
+	struct device_node *np = dev->dev.of_node;
 
-	dev_info(&adev->dev,
-		 "ARM PL022 driver, device ID: 0x%08x\n", adev->periphid);
 	if (!platform_info && IS_ENABLED(CONFIG_OF))
 		platform_info = pl022_platform_data_dt_get(dev);
+#endif
 
 	if (!platform_info) {
 		dev_err(dev, "probe: no platform data defined\n");
@@ -2121,18 +2149,18 @@ static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
 	/* Allocate master with space for data */
 	master = spi_alloc_master(dev, sizeof(struct pl022));
 	if (master == NULL) {
-		dev_err(&adev->dev, "probe - cannot alloc SPI master\n");
+		dev_err(dev, "probe - cannot alloc SPI master\n");
 		return -ENOMEM;
 	}
 
 	pl022 = spi_master_get_devdata(master);
 	pl022->master = master;
 	pl022->master_info = platform_info;
-	pl022->adev = adev;
-	pl022->vendor = id->data;
+	pl022->vendor = vendor;
 	pl022->chipselects = devm_kzalloc(dev, num_cs * sizeof(int),
 					  GFP_KERNEL);
 
+#ifdef CONFIG_ARM_AMBA
 	pl022->pinctrl = devm_pinctrl_get(dev);
 	if (IS_ERR(pl022->pinctrl)) {
 		status = PTR_ERR(pl022->pinctrl);
@@ -2159,6 +2187,7 @@ static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
 					       PINCTRL_STATE_SLEEP);
 	if (IS_ERR(pl022->pins_sleep))
 		dev_dbg(dev, "could not get sleep pinstate\n");
+#endif
 
 	/*
 	 * Bus Number Which has been Assigned to this SSP controller
@@ -2172,11 +2201,14 @@ static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
 	master->transfer_one_message = pl022_transfer_one_message;
 	master->unprepare_transfer_hardware = pl022_unprepare_transfer_hardware;
 	master->rt = platform_info->rt;
+#ifdef CONFIG_ARM_AMBA
 	master->dev.of_node = dev->of_node;
+#endif
 
 	if (platform_info->num_chipselect && platform_info->chipselects) {
 		for (i = 0; i < num_cs; i++)
 			pl022->chipselects[i] = platform_info->chipselects[i];
+#ifdef CONFIG_ARM_AMBA
 	} else if (IS_ENABLED(CONFIG_OF)) {
 		for (i = 0; i < num_cs; i++) {
 			int cs_gpio = of_get_named_gpio(np, "cs-gpios", i);
@@ -2199,6 +2231,7 @@ static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
 						cs_gpio);
 			}
 		}
+#endif
 	}
 
 	/*
@@ -2209,38 +2242,37 @@ static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
 	if (pl022->vendor->extended_cr)
 		master->mode_bits |= SPI_LSB_FIRST;
 
-	dev_dbg(&adev->dev, "BUSNO: %d\n", master->bus_num);
+	dev_dbg(dev, "BUSNO: %d\n", master->bus_num);
 
-	status = amba_request_regions(adev, NULL);
-	if (status)
+	if (!request_mem_region(res->start, resource_size(res),
+			dev->driver->name))
 		goto err_no_ioregion;
 
-	pl022->phybase = adev->res.start;
-	pl022->virtbase = devm_ioremap(dev, adev->res.start,
-				       resource_size(&adev->res));
+	pl022->phybase = dev->res.start;
+	pl022->virtbase = ioremap(res->start, resource_size(res));
 	if (pl022->virtbase == NULL) {
 		status = -ENOMEM;
 		goto err_no_ioremap;
 	}
-	printk(KERN_INFO "pl022: mapped registers from 0x%08x to %p\n",
-	       adev->res.start, pl022->virtbase);
+	pr_info("pl022: mapped registers from 0x%08x to %p\n",
+		res->start, pl022->virtbase);
 
-	pl022->clk = devm_clk_get(&adev->dev, NULL);
+	pl022->clk = clk_get(dev, NULL);
 	if (IS_ERR(pl022->clk)) {
 		status = PTR_ERR(pl022->clk);
-		dev_err(&adev->dev, "could not retrieve SSP/SPI bus clock\n");
+		dev_err(dev, "could not retrieve SSP/SPI bus clock\n");
 		goto err_no_clk;
 	}
 
 	status = clk_prepare(pl022->clk);
 	if (status) {
-		dev_err(&adev->dev, "could not prepare SSP/SPI bus clock\n");
+		dev_err(dev, "could not prepare SSP/SPI bus clock\n");
 		goto  err_clk_prep;
 	}
 
 	status = clk_enable(pl022->clk);
 	if (status) {
-		dev_err(&adev->dev, "could not enable SSP/SPI bus clock\n");
+		dev_err(dev, "could not enable SSP/SPI bus clock\n");
 		goto err_no_clk_en;
 	}
 
@@ -2253,13 +2285,14 @@ static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
 	       SSP_CR1(pl022->virtbase));
 	load_ssp_default_config(pl022);
 
-	status = devm_request_irq(dev, adev->irq[0], pl022_interrupt_handler,
+	status = devm_request_irq(dev, irq, pl022_interrupt_handler,
 				  0, "pl022", pl022);
 	if (status < 0) {
-		dev_err(&adev->dev, "probe - cannot get IRQ (%d)\n", status);
+		dev_err(dev, "probe - cannot get IRQ (%d)\n", status);
 		goto err_no_irq;
 	}
 
+#ifdef CONFIG_ARM_AMBA
 	/* Get DMA channels, try autoconfiguration first */
 	status = pl022_dma_autoprobe(pl022);
 
@@ -2267,24 +2300,30 @@ static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
 	if (status == 0)
 		platform_info->enable_dma = 1;
 	else if (platform_info->enable_dma) {
+#else
+	if (platform_info->enable_dma) {
+#endif
 		status = pl022_dma_probe(pl022);
 		if (status != 0)
 			platform_info->enable_dma = 0;
 	}
 
 	/* Register with the SPI framework */
-	amba_set_drvdata(adev, pl022);
+	dev_set_drvdata(dev, pl022);
 	status = spi_register_master(master);
 	if (status != 0) {
-		dev_err(&adev->dev,
+		dev_err(dev,
 			"probe - problem registering spi master\n");
 		goto err_spi_register;
 	}
 	dev_dbg(dev, "probe succeeded\n");
 
+	if (retpl022)
+		*retpl022 = pl022;
+
 	/* let runtime pm put suspend */
 	if (platform_info->autosuspend_delay > 0) {
-		dev_info(&adev->dev,
+		dev_info(dev,
 			"will use autosuspend for runtime pm, delay %dms\n",
 			platform_info->autosuspend_delay);
 		pm_runtime_set_autosuspend_delay(dev,
@@ -2305,7 +2344,7 @@ static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
  err_clk_prep:
  err_no_clk:
  err_no_ioremap:
-	amba_release_regions(adev);
+	release_mem_region(res->start, resource_size(res));
  err_no_ioregion:
  err_no_gpio:
  err_no_pinctrl:
@@ -2314,9 +2353,9 @@ static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
 }
 
 static int
-pl022_remove(struct amba_device *adev)
+pl022_remove(struct device *dev, struct resource *res, int irq)
 {
-	struct pl022 *pl022 = amba_get_drvdata(adev);
+	struct pl022 *pl022 = dev_get_drvdata(dev);
 
 	if (!pl022)
 		return 0;
@@ -2325,7 +2364,7 @@ pl022_remove(struct amba_device *adev)
 	 * undo pm_runtime_put() in probe.  I assume that we're not
 	 * accessing the primecell here.
 	 */
-	pm_runtime_get_noresume(&adev->dev);
+	pm_runtime_get_noresume(&dev->dev);
 
 	load_ssp_default_config(pl022);
 	if (pl022->master_info->enable_dma)
@@ -2333,10 +2372,10 @@ pl022_remove(struct amba_device *adev)
 
 	clk_disable(pl022->clk);
 	clk_unprepare(pl022->clk);
-	amba_release_regions(adev);
+	release_mem_region(res->start, resource_size(res));
 	tasklet_disable(&pl022->pump_transfers);
 	spi_unregister_master(pl022->master);
-	amba_set_drvdata(adev, NULL);
+	dev_set_drvdata(dev, NULL);
 	return 0;
 }
 
@@ -2358,7 +2397,7 @@ static void pl022_suspend_resources(struct pl022 *pl022, bool runtime)
 	if (!IS_ERR(pins_state)) {
 		ret = pinctrl_select_state(pl022->pinctrl, pins_state);
 		if (ret)
-			dev_err(&pl022->adev->dev, "could not set %s pins\n",
+			dev_err(&pl022->dev->dev, "could not set %s pins\n",
 				runtime ? "idle" : "sleep");
 	}
 }
@@ -2372,7 +2411,7 @@ static void pl022_resume_resources(struct pl022 *pl022, bool runtime)
 	if (!IS_ERR(pl022->pins_default)) {
 		ret = pinctrl_select_state(pl022->pinctrl, pl022->pins_default);
 		if (ret)
-			dev_err(&pl022->adev->dev,
+			dev_err(&pl022->dev->dev,
 				"could not set default pins\n");
 	}
 
@@ -2382,7 +2421,7 @@ static void pl022_resume_resources(struct pl022 *pl022, bool runtime)
 			ret = pinctrl_select_state(pl022->pinctrl,
 					pl022->pins_idle);
 		if (ret)
-			dev_err(&pl022->adev->dev,
+			dev_err(&pl022->dev->dev,
 				"could not set idle pins\n");
 		}
 	}
@@ -2461,6 +2500,7 @@ static struct vendor_data vendor_arm = {
 	.loopback = true,
 };
 
+#ifdef CONFIG_ARM_AMBA
 static struct vendor_data vendor_st = {
 	.fifodepth = 32,
 	.max_bpw = 32,
@@ -2479,6 +2519,27 @@ static struct vendor_data vendor_st_pl023 = {
 	.loopback = false,
 };
 
+static int
+pl022_amba_probe(struct amba_device *adev, struct amba_id *id)
+{
+	struct pl022 *pl022 = NULL;
+	int ret;
+	dev_info(&adev->dev,
+		"ARM PL022 driver, device ID: 0x%08x\n", adev->periphid);
+	ret = pl022_probe(&adev->dev, id->data,
+		&adev->res, adev->irq[0], &pl022);
+
+	if (ret < 0)
+		return ret;
+	pl022->dev = adev;
+	return 0;
+}
+
+pl022_amba_remove(struct amba_device *adev)
+{
+	return  pl022_remove(&adev->dev, &adev->res, adev->irq[0]);
+}
+
 static struct amba_id pl022_ids[] = {
 	{
 		/*
@@ -2521,19 +2582,289 @@ static struct amba_driver pl022_driver = {
 		.pm	= &pl022_dev_pm_ops,
 	},
 	.id_table	= pl022_ids,
-	.probe		= pl022_probe,
-	.remove		= pl022_remove,
+	.probe		= pl022_amba_probe,
+	.remove		= pl022_amba_remove,
+};
+#else
+static void __iomem *pl022_virtbase;
+static void __acp_spi_cs_control(u32 control, int cs)
+{
+	if (control == SSP_CHIP_SELECT)
+		writel(
+			readl(SSP_CSR(pl022_virtbase)) &
+				~(1 << cs),
+			SSP_CSR(pl022_virtbase));
+	else if (control == SSP_CHIP_DESELECT)
+		writel(
+			readl(SSP_CSR(pl022_virtbase)) |
+				(1 << cs),
+			SSP_CSR(pl022_virtbase));
+}
+
+#define DECLARE_PL022_CS_FUN(x) \
+static void __acp_spi_cs_control_##x(u32 control) \
+{ \
+	__acp_spi_cs_control(control, x); \
+}
+
+DECLARE_PL022_CS_FUN(0);
+DECLARE_PL022_CS_FUN(1);
+DECLARE_PL022_CS_FUN(2);
+DECLARE_PL022_CS_FUN(3);
+DECLARE_PL022_CS_FUN(4);
+DECLARE_PL022_CS_FUN(5);
+DECLARE_PL022_CS_FUN(6);
+DECLARE_PL022_CS_FUN(7);
+
+static void (*acp_cs_control[])(u32) = {
+	__acp_spi_cs_control_0,
+	__acp_spi_cs_control_1,
+	__acp_spi_cs_control_2,
+	__acp_spi_cs_control_3,
+	__acp_spi_cs_control_4,
+	__acp_spi_cs_control_5,
+	__acp_spi_cs_control_6,
+	__acp_spi_cs_control_7,
+};
+
+struct pl022_config_chip eeprom_chip_info = {
+	.iface = SSP_INTERFACE_MOTOROLA_SPI,
+	.hierarchy = SSP_MASTER,
+	.clk_freq = {
+		.cpsdvsr = 0x2,
+		.scr = 0x31,
+	},
+	.com_mode = INTERRUPT_TRANSFER,
+	.rx_lev_trig = SSP_RX_1_OR_MORE_ELEM,
+	.tx_lev_trig = SSP_TX_1_OR_MORE_EMPTY_LOC,
+	.ctrl_len = SSP_BITS_8,
+	.wait_state = SSP_MWIRE_WAIT_ZERO,
+	.duplex = SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
+};
+
+struct spi_eeprom eeprom_chip = {
+	.flags = EE_ADDR3 | EE_READONLY,
+	.byte_len = 128*1024,
+};
+
+static void register_spi_device(struct pl022 *pl022)
+{
+	struct spi_device *spi;
+	struct device_node *nc;
+	const __be32 *prop;
+	int rc;
+	int len;
+	struct spi_master *master = pl022->master;
+
+	int is_at25;
+
+	/* Save pl022 io base for cs functions */
+	pl022_virtbase = pl022->virtbase;
+	for_each_child_of_node(pl022->dev->dev.of_node, nc) {
+		/* Alloc an spi_device */
+		spi = spi_alloc_device(pl022->master);
+		if (!spi) {
+			dev_err(&master->dev, "spi_device alloc error for %s\n",
+				nc->full_name);
+			spi_dev_put(spi);
+			continue;
+		}
+		/* Select device driver */
+		is_at25 = 0;
+		if (of_device_is_compatible(nc, "at25")) {
+			sprintf(spi->modalias, "at25");
+			is_at25 = 1;
+		} else if (of_modalias_node(nc, spi->modalias,
+			sizeof(spi->modalias)) < 0) {
+			dev_err(&master->dev, "cannot find modalias for %s\n",
+				nc->full_name);
+			spi_dev_put(spi);
+			continue;
+		}
+
+		/* Device address */
+		prop = of_get_property(nc, "reg", &len);
+		if (!prop || len < sizeof(*prop)) {
+			dev_err(&master->dev, "%s has no 'reg' property\n",
+				nc->full_name);
+			spi_dev_put(spi);
+			continue;
+		}
+		spi->chip_select = be32_to_cpup(prop);
+		if (spi->chip_select >= master->num_chipselect)	{
+			dev_err(&master->dev, "%s got a wrong cs %d\n",
+				nc->full_name, spi->chip_select);
+			spi_dev_put(spi);
+			continue;
+		}
+
+		/* Mode (clock phase/polarity/etc.) */
+		if (of_find_property(nc, "spi-cpha", NULL))
+			spi->mode |= SPI_CPHA;
+		if (of_find_property(nc, "spi-cpol", NULL))
+			spi->mode |= SPI_CPOL;
+		if (of_find_property(nc, "spi-cs-high", NULL))
+			spi->mode |= SPI_CS_HIGH;
+
+		/* Device speed */
+		prop = of_get_property(nc, "spi-max-frequency", &len);
+		if (!prop || len < sizeof(*prop)) {
+			dev_err(&master->dev, "%s has no 'spi-max-frequency'"
+				" property\n",
+				nc->full_name);
+			spi_dev_put(spi);
+			continue;
+		}
+		spi->max_speed_hz = be32_to_cpup(prop);
+
+		/* IRQ */
+		spi->irq = irq_of_parse_and_map(nc, 0);
+
+		/* Store a pointer to the node in the device structure */
+		of_node_get(nc);
+		spi->dev.of_node = nc;
+
+		if (is_at25) {
+			eeprom_chip_info.cs_control =
+				acp_cs_control[spi->chip_select],
+			spi->controller_data = &eeprom_chip_info;
+			spi->dev.platform_data = &eeprom_chip;
+		}
+
+		/* Register the new device */
+		request_module(spi->modalias);
+		rc = spi_add_device(spi);
+		if (rc) {
+			dev_err(&master->dev, "spi_device register error %s\n",
+				nc->full_name);
+			spi_dev_put(spi);
+		}
+	}
+}
+
+static struct of_device_id pl022_match[];
+
+static int
+pl022_of_probe(struct platform_device *ofdev)
+{
+	struct pl022_ssp_controller *platform_info;
+	int ret = -ENODEV;
+	struct resource r_mem;
+	int irq;
+	struct pl022 *pl022 = NULL;
+	const u32 *prop;
+	int len;
+	struct device_node *of_node = ofdev->dev.of_node;
+	const struct of_device_id *id = of_match_node(pl022_match, of_node);
+	const int *enabled;
+
+	platform_info = kmalloc(sizeof(struct pl022_ssp_controller),
+		GFP_KERNEL);
+	if (!platform_info)
+		return -ENOMEM;
+
+	prop = of_get_property(of_node, "cell-index", &len);
+	if (!prop || len < sizeof(*prop)) {
+		dev_warn(&ofdev->dev, "no 'cell-index' property\n");
+		goto err_data;
+	}
+	platform_info->bus_id = *prop;
+	/* number of slave select bits is required */
+	prop = of_get_property(of_node, "num-ss-bits", &len);
+	if (!prop || len < sizeof(*prop)) {
+		dev_warn(&ofdev->dev, "no 'num-ss-bits' property\n");
+		goto err_data;
+	}
+	platform_info->num_chipselect = *prop;
+	/* number of slave select bits is required */
+	prop = of_get_property(of_node, "enalbe-dma", &len);
+	if (!prop || len < sizeof(*prop))
+		platform_info->enable_dma = 0;
+	platform_info->enable_dma = *prop;
+
+	ofdev->dev.platform_data = platform_info;
+
+	ret = of_address_to_resource(of_node, 0, &r_mem);
+	if (ret) {
+		dev_warn(&ofdev->dev, "invalid address\n");
+		goto err_data;
+	}
+
+	irq = of_irq_to_resource(of_node, 0, NULL);
+
+	ret = pl022_probe(&ofdev->dev, id->data, &r_mem, irq, &pl022);
+
+	if (ret < 0)
+		goto err_data;
+
+	pl022->dev = ofdev;
+	register_spi_device(pl022);
+	return 0;
+err_data:
+	kfree(platform_info);
+	return ret;
+}
+
+static int
+pl022_of_remove(struct platform_device *ofdev)
+{
+	struct resource r_mem;
+	int irq;
+	int ret;
+	struct device_node *of_node = ofdev->dev.of_node;
+
+	of_address_to_resource(of_node, 0, &r_mem);
+
+	irq = of_irq_to_resource(of_node, 0, NULL);
+
+	ret = pl022_remove(&ofdev->dev, &r_mem, irq);
+	if (ret)
+		return ret;
+	kfree(ofdev->dev.platform_data);
+	return 0;
+}
+
+static struct of_device_id pl022_match[] = {
+	{
+		.compatible = "arm,acp-ssp",
+		.data = (void *)&vendor_arm,
+	},
+	{
+		.compatible = "acp-ssp",
+		.data = (void *)&vendor_arm,
+	},
+	{ /* end of list */ },
+};
+
+static struct platform_driver pl022_driver = {
+	.driver = {
+		.name	= "ssp-pl022",
+		.pm	= &pl022_dev_pm_ops,
+		.of_match_table = pl022_match,
+	},
+	.probe = pl022_of_probe,
+	.remove = __exit_p(pl022_of_remove),
 };
+#endif
 
 static int __init pl022_init(void)
 {
+	pr_info("--> %s:%d -\n", __FILE__, __LINE__);
+#ifdef CONFIG_ARM_AMBA
 	return amba_driver_register(&pl022_driver);
+#else
+	return platform_driver_register(&pl022_driver);
+#endif
 }
 subsys_initcall(pl022_init);
 
 static void __exit pl022_exit(void)
 {
+#ifdef CONFIG_ARM_AMBA
 	amba_driver_unregister(&pl022_driver);
+#else
+	platform_driver_unregister(&pl022_driver);
+#endif
 }
 module_exit(pl022_exit);
 
-- 
1.7.5.4

