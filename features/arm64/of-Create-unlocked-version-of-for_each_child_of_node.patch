From 3be600423c66cdfe1a85c4ac5c156a48e7ea52fc Mon Sep 17 00:00:00 2001
From: Grant Likely <grant.likely@linaro.org>
Date: Thu, 22 May 2014 01:04:17 +0900
Subject: [PATCH 266/430] of: Create unlocked version of
 for_each_child_of_node()

When iterating over nodes, sometimes it needs to be done when the DT
lock is already held. This patch makes an unlocked version of the
for_each_child_of_node() macro.

Signed-off-by: Grant Likely <grant.likely@linaro.org>
(cherry picked from commit 0d0e02d605c5696a5076510f564fefe659127aa4)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/of/base.c |   22 +++++++++++++++++-----
 1 files changed, 17 insertions(+), 5 deletions(-)

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 5ca243b..cbb7e4d 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -695,6 +695,22 @@ struct device_node *of_get_next_parent(struct device_node *node)
 }
 EXPORT_SYMBOL(of_get_next_parent);
 
+static struct device_node *__of_get_next_child(const struct device_node *node,
+						struct device_node *prev)
+{
+	struct device_node *next;
+
+	next = prev ? prev->sibling : node->child;
+	for (; next; next = next->sibling)
+		if (of_node_get(next))
+			break;
+	of_node_put(prev);
+	return next;
+}
+#define __for_each_child_of_node(parent, child) \
+	for (child = __of_get_next_child(parent, NULL); child != NULL; \
+	     child = __of_get_next_child(parent, child))
+
 /**
  *	of_get_next_child - Iterate a node childs
  *	@node:	parent node
@@ -710,11 +726,7 @@ struct device_node *of_get_next_child(const struct device_node *node,
 	unsigned long flags;
 
 	raw_spin_lock_irqsave(&devtree_lock, flags);
-	next = prev ? prev->sibling : node->child;
-	for (; next; next = next->sibling)
-		if (of_node_get(next))
-			break;
-	of_node_put(prev);
+	next = __of_get_next_child(node, prev);
 	raw_spin_unlock_irqrestore(&devtree_lock, flags);
 	return next;
 }
-- 
1.7.5.4

