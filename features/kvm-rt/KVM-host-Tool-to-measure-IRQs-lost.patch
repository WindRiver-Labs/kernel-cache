From ad384f547909f6453174634695ea20b2f145fde2 Mon Sep 17 00:00:00 2001
From: Nam Ninh <nam.ninh@windriver.com>
Date: Wed, 13 Nov 2013 15:55:24 -0500
Subject: [PATCH] KVM-host: Tool to measure IRQs lost

This is the host-side of the tool to inject vIRQs to the guest
to measure the percentage of lost interrupts at specified
injection rates. The injection is enabled with inject_virq=1
when kvm module is loaded. Another module parameter scale_factor
controls the injection rate. By default, scale_factor is 4,
meaning the host injects a quarter of maximum rate. The smaller
the scale factor, the faster the injection rate. scale_factor of
1 means maximum injection rate.

Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 473aad4..182d175 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -501,9 +501,11 @@ struct kvm_vcpu_arch {
 		struct gfn_to_hva_cache data;
 	} pv_eoi;
 
-	/* Guest tsc counter before virq is injected into the guest */
 	struct {
+		/* Guest tsc counter before virq is injected into the guest */
 		u64 tsc;
+		/* Current number of vIRQs was injected to the guest */
+		u64 virq_num;
 		struct gfn_to_hva_cache data;
 	} guest_tsc;
 };
diff --git a/arch/x86/include/asm/kvm_para.h b/arch/x86/include/asm/kvm_para.h
index dcd7095..919a560 100644
--- a/arch/x86/include/asm/kvm_para.h
+++ b/arch/x86/include/asm/kvm_para.h
@@ -39,7 +39,7 @@
 #define MSR_KVM_ASYNC_PF_EN 0x4b564d02
 #define MSR_KVM_STEAL_TIME  0x4b564d03
 #define MSR_KVM_PV_EOI_EN      0x4b564d04
-#define MSR_KVM_GUEST_TSC      0x4b564d05
+#define MSR_KVM_VIRQ_DATA_TO_GUEST  0x4b564d05
 
 struct kvm_steal_time {
 	__u64 steal;
diff --git a/arch/x86/kvm/Kconfig b/arch/x86/kvm/Kconfig
index 1494fd7..2d197d9 100644
--- a/arch/x86/kvm/Kconfig
+++ b/arch/x86/kvm/Kconfig
@@ -80,18 +80,36 @@ config KVM_MMU_AUDIT
 	 This option adds a R/W kVM module parameter 'mmu_audit', which allows
 	 audit  KVM MMU at runtime.
 
-config VIRT_INT_LAT_HOST
-	bool "Inject vIRQ to KVM guest"
+menuconfig IRQ_BENCHMARK_HOST
+	bool "IRQs benchmark tool"
 	depends on KVM
 	default n
 	---help---
-	 Enable this option to inject vIRQ to KVM guest for vIRQ latency
+	 Say Y here to see options related to IRQs benchmark.
+	 If you say N, all options in this submenu will be skipped and disabled.
+
+choice
+	prompt "IRQs Latency or lost benchmark"
+	depends on IRQ_BENCHMARK_HOST
+	default VIRT_INT_LAT_HOST
+
+config VIRT_INT_LAT_HOST
+	bool "IRQs latency"
+	---help---
+	 Enable this option to inject IRQs to KVM guest for IRQs latency
 	 measurement on the guest
 
+config VIRT_INT_LOST_HOST
+	bool "IRQs lost"
+	---help---
+	 Enable this option to inject IRQs to KVM guest for IRQs
+	 lost benchmarking.
+endchoice
+
 config VIRT_INT_INJECT_PERIOD
-	int "Frequency to inject vIRQ from host to guest in msec"
+	int "Frequency to inject IRQs from host to guest in msec"
 	depends on VIRT_INT_LAT_HOST
-	default 1000
+	default 10
 
 # OK, it's a little counter-intuitive to do this, but it puts it neatly under
 # the virtualization menu.
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index bf21c30..45091e2 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -101,13 +101,22 @@ EXPORT_SYMBOL_GPL(kvm_max_guest_tsc_khz);
 static u32 tsc_tolerance_ppm = 250;
 module_param(tsc_tolerance_ppm, uint, S_IRUGO | S_IWUSR);
 
-#ifdef CONFIG_VIRT_INT_LAT_HOST
+#ifdef CONFIG_IRQ_BENCHMARK_HOST
 static bool inject_enabled;
 static int auto_inject_virq;
-static unsigned long auto_inject_jiffies;
 module_param(inject_enabled, bool, S_IRUGO | S_IWUSR);
 #endif
 
+#ifdef CONFIG_VIRT_INT_LOST_HOST
+/*
+ * By default, we start injecting a quater of the maximum
+ * injection rate.
+ */
+static unsigned int scale_factor = 4;
+module_param(scale_factor, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(scale_factor, "Scale factor of max irqs inject rate");
+#endif
+
 #define KVM_NR_SHARED_MSRS 16
 
 struct kvm_shared_msrs_global {
@@ -1703,8 +1712,8 @@ int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 		if (kvm_lapic_enable_pv_eoi(vcpu, data))
 			return 1;
 		break;
-#ifdef CONFIG_VIRT_INT_LAT_HOST
-	case MSR_KVM_GUEST_TSC:
+#ifdef CONFIG_IRQ_BENCHMARK_HOST
+	case MSR_KVM_VIRQ_DATA_TO_GUEST:
 		if (kvm_gfn_to_hva_cache_init(vcpu->kvm,
 						&vcpu->arch.guest_tsc.data,
 						data,
@@ -1962,7 +1971,7 @@ int kvm_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)
 	case MSR_K8_INT_PENDING_MSG:
 	case MSR_AMD64_NB_CFG:
 	case MSR_FAM10H_MMIO_CONF_BASE:
-	case MSR_KVM_GUEST_TSC:
+	case MSR_KVM_VIRQ_DATA_TO_GUEST:
 		data = 0;
 		break;
 	case MSR_P6_PERFCTR0:
@@ -2743,7 +2752,7 @@ long kvm_arch_vcpu_ioctl(struct file *filp,
 		break;
 	}
 	case KVM_NMI: {
-#ifdef CONFIG_VIRT_INT_LAT_HOST
+#ifdef CONFIG_IRQ_BENCHMARK_HOST
 		if (inject_enabled) {
 			/* nmi command in qemu monitor enables this parameter */
 			if (auto_inject_virq == 0) {
@@ -5526,6 +5535,12 @@ static int __vcpu_run(struct kvm_vcpu *vcpu)
 {
 	int r;
 	struct kvm *kvm = vcpu->kvm;
+#ifdef CONFIG_VIRT_INT_LOST_HOST
+	static u64 run_enter_cnt;
+#endif
+#ifdef CONFIG_VIRT_INT_LAT_HOST
+	static unsigned long auto_inject_jiffies;
+#endif
 
 	if (unlikely(vcpu->arch.mp_state == KVM_MP_STATE_SIPI_RECEIVED)) {
 		pr_debug("vcpu %d received sipi with vector # %x\n",
@@ -5605,6 +5620,52 @@ static int __vcpu_run(struct kvm_vcpu *vcpu)
 			}
 		}
 #endif
+#ifdef CONFIG_VIRT_INT_LOST_HOST
+		/*
+		 * vCPU0 is pinned to pCPU1.
+		 * vCPU1 is pinned to pCPU2.
+		 * For vIRQs lost benchmark, we only inject vIRQs from
+		 * pCPU1 to vCPU1
+		 */
+		if ((auto_inject_virq) && (smp_processor_id() == 1)) {
+			/* Limit the inject rate based on the scale factor */
+			if ((run_enter_cnt++ % scale_factor))
+				goto out;
+
+			/*
+			 * After the scale factor was sent to the guest
+			 * with the first IRQ, we give it some time to make
+			 * sure the IRQ is not lost. Otherwise, the guest
+			 * never knows the scale factor we start with.
+			 */
+			if (unlikely((vcpu->arch.guest_tsc.virq_num == 1) &&
+				(run_enter_cnt < 10)))
+				goto out;
+
+			if (unlikely(!vcpu->arch.guest_tsc.virq_num)) {
+				vcpu->arch.guest_tsc.virq_num++;
+				/*
+				 * Let the guest know once about the start scale
+				 * factor of the maximum injection rate.
+				 */
+				kvm_write_guest_cached(vcpu->kvm,
+					&vcpu->arch.guest_tsc.data,
+					&scale_factor, sizeof(unsigned int));
+			} else {
+				/* Update the guest with current number of
+				 * injected interrupts.
+				 */
+				vcpu->arch.guest_tsc.virq_num++;
+				kvm_write_guest_cached(vcpu->kvm,
+					&vcpu->arch.guest_tsc.data,
+					&vcpu->arch.guest_tsc.virq_num,
+					sizeof(u64));
+			}
+			/* Inject vIRQ now */
+			kvm_vcpu_ioctl_nmi(vcpu);
+		}
+out:
+#endif
 		kvm_check_async_pf_completion(vcpu);
 
 		if (signal_pending(current)) {
-- 
1.8.4.1

