From 4343802161a06e5a97afeec22d9e7db73c2ddb43 Mon Sep 17 00:00:00 2001
From: Nam Ninh <nam.ninh@windriver.com>
Date: Wed, 13 Nov 2013 15:55:24 -0500
Subject: [PATCH] KVM-host: Tool to measure IRQs lost

This is the host-side of the tool to inject vIRQs to the guest
to measure the percentage of lost interrupts at specified
injection rates. The injection is enabled with inject_virq=1
when kvm module is loaded. Another module parameter scale_factor
controls the injection rate. By default, scale_factor is 4,
meaning the host injects a quarter of maximum rate. The smaller
the scale factor, the faster the injection rate. scale_factor of
1 means maximum injection rate.

Signed-off-by: Nam Ninh <nam.ninh@windriver.com>
---
 arch/x86/include/asm/kvm_host.h |  4 ++-
 arch/x86/include/asm/kvm_para.h |  2 +-
 arch/x86/kvm/Kconfig            | 28 +++++++++++++---
 arch/x86/kvm/x86.c              | 73 +++++++++++++++++++++++++++++++++++++----
 4 files changed, 94 insertions(+), 13 deletions(-)

diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 2ebc9667a9d0..f14df652a871 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -530,9 +530,11 @@ struct kvm_vcpu_arch {
 		bool pv_unhalted;
 	} pv;
 
-	/* Guest tsc counter before virq is injected into the guest */
 	struct {
+		/* Guest tsc counter before virq is injected into the guest */
 		u64 tsc;
+		/* Current number of vIRQs was injected to the guest */
+		u64 virq_num;
 		struct gfn_to_hva_cache data;
 	} guest_tsc;
 };
diff --git a/arch/x86/include/asm/kvm_para.h b/arch/x86/include/asm/kvm_para.h
index 5cdbd4d728d5..314e284e7947 100644
--- a/arch/x86/include/asm/kvm_para.h
+++ b/arch/x86/include/asm/kvm_para.h
@@ -1,6 +1,6 @@
 #ifndef _ASM_X86_KVM_PARA_H
 #define _ASM_X86_KVM_PARA_H
-#define MSR_KVM_GUEST_TSC      0x4b564d05
+#define MSR_KVM_VIRQ_DATA_TO_GUEST  0x4b564d05
 
 #include <asm/processor.h>
 #include <asm/alternative.h>
diff --git a/arch/x86/kvm/Kconfig b/arch/x86/kvm/Kconfig
index 48b13a768741..94e88463ee77 100644
--- a/arch/x86/kvm/Kconfig
+++ b/arch/x86/kvm/Kconfig
@@ -93,18 +93,36 @@ config KVM_DEVICE_ASSIGNMENT
 
 	  If unsure, say Y.
 
-config VIRT_INT_LAT_HOST
-	bool "Inject vIRQ to KVM guest"
+menuconfig IRQ_BENCHMARK_HOST
+	bool "IRQs benchmark tool"
 	depends on KVM
 	default n
 	---help---
-	 Enable this option to inject vIRQ to KVM guest for vIRQ latency
+	 Say Y here to see options related to IRQs benchmark.
+	 If you say N, all options in this submenu will be skipped and disabled.
+
+choice
+	prompt "IRQs Latency or lost benchmark"
+	depends on IRQ_BENCHMARK_HOST
+	default VIRT_INT_LAT_HOST
+
+config VIRT_INT_LAT_HOST
+	bool "IRQs latency"
+	---help---
+	 Enable this option to inject IRQs to KVM guest for IRQs latency
 	 measurement on the guest
 
+config VIRT_INT_LOST_HOST
+	bool "IRQs lost"
+	---help---
+	 Enable this option to inject IRQs to KVM guest for IRQs
+	 lost benchmarking.
+endchoice
+
 config VIRT_INT_INJECT_PERIOD
-	int "Frequency to inject vIRQ from host to guest in msec"
+	int "Frequency to inject IRQs from host to guest in msec"
 	depends on VIRT_INT_LAT_HOST
-	default 1000
+	default 10
 
 # OK, it's a little counter-intuitive to do this, but it puts it neatly under
 # the virtualization menu.
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index dd8288512065..0ac6863f7ead 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -106,13 +106,22 @@ EXPORT_SYMBOL_GPL(kvm_max_guest_tsc_khz);
 static u32 tsc_tolerance_ppm = 250;
 module_param(tsc_tolerance_ppm, uint, S_IRUGO | S_IWUSR);
 
-#ifdef CONFIG_VIRT_INT_LAT_HOST
+#ifdef CONFIG_IRQ_BENCHMARK_HOST
 static bool inject_enabled;
 static int auto_inject_virq;
-static unsigned long auto_inject_jiffies;
 module_param(inject_enabled, bool, S_IRUGO | S_IWUSR);
 #endif
 
+#ifdef CONFIG_VIRT_INT_LOST_HOST
+/*
+ * By default, we start injecting a quater of the maximum
+ * injection rate.
+ */
+static unsigned int scale_factor = 4;
+module_param(scale_factor, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(scale_factor, "Scale factor of max irqs inject rate");
+#endif
+
 #define KVM_NR_SHARED_MSRS 16
 
 struct kvm_shared_msrs_global {
@@ -2142,8 +2151,8 @@ int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 		if (kvm_lapic_enable_pv_eoi(vcpu, data))
 			return 1;
 		break;
-#ifdef CONFIG_VIRT_INT_LAT_HOST
-	case MSR_KVM_GUEST_TSC:
+#ifdef CONFIG_IRQ_BENCHMARK_HOST
+	case MSR_KVM_VIRQ_DATA_TO_GUEST:
 		if (kvm_gfn_to_hva_cache_init(vcpu->kvm,
 						&vcpu->arch.guest_tsc.data,
 						data,
@@ -2410,7 +2419,7 @@ int kvm_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)
 	case MSR_AMD64_NB_CFG:
 	case MSR_FAM10H_MMIO_CONF_BASE:
 	case MSR_AMD64_BU_CFG2:
-	case MSR_KVM_GUEST_TSC:
+	case MSR_KVM_VIRQ_DATA_TO_GUEST:
 		data = 0;
 		break;
 	case MSR_P6_PERFCTR0:
@@ -3209,7 +3218,7 @@ long kvm_arch_vcpu_ioctl(struct file *filp,
 		break;
 	}
 	case KVM_NMI: {
-#ifdef CONFIG_VIRT_INT_LAT_HOST
+#ifdef CONFIG_IRQ_BENCHMARK_HOST
 		if (inject_enabled) {
 			/* nmi command in qemu monitor enables this parameter */
 			if (auto_inject_virq == 0) {
@@ -6152,6 +6161,12 @@ static int __vcpu_run(struct kvm_vcpu *vcpu)
 {
 	int r;
 	struct kvm *kvm = vcpu->kvm;
+#ifdef CONFIG_VIRT_INT_LOST_HOST
+	static u64 run_enter_cnt;
+#endif
+#ifdef CONFIG_VIRT_INT_LAT_HOST
+	static unsigned long auto_inject_jiffies;
+#endif
 
 	vcpu->srcu_idx = srcu_read_lock(&kvm->srcu);
 
@@ -6218,6 +6233,52 @@ static int __vcpu_run(struct kvm_vcpu *vcpu)
 			}
 		}
 #endif
+#ifdef CONFIG_VIRT_INT_LOST_HOST
+		/*
+		 * vCPU0 is pinned to pCPU1.
+		 * vCPU1 is pinned to pCPU2.
+		 * For vIRQs lost benchmark, we only inject vIRQs from
+		 * pCPU1 to vCPU1
+		 */
+		if ((auto_inject_virq) && (smp_processor_id() == 1)) {
+			/* Limit the inject rate based on the scale factor */
+			if ((run_enter_cnt++ % scale_factor))
+				goto out;
+
+			/*
+			 * After the scale factor was sent to the guest
+			 * with the first IRQ, we give it some time to make
+			 * sure the IRQ is not lost. Otherwise, the guest
+			 * never knows the scale factor we start with.
+			 */
+			if (unlikely((vcpu->arch.guest_tsc.virq_num == 1) &&
+				(run_enter_cnt < 10)))
+				goto out;
+
+			if (unlikely(!vcpu->arch.guest_tsc.virq_num)) {
+				vcpu->arch.guest_tsc.virq_num++;
+				/*
+				 * Let the guest know once about the start scale
+				 * factor of the maximum injection rate.
+				 */
+				kvm_write_guest_cached(vcpu->kvm,
+					&vcpu->arch.guest_tsc.data,
+					&scale_factor, sizeof(unsigned int));
+			} else {
+				/* Update the guest with current number of
+				 * injected interrupts.
+				 */
+				vcpu->arch.guest_tsc.virq_num++;
+				kvm_write_guest_cached(vcpu->kvm,
+					&vcpu->arch.guest_tsc.data,
+					&vcpu->arch.guest_tsc.virq_num,
+					sizeof(u64));
+			}
+			/* Inject vIRQ now */
+			kvm_vcpu_ioctl_nmi(vcpu);
+		}
+out:
+#endif
 		kvm_check_async_pf_completion(vcpu);
 
 		if (signal_pending(current)) {
-- 
2.2.1

