From 88c88d24eb75433c6799ac36b9eec862651ca048 Mon Sep 17 00:00:00 2001
From: Thomas Gleixner <tglx@linutronix.de>
Date: Sun, 18 Dec 2011 12:49:38 +0100
Subject: [PATCH] kvm-trace-support-combine-host-guest-tracing.patch

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
[BA: ringbuffer/trace: 3.6 build/compile fixups]
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
Signed-off-by: Michael Barabanov <michael.barabanov@windriver.com>

diff --git a/arch/x86/kvm/trace.h b/arch/x86/kvm/trace.h
index bca63f0..00d0d6a 100644
--- a/arch/x86/kvm/trace.h
+++ b/arch/x86/kvm/trace.h
@@ -191,6 +191,7 @@ TRACE_EVENT(kvm_exit,
 	TP_ARGS(exit_reason, vcpu, isa),
 
 	TP_STRUCT__entry(
+		__field(	unsigned int,	vcpu_id		)
 		__field(	unsigned int,	exit_reason	)
 		__field(	unsigned long,	guest_rip	)
 		__field(	u32,	        isa             )
@@ -199,6 +200,7 @@ TRACE_EVENT(kvm_exit,
 	),
 
 	TP_fast_assign(
+		__entry->vcpu_id	= vcpu->vcpu_id;
 		__entry->exit_reason	= exit_reason;
 		__entry->guest_rip	= kvm_rip_read(vcpu);
 		__entry->isa            = isa;
@@ -206,7 +208,8 @@ TRACE_EVENT(kvm_exit,
 					   &__entry->info2);
 	),
 
-	TP_printk("reason %s rip 0x%lx info %llx %llx",
+	TP_printk("vcpu %u reason %s rip 0x%lx info %llx %llx",
+		  __entry->vcpu_id,
 		 (__entry->isa == KVM_ISA_VMX) ?
 		 __print_symbolic(__entry->exit_reason, VMX_EXIT_REASONS) :
 		 __print_symbolic(__entry->exit_reason, SVM_EXIT_REASONS),
diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index 2d91079..762b017 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -129,6 +129,8 @@ module_param(ple_gap, int, S_IRUGO);
 static int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;
 module_param(ple_window, int, S_IRUGO);
 
+u64 global_trace_time_stamp(void);
+
 #define NR_AUTOLOAD_MSRS 8
 #define VMCS02_POOL_SIZE 1
 
@@ -4579,6 +4581,11 @@ static int handle_io(struct kvm_vcpu *vcpu)
 	int size, in, string;
 	unsigned port;
 
+	static bool got_2nd_part = true;
+	static u64 guest_time;
+	static u64 host_time;
+	extern s64 host_guest_delta;
+
 	exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
 	string = (exit_qualification & 16) != 0;
 	in = (exit_qualification & 8) != 0;
@@ -4590,6 +4597,36 @@ static int handle_io(struct kvm_vcpu *vcpu)
 
 	port = exit_qualification >> 16;
 	size = (exit_qualification & 7) + 1;
+
+#ifdef CONFIG_TRACING
+	/* magic trap from KVM guest */
+	if (port == 0x55) {
+		trace_printk("Delta between host and guest: %lli\n", host_guest_delta);
+		trace_printk("Disabling tracing due to magic trap from KVM guest!\n");
+		tracing_off();
+	}
+	if (port == 0x56) {
+		if (got_2nd_part) {
+			tracing_on();
+			trace_printk("Enabling tracing due to magic trap from KVM guest!\n");
+
+			guest_time = kvm_register_read(vcpu, VCPU_REGS_RAX);
+			guest_time = guest_time << 32;
+			host_time = global_trace_time_stamp();
+		}
+		else {
+			guest_time += kvm_register_read(vcpu, VCPU_REGS_RAX);
+			host_guest_delta = (host_time - guest_time) / 1000;
+
+			trace_printk("Guest time: %llu\n", guest_time);
+			trace_printk("Host time: %llu\n", host_time);
+			trace_printk("Delta between host and guest: %lli\n", host_guest_delta);
+		}
+
+		got_2nd_part = !got_2nd_part;
+	}
+#endif
+
 	skip_emulated_instruction(vcpu);
 
 	return kvm_fast_pio_out(vcpu, size, port);
diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c
index 4904e07..f23dadf 100644
--- a/kernel/trace/ring_buffer.c
+++ b/kernel/trace/ring_buffer.c
@@ -21,6 +21,7 @@
 #include <linux/fs.h>
 
 #include <asm/local.h>
+#include <asm/kvm_para.h>
 #include "trace.h"
 
 /*
@@ -152,13 +153,15 @@ enum {
 	RB_BUFFERS_DISABLED	= 1 << RB_BUFFERS_DISABLED_BIT,
 };
 
-static unsigned long ring_buffer_flags __read_mostly = RB_BUFFERS_ON;
+// static unsigned long ring_buffer_flags __read_mostly = RB_BUFFERS_ON;
+unsigned long ring_buffer_flags __read_mostly = RB_BUFFERS_ON;
 
 /* Used for individual buffers (after the counter) */
 #define RB_BUFFER_OFF		(1 << 20)
 
 #define BUF_PAGE_HDR_SIZE offsetof(struct buffer_data_page, data)
 
+
 /**
  * tracing_off_permanent - permanently disable ring buffers
  *
@@ -515,7 +518,7 @@ struct ring_buffer_iter {
 /* Up this if you want to test the TIME_EXTENTS and normalization */
 #define DEBUG_SHIFT 0
 
-static inline u64 rb_time_stamp(struct ring_buffer *buffer)
+inline u64 rb_time_stamp(struct ring_buffer *buffer)
 {
 	/* shift to debug/test normalization and TIME_EXTENTS */
 	return buffer->clock() << DEBUG_SHIFT;
@@ -1164,7 +1167,7 @@ struct ring_buffer *__ring_buffer_alloc(unsigned long size, unsigned flags,
 
 	buffer->pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);
 	buffer->flags = flags;
-	buffer->clock = trace_clock_local;
+	buffer->clock = trace_clock_global;
 	buffer->reader_lock_key = key;
 
 	/* need at least two pages */
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 4b04ac8..88d9bef 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -39,6 +39,7 @@
 #include <linux/nmi.h>
 #include <linux/fs.h>
 #include <linux/sched/rt.h>
+#include <linux/kvm_para.h>
 
 #include "trace.h"
 #include "trace_output.h"
@@ -173,6 +174,12 @@ unsigned long long ns2usecs(cycle_t nsec)
  */
 static struct trace_array	global_trace;
 
+u64 global_trace_time_stamp(void)
+{
+	return rb_time_stamp(global_trace.buffer);
+}
+EXPORT_SYMBOL_GPL(global_trace_time_stamp);
+
 static DEFINE_PER_CPU(struct trace_array_cpu, global_trace_cpu);
 
 int filter_current_check_discard(struct ring_buffer *buffer,
@@ -353,6 +360,19 @@ static void wakeup_work_handler(struct work_struct *work)
 
 static DECLARE_DELAYED_WORK(wakeup_work, wakeup_work_handler);
 
+s64 host_guest_delta = 0;
+EXPORT_SYMBOL_GPL(host_guest_delta);
+
+static inline void host_tracing_on(void)
+{
+	u64 now = global_trace_time_stamp();
+	trace_printk("Notifying host (trace enabled)!\n");
+	trace_printk("My time: %llu\n", now);
+	outl((u32)(now >> 32), 0x56);
+	outl((u32)now, 0x56);
+}
+
+
 /**
  * tracing_on - enable tracing buffers
  *
@@ -370,9 +390,23 @@ void tracing_on(void)
 	 * on the buffer.
 	 */
 	global_trace.buffer_disabled = 0;
+
+	trace_printk("Tracing enabled!\n");
+
+	/* notify host kernel */
+	if (kvm_para_available())
+		host_tracing_on();
 }
 EXPORT_SYMBOL_GPL(tracing_on);
 
+
+static inline void host_tracing_off(void)
+{
+	trace_printk("Notifying host (trace disabled)!\n");
+	outl(0x1, 0x55);
+}
+
+
 /**
  * tracing_off - turn off tracing buffers
  *
@@ -383,6 +417,12 @@ EXPORT_SYMBOL_GPL(tracing_on);
  */
 void tracing_off(void)
 {
+	trace_printk("Tracing disabled!\n");
+
+	/* notify host kernel */
+	if (kvm_para_available())
+		host_tracing_off();
+
 	if (global_trace.buffer)
 		ring_buffer_record_off(global_trace.buffer);
 	/*
@@ -395,6 +435,7 @@ void tracing_off(void)
 }
 EXPORT_SYMBOL_GPL(tracing_off);
 
+
 /**
  * tracing_is_on - show state of ring buffers enabled
  */
@@ -4667,6 +4708,18 @@ static __init void create_trace_options_dir(void)
 }
 
 static ssize_t
+host_guest_delta_read(struct file *filp, char __user *ubuf,
+               size_t cnt, loff_t *ppos)
+{
+	char buf[64];
+	int r;
+
+	r = sprintf(buf, "%lli\n", host_guest_delta);
+
+	return simple_read_from_buffer(ubuf, cnt, ppos, buf, r);
+}
+
+static ssize_t
 rb_simple_read(struct file *filp, char __user *ubuf,
 	       size_t cnt, loff_t *ppos)
 {
@@ -4699,10 +4752,27 @@ rb_simple_write(struct file *filp, const char __user *ubuf,
 		return ret;
 
 	if (buffer) {
-		if (val)
+		if (val) {
 			ring_buffer_record_on(buffer);
-		else
+
+			trace_printk("Tracing enabled!\n");
+
+			/* notify host kernel */
+			if (kvm_para_available()) {
+				trace_printk("Notifying host (trace enabled)!\n");
+				host_tracing_on();
+			}
+
+		} else {
+			trace_printk("Tracing disabled!\n");
+
+			/* notify host kernel */
+			if (kvm_para_available()) {
+				trace_printk("Notifying host (trace disabled)!\n");
+				host_tracing_off();
+			}
 			ring_buffer_record_off(buffer);
+		}
 	}
 
 	(*ppos)++;
@@ -4717,6 +4787,14 @@ static const struct file_operations rb_simple_fops = {
 	.llseek		= default_llseek,
 };
 
+static const struct file_operations host_guest_delta_fops = {
+	.open		= tracing_open_generic,
+	.read		= host_guest_delta_read,
+	.llseek		= default_llseek,
+};
+
+extern unsigned long ring_buffer_flags;
+
 static __init int tracer_init_debugfs(void)
 {
 	struct dentry *d_tracer;
@@ -4779,6 +4857,9 @@ static __init int tracer_init_debugfs(void)
 	trace_create_file("tracing_on", 0644, d_tracer,
 			    &global_trace, &rb_simple_fops);
 
+	trace_create_file("host_guest_delta", 0644, d_tracer,
+			    &ring_buffer_flags, &host_guest_delta_fops);
+
 #ifdef CONFIG_DYNAMIC_FTRACE
 	trace_create_file("dyn_ftrace_total_info", 0444, d_tracer,
 			&ftrace_update_tot_cnt, &tracing_dyn_info_fops);
diff --git a/kernel/trace/trace.h b/kernel/trace/trace.h
index 62f1fca..40753c6 100644
--- a/kernel/trace/trace.h
+++ b/kernel/trace/trace.h
@@ -513,6 +513,8 @@ enum print_line_t print_trace_line(struct trace_iterator *iter);
 extern unsigned long trace_flags;
 
 extern int trace_clock_id;
+u64 rb_time_stamp(struct ring_buffer *buffer);
+u64 global_trace_time_stamp(void);
 
 /* Standard output formatting function used for function return traces */
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
-- 
1.8.3.1

