From 43dd64fcee32dff45d4bf81afc3820644cabad51 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Mon, 28 Apr 2014 14:43:37 -0400
Subject: [PATCH] kvm: add option to allow old LAPIC before PIC behaviour

The spec says to try PIC before LAPIC, but kernels up to
v3.9 did the reverse (as of f3200d00ea42e485).  Some binary
blob guests seem to depend on doing LAPIC before PIC, and so
setting this option will give the old behaviour.

We don't bother with the switching of behaviour in kvm_cpu_has_extint
that also was done in f3200d00ea42e485, since emperical testing
showed that to not be necessary.

Reported-by: "Mercado, David" <david.mercado@windriver.com>
Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/x86/kvm/Kconfig b/arch/x86/kvm/Kconfig
index 2d197d90c771..511c355f3a1b 100644
--- a/arch/x86/kvm/Kconfig
+++ b/arch/x86/kvm/Kconfig
@@ -63,6 +63,15 @@ config KVM_INTEL
 	  To compile this as a module, choose M here: the module
 	  will be called kvm-intel.
 
+config KVM_LAPIC_B4_PIC
+	bool "Try LAPIC before PIC delivery"
+	depends on KVM_INTEL
+	---help---
+	  The spec says to try PIC before LAPIC, but kernels up to
+	  v3.9 did the reverse (as of f3200d00ea42e485).  Some binary
+	  blob guests seem to depend on doing LAPIC before PIC, and so
+	  setting this option will give the old behaviour.
+
 config KVM_AMD
 	tristate "KVM for AMD processors support"
 	depends on KVM
diff --git a/arch/x86/kvm/irq.c b/arch/x86/kvm/irq.c
index 484bc874688b..7c0b27c2b1cc 100644
--- a/arch/x86/kvm/irq.c
+++ b/arch/x86/kvm/irq.c
@@ -89,12 +89,14 @@ EXPORT_SYMBOL_GPL(kvm_cpu_has_interrupt);
  * Read pending interrupt(from non-APIC source)
  * vector and intack.
  */
+#ifndef CONFIG_KVM_LAPIC_B4_PIC
 static int kvm_cpu_get_extint(struct kvm_vcpu *v)
 {
 	if (kvm_cpu_has_extint(v))
 		return kvm_pic_read_irq(v->kvm); /* PIC */
 	return -1;
 }
+#endif
 
 /*
  * Read pending interrupt vector and intack.
@@ -106,12 +108,26 @@ int kvm_cpu_get_interrupt(struct kvm_vcpu *v)
 	if (!irqchip_in_kernel(v->kvm))
 		return v->arch.interrupt.nr;
 
+#ifdef CONFIG_KVM_LAPIC_B4_PIC
+	vector = kvm_get_apic_interrupt(v);     /* APIC */
+	if (vector == -1) {
+		if (kvm_apic_accept_pic_intr(v)) {
+			struct kvm_pic *s;
+
+			s = pic_irqchip(v->kvm);
+			s->output = 0;          /* PIC */
+			vector = kvm_pic_read_irq(v->kvm);
+		}
+	}
+	return vector;
+#else
 	vector = kvm_cpu_get_extint(v);
 
 	if (kvm_apic_vid_enabled(v->kvm) || vector != -1)
 		return vector;			/* PIC */
 
 	return kvm_get_apic_interrupt(v);	/* APIC */
+#endif
 }
 
 void kvm_inject_pending_timer_irqs(struct kvm_vcpu *vcpu)
-- 
1.9.0

