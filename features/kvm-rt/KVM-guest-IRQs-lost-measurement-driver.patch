From 8f7e193796ece21df2746555aa7d672d3e81005e Mon Sep 17 00:00:00 2001
From: Nam Ninh <nam.ninh@windriver.com>
Date: Wed, 13 Nov 2013 15:55:25 -0500
Subject: [PATCH] KVM-guest: IRQs lost measurement driver

This driver is the guest-side of the tool to measure the number
and the percentage of lost interrupts when the interrupst are
injected from host at a certain rate. The driver also calculates
the injection duration and rate in IRQs/second. testintlost
application is used to retrieve and display statistics from this
driver.

Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 3fe7a5cd6d87..df32265824e0 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -704,13 +704,32 @@ config KVM_DEBUG_FS
 	  Statistics are displayed in debugfs filesystem. Enabling this option
 	  may incur significant overhead.
 
-config VIRT_INT_LAT_GUEST
-	bool "Measure interrupt latency from KVM host to guest"
+menuconfig IRQ_BENCHMARK_GUEST
+	bool "IRQs benchmark tool"
 	depends on KVM_GUEST
 	default n
 	---help---
+	 Say Y here to see options related to IRQs benchmark.
+	 If you say N, all options in this submenu will be skipped and disabled.
+
+choice
+	prompt "IRQs Latency or lost benchmark"
+	depends on IRQ_BENCHMARK_GUEST
+	default VIRT_INT_LAT_GUEST
+
+config VIRT_INT_LAT_GUEST
+	bool "Interrupt latency from KVM host to guest"
+	---help---
 	  This is a generic driver to measure minimum, average and maximum
-	  latency from KVM host to guest for X86 platform.
+	  latency from KVM host to guest.
+
+config VIRT_INT_LOST_GUEST
+	bool "Interrupt lost from KVM host to guest"
+	---help---
+	  This is a generic driver to detect inject rate threshold at
+	  which the interrupts from KVM host to guest starts being lost,
+	  and measure how much interrupts are lost at a certain rate.
+endchoice
 
 source "arch/x86/lguest/Kconfig"
 
diff --git a/arch/x86/include/asm/paravirt.h b/arch/x86/include/asm/paravirt.h
index 5d09df2190ac..3b47b71797d9 100644
--- a/arch/x86/include/asm/paravirt.h
+++ b/arch/x86/include/asm/paravirt.h
@@ -298,6 +298,22 @@ static inline u64 paravirt_read_virq_start_tsc(int cpu)
 }
 #endif
 
+#ifdef CONFIG_VIRT_INT_LOST_GUEST
+/*
+ * Before KVM host injects each vIRQ to the guest, it puts
+ * the number of vIRQs that has been injected on a MSR
+ * shared memory buffer. This function is called by the guest
+ * to read out the total generated vIRQs from this shared
+ * memory. Locally, the guest records the total of vIRQs it
+ * has received. Based on the generated number and the received
+ * number, it calculates the percentage of lost interrupts.
+ */
+static inline u64 paravirt_read_generated_virq_total(int cpu)
+{
+	return PVOP_CALL1(u64, pv_time_ops.gen_total, cpu);
+}
+#endif
+
 static inline void write_ldt_entry(struct desc_struct *dt, int entry,
 				   const void *desc)
 {
diff --git a/arch/x86/include/asm/paravirt_types.h b/arch/x86/include/asm/paravirt_types.h
index f310ca81e63b..c844c7bde7fb 100644
--- a/arch/x86/include/asm/paravirt_types.h
+++ b/arch/x86/include/asm/paravirt_types.h
@@ -99,6 +99,7 @@ struct pv_time_ops {
 	unsigned long long (*steal_clock)(int cpu);
 	unsigned long (*get_tsc_khz)(void);
 	unsigned long long (*read_tsc)(int cpu);
+	unsigned long long (*gen_total)(int cpu);
 };
 
 struct pv_cpu_ops {
diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index 61f28d44117e..0674ef16b47b 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -113,6 +113,7 @@ obj-$(CONFIG_TRACING)			+= tracepoint.o
 obj-$(CONFIG_IOSF_MBI)			+= iosf_mbi.o
 obj-$(CONFIG_PMC_ATOM)			+= pmc_atom.o
 obj-$(CONFIG_VIRT_INT_LAT_GUEST)	+= intlatdrv.o
+obj-$(CONFIG_VIRT_INT_LOST_GUEST)	+= intlostdrv.o
 
 ###
 # 64 bit specific files
diff --git a/arch/x86/kernel/intlostdrv.c b/arch/x86/kernel/intlostdrv.c
new file mode 100644
index 000000000000..af6868e474bd
--- /dev/null
+++ b/arch/x86/kernel/intlostdrv.c
@@ -0,0 +1,208 @@
+/*
+ * Virtual Interrupt Lost Measurement Driver
+ *
+ * Copyright (c) 2013 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/fs.h>
+#include <linux/pci.h>
+#include <asm/paravirt.h>
+#include <asm/msr.h>
+
+#include "intlostdrv.h"
+
+#define DEVICE_NAME				"vintlost"
+
+struct intlost_info_s {
+	void *intlost_va;
+	void *intlost_ptr;
+};
+
+static int major;
+static uint32_t current_scale_factor;
+static uint64_t start_tsc, current_tsc, duration_tsc;
+static struct intlost_info_s *lost_info;
+
+static int device_open(struct inode *, struct file *);
+static int device_release(struct inode *, struct file *);
+static int device_mmap(struct file *file, struct vm_area_struct *vma);
+static long device_ioctl(struct file *file, unsigned int cmd,
+							unsigned long arg);
+
+static const struct file_operations fops = {
+	.open = device_open,
+	.release = device_release,
+	.mmap = device_mmap,
+	.unlocked_ioctl = device_ioctl
+};
+
+/* Called when a process tries to open the device file. */
+static int device_open(struct inode *inode, struct file *file)
+{
+	pr_debug("Device open");
+	if (try_module_get(THIS_MODULE))
+		return 0;
+	return -EBUSY;
+}
+
+/*
+ * Called when a process closes the device file.
+ */
+static int device_release(struct inode *inode, struct file *file)
+{
+	/*
+	 * Decrement the usage count, or else once you opened the file, you'll
+	 * never get rid of the module.
+	 */
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+/*
+ * Called when the user-space library calls the mmap libc function.
+ * Usage:
+ * intlost_va = (void *)mmap(NULL, sizeof(struct intlost_stats_s),
+ *             PROT_READ | PROT_WRITE, MAP_SHARED | MAP_LOCKED, fd, 0);
+ */
+static int device_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long start = vma->vm_start;
+	unsigned long size  = vma->vm_end - vma->vm_start;
+	unsigned long pfn;
+	struct intlost_stats_s *intlost_stats = (struct intlost_stats_s *)
+						lost_info->intlost_va;
+
+	intlost_stats->scale_factor = current_scale_factor;
+	intlost_stats->inject_duration_tsc = duration_tsc;
+	pfn = page_to_pfn(virt_to_page((unsigned long)lost_info->intlost_va));
+	if (remap_pfn_range(vma, start, pfn, size, vma->vm_page_prot)) {
+		pr_err("remap_pfn_range failed\n");
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+static long device_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int result = -ENOIOCTLCMD;
+
+	switch (cmd) {
+	case INTLOST_CMD_INT:
+		result = 0;
+		break;
+	default:
+		{
+		pr_err("Unknown ioctl: %u\n", cmd);
+		break;
+		}
+	}
+	return result;
+}
+
+void update_irqs_lost_stats(void)
+{
+	struct intlost_stats_s *intlost_stats = (struct intlost_stats_s *)
+						lost_info->intlost_va;
+
+	intlost_stats->received_total++;
+	/*
+	 * Data with first virq is the start scale factor
+	 * of the maximum injection rate, i.e., scale factor of 4
+	 * is a quater of max rate, and 2 is half rate.
+	 */
+	if (unlikely(intlost_stats->received_total == 1)) {
+		rdtscll(start_tsc);
+		current_tsc = start_tsc;
+		current_scale_factor =
+			paravirt_read_generated_virq_total(smp_processor_id());
+		pr_debug("Start max inject rate scale factor: %u\n",
+			current_scale_factor);
+	} else {
+		intlost_stats->injected_total =
+			paravirt_read_generated_virq_total(smp_processor_id());
+		rdtscll(current_tsc);
+		if (likely(current_tsc > start_tsc))
+			duration_tsc = current_tsc - start_tsc;
+		else
+			/* TSC rollover */
+			duration_tsc = (current_tsc + (~0ULL - start_tsc));
+	}
+
+	/* Print out debug info */
+	pr_debug("vIRQs injected: %llu, vIRQs received: %llu\n",
+		intlost_stats->injected_total,
+		intlost_stats->received_total);
+}
+
+static int __init intlost_init_module(void)
+{
+	lost_info = kzalloc(sizeof(struct intlost_info_s), GFP_KERNEL);
+	if (lost_info == NULL) {
+		pr_err("Failed to allocate memory for for intlost_info\n");
+		return -ENOMEM;
+	}
+
+	/* Allocate the shared memory for timer info */
+	lost_info->intlost_ptr = kzalloc(((sizeof(struct intlost_stats_s)/
+					PAGE_SIZE)+3)*PAGE_SIZE, GFP_KERNEL);
+	if (lost_info->intlost_ptr == NULL) {
+		pr_err("Failed to allocate memory for for intlost_ptr\n");
+		kfree(lost_info);
+		return -ENOMEM;
+	}
+	lost_info->intlost_va = (int *)((((unsigned long)
+		lost_info->intlost_ptr) + PAGE_SIZE - 1) & PAGE_MASK);
+	SetPageReserved(virt_to_page((
+				(unsigned long)lost_info->intlost_va)));
+
+	major = register_chrdev(0, DEVICE_NAME, &fops);
+	if (major < 0) {
+		pr_err("Registering char device failed with %d for master\n",
+									major);
+		ClearPageReserved(virt_to_page(
+				(unsigned long)lost_info->intlost_va));
+		kfree(lost_info->intlost_ptr);
+		kfree(lost_info);
+		return major;
+	} else
+		pr_debug("Char Dev Drv with major %d\n", major);
+
+	return 0;
+}
+
+static void intlost_cleanup_module(void)
+{
+	/* Clear reserved page for timer info */
+	ClearPageReserved(virt_to_page(
+				(unsigned long)lost_info->intlost_va));
+	kfree(lost_info->intlost_ptr);
+	kfree(lost_info);
+
+	/* Unregister the device */
+	unregister_chrdev(major, DEVICE_NAME);
+}
+
+module_init(intlost_init_module);
+module_exit(intlost_cleanup_module);
+
+MODULE_AUTHOR("Wind River");
+MODULE_DESCRIPTION("Interrupts Lost Benchmark Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.1");
diff --git a/arch/x86/kernel/intlostdrv.h b/arch/x86/kernel/intlostdrv.h
new file mode 100644
index 000000000000..de53fdad4bbc
--- /dev/null
+++ b/arch/x86/kernel/intlostdrv.h
@@ -0,0 +1,43 @@
+/*
+ * Virtual Interrupt Lost Measurement Driver
+ *
+ * Copyright (c) 2013 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#ifndef INTLOSTDRV_H
+#define INTLOSTDRV_H
+
+#define INTLOST_CMD_MAGIC			'e'
+#define INTLOST_CMD_INT				(0)
+#define INTLOST_IOCTL_INT \
+		_IOWR(INTLOST_CMD_MAGIC, INTLOST_CMD_INT, unsigned int)
+
+struct intlost_stats_s {
+	uint64_t injected_total;
+	uint64_t received_total;
+	uint64_t inject_duration_tsc;
+	/*
+	 * Scale factor of maximum injection rate, i.e, with scale
+	 * factor of 4, the host injects one quarter of the max
+	 * injection rate.
+	 */
+	uint32_t scale_factor;
+};
+
+extern void update_irqs_lost_stats(void);
+
+#endif
diff --git a/arch/x86/kernel/kvm.c b/arch/x86/kernel/kvm.c
index 8de0324fb56b..f3bc272c4c81 100644
--- a/arch/x86/kernel/kvm.c
+++ b/arch/x86/kernel/kvm.c
@@ -332,23 +332,29 @@ static void kvm_guest_apic_eoi_write(u32 reg, u32 val)
 	apic_write(APIC_EOI, APIC_EOI_ACK);
 }
 
-#ifdef CONFIG_VIRT_INT_LAT_GUEST
-static DEFINE_PER_CPU(u64, kvm_guest_tsc);
-static void kvm_init_read_tsc_area(void)
+#ifdef CONFIG_IRQ_BENCHMARK_GUEST
+/*
+ * Data from host is either tsc timestamp of generate virq
+ * if the tool is used to measure interrupt latency, or
+ * the current total number of generated vIRQs if the tool
+ * is used to benchmark vIRQs lost
+ */
+static DEFINE_PER_CPU(u64, kvm_data_from_host);
+static void kvm_init_read_data_from_host(void)
 {
 	int cpu = smp_processor_id();
-	u64 *tsc = &per_cpu(kvm_guest_tsc, cpu);
+	u64 *tsc = &per_cpu(kvm_data_from_host, cpu);
 
-	wrmsrl(MSR_KVM_GUEST_TSC, __pa(tsc));
-	printk(KERN_INFO "register_inject_tsc: cpu %d, msr %lx\n",
+	wrmsrl(MSR_KVM_VIRQ_DATA_TO_GUEST, __pa(tsc));
+	printk(KERN_INFO "%s: cpu %d, msr %lx\n", __func__,
 						cpu, __pa(tsc));
 }
 
-static u64 kvm_read_inject_tsc(int cpu)
+static u64 kvm_read_data_from_host(int cpu)
 {
 	u64 tsc;
 
-	tsc = per_cpu(kvm_guest_tsc, cpu);
+	tsc = per_cpu(kvm_data_from_host, cpu);
 	/*
 	 * Make sure there is no reordering between reading and
 	 * writing to the shared buffer.
@@ -388,8 +394,8 @@ void kvm_guest_cpu_init(void)
 	if (has_steal_clock)
 		kvm_register_steal_time();
 
-#ifdef CONFIG_VIRT_INT_LAT_GUEST
-	kvm_init_read_tsc_area();
+#ifdef CONFIG_IRQ_BENCHMARK_GUEST
+	kvm_init_read_data_from_host();
 #endif
 }
 
@@ -533,7 +539,11 @@ void __init kvm_guest_init(void)
 		kvm_setup_vsyscall_timeinfo();
 
 #ifdef CONFIG_VIRT_INT_LAT_GUEST
-	pv_time_ops.read_tsc = kvm_read_inject_tsc;
+	pv_time_ops.read_tsc = kvm_read_data_from_host;
+#endif
+
+#ifdef CONFIG_VIRT_INT_LOST_GUEST
+	pv_time_ops.gen_total = kvm_read_data_from_host;
 #endif
 
 #ifdef CONFIG_SMP
diff --git a/arch/x86/kernel/nmi.c b/arch/x86/kernel/nmi.c
index 84f00366adfc..5f8e502ad41b 100644
--- a/arch/x86/kernel/nmi.c
+++ b/arch/x86/kernel/nmi.c
@@ -37,6 +37,10 @@
 #include "intlatdrv.h"
 #endif
 
+#ifdef CONFIG_VIRT_INT_LOST_GUEST
+#include "intlostdrv.h"
+#endif
+
 struct nmi_desc {
 	spinlock_t lock;
 	struct list_head head;
@@ -298,9 +302,9 @@ unknown_nmi_error(unsigned char reason, struct pt_regs *regs)
 
 
 	/*
-	 * Quiet these messages when the virq latency test is run
+	 * Quiet these messages when the virq test tool is run
 	 */
-#ifndef CONFIG_VIRT_INT_LAT_GUEST
+#ifndef CONFIG_IRQ_BENCHMARK_GUEST
 	pr_emerg("Uhhuh. NMI received for unknown reason %02x on CPU %d.\n",
 		 reason, smp_processor_id());
 
@@ -502,6 +506,9 @@ nmi_restart:
 #ifdef CONFIG_VIRT_INT_LAT_GUEST
 	update_latency_timestamp();
 #endif
+#ifdef CONFIG_VIRT_INT_LOST_GUEST
+	update_irqs_lost_stats();
+#endif
 
 #ifdef CONFIG_X86_64
 	/*
-- 
2.5.0

