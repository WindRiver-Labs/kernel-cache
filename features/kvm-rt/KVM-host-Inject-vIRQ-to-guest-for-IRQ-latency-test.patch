From ed0697570938927e74bf4b5748b20e56dedea506 Mon Sep 17 00:00:00 2001
From: Nam Ninh <nam.ninh@windriver.com>
Date: Mon, 21 Oct 2013 13:37:24 -0400
Subject: [PATCH] KVM-host: Inject vIRQ to guest for IRQ latency test

When inject_virq=1 is specified with kvm module loading, vIRQ injecting
to guest is enabled. The injecting period is 1 second by default.

Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 41b06fca39f7..bb72dc70ad09 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -540,6 +540,12 @@ struct kvm_vcpu_arch {
 	struct {
 		bool pv_unhalted;
 	} pv;
+
+	/* Guest tsc counter before virq is injected into the guest */
+	struct {
+		u64 tsc;
+		struct gfn_to_hva_cache data;
+	} guest_tsc;
 };
 
 struct kvm_lpage_info {
diff --git a/arch/x86/include/asm/kvm_para.h b/arch/x86/include/asm/kvm_para.h
index c1adf33fdd0d..8737a594dd6d 100644
--- a/arch/x86/include/asm/kvm_para.h
+++ b/arch/x86/include/asm/kvm_para.h
@@ -1,5 +1,6 @@
 #ifndef _ASM_X86_KVM_PARA_H
 #define _ASM_X86_KVM_PARA_H
+#define MSR_KVM_GUEST_TSC      0x4b564d05
 
 #include <asm/processor.h>
 #include <asm/alternative.h>
diff --git a/arch/x86/kvm/Kconfig b/arch/x86/kvm/Kconfig
index 413a7bf9efbb..f5f304cafde2 100644
--- a/arch/x86/kvm/Kconfig
+++ b/arch/x86/kvm/Kconfig
@@ -96,6 +96,19 @@ config KVM_DEVICE_ASSIGNMENT
 
 	  If unsure, say Y.
 
+config VIRT_INT_LAT_HOST
+	bool "Inject vIRQ to KVM guest"
+	depends on KVM
+	default n
+	---help---
+	 Enable this option to inject vIRQ to KVM guest for vIRQ latency
+	 measurement on the guest
+
+config VIRT_INT_INJECT_PERIOD
+	int "Frequency to inject vIRQ from host to guest in msec"
+	depends on VIRT_INT_LAT_HOST
+	default 1000
+
 # OK, it's a little counter-intuitive to do this, but it puts it neatly under
 # the virtualization menu.
 source drivers/vhost/Kconfig
diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index 1c141304994d..908dd6038690 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -50,8 +50,6 @@
 #include "trace.h"
 
 #define __ex(x) __kvm_handle_fault_on_reboot(x)
-#define __ex_clear(x, reg) \
-	____kvm_handle_fault_on_reboot(x, "xor " reg " , " reg)
 
 MODULE_AUTHOR("Qumranet");
 MODULE_LICENSE("GPL");
@@ -1378,15 +1376,6 @@ static inline void ept_sync_context(u64 eptp)
 	}
 }
 
-static __always_inline unsigned long vmcs_readl(unsigned long field)
-{
-	unsigned long value;
-
-	asm volatile (__ex_clear(ASM_VMX_VMREAD_RDX_RAX, "%0")
-		      : "=a"(value) : "d"(field) : "cc");
-	return value;
-}
-
 static __always_inline u16 vmcs_read16(unsigned long field)
 {
 	return vmcs_readl(field);
@@ -1397,15 +1386,6 @@ static __always_inline u32 vmcs_read32(unsigned long field)
 	return vmcs_readl(field);
 }
 
-static __always_inline u64 vmcs_read64(unsigned long field)
-{
-#ifdef CONFIG_X86_64
-	return vmcs_readl(field);
-#else
-	return vmcs_readl(field) | ((u64)vmcs_readl(field+1) << 32);
-#endif
-}
-
 static noinline void vmwrite_error(unsigned long field, unsigned long value)
 {
 	printk(KERN_ERR "vmwrite error: reg %lx value %lx (err %d)\n",
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 02aeb5b0c2a6..28c387b83d4e 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -114,6 +114,13 @@ module_param(lapic_timer_advance_ns, uint, S_IRUGO | S_IWUSR);
 
 static bool backwards_tsc_observed = false;
 
+#ifdef CONFIG_VIRT_INT_LAT_HOST
+static bool inject_enabled;
+static int auto_inject_virq;
+static unsigned long auto_inject_jiffies;
+module_param(inject_enabled, bool, S_IRUGO | S_IWUSR);
+#endif
+
 #define KVM_NR_SHARED_MSRS 16
 
 struct kvm_shared_msrs_global {
@@ -2275,7 +2282,15 @@ int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 		if (kvm_lapic_enable_pv_eoi(vcpu, data))
 			return 1;
 		break;
-
+#ifdef CONFIG_VIRT_INT_LAT_HOST
+	case MSR_KVM_GUEST_TSC:
+		if (kvm_gfn_to_hva_cache_init(vcpu->kvm,
+						&vcpu->arch.guest_tsc.data,
+						data,
+						sizeof(u64)))
+			return 1;
+		break;
+#endif
 	case MSR_IA32_MCG_CTL:
 	case MSR_IA32_MCG_STATUS:
 	case MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:
@@ -2545,6 +2560,7 @@ int kvm_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)
 	case MSR_AMD64_NB_CFG:
 	case MSR_FAM10H_MMIO_CONF_BASE:
 	case MSR_AMD64_BU_CFG2:
+	case MSR_KVM_GUEST_TSC:
 		data = 0;
 		break;
 	case MSR_P6_PERFCTR0:
@@ -3412,6 +3428,20 @@ long kvm_arch_vcpu_ioctl(struct file *filp,
 		break;
 	}
 	case KVM_NMI: {
+#ifdef CONFIG_VIRT_INT_LAT_HOST
+		if (inject_enabled) {
+			/* nmi command in qemu monitor enables this parameter */
+			if (auto_inject_virq == 0) {
+				pr_debug("## Enable auto_inject_virq\n");
+				auto_inject_virq = 1;
+			} else {
+				pr_debug("## Disable auto_inject_virq\n");
+				auto_inject_virq = 0;
+			}
+			r = 0;
+			break;
+		}
+#endif
 		r = kvm_vcpu_ioctl_nmi(vcpu);
 		break;
 	}
@@ -6500,7 +6530,29 @@ static int vcpu_run(struct kvm_vcpu *vcpu)
 			++vcpu->stat.request_irq_exits;
 			break;
 		}
-
+#ifdef CONFIG_VIRT_INT_LAT_HOST
+		/*
+		 * After entering the nmi command in qemu monitor and exiting
+		 * the monitor, the host will automatically inject nmi virq
+		 * every second.
+		 */
+		if (auto_inject_virq) {
+			if ((auto_inject_jiffies == 0) ||
+			    time_after(jiffies, auto_inject_jiffies)) {
+				unsigned int virq_period;
+				/*
+				 * Let the guest know the timestamp when the
+				 * virq was injected from host
+				 */
+				virq_inject_time(vcpu);
+				/* Inject the virq now */
+				kvm_vcpu_ioctl_nmi(vcpu);
+				virq_period = CONFIG_VIRT_INT_INJECT_PERIOD;
+				auto_inject_jiffies =
+					jiffies + msecs_to_jiffies(virq_period);
+			}
+		}
+#endif
 		kvm_check_async_pf_completion(vcpu);
 
 		if (signal_pending(current)) {
@@ -6602,6 +6654,30 @@ static int complete_emulated_mmio(struct kvm_vcpu *vcpu)
 	return 0;
 }
 
+#ifdef CONFIG_VIRT_INT_LAT_HOST
+
+/*
+ * Reads and returns guest's timestamp counter "register"
+ * guest_tsc = host_tsc + tsc_offset
+ */
+static u64 guest_read_tsc(void)
+{
+	u64 host_tsc, tsc_offset;
+
+	rdtscll(host_tsc);
+	tsc_offset = vmcs_read64(TSC_OFFSET);
+	return host_tsc + tsc_offset;
+}
+
+static void virq_inject_time(struct kvm_vcpu *vcpu)
+{
+	vcpu->arch.guest_tsc.tsc = guest_read_tsc();
+
+	kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.guest_tsc.data,
+		&vcpu->arch.guest_tsc.tsc, sizeof(u64));
+}
+
+#endif  /* CONFIG_VIRT_INT_LAT_HOST */
 
 int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)
 {
diff --git a/arch/x86/kvm/x86.h b/arch/x86/kvm/x86.h
index f5fef1868096..5b28fd01c605 100644
--- a/arch/x86/kvm/x86.h
+++ b/arch/x86/kvm/x86.h
@@ -2,8 +2,34 @@
 #define ARCH_X86_KVM_X86_H
 
 #include <linux/kvm_host.h>
+#include <asm/vmx.h>
 #include "kvm_cache_regs.h"
 
+#define __ex_clear(x, reg) \
+	____kvm_handle_fault_on_reboot(x, "xor " reg " , " reg)
+
+/*
+ * vmcs_readl and vmcs_read64 are moved here from vmx.c so that
+ * kvm/x86.c can use.
+ */
+static __always_inline unsigned long vmcs_readl(unsigned long field)
+{
+	unsigned long value;
+
+	asm volatile (__ex_clear(ASM_VMX_VMREAD_RDX_RAX, "%0")
+		      : "=a"(value) : "d"(field) : "cc");
+	return value;
+}
+
+static __always_inline u64 vmcs_read64(unsigned long field)
+{
+#ifdef CONFIG_X86_64
+	return vmcs_readl(field);
+#else
+	return vmcs_readl(field) | ((u64)vmcs_readl(field+1) << 32);
+#endif
+}
+
 static inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)
 {
 	vcpu->arch.exception.pending = false;
-- 
2.5.0

