From 5cb0de522e18b698864a0ddfa4c5c5a300c0f81f Mon Sep 17 00:00:00 2001
From: Nam Ninh <nam.ninh@windriver.com>
Date: Wed, 9 Oct 2013 14:38:11 -0400
Subject: [PATCH] KVM-host: Inject vIRQ to guest for IRQ latency test

When inject_virq=1 is specified with kvm module loading, vIRQ injecting
to guest is enabled. The injecting period is 1 second by default.

Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/x86/kvm/Kconfig b/arch/x86/kvm/Kconfig
index a28f338..436b614 100644
--- a/arch/x86/kvm/Kconfig
+++ b/arch/x86/kvm/Kconfig
@@ -80,6 +80,10 @@ config KVM_MMU_AUDIT
 	 This option adds a R/W kVM module parameter 'mmu_audit', which allows
 	 audit  KVM MMU at runtime.
 
+config VIRT_INT_INJECT_PERIOD
+	int "Frequency to inject vIRQ from host to guest in msec"
+	default 1000
+
 # OK, it's a little counter-intuitive to do this, but it puts it neatly under
 # the virtualization menu.
 source drivers/vhost/Kconfig
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 9a0bdef..3cee0ee 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -101,6 +101,9 @@ EXPORT_SYMBOL_GPL(kvm_max_guest_tsc_khz);
 static u32 tsc_tolerance_ppm = 250;
 module_param(tsc_tolerance_ppm, uint, S_IRUGO | S_IWUSR);
 
+static bool inject_enabled;
+module_param(inject_enabled, bool, S_IRUGO | S_IWUSR);
+
 #define KVM_NR_SHARED_MSRS 16
 
 struct kvm_shared_msrs_global {
@@ -2665,6 +2668,8 @@ static int kvm_set_guest_paused(struct kvm_vcpu *vcpu)
 	return 0;
 }
 
+static int auto_inject_virq;
+static u64 auto_inject_jiffies;
 long kvm_arch_vcpu_ioctl(struct file *filp,
 			 unsigned int ioctl, unsigned long arg)
 {
@@ -2727,6 +2732,18 @@ long kvm_arch_vcpu_ioctl(struct file *filp,
 		break;
 	}
 	case KVM_NMI: {
+		if (inject_enabled) {
+			/* nmi command in qemu monitor enables this parameter */
+			if (auto_inject_virq == 0) {
+				pr_debug("## Enable auto_inject_virq\n");
+				auto_inject_virq = 1;
+			} else {
+				pr_debug("## Disable auto_inject_virq\n");
+				auto_inject_virq = 0;
+			}
+			r = 0;
+			break;
+		}
 		r = kvm_vcpu_ioctl_nmi(vcpu);
 		if (r)
 			goto out;
@@ -5471,6 +5488,7 @@ out:
 static int __vcpu_run(struct kvm_vcpu *vcpu)
 {
 	int r;
+	unsigned int virq_period;
 	struct kvm *kvm = vcpu->kvm;
 
 	if (unlikely(vcpu->arch.mp_state == KVM_MP_STATE_SIPI_RECEIVED)) {
@@ -5529,6 +5547,21 @@ static int __vcpu_run(struct kvm_vcpu *vcpu)
 			++vcpu->stat.request_irq_exits;
 		}
 
+		/*
+		 * After entering the nmi command in qemu monitor and exiting
+		 * the monitor, the host will automatically inject nmi virq
+		 * every second.
+		 */
+		if (auto_inject_virq) {
+			if ((auto_inject_jiffies == 0) ||
+			    time_after(jiffies, auto_inject_jiffies)) {
+				kvm_vcpu_ioctl_nmi(vcpu);
+				virq_period = CONFIG_VIRT_INT_INJECT_PERIOD;
+				auto_inject_jiffies =
+					jiffies + msecs_to_jiffies(virq_period);
+			}
+		}
+
 		kvm_check_async_pf_completion(vcpu);
 
 		if (signal_pending(current)) {
-- 
1.8.3.1

