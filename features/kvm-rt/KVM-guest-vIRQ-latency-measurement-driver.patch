From 2f62c62d3d73832291490211d4e13c8201d4e00c Mon Sep 17 00:00:00 2001
From: Nam Ninh <nam.ninh@windriver.com>
Date: Wed, 9 Oct 2013 14:39:22 -0400
Subject: [PATCH] KVM-guest: vIRQ latency measurement driver

This driver calculates the average latency of vIRQs injected from
OVP KVM host to OVP KVM guest. An application needs to mmap timer
information structure to user-space in order to read the latency.

Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index a400d1f..c698d16 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -1031,6 +1031,13 @@ config X86_CPUID
 	  with major 203 and minors 0 to 31 for /dev/cpu/0/cpuid to
 	  /dev/cpu/31/cpuid.
 
+config VIRT_INT_LAT
+	bool "Measure interrupt latency from KVM host to guest"
+	default n
+	---help---
+	  This is a generic driver to measure minimum, average and maximum
+	  latency from KVM host to guest for any platform.
+
 choice
 	prompt "High Memory Support"
 	default HIGHMEM64G if X86_NUMAQ
diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index d23d835..0007285 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -102,6 +102,7 @@ obj-$(CONFIG_X86_CHECK_BIOS_CORRUPTION) += check.o
 obj-$(CONFIG_SWIOTLB)			+= pci-swiotlb.o
 obj-$(CONFIG_OF)			+= devicetree.o
 obj-$(CONFIG_UPROBES)			+= uprobes.o
+obj-$(CONFIG_VIRT_INT_LAT)		+= intlatdrv.o
 
 ###
 # 64 bit specific files
diff --git a/arch/x86/kernel/intlatdrv.c b/arch/x86/kernel/intlatdrv.c
new file mode 100644
index 0000000..1e0ee65
--- /dev/null
+++ b/arch/x86/kernel/intlatdrv.c
@@ -0,0 +1,236 @@
+/*
+ * Virtual Interrupt Latency Measurement Driver
+ *
+ * Copyright (c) 2013 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/fs.h>
+#include <linux/pci.h>
+#include <linux/jiffies.h>
+
+#include "intlatdrv.h"
+
+#define DEVICE_NAME				"vintlat"
+
+struct intlat_info_s {
+	void *kern_timer_va;
+	void *kern_timer_ptr;
+};
+
+static int _major;
+static uint64_t last_timestamp;
+static struct intlat_info_s *_intlat_info;
+
+static int device_open(struct inode *, struct file *);
+static int device_release(struct inode *, struct file *);
+static int device_mmap(struct file *file, struct vm_area_struct *vma);
+static long device_ioctl(struct file *file, unsigned int cmd,
+							unsigned long arg);
+
+static const struct file_operations fops = {
+	.open = device_open,
+	.release = device_release,
+	.mmap = device_mmap,
+	.unlocked_ioctl = device_ioctl
+};
+
+/* Called when a process tries to open the device file. */
+static int device_open(struct inode *inode, struct file *file)
+{
+	pr_debug("Device open");
+	if (try_module_get(THIS_MODULE))
+		return 0;
+	return -EBUSY;
+}
+
+/*
+ * Called when a process closes the device file.
+ */
+static int device_release(struct inode *inode, struct file *file)
+{
+	/*
+	 * Decrement the usage count, or else once you opened the file, you'll
+	 * never get rid of the module.
+	 */
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+/*
+ * Called when the user-space library calls the mmap libc function.
+ * Usage:
+ * lib_timer_va = (void *)mmap(NULL, sizeof(struct timer_info_s),
+ *             PROT_READ | PROT_WRITE, MAP_SHARED | MAP_LOCKED, fd, 0);
+ */
+static int device_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int irq_interval = jiffies_to_usecs(HZ);
+	unsigned long start = vma->vm_start;
+	unsigned long size  = vma->vm_end - vma->vm_start;
+	unsigned long pfn;
+	struct timer_info_s *timer_info = (struct timer_info_s *)
+						_intlat_info->kern_timer_va;
+	static int latAdjust;
+
+	/*
+	 * vIRQs are injected from host every one second, so subtract 1s
+	 * from all latencies to get the real latencies
+	 */
+	pr_debug("irq_interval = %d\n", irq_interval);
+	if (!latAdjust) {
+		timer_info->latency_min -= irq_interval;
+		timer_info->latency_max -= irq_interval;
+		timer_info->latency_total -=
+				(timer_info->no_interrupts*irq_interval);
+		latAdjust = 1;
+	}
+
+	pfn = page_to_pfn(virt_to_page((unsigned long)
+				_intlat_info->kern_timer_va));
+	if (remap_pfn_range(vma, start, pfn, size, vma->vm_page_prot)) {
+		pr_err("remap_pfn_range failed\n");
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+static long device_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int result = -ENOIOCTLCMD;
+
+	switch (cmd) {
+	case INTLAT_CMD_INT:
+		result = 0;
+		break;
+	default:
+		{
+		pr_err("Unknown ioctl: %u\n", cmd);
+		break;
+		}
+	}
+	return result;
+}
+
+void update_latency_timestamp(void)
+{
+	uint64_t irq_latency;
+	struct timer_info_s *timer_info = (struct timer_info_s *)
+						_intlat_info->kern_timer_va;
+
+	if (unlikely(last_timestamp == 0)) {
+		/*
+		 * This is the case where the first nmi irq is injected by
+		 * the nmi command in qemu monitor
+		 */
+		timer_info->no_interrupts = 0;
+		timer_info->latency_min = 10000000;
+		timer_info->latency_max = 0;
+		timer_info->latency_total = 0;
+		last_timestamp = jiffies;
+	} else {
+		/* TODO: more accurate time reading for accurate latency */
+
+		/*
+		 * VIRQ is injected every second, so time from the last
+		 * irq includes injection interval and irq latency
+		 */
+		irq_latency = jiffies - last_timestamp;
+
+		/*
+		 * Sometime the host injects 2 virqs at the same time; one
+		 * to each core. Filter out repeated virq injected to the
+		 * other core
+		 */
+		if (!irq_latency)
+			return;
+
+		/* Update latencies */
+		last_timestamp = jiffies;
+		irq_latency = jiffies_to_usecs(irq_latency);
+		if (irq_latency > timer_info->latency_max)
+			timer_info->latency_max = irq_latency;
+		if (irq_latency < timer_info->latency_min)
+			timer_info->latency_min = irq_latency;
+		timer_info->no_interrupts++;
+		timer_info->latency_total += irq_latency;
+		/* Print out debug info every 100 interrupts */
+		pr_debug("Num of interrupts: %lu, min: %lu, avg: %lu, max: %lu\n",
+			timer_info->no_interrupts, timer_info->latency_min,
+			timer_info->latency_total/timer_info->no_interrupts,
+			timer_info->latency_max);
+	}
+}
+
+static int __init latInt_init_module(void)
+{
+	_intlat_info = kzalloc(sizeof(struct intlat_info_s), GFP_KERNEL);
+	if (_intlat_info == NULL) {
+		pr_err("Failed to allocate memory for for intlat_info\n");
+		return -ENOMEM;
+	}
+
+	/* Allocate the shared memory for timer info */
+	_intlat_info->kern_timer_ptr = kzalloc(((sizeof(struct timer_info_s)/
+					PAGE_SIZE)+3)*PAGE_SIZE, GFP_KERNEL);
+	if (_intlat_info->kern_timer_ptr == NULL) {
+		pr_err("Failed to allocate memory for for kern_timer_ptr\n");
+		kfree(_intlat_info);
+		return -ENOMEM;
+	}
+	_intlat_info->kern_timer_va = (int *)((((unsigned long)
+		_intlat_info->kern_timer_ptr) + PAGE_SIZE - 1) & PAGE_MASK);
+	SetPageReserved(virt_to_page((
+				(unsigned long)_intlat_info->kern_timer_va)));
+
+	_major = register_chrdev(0, DEVICE_NAME, &fops);
+	if (_major < 0) {
+		pr_err("Registering char device failed with %d for master\n",
+									_major);
+		ClearPageReserved(virt_to_page(
+				(unsigned long)_intlat_info->kern_timer_va));
+		kfree(_intlat_info->kern_timer_ptr);
+		kfree(_intlat_info);
+		return _major;
+	} else
+		pr_debug("Char Dev Drv with _major %d\n", _major);
+
+	return 0;
+}
+
+static void latInt_cleanup_module(void)
+{
+	/* Clear reserved page for timer info */
+	ClearPageReserved(virt_to_page(
+				(unsigned long)_intlat_info->kern_timer_va));
+	kfree(_intlat_info->kern_timer_ptr);
+	kfree(_intlat_info);
+
+	/* Unregister the device */
+	unregister_chrdev(_major, DEVICE_NAME);
+}
+
+module_init(latInt_init_module);
+module_exit(latInt_cleanup_module);
+
+MODULE_AUTHOR("Wind River");
+MODULE_DESCRIPTION("Interrupt Latency Testing Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.1");
diff --git a/arch/x86/kernel/intlatdrv.h b/arch/x86/kernel/intlatdrv.h
new file mode 100644
index 0000000..b0f36df
--- /dev/null
+++ b/arch/x86/kernel/intlatdrv.h
@@ -0,0 +1,38 @@
+/*
+ * Virtual Interrupt Latency Measurement Driver
+ *
+ * Copyright (c) 2013 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#ifndef INTLATDRV_H
+#define INTLATDRV_H
+
+#define INTLAT_CMD_MAGIC			'e'
+#define INTLAT_CMD_INT				(0)
+#define INTLAT_IOCTL_INT \
+		_IOWR(INTLAT_CMD_MAGIC, INTLAT_CMD_INT, unsigned int)
+
+struct timer_info_s {
+	uint64_t latency_min;
+	uint64_t latency_max;
+	uint64_t latency_total;
+	uint64_t no_interrupts;
+};
+
+extern void update_latency_timestamp(void);
+
+#endif
diff --git a/arch/x86/kernel/nmi.c b/arch/x86/kernel/nmi.c
index 32856fa..6b88367 100644
--- a/arch/x86/kernel/nmi.c
+++ b/arch/x86/kernel/nmi.c
@@ -31,6 +31,10 @@
 #include <asm/nmi.h>
 #include <asm/x86_init.h>
 
+#ifdef CONFIG_VIRT_INT_LAT
+#include "intlatdrv.h"
+#endif
+
 #define NMI_MAX_NAMELEN	16
 struct nmiaction {
 	struct list_head list;
@@ -507,6 +511,9 @@ static inline void nmi_nesting_postprocess(void)
 dotraplinkage notrace __kprobes void
 do_nmi(struct pt_regs *regs, long error_code)
 {
+#ifdef CONFIG_VIRT_INT_LAT
+	update_latency_timestamp();
+#endif
 	nmi_nesting_preprocess(regs);
 
 	nmi_enter();
-- 
1.8.3.1

