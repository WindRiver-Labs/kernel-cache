From 7b16e2f674c79c9663e49a6b5d0046ca9aa2f850 Mon Sep 17 00:00:00 2001
From: Nam Ninh <nam.ninh@windriver.com>
Date: Mon, 21 Oct 2013 12:43:08 -0400
Subject: [PATCH] KVM-guest: vIRQ latency measurement driver

This driver calculates the average latency of vIRQs injected from
OVP KVM host to OVP KVM guest. Before injecting the virq, the host
reads the guest TSC timestamp and sends it back to the guest via a
MSR reserved buffer shared between host and guest. When the guest
receives the virq, it reads the current TSC counter and the
injecting TSC counter from the shared buffer sent from the host,
then calculate the delta for the latency. An application needs to
mmap timer information structure to user-space in order to read the
latency.

Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index aac357a4cd5c..3fe7a5cd6d87 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -704,6 +704,14 @@ config KVM_DEBUG_FS
 	  Statistics are displayed in debugfs filesystem. Enabling this option
 	  may incur significant overhead.
 
+config VIRT_INT_LAT_GUEST
+	bool "Measure interrupt latency from KVM host to guest"
+	depends on KVM_GUEST
+	default n
+	---help---
+	  This is a generic driver to measure minimum, average and maximum
+	  latency from KVM host to guest for X86 platform.
+
 source "arch/x86/lguest/Kconfig"
 
 config PARAVIRT_TIME_ACCOUNTING
diff --git a/arch/x86/include/asm/paravirt.h b/arch/x86/include/asm/paravirt.h
index 8957810ad7d1..5d09df2190ac 100644
--- a/arch/x86/include/asm/paravirt.h
+++ b/arch/x86/include/asm/paravirt.h
@@ -283,6 +283,21 @@ static inline void load_gs_index(unsigned int gs)
 }
 #endif
 
+#ifdef CONFIG_VIRT_INT_LAT_GUEST
+/*
+ * KVM host reads TSC timestamp from guest before it injects
+ * the virq to the guest. It then put the timestamp to a MSR
+ * shared memory buffer. This function is called by the guest
+ * to read out the start timestamp from this shared memory
+ * to calculate the delta with the current TSC for latency
+ * calculation
+ */
+static inline u64 paravirt_read_virq_start_tsc(int cpu)
+{
+	return PVOP_CALL1(u64, pv_time_ops.read_tsc, cpu);
+}
+#endif
+
 static inline void write_ldt_entry(struct desc_struct *dt, int entry,
 				   const void *desc)
 {
diff --git a/arch/x86/include/asm/paravirt_types.h b/arch/x86/include/asm/paravirt_types.h
index f7b0b5c112f2..f310ca81e63b 100644
--- a/arch/x86/include/asm/paravirt_types.h
+++ b/arch/x86/include/asm/paravirt_types.h
@@ -98,6 +98,7 @@ struct pv_time_ops {
 	unsigned long long (*sched_clock)(void);
 	unsigned long long (*steal_clock)(int cpu);
 	unsigned long (*get_tsc_khz)(void);
+	unsigned long long (*read_tsc)(int cpu);
 };
 
 struct pv_cpu_ops {
diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index 9bcd0b56ca17..61f28d44117e 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -112,6 +112,7 @@ obj-$(CONFIG_PERF_EVENTS)		+= perf_regs.o
 obj-$(CONFIG_TRACING)			+= tracepoint.o
 obj-$(CONFIG_IOSF_MBI)			+= iosf_mbi.o
 obj-$(CONFIG_PMC_ATOM)			+= pmc_atom.o
+obj-$(CONFIG_VIRT_INT_LAT_GUEST)	+= intlatdrv.o
 
 ###
 # 64 bit specific files
diff --git a/arch/x86/kernel/intlatdrv.c b/arch/x86/kernel/intlatdrv.c
new file mode 100644
index 000000000000..c7551a9e8d66
--- /dev/null
+++ b/arch/x86/kernel/intlatdrv.c
@@ -0,0 +1,210 @@
+/*
+ * Virtual Interrupt Latency Measurement Driver
+ *
+ * Copyright (c) 2013 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/fs.h>
+#include <linux/pci.h>
+#include <linux/jiffies.h>
+#include <asm/paravirt.h>
+#include <asm/msr.h>
+
+#include "intlatdrv.h"
+
+#define DEVICE_NAME				"vintlat"
+
+struct intlat_info_s {
+	void *kern_timer_va;
+	void *kern_timer_ptr;
+};
+
+static int _major;
+static struct intlat_info_s *_intlat_info;
+
+static int device_open(struct inode *, struct file *);
+static int device_release(struct inode *, struct file *);
+static int device_mmap(struct file *file, struct vm_area_struct *vma);
+static long device_ioctl(struct file *file, unsigned int cmd,
+							unsigned long arg);
+
+static const struct file_operations fops = {
+	.open = device_open,
+	.release = device_release,
+	.mmap = device_mmap,
+	.unlocked_ioctl = device_ioctl
+};
+
+/* Called when a process tries to open the device file. */
+static int device_open(struct inode *inode, struct file *file)
+{
+	pr_debug("Device open");
+	if (try_module_get(THIS_MODULE))
+		return 0;
+	return -EBUSY;
+}
+
+/*
+ * Called when a process closes the device file.
+ */
+static int device_release(struct inode *inode, struct file *file)
+{
+	/*
+	 * Decrement the usage count, or else once you opened the file, you'll
+	 * never get rid of the module.
+	 */
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+/*
+ * Called when the user-space library calls the mmap libc function.
+ * Usage:
+ * lib_timer_va = (void *)mmap(NULL, sizeof(struct timer_info_s),
+ *             PROT_READ | PROT_WRITE, MAP_SHARED | MAP_LOCKED, fd, 0);
+ */
+static int device_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long start = vma->vm_start;
+	unsigned long size  = vma->vm_end - vma->vm_start;
+	unsigned long pfn;
+
+	pfn = page_to_pfn(virt_to_page((unsigned long)
+				_intlat_info->kern_timer_va));
+	if (remap_pfn_range(vma, start, pfn, size, vma->vm_page_prot)) {
+		pr_err("remap_pfn_range failed\n");
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+static long device_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int result = -ENOIOCTLCMD;
+
+	switch (cmd) {
+	case INTLAT_CMD_INT:
+		result = 0;
+		break;
+	default:
+		{
+		pr_err("Unknown ioctl: %u\n", cmd);
+		break;
+		}
+	}
+	return result;
+}
+
+void update_latency_timestamp(void)
+{
+	static int initialized;
+	uint64_t irq_latency, start_tsc, current_tsc;
+	struct timer_info_s *timer_info = (struct timer_info_s *)
+						_intlat_info->kern_timer_va;
+
+	if (unlikely(!initialized)) {
+		timer_info->latency_min = ~0ULL;
+		timer_info->latency_max = 0;
+		timer_info->latency_total = 0;
+		initialized = 1;
+		return;
+	} else {
+		/* Calculate latency */
+		start_tsc = paravirt_read_virq_start_tsc(smp_processor_id());
+		rdtscll(current_tsc);
+		if (likely(current_tsc > start_tsc))
+			irq_latency = current_tsc - start_tsc;
+		else
+			/* TSC rollover */
+			irq_latency = (current_tsc + (~0ULL - start_tsc));
+
+		/* Update statistics */
+		if (irq_latency > timer_info->latency_max)
+			timer_info->latency_max = irq_latency;
+		if (irq_latency < timer_info->latency_min)
+			timer_info->latency_min = irq_latency;
+		timer_info->latency_total += irq_latency;
+		timer_info->no_interrupts++;
+	}
+	/* Print out debug info */
+	pr_debug("Num of interrupts: %llu, current latency: %llu, " \
+			"min: %llu, avg: %llu, max: %llu\n",
+			timer_info->no_interrupts, irq_latency,
+			timer_info->latency_min,
+			timer_info->latency_total/timer_info->no_interrupts,
+			timer_info->latency_max);
+}
+
+static int __init latInt_init_module(void)
+{
+	_intlat_info = kzalloc(sizeof(struct intlat_info_s), GFP_KERNEL);
+	if (_intlat_info == NULL) {
+		pr_err("Failed to allocate memory for for intlat_info\n");
+		return -ENOMEM;
+	}
+
+	/* Allocate the shared memory for timer info */
+	_intlat_info->kern_timer_ptr = kzalloc(((sizeof(struct timer_info_s)/
+					PAGE_SIZE)+3)*PAGE_SIZE, GFP_KERNEL);
+	if (_intlat_info->kern_timer_ptr == NULL) {
+		pr_err("Failed to allocate memory for for kern_timer_ptr\n");
+		kfree(_intlat_info);
+		return -ENOMEM;
+	}
+	_intlat_info->kern_timer_va = (int *)((((unsigned long)
+		_intlat_info->kern_timer_ptr) + PAGE_SIZE - 1) & PAGE_MASK);
+	SetPageReserved(virt_to_page((
+				(unsigned long)_intlat_info->kern_timer_va)));
+
+	_major = register_chrdev(0, DEVICE_NAME, &fops);
+	if (_major < 0) {
+		pr_err("Registering char device failed with %d for master\n",
+									_major);
+		ClearPageReserved(virt_to_page(
+				(unsigned long)_intlat_info->kern_timer_va));
+		kfree(_intlat_info->kern_timer_ptr);
+		kfree(_intlat_info);
+		return _major;
+	} else
+		pr_debug("Char Dev Drv with _major %d\n", _major);
+
+	return 0;
+}
+
+static void latInt_cleanup_module(void)
+{
+	/* Clear reserved page for timer info */
+	ClearPageReserved(virt_to_page(
+				(unsigned long)_intlat_info->kern_timer_va));
+	kfree(_intlat_info->kern_timer_ptr);
+	kfree(_intlat_info);
+
+	/* Unregister the device */
+	unregister_chrdev(_major, DEVICE_NAME);
+}
+
+module_init(latInt_init_module);
+module_exit(latInt_cleanup_module);
+
+MODULE_AUTHOR("Wind River");
+MODULE_DESCRIPTION("Interrupt Latency Testing Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.1");
diff --git a/arch/x86/kernel/intlatdrv.h b/arch/x86/kernel/intlatdrv.h
new file mode 100644
index 000000000000..b0f36dfd793f
--- /dev/null
+++ b/arch/x86/kernel/intlatdrv.h
@@ -0,0 +1,38 @@
+/*
+ * Virtual Interrupt Latency Measurement Driver
+ *
+ * Copyright (c) 2013 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#ifndef INTLATDRV_H
+#define INTLATDRV_H
+
+#define INTLAT_CMD_MAGIC			'e'
+#define INTLAT_CMD_INT				(0)
+#define INTLAT_IOCTL_INT \
+		_IOWR(INTLAT_CMD_MAGIC, INTLAT_CMD_INT, unsigned int)
+
+struct timer_info_s {
+	uint64_t latency_min;
+	uint64_t latency_max;
+	uint64_t latency_total;
+	uint64_t no_interrupts;
+};
+
+extern void update_latency_timestamp(void);
+
+#endif
diff --git a/arch/x86/kernel/kvm.c b/arch/x86/kernel/kvm.c
index 29a2820b67fb..8de0324fb56b 100644
--- a/arch/x86/kernel/kvm.c
+++ b/arch/x86/kernel/kvm.c
@@ -332,6 +332,32 @@ static void kvm_guest_apic_eoi_write(u32 reg, u32 val)
 	apic_write(APIC_EOI, APIC_EOI_ACK);
 }
 
+#ifdef CONFIG_VIRT_INT_LAT_GUEST
+static DEFINE_PER_CPU(u64, kvm_guest_tsc);
+static void kvm_init_read_tsc_area(void)
+{
+	int cpu = smp_processor_id();
+	u64 *tsc = &per_cpu(kvm_guest_tsc, cpu);
+
+	wrmsrl(MSR_KVM_GUEST_TSC, __pa(tsc));
+	printk(KERN_INFO "register_inject_tsc: cpu %d, msr %lx\n",
+						cpu, __pa(tsc));
+}
+
+static u64 kvm_read_inject_tsc(int cpu)
+{
+	u64 tsc;
+
+	tsc = per_cpu(kvm_guest_tsc, cpu);
+	/*
+	 * Make sure there is no reordering between reading and
+	 * writing to the shared buffer.
+	 */
+	rmb();
+	return tsc;
+}
+#endif
+
 void kvm_guest_cpu_init(void)
 {
 	if (!kvm_para_available())
@@ -361,6 +387,10 @@ void kvm_guest_cpu_init(void)
 
 	if (has_steal_clock)
 		kvm_register_steal_time();
+
+#ifdef CONFIG_VIRT_INT_LAT_GUEST
+	kvm_init_read_tsc_area();
+#endif
 }
 
 static void kvm_pv_disable_apf(void)
@@ -502,6 +532,10 @@ void __init kvm_guest_init(void)
 	if (kvmclock_vsyscall)
 		kvm_setup_vsyscall_timeinfo();
 
+#ifdef CONFIG_VIRT_INT_LAT_GUEST
+	pv_time_ops.read_tsc = kvm_read_inject_tsc;
+#endif
+
 #ifdef CONFIG_SMP
 	smp_ops.smp_prepare_boot_cpu = kvm_smp_prepare_boot_cpu;
 	register_cpu_notifier(&kvm_cpu_notifier);
diff --git a/arch/x86/kernel/nmi.c b/arch/x86/kernel/nmi.c
index d05bd2e2ee91..84f00366adfc 100644
--- a/arch/x86/kernel/nmi.c
+++ b/arch/x86/kernel/nmi.c
@@ -33,6 +33,10 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/nmi.h>
 
+#ifdef CONFIG_VIRT_INT_LAT_GUEST
+#include "intlatdrv.h"
+#endif
+
 struct nmi_desc {
 	spinlock_t lock;
 	struct list_head head;
@@ -292,6 +296,11 @@ unknown_nmi_error(unsigned char reason, struct pt_regs *regs)
 
 	__this_cpu_add(nmi_stats.unknown, 1);
 
+
+	/*
+	 * Quiet these messages when the virq latency test is run
+	 */
+#ifndef CONFIG_VIRT_INT_LAT_GUEST
 	pr_emerg("Uhhuh. NMI received for unknown reason %02x on CPU %d.\n",
 		 reason, smp_processor_id());
 
@@ -300,6 +309,7 @@ unknown_nmi_error(unsigned char reason, struct pt_regs *regs)
 		panic("NMI: Not continuing");
 
 	pr_emerg("Dazed and confused, but trying to continue\n");
+#endif
 }
 NOKPROBE_SYMBOL(unknown_nmi_error);
 
@@ -489,6 +499,10 @@ do_nmi(struct pt_regs *regs, long error_code)
 	this_cpu_write(nmi_cr2, read_cr2());
 nmi_restart:
 
+#ifdef CONFIG_VIRT_INT_LAT_GUEST
+	update_latency_timestamp();
+#endif
+
 #ifdef CONFIG_X86_64
 	/*
 	 * If we interrupted a breakpoint, it is possible that
-- 
2.5.0

