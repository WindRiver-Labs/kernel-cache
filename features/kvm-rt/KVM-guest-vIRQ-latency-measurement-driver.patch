From e7a8fbf18f132b237083c6ad4fa6015e9cc9df3f Mon Sep 17 00:00:00 2001
From: Nam Ninh <nam.ninh@windriver.com>
Date: Mon, 21 Oct 2013 12:43:08 -0400
Subject: [PATCH] KVM-guest: vIRQ latency measurement driver

This driver calculates the average latency of vIRQs injected from
OVP KVM host to OVP KVM guest. Before injecting the virq, the host
reads the guest TSC timestamp and sends it back to the guest via a
MSR reserved buffer shared between host and guest. When the guest
receives the virq, it reads the current TSC counter and the
injecting TSC counter from the shared buffer sent from the host,
then calculate the delta for the latency. An application needs to
mmap timer information structure to user-space in order to read the
latency.

Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 1d4b06c..ba8f7b0 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -586,6 +586,14 @@ config KVM_GUEST
 	  This option enables various optimizations for running under the KVM
 	  hypervisor.
 
+config VIRT_INT_LAT_GUEST
+	bool "Measure interrupt latency from KVM host to guest"
+	depends on KVM_GUEST
+	default n
+	---help---
+	  This is a generic driver to measure minimum, average and maximum
+	  latency from KVM host to guest for X86 platform.
+
 source "arch/x86/lguest/Kconfig"
 
 config PARAVIRT
diff --git a/arch/x86/include/asm/paravirt.h b/arch/x86/include/asm/paravirt.h
index 25e9734..ded6f59 100644
--- a/arch/x86/include/asm/paravirt.h
+++ b/arch/x86/include/asm/paravirt.h
@@ -324,6 +324,21 @@ static inline void load_gs_index(unsigned int gs)
 }
 #endif
 
+#ifdef CONFIG_VIRT_INT_LAT_GUEST
+/*
+ * KVM host reads TSC timestamp from guest before it injects
+ * the virq to the guest. It then put the timestamp to a MSR
+ * shared memory buffer. This function is called by the guest
+ * to read out the start timestamp from this shared memory
+ * to calculate the delta with the current TSC for latency
+ * calculation
+ */
+static inline u64 paravirt_read_virq_start_tsc(int cpu)
+{
+	return PVOP_CALL1(u64, pv_time_ops.read_tsc, cpu);
+}
+#endif
+
 static inline void write_ldt_entry(struct desc_struct *dt, int entry,
 				   const void *desc)
 {
diff --git a/arch/x86/include/asm/paravirt_types.h b/arch/x86/include/asm/paravirt_types.h
index faf2c04..ae49972 100644
--- a/arch/x86/include/asm/paravirt_types.h
+++ b/arch/x86/include/asm/paravirt_types.h
@@ -98,6 +98,7 @@ struct pv_time_ops {
 	unsigned long long (*sched_clock)(void);
 	unsigned long long (*steal_clock)(int cpu);
 	unsigned long (*get_tsc_khz)(void);
+	unsigned long long (*read_tsc)(int cpu);
 };
 
 struct pv_cpu_ops {
diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index 532d2e0..b1d3096 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -101,6 +101,7 @@ obj-$(CONFIG_X86_CHECK_BIOS_CORRUPTION) += check.o
 
 obj-$(CONFIG_SWIOTLB)			+= pci-swiotlb.o
 obj-$(CONFIG_OF)			+= devicetree.o
+obj-$(CONFIG_VIRT_INT_LAT_GUEST)		+= intlatdrv.o
 
 ###
 # 64 bit specific files
diff --git a/arch/x86/kernel/intlatdrv.c b/arch/x86/kernel/intlatdrv.c
new file mode 100644
index 0000000..c7551a9
--- /dev/null
+++ b/arch/x86/kernel/intlatdrv.c
@@ -0,0 +1,210 @@
+/*
+ * Virtual Interrupt Latency Measurement Driver
+ *
+ * Copyright (c) 2013 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/fs.h>
+#include <linux/pci.h>
+#include <linux/jiffies.h>
+#include <asm/paravirt.h>
+#include <asm/msr.h>
+
+#include "intlatdrv.h"
+
+#define DEVICE_NAME				"vintlat"
+
+struct intlat_info_s {
+	void *kern_timer_va;
+	void *kern_timer_ptr;
+};
+
+static int _major;
+static struct intlat_info_s *_intlat_info;
+
+static int device_open(struct inode *, struct file *);
+static int device_release(struct inode *, struct file *);
+static int device_mmap(struct file *file, struct vm_area_struct *vma);
+static long device_ioctl(struct file *file, unsigned int cmd,
+							unsigned long arg);
+
+static const struct file_operations fops = {
+	.open = device_open,
+	.release = device_release,
+	.mmap = device_mmap,
+	.unlocked_ioctl = device_ioctl
+};
+
+/* Called when a process tries to open the device file. */
+static int device_open(struct inode *inode, struct file *file)
+{
+	pr_debug("Device open");
+	if (try_module_get(THIS_MODULE))
+		return 0;
+	return -EBUSY;
+}
+
+/*
+ * Called when a process closes the device file.
+ */
+static int device_release(struct inode *inode, struct file *file)
+{
+	/*
+	 * Decrement the usage count, or else once you opened the file, you'll
+	 * never get rid of the module.
+	 */
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+/*
+ * Called when the user-space library calls the mmap libc function.
+ * Usage:
+ * lib_timer_va = (void *)mmap(NULL, sizeof(struct timer_info_s),
+ *             PROT_READ | PROT_WRITE, MAP_SHARED | MAP_LOCKED, fd, 0);
+ */
+static int device_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long start = vma->vm_start;
+	unsigned long size  = vma->vm_end - vma->vm_start;
+	unsigned long pfn;
+
+	pfn = page_to_pfn(virt_to_page((unsigned long)
+				_intlat_info->kern_timer_va));
+	if (remap_pfn_range(vma, start, pfn, size, vma->vm_page_prot)) {
+		pr_err("remap_pfn_range failed\n");
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+static long device_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int result = -ENOIOCTLCMD;
+
+	switch (cmd) {
+	case INTLAT_CMD_INT:
+		result = 0;
+		break;
+	default:
+		{
+		pr_err("Unknown ioctl: %u\n", cmd);
+		break;
+		}
+	}
+	return result;
+}
+
+void update_latency_timestamp(void)
+{
+	static int initialized;
+	uint64_t irq_latency, start_tsc, current_tsc;
+	struct timer_info_s *timer_info = (struct timer_info_s *)
+						_intlat_info->kern_timer_va;
+
+	if (unlikely(!initialized)) {
+		timer_info->latency_min = ~0ULL;
+		timer_info->latency_max = 0;
+		timer_info->latency_total = 0;
+		initialized = 1;
+		return;
+	} else {
+		/* Calculate latency */
+		start_tsc = paravirt_read_virq_start_tsc(smp_processor_id());
+		rdtscll(current_tsc);
+		if (likely(current_tsc > start_tsc))
+			irq_latency = current_tsc - start_tsc;
+		else
+			/* TSC rollover */
+			irq_latency = (current_tsc + (~0ULL - start_tsc));
+
+		/* Update statistics */
+		if (irq_latency > timer_info->latency_max)
+			timer_info->latency_max = irq_latency;
+		if (irq_latency < timer_info->latency_min)
+			timer_info->latency_min = irq_latency;
+		timer_info->latency_total += irq_latency;
+		timer_info->no_interrupts++;
+	}
+	/* Print out debug info */
+	pr_debug("Num of interrupts: %llu, current latency: %llu, " \
+			"min: %llu, avg: %llu, max: %llu\n",
+			timer_info->no_interrupts, irq_latency,
+			timer_info->latency_min,
+			timer_info->latency_total/timer_info->no_interrupts,
+			timer_info->latency_max);
+}
+
+static int __init latInt_init_module(void)
+{
+	_intlat_info = kzalloc(sizeof(struct intlat_info_s), GFP_KERNEL);
+	if (_intlat_info == NULL) {
+		pr_err("Failed to allocate memory for for intlat_info\n");
+		return -ENOMEM;
+	}
+
+	/* Allocate the shared memory for timer info */
+	_intlat_info->kern_timer_ptr = kzalloc(((sizeof(struct timer_info_s)/
+					PAGE_SIZE)+3)*PAGE_SIZE, GFP_KERNEL);
+	if (_intlat_info->kern_timer_ptr == NULL) {
+		pr_err("Failed to allocate memory for for kern_timer_ptr\n");
+		kfree(_intlat_info);
+		return -ENOMEM;
+	}
+	_intlat_info->kern_timer_va = (int *)((((unsigned long)
+		_intlat_info->kern_timer_ptr) + PAGE_SIZE - 1) & PAGE_MASK);
+	SetPageReserved(virt_to_page((
+				(unsigned long)_intlat_info->kern_timer_va)));
+
+	_major = register_chrdev(0, DEVICE_NAME, &fops);
+	if (_major < 0) {
+		pr_err("Registering char device failed with %d for master\n",
+									_major);
+		ClearPageReserved(virt_to_page(
+				(unsigned long)_intlat_info->kern_timer_va));
+		kfree(_intlat_info->kern_timer_ptr);
+		kfree(_intlat_info);
+		return _major;
+	} else
+		pr_debug("Char Dev Drv with _major %d\n", _major);
+
+	return 0;
+}
+
+static void latInt_cleanup_module(void)
+{
+	/* Clear reserved page for timer info */
+	ClearPageReserved(virt_to_page(
+				(unsigned long)_intlat_info->kern_timer_va));
+	kfree(_intlat_info->kern_timer_ptr);
+	kfree(_intlat_info);
+
+	/* Unregister the device */
+	unregister_chrdev(_major, DEVICE_NAME);
+}
+
+module_init(latInt_init_module);
+module_exit(latInt_cleanup_module);
+
+MODULE_AUTHOR("Wind River");
+MODULE_DESCRIPTION("Interrupt Latency Testing Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.1");
diff --git a/arch/x86/kernel/intlatdrv.h b/arch/x86/kernel/intlatdrv.h
new file mode 100644
index 0000000..b0f36df
--- /dev/null
+++ b/arch/x86/kernel/intlatdrv.h
@@ -0,0 +1,38 @@
+/*
+ * Virtual Interrupt Latency Measurement Driver
+ *
+ * Copyright (c) 2013 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#ifndef INTLATDRV_H
+#define INTLATDRV_H
+
+#define INTLAT_CMD_MAGIC			'e'
+#define INTLAT_CMD_INT				(0)
+#define INTLAT_IOCTL_INT \
+		_IOWR(INTLAT_CMD_MAGIC, INTLAT_CMD_INT, unsigned int)
+
+struct timer_info_s {
+	uint64_t latency_min;
+	uint64_t latency_max;
+	uint64_t latency_total;
+	uint64_t no_interrupts;
+};
+
+extern void update_latency_timestamp(void);
+
+#endif
diff --git a/arch/x86/kernel/kvm.c b/arch/x86/kernel/kvm.c
index 1fad065..9600050 100644
--- a/arch/x86/kernel/kvm.c
+++ b/arch/x86/kernel/kvm.c
@@ -315,6 +315,32 @@ static void kvm_guest_apic_eoi_write(u32 reg, u32 val)
 	apic_write(APIC_EOI, APIC_EOI_ACK);
 }
 
+#ifdef CONFIG_VIRT_INT_LAT_GUEST
+static DEFINE_PER_CPU(u64, kvm_guest_tsc);
+static void kvm_init_read_tsc_area(void)
+{
+	int cpu = smp_processor_id();
+	u64 *tsc = &per_cpu(kvm_guest_tsc, cpu);
+
+	wrmsrl(MSR_KVM_GUEST_TSC, __pa(tsc));
+	printk(KERN_INFO "register_inject_tsc: cpu %d, msr %lx\n",
+						cpu, __pa(tsc));
+}
+
+static u64 kvm_read_inject_tsc(int cpu)
+{
+	u64 tsc;
+
+	tsc = per_cpu(kvm_guest_tsc, cpu);
+	/*
+	 * Make sure there is no reordering between reading and
+	 * writing to the shared buffer.
+	 */
+	rmb();
+	return tsc;
+}
+#endif
+
 void __cpuinit kvm_guest_cpu_init(void)
 {
 	if (!kvm_para_available())
@@ -343,6 +369,10 @@ void __cpuinit kvm_guest_cpu_init(void)
 
 	if (has_steal_clock)
 		kvm_register_steal_time();
+
+#ifdef CONFIG_VIRT_INT_LAT_GUEST
+	kvm_init_read_tsc_area();
+#endif
 }
 
 static void kvm_pv_disable_apf(void)
@@ -482,6 +512,10 @@ void __init kvm_guest_init(void)
 	if (kvm_para_has_feature(KVM_FEATURE_PV_EOI))
 		apic_set_eoi_write(kvm_guest_apic_eoi_write);
 
+#ifdef CONFIG_VIRT_INT_LAT_GUEST
+	pv_time_ops.read_tsc = kvm_read_inject_tsc;
+#endif
+
 #ifdef CONFIG_SMP
 	smp_ops.smp_prepare_boot_cpu = kvm_smp_prepare_boot_cpu;
 	register_cpu_notifier(&kvm_cpu_notifier);
diff --git a/arch/x86/kernel/nmi.c b/arch/x86/kernel/nmi.c
index 32856fa..5a8442d 100644
--- a/arch/x86/kernel/nmi.c
+++ b/arch/x86/kernel/nmi.c
@@ -31,6 +31,10 @@
 #include <asm/nmi.h>
 #include <asm/x86_init.h>
 
+#ifdef CONFIG_VIRT_INT_LAT_GUEST
+#include "intlatdrv.h"
+#endif
+
 #define NMI_MAX_NAMELEN	16
 struct nmiaction {
 	struct list_head list;
@@ -292,6 +296,11 @@ unknown_nmi_error(unsigned char reason, struct pt_regs *regs)
 		return;
 	}
 #endif
+
+	/*
+	 * Quiet these messages when the virq latency test is run
+	 */
+#ifndef CONFIG_VIRT_INT_LAT_GUEST
 	pr_emerg("Uhhuh. NMI received for unknown reason %02x on CPU %d.\n",
 		 reason, smp_processor_id());
 
@@ -300,6 +309,7 @@ unknown_nmi_error(unsigned char reason, struct pt_regs *regs)
 		panic("NMI: Not continuing");
 
 	pr_emerg("Dazed and confused, but trying to continue\n");
+#endif
 }
 
 static DEFINE_PER_CPU(bool, swallow_nmi);
@@ -507,6 +517,9 @@ static inline void nmi_nesting_postprocess(void)
 dotraplinkage notrace __kprobes void
 do_nmi(struct pt_regs *regs, long error_code)
 {
+#ifdef CONFIG_VIRT_INT_LAT_GUEST
+	update_latency_timestamp();
+#endif
 	nmi_nesting_preprocess(regs);
 
 	nmi_enter();
-- 
1.8.4

