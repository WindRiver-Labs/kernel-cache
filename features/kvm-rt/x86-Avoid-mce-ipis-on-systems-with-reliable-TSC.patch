From 0d1e65f20d29719b299b37b24c9f3f8f389a690f Mon Sep 17 00:00:00 2001
From: Thomas Gleixner <tglx@linutronix.de>
Date: Fri, 6 Apr 2012 21:20:07 +0100
Subject: [PATCH] x86: Avoid mce ipis on systems with reliable TSC

It's pointless to grab a timestamp with an IPI if we have a reliable
TSC.

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Signed-off-by: Michael Barabanov <michael.barabanov@windriver.com>

diff --git a/arch/x86/kernel/cpu/mcheck/mce.c b/arch/x86/kernel/cpu/mcheck/mce.c
index 91466f5..e615e62 100644
--- a/arch/x86/kernel/cpu/mcheck/mce.c
+++ b/arch/x86/kernel/cpu/mcheck/mce.c
@@ -1660,17 +1660,21 @@ static int __mce_read_apei(char __user **ubuf, size_t usize)
 	return 0;
 }
 
+extern int tsc_clocksource_reliable;
+
 static ssize_t mce_chrdev_read(struct file *filp, char __user *ubuf,
 				size_t usize, loff_t *off)
 {
 	char __user *buf = ubuf;
-	unsigned long *cpu_tsc;
+	unsigned long now = 0, *cpu_tsc = NULL;
 	unsigned prev, next;
 	int i, err;
 
-	cpu_tsc = kmalloc(nr_cpu_ids * sizeof(long), GFP_KERNEL);
-	if (!cpu_tsc)
-		return -ENOMEM;
+	if (!tsc_clocksource_reliable) {
+		cpu_tsc = kmalloc(nr_cpu_ids * sizeof(long), GFP_KERNEL);
+		if (!cpu_tsc)
+			return -ENOMEM;
+	}
 
 	mutex_lock(&mce_chrdev_read_mutex);
 
@@ -1720,12 +1724,18 @@ timeout:
 	 * Collect entries that were still getting written before the
 	 * synchronize.
 	 */
-	on_each_cpu(collect_tscs, cpu_tsc, 1);
+	if (!tsc_clocksource_reliable)
+		on_each_cpu(collect_tscs, cpu_tsc, 1);
+	else
+		rdtscll(now);
 
 	for (i = next; i < MCE_LOG_LEN; i++) {
 		struct mce *m = &mcelog.entry[i];
+		unsigned long tsc;
+
+		tsc = tsc_clocksource_reliable ? now : cpu_tsc[m->cpu];
 
-		if (m->finished && m->tsc < cpu_tsc[m->cpu]) {
+		if (m->finished && m->tsc < tsc) {
 			err |= copy_to_user(buf, m, sizeof(*m));
 			smp_rmb();
 			buf += sizeof(*m);
-- 
1.7.9.5

