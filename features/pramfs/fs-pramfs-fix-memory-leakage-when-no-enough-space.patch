From 9db5da257ee49a4b9abc19425e23e8f90ab4292b Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 16 Nov 2011 14:06:55 +0800
Subject: [PATCH 18/18] fs: pramfs: fix memory leakage when no enough space

There are three situations in WRITE when no enough space
as follows:

  1) Just start to write for a new file
       s_free_blocks_count < num + ROWCOL
  2) need a new row if a big file
       s_free_blocks_count < num + ROWNEW
  3) writing in the same row
       s_free_blocks_count < num

In these cases, pram_new_block returns -ENOSPC, and
pram_alloc_blocks will be failure, but some blocks
alloced will become orphans, which have been gotten
in for loop of pram_alloc_blocks.

So we add check if there is enough space before WRITE
in inode scope and return -EFBIG to avoid unnecessary
pram_new_block and memory leakage.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 fs/pramfs/inode.c |   18 +++++++++++++++++-
 fs/pramfs/pram.h  |    7 +++++++
 2 files changed, 24 insertions(+), 1 deletions(-)

diff --git a/fs/pramfs/inode.c b/fs/pramfs/inode.c
index a23e010..537a312 100644
--- a/fs/pramfs/inode.c
+++ b/fs/pramfs/inode.c
@@ -189,6 +189,7 @@ int pram_alloc_blocks(struct inode *inode, int file_blocknr, unsigned int num)
 {
 	struct super_block *sb = inode->i_sb;
 	struct pram_inode *pi = pram_get_inode(sb, inode->i_ino);
+	struct pram_super_block *ps = pram_get_super(sb);
 	int N = sb->s_blocksize >> 3; /* num block ptrs per block */
 	int Nbits = sb->s_blocksize_bits - 3;
 	int first_file_blocknr;
@@ -200,6 +201,11 @@ int pram_alloc_blocks(struct inode *inode, int file_blocknr, unsigned int num)
 	u64 *col;
 
 	if (!pi->i_type.reg.row_block) {
+		if (be32_to_cpu(ps->s_free_blocks_count) < num + ROWCOL) {
+			errval = -EFBIG;
+			goto fail;
+		}
+
 		/* alloc the 2nd order array block */
 		errval = pram_new_block(sb, &blocknr, 1);
 		if (errval) {
@@ -228,6 +234,11 @@ int pram_alloc_blocks(struct inode *inode, int file_blocknr, unsigned int num)
 		 * there is a block allocated for the row.
 		 */
 		if (!row[i]) {
+			if (be32_to_cpu(ps->s_free_blocks_count) < num + ROWNEW) {
+				errval = -EFBIG;
+				goto fail;
+			}
+
 			/* allocate the row block */
 			errval = pram_new_block(sb, &blocknr, 1);
 			if (errval) {
@@ -237,7 +248,12 @@ int pram_alloc_blocks(struct inode *inode, int file_blocknr, unsigned int num)
 			pram_memunlock_block(sb, row);
 			row[i] = cpu_to_be64(pram_get_block_off(sb, blocknr));
 			pram_memlock_block(sb, row);
-		}
+		} else
+			if (be32_to_cpu(ps->s_free_blocks_count) < num) {
+				errval = -EFBIG;
+				goto fail;
+			}
+
 		col = pram_get_block(sb, be64_to_cpu(row[i]));
 
 		first_col_index = (i == first_row_index) ?
diff --git a/fs/pramfs/pram.h b/fs/pramfs/pram.h
index db08fd1..f19a5f8 100644
--- a/fs/pramfs/pram.h
+++ b/fs/pramfs/pram.h
@@ -61,6 +61,13 @@
 /* Flags that are appropriate for non-directories/regular files. */
 #define PRAM_OTHER_FLMASK (FS_NODUMP_FL | FS_NOATIME_FL)
 
+/* As a new regular file, two blocks needed for row and col
+ * pointers to data block
+ */
+#define ROWCOL	2
+/* we need a block for another new row if a big file*/
+#define ROWNEW	1
+
 /* Function Prototypes */
 extern void pram_error_mng(struct super_block * sb, const char * fmt, ...);
 extern int pram_get_and_update_block(struct inode *inode, sector_t iblock,
-- 
1.7.0.4

