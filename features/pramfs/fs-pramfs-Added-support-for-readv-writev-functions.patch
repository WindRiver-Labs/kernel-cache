From 45212b9a120968268267b443adffdbf9bd61b8c5 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 16 Nov 2011 14:06:39 +0800
Subject: [PATCH 02/18] fs: pramfs: Added support for readv/writev functions

Upstream ID d33d562f4e92846e39aaf3780eaa35c0fc1bb646
  git://pramfs.git.sourceforge.net/gitroot/pramfs/pramfs
  From: Marco <marco@ncc-1701-f.site>

Integrated-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 fs/pramfs/file.c |  136 ++++++++++++++++++++++++++++++++++++++++++++++++++---
 1 files changed, 128 insertions(+), 8 deletions(-)

diff --git a/fs/pramfs/file.c b/fs/pramfs/file.c
index a8c4e54..b22d1f3 100644
--- a/fs/pramfs/file.c
+++ b/fs/pramfs/file.c
@@ -23,6 +23,123 @@
 #include "xip.h"
 #include "xattr.h"
 
+/*
+ * The following functions are helper routines to copy to/from
+ * user space and iter over io vectors (mainly for readv/writev).
+ * They are used in the direct IO path.
+ */
+static size_t __pram_iov_copy_from(char *vaddr,
+			const struct iovec *iov, size_t base, size_t bytes)
+{
+	size_t copied = 0, left = 0;
+
+	while (bytes) {
+		char __user *buf = iov->iov_base + base;
+		int copy = min(bytes, iov->iov_len - base);
+
+		base = 0;
+		left = copy_from_user(vaddr, buf, copy);
+		copied += copy;
+		bytes -= copy;
+		vaddr += copy;
+		iov++;
+
+		if (unlikely(left))
+			break;
+	}
+	return copied - left;
+}
+
+static size_t __pram_iov_copy_to(char *vaddr,
+			const struct iovec *iov, size_t base, size_t bytes)
+{
+	size_t copied = 0, left = 0;
+
+	while (bytes) {
+		char __user *buf = iov->iov_base + base;
+		int copy = min(bytes, iov->iov_len - base);
+
+		base = 0;
+		left = copy_to_user(buf, vaddr, copy);
+		copied += copy;
+		bytes -= copy;
+		vaddr += copy;
+		iov++;
+
+		if (unlikely(left))
+			break;
+	}
+	return copied - left;
+}
+
+static size_t pram_iov_copy_from(void *to, struct iov_iter *i, size_t bytes)
+{
+	size_t copied;
+
+	if (likely(i->nr_segs == 1)) {
+		int left;
+		char __user *buf = i->iov->iov_base + i->iov_offset;
+		left = copy_from_user(to, buf, bytes);
+		copied = bytes - left;
+	} else {
+		copied = __pram_iov_copy_from(to, i->iov, i->iov_offset, bytes);
+	}
+
+	return copied;
+}
+
+static size_t pram_iov_copy_to(void *from, struct iov_iter *i, size_t bytes)
+{
+	size_t copied;
+
+	if (likely(i->nr_segs == 1)) {
+		int left;
+		char __user *buf = i->iov->iov_base + i->iov_offset;
+		left = copy_to_user(buf, from, bytes);
+		copied = bytes - left;
+	} else {
+		copied = __pram_iov_copy_to(from, i->iov, i->iov_offset, bytes);
+	}
+
+	return copied;
+}
+
+static size_t __pram_clear_user(const struct iovec *iov, size_t base, size_t bytes)
+{
+	size_t claened = 0, left = 0;
+
+	while (bytes) {
+		char __user *buf = iov->iov_base + base;
+		int clear = min(bytes, iov->iov_len - base);
+
+		base = 0;
+		left = clear_user(buf, clear);
+		claened += clear;
+		bytes -= clear;
+		iov++;
+
+		if (unlikely(left))
+			break;
+	}
+	return claened - left;
+}
+
+static size_t pram_clear_user(struct iov_iter *i, size_t bytes)
+{
+	size_t clear;
+
+	if (likely(i->nr_segs == 1)) {
+		int left;
+		char __user *buf = i->iov->iov_base + i->iov_offset;
+		left = clear_user(buf, bytes);
+		clear = bytes - left;
+	} else {
+		clear = __pram_clear_user(i->iov, i->iov_offset, bytes);
+	}
+
+	return clear;
+}
+
 static int pram_open_file(struct inode *inode, struct file *filp)
 {
 	filp->f_flags |= O_DIRECT;
@@ -40,8 +157,8 @@ ssize_t pram_direct_IO(int rw, struct kiocb *iocb,
 	ssize_t retval = 0;
 	void *tmp = NULL;
 	unsigned long blocknr, blockoff;
+	struct iov_iter iter;
 	int num_blocks, blocksize_mask, blocksize, blocksize_bits;
-	char __user *buf = iov->iov_base;
 	size_t length = iov_length(iov, nr_segs);
 
 	if (length < 0)
@@ -74,6 +191,8 @@ ssize_t pram_direct_IO(int rw, struct kiocb *iocb,
 			goto fail1;
 	}
 
+	iov_iter_init(&iter, iov, nr_segs, length, 0);
+
 	while (length) {
 		int count;
 		u8 *bp = NULL;
@@ -92,21 +211,22 @@ ssize_t pram_direct_IO(int rw, struct kiocb *iocb,
 
 		if (rw == READ) {
 			if (unlikely(hole)) {
-				retval = clear_user(buf, count);
-				if (retval) {
+				retval = pram_clear_user(&iter, count);
+				if (retval != count) {
 					retval = -EFAULT;
 					goto fail1;
 				}
 			} else {
-				retval = copy_to_user(buf, &bp[blockoff], count);
-				if (retval) {
+				retval = pram_iov_copy_to(&bp[blockoff], &iter,
+							  count);
+				if (retval != count) {
 					retval = -EFAULT;
 					goto fail1;
 				}
 			}
 		} else {
-			retval = copy_from_user(tmp, buf, count);
-			if (retval) {
+			retval = pram_iov_copy_from(tmp, &iter, count);
+			if (retval != count) {
 				retval = -EFAULT;
 				goto fail1;
 			}
@@ -117,7 +237,7 @@ ssize_t pram_direct_IO(int rw, struct kiocb *iocb,
 		}
 
 		progress += count;
-		buf += count;
+		iov_iter_advance(&iter, count);
 		length -= count;
 		blockoff = 0;
 		hole = 0;
-- 
1.7.0.4

