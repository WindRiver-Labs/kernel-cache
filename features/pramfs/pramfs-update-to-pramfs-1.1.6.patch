From b0835a71171e056a8692e8c1fbcc179354d7f046 Mon Sep 17 00:00:00 2001
From: Ivar Holmqvist <ivar.holmqvist@windriver.com>
Date: Tue, 23 Mar 2010 05:30:06 -0700
Subject: [PATCH 4/5] pramfs: update to pramfs-1.1.6

Applied pramfs-1.1.6 for 2.6.33. Manual merge fixes from 1.1.5->1.1.6

Signed-off-by: Ivar Holmqvist <ivar.holmqvist@windriver.com>
---
 Documentation/filesystems/pramfs.txt |    7 +++
 Documentation/filesystems/xip.txt    |    2 +
 fs/pramfs/Kconfig                    |    3 +-
 fs/pramfs/balloc.c                   |   20 +++++-----
 fs/pramfs/dir.c                      |   46 +++++++++++-----------
 fs/pramfs/file.c                     |    4 +-
 fs/pramfs/inode.c                    |   68 +++++++++++++++++-----------------
 fs/pramfs/namei.c                    |    4 +-
 fs/pramfs/pram.h                     |   56 +++++++++++++++++-----------
 fs/pramfs/super.c                    |   24 +++++++++---
 fs/pramfs/symlink.c                  |    4 +-
 fs/pramfs/xip.c                      |    4 +-
 include/linux/pram_fs.h              |    1 -
 13 files changed, 138 insertions(+), 105 deletions(-)

diff --git a/Documentation/filesystems/pramfs.txt b/Documentation/filesystems/pramfs.txt
index 579a5e9..b9c9b54 100644
--- a/Documentation/filesystems/pramfs.txt
+++ b/Documentation/filesystems/pramfs.txt
@@ -162,6 +162,13 @@ list at sourceforge: pramfs-devel@lists.sourceforge.net.
 ChangeLog
 =========
 
+1.1.6
+	- kernel 2.6.33
+	- added preempt_enable/disable in pram_{memlock|memunlock}_range in
+	  order to avoid race conditions
+	. replaced pram_unlock_* and pram_lock_* with pram_memlock_* and
+	  pram_memunlock_*
+
 1.1.5
 	- kernel 2.6.31
 	- reworked pram_writeable in order to use the funcions 
diff --git a/Documentation/filesystems/xip.txt b/Documentation/filesystems/xip.txt
index 0466ee5..f15c87d 100644
--- a/Documentation/filesystems/xip.txt
+++ b/Documentation/filesystems/xip.txt
@@ -49,6 +49,8 @@ This address space operation is mutually exclusive with readpage&writepage that
 do page cache read/write operations.
 The following filesystems support it as of today:
 - ext2: the second extended filesystem, see Documentation/filesystems/ext2.txt
+- pramfs: persistent and protected RAM filesystem, see 
+  Documentation/filesystems/pramfs.txt
 
 A set of file operations that do utilize get_xip_page can be found in
 mm/filemap_xip.c . The following file operation implementations are provided:
diff --git a/fs/pramfs/Kconfig b/fs/pramfs/Kconfig
index 338e44a..8d1064a 100644
--- a/fs/pramfs/Kconfig
+++ b/fs/pramfs/Kconfig
@@ -1,6 +1,7 @@
 config PRAMFS
 	tristate "Persistent and Protected RAM file system support"
-	depends on EXPERIMENTAL && CRC16
+	depends on EXPERIMENTAL
+	select CRC16
 	help
 	   If your system has a block of fast (comparable in access speed to
 	   system memory) and non-volatile RAM and you wish to mount a
diff --git a/fs/pramfs/balloc.c b/fs/pramfs/balloc.c
index e21f22c..fe973c0 100644
--- a/fs/pramfs/balloc.c
+++ b/fs/pramfs/balloc.c
@@ -56,16 +56,16 @@ void pram_free_block(struct super_block *sb, int blocknr)
 	bitmap_block = pram_get_block_off(sb, bitmap_bnr);
 	bp = pram_get_block(sb, bitmap_block);
 
-	pram_lock_block(sb, bp);
+	pram_memunlock_block(sb, bp);
 	clear_bit(blocknr, bitmap); /* mark the block free */
-	pram_unlock_block(sb, bp);
+	pram_memlock_block(sb, bp);
 
 	ps = pram_get_super(sb);
-	pram_lock_super(ps);
+	pram_memunlock_super(ps);
 	if (blocknr < be32_to_cpu(ps->s_free_blocknr_hint))
 		ps->s_free_blocknr_hint = cpu_to_be32(blocknr);
 	be32_add_cpu(&ps->s_free_blocks_count, 1);
-	pram_unlock_super(ps);
+	pram_memlock_super(ps);
 
 	unlock_super(sb);
 }
@@ -101,13 +101,13 @@ int pram_new_block(struct super_block *sb, int *blocknr, int zero)
 		}
 
 		pram_dbg("allocating blocknr %d\n", bnr);
-		pram_lock_super(ps);
+		pram_memunlock_super(ps);
 		be32_add_cpu(&ps->s_free_blocks_count, -1);
 		if (bnr < (be32_to_cpu(ps->s_blocks_count)-1))
 			ps->s_free_blocknr_hint = cpu_to_be32(bnr+1);
 		else 
 			ps->s_free_blocknr_hint = 0;
-		pram_unlock_super(ps);
+		pram_memlock_super(ps);
 	} else {
 		pram_err("all blocks allocated\n");
 		errval = -ENOSPC;
@@ -123,15 +123,15 @@ int pram_new_block(struct super_block *sb, int *blocknr, int zero)
 	bitmap_block = pram_get_block_off(sb, bitmap_bnr);
 	bp = pram_get_block(sb, bitmap_block);
 
-	pram_lock_block(sb, bp);
+	pram_memunlock_block(sb, bp);
 	set_bit(bnr, bitmap); /* mark the new block in use */
-	pram_unlock_block(sb, bp);
+	pram_memlock_block(sb, bp);
 
 	if (zero) {
 		bp = pram_get_block(sb, pram_get_block_off(sb, bnr));
-		pram_lock_block(sb, bp);
+		pram_memunlock_block(sb, bp);
 		memset(bp, 0, sb->s_blocksize);
-		pram_unlock_block(sb, bp);
+		pram_memlock_block(sb, bp);
 	}
 
 	*blocknr = bnr;
diff --git a/fs/pramfs/dir.c b/fs/pramfs/dir.c
index 25c7e13..cf6dd33 100644
--- a/fs/pramfs/dir.c
+++ b/fs/pramfs/dir.c
@@ -40,36 +40,36 @@ int pram_add_link(struct dentry *dentry, struct inode *inode)
 	tail_ino = be64_to_cpu(pidir->i_type.dir.tail);
 	if (tail_ino != 0) {
 		pitail = pram_get_inode(dir->i_sb, tail_ino);
-		pram_lock_inode(pitail);
+		pram_memunlock_inode(pitail);
 		pitail->i_d.d_next = cpu_to_be64(inode->i_ino);
-		pram_unlock_inode(pitail);
+		pram_memlock_inode(pitail);
 
 		prev_ino = tail_ino;
 
-		pram_lock_inode(pidir);
+		pram_memunlock_inode(pidir);
 		pidir->i_type.dir.tail = cpu_to_be64(inode->i_ino);
 		pidir->i_mtime = cpu_to_be32(dir->i_mtime.tv_sec);
 		pidir->i_ctime = cpu_to_be32(dir->i_ctime.tv_sec);
-		pram_unlock_inode(pidir);
+		pram_memlock_inode(pidir);
 	} else {
 		/* the directory is empty */
 		prev_ino = 0;
 
-		pram_lock_inode(pidir);
+		pram_memunlock_inode(pidir);
 		pidir->i_type.dir.tail = cpu_to_be64(inode->i_ino);
 		pidir->i_type.dir.head = cpu_to_be64(inode->i_ino);
 		pidir->i_mtime = cpu_to_be32(dir->i_mtime.tv_sec);
 		pidir->i_ctime = cpu_to_be32(dir->i_ctime.tv_sec);
-		pram_unlock_inode(pidir);
+		pram_memlock_inode(pidir);
 	}
 
 
-	pram_lock_inode(pi);
+	pram_memunlock_inode(pi);
 	pi->i_d.d_prev = cpu_to_be64(prev_ino);
 	pi->i_d.d_parent = cpu_to_be64(dir->i_ino);
 	memcpy(pi->i_d.d_name, name, namelen);
 	pi->i_d.d_name[namelen] = '\0';
-	pram_unlock_inode(pi);
+	pram_memlock_inode(pi);
 	return 0;
 }
 
@@ -90,50 +90,50 @@ int pram_remove_link(struct inode *inode)
 		next = pram_get_inode(sb, be64_to_cpu(pi->i_d.d_next));
 
 		if (next) {
-			pram_lock_inode(next);
+			pram_memunlock_inode(next);
 			next->i_d.d_prev = 0;
-			pram_unlock_inode(next);
+			pram_memlock_inode(next);
 
-			pram_lock_inode(pidir);
+			pram_memunlock_inode(pidir);
 			pidir->i_type.dir.head = pi->i_d.d_next;
 		} else {
-			pram_lock_inode(pidir);
+			pram_memunlock_inode(pidir);
 			pidir->i_type.dir.head = 0;
 			pidir->i_type.dir.tail = 0;
 		}
-		pram_unlock_inode(pidir);
+		pram_memlock_inode(pidir);
 	} else if (inode->i_ino == be64_to_cpu(pidir->i_type.dir.tail)) {
 		/* last inode in directory */
 		prev = pram_get_inode(sb, be64_to_cpu(pi->i_d.d_prev));
 
-		pram_lock_inode(prev);
+		pram_memunlock_inode(prev);
 		prev->i_d.d_next = 0;
-		pram_unlock_inode(prev);
+		pram_memlock_inode(prev);
 
-		pram_lock_inode(pidir);
+		pram_memunlock_inode(pidir);
 		pidir->i_type.dir.tail = pi->i_d.d_prev;
-		pram_unlock_inode(pidir);
+		pram_memlock_inode(pidir);
 	} else {
 		/* somewhere in the middle */
 		prev = pram_get_inode(sb, be64_to_cpu(pi->i_d.d_prev));
 		next = pram_get_inode(sb, be64_to_cpu(pi->i_d.d_next));
 
 		if (prev && next) {
-			pram_lock_inode(prev);
+			pram_memunlock_inode(prev);
 			prev->i_d.d_next = pi->i_d.d_next;
-			pram_unlock_inode(prev);
+			pram_memlock_inode(prev);
 
-			pram_lock_inode(next);
+			pram_memunlock_inode(next);
 			next->i_d.d_prev = pi->i_d.d_prev;
-			pram_unlock_inode(next);
+			pram_memlock_inode(next);
 		}
 	}
 
-	pram_lock_inode(pi);
+	pram_memunlock_inode(pi);
 	pi->i_d.d_next = 0;
 	pi->i_d.d_prev = 0;
 	pi->i_d.d_parent = 0;
-	pram_unlock_inode(pi);
+	pram_memlock_inode(pi);
 
 	return 0;
 }
diff --git a/fs/pramfs/file.c b/fs/pramfs/file.c
index c4ddac7..f3215ef 100644
--- a/fs/pramfs/file.c
+++ b/fs/pramfs/file.c
@@ -102,9 +102,9 @@ ssize_t __pram_direct_IO(int rw, struct kiocb *iocb,
 		} else {
 			copy_from_user(tmp, buf, count);
 
-			pram_lock_block(inode->i_sb, bp);
+			pram_memunlock_block(inode->i_sb, bp);
 			memcpy(&bp[blockoff], tmp, count);
-			pram_unlock_block(inode->i_sb, bp);
+			pram_memlock_block(inode->i_sb, bp);			
 		}
 
 		progress += count;
diff --git a/fs/pramfs/inode.c b/fs/pramfs/inode.c
index 5d70fe9..c3d2b18 100644
--- a/fs/pramfs/inode.c
+++ b/fs/pramfs/inode.c
@@ -24,7 +24,7 @@
 #include "pram.h"
 #include "xip.h"
 
-static struct backing_dev_info pram_backing_dev_info = {
+struct backing_dev_info pram_backing_dev_info __read_mostly = {
 	.ra_pages       = 0,    /* No readahead */
 	.capabilities	= BDI_CAP_NO_ACCT_AND_WRITEBACK,
 };
@@ -42,9 +42,9 @@ pram_new_data_block(struct inode *inode, int *blocknr, int zero)
 		struct pram_inode *pi = pram_get_inode(inode->i_sb,
 							inode->i_ino);
 		inode->i_blocks++;
-		pram_lock_inode(pi);
+		pram_memunlock_inode(pi);
 		pi->i_blocks = cpu_to_be32(inode->i_blocks);
-		pram_unlock_inode(pi);
+		pram_memlock_inode(pi);
 	}
 
 	return errval;
@@ -119,17 +119,17 @@ pram_truncate_blocks(struct inode *inode, int first_trunc_block)
 		for (j = first_col_index; j <= last_col_index; j++) {
 			blocknr = pram_get_blocknr(sb, be64_to_cpu(col[j]));
 			pram_free_block(sb, blocknr);
-			pram_lock_block(sb, col);
+			pram_memunlock_block(sb, col);
 			col[j] = 0;
-			pram_unlock_block(sb, col);
+			pram_memlock_block(sb, col);
 		}
 
 		if (first_col_index == 0) {
 			blocknr = pram_get_blocknr(sb, be64_to_cpu(row[i]));
 			pram_free_block(sb, blocknr);
-			pram_lock_block(sb, row);
+			pram_memunlock_block(sb, row);
 			row[i] = 0;
-			pram_unlock_block(sb, row);
+			pram_memlock_block(sb, row);
 		}
 	}
 
@@ -138,13 +138,13 @@ pram_truncate_blocks(struct inode *inode, int first_trunc_block)
 	if (first_row_index == 0) {
 		blocknr = pram_get_blocknr(sb, be64_to_cpu(pi->i_type.reg.row_block));
 		pram_free_block(sb, blocknr);
-		pram_lock_inode(pi);
+		pram_memunlock_inode(pi);
 		pi->i_type.reg.row_block = 0;
-		pram_unlock_inode(pi);
+		pram_memlock_inode(pi);
 	}
-	pram_lock_inode(pi);
+	pram_memunlock_inode(pi);
 	pi->i_blocks = cpu_to_be32(inode->i_blocks);
-	pram_unlock_inode(pi);
+	pram_memlock_inode(pi);
 }
 
 /*
@@ -172,9 +172,9 @@ int pram_alloc_blocks(struct inode *inode, int file_blocknr, int num)
 			pram_err("failed to alloc 2nd order array block\n");
 			goto fail;
 		}
-		pram_lock_inode(pi);
+		pram_memunlock_inode(pi);
 		pi->i_type.reg.row_block = cpu_to_be64(pram_get_block_off(sb, blocknr));
-		pram_unlock_inode(pi);
+		pram_memlock_inode(pi);
 	}
 
 	row = pram_get_block(sb, be64_to_cpu(pi->i_type.reg.row_block));
@@ -199,9 +199,9 @@ int pram_alloc_blocks(struct inode *inode, int file_blocknr, int num)
 				pram_err("failed to alloc row block\n");
 				goto fail;
 			}
-			pram_lock_block(sb, row);
+			pram_memunlock_block(sb, row);
 			row[i] = cpu_to_be64(pram_get_block_off(sb, blocknr));
-			pram_unlock_block(sb, row);
+			pram_memlock_block(sb, row);
 		}
 		col = pram_get_block(sb, be64_to_cpu(row[i]));
 
@@ -223,9 +223,9 @@ int pram_alloc_blocks(struct inode *inode, int file_blocknr, int num)
 						  "data block\n");
 					goto fail;
 				}
-				pram_lock_block(sb, col);
+				pram_memunlock_block(sb, col);
 				col[j] = cpu_to_be64(pram_get_block_off(sb, blocknr));
-				pram_unlock_block(sb, col);
+				pram_memlock_block(sb, col);
 			}
 		}
 	}
@@ -303,7 +303,7 @@ static int pram_update_inode(struct inode *inode)
 
 	pi = pram_get_inode(inode->i_sb, inode->i_ino);
 
-	pram_lock_inode(pi);
+	pram_memunlock_inode(pi);
 	pi->i_mode = cpu_to_be16(inode->i_mode);
 	pi->i_uid = cpu_to_be32(inode->i_uid);
 	pi->i_gid = cpu_to_be32(inode->i_gid);
@@ -317,7 +317,7 @@ static int pram_update_inode(struct inode *inode)
 	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
 		pi->i_type.dev.rdev = cpu_to_be32(inode->i_rdev);
 
-	pram_unlock_inode(pi);
+	pram_memlock_inode(pi);
 	return retval;
 }
 
@@ -352,14 +352,14 @@ static void pram_free_inode(struct inode *inode)
 	inode_nr = (inode->i_ino - PRAM_ROOT_INO) >> PRAM_INODE_BITS;
 
 	pi = pram_get_inode(sb, inode->i_ino);
-	pram_lock_inode(pi);
+	pram_memunlock_inode(pi);
 	pi->i_dtime = cpu_to_be32(get_seconds());
 	pi->i_type.reg.row_block = 0;
-	pram_unlock_inode(pi);
+	pram_memlock_inode(pi);
 
 	/* increment s_free_inodes_count */
 	ps = pram_get_super(sb);
-	pram_lock_super(ps);
+	pram_memunlock_super(ps);
 	if (inode_nr < be32_to_cpu(ps->s_free_inode_hint))
 		ps->s_free_inode_hint = cpu_to_be32(inode_nr);
 	be32_add_cpu(&ps->s_free_inodes_count, 1);
@@ -368,7 +368,7 @@ static void pram_free_inode(struct inode *inode)
 		pram_dbg("fs is empty!\n");
 		ps->s_free_inode_hint = cpu_to_be32(1);
 	}
-	pram_unlock_super(ps);
+	pram_memlock_super(ps);
 
 	unlock_super(sb);
 }
@@ -427,7 +427,7 @@ struct inode *pram_new_inode(const struct inode *dir, int mode)
 	lock_super(sb);
 	ps = pram_get_super(sb);
 
-	if (be32_to_cpu(ps->s_free_inodes_count)) {
+	if (ps->s_free_inodes_count) {
 		/* find the oldest unused pram inode */
 		for (i = be32_to_cpu(ps->s_free_inode_hint); i < be32_to_cpu(ps->s_inodes_count); i++) {
 			ino = PRAM_ROOT_INO + (i << PRAM_INODE_BITS);
@@ -447,13 +447,13 @@ struct inode *pram_new_inode(const struct inode *dir, int mode)
 		}
 
 		pram_dbg("allocating inode %lu\n", ino);
-		pram_lock_super(ps);
+		pram_memunlock_super(ps);
 		be32_add_cpu(&ps->s_free_inodes_count, -1);
 		if (i < be32_to_cpu(ps->s_inodes_count)-1) 
 			ps->s_free_inode_hint = cpu_to_be32(i+1);
 		else
 			ps->s_free_inode_hint = 0;
-		pram_unlock_super(ps);
+		pram_memlock_super(ps);
 	} else {
 		pram_err("no space left to create new inode!\n");
 		errval = -ENOSPC;
@@ -476,10 +476,10 @@ struct inode *pram_new_inode(const struct inode *dir, int mode)
 	inode->i_blocks = inode->i_size = 0;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
 
-	pram_lock_inode(pi);
+	pram_memunlock_inode(pi);
 	pi->i_d.d_next = 0;
 	pi->i_d.d_prev = 0;
-	pram_unlock_inode(pi);
+	pram_memlock_inode(pi);
 
 	insert_inode_hash(inode);
 	pram_write_inode(inode, 0);
@@ -517,9 +517,9 @@ void pram_truncate(struct inode *inode)
 	blocksize = 1 << blocksize_bits;
 	blocknr = (inode->i_size + blocksize-1) >> blocksize_bits;
 
-	mutex_lock(&pram_lock);
+	mutex_lock(&truncate_lock);
 	pram_truncate_blocks(inode, blocknr);
-	mutex_unlock(&pram_lock);
+	mutex_unlock(&truncate_lock);
 	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
 	pram_update_inode(inode);
 }
@@ -550,7 +550,7 @@ int pram_get_and_update_block(struct inode *inode, sector_t iblock,
 
 	BUG_ON(PageHighMem(bh->b_page));
 
-	mutex_lock(&pram_lock);
+	mutex_lock(&truncate_lock);
 
 	block = pram_find_data_block(inode, iblock);
 
@@ -575,9 +575,9 @@ int pram_get_and_update_block(struct inode *inode, sector_t iblock,
 	/* now update the buffer synchronously */
 	bp = pram_get_block(sb, block);
 	if (buffer_new(bh)) {
-		pram_lock_block(sb, bp);
+		pram_memunlock_block(sb, bp);
 		memset(bp, 0, blocksize);
-		pram_unlock_block(sb, bp);
+		pram_memlock_block(sb, bp);
 		memset(bh->b_data, 0, blocksize);
 	} else {
 		memcpy(bh->b_data, bp, blocksize);
@@ -587,7 +587,7 @@ int pram_get_and_update_block(struct inode *inode, sector_t iblock,
 	err = 0;
 
  out:
-	mutex_unlock(&pram_lock);
+	mutex_unlock(&truncate_lock);
 	return err;
 }
 
diff --git a/fs/pramfs/namei.c b/fs/pramfs/namei.c
index d87ad8a..9953d4c 100644
--- a/fs/pramfs/namei.c
+++ b/fs/pramfs/namei.c
@@ -217,9 +217,9 @@ static int pram_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 
 	/* make the new directory empty */
 	pi = pram_get_inode(dir->i_sb, inode->i_ino);
-	pram_lock_inode(pi);
+	pram_memunlock_inode(pi);
 	pi->i_type.dir.head = pi->i_type.dir.tail = 0;
-	pram_unlock_inode(pi);
+	pram_memlock_inode(pi);
 
 	err = pram_add_link(dentry, inode);
 	if (err)
diff --git a/fs/pramfs/pram.h b/fs/pramfs/pram.h
index 493e045..2958bee 100644
--- a/fs/pramfs/pram.h
+++ b/fs/pramfs/pram.h
@@ -135,7 +135,7 @@ static inline int pram_calc_checksum(u8 *data, int n)
 }
 
 /* If this is part of a read-modify-write of the super block,
-   pram_lock_super() before calling! */
+   pram_memunlock_super() before calling! */
 static inline struct pram_super_block *
 pram_get_super(struct super_block *sb)
 {
@@ -150,7 +150,7 @@ pram_get_redund_super(struct super_block *sb)
 	return (struct pram_super_block *)(sbi->virt_addr + PRAM_SB_SIZE);
 }
 
-/* pram_lock_super() before calling! */
+/* pram_memunlock_super() before calling! */
 static inline void pram_sync_super(struct pram_super_block *ps)
 {
 	u16 crc = 0;
@@ -162,7 +162,7 @@ static inline void pram_sync_super(struct pram_super_block *ps)
 	memcpy((void *)ps + PRAM_SB_SIZE, (void *)ps, PRAM_SB_SIZE);
 }
 
-/* pram_lock_inode() before calling! */
+/* pram_memunlock_inode() before calling! */
 static inline void pram_sync_inode(struct pram_inode *pi)
 {
 	u16 crc = 0;
@@ -172,34 +172,44 @@ static inline void pram_sync_inode(struct pram_inode *pi)
 }
 
 #ifdef CONFIG_PRAMFS_WRITE_PROTECT
-#define pram_lock_range(p, len) pram_writeable((p), (len), 1);
-#define pram_unlock_range(p, len) pram_writeable((p), (len), 0);
+
+static inline void pram_memunlock_range(void *p, unsigned long len)
+{
+	preempt_disable();
+	pram_writeable(p, len, 1);
+}
+
+static inline void pram_memlock_range(void *p, unsigned long len)
+{
+	pram_writeable(p, len, 0);
+	preempt_enable();
+}
 #else
-#define pram_lock_range(p, len) do {} while (0)
-#define pram_unlock_range(p, len) do {} while (0)
+static inline void pram_memunlock_range(p, len) {}
+static inline void pram_memlock_range(p, len) {}
 #endif
 
 /* write protection for super block */
-#define pram_lock_super(ps) \
-	pram_lock_range((ps), PRAM_SB_SIZE)
-#define pram_unlock_super(ps) {\
+#define pram_memunlock_super(ps) \
+	pram_memunlock_range((ps), PRAM_SB_SIZE)
+#define pram_memlock_super(ps) {\
 	pram_sync_super(ps);\
-	pram_unlock_range((ps), PRAM_SB_SIZE);\
+	pram_memlock_range((ps), PRAM_SB_SIZE);\
 }
 
 /* write protection for inode metadata */
-#define pram_lock_inode(pi) \
-	pram_lock_range((pi), PRAM_INODE_SIZE)
-#define pram_unlock_inode(pi) {\
+#define pram_memunlock_inode(pi) \
+	pram_memunlock_range((pi), PRAM_INODE_SIZE)
+#define pram_memlock_inode(pi) {\
 	pram_sync_inode(pi);\
-	pram_unlock_range((pi), PRAM_INODE_SIZE);\
+	pram_memlock_range((pi), PRAM_INODE_SIZE);\
 }
 
 /* write protection for a data block */
-#define pram_lock_block(sb, bp) \
-	pram_lock_range((bp), (sb)->s_blocksize)
-#define pram_unlock_block(sb, bp) \
-	pram_unlock_range((bp), (sb)->s_blocksize)
+#define pram_memunlock_block(sb, bp) \
+	pram_memunlock_range((bp), (sb)->s_blocksize)
+#define pram_memlock_block(sb, bp) \
+	pram_memlock_range((bp), (sb)->s_blocksize)
 
 static inline void *
 pram_get_bitmap(struct super_block *sb)
@@ -209,7 +219,7 @@ pram_get_bitmap(struct super_block *sb)
 }
 
 /* If this is part of a read-modify-write of the inode metadata,
-   pram_lock_inode() before calling! */
+   pram_memunlock_inode() before calling! */
 static inline struct pram_inode *
 pram_get_inode(struct super_block *sb, u64 ino)
 {
@@ -240,7 +250,7 @@ pram_get_blocknr(struct super_block *sb, u64 block)
 }
 
 /* If this is part of a read-modify-write of the block,
-   pram_lock_block() before calling! */
+   pram_memunlock_block() before calling! */
 static inline void *
 pram_get_block(struct super_block *sb, u64 block)
 {
@@ -269,6 +279,8 @@ extern struct inode_operations pram_dir_inode_operations;
 /* symlink.c */
 extern struct inode_operations pram_symlink_inode_operations;
 
-extern struct mutex pram_lock;
+extern struct mutex truncate_lock;
+
+extern struct backing_dev_info pram_backing_dev_info;
 
 #endif	/* __PRAM_H */
diff --git a/fs/pramfs/super.c b/fs/pramfs/super.c
index 1c7e4ca..ada5616 100644
--- a/fs/pramfs/super.c
+++ b/fs/pramfs/super.c
@@ -33,7 +33,7 @@
 
 static struct super_operations pram_sops;
 
-DEFINE_MUTEX(pram_lock);
+DEFINE_MUTEX(truncate_lock);
 
 #ifdef CONFIG_PRAMFS_TEST
 static void *first_pram_super;
@@ -294,7 +294,7 @@ static struct pram_inode *pram_init(struct super_block *sb, unsigned long size)
 	pram_dbg("max name length %d\n", PRAM_NAME_LEN);
 
 	super = pram_get_super(sb);
-	pram_lock_range(super, bitmap_start + bitmap_size);
+	pram_memunlock_range(super, bitmap_start + bitmap_size);
 
 	/* clear out super-block and inode table */
 	memset(super, 0, bitmap_start);
@@ -322,7 +322,7 @@ static struct pram_inode *pram_init(struct super_block *sb, unsigned long size)
 
 	pram_init_bitmap(sb);
 
-	pram_unlock_range(super, bitmap_start + bitmap_size);
+	pram_memlock_range(super, bitmap_start + bitmap_size);
 
 	return root_i;
 }
@@ -515,9 +515,9 @@ int pram_remount(struct super_block *sb, int *mntflags, char *data)
 	
 	if ((*mntflags & MS_RDONLY) != (sb->s_flags & MS_RDONLY)) {
 		ps = pram_get_super(sb);
-		pram_lock_super(ps);
+		pram_memunlock_super(ps);
 		ps->s_mtime = cpu_to_be32(get_seconds()); /* update mount time */
-		pram_unlock_super(ps);
+		pram_memlock_super(ps);
 	}
 
 	return 0;
@@ -574,12 +574,24 @@ static struct file_system_type pram_fs_type = {
 
 static int __init init_pram_fs(void)
 {
-	return register_filesystem(&pram_fs_type);
+	int rc = 0;	
+
+	rc = bdi_init(&pram_backing_dev_info);
+	if (rc)
+		goto out;
+
+	rc = register_filesystem(&pram_fs_type);
+	if (rc)
+		bdi_destroy(&pram_backing_dev_info);
+
+out:
+	return rc;
 }
 
 static void __exit exit_pram_fs(void)
 {
 	unregister_filesystem(&pram_fs_type);
+	bdi_destroy(&pram_backing_dev_info);
 }
 
 MODULE_AUTHOR("Marco Stornelli <marco.stornelli@gmail.com>");
diff --git a/fs/pramfs/symlink.c b/fs/pramfs/symlink.c
index 3ae9c13..4a14f63 100644
--- a/fs/pramfs/symlink.c
+++ b/fs/pramfs/symlink.c
@@ -31,10 +31,10 @@ int pram_block_symlink(struct inode *inode, const char *symname, int len)
 	block = pram_find_data_block(inode, 0);
 	blockp = pram_get_block(sb, block);
 
-	pram_lock_block(sb, blockp);
+	pram_memunlock_block(sb, blockp);
 	memcpy(blockp, symname, len);
 	blockp[len] = '\0';
-	pram_unlock_block(sb, blockp);
+	pram_memlock_block(sb, blockp);
 	return 0;
 }
 
diff --git a/fs/pramfs/xip.c b/fs/pramfs/xip.c
index 129732a..c69fab6 100644
--- a/fs/pramfs/xip.c
+++ b/fs/pramfs/xip.c
@@ -24,7 +24,7 @@ static int pram_find_and_alloc_blocks(struct inode *inode, sector_t iblock,
 	int err = -EIO;
 	off_t block;
 
-	mutex_lock(&pram_lock);
+	mutex_lock(&truncate_lock);
 
 	block = pram_find_data_block(inode, iblock);
 
@@ -49,7 +49,7 @@ static int pram_find_and_alloc_blocks(struct inode *inode, sector_t iblock,
 	err = 0;
 
  err:
-	mutex_unlock(&pram_lock);
+	mutex_unlock(&truncate_lock);
 	return err;
 }
 
diff --git a/include/linux/pram_fs.h b/include/linux/pram_fs.h
index e66d99c..e6e86a5 100644
--- a/include/linux/pram_fs.h
+++ b/include/linux/pram_fs.h
@@ -88,7 +88,6 @@ struct pram_inode {
 
 
 #define PRAM_SB_SIZE 128 /* must be power of two */
-#define PRAM_SB_BITS   7
 
 /*
  * Structure of the super block in PRAMFS
-- 
1.6.5.2

