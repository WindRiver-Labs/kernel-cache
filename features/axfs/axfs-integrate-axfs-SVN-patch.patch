From 6e7053dace7b9011eb0cb766611db2c3422c9812 Mon Sep 17 00:00:00 2001
From: Bruce Ashfield <bruce.ashfield@windriver.com>
Date: Fri, 28 May 2010 10:47:08 -0400
Subject: [PATCH] axfs: integrate axfs SVN patch

integrated from: https://axfs.svn.sourceforge.net/svnroot/axfs axfs

The Advanced XIP File System or (AXFS) is a highly compressed
readonly filesystem like cramfs or squashfs.  It also can be
configured to store individual pages of files compressed or
uncompressed as XIP pages.  This allows for faster boot up and
application launch time with a smaller memory footprint.

Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 fs/Kconfig                |   21 +
 fs/Makefile               |    1 +
 fs/axfs/Makefile          |    7 +
 fs/axfs/axfs_bdev.c       |  179 +++++++++
 fs/axfs/axfs_inode.c      |  711 ++++++++++++++++++++++++++++++++++
 fs/axfs/axfs_mtd.c        |  506 ++++++++++++++++++++++++
 fs/axfs/axfs_physmem.c    |   69 ++++
 fs/axfs/axfs_profiling.c  |  602 +++++++++++++++++++++++++++++
 fs/axfs/axfs_super.c      |  928 +++++++++++++++++++++++++++++++++++++++++++++
 fs/axfs/axfs_uml.c        |   47 +++
 fs/axfs/axfs_uncompress.c |  124 ++++++
 include/linux/axfs.h      |  375 ++++++++++++++++++
 12 files changed, 3570 insertions(+), 0 deletions(-)
 create mode 100644 fs/axfs/Makefile
 create mode 100644 fs/axfs/axfs_bdev.c
 create mode 100644 fs/axfs/axfs_inode.c
 create mode 100644 fs/axfs/axfs_mtd.c
 create mode 100644 fs/axfs/axfs_physmem.c
 create mode 100644 fs/axfs/axfs_profiling.c
 create mode 100644 fs/axfs/axfs_super.c
 create mode 100644 fs/axfs/axfs_uml.c
 create mode 100644 fs/axfs/axfs_uncompress.c
 create mode 100644 include/linux/axfs.h

diff --git a/fs/Kconfig b/fs/Kconfig
index 5117129..7fb75c4 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -133,6 +133,27 @@ config TMPFS_POSIX_ACL
 
 	  If you don't know what Access Control Lists are, say N.
 
+config AXFS
+	tristate "Advanced XIP File System (AXFS) support (EXPERIMENTAL)"
+	select FS_XIP
+	select ZLIB_INFLATE
+	default n
+	help
+	  The Advanced XIP File System or (AXFS) is a highly compressed
+	  readonly filesystem like cramfs or squashfs.  It also can be
+	  configured to store individual pages of files compressed or
+	  uncompressed as XIP pages.  This allows for faster boot up and
+	  application launch time with a smaller memory footprint.
+
+config AXFS_PROFILING
+	bool "Profiling extensions for AXFS (EXPERIMENTAL)"
+	depends on AXFS
+	default n
+	help
+	  Profiling tooling used to identify what pages in the filesystem
+	  image are actually accessed and how much.
+
+
 config HUGETLBFS
 	bool "HugeTLB file system support"
 	depends on X86 || IA64 || SPARC64 || (S390 && 64BIT) || \
diff --git a/fs/Makefile b/fs/Makefile
index 8f33917..47c62f5 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -116,6 +116,7 @@ obj-$(CONFIG_SUN_OPENPROMFS)	+= openpromfs/
 obj-$(CONFIG_OMFS_FS)		+= omfs/
 obj-$(CONFIG_JFS_FS)		+= jfs/
 obj-$(CONFIG_XFS_FS)		+= xfs/
+obj-$(CONFIG_AXFS)		+= axfs/
 obj-$(CONFIG_9P_FS)		+= 9p/
 obj-$(CONFIG_AFS_FS)		+= afs/
 obj-$(CONFIG_NILFS2_FS)		+= nilfs2/
diff --git a/fs/axfs/Makefile b/fs/axfs/Makefile
new file mode 100644
index 0000000..4c40e13
--- /dev/null
+++ b/fs/axfs/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the linux axfs routines
+#
+
+obj-$(CONFIG_AXFS) += axfs.o
+
+axfs-objs := axfs_inode.o axfs_super.o axfs_uncompress.o axfs_profiling.o axfs_uml.o axfs_mtd.o axfs_bdev.o axfs_physmem.o
diff --git a/fs/axfs/axfs_bdev.c b/fs/axfs/axfs_bdev.c
new file mode 100644
index 0000000..209f59f
--- /dev/null
+++ b/fs/axfs/axfs_bdev.c
@@ -0,0 +1,179 @@
+/*
+ * Advanced XIP File System for Linux - AXFS
+ *   Readonly, compressed, and XIP filesystem for Linux systems big and small
+ *
+ * Copyright(c) 2008 Numonyx
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * Authors:
+ *  Jared Hulbert <jaredeh@gmail.com>
+ *
+ * Project url: http://axfs.sourceforge.net
+ *
+ * axfs_bdev.c -
+ *   Allows axfs to use block devices or has dummy functions if block
+ *   device support is compiled out of the kernel.
+ *
+ */
+
+#include <linux/axfs.h>
+#include <linux/mount.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
+#else
+#define CONFIG_BLOCK
+#endif
+#ifdef CONFIG_BLOCK
+#include <linux/buffer_head.h>
+#include <linux/namei.h>
+
+int axfs_fill_super(struct super_block *sb, void *data, int silent);
+
+int axfs_get_sb_bdev(struct file_system_type *fs_type, int flags,
+		     const char *dev_name, struct axfs_super *sbi,
+		     struct vfsmount *mnt, int *err)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17)
+	*err = get_sb_bdev(fs_type, flags, dev_name, sbi, axfs_fill_super, mnt);
+
+	if (*err)
+		return FALSE;
+#else
+	mnt->mnt_sb =
+	    get_sb_bdev(fs_type, flags, dev_name, (void *)sbi, axfs_fill_super);
+	if (IS_ERR(mnt->mnt_sb)) {
+		*err = PTR_ERR(mnt->mnt_sb);
+		return FALSE;
+	}
+#endif
+	return TRUE;
+}
+
+void axfs_kill_block_super(struct super_block *sb)
+{
+	kill_block_super(sb);
+}
+
+/******************************************************************************
+ *
+ * axfs_copy_block_data
+ *
+ * Description: Helper function to read data from block device
+ *
+ * Parameters:
+ *    (IN) sb - pointer to super block structure.
+ *
+ *    (IN) dst_addr - pointer to buffer into which data is to be read.
+ *
+ *    (IN) boffset - offset within block device
+ *
+ *    (IN) len - length of data to be read
+ *
+ * Returns:
+ *     0 or error number
+ *
+ *****************************************************************************/
+int axfs_copy_block(struct super_block *sb, void *dst_addr, u64 fsoffset,
+		    u64 len)
+{
+	struct axfs_super *sbi = AXFS_SB(sb);
+	u64 boffset = AXFS_FSOFFSET_2_DEVOFFSET(sbi, fsoffset);
+	u64 blocks;
+	u64 blksize = sb->s_blocksize;
+	unsigned long dst;
+	unsigned long src;
+	sector_t block;
+	size_t bytes;
+	struct buffer_head *bh;
+	u64 copied = 0;
+
+	if (len == 0)
+		return 0;
+
+	blocks = len / blksize;
+	if ((len % blksize) > 0)
+		blocks += 1;
+
+	while (copied < len) {
+		/* Explicit casting for ARM linker errors. */
+		block = (sector_t) boffset + (sector_t) copied;
+		block /= (sector_t) blksize;
+		bh = sb_bread(sb, block);
+		src = (unsigned long)bh->b_data;
+		dst = (unsigned long)dst_addr;
+		if (copied == 0) {
+			/* Explicit casting for ARM linker errors. */
+			bytes = (size_t) blksize;
+			bytes -= (size_t) boffset % (size_t) blksize;
+			if (bytes > len)
+				bytes = len;
+			/* Explicit casting for ARM linker errors. */
+			src += (unsigned long)boffset % (unsigned long)blksize;
+		} else {
+			dst += copied;
+			if ((len - copied) < blksize) {
+				bytes = len - copied;
+			} else {
+				bytes = blksize;
+			}
+		}
+		memcpy((void *)dst, (void *)src, bytes);
+		copied += bytes;
+		brelse(bh);
+	}
+	return 0;
+}
+
+int axfs_is_dev_bdev(char *path)
+{
+	struct nameidata nd;
+	int ret = FALSE;
+
+	if (!path)
+		return FALSE;
+
+	if (path_lookup(path, LOOKUP_FOLLOW, &nd))
+		return FALSE;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24)
+	if (S_ISBLK(nd.path.dentry->d_inode->i_mode))
+#else
+	if (S_ISBLK(nd.dentry->d_inode->i_mode))
+#endif
+		ret = TRUE;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24)
+	path_put(&nd.path);
+#else
+	path_release(&nd);
+#endif
+	return ret;
+}
+
+#else
+
+int axfs_get_sb_bdev(struct file_system_type *fs_type, int flags,
+		     const char *dev_name, struct axfs_super *sbi,
+		     struct vfsmount *mnt, int *err)
+{
+	return FALSE;
+}
+
+void axfs_kill_block_super(struct super_block *sb)
+{
+}
+
+int axfs_copy_block(struct super_block *sb, void *dst_addr, u64 fsoffset,
+		    u64 len)
+{
+	return -EINVAL;
+}
+
+int axfs_is_dev_bdev(char *path)
+{
+	return FALSE;
+}
+
+#endif /* CONFIG_BLOCK */
diff --git a/fs/axfs/axfs_inode.c b/fs/axfs/axfs_inode.c
new file mode 100644
index 0000000..6028726
--- /dev/null
+++ b/fs/axfs/axfs_inode.c
@@ -0,0 +1,711 @@
+/*
+ * Advanced XIP File System for Linux - AXFS
+ *   Readonly, compressed, and XIP filesystem for Linux systems big and small
+ *
+ * Copyright(c) 2008 Numonyx
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * Authors:
+ *  Eric Anderson
+ *  Jared Hulbert <jaredeh@gmail.com>
+ *  Sujaya Srinivasan
+ *  Justin Treon
+ *
+ * Project url: http://axfs.sourceforge.net
+ *
+ * Borrowed heavily from fs/cramfs/inode.c by Linus Torvalds
+ *
+ * axfs_inode.c -
+ *   Contains the most of the filesystem logic with the major exception of the
+ *   mounting infrastructure.
+ *
+ */
+
+#include <linux/axfs.h>
+#include <linux/pagemap.h>
+
+/***************** functions in other axfs files ******************************/
+int axfs_get_sb(struct file_system_type *, int, const char *, void *,
+		struct vfsmount *);
+void axfs_kill_super(struct super_block *);
+void axfs_profiling_add(struct axfs_super *, unsigned long, unsigned int);
+int axfs_copy_mtd(struct super_block *, void *, u64, u64);
+int axfs_copy_block(struct super_block *, void *, u64, u64);
+/******************************************************************************/
+static int axfs_readdir(struct file *, void *, filldir_t);
+static int axfs_mmap(struct file *, struct vm_area_struct *);
+static ssize_t axfs_file_read(struct file *, char __user *, size_t, loff_t *);
+static int axfs_readpage(struct file *, struct page *);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
+static int axfs_fault(struct vm_area_struct *, struct vm_fault *);
+#else
+static struct page *axfs_nopage(struct vm_area_struct *, unsigned long, int *);
+#endif
+static struct dentry *axfs_lookup(struct inode *, struct dentry *,
+				  struct nameidata *);
+static int axfs_get_xip_mem(struct address_space *, pgoff_t, int, void **,
+			    unsigned long *);
+#ifdef VM_MIXEDMAP
+#else
+struct page *axfs_get_xip_page(struct address_space *mapping, sector_t offset,
+			       int create);
+#endif
+
+/******************************************************************************/
+
+static struct file_operations axfs_directory_operations = {
+	.llseek = generic_file_llseek,
+	.read = generic_read_dir,
+	.readdir = axfs_readdir,
+};
+
+static struct file_operations axfs_fops = {
+	.read = axfs_file_read,
+	.aio_read = generic_file_aio_read,
+	.mmap = axfs_mmap,
+};
+
+static struct address_space_operations axfs_aops = {
+	.readpage = axfs_readpage,
+#ifdef VM_MIXEDMAP
+	.get_xip_mem = axfs_get_xip_mem,
+#else
+	.get_xip_page = axfs_get_xip_page,
+#endif
+};
+
+static struct inode_operations axfs_dir_inode_operations = {
+	.lookup = axfs_lookup,
+};
+
+static struct vm_operations_struct axfs_vm_ops = {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
+	.fault = axfs_fault,
+#else
+	.nopage = axfs_nopage,
+#endif
+};
+
+static int axfs_copy_data(struct super_block *sb, void *dst,
+			  struct axfs_region_desc *region, u64 offset, u64 len)
+{
+	u64 mmapped = 0;
+	u64 end = region->fsoffset + offset + len;
+	u64 begin = region->fsoffset + offset;
+	u64 left;
+	void *addr;
+	void *newdst;
+	struct axfs_super *sbi = AXFS_SB(sb);
+
+	if (len == 0)
+		return 0;
+
+	if (region->virt_addr) {
+		if (sbi->mmap_size >= end) {
+			mmapped = len;
+		} else if (sbi->mmap_size > begin) {
+			mmapped = sbi->mmap_size - begin;
+		}
+	}
+
+	if (mmapped) {
+		addr = (void *)(region->virt_addr + offset);
+		memcpy(dst, addr, mmapped);
+	}
+
+	newdst = (void *)(dst + mmapped);
+	left = len - mmapped;
+
+	if (left == 0)
+		return len;
+
+	if (AXFS_HAS_BDEV(sb)) {
+		return axfs_copy_block(sb, newdst, begin + mmapped, left);
+	} else if (AXFS_HAS_MTD(sb)) {
+		return axfs_copy_mtd(sb, newdst, begin + mmapped, left);
+	} else {
+		return 0;
+	}
+}
+
+static int axfs_iget5_test(struct inode *inode, void *opaque)
+{
+	u64 *inode_number = (u64 *) opaque;
+
+	if (inode->i_sb == NULL) {
+		printk(KERN_ERR "axfs_iget5_test:"
+		       " the super block is set to null\n");
+	}
+	if (inode->i_ino == *inode_number)
+		return 1;	/* matches */
+	else
+		return 0;	/* does not match */
+}
+
+static int axfs_iget5_set(struct inode *inode, void *opaque)
+{
+	u64 *inode_number = (u64 *) opaque;
+
+	if (inode->i_sb == NULL) {
+		printk(KERN_ERR "axfs_iget5_set:"
+		       " the super block is set to null \n");
+	}
+	inode->i_ino = *inode_number;
+	return 0;
+}
+
+struct inode *axfs_create_vfs_inode(struct super_block *sb, int ino)
+{
+	struct axfs_super *sbi = AXFS_SB(sb);
+	struct inode *inode;
+	u64 size;
+
+	inode = iget5_locked(sb, ino, axfs_iget5_test, axfs_iget5_set, &ino);
+
+	if (!(inode && (inode->i_state & I_NEW)))
+		return inode;
+
+	inode->i_mode = AXFS_GET_MODE(sbi, ino);
+	inode->i_uid = AXFS_GET_UID(sbi, ino);
+	size = AXFS_GET_INODE_FILE_SIZE(sbi, ino);
+	inode->i_size = size;
+	inode->i_blocks = AXFS_GET_INODE_NUM_ENTRIES(sbi, ino);
+	inode->i_blkbits = PAGE_CACHE_SIZE * 8;
+	inode->i_gid = AXFS_GET_GID(sbi, ino);
+
+	inode->i_mtime = inode->i_atime = inode->i_ctime = sbi->timestamp;
+	inode->i_ino = ino;
+
+	if (S_ISREG(inode->i_mode)) {
+		inode->i_fop = &axfs_fops;
+		inode->i_data.a_ops = &axfs_aops;
+		inode->i_mapping->a_ops = &axfs_aops;
+	} else if (S_ISDIR(inode->i_mode)) {
+		inode->i_op = &axfs_dir_inode_operations;
+		inode->i_fop = &axfs_directory_operations;
+	} else if (S_ISLNK(inode->i_mode)) {
+		inode->i_op = &page_symlink_inode_operations;
+		inode->i_data.a_ops = &axfs_aops;
+	} else {
+		inode->i_size = 0;
+		inode->i_blocks = 0;
+		init_special_inode(inode, inode->i_mode, old_decode_dev(size));
+	}
+	unlock_new_inode(inode);
+
+	return inode;
+}
+
+#ifdef VM_MIXEDMAP
+#else
+static int axfs_insert_pfns(struct file *file, struct vm_area_struct *vma)
+{
+	struct inode *inode = file->f_dentry->d_inode;
+	struct super_block *sb = inode->i_sb;
+	struct axfs_super *sbi = AXFS_SB(sb);
+	unsigned long array_index, length, offset, count, xip_addr, addr, pfn;
+	unsigned int numpages;
+	u64 ino_number = inode->i_ino;
+	int error;
+
+	offset = vma->vm_pgoff;
+
+	array_index = AXFS_GET_INODE_ARRAY_INDEX(sbi, ino_number);
+	array_index += offset;
+	length = vma->vm_end - vma->vm_start;
+
+	if (length > inode->i_size)
+		length = inode->i_size;
+
+	length = PAGE_ALIGN(length);
+	numpages = length >> PAGE_SHIFT;
+
+	for (count = 0; count < numpages; count++, array_index++) {
+		if (!AXFS_IS_NODE_XIP(sbi, array_index))
+			continue;
+#ifdef VM_XIP
+		vma->vm_flags |= (VM_IO | VM_XIP);
+#endif
+		addr = vma->vm_start + (PAGE_SIZE * count);
+		xip_addr = AXFS_GET_XIP_REGION_PHYSADDR(sbi);
+		xip_addr += AXFS_GET_NODE_INDEX(sbi, array_index) << PAGE_SHIFT;
+		pfn = xip_addr >> PAGE_SHIFT;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
+		error = vm_insert_pfn(vma, addr, pfn);
+#else
+		error =
+		    remap_pfn_range(vma, addr, pfn, PAGE_SIZE,
+				    vma->vm_page_prot);
+#endif
+#else
+		xip_addr = pfn << PAGE_SHIFT;
+		error =
+		    remap_page_range(vma, addr, xip_addr, PAGE_SIZE,
+				     vma->vm_page_prot);
+#endif
+		if (error)
+			return error;
+	}
+
+	return 0;
+}
+#endif
+
+static int axfs_mmap(struct file *file, struct vm_area_struct *vma)
+{
+
+	file_accessed(file);
+
+	vma->vm_ops = &axfs_vm_ops;
+
+#ifdef VM_MIXEDMAP
+#ifdef VM_CAN_NONLINEAR
+	vma->vm_flags |= VM_CAN_NONLINEAR | VM_MIXEDMAP;
+#else
+	vma->vm_flags | = VM_IO | VM_MIXEDMAP;
+#endif
+#else
+#ifdef VM_PFNMAP
+	vma->vm_flags |= VM_IO | VM_PFNMAP;
+#else
+	vma->vm_flags |= VM_IO;
+#endif
+#endif
+#ifdef VM_XIP
+	vma->vm_flags |= VM_XIP;
+#endif
+
+#ifdef VM_MIXEDMAP
+	return 0;
+#else
+	return axfs_insert_pfns(file, vma);
+#endif
+}
+
+static struct dentry *axfs_lookup(struct inode *dir, struct dentry *dentry,
+				  struct nameidata *nd)
+{
+	struct super_block *sb = dir->i_sb;
+	struct axfs_super *sbi = AXFS_SB(sb);
+	u64 ino_number = dir->i_ino;
+	u64 dir_index = 0;
+	u64 entry;
+	char *name;
+	int namelen, err;
+
+	while (dir_index < AXFS_GET_INODE_NUM_ENTRIES(sbi, ino_number)) {
+		entry = AXFS_GET_INODE_ARRAY_INDEX(sbi, ino_number);
+		entry += dir_index;
+
+		name = AXFS_GET_INODE_NAME(sbi, entry);
+		namelen = strlen(name);
+
+		/* fast test, the entries are sorted alphabetically and the
+		 * first letter is smaller than the first letter in the search
+		 * name then it isn't in this directory.  Keeps this loop from
+		 * needing to scan through always.
+		 */
+		if (dentry->d_name.name[0] < name[0])
+			break;
+
+		dir_index++;
+
+		/* Quick check that the name is roughly the right length */
+		if (dentry->d_name.len != namelen)
+			continue;
+
+		err = memcmp(dentry->d_name.name, name, namelen);
+		if (err > 0)
+			continue;
+
+		/* The file name isn't present in the directory. */
+		if (err < 0)
+			break;
+
+		d_add(dentry, axfs_create_vfs_inode(dir->i_sb, entry));
+		goto out;
+
+	}
+	d_add(dentry, NULL);
+
+out:
+	return NULL;
+}
+
+static int axfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
+{
+	struct inode *inode = filp->f_dentry->d_inode;
+	struct super_block *sb = inode->i_sb;
+	struct axfs_super *sbi = AXFS_SB(sb);
+	u64 ino_number = inode->i_ino;
+	u64 entry;
+	loff_t dir_index;
+	char *name;
+	int namelen, mode;
+	int err = 0;
+
+	/* Get the current index into the directory and verify it is not beyond
+	   the end of the list */
+	dir_index = filp->f_pos;
+	if (dir_index >= AXFS_GET_INODE_NUM_ENTRIES(sbi, ino_number))
+		goto out;
+
+	/* Verify the inode is for a directory */
+	if (!(S_ISDIR(inode->i_mode))) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	while (dir_index < AXFS_GET_INODE_NUM_ENTRIES(sbi, ino_number)) {
+		entry = AXFS_GET_INODE_ARRAY_INDEX(sbi, ino_number) + dir_index;
+
+		name = (char *)AXFS_GET_INODE_NAME(sbi, entry);
+		namelen = strlen(name);
+
+		mode = (int)AXFS_GET_MODE(sbi, entry);
+		err = filldir(dirent, name, namelen, dir_index, entry, mode);
+
+		if (err)
+			break;
+
+		dir_index++;
+		filp->f_pos = dir_index;
+	}
+
+out:
+	return 0;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
+/******************************************************************************
+ *
+ * axfs_fault
+ *
+ * Description: This function is mapped into the VMA operations vector, and
+ *              gets called on a page fault. Depending on whether the page
+ *              is XIP or compressed, xip_file_fault or filemap_fault is
+ *              called.  This function also logs when a fault occurs when
+ *              profiling is on.
+ *
+ * Parameters:
+ *    (IN) vma  - The virtual memory area corresponding to a file
+ *
+ *    (IN) vmf  - The fault info pass in by the fault handler
+ *
+ * Returns:
+ *    0 or error number
+ *
+ *****************************************************************************/
+static int axfs_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+#else
+static struct page *axfs_nopage(struct vm_area_struct *vma,
+				unsigned long address, int *type)
+#endif
+{
+	struct file *file = vma->vm_file;
+	struct inode *inode = file->f_dentry->d_inode;
+	struct super_block *sb = inode->i_sb;
+	struct axfs_super *sbi = AXFS_SB(sb);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
+#else
+	unsigned long pgoff;
+#endif
+	u64 ino_number = inode->i_ino;
+	u64 array_index;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
+	array_index = AXFS_GET_INODE_ARRAY_INDEX(sbi, ino_number) + vmf->pgoff;
+#else
+	pgoff = ((address - vma->vm_start) >> PAGE_CACHE_SHIFT) + vma->vm_pgoff;
+	array_index = AXFS_GET_INODE_ARRAY_INDEX(sbi, ino_number) + pgoff;
+#endif
+
+	/* if that pages are marked for write they will probably end up in RAM
+	   therefore we don't want their counts for being XIP'd */
+	if (!(vma->vm_flags & VM_WRITE))
+		axfs_profiling_add(sbi, array_index, ino_number);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
+	/* figure out if the node is XIP or compressed and call the
+	   appropriate function
+	 */
+#ifdef VM_MIXEDMAP
+	if (AXFS_IS_NODE_XIP(sbi, array_index))
+#else
+	if (AXFS_IS_NODE_XIP(sbi, array_index) && !AXFS_PHYSADDR_IS_VALID(sbi))
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
+		return xip_file_fault(vma, vmf);
+#else
+		return xip_file_nopage(vma, address, type);
+#endif
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
+	return filemap_fault(vma, vmf);
+#else
+	return filemap_nopage(vma, address, type);
+#endif
+
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
+#else
+static ssize_t axfs_xip_file_read(struct file *filp, char __user *buf,
+				  size_t len, loff_t *ppos)
+{
+	struct address_space *mapping = filp->f_mapping;
+	struct inode *inode = mapping->host;
+	unsigned long index, end_index, offset;
+	loff_t isize, pos;
+	size_t copied = 0, error = 0;
+
+	pos = *ppos;
+	index = pos >> PAGE_CACHE_SHIFT;
+	offset = pos & ~PAGE_CACHE_MASK;
+
+	isize = i_size_read(inode);
+	if (!isize)
+		goto out;
+
+	end_index = (isize - 1) >> PAGE_CACHE_SHIFT;
+	do {
+		unsigned long nr, left, pfn;
+		void *xip_mem;
+		int zero = 0;
+
+		/* nr is the maximum number of bytes to copy from this page */
+		nr = PAGE_CACHE_SIZE;
+		if (index >= end_index) {
+			if (index > end_index)
+				goto out;
+			nr = ((isize - 1) & ~PAGE_CACHE_MASK) + 1;
+			if (nr <= offset)
+				goto out;
+		}
+		nr = nr - offset;
+		if (nr > len)
+			nr = len;
+		axfs_get_xip_mem(mapping, index, 0, &xip_mem, &pfn);
+		if (!xip_mem) {
+			error = -EIO;
+			goto out;
+		}
+		if (unlikely(IS_ERR(xip_mem))) {
+			if (PTR_ERR(xip_mem) == -ENODATA) {
+				/* sparse */
+				zero = 1;
+			} else {
+				error = PTR_ERR(xip_mem);
+				goto out;
+			}
+		}
+		/*
+		 * Ok, we have the mem, so now we can copy it to user space...
+		 *
+		 * The actor routine returns how many bytes were actually used..
+		 * NOTE! This may not be the same as how much of a user buffer
+		 * we filled up (we may be padding etc), so we can only update
+		 * "pos" here (the actor routine has to update the user buffer
+		 * pointers and the remaining count).
+		 */
+		if (!zero)
+			left =
+			    __copy_to_user(buf + copied, xip_mem + offset, nr);
+		else
+			left = __clear_user(buf + copied, nr);
+
+		if (left) {
+			error = -EFAULT;
+			goto out;
+		}
+
+		copied += (nr - left);
+		offset += (nr - left);
+		index += offset >> PAGE_CACHE_SHIFT;
+		offset &= ~PAGE_CACHE_MASK;
+	} while (copied < len);
+
+out:
+	*ppos = pos + copied;
+	if (filp)
+		file_accessed(filp);
+
+	return (copied ? copied : error);
+}
+#endif
+
+/******************************************************************************
+ *
+ * axfs_file_read
+ *
+ * Description: axfs_file_read is mapped into the file_operations vector for
+ *              all axfs files. It loops through the pages to be read and calls
+ *              either do_sync_read (if the page is a compressed one) or
+ *              xip_file_read (if the page is XIP).
+ *
+ * Parameters:
+ *    (IN) filp -  file to be read
+ *
+ *    (OUT) buf - user buffer that is filled with the data that we read.
+ *
+ *    (IN) len - length of file to be read
+ *
+ *    (IN) ppos - offset within the file to read from
+ *
+ * Returns:
+ *    actual size of data read.
+ *
+ *****************************************************************************/
+static ssize_t axfs_file_read(struct file *filp, char __user *buf, size_t len,
+			      loff_t *ppos)
+{
+	struct inode *inode = filp->f_dentry->d_inode;
+	struct super_block *sb = inode->i_sb;
+	struct axfs_super *sbi = AXFS_SB(sb);
+	size_t read = 0, total_read = 0;
+	size_t readlength, actual_size, file_size, remaining;
+	u64 ino_number = inode->i_ino;
+	u64 size, array_index;
+
+	file_size = AXFS_GET_INODE_FILE_SIZE(sbi, ino_number);
+	remaining = file_size - *ppos;
+	actual_size = len > remaining ? remaining : len;
+	readlength = actual_size < PAGE_SIZE ? actual_size : PAGE_SIZE;
+
+	for (size = actual_size; size > 0; size -= read) {
+		array_index = AXFS_GET_INODE_ARRAY_INDEX(sbi, ino_number);
+		array_index += *ppos >> PAGE_SHIFT;
+
+		if (AXFS_IS_NODE_XIP(sbi, array_index)) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
+			read = xip_file_read(filp, buf, readlength, ppos);
+#else
+			read = axfs_xip_file_read(filp, buf, readlength, ppos);
+#endif
+		} else {
+			read = do_sync_read(filp, buf, readlength, ppos);
+		}
+		buf += read;
+		total_read += read;
+
+		if ((len - total_read < PAGE_SIZE) && (total_read != len))
+			readlength = len - total_read;
+	}
+
+	return total_read;
+}
+
+static int axfs_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	struct super_block *sb = inode->i_sb;
+	struct axfs_super *sbi = AXFS_SB(sb);
+	u64 array_index, node_index, cnode_index, maxblock, ofs;
+	u64 ino_number = inode->i_ino;
+	u32 max_len, cnode_offset;
+	u32 cblk_size = sbi->cblock_size;
+	u32 len = 0;
+	u8 node_type;
+	void *pgdata;
+	void *src;
+	void *cblk0 = sbi->cblock_buffer[0];
+	void *cblk1 = sbi->cblock_buffer[1];
+
+	maxblock = (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
+	pgdata = kmap(page);
+
+	if (page->index >= maxblock)
+		goto out;
+
+	array_index = AXFS_GET_INODE_ARRAY_INDEX(sbi, ino_number);
+	array_index += page->index;
+
+	node_index = AXFS_GET_NODE_INDEX(sbi, array_index);
+	node_type = AXFS_GET_NODE_TYPE(sbi, array_index);
+
+	if (node_type == Compressed) {
+		/* node is in compessed region */
+		cnode_offset = AXFS_GET_CNODE_OFFSET(sbi, node_index);
+		cnode_index = AXFS_GET_CNODE_INDEX(sbi, node_index);
+		down_write(&sbi->lock);
+		if (cnode_index != sbi->current_cnode_index) {
+			/* uncompress only necessary if different cblock */
+			ofs = AXFS_GET_CBLOCK_OFFSET(sbi, cnode_index);
+			len = AXFS_GET_CBLOCK_OFFSET(sbi, cnode_index + 1);
+			len -= ofs;
+			axfs_copy_data(sb, cblk1, &(sbi->compressed), ofs, len);
+			axfs_uncompress_block(cblk0, cblk_size, cblk1, len);
+			sbi->current_cnode_index = cnode_index;
+		}
+		downgrade_write(&sbi->lock);
+		max_len = cblk_size - cnode_offset;
+		len = max_len > PAGE_CACHE_SIZE ? PAGE_CACHE_SIZE : max_len;
+		src = (void *)((unsigned long)cblk0 + cnode_offset);
+		memcpy(pgdata, src, len);
+		up_read(&sbi->lock);
+	} else if (node_type == Byte_Aligned) {
+		/* node is in BA region */
+		ofs = AXFS_GET_BANODE_OFFSET(sbi, node_index);
+		max_len = sbi->byte_aligned.size - ofs;
+		len = max_len > PAGE_CACHE_SIZE ? PAGE_CACHE_SIZE : max_len;
+		axfs_copy_data(sb, pgdata, &(sbi->byte_aligned), ofs, len);
+	} else {
+		/* node is XIP */
+		ofs = node_index << PAGE_SHIFT;
+		len = PAGE_CACHE_SIZE;
+		axfs_copy_data(sb, pgdata, &(sbi->xip), ofs, len);
+	}
+
+out:
+	memset(pgdata + len, 0, PAGE_CACHE_SIZE - len);
+	kunmap(page);
+	flush_dcache_page(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+	return 0;
+}
+
+static int axfs_get_xip_mem(struct address_space *mapping, pgoff_t offset,
+			    int create, void **kaddr, unsigned long *pfn)
+{
+	struct inode *inode = mapping->host;
+	struct super_block *sb = inode->i_sb;
+	struct axfs_super *sbi = AXFS_SB(sb);
+	u64 ino_number = inode->i_ino;
+	u64 ino_index, node_index;
+
+	ino_index = AXFS_GET_INODE_ARRAY_INDEX(sbi, ino_number);
+	ino_index += offset;
+
+	node_index = AXFS_GET_NODE_INDEX(sbi, ino_index);
+
+	*kaddr = (void *)(sbi->xip.virt_addr + (node_index << PAGE_SHIFT));
+	if (AXFS_PHYSADDR_IS_VALID(sbi)) {
+		*pfn = (AXFS_GET_XIP_REGION_PHYSADDR(sbi) >> PAGE_SHIFT);
+		*pfn += node_index;
+	} else {
+		*pfn = page_to_pfn(virt_to_page((unsigned long)*kaddr));
+	}
+
+	return 0;
+}
+
+#ifdef VM_MIXEDMAP
+#else
+
+struct page *axfs_get_xip_page(struct address_space *mapping, sector_t offset,
+			       int create)
+{
+	unsigned long pfn;
+	void *kaddr;
+
+	axfs_get_xip_mem(mapping, offset * 512, create, &kaddr, &pfn);
+
+	return virt_to_page(kaddr);
+}
+#endif
diff --git a/fs/axfs/axfs_mtd.c b/fs/axfs/axfs_mtd.c
new file mode 100644
index 0000000..8b3ab18
--- /dev/null
+++ b/fs/axfs/axfs_mtd.c
@@ -0,0 +1,506 @@
+/*
+ * Advanced XIP File System for Linux - AXFS
+ *   Readonly, compressed, and XIP filesystem for Linux systems big and small
+ *
+ * Copyright(c) 2008 Numonyx
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * Authors:
+ *  Jared Hulbert <jaredeh@gmail.com>
+ *
+ * Project url: http://axfs.sourceforge.net
+ *
+ * axfs_mtd.c -
+ *   Allows axfs to use mtd devices or has dummy functions if mtd
+ *   device support is compiled out of the kernel.
+ */
+
+#include <linux/axfs.h>
+#include <linux/fs.h>
+#include <linux/mount.h>
+#include <linux/ctype.h>
+#include <linux/namei.h>
+
+#ifdef CONFIG_MTD
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
+#include <linux/mtd/super.h>
+#else
+#include <linux/mtd/mtd.h>
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,25)
+#else
+#define OLD_POINT 1
+#endif
+
+int axfs_fill_super(struct super_block *, void *, int);
+
+static struct mtd_info *axfs_get_mtd_device(int mtdnr)
+{
+	struct mtd_info *device;
+
+	device = get_mtd_device(NULL, mtdnr);
+
+	if (!PTR_ERR(device))
+		return NULL;
+
+	return device;
+}
+
+int axfs_is_dev_mtd(char *path, int *mtdnr)
+{
+	char *off = NULL;
+	char *endptr = NULL;
+	char dev[] = "/dev/\0";
+	char mtd[] = "mtd\0";
+	char mtdblk[] = "mtdblock\0";
+
+	if (!path || !*path)
+		return FALSE;
+
+	off = path;
+
+	if (strncmp(dev, off, strlen(dev)) == 0)
+		off += strlen(dev);
+
+	if (!strncmp(mtd, off, strlen(mtd)) && isdigit(off[strlen(mtd)]))
+		off += strlen(mtd);
+
+	if (!strncmp(mtdblk, off, strlen(mtdblk))
+	    && isdigit(off[strlen(mtdblk)]))
+		off += strlen(mtdblk);
+
+	*mtdnr = simple_strtoul(off, &endptr, 0);
+
+	if (!*endptr)
+		return TRUE;
+
+	return FALSE;
+}
+
+static struct mtd_info *axfs_get_mtd_info(struct super_block *sb, u64 fsoffset)
+{
+	struct axfs_super *sbi = AXFS_SB(sb);
+
+	if (fsoffset == 0)
+		return (struct mtd_info *)AXFS_MTD0(sb);
+
+	if (fsoffset < sbi->mmap_size)
+		return (struct mtd_info *)AXFS_MTD0(sb);
+
+	if (AXFS_MTD1(sb) != NULL)
+		return (struct mtd_info *)AXFS_MTD1(sb);
+
+	return (struct mtd_info *)AXFS_MTD0(sb);
+}
+
+int axfs_copy_mtd(struct super_block *sb, void *dst, u64 fsoffset, u64 len)
+{
+	struct axfs_super *sbi = AXFS_SB(sb);
+	u64 offset = AXFS_FSOFFSET_2_DEVOFFSET(sbi, fsoffset);
+	struct mtd_info *mtd;
+	u_char *mtdbuf = (u_char *) dst;
+	size_t retlen;
+	int err;
+
+	if (len == 0)
+		return 0;
+
+	mtd = axfs_get_mtd_info(sb, fsoffset);
+	err = mtd->read(mtd, (loff_t) offset, (size_t) len, &retlen, mtdbuf);
+
+	if (len != retlen)
+		return -EIO;
+
+	return err;
+}
+
+/******************************************************************************
+ *
+ * axfs_map_mtd
+ *
+ * Description: When provided, uses the mtd point() capability to map allow
+ *              axfs a direct memory access to the filesystem.
+ *
+ * Parameters:
+ *    (IN) sb - pointer to the super_block structure
+ *
+ * Returns:
+ *    0 or error number
+ *
+ *****************************************************************************/
+int axfs_map_mtd(struct super_block *sb)
+{
+	struct axfs_super *sbi = AXFS_SB(sb);
+	struct mtd_info *mtd = (struct mtd_info *)AXFS_MTD0(sb);
+	size_t retlen;
+	int err = 0;
+#ifndef OLD_POINT
+	void *virt;
+	resource_size_t phys;
+#else
+	u_char *virt;
+#endif
+
+	if (!mtd->point || !mtd->unpoint)
+		return 0;
+
+#ifndef OLD_POINT
+	err = mtd->point(mtd, 0, sbi->mmap_size, &retlen, &virt, &phys);
+#else
+	err = mtd->point(mtd, 0, sbi->mmap_size, &retlen, &virt);
+#endif
+	if (err)
+		return err;
+
+	if (retlen != sbi->mmap_size) {
+#ifndef OLD_POINT
+		mtd->unpoint(mtd, 0, retlen);
+#else
+		mtd->unpoint(mtd, 0, 0, retlen);
+#endif
+		return -EINVAL;
+	}
+
+	sbi->virt_start_addr = (unsigned long)virt;
+#ifndef OLD_POINT
+	sbi->phys_start_addr = (unsigned long)phys;
+#else
+	sbi->phys_start_addr = 0;
+#endif
+	sbi->mtd_pointed = TRUE;
+
+	return 0;
+}
+
+void axfs_unmap_mtd(struct super_block *sb)
+{
+	struct axfs_super *sbi = AXFS_SB(sb);
+	struct mtd_info *mtd = (struct mtd_info *)AXFS_MTD0(sb);
+
+	if (!sbi)
+		return;
+
+	if (AXFS_MTD1(sb))
+		put_mtd_device((struct mtd_info *)AXFS_MTD1(sb));
+
+	if (AXFS_IS_POINTED(sbi)) {
+#ifndef OLD_POINT
+		mtd->unpoint(mtd, 0, sbi->mmap_size);
+#else
+		mtd->unpoint(mtd, 0, 0, sbi->mmap_size);
+#endif
+	} else {
+		if (AXFS_MTD0(sb))
+			put_mtd_device((struct mtd_info *)AXFS_MTD0(sb));
+	}
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
+#else
+/* -------------------- START COPY FROM 2.6.22 -------------------------- */
+/* MTD-based superblock management
+ *
+ * Copyright Â© 2001-2007 Red Hat, Inc. All Rights Reserved.
+ * Written by:  David Howells <dhowells@redhat.com>
+ *              David Woodhouse <dwmw2@infradead.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+/*
+ * compare superblocks to see if they're equivalent
+ * - they are if the underlying MTD device is the same
+ */
+static int get_sb_mtd_compare(struct super_block *sb, void *_mtd)
+{
+	struct mtd_info *mtd = _mtd;
+	struct mtd_info *s_mtd = (struct mtd_info *)AXFS_MTD0(sb);
+
+	if (s_mtd == mtd) {
+		DEBUG(2, "MTDSB: Match on device %d (\"%s\")\n",
+		      mtd->index, mtd->name);
+		return 1;
+	}
+
+	DEBUG(2, "MTDSB: No match, device %d (\"%s\"), device %d (\"%s\")\n",
+	      s_mtd->index, s_mtd->name, mtd->index, mtd->name);
+	return 0;
+}
+
+/*
+ * mark the superblock by the MTD device it is using
+ * - set the device number to be the correct MTD block device for pesuperstence
+ *   of NFS exports
+ */
+static int get_sb_mtd_set(struct super_block *sb, void *_mtd)
+{
+	struct mtd_info *mtd = _mtd;
+	struct mtd_info *s_mtd = (struct mtd_info *)AXFS_MTD0(sb);
+
+	s_mtd = mtd;
+	sb->s_dev = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
+	return 0;
+}
+
+/* Lifted wholesale from 2.6.22 */
+int simple_set_mnt(struct vfsmount *mnt, struct super_block *sb)
+{
+	mnt->mnt_sb = sb;
+	mnt->mnt_root = dget(sb->s_root);
+	return 0;
+}
+
+/*
+ * get a superblock on an MTD-backed filesystem
+ */
+static int get_sb_mtd_aux(struct file_system_type *fs_type, int flags,
+			  const char *dev_name, void *data,
+			  struct mtd_info *mtd,
+			  int (*fill_super) (struct super_block *, void *, int),
+			  struct vfsmount *mnt)
+{
+	struct super_block *sb;
+	int ret;
+
+	sb = sget(fs_type, get_sb_mtd_compare, get_sb_mtd_set, mtd);
+	if (IS_ERR(sb))
+		goto out_error;
+
+	if (sb->s_root)
+		goto already_mounted;
+
+	/* fresh new superblock */
+	DEBUG(1, "MTDSB: New superblock for device %d (\"%s\")\n",
+	      mtd->index, mtd->name);
+
+	ret = fill_super(sb, data, 0);
+	if (ret < 0) {
+		up_write(&sb->s_umount);
+		deactivate_super(sb);
+		return ret;
+	}
+
+	/* go */
+	sb->s_flags |= MS_ACTIVE;
+	return simple_set_mnt(mnt, sb);
+
+	/* new mountpoint for an already mounted superblock */
+      already_mounted:
+	DEBUG(1, "MTDSB: Device %d (\"%s\") is already mounted\n",
+	      mtd->index, mtd->name);
+	ret = simple_set_mnt(mnt, sb);
+	goto out_put;
+
+      out_error:
+	ret = PTR_ERR(sb);
+      out_put:
+	put_mtd_device(mtd);
+	return ret;
+}
+
+/*
+ * get a superblock on an MTD-backed filesystem by MTD device number
+ */
+static int get_sb_mtd_nr(struct file_system_type *fs_type, int flags,
+			 const char *dev_name, void *data, int mtdnr,
+			 int (*fill_super) (struct super_block *, void *, int),
+			 struct vfsmount *mnt)
+{
+	struct mtd_info *mtd;
+
+	mtd = get_mtd_device(NULL, mtdnr);
+	if (IS_ERR(mtd)) {
+		DEBUG(0, "MTDSB: Device #%u doesn't appear to exist\n", mtdnr);
+		return PTR_ERR(mtd);
+	}
+
+	return get_sb_mtd_aux(fs_type, flags, dev_name, data, mtd, fill_super,
+			      mnt);
+}
+
+/*
+ * set up an MTD-based superblock
+ */
+static int get_sb_mtd(struct file_system_type *fs_type, int flags,
+		      const char *dev_name, void *data,
+		      int (*fill_super) (struct super_block *, void *, int),
+		      struct vfsmount *mnt)
+{
+	struct nameidata nd;
+	int mtdnr, ret;
+
+	if (!dev_name)
+		return -EINVAL;
+
+	DEBUG(2, "MTDSB: dev_name \"%s\"\n", dev_name);
+
+	/* the preferred way of mounting in future; especially when
+	 * CONFIG_BLOCK=n - we specify the underlying MTD device by number or
+	 * by name, so that we don't require block device support to be present
+	 * in the kernel. */
+	if (dev_name[0] == 'm' && dev_name[1] == 't' && dev_name[2] == 'd') {
+		if (dev_name[3] == ':') {
+			struct mtd_info *mtd;
+
+			/* mount by MTD device name */
+			DEBUG(1, "MTDSB: mtd:%%s, name \"%s\"\n", dev_name + 4);
+
+			for (mtdnr = 0; mtdnr < MAX_MTD_DEVICES; mtdnr++) {
+				mtd = get_mtd_device(NULL, mtdnr);
+				if (!IS_ERR(mtd)) {
+					if (!strcmp(mtd->name, dev_name + 4))
+						return get_sb_mtd_aux(fs_type,
+								      flags,
+								      dev_name,
+								      data, mtd,
+								      fill_super,
+								      mnt);
+
+					put_mtd_device(mtd);
+				}
+			}
+
+			printk(KERN_NOTICE "MTD:"
+			       " MTD device with name \"%s\" not found.\n",
+			       dev_name + 4);
+
+		} else if (isdigit(dev_name[3])) {
+			/* mount by MTD device number name */
+			char *endptr;
+
+			mtdnr = simple_strtoul(dev_name + 3, &endptr, 0);
+			if (!*endptr) {
+				/* It was a valid number */
+				DEBUG(1, "MTDSB: mtd%%d, mtdnr %d\n", mtdnr);
+				return get_sb_mtd_nr(fs_type, flags,
+						     dev_name, data,
+						     mtdnr, fill_super, mnt);
+			}
+		}
+	}
+
+	/* try the old way - the hack where we allowed users to mount
+	 * /dev/mtdblock$(n) but didn't actually _use_ the blockdev
+	 */
+	ret = path_lookup(dev_name, LOOKUP_FOLLOW, &nd);
+
+	DEBUG(1, "MTDSB: path_lookup() returned %d, inode %p\n",
+	      ret, nd.dentry ? nd.dentry->d_inode : NULL);
+
+	if (ret)
+		return ret;
+
+	ret = -EINVAL;
+
+	if (!S_ISBLK(nd.dentry->d_inode->i_mode))
+		goto out;
+
+	if (nd.mnt->mnt_flags & MNT_NODEV) {
+		ret = -EACCES;
+		goto out;
+	}
+
+	if (imajor(nd.dentry->d_inode) != MTD_BLOCK_MAJOR)
+		goto not_an_MTD_device;
+
+	mtdnr = iminor(nd.dentry->d_inode);
+	path_release(&nd);
+
+	return get_sb_mtd_nr(fs_type, flags, dev_name, data, mtdnr, fill_super,
+			     mnt);
+
+      not_an_MTD_device:
+	printk(KERN_NOTICE
+	       "MTD: Attempt to mount non-MTD device \"%s\"\n", dev_name);
+      out:
+	path_release(&nd);
+	return ret;
+
+}
+
+/*
+ * destroy an MTD-based superblock
+ */
+static void kill_mtd_super(struct super_block *sb)
+{
+	struct mtd_info *s_mtd = (struct mtd_info *)AXFS_MTD0(sb);
+	generic_shutdown_super(sb);
+	put_mtd_device(s_mtd);
+	AXFS_MTD0(sb) = NULL;
+}
+
+/* ---------------------- END COPY --------------------------------------*/
+#endif
+
+int axfs_get_sb_mtd(struct file_system_type *fs_type, int flags,
+		    const char *dev_name, struct axfs_super *sbi,
+		    struct vfsmount *mnt, int *err)
+{
+	int nflags, mtdnr;
+
+	if (axfs_is_dev_mtd(sbi->second_dev, &mtdnr)) {
+		sbi->mtd1 = (void *)axfs_get_mtd_device(mtdnr);
+		if (!sbi->mtd1) {
+			*err = -EINVAL;
+			return FALSE;
+		}
+	}
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
+	nflags = flags & MS_SILENT;
+#else
+	nflags = flags;
+#endif
+
+	*err = get_sb_mtd(fs_type, nflags, dev_name, sbi, axfs_fill_super, mnt);
+	if (*err)
+		return FALSE;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,21)
+	sbi->mtd0 = mnt->mnt_sb->s_mtd;
+#endif
+	return TRUE;
+}
+
+void axfs_kill_mtd_super(struct super_block *sb)
+{
+	kill_mtd_super(sb);
+}
+#else
+
+int axfs_map_mtd(struct super_block *sb)
+{
+	return 0;
+}
+
+void axfs_unmap_mtd(struct super_block *sb)
+{
+}
+
+int axfs_copy_mtd(struct super_block *sb, void *dst, u64 fsoffset, u64 len)
+{
+	return -EINVAL;
+}
+
+int axfs_get_sb_mtd(struct file_system_type *fs_type, int flags,
+		    const char *dev_name, char *second_dev,
+		    struct axfs_super *sbi, struct vfsmount *mnt, int *err)
+{
+	return FALSE;
+}
+
+int axfs_is_dev_mtd(char *path, int *mtdnr)
+{
+	return FALSE;
+}
+
+void axfs_kill_mtd_super(struct super_block *sb)
+{
+}
+
+#endif /* CONFIG_MTD */
diff --git a/fs/axfs/axfs_physmem.c b/fs/axfs/axfs_physmem.c
new file mode 100644
index 0000000..e225966
--- /dev/null
+++ b/fs/axfs/axfs_physmem.c
@@ -0,0 +1,69 @@
+/*
+ * Advanced XIP File System for Linux - AXFS
+ *   Readonly, compressed, and XIP filesystem for Linux systems big and small
+ *
+ * Copyright(c) 2008 Numonyx
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * Authors:
+ *  Jared Hulbert <jaredeh@gmail.com>
+ *
+ * Project url: http://axfs.sourceforge.net
+ *
+ * axfs_physmem.c -
+ *   Allows axfs to use striaght memory or has dummy functions if
+ *   this is a UML system.
+ */
+
+#include <linux/axfs.h>
+#include <linux/fs.h>
+#ifdef CONFIG_UML
+
+void axfs_map_physmem(struct axfs_super *sbi, unsigned long size)
+{
+}
+
+void axfs_unmap_physmem(struct super_block *sb)
+{
+}
+
+#else
+#include <asm/io.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
+#else
+#include <asm/pgtable.h>
+#endif
+
+#ifdef ioremap_cached
+#define AXFS_REMAP(a,b) (void __force *)ioremap_cached((a),(b))
+#else
+#define AXFS_REMAP(a,b) (void __force *)ioremap((a),(b))
+#endif /* ioremap_cached */
+
+void axfs_map_physmem(struct axfs_super *sbi, unsigned long size)
+{
+	void *addr;
+
+	if (AXFS_IS_PHYSMEM(sbi)) {
+		addr = AXFS_REMAP(sbi->phys_start_addr, size);
+		sbi->virt_start_addr = (unsigned long)addr;
+	}
+}
+
+void axfs_unmap_physmem(struct super_block *sb)
+{
+	struct axfs_super *sbi = AXFS_SB(sb);
+
+	if (!sbi)
+		return;
+
+	if (AXFS_IS_PHYSMEM(sbi) && AXFS_VIRTADDR_IS_VALID(sbi)) {
+		iounmap((void *)(sbi->virt_start_addr));
+		sbi->virt_start_addr = 0;
+	}
+}
+
+#endif /* CONFIG_UML */
diff --git a/fs/axfs/axfs_profiling.c b/fs/axfs/axfs_profiling.c
new file mode 100644
index 0000000..be39a61
--- /dev/null
+++ b/fs/axfs/axfs_profiling.c
@@ -0,0 +1,602 @@
+/*
+ * Advanced XIP File System for Linux - AXFS
+ *   Readonly, compressed, and XIP filesystem for Linux systems big and small
+ *
+ * Copyright(c) 2008 Numonyx
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * Authors:
+ *  Eric Anderson
+ *  Jared Hulbert <jaredeh@gmail.com>
+ *  Sujaya Srinivasan
+ *  Justin Treon
+ *
+ * More info and current contacts at http://axfs.sourceforge.net
+ *
+ * axfs_profiling.c -
+ *   Tracks pages of files that enter the page cache.  Outputs through a proc
+ *   file which generates a comma separated data file with path, page offset,
+ *   count of times entered page cache.
+ */
+
+#include <linux/axfs.h>
+#ifdef CONFIG_AXFS_PROFILING
+#include <linux/module.h>
+#include <linux/vmalloc.h>
+#include <linux/proc_fs.h>
+
+#define AXFS_PROC_DIR_NAME "axfs"
+
+struct axfs_profiling_manager {
+	struct axfs_profiling_data *profiling_data;
+	struct axfs_super *sbi;
+	u32 *dir_structure;
+	u32 size;
+};
+
+#define MAX_STRING_LEN 1024
+
+/* Handles for our Directory and File */
+static struct proc_dir_entry *axfs_proc_dir;
+static u32 proc_name_inc;
+
+/******************************************************************************
+ *
+ * axfs_init_profile_dir_structure
+ *
+ * Description:
+ *   Creates the structures for tracking the page usage data and creates the
+ *   proc file that will be used to get the data.
+ *
+ * Parameters:
+ *    (IN) manager - pointer to the profile manager for the filing system
+ *
+ *    (IN) num_inodes - number of files in the system
+ *
+ * Returns:
+ *    0
+ *
+ *****************************************************************************/
+static int axfs_init_profile_dir_structure(struct axfs_profiling_manager
+					   *manager, u32 num_inodes)
+{
+
+	struct axfs_super *sbi = (struct axfs_super *)manager->sbi;
+	u32 child_index = 0, i, j;
+	u32 *dir_structure = manager->dir_structure;
+
+	/* loop through each inode in the image and find all
+	   of the directories and mark their children */
+	for (i = 0; i < num_inodes; i++) {
+		/* determine if the entry is a directory */
+		if (!S_ISDIR(AXFS_GET_MODE(sbi, i)))
+			continue;
+
+		/* get the index number for this directory */
+		child_index = AXFS_GET_INODE_ARRAY_INDEX(sbi, i);
+
+		/* get the offset to its children */
+		for (j = 0; j < AXFS_GET_INODE_NUM_ENTRIES(sbi, i); j++) {
+			if (dir_structure[child_index + j] != 0) {
+				printk(KERN_ERR
+				       "axfs: ERROR inode was already set old "
+				       "%lu new %lu\n", (unsigned long)
+				       dir_structure[child_index + j],
+				       (unsigned long)i);
+			}
+			dir_structure[child_index + j] = i;
+		}
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+ *
+ * axfs_get_directory_path
+ *
+ * Description:
+ *   Determines the directory path of every file for printing the spreadsheet.
+ *
+ * Parameters:
+ *    (IN) manager - Pointer to axfs profile manager
+ *
+ *    (OUT) buffer - Pointer to the printable directory path for each file
+ *
+ *    (IN) inode_number - Inode number of file to look up
+ *
+ * Returns:
+ *    Size of the path to the file
+ *
+ *
+ **************************************************************************/
+static int axfs_get_directory_path(struct axfs_profiling_manager *manager,
+				   char *buffer, u32 inode_number)
+{
+	u32 path_depth = 0;
+	u32 path_size = 0;
+	u32 string_len = 0;
+	u32 index = inode_number;
+	u32 dir_number;
+	u8 **path_array = NULL;
+	struct axfs_super *sbi = (struct axfs_super *)manager->sbi;
+	int i;
+
+	/* determine how deep the directory path is and how big the name
+	   string will be walk back until the root directory index is found
+	   (index 0 is root) */
+	while (manager->dir_structure[index] != 0) {
+		path_depth++;
+		/* set the index to the index of the parent directory */
+		index = manager->dir_structure[index];
+	}
+
+	if (path_depth != 0) {
+		/* create an array that will hold a pointer for each of the
+		   directories names */
+		path_array = vmalloc(path_depth * sizeof(*path_array));
+		if (path_array == NULL) {
+			printk(KERN_DEBUG
+			       "axfs: directory_path vmalloc failed.\n");
+			goto out;
+		}
+	}
+
+	index = manager->dir_structure[inode_number];
+	for (i = path_depth; i > 0; i--) {
+		/* get the array_index for the directory corresponding to
+		   index */
+		dir_number = AXFS_GET_INODE_ARRAY_INDEX(sbi, index);
+
+		/* store a pointer to the name in the array */
+		path_array[(i - 1)] = (u8 *) AXFS_GET_INODE_NAME(sbi, index);
+
+		index = manager->dir_structure[index];
+	}
+
+	/* now print out the directory structure from the begining */
+	string_len = sprintf(buffer, "./");
+	path_size += string_len;
+	for (i = 0; i < path_depth; i++) {
+		buffer = buffer + string_len;
+		string_len = sprintf(buffer, "%s/", (char *)path_array[i]);
+		path_size += string_len;
+	}
+
+	if (path_array != NULL)
+		vfree(path_array);
+
+out:
+	return path_size;
+
+}
+
+static ssize_t axfs_procfile_read(char *buffer,
+				  char **buffer_location,
+				  off_t offset, int buffer_length, int *eof,
+				  void *data)
+{
+	struct axfs_profiling_manager *man;
+	struct axfs_profiling_data *profile;
+	struct axfs_super *sbi;
+	u64 array_index;
+	u64 loop_size, inode_page_offset, node_offset, inode_number;
+	u64 print_len = 0;
+	unsigned long addr;
+	int len = 0;
+	int i;
+	char *buff, *name = NULL;
+
+	man = (struct axfs_profiling_manager *)data;
+	sbi = man->sbi;
+
+	loop_size = man->size / sizeof(*profile);
+
+	/* If all data has been returned set EOF */
+	if (offset >= loop_size) {
+		*eof = 1;
+		return 0;
+	}
+
+	buff = buffer;
+	/* print as much as the buffer can take */
+	for (i = offset; i < loop_size; i++) {
+
+		if ((print_len + MAX_STRING_LEN) > buffer_length)
+			break;
+		/* get the first profile data structure */
+		profile = &(man->profiling_data[i]);
+
+		if (profile->count == 0)
+			continue;
+
+		inode_number = profile->inode_number;
+
+		/* file names can be duplicated so we must print out the path */
+		len = axfs_get_directory_path(man, buff, inode_number);
+
+		print_len += len;
+		buff += len;
+
+		/* get a pointer to the inode name */
+		array_index = AXFS_GET_INODE_ARRAY_INDEX(sbi, inode_number);
+		name = (char *)AXFS_GET_INODE_NAME(sbi, inode_number);
+
+		/* need to convert the page number in the node area to
+		   the page number within the file */
+		node_offset = i;
+		/* gives the offset of the node in the node list area
+		   then substract that from the */
+		inode_page_offset = node_offset - array_index;
+
+		/* set everything up to print out */
+		addr = (unsigned long)(inode_page_offset * PAGE_SIZE);
+		len = sprintf(buff, "%s,%lu,%lu\n", name, addr, profile->count);
+
+		print_len += len;
+		buff += len;
+	}
+
+	/* return the number of items printed.
+	   This will be added to offset and passed back to us */
+	*buffer_location = (char *)(i - offset);
+
+	return print_len;
+}
+
+static ssize_t axfs_procfile_write(struct file *file,
+				   const char *buffer, unsigned long count,
+				   void *data)
+{
+	struct axfs_profiling_manager *man_ptr =
+	    (struct axfs_profiling_manager *)data;
+
+	if ((count >= 2) && (0 == memcmp(buffer, "on", 2))) {
+		man_ptr->sbi->profiling_on = TRUE;
+	} else if ((count >= 3) && (0 == memcmp(buffer, "off", 3))) {
+		man_ptr->sbi->profiling_on = FALSE;
+	} else if ((count >= 5) && (0 == memcmp(buffer, "clear", 5))) {
+		memset(man_ptr->profiling_data, 0, man_ptr->size);
+	} else {
+		printk(KERN_INFO
+		       "axfs: Unknown command.  Supported options are:\n");
+		printk(KERN_INFO "\t\"on\"\tTurn on profiling\n");
+		printk(KERN_INFO "\t\"off\"\tTurn off profiling\n");
+		printk(KERN_INFO "\t\"clear\"\tClear profiling buffer\n");
+	}
+
+	return count;
+}
+
+static int axfs_create_proc_directory(void)
+{
+	if (axfs_proc_dir == NULL) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,25)
+		axfs_proc_dir = proc_mkdir(AXFS_PROC_DIR_NAME, NULL);
+#else
+		axfs_proc_dir = proc_mkdir(AXFS_PROC_DIR_NAME, &proc_root);
+#endif
+		if (!axfs_proc_dir) {
+			printk(KERN_WARNING
+			       "axfs: Failed to create directory\n");
+			return FALSE;
+		}
+	}
+	return TRUE;
+}
+
+static void axfs_delete_proc_directory(void)
+{
+	/* Determine if there are any directory elements
+	   and remove if all of the proc files are removed. */
+	if (axfs_proc_dir != NULL) {
+		if (axfs_proc_dir->subdir == NULL) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,25)
+			remove_proc_entry(AXFS_PROC_DIR_NAME, NULL);
+#else
+			remove_proc_entry(AXFS_PROC_DIR_NAME, &proc_root);
+#endif
+			axfs_proc_dir = NULL;
+		}
+	}
+}
+
+/******************************************************************************
+ *
+ * axfs_delete_proc_file
+ *
+ * Description:
+ *   Will search through the proc directory for the correct proc file,
+ *   then delete it
+ *
+ * Parameters:
+ *    (IN) sbi- axfs superblock pointer to determine which proc file to remove
+ *
+ * Returns:
+ *    The profiling manager pointer for the proc file.
+ *
+ *****************************************************************************/
+static struct axfs_profiling_manager *axfs_delete_proc_file(struct axfs_super
+							    *sbi)
+{
+	struct proc_dir_entry *current_proc_file;
+	struct axfs_profiling_manager *manager;
+	void *rv = NULL;
+
+	if (!axfs_proc_dir)
+		return NULL;
+
+	/* Walk through the proc file entries to find the matching sbi */
+	current_proc_file = axfs_proc_dir->subdir;
+
+	while (current_proc_file != NULL) {
+		manager = current_proc_file->data;
+		if (manager == NULL) {
+			printk(KERN_WARNING
+			       "axfs: Error removing proc file private "
+			       "data was NULL.\n");
+			rv = NULL;
+			break;
+		}
+		if (manager->sbi == sbi) {
+			/* we found the match */
+			remove_proc_entry(current_proc_file->name,
+					  axfs_proc_dir);
+			rv = (void *)manager;
+			break;
+		}
+		current_proc_file = axfs_proc_dir->next;
+	}
+	return (struct axfs_profiling_manager *)rv;
+}
+
+/******************************************************************************
+ *
+ * axfs_register_profiling_proc
+ *
+ * Description:
+ *   Will register the instance of the proc file for a given volume.
+ *
+ * Parameters:
+ *    (IN) manager - Pointer to the profiling manager for the axfs volume
+ *
+ * Returns:
+ *    0 or error number
+ *
+ *****************************************************************************/
+static int axfs_register_profiling_proc(struct axfs_profiling_manager *manager)
+{
+	int rv = 0;
+	struct proc_dir_entry *proc_file;
+	char file_name[20];
+
+	if (!axfs_create_proc_directory()) {
+		rv = -ENOMEM;
+		goto out;
+	}
+
+	sprintf(file_name, "volume%d", proc_name_inc);
+	proc_file = create_proc_entry(file_name, (mode_t) 0644, axfs_proc_dir);
+	if (proc_file == NULL) {
+		remove_proc_entry(file_name, axfs_proc_dir);
+		axfs_delete_proc_directory();
+		rv = -ENOMEM;
+		goto out;
+	}
+
+	proc_name_inc++;
+	proc_file->read_proc = axfs_procfile_read;
+	proc_file->write_proc = axfs_procfile_write;
+	proc_file->owner = THIS_MODULE;
+	proc_file->mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
+	proc_file->uid = 0;
+	proc_file->gid = 0;
+	proc_file->data = manager;
+
+	printk(KERN_DEBUG "axfs: Proc entry created\n");
+
+out:
+	return rv;
+}
+
+/******************************************************************************
+ *
+ * axfs_unregister_profiling_proc
+ *
+ * Description:
+ *   Will unregister the instance of the proc file for the volume that was
+ *   mounted.  If this is the last volume mounted then the proc directory
+ *   will also be removed.
+ *
+ * Parameters:
+ *    (IN) sbi- axfs superblock pointer to determine which proc file to remove
+ *
+ * Returns:
+ *    The profiling manager pointer for the proc file.
+ *
+ *****************************************************************************/
+static struct axfs_profiling_manager *axfs_unregister_profiling_proc(struct
+								     axfs_super
+								     *sbi)
+{
+	struct axfs_profiling_manager *manager;
+	manager = axfs_delete_proc_file(sbi);
+	axfs_delete_proc_directory();
+	return manager;
+}
+
+/******************************************************************************
+ *
+ * axfs_init_profiling
+ *
+ * Description:
+ *   Creates the structures for tracking the page usage data and creates the
+ *   proc file that will be used to get the data.
+ *
+ * Parameters:
+ *    (IN) sbi- axfs superblock pointer
+ *
+ * Returns:
+ *    TRUE or FALSE
+ *
+ *****************************************************************************/
+int axfs_init_profiling(struct axfs_super *sbi)
+{
+
+	u32 num_nodes, num_inodes;
+	struct axfs_profiling_manager *manager = NULL;
+	struct axfs_profiling_data *profile_data = NULL;
+	int err = -ENOMEM;
+
+	/* determine the max number of pages in the FS */
+	num_nodes = sbi->blocks;
+	if (!num_nodes)
+		return 0;
+
+	manager = vmalloc(sizeof(*manager));
+	if (!manager)
+		goto out;
+
+	profile_data = vmalloc(num_nodes * sizeof(*profile_data));
+	if (!profile_data)
+		goto out;
+
+	memset(profile_data, 0, num_nodes * sizeof(*profile_data));
+
+	/* determine the max number of inodes in the FS */
+	num_inodes = sbi->files;
+
+	manager->dir_structure = vmalloc(num_inodes * sizeof(u32 *));
+	if (!manager->dir_structure)
+		goto out;
+
+	memset(manager->dir_structure, 0, (num_inodes * sizeof(u32 *)));
+
+	manager->profiling_data = profile_data;
+	manager->size = num_nodes * sizeof(*profile_data);
+	manager->sbi = sbi;
+	sbi->profiling_on = TRUE;	/* Turn on profiling by default */
+	sbi->profile_data_ptr = profile_data;
+
+	err = axfs_init_profile_dir_structure(manager, num_inodes);
+	if (err)
+		goto out;
+
+	err = axfs_register_profiling_proc(manager);
+	if (err)
+		goto out;
+
+	return 0;
+
+out:
+	if (manager->dir_structure)
+		vfree(manager->dir_structure);
+	if (profile_data)
+		vfree(profile_data);
+	if (manager)
+		vfree(manager);
+	return err;
+}
+
+/******************************************************************************
+ *
+ * axfs_shutdown_profiling
+ *
+ * Description:
+ *   Remove the proc file for this volume and release the memory in the
+ *   profiling manager
+ *
+ * Parameters:
+ *    (IN) sbi- axfs superblock pointer
+ *
+ * Returns:
+ *    TRUE or FALSE
+ *
+ *****************************************************************************/
+int axfs_shutdown_profiling(struct axfs_super *sbi)
+{
+	struct axfs_profiling_manager *manager;
+	/* remove the proc file for this volume and release the memory in the
+	   profiling manager */
+
+	if (!sbi)
+		return TRUE;
+
+	if (!sbi->profile_data_ptr)
+		return TRUE;
+
+	manager = axfs_unregister_profiling_proc(sbi);
+
+	if (manager == NULL)
+		return FALSE;
+
+	if (manager->dir_structure)
+		vfree(manager->dir_structure);
+	if (manager->profiling_data)
+		vfree(manager->profiling_data);
+	if (manager)
+		vfree(manager);
+	return TRUE;
+}
+
+/******************************************************************************
+ *
+ * axfs_profiling_add
+ *
+ * Description:
+ *    Log when a node is paged into memory by incrementing the count in the
+ *    array profile data structure.
+ *
+ * Parameters:
+ *    (IN) sbi- axfs superblock pointer
+ *
+ *    (IN) array_index - The offset into the nodes table of file (node number)
+ *
+ *    (IN) axfs_inode_number - Inode of the node to determine file name later
+ *
+ * Returns:
+ *    none
+ *
+ *****************************************************************************/
+void axfs_profiling_add(struct axfs_super *sbi, unsigned long array_index,
+			unsigned int axfs_inode_number)
+{
+	unsigned long addr;
+	struct axfs_profiling_data *profile_data;
+
+	if (sbi->profiling_on != TRUE)
+		return;
+
+	addr = (unsigned long)sbi->profile_data_ptr;
+	addr += array_index * sizeof(*profile_data);
+
+	profile_data = (struct axfs_profiling_data *)addr;
+
+	/* Record the inode number to determine the file name later. */
+	profile_data->inode_number = axfs_inode_number;
+
+	/* Increment the number of times the node has been paged in */
+	profile_data->count++;
+}
+
+#else
+
+int axfs_init_profiling(struct axfs_super *sbi)
+{
+	return 0;
+}
+
+int axfs_shutdown_profiling(struct axfs_super *sbi)
+{
+	return 0;
+}
+
+void axfs_profiling_add(struct axfs_super *sbi, unsigned long array_index,
+			unsigned int axfs_inode_number)
+{
+}
+
+#endif /* CONFIG_AXFS_PROFILING */
diff --git a/fs/axfs/axfs_super.c b/fs/axfs/axfs_super.c
new file mode 100644
index 0000000..5269589
--- /dev/null
+++ b/fs/axfs/axfs_super.c
@@ -0,0 +1,928 @@
+/*
+ * Advanced XIP File System for Linux - AXFS
+ *   Readonly, compressed, and XIP filesystem for Linux systems big and small
+ *
+ * Copyright(c) 2008 Numonyx
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * Authors:
+ *  Eric Anderson
+ *  Jared Hulbert <jaredeh@gmail.com>
+ *  Sujaya Srinivasan
+ *  Justin Treon
+ *
+ * More info and current contacts at http://axfs.sourceforge.net
+ *
+ * axfs_super.c -
+ *   Contains the core code used to mount the fs.
+ *
+ */
+
+#include <linux/axfs.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/parser.h>
+#include <linux/statfs.h>
+#include <linux/module.h>
+#include <linux/mount.h>
+#include <linux/mtd/mtd.h>
+
+/******************** Function Declarations ****************************/
+static struct super_operations axfs_sops;
+static struct axfs_super *axfs_get_sbi(void);
+static void axfs_put_sbi(struct axfs_super *);
+/***************** functions in other axfs files ***************************/
+int axfs_get_sb_bdev(struct file_system_type *, int, const char *,
+		     struct axfs_super *, struct vfsmount *, int *);
+void axfs_kill_block_super(struct super_block *);
+int axfs_copy_block(struct super_block *, void *, u64, u64);
+int axfs_is_dev_bdev(char *);
+#ifndef NO_PHYSMEM
+void axfs_map_physmem(struct axfs_super *, unsigned long);
+void axfs_unmap_physmem(struct super_block *);
+#endif
+int axfs_map_mtd(struct super_block *);
+void axfs_unmap_mtd(struct super_block *);
+int axfs_copy_mtd(struct super_block *, void *, u64, u64);
+int axfs_get_sb_mtd(struct file_system_type *, int, const char *,
+		    struct axfs_super *, struct vfsmount *, int *);
+int axfs_is_dev_mtd(char *, int *);
+void axfs_kill_mtd_super(struct super_block *);
+struct inode *axfs_create_vfs_inode(struct super_block *, int);
+int axfs_get_uml_address(char *, unsigned long *, unsigned long *);
+int axfs_init_profiling(struct axfs_super *);
+int axfs_shutdown_profiling(struct axfs_super *);
+void axfs_profiling_add(struct axfs_super *, unsigned long, unsigned int);
+struct inode *axfs_create_vfs_inode(struct super_block *, int);
+/******************************************************************************/
+
+static void axfs_free_region(struct axfs_super *sbi,
+			     struct axfs_region_desc *region)
+{
+	if (!region)
+		return;
+
+	if (AXFS_IS_REGION_XIP(sbi, region))
+		return;
+
+	if (region->virt_addr)
+		vfree(region->virt_addr);
+}
+
+static void axfs_put_sbi(struct axfs_super *sbi)
+{
+	if (!sbi)
+		return;
+
+	axfs_shutdown_profiling(sbi);
+
+	axfs_free_region(sbi, &sbi->strings);
+	axfs_free_region(sbi, &sbi->xip);
+	axfs_free_region(sbi, &sbi->compressed);
+	axfs_free_region(sbi, &sbi->byte_aligned);
+	axfs_free_region(sbi, &sbi->node_type);
+	axfs_free_region(sbi, &sbi->node_index);
+	axfs_free_region(sbi, &sbi->cnode_offset);
+	axfs_free_region(sbi, &sbi->cnode_index);
+	axfs_free_region(sbi, &sbi->banode_offset);
+	axfs_free_region(sbi, &sbi->cblock_offset);
+	axfs_free_region(sbi, &sbi->inode_file_size);
+	axfs_free_region(sbi, &sbi->inode_name_offset);
+	axfs_free_region(sbi, &sbi->inode_num_entries);
+	axfs_free_region(sbi, &sbi->inode_mode_index);
+	axfs_free_region(sbi, &sbi->inode_array_index);
+	axfs_free_region(sbi, &sbi->modes);
+	axfs_free_region(sbi, &sbi->uids);
+	axfs_free_region(sbi, &sbi->gids);
+
+	if (sbi->second_dev)
+		kfree(sbi->second_dev);
+
+	if (sbi->cblock_buffer[0])
+		vfree(sbi->cblock_buffer[0]);
+	if (sbi->cblock_buffer[1])
+		vfree(sbi->cblock_buffer[1]);
+
+	kfree(sbi);
+}
+
+static void axfs_put_super(struct super_block *sb)
+{
+	axfs_unmap_mtd(sb);
+#ifndef NO_PHYSMEM
+	axfs_unmap_physmem(sb);
+#endif
+	axfs_put_sbi(AXFS_SB(sb));
+	sb->s_fs_info = NULL;
+}
+
+static int axfs_copy_mem(struct super_block *sb, void *buf, u64 fsoffset,
+			 u64 len)
+{
+	struct axfs_super *sbi = AXFS_SB(sb);
+	unsigned long addr;
+
+	addr = sbi->virt_start_addr + (unsigned long)fsoffset;
+	memcpy(buf, (void *)addr, (size_t) len);
+	return 0;
+}
+
+static int axfs_copy_metadata(struct super_block *sb, void *buf, u64 fsoffset,
+			      u64 len)
+{
+	struct axfs_super *sbi = AXFS_SB(sb);
+	u64 end = fsoffset + len;
+	u64 a = sbi->mmap_size - fsoffset;
+	u64 b = end - sbi->mmap_size;
+	void *bb = (void *)((unsigned long)buf + (unsigned long)a);
+	int err;
+
+	/* Catches case where sbi is not yet fully initialized. */
+	if ((sbi->magic == 0) && (sbi->virt_start_addr != 0))
+		return axfs_copy_mem(sb, buf, fsoffset, len);
+
+	if (fsoffset < sbi->mmap_size) {
+		if (end > sbi->mmap_size) {
+			err = axfs_copy_metadata(sb, buf, fsoffset, a);
+			if (err)
+				return err;
+			err = axfs_copy_metadata(sb, bb, sbi->mmap_size, b);
+		} else {
+			if (AXFS_IS_OFFSET_MMAPABLE(sbi, fsoffset)) {
+				err = axfs_copy_mem(sb, buf, fsoffset, len);
+			} else if (AXFS_HAS_MTD(sb)) {
+				err = axfs_copy_mtd(sb, buf, fsoffset, len);
+			} else if (AXFS_HAS_BDEV(sb)) {
+				err = axfs_copy_block(sb, buf, fsoffset, len);
+			} else {
+				err = -EINVAL;
+			}
+		}
+	} else {
+		if (AXFS_NODEV(sb)) {
+			err = axfs_copy_mem(sb, buf, fsoffset, len);
+		} else if (AXFS_HAS_BDEV(sb)) {
+			err = axfs_copy_block(sb, buf, fsoffset, len);
+		} else if (AXFS_HAS_MTD(sb)) {
+			err = axfs_copy_mtd(sb, buf, fsoffset, len);
+		} else {
+			err = -EINVAL;
+		}
+	}
+	return err;
+}
+
+static int axfs_fill_region_data(struct super_block *sb,
+				 struct axfs_region_desc *region, int force)
+{
+	struct axfs_super *sbi = AXFS_SB(sb);
+	unsigned long addr;
+	void *buff = NULL;
+	void *vaddr;
+	int err = -ENOMEM;
+	u64 size = region->size;
+	u64 fsoffset = region->fsoffset;
+	u64 end = fsoffset + size;
+	u64 c_size = region->compressed_size;
+
+	if (size == 0)
+		return 0;
+
+	if (AXFS_IS_REGION_INCORE(region))
+		goto incore;
+
+	if (AXFS_IS_REGION_COMPRESSED(region))
+		goto incore;
+
+	if (AXFS_IS_REGION_XIP(sbi, region)) {
+		if ((end > sbi->mmap_size) && (force))
+			goto incore;
+		addr = sbi->virt_start_addr;
+		addr += (unsigned long)fsoffset;
+		region->virt_addr = (void *)addr;
+		return 0;
+	}
+
+	if (force)
+		goto incore;
+
+	region->virt_addr = NULL;
+	return 0;
+
+incore:
+	region->virt_addr = vmalloc(size);
+	if (!region->virt_addr)
+		goto out;
+	vaddr = region->virt_addr;
+
+	if (AXFS_IS_REGION_COMPRESSED(region)) {
+		buff = vmalloc(c_size);
+		if (!buff)
+			goto out;
+		axfs_copy_metadata(sb, buff, fsoffset, c_size);
+		err = axfs_uncompress_block(vaddr, size, buff, c_size);
+		if (!err)
+			goto out;
+		vfree(buff);
+	} else {
+		axfs_copy_metadata(sb, vaddr, fsoffset, size);
+	}
+
+	return 0;
+
+out:
+	if (buff)
+		vfree(buff);
+	if (region->virt_addr)
+		vfree(region->virt_addr);
+	return err;
+}
+
+static int axfs_fill_region_data_ptrs(struct super_block *sb)
+{
+	int err;
+	struct axfs_super *sbi = AXFS_SB(sb);
+
+	err = axfs_fill_region_data(sb, &sbi->strings, TRUE);
+	if (err)
+		goto out;
+
+	err = axfs_fill_region_data(sb, &sbi->xip, TRUE);
+	if (err)
+		goto out;
+
+	err = axfs_fill_region_data(sb, &sbi->compressed, FALSE);
+	if (err)
+		goto out;
+
+	err = axfs_fill_region_data(sb, &sbi->byte_aligned, FALSE);
+	if (err)
+		goto out;
+
+	err = axfs_fill_region_data(sb, &sbi->node_type, TRUE);
+	if (err)
+		goto out;
+	err = axfs_fill_region_data(sb, &sbi->node_index, TRUE);
+	if (err)
+		goto out;
+	err = axfs_fill_region_data(sb, &sbi->cnode_offset, TRUE);
+	if (err)
+		goto out;
+	err = axfs_fill_region_data(sb, &sbi->cnode_index, TRUE);
+	if (err)
+		goto out;
+	err = axfs_fill_region_data(sb, &sbi->banode_offset, TRUE);
+	if (err)
+		goto out;
+	err = axfs_fill_region_data(sb, &sbi->cblock_offset, TRUE);
+	if (err)
+		goto out;
+	err = axfs_fill_region_data(sb, &sbi->inode_file_size, TRUE);
+	if (err)
+		goto out;
+	err = axfs_fill_region_data(sb, &sbi->inode_name_offset, TRUE);
+	if (err)
+		goto out;
+	err = axfs_fill_region_data(sb, &sbi->inode_num_entries, TRUE);
+	if (err)
+		goto out;
+	err = axfs_fill_region_data(sb, &sbi->inode_mode_index, TRUE);
+	if (err)
+		goto out;
+	err = axfs_fill_region_data(sb, &sbi->inode_array_index, TRUE);
+	if (err)
+		goto out;
+	err = axfs_fill_region_data(sb, &sbi->modes, TRUE);
+	if (err)
+		goto out;
+	err = axfs_fill_region_data(sb, &sbi->uids, TRUE);
+	if (err)
+		goto out;
+	err = axfs_fill_region_data(sb, &sbi->gids, TRUE);
+	if (err)
+		goto out;
+
+out:
+	return err;
+}
+
+static int axfs_init_cblock_buffers(struct axfs_super *sbi)
+{
+	sbi->current_cnode_index = -1;
+	sbi->cblock_buffer[0] = vmalloc(sbi->cblock_size);
+	sbi->cblock_buffer[1] = vmalloc(sbi->cblock_size);
+	if ((!sbi->cblock_buffer[0]) || (!sbi->cblock_buffer[1]))
+		return -ENOMEM;
+
+	return 0;
+}
+
+static int axfs_fixup_devices(struct super_block *sb)
+{
+	struct axfs_super *sbi = AXFS_SB(sb);
+	int err = 0;
+
+#ifndef NO_PHYSMEM
+	if (AXFS_IS_PHYSMEM(sbi)) {
+		axfs_map_physmem(sbi, sbi->mmap_size);
+	} else if (AXFS_HAS_MTD(sb)) {
+#else
+	if (AXFS_HAS_MTD(sb)) {
+#endif
+		err = axfs_map_mtd(sb);
+	} else if (AXFS_IS_IOMEM(sbi)) {
+		sbi->phys_start_addr = 0;
+	}
+	return err;
+}
+
+static void axfs_fill_region_desc(struct super_block *sb,
+				  struct axfs_region_desc_onmedia *out,
+				  u64 offset_be, struct axfs_region_desc *in)
+{
+	u64 offset = be64_to_cpu(offset_be);
+
+	axfs_copy_metadata(sb, (void *)out, offset, sizeof(*out));
+
+	in->fsoffset = be64_to_cpu(out->fsoffset);
+	in->size = be64_to_cpu(out->size);
+	in->compressed_size = be64_to_cpu(out->compressed_size);
+	in->max_index = be64_to_cpu(out->max_index);
+	in->table_byte_depth = out->table_byte_depth;
+	in->incore = out->incore;
+}
+
+static int axfs_fill_region_descriptors(struct super_block *sb,
+					struct axfs_super_onmedia *sbo)
+{
+	struct axfs_super *sbi = AXFS_SB(sb);
+	struct axfs_region_desc_onmedia *out;
+
+	out = kmalloc(sizeof(*out), GFP_KERNEL);
+	if (!out)
+		return -ENOMEM;
+	memset(out, 0, sizeof(*out));
+
+	axfs_fill_region_desc(sb, out, sbo->strings, &sbi->strings);
+	axfs_fill_region_desc(sb, out, sbo->xip, &sbi->xip);
+	axfs_fill_region_desc(sb, out, sbo->compressed, &sbi->compressed);
+	axfs_fill_region_desc(sb, out, sbo->byte_aligned, &sbi->byte_aligned);
+	axfs_fill_region_desc(sb, out, sbo->node_type, &sbi->node_type);
+	axfs_fill_region_desc(sb, out, sbo->node_index, &sbi->node_index);
+	axfs_fill_region_desc(sb, out, sbo->cnode_offset, &sbi->cnode_offset);
+	axfs_fill_region_desc(sb, out, sbo->cnode_index, &sbi->cnode_index);
+	axfs_fill_region_desc(sb, out, sbo->banode_offset, &sbi->banode_offset);
+	axfs_fill_region_desc(sb, out, sbo->cblock_offset, &sbi->cblock_offset);
+	axfs_fill_region_desc(sb, out, sbo->inode_file_size,
+			      &sbi->inode_file_size);
+	axfs_fill_region_desc(sb, out, sbo->inode_name_offset,
+			      &sbi->inode_name_offset);
+	axfs_fill_region_desc(sb, out, sbo->inode_num_entries,
+			      &sbi->inode_num_entries);
+	axfs_fill_region_desc(sb, out, sbo->inode_mode_index,
+			      &sbi->inode_mode_index);
+	axfs_fill_region_desc(sb, out, sbo->inode_array_index,
+			      &sbi->inode_array_index);
+	axfs_fill_region_desc(sb, out, sbo->modes, &sbi->modes);
+	axfs_fill_region_desc(sb, out, sbo->uids, &sbi->uids);
+	axfs_fill_region_desc(sb, out, sbo->gids, &sbi->gids);
+
+	kfree(out);
+
+	return 0;
+}
+
+int axfs_set_compression_type(struct axfs_super *sbi)
+{
+	if (sbi->compression_type != ZLIB)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int axfs_get_onmedia_super(struct super_block *sb)
+{
+	int err;
+	struct axfs_super *sbi = AXFS_SB(sb);
+	struct axfs_super_onmedia *sbo;
+
+	sbo = kmalloc(sizeof(*sbo), GFP_KERNEL);
+	if (!sbo)
+		return -ENOMEM;
+
+#ifndef NO_PHYSMEM
+	axfs_map_physmem(sbi, sizeof(*sbo));
+#endif
+	axfs_copy_metadata(sb, (void *)sbo, 0, sizeof(*sbo));
+
+	/* Do sanity checks on the superblock */
+	if (be32_to_cpu(sbo->magic) != AXFS_MAGIC) {
+		printk(KERN_ERR "axfs: wrong magic\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	/* verify the signiture is correct */
+	if (strncmp(sbo->signature, AXFS_SIGNATURE, sizeof(AXFS_SIGNATURE))) {
+		printk(KERN_ERR "axfs: wrong axfs signature,"
+		       " read %s, expected %s\n",
+		       sbo->signature, AXFS_SIGNATURE);
+		err = -EINVAL;
+		goto out;
+	}
+
+	sbi->magic = be32_to_cpu(sbo->magic);
+	sbi->version_major = sbo->version_major;
+	sbi->version_minor = sbo->version_minor;
+	sbi->version_sub = sbo->version_sub;
+	sbi->files = be64_to_cpu(sbo->files);
+	sbi->size = be64_to_cpu(sbo->size);
+	sbi->blocks = be64_to_cpu(sbo->blocks);
+	sbi->mmap_size = be64_to_cpu(sbo->mmap_size);
+	sbi->cblock_size = be32_to_cpu(sbo->cblock_size);
+	sbi->timestamp.tv_sec = be64_to_cpu(sbo->timestamp);
+	sbi->timestamp.tv_nsec = 0;
+	sbi->compression_type = sbo->compression_type;
+
+	err = axfs_set_compression_type(sbi);
+	if (err)
+		goto out;
+
+	/* If no block or MTD device, adjust mmapable to cover all image */
+	if (AXFS_NODEV(sb))
+		sbi->mmap_size = sbi->size;
+
+	err = axfs_fill_region_descriptors(sb, sbo);
+	if (err)
+		goto out;
+
+	err = 0;
+out:
+	kfree(sbo);
+#ifndef NO_PHYSMEM
+	axfs_unmap_physmem(sb);
+#endif
+	return err;
+}
+
+/* Verify that the size of the block segment of a split filesystem
+   is less than or equal to that of the device containing it.
+   Validation of the size of an mmap segment vs. the device containing
+   it is handled by the point() function in axfs_map_mtd.
+*/
+int axfs_verify_device_sizes(struct super_block *sb)
+{
+	struct axfs_super *sbi = AXFS_SB(sb);
+	struct mtd_info *mtd0 = AXFS_MTD(sb);
+	struct mtd_info *mtd1 = AXFS_MTD1(sb);
+	int sndsize = sbi->size - sbi->mmap_size;
+
+	/* Whole FS on one device */
+	if (mtd0 && !mtd1 && (mtd0->size < sbi->size)) {
+		printk(KERN_ERR "axfs: ERROR: Filesystem extends beyond end of"
+		       "MTD! Filesystem cannot be safely mounted!\n");
+		printk(KERN_ERR "mtd name: %s, mtd size: 0x%x,"
+		       " fs size: 0x%llx\n", mtd0->name, mtd0->size, sbi->size);
+		return -EINVAL;
+	}
+
+	/* Split filesystem using physaddr */
+	if (sndsize && !mtd0 && mtd1 && (mtd1->size < sndsize)) {
+		printk(KERN_ERR "axfs: ERROR: The specified second_dev device "
+		       "is smaller than the store and download segment!\n");
+		printk(KERN_ERR "mtd name: %s, mtd size: 0x%x, "
+		       "snd size: 0x%x\n", mtd1->name, mtd1->size, sndsize);
+		return -EINVAL;
+	}
+
+	/* Split filesystem using two devices */
+	if (sndsize && mtd0 && mtd1) {
+		if (mtd0->size < sbi->mmap_size) {
+			printk(KERN_ERR "axfs: ERROR: Mmap segment extends"
+			       " beyond end of MTD!");
+			printk(KERN_ERR "mtd name: %s, mtd size: 0x%x, mmap "
+			       "size: 0x%llx",
+			       mtd0->name, mtd0->size, sbi->mmap_size);
+			return -EINVAL;
+		}
+		if (mtd1->size < sndsize) {
+			printk(KERN_ERR "axfs: ERROR: The specified second_dev "
+			       "device is smaller than the store and download "
+			       "segment!\n");
+			printk(KERN_ERR "mtd name: %s, mtd size: 0x%x, "
+			       "snd size: 0x%x\n",
+			       mtd1->name, mtd1->size, sndsize);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+/* Read the last four bytes of the volume and make sure the AXFS magic is
+   present. */
+int axfs_verify_eofs_magic(struct super_block *sb)
+{
+	struct axfs_super *sbi = AXFS_SB(sb);
+	u32 buf = 0;
+	int err;
+	u32 fsoffset = sbi->size - sizeof(u32);
+	int len = sizeof(u32);
+
+	err = axfs_copy_metadata(sb, &buf, fsoffset, len);
+
+	if (err)
+		return -EINVAL;
+
+	if (be32_to_cpu(buf) != AXFS_MAGIC) {
+		printk(KERN_ERR "READ: 0x%x\n", be32_to_cpu(buf));
+		printk(KERN_ERR "ERROR: Filesystem is incomplete and cannot be "
+		       "mounted!\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int axfs_do_fill_super(struct super_block *sb)
+{
+	struct axfs_super *sbi = AXFS_SB(sb);
+	int err;
+
+	err = axfs_get_onmedia_super(sb);
+	if (err)
+		goto out;
+
+	err = axfs_fixup_devices(sb);
+	if (err)
+		goto out;
+
+	err = axfs_verify_device_sizes(sb);
+	if (err)
+		goto out;
+
+	err = axfs_verify_eofs_magic(sb);
+	if (err)
+		goto out;
+
+	err = axfs_fill_region_data_ptrs(sb);
+	if (err)
+		goto out;
+
+	/* Check that the root inode is in a sane state */
+	if (!S_ISDIR(AXFS_GET_MODE(sbi, 0))) {
+		printk(KERN_ERR "axfs: root is not a directory\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	if (AXFS_GET_INODE_NUM_ENTRIES(sbi, 0) == 0) {
+		printk(KERN_INFO "axfs: empty filesystem");
+		err = -EINVAL;
+		goto out;
+	}
+
+	err = axfs_init_cblock_buffers(sbi);
+	if (err)
+		goto out;
+
+	init_rwsem(&sbi->lock);
+
+	return 0;
+
+out:
+	axfs_put_super(sb);
+	return err;
+}
+
+int axfs_fill_super(struct super_block *sb, void *data, int silent)
+{
+	struct axfs_super *sbi_in = (struct axfs_super *)data;
+	struct axfs_super *sbi;
+	struct inode *root;
+	int err;
+
+	sbi = axfs_get_sbi();
+	sb->s_fs_info = (void *)sbi;
+	memcpy(sbi, sbi_in, sizeof(*sbi));
+
+	/* fully populate the incore superblock structures */
+	err = axfs_do_fill_super(sb);
+	if (err)
+		goto out;
+
+	sb->s_flags |= MS_RDONLY;
+
+	/* Setup the VFS super block now */
+	sb->s_op = &axfs_sops;
+	root = axfs_create_vfs_inode(sb, 0);
+	if (!root) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	sb->s_root = d_alloc_root(root);
+	if (!sb->s_root) {
+		iput(root);
+		err = -EINVAL;
+		goto out;
+	}
+
+	err = axfs_init_profiling(sbi);
+	if (err)
+		goto out;
+
+	return 0;
+
+out:
+	axfs_put_super(sb);
+	return err;
+}
+
+static int axfs_get_sb_address(struct file_system_type *fs_type, int flags,
+			       struct axfs_super *sbi, struct vfsmount *mnt,
+			       int *err)
+{
+	int mtdnr;
+	char *sd = sbi->second_dev;
+
+	if (sbi->phys_start_addr == 0)
+		return FALSE;
+
+	if (sbi->phys_start_addr & (PAGE_SIZE - 1)) {
+		printk(KERN_ERR
+		       "axfs: address 0x%lx for axfs image isn't aligned"
+		       " to a page boundary\n", sbi->phys_start_addr);
+		*err = -EINVAL;
+		return TRUE;
+	}
+
+	if (axfs_is_dev_mtd(sd, &mtdnr)) {
+		return axfs_get_sb_mtd(fs_type, flags, sd, sbi, mnt, err);
+	} else if (axfs_is_dev_bdev(sd)) {
+		return axfs_get_sb_bdev(fs_type, flags, sd, sbi, mnt, err);
+	} else {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
+		*err = get_sb_nodev(fs_type, flags, sbi, axfs_fill_super, mnt);
+#else
+		mnt->mnt_sb =
+		    get_sb_nodev(fs_type, flags, (void *)sbi, axfs_fill_super);
+#endif
+	}
+
+	return TRUE;
+}
+
+/* helpers for parse_axfs_options */
+enum {
+	OPTION_ERR,
+	OPTION_SECOND_DEV,
+	OPTION_PHYSICAL_ADDRESS_LOWER_X,
+	OPTION_PHYSICAL_ADDRESS_UPPER_X,
+	OPTION_IOMEM
+};
+
+/* helpers for parse_axfs_options */
+static match_table_t tokens = {
+	{OPTION_SECOND_DEV, "second_dev=%s"},
+	{OPTION_PHYSICAL_ADDRESS_LOWER_X, "physaddr=0x%s"},
+	{OPTION_PHYSICAL_ADDRESS_UPPER_X, "physaddr=0X%s"},
+	{OPTION_IOMEM, "iomem=%s"},
+	{OPTION_ERR, NULL}
+};
+
+static int axfs_check_options(char *options, struct axfs_super *sbi)
+{
+	unsigned long address = 0;
+	char *iomem = NULL;
+	unsigned long length = 0;
+	char *p;
+	int err = -EINVAL;
+	substring_t args[MAX_OPT_ARGS];
+
+	if (!options)
+		return 0;
+
+	if (!*options)
+		return 0;
+
+	while ((p = strsep(&options, ",")) != NULL) {
+		int token;
+		if (!*p)
+			continue;
+
+		token = match_token(p, tokens, args);
+		switch (token) {
+		case OPTION_SECOND_DEV:
+			sbi->second_dev = match_strdup(&args[0]);
+			if (!(sbi->second_dev)) {
+				err = -ENOMEM;
+				goto out;
+			}
+			if (!*(sbi->second_dev))
+				goto bad_value;
+			break;
+		case OPTION_IOMEM:
+			iomem = match_strdup(&args[0]);
+			if (!(iomem)) {
+				err = -ENOMEM;
+				goto out;
+			}
+			if (!*iomem)
+				goto bad_value;
+			break;
+		case OPTION_PHYSICAL_ADDRESS_LOWER_X:
+		case OPTION_PHYSICAL_ADDRESS_UPPER_X:
+			if (match_hex(&args[0], (int *)&address))
+				goto out;
+			if (!address)
+				goto bad_value;
+			break;
+		default:
+			printk(KERN_ERR
+			       "axfs: unrecognized mount option \"%s\" "
+			       "or missing value\n", p);
+			goto out;
+		}
+	}
+
+	if (iomem) {
+		if (address)
+			goto out;
+		err = axfs_get_uml_address(iomem, &address, &length);
+		kfree(iomem);
+		sbi->iomem_size = length;
+		sbi->virt_start_addr = address;
+	}
+
+	sbi->phys_start_addr = address;
+	return 0;
+
+bad_value:
+	printk(KERN_ERR
+	       "axfs: unrecognized mount option \"%s\" "
+	       "or missing value\n", p);
+out:
+	if (iomem)
+		kfree(iomem);
+	return err;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17)
+int axfs_get_sb(struct file_system_type *fs_type, int flags,
+		const char *dev_name, void *data, struct vfsmount *mnt)
+#else
+struct super_block *axfs_get_sb(struct file_system_type *fs_type, int flags,
+				const char *dev_name, void *data)
+#endif
+{
+	struct axfs_super *sbi;
+	int err;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17)
+#else
+	struct super_block *sb;
+	struct vfsmount *mnt;
+	mnt = kmalloc(sizeof(*mnt), GFP_KERNEL);
+	memset(mnt, 0, sizeof(*mnt));
+#endif
+
+	sbi = axfs_get_sbi();
+	if (IS_ERR(sbi))
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17)
+		return PTR_ERR(sbi);
+#else
+		return (struct super_block *)sbi;
+#endif
+
+	err = axfs_check_options((char *)data, sbi);
+	if (err)
+		goto out;
+
+	/* First we check if we are mounting directly to memory */
+	if (axfs_get_sb_address(fs_type, flags, sbi, mnt, &err))
+		goto out;
+
+	/* Next we assume there's a MTD device */
+	if (axfs_get_sb_mtd(fs_type, flags, dev_name, sbi, mnt, &err))
+		goto out;
+
+	/* Now we assume it's a block device */
+	if (sbi->second_dev) {
+		printk(KERN_ERR
+		       "axfs: can't specify secondary block device %s because"
+		       " %s is assumed to be a block device\n", sbi->second_dev,
+		       dev_name);
+		err = -EINVAL;
+		goto out;
+	}
+
+	if (axfs_get_sb_bdev(fs_type, flags, dev_name, sbi, mnt, &err))
+		goto out;
+
+	err = -EINVAL;
+
+out:
+	axfs_put_sbi(sbi);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17)
+	return err;
+#else
+	if (err)
+		return ERR_PTR(err);
+
+	sb = mnt->mnt_sb;
+	kfree(mnt);
+	return sb;
+#endif
+}
+
+static struct axfs_super *axfs_get_sbi(void)
+{
+	struct axfs_super *sbi;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
+	sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);
+#else
+	sbi = kmalloc(sizeof(*sbi), GFP_KERNEL);
+	memset(sbi, 0, sizeof(*sbi));
+#endif
+	if (sbi)
+		return sbi;
+
+	axfs_put_sbi(sbi);
+	return ERR_PTR(-ENOMEM);
+}
+
+static void axfs_kill_super(struct super_block *sb)
+{
+	if (AXFS_NODEV(sb))
+		return kill_anon_super(sb);
+
+	if (AXFS_HAS_MTD(sb))
+		axfs_kill_mtd_super(sb);
+
+	if (AXFS_HAS_BDEV(sb))
+		axfs_kill_block_super(sb);
+}
+
+static int axfs_remount(struct super_block *sb, int *flags, char *data)
+{
+	*flags |= MS_RDONLY;
+	return 0;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17)
+static int axfs_statfs(struct dentry *dentry, struct kstatfs *buf)
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+static int axfs_statfs(struct super_block *sb, struct kstatfs *buf)
+#else
+static int axfs_statfs(struct super_block *sb, struct statfs *buf)
+#endif
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17)
+	struct axfs_super *sbi = AXFS_SB(dentry->d_sb);
+#else
+	struct axfs_super *sbi = AXFS_SB(sb);
+#endif
+
+	buf->f_type = AXFS_MAGIC;
+	buf->f_bsize = AXFS_PAGE_SIZE;
+	buf->f_blocks = sbi->blocks;
+	buf->f_bfree = 0;
+	buf->f_bavail = 0;
+	buf->f_files = sbi->files;
+	buf->f_ffree = 0;
+	buf->f_namelen = AXFS_MAXPATHLEN;
+	return 0;
+}
+
+static struct super_operations axfs_sops = {
+	.put_super = axfs_put_super,
+	.remount_fs = axfs_remount,
+	.statfs = axfs_statfs,
+};
+
+static struct file_system_type axfs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "axfs",
+	.get_sb = axfs_get_sb,
+	.kill_sb = axfs_kill_super,
+};
+
+static int __init init_axfs_fs(void)
+{
+	axfs_uncompress_init();
+	return register_filesystem(&axfs_fs_type);
+}
+
+static void __exit exit_axfs_fs(void)
+{
+	axfs_uncompress_exit();
+	unregister_filesystem(&axfs_fs_type);
+}
+
+module_init(init_axfs_fs);
+module_exit(exit_axfs_fs);
+MODULE_LICENSE("GPL");
diff --git a/fs/axfs/axfs_uml.c b/fs/axfs/axfs_uml.c
new file mode 100644
index 0000000..7d479a0
--- /dev/null
+++ b/fs/axfs/axfs_uml.c
@@ -0,0 +1,47 @@
+/*
+ * Advanced XIP File System for Linux - AXFS
+ *   Readonly, compressed, and XIP filesystem for Linux systems big and small
+ *
+ * Copyright(c) 2008 Numonyx
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * Authors:
+ *  Jared Hulbert <jaredeh@gmail.com>
+ *
+ * Project url: http://axfs.sourceforge.net
+ *
+ * axfs_uml.c -
+ *   Allows axfs to a UML kernels find_iomem() interface as an XIP device or
+ *   dummy functions if this is not a UML build.
+ */
+
+#include <linux/axfs.h>
+#ifdef CONFIG_UML
+#include <mem_user.h>
+int axfs_get_uml_address(char *iomem, unsigned long *address,
+			 unsigned long *length)
+{
+	*address = find_iomem(iomem, length);
+	if (!(*address)) {
+		printk(KERN_DEBUG "axfs: find_iomem() failed\n");
+		return -EINVAL;
+	}
+
+	if (*length < PAGE_SIZE) {
+		printk(KERN_DEBUG
+		       "axfs: iomem() too small, must be at least %li Bytes\n",
+		       PAGE_SIZE);
+		return -EINVAL;
+	}
+	return 0;
+}
+#else
+int axfs_get_uml_address(char *iomem, unsigned long *address,
+			 unsigned long *length)
+{
+	return 0;
+}
+#endif /* CONFIG_UML */
diff --git a/fs/axfs/axfs_uncompress.c b/fs/axfs/axfs_uncompress.c
new file mode 100644
index 0000000..36c2b76
--- /dev/null
+++ b/fs/axfs/axfs_uncompress.c
@@ -0,0 +1,124 @@
+/*
+ * Advanced XIP File System for Linux - AXFS
+ *   Readonly, compressed, and XIP filesystem for Linux systems big and small
+ *
+ *   Modified in 2006 by Eric Anderson
+ *     from the cramfs sources fs/cramfs/uncompress.c
+ *
+ * (C) Copyright 1999 Linus Torvalds
+ *
+ * axfs_uncompress.c -
+ *  axfs interfaces to the uncompression library. There's really just
+ * three entrypoints:
+ *
+ *  - axfs_uncompress_init() - called to initialize the thing.
+ *  - axfs_uncompress_exit() - tell me when you're done
+ *  - axfs_uncompress_block() - uncompress a block.
+ *
+ * NOTE NOTE NOTE! The uncompression is entirely single-threaded. We
+ * only have one stream, and we'll initialize it only once even if it
+ * then is used by multiple filesystems.
+ *
+ */
+
+#ifndef ALL_VERSIONS
+#include <linux/version.h>	/* For multi-version support */
+#endif
+#include <linux/errno.h>
+#include <linux/vmalloc.h>
+#include <linux/zlib.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
+#include <linux/mutex.h>
+#else
+#include <linux/rwsem.h>
+#endif
+
+static z_stream stream;
+static int initialized;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
+static struct mutex axfs_uncmp_mutex;
+#else
+static struct rw_semaphore axfs_uncmp_mutex;
+#endif
+
+int axfs_uncompress_block(void *dst, int dstlen, void *src, int srclen)
+{
+	int err;
+	int out;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
+	mutex_lock(&axfs_uncmp_mutex);
+#else
+	down_write(&axfs_uncmp_mutex);
+#endif
+
+	stream.next_in = src;
+	stream.avail_in = srclen;
+
+	stream.next_out = dst;
+	stream.avail_out = dstlen;
+
+	err = zlib_inflateReset(&stream);
+	if (err != Z_OK) {
+		printk(KERN_ERR "zlib_inflateReset error %d\n", err);
+		zlib_inflateEnd(&stream);
+		zlib_inflateInit(&stream);
+	}
+
+	err = zlib_inflate(&stream, Z_FINISH);
+	if (err != Z_STREAM_END)
+		goto err;
+
+	out = stream.total_out;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
+	mutex_unlock(&axfs_uncmp_mutex);
+#else
+	up_write(&axfs_uncmp_mutex);
+#endif
+
+	return out;
+
+err:
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
+	mutex_unlock(&axfs_uncmp_mutex);
+#else
+	up_write(&axfs_uncmp_mutex);
+#endif
+
+	printk(KERN_ERR "Error %d while decompressing!\n", err);
+	printk(KERN_ERR "%p(%d)->%p(%d)\n", src, srclen, dst, dstlen);
+	return 0;
+}
+
+int axfs_uncompress_init(void)
+{
+	if (!initialized++) {
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
+		mutex_init(&axfs_uncmp_mutex);
+#else
+		init_rwsem(&axfs_uncmp_mutex);
+#endif
+
+		stream.workspace = vmalloc(zlib_inflate_workspacesize());
+		if (!stream.workspace) {
+			initialized = 0;
+			return -ENOMEM;
+		}
+		stream.next_in = NULL;
+		stream.avail_in = 0;
+		zlib_inflateInit(&stream);
+	}
+	return 0;
+}
+
+int axfs_uncompress_exit(void)
+{
+	if (!--initialized) {
+		zlib_inflateEnd(&stream);
+		vfree(stream.workspace);
+	}
+	return 0;
+}
diff --git a/include/linux/axfs.h b/include/linux/axfs.h
new file mode 100644
index 0000000..b0cfdac
--- /dev/null
+++ b/include/linux/axfs.h
@@ -0,0 +1,375 @@
+/*
+ * Advanced XIP File System for Linux - AXFS
+ *   Readonly, compressed, and XIP filesystem for Linux systems big and small
+ *
+ * Copyright(c) 2008 Numonyx
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * Authors:
+ *  Eric Anderson
+ *  Jared Hulbert <jaredeh@gmail.com>
+ *  Sujaya Srinivasan
+ *  Justin Treon
+ *
+ * Project url: http://axfs.sourceforge.net
+ */
+
+#ifndef __AXFS_H
+#define __AXFS_H
+
+#ifndef ALL_VERSIONS
+#include <linux/version.h>	/* For multi-version support */
+#endif
+
+#ifdef __KERNEL__
+#include <linux/rwsem.h>
+#endif
+#include <linux/errno.h>
+#include <linux/time.h>
+
+#define AXFS_MAGIC	0x48A0E4CD	/* some random number */
+#define AXFS_SIGNATURE	"Advanced XIP FS"
+#define AXFS_MAXPATHLEN 255
+
+/* Uncompression interfaces to the underlying zlib */
+int axfs_uncompress_block(void *, int, void *, int);
+int axfs_uncompress_init(void);
+int axfs_uncompress_exit(void);
+
+struct axfs_profiling_data {
+	u64 inode_number;
+	unsigned long count;
+};
+
+enum axfs_node_types {
+	XIP = 0,
+	Compressed,
+	Byte_Aligned,
+};
+
+enum axfs_compression_types {
+	ZLIB = 0
+};
+
+/*
+ *  on media struct describing a data region
+ */
+struct axfs_region_desc_onmedia {
+	u64 fsoffset;
+	u64 size;
+	u64 compressed_size;
+	u64 max_index;
+	u8 table_byte_depth;
+	u8 incore;
+};
+
+struct axfs_region_desc {
+	u64 fsoffset;
+	u64 size;
+	u64 compressed_size;
+	u64 max_index;
+	void *virt_addr;
+	u8 table_byte_depth;
+	u8 incore;
+};
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
+#else
+struct axfs_fill_super_info {
+	struct axfs_super_onmedia *onmedia_super_block;
+	unsigned long physical_start_address;
+	unsigned long virtual_start_address;
+};
+#endif
+/*
+ * axfs_super is the on media format for the super block it must be big endian
+ */
+struct axfs_super_onmedia {
+	u32 magic;		/* 0x48A0E4CD - random number */
+	u8 signature[16];	/* "Advanced XIP FS" */
+	u8 digest[40];		/* sha1 digest for checking data integrity */
+	u32 cblock_size;	/* maximum size of the block being compressed */
+	u64 files;		/* number of inodes/files in fs */
+	u64 size;		/* total image size */
+	u64 blocks;		/* number of nodes in fs */
+	u64 mmap_size;		/* size of the memory mapped part of image */
+	u64 strings;		/* offset to strings region descriptor */
+	u64 xip;		/* offset to xip region descriptor */
+	u64 byte_aligned;	/* offset to the byte aligned region desc */
+	u64 compressed;		/* offset to the compressed region desc */
+	u64 node_type;		/* offset to node type region desc */
+	u64 node_index;		/* offset to node index region desc */
+	u64 cnode_offset;	/* offset to cnode offset region desc */
+	u64 cnode_index;	/* offset to cnode index region desc */
+	u64 banode_offset;	/* offset to banode offset region desc */
+	u64 cblock_offset;	/* offset to cblock offset region desc */
+	u64 inode_file_size;	/* offset to inode file size desc*/
+	u64 inode_name_offset;	/* offset to inode num_entries region desc */
+	u64 inode_num_entries;	/* offset to inode num_entries region desc */
+	u64 inode_mode_index;	/* offset to inode mode index region desc */
+	u64 inode_array_index;	/* offset to inode node index region desc */
+	u64 modes;		/* offset to mode mode region desc */
+	u64 uids;		/* offset to mode uid index region desc */
+	u64 gids;		/* offset to mode gid index region desc */
+	u8 version_major;
+	u8 version_minor;
+	u8 version_sub;
+	u8 compression_type;	/* Identifies type of compression used on FS */
+	u64 timestamp;		/* UNIX time_t of filesystem build time */
+};
+
+/*
+ * axfs super-block data in core
+ */
+struct axfs_super {
+	u32 magic;
+	u8 version_major;
+	u8 version_minor;
+	u8 version_sub;
+	u8 padding;
+	u64 files;
+	u64 size;
+	u64 blocks;
+	u64 mmap_size;
+	struct axfs_region_desc strings;
+	struct axfs_region_desc xip;
+	struct axfs_region_desc compressed;
+	struct axfs_region_desc byte_aligned;
+	struct axfs_region_desc node_type;
+	struct axfs_region_desc node_index;
+	struct axfs_region_desc cnode_offset;
+	struct axfs_region_desc cnode_index;
+	struct axfs_region_desc banode_offset;
+	struct axfs_region_desc cblock_offset;
+	struct axfs_region_desc inode_file_size;
+	struct axfs_region_desc inode_name_offset;
+	struct axfs_region_desc inode_num_entries;
+	struct axfs_region_desc inode_mode_index;
+	struct axfs_region_desc inode_array_index;
+	struct axfs_region_desc modes;
+	struct axfs_region_desc uids;
+	struct axfs_region_desc gids;
+	unsigned long phys_start_addr;
+	unsigned long virt_start_addr;
+	char *second_dev;
+	unsigned long iomem_size;
+	void *mtd0;		/* primary device */
+	void *mtd1;		/* secondary device */
+	u32 cblock_size;
+	u64 current_cnode_index;
+	void *cblock_buffer[2];
+	struct rw_semaphore lock;
+	struct axfs_profiling_data *profile_data_ptr;
+	u8 profiling_on;	/* Determines if profiling is on or off */
+	u8 mtd_pointed;
+	u8 compression_type;
+	struct timespec timestamp;
+};
+
+#define AXFS_PAGE_SIZE 4096
+
+#define AXFS_SB(sb) (struct axfs_super *)((sb)->s_fs_info)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,21)
+#define AXFS_MTD(sb) (void *)((sb)->s_mtd)
+#else
+#define AXFS_MTD(sb) 0
+#endif
+#define AXFS_MTD0(sb) (((AXFS_SB(sb))->mtd0) ? \
+  ((AXFS_SB(sb))->mtd0) : (AXFS_MTD(sb)))
+#define AXFS_MTD1(sb) ((AXFS_SB(sb))->mtd1)
+
+#define AXFS_BDEV(sb) ((sb)->s_bdev)
+
+#define AXFS_HAS_BDEV(sb) \
+  ((AXFS_BDEV(sb) != NULL) ? TRUE : FALSE)
+#define AXFS_HAS_MTD(sb) \
+  (((AXFS_MTD0(sb) != NULL) || \
+    (AXFS_MTD1(sb) != NULL) || \
+    (AXFS_MTD(sb) != NULL)) ? TRUE : FALSE)
+
+#define AXFS_NODEV(sb) \
+  ((!AXFS_HAS_MTD(sb) && !AXFS_HAS_BDEV(sb)) ? TRUE : FALSE)
+
+static inline u64 axfs_bytetable_stitch(u8 depth, u8 *table, u64 index)
+{
+	u64 i;
+	u64 output = 0;
+	u64 byte = 0;
+	u64 j;
+	u64 bits;
+
+	for (i = 0; i < depth; i++) {
+		j = index * depth + i;
+		bits = 8 * (depth - i - 1);
+		byte = table[j];
+		output += byte << bits;
+	}
+	return output;
+}
+
+#define AXFS_GET_BYTETABLE_VAL(desc,index) \
+  axfs_bytetable_stitch(((struct axfs_region_desc)(desc)).table_byte_depth,\
+  (u8 *)((struct axfs_region_desc)(desc)).virt_addr, index)
+
+#define AXFS_GET_NODE_TYPE(sbi,node_index) \
+  AXFS_GET_BYTETABLE_VAL(((struct axfs_super *)(sbi))->node_type,\
+   (node_index))
+
+#define AXFS_GET_NODE_INDEX(sbi,node__index) \
+  AXFS_GET_BYTETABLE_VAL(((struct axfs_super *)(sbi))->node_index,\
+   (node__index))
+
+#define AXFS_IS_NODE_XIP(sbi,node_index) \
+  (AXFS_GET_NODE_TYPE(sbi, (node_index)) == XIP)
+
+#define AXFS_GET_CNODE_INDEX(sbi,node_index) \
+  AXFS_GET_BYTETABLE_VAL(((struct axfs_super *)(sbi))->cnode_index,\
+   (node_index))
+
+#define AXFS_GET_CNODE_OFFSET(desc,node_index) \
+  AXFS_GET_BYTETABLE_VAL(((struct axfs_super *)(sbi))->cnode_offset,\
+   (node_index))
+
+#define AXFS_GET_BANODE_OFFSET(desc,node_index) \
+  AXFS_GET_BYTETABLE_VAL(((struct axfs_super *)(sbi))->banode_offset,\
+   (node_index))
+
+#define AXFS_GET_CBLOCK_OFFSET(desc,node_index) \
+  AXFS_GET_BYTETABLE_VAL(((struct axfs_super *)(sbi))->cblock_offset,\
+   (node_index))
+
+#define AXFS_GET_INODE_FILE_SIZE(sbi,inode_index) \
+  AXFS_GET_BYTETABLE_VAL(((struct axfs_super *)(sbi))->inode_file_size,\
+   (inode_index))
+
+#define AXFS_GET_INODE_NAME_OFFSET(sbi,inode_index) \
+  AXFS_GET_BYTETABLE_VAL(((struct axfs_super *)(sbi))->inode_name_offset,\
+	(inode_index))
+
+#define AXFS_GET_INODE_NUM_ENTRIES(sbi,inode_index) \
+  AXFS_GET_BYTETABLE_VAL(((struct axfs_super *)(sbi))->inode_num_entries,\
+	(inode_index))
+
+#define AXFS_GET_INODE_MODE_INDEX(sbi,inode_index) \
+  AXFS_GET_BYTETABLE_VAL(((struct axfs_super *)(sbi))->inode_mode_index,\
+   (inode_index))
+
+#define AXFS_GET_INODE_ARRAY_INDEX(sbi,inode_index) \
+  AXFS_GET_BYTETABLE_VAL(((struct axfs_super *)(sbi))->inode_array_index,\
+   (inode_index))
+
+#define AXFS_GET_MODE(sbi,mode_index) \
+  AXFS_GET_BYTETABLE_VAL(((struct axfs_super *)(sbi))->modes,\
+  (AXFS_GET_INODE_MODE_INDEX(sbi, (mode_index))))
+
+#define AXFS_GET_UID(sbi,mode_index) \
+  AXFS_GET_BYTETABLE_VAL(((struct axfs_super *)(sbi))->uids,\
+  (AXFS_GET_INODE_MODE_INDEX(sbi, (mode_index))))
+
+#define AXFS_GET_GID(sbi,mode_index) \
+  AXFS_GET_BYTETABLE_VAL(((struct axfs_super *)(sbi))->gids,\
+  (AXFS_GET_INODE_MODE_INDEX(sbi, (mode_index))))
+
+#define AXFS_IS_REGION_COMPRESSED(_region) \
+    (( \
+     ((struct axfs_region_desc *)(_region))->compressed_size > \
+     0 \
+    ) ? TRUE : FALSE)
+
+#define AXFS_PHYSADDR_IS_VALID(sbi) \
+    (((((struct axfs_super *)(sbi))->phys_start_addr) > 0 \
+	) ? TRUE : FALSE)
+
+#define AXFS_VIRTADDR_IS_VALID(sbi) \
+    (((((struct axfs_super *)(sbi))->virt_start_addr) > 0 \
+	) ? TRUE : FALSE)
+
+#define AXFS_IS_IOMEM(sbi) \
+    (((((struct axfs_super *)(sbi))->iomem_size) > 0) ? TRUE : FALSE)
+
+#define AXFS_IS_POINTED(sbi) \
+    (((((struct axfs_super *)(sbi))->mtd_pointed) > 0) ? TRUE : FALSE)
+
+#define AXFS_IS_PHYSMEM(sbi) \
+    (( \
+      AXFS_PHYSADDR_IS_VALID(sbi) \
+      && !AXFS_IS_IOMEM(sbi) \
+      && !AXFS_IS_POINTED(sbi) \
+    ) ? TRUE : FALSE)
+
+#define AXFS_IS_MMAPABLE(sbi,offset) \
+    ((\
+       (((struct axfs_super *)(sbi))->mmap_size) > (offset) \
+    ) ? TRUE : FALSE)
+
+#define AXFS_IS_OFFSET_MMAPABLE(sbi,offset) \
+    (( \
+       AXFS_IS_MMAPABLE(sbi, offset) && AXFS_VIRTADDR_IS_VALID(sbi) \
+     ) ? TRUE : FALSE)
+
+#define AXFS_IS_REGION_MMAPABLE(sbi,_region) \
+    (( \
+      AXFS_IS_MMAPABLE(sbi, ((struct axfs_region_desc *)(_region))->fsoffset) \
+      && AXFS_VIRTADDR_IS_VALID(sbi) \
+     ) ? TRUE : FALSE)
+
+#define AXFS_IS_REGION_INCORE(_region) \
+    (((_region)->incore > 0) ? TRUE : FALSE)
+
+#define AXFS_IS_REGION_XIP(sbi,_region) \
+    (( \
+     !AXFS_IS_REGION_COMPRESSED(_region) && \
+     !AXFS_IS_REGION_INCORE(_region) && \
+     AXFS_IS_REGION_MMAPABLE(sbi,_region) \
+    ) ? TRUE : FALSE)
+
+#define AXFS_GET_XIP_REGION_PHYSADDR(sbi) \
+    (unsigned long)((sbi)->phys_start_addr + (sbi)->xip.fsoffset)
+
+#define AXFS_GET_INODE_NAME(sbi,inode_index) \
+     (char *)( \
+	(sbi)->strings.virt_addr \
+	+ AXFS_GET_INODE_NAME_OFFSET(sbi,inode_index) \
+     )
+
+#define AXFS_GET_CBLOCK_ADDRESS(sbi, cnode_index)\
+    (unsigned long)( \
+       (sbi)->compressed.virt_addr \
+       + AXFS_GET_CBLOCK_OFFSET(sbi, cnode_index) \
+    )
+
+#define AXFS_GET_NODE_ADDRESS(sbi,node__index) \
+    (unsigned long)( \
+       (sbi)->node_index.virt_addr \
+       + AXFS_GET_NODE_INDEX(sbi, node__index) \
+    )
+
+#define AXFS_GET_BANODE_ADDRESS(sbi,banode_index) \
+    (unsigned long)( \
+       (sbi)->byte_aligned.virt_addr \
+       + AXFS_GET_BANODE_OFFSET(sbi, banode_index) \
+    )
+
+#define AXFS_FSOFFSET_2_DEVOFFSET(sbi,fsoffset) \
+    (( \
+      ((sbi)->phys_start_addr == 0) && ((sbi)->virt_start_addr == 0) \
+      ) ? (fsoffset) : (fsoffset - (sbi)->mmap_size) \
+    )
+
+#define AXFS_GET_CBLOCK_LENGTH(sbi,cblock_index) \
+    (u64)( \
+      (u64)AXFS_GET_CBLOCK_OFFSET(sbi, ((u64)(cblock_index)+(u64)1)) \
+      - (u64)AXFS_GET_CBLOCK_OFFSET(sbi, (cblock_index)) \
+    )
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#endif
-- 
1.6.5.2

