From f38781d13cd44776e07de6b89bc1f58fd9dd26e6 Mon Sep 17 00:00:00 2001
From: Denis Oliver Kropp <dok@directfb.org>
Date: Mon, 4 Nov 2002 16:28:36 +0000
Subject: [PATCH] Implemented FusionProperty in kernel space (200k -> 700k lease/cede per sec).

---
 drivers/char/fusion/Makefile    |    2 +-
 drivers/char/fusion/fusiondev.c |   40 +++++
 drivers/char/fusion/fusionee.c  |    2 +
 drivers/char/fusion/property.c  |  360 +++++++++++++++++++++++++++++++++++++++
 drivers/char/fusion/property.h  |   40 +++++
 include/linux/fusion.h          |    6 +
 6 files changed, 449 insertions(+), 1 deletions(-)
 create mode 100644 drivers/char/fusion/property.c
 create mode 100644 drivers/char/fusion/property.h

diff --git a/drivers/char/fusion/Makefile b/drivers/char/fusion/Makefile
index 2775139..251ac10 100644
--- a/drivers/char/fusion/Makefile
+++ b/drivers/char/fusion/Makefile
@@ -1,6 +1,6 @@
 O_TARGET := fusion.o
 
-obj-y   := fusiondev.o fusionee.o list.o ref.o skirmish.o
+obj-y   := fusiondev.o fusionee.o list.o property.o ref.o skirmish.o
 obj-m   := $(O_TARGET)
 
 include $(TOPDIR)/Rules.make
diff --git a/drivers/char/fusion/fusiondev.c b/drivers/char/fusion/fusiondev.c
index 9344c9f..65c63a0 100644
--- a/drivers/char/fusion/fusiondev.c
+++ b/drivers/char/fusion/fusiondev.c
@@ -27,6 +27,7 @@
 
 #include "fusiondev.h"
 #include "fusionee.h"
+#include "property.h"
 #include "ref.h"
 #include "skirmish.h"
 
@@ -78,6 +79,7 @@ fusion_ioctl (struct inode *inode, struct file *file,
       put_user (fusion_id, (int*) arg);
       break;
 
+
     case FUSION_REF_NEW:
       ret = fusion_ref_new (&id);
       if (ret)
@@ -135,6 +137,7 @@ fusion_ioctl (struct inode *inode, struct file *file,
 
       return fusion_ref_destroy (id);
 
+
     case FUSION_SKIRMISH_NEW:
       ret = fusion_skirmish_new (&id);
       if (ret)
@@ -163,6 +166,35 @@ fusion_ioctl (struct inode *inode, struct file *file,
 
       return fusion_skirmish_destroy (id);
 
+
+    case FUSION_PROPERTY_NEW:
+      ret = fusion_property_new (&id);
+      if (ret)
+        return ret;
+
+      put_user (id, (int*) arg);
+      break;
+
+    case FUSION_PROPERTY_LEASE:
+      get_user (id, (int*) arg);
+
+      return fusion_property_lease (id, fusion_id);
+
+    case FUSION_PROPERTY_PURCHASE:
+      get_user (id, (int*) arg);
+
+      return fusion_property_purchase (id, fusion_id);
+
+    case FUSION_PROPERTY_CEDE:
+      get_user (id, (int*) arg);
+
+      return fusion_property_cede (id, fusion_id);
+
+    case FUSION_PROPERTY_DESTROY:
+      get_user (id, (int*) arg);
+
+      return fusion_property_destroy (id);
+
     default:
       return -ENOTTY;
     }
@@ -204,6 +236,10 @@ fusion_init(void)
   if (ret)
     goto error_skirmish;
 
+  ret = fusion_property_init();
+  if (ret)
+    goto error_property;
+
   ret = misc_register (&fusion_miscdev);
   if (ret)
     goto error_misc;
@@ -212,6 +248,9 @@ fusion_init(void)
 
 
  error_misc:
+  fusion_property_cleanup();
+
+ error_property:
   fusion_skirmish_cleanup();
 
  error_skirmish:
@@ -229,6 +268,7 @@ fusion_exit(void)
 {
   misc_deregister (&fusion_miscdev);
   
+  fusion_property_cleanup();
   fusion_skirmish_cleanup();
   fusion_ref_cleanup();
   fusionee_cleanup();
diff --git a/drivers/char/fusion/fusionee.c b/drivers/char/fusion/fusionee.c
index 9e5c809..03404ef 100644
--- a/drivers/char/fusion/fusionee.c
+++ b/drivers/char/fusion/fusionee.c
@@ -23,6 +23,7 @@
 #include "list.h"
 #include "fusiondev.h"
 #include "fusionee.h"
+#include "property.h"
 #include "ref.h"
 #include "skirmish.h"
 
@@ -161,6 +162,7 @@ fusionee_destroy (int id)
   fusion_list_remove (&fusionees, &fusionee->link);
 
   fusion_skirmish_dismiss_all (id);
+  fusion_property_cede_all (id);
   fusion_ref_clear_all_local (id);
 
   spin_unlock (&fusionees_lock);
diff --git a/drivers/char/fusion/property.c b/drivers/char/fusion/property.c
new file mode 100644
index 0000000..e2daf27
--- /dev/null
+++ b/drivers/char/fusion/property.c
@@ -0,0 +1,360 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  convergence integrated media GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "property.h"
+
+typedef enum {
+     FUSION_PROPERTY_AVAILABLE = 0,
+     FUSION_PROPERTY_LEASED,
+     FUSION_PROPERTY_PURCHASED
+} FusionPropertyState;
+
+typedef struct {
+  FusionLink          link;
+
+  spinlock_t          lock;
+
+  int                 id;
+  int                 pid;
+
+  FusionPropertyState state;
+  int                 fusion_id; /* non-zero if leased/purchased */
+
+  wait_queue_head_t   wait;
+} FusionProperty;
+
+/******************************************************************************/
+
+static FusionProperty *lookup_property     (int id);
+
+static FusionProperty *lock_property       (int id);
+static void            unlock_property     (FusionProperty *property);
+
+/******************************************************************************/
+
+static int         ids             = 0;
+static FusionLink *properties      = NULL;
+static spinlock_t  properties_lock = SPIN_LOCK_UNLOCKED;
+
+/******************************************************************************/
+
+static int
+fusion_property_read_proc(char *buf, char **start, off_t offset,
+                     int len, int *eof, void *private)
+{
+  FusionLink *l;
+  int written = 0;
+
+  spin_lock (&properties_lock);
+
+  fusion_list_foreach (l, properties)
+    {
+      FusionProperty *property = (FusionProperty*) l;
+
+      written += sprintf(buf+written, "(%5d) 0x%08x %s\n",
+                         property->pid, property->id,
+                         property->state ?
+                           (property->state == FUSION_PROPERTY_LEASED ?
+                              "leased" : "purchased") :
+                           "");
+      if (written < offset)
+        {
+          offset -= written;
+          written = 0;
+        }
+
+      if (written >= len)
+        break;
+    }
+
+  spin_unlock (&properties_lock);
+
+  *start = buf + offset;
+  written -= offset;
+  if(written > len)
+    {
+      *eof = 0;
+      return len;
+    }
+
+  *eof = 1;
+  return (written<0) ? 0 : written;
+}
+
+int
+fusion_property_init()
+{
+  create_proc_read_entry("properties", 0, proc_fusion_dir,
+                         fusion_property_read_proc, NULL);
+
+  return 0;
+}
+
+void
+fusion_property_cleanup()
+{
+  FusionLink *l = properties;
+
+  while (l)
+    {
+      FusionLink     *next     = l->next;
+      FusionProperty *property = (FusionProperty *) l;
+
+      kfree (property);
+
+      l = next;
+    }
+
+  properties = NULL;
+
+  remove_proc_entry ("properties", proc_fusion_dir);
+}
+
+/******************************************************************************/
+
+int
+fusion_property_new (int *id)
+{
+  FusionProperty *property;
+
+  property = kmalloc (sizeof(FusionProperty), GFP_KERNEL);
+  if (!property)
+    return -ENOMEM;
+
+  memset (property, 0, sizeof(FusionProperty));
+
+  spin_lock (&properties_lock);
+
+  property->id   = ids++;
+  property->pid  = current->pid;
+  property->lock = SPIN_LOCK_UNLOCKED;
+
+  init_waitqueue_head (&property->wait);
+
+  fusion_list_prepend (&properties, &property->link);
+
+  spin_unlock (&properties_lock);
+
+  *id = property->id;
+
+  return 0;
+}
+
+int
+fusion_property_lease (int id, int fusion_id)
+{
+  FusionProperty *property;
+
+  while (true)
+    {
+      property = lock_property (id);
+      if (!property)
+        return -EINVAL;
+
+      switch (property->state)
+        {
+        case FUSION_PROPERTY_AVAILABLE:
+          property->state     = FUSION_PROPERTY_LEASED;
+          property->fusion_id = fusion_id;
+
+          unlock_property (property);
+          return 0;
+
+        case FUSION_PROPERTY_LEASED:
+          unlock_property (property);
+
+          interruptible_sleep_on (&property->wait);
+
+          if (signal_pending(current))
+            return -ERESTARTSYS;
+
+          break;
+
+        case FUSION_PROPERTY_PURCHASED:
+          unlock_property (property);
+          return -EAGAIN;
+        }
+    }
+
+  /* won't reach this */
+  return 0;
+}
+
+int
+fusion_property_purchase (int id, int fusion_id)
+{
+  FusionProperty *property;
+
+  while (true)
+    {
+      property = lock_property (id);
+      if (!property)
+        return -EINVAL;
+
+      switch (property->state)
+        {
+        case FUSION_PROPERTY_AVAILABLE:
+          property->state     = FUSION_PROPERTY_PURCHASED;
+          property->fusion_id = fusion_id;
+
+          wake_up_interruptible_all (&property->wait);
+
+          unlock_property (property);
+          return 0;
+
+        case FUSION_PROPERTY_LEASED:
+          unlock_property (property);
+
+          interruptible_sleep_on (&property->wait);
+
+          if (signal_pending(current))
+            return -ERESTARTSYS;
+
+          break;
+
+        case FUSION_PROPERTY_PURCHASED:
+          unlock_property (property);
+          return -EAGAIN;
+        }
+    }
+
+  /* won't reach this */
+  return 0;
+}
+
+int
+fusion_property_cede (int id, int fusion_id)
+{
+  FusionProperty *property = lock_property (id);
+
+  if (!property)
+    return -EINVAL;
+
+  if (property->fusion_id != fusion_id)
+    {
+      unlock_property (property);
+      return -EIO;
+    }
+
+  property->state     = FUSION_PROPERTY_AVAILABLE;
+  property->fusion_id = 0;
+
+  wake_up_interruptible_all (&property->wait);
+
+  unlock_property (property);
+
+  return 0;
+}
+
+int
+fusion_property_destroy (int id)
+{
+  FusionProperty *property = lookup_property (id);
+
+  if (!property)
+    return -EINVAL;
+
+  spin_lock (&property->lock);
+
+  fusion_list_remove (&properties, &property->link);
+
+  wake_up_interruptible_all (&property->wait);
+
+  spin_unlock (&properties_lock);
+
+  kfree (property);
+
+  return 0;
+}
+
+void
+fusion_property_cede_all (int fusion_id)
+{
+  FusionLink *l;
+
+  spin_lock (&properties_lock);
+
+  fusion_list_foreach (l, properties)
+    {
+      FusionProperty *property = (FusionProperty *) l;
+
+      spin_lock (&property->lock);
+
+      if (property->fusion_id == fusion_id)
+        {
+          property->state     = FUSION_PROPERTY_AVAILABLE;
+          property->fusion_id = 0;
+
+          wake_up_interruptible_all (&property->wait);
+        }
+
+      spin_unlock (&property->lock);
+    }
+
+  spin_unlock (&properties_lock);
+}
+
+/******************************************************************************/
+
+static FusionProperty *
+lookup_property (int id)
+{
+  FusionLink *l;
+
+  spin_lock (&properties_lock);
+
+  fusion_list_foreach (l, properties)
+    {
+      FusionProperty *property = (FusionProperty *) l;
+
+      if (property->id == id)
+        return property;
+    }
+
+  spin_unlock (&properties_lock);
+
+  return NULL;
+}
+
+static FusionProperty *
+lock_property (int id)
+{
+  FusionProperty *property = lookup_property (id);
+
+  if (property)
+    {
+      spin_lock (&property->lock);
+      spin_unlock (&properties_lock);
+    }
+
+  return property;
+}
+
+static void
+unlock_property (FusionProperty *property)
+{
+  spin_unlock (&property->lock);
+}
diff --git a/drivers/char/fusion/property.h b/drivers/char/fusion/property.h
new file mode 100644
index 0000000..629f14f
--- /dev/null
+++ b/drivers/char/fusion/property.h
@@ -0,0 +1,40 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  convergence integrated media GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSION__PROPERTY_H__
+#define __FUSION__PROPERTY_H__
+
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_property_init (void);
+void fusion_property_cleanup (void);
+
+
+/* public API */
+
+int fusion_property_new (int *id);
+int fusion_property_lease (int id, int fusion_id);
+int fusion_property_purchase (int id, int fusion_id);
+int fusion_property_cede (int id, int fusion_id);
+int fusion_property_destroy (int id);
+
+
+/* internal functions */
+
+void fusion_property_cede_all (int fusion_id);
+
+#endif
diff --git a/include/linux/fusion.h b/include/linux/fusion.h
index 3f0edbf..bd807d6 100644
--- a/include/linux/fusion.h
+++ b/include/linux/fusion.h
@@ -23,5 +23,11 @@
 #define FUSION_SKIRMISH_DISMISS         _IOW('F', 0x23, sizeof(int))
 #define FUSION_SKIRMISH_DESTROY         _IOW('F', 0x24, sizeof(int))
 
+#define FUSION_PROPERTY_NEW             _IOW('F', 0x30, sizeof(int))
+#define FUSION_PROPERTY_LEASE           _IOW('F', 0x31, sizeof(int))
+#define FUSION_PROPERTY_PURCHASE        _IOW('F', 0x32, sizeof(int))
+#define FUSION_PROPERTY_CEDE            _IOW('F', 0x33, sizeof(int))
+#define FUSION_PROPERTY_DESTROY         _IOW('F', 0x34, sizeof(int))
+
 #endif
 
-- 
1.7.3.3

