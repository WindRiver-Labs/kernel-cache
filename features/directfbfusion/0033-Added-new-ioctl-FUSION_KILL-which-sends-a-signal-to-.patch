From f4dbf3d253b6364ed8036904d129932aa81e1c92 Mon Sep 17 00:00:00 2001
From: Denis Oliver Kropp <dok@directfb.org>
Date: Wed, 4 Jun 2003 18:58:10 +0000
Subject: [PATCH] Added new ioctl FUSION_KILL which sends a signal to one or more fusionees with an optional timeout for waiting for their termination.

---
 drivers/char/fusion/fusiondev.c |   10 +++++
 drivers/char/fusion/fusionee.c  |   71 +++++++++++++++++++++++++++++++++-----
 drivers/char/fusion/fusionee.h  |    2 +-
 drivers/char/fusion/property.c  |    2 +-
 include/linux/fusion.h          |   14 ++++++-
 5 files changed, 85 insertions(+), 14 deletions(-)

diff --git a/drivers/char/fusion/fusiondev.c b/drivers/char/fusion/fusiondev.c
index 0cca194..3062f4b 100644
--- a/drivers/char/fusion/fusiondev.c
+++ b/drivers/char/fusion/fusiondev.c
@@ -178,6 +178,7 @@ fusion_ioctl (struct inode *inode, struct file *file,
   int fusion_id = (int) file->private_data;
   FusionSendMessage     send;
   FusionReactorDispatch dispatch;
+  FusionKill            kill;
   FusionCallNew         call;
   FusionCallExecute     execute;
   FusionCallReturn      call_ret;
@@ -190,6 +191,7 @@ fusion_ioctl (struct inode *inode, struct file *file,
 
       break;
 
+
     case FUSION_SEND_MESSAGE:
       if (copy_from_user (&send, (FusionSendMessage*) arg, sizeof(send)))
         return -EFAULT;
@@ -245,6 +247,14 @@ fusion_ioctl (struct inode *inode, struct file *file,
       return fusion_call_destroy (fusion_id, id);
 
 
+    case FUSION_KILL:
+      if (copy_from_user (&kill, (FusionKill*) arg, sizeof(kill)))
+        return -EFAULT;
+
+      return fusionee_kill (fusion_id,
+                            kill.fusion_id, kill.signal, kill.timeout_ms);
+
+
     case FUSION_REF_NEW:
       ret = fusion_ref_new (&id);
       if (ret)
diff --git a/drivers/char/fusion/fusionee.c b/drivers/char/fusion/fusionee.c
index a2507d9..0663b9e 100644
--- a/drivers/char/fusion/fusionee.c
+++ b/drivers/char/fusion/fusionee.c
@@ -66,10 +66,11 @@ static void      unlock_fusionee (Fusionee *fusionee);
 
 /******************************************************************************/
 
-static int         last_id        = 0;
-static FusionLink *fusionees      = NULL;
-static spinlock_t  fusionees_lock = SPIN_LOCK_UNLOCKED;
-static atomic_t    msg_total;
+static int                last_id        = 0;
+static FusionLink        *fusionees      = NULL;
+static spinlock_t         fusionees_lock = SPIN_LOCK_UNLOCKED;
+static wait_queue_head_t  fusionees_wait;
+static atomic_t           msg_total;
 
 /******************************************************************************/
 
@@ -117,6 +118,8 @@ fusionee_init()
 {
   atomic_set (&msg_total, 0);
 
+  init_waitqueue_head (&fusionees_wait);
+
   create_proc_read_entry("fusionees", 0, proc_fusion_dir,
                          fusionees_read_proc, NULL);
 
@@ -352,16 +355,61 @@ fusionee_poll (int id, struct file *file, poll_table * wait)
 }
 
 int
-fusionee_kill (int id)
+fusionee_kill (int id, int target, int signal, int timeout_ms)
 {
-  Fusionee *fusionee = lock_fusionee (id);
+  long timeout = -1;
 
-  if (!fusionee)
-    return -EINVAL;
+  while (true)
+    {
+      FusionLink *l;
+      Fusionee   *fusionee = lookup_fusionee (id);
+      int         killed   = 0;
 
-  kill_proc (fusionee->pid, SIGKILL, 0);
+      if (!fusionee)
+        return -EINVAL;
 
-  unlock_fusionee (fusionee);
+      fusion_list_foreach (l, fusionees)
+        {
+          Fusionee *f = (Fusionee*) l;
+
+          if (f->id != id && (!target || target == f->id))
+            {
+              kill_proc (f->pid, signal, 0);
+              killed++;
+            }
+        }
+
+      if (!killed || timeout_ms < 0)
+        break;
+
+      if (timeout_ms)
+        {
+          switch (timeout)
+            {
+            case 0:  /* timed out */
+              spin_unlock (&fusionees_lock);
+              return -ETIMEDOUT;
+
+            case -1: /* setup timeout */
+              timeout = (timeout_ms * HZ + 500) / 1000;
+              if (!timeout)
+                timeout = 1;
+
+              /* fall through */
+
+            default:
+              fusion_sleep_on (&fusionees_wait, &fusionees_lock, &timeout);
+              break;
+            }
+        }
+      else
+        fusion_sleep_on (&fusionees_wait, &fusionees_lock, NULL);
+
+      if (signal_pending(current))
+        return -ERESTARTSYS;
+    }
+  
+  spin_unlock (&fusionees_lock);
 
   return 0;
 }
@@ -378,8 +426,11 @@ fusionee_destroy (int id)
 
   fusion_list_remove (&fusionees, &fusionee->link);
 
+  wake_up_interruptible_all (&fusionees_wait);
+
   spin_unlock (&fusionees_lock);
 
+
   fusion_call_destroy_all (id);
   fusion_skirmish_dismiss_all (id);
   fusion_reactor_detach_all (id);
diff --git a/drivers/char/fusion/fusionee.h b/drivers/char/fusion/fusionee.h
index f709313..2e707ab 100644
--- a/drivers/char/fusion/fusionee.h
+++ b/drivers/char/fusion/fusionee.h
@@ -39,7 +39,7 @@ int fusionee_get_messages (int id, void *buf, int buf_size, int block);
 
 unsigned int fusionee_poll (int id, struct file *file, poll_table * wait);
 
-int fusionee_kill (int id);
+int fusionee_kill (int id, int target, int signal, int timeout_ms);
 
 int fusionee_destroy (int id);
 
diff --git a/drivers/char/fusion/property.c b/drivers/char/fusion/property.c
index 12e6077..10ea90b 100644
--- a/drivers/char/fusion/property.c
+++ b/drivers/char/fusion/property.c
@@ -347,7 +347,7 @@ fusion_property_holdup (int id, int fusion_id)
           return -EIO;
         }
 
-      fusionee_kill (property->fusion_id);
+      fusionee_kill (fusion_id, property->fusion_id, SIGKILL, -1);
     }
 
   unlock_property (property);
diff --git a/include/linux/fusion.h b/include/linux/fusion.h
index 6f238f9..b16be3c 100644
--- a/include/linux/fusion.h
+++ b/include/linux/fusion.h
@@ -66,10 +66,9 @@ typedef struct {
   int   call_id;              /* each call has a fixed owner */
   
   int   call_arg;             /* optional int argument */
-  void *call_ptr;             /* optional pointer argument (e.g. shared memory) */
+  void *call_ptr;             /* optional pointer argument (shared memory) */
 } FusionCallExecute;
 
-
 typedef struct {
   int   call_id;              /* id of currently executing call */
 
@@ -85,6 +84,15 @@ typedef struct {
   void              *call_ptr;  /* optional call parameter */
 } FusionCallMessage;
   
+/*
+ * Killing other fusionees (experimental)
+ */
+typedef struct {
+  int fusion_id;    /* fusionee to kill, zero means all but ourself */
+  int signal;       /* signal to be delivered, e.g. SIGTERM */
+  int timeout_ms;   /* -1 means no timeout, 0 means infinite, otherwise the
+                       max. time to wait until the fusionee(s) terminated */
+} FusionKill;
 
 
 #define FUSION_GET_ID                   _IOR('F', 0x00, sizeof(int))
@@ -96,6 +104,8 @@ typedef struct {
 #define FUSION_CALL_RETURN              _IOW('F', 0x04, sizeof(FusionCallReturn))
 #define FUSION_CALL_DESTROY             _IOW('F', 0x05, sizeof(int))
 
+#define FUSION_KILL                     _IOW('F', 0x06, sizeof(FusionKill))
+
 #define FUSION_REF_NEW                  _IOW('F', 0x10, sizeof(int))
 #define FUSION_REF_UP                   _IOW('F', 0x11, sizeof(int))
 #define FUSION_REF_UP_GLOBAL            _IOW('F', 0x12, sizeof(int))
-- 
1.7.3.3

