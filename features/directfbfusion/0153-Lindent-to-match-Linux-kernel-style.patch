From f9f61f5a14294c60fd4119920d2387960de4f926 Mon Sep 17 00:00:00 2001
From: Niels Roest <niels@directfb.org>
Date: Tue, 3 Mar 2009 19:03:37 +0100
Subject: [PATCH] Lindent to match Linux kernel style

---
 drivers/char/fusion/call.c      |  617 ++++++++--------
 drivers/char/fusion/call.h      |   29 +-
 drivers/char/fusion/entries.c   |  590 +++++++--------
 drivers/char/fusion/entries.h   |   89 +--
 drivers/char/fusion/fifo.c      |   42 +-
 drivers/char/fusion/fifo.h      |   20 +-
 drivers/char/fusion/fusiondev.c | 1626 ++++++++++++++++++++-------------------
 drivers/char/fusion/fusiondev.h |  105 ++--
 drivers/char/fusion/fusionee.c  | 1084 +++++++++++++-------------
 drivers/char/fusion/fusionee.h  |   91 +--
 drivers/char/fusion/list.c      |   51 +-
 drivers/char/fusion/list.h      |   12 +-
 drivers/char/fusion/property.c  |  400 +++++-----
 drivers/char/fusion/property.h  |   32 +-
 drivers/char/fusion/reactor.c   |  721 +++++++++---------
 drivers/char/fusion/reactor.h   |   52 +-
 drivers/char/fusion/ref.c       |  837 ++++++++++-----------
 drivers/char/fusion/ref.h       |   54 +-
 drivers/char/fusion/shmpool.c   |  471 ++++++------
 drivers/char/fusion/shmpool.h   |   51 +-
 drivers/char/fusion/skirmish.c  | 1009 ++++++++++++------------
 drivers/char/fusion/skirmish.h  |   55 +-
 drivers/char/fusion/types.h     |   15 +-
 include/linux/fusion.h          |  204 +++---
 24 files changed, 3990 insertions(+), 4267 deletions(-)

diff --git a/drivers/char/fusion/call.c b/drivers/char/fusion/call.c
index 23c4810..b935b59 100644
--- a/drivers/char/fusion/call.c
+++ b/drivers/char/fusion/call.c
@@ -30,422 +30,411 @@
 #include "call.h"
 
 typedef struct {
-     FusionLink        link;
+	FusionLink link;
 
-     Fusionee         *caller;
+	Fusionee *caller;
 
-     int               ret_val;
+	int ret_val;
 
-     bool              executed;
+	bool executed;
 
-     wait_queue_head_t wait;
+	wait_queue_head_t wait;
 
-     int               call_id;
-     unsigned int      serial;
+	int call_id;
+	unsigned int serial;
 } FusionCallExecution;
 
 typedef struct {
-     FusionEntry        entry;
+	FusionEntry entry;
 
-     int                fusion_id; /* owner fusion id */
+	int fusion_id;		/* owner fusion id */
 
-     void              *handler;
-     void              *ctx;
+	void *handler;
+	void *ctx;
 
-     FusionLink        *executions;      /* prepending! */
-     FusionLink        *last;            /* points to the last item of executions */
+	FusionLink *executions;	/* prepending! */
+	FusionLink *last;	/* points to the last item of executions */
 
-     int                count;    /* number of calls ever made */
+	int count;		/* number of calls ever made */
 
-     unsigned int       serial;
+	unsigned int serial;
 } FusionCall;
 
 /* collection, required for 1-param-only passing */
 struct fusion_construct_ctx {
-     int            fusion_id;
-     FusionCallNew *call_new;
+	int fusion_id;
+	FusionCallNew *call_new;
 };
 
 /******************************************************************************/
 
-static FusionCallExecution *add_execution       (FusionCall          *call,
-                                                 Fusionee            *caller,
-                                                 FusionCallExecute   *execute,
-                                                 unsigned int         serial);
-static void                 remove_execution    (FusionCall          *call,
-                                                 FusionCallExecution *execution);
-static void                 free_all_executions (FusionCall          *call);
+static FusionCallExecution *add_execution(FusionCall * call,
+					  Fusionee * caller,
+					  FusionCallExecute * execute,
+					  unsigned int serial);
+static void remove_execution(FusionCall * call,
+			     FusionCallExecution * execution);
+static void free_all_executions(FusionCall * call);
 
 /******************************************************************************/
 
 static int
-fusion_call_construct( FusionEntry *entry,
-                       void        *ctx,
-                       void        *create_ctx )
+fusion_call_construct(FusionEntry * entry, void *ctx, void *create_ctx)
 {
-     FusionCall *call = (FusionCall*) entry;
-     
-     struct fusion_construct_ctx *cc = (struct fusion_construct_ctx*) create_ctx;
+	FusionCall *call = (FusionCall *) entry;
 
-     call->fusion_id = cc->fusion_id;
-     call->handler   = cc->call_new->handler;
-     call->ctx       = cc->call_new->ctx;
+	struct fusion_construct_ctx *cc =
+	    (struct fusion_construct_ctx *)create_ctx;
 
-     cc->call_new->call_id = entry->id;
+	call->fusion_id = cc->fusion_id;
+	call->handler = cc->call_new->handler;
+	call->ctx = cc->call_new->ctx;
 
-     return 0;
-}
+	cc->call_new->call_id = entry->id;
 
+	return 0;
+}
 
-static void
-fusion_call_destruct( FusionEntry *entry,
-                      void        *ctx )
+static void fusion_call_destruct(FusionEntry * entry, void *ctx)
 {
-     FusionCall *call = (FusionCall*) entry;
+	FusionCall *call = (FusionCall *) entry;
 
-     free_all_executions (call);
+	free_all_executions(call);
 }
 
 static void
-fusion_call_print( FusionEntry     *entry,
-                   void            *ctx,
-                   struct seq_file *p )
+fusion_call_print(FusionEntry * entry, void *ctx, struct seq_file *p)
 {
-     FusionLink *e;
-     bool        idle = true;
-     FusionCall *call = (FusionCall*) entry;
+	FusionLink *e;
+	bool idle = true;
+	FusionCall *call = (FusionCall *) entry;
 
-     if (call->executions)
-          idle = ((FusionCallExecution*) call->executions)->executed;
+	if (call->executions)
+		idle = ((FusionCallExecution *) call->executions)->executed;
 
-     seq_printf( p, "(%5d) 0x%08x (%d calls) %s",
-                    call->entry.pid, call->entry.id, call->count,
-                    idle ? "idle" : "executing");
+	seq_printf(p, "(%5d) 0x%08x (%d calls) %s",
+		   call->entry.pid, call->entry.id, call->count,
+		   idle ? "idle" : "executing");
 
-     fusion_list_foreach (e, call->executions) {
-          FusionCallExecution *exec = (FusionCallExecution *) e;
+	fusion_list_foreach(e, call->executions) {
+		FusionCallExecution *exec = (FusionCallExecution *) e;
 
-          seq_printf( p, "  [0x%08lx]", exec->caller ? fusionee_id( exec->caller ) : 0);
-     }
+		seq_printf(p, "  [0x%08lx]",
+			   exec->caller ? fusionee_id(exec->caller) : 0);
+	}
 
-     seq_printf( p, "\n" );
+	seq_printf(p, "\n");
 }
 
-
-FUSION_ENTRY_CLASS( FusionCall, call, fusion_call_construct,
-                    fusion_call_destruct, fusion_call_print )
+FUSION_ENTRY_CLASS(FusionCall, call, fusion_call_construct,
+		   fusion_call_destruct, fusion_call_print)
 
 /******************************************************************************/
 
-int
-fusion_call_init (FusionDev *dev)
+int fusion_call_init(FusionDev * dev)
 {
-     fusion_entries_init( &dev->call, &call_class, dev );
+	fusion_entries_init(&dev->call, &call_class, dev);
 
-     fusion_entries_create_proc_entry( dev, "calls", &dev->call );
+	fusion_entries_create_proc_entry(dev, "calls", &dev->call);
 
-     return 0;
+	return 0;
 }
 
-void
-fusion_call_deinit (FusionDev *dev)
+void fusion_call_deinit(FusionDev * dev)
 {
-     remove_proc_entry ("calls", dev->proc_dir);
+	remove_proc_entry("calls", dev->proc_dir);
 
-     fusion_entries_deinit( &dev->call );
+	fusion_entries_deinit(&dev->call);
 }
 
 /******************************************************************************/
 
-int
-fusion_call_new (FusionDev *dev, int fusion_id, FusionCallNew *call_new)
+int fusion_call_new(FusionDev * dev, int fusion_id, FusionCallNew * call_new)
 {
-     int         id;
-     int         ret;
+	int id;
+	int ret;
 
-     struct fusion_construct_ctx cc = { fusion_id, call_new };
-     
-     ret = fusion_entry_create( &dev->call, &id, &cc );
-     if( ret )
-          return ret;
+	struct fusion_construct_ctx cc = { fusion_id, call_new };
 
-     return 0;
+	ret = fusion_entry_create(&dev->call, &id, &cc);
+	if (ret)
+		return ret;
+
+	return 0;
 }
 
 int
-fusion_call_execute (FusionDev *dev, Fusionee *fusionee, FusionCallExecute *execute)
+fusion_call_execute(FusionDev * dev, Fusionee * fusionee,
+		    FusionCallExecute * execute)
 {
-     int                  ret;
-     FusionCall          *call;
-     FusionCallExecution *execution = NULL;
-     FusionCallMessage    message;
-     unsigned int         serial;
-
-     /* Lookup and lock call. */
-     ret = fusion_call_lock( &dev->call, execute->call_id, false, &call );
-     if (ret)
-          return ret;
-
-     do {
-          serial = ++call->serial;
-     } while (!serial);
-
-     /* Add execution to receive the result. */
-     if (fusionee && !(execute->flags & FCEF_ONEWAY)) {
-          execution = add_execution (call, fusionee, execute, serial);
-          if (!execution) {
-               fusion_call_unlock (call);
-               return -ENOMEM;
-          }
-     }
-
-
-     /* Fill call message. */
-     message.handler  = call->handler;
-     message.ctx      = call->ctx;
-
-     message.caller   = fusionee ? fusionee_id( fusionee ) : 0;
-
-     message.call_arg = execute->call_arg;
-     message.call_ptr = execute->call_ptr;
-
-     message.serial   = execution ? serial : 0;
-
-     /* Put message into queue of callee. */
-     ret = fusionee_send_message (dev, fusionee, call->fusion_id, FMT_CALL,
-                                  call->entry.id, 0, sizeof(message), &message, NULL, NULL, 1);
-     if (ret) {
-          if (execution) {
-               remove_execution (call, execution);
-               kfree (execution);
-          }
-          fusion_call_unlock( call );
-          return ret;
-     }
-
-     call->count++;
-
-     /* When waiting for a result... */
-     if (execution) {
-          /* Transfer held skirmishs (locks). */
-          fusion_skirmish_transfer_all( dev, call->fusion_id, fusionee_id( fusionee ), current->pid );
-
-          /* Unlock call and wait for execution result. TODO: add timeout? */
-          fusion_sleep_on( &execution->wait, &call->entry.lock, 0 );
-
-          if (signal_pending(current)) {
-               /* Indicate that a signal was received and execution won't be freed by caller. */
-               execution->caller = NULL;
-               return -EINTR;
-          }
-
-          /* Return result to calling process. */
-          execute->ret_val = execution->ret_val;
-
-          /* Free execution, which has already been removed by callee. */
-          kfree( execution );
-
-          /* Reclaim skirmishs. */
-          fusion_skirmish_reclaim_all( dev, current->pid );
-     }
-     else
-          /* Unlock call. */
-          fusion_call_unlock( call );
-
-     return 0;
+	int ret;
+	FusionCall *call;
+	FusionCallExecution *execution = NULL;
+	FusionCallMessage message;
+	unsigned int serial;
+
+	/* Lookup and lock call. */
+	ret = fusion_call_lock(&dev->call, execute->call_id, false, &call);
+	if (ret)
+		return ret;
+
+	do {
+		serial = ++call->serial;
+	} while (!serial);
+
+	/* Add execution to receive the result. */
+	if (fusionee && !(execute->flags & FCEF_ONEWAY)) {
+		execution = add_execution(call, fusionee, execute, serial);
+		if (!execution) {
+			fusion_call_unlock(call);
+			return -ENOMEM;
+		}
+	}
+
+	/* Fill call message. */
+	message.handler = call->handler;
+	message.ctx = call->ctx;
+
+	message.caller = fusionee ? fusionee_id(fusionee) : 0;
+
+	message.call_arg = execute->call_arg;
+	message.call_ptr = execute->call_ptr;
+
+	message.serial = execution ? serial : 0;
+
+	/* Put message into queue of callee. */
+	ret = fusionee_send_message(dev, fusionee, call->fusion_id, FMT_CALL,
+				    call->entry.id, 0, sizeof(message),
+				    &message, NULL, NULL, 1);
+	if (ret) {
+		if (execution) {
+			remove_execution(call, execution);
+			kfree(execution);
+		}
+		fusion_call_unlock(call);
+		return ret;
+	}
+
+	call->count++;
+
+	/* When waiting for a result... */
+	if (execution) {
+		/* Transfer held skirmishs (locks). */
+		fusion_skirmish_transfer_all(dev, call->fusion_id,
+					     fusionee_id(fusionee),
+					     current->pid);
+
+		/* Unlock call and wait for execution result. TODO: add timeout? */
+		fusion_sleep_on(&execution->wait, &call->entry.lock, 0);
+
+		if (signal_pending(current)) {
+			/* Indicate that a signal was received and execution won't be freed by caller. */
+			execution->caller = NULL;
+			return -EINTR;
+		}
+
+		/* Return result to calling process. */
+		execute->ret_val = execution->ret_val;
+
+		/* Free execution, which has already been removed by callee. */
+		kfree(execution);
+
+		/* Reclaim skirmishs. */
+		fusion_skirmish_reclaim_all(dev, current->pid);
+	} else
+		/* Unlock call. */
+		fusion_call_unlock(call);
+
+	return 0;
 }
 
 int
-fusion_call_return (FusionDev *dev, int fusion_id, FusionCallReturn *call_ret)
+fusion_call_return(FusionDev * dev, int fusion_id, FusionCallReturn * call_ret)
 {
-     int         ret;
-     FusionLink *l;
-     FusionCall *call;
-
-     if (!call_ret->serial)
-          return -EOPNOTSUPP;
-
-     /* Lookup and lock call. */
-     ret = fusion_call_lock (&dev->call, call_ret->call_id, false, &call);
-     if (ret)
-          return ret;
-
-     /* Search for execution, starting with last (oldest). */
-     l = call->last;
-     while (l) {
-          FusionCallExecution *execution = (FusionCallExecution*) l;
-
-          if (    (execution->executed)
-               || (execution->call_id != call_ret->call_id)
-               || ((dev->api.major >= 4) && (execution->serial != call_ret->serial))    ) {
-               l = l->prev;
-               continue;
-          }
-
-          /*
-           * Check if caller received a signal while waiting for the result.
-           *
-           * TODO: This is not completely solved. Restarting the system call
-           * should be possible without causing another execution.
-           */
-          FUSION_ASSUME (execution->caller != NULL);
-          if (!execution->caller) {
-               /* Remove and free execution. */
-               remove_execution( call, execution );
-               kfree( execution );
-               fusion_call_unlock( call );
-               return -EIDRM;
-          }
-
-          /* Write result to execution. */
-          execution->ret_val  = call_ret->val;
-          execution->executed = true;
-
-          /* Remove execution, freeing is up to caller. */
-          remove_execution( call, execution );
-
-          /* FIXME: Caller might still have received a signal since check above. */
-          FUSION_ASSERT( execution->caller != NULL );
-
-          /* Wake up caller. */
-          wake_up_interruptible( &execution->wait );
-
-          /* Unlock call. */
-          fusion_call_unlock( call );
-
-          return 0;
-     }
-
-     /* Unlock call. */
-     fusion_call_unlock( call );
-
-     /* DirectFB 1.0.x does not handle one-way-calls properly */
-     if (dev->api.major <= 3)
-          return 0;
-
-     return -ENOMSG;
+	int ret;
+	FusionLink *l;
+	FusionCall *call;
+
+	if (!call_ret->serial)
+		return -EOPNOTSUPP;
+
+	/* Lookup and lock call. */
+	ret = fusion_call_lock(&dev->call, call_ret->call_id, false, &call);
+	if (ret)
+		return ret;
+
+	/* Search for execution, starting with last (oldest). */
+	l = call->last;
+	while (l) {
+		FusionCallExecution *execution = (FusionCallExecution *) l;
+
+		if ((execution->executed)
+		    || (execution->call_id != call_ret->call_id)
+		    || ((dev->api.major >= 4)
+			&& (execution->serial != call_ret->serial))) {
+			l = l->prev;
+			continue;
+		}
+
+		/*
+		 * Check if caller received a signal while waiting for the result.
+		 *
+		 * TODO: This is not completely solved. Restarting the system call
+		 * should be possible without causing another execution.
+		 */
+		FUSION_ASSUME(execution->caller != NULL);
+		if (!execution->caller) {
+			/* Remove and free execution. */
+			remove_execution(call, execution);
+			kfree(execution);
+			fusion_call_unlock(call);
+			return -EIDRM;
+		}
+
+		/* Write result to execution. */
+		execution->ret_val = call_ret->val;
+		execution->executed = true;
+
+		/* Remove execution, freeing is up to caller. */
+		remove_execution(call, execution);
+
+		/* FIXME: Caller might still have received a signal since check above. */
+		FUSION_ASSERT(execution->caller != NULL);
+
+		/* Wake up caller. */
+		wake_up_interruptible(&execution->wait);
+
+		/* Unlock call. */
+		fusion_call_unlock(call);
+
+		return 0;
+	}
+
+	/* Unlock call. */
+	fusion_call_unlock(call);
+
+	/* DirectFB 1.0.x does not handle one-way-calls properly */
+	if (dev->api.major <= 3)
+		return 0;
+
+	return -ENOMSG;
 }
 
-int
-fusion_call_destroy (FusionDev *dev, int fusion_id, int call_id)
+int fusion_call_destroy(FusionDev * dev, int fusion_id, int call_id)
 {
-     int                  ret;
-     FusionCall          *call;
-     FusionCallExecution *execution;
-
-     do {
-          /* Wait for all messages being processed. */
-          ret = fusionee_wait_processing( dev, fusion_id, FMT_CALL, call_id );
-          if (ret)
-               return ret;
-
-          ret = fusion_call_lock (&dev->call, call_id, false, &call);
-          if (ret)
-               return ret;
-
-          /* Check if we own the call. */
-          if (call->fusion_id != fusion_id) {
-               fusion_call_unlock( call );
-               return -EIO;
-          }
-
-          /* If an execution is pending... */
-          execution = (FusionCallExecution *) call->executions;
-          if (execution) {
-               /* Unlock call and wait for execution. TODO: add timeout? */
-               fusion_sleep_on( &execution->wait, &call->entry.lock, 0 );
-
-               if (signal_pending(current))
-                    return -EINTR;
-          }
-     } while (execution);
-
-     fusion_entry_destroy_locked( call->entry.entries, &call->entry );
-
-     return 0;
+	int ret;
+	FusionCall *call;
+	FusionCallExecution *execution;
+
+	do {
+		/* Wait for all messages being processed. */
+		ret =
+		    fusionee_wait_processing(dev, fusion_id, FMT_CALL, call_id);
+		if (ret)
+			return ret;
+
+		ret = fusion_call_lock(&dev->call, call_id, false, &call);
+		if (ret)
+			return ret;
+
+		/* Check if we own the call. */
+		if (call->fusion_id != fusion_id) {
+			fusion_call_unlock(call);
+			return -EIO;
+		}
+
+		/* If an execution is pending... */
+		execution = (FusionCallExecution *) call->executions;
+		if (execution) {
+			/* Unlock call and wait for execution. TODO: add timeout? */
+			fusion_sleep_on(&execution->wait, &call->entry.lock, 0);
+
+			if (signal_pending(current))
+				return -EINTR;
+		}
+	} while (execution);
+
+	fusion_entry_destroy_locked(call->entry.entries, &call->entry);
+
+	return 0;
 }
 
-void
-fusion_call_destroy_all (FusionDev *dev, int fusion_id)
+void fusion_call_destroy_all(FusionDev * dev, int fusion_id)
 {
-     FusionLink *l;
+	FusionLink *l;
 
-     down (&dev->call.lock);
+	down(&dev->call.lock);
 
-     l = dev->call.list;
+	l = dev->call.list;
 
-     while (l) {
-          FusionLink *next = l->next;
-          FusionCall *call = (FusionCall *) l;
+	while (l) {
+		FusionLink *next = l->next;
+		FusionCall *call = (FusionCall *) l;
 
-          down (&call->entry.lock);
+		down(&call->entry.lock);
 
-          if (call->fusion_id == fusion_id)
-               fusion_entry_destroy_locked( call->entry.entries, &call->entry );
-          else
-               up (&call->entry.lock);
+		if (call->fusion_id == fusion_id)
+			fusion_entry_destroy_locked(call->entry.entries,
+						    &call->entry);
+		else
+			up(&call->entry.lock);
 
-          l = next;
-     }
+		l = next;
+	}
 
-     up (&dev->call.lock);
+	up(&dev->call.lock);
 }
 
-
 /******************************************************************************/
 
-
-static FusionCallExecution *
-add_execution (FusionCall        *call,
-               Fusionee          *caller,
-               FusionCallExecute *execute,
-               unsigned int       serial)
+static FusionCallExecution *add_execution(FusionCall * call,
+					  Fusionee * caller,
+					  FusionCallExecute * execute,
+					  unsigned int serial)
 {
-     FusionCallExecution *execution;
+	FusionCallExecution *execution;
 
-     /* Allocate execution. */
-     execution = kmalloc (sizeof(FusionCallExecution), GFP_KERNEL);
-     if (!execution)
-          return NULL;
+	/* Allocate execution. */
+	execution = kmalloc(sizeof(FusionCallExecution), GFP_KERNEL);
+	if (!execution)
+		return NULL;
 
-     /* Initialize execution. */
-     memset (execution, 0, sizeof(FusionCallExecution));
+	/* Initialize execution. */
+	memset(execution, 0, sizeof(FusionCallExecution));
 
-     execution->caller  = caller;
-     execution->call_id = call->entry.id;
-     execution->serial  = serial;
+	execution->caller = caller;
+	execution->call_id = call->entry.id;
+	execution->serial = serial;
 
-     init_waitqueue_head (&execution->wait);
+	init_waitqueue_head(&execution->wait);
 
-     /* Add execution. */
-     fusion_list_prepend (&call->executions, &execution->link);
+	/* Add execution. */
+	fusion_list_prepend(&call->executions, &execution->link);
 
-     if (!call->last)
-          call->last = &execution->link;
+	if (!call->last)
+		call->last = &execution->link;
 
-     return execution;
+	return execution;
 }
 
-static void
-remove_execution (FusionCall          *call,
-                  FusionCallExecution *execution)
+static void remove_execution(FusionCall * call, FusionCallExecution * execution)
 {
-     if (call->last == &execution->link)
-          call->last = execution->link.prev;
+	if (call->last == &execution->link)
+		call->last = execution->link.prev;
 
-     fusion_list_remove (&call->executions, &execution->link);
+	fusion_list_remove(&call->executions, &execution->link);
 }
 
-static void
-free_all_executions (FusionCall *call)
+static void free_all_executions(FusionCall * call)
 {
-     while (call->last) {
-          FusionCallExecution *execution = (FusionCallExecution *) call->last;
+	while (call->last) {
+		FusionCallExecution *execution =
+		    (FusionCallExecution *) call->last;
 
-          remove_execution (call, execution);
+		remove_execution(call, execution);
 
-          wake_up_interruptible_all (&execution->wait);
+		wake_up_interruptible_all(&execution->wait);
 
-          kfree (execution);
-     }
+		kfree(execution);
+	}
 }
diff --git a/drivers/char/fusion/call.h b/drivers/char/fusion/call.h
index d908c5a..9b65e5f 100644
--- a/drivers/char/fusion/call.h
+++ b/drivers/char/fusion/call.h
@@ -11,7 +11,7 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  */
- 
+
 #ifndef __FUSION__CALL_H__
 #define __FUSION__CALL_H__
 
@@ -21,32 +21,23 @@
 
 /* module init/cleanup */
 
-int  fusion_call_init   (FusionDev *dev);
-void fusion_call_deinit (FusionDev *dev);
-
+int fusion_call_init(FusionDev * dev);
+void fusion_call_deinit(FusionDev * dev);
 
 /* public API */
 
-int fusion_call_new     (FusionDev         *dev,
-                         int                fusion_id,
-                         FusionCallNew     *call);
-
-int fusion_call_execute (FusionDev         *dev,
-                         Fusionee          *fusionee, /* NULL if call is from kernel */
-                         FusionCallExecute *execute);
+int fusion_call_new(FusionDev * dev, int fusion_id, FusionCallNew * call);
 
-int fusion_call_return  (FusionDev         *dev,
-                         int                fusion_id,
-                         FusionCallReturn  *call_ret);
+int fusion_call_execute(FusionDev * dev, Fusionee * fusionee,	/* NULL if call is from kernel */
+			FusionCallExecute * execute);
 
-int fusion_call_destroy (FusionDev         *dev,
-                         int                fusion_id,
-                         int                call_id);
+int fusion_call_return(FusionDev * dev,
+		       int fusion_id, FusionCallReturn * call_ret);
 
+int fusion_call_destroy(FusionDev * dev, int fusion_id, int call_id);
 
 /* internal functions */
 
-void fusion_call_destroy_all (FusionDev *dev,
-                              int        fusion_id);
+void fusion_call_destroy_all(FusionDev * dev, int fusion_id);
 
 #endif
diff --git a/drivers/char/fusion/entries.c b/drivers/char/fusion/entries.c
index 437f75b..11edd43 100644
--- a/drivers/char/fusion/entries.c
+++ b/drivers/char/fusion/entries.c
@@ -31,471 +31,449 @@
 struct timeval now;
 
 void
-fusion_entries_init( FusionEntries    *entries,
-                     FusionEntryClass *class,
-                     void             *ctx )
+fusion_entries_init(FusionEntries * entries,
+		    FusionEntryClass * class, void *ctx)
 {
-     FUSION_ASSERT( entries != NULL );
-     FUSION_ASSERT( class != NULL );
-     FUSION_ASSERT( class->object_size >= sizeof(FusionEntry) );
+	FUSION_ASSERT(entries != NULL);
+	FUSION_ASSERT(class != NULL);
+	FUSION_ASSERT(class->object_size >= sizeof(FusionEntry));
 
-     memset( entries, 0, sizeof(FusionEntries) );
+	memset(entries, 0, sizeof(FusionEntries));
 
-     entries->class = class;
-     entries->ctx   = ctx;
+	entries->class = class;
+	entries->ctx = ctx;
 
-     init_MUTEX( &entries->lock );
+	init_MUTEX(&entries->lock);
 }
 
-void
-fusion_entries_deinit( FusionEntries *entries )
+void fusion_entries_deinit(FusionEntries * entries)
 {
-     FusionLink       *tmp;
-     FusionEntry      *entry;
-     FusionEntryClass *class;
+	FusionLink *tmp;
+	FusionEntry *entry;
+	FusionEntryClass *class;
 
-     FUSION_ASSERT( entries != NULL );
-     FUSION_ASSERT( entries->class != NULL );
+	FUSION_ASSERT(entries != NULL);
+	FUSION_ASSERT(entries->class != NULL);
 
-     class = entries->class;
+	class = entries->class;
 
-     down( &entries->lock );
+	down(&entries->lock);
 
-     fusion_list_foreach_safe (entry, tmp, entries->list) {
-          if (class->Destroy)
-               class->Destroy( entry, entries->ctx );
+	fusion_list_foreach_safe(entry, tmp, entries->list) {
+		if (class->Destroy)
+			class->Destroy(entry, entries->ctx);
 
-          kfree( entry );
-     }
+		kfree(entry);
+	}
 
-     up( &entries->lock );
+	up(&entries->lock);
 }
 
 /* reading PROC entries */
 
-static void *fusion_entries_seq_start(struct seq_file *f, loff_t *pos)
+static void *fusion_entries_seq_start(struct seq_file *f, loff_t * pos)
 {
-     int i = *pos;
+	int i = *pos;
+
+	FusionEntry *entry;
+	FusionEntries *entries;
+	FusionEntryClass *class;
 
-     FusionEntry      *entry;
-     FusionEntries    *entries;
-     FusionEntryClass *class;
+	entries = f->private;
+	entry = (void *)(entries->list);
 
-     entries = f->private;
-     entry   = (void*)(entries->list);
-     
-     while(i && entry) {
-          entry = (void*)(entry->link.next);
-          i--;
-     }
+	while (i && entry) {
+		entry = (void *)(entry->link.next);
+		i--;
+	}
 
-     FUSION_ASSERT( entries != NULL );
-     FUSION_ASSERT( entries->class != NULL );
+	FUSION_ASSERT(entries != NULL);
+	FUSION_ASSERT(entries->class != NULL);
 
-     if (down_interruptible (&entries->lock))
-          return NULL;
+	if (down_interruptible(&entries->lock))
+		return NULL;
 
-     class = entries->class;
-     if (!class->Print)
-          return NULL;
+	class = entries->class;
+	if (!class->Print)
+		return NULL;
 
-     do_gettimeofday( &now );
+	do_gettimeofday(&now);
 
-     return entry;
+	return entry;
 }
 
-static void *fusion_entries_seq_next(struct seq_file *f, void *v, loff_t *pos)
+static void *fusion_entries_seq_next(struct seq_file *f, void *v, loff_t * pos)
 {
-     FusionEntry *entry = v;
+	FusionEntry *entry = v;
 
-     (*pos)++;
-     return entry->link.next;
+	(*pos)++;
+	return entry->link.next;
 }
 
 static void fusion_entries_seq_stop(struct seq_file *f, void *v)
 {
-     FusionEntries *entries;
+	FusionEntries *entries;
 
-     entries = f->private;
-     (void)v;
- 
-     up (&entries->lock);
+	entries = f->private;
+	(void)v;
+
+	up(&entries->lock);
 }
 
-int
-fusion_entries_show(struct seq_file *p, void *v)
+int fusion_entries_show(struct seq_file *p, void *v)
 {
-     FusionEntry      *entry;
-     FusionEntryClass *class;
+	FusionEntry *entry;
+	FusionEntryClass *class;
 
-     entry = v;
+	entry = v;
 
-     class = entry->entries->class;
+	class = entry->entries->class;
 
-     if (entry->last_lock.tv_sec) {
-          int diff = ((now.tv_sec  - entry->last_lock.tv_sec) * 1000 +
-                      (now.tv_usec - entry->last_lock.tv_usec) / 1000);
+	if (entry->last_lock.tv_sec) {
+		int diff = ((now.tv_sec - entry->last_lock.tv_sec) * 1000 +
+			    (now.tv_usec - entry->last_lock.tv_usec) / 1000);
 
-          if (diff < 1000) {
-               seq_printf( p, "%3d  ms  ", diff );
-          }
-          else if (diff < 1000000) {
-               seq_printf( p, "%3d.%d s  ", diff / 1000, (diff % 1000) / 100 );
-          }
-          else {
-               diff = ( now.tv_sec  - entry->last_lock.tv_sec +
-                       (now.tv_usec - entry->last_lock.tv_usec) / 1000000);
+		if (diff < 1000) {
+			seq_printf(p, "%3d  ms  ", diff);
+		} else if (diff < 1000000) {
+			seq_printf(p, "%3d.%d s  ", diff / 1000,
+				   (diff % 1000) / 100);
+		} else {
+			diff = (now.tv_sec - entry->last_lock.tv_sec +
+				(now.tv_usec -
+				 entry->last_lock.tv_usec) / 1000000);
 
-               seq_printf( p, "%3d.%d h  ", diff / 3600, (diff % 3600) / 360 );
-          }
-     }
-     else
-          seq_printf( p, "  -.-    " );
+			seq_printf(p, "%3d.%d h  ", diff / 3600,
+				   (diff % 3600) / 360);
+		}
+	} else
+		seq_printf(p, "  -.-    ");
 
+	seq_printf(p, "(%5d) 0x%08x  ", entry->pid, entry->id);
+	seq_printf(p, "%-24s  ", entry->name[0] ? entry->name : "");
 
-     seq_printf( p, "(%5d) 0x%08x  ", entry->pid, entry->id );
-     seq_printf( p, "%-24s  ", entry->name[0] ? entry->name : "" );
+	class->Print(entry, entry->entries->ctx, p);
 
-     class->Print( entry, entry->entries->ctx, p );
-
-     return 0;
+	return 0;
 }
 
 static const struct seq_operations fusion_entries_seq_ops = {
-     .start = fusion_entries_seq_start,
-     .next  = fusion_entries_seq_next,
-     .stop  = fusion_entries_seq_stop,
-     .show  = fusion_entries_show
+	.start = fusion_entries_seq_start,
+	.next  = fusion_entries_seq_next,
+	.stop  = fusion_entries_seq_stop,
+	.show  = fusion_entries_show
 };
 
 static int fusion_entries_open(struct inode *inode, struct file *file)
 {
-        struct seq_file *sf;
-        int ret;
+	struct seq_file *sf;
+	int ret;
 
-        ret = seq_open(file, &fusion_entries_seq_ops);
-        if (ret < 0)
-                return ret;
+	ret = seq_open(file, &fusion_entries_seq_ops);
+	if (ret < 0)
+		return ret;
 
-        sf = file->private_data;
-        sf->private = PDE(inode)->data;
+	sf = file->private_data;
+	sf->private = PDE(inode)->data;
 
-        return 0;
+	return 0;
 }
 
 static const struct file_operations proc_fusion_entries_operations = {
-     .open     = fusion_entries_open,
-     .read     = seq_read,
-     .llseek   = seq_lseek,
-     .release  = seq_release,
+	.open    = fusion_entries_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release,
 };
 
-void fusion_entries_create_proc_entry( FusionDev *dev, const char *name, FusionEntries *data )
+void fusion_entries_create_proc_entry(FusionDev * dev, const char *name,
+				      FusionEntries * data)
 {
-     struct proc_dir_entry *pde;
+	struct proc_dir_entry *pde;
 
-     pde = create_proc_entry( name, 0, dev->proc_dir );
-     if (pde) {
-          pde->proc_fops = &proc_fusion_entries_operations;
-          pde->data      = data;
-     }
+	pde = create_proc_entry(name, 0, dev->proc_dir);
+	if (pde) {
+		pde->proc_fops = &proc_fusion_entries_operations;
+		pde->data = data;
+	}
 }
 
-
-
-int
-fusion_entry_create( FusionEntries *entries,
-                     int           *ret_id,
-                     void          *create_ctx )
+int fusion_entry_create(FusionEntries * entries, int *ret_id, void *create_ctx)
 {
-     int               ret;
-     FusionEntry      *entry;
-     FusionEntryClass *class;
+	int ret;
+	FusionEntry *entry;
+	FusionEntryClass *class;
 
-     FUSION_ASSERT( entries != NULL );
-     FUSION_ASSERT( entries->class != NULL );
-     FUSION_ASSERT( ret_id != NULL );
+	FUSION_ASSERT(entries != NULL);
+	FUSION_ASSERT(entries->class != NULL);
+	FUSION_ASSERT(ret_id != NULL);
 
-     class = entries->class;
+	class = entries->class;
 
-     entry = kmalloc( class->object_size, GFP_KERNEL );
-     if (!entry)
-          return -ENOMEM;
+	entry = kmalloc(class->object_size, GFP_KERNEL);
+	if (!entry)
+		return -ENOMEM;
 
-     memset( entry, 0, class->object_size );
+	memset(entry, 0, class->object_size);
 
-     if (down_interruptible( &entries->lock )) {
-          kfree( entry );
-          return -EINTR;
-     }
+	if (down_interruptible(&entries->lock)) {
+		kfree(entry);
+		return -EINTR;
+	}
 
-     entry->entries = entries;
-     entry->id      = ++entries->ids;
-     entry->pid     = current->pid;
+	entry->entries = entries;
+	entry->id = ++entries->ids;
+	entry->pid = current->pid;
 
-     init_MUTEX( &entry->lock );
+	init_MUTEX(&entry->lock);
 
-     init_waitqueue_head( &entry->wait );
+	init_waitqueue_head(&entry->wait);
 
-     if (class->Init) {
-          ret = class->Init( entry, entries->ctx, create_ctx );
-          if (ret) {
-               up( &entries->lock );
-               kfree( entry );
-               return ret;
-          }
-     }
+	if (class->Init) {
+		ret = class->Init(entry, entries->ctx, create_ctx);
+		if (ret) {
+			up(&entries->lock);
+			kfree(entry);
+			return ret;
+		}
+	}
 
-     fusion_list_prepend( &entries->list, &entry->link );
+	fusion_list_prepend(&entries->list, &entry->link);
 
-     up( &entries->lock );
+	up(&entries->lock);
 
-     *ret_id = entry->id;
+	*ret_id = entry->id;
 
-     return 0;
+	return 0;
 }
 
-int
-fusion_entry_destroy( FusionEntries  *entries,
-                      int             id )
+int fusion_entry_destroy(FusionEntries * entries, int id)
 {
-     FusionEntry      *entry;
-     FusionEntryClass *class;
+	FusionEntry *entry;
+	FusionEntryClass *class;
 
-     FUSION_ASSERT( entries != NULL );
-     FUSION_ASSERT( entries->class != NULL );
+	FUSION_ASSERT(entries != NULL);
+	FUSION_ASSERT(entries->class != NULL);
 
-     class = entries->class;
+	class = entries->class;
 
-     /* Lock entries. */
-     if (down_interruptible( &entries->lock ))
-          return -EINTR;
+	/* Lock entries. */
+	if (down_interruptible(&entries->lock))
+		return -EINTR;
 
-     /* Lookup the entry. */
-     fusion_list_foreach (entry, entries->list) {
-          if (entry->id == id)
-               break;
-     }
+	/* Lookup the entry. */
+	fusion_list_foreach(entry, entries->list) {
+		if (entry->id == id)
+			break;
+	}
 
-     /* Check if no entry was found. */
-     if (!entry) {
-          up( &entries->lock );
-          return -EINVAL;
-     }
+	/* Check if no entry was found. */
+	if (!entry) {
+		up(&entries->lock);
+		return -EINVAL;
+	}
 
-     /* Lock the entry. */
-     if (down_interruptible( &entry->lock )) {
-          up( &entries->lock );
-          return -EINTR;
-     }
+	/* Lock the entry. */
+	if (down_interruptible(&entry->lock)) {
+		up(&entries->lock);
+		return -EINTR;
+	}
 
-     /* Destroy it now. */
-     fusion_entry_destroy_locked( entries, entry );
+	/* Destroy it now. */
+	fusion_entry_destroy_locked(entries, entry);
 
-     /* Unlock entries. */
-     up( &entries->lock );
+	/* Unlock entries. */
+	up(&entries->lock);
 
-     return 0;
+	return 0;
 }
 
-void
-fusion_entry_destroy_locked( FusionEntries  *entries,
-                             FusionEntry    *entry )
+void fusion_entry_destroy_locked(FusionEntries * entries, FusionEntry * entry)
 {
-     FusionEntryClass *class;
+	FusionEntryClass *class;
 
-     FUSION_ASSERT( entries != NULL );
-     FUSION_ASSERT( entries->class != NULL );
+	FUSION_ASSERT(entries != NULL);
+	FUSION_ASSERT(entries->class != NULL);
 
-     class = entries->class;
+	class = entries->class;
 
-     /* Remove the entry from the list. */
-     fusion_list_remove( &entries->list, &entry->link );
+	/* Remove the entry from the list. */
+	fusion_list_remove(&entries->list, &entry->link);
 
-     /* Wake up any waiting process. */
-     wake_up_interruptible_all( &entry->wait );
+	/* Wake up any waiting process. */
+	wake_up_interruptible_all(&entry->wait);
 
-     /* Call the destroy function. */
-     if (class->Destroy)
-          class->Destroy( entry, entries->ctx );
+	/* Call the destroy function. */
+	if (class->Destroy)
+		class->Destroy(entry, entries->ctx);
 
-     /* Unlock the entry. */
-     up( &entry->lock );
+	/* Unlock the entry. */
+	up(&entry->lock);
 
-     /* Deallocate the entry. */
-     kfree( entry );
+	/* Deallocate the entry. */
+	kfree(entry);
 }
 
-int
-fusion_entry_set_info( FusionEntries         *entries,
-                       const FusionEntryInfo *info )
+int fusion_entry_set_info(FusionEntries * entries, const FusionEntryInfo * info)
 {
-     int          ret;
-     FusionEntry *entry;
+	int ret;
+	FusionEntry *entry;
 
-     FUSION_ASSERT( entries != NULL );
-     FUSION_ASSERT( info != NULL );
+	FUSION_ASSERT(entries != NULL);
+	FUSION_ASSERT(info != NULL);
 
-     ret = fusion_entry_lock( entries, info->id, false, &entry );
-     if (ret)
-          return ret;
+	ret = fusion_entry_lock(entries, info->id, false, &entry);
+	if (ret)
+		return ret;
 
-     snprintf( entry->name, FUSION_ENTRY_INFO_NAME_LENGTH, info->name );
+	snprintf(entry->name, FUSION_ENTRY_INFO_NAME_LENGTH, info->name);
 
-     fusion_entry_unlock( entry );
+	fusion_entry_unlock(entry);
 
-     return 0;
+	return 0;
 }
 
-int
-fusion_entry_get_info( FusionEntries   *entries,
-                       FusionEntryInfo *info )
+int fusion_entry_get_info(FusionEntries * entries, FusionEntryInfo * info)
 {
-     int          ret;
-     FusionEntry *entry;
+	int ret;
+	FusionEntry *entry;
 
-     FUSION_ASSERT( entries != NULL );
-     FUSION_ASSERT( info != NULL );
+	FUSION_ASSERT(entries != NULL);
+	FUSION_ASSERT(info != NULL);
 
-     ret = fusion_entry_lock( entries, info->id, false, &entry );
-     if (ret)
-          return ret;
+	ret = fusion_entry_lock(entries, info->id, false, &entry);
+	if (ret)
+		return ret;
 
-     snprintf( info->name, FUSION_ENTRY_INFO_NAME_LENGTH, entry->name );
+	snprintf(info->name, FUSION_ENTRY_INFO_NAME_LENGTH, entry->name);
 
-     fusion_entry_unlock( entry );
+	fusion_entry_unlock(entry);
 
-     return 0;
+	return 0;
 }
 
 int
-fusion_entry_lock( FusionEntries  *entries,
-                   int             id,
-                   bool            keep_entries_lock,
-                   FusionEntry   **ret_entry )
+fusion_entry_lock(FusionEntries * entries,
+		  int id, bool keep_entries_lock, FusionEntry ** ret_entry)
 {
-     FusionEntry *entry;
+	FusionEntry *entry;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
-     struct timespec xtime;
+	struct timespec xtime;
 #endif
 
-     FUSION_ASSERT( entries != NULL );
-     FUSION_ASSERT( ret_entry != NULL );
+	FUSION_ASSERT(entries != NULL);
+	FUSION_ASSERT(ret_entry != NULL);
 
-     /* Lock entries. */
-     if (down_interruptible( &entries->lock ))
-          return -EINTR;
+	/* Lock entries. */
+	if (down_interruptible(&entries->lock))
+		return -EINTR;
 
-     /* Lookup the entry. */
-     fusion_list_foreach (entry, entries->list) {
-          if (entry->id == id)
-               break;
-     }
+	/* Lookup the entry. */
+	fusion_list_foreach(entry, entries->list) {
+		if (entry->id == id)
+			break;
+	}
 
-     /* Check if no entry was found. */
-     if (!entry) {
-          up( &entries->lock );
-          return -EINVAL;
-     }
+	/* Check if no entry was found. */
+	if (!entry) {
+		up(&entries->lock);
+		return -EINVAL;
+	}
 
-     FUSION_ASSUME( entry->lock_pid != current->pid );
+	FUSION_ASSUME(entry->lock_pid != current->pid);
 
-     /* Move the entry to the front of all entries. */
-     fusion_list_move_to_front( &entries->list, &entry->link );
+	/* Move the entry to the front of all entries. */
+	fusion_list_move_to_front(&entries->list, &entry->link);
 
-     /* Lock the entry. */
-     if (down_interruptible( &entry->lock )) {
-          up( &entries->lock );
-          return -EINTR;
-     }
+	/* Lock the entry. */
+	if (down_interruptible(&entry->lock)) {
+		up(&entries->lock);
+		return -EINTR;
+	}
 
-     /* Mark as locked. */
-     entry->lock_pid = current->pid;
+	/* Mark as locked. */
+	entry->lock_pid = current->pid;
 
-     /* Keep timestamp, but use the slightly
-        inexact version to avoid performance impacts. */
+	/* Keep timestamp, but use the slightly
+	   inexact version to avoid performance impacts. */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0) && defined _STRUCT_TIMESPEC
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
-     xtime = current_kernel_time();
+	xtime = current_kernel_time();
 #endif
-     entry->last_lock.tv_sec = xtime.tv_sec;
-     entry->last_lock.tv_usec = xtime.tv_nsec / 1000;
+	entry->last_lock.tv_sec = xtime.tv_sec;
+	entry->last_lock.tv_usec = xtime.tv_nsec / 1000;
 #else
-     entry->last_lock = xtime;
+	entry->last_lock = xtime;
 #endif
 
-     /* Unlock entries. */
-     if (!keep_entries_lock)
-          up( &entries->lock );
+	/* Unlock entries. */
+	if (!keep_entries_lock)
+		up(&entries->lock);
 
-     /* Return the locked entry. */
-     *ret_entry = entry;
+	/* Return the locked entry. */
+	*ret_entry = entry;
 
-     return 0;
+	return 0;
 }
 
-void
-fusion_entry_unlock( FusionEntry *entry )
+void fusion_entry_unlock(FusionEntry * entry)
 {
-     FUSION_ASSERT( entry != NULL );
-     FUSION_ASSUME( entry->lock_pid == current->pid );
+	FUSION_ASSERT(entry != NULL);
+	FUSION_ASSUME(entry->lock_pid == current->pid);
 
-     entry->lock_pid = 0;
+	entry->lock_pid = 0;
 
-     /* Unlock the entry. */
-     up( &entry->lock );
+	/* Unlock the entry. */
+	up(&entry->lock);
 }
 
-int
-fusion_entry_wait( FusionEntry *entry, long *timeout )
+int fusion_entry_wait(FusionEntry * entry, long *timeout)
 {
-     int            ret;
-     int            id;
-     FusionEntries *entries;
-     FusionEntry   *entry2;
+	int ret;
+	int id;
+	FusionEntries *entries;
+	FusionEntry *entry2;
 
-     FUSION_ASSERT( entry != NULL );
-     FUSION_ASSERT( entry->entries != NULL );
-     FUSION_ASSUME( entry->lock_pid == current->pid );
+	FUSION_ASSERT(entry != NULL);
+	FUSION_ASSERT(entry->entries != NULL);
+	FUSION_ASSUME(entry->lock_pid == current->pid);
 
-     id      = entry->id;
-     entries = entry->entries;
+	id = entry->id;
+	entries = entry->entries;
 
-     entry->waiters++;
+	entry->waiters++;
 
-     entry->lock_pid = 0;
-     fusion_sleep_on( &entry->wait, &entry->lock, timeout );
+	entry->lock_pid = 0;
+	fusion_sleep_on(&entry->wait, &entry->lock, timeout);
 
-     entry->waiters--;
+	entry->waiters--;
 
-     if (signal_pending(current))
-          return -EINTR;
+	if (signal_pending(current))
+		return -EINTR;
 
-     if (timeout && !*timeout)
-          return -ETIMEDOUT;
+	if (timeout && !*timeout)
+		return -ETIMEDOUT;
 
-     ret = fusion_entry_lock( entries, id, false, &entry2 );
-     switch (ret) {
-          case -EINVAL:
-               return -EIDRM;
+	ret = fusion_entry_lock(entries, id, false, &entry2);
+	switch (ret) {
+	case -EINVAL:
+		return -EIDRM;
 
-          case 0:
-               if (entry != entry2)
-                    BUG();
-     }
+	case 0:
+		if (entry != entry2)
+			BUG();
+	}
 
-     return ret;
+	return ret;
 }
 
-void
-fusion_entry_notify( FusionEntry *entry, bool all )
+void fusion_entry_notify(FusionEntry * entry, bool all)
 {
-     FUSION_ASSERT( entry != NULL );
-     FUSION_ASSUME( entry->lock_pid == current->pid );
+	FUSION_ASSERT(entry != NULL);
+	FUSION_ASSUME(entry->lock_pid == current->pid);
 
-     if (all)
-          wake_up_interruptible_all( &entry->wait );
-     else
-          wake_up_interruptible( &entry->wait );
+	if (all)
+		wake_up_interruptible_all(&entry->wait);
+	else
+		wake_up_interruptible(&entry->wait);
 }
-
diff --git a/drivers/char/fusion/entries.h b/drivers/char/fusion/entries.h
index 1f5b455..f5d5bd2 100644
--- a/drivers/char/fusion/entries.h
+++ b/drivers/char/fusion/entries.h
@@ -21,92 +21,77 @@
 #include "types.h"
 #include "list.h"
 
-
 typedef struct __FD_FusionEntry FusionEntry;
 
-
 typedef const struct {
-     int object_size;
+	int object_size;
 
-     int  (*Init)   ( FusionEntry *entry, void *ctx, void *create_ctx );
-     void (*Destroy)( FusionEntry *entry, void *ctx );
-     void (*Print)  ( FusionEntry *entry, void *ctx, struct seq_file *p );
+	int (*Init)     (FusionEntry * entry, void *ctx, void *create_ctx);
+	void (*Destroy) (FusionEntry * entry, void *ctx);
+	void (*Print)   (FusionEntry * entry, void *ctx, struct seq_file * p);
 } FusionEntryClass;
 
-
 typedef struct {
-     FusionEntryClass  *class;
-     void              *ctx;
+	FusionEntryClass *class;
+	void *ctx;
 
-     FusionLink        *list;
-     int                ids;
-     struct semaphore   lock;
+	FusionLink *list;
+	int ids;
+	struct semaphore lock;
 } FusionEntries;
 
-
 struct __FD_FusionEntry {
-     FusionLink         link;
+	FusionLink link;
 
-     FusionEntries     *entries;
+	FusionEntries *entries;
 
-     int                id;
-     pid_t              pid;
+	int id;
+	pid_t pid;
 
-     pid_t              lock_pid;
+	pid_t lock_pid;
 
-     struct semaphore   lock;
-     wait_queue_head_t  wait;
-     int                waiters;
+	struct semaphore lock;
+	wait_queue_head_t wait;
+	int waiters;
 
-     struct timeval     last_lock;
+	struct timeval last_lock;
 
-     char               name[FUSION_ENTRY_INFO_NAME_LENGTH];
+	char name[FUSION_ENTRY_INFO_NAME_LENGTH];
 };
 
-
 /* Entries Init & DeInit */
 
-void fusion_entries_init  ( FusionEntries    *entries,
-                            FusionEntryClass *class,
-                            void             *ctx );
-
-void fusion_entries_deinit( FusionEntries    *entries );
+void fusion_entries_init(FusionEntries * entries,
+			 FusionEntryClass * class, void *ctx);
 
+void fusion_entries_deinit(FusionEntries * entries);
 
 /* '/proc' support */
 
-void fusion_entries_create_proc_entry( FusionDev *dev, const char *name, FusionEntries *data );
+void fusion_entries_create_proc_entry(FusionDev * dev, const char *name,
+				      FusionEntries * data);
 
 /* Create & Destroy */
 
-int  fusion_entry_create        ( FusionEntries  *entries,
-                                  int            *ret_id,
-                                  void           *create_ctx );
+int fusion_entry_create(FusionEntries * entries, int *ret_id, void *create_ctx);
 
-int  fusion_entry_destroy       ( FusionEntries  *entries,
-                                  int             id );
+int fusion_entry_destroy(FusionEntries * entries, int id);
 
-void fusion_entry_destroy_locked( FusionEntries  *entries,
-                                  FusionEntry    *entry );
+void fusion_entry_destroy_locked(FusionEntries * entries, FusionEntry * entry);
 
 /* Information */
 
-int  fusion_entry_set_info( FusionEntries          *entries,
-                            const FusionEntryInfo  *info );
-
-int  fusion_entry_get_info( FusionEntries          *entries,
-                            FusionEntryInfo        *info );
+int fusion_entry_set_info(FusionEntries * entries,
+			  const FusionEntryInfo * info);
 
+int fusion_entry_get_info(FusionEntries * entries, FusionEntryInfo * info);
 
 /* Lock & Unlock */
 
-int  fusion_entry_lock    ( FusionEntries    *entries,
-                            int               id,
-                            bool              keep_entries_lock,
-                            FusionEntry     **ret_entry );
-
-void fusion_entry_unlock  ( FusionEntry      *entry );
+int fusion_entry_lock(FusionEntries * entries,
+		      int id, bool keep_entries_lock, FusionEntry ** ret_entry);
 
+void fusion_entry_unlock(FusionEntry * entry);
 
 /** Wait & Notify **/
 
@@ -124,17 +109,14 @@ void fusion_entry_unlock  ( FusionEntry      *entry );
  *   -ETIMEDOUT  Timeout occured.
  *   -EINTR      A signal has been received.
  */
-int  fusion_entry_wait    ( FusionEntry      *entry,
-                            long             *timeout );
+int fusion_entry_wait(FusionEntry * entry, long *timeout);
 
 /*
  * Wake up one or all processes waiting for the entry to be notified.
  *
  * The entry has to be locked prior to calling this function.
  */
-void fusion_entry_notify  ( FusionEntry      *entry,
-                            bool              all );
-
+void fusion_entry_notify(FusionEntry * entry, bool all);
 
 #define FUSION_ENTRY_CLASS( Type, name, init_func, destroy_func, print_func )   \
                                                                                 \
@@ -176,5 +158,4 @@ void fusion_entry_notify  ( FusionEntry      *entry,
           fusion_entry_notify( (FusionEntry*) name, all );                      \
      }
 
-
 #endif
diff --git a/drivers/char/fusion/fifo.c b/drivers/char/fusion/fifo.c
index e24d433..8eeecfc 100644
--- a/drivers/char/fusion/fifo.c
+++ b/drivers/char/fusion/fifo.c
@@ -16,38 +16,36 @@
 
 #include "fifo.h"
 
-void
-fusion_fifo_put (FusionFifo *fifo, FusionLink *link)
+void fusion_fifo_put(FusionFifo * fifo, FusionLink * link)
 {
-     link->prev = fifo->last;
-     link->next = NULL;
+	link->prev = fifo->last;
+	link->next = NULL;
 
-     if (fifo->last)
-          fifo->last->next = link;
-     else
-          fifo->first = link;
+	if (fifo->last)
+		fifo->last->next = link;
+	else
+		fifo->first = link;
 
-     fifo->last = link;
+	fifo->last = link;
 
-     fifo->count++;
+	fifo->count++;
 }
 
-FusionLink *
-fusion_fifo_get (FusionFifo *fifo)
+FusionLink *fusion_fifo_get(FusionFifo * fifo)
 {
-     FusionLink *first = fifo->first;
+	FusionLink *first = fifo->first;
 
-     if (!first)
-          return NULL;
+	if (!first)
+		return NULL;
 
-     fifo->first = first->next;
+	fifo->first = first->next;
 
-     if (fifo->last == first)
-          fifo->last = NULL;
-     else
-          fifo->first->prev = NULL;
+	if (fifo->last == first)
+		fifo->last = NULL;
+	else
+		fifo->first->prev = NULL;
 
-     fifo->count--;
+	fifo->count--;
 
-     return first;
+	return first;
 }
diff --git a/drivers/char/fusion/fifo.h b/drivers/char/fusion/fifo.h
index 3fa83b9..29bfc21 100644
--- a/drivers/char/fusion/fifo.h
+++ b/drivers/char/fusion/fifo.h
@@ -19,24 +19,20 @@
 #include "list.h"
 
 typedef struct {
-     FusionLink *first;
-     FusionLink *last;
+	FusionLink *first;
+	FusionLink *last;
 
-     int         count;
+	int count;
 } FusionFifo;
 
-void        fusion_fifo_put   (FusionFifo *fifo,
-                               FusionLink *link);
+void fusion_fifo_put(FusionFifo * fifo, FusionLink * link);
 
-FusionLink *fusion_fifo_get   (FusionFifo *fifo);
+FusionLink *fusion_fifo_get(FusionFifo * fifo);
 
-
-static inline void
-fusion_fifo_reset( FusionFifo *fifo )
+static inline void fusion_fifo_reset(FusionFifo * fifo)
 {
-     fifo->count = 0;
-     fifo->first = fifo->last = NULL;
+	fifo->count = 0;
+	fifo->first = fifo->last = NULL;
 }
 
 #endif /* __FUSION__FIFO_H__ */
-
diff --git a/drivers/char/fusion/fusiondev.c b/drivers/char/fusion/fusiondev.c
index 99b1159..eb77a19 100644
--- a/drivers/char/fusion/fusiondev.c
+++ b/drivers/char/fusion/fusiondev.c
@@ -67,14 +67,14 @@ struct proc_dir_entry *proc_fusion_dir;
 
 #define NUM_MINORS 8
 
-static FusionDev  *fusion_devs[NUM_MINORS] = { 0 };
+static FusionDev *fusion_devs[NUM_MINORS] = { 0 };
 static DECLARE_MUTEX(devs_lock);
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
 static devfs_handle_t devfs_handles[NUM_MINORS];
 static inline unsigned iminor(struct inode *inode)
 {
-        return MINOR(inode->i_rdev);
+	return MINOR(inode->i_rdev);
 }
 #endif
 
@@ -90,45 +90,47 @@ static struct class_simple *fusion_class;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
 void
-fusion_sleep_on(wait_queue_head_t *q, struct semaphore *lock, signed long *timeout)
+fusion_sleep_on(wait_queue_head_t * q, struct semaphore *lock,
+		signed long *timeout)
 {
-     DEFINE_WAIT(wait);
+	DEFINE_WAIT(wait);
 
-     prepare_to_wait( q, &wait, TASK_INTERRUPTIBLE );
+	prepare_to_wait(q, &wait, TASK_INTERRUPTIBLE);
 
-     up( lock );
+	up(lock);
 
-     if (timeout)
-          *timeout = schedule_timeout(*timeout);
-     else
-          schedule();
+	if (timeout)
+		*timeout = schedule_timeout(*timeout);
+	else
+		schedule();
 
-     finish_wait( q, &wait );
+	finish_wait(q, &wait);
 }
 #else
 void
-fusion_sleep_on(wait_queue_head_t *q, struct semaphore *lock, signed long *timeout)
+fusion_sleep_on(wait_queue_head_t * q, struct semaphore *lock,
+		signed long *timeout)
 {
-     wait_queue_t wait;
+	wait_queue_t wait;
 
-     init_waitqueue_entry (&wait, current);
+	init_waitqueue_entry(&wait, current);
 
-     current->state = TASK_INTERRUPTIBLE;
+	current->state = TASK_INTERRUPTIBLE;
 
-     write_lock (&q->lock);
-     __add_wait_queue (q, &wait);
-     write_unlock (&q->lock);
+	write_lock(&q->lock);
+	__add_wait_queue(q, &wait);
+	write_unlock(&q->lock);
 
-     up (lock);
+	up(lock);
 
-     if (timeout)
-          *timeout = schedule_timeout(*timeout);
-     else
-          schedule();
+	if (timeout)
+		*timeout = schedule_timeout(*timeout);
+	else
+		schedule();
 
-     write_lock (&q->lock);
-     __remove_wait_queue (q, &wait);
-     write_unlock (&q->lock);
+	write_lock(&q->lock);
+	__remove_wait_queue(q, &wait);
+	write_unlock(&q->lock);
 }
 #endif
 
@@ -136,1120 +138,1130 @@ fusion_sleep_on(wait_queue_head_t *q, struct semaphore *lock, signed long *timeo
 
 static int
 fusiondev_stat_read_proc(char *buf, char **start, off_t offset,
-                         int len, int *eof, void *private)
+			 int len, int *eof, void *private)
 {
-     FusionDev *dev     = private;
-     int        written = 0;
-
-     if ( (dev->api.major != 0) || (dev->api.minor != 0) )
-          written += sprintf( buf, "Fusion API:%d.%d\n", dev->api.major, dev->api.minor );
-     
-     written += snprintf( buf + written, offset + len - written,
-                          "lease/purchase   cede      attach     detach   dispatch      "
-                          "ref up   ref down  prevail/swoop dismiss\n" );
-     if (written < offset) {
-          offset -= written;
-          written = 0;
-     }
-
-     if (written < len) {
-          written += snprintf( buf+written, offset + len - written,
-                               "%10d %10d  %10d %10d %10d  %10d %10d  %10d %10d\n",
-                               dev->stat.property_lease_purchase,
-                               dev->stat.property_cede,
-                               dev->stat.reactor_attach,
-                               dev->stat.reactor_detach,
-                               dev->stat.reactor_dispatch,
-                               dev->stat.ref_up,
-                               dev->stat.ref_down,
-                               dev->stat.skirmish_prevail_swoop,
-                               dev->stat.skirmish_dismiss );
-          if (written < offset) {
-               offset -= written;
-               written = 0;
-          }
-     }
-
-     *start = buf + offset;
-     written -= offset;
-     if (written > len) {
-          *eof = 0;
-          return len;
-     }
-
-     *eof = 1;
-     return(written<0) ? 0 : written;
+	FusionDev *dev = private;
+	int written = 0;
+
+	if ((dev->api.major != 0) || (dev->api.minor != 0))
+		written +=
+		    sprintf(buf, "Fusion API:%d.%d\n", dev->api.major,
+			    dev->api.minor);
+
+	written += snprintf(buf + written, offset + len - written,
+			    "lease/purchase   cede      attach     detach   dispatch      "
+			    "ref up   ref down  prevail/swoop dismiss\n");
+	if (written < offset) {
+		offset -= written;
+		written = 0;
+	}
+
+	if (written < len) {
+		written += snprintf(buf + written, offset + len - written,
+				    "%10d %10d  %10d %10d %10d  %10d %10d  %10d %10d\n",
+				    dev->stat.property_lease_purchase,
+				    dev->stat.property_cede,
+				    dev->stat.reactor_attach,
+				    dev->stat.reactor_detach,
+				    dev->stat.reactor_dispatch,
+				    dev->stat.ref_up,
+				    dev->stat.ref_down,
+				    dev->stat.skirmish_prevail_swoop,
+				    dev->stat.skirmish_dismiss);
+		if (written < offset) {
+			offset -= written;
+			written = 0;
+		}
+	}
+
+	*start = buf + offset;
+	written -= offset;
+	if (written > len) {
+		*eof = 0;
+		return len;
+	}
+
+	*eof = 1;
+	return (written < 0) ? 0 : written;
 }
 
 /******************************************************************************/
 
-static int
-fusiondev_init (FusionDev *dev)
+static int fusiondev_init(FusionDev * dev)
 {
-     int ret;
-
-     init_MUTEX( &dev->enter_lock );
-     init_waitqueue_head( &dev->enter_wait );
+	int ret;
 
-     ret = fusionee_init (dev);
-     if (ret)
-          goto error_fusionee;
+	init_MUTEX(&dev->enter_lock);
+	init_waitqueue_head(&dev->enter_wait);
 
-     ret = fusion_ref_init (dev);
-     if (ret)
-          goto error_ref;
+	ret = fusionee_init(dev);
+	if (ret)
+		goto error_fusionee;
 
-     ret = fusion_skirmish_init (dev);
-     if (ret)
-          goto error_skirmish;
+	ret = fusion_ref_init(dev);
+	if (ret)
+		goto error_ref;
 
-     ret = fusion_property_init (dev);
-     if (ret)
-          goto error_property;
+	ret = fusion_skirmish_init(dev);
+	if (ret)
+		goto error_skirmish;
 
-     ret = fusion_reactor_init (dev);
-     if (ret)
-          goto error_reactor;
+	ret = fusion_property_init(dev);
+	if (ret)
+		goto error_property;
 
-     ret = fusion_shmpool_init (dev);
-     if (ret)
-          goto error_shmpool;
+	ret = fusion_reactor_init(dev);
+	if (ret)
+		goto error_reactor;
 
-     ret = fusion_call_init (dev);
-     if (ret)
-          goto error_call;
+	ret = fusion_shmpool_init(dev);
+	if (ret)
+		goto error_shmpool;
 
-     create_proc_read_entry( "stat", 0, dev->proc_dir,
-                             fusiondev_stat_read_proc, dev );
+	ret = fusion_call_init(dev);
+	if (ret)
+		goto error_call;
 
-     return 0;
+	create_proc_read_entry("stat", 0, dev->proc_dir,
+			       fusiondev_stat_read_proc, dev);
 
+	return 0;
 
-error_call:
-     fusion_shmpool_deinit (dev);
+      error_call:
+	fusion_shmpool_deinit(dev);
 
-error_shmpool:
-     fusion_reactor_deinit (dev);
+      error_shmpool:
+	fusion_reactor_deinit(dev);
 
-error_reactor:
-     fusion_property_deinit (dev);
+      error_reactor:
+	fusion_property_deinit(dev);
 
-error_property:
-     fusion_skirmish_deinit (dev);
+      error_property:
+	fusion_skirmish_deinit(dev);
 
-error_skirmish:
-     fusion_ref_deinit (dev);
+      error_skirmish:
+	fusion_ref_deinit(dev);
 
-error_ref:
-     fusionee_deinit (dev);
+      error_ref:
+	fusionee_deinit(dev);
 
-error_fusionee:
-     return ret;
+      error_fusionee:
+	return ret;
 }
 
-static void
-fusiondev_deinit (FusionDev *dev)
+static void fusiondev_deinit(FusionDev * dev)
 {
-     remove_proc_entry ("stat", dev->proc_dir);
-
-     fusion_call_deinit (dev);
-     fusion_shmpool_deinit (dev);
-     fusion_reactor_deinit (dev);
-     fusion_property_deinit (dev);
-     fusion_skirmish_deinit (dev);
-     fusion_ref_deinit (dev);
-     fusionee_deinit (dev);
-
-     if (dev->shared_area) {
-          ClearPageReserved( virt_to_page(dev->shared_area) );
-          free_page( dev->shared_area );
-     }
+	remove_proc_entry("stat", dev->proc_dir);
+
+	fusion_call_deinit(dev);
+	fusion_shmpool_deinit(dev);
+	fusion_reactor_deinit(dev);
+	fusion_property_deinit(dev);
+	fusion_skirmish_deinit(dev);
+	fusion_ref_deinit(dev);
+	fusionee_deinit(dev);
+
+	if (dev->shared_area) {
+		ClearPageReserved(virt_to_page(dev->shared_area));
+		free_page(dev->shared_area);
+	}
 }
 
 /******************************************************************************/
 
-static int
-fusion_open (struct inode *inode, struct file *file)
+static int fusion_open(struct inode *inode, struct file *file)
 {
-     int       ret;
-     Fusionee *fusionee;
-     int       minor = iminor(inode);
+	int ret;
+	Fusionee *fusionee;
+	int minor = iminor(inode);
 
-     DEBUG( "fusion_open( %p, %d )\n", file, atomic_read(&file->f_count) );
+	DEBUG("fusion_open( %p, %d )\n", file, atomic_read(&file->f_count));
 
-     if (down_interruptible (&devs_lock))
-          return -EINTR;
+	if (down_interruptible(&devs_lock))
+		return -EINTR;
 
-     if (!fusion_devs[minor]) {
-          char buf[4];
+	if (!fusion_devs[minor]) {
+		char buf[4];
 
-          fusion_devs[minor] = kmalloc (sizeof(FusionDev), GFP_KERNEL);
-          if (!fusion_devs[minor]) {
-               up (&devs_lock);
-               return -ENOMEM;
-          }
+		fusion_devs[minor] = kmalloc(sizeof(FusionDev), GFP_KERNEL);
+		if (!fusion_devs[minor]) {
+			up(&devs_lock);
+			return -ENOMEM;
+		}
 
-          memset (fusion_devs[minor], 0, sizeof(FusionDev));
+		memset(fusion_devs[minor], 0, sizeof(FusionDev));
 
-          snprintf (buf, 4, "%d", minor);
+		snprintf(buf, 4, "%d", minor);
 
-          fusion_devs[minor]->proc_dir = proc_mkdir (buf, proc_fusion_dir);
-          fusion_devs[minor]->index    = minor;
+		fusion_devs[minor]->proc_dir = proc_mkdir(buf, proc_fusion_dir);
+		fusion_devs[minor]->index = minor;
 
-          ret = fusiondev_init (fusion_devs[minor]);
-          if (ret) {
-               remove_proc_entry (buf, proc_fusion_dir);
+		ret = fusiondev_init(fusion_devs[minor]);
+		if (ret) {
+			remove_proc_entry(buf, proc_fusion_dir);
 
-               kfree (fusion_devs[minor]);
-               fusion_devs[minor] = NULL;
+			kfree(fusion_devs[minor]);
+			fusion_devs[minor] = NULL;
 
-               up (&devs_lock);
+			up(&devs_lock);
 
-               return ret;
-          }
-     }
-     else if (file->f_flags & O_EXCL) {
-          if (fusion_devs[minor]->fusionee.last_id) {
-               up (&devs_lock);
-               return -EBUSY;
-          }
-     }
+			return ret;
+		}
+	} else if (file->f_flags & O_EXCL) {
+		if (fusion_devs[minor]->fusionee.last_id) {
+			up(&devs_lock);
+			return -EBUSY;
+		}
+	}
 
-     ret = fusionee_new (fusion_devs[minor], !!(file->f_flags & O_APPEND), &fusionee);
-     if (ret) {
-          if (!fusion_devs[minor]->refs) {
-               fusiondev_deinit (fusion_devs[minor]);
+	ret =
+	    fusionee_new(fusion_devs[minor], !!(file->f_flags & O_APPEND),
+			 &fusionee);
+	if (ret) {
+		if (!fusion_devs[minor]->refs) {
+			fusiondev_deinit(fusion_devs[minor]);
 
-               remove_proc_entry (fusion_devs[minor]->proc_dir->name,
-                                  proc_fusion_dir);
+			remove_proc_entry(fusion_devs[minor]->proc_dir->name,
+					  proc_fusion_dir);
 
-               kfree (fusion_devs[minor]);
-               fusion_devs[minor] = NULL;
-          }
+			kfree(fusion_devs[minor]);
+			fusion_devs[minor] = NULL;
+		}
 
-          up (&devs_lock);
+		up(&devs_lock);
 
-          return ret;
-     }
+		return ret;
+	}
 
-     fusion_devs[minor]->refs++;
+	fusion_devs[minor]->refs++;
 
-     up (&devs_lock);
+	up(&devs_lock);
 
+	file->private_data = fusionee;
 
-     file->private_data = fusionee;
-
-     return 0;
+	return 0;
 }
 
-static int
-fusion_release (struct inode *inode, struct file *file)
+static int fusion_release(struct inode *inode, struct file *file)
 {
-     int       minor    = iminor(inode);
-     Fusionee *fusionee = file->private_data;
+	int minor = iminor(inode);
+	Fusionee *fusionee = file->private_data;
 
-     DEBUG( "fusion_release( %p, %d )\n", file, atomic_read(&file->f_count) );
+	DEBUG("fusion_release( %p, %d )\n", file, atomic_read(&file->f_count));
 
-     fusionee_destroy (fusion_devs[minor], fusionee);
+	fusionee_destroy(fusion_devs[minor], fusionee);
 
-     down (&devs_lock);
+	down(&devs_lock);
 
-     if (! --fusion_devs[minor]->refs) {
-          fusiondev_deinit (fusion_devs[minor]);
+	if (!--fusion_devs[minor]->refs) {
+		fusiondev_deinit(fusion_devs[minor]);
 
-          remove_proc_entry (fusion_devs[minor]->proc_dir->name,
-                             proc_fusion_dir);
+		remove_proc_entry(fusion_devs[minor]->proc_dir->name,
+				  proc_fusion_dir);
 
-          kfree (fusion_devs[minor]);
-          fusion_devs[minor] = NULL;
-     }
+		kfree(fusion_devs[minor]);
+		fusion_devs[minor] = NULL;
+	}
 
-     up (&devs_lock);
+	up(&devs_lock);
 
-     return 0;
+	return 0;
 }
 
 static int
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
-fusion_flush (struct file *file, fl_owner_t id)
+fusion_flush(struct file *file, fl_owner_t id)
 #else
-fusion_flush (struct file *file)
+fusion_flush(struct file *file)
 #endif
 {
-     Fusionee  *fusionee = file->private_data;
-     FusionDev *dev      = fusion_devs[iminor(file->f_dentry->d_inode)];
+	Fusionee *fusionee = file->private_data;
+	FusionDev *dev = fusion_devs[iminor(file->f_dentry->d_inode)];
 
-     (void) fusionee;
+	(void)fusionee;
 
-     DEBUG( "fusion_flush( %p, %d, 0x%08x %d )\n", file, atomic_read(&file->f_count), fusionee_id(fusionee), current->pid );
+	DEBUG("fusion_flush( %p, %d, 0x%08x %d )\n", file,
+	      atomic_read(&file->f_count), fusionee_id(fusionee), current->pid);
 
-     if (current->flags & PF_EXITING)
-          fusion_skirmish_dismiss_all_from_pid (dev, current->pid);
+	if (current->flags & PF_EXITING)
+		fusion_skirmish_dismiss_all_from_pid(dev, current->pid);
 
-     return 0;
+	return 0;
 }
 
 static ssize_t
-fusion_read (struct file *file, char *buf, size_t count, loff_t *ppos)
+fusion_read(struct file *file, char *buf, size_t count, loff_t * ppos)
 {
-     Fusionee  *fusionee = file->private_data;
-     FusionDev *dev      = fusion_devs[iminor(file->f_dentry->d_inode)];
+	Fusionee *fusionee = file->private_data;
+	FusionDev *dev = fusion_devs[iminor(file->f_dentry->d_inode)];
 
-     DEBUG( "fusion_read( %p, %d, %d )\n", file, atomic_read(&file->f_count), count );
+	DEBUG("fusion_read( %p, %d, %d )\n", file, atomic_read(&file->f_count),
+	      count);
 
-     return fusionee_get_messages (dev, fusionee, buf, count,
-                                   !(file->f_flags & O_NONBLOCK));
+	return fusionee_get_messages(dev, fusionee, buf, count,
+				     !(file->f_flags & O_NONBLOCK));
 }
 
-static unsigned int
-fusion_poll (struct file *file, poll_table * wait)
+static unsigned int fusion_poll(struct file *file, poll_table * wait)
 {
-     Fusionee  *fusionee = file->private_data;
-     FusionDev *dev      = fusion_devs[iminor(file->f_dentry->d_inode)];
+	Fusionee *fusionee = file->private_data;
+	FusionDev *dev = fusion_devs[iminor(file->f_dentry->d_inode)];
 
-     DEBUG( "fusion_poll( %p, %d )\n", file, atomic_read(&file->f_count) );
+	DEBUG("fusion_poll( %p, %d )\n", file, atomic_read(&file->f_count));
 
-     return fusionee_poll (dev, fusionee, file, wait);
+	return fusionee_poll(dev, fusionee, file, wait);
 }
 
 static int
-lounge_ioctl (struct file *file, FusionDev *dev, Fusionee *fusionee,
-              unsigned int cmd, unsigned long arg)
+lounge_ioctl(struct file *file, FusionDev * dev, Fusionee * fusionee,
+	     unsigned int cmd, unsigned long arg)
 {
-     int             ret;
-     FusionEnter     enter;
-     FusionKill      kill;
-     FusionEntryInfo info;
-     FusionFork      fork = {0};
+	int ret;
+	FusionEnter enter;
+	FusionKill kill;
+	FusionEntryInfo info;
+	FusionFork fork = { 0 };
 
-     switch (_IOC_NR(cmd)) {
-          case _IOC_NR(FUSION_ENTER):
-               if (copy_from_user (&enter, (FusionEnter*) arg, sizeof(enter)))
-                    return -EFAULT;
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(FUSION_ENTER):
+		if (copy_from_user(&enter, (FusionEnter *) arg, sizeof(enter)))
+			return -EFAULT;
 
-               ret = fusionee_enter( dev, &enter, fusionee );
-               if (ret)
-                    return ret;
+		ret = fusionee_enter(dev, &enter, fusionee);
+		if (ret)
+			return ret;
 
-               if (copy_to_user ((FusionEnter*) arg, &enter, sizeof(enter)))
-                    return -EFAULT;
+		if (copy_to_user((FusionEnter *) arg, &enter, sizeof(enter)))
+			return -EFAULT;
 
-               return 0;
+		return 0;
 
-          case _IOC_NR(FUSION_UNBLOCK):
-               if (fusionee_id( fusionee ) != FUSION_ID_MASTER)
-                    return -EPERM;
+	case _IOC_NR(FUSION_UNBLOCK):
+		if (fusionee_id(fusionee) != FUSION_ID_MASTER)
+			return -EPERM;
 
-               if (down_interruptible( &dev->enter_lock ))
-                    return -EINTR;
+		if (down_interruptible(&dev->enter_lock))
+			return -EINTR;
 
-               dev->enter_ok = 1;
+		dev->enter_ok = 1;
 
-               wake_up_interruptible_all( &dev->enter_wait );
+		wake_up_interruptible_all(&dev->enter_wait);
 
-               up( &dev->enter_lock );
+		up(&dev->enter_lock);
 
-               return 0;
+		return 0;
 
-          case _IOC_NR(FUSION_KILL):
-               if (copy_from_user (&kill, (FusionKill*) arg, sizeof(kill)))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_KILL):
+		if (copy_from_user(&kill, (FusionKill *) arg, sizeof(kill)))
+			return -EFAULT;
 
-               return fusionee_kill (dev, fusionee,
-                                     kill.fusion_id, kill.signal, kill.timeout_ms);
+		return fusionee_kill(dev, fusionee,
+				     kill.fusion_id, kill.signal,
+				     kill.timeout_ms);
 
-          case _IOC_NR(FUSION_ENTRY_SET_INFO):
-               if (copy_from_user (&info, (FusionEntryInfo*) arg, sizeof(info)))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_ENTRY_SET_INFO):
+		if (copy_from_user
+		    (&info, (FusionEntryInfo *) arg, sizeof(info)))
+			return -EFAULT;
 
-               switch (info.type) {
-                    case FT_SKIRMISH:
-                         return fusion_entry_set_info (&dev->skirmish, &info);
+		switch (info.type) {
+		case FT_SKIRMISH:
+			return fusion_entry_set_info(&dev->skirmish, &info);
 
-                    case FT_PROPERTY:
-                         return fusion_entry_set_info (&dev->properties, &info);
+		case FT_PROPERTY:
+			return fusion_entry_set_info(&dev->properties, &info);
 
-                    case FT_REACTOR:
-                         return fusion_entry_set_info (&dev->reactor, &info);
+		case FT_REACTOR:
+			return fusion_entry_set_info(&dev->reactor, &info);
 
-                    case FT_REF:
-                         return fusion_entry_set_info (&dev->ref, &info);
+		case FT_REF:
+			return fusion_entry_set_info(&dev->ref, &info);
 
-                    case FT_SHMPOOL:
-                         return fusion_entry_set_info (&dev->shmpool, &info);
+		case FT_SHMPOOL:
+			return fusion_entry_set_info(&dev->shmpool, &info);
 
-                    default:
-                         return -ENOSYS;
-               }
+		default:
+			return -ENOSYS;
+		}
 
-          case _IOC_NR(FUSION_ENTRY_GET_INFO):
-               if (copy_from_user (&info, (FusionEntryInfo*) arg, sizeof(info)))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_ENTRY_GET_INFO):
+		if (copy_from_user
+		    (&info, (FusionEntryInfo *) arg, sizeof(info)))
+			return -EFAULT;
 
-               switch (info.type) {
-                    case FT_SKIRMISH:
-                         ret = fusion_entry_get_info (&dev->skirmish, &info);
-                         break;
+		switch (info.type) {
+		case FT_SKIRMISH:
+			ret = fusion_entry_get_info(&dev->skirmish, &info);
+			break;
 
-                    case FT_PROPERTY:
-                         ret = fusion_entry_get_info (&dev->properties, &info);
-                         break;
+		case FT_PROPERTY:
+			ret = fusion_entry_get_info(&dev->properties, &info);
+			break;
 
-                    case FT_REACTOR:
-                         ret = fusion_entry_get_info (&dev->reactor, &info);
-                         break;
+		case FT_REACTOR:
+			ret = fusion_entry_get_info(&dev->reactor, &info);
+			break;
 
-                    case FT_REF:
-                         ret = fusion_entry_get_info (&dev->ref, &info);
-                         break;
+		case FT_REF:
+			ret = fusion_entry_get_info(&dev->ref, &info);
+			break;
 
-                    case FT_SHMPOOL:
-                         ret = fusion_entry_get_info (&dev->shmpool, &info);
-                         break;
+		case FT_SHMPOOL:
+			ret = fusion_entry_get_info(&dev->shmpool, &info);
+			break;
 
-                    default:
-                         return -ENOSYS;
-               }
+		default:
+			return -ENOSYS;
+		}
 
-               if (ret)
-                    return ret;
+		if (ret)
+			return ret;
 
-               if (copy_to_user ((FusionEntryInfo*) arg, &info, sizeof(info)))
-                    return -EFAULT;
+		if (copy_to_user((FusionEntryInfo *) arg, &info, sizeof(info)))
+			return -EFAULT;
 
-               return 0;
+		return 0;
 
-          case _IOC_NR(FUSION_FORK):
-               if (copy_from_user( &fork, (FusionFork*) arg, sizeof(fork) ))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_FORK):
+		if (copy_from_user(&fork, (FusionFork *) arg, sizeof(fork)))
+			return -EFAULT;
 
-               ret = fusionee_fork( dev, &fork, fusionee );
-               if (ret)
-                    return ret;
+		ret = fusionee_fork(dev, &fork, fusionee);
+		if (ret)
+			return ret;
 
-               if (copy_to_user( (FusionFork*) arg, &fork, sizeof(fork) ))
-                    return -EFAULT;
+		if (copy_to_user((FusionFork *) arg, &fork, sizeof(fork)))
+			return -EFAULT;
 
-               return 0;
-     }
+		return 0;
+	}
 
-     return -ENOSYS;
+	return -ENOSYS;
 }
 
 static int
-messaging_ioctl (FusionDev *dev, Fusionee *fusionee,
-                 unsigned int cmd, unsigned long arg)
+messaging_ioctl(FusionDev * dev, Fusionee * fusionee,
+		unsigned int cmd, unsigned long arg)
 {
-     FusionSendMessage send;
+	FusionSendMessage send;
 
-     switch (_IOC_NR(cmd)) {
-          case _IOC_NR(FUSION_SEND_MESSAGE):
-               if (copy_from_user (&send, (FusionSendMessage*) arg, sizeof(send)))
-                    return -EFAULT;
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(FUSION_SEND_MESSAGE):
+		if (copy_from_user
+		    (&send, (FusionSendMessage *) arg, sizeof(send)))
+			return -EFAULT;
 
-               if (send.msg_size <= 0)
-                    return -EINVAL;
+		if (send.msg_size <= 0)
+			return -EINVAL;
 
-               /* message data > 64k should be stored in shared memory */
-               if (send.msg_size > 0x10000)
-                    return -EMSGSIZE;
+		/* message data > 64k should be stored in shared memory */
+		if (send.msg_size > 0x10000)
+			return -EMSGSIZE;
 
-               return fusionee_send_message (dev, fusionee, send.fusion_id, FMT_SEND,
-                                             send.msg_id, send.msg_channel, send.msg_size, send.msg_data,
-                                             NULL, NULL, 0);
-     }
+		return fusionee_send_message(dev, fusionee, send.fusion_id,
+					     FMT_SEND, send.msg_id,
+					     send.msg_channel, send.msg_size,
+					     send.msg_data, NULL, NULL, 0);
+	}
 
-     return -ENOSYS;
+	return -ENOSYS;
 }
 
 static int
-call_ioctl (FusionDev *dev, Fusionee *fusionee,
-            unsigned int cmd, unsigned long arg)
+call_ioctl(FusionDev * dev, Fusionee * fusionee,
+	   unsigned int cmd, unsigned long arg)
 {
-     int               id;
-     int               ret;
-     FusionCallNew     call;
-     FusionCallExecute execute;
-     FusionCallReturn  call_ret;
-     FusionID          fusion_id = fusionee_id( fusionee );
-
-     switch (_IOC_NR(cmd)) {
-          case _IOC_NR(FUSION_CALL_NEW):
-               if (copy_from_user (&call, (FusionCallNew*) arg, sizeof(call)))
-                    return -EFAULT;
-
-               ret = fusion_call_new (dev, fusion_id, &call);
-               if (ret)
-                    return ret;
-
-               if (put_user (call.call_id, (int*) arg)) {
-                    fusion_call_destroy (dev, fusion_id, call.call_id);
-                    return -EFAULT;
-               }
-               return 0;
-
-          case _IOC_NR(FUSION_CALL_EXECUTE):
-               if (copy_from_user (&execute, (FusionCallExecute*) arg, sizeof(execute)))
-                    return -EFAULT;
-
-               ret = fusion_call_execute (dev, fusionee, &execute);
-               if (ret)
-                    return ret;
-
-               if (put_user (execute.ret_val, (int*) arg))
-                    return -EFAULT;
-               return 0;
-
-          case _IOC_NR(FUSION_CALL_RETURN):
-               if (copy_from_user (&call_ret, (FusionCallReturn*) arg, sizeof(call_ret)))
-                    return -EFAULT;
-
-               return fusion_call_return (dev, fusion_id, &call_ret);
-
-          case _IOC_NR(FUSION_CALL_DESTROY):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
-
-               return fusion_call_destroy (dev, fusion_id, id);
-     }
-
-     return -ENOSYS;
+	int id;
+	int ret;
+	FusionCallNew call;
+	FusionCallExecute execute;
+	FusionCallReturn call_ret;
+	FusionID fusion_id = fusionee_id(fusionee);
+
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(FUSION_CALL_NEW):
+		if (copy_from_user(&call, (FusionCallNew *) arg, sizeof(call)))
+			return -EFAULT;
+
+		ret = fusion_call_new(dev, fusion_id, &call);
+		if (ret)
+			return ret;
+
+		if (put_user(call.call_id, (int *)arg)) {
+			fusion_call_destroy(dev, fusion_id, call.call_id);
+			return -EFAULT;
+		}
+		return 0;
+
+	case _IOC_NR(FUSION_CALL_EXECUTE):
+		if (copy_from_user
+		    (&execute, (FusionCallExecute *) arg, sizeof(execute)))
+			return -EFAULT;
+
+		ret = fusion_call_execute(dev, fusionee, &execute);
+		if (ret)
+			return ret;
+
+		if (put_user(execute.ret_val, (int *)arg))
+			return -EFAULT;
+		return 0;
+
+	case _IOC_NR(FUSION_CALL_RETURN):
+		if (copy_from_user
+		    (&call_ret, (FusionCallReturn *) arg, sizeof(call_ret)))
+			return -EFAULT;
+
+		return fusion_call_return(dev, fusion_id, &call_ret);
+
+	case _IOC_NR(FUSION_CALL_DESTROY):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
+
+		return fusion_call_destroy(dev, fusion_id, id);
+	}
+
+	return -ENOSYS;
 }
 
 static int
-ref_ioctl (FusionDev *dev, Fusionee *fusionee,
-           unsigned int cmd, unsigned long arg)
+ref_ioctl(FusionDev * dev, Fusionee * fusionee,
+	  unsigned int cmd, unsigned long arg)
 {
-     int              id;
-     int              ret;
-     int              refs;
-     FusionRefWatch   watch;
-     FusionRefInherit inherit;
-     FusionID         fusion_id = fusionee_id( fusionee );
+	int id;
+	int ret;
+	int refs;
+	FusionRefWatch watch;
+	FusionRefInherit inherit;
+	FusionID fusion_id = fusionee_id(fusionee);
 
-     switch (_IOC_NR(cmd)) {
-          case _IOC_NR(FUSION_REF_NEW):
-               ret = fusion_ref_new (dev, &id);
-               if (ret)
-                    return ret;
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(FUSION_REF_NEW):
+		ret = fusion_ref_new(dev, &id);
+		if (ret)
+			return ret;
 
-               if (put_user (id, (int*) arg)) {
-                    fusion_ref_destroy (dev, id);
-                    return -EFAULT;
-               }
-               return 0;
+		if (put_user(id, (int *)arg)) {
+			fusion_ref_destroy(dev, id);
+			return -EFAULT;
+		}
+		return 0;
 
-          case _IOC_NR(FUSION_REF_UP):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_REF_UP):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_ref_up (dev, id, fusion_id);
+		return fusion_ref_up(dev, id, fusion_id);
 
-          case _IOC_NR(FUSION_REF_UP_GLOBAL):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_REF_UP_GLOBAL):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_ref_up (dev, id, 0);
+		return fusion_ref_up(dev, id, 0);
 
-          case _IOC_NR(FUSION_REF_DOWN):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_REF_DOWN):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_ref_down (dev, id, fusion_id);
+		return fusion_ref_down(dev, id, fusion_id);
 
-          case _IOC_NR(FUSION_REF_DOWN_GLOBAL):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_REF_DOWN_GLOBAL):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_ref_down (dev, id, 0);
+		return fusion_ref_down(dev, id, 0);
 
-          case _IOC_NR(FUSION_REF_ZERO_LOCK):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_REF_ZERO_LOCK):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_ref_zero_lock (dev, id, fusion_id);
+		return fusion_ref_zero_lock(dev, id, fusion_id);
 
-          case _IOC_NR(FUSION_REF_ZERO_TRYLOCK):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_REF_ZERO_TRYLOCK):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_ref_zero_trylock (dev, id, fusion_id);
+		return fusion_ref_zero_trylock(dev, id, fusion_id);
 
-          case _IOC_NR(FUSION_REF_UNLOCK):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_REF_UNLOCK):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_ref_zero_unlock (dev, id, fusion_id);
+		return fusion_ref_zero_unlock(dev, id, fusion_id);
 
-          case _IOC_NR(FUSION_REF_STAT):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_REF_STAT):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               ret = fusion_ref_stat (dev, id, &refs);
-               if (ret)
-                    return ret;
+		ret = fusion_ref_stat(dev, id, &refs);
+		if (ret)
+			return ret;
 
-               return refs;
+		return refs;
 
-          case _IOC_NR(FUSION_REF_WATCH):
-               if (copy_from_user (&watch, (FusionRefWatch*) arg, sizeof(watch)))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_REF_WATCH):
+		if (copy_from_user
+		    (&watch, (FusionRefWatch *) arg, sizeof(watch)))
+			return -EFAULT;
 
-               return fusion_ref_watch (dev, watch.id, watch.call_id, watch.call_arg);
+		return fusion_ref_watch(dev, watch.id, watch.call_id,
+					watch.call_arg);
 
-          case _IOC_NR(FUSION_REF_INHERIT):
-               if (copy_from_user (&inherit, (FusionRefInherit*) arg, sizeof(inherit)))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_REF_INHERIT):
+		if (copy_from_user
+		    (&inherit, (FusionRefInherit *) arg, sizeof(inherit)))
+			return -EFAULT;
 
-               return fusion_ref_inherit (dev, inherit.id, inherit.from);
+		return fusion_ref_inherit(dev, inherit.id, inherit.from);
 
-          case _IOC_NR(FUSION_REF_DESTROY):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_REF_DESTROY):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_ref_destroy (dev, id);
-     }
+		return fusion_ref_destroy(dev, id);
+	}
 
-     return -ENOSYS;
+	return -ENOSYS;
 }
 
 static int
-skirmish_ioctl (FusionDev *dev, Fusionee *fusionee,
-                unsigned int cmd, unsigned long arg)
+skirmish_ioctl(FusionDev * dev, Fusionee * fusionee,
+	       unsigned int cmd, unsigned long arg)
 {
-     int                id;
-     int                ret;
-     int                lock_count;
-     FusionSkirmishWait wait;
-     FusionID           fusion_id = fusionee_id( fusionee );
+	int id;
+	int ret;
+	int lock_count;
+	FusionSkirmishWait wait;
+	FusionID fusion_id = fusionee_id(fusionee);
 
-     switch (_IOC_NR(cmd)) {
-          case _IOC_NR(FUSION_SKIRMISH_NEW):
-               ret = fusion_skirmish_new (dev, &id);
-               if (ret)
-                    return ret;
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(FUSION_SKIRMISH_NEW):
+		ret = fusion_skirmish_new(dev, &id);
+		if (ret)
+			return ret;
 
-               if (put_user (id, (int*) arg)) {
-                    fusion_skirmish_destroy (dev, id);
-                    return -EFAULT;
-               }
-               return 0;
+		if (put_user(id, (int *)arg)) {
+			fusion_skirmish_destroy(dev, id);
+			return -EFAULT;
+		}
+		return 0;
 
-          case _IOC_NR(FUSION_SKIRMISH_PREVAIL):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_SKIRMISH_PREVAIL):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_skirmish_prevail (dev, id, fusion_id);
+		return fusion_skirmish_prevail(dev, id, fusion_id);
 
-          case _IOC_NR(FUSION_SKIRMISH_SWOOP):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_SKIRMISH_SWOOP):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_skirmish_swoop (dev, id, fusion_id);
+		return fusion_skirmish_swoop(dev, id, fusion_id);
 
-          case _IOC_NR(FUSION_SKIRMISH_DISMISS):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_SKIRMISH_DISMISS):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_skirmish_dismiss (dev, id, fusion_id);
+		return fusion_skirmish_dismiss(dev, id, fusion_id);
 
-          case _IOC_NR(FUSION_SKIRMISH_DESTROY):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_SKIRMISH_DESTROY):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_skirmish_destroy (dev, id);
+		return fusion_skirmish_destroy(dev, id);
 
-          case _IOC_NR(FUSION_SKIRMISH_LOCK_COUNT):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_SKIRMISH_LOCK_COUNT):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               ret = fusion_skirmish_lock_count (dev, id, fusion_id, &lock_count);
-               if (put_user(lock_count, ((int*)arg)+1))
-                    return -EFAULT;
+		ret =
+		    fusion_skirmish_lock_count(dev, id, fusion_id, &lock_count);
+		if (put_user(lock_count, ((int *)arg) + 1))
+			return -EFAULT;
 
-               return ret;
+		return ret;
 
-          case _IOC_NR(FUSION_SKIRMISH_WAIT):
-               if (copy_from_user (&wait, (FusionSkirmishWait*) arg, sizeof(wait)))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_SKIRMISH_WAIT):
+		if (copy_from_user
+		    (&wait, (FusionSkirmishWait *) arg, sizeof(wait)))
+			return -EFAULT;
 
-               ret = fusion_skirmish_wait_ (dev, &wait, fusion_id);
-               if (copy_to_user ((FusionSkirmishWait*) arg, &wait, sizeof(wait)))
-                    return -EFAULT;
+		ret = fusion_skirmish_wait_(dev, &wait, fusion_id);
+		if (copy_to_user
+		    ((FusionSkirmishWait *) arg, &wait, sizeof(wait)))
+			return -EFAULT;
 
-               return ret;
+		return ret;
 
-          case _IOC_NR(FUSION_SKIRMISH_NOTIFY):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_SKIRMISH_NOTIFY):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_skirmish_notify_ (dev, id, fusion_id);
-     }
+		return fusion_skirmish_notify_(dev, id, fusion_id);
+	}
 
-     return -ENOSYS;
+	return -ENOSYS;
 }
 
 static int
-property_ioctl (FusionDev *dev, Fusionee *fusionee,
-                unsigned int cmd, unsigned long arg)
+property_ioctl(FusionDev * dev, Fusionee * fusionee,
+	       unsigned int cmd, unsigned long arg)
 {
-     int      id;
-     int      ret;
-     FusionID fusion_id = fusionee_id( fusionee );
+	int id;
+	int ret;
+	FusionID fusion_id = fusionee_id(fusionee);
 
-     switch (_IOC_NR(cmd)) {
-          case _IOC_NR(FUSION_PROPERTY_NEW):
-               ret = fusion_property_new (dev, &id);
-               if (ret)
-                    return ret;
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(FUSION_PROPERTY_NEW):
+		ret = fusion_property_new(dev, &id);
+		if (ret)
+			return ret;
 
-               if (put_user (id, (int*) arg)) {
-                    fusion_property_destroy (dev, id);
-                    return -EFAULT;
-               }
-               return 0;
+		if (put_user(id, (int *)arg)) {
+			fusion_property_destroy(dev, id);
+			return -EFAULT;
+		}
+		return 0;
 
-          case _IOC_NR(FUSION_PROPERTY_LEASE):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_PROPERTY_LEASE):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_property_lease (dev, id, fusion_id);
+		return fusion_property_lease(dev, id, fusion_id);
 
-          case _IOC_NR(FUSION_PROPERTY_PURCHASE):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_PROPERTY_PURCHASE):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_property_purchase (dev, id, fusion_id);
+		return fusion_property_purchase(dev, id, fusion_id);
 
-          case _IOC_NR(FUSION_PROPERTY_CEDE):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_PROPERTY_CEDE):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_property_cede (dev, id, fusion_id);
+		return fusion_property_cede(dev, id, fusion_id);
 
-          case _IOC_NR(FUSION_PROPERTY_HOLDUP):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_PROPERTY_HOLDUP):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_property_holdup (dev, id, fusionee);
+		return fusion_property_holdup(dev, id, fusionee);
 
-          case _IOC_NR(FUSION_PROPERTY_DESTROY):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_PROPERTY_DESTROY):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_property_destroy (dev, id);
-     }
+		return fusion_property_destroy(dev, id);
+	}
 
-     return -ENOSYS;
+	return -ENOSYS;
 }
 
 static int
-reactor_ioctl (FusionDev *dev, Fusionee *fusionee,
-               unsigned int cmd, unsigned long arg)
+reactor_ioctl(FusionDev * dev, Fusionee * fusionee,
+	      unsigned int cmd, unsigned long arg)
 {
-     int                      id;
-     int                      ret;
-     FusionReactorAttach      attach;
-     FusionReactorDetach      detach;
-     FusionReactorDispatch    dispatch;
-     FusionReactorSetCallback callback;
-     FusionID                 fusion_id = fusionee_id( fusionee );
-
-     switch (_IOC_NR(cmd)) {
-          case _IOC_NR(FUSION_REACTOR_NEW):
-               ret = fusion_reactor_new (dev, &id);
-               if (ret)
-                    return ret;
-
-               if (put_user (id, (int*) arg)) {
-                    fusion_reactor_destroy (dev, id);
-                    return -EFAULT;
-               }
-               return 0;
-
-          case _IOC_NR(FUSION_REACTOR_ATTACH):
-               if (dev->api.major <= 4) {
-                    if (get_user (id, (int*) arg))
-                         return -EFAULT;
-
-                    attach.reactor_id = id;
-                    attach.channel    = 0;
-               }
-               else {
-                    if (copy_from_user (&attach,
-                                       (FusionReactorAttach*) arg, sizeof(attach)))
-                         return -EFAULT;
-               }
-
-               return fusion_reactor_attach (dev, attach.reactor_id, attach.channel, fusion_id);
-
-          case _IOC_NR(FUSION_REACTOR_DETACH):
-               if (dev->api.major <= 4) {
-                    if (get_user (id, (int*) arg))
-                         return -EFAULT;
-
-                    detach.reactor_id = id;
-                    detach.channel    = 0;
-               }
-               else {
-                    if (copy_from_user (&detach,
-                                       (FusionReactorDetach*) arg, sizeof(detach)))
-                         return -EFAULT;
-               }
-
-               return fusion_reactor_detach (dev, detach.reactor_id, detach.channel, fusion_id);
-
-          case _IOC_NR(FUSION_REACTOR_DISPATCH):
-               if (copy_from_user (&dispatch,
-                                   (FusionReactorDispatch*) arg, sizeof(dispatch)))
-                    return -EFAULT;
-
-               if (dispatch.msg_size <= 0)
-                    return -EINVAL;
-
-               /* message data > 64k should be stored in shared memory */
-               if (dispatch.msg_size > 0x10000)
-                    return -EMSGSIZE;
-
-               if (dev->api.major <= 4)
-                    dispatch.channel = 0;
-
-               return fusion_reactor_dispatch (dev, dispatch.reactor_id, dispatch.channel,
-                                               dispatch.self ? NULL : fusionee,
-                                               dispatch.msg_size, dispatch.msg_data);
-
-          case _IOC_NR(FUSION_REACTOR_DESTROY):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
-
-               return fusion_reactor_destroy (dev, id);
-
-          case _IOC_NR(FUSION_REACTOR_SET_DISPATCH_CALLBACK):
-               if (copy_from_user (&callback,
-                                   (FusionReactorSetCallback*) arg, sizeof(callback)))
-                    return -EFAULT;
-
-               return fusion_reactor_set_dispatch_callback (dev, callback.reactor_id,
-                                                            callback.call_id, callback.call_ptr);
-     }
-
-     return -ENOSYS;
+	int id;
+	int ret;
+	FusionReactorAttach attach;
+	FusionReactorDetach detach;
+	FusionReactorDispatch dispatch;
+	FusionReactorSetCallback callback;
+	FusionID fusion_id = fusionee_id(fusionee);
+
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(FUSION_REACTOR_NEW):
+		ret = fusion_reactor_new(dev, &id);
+		if (ret)
+			return ret;
+
+		if (put_user(id, (int *)arg)) {
+			fusion_reactor_destroy(dev, id);
+			return -EFAULT;
+		}
+		return 0;
+
+	case _IOC_NR(FUSION_REACTOR_ATTACH):
+		if (dev->api.major <= 4) {
+			if (get_user(id, (int *)arg))
+				return -EFAULT;
+
+			attach.reactor_id = id;
+			attach.channel = 0;
+		} else {
+			if (copy_from_user(&attach,
+					   (FusionReactorAttach *) arg,
+					   sizeof(attach)))
+				return -EFAULT;
+		}
+
+		return fusion_reactor_attach(dev, attach.reactor_id,
+					     attach.channel, fusion_id);
+
+	case _IOC_NR(FUSION_REACTOR_DETACH):
+		if (dev->api.major <= 4) {
+			if (get_user(id, (int *)arg))
+				return -EFAULT;
+
+			detach.reactor_id = id;
+			detach.channel = 0;
+		} else {
+			if (copy_from_user(&detach,
+					   (FusionReactorDetach *) arg,
+					   sizeof(detach)))
+				return -EFAULT;
+		}
+
+		return fusion_reactor_detach(dev, detach.reactor_id,
+					     detach.channel, fusion_id);
+
+	case _IOC_NR(FUSION_REACTOR_DISPATCH):
+		if (copy_from_user(&dispatch,
+				   (FusionReactorDispatch *) arg,
+				   sizeof(dispatch)))
+			return -EFAULT;
+
+		if (dispatch.msg_size <= 0)
+			return -EINVAL;
+
+		/* message data > 64k should be stored in shared memory */
+		if (dispatch.msg_size > 0x10000)
+			return -EMSGSIZE;
+
+		if (dev->api.major <= 4)
+			dispatch.channel = 0;
+
+		return fusion_reactor_dispatch(dev, dispatch.reactor_id,
+					       dispatch.channel,
+					       dispatch.self ? NULL : fusionee,
+					       dispatch.msg_size,
+					       dispatch.msg_data);
+
+	case _IOC_NR(FUSION_REACTOR_DESTROY):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
+
+		return fusion_reactor_destroy(dev, id);
+
+	case _IOC_NR(FUSION_REACTOR_SET_DISPATCH_CALLBACK):
+		if (copy_from_user(&callback,
+				   (FusionReactorSetCallback *) arg,
+				   sizeof(callback)))
+			return -EFAULT;
+
+		return fusion_reactor_set_dispatch_callback(dev,
+							    callback.reactor_id,
+							    callback.call_id,
+							    callback.call_ptr);
+	}
+
+	return -ENOSYS;
 }
 
 static int
-shmpool_ioctl (FusionDev *dev, Fusionee *fusionee,
-               unsigned int cmd, unsigned long arg)
+shmpool_ioctl(FusionDev * dev, Fusionee * fusionee,
+	      unsigned int cmd, unsigned long arg)
 {
-     int                   id;
-     int                   ret;
-     FusionSHMPoolNew      pool;
-     FusionSHMPoolAttach   attach;
-     FusionSHMPoolDispatch dispatch;
-     FusionID              fusion_id = fusionee_id( fusionee );
+	int id;
+	int ret;
+	FusionSHMPoolNew pool;
+	FusionSHMPoolAttach attach;
+	FusionSHMPoolDispatch dispatch;
+	FusionID fusion_id = fusionee_id(fusionee);
 
-     switch (_IOC_NR(cmd)) {
-          case _IOC_NR(FUSION_SHMPOOL_NEW):
-               if (copy_from_user (&pool, (FusionSHMPoolNew*) arg, sizeof(pool)))
-                    return -EFAULT;
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(FUSION_SHMPOOL_NEW):
+		if (copy_from_user
+		    (&pool, (FusionSHMPoolNew *) arg, sizeof(pool)))
+			return -EFAULT;
 
-               ret = fusion_shmpool_new (dev, &pool);
-               if (ret)
-                    return ret;
+		ret = fusion_shmpool_new(dev, &pool);
+		if (ret)
+			return ret;
 
-               if (copy_to_user ((FusionSHMPoolNew*) arg, &pool, sizeof(pool))) {
-                    fusion_shmpool_destroy (dev, pool.pool_id);
-                    return -EFAULT;
-               }
+		if (copy_to_user((FusionSHMPoolNew *) arg, &pool, sizeof(pool))) {
+			fusion_shmpool_destroy(dev, pool.pool_id);
+			return -EFAULT;
+		}
 
-               return 0;
+		return 0;
 
-          case _IOC_NR(FUSION_SHMPOOL_ATTACH):
-               if (copy_from_user (&attach,
-                                   (FusionSHMPoolAttach*) arg, sizeof(attach)))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_SHMPOOL_ATTACH):
+		if (copy_from_user(&attach,
+				   (FusionSHMPoolAttach *) arg, sizeof(attach)))
+			return -EFAULT;
 
-               ret = fusion_shmpool_attach (dev, &attach, fusion_id);
-               if (ret)
-                    return ret;
+		ret = fusion_shmpool_attach(dev, &attach, fusion_id);
+		if (ret)
+			return ret;
 
-               if (copy_to_user ((FusionSHMPoolAttach*) arg, &attach, sizeof(attach))) {
-                    fusion_shmpool_detach (dev, attach.pool_id, fusion_id);
-                    return -EFAULT;
-               }
+		if (copy_to_user
+		    ((FusionSHMPoolAttach *) arg, &attach, sizeof(attach))) {
+			fusion_shmpool_detach(dev, attach.pool_id, fusion_id);
+			return -EFAULT;
+		}
 
-               return 0;
+		return 0;
 
-          case _IOC_NR(FUSION_SHMPOOL_DETACH):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_SHMPOOL_DETACH):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_shmpool_detach (dev, id, fusion_id);
+		return fusion_shmpool_detach(dev, id, fusion_id);
 
-          case _IOC_NR(FUSION_SHMPOOL_DISPATCH):
-               if (copy_from_user (&dispatch,
-                                   (FusionSHMPoolDispatch*) arg, sizeof(dispatch)))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_SHMPOOL_DISPATCH):
+		if (copy_from_user(&dispatch,
+				   (FusionSHMPoolDispatch *) arg,
+				   sizeof(dispatch)))
+			return -EFAULT;
 
-               return fusion_shmpool_dispatch (dev, &dispatch, fusionee);
+		return fusion_shmpool_dispatch(dev, &dispatch, fusionee);
 
-          case _IOC_NR(FUSION_SHMPOOL_DESTROY):
-               if (get_user (id, (int*) arg))
-                    return -EFAULT;
+	case _IOC_NR(FUSION_SHMPOOL_DESTROY):
+		if (get_user(id, (int *)arg))
+			return -EFAULT;
 
-               return fusion_shmpool_destroy (dev, id);
-     }
+		return fusion_shmpool_destroy(dev, id);
+	}
 
-     return -ENOSYS;
+	return -ENOSYS;
 }
 
 static int
-fusion_ioctl (struct inode *inode, struct file *file,
-              unsigned int cmd, unsigned long arg)
+fusion_ioctl(struct inode *inode, struct file *file,
+	     unsigned int cmd, unsigned long arg)
 {
-     Fusionee  *fusionee = file->private_data;
-     FusionDev *dev      = fusion_devs[iminor(inode)];
+	Fusionee *fusionee = file->private_data;
+	FusionDev *dev = fusion_devs[iminor(inode)];
 
-     DEBUG( "fusion_ioctl (0x%08x)\n", cmd );
+	DEBUG("fusion_ioctl (0x%08x)\n", cmd);
 
-     switch (_IOC_TYPE(cmd)) {
-          case FT_LOUNGE:
-               return lounge_ioctl( file, dev, fusionee, cmd, arg );
+	switch (_IOC_TYPE(cmd)) {
+	case FT_LOUNGE:
+		return lounge_ioctl(file, dev, fusionee, cmd, arg);
 
-          case FT_MESSAGING:
-               return messaging_ioctl( dev, fusionee, cmd, arg );
+	case FT_MESSAGING:
+		return messaging_ioctl(dev, fusionee, cmd, arg);
 
-          case FT_CALL:
-               return call_ioctl( dev, fusionee, cmd, arg );
+	case FT_CALL:
+		return call_ioctl(dev, fusionee, cmd, arg);
 
-          case FT_REF:
-               return ref_ioctl( dev, fusionee, cmd, arg );
+	case FT_REF:
+		return ref_ioctl(dev, fusionee, cmd, arg);
 
-          case FT_SKIRMISH:
-               return skirmish_ioctl( dev, fusionee, cmd, arg );
+	case FT_SKIRMISH:
+		return skirmish_ioctl(dev, fusionee, cmd, arg);
 
-          case FT_PROPERTY:
-               return property_ioctl( dev, fusionee, cmd, arg );
+	case FT_PROPERTY:
+		return property_ioctl(dev, fusionee, cmd, arg);
 
-          case FT_REACTOR:
-               return reactor_ioctl( dev, fusionee, cmd, arg );
+	case FT_REACTOR:
+		return reactor_ioctl(dev, fusionee, cmd, arg);
 
-          case FT_SHMPOOL:
-               return shmpool_ioctl( dev, fusionee, cmd, arg );
-     }
+	case FT_SHMPOOL:
+		return shmpool_ioctl(dev, fusionee, cmd, arg);
+	}
 
-     return -ENOSYS;
+	return -ENOSYS;
 }
 
-static int
-fusion_mmap( struct file           *file,
-             struct vm_area_struct *vma )
+static int fusion_mmap(struct file *file, struct vm_area_struct *vma)
 {
-     Fusionee     *fusionee = file->private_data;
-     FusionDev    *dev      = fusion_devs[iminor(file->f_dentry->d_inode)];
-     unsigned int  size;
-
-     if (vma->vm_pgoff != 0)
-          return -EINVAL;
+	Fusionee *fusionee = file->private_data;
+	FusionDev *dev = fusion_devs[iminor(file->f_dentry->d_inode)];
+	unsigned int size;
 
-     size = vma->vm_end - vma->vm_start;
-     if (!size || size > PAGE_SIZE)
-          return -EINVAL;
+	if (vma->vm_pgoff != 0)
+		return -EINVAL;
 
-     if (!dev->shared_area) {
-          if (fusionee_id( fusionee ) != FUSION_ID_MASTER)
-               return -EPERM;
+	size = vma->vm_end - vma->vm_start;
+	if (!size || size > PAGE_SIZE)
+		return -EINVAL;
 
-          dev->shared_area = get_zeroed_page( GFP_KERNEL );
-          if (!dev->shared_area)
-               return -ENOMEM;
+	if (!dev->shared_area) {
+		if (fusionee_id(fusionee) != FUSION_ID_MASTER)
+			return -EPERM;
 
-          SetPageReserved( virt_to_page(dev->shared_area) );
-     }
+		dev->shared_area = get_zeroed_page(GFP_KERNEL);
+		if (!dev->shared_area)
+			return -ENOMEM;
 
+		SetPageReserved(virt_to_page(dev->shared_area));
+	}
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
-     return remap_pfn_range( vma, vma->vm_start,
-                             virt_to_phys((void*)dev->shared_area) >> PAGE_SHIFT,
-                             PAGE_SIZE, vma->vm_page_prot );
+	return remap_pfn_range(vma, vma->vm_start,
+			       virt_to_phys((void *)dev->
+					    shared_area) >> PAGE_SHIFT,
+			       PAGE_SIZE, vma->vm_page_prot);
 #else
-     return io_remap_page_range( vma->vm_start,
-                                 virt_to_phys((void*)dev->shared_area),
-                                 PAGE_SIZE, vma->vm_page_prot );
+	return io_remap_page_range(vma->vm_start,
+				   virt_to_phys((void *)dev->shared_area),
+				   PAGE_SIZE, vma->vm_page_prot);
 #endif
 }
 
 static struct file_operations fusion_fops = {
-     .owner   = THIS_MODULE,
-     .open    = fusion_open,
-     .flush   = fusion_flush,
-     .release = fusion_release,
-     .read    = fusion_read,
-     .poll    = fusion_poll,
-     .ioctl   = fusion_ioctl,
-     .mmap    = fusion_mmap
+	.owner = THIS_MODULE,
+	.open = fusion_open,
+	.flush = fusion_flush,
+	.release = fusion_release,
+	.read = fusion_read,
+	.poll = fusion_poll,
+	.ioctl = fusion_ioctl,
+	.mmap = fusion_mmap
 };
 
 /******************************************************************************/
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
-static int __init
-register_devices(void)
+static int __init register_devices(void)
 {
-     int  i;
-
-     if (register_chrdev (FUSION_MAJOR, "fusion", &fusion_fops)) {
-          printk (KERN_ERR "fusion: unable to get major %d\n", FUSION_MAJOR);
-          return -EIO;
-     }
+	int i;
 
+	if (register_chrdev(FUSION_MAJOR, "fusion", &fusion_fops)) {
+		printk(KERN_ERR "fusion: unable to get major %d\n",
+		       FUSION_MAJOR);
+		return -EIO;
+	}
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
-     fusion_class = class_create (THIS_MODULE, "fusion");
+	fusion_class = class_create(THIS_MODULE, "fusion");
 #else
-     fusion_class = class_simple_create (THIS_MODULE, "fusion");
+	fusion_class = class_simple_create(THIS_MODULE, "fusion");
 #endif
-     if (IS_ERR(fusion_class)) {
-          unregister_chrdev (FUSION_MAJOR, "fusion");
-          return PTR_ERR(fusion_class);
-     }
+	if (IS_ERR(fusion_class)) {
+		unregister_chrdev(FUSION_MAJOR, "fusion");
+		return PTR_ERR(fusion_class);
+	}
 #endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
-     devfs_mk_dir("fusion");
+	devfs_mk_dir("fusion");
 #endif
 
-     for (i=0; i<NUM_MINORS; i++) {
+	for (i = 0; i < NUM_MINORS; i++) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
-          device_create (fusion_class,
-                         NULL,
-                         MKDEV(FUSION_MAJOR, i),
-                         NULL, "fusion%d", i);
+		device_create(fusion_class,
+			      NULL,
+			      MKDEV(FUSION_MAJOR, i), NULL, "fusion%d", i);
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
-          device_create (fusion_class,
-                         NULL,
-                         MKDEV(FUSION_MAJOR, i),
-                         "fusion%d", i);
+		device_create(fusion_class,
+			      NULL, MKDEV(FUSION_MAJOR, i), "fusion%d", i);
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 15)
-          class_device_create (fusion_class,
-                               NULL,
-                               MKDEV(FUSION_MAJOR, i),
-                               NULL, "fusion%d", i);
+		class_device_create(fusion_class,
+				    NULL,
+				    MKDEV(FUSION_MAJOR, i),
+				    NULL, "fusion%d", i);
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
-          class_device_create (fusion_class,
-                               MKDEV(FUSION_MAJOR, i),
-                               NULL, "fusion%d", i);
+		class_device_create(fusion_class,
+				    MKDEV(FUSION_MAJOR, i),
+				    NULL, "fusion%d", i);
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
-          class_simple_device_add (fusion_class,
-                                   MKDEV(FUSION_MAJOR, i),
-                                   NULL, "fusion%d", i);
+		class_simple_device_add(fusion_class,
+					MKDEV(FUSION_MAJOR, i),
+					NULL, "fusion%d", i);
 #endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
-          devfs_mk_cdev (MKDEV(FUSION_MAJOR, i),
-                         S_IFCHR | S_IRUSR | S_IWUSR,
-                         "fusion/%d", i);
+		devfs_mk_cdev(MKDEV(FUSION_MAJOR, i),
+			      S_IFCHR | S_IRUSR | S_IWUSR, "fusion/%d", i);
 #endif
-     }
+	}
 
-     return 0;
+	return 0;
 }
 #else
-static int __init
-register_devices(void)
+static int __init register_devices(void)
 {
-     int  i;
-     char buf[16];
+	int i;
+	char buf[16];
 
-     if (devfs_register_chrdev (FUSION_MAJOR, "fusion", &fusion_fops)) {
-          printk (KERN_ERR "fusion: unable to get major %d\n", FUSION_MAJOR);
-          return -EIO;
-     }
+	if (devfs_register_chrdev(FUSION_MAJOR, "fusion", &fusion_fops)) {
+		printk(KERN_ERR "fusion: unable to get major %d\n",
+		       FUSION_MAJOR);
+		return -EIO;
+	}
 
-     for (i=0; i<NUM_MINORS; i++) {
-          snprintf (buf, 16, "fusion/%d", i);
+	for (i = 0; i < NUM_MINORS; i++) {
+		snprintf(buf, 16, "fusion/%d", i);
 
-          devfs_handles[i] = devfs_register (NULL, buf, DEVFS_FL_DEFAULT,
-                                             FUSION_MAJOR, i,
-                                             S_IFCHR | S_IRUSR | S_IWUSR,
-                                             &fusion_fops, NULL);
-     }
+		devfs_handles[i] = devfs_register(NULL, buf, DEVFS_FL_DEFAULT,
+						  FUSION_MAJOR, i,
+						  S_IFCHR | S_IRUSR | S_IWUSR,
+						  &fusion_fops, NULL);
+	}
 
-     return 0;
+	return 0;
 }
 #endif
 
-int __init
-fusion_init(void)
+int __init fusion_init(void)
 {
-     int ret;
+	int ret;
 
-     ret = register_devices();
-     if (ret)
-          return ret;
+	ret = register_devices();
+	if (ret)
+		return ret;
 
-     proc_fusion_dir = proc_mkdir ("fusion", NULL);
+	proc_fusion_dir = proc_mkdir("fusion", NULL);
 
-     return 0;
+	return 0;
 }
 
 /******************************************************************************/
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
-static void __exit
-deregister_devices(void)
+static void __exit deregister_devices(void)
 {
-     int i;
+	int i;
 
-     unregister_chrdev (FUSION_MAJOR, "fusion");
+	unregister_chrdev(FUSION_MAJOR, "fusion");
 
-     for (i=0; i<NUM_MINORS; i++) {
+	for (i = 0; i < NUM_MINORS; i++) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
-          device_destroy (fusion_class, MKDEV(FUSION_MAJOR, i));
+		device_destroy(fusion_class, MKDEV(FUSION_MAJOR, i));
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
-          class_device_destroy (fusion_class, MKDEV(FUSION_MAJOR, i));
+		class_device_destroy(fusion_class, MKDEV(FUSION_MAJOR, i));
 #else
-          class_simple_device_remove (MKDEV(FUSION_MAJOR, i));
+		class_simple_device_remove(MKDEV(FUSION_MAJOR, i));
 #endif
 #endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
-          devfs_remove ("fusion/%d", i);
+		devfs_remove("fusion/%d", i);
 #endif
-     }
+	}
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
-     class_destroy (fusion_class);
+	class_destroy(fusion_class);
 #else
-     class_simple_destroy (fusion_class);
+	class_simple_destroy(fusion_class);
 #endif
 #endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
-     devfs_remove ("fusion");
+	devfs_remove("fusion");
 #endif
 }
 #else
-static void __exit
-deregister_devices(void)
+static void __exit deregister_devices(void)
 {
-     int i;
+	int i;
 
-     devfs_unregister_chrdev (FUSION_MAJOR, "fusion");
+	devfs_unregister_chrdev(FUSION_MAJOR, "fusion");
 
-     for (i=0; i<NUM_MINORS; i++)
-          devfs_unregister (devfs_handles[i]);
+	for (i = 0; i < NUM_MINORS; i++)
+		devfs_unregister(devfs_handles[i]);
 }
 #endif
 
-void __exit
-fusion_exit(void)
+void __exit fusion_exit(void)
 {
-     deregister_devices();
+	deregister_devices();
 
-     remove_proc_entry ("fusion", NULL);
+	remove_proc_entry("fusion", NULL);
 }
 
 module_init(fusion_init);
 module_exit(fusion_exit);
-
diff --git a/drivers/char/fusion/fusiondev.h b/drivers/char/fusion/fusiondev.h
index 2ae5e8b..b840ba1 100644
--- a/drivers/char/fusion/fusiondev.h
+++ b/drivers/char/fusion/fusiondev.h
@@ -12,8 +12,8 @@
  *	2 of the License, or (at your option) any later version.
  */
 
-#ifndef __FUSIONDEV_H__
-#define __FUSIONDEV_H__
+#ifndef __FUSION__FUSIONDEV_H__
+#define __FUSION__FUSIONDEV_H__
 
 #include <linux/proc_fs.h>
 
@@ -24,62 +24,61 @@
 #define FUSION_ASSUME(exp)    do { if (!(exp)) printk( KERN_ERR "fusiondev: assumption '" #exp "' failed!\n" ); } while (0)
 
 struct __Fusion_FusionDev {
-     int                    refs;
-     int                    index;
-     struct {
-          int               major;
-          int               minor;
-     } api;
-
-     struct semaphore       enter_lock;
-     int                    enter_ok;
-     wait_queue_head_t      enter_wait;
-
-     unsigned long          shared_area;
-
-     struct proc_dir_entry *proc_dir;
-
-     struct {
-          int property_lease_purchase;
-          int property_cede;
-
-          int reactor_attach;
-          int reactor_detach;
-          int reactor_dispatch;
-
-          int ref_up;
-          int ref_down;
-
-          int skirmish_prevail_swoop;
-          int skirmish_dismiss;
-          int skirmish_wait;
-          int skirmish_notify;
-
-          int shmpool_attach;
-          int shmpool_detach;
-     } stat;
-
-     struct {
-          int                last_id;
-          FusionLink        *list;
-          struct semaphore   lock;
-          wait_queue_head_t  wait;
-     } fusionee;
-
-     FusionEntries  call;
-     FusionEntries  properties;
-     FusionEntries  reactor;
-     FusionEntries  ref;
-     FusionEntries  shmpool;
-     FusionEntries  skirmish;
+	int refs;
+	int index;
+	struct {
+		int major;
+		int minor;
+	} api;
+
+	struct semaphore enter_lock;
+	int enter_ok;
+	wait_queue_head_t enter_wait;
+
+	unsigned long shared_area;
+
+	struct proc_dir_entry *proc_dir;
+
+	struct {
+		int property_lease_purchase;
+		int property_cede;
+
+		int reactor_attach;
+		int reactor_detach;
+		int reactor_dispatch;
+
+		int ref_up;
+		int ref_down;
+
+		int skirmish_prevail_swoop;
+		int skirmish_dismiss;
+		int skirmish_wait;
+		int skirmish_notify;
+
+		int shmpool_attach;
+		int shmpool_detach;
+	} stat;
+
+	struct {
+		int last_id;
+		FusionLink *list;
+		struct semaphore lock;
+		wait_queue_head_t wait;
+	} fusionee;
+
+	FusionEntries call;
+	FusionEntries properties;
+	FusionEntries reactor;
+	FusionEntries ref;
+	FusionEntries shmpool;
+	FusionEntries skirmish;
 };
 
 /*
  * Special version of interruptible_sleep_on() that unlocks the mutex
  * after adding the entry to the queue (just before schedule).
  */
-void fusion_sleep_on (wait_queue_head_t *q,
-                      struct semaphore  *lock,
-                      signed long       *timeout_ms);
+void fusion_sleep_on(wait_queue_head_t * q,
+		     struct semaphore *lock, signed long *timeout_ms);
 
 #endif
diff --git a/drivers/char/fusion/fusionee.c b/drivers/char/fusion/fusionee.c
index f8e361b..afdee51 100644
--- a/drivers/char/fusion/fusionee.c
+++ b/drivers/char/fusion/fusionee.c
@@ -43,747 +43,723 @@
 #endif
 
 struct __Fusion_Fusionee {
-     FusionLink        link;
+	FusionLink link;
 
-     struct semaphore  lock;
+	struct semaphore lock;
 
-     FusionID          id;
-     int               pid;
+	FusionID id;
+	int pid;
 
-     FusionFifo        messages;
-     FusionFifo        prev_msgs;
+	FusionFifo messages;
+	FusionFifo prev_msgs;
 
-     int               rcv_total;  /* Total number of messages received. */
-     int               snd_total;  /* Total number of messages sent. */
+	int rcv_total;		/* Total number of messages received. */
+	int snd_total;		/* Total number of messages sent. */
 
-     wait_queue_head_t wait;
+	wait_queue_head_t wait;
 
-     bool              force_slave;
+	bool force_slave;
 
-     struct mm_struct *mm;
+	struct mm_struct *mm;
 
-     pid_t             dispatcher_pid;
+	pid_t dispatcher_pid;
 };
 
 typedef struct {
-     FusionLink         link;
+	FusionLink link;
 
-     FusionMessageType  type;
-     int                id;
-     int                channel;
-     int                size;
-     void              *data;
+	FusionMessageType type;
+	int id;
+	int channel;
+	int size;
+	void *data;
 
-     MessageCallback    callback;
-     void              *callback_ctx;
-     int                callback_param;
+	MessageCallback callback;
+	void *callback_ctx;
+	int callback_param;
 } Message;
 
 /******************************************************************************/
 
-static int  lookup_fusionee (FusionDev *dev, FusionID id, Fusionee **ret_fusionee);
-static int  lock_fusionee   (FusionDev *dev, FusionID id, Fusionee **ret_fusionee);
-static void unlock_fusionee (Fusionee *fusionee);
+static int lookup_fusionee(FusionDev * dev, FusionID id,
+			   Fusionee ** ret_fusionee);
+static int lock_fusionee(FusionDev * dev, FusionID id,
+			 Fusionee ** ret_fusionee);
+static void unlock_fusionee(Fusionee * fusionee);
 
-static void flush_messages  (FusionDev *dev, FusionFifo *fifo);
+static void flush_messages(FusionDev * dev, FusionFifo * fifo);
 
 /******************************************************************************/
 
 static int
 fusionees_read_proc(char *buf, char **start, off_t offset,
-                    int len, int *eof, void *private)
+		    int len, int *eof, void *private)
 {
-     FusionLink *l;
-     FusionDev  *dev     = private;
-     int         written = 0;
-
-     if (down_interruptible (&dev->fusionee.lock))
-          return -EINTR;
-
-     fusion_list_foreach (l, dev->fusionee.list) {
-          Fusionee *fusionee = (Fusionee*) l;
-
-          written += sprintf(buf+written, "(%5d) 0x%08lx (%4d messages waiting, %7d received, %7d sent)\n",
-                             fusionee->pid, fusionee->id, fusionee->messages.count, fusionee->rcv_total, fusionee->snd_total);
-          if (written < offset) {
-               offset -= written;
-               written = 0;
-          }
-
-          if (written >= len)
-               break;
-     }
-
-     up (&dev->fusionee.lock);
-
-     *start = buf + offset;
-     written -= offset;
-     if (written > len) {
-          *eof = 0;
-          return len;
-     }
-
-     *eof = 1;
-     return(written<0) ? 0 : written;
+	FusionLink *l;
+	FusionDev *dev = private;
+	int written = 0;
+
+	if (down_interruptible(&dev->fusionee.lock))
+		return -EINTR;
+
+	fusion_list_foreach(l, dev->fusionee.list) {
+		Fusionee *fusionee = (Fusionee *) l;
+
+		written +=
+		    sprintf(buf + written,
+			    "(%5d) 0x%08lx (%4d messages waiting, %7d received, %7d sent)\n",
+			    fusionee->pid, fusionee->id,
+			    fusionee->messages.count, fusionee->rcv_total,
+			    fusionee->snd_total);
+		if (written < offset) {
+			offset -= written;
+			written = 0;
+		}
+
+		if (written >= len)
+			break;
+	}
+
+	up(&dev->fusionee.lock);
+
+	*start = buf + offset;
+	written -= offset;
+	if (written > len) {
+		*eof = 0;
+		return len;
+	}
+
+	*eof = 1;
+	return (written < 0) ? 0 : written;
 }
 
-int
-fusionee_init (FusionDev *dev)
+int fusionee_init(FusionDev * dev)
 {
-     init_waitqueue_head (&dev->fusionee.wait);
+	init_waitqueue_head(&dev->fusionee.wait);
 
-     init_MUTEX (&dev->fusionee.lock);
+	init_MUTEX(&dev->fusionee.lock);
 
-     create_proc_read_entry("fusionees", 0, dev->proc_dir,
-                            fusionees_read_proc, dev);
+	create_proc_read_entry("fusionees", 0, dev->proc_dir,
+			       fusionees_read_proc, dev);
 
-     return 0;
+	return 0;
 }
 
-void
-fusionee_deinit (FusionDev *dev)
+void fusionee_deinit(FusionDev * dev)
 {
-     FusionLink *l;
+	FusionLink *l;
 
-     down (&dev->fusionee.lock);
+	down(&dev->fusionee.lock);
 
-     remove_proc_entry ("fusionees", dev->proc_dir);
+	remove_proc_entry("fusionees", dev->proc_dir);
 
-     l = dev->fusionee.list;
-     while (l) {
-          FusionLink *next     = l->next;
-          Fusionee   *fusionee = (Fusionee *) l;
+	l = dev->fusionee.list;
+	while (l) {
+		FusionLink *next = l->next;
+		Fusionee *fusionee = (Fusionee *) l;
 
-          while (fusionee->messages.count) {
-               Message *message = (Message*) fusion_fifo_get (&fusionee->messages);
+		while (fusionee->messages.count) {
+			Message *message =
+			    (Message *) fusion_fifo_get(&fusionee->messages);
 
-               kfree (message);
-          }
+			kfree(message);
+		}
 
-          kfree (fusionee);
+		kfree(fusionee);
 
-          l = next;
-     }
+		l = next;
+	}
 
-     up (&dev->fusionee.lock);
+	up(&dev->fusionee.lock);
 }
 
 /******************************************************************************/
 
-int
-fusionee_new( FusionDev  *dev,
-              bool        force_slave,
-              Fusionee  **ret_fusionee )
+int fusionee_new(FusionDev * dev, bool force_slave, Fusionee ** ret_fusionee)
 {
-     Fusionee *fusionee;
+	Fusionee *fusionee;
 
-     fusionee = kmalloc (sizeof(Fusionee), GFP_KERNEL);
-     if (!fusionee)
-          return -ENOMEM;
+	fusionee = kmalloc(sizeof(Fusionee), GFP_KERNEL);
+	if (!fusionee)
+		return -ENOMEM;
 
-     memset (fusionee, 0, sizeof(Fusionee));
+	memset(fusionee, 0, sizeof(Fusionee));
 
-     if (down_interruptible (&dev->fusionee.lock)) {
-          kfree (fusionee);
-          return -EINTR;
-     }
+	if (down_interruptible(&dev->fusionee.lock)) {
+		kfree(fusionee);
+		return -EINTR;
+	}
 
-     fusionee->pid         = current->pid;
-     fusionee->force_slave = force_slave;
-     fusionee->mm          = current->mm;
+	fusionee->pid = current->pid;
+	fusionee->force_slave = force_slave;
+	fusionee->mm = current->mm;
 
-     init_MUTEX (&fusionee->lock);
+	init_MUTEX(&fusionee->lock);
 
-     init_waitqueue_head (&fusionee->wait);
+	init_waitqueue_head(&fusionee->wait);
 
-     fusion_list_prepend (&dev->fusionee.list, &fusionee->link);
+	fusion_list_prepend(&dev->fusionee.list, &fusionee->link);
 
-     up (&dev->fusionee.lock);
+	up(&dev->fusionee.lock);
 
-     *ret_fusionee = fusionee;
+	*ret_fusionee = fusionee;
 
-     return 0;
+	return 0;
 }
 
-int
-fusionee_enter( FusionDev   *dev,
-                FusionEnter *enter,
-                Fusionee    *fusionee )
+int fusionee_enter(FusionDev * dev, FusionEnter * enter, Fusionee * fusionee)
 {
-     if (down_interruptible( &dev->enter_lock ))
-          return -EINTR;
+	if (down_interruptible(&dev->enter_lock))
+		return -EINTR;
 
-     if (dev->fusionee.last_id || fusionee->force_slave) {
-          while (!dev->enter_ok) {
-               fusion_sleep_on( &dev->enter_wait, &dev->enter_lock, NULL );
+	if (dev->fusionee.last_id || fusionee->force_slave) {
+		while (!dev->enter_ok) {
+			fusion_sleep_on(&dev->enter_wait, &dev->enter_lock,
+					NULL);
 
-               if (signal_pending(current))
-                    return -EINTR;
+			if (signal_pending(current))
+				return -EINTR;
 
-               if (down_interruptible( &dev->enter_lock ))
-                    return -EINTR;
-          }
+			if (down_interruptible(&dev->enter_lock))
+				return -EINTR;
+		}
 
-          FUSION_ASSERT( dev->fusionee.last_id != 0 );
-     }
+		FUSION_ASSERT(dev->fusionee.last_id != 0);
+	}
 
-     if( dev->fusionee.last_id == 0 ) {
-          /* master determines Fusion API (if supported) */
-          int major = enter->api.major;
-          if( (major != 3) && (major != 4) && (major != 8) )
-               return -ENOPROTOOPT;
+	if (dev->fusionee.last_id == 0) {
+		/* master determines Fusion API (if supported) */
+		int major = enter->api.major;
+		if ((major != 3) && (major != 4) && (major != 8))
+			return -ENOPROTOOPT;
 
-          dev->api.major = enter->api.major;
-          dev->api.minor = enter->api.minor;
-     }
-     else {
-          if( (enter->api.major != dev->api.major) || (enter->api.minor > dev->api.minor) )
-               return -ENOPROTOOPT;
-     }
+		dev->api.major = enter->api.major;
+		dev->api.minor = enter->api.minor;
+	} else {
+		if ((enter->api.major != dev->api.major)
+		    || (enter->api.minor > dev->api.minor))
+			return -ENOPROTOOPT;
+	}
 
-     fusionee->id = ++dev->fusionee.last_id;
+	fusionee->id = ++dev->fusionee.last_id;
 
-     up( &dev->enter_lock );
+	up(&dev->enter_lock);
 
-     enter->fusion_id = fusionee->id;
+	enter->fusion_id = fusionee->id;
 
-     return 0;
+	return 0;
 }
 
-int
-fusionee_fork( FusionDev  *dev,
-               FusionFork *fork,
-               Fusionee   *fusionee )
+int fusionee_fork(FusionDev * dev, FusionFork * fork, Fusionee * fusionee)
 {
-     int ret;
+	int ret;
 
-     ret = fusion_shmpool_fork_all( dev, fusionee->id, fork->fusion_id );
-     if (ret)
-          return ret;
+	ret = fusion_shmpool_fork_all(dev, fusionee->id, fork->fusion_id);
+	if (ret)
+		return ret;
 
-     ret = fusion_reactor_fork_all( dev, fusionee->id, fork->fusion_id );
-     if (ret)
-          return ret;
+	ret = fusion_reactor_fork_all(dev, fusionee->id, fork->fusion_id);
+	if (ret)
+		return ret;
 
-     ret = fusion_ref_fork_all_local( dev, fusionee->id, fork->fusion_id );
-     if (ret)
-          return ret;
+	ret = fusion_ref_fork_all_local(dev, fusionee->id, fork->fusion_id);
+	if (ret)
+		return ret;
 
-     fork->fusion_id = fusionee->id;
+	fork->fusion_id = fusionee->id;
 
-     return 0;
+	return 0;
 }
 
 int
-fusionee_send_message( FusionDev         *dev,
-                       Fusionee          *sender,
-                       FusionID           recipient,
-                       FusionMessageType  msg_type,
-                       int                msg_id,
-                       int                msg_channel,
-                       int                msg_size,
-                       const void        *msg_data,
-                       MessageCallback    callback,
-                       void              *callback_ctx,
-                       int                callback_param )
+fusionee_send_message(FusionDev * dev,
+		      Fusionee * sender,
+		      FusionID recipient,
+		      FusionMessageType msg_type,
+		      int msg_id,
+		      int msg_channel,
+		      int msg_size,
+		      const void *msg_data,
+		      MessageCallback callback,
+		      void *callback_ctx, int callback_param)
 {
-     int       ret;
-     Message  *message;
-     Fusionee *fusionee;
-
-     DEBUG( "fusionee_send_message (%d -> %d, type %d, id %d, size %d)\n",
-            fusionee->id, recipient, msg_type, msg_id, msg_size );
-
-     ret = lookup_fusionee (dev, recipient, &fusionee);
-     if (ret)
-          return ret;
-
-     if (down_interruptible (&fusionee->lock)) {
-          up (&dev->fusionee.lock);
-          return -EINTR;
-     }
-
-     if (sender && sender != fusionee) {
-          if (down_interruptible (&sender->lock)) {
-               unlock_fusionee (fusionee);
-               up (&dev->fusionee.lock);
-               return -EINTR;
-          }
-     }
-
-     up (&dev->fusionee.lock);
-
-
-     message = kmalloc (sizeof(Message) + msg_size, GFP_KERNEL);
-     if (!message) {
-          if (sender && sender != fusionee)
-               unlock_fusionee (sender);
-          unlock_fusionee (fusionee);
-          return -ENOMEM;
-     }
-
-     message->data = message + 1;
-
-     if (msg_type == FMT_CALL || msg_type == FMT_SHMPOOL)
-          memcpy (message->data, msg_data, msg_size);
-     else if (copy_from_user (message->data, msg_data, msg_size)) {
-          kfree (message);
-          if (sender && sender != fusionee)
-               unlock_fusionee (sender);
-          unlock_fusionee (fusionee);
-          return -EFAULT;
-     }
-
-     message->type           = msg_type;
-     message->id             = msg_id;
-     message->channel        = msg_channel;
-     message->size           = msg_size;
-     message->callback       = callback;
-     message->callback_ctx   = callback_ctx;
-     message->callback_param = callback_param;
-
-     fusion_fifo_put (&fusionee->messages, &message->link);
-
-     fusionee->rcv_total++;
-     if (sender)
-          sender->snd_total++;
-
-     wake_up_interruptible_all (&fusionee->wait);
-
-     if (sender && sender != fusionee)
-          unlock_fusionee (sender);
-
-     unlock_fusionee (fusionee);
-
-     return 0;
+	int ret;
+	Message *message;
+	Fusionee *fusionee;
+
+	DEBUG("fusionee_send_message (%d -> %d, type %d, id %d, size %d)\n",
+	      fusionee->id, recipient, msg_type, msg_id, msg_size);
+
+	ret = lookup_fusionee(dev, recipient, &fusionee);
+	if (ret)
+		return ret;
+
+	if (down_interruptible(&fusionee->lock)) {
+		up(&dev->fusionee.lock);
+		return -EINTR;
+	}
+
+	if (sender && sender != fusionee) {
+		if (down_interruptible(&sender->lock)) {
+			unlock_fusionee(fusionee);
+			up(&dev->fusionee.lock);
+			return -EINTR;
+		}
+	}
+
+	up(&dev->fusionee.lock);
+
+	message = kmalloc(sizeof(Message) + msg_size, GFP_KERNEL);
+	if (!message) {
+		if (sender && sender != fusionee)
+			unlock_fusionee(sender);
+		unlock_fusionee(fusionee);
+		return -ENOMEM;
+	}
+
+	message->data = message + 1;
+
+	if (msg_type == FMT_CALL || msg_type == FMT_SHMPOOL)
+		memcpy(message->data, msg_data, msg_size);
+	else if (copy_from_user(message->data, msg_data, msg_size)) {
+		kfree(message);
+		if (sender && sender != fusionee)
+			unlock_fusionee(sender);
+		unlock_fusionee(fusionee);
+		return -EFAULT;
+	}
+
+	message->type		= msg_type;
+	message->id		= msg_id;
+	message->channel	= msg_channel;
+	message->size		= msg_size;
+	message->callback	= callback;
+	message->callback_ctx	= callback_ctx;
+	message->callback_param	= callback_param;
+
+	fusion_fifo_put(&fusionee->messages, &message->link);
+
+	fusionee->rcv_total++;
+	if (sender)
+		sender->snd_total++;
+
+	wake_up_interruptible_all(&fusionee->wait);
+
+	if (sender && sender != fusionee)
+		unlock_fusionee(sender);
+
+	unlock_fusionee(fusionee);
+
+	return 0;
 }
 
 int
-fusionee_get_messages (FusionDev *dev,
-                       Fusionee  *fusionee,
-                       void      *buf,
-                       int        buf_size,
-                       bool       block)
+fusionee_get_messages(FusionDev * dev,
+		      Fusionee * fusionee, void *buf, int buf_size, bool block)
 {
-     int        written = 0;
-     FusionFifo prev_msgs;
-
-     if (down_interruptible (&fusionee->lock))
-          return -EINTR;
-
-     if (fusionee->dispatcher_pid)
-          FUSION_ASSUME( fusionee->dispatcher_pid == current->pid );
-
-     fusionee->dispatcher_pid = current->pid;
-
-     prev_msgs = fusionee->prev_msgs;
-
-     fusion_fifo_reset( &fusionee->prev_msgs );
-
-     wake_up_interruptible_all (&fusionee->wait);
-
-     while (!fusionee->messages.count) {
-          if (!block) {
-               unlock_fusionee( fusionee );
-               flush_messages( dev, &prev_msgs );
-               return -EAGAIN;
-          }
-
-          if (prev_msgs.count) {
-               unlock_fusionee( fusionee );
-               flush_messages( dev, &prev_msgs );
-          }
-          else {
-               fusion_sleep_on( &fusionee->wait, &fusionee->lock, 0 );
-
-               if (signal_pending( current ))
-                    return -EINTR;
-          }
-
-          if (down_interruptible (&fusionee->lock))
-               return -EINTR;
-     }
-
-     while (fusionee->messages.count) {
-          FusionReadMessage  header;
-          Message           *message = (Message*) fusionee->messages.first;
-          int                bytes   = ((message->size + 3) & ~3) + sizeof(header);
-
-          if (bytes > buf_size) {
-               if (!written) {
-                    unlock_fusionee (fusionee);
-                    flush_messages( dev, &prev_msgs );
-                    return -EMSGSIZE;
-               }
-
-               break;
-          }
-
-          header.msg_type    = message->type;
-          header.msg_id      = message->id;
-          header.msg_channel = message->channel;
-          header.msg_size    = message->size;
-
-          if (copy_to_user (buf, &header, sizeof(header)) ||
-              copy_to_user (buf + sizeof(header), message->data, message->size))
-          {
-               unlock_fusionee (fusionee);
-               flush_messages( dev, &prev_msgs );
-               return -EFAULT;
-          }
-          
-          if (bytes > message->size + sizeof(header)) {
-               int pad = bytes - message->size - sizeof(header);
-               u8 *dst = buf + sizeof(header) + message->size;
-               
-               while (pad--)
-                    *dst++ = 0;
-          }
-
-          written  += bytes;
-          buf      += bytes;
-          buf_size -= bytes;
-
-          fusion_fifo_get (&fusionee->messages);
-
-          if (message->callback || message->callback_ctx || message->callback_param)
-               fusion_fifo_put( &fusionee->prev_msgs, &message->link );
-          else
-               kfree( message );
-     }
-
-     unlock_fusionee (fusionee);
-
-     flush_messages( dev, &prev_msgs );
-
-     return written;
+	int written = 0;
+	FusionFifo prev_msgs;
+
+	if (down_interruptible(&fusionee->lock))
+		return -EINTR;
+
+	if (fusionee->dispatcher_pid)
+		FUSION_ASSUME(fusionee->dispatcher_pid == current->pid);
+
+	fusionee->dispatcher_pid = current->pid;
+
+	prev_msgs = fusionee->prev_msgs;
+
+	fusion_fifo_reset(&fusionee->prev_msgs);
+
+	wake_up_interruptible_all(&fusionee->wait);
+
+	while (!fusionee->messages.count) {
+		if (!block) {
+			unlock_fusionee(fusionee);
+			flush_messages(dev, &prev_msgs);
+			return -EAGAIN;
+		}
+
+		if (prev_msgs.count) {
+			unlock_fusionee(fusionee);
+			flush_messages(dev, &prev_msgs);
+		} else {
+			fusion_sleep_on(&fusionee->wait, &fusionee->lock, 0);
+
+			if (signal_pending(current))
+				return -EINTR;
+		}
+
+		if (down_interruptible(&fusionee->lock))
+			return -EINTR;
+	}
+
+	while (fusionee->messages.count) {
+		FusionReadMessage header;
+		Message *message = (Message *) fusionee->messages.first;
+		int bytes = ((message->size + 3) & ~3) + sizeof(header);
+
+		if (bytes > buf_size) {
+			if (!written) {
+				unlock_fusionee(fusionee);
+				flush_messages(dev, &prev_msgs);
+				return -EMSGSIZE;
+			}
+
+			break;
+		}
+
+		header.msg_type		= message->type;
+		header.msg_id		= message->id;
+		header.msg_channel	= message->channel;
+		header.msg_size		= message->size;
+
+		if (copy_to_user(buf, &header, sizeof(header)) ||
+		    copy_to_user(buf + sizeof(header), message->data,
+				 message->size)) {
+			unlock_fusionee(fusionee);
+			flush_messages(dev, &prev_msgs);
+			return -EFAULT;
+		}
+
+		if (bytes > message->size + sizeof(header)) {
+			int pad = bytes - message->size - sizeof(header);
+			u8 *dst = buf + sizeof(header) + message->size;
+
+			while (pad--)
+				*dst++ = 0;
+		}
+
+		written += bytes;
+		buf += bytes;
+		buf_size -= bytes;
+
+		fusion_fifo_get(&fusionee->messages);
+
+		if (message->callback || message->callback_ctx
+		    || message->callback_param)
+			fusion_fifo_put(&fusionee->prev_msgs, &message->link);
+		else
+			kfree(message);
+	}
+
+	unlock_fusionee(fusionee);
+
+	flush_messages(dev, &prev_msgs);
+
+	return written;
 }
 
 int
-fusionee_wait_processing (FusionDev         *dev,
-                          int                fusion_id,
-                          FusionMessageType  msg_type,
-                          int                msg_id)
+fusionee_wait_processing(FusionDev * dev,
+			 int fusion_id, FusionMessageType msg_type, int msg_id)
 {
-     Fusionee *fusionee;
+	Fusionee *fusionee;
 
-     do {
-          int      ret;
-          Message *message;
+	do {
+		int ret;
+		Message *message;
 
-          ret = lock_fusionee( dev, fusion_id, &fusionee );
-          if (ret)
-               return ret;
+		ret = lock_fusionee(dev, fusion_id, &fusionee);
+		if (ret)
+			return ret;
 
-          /* Search all pending messages. */
-          message = (Message*) fusionee->messages.first;
-          while (message) {
-               if (message->type == msg_type && message->id == msg_id)
-                    break;
+		/* Search all pending messages. */
+		message = (Message *) fusionee->messages.first;
+		while (message) {
+			if (message->type == msg_type && message->id == msg_id)
+				break;
 
-               message = (Message*) message->link.next;
-          }
+			message = (Message *) message->link.next;
+		}
 
-          /* Search messages being processed right now. */
-          if (!message) {
-               message = (Message*) fusionee->prev_msgs.first;
-               while (message) {
-                    if (message->type == msg_type && message->id == msg_id)
-                         break;
+		/* Search messages being processed right now. */
+		if (!message) {
+			message = (Message *) fusionee->prev_msgs.first;
+			while (message) {
+				if (message->type == msg_type
+				    && message->id == msg_id)
+					break;
 
-                    message = (Message*) message->link.next;
-               }
-          }
+				message = (Message *) message->link.next;
+			}
+		}
 
-          /* Really no more message of that type and ID? */
-          if (!message)
-               break;
+		/* Really no more message of that type and ID? */
+		if (!message)
+			break;
 
-          if (fusionee->dispatcher_pid)
-               FUSION_ASSUME( fusionee->dispatcher_pid != current->pid );
+		if (fusionee->dispatcher_pid)
+			FUSION_ASSUME(fusionee->dispatcher_pid != current->pid);
 
-          /* Otherwise unlock and wait. */
-          fusion_sleep_on( &fusionee->wait, &fusionee->lock, 0 );
+		/* Otherwise unlock and wait. */
+		fusion_sleep_on(&fusionee->wait, &fusionee->lock, 0);
 
-          if (signal_pending(current))
-               return -EINTR;
-     } while (true);
+		if (signal_pending(current))
+			return -EINTR;
+	} while (true);
 
-     unlock_fusionee (fusionee);
+	unlock_fusionee(fusionee);
 
-     return 0;
+	return 0;
 }
 
 unsigned int
-fusionee_poll (FusionDev   *dev,
-               Fusionee    *fusionee,
-               struct file *file,
-               poll_table  *wait)
+fusionee_poll(FusionDev * dev,
+	      Fusionee * fusionee, struct file *file, poll_table * wait)
 {
-     int        ret;
-     FusionID   id = fusionee->id;
-     FusionFifo prev_msgs;
+	int ret;
+	FusionID id = fusionee->id;
+	FusionFifo prev_msgs;
 
-     ret = lock_fusionee (dev, id, &fusionee);
-     if (ret)
-          return POLLERR;
+	ret = lock_fusionee(dev, id, &fusionee);
+	if (ret)
+		return POLLERR;
 
-     prev_msgs = fusionee->prev_msgs;
+	prev_msgs = fusionee->prev_msgs;
 
-     fusion_fifo_reset( &fusionee->prev_msgs );
+	fusion_fifo_reset(&fusionee->prev_msgs);
 
-     unlock_fusionee (fusionee);
+	unlock_fusionee(fusionee);
 
-     flush_messages( dev, &prev_msgs );
+	flush_messages(dev, &prev_msgs);
 
-     wake_up_all (&fusionee->wait);
+	wake_up_all(&fusionee->wait);
 
-     poll_wait (file, &fusionee->wait, wait);
+	poll_wait(file, &fusionee->wait, wait);
 
-     ret = lock_fusionee (dev, id, &fusionee);
-     if (ret)
-          return POLLERR;
+	ret = lock_fusionee(dev, id, &fusionee);
+	if (ret)
+		return POLLERR;
 
-     if (fusionee->messages.count) {
-          unlock_fusionee (fusionee);
+	if (fusionee->messages.count) {
+		unlock_fusionee(fusionee);
 
-          return POLLIN | POLLRDNORM;
-     }
+		return POLLIN | POLLRDNORM;
+	}
 
-     unlock_fusionee (fusionee);
+	unlock_fusionee(fusionee);
 
-     return 0;
+	return 0;
 }
 
 int
-fusionee_kill (FusionDev *dev,
-               Fusionee  *fusionee,
-               FusionID   target,
-               int        signal,
-               int        timeout_ms)
+fusionee_kill(FusionDev * dev,
+	      Fusionee * fusionee, FusionID target, int signal, int timeout_ms)
 {
-     long timeout = -1;
+	long timeout = -1;
 
-     while (true) {
-          FusionLink *l;
-          int         killed = 0;
+	while (true) {
+		FusionLink *l;
+		int killed = 0;
 
-          if (down_interruptible (&dev->fusionee.lock))
-               return -EINTR;
+		if (down_interruptible(&dev->fusionee.lock))
+			return -EINTR;
 
-          fusion_list_foreach (l, dev->fusionee.list) {
-               Fusionee *f = (Fusionee*) l;
+		fusion_list_foreach(l, dev->fusionee.list) {
+			Fusionee *f = (Fusionee *) l;
 
-               if (f != fusionee && (!target || target == f->id)) {
-                    struct task_struct *p;
+			if (f != fusionee && (!target || target == f->id)) {
+				struct task_struct *p;
 
 #ifdef rcu_read_lock
-                    rcu_read_lock();
+				rcu_read_lock();
 #else
-                    read_lock(&tasklist_lock);
+				read_lock(&tasklist_lock);
 #endif
-#ifdef for_each_task // 2.4
-                    for_each_task(p) {
-#else  // for >= 2.6.0 & redhat WS EL3 w/ 2.4 kernel
-                    for_each_process(p) {
+#ifdef for_each_task		/* 2.4 */
+				for_each_task(p) {
+#else /* for >= 2.6.0 & redhat WS EL3 w/ 2.4 kernel */
+				for_each_process(p) {
 #endif
-                         if (p->mm == f->mm) {
-                              send_sig_info( signal,
-                                    (void*)1L /* 1 means from kernel */,
-                                    p );
-                              killed++;
-                         }
-                    }
+					if (p->mm == f->mm) {
+						send_sig_info(signal,
+							      (void *)1L
+							      /* 1 means from kernel */
+							      ,
+							      p);
+						killed++;
+					}
+				}
 
 #ifdef rcu_read_unlock
-                    rcu_read_unlock();
+				rcu_read_unlock();
 #else
-                    read_unlock(&tasklist_lock);
+				read_unlock(&tasklist_lock);
 #endif
-               }
-          }
-
-          if (!killed || timeout_ms < 0) {
-               up (&dev->fusionee.lock);
-               break;
-          }
-
-          if (timeout_ms) {
-               switch (timeout) {
-                    case 0:  /* timed out */
-                         up (&dev->fusionee.lock);
-                         return -ETIMEDOUT;
-
-                    case -1: /* setup timeout */
-                         timeout = (timeout_ms * HZ + 500) / 1000;
-                         if (!timeout)
-                              timeout = 1;
-
-                         /* fall through */
-
-                    default:
-                         fusion_sleep_on (&dev->fusionee.wait,
-                                          &dev->fusionee.lock, &timeout);
-                         break;
-               }
-          }
-          else
-               fusion_sleep_on (&dev->fusionee.wait, &dev->fusionee.lock, NULL);
-
-          if (signal_pending(current))
-               return -EINTR;
-     }
-
-     return 0;
+			}
+		}
+
+		if (!killed || timeout_ms < 0) {
+			up(&dev->fusionee.lock);
+			break;
+		}
+
+		if (timeout_ms) {
+			switch (timeout) {
+			case 0:	/* timed out */
+				up(&dev->fusionee.lock);
+				return -ETIMEDOUT;
+
+			case -1:	/* setup timeout */
+				timeout = (timeout_ms * HZ + 500) / 1000;
+				if (!timeout)
+					timeout = 1;
+
+				/* fall through */
+
+			default:
+				fusion_sleep_on(&dev->fusionee.wait,
+						&dev->fusionee.lock, &timeout);
+				break;
+			}
+		} else
+			fusion_sleep_on(&dev->fusionee.wait,
+					&dev->fusionee.lock, NULL);
+
+		if (signal_pending(current))
+			return -EINTR;
+	}
+
+	return 0;
 }
 
-void
-fusionee_destroy (FusionDev *dev,
-                  Fusionee  *fusionee)
+void fusionee_destroy(FusionDev * dev, Fusionee * fusionee)
 {
-     FusionFifo prev_msgs;
-     FusionFifo messages;
+	FusionFifo prev_msgs;
+	FusionFifo messages;
 
-     /* Lock list. */
-     down (&dev->fusionee.lock);
+	/* Lock list. */
+	down(&dev->fusionee.lock);
 
-     /* Lock fusionee. */
-     down (&fusionee->lock);
+	/* Lock fusionee. */
+	down(&fusionee->lock);
 
-     prev_msgs = fusionee->prev_msgs;
-     messages  = fusionee->messages;
+	prev_msgs = fusionee->prev_msgs;
+	messages = fusionee->messages;
 
-     /* Remove from list. */
-     fusion_list_remove (&dev->fusionee.list, &fusionee->link);
+	/* Remove from list. */
+	fusion_list_remove(&dev->fusionee.list, &fusionee->link);
 
-     /* Wake up waiting killer. */
-     wake_up_interruptible_all (&dev->fusionee.wait);
+	/* Wake up waiting killer. */
+	wake_up_interruptible_all(&dev->fusionee.wait);
 
-     /* Unlock list. */
-     up (&dev->fusionee.lock);
+	/* Unlock list. */
+	up(&dev->fusionee.lock);
 
+	/* Release locks, references, ... */
+	fusion_call_destroy_all(dev, fusionee->id);
+	fusion_skirmish_dismiss_all(dev, fusionee->id);
+	fusion_reactor_detach_all(dev, fusionee->id);
+	fusion_property_cede_all(dev, fusionee->id);
+	fusion_ref_clear_all_local(dev, fusionee->id);
+	fusion_shmpool_detach_all(dev, fusionee->id);
 
-     /* Release locks, references, ... */
-     fusion_call_destroy_all (dev, fusionee->id);
-     fusion_skirmish_dismiss_all (dev, fusionee->id);
-     fusion_reactor_detach_all (dev, fusionee->id);
-     fusion_property_cede_all (dev, fusionee->id);
-     fusion_ref_clear_all_local (dev, fusionee->id);
-     fusion_shmpool_detach_all (dev, fusionee->id);
+	/* Unlock fusionee. */
+	up(&fusionee->lock);
 
-     /* Unlock fusionee. */
-     up (&fusionee->lock);
+	/* Free all pending messages. */
+	flush_messages(dev, &prev_msgs);
+	flush_messages(dev, &messages);
 
-     /* Free all pending messages. */
-     flush_messages( dev, &prev_msgs );
-     flush_messages( dev, &messages );
-
-     /* Free fusionee data. */
-     kfree (fusionee);
+	/* Free fusionee data. */
+	kfree(fusionee);
 }
 
-FusionID
-fusionee_id( const Fusionee *fusionee )
+FusionID fusionee_id(const Fusionee * fusionee)
 {
-     return fusionee->id;
+	return fusionee->id;
 }
 
-pid_t
-fusionee_dispatcher_pid( FusionDev *dev,
-                         FusionID   fusion_id )
+pid_t fusionee_dispatcher_pid(FusionDev * dev, FusionID fusion_id)
 {
-     FusionLink *l;
-     int         ret = -EINVAL;
+	FusionLink *l;
+	int ret = -EINVAL;
 
-     down (&dev->fusionee.lock);
+	down(&dev->fusionee.lock);
 
-     fusion_list_foreach (l, dev->fusionee.list) {
-          Fusionee *fusionee = (Fusionee *) l;
+	fusion_list_foreach(l, dev->fusionee.list) {
+		Fusionee *fusionee = (Fusionee *) l;
 
-          if (fusionee->id == fusion_id) {
-               /* FIXME: wait for it? */
-               FUSION_ASSUME( fusionee->dispatcher_pid != 0 );
+		if (fusionee->id == fusion_id) {
+			/* FIXME: wait for it? */
+			FUSION_ASSUME(fusionee->dispatcher_pid != 0);
 
-               ret = fusionee->dispatcher_pid;
-               break;
-          }
-     }
+			ret = fusionee->dispatcher_pid;
+			break;
+		}
+	}
 
-     up (&dev->fusionee.lock);
+	up(&dev->fusionee.lock);
 
-     return ret;
+	return ret;
 }
 
 /******************************************************************************/
 
 static int
-lookup_fusionee (FusionDev *dev,
-                 FusionID   id,
-                 Fusionee **ret_fusionee)
+lookup_fusionee(FusionDev * dev, FusionID id, Fusionee ** ret_fusionee)
 {
-     FusionLink *l;
+	FusionLink *l;
 
-     if (down_interruptible (&dev->fusionee.lock))
-          return -EINTR;
+	if (down_interruptible(&dev->fusionee.lock))
+		return -EINTR;
 
-     fusion_list_foreach (l, dev->fusionee.list) {
-          Fusionee *fusionee = (Fusionee *) l;
+	fusion_list_foreach(l, dev->fusionee.list) {
+		Fusionee *fusionee = (Fusionee *) l;
 
-          if (fusionee->id == id) {
-               *ret_fusionee = fusionee;
-               return 0;
-          }
-     }
+		if (fusionee->id == id) {
+			*ret_fusionee = fusionee;
+			return 0;
+		}
+	}
 
-     up (&dev->fusionee.lock);
+	up(&dev->fusionee.lock);
 
-     return -EINVAL;
+	return -EINVAL;
 }
 
-static int
-lock_fusionee (FusionDev *dev,
-               FusionID   id,
-               Fusionee **ret_fusionee)
+static int lock_fusionee(FusionDev * dev, FusionID id, Fusionee ** ret_fusionee)
 {
-     int       ret;
-     Fusionee *fusionee;
+	int ret;
+	Fusionee *fusionee;
 
-     ret = lookup_fusionee (dev, id, &fusionee);
-     if (ret)
-          return ret;
+	ret = lookup_fusionee(dev, id, &fusionee);
+	if (ret)
+		return ret;
 
-     fusion_list_move_to_front (&dev->fusionee.list, &fusionee->link);
+	fusion_list_move_to_front(&dev->fusionee.list, &fusionee->link);
 
-     if (down_interruptible (&fusionee->lock)) {
-          up (&dev->fusionee.lock);
-          return -EINTR;
-     }
+	if (down_interruptible(&fusionee->lock)) {
+		up(&dev->fusionee.lock);
+		return -EINTR;
+	}
 
-     up (&dev->fusionee.lock);
+	up(&dev->fusionee.lock);
 
-     *ret_fusionee = fusionee;
+	*ret_fusionee = fusionee;
 
-     return 0;
+	return 0;
 }
 
-static void
-unlock_fusionee (Fusionee *fusionee)
+static void unlock_fusionee(Fusionee * fusionee)
 {
-     up (&fusionee->lock);
+	up(&fusionee->lock);
 }
 
 /******************************************************************************/
 
-static void
-flush_messages( FusionDev *dev, FusionFifo *fifo )
+static void flush_messages(FusionDev * dev, FusionFifo * fifo)
 {
-     Message *message;
+	Message *message;
 
-     while ((message = (Message*) fusion_fifo_get( fifo )) != NULL) {
-          if (message->callback)
-               message->callback( dev, message->id, message->callback_ctx, message->callback_param );
+	while ((message = (Message *) fusion_fifo_get(fifo)) != NULL) {
+		if (message->callback)
+			message->callback(dev, message->id,
+					  message->callback_ctx,
+					  message->callback_param);
 
-          kfree( message );
-     }
+		kfree(message);
+	}
 }
-
diff --git a/drivers/char/fusion/fusionee.h b/drivers/char/fusion/fusionee.h
index a1f05b1..0ac6a37 100644
--- a/drivers/char/fusion/fusionee.h
+++ b/drivers/char/fusion/fusionee.h
@@ -11,9 +11,9 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  */
- 
-#ifndef __FUSIONEE_H__
-#define __FUSIONEE_H__
+
+#ifndef __FUSION__FUSIONEE_H__
+#define __FUSION__FUSIONEE_H__
 
 #include <linux/poll.h>
 #include <linux/fusion.h>
@@ -23,65 +23,48 @@
 
 /* module init/cleanup */
 
-int  fusionee_init   (FusionDev *dev);
-void fusionee_deinit (FusionDev *dev);
-
+int fusionee_init(FusionDev * dev);
+void fusionee_deinit(FusionDev * dev);
 
 /* internal functions */
 
-int fusionee_new           (FusionDev         *dev,
-                            bool               force_slave,
-                            Fusionee         **ret_fusionee);
-
-int fusionee_enter         (FusionDev         *dev,
-                            FusionEnter       *enter,
-                            Fusionee          *fusionee);
-
-int fusionee_fork          (FusionDev         *dev,
-                            FusionFork        *fork,
-                            Fusionee          *fusionee);
-
-int fusionee_send_message  (FusionDev         *dev,
-                            Fusionee          *fusionee,
-                            FusionID           recipient,
-                            FusionMessageType  msg_type,
-                            int                msg_id,
-                            int                msg_channel,
-                            int                msg_size,
-                            const void        *msg_data,
-                            MessageCallback    callback,
-                            void              *callback_ctx,
-                            int                callback_param);
-
-int fusionee_get_messages  (FusionDev         *dev,
-                            Fusionee          *fusionee,
-                            void              *buf,
-                            int                buf_size,
-                            bool               block);
-
-int fusionee_wait_processing (FusionDev         *dev,
-                              int                fusion_id,
-                              FusionMessageType  msg_type,
-                              int                msg_id);
+int fusionee_new(FusionDev * dev, bool force_slave, Fusionee ** ret_fusionee);
+
+int fusionee_enter(FusionDev * dev, FusionEnter * enter, Fusionee * fusionee);
+
+int fusionee_fork(FusionDev * dev, FusionFork * fork, Fusionee * fusionee);
+
+int fusionee_send_message(FusionDev * dev,
+			  Fusionee * fusionee,
+			  FusionID recipient,
+			  FusionMessageType msg_type,
+			  int msg_id,
+			  int msg_channel,
+			  int msg_size,
+			  const void *msg_data,
+			  MessageCallback callback,
+			  void *callback_ctx, int callback_param);
+
+int fusionee_get_messages(FusionDev * dev,
+			  Fusionee * fusionee,
+			  void *buf, int buf_size, bool block);
+
+int fusionee_wait_processing(FusionDev * dev,
+			     int fusion_id,
+			     FusionMessageType msg_type, int msg_id);
 
 unsigned
-int fusionee_poll          (FusionDev         *dev,
-                            Fusionee          *fusionee,
-                            struct file       *file,
-                            poll_table        *wait);
+int fusionee_poll(FusionDev * dev,
+		  Fusionee * fusionee, struct file *file, poll_table * wait);
 
-int fusionee_kill          (FusionDev         *dev,
-                            Fusionee          *fusionee,
-                            FusionID           target,
-                            int                signal,
-                            int                timeout_ms);
+int fusionee_kill(FusionDev * dev,
+		  Fusionee * fusionee,
+		  FusionID target, int signal, int timeout_ms);
 
-void fusionee_destroy      (FusionDev         *dev,
-                            Fusionee          *fusionee);
+void fusionee_destroy(FusionDev * dev, Fusionee * fusionee);
 
-FusionID fusionee_id( const Fusionee *fusionee );
+FusionID fusionee_id(const Fusionee * fusionee);
 
-pid_t    fusionee_dispatcher_pid( FusionDev *dev,
-                                  FusionID   fusion_id );
+pid_t fusionee_dispatcher_pid(FusionDev * dev, FusionID fusion_id);
 
 #endif
diff --git a/drivers/char/fusion/list.c b/drivers/char/fusion/list.c
index 78bf4eb..d5f64c2 100644
--- a/drivers/char/fusion/list.c
+++ b/drivers/char/fusion/list.c
@@ -16,47 +16,44 @@
 
 #include "list.h"
 
-void
-fusion_list_prepend (FusionLink **list, FusionLink *link)
+void fusion_list_prepend(FusionLink ** list, FusionLink * link)
 {
-     link->prev = NULL;
-     link->next = *list;
+	link->prev = NULL;
+	link->next = *list;
 
-     if (*list)
-          (*list)->prev = link;
+	if (*list)
+		(*list)->prev = link;
 
-     *list = link;
+	*list = link;
 }
 
-void
-fusion_list_remove (FusionLink **list, FusionLink *link)
+void fusion_list_remove(FusionLink ** list, FusionLink * link)
 {
-     if (link->prev)
-          link->prev->next = link->next;
-     else
-          *list = link->next;
+	if (link->prev)
+		link->prev->next = link->next;
+	else
+		*list = link->next;
 
-     if (link->next)
-          link->next->prev = link->prev;
+	if (link->next)
+		link->next->prev = link->prev;
 
-     link->next = link->prev = NULL;
+	link->next = link->prev = NULL;
 }
 
-void
-fusion_list_move_to_front (FusionLink **list, FusionLink *link)
+void fusion_list_move_to_front(FusionLink ** list, FusionLink * link)
 {
-     if (*list == link)
-          return;
+	if (*list == link)
+		return;
 
-     link->prev->next = link->next;
+	link->prev->next = link->next;
 
-     if (link->next)
-          link->next->prev = link->prev;
+	if (link->next)
+		link->next->prev = link->prev;
 
-     link->prev = NULL;
-     link->next = *list;
+	link->prev = NULL;
+	link->next = *list;
 
-     (*list)->prev = link;
+	(*list)->prev = link;
 
-     *list = link;
+	*list = link;
 }
diff --git a/drivers/char/fusion/list.h b/drivers/char/fusion/list.h
index 793e037..e9e1352 100644
--- a/drivers/char/fusion/list.h
+++ b/drivers/char/fusion/list.h
@@ -16,14 +16,13 @@
 #define __FUSION__LIST_H__
 
 typedef struct _FusionLink {
-     struct _FusionLink *next;
-     struct _FusionLink *prev;
+	struct _FusionLink *next;
+	struct _FusionLink *prev;
 } FusionLink;
 
-void fusion_list_prepend       (FusionLink **list, FusionLink *link);
-void fusion_list_remove        (FusionLink **list, FusionLink *link);
-void fusion_list_move_to_front (FusionLink **list, FusionLink *link);
-
+void fusion_list_prepend(FusionLink ** list, FusionLink * link);
+void fusion_list_remove(FusionLink ** list, FusionLink * link);
+void fusion_list_move_to_front(FusionLink ** list, FusionLink * link);
 
 #define fusion_list_foreach(elem, list)                     \
      for (elem = (void*)(list);                             \
@@ -36,4 +35,3 @@ void fusion_list_move_to_front (FusionLink **list, FusionLink *link);
           elem = (void*)(temp), temp = ((elem) ? (void*)(((FusionLink*)(elem))->next) : NULL))
 
 #endif /* __FUSION__LIST_H__ */
-
diff --git a/drivers/char/fusion/property.c b/drivers/char/fusion/property.c
index 080e396..e2e9677 100644
--- a/drivers/char/fusion/property.c
+++ b/drivers/char/fusion/property.c
@@ -35,307 +35,297 @@
 #include "property.h"
 
 typedef enum {
-     FUSION_PROPERTY_AVAILABLE = 0,
-     FUSION_PROPERTY_LEASED,
-     FUSION_PROPERTY_PURCHASED
+	FUSION_PROPERTY_AVAILABLE = 0,
+	FUSION_PROPERTY_LEASED,
+	FUSION_PROPERTY_PURCHASED
 } FusionPropertyState;
 
 typedef struct {
-     FusionEntry         entry;
+	FusionEntry entry;
 
-     FusionPropertyState state;
-     int                 fusion_id; /* non-zero if leased/purchased */
-     unsigned long       purchase_stamp;
-     int                 lock_pid;
-     int                 count;    /* lock counter */
+	FusionPropertyState state;
+	int fusion_id;		/* non-zero if leased/purchased */
+	unsigned long purchase_stamp;
+	int lock_pid;
+	int count;		/* lock counter */
 } FusionProperty;
 
 static void
-fusion_property_print( FusionEntry     *entry,
-                       void            *ctx,
-                       struct seq_file *p )
+fusion_property_print(FusionEntry * entry, void *ctx, struct seq_file *p)
 {
-     FusionProperty *property = (FusionProperty*) entry;
-
-     if (property->state != FUSION_PROPERTY_AVAILABLE) {
-          seq_printf( p, "%s by 0x%08x (%d) %dx\n",
-                      property->state == FUSION_PROPERTY_LEASED ? "leased" : "purchased",
-                      property->fusion_id, property->lock_pid, property->count );
-          return;
-     }
-
-     seq_printf( p, "\n" );
+	FusionProperty *property = (FusionProperty *) entry;
+
+	if (property->state != FUSION_PROPERTY_AVAILABLE) {
+		seq_printf(p, "%s by 0x%08x (%d) %dx\n",
+			   property->state ==
+			   FUSION_PROPERTY_LEASED ? "leased" : "purchased",
+			   property->fusion_id, property->lock_pid,
+			   property->count);
+		return;
+	}
+
+	seq_printf(p, "\n");
 }
 
-FUSION_ENTRY_CLASS( FusionProperty, property, NULL, NULL, fusion_property_print )
+FUSION_ENTRY_CLASS(FusionProperty, property, NULL, NULL, fusion_property_print)
 
 /******************************************************************************/
-
-int
-fusion_property_init( FusionDev *dev )
+int fusion_property_init(FusionDev * dev)
 {
-     fusion_entries_init( &dev->properties, &property_class, dev );
+	fusion_entries_init(&dev->properties, &property_class, dev);
 
-     fusion_entries_create_proc_entry( dev, "properties", &dev->properties );
+	fusion_entries_create_proc_entry(dev, "properties", &dev->properties);
 
-     return 0;
+	return 0;
 }
 
-void
-fusion_property_deinit( FusionDev *dev )
+void fusion_property_deinit(FusionDev * dev)
 {
-     remove_proc_entry( "properties", dev->proc_dir );
+	remove_proc_entry("properties", dev->proc_dir);
 
-     fusion_entries_deinit( &dev->properties );
+	fusion_entries_deinit(&dev->properties);
 }
 
 /******************************************************************************/
 
-int
-fusion_property_new( FusionDev *dev, int *ret_id )
+int fusion_property_new(FusionDev * dev, int *ret_id)
 {
-     return fusion_entry_create( &dev->properties, ret_id, NULL );
+	return fusion_entry_create(&dev->properties, ret_id, NULL);
 }
 
-int
-fusion_property_lease( FusionDev *dev, int id, int fusion_id )
+int fusion_property_lease(FusionDev * dev, int id, int fusion_id)
 {
-     int             ret;
-     FusionProperty *property;
-     long            timeout = -1;
+	int ret;
+	FusionProperty *property;
+	long timeout = -1;
 
-     dev->stat.property_lease_purchase++;
+	dev->stat.property_lease_purchase++;
 
-     ret = fusion_property_lock( &dev->properties, id, false, &property );
-     if (ret)
-          return ret;
+	ret = fusion_property_lock(&dev->properties, id, false, &property);
+	if (ret)
+		return ret;
 
-     while (true) {
-          switch (property->state) {
-               case FUSION_PROPERTY_AVAILABLE:
-                    property->state     = FUSION_PROPERTY_LEASED;
-                    property->fusion_id = fusion_id;
-                    property->lock_pid  = current->pid;
-                    property->count     = 1;
+	while (true) {
+		switch (property->state) {
+		case FUSION_PROPERTY_AVAILABLE:
+			property->state = FUSION_PROPERTY_LEASED;
+			property->fusion_id = fusion_id;
+			property->lock_pid = current->pid;
+			property->count = 1;
 
-                    fusion_property_unlock( property );
-                    return 0;
+			fusion_property_unlock(property);
+			return 0;
 
-               case FUSION_PROPERTY_LEASED:
-                    if (property->lock_pid == current->pid) {
-                         property->count++;
+		case FUSION_PROPERTY_LEASED:
+			if (property->lock_pid == current->pid) {
+				property->count++;
 
-                         fusion_property_unlock( property );
-                         return 0;
-                    }
+				fusion_property_unlock(property);
+				return 0;
+			}
 
-                    ret = fusion_property_wait( property, NULL );
-                    if (ret)
-                         return ret;
+			ret = fusion_property_wait(property, NULL);
+			if (ret)
+				return ret;
 
-                    break;
+			break;
 
-               case FUSION_PROPERTY_PURCHASED:
-                    if (property->lock_pid == current->pid) {
-                         fusion_property_unlock( property );
-                         return -EIO;
-                    }
+		case FUSION_PROPERTY_PURCHASED:
+			if (property->lock_pid == current->pid) {
+				fusion_property_unlock(property);
+				return -EIO;
+			}
 
-                    if (timeout == -1) {
-                         if (jiffies - property->purchase_stamp > HZ / 10) {
-                              fusion_property_unlock( property );
-                              return -EAGAIN;
-                         }
+			if (timeout == -1) {
+				if (jiffies - property->purchase_stamp >
+				    HZ / 10) {
+					fusion_property_unlock(property);
+					return -EAGAIN;
+				}
 
-                         timeout = HZ / 10;
-                    }
+				timeout = HZ / 10;
+			}
 
-                    ret = fusion_property_wait( property, &timeout );
-                    if (ret)
-                         return ret;
+			ret = fusion_property_wait(property, &timeout);
+			if (ret)
+				return ret;
 
-                    break;
+			break;
 
-               default:
-                    BUG();
-          }
-     }
+		default:
+			BUG();
+		}
+	}
 
-     BUG();
+	BUG();
 
-     /* won't reach this */
-     return -1;
+	/* won't reach this */
+	return -1;
 }
 
-int
-fusion_property_purchase( FusionDev *dev, int id, int fusion_id )
+int fusion_property_purchase(FusionDev * dev, int id, int fusion_id)
 {
-     int             ret;
-     FusionProperty *property;
-     signed long     timeout = -1;
+	int ret;
+	FusionProperty *property;
+	signed long timeout = -1;
 
-     dev->stat.property_lease_purchase++;
+	dev->stat.property_lease_purchase++;
 
-     ret = fusion_property_lock( &dev->properties, id, false, &property );
-     if (ret)
-          return ret;
+	ret = fusion_property_lock(&dev->properties, id, false, &property);
+	if (ret)
+		return ret;
 
-     while (true) {
-          switch (property->state) {
-               case FUSION_PROPERTY_AVAILABLE:
-                    property->state          = FUSION_PROPERTY_PURCHASED;
-                    property->fusion_id      = fusion_id;
-                    property->purchase_stamp = jiffies;
-                    property->lock_pid       = current->pid;
-                    property->count          = 1;
+	while (true) {
+		switch (property->state) {
+		case FUSION_PROPERTY_AVAILABLE:
+			property->state = FUSION_PROPERTY_PURCHASED;
+			property->fusion_id = fusion_id;
+			property->purchase_stamp = jiffies;
+			property->lock_pid = current->pid;
+			property->count = 1;
 
-                    fusion_property_notify( property, true );
+			fusion_property_notify(property, true);
 
-                    fusion_property_unlock( property );
-                    return 0;
+			fusion_property_unlock(property);
+			return 0;
 
-               case FUSION_PROPERTY_LEASED:
-                    if (property->lock_pid == current->pid) {
-                         fusion_property_unlock( property );
-                         return -EIO;
-                    }
+		case FUSION_PROPERTY_LEASED:
+			if (property->lock_pid == current->pid) {
+				fusion_property_unlock(property);
+				return -EIO;
+			}
 
-                    ret = fusion_property_wait( property, NULL );
-                    if (ret)
-                         return ret;
+			ret = fusion_property_wait(property, NULL);
+			if (ret)
+				return ret;
 
-                    break;
+			break;
 
-               case FUSION_PROPERTY_PURCHASED:
-                    if (property->lock_pid == current->pid) {
-                         property->count++;
+		case FUSION_PROPERTY_PURCHASED:
+			if (property->lock_pid == current->pid) {
+				property->count++;
 
-                         fusion_property_unlock( property );
-                         return 0;
-                    }
+				fusion_property_unlock(property);
+				return 0;
+			}
 
-                    if (timeout == -1) {
-                         if (jiffies - property->purchase_stamp > HZ) {
-                              fusion_property_unlock( property );
-                              return -EAGAIN;
-                         }
+			if (timeout == -1) {
+				if (jiffies - property->purchase_stamp > HZ) {
+					fusion_property_unlock(property);
+					return -EAGAIN;
+				}
 
-                         timeout = HZ;
-                    }
+				timeout = HZ;
+			}
 
-                    ret = fusion_property_wait( property, &timeout );
-                    if (ret)
-                         return ret;
+			ret = fusion_property_wait(property, &timeout);
+			if (ret)
+				return ret;
 
-                    break;
+			break;
 
-               default:
-                    BUG();
-          }
-     }
+		default:
+			BUG();
+		}
+	}
 
-     BUG();
+	BUG();
 
-     /* won't reach this */
-     return -1;
+	/* won't reach this */
+	return -1;
 }
 
-int
-fusion_property_cede( FusionDev *dev, int id, int fusion_id )
+int fusion_property_cede(FusionDev * dev, int id, int fusion_id)
 {
-     int             ret;
-     FusionProperty *property;
-     bool            purchased;
+	int ret;
+	FusionProperty *property;
+	bool purchased;
 
-     dev->stat.property_cede++;
+	dev->stat.property_cede++;
 
-     ret = fusion_property_lock( &dev->properties, id, false, &property );
-     if (ret)
-          return ret;
+	ret = fusion_property_lock(&dev->properties, id, false, &property);
+	if (ret)
+		return ret;
 
-     if (property->lock_pid != current->pid) {
-          fusion_property_unlock( property );
-          return -EIO;
-     }
+	if (property->lock_pid != current->pid) {
+		fusion_property_unlock(property);
+		return -EIO;
+	}
 
-     if (--property->count) {
-          fusion_property_unlock( property );
-          return 0;
-     }
+	if (--property->count) {
+		fusion_property_unlock(property);
+		return 0;
+	}
 
-     purchased = (property->state == FUSION_PROPERTY_PURCHASED);
+	purchased = (property->state == FUSION_PROPERTY_PURCHASED);
 
-     property->state     = FUSION_PROPERTY_AVAILABLE;
-     property->fusion_id = 0;
-     property->lock_pid  = 0;
+	property->state = FUSION_PROPERTY_AVAILABLE;
+	property->fusion_id = 0;
+	property->lock_pid = 0;
 
-     fusion_property_notify( property, true );
+	fusion_property_notify(property, true);
 
-     fusion_property_unlock( property );
+	fusion_property_unlock(property);
 
-     if (purchased)
-          yield();
+	if (purchased)
+		yield();
 
-     return 0;
+	return 0;
 }
 
-int
-fusion_property_holdup( FusionDev *dev, int id, Fusionee *fusionee )
+int fusion_property_holdup(FusionDev * dev, int id, Fusionee * fusionee)
 {
-     int             ret;
-     FusionProperty *property;
-     FusionID        fusion_id = fusionee_id( fusionee );
+	int ret;
+	FusionProperty *property;
+	FusionID fusion_id = fusionee_id(fusionee);
 
-     if (fusion_id > 1)
-          return -EPERM;
+	if (fusion_id > 1)
+		return -EPERM;
 
-     ret = fusion_property_lock( &dev->properties, id, false, &property );
-     if (ret)
-          return ret;
+	ret = fusion_property_lock(&dev->properties, id, false, &property);
+	if (ret)
+		return ret;
 
-     if (property->state == FUSION_PROPERTY_PURCHASED) {
-          if (property->fusion_id == fusion_id) {
-               fusion_property_unlock( property );
-               return -EIO;
-          }
+	if (property->state == FUSION_PROPERTY_PURCHASED) {
+		if (property->fusion_id == fusion_id) {
+			fusion_property_unlock(property);
+			return -EIO;
+		}
 
-          fusionee_kill( dev, fusionee, property->fusion_id, SIGKILL, -1 );
-     }
+		fusionee_kill(dev, fusionee, property->fusion_id, SIGKILL, -1);
+	}
 
-     fusion_property_unlock( property );
+	fusion_property_unlock(property);
 
-     return 0;
+	return 0;
 }
 
-int
-fusion_property_destroy( FusionDev *dev, int id )
+int fusion_property_destroy(FusionDev * dev, int id)
 {
-     return fusion_entry_destroy( &dev->properties, id );
+	return fusion_entry_destroy(&dev->properties, id);
 }
 
-void
-fusion_property_cede_all( FusionDev *dev, int fusion_id )
+void fusion_property_cede_all(FusionDev * dev, int fusion_id)
 {
-     FusionLink *l;
+	FusionLink *l;
 
-     down( &dev->properties.lock );
+	down(&dev->properties.lock);
 
-     fusion_list_foreach (l, dev->properties.list) {
-          FusionProperty *property = (FusionProperty *) l;
+	fusion_list_foreach(l, dev->properties.list) {
+		FusionProperty *property = (FusionProperty *) l;
 
-          down( &property->entry.lock );
+		down(&property->entry.lock);
 
-          if (property->fusion_id == fusion_id) {
-               property->state     = FUSION_PROPERTY_AVAILABLE;
-               property->fusion_id = 0;
-               property->lock_pid  = 0;
+		if (property->fusion_id == fusion_id) {
+			property->state = FUSION_PROPERTY_AVAILABLE;
+			property->fusion_id = 0;
+			property->lock_pid = 0;
 
-               wake_up_interruptible_all (&property->entry.wait);
-          }
+			wake_up_interruptible_all(&property->entry.wait);
+		}
 
-          up( &property->entry.lock );
-     }
+		up(&property->entry.lock);
+	}
 
-     up( &dev->properties.lock );
+	up(&dev->properties.lock);
 }
-
diff --git a/drivers/char/fusion/property.h b/drivers/char/fusion/property.h
index 63a403d..69e7fc4 100644
--- a/drivers/char/fusion/property.h
+++ b/drivers/char/fusion/property.h
@@ -18,41 +18,27 @@
 #include "fusiondev.h"
 #include "types.h"
 
-
 /* module init/cleanup */
 
-int  fusion_property_init   (FusionDev *dev);
-void fusion_property_deinit (FusionDev *dev);
-
+int fusion_property_init(FusionDev * dev);
+void fusion_property_deinit(FusionDev * dev);
 
 /* public API */
 
-int fusion_property_new      (FusionDev *dev,
-                              int       *ret_id);
-
-int fusion_property_lease    (FusionDev *dev,
-                              int        id,
-                              int        fusion_id);
+int fusion_property_new(FusionDev * dev, int *ret_id);
 
-int fusion_property_purchase (FusionDev *dev,
-                              int        id,
-                              int        fusion_id);
+int fusion_property_lease(FusionDev * dev, int id, int fusion_id);
 
-int fusion_property_cede     (FusionDev *dev,
-                              int        id,
-                              int        fusion_id);
+int fusion_property_purchase(FusionDev * dev, int id, int fusion_id);
 
-int fusion_property_holdup   (FusionDev *dev,
-                              int        id,
-                              Fusionee  *fusionee);
+int fusion_property_cede(FusionDev * dev, int id, int fusion_id);
 
-int fusion_property_destroy  (FusionDev *dev,
-                              int        id);
+int fusion_property_holdup(FusionDev * dev, int id, Fusionee * fusionee);
 
+int fusion_property_destroy(FusionDev * dev, int id);
 
 /* internal functions */
 
-void fusion_property_cede_all (FusionDev *dev,
-                               int        fusion_id);
+void fusion_property_cede_all(FusionDev * dev, int fusion_id);
 
 #endif
diff --git a/drivers/char/fusion/reactor.c b/drivers/char/fusion/reactor.c
index 101ddeb..fe40cd9 100644
--- a/drivers/char/fusion/reactor.c
+++ b/drivers/char/fusion/reactor.c
@@ -32,526 +32,517 @@
 #include "shmpool.h"
 
 typedef struct {
-     FusionLink         link;
+	FusionLink link;
 
-     int                fusion_id;
+	int fusion_id;
 
-     int               *counts;     /* number of attach calls */
-     int                num_counts;
+	int *counts;		/* number of attach calls */
+	int num_counts;
 } ReactorNode;
 
 typedef struct {
-     int                count;     /* number of recipients */
+	int count;		/* number of recipients */
 
-     int                call_id;   /* id of call to execute when count reaches zero */
-     int                call_arg;  /* optional parameter of user space */
-     void              *call_ptr;
+	int call_id;		/* id of call to execute when count reaches zero */
+	int call_arg;		/* optional parameter of user space */
+	void *call_ptr;
 } ReactorDispatch;
 
 typedef struct {
-     FusionEntry        entry;
+	FusionEntry entry;
 
-     FusionLink        *nodes;
+	FusionLink *nodes;
 
-     int                dispatch_count;
+	int dispatch_count;
 
-     bool               destroyed;
+	bool destroyed;
 
-     int                call_id;
-     void              *call_ptr;
+	int call_id;
+	void *call_ptr;
 } FusionReactor;
 
 /******************************************************************************/
 
-static int  fork_node     ( FusionReactor *reactor,
-                            FusionID       fusion_id,
-                            FusionID       from_id );
+static int fork_node(FusionReactor * reactor,
+		     FusionID fusion_id, FusionID from_id);
 
-static void free_all_nodes( FusionReactor *reactor );
+static void free_all_nodes(FusionReactor * reactor);
 
 /******************************************************************************/
 
-static inline ReactorNode *
-get_node (FusionReactor *reactor,
-          FusionID       fusion_id)
+static inline ReactorNode *get_node(FusionReactor * reactor, FusionID fusion_id)
 {
-     ReactorNode *node;
+	ReactorNode *node;
 
-     fusion_list_foreach (node, reactor->nodes) {
-          if (node->fusion_id == fusion_id)
-               return node;
-     }
+	fusion_list_foreach(node, reactor->nodes) {
+		if (node->fusion_id == fusion_id)
+			return node;
+	}
 
-     return NULL;
+	return NULL;
 }
 
 /******************************************************************************/
 
-static void
-fusion_reactor_destruct( FusionEntry *entry,
-                         void        *ctx )
+static void fusion_reactor_destruct(FusionEntry * entry, void *ctx)
 {
-     FusionReactor *reactor = (FusionReactor*) entry;
+	FusionReactor *reactor = (FusionReactor *) entry;
 
-     free_all_nodes( reactor );
+	free_all_nodes(reactor);
 }
 
 static void
-fusion_reactor_print( FusionEntry     *entry,
-                      void            *ctx,
-                      struct seq_file *p )
+fusion_reactor_print(FusionEntry * entry, void *ctx, struct seq_file *p)
 {
-     int            num     = 0;
-     FusionReactor *reactor = (FusionReactor*) entry;
-     FusionLink    *node    = reactor->nodes;
+	int num = 0;
+	FusionReactor *reactor = (FusionReactor *) entry;
+	FusionLink *node = reactor->nodes;
 
-     fusion_list_foreach (node, reactor->nodes) {
-          num++;
-     }
+	fusion_list_foreach(node, reactor->nodes) {
+		num++;
+	}
 
-     seq_printf( p, "%5dx dispatch, %d nodes%s\n", reactor->dispatch_count, num,
-                    reactor->destroyed ? "  DESTROYED" : "" );
+	seq_printf(p, "%5dx dispatch, %d nodes%s\n", reactor->dispatch_count,
+		   num, reactor->destroyed ? "  DESTROYED" : "");
 }
 
-
-FUSION_ENTRY_CLASS( FusionReactor, reactor, NULL,
-                    fusion_reactor_destruct, fusion_reactor_print )
+FUSION_ENTRY_CLASS(FusionReactor, reactor, NULL,
+		   fusion_reactor_destruct, fusion_reactor_print)
 
 /******************************************************************************/
-
-int
-fusion_reactor_init (FusionDev *dev)
+int fusion_reactor_init(FusionDev * dev)
 {
-     fusion_entries_init( &dev->reactor, &reactor_class, dev );
+	fusion_entries_init(&dev->reactor, &reactor_class, dev);
 
-     fusion_entries_create_proc_entry( dev, "reactors", &dev->reactor );
+	fusion_entries_create_proc_entry(dev, "reactors", &dev->reactor);
 
-     return 0;
+	return 0;
 }
 
-void
-fusion_reactor_deinit (FusionDev *dev)
+void fusion_reactor_deinit(FusionDev * dev)
 {
-     remove_proc_entry ("reactors", dev->proc_dir);
+	remove_proc_entry("reactors", dev->proc_dir);
 
-     fusion_entries_deinit( &dev->reactor );
+	fusion_entries_deinit(&dev->reactor);
 }
 
 /******************************************************************************/
 
-int
-fusion_reactor_new (FusionDev *dev, int *ret_id)
+int fusion_reactor_new(FusionDev * dev, int *ret_id)
 {
-     return fusion_entry_create( &dev->reactor, ret_id, NULL );
+	return fusion_entry_create(&dev->reactor, ret_id, NULL);
 }
 
 int
-fusion_reactor_attach (FusionDev *dev, int id, int channel, FusionID fusion_id)
+fusion_reactor_attach(FusionDev * dev, int id, int channel, FusionID fusion_id)
 {
-     int            ret;
-     ReactorNode   *node;
-     FusionReactor *reactor;
+	int ret;
+	ReactorNode *node;
+	FusionReactor *reactor;
 
-     if (channel < 0 || channel > 1023)
-          return -EINVAL;
+	if (channel < 0 || channel > 1023)
+		return -EINVAL;
 
-     ret = fusion_reactor_lock( &dev->reactor, id, false, &reactor );
-     if (ret)
-          return ret;
+	ret = fusion_reactor_lock(&dev->reactor, id, false, &reactor);
+	if (ret)
+		return ret;
 
-     if (reactor->destroyed) {
-          fusion_reactor_unlock( reactor );
-          return -EIDRM;
-     }
+	if (reactor->destroyed) {
+		fusion_reactor_unlock(reactor);
+		return -EIDRM;
+	}
 
-     dev->stat.reactor_attach++;
+	dev->stat.reactor_attach++;
 
-     node = get_node (reactor, fusion_id);
-     if (!node) {
-          int ncount = channel + 4;
+	node = get_node(reactor, fusion_id);
+	if (!node) {
+		int ncount = channel + 4;
 
-          node = kmalloc (sizeof(ReactorNode), GFP_KERNEL);
-          if (!node) {
-               fusion_reactor_unlock( reactor );
-               return -ENOMEM;
-          }
+		node = kmalloc(sizeof(ReactorNode), GFP_KERNEL);
+		if (!node) {
+			fusion_reactor_unlock(reactor);
+			return -ENOMEM;
+		}
 
-          node->counts = kmalloc( sizeof(int) * ncount, GFP_KERNEL );
-          if (!node->counts) {
-               kfree( node );
-               fusion_reactor_unlock( reactor );
-               return -ENOMEM;
-          }
+		node->counts = kmalloc(sizeof(int) * ncount, GFP_KERNEL);
+		if (!node->counts) {
+			kfree(node);
+			fusion_reactor_unlock(reactor);
+			return -ENOMEM;
+		}
 
-          memset( node->counts, 0, sizeof(int) * ncount );
+		memset(node->counts, 0, sizeof(int) * ncount);
 
-          node->num_counts = ncount;
-          node->fusion_id  = fusion_id;
+		node->num_counts = ncount;
+		node->fusion_id = fusion_id;
 
-          node->counts[channel] = 1;
+		node->counts[channel] = 1;
 
-          fusion_list_prepend (&reactor->nodes, &node->link);
-     }
-     else {
-          if (node->num_counts <= channel) {
-               int  ncount = channel + 4;
-               int *counts = kmalloc( sizeof(int) * ncount, GFP_KERNEL );
+		fusion_list_prepend(&reactor->nodes, &node->link);
+	} else {
+		if (node->num_counts <= channel) {
+			int ncount = channel + 4;
+			int *counts = kmalloc(sizeof(int) * ncount, GFP_KERNEL);
 
-               if (!counts) {
-                    fusion_reactor_unlock( reactor );
-                    return -ENOMEM;
-               }
+			if (!counts) {
+				fusion_reactor_unlock(reactor);
+				return -ENOMEM;
+			}
 
-               memcpy( counts, node->counts, sizeof(int) * node->num_counts );
-               memset( counts + node->num_counts, 0, sizeof(int) * (ncount - node->num_counts) );
+			memcpy(counts, node->counts,
+			       sizeof(int) * node->num_counts);
+			memset(counts + node->num_counts, 0,
+			       sizeof(int) * (ncount - node->num_counts));
 
-               kfree( node->counts );
+			kfree(node->counts);
 
-               node->counts     = counts;
-               node->num_counts = ncount;
-          }
+			node->counts = counts;
+			node->num_counts = ncount;
+		}
 
-          node->counts[channel]++;
-     }
+		node->counts[channel]++;
+	}
 
-     fusion_reactor_unlock( reactor );
+	fusion_reactor_unlock(reactor);
 
-     return 0;
+	return 0;
 }
 
 int
-fusion_reactor_detach (FusionDev *dev, int id, int channel, FusionID fusion_id)
+fusion_reactor_detach(FusionDev * dev, int id, int channel, FusionID fusion_id)
 {
-     int            ret;
-     ReactorNode   *node;
-     FusionReactor *reactor;
+	int ret;
+	ReactorNode *node;
+	FusionReactor *reactor;
 
-     if (channel < 0 || channel > 1023)
-          return -EINVAL;
+	if (channel < 0 || channel > 1023)
+		return -EINVAL;
 
-     ret = fusion_reactor_lock( &dev->reactor, id, true, &reactor );
-     if (ret)
-          return ret;
+	ret = fusion_reactor_lock(&dev->reactor, id, true, &reactor);
+	if (ret)
+		return ret;
 
-     dev->stat.reactor_detach++;
+	dev->stat.reactor_detach++;
 
-     node = get_node (reactor, fusion_id);
-     if (!node || node->num_counts <= channel) {
-          fusion_reactor_unlock( reactor );
-          up( &dev->reactor.lock );
-          return -EIO;
-     }
+	node = get_node(reactor, fusion_id);
+	if (!node || node->num_counts <= channel) {
+		fusion_reactor_unlock(reactor);
+		up(&dev->reactor.lock);
+		return -EIO;
+	}
 
-     if (! --node->counts[channel]) {
-          int i;
+	if (!--node->counts[channel]) {
+		int i;
 
-          for (i=0; i<node->num_counts; i++) {
-               if (node->counts[i])
-                    break;
-          }
+		for (i = 0; i < node->num_counts; i++) {
+			if (node->counts[i])
+				break;
+		}
 
-          if (i == node->num_counts) {
-               fusion_list_remove (&reactor->nodes, &node->link);
-               kfree (node->counts);
-               kfree (node);
-          }
-     }
+		if (i == node->num_counts) {
+			fusion_list_remove(&reactor->nodes, &node->link);
+			kfree(node->counts);
+			kfree(node);
+		}
+	}
 
-     if (reactor->destroyed && !reactor->nodes)
-          fusion_entry_destroy_locked( &dev->reactor, &reactor->entry );
-     else
-          fusion_reactor_unlock( reactor );
+	if (reactor->destroyed && !reactor->nodes)
+		fusion_entry_destroy_locked(&dev->reactor, &reactor->entry);
+	else
+		fusion_reactor_unlock(reactor);
 
-     up( &dev->reactor.lock );
+	up(&dev->reactor.lock);
 
-     return 0;
+	return 0;
 }
 
-static void
-dispatch_callback( FusionDev *dev,
-                   int        id,
-                   void      *ctx,
-                   int        arg )
+static void dispatch_callback(FusionDev * dev, int id, void *ctx, int arg)
 {
-     FusionLink      *l;
-     FusionReactor   *reactor  = NULL;
-     ReactorDispatch *dispatch = ctx;
+	FusionLink *l;
+	FusionReactor *reactor = NULL;
+	ReactorDispatch *dispatch = ctx;
 
-     down (&dev->reactor.lock);
+	down(&dev->reactor.lock);
 
-     fusion_list_foreach (l, dev->reactor.list) {
-          reactor = (FusionReactor *) l;
+	fusion_list_foreach(l, dev->reactor.list) {
+		reactor = (FusionReactor *) l;
 
-          if (reactor->entry.id == id) {
-               down (&reactor->entry.lock);
+		if (reactor->entry.id == id) {
+			down(&reactor->entry.lock);
 
-               if (! --dispatch->count) {
-                    FusionCallExecute execute;
+			if (!--dispatch->count) {
+				FusionCallExecute execute;
 
-                    execute.call_id  = dispatch->call_id;
-                    execute.call_arg = dispatch->call_arg;
-                    execute.call_ptr = dispatch->call_ptr;
+				execute.call_id = dispatch->call_id;
+				execute.call_arg = dispatch->call_arg;
+				execute.call_ptr = dispatch->call_ptr;
 
-                    fusion_call_execute( dev, NULL, &execute );
+				fusion_call_execute(dev, NULL, &execute);
 
-                    kfree( dispatch );
-               }
+				kfree(dispatch);
+			}
 
-               up (&reactor->entry.lock);
+			up(&reactor->entry.lock);
 
-               break;
-          }
-     }
+			break;
+		}
+	}
 
-     if (!reactor) {
-          if (! --dispatch->count)
-               kfree( dispatch );
-     }
+	if (!reactor) {
+		if (!--dispatch->count)
+			kfree(dispatch);
+	}
 
-     up( &dev->reactor.lock );
+	up(&dev->reactor.lock);
 }
 
 int
-fusion_reactor_dispatch (FusionDev *dev, int id, int channel, Fusionee *fusionee,
-                         int msg_size, const void *msg_data)
+fusion_reactor_dispatch(FusionDev * dev, int id, int channel,
+			Fusionee * fusionee, int msg_size, const void *msg_data)
 {
-     int              ret;
-     FusionLink      *l;
-     FusionReactor   *reactor;
-     ReactorDispatch *dispatch  = NULL;
-     FusionID         fusion_id = fusionee ? fusionee_id( fusionee ) : 0;
-
-     if (channel < 0 || channel > 1023)
-          return -EINVAL;
-
-     ret = fusion_reactor_lock( &dev->reactor, id, false, &reactor );
-     if (ret)
-          return ret;
-
-     if (reactor->destroyed) {
-          fusion_reactor_unlock( reactor );
-          return -EIDRM;
-     }
-
-     if (reactor->call_id) {
-          void *ptr = *(void**)msg_data;
-
-          dispatch = kmalloc (sizeof(ReactorDispatch), GFP_KERNEL);
-          if (!dispatch) {
-               fusion_reactor_unlock( reactor );
-               return -ENOMEM;
-          }
-
-          dispatch->count    = 0;
-          dispatch->call_id  = reactor->call_id;
-          dispatch->call_arg = channel;
-
-          if (!reactor->call_ptr && msg_size == sizeof(ptr) &&
-              (unsigned long) ptr >= FUSION_SHM_BASE &&
-              (unsigned long) ptr < (FUSION_SHM_BASE+FUSION_SHM_SIZE))
-               dispatch->call_ptr = ptr;
-          else
-               dispatch->call_ptr = reactor->call_ptr;
-     }
-
-     reactor->dispatch_count++;
-
-     dev->stat.reactor_dispatch++;
-
-     fusion_list_foreach (l, reactor->nodes) {
-          ReactorNode *node = (ReactorNode *) l;
-
-          if (node->fusion_id == fusion_id || node->num_counts <= channel || !node->counts[channel])
-               continue;
-
-          if (dispatch) {
-               dispatch->count++;
-
-               ret = fusionee_send_message (dev, fusionee, node->fusion_id, FMT_REACTOR,
-								    reactor->entry.id, channel, msg_size, msg_data,
-								    dispatch_callback, dispatch, reactor->entry.id);
-          }
-          else
-               ret = fusionee_send_message (dev, fusionee, node->fusion_id, FMT_REACTOR,
-								    reactor->entry.id, channel, msg_size, msg_data, NULL, NULL, 0);
-     }
-
-     if (dispatch && !dispatch->count) {
-          FusionCallExecute execute;
-
-          execute.call_id  = dispatch->call_id;
-          execute.call_arg = dispatch->call_arg;
-          execute.call_ptr = dispatch->call_ptr;
-
-          fusion_call_execute( dev, NULL, &execute );
-
-          kfree( dispatch );
-     }
-
-     fusion_reactor_unlock( reactor );
-
-     return 0;
+	int ret;
+	FusionLink *l;
+	FusionReactor *reactor;
+	ReactorDispatch *dispatch = NULL;
+	FusionID fusion_id = fusionee ? fusionee_id(fusionee) : 0;
+
+	if (channel < 0 || channel > 1023)
+		return -EINVAL;
+
+	ret = fusion_reactor_lock(&dev->reactor, id, false, &reactor);
+	if (ret)
+		return ret;
+
+	if (reactor->destroyed) {
+		fusion_reactor_unlock(reactor);
+		return -EIDRM;
+	}
+
+	if (reactor->call_id) {
+		void *ptr = *(void **)msg_data;
+
+		dispatch = kmalloc(sizeof(ReactorDispatch), GFP_KERNEL);
+		if (!dispatch) {
+			fusion_reactor_unlock(reactor);
+			return -ENOMEM;
+		}
+
+		dispatch->count = 0;
+		dispatch->call_id = reactor->call_id;
+		dispatch->call_arg = channel;
+
+		if (!reactor->call_ptr && msg_size == sizeof(ptr) &&
+		    (unsigned long)ptr >= FUSION_SHM_BASE &&
+		    (unsigned long)ptr < (FUSION_SHM_BASE + FUSION_SHM_SIZE))
+			dispatch->call_ptr = ptr;
+		else
+			dispatch->call_ptr = reactor->call_ptr;
+	}
+
+	reactor->dispatch_count++;
+
+	dev->stat.reactor_dispatch++;
+
+	fusion_list_foreach(l, reactor->nodes) {
+		ReactorNode *node = (ReactorNode *) l;
+
+		if (node->fusion_id == fusion_id || node->num_counts <= channel
+		    || !node->counts[channel])
+			continue;
+
+		if (dispatch) {
+			dispatch->count++;
+
+			ret =
+			    fusionee_send_message(dev, fusionee,
+						  node->fusion_id, FMT_REACTOR,
+						  reactor->entry.id, channel,
+						  msg_size, msg_data,
+						  dispatch_callback, dispatch,
+						  reactor->entry.id);
+		} else
+			ret =
+			    fusionee_send_message(dev, fusionee,
+						  node->fusion_id, FMT_REACTOR,
+						  reactor->entry.id, channel,
+						  msg_size, msg_data, NULL,
+						  NULL, 0);
+	}
+
+	if (dispatch && !dispatch->count) {
+		FusionCallExecute execute;
+
+		execute.call_id = dispatch->call_id;
+		execute.call_arg = dispatch->call_arg;
+		execute.call_ptr = dispatch->call_ptr;
+
+		fusion_call_execute(dev, NULL, &execute);
+
+		kfree(dispatch);
+	}
+
+	fusion_reactor_unlock(reactor);
+
+	return 0;
 }
 
 int
-fusion_reactor_set_dispatch_callback (FusionDev  *dev,
-                                      int         id,
-                                      int         call_id,
-                                      void       *call_ptr)
+fusion_reactor_set_dispatch_callback(FusionDev * dev,
+				     int id, int call_id, void *call_ptr)
 {
-     int            ret;
-     FusionReactor *reactor;
+	int ret;
+	FusionReactor *reactor;
 
-     ret = fusion_reactor_lock( &dev->reactor, id, false, &reactor );
-     if (ret)
-          return ret;
+	ret = fusion_reactor_lock(&dev->reactor, id, false, &reactor);
+	if (ret)
+		return ret;
 
-     if (reactor->destroyed) {
-          fusion_reactor_unlock( reactor );
-          return -EIDRM;
-     }
+	if (reactor->destroyed) {
+		fusion_reactor_unlock(reactor);
+		return -EIDRM;
+	}
 
-     reactor->call_id  = call_id;
-     reactor->call_ptr = call_ptr;
+	reactor->call_id = call_id;
+	reactor->call_ptr = call_ptr;
 
-     fusion_reactor_unlock( reactor );
+	fusion_reactor_unlock(reactor);
 
-     return 0;
+	return 0;
 }
 
-int
-fusion_reactor_destroy (FusionDev *dev, int id)
+int fusion_reactor_destroy(FusionDev * dev, int id)
 {
-     int            ret;
-     FusionReactor *reactor;
+	int ret;
+	FusionReactor *reactor;
 
-     ret = fusion_reactor_lock( &dev->reactor, id, true, &reactor );
-     if (ret)
-          return ret;
+	ret = fusion_reactor_lock(&dev->reactor, id, true, &reactor);
+	if (ret)
+		return ret;
 
-     if (reactor->destroyed) {
-          fusion_reactor_unlock( reactor );
-          up( &dev->reactor.lock );
-          return -EIDRM;
-     }
+	if (reactor->destroyed) {
+		fusion_reactor_unlock(reactor);
+		up(&dev->reactor.lock);
+		return -EIDRM;
+	}
 
-     reactor->destroyed = true;
+	reactor->destroyed = true;
 
-     if (!reactor->nodes)
-          fusion_entry_destroy_locked( &dev->reactor, &reactor->entry );
-     else
-          fusion_reactor_unlock( reactor );
+	if (!reactor->nodes)
+		fusion_entry_destroy_locked(&dev->reactor, &reactor->entry);
+	else
+		fusion_reactor_unlock(reactor);
 
-     up( &dev->reactor.lock );
+	up(&dev->reactor.lock);
 
-     return 0;
+	return 0;
 }
 
-void
-fusion_reactor_detach_all (FusionDev *dev, FusionID fusion_id)
+void fusion_reactor_detach_all(FusionDev * dev, FusionID fusion_id)
 {
-     FusionLink *l, *n;
-
-     down (&dev->reactor.lock);
-
-     fusion_list_foreach_safe (l, n, dev->reactor.list) {
-          ReactorNode   *node;
-          FusionReactor *reactor = (FusionReactor *) l;
-
-          down (&reactor->entry.lock);
-
-          fusion_list_foreach (node, reactor->nodes) {
-               if (node->fusion_id == fusion_id) {
-                    fusion_list_remove (&reactor->nodes, &node->link);
-                    kfree (node->counts);
-                    kfree (node);
-                    break;
-               }
-          }
-
-          if (reactor->destroyed && !reactor->nodes)
-               fusion_entry_destroy_locked( &dev->reactor, &reactor->entry );
-          else
-               up (&reactor->entry.lock);
-     }
-
-     up (&dev->reactor.lock);
+	FusionLink *l, *n;
+
+	down(&dev->reactor.lock);
+
+	fusion_list_foreach_safe(l, n, dev->reactor.list) {
+		ReactorNode *node;
+		FusionReactor *reactor = (FusionReactor *) l;
+
+		down(&reactor->entry.lock);
+
+		fusion_list_foreach(node, reactor->nodes) {
+			if (node->fusion_id == fusion_id) {
+				fusion_list_remove(&reactor->nodes,
+						   &node->link);
+				kfree(node->counts);
+				kfree(node);
+				break;
+			}
+		}
+
+		if (reactor->destroyed && !reactor->nodes)
+			fusion_entry_destroy_locked(&dev->reactor,
+						    &reactor->entry);
+		else
+			up(&reactor->entry.lock);
+	}
+
+	up(&dev->reactor.lock);
 }
 
 int
-fusion_reactor_fork_all (FusionDev *dev, FusionID fusion_id, FusionID from_id)
+fusion_reactor_fork_all(FusionDev * dev, FusionID fusion_id, FusionID from_id)
 {
-     FusionLink *l;
-     int         ret = 0;
+	FusionLink *l;
+	int ret = 0;
 
-     down (&dev->reactor.lock);
+	down(&dev->reactor.lock);
 
-     fusion_list_foreach (l, dev->reactor.list) {
-          FusionReactor *reactor = (FusionReactor *) l;
+	fusion_list_foreach(l, dev->reactor.list) {
+		FusionReactor *reactor = (FusionReactor *) l;
 
-          ret = fork_node (reactor, fusion_id, from_id);
-          if (ret)
-               break;
-     }
+		ret = fork_node(reactor, fusion_id, from_id);
+		if (ret)
+			break;
+	}
 
-     up (&dev->reactor.lock);
+	up(&dev->reactor.lock);
 
-     return ret;
+	return ret;
 }
 
 /******************************************************************************/
 
 static int
-fork_node (FusionReactor *reactor, FusionID fusion_id, FusionID from_id)
+fork_node(FusionReactor * reactor, FusionID fusion_id, FusionID from_id)
 {
-     ReactorNode *node;
+	ReactorNode *node;
 
-     down (&reactor->entry.lock);
+	down(&reactor->entry.lock);
 
-     fusion_list_foreach (node, reactor->nodes) {
-          if (node->fusion_id == from_id) {
-               ReactorNode *new_node;
+	fusion_list_foreach(node, reactor->nodes) {
+		if (node->fusion_id == from_id) {
+			ReactorNode *new_node;
 
-               new_node = kmalloc (sizeof(ReactorNode), GFP_KERNEL);
-               if (!new_node) {
-                    up (&reactor->entry.lock);
-                    return -ENOMEM;
-               }
+			new_node = kmalloc(sizeof(ReactorNode), GFP_KERNEL);
+			if (!new_node) {
+				up(&reactor->entry.lock);
+				return -ENOMEM;
+			}
 
-               new_node->counts = kmalloc (sizeof(int) * node->num_counts, GFP_KERNEL);
-               if (!new_node->counts) {
-                    kfree( new_node );
-                    up (&reactor->entry.lock);
-                    return -ENOMEM;
-               }
+			new_node->counts =
+			    kmalloc(sizeof(int) * node->num_counts, GFP_KERNEL);
+			if (!new_node->counts) {
+				kfree(new_node);
+				up(&reactor->entry.lock);
+				return -ENOMEM;
+			}
 
-               new_node->fusion_id  = fusion_id;
-               new_node->num_counts = node->num_counts;
+			new_node->fusion_id = fusion_id;
+			new_node->num_counts = node->num_counts;
 
-               memcpy( new_node->counts, node->counts, sizeof(int) * node->num_counts );
+			memcpy(new_node->counts, node->counts,
+			       sizeof(int) * node->num_counts);
 
-               fusion_list_prepend (&reactor->nodes, &new_node->link);
+			fusion_list_prepend(&reactor->nodes, &new_node->link);
 
-               break;
-          }
-     }
+			break;
+		}
+	}
 
-     up (&reactor->entry.lock);
+	up(&reactor->entry.lock);
 
-     return 0;
+	return 0;
 }
 
-static void
-free_all_nodes (FusionReactor *reactor)
-
+static void free_all_nodes(FusionReactor * reactor)
 {
-     FusionLink  *n;
-     ReactorNode *node;
+	FusionLink *n;
+	ReactorNode *node;
 
-     fusion_list_foreach_safe (node, n, reactor->nodes) {
-          kfree (node->counts);
-          kfree (node);
-     }
+	fusion_list_foreach_safe(node, n, reactor->nodes) {
+		kfree(node->counts);
+		kfree(node);
+	}
 
-     reactor->nodes = NULL;
+	reactor->nodes = NULL;
 }
diff --git a/drivers/char/fusion/reactor.h b/drivers/char/fusion/reactor.h
index f4920fe..dde6194 100644
--- a/drivers/char/fusion/reactor.h
+++ b/drivers/char/fusion/reactor.h
@@ -11,57 +11,43 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  */
- 
+
 #ifndef __FUSION__REACTOR_H__
 #define __FUSION__REACTOR_H__
 
 #include "fusiondev.h"
 #include "types.h"
 
-
 /* module init/cleanup */
 
-int  fusion_reactor_init   (FusionDev *dev);
-void fusion_reactor_deinit (FusionDev *dev);
-
+int fusion_reactor_init(FusionDev * dev);
+void fusion_reactor_deinit(FusionDev * dev);
 
 /* public API */
 
-int fusion_reactor_new      (FusionDev  *dev,
-                             int        *id);
-
-int fusion_reactor_attach   (FusionDev  *dev,
-                             int         id,
-                             int         channel,
-                             FusionID    fusion_id);
+int fusion_reactor_new(FusionDev * dev, int *id);
 
-int fusion_reactor_detach   (FusionDev  *dev,
-                             int         id,
-                             int         channel,
-                             FusionID    fusion_id);
+int fusion_reactor_attach(FusionDev * dev,
+			  int id, int channel, FusionID fusion_id);
 
-int fusion_reactor_dispatch (FusionDev  *dev,
-                             int         id,
-                             int         channel,
-                             Fusionee   *fusionee,
-                             int         msg_size,
-                             const void *msg_data);
+int fusion_reactor_detach(FusionDev * dev,
+			  int id, int channel, FusionID fusion_id);
 
-int fusion_reactor_destroy  (FusionDev  *dev,
-                             int         id);
+int fusion_reactor_dispatch(FusionDev * dev,
+			    int id,
+			    int channel,
+			    Fusionee * fusionee,
+			    int msg_size, const void *msg_data);
 
-int fusion_reactor_set_dispatch_callback (FusionDev  *dev,
-                                          int         id,
-                                          int         call_id,
-                                          void       *call_ptr);
+int fusion_reactor_destroy(FusionDev * dev, int id);
 
+int fusion_reactor_set_dispatch_callback(FusionDev * dev,
+					 int id, int call_id, void *call_ptr);
 
 /* internal functions */
 
-void fusion_reactor_detach_all (FusionDev *dev,
-                                FusionID   fusion_id);
+void fusion_reactor_detach_all(FusionDev * dev, FusionID fusion_id);
 
-int  fusion_reactor_fork_all   (FusionDev *dev,
-                                FusionID   fusion_id,
-                                FusionID   from_id);
+int fusion_reactor_fork_all(FusionDev * dev,
+			    FusionID fusion_id, FusionID from_id);
 #endif
diff --git a/drivers/char/fusion/ref.c b/drivers/char/fusion/ref.c
index 161415d..d6ef875 100644
--- a/drivers/char/fusion/ref.c
+++ b/drivers/char/fusion/ref.c
@@ -32,657 +32,604 @@
 typedef struct __Fusion_FusionRef FusionRef;
 
 typedef struct {
-     FusionLink     link;
-     FusionID       fusion_id;
-     int            refs;
+	FusionLink link;
+	FusionID fusion_id;
+	int refs;
 } LocalRef;
 
 typedef struct {
-     FusionLink     link;
-     FusionRef     *ref;
+	FusionLink link;
+	FusionRef *ref;
 } Inheritor;
 
 struct __Fusion_FusionRef {
-     FusionEntry    entry;
+	FusionEntry entry;
 
-     int            global;
-     int            local;
+	int global;
+	int local;
 
-     int            locked;    /* non-zero fusion id of lock owner */
+	int locked;		/* non-zero fusion id of lock owner */
 
-     bool           watched;   /* true if watch has been installed */
-     int            call_id;   /* id of call registered with a watch */
-     int            call_arg;  /* optional call parameter */
+	bool watched;		/* true if watch has been installed */
+	int call_id;		/* id of call registered with a watch */
+	int call_arg;		/* optional call parameter */
 
-     FusionRef     *inherited;
-     FusionLink    *inheritors;
+	FusionRef *inherited;
+	FusionLink *inheritors;
 
-     FusionLink    *local_refs;
+	FusionLink *local_refs;
 };
 
 /**********************************************************************************************************************/
 
-static int  add_local       ( FusionRef *ref, FusionID fusion_id, int add );
-static void clear_local     ( FusionDev *dev, FusionRef *ref, FusionID fusion_id );
-static int  fork_local      ( FusionDev *dev, FusionRef *ref, FusionID fusion_id, FusionID from_id );
-static void free_all_local  ( FusionRef *ref );
+static int add_local(FusionRef * ref, FusionID fusion_id, int add);
+static void clear_local(FusionDev * dev, FusionRef * ref, FusionID fusion_id);
+static int fork_local(FusionDev * dev, FusionRef * ref, FusionID fusion_id,
+		      FusionID from_id);
+static void free_all_local(FusionRef * ref);
 
-static int  propagate_local ( FusionDev *dev, FusionRef *ref, int diff );
+static int propagate_local(FusionDev * dev, FusionRef * ref, int diff);
 
-static void notify_ref      ( FusionDev *dev, FusionRef *ref );
+static void notify_ref(FusionDev * dev, FusionRef * ref);
 
-static int  add_inheritor   ( FusionRef *ref, FusionRef *from );
-static void remove_inheritor( FusionRef *ref, FusionRef *from );
-static void drop_inheritors ( FusionDev *dev, FusionRef *ref );
+static int add_inheritor(FusionRef * ref, FusionRef * from);
+static void remove_inheritor(FusionRef * ref, FusionRef * from);
+static void drop_inheritors(FusionDev * dev, FusionRef * ref);
 
 /**********************************************************************************************************************/
 
-static void
-fusion_ref_destruct( FusionEntry *entry,
-                     void        *ctx )
+static void fusion_ref_destruct(FusionEntry * entry, void *ctx)
 {
-     FusionRef *ref = (FusionRef*) entry;
-     FusionDev *dev = (FusionDev*) ctx;
+	FusionRef *ref = (FusionRef *) entry;
+	FusionDev *dev = (FusionDev *) ctx;
 
-     drop_inheritors( dev, ref );
+	drop_inheritors(dev, ref);
 
-     if (ref->inherited)
-          remove_inheritor( ref, ref->inherited );
+	if (ref->inherited)
+		remove_inheritor(ref, ref->inherited);
 
-     free_all_local( ref );
+	free_all_local(ref);
 }
 
-
-static void
-fusion_ref_print( FusionEntry     *entry,
-                  void            *ctx,
-                  struct seq_file *p )
+static void fusion_ref_print(FusionEntry * entry, void *ctx, struct seq_file *p)
 {
-     FusionRef *ref = (FusionRef*) entry;
+	FusionRef *ref = (FusionRef *) entry;
 
-     if (ref->locked) {
-          seq_printf( p, "%2d %2d (locked by %d)\n", ref->global, ref->local, ref->locked );
-          return;
-     }
+	if (ref->locked) {
+		seq_printf(p, "%2d %2d (locked by %d)\n", ref->global,
+			   ref->local, ref->locked);
+		return;
+	}
 
-     seq_printf( p, "%2d %2d\n", ref->global, ref->local );
+	seq_printf(p, "%2d %2d\n", ref->global, ref->local);
 }
 
-FUSION_ENTRY_CLASS( FusionRef, ref, NULL,
-                    fusion_ref_destruct, fusion_ref_print );
+FUSION_ENTRY_CLASS(FusionRef, ref, NULL, fusion_ref_destruct, fusion_ref_print);
 
 /**********************************************************************************************************************/
 
-int
-fusion_ref_init( FusionDev *dev )
+int fusion_ref_init(FusionDev * dev)
 {
-     fusion_entries_init( &dev->ref, &ref_class, dev );
+	fusion_entries_init(&dev->ref, &ref_class, dev);
 
-     fusion_entries_create_proc_entry( dev, "refs", &dev->ref );
+	fusion_entries_create_proc_entry(dev, "refs", &dev->ref);
 
-     return 0;
+	return 0;
 }
 
-void
-fusion_ref_deinit( FusionDev *dev )
+void fusion_ref_deinit(FusionDev * dev)
 {
-     remove_proc_entry( "refs", dev->proc_dir );
+	remove_proc_entry("refs", dev->proc_dir);
 
-     fusion_entries_deinit( &dev->ref );
+	fusion_entries_deinit(&dev->ref);
 }
 
 /**********************************************************************************************************************/
 
-int
-fusion_ref_new( FusionDev *dev, int *ret_id )
+int fusion_ref_new(FusionDev * dev, int *ret_id)
 {
-     return fusion_entry_create( &dev->ref, ret_id, NULL );
+	return fusion_entry_create(&dev->ref, ret_id, NULL);
 }
 
-int
-fusion_ref_up (FusionDev *dev, int id, FusionID fusion_id)
+int fusion_ref_up(FusionDev * dev, int id, FusionID fusion_id)
 {
-     int        ret;
-     FusionRef *ref;
+	int ret;
+	FusionRef *ref;
 
-     ret = fusion_ref_lock( &dev->ref, id, true, &ref );
-     if (ret)
-          return ret;
+	ret = fusion_ref_lock(&dev->ref, id, true, &ref);
+	if (ret)
+		return ret;
 
-     dev->stat.ref_up++;
+	dev->stat.ref_up++;
 
-     if (ref->locked) {
-          ret = -EAGAIN;
-          goto out;
-     }
+	if (ref->locked) {
+		ret = -EAGAIN;
+		goto out;
+	}
 
-     if (fusion_id) {
-          ret = add_local (ref, fusion_id, 1);
-          if (ret)
-               goto out;
+	if (fusion_id) {
+		ret = add_local(ref, fusion_id, 1);
+		if (ret)
+			goto out;
 
-          ret = propagate_local( dev, ref, 1 );
-     }
-     else
-          ref->global++;
+		ret = propagate_local(dev, ref, 1);
+	} else
+		ref->global ++;
 
+      out:
+	fusion_ref_unlock(ref);
+	up(&dev->ref.lock);
 
-out:
-     fusion_ref_unlock( ref );
-     up( &dev->ref.lock );
-
-     return ret;
+	return ret;
 }
 
-int
-fusion_ref_down (FusionDev *dev, int id, FusionID fusion_id)
+int fusion_ref_down(FusionDev * dev, int id, FusionID fusion_id)
 {
-     int        ret;
-     FusionRef *ref;
+	int ret;
+	FusionRef *ref;
 
-     ret = fusion_ref_lock( &dev->ref, id, true, &ref );
-     if (ret)
-          return ret;
+	ret = fusion_ref_lock(&dev->ref, id, true, &ref);
+	if (ret)
+		return ret;
 
-     dev->stat.ref_down++;
+	dev->stat.ref_down++;
 
-     if (ref->locked) {
-          ret = -EAGAIN;
-          goto out;
-     }
+	if (ref->locked) {
+		ret = -EAGAIN;
+		goto out;
+	}
 
-     if (fusion_id) {
-          ret = -EIO;
-          if (!ref->local)
-               goto out;
+	if (fusion_id) {
+		ret = -EIO;
+		if (!ref->local)
+			goto out;
 
-          ret = add_local (ref, fusion_id, -1);
-          if (ret)
-               goto out;
+		ret = add_local(ref, fusion_id, -1);
+		if (ret)
+			goto out;
 
-          ret = propagate_local( dev, ref, -1 );
-     }
-     else {
-          if (!ref->global) {
-               ret = -EIO;
-               goto out;
-          }
+		ret = propagate_local(dev, ref, -1);
+	} else {
+		if (!ref->global) {
+			ret = -EIO;
+			goto out;
+		}
 
-          ref->global--;
+		ref->global --;
 
-          if (ref->local + ref->global == 0)
-               notify_ref (dev, ref);
-     }
+		if (ref->local + ref->global == 0)
+			notify_ref(dev, ref);
+	}
 
+      out:
+	fusion_ref_unlock(ref);
+	up(&dev->ref.lock);
 
-out:
-     fusion_ref_unlock( ref );
-     up( &dev->ref.lock );
-
-     return ret;
+	return ret;
 }
 
-int
-fusion_ref_zero_lock (FusionDev *dev, int id, FusionID fusion_id)
+int fusion_ref_zero_lock(FusionDev * dev, int id, FusionID fusion_id)
 {
-     int        ret;
-     FusionRef *ref;
-
-     ret = fusion_ref_lock( &dev->ref, id, false, &ref );
-     if (ret)
-          return ret;
-
-     while (true) {
-          if (ref->watched) {
-               fusion_ref_unlock( ref );
-               return -EACCES;
-          }
-
-          if (ref->locked) {
-               fusion_ref_unlock( ref );
-               return ref->locked == fusion_id ? -EIO : -EAGAIN;
-          }
-
-          if (ref->global || ref->local) {
-               ret = fusion_ref_wait( ref, NULL );
-               if (ret)
-                    return ret;
-          }
-          else
-               break;
-     }
-
-     ref->locked = fusion_id;
-
-     fusion_ref_unlock( ref );
-
-     return 0;
+	int ret;
+	FusionRef *ref;
+
+	ret = fusion_ref_lock(&dev->ref, id, false, &ref);
+	if (ret)
+		return ret;
+
+	while (true) {
+		if (ref->watched) {
+			fusion_ref_unlock(ref);
+			return -EACCES;
+		}
+
+		if (ref->locked) {
+			fusion_ref_unlock(ref);
+			return ref->locked == fusion_id ? -EIO : -EAGAIN;
+		}
+
+		if (ref->global ||ref->local) {
+			ret = fusion_ref_wait(ref, NULL);
+			if (ret)
+				return ret;
+		} else
+			break;
+	}
+
+	ref->locked = fusion_id;
+
+	fusion_ref_unlock(ref);
+
+	return 0;
 }
 
-int
-fusion_ref_zero_trylock (FusionDev *dev, int id, FusionID fusion_id)
+int fusion_ref_zero_trylock(FusionDev * dev, int id, FusionID fusion_id)
 {
-     int        ret;
-     FusionRef *ref;
+	int ret;
+	FusionRef *ref;
 
-     ret = fusion_ref_lock( &dev->ref, id, false, &ref );
-     if (ret)
-          return ret;
+	ret = fusion_ref_lock(&dev->ref, id, false, &ref);
+	if (ret)
+		return ret;
 
-     if (ref->locked) {
-          fusion_ref_unlock( ref );
-          return ref->locked == fusion_id ? -EIO : -EAGAIN;
-     }
+	if (ref->locked) {
+		fusion_ref_unlock(ref);
+		return ref->locked == fusion_id ? -EIO : -EAGAIN;
+	}
 
-     if (ref->global || ref->local)
-          ret = -ETOOMANYREFS;
-     else
-          ref->locked = fusion_id;
+	if (ref->global ||ref->local)
+		ret = -ETOOMANYREFS;
+	else
+		ref->locked = fusion_id;
 
-     fusion_ref_unlock( ref );
+	fusion_ref_unlock(ref);
 
-     return ret;
+	return ret;
 }
 
-int
-fusion_ref_zero_unlock (FusionDev *dev, int id, FusionID fusion_id)
+int fusion_ref_zero_unlock(FusionDev * dev, int id, FusionID fusion_id)
 {
-     int        ret;
-     FusionRef *ref;
+	int ret;
+	FusionRef *ref;
 
-     ret = fusion_ref_lock( &dev->ref, id, false, &ref );
-     if (ret)
-          return ret;
+	ret = fusion_ref_lock(&dev->ref, id, false, &ref);
+	if (ret)
+		return ret;
 
-     if (ref->locked != fusion_id) {
-          fusion_ref_unlock( ref );
-          return -EIO;
-     }
+	if (ref->locked != fusion_id) {
+		fusion_ref_unlock(ref);
+		return -EIO;
+	}
 
-     ref->locked = 0;
+	ref->locked = 0;
 
-     fusion_ref_unlock( ref );
+	fusion_ref_unlock(ref);
 
-     return 0;
+	return 0;
 }
 
-int
-fusion_ref_stat (FusionDev *dev, int id, int *refs)
+int fusion_ref_stat(FusionDev * dev, int id, int *refs)
 {
-     int        ret;
-     FusionRef *ref;
+	int ret;
+	FusionRef *ref;
 
-     ret = fusion_ref_lock( &dev->ref, id, false, &ref );
-     if (ret)
-          return ret;
+	ret = fusion_ref_lock(&dev->ref, id, false, &ref);
+	if (ret)
+		return ret;
 
-     *refs = ref->global + ref->local;
+	*refs = ref->global +ref->local;
 
-     fusion_ref_unlock( ref );
+	fusion_ref_unlock(ref);
 
-     return 0;
+	return 0;
 }
 
-int
-fusion_ref_watch (FusionDev      *dev,
-                  int             id,
-                  int             call_id,
-                  int             call_arg)
+int fusion_ref_watch(FusionDev * dev, int id, int call_id, int call_arg)
 {
-     int        ret;
-     FusionRef *ref;
+	int ret;
+	FusionRef *ref;
 
-     ret = fusion_ref_lock( &dev->ref, id, false, &ref );
-     if (ret)
-          return ret;
+	ret = fusion_ref_lock(&dev->ref, id, false, &ref);
+	if (ret)
+		return ret;
 
-     if (ref->entry.pid != current->pid) {
-          fusion_ref_unlock( ref );
-          return -EACCES;
-     }
+	if (ref->entry.pid != current->pid) {
+		fusion_ref_unlock(ref);
+		return -EACCES;
+	}
 
-     if (ref->global + ref->local == 0) {
-          fusion_ref_unlock( ref );
-          return -EIO;
-     }
+	if (ref->global +ref->local == 0) {
+		fusion_ref_unlock(ref);
+		return -EIO;
+	}
 
-     if (ref->watched) {
-          fusion_ref_unlock( ref );
-          return -EBUSY;
-     }
+	if (ref->watched) {
+		fusion_ref_unlock(ref);
+		return -EBUSY;
+	}
 
-     ref->watched  = true;
-     ref->call_id  = call_id;
-     ref->call_arg = call_arg;
+	ref->watched = true;
+	ref->call_id = call_id;
+	ref->call_arg = call_arg;
 
-     fusion_ref_notify( ref, true );
+	fusion_ref_notify(ref, true);
 
-     fusion_ref_unlock( ref );
+	fusion_ref_unlock(ref);
 
-     return 0;
+	return 0;
 }
 
-int
-fusion_ref_inherit (FusionDev *dev,
-                    int        id,
-                    int        from_id)
+int fusion_ref_inherit(FusionDev * dev, int id, int from_id)
 {
-     int        ret;
-     FusionRef *ref;
-     FusionRef *from = NULL;
-
-     ret = fusion_ref_lock( &dev->ref, id, true, &ref );
-     if (ret)
-          return ret;
-
-     ret = -EBUSY;
-     if (ref->inherited)
-          goto out;
-
-     ret = -EINVAL;
-     fusion_list_foreach (from, dev->ref.list) {
-          if (from->entry.id == from_id) {
-               if (down_interruptible( &from->entry.lock )) {
-                    ret  = -EINTR;
-                    from = NULL;
-               }
-
-               break;
-          }
-     }
-     if (!from)
-          goto out;
-
-     ret = add_inheritor( ref, from );
-     if (ret)
-          goto out;
-
-     ret = propagate_local( dev, ref, from->local );
-     if (ret)
-          goto out;
-
-     ref->inherited = from;
-
-out:
-     if (from)
-          up( &from->entry.lock );
-
-     fusion_ref_unlock( ref );
-     up ( &dev->ref.lock );
-
-     return ret;
+	int ret;
+	FusionRef *ref;
+	FusionRef *from = NULL;
+
+	ret = fusion_ref_lock(&dev->ref, id, true, &ref);
+	if (ret)
+		return ret;
+
+	ret = -EBUSY;
+	if (ref->inherited)
+		goto out;
+
+	ret = -EINVAL;
+	fusion_list_foreach(from, dev->ref.list) {
+		if (from->entry.id == from_id) {
+			if (down_interruptible(&from->entry.lock)) {
+				ret = -EINTR;
+				from = NULL;
+			}
+
+			break;
+		}
+	}
+	if (!from)
+		goto out;
+
+	ret = add_inheritor(ref, from);
+	if (ret)
+		goto out;
+
+	ret = propagate_local(dev, ref, from->local);
+	if (ret)
+		goto out;
+
+	ref->inherited = from;
+
+      out:
+	if (from)
+		up(&from->entry.lock);
+
+	fusion_ref_unlock(ref);
+	up(&dev->ref.lock);
+
+	return ret;
 }
 
-int
-fusion_ref_destroy (FusionDev *dev, int id)
+int fusion_ref_destroy(FusionDev * dev, int id)
 {
-     return fusion_entry_destroy( &dev->ref, id );
+	return fusion_entry_destroy(&dev->ref, id);
 }
 
-void
-fusion_ref_clear_all_local( FusionDev *dev, FusionID fusion_id )
+void fusion_ref_clear_all_local(FusionDev * dev, FusionID fusion_id)
 {
-     FusionRef *ref;
+	FusionRef *ref;
 
-     down( &dev->ref.lock );
+	down(&dev->ref.lock);
 
-     fusion_list_foreach (ref, dev->ref.list)
-          clear_local( dev, ref, fusion_id );
+	fusion_list_foreach(ref, dev->ref.list)
+	    clear_local(dev, ref, fusion_id);
 
-     up( &dev->ref.lock );
+	up(&dev->ref.lock);
 }
 
 int
-fusion_ref_fork_all_local( FusionDev *dev, FusionID fusion_id, FusionID from_id )
+fusion_ref_fork_all_local(FusionDev * dev, FusionID fusion_id, FusionID from_id)
 {
-     FusionRef *ref;
-     int        ret = 0;
+	FusionRef *ref;
+	int ret = 0;
 
-     down( &dev->ref.lock );
+	down(&dev->ref.lock);
 
-     fusion_list_foreach (ref, dev->ref.list) {
-          ret = fork_local( dev, ref, fusion_id, from_id );
-          if (ret)
-               break;
-     }
+	fusion_list_foreach(ref, dev->ref.list) {
+		ret = fork_local(dev, ref, fusion_id, from_id);
+		if (ret)
+			break;
+	}
 
-     up( &dev->ref.lock );
+	up(&dev->ref.lock);
 
-     return ret;
+	return ret;
 }
 
 /**********************************************************************************************************************/
 
-static int
-add_local (FusionRef *ref, FusionID fusion_id, int add)
+static int add_local(FusionRef * ref, FusionID fusion_id, int add)
 {
-     FusionLink *l;
-     LocalRef   *local;
+	FusionLink *l;
+	LocalRef *local;
 
-     fusion_list_foreach (l, ref->local_refs) {
-          local = (LocalRef *) l;
+	fusion_list_foreach(l, ref->local_refs) {
+		local = (LocalRef *) l;
 
-          if (local->fusion_id == fusion_id) {
-               fusion_list_move_to_front( &ref->local_refs, l );
+		if (local->fusion_id == fusion_id) {
+			fusion_list_move_to_front(&ref->local_refs, l);
 
-               if (local->refs + add < 0)
-                    return -EIO;
+			if (local->refs + add < 0)
+				return -EIO;
 
-               local->refs += add;
-               return 0;
-          }
-     }
+			local->refs += add;
+			return 0;
+		}
+	}
 
-     /* Can only create local node if value is positive. */
-     if (add <= 0)
-          return -EIO;
+	/* Can only create local node if value is positive. */
+	if (add <= 0)
+		return -EIO;
 
-     local = kmalloc (sizeof(LocalRef), GFP_KERNEL);
-     if (!local)
-          return -ENOMEM;
+	local = kmalloc(sizeof(LocalRef), GFP_KERNEL);
+	if (!local)
+		return -ENOMEM;
 
-     local->fusion_id = fusion_id;
-     local->refs      = add;
+	local->fusion_id = fusion_id;
+	local->refs = add;
 
-     fusion_list_prepend (&ref->local_refs, &local->link);
+	fusion_list_prepend(&ref->local_refs, &local->link);
 
-     return 0;
+	return 0;
 }
 
-static void
-clear_local (FusionDev *dev, FusionRef *ref, FusionID fusion_id)
+static void clear_local(FusionDev * dev, FusionRef * ref, FusionID fusion_id)
 {
-     FusionLink *l;
+	FusionLink *l;
 
-     down (&ref->entry.lock);
+	down(&ref->entry.lock);
 
-     if (ref->locked == fusion_id) {
-          ref->locked = 0;
-          wake_up_interruptible_all (&ref->entry.wait);
-     }
+	if (ref->locked == fusion_id) {
+		ref->locked = 0;
+		wake_up_interruptible_all(&ref->entry.wait);
+	}
 
-     fusion_list_foreach (l, ref->local_refs) {
-          LocalRef *local = (LocalRef *) l;
+	fusion_list_foreach(l, ref->local_refs) {
+		LocalRef *local = (LocalRef *) l;
 
-          if (local->fusion_id == fusion_id) {
-               if (local->refs)
-                    propagate_local( dev, ref, - local->refs );
+		if (local->fusion_id == fusion_id) {
+			if (local->refs)
+				propagate_local(dev, ref, -local->refs);
 
-               fusion_list_remove( &ref->local_refs, l );
+			fusion_list_remove(&ref->local_refs, l);
 
-               kfree (l);
-               break;
-          }
-     }
+			kfree(l);
+			break;
+		}
+	}
 
-     up (&ref->entry.lock);
+	up(&ref->entry.lock);
 }
 
 static int
-fork_local (FusionDev *dev, FusionRef *ref, FusionID fusion_id, FusionID from_id)
+fork_local(FusionDev * dev, FusionRef * ref, FusionID fusion_id,
+	   FusionID from_id)
 {
-     FusionLink *l;
-     int         ret = 0;
-
-     down (&ref->entry.lock);
-
-     fusion_list_foreach (l, ref->local_refs) {
-          LocalRef *local = (LocalRef *) l;
+	FusionLink *l;
+	int ret = 0;
 
-          if (local->fusion_id == from_id) {
-               if (local->refs) {
-#if 0
-                    LocalRef *new_local;
+	down(&ref->entry.lock);
 
-                    new_local = kmalloc (sizeof(LocalRef), GFP_KERNEL);
-                    if (!new_local) {
-                         ret = -ENOMEM;
-                         break;
-                    }
+	fusion_list_foreach(l, ref->local_refs) {
+		LocalRef *local = (LocalRef *) l;
 
-                    new_local->fusion_id = fusion_id;
-                    new_local->refs      = local->refs;
+		if (local->fusion_id == from_id) {
+			if (local->refs) {
+				local->refs++;
+			}
+			break;
+		}
+	}
 
-                    fusion_list_prepend( &ref->local_refs, &new_local->link );
+	up(&ref->entry.lock);
 
-                    propagate_local( dev, ref, local->refs );
-#else
-                    local->refs++;
-#endif
-               }
-               break;
-          }
-     }
-
-     up (&ref->entry.lock);
-
-     return ret;
+	return ret;
 }
 
-static void
-free_all_local (FusionRef *ref)
+static void free_all_local(FusionRef * ref)
 {
-     FusionLink *l = ref->local_refs;
+	FusionLink *l = ref->local_refs;
 
-     while (l) {
-          FusionLink *next = l->next;
+	while (l) {
+		FusionLink *next = l->next;
 
-          kfree (l);
+		kfree(l);
 
-          l = next;
-     }
+		l = next;
+	}
 
-     ref->local_refs = NULL;
+	ref->local_refs = NULL;
 }
 
-static void
-notify_ref (FusionDev *dev, FusionRef *ref)
+static void notify_ref(FusionDev * dev, FusionRef * ref)
 {
-     if (ref->watched) {
-          FusionCallExecute execute;
+	if (ref->watched) {
+		FusionCallExecute execute;
 
-          execute.call_id  = ref->call_id;
-          execute.call_arg = ref->call_arg;
-          execute.call_ptr = NULL;
+		execute.call_id = ref->call_id;
+		execute.call_arg = ref->call_arg;
+		execute.call_ptr = NULL;
 
-          fusion_call_execute (dev, 0, &execute);
-     }
-     else
-          wake_up_interruptible_all (&ref->entry.wait);
+		fusion_call_execute(dev, 0, &execute);
+	} else
+		wake_up_interruptible_all(&ref->entry.wait);
 }
 
-static int
-propagate_local( FusionDev *dev, FusionRef *ref, int diff )
+static int propagate_local(FusionDev * dev, FusionRef * ref, int diff)
 {
-     FusionLink *l;
+	FusionLink *l;
 
-     /* Recurse into inheritors. */
-     fusion_list_foreach (l, ref->inheritors) {
-          FusionRef *inheritor = ((Inheritor*) l)->ref;
+	/* Recurse into inheritors. */
+	fusion_list_foreach(l, ref->inheritors) {
+		FusionRef *inheritor = ((Inheritor *) l)->ref;
 
-          if (down_interruptible( &inheritor->entry.lock )) {
-               printk( KERN_ERR "fusion_ref: propagate_local() interrupted!\n" );
-               //return -EINTR;
-          }
+		if (down_interruptible(&inheritor->entry.lock)) {
+			printk(KERN_ERR
+			       "fusion_ref: propagate_local() interrupted!\n");
+			/* return -EINTR; */
+		}
 
-          propagate_local( dev, inheritor, diff );
+		propagate_local(dev, inheritor, diff);
 
-          up( &inheritor->entry.lock );
-     }
+		up(&inheritor->entry.lock);
+	}
 
-     /* Apply difference. */
-     ref->local += diff;
+	/* Apply difference. */
+	ref->local += diff;
 
-     /* Notify zero count. */
-     if (ref->local + ref->global == 0)
-          notify_ref( dev, ref );
+	/* Notify zero count. */
+	if (ref->local + ref->global == 0)
+		notify_ref(dev, ref);
 
-     return 0;
+	return 0;
 }
 
-static int
-add_inheritor(FusionRef *ref, FusionRef *from)
+static int add_inheritor(FusionRef * ref, FusionRef * from)
 {
-     Inheritor *inheritor;
+	Inheritor *inheritor;
 
-     inheritor = kmalloc (sizeof(Inheritor), GFP_KERNEL);
-     if (!inheritor)
-          return -ENOMEM;
+	inheritor = kmalloc(sizeof(Inheritor), GFP_KERNEL);
+	if (!inheritor)
+		return -ENOMEM;
 
-     inheritor->ref = ref;
+	inheritor->ref = ref;
 
-     fusion_list_prepend( &from->inheritors, &inheritor->link );
+	fusion_list_prepend(&from->inheritors, &inheritor->link);
 
-     return 0;
+	return 0;
 }
 
-static void
-remove_inheritor(FusionRef *ref, FusionRef *from)
+static void remove_inheritor(FusionRef * ref, FusionRef * from)
 {
-     FusionLink *l;
+	FusionLink *l;
 
-     down( &from->entry.lock );
+	down(&from->entry.lock);
 
-     fusion_list_foreach (l, from->inheritors) {
-          Inheritor *inheritor = (Inheritor*) l;
+	fusion_list_foreach(l, from->inheritors) {
+		Inheritor *inheritor = (Inheritor *) l;
 
-          if (inheritor->ref == ref) {
-               fusion_list_remove( &from->inheritors, &inheritor->link );
+		if (inheritor->ref == ref) {
+			fusion_list_remove(&from->inheritors, &inheritor->link);
 
-               kfree( l );
-               break;
-          }
-     }
+			kfree(l);
+			break;
+		}
+	}
 
-     up( &from->entry.lock );
+	up(&from->entry.lock);
 }
 
-static void
-drop_inheritors( FusionDev *dev, FusionRef *ref )
+static void drop_inheritors(FusionDev * dev, FusionRef * ref)
 {
-     FusionLink *l = ref->inheritors;
-
-     while (l) {
-          FusionLink *next      = l->next;
-          FusionRef  *inheritor = ((Inheritor*) l)->ref;
+	FusionLink *l = ref->inheritors;
 
-          if (down_interruptible( &inheritor->entry.lock )) {
-               printk( KERN_ERR "fusion_ref: drop_inheritors() interrupted!\n" );
-               //return;
-          }
+	while (l) {
+		FusionLink *next = l->next;
+		FusionRef *inheritor = ((Inheritor *) l)->ref;
 
-          propagate_local( dev, inheritor, - ref->local );
+		if (down_interruptible(&inheritor->entry.lock)) {
+			printk(KERN_ERR
+			       "fusion_ref: drop_inheritors() interrupted!\n");
+			/* return; */
+		}
 
-          inheritor->inherited = NULL;
+		propagate_local(dev, inheritor, -ref->local);
 
-          up( &inheritor->entry.lock );
+		inheritor->inherited = NULL;
 
+		up(&inheritor->entry.lock);
 
-          kfree (l);
+		kfree(l);
 
-          l = next;
-     }
+		l = next;
+	}
 
-     ref->inheritors = NULL;
+	ref->inheritors = NULL;
 }
-
diff --git a/drivers/char/fusion/ref.h b/drivers/char/fusion/ref.h
index ba7f303..9ccec54 100644
--- a/drivers/char/fusion/ref.h
+++ b/drivers/char/fusion/ref.h
@@ -18,62 +18,38 @@
 #include "fusiondev.h"
 #include "types.h"
 
-
 /* module init/cleanup */
 
-int  fusion_ref_init   (FusionDev *dev);
-void fusion_ref_deinit (FusionDev *dev);
-
+int fusion_ref_init(FusionDev * dev);
+void fusion_ref_deinit(FusionDev * dev);
 
 /* public API */
 
-int fusion_ref_new          (FusionDev      *dev,
-                             int            *id);
-
-int fusion_ref_up           (FusionDev      *dev,
-                             int             id,
-                             FusionID        fusion_id);
+int fusion_ref_new(FusionDev * dev, int *id);
 
-int fusion_ref_down         (FusionDev      *dev,
-                             int             id,
-                             FusionID        fusion_id);
+int fusion_ref_up(FusionDev * dev, int id, FusionID fusion_id);
 
-int fusion_ref_zero_lock    (FusionDev      *dev,
-                             int             id,
-                             FusionID        fusion_id);
+int fusion_ref_down(FusionDev * dev, int id, FusionID fusion_id);
 
-int fusion_ref_zero_trylock (FusionDev      *dev,
-                             int             id,
-                             FusionID        fusion_id);
+int fusion_ref_zero_lock(FusionDev * dev, int id, FusionID fusion_id);
 
-int fusion_ref_zero_unlock  (FusionDev      *dev,
-                             int             id,
-                             FusionID        fusion_id);
+int fusion_ref_zero_trylock(FusionDev * dev, int id, FusionID fusion_id);
 
-int fusion_ref_stat         (FusionDev      *dev,
-                             int             id,
-                             int            *refs);
+int fusion_ref_zero_unlock(FusionDev * dev, int id, FusionID fusion_id);
 
-int fusion_ref_watch        (FusionDev      *dev,
-                             int             id,
-                             int             call_id,
-                             int             call_arg);
+int fusion_ref_stat(FusionDev * dev, int id, int *refs);
 
-int fusion_ref_inherit      (FusionDev      *dev,
-                             int             id,
-                             int             from);
+int fusion_ref_watch(FusionDev * dev, int id, int call_id, int call_arg);
 
-int fusion_ref_destroy      (FusionDev      *dev,
-                             int             id);
+int fusion_ref_inherit(FusionDev * dev, int id, int from);
 
+int fusion_ref_destroy(FusionDev * dev, int id);
 
 /* internal functions */
 
-void fusion_ref_clear_all_local (FusionDev *dev,
-                                 FusionID   fusion_id);
+void fusion_ref_clear_all_local(FusionDev * dev, FusionID fusion_id);
 
-int  fusion_ref_fork_all_local  (FusionDev *dev,
-                                 FusionID   fusion_id,
-                                 FusionID   from_id);
+int fusion_ref_fork_all_local(FusionDev * dev,
+			      FusionID fusion_id, FusionID from_id);
 
 #endif
diff --git a/drivers/char/fusion/shmpool.c b/drivers/char/fusion/shmpool.c
index c086bf2..af63d14 100644
--- a/drivers/char/fusion/shmpool.c
+++ b/drivers/char/fusion/shmpool.c
@@ -30,414 +30,387 @@
 #include "list.h"
 #include "shmpool.h"
 
-
-
 typedef struct {
-     FusionLink         link;
-     unsigned long      next_base;
+	FusionLink link;
+	unsigned long next_base;
 } AddrEntry;
 
-
 typedef struct {
-     FusionLink         link;
+	FusionLink link;
 
-     FusionID           fusion_id;
+	FusionID fusion_id;
 
-     int                count;     /* number of attach calls */
+	int count;		/* number of attach calls */
 } SHMPoolNode;
 
 typedef struct {
-     FusionEntry        entry;
+	FusionEntry entry;
 
-     int                max_size;
+	int max_size;
 
-     void              *addr_base;
-     int                size;
+	void *addr_base;
+	int size;
 
-     AddrEntry         *addr_entry;
+	AddrEntry *addr_entry;
 
-     FusionLink        *nodes;
+	FusionLink *nodes;
 
-     int                dispatch_count;
+	int dispatch_count;
 } FusionSHMPool;
 
 /******************************************************************************/
 
-static SHMPoolNode *get_node      ( FusionSHMPool *shmpool,
-                                    FusionID       fusion_id );
+static SHMPoolNode *get_node(FusionSHMPool * shmpool, FusionID fusion_id);
 
-static void         remove_node   ( FusionSHMPool *shmpool,
-                                    FusionID       fusion_id );
+static void remove_node(FusionSHMPool * shmpool, FusionID fusion_id);
 
-static int          fork_node     ( FusionSHMPool *shmpool,
-                                    FusionID       fusion_id,
-                                    FusionID       from_id );
+static int fork_node(FusionSHMPool * shmpool,
+		     FusionID fusion_id, FusionID from_id);
 
-static void         free_all_nodes( FusionSHMPool *shmpool );
+static void free_all_nodes(FusionSHMPool * shmpool);
 
 /******************************************************************************/
 
-
-static DECLARE_MUTEX (addr_lock);
-static FusionLink    *addr_entries;
-static unsigned long  addr_base = FUSION_SHM_BASE;
+static DECLARE_MUTEX(addr_lock);
+static FusionLink *addr_entries;
+static unsigned long addr_base = FUSION_SHM_BASE;
 
 /******************************************************************************/
 
-static AddrEntry *
-add_addr_entry( unsigned long next_base )
+static AddrEntry *add_addr_entry(unsigned long next_base)
 {
-     AddrEntry *entry = kmalloc( sizeof(AddrEntry), GFP_KERNEL );
+	AddrEntry *entry = kmalloc(sizeof(AddrEntry), GFP_KERNEL);
 
-     entry->next_base = next_base;
+	entry->next_base = next_base;
 
-     fusion_list_prepend( &addr_entries, &entry->link );
+	fusion_list_prepend(&addr_entries, &entry->link);
 
-     return entry;
+	return entry;
 }
 
 /******************************************************************************/
 
 static int
-fusion_shmpool_construct( FusionEntry *entry,
-                          void        *ctx,
-                          void        *create_ctx )
+fusion_shmpool_construct(FusionEntry * entry, void *ctx, void *create_ctx)
 {
-     FusionSHMPool    *shmpool = (FusionSHMPool*) entry;
-     FusionSHMPoolNew *poolnew = create_ctx;
+	FusionSHMPool *shmpool = (FusionSHMPool *) entry;
+	FusionSHMPoolNew *poolnew = create_ctx;
 
-     down( &addr_lock );
+	down(&addr_lock);
 
-     if (addr_base + poolnew->max_size >= FUSION_SHM_BASE + FUSION_SHM_SIZE) {
-          up( &addr_lock );
-          printk( KERN_WARNING "%s: virtual address space exhausted! (FIXME)\n", __FUNCTION__ );
-          return -ENOSPC;
-     }
+	if (addr_base + poolnew->max_size >= FUSION_SHM_BASE + FUSION_SHM_SIZE) {
+		up(&addr_lock);
+		printk(KERN_WARNING
+		       "%s: virtual address space exhausted! (FIXME)\n",
+		       __FUNCTION__);
+		return -ENOSPC;
+	}
 
-     shmpool->max_size  = poolnew->max_size;
-     shmpool->addr_base = poolnew->addr_base = (void*) addr_base;
+	shmpool->max_size = poolnew->max_size;
+	shmpool->addr_base = poolnew->addr_base = (void *)addr_base;
 
-     addr_base = (addr_base + PAGE_ALIGN(poolnew->max_size) + PAGE_SIZE + 0xffff) & ~0xffff;
+	addr_base =
+	    (addr_base + PAGE_ALIGN(poolnew->max_size) + PAGE_SIZE +
+	     0xffff) & ~0xffff;
 
-     shmpool->addr_entry = add_addr_entry( addr_base );
+	shmpool->addr_entry = add_addr_entry(addr_base);
 
-     up( &addr_lock );
+	up(&addr_lock);
 
-     return 0;
+	return 0;
 }
 
-static void
-fusion_shmpool_destruct( FusionEntry *entry,
-                         void        *ctx )
+static void fusion_shmpool_destruct(FusionEntry * entry, void *ctx)
 {
-     AddrEntry     *addr_entry;
-     FusionSHMPool *shmpool = (FusionSHMPool*) entry;
-
-     free_all_nodes( shmpool );
+	AddrEntry *addr_entry;
+	FusionSHMPool *shmpool = (FusionSHMPool *) entry;
 
+	free_all_nodes(shmpool);
 
-     down( &addr_lock );
+	down(&addr_lock);
 
-     fusion_list_remove( &addr_entries, &shmpool->addr_entry->link );
+	fusion_list_remove(&addr_entries, &shmpool->addr_entry->link);
 
+	/*
+	 * free trailing address space
+	 */
 
-     /*
-      * free trailing address space
-      */
+	addr_base = FUSION_SHM_BASE;
 
-     addr_base = FUSION_SHM_BASE;
+	fusion_list_foreach(addr_entry, addr_entries) {
+		if (addr_entry->next_base > addr_base)
+			addr_base = addr_entry->next_base;
+	}
 
-     fusion_list_foreach (addr_entry, addr_entries) {
-          if (addr_entry->next_base > addr_base)
-               addr_base = addr_entry->next_base;
-     }
-
-     up( &addr_lock );
+	up(&addr_lock);
 }
 
 static void
-fusion_shmpool_print( FusionEntry     *entry,
-                      void            *ctx,
-                      struct seq_file *p )
+fusion_shmpool_print(FusionEntry * entry, void *ctx, struct seq_file *p)
 {
-     int            num     = 0;
-     FusionSHMPool *shmpool = (FusionSHMPool*) entry;
-     FusionLink    *node    = shmpool->nodes;
+	int num = 0;
+	FusionSHMPool *shmpool = (FusionSHMPool *) entry;
+	FusionLink *node = shmpool->nodes;
 
-     fusion_list_foreach (node, shmpool->nodes) {
-          num++;
-     }
+	fusion_list_foreach(node, shmpool->nodes) {
+		num++;
+	}
 
-     seq_printf( p, "0x%p [0x%x] - 0x%x, %dx dispatch, %d nodes\n",
-                 shmpool->addr_base, shmpool->max_size, shmpool->size,
-                 shmpool->dispatch_count, num );
+	seq_printf(p, "0x%p [0x%x] - 0x%x, %dx dispatch, %d nodes\n",
+		   shmpool->addr_base, shmpool->max_size, shmpool->size,
+		   shmpool->dispatch_count, num);
 }
 
-
-FUSION_ENTRY_CLASS( FusionSHMPool, shmpool, fusion_shmpool_construct,
-                    fusion_shmpool_destruct, fusion_shmpool_print )
+FUSION_ENTRY_CLASS(FusionSHMPool, shmpool, fusion_shmpool_construct,
+		   fusion_shmpool_destruct, fusion_shmpool_print)
 
 /******************************************************************************/
-
-int
-fusion_shmpool_init (FusionDev *dev)
+int fusion_shmpool_init(FusionDev * dev)
 {
-     fusion_entries_init( &dev->shmpool, &shmpool_class, dev );
+	fusion_entries_init(&dev->shmpool, &shmpool_class, dev);
 
-     fusion_entries_create_proc_entry( dev, "shmpools", &dev->shmpool );
+	fusion_entries_create_proc_entry(dev, "shmpools", &dev->shmpool);
 
-     return 0;
+	return 0;
 }
 
-void
-fusion_shmpool_deinit (FusionDev *dev)
+void fusion_shmpool_deinit(FusionDev * dev)
 {
-     remove_proc_entry ("shmpools", dev->proc_dir);
+	remove_proc_entry("shmpools", dev->proc_dir);
 
-     fusion_entries_deinit( &dev->shmpool );
+	fusion_entries_deinit(&dev->shmpool);
 }
 
 /******************************************************************************/
 
-int
-fusion_shmpool_new (FusionDev        *dev,
-                    FusionSHMPoolNew *pool)
+int fusion_shmpool_new(FusionDev * dev, FusionSHMPoolNew * pool)
 {
-     if (pool->max_size <= 0)
-          return -EINVAL;
+	if (pool->max_size <= 0)
+		return -EINVAL;
 
-     return fusion_entry_create( &dev->shmpool, &pool->pool_id, pool );
+	return fusion_entry_create(&dev->shmpool, &pool->pool_id, pool);
 }
 
 int
-fusion_shmpool_attach (FusionDev           *dev,
-                       FusionSHMPoolAttach *attach,
-                       FusionID             fusion_id)
+fusion_shmpool_attach(FusionDev * dev,
+		      FusionSHMPoolAttach * attach, FusionID fusion_id)
 {
-     int            ret;
-     SHMPoolNode   *node;
-     FusionSHMPool *shmpool;
+	int ret;
+	SHMPoolNode *node;
+	FusionSHMPool *shmpool;
 
-     ret = fusion_shmpool_lock( &dev->shmpool, attach->pool_id, false, &shmpool );
-     if (ret)
-          return ret;
+	ret =
+	    fusion_shmpool_lock(&dev->shmpool, attach->pool_id, false,
+				&shmpool);
+	if (ret)
+		return ret;
 
-     dev->stat.shmpool_attach++;
+	dev->stat.shmpool_attach++;
 
-     node = get_node (shmpool, fusion_id);
-     if (!node) {
-          node = kmalloc (sizeof(SHMPoolNode), GFP_KERNEL);
-          if (!node) {
-               fusion_shmpool_unlock( shmpool );
-               return -ENOMEM;
-          }
+	node = get_node(shmpool, fusion_id);
+	if (!node) {
+		node = kmalloc(sizeof(SHMPoolNode), GFP_KERNEL);
+		if (!node) {
+			fusion_shmpool_unlock(shmpool);
+			return -ENOMEM;
+		}
 
-          node->fusion_id = fusion_id;
-          node->count     = 1;
+		node->fusion_id = fusion_id;
+		node->count = 1;
 
-          fusion_list_prepend (&shmpool->nodes, &node->link);
-     }
-     else
-          node->count++;
+		fusion_list_prepend(&shmpool->nodes, &node->link);
+	} else
+		node->count++;
 
-     attach->addr_base = shmpool->addr_base;
-     attach->size      = shmpool->size;
+	attach->addr_base = shmpool->addr_base;
+	attach->size = shmpool->size;
 
-     fusion_shmpool_unlock( shmpool );
+	fusion_shmpool_unlock(shmpool);
 
-     return 0;
+	return 0;
 }
 
-int
-fusion_shmpool_detach (FusionDev *dev, int id, FusionID fusion_id)
+int fusion_shmpool_detach(FusionDev * dev, int id, FusionID fusion_id)
 {
-     int            ret;
-     SHMPoolNode   *node;
-     FusionSHMPool *shmpool;
+	int ret;
+	SHMPoolNode *node;
+	FusionSHMPool *shmpool;
 
-     ret = fusion_shmpool_lock( &dev->shmpool, id, false, &shmpool );
-     if (ret)
-          return ret;
+	ret = fusion_shmpool_lock(&dev->shmpool, id, false, &shmpool);
+	if (ret)
+		return ret;
 
-     dev->stat.shmpool_detach++;
+	dev->stat.shmpool_detach++;
 
-     node = get_node (shmpool, fusion_id);
-     if (!node) {
-          fusion_shmpool_unlock( shmpool );
-          return -EIO;
-     }
+	node = get_node(shmpool, fusion_id);
+	if (!node) {
+		fusion_shmpool_unlock(shmpool);
+		return -EIO;
+	}
 
-     if (! --node->count) {
-          fusion_list_remove (&shmpool->nodes, &node->link);
-          kfree (node);
-     }
+	if (!--node->count) {
+		fusion_list_remove(&shmpool->nodes, &node->link);
+		kfree(node);
+	}
 
-     fusion_shmpool_unlock( shmpool );
+	fusion_shmpool_unlock(shmpool);
 
-     return 0;
+	return 0;
 }
 
 int
-fusion_shmpool_dispatch( FusionDev             *dev,
-                         FusionSHMPoolDispatch *dispatch,
-                         Fusionee              *fusionee )
+fusion_shmpool_dispatch(FusionDev * dev,
+			FusionSHMPoolDispatch * dispatch, Fusionee * fusionee)
 {
-     int                   ret;
-     FusionLink           *l;
-     FusionSHMPool        *shmpool;
-     FusionSHMPoolMessage  message;
-     FusionID              fusion_id = fusionee_id( fusionee );
+	int ret;
+	FusionLink *l;
+	FusionSHMPool *shmpool;
+	FusionSHMPoolMessage message;
+	FusionID fusion_id = fusionee_id(fusionee);
 
-     if (dispatch->size <= 0)
-          return -EINVAL;
+	if (dispatch->size <= 0)
+		return -EINVAL;
 
-     ret = fusion_shmpool_lock( &dev->shmpool, dispatch->pool_id, false, &shmpool );
-     if (ret)
-          return ret;
+	ret =
+	    fusion_shmpool_lock(&dev->shmpool, dispatch->pool_id, false,
+				&shmpool);
+	if (ret)
+		return ret;
 
-     message.type = FSMT_REMAP;
-     message.size = dispatch->size;
+	message.type = FSMT_REMAP;
+	message.size = dispatch->size;
 
-     shmpool->dispatch_count++;
+	shmpool->dispatch_count++;
 
-     shmpool->size = dispatch->size;
+	shmpool->size = dispatch->size;
 
-     fusion_list_foreach (l, shmpool->nodes) {
-          SHMPoolNode *node = (SHMPoolNode *) l;
+	fusion_list_foreach(l, shmpool->nodes) {
+		SHMPoolNode *node = (SHMPoolNode *) l;
 
-          if (node->fusion_id == fusion_id)
-               continue;
+		if (node->fusion_id == fusion_id)
+			continue;
 
-          fusionee_send_message (dev, fusionee, node->fusion_id, FMT_SHMPOOL,
-                                 shmpool->entry.id, 0, sizeof(message), &message,
-                                 NULL, NULL, 0);
-     }
+		fusionee_send_message(dev, fusionee, node->fusion_id,
+				      FMT_SHMPOOL, shmpool->entry.id, 0,
+				      sizeof(message), &message, NULL, NULL, 0);
+	}
 
-     fusion_shmpool_unlock( shmpool );
+	fusion_shmpool_unlock(shmpool);
 
-     return 0;
+	return 0;
 }
 
-int
-fusion_shmpool_destroy (FusionDev *dev, int id)
+int fusion_shmpool_destroy(FusionDev * dev, int id)
 {
-     return fusion_entry_destroy( &dev->shmpool, id );
+	return fusion_entry_destroy(&dev->shmpool, id);
 }
 
-void
-fusion_shmpool_detach_all (FusionDev *dev, FusionID fusion_id)
+void fusion_shmpool_detach_all(FusionDev * dev, FusionID fusion_id)
 {
-     FusionLink *l;
+	FusionLink *l;
 
-     down (&dev->shmpool.lock);
+	down(&dev->shmpool.lock);
 
-     fusion_list_foreach (l, dev->shmpool.list) {
-          FusionSHMPool *shmpool = (FusionSHMPool *) l;
+	fusion_list_foreach(l, dev->shmpool.list) {
+		FusionSHMPool *shmpool = (FusionSHMPool *) l;
 
-          remove_node (shmpool, fusion_id);
-     }
+		remove_node(shmpool, fusion_id);
+	}
 
-     up (&dev->shmpool.lock);
+	up(&dev->shmpool.lock);
 }
 
 int
-fusion_shmpool_fork_all( FusionDev *dev,
-                         FusionID   fusion_id,
-                         FusionID   from_id )
+fusion_shmpool_fork_all(FusionDev * dev, FusionID fusion_id, FusionID from_id)
 {
-     FusionLink *l;
-     int         ret = 0;
+	FusionLink *l;
+	int ret = 0;
 
-     down (&dev->shmpool.lock);
+	down(&dev->shmpool.lock);
 
-     fusion_list_foreach (l, dev->shmpool.list) {
-          FusionSHMPool *shmpool = (FusionSHMPool *) l;
+	fusion_list_foreach(l, dev->shmpool.list) {
+		FusionSHMPool *shmpool = (FusionSHMPool *) l;
 
-          ret = fork_node( shmpool, fusion_id, from_id );
-          if (ret)
-               break;
-     }
+		ret = fork_node(shmpool, fusion_id, from_id);
+		if (ret)
+			break;
+	}
 
-     up (&dev->shmpool.lock);
+	up(&dev->shmpool.lock);
 
-     return ret;
+	return ret;
 }
 
 /******************************************************************************/
 
-static SHMPoolNode *
-get_node (FusionSHMPool *shmpool,
-          FusionID       fusion_id)
+static SHMPoolNode *get_node(FusionSHMPool * shmpool, FusionID fusion_id)
 {
-     SHMPoolNode *node;
+	SHMPoolNode *node;
 
-     fusion_list_foreach (node, shmpool->nodes) {
-          if (node->fusion_id == fusion_id)
-               return node;
-     }
+	fusion_list_foreach(node, shmpool->nodes) {
+		if (node->fusion_id == fusion_id)
+			return node;
+	}
 
-     return NULL;
+	return NULL;
 }
 
-static void
-remove_node (FusionSHMPool *shmpool, FusionID fusion_id)
+static void remove_node(FusionSHMPool * shmpool, FusionID fusion_id)
 {
-     SHMPoolNode *node;
+	SHMPoolNode *node;
 
-     down (&shmpool->entry.lock);
+	down(&shmpool->entry.lock);
 
-     fusion_list_foreach (node, shmpool->nodes) {
-          if (node->fusion_id == fusion_id) {
-               fusion_list_remove (&shmpool->nodes, &node->link);
-               break;
-          }
-     }
+	fusion_list_foreach(node, shmpool->nodes) {
+		if (node->fusion_id == fusion_id) {
+			fusion_list_remove(&shmpool->nodes, &node->link);
+			break;
+		}
+	}
 
-     up (&shmpool->entry.lock);
+	up(&shmpool->entry.lock);
 }
 
 static int
-fork_node (FusionSHMPool *shmpool, FusionID fusion_id, FusionID from_id)
+fork_node(FusionSHMPool * shmpool, FusionID fusion_id, FusionID from_id)
 {
-     int          ret = 0;
-     SHMPoolNode *node;
+	int ret = 0;
+	SHMPoolNode *node;
 
-     down (&shmpool->entry.lock);
+	down(&shmpool->entry.lock);
 
-     fusion_list_foreach (node, shmpool->nodes) {
-          if (node->fusion_id == from_id) {
-               SHMPoolNode *new_node;
+	fusion_list_foreach(node, shmpool->nodes) {
+		if (node->fusion_id == from_id) {
+			SHMPoolNode *new_node;
 
-               new_node = kmalloc (sizeof(SHMPoolNode), GFP_KERNEL);
-               if (!new_node) {
-                    ret = -ENOMEM;
-                    break;
-               }
+			new_node = kmalloc(sizeof(SHMPoolNode), GFP_KERNEL);
+			if (!new_node) {
+				ret = -ENOMEM;
+				break;
+			}
 
-               new_node->fusion_id = fusion_id;
-               new_node->count     = node->count;
+			new_node->fusion_id = fusion_id;
+			new_node->count = node->count;
 
-               fusion_list_prepend (&shmpool->nodes, &new_node->link);
+			fusion_list_prepend(&shmpool->nodes, &new_node->link);
 
-               break;
-          }
-     }
+			break;
+		}
+	}
 
-     up (&shmpool->entry.lock);
+	up(&shmpool->entry.lock);
 
-     return ret;
+	return ret;
 }
 
-static void
-free_all_nodes (FusionSHMPool *shmpool)
-
+static void free_all_nodes(FusionSHMPool * shmpool)
 {
-     FusionLink  *n;
-     SHMPoolNode *node;
+	FusionLink *n;
+	SHMPoolNode *node;
 
-     fusion_list_foreach_safe (node, n, shmpool->nodes) {
-          kfree (node);
-     }
+	fusion_list_foreach_safe(node, n, shmpool->nodes) {
+		kfree(node);
+	}
 
-     shmpool->nodes = NULL;
+	shmpool->nodes = NULL;
 }
diff --git a/drivers/char/fusion/shmpool.h b/drivers/char/fusion/shmpool.h
index a3a67b6..ec0e371 100644
--- a/drivers/char/fusion/shmpool.h
+++ b/drivers/char/fusion/shmpool.h
@@ -11,63 +11,52 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  */
- 
+
 #ifndef __FUSION__SHMPOOL_H__
 #define __FUSION__SHMPOOL_H__
 
 #include "fusiondev.h"
 #include "types.h"
 
-#ifdef __x86_64__
-#define FUSION_SHM_BASE    0x523000010000     /* virtual base address */
-#define FUSION_SHM_SIZE    0x000FFFFEF000     /* size of virtual address space */
+#if (sizeof(void*) == 8)
+#define FUSION_SHM_BASE    0x523000010000	/* virtual base address */
+#define FUSION_SHM_SIZE    0x000FFFFEF000	/* size of virtual address space */
 #else
 
-
 #ifdef __mips__
-#define FUSION_SHM_BASE    0x50010000     /* virtual base address */
+#define FUSION_SHM_BASE    0x50010000	/* virtual base address */
 #else
-#define FUSION_SHM_BASE    0x20010000     /* virtual base address */
+#define FUSION_SHM_BASE    0x20010000	/* virtual base address */
 #endif
 
-#define FUSION_SHM_SIZE    0x1FFEF000     /* size of virtual address space */
+#define FUSION_SHM_SIZE    0x1FFEF000	/* size of virtual address space */
 #endif
 
 /* module init/cleanup */
 
-int  fusion_shmpool_init   (FusionDev *dev);
-void fusion_shmpool_deinit (FusionDev *dev);
-
+int fusion_shmpool_init(FusionDev * dev);
+void fusion_shmpool_deinit(FusionDev * dev);
 
 /* public API */
 
-int fusion_shmpool_new      (FusionDev             *dev,
-                             FusionSHMPoolNew      *pool);
+int fusion_shmpool_new(FusionDev * dev, FusionSHMPoolNew * pool);
 
-int fusion_shmpool_attach   (FusionDev             *dev,
-                             FusionSHMPoolAttach   *attach,
-                             FusionID               fusion_id);
+int fusion_shmpool_attach(FusionDev * dev,
+			  FusionSHMPoolAttach * attach, FusionID fusion_id);
 
-int fusion_shmpool_detach   (FusionDev             *dev,
-                             int                    id,
-                             FusionID               fusion_id);
+int fusion_shmpool_detach(FusionDev * dev, int id, FusionID fusion_id);
 
-int fusion_shmpool_dispatch (FusionDev             *dev,
-                             FusionSHMPoolDispatch *dispatch,
-                             Fusionee              *fusionee );
-
-int fusion_shmpool_destroy  (FusionDev             *dev,
-                             int                    id);
+int fusion_shmpool_dispatch(FusionDev * dev,
+			    FusionSHMPoolDispatch * dispatch,
+			    Fusionee * fusionee);
 
+int fusion_shmpool_destroy(FusionDev * dev, int id);
 
 /* internal functions */
 
-void fusion_shmpool_detach_all (FusionDev *dev,
-                                FusionID   fusion_id);
+void fusion_shmpool_detach_all(FusionDev * dev, FusionID fusion_id);
 
-int  fusion_shmpool_fork_all   (FusionDev *dev,
-                                FusionID   fusion_id,
-                                FusionID   from_id);
+int fusion_shmpool_fork_all(FusionDev * dev,
+			    FusionID fusion_id, FusionID from_id);
 
 #endif
-
diff --git a/drivers/char/fusion/skirmish.c b/drivers/char/fusion/skirmish.c
index a805bbb..b9c22a2 100644
--- a/drivers/char/fusion/skirmish.c
+++ b/drivers/char/fusion/skirmish.c
@@ -29,36 +29,34 @@
 #include "list.h"
 #include "skirmish.h"
 
-
 #define MAX_PRE_ACQUISITIONS  256
 
 #define FUSION_SKIRMISH_LOG(x...)  do {} while (0)
 
-
 typedef struct __FUSION_FusionSkirmish FusionSkirmish;
 
 struct __FUSION_FusionSkirmish {
-     FusionEntry  entry;
+	FusionEntry entry;
 
-     int          lock_fid;  /* non-zero if locked */
-     int          lock_pid;
-     int          lock_count;
+	int lock_fid;		/* non-zero if locked */
+	int lock_pid;
+	int lock_count;
 
-     int          lock_total;
+	int lock_total;
 
-     unsigned int notify_count;
+	unsigned int notify_count;
 
-     unsigned long  lock_time;
+	unsigned long lock_time;
 
-     FusionID       transfer_to;
-     FusionID       transfer_from;
-     int            transfer_from_pid;
-     int            transfer_count;
+	FusionID transfer_to;
+	FusionID transfer_from;
+	int transfer_from_pid;
+	int transfer_count;
 
 #ifdef FUSION_DEBUG_SKIRMISH_DEADLOCK
-     int          pre_acquis[MAX_PRE_ACQUISITIONS];
+	int pre_acquis[MAX_PRE_ACQUISITIONS];
 
-     bool         outer;
+	bool outer;
 #endif
 };
 
@@ -68,667 +66,672 @@ struct __FUSION_FusionSkirmish {
 #define PID_MAX_DEFAULT PID_MAX
 #endif
 
-static unsigned int m_pidlocks[PID_MAX_DEFAULT+1];  /* FIXME: find cleaner, but still fast method */
-static sigset_t     m_sigmask;
+static unsigned int m_pidlocks[PID_MAX_DEFAULT + 1];	/* FIXME: find cleaner, but still fast method */
+static sigset_t m_sigmask;
 
 #ifdef FUSION_BLOCK_SIGNALS
-static int
-skirmish_signal_handler( void *ctx )
+static int skirmish_signal_handler(void *ctx)
 {
-     if (current->pid <= PID_MAX_DEFAULT && !m_pidlocks[current->pid]) {
-          unblock_all_signals();
-          return 1;
-     }
-
-     printk( KERN_DEBUG "FusionSkirmish: Blocking signal for process %d!\n", current->pid );
-     
-     return 0;
+	if (current->pid <= PID_MAX_DEFAULT && !m_pidlocks[current->pid]) {
+		unblock_all_signals();
+		return 1;
+	}
+
+	printk(KERN_DEBUG "FusionSkirmish: Blocking signal for process %d!\n",
+	       current->pid);
+
+	return 0;
 }
 #endif
 
 /******************************************************************************/
 
 static void
-fusion_skirmish_print( FusionEntry     *entry,
-                       void            *ctx,
-                       struct seq_file *p )
+fusion_skirmish_print(FusionEntry * entry, void *ctx, struct seq_file *p)
 {
-     FusionSkirmish *skirmish = (FusionSkirmish*) entry;
+	FusionSkirmish *skirmish = (FusionSkirmish *) entry;
 
 #ifdef FUSION_DEBUG_SKIRMISH_DEADLOCK
-     int             i, n;
-
+	int i, n;
 
-     for (i=0, n=0; i<MAX_PRE_ACQUISITIONS; i++) {
-          if (skirmish->pre_acquis[i]) {
-               n++;
-          }
-     }
+	for (i = 0, n = 0; i < MAX_PRE_ACQUISITIONS; i++) {
+		if (skirmish->pre_acquis[i]) {
+			n++;
+		}
+	}
 
-     seq_printf( p, "[%2d]%s", n, skirmish->outer ? "." : " " );
+	seq_printf(p, "[%2d]%s", n, skirmish->outer ? "." : " ");
 
-     for (i=0, n=0; i<MAX_PRE_ACQUISITIONS; i++) {
-          if (skirmish->pre_acquis[i]) {
-               seq_printf( p, "%s%02x", n ? "," : "", skirmish->pre_acquis[i] - 1 );
+	for (i = 0, n = 0; i < MAX_PRE_ACQUISITIONS; i++) {
+		if (skirmish->pre_acquis[i]) {
+			seq_printf(p, "%s%02x", n ? "," : "",
+				   skirmish->pre_acquis[i] - 1);
 
-               n++;
-          }
-     }
+			n++;
+		}
+	}
 #endif
 
-     if (skirmish->lock_fid) {
-          if (skirmish->entry.waiters)
-               seq_printf( p, " - %dx [0x%08x] (%d)  %d WAITING\n",
-                           skirmish->lock_count, skirmish->lock_fid,
-                           skirmish->lock_pid, skirmish->entry.waiters );
-          else
-               seq_printf( p, " - %dx [0x%08x] (%d)\n",
-                           skirmish->lock_count, skirmish->lock_fid,
-                           skirmish->lock_pid );
-          return;
-     }
-
-     seq_printf( p, "\n" );
+	if (skirmish->lock_fid) {
+		if (skirmish->entry.waiters)
+			seq_printf(p, " - %dx [0x%08x] (%d)  %d WAITING\n",
+				   skirmish->lock_count, skirmish->lock_fid,
+				   skirmish->lock_pid, skirmish->entry.waiters);
+		else
+			seq_printf(p, " - %dx [0x%08x] (%d)\n",
+				   skirmish->lock_count, skirmish->lock_fid,
+				   skirmish->lock_pid);
+		return;
+	}
+
+	seq_printf(p, "\n");
 }
 
-FUSION_ENTRY_CLASS( FusionSkirmish, skirmish, NULL, NULL, fusion_skirmish_print )
+FUSION_ENTRY_CLASS(FusionSkirmish, skirmish, NULL, NULL, fusion_skirmish_print)
 
 /******************************************************************************/
-
-int
-fusion_skirmish_init (FusionDev *dev)
+int fusion_skirmish_init(FusionDev * dev)
 {
-     fusion_entries_init( &dev->skirmish, &skirmish_class, dev );
+	fusion_entries_init(&dev->skirmish, &skirmish_class, dev);
 
-     fusion_entries_create_proc_entry( dev, "skirmishs", &dev->skirmish );
+	fusion_entries_create_proc_entry(dev, "skirmishs", &dev->skirmish);
 
-     sigemptyset( &m_sigmask );
-     sigaddset( &m_sigmask, SIGSTOP );
-     sigaddset( &m_sigmask, SIGTTIN );
-     sigaddset( &m_sigmask, SIGTERM );
-     sigaddset( &m_sigmask, SIGINT );
+	sigemptyset(&m_sigmask);
+	sigaddset(&m_sigmask, SIGSTOP);
+	sigaddset(&m_sigmask, SIGTTIN);
+	sigaddset(&m_sigmask, SIGTERM);
+	sigaddset(&m_sigmask, SIGINT);
 
-     return 0;
+	return 0;
 }
 
-void
-fusion_skirmish_deinit (FusionDev *dev)
+void fusion_skirmish_deinit(FusionDev * dev)
 {
-     remove_proc_entry ("skirmishs", dev->proc_dir);
+	remove_proc_entry("skirmishs", dev->proc_dir);
 
-     fusion_entries_deinit( &dev->skirmish );
+	fusion_entries_deinit(&dev->skirmish);
 }
 
 /******************************************************************************/
 
-int
-fusion_skirmish_new (FusionDev *dev, int *ret_id)
+int fusion_skirmish_new(FusionDev * dev, int *ret_id)
 {
-     return fusion_entry_create( &dev->skirmish, ret_id, NULL );
+	return fusion_entry_create(&dev->skirmish, ret_id, NULL);
 }
 
-int
-fusion_skirmish_prevail (FusionDev *dev, int id, int fusion_id)
+int fusion_skirmish_prevail(FusionDev * dev, int id, int fusion_id)
 {
-     int             ret;
-     FusionSkirmish *skirmish;
+	int ret;
+	FusionSkirmish *skirmish;
 #ifdef FUSION_DEBUG_SKIRMISH_DEADLOCK
-     FusionSkirmish *s;
-     int             i;
-     bool            outer = true;
+	FusionSkirmish *s;
+	int i;
+	bool outer = true;
 #endif
 
-     dev->stat.skirmish_prevail_swoop++;
-
-     ret = fusion_skirmish_lock( &dev->skirmish, id, true, &skirmish );
-     if (ret)
-          return ret;
+	dev->stat.skirmish_prevail_swoop++;
 
-     if (skirmish->lock_pid == current->pid) {
-          skirmish->lock_count++;
-          skirmish->lock_total++;
-          fusion_skirmish_unlock( skirmish );
-          up( &dev->skirmish.lock );
-          return 0;
-     }
+	ret = fusion_skirmish_lock(&dev->skirmish, id, true, &skirmish);
+	if (ret)
+		return ret;
 
+	if (skirmish->lock_pid == current->pid) {
+		skirmish->lock_count++;
+		skirmish->lock_total++;
+		fusion_skirmish_unlock(skirmish);
+		up(&dev->skirmish.lock);
+		return 0;
+	}
 #ifdef FUSION_DEBUG_SKIRMISH_DEADLOCK
-     /* look in currently acquired skirmishs for this one being
-        a pre-acquisition, indicating a potential deadlock */
-     fusion_list_foreach (s, dev->skirmish.list) {
-          if (s->lock_pid != current->pid)
-               continue;
-
-          outer = false;
-
-          for (i=0; i<MAX_PRE_ACQUISITIONS; i++) {
-               if (s->pre_acquis[i] == id + 1) {
-                    printk( KERN_DEBUG "FusionSkirmish: Potential deadlock "
-                            "between locked 0x%x and to be locked 0x%x in world %d!\n",
-                            s->entry.id, skirmish->entry.id, dev->index );
-               }
-          }
-     }
-
-     if (outer)
-          skirmish->outer = true;
-
-     /* remember all previously acquired skirmishs being pre-acquisitions for
-        this one, to detect potential deadlocks due to a lock order twist */
-     fusion_list_foreach (s, dev->skirmish.list) {
-          int free = -1;
-
-          if (s->lock_pid != current->pid)
-               continue;
-
-          for (i=0; i<MAX_PRE_ACQUISITIONS; i++) {
-               if (skirmish->pre_acquis[i]) {
-                    if (skirmish->pre_acquis[i] == s->entry.id + 1) {
-                         break;
-                    }
-               }
-               else
-                    free = i;
-          }
-
-          /* not found? */
-          if (i == MAX_PRE_ACQUISITIONS) {
-               if (free != -1) {
-                    skirmish->pre_acquis[free] = s->entry.id + 1;
-               }
-               else {
-                    printk( KERN_DEBUG "FusionSkirmish: Too many pre-acquisitions to remember.\n" );
-
-                    printk( KERN_DEBUG " [ '%s' ] <- ", skirmish->entry.name );
-
-                    for (i=0; i<MAX_PRE_ACQUISITIONS; i++)
-                         printk( "0x%03x ", skirmish->pre_acquis[i] - 1 );
-
-                    printk( "\n" );
-               }
-          }
-     }
+	/* look in currently acquired skirmishs for this one being
+	   a pre-acquisition, indicating a potential deadlock */
+	fusion_list_foreach(s, dev->skirmish.list) {
+		if (s->lock_pid != current->pid)
+			continue;
+
+		outer = false;
+
+		for (i = 0; i < MAX_PRE_ACQUISITIONS; i++) {
+			if (s->pre_acquis[i] == id + 1) {
+				printk(KERN_DEBUG
+				       "FusionSkirmish: Potential deadlock "
+				       "between locked 0x%x and to be locked 0x%x in world %d!\n",
+				       s->entry.id, skirmish->entry.id,
+				       dev->index);
+			}
+		}
+	}
+
+	if (outer)
+		skirmish->outer = true;
+
+	/* remember all previously acquired skirmishs being pre-acquisitions for
+	   this one, to detect potential deadlocks due to a lock order twist */
+	fusion_list_foreach(s, dev->skirmish.list) {
+		int free = -1;
+
+		if (s->lock_pid != current->pid)
+			continue;
+
+		for (i = 0; i < MAX_PRE_ACQUISITIONS; i++) {
+			if (skirmish->pre_acquis[i]) {
+				if (skirmish->pre_acquis[i] == s->entry.id + 1) {
+					break;
+				}
+			} else
+				free = i;
+		}
+
+		/* not found? */
+		if (i == MAX_PRE_ACQUISITIONS) {
+			if (free != -1) {
+				skirmish->pre_acquis[free] = s->entry.id + 1;
+			} else {
+				printk(KERN_DEBUG
+				       "FusionSkirmish: Too many pre-acquisitions to remember.\n");
+
+				printk(KERN_DEBUG " [ '%s' ] <- ",
+				       skirmish->entry.name);
+
+				for (i = 0; i < MAX_PRE_ACQUISITIONS; i++)
+					printk("0x%03x ",
+					       skirmish->pre_acquis[i] - 1);
+
+				printk("\n");
+			}
+		}
+	}
 #endif
 
-     up( &dev->skirmish.lock );
+	up(&dev->skirmish.lock);
 
-     while (skirmish->lock_pid || (skirmish->transfer_to != 0 &&
-                                   fusionee_dispatcher_pid( dev, skirmish->transfer_to ) != current->pid))
-     {
-          ret = fusion_skirmish_wait( skirmish, NULL );
-          if (ret)
-               return ret;
-     }
+	while (skirmish->lock_pid || (skirmish->transfer_to != 0 &&
+				      fusionee_dispatcher_pid(dev,
+							      skirmish->
+							      transfer_to) !=
+				      current->pid)) {
+		ret = fusion_skirmish_wait(skirmish, NULL);
+		if (ret)
+			return ret;
+	}
 
 #ifdef FUSION_BLOCK_SIGNALS
-     if (current->pid <= PID_MAX_DEFAULT && !m_pidlocks[current->pid]++)
-          block_all_signals( skirmish_signal_handler, dev, &m_sigmask );
+	if (current->pid <= PID_MAX_DEFAULT && !m_pidlocks[current->pid]++)
+		block_all_signals(skirmish_signal_handler, dev, &m_sigmask);
 #endif
 
-     skirmish->lock_fid   = fusion_id;
-     skirmish->lock_pid   = current->pid;
-     skirmish->lock_count = 1;
-     skirmish->lock_time  = jiffies;
+	skirmish->lock_fid   = fusion_id;
+	skirmish->lock_pid   = current->pid;
+	skirmish->lock_count = 1;
+	skirmish->lock_time  = jiffies;
 
-     skirmish->lock_total++;
+	skirmish->lock_total++;
 
-     fusion_skirmish_unlock( skirmish );
+	fusion_skirmish_unlock(skirmish);
 
-     return 0;
+	return 0;
 }
 
-int
-fusion_skirmish_swoop (FusionDev *dev, int id, int fusion_id)
+int fusion_skirmish_swoop(FusionDev * dev, int id, int fusion_id)
 {
-     int             ret;
-     FusionSkirmish *skirmish;
-
-     ret = fusion_skirmish_lock( &dev->skirmish, id, false, &skirmish );
-     if (ret)
-          return ret;
-
-     dev->stat.skirmish_prevail_swoop++;
-
-     if (skirmish->lock_fid || (skirmish->transfer_to != 0 &&
-                                fusionee_dispatcher_pid( dev, skirmish->transfer_to ) != current->pid)) {
-          if (skirmish->lock_pid == current->pid) {
-               skirmish->lock_count++;
-               skirmish->lock_total++;
-               fusion_skirmish_unlock( skirmish );
-               return 0;
-          }
-
-          fusion_skirmish_unlock( skirmish );
-
-          return -EAGAIN;
-     }
-
+	int ret;
+	FusionSkirmish *skirmish;
+
+	ret = fusion_skirmish_lock(&dev->skirmish, id, false, &skirmish);
+	if (ret)
+		return ret;
+
+	dev->stat.skirmish_prevail_swoop++;
+
+	if (skirmish->lock_fid || (skirmish->transfer_to != 0 &&
+				   fusionee_dispatcher_pid(dev,
+							   skirmish->
+							   transfer_to) !=
+				   current->pid)) {
+		if (skirmish->lock_pid == current->pid) {
+			skirmish->lock_count++;
+			skirmish->lock_total++;
+			fusion_skirmish_unlock(skirmish);
+			return 0;
+		}
+
+		fusion_skirmish_unlock(skirmish);
+
+		return -EAGAIN;
+	}
 #ifdef FUSION_BLOCK_SIGNALS
-     if (current->pid <= PID_MAX_DEFAULT && !m_pidlocks[current->pid]++)
-          block_all_signals( skirmish_signal_handler, dev, &m_sigmask );
+	if (current->pid <= PID_MAX_DEFAULT && !m_pidlocks[current->pid]++)
+		block_all_signals(skirmish_signal_handler, dev, &m_sigmask);
 #endif
 
-     skirmish->lock_fid   = fusion_id;
-     skirmish->lock_pid   = current->pid;
-     skirmish->lock_count = 1;
+	skirmish->lock_fid   = fusion_id;
+	skirmish->lock_pid   = current->pid;
+	skirmish->lock_count = 1;
 
-     skirmish->lock_total++;
+	skirmish->lock_total++;
 
-     fusion_skirmish_unlock( skirmish );
+	fusion_skirmish_unlock(skirmish);
 
-     return 0;
+	return 0;
 }
 
 int
-fusion_skirmish_lock_count (FusionDev *dev, int id, int fusion_id, int *ret_lock_count)
+fusion_skirmish_lock_count(FusionDev * dev, int id, int fusion_id,
+			   int *ret_lock_count)
 {
-     int             ret;
-     FusionSkirmish *skirmish;
-
-     ret = fusion_skirmish_lock( &dev->skirmish, id, false, &skirmish );
-     if (ret)
-          return ret;
-
-     if (skirmish->lock_fid == fusion_id &&
-         skirmish->lock_pid == current->pid)
-     {
-          *ret_lock_count = skirmish->lock_count;
-     }
-     else
-     {
-          *ret_lock_count = 0; 
-     }
-
-     fusion_skirmish_unlock( skirmish );
-
-     return 0;
+	int ret;
+	FusionSkirmish *skirmish;
+
+	ret = fusion_skirmish_lock(&dev->skirmish, id, false, &skirmish);
+	if (ret)
+		return ret;
+
+	if (skirmish->lock_fid == fusion_id &&
+	    skirmish->lock_pid == current->pid) {
+		*ret_lock_count = skirmish->lock_count;
+	} else {
+		*ret_lock_count = 0;
+	}
+
+	fusion_skirmish_unlock(skirmish);
+
+	return 0;
 }
 
-int
-fusion_skirmish_dismiss (FusionDev *dev, int id, int fusion_id)
+int fusion_skirmish_dismiss(FusionDev * dev, int id, int fusion_id)
 {
-     int             ret;
-     FusionSkirmish *skirmish;
-     unsigned long   lock_jiffies = 0;
+	int ret;
+	FusionSkirmish *skirmish;
+	unsigned long lock_jiffies = 0;
 
-     ret = fusion_skirmish_lock( &dev->skirmish, id, false, &skirmish );
-     if (ret)
-          return ret;
+	ret = fusion_skirmish_lock(&dev->skirmish, id, false, &skirmish);
+	if (ret)
+		return ret;
 
-     dev->stat.skirmish_dismiss++;
+	dev->stat.skirmish_dismiss++;
 
-     if (skirmish->lock_pid != current->pid) {
-          fusion_skirmish_unlock( skirmish );
-          return -EIO;
-     }
+	if (skirmish->lock_pid != current->pid) {
+		fusion_skirmish_unlock(skirmish);
+		return -EIO;
+	}
 
-     if (--skirmish->lock_count == 0) {
-          skirmish->lock_fid = 0;
-          skirmish->lock_pid = 0;
+	if (--skirmish->lock_count == 0) {
+		skirmish->lock_fid = 0;
+		skirmish->lock_pid = 0;
 
-          lock_jiffies = jiffies - skirmish->lock_time;
+		lock_jiffies = jiffies - skirmish->lock_time;
 
-          fusion_skirmish_notify( skirmish, true );
+		fusion_skirmish_notify(skirmish, true);
 
 #ifdef FUSION_BLOCK_SIGNALS
-          if (current->pid <= PID_MAX_DEFAULT && ! --m_pidlocks[current->pid])
-               unblock_all_signals();
+		if (current->pid <= PID_MAX_DEFAULT
+		    && !--m_pidlocks[current->pid])
+			unblock_all_signals();
 #endif
-     }
+	}
 
-     fusion_skirmish_unlock( skirmish );
+	fusion_skirmish_unlock(skirmish);
 
 #ifdef FUSION_SKIRMISH_YIELD
-     /* Locked > 20 ms ? */
-     if (lock_jiffies > HZ/50)// && current->policy == SCHED_NORMAL)
-          yield();
+	/* Locked > 20 ms ? */
+	if (lock_jiffies > HZ / 50)
+		yield();
 #endif
 
-     return 0;
+	return 0;
 }
 
-int
-fusion_skirmish_destroy (FusionDev *dev, int id)
+int fusion_skirmish_destroy(FusionDev * dev, int id)
 {
-     int             ret;
-     FusionSkirmish *skirmish;
+	int ret;
+	FusionSkirmish *skirmish;
 #ifdef FUSION_DEBUG_SKIRMISH_DEADLOCK
-     int             i;
-     FusionSkirmish *s;
+	int i;
+	FusionSkirmish *s;
 #endif
 
-     ret = fusion_skirmish_lock( &dev->skirmish, id, true, &skirmish );
-     if (ret)
-          return ret;
+	ret = fusion_skirmish_lock(&dev->skirmish, id, true, &skirmish);
+	if (ret)
+		return ret;
 
 #ifdef FUSION_DEBUG_SKIRMISH_DEADLOCK
-     /* remove from all pre-acquisition lists */
-     fusion_list_foreach (s, dev->skirmish.list) {
-          for (i=0; i<MAX_PRE_ACQUISITIONS; i++) {
-               if (s->pre_acquis[i] == id + 1)
-                    s->pre_acquis[i] = 0;
-          }
-     }
+	/* remove from all pre-acquisition lists */
+	fusion_list_foreach(s, dev->skirmish.list) {
+		for (i = 0; i < MAX_PRE_ACQUISITIONS; i++) {
+			if (s->pre_acquis[i] == id + 1)
+				s->pre_acquis[i] = 0;
+		}
+	}
 #endif
 
-     up( &dev->skirmish.lock );
+	up(&dev->skirmish.lock);
 
 #ifdef FUSION_BLOCK_SIGNALS
-     if (skirmish->lock_pid == current->pid &&
-         current->pid <= PID_MAX_DEFAULT && ! --m_pidlocks[current->pid])
-          unblock_all_signals();
+	if (skirmish->lock_pid == current->pid &&
+	    current->pid <= PID_MAX_DEFAULT && !--m_pidlocks[current->pid])
+		unblock_all_signals();
 #endif
 
-     fusion_skirmish_unlock( skirmish );
+	fusion_skirmish_unlock(skirmish);
 
-     /* FIXME: gap? */
+	/* FIXME: gap? */
 
-     return fusion_entry_destroy( &dev->skirmish, id );
+	return fusion_entry_destroy(&dev->skirmish, id);
 }
 
 int
-fusion_skirmish_wait_ (FusionDev *dev, FusionSkirmishWait *wait, FusionID fusion_id)
+fusion_skirmish_wait_(FusionDev * dev, FusionSkirmishWait * wait,
+		      FusionID fusion_id)
 {
-     int             ret, ret2;
-     FusionSkirmish *skirmish;
-
-     FUSION_SKIRMISH_LOG( "FusionSkirmish: %s( 0x%x, lock count %u, notify count %u, timeout %u ) called...\n",
-                          __FUNCTION__, wait->id, wait->lock_count, wait->notify_count, wait->timeout );
-
-     /* Lookup and lock the entry. */
-     ret = fusion_skirmish_lock( &dev->skirmish, wait->id, false, &skirmish );
-     if (ret) {
-          FUSION_SKIRMISH_LOG( "FusionSkirmish: Failed to lookup skirmish with id 0x%x!\n", wait->id );
-          return ret;
-     }
-
-     FUSION_SKIRMISH_LOG( "FusionSkirmish: Found entry at %p!\n", skirmish );
-
-     /* Statistics... */
-     dev->stat.skirmish_wait++;
-
-     /* Check if not a resumed call. */
-     if (!wait->lock_count) {
-          /* Cannot wait for skirmish not held by the current task. */
-          if (skirmish->lock_pid != current->pid) {
-               fusion_skirmish_unlock( skirmish );
-               FUSION_SKIRMISH_LOG( "FusionSkirmish: Tried to wait for skirmish not held by the current task!\n" );
-               return -EIO;
-          }
-
-          /* Remember lock and notification counters. */
-          wait->lock_count   = skirmish->lock_count;
-          wait->notify_count = skirmish->notify_count;
-
-          /* Temporarily give up the skirmish. */
-          skirmish->lock_fid = 0;
-          skirmish->lock_pid = 0;
+	int ret, ret2;
+	FusionSkirmish *skirmish;
+
+	FUSION_SKIRMISH_LOG
+	    ("FusionSkirmish: %s( 0x%x, lock count %u, notify count %u, timeout %u ) called...\n",
+	     __FUNCTION__, wait->id, wait->lock_count, wait->notify_count,
+	     wait->timeout);
+
+	/* Lookup and lock the entry. */
+	ret = fusion_skirmish_lock(&dev->skirmish, wait->id, false, &skirmish);
+	if (ret) {
+		FUSION_SKIRMISH_LOG
+		    ("FusionSkirmish: Failed to lookup skirmish with id 0x%x!\n",
+		     wait->id);
+		return ret;
+	}
+
+	FUSION_SKIRMISH_LOG("FusionSkirmish: Found entry at %p!\n", skirmish);
+
+	/* Statistics... */
+	dev->stat.skirmish_wait++;
+
+	/* Check if not a resumed call. */
+	if (!wait->lock_count) {
+		/* Cannot wait for skirmish not held by the current task. */
+		if (skirmish->lock_pid != current->pid) {
+			fusion_skirmish_unlock(skirmish);
+			FUSION_SKIRMISH_LOG
+			    ("FusionSkirmish: Tried to wait for skirmish not held by the current task!\n");
+			return -EIO;
+		}
+
+		/* Remember lock and notification counters. */
+		wait->lock_count = skirmish->lock_count;
+		wait->notify_count = skirmish->notify_count;
+
+		/* Temporarily give up the skirmish. */
+		skirmish->lock_fid = 0;
+		skirmish->lock_pid = 0;
 
 #ifdef FUSION_BLOCK_SIGNALS
-          if (current->pid <= PID_MAX_DEFAULT && ! --m_pidlocks[current->pid])
-               unblock_all_signals();
+		if (current->pid <= PID_MAX_DEFAULT
+		    && !--m_pidlocks[current->pid])
+			unblock_all_signals();
 #endif
 
-          /* Notify potential notifiers waiting for the entry. */
-          fusion_skirmish_notify( skirmish, true );
-     }
-     /* This might happen when lock count was not initialized. */
-     else if (skirmish->lock_pid == current->pid) {
-          fusion_skirmish_unlock( skirmish );
-          FUSION_SKIRMISH_LOG( "FusionSkirmish: Tried to resume wait for skirmish still held by the current task!\n" );
-          return -EIO;
-     }
-
-     /* Wait until the notification counter differs. */
-     if (wait->timeout) {
-          long timeout_jiffies = wait->timeout * HZ / 1000;
-
-          while (wait->notify_count == skirmish->notify_count && !ret)
-               ret = fusion_skirmish_wait( skirmish, &timeout_jiffies );
-
-          wait->timeout = (timeout_jiffies * 1000 / HZ) ? : 1;
-     }
-     else {
-          while (wait->notify_count == skirmish->notify_count && !ret)
-               ret = fusion_skirmish_wait( skirmish, NULL );
-     }
-
-     /* Check for normal or unusual results. */
-     switch (ret) {
-          case 0:
-               break;
-
-          case -ETIMEDOUT:
-               FUSION_SKIRMISH_LOG( "FusionSkirmish: Timeout while waiting for notification!\n" );
-
-               /* Relock after timeout. */
-               ret2 = fusion_skirmish_lock( &dev->skirmish, wait->id, false, &skirmish );
-               if (ret2) {
-                    FUSION_SKIRMISH_LOG( "FusionSkirmish: Failed to relookup skirmish with id 0x%x!\n", wait->id );
-                    return ret2;
-               }
-               break;
-
-          case -EINTR:
-               /* Return immediately upon signal. */
-               FUSION_SKIRMISH_LOG( "FusionSkirmish: Interrupted while waiting for notification!\n" );
-               return ret;
-
-          default:
-               /* Return immediately upon unusual result. */
-               FUSION_SKIRMISH_LOG( "FusionSkirmish: Error while waiting for notification (%d)!\n", ret );
-               return ret;
-     }
-
-     /* Wait until the lock can be taken again. */
-     while (skirmish->lock_pid) {
-          ret2 = fusion_skirmish_wait( skirmish, NULL );
-          
-          /* Check for normal or unusual results. */
-          switch (ret2) {
-               case 0:
-                    break;
-
-               case -EINTR:
-                    /* Return immediately upon signal. */
-                    FUSION_SKIRMISH_LOG( "FusionSkirmish: Interrupted while waiting for relock!\n" );
-                    return ret2;
-
-               default:
-                    /* Return immediately upon unusual result. */
-                    FUSION_SKIRMISH_LOG( "FusionSkirmish: Error while waiting for notification (%d)!\n", ret2 );
-                    return ret2;
-          }
-     }
+		/* Notify potential notifiers waiting for the entry. */
+		fusion_skirmish_notify(skirmish, true);
+	}
+	/* This might happen when lock count was not initialized. */
+	else if (skirmish->lock_pid == current->pid) {
+		fusion_skirmish_unlock(skirmish);
+		FUSION_SKIRMISH_LOG
+		    ("FusionSkirmish: Tried to resume wait for skirmish still held by the current task!\n");
+		return -EIO;
+	}
+
+	/* Wait until the notification counter differs. */
+	if (wait->timeout) {
+		long timeout_jiffies = wait->timeout * HZ / 1000;
+
+		while (wait->notify_count == skirmish->notify_count && !ret)
+			ret = fusion_skirmish_wait(skirmish, &timeout_jiffies);
+
+		wait->timeout = (timeout_jiffies * 1000 / HZ) ? : 1;
+	} else {
+		while (wait->notify_count == skirmish->notify_count && !ret)
+			ret = fusion_skirmish_wait(skirmish, NULL);
+	}
+
+	/* Check for normal or unusual results. */
+	switch (ret) {
+	case 0:
+		break;
+
+	case -ETIMEDOUT:
+		FUSION_SKIRMISH_LOG
+		    ("FusionSkirmish: Timeout while waiting for notification!\n");
+
+		/* Relock after timeout. */
+		ret2 =
+		    fusion_skirmish_lock(&dev->skirmish, wait->id, false,
+					 &skirmish);
+		if (ret2) {
+			FUSION_SKIRMISH_LOG
+			    ("FusionSkirmish: Failed to relookup skirmish with id 0x%x!\n",
+			     wait->id);
+			return ret2;
+		}
+		break;
+
+	case -EINTR:
+		/* Return immediately upon signal. */
+		FUSION_SKIRMISH_LOG
+		    ("FusionSkirmish: Interrupted while waiting for notification!\n");
+		return ret;
+
+	default:
+		/* Return immediately upon unusual result. */
+		FUSION_SKIRMISH_LOG
+		    ("FusionSkirmish: Error while waiting for notification (%d)!\n",
+		     ret);
+		return ret;
+	}
+
+	/* Wait until the lock can be taken again. */
+	while (skirmish->lock_pid) {
+		ret2 = fusion_skirmish_wait(skirmish, NULL);
+
+		/* Check for normal or unusual results. */
+		switch (ret2) {
+		case 0:
+			break;
+
+		case -EINTR:
+			/* Return immediately upon signal. */
+			FUSION_SKIRMISH_LOG
+			    ("FusionSkirmish: Interrupted while waiting for relock!\n");
+			return ret2;
+
+		default:
+			/* Return immediately upon unusual result. */
+			FUSION_SKIRMISH_LOG
+			    ("FusionSkirmish: Error while waiting for notification (%d)!\n",
+			     ret2);
+			return ret2;
+		}
+	}
 
 #ifdef FUSION_BLOCK_SIGNALS
-     if (current->pid <= PID_MAX_DEFAULT && !m_pidlocks[current->pid]++)
-          block_all_signals( skirmish_signal_handler, dev, &m_sigmask );
+	if (current->pid <= PID_MAX_DEFAULT && !m_pidlocks[current->pid]++)
+		block_all_signals(skirmish_signal_handler, dev, &m_sigmask);
 #endif
 
-     skirmish->lock_fid   = fusion_id;
-     skirmish->lock_pid   = current->pid;
-     skirmish->lock_count = wait->lock_count;
+	skirmish->lock_fid   = fusion_id;
+	skirmish->lock_pid   = current->pid;
+	skirmish->lock_count = wait->lock_count;
 
-     fusion_skirmish_unlock( skirmish );
+	fusion_skirmish_unlock(skirmish);
 
-     FUSION_SKIRMISH_LOG( "FusionSkirmish: ...done (%d).\n", ret );
+	FUSION_SKIRMISH_LOG("FusionSkirmish: ...done (%d).\n", ret);
 
-     return ret;
+	return ret;
 }
 
-int
-fusion_skirmish_notify_ (FusionDev *dev, int id, FusionID fusion_id)
+int fusion_skirmish_notify_(FusionDev * dev, int id, FusionID fusion_id)
 {
-     int             ret;
-     FusionSkirmish *skirmish;
+	int ret;
+	FusionSkirmish *skirmish;
 
-     ret = fusion_skirmish_lock( &dev->skirmish, id, false, &skirmish );
-     if (ret)
-          return ret;
+	ret = fusion_skirmish_lock(&dev->skirmish, id, false, &skirmish);
+	if (ret)
+		return ret;
 
-     dev->stat.skirmish_notify++;
+	dev->stat.skirmish_notify++;
 
-     if (skirmish->lock_pid != current->pid) {
-          fusion_skirmish_unlock( skirmish );
-          return -EIO;
-     }
+	if (skirmish->lock_pid != current->pid) {
+		fusion_skirmish_unlock(skirmish);
+		return -EIO;
+	}
 
-     skirmish->notify_count++;
+	skirmish->notify_count++;
 
-     fusion_skirmish_notify( skirmish, true );
+	fusion_skirmish_notify(skirmish, true);
 
-     fusion_skirmish_unlock( skirmish );
+	fusion_skirmish_unlock(skirmish);
 
-     return 0;
+	return 0;
 }
 
-void
-fusion_skirmish_dismiss_all (FusionDev *dev, int fusion_id)
+void fusion_skirmish_dismiss_all(FusionDev * dev, int fusion_id)
 {
-     FusionLink *l;
+	FusionLink *l;
 
-     down (&dev->skirmish.lock);
+	down(&dev->skirmish.lock);
 
-     fusion_list_foreach (l, dev->skirmish.list) {
-          FusionSkirmish *skirmish = (FusionSkirmish *) l;
+	fusion_list_foreach(l, dev->skirmish.list) {
+		FusionSkirmish *skirmish = (FusionSkirmish *) l;
 
-          down (&skirmish->entry.lock);
+		down(&skirmish->entry.lock);
 
-          if (skirmish->lock_fid == fusion_id) {
-               m_pidlocks[skirmish->lock_pid] = 0;
+		if (skirmish->lock_fid == fusion_id) {
+			m_pidlocks[skirmish->lock_pid] = 0;
 
-               skirmish->lock_fid   = 0;
-               skirmish->lock_pid   = 0;
-               skirmish->lock_count = 0;
+			skirmish->lock_fid   = 0;
+			skirmish->lock_pid   = 0;
+			skirmish->lock_count = 0;
 
-               wake_up_interruptible_all (&skirmish->entry.wait);
-          }
+			wake_up_interruptible_all(&skirmish->entry.wait);
+		}
 
-          if (skirmish->transfer_from == fusion_id) {
-               skirmish->transfer_to       = 0;
-               skirmish->transfer_from     = 0;
-               skirmish->transfer_from_pid = 0;
-               skirmish->transfer_count    = 0;
+		if (skirmish->transfer_from == fusion_id) {
+			skirmish->transfer_to       = 0;
+			skirmish->transfer_from     = 0;
+			skirmish->transfer_from_pid = 0;
+			skirmish->transfer_count    = 0;
 
-               wake_up_interruptible_all (&skirmish->entry.wait);
-          }
+			wake_up_interruptible_all(&skirmish->entry.wait);
+		}
 
-          up (&skirmish->entry.lock);
-     }
+		up(&skirmish->entry.lock);
+	}
 
-     up (&dev->skirmish.lock);
+	up(&dev->skirmish.lock);
 }
 
-void
-fusion_skirmish_dismiss_all_from_pid (FusionDev *dev, int pid)
+void fusion_skirmish_dismiss_all_from_pid(FusionDev * dev, int pid)
 {
-     FusionLink *l;
+	FusionLink *l;
 
-     down (&dev->skirmish.lock);
+	down(&dev->skirmish.lock);
 
-     m_pidlocks[pid] = 0;
+	m_pidlocks[pid] = 0;
 
-     fusion_list_foreach (l, dev->skirmish.list) {
-          FusionSkirmish *skirmish = (FusionSkirmish *) l;
+	fusion_list_foreach(l, dev->skirmish.list) {
+		FusionSkirmish *skirmish = (FusionSkirmish *) l;
 
-          down (&skirmish->entry.lock);
+		down(&skirmish->entry.lock);
 
-          if (skirmish->lock_pid == pid) {
-               skirmish->lock_fid   = 0;
-               skirmish->lock_pid   = 0;
-               skirmish->lock_count = 0;
+		if (skirmish->lock_pid == pid) {
+			skirmish->lock_fid   = 0;
+			skirmish->lock_pid   = 0;
+			skirmish->lock_count = 0;
 
-               wake_up_interruptible_all (&skirmish->entry.wait);
-          }
+			wake_up_interruptible_all(&skirmish->entry.wait);
+		}
 
-          if (skirmish->transfer_from_pid == pid) {
-               skirmish->transfer_to       = 0;
-               skirmish->transfer_from     = 0;
-               skirmish->transfer_from_pid = 0;
-               skirmish->transfer_count    = 0;
+		if (skirmish->transfer_from_pid == pid) {
+			skirmish->transfer_to       = 0;
+			skirmish->transfer_from     = 0;
+			skirmish->transfer_from_pid = 0;
+			skirmish->transfer_count    = 0;
 
-               wake_up_interruptible_all (&skirmish->entry.wait);
-          }
+			wake_up_interruptible_all(&skirmish->entry.wait);
+		}
 
-          up (&skirmish->entry.lock);
-     }
+		up(&skirmish->entry.lock);
+	}
 
-     up (&dev->skirmish.lock);
+	up(&dev->skirmish.lock);
 }
 
 void
-fusion_skirmish_transfer_all (FusionDev *dev,
-                              FusionID   to,
-                              FusionID   from,
-                              int        from_pid)
+fusion_skirmish_transfer_all(FusionDev * dev,
+			     FusionID to, FusionID from, int from_pid)
 {
-     FusionLink *l;
+	FusionLink *l;
 
-     down (&dev->skirmish.lock);
+	down(&dev->skirmish.lock);
 
-     fusion_list_foreach (l, dev->skirmish.list) {
-          FusionSkirmish *skirmish = (FusionSkirmish *) l;
+	fusion_list_foreach(l, dev->skirmish.list) {
+		FusionSkirmish *skirmish = (FusionSkirmish *) l;
 
-          down (&skirmish->entry.lock);
+		down(&skirmish->entry.lock);
 
-          if (skirmish->lock_pid == from_pid) {
-               FUSION_ASSERT( skirmish->transfer_to == 0 );
-               FUSION_ASSERT( skirmish->transfer_from == 0 );
-               FUSION_ASSERT( skirmish->transfer_from_pid == 0 );
-               FUSION_ASSERT( skirmish->transfer_count == 0 );
-               FUSION_ASSERT( skirmish->lock_count > 0 );
+		if (skirmish->lock_pid == from_pid) {
+			FUSION_ASSERT(skirmish->transfer_to == 0);
+			FUSION_ASSERT(skirmish->transfer_from == 0);
+			FUSION_ASSERT(skirmish->transfer_from_pid == 0);
+			FUSION_ASSERT(skirmish->transfer_count == 0);
+			FUSION_ASSERT(skirmish->lock_count > 0);
 
-               skirmish->transfer_to       = to;
-               skirmish->transfer_from     = from;
-               skirmish->transfer_from_pid = from_pid;
-               skirmish->transfer_count    = skirmish->lock_count;
+			skirmish->transfer_to       = to;
+			skirmish->transfer_from     = from;
+			skirmish->transfer_from_pid = from_pid;
+			skirmish->transfer_count    = skirmish->lock_count;
 
-               skirmish->lock_fid   = 0;
-               skirmish->lock_pid   = 0;
-               skirmish->lock_count = 0;
+			skirmish->lock_fid   = 0;
+			skirmish->lock_pid   = 0;
+			skirmish->lock_count = 0;
 
-               wake_up_interruptible_all (&skirmish->entry.wait);
-          }
+			wake_up_interruptible_all(&skirmish->entry.wait);
+		}
 
-          up (&skirmish->entry.lock);
-     }
+		up(&skirmish->entry.lock);
+	}
 
-     up (&dev->skirmish.lock);
+	up(&dev->skirmish.lock);
 }
 
-void
-fusion_skirmish_reclaim_all (FusionDev *dev,
-                             int        from_pid)
+void fusion_skirmish_reclaim_all(FusionDev * dev, int from_pid)
 {
-     FusionLink *l;
+	FusionLink *l;
 
-     down (&dev->skirmish.lock);
+	down(&dev->skirmish.lock);
 
-     fusion_list_foreach (l, dev->skirmish.list) {
-          FusionSkirmish *skirmish = (FusionSkirmish *) l;
+	fusion_list_foreach(l, dev->skirmish.list) {
+		FusionSkirmish *skirmish = (FusionSkirmish *) l;
 
-          down (&skirmish->entry.lock);
+		down(&skirmish->entry.lock);
 
-          if (skirmish->transfer_from_pid == from_pid) {
-               FUSION_ASSERT( skirmish->transfer_to != 0 );
-               FUSION_ASSERT( skirmish->transfer_from != 0 );
-               FUSION_ASSERT( skirmish->transfer_count > 0 );
-               FUSION_ASSUME( skirmish->lock_pid == 0 );
+		if (skirmish->transfer_from_pid == from_pid) {
+			FUSION_ASSERT(skirmish->transfer_to != 0);
+			FUSION_ASSERT(skirmish->transfer_from != 0);
+			FUSION_ASSERT(skirmish->transfer_count > 0);
+			FUSION_ASSUME(skirmish->lock_pid == 0);
 
-               skirmish->lock_fid   = skirmish->transfer_from;
-               skirmish->lock_pid   = skirmish->transfer_from_pid;
-               skirmish->lock_count = skirmish->transfer_count;
+			skirmish->lock_fid   = skirmish->transfer_from;
+			skirmish->lock_pid   = skirmish->transfer_from_pid;
+			skirmish->lock_count = skirmish->transfer_count;
 
-               skirmish->transfer_to       = 0;
-               skirmish->transfer_from     = 0;
-               skirmish->transfer_from_pid = 0;
-               skirmish->transfer_count    = 0;
-          }
+			skirmish->transfer_to       = 0;
+			skirmish->transfer_from     = 0;
+			skirmish->transfer_from_pid = 0;
+			skirmish->transfer_count    = 0;
+		}
 
-          up (&skirmish->entry.lock);
-     }
+		up(&skirmish->entry.lock);
+	}
 
-     up (&dev->skirmish.lock);
+	up(&dev->skirmish.lock);
 }
-
diff --git a/drivers/char/fusion/skirmish.h b/drivers/char/fusion/skirmish.h
index e60b40a..f68a462 100644
--- a/drivers/char/fusion/skirmish.h
+++ b/drivers/char/fusion/skirmish.h
@@ -18,61 +18,40 @@
 #include "fusiondev.h"
 #include "types.h"
 
-
 /* module init/cleanup */
 
-int  fusion_skirmish_init   (FusionDev *dev);
-void fusion_skirmish_deinit (FusionDev *dev);
-
+int fusion_skirmish_init(FusionDev * dev);
+void fusion_skirmish_deinit(FusionDev * dev);
 
 /* public API */
 
-int fusion_skirmish_new     (FusionDev *dev,
-                             int       *id);
-
-int fusion_skirmish_prevail (FusionDev *dev,
-                             int        id,
-                             int        fusion_id);
+int fusion_skirmish_new(FusionDev * dev, int *id);
 
-int fusion_skirmish_swoop   (FusionDev *dev,
-                             int        id,
-                             int        fusion_id);
+int fusion_skirmish_prevail(FusionDev * dev, int id, int fusion_id);
 
-int fusion_skirmish_lock_count (FusionDev *dev,
-                                int     id,
-                                int     fusion_id,
-                                int    *ret_lock_count);
+int fusion_skirmish_swoop(FusionDev * dev, int id, int fusion_id);
 
-int fusion_skirmish_dismiss (FusionDev *dev,
-                             int        id,
-                             int        fusion_id);
+int fusion_skirmish_lock_count(FusionDev * dev,
+			       int id, int fusion_id, int *ret_lock_count);
 
-int fusion_skirmish_destroy (FusionDev *dev,
-                             int        id);
+int fusion_skirmish_dismiss(FusionDev * dev, int id, int fusion_id);
 
-int fusion_skirmish_wait_   (FusionDev          *dev,
-                             FusionSkirmishWait *wait,
-                             FusionID            fusion_id);
+int fusion_skirmish_destroy(FusionDev * dev, int id);
 
-int fusion_skirmish_notify_ (FusionDev *dev,
-                             int        id,
-                             FusionID   fusion_id);
+int fusion_skirmish_wait_(FusionDev * dev,
+			  FusionSkirmishWait * wait, FusionID fusion_id);
 
+int fusion_skirmish_notify_(FusionDev * dev, int id, FusionID fusion_id);
 
 /* internal functions */
 
-void fusion_skirmish_dismiss_all (FusionDev *dev,
-                                  int        fusion_id);
+void fusion_skirmish_dismiss_all(FusionDev * dev, int fusion_id);
 
-void fusion_skirmish_dismiss_all_from_pid (FusionDev *dev,
-                                           int        pid);
+void fusion_skirmish_dismiss_all_from_pid(FusionDev * dev, int pid);
 
-void fusion_skirmish_transfer_all (FusionDev *dev,
-                                   FusionID   to,
-                                   FusionID   from,
-                                   int        from_pid);
+void fusion_skirmish_transfer_all(FusionDev * dev,
+				  FusionID to, FusionID from, int from_pid);
 
-void fusion_skirmish_reclaim_all (FusionDev *dev,
-                                  int        from_pid);
+void fusion_skirmish_reclaim_all(FusionDev * dev, int from_pid);
 
 #endif
diff --git a/drivers/char/fusion/types.h b/drivers/char/fusion/types.h
index 22ced8c..589250f 100644
--- a/drivers/char/fusion/types.h
+++ b/drivers/char/fusion/types.h
@@ -11,7 +11,7 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  */
- 
+
 #ifndef __FUSION__TYPES_H__
 #define __FUSION__TYPES_H__
 
@@ -19,18 +19,15 @@
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
 typedef enum {
-  false = 0,
-  true  = !false
+	false = 0,
+	true = !false
 } bool;
 #endif
 
 typedef struct __Fusion_FusionDev FusionDev;
-typedef struct __Fusion_Fusionee  Fusionee;
-
+typedef struct __Fusion_Fusionee Fusionee;
 
-typedef void (*MessageCallback)( FusionDev *dev,
-                                 int        msg_id,
-                                 void      *ctx,
-                                 int        param );
+typedef void (*MessageCallback) (FusionDev * dev,
+				 int msg_id, void *ctx, int param);
 
 #endif
diff --git a/include/linux/fusion.h b/include/linux/fusion.h
index 9081653..1170a56 100644
--- a/include/linux/fusion.h
+++ b/include/linux/fusion.h
@@ -1,3 +1,17 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
 #ifndef __LINUX__FUSION_H__
 #define __LINUX__FUSION_H__
 
@@ -21,7 +35,7 @@
  */
 typedef unsigned long FusionID;
 
-#define FUSION_ID_MASTER      1         /* This is the fusion id of the master (first process). */
+#define FUSION_ID_MASTER     1	/* This is the fusion id of the master (first process). */
 
 /*
  * Entering a world
@@ -29,79 +43,79 @@ typedef unsigned long FusionID;
  * supported are API 3.x for DirectFB 1.0.x, API 4.x for DirectFB 1.1.x, and API 8.x for DirectFB 1.2.x and beyond.
  */
 typedef struct {
-     struct {
-          int            major;
-          int            minor;
-     } api;
+	struct {
+		int major;
+		int minor;
+	} api;
 
-     FusionID            fusion_id;     /* Returns the fusion id of the entering process. */
+	FusionID fusion_id;	/* Returns the fusion id of the entering process. */
 } FusionEnter;
 
 /*
  * Forking in world
  */
 typedef struct {
-     FusionID            fusion_id;     /* Returns the fusion id of the new (forked) fusionee. */
+	FusionID fusion_id;	/* Returns the fusion id of the new (forked) fusionee. */
 } FusionFork;
 
 /*
  * Sending a message
  */
 typedef struct {
-     FusionID            fusion_id;     /* recipient */
+	FusionID fusion_id;	/* recipient */
 
-     int                 msg_id;        /* optional message identifier */
-     int                 msg_channel;   /* optional channel number */
-     int                 msg_size;      /* message size, must be greater than zero */
-     const void         *msg_data;      /* message data, must not be NULL */
+	int msg_id;		/* optional message identifier */
+	int msg_channel;	/* optional channel number */
+	int msg_size;		/* message size, must be greater than zero */
+	const void *msg_data;	/* message data, must not be NULL */
 } FusionSendMessage;
 
 /*
  * Receiving a message
  */
 typedef enum {
-     FMT_SEND,                          /* msg_id is an optional custom id */
-     FMT_CALL,                          /* msg_id is the call id */
-     FMT_REACTOR,                       /* msg_id is the reactor id */
-     FMT_SHMPOOL                        /* msg_id is the pool id */
+	FMT_SEND,		/* msg_id is an optional custom id */
+	FMT_CALL,		/* msg_id is the call id */
+	FMT_REACTOR,		/* msg_id is the reactor id */
+	FMT_SHMPOOL		/* msg_id is the pool id */
 } FusionMessageType;
 
 typedef struct {
-     FusionMessageType   msg_type;      /* type (origin) of message */
+	FusionMessageType msg_type;	/* type (origin) of message */
 
-     int                 msg_id;        /* message id (custom id or call/reactor/pool id) */
-     int                 msg_size;      /* size of the following message data */
-     int                 msg_channel;   /* optional or reactor channel */
+	int msg_id;		/* message id (custom id or call/reactor/pool id) */
+	int msg_size;		/* size of the following message data */
+	int msg_channel;	/* optional or reactor channel */
 
-     /* message data follows */
+	/* message data follows */
 } FusionReadMessage;
 
 /*
  * Dispatching a message via a reactor
  */
 typedef struct {
-     int                 reactor_id;    /* id of target reactor */
-     int                 channel;       /* optional reactor channel (0-1023) */
-     int                 self;          /* send to ourself if attached */
+	int reactor_id;		/* id of target reactor */
+	int channel;		/* optional reactor channel (0-1023) */
+	int self;		/* send to ourself if attached */
 
-     int                 msg_size;      /* message size, must be greater than zero */
-     const void         *msg_data;      /* message data, must not be NULL */
+	int msg_size;		/* message size, must be greater than zero */
+	const void *msg_data;	/* message data, must not be NULL */
 } FusionReactorDispatch;
 
 /*
  * Attaching to a reactor
  */
 typedef struct {
-     int                 reactor_id;
-     int                 channel;
+	int reactor_id;
+	int channel;
 } FusionReactorAttach;
 
 /*
  * Detaching from a reactor
  */
 typedef struct {
-     int                 reactor_id;
-     int                 channel;
+	int reactor_id;
+	int channel;
 } FusionReactorDetach;
 
 /*
@@ -110,58 +124,58 @@ typedef struct {
  * The call_arg will be set to the channel number
  */
 typedef struct {
-     int                 reactor_id;
+	int reactor_id;
 
-     int                 call_id;       /* id of the call to execute when a message has been
-                                           processed by all recipients of the dispatch */
-     int                *call_ptr;      /* optional call parameter, e.g. the pointer of a user
-                                           space resource associated with that reference */
+	int call_id;		/* id of the call to execute when a message has been
+				   processed by all recipients of the dispatch */
+	int *call_ptr;		/* optional call parameter, e.g. the pointer of a user
+				   space resource associated with that reference */
 } FusionReactorSetCallback;
 
 /*
  * Calling (synchronous RPC)
  */
 typedef struct {
-     int                 call_id;       /* new call id returned */
+	int call_id;		/* new call id returned */
 
-     void               *handler;       /* function pointer of handler to install */
-     void               *ctx;           /* optional handler context */
+	void *handler;		/* function pointer of handler to install */
+	void *ctx;		/* optional handler context */
 } FusionCallNew;
 
 typedef enum {
-     FCEF_NONE   = 0x00000000,
-     FCEF_ONEWAY = 0x00000001,
-     FCEF_ALL    = 0x00000001
+	FCEF_NONE   = 0x00000000,
+	FCEF_ONEWAY = 0x00000001,
+	FCEF_ALL    = 0x00000001
 } FusionCallExecFlags;
 
 typedef struct {
-     int                 ret_val;       /* return value of the call */
+	int ret_val;		/* return value of the call */
 
-     int                 call_id;       /* id of the requested call, each call has a fixed owner */
+	int call_id;		/* id of the requested call, each call has a fixed owner */
 
-     int                 call_arg;      /* optional int argument */
-     void               *call_ptr;      /* optional pointer argument (shared memory) */
+	int call_arg;		/* optional int argument */
+	void *call_ptr;		/* optional pointer argument (shared memory) */
 
-     FusionCallExecFlags flags;         /* execution flags */
+	FusionCallExecFlags flags;	/* execution flags */
 } FusionCallExecute;
 
 typedef struct {
-     int                 call_id;       /* id of currently executing call */
+	int call_id;		/* id of currently executing call */
 
-     int                 val;           /* value to return */
+	int val;		/* value to return */
 
-     unsigned int        serial;        
+	unsigned int serial;
 } FusionCallReturn;
 
 typedef struct {
-     void               *handler;       /* function pointer of handler to call */
-     void               *ctx;           /* optional handler context */
+	void *handler;		/* function pointer of handler to call */
+	void *ctx;		/* optional handler context */
 
-     int                 caller;        /* fusion id of the caller or zero if called from Fusion */
-     int                 call_arg;      /* optional call parameter */
-     void               *call_ptr;      /* optional call parameter */
+	int caller;		/* fusion id of the caller or zero if called from Fusion */
+	int call_arg;		/* optional call parameter */
+	void *call_ptr;		/* optional call parameter */
 
-     unsigned int        serial;        /* serial number of call, used for return, zero if nothing shall be returned */
+	unsigned int serial;	/* serial number of call, used for return, zero if nothing shall be returned */
 } FusionCallMessage;
 
 /*
@@ -174,107 +188,102 @@ typedef struct {
  *
  */
 typedef struct {
-     int                 id;            /* id of the reference to watch */
+	int id;			/* id of the reference to watch */
 
-     int                 call_id;       /* id of the call to execute */
-     int                 call_arg;      /* optional call parameter, e.g. the id of a user
-                                           space resource associated with that reference */
+	int call_id;		/* id of the call to execute */
+	int call_arg;		/* optional call parameter, e.g. the id of a user
+				   space resource associated with that reference */
 } FusionRefWatch;
 
 /*
  * Inheriting local count from other reference
  */
 typedef struct {
-     int                 id;            /* own reference id */
-     int                 from;          /* id of the reference to inherit from */
+	int id;			/* own reference id */
+	int from;		/* id of the reference to inherit from */
 } FusionRefInherit;
 
 /*
  * Killing other fusionees (experimental)
  */
 typedef struct {
-     FusionID            fusion_id;     /* fusionee to kill, zero means all but ourself */
-     int                 signal;        /* signal to be delivered, e.g. SIGTERM */
-     int                 timeout_ms;    /* -1 means no timeout, 0 means infinite, otherwise the
-                                           max. time to wait until the fusionee(s) terminated */
+	FusionID fusion_id;	/* fusionee to kill, zero means all but ourself */
+	int signal;		/* signal to be delivered, e.g. SIGTERM */
+	int timeout_ms;		/* -1 means no timeout, 0 means infinite, otherwise the
+				   max. time to wait until the fusionee(s) terminated */
 } FusionKill;
 
 /*
  * Wait for a skirmish notification
  */
 typedef struct {
-     int                 id;            /* skirmish id */
-     unsigned int        timeout;       /* timeout in ms (0 = unlimited) */
+	int id;			/* skirmish id */
+	unsigned int timeout;	/* timeout in ms (0 = unlimited) */
 
-     unsigned int        lock_count;    /* MUST be set to zero, MUST NOT be reset when the system call is resumed. */
-     unsigned int        notify_count;  /* MUST NOT be reset when the system call is resumed after a signal. */
+	unsigned int lock_count;	/* MUST be set to zero, MUST NOT be reset when the system call is resumed. */
+	unsigned int notify_count;	/* MUST NOT be reset when the system call is resumed after a signal. */
 } FusionSkirmishWait;
 
-
 /*
  * Shared memory pools
  */
 typedef struct {
-     int                 max_size;      /* Maximum size that this pool will be allowed to grow to. */
+	int max_size;		/* Maximum size that this pool will be allowed to grow to. */
 
-     int                 pool_id;       /* Returns the new pool id. */
-     void               *addr_base;     /* Returns the base of the reserved virtual memory address space. */
+	int pool_id;		/* Returns the new pool id. */
+	void *addr_base;	/* Returns the base of the reserved virtual memory address space. */
 } FusionSHMPoolNew;
 
 typedef struct {
-     int                 pool_id;       /* The id of the pool to attach to. */
+	int pool_id;		/* The id of the pool to attach to. */
 
-     void               *addr_base;     /* Returns the base of the reserved virtual memory address space. */
-     int                 size;          /* Returns the current size of the pool. */
+	void *addr_base;	/* Returns the base of the reserved virtual memory address space. */
+	int size;		/* Returns the current size of the pool. */
 } FusionSHMPoolAttach;
 
 typedef struct {
-     int                 pool_id;       /* The id of the pool to notify. */
+	int pool_id;		/* The id of the pool to notify. */
 
-     int                 size;          /* New size of the pool. */
+	int size;		/* New size of the pool. */
 } FusionSHMPoolDispatch;
 
 typedef enum {
-     FSMT_REMAP,                        /* Remap the pool due to a change of its size. */
-     FSMT_UNMAP                         /* Unmap the pool due to its destruction. */
+	FSMT_REMAP,		/* Remap the pool due to a change of its size. */
+	FSMT_UNMAP		/* Unmap the pool due to its destruction. */
 } FusionSHMPoolMessageType;
 
 typedef struct {
-     FusionSHMPoolMessageType type;     /* Type of the message. */
+	FusionSHMPoolMessageType type;	/* Type of the message. */
 
-     int                      size;     /* New size of the pool, if type is FSMT_REMAP. */
+	int size;		/* New size of the pool, if type is FSMT_REMAP. */
 } FusionSHMPoolMessage;
 
-
 /*
  * Fusion types
  */
 typedef enum {
-     FT_LOUNGE,
-     FT_MESSAGING,
-     FT_CALL,
-     FT_REF,
-     FT_SKIRMISH,
-     FT_PROPERTY,
-     FT_REACTOR,
-     FT_SHMPOOL
+	FT_LOUNGE,
+	FT_MESSAGING,
+	FT_CALL,
+	FT_REF,
+	FT_SKIRMISH,
+	FT_PROPERTY,
+	FT_REACTOR,
+	FT_SHMPOOL
 } FusionType;
 
-
 /*
  * Set attributes like 'name' for an entry of the specified type.
  */
 #define FUSION_ENTRY_INFO_NAME_LENGTH   24
 
 typedef struct {
-     FusionType          type;
-     int                 id;
+	FusionType type;
+	int id;
 
-     char                name[FUSION_ENTRY_INFO_NAME_LENGTH];
+	char name[FUSION_ENTRY_INFO_NAME_LENGTH];
 } FusionEntryInfo;
 
-
-
 #define FUSION_ENTER                         _IOR(FT_LOUNGE,    0x00, FusionEnter)
 #define FUSION_UNBLOCK                       _IO (FT_LOUNGE,    0x01)
 #define FUSION_KILL                          _IOW(FT_LOUNGE,    0x02, FusionKill)
@@ -334,4 +343,3 @@ typedef struct {
 #define FUSION_SHMPOOL_DESTROY               _IOW(FT_SHMPOOL,   0x04, int)
 
 #endif
-
-- 
1.7.3.3

