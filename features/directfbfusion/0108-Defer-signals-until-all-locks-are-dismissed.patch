From 2dae2d2d2ff980687aa27b2b00bd758d8cf9999d Mon Sep 17 00:00:00 2001
From: Denis Oliver Kropp <dok@shizo.(none)>
Date: Tue, 29 May 2007 13:55:36 +0200
Subject: [PATCH] Defer signals until all locks are dismissed.

---
 drivers/char/fusion/skirmish.c |   35 +++++++++++++++++++++++++++++++++++
 1 files changed, 35 insertions(+), 0 deletions(-)

diff --git a/drivers/char/fusion/skirmish.c b/drivers/char/fusion/skirmish.c
index edd8e13..109c7ff 100644
--- a/drivers/char/fusion/skirmish.c
+++ b/drivers/char/fusion/skirmish.c
@@ -52,6 +52,20 @@ struct __FUSION_FusionSkirmish {
 #endif
 };
 
+/******************************************************************************/
+
+static unsigned int m_pidlocks[PID_MAX_DEFAULT+1];  /* FIXME: find cleaner, but still fast method */
+static sigset_t     m_sigmask;
+
+static int
+skirmish_signal_handler( void *ctx )
+{
+     printk( KERN_DEBUG "FusionSkirmish: Blocking signal for process %d!\n", current->pid );
+     return 0;
+}
+
+/******************************************************************************/
+
 static int
 fusion_skirmish_print( FusionEntry *entry,
                        void        *ctx,
@@ -107,6 +121,8 @@ fusion_skirmish_init (FusionDev *dev)
      create_proc_read_entry( "skirmishs", 0, dev->proc_dir,
                              fusion_entries_read_proc, &dev->skirmish );
 
+     sigfillset( &m_sigmask );
+
      return 0;
 }
 
@@ -217,6 +233,9 @@ fusion_skirmish_prevail (FusionDev *dev, int id, int fusion_id)
                return ret;
      }
 
+     if (current->pid <= PID_MAX_DEFAULT && !m_pidlocks[current->pid]++)
+          block_all_signals( skirmish_signal_handler, dev, &m_sigmask );
+
      skirmish->lock_fid   = fusion_id;
      skirmish->lock_pid   = current->pid;
      skirmish->lock_count = 1;
@@ -253,6 +272,9 @@ fusion_skirmish_swoop (FusionDev *dev, int id, int fusion_id)
           return -EAGAIN;
      }
 
+     if (current->pid <= PID_MAX_DEFAULT && !m_pidlocks[current->pid]++)
+          block_all_signals( skirmish_signal_handler, dev, &m_sigmask );
+
      skirmish->lock_fid   = fusion_id;
      skirmish->lock_pid   = current->pid;
      skirmish->lock_count = 1;
@@ -311,6 +333,9 @@ fusion_skirmish_dismiss (FusionDev *dev, int id, int fusion_id)
           skirmish->lock_pid = 0;
 
           fusion_skirmish_notify( skirmish, true );
+
+          if (current->pid <= PID_MAX_DEFAULT && ! --m_pidlocks[current->pid])
+               unblock_all_signals();
      }
 
      fusion_skirmish_unlock( skirmish );
@@ -370,6 +395,9 @@ fusion_skirmish_wait_ (FusionDev *dev, int id, int fusion_id)
      skirmish->lock_fid = 0;
      skirmish->lock_pid = 0;
 
+     if (current->pid <= PID_MAX_DEFAULT && ! --m_pidlocks[current->pid])
+          unblock_all_signals();
+
      fusion_skirmish_notify( skirmish, true );
 
      while (notify_count == skirmish->notify_count) {
@@ -384,6 +412,9 @@ fusion_skirmish_wait_ (FusionDev *dev, int id, int fusion_id)
                return ret;
      }
 
+     if (current->pid <= PID_MAX_DEFAULT && !m_pidlocks[current->pid]++)
+          block_all_signals( skirmish_signal_handler, dev, &m_sigmask );
+
      skirmish->lock_fid   = fusion_id;
      skirmish->lock_pid   = current->pid;
      skirmish->lock_count = lock_count;
@@ -436,6 +467,8 @@ fusion_skirmish_dismiss_all (FusionDev *dev, int fusion_id)
                skirmish->lock_pid   = 0;
                skirmish->lock_count = 0;
 
+               /* FIXME: unblock? */
+
                wake_up_interruptible_all (&skirmish->entry.wait);
           }
 
@@ -462,6 +495,8 @@ fusion_skirmish_dismiss_all_from_pid (FusionDev *dev, int pid)
                skirmish->lock_pid   = 0;
                skirmish->lock_count = 0;
 
+               /* FIXME: unblock? */
+
                wake_up_interruptible_all (&skirmish->entry.wait);
           }
 
-- 
1.7.3.3

