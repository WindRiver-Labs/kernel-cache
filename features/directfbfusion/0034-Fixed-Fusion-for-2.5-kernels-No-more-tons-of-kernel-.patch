From 0eda43cf5d6c905d5743354f69b6e605e02f8f9f Mon Sep 17 00:00:00 2001
From: Denis Oliver Kropp <dok@directfb.org>
Date: Thu, 5 Jun 2003 14:32:08 +0000
Subject: [PATCH] Fixed Fusion for 2.5 kernels! No more tons of kernel debug messages, not even a single note about a process exitting with an active preempt counter.

1)
Call kmalloc() with GFP_ATOMIC instead of GFP_KERNEL which isn't allowed while a
spinlock is held. I'm not sure if we should use GFP_ATOMIC including __GFP_HIGH,
but it's the only GFP_* which doesn't include the offending __GFP_WAIT.

2)
Added missing spin_unlock() calls. I didn't forget them but dropped the
unlock in case the spinlock is thrown away and never locked again anyways.
Unfortunately these are always required for preemptible kernels because
spin_lock/unlock() increase/decrease the preempt counter.
---
 drivers/char/fusion/call.c     |   13 +++++++------
 drivers/char/fusion/fusionee.c |    6 ++++--
 drivers/char/fusion/property.c |    4 +++-
 drivers/char/fusion/reactor.c  |    6 ++++--
 drivers/char/fusion/ref.c      |    6 ++++--
 drivers/char/fusion/skirmish.c |    4 +++-
 6 files changed, 25 insertions(+), 14 deletions(-)

diff --git a/drivers/char/fusion/call.c b/drivers/char/fusion/call.c
index 6463749..5221b58 100644
--- a/drivers/char/fusion/call.c
+++ b/drivers/char/fusion/call.c
@@ -171,7 +171,7 @@ fusion_call_new (int fusion_id, FusionCallNew *call_new)
 {
   FusionCall *call;
 
-  call = kmalloc (sizeof(FusionCall), GFP_KERNEL);
+  call = kmalloc (sizeof(FusionCall), GFP_ATOMIC);
   if (!call)
     return -ENOMEM;
 
@@ -249,10 +249,7 @@ fusion_call_execute (int fusion_id, FusionCallExecute *execute)
   kfree (execution);
 
   if (signal_pending(current))
-    {
-      unlock_call (call);
-      return -ERESTARTSYS;
-    }
+    ret = -ERESTARTSYS;
 
   unlock_call (call);
 
@@ -312,6 +309,8 @@ fusion_call_destroy (int fusion_id, int call_id)
 
   spin_unlock (&calls_lock);
 
+  spin_unlock (&call->lock);
+  
   kfree (call);
 
   return 0;
@@ -339,6 +338,8 @@ fusion_call_destroy_all (int fusion_id)
 
           fusion_list_remove (&calls, &call->link);
 
+          spin_unlock (&call->lock);
+          
           kfree (call);
         }
       else
@@ -402,7 +403,7 @@ add_execution (FusionCall        *call,
   FusionCallExecution *execution;
 
   /* Allocate execution. */
-  execution = kmalloc (sizeof(FusionCallExecution), GFP_KERNEL);
+  execution = kmalloc (sizeof(FusionCallExecution), GFP_ATOMIC);
   if (!execution)
     return NULL;
 
diff --git a/drivers/char/fusion/fusionee.c b/drivers/char/fusion/fusionee.c
index 0663b9e..705ae60 100644
--- a/drivers/char/fusion/fusionee.c
+++ b/drivers/char/fusion/fusionee.c
@@ -174,7 +174,7 @@ fusionee_new (int *id)
 {
   Fusionee *fusionee;
 
-  fusionee = kmalloc (sizeof(Fusionee), GFP_KERNEL);
+  fusionee = kmalloc (sizeof(Fusionee), GFP_ATOMIC);
   if (!fusionee)
     return -ENOMEM;
 
@@ -215,7 +215,7 @@ fusionee_send_message (int id, int recipient, FusionMessageType msg_type,
       return -EIO;
     }
 
-  message = kmalloc (sizeof(Message) + msg_size, GFP_KERNEL);
+  message = kmalloc (sizeof(Message) + msg_size, GFP_ATOMIC);
   if (!message)
     {
       unlock_fusionee (sender);
@@ -444,6 +444,8 @@ fusionee_destroy (int id)
       kfree (message);
     }
 
+  spin_unlock (&fusionee->lock);
+  
   kfree (fusionee);
 
   return 0;
diff --git a/drivers/char/fusion/property.c b/drivers/char/fusion/property.c
index 10ea90b..7c822bf 100644
--- a/drivers/char/fusion/property.c
+++ b/drivers/char/fusion/property.c
@@ -153,7 +153,7 @@ fusion_property_new (int *id)
 {
   FusionProperty *property;
 
-  property = kmalloc (sizeof(FusionProperty), GFP_KERNEL);
+  property = kmalloc (sizeof(FusionProperty), GFP_ATOMIC);
   if (!property)
     return -ENOMEM;
 
@@ -371,6 +371,8 @@ fusion_property_destroy (int id)
 
   spin_unlock (&properties_lock);
 
+  spin_unlock (&property->lock);
+  
   kfree (property);
 
   return 0;
diff --git a/drivers/char/fusion/reactor.c b/drivers/char/fusion/reactor.c
index 3b5955c..aede742 100644
--- a/drivers/char/fusion/reactor.c
+++ b/drivers/char/fusion/reactor.c
@@ -155,7 +155,7 @@ fusion_reactor_new (int *id)
 {
   FusionReactor *reactor;
 
-  reactor = kmalloc (sizeof(FusionReactor), GFP_KERNEL);
+  reactor = kmalloc (sizeof(FusionReactor), GFP_ATOMIC);
   if (!reactor)
     return -ENOMEM;
 
@@ -188,7 +188,7 @@ fusion_reactor_attach (int id, int fusion_id)
   node = get_node (reactor, fusion_id);
   if (!node)
     {
-      node = kmalloc (sizeof(ReactorNode), GFP_KERNEL);
+      node = kmalloc (sizeof(ReactorNode), GFP_ATOMIC);
       if (!node)
         {
           unlock_reactor (reactor);
@@ -277,6 +277,8 @@ fusion_reactor_destroy (int id)
 
   free_all_nodes (reactor);
 
+  spin_unlock (&reactor->lock);
+  
   kfree (reactor);
 
   return 0;
diff --git a/drivers/char/fusion/ref.c b/drivers/char/fusion/ref.c
index 09ce182..4c7a873 100644
--- a/drivers/char/fusion/ref.c
+++ b/drivers/char/fusion/ref.c
@@ -162,7 +162,7 @@ fusion_ref_new (int *id)
 {
   FusionRef *ref;
 
-  ref = kmalloc (sizeof(FusionRef), GFP_KERNEL);
+  ref = kmalloc (sizeof(FusionRef), GFP_ATOMIC);
   if (!ref)
     return -ENOMEM;
 
@@ -381,6 +381,8 @@ fusion_ref_destroy (int id)
 
   free_all_local (ref);
 
+  spin_unlock (&ref->lock);
+  
   kfree (ref);
 
   return 0;
@@ -467,7 +469,7 @@ add_local (FusionRef *ref, int fusion_id, int add)
         }
     }
 
-  local = kmalloc (sizeof(LocalRef), GFP_KERNEL);
+  local = kmalloc (sizeof(LocalRef), GFP_ATOMIC);
   if (!local)
     return -ENOMEM;
 
diff --git a/drivers/char/fusion/skirmish.c b/drivers/char/fusion/skirmish.c
index e9712e8..ca39cf3 100644
--- a/drivers/char/fusion/skirmish.c
+++ b/drivers/char/fusion/skirmish.c
@@ -144,7 +144,7 @@ fusion_skirmish_new (int *id)
 {
   FusionSkirmish *skirmish;
 
-  skirmish = kmalloc (sizeof(FusionSkirmish), GFP_KERNEL);
+  skirmish = kmalloc (sizeof(FusionSkirmish), GFP_ATOMIC);
   if (!skirmish)
     return -ENOMEM;
 
@@ -279,6 +279,8 @@ fusion_skirmish_destroy (int id)
 
   wake_up_interruptible_all (&skirmish->wait);
 
+  spin_unlock (&skirmish->lock);
+  
   kfree (skirmish);
 
   return 0;
-- 
1.7.3.3

