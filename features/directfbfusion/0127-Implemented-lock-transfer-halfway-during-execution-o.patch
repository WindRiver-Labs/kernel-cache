From 113631d7fdaeb7c911a80c61582c85789b7973bd Mon Sep 17 00:00:00 2001
From: Denis Oliver Kropp <dok@shizo.zion.home>
Date: Tue, 9 Oct 2007 04:06:08 +0200
Subject: [PATCH] Implemented lock transfer (halfway) during execution of synchronous calls.

When process A calls process B, the locks held by A are unlocked
and reserved for B's dispatcher thread to lock it. Other threads
would block as if it's still locked.

When B returns the call, the locks are reclaimed. A FUSION_ASSUME will
fail if B did not unlock properly and the lock is hauled to A again.
---
 drivers/char/fusion/call.c     |    7 +++
 drivers/char/fusion/skirmish.c |  103 +++++++++++++++++++++++++++++++++++++++-
 drivers/char/fusion/skirmish.h |    8 +++
 3 files changed, 116 insertions(+), 2 deletions(-)

diff --git a/drivers/char/fusion/call.c b/drivers/char/fusion/call.c
index 7f78c73..739218f 100644
--- a/drivers/char/fusion/call.c
+++ b/drivers/char/fusion/call.c
@@ -26,6 +26,7 @@
 #include "fusiondev.h"
 #include "fusionee.h"
 #include "list.h"
+#include "skirmish.h"
 #include "call.h"
 
 typedef struct {
@@ -251,9 +252,15 @@ fusion_call_execute (FusionDev *dev, Fusionee *fusionee, FusionCallExecute *exec
      call->count++;
 
      if (execution) {
+          /* Transfer locks. */
+          fusion_skirmish_transfer_all( dev, call->fusion_id, fusionee_id( fusionee ), current->pid );
+
           /* TODO: implement timeout */
           fusion_sleep_on (&execution->wait, &call->lock, 0);
 
+          /* Reclaim locks. */
+          fusion_skirmish_reclaim_all( dev, current->pid );
+
           ret = lock_call (dev, execute->call_id, &call);
           if (ret) {
                /* Clear caller to allow cleanup of entry. */
diff --git a/drivers/char/fusion/skirmish.c b/drivers/char/fusion/skirmish.c
index 6f09cbb..baa77ce 100644
--- a/drivers/char/fusion/skirmish.c
+++ b/drivers/char/fusion/skirmish.c
@@ -47,6 +47,11 @@ struct __FUSION_FusionSkirmish {
 
      unsigned long  lock_time;
 
+     FusionID       transfer_to;
+     FusionID       transfer_from;
+     int            transfer_from_pid;
+     int            transfer_count;
+
 #ifdef FUSION_DEBUG_SKIRMISH_DEADLOCK
      int          pre_acquis[MAX_PRE_ACQUISITIONS];
 
@@ -245,7 +250,9 @@ fusion_skirmish_prevail (FusionDev *dev, int id, int fusion_id)
 
      up( &dev->skirmish.lock );
 
-     while (skirmish->lock_pid) {
+     while (skirmish->lock_pid || (skirmish->transfer_to != 0 &&
+                                   fusionee_dispatcher_pid( dev, skirmish->transfer_to ) != current->pid))
+     {
           ret = fusion_skirmish_wait( skirmish, NULL );
           if (ret)
                return ret;
@@ -280,7 +287,8 @@ fusion_skirmish_swoop (FusionDev *dev, int id, int fusion_id)
 
      dev->stat.skirmish_prevail_swoop++;
 
-     if (skirmish->lock_fid) {
+     if (skirmish->lock_fid || (skirmish->transfer_to != 0 &&
+                                fusionee_dispatcher_pid( dev, skirmish->transfer_to ) != current->pid)) {
           if (skirmish->lock_pid == current->pid) {
                skirmish->lock_count++;
                skirmish->lock_total++;
@@ -531,6 +539,15 @@ fusion_skirmish_dismiss_all (FusionDev *dev, int fusion_id)
                wake_up_interruptible_all (&skirmish->entry.wait);
           }
 
+          if (skirmish->transfer_from == fusion_id) {
+               skirmish->transfer_to       = 0;
+               skirmish->transfer_from     = 0;
+               skirmish->transfer_from_pid = 0;
+               skirmish->transfer_count    = 0;
+
+               wake_up_interruptible_all (&skirmish->entry.wait);
+          }
+
           up (&skirmish->entry.lock);
      }
 
@@ -559,6 +576,88 @@ fusion_skirmish_dismiss_all_from_pid (FusionDev *dev, int pid)
                wake_up_interruptible_all (&skirmish->entry.wait);
           }
 
+          if (skirmish->transfer_from_pid == pid) {
+               skirmish->transfer_to       = 0;
+               skirmish->transfer_from     = 0;
+               skirmish->transfer_from_pid = 0;
+               skirmish->transfer_count    = 0;
+
+               wake_up_interruptible_all (&skirmish->entry.wait);
+          }
+
+          up (&skirmish->entry.lock);
+     }
+
+     up (&dev->skirmish.lock);
+}
+
+void
+fusion_skirmish_transfer_all (FusionDev *dev,
+                              FusionID   to,
+                              FusionID   from,
+                              int        from_pid)
+{
+     FusionLink *l;
+
+     down (&dev->skirmish.lock);
+
+     fusion_list_foreach (l, dev->skirmish.list) {
+          FusionSkirmish *skirmish = (FusionSkirmish *) l;
+
+          down (&skirmish->entry.lock);
+
+          if (skirmish->lock_pid == from_pid) {
+               FUSION_ASSERT( skirmish->transfer_to == 0 );
+               FUSION_ASSERT( skirmish->transfer_from == 0 );
+               FUSION_ASSERT( skirmish->transfer_from_pid == 0 );
+               FUSION_ASSERT( skirmish->transfer_count == 0 );
+               FUSION_ASSERT( skirmish->lock_count > 0 );
+
+               skirmish->transfer_to       = to;
+               skirmish->transfer_from     = from;
+               skirmish->transfer_from_pid = from_pid;
+               skirmish->transfer_count    = skirmish->lock_count;
+
+               skirmish->lock_fid   = 0;
+               skirmish->lock_pid   = 0;
+               skirmish->lock_count = 0;
+          }
+
+          up (&skirmish->entry.lock);
+     }
+
+     up (&dev->skirmish.lock);
+}
+
+void
+fusion_skirmish_reclaim_all (FusionDev *dev,
+                             int        from_pid)
+{
+     FusionLink *l;
+
+     down (&dev->skirmish.lock);
+
+     fusion_list_foreach (l, dev->skirmish.list) {
+          FusionSkirmish *skirmish = (FusionSkirmish *) l;
+
+          down (&skirmish->entry.lock);
+
+          if (skirmish->transfer_from_pid == from_pid) {
+               FUSION_ASSERT( skirmish->transfer_to != 0 );
+               FUSION_ASSERT( skirmish->transfer_from != 0 );
+               FUSION_ASSERT( skirmish->transfer_count > 0 );
+               FUSION_ASSUME( skirmish->lock_pid == 0 );
+
+               skirmish->lock_fid   = skirmish->transfer_from;
+               skirmish->lock_pid   = skirmish->transfer_from_pid;
+               skirmish->lock_count = skirmish->transfer_count;
+
+               skirmish->transfer_to       = 0;
+               skirmish->transfer_from     = 0;
+               skirmish->transfer_from_pid = 0;
+               skirmish->transfer_count    = 0;
+          }
+
           up (&skirmish->entry.lock);
      }
 
diff --git a/drivers/char/fusion/skirmish.h b/drivers/char/fusion/skirmish.h
index 9f89e44..988b8db 100644
--- a/drivers/char/fusion/skirmish.h
+++ b/drivers/char/fusion/skirmish.h
@@ -68,4 +68,12 @@ void fusion_skirmish_dismiss_all (FusionDev *dev,
 void fusion_skirmish_dismiss_all_from_pid (FusionDev *dev,
                                            int        pid);
 
+void fusion_skirmish_transfer_all (FusionDev *dev,
+                                   FusionID   to,
+                                   FusionID   from,
+                                   int        from_pid);
+
+void fusion_skirmish_reclaim_all (FusionDev *dev,
+                                  int        from_pid);
+
 #endif
-- 
1.7.3.3

