From 5b57059b8ebc7e8bcdfc2ef45f17546b136d77c6 Mon Sep 17 00:00:00 2001
From: Denis Oliver Kropp <dok@directfb.org>
Date: Tue, 17 Aug 2004 17:24:36 +0000
Subject: [PATCH] Added base code for all primitives.

Property already uses the new clean code.
---
 drivers/char/fusion/Makefile-2.4 |    2 +-
 drivers/char/fusion/Makefile-2.6 |    2 +-
 drivers/char/fusion/call.c       |    2 +-
 drivers/char/fusion/entries.c    |  282 ++++++++++++++++++++++++++++++++++++
 drivers/char/fusion/entries.h    |  152 ++++++++++++++++++++
 drivers/char/fusion/fusiondev.h  |    9 +-
 drivers/char/fusion/fusionee.c   |    4 +-
 drivers/char/fusion/list.h       |   11 ++-
 drivers/char/fusion/property.c   |  292 +++++++++++---------------------------
 drivers/char/fusion/property.h   |    4 +-
 drivers/char/fusion/ref.c        |    2 +-
 drivers/char/fusion/skirmish.c   |    2 +-
 12 files changed, 542 insertions(+), 222 deletions(-)
 create mode 100644 drivers/char/fusion/entries.c
 create mode 100644 drivers/char/fusion/entries.h

diff --git a/drivers/char/fusion/Makefile-2.4 b/drivers/char/fusion/Makefile-2.4
index 4503602..8d46871 100644
--- a/drivers/char/fusion/Makefile-2.4
+++ b/drivers/char/fusion/Makefile-2.4
@@ -1,6 +1,6 @@
 O_TARGET := fusion.o
 
-obj-y   := call.o fifo.o fusiondev.o fusionee.o list.o property.o reactor.o ref.o skirmish.o
+obj-y   := call.o entries.o fifo.o fusiondev.o fusionee.o list.o property.o reactor.o ref.o skirmish.o
 obj-m   := $(O_TARGET)
 
 include $(TOPDIR)/Rules.make
diff --git a/drivers/char/fusion/Makefile-2.6 b/drivers/char/fusion/Makefile-2.6
index d7d5027..39163f0 100644
--- a/drivers/char/fusion/Makefile-2.6
+++ b/drivers/char/fusion/Makefile-2.6
@@ -1,3 +1,3 @@
 obj-m += fusion.o
 
-fusion-y := call.o fifo.o fusiondev.o fusionee.o list.o property.o reactor.o ref.o skirmish.o
+fusion-y := call.o entries.o fifo.o fusiondev.o fusionee.o list.o property.o reactor.o ref.o skirmish.o
diff --git a/drivers/char/fusion/call.c b/drivers/char/fusion/call.c
index 410a64a..99fc9d0 100644
--- a/drivers/char/fusion/call.c
+++ b/drivers/char/fusion/call.c
@@ -236,7 +236,7 @@ fusion_call_execute (FusionDev *dev, int fusion_id, FusionCallExecute *execute)
           if (signal_pending(current)) {
                execution->caller = 0;
                unlock_call (call);
-               return -ERESTARTSYS;
+               return -EINTR;
           }
 
           execute->ret_val = execution->ret_val;
diff --git a/drivers/char/fusion/entries.c b/drivers/char/fusion/entries.c
new file mode 100644
index 0000000..70b9b13
--- /dev/null
+++ b/drivers/char/fusion/entries.c
@@ -0,0 +1,282 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "entries.h"
+
+
+void
+fusion_entries_init( FusionEntries    *entries,
+                     FusionEntryClass *class,
+                     void             *ctx )
+{
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( class != NULL );
+     FUSION_ASSERT( class->object_size >= sizeof(FusionEntry) );
+
+     memset( entries, 0, sizeof(FusionEntries) );
+
+     entries->class = class;
+     entries->ctx   = ctx;
+
+     init_MUTEX( &entries->lock );
+}
+
+void
+fusion_entries_deinit( FusionEntries *entries )
+{
+     FusionLink       *tmp;
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+
+     class = entries->class;
+
+     down( &entries->lock );
+
+     fusion_list_foreach_safe (entry, tmp, entries->list) {
+          if (class->Destroy)
+               class->Destroy( entry, entries->ctx );
+
+          kfree( entry );
+     }
+
+     up( &entries->lock );
+}
+
+
+int
+fusion_entry_create( FusionEntries *entries,
+                     int           *ret_id )
+{
+     int               ret;
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+     FUSION_ASSERT( ret_id != NULL );
+
+     class = entries->class;
+
+     entry = kmalloc( class->object_size, GFP_KERNEL );
+     if (!entry)
+          return -ENOMEM;
+
+     memset( entry, 0, class->object_size );
+
+     if (down_interruptible( &entries->lock )) {
+          kfree( entry );
+          return -EINTR;
+     }
+
+     entry->entries = entries;
+     entry->id      = entries->ids++;
+     entry->pid     = current->pid;
+
+     init_MUTEX( &entry->lock );
+
+     init_waitqueue_head( &entry->wait );
+
+     if (class->Init) {
+          ret = class->Init( entry, entries->ctx );
+          if (ret) {
+               kfree( entry );
+               return ret;
+          }
+     }
+
+     fusion_list_prepend( &entries->list, &entry->link );
+
+     up( &entries->lock );
+
+     *ret_id = entry->id;
+
+     return 0;
+}
+
+int
+fusion_entry_destroy( FusionEntries  *entries,
+                      int             id )
+{
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+
+     class = entries->class;
+
+     /* Lock entries. */
+     if (down_interruptible( &entries->lock ))
+          return -EINTR;
+
+     /* Lookup the entry. */
+     fusion_list_foreach (entry, entries->list) {
+          if (entry->id == id)
+               break;
+     }
+
+     /* Check if no entry was found. */
+     if (!entry) {
+          up( &entries->lock );
+          return -EINVAL;
+     }
+
+     /* Lock the entry. */
+     if (down_interruptible( &entry->lock )) {
+          up( &entries->lock );
+          return -EINTR;
+     }
+
+     /* Remove the entry from the list. */
+     fusion_list_remove( &entries->list, &entry->link );
+
+     /* Wake up any waiting process. */
+     wake_up_interruptible_all( &entry->wait );
+
+     /* Unlock entries. */
+     up( &entries->lock );
+
+
+     /* Call the destroy function. */
+     if (class->Destroy)
+          class->Destroy( entry, entries->ctx );
+
+     /* Deallocate the entry. */
+     kfree( entry );
+
+     return 0;
+}
+
+int
+fusion_entry_lock( FusionEntries  *entries,
+                   int             id,
+                   FusionEntry   **ret_entry )
+{
+     FusionEntry *entry;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( ret_entry != NULL );
+
+     /* Lock entries. */
+     if (down_interruptible( &entries->lock ))
+          return -EINTR;
+
+     /* Lookup the entry. */
+     fusion_list_foreach (entry, entries->list) {
+          if (entry->id == id)
+               break;
+     }
+
+     /* Check if no entry was found. */
+     if (!entry) {
+          up( &entries->lock );
+          return -EINVAL;
+     }
+
+     FUSION_ASSERT( entry->lock_pid != current->pid );
+
+     /* Move the entry to the front of all entries. */
+     fusion_list_move_to_front( &entries->list, &entry->link );
+
+     /* Lock the entry. */
+     if (down_interruptible( &entry->lock )) {
+          up( &entries->lock );
+          return -EINTR;
+     }
+
+     /* Mark as locked. */
+     entry->lock_pid = current->pid;
+
+     /* Unlock entries. */
+     up( &entries->lock );
+
+     /* Return the locked entry. */
+     *ret_entry = entry;
+
+     return 0;
+}
+
+void
+fusion_entry_unlock( FusionEntry *entry )
+{
+     FUSION_ASSERT( entry != NULL );
+     FUSION_ASSERT( entry->lock_pid == current->pid );
+
+     entry->lock_pid = 0;
+
+     /* Unlock the entry. */
+     up( &entry->lock );
+}
+
+int
+fusion_entry_wait( FusionEntry *entry, long *timeout )
+{
+     int            ret;
+     int            id;
+     FusionEntries *entries;
+     FusionEntry   *entry2;
+
+     FUSION_ASSERT( entry != NULL );
+     FUSION_ASSERT( entry->entries != NULL );
+     FUSION_ASSERT( entry->lock_pid == current->pid );
+
+     id      = entry->id;
+     entries = entry->entries;
+
+     fusion_sleep_on( &entry->wait, &entry->lock, timeout );
+
+     if (timeout && !*timeout)
+          return -ETIMEDOUT;
+
+     if (signal_pending(current))
+          return -EINTR;
+
+     ret = fusion_entry_lock( entries, id, &entry2 );
+     switch (ret) {
+          case -EINVAL:
+               return -EIDRM;
+
+          case 0:
+               if (entry != entry2)
+                    BUG();
+     }
+
+     return ret;
+}
+
+void
+fusion_entry_notify( FusionEntry *entry, bool all )
+{
+     FUSION_ASSERT( entry != NULL );
+     FUSION_ASSERT( entry->lock_pid == current->pid );
+
+     if (all)
+          wake_up_interruptible_all( &entry->wait );
+     else
+          wake_up_interruptible( &entry->wait );
+}
+
diff --git a/drivers/char/fusion/entries.h b/drivers/char/fusion/entries.h
new file mode 100644
index 0000000..9ab008d
--- /dev/null
+++ b/drivers/char/fusion/entries.h
@@ -0,0 +1,152 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__ENTRIES_H__
+#define __FUSION__ENTRIES_H__
+
+#include "types.h"
+#include "list.h"
+
+
+typedef struct __FD_FusionEntry FusionEntry;
+
+
+typedef const struct {
+     int object_size;
+
+     int  (*Init)   ( FusionEntry *entry, void *ctx );
+     void (*Destroy)( FusionEntry *entry, void *ctx );
+} FusionEntryClass;
+
+
+typedef struct {
+     FusionEntryClass  *class;
+     void              *ctx;
+
+     FusionLink        *list;
+     int                ids;
+     struct semaphore   lock;
+} FusionEntries;
+
+
+struct __FD_FusionEntry {
+     FusionLink         link;
+
+     FusionEntries     *entries;
+
+     int                id;
+     pid_t              pid;
+
+     pid_t              lock_pid;
+
+     struct semaphore   lock;
+     wait_queue_head_t  wait;
+};
+
+
+/* Entries Init & DeInit */
+
+void fusion_entries_init  ( FusionEntries    *entries,
+                            FusionEntryClass *class,
+                            void             *ctx );
+
+void fusion_entries_deinit( FusionEntries    *entries );
+
+
+/* Create & Destroy */
+
+int  fusion_entry_create  ( FusionEntries    *entries,
+                            int              *ret_id );
+
+int  fusion_entry_destroy ( FusionEntries    *entries,
+                            int               id );
+
+
+/* Lock & Unlock */
+
+int  fusion_entry_lock    ( FusionEntries    *entries,
+                            int               id,
+                            FusionEntry     **ret_entry );
+
+void fusion_entry_unlock  ( FusionEntry      *entry );
+
+
+/** Wait & Notify **/
+
+/*
+ * Wait for the entry to be notified with an optional timeout.
+ *
+ * The entry
+ *   (1) has to be locked prior to calling this function.
+ *   (2) is temporarily unlocked while being waited for.
+ *
+ * If this function returns an error, the entry is not locked again!
+ *
+ * Possible errors are:
+ *   -EIDRM      Entry has been removed while being waited for.
+ *   -ETIMEDOUT  Timeout occured.
+ *   -EINTR      A signal has been received.
+ */
+int  fusion_entry_wait    ( FusionEntry      *entry,
+                            long             *timeout );
+
+/*
+ * Wake up one or all processes waiting for the entry to be notified.
+ *
+ * The entry has to be locked prior to calling this function.
+ */
+void fusion_entry_notify  ( FusionEntry      *entry,
+                            bool              all );
+
+
+#define FUSION_ENTRY_CLASS( Type, name, init_func, destroy_func )          \
+                                                                           \
+     static FusionEntryClass name##_class = {                              \
+          .object_size = sizeof(Type),                                     \
+          .Init        = init_func,                                        \
+          .Destroy     = destroy_func                                      \
+     };                                                                    \
+                                                                           \
+     static inline int fusion_##name##_lock( FusionEntries  *entries,      \
+                                             int             id,           \
+                                             Type          **ret_##name )  \
+     {                                                                     \
+          int          ret;                                                \
+          FusionEntry *entry;                                              \
+                                                                           \
+          ret = fusion_entry_lock( entries, id, &entry );                  \
+                                                                           \
+          if (!ret)                                                        \
+               *ret_##name = (Type *) entry;                               \
+                                                                           \
+          return ret;                                                      \
+     }                                                                     \
+                                                                           \
+     static inline void fusion_##name##_unlock( Type *name )               \
+     {                                                                     \
+          fusion_entry_unlock( (FusionEntry*) name );                      \
+     }                                                                     \
+                                                                           \
+     static inline int fusion_##name##_wait( Type *name, long *timeout )   \
+     {                                                                     \
+          return fusion_entry_wait( (FusionEntry*) name, timeout );        \
+     }                                                                     \
+                                                                           \
+     static inline void fusion_##name##_notify( Type *name, bool all )     \
+     {                                                                     \
+          fusion_entry_notify( (FusionEntry*) name, all );                 \
+     }
+
+
+#endif
diff --git a/drivers/char/fusion/fusiondev.h b/drivers/char/fusion/fusiondev.h
index 023f8f6..b15afec 100644
--- a/drivers/char/fusion/fusiondev.h
+++ b/drivers/char/fusion/fusiondev.h
@@ -17,8 +17,11 @@
 
 #include <linux/proc_fs.h>
 
+#include "entries.h"
 #include "list.h"
 
+#define FUSION_ASSERT(exp)    if (!(exp)) BUG()
+
 typedef struct {
      int refs;
 
@@ -51,11 +54,7 @@ typedef struct {
           wait_queue_head_t  wait;
      } fusionee;
 
-     struct {
-          int                ids;
-          FusionLink        *list;
-          struct semaphore   lock;
-     } property;
+     FusionEntries  properties;
 
      struct {
           int                ids;
diff --git a/drivers/char/fusion/fusionee.c b/drivers/char/fusion/fusionee.c
index d05f558..3b24001 100644
--- a/drivers/char/fusion/fusionee.c
+++ b/drivers/char/fusion/fusionee.c
@@ -274,7 +274,7 @@ fusionee_get_messages (FusionDev *dev,
           fusion_sleep_on (&fusionee->wait, &fusionee->lock, 0);
 
           if (signal_pending(current))
-               return -ERESTARTSYS;
+               return -EINTR;
 
           ret = lock_fusionee (dev, id, &fusionee);
           if (ret)
@@ -403,7 +403,7 @@ fusionee_kill (FusionDev *dev, int id, int target, int signal, int timeout_ms)
                fusion_sleep_on (&dev->fusionee.wait, &dev->fusionee.lock, NULL);
 
           if (signal_pending(current))
-               return -ERESTARTSYS;
+               return -EINTR;
      }
 
      up (&dev->fusionee.lock);
diff --git a/drivers/char/fusion/list.h b/drivers/char/fusion/list.h
index e0aea76..793e037 100644
--- a/drivers/char/fusion/list.h
+++ b/drivers/char/fusion/list.h
@@ -24,7 +24,16 @@ void fusion_list_prepend       (FusionLink **list, FusionLink *link);
 void fusion_list_remove        (FusionLink **list, FusionLink *link);
 void fusion_list_move_to_front (FusionLink **list, FusionLink *link);
 
-#define fusion_list_foreach(link, list)  for (link = list; link; link = link->next)
+
+#define fusion_list_foreach(elem, list)                     \
+     for (elem = (void*)(list);                             \
+          elem;                                             \
+          elem = (void*)(((FusionLink*)(elem))->next))
+
+#define fusion_list_foreach_safe(elem, temp, list)                                             \
+     for (elem = (void*)(list), temp = ((elem) ? (void*)(((FusionLink*)(elem))->next) : NULL); \
+          elem;                                                                                \
+          elem = (void*)(temp), temp = ((elem) ? (void*)(((FusionLink*)(elem))->next) : NULL))
 
 #endif /* __FUSION__LIST_H__ */
 
diff --git a/drivers/char/fusion/property.c b/drivers/char/fusion/property.c
index 7e35b28..d21781d 100644
--- a/drivers/char/fusion/property.c
+++ b/drivers/char/fusion/property.c
@@ -25,6 +25,7 @@
 
 #include <linux/fusion.h>
 
+#include "entries.h"
 #include "fusiondev.h"
 #include "fusionee.h"
 #include "list.h"
@@ -37,54 +38,43 @@ typedef enum {
 } FusionPropertyState;
 
 typedef struct {
-     FusionLink          link;
-
-     struct semaphore    lock;
-
-     int                 id;
-     int                 pid;
+     FusionEntry         entry;
 
      FusionPropertyState state;
      int                 fusion_id; /* non-zero if leased/purchased */
      unsigned long       purchase_stamp;
      int                 lock_pid;
      int                 count;    /* lock counter */
-
-     wait_queue_head_t   wait;
 } FusionProperty;
 
-/******************************************************************************/
-
-static int  lookup_property (FusionDev *dev, int id, FusionProperty **ret_property);
-static int  lock_property   (FusionDev *dev, int id, FusionProperty **ret_property);
-static void unlock_property (FusionProperty *property);
+FUSION_ENTRY_CLASS( FusionProperty, property, NULL, NULL )
 
 /******************************************************************************/
 
 static int
-properties_read_proc(char *buf, char **start, off_t offset,
-                     int len, int *eof, void *private)
+properties_read_proc( char *buf, char **start, off_t offset,
+                      int len, int *eof, void *private )
 {
      FusionLink *l;
      FusionDev  *dev     = private;
      int         written = 0;
 
-     if (down_interruptible (&dev->property.lock))
+     if (down_interruptible( &dev->properties.lock ))
           return -EINTR;
 
-     fusion_list_foreach (l, dev->property.list) {
+     fusion_list_foreach (l, dev->properties.list) {
           FusionProperty *property = (FusionProperty*) l;
 
           if (property->state != FUSION_PROPERTY_AVAILABLE) {
                written += sprintf(buf+written, "(%5d) 0x%08x %s (0x%08x %d)\n",
-                                  property->pid, property->id,
+                                  property->entry.pid, property->entry.id,
                                   property->state == FUSION_PROPERTY_LEASED ?
                                   "leased" : "purchased", property->fusion_id,
                                   property->lock_pid);
           }
           else {
                written += sprintf(buf+written, "(%5d) 0x%08x\n",
-                                  property->pid, property->id);
+                                  property->entry.pid, property->entry.id);
           }
 
           if (written < offset) {
@@ -96,7 +86,7 @@ properties_read_proc(char *buf, char **start, off_t offset,
                break;
      }
 
-     up (&dev->property.lock);
+     up( &dev->properties.lock );
 
      *start = buf + offset;
      written -= offset;
@@ -110,87 +100,45 @@ properties_read_proc(char *buf, char **start, off_t offset,
 }
 
 int
-fusion_property_init (FusionDev *dev)
+fusion_property_init( FusionDev *dev )
 {
-     init_MUTEX (&dev->property.lock);
+     fusion_entries_init( &dev->properties, &property_class, dev );
 
-     create_proc_read_entry("properties", 0, dev->proc_dir,
-                            properties_read_proc, dev);
+     create_proc_read_entry( "properties", 0, dev->proc_dir, properties_read_proc, dev );
 
      return 0;
 }
 
 void
-fusion_property_deinit (FusionDev *dev)
+fusion_property_deinit( FusionDev *dev )
 {
-     FusionLink *l;
-
-     down (&dev->property.lock);
+     remove_proc_entry( "properties", dev->proc_dir );
 
-     remove_proc_entry ("properties", dev->proc_dir);
-
-     l = dev->property.list;
-     while (l) {
-          FusionLink     *next     = l->next;
-          FusionProperty *property = (FusionProperty *) l;
-
-          kfree (property);
-
-          l = next;
-     }
-
-     up (&dev->property.lock);
+     fusion_entries_deinit( &dev->properties );
 }
 
 /******************************************************************************/
 
 int
-fusion_property_new (FusionDev *dev, int *id)
+fusion_property_new( FusionDev *dev, int *ret_id )
 {
-     FusionProperty *property;
-
-     property = kmalloc (sizeof(FusionProperty), GFP_KERNEL);
-     if (!property)
-          return -ENOMEM;
-
-     memset (property, 0, sizeof(FusionProperty));
-
-     if (down_interruptible (&dev->property.lock)) {
-          kfree (property);
-          return -EINTR;
-     }
-
-     property->id   = dev->property.ids++;
-     property->pid  = current->pid;
-
-     init_MUTEX (&property->lock);
-
-     init_waitqueue_head (&property->wait);
-
-     fusion_list_prepend (&dev->property.list, &property->link);
-
-     up (&dev->property.lock);
-
-     *id = property->id;
-
-     return 0;
+     return fusion_entry_create( &dev->properties, ret_id );
 }
 
 int
-fusion_property_lease (FusionDev *dev, int id, int fusion_id)
+fusion_property_lease( FusionDev *dev, int id, int fusion_id )
 {
+     int             ret;
      FusionProperty *property;
-     signed long     timeout = -1;
+     long            timeout = -1;
 
      dev->stat.property_lease_purchase++;
 
-     while (true) {
-          int ret;
-
-          ret = lock_property (dev, id, &property);
-          if (ret)
-               return ret;
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
 
+     while (true) {
           switch (property->state) {
                case FUSION_PROPERTY_AVAILABLE:
                     property->state     = FUSION_PROPERTY_LEASED;
@@ -198,21 +146,20 @@ fusion_property_lease (FusionDev *dev, int id, int fusion_id)
                     property->lock_pid  = current->pid;
                     property->count     = 1;
 
-                    unlock_property (property);
+                    fusion_property_unlock( property );
                     return 0;
 
                case FUSION_PROPERTY_LEASED:
                     if (property->lock_pid == current->pid) {
                          property->count++;
 
-                         unlock_property (property);
+                         fusion_property_unlock( property );
                          return 0;
                     }
 
-                    fusion_sleep_on (&property->wait, &property->lock, NULL);
-
-                    if (signal_pending(current))
-                         return -ERESTARTSYS;
+                    ret = fusion_property_wait( property, NULL );
+                    if (ret)
+                         return ret;
 
                     break;
 
@@ -221,7 +168,7 @@ fusion_property_lease (FusionDev *dev, int id, int fusion_id)
                          case -1:
                               if (jiffies - property->purchase_stamp > HZ / 10) {
                          case 0:
-                                   unlock_property (property);
+                                   fusion_property_unlock( property );
                                    return -EAGAIN;
                               }
                               else
@@ -230,37 +177,40 @@ fusion_property_lease (FusionDev *dev, int id, int fusion_id)
                               /* fall through */
 
                          default:
-                              fusion_sleep_on (&property->wait, &property->lock, &timeout);
-
-                              if (signal_pending(current))
-                                   return -ERESTARTSYS;
+                              ret = fusion_property_wait( property, &timeout );
+                              if (ret)
+                                   return ret;
 
                               break;
                     }
 
                     break;
+
+               default:
+                    BUG();
           }
      }
 
+     BUG();
+
      /* won't reach this */
      return -1;
 }
 
 int
-fusion_property_purchase (FusionDev *dev, int id, int fusion_id)
+fusion_property_purchase( FusionDev *dev, int id, int fusion_id )
 {
+     int             ret;
      FusionProperty *property;
      signed long     timeout = -1;
 
      dev->stat.property_lease_purchase++;
 
-     while (true) {
-          int ret;
-
-          ret = lock_property (dev, id, &property);
-          if (ret)
-               return ret;
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
 
+     while (true) {
           switch (property->state) {
                case FUSION_PROPERTY_AVAILABLE:
                     property->state          = FUSION_PROPERTY_PURCHASED;
@@ -269,16 +219,15 @@ fusion_property_purchase (FusionDev *dev, int id, int fusion_id)
                     property->lock_pid       = current->pid;
                     property->count          = 1;
 
-                    wake_up_interruptible_all (&property->wait);
+                    fusion_property_notify( property, true );
 
-                    unlock_property (property);
+                    fusion_property_unlock( property );
                     return 0;
 
                case FUSION_PROPERTY_LEASED:
-                    fusion_sleep_on (&property->wait, &property->lock, NULL);
-
-                    if (signal_pending(current))
-                         return -ERESTARTSYS;
+                    ret = fusion_property_wait( property, NULL );
+                    if (ret)
+                         return ret;
 
                     break;
 
@@ -287,7 +236,7 @@ fusion_property_purchase (FusionDev *dev, int id, int fusion_id)
                          case -1:
                               if (jiffies - property->purchase_stamp > HZ) {
                          case 0:
-                                   unlock_property (property);
+                                   fusion_property_unlock( property );
                                    return -EAGAIN;
                               }
                               else
@@ -296,42 +245,46 @@ fusion_property_purchase (FusionDev *dev, int id, int fusion_id)
                               /* fall through */
 
                          default:
-                              fusion_sleep_on (&property->wait, &property->lock, &timeout);
-
-                              if (signal_pending(current))
-                                   return -ERESTARTSYS;
+                              ret = fusion_property_wait( property, &timeout );
+                              if (ret)
+                                   return ret;
 
                               break;
                     }
 
                     break;
+
+               default:
+                    BUG();
           }
      }
 
+     BUG();
+
      /* won't reach this */
      return -1;
 }
 
 int
-fusion_property_cede (FusionDev *dev, int id, int fusion_id)
+fusion_property_cede( FusionDev *dev, int id, int fusion_id )
 {
      int             ret;
-     bool            purchased;
      FusionProperty *property;
+     bool            purchased;
 
-     ret = lock_property (dev, id, &property);
+     dev->stat.property_cede++;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
      if (ret)
           return ret;
 
-     dev->stat.property_cede++;
-
      if (property->lock_pid != current->pid) {
-          unlock_property (property);
+          fusion_property_unlock( property );
           return -EIO;
      }
 
      if (--property->count) {
-          unlock_property (property);
+          fusion_property_unlock( property );
           return 0;
      }
 
@@ -341,9 +294,9 @@ fusion_property_cede (FusionDev *dev, int id, int fusion_id)
      property->fusion_id = 0;
      property->lock_pid  = 0;
 
-     wake_up_interruptible_all (&property->wait);
+     fusion_property_notify( property, true );
 
-     unlock_property (property);
+     fusion_property_unlock( property );
 
      if (purchased)
           yield();
@@ -352,136 +305,61 @@ fusion_property_cede (FusionDev *dev, int id, int fusion_id)
 }
 
 int
-fusion_property_holdup (FusionDev *dev, int id, int fusion_id)
+fusion_property_holdup( FusionDev *dev, int id, int fusion_id )
 {
      int             ret;
      FusionProperty *property;
 
-     ret = lock_property (dev, id, &property);
+     if (fusion_id > 1)
+          return -EPERM;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
      if (ret)
           return ret;
 
      if (property->state == FUSION_PROPERTY_PURCHASED) {
           if (property->fusion_id == fusion_id) {
-               unlock_property (property);
+               fusion_property_unlock( property );
                return -EIO;
           }
 
-          fusionee_kill (dev, fusion_id, property->fusion_id, SIGKILL, -1);
+          fusionee_kill( dev, fusion_id, property->fusion_id, SIGKILL, -1 );
      }
 
-     unlock_property (property);
+     fusion_property_unlock( property );
 
      return 0;
 }
 
 int
-fusion_property_destroy (FusionDev *dev, int id)
+fusion_property_destroy( FusionDev *dev, int id )
 {
-     int             ret;
-     FusionProperty *property;
-
-     ret = lookup_property (dev, id, &property);
-     if (ret)
-          return ret;
-
-     if (down_interruptible (&property->lock)) {
-          up (&dev->property.lock);
-          return -EINTR;
-     }
-
-     fusion_list_remove (&dev->property.list, &property->link);
-
-     wake_up_interruptible_all (&property->wait);
-
-     up (&dev->property.lock);
-
-     up (&property->lock);
-
-     kfree (property);
-
-     return 0;
+     return fusion_entry_destroy( &dev->properties, id );
 }
 
 void
-fusion_property_cede_all (FusionDev *dev, int fusion_id)
+fusion_property_cede_all( FusionDev *dev, int fusion_id )
 {
      FusionLink *l;
 
-     down (&dev->property.lock);
+     down( &dev->properties.lock );
 
-     fusion_list_foreach (l, dev->property.list) {
+     fusion_list_foreach (l, dev->properties.list) {
           FusionProperty *property = (FusionProperty *) l;
 
-          down (&property->lock);
+          down( &property->entry.lock );
 
           if (property->fusion_id == fusion_id) {
                property->state     = FUSION_PROPERTY_AVAILABLE;
                property->fusion_id = 0;
                property->lock_pid  = 0;
 
-               wake_up_interruptible_all (&property->wait);
+               wake_up_interruptible_all (&property->entry.wait);
           }
 
-          up (&property->lock);
+          up( &property->entry.lock );
      }
 
-     up (&dev->property.lock);
-}
-
-/******************************************************************************/
-
-static int
-lookup_property (FusionDev *dev, int id, FusionProperty **ret_property)
-{
-     FusionLink *l;
-
-     if (down_interruptible (&dev->property.lock))
-          return -EINTR;
-
-     fusion_list_foreach (l, dev->property.list) {
-          FusionProperty *property = (FusionProperty *) l;
-
-          if (property->id == id) {
-               *ret_property = property;
-               return 0;
-          }
-     }
-
-     up (&dev->property.lock);
-
-     return -EINVAL;
-}
-
-static int
-lock_property (FusionDev *dev, int id, FusionProperty **ret_property)
-{
-     int             ret;
-     FusionProperty *property;
-
-     ret = lookup_property (dev, id, &property);
-     if (ret)
-          return ret;
-
-     if (property) {
-          fusion_list_move_to_front (&dev->property.list, &property->link);
-
-          if (down_interruptible (&property->lock)) {
-               up (&dev->property.lock);
-               return -EINTR;
-          }
-
-          up (&dev->property.lock);
-     }
-
-     *ret_property = property;
-
-     return 0;
-}
-
-static void
-unlock_property (FusionProperty *property)
-{
-     up (&property->lock);
+     up( &dev->properties.lock );
 }
 
diff --git a/drivers/char/fusion/property.h b/drivers/char/fusion/property.h
index da5c959..92790f5 100644
--- a/drivers/char/fusion/property.h
+++ b/drivers/char/fusion/property.h
@@ -11,7 +11,7 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  */
- 
+
 #ifndef __FUSION__PROPERTY_H__
 #define __FUSION__PROPERTY_H__
 
@@ -28,7 +28,7 @@ void fusion_property_deinit (FusionDev *dev);
 /* public API */
 
 int fusion_property_new      (FusionDev *dev,
-                              int       *id);
+                              int       *ret_id);
 
 int fusion_property_lease    (FusionDev *dev,
                               int        id,
diff --git a/drivers/char/fusion/ref.c b/drivers/char/fusion/ref.c
index 72f2102..85e0163 100644
--- a/drivers/char/fusion/ref.c
+++ b/drivers/char/fusion/ref.c
@@ -287,7 +287,7 @@ fusion_ref_zero_lock (FusionDev *dev, int id, int fusion_id)
                fusion_sleep_on (&ref->wait, &ref->lock, 0);
 
                if (signal_pending(current))
-                    return -ERESTARTSYS;
+                    return -EINTR;
           }
           else
                break;
diff --git a/drivers/char/fusion/skirmish.c b/drivers/char/fusion/skirmish.c
index ea21e89..b585baf 100644
--- a/drivers/char/fusion/skirmish.c
+++ b/drivers/char/fusion/skirmish.c
@@ -184,7 +184,7 @@ fusion_skirmish_prevail (FusionDev *dev, int id, int fusion_id)
                fusion_sleep_on (&skirmish->wait, &skirmish->lock, 0);
 
                if (signal_pending(current))
-                    return -ERESTARTSYS;
+                    return -EINTR;
           }
           else
                break;
-- 
1.7.3.3

