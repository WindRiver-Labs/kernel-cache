From 4ddb9c2ab58cb3a179c27152ff4fc2a98789b2b3 Mon Sep 17 00:00:00 2001
From: Denis Oliver Kropp <dok@directfb.org>
Date: Sun, 3 Sep 2006 11:50:55 +0000
Subject: [PATCH] Only mark reactors as being destroyed, but actually destroy/remove them when the last node detached. No more attach or dispatch is allowed though.

---
 drivers/char/fusion/entries.c |   26 +++++++--
 drivers/char/fusion/entries.h |   12 ++--
 drivers/char/fusion/reactor.c |  127 ++++++++++++++++++++++++++---------------
 3 files changed, 107 insertions(+), 58 deletions(-)

diff --git a/drivers/char/fusion/entries.c b/drivers/char/fusion/entries.c
index 42773a4..2834bc7 100644
--- a/drivers/char/fusion/entries.c
+++ b/drivers/char/fusion/entries.c
@@ -230,24 +230,38 @@ fusion_entry_destroy( FusionEntries  *entries,
           return -EINTR;
      }
 
+     /* Destroy it now. */
+     fusion_entry_destroy_locked( entries, entry );
+
+     /* Unlock entries. */
+     up( &entries->lock );
+
+     return 0;
+}
+
+void
+fusion_entry_destroy_locked( FusionEntries  *entries,
+                             FusionEntry    *entry )
+{
+     FusionEntryClass *class;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+
+     class = entries->class;
+
      /* Remove the entry from the list. */
      fusion_list_remove( &entries->list, &entry->link );
 
      /* Wake up any waiting process. */
      wake_up_interruptible_all( &entry->wait );
 
-     /* Unlock entries. */
-     up( &entries->lock );
-
-
      /* Call the destroy function. */
      if (class->Destroy)
           class->Destroy( entry, entries->ctx );
 
      /* Deallocate the entry. */
      kfree( entry );
-
-     return 0;
 }
 
 int
diff --git a/drivers/char/fusion/entries.h b/drivers/char/fusion/entries.h
index 79a6157..37296c5 100644
--- a/drivers/char/fusion/entries.h
+++ b/drivers/char/fusion/entries.h
@@ -78,13 +78,15 @@ int  fusion_entries_read_proc( char *buf, char **start, off_t offset,
 
 /* Create & Destroy */
 
-int  fusion_entry_create  ( FusionEntries    *entries,
-                            int              *ret_id,
-                            void             *create_ctx );
+int  fusion_entry_create        ( FusionEntries  *entries,
+                                  int            *ret_id,
+                                  void           *create_ctx );
 
-int  fusion_entry_destroy ( FusionEntries    *entries,
-                            int               id );
+int  fusion_entry_destroy       ( FusionEntries  *entries,
+                                  int             id );
 
+void fusion_entry_destroy_locked( FusionEntries  *entries,
+                                  FusionEntry    *entry );
 
 /* Information */
 
diff --git a/drivers/char/fusion/reactor.c b/drivers/char/fusion/reactor.c
index cce504e..7ea4d8c 100644
--- a/drivers/char/fusion/reactor.c
+++ b/drivers/char/fusion/reactor.c
@@ -40,21 +40,33 @@ typedef struct {
      FusionLink        *nodes;
 
      int                dispatch_count;
+
+     bool               destroyed;
 } FusionReactor;
 
 /******************************************************************************/
 
-static ReactorNode *get_node      ( FusionReactor *reactor,
-                                    FusionID       fusion_id );
+static int  fork_node     ( FusionReactor *reactor,
+                            FusionID       fusion_id,
+                            FusionID       from_id );
 
-static void         remove_node   ( FusionReactor *reactor,
-                                    FusionID       fusion_id );
+static void free_all_nodes( FusionReactor *reactor );
 
-static int          fork_node     ( FusionReactor *reactor,
-                                    FusionID       fusion_id,
-                                    FusionID       from_id );
+/******************************************************************************/
 
-static void         free_all_nodes( FusionReactor *reactor );
+static inline ReactorNode *
+get_node (FusionReactor *reactor,
+          FusionID       fusion_id)
+{
+     ReactorNode *node;
+
+     fusion_list_foreach (node, reactor->nodes) {
+          if (node->fusion_id == fusion_id)
+               return node;
+     }
+
+     return NULL;
+}
 
 /******************************************************************************/
 
@@ -80,7 +92,8 @@ fusion_reactor_print( FusionEntry *entry,
           num++;
      }
 
-     return sprintf( buf, "%5dx dispatch, %d nodes\n", reactor->dispatch_count, num );
+     return sprintf( buf, "%5dx dispatch, %d nodes%s\n", reactor->dispatch_count, num,
+                     reactor->destroyed ? "  DESTROYED" : "" );
 }
 
 
@@ -127,6 +140,11 @@ fusion_reactor_attach (FusionDev *dev, int id, FusionID fusion_id)
      if (ret)
           return ret;
 
+     if (reactor->destroyed) {
+          fusion_reactor_unlock( reactor );
+          return -EIDRM;
+     }
+
      dev->stat.reactor_attach++;
 
      node = get_node (reactor, fusion_id);
@@ -157,7 +175,7 @@ fusion_reactor_detach (FusionDev *dev, int id, FusionID fusion_id)
      ReactorNode   *node;
      FusionReactor *reactor;
 
-     ret = fusion_reactor_lock( &dev->reactor, id, false, &reactor );
+     ret = fusion_reactor_lock( &dev->reactor, id, true, &reactor );
      if (ret)
           return ret;
 
@@ -166,6 +184,7 @@ fusion_reactor_detach (FusionDev *dev, int id, FusionID fusion_id)
      node = get_node (reactor, fusion_id);
      if (!node) {
           fusion_reactor_unlock( reactor );
+          up( &dev->reactor.lock );
           return -EIO;
      }
 
@@ -174,7 +193,12 @@ fusion_reactor_detach (FusionDev *dev, int id, FusionID fusion_id)
           kfree (node);
      }
 
-     fusion_reactor_unlock( reactor );
+     if (reactor->destroyed && !reactor->nodes)
+          fusion_entry_destroy_locked( &dev->reactor, &reactor->entry );
+     else
+          fusion_reactor_unlock( reactor );
+
+     up( &dev->reactor.lock );
 
      return 0;
 }
@@ -191,6 +215,11 @@ fusion_reactor_dispatch (FusionDev *dev, int id, FusionID fusion_id,
      if (ret)
           return ret;
 
+     if (reactor->destroyed) {
+          fusion_reactor_unlock( reactor );
+          return -EIDRM;
+     }
+
      reactor->dispatch_count++;
 
      fusion_list_foreach (l, reactor->nodes) {
@@ -211,20 +240,56 @@ fusion_reactor_dispatch (FusionDev *dev, int id, FusionID fusion_id,
 int
 fusion_reactor_destroy (FusionDev *dev, int id)
 {
-     return fusion_entry_destroy( &dev->reactor, id );
+     int            ret;
+     FusionReactor *reactor;
+
+     ret = fusion_reactor_lock( &dev->reactor, id, true, &reactor );
+     if (ret)
+          return ret;
+
+     if (reactor->destroyed) {
+          fusion_reactor_unlock( reactor );
+          up( &dev->reactor.lock );
+          return -EIDRM;
+     }
+
+     reactor->destroyed = true;
+
+     if (!reactor->nodes)
+          fusion_entry_destroy_locked( &dev->reactor, &reactor->entry );
+     else
+          fusion_reactor_unlock( reactor );
+
+     up( &dev->reactor.lock );
+
+     return 0;
 }
 
 void
 fusion_reactor_detach_all (FusionDev *dev, FusionID fusion_id)
 {
-     FusionLink *l;
+     FusionLink *l, *n;
 
      down (&dev->reactor.lock);
 
-     fusion_list_foreach (l, dev->reactor.list) {
+     fusion_list_foreach_safe (l, n, dev->reactor.list) {
+          ReactorNode   *node;
           FusionReactor *reactor = (FusionReactor *) l;
 
-          remove_node (reactor, fusion_id);
+          down (&reactor->entry.lock);
+
+          fusion_list_foreach (node, reactor->nodes) {
+               if (node->fusion_id == fusion_id) {
+                    fusion_list_remove (&reactor->nodes, &node->link);
+                    kfree (node);
+                    break;
+               }
+          }
+
+          if (reactor->destroyed && !reactor->nodes)
+               fusion_entry_destroy_locked( &dev->reactor, &reactor->entry );
+          else
+               up (&reactor->entry.lock);
      }
 
      up (&dev->reactor.lock);
@@ -253,38 +318,6 @@ fusion_reactor_fork_all (FusionDev *dev, FusionID fusion_id, FusionID from_id)
 
 /******************************************************************************/
 
-static ReactorNode *
-get_node (FusionReactor *reactor,
-          FusionID       fusion_id)
-{
-     ReactorNode *node;
-
-     fusion_list_foreach (node, reactor->nodes) {
-          if (node->fusion_id == fusion_id)
-               return node;
-     }
-
-     return NULL;
-}
-
-static void
-remove_node (FusionReactor *reactor, FusionID fusion_id)
-{
-     ReactorNode *node;
-
-     down (&reactor->entry.lock);
-
-     fusion_list_foreach (node, reactor->nodes) {
-          if (node->fusion_id == fusion_id) {
-               fusion_list_remove (&reactor->nodes, &node->link);
-               kfree (node);
-               break;
-          }
-     }
-
-     up (&reactor->entry.lock);
-}
-
 static int
 fork_node (FusionReactor *reactor, FusionID fusion_id, FusionID from_id)
 {
-- 
1.7.3.3

