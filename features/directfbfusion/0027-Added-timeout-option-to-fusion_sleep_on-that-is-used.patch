From 440aecf485c223739305c4b98a16eea34496cbeb Mon Sep 17 00:00:00 2001
From: Denis Oliver Kropp <dok@directfb.org>
Date: Thu, 8 May 2003 17:58:47 +0000
Subject: [PATCH] Added timeout option to fusion_sleep_on() that is used by properties. Leasing/purchasing doesn't fail immediately now if a property is purchased. Instead it fails after a timeout of 20 ms.

This improves DirectFB DRI interoperation significantly as DirectFB doesn't
give up early to access the hardware if an OpenGL application does the rendering
which is most of the time, but depending on the framerate very short periods.
If this period is short enough (say having 40 fps) the timeout will never
expire and no software fallback is used.

Running OpenGL with ~150 fps while scrolling in an IDE which is half transp.
above runs quite smooth.
---
 drivers/char/fusion/call.c      |    3 ++-
 drivers/char/fusion/fusiondev.c |   12 +++++++++---
 drivers/char/fusion/fusiondev.h |    4 +++-
 drivers/char/fusion/fusionee.c  |    2 +-
 drivers/char/fusion/property.c  |   36 ++++++++++++++++++++++++++++++------
 drivers/char/fusion/ref.c       |    2 +-
 drivers/char/fusion/skirmish.c  |    2 +-
 7 files changed, 47 insertions(+), 14 deletions(-)

diff --git a/drivers/char/fusion/call.c b/drivers/char/fusion/call.c
index e8d27a0..6463749 100644
--- a/drivers/char/fusion/call.c
+++ b/drivers/char/fusion/call.c
@@ -235,7 +235,8 @@ fusion_call_execute (int fusion_id, FusionCallExecute *execute)
 
   call->count++;
 
-  fusion_sleep_on (&execution->wait, &call->lock);
+  /* TODO: implement timeout */
+  fusion_sleep_on (&execution->wait, &call->lock, 0);
       
   call = lock_call (execute->call_id);
   if (!call)
diff --git a/drivers/char/fusion/fusiondev.c b/drivers/char/fusion/fusiondev.c
index 4c85bad..85430ec 100644
--- a/drivers/char/fusion/fusiondev.c
+++ b/drivers/char/fusion/fusiondev.c
@@ -51,7 +51,7 @@ static spinlock_t refs_lock = SPIN_LOCK_UNLOCKED;
 /******************************************************************************/
 
 void
-fusion_sleep_on(wait_queue_head_t *q, spinlock_t *lock)
+fusion_sleep_on(wait_queue_head_t *q, spinlock_t *lock, signed long *timeout_ms)
 {
   unsigned long flags;
   wait_queue_t  wait;
@@ -67,7 +67,10 @@ fusion_sleep_on(wait_queue_head_t *q, spinlock_t *lock)
 
   spin_unlock (lock);
 
-  schedule();
+  if (timeout_ms)
+       *timeout_ms = schedule_timeout(1 + *timeout_ms * HZ / 1000);
+  else
+       schedule();
 
   write_lock_irq (&q->lock);
   __remove_wait_queue (q, &wait);
@@ -79,7 +82,10 @@ fusion_sleep_on(wait_queue_head_t *q, spinlock_t *lock)
 
   spin_unlock (lock);
 
-  schedule();
+  if (timeout_ms)
+       *timeout_ms = schedule_timeout(1 + *timeout_ms * HZ / 1000);
+  else
+       schedule();
 
   wq_write_lock_irq (&q->lock);
   __remove_wait_queue (q, &wait);
diff --git a/drivers/char/fusion/fusiondev.h b/drivers/char/fusion/fusiondev.h
index 2a1aeaa..279bb85 100644
--- a/drivers/char/fusion/fusiondev.h
+++ b/drivers/char/fusion/fusiondev.h
@@ -23,6 +23,8 @@ extern struct proc_dir_entry *proc_fusion_dir;
  * Special version of interruptible_sleep_on() that unlocks the spinlock
  * after adding the entry to the queue (just before schedule).
  */
-void fusion_sleep_on(wait_queue_head_t *q, spinlock_t *lock);
+void fusion_sleep_on(wait_queue_head_t *q,
+                     spinlock_t        *lock,
+                     signed long       *timeout_ms);
 
 #endif
diff --git a/drivers/char/fusion/fusionee.c b/drivers/char/fusion/fusionee.c
index c501dff..a2507d9 100644
--- a/drivers/char/fusion/fusionee.c
+++ b/drivers/char/fusion/fusionee.c
@@ -268,7 +268,7 @@ fusionee_get_messages (int id, void *buf, int buf_size, int block)
           return -EAGAIN;
         }
 
-      fusion_sleep_on (&fusionee->wait, &fusionee->lock);
+      fusion_sleep_on (&fusionee->wait, &fusionee->lock, 0);
 
       if (signal_pending(current))
         return -ERESTARTSYS;
diff --git a/drivers/char/fusion/property.c b/drivers/char/fusion/property.c
index 62ee2ef..974bf7a 100644
--- a/drivers/char/fusion/property.c
+++ b/drivers/char/fusion/property.c
@@ -179,6 +179,7 @@ int
 fusion_property_lease (int id, int fusion_id)
 {
   FusionProperty *property;
+  signed long     timeout = 20;
 
   while (true)
     {
@@ -196,7 +197,7 @@ fusion_property_lease (int id, int fusion_id)
           return 0;
 
         case FUSION_PROPERTY_LEASED:
-          fusion_sleep_on (&property->wait, &property->lock);
+          fusion_sleep_on (&property->wait, &property->lock, NULL);
 
           if (signal_pending(current))
             return -ERESTARTSYS;
@@ -204,8 +205,19 @@ fusion_property_lease (int id, int fusion_id)
           break;
 
         case FUSION_PROPERTY_PURCHASED:
-          unlock_property (property);
-          return -EAGAIN;
+          if (!timeout)
+            {
+              printk(KERN_DEBUG "timeout\n");
+              unlock_property (property);
+              return -EAGAIN;
+            }
+     
+          fusion_sleep_on (&property->wait, &property->lock, &timeout);
+     
+          if (signal_pending(current))
+            return -ERESTARTSYS;
+     
+          break;
         }
     }
 
@@ -217,6 +229,7 @@ int
 fusion_property_purchase (int id, int fusion_id)
 {
   FusionProperty *property;
+  signed long     timeout = 20;
 
   while (true)
     {
@@ -236,7 +249,7 @@ fusion_property_purchase (int id, int fusion_id)
           return 0;
 
         case FUSION_PROPERTY_LEASED:
-          fusion_sleep_on (&property->wait, &property->lock);
+          fusion_sleep_on (&property->wait, &property->lock, NULL);
 
           if (signal_pending(current))
             return -ERESTARTSYS;
@@ -244,8 +257,19 @@ fusion_property_purchase (int id, int fusion_id)
           break;
 
         case FUSION_PROPERTY_PURCHASED:
-          unlock_property (property);
-          return -EAGAIN;
+          if (!timeout)
+            {
+              printk(KERN_DEBUG "timeout\n");
+              unlock_property (property);
+              return -EAGAIN;
+            }
+
+          fusion_sleep_on (&property->wait, &property->lock, &timeout);
+
+          if (signal_pending(current))
+            return -ERESTARTSYS;
+
+          break;
         }
     }
 
diff --git a/drivers/char/fusion/ref.c b/drivers/char/fusion/ref.c
index dd1e7c1..71b2d98 100644
--- a/drivers/char/fusion/ref.c
+++ b/drivers/char/fusion/ref.c
@@ -281,7 +281,7 @@ fusion_ref_zero_lock (int id)
 
       if (ref->global || ref->local)
         {
-          fusion_sleep_on (&ref->wait, &ref->lock);
+          fusion_sleep_on (&ref->wait, &ref->lock, 0);
 
           if (signal_pending(current))
             return -ERESTARTSYS;
diff --git a/drivers/char/fusion/skirmish.c b/drivers/char/fusion/skirmish.c
index f3bf2ae..e9712e8 100644
--- a/drivers/char/fusion/skirmish.c
+++ b/drivers/char/fusion/skirmish.c
@@ -187,7 +187,7 @@ fusion_skirmish_prevail (int id, int fusion_id)
               return 0;
             }
 
-          fusion_sleep_on (&skirmish->wait, &skirmish->lock);
+          fusion_sleep_on (&skirmish->wait, &skirmish->lock, 0);
 
           if (signal_pending(current))
             return -ERESTARTSYS;
-- 
1.7.3.3

