From 8a7e65ddf5ba6b907b7183ac8fa1a5472245939d Mon Sep 17 00:00:00 2001
From: Denis Oliver Kropp <dok@directfb.org>
Date: Thu, 8 May 2003 18:52:35 +0000
Subject: [PATCH] Don't do a lease/purchase with timeout if property has been purchased more than 100 ms ago. Otherwise timeout after another 100 ms. Better suitable for long time purchasing which fullscreen apps do.

---
 drivers/char/fusion/fusiondev.c |   10 +++---
 drivers/char/fusion/property.c  |   68 ++++++++++++++++++++++++++------------
 2 files changed, 51 insertions(+), 27 deletions(-)

diff --git a/drivers/char/fusion/fusiondev.c b/drivers/char/fusion/fusiondev.c
index 85430ec..a04a558 100644
--- a/drivers/char/fusion/fusiondev.c
+++ b/drivers/char/fusion/fusiondev.c
@@ -51,7 +51,7 @@ static spinlock_t refs_lock = SPIN_LOCK_UNLOCKED;
 /******************************************************************************/
 
 void
-fusion_sleep_on(wait_queue_head_t *q, spinlock_t *lock, signed long *timeout_ms)
+fusion_sleep_on(wait_queue_head_t *q, spinlock_t *lock, signed long *timeout)
 {
   unsigned long flags;
   wait_queue_t  wait;
@@ -67,8 +67,8 @@ fusion_sleep_on(wait_queue_head_t *q, spinlock_t *lock, signed long *timeout_ms)
 
   spin_unlock (lock);
 
-  if (timeout_ms)
-       *timeout_ms = schedule_timeout(1 + *timeout_ms * HZ / 1000);
+  if (timeout)
+       *timeout = schedule_timeout(*timeout);
   else
        schedule();
 
@@ -82,8 +82,8 @@ fusion_sleep_on(wait_queue_head_t *q, spinlock_t *lock, signed long *timeout_ms)
 
   spin_unlock (lock);
 
-  if (timeout_ms)
-       *timeout_ms = schedule_timeout(1 + *timeout_ms * HZ / 1000);
+  if (timeout)
+       *timeout = schedule_timeout(*timeout);
   else
        schedule();
 
diff --git a/drivers/char/fusion/property.c b/drivers/char/fusion/property.c
index 974bf7a..ea00b38 100644
--- a/drivers/char/fusion/property.c
+++ b/drivers/char/fusion/property.c
@@ -42,6 +42,7 @@ typedef struct {
 
   FusionPropertyState state;
   int                 fusion_id; /* non-zero if leased/purchased */
+  unsigned long       purchase_stamp;
 
   wait_queue_head_t   wait;
 } FusionProperty;
@@ -179,7 +180,7 @@ int
 fusion_property_lease (int id, int fusion_id)
 {
   FusionProperty *property;
-  signed long     timeout = 20;
+  signed long     timeout = -1;
 
   while (true)
     {
@@ -205,17 +206,28 @@ fusion_property_lease (int id, int fusion_id)
           break;
 
         case FUSION_PROPERTY_PURCHASED:
-          if (!timeout)
+          switch (timeout)
             {
-              printk(KERN_DEBUG "timeout\n");
-              unlock_property (property);
-              return -EAGAIN;
-            }
-     
-          fusion_sleep_on (&property->wait, &property->lock, &timeout);
+            case -1:
+              if (jiffies - property->purchase_stamp > HZ / 10)
+                {
+                case 0:
+                  unlock_property (property);
+                  return -EAGAIN;
+                }
+              else
+                timeout = HZ / 10;
+
+              /* fall through */
+
+            default:
+              fusion_sleep_on (&property->wait, &property->lock, &timeout);
      
-          if (signal_pending(current))
-            return -ERESTARTSYS;
+              if (signal_pending(current))
+                return -ERESTARTSYS;
+
+              break;
+            }
      
           break;
         }
@@ -229,7 +241,7 @@ int
 fusion_property_purchase (int id, int fusion_id)
 {
   FusionProperty *property;
-  signed long     timeout = 20;
+  signed long     timeout = -1;
 
   while (true)
     {
@@ -240,8 +252,9 @@ fusion_property_purchase (int id, int fusion_id)
       switch (property->state)
         {
         case FUSION_PROPERTY_AVAILABLE:
-          property->state     = FUSION_PROPERTY_PURCHASED;
-          property->fusion_id = fusion_id;
+          property->state          = FUSION_PROPERTY_PURCHASED;
+          property->fusion_id      = fusion_id;
+          property->purchase_stamp = jiffies;
 
           wake_up_interruptible_all (&property->wait);
 
@@ -257,17 +270,28 @@ fusion_property_purchase (int id, int fusion_id)
           break;
 
         case FUSION_PROPERTY_PURCHASED:
-          if (!timeout)
+          switch (timeout)
             {
-              printk(KERN_DEBUG "timeout\n");
-              unlock_property (property);
-              return -EAGAIN;
-            }
-
-          fusion_sleep_on (&property->wait, &property->lock, &timeout);
+            case -1:
+              if (jiffies - property->purchase_stamp > HZ / 10)
+                {
+                case 0:
+                  unlock_property (property);
+                  return -EAGAIN;
+                }
+              else
+                timeout = HZ / 10;
+
+              /* fall through */
+
+            default:
+              fusion_sleep_on (&property->wait, &property->lock, &timeout);
+     
+              if (signal_pending(current))
+                return -ERESTARTSYS;
 
-          if (signal_pending(current))
-            return -ERESTARTSYS;
+              break;
+            }
 
           break;
         }
-- 
1.7.3.3

