From 226c2d0e7b6b768f31c06eaa4dd42fedaa3b9357 Mon Sep 17 00:00:00 2001
From: Denis Oliver Kropp <dok@directfb.org>
Date: Mon, 7 Apr 2003 12:04:20 +0000
Subject: [PATCH] Added utility function fusion_sleep_on() which does the same as interruptible_sleep_on() but takes an additional argument specifying a spinlock that is unlocked after the wait queue has been modified.

Replaced everything like:

foo_unlock (foo);
/* unsafe gap */
interruptible_sleep_on (&foo->wait);

by:

fusion_sleep_on (&foo->wait, &foo->lock);

Closes the unsafe gap (resulting in blocking) on SMP or preemptible kernels.

Forgot to call fusion_call_destroy_all() in fusionee_destroy().
---
 drivers/char/fusion/call.c      |    4 +---
 drivers/char/fusion/fusiondev.c |   25 +++++++++++++++++++++++++
 drivers/char/fusion/fusiondev.h |    6 ++++++
 drivers/char/fusion/fusionee.c  |   11 +++++++----
 drivers/char/fusion/property.c  |    8 ++------
 drivers/char/fusion/ref.c       |    4 +---
 drivers/char/fusion/skirmish.c  |    4 +---
 7 files changed, 43 insertions(+), 19 deletions(-)

diff --git a/drivers/char/fusion/call.c b/drivers/char/fusion/call.c
index 4ecf854..e8d27a0 100644
--- a/drivers/char/fusion/call.c
+++ b/drivers/char/fusion/call.c
@@ -235,9 +235,7 @@ fusion_call_execute (int fusion_id, FusionCallExecute *execute)
 
   call->count++;
 
-  unlock_call (call);
-
-  interruptible_sleep_on (&execution->wait);
+  fusion_sleep_on (&execution->wait, &call->lock);
       
   call = lock_call (execute->call_id);
   if (!call)
diff --git a/drivers/char/fusion/fusiondev.c b/drivers/char/fusion/fusiondev.c
index 341547b..fe35b8d 100644
--- a/drivers/char/fusion/fusiondev.c
+++ b/drivers/char/fusion/fusiondev.c
@@ -49,6 +49,31 @@ static spinlock_t refs_lock = SPIN_LOCK_UNLOCKED;
 
 /******************************************************************************/
 
+void
+fusion_sleep_on(wait_queue_head_t *q, spinlock_t *lock)
+{
+  unsigned long flags;
+  wait_queue_t  wait;
+  
+  init_waitqueue_entry (&wait, current);
+
+  current->state = TASK_INTERRUPTIBLE;
+
+  wq_write_lock_irqsave (&q->lock,flags);
+  __add_wait_queue (q, &wait);
+  wq_write_unlock (&q->lock);
+
+  spin_unlock (lock);
+
+  schedule();
+
+  wq_write_lock_irq (&q->lock);
+  __remove_wait_queue (q, &wait);
+  wq_write_unlock_irqrestore (&q->lock,flags);
+}
+
+/******************************************************************************/
+
 static void
 fusion_reset (void)
 {
diff --git a/drivers/char/fusion/fusiondev.h b/drivers/char/fusion/fusiondev.h
index 87402f4..2a1aeaa 100644
--- a/drivers/char/fusion/fusiondev.h
+++ b/drivers/char/fusion/fusiondev.h
@@ -19,4 +19,10 @@
 
 extern struct proc_dir_entry *proc_fusion_dir;
 
+/*
+ * Special version of interruptible_sleep_on() that unlocks the spinlock
+ * after adding the entry to the queue (just before schedule).
+ */
+void fusion_sleep_on(wait_queue_head_t *q, spinlock_t *lock);
+
 #endif
diff --git a/drivers/char/fusion/fusionee.c b/drivers/char/fusion/fusionee.c
index 941d598..c501dff 100644
--- a/drivers/char/fusion/fusionee.c
+++ b/drivers/char/fusion/fusionee.c
@@ -21,6 +21,7 @@
 
 #include <linux/fusion.h>
 
+#include "call.h"
 #include "fifo.h"
 #include "list.h"
 #include "fusiondev.h"
@@ -261,12 +262,13 @@ fusionee_get_messages (int id, void *buf, int buf_size, int block)
 
   while (!fusionee->messages.count)
     {
-      unlock_fusionee (fusionee);
-
       if (!block)
-        return -EAGAIN;
+        {
+          unlock_fusionee (fusionee);
+          return -EAGAIN;
+        }
 
-      interruptible_sleep_on (&fusionee->wait);
+      fusion_sleep_on (&fusionee->wait, &fusionee->lock);
 
       if (signal_pending(current))
         return -ERESTARTSYS;
@@ -378,6 +380,7 @@ fusionee_destroy (int id)
 
   spin_unlock (&fusionees_lock);
 
+  fusion_call_destroy_all (id);
   fusion_skirmish_dismiss_all (id);
   fusion_reactor_detach_all (id);
   fusion_property_cede_all (id);
diff --git a/drivers/char/fusion/property.c b/drivers/char/fusion/property.c
index 3452fca..62ee2ef 100644
--- a/drivers/char/fusion/property.c
+++ b/drivers/char/fusion/property.c
@@ -196,9 +196,7 @@ fusion_property_lease (int id, int fusion_id)
           return 0;
 
         case FUSION_PROPERTY_LEASED:
-          unlock_property (property);
-
-          interruptible_sleep_on (&property->wait);
+          fusion_sleep_on (&property->wait, &property->lock);
 
           if (signal_pending(current))
             return -ERESTARTSYS;
@@ -238,9 +236,7 @@ fusion_property_purchase (int id, int fusion_id)
           return 0;
 
         case FUSION_PROPERTY_LEASED:
-          unlock_property (property);
-
-          interruptible_sleep_on (&property->wait);
+          fusion_sleep_on (&property->wait, &property->lock);
 
           if (signal_pending(current))
             return -ERESTARTSYS;
diff --git a/drivers/char/fusion/ref.c b/drivers/char/fusion/ref.c
index ba76f1e..dd1e7c1 100644
--- a/drivers/char/fusion/ref.c
+++ b/drivers/char/fusion/ref.c
@@ -281,9 +281,7 @@ fusion_ref_zero_lock (int id)
 
       if (ref->global || ref->local)
         {
-          unlock_ref (ref);
-
-          interruptible_sleep_on (&ref->wait);
+          fusion_sleep_on (&ref->wait, &ref->lock);
 
           if (signal_pending(current))
             return -ERESTARTSYS;
diff --git a/drivers/char/fusion/skirmish.c b/drivers/char/fusion/skirmish.c
index 0330ae5..f3bf2ae 100644
--- a/drivers/char/fusion/skirmish.c
+++ b/drivers/char/fusion/skirmish.c
@@ -187,9 +187,7 @@ fusion_skirmish_prevail (int id, int fusion_id)
               return 0;
             }
 
-          unlock_skirmish (skirmish);
-
-          interruptible_sleep_on (&skirmish->wait);
+          fusion_sleep_on (&skirmish->wait, &skirmish->lock);
 
           if (signal_pending(current))
             return -ERESTARTSYS;
-- 
1.7.3.3

