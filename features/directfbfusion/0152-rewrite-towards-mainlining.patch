From 188dec2f5868cafe713fa51bbafbfb9334a016d6 Mon Sep 17 00:00:00 2001
From: Niels Roest <niels@directfb.org>
Date: Mon, 2 Mar 2009 21:21:10 +0100
Subject: [PATCH] rewrite towards mainlining

all: use seq_file for safe /proc output
call: use FusionEntry to align with other fusion objects
call: fix for bug in DirectFB 1.0.x when using one-way calls
---
 drivers/char/fusion/call.c      |  274 ++++++++++++---------------------------
 drivers/char/fusion/entries.c   |  157 +++++++++++++++-------
 drivers/char/fusion/entries.h   |    7 +-
 drivers/char/fusion/fusiondev.h |    7 +-
 drivers/char/fusion/property.c  |   21 ++--
 drivers/char/fusion/reactor.c   |   16 +-
 drivers/char/fusion/ref.c       |   20 ++-
 drivers/char/fusion/shmpool.c   |   18 ++--
 drivers/char/fusion/skirmish.c  |   32 +++---
 9 files changed, 251 insertions(+), 301 deletions(-)

diff --git a/drivers/char/fusion/call.c b/drivers/char/fusion/call.c
index 989eadd..23c4810 100644
--- a/drivers/char/fusion/call.c
+++ b/drivers/char/fusion/call.c
@@ -45,13 +45,8 @@ typedef struct {
 } FusionCallExecution;
 
 typedef struct {
-     FusionLink         link;
+     FusionEntry        entry;
 
-     struct semaphore   lock;
-
-     int                id;        /* call id */
-
-     int                pid;       /* owner pid */
      int                fusion_id; /* owner fusion id */
 
      void              *handler;
@@ -65,11 +60,13 @@ typedef struct {
      unsigned int       serial;
 } FusionCall;
 
-/******************************************************************************/
+/* collection, required for 1-param-only passing */
+struct fusion_construct_ctx {
+     int            fusion_id;
+     FusionCallNew *call_new;
+};
 
-static int  lookup_call (FusionDev *dev, int id, FusionCall **ret_call);
-static int  lock_call   (FusionDev *dev, int id, FusionCall **ret_call);
-static void unlock_call (FusionCall *call);
+/******************************************************************************/
 
 static FusionCallExecution *add_execution       (FusionCall          *call,
                                                  Fusionee            *caller,
@@ -82,65 +79,70 @@ static void                 free_all_executions (FusionCall          *call);
 /******************************************************************************/
 
 static int
-fusion_call_read_proc (char *buf, char **start, off_t offset,
-                       int len, int *eof, void *private)
+fusion_call_construct( FusionEntry *entry,
+                       void        *ctx,
+                       void        *create_ctx )
 {
-     FusionLink *l, *e;
-     FusionDev  *dev     = private;
-     int         written = 0;
+     FusionCall *call = (FusionCall*) entry;
+     
+     struct fusion_construct_ctx *cc = (struct fusion_construct_ctx*) create_ctx;
 
-     if (down_interruptible (&dev->call.lock))
-          return -EINTR;
+     call->fusion_id = cc->fusion_id;
+     call->handler   = cc->call_new->handler;
+     call->ctx       = cc->call_new->ctx;
 
-     fusion_list_foreach (l, dev->call.list) {
-          bool        idle = true;
-          FusionCall *call = (FusionCall*) l;
+     cc->call_new->call_id = entry->id;
 
-          if (call->executions)
-               idle = ((FusionCallExecution*) call->executions)->executed;
+     return 0;
+}
 
-          written += sprintf(buf+written,
-                             "(%5d) 0x%08x (%d calls) %s",
-                             call->pid, call->id, call->count,
-                             idle ? "idle" : "executing");
 
-          fusion_list_foreach (e, call->executions) {
-               FusionCallExecution *exec = (FusionCallExecution *) e;
+static void
+fusion_call_destruct( FusionEntry *entry,
+                      void        *ctx )
+{
+     FusionCall *call = (FusionCall*) entry;
 
-               written += sprintf(buf+written, "  [0x%08lx]", exec->caller ? fusionee_id( exec->caller ) : 0);
-          }
+     free_all_executions (call);
+}
 
-          written += sprintf(buf+written, "\n");
+static void
+fusion_call_print( FusionEntry     *entry,
+                   void            *ctx,
+                   struct seq_file *p )
+{
+     FusionLink *e;
+     bool        idle = true;
+     FusionCall *call = (FusionCall*) entry;
 
-          if (written < offset) {
-               offset -= written;
-               written = 0;
-          }
+     if (call->executions)
+          idle = ((FusionCallExecution*) call->executions)->executed;
 
-          if (written >= len)
-               break;
-     }
+     seq_printf( p, "(%5d) 0x%08x (%d calls) %s",
+                    call->entry.pid, call->entry.id, call->count,
+                    idle ? "idle" : "executing");
 
-     up (&dev->call.lock);
+     fusion_list_foreach (e, call->executions) {
+          FusionCallExecution *exec = (FusionCallExecution *) e;
 
-     *start = buf + offset;
-     written -= offset;
-     if (written > len) {
-          *eof = 0;
-          return len;
+          seq_printf( p, "  [0x%08lx]", exec->caller ? fusionee_id( exec->caller ) : 0);
      }
 
-     *eof = 1;
-     return(written<0) ? 0 : written;
+     seq_printf( p, "\n" );
 }
 
+
+FUSION_ENTRY_CLASS( FusionCall, call, fusion_call_construct,
+                    fusion_call_destruct, fusion_call_print )
+
+/******************************************************************************/
+
 int
 fusion_call_init (FusionDev *dev)
 {
-     create_proc_read_entry("calls", 0, dev->proc_dir,
-                            fusion_call_read_proc, dev);
+     fusion_entries_init( &dev->call, &call_class, dev );
 
-     init_MUTEX(&dev->call.lock);
+     fusion_entries_create_proc_entry( dev, "calls", &dev->call );
 
      return 0;
 }
@@ -148,25 +150,9 @@ fusion_call_init (FusionDev *dev)
 void
 fusion_call_deinit (FusionDev *dev)
 {
-     FusionLink *l;
-
-     down (&dev->call.lock);
-
      remove_proc_entry ("calls", dev->proc_dir);
 
-     l = dev->call.list;
-     while (l) {
-          FusionLink *next = l->next;
-          FusionCall *call = (FusionCall *) l;
-
-          free_all_executions (call);
-
-          kfree (call);
-
-          l = next;
-     }
-
-     up (&dev->call.lock);
+     fusion_entries_deinit( &dev->call );
 }
 
 /******************************************************************************/
@@ -174,32 +160,14 @@ fusion_call_deinit (FusionDev *dev)
 int
 fusion_call_new (FusionDev *dev, int fusion_id, FusionCallNew *call_new)
 {
-     FusionCall *call;
-
-     call = kmalloc (sizeof(FusionCall), GFP_KERNEL);
-     if (!call)
-          return -ENOMEM;
-
-     memset (call, 0, sizeof(FusionCall));
-
-     if (down_interruptible (&dev->call.lock)) {
-          kfree (call);
-          return -EINTR;
-     }
-
-     call->id        = ++dev->call.ids;
-     call->pid       = current->pid;
-     call->fusion_id = fusion_id;
-     call->handler   = call_new->handler;
-     call->ctx       = call_new->ctx;
-
-     init_MUTEX (&call->lock);
-
-     fusion_list_prepend (&dev->call.list, &call->link);
-
-     up (&dev->call.lock);
+     int         id;
+     int         ret;
 
-     call_new->call_id = call->id;
+     struct fusion_construct_ctx cc = { fusion_id, call_new };
+     
+     ret = fusion_entry_create( &dev->call, &id, &cc );
+     if( ret )
+          return ret;
 
      return 0;
 }
@@ -214,7 +182,7 @@ fusion_call_execute (FusionDev *dev, Fusionee *fusionee, FusionCallExecute *exec
      unsigned int         serial;
 
      /* Lookup and lock call. */
-     ret = lock_call (dev, execute->call_id, &call);
+     ret = fusion_call_lock( &dev->call, execute->call_id, false, &call );
      if (ret)
           return ret;
 
@@ -226,11 +194,12 @@ fusion_call_execute (FusionDev *dev, Fusionee *fusionee, FusionCallExecute *exec
      if (fusionee && !(execute->flags & FCEF_ONEWAY)) {
           execution = add_execution (call, fusionee, execute, serial);
           if (!execution) {
-               unlock_call (call);
+               fusion_call_unlock (call);
                return -ENOMEM;
           }
      }
 
+
      /* Fill call message. */
      message.handler  = call->handler;
      message.ctx      = call->ctx;
@@ -244,13 +213,13 @@ fusion_call_execute (FusionDev *dev, Fusionee *fusionee, FusionCallExecute *exec
 
      /* Put message into queue of callee. */
      ret = fusionee_send_message (dev, fusionee, call->fusion_id, FMT_CALL,
-                                  call->id, 0, sizeof(message), &message, NULL, NULL, 1);
+                                  call->entry.id, 0, sizeof(message), &message, NULL, NULL, 1);
      if (ret) {
           if (execution) {
                remove_execution (call, execution);
                kfree (execution);
           }
-          unlock_call (call);
+          fusion_call_unlock( call );
           return ret;
      }
 
@@ -262,7 +231,7 @@ fusion_call_execute (FusionDev *dev, Fusionee *fusionee, FusionCallExecute *exec
           fusion_skirmish_transfer_all( dev, call->fusion_id, fusionee_id( fusionee ), current->pid );
 
           /* Unlock call and wait for execution result. TODO: add timeout? */
-          fusion_sleep_on( &execution->wait, &call->lock, 0 );
+          fusion_sleep_on( &execution->wait, &call->entry.lock, 0 );
 
           if (signal_pending(current)) {
                /* Indicate that a signal was received and execution won't be freed by caller. */
@@ -281,7 +250,7 @@ fusion_call_execute (FusionDev *dev, Fusionee *fusionee, FusionCallExecute *exec
      }
      else
           /* Unlock call. */
-          unlock_call( call );
+          fusion_call_unlock( call );
 
      return 0;
 }
@@ -297,7 +266,7 @@ fusion_call_return (FusionDev *dev, int fusion_id, FusionCallReturn *call_ret)
           return -EOPNOTSUPP;
 
      /* Lookup and lock call. */
-     ret = lock_call (dev, call_ret->call_id, &call);
+     ret = fusion_call_lock (&dev->call, call_ret->call_id, false, &call);
      if (ret)
           return ret;
 
@@ -324,7 +293,7 @@ fusion_call_return (FusionDev *dev, int fusion_id, FusionCallReturn *call_ret)
                /* Remove and free execution. */
                remove_execution( call, execution );
                kfree( execution );
-               unlock_call( call );
+               fusion_call_unlock( call );
                return -EIDRM;
           }
 
@@ -342,13 +311,17 @@ fusion_call_return (FusionDev *dev, int fusion_id, FusionCallReturn *call_ret)
           wake_up_interruptible( &execution->wait );
 
           /* Unlock call. */
-          unlock_call (call);
+          fusion_call_unlock( call );
 
           return 0;
      }
 
      /* Unlock call. */
-     unlock_call (call);
+     fusion_call_unlock( call );
+
+     /* DirectFB 1.0.x does not handle one-way-calls properly */
+     if (dev->api.major <= 3)
+          return 0;
 
      return -ENOMSG;
 }
@@ -366,48 +339,28 @@ fusion_call_destroy (FusionDev *dev, int fusion_id, int call_id)
           if (ret)
                return ret;
 
-          /* Lookup call only, list still locked. */
-          ret = lookup_call( dev, call_id, &call );
+          ret = fusion_call_lock (&dev->call, call_id, false, &call);
           if (ret)
                return ret;
 
           /* Check if we own the call. */
           if (call->fusion_id != fusion_id) {
-               up (&dev->call.lock);
+               fusion_call_unlock( call );
                return -EIO;
           }
 
-          /* Lock the call, too. */
-          if (down_interruptible (&call->lock)) {
-               up (&dev->call.lock);
-               return -EINTR;
-          }
-
           /* If an execution is pending... */
           execution = (FusionCallExecution *) call->executions;
           if (execution) {
-               /* Unlock the list. */
-               up (&dev->call.lock);
-
                /* Unlock call and wait for execution. TODO: add timeout? */
-               fusion_sleep_on( &execution->wait, &call->lock, 0 );
+               fusion_sleep_on( &execution->wait, &call->entry.lock, 0 );
 
                if (signal_pending(current))
                     return -EINTR;
           }
      } while (execution);
 
-
-
-     fusion_list_remove (&dev->call.list, &call->link);
-
-     free_all_executions (call);
-
-     up (&dev->call.lock);
-
-     up (&call->lock);
-
-     kfree (call);
+     fusion_entry_destroy_locked( call->entry.entries, &call->entry );
 
      return 0;
 }
@@ -425,19 +378,12 @@ fusion_call_destroy_all (FusionDev *dev, int fusion_id)
           FusionLink *next = l->next;
           FusionCall *call = (FusionCall *) l;
 
-          down (&call->lock);
-
-          if (call->fusion_id == fusion_id) {
-               free_all_executions (call);
-
-               fusion_list_remove (&dev->call.list, &call->link);
+          down (&call->entry.lock);
 
-               up (&call->lock);
-
-               kfree (call);
-          }
+          if (call->fusion_id == fusion_id)
+               fusion_entry_destroy_locked( call->entry.entries, &call->entry );
           else
-               up (&call->lock);
+               up (&call->entry.lock);
 
           l = next;
      }
@@ -445,61 +391,9 @@ fusion_call_destroy_all (FusionDev *dev, int fusion_id)
      up (&dev->call.lock);
 }
 
-/******************************************************************************/
-
-static int
-lookup_call (FusionDev *dev, int id, FusionCall **ret_call)
-{
-     FusionLink *l;
-
-     if (down_interruptible (&dev->call.lock))
-          return -EINTR;
-
-     fusion_list_foreach (l, dev->call.list) {
-          FusionCall *call = (FusionCall *) l;
-
-          if (call->id == id) {
-               *ret_call = call;
-               return 0;
-          }
-     }
 
-     up (&dev->call.lock);
-
-     return -EINVAL;
-}
-
-static int
-lock_call (FusionDev *dev, int id, FusionCall **ret_call)
-{
-     int         ret;
-     FusionCall *call;
-
-     ret = lookup_call (dev, id, &call);
-     if (ret)
-          return ret;
-
-     if (call) {
-          fusion_list_move_to_front (&dev->call.list, &call->link);
-
-          if (down_interruptible (&call->lock)) {
-               up (&dev->call.lock);
-               return -EINTR;
-          }
-
-          up (&dev->call.lock);
-     }
-
-     *ret_call = call;
-
-     return 0;
-}
+/******************************************************************************/
 
-static void
-unlock_call (FusionCall *call)
-{
-     up (&call->lock);
-}
 
 static FusionCallExecution *
 add_execution (FusionCall        *call,
@@ -518,7 +412,7 @@ add_execution (FusionCall        *call,
      memset (execution, 0, sizeof(FusionCallExecution));
 
      execution->caller  = caller;
-     execution->call_id = call->id;
+     execution->call_id = call->entry.id;
      execution->serial  = serial;
 
      init_waitqueue_head (&execution->wait);
diff --git a/drivers/char/fusion/entries.c b/drivers/char/fusion/entries.c
index 7469710..437f75b 100644
--- a/drivers/char/fusion/entries.c
+++ b/drivers/char/fusion/entries.c
@@ -28,6 +28,7 @@
 #include "fusiondev.h"
 #include "entries.h"
 
+struct timeval now;
 
 void
 fusion_entries_init( FusionEntries    *entries,
@@ -70,82 +71,138 @@ fusion_entries_deinit( FusionEntries *entries )
      up( &entries->lock );
 }
 
-int
-fusion_entries_read_proc(char *buf, char **start, off_t offset,
-                         int len, int *eof, void *private)
+/* reading PROC entries */
+
+static void *fusion_entries_seq_start(struct seq_file *f, loff_t *pos)
 {
+     int i = *pos;
+
      FusionEntry      *entry;
+     FusionEntries    *entries;
      FusionEntryClass *class;
-     FusionEntries    *entries = private;
-     int               written = 0;
-     struct timeval    now;
+
+     entries = f->private;
+     entry   = (void*)(entries->list);
+     
+     while(i && entry) {
+          entry = (void*)(entry->link.next);
+          i--;
+     }
 
      FUSION_ASSERT( entries != NULL );
      FUSION_ASSERT( entries->class != NULL );
 
-     class = entries->class;
+     if (down_interruptible (&entries->lock))
+          return NULL;
 
+     class = entries->class;
      if (!class->Print)
-          return -ENOTSUPP;
-
-     if (down_interruptible (&entries->lock))
-          return -EINTR;
+          return NULL;
 
      do_gettimeofday( &now );
 
-     fusion_list_foreach (entry, entries->list) {
-          if (entry->last_lock.tv_sec) {
-               int diff = ((now.tv_sec  - entry->last_lock.tv_sec) * 1000 +
-                           (now.tv_usec - entry->last_lock.tv_usec) / 1000);
-
-               if (diff < 1000) {
-                    written += sprintf( buf + written, "%3d  ms  ", diff );
-               }
-               else if (diff < 1000000) {
-                    written += sprintf( buf + written, "%3d.%d s  ",
-                                        diff / 1000, (diff % 1000) / 100 );
-               }
-               else {
-                    diff = ( now.tv_sec  - entry->last_lock.tv_sec +
-                            (now.tv_usec - entry->last_lock.tv_usec) / 1000000);
-
-                    written += sprintf( buf + written, "%3d.%d h  ",
-                                        diff / 3600, (diff % 3600) / 360 );
-               }
-          }
-          else
-               written += sprintf( buf + written, "  -.-    " );
+     return entry;
+}
+
+static void *fusion_entries_seq_next(struct seq_file *f, void *v, loff_t *pos)
+{
+     FusionEntry *entry = v;
+
+     (*pos)++;
+     return entry->link.next;
+}
+
+static void fusion_entries_seq_stop(struct seq_file *f, void *v)
+{
+     FusionEntries *entries;
+
+     entries = f->private;
+     (void)v;
+ 
+     up (&entries->lock);
+}
 
+int
+fusion_entries_show(struct seq_file *p, void *v)
+{
+     FusionEntry      *entry;
+     FusionEntryClass *class;
 
-          written += sprintf( buf + written, "(%5d) 0x%08x  ", entry->pid, entry->id );
+     entry = v;
 
-          written += sprintf( buf + written, "%-24s  ", entry->name[0] ? entry->name : "" );
+     class = entry->entries->class;
 
-          written += class->Print( entry, entries->ctx, buf + written );
+     if (entry->last_lock.tv_sec) {
+          int diff = ((now.tv_sec  - entry->last_lock.tv_sec) * 1000 +
+                      (now.tv_usec - entry->last_lock.tv_usec) / 1000);
 
-          if (written < offset) {
-               offset -= written;
-               written = 0;
+          if (diff < 1000) {
+               seq_printf( p, "%3d  ms  ", diff );
+          }
+          else if (diff < 1000000) {
+               seq_printf( p, "%3d.%d s  ", diff / 1000, (diff % 1000) / 100 );
           }
+          else {
+               diff = ( now.tv_sec  - entry->last_lock.tv_sec +
+                       (now.tv_usec - entry->last_lock.tv_usec) / 1000000);
 
-          if (written >= len)
-               break;
+               seq_printf( p, "%3d.%d h  ", diff / 3600, (diff % 3600) / 360 );
+          }
      }
+     else
+          seq_printf( p, "  -.-    " );
 
-     up (&entries->lock);
 
-     *start = buf + offset;
-     written -= offset;
-     if (written > len) {
-          *eof = 0;
-          return len;
-     }
+     seq_printf( p, "(%5d) 0x%08x  ", entry->pid, entry->id );
+     seq_printf( p, "%-24s  ", entry->name[0] ? entry->name : "" );
 
-     *eof = 1;
+     class->Print( entry, entry->entries->ctx, p );
 
-     return (written<0) ? 0 : written;
+     return 0;
 }
 
+static const struct seq_operations fusion_entries_seq_ops = {
+     .start = fusion_entries_seq_start,
+     .next  = fusion_entries_seq_next,
+     .stop  = fusion_entries_seq_stop,
+     .show  = fusion_entries_show
+};
+
+static int fusion_entries_open(struct inode *inode, struct file *file)
+{
+        struct seq_file *sf;
+        int ret;
+
+        ret = seq_open(file, &fusion_entries_seq_ops);
+        if (ret < 0)
+                return ret;
+
+        sf = file->private_data;
+        sf->private = PDE(inode)->data;
+
+        return 0;
+}
+
+static const struct file_operations proc_fusion_entries_operations = {
+     .open     = fusion_entries_open,
+     .read     = seq_read,
+     .llseek   = seq_lseek,
+     .release  = seq_release,
+};
+
+void fusion_entries_create_proc_entry( FusionDev *dev, const char *name, FusionEntries *data )
+{
+     struct proc_dir_entry *pde;
+
+     pde = create_proc_entry( name, 0, dev->proc_dir );
+     if (pde) {
+          pde->proc_fops = &proc_fusion_entries_operations;
+          pde->data      = data;
+     }
+}
+
+
+
 int
 fusion_entry_create( FusionEntries *entries,
                      int           *ret_id,
diff --git a/drivers/char/fusion/entries.h b/drivers/char/fusion/entries.h
index 2ca5ae0..1f5b455 100644
--- a/drivers/char/fusion/entries.h
+++ b/drivers/char/fusion/entries.h
@@ -16,6 +16,7 @@
 #define __FUSION__ENTRIES_H__
 
 #include <linux/mutex.h>
+#include <linux/seq_file.h>
 
 #include "types.h"
 #include "list.h"
@@ -29,7 +30,7 @@ typedef const struct {
 
      int  (*Init)   ( FusionEntry *entry, void *ctx, void *create_ctx );
      void (*Destroy)( FusionEntry *entry, void *ctx );
-     int  (*Print)  ( FusionEntry *entry, void *ctx, char *buf );
+     void (*Print)  ( FusionEntry *entry, void *ctx, struct seq_file *p );
 } FusionEntryClass;
 
 
@@ -74,9 +75,7 @@ void fusion_entries_deinit( FusionEntries    *entries );
 
 /* '/proc' support */
 
-int  fusion_entries_read_proc( char *buf, char **start, off_t offset,
-                               int len, int *eof, void *private );
-
+void fusion_entries_create_proc_entry( FusionDev *dev, const char *name, FusionEntries *data );
 
 /* Create & Destroy */
 
diff --git a/drivers/char/fusion/fusiondev.h b/drivers/char/fusion/fusiondev.h
index 468ec6b..2ae5e8b 100644
--- a/drivers/char/fusion/fusiondev.h
+++ b/drivers/char/fusion/fusiondev.h
@@ -60,18 +60,13 @@ struct __Fusion_FusionDev {
      } stat;
 
      struct {
-          int                ids;
-          FusionLink        *list;
-          struct semaphore   lock;
-     } call;
-
-     struct {
           int                last_id;
           FusionLink        *list;
           struct semaphore   lock;
           wait_queue_head_t  wait;
      } fusionee;
 
+     FusionEntries  call;
      FusionEntries  properties;
      FusionEntries  reactor;
      FusionEntries  ref;
diff --git a/drivers/char/fusion/property.c b/drivers/char/fusion/property.c
index 4059b0f..080e396 100644
--- a/drivers/char/fusion/property.c
+++ b/drivers/char/fusion/property.c
@@ -20,6 +20,7 @@
 #include <linux/slab.h>
 #include <linux/smp_lock.h>
 #include <linux/sched.h>
+#include <linux/proc_fs.h>
 
 #ifndef yield
 #define yield schedule
@@ -49,20 +50,21 @@ typedef struct {
      int                 count;    /* lock counter */
 } FusionProperty;
 
-static int
-fusion_property_print( FusionEntry *entry,
-                       void        *ctx,
-                       char        *buf )
+static void
+fusion_property_print( FusionEntry     *entry,
+                       void            *ctx,
+                       struct seq_file *p )
 {
      FusionProperty *property = (FusionProperty*) entry;
 
      if (property->state != FUSION_PROPERTY_AVAILABLE) {
-          return sprintf( buf, "%s by 0x%08x (%d) %dx\n",
-                          property->state == FUSION_PROPERTY_LEASED ? "leased" : "purchased",
-                          property->fusion_id, property->lock_pid, property->count );
+          seq_printf( p, "%s by 0x%08x (%d) %dx\n",
+                      property->state == FUSION_PROPERTY_LEASED ? "leased" : "purchased",
+                      property->fusion_id, property->lock_pid, property->count );
+          return;
      }
 
-     return sprintf( buf, "\n" );
+     seq_printf( p, "\n" );
 }
 
 FUSION_ENTRY_CLASS( FusionProperty, property, NULL, NULL, fusion_property_print )
@@ -74,8 +76,7 @@ fusion_property_init( FusionDev *dev )
 {
      fusion_entries_init( &dev->properties, &property_class, dev );
 
-     create_proc_read_entry( "properties", 0, dev->proc_dir,
-                             fusion_entries_read_proc, &dev->properties );
+     fusion_entries_create_proc_entry( dev, "properties", &dev->properties );
 
      return 0;
 }
diff --git a/drivers/char/fusion/reactor.c b/drivers/char/fusion/reactor.c
index 6805f0f..101ddeb 100644
--- a/drivers/char/fusion/reactor.c
+++ b/drivers/char/fusion/reactor.c
@@ -20,6 +20,7 @@
 #include <linux/slab.h>
 #include <linux/smp_lock.h>
 #include <linux/sched.h>
+#include <linux/proc_fs.h>
 
 #include <linux/fusion.h>
 
@@ -95,10 +96,10 @@ fusion_reactor_destruct( FusionEntry *entry,
      free_all_nodes( reactor );
 }
 
-static int
-fusion_reactor_print( FusionEntry *entry,
-                      void        *ctx,
-                      char        *buf )
+static void
+fusion_reactor_print( FusionEntry     *entry,
+                      void            *ctx,
+                      struct seq_file *p )
 {
      int            num     = 0;
      FusionReactor *reactor = (FusionReactor*) entry;
@@ -108,8 +109,8 @@ fusion_reactor_print( FusionEntry *entry,
           num++;
      }
 
-     return sprintf( buf, "%5dx dispatch, %d nodes%s\n", reactor->dispatch_count, num,
-                     reactor->destroyed ? "  DESTROYED" : "" );
+     seq_printf( p, "%5dx dispatch, %d nodes%s\n", reactor->dispatch_count, num,
+                    reactor->destroyed ? "  DESTROYED" : "" );
 }
 
 
@@ -123,8 +124,7 @@ fusion_reactor_init (FusionDev *dev)
 {
      fusion_entries_init( &dev->reactor, &reactor_class, dev );
 
-     create_proc_read_entry( "reactors", 0, dev->proc_dir,
-                             fusion_entries_read_proc, &dev->reactor );
+     fusion_entries_create_proc_entry( dev, "reactors", &dev->reactor );
 
      return 0;
 }
diff --git a/drivers/char/fusion/ref.c b/drivers/char/fusion/ref.c
index be8bdc0..161415d 100644
--- a/drivers/char/fusion/ref.c
+++ b/drivers/char/fusion/ref.c
@@ -20,6 +20,7 @@
 #include <linux/slab.h>
 #include <linux/smp_lock.h>
 #include <linux/sched.h>
+#include <linux/proc_fs.h>
 
 #include <linux/fusion.h>
 
@@ -91,17 +92,20 @@ fusion_ref_destruct( FusionEntry *entry,
      free_all_local( ref );
 }
 
-static int
-fusion_ref_print( FusionEntry *entry,
-                  void        *ctx,
-                  char        *buf )
+
+static void
+fusion_ref_print( FusionEntry     *entry,
+                  void            *ctx,
+                  struct seq_file *p )
 {
      FusionRef *ref = (FusionRef*) entry;
 
-     if (ref->locked)
-          return sprintf( buf, "%2d %2d (locked by %d)\n", ref->global, ref->local, ref->locked );
+     if (ref->locked) {
+          seq_printf( p, "%2d %2d (locked by %d)\n", ref->global, ref->local, ref->locked );
+          return;
+     }
 
-     return sprintf( buf, "%2d %2d\n", ref->global, ref->local );
+     seq_printf( p, "%2d %2d\n", ref->global, ref->local );
 }
 
 FUSION_ENTRY_CLASS( FusionRef, ref, NULL,
@@ -114,7 +118,7 @@ fusion_ref_init( FusionDev *dev )
 {
      fusion_entries_init( &dev->ref, &ref_class, dev );
 
-     create_proc_read_entry( "refs", 0, dev->proc_dir, fusion_entries_read_proc, &dev->ref );
+     fusion_entries_create_proc_entry( dev, "refs", &dev->ref );
 
      return 0;
 }
diff --git a/drivers/char/fusion/shmpool.c b/drivers/char/fusion/shmpool.c
index 9e96b1d..c086bf2 100644
--- a/drivers/char/fusion/shmpool.c
+++ b/drivers/char/fusion/shmpool.c
@@ -21,6 +21,7 @@
 #include <linux/smp_lock.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
+#include <linux/proc_fs.h>
 
 #include <linux/fusion.h>
 
@@ -154,10 +155,10 @@ fusion_shmpool_destruct( FusionEntry *entry,
      up( &addr_lock );
 }
 
-static int
-fusion_shmpool_print( FusionEntry *entry,
-                      void        *ctx,
-                      char        *buf )
+static void
+fusion_shmpool_print( FusionEntry     *entry,
+                      void            *ctx,
+                      struct seq_file *p )
 {
      int            num     = 0;
      FusionSHMPool *shmpool = (FusionSHMPool*) entry;
@@ -167,9 +168,9 @@ fusion_shmpool_print( FusionEntry *entry,
           num++;
      }
 
-     return sprintf( buf, "0x%p [0x%x] - 0x%x, %dx dispatch, %d nodes\n",
-                     shmpool->addr_base, shmpool->max_size, shmpool->size,
-                     shmpool->dispatch_count, num );
+     seq_printf( p, "0x%p [0x%x] - 0x%x, %dx dispatch, %d nodes\n",
+                 shmpool->addr_base, shmpool->max_size, shmpool->size,
+                 shmpool->dispatch_count, num );
 }
 
 
@@ -183,8 +184,7 @@ fusion_shmpool_init (FusionDev *dev)
 {
      fusion_entries_init( &dev->shmpool, &shmpool_class, dev );
 
-     create_proc_read_entry( "shmpools", 0, dev->proc_dir,
-                             fusion_entries_read_proc, &dev->shmpool );
+     fusion_entries_create_proc_entry( dev, "shmpools", &dev->shmpool );
 
      return 0;
 }
diff --git a/drivers/char/fusion/skirmish.c b/drivers/char/fusion/skirmish.c
index a5da11b..a805bbb 100644
--- a/drivers/char/fusion/skirmish.c
+++ b/drivers/char/fusion/skirmish.c
@@ -20,6 +20,7 @@
 #include <linux/slab.h>
 #include <linux/smp_lock.h>
 #include <linux/sched.h>
+#include <linux/proc_fs.h>
 
 #include <linux/fusion.h>
 
@@ -87,12 +88,11 @@ skirmish_signal_handler( void *ctx )
 
 /******************************************************************************/
 
-static int
-fusion_skirmish_print( FusionEntry *entry,
-                       void        *ctx,
-                       char        *buf )
+static void
+fusion_skirmish_print( FusionEntry     *entry,
+                       void            *ctx,
+                       struct seq_file *p )
 {
-     int             written  = 0;
      FusionSkirmish *skirmish = (FusionSkirmish*) entry;
 
 #ifdef FUSION_DEBUG_SKIRMISH_DEADLOCK
@@ -105,11 +105,11 @@ fusion_skirmish_print( FusionEntry *entry,
           }
      }
 
-     written += sprintf( buf + written, "[%2d]%s", n, skirmish->outer ? "." : " " );
+     seq_printf( p, "[%2d]%s", n, skirmish->outer ? "." : " " );
 
      for (i=0, n=0; i<MAX_PRE_ACQUISITIONS; i++) {
           if (skirmish->pre_acquis[i]) {
-               written += sprintf( buf + written, "%s%02x", n ? "," : "", skirmish->pre_acquis[i] - 1 );
+               seq_printf( p, "%s%02x", n ? "," : "", skirmish->pre_acquis[i] - 1 );
 
                n++;
           }
@@ -118,16 +118,17 @@ fusion_skirmish_print( FusionEntry *entry,
 
      if (skirmish->lock_fid) {
           if (skirmish->entry.waiters)
-               return sprintf( buf + written, " - %dx [0x%08x] (%d)  %d WAITING\n",
-                               skirmish->lock_count, skirmish->lock_fid,
-                               skirmish->lock_pid, skirmish->entry.waiters ) + written;
+               seq_printf( p, " - %dx [0x%08x] (%d)  %d WAITING\n",
+                           skirmish->lock_count, skirmish->lock_fid,
+                           skirmish->lock_pid, skirmish->entry.waiters );
           else
-               return sprintf( buf + written, " - %dx [0x%08x] (%d)\n",
-                               skirmish->lock_count, skirmish->lock_fid,
-                               skirmish->lock_pid ) + written;
+               seq_printf( p, " - %dx [0x%08x] (%d)\n",
+                           skirmish->lock_count, skirmish->lock_fid,
+                           skirmish->lock_pid );
+          return;
      }
 
-     return sprintf( buf + written, "\n" ) + written;
+     seq_printf( p, "\n" );
 }
 
 FUSION_ENTRY_CLASS( FusionSkirmish, skirmish, NULL, NULL, fusion_skirmish_print )
@@ -139,8 +140,7 @@ fusion_skirmish_init (FusionDev *dev)
 {
      fusion_entries_init( &dev->skirmish, &skirmish_class, dev );
 
-     create_proc_read_entry( "skirmishs", 0, dev->proc_dir,
-                             fusion_entries_read_proc, &dev->skirmish );
+     fusion_entries_create_proc_entry( dev, "skirmishs", &dev->skirmish );
 
      sigemptyset( &m_sigmask );
      sigaddset( &m_sigmask, SIGSTOP );
-- 
1.7.3.3

