From 45a94c9c413ecbab3a18e0d1dbb9f86922826e8c Mon Sep 17 00:00:00 2001
From: Denis Oliver Kropp <dok@shizo.zion.home>
Date: Tue, 9 Oct 2007 03:51:41 +0200
Subject: [PATCH] Fix missing cleanup of execution entry if caller receives a signal while waiting for the execution.

---
 drivers/char/fusion/call.c |   20 +++++++++++++-------
 1 files changed, 13 insertions(+), 7 deletions(-)

diff --git a/drivers/char/fusion/call.c b/drivers/char/fusion/call.c
index 064cace..7f78c73 100644
--- a/drivers/char/fusion/call.c
+++ b/drivers/char/fusion/call.c
@@ -255,13 +255,11 @@ fusion_call_execute (FusionDev *dev, Fusionee *fusionee, FusionCallExecute *exec
           fusion_sleep_on (&execution->wait, &call->lock, 0);
 
           ret = lock_call (dev, execute->call_id, &call);
-          if (ret)
-               return ret == -EINVAL ? -EIDRM : ret;
+          if (ret) {
+               /* Clear caller to allow cleanup of entry. */
+               execution->caller = NULL;
 
-          if (signal_pending(current)) {
-               execution->caller = 0;
-               unlock_call (call);
-               return -EINTR;
+               return ret == -EINVAL ? -EIDRM : ret;
           }
 
           execute->ret_val = execution->ret_val;
@@ -273,7 +271,7 @@ fusion_call_execute (FusionDev *dev, Fusionee *fusionee, FusionCallExecute *exec
 
      unlock_call (call);
 
-     return 0;
+     return ret;
 }
 
 int
@@ -291,6 +289,14 @@ fusion_call_return (FusionDev *dev, int fusion_id, FusionCallReturn *call_ret)
      while (l) {
           FusionCallExecution *execution = (FusionCallExecution*) l;
 
+          /* Cleanup entry from caller that got a signal? */
+          if (!execution->caller) {
+               l = l->prev;
+               remove_execution (call, execution);
+               kfree (execution);
+               continue;
+          }
+
           if (execution->call_id != call_ret->call_id || execution->serial != call_ret->serial) {
                l = l->prev;
                continue;
-- 
1.7.3.3

