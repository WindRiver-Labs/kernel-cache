From 28837d1a660263f2c22f02527c9ae4d5000d4970 Mon Sep 17 00:00:00 2001
From: Denis Oliver Kropp <dok@directfb.org>
Date: Sun, 7 Nov 2004 09:15:11 +0000
Subject: [PATCH] Added version numbering to the Fusion Kernel API. The major number is increased if binary compatibility breaks, while the minor number is increased for new features.

Added new ioctl FUSION_REF_INHERIT to have a reference inherit
the local reference count from another reference, i.e. adding
the other's local count to its own. If the inherited reference
is changed, the inheritor is also updated.

There's just one reference that can be inherited from by each
reference, but a reference can have multiple inheritors.

Replaced FUSION_GET_ID by FUSION_ENTER. The new ioctl gets a
struct containing the API version the applicaiton was compiled
with. If the versions are incompatible, an error is returned,
otherwise the fusion id passed back to the application via the
struct.

Use the 'type' field of the ioctl code to encode one of the
following command group identifiers: FT_LOUNGE, FT_MESSAGING,
FT_CALL, FT_REF, FT_SKIRMISH, FT_PROPERTY and FT_REACTOR.

Now, the 'nr' field value is starting at zero within each group.

The huge switch in fusion_ioctl() for all commands is replaced
by a switch for just the different types (see above). Each type
has its own function with a switch for the command numbers.
It's not faster on my machine, but at least it looks much better.

Fixed a memory leak when clearing local references upon process exit.

Added some TODOs.
---
 drivers/char/fusion/fusiondev.c |  161 +++++++++++++++++++----
 drivers/char/fusion/ref.c       |  281 +++++++++++++++++++++++++++++++-------
 drivers/char/fusion/ref.h       |    6 +-
 include/linux/fusion.h          |  114 ++++++++++------
 4 files changed, 440 insertions(+), 122 deletions(-)

diff --git a/drivers/char/fusion/fusiondev.c b/drivers/char/fusion/fusiondev.c
index c8adf26..18d08fe 100644
--- a/drivers/char/fusion/fusiondev.c
+++ b/drivers/char/fusion/fusiondev.c
@@ -372,32 +372,45 @@ fusion_poll (struct file *file, poll_table * wait)
 }
 
 static int
-fusion_ioctl (struct inode *inode, struct file *file,
+lounge_ioctl (FusionDev *dev, int fusion_id,
               unsigned int cmd, unsigned long arg)
 {
-     int                    id;
-     int                    ret;
-     int                    refs;
-     int                    fusion_id = (int) file->private_data;
-     FusionDev             *dev = fusion_devs[MINOR(inode->i_rdev)];
-     FusionSendMessage      send;
-     FusionReactorDispatch  dispatch;
-     FusionRefWatch         watch;
-     FusionKill             kill;
-     FusionCallNew          call;
-     FusionCallExecute      execute;
-     FusionCallReturn       call_ret;
-
-     DEBUG( "fusion_ioctl (0x%08x)\n", cmd );
+     FusionEnter enter;
+     FusionKill  kill;
 
      switch (_IOC_NR(cmd)) {
-          case _IOC_NR(FUSION_GET_ID):
-               if (put_user (fusion_id, (int*) arg))
+          case _IOC_NR(FUSION_ENTER):
+               if (copy_from_user (&enter, (FusionEnter*) arg, sizeof(enter)))
+                    return -EFAULT;
+
+               if (enter.api.major != FUSION_API_MAJOR || enter.api.minor > FUSION_API_MINOR)
+                    return -ENOPROTOOPT;
+
+               enter.fusion_id = fusion_id;
+
+               if (copy_to_user ((FusionEnter*) arg, &enter, sizeof(enter)))
                     return -EFAULT;
 
                return 0;
 
+          case _IOC_NR(FUSION_KILL):
+               if (copy_from_user (&kill, (FusionKill*) arg, sizeof(kill)))
+                    return -EFAULT;
+
+               return fusionee_kill (dev, fusion_id,
+                                     kill.fusion_id, kill.signal, kill.timeout_ms);
+     }
+
+     return -ENOSYS;
+}
 
+static int
+messaging_ioctl (FusionDev *dev, int fusion_id,
+                 unsigned int cmd, unsigned long arg)
+{
+     FusionSendMessage send;
+
+     switch (_IOC_NR(cmd)) {
           case _IOC_NR(FUSION_SEND_MESSAGE):
                if (copy_from_user (&send, (FusionSendMessage*) arg, sizeof(send)))
                     return -EFAULT;
@@ -411,8 +424,22 @@ fusion_ioctl (struct inode *inode, struct file *file,
 
                return fusionee_send_message (dev, fusion_id, send.fusion_id, FMT_SEND,
                                              send.msg_id, send.msg_size, send.msg_data);
+     }
+
+     return -ENOSYS;
+}
 
+static int
+call_ioctl (FusionDev *dev, int fusion_id,
+            unsigned int cmd, unsigned long arg)
+{
+     int               id;
+     int               ret;
+     FusionCallNew     call;
+     FusionCallExecute execute;
+     FusionCallReturn  call_ret;
 
+     switch (_IOC_NR(cmd)) {
           case _IOC_NR(FUSION_CALL_NEW):
                if (copy_from_user (&call, (FusionCallNew*) arg, sizeof(call)))
                     return -EFAULT;
@@ -450,16 +477,22 @@ fusion_ioctl (struct inode *inode, struct file *file,
                     return -EFAULT;
 
                return fusion_call_destroy (dev, fusion_id, id);
+     }
 
+     return -ENOSYS;
+}
 
-          case _IOC_NR(FUSION_KILL):
-               if (copy_from_user (&kill, (FusionKill*) arg, sizeof(kill)))
-                    return -EFAULT;
-
-               return fusionee_kill (dev, fusion_id,
-                                     kill.fusion_id, kill.signal, kill.timeout_ms);
-
+static int
+ref_ioctl (FusionDev *dev, int fusion_id,
+           unsigned int cmd, unsigned long arg)
+{
+     int              id;
+     int              ret;
+     int              refs;
+     FusionRefWatch   watch;
+     FusionRefInherit inherit;
 
+     switch (_IOC_NR(cmd)) {
           case _IOC_NR(FUSION_REF_NEW):
                ret = fusion_ref_new (dev, &id);
                if (ret)
@@ -527,16 +560,32 @@ fusion_ioctl (struct inode *inode, struct file *file,
                if (copy_from_user (&watch, (FusionRefWatch*) arg, sizeof(watch)))
                     return -EFAULT;
 
-               return fusion_ref_watch (dev, watch.id,
-                                        watch.call_id, watch.call_arg);
+               return fusion_ref_watch (dev, watch.id, watch.call_id, watch.call_arg);
+
+          case _IOC_NR(FUSION_REF_INHERIT):
+               if (copy_from_user (&inherit, (FusionRefInherit*) arg, sizeof(inherit)))
+                    return -EFAULT;
+
+               return fusion_ref_inherit (dev, inherit.id, inherit.from);
 
           case _IOC_NR(FUSION_REF_DESTROY):
                if (get_user (id, (int*) arg))
                     return -EFAULT;
 
                return fusion_ref_destroy (dev, id);
+     }
+
+     return -ENOSYS;
+}
 
+static int
+skirmish_ioctl (FusionDev *dev, int fusion_id,
+                unsigned int cmd, unsigned long arg)
+{
+     int id;
+     int ret;
 
+     switch (_IOC_NR(cmd)) {
           case _IOC_NR(FUSION_SKIRMISH_NEW):
                ret = fusion_skirmish_new (dev, &id);
                if (ret)
@@ -571,8 +620,19 @@ fusion_ioctl (struct inode *inode, struct file *file,
                     return -EFAULT;
 
                return fusion_skirmish_destroy (dev, id);
+     }
 
+     return -ENOSYS;
+}
+
+static int
+property_ioctl (FusionDev *dev, int fusion_id,
+                unsigned int cmd, unsigned long arg)
+{
+     int id;
+     int ret;
 
+     switch (_IOC_NR(cmd)) {
           case _IOC_NR(FUSION_PROPERTY_NEW):
                ret = fusion_property_new (dev, &id);
                if (ret)
@@ -613,8 +673,20 @@ fusion_ioctl (struct inode *inode, struct file *file,
                     return -EFAULT;
 
                return fusion_property_destroy (dev, id);
+     }
 
+     return -ENOSYS;
+}
 
+static int
+reactor_ioctl (FusionDev *dev, int fusion_id,
+               unsigned int cmd, unsigned long arg)
+{
+     int                   id;
+     int                   ret;
+     FusionReactorDispatch dispatch;
+
+     switch (_IOC_NR(cmd)) {
           case _IOC_NR(FUSION_REACTOR_NEW):
                ret = fusion_reactor_new (dev, &id);
                if (ret)
@@ -661,7 +733,42 @@ fusion_ioctl (struct inode *inode, struct file *file,
                return fusion_reactor_destroy (dev, id);
      }
 
-     return -ENOTTY;
+     return -ENOSYS;
+}
+
+static int
+fusion_ioctl (struct inode *inode, struct file *file,
+              unsigned int cmd, unsigned long arg)
+{
+     int        id  = (int) file->private_data;
+     FusionDev *dev = fusion_devs[MINOR(inode->i_rdev)];
+
+     DEBUG( "fusion_ioctl (0x%08x)\n", cmd );
+
+     switch (_IOC_TYPE(cmd)) {
+          case FT_LOUNGE:
+               return lounge_ioctl( dev, id, cmd, arg );
+
+          case FT_MESSAGING:
+               return messaging_ioctl( dev, id, cmd, arg );
+
+          case FT_CALL:
+               return call_ioctl( dev, id, cmd, arg );
+
+          case FT_REF:
+               return ref_ioctl( dev, id, cmd, arg );
+
+          case FT_SKIRMISH:
+               return skirmish_ioctl( dev, id, cmd, arg );
+
+          case FT_PROPERTY:
+               return property_ioctl( dev, id, cmd, arg );
+
+          case FT_REACTOR:
+               return reactor_ioctl( dev, id, cmd, arg );
+     }
+
+     return -ENOSYS;
 }
 
 static struct file_operations fusion_fops = {
diff --git a/drivers/char/fusion/ref.c b/drivers/char/fusion/ref.c
index 85e0163..867da9b 100644
--- a/drivers/char/fusion/ref.c
+++ b/drivers/char/fusion/ref.c
@@ -26,6 +26,8 @@
 #include "call.h"
 #include "ref.h"
 
+typedef struct __Fusion_FusionRef FusionRef;
+
 typedef struct {
      FusionLink  link;
      int         fusion_id;
@@ -33,6 +35,11 @@ typedef struct {
 } LocalRef;
 
 typedef struct {
+     FusionLink  link;
+     FusionRef  *ref;
+} Inheritor;
+
+struct __Fusion_FusionRef {
      FusionLink         link;
 
      struct semaphore   lock;
@@ -49,22 +56,31 @@ typedef struct {
      int                call_id;   /* id of call registered with a watch */
      int                call_arg;  /* optional call parameter */
 
+     FusionRef         *inherited;
+     FusionLink        *inheritors;
+
      FusionLink        *local_refs;
 
      wait_queue_head_t  wait;
-} FusionRef;
+};
 
 /******************************************************************************/
 
-static int  lookup_ref (FusionDev *dev, int id, FusionRef **ret_ref);
-static int  lock_ref   (FusionDev *dev, int id, FusionRef **ret_ref);
+static int  lookup_ref (FusionDev *dev, bool locked, int id, FusionRef **ret_ref);
+static int  lock_ref   (FusionDev *dev, bool locked, int id, FusionRef **ret_ref);
 static void unlock_ref (FusionRef *ref);
 
-static int  add_local      (FusionRef *ref, int fusion_id, int add);
-static void clear_local    (FusionDev *dev, FusionRef *ref, int fusion_id);
-static void free_all_local (FusionRef *ref);
+static int  add_local       (FusionRef *ref, int fusion_id, int add);
+static void clear_local     (FusionDev *dev, FusionRef *ref, int fusion_id);
+static void free_all_local  (FusionRef *ref);
+
+static int  propagate_local (FusionDev *dev, FusionRef *ref, int diff);
 
-static void notify_ref     (FusionDev *dev, FusionRef *ref);
+static void notify_ref      (FusionDev *dev, FusionRef *ref);
+
+static int  add_inheritor   (FusionRef *ref, FusionRef *from);
+static void remove_inheritor(FusionRef *ref, FusionRef *from);
+static void drop_inheritors (FusionDev *dev, FusionRef *ref);
 
 /******************************************************************************/
 
@@ -186,34 +202,38 @@ fusion_ref_up (FusionDev *dev, int id, int fusion_id)
      int        ret;
      FusionRef *ref;
 
-     ret = lock_ref (dev, id, &ref);
+     ret = lookup_ref (dev, false, id, &ref);
      if (ret)
           return ret;
 
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
      dev->stat.ref_up++;
 
      if (ref->locked) {
-          unlock_ref (ref);
-          return -EAGAIN;
+          ret = -EAGAIN;
+          goto out;
      }
 
      if (fusion_id) {
-          int ret;
-
           ret = add_local (ref, fusion_id, 1);
-          if (ret) {
-               unlock_ref (ref);
-               return ret;
-          }
+          if (ret)
+               goto out;
 
-          ref->local++;
+          ret = propagate_local( dev, ref, 1 );
      }
      else
           ref->global++;
 
+
+out:
+     up (&dev->ref.lock);
      unlock_ref (ref);
 
-     return 0;
+     return ret;
 }
 
 int
@@ -222,44 +242,51 @@ fusion_ref_down (FusionDev *dev, int id, int fusion_id)
      int        ret;
      FusionRef *ref;
 
-     ret = lock_ref (dev, id, &ref);
+     ret = lookup_ref (dev, false, id, &ref);
      if (ret)
           return ret;
 
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
      dev->stat.ref_down++;
 
      if (ref->locked) {
-          unlock_ref (ref);
-          return -EAGAIN;
+          ret = -EAGAIN;
+          goto out;
      }
 
      if (fusion_id) {
-          int ret;
-
+          ret = -EIO;
           if (!ref->local)
-               return -EIO;
+               goto out;
 
           ret = add_local (ref, fusion_id, -1);
-          if (ret) {
-               unlock_ref (ref);
-               return ret;
-          }
+          if (ret)
+               goto out;
 
-          ref->local--;
+          ret = propagate_local( dev, ref, -1 );
      }
      else {
-          if (!ref->global)
-               return -EIO;
+          if (!ref->global) {
+               ret = -EIO;
+               goto out;
+          }
 
           ref->global--;
+
+          if (ref->local + ref->global == 0)
+               notify_ref (dev, ref);
      }
 
-     if (ref->local + ref->global == 0)
-          notify_ref (dev, ref);
 
+out:
+     up (&dev->ref.lock);
      unlock_ref (ref);
 
-     return 0;
+     return ret;
 }
 
 int
@@ -269,7 +296,7 @@ fusion_ref_zero_lock (FusionDev *dev, int id, int fusion_id)
      FusionRef *ref;
 
      while (true) {
-          ret = lock_ref (dev, id, &ref);
+          ret = lock_ref (dev, false, id, &ref);
           if (ret)
                return ret;
 
@@ -306,7 +333,7 @@ fusion_ref_zero_trylock (FusionDev *dev, int id, int fusion_id)
      int        ret;
      FusionRef *ref;
 
-     ret = lock_ref (dev, id, &ref);
+     ret = lock_ref (dev, false, id, &ref);
      if (ret)
           return ret;
 
@@ -331,7 +358,7 @@ fusion_ref_unlock (FusionDev *dev, int id, int fusion_id)
      int        ret;
      FusionRef *ref;
 
-     ret = lock_ref (dev, id, &ref);
+     ret = lock_ref (dev, false, id, &ref);
      if (ret)
           return ret;
 
@@ -353,7 +380,7 @@ fusion_ref_stat (FusionDev *dev, int id, int *refs)
      int        ret;
      FusionRef *ref;
 
-     ret = lock_ref (dev, id, &ref);
+     ret = lock_ref (dev, false, id, &ref);
      if (ret)
           return ret;
 
@@ -373,7 +400,7 @@ fusion_ref_watch (FusionDev      *dev,
      int        ret;
      FusionRef *ref;
 
-     ret = lock_ref (dev, id, &ref);
+     ret = lock_ref (dev, false, id, &ref);
      if (ret)
           return ret;
 
@@ -404,12 +431,59 @@ fusion_ref_watch (FusionDev      *dev,
 }
 
 int
+fusion_ref_inherit (FusionDev *dev,
+                    int        id,
+                    int        from_id)
+{
+     int        ret;
+     FusionRef *ref;
+     FusionRef *from = NULL;
+
+     ret = lookup_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
+     ret = -EBUSY;
+     if (ref->inherited)
+          goto out;
+
+     ret = lock_ref (dev, true, from_id, &from);
+     if (ret)
+          goto out;
+
+     ret = add_inheritor( ref, from );
+     if (ret)
+          goto out;
+
+     ret = propagate_local( dev, ref, from->local );
+     if (ret)
+          goto out;
+
+     ref->inherited = from;
+
+out:
+     if (from)
+          unlock_ref (from);
+
+     unlock_ref (ref);
+
+     up (&dev->ref.lock);
+
+     return ret;
+}
+
+int
 fusion_ref_destroy (FusionDev *dev, int id)
 {
      int        ret;
      FusionRef *ref;
 
-     ret = lookup_ref (dev, id, &ref);
+     ret = lookup_ref (dev, false, id, &ref);
      if (ret)
           return ret;
 
@@ -418,6 +492,11 @@ fusion_ref_destroy (FusionDev *dev, int id)
           return -EINTR;
      }
 
+     drop_inheritors( dev, ref );
+
+     if (ref->inherited)
+          remove_inheritor( ref, ref->inherited );
+
      fusion_list_remove (&dev->ref.list, &ref->link);
 
      wake_up_interruptible_all (&ref->wait);
@@ -452,11 +531,11 @@ fusion_ref_clear_all_local (FusionDev *dev, int fusion_id)
 /******************************************************************************/
 
 static int
-lookup_ref (FusionDev *dev, int id, FusionRef **ret_ref)
+lookup_ref (FusionDev *dev, bool locked, int id, FusionRef **ret_ref)
 {
      FusionLink *l;
 
-     if (down_interruptible (&dev->ref.lock))
+     if (!locked && down_interruptible (&dev->ref.lock))
           return -EINTR;
 
      fusion_list_foreach (l, dev->ref.list) {
@@ -468,18 +547,19 @@ lookup_ref (FusionDev *dev, int id, FusionRef **ret_ref)
           }
      }
 
-     up (&dev->ref.lock);
+     if (!locked)
+          up (&dev->ref.lock);
 
      return -EINVAL;
 }
 
 static int
-lock_ref (FusionDev *dev, int id, FusionRef **ret_ref)
+lock_ref (FusionDev *dev, bool locked, int id, FusionRef **ret_ref)
 {
      int         ret;
      FusionRef *ref;
 
-     ret = lookup_ref (dev, id, &ref);
+     ret = lookup_ref (dev, locked, id, &ref);
      if (ret)
           return ret;
 
@@ -487,11 +567,13 @@ lock_ref (FusionDev *dev, int id, FusionRef **ret_ref)
           fusion_list_move_to_front (&dev->ref.list, &ref->link);
 
           if (down_interruptible (&ref->lock)) {
-               up (&dev->ref.lock);
+               if (!locked)
+                    up (&dev->ref.lock);
                return -EINTR;
           }
 
-          up (&dev->ref.lock);
+          if (!locked)
+               up (&dev->ref.lock);
      }
 
      *ret_ref = ref;
@@ -515,6 +597,8 @@ add_local (FusionRef *ref, int fusion_id, int add)
           local = (LocalRef *) l;
 
           if (local->fusion_id == fusion_id) {
+               fusion_list_move_to_front( &ref->local_refs, l );
+
                if (local->refs + add < 0)
                     return -EIO;
 
@@ -549,13 +633,11 @@ clear_local (FusionDev *dev, FusionRef *ref, int fusion_id)
           LocalRef *local = (LocalRef *) l;
 
           if (local->fusion_id == fusion_id) {
-               ref->local -= local->refs;
+               propagate_local( dev, ref, - local->refs );
 
-               if (ref->local + ref->global == 0)
-                    notify_ref (dev, ref);
-
-               fusion_list_remove (&ref->local_refs, l);
+               fusion_list_remove( &ref->local_refs, l );
 
+               kfree (l);
                break;
           }
      }
@@ -595,3 +677,98 @@ notify_ref (FusionDev *dev, FusionRef *ref)
           wake_up_interruptible_all (&ref->wait);
 }
 
+static int
+propagate_local( FusionDev *dev, FusionRef *ref, int diff )
+{
+     FusionLink *l;
+
+     /* Recurse into inheritors. */
+     fusion_list_foreach (l, ref->inheritors) {
+          FusionRef *inheritor = ((Inheritor*) l)->ref;
+
+          if (down_interruptible( &inheritor->lock )) {
+               printk( KERN_ERR "fusion_ref: propagate_local() interrupted!\n" );
+               //return -EINTR;
+          }
+
+          propagate_local( dev, inheritor, diff );
+
+          up( &inheritor->lock );
+     }
+
+     /* Apply difference. */
+     ref->local += diff;
+
+     /* Notify zero count. */
+     if (ref->local + ref->global == 0)
+          notify_ref( dev, ref );
+
+     return 0;
+}
+
+static int
+add_inheritor(FusionRef *ref, FusionRef *from)
+{
+     Inheritor *inheritor;
+
+     inheritor = kmalloc (sizeof(Inheritor), GFP_KERNEL);
+     if (!inheritor)
+          return -ENOMEM;
+
+     inheritor->ref = ref;
+
+     fusion_list_prepend( &from->inheritors, &inheritor->link );
+
+     return 0;
+}
+
+static void
+remove_inheritor(FusionRef *ref, FusionRef *from)
+{
+     FusionLink *l;
+
+     down( &from->lock );
+
+     fusion_list_foreach (l, from->inheritors) {
+          Inheritor *inheritor = (Inheritor*) l;
+
+          if (inheritor->ref == ref) {
+               fusion_list_remove( &from->inheritors, &inheritor->link );
+
+               kfree( l );
+               break;
+          }
+     }
+
+     up( &from->lock );
+}
+
+static void
+drop_inheritors( FusionDev *dev, FusionRef *ref )
+{
+     FusionLink *l = ref->inheritors;
+
+     while (l) {
+          FusionLink *next      = l->next;
+          FusionRef  *inheritor = ((Inheritor*) l)->ref;
+
+          if (down_interruptible( &inheritor->lock )) {
+               printk( KERN_ERR "fusion_ref: drop_inheritors() interrupted!\n" );
+               //return;
+          }
+
+          propagate_local( dev, inheritor, - ref->local );
+
+          inheritor->inherited = NULL;
+
+          up( &inheritor->lock );
+
+
+          kfree (l);
+
+          l = next;
+     }
+
+     ref->inheritors = NULL;
+}
+
diff --git a/drivers/char/fusion/ref.h b/drivers/char/fusion/ref.h
index 5ac05df..93ca0cf 100644
--- a/drivers/char/fusion/ref.h
+++ b/drivers/char/fusion/ref.h
@@ -11,7 +11,7 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  */
- 
+
 #ifndef __FUSION__REF_H__
 #define __FUSION__REF_H__
 
@@ -59,6 +59,10 @@ int fusion_ref_watch        (FusionDev      *dev,
                              int             call_id,
                              int             call_arg);
 
+int fusion_ref_inherit      (FusionDev      *dev,
+                             int             id,
+                             int             from);
+
 int fusion_ref_destroy      (FusionDev      *dev,
                              int             id);
 
diff --git a/include/linux/fusion.h b/include/linux/fusion.h
index 8962fd4..c60da3d 100644
--- a/include/linux/fusion.h
+++ b/include/linux/fusion.h
@@ -87,7 +87,7 @@ typedef struct {
  * reference count reaches zero. Currently one watch per reference is allowed.
  *
  * The call is made by Fusion and therefor has a caller id of zero.
- * 
+ *
  */
 typedef struct {
      int                id;        /* id of the reference to watch */
@@ -99,6 +99,14 @@ typedef struct {
 } FusionRefWatch;
 
 /*
+ * Inheriting local count from other reference
+ */
+typedef struct {
+     int                id;        /* own reference id */
+     int                from;      /* id of the reference to inherit from */
+} FusionRefInherit;
+
+/*
  * Killing other fusionees (experimental)
  */
 typedef struct {
@@ -108,47 +116,69 @@ typedef struct {
                           max. time to wait until the fusionee(s) terminated */
 } FusionKill;
 
+#define FUSION_API_MAJOR   1  /* Increased if backward compatibility is dropped. */
+#define FUSION_API_MINOR   0  /* Increased if new features are added. */
 
-#define FUSION_GET_ID                   _IOR('F', 0x00, int)
-
-#define FUSION_SEND_MESSAGE             _IOW('F', 0x01, FusionSendMessage)
-
-#define FUSION_CALL_NEW                 _IOW('F', 0x02, FusionCallNew)
-#define FUSION_CALL_EXECUTE             _IOW('F', 0x03, FusionCallExecute)
-#define FUSION_CALL_RETURN              _IOW('F', 0x04, FusionCallReturn)
-#define FUSION_CALL_DESTROY             _IOW('F', 0x05, int)
-
-#define FUSION_KILL                     _IOW('F', 0x06, FusionKill)
-
-#define FUSION_REF_NEW                  _IOW('F', 0x07, int)
-#define FUSION_REF_UP                   _IOW('F', 0x08, int)
-#define FUSION_REF_UP_GLOBAL            _IOW('F', 0x09, int)
-#define FUSION_REF_DOWN                 _IOW('F', 0x0A, int)
-#define FUSION_REF_DOWN_GLOBAL          _IOW('F', 0x0B, int)
-#define FUSION_REF_ZERO_LOCK            _IOW('F', 0x0C, int)
-#define FUSION_REF_ZERO_TRYLOCK         _IOW('F', 0x0D, int)
-#define FUSION_REF_UNLOCK               _IOW('F', 0x0E, int)
-#define FUSION_REF_STAT                 _IOW('F', 0x0F, int)
-#define FUSION_REF_WATCH                _IOW('F', 0x10, FusionRefWatch)
-#define FUSION_REF_DESTROY              _IOW('F', 0x11, int)
-
-#define FUSION_SKIRMISH_NEW             _IOW('F', 0x12, int)
-#define FUSION_SKIRMISH_PREVAIL         _IOW('F', 0x13, int)
-#define FUSION_SKIRMISH_SWOOP           _IOW('F', 0x14, int)
-#define FUSION_SKIRMISH_DISMISS         _IOW('F', 0x15, int)
-#define FUSION_SKIRMISH_DESTROY         _IOW('F', 0x16, int)
-
-#define FUSION_PROPERTY_NEW             _IOW('F', 0x17, int)
-#define FUSION_PROPERTY_LEASE           _IOW('F', 0x18, int)
-#define FUSION_PROPERTY_PURCHASE        _IOW('F', 0x19, int)
-#define FUSION_PROPERTY_CEDE            _IOW('F', 0x1A, int)
-#define FUSION_PROPERTY_HOLDUP          _IOW('F', 0x1B, int)
-#define FUSION_PROPERTY_DESTROY         _IOW('F', 0x1C, int)
-
-#define FUSION_REACTOR_NEW              _IOW('F', 0x1D, int)
-#define FUSION_REACTOR_ATTACH           _IOW('F', 0x1E, int)
-#define FUSION_REACTOR_DETACH           _IOW('F', 0x1F, int)
-#define FUSION_REACTOR_DISPATCH         _IOW('F', 0x20, FusionReactorDispatch)
-#define FUSION_REACTOR_DESTROY          _IOW('F', 0x21, int)
+typedef struct {
+     struct {
+          int major;
+          int minor;
+     } api;
+
+     int fusion_id;
+} FusionEnter;
+
+typedef enum {
+     FT_LOUNGE,
+     FT_MESSAGING,
+     FT_CALL,
+     FT_REF,
+     FT_SKIRMISH,
+     FT_PROPERTY,
+     FT_REACTOR
+} FusionType;
+
+
+#define FUSION_ENTER               _IOR(FT_LOUNGE,    0x00, FusionEnter)
+#define FUSION_KILL                _IOW(FT_LOUNGE,    0x01, FusionKill)
+
+#define FUSION_SEND_MESSAGE        _IOW(FT_MESSAGING, 0x00, FusionSendMessage)
+
+#define FUSION_CALL_NEW            _IOW(FT_CALL,      0x00, FusionCallNew)
+#define FUSION_CALL_EXECUTE        _IOW(FT_CALL,      0x01, FusionCallExecute)
+#define FUSION_CALL_RETURN         _IOW(FT_CALL,      0x02, FusionCallReturn)
+#define FUSION_CALL_DESTROY        _IOW(FT_CALL,      0x03, int)
+
+#define FUSION_REF_NEW             _IOW(FT_REF,       0x00, int)
+#define FUSION_REF_UP              _IOW(FT_REF,       0x01, int)
+#define FUSION_REF_UP_GLOBAL       _IOW(FT_REF,       0x02, int)
+#define FUSION_REF_DOWN            _IOW(FT_REF,       0x03, int)
+#define FUSION_REF_DOWN_GLOBAL     _IOW(FT_REF,       0x04, int)
+#define FUSION_REF_ZERO_LOCK       _IOW(FT_REF,       0x05, int)
+#define FUSION_REF_ZERO_TRYLOCK    _IOW(FT_REF,       0x06, int)
+#define FUSION_REF_UNLOCK          _IOW(FT_REF,       0x07, int)
+#define FUSION_REF_STAT            _IOW(FT_REF,       0x08, int)
+#define FUSION_REF_WATCH           _IOW(FT_REF,       0x09, FusionRefWatch)
+#define FUSION_REF_INHERIT         _IOW(FT_REF,       0x0A, FusionRefInherit)
+#define FUSION_REF_DESTROY         _IOW(FT_REF,       0x0B, int)
+
+#define FUSION_SKIRMISH_NEW        _IOW(FT_SKIRMISH,  0x00, int)
+#define FUSION_SKIRMISH_PREVAIL    _IOW(FT_SKIRMISH,  0x01, int)
+#define FUSION_SKIRMISH_SWOOP      _IOW(FT_SKIRMISH,  0x02, int)
+#define FUSION_SKIRMISH_DISMISS    _IOW(FT_SKIRMISH,  0x03, int)
+#define FUSION_SKIRMISH_DESTROY    _IOW(FT_SKIRMISH,  0x04, int)
+
+#define FUSION_PROPERTY_NEW        _IOW(FT_PROPERTY,  0x00, int)
+#define FUSION_PROPERTY_LEASE      _IOW(FT_PROPERTY,  0x01, int)
+#define FUSION_PROPERTY_PURCHASE   _IOW(FT_PROPERTY,  0x02, int)
+#define FUSION_PROPERTY_CEDE       _IOW(FT_PROPERTY,  0x03, int)
+#define FUSION_PROPERTY_HOLDUP     _IOW(FT_PROPERTY,  0x04, int)
+#define FUSION_PROPERTY_DESTROY    _IOW(FT_PROPERTY,  0x05, int)
+
+#define FUSION_REACTOR_NEW         _IOW(FT_REACTOR,   0x00, int)
+#define FUSION_REACTOR_ATTACH      _IOW(FT_REACTOR,   0x01, int)
+#define FUSION_REACTOR_DETACH      _IOW(FT_REACTOR,   0x02, int)
+#define FUSION_REACTOR_DISPATCH    _IOW(FT_REACTOR,   0x03, FusionReactorDispatch)
+#define FUSION_REACTOR_DESTROY     _IOW(FT_REACTOR,   0x04, int)
 
 #endif
-- 
1.7.3.3

