From 26744d47325e68fc546ce95ec25a8a8ba8cb37a6 Mon Sep 17 00:00:00 2001
From: Denis Oliver Kropp <dok@directfb.org>
Date: Mon, 16 Jun 2003 17:47:03 +0000
Subject: [PATCH] Added support for multiple Fusion "worlds" via device minor.

New directory layout is
	mkdir /dev/fusion
	mknod /dev/fusion/0 c 253 0
	mknod /dev/fusion/1 c 253 1
	...currently limited to eight minors

The /proc directory layout also changed this way.

Updated all patches.
---
 drivers/char/fusion/call.c      |  477 ++++++++++++-------------
 drivers/char/fusion/call.h      |   30 ++-
 drivers/char/fusion/fifo.c      |   38 +-
 drivers/char/fusion/fifo.h      |   10 +-
 drivers/char/fusion/fusiondev.c |  749 ++++++++++++++++++++++-----------------
 drivers/char/fusion/fusiondev.h |   53 +++-
 drivers/char/fusion/fusionee.c  |  613 +++++++++++++++-----------------
 drivers/char/fusion/fusionee.h  |   41 ++-
 drivers/char/fusion/list.c      |   20 +-
 drivers/char/fusion/list.h      |    9 +-
 drivers/char/fusion/property.c  |  507 +++++++++++++--------------
 drivers/char/fusion/property.h  |   38 ++-
 drivers/char/fusion/reactor.c   |  416 ++++++++++------------
 drivers/char/fusion/reactor.h   |   36 ++-
 drivers/char/fusion/ref.c       |  580 ++++++++++++++----------------
 drivers/char/fusion/ref.h       |   48 ++-
 drivers/char/fusion/skirmish.c  |  405 ++++++++++-----------
 drivers/char/fusion/skirmish.h  |   33 ++-
 18 files changed, 2067 insertions(+), 2036 deletions(-)

diff --git a/drivers/char/fusion/call.c b/drivers/char/fusion/call.c
index 5221b58..3f02d37 100644
--- a/drivers/char/fusion/call.c
+++ b/drivers/char/fusion/call.c
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -11,7 +11,7 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  */
- 
+
 #include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
@@ -27,41 +27,41 @@
 #include "call.h"
 
 typedef struct {
-  FusionLink        link;
+     FusionLink        link;
 
-  int               caller;
+     int               caller;
 
-  int               ret_val;
+     int               ret_val;
 
-  bool              executed;
+     bool              executed;
 
-  wait_queue_head_t wait;
+     wait_queue_head_t wait;
 } FusionCallExecution;
 
 typedef struct {
-  FusionLink         link;
+     FusionLink         link;
 
-  spinlock_t         lock;
+     spinlock_t         lock;
 
-  int                id;        /* call id */
+     int                id;        /* call id */
 
-  int                pid;       /* owner pid */
-  int                fusion_id; /* owner fusion id */
+     int                pid;       /* owner pid */
+     int                fusion_id; /* owner fusion id */
 
-  FusionCallHandler  handler;
-  void              *ctx;
+     FusionCallHandler  handler;
+     void              *ctx;
 
-  FusionLink          *executions;      /* prepending! */
-  FusionCallExecution *next;            /* points to the last item of executions */
+     FusionLink          *executions;      /* prepending! */
+     FusionCallExecution *next;            /* points to the last item of executions */
 
-  int                count;    /* number of calls ever made */
+     int                count;    /* number of calls ever made */
 } FusionCall;
 
 /******************************************************************************/
 
-static FusionCall *lookup_call (int id);
+static FusionCall *lookup_call (FusionDev *dev, int id);
 
-static FusionCall *lock_call   (int id);
+static FusionCall *lock_call   (FusionDev *dev, int id);
 static void        unlock_call (FusionCall *call);
 
 static FusionCallExecution *add_execution       (FusionCall          *call,
@@ -73,326 +73,302 @@ static void                 free_all_executions (FusionCall          *call);
 
 /******************************************************************************/
 
-static int         ids        = 0;
-static FusionLink *calls      = NULL;
-static spinlock_t  calls_lock = SPIN_LOCK_UNLOCKED;
-
-/******************************************************************************/
-
 static int
 fusion_call_read_proc (char *buf, char **start, off_t offset,
                        int len, int *eof, void *private)
 {
-  FusionLink *l;
-  int written = 0;
-
-  spin_lock (&calls_lock);
-
-  fusion_list_foreach (l, calls)
-    {
-      FusionCall *call = (FusionCall*) l;
-
-      written += sprintf(buf+written,
-                         "(%5d) 0x%08x (%d calls) %s\n",
-                         call->pid, call->id, call->count,
-                         call->next ? "executing" : "idle");
-
-      if (written < offset)
-        {
-          offset -= written;
-          written = 0;
-        }
-
-      if (written >= len)
-        break;
-    }
-
-  spin_unlock (&calls_lock);
-
-  *start = buf + offset;
-  written -= offset;
-  if(written > len)
-    {
-      *eof = 0;
-      return len;
-    }
-
-  *eof = 1;
-  return (written<0) ? 0 : written;
-}
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
 
-int
-fusion_call_init()
-{
-  create_proc_read_entry("calls", 0, proc_fusion_dir,
-                         fusion_call_read_proc, NULL);
+     spin_lock (&dev->call.lock);
 
-  return 0;
-}
+     fusion_list_foreach (l, dev->call.list) {
+          FusionCall *call = (FusionCall*) l;
 
-void
-fusion_call_reset()
-{
-  FusionLink *l;
+          written += sprintf(buf+written,
+                             "(%5d) 0x%08x (%d calls) %s\n",
+                             call->pid, call->id, call->count,
+                             call->next ? "executing" : "idle");
 
-  spin_lock (&calls_lock);
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
 
-  l = calls;
-  while (l)
-    {
-      FusionLink *next = l->next;
-      FusionCall *call = (FusionCall *) l;
+          if (written >= len)
+               break;
+     }
 
-      free_all_executions (call);
+     spin_unlock (&dev->call.lock);
 
-      kfree (call);
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
 
-      l = next;
-    }
+     *eof = 1;
+     return(written<0) ? 0 : written;
+}
+
+int
+fusion_call_init (FusionDev *dev)
+{
+     create_proc_read_entry("calls", 0, dev->proc_dir,
+                            fusion_call_read_proc, dev);
 
-  ids   = 0;
-  calls = NULL;
+     dev->call.lock = SPIN_LOCK_UNLOCKED;
 
-  spin_unlock (&calls_lock);
+     return 0;
 }
 
 void
-fusion_call_cleanup()
+fusion_call_deinit (FusionDev *dev)
 {
-  fusion_call_reset();
+     FusionLink *l;
 
-  remove_proc_entry ("calls", proc_fusion_dir);
+     spin_lock (&dev->call.lock);
+
+     remove_proc_entry ("calls", dev->proc_dir);
+     
+     l = dev->call.list;
+     while (l) {
+          FusionLink *next = l->next;
+          FusionCall *call = (FusionCall *) l;
+
+          free_all_executions (call);
+
+          kfree (call);
+
+          l = next;
+     }
+
+     spin_unlock (&dev->call.lock);
 }
 
 /******************************************************************************/
 
 int
-fusion_call_new (int fusion_id, FusionCallNew *call_new)
+fusion_call_new (FusionDev *dev, int fusion_id, FusionCallNew *call_new)
 {
-  FusionCall *call;
+     FusionCall *call;
 
-  call = kmalloc (sizeof(FusionCall), GFP_ATOMIC);
-  if (!call)
-    return -ENOMEM;
+     call = kmalloc (sizeof(FusionCall), GFP_ATOMIC);
+     if (!call)
+          return -ENOMEM;
 
-  memset (call, 0, sizeof(FusionCall));
+     memset (call, 0, sizeof(FusionCall));
 
-  spin_lock (&calls_lock);
+     spin_lock (&dev->call.lock);
 
-  call->id        = ids++;
-  call->pid       = current->pid;
-  call->fusion_id = fusion_id;
-  call->lock      = SPIN_LOCK_UNLOCKED;
+     call->id        = dev->call.ids++;
+     call->pid       = current->pid;
+     call->fusion_id = fusion_id;
+     call->lock      = SPIN_LOCK_UNLOCKED;
 
-  call->handler   = call_new->handler;
-  call->ctx       = call_new->ctx;
+     call->handler   = call_new->handler;
+     call->ctx       = call_new->ctx;
 
-  fusion_list_prepend (&calls, &call->link);
+     fusion_list_prepend (&dev->call.list, &call->link);
 
-  spin_unlock (&calls_lock);
+     spin_unlock (&dev->call.lock);
 
-  call_new->call_id = call->id;
+     call_new->call_id = call->id;
 
-  return 0;
+     return 0;
 }
 
 int
-fusion_call_execute (int fusion_id, FusionCallExecute *execute)
+fusion_call_execute (FusionDev *dev, int fusion_id, FusionCallExecute *execute)
 {
-  int                  ret;
-  FusionCall          *call;
-  FusionCallExecution *execution;
-  FusionCallMessage    message;
+     int                  ret;
+     FusionCall          *call;
+     FusionCallExecution *execution;
+     FusionCallMessage    message;
 
-  call = lock_call (execute->call_id);
-  if (!call)
-    return -EINVAL;
+     call = lock_call (dev, execute->call_id);
+     if (!call)
+          return -EINVAL;
 
-  execution = add_execution (call, fusion_id, execute);
-  if (!execution)
-    {
-      unlock_call (call);
-      return -ENOMEM;
-    }
-  
-  /* Send call message. */
-  message.handler  = call->handler;
-  message.ctx      = call->ctx;
+     execution = add_execution (call, fusion_id, execute);
+     if (!execution) {
+          unlock_call (call);
+          return -ENOMEM;
+     }
 
-  message.caller   = execution->caller;
+     /* Send call message. */
+     message.handler  = call->handler;
+     message.ctx      = call->ctx;
 
-  message.call_arg = execute->call_arg;
-  message.call_ptr = execute->call_ptr;
+     message.caller   = execution->caller;
 
-  ret = fusionee_send_message (fusion_id, call->fusion_id, FMT_CALL,
-                               call->id, sizeof(message), &message);
-  if (ret)
-    {
-      remove_execution (call, execution);
-      unlock_call (call);
-      return ret;
-    }
+     message.call_arg = execute->call_arg;
+     message.call_ptr = execute->call_ptr;
 
-  call->count++;
+     ret = fusionee_send_message (dev, fusion_id, call->fusion_id, FMT_CALL,
+                                  call->id, sizeof(message), &message);
+     if (ret) {
+          remove_execution (call, execution);
+          unlock_call (call);
+          return ret;
+     }
 
-  /* TODO: implement timeout */
-  fusion_sleep_on (&execution->wait, &call->lock, 0);
-      
-  call = lock_call (execute->call_id);
-  if (!call)
-    return -EIDRM;
+     call->count++;
 
-  execute->ret_val = execution->ret_val;
+     /* TODO: implement timeout */
+     fusion_sleep_on (&execution->wait, &call->lock, 0);
 
-  remove_execution (call, execution);
+     call = lock_call (dev, execute->call_id);
+     if (!call)
+          return -EIDRM;
 
-  kfree (execution);
+     execute->ret_val = execution->ret_val;
 
-  if (signal_pending(current))
-    ret = -ERESTARTSYS;
+     remove_execution (call, execution);
 
-  unlock_call (call);
+     kfree (execution);
 
-  return 0;
+     if (signal_pending(current))
+          ret = -ERESTARTSYS;
+
+     unlock_call (call);
+
+     return 0;
 }
 
 int
-fusion_call_return (int fusion_id, FusionCallReturn *call_ret)
+fusion_call_return (FusionDev *dev, int fusion_id, FusionCallReturn *call_ret)
 {
-  FusionLink *l;
-  FusionCall *call = lock_call (call_ret->call_id);
+     FusionLink *l;
+     FusionCall *call = lock_call (dev, call_ret->call_id);
 
-  if (!call)
-    return -EINVAL;
+     if (!call)
+          return -EINVAL;
 
-  fusion_list_foreach (l, call->executions)
-    {
-      FusionCallExecution *execution = (FusionCallExecution*) l;
+     fusion_list_foreach (l, call->executions) {
+          FusionCallExecution *execution = (FusionCallExecution*) l;
 
-      if (execution->executed)
-        continue;
+          if (execution->executed)
+               continue;
 
-      execution->ret_val  = call_ret->val;
-      execution->executed = true;
+          execution->ret_val  = call_ret->val;
+          execution->executed = true;
 
-      wake_up_interruptible_all (&execution->wait);
+          wake_up_interruptible_all (&execution->wait);
 
-      unlock_call (call);
+          unlock_call (call);
 
-      return 0;
-    }
+          return 0;
+     }
 
-  unlock_call (call);
+     unlock_call (call);
 
-  return -EIO;
+     return -EIO;
 }
 
 int
-fusion_call_destroy (int fusion_id, int call_id)
+fusion_call_destroy (FusionDev *dev, int fusion_id, int call_id)
 {
-  FusionCall *call = lookup_call (call_id);
+     FusionCall *call = lookup_call (dev, call_id);
+
+     if (!call)
+          return -EINVAL;
 
-  if (!call)
-    return -EINVAL;
+     if (call->fusion_id != fusion_id) {
+          spin_unlock (&dev->call.lock);
+          return -EIO;
+     }
 
-  if (call->fusion_id != fusion_id)
-    {
-      spin_unlock (&calls_lock);
-      return -EIO;
-    }
+     spin_lock (&call->lock);
 
-  spin_lock (&call->lock);
+     fusion_list_remove (&dev->call.list, &call->link);
 
-  fusion_list_remove (&calls, &call->link);
+     free_all_executions (call);
 
-  free_all_executions (call);
+     spin_unlock (&dev->call.lock);
 
-  spin_unlock (&calls_lock);
+     spin_unlock (&call->lock);
 
-  spin_unlock (&call->lock);
-  
-  kfree (call);
+     kfree (call);
 
-  return 0;
+     return 0;
 }
 
 void
-fusion_call_destroy_all (int fusion_id)
+fusion_call_destroy_all (FusionDev *dev, int fusion_id)
 {
-  FusionLink *l;
+     FusionLink *l;
 
-  spin_lock (&calls_lock);
+     spin_lock (&dev->call.lock);
 
-  l = calls;
+     l = dev->call.list;
 
-  while (l)
-    {
-      FusionLink *next = l->next;
-      FusionCall *call = (FusionCall *) l;
+     while (l) {
+          FusionLink *next = l->next;
+          FusionCall *call = (FusionCall *) l;
 
-      spin_lock (&call->lock);
+          spin_lock (&call->lock);
 
-      if (call->fusion_id == fusion_id)
-        {
-          free_all_executions (call);
+          if (call->fusion_id == fusion_id) {
+               free_all_executions (call);
 
-          fusion_list_remove (&calls, &call->link);
+               fusion_list_remove (&dev->call.list, &call->link);
 
-          spin_unlock (&call->lock);
-          
-          kfree (call);
-        }
-      else
-        spin_unlock (&call->lock);
+               spin_unlock (&call->lock);
+
+               kfree (call);
+          }
+          else
+               spin_unlock (&call->lock);
 
-      l = next;
-    }
+          l = next;
+     }
 
-  spin_unlock (&calls_lock);
+     spin_unlock (&dev->call.lock);
 }
 
 /******************************************************************************/
 
 static FusionCall *
-lookup_call (int id)
+lookup_call (FusionDev *dev, int id)
 {
-  FusionLink *l;
+     FusionLink *l;
 
-  spin_lock (&calls_lock);
+     spin_lock (&dev->call.lock);
 
-  fusion_list_foreach (l, calls)
-    {
-      FusionCall *call = (FusionCall *) l;
+     fusion_list_foreach (l, dev->call.list) {
+          FusionCall *call = (FusionCall *) l;
 
-      if (call->id == id)
-        return call;
-    }
+          if (call->id == id)
+               return call;
+     }
 
-  spin_unlock (&calls_lock);
+     spin_unlock (&dev->call.lock);
 
-  return NULL;
+     return NULL;
 }
 
 static FusionCall *
-lock_call (int id)
+lock_call (FusionDev *dev, int id)
 {
-  FusionCall *call = lookup_call (id);
+     FusionCall *call = lookup_call (dev, id);
 
-  if (call)
-    {
-      fusion_list_move_to_front (&calls, &call->link);
+     if (call) {
+          fusion_list_move_to_front (&dev->call.list, &call->link);
 
-      spin_lock (&call->lock);
-      spin_unlock (&calls_lock);
-    }
+          spin_lock (&call->lock);
+          spin_unlock (&dev->call.lock);
+     }
 
-  return call;
+     return call;
 }
 
 static void
 unlock_call (FusionCall *call)
 {
-  spin_unlock (&call->lock);
+     spin_unlock (&call->lock);
 }
 
 static FusionCallExecution *
@@ -400,50 +376,49 @@ add_execution (FusionCall        *call,
                int                fusion_id,
                FusionCallExecute *execute)
 {
-  FusionCallExecution *execution;
+     FusionCallExecution *execution;
 
-  /* Allocate execution. */
-  execution = kmalloc (sizeof(FusionCallExecution), GFP_ATOMIC);
-  if (!execution)
-    return NULL;
+     /* Allocate execution. */
+     execution = kmalloc (sizeof(FusionCallExecution), GFP_ATOMIC);
+     if (!execution)
+          return NULL;
 
-  /* Initialize execution. */
-  memset (execution, 0, sizeof(FusionCallExecution));
+     /* Initialize execution. */
+     memset (execution, 0, sizeof(FusionCallExecution));
 
-  execution->caller = fusion_id;
+     execution->caller = fusion_id;
 
-  init_waitqueue_head (&execution->wait);
+     init_waitqueue_head (&execution->wait);
 
-  /* Add execution. */
-  fusion_list_prepend (&call->executions, &execution->link);
+     /* Add execution. */
+     fusion_list_prepend (&call->executions, &execution->link);
 
-  if (!call->next)
-    call->next = execution;
+     if (!call->next)
+          call->next = execution;
 
-  return execution;
+     return execution;
 }
 
 static void
 remove_execution (FusionCall          *call,
                   FusionCallExecution *execution)
 {
-  if (call->next == execution)
-    call->next = (FusionCallExecution*) execution->link.prev;
+     if (call->next == execution)
+          call->next = (FusionCallExecution*) execution->link.prev;
 
-  fusion_list_remove (&call->executions, &execution->link);
+     fusion_list_remove (&call->executions, &execution->link);
 }
 
 static void
 free_all_executions (FusionCall *call)
 {
-  while (call->next)
-    {
-      FusionCallExecution *execution = call->next;
+     while (call->next) {
+          FusionCallExecution *execution = call->next;
 
-      remove_execution (call, execution);
+          remove_execution (call, execution);
 
-      wake_up_interruptible_all (&execution->wait);
+          wake_up_interruptible_all (&execution->wait);
 
-      kfree (execution);
-    }
+          kfree (execution);
+     }
 }
diff --git a/drivers/char/fusion/call.h b/drivers/char/fusion/call.h
index 33200b1..02e3fcd 100644
--- a/drivers/char/fusion/call.h
+++ b/drivers/char/fusion/call.h
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -17,24 +17,36 @@
 
 #include <linux/fusion.h>
 
+#include "fusiondev.h"
 
 /* module init/cleanup */
 
-int  fusion_call_init (void);
-void fusion_call_reset (void);
-void fusion_call_cleanup (void);
+int  fusion_call_init   (FusionDev *dev);
+void fusion_call_deinit (FusionDev *dev);
 
 
 /* public API */
 
-int fusion_call_new (int fusion_id, FusionCallNew *call);
-int fusion_call_execute (int fusion_id, FusionCallExecute *execute);
-int fusion_call_return (int fusion_id, FusionCallReturn *call_ret);
-int fusion_call_destroy (int fusion_id, int call_id);
+int fusion_call_new     (FusionDev         *dev,
+                         int                fusion_id,
+                         FusionCallNew     *call);
+
+int fusion_call_execute (FusionDev         *dev,
+                         int                fusion_id,
+                         FusionCallExecute *execute);
+
+int fusion_call_return  (FusionDev         *dev,
+                         int                fusion_id,
+                         FusionCallReturn  *call_ret);
+
+int fusion_call_destroy (FusionDev         *dev,
+                         int                fusion_id,
+                         int                call_id);
 
 
 /* internal functions */
 
-void fusion_call_destroy_all (int fusion_id);
+void fusion_call_destroy_all (FusionDev *dev,
+                              int        fusion_id);
 
 #endif
diff --git a/drivers/char/fusion/fifo.c b/drivers/char/fusion/fifo.c
index adc2901..e24d433 100644
--- a/drivers/char/fusion/fifo.c
+++ b/drivers/char/fusion/fifo.c
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -19,35 +19,35 @@
 void
 fusion_fifo_put (FusionFifo *fifo, FusionLink *link)
 {
-  link->prev = fifo->last;
-  link->next = NULL;
+     link->prev = fifo->last;
+     link->next = NULL;
 
-  if (fifo->last)
-    fifo->last->next = link;
-  else
-    fifo->first = link;
+     if (fifo->last)
+          fifo->last->next = link;
+     else
+          fifo->first = link;
 
-  fifo->last = link;
+     fifo->last = link;
 
-  fifo->count++;
+     fifo->count++;
 }
 
 FusionLink *
 fusion_fifo_get (FusionFifo *fifo)
 {
-  FusionLink *first = fifo->first;
+     FusionLink *first = fifo->first;
 
-  if (!first)
-    return NULL;
+     if (!first)
+          return NULL;
 
-  fifo->first = first->next;
+     fifo->first = first->next;
 
-  if (fifo->last == first)
-    fifo->last = NULL;
-  else
-    fifo->first->prev = NULL;
+     if (fifo->last == first)
+          fifo->last = NULL;
+     else
+          fifo->first->prev = NULL;
 
-  fifo->count--;
+     fifo->count--;
 
-  return first;
+     return first;
 }
diff --git a/drivers/char/fusion/fifo.h b/drivers/char/fusion/fifo.h
index f1cb013..6dc1817 100644
--- a/drivers/char/fusion/fifo.h
+++ b/drivers/char/fusion/fifo.h
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -19,10 +19,10 @@
 #include "list.h"
 
 typedef struct {
-  FusionLink *first;
-  FusionLink *last;
+     FusionLink *first;
+     FusionLink *last;
 
-  int         count;
+     int         count;
 } FusionFifo;
 
 void        fusion_fifo_put   (FusionFifo *fifo,
@@ -32,7 +32,5 @@ FusionLink *fusion_fifo_get   (FusionFifo *fifo);
 
 int         fusion_fifo_count (FusionFifo *fifo);
 
-//#define fusion_list_foreach(link, list)  for (link = list; link; link = link->next)
-
 #endif /* __FUSION__LIST_H__ */
 
diff --git a/drivers/char/fusion/fusiondev.c b/drivers/char/fusion/fusiondev.c
index 3062f4b..9af7b5e 100644
--- a/drivers/char/fusion/fusiondev.c
+++ b/drivers/char/fusion/fusiondev.c
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -11,7 +11,7 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  */
- 
+
 #include <linux/version.h>
 #include <linux/module.h>
 #include <linux/config.h>
@@ -19,7 +19,7 @@
 #include <linux/kernel.h>
 #include <linux/fs.h>
 #include <linux/slab.h>
-#include <linux/miscdevice.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/proc_fs.h>
 #include <linux/poll.h>
 #include <linux/init.h>
@@ -37,73 +37,128 @@
 
 #define DEBUG(x...)  printk (KERN_DEBUG "Fusion: " x)
 
-#ifndef FUSION_MINOR
-#define FUSION_MINOR 23
+#ifndef FUSION_MAJOR
+#define FUSION_MAJOR 253
 #endif
 
 MODULE_LICENSE("GPL");
 
 struct proc_dir_entry *proc_fusion_dir;
 
-static int        refs      = 0;
-static spinlock_t refs_lock = SPIN_LOCK_UNLOCKED;
+#define NUM_MINORS 8
+
+static FusionDev  *fusion_devs[NUM_MINORS] = { 0 };
+static spinlock_t  devs_lock               = SPIN_LOCK_UNLOCKED;
+
+static devfs_handle_t devfs_handles[NUM_MINORS];
 
 /******************************************************************************/
 
 void
 fusion_sleep_on(wait_queue_head_t *q, spinlock_t *lock, signed long *timeout)
 {
-  unsigned long flags;
-  wait_queue_t  wait;
-  
-  init_waitqueue_entry (&wait, current);
+     unsigned long flags;
+     wait_queue_t  wait;
+
+     init_waitqueue_entry (&wait, current);
 
-  current->state = TASK_INTERRUPTIBLE;
+     current->state = TASK_INTERRUPTIBLE;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
-  write_lock_irqsave (&q->lock,flags);
-  __add_wait_queue (q, &wait);
-  write_unlock (&q->lock);
+     write_lock_irqsave (&q->lock,flags);
+     __add_wait_queue (q, &wait);
+     write_unlock (&q->lock);
 
-  spin_unlock (lock);
+     spin_unlock (lock);
 
-  if (timeout)
-       *timeout = schedule_timeout(*timeout);
-  else
-       schedule();
+     if (timeout)
+          *timeout = schedule_timeout(*timeout);
+     else
+          schedule();
 
-  write_lock_irq (&q->lock);
-  __remove_wait_queue (q, &wait);
-  write_unlock_irqrestore (&q->lock,flags);
+     write_lock_irq (&q->lock);
+     __remove_wait_queue (q, &wait);
+     write_unlock_irqrestore (&q->lock,flags);
 #else
-  wq_write_lock_irqsave (&q->lock,flags);
-  __add_wait_queue (q, &wait);
-  wq_write_unlock (&q->lock);
+     wq_write_lock_irqsave (&q->lock,flags);
+     __add_wait_queue (q, &wait);
+     wq_write_unlock (&q->lock);
 
-  spin_unlock (lock);
+     spin_unlock (lock);
 
-  if (timeout)
-       *timeout = schedule_timeout(*timeout);
-  else
-       schedule();
+     if (timeout)
+          *timeout = schedule_timeout(*timeout);
+     else
+          schedule();
 
-  wq_write_lock_irq (&q->lock);
-  __remove_wait_queue (q, &wait);
-  wq_write_unlock_irqrestore (&q->lock,flags);
+     wq_write_lock_irq (&q->lock);
+     __remove_wait_queue (q, &wait);
+     wq_write_unlock_irqrestore (&q->lock,flags);
 #endif
 }
 
 /******************************************************************************/
 
+static int
+fusiondev_init (FusionDev *dev)
+{
+     int ret;
+
+     ret = fusionee_init (dev);
+     if (ret)
+          goto error_fusionee;
+
+     ret = fusion_ref_init (dev);
+     if (ret)
+          goto error_ref;
+
+     ret = fusion_skirmish_init (dev);
+     if (ret)
+          goto error_skirmish;
+
+     ret = fusion_property_init (dev);
+     if (ret)
+          goto error_property;
+
+     ret = fusion_reactor_init (dev);
+     if (ret)
+          goto error_reactor;
+
+     ret = fusion_call_init (dev);
+     if (ret)
+          goto error_call;
+
+     return 0;
+
+
+error_call:
+     fusion_reactor_deinit (dev);
+
+error_reactor:
+     fusion_property_deinit (dev);
+
+error_property:
+     fusion_skirmish_deinit (dev);
+
+error_skirmish:
+     fusion_ref_deinit (dev);
+
+error_ref:
+     fusionee_deinit (dev);
+
+error_fusionee:
+     return ret;
+}
+
 static void
-fusion_reset (void)
+fusiondev_deinit (FusionDev *dev)
 {
-  fusion_call_reset();
-  fusion_reactor_reset();
-  fusion_property_reset();
-  fusion_skirmish_reset();
-  fusion_ref_reset();
-  fusionee_reset();
+     fusion_call_deinit (dev);
+     fusion_reactor_deinit (dev);
+     fusion_property_deinit (dev);
+     fusion_skirmish_deinit (dev);
+     fusion_ref_deinit (dev);
+     fusionee_deinit (dev);
 }
 
 /******************************************************************************/
@@ -111,443 +166,471 @@ fusion_reset (void)
 static int
 fusion_open (struct inode *inode, struct file *file)
 {
-  int ret;
-  int fusion_id;
+     int ret;
+     int fusion_id;
+     int minor = minor(inode->i_rdev);
+
+     spin_lock (&devs_lock);
+
+     if (!fusion_devs[minor]) {
+          char buf[4];
+
+          fusion_devs[minor] = kmalloc (sizeof(FusionDev), GFP_ATOMIC);
+          if (!fusion_devs[minor]) {
+               spin_unlock (&devs_lock);
+               return -ENOMEM;
+          }
 
-  spin_lock (&refs_lock);
+          memset (fusion_devs[minor], 0, sizeof(FusionDev));
 
-  ret = fusionee_new (&fusion_id);
-  if (ret)
-    {
-      spin_unlock (&refs_lock);
+          snprintf (buf, 4, "%d", minor);
 
-      return ret;
-    }
+          fusion_devs[minor]->proc_dir = proc_mkdir (buf, proc_fusion_dir);
+          
+          ret = fusiondev_init (fusion_devs[minor]);
+          if (ret) {
+               remove_proc_entry (buf, proc_fusion_dir);
 
-  refs++;
+               kfree (fusion_devs[minor]);
+               fusion_devs[minor] = NULL;
 
-  spin_unlock (&refs_lock);
+               spin_unlock (&devs_lock);
+               
+               return ret;
+          }
+     }
+     else if (file->f_flags & O_EXCL) {
+          spin_unlock (&devs_lock);
+          return -EBUSY;
+     }
 
+     ret = fusionee_new (fusion_devs[minor], &fusion_id);
+     if (ret) {
+          if (!fusion_devs[minor]->refs) {
+               fusiondev_deinit (fusion_devs[minor]);
 
-  file->private_data = (void*) fusion_id;
+               remove_proc_entry (fusion_devs[minor]->proc_dir->name,
+                                  proc_fusion_dir);
+               
+               kfree (fusion_devs[minor]);
+               fusion_devs[minor] = NULL;
+          }
 
-  return 0;
+          spin_unlock (&devs_lock);
+
+          return ret;
+     }
+
+     fusion_devs[minor]->refs++;
+
+     spin_unlock (&devs_lock);
+
+
+     file->private_data = (void*) fusion_id;
+
+     return 0;
 }
 
 static int
 fusion_release (struct inode *inode, struct file *file)
 {
-  int fusion_id = (int) file->private_data;
+     int minor     = minor(inode->i_rdev);
+     int fusion_id = (int) file->private_data;
+
+     fusionee_destroy (fusion_devs[minor], fusion_id);
 
-  fusionee_destroy (fusion_id);
+     spin_lock (&devs_lock);
 
-  spin_lock (&refs_lock);
+     if (! --fusion_devs[minor]->refs) {
+          fusiondev_deinit (fusion_devs[minor]);
 
-  if (! --refs)
-    fusion_reset();
+          remove_proc_entry (fusion_devs[minor]->proc_dir->name,
+                             proc_fusion_dir);
+          
+          kfree (fusion_devs[minor]);
+          fusion_devs[minor] = NULL;
+     }
 
-  spin_unlock (&refs_lock);
+     spin_unlock (&devs_lock);
 
-  return 0;
+     return 0;
 }
 
 static ssize_t
 fusion_read (struct file *file, char *buf, size_t count, loff_t *ppos)
 {
-  int fusion_id = (int) file->private_data;
+     int        fusion_id = (int) file->private_data;
+     FusionDev *dev       = fusion_devs[minor(file->f_dentry->d_inode->i_rdev)];
 
-  return fusionee_get_messages (fusion_id, buf, count,
-                                !(file->f_flags & O_NONBLOCK));
+     return fusionee_get_messages (dev, fusion_id, buf, count,
+                                   !(file->f_flags & O_NONBLOCK));
 }
 
 static unsigned int
 fusion_poll (struct file *file, poll_table * wait)
 {
-  int fusion_id = (int) file->private_data;
+     int        fusion_id = (int) file->private_data;
+     FusionDev *dev       = fusion_devs[minor(file->f_dentry->d_inode->i_rdev)];
 
-  return fusionee_poll (fusion_id, file, wait);
+     return fusionee_poll (dev, fusion_id, file, wait);
 }
 
 static int
 fusion_ioctl (struct inode *inode, struct file *file,
               unsigned int cmd, unsigned long arg)
 {
-  int id;
-  int ret;
-  int refs;
-  int fusion_id = (int) file->private_data;
-  FusionSendMessage     send;
-  FusionReactorDispatch dispatch;
-  FusionKill            kill;
-  FusionCallNew         call;
-  FusionCallExecute     execute;
-  FusionCallReturn      call_ret;
+     int                    id;
+     int                    ret;
+     int                    refs;
+     int                    fusion_id = (int) file->private_data;
+     FusionDev             *dev = fusion_devs[minor(inode->i_rdev)];
+     FusionSendMessage      send;
+     FusionReactorDispatch  dispatch;
+     FusionKill             kill;
+     FusionCallNew          call;
+     FusionCallExecute      execute;
+     FusionCallReturn       call_ret;
 
-  switch (cmd)
-    {
-    case FUSION_GET_ID:
-      if (put_user (fusion_id, (int*) arg))
-        return -EFAULT;
+     switch (cmd) {
+          case FUSION_GET_ID:
+               if (put_user (fusion_id, (int*) arg))
+                    return -EFAULT;
 
-      break;
+               break;
 
 
-    case FUSION_SEND_MESSAGE:
-      if (copy_from_user (&send, (FusionSendMessage*) arg, sizeof(send)))
-        return -EFAULT;
+          case FUSION_SEND_MESSAGE:
+               if (copy_from_user (&send, (FusionSendMessage*) arg, sizeof(send)))
+                    return -EFAULT;
 
-      if (send.msg_size <= 0)
-        return -EINVAL;
+               if (send.msg_size <= 0)
+                    return -EINVAL;
 
-      /* message data > 64k should be stored in shared memory */
-      if (send.msg_size > 0x10000)
-        return -EMSGSIZE;
+               /* message data > 64k should be stored in shared memory */
+               if (send.msg_size > 0x10000)
+                    return -EMSGSIZE;
 
-      return fusionee_send_message (fusion_id, send.fusion_id, FMT_SEND, send.msg_id,
-                                    send.msg_size, send.msg_data);
+               return fusionee_send_message (dev, fusion_id, send.fusion_id, FMT_SEND,
+                                             send.msg_id, send.msg_size, send.msg_data);
 
 
-    case FUSION_CALL_NEW:
-      if (copy_from_user (&call, (FusionCallNew*) arg, sizeof(call)))
-        return -EFAULT;
+          case FUSION_CALL_NEW:
+               if (copy_from_user (&call, (FusionCallNew*) arg, sizeof(call)))
+                    return -EFAULT;
 
-      ret = fusion_call_new (fusion_id, &call);
-      if (ret)
-        return ret;
+               ret = fusion_call_new (dev, fusion_id, &call);
+               if (ret)
+                    return ret;
 
-      if (put_user (call.call_id, (int*) arg))
-        {
-          fusion_call_destroy (fusion_id, call.call_id);
-          return -EFAULT;
-        }
-      break;
+               if (put_user (call.call_id, (int*) arg)) {
+                    fusion_call_destroy (dev, fusion_id, call.call_id);
+                    return -EFAULT;
+               }
+               break;
 
-    case FUSION_CALL_EXECUTE:
-      if (copy_from_user (&execute, (FusionCallExecute*) arg, sizeof(execute)))
-        return -EFAULT;
+          case FUSION_CALL_EXECUTE:
+               if (copy_from_user (&execute, (FusionCallExecute*) arg, sizeof(execute)))
+                    return -EFAULT;
 
-      ret = fusion_call_execute (fusion_id, &execute);
-      if (ret)
-        return ret;
+               ret = fusion_call_execute (dev, fusion_id, &execute);
+               if (ret)
+                    return ret;
 
-      if (put_user (execute.ret_val, (int*) arg))
-        return -EFAULT;
-      break;
+               if (put_user (execute.ret_val, (int*) arg))
+                    return -EFAULT;
+               break;
 
-    case FUSION_CALL_RETURN:
-      if (copy_from_user (&call_ret, (FusionCallReturn*) arg, sizeof(call_ret)))
-        return -EFAULT;
+          case FUSION_CALL_RETURN:
+               if (copy_from_user (&call_ret, (FusionCallReturn*) arg, sizeof(call_ret)))
+                    return -EFAULT;
 
-      return fusion_call_return (fusion_id, &call_ret);
+               return fusion_call_return (dev, fusion_id, &call_ret);
 
-    case FUSION_CALL_DESTROY:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_CALL_DESTROY:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_call_destroy (fusion_id, id);
+               return fusion_call_destroy (dev, fusion_id, id);
 
 
-    case FUSION_KILL:
-      if (copy_from_user (&kill, (FusionKill*) arg, sizeof(kill)))
-        return -EFAULT;
+          case FUSION_KILL:
+               if (copy_from_user (&kill, (FusionKill*) arg, sizeof(kill)))
+                    return -EFAULT;
 
-      return fusionee_kill (fusion_id,
-                            kill.fusion_id, kill.signal, kill.timeout_ms);
+               return fusionee_kill (dev, fusion_id,
+                                     kill.fusion_id, kill.signal, kill.timeout_ms);
 
 
-    case FUSION_REF_NEW:
-      ret = fusion_ref_new (&id);
-      if (ret)
-        return ret;
+          case FUSION_REF_NEW:
+               ret = fusion_ref_new (dev, &id);
+               if (ret)
+                    return ret;
 
-      if (put_user (id, (int*) arg))
-        {
-          fusion_ref_destroy (id);
-          return -EFAULT;
-        }
-      break;
+               if (put_user (id, (int*) arg)) {
+                    fusion_ref_destroy (dev, id);
+                    return -EFAULT;
+               }
+               break;
 
-    case FUSION_REF_UP:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_REF_UP:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_ref_up (id, fusion_id);
+               return fusion_ref_up (dev, id, fusion_id);
 
-    case FUSION_REF_UP_GLOBAL:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_REF_UP_GLOBAL:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_ref_up (id, 0);
+               return fusion_ref_up (dev, id, 0);
 
-    case FUSION_REF_DOWN:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_REF_DOWN:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_ref_down (id, fusion_id);
+               return fusion_ref_down (dev, id, fusion_id);
 
-    case FUSION_REF_DOWN_GLOBAL:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_REF_DOWN_GLOBAL:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_ref_down (id, 0);
+               return fusion_ref_down (dev, id, 0);
 
-    case FUSION_REF_ZERO_LOCK:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_REF_ZERO_LOCK:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_ref_zero_lock (id, fusion_id);
+               return fusion_ref_zero_lock (dev, id, fusion_id);
 
-    case FUSION_REF_ZERO_TRYLOCK:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_REF_ZERO_TRYLOCK:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_ref_zero_trylock (id, fusion_id);
+               return fusion_ref_zero_trylock (dev, id, fusion_id);
 
-    case FUSION_REF_UNLOCK:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_REF_UNLOCK:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_ref_unlock (id, fusion_id);
+               return fusion_ref_unlock (dev, id, fusion_id);
 
-    case FUSION_REF_STAT:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_REF_STAT:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      ret = fusion_ref_stat (id, &refs);
-      if (ret)
-        return ret;
+               ret = fusion_ref_stat (dev, id, &refs);
+               if (ret)
+                    return ret;
 
-      return refs;
+               return refs;
 
-    case FUSION_REF_DESTROY:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_REF_DESTROY:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_ref_destroy (id);
+               return fusion_ref_destroy (dev, id);
 
 
-    case FUSION_SKIRMISH_NEW:
-      ret = fusion_skirmish_new (&id);
-      if (ret)
-        return ret;
+          case FUSION_SKIRMISH_NEW:
+               ret = fusion_skirmish_new (dev, &id);
+               if (ret)
+                    return ret;
 
-      if (put_user (id, (int*) arg))
-        {
-          fusion_skirmish_destroy (id);
-          return -EFAULT;
-        }
-      break;
+               if (put_user (id, (int*) arg)) {
+                    fusion_skirmish_destroy (dev, id);
+                    return -EFAULT;
+               }
+               break;
 
-    case FUSION_SKIRMISH_PREVAIL:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_SKIRMISH_PREVAIL:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_skirmish_prevail (id, fusion_id);
+               return fusion_skirmish_prevail (dev, id, fusion_id);
 
-    case FUSION_SKIRMISH_SWOOP:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_SKIRMISH_SWOOP:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_skirmish_swoop (id, fusion_id);
+               return fusion_skirmish_swoop (dev, id, fusion_id);
 
-    case FUSION_SKIRMISH_DISMISS:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_SKIRMISH_DISMISS:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_skirmish_dismiss (id, fusion_id);
+               return fusion_skirmish_dismiss (dev, id, fusion_id);
 
-    case FUSION_SKIRMISH_DESTROY:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_SKIRMISH_DESTROY:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_skirmish_destroy (id);
+               return fusion_skirmish_destroy (dev, id);
 
 
-    case FUSION_PROPERTY_NEW:
-      ret = fusion_property_new (&id);
-      if (ret)
-        return ret;
+          case FUSION_PROPERTY_NEW:
+               ret = fusion_property_new (dev, &id);
+               if (ret)
+                    return ret;
 
-      if (put_user (id, (int*) arg))
-        {
-          fusion_property_destroy (id);
-          return -EFAULT;
-        }
-      break;
+               if (put_user (id, (int*) arg)) {
+                    fusion_property_destroy (dev, id);
+                    return -EFAULT;
+               }
+               break;
 
-    case FUSION_PROPERTY_LEASE:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_PROPERTY_LEASE:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_property_lease (id, fusion_id);
+               return fusion_property_lease (dev, id, fusion_id);
 
-    case FUSION_PROPERTY_PURCHASE:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_PROPERTY_PURCHASE:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_property_purchase (id, fusion_id);
+               return fusion_property_purchase (dev, id, fusion_id);
 
-    case FUSION_PROPERTY_CEDE:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_PROPERTY_CEDE:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_property_cede (id, fusion_id);
+               return fusion_property_cede (dev, id, fusion_id);
 
-    case FUSION_PROPERTY_HOLDUP:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_PROPERTY_HOLDUP:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_property_holdup (id, fusion_id);
+               return fusion_property_holdup (dev, id, fusion_id);
 
-    case FUSION_PROPERTY_DESTROY:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_PROPERTY_DESTROY:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_property_destroy (id);
+               return fusion_property_destroy (dev, id);
 
 
-    case FUSION_REACTOR_NEW:
-      ret = fusion_reactor_new (&id);
-      if (ret)
-        return ret;
+          case FUSION_REACTOR_NEW:
+               ret = fusion_reactor_new (dev, &id);
+               if (ret)
+                    return ret;
 
-      if (put_user (id, (int*) arg))
-        {
-          fusion_reactor_destroy (id);
-          return -EFAULT;
-        }
-      break;
+               if (put_user (id, (int*) arg)) {
+                    fusion_reactor_destroy (dev, id);
+                    return -EFAULT;
+               }
+               break;
 
-    case FUSION_REACTOR_ATTACH:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_REACTOR_ATTACH:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_reactor_attach (id, fusion_id);
+               return fusion_reactor_attach (dev, id, fusion_id);
 
-    case FUSION_REACTOR_DETACH:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_REACTOR_DETACH:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_reactor_detach (id, fusion_id);
+               return fusion_reactor_detach (dev, id, fusion_id);
 
-    case FUSION_REACTOR_DISPATCH:
-      if (copy_from_user (&dispatch,
-                          (FusionReactorDispatch*) arg, sizeof(dispatch)))
-        return -EFAULT;
+          case FUSION_REACTOR_DISPATCH:
+               if (copy_from_user (&dispatch,
+                                   (FusionReactorDispatch*) arg, sizeof(dispatch)))
+                    return -EFAULT;
 
-      if (dispatch.msg_size <= 0)
-        return -EINVAL;
+               if (dispatch.msg_size <= 0)
+                    return -EINVAL;
 
-      /* message data > 64k should be stored in shared memory */
-      if (dispatch.msg_size > 0x10000)
-        return -EMSGSIZE;
+               /* message data > 64k should be stored in shared memory */
+               if (dispatch.msg_size > 0x10000)
+                    return -EMSGSIZE;
 
-      return fusion_reactor_dispatch (dispatch.reactor_id,
-                                      dispatch.self ? 0 : fusion_id,
-                                      dispatch.msg_size, dispatch.msg_data);
+               return fusion_reactor_dispatch (dev, dispatch.reactor_id,
+                                               dispatch.self ? 0 : fusion_id,
+                                               dispatch.msg_size, dispatch.msg_data);
 
-    case FUSION_REACTOR_DESTROY:
-      if (get_user (id, (int*) arg))
-        return -EFAULT;
+          case FUSION_REACTOR_DESTROY:
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
 
-      return fusion_reactor_destroy (id);
+               return fusion_reactor_destroy (dev, id);
 
 
-    default:
-      return -ENOTTY;
-    }
+          default:
+               return -ENOTTY;
+     }
 
-  return 0;
+     return 0;
 }
 
 static struct file_operations fusion_fops = {
-  .owner   = THIS_MODULE,
-  .open    = fusion_open,
-  .release = fusion_release,
-  .read    = fusion_read,
-  .poll    = fusion_poll,
-  .ioctl   = fusion_ioctl
-};
-
-static struct miscdevice fusion_miscdev = {
-  .minor   = FUSION_MINOR,
-  .name    = "fusion",
-  .fops    = &fusion_fops
+     .owner   = THIS_MODULE,
+     .open    = fusion_open,
+     .release = fusion_release,
+     .read    = fusion_read,
+     .poll    = fusion_poll,
+     .ioctl   = fusion_ioctl
 };
 
 /******************************************************************************/
 
-int __init
-fusion_init(void)
+static int __init
+register_devices(void)
 {
-  int ret;
-
-  proc_fusion_dir = proc_mkdir ("fusion", NULL);
-
-  ret = fusionee_init();
-  if (ret)
-    goto error_fusionee;
+     int  i;
+     char buf[16];
 
-  ret = fusion_ref_init();
-  if (ret)
-    goto error_ref;
+     if (devfs_register_chrdev (FUSION_MAJOR, "fusion", &fusion_fops)) {
+          printk (KERN_ERR "fusion: unable to get major %d\n", FUSION_MAJOR);
+          return -EIO;
+     }
 
-  ret = fusion_skirmish_init();
-  if (ret)
-    goto error_skirmish;
+     for (i=0; i<NUM_MINORS; i++) {
+          snprintf (buf, 16, "fusion/%d", i);
 
-  ret = fusion_property_init();
-  if (ret)
-    goto error_property;
-
-  ret = fusion_reactor_init();
-  if (ret)
-    goto error_reactor;
-
-  ret = fusion_call_init();
-  if (ret)
-    goto error_call;
-
-  ret = misc_register (&fusion_miscdev);
-  if (ret)
-    goto error_misc;
-
-  return 0;
+          devfs_handles[i] = devfs_register (NULL, buf, DEVFS_FL_DEFAULT,
+                                             FUSION_MAJOR, i,
+                                             S_IFCHR | S_IRUSR | S_IWUSR,
+                                             &fusion_fops, NULL);
+     }
 
+     return 0;
+}
 
- error_misc:
-  fusion_call_cleanup();
+int __init
+fusion_init(void)
+{
+     int ret;
 
- error_call:
-  fusion_reactor_cleanup();
+     ret = register_devices();
+     if (ret)
+          return ret;
 
- error_reactor:
-  fusion_property_cleanup();
+     proc_fusion_dir = proc_mkdir ("fusion", NULL);
+     
+     return 0;
+}
 
- error_property:
-  fusion_skirmish_cleanup();
+/******************************************************************************/
 
- error_skirmish:
-  fusion_ref_cleanup();
+static void __exit
+deregister_devices(void)
+{
+     int i;
 
- error_ref:
-  fusionee_cleanup();
+     devfs_unregister_chrdev (FUSION_MAJOR, "fusion");
 
- error_fusionee:
-  return ret;
+     for (i=0; i<NUM_MINORS; i++)
+          devfs_unregister (devfs_handles[i]);
 }
 
 void __exit
 fusion_exit(void)
 {
-  fusion_reactor_cleanup();
-  fusion_property_cleanup();
-  fusion_skirmish_cleanup();
-  fusion_ref_cleanup();
-  fusionee_cleanup();
+     deregister_devices();
 
-  misc_deregister (&fusion_miscdev);
+     remove_proc_entry ("fusion", NULL);
 }
 
 module_init(fusion_init);
 module_exit(fusion_exit);
+
diff --git a/drivers/char/fusion/fusiondev.h b/drivers/char/fusion/fusiondev.h
index 279bb85..00ff4fe 100644
--- a/drivers/char/fusion/fusiondev.h
+++ b/drivers/char/fusion/fusiondev.h
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -17,14 +17,57 @@
 
 #include <linux/proc_fs.h>
 
-extern struct proc_dir_entry *proc_fusion_dir;
+#include "list.h"
+
+typedef struct {
+     int refs;
+     
+     struct proc_dir_entry *proc_dir;
+     
+     struct {
+          int         ids;
+          FusionLink *list;
+          spinlock_t  lock;
+     } call;
+
+     struct {
+          int                last_id;
+          FusionLink        *list;
+          spinlock_t         lock;
+          wait_queue_head_t  wait;
+     } fusionee;
+     
+     struct {
+          int         ids;
+          FusionLink *list;
+          spinlock_t  lock;
+     } property;
+     
+     struct {
+          int         ids;
+          FusionLink *list;
+          spinlock_t  lock;
+     } reactor;
+     
+     struct {
+          int         ids;
+          FusionLink *list;
+          spinlock_t  lock;
+     } ref;
+     
+     struct {
+          int         ids;
+          FusionLink *list;
+          spinlock_t  lock;
+     } skirmish;
+} FusionDev;
 
 /*
  * Special version of interruptible_sleep_on() that unlocks the spinlock
  * after adding the entry to the queue (just before schedule).
  */
-void fusion_sleep_on(wait_queue_head_t *q,
-                     spinlock_t        *lock,
-                     signed long       *timeout_ms);
+void fusion_sleep_on (wait_queue_head_t *q,
+                      spinlock_t        *lock,
+                      signed long       *timeout_ms);
 
 #endif
diff --git a/drivers/char/fusion/fusionee.c b/drivers/char/fusion/fusionee.c
index 705ae60..bae0921 100644
--- a/drivers/char/fusion/fusionee.c
+++ b/drivers/char/fusion/fusionee.c
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -11,7 +11,7 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  */
- 
+
 #include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
@@ -33,462 +33,423 @@
 
 
 typedef struct {
-  FusionLink        link;
+     FusionLink        link;
 
-  spinlock_t        lock;
+     spinlock_t        lock;
 
-  int               id;
-  int               pid;
+     int               id;
+     int               pid;
 
-  FusionFifo        messages;
+     FusionFifo        messages;
 
-  int               rcv_total;  /* Total number of messages received. */
-  int               snd_total;  /* Total number of messages sent. */
+     int               rcv_total;  /* Total number of messages received. */
+     int               snd_total;  /* Total number of messages sent. */
 
-  wait_queue_head_t wait;
+     wait_queue_head_t wait;
 } Fusionee;
 
 typedef struct {
-  FusionLink         link;
+     FusionLink         link;
 
-  FusionMessageType  type;
-  int                id;
-  int                size;
-  void              *data;
+     FusionMessageType  type;
+     int                id;
+     int                size;
+     void              *data;
 } Message;
 
 /******************************************************************************/
 
-static Fusionee *lookup_fusionee (int id);
+static Fusionee *lookup_fusionee (FusionDev *dev, int id);
 
-static Fusionee *lock_fusionee   (int id);
+static Fusionee *lock_fusionee   (FusionDev *dev, int id);
 static void      unlock_fusionee (Fusionee *fusionee);
 
 /******************************************************************************/
 
-static int                last_id        = 0;
-static FusionLink        *fusionees      = NULL;
-static spinlock_t         fusionees_lock = SPIN_LOCK_UNLOCKED;
-static wait_queue_head_t  fusionees_wait;
-static atomic_t           msg_total;
-
-/******************************************************************************/
-
 static int
 fusionees_read_proc(char *buf, char **start, off_t offset,
                     int len, int *eof, void *private)
 {
-  FusionLink *l;
-  int written = 0;
-
-  spin_lock (&fusionees_lock);
-
-  fusion_list_foreach (l, fusionees)
-    {
-      Fusionee *fusionee = (Fusionee*) l;
-
-      written += sprintf(buf+written, "(%5d) 0x%08x (%4d messages waiting, %5d received, %5d sent)\n",
-                         fusionee->pid, fusionee->id, fusionee->messages.count, fusionee->rcv_total, fusionee->snd_total);
-      if (written < offset)
-        {
-          offset -= written;
-          written = 0;
-        }
-
-      if (written >= len)
-        break;
-    }
-
-  spin_unlock (&fusionees_lock);
-
-  *start = buf + offset;
-  written -= offset;
-  if(written > len)
-    {
-      *eof = 0;
-      return len;
-    }
-
-  *eof = 1;
-  return (written<0) ? 0 : written;
-}
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
 
-int
-fusionee_init()
-{
-  atomic_set (&msg_total, 0);
+     spin_lock (&dev->fusionee.lock);
+
+     fusion_list_foreach (l, dev->fusionee.list) {
+          Fusionee *fusionee = (Fusionee*) l;
 
-  init_waitqueue_head (&fusionees_wait);
+          written += sprintf(buf+written, "(%5d) 0x%08x (%4d messages waiting, %5d received, %5d sent)\n",
+                             fusionee->pid, fusionee->id, fusionee->messages.count, fusionee->rcv_total, fusionee->snd_total);
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
 
-  create_proc_read_entry("fusionees", 0, proc_fusion_dir,
-                         fusionees_read_proc, NULL);
+          if (written >= len)
+               break;
+     }
 
-  return 0;
+     spin_unlock (&dev->fusionee.lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
 }
 
-void
-fusionee_reset()
+int
+fusionee_init (FusionDev *dev)
 {
-  FusionLink *l;
+     init_waitqueue_head (&dev->fusionee.wait);
 
-  spin_lock (&fusionees_lock);
+     dev->fusionee.lock = SPIN_LOCK_UNLOCKED;
+     
+     create_proc_read_entry("fusionees", 0, dev->proc_dir,
+                            fusionees_read_proc, dev);
 
-  l = fusionees;
-  while (l)
-    {
-      FusionLink *next     = l->next;
-      Fusionee   *fusionee = (Fusionee *) l;
-
-      while (fusionee->messages.count)
-        {
-          Message *message = (Message*) fusion_fifo_get (&fusionee->messages);
+     return 0;
+}
 
-          kfree (message);
-        }
+void
+fusionee_deinit (FusionDev *dev)
+{
+     FusionLink *l;
 
-      kfree (fusionee);
+     spin_lock (&dev->fusionee.lock);
 
-      l = next;
-    }
+     remove_proc_entry ("fusionees", dev->proc_dir);
+     
+     l = dev->fusionee.list;
+     while (l) {
+          FusionLink *next     = l->next;
+          Fusionee   *fusionee = (Fusionee *) l;
 
-  last_id   = 0;
-  fusionees = NULL;
+          while (fusionee->messages.count) {
+               Message *message = (Message*) fusion_fifo_get (&fusionee->messages);
 
-  atomic_set (&msg_total, 0);
+               kfree (message);
+          }
 
-  spin_unlock (&fusionees_lock);
-}
+          kfree (fusionee);
 
-void
-fusionee_cleanup()
-{
-  fusionee_reset();
+          l = next;
+     }
 
-  remove_proc_entry ("fusionees", proc_fusion_dir);
+     spin_unlock (&dev->fusionee.lock);
 }
 
 /******************************************************************************/
 
 int
-fusionee_new (int *id)
+fusionee_new (FusionDev *dev, int *id)
 {
-  Fusionee *fusionee;
+     Fusionee *fusionee;
 
-  fusionee = kmalloc (sizeof(Fusionee), GFP_ATOMIC);
-  if (!fusionee)
-    return -ENOMEM;
+     fusionee = kmalloc (sizeof(Fusionee), GFP_ATOMIC);
+     if (!fusionee)
+          return -ENOMEM;
 
-  memset (fusionee, 0, sizeof(Fusionee));
+     memset (fusionee, 0, sizeof(Fusionee));
 
-  spin_lock (&fusionees_lock);
+     spin_lock (&dev->fusionee.lock);
 
-  fusionee->id   = ++last_id;
-  fusionee->pid  = current->pid;
-  fusionee->lock = SPIN_LOCK_UNLOCKED;
+     fusionee->id   = ++dev->fusionee.last_id;
+     fusionee->pid  = current->pid;
+     fusionee->lock = SPIN_LOCK_UNLOCKED;
 
-  init_waitqueue_head (&fusionee->wait);
+     init_waitqueue_head (&fusionee->wait);
 
-  fusion_list_prepend (&fusionees, &fusionee->link);
+     fusion_list_prepend (&dev->fusionee.list, &fusionee->link);
 
-  spin_unlock (&fusionees_lock);
+     spin_unlock (&dev->fusionee.lock);
 
-  *id = fusionee->id;
+     *id = fusionee->id;
 
-  return 0;
+     return 0;
 }
 
 int
-fusionee_send_message (int id, int recipient, FusionMessageType msg_type,
-                       int msg_id, int msg_size, const void *msg_data)
+fusionee_send_message (FusionDev *dev, int id, int recipient,
+                       FusionMessageType msg_type, int msg_id,
+                       int msg_size, const void *msg_data)
 {
-  Message  *message;
-  Fusionee *sender;
-  Fusionee *fusionee = lock_fusionee (recipient);
-
-  if (!fusionee)
-    return -EINVAL;
+     Message  *message;
+     Fusionee *sender;
+     Fusionee *fusionee = lock_fusionee (dev, recipient);
 
-  sender = lock_fusionee (id);
-  if (!sender)
-    {
-      unlock_fusionee (fusionee);
-      return -EIO;
-    }
+     if (!fusionee)
+          return -EINVAL;
 
-  message = kmalloc (sizeof(Message) + msg_size, GFP_ATOMIC);
-  if (!message)
-    {
-      unlock_fusionee (sender);
-      unlock_fusionee (fusionee);
-      return -ENOMEM;
-    }
+     sender = lock_fusionee (dev, id);
+     if (!sender) {
+          unlock_fusionee (fusionee);
+          return -EIO;
+     }
 
-  message->data = message + 1;
+     message = kmalloc (sizeof(Message) + msg_size, GFP_ATOMIC);
+     if (!message) {
+          unlock_fusionee (sender);
+          unlock_fusionee (fusionee);
+          return -ENOMEM;
+     }
 
-  if (msg_type == FMT_CALL)
-    memcpy (message->data, msg_data, msg_size);
-  else if (copy_from_user (message->data, msg_data, msg_size))
-    {
-      kfree (message);
-      unlock_fusionee (sender);
-      unlock_fusionee (fusionee);
-      return -EFAULT;
-    }
+     message->data = message + 1;
 
-  message->type = msg_type;
-  message->id   = msg_id;
-  message->size = msg_size;
+     if (msg_type == FMT_CALL)
+          memcpy (message->data, msg_data, msg_size);
+     else if (copy_from_user (message->data, msg_data, msg_size)) {
+          kfree (message);
+          unlock_fusionee (sender);
+          unlock_fusionee (fusionee);
+          return -EFAULT;
+     }
 
-  fusion_fifo_put (&fusionee->messages, &message->link);
+     message->type = msg_type;
+     message->id   = msg_id;
+     message->size = msg_size;
 
-  fusionee->rcv_total++;
-  sender->snd_total++;
+     fusion_fifo_put (&fusionee->messages, &message->link);
 
-  atomic_inc (&msg_total);
+     fusionee->rcv_total++;
+     sender->snd_total++;
 
-  wake_up_interruptible_all (&fusionee->wait);
+     wake_up_interruptible_all (&fusionee->wait);
 
-  unlock_fusionee (sender);
-  unlock_fusionee (fusionee);
+     unlock_fusionee (sender);
+     unlock_fusionee (fusionee);
 
-  return 0;
+     return 0;
 }
 
 int
-fusionee_get_messages (int id, void *buf, int buf_size, int block)
+fusionee_get_messages (FusionDev *dev,
+                       int id, void *buf, int buf_size, bool block)
 {
-  int       written  = 0;
-  Fusionee *fusionee = lock_fusionee (id);
+     int       written  = 0;
+     Fusionee *fusionee = lock_fusionee (dev, id);
 
-  if (!fusionee)
-    return -EINVAL;
+     if (!fusionee)
+          return -EINVAL;
 
-  while (!fusionee->messages.count)
-    {
-      if (!block)
-        {
-          unlock_fusionee (fusionee);
-          return -EAGAIN;
-        }
-
-      fusion_sleep_on (&fusionee->wait, &fusionee->lock, 0);
-
-      if (signal_pending(current))
-        return -ERESTARTSYS;
-
-      fusionee = lock_fusionee (id);
-      if (!fusionee)
-        return -EINVAL;
-    }
-
-  while (fusionee->messages.count)
-    {
-      FusionReadMessage  header;
-      Message           *message = (Message*) fusionee->messages.first;
-      int                bytes   = message->size + sizeof(header);
-
-      if (bytes > buf_size)
-        {
-          if (!written)
-            {
-              unlock_fusionee (fusionee);
-              return -EMSGSIZE;
-            }
-
-          break;
-        }
-
-      header.msg_type = message->type;
-      header.msg_id   = message->id;
-      header.msg_size = message->size;
-
-      if (copy_to_user (buf, &header, sizeof(header)) ||
-          copy_to_user (buf + sizeof(header), message->data, message->size))
-        {
-          unlock_fusionee (fusionee);
-          return -EFAULT;
-        }
-        
-      written  += bytes;
-      buf      += bytes;
-      buf_size -= bytes;
+     while (!fusionee->messages.count) {
+          if (!block) {
+               unlock_fusionee (fusionee);
+               return -EAGAIN;
+          }
+
+          fusion_sleep_on (&fusionee->wait, &fusionee->lock, 0);
+
+          if (signal_pending(current))
+               return -ERESTARTSYS;
+
+          fusionee = lock_fusionee (dev, id);
+          if (!fusionee)
+               return -EINVAL;
+     }
+
+     while (fusionee->messages.count) {
+          FusionReadMessage  header;
+          Message           *message = (Message*) fusionee->messages.first;
+          int                bytes   = message->size + sizeof(header);
+
+          if (bytes > buf_size) {
+               if (!written) {
+                    unlock_fusionee (fusionee);
+                    return -EMSGSIZE;
+               }
+
+               break;
+          }
+
+          header.msg_type = message->type;
+          header.msg_id   = message->id;
+          header.msg_size = message->size;
 
-      fusion_fifo_get (&fusionee->messages);
+          if (copy_to_user (buf, &header, sizeof(header)) ||
+              copy_to_user (buf + sizeof(header), message->data, message->size)) {
+               unlock_fusionee (fusionee);
+               return -EFAULT;
+          }
 
-      kfree (message);
-    }
+          written  += bytes;
+          buf      += bytes;
+          buf_size -= bytes;
 
-  unlock_fusionee (fusionee);
+          fusion_fifo_get (&fusionee->messages);
 
-  return written;
+          kfree (message);
+     }
+
+     unlock_fusionee (fusionee);
+
+     return written;
 }
 
 unsigned int
-fusionee_poll (int id, struct file *file, poll_table * wait)
+fusionee_poll (FusionDev *dev, int id, struct file *file, poll_table * wait)
 {
-  Fusionee *fusionee = lock_fusionee (id);
+     Fusionee *fusionee = lock_fusionee (dev, id);
 
-  if (!fusionee)
-    return -EINVAL;
+     if (!fusionee)
+          return -EINVAL;
 
-  unlock_fusionee (fusionee);
+     unlock_fusionee (fusionee);
 
 
-  poll_wait (file, &fusionee->wait, wait);
+     poll_wait (file, &fusionee->wait, wait);
 
-  
-  fusionee = lock_fusionee (id);
 
-  if (!fusionee)
-    return -EINVAL;
+     fusionee = lock_fusionee (dev, id);
 
-  if (fusionee->messages.count)
-    {
-      unlock_fusionee (fusionee);
+     if (!fusionee)
+          return -EINVAL;
 
-      return POLLIN | POLLRDNORM;
-    }
+     if (fusionee->messages.count) {
+          unlock_fusionee (fusionee);
 
-  unlock_fusionee (fusionee);
+          return POLLIN | POLLRDNORM;
+     }
 
-  return 0;
+     unlock_fusionee (fusionee);
+
+     return 0;
 }
 
 int
-fusionee_kill (int id, int target, int signal, int timeout_ms)
+fusionee_kill (FusionDev *dev, int id, int target, int signal, int timeout_ms)
 {
-  long timeout = -1;
-
-  while (true)
-    {
-      FusionLink *l;
-      Fusionee   *fusionee = lookup_fusionee (id);
-      int         killed   = 0;
-
-      if (!fusionee)
-        return -EINVAL;
-
-      fusion_list_foreach (l, fusionees)
-        {
-          Fusionee *f = (Fusionee*) l;
-
-          if (f->id != id && (!target || target == f->id))
-            {
-              kill_proc (f->pid, signal, 0);
-              killed++;
-            }
-        }
-
-      if (!killed || timeout_ms < 0)
-        break;
-
-      if (timeout_ms)
-        {
-          switch (timeout)
-            {
-            case 0:  /* timed out */
-              spin_unlock (&fusionees_lock);
-              return -ETIMEDOUT;
-
-            case -1: /* setup timeout */
-              timeout = (timeout_ms * HZ + 500) / 1000;
-              if (!timeout)
-                timeout = 1;
-
-              /* fall through */
-
-            default:
-              fusion_sleep_on (&fusionees_wait, &fusionees_lock, &timeout);
-              break;
-            }
-        }
-      else
-        fusion_sleep_on (&fusionees_wait, &fusionees_lock, NULL);
-
-      if (signal_pending(current))
-        return -ERESTARTSYS;
-    }
-  
-  spin_unlock (&fusionees_lock);
-
-  return 0;
+     long timeout = -1;
+
+     while (true) {
+          FusionLink *l;
+          Fusionee   *fusionee = lookup_fusionee (dev, id);
+          int         killed   = 0;
+
+          if (!fusionee)
+               return -EINVAL;
+
+          fusion_list_foreach (l, dev->fusionee.list) {
+               Fusionee *f = (Fusionee*) l;
+
+               if (f->id != id && (!target || target == f->id)) {
+                    kill_proc (f->pid, signal, 0);
+                    killed++;
+               }
+          }
+
+          if (!killed || timeout_ms < 0)
+               break;
+
+          if (timeout_ms) {
+               switch (timeout) {
+                    case 0:  /* timed out */
+                         spin_unlock (&fusionees_lock);
+                         return -ETIMEDOUT;
+
+                    case -1: /* setup timeout */
+                         timeout = (timeout_ms * HZ + 500) / 1000;
+                         if (!timeout)
+                              timeout = 1;
+
+                         /* fall through */
+
+                    default:
+                         fusion_sleep_on (&dev->fusionee.wait,
+                                          &dev->fusionee.lock, &timeout);
+                         break;
+               }
+          }
+          else
+               fusion_sleep_on (&dev->fusionee.wait, &dev->fusionee.lock, NULL);
+
+          if (signal_pending(current))
+               return -ERESTARTSYS;
+     }
+
+     spin_unlock (&fusionees_lock);
+
+     return 0;
 }
 
 int
-fusionee_destroy (int id)
+fusionee_destroy (FusionDev *dev, int id)
 {
-  Fusionee *fusionee = lookup_fusionee (id);
+     Fusionee *fusionee = lookup_fusionee (dev, id);
 
-  if (!fusionee)
-    return -EINVAL;
+     if (!fusionee)
+          return -EINVAL;
 
-  spin_lock (&fusionee->lock);
+     spin_lock (&fusionee->lock);
 
-  fusion_list_remove (&fusionees, &fusionee->link);
+     fusion_list_remove (&dev->fusionee.list, &fusionee->link);
 
-  wake_up_interruptible_all (&fusionees_wait);
+     wake_up_interruptible_all (&dev->fusionee.wait);
 
-  spin_unlock (&fusionees_lock);
+     spin_unlock (&fusionees_lock);
 
 
-  fusion_call_destroy_all (id);
-  fusion_skirmish_dismiss_all (id);
-  fusion_reactor_detach_all (id);
-  fusion_property_cede_all (id);
-  fusion_ref_clear_all_local (id);
+     fusion_call_destroy_all (dev, id);
+     fusion_skirmish_dismiss_all (dev, id);
+     fusion_reactor_detach_all (dev, id);
+     fusion_property_cede_all (dev, id);
+     fusion_ref_clear_all_local (dev, id);
 
-  while (fusionee->messages.count)
-    {
-      Message *message = (Message*) fusion_fifo_get (&fusionee->messages);
+     while (fusionee->messages.count) {
+          Message *message = (Message*) fusion_fifo_get (&fusionee->messages);
 
-      kfree (message);
-    }
+          kfree (message);
+     }
+
+     spin_unlock (&fusionee->lock);
 
-  spin_unlock (&fusionee->lock);
-  
-  kfree (fusionee);
+     kfree (fusionee);
 
-  return 0;
+     return 0;
 }
 
 /******************************************************************************/
 
 static Fusionee *
-lookup_fusionee (int id)
+lookup_fusionee (FusionDev *dev, int id)
 {
-  FusionLink *l;
+     FusionLink *l;
 
-  spin_lock (&fusionees_lock);
+     spin_lock (&dev->fusionee.lock);
 
-  fusion_list_foreach (l, fusionees)
-    {
-      Fusionee *fusionee = (Fusionee *) l;
+     fusion_list_foreach (l, dev->fusionee.list) {
+          Fusionee *fusionee = (Fusionee *) l;
 
-      if (fusionee->id == id)
-        return fusionee;
-    }
+          if (fusionee->id == id)
+               return fusionee;
+     }
 
-  spin_unlock (&fusionees_lock);
+     spin_unlock (&dev->fusionee.lock);
 
-  return NULL;
+     return NULL;
 }
 
 static Fusionee *
-lock_fusionee (int id)
+lock_fusionee (FusionDev *dev, int id)
 {
-  Fusionee *fusionee = lookup_fusionee (id);
+     Fusionee *fusionee = lookup_fusionee (dev, id);
 
-  if (fusionee)
-    {
-      spin_lock (&fusionee->lock);
-      spin_unlock (&fusionees_lock);
-    }
+     if (fusionee) {
+          spin_lock (&fusionee->lock);
+          spin_unlock (&dev->fusionee.lock);
+     }
 
-  return fusionee;
+     return fusionee;
 }
 
 static void
 unlock_fusionee (Fusionee *fusionee)
 {
-  spin_unlock (&fusionee->lock);
+     spin_unlock (&fusionee->lock);
 }
+
diff --git a/drivers/char/fusion/fusionee.h b/drivers/char/fusion/fusionee.h
index 2e707ab..ed65052 100644
--- a/drivers/char/fusion/fusionee.h
+++ b/drivers/char/fusion/fusionee.h
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -18,29 +18,48 @@
 #include <linux/poll.h>
 #include <linux/fusion.h>
 
+#include "fusiondev.h"
 #include "types.h"
 
 
 /* module init/cleanup */
 
-int  fusionee_init (void);
-void fusionee_reset (void);
-void fusionee_cleanup (void);
+int  fusionee_init   (FusionDev *dev);
+void fusionee_deinit (FusionDev *dev);
 
 
 /* internal functions */
 
-int fusionee_new (int *id);
+int fusionee_new           (FusionDev         *dev,
+                            int               *id);
 
-int fusionee_send_message (int id, int recipient, FusionMessageType msg_type,
-                           int msg_id, int msg_size, const void *msg_data);
+int fusionee_send_message  (FusionDev         *dev,
+                            int                id,
+                            int                recipient,
+                            FusionMessageType  msg_type,
+                            int                msg_id,
+                            int                msg_size,
+                            const void        *msg_data);
 
-int fusionee_get_messages (int id, void *buf, int buf_size, int block);
+int fusionee_get_messages  (FusionDev         *dev,
+                            int                id,
+                            void              *buf,
+                            int                buf_size,
+                            bool               block);
 
-unsigned int fusionee_poll (int id, struct file *file, poll_table * wait);
+unsigned
+int fusionee_poll          (FusionDev         *dev,
+                            int                id,
+                            struct file       *file,
+                            poll_table        *wait);
 
-int fusionee_kill (int id, int target, int signal, int timeout_ms);
+int fusionee_kill          (FusionDev         *dev,
+                            int                id,
+                            int                target,
+                            int                signal,
+                            int                timeout_ms);
 
-int fusionee_destroy (int id);
+int fusionee_destroy       (FusionDev         *dev,
+                            int                id);
 
 #endif
diff --git a/drivers/char/fusion/list.c b/drivers/char/fusion/list.c
index 9dd0380..78bf4eb 100644
--- a/drivers/char/fusion/list.c
+++ b/drivers/char/fusion/list.c
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -45,18 +45,18 @@ fusion_list_remove (FusionLink **list, FusionLink *link)
 void
 fusion_list_move_to_front (FusionLink **list, FusionLink *link)
 {
-  if (*list == link)
-    return;
+     if (*list == link)
+          return;
 
-  link->prev->next = link->next;
+     link->prev->next = link->next;
 
-  if (link->next)
-    link->next->prev = link->prev;
+     if (link->next)
+          link->next->prev = link->prev;
 
-  link->prev = NULL;
-  link->next = *list;
+     link->prev = NULL;
+     link->next = *list;
 
-  (*list)->prev = link;
+     (*list)->prev = link;
 
-  *list = link;
+     *list = link;
 }
diff --git a/drivers/char/fusion/list.h b/drivers/char/fusion/list.h
index 1e5bb58..e0aea76 100644
--- a/drivers/char/fusion/list.h
+++ b/drivers/char/fusion/list.h
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -15,12 +15,9 @@
 #ifndef __FUSION__LIST_H__
 #define __FUSION__LIST_H__
 
-#include "types.h"
-
-
 typedef struct _FusionLink {
-  struct _FusionLink *next;
-  struct _FusionLink *prev;
+     struct _FusionLink *next;
+     struct _FusionLink *prev;
 } FusionLink;
 
 void fusion_list_prepend       (FusionLink **list, FusionLink *link);
diff --git a/drivers/char/fusion/property.c b/drivers/char/fusion/property.c
index 7c822bf..a3b8508 100644
--- a/drivers/char/fusion/property.c
+++ b/drivers/char/fusion/property.c
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -11,7 +11,7 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  */
- 
+
 #include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
@@ -33,418 +33,387 @@ typedef enum {
 } FusionPropertyState;
 
 typedef struct {
-  FusionLink          link;
+     FusionLink          link;
 
-  spinlock_t          lock;
+     spinlock_t          lock;
 
-  int                 id;
-  int                 pid;
+     int                 id;
+     int                 pid;
 
-  FusionPropertyState state;
-  int                 fusion_id; /* non-zero if leased/purchased */
-  unsigned long       purchase_stamp;
+     FusionPropertyState state;
+     int                 fusion_id; /* non-zero if leased/purchased */
+     unsigned long       purchase_stamp;
 
-  wait_queue_head_t   wait;
+     wait_queue_head_t   wait;
 } FusionProperty;
 
 /******************************************************************************/
 
-static FusionProperty *lookup_property     (int id);
+static FusionProperty *lookup_property     (FusionDev *dev, int id);
 
-static FusionProperty *lock_property       (int id);
+static FusionProperty *lock_property       (FusionDev *dev, int id);
 static void            unlock_property     (FusionProperty *property);
 
 /******************************************************************************/
 
-static int         ids             = 0;
-static FusionLink *properties      = NULL;
-static spinlock_t  properties_lock = SPIN_LOCK_UNLOCKED;
-
-/******************************************************************************/
-
 static int
-fusion_property_read_proc(char *buf, char **start, off_t offset,
+properties_read_proc(char *buf, char **start, off_t offset,
                      int len, int *eof, void *private)
 {
-  FusionLink *l;
-  int written = 0;
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
 
-  spin_lock (&properties_lock);
+     spin_lock (&dev->property.lock);
 
-  fusion_list_foreach (l, properties)
-    {
-      FusionProperty *property = (FusionProperty*) l;
+     fusion_list_foreach (l, dev->property.list) {
+          FusionProperty *property = (FusionProperty*) l;
 
-      written += sprintf(buf+written, "(%5d) 0x%08x %s\n",
-                         property->pid, property->id,
-                         property->state ?
-                           (property->state == FUSION_PROPERTY_LEASED ?
+          written += sprintf(buf+written, "(%5d) 0x%08x %s\n",
+                             property->pid, property->id,
+                             property->state ?
+                             (property->state == FUSION_PROPERTY_LEASED ?
                               "leased" : "purchased") :
-                           "");
-      if (written < offset)
-        {
-          offset -= written;
-          written = 0;
-        }
-
-      if (written >= len)
-        break;
-    }
-
-  spin_unlock (&properties_lock);
-
-  *start = buf + offset;
-  written -= offset;
-  if(written > len)
-    {
-      *eof = 0;
-      return len;
-    }
-
-  *eof = 1;
-  return (written<0) ? 0 : written;
+                             "");
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     spin_unlock (&dev->property.lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
 }
 
 int
-fusion_property_init()
+fusion_property_init (FusionDev *dev)
 {
-  create_proc_read_entry("properties", 0, proc_fusion_dir,
-                         fusion_property_read_proc, NULL);
+     dev->property.lock = SPIN_LOCK_UNLOCKED;
 
-  return 0;
+     create_proc_read_entry("properties", 0, dev->proc_dir,
+                            properties_read_proc, dev);
+
+     return 0;
 }
 
 void
-fusion_property_reset()
+fusion_property_deinit (FusionDev *dev)
 {
-  FusionLink *l;
-
-  spin_lock (&properties_lock);
-
-  l = properties;
-  while (l)
-    {
-      FusionLink     *next     = l->next;
-      FusionProperty *property = (FusionProperty *) l;
+     FusionLink *l;
 
-      kfree (property);
+     spin_lock (&dev->property.lock);
 
-      l = next;
-    }
-
-  ids        = 0;
-  properties = NULL;
+     remove_proc_entry ("properties", dev->proc_dir);
+     
+     l = dev->property.list;
+     while (l) {
+          FusionLink     *next     = l->next;
+          FusionProperty *property = (FusionProperty *) l;
 
-  spin_unlock (&properties_lock);
-}
+          kfree (property);
 
-void
-fusion_property_cleanup()
-{
-  fusion_property_reset();
+          l = next;
+     }
 
-  remove_proc_entry ("properties", proc_fusion_dir);
+     spin_unlock (&dev->property.lock);
 }
 
 /******************************************************************************/
 
 int
-fusion_property_new (int *id)
+fusion_property_new (FusionDev *dev, int *id)
 {
-  FusionProperty *property;
+     FusionProperty *property;
 
-  property = kmalloc (sizeof(FusionProperty), GFP_ATOMIC);
-  if (!property)
-    return -ENOMEM;
+     property = kmalloc (sizeof(FusionProperty), GFP_ATOMIC);
+     if (!property)
+          return -ENOMEM;
 
-  memset (property, 0, sizeof(FusionProperty));
+     memset (property, 0, sizeof(FusionProperty));
 
-  spin_lock (&properties_lock);
+     spin_lock (&dev->property.lock);
 
-  property->id   = ids++;
-  property->pid  = current->pid;
-  property->lock = SPIN_LOCK_UNLOCKED;
+     property->id   = dev->property.ids++;
+     property->pid  = current->pid;
+     property->lock = SPIN_LOCK_UNLOCKED;
 
-  init_waitqueue_head (&property->wait);
+     init_waitqueue_head (&property->wait);
 
-  fusion_list_prepend (&properties, &property->link);
+     fusion_list_prepend (&dev->property.list, &property->link);
 
-  spin_unlock (&properties_lock);
+     spin_unlock (&dev->property.lock);
 
-  *id = property->id;
+     *id = property->id;
 
-  return 0;
+     return 0;
 }
 
 int
-fusion_property_lease (int id, int fusion_id)
+fusion_property_lease (FusionDev *dev, int id, int fusion_id)
 {
-  FusionProperty *property;
-  signed long     timeout = -1;
+     FusionProperty *property;
+     signed long     timeout = -1;
 
-  while (true)
-    {
-      property = lock_property (id);
-      if (!property)
-        return -EINVAL;
+     while (true) {
+          property = lock_property (dev, id);
+          if (!property)
+               return -EINVAL;
 
-      switch (property->state)
-        {
-        case FUSION_PROPERTY_AVAILABLE:
-          property->state     = FUSION_PROPERTY_LEASED;
-          property->fusion_id = fusion_id;
+          switch (property->state) {
+               case FUSION_PROPERTY_AVAILABLE:
+                    property->state     = FUSION_PROPERTY_LEASED;
+                    property->fusion_id = fusion_id;
 
-          unlock_property (property);
-          return 0;
+                    unlock_property (property);
+                    return 0;
 
-        case FUSION_PROPERTY_LEASED:
-          fusion_sleep_on (&property->wait, &property->lock, NULL);
+               case FUSION_PROPERTY_LEASED:
+                    fusion_sleep_on (&property->wait, &property->lock, NULL);
 
-          if (signal_pending(current))
-            return -ERESTARTSYS;
+                    if (signal_pending(current))
+                         return -ERESTARTSYS;
 
-          break;
+                    break;
 
-        case FUSION_PROPERTY_PURCHASED:
-          switch (timeout)
-            {
-            case -1:
-              if (jiffies - property->purchase_stamp > HZ / 10)
-                {
-                case 0:
-                  unlock_property (property);
-                  return -EAGAIN;
-                }
-              else
-                timeout = HZ / 10;
+               case FUSION_PROPERTY_PURCHASED:
+                    switch (timeout) {
+                         case -1:
+                              if (jiffies - property->purchase_stamp > HZ / 10) {
+                         case 0:
+                                   unlock_property (property);
+                                   return -EAGAIN;
+                              }
+                              else
+                                   timeout = HZ / 10;
 
-              /* fall through */
+                              /* fall through */
 
-            default:
-              fusion_sleep_on (&property->wait, &property->lock, &timeout);
-     
-              if (signal_pending(current))
-                return -ERESTARTSYS;
+                         default:
+                              fusion_sleep_on (&property->wait, &property->lock, &timeout);
 
-              break;
-            }
-     
-          break;
-        }
-    }
+                              if (signal_pending(current))
+                                   return -ERESTARTSYS;
+
+                              break;
+                    }
 
-  /* won't reach this */
-  return 0;
+                    break;
+          }
+     }
+
+     /* won't reach this */
+     return 0;
 }
 
 int
-fusion_property_purchase (int id, int fusion_id)
+fusion_property_purchase (FusionDev *dev, int id, int fusion_id)
 {
-  FusionProperty *property;
-  signed long     timeout = -1;
+     FusionProperty *property;
+     signed long     timeout = -1;
 
-  while (true)
-    {
-      property = lock_property (id);
-      if (!property)
-        return -EINVAL;
+     while (true) {
+          property = lock_property (dev, id);
+          if (!property)
+               return -EINVAL;
 
-      switch (property->state)
-        {
-        case FUSION_PROPERTY_AVAILABLE:
-          property->state          = FUSION_PROPERTY_PURCHASED;
-          property->fusion_id      = fusion_id;
-          property->purchase_stamp = jiffies;
+          switch (property->state) {
+               case FUSION_PROPERTY_AVAILABLE:
+                    property->state          = FUSION_PROPERTY_PURCHASED;
+                    property->fusion_id      = fusion_id;
+                    property->purchase_stamp = jiffies;
 
-          wake_up_interruptible_all (&property->wait);
+                    wake_up_interruptible_all (&property->wait);
 
-          unlock_property (property);
-          return 0;
+                    unlock_property (property);
+                    return 0;
 
-        case FUSION_PROPERTY_LEASED:
-          fusion_sleep_on (&property->wait, &property->lock, NULL);
+               case FUSION_PROPERTY_LEASED:
+                    fusion_sleep_on (&property->wait, &property->lock, NULL);
 
-          if (signal_pending(current))
-            return -ERESTARTSYS;
+                    if (signal_pending(current))
+                         return -ERESTARTSYS;
 
-          break;
+                    break;
 
-        case FUSION_PROPERTY_PURCHASED:
-          switch (timeout)
-            {
-            case -1:
-              if (jiffies - property->purchase_stamp > HZ)
-                {
-                case 0:
-                  unlock_property (property);
-                  return -EAGAIN;
-                }
-              else
-                timeout = HZ;
+               case FUSION_PROPERTY_PURCHASED:
+                    switch (timeout) {
+                         case -1:
+                              if (jiffies - property->purchase_stamp > HZ) {
+                         case 0:
+                                   unlock_property (property);
+                                   return -EAGAIN;
+                              }
+                              else
+                                   timeout = HZ;
 
-              /* fall through */
+                              /* fall through */
 
-            default:
-              fusion_sleep_on (&property->wait, &property->lock, &timeout);
-     
-              if (signal_pending(current))
-                return -ERESTARTSYS;
+                         default:
+                              fusion_sleep_on (&property->wait, &property->lock, &timeout);
 
-              break;
-            }
+                              if (signal_pending(current))
+                                   return -ERESTARTSYS;
 
-          break;
-        }
-    }
+                              break;
+                    }
 
-  /* won't reach this */
-  return 0;
+                    break;
+          }
+     }
+
+     /* won't reach this */
+     return 0;
 }
 
 int
-fusion_property_cede (int id, int fusion_id)
+fusion_property_cede (FusionDev *dev, int id, int fusion_id)
 {
-  bool            purchased;
-  FusionProperty *property = lock_property (id);
+     bool            purchased;
+     FusionProperty *property = lock_property (dev, id);
 
-  if (!property)
-    return -EINVAL;
+     if (!property)
+          return -EINVAL;
 
-  if (property->fusion_id != fusion_id)
-    {
-      unlock_property (property);
-      return -EIO;
-    }
+     if (property->fusion_id != fusion_id) {
+          unlock_property (property);
+          return -EIO;
+     }
 
-  purchased = (property->state == FUSION_PROPERTY_PURCHASED);
+     purchased = (property->state == FUSION_PROPERTY_PURCHASED);
 
-  property->state     = FUSION_PROPERTY_AVAILABLE;
-  property->fusion_id = 0;
+     property->state     = FUSION_PROPERTY_AVAILABLE;
+     property->fusion_id = 0;
 
-  wake_up_interruptible_all (&property->wait);
+     wake_up_interruptible_all (&property->wait);
 
-  unlock_property (property);
+     unlock_property (property);
 
-  if (purchased)
-    yield();
+     if (purchased)
+          yield();
 
-  return 0;
+     return 0;
 }
 
 int
-fusion_property_holdup (int id, int fusion_id)
+fusion_property_holdup (FusionDev *dev, int id, int fusion_id)
 {
-  FusionProperty *property = lock_property (id);
+     FusionProperty *property = lock_property (dev, id);
 
-  if (!property)
-    return -EINVAL;
+     if (!property)
+          return -EINVAL;
 
-  if (property->state == FUSION_PROPERTY_PURCHASED)
-    {
-      if (property->fusion_id == fusion_id)
-        {
-          unlock_property (property);
-          return -EIO;
-        }
+     if (property->state == FUSION_PROPERTY_PURCHASED) {
+          if (property->fusion_id == fusion_id) {
+               unlock_property (property);
+               return -EIO;
+          }
 
-      fusionee_kill (fusion_id, property->fusion_id, SIGKILL, -1);
-    }
+          fusionee_kill (dev, fusion_id, property->fusion_id, SIGKILL, -1);
+     }
 
-  unlock_property (property);
+     unlock_property (property);
 
-  return 0;
+     return 0;
 }
 
 int
-fusion_property_destroy (int id)
+fusion_property_destroy (FusionDev *dev, int id)
 {
-  FusionProperty *property = lookup_property (id);
+     FusionProperty *property = lookup_property (dev, id);
+
+     if (!property)
+          return -EINVAL;
 
-  if (!property)
-    return -EINVAL;
+     spin_lock (&property->lock);
 
-  spin_lock (&property->lock);
+     fusion_list_remove (&dev->property.list, &property->link);
 
-  fusion_list_remove (&properties, &property->link);
+     wake_up_interruptible_all (&property->wait);
 
-  wake_up_interruptible_all (&property->wait);
+     spin_unlock (&dev->property.lock);
 
-  spin_unlock (&properties_lock);
+     spin_unlock (&property->lock);
 
-  spin_unlock (&property->lock);
-  
-  kfree (property);
+     kfree (property);
 
-  return 0;
+     return 0;
 }
 
 void
-fusion_property_cede_all (int fusion_id)
+fusion_property_cede_all (FusionDev *dev, int fusion_id)
 {
-  FusionLink *l;
+     FusionLink *l;
 
-  spin_lock (&properties_lock);
+     spin_lock (&dev->property.lock);
 
-  fusion_list_foreach (l, properties)
-    {
-      FusionProperty *property = (FusionProperty *) l;
+     fusion_list_foreach (l, dev->property.list) {
+          FusionProperty *property = (FusionProperty *) l;
 
-      spin_lock (&property->lock);
+          spin_lock (&property->lock);
 
-      if (property->fusion_id == fusion_id)
-        {
-          property->state     = FUSION_PROPERTY_AVAILABLE;
-          property->fusion_id = 0;
+          if (property->fusion_id == fusion_id) {
+               property->state     = FUSION_PROPERTY_AVAILABLE;
+               property->fusion_id = 0;
 
-          wake_up_interruptible_all (&property->wait);
-        }
+               wake_up_interruptible_all (&property->wait);
+          }
 
-      spin_unlock (&property->lock);
-    }
+          spin_unlock (&property->lock);
+     }
 
-  spin_unlock (&properties_lock);
+     spin_unlock (&dev->property.lock);
 }
 
 /******************************************************************************/
 
 static FusionProperty *
-lookup_property (int id)
+lookup_property (FusionDev *dev, int id)
 {
-  FusionLink *l;
+     FusionLink *l;
 
-  spin_lock (&properties_lock);
+     spin_lock (&dev->property.lock);
 
-  fusion_list_foreach (l, properties)
-    {
-      FusionProperty *property = (FusionProperty *) l;
+     fusion_list_foreach (l, dev->property.list) {
+          FusionProperty *property = (FusionProperty *) l;
 
-      if (property->id == id)
-        return property;
-    }
+          if (property->id == id)
+               return property;
+     }
 
-  spin_unlock (&properties_lock);
+     spin_unlock (&dev->property.lock);
 
-  return NULL;
+     return NULL;
 }
 
 static FusionProperty *
-lock_property (int id)
+lock_property (FusionDev *dev, int id)
 {
-  FusionProperty *property = lookup_property (id);
+     FusionProperty *property = lookup_property (dev, id);
 
-  if (property)
-    {
-      fusion_list_move_to_front (&properties, &property->link);
+     if (property) {
+          fusion_list_move_to_front (&dev->property.list, &property->link);
 
-      spin_lock (&property->lock);
-      spin_unlock (&properties_lock);
-    }
+          spin_lock (&property->lock);
+          spin_unlock (&dev->property.lock);
+     }
 
-  return property;
+     return property;
 }
 
 static void
 unlock_property (FusionProperty *property)
 {
-  spin_unlock (&property->lock);
+     spin_unlock (&property->lock);
 }
diff --git a/drivers/char/fusion/property.h b/drivers/char/fusion/property.h
index 623ce1d..da5c959 100644
--- a/drivers/char/fusion/property.h
+++ b/drivers/char/fusion/property.h
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -15,28 +15,44 @@
 #ifndef __FUSION__PROPERTY_H__
 #define __FUSION__PROPERTY_H__
 
+#include "fusiondev.h"
 #include "types.h"
 
 
 /* module init/cleanup */
 
-int  fusion_property_init (void);
-void fusion_property_reset (void);
-void fusion_property_cleanup (void);
+int  fusion_property_init   (FusionDev *dev);
+void fusion_property_deinit (FusionDev *dev);
 
 
 /* public API */
 
-int fusion_property_new (int *id);
-int fusion_property_lease (int id, int fusion_id);
-int fusion_property_purchase (int id, int fusion_id);
-int fusion_property_cede (int id, int fusion_id);
-int fusion_property_holdup (int id, int fusion_id);
-int fusion_property_destroy (int id);
+int fusion_property_new      (FusionDev *dev,
+                              int       *id);
+
+int fusion_property_lease    (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_purchase (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_cede     (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_holdup   (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_destroy  (FusionDev *dev,
+                              int        id);
 
 
 /* internal functions */
 
-void fusion_property_cede_all (int fusion_id);
+void fusion_property_cede_all (FusionDev *dev,
+                               int        fusion_id);
 
 #endif
diff --git a/drivers/char/fusion/reactor.c b/drivers/char/fusion/reactor.c
index aede742..ea6be56 100644
--- a/drivers/char/fusion/reactor.c
+++ b/drivers/char/fusion/reactor.c
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -11,7 +11,7 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  */
- 
+
 #include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
@@ -27,29 +27,29 @@
 #include "reactor.h"
 
 typedef struct {
-  FusionLink         link;
+     FusionLink         link;
 
-  int                fusion_id;
+     int                fusion_id;
 
-  int                count;     /* number of attach calls */
+     int                count;     /* number of attach calls */
 } ReactorNode;
 
 typedef struct {
-  FusionLink         link;
+     FusionLink         link;
 
-  spinlock_t         lock;
+     spinlock_t         lock;
 
-  int                id;
-  int                pid;
+     int                id;
+     int                pid;
 
-  FusionLink        *nodes;
+     FusionLink        *nodes;
 } FusionReactor;
 
 /******************************************************************************/
 
-static FusionReactor *lookup_reactor     (int id);
+static FusionReactor *lookup_reactor     (FusionDev *dev, int id);
 
-static FusionReactor *lock_reactor       (int id);
+static FusionReactor *lock_reactor       (FusionDev *dev, int id);
 static void           unlock_reactor     (FusionReactor *reactor);
 
 static ReactorNode   *get_node           (FusionReactor *reactor,
@@ -60,343 +60,315 @@ static void           free_all_nodes     (FusionReactor *reactor);
 
 /******************************************************************************/
 
-static int         ids           = 0;
-static FusionLink *reactors      = NULL;
-static spinlock_t  reactors_lock = SPIN_LOCK_UNLOCKED;
-
-/******************************************************************************/
-
 static int
-fusion_reactor_read_proc(char *buf, char **start, off_t offset,
-                         int len, int *eof, void *private)
+reactors_read_proc(char *buf, char **start, off_t offset,
+                   int len, int *eof, void *private)
 {
-  FusionLink *l;
-  int written = 0;
-
-  spin_lock (&reactors_lock);
-
-  fusion_list_foreach (l, reactors)
-    {
-      FusionReactor *reactor = (FusionReactor*) l;
-
-      written += sprintf(buf+written, "(%5d) 0x%08x %s\n", reactor->pid,
-                         reactor->id, reactor->nodes ? "" : "(none attached)");
-      if (written < offset)
-        {
-          offset -= written;
-          written = 0;
-        }
-
-      if (written >= len)
-        break;
-    }
-
-  spin_unlock (&reactors_lock);
-
-  *start = buf + offset;
-  written -= offset;
-  if(written > len)
-    {
-      *eof = 0;
-      return len;
-    }
-
-  *eof = 1;
-  return (written<0) ? 0 : written;
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
+
+     spin_lock (&dev->reactor.lock);
+
+     fusion_list_foreach (l, dev->reactor.list) {
+          FusionReactor *reactor = (FusionReactor*) l;
+
+          written += sprintf(buf+written, "(%5d) 0x%08x %s\n", reactor->pid,
+                             reactor->id, reactor->nodes ? "" : "(none attached)");
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     spin_unlock (&dev->reactor.lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
 }
 
 int
-fusion_reactor_init()
+fusion_reactor_init (FusionDev *dev)
 {
-  create_proc_read_entry("reactors", 0, proc_fusion_dir,
-                         fusion_reactor_read_proc, NULL);
+     dev->reactor.lock = SPIN_LOCK_UNLOCKED;
+
+     create_proc_read_entry("reactors", 0, dev->proc_dir,
+                            reactors_read_proc, dev);
 
-  return 0;
+     return 0;
 }
 
 void
-fusion_reactor_reset()
+fusion_reactor_deinit (FusionDev *dev)
 {
-  FusionLink *l;
+     FusionLink *l;
 
-  spin_lock (&reactors_lock);
+     spin_lock (&dev->reactor.lock);
 
-  l = reactors;
-  while (l)
-    {
-      FusionLink    *next    = l->next;
-      FusionReactor *reactor = (FusionReactor *) l;
+     remove_proc_entry ("reactors", dev->proc_dir);
+     
+     l = dev->reactor.list;
+     while (l) {
+          FusionLink    *next    = l->next;
+          FusionReactor *reactor = (FusionReactor *) l;
 
-      free_all_nodes (reactor);
-          
-      kfree (reactor);
+          free_all_nodes (reactor);
 
-      l = next;
-    }
+          kfree (reactor);
 
-  ids      = 0;
-  reactors = NULL;
+          l = next;
+     }
 
-  spin_unlock (&reactors_lock);
-}
-
-void
-fusion_reactor_cleanup()
-{
-  fusion_reactor_reset();
-
-  remove_proc_entry ("reactors", proc_fusion_dir);
+     spin_unlock (&dev->reactor.lock);
 }
 
 /******************************************************************************/
 
 int
-fusion_reactor_new (int *id)
+fusion_reactor_new (FusionDev *dev, int *id)
 {
-  FusionReactor *reactor;
+     FusionReactor *reactor;
 
-  reactor = kmalloc (sizeof(FusionReactor), GFP_ATOMIC);
-  if (!reactor)
-    return -ENOMEM;
+     reactor = kmalloc (sizeof(FusionReactor), GFP_ATOMIC);
+     if (!reactor)
+          return -ENOMEM;
 
-  memset (reactor, 0, sizeof(FusionReactor));
+     memset (reactor, 0, sizeof(FusionReactor));
 
-  spin_lock (&reactors_lock);
+     spin_lock (&dev->reactor.lock);
 
-  reactor->id   = ids++;
-  reactor->pid  = current->pid;
-  reactor->lock = SPIN_LOCK_UNLOCKED;
+     reactor->id   = dev->reactor.ids++;
+     reactor->pid  = current->pid;
+     reactor->lock = SPIN_LOCK_UNLOCKED;
 
-  fusion_list_prepend (&reactors, &reactor->link);
+     fusion_list_prepend (&dev->reactor.list, &reactor->link);
 
-  spin_unlock (&reactors_lock);
+     spin_unlock (&dev->reactor.lock);
 
-  *id = reactor->id;
+     *id = reactor->id;
 
-  return 0;
+     return 0;
 }
 
 int
-fusion_reactor_attach (int id, int fusion_id)
+fusion_reactor_attach (FusionDev *dev, int id, int fusion_id)
 {
-  ReactorNode   *node;
-  FusionReactor *reactor = lock_reactor (id);
-
-  if (!reactor)
-    return -EINVAL;
-
-  node = get_node (reactor, fusion_id);
-  if (!node)
-    {
-      node = kmalloc (sizeof(ReactorNode), GFP_ATOMIC);
-      if (!node)
-        {
-          unlock_reactor (reactor);
-          return -ENOMEM;
-        }
+     ReactorNode   *node;
+     FusionReactor *reactor = lock_reactor (dev, id);
+
+     if (!reactor)
+          return -EINVAL;
 
-      node->fusion_id = fusion_id;
-      node->count     = 1;
+     node = get_node (reactor, fusion_id);
+     if (!node) {
+          node = kmalloc (sizeof(ReactorNode), GFP_ATOMIC);
+          if (!node) {
+               unlock_reactor (reactor);
+               return -ENOMEM;
+          }
 
-      fusion_list_prepend (&reactor->nodes, &node->link);
-    }
-  else
-    node->count++;
+          node->fusion_id = fusion_id;
+          node->count     = 1;
 
-  unlock_reactor (reactor);
+          fusion_list_prepend (&reactor->nodes, &node->link);
+     }
+     else
+          node->count++;
 
-  return 0;
+     unlock_reactor (reactor);
+
+     return 0;
 }
 
 int
-fusion_reactor_detach (int id, int fusion_id)
+fusion_reactor_detach (FusionDev *dev, int id, int fusion_id)
 {
-  ReactorNode   *node;
-  FusionReactor *reactor = lock_reactor (id);
+     ReactorNode   *node;
+     FusionReactor *reactor = lock_reactor (dev, id);
 
-  if (!reactor)
-    return -EINVAL;
+     if (!reactor)
+          return -EINVAL;
 
-  node = get_node (reactor, fusion_id);
-  if (!node)
-    {
-      unlock_reactor (reactor);
-      return -EIO;
-    }
+     node = get_node (reactor, fusion_id);
+     if (!node) {
+          unlock_reactor (reactor);
+          return -EIO;
+     }
 
-  if (! --node->count)
-    {
-      fusion_list_remove (&reactor->nodes, &node->link);
-      kfree (node);
-    }
+     if (! --node->count) {
+          fusion_list_remove (&reactor->nodes, &node->link);
+          kfree (node);
+     }
 
-  unlock_reactor (reactor);
+     unlock_reactor (reactor);
 
-  return 0;
+     return 0;
 }
 
 int
-fusion_reactor_dispatch (int id, int fusion_id,
+fusion_reactor_dispatch (FusionDev *dev, int id, int fusion_id,
                          int msg_size, const void *msg_data)
 {
-  FusionLink    *l;
-  FusionReactor *reactor = lock_reactor (id);
+     FusionLink    *l;
+     FusionReactor *reactor = lock_reactor (dev, id);
 
-  if (!reactor)
-    return -EINVAL;
+     if (!reactor)
+          return -EINVAL;
 
-  fusion_list_foreach (l, reactor->nodes)
-    {
-      ReactorNode *node = (ReactorNode *) l;
+     fusion_list_foreach (l, reactor->nodes) {
+          ReactorNode *node = (ReactorNode *) l;
 
-      if (node->fusion_id == fusion_id)
-        continue;
+          if (node->fusion_id == fusion_id)
+               continue;
 
-      fusionee_send_message (fusion_id, node->fusion_id, FMT_REACTOR,
-                             reactor->id, msg_size, msg_data);
-    }
+          fusionee_send_message (dev, fusion_id, node->fusion_id, FMT_REACTOR,
+                                 reactor->id, msg_size, msg_data);
+     }
 
-  unlock_reactor (reactor);
+     unlock_reactor (reactor);
 
-  return 0;
+     return 0;
 }
 
 int
-fusion_reactor_destroy (int id)
+fusion_reactor_destroy (FusionDev *dev, int id)
 {
-  FusionReactor *reactor = lookup_reactor (id);
+     FusionReactor *reactor = lookup_reactor (dev, id);
+
+     if (!reactor)
+          return -EINVAL;
 
-  if (!reactor)
-    return -EINVAL;
+     spin_lock (&reactor->lock);
 
-  spin_lock (&reactor->lock);
+     fusion_list_remove (&dev->reactor.list, &reactor->link);
 
-  fusion_list_remove (&reactors, &reactor->link);
+     spin_unlock (&dev->reactor.lock);
 
-  spin_unlock (&reactors_lock);
+     free_all_nodes (reactor);
 
-  free_all_nodes (reactor);
+     spin_unlock (&reactor->lock);
 
-  spin_unlock (&reactor->lock);
-  
-  kfree (reactor);
+     kfree (reactor);
 
-  return 0;
+     return 0;
 }
 
 void
-fusion_reactor_detach_all (int fusion_id)
+fusion_reactor_detach_all (FusionDev *dev, int fusion_id)
 {
-  FusionLink *l;
+     FusionLink *l;
 
-  spin_lock (&reactors_lock);
+     spin_lock (&dev->reactor.lock);
 
-  fusion_list_foreach (l, reactors)
-    {
-      FusionReactor *reactor = (FusionReactor *) l;
+     fusion_list_foreach (l, dev->reactor.list) {
+          FusionReactor *reactor = (FusionReactor *) l;
 
-      remove_node (reactor, fusion_id);
-    }
+          remove_node (reactor, fusion_id);
+     }
 
-  spin_unlock (&reactors_lock);
+     spin_unlock (&dev->reactor.lock);
 }
 
 /******************************************************************************/
 
 static FusionReactor *
-lookup_reactor (int id)
+lookup_reactor (FusionDev *dev, int id)
 {
-  FusionLink *l;
+     FusionLink *l;
 
-  spin_lock (&reactors_lock);
+     spin_lock (&dev->reactor.lock);
 
-  fusion_list_foreach (l, reactors)
-    {
-      FusionReactor *reactor = (FusionReactor *) l;
+     fusion_list_foreach (l, dev->reactor.list) {
+          FusionReactor *reactor = (FusionReactor *) l;
 
-      if (reactor->id == id)
-        return reactor;
-    }
+          if (reactor->id == id)
+               return reactor;
+     }
 
-  spin_unlock (&reactors_lock);
+     spin_unlock (&dev->reactor.lock);
 
-  return NULL;
+     return NULL;
 }
 
 static FusionReactor *
-lock_reactor (int id)
+lock_reactor (FusionDev *dev, int id)
 {
-  FusionReactor *reactor = lookup_reactor (id);
+     FusionReactor *reactor = lookup_reactor (dev, id);
 
-  if (reactor)
-    {
-      fusion_list_move_to_front (&reactors, &reactor->link);
+     if (reactor) {
+          fusion_list_move_to_front (&dev->reactor.list, &reactor->link);
 
-      spin_lock (&reactor->lock);
-      spin_unlock (&reactors_lock);
-    }
+          spin_lock (&reactor->lock);
+          spin_unlock (&dev->reactor.lock);
+     }
 
-  return reactor;
+     return reactor;
 }
 
 static void
 unlock_reactor (FusionReactor *reactor)
 {
-  spin_unlock (&reactor->lock);
+     spin_unlock (&reactor->lock);
 }
 
 static ReactorNode *
 get_node (FusionReactor *reactor,
           int            fusion_id)
 {
-  FusionLink *l;
+     FusionLink *l;
 
-  fusion_list_foreach (l, reactor->nodes)
-    {
-      ReactorNode *node = (ReactorNode *) l;
+     fusion_list_foreach (l, reactor->nodes) {
+          ReactorNode *node = (ReactorNode *) l;
 
-      if (node->fusion_id == fusion_id)
-        return node;
-    }
+          if (node->fusion_id == fusion_id)
+               return node;
+     }
 
-  return NULL;
+     return NULL;
 }
 
 static void
 remove_node (FusionReactor *reactor, int fusion_id)
 {
-  FusionLink *l;
+     FusionLink *l;
 
-  spin_lock (&reactor->lock);
+     spin_lock (&reactor->lock);
 
-  fusion_list_foreach (l, reactor->nodes)
-    {
-      ReactorNode *node = (ReactorNode *) l;
+     fusion_list_foreach (l, reactor->nodes) {
+          ReactorNode *node = (ReactorNode *) l;
 
-      if (node->fusion_id == fusion_id)
-        {
-          fusion_list_remove (&reactor->nodes, l);
-          break;
-        }
-    }
+          if (node->fusion_id == fusion_id) {
+               fusion_list_remove (&reactor->nodes, l);
+               break;
+          }
+     }
 
-  spin_unlock (&reactor->lock);
+     spin_unlock (&reactor->lock);
 }
 
 static void
 free_all_nodes (FusionReactor *reactor)
 
 {
-  FusionLink *l = reactor->nodes;
+     FusionLink *l = reactor->nodes;
 
-  while (l)
-    {
-      FusionLink *next = l->next;
+     while (l) {
+          FusionLink *next = l->next;
 
-      kfree (l);
+          kfree (l);
 
-      l = next;
-    }
+          l = next;
+     }
 
-  reactor->nodes = NULL;
+     reactor->nodes = NULL;
 }
diff --git a/drivers/char/fusion/reactor.h b/drivers/char/fusion/reactor.h
index ec53158..ac14c5e 100644
--- a/drivers/char/fusion/reactor.h
+++ b/drivers/char/fusion/reactor.h
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -15,28 +15,42 @@
 #ifndef __FUSION__REACTOR_H__
 #define __FUSION__REACTOR_H__
 
+#include "fusiondev.h"
 #include "types.h"
 
 
 /* module init/cleanup */
 
-int  fusion_reactor_init (void);
-void fusion_reactor_reset (void);
-void fusion_reactor_cleanup (void);
+int  fusion_reactor_init   (FusionDev *dev);
+void fusion_reactor_deinit (FusionDev *dev);
 
 
 /* public API */
 
-int fusion_reactor_new (int *id);
-int fusion_reactor_attach (int id, int fusion_id);
-int fusion_reactor_detach (int id, int fusion_id);
-int fusion_reactor_dispatch (int id, int fusion_id,
-                             int msg_size, const void *msg_data);
-int fusion_reactor_destroy (int id);
+int fusion_reactor_new      (FusionDev  *dev,
+                             int        *id);
+
+int fusion_reactor_attach   (FusionDev  *dev,
+                             int         id,
+                             int         fusion_id);
+
+int fusion_reactor_detach   (FusionDev  *dev,
+                             int         id,
+                             int         fusion_id);
+
+int fusion_reactor_dispatch (FusionDev  *dev,
+                             int         id,
+                             int         fusion_id,
+                             int         msg_size,
+                             const void *msg_data);
+
+int fusion_reactor_destroy  (FusionDev  *dev,
+                             int         id);
 
 
 /* internal functions */
 
-void fusion_reactor_detach_all (int fusion_id);
+void fusion_reactor_detach_all (FusionDev *dev,
+                                int        fusion_id);
 
 #endif
diff --git a/drivers/char/fusion/ref.c b/drivers/char/fusion/ref.c
index 4c7a873..0919c3d 100644
--- a/drivers/char/fusion/ref.c
+++ b/drivers/char/fusion/ref.c
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -11,7 +11,7 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  */
- 
+
 #include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
@@ -26,34 +26,34 @@
 #include "ref.h"
 
 typedef struct {
-  FusionLink  link;
-  int         fusion_id;
-  int         refs;
+     FusionLink  link;
+     int         fusion_id;
+     int         refs;
 } LocalRef;
 
 typedef struct {
-  FusionLink         link;
+     FusionLink         link;
 
-  spinlock_t         lock;
+     spinlock_t         lock;
 
-  int                id;
-  int                pid;
+     int                id;
+     int                pid;
 
-  int                global;
-  int                local;
+     int                global;
+     int                local;
 
-  int                locked;    /* non-zero fusion id of lock owner */
+     int                locked;    /* non-zero fusion id of lock owner */
 
-  FusionLink        *local_refs;
+     FusionLink        *local_refs;
 
-  wait_queue_head_t  wait;
+     wait_queue_head_t  wait;
 } FusionRef;
 
 /******************************************************************************/
 
-static FusionRef *lookup_ref     (int id);
+static FusionRef *lookup_ref     (FusionDev *dev, int id);
 
-static FusionRef *lock_ref       (int id);
+static FusionRef *lock_ref       (FusionDev *dev, int id);
 static void       unlock_ref     (FusionRef *ref);
 
 static int        add_local      (FusionRef *ref, int fusion_id, int add);
@@ -62,468 +62,432 @@ static void       free_all_local (FusionRef *ref);
 
 /******************************************************************************/
 
-static int         ids       = 0;
-static FusionLink *refs      = NULL;
-static spinlock_t  refs_lock = SPIN_LOCK_UNLOCKED;
-
-/******************************************************************************/
-
 static int
-fusion_ref_read_proc(char *buf, char **start, off_t offset,
-                     int len, int *eof, void *private)
+refs_read_proc(char *buf, char **start, off_t offset,
+               int len, int *eof, void *private)
 {
-  FusionLink *l;
-  int written = 0;
-
-  spin_lock (&refs_lock);
-
-  fusion_list_foreach (l, refs)
-    {
-      FusionRef *ref = (FusionRef*) l;
-
-      if (ref->locked)
-        written += sprintf(buf+written, "(%5d) 0x%08x %2d %2d (locked by %d)\n",
-                           ref->pid, ref->id, ref->global, ref->local,
-                           ref->locked);
-      else
-        written += sprintf(buf+written, "(%5d) 0x%08x %2d %2d\n",
-                           ref->pid, ref->id, ref->global, ref->local);
-      if (written < offset)
-        {
-          offset -= written;
-          written = 0;
-        }
-
-      if (written >= len)
-        break;
-    }
-
-  spin_unlock (&refs_lock);
-
-  *start = buf + offset;
-  written -= offset;
-  if(written > len)
-    {
-      *eof = 0;
-      return len;
-    }
-
-  *eof = 1;
-  return (written<0) ? 0 : written;
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
+
+     spin_lock (&dev->ref.lock);
+
+     fusion_list_foreach (l, dev->ref.list) {
+          FusionRef *ref = (FusionRef*) l;
+
+          if (ref->locked)
+               written += sprintf(buf+written, "(%5d) 0x%08x %2d %2d (locked by %d)\n",
+                                  ref->pid, ref->id, ref->global, ref->local,
+                                  ref->locked);
+          else
+               written += sprintf(buf+written, "(%5d) 0x%08x %2d %2d\n",
+                                  ref->pid, ref->id, ref->global, ref->local);
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     spin_unlock (&dev->ref.lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
 }
 
 int
-fusion_ref_init()
+fusion_ref_init (FusionDev *dev)
 {
-  create_proc_read_entry("refs", 0, proc_fusion_dir,
-                         fusion_ref_read_proc, NULL);
+     dev->ref.lock = SPIN_LOCK_UNLOCKED;
+
+     create_proc_read_entry("refs", 0, dev->proc_dir,
+                            refs_read_proc, dev);
 
-  return 0;
+     return 0;
 }
 
 void
-fusion_ref_reset()
+fusion_ref_deinit (FusionDev *dev)
 {
-  FusionLink *l;
-
-  spin_lock (&refs_lock);
+     FusionLink *l;
 
-  l = refs;
-  while (l)
-    {
-      FusionLink *next = l->next;
-      FusionRef  *ref  = (FusionRef *) l;
+     spin_lock (&dev->ref.lock);
 
-      free_all_local (ref);
+     remove_proc_entry ("refs", dev->proc_dir);
+     
+     l = dev->ref.list;
+     while (l) {
+          FusionLink *next = l->next;
+          FusionRef  *ref  = (FusionRef *) l;
 
-      kfree (ref);
+          free_all_local (ref);
 
-      l = next;
-    }
+          kfree (ref);
 
-  ids  = 0;
-  refs = NULL;
-
-  spin_unlock (&refs_lock);
-}
-
-void
-fusion_ref_cleanup()
-{
-  fusion_ref_reset();
+          l = next;
+     }
 
-  remove_proc_entry ("refs", proc_fusion_dir);
+     spin_unlock (&dev->ref.lock);
 }
 
 /******************************************************************************/
 
 int
-fusion_ref_new (int *id)
+fusion_ref_new (FusionDev *dev, int *id)
 {
-  FusionRef *ref;
+     FusionRef *ref;
 
-  ref = kmalloc (sizeof(FusionRef), GFP_ATOMIC);
-  if (!ref)
-    return -ENOMEM;
+     ref = kmalloc (sizeof(FusionRef), GFP_ATOMIC);
+     if (!ref)
+          return -ENOMEM;
 
-  memset (ref, 0, sizeof(FusionRef));
+     memset (ref, 0, sizeof(FusionRef));
 
-  spin_lock (&refs_lock);
+     spin_lock (&dev->ref.lock);
 
-  ref->id   = ids++;
-  ref->pid  = current->pid;
-  ref->lock = SPIN_LOCK_UNLOCKED;
+     ref->id   = dev->ref.ids++;
+     ref->pid  = current->pid;
+     ref->lock = SPIN_LOCK_UNLOCKED;
 
-  init_waitqueue_head (&ref->wait);
+     init_waitqueue_head (&ref->wait);
 
-  fusion_list_prepend (&refs, &ref->link);
+     fusion_list_prepend (&dev->ref.list, &ref->link);
 
-  spin_unlock (&refs_lock);
+     spin_unlock (&dev->ref.lock);
 
-  *id = ref->id;
+     *id = ref->id;
 
-  return 0;
+     return 0;
 }
 
 int
-fusion_ref_up (int id, int fusion_id)
+fusion_ref_up (FusionDev *dev, int id, int fusion_id)
 {
-  FusionRef *ref = lock_ref (id);
+     FusionRef *ref = lock_ref (dev, id);
 
-  if (!ref)
-    return -EINVAL;
+     if (!ref)
+          return -EINVAL;
 
-  if (ref->locked)
-    {
-      unlock_ref (ref);
-      return -EAGAIN;
-    }
+     if (ref->locked) {
+          unlock_ref (ref);
+          return -EAGAIN;
+     }
 
-  if (fusion_id)
-    {
-      int ret;
+     if (fusion_id) {
+          int ret;
 
-      ret = add_local (ref, fusion_id, 1);
-      if (ret)
-        {
-          unlock_ref (ref);
-          return ret;
-        }
+          ret = add_local (ref, fusion_id, 1);
+          if (ret) {
+               unlock_ref (ref);
+               return ret;
+          }
 
-      ref->local++;
-    }
-  else
-    ref->global++;
+          ref->local++;
+     }
+     else
+          ref->global++;
 
-  unlock_ref (ref);
+     unlock_ref (ref);
 
-  return 0;
+     return 0;
 }
 
 int
-fusion_ref_down (int id, int fusion_id)
+fusion_ref_down (FusionDev *dev, int id, int fusion_id)
 {
-  FusionRef *ref = lock_ref (id);
+     FusionRef *ref = lock_ref (dev, id);
 
-  if (!ref)
-    return -EINVAL;
+     if (!ref)
+          return -EINVAL;
 
-  if (ref->locked)
-    {
-      unlock_ref (ref);
-      return -EAGAIN;
-    }
+     if (ref->locked) {
+          unlock_ref (ref);
+          return -EAGAIN;
+     }
 
-  if (fusion_id)
-    {
-      int ret;
+     if (fusion_id) {
+          int ret;
 
-      if (!ref->local)
-        return -EIO;
+          if (!ref->local)
+               return -EIO;
 
-      ret = add_local (ref, fusion_id, -1);
-      if (ret)
-        {
-          unlock_ref (ref);
-          return ret;
-        }
+          ret = add_local (ref, fusion_id, -1);
+          if (ret) {
+               unlock_ref (ref);
+               return ret;
+          }
 
-      ref->local--;
-    }
-  else
-    {
-      if (!ref->global)
-        return -EIO;
+          ref->local--;
+     }
+     else {
+          if (!ref->global)
+               return -EIO;
 
-      ref->global--;
-    }
+          ref->global--;
+     }
 
-  if (ref->local + ref->global == 0)
-    wake_up_interruptible_all (&ref->wait);
+     if (ref->local + ref->global == 0)
+          wake_up_interruptible_all (&ref->wait);
 
-  unlock_ref (ref);
+     unlock_ref (ref);
 
-  return 0;
+     return 0;
 }
 
 int
-fusion_ref_zero_lock (int id, int fusion_id)
+fusion_ref_zero_lock (FusionDev *dev, int id, int fusion_id)
 {
-  FusionRef *ref;
+     FusionRef *ref;
 
-  while (true)
-    {
-      ref = lock_ref (id);
-      if (!ref)
-        return -EINVAL;
+     while (true) {
+          ref = lock_ref (dev, id);
+          if (!ref)
+               return -EINVAL;
 
-      if (ref->locked)
-        {
-          unlock_ref (ref);
+          if (ref->locked) {
+               unlock_ref (ref);
 
-          return ref->locked == fusion_id ? -EIO : -EAGAIN;
-        }
+               return ref->locked == fusion_id ? -EIO : -EAGAIN;
+          }
 
-      if (ref->global || ref->local)
-        {
-          fusion_sleep_on (&ref->wait, &ref->lock, 0);
+          if (ref->global || ref->local) {
+               fusion_sleep_on (&ref->wait, &ref->lock, 0);
 
-          if (signal_pending(current))
-            return -ERESTARTSYS;
-        }
-      else
-        break;
-    }
+               if (signal_pending(current))
+                    return -ERESTARTSYS;
+          }
+          else
+               break;
+     }
 
-  ref->locked = fusion_id;
+     ref->locked = fusion_id;
 
-  unlock_ref (ref);
+     unlock_ref (ref);
 
-  return 0;
+     return 0;
 }
 
 int
-fusion_ref_zero_trylock (int id, int fusion_id)
+fusion_ref_zero_trylock (FusionDev *dev, int id, int fusion_id)
 {
-  int        ret = 0;
-  FusionRef *ref = lock_ref (id);
+     int        ret = 0;
+     FusionRef *ref = lock_ref (dev, id);
 
-  if (!ref)
-    return -EINVAL;
+     if (!ref)
+          return -EINVAL;
 
-  if (ref->locked)
-    {
-      unlock_ref (ref);
-      return ref->locked == fusion_id ? -EIO : -EAGAIN;
-    }
+     if (ref->locked) {
+          unlock_ref (ref);
+          return ref->locked == fusion_id ? -EIO : -EAGAIN;
+     }
 
-  if (ref->global || ref->local)
-    ret = -ETOOMANYREFS;
-  else
-    ref->locked = fusion_id;
+     if (ref->global || ref->local)
+          ret = -ETOOMANYREFS;
+     else
+          ref->locked = fusion_id;
 
-  unlock_ref (ref);
+     unlock_ref (ref);
 
-  return ret;
+     return ret;
 }
 
 int
-fusion_ref_unlock (int id, int fusion_id)
+fusion_ref_unlock (FusionDev *dev, int id, int fusion_id)
 {
-  FusionRef *ref = lock_ref (id);
+     FusionRef *ref = lock_ref (dev, id);
 
-  if (!ref)
-    return -EINVAL;
+     if (!ref)
+          return -EINVAL;
 
-  if (ref->locked != fusion_id)
-    {
-      unlock_ref (ref);
-      return -EIO;
-    }
+     if (ref->locked != fusion_id) {
+          unlock_ref (ref);
+          return -EIO;
+     }
 
-  ref->locked = 0;
+     ref->locked = 0;
 
-  unlock_ref (ref);
+     unlock_ref (ref);
 
-  return 0;
+     return 0;
 }
 
 int
-fusion_ref_stat (int id, int *refs)
+fusion_ref_stat (FusionDev *dev, int id, int *refs)
 {
-  FusionRef *ref = lock_ref (id);
+     FusionRef *ref = lock_ref (dev, id);
 
-  if (!ref)
-    return -EINVAL;
+     if (!ref)
+          return -EINVAL;
 
-  *refs = ref->global + ref->local;
+     *refs = ref->global + ref->local;
 
-  unlock_ref (ref);
+     unlock_ref (ref);
 
-  return 0;
+     return 0;
 }
 
 int
-fusion_ref_destroy (int id)
+fusion_ref_destroy (FusionDev *dev, int id)
 {
-  FusionRef *ref = lookup_ref (id);
+     FusionRef *ref = lookup_ref (dev, id);
+
+     if (!ref)
+          return -EINVAL;
 
-  if (!ref)
-    return -EINVAL;
+     spin_lock (&ref->lock);
 
-  spin_lock (&ref->lock);
+     fusion_list_remove (&dev->ref.list, &ref->link);
 
-  fusion_list_remove (&refs, &ref->link);
+     wake_up_interruptible_all (&ref->wait);
 
-  wake_up_interruptible_all (&ref->wait);
+     spin_unlock (&dev->ref.lock);
 
-  spin_unlock (&refs_lock);
+     free_all_local (ref);
 
-  free_all_local (ref);
+     spin_unlock (&ref->lock);
 
-  spin_unlock (&ref->lock);
-  
-  kfree (ref);
+     kfree (ref);
 
-  return 0;
+     return 0;
 }
 
 void
-fusion_ref_clear_all_local (int fusion_id)
+fusion_ref_clear_all_local (FusionDev *dev, int fusion_id)
 {
-  FusionLink *l;
+     FusionLink *l;
 
-  spin_lock (&refs_lock);
+     spin_lock (&dev->ref.lock);
 
-  fusion_list_foreach (l, refs)
-    {
-      FusionRef *ref = (FusionRef *) l;
+     fusion_list_foreach (l, dev->ref.list) {
+          FusionRef *ref = (FusionRef *) l;
 
-      clear_local (ref, fusion_id);
-    }
+          clear_local (ref, fusion_id);
+     }
 
-  spin_unlock (&refs_lock);
+     spin_unlock (&dev->ref.lock);
 }
 
 /******************************************************************************/
 
 static FusionRef *
-lookup_ref (int id)
+lookup_ref (FusionDev *dev, int id)
 {
-  FusionLink *l;
+     FusionLink *l;
 
-  spin_lock (&refs_lock);
+     spin_lock (&dev->ref.lock);
 
-  fusion_list_foreach (l, refs)
-    {
-      FusionRef *ref = (FusionRef *) l;
+     fusion_list_foreach (l, dev->ref.list) {
+          FusionRef *ref = (FusionRef *) l;
 
-      if (ref->id == id)
-        return ref;
-    }
+          if (ref->id == id)
+               return ref;
+     }
 
-  spin_unlock (&refs_lock);
+     spin_unlock (&dev->ref.lock);
 
-  return NULL;
+     return NULL;
 }
 
 static FusionRef *
-lock_ref (int id)
+lock_ref (FusionDev *dev, int id)
 {
-  FusionRef *ref = lookup_ref (id);
+     FusionRef *ref = lookup_ref (dev, id);
 
-  if (ref)
-    {
-      fusion_list_move_to_front (&refs, &ref->link);
+     if (ref) {
+          fusion_list_move_to_front (&dev->ref.list, &ref->link);
 
-      spin_lock (&ref->lock);
-      spin_unlock (&refs_lock);
-    }
+          spin_lock (&ref->lock);
+          spin_unlock (&dev->ref.lock);
+     }
 
-  return ref;
+     return ref;
 }
 
 static void
 unlock_ref (FusionRef *ref)
 {
-  spin_unlock (&ref->lock);
+     spin_unlock (&ref->lock);
 }
 
 static int
 add_local (FusionRef *ref, int fusion_id, int add)
 {
-  FusionLink *l;
-  LocalRef   *local;
+     FusionLink *l;
+     LocalRef   *local;
 
-  fusion_list_foreach (l, ref->local_refs)
-    {
-      local = (LocalRef *) l;
+     fusion_list_foreach (l, ref->local_refs) {
+          local = (LocalRef *) l;
 
-      if (local->fusion_id == fusion_id)
-        {
-          if (local->refs + add < 0)
-            return -EIO;
+          if (local->fusion_id == fusion_id) {
+               if (local->refs + add < 0)
+                    return -EIO;
 
-          local->refs += add;
-          return 0;
-        }
-    }
+               local->refs += add;
+               return 0;
+          }
+     }
 
-  local = kmalloc (sizeof(LocalRef), GFP_ATOMIC);
-  if (!local)
-    return -ENOMEM;
+     local = kmalloc (sizeof(LocalRef), GFP_ATOMIC);
+     if (!local)
+          return -ENOMEM;
 
-  local->fusion_id = fusion_id;
-  local->refs      = add;
+     local->fusion_id = fusion_id;
+     local->refs      = add;
 
-  fusion_list_prepend (&ref->local_refs, &local->link);
+     fusion_list_prepend (&ref->local_refs, &local->link);
 
-  return 0;
+     return 0;
 }
 
 static void
 clear_local (FusionRef *ref, int fusion_id)
 {
-  FusionLink *l;
+     FusionLink *l;
 
-  spin_lock (&ref->lock);
+     spin_lock (&ref->lock);
 
-  if (ref->locked == fusion_id)
-    ref->locked = 0;
+     if (ref->locked == fusion_id)
+          ref->locked = 0;
 
-  fusion_list_foreach (l, ref->local_refs)
-    {
-      LocalRef *local = (LocalRef *) l;
+     fusion_list_foreach (l, ref->local_refs) {
+          LocalRef *local = (LocalRef *) l;
 
-      if (local->fusion_id == fusion_id)
-        {
-          ref->local -= local->refs;
+          if (local->fusion_id == fusion_id) {
+               ref->local -= local->refs;
 
-          if (ref->local + ref->global == 0)
-            wake_up_interruptible_all (&ref->wait);
+               if (ref->local + ref->global == 0)
+                    wake_up_interruptible_all (&ref->wait);
 
-          fusion_list_remove (&ref->local_refs, l);
+               fusion_list_remove (&ref->local_refs, l);
 
-          break;
-        }
-    }
+               break;
+          }
+     }
 
-  spin_unlock (&ref->lock);
+     spin_unlock (&ref->lock);
 }
 
 static void
 free_all_local (FusionRef *ref)
 {
-  FusionLink *l = ref->local_refs;
+     FusionLink *l = ref->local_refs;
 
-  while (l)
-    {
-      FusionLink *next = l->next;
+     while (l) {
+          FusionLink *next = l->next;
 
-      kfree (l);
+          kfree (l);
 
-      l = next;
-    }
+          l = next;
+     }
 
-  ref->local_refs = NULL;
+     ref->local_refs = NULL;
 }
diff --git a/drivers/char/fusion/ref.h b/drivers/char/fusion/ref.h
index 942bfc0..088544a 100644
--- a/drivers/char/fusion/ref.h
+++ b/drivers/char/fusion/ref.h
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -15,30 +15,52 @@
 #ifndef __FUSION__REF_H__
 #define __FUSION__REF_H__
 
+#include "fusiondev.h"
 #include "types.h"
 
 
 /* module init/cleanup */
 
-int  fusion_ref_init (void);
-void fusion_ref_reset (void);
-void fusion_ref_cleanup (void);
+int  fusion_ref_init   (FusionDev *dev);
+void fusion_ref_deinit (FusionDev *dev);
 
 
 /* public API */
 
-int fusion_ref_new (int *id);
-int fusion_ref_up (int id, int fusion_id);
-int fusion_ref_down (int id, int fusion_id);
-int fusion_ref_zero_lock (int id, int fusion_id);
-int fusion_ref_zero_trylock (int id, int fusion_id);
-int fusion_ref_unlock (int id, int fusion_id);
-int fusion_ref_stat (int id, int *refs);
-int fusion_ref_destroy (int id);
+int fusion_ref_new          (FusionDev *dev,
+                             int       *id);
+
+int fusion_ref_up           (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_ref_down         (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_ref_zero_lock    (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_ref_zero_trylock (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_ref_unlock       (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_ref_stat         (FusionDev *dev,
+                             int        id,
+                             int       *refs);
+
+int fusion_ref_destroy      (FusionDev *dev,
+                             int        id);
 
 
 /* internal functions */
 
-void fusion_ref_clear_all_local (int fusion_id);
+void fusion_ref_clear_all_local (FusionDev *dev,
+                                 int        fusion_id);
 
 #endif
diff --git a/drivers/char/fusion/skirmish.c b/drivers/char/fusion/skirmish.c
index ca39cf3..3838215 100644
--- a/drivers/char/fusion/skirmish.c
+++ b/drivers/char/fusion/skirmish.c
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -11,7 +11,7 @@
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
  */
- 
+
 #include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
@@ -27,333 +27,306 @@
 #include "skirmish.h"
 
 typedef struct {
-  FusionLink         link;
+     FusionLink         link;
 
-  spinlock_t         lock;
+     spinlock_t         lock;
 
-  int                id;
-  int                pid;
+     int                id;
+     int                pid;
 
-  int                lock_fid;  /* non-zero if locked */
-  int                lock_pid;
-  int                lock_count;
+     int                lock_fid;  /* non-zero if locked */
+     int                lock_pid;
+     int                lock_count;
 
-  wait_queue_head_t  wait;
+     wait_queue_head_t  wait;
 } FusionSkirmish;
 
 /******************************************************************************/
 
-static FusionSkirmish *lookup_skirmish     (int id);
+static FusionSkirmish *lookup_skirmish     (FusionDev *dev, int id);
 
-static FusionSkirmish *lock_skirmish       (int id);
+static FusionSkirmish *lock_skirmish       (FusionDev *dev, int id);
 static void            unlock_skirmish     (FusionSkirmish *skirmish);
 
 /******************************************************************************/
 
-static int         ids            = 0;
-static FusionLink *skirmishs      = NULL;
-static spinlock_t  skirmishs_lock = SPIN_LOCK_UNLOCKED;
-
-/******************************************************************************/
-
 static int
-fusion_skirmish_read_proc(char *buf, char **start, off_t offset,
-                     int len, int *eof, void *private)
+skirmishs_read_proc(char *buf, char **start, off_t offset,
+                    int len, int *eof, void *private)
 {
-  FusionLink *l;
-  int written = 0;
-
-  spin_lock (&skirmishs_lock);
-
-  fusion_list_foreach (l, skirmishs)
-    {
-      FusionSkirmish *skirmish = (FusionSkirmish*) l;
-
-      written += sprintf(buf+written, "(%5d) 0x%08x %s\n",
-                         skirmish->pid, skirmish->id,
-                         skirmish->lock_fid ? "(locked)" : "");
-      if (written < offset)
-        {
-          offset -= written;
-          written = 0;
-        }
-
-      if (written >= len)
-        break;
-    }
-
-  spin_unlock (&skirmishs_lock);
-
-  *start = buf + offset;
-  written -= offset;
-  if(written > len)
-    {
-      *eof = 0;
-      return len;
-    }
-
-  *eof = 1;
-  return (written<0) ? 0 : written;
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
+
+     spin_lock (&dev->skirmish.lock);
+
+     fusion_list_foreach (l, dev->skirmish.list) {
+          FusionSkirmish *skirmish = (FusionSkirmish*) l;
+
+          written += sprintf(buf+written, "(%5d) 0x%08x %s\n",
+                             skirmish->pid, skirmish->id,
+                             skirmish->lock_fid ? "(locked)" : "");
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     spin_unlock (&dev->skirmish.lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
 }
 
 int
-fusion_skirmish_init()
+fusion_skirmish_init (FusionDev *dev)
 {
-  create_proc_read_entry("skirmishs", 0, proc_fusion_dir,
-                         fusion_skirmish_read_proc, NULL);
+     dev->skirmish.lock = SPIN_LOCK_UNLOCKED;
+
+     create_proc_read_entry("skirmishs", 0, dev->proc_dir,
+                            skirmishs_read_proc, dev);
 
-  return 0;
+     return 0;
 }
 
 void
-fusion_skirmish_reset()
+fusion_skirmish_deinit (FusionDev *dev)
 {
-  FusionLink *l;
-
-  spin_lock (&skirmishs_lock);
+     FusionLink *l;
 
-  l = skirmishs;
-  while (l)
-    {
-      FusionLink     *next     = l->next;
-      FusionSkirmish *skirmish = (FusionSkirmish *) l;
+     spin_lock (&dev->skirmish.lock);
 
-      kfree (skirmish);
+     remove_proc_entry ("skirmishs", dev->proc_dir);
 
-      l = next;
-    }
+     l = dev->skirmish.list;
+     while (l) {
+          FusionLink     *next     = l->next;
+          FusionSkirmish *skirmish = (FusionSkirmish *) l;
 
-  ids       = 0;
-  skirmishs = NULL;
+          kfree (skirmish);
 
-  spin_unlock (&skirmishs_lock);
-}
-
-void
-fusion_skirmish_cleanup()
-{
-  fusion_skirmish_reset();
+          l = next;
+     }
 
-  remove_proc_entry ("skirmishs", proc_fusion_dir);
+     spin_unlock (&dev->skirmish.lock);
 }
 
 /******************************************************************************/
 
 int
-fusion_skirmish_new (int *id)
+fusion_skirmish_new (FusionDev *dev, int *id)
 {
-  FusionSkirmish *skirmish;
+     FusionSkirmish *skirmish;
 
-  skirmish = kmalloc (sizeof(FusionSkirmish), GFP_ATOMIC);
-  if (!skirmish)
-    return -ENOMEM;
+     skirmish = kmalloc (sizeof(FusionSkirmish), GFP_ATOMIC);
+     if (!skirmish)
+          return -ENOMEM;
 
-  memset (skirmish, 0, sizeof(FusionSkirmish));
+     memset (skirmish, 0, sizeof(FusionSkirmish));
 
-  spin_lock (&skirmishs_lock);
+     spin_lock (&dev->skirmish.lock);
 
-  skirmish->id   = ids++;
-  skirmish->pid  = current->pid;
-  skirmish->lock = SPIN_LOCK_UNLOCKED;
+     skirmish->id   = dev->skirmish.ids++;
+     skirmish->pid  = current->pid;
+     skirmish->lock = SPIN_LOCK_UNLOCKED;
 
-  init_waitqueue_head (&skirmish->wait);
+     init_waitqueue_head (&skirmish->wait);
 
-  fusion_list_prepend (&skirmishs, &skirmish->link);
+     fusion_list_prepend (&dev->skirmish.list, &skirmish->link);
 
-  spin_unlock (&skirmishs_lock);
+     spin_unlock (&dev->skirmish.lock);
 
-  *id = skirmish->id;
+     *id = skirmish->id;
 
-  return 0;
+     return 0;
 }
 
 int
-fusion_skirmish_prevail (int id, int fusion_id)
+fusion_skirmish_prevail (FusionDev *dev, int id, int fusion_id)
 {
-  FusionSkirmish *skirmish;
-
-  while (true)
-    {
-      skirmish = lock_skirmish (id);
-      if (!skirmish)
-        return -EINVAL;
-
-      if (skirmish->lock_fid)
-        {
-          if (skirmish->lock_pid == current->pid)
-            {
-              skirmish->lock_count++;
-              unlock_skirmish (skirmish);
-              return 0;
-            }
-
-          fusion_sleep_on (&skirmish->wait, &skirmish->lock, 0);
-
-          if (signal_pending(current))
-            return -ERESTARTSYS;
-        }
-      else
-        break;
-    }
-
-  skirmish->lock_fid   = fusion_id;
-  skirmish->lock_pid   = current->pid;
-  skirmish->lock_count = 1;
-
-  unlock_skirmish (skirmish);
-
-  return 0;
+     FusionSkirmish *skirmish;
+
+     while (true) {
+          skirmish = lock_skirmish (dev, id);
+          if (!skirmish)
+               return -EINVAL;
+
+          if (skirmish->lock_fid) {
+               if (skirmish->lock_pid == current->pid) {
+                    skirmish->lock_count++;
+                    unlock_skirmish (skirmish);
+                    return 0;
+               }
+
+               fusion_sleep_on (&skirmish->wait, &skirmish->lock, 0);
+
+               if (signal_pending(current))
+                    return -ERESTARTSYS;
+          }
+          else
+               break;
+     }
+
+     skirmish->lock_fid   = fusion_id;
+     skirmish->lock_pid   = current->pid;
+     skirmish->lock_count = 1;
+
+     unlock_skirmish (skirmish);
+
+     return 0;
 }
 
 int
-fusion_skirmish_swoop (int id, int fusion_id)
+fusion_skirmish_swoop (FusionDev *dev, int id, int fusion_id)
 {
-  FusionSkirmish *skirmish = lock_skirmish (id);
+     FusionSkirmish *skirmish = lock_skirmish (dev, id);
 
-  if (!skirmish)
-    return -EINVAL;
+     if (!skirmish)
+          return -EINVAL;
 
-  if (skirmish->lock_fid)
-    {
-      if (skirmish->lock_pid == current->pid)
-        {
-          skirmish->lock_count++;
-          unlock_skirmish (skirmish);
-          return 0;
-        }
+     if (skirmish->lock_fid) {
+          if (skirmish->lock_pid == current->pid) {
+               skirmish->lock_count++;
+               unlock_skirmish (skirmish);
+               return 0;
+          }
 
-      unlock_skirmish (skirmish);
+          unlock_skirmish (skirmish);
 
-      return -EAGAIN;
-    }
+          return -EAGAIN;
+     }
 
-  skirmish->lock_fid   = fusion_id;
-  skirmish->lock_pid   = current->pid;
-  skirmish->lock_count = 1;
+     skirmish->lock_fid   = fusion_id;
+     skirmish->lock_pid   = current->pid;
+     skirmish->lock_count = 1;
 
-  unlock_skirmish (skirmish);
+     unlock_skirmish (skirmish);
 
-  return 0;
+     return 0;
 }
 
 int
-fusion_skirmish_dismiss (int id, int fusion_id)
+fusion_skirmish_dismiss (FusionDev *dev, int id, int fusion_id)
 {
-  FusionSkirmish *skirmish = lock_skirmish (id);
+     FusionSkirmish *skirmish = lock_skirmish (dev, id);
 
-  if (!skirmish)
-    return -EINVAL;
+     if (!skirmish)
+          return -EINVAL;
 
-  if (skirmish->lock_pid != current->pid)
-    {
-      unlock_skirmish (skirmish);
-      return -EIO;
-    }
+     if (skirmish->lock_pid != current->pid) {
+          unlock_skirmish (skirmish);
+          return -EIO;
+     }
 
-  if (--skirmish->lock_count == 0)
-    {
-      skirmish->lock_fid = 0;
-      skirmish->lock_pid = 0;
+     if (--skirmish->lock_count == 0) {
+          skirmish->lock_fid = 0;
+          skirmish->lock_pid = 0;
 
-      wake_up_interruptible_all (&skirmish->wait);
-    }
+          wake_up_interruptible_all (&skirmish->wait);
+     }
 
-  unlock_skirmish (skirmish);
+     unlock_skirmish (skirmish);
 
-  return 0;
+     return 0;
 }
 
 int
-fusion_skirmish_destroy (int id)
+fusion_skirmish_destroy (FusionDev *dev, int id)
 {
-  FusionSkirmish *skirmish = lookup_skirmish (id);
+     FusionSkirmish *skirmish = lookup_skirmish (dev, id);
 
-  if (!skirmish)
-    return -EINVAL;
+     if (!skirmish)
+          return -EINVAL;
 
-  spin_lock (&skirmish->lock);
+     spin_lock (&skirmish->lock);
 
-  fusion_list_remove (&skirmishs, &skirmish->link);
+     fusion_list_remove (&dev->skirmish.list, &skirmish->link);
 
-  spin_unlock (&skirmishs_lock);
+     spin_unlock (&dev->skirmish.lock);
 
-  wake_up_interruptible_all (&skirmish->wait);
+     wake_up_interruptible_all (&skirmish->wait);
 
-  spin_unlock (&skirmish->lock);
-  
-  kfree (skirmish);
+     spin_unlock (&skirmish->lock);
 
-  return 0;
+     kfree (skirmish);
+
+     return 0;
 }
 
 void
-fusion_skirmish_dismiss_all (int fusion_id)
+fusion_skirmish_dismiss_all (FusionDev *dev, int fusion_id)
 {
-  FusionLink *l;
+     FusionLink *l;
 
-  spin_lock (&skirmishs_lock);
+     spin_lock (&dev->skirmish.lock);
 
-  fusion_list_foreach (l, skirmishs)
-    {
-      FusionSkirmish *skirmish = (FusionSkirmish *) l;
+     fusion_list_foreach (l, dev->skirmish.list) {
+          FusionSkirmish *skirmish = (FusionSkirmish *) l;
 
-      spin_lock (&skirmish->lock);
+          spin_lock (&skirmish->lock);
 
-      if (skirmish->lock_fid == fusion_id)
-        {
-          skirmish->lock_fid   = 0;
-          skirmish->lock_pid   = 0;
-          skirmish->lock_count = 0;
+          if (skirmish->lock_fid == fusion_id) {
+               skirmish->lock_fid   = 0;
+               skirmish->lock_pid   = 0;
+               skirmish->lock_count = 0;
 
-          wake_up_interruptible_all (&skirmish->wait);
-        }
+               wake_up_interruptible_all (&skirmish->wait);
+          }
 
-      spin_unlock (&skirmish->lock);
-    }
+          spin_unlock (&skirmish->lock);
+     }
 
-  spin_unlock (&skirmishs_lock);
+     spin_unlock (&dev->skirmish.lock);
 }
 
 /******************************************************************************/
 
 static FusionSkirmish *
-lookup_skirmish (int id)
+lookup_skirmish (FusionDev *dev, int id)
 {
-  FusionLink *l;
+     FusionLink *l;
 
-  spin_lock (&skirmishs_lock);
+     spin_lock (&dev->skirmish.lock);
 
-  fusion_list_foreach (l, skirmishs)
-    {
-      FusionSkirmish *skirmish = (FusionSkirmish *) l;
+     fusion_list_foreach (l, dev->skirmish.list) {
+          FusionSkirmish *skirmish = (FusionSkirmish *) l;
 
-      if (skirmish->id == id)
-        return skirmish;
-    }
+          if (skirmish->id == id)
+               return skirmish;
+     }
 
-  spin_unlock (&skirmishs_lock);
+     spin_unlock (&dev->skirmish.lock);
 
-  return NULL;
+     return NULL;
 }
 
 static FusionSkirmish *
-lock_skirmish (int id)
+lock_skirmish (FusionDev *dev, int id)
 {
-  FusionSkirmish *skirmish = lookup_skirmish (id);
+     FusionSkirmish *skirmish = lookup_skirmish (dev, id);
 
-  if (skirmish)
-    {
-      fusion_list_move_to_front (&skirmishs, &skirmish->link);
+     if (skirmish) {
+          fusion_list_move_to_front (&dev->skirmish.list, &skirmish->link);
 
-      spin_lock (&skirmish->lock);
-      spin_unlock (&skirmishs_lock);
-    }
+          spin_lock (&skirmish->lock);
+          spin_unlock (&dev->skirmish.lock);
+     }
 
-  return skirmish;
+     return skirmish;
 }
 
 static void
 unlock_skirmish (FusionSkirmish *skirmish)
 {
-  spin_unlock (&skirmish->lock);
+     spin_unlock (&skirmish->lock);
 }
diff --git a/drivers/char/fusion/skirmish.h b/drivers/char/fusion/skirmish.h
index 25df0cc..e544648 100644
--- a/drivers/char/fusion/skirmish.h
+++ b/drivers/char/fusion/skirmish.h
@@ -1,7 +1,7 @@
 /*
  *	Fusion Kernel Module
  *
- *	(c) Copyright 2002  Convergence GmbH
+ *	(c) Copyright 2002-2003  Convergence GmbH
  *
  *      Written by Denis Oliver Kropp <dok@directfb.org>
  *
@@ -15,27 +15,40 @@
 #ifndef __FUSION__SKIRMISH_H__
 #define __FUSION__SKIRMISH_H__
 
+#include "fusiondev.h"
 #include "types.h"
 
 
 /* module init/cleanup */
 
-int  fusion_skirmish_init (void);
-void fusion_skirmish_reset (void);
-void fusion_skirmish_cleanup (void);
+int  fusion_skirmish_init   (FusionDev *dev);
+void fusion_skirmish_deinit (FusionDev *dev);
 
 
 /* public API */
 
-int fusion_skirmish_new (int *id);
-int fusion_skirmish_prevail (int id, int fusion_id);
-int fusion_skirmish_swoop (int id, int fusion_id);
-int fusion_skirmish_dismiss (int id, int fusion_id);
-int fusion_skirmish_destroy (int id);
+int fusion_skirmish_new     (FusionDev *dev,
+                             int       *id);
+
+int fusion_skirmish_prevail (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_skirmish_swoop   (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_skirmish_dismiss (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_skirmish_destroy (FusionDev *dev,
+                             int        id);
 
 
 /* internal functions */
 
-void fusion_skirmish_dismiss_all (int fusion_id);
+void fusion_skirmish_dismiss_all (FusionDev *dev,
+                                  int        fusion_id);
 
 #endif
-- 
1.7.3.3

