From 6939fd67b3ece0b39f2a3ac247fc97513f90cd4d Mon Sep 17 00:00:00 2001
From: Denis Oliver Kropp <dok@cyto.(none)>
Date: Sun, 14 Sep 2008 02:52:21 +0200
Subject: [PATCH] Fixed dead lock in fusion_call_destroy() leading to unkillable process.

There was a typo that caused the call to be unlocked instead of the list.

Furthermore, there were two places without checking for a pending signal after
calling fusion_sleep_on().
---
 drivers/char/fusion/call.c     |    5 ++++-
 drivers/char/fusion/fusionee.c |    3 +++
 2 files changed, 7 insertions(+), 1 deletions(-)

diff --git a/drivers/char/fusion/call.c b/drivers/char/fusion/call.c
index 7cadebf..d3d5ee6 100644
--- a/drivers/char/fusion/call.c
+++ b/drivers/char/fusion/call.c
@@ -375,10 +375,13 @@ fusion_call_destroy (FusionDev *dev, int fusion_id, int call_id)
           execution = (FusionCallExecution *) call->executions;
           if (execution) {
                /* Unlock the list. */
-               up (&call->lock);
+               up (&dev->call.lock);
 
                /* Unlock call and wait for execution. TODO: add timeout? */
                fusion_sleep_on( &execution->wait, &call->lock, 0 );
+
+               if (signal_pending(current))
+                    return -EINTR;
           }
      } while (execution);
 
diff --git a/drivers/char/fusion/fusionee.c b/drivers/char/fusion/fusionee.c
index 29f0e56..ddb26fb 100644
--- a/drivers/char/fusion/fusionee.c
+++ b/drivers/char/fusion/fusionee.c
@@ -491,6 +491,9 @@ fusionee_wait_processing (FusionDev         *dev,
 
           /* Otherwise unlock and wait. */
           fusion_sleep_on( &fusionee->wait, &fusionee->lock, 0 );
+
+          if (signal_pending(current))
+               return -EINTR;
      } while (true);
 
      unlock_fusionee (fusionee);
-- 
1.7.3.3

