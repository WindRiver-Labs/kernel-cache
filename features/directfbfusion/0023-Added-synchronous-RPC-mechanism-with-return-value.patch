From 017c31b984bf58925c73e5fdfeca0ea5865e9cc6 Mon Sep 17 00:00:00 2001
From: Denis Oliver Kropp <dok@directfb.org>
Date: Sat, 5 Apr 2003 02:42:59 +0000
Subject: [PATCH] Added synchronous RPC mechanism (with return value).

---
 drivers/char/fusion/Makefile    |    2 +-
 drivers/char/fusion/call.c      |  449 +++++++++++++++++++++++++++++++++++++++
 drivers/char/fusion/call.h      |   40 ++++
 drivers/char/fusion/fusiondev.c |   54 +++++-
 drivers/char/fusion/fusionee.c  |    4 +-
 include/linux/fusion.h          |   69 ++++++-
 6 files changed, 610 insertions(+), 8 deletions(-)
 create mode 100644 drivers/char/fusion/call.c
 create mode 100644 drivers/char/fusion/call.h

diff --git a/drivers/char/fusion/Makefile b/drivers/char/fusion/Makefile
index ad06bd2..4503602 100644
--- a/drivers/char/fusion/Makefile
+++ b/drivers/char/fusion/Makefile
@@ -1,6 +1,6 @@
 O_TARGET := fusion.o
 
-obj-y   := fifo.o fusiondev.o fusionee.o list.o property.o reactor.o ref.o skirmish.o
+obj-y   := call.o fifo.o fusiondev.o fusionee.o list.o property.o reactor.o ref.o skirmish.o
 obj-m   := $(O_TARGET)
 
 include $(TOPDIR)/Rules.make
diff --git a/drivers/char/fusion/call.c b/drivers/char/fusion/call.c
new file mode 100644
index 0000000..4ecf854
--- /dev/null
+++ b/drivers/char/fusion/call.c
@@ -0,0 +1,449 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "call.h"
+
+typedef struct {
+  FusionLink        link;
+
+  int               caller;
+
+  int               ret_val;
+
+  bool              executed;
+
+  wait_queue_head_t wait;
+} FusionCallExecution;
+
+typedef struct {
+  FusionLink         link;
+
+  spinlock_t         lock;
+
+  int                id;        /* call id */
+
+  int                pid;       /* owner pid */
+  int                fusion_id; /* owner fusion id */
+
+  FusionCallHandler  handler;
+  void              *ctx;
+
+  FusionLink          *executions;      /* prepending! */
+  FusionCallExecution *next;            /* points to the last item of executions */
+
+  int                count;    /* number of calls ever made */
+} FusionCall;
+
+/******************************************************************************/
+
+static FusionCall *lookup_call (int id);
+
+static FusionCall *lock_call   (int id);
+static void        unlock_call (FusionCall *call);
+
+static FusionCallExecution *add_execution       (FusionCall          *call,
+                                                 int                  fusion_id,
+                                                 FusionCallExecute   *execute);
+static void                 remove_execution    (FusionCall          *call,
+                                                 FusionCallExecution *execution);
+static void                 free_all_executions (FusionCall          *call);
+
+/******************************************************************************/
+
+static int         ids        = 0;
+static FusionLink *calls      = NULL;
+static spinlock_t  calls_lock = SPIN_LOCK_UNLOCKED;
+
+/******************************************************************************/
+
+static int
+fusion_call_read_proc (char *buf, char **start, off_t offset,
+                       int len, int *eof, void *private)
+{
+  FusionLink *l;
+  int written = 0;
+
+  spin_lock (&calls_lock);
+
+  fusion_list_foreach (l, calls)
+    {
+      FusionCall *call = (FusionCall*) l;
+
+      written += sprintf(buf+written,
+                         "(%5d) 0x%08x (%d calls) %s\n",
+                         call->pid, call->id, call->count,
+                         call->next ? "executing" : "idle");
+
+      if (written < offset)
+        {
+          offset -= written;
+          written = 0;
+        }
+
+      if (written >= len)
+        break;
+    }
+
+  spin_unlock (&calls_lock);
+
+  *start = buf + offset;
+  written -= offset;
+  if(written > len)
+    {
+      *eof = 0;
+      return len;
+    }
+
+  *eof = 1;
+  return (written<0) ? 0 : written;
+}
+
+int
+fusion_call_init()
+{
+  create_proc_read_entry("calls", 0, proc_fusion_dir,
+                         fusion_call_read_proc, NULL);
+
+  return 0;
+}
+
+void
+fusion_call_reset()
+{
+  FusionLink *l;
+
+  spin_lock (&calls_lock);
+
+  l = calls;
+  while (l)
+    {
+      FusionLink *next = l->next;
+      FusionCall *call = (FusionCall *) l;
+
+      free_all_executions (call);
+
+      kfree (call);
+
+      l = next;
+    }
+
+  ids   = 0;
+  calls = NULL;
+
+  spin_unlock (&calls_lock);
+}
+
+void
+fusion_call_cleanup()
+{
+  fusion_call_reset();
+
+  remove_proc_entry ("calls", proc_fusion_dir);
+}
+
+/******************************************************************************/
+
+int
+fusion_call_new (int fusion_id, FusionCallNew *call_new)
+{
+  FusionCall *call;
+
+  call = kmalloc (sizeof(FusionCall), GFP_KERNEL);
+  if (!call)
+    return -ENOMEM;
+
+  memset (call, 0, sizeof(FusionCall));
+
+  spin_lock (&calls_lock);
+
+  call->id        = ids++;
+  call->pid       = current->pid;
+  call->fusion_id = fusion_id;
+  call->lock      = SPIN_LOCK_UNLOCKED;
+
+  call->handler   = call_new->handler;
+  call->ctx       = call_new->ctx;
+
+  fusion_list_prepend (&calls, &call->link);
+
+  spin_unlock (&calls_lock);
+
+  call_new->call_id = call->id;
+
+  return 0;
+}
+
+int
+fusion_call_execute (int fusion_id, FusionCallExecute *execute)
+{
+  int                  ret;
+  FusionCall          *call;
+  FusionCallExecution *execution;
+  FusionCallMessage    message;
+
+  call = lock_call (execute->call_id);
+  if (!call)
+    return -EINVAL;
+
+  execution = add_execution (call, fusion_id, execute);
+  if (!execution)
+    {
+      unlock_call (call);
+      return -ENOMEM;
+    }
+  
+  /* Send call message. */
+  message.handler  = call->handler;
+  message.ctx      = call->ctx;
+
+  message.caller   = execution->caller;
+
+  message.call_arg = execute->call_arg;
+  message.call_ptr = execute->call_ptr;
+
+  ret = fusionee_send_message (fusion_id, call->fusion_id, FMT_CALL,
+                               call->id, sizeof(message), &message);
+  if (ret)
+    {
+      remove_execution (call, execution);
+      unlock_call (call);
+      return ret;
+    }
+
+  call->count++;
+
+  unlock_call (call);
+
+  interruptible_sleep_on (&execution->wait);
+      
+  call = lock_call (execute->call_id);
+  if (!call)
+    return -EIDRM;
+
+  execute->ret_val = execution->ret_val;
+
+  remove_execution (call, execution);
+
+  kfree (execution);
+
+  if (signal_pending(current))
+    {
+      unlock_call (call);
+      return -ERESTARTSYS;
+    }
+
+  unlock_call (call);
+
+  return 0;
+}
+
+int
+fusion_call_return (int fusion_id, FusionCallReturn *call_ret)
+{
+  FusionLink *l;
+  FusionCall *call = lock_call (call_ret->call_id);
+
+  if (!call)
+    return -EINVAL;
+
+  fusion_list_foreach (l, call->executions)
+    {
+      FusionCallExecution *execution = (FusionCallExecution*) l;
+
+      if (execution->executed)
+        continue;
+
+      execution->ret_val  = call_ret->val;
+      execution->executed = true;
+
+      wake_up_interruptible_all (&execution->wait);
+
+      unlock_call (call);
+
+      return 0;
+    }
+
+  unlock_call (call);
+
+  return -EIO;
+}
+
+int
+fusion_call_destroy (int fusion_id, int call_id)
+{
+  FusionCall *call = lookup_call (call_id);
+
+  if (!call)
+    return -EINVAL;
+
+  if (call->fusion_id != fusion_id)
+    {
+      spin_unlock (&calls_lock);
+      return -EIO;
+    }
+
+  spin_lock (&call->lock);
+
+  fusion_list_remove (&calls, &call->link);
+
+  free_all_executions (call);
+
+  spin_unlock (&calls_lock);
+
+  kfree (call);
+
+  return 0;
+}
+
+void
+fusion_call_destroy_all (int fusion_id)
+{
+  FusionLink *l;
+
+  spin_lock (&calls_lock);
+
+  l = calls;
+
+  while (l)
+    {
+      FusionLink *next = l->next;
+      FusionCall *call = (FusionCall *) l;
+
+      spin_lock (&call->lock);
+
+      if (call->fusion_id == fusion_id)
+        {
+          free_all_executions (call);
+
+          fusion_list_remove (&calls, &call->link);
+
+          kfree (call);
+        }
+      else
+        spin_unlock (&call->lock);
+
+      l = next;
+    }
+
+  spin_unlock (&calls_lock);
+}
+
+/******************************************************************************/
+
+static FusionCall *
+lookup_call (int id)
+{
+  FusionLink *l;
+
+  spin_lock (&calls_lock);
+
+  fusion_list_foreach (l, calls)
+    {
+      FusionCall *call = (FusionCall *) l;
+
+      if (call->id == id)
+        return call;
+    }
+
+  spin_unlock (&calls_lock);
+
+  return NULL;
+}
+
+static FusionCall *
+lock_call (int id)
+{
+  FusionCall *call = lookup_call (id);
+
+  if (call)
+    {
+      fusion_list_move_to_front (&calls, &call->link);
+
+      spin_lock (&call->lock);
+      spin_unlock (&calls_lock);
+    }
+
+  return call;
+}
+
+static void
+unlock_call (FusionCall *call)
+{
+  spin_unlock (&call->lock);
+}
+
+static FusionCallExecution *
+add_execution (FusionCall        *call,
+               int                fusion_id,
+               FusionCallExecute *execute)
+{
+  FusionCallExecution *execution;
+
+  /* Allocate execution. */
+  execution = kmalloc (sizeof(FusionCallExecution), GFP_KERNEL);
+  if (!execution)
+    return NULL;
+
+  /* Initialize execution. */
+  memset (execution, 0, sizeof(FusionCallExecution));
+
+  execution->caller = fusion_id;
+
+  init_waitqueue_head (&execution->wait);
+
+  /* Add execution. */
+  fusion_list_prepend (&call->executions, &execution->link);
+
+  if (!call->next)
+    call->next = execution;
+
+  return execution;
+}
+
+static void
+remove_execution (FusionCall          *call,
+                  FusionCallExecution *execution)
+{
+  if (call->next == execution)
+    call->next = (FusionCallExecution*) execution->link.prev;
+
+  fusion_list_remove (&call->executions, &execution->link);
+}
+
+static void
+free_all_executions (FusionCall *call)
+{
+  while (call->next)
+    {
+      FusionCallExecution *execution = call->next;
+
+      remove_execution (call, execution);
+
+      wake_up_interruptible_all (&execution->wait);
+
+      kfree (execution);
+    }
+}
diff --git a/drivers/char/fusion/call.h b/drivers/char/fusion/call.h
new file mode 100644
index 0000000..33200b1
--- /dev/null
+++ b/drivers/char/fusion/call.h
@@ -0,0 +1,40 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSION__CALL_H__
+#define __FUSION__CALL_H__
+
+#include <linux/fusion.h>
+
+
+/* module init/cleanup */
+
+int  fusion_call_init (void);
+void fusion_call_reset (void);
+void fusion_call_cleanup (void);
+
+
+/* public API */
+
+int fusion_call_new (int fusion_id, FusionCallNew *call);
+int fusion_call_execute (int fusion_id, FusionCallExecute *execute);
+int fusion_call_return (int fusion_id, FusionCallReturn *call_ret);
+int fusion_call_destroy (int fusion_id, int call_id);
+
+
+/* internal functions */
+
+void fusion_call_destroy_all (int fusion_id);
+
+#endif
diff --git a/drivers/char/fusion/fusiondev.c b/drivers/char/fusion/fusiondev.c
index 341180c..341547b 100644
--- a/drivers/char/fusion/fusiondev.c
+++ b/drivers/char/fusion/fusiondev.c
@@ -26,6 +26,7 @@
 
 #include <linux/fusion.h>
 
+#include "call.h"
 #include "fusiondev.h"
 #include "fusionee.h"
 #include "property.h"
@@ -51,6 +52,7 @@ static spinlock_t refs_lock = SPIN_LOCK_UNLOCKED;
 static void
 fusion_reset (void)
 {
+  fusion_call_reset();
   fusion_reactor_reset();
   fusion_property_reset();
   fusion_skirmish_reset();
@@ -128,8 +130,11 @@ fusion_ioctl (struct inode *inode, struct file *file,
   int ret;
   int refs;
   int fusion_id = (int) file->private_data;
-  FusionSendMessage send;
+  FusionSendMessage     send;
   FusionReactorDispatch dispatch;
+  FusionCallNew         call;
+  FusionCallExecute     execute;
+  FusionCallReturn      call_ret;
 
   switch (cmd)
     {
@@ -154,6 +159,46 @@ fusion_ioctl (struct inode *inode, struct file *file,
                                     send.msg_size, send.msg_data);
 
 
+    case FUSION_CALL_NEW:
+      if (copy_from_user (&call, (FusionCallNew*) arg, sizeof(call)))
+        return -EFAULT;
+
+      ret = fusion_call_new (fusion_id, &call);
+      if (ret)
+        return ret;
+
+      if (put_user (call.call_id, (int*) arg))
+        {
+          fusion_call_destroy (fusion_id, call.call_id);
+          return -EFAULT;
+        }
+      break;
+
+    case FUSION_CALL_EXECUTE:
+      if (copy_from_user (&execute, (FusionCallExecute*) arg, sizeof(execute)))
+        return -EFAULT;
+
+      ret = fusion_call_execute (fusion_id, &execute);
+      if (ret)
+        return ret;
+
+      if (put_user (execute.ret_val, (int*) arg))
+        return -EFAULT;
+      break;
+
+    case FUSION_CALL_RETURN:
+      if (copy_from_user (&call_ret, (FusionCallReturn*) arg, sizeof(call_ret)))
+        return -EFAULT;
+
+      return fusion_call_return (fusion_id, &call_ret);
+
+    case FUSION_CALL_DESTROY:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_call_destroy (fusion_id, id);
+
+
     case FUSION_REF_NEW:
       ret = fusion_ref_new (&id);
       if (ret)
@@ -403,6 +448,10 @@ fusion_init(void)
   if (ret)
     goto error_reactor;
 
+  ret = fusion_call_init();
+  if (ret)
+    goto error_call;
+
   ret = misc_register (&fusion_miscdev);
   if (ret)
     goto error_misc;
@@ -411,6 +460,9 @@ fusion_init(void)
 
 
  error_misc:
+  fusion_call_cleanup();
+
+ error_call:
   fusion_reactor_cleanup();
 
  error_reactor:
diff --git a/drivers/char/fusion/fusionee.c b/drivers/char/fusion/fusionee.c
index c50e8d2..941d598 100644
--- a/drivers/char/fusion/fusionee.c
+++ b/drivers/char/fusion/fusionee.c
@@ -221,7 +221,9 @@ fusionee_send_message (int id, int recipient, FusionMessageType msg_type,
 
   message->data = message + 1;
 
-  if (copy_from_user (message->data, msg_data, msg_size))
+  if (msg_type == FMT_CALL)
+    memcpy (message->data, msg_data, msg_size);
+  else if (copy_from_user (message->data, msg_data, msg_size))
     {
       kfree (message);
       unlock_fusionee (sender);
diff --git a/include/linux/fusion.h b/include/linux/fusion.h
index 9806ea0..6f238f9 100644
--- a/include/linux/fusion.h
+++ b/include/linux/fusion.h
@@ -4,6 +4,9 @@
 #include <asm/ioctl.h>
 #include <asm/types.h>
 
+/*
+ * Sending
+ */
 typedef struct {
   int         fusion_id;      /* recipient */
 
@@ -12,9 +15,13 @@ typedef struct {
   const void *msg_data;       /* message data, must not be NULL */
 } FusionSendMessage;
 
+/*
+ * Receiving
+ */
 typedef enum {
   FMT_SEND,
-  FMT_REACTOR
+  FMT_CALL,                   /* msg_id is the call id */
+  FMT_REACTOR                 /* msg_id is the reactor id */
 } FusionMessageType;
 
 typedef struct {
@@ -26,6 +33,9 @@ typedef struct {
   /* message data follows */
 } FusionReadMessage;
 
+/*
+ * Dispatching
+ */
 typedef struct {
   int         reactor_id;
   int         self;
@@ -34,10 +44,59 @@ typedef struct {
   const void *msg_data;       /* message data, must not be NULL */
 } FusionReactorDispatch;
 
+/*
+ * Calling (synchronous RPC)
+ */
+typedef int (*FusionCallHandler) (int   caller,   /* fusion id of the caller */
+                                  int   call_arg, /* optional call parameter */
+                                  void *call_ptr, /* optional call parameter */
+                                  void *ctx       /* optional handler context */
+                                  );
+
+typedef struct {
+  int                call_id;   /* new call id returned */
+
+  FusionCallHandler  handler;   /* function pointer of handler to install */
+  void              *ctx;       /* optional handler context */
+} FusionCallNew;
+
+typedef struct {
+  int   ret_val;              /* return value of the call */
+
+  int   call_id;              /* each call has a fixed owner */
+  
+  int   call_arg;             /* optional int argument */
+  void *call_ptr;             /* optional pointer argument (e.g. shared memory) */
+} FusionCallExecute;
+
+
+typedef struct {
+  int   call_id;              /* id of currently executing call */
+
+  int   val;                  /* value to return */
+} FusionCallReturn;
+
+typedef struct {
+  FusionCallHandler  handler;   /* function pointer of handler to call */
+  void              *ctx;       /* optional handler context */
+
+  int                caller;    /* fusion id of the caller */
+  int                call_arg;  /* optional call parameter */
+  void              *call_ptr;  /* optional call parameter */
+} FusionCallMessage;
+  
+
+
 #define FUSION_GET_ID                   _IOR('F', 0x00, sizeof(int))
+
 #define FUSION_SEND_MESSAGE             _IOW('F', 0x01, sizeof(FusionSendMessage))
 
-#define FUSION_REF_NEW                  _IOR('F', 0x10, sizeof(int))
+#define FUSION_CALL_NEW                 _IOW('F', 0x02, sizeof(FusionCallNew))
+#define FUSION_CALL_EXECUTE             _IOW('F', 0x03, sizeof(FusionCallExecute))
+#define FUSION_CALL_RETURN              _IOW('F', 0x04, sizeof(FusionCallReturn))
+#define FUSION_CALL_DESTROY             _IOW('F', 0x05, sizeof(int))
+
+#define FUSION_REF_NEW                  _IOW('F', 0x10, sizeof(int))
 #define FUSION_REF_UP                   _IOW('F', 0x11, sizeof(int))
 #define FUSION_REF_UP_GLOBAL            _IOW('F', 0x12, sizeof(int))
 #define FUSION_REF_DOWN                 _IOW('F', 0x13, sizeof(int))
@@ -48,20 +107,20 @@ typedef struct {
 #define FUSION_REF_STAT                 _IOW('F', 0x18, sizeof(int))
 #define FUSION_REF_DESTROY              _IOW('F', 0x19, sizeof(int))
 
-#define FUSION_SKIRMISH_NEW             _IOR('F', 0x20, sizeof(int))
+#define FUSION_SKIRMISH_NEW             _IOW('F', 0x20, sizeof(int))
 #define FUSION_SKIRMISH_PREVAIL         _IOW('F', 0x21, sizeof(int))
 #define FUSION_SKIRMISH_SWOOP           _IOW('F', 0x22, sizeof(int))
 #define FUSION_SKIRMISH_DISMISS         _IOW('F', 0x23, sizeof(int))
 #define FUSION_SKIRMISH_DESTROY         _IOW('F', 0x24, sizeof(int))
 
-#define FUSION_PROPERTY_NEW             _IOR('F', 0x30, sizeof(int))
+#define FUSION_PROPERTY_NEW             _IOW('F', 0x30, sizeof(int))
 #define FUSION_PROPERTY_LEASE           _IOW('F', 0x31, sizeof(int))
 #define FUSION_PROPERTY_PURCHASE        _IOW('F', 0x32, sizeof(int))
 #define FUSION_PROPERTY_CEDE            _IOW('F', 0x33, sizeof(int))
 #define FUSION_PROPERTY_HOLDUP          _IOW('F', 0x34, sizeof(int))
 #define FUSION_PROPERTY_DESTROY         _IOW('F', 0x35, sizeof(int))
 
-#define FUSION_REACTOR_NEW              _IOR('F', 0x50, sizeof(int))
+#define FUSION_REACTOR_NEW              _IOW('F', 0x50, sizeof(int))
 #define FUSION_REACTOR_ATTACH           _IOW('F', 0x51, sizeof(int))
 #define FUSION_REACTOR_DETACH           _IOW('F', 0x52, sizeof(int))
 #define FUSION_REACTOR_DISPATCH         _IOW('F', 0x53, sizeof(FusionReactorDispatch))
-- 
1.7.3.3

