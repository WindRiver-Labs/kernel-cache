From 659c66711501f6c80d0b76604eec0b06fd802d60 Mon Sep 17 00:00:00 2001
From: Yong Zhang <yong.zhang@windriver.com>
Date: Wed, 21 Apr 2010 20:30:05 -0700
Subject: [PATCH 06/11] net: add socket stats support

Datagram sockets will be able to retrieve and or reset counters
for both the number of packets received in total as well as the
number of packets dropped due to buffer overflow through ioctl
command SIOCGSOCKSTATS and SIOCZEROSOCKSTATS.

Signed-off-by: Yongli he   <yongli.he@windriver.com>
Integrated-by: Yong Zhang <yong.zhang@windriver.com>
Signed-off-by: Joe MacDonald <joe.macdonald@windriver.com>
---
 include/linux/sockios.h |    4 ++++
 include/net/sock.h      |   52 +++++++++++++++++++++++++++++++++++++++++++++++
 net/Kconfig             |   11 ++++++++++
 net/core/sock.c         |    4 ++++
 net/socket.c            |   24 ++++++++++++++++++++++
 5 files changed, 95 insertions(+)

diff --git a/include/linux/sockios.h b/include/linux/sockios.h
index 7997a50..0d321b3 100644
--- a/include/linux/sockios.h
+++ b/include/linux/sockios.h
@@ -127,6 +127,10 @@
 /* hardware time stamping: parameters in linux/net_tstamp.h */
 #define SIOCSHWTSTAMP   0x89b0
 
+/* per-socket statistics manipulation */
+#define SIOCGSOCKSTATS		0x89c0	/* get the per-socket statistics */
+#define SIOCZEROSOCKSTATS	0x89c1	/* zero the per-socket statistics */
+
 /* Device private ioctl calls */
 
 /*
diff --git a/include/net/sock.h b/include/net/sock.h
index 2e3d4d0..b31b506 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -102,6 +102,55 @@ void SOCK_DEBUG(struct sock *sk, const char *msg, ...)
 }
 #endif
 
+/* per-socket statistics.  received is the total number of skbuffs received
+ * on that socket.  dropped_no_mem is the number of packets dropped due
+ * to a lack of space on the socket receive buffer.
+ *
+ * Note:  The lock only protects the reader from another cpu trying to zero
+ * the data.  There is still a race between the counts being updated and the
+ * counts being zeroed.  We don't worry about that.
+ */
+typedef struct {
+	__u64	received;
+	__u32	dropped_no_mem;
+} socket_stats;
+
+typedef struct {
+	socket_stats data;
+	spinlock_t lock;
+} socket_stats_struct;
+
+#ifdef CONFIG_DGRAM_SOCKSTATS
+#define inc_dgram_stats_received(sk)					\
+	do {sk->stats.data.received++; } while (0)
+#define inc_dgram_stats_dropped(sk)					\
+	do {sk->stats.data.dropped_no_mem++; } while (0)
+#define init_dgram_stats(sk)						\
+do {									\
+	(sk)->stats.data.dropped_no_mem = 0;				\
+	(sk)->stats.data.received = 0;					\
+	spin_lock_init(&(sk)->stats.lock);				\
+} while (0)
+#define zero_dgram_stats(sk)						\
+do {									\
+	spin_lock(&(sk)->stats.lock);					\
+	(sk)->stats.data.dropped_no_mem = 0;				\
+	(sk)->stats.data.received = 0;					\
+	spin_unlock(&(sk)->stats.lock);					\
+} while (0)
+#define copy_dgram_stats(tostats, sk)					\
+do {									\
+	spin_lock(&(sk)->stats.lock);					\
+	(tostats)->dropped_no_mem = (sk)->stats.data.dropped_no_mem;	\
+	(tostats)->received = (sk)->stats.data.received;		\
+	spin_unlock(&(sk)->stats.lock);					\
+} while	(0)
+#else
+#define inc_dgram_stats_received(sk)
+#define inc_dgram_stats_dropped(sk)
+#define init_dgram_stats(sk)
+#endif
+
 /* This is the per-socket lock.  The spinlock provides a synchronization
  * between user contexts and software interrupt processing, whereas the
  * mini-semaphore synchronizes multiple users amongst themselves.
@@ -375,6 +424,9 @@ struct sock {
   	int			(*sk_backlog_rcv)(struct sock *sk,
 						  struct sk_buff *skb);  
 	void                    (*sk_destruct)(struct sock *sk);
+#ifdef CONFIG_DGRAM_SOCKSTATS
+	socket_stats_struct stats;
+#endif
 };
 
 static inline int sk_peek_offset(struct sock *sk, int flags)
diff --git a/net/Kconfig b/net/Kconfig
index e07272d..f302f49 100644
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -50,6 +50,17 @@ source "net/unix/Kconfig"
 source "net/xfrm/Kconfig"
 source "net/iucv/Kconfig"
 
+config DGRAM_SOCKSTATS
+	bool "Datagram socket statistics"
+	default n
+	help
+	  If you say Y here, datagram sockets will be able to retrieve and
+	  or reset counters for both the number of packets received in total
+	  as well as the number of packets dropped due to buffer overflow.
+	  See code for data structures.
+
+	  If unsure, say N.
+
 config INET
 	bool "TCP/IP networking"
 	---help---
diff --git a/net/core/sock.c b/net/core/sock.c
index f0b6338..1d733e7 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -339,9 +339,11 @@ int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
 	unsigned long flags;
 	struct sk_buff_head *list = &sk->sk_receive_queue;
 
+	inc_dgram_stats_received(sk);
 	if (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf) {
 		atomic_inc_unchecked(&sk->sk_drops);
 		trace_sock_rcvqueue_full(sk, skb);
+		inc_dgram_stats_dropped(sk);
 		return -ENOMEM;
 	}
 
@@ -2125,6 +2127,8 @@ void sock_init_data(struct socket *sock, struct sock *sk)
 
 	sk->sk_stamp = ktime_set(-1L, 0);
 
+	init_dgram_stats(sk);
+
 	/*
 	 * Before updating sk_refcnt, we must commit prior changes to memory
 	 * (Documentation/RCU/rculist_nulls.txt for details)
diff --git a/net/socket.c b/net/socket.c
index 3eccc92..39fc170 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -1082,6 +1082,26 @@ static long sock_ioctl(struct file *file, unsigned cmd, unsigned long arg)
 				err = dlci_ioctl_hook(cmd, argp);
 			mutex_unlock(&dlci_ioctl_mutex);
 			break;
+#ifdef CONFIG_DGRAM_SOCKSTATS
+		case SIOCGSOCKSTATS:
+		{
+			socket_stats stats;
+			err = -EINVAL;
+			if (!sock->sk)
+				break;
+			copy_dgram_stats(&stats, sock->sk);
+			err = copy_to_user(argp, &stats,
+					sizeof(stats));
+			break;
+		}
+		case SIOCZEROSOCKSTATS:
+			err = -EINVAL;
+			if (!sock->sk)
+				break;
+			zero_dgram_stats(sock->sk);
+			err = 0;
+			break;
+#endif
 		default:
 			err = sock_do_ioctl(net, sock, cmd, arg);
 			break;
@@ -3283,6 +3303,10 @@ static int compat_sock_ioctl_trans(struct file *file, struct socket *sock,
 	case SIOCSIFVLAN:
 	case SIOCADDDLCI:
 	case SIOCDELDLCI:
+#ifdef CONFIG_DGRAM_SOCKSTATS
+	case SIOCGSOCKSTATS:
+	case SIOCZEROSOCKSTATS:
+#endif
 		return sock_ioctl(file, cmd, arg);
 
 	case SIOCGIFFLAGS:
-- 
1.7.9.7

