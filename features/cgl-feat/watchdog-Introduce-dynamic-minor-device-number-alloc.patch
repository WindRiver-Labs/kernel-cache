From 21df88c6e3fb4a53b31d176cfef1e8e8268490bc Mon Sep 17 00:00:00 2001
From: Yong Zhang <yong.zhang@windriver.com>
Date: Wed, 21 Apr 2010 00:38:08 -0700
Subject: [PATCH 10/11] watchdog: Introduce dynamic minor device number
 allocation

Enables software watchdog minor number to be allocated dynamically.
This can be applied with the kernel parameter softdog.dynamic_dev (0|1).
By default, kernel take the traditional action(softdog.dynamic_dev=0).

Signed-off-by: Liming Wang <liming.wang@windriver.com>
Integrated-by: Yong Zhang <yong.zhang@windriver.com>
Signed-off-by: Joe MacDonald <joe.macdonald@windriver.com>
---
 drivers/watchdog/Kconfig        |    8 +++++
 drivers/watchdog/softdog.c      |   33 +++++++++++++++++++-
 drivers/watchdog/watchdog_dev.c |   66 +++++++++++++++++++++++++++++++++++++++
 include/linux/watchdog.h        |    4 +++
 4 files changed, 110 insertions(+), 1 deletion(-)

diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 257acf3..f857c89 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -80,6 +80,14 @@ config WM8350_WATCHDOG
 	  Support for the watchdog in the WM8350 AudioPlus PMIC.  When
 	  the watchdog triggers the system will be reset.
 
+config SOFT_WATCHDOG_DYNDEV
+	bool "Software watchdog dynamic minor device number"
+	depends on SOFT_WATCHDOG
+	help
+	  Enables software watchdog minor number to be allocated
+	  dynamically. This is enables with the kenrel parameter
+	  dynamic_dev (0|1).
+
 # ALPHA Architecture
 
 # ARM Architecture
diff --git a/drivers/watchdog/softdog.c b/drivers/watchdog/softdog.c
index fe83beb..46d45b4 100644
--- a/drivers/watchdog/softdog.c
+++ b/drivers/watchdog/softdog.c
@@ -73,6 +73,14 @@ module_param(soft_panic, int, 0);
 MODULE_PARM_DESC(soft_panic,
 	"Softdog action, set to 1 to panic, 0 to reboot (default=0)");
 
+#ifdef CONFIG_SOFT_WATCHDOG_DYNDEV
+static bool dynamic_dev;
+
+module_param(dynamic_dev, bool, 0);
+MODULE_PARM_DESC(dynamic_dev,
+		 "Watchdog minor number is allocated dynamically (default=0)");
+#endif
+
 /*
  *	Our timer
  */
@@ -145,7 +153,16 @@ static struct notifier_block softdog_notifier = {
 
 static struct watchdog_info softdog_info = {
 	.identity = "Software Watchdog",
-	.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,
+	.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE | WDIOF_SDDYNMINOR,
+#ifdef CONFIG_SOFT_WATCHDOG_DYNDEV
+	.minor = WATCHDOG_MINOR,
+};
+
+static struct watchdog_info softdog_dyn_info = {
+	.identity = "Software Watchdog",
+	.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE | WDIOF_SDDYNMINOR,
+	.minor = MISC_DYNAMIC_MINOR,
+#endif
 };
 
 static struct watchdog_ops softdog_ops = {
@@ -163,6 +180,15 @@ static struct watchdog_device softdog_dev = {
 	.max_timeout = 0xFFFF
 };
 
+#ifdef CONFIG_SOFT_WATCHDOG_DYNDEV
+static struct watchdog_device softdog_dyn_dev = {
+	.info = &softdog_dyn_info,
+	.ops = &softdog_ops,
+	.min_timeout = 1,
+	.max_timeout = 0xFFFF
+};
+#endif
+
 static int __init watchdog_init(void)
 {
 	int ret;
@@ -184,6 +210,11 @@ static int __init watchdog_init(void)
 		return ret;
 	}
 
+#ifdef CONFIG_SOFT_WATCHDOG_DYNDEV
+	if (dynamic_dev)
+		ret = watchdog_register_device(&softdog_dyn_dev);
+	else
+#endif
 	ret = watchdog_register_device(&softdog_dev);
 	if (ret) {
 		unregister_reboot_notifier(&softdog_notifier);
diff --git a/drivers/watchdog/watchdog_dev.c b/drivers/watchdog/watchdog_dev.c
index 8558da9..5af9c46 100644
--- a/drivers/watchdog/watchdog_dev.c
+++ b/drivers/watchdog/watchdog_dev.c
@@ -337,6 +337,14 @@ static struct miscdevice watchdog_miscdev = {
 	.fops		= &watchdog_fops,
 };
 
+#ifdef CONFIG_SOFT_WATCHDOG_DYNDEV
+static struct miscdevice watchdog_dynamic_miscdev = {
+	.minor		= MISC_DYNAMIC_MINOR,
+	.name		= "softdog",
+	.fops		= &watchdog_fops,
+};
+#endif
+
 /*
  *	watchdog_dev_register:
  *	@watchdog: watchdog device
@@ -349,6 +357,21 @@ int watchdog_dev_register(struct watchdog_device *watchdog)
 {
 	int err;
 
+#ifdef CONFIG_SOFT_WATCHDOG_DYNDEV
+	/* If we support dynamic minor device numbers for watchdogs --
+	 * specifically for softdogs -- we can allow multiple devices to be
+	 * loaded.  But since we're specifically only supporting dynamic minor
+	 * numbers for softdogs, we still want to keep the /dev/watchdog check
+	 * for hardware watchdogs.  Or for anything not requesting a dynamic
+	 * minor number. */
+	if (!((watchdog->info->options & WDIOF_SDDYNMINOR) &&
+	      (watchdog->info->minor == MISC_DYNAMIC_MINOR)))
+		/* Only one device can register for /dev/watchdog */
+		if (test_and_set_bit(0, &watchdog_dev_busy)) {
+			pr_err("only one watchdog can use /dev/watchdog\n");
+			return -EBUSY;
+		}
+#endif
 	/* Only one device can register for /dev/watchdog */
 	if (test_and_set_bit(0, &watchdog_dev_busy)) {
 		pr_err("only one watchdog can use /dev/watchdog\n");
@@ -357,18 +380,37 @@ int watchdog_dev_register(struct watchdog_device *watchdog)
 
 	wdd = watchdog;
 
+#ifdef CONFIG_SOFT_WATCHDOG_DYNDEV
+	if (!((watchdog->info->options & WDIOF_SDDYNMINOR) &&
+	      (watchdog->info->minor == MISC_DYNAMIC_MINOR)))
+		err = misc_register(&watchdog_miscdev);
+	else
+		err = misc_register(&watchdog_dynamic_miscdev);
+	if (err != 0) {
+		pr_err("%s: cannot register miscdev on minor=%d (err=%d)\n",
+		       watchdog->info->identity, MISC_DYNAMIC_MINOR, err);
+		goto out;
+	}
+#else
 	err = misc_register(&watchdog_miscdev);
 	if (err != 0) {
 		pr_err("%s: cannot register miscdev on minor=%d (err=%d)\n",
 		       watchdog->info->identity, WATCHDOG_MINOR, err);
 		goto out;
 	}
+#endif
 
 	return 0;
 
 out:
 	wdd = NULL;
+#ifdef CONFIG_SOFT_WATCHDOG_DYNDEV
+	if (!((watchdog->info->options & WDIOF_SDDYNMINOR) &&
+	      (watchdog->info->minor == MISC_DYNAMIC_MINOR)))
+		clear_bit(0, &watchdog_dev_busy);
+#else
 	clear_bit(0, &watchdog_dev_busy);
+#endif
 	return err;
 }
 
@@ -381,6 +423,29 @@ out:
 
 int watchdog_dev_unregister(struct watchdog_device *watchdog)
 {
+#ifdef CONFIG_SOFT_WATCHDOG_DYNDEV
+	if (!((watchdog->info->options & WDIOF_SDDYNMINOR) &&
+	      (watchdog->info->minor == MISC_DYNAMIC_MINOR))) {
+		if (misc_deregister(&watchdog_dynamic_miscdev) < 0) {
+			return -ENODEV;
+		}
+	} else {
+		/* Check that a watchdog device was registered in the past */
+		if (!test_bit(0, &watchdog_dev_busy) || !wdd)
+			return -ENODEV;
+
+		/* We can only unregister the watchdog device that was registered */
+		if (watchdog != wdd) {
+			pr_err("%s: watchdog was not registered as /dev/watchdog\n",
+			       watchdog->info->identity);
+			return -ENODEV;
+		}
+
+		misc_deregister(&watchdog_miscdev);
+		wdd = NULL;
+		clear_bit(0, &watchdog_dev_busy);
+	}
+#else
 	/* Check that a watchdog device was registered in the past */
 	if (!test_bit(0, &watchdog_dev_busy) || !wdd)
 		return -ENODEV;
@@ -395,5 +460,6 @@ int watchdog_dev_unregister(struct watchdog_device *watchdog)
 	misc_deregister(&watchdog_miscdev);
 	wdd = NULL;
 	clear_bit(0, &watchdog_dev_busy);
+#endif
 	return 0;
 }
diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index ac40716..4485480 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -18,6 +18,9 @@ struct watchdog_info {
 	__u32 options;		/* Options the card/driver supports */
 	__u32 firmware_version;	/* Firmware version of the card */
 	__u8  identity[32];	/* Identity of the board */
+#ifdef CONFIG_SOFT_WATCHDOG_DYNDEV
+	__u32 minor;		/* Device minor number */
+#endif
 };
 
 #define	WDIOC_GETSUPPORT	_IOR(WATCHDOG_IOCTL_BASE, 0, struct watchdog_info)
@@ -46,6 +49,7 @@ struct watchdog_info {
 #define	WDIOF_MAGICCLOSE	0x0100	/* Supports magic close char */
 #define	WDIOF_PRETIMEOUT	0x0200  /* Pretimeout (in seconds), get/set */
 #define	WDIOF_KEEPALIVEPING	0x8000	/* Keep alive ping reply */
+#define	WDIOF_SDDYNMINOR	0x4000	/* Support a dynamic minor number for softdogs */
 
 #define	WDIOS_DISABLECARD	0x0001	/* Turn off the watchdog timer */
 #define	WDIOS_ENABLECARD	0x0002	/* Turn on the watchdog timer */
-- 
1.7.9.7

