memcg: fix BUG: using smp_processor_id() in preemptible

A combination of upstream (e.g. addb9efe) and as per discussion
on rt list (Dec 2008) between Tim Blechmann and Kamezawa Hiroyuki,
this is needed to fix the following:

BUG: using smp_processor_id() in preemptible [00000000] code: swapper/1
caller is mem_cgroup_charge_statistics+0x85/0xa0
Pid: 1, comm: swapper Not tainted 2.6.26.8-rt12 #1

Call Trace:
 [<ffffffff8038eb94>] debug_smp_processor_id+0xc4/0xd0
 [<ffffffff8029ffe5>] mem_cgroup_charge_statistics+0x85/0xa0
 [<ffffffff802a0039>] __mem_cgroup_add_list+0x39/0x60
 [<ffffffff802a0807>] mem_cgroup_charge_common+0x317/0x340
 [<ffffffff802a0849>] mem_cgroup_cache_charge+0x19/0x20
 [<ffffffff80276918>] add_to_page_cache+0x38/0x250
 [<ffffffff8027d43d>] ? __alloc_pages_internal+0xed/0x4f0
 [<ffffffff80276b49>] add_to_page_cache_lru+0x19/0x40
 [<ffffffff80277603>] find_or_create_page+0x63/0xb0
 [<ffffffff802cd401>] __getblk+0x101/0x320
 [<ffffffff802fddd6>] __ext3_get_inode_loc+0x106/0x320
 [<ffffffff802fe060>] ext3_iget+0x70/0x420
 [<ffffffff80305068>] ext3_lookup+0xa8/0x100

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>


---
 mm/memcontrol.c |   19 ++++++++++++-------
 1 files changed, 12 insertions(+), 7 deletions(-)

diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index ed1cfb1..86e7f14 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -65,11 +65,11 @@ struct mem_cgroup_stat {
 /*
  * For accounting under irq disable, no need for increment preempt count.
  */
-static void __mem_cgroup_stat_add_safe(struct mem_cgroup_stat *stat,
+static inline void __mem_cgroup_stat_add_safe(struct mem_cgroup_stat_cpu *stat,
 		enum mem_cgroup_stat_index idx, int val)
 {
-	int cpu = smp_processor_id();
-	stat->cpustat[cpu].count[idx] += val;
+	stat->count[idx] += val;
+
 }
 
 static s64 mem_cgroup_read_stat(struct mem_cgroup_stat *stat,
@@ -195,19 +195,24 @@ static void mem_cgroup_charge_statistics(struct mem_cgroup *mem, int flags,
 {
 	int val = (charge)? 1 : -1;
 	struct mem_cgroup_stat *stat = &mem->stat;
+	struct mem_cgroup_stat_cpu *cpustat;
+	int cpu = get_cpu();
 
 	VM_BUG_ON(!irqs_disabled());
+
+	cpustat = &stat->cpustat[cpu];
 	if (flags & PAGE_CGROUP_FLAG_CACHE)
-		__mem_cgroup_stat_add_safe(stat, MEM_CGROUP_STAT_CACHE, val);
+		__mem_cgroup_stat_add_safe(cpustat, MEM_CGROUP_STAT_CACHE, val);
 	else
-		__mem_cgroup_stat_add_safe(stat, MEM_CGROUP_STAT_RSS, val);
+		__mem_cgroup_stat_add_safe(cpustat, MEM_CGROUP_STAT_RSS, val);
 
 	if (charge)
-		__mem_cgroup_stat_add_safe(stat,
+		__mem_cgroup_stat_add_safe(cpustat,
 				MEM_CGROUP_STAT_PGPGIN_COUNT, 1);
 	else
-		__mem_cgroup_stat_add_safe(stat,
+		__mem_cgroup_stat_add_safe(cpustat,
 				MEM_CGROUP_STAT_PGPGOUT_COUNT, 1);
+	put_cpu();
 }
 
 static struct mem_cgroup_per_zone *
