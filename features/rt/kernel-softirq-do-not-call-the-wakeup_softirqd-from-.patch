From 5cd2469911b91f9159eec1c8bf4eb55deb0937fc Mon Sep 17 00:00:00 2001
From: Shan Hai <shan.hai@windriver.com>
Date: Tue, 22 Dec 2015 09:03:17 +0800
Subject: [PATCH] kernel/softirq: do not call the wakeup_softirqd() from
 interrupt context

The "softirqs: forced threading of softirqs" commit removes in_interrupt()
checking before calling wakeup_softirqd() from raise_softirq_irqoff() in
CGL kernel, which causes following dead lock under certain workload, fix it
by adding in_interrupt() check in raise_softirq_irqoff() to avoid calling of
the wakeup_softirqd() from interrupt context.

Even though the interrupts are threaded in the CGL kernel but there is an
exception, the timer interrupt, which is not threaded like other interrupts.
And there is a kernel control path which starts from hrtimer_interrupt
to wakeup_softirqd() from interrupt context as following call trace indicates.

The in_interrupt() checking is correct for below reasons:
o calling wakeup_softirqd() is not necessary from interrupt context for
	marking of the softirq pending is cpu local and the softirq could
	not preempt hardirq
o the softirq kernel daemon will be wokeup by invoke_softirq() in irq_exit()
	before returning from interrupt handler, so we do not lose any chance
	waking up the softirqd even if not calling wakeup_softirqd() from
	interrupt context
o if the wakeup_softirqd() is called from interrupt thread(process context)
	the in_interrupt() checking would do no harm except adds neglectable
	overhead

A dead lock scnario caused by recursive locking for calling wakeup_softirqd
from interrupt context(the rq->lock was held at c003689c and then the same
control path tries to hold the same rq->lock at c002afb0):

NIP [c05dd8fc] __raw_spin_lock+0x8c/0xb0
LR [c05dd8d8] __raw_spin_lock+0x68/0xb0
Call Trace:
[ef997bd0] [c05dd8d8] __raw_spin_lock+0x68/0xb0 (unreliable)
[ef997be0] [c002afb0] task_rq_lock+0x50/0xa0
[ef997c00] [c003672c] try_to_wake_up+0x4c/0x400
[ef997c40] [c00437bc] wakeup_softirqd+0x5c/0x70
[ef997c50] [c0060208] __hrtimer_start_range_ns+0x258/0x360
[ef997cb0] [c002fcf0] __enqueue_rt_entity+0x1c0/0x380
[ef997ce0] [c003043c] enqueue_rt_entity+0x7c/0xa0
[ef997d00] [c0030914] enqueue_task_rt+0x34/0x90
[ef997d10] [c0028040] enqueue_task+0x40/0x60
[ef997d20] [c00281d4] activate_task+0x44/0x70
[ef997d30] [c003689c] try_to_wake_up+0x1bc/0x400
[ef997d70] [c004e9f4] signal_wake_up+0x44/0x70
[ef997d80] [c005140c] send_sigqueue+0xfc/0x160
[ef997db0] [c005a0ec] posix_timer_event+0x4c/0x80
[ef997dc0] [c005a170] posix_timer_fn+0x50/0x190
[ef997df0] [c005f3b0] __run_hrtimer+0x50/0xd0
[ef997e10] [c0060758] hrtimer_interrupt+0x158/0x440
[ef997e90] [c000dcac] native_timer_interrupt+0x10c/0x1b0
[ef997eb0] [c000ce90] timer_interrupt+0x10/0x20
[ef997ec0] [c0012060] ret_from_except+0x0/0x18
---
 kernel/softirq.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/kernel/softirq.c b/kernel/softirq.c
index 6d99258..b5490018 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -558,7 +558,8 @@ inline void raise_softirq_irqoff(unsigned int nr)
 	__do_raise_softirq_irqoff(nr);
 
 #ifdef CONFIG_PREEMPT_SOFTIRQS
-	wakeup_softirqd(nr);
+	if (!in_interrupt())
+		wakeup_softirqd(nr);
 #endif
 }
 
-- 
1.7.5.4

