From f38aa5f349ab8e78471d1f8ea0d04821af67e741 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Sun, 5 Jun 2016 08:11:13 +0200
Subject: [PATCH] mm/memcontrol: consume/refill stock - local_irq_disable -->
 local_lock_irq

v4.8 grew more local_irq_disable() in mm/memcontrol.c

Convert them to use the existing local_lock(event_lock) like the others.

Based on similar patch by Mike Galbraith <umgwanakikbuti@gmail.com>

Upstream commit is db2ba40c277dc ("mm: memcontrol: make per-cpu charge
cache IRQ-safe for socket accounting")

This also replaces the old -rt patch:
    cgroups-scheduling-while-atomic-in-cgroup-code.patch
that used cpu light in the refill path.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index 462c0feb8da2..fe590c345f99 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -1749,7 +1749,7 @@ static bool consume_stock(struct mem_cgroup *memcg, unsigned int nr_pages)
 	if (nr_pages > CHARGE_BATCH)
 		return ret;
 
-	local_irq_save(flags);
+	local_lock_irqsave(event_lock, flags);
 
 	stock = this_cpu_ptr(&memcg_stock);
 	if (memcg == stock->cached && stock->nr_pages >= nr_pages) {
@@ -1757,7 +1757,7 @@ static bool consume_stock(struct mem_cgroup *memcg, unsigned int nr_pages)
 		ret = true;
 	}
 
-	local_irq_restore(flags);
+	local_unlock_irqrestore(event_lock, flags);
 
 	return ret;
 }
@@ -1802,7 +1802,7 @@ static void refill_stock(struct mem_cgroup *memcg, unsigned int nr_pages)
 	struct memcg_stock_pcp *stock;
 	unsigned long flags;
 
-	local_irq_save(flags);
+	local_lock_irqsave(event_lock, flags);
 
 	stock = this_cpu_ptr(&memcg_stock);
 	if (stock->cached != memcg) { /* reset if necessary */
@@ -1811,7 +1811,7 @@ static void refill_stock(struct mem_cgroup *memcg, unsigned int nr_pages)
 	}
 	stock->nr_pages += nr_pages;
 
-	local_irq_restore(flags);
+	local_unlock_irqrestore(event_lock, flags);
 }
 
 /*
-- 
2.10.0

