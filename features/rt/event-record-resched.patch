From: Steven Rostedt <srostedt@redhat.com>
Subject: event trace: add tracing of resched_task

Signed-off-by: Steven Rostedt <srostedt@redhat.com>
---
 kernel/trace/trace.c        |   36 ++++++++++++++++++++++++++++++++++++
 kernel/trace/trace.h        |    7 +++++++
 kernel/trace/trace_events.c |   38 +++++++++++++++++++++++++++++++++++++-
 3 files changed, 80 insertions(+), 1 deletions(-)

diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 2bcfa52..5a2b856 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -1104,6 +1104,24 @@ void tracing_event_program_event(struct trace_array *tr,
 	entry->program.delta	= *delta;
 }
 
+void tracing_event_resched_task(struct trace_array *tr,
+				struct trace_array_cpu *data,
+				unsigned long flags,
+				unsigned long ip,
+				struct task_struct *p,
+				int cpu)
+{
+	struct trace_entry *entry;
+
+	entry = tracing_get_trace_entry(tr, data);
+	tracing_generic_entry_update(entry, flags);
+	entry->type		= TRACE_RESCHED_TASK;
+	entry->task.ip	= ip;
+	entry->task.prio	= p->prio;
+	entry->task.pid	= p->pid;
+	entry->task.cpu	= cpu;
+}
+
 void tracing_event_timer_triggered(struct trace_array *tr,
 				   struct trace_array_cpu *data,
 				   unsigned long flags,
@@ -1792,6 +1810,15 @@ print_lat_fmt(struct trace_iterator *iter, unsigned int trace_idx, int cpu)
 		trace_print_ktime(s, entry->program.expire);
 		trace_seq_printf(s, " (%Ld)\n", entry->program.delta);
 		break;
+	case TRACE_RESCHED_TASK:
+		seq_print_ip_sym(s, entry->program.ip, sym_flags);
+		comm = trace_find_cmdline(entry->task.pid);
+		trace_seq_printf(s, " ++> [%03d] %5d:%3d %s\n",
+				 entry->task.cpu,
+				 entry->task.pid,
+				 entry->task.prio,
+				 comm);
+		break;
 	case TRACE_TASK_ACT:
 		seq_print_ip_sym(s, entry->task.ip, sym_flags);
 		comm = trace_find_cmdline(entry->task.pid);
@@ -1976,6 +2003,15 @@ static int print_trace_fmt(struct trace_iterator *iter)
 		trace_print_ktime(s, entry->program.expire);
 		trace_seq_printf(s, " (%Ld)\n", entry->program.delta);
 		break;
+	case TRACE_RESCHED_TASK:
+		seq_print_ip_sym(s, entry->program.ip, sym_flags);
+		comm = trace_find_cmdline(entry->task.pid);
+		trace_seq_printf(s, " ++> [%03d] %5d:%3d %s\n",
+				 entry->task.cpu,
+				 entry->task.pid,
+				 entry->task.prio,
+				 comm);
+		break;
 	case TRACE_TASK_ACT:
 		seq_print_ip_sym(s, entry->task.ip, sym_flags);
 		comm = trace_find_cmdline(entry->task.pid);
diff --git a/kernel/trace/trace.h b/kernel/trace/trace.h
index f62256b..013c43c 100644
--- a/kernel/trace/trace.h
+++ b/kernel/trace/trace.h
@@ -23,6 +23,7 @@ enum trace_type {
 	TRACE_TIMER_TRIG,
 	TRACE_TIMESTAMP,
 	TRACE_PROGRAM_EVENT,
+	TRACE_RESCHED_TASK,
 	TRACE_TASK_ACT,
 	TRACE_TASK_DEACT,
 	TRACE_SYSCALL,
@@ -344,6 +345,12 @@ void tracing_event_program_event(struct trace_array *tr,
 				 unsigned long flags,
 				 unsigned long ip,
 				 ktime_t *expires, int64_t *delta);
+void tracing_event_resched_task(struct trace_array *tr,
+				struct trace_array_cpu *data,
+				unsigned long flags,
+				unsigned long ip,
+				struct task_struct *p,
+				int cpu);
 void tracing_event_wakeup(struct trace_array *tr,
 			  struct trace_array_cpu *data,
 			  unsigned long flags,
diff --git a/kernel/trace/trace_events.c b/kernel/trace/trace_events.c
index c33931b..38e0eba 100644
--- a/kernel/trace/trace_events.c
+++ b/kernel/trace/trace_events.c
@@ -291,6 +291,32 @@ event_program_event_callback(ktime_t *expires, int64_t *delta)
 	atomic_dec(&data->disabled);
 }
 
+static void
+event_resched_task_callback(struct task_struct *task, int task_cpu)
+{
+	struct trace_array *tr = events_trace;
+	struct trace_array_cpu *data;
+	unsigned long flags;
+	long disable;
+	int cpu;
+
+	if (!tracer_enabled || function_trace_stop)
+		return;
+
+	/* interrupts should be off, we are in an interrupt */
+	cpu = smp_processor_id();
+	data = tr->data[cpu];
+
+	disable = atomic_inc_return(&data->disabled);
+	if (disable != 1)
+		goto out;
+
+	local_save_flags(flags);
+	tracing_event_resched_task(tr, data, flags, CALLER_ADDR1, task, task_cpu);
+
+ out:
+	atomic_dec(&data->disabled);
+}
 
 static void
 event_task_activate_callback(struct task_struct *p, int rqcpu)
@@ -488,10 +514,19 @@ static void event_tracer_register(struct trace_array *tr)
 		goto out10;
 	}
 
+	ret = register_trace_sched_resched_task(event_resched_task_callback);
+	if (ret) {
+		pr_info("event trace: Couldn't activate tracepoint"
+			" probe to kernel_event_resched_task\n");
+		goto out11;
+	}
+
 	return;
 
- out10:
+ out11:
 	unregister_trace_event_program_event(event_program_event_callback);
+ out10:
+	unregister_trace_sched_switch(event_ctx_callback);
  out9:
 	unregister_trace_sched_wakeup_new(event_wakeup_callback);
  out8:
@@ -514,6 +549,7 @@ static void event_tracer_register(struct trace_array *tr)
 
 static void event_tracer_unregister(struct trace_array *tr)
 {
+	unregister_trace_sched_resched_task(event_resched_task_callback);
 	unregister_trace_event_program_event(event_program_event_callback);
 	unregister_trace_sched_switch(event_ctx_callback);
 	unregister_trace_sched_wakeup_new(event_wakeup_callback);
