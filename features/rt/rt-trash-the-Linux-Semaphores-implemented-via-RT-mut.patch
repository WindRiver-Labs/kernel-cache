From 3a281b343cf1d0cd111a4dc0560600b3fc91062d Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Mon, 17 Jan 2011 20:56:11 -0500
Subject: [PATCH] rt: trash the Linux Semaphores implemented via RT-mutexes

This is one of several extractions from the merge up to 33-rc8.

Best seen in the tip repo with:

	git diff 5f854cfc024622e4aae14d7cf422f6ff86278688^1 \
		 5f854cfc024622e4aae14d7cf422f6ff86278688 kernel/rt.c

i.e. show the difference between the 1st parent of the merge
(which is kernel.org default) and the code after the change.

You can find the origin of this change in the tip merge commit:

     commit 5f854cfc024622e4aae14d7cf422f6ff86278688
     Merge: cc24da0 4ec62b2
     Author: Thomas Gleixner <tglx@linutronix.de>
     Date:   Sun Feb 21 20:17:22 2010 +0100

         Forward to 2.6.33-rc8

         Merge branch 'linus' into rt/head with a pile of conflicts.

         Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

Normally there are not significant changes/additions in a merge commit that
are not from any other "normal" commit.  But in this case there are, so
break them out into separate explicit commits.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 kernel/rt.c |  133 -----------------------------------------------------------
 1 files changed, 0 insertions(+), 133 deletions(-)

diff --git a/kernel/rt.c b/kernel/rt.c
index fd033a9..ccbf20f 100644
--- a/kernel/rt.c
+++ b/kernel/rt.c
@@ -408,139 +408,6 @@ void  __rt_rwsem_init(struct rw_semaphore *rwsem, char *name,
 }
 EXPORT_SYMBOL(__rt_rwsem_init);
 
-/*
- * Semaphores
- */
-/*
- * Linux Semaphores implemented via RT-mutexes.
- *
- * In the down() variants we use the mutex as the semaphore blocking
- * object: we always acquire it, decrease the counter and keep the lock
- * locked if we did the 1->0 transition. The next down() will then block.
- *
- * In the up() path we atomically increase the counter and do the
- * unlock if we were the one doing the 0->1 transition.
- */
-
-static inline void __down_complete(struct semaphore *sem)
-{
-	int count = atomic_dec_return(&sem->count);
-
-	if (unlikely(count > 0))
-		rt_mutex_unlock(&sem->lock);
-}
-
-void  rt_down(struct semaphore *sem)
-{
-	rt_mutex_lock(&sem->lock);
-	__down_complete(sem);
-}
-EXPORT_SYMBOL(rt_down);
-
-int  rt_down_interruptible(struct semaphore *sem)
-{
-	int ret;
-
-	ret = rt_mutex_lock_interruptible(&sem->lock, 0);
-	if (ret)
-		return ret;
-	__down_complete(sem);
-	return 0;
-}
-EXPORT_SYMBOL(rt_down_interruptible);
-
-int rt_down_timeout(struct semaphore *sem, long jiff)
-{
-	struct hrtimer_sleeper t;
-	struct timespec ts;
-	unsigned long expires = jiffies + jiff + 1;
-	int ret;
-
-	/*
-	 * rt_mutex_slowlock can use an interruptible, but this needs to
-	 * be TASK_INTERRUPTIBLE. The down_timeout uses TASK_UNINTERRUPTIBLE.
-	 * To handle this we loop if a signal caused the timeout and the
-	 * we recalculate the new timeout.
-	 * Yes Thomas, this is a hack! But we can fix it right later.
-	 */
-	do {
-		jiffies_to_timespec(jiff, &ts);
-		hrtimer_init_on_stack(&t.timer, HRTIMER_MODE_REL, CLOCK_MONOTONIC);
-		t.timer._expires = timespec_to_ktime(ts);
-
-		ret = rt_mutex_timed_lock(&sem->lock, &t, 0);
-		if (ret != -EINTR)
-			break;
-
-		/* signal occured, but the down_timeout doesn't handle them */
-		jiff = expires - jiffies;
-
-	} while (jiff > 0);
-
-	if (!ret)
-		__down_complete(sem);
-	else
-		ret = -ETIME;
-
-	return ret;
-}
-EXPORT_SYMBOL(rt_down_timeout);
-
-/*
- * try to down the semaphore, 0 on success and 1 on failure. (inverted)
- */
-int  rt_down_trylock(struct semaphore *sem)
-{
-	/*
-	 * Here we are a tiny bit different from ordinary Linux semaphores,
-	 * because we can get 'transient' locking-failures when say a
-	 * process decreases the count from 9 to 8 and locks/releases the
-	 * embedded mutex internally. It would be quite complex to remove
-	 * these transient failures so lets try it the simple way first:
-	 */
-	if (rt_mutex_trylock(&sem->lock)) {
-		__down_complete(sem);
-		return 0;
-	}
-	return 1;
-}
-EXPORT_SYMBOL(rt_down_trylock);
-
-void  rt_up(struct semaphore *sem)
-{
-	int count;
-
-	/*
-	 * Disable preemption to make sure a highprio trylock-er cannot
-	 * preempt us here and get into an infinite loop:
-	 */
-	preempt_disable();
-	count = atomic_inc_return(&sem->count);
-	/*
-	 * If we did the 0 -> 1 transition then we are the ones to unlock it:
-	 */
-	if (likely(count == 1))
-		rt_mutex_unlock(&sem->lock);
-	preempt_enable();
-}
-EXPORT_SYMBOL(rt_up);
-
-void  __sema_init(struct semaphore *sem, int val,
-			  char *name, char *file, int line)
-{
-	atomic_set(&sem->count, val);
-	switch (val) {
-	case 0:
-		__rt_mutex_init(&sem->lock, name);
-		rt_mutex_lock(&sem->lock);
-		break;
-	default:
-		__rt_mutex_init(&sem->lock, name);
-		break;
-	}
-}
-EXPORT_SYMBOL(__sema_init);
-
 /**
  * atomic_dec_and_mutex_lock - return holding mutex if we dec to 0
  * @cnt: the atomic which we are to dec
-- 
1.7.0.4

