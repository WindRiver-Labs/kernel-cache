From: Peter Zijlstra

---
 include/linux/hardirq.h |   28 ++++++++++++++++++++++++----
 kernel/sched_clock.c    |    9 +++++++++
 2 files changed, 33 insertions(+), 4 deletions(-)

diff --git a/include/linux/hardirq.h b/include/linux/hardirq.h
index 9fd2079..9c7cbbc 100644
--- a/include/linux/hardirq.h
+++ b/include/linux/hardirq.h
@@ -22,10 +22,13 @@
  * PREEMPT_MASK: 0x000000ff
  * SOFTIRQ_MASK: 0x0000ff00
  * HARDIRQ_MASK: 0x0fff0000
+ * HARDNMI_MASK: 0x40000000
  */
 #define PREEMPT_BITS	8
 #define SOFTIRQ_BITS	8
 
+#define HARDNMI_BITS	1
+
 #ifndef HARDIRQ_BITS
 #define HARDIRQ_BITS	12
 
@@ -46,30 +49,35 @@
 #define PREEMPT_SHIFT		0
 #define SOFTIRQ_SHIFT		(PREEMPT_SHIFT + PREEMPT_BITS)
 #define HARDIRQ_SHIFT		(SOFTIRQ_SHIFT + SOFTIRQ_BITS)
-#define PREEMPT_ACTIVE_SHIFT	(HARDIRQ_SHIFT + HARDIRQ_BITS)
+#define HARDNMI_SHIFT  		(30)
 
 #define __IRQ_MASK(x)		((1UL << (x))-1)
 
 #define PREEMPT_MASK		(__IRQ_MASK(PREEMPT_BITS) << PREEMPT_SHIFT)
 #define SOFTIRQ_MASK		(__IRQ_MASK(SOFTIRQ_BITS) << SOFTIRQ_SHIFT)
 #define HARDIRQ_MASK		(__IRQ_MASK(HARDIRQ_BITS) << HARDIRQ_SHIFT)
+#define HARDNMI_MASK   		(__IRQ_MASK(HARDNMI_BITS) << HARDNMI_SHIFT)
 
 #define PREEMPT_OFFSET		(1UL << PREEMPT_SHIFT)
 #define SOFTIRQ_OFFSET		(1UL << SOFTIRQ_SHIFT)
 #define HARDIRQ_OFFSET		(1UL << HARDIRQ_SHIFT)
+#define HARDNMI_OFFSET 		(1UL << HARDNMI_SHIFT)
 
 #if PREEMPT_ACTIVE < (1 << (HARDIRQ_SHIFT + HARDIRQ_BITS))
 # error PREEMPT_ACTIVE is too low!
 #endif
 
+#define hardnmi_count()	(preempt_count() & HARDNMI_MASK)
 #define hardirq_count()	(preempt_count() & HARDIRQ_MASK)
 #define softirq_count()	(preempt_count() & SOFTIRQ_MASK)
-#define irq_count()	(preempt_count() & (HARDIRQ_MASK | SOFTIRQ_MASK))
+#define irq_count()	\
+	(preempt_count() & (HARDNMI_MASK | HARDIRQ_MASK | SOFTIRQ_MASK))
 
 /*
  * Are we doing bottom half or hardware interrupt processing?
  * Are we in a softirq context? Interrupt context?
  */
+#define in_nmi()	(hardnmi_count())
 #define in_irq()	(hardirq_count() || (current->flags & PF_HARDIRQ))
 #define in_softirq()	(softirq_count() || (current->flags & PF_SOFTIRQ))
 #define in_interrupt()	(irq_count())
@@ -161,7 +169,19 @@ extern void irq_enter(void);
  */
 extern void irq_exit(void);
 
-#define nmi_enter()		do { lockdep_off(); __irq_enter(); } while (0)
-#define nmi_exit()		do { __irq_exit(); lockdep_on(); } while (0)
+#define nmi_enter()					\
+	do {                                            \
+		lockdep_off();                          \
+		BUG_ON(hardnmi_count());                \
+		add_preempt_count(HARDNMI_OFFSET);      \
+		__irq_enter();                          \
+	} while (0)
+
+#define nmi_exit()					\
+	do {                                            \
+		__irq_exit();                           \
+		sub_preempt_count(HARDNMI_OFFSET);      \
+		lockdep_on();                           \
+	} while (0)
 
 #endif /* LINUX_HARDIRQ_H */
diff --git a/kernel/sched_clock.c b/kernel/sched_clock.c
index c2d232f..73c2f95 100644
--- a/kernel/sched_clock.c
+++ b/kernel/sched_clock.c
@@ -157,6 +157,7 @@ u64 sched_clock_cpu(int cpu)
 	WARN_ON_ONCE(!irqs_disabled());
 	now = sched_clock();
 
+#if 0
 	if (cpu != raw_smp_processor_id()) {
 		struct sched_clock_data *my_scd = this_scd();
 
@@ -189,6 +190,14 @@ u64 sched_clock_cpu(int cpu)
 	}
 
 	__raw_spin_unlock(&scd->lock);
+#else
+	if (cpu == smp_processor_id() && __raw_spin_trylock(&scd->lock)) {
+		__update_sched_clock(scd, now);
+		clock = scd->clock;
+		__raw_spin_unlock(&scd->lock);
+	} else
+		clock = scd->clock;
+#endif
 
 	return clock;
 }
