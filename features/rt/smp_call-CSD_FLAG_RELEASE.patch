From: Steven Rostedt <srostedt@redhat.com>
Date: Tue, 27 Jan 2009 22:18:42 -0500
Subject: [PATCH] preempt-rt: avoid any calls to memory allocator in IPIs

In PREEMPT_RT, the memory allocators call sleeping locks even on
GFP_ATOMIC. There are some cases that still have preemption disabled
in PREEMPT_RT, and these cases can not call memory functions.

One case is the IPI. This patch is a hack to get around needing
to call the memory functions from an IPI or even with preemption
disabled, like the call smp function is.

Signed-off-by: Steven Rostedt <srostedt@redhat.com>
(cherry picked from RT git a9e70a6365603e23d310e375d95739d04962323a)
diff --git a/include/linux/smp.h b/include/linux/smp.h
index 8ee91a9..2c98662 100644
--- a/include/linux/smp.h
+++ b/include/linux/smp.h
@@ -191,6 +191,7 @@ void smp_setup_processor_id(void);
 enum {
 	CSD_FLAG_WAIT		= 0x01,
 	CSD_FLAG_ALLOC		= 0x02,
+	CSD_FLAG_RELEASE	= 0x04,
 };
 
 #endif /* __LINUX_SMP_H */
diff --git a/kernel/smp.c b/kernel/smp.c
index b045947..46e9ee4 100644
--- a/kernel/smp.c
+++ b/kernel/smp.c
@@ -163,21 +163,31 @@ void generic_smp_call_function_single_interrupt(void)
 
 		while (!list_empty(&list)) {
 			struct call_single_data *data;
+			struct call_single_data d;
 
 			data = list_entry(list.next, struct call_single_data,
 						list);
 			list_del(&data->list);
 
+			d = *data;
+			data->flags &= ~CSD_FLAG_RELEASE;
+			smp_wmb();
+
 			/*
 			 * 'data' can be invalid after this call if
 			 * flags == 0 (when called through
 			 * generic_exec_single(), so save them away before
 			 * making the call.
 			 */
-			data_flags = data->flags;
+			data_flags = d.flags;
+			smp_rmb();
 
-			data->func(data->info);
+			d.func(d.info);
 
+			/*
+			 * data still exists if either of these
+			 * flags are true. We should not use d.
+			 */
 			if (data_flags & CSD_FLAG_WAIT) {
 				smp_wmb();
 				data->flags &= ~CSD_FLAG_WAIT;
@@ -222,9 +232,21 @@ int smp_call_function_single(int cpu, void (*func) (void *info), void *info,
 		struct call_single_data *data = NULL;
 
 		if (!wait) {
+#ifdef CONFIG_PREEMPT_RT
+			/* HACK
+			 * We can not allocate here because
+			 * we have preemption disabled.
+			 * Instead we let the calling function
+			 * let us know that they are done
+			 * with this data.
+			 */
+			data = &d;
+			data->flags = CSD_FLAG_RELEASE;
+#else
 			data = kmalloc(sizeof(*data), GFP_ATOMIC);
 			if (data)
 				data->flags = CSD_FLAG_ALLOC;
+#endif
 		}
 		if (!data) {
 			data = &d;
@@ -234,6 +256,11 @@ int smp_call_function_single(int cpu, void (*func) (void *info), void *info,
 		data->func = func;
 		data->info = info;
 		generic_exec_single(cpu, data);
+
+#ifdef CONFIG_PREEMPT_RT
+		while ((data->flags & CSD_FLAG_RELEASE))
+			cpu_relax();
+#endif
 	} else {
 		err = -ENXIO;	/* CPU not online */
 	}
