From: Steven Rostedt <srostedt@redhat.com>
Date: Tue, 27 Jan 2009 22:18:42 -0500
Subject: [PATCH] preempt-rt: avoid any calls to memory allocator in IPIs

In PREEMPT_RT, the memory allocators call sleeping locks even on
GFP_ATOMIC. There are some cases that still have preemption disabled
in PREEMPT_RT, and these cases can not call memory functions.

One case is the IPI. This patch is a hack to get around needing
to call the memory functions from an IPI or even with preemption
disabled, like the call smp function is.

Signed-off-by: Steven Rostedt <srostedt@redhat.com>
(cherry picked from RT git a9e70a6365603e23d310e375d95739d04962323a)
---
 kernel/smp.c |   32 ++++++++++++++++++++++++++++++--
 1 files changed, 30 insertions(+), 2 deletions(-)

diff --git a/kernel/smp.c b/kernel/smp.c
index 0f32131..7c428cf 100644
--- a/kernel/smp.c
+++ b/kernel/smp.c
@@ -18,6 +18,7 @@ __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(call_function_lock);
 enum {
 	CSD_FLAG_WAIT		= 0x01,
 	CSD_FLAG_ALLOC		= 0x02,
+	CSD_FLAG_RELEASE	= 0x04,
 };
 
 struct call_function_data {
@@ -168,21 +169,31 @@ void generic_smp_call_function_single_interrupt(void)
 
 		while (!list_empty(&list)) {
 			struct call_single_data *data;
+			struct call_single_data d;
 
 			data = list_entry(list.next, struct call_single_data,
 						list);
 			list_del(&data->list);
 
+			d = *data;
+			data->flags &= ~CSD_FLAG_RELEASE;
+			smp_wmb();
+
 			/*
 			 * 'data' can be invalid after this call if
 			 * flags == 0 (when called through
 			 * generic_exec_single(), so save them away before
 			 * making the call.
 			 */
-			data_flags = data->flags;
+			data_flags = d.flags;
+			smp_rmb();
 
-			data->func(data->info);
+			d.func(d.info);
 
+			/*
+			 * data still exists if either of these
+			 * flags are true. We should not use d.
+			 */
 			if (data_flags & CSD_FLAG_WAIT) {
 				smp_wmb();
 				data->flags &= ~CSD_FLAG_WAIT;
@@ -227,9 +238,21 @@ int smp_call_function_single(int cpu, void (*func) (void *info), void *info,
 		struct call_single_data *data = NULL;
 
 		if (!wait) {
+#ifdef CONFIG_PREEMPT_RT
+			/* HACK
+			 * We can not allocate here because
+			 * we have preemption disabled.
+			 * Instead we let the calling function
+			 * let us know that they are done
+			 * with this data.
+			 */
+			data = &d;
+			data->flags = CSD_FLAG_RELEASE;
+#else
 			data = kmalloc(sizeof(*data), GFP_ATOMIC);
 			if (data)
 				data->flags = CSD_FLAG_ALLOC;
+#endif
 		}
 		if (!data) {
 			data = &d;
@@ -239,6 +262,11 @@ int smp_call_function_single(int cpu, void (*func) (void *info), void *info,
 		data->func = func;
 		data->info = info;
 		generic_exec_single(cpu, data);
+
+#ifdef CONFIG_PREEMPT_RT
+		while ((data->flags & CSD_FLAG_RELEASE))
+			cpu_relax();
+#endif
 	} else {
 		err = -ENXIO;	/* CPU not online */
 	}
