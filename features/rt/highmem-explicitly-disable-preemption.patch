From: Thomas Gleixner <tglx@linutronix.de>
Date: Fri, 24 Jul 2009 15:23:05 +0200
Subject: highmem: Explicitely disable preemption

With the separation of pagefault_{disable,enable}() from the
preempt_count a previously overlooked dependancy became painfully
clear.

kmap_atomic() is per cpu and relies not only on disabling the
pagefault handler, but really needs preemption disabled too.

Make this explicit now - so that we can change pagefault_disable().

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

---
 arch/arm/include/asm/futex.h       |    4 ++--
 arch/arm/mm/highmem.c              |    3 +++
 arch/frv/include/asm/highmem.h     |    2 ++
 arch/frv/mm/highmem.c              |    2 ++
 arch/mips/mm/highmem.c             |    5 ++++-
 arch/mn10300/include/asm/highmem.h |    3 +++
 arch/powerpc/mm/highmem.c          |    4 +++-
 arch/sh/mm/kmap.c                  |    2 ++
 arch/sparc/mm/highmem.c            |    4 +++-
 arch/tile/mm/highmem.c             |    3 ++-
 arch/x86/mm/highmem_32.c           |    2 +-
 arch/x86/mm/iomap_32.c             |    2 ++
 12 files changed, 29 insertions(+), 7 deletions(-)

Index: linux-2.6-tip/arch/arm/include/asm/futex.h
===================================================================
--- linux-2.6-tip.orig/arch/arm/include/asm/futex.h
+++ linux-2.6-tip/arch/arm/include/asm/futex.h
@@ -125,7 +125,7 @@ futex_atomic_op_inuser (int encoded_op, 
 	if (!access_ok(VERIFY_WRITE, uaddr, sizeof(u32)))
 		return -EFAULT;
 
-	pagefault_disable();	/* implies preempt_disable() */
+	pagefault_disable();
 
 	switch (op) {
 	case FUTEX_OP_SET:
@@ -147,7 +147,7 @@ futex_atomic_op_inuser (int encoded_op, 
 		ret = -ENOSYS;
 	}
 
-	pagefault_enable();	/* subsumes preempt_enable() */
+	pagefault_enable();
 
 	if (!ret) {
 		switch (cmp) {
Index: linux-2.6-tip/arch/arm/mm/highmem.c
===================================================================
--- linux-2.6-tip.orig/arch/arm/mm/highmem.c
+++ linux-2.6-tip/arch/arm/mm/highmem.c
@@ -43,6 +43,7 @@ void *__kmap_atomic(struct page *page)
 	void *kmap;
 	int type;
 
+	preempt_disable();
 	pagefault_disable();
 	if (!PageHighMem(page))
 		return page_address(page);
@@ -107,6 +108,7 @@ void __kunmap_atomic(void *kvaddr)
 		kunmap_high(pte_page(pkmap_page_table[PKMAP_NR(vaddr)]));
 	}
 	pagefault_enable();
+	preempt_enable();
 }
 EXPORT_SYMBOL(__kunmap_atomic);
 
@@ -115,6 +117,7 @@ void *kmap_atomic_pfn(unsigned long pfn)
 	unsigned long vaddr;
 	int idx, type;
 
+	preempt_disable();
 	pagefault_disable();
 
 	type = kmap_atomic_idx_push();
Index: linux-2.6-tip/arch/frv/include/asm/highmem.h
===================================================================
--- linux-2.6-tip.orig/arch/frv/include/asm/highmem.h
+++ linux-2.6-tip/arch/frv/include/asm/highmem.h
@@ -116,6 +116,7 @@ static inline void *kmap_atomic_primary(
 {
 	unsigned long paddr;
 
+	preempt_disable();
 	pagefault_disable();
 	paddr = page_to_phys(page);
 
@@ -155,6 +156,7 @@ static inline void kunmap_atomic_primary
 		BUG();
 	}
 	pagefault_enable();
+	preempt_enable();
 }
 
 void *__kmap_atomic(struct page *page);
Index: linux-2.6-tip/arch/frv/mm/highmem.c
===================================================================
--- linux-2.6-tip.orig/arch/frv/mm/highmem.c
+++ linux-2.6-tip/arch/frv/mm/highmem.c
@@ -42,6 +42,7 @@ void *__kmap_atomic(struct page *page)
 	unsigned long paddr;
 	int type;
 
+	preempt_disable();
 	pagefault_disable();
 	type = kmap_atomic_idx_push();
 	paddr = page_to_phys(page);
@@ -85,5 +86,6 @@ void __kunmap_atomic(void *kvaddr)
 	}
 	kmap_atomic_idx_pop();
 	pagefault_enable();
+	preempt_enable();
 }
 EXPORT_SYMBOL(__kunmap_atomic);
Index: linux-2.6-tip/arch/mips/mm/highmem.c
===================================================================
--- linux-2.6-tip.orig/arch/mips/mm/highmem.c
+++ linux-2.6-tip/arch/mips/mm/highmem.c
@@ -46,7 +46,7 @@ void *__kmap_atomic(struct page *page)
 	unsigned long vaddr;
 	int idx, type;
 
-	/* even !CONFIG_PREEMPT needs this, for in_atomic in do_page_fault */
+	preempt_disable();
 	pagefault_disable();
 	if (!PageHighMem(page))
 		return page_address(page);
@@ -71,6 +71,7 @@ void __kunmap_atomic(void *kvaddr)
 
 	if (vaddr < FIXADDR_START) { // FIXME
 		pagefault_enable();
+		preempt_enable();
 		return;
 	}
 
@@ -91,6 +92,7 @@ void __kunmap_atomic(void *kvaddr)
 #endif
 	kmap_atomic_idx_pop();
 	pagefault_enable();
+	preempt_enable();
 }
 EXPORT_SYMBOL(__kunmap_atomic);
 
@@ -103,6 +105,7 @@ void *kmap_atomic_pfn(unsigned long pfn)
 	unsigned long vaddr;
 	int idx, type;
 
+	preempt_disable();
 	pagefault_disable();
 
 	type = kmap_atomic_idx_push();
Index: linux-2.6-tip/arch/mn10300/include/asm/highmem.h
===================================================================
--- linux-2.6-tip.orig/arch/mn10300/include/asm/highmem.h
+++ linux-2.6-tip/arch/mn10300/include/asm/highmem.h
@@ -75,6 +75,7 @@ static inline unsigned long __kmap_atomi
 	unsigned long vaddr;
 	int idx, type;
 
+	preempt_disable();
 	pagefault_disable();
 	if (page < highmem_start_page)
 		return page_address(page);
@@ -98,6 +99,7 @@ static inline void __kunmap_atomic(unsig
 
 	if (vaddr < FIXADDR_START) { /* FIXME */
 		pagefault_enable();
+		preempt_enable();
 		return;
 	}
 
@@ -122,6 +124,7 @@ static inline void __kunmap_atomic(unsig
 
 	kmap_atomic_idx_pop();
 	pagefault_enable();
+	preempt_enable();
 }
 #endif /* __KERNEL__ */
 
Index: linux-2.6-tip/arch/powerpc/mm/highmem.c
===================================================================
--- linux-2.6-tip.orig/arch/powerpc/mm/highmem.c
+++ linux-2.6-tip/arch/powerpc/mm/highmem.c
@@ -34,7 +34,7 @@ void *kmap_atomic_prot(struct page *page
 	unsigned long vaddr;
 	int idx, type;
 
-	/* even !CONFIG_PREEMPT needs this, for in_atomic in do_page_fault */
+	preempt_disable();
 	pagefault_disable();
 	if (!PageHighMem(page))
 		return page_address(page);
@@ -59,6 +59,7 @@ void __kunmap_atomic(void *kvaddr)
 
 	if (vaddr < __fix_to_virt(FIX_KMAP_END)) {
 		pagefault_enable();
+		preempt_enable();
 		return;
 	}
 
@@ -82,5 +83,6 @@ void __kunmap_atomic(void *kvaddr)
 
 	kmap_atomic_idx_pop();
 	pagefault_enable();
+	preempt_enable();
 }
 EXPORT_SYMBOL(__kunmap_atomic);
Index: linux-2.6-tip/arch/sh/mm/kmap.c
===================================================================
--- linux-2.6-tip.orig/arch/sh/mm/kmap.c
+++ linux-2.6-tip/arch/sh/mm/kmap.c
@@ -36,6 +36,7 @@ void *kmap_coherent(struct page *page, u
 
 	BUG_ON(!test_bit(PG_dcache_clean, &page->flags));
 
+	preempt_disable();
 	pagefault_disable();
 
 	idx = FIX_CMAP_END -
@@ -64,4 +65,5 @@ void kunmap_coherent(void *kvaddr)
 	}
 
 	pagefault_enable();
+	preempt_enable();
 }
Index: linux-2.6-tip/arch/sparc/mm/highmem.c
===================================================================
--- linux-2.6-tip.orig/arch/sparc/mm/highmem.c
+++ linux-2.6-tip/arch/sparc/mm/highmem.c
@@ -34,7 +34,7 @@ void *__kmap_atomic(struct page *page)
 	unsigned long vaddr;
 	long idx, type;
 
-	/* even !CONFIG_PREEMPT needs this, for in_atomic in do_page_fault */
+	preempt_disable();
 	pagefault_disable();
 	if (!PageHighMem(page))
 		return page_address(page);
@@ -72,6 +72,7 @@ void __kunmap_atomic(void *kvaddr)
 
 	if (vaddr < FIXADDR_START) { // FIXME
 		pagefault_enable();
+		preempt_enable();
 		return;
 	}
 
@@ -107,6 +108,7 @@ void __kunmap_atomic(void *kvaddr)
 
 	kmap_atomic_idx_pop();
 	pagefault_enable();
+	preempt_enable();
 }
 EXPORT_SYMBOL(__kunmap_atomic);
 
Index: linux-2.6-tip/arch/tile/mm/highmem.c
===================================================================
--- linux-2.6-tip.orig/arch/tile/mm/highmem.c
+++ linux-2.6-tip/arch/tile/mm/highmem.c
@@ -202,7 +202,7 @@ void *kmap_atomic_prot(struct page *page
 	int idx, type;
 	pte_t *pte;
 
-	/* even !CONFIG_PREEMPT needs this, for in_atomic in do_page_fault */
+	preempt_disable();
 	pagefault_disable();
 
 	/* Avoid icache flushes by disallowing atomic executable mappings. */
@@ -261,6 +261,7 @@ void __kunmap_atomic(void *kvaddr)
 
 	arch_flush_lazy_mmu_mode();
 	pagefault_enable();
+	preempt_enable();
 }
 EXPORT_SYMBOL(__kunmap_atomic);
 
Index: linux-2.6-tip/arch/x86/mm/highmem_32.c
===================================================================
--- linux-2.6-tip.orig/arch/x86/mm/highmem_32.c
+++ linux-2.6-tip/arch/x86/mm/highmem_32.c
@@ -34,7 +34,6 @@ void *kmap_atomic_prot(struct page *page
 	unsigned long vaddr;
 	int idx, type;
 
-	/* even !CONFIG_PREEMPT needs this, for in_atomic in do_page_fault */
 	pagefault_disable();
 
 	if (!PageHighMem(page))
@@ -97,6 +96,7 @@ void __kunmap_atomic(void *kvaddr)
 #endif
 
 	pagefault_enable();
+	preempt_enable();
 }
 EXPORT_SYMBOL(__kunmap_atomic);
 
Index: linux-2.6-tip/arch/x86/mm/iomap_32.c
===================================================================
--- linux-2.6-tip.orig/arch/x86/mm/iomap_32.c
+++ linux-2.6-tip/arch/x86/mm/iomap_32.c
@@ -59,6 +59,7 @@ void *kmap_atomic_prot_pfn(unsigned long
 	unsigned long vaddr;
 	int idx, type;
 
+	preempt_disable();
 	pagefault_disable();
 
 	type = kmap_atomic_idx_push();
@@ -115,5 +116,6 @@ iounmap_atomic(void __iomem *kvaddr)
 	}
 
 	pagefault_enable();
+	preempt_enable();
 }
 EXPORT_SYMBOL_GPL(iounmap_atomic);
