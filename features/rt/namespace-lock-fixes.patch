From chirag@linux.vnet.ibm.com Wed Jul 30 13:38:51 2008
Date: Wed, 30 Jul 2008 22:48:42 +0530
From: Chirag Jog <chirag@linux.vnet.ibm.com>
To: J?rgen Mell <j.mell@t-online.de>, Thomas Gleixner <tglx@linutronix.de>
Cc: Thomas Gleixner <tglx@linutronix.de>, LKML <linux-kernel@vger.kernel.org>, rt-users <linux-rt-users@vger.kernel.org>, Steven Rostedt <rostedt@goodmis.org>, Clark Williams <williams@redhat.com>, Peter Zijlstra <peterz@infradead.org>, Josh Triplett <josht@linux.vnet.ibm.com>, Timothy R. Chavez <tim.chavez@linux.vnet.ibm.com>
Subject: [PATCH] Fix Bug messages

    [ The following text is in the "iso-8859-1" character set. ]
    [ Your display is set for the "ANSI_X3.4-1968" character set.  ]
    [ Some characters may be displayed incorrectly. ]

* J?rgen Mell <j.mell@t-online.de> [2008-07-30 11:01:32]:

> Hello Thomas,
> 
> On Wednesday, 30. July 2008, Thomas Gleixner wrote:
> > We are pleased to announce the 2.6.26-rt1 tree, which can be
> > downloaded from the location:
> 
> I have tried the new kernel and have some good news and some bad news:
> 
> The good news: The machine boots and seems to run without major problems.
> 
> The bad news: It produces continuously lots of bug messages in the error 
> logs (cf. attached dmesg.tgz). The error at rtmutex.c:743 was already 
> present in 2.6.25-rt* when ACPI was enabled. The 'using smp_processor_id 
> ()  in preemptible code' is new here with 2.6.26.
> 
> Machine is an old Athlon XP (single core) on an EPOX mainboard with VIA 
> chipset.
> 
> If I can help with testing, please let me know.
> 
> Bye,
>          J?rgen
> 
> 
This patch should solve some of the bug messages.
It does two things:
1. Change rt_runtime_lock to be a raw spinlock as the comment above it
says: it is nested inside the rq lock.

2. Change mnt_writers to be a per_cpu locked variable.
This eliminates the need for the codepath to disable preemption and
then potentially sleep, leading to the BUG messages

Signed-Off-By: Chirag <chirag@linux.vnet.ibm.com>



---
 fs/namespace.c |   22 +++++++++++-----------
 1 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/fs/namespace.c b/fs/namespace.c
index 6e283c9..bd91158 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -180,13 +180,13 @@ struct mnt_writer {
 	unsigned long count;
 	struct vfsmount *mnt;
 } ____cacheline_aligned_in_smp;
-static DEFINE_PER_CPU(struct mnt_writer, mnt_writers);
+static DEFINE_PER_CPU_LOCKED(struct mnt_writer, mnt_writers);
 
 static int __init init_mnt_writers(void)
 {
 	int cpu;
 	for_each_possible_cpu(cpu) {
-		struct mnt_writer *writer = &per_cpu(mnt_writers, cpu);
+		struct mnt_writer *writer = &per_cpu_var_locked(mnt_writers, cpu);
 		spin_lock_init(&writer->lock);
 		lockdep_set_class(&writer->lock, &writer->lock_class);
 		writer->count = 0;
@@ -201,7 +201,7 @@ static void unlock_mnt_writers(void)
 	struct mnt_writer *cpu_writer;
 
 	for_each_possible_cpu(cpu) {
-		cpu_writer = &per_cpu(mnt_writers, cpu);
+		cpu_writer = &per_cpu_var_locked(mnt_writers, cpu);
 		spin_unlock(&cpu_writer->lock);
 	}
 }
@@ -253,8 +253,8 @@ int mnt_want_write(struct vfsmount *mnt)
 {
 	int ret = 0;
 	struct mnt_writer *cpu_writer;
-
-	cpu_writer = &get_cpu_var(mnt_writers);
+	int cpu = 0;
+	cpu_writer = &get_cpu_var_locked(mnt_writers, &cpu);
 	spin_lock(&cpu_writer->lock);
 	if (__mnt_is_readonly(mnt)) {
 		ret = -EROFS;
@@ -264,7 +264,7 @@ int mnt_want_write(struct vfsmount *mnt)
 	cpu_writer->count++;
 out:
 	spin_unlock(&cpu_writer->lock);
-	put_cpu_var(mnt_writers);
+	put_cpu_var_locked(mnt_writers, cpu);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(mnt_want_write);
@@ -275,7 +275,7 @@ static void lock_mnt_writers(void)
 	struct mnt_writer *cpu_writer;
 
 	for_each_possible_cpu(cpu) {
-		cpu_writer = &per_cpu(mnt_writers, cpu);
+		cpu_writer = &per_cpu_var_locked(mnt_writers, cpu);
 		spin_lock(&cpu_writer->lock);
 		__clear_mnt_count(cpu_writer);
 		cpu_writer->mnt = NULL;
@@ -333,8 +333,8 @@ void mnt_drop_write(struct vfsmount *mnt)
 {
 	int must_check_underflow = 0;
 	struct mnt_writer *cpu_writer;
-
-	cpu_writer = &get_cpu_var(mnt_writers);
+	int cpu = 0;
+	cpu_writer = &get_cpu_var_locked(mnt_writers, &cpu);
 	spin_lock(&cpu_writer->lock);
 
 	use_cpu_writer_for_mount(cpu_writer, mnt);
@@ -361,7 +361,7 @@ void mnt_drop_write(struct vfsmount *mnt)
 	 * __mnt_writers can underflow.  Without it,
 	 * we could theoretically wrap __mnt_writers.
 	 */
-	put_cpu_var(mnt_writers);
+	put_cpu_var_locked(mnt_writers, cpu);
 }
 EXPORT_SYMBOL_GPL(mnt_drop_write);
 
@@ -613,7 +613,7 @@ static inline void __mntput(struct vfsmount *mnt)
 	 * can come in.
 	 */
 	for_each_possible_cpu(cpu) {
-		struct mnt_writer *cpu_writer = &per_cpu(mnt_writers, cpu);
+		struct mnt_writer *cpu_writer = &per_cpu_var_locked(mnt_writers, cpu);
 		if (cpu_writer->mnt != mnt)
 			continue;
 		spin_lock(&cpu_writer->lock);
