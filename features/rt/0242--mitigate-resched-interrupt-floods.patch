From bba6acbd7d322d110d04e4d756e1bc6f26481178 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Tue, 30 Sep 2008 17:00:06 -0400
Subject: [PATCH] [PATCH 1/3] mitigate-resched-interrupt-floods

Mitigate rescheduling interrupt floods.

Background: preempt-rt sends a resched interrupt to all
other cpus whenever some realtime task gets preempted.
This is to give that task a chance to continue running
on some other cpu.  Unfortunately this can cause 'resched
interrupt floods' when there are large numbers of realtime
tasks on the system that are continually being preempted.

This patch reduces such interrupts by noting that it is
not necessary to send rescheduling interrupts to every cpu
in the system, just to those cpus in the affinity mask of
the task to be migrated.

This works well in the real world, as traditionally
realtime tasks are carefully targeted to specific cpus or
sets of cpus, meaning users often give such tasks reduced
affinity masks.

Signed-off-by: Joe Korty <joe.korty@ccur.com>
---
 arch/x86/kernel/smp.c |    9 +++++++++
 include/asm-x86/smp.h |    4 ++++
 include/linux/smp.h   |    9 +++++++++
 3 files changed, 22 insertions(+), 0 deletions(-)

diff --git a/arch/x86/kernel/smp.c b/arch/x86/kernel/smp.c
index a79d98a..48e551a 100644
--- a/arch/x86/kernel/smp.c
+++ b/arch/x86/kernel/smp.c
@@ -18,6 +18,7 @@
 #include <linux/spinlock.h>
 #include <linux/kernel_stat.h>
 #include <linux/mc146818rtc.h>
+#include <linux/cpumask.h>
 #include <linux/cache.h>
 #include <linux/interrupt.h>
 #include <linux/cpu.h>
@@ -121,6 +122,14 @@ static void native_smp_send_reschedule(int cpu)
 	send_IPI_mask(cpumask_of_cpu(cpu), RESCHEDULE_VECTOR);
 }
 
+void smp_send_reschedule_allbutself_cpumask(cpumask_t mask)
+{
+	cpu_clear(smp_processor_id(), mask);
+	cpus_and(mask, mask, cpu_online_map);
+	if (!cpus_empty(mask))
+		send_IPI_mask(mask, RESCHEDULE_VECTOR);
+}
+
 /*
  * this function sends a 'reschedule' IPI to all other CPUs.
  * This is used when RT tasks are starving and other CPUs
diff --git a/include/asm-x86/smp.h b/include/asm-x86/smp.h
index 3c877f7..c1487ff 100644
--- a/include/asm-x86/smp.h
+++ b/include/asm-x86/smp.h
@@ -204,5 +204,9 @@ static inline int hard_smp_processor_id(void)
 extern void cpu_uninit(void);
 #endif
 
+
+/* TODO: Put this in the Kconfig files. */
+#define HAVE_RESCHEDULE_ALLBUTSELF_CPUMASK 1
+
 #endif /* __ASSEMBLY__ */
 #endif
diff --git a/include/linux/smp.h b/include/linux/smp.h
index f8f41be..be9427a 100644
--- a/include/linux/smp.h
+++ b/include/linux/smp.h
@@ -52,6 +52,14 @@ extern void smp_send_reschedule_allbutself(void);
  */
 extern void smp_send_reschedule_allbutself(void);
 
+#ifdef HAVE_RESCHEDULE_ALLBUTSELF_CPUMASK
+extern void smp_send_reschedule_allbutself_cpumask(cpumask_t);
+#else
+static inline void smp_send_reschedule_allbutself_cpumask(cpumask_t mask) {
+	smp_send_reschedule_allbutself();
+}
+#endif
+
 
 /*
  * Prepare machine for booting other CPUs.
@@ -134,6 +142,7 @@ static inline int up_smp_call_function(void (*func)(void *), void *info)
 	})
 static inline void smp_send_reschedule(int cpu) { }
 static inline void smp_send_reschedule_allbutself(void) { }
+static inline void smp_send_reschedule_allbutself_cpumask(cpumask_t mask) { }
 #define num_booting_cpus()			1
 #define smp_prepare_boot_cpu()			do {} while (0)
 #define smp_call_function_single(cpuid, func, info, wait) \
-- 
1.6.0.90.g436ed

