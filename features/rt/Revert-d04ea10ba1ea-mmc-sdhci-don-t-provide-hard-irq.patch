From 6f233b40cecf82e4db909f2ddfee4f9d0ab90f24 Mon Sep 17 00:00:00 2001
From: Thomas Gleixner <tglx@linutronix.de>
Date: Sat, 19 Sep 2015 10:25:18 +0200
Subject: [PATCH] Revert d04ea10ba1ea mmc: sdhci: don't provide hard irq
 handler

This workaround cannot work because the logic in the SDHCI driver is:

interrupt
  hard_interrupt_handler()
    wake_thread_handler()

thread_handler()
  poke_hardware()
  wait_for_interrupt()

Now the reverted commit changed that to:

interrupt
    wake_thread()

thread()
  hard_interrupt_handler()
    thread_handler()
    poke_hardware()
    wait_for_interrupt()

Doesn't really work well because thread handler waits for
hard_interrupt_handler() to wake it up again.....

This revert reintroduces the problem which was tried to be solved by
this patch. This can't be solved at the driver level, this needs a
solution at the irq core code.

Reported-by: Nathan Sullivan <nathan.sullivan@ni.com>
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 9555d9805350..cbaf3df3ebd9 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -2677,31 +2677,6 @@ static irqreturn_t sdhci_thread_irq(int irq, void *dev_id)
 	return isr ? IRQ_HANDLED : IRQ_NONE;
 }
 
-#ifdef CONFIG_PREEMPT_RT_BASE
-static irqreturn_t sdhci_rt_irq(int irq, void *dev_id)
-{
-	irqreturn_t ret;
-
-	local_bh_disable();
-	ret = sdhci_irq(irq, dev_id);
-	local_bh_enable();
-	if (ret == IRQ_WAKE_THREAD)
-		ret = sdhci_thread_irq(irq, dev_id);
-	return ret;
-}
-#endif
-
-static int sdhci_req_irq(struct sdhci_host *host)
-{
-#ifdef CONFIG_PREEMPT_RT_BASE
-	return request_threaded_irq(host->irq, NULL, sdhci_rt_irq,
-				    IRQF_SHARED, mmc_hostname(host->mmc), host);
-#else
-	return request_threaded_irq(host->irq, sdhci_irq, sdhci_thread_irq,
-				    IRQF_SHARED, mmc_hostname(host->mmc), host);
-#endif
-}
-
 /*****************************************************************************\
  *                                                                           *
  * Suspend/resume                                                            *
@@ -2769,7 +2744,9 @@ int sdhci_resume_host(struct sdhci_host *host)
 	}
 
 	if (!device_may_wakeup(mmc_dev(host->mmc))) {
-		ret = sdhci_req_irq(host);
+		ret = request_threaded_irq(host->irq, sdhci_irq,
+					   sdhci_thread_irq, IRQF_SHARED,
+					   mmc_hostname(host->mmc), host);
 		if (ret)
 			return ret;
 	} else {
@@ -3429,7 +3406,8 @@ int sdhci_add_host(struct sdhci_host *host)
 
 	sdhci_init(host, 0);
 
-	ret = sdhci_req_irq(host);
+	ret = request_threaded_irq(host->irq, sdhci_irq, sdhci_thread_irq,
+				   IRQF_SHARED,	mmc_hostname(mmc), host);
 	if (ret) {
 		pr_err("%s: Failed to request IRQ %d: %d\n",
 		       mmc_hostname(mmc), host->irq, ret);
-- 
2.5.0

