do_irqd: wrap do_hardirq in irq_enter/exit for non-RT

The preempt-irqs-core.patch which is responsible for creating do_irqd
had the call to do_hardirq() wrapped with an irq_enter() and irq_exit().

Then preempt-realtime-irqs.patch made the distinction that these
wrappers could be within an #ifndef CONFIG_PREEMPT_RT (i.e. enabled
for non-RT kernels).

Then the new-softirq-code.patch was added, which tried to piggy back
the do_softirq right in after the end of the do_hardirq() as an
optimization.  But this patch didn't keep the irq_enter/exit wrappers.

Finally, disable-run-softirq-from-hardirq-completely.patch essentially
reverts the chained softirq the above patch added, but we are still
without the wrappers.

On a non-RT build, but with preemptible IRQs still enabled, you will
typically see lots of scheduling while atomic messages from things like
the Rx IRQ of NAPI style ethernet drivers (e1000, pasemi_mac, etc):

BUG: scheduling while atomic: IRQ-148/0x00010001/587, CPU#1
Call Trace:
[c00000003d74fb30] [c000000000010574] .show_stack+0x64/0x1d0 (unreliable)
[c00000003d74fbe0] [c000000000049968] .__schedule_bug+0xb8/0xc0
[c00000003d74fc80] [c000000000591178] .__schedule+0x4a8/0x860
[c00000003d74fda0] [c000000000591598] .schedule+0x68/0x130
[c00000003d74fe30] [c00000000008c4a8] .do_irqd+0x238/0x420
[c00000003d74ff00] [c00000000006dfcc] .kthread+0x7c/0xe0
[c00000003d74ff90] [c0000000000248f0] .kernel_thread+0x4c/0x68

The threaded hard interrupt handler (which typically can be
thread_simple_irq()) will invoke cond_resched_hardirq_context(), which
might sleep.  Prior to being rescheduled, cond_resched_hard_irqcontext()
calls irq_exit() to drop the hardirq preempt count.  When it resumes,
cond_resched_hardirq_context() calls __irq_enter() to bump up the
hardirq preempt count again. 

Reinstating them back to the form that was in place prior to the
application of new-softirq-code.patch solves the problem.

Signed-off-by: Hong H. Pham <hong.pham@windriver.com>
Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 kernel/irq/manage.c |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)

diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 0757ca3..59594e9 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -880,7 +880,13 @@ static int do_irqd(void * __desc)
 		local_irq_disable_nort();
 		do {
 			set_current_state(TASK_INTERRUPTIBLE);
+#ifndef CONFIG_PREEMPT_RT
+			irq_enter();
+#endif
 			do_hardirq(desc);
+#ifndef CONFIG_PREEMPT_RT
+			irq_exit();
+#endif
 		} while (current->state == TASK_RUNNING);
 
 		local_irq_enable_nort();
