From: Paul Gortmaker <paul.gortmaker@windriver.com>

hard IRQ thread: threads are incorrectly created for IRQF_NODELAY

There are two ways that start_irq_thread() can be called; either
as a part of setup_irq() for flags !IRQF_NODELAY, or as a blanket
walk over NR_IRQS for status !IRQ_NODELAY from init_hardirqs().
The printk timestamps will confirm that either may get there 1st.

The problem is that if the latter gets there 1st, the IRQF_NODELAY
may not have propagated from flags to an IRQ_NODELAY in status, and
you end up with an IRQ-0 thread for the timer IRQ, even though it
should be IRQF_NODELAY and have no IRQ-0 thread.  The threaded IRQ-0
eventually blows up when tick_periodic() does the following:

        update_process_times(user_mode(get_irq_regs()));

and this results in a trace that looks like the attached.  I've
added an explicit call to recalculate_desc_flags() before we decide
to create a thread or not, which propagates IRQF_NODELAY from flags
to an IRQ_NODELAY in status.

[    0.062407] BUG: unable to handle kernel NULL pointer dereference at 00000030
[    0.062990] IP: [<c0230385>] tick_periodic+0x63/0x79
[    0.062990] *pde = 00000000
[    0.062990] Oops: 0000 [#1] PREEMPT
[    0.062990]
[    0.062990] Pid: 3, comm: IRQ-0 Not tainted (2.6.27-rc8-26rt9 #3)
[    0.062990] EIP: 0060:[<c0230385>] EFLAGS: 00010246 CPU: 0
[    0.062990] EIP is at tick_periodic+0x63/0x79
[    0.062990] Call Trace:
[    0.062990]  [<c02303b3>] ? tick_handle_periodic+0x18/0x5d
[    0.062990]  [<c0205525>] ? timer_interrupt+0x19/0x20
[    0.062990]  [<c0238b3d>] ? handle_IRQ_event+0x45/0xb6
[    0.062990]  [<c0239386>] ? do_irqd+0x0/0x270
[    0.062990]  [<c0238f6d>] ? thread_simple_irq+0x5a/0x93

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 kernel/irq/manage.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 4d1ffd1..0757ca3 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -930,6 +930,7 @@ void __init init_hardirqs(void)
 	for (i = 0; i < NR_IRQS; i++) {
 		irq_desc_t *desc = irq_desc + i;
 
+		recalculate_desc_flags(desc);
 		if (desc->action && !(desc->status & IRQ_NODELAY))
 			start_irq_thread(i, desc);
 	}
