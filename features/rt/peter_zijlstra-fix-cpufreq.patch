Subject: cpufreq: Convert cpufreq_driver_lock to a raw_spinlock_t
From: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date: Fri Aug 05 23:03:20 CEST 2011

[    1.105624] =================================
[    1.105625] [ INFO: inconsistent lock state ]
[    1.105628] 3.0.1-rt8+ #6
[    1.105629] ---------------------------------
[    1.105631] inconsistent {HARDIRQ-ON-W} -> {IN-HARDIRQ-W} usage.
[    1.105634] swapper/0 [HC1[1]:SC0[18446744069414584320]:HE0:SE1] takes:
[    1.105636]  (cpufreq_driver_lock){?.+...}, at: [<ffffffff8142904f>] cpufreq_cpu_get+0x34/0x1da
[    1.105646] {HARDIRQ-ON-W} state was registered at:
[    1.105647]   [<ffffffff810aad51>] __lock_acquire+0x6e8/0x1812
[    1.105652]   [<ffffffff810ac4a7>] lock_acquire+0x145/0x18a
[    1.105655]   [<ffffffff814f7da4>] rt_spin_lock+0x4c/0x53
[    1.105660]   [<ffffffff8142904f>] cpufreq_cpu_get+0x34/0x1da
[    1.105663]   [<ffffffff81429f7e>] cpufreq_get_policy+0x21/0x46
[    1.105666]   [<ffffffff81011747>] kvm_timer_init+0x66/0xf3
[    1.105670]   [<ffffffff81016d9e>] kvm_arch_init+0xe4/0x11b
[    1.105673]   [<ffffffff81003d16>] kvm_init+0x24/0x2ef
[    1.105677]   [<ffffffff81a1ac38>] svm_init+0x1c/0x1e
[    1.105680]   [<ffffffff810002f2>] do_one_initcall+0x7f/0x135
[    1.105684]   [<ffffffff81a18b93>] kernel_init+0x9d/0x11d
[    1.105689]   [<ffffffff814ff7d4>] kernel_thread_helper+0x4/0x10
[    1.105694] irq event stamp: 82338
[    1.105695] hardirqs last  enabled at (82337): [<ffffffff8103ef10>] default_idle+0x1a6/0x39e
[    1.105699] hardirqs last disabled at (82338): [<ffffffff814f8a27>] save_args+0x67/0x70
[    1.105703] softirqs last  enabled at (0): [<          (null)>]           (null)
[    1.105706] softirqs last disabled at (0): [<          (null)>]           (null)
[    1.105708]
[    1.105709] other info that might help us debug this:
[    1.105710]  Possible unsafe locking scenario:
[    1.105711]
[    1.105712]        CPU0
[    1.105713]        ----
[    1.105714]   lock(cpufreq_driver_lock);
[    1.105716]   <Interrupt>
[    1.105717]     lock(cpufreq_driver_lock);
[    1.105719]
[    1.105720]  *** DEADLOCK ***
[    1.105720]
[    1.105722] no locks held by swapper/0.
[    1.105723]
[    1.105724] stack backtrace:
[    1.105726] Pid: 0, comm: swapper Not tainted 3.0.1-rt8+ #6
[    1.105728] Call Trace:
[    1.105730]  <IRQ>  [<ffffffff810aa128>] print_usage_bug+0x285/0x296
[    1.105737]  [<ffffffff81043813>] ? save_stack_trace+0x2f/0x4c
[    1.105740]  [<ffffffff810a95be>] ? print_irq_inversion_bug+0x1cd/0x1cd
[    1.105743]  [<ffffffff810aa422>] mark_lock+0x2e9/0x530
[    1.105746]  [<ffffffff810aaccb>] __lock_acquire+0x662/0x1812
[    1.105751]  [<ffffffff810a79b2>] ? trace_hardirqs_off_caller+0x1f/0x99
[    1.105757]  [<ffffffff8103dc4c>] ? native_sched_clock+0x37/0x6d
[    1.105760]  [<ffffffff810a79b2>] ? trace_hardirqs_off_caller+0x1f/0x99
[    1.105764]  [<ffffffff8142904f>] ? cpufreq_cpu_get+0x34/0x1da
[    1.105767]  [<ffffffff810ac4a7>] lock_acquire+0x145/0x18a
[    1.105770]  [<ffffffff8142904f>] ? cpufreq_cpu_get+0x34/0x1da
[    1.105774]  [<ffffffff814f7da4>] rt_spin_lock+0x4c/0x53
[    1.105777]  [<ffffffff8142904f>] ? cpufreq_cpu_get+0x34/0x1da
[    1.105781]  [<ffffffff8142904f>] cpufreq_cpu_get+0x34/0x1da
[    1.105784]  [<ffffffff8142a388>] cpufreq_quick_get+0x15/0x2d
[    1.105788]  [<ffffffff810115b1>] tsc_khz_changed+0x2f/0x47
[    1.105792]  [<ffffffff810b3244>] generic_smp_call_function_single_interrupt+0xd6/0xf9
[    1.105798]  [<ffffffff8104fa59>] smp_call_function_single_interrupt+0x27/0x36
[    1.105801]  [<ffffffff814ff533>] call_function_single_interrupt+0x13/0x20
[    1.105803]  <EOI>  [<ffffffff8103ef12>] ? default_idle+0x1a8/0x39e
[    1.105809]  [<ffffffff8103ef10>] ? default_idle+0x1a6/0x39e
[    1.105811]  [<ffffffff8103f1ed>] amd_e400_idle+0xe5/0xe7
[    1.105815]  [<ffffffff81037180>] cpu_idle+0x58/0x72
[    1.105818]  [<ffffffff814d9c58>] rest_init+0xbc/0xc3
[    1.105821]  [<ffffffff814d9b9c>] ? csum_partial_copy_generic+0x16c/0x16c
[    1.105825]  [<ffffffff81a18aeb>] start_kernel+0x35c/0x367
[    1.105829]  [<ffffffff81a182a6>] x86_64_start_reservations+0xb6/0xba
[    1.105832]  [<ffffffff81a1839c>] x86_64_start_kernel+0xf2/0xf9

the trivial conversion to raw spinlock isn't there because of the
for_each_cpu() loops done while holding the lock.

Pull the spinlock in the for_each_cpu() loops and assume the policy
rwsem will serialize enough and add a possibly redundant
get_online_cpu()s around the thing to stabilize the cpumasks
(otherwise accomplished by disabling preemption).

Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
---
 drivers/cpufreq/cpufreq.c |   56 +++++++++++++++++++++++++---------------------
 1 file changed, 31 insertions(+), 25 deletions(-)

Index: linux-2.6/drivers/cpufreq/cpufreq.c
===================================================================
--- linux-2.6.orig/drivers/cpufreq/cpufreq.c
+++ linux-2.6/drivers/cpufreq/cpufreq.c
@@ -43,7 +43,7 @@ static DEFINE_PER_CPU(struct cpufreq_pol
 /* This one keeps track of the previously set governor of a removed CPU */
 static DEFINE_PER_CPU(char[CPUFREQ_NAME_LEN], cpufreq_cpu_governor);
 #endif
-static DEFINE_SPINLOCK(cpufreq_driver_lock);
+static DEFINE_RAW_SPINLOCK(cpufreq_driver_lock);
 
 /*
  * cpu_policy_rwsem is a per CPU reader-writer semaphore designed to cure
@@ -138,7 +138,7 @@ struct cpufreq_policy *cpufreq_cpu_get(u
 		goto err_out;
 
 	/* get the cpufreq driver */
-	spin_lock_irqsave(&cpufreq_driver_lock, flags);
+	raw_spin_lock_irqsave(&cpufreq_driver_lock, flags);
 
 	if (!cpufreq_driver)
 		goto err_out_unlock;
@@ -156,13 +156,13 @@ struct cpufreq_policy *cpufreq_cpu_get(u
 	if (!kobject_get(&data->kobj))
 		goto err_out_put_module;
 
-	spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+	raw_spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
 	return data;
 
 err_out_put_module:
 	module_put(cpufreq_driver->owner);
 err_out_unlock:
-	spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+	raw_spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
 err_out:
 	return NULL;
 }
@@ -722,10 +722,10 @@ static int cpufreq_add_dev_policy(unsign
 				return -EBUSY;
 			}
 
-			spin_lock_irqsave(&cpufreq_driver_lock, flags);
+			raw_spin_lock_irqsave(&cpufreq_driver_lock, flags);
 			cpumask_copy(managed_policy->cpus, policy->cpus);
 			per_cpu(cpufreq_cpu_data, cpu) = managed_policy;
-			spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+			raw_spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
 
 			pr_debug("CPU already managed, adding link\n");
 			ret = sysfs_create_link(&sys_dev->kobj,
@@ -821,14 +821,16 @@ static int cpufreq_add_dev_interface(uns
 			goto err_out_kobj_put;
 	}
 
-	spin_lock_irqsave(&cpufreq_driver_lock, flags);
+	get_online_cpus();
 	for_each_cpu(j, policy->cpus) {
 		if (!cpu_online(j))
 			continue;
+		raw_spin_lock_irqsave(&cpufreq_driver_lock, flags);
 		per_cpu(cpufreq_cpu_data, j) = policy;
 		per_cpu(cpufreq_policy_cpu, j) = policy->cpu;
+		raw_spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
 	}
-	spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+	put_online_cpus();
 
 	ret = cpufreq_add_dev_symlink(cpu, policy);
 	if (ret)
@@ -970,10 +972,13 @@ static int cpufreq_add_dev(struct sys_de
 
 
 err_out_unregister:
-	spin_lock_irqsave(&cpufreq_driver_lock, flags);
-	for_each_cpu(j, policy->cpus)
+	get_online_cpus();
+	for_each_cpu(j, policy->cpus) {
+		raw_spin_lock_irqsave(&cpufreq_driver_lock, flags);
 		per_cpu(cpufreq_cpu_data, j) = NULL;
-	spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+		raw_spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+	}
+	put_online_cpus();
 
 	kobject_put(&policy->kobj);
 	wait_for_completion(&policy->kobj_unregister);
@@ -1013,11 +1018,11 @@ static int __cpufreq_remove_dev(struct s
 
 	pr_debug("unregistering CPU %u\n", cpu);
 
-	spin_lock_irqsave(&cpufreq_driver_lock, flags);
+	raw_spin_lock_irqsave(&cpufreq_driver_lock, flags);
 	data = per_cpu(cpufreq_cpu_data, cpu);
 
 	if (!data) {
-		spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+		raw_spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
 		unlock_policy_rwsem_write(cpu);
 		return -EINVAL;
 	}
@@ -1031,7 +1036,7 @@ static int __cpufreq_remove_dev(struct s
 	if (unlikely(cpu != data->cpu)) {
 		pr_debug("removing link\n");
 		cpumask_clear_cpu(cpu, data->cpus);
-		spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+		raw_spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
 		kobj = &sys_dev->kobj;
 		cpufreq_cpu_put(data);
 		unlock_policy_rwsem_write(cpu);
@@ -1040,6 +1045,7 @@ static int __cpufreq_remove_dev(struct s
 	}
 #endif
 
+	raw_spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
 #ifdef CONFIG_SMP
 
 #ifdef CONFIG_HOTPLUG_CPU
@@ -1052,15 +1058,17 @@ static int __cpufreq_remove_dev(struct s
 	 * per_cpu(cpufreq_cpu_data) while holding the lock, and remove
 	 * the sysfs links afterwards.
 	 */
+	get_online_cpus();
 	if (unlikely(cpumask_weight(data->cpus) > 1)) {
 		for_each_cpu(j, data->cpus) {
 			if (j == cpu)
 				continue;
+			raw_spin_lock_irqsave(&cpufreq_driver_lock, flags);
 			per_cpu(cpufreq_cpu_data, j) = NULL;
+			raw_spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
 		}
 	}
-
-	spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+	put_online_cpus();
 
 	if (unlikely(cpumask_weight(data->cpus) > 1)) {
 		for_each_cpu(j, data->cpus) {
@@ -1079,8 +1087,6 @@ static int __cpufreq_remove_dev(struct s
 			cpufreq_cpu_put(data);
 		}
 	}
-#else
-	spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
 #endif
 
 	if (cpufreq_driver->target)
@@ -1802,13 +1808,13 @@ int cpufreq_register_driver(struct cpufr
 	if (driver_data->setpolicy)
 		driver_data->flags |= CPUFREQ_CONST_LOOPS;
 
-	spin_lock_irqsave(&cpufreq_driver_lock, flags);
+	raw_spin_lock_irqsave(&cpufreq_driver_lock, flags);
 	if (cpufreq_driver) {
-		spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+		raw_spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
 		return -EBUSY;
 	}
 	cpufreq_driver = driver_data;
-	spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+	raw_spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
 
 	ret = sysdev_driver_register(&cpu_sysdev_class,
 					&cpufreq_sysdev_driver);
@@ -1842,9 +1848,9 @@ int cpufreq_register_driver(struct cpufr
 	sysdev_driver_unregister(&cpu_sysdev_class,
 			&cpufreq_sysdev_driver);
 err_null_driver:
-	spin_lock_irqsave(&cpufreq_driver_lock, flags);
+	raw_spin_lock_irqsave(&cpufreq_driver_lock, flags);
 	cpufreq_driver = NULL;
-	spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+	raw_spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(cpufreq_register_driver);
@@ -1870,9 +1876,9 @@ int cpufreq_unregister_driver(struct cpu
 	sysdev_driver_unregister(&cpu_sysdev_class, &cpufreq_sysdev_driver);
 	unregister_hotcpu_notifier(&cpufreq_cpu_notifier);
 
-	spin_lock_irqsave(&cpufreq_driver_lock, flags);
+	raw_spin_lock_irqsave(&cpufreq_driver_lock, flags);
 	cpufreq_driver = NULL;
-	spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+	raw_spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
 
 	return 0;
 }
