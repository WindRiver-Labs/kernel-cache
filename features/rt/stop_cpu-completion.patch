From: Paul Gortmaker <paul.gortmaker@windriver.com>
Subject: stop_cpu: dont run a completion with irqs disabled
    
Currently, stop_cpu() calls ack_state(), which when all is done
(i.e. state == STOPMACHINE_EXIT), launches the completion to tie
up loose ends.  However, we are still running with irqs disabled
from what stop_cpu() set up earlier, and so we get this:

BUG: sleeping function called from invalid context kstop1(2205) at
linux/kernel/rtmutex.c:743
in_atomic():0 [00000000], irqs_disabled():1
Pid: 2205, comm: kstop1 Not tainted 2.6.27.18-rt #1
Call Trace:
[<ffffffff805910c9>] __rt_spin_lock+0x79/0x80
[<ffffffff80230e10>] complete+0x20/0x50
[<ffffffff802720a4>] stop_cpu+0x94/0xf0
    
Since we know we are out the bottom already and in final EXIT
stage, we can enable irqs around the completion.
    
Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

---

diff --git a/kernel/stop_machine.c b/kernel/stop_machine.c
index 87d498c..2d53cc4 100644
--- a/kernel/stop_machine.c
+++ b/kernel/stop_machine.c
@@ -53,9 +53,12 @@ static void ack_state(void)
 {
 	if (atomic_dec_and_test(&thread_ack)) {
 		/* If we're the last one to ack the EXIT, we're finished. */
-		if (state == STOPMACHINE_EXIT)
+		if (state == STOPMACHINE_EXIT) {
+			local_irq_enable();	/* off from stop_cpu */
 			complete(&finished);
-		else
+			local_irq_disable();
+			
+		} else
 			set_state(state + 1);
 	}
 }
