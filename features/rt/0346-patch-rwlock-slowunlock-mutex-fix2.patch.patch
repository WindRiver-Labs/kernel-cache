From 26a5346d3e82fcebba3816f8423fca3d5fec9421 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Fri, 5 Sep 2008 00:23:58 -0400
Subject: [PATCH] patch rwlock-slowunlock-mutex-fix2.patch

---
 kernel/rtmutex.c |   13 +++++++++++++
 1 files changed, 13 insertions(+), 0 deletions(-)

diff --git a/kernel/rtmutex.c b/kernel/rtmutex.c
index 50b0850..b485438 100644
--- a/kernel/rtmutex.c
+++ b/kernel/rtmutex.c
@@ -1684,6 +1684,7 @@ rt_read_slowunlock(struct rw_mutex *rwm, int mtx)
 {
 	struct rt_mutex *mutex = &rwm->mutex;
 	struct rt_mutex_waiter *waiter;
+	struct task_struct *pendowner;
 	struct reader_lock_struct *rls;
 	unsigned long flags;
 	unsigned int reader_count;
@@ -1792,6 +1793,7 @@ rt_read_slowunlock(struct rw_mutex *rwm, int mtx)
 			rwm->owner = RT_RW_PENDING_READ;
 	}
 
+	pendowner = waiter->task;
 	wakeup_next_waiter(mutex, savestate);
 
 	/*
@@ -1807,6 +1809,17 @@ rt_read_slowunlock(struct rw_mutex *rwm, int mtx)
 	if (rt_mutex_has_waiters(mutex)) {
 		waiter = rt_mutex_top_waiter(mutex);
 		rwm->prio = waiter->task->prio;
+		/*
+		 * If readers still own this lock, then we need
+		 * to update the pi_list too. Readers have a separate
+		 * path in the PI chain.
+		 */
+		if (reader_count) {
+			spin_lock(&pendowner->pi_lock);
+			plist_del(&waiter->pi_list_entry,
+				  &pendowner->pi_waiters);
+			spin_unlock(&pendowner->pi_lock);
+		}
 	} else
 		rwm->prio = MAX_PRIO;
 
-- 
1.6.0.90.g436ed

