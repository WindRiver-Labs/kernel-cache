From 0b4ae2fffa325a9b863e038072ab73181b2921a6 Mon Sep 17 00:00:00 2001
From: Steven Rostedt <srostedt@redhat.com>
Date: Fri, 5 Sep 2008 00:23:54 -0400
Subject: [PATCH] Subject: rwlock: fix non PREEMPT_RT case
 Seems that the addition of RT_RW_READER broke the non PREEMPT_RT case.
 This patch fixes it.

Signed-off-by: Steven Rostedt <srostedt@redhat.com>
---
 kernel/rtmutex.c |   16 +++++++++++-----
 1 files changed, 11 insertions(+), 5 deletions(-)

diff --git a/kernel/rtmutex.c b/kernel/rtmutex.c
index d3984c9..5ed4a93 100644
--- a/kernel/rtmutex.c
+++ b/kernel/rtmutex.c
@@ -124,6 +124,12 @@ static inline void mark_rt_rwlock_check(struct rw_mutex *rwm)
 #endif /* CONFIG_PREEMPT_RT */
 #endif
 
+#ifdef CONFIG_PREEMPT_RT
+#define task_is_reader(task) ((task) == RT_RW_READER)
+#else
+#define task_is_reader(task) (0)
+#endif
+
 int pi_initialized;
 
 /*
@@ -316,7 +322,7 @@ static int rt_mutex_adjust_prio_chain(struct task_struct *task,
 	/*
 	 * Readers are special. We may need to boost more than one owner.
 	 */
-	if (task == RT_RW_READER) {
+	if (task_is_reader(task)) {
 		ret = rt_mutex_adjust_readers(orig_lock, orig_waiter,
 					      top_task, lock,
 					      recursion_depth);
@@ -377,7 +383,7 @@ static inline int try_to_steal_lock(struct rt_mutex *lock, int mode)
 	if (pendowner == current)
 		return 1;
 
-	WARN_ON(rt_mutex_owner(lock) == RT_RW_READER);
+	WARN_ON(task_is_reader(rt_mutex_owner(lock)));
 
 	spin_lock(&pendowner->pi_lock);
 	if (!lock_is_stealable(pendowner, mode)) {
@@ -507,7 +513,7 @@ static int task_blocks_on_rt_mutex(struct rt_mutex *lock,
 
 	if (waiter == rt_mutex_top_waiter(lock)) {
 		/* readers are handled differently */
-		if (owner == RT_RW_READER) {
+		if (task_is_reader(owner)) {
 			res = rt_mutex_adjust_readers(lock, waiter,
 						      current, lock, 0);
 			return res;
@@ -525,7 +531,7 @@ static int task_blocks_on_rt_mutex(struct rt_mutex *lock,
 	else if (debug_rt_mutex_detect_deadlock(waiter, detect_deadlock))
 		chain_walk = 1;
 
-	if (!chain_walk || owner == RT_RW_READER)
+	if (!chain_walk || task_is_reader(owner))
 		return 0;
 
 	/*
@@ -625,7 +631,7 @@ static void remove_waiter(struct rt_mutex *lock,
 	current->pi_blocked_on = NULL;
 	spin_unlock(&current->pi_lock);
 
-	if (first && owner != current && owner != RT_RW_READER) {
+	if (first && owner != current && !task_is_reader(owner)) {
 
 		spin_lock(&owner->pi_lock);
 
-- 
1.6.0.90.g436ed

