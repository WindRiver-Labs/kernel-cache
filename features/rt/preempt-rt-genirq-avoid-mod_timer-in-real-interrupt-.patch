From d2bb6cb274f4b1b1952d17b224d1caf921e4e4ca Mon Sep 17 00:00:00 2001
From: Zhang Xiao <xiao.zhang@windriver.com>
Date: Mon, 21 Nov 2016 17:21:40 +0800
Subject: [PATCH] preempt-rt: genirq: avoid mod_timer in real interrupt
 context

For no one handled interrupt, once there are too many of them, kernel
will judge it as a spurious irq. For spurious irq, kernel disable
it in chip level and start a timer with "mod_timer" to poll the
spurious irq every POLL_SPURIOUS_IRQ_INTERVAL jiffies. All these
above works in real interrupt context. There is a spin_lock operation
in mod_timer, it works for common cases but in preempt-rt kernel the
spin_lock is sleep-able. And this will cause an error: BUG: sleeping
function called from invalid context.

Add a kernel thread and let it do the real job(mod_timer) to avoid
this issue.

Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 kernel/irq/spurious.c |   45 ++++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 44 insertions(+), 1 deletions(-)

diff --git a/kernel/irq/spurious.c b/kernel/irq/spurious.c
index 1648232..2b31f18 100644
--- a/kernel/irq/spurious.c
+++ b/kernel/irq/spurious.c
@@ -267,6 +267,42 @@ try_misrouted_irq(unsigned int irq, struct irq_desc *desc,
 
 #define SPURIOUS_DEFERRED	0x80000000
 
+#ifdef CONFIG_PREEMPT_RT_FULL
+/*
+ * RT can not call mod_timer in real interrupt context.
+ * Create a thread to do the real work.
+ */
+#include <linux/kthread.h>
+
+static struct task_struct *mod_timer_thread = NULL;
+static bool do_mod_timer = false;
+
+static int modtimer_thread(void)
+{
+	while (!kthread_should_stop()) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (do_mod_timer) {
+			do_mod_timer = false;
+			mod_timer(&poll_spurious_irq_timer,
+				  jiffies + POLL_SPURIOUS_IRQ_INTERVAL);
+		}
+		schedule();
+	}
+	__set_current_state(TASK_RUNNING);
+	return 0;
+}
+
+static __init int create_mod_timer_thread(void)
+{
+	mod_timer_thread = kthread_run(modtimer_thread, NULL,
+				       "modtimer_thread");
+	BUG_ON(!mod_timer_thread);
+	return 0;
+}
+
+early_initcall(create_mod_timer_thread);
+#endif /* CONFIG_PREEMPT_RT_FULL */
+
 void note_interrupt(unsigned int irq, struct irq_desc *desc,
 		    irqreturn_t action_ret)
 {
@@ -415,9 +451,16 @@ void note_interrupt(unsigned int irq, struct irq_desc *desc,
 		desc->istate |= IRQS_SPURIOUS_DISABLED;
 		desc->depth++;
 		irq_disable(desc);
-
+#ifdef CONFIG_PREEMPT_RT_FULL
+		/* Let kernel thread mod_timer in RT_FULL. */
+		do_mod_timer = true;
+		smp_wmb();
+		if(mod_timer_thread)
+			wake_up_process(mod_timer_thread);
+#else
 		mod_timer(&poll_spurious_irq_timer,
 			  jiffies + POLL_SPURIOUS_IRQ_INTERVAL);
+#endif /* CONFIG_PREEMPT_RT_FULL */
 	}
 	desc->irqs_unhandled = 0;
 }
-- 
1.7.5.4

