From: Thomas Gleixner <tglx@linutronix.de>
Date: Sat, 20 Jun 2009 11:36:54 +0200
Subject: drivers/net: fix livelock issues

Preempt-RT runs into a live lock issue with the NETDEV_TX_LOCKED micro
optimization. The reason is that the softirq thread is rescheduling
itself on that return value. Depending on priorities it starts to
monoplize the CPU and livelock on UP systems.

Remove it.

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

---
 drivers/net/atl1c/atl1c_main.c |    7 ++-----
 drivers/net/atl1e/atl1e_main.c |    3 +--
 drivers/net/chelsio/sge.c      |    3 +--
 drivers/net/rionet.c           |    6 +-----
 drivers/net/s2io.c             |    7 +------
 drivers/net/sungem.c           |    6 ++----
 drivers/net/tehuti.c           |    9 ++-------
 7 files changed, 10 insertions(+), 31 deletions(-)

Index: linux-2.6-tip/drivers/net/atl1c/atl1c_main.c
===================================================================
--- linux-2.6-tip.orig/drivers/net/atl1c/atl1c_main.c
+++ linux-2.6-tip/drivers/net/atl1c/atl1c_main.c
@@ -2218,11 +2218,8 @@ static netdev_tx_t atl1c_xmit_frame(stru
 	}
 
 	tpd_req = atl1c_cal_tpd_req(skb);
-	if (!spin_trylock_irqsave(&adapter->tx_lock, flags)) {
-		if (netif_msg_pktdata(adapter))
-			dev_info(&adapter->pdev->dev, "tx locked\n");
-		return NETDEV_TX_LOCKED;
-	}
+	spin_lock_irqsave(&adapter->tx_lock, flags);
+
 	if (skb->mark == 0x01)
 		type = atl1c_trans_high;
 	else
Index: linux-2.6-tip/drivers/net/atl1e/atl1e_main.c
===================================================================
--- linux-2.6-tip.orig/drivers/net/atl1e/atl1e_main.c
+++ linux-2.6-tip/drivers/net/atl1e/atl1e_main.c
@@ -1800,8 +1800,7 @@ static netdev_tx_t atl1e_xmit_frame(stru
 		return NETDEV_TX_OK;
 	}
 	tpd_req = atl1e_cal_tdp_req(skb);
-	if (!spin_trylock_irqsave(&adapter->tx_lock, flags))
-		return NETDEV_TX_LOCKED;
+	spin_lock_irqsave(&adapter->tx_lock, flags);
 
 	if (atl1e_tpd_avail(adapter) < tpd_req) {
 		/* no enough descriptor, just stop queue */
Index: linux-2.6-tip/drivers/net/chelsio/sge.c
===================================================================
--- linux-2.6-tip.orig/drivers/net/chelsio/sge.c
+++ linux-2.6-tip/drivers/net/chelsio/sge.c
@@ -1679,8 +1679,7 @@ static int t1_sge_tx(struct sk_buff *skb
 	struct cmdQ *q = &sge->cmdQ[qid];
 	unsigned int credits, pidx, genbit, count, use_sched_skb = 0;
 
-	if (!spin_trylock(&q->lock))
-		return NETDEV_TX_LOCKED;
+	spin_lock(&q->lock);
 
 	reclaim_completed_tx(sge, q);
 
Index: linux-2.6-tip/drivers/net/rionet.c
===================================================================
--- linux-2.6-tip.orig/drivers/net/rionet.c
+++ linux-2.6-tip/drivers/net/rionet.c
@@ -176,11 +176,7 @@ static int rionet_start_xmit(struct sk_b
 	u16 destid;
 	unsigned long flags;
 
-	local_irq_save(flags);
-	if (!spin_trylock(&rnet->tx_lock)) {
-		local_irq_restore(flags);
-		return NETDEV_TX_LOCKED;
-	}
+	spin_lock_irqsave(&rnet->tx_lock, flags);
 
 	if ((rnet->tx_cnt + 1) > RIONET_TX_RING_SIZE) {
 		netif_stop_queue(ndev);
Index: linux-2.6-tip/drivers/net/s2io.c
===================================================================
--- linux-2.6-tip.orig/drivers/net/s2io.c
+++ linux-2.6-tip/drivers/net/s2io.c
@@ -4142,12 +4142,7 @@ static netdev_tx_t s2io_xmit(struct sk_b
 			[skb->priority & (MAX_TX_FIFOS - 1)];
 	fifo = &mac_control->fifos[queue];
 
-	if (do_spin_lock)
-		spin_lock_irqsave(&fifo->tx_lock, flags);
-	else {
-		if (unlikely(!spin_trylock_irqsave(&fifo->tx_lock, flags)))
-			return NETDEV_TX_LOCKED;
-	}
+	spin_lock_irqsave(&fifo->tx_lock, flags);
 
 	if (sp->config.multiq) {
 		if (__netif_subqueue_stopped(dev, fifo->fifo_no)) {
Index: linux-2.6-tip/drivers/net/sungem.c
===================================================================
--- linux-2.6-tip.orig/drivers/net/sungem.c
+++ linux-2.6-tip/drivers/net/sungem.c
@@ -1013,10 +1013,8 @@ static netdev_tx_t gem_start_xmit(struct
 			(csum_stuff_off << 21));
 	}
 
-	if (!spin_trylock_irqsave(&gp->tx_lock, flags)) {
-		/* Tell upper layer to requeue */
-		return NETDEV_TX_LOCKED;
-	}
+	spin_lock_irqsave(&gp->tx_lock, flags);
+
 	/* We raced with gem_do_stop() */
 	if (!gp->running) {
 		spin_unlock_irqrestore(&gp->tx_lock, flags);
Index: linux-2.6-tip/drivers/net/tehuti.c
===================================================================
--- linux-2.6-tip.orig/drivers/net/tehuti.c
+++ linux-2.6-tip/drivers/net/tehuti.c
@@ -1627,13 +1627,8 @@ static netdev_tx_t bdx_tx_transmit(struc
 	unsigned long flags;
 
 	ENTER;
-	local_irq_save(flags);
-	if (!spin_trylock(&priv->tx_lock)) {
-		local_irq_restore(flags);
-		DBG("%s[%s]: TX locked, returning NETDEV_TX_LOCKED\n",
-		    BDX_DRV_NAME, ndev->name);
-		return NETDEV_TX_LOCKED;
-	}
+
+	spin_lock_irqsave(&priv->tx_lock, flags);
 
 	/* build tx descriptor */
 	BDX_ASSERT(f->m.wptr >= f->m.memsz);	/* started with valid wptr */
