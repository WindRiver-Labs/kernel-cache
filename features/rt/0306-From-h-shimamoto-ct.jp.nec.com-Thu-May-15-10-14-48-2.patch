From 419acfb3ae2cdac0e9b2a5c434bb10e696fcc57c Mon Sep 17 00:00:00 2001
From: Hiroshi Shimamoto <h-shimamoto@ct.jp.nec.com>
Date: Tue, 30 Sep 2008 17:01:30 -0400
Subject: [PATCH] From h-shimamoto@ct.jp.nec.com Thu May 15 10:14:48 2008
 Date: Mon, 28 Apr 2008 11:16:31 -0700
 To: Ingo Molnar <mingo@elte.hu>, Steven Rostedt <rostedt@goodmis.org>,
      Thomas Gleixner <tglx@linutronix.de>
 Cc: linux-kernel@vger.kernel.org, linux-rt-users@vger.kernel.org
 Subject: [PATCH -rt 2/4] x86: return true for NMI handled
 NMI for show_regs causes unknown NMI when nmi_watchdog is local APIC mode.
 Because lapic_wd_event() will fail due to still running perfctr.
 If NMI is for show_regs, nmi_watchdog_tick() should return 1.

On x86_32, call irq_show_regs_callback() is moved to top of the
nmi_watchdog_tick() same as x86_64.

Signed-off-by: Hiroshi Shimamoto <h-shimamoto@ct.jp.nec.com>
---
 arch/x86/kernel/nmi.c |    9 +++++----
 include/linux/sched.h |    2 +-
 2 files changed, 6 insertions(+), 5 deletions(-)

diff --git a/arch/x86/kernel/nmi.c b/arch/x86/kernel/nmi.c
index 56999a8..4b88c88 100644
--- a/arch/x86/kernel/nmi.c
+++ b/arch/x86/kernel/nmi.c
@@ -409,10 +409,10 @@ void nmi_show_all_regs(void)
 
 static DEFINE_RAW_SPINLOCK(nmi_print_lock);
 
-notrace void irq_show_regs_callback(int cpu, struct pt_regs *regs)
+notrace int irq_show_regs_callback(int cpu, struct pt_regs *regs)
 {
 	if (!nmi_show_regs[cpu])
-		return;
+		return 0;
 
 	nmi_show_regs[cpu] = 0;
 	spin_lock(&nmi_print_lock);
@@ -421,6 +421,7 @@ notrace void irq_show_regs_callback(int cpu, struct pt_regs *regs)
 		per_cpu(irq_stat, cpu).apic_timer_irqs);
 	show_regs(regs);
 	spin_unlock(&nmi_print_lock);
+	return 1;
 }
 
 notrace __kprobes int
@@ -434,8 +435,9 @@ nmi_watchdog_tick(struct pt_regs *regs, unsigned reason)
 	unsigned int sum;
 	int touched = 0;
 	int cpu = smp_processor_id();
-	int rc = 0;
+	int rc;
 
+	rc = irq_show_regs_callback(cpu, regs);
 	irq_show_regs_callback(cpu, regs);
 	 __profile_tick(CPU_PROFILING, regs);
 
@@ -467,7 +469,6 @@ nmi_watchdog_tick(struct pt_regs *regs, unsigned reason)
 	if (mce_in_progress())
 		touched = 1;
 
-	irq_show_regs_callback(cpu, regs);
 	/* if the apic timer isn't firing, this cpu isn't doing much */
 	/* if the none of the timers isn't firing, this cpu isn't doing much */
 	if (!touched && __get_cpu_var(last_irq_sum) == sum) {
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 5df06b8..e997f30 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -320,7 +320,7 @@ static inline void show_state(void)
 }
 
 extern void show_regs(struct pt_regs *);
-extern void irq_show_regs_callback(int cpu, struct pt_regs *regs);
+extern int irq_show_regs_callback(int cpu, struct pt_regs *regs);
 
 /*
  * TASK is a pointer to the task whose backtrace we want to see (or NULL for current
-- 
1.6.0.90.g436ed

