Subject: fix-tracer-wreckage-wtf-is-this-code-all-features.patch
From: Thomas Gleixner <tglx@linutronix.de>
Date: Thu, 19 Jun 2008 19:24:14 +0200

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
---
 arch/x86/kernel/traps_32.c |    2 ++
 arch/x86/kernel/traps_64.c |    3 +++
 include/linux/ftrace.h     |   15 +++++++++++----
 kernel/trace/ftrace.c      |   17 +++++++++++++++++
 kernel/trace/trace.c       |   31 +++++++++++++++++++++++++++++++
 5 files changed, 64 insertions(+), 4 deletions(-)

diff --git a/arch/x86/kernel/traps_32.c b/arch/x86/kernel/traps_32.c
index c3c0ead..3104c21 100644
--- a/arch/x86/kernel/traps_32.c
+++ b/arch/x86/kernel/traps_32.c
@@ -419,6 +419,8 @@ int __kprobes __die(const char *str, struct pt_regs *regs, long err)
 	unsigned short ss;
 	unsigned long sp;
 
+	ftrace_stop();
+
 	printk(KERN_EMERG "%s: %04lx [#%d] ", str, err & 0xffff, ++die_counter);
 #ifdef CONFIG_PREEMPT
 	printk("PREEMPT ");
diff --git a/arch/x86/kernel/traps_64.c b/arch/x86/kernel/traps_64.c
index 55d065a..15ac6f4 100644
--- a/arch/x86/kernel/traps_64.c
+++ b/arch/x86/kernel/traps_64.c
@@ -528,6 +528,9 @@ void __kprobes oops_end(unsigned long flags, struct pt_regs *regs, int signr)
 
 int __kprobes __die(const char *str, struct pt_regs *regs, long err)
 {
+
+	ftrace_stop();
+
 	printk(KERN_EMERG "%s: %04lx [%u] ", str, err & 0xffff, ++die_counter);
 #ifdef CONFIG_PREEMPT
 	printk("PREEMPT ");
diff --git a/include/linux/ftrace.h b/include/linux/ftrace.h
index 1e3f3bc..3e4542a 100644
--- a/include/linux/ftrace.h
+++ b/include/linux/ftrace.h
@@ -37,10 +37,19 @@ extern void ftrace_stub(unsigned long a0, unsigned long a1);
 void ftrace_enable(void);
 void ftrace_disable(void);
 
+/* totally disable ftrace - can not re-enable after this */
+void ftrace_kill(void);
+void __ftrace_kill(void);
+void ftrace_kill_atomic(void);
+
+
 #else /* !CONFIG_FTRACE */
 # define register_ftrace_function(ops) do { } while (0)
 # define unregister_ftrace_function(ops) do { } while (0)
 # define clear_ftrace_function(ops) do { } while (0)
+# define ftrace_kill()				do { } while (0)
+# define __ftrace_kill()			do { } while (0)
+# define ftrace_kill_atomic()			do { } while (0)
 #endif /* CONFIG_FTRACE */
 
 #ifdef CONFIG_DYNAMIC_FTRACE
@@ -92,10 +101,6 @@ void ftrace_enable_daemon(void);
 # define ftrace_enable_daemon()			do { } while (0)
 #endif /* CONFIG_DYNAMIC_FTRACE */
 
-/* totally disable ftrace - can not re-enable after this */
-void ftrace_kill(void);
-void ftrace_kill_atomic(void);
-
 static inline void tracer_disable(void)
 {
 #ifdef CONFIG_FTRACE
@@ -162,9 +167,11 @@ static inline void __ftrace_enabled_restore(int enabled)
 #ifdef CONFIG_TRACING
 extern void
 ftrace_special(unsigned long arg1, unsigned long arg2, unsigned long arg3);
+void ftrace_stop(void);
 #else
 static inline void
 ftrace_special(unsigned long arg1, unsigned long arg2, unsigned long arg3) { }
+static inline void ftrace_stop(void) { }
 #endif
 
 struct hrtimer;
diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
index ca434c0..fe7a0d6 100644
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@ -1692,6 +1692,23 @@ void ftrace_kill(void)
 }
 
 /**
+ * __ftrace_kill - shutdown ftrace in a mean fashion
+ *
+ * In case of system failure we want to stop ftrace as soon as
+ * possible. This is like ftrace_kill but does not grab the
+ * mutexes nor does it call the kstop machine.
+ *
+ * This one is save to use in atomic.
+ */
+void __ftrace_kill(void)
+{
+	ftrace_disabled = 1;
+	ftrace_enabled = 0;
+
+	clear_ftrace_function();
+}
+
+/**
  * register_ftrace_function - register a function for profiling
  * @ops - ops structure that holds the function for profiling.
  *
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index d9ae938..2b0bd30 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -3302,6 +3302,37 @@ static __init void tracer_init_debugfs(void)
 #endif
 }
 
+/**
+ * ftrace_stop - called when we need to drastically disable the tracer.
+ */
+void ftrace_stop(void)
+{
+	struct tracer *saved_tracer = current_trace;
+	struct trace_array *tr = &global_trace;
+	struct trace_array_cpu *data;
+	int i;
+
+	__ftrace_kill();
+	for_each_tracing_cpu(i) {
+		data = tr->data[i];
+		atomic_inc(&data->disabled);
+	}
+	tracer_enabled = 0;
+
+	/*
+	 * TODO: make a safe method to ctrl_update.
+	 *  ctrl_update may schedule, but currently only
+	 *  does when ftrace is enabled.
+	 */
+	if (tr->ctrl) {
+		tr->ctrl = 0;
+		if (saved_tracer && saved_tracer->ctrl_update)
+			saved_tracer->ctrl_update(tr);
+	}
+
+
+}
+
 static int trace_alloc_page(void)
 {
 	struct trace_array_cpu *data;
