From 3d0b3210fd1d998888f205ecc298b67940e1bde4 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Sat, 1 Jan 2011 22:40:03 -0500
Subject: [PATCH] sched: TASK_WAKING state is not exclusive

The commit for:
  "sched: move_task_off_dead_cpu(): Take rq->lock around select_fallback_rq()"

in RT on 2.6.33 had an "almost" cherry pick of upstream commit
1445c08d06c5594895b4fae952ef8a457e89c390, contained in commit
ae35e6fffd929f71b6ea1193862d50b56b636a1b on tip.  The difference
in these two almost identical commits is just the same issue
seen previously with respect to testing for equality on the
TASK_WAKING being not valid in RT.

With 2.6.34.x incorporating the upstream version, and hence the
RT queue dropping the tip version of this commit, we have to
restore the delta between the two, so that RT checks for the
set bit and not complete equality.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 kernel/sched.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/kernel/sched.c b/kernel/sched.c
index 1c4b0cc..f6d9829 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -5877,7 +5877,7 @@ void move_task_off_dead_cpu(int dead_cpu, struct task_struct *p)
 	local_irq_save(flags);
 
 	raw_spin_lock(&rq->lock);
-	needs_cpu = (task_cpu(p) == dead_cpu) && (p->state != TASK_WAKING);
+	needs_cpu = (task_cpu(p) == dead_cpu) && !(p->state & TASK_WAKING);
 	if (needs_cpu)
 		dest_cpu = select_fallback_rq(dead_cpu, p);
 	raw_spin_unlock(&rq->lock);
-- 
1.7.0.4

