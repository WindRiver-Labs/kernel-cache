From: Paul Gortmaker <paul.gortmaker@windriver.com>
Subject: lockdep: mutex_lock_nest_lock()

This is a direct parallel of Peter Zijlstra's commit b7d39aff
that introduced spin_lock_nest_lock() -- just the rt mutex
version.  Of course we also have to do the underscore dance on
the existing one to get it to dynamically map to the appropriate
rt or non-rt version.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

---
 include/linux/lockdep.h          |    2 ++
 include/linux/mutex.h            |    2 ++
 include/linux/spinlock.h         |   13 +++++++------
 include/linux/spinlock_api_smp.h |    2 +-
 kernel/rt.c                      |    9 +++++++++
 kernel/spinlock.c                |    8 ++++----
 6 files changed, 25 insertions(+), 11 deletions(-)

diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h
index e206031..ac7a757 100644
--- a/include/linux/lockdep.h
+++ b/include/linux/lockdep.h
@@ -485,8 +485,10 @@ static inline void print_irqtrace_events(struct task_struct *curr)
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 # ifdef CONFIG_PROVE_LOCKING
 #  define mutex_acquire(l, s, t, i)		lock_acquire(l, s, t, 0, 2, NULL, i)
+#  define mutex_acquire_nest(l, s, t, n, i)	lock_acquire(l, s, t, 0, 2, n, i)
 # else
 #  define mutex_acquire(l, s, t, i)		lock_acquire(l, s, t, 0, 1, NULL, i)
+#  define mutex_acquire_nest(l, s, t, n, i)	lock_acquire(l, s, t, 0, 1, NULL, i)
 # endif
 # define mutex_release(l, n, i)			lock_release(l, n, i)
 #else
diff --git a/include/linux/mutex.h b/include/linux/mutex.h
index 04d7212..3255797 100644
--- a/include/linux/mutex.h
+++ b/include/linux/mutex.h
@@ -53,6 +53,8 @@ extern void __lockfunc _mutex_lock(struct mutex *lock);
 extern int __lockfunc _mutex_lock_interruptible(struct mutex *lock);
 extern int __lockfunc _mutex_lock_killable(struct mutex *lock);
 extern void __lockfunc _mutex_lock_nested(struct mutex *lock, int subclass);
+extern void __lockfunc _mutex_lock_nest_lock(struct mutex *lock,
+					struct lockdep_map *nest_lock);
 extern int __lockfunc _mutex_lock_interruptible_nested(struct mutex *lock, int subclass);
 extern int __lockfunc _mutex_lock_killable_nested(struct mutex *lock, int subclass);
 extern int __lockfunc _mutex_trylock(struct mutex *lock);
diff --git a/include/linux/spinlock.h b/include/linux/spinlock.h
index 6721994..9d544c9 100644
--- a/include/linux/spinlock.h
+++ b/include/linux/spinlock.h
@@ -165,6 +165,8 @@ __rt_spin_lock_init(spinlock_t *lock, char *name, struct lock_class_key *key);
 
 extern void __lockfunc rt_spin_lock(spinlock_t *lock);
 extern void __lockfunc rt_spin_lock_nested(spinlock_t *lock, int subclass);
+extern void __lockfunc
+rt_spin_lock_nest_lock(spinlock_t *lock, struct lockdep_map *map);
 extern void __lockfunc rt_spin_unlock(spinlock_t *lock);
 extern void __lockfunc rt_spin_unlock_wait(spinlock_t *lock);
 extern int __lockfunc
@@ -182,6 +184,7 @@ extern void __lockfunc __rt_spin_unlock(struct rt_mutex *lock);
 #ifdef CONFIG_PREEMPT_RT
 # define _spin_lock(l)			rt_spin_lock(l)
 # define _spin_lock_nested(l, s)	rt_spin_lock_nested(l, s)
+# define _spin_lock_nest_lock(l, m)	rt_spin_lock_nest_lock(l, m)
 # define _spin_lock_bh(l)		rt_spin_lock(l)
 # define _spin_lock_irq(l)		rt_spin_lock(l)
 # define _spin_unlock(l)		rt_spin_unlock(l)
@@ -212,6 +215,7 @@ _spin_lock_irqsave_nested(spinlock_t *lock, int subclass)
 }
 # define _spin_lock(l)			do { } while (0)
 # define _spin_lock_nested(l, s)	do { } while (0)
+# define _spin_lock_nest_lock(l, m)	do { } while (0)
 # define _spin_lock_bh(l)		do { } while (0)
 # define _spin_lock_irq(l)		do { } while (0)
 # define _spin_unlock(l)		do { } while (0)
@@ -403,14 +407,11 @@ do {								\
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 # define spin_lock_nested(lock, subclass)	\
 	PICK_SPIN_OP(__spin_lock_nested, _spin_lock_nested, lock, subclass)
-# define spin_lock_nest_lock(lock, nest_lock)				\
-	 do {								\
-		 typecheck(struct lockdep_map *, &(nest_lock)->dep_map);\
-		 _spin_lock_nest_lock(lock, &(nest_lock)->dep_map);	\
-	 } while (0)
+# define spin_lock_nest_lock(lock, nest_lock)	\
+	PICK_SPIN_OP(__spin_lock_nest_lock, _spin_lock_nest_lock, lock, nest_lock)
 #else
 # define spin_lock_nested(lock, subclass) spin_lock(lock)
-# define spin_lock_nest_lock(lock, nest_lock) _spin_lock(lock)
+# define spin_lock_nest_lock(lock, nest_lock) spin_lock(lock)
 #endif
 
 #define write_lock(lock) PICK_RW_OP(__write_lock, _write_lock, lock)
diff --git a/include/linux/spinlock_api_smp.h b/include/linux/spinlock_api_smp.h
index 3398e3f..560c4c8 100644
--- a/include/linux/spinlock_api_smp.h
+++ b/include/linux/spinlock_api_smp.h
@@ -27,7 +27,7 @@ int in_lock_functions(unsigned long addr);
 void __lockfunc __spin_lock(raw_spinlock_t *lock)		ACQUIRE_SPIN;
 void __lockfunc __spin_lock_nested(raw_spinlock_t *lock, int subclass)
 								ACQUIRE_SPIN;
-void __lockfunc _spin_lock_nest_lock(spinlock_t *lock, struct lockdep_map *map)
+void __lockfunc __spin_lock_nest_lock(raw_spinlock_t *lock, struct lockdep_map *map)
 								ACQUIRE_SPIN;
 void __lockfunc __read_lock(raw_rwlock_t *lock)			ACQUIRE_RW;
 void __lockfunc __write_lock(raw_rwlock_t *lock)		ACQUIRE_RW;
diff --git a/kernel/rt.c b/kernel/rt.c
index 039116a..abf2953 100644
--- a/kernel/rt.c
+++ b/kernel/rt.c
@@ -141,6 +141,15 @@ void __lockfunc _mutex_lock_nested(struct mutex *lock, int subclass)
 }
 EXPORT_SYMBOL(_mutex_lock_nested);
 
+void __lockfunc _mutex_lock_nest_lock(struct mutex *lock,
+					struct lockdep_map *nest_lock)
+{
+	mutex_acquire_nest(&lock->dep_map, 0, 0, nest_lock, _RET_IP_);
+	LOCK_CONTENDED_RT(lock, rt_mutex_trylock, rt_mutex_lock);
+}
+EXPORT_SYMBOL(_mutex_lock_nest_lock);
+
+
 int __lockfunc _mutex_lock_interruptible_nested(struct mutex *lock, int subclass)
 {
 	int ret;
diff --git a/kernel/spinlock.c b/kernel/spinlock.c
index d7f8839..66817f0 100644
--- a/kernel/spinlock.c
+++ b/kernel/spinlock.c
@@ -345,8 +345,8 @@ void __lockfunc __spin_lock_nested(raw_spinlock_t *lock, int subclass)
 }
 EXPORT_SYMBOL(__spin_lock_nested);
 
-unsigned long __lockfunc
-__spin_lock_irqsave_nested(raw_spinlock_t *lock, int subclass)
+unsigned long __lockfunc __spin_lock_irqsave_nested(raw_spinlock_t *lock,
+							int subclass)
 {
 	unsigned long flags;
 
@@ -367,14 +367,14 @@ __spin_lock_irqsave_nested(raw_spinlock_t *lock, int subclass)
 }
 EXPORT_SYMBOL(__spin_lock_irqsave_nested);
 
-void __lockfunc _spin_lock_nest_lock(spinlock_t *lock,
+void __lockfunc __spin_lock_nest_lock(raw_spinlock_t *lock,
 				     struct lockdep_map *nest_lock)
 {
 	preempt_disable();
 	spin_acquire_nest(&lock->dep_map, 0, 0, nest_lock, _RET_IP_);
 	LOCK_CONTENDED(lock, _raw_spin_trylock, _raw_spin_lock);
 }
-EXPORT_SYMBOL(_spin_lock_nest_lock);
+EXPORT_SYMBOL(__spin_lock_nest_lock);
 
 #endif
 
