From ca58aabd9bca424d8e19eb6ad031f4d3fe7b3ec7 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Tue, 30 Sep 2008 16:58:26 -0400
Subject: [PATCH] patch preempt-realtime-irqs.patch

---
 include/linux/irq.h   |   10 ++++------
 kernel/irq/handle.c   |   10 +++++++++-
 kernel/irq/manage.c   |   22 ++++++++++++++++------
 kernel/irq/spurious.c |    3 +--
 4 files changed, 30 insertions(+), 15 deletions(-)

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 37b7ada..6c02594 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -147,7 +147,6 @@ struct irq_chip {
  * @last_unhandled:	aging timer for unhandled count
  * @thread:		Thread pointer for threaded preemptible irq handling
  * @wait_for_handler:	Waitqueue to wait for a running preemptible handler
- * @cycles:		Timestamp for stats and debugging
  * @lock:		locking for SMP
  * @affinity:		IRQ affinity on SMP
  * @cpu:		cpu index useful for balancing
@@ -170,10 +169,10 @@ struct irq_desc {
 	unsigned int		irq_count;	/* For detecting broken IRQs */
 	unsigned int		irqs_unhandled;
 	unsigned long		last_unhandled;	/* Aging timer for unhandled count */
- 	struct task_struct	*thread;
- 	wait_queue_head_t	wait_for_handler;
- 	cycles_t		timestamp;
-	spinlock_t		lock;
+	struct task_struct	*thread;
+	wait_queue_head_t	wait_for_handler;
+	cycles_t		timestamp;
+	raw_spinlock_t		lock;
 #ifdef CONFIG_SMP
 	cpumask_t		affinity;
 	unsigned int		cpu;
@@ -389,7 +388,6 @@ extern int set_irq_msi(unsigned int irq, struct msi_desc *entry);
 
 /* Early initialization of irqs */
 extern void early_init_hardirqs(void);
-extern cycles_t irq_timestamp(unsigned int irq);
 
 #if defined(CONFIG_PREEMPT_HARDIRQS)
 extern void init_hardirqs(void);
diff --git a/kernel/irq/handle.c b/kernel/irq/handle.c
index 706efe7..9ea9f73 100644
--- a/kernel/irq/handle.c
+++ b/kernel/irq/handle.c
@@ -54,12 +54,13 @@ struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = {
 		.chip = &no_irq_chip,
 		.handle_irq = handle_bad_irq,
 		.depth = 1,
-		.lock = __SPIN_LOCK_UNLOCKED(irq_desc->lock),
+		.lock = RAW_SPIN_LOCK_UNLOCKED(irq_desc),
 #ifdef CONFIG_SMP
 		.affinity = CPU_MASK_ALL
 #endif
 	}
 };
+EXPORT_SYMBOL_GPL(irq_desc);
 
 /*
  * What should we do if we get a hw irq event on an illegal vector?
@@ -248,6 +249,13 @@ unsigned int __do_IRQ(unsigned int irq)
 		desc->chip->end(irq);
 		return 1;
 	}
+	/*
+	 * If the task is currently running in user mode, don't
+	 * detect soft lockups.  If CONFIG_DETECT_SOFTLOCKUP is not
+	 * configured, this should be optimized out.
+	 */
+	if (user_mode(get_irq_regs()))
+		touch_softlockup_watchdog();
 
 	spin_lock(&desc->lock);
 	if (desc->chip->ack)
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 47e820a..bf89f10 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -574,9 +574,9 @@ void free_irq(unsigned int irq, void *dev_id)
 			 * parallel with our fake
 			 */
 			if (action->flags & IRQF_SHARED) {
-				local_irq_save(flags);
+				local_irq_save_nort(flags);
 				action->handler(irq, dev_id);
-				local_irq_restore(flags);
+				local_irq_restore_nort(flags);
 			}
 #endif
 			kfree(action);
@@ -669,9 +669,9 @@ int request_irq(unsigned int irq, irq_handler_t handler,
 		 */
 		unsigned long flags;
 
-		local_irq_save(flags);
+		local_irq_save_nort(flags);
 		handler(irq, dev_id);
-		local_irq_restore(flags);
+		local_irq_restore_nort(flags);
 	}
 #endif
 
@@ -689,6 +689,11 @@ int hardirq_preemption = 1;
 
 EXPORT_SYMBOL(hardirq_preemption);
 
+/*
+ * Real-Time Preemption depends on hardirq threading:
+ */
+#ifndef CONFIG_PREEMPT_RT
+
 static int __init hardirq_preempt_setup (char *str)
 {
 	if (!strncmp(str, "off", 3))
@@ -703,6 +708,7 @@ static int __init hardirq_preempt_setup (char *str)
 
 __setup("hardirq-preempt=", hardirq_preempt_setup);
 
+#endif
 
 /*
  * threaded simple handler
@@ -862,12 +868,16 @@ static int do_irqd(void * __desc)
 	sys_sched_setscheduler(current->pid, SCHED_FIFO, &param);
 
 	while (!kthread_should_stop()) {
-		local_irq_disable();
+		local_irq_disable_nort();
 		set_current_state(TASK_INTERRUPTIBLE);
+#ifndef CONFIG_PREEMPT_RT
 		irq_enter();
+#endif
 		do_hardirq(desc);
+#ifndef CONFIG_PREEMPT_RT
 		irq_exit();
-		local_irq_enable();
+#endif
+		local_irq_enable_nort();
 		cond_resched();
 #ifdef CONFIG_SMP
 		/*
diff --git a/kernel/irq/spurious.c b/kernel/irq/spurious.c
index 9fc3b1c..1534224 100644
--- a/kernel/irq/spurious.c
+++ b/kernel/irq/spurious.c
@@ -62,9 +62,8 @@ static int misrouted_irq(int irq)
 			}
 			action = action->next;
 		}
-		local_irq_disable();
 		/* Now clean up the flags */
-		spin_lock(&desc->lock);
+		spin_lock_irq(&desc->lock);
 		action = desc->action;
 
 		/*
-- 
1.6.0.90.g436ed

