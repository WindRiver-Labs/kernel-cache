From 35e4a57ff96bc10feba6ca04fb0a5a644ee064db Mon Sep 17 00:00:00 2001
From: Yong Zhang <yong.zhang@windriver.com>
Date: Thu, 24 May 2012 13:00:16 +0800
Subject: [PATCH] EMGD: upgrade to version 2209-1.10

Kernel driver from Intel EMGD rev 2209-1.10,
with modifications to build in the WR Linux kernel tree.

Integrated-by: Yong Zhang <yong.zhang@windriver.com>
---
 drivers/gpu/drm/emgd/Makefile                      |   24 +-
 drivers/gpu/drm/emgd/emgd/cfg/config.h             |   21 +-
 drivers/gpu/drm/emgd/emgd/cfg/config_default.h     |    7 +-
 drivers/gpu/drm/emgd/emgd/cfg/config_helper.c      |   11 +-
 .../gpu/drm/emgd/emgd/core/init/cmn/igd_global.c   |   12 +-
 drivers/gpu/drm/emgd/emgd/core/init/cmn/igd_init.c |   39 +-
 .../drm/emgd/emgd/core/init/cmn/init_dispatch.h    |    6 +-
 drivers/gpu/drm/emgd/emgd/core/init/plb/init_plb.c |    4 +-
 .../drm/emgd/emgd/core/init/plb/micro_init_plb.c   |   12 +-
 drivers/gpu/drm/emgd/emgd/core/init/tnc/init_tnc.c |  148 +-
 .../drm/emgd/emgd/core/init/tnc/micro_init_tnc.c   |   91 +-
 drivers/gpu/drm/emgd/emgd/display/dsp/cmn/dsp.c    |  102 +-
 .../drm/emgd/emgd/display/dsp/cmn/dsp_dispatch.h   |    7 +-
 .../gpu/drm/emgd/emgd/display/dsp/plb/dsp_plb.c    |   51 +-
 .../gpu/drm/emgd/emgd/display/dsp/tnc/dsp_tnc.c    |   52 +-
 .../gpu/drm/emgd/emgd/display/mode/cmn/igd_mode.c  |  180 +-
 drivers/gpu/drm/emgd/emgd/display/mode/cmn/match.c | 1151 ++--
 drivers/gpu/drm/emgd/emgd/display/mode/cmn/match.h |   20 +-
 .../drm/emgd/emgd/display/mode/cmn/micro_mode.c    |  136 +-
 .../drm/emgd/emgd/display/mode/cmn/mode_dispatch.h |   54 +-
 .../gpu/drm/emgd/emgd/display/mode/cmn/vga_mode.c  |  180 +-
 .../drm/emgd/emgd/display/mode/plb/clocks_plb.c    |  201 +-
 .../drm/emgd/emgd/display/mode/plb/kms_mode_plb.c  | 1102 ++++
 .../emgd/emgd/display/mode/plb/micro_mode_plb.c    |   62 +-
 .../gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c  |  188 +-
 .../gpu/drm/emgd/emgd/display/mode/plb/mode_plb.h  |   47 +
 .../drm/emgd/emgd/display/mode/tnc/clocks_tnc.c    |  380 +-
 .../drm/emgd/emgd/display/mode/tnc/kms_mode_tnc.c  | 1721 +++++
 .../emgd/emgd/display/mode/tnc/micro_mode_tnc.c    |  532 +-
 .../gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.c  |  308 +-
 .../gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.h  |   52 +
 drivers/gpu/drm/emgd/emgd/display/pd/cmn/pd.c      |   10 +-
 .../gpu/drm/emgd/emgd/display/pi/cmn/displayid.c   |   10 +-
 drivers/gpu/drm/emgd/emgd/display/pi/cmn/edid.c    |   10 +-
 .../drm/emgd/emgd/display/pi/cmn/i2c_dispatch.h    |    8 +-
 drivers/gpu/drm/emgd/emgd/display/pi/cmn/igd_pi.c  |   10 +-
 .../gpu/drm/emgd/emgd/display/pi/cmn/mode_table.c  |   13 +-
 .../gpu/drm/emgd/emgd/display/pi/cmn/pd_init_all.c |   16 +-
 drivers/gpu/drm/emgd/emgd/display/pi/cmn/pi.c      |  163 +-
 drivers/gpu/drm/emgd/emgd/display/pi/plb/i2c_plb.c |   10 +-
 .../drm/emgd/emgd/display/pi/tnc/i2c_bitbash_tnc.c |   37 +-
 .../drm/emgd/emgd/display/pi/tnc/i2c_gmbus_tnc.c   |   21 +-
 drivers/gpu/drm/emgd/emgd/drm/drm_emgd_private.h   |   41 +-
 drivers/gpu/drm/emgd/emgd/drm/emgd_connector.c     |  512 ++
 drivers/gpu/drm/emgd/emgd/drm/emgd_crtc.c          | 1004 +++
 drivers/gpu/drm/emgd/emgd/drm/emgd_drv.c           | 1092 +++-
 drivers/gpu/drm/emgd/emgd/drm/emgd_drv.h           |   31 +-
 drivers/gpu/drm/emgd/emgd/drm/emgd_encoder.c       |  474 ++
 drivers/gpu/drm/emgd/emgd/drm/emgd_fb.c            | 1633 +++--
 drivers/gpu/drm/emgd/emgd/drm/emgd_fbcon.c         |  795 +++
 drivers/gpu/drm/emgd/emgd/drm/emgd_interface.c     |  635 +-
 drivers/gpu/drm/emgd/emgd/drm/emgd_mmap.c          |    8 +-
 drivers/gpu/drm/emgd/emgd/drm/emgd_test_pvrsrv.c   |   11 +-
 drivers/gpu/drm/emgd/emgd/drm/image_data.h         |   33 +
 drivers/gpu/drm/emgd/emgd/drm/splash_screen.c      | 2138 +++++-
 drivers/gpu/drm/emgd/emgd/drm/splash_screen.h      |  229 +-
 drivers/gpu/drm/emgd/emgd/drm/user_config.c        |  347 +-
 drivers/gpu/drm/emgd/emgd/drm/user_config.h        |    6 +-
 drivers/gpu/drm/emgd/emgd/gmm/gmm.c                |  254 +-
 drivers/gpu/drm/emgd/emgd/gmm/gtt.c                |   39 +-
 drivers/gpu/drm/emgd/emgd/include/cmd.h            |    4 +-
 drivers/gpu/drm/emgd/emgd/include/context.h        |   39 +-
 drivers/gpu/drm/emgd/emgd/include/debug.h          |   11 +-
 drivers/gpu/drm/emgd/emgd/include/decode.h         |    4 +-
 drivers/gpu/drm/emgd/emgd/include/dispatch.h       |    4 +-
 drivers/gpu/drm/emgd/emgd/include/dispatch_utils.h |    4 +-
 drivers/gpu/drm/emgd/emgd/include/displayid.h      |   10 +-
 drivers/gpu/drm/emgd/emgd/include/dsp.h            |   10 +-
 drivers/gpu/drm/emgd/emgd/include/edid.h           |   10 +-
 drivers/gpu/drm/emgd/emgd/include/general.h        |   10 +-
 drivers/gpu/drm/emgd/emgd/include/instr_common.h   |    4 +-
 drivers/gpu/drm/emgd/emgd/include/intelpci.h       |   10 +-
 drivers/gpu/drm/emgd/emgd/include/math_fix.h       |    4 +-
 drivers/gpu/drm/emgd/emgd/include/memlist.h        |   15 +-
 drivers/gpu/drm/emgd/emgd/include/memory.h         |    4 +-
 drivers/gpu/drm/emgd/emgd/include/mode.h           |  157 +-
 drivers/gpu/drm/emgd/emgd/include/mode_access.h    |   10 +-
 drivers/gpu/drm/emgd/emgd/include/module_init.h    |    4 +-
 drivers/gpu/drm/emgd/emgd/include/msvdx.h          |    4 +-
 drivers/gpu/drm/emgd/emgd/include/pci.h            |    4 +-
 drivers/gpu/drm/emgd/emgd/include/pd.h             |   11 +-
 drivers/gpu/drm/emgd/emgd/include/pd_init.h        |   10 +-
 drivers/gpu/drm/emgd/emgd/include/pi.h             |   13 +-
 drivers/gpu/drm/emgd/emgd/include/plb/appcontext.h |    4 +-
 drivers/gpu/drm/emgd/emgd/include/plb/cmd.h        |    4 +-
 drivers/gpu/drm/emgd/emgd/include/plb/context.h    |    7 +-
 drivers/gpu/drm/emgd/emgd/include/plb/instr.h      |   10 +-
 drivers/gpu/drm/emgd/emgd/include/plb/mi.h         |    4 +-
 drivers/gpu/drm/emgd/emgd/include/plb/regs.h       |   47 +-
 drivers/gpu/drm/emgd/emgd/include/plb/sgx.h        |    4 +-
 drivers/gpu/drm/emgd/emgd/include/plb/state3d.h    |    4 +-
 .../gpu/drm/emgd/emgd/include/plb/state3d_plb.h    |   38 +-
 drivers/gpu/drm/emgd/emgd/include/psb_regs.h       |   10 +-
 drivers/gpu/drm/emgd/emgd/include/rb.h             |   12 +-
 drivers/gpu/drm/emgd/emgd/include/reset.h          |    4 +-
 drivers/gpu/drm/emgd/emgd/include/sched.h          |   40 +-
 drivers/gpu/drm/emgd/emgd/include/state2d.h        |    4 +-
 drivers/gpu/drm/emgd/emgd/include/tnc/appcontext.h |    4 +-
 drivers/gpu/drm/emgd/emgd/include/tnc/cmd.h        |    4 +-
 drivers/gpu/drm/emgd/emgd/include/tnc/context.h    |    4 +-
 drivers/gpu/drm/emgd/emgd/include/tnc/igd_tnc_wa.h |   33 +-
 drivers/gpu/drm/emgd/emgd/include/tnc/instr.h      |   10 +-
 drivers/gpu/drm/emgd/emgd/include/tnc/mi.h         |    4 +-
 drivers/gpu/drm/emgd/emgd/include/tnc/regs.h       |   60 +-
 drivers/gpu/drm/emgd/emgd/include/tnc/sgx.h        |    4 +-
 drivers/gpu/drm/emgd/emgd/include/tnc/state3d.h    |    4 +-
 .../gpu/drm/emgd/emgd/include/tnc/state3d_plb.h    |    4 +-
 drivers/gpu/drm/emgd/emgd/include/topaz.h          |    5 +-
 drivers/gpu/drm/emgd/emgd/include/utils.h          |   10 +-
 drivers/gpu/drm/emgd/emgd/include/vga.h            |   13 +-
 drivers/gpu/drm/emgd/emgd/oal/src/math_fix.c       |    4 +-
 drivers/gpu/drm/emgd/emgd/oal/src/memmap.c         |    4 +-
 drivers/gpu/drm/emgd/emgd/oal/src/pci.c            |    4 +-
 drivers/gpu/drm/emgd/emgd/pal/Makefile.include     |    4 +-
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.c      | 2349 +++++++
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.def    |    5 +
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.h      |   51 +
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.c |  933 +++
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.h |   85 +
 .../drm/emgd/emgd/pal/ch7036/ch7036_def_regmap.h   |  700 ++
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.c   |  502 ++
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.h   |  217 +
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_iic.c  |  335 +
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_iic.h  |   62 +
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.c |  922 +++
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.h |  216 +
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_pm.c   |  512 ++
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.c | 1164 ++++
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.h |   59 +
 .../drm/emgd/emgd/pal/ch7036/ch7036_reg_table.c    |  220 +
 .../drm/emgd/emgd/pal/ch7036/ch7036_reg_table.h    |  118 +
 .../gpu/drm/emgd/emgd/pal/ch7036/ch7036_typedef.h  |  464 ++
 drivers/gpu/drm/emgd/emgd/pal/ch7036/config_.h     |   87 +
 drivers/gpu/drm/emgd/emgd/pal/ch7036/hdcp7036.car  | 6782 ++++++++++++++++++++
 drivers/gpu/drm/emgd/emgd/pal/ch7036/lvds/lvds.c   | 1563 +++++
 drivers/gpu/drm/emgd/emgd/pal/ch7036/lvds/lvds.h   |  167 +
 drivers/gpu/drm/emgd/emgd/pal/lpd/lpd.c            |    4 +-
 drivers/gpu/drm/emgd/emgd/pal/lpd/pd_print.h       |   10 +-
 drivers/gpu/drm/emgd/emgd/pal/lvds/lvds.c          |   42 +-
 drivers/gpu/drm/emgd/emgd/pal/lvds/lvds.h          |   10 +-
 drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo.def        |   20 +
 drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_attr.c     |   26 +-
 drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_attr.h     |    4 +-
 drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_hdmi.c     |    4 +-
 drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_hdmi.h     |    4 +-
 drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_intf.c     |    4 +-
 drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_intf.h     |   10 +-
 drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.c     |  165 +-
 drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.h     |    4 +-
 .../state/appcontext/cmn/appcontext_dispatch.h     |    4 +-
 .../emgd/state/appcontext/cmn/igd_appcontext.c     |   10 +-
 .../emgd/state/appcontext/plb/appcontext_plb.c     |   11 +-
 .../gpu/drm/emgd/emgd/state/power/cmn/igd_pwr.c    |   34 +-
 .../drm/emgd/emgd/state/power/cmn/pwr_dispatch.h   |    9 +-
 .../gpu/drm/emgd/emgd/state/power/plb/pwr_plb.c    |   10 +-
 drivers/gpu/drm/emgd/emgd/state/reg/cmn/reg.c      |  172 +-
 .../gpu/drm/emgd/emgd/state/reg/cmn/reg_dispatch.h |    7 +-
 drivers/gpu/drm/emgd/emgd/state/reg/plb/reg_plb.c  |   93 +-
 drivers/gpu/drm/emgd/emgd/state/reg/tnc/reg_tnc.c  |   93 +-
 drivers/gpu/drm/emgd/emgd/utils/math_fix.c         |    4 +-
 drivers/gpu/drm/emgd/emgd/utils/memmap.c           |    4 +-
 drivers/gpu/drm/emgd/emgd/utils/pci.c              |    4 +-
 drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx.c      |   26 +-
 drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_init.c |   50 +-
 drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_pvr.c  |    4 +-
 drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_pvr.h  |    4 +-
 .../gpu/drm/emgd/emgd/video/overlay/cmn/igd_ovl.c  |  105 +-
 .../drm/emgd/emgd/video/overlay/cmn/micro_ovl.c    |    4 +-
 .../drm/emgd/emgd/video/overlay/cmn/ovl_coeff.c    |    6 +-
 .../drm/emgd/emgd/video/overlay/cmn/ovl_coeff.h    |    4 +-
 .../drm/emgd/emgd/video/overlay/cmn/ovl_dispatch.h |    4 +-
 .../gpu/drm/emgd/emgd/video/overlay/cmn/ovl_virt.h |   21 +-
 .../emgd/emgd/video/overlay/plb/micro_ovl_plb.c    |   52 +-
 .../gpu/drm/emgd/emgd/video/overlay/plb/ovl2_plb.c |   11 +-
 .../gpu/drm/emgd/emgd/video/overlay/plb/ovl2_plb.h |    4 +-
 .../emgd/emgd/video/overlay/plb/ovl2_regs_plb.h    |    5 +-
 .../gpu/drm/emgd/emgd/video/overlay/plb/ovl_plb.c  |   26 +-
 .../emgd/emgd/video/overlay/plb/ovl_plb_cache.c    |    4 +-
 .../emgd/emgd/video/overlay/plb/ovl_plb_cache.h    |    4 +-
 .../drm/emgd/emgd/video/overlay/plb/ovl_regs_plb.h |    4 +-
 .../emgd/emgd/video/overlay/tnc/micro_ovl_tnc.c    |   89 +-
 .../emgd/emgd/video/overlay/tnc/ovl2_regs_tnc.h    |    5 +-
 .../gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_tnc.c |    7 +-
 .../gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_tnc.h |    4 +-
 .../drm/emgd/emgd/video/overlay/tnc/ovl_regs_tnc.h |    4 +-
 .../gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc.c  |   23 +-
 .../emgd/emgd/video/overlay/tnc/ovl_tnc_cache.c    |    4 +-
 .../emgd/emgd/video/overlay/tnc/ovl_tnc_cache.h    |    4 +-
 drivers/gpu/drm/emgd/emgd/video/topaz/topaz.c      |   31 +-
 drivers/gpu/drm/emgd/emgd/video/topaz/topaz_hdr.h  |    4 +-
 drivers/gpu/drm/emgd/emgd/video/topaz/topaz_init.c |  145 +-
 drivers/gpu/drm/emgd/include/emgd_drm.h            |   99 +-
 drivers/gpu/drm/emgd/include/emgd_shared.h         |    4 +-
 drivers/gpu/drm/emgd/include/gart.h                |    4 +-
 drivers/gpu/drm/emgd/include/igd.h                 |  145 +-
 drivers/gpu/drm/emgd/include/igd_2d.h              |    4 +-
 drivers/gpu/drm/emgd/include/igd_appcontext.h      |   11 +-
 drivers/gpu/drm/emgd/include/igd_blend.h           |   11 +-
 drivers/gpu/drm/emgd/include/igd_debug.h           |    4 +-
 drivers/gpu/drm/emgd/include/igd_errno.h           |   25 +-
 drivers/gpu/drm/emgd/include/igd_gart.h            |    4 +-
 drivers/gpu/drm/emgd/include/igd_gmm.h             |    8 +-
 drivers/gpu/drm/emgd/include/igd_init.h            |   93 +-
 drivers/gpu/drm/emgd/include/igd_interrupt.h       |    4 +-
 drivers/gpu/drm/emgd/include/igd_mode.h            |   25 +-
 drivers/gpu/drm/emgd/include/igd_ovl.h             |   14 +-
 drivers/gpu/drm/emgd/include/igd_pd.h              |   52 +-
 drivers/gpu/drm/emgd/include/igd_pi.h              |   11 +-
 drivers/gpu/drm/emgd/include/igd_pwr.h             |    4 +-
 drivers/gpu/drm/emgd/include/igd_rb.h              |   11 +-
 drivers/gpu/drm/emgd/include/igd_render.h          |   37 +-
 drivers/gpu/drm/emgd/include/igd_reset.h           |    4 +-
 drivers/gpu/drm/emgd/include/igd_version.h         |    8 +-
 drivers/gpu/drm/emgd/include/igd_vga.h             |    4 +-
 drivers/gpu/drm/emgd/include/io.h                  |   10 +-
 drivers/gpu/drm/emgd/include/memmap.h              |    4 +-
 drivers/gpu/drm/emgd/pvr/include4/services.h       |    2 +-
 drivers/gpu/drm/emgd/pvr/include4/servicesext.h    |    2 +-
 .../services4/3rdparty/emgd_displayclass/emgd_dc.c |   31 +-
 .../services4/3rdparty/emgd_displayclass/emgd_dc.h |    4 +-
 .../3rdparty/emgd_displayclass/emgd_dc_linux.c     |    2 +-
 .../drm/emgd/pvr/services4/include/pvr_bridge_km.h |    5 +
 .../services4/srvkm/bridged/bridged_pvr_bridge.c   |    2 +-
 .../srvkm/bridged/sgx/bridged_sgx_bridge.c         |    2 +-
 .../emgd/pvr/services4/srvkm/common/deviceclass.c  |    8 +-
 .../emgd/pvr/services4/srvkm/common/devicemem.c    |   90 +-
 .../gpu/drm/emgd/pvr/services4/srvkm/common/hash.c |    4 +-
 .../drm/emgd/pvr/services4/srvkm/common/resman.c   |    3 -
 .../drm/emgd/pvr/services4/srvkm/devices/sgx/mmu.c |    4 +-
 .../pvr/services4/srvkm/devices/sgx/sgxinfokm.h    |    2 +-
 .../emgd/pvr/services4/srvkm/devices/sgx/sgxinit.c |   10 +-
 .../drm/emgd/pvr/services4/srvkm/env/linux/event.c |    8 +-
 .../drm/emgd/pvr/services4/srvkm/env/linux/mm.c    |   12 +-
 .../drm/emgd/pvr/services4/srvkm/env/linux/mm.h    |    4 -
 .../drm/emgd/pvr/services4/srvkm/env/linux/mmap.c  |   12 +-
 .../emgd/pvr/services4/srvkm/env/linux/module.c    |    4 -
 .../emgd/pvr/services4/srvkm/env/linux/mutils.c    |    3 -
 .../emgd/pvr/services4/srvkm/env/linux/mutils.h    |    4 -
 .../emgd/pvr/services4/srvkm/env/linux/osfunc.c    |   10 +-
 .../drm/emgd/pvr/services4/srvkm/env/linux/proc.c  |   12 +-
 .../pvr/services4/srvkm/env/linux/pvr_bridge_k.c   |    2 +-
 .../emgd/pvr/services4/srvkm/env/linux/pvr_debug.c |    8 +-
 .../emgd/pvr/services4/srvkm/env/linux/pvr_drm.c   |    4 -
 .../emgd/pvr/services4/system/common/sysconfig.c   |    7 +-
 .../emgd/pvr/services4/system/include/sysconfig.h  |   10 +-
 .../drm/emgd/pvr/services4/system/plb/sysconfig.c  |    7 +-
 .../drm/emgd/pvr/services4/system/tnc/sysconfig.c  |    7 +-
 .../tools/intern/debug/dbgdriv/linux/hostfunc.c    |    2 +-
 248 files changed, 33250 insertions(+), 3784 deletions(-)
 create mode 100644 drivers/gpu/drm/emgd/emgd/display/mode/plb/kms_mode_plb.c
 create mode 100644 drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.h
 create mode 100644 drivers/gpu/drm/emgd/emgd/display/mode/tnc/kms_mode_tnc.c
 create mode 100644 drivers/gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.h
 create mode 100644 drivers/gpu/drm/emgd/emgd/drm/emgd_connector.c
 create mode 100644 drivers/gpu/drm/emgd/emgd/drm/emgd_crtc.c
 create mode 100644 drivers/gpu/drm/emgd/emgd/drm/emgd_encoder.c
 create mode 100644 drivers/gpu/drm/emgd/emgd/drm/emgd_fbcon.c
 create mode 100644 drivers/gpu/drm/emgd/emgd/drm/image_data.h
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.c
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.def
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.h
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.c
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.h
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_def_regmap.h
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.c
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.h
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_iic.c
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_iic.h
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.c
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.h
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_pm.c
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.c
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.h
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_reg_table.c
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_reg_table.h
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_typedef.h
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/config_.h
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/hdcp7036.car
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/lvds/lvds.c
 create mode 100644 drivers/gpu/drm/emgd/emgd/pal/ch7036/lvds/lvds.h

diff --git a/drivers/gpu/drm/emgd/Makefile b/drivers/gpu/drm/emgd/Makefile
index 06d92d8..a04034f 100644
--- a/drivers/gpu/drm/emgd/Makefile
+++ b/drivers/gpu/drm/emgd/Makefile
@@ -1,6 +1,6 @@
 #----------------------------------------------------------------------------
 # Filename: Makefile.gnu
-# $Revision: 1.53 $
+# $Revision: 1.57 $
 #----------------------------------------------------------------------------
 # Copyright (c) 2002-2010, Intel Corporation.
 #
@@ -33,6 +33,8 @@ ccflags-y := \
 	   -Idrivers/gpu/drm/emgd/emgd/include \
 	   -Idrivers/gpu/drm/emgd/emgd/cfg \
 	   -Idrivers/gpu/drm/emgd/emgd/pal/lpd \
+	   -Idrivers/gpu/drm/emgd/emgd/pal/lvds \
+	   -Idrivers/gpu/drm/emgd/emgd/pal/ch7036 \
 	   -Idrivers/gpu/drm/emgd/emgd/drm \
 	   -Iinclude/drm \
 	   -Idrivers/gpu/drm/emgd/pvr/include4 \
@@ -51,7 +53,7 @@ ccflags-y := \
 	   -DSUPPORT_DRI_DRM_EXT \
 	   -DLINUX \
 	   -DPVR_BUILD_DIR="\"emgd\"" \
-	   -DPVR_BUILD_DATE="20100408" \
+	   -DPVR_BUILD_DATE="\"20111115\"" \
 	   -DPVR_BUILD_TYPE="\"release\"" \
 	   -DBUILD=release \
 	   -DRELEASE \
@@ -90,14 +92,15 @@ ccflags-y := \
 	   -DSUPPORT_EGL_IMAGE_SYNC_DEPENDENCY \
 
 
-#       -Werror \
-	   -DSUPPORT_MEMINFO_IDS \
-
 
 
 
 EMGD_OBJS := \
 	emgd/drm/emgd_fb.o \
+	emgd/drm/emgd_fbcon.o \
+	emgd/drm/emgd_crtc.o \
+	emgd/drm/emgd_encoder.o \
+	emgd/drm/emgd_connector.o \
 	emgd/drm/emgd_mmap.o \
 	emgd/drm/emgd_drv.o \
 	emgd/drm/emgd_interface.o \
@@ -120,10 +123,12 @@ EMGD_OBJS := \
 	emgd/display/mode/cmn/igd_mode.o \
 	emgd/display/mode/tnc/micro_mode_tnc.o \
 	emgd/display/mode/tnc/mode_tnc.o \
+	emgd/display/mode/tnc/kms_mode_tnc.o \
 	emgd/display/mode/tnc/clocks_tnc.o \
 	emgd/display/mode/plb/micro_mode_plb.o \
 	emgd/display/mode/plb/clocks_plb.o \
 	emgd/display/mode/plb/mode_plb.o \
+	emgd/display/mode/plb/kms_mode_plb.o \
 	emgd/display/dsp/cmn/dsp.o \
 	emgd/display/dsp/tnc/dsp_tnc.o \
 	emgd/display/dsp/plb/dsp_plb.o \
@@ -160,6 +165,15 @@ EMGD_OBJS := \
 	emgd/pal/sdvo/sdvo_hdmi.o \
 	emgd/pal/sdvo/sdvo_port.o \
 	emgd/pal/sdvo/sdvo_intf.o \
+	emgd/pal/ch7036/ch7036_attr.o \
+	emgd/pal/ch7036/ch7036_fw.o \
+	emgd/pal/ch7036/ch7036_intf.o \
+	emgd/pal/ch7036/ch7036_port.o \
+	emgd/pal/ch7036/ch7036.o \
+	emgd/pal/ch7036/ch7036_iic.o \
+	emgd/pal/ch7036/ch7036_pm.o \
+	emgd/pal/ch7036/ch7036_reg_table.o \
+	emgd/pal/ch7036/lvds/lvds.o \
 	emgd/pal/lvds/lvds.o \
 	emgd/pal/lpd/lpd.o \
 	emgd/gmm/gmm.o \
diff --git a/drivers/gpu/drm/emgd/emgd/cfg/config.h b/drivers/gpu/drm/emgd/emgd/cfg/config.h
index f440655..14e7ca8 100644
--- a/drivers/gpu/drm/emgd/emgd/cfg/config.h
+++ b/drivers/gpu/drm/emgd/emgd/cfg/config.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: config.h
- * $Revision: 1.12 $
+ * $Revision: 1.14 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -37,21 +37,6 @@
 #define _HAL_CONFIG_H
 
 /*
- *  * Select ONE of these to be defined. It controls which OAL port
- *   * is used during the build and where the output goes.
- *    */
-/* #define CONFIG_OAL linux */
-#define CONFIG_OAL linux-user
-/* #define CONFIG_OAL xfree86 */
-/* #define CONFIG_OAL windows */
-/* #define CONFIG_OAL null */
-
-/* #define CONFIG_OAL_WINDOWS_MINIPORT */
-
-
-//#define CONFIG_NEW_MATCH 1
-
-/*
  * Which Cores are supported
  *
  * Use Defaults
@@ -112,9 +97,11 @@
 #define CONFIG_PD_LVDS   1
 #define CONFIG_PD_SDVO   1
 #define CONFIG_PD_TV     0 /* Integrated TV for NAPA */
+#define CONFIG_PD_CH7036  1
 
 #define CONFIG_LINK_PD_LVDS
 #define CONFIG_LINK_PD_SDVO
+#define CONFIG_LINK_PD_CH7036
 
 #define CONFIG_DECODE
 
diff --git a/drivers/gpu/drm/emgd/emgd/cfg/config_default.h b/drivers/gpu/drm/emgd/emgd/cfg/config_default.h
index 045f31c..ded040a5 100644
--- a/drivers/gpu/drm/emgd/emgd/cfg/config_default.h
+++ b/drivers/gpu/drm/emgd/emgd/cfg/config_default.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: config_default.h
- * $Revision: 1.11 $
+ * $Revision: 1.15 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -46,7 +46,7 @@
 #ifndef _HAL_CONFIG_DEFAULT_H
 #define _HAL_CONFIG_DEFAULT_H
 
-#include <personality.h>
+#include <igd_version.h>
 
 #ifndef CONFIG_MICRO
 #define CONFIG_FULL
@@ -101,6 +101,7 @@
 #define CONFIG_PD_HDMI
 #define CONFIG_PD_SDVO
 #define CONFIG_PD_SOFTPD
+#define CONFIG_PD_CH7036
 #endif
 
 #ifdef CONFIG_DEPRECATED
diff --git a/drivers/gpu/drm/emgd/emgd/cfg/config_helper.c b/drivers/gpu/drm/emgd/emgd/cfg/config_helper.c
index a7800b7..a9e1327 100644
--- a/drivers/gpu/drm/emgd/emgd/cfg/config_helper.c
+++ b/drivers/gpu/drm/emgd/emgd/cfg/config_helper.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: config_helper.c
- * $Revision: 1.6 $
+ * $Revision: 1.8 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -170,6 +170,9 @@ int main(int argc, char **argv)
 #ifdef CONFIG_PD_SOFTPD
 		"PD_SOFTPD "
 #endif
+#ifdef CONFIG_PD_CH7036
+		"PD_CH7036 "
+#endif
 		/*
 		 * Port Driver Link Options
 		 */
@@ -227,7 +230,9 @@ int main(int argc, char **argv)
 #ifdef CONFIG_LINK_PD_SOFTPD
 		"LINK_PD_SOFTPD "
 #endif
-
+#ifdef CONFIG_LINK_PD_CH7036
+      "LINK_PD_CH7036 "
+#endif
 
 #ifdef CONFIG_COPP
 		"COPP "
diff --git a/drivers/gpu/drm/emgd/emgd/core/init/cmn/igd_global.c b/drivers/gpu/drm/emgd/emgd/core/init/cmn/igd_global.c
index afbbdb3..52bc62e 100644
--- a/drivers/gpu/drm/emgd/emgd/core/init/cmn/igd_global.c
+++ b/drivers/gpu/drm/emgd/emgd/core/init/cmn/igd_global.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_global.c
- * $Revision: 1.7 $
+ * $Revision: 1.9 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -32,11 +32,3 @@
 #include <igd_debug.h>
 
 /* Global debug flag has been moved to egd_drm/emgd/drm/emgd_drv.c */
-
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: igd_global.c,v 1.7 2011/03/02 22:47:04 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/core/init/cmn/igd_global.c,v $
- *----------------------------------------------------------------------------
- */
-
diff --git a/drivers/gpu/drm/emgd/emgd/core/init/cmn/igd_init.c b/drivers/gpu/drm/emgd/emgd/core/init/cmn/igd_init.c
index e25c299..ae8355f 100644
--- a/drivers/gpu/drm/emgd/emgd/core/init/cmn/igd_init.c
+++ b/drivers/gpu/drm/emgd/emgd/core/init/cmn/igd_init.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_init.c
- * $Revision: 1.19 $
+ * $Revision: 1.24 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -708,6 +708,9 @@ int igd_module_init(igd_driver_h driver_handle,
 	context->mod_dispatch.init_params = params;
 	context->dispatch.idle = empty_idle;
 	context->dispatch.sync = empty_sync;
+	context->mod_dispatch.in_dih_clone_mode = 0;
+	context->mod_dispatch.dih_clone_display = 0;
+	context->mod_dispatch.fb_blend_ovl_override = 0;
 
 	/* Intialize IGD Modules */
 	ret = init_modules(params, context);
@@ -878,10 +881,38 @@ void igd_driver_shutdown_hal(igd_driver_h driver_handle)
 	return;
 }
 
+
+/*!
+ * This function is exported directly. It will shutdown an instance
+ * of the HAL that was initialized with igd_driver_init.
+ *
+ * Since the symbol is exported as part of the documented API it must
+ * always exist, however it becomes an empty function when the init
+ * module is not fully included.
+ *
+ * @param driver_handle
+ *
+ * @return void
+ */
+void igd_query_2d_caps_hwhint(igd_driver_h driver_handle,
+		unsigned long caps_val,
+		unsigned long *status)
+{
+	igd_context_t *context = (igd_context_t *)driver_handle;
+
+	EMGD_TRACE_ENTER;
+
+	if (init_dispatch->query_2d_caps_hwint != NULL){
+		init_dispatch->
+			query_2d_caps_hwint(context, caps_val, status);
+	}
+
+	EMGD_TRACE_EXIT;
+	return;
+}
 /*----------------------------------------------------------------------------
  * File Revision History
- * $Id: igd_init.c,v 1.19 2011/03/02 22:47:04 astead Exp $
+ * $Id: igd_init.c,v 1.24 2011/09/30 07:53:25 rlim Exp $
  * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/core/init/cmn/igd_init.c,v $
  *----------------------------------------------------------------------------
  */
-
diff --git a/drivers/gpu/drm/emgd/emgd/core/init/cmn/init_dispatch.h b/drivers/gpu/drm/emgd/emgd/core/init/cmn/init_dispatch.h
index 77dfbd8..7c58997 100644
--- a/drivers/gpu/drm/emgd/emgd/core/init/cmn/init_dispatch.h
+++ b/drivers/gpu/drm/emgd/emgd/core/init/cmn/init_dispatch.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: init_dispatch.h
- * $Revision: 1.6 $
+ * $Revision: 1.8 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -53,6 +53,8 @@ typedef struct _init_dispatch {
 	int (*get_param)(igd_context_t *context, unsigned long id,
 		unsigned long *value);
 	void (*shutdown)(igd_context_t *context);
+	int (*query_2d_caps_hwint) (igd_context_t *context,
+		unsigned long caps_val, unsigned long *status);
 } init_dispatch_t;
 
 extern init_dispatch_t init_dispatch_plb;
diff --git a/drivers/gpu/drm/emgd/emgd/core/init/plb/init_plb.c b/drivers/gpu/drm/emgd/emgd/core/init/plb/init_plb.c
index 47257d4..06d189e 100644
--- a/drivers/gpu/drm/emgd/emgd/core/init/plb/init_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/core/init/plb/init_plb.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: init_plb.c
- * $Revision: 1.18 $
+ * $Revision: 1.19 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/core/init/plb/micro_init_plb.c b/drivers/gpu/drm/emgd/emgd/core/init/plb/micro_init_plb.c
index 7a676b0..c91adb6 100644
--- a/drivers/gpu/drm/emgd/emgd/core/init/plb/micro_init_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/core/init/plb/micro_init_plb.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: micro_init_plb.c
- * $Revision: 1.11 $
+ * $Revision: 1.13 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -52,6 +52,7 @@
 #include <plb/regs.h>
 #include <plb/context.h>
 
+#include "user_config.h"
 #include "../cmn/init_dispatch.h"
 
 /*!
@@ -79,6 +80,7 @@
 
 extern unsigned char io_mapped;
 extern unsigned short io_base;
+extern emgd_drm_config_t config_drm;
 
 extern int full_config_plb(igd_context_t *context,
 	init_dispatch_t *dispatch);
@@ -119,7 +121,8 @@ init_dispatch_t init_dispatch_plb = {
 	config_plb,
 	set_param_plb,
 	get_param_plb,
-	shutdown_plb
+	shutdown_plb,
+	NULL
 };
 
 
@@ -418,6 +421,9 @@ static int config_plb(igd_context_t *context,
 
 	OPT_MICRO_CALL(full_config_plb(context, dispatch));
 
+	/* If KMS is set, we need to unset it as KMS is not supported on PLB */
+	config_drm.kms = 0;
+
 	/* Set the Max Dclock */
 	if(OS_PCI_READ_CONFIG_32(platform_context->pcidev0,
 			INTEL_OFFSET_VGA_CORECLK, &coreclk)) {
diff --git a/drivers/gpu/drm/emgd/emgd/core/init/tnc/init_tnc.c b/drivers/gpu/drm/emgd/emgd/core/init/tnc/init_tnc.c
index 5f9f257..2cc3dfb 100644
--- a/drivers/gpu/drm/emgd/emgd/core/init/tnc/init_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/core/init/tnc/init_tnc.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: init_tnc.c
- * $Revision: 1.22 $
+ * $Revision: 1.24 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -50,6 +50,7 @@
 
 #include <tnc/regs.h>
 #include <tnc/context.h>
+#include <tnc/igd_tnc_wa.h>
 
 #include "../cmn/init_dispatch.h"
 
@@ -67,32 +68,6 @@ int full_get_param_tnc(igd_context_t *context,
 	unsigned long id,
 	unsigned long *value);
 
-/*!
- *
- * @param context
- * @param dispatch
- * @param vga_dev
- *
- * @return -IGD_ERROR_NODEV on failure
- * @return 0 on success
- */
-int get_revision_id_tnc(igd_context_t *context,
-	os_pci_dev_t vga_dev)
-{
-	EMGD_TRACE_ENTER;
-
-	/* Read RID */
-	if(OS_PCI_READ_CONFIG_8(vga_dev, PCI_RID,
-			(unsigned char *)&context->device_context.rid)) {
-		EMGD_ERROR_EXIT("Error occured reading RID");
-		return -IGD_ERROR_NODEV;
-	}
-
-	EMGD_DEBUG(" rid = 0x%lx", context->device_context.rid);
-
-	EMGD_TRACE_EXIT;
-	return 0;
-}
 
 /*!
  *
@@ -272,49 +247,50 @@ static int full_config_vga_tnc(igd_context_t *context,
 		context->device_context.virt_mmadr_sdvo);
 
 	/* Map the STMicro SDVO registers. */
-	if(OS_PCI_READ_CONFIG_32(platform_context->stbridgedev,
-			TNC_PCI_MMADR, (void*)&context->device_context.mmadr_sdvo_st)) {
-		EMGD_ERROR_EXIT("Reading MMADR");
-		return -IGD_ERROR_NODEV;
-	}
+	if(platform_context->stbridgedev) {
+		if(OS_PCI_READ_CONFIG_32(platform_context->stbridgedev,
+					TNC_PCI_MMADR, (void*)&context->device_context.mmadr_sdvo_st)) {
+			EMGD_ERROR_EXIT("Reading MMADR");
+			return -IGD_ERROR_NODEV;
+		}
 
-	context->device_context.mmadr_sdvo_st &= 0xfffffff9;
-	context->device_context.virt_mmadr_sdvo_st =
-		OS_MAP_IO_TO_MEM_NOCACHE(context->device_context.mmadr_sdvo_st,
-		TNC_ST_SDVO_MMIO_SIZE);
+		context->device_context.mmadr_sdvo_st &= 0xfffffff9;
+		context->device_context.virt_mmadr_sdvo_st =
+			OS_MAP_IO_TO_MEM_NOCACHE(context->device_context.mmadr_sdvo_st,
+					TNC_ST_SDVO_MMIO_SIZE);
 
-	if (!context->device_context.virt_mmadr_sdvo_st) {
-		EMGD_ERROR_EXIT("Failed to map MMADR");
-		return -IGD_ERROR_NODEV;
-	}
+		if (!context->device_context.virt_mmadr_sdvo_st) {
+			EMGD_ERROR_EXIT("Failed to map MMADR");
+			return -IGD_ERROR_NODEV;
+		}
 
-	EMGD_DEBUG("STMicro sdvo mmadr mapped %dKB @ (phys):0x%lx  (virt):%p",
-		TNC_ST_SDVO_MMIO_SIZE/1024,
-		context->device_context.mmadr_sdvo_st,
-		context->device_context.virt_mmadr_sdvo_st);
+		EMGD_DEBUG("STMicro sdvo mmadr mapped %dKB @ (phys):0x%lx  (virt):%p",
+				TNC_ST_SDVO_MMIO_SIZE/1024,
+				context->device_context.mmadr_sdvo_st,
+				context->device_context.virt_mmadr_sdvo_st);
 
-	/* Map the STMicro SDVO registers. */
-	if(OS_PCI_READ_CONFIG_32(platform_context->stgpiodev,
-			TNC_PCI_MMADR, (void*)&context->device_context.mmadr_sdvo_st_gpio)) {
-		EMGD_ERROR_EXIT("Reading MMADR");
-		return -IGD_ERROR_NODEV;
-	}
-
-	context->device_context.mmadr_sdvo_st_gpio &= 0xfffffff9;
-	context->device_context.virt_mmadr_sdvo_st_gpio =
-		OS_MAP_IO_TO_MEM_NOCACHE(context->device_context.mmadr_sdvo_st_gpio,
-		TNC_ST_SDVO_MMIO_SIZE);
+		/* Map the STMicro GPIO registers. */
+		if(OS_PCI_READ_CONFIG_32(platform_context->stgpiodev,
+					TNC_PCI_MMADR, (void*)&context->device_context.mmadr_sdvo_st_gpio)) {
+			EMGD_ERROR_EXIT("Reading MMADR");
+			return -IGD_ERROR_NODEV;
+		}
 
-	if (!context->device_context.virt_mmadr_sdvo_st_gpio) {
-		EMGD_ERROR_EXIT("Failed to map MMADR");
-		return -IGD_ERROR_NODEV;
-	}
+		context->device_context.mmadr_sdvo_st_gpio &= 0xfffffff9;
+		context->device_context.virt_mmadr_sdvo_st_gpio =
+			OS_MAP_IO_TO_MEM_NOCACHE(context->device_context.mmadr_sdvo_st_gpio,
+					TNC_ST_SDVO_MMIO_SIZE);
 
-	EMGD_DEBUG("STMicro sdvo gpio mmadr mapped %dKB @ (phys):0x%lx  (virt):%p",
-		TNC_ST_SDVO_MMIO_SIZE/1024,
-		context->device_context.mmadr_sdvo_st_gpio,
-		context->device_context.virt_mmadr_sdvo_st_gpio);
+		if (!context->device_context.virt_mmadr_sdvo_st_gpio) {
+			EMGD_ERROR_EXIT("Failed to map MMADR");
+			return -IGD_ERROR_NODEV;
+		}
 
+		EMGD_DEBUG("STMicro sdvo gpio mmadr mapped %dKB @ (phys):0x%lx  (virt):%p",
+				TNC_ST_SDVO_MMIO_SIZE/1024,
+				context->device_context.mmadr_sdvo_st_gpio,
+				context->device_context.virt_mmadr_sdvo_st_gpio);
+	}
 
 	/* Map the GPIO BAR. Provides the 64 bytes of I/O space for GPIO
 	 * BAR is defined by bits 15:6 */
@@ -600,3 +576,47 @@ void full_shutdown_tnc(igd_context_t *context)
 	}
 	EMGD_TRACE_EXIT;
 }
+
+
+ int query_2d_caps_hwhint_tnc(
+  	         igd_context_t *context,
+  	         unsigned long caps_val,
+  	         unsigned long *status)
+{
+	platform_context_tnc_t *platform_context;
+
+	EMGD_TRACE_ENTER;
+
+
+	platform_context = (platform_context_tnc_t *)context->platform_context;
+
+	/*
+	* Only 2D BLT capability query is currently implemented.
+	* This is required by TNC B0 flickering workaround.
+	* Query for other 2D capability can be implemented
+	* in the future if neeeded.
+	*/
+	switch (caps_val) {
+		case IGD_2D_CAPS_BLT:
+			if((context->device_context.did == PCI_DEVICE_ID_VGA_TNC) &&
+				(context->device_context.rid == TNC_B0_RID) &&
+				(platform_context->tnc_dev3_rid == TNC_B0_DEV3_RID)) {
+					*status = IGD_2D_HW_DISABLE;
+					/* disable 2d blt hardware acceleration for TNC B0 */
+			} else {
+					*status = IGD_2D_HW_ENABLE;
+					/* enable 2d blt hardware acceleration */
+			}
+		break;
+
+		default:
+			*status = IGD_2D_CAPS_UNKNOWN;
+			/* Unknown 2d capability to query */
+			EMGD_ERROR("2D caps to query is unknown!");
+		break;
+	}
+
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+
diff --git a/drivers/gpu/drm/emgd/emgd/core/init/tnc/micro_init_tnc.c b/drivers/gpu/drm/emgd/emgd/core/init/tnc/micro_init_tnc.c
index f101327..ea3f85c 100644
--- a/drivers/gpu/drm/emgd/emgd/core/init/tnc/micro_init_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/core/init/tnc/micro_init_tnc.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: micro_init_tnc.c
- * $Revision: 1.21 $
+ * $Revision: 1.24 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -101,11 +101,16 @@ extern unsigned short io_base_sdvo_st_gpio;
 
 extern int full_config_tnc(igd_context_t *context,
 	init_dispatch_t *dispatch);
-extern int get_revision_id_tnc(igd_context_t *context, os_pci_dev_t vga_dev);
+extern int get_revision_id_tnc(igd_context_t *context, os_pci_dev_t vga_dev, os_pci_dev_t sdvo_dev);
 extern int full_get_param_tnc(igd_context_t *context, unsigned long id,
 	unsigned long *value);
 extern void full_shutdown_tnc(igd_context_t *context);
 
+extern int query_2d_caps_hwhint_tnc(
+  	         igd_context_t *context,
+  	         unsigned long caps_val,
+  	         unsigned long *status);
+
 static int query_tnc(igd_context_t *context,init_dispatch_t *dispatch,
 	os_pci_dev_t vga_dev, unsigned int *bus, unsigned int *slot,
 	unsigned int *func);
@@ -136,7 +141,8 @@ init_dispatch_t init_dispatch_tnc = {
 	config_tnc,
 	set_param_tnc,
 	get_param_tnc,
-	shutdown_tnc
+	shutdown_tnc,
+	query_2d_caps_hwhint_tnc
 };
 
 /* Array to keep the Bridge ID. Atom E6xx ULP uses a different bridge ID */
@@ -466,11 +472,11 @@ static int query_tnc(
 				(os_pci_dev_t)0);
 		if(platform_context->bridgedev){
 			bridge_dev = platform_context->bridgedev;
-  	        context->device_context.bid = bridge_id[i];
-  	        break;
+	        context->device_context.bid = bridge_id[i];
+	        break;
 		}
-  	 	i++;
-  	 }
+		i++;
+	 }
 	/*
 	 * Current specs indicate that Atom E6xx has only one PCI function.
 	 * If this changes then we need to make sure we have func 0
@@ -493,13 +499,29 @@ static int query_tnc(
 			1,
 			(os_pci_dev_t)0);
 
-	platform_context->stgpiodev = OS_PCI_FIND_DEVICE(PCI_VENDOR_ID_STMICRO,
+	if (platform_context->stbridgedev) {
+		platform_context->stgpiodev = OS_PCI_FIND_DEVICE(PCI_VENDOR_ID_STMICRO,
 			PCI_DEVICE_ID_SDVO_TNC_ST_GPIO,
-			4,
+			3,
+			0,
 			0,
-			5,
 			(os_pci_dev_t)0);
 
+		if (!platform_context->stgpiodev) {
+			platform_context->stgpiodev = OS_PCI_FIND_DEVICE(PCI_VENDOR_ID_STMICRO,
+				PCI_DEVICE_ID_SDVO_TNC_ST_GPIO,
+				4,
+				0,
+				5,
+				(os_pci_dev_t)0);
+			if (!platform_context->stgpiodev) {
+				printk("Using STM device, but is not CUT1 or CUT2\n");
+				EMGD_ERROR_EXIT("Using STM device, but is not Cut1 or Cut2");
+				return -IGD_ERROR_NODEV;
+			}
+		}
+	}
+
 	/* Set to NULL, so full_shutdown_tnc() knows whether it was initialized: */
 	platform_context->lpc_dev = NULL;
 
@@ -509,7 +531,7 @@ static int query_tnc(
 	 */
 	OS_PCI_GET_SLOT_ADDRESS(vga_dev, bus, slot, func);
 
-	OPT_MICRO_CALL(get_revision_id_tnc(context, vga_dev));
+	get_revision_id_tnc(context, vga_dev, platform_context->pcidev1);
 
 	/*
 	 * Read BSM.
@@ -685,12 +707,12 @@ static int config_tnc(igd_context_t *context,
 	 * GVD.H_HP Control register's BIT1 is set 1.
 	 * TODO: Removed this after this is fix in system BIOS.
 	 */
- 	lp_ctrl_reg = EMGD_READ32(EMGD_MMIO(context->device_context.virt_mmadr) + 0x20f4);
+	lp_ctrl_reg = EMGD_READ32(EMGD_MMIO(context->device_context.virt_mmadr) + 0x20f4);
 	lp_ctrl_reg |= BIT1;
 	lp_ctrl_reg &= ~(BIT2 | BIT3);
     EMGD_WRITE32(lp_ctrl_reg, EMGD_MMIO(context->device_context.virt_mmadr) + 0x20f4);
 
- 	hp_ctrl_reg = EMGD_READ32(EMGD_MMIO(context->device_context.virt_mmadr) + 0x20f8);
+	hp_ctrl_reg = EMGD_READ32(EMGD_MMIO(context->device_context.virt_mmadr) + 0x20f8);
 	hp_ctrl_reg |= BIT1;
     EMGD_WRITE32(hp_ctrl_reg, EMGD_MMIO(context->device_context.virt_mmadr) + 0x20f8);
 
@@ -699,7 +721,7 @@ static int config_tnc(igd_context_t *context,
 	 * Tested with Punit B0_500309_CFG2 and Punit C0_060510_CFG2 in BIOS39 and
 	 * BIOS41 or above.
 	 */
- 	ved_cg_dis_reg = EMGD_READ32(EMGD_MMIO(context->device_context.virt_mmadr) + 0x2064);
+	ved_cg_dis_reg = EMGD_READ32(EMGD_MMIO(context->device_context.virt_mmadr) + 0x2064);
 	ved_cg_dis_reg |= (BIT16 | BIT8 | 0xFF);
     EMGD_WRITE32(ved_cg_dis_reg, EMGD_MMIO(context->device_context.virt_mmadr) + 0x2064);
 
@@ -928,4 +950,43 @@ static void shutdown_tnc(igd_context_t *context)
 	OPT_MICRO_VOID_CALL(full_shutdown_tnc(context));
 }
 
+
+/*!
+ *
+ * @param context
+ * @param dispatch
+ * @param vga_dev
+ *
+ * @return -IGD_ERROR_NODEV on failure
+ * @return 0 on success
+ */
+int get_revision_id_tnc(igd_context_t *context,
+	os_pci_dev_t vga_dev,
+	os_pci_dev_t sdvo_dev)
+{
+	platform_context_tnc_t *platform_context;
+
+	EMGD_TRACE_ENTER;
+
+	platform_context = (platform_context_tnc_t *)context->platform_context;
+
+	/* Read RID */
+	if(OS_PCI_READ_CONFIG_8(vga_dev, PCI_RID,
+		(unsigned char *)&context->device_context.rid)) {
+		EMGD_ERROR_EXIT("Error occured reading RID");
+		return -IGD_ERROR_NODEV;
+	}
+
+	if(OS_PCI_READ_CONFIG_8(sdvo_dev, PCI_RID,
+		&platform_context->tnc_dev3_rid)) {
+		EMGD_ERROR_EXIT("Error occured reading TNC SDVO RID");
+		return -IGD_ERROR_NODEV;
+	}
+
+	EMGD_DEBUG(" rid = 0x%lx", context->device_context.rid);
+
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+
 #endif
diff --git a/drivers/gpu/drm/emgd/emgd/display/dsp/cmn/dsp.c b/drivers/gpu/drm/emgd/emgd/display/dsp/cmn/dsp.c
index ddd29bd..df62dd7 100644
--- a/drivers/gpu/drm/emgd/emgd/display/dsp/cmn/dsp.c
+++ b/drivers/gpu/drm/emgd/emgd/display/dsp/cmn/dsp.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: dsp.c
- * $Revision: 1.19 $
+ * $Revision: 1.25 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -623,7 +623,7 @@ static void dsp_get_display(unsigned short port_number,
 		}
 	}
 	if(display) {
-		*display = dsp_context.display_ptr_list[port_number];
+	  *display = dsp_context.display_ptr_list[port_number];
 	}
 	return;
 }
@@ -717,6 +717,18 @@ static void dsp_get_planes_pipes(igd_plane_t **primary_display_plane,
 	EMGD_TRACE_EXIT;
 }
 
+static void dsp_control_plane_format(int enable, int display_plane, igd_plane_t *plane_override)
+{
+	EMGD_TRACE_ENTER;
+
+	dsp_context.dispatch->dsp_control_plane_format(dsp_context.context,
+			enable, display_plane, plane_override);
+
+	dsp_context.context->mod_dispatch.fb_blend_ovl_override = 1;
+
+	EMGD_TRACE_EXIT;
+}
+
 /*!
  * Check port features of multiple ports to see if they can share a pipe.
  * Ports that are passed in as NULL are not considered.  There must be
@@ -1357,6 +1369,7 @@ int igd_query_dc(igd_driver_h driver_handle,
 				return 0;
 			}
 		}
+
 		/* Find first match of same type */
 		for(d = 0; d < dsp_context.dsp_dc_list.count; d++) {
 			if (dsp_context.dsp_dc_list.dc_list[d] & (request & 0x0f)) {
@@ -1471,6 +1484,8 @@ int dsp_alloc(igd_context_t *context,
 	int ret;
 #endif
 
+	EMGD_TRACE_ENTER;
+
 #ifndef CONFIG_MICRO
 	/*
 	 * Surfaces in the surface cache have a display handle associated with
@@ -1576,15 +1591,6 @@ int dsp_alloc(igd_context_t *context,
 		}
 		pipe->inuse = 0;
 
-#ifndef CONFIG_MICRO
-		if(context->mod_dispatch.alloc_queues) {
-			ret = context->mod_dispatch.alloc_queues(context, pipe, flags);
-			if (ret) {
-				EMGD_ERROR("Error, unable to allocate ring buffers");
-				return -IGD_INVAL;
-			}
-		}
-#endif
 
 		/* set up the display handle */
 		dsp_context.display_list[0].plane = (void *)plane;
@@ -1704,11 +1710,10 @@ int dsp_alloc(igd_context_t *context,
 		cursor2->cursor_info = cursor->cursor_info;
 
 	case IGD_DISPLAY_CONFIG_EXTENDED:
-		if (plane2) {
 
-#ifndef CONFIG_MICRO
-			/* This condition is always true, not sure why this check is
-			 * required */
+		if (plane2) {
+			/* Need to check here because the last case, CLONE, falls
+			 * through to this one */
 			if (!(dc & IGD_DISPLAY_CONFIG_CLONE)) {
 				/* If this is really extended and not clone, break mirrors */
 				plane->mirror = NULL;
@@ -1729,7 +1734,6 @@ int dsp_alloc(igd_context_t *context,
 					cursor2->cursor_info = NULL;
 				}
 			}
-#endif
 
 			port_number = IGD_DC_SECONDARY(dc);
 			dsp_context.display_list[1].plane = (void *)plane2;
@@ -1810,6 +1814,7 @@ int dsp_alloc(igd_context_t *context,
 	}
 
 	dsp_context.current_dc = dc;
+	EMGD_TRACE_EXIT;
 	return 0;
 }
 
@@ -1832,7 +1837,7 @@ int dsp_init(igd_context_t *context)
 	igd_param_t   *params = context->mod_dispatch.init_params;
 	int ret;
 
-	EMGD_DEBUG("Enter dsp_init()");
+	EMGD_TRACE_ENTER;
 
 	OS_MEMSET(&dsp_context, 0, sizeof(dsp_context));
 
@@ -1863,7 +1868,8 @@ int dsp_init(igd_context_t *context)
 	context->mod_dispatch.dsp_get_dc = dsp_get_dc;
 	context->mod_dispatch.dsp_get_display = dsp_get_display;
 	context->mod_dispatch.dsp_get_planes_pipes = dsp_get_planes_pipes;
-
+	context->mod_dispatch.dsp_alloc = dsp_alloc;
+	context->mod_dispatch.dsp_control_plane_format = dsp_control_plane_format;
 
 	/* Dsp data members in inter module dispatch. This is done to make
 	 * these data members available for vBIOS after init when dsp is
@@ -2026,6 +2032,7 @@ int dsp_init(igd_context_t *context)
 	 * Build the list of valid display configurations.
 	 */
 	/* dsp_dc_init(context); */
+	EMGD_TRACE_EXIT;
 
 	return 0;
 } /* end dsp_init() */
@@ -2227,23 +2234,23 @@ int dsp_wait_rb(igd_context_t *context)
 					return (-IGD_INVAL);
 				}
 
-                if(PIPE(&dsp_context.display_list[p])->queue[IGD_PRIORITY_BIN]) {
-                	/* Sync the Binner also. */
-                	sync_val = 0;
-                	timeout = OS_SET_ALARM(wait_time * 1000);
-                	do {
-                		ret = context->dispatch.sync(
-							&dsp_context.display_list[p],
-							IGD_PRIORITY_BIN, &sync_val,
-							IGD_SYNC_BLOCK | IGD_SYNC_NOFLUSH_PIPE);
-                		OS_SCHEDULE();
-                	} while ((ret == -IGD_ERROR_BUSY) && (!OS_TEST_ALARM(timeout)));
-
-                	if (ret == -IGD_ERROR_BUSY) {
-                		EMGD_ERROR("Timeout waiting for Binner sync");
-                		return (-IGD_INVAL);
-                	}
-                }
+				if(PIPE(&dsp_context.display_list[p])->queue[IGD_PRIORITY_BIN]) {
+					/* Sync the Binner also. */
+					sync_val = 0;
+					timeout = OS_SET_ALARM(wait_time * 1000);
+					do {
+						ret = context->dispatch.sync(
+								&dsp_context.display_list[p],
+								IGD_PRIORITY_BIN, &sync_val,
+								IGD_SYNC_BLOCK | IGD_SYNC_NOFLUSH_PIPE);
+						OS_SCHEDULE();
+					} while ((ret == -IGD_ERROR_BUSY) && (!OS_TEST_ALARM(timeout)));
+
+					if (ret == -IGD_ERROR_BUSY) {
+						EMGD_ERROR("Timeout waiting for Binner sync");
+						return (-IGD_INVAL);
+					}
+				}
 			}
 		}
 	}
@@ -2263,9 +2270,12 @@ void dsp_shutdown(igd_context_t *context)
 	igd_display_port_t *port = NULL;
 	igd_plane_t *plane = NULL;
 	igd_display_pipe_t *temp_pipe = NULL;
+	unsigned int hal_attr_index = 0;
 
 	EMGD_DEBUG("dsp_shutdown Entry");
 
+	context->mod_dispatch.fb_blend_ovl_override = 0;
+
 	/*
 	 * Free all the ports pt_info's. Need to add this here because there
 	 * is no longer a 1-to-1 relationship between displays and ports.
@@ -2286,14 +2296,22 @@ void dsp_shutdown(igd_context_t *context)
 			OS_FREE(port->attr_list);
 			port->attr_list = NULL;
 		}
+
+		/* We should restore the gamma, brightness and contrast attributes
+		 * to their defaults when the HAL is shutting down or else they
+		 * would retain their previous values.
+		 */
+		while (PD_ATTR_LIST_END != port->attributes[hal_attr_index].id) {
+			port->attributes[hal_attr_index].current_value =
+				port->attributes[hal_attr_index].default_value;
+
+			hal_attr_index++;
+		}
 	}
 
 
 	/* Free pipes, cursors, and any allocated command queues */
 	while ((temp_pipe = dsp_get_next_pipe(context, temp_pipe, 0)) != NULL) {
-		if(context->mod_dispatch.free_queues) {
-			context->mod_dispatch.free_queues(context, temp_pipe);
-		}
 
 		/* probably not needed since shutting down */
 		temp_pipe->inuse = 0;
@@ -2348,9 +2366,3 @@ static int dsp_full_init(igd_context_t *context)
 #endif
 
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: dsp.c,v 1.19 2011/03/02 22:47:04 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/display/dsp/cmn/dsp.c,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/display/dsp/cmn/dsp_dispatch.h b/drivers/gpu/drm/emgd/emgd/display/dsp/cmn/dsp_dispatch.h
index 42372a5..7812416 100644
--- a/drivers/gpu/drm/emgd/emgd/display/dsp/cmn/dsp_dispatch.h
+++ b/drivers/gpu/drm/emgd/emgd/display/dsp/cmn/dsp_dispatch.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: dsp_dispatch.h
- * $Revision: 1.6 $
+ * $Revision: 1.8 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -53,6 +53,9 @@ typedef struct _dsp_dispatch {
 	unsigned long *render_pfs;
 	unsigned long *texture_pfs;
 	int (*dsp_init)(igd_context_t *context);
+	void (*dsp_control_plane_format)(igd_context_t *context,
+			int enable, int display_plane,
+			igd_plane_t *plane_override);
 } dsp_dispatch_t;
 
 extern dsp_dispatch_t dsp_dispatch_plb;
diff --git a/drivers/gpu/drm/emgd/emgd/display/dsp/plb/dsp_plb.c b/drivers/gpu/drm/emgd/emgd/display/dsp/plb/dsp_plb.c
index ec75a09..9330537 100644
--- a/drivers/gpu/drm/emgd/emgd/display/dsp/plb/dsp_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/display/dsp/plb/dsp_plb.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: dsp_plb.c
- * $Revision: 1.6 $
+ * $Revision: 1.8 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -650,6 +650,50 @@ static int dsp_init_plb(igd_context_t *context)
 	return 0;
 }
 
+void dsp_control_plane_format_plb(igd_context_t *context,
+		int enable, int plane, igd_plane_t *plane_override)
+{
+	igd_plane_t * pl = NULL;
+	unsigned char *mmio = EMGD_MMIO(context->device_context.virt_mmadr);
+	unsigned long tmp;
+
+	if (plane_override == NULL) {
+		pl = (plane == 0) ? &planea_plb : &planeb_plb;
+	} else {
+		pl = plane_override;
+	}
+	tmp = EMGD_READ32(mmio +  pl->plane_reg);
+
+	/*
+	 * Pixel format bits (29:26) are in plane control register 0x70180 for
+	 * Plane A and 0x71180 for Plane B
+	 * 0110 = XRGB pixel format
+	 * 0111 = ARGB pixel format
+	 * Note that the plane control register is double buffered and will be
+	 * updated on the next VBLANK operation so there is no need to sync with
+	 * an explicit VSYNC.
+	 */
+	if(enable) {
+		if((tmp & DSPxCNTR_SRC_FMT_MASK) == DSPxCNTR_RGB_8888) {
+			EMGD_WRITE32(tmp | DSPxCNTR_ARGB_8888, mmio +  pl->plane_reg);
+			tmp = EMGD_READ32(mmio + pl->plane_reg + 4);
+			EMGD_WRITE32(tmp, mmio + pl->plane_reg + 4);
+			EMGD_DEBUG("Changed pixel format from XRGB to ARGB\n");
+		}
+	} else {
+		if((tmp & DSPxCNTR_SRC_FMT_MASK) == DSPxCNTR_ARGB_8888) {
+			tmp = tmp & (~(DSPxCNTR_SRC_FMT_MASK));
+			EMGD_WRITE32(tmp | DSPxCNTR_RGB_8888, mmio +  pl->plane_reg);
+			tmp = EMGD_READ32(mmio + pl->plane_reg + 4);
+			EMGD_WRITE32(tmp, mmio + pl->plane_reg + 4);
+			OS_SLEEP(100);
+			EMGD_DEBUG("Changed pixel format from ARGB to XRGB\n");
+		}
+	}
+	EMGD_DEBUG("Plane register 0x%lX has value of 0x%X\n", pl->plane_reg,
+			EMGD_READ32(mmio + pl->plane_reg));
+
+}
 
 dsp_dispatch_t dsp_dispatch_plb = {
 	plane_table_plb, pipe_table_plb, port_table_plb,
@@ -657,7 +701,8 @@ dsp_dispatch_t dsp_dispatch_plb = {
 	OPT_MICRO_VALUE(overlay_pixel_formats_plb, NULL),
 	OPT_MICRO_VALUE(render_pixel_formats_plb, NULL),
 	OPT_MICRO_VALUE(texture_pixel_formats_plb, NULL),
-	dsp_init_plb
+	dsp_init_plb,
+	dsp_control_plane_format_plb,
 };
 
 #endif
diff --git a/drivers/gpu/drm/emgd/emgd/display/dsp/tnc/dsp_tnc.c b/drivers/gpu/drm/emgd/emgd/display/dsp/tnc/dsp_tnc.c
index ba064f4..0697657 100644
--- a/drivers/gpu/drm/emgd/emgd/display/dsp/tnc/dsp_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/display/dsp/tnc/dsp_tnc.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: dsp_tnc.c
- * $Revision: 1.8 $
+ * $Revision: 1.10 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -483,6 +483,51 @@ static int dsp_init_tnc(igd_context_t *context)
 	return 0;
 }
 
+void dsp_control_plane_format_tnc(igd_context_t *context,
+		int enable, int plane, igd_plane_t *plane_override)
+{
+	igd_plane_t * pl = NULL;
+	unsigned char *mmio = EMGD_MMIO(context->device_context.virt_mmadr);
+	unsigned long tmp;
+
+	if (plane_override == NULL) {
+		pl = (plane == 0) ? &planea_tnc : &planeb_tnc;
+	} else {
+		pl = plane_override;
+	}
+	tmp = EMGD_READ32(mmio +  pl->plane_reg);
+	/*
+	 * Pixel format bits (29:26) are in plane control register 0x70180 for
+	 * Plane A and 0x71180 for Plane B
+	 * 0110 = XRGB pixel format
+	 * 0111 = ARGB pixel format
+	 * Note that the plane control register is double buffered and will be
+	 * updated on the next VBLANK operation so there is no need to sync with
+	 * an explicit VSYNC.
+	 */
+	if(enable) {
+		if((tmp & DSPxCNTR_SRC_FMT_MASK) == DSPxCNTR_RGB_8888) {
+			tmp = tmp & (~(DSPxCNTR_SRC_FMT_MASK));
+			EMGD_WRITE32(tmp | DSPxCNTR_ARGB_8888, mmio + pl->plane_reg);
+			EMGD_READ32(mmio + pl->plane_reg);
+			tmp = EMGD_READ32(mmio + pl->plane_reg + 0x1c);
+			EMGD_WRITE32(tmp, mmio + pl->plane_reg + 0x1c);
+			EMGD_DEBUG("Changed pixel format from XRGB to ARGB\n");
+		}
+	} else {
+		if((tmp & DSPxCNTR_SRC_FMT_MASK) == DSPxCNTR_ARGB_8888) {
+			tmp = tmp & (~(DSPxCNTR_SRC_FMT_MASK));
+			EMGD_WRITE32(tmp | DSPxCNTR_RGB_8888, mmio +  pl->plane_reg);
+			EMGD_READ32(mmio + pl->plane_reg);
+			tmp = EMGD_READ32(mmio + pl->plane_reg + 0x1c);
+			EMGD_WRITE32(tmp, mmio + pl->plane_reg + 0x1c);
+			OS_SLEEP(100);
+			EMGD_DEBUG("Changed pixel format from ARGB to XRGB\n");
+		}
+	}
+	EMGD_DEBUG("Plane register 0x%lX has value of 0x%X\n", pl->plane_reg,
+			EMGD_READ32(mmio + pl->plane_reg));
+}
 
 dsp_dispatch_t dsp_dispatch_tnc = {
 	plane_table_tnc, pipe_table_tnc, port_table_tnc,
@@ -490,7 +535,8 @@ dsp_dispatch_t dsp_dispatch_tnc = {
 	OPT_MICRO_VALUE(overlay_pixel_formats_tnc, NULL),
 	OPT_MICRO_VALUE(render_pixel_formats_tnc, NULL),
 	OPT_MICRO_VALUE(texture_pixel_formats_tnc, NULL),
-	dsp_init_tnc
+	dsp_init_tnc,
+	dsp_control_plane_format_tnc,
 };
 
 #endif
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/igd_mode.c b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/igd_mode.c
index 9d0d659..9a4b062 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/igd_mode.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/igd_mode.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_mode.c
- * $Revision: 1.26 $
+ * $Revision: 1.32 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -61,6 +61,8 @@
 #include <utils.h>
 #include <general.h>
 
+#include "emgd_drv.h"
+#include "drm_emgd_private.h"
 #include "match.h"
 #include "mode_dispatch.h"
 
@@ -102,9 +104,14 @@ void igd_fb_to_screen(unsigned short rotation,
 					unsigned short *x, unsigned short *y,
 					unsigned short hotx, unsigned short hoty);
 
+int igd_kms_match_mode(void *emgd_encoder,
+	void *fb_info, igd_timing_info_h **timing);
+
 /* Do not malloc the context */
 extern mode_context_t mode_context[];
 
+extern emgd_drm_config_t config_drm;
+
 /* This symbol has to be in this file as it is part of
  *  driver ONLY.
  */
@@ -129,6 +136,7 @@ int set_color_correct(igd_display_context_t *display,
 	mode_dispatch_t       *dispatch = mode_context->dispatch;
 	igd_range_attr_t      *attr     = NULL;
 	unsigned int          i         = 0;
+	int  				  changed_flag_set = 1;
 
 	EMGD_TRACE_ENTER;
 
@@ -141,6 +149,9 @@ int set_color_correct(igd_display_context_t *display,
 		if (attr_to_set->id == hal_attr_list[i].id) {
 			attr = (igd_range_attr_t *) &hal_attr_list[i];
 
+			if (!(attr_to_set->flags & PD_ATTR_FLAG_VALUE_CHANGED)){
+				changed_flag_set = 0;
+			}
 			/* make sure the value is within range */
 			attr->current_value = OS_MAX(attr_to_set->current_value,
 									attr->min);
@@ -165,8 +176,10 @@ int set_color_correct(igd_display_context_t *display,
 	}
 
 	/* Program palette */
-	dispatch = mode_context->dispatch;
-	dispatch->full->set_color_correct(display);
+	if(changed_flag_set){
+		dispatch = mode_context->dispatch;
+		dispatch->full->set_color_correct(display);
+	}
 
 	EMGD_TRACE_EXIT;
 	return 0;
@@ -185,39 +198,28 @@ int set_color_correct(igd_display_context_t *display,
 int mode_pwr(igd_context_t *context,
 	unsigned long powerstate)
 {
+
 	igd_display_context_t *display_list[2];
 	igd_display_context_t *display = NULL;
 	int i,j;
 
 	EMGD_TRACE_ENTER;
 
-	context->mod_dispatch.dsp_get_dc(NULL, &display_list[0],
-		&display_list[1]);
-
-	for(j = 0; j < 2; j++) {
-		display = display_list[j];
-		/* if there is no display or display not allocated, continue */
-		if(!display || !display->allocated) {
-			continue;
-		}
+	switch(powerstate) {
+	case IGD_POWERSTATE_D0:
+		for(j = 0; j < 2; j++) {
+			display = display_list[j];
+			/* if there is no display or display not allocated, continue */
+			if(!display || !display->allocated) {
+				continue;
+			}
 
-		switch(powerstate) {
-		case IGD_POWERSTATE_D0:
 			if (!PIPE(display)->timing) {
 				/* if there is no pipe timing, cannot enable, continue */
-				EMGD_DEBUG("No pipe timing for port = %lu", display->port_number);
+				EMGD_DEBUG("No pipe timing for port = %lu",
+							display->port_number);
 				continue;
 			}
-			/* Enable command queues */
-			if(context->mod_dispatch.cmd_control) {
-				for (i = 0; i < IGD_MAX_PIPE_QUEUES; i++) {
-					if (PIPE(display)->queue[i]) {
-						EMGD_DEBUG("Enabling command queue [%d]", i);
-						context->mod_dispatch.cmd_control(
-							PIPE(display)->queue[i], CMD_CONTROL_ON);
-					}
-				}
-			}
 
 			/* Set port power state */
 			for (i = 0; i < IGD_MAX_PORTS; i++) {
@@ -227,8 +229,10 @@ int mode_pwr(igd_context_t *context,
 					mode_context->dispatch->program_port(display, i+1, TRUE);
 				}
 			}
+
 			mode_context->dispatch->program_pipe(display, TRUE);
 			mode_context->dispatch->program_plane(display, TRUE);
+
 			for (i = 0; i < IGD_MAX_PORTS; i++) {
 				if (display->port[i] &&
 					(((igd_display_port_t *)display->port[i])->pt_info->flags &
@@ -236,35 +240,17 @@ int mode_pwr(igd_context_t *context,
 					mode_context->dispatch->post_program_port(display, i+1, 0);
 				}
 			}
-			break;
-		case IGD_POWERSTATE_D1:
-		case IGD_POWERSTATE_D2:
-		case IGD_POWERSTATE_D3:
-			/* Set port power state */
-			for (i = 0; i < IGD_MAX_PORTS; i++) {
-				if (display->port[i] &&
-					(((igd_display_port_t *)display->port[i])->pt_info->flags &
-						IGD_DISPLAY_ENABLE)) {
-					mode_context->dispatch->program_port(display, i+1, TRUE);
-				}
-			}
-			mode_context->dispatch->program_plane(display, TRUE);
-			mode_context->dispatch->program_pipe(display, TRUE);
 
-			/* Disable command queues */
-			if(context->mod_dispatch.cmd_control) {
-				for (i = 0; i < IGD_MAX_PIPE_QUEUES; i++) {
-					if (PIPE(display)->queue[i]) {
-						EMGD_DEBUG("Disabling command queue [%d]", i);
-						context->mod_dispatch.cmd_control(
-							PIPE(display)->queue[i], CMD_CONTROL_OFF);
-					}
-				}
-			}
-			break;
-		default:
-			break;
 		}
+
+		break;
+	case IGD_POWERSTATE_D1:
+	case IGD_POWERSTATE_D2:
+	case IGD_POWERSTATE_D3:
+		mode_context->dispatch->reset_plane_pipe_ports(mode_context->context);
+		break;
+	default:
+		break;
 	}
 
 	EMGD_TRACE_EXIT;
@@ -658,12 +644,14 @@ int igd_alter_cursor(igd_display_h display_handle,
 	unsigned long cursor_state2;
 	unsigned long *cursora = NULL;
 	unsigned char *cursorx = NULL;
+//	unsigned long in_dihclone=0;
 
 	EMGD_TRACE_ENTER;
 
 	EMGD_ASSERT(display, "Null Display Handle", -IGD_ERROR_INVAL);
 	EMGD_ASSERT(cursor_info, "Null cursor info", -IGD_ERROR_INVAL);
 
+//	in_dihclone = display->context->mod_dispatch.in_dih_clone_mode;
 	if(validate_cursor(cursor_info, display)) {
 		EMGD_ERROR_EXIT("pixel_format validation failed.");
 		return -IGD_ERROR_INVAL;
@@ -681,7 +669,8 @@ int igd_alter_cursor(igd_display_h display_handle,
 	display->context->mod_dispatch.dsp_get_dc(NULL, &primary, NULL);
 
 	/* If cursor plane is mirrored, then do the same for the other cursor */
-	if (PIPE(display)->cursor->mirror != NULL) {
+//	if (PIPE(display)->cursor->mirror != NULL || in_dihclone) {
+	if (PIPE(display)->cursor->mirror != NULL ) {
 		if(display == primary) {
 			display->context->mod_dispatch.dsp_get_dc(NULL, NULL,
 				&display2);
@@ -704,15 +693,6 @@ int igd_alter_cursor(igd_display_h display_handle,
 	 */
 
 	if ((image != NULL) && (cursor_info->flags & IGD_CURSOR_LOAD_ARGB_IMAGE)) {
-#ifdef PRE_KOHEO_CODE
-		cursora = (unsigned long *)OS_GART_MAP(0, internal_ci->argb_offset,
-			0, display->context->device_context.virt_fb_adr);
-
-		if(!cursora){
-			cursora = (unsigned long *)(internal_ci->argb_offset +
-			display->context->device_context.virt_fb_adr);
-		}
-#else /* PRE_KOHEO_CODE */
 		unsigned long buffer_phys = 0;
 
 		/* Calculate the cursor's address in kernel-space: */
@@ -733,17 +713,12 @@ int igd_alter_cursor(igd_display_h display_handle,
 			return -IGD_ERROR_INVAL;
 		}
 
-#endif /* PRE_KOHEO_CODE */
 		/* Clear cursor plane */
 		OS_MEMSET(cursora, 0, 64*64*4);
 
 	} else if ((image != NULL) &&
 		(cursor_info->flags & IGD_CURSOR_LOAD_XOR_IMAGE)) {
 
-#ifdef PRE_KOHEO_CODE
-		cursorx = (unsigned char *)(internal_ci->xor_offset +
-			display->context->device_context.virt_fb_adr);
-#else /* PRE_KOHEO_CODE */
 		unsigned long buffer_phys = 0;
 
 		/* Calculate the cursor's address in kernel-space: */
@@ -763,7 +738,6 @@ int igd_alter_cursor(igd_display_h display_handle,
 			EMGD_ERROR_EXIT("Physical to Virtual Address translation failed");
 			return -IGD_ERROR_INVAL;
 		}
-#endif /* PRE_KOHEO_CODE */
 	}
 
 	/* calculate the cursor position adjusting to new hotspot */
@@ -799,7 +773,8 @@ int igd_alter_cursor(igd_display_h display_handle,
 		mode_context->dispatch->full->program_cursor(display, FALSE);
 	}
 
-	if (PIPE(display)->cursor->mirror) {
+//	if (PIPE(display)->cursor->mirror || (in_dihclone && display == primary) ) {
+	if (PIPE(display)->cursor->mirror ) {
 		igd_set_cursor_pos(display2,
 			(unsigned short)cursor_info->x_offset,
 			(unsigned short)cursor_info->y_offset,
@@ -852,15 +827,23 @@ int igd_alter_cursor_pos(igd_display_h display_handle,
 {
 	igd_display_context_t *display = (igd_display_context_t *) display_handle;
 	igd_display_context_t *display2 = NULL;
+//	igd_display_context_t * primary= NULL;
 	igd_cursor_info_t *internal_ci;
 	unsigned long cursor_on_screen;
 	unsigned long cursor_state=0;
+//	unsigned long in_dihclone=0;
 
 	/* If there is no cursor, return immediately */
 	if (!display || !PIPE(display) || !PIPE(display)->cursor) {
 		return -IGD_INVAL;
 	}
 
+//	in_dihclone = display->context->mod_dispatch.in_dih_clone_mode;
+
+//	display->context->mod_dispatch.dsp_get_dc(NULL, &primary, NULL);
+
+
+//	if (PIPE(display)->cursor->mirror != NULL || ( in_dihclone && display == primary )) {
 	if (PIPE(display)->cursor->mirror != NULL) {
 		display->context->mod_dispatch.dsp_get_dc(NULL, NULL, &display2);
 		if (display == display2) {
@@ -870,7 +853,6 @@ int igd_alter_cursor_pos(igd_display_h display_handle,
 			cursor_state = CURSOR_1_STATE;
 		}
 	}
-
 	/* Reset display2 if cursor isn't setup */
 	if (display2) {
 		if (!PIPE(display2) || !PIPE(display2)->cursor) {
@@ -1039,11 +1021,10 @@ long igd_pan_display(igd_display_h hDisplay,
 	}
 
 	/*
-	address HSD 200474  (08/27/2008
-	handle case primary: 1280x720  seconday:1024x768
-	TODO (Chandra idea)
-	"ideally the FB 720 height should center on LVDS 768 height and pan across horizontally that is 1280 FB width pans on LVDS 1024 width."
-	*/
+	 * handle case primary: 1280x720  seconday:1024x768
+	 * TODO:
+	 * "ideally the FB 720 height should center on LVDS 768 height and pan across horizontally that is 1280 FB width pans on LVDS 1024 width."
+	 */
 	if (fb_info->height >= pt_info->height) {
 		if (pt_info->width + x_offset > fb_info->width ||
 			pt_info->height + y_offset > fb_info->height) {
@@ -1701,10 +1682,15 @@ int full_mode_query(igd_driver_h driver_handle,
 	igd_timing_info_t *xt;
 	int timings = 0;
 
+	EMGD_TRACE_ENTER;
+
+	EMGD_DEBUG("Looking up timings for port: %ld", port->port_number);
+
 	/* determine the size of the mode list including the extensions */
 	tt = port->timing_table;
 	if (!tt) {
 		EMGD_ERROR("igd_query_mode_list:  No Timings");
+		EMGD_TRACE_EXIT;
 		return -IGD_ERROR_INVAL;
 	}
 	while (tt->width != IGD_TIMING_TABLE_END) {
@@ -1715,6 +1701,7 @@ int full_mode_query(igd_driver_h driver_handle,
 		 */
 		if (tt->mode_info_flags & PD_MODE_SUPPORTED) {
 			timings++;
+			EMGD_DEBUG("Adding timing: (%dx%d)", tt->width, tt->height);
 		}
 		tt++;
 
@@ -1752,8 +1739,10 @@ int full_mode_query(igd_driver_h driver_handle,
 		OS_MEMCPY(xt, tt, sizeof(igd_timing_info_t));
 	} else {
 		EMGD_ERROR("igd_query_mode_list: Memory allocation failure.");
+		EMGD_TRACE_EXIT;
 		return -IGD_ERROR_INVAL;
 	}
+	EMGD_TRACE_EXIT;
 	return 0;
 }
 
@@ -1771,6 +1760,7 @@ static void mode_shutdown(igd_context_t *context)
 	inter_module_dispatch_t *md;
 	module_state_h *mode_state = NULL;
 	unsigned long *flags = NULL;
+	reg_state_id_t id;
 
 	EMGD_DEBUG("mode_shutdown Entry");
 
@@ -1794,7 +1784,12 @@ static void mode_shutdown(igd_context_t *context)
 
 	/* Restore mode state */
 	md = &context->mod_dispatch;
-	md->reg_get_mod_state(REG_MODE_STATE, &mode_state, &flags);
+	if (config_drm.init) {
+		id = REG_MODE_STATE_CON;
+	} else {
+		id = REG_MODE_STATE_REG;
+	}
+	md->reg_get_mod_state(id, &mode_state, &flags);
 	mode_restore(context, mode_state, flags);
 
 	/* Shutdown PI module */
@@ -1855,6 +1850,7 @@ int full_mode_init(igd_context_t *context,
 	context->mod_dispatch.get_refresh_in_border =
 		mode_context->dispatch->get_refresh_in_border;
 
+
 	/* Hook up Core specific IGD dispatch table entries */
 	dispatch->set_palette_entry = mode_context->dispatch->set_palette_entry;
 	dispatch->get_scanline = mode_context->dispatch->full->get_scanline;
@@ -2194,8 +2190,30 @@ int query_seamless(unsigned long dc,
 	return ret;
 } /* end of query_seamless */
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: igd_mode.c,v 1.26 2011/03/02 23:01:46 astead Exp $
- *----------------------------------------------------------------------------
+
+/*!
+ * Takes inter-module function calls and calls mode-specific
+ * kms_match_mode.
+ *
+ * @param emgd_encoder
+ * @param fb_info
+ * @param timing
+ *
+ * @return -IGD_ERROR_INVAL on failure
+ * @return 0 on success
  */
+int igd_kms_match_mode(void *emgd_encoder,
+    void *fb_info,
+	igd_timing_info_h **timing)
+{
+	int ret;
+
+	EMGD_TRACE_ENTER;
+
+	ret = kms_match_mode((emgd_encoder_t *)emgd_encoder,
+		(igd_framebuffer_info_t *)fb_info,
+		(igd_timing_info_t **)timing);
+
+	EMGD_TRACE_EXIT;
+	return ret;
+}
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/match.c b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/match.c
index 05f838e..4db71aa 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/match.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/match.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: match.c
- * $Revision: 1.10 $
+ * $Revision: 1.12 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -50,6 +50,18 @@
 
 #include "match.h"
 
+
+#define MATCH_MOD(x)  ((x>0)?x:-x)
+#define MATCH_EXACT    0x01
+#define MATCH_NATIVE   0x02
+#define MATCH_CENTER   0x10
+#define MATCH_FOR_VGA  0x20
+
+extern igd_timing_info_t vga_timing_table[];
+extern igd_timing_info_t crt_timing_table[];
+static igd_timing_info_t scaled_timing[IGD_MAX_PIPES];
+
+
 /*!
  * @addtogroup display_group
  * @{
@@ -127,22 +139,11 @@ static void fill_pt(
 	return;
 }
 
-#ifndef CONFIG_NEW_MATCH
-
-
-extern igd_timing_info_t vga_timing_table[];
-extern igd_timing_info_t crt_timing_table[];
-
 
-#define MATCH_MOD(x)  ((x>0)?x:-x)
-#define MATCH_EXACT    0x01
-#define MATCH_NATIVE   0x02
-#define MATCH_CENTER   0x10
-#define MATCH_FOR_VGA  0x20
 
 /*!
  *
- * @param display
+ * @param emgd_encoder
  * @param timing_table
  * @param pt_info
  * @param type
@@ -150,26 +151,33 @@ extern igd_timing_info_t crt_timing_table[];
  * @return NULL on failure
  * @return timing on success
  */
-static igd_timing_info_t *match_resolution(
-		igd_display_context_t *display,
+igd_timing_info_t *kms_match_resolution(
+		emgd_encoder_t *emgd_encoder,
 		igd_timing_info_t *timing_table,
 		igd_display_info_t *pt_info,
 		int type)
 {
-	igd_timing_info_t *timing;
-	igd_timing_info_t *match;
-	igd_timing_info_t *native_match = NULL;
-	igd_display_port_t *port;
+	struct drm_device  *dev          = NULL;
+	igd_timing_info_t  *timing       = NULL;
+	igd_timing_info_t  *match        = NULL;
+	igd_timing_info_t  *native_match = NULL;
+	struct drm_encoder *encoder      = NULL;
+	igd_display_port_t *port         = NULL;
+	struct drm_crtc    *crtc         = NULL;
+	emgd_crtc_t        *emgd_crtc    = NULL;
+	igd_display_pipe_t *pipe         = NULL;
 
-	EMGD_DEBUG("Enter match_resolution");
+	EMGD_TRACE_ENTER;
 
 	EMGD_DEBUG("Width=%d, height=%d, refresh=%d mode_number=0x%x",
 		pt_info->width, pt_info->height, pt_info->refresh,
 		pt_info->mode_number);
 
+	encoder = &emgd_encoder->base;
+	dev = encoder->dev;
 	timing = timing_table;
+	port = emgd_encoder->igd_port;
 	match = NULL;
-	port = PORT_OWNER(display);
 
 	/*
 	 * Note on Native matching.
@@ -194,8 +202,15 @@ static igd_timing_info_t *match_resolution(
 		}
 		if((pt_info->flags & IGD_MODE_VESA) &&
 			(pt_info->mode_number <= 0x13)) {
-			if(PIPE(display)->timing) {
-				native_match = PIPE(display)->timing;
+
+			list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+				if (crtc == encoder->crtc) {
+					emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+					pipe = emgd_crtc->igd_pipe;
+					if(pipe->timing) {
+						native_match = pipe->timing;
+					}
+				}
 			}
 		}
 	}
@@ -371,36 +386,16 @@ static igd_timing_info_t *match_resolution(
 	return match;
 } /* end match_resolution */
 
-static igd_timing_info_t scaled_timing[IGD_MAX_PIPES];
+
 
 /*!
  * Match the fb and pt structures to a Mode Structure from the table.
  * When a mode is found update the input structures to reflect the
  * values found.
  *
- * Notes:
- *  Match mode has several options for what it can do. Foremost it should
- * attempt to find a mode matching the requested one from the timing table
- * provided. If the mode requested is not in the list this means one of
- * two things.
- *   1) The IAL is calling without checking modes. It is just passing down
- *  something that a user asked for. This is ok but we need to be safe so
- *  we return the next smaller mode with the same aspect ratio.
- *
- *   2) The IAL is requesting a very common "required" mode even though the
- *  port doesn't support it. In this case it should be in the static common
- *  modes table and can be centered in the next larger timings in the
- *  mode table.
- *
- * If the Frambuffer is smaller than the timings requested a fake set of
- * centered timings is returned to program the pipe.
- *
- * In the case of VGA modes. If the mode is in the mode table everything is
- * fine and we just return that. If it is not in the table we find the next
- * larger suitable mode and prepare to center in that mode. Using the static
- * timings from the VGA table as the VGA mode. We do not need to generate
- * a fake set of timings because VGA will center itself automatically in
- * hardware.
+ * If the frambuffer is smaller than the timings requested, then we
+ * modify the timings so that the framebuffer will be centered.  That is,
+ * unless we are asked to upscale the framebuffer to fit the timings requested.
  *
  * In the case of LVDS both centering and scaling can happen. If the mode
  * is in the list it will be scaled to the Native Timings. If the mode
@@ -413,36 +408,51 @@ static igd_timing_info_t scaled_timing[IGD_MAX_PIPES];
  * first extension pointer will contain the scalable timings and the
  * second will contain the centering timings. The static "scaled_timings"
  * data structure will be used when the scaled timings need to be
- * created on the fly due to a Framebuffer that is smaller than the
+ * created on the fly due to a framebuffer that is smaller than the
  * timings.
  *
- * @param display
- * @param timing_table
- * @param fb_info
- * @param pt_info
- * @param timing
+ * FIXME: There is a lot of mentioning of VGA modes in this function from
+ * an earlier implementation of this feature.  The VGA-related code may
+ * not be relevant anymore if we are not building the VBIOS.
+ *
+ * @param emgd_encoder [IN]  Encoder expected to have a mode change
+ * @param fb_info      [IN]  Dimension of the FB to be displayed
+ * @param timing       [OUT] Best matched timing
  *
  * @return -IGD_ERROR_INVAL on failure
  * @return 0 on success
  */
-int match_mode (
-	igd_display_context_t *display,
-	igd_timing_info_t *timing_table,
+int kms_match_mode (
+	emgd_encoder_t *emgd_encoder,
 	igd_framebuffer_info_t *fb_info,
-	igd_display_info_t *pt_info,
 	igd_timing_info_t **timing)
 {
-	igd_timing_info_t *exact_timing = NULL;
-	igd_timing_info_t *pipe_timing = NULL;
-	igd_timing_info_t *user_timing = NULL;
-	igd_timing_info_t *native_timing = NULL;
-	igd_timing_info_t *vga_timing = NULL;
-	igd_timing_info_t *vesa_timing = NULL;
-	short cntr_dff_w = 0;
-	short cntr_dff_h = 0;
-	unsigned long upscale = 0;
+	struct drm_device  *dev;
+	struct drm_encoder *encoder;
+	igd_display_port_t *port;
+	igd_timing_info_t  *timing_table;
+	igd_timing_info_t  *exact_timing  = NULL;
+	igd_timing_info_t  *pipe_timing   = NULL;
+	igd_timing_info_t  *user_timing   = NULL;
+	igd_timing_info_t  *native_timing = NULL;
+	igd_timing_info_t  *vga_timing    = NULL;
+	igd_timing_info_t  *vesa_timing   = NULL;
+	igd_display_info_t *pt_info       = NULL;
+	struct drm_crtc    *crtc          = NULL;
+	emgd_crtc_t        *emgd_crtc     = NULL;
+	igd_display_pipe_t *pipe          = NULL;
+	short               cntr_dff_w    = 0;
+	short               cntr_dff_h    = 0;
+	unsigned long       upscale       = 0;
 
-	EMGD_DEBUG("Enter Match Mode");
+	EMGD_TRACE_ENTER;
+
+
+	encoder      = &emgd_encoder->base;
+	dev          = encoder->dev;
+	port         = emgd_encoder->igd_port;
+	pt_info      = port->pt_info;
+	timing_table = port->timing_table;
 
 	if(!pt_info) {
 		EMGD_ERROR("NULL Port info detected, returning");
@@ -453,13 +463,14 @@ int match_mode (
 	if (!(pt_info->flags & IGD_MODE_VESA) &&
 		(pt_info->width == 0) && (pt_info->height == 0)) {
 		EMGD_DEBUG("Display Info width, height are zero, using default case");
-		pt_info->width = CONFIG_DEFAULT_WIDTH;
+		pt_info->width  = CONFIG_DEFAULT_WIDTH;
 		pt_info->height = CONFIG_DEFAULT_HEIGHT;
 	}
 
 	EMGD_DEBUG("Checking for exact mode match");
-	exact_timing = match_resolution(display, timing_table, pt_info,
+	exact_timing = kms_match_resolution(emgd_encoder, timing_table, pt_info,
 		MATCH_EXACT);
+
 	/*
 	 * At this point we have one of these cases:
 	 *  1) Found an exact match, VGA, VESA or other.
@@ -479,7 +490,7 @@ int match_mode (
 			EMGD_DEBUG("Checking for exact match in VGA table");
 			/* this only happens if it was a VGA mode number */
 			pt_info->refresh = 0;
-			vga_timing = match_resolution(display, vga_timing_table,
+			vga_timing = kms_match_resolution(emgd_encoder, vga_timing_table,
 				pt_info, MATCH_EXACT);
 
 			if(!vga_timing) {
@@ -494,20 +505,21 @@ int match_mode (
 			/* continue at the bottom where we have
 			 * pipe_timing = NULL, so we will look
 			 * for centered timings for pt_info and
-			 * use cmn_vga_timings to tell match_resolution
+			 * use cmn_vga_timings to tell kms_match_resolution
 			 * to take into account special VGA mode
 			 * centering regulations
 			 */
 		}
 	}
 
-	/* Find UPSCALING attr value*/
-	pi_pd_find_attr_and_value(PORT_OWNER(display),
+	/* Find UPSCALING attr value
+	 * this PI func will not modify value of upscale if attr does not exist */
+	pi_pd_find_attr_and_value(port,
 			PD_ATTR_ID_PANEL_FIT,
 			0,/*no PD_FLAG for UPSCALING */
 			NULL, /* dont need the attr ptr*/
 			&upscale);
-	/* this PI func will not modify value of upscale if attr does not exist */
+
 
 	if(!pipe_timing){
 		/* At this point, one of 2 things has happenned:
@@ -540,7 +552,7 @@ int match_mode (
 			 * in case we need it later for VBIOS
 			 * which doesnt populate the FBInfo
 			 */
-			vesa_timing = match_resolution(display, crt_timing_table,
+			vesa_timing = kms_match_resolution(emgd_encoder, crt_timing_table,
 				pt_info, MATCH_EXACT);
 		}
 
@@ -550,8 +562,8 @@ int match_mode (
 			 * instead of centering VGA in another resolution */
 			pipe_timing = vga_timing;
 		} else {
-			pipe_timing = match_resolution(display, timing_table, pt_info,
-				match_type);
+			pipe_timing = kms_match_resolution(emgd_encoder, timing_table,
+							pt_info, match_type);
 			/* This can happen if there is a spurious pt_info from IAL */
 			if (!pipe_timing) {
 				return -IGD_ERROR_INVAL;
@@ -648,43 +660,48 @@ int match_mode (
 				 * also need to acomodate native timings as well
 				 */
 				/* NOTE: we could never be in here in fb_info was NULL */
-				cntr_dff_w = (pipe_timing->width - fb_info->width) / 2;
+				cntr_dff_w = (pipe_timing->width  - fb_info->width)  / 2;
 				cntr_dff_h = (pipe_timing->height - fb_info->height) / 2;
 
 				/* Dont forget to use a different storage sice we dont
 				 * want to change the original (and to be used later)
 				 * ports mode list timings
 				 */
-				OS_MEMCPY(&scaled_timing[(PIPE(display)->pipe_num)],
-					pipe_timing,
-					sizeof(igd_timing_info_t));
-
-				pipe_timing = &scaled_timing[(PIPE(display)->pipe_num)];
+				list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+					if (crtc == encoder->crtc) {
+						emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+						pipe = emgd_crtc->igd_pipe;
+
+						OS_MEMCPY(&scaled_timing[(pipe->pipe_num)],
+							pipe_timing, sizeof(igd_timing_info_t));
+						pipe_timing = &scaled_timing[(pipe->pipe_num)];
+					}
+				}
 
-				if(PORT_OWNER(display)->pd_type != PD_DISPLAY_TVOUT ) {
+				if(port->pd_type != PD_DISPLAY_TVOUT ) {
 					/* TV display don't like changed pipe actives,
 					 * Updating syncs work for TV centering */
 					if (fb_info->width < temp_width) {
 						pipe_timing->width = (unsigned short)fb_info->width;
 						pipe_timing->hblank_start -= cntr_dff_w;
-						pipe_timing->hblank_end -= cntr_dff_w;
+						pipe_timing->hblank_end   -= cntr_dff_w;
 					}
 
 					if (fb_info->height < temp_height) {
 						pipe_timing->height = (unsigned short)fb_info->height;
 						pipe_timing->vblank_start -= cntr_dff_h;
-						pipe_timing->vblank_end -= cntr_dff_h;
+						pipe_timing->vblank_end   -= cntr_dff_h;
 					}
 				}
 
 				if (fb_info->width < temp_width) {
 					pipe_timing->hsync_start -= cntr_dff_w;
-					pipe_timing->hsync_end -= cntr_dff_w;
+					pipe_timing->hsync_end   -= cntr_dff_w;
 				}
 
 				if (fb_info->height < temp_height) {
 					pipe_timing->vsync_start -= cntr_dff_h;
-					pipe_timing->vsync_end -= cntr_dff_h;
+					pipe_timing->vsync_end   -= cntr_dff_h;
 				}
 			}
 		}
@@ -693,8 +710,8 @@ int match_mode (
 	if(upscale) {
 		/* Get the native timings */
 		EMGD_DEBUG("Checking for Native LVDS match for scaling");
-		native_timing = match_resolution(display, timing_table, pt_info,
-			MATCH_NATIVE);
+		native_timing = kms_match_resolution(emgd_encoder, timing_table,
+							pt_info, MATCH_NATIVE);
 		if(native_timing && (native_timing != pipe_timing)) {
 			native_timing->extn_ptr = pipe_timing;
 			pipe_timing = native_timing;
@@ -729,146 +746,32 @@ int match_mode (
 	 */
 	fill_pt(user_timing, pt_info);
 	*timing = pipe_timing;
-	EMGD_DEBUG("Return");
+	EMGD_TRACE_EXIT;
 
 	return 0;
 }
-#else
-
-#define MATCH_NUMBER    0x001
-#define MATCH_REFRESH   0x002
-#define MATCH_WIDTH     0x004
-#define MATCH_HEIGHT    0x008
-#define MATCH_FLAGS     0x010
-#define MATCH_GE_WIDTH  0x020
-#define MATCH_GE_HEIGHT 0x040
-#define MATCH_FOR_VGA   0x100
-
-static int modes_match(igd_display_info_t *x,
-	igd_timing_info_t *y,
-	unsigned int flags)
-{
-	if((flags & MATCH_NUMBER) &&
-		(x->mode_number != y->mode_number)) {
-		return 0;
-	}
-	if((flags & MATCH_REFRESH) &&
-		(x->refresh && (x->refresh != y->refresh))) {
-		return 0;
-	}
-	if((flags & MATCH_WIDTH) &&
-		(x->width != y->width)) {
-		return 0;
-	}
-	if((flags & MATCH_HEIGHT) &&
-		(x->height != y->height)) {
-		return 0;
-	}
-	if((flags & MATCH_GE_WIDTH) &&
-		(x->width > y->width)) {
-		return 0;
-	}
-	if((flags & MATCH_GE_HEIGHT) &&
-		(x->height > y->height)) {
-		return 0;
-	}
-	if((flags & MATCH_FLAGS) &&
-		(x->flags & (IGD_SCAN_INTERLACE|IGD_PIXEL_DOUBLE|IGD_LINE_DOUBLE)) !=
-		(y->mode_info_flags &
-			(IGD_SCAN_INTERLACE|IGD_PIXEL_DOUBLE|IGD_LINE_DOUBLE))) {
-		return 0;
-	}
-
-	return 1;
-}
-
-typedef struct _vga_wh {
-	short width;
-	short height;
-} vga_wh_t;
-
-static vga_wh_t vga_size[] = {
-	{640, 400}, {640, 400}, {640, 400}, {640, 400},
-	{320, 400}, {320, 400}, {640, 400}, {720, 350},
-	{640, 400}, {640, 400}, {640, 350}, {640, 350},
-	{640, 350}, {640, 350}, {640, 350}, {640, 350},
-	{640, 400}, {720, 400}, {720, 400}, {640, 480},
-	{640, 480}, {640, 400}
-};
-
-/*
- * For VGA modes we do not actually have a mode table. Just use a
- * temporary slot (one per-pipe) and put the VGA mode number in it.
- */
-static igd_timing_info_t vga_timing[] = {
-	{
-		720, 400, 70,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0x00,
-		IGD_MODE_VESA | IGD_MODE_SUPPORTED,
-		0, 0, NULL, NULL
-	},
-	{
-		720, 400, 70,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0x00,
-		IGD_MODE_VESA | IGD_MODE_SUPPORTED,
-		0, 0, NULL, NULL
-	}
-};
 
-/*
- * The magic mode, when found in a port's mode list, means that the port
- * can do native VGA output. A mode with a wxh of 720x480 and refresh of
- * 70 is the magic mode.
- */
-static igd_display_info_t magic_timing = {
-	720, 400, 70,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0x00,
-	IGD_MODE_VESA | PD_MODE_SUPPORTED,
-	0, 0, NULL, NULL
-};
 
 /*!
- * Match Resolution searches the provided timing table for a mode that
- * matches the requested parameters using the provided criteria.
  *
- * @param display The display on which the mode will be displayed.
- * @param timing_table The list of modes to search through.
- * @param pt_info The timing set used as reference for the match
- * @param criteria The criteria that must match (bitfield). Options are
- *  MATCH_NUMBER: Match the VGA/VESA mode number
- *  MATCH_REFRESH: Match the refresh rate
- *  MATCH_WIDTH: Match the width
- *  MATCH_HEIGHT: Match the height
- *  MATCH_FLAGS: Match relavent interlace, pixel double, etc flags.
- *  MATCH_GE_WIDTH: Match width greater or equal to requested (used with
- *    best_match = 1)
- *  MATCH_GE_HEIGHT: Match height greater or equal to requested (used with
- *    best_match = 1)
- *  MATCH_FOR_VGA: Match is used for a VGA container which may need to take
- *    into accoutn 9th pixel dropping in the hardware.
- * @param best_match When set to 0 the first mode found matching the criteria
- * 	will be returned. Null will be returned if no match is found.
- * 	When set to 1 the best matching mode is found after searching all modes.
- * 	if no mode is found matching the criteria, the last mode in the table
- * 	is used (should be the largest mode as mode tables are sorted)
+ * @param display
+ * @param timing_table
+ * @param pt_info
+ * @param type
  *
- * @return igd_timing_info_t
+ * @return NULL on failure
+ * @return timing on success
  */
 static igd_timing_info_t *match_resolution(
 		igd_display_context_t *display,
 		igd_timing_info_t *timing_table,
 		igd_display_info_t *pt_info,
-		unsigned int criteria,
-		int best_match)
+		int type)
 {
 	igd_timing_info_t *timing;
 	igd_timing_info_t *match;
-	igd_timing_info_t *last_mode = NULL;
+	igd_timing_info_t *native_match = NULL;
 	igd_display_port_t *port;
-	unsigned short save_width;
 
 	EMGD_DEBUG("Enter match_resolution");
 
@@ -879,187 +782,207 @@ static igd_timing_info_t *match_resolution(
 	timing = timing_table;
 	match = NULL;
 	port = PORT_OWNER(display);
-	save_width = pt_info->width;
 
 	/*
-	 * Hardware has a mode where it can drop every 9th pixel to fit
-	 * a 720 width VGA mode into a 640 width container. Modify the
-	 * reference mode to reflect 640 width and put it back at the end.
+	 * Note on Native matching.
+	 * The Ideal thing is for a fp_native_dtd to already be marked as such.
+	 * If there is no native timing indicated then we must choose what is
+	 * most likely correct.
+	 * If the mode is not VGA then we should choose any DTD that closely
+	 * matches the mode being set. Failing that we should choose any timing
+	 * that closely matches the mode.
+	 * If the mode is VGA then we should take the current mode as it is
+	 * more likely correct.
 	 */
-	if(criteria & MATCH_FOR_VGA) {
-		if((pt_info->width == 720) &&
-			(port->port_features & IGD_VGA_COMPRESS)) {
-			pt_info->width = 640;
+	if(type == MATCH_NATIVE) {
+		if(port->fp_native_dtd) {
+			EMGD_DEBUG("Returning quick with a native match");
+
+			EMGD_DEBUG("NATIVE Width=%d, height=%d, refresh=%d mode_num=0x%x",
+				port->fp_native_dtd->width, port->fp_native_dtd->height,
+				port->fp_native_dtd->refresh, port->fp_native_dtd->mode_number);
+
+			return port->fp_native_dtd;
+		}
+		if((pt_info->flags & IGD_MODE_VESA) &&
+			(pt_info->mode_number <= 0x13)) {
+			if(PIPE(display)->timing) {
+				native_match = PIPE(display)->timing;
+			}
 		}
 	}
 
 	while (timing->width != IGD_TIMING_TABLE_END) {
-		if(!MODE_IS_SUPPORTED(timing)) {
+		if(!(timing->mode_info_flags & IGD_MODE_SUPPORTED)) {
 			timing++;
 			continue;
 		}
-		if(modes_match(pt_info, timing, criteria)) {
+
+		if(type == MATCH_NATIVE) {
+			if(timing->mode_info_flags & IGD_MODE_DTD_FP_NATIVE) {
+				port->fp_native_dtd = timing;
+				return timing;
+			}
+
+			if(port->fp_info) {
+				/*
+				 * We may have only fp_width and fp_height which is really
+				 * not enough information to be useful. If we find a
+				 * matching width and height we'll keep the first one while
+				 * still hoping to find an actual native mode later.
+				 */
+				if(!match &&
+					(port->fp_info->fp_width ==
+						(unsigned long)timing->width) &&
+					(port->fp_info->fp_height ==
+						(unsigned long)timing->height)) {
+					match = timing;
+				}
+			} else {
+				/*
+				 * Keep a match because in the event that we never find a
+				 * native DTD then we will just take the exact match.
+				 */
+				if(!match &&
+					(timing->width == pt_info->width) &&
+					(timing->height == pt_info->height) &&
+					(timing->refresh == pt_info->refresh)) {
+					match = timing;
+				}
+			}
+
 			/*
-			 * If we are looking for the first match we are done.
+			 * If it is a DTD then keep it only if it is better than any
+			 * found before.
 			 */
-			if(!best_match) {
-				match = timing;
-				break;
+			if(timing->mode_info_flags & IGD_MODE_DTD_USER) {
+				if(native_match) {
+					if(MATCH_MOD((int)(pt_info->width*pt_info->height) -
+							(native_match->width * native_match->height)) >
+						MATCH_MOD((int)(pt_info->width*pt_info->height) -
+							(timing->width*timing->height))) {
+						native_match = timing;
+					}
+				} else {
+					native_match = timing;
+				}
 			}
+		} else if (type == MATCH_EXACT) {
 			/*
-			 * Looking for best match. Compare the new match to the last one
-			 * to see if it is better.
+			 * Looking for an exact match. For VGA/VESA it must match
+			 * mode number. Otherwise it must match width, height, refresh
+			 * etc.
 			 */
-			if(match) {
-				/* Check for tighter fit */
-				if((timing->width < match->width) ||
-					(timing->height < match->height)) {
+			if(pt_info->flags & IGD_MODE_VESA) {
+				/* ((timing->mode_info_flags & IGD_MODE_VESA)) */
+				if((pt_info->mode_number == timing->mode_number) &&
+					(!pt_info->refresh ||
+						(pt_info->refresh == timing->refresh))) {
 					match = timing;
+					break;
 				}
 			} else {
-				match = timing;
+				/* If exact match found, then break the loop */
+				if((timing->width == pt_info->width) &&
+					(timing->height == pt_info->height) &&
+					(timing->refresh == pt_info->refresh) &&
+					(
+						(timing->mode_info_flags &
+							(IGD_SCAN_INTERLACE|IGD_PIXEL_DOUBLE|
+								IGD_LINE_DOUBLE)) ==
+						(pt_info->flags &
+							(IGD_SCAN_INTERLACE|IGD_PIXEL_DOUBLE|
+								IGD_LINE_DOUBLE)))) {
+					match = timing;
+
+					/* If exact match found, then break the loop */
+					if ((timing->mode_info_flags & PD_MODE_DTD_USER) ||
+						(timing->mode_info_flags & PD_MODE_DTD)) {
+						break;
+					}
+				}
 			}
 		}
-		last_mode = timing;
-		timing++;
-	}
 
-	pt_info->width = save_width;
-	if(!match && best_match) {
-		/*
-		 * Take the last one in the table for container modes. This insures
-		 * that we never fail a container mode.
-		 */
-		match = last_mode;
-	}
-
-	if (match) {
-		EMGD_DEBUG("Returning with a match");
-		EMGD_DEBUG("Width=%d, height=%d, refresh=%d mode_number=0x%x",
-			match->width, match->height, match->refresh, match->mode_number);
-	} else {
-		EMGD_DEBUG("Returning with NO match");
-	}
 
-	return match;
-} /* end match_resolution */
-
-
-void update_fb_size(igd_timing_info_t *match,
-	igd_framebuffer_info_t *fb_info)
-{
-
-	/*
-	 * fb_info is sometimes NULL when just testing something.
-	 */
-	if(fb_info) {
+		/* Center needs only to be bigger. Aspect ratio doesn't matter. */
 		/*
-		 * If The FB data comes in as zero we populate it with the matched
-		 * size. Also if the FB is coming from vBIOS we increase the size
-		 * to fit the match.
+		 * Note: The timings have to be big enough to fit the pt_info
+		 * including any pixel double flags. VGA modes will sometimes be
+		 * pixel doubled and need to be centered in a pipe that is double
+		 * in size.
+		 *
+		 * Note2: 720x400 VGA modes can be centered in 640x480 with a
+		 * special hardware config that drops every 9th pixel. Only do
+		 * this when requested.
 		 */
-		if((fb_info->width == 0) || (fb_info->flags & IGD_VBIOS_FB)) {
+		else if(type & MATCH_CENTER) {
+			unsigned short eff_width = pt_info->width;
+			unsigned short eff_height = pt_info->height;
 
-			if((fb_info->width < match->width) ||
-				(fb_info->height < match->height)) {
-				fb_info->width = match->width;
-				fb_info->height = match->height;
+			if(type & MATCH_FOR_VGA) {
+				/*
+				 * 720x400 is a magic mode that means all VGA modes are supported
+				 * always use that mode for centering if found.
+				 */
+				if((timing->width == 720) && (timing->height == 400)) {
+					EMGD_DEBUG("Returning with a magic VGA mode");
+					return timing;
+				}
+				if(pt_info->flags & IGD_PIXEL_DOUBLE) {
+					eff_width *= 2;
+				}
+				if(pt_info->flags & IGD_LINE_DOUBLE) {
+					eff_height *= 2;
+				}
+				if((eff_width == 720) &&
+					(port->port_features & IGD_VGA_COMPRESS)) {
+					eff_width = 640;
+				}
 			}
-		}
-	}
-}
 
-/*!
- * Push a Match on to the stack which is represented by a link list.
- * Only push the mode if it is different than the head of the list.
- *
- * @param match
- * @param timing_stack
- *
- * @return void
- */
-void push_match(igd_timing_info_t *match,
-	igd_timing_info_t **timing_stack)
-{
-
-	if(match == *timing_stack) {
-		return;
+			if((timing->width >= eff_width) &&
+				(timing->height >= eff_height) &&
+				(timing->mode_info_flags & IGD_SCAN_INTERLACE) ==
+				(pt_info->flags & IGD_SCAN_INTERLACE)) {
+				if(match) {
+					/* Check for tighter fit */
+					if((match->width > timing->width) ||
+						(match->height > timing->height)) {
+						match = timing;
+					}
+					/* Try to match refreshrate as well */
+					if((match->width == timing->width) &&
+					   (match->height == timing->height) &&
+					   (pt_info->refresh == timing->refresh)){
+						match = timing;
+					}
+				} else {
+					match = timing;
+				}
+			}
+		}
+		timing++;
 	}
-	match->extn_ptr = *timing_stack;
-	*timing_stack = match;
-	return;
-}
-
-
-static igd_timing_info_t scaled_timing[IGD_MAX_PIPES];
-
-/*!
- * This function determines if the input timings need to be modified
- * to accomodate the provided framebuffer. If so it converts the timing set
- * to a modified set that centers the provided framebuffer image.
- * The provided timings are not modified and the returned set
- * may be used until the next mode set. The returned timings do
- * not need to be freed.
- *
- * @param display A pointer to the display used for these timings.
- * 	This parameter is used to determine which pipe the timings
- * 	will be used with. There is one set of static timings for
- * 	each pipe.
- * @param timing The input timings which are used as reference to
- * 	generate the new timings. Only the width/height and blank/syncs
- * 	will be altered. The pixel clock and total sizes will not be changed.
- * @param fb_info The framebuffer information to center within the
- * 	provided timings. (May be NULL)
- *
- * @return Modified timing set
- */
-igd_timing_info_t *get_centered_timings(igd_display_context_t *display,
-	igd_timing_info_t *timing,
-	igd_framebuffer_info_t *fb_info)
-{
-	short cntr_dff_w = 0;
-	short cntr_dff_h = 0;
 
-	if(!fb_info) {
-		return timing;
+	if(native_match) {
+		EMGD_DEBUG("Returning with a native match");
+		EMGD_DEBUG("Width=%d, height=%d, refresh=%d mode_number=0x%x",
+			native_match->width, native_match->height, native_match->refresh,
+			native_match->mode_number);
+		return native_match;
 	}
-
-	/*
-	 * If we end up making a munged centered timings we need to use
-	 * a copy and not the originals.
-	 *
-	 */
-	OS_MEMCPY(&scaled_timing[(PIPE(display)->pipe_num)],
-		timing, sizeof(igd_timing_info_t));
-
-	if(PORT_OWNER(display)->pd_type != PD_DISPLAY_TVOUT) {
-		/*
-		 * TV display don't like changed pipe actives,
-		 * Updating syncs work for TV centering
-		 */
-		if (fb_info->width < timing->width) {
-			timing = &scaled_timing[(PIPE(display)->pipe_num)];
-			cntr_dff_w = (timing->width - fb_info->width) / 2;
-			timing->width = (unsigned short)fb_info->width;
-			timing->hblank_start -= cntr_dff_w;
-			timing->hblank_end -= cntr_dff_w;
-		}
-		if (fb_info->height < timing->height) {
-			timing = &scaled_timing[(PIPE(display)->pipe_num)];
-			cntr_dff_h = (timing->height - fb_info->height) / 2;
-			timing->height = (unsigned short)fb_info->height;
-			timing->vblank_start -= cntr_dff_h;
-			timing->vblank_end -= cntr_dff_h;
-		}
+	if (!match) {
+		EMGD_DEBUG("Returning with NO match");
+		return NULL;
 	}
 
-	timing->hsync_start -= cntr_dff_w;
-	timing->hsync_end -= cntr_dff_w;
-	timing->vsync_start -= cntr_dff_h;
-	timing->vsync_end -= cntr_dff_h;
+	EMGD_DEBUG("Returning with a match");
+	EMGD_DEBUG("Width=%d, height=%d, refresh=%d mode_number=0x%x",
+		match->width, match->height, match->refresh, match->mode_number);
+	return match;
+} /* end match_resolution */
 
-	return timing;
-}
 
 
 /*!
@@ -1067,104 +990,43 @@ igd_timing_info_t *get_centered_timings(igd_display_context_t *display,
  * When a mode is found update the input structures to reflect the
  * values found.
  *
- *  The match mode function will compile all the information needed by
- * the HAL to put the hardware into a mode. This may be a regular
- * full-screen mode, a centered mode, a panned mode, a scaled mode.
- * Below is a table of the mode that will be used and the cases in which
- * it will occurr.
- *
- * Native
- *  The requested mode is matched in the mode table in terms of width
- *  height, refresh, and interlace flags. There is no fp_native_dtd or
- *  the matching mode IS the fp_native_dtd.
- * Centered
- *  1) The requested mode is matched in the mode table but the framebuffer
- *     is a smaller size and needs to be centered.
- *  2) The requested mode is NOT matched in the mode table and the
- *     framebuffer matches the requested mode. A container mode is used
- *     with the original smaller framebuffer.
- * Scaled
- *  The requested mode is matched in the mode table and a fp_native_dtd
- *  is present for the port. The matched mode does not match the native
- *  and is therefore scaled to fit.
- * Panned/Cropped
- *  The requested mode is matched in the mode table but the framebuffer
- *  is larger (in at least one demension) that the mode. The mode is
- *  set with a cropped FB that may then be panned by the IAL.
- * Render Scaled
- *  The requested mode may or may not be matched in the mode table. The
- *  framebuffer data is empty. The HAL will match the mode or find a
- *  container or find the largest mode and set the framebuffer to the
- *  same size. The IAL will scale the actual framebuffer to the returned
- *  framebuffer.
- * Native VGA
- *  A VGA mode is requested (by number) and the magic VGA mode is matched
- *  in the mode table. FB contents are output only.
- * Centered VGA
- *  A VGA mode is requested (by number) and the magic VGA mode is NOT
- *  matched. A container mode is found or the largest mode is used. The
- *  VGA is hardware centered in the container mode. FB contents are
- *  output only.
- * Scaled VGA
- *  A VGA mode is requested (by number) and the magic VGA mode is NOT
- *  matched. A fp_native_dtd is found. The VGA image will be scaled to
- *  the native timings.
- *
+ * Notes:
+ *  Match mode has several options for what it can do. Foremost it should
+ * attempt to find a mode matching the requested one from the timing table
+ * provided. If the mode requested is not in the list this means one of
+ * two things.
+ *   1) The IAL is calling without checking modes. It is just passing down
+ *  something that a user asked for. This is ok but we need to be safe so
+ *  we return the next smaller mode with the same aspect ratio.
  *
- * The timings returned may be part of a linked list of timings which
- * are used by the HAL to perform centering and scaling operations. One
- * of the following will result.
+ *   2) The IAL is requesting a very common "required" mode even though the
+ *  port doesn't support it. In this case it should be in the static common
+ *  modes table and can be centered in the next larger timings in the
+ *  mode table.
  *
- * Requested Mode
- *   The requested mode matched and is returned with no linked modes.
- * Munged Requested Mode
- *   The requested mode was larger than the requested framebuffer. The
- *   timings were then modified to center the framebuffer.
- * Native Mode -> Requested Mode
- *   The display is fixed resolution and any mode must be scaled to that
- *   resolution by the PD. The native mode is returned and linked to the
- *   requested mode which will be scaled to fit the native mode. The
- *   pt_info will be populated with the requested mode giving the caller
- *   the impression that the mode was set natively.
- * Native Mode -> Munged Requested Mode
- *   The display is fixed resolution and any mode must be scaled to that
- *   resolution by the PD. In addition the requested framebuffer is smaller
- *   then the requested mode. The native mode is returned and linked to the
- *   requested mode which has been modifed to center the framebuffer.
- *   The result will be the requested framebuffer scaled to fit the native
- *   mode. The pt_info will be populated with the requested mode giving the
- *   caller the impression that the mode was set natively.
- * VGA Mode -> Magic VGA Mode
- *   The requested mode was a legacy VGA mode and the display supports
- *   native VGA output. The 720x400 "magic" mode is returned to indicate
- *   to the HAL that native VGA should be used. The magic mode is linked
- *   to the requested VGA mode.
- * Container Mode -> VGA Mode
- *   The requested mode was a legacy VGA mode but the display does not
- *   support native VGA output. A larger container mode was found and
- *   returned. The hardware will center the VGA mode within the container
- *   for output. The pt_info will contain the VGA mode giving the caller
- *   the impression that the VGA mode was set natively.
- * Native Mode -> VGA Mode
- *   The requested mode was a legacy VGA mode but the and the PD is
- *   set for scaling to a fixed resolution display. The Native mode is
- *   returned linked to the VGA mode. The result is the VGA mode scaled to
- *   fit the native screen.
+ * If the Frambuffer is smaller than the timings requested a fake set of
+ * centered timings is returned to program the pipe.
  *
- *   @note: There is a tradeoff to this behavior. If a VGA mode is set and
- *   scaled to full-screen there is no guarentee that ALL VGA modes are
- *   possible in that configuration. For instance, in DOS if a mode 3 is
- *   set (720x400) and scaled full-screen, an application cannot directly
- *   program the VGA registers (as many games do) to get an acceptable
- *   output at 640x480. This tradeoff is acknoledged and accepted.
+ * In the case of VGA modes. If the mode is in the mode table everything is
+ * fine and we just return that. If it is not in the table we find the next
+ * larger suitable mode and prepare to center in that mode. Using the static
+ * timings from the VGA table as the VGA mode. We do not need to generate
+ * a fake set of timings because VGA will center itself automatically in
+ * hardware.
  *
+ * In the case of LVDS both centering and scaling can happen. If the mode
+ * is in the list it will be scaled to the Native Timings. If the mode
+ * is not in the list (common or VGA) it will be centered in the next larger
+ * supported mode and then scaled to the native timings.
  *
- * Assumtions:
- *  1) fp_native_dtd is set in all instances where the output is a fixed
- *   resolution. (and only those instances)
- *  2) PDs timing table contains all modes that can be output or all
- *   modes that can be scaled to the native output.
- *  3) Scaling PDs can accept a VGA mode to be scaled to the native.
+ * Centering is always indicated by returning the timings that should be
+ * programmed to the pipe. The timings will then have their extension pointer
+ * set to point to the centered timings. For centering with scaling the
+ * first extension pointer will contain the scalable timings and the
+ * second will contain the centering timings. The static "scaled_timings"
+ * data structure will be used when the scaled timings need to be
+ * created on the fly due to a Framebuffer that is smaller than the
+ * timings.
  *
  * @param display
  * @param timing_table
@@ -1172,7 +1034,8 @@ igd_timing_info_t *get_centered_timings(igd_display_context_t *display,
  * @param pt_info
  * @param timing
  *
- * @return 0
+ * @return -IGD_ERROR_INVAL on failure
+ * @return 0 on success
  */
 int match_mode (
 	igd_display_context_t *display,
@@ -1181,144 +1044,304 @@ int match_mode (
 	igd_display_info_t *pt_info,
 	igd_timing_info_t **timing)
 {
-	igd_timing_info_t *match = NULL;
-	igd_timing_info_t *timing_stack = NULL;
+	igd_timing_info_t *exact_timing = NULL;
+	igd_timing_info_t *pipe_timing = NULL;
+	igd_timing_info_t *user_timing = NULL;
+	igd_timing_info_t *native_timing = NULL;
+	igd_timing_info_t *vga_timing = NULL;
+	igd_timing_info_t *vesa_timing = NULL;
+	short cntr_dff_w = 0;
+	short cntr_dff_h = 0;
+	unsigned long upscale = 0;
 
 	EMGD_DEBUG("Enter Match Mode");
 
-	EMGD_ASSERT(pt_info, "Null PT Info", -IGD_ERROR_INVAL);
-	EMGD_ASSERT((pt_info->flags & IGD_MODE_VESA) ||
-		(pt_info->width && pt_info->height),
-		"Width and Height are Zero", -IGD_ERROR_INVAL);
+	if(!pt_info) {
+		EMGD_ERROR("NULL Port info detected, returning");
+		return -IGD_ERROR_INVAL;
+	}
 
-	if(MODE_IS_VGA(pt_info)) {
-		/*
-		 * The requested mode is a legacy VGA mode
-		 */
-		EMGD_DEBUG("Matching a VGA mode");
+	/* Check for default case */
+	if (!(pt_info->flags & IGD_MODE_VESA) &&
+		(pt_info->width == 0) && (pt_info->height == 0)) {
+		EMGD_DEBUG("Display Info width, height are zero, using default case");
+		pt_info->width = CONFIG_DEFAULT_WIDTH;
+		pt_info->height = CONFIG_DEFAULT_HEIGHT;
+	}
 
-		/*
-		 * All VGA modes are possible. Just use a temporary timing
-		 * block and put the VGA mode number in it. We don't actually
-		 * use any timing information for VGA modes.
-		 */
-		match = &vga_timing[(PIPE(display)->pipe_num)];
-		match->mode_number = pt_info->mode_number;
-		match->width = vga_size[pt_info->mode_number].width;
-		match->height = vga_size[pt_info->mode_number].height;
+	EMGD_DEBUG("Checking for exact mode match");
+	exact_timing = match_resolution(display, timing_table, pt_info,
+		MATCH_EXACT);
+	/*
+	 * At this point we have one of these cases:
+	 *  1) Found an exact match, VGA, VESA or other.
+	 *    -> Go check for FB centering and finish up.
+	 *  2) Found nothing
+	 *    -> Check for VGA/VESA mode to center.
+	 *    -> Check common modes.
+	 */
+	if(exact_timing) {
+		pipe_timing = exact_timing;
+		user_timing = exact_timing;
+		pipe_timing->extn_ptr = NULL;
+	} else {
+		/* No match found? Is it VGA? */
+		if( (pt_info->flags & IGD_MODE_VESA) &&
+			(pt_info->mode_number < 0x1D)    ){
+			EMGD_DEBUG("Checking for exact match in VGA table");
+			/* this only happens if it was a VGA mode number */
+			pt_info->refresh = 0;
+			vga_timing = match_resolution(display, vga_timing_table,
+				pt_info, MATCH_EXACT);
 
-		push_match(match, &timing_stack);
-		update_fb_size(match, fb_info);
+			if(!vga_timing) {
+				return -IGD_ERROR_INVAL;
+			}
 
-		/* The caller should think we set the VGA mode directly */
-		fill_pt(match, pt_info);
+			vga_timing->extn_ptr = NULL;
+			/* We got something sane that needs to be centered */
+			user_timing = vga_timing;
+			fill_pt(vga_timing,pt_info);
 
-		match = match_resolution(display, timing_table, &magic_timing,
-			MATCH_WIDTH|MATCH_HEIGHT, 0);
-		if(match) {
-			/*
-			 * Magic VGA mode was found. This indicates the display can
-			 * do full native VGA timings. We will send the mode out
-			 * natively.
+			/* continue at the bottom where we have
+			 * pipe_timing = NULL, so we will look
+			 * for centered timings for pt_info and
+			 * use cmn_vga_timings to tell match_resolution
+			 * to take into account special VGA mode
+			 * centering regulations
 			 */
-			EMGD_DEBUG("Native VGA output");
-			push_match(match, &timing_stack);
-
-			*timing = timing_stack;
-			return 0;
 		}
+	}
 
-		/*
-		 * This display cannot do native VGA. We need to center or
-		 * scale the VGA to fit.
+	/* Find UPSCALING attr value*/
+	pi_pd_find_attr_and_value(PORT_OWNER(display),
+			PD_ATTR_ID_PANEL_FIT,
+			0,/*no PD_FLAG for UPSCALING */
+			NULL, /* dont need the attr ptr*/
+			&upscale);
+	/* this PI func will not modify value of upscale if attr does not exist */
+
+	if(!pipe_timing){
+		/* At this point, one of 2 things has happenned:
+		 *      - we have a mode request that we could not match exactly.
+		 *        and it WASNT a VESA_MODE number request.
+		 *      - we have a request based on VESA_MODE number (maybe from
+		 *        VBIOS IAL) and we could not get a exact match from the
+		 *        port_timing_table, but we did get a match from the vga-
+		 *        timing_table.
+		 * In this case, there is one thing to do - MATCH_CENTER. Match
+		 * resolution will handle it this way:
+		 *      - if its VESA MODE number based, we only need to get
+		 *        the best (tightest) match if its VGA OR DONT match
+		 *        if its one of those magic timings
+		 *      - Else, we need to get the best (tightest) match, AND
+		 *        we need to center requested timings in that tightest fitting
+		 *        timing. But wait! This could mean if the requested pt_info
+		 *        is bigger than anything in the port timing table, we have
+		 *        no choice but to fail.
 		 */
-		if(PORT_OWNER(display)->fp_native_dtd) {
-			/*
-			 * Native mode in the port indicates the PD can scale.
-			 * Push the native mode on the list to get VGA scaled
-			 * to native.
+		unsigned char match_type = MATCH_CENTER;
+
+		EMGD_DEBUG("Checking for a safe centered match");
+		if(vga_timing) {
+			match_type |= MATCH_FOR_VGA;
+		} else if(pt_info->flags & IGD_MODE_VESA) {
+			/* if a vesa mode number was requested...
+			 * and we are centering that mode, we
+			 * need to get the common mode fb size
+			 * in case we need it later for VBIOS
+			 * which doesnt populate the FBInfo
 			 */
-			EMGD_DEBUG("VGA Scaled to Native");
-			push_match(PORT_OWNER(display)->fp_native_dtd, &timing_stack);
+			vesa_timing = match_resolution(display, crt_timing_table,
+				pt_info, MATCH_EXACT);
+		}
+
+		if (upscale && vga_timing) {
+			/* If port supports upscaling and match is called for VGA,
+			 * then center vga mode resolution directly in the native mode
+			 * instead of centering VGA in another resolution */
+			pipe_timing = vga_timing;
 		} else {
-			/*
-			 * No native mode means the PD is not scaling. Output
-			 * VGA centered in a safe container mode.
+			pipe_timing = match_resolution(display, timing_table, pt_info,
+				match_type);
+			/* This can happen if there is a spurious pt_info from IAL */
+			if (!pipe_timing) {
+				return -IGD_ERROR_INVAL;
+			}
+			pipe_timing->extn_ptr = vga_timing;
+			/* for the case of non VGA mode call,
+			 * at this point, vga_timing is NULL
 			 */
-			EMGD_DEBUG("VGA centered in Container");
-			match = match_resolution(display, timing_table, pt_info,
-				MATCH_FOR_VGA|MATCH_GE_WIDTH|MATCH_GE_HEIGHT|MATCH_FLAGS, 1);
-			EMGD_ASSERT(match, "Match Container Failed", -IGD_ERROR_INVAL);
-
-			push_match(match, &timing_stack);
 		}
 
-		*timing = timing_stack;
-		return 0;
-
+		if(!vga_timing) {
+			user_timing = pipe_timing;
+		}
 	}
 
 	/*
-	 * Regular NON-VGA mode
+	 * At this point pipe_timing is what we are going to program the
+	 * pipe to roughly speaking. If there is a common timing then we
+	 * want it centered in the pipe_timing.
+	 *
+	 * If the framebuffer is smaller than the timings then we need to
+	 * generate a centered set of timings by copying the pipe timings
+	 * and shifting them a bit.
+	 *
+	 * If fb width and height are zero just assume that we want it to
+	 * match the timings and make up a pixel format. This is mostly because
+	 * VGA/VESA modes will just be set by number. We don't know their size
+	 * until we look up the number.
 	 */
-	EMGD_DEBUG("Matching a regular NON-VGA mode");
-
-	match = match_resolution(display, timing_table, pt_info,
-		(pt_info->flags & IGD_MODE_VESA)?
-		MATCH_NUMBER|MATCH_REFRESH:
-		MATCH_WIDTH|MATCH_HEIGHT|MATCH_REFRESH|MATCH_FLAGS, 0);
-	if(match) {
+	if(fb_info) {
 		/*
-		 * Exact match for requested mode was found in the mode table.
-		 * This mode will be output directly.
+		 * fb_info is sometimes NULL when just testing something.
 		 */
-		EMGD_DEBUG("Input Mode Matched exactly");
-	} else {
+		if(!fb_info->pixel_format) {
+			/* Ugly VGA modes, it doesn't matter */
+			fb_info->pixel_format = IGD_PF_ARGB8_INDEXED;
+		}
+		if(!fb_info->width) {
+			if(vga_timing) {
+				fb_info->width = vga_timing->width;
+				fb_info->height = vga_timing->height;
+			} else {
+				if(!vesa_timing){
+					vesa_timing = pipe_timing;
+					/* in case vesa_timing is false set it to
+					 * pipe_timing so we dont need to check for
+					 * validity later, when increasing fb size for
+					 * VBIOS in clone mode (see 18 lines below)
+					 */
+				}
+				fb_info->width = vesa_timing->width;
+				fb_info->height = vesa_timing->height;
+			}
+		}
+
 		/*
-		 * Matching mode was not found. This happens for several
-		 * reasons:
-		 *
-		 * 1) We are setting the clone mode but the IAL does not
-		 *   know the clone width/height. We are just getting the
-		 *   best guess. In this case fb info is populated.
-		 * 2) IAL is doing Render Scaling but doesn't know what mode
-		 *   to scale to. We are getting the best fit. In this case
-		 *   fb info is all zeros.
-		 * 3) IAL is just setting random modes and wants something
-		 *   close. Fb info may or may not be populated.
+		 * VGA common timings are centered in pipe timings by hardware.
+		 * Otherwise we need to adjust the timings when centering is
+		 * needed.
 		 */
-		EMGD_DEBUG("Input Mode NOT matched, container used");
-		match = match_resolution(display, timing_table, pt_info,
-			MATCH_GE_WIDTH|MATCH_GE_HEIGHT|MATCH_FLAGS, 1);
-		EMGD_ASSERT(match, "Match Container Failed", -IGD_ERROR_INVAL);
-	}
-	update_fb_size(match, fb_info);
-	match = get_centered_timings(display, match, fb_info);
-	push_match(match, &timing_stack);
+		if (!vga_timing) {
+			/*
+			 * For VBIOS clone modes the FB should be the biggest mode
+			 * if this is the second match we may need to update the fb
+			 * data structure.
+			 */
+			if(fb_info->flags & IGD_VBIOS_FB) {
+				if ((fb_info->width < vesa_timing->width) ||
+					(fb_info->height < vesa_timing->height)) {
+					fb_info->width = vesa_timing->width;
+					fb_info->height = vesa_timing->height;
+				}
+			}
 
-	fill_pt(match, pt_info);
 
-	if(PORT_OWNER(display)->fp_native_dtd) {
-		/*
-		 * Native DTD indicates that the PD is scaling. Hook the
-		 * match mode up to the native to get scaling.
-		 */
-		EMGD_DEBUG("Input Mode Scaled to Native");
-		push_match(PORT_OWNER(display)->fp_native_dtd, &timing_stack);
-	}
+			/* Do centering if fb is smaller than timing except on TV */
+			if ((fb_info->width < pipe_timing->width) ||
+				(fb_info->height < pipe_timing->height)) {
+				unsigned short temp_width = pipe_timing->width;
+				unsigned short temp_height = pipe_timing->height;
+				/* Normally, we should NOT be in here. All IALs only
+				 * are supposed to request for timings that ARE surely
+				 * supported by the HAL,... i.e. query the list of
+				 * supported timings by the port first!
+				 *
+				 * The exception would be if the IAL is purposely
+				 * asking for CENTERING!!! (pt_info's that were not
+				 * part of the supported mode list). This could indicate an
+				 * error or an explicit request for VESA centering!.
+				 */
 
+				/* let's use these 2 variables as flags... and do the
+				 * actual "centering" of the timings later since we do
+				 * also need to acomodate native timings as well
+				 */
+				/* NOTE: we could never be in here in fb_info was NULL */
+				cntr_dff_w = (pipe_timing->width - fb_info->width) / 2;
+				cntr_dff_h = (pipe_timing->height - fb_info->height) / 2;
 
-	*timing = timing_stack;
-	return 0;
-}
+				/* Dont forget to use a different storage sice we dont
+				 * want to change the original (and to be used later)
+				 * ports mode list timings
+				 */
+				OS_MEMCPY(&scaled_timing[(PIPE(display)->pipe_num)],
+					pipe_timing,
+					sizeof(igd_timing_info_t));
 
+				pipe_timing = &scaled_timing[(PIPE(display)->pipe_num)];
 
-#endif
+				if(PORT_OWNER(display)->pd_type != PD_DISPLAY_TVOUT ) {
+					/* TV display don't like changed pipe actives,
+					 * Updating syncs work for TV centering */
+					if (fb_info->width < temp_width) {
+						pipe_timing->width = (unsigned short)fb_info->width;
+						pipe_timing->hblank_start -= cntr_dff_w;
+						pipe_timing->hblank_end -= cntr_dff_w;
+					}
 
+					if (fb_info->height < temp_height) {
+						pipe_timing->height = (unsigned short)fb_info->height;
+						pipe_timing->vblank_start -= cntr_dff_h;
+						pipe_timing->vblank_end -= cntr_dff_h;
+					}
+				}
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: match.c,v 1.10 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/display/mode/cmn/match.c,v $
- *----------------------------------------------------------------------------
- */
+				if (fb_info->width < temp_width) {
+					pipe_timing->hsync_start -= cntr_dff_w;
+					pipe_timing->hsync_end -= cntr_dff_w;
+				}
+
+				if (fb_info->height < temp_height) {
+					pipe_timing->vsync_start -= cntr_dff_h;
+					pipe_timing->vsync_end -= cntr_dff_h;
+				}
+			}
+		}
+	}
+
+	if(upscale) {
+		/* Get the native timings */
+		EMGD_DEBUG("Checking for Native LVDS match for scaling");
+		native_timing = match_resolution(display, timing_table, pt_info,
+			MATCH_NATIVE);
+		if(native_timing && (native_timing != pipe_timing)) {
+			native_timing->extn_ptr = pipe_timing;
+			pipe_timing = native_timing;
+		}
+	}
+
+	/*
+	 * Match mode returns as follows:
+	 * In case of VGA setmode:
+	 * 1) We will end up with either:
+	 *   magic->vga   ---   For displays supports native VGA
+	 *      or
+	 *   native->vga  ---   Upscaling displays
+	 *      or
+	 *   pipe->vga    ---   For other displays
+	 *
+	 * 2) In case of regular setmode:
+	 *   pipe         ---   For regular displays
+	 *      or
+	 *   native->vesa ---   Upscaling displays
+	 *
+	 *   Note: 1) Here "pipe" can be munged if centering is required.
+	 *         2) "vesa" is the requested mode, native is the native timing
+	 *            of the display.
+	 */
+
+	/*
+	 * Update Input Structures with values found
+	 * Note: This might not be what is going to be programmed. It is what
+	 * the user thinks they set. Scaling or centering could have altered
+	 * that.
+	 */
+	fill_pt(user_timing, pt_info);
+	*timing = pipe_timing;
+	EMGD_DEBUG("Return");
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/match.h b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/match.h
index 4216038..40a6721 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/match.h
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/match.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: match.h
- * $Revision: 1.5 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -46,10 +46,14 @@ int match_mode (
 	igd_display_info_t *pt_info,
 	igd_timing_info_t **timing);
 
+int kms_match_mode (
+	emgd_encoder_t *emgd_encoder,
+	igd_framebuffer_info_t *fb_info,
+	igd_timing_info_t **timing);
+
+igd_timing_info_t *kms_match_resolution(
+	emgd_encoder_t *emgd_encoder,
+	igd_timing_info_t *timing_table,
+	igd_display_info_t *pt_info,
+	int type);
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: match.h,v 1.5 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/display/mode/cmn/match.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/micro_mode.c b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/micro_mode.c
index 06da149..92d01ba 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/micro_mode.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/micro_mode.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: micro_mode.c
- * $Revision: 1.23 $
+ * $Revision: 1.29 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -61,6 +61,7 @@
 #include <general.h>
 #include <module_init.h>
 
+#include "drm_emgd_private.h"
 #include "match.h"
 #include "mode_dispatch.h"
 
@@ -78,6 +79,7 @@
 
 #define MODE_MIN(x, y) (x<y)?x:y
 
+extern emgd_drm_config_t config_drm;
 
 /*
  * NOTE: Do not add comma's to this dispatch table. The macro's
@@ -89,6 +91,19 @@ static dispatch_table_t mode_dispatch[] = {
 	DISPATCH_END
 };
 
+
+
+/*
+ * Kernel Mode Setting (KMS) dispatch table
+ */
+static dispatch_table_t mode_kms_dispatch[] = {
+	DISPATCH_PLB( &mode_kms_dispatch_plb )
+	DISPATCH_TNC( &mode_kms_dispatch_tnc )
+	DISPATCH_END
+};
+
+
+
 /*
  * Do not malloc the context for two reasons.
  *  1) vBIOS needs to minimize mallocs
@@ -341,6 +356,11 @@ static int mode_update_plane_pipe_ports(
 		} else {
 			/* If not reallocating, use back the offset in plane_fb_info */
 			fb_info->fb_base_offset = plane_fb_info->fb_base_offset;
+			 /* We must set the visible offset and screen pitch
+			  * to proper value if we use back the plane.
+			  */
+                        fb_info->visible_offset = fb_info->fb_base_offset;
+                        fb_info->screen_pitch = plane_fb_info->screen_pitch;
 		}
 
 		OS_MEMCPY(plane_fb_info, fb_info, sizeof(igd_framebuffer_info_t));
@@ -449,7 +469,7 @@ static int calculate_infoframes(
  *
  * @return 0
  */
-static int calculate_eld(
+int calculate_eld(
 	igd_display_port_t *port,
 	igd_timing_info_t *timing_info)
 {
@@ -856,6 +876,36 @@ static int configure_display(
 	return 0;
 }
 
+int igd_configure_display(
+	igd_driver_h driver_handle,
+	igd_display_h *display,
+	igd_display_info_t *pt_info,
+	igd_framebuffer_info_t *fb_info,
+	unsigned long dc,
+	int fb_index,
+	unsigned long flags)
+{
+	int p0, pn;
+	int ret;
+
+	EMGD_TRACE_ENTER;
+
+    /* Which ports do we loop through in the dc */
+    if (fb_index == 0) {
+        p0 = 0;
+        pn = 4;
+    } else {
+        p0 = 4;
+        pn = 7;
+    }
+
+	ret = configure_display(driver_handle, (igd_display_context_t *)display,
+		pt_info, fb_info, dc, p0, pn, flags);
+
+	EMGD_TRACE_EXIT;
+	return ret;
+}
+
 
 #ifndef CONFIG_MICRO
 
@@ -1065,11 +1115,6 @@ int igd_alter_displays(
 	unsigned char disable_plane_pipe = 0;
 	unsigned long current_dc;
 
-#if 0 /* Ian Elliott is taking this out ... see comment below */
-#ifndef CONFIG_MICRO
-	igd_framebuffer_info_t *plane_fb_info = NULL;
-#endif
-#endif /* 0 -- Ian is taking this out */
 
 	EMGD_TRACE_ENTER;
 
@@ -1127,8 +1172,8 @@ int igd_alter_displays(
 
 #ifndef CONFIG_MICRO
 	/* Check if platform needs force alter
- 	* 	to make sure we run tuning code. This
- 	* 	is for TNC-B0 workaround.*/
+	* 	to make sure we run tuning code. This
+	* 	is for TNC-B0 workaround.*/
 	if (mode_context->dispatch->dsp_is_force_alter_required){
 		if (mode_context->dispatch-> dsp_is_force_alter_required(context->
 						mod_dispatch.dsp_display_list[IGD_DC_PRIMARY(current_dc)],
@@ -1273,29 +1318,11 @@ int igd_alter_displays(
 	/* Attach the displays to the caller's pointers */
 	if (primary) {
 		*primary = context->mod_dispatch.dsp_display_list[IGD_DC_PRIMARY(dc)];
-#ifndef CONFIG_MICRO
-		if (*primary && context->mod_dispatch.alloc_queues) {
-			ret = context->mod_dispatch.alloc_queues(driver_handle,
-				(*primary)->pipe, flags);
-			if (ret) {
-				EMGD_ERROR("unable to allocate command queues");
-			}
-		}
-#endif
 	}
 	if (secondary) {
 		EMGD_DEBUG("Attaching display 1 to secondary pointer");
 		*secondary = context->mod_dispatch.
 			dsp_display_list[IGD_DC_SECONDARY(dc)];
-#ifndef CONFIG_MICRO
-		if (*secondary && context->mod_dispatch.alloc_queues) {
-			ret = context->mod_dispatch.alloc_queues(driver_handle,
-				(*secondary)->pipe, flags);
-			if (ret) {
-				EMGD_ERROR("unable to allocate command queues");
-			}
-		}
-#endif
 	}
 
 	/*
@@ -1597,10 +1624,41 @@ int mode_init(igd_context_t *context)
 	mode_context->first_alter = TRUE;
 	mode_context->display_color =
 		context->mod_dispatch.init_params->display_color;
+#ifndef CONFIG_MICRO
 	mode_context->ref_freq =
 		context->mod_dispatch.init_params->ref_freq;
 	mode_context->tuning_wa =
 		context->mod_dispatch.init_params->tuning_wa;
+	/*To give option for validation*/
+	mode_context->clip_hw_fix =
+		context->mod_dispatch.init_params->clip_hw_fix;
+	mode_context->async_flip_wa =
+		context->mod_dispatch.init_params->async_flip_wa;
+	mode_context->en_reg_override =
+		context->mod_dispatch.init_params->en_reg_override;
+	mode_context->disp_arb =
+		context->mod_dispatch.init_params->disp_arb;
+	mode_context->fifo_watermark1 =
+		context->mod_dispatch.init_params->fifo_watermark1;
+	mode_context->fifo_watermark2 =
+		context->mod_dispatch.init_params->fifo_watermark2;
+	mode_context->fifo_watermark3 =
+		context->mod_dispatch.init_params->fifo_watermark3;
+	mode_context->fifo_watermark4 =
+		context->mod_dispatch.init_params->fifo_watermark4;
+	mode_context->fifo_watermark5 =
+		context->mod_dispatch.init_params->fifo_watermark5;
+	mode_context->fifo_watermark6 =
+		context->mod_dispatch.init_params->fifo_watermark6;
+	mode_context->gvd_hp_control =
+		context->mod_dispatch.init_params->gvd_hp_control;
+	mode_context->bunit_chicken_bits =
+		context->mod_dispatch.init_params->bunit_chicken_bits;
+	mode_context->bunit_write_flush =
+		context->mod_dispatch.init_params->bunit_write_flush;
+	mode_context->disp_chicken_bits =
+		context->mod_dispatch.init_params->disp_chicken_bits;
+#endif
 
 	/* Get mode's dispatch table */
 	mode_context->dispatch = (mode_dispatch_t *)
@@ -1610,6 +1668,15 @@ int mode_init(igd_context_t *context)
 		return -IGD_ERROR_NODEV;
 	}
 
+	/* Hook up KMS dispatch table */
+	mode_context->kms_dispatch = (mode_kms_dispatch_t *)
+		dispatch_acquire(context, mode_kms_dispatch);
+	if(!mode_context->kms_dispatch) {
+		EMGD_ERROR_EXIT("Unsupported Device");
+		return -IGD_ERROR_NODEV;
+	}
+
+
 	md = &context->mod_dispatch;
 
 	/* Set the fw_info to 0 */
@@ -1620,6 +1687,7 @@ int mode_init(igd_context_t *context)
 	dispatch->power_display = igd_power_display;
 	dispatch->query_mode_list = igd_query_mode_list;
 	dispatch->alter_displays = igd_alter_displays;
+	dispatch->igd_configure_display = igd_configure_display;
 
 	OPT_MICRO_CALL(full_mode_init(context, mode_context));
 
@@ -1652,11 +1720,19 @@ int mode_init(igd_context_t *context)
 	}
 
 	if (mode_context->dispatch->full && md->reg_get_mod_state) {
-		/* Save mode state */
 		module_state_h *state = NULL;
+
+		/* Save mode state for the regular case*/
 		unsigned long *flags = NULL;
-		md->reg_get_mod_state(REG_MODE_STATE, &state, &flags);
+		md->reg_get_mod_state(REG_MODE_STATE_REG, &state, &flags);
 		md->mode_save(context, state, flags);
+
+		/*Save mode state for the console case */
+		if (config_drm.init) {
+			state = NULL;
+			md->reg_get_mod_state(REG_MODE_STATE_CON, &state, &flags);
+			md->mode_save(context, state, flags);
+		}
 	}
 
 	/* Initialize the Display Configuration List */
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/mode_dispatch.h b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/mode_dispatch.h
index ecb7333..d89a733 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/mode_dispatch.h
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/mode_dispatch.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: mode_dispatch.h
- * $Revision: 1.13 $
+ * $Revision: 1.15 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -36,6 +36,24 @@
 
 #include <mode.h>
 
+
+
+typedef struct _mode_kms_dispatch {
+	void (*kms_program_pipe) (emgd_crtc_t *emgd_crtc);
+	void (*kms_set_pipe_pwr) (emgd_crtc_t *emgd_crtc, unsigned long enable);
+	void (*kms_program_plane)(emgd_crtc_t *emgd_crtc, unsigned long status);
+	void (*kms_set_plane_pwr)(emgd_crtc_t *emgd_crtc, unsigned long enable);
+	int  (*kms_program_port) (emgd_encoder_t *emgd_encoder,
+		unsigned long status);
+	int  (*kms_post_program_port)(emgd_encoder_t *emgd_encoder,
+		unsigned long status);
+	u32  (*kms_get_vblank_counter)(emgd_crtc_t *emgd_crtc);
+	int (*kms_match_mode)(emgd_encoder_t *emgd_encoder,
+		igd_framebuffer_info_t *fb_info, igd_timing_info_t **timing);
+} mode_kms_dispatch_t;
+
+
+
 typedef struct _mode_full_dispatch {
 	int (*alter_cursor_pos)(igd_display_h display_handle,
 		igd_cursor_info_t *cursor_info);
@@ -178,13 +196,16 @@ typedef struct _fw_info {
 
 } fw_info_t;
 
+
+
 typedef struct _mode_context {
 	/*
 	 * All of the below values will be initialized in mode module
 	 * init function mode_init().
 	 */
-	unsigned long  first_alter;
-	mode_dispatch_t *dispatch;
+	unsigned long        first_alter;
+	mode_dispatch_t     *dispatch;
+	mode_kms_dispatch_t *kms_dispatch;
 
 	igd_context_t *context;
 	unsigned long display_color;
@@ -197,6 +218,27 @@ typedef struct _mode_context {
     int splash;
 	unsigned long ref_freq;
 	int tuning_wa;
+	unsigned long clip_hw_fix;
+	unsigned long async_flip_wa;
+
+	/*
+	 * Enable override of following registers when en_reg_override=1.
+	 * Display Arbitration, FIFO Watermark Control, GVD HP_CONTROL,
+	 * Bunit Chickenbits, Bunit Write Flush, Display Chickenbits
+	 */
+	unsigned long en_reg_override;
+	unsigned long disp_arb;
+	unsigned long fifo_watermark1;
+	unsigned long fifo_watermark2;
+	unsigned long fifo_watermark3;
+	unsigned long fifo_watermark4;
+	unsigned long fifo_watermark5;
+	unsigned long fifo_watermark6;
+	unsigned long gvd_hp_control;
+	unsigned long bunit_chicken_bits;
+	unsigned long bunit_write_flush;
+	unsigned long disp_chicken_bits;
+
 } mode_context_t;
 
 extern int full_mode_init(igd_context_t *context,
@@ -232,6 +274,10 @@ extern mode_context_t mode_context[];
 extern mode_dispatch_t mode_dispatch_plb;
 extern mode_dispatch_t mode_dispatch_tnc;
 
+extern mode_kms_dispatch_t mode_kms_dispatch_plb;
+extern mode_kms_dispatch_t mode_kms_dispatch_tnc;
+
+
 
 /*******************************************************************************
  *
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/vga_mode.c b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/vga_mode.c
index ccfc165..546b699 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/cmn/vga_mode.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/cmn/vga_mode.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: vga_mode.c
- * $Revision: 1.7 $
+ * $Revision: 1.8 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -40,6 +40,8 @@
 
 #include <igd_vga.h>
 
+#include "drm_emgd_private.h"
+
 #include <mode.h>
 #include <utils.h>
 #include <vga.h>
@@ -88,6 +90,29 @@ void write_vga_reg(unsigned char *mmio, unsigned short port,
  *
  * @return void
  */
+void kms_program_plane_vga(unsigned char *mmio,
+	igd_timing_info_t *timings)
+{
+
+	EMGD_DEBUG("Enter program_plane_vga");
+
+	/* Set Bit 5 so the plane remains off.  It will be turned on
+	 * in the IAL.  This is necessary, so the clear screen can occur
+	 * before the mode is enabled. */
+	write_vga_reg(mmio, SR_PORT, 0x01,
+		(*vga_mode_data_ptr)[timings->mode_number].sr_regs[0] | 0x20);
+	OS_SLEEP(1000);
+
+	return;
+}
+
+/*!
+ *
+ * @param display
+ * @param timings
+ *
+ * @return void
+ */
 void program_plane_vga(igd_display_context_t *display,
 	igd_timing_info_t *timings)
 {
@@ -275,6 +300,157 @@ void write_next_gr_reg(unsigned char value)
  * This function programs the Timing registers and clock registers and
  * other control registers for PIPE.
  *
+ * @param emgd_crtc
+ * @param timings
+ *
+ * @return void
+ */
+void kms_program_pipe_vga(emgd_crtc_t *emgd_crtc,
+	igd_timing_info_t *timings)
+{
+	struct drm_device  *dev = NULL;
+	igd_context_t      *context = NULL;
+	igd_display_pipe_t *pipe = NULL;
+	unsigned char *mmio, i;
+	unsigned char *colors=0;
+	unsigned char palette_hack=0;
+	unsigned char *color_bits = 0;
+	int mode_index;
+	unsigned char msr_temp;
+
+	/* This is a mapping from the HAL mode number to the type of Palette
+	 * being programmed for this mode. */
+	char palette_type[] = {
+	/* 9=Don't care.
+	 *  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f */
+		1, 1, 1, 1, 1, 1, 1, 2,	9, 9, 9, 9, 9, 1, 1, 9,
+		9, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 4 };
+
+	EMGD_TRACE_ENTER;
+
+	pipe = emgd_crtc->igd_pipe;
+	dev = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+	mmio = (unsigned char *)context->device_context.virt_mmadr;
+	g_mmio = mmio;
+	mode_index = timings->mode_number;
+
+	EMGD_DEBUG("IGD Mode#:0x%x", mode_index);
+
+	/* Disable Group 0 Protection */
+	write_vga_reg(mmio, CR_PORT, 0x11, 0x00);
+
+	/*
+	 * Note: for monochrome modes this will cause the IO port to change
+	 * for the CRTC and the Status regs.
+	 */
+	 msr_temp = (*vga_mode_data_ptr)[mode_index].misc_reg;
+
+#ifdef CONFIG_GN4
+	/*
+	 * According to Chrontel the VGA By-pass requires the HSYNC and VSYNC to be
+	 * of positive polarity.  In the MSR - Miscellaneous Output register
+	 * Bit 7 is CRT VSYNC polarity (0 = Positive, 1 = Negative)
+	 * Bit 6 is CRT HSYNC polarity (0 = Positive, 1 = Negative)
+	 */
+	{
+		pt = get_port_type(emgd_crtc->crtc_id);
+		if (pt == IGD_PORT_DIGITAL) {
+			msr_temp &= (~(BIT(7)|BIT(6)));
+		}
+	}
+#endif
+	EMGD_WRITE8(msr_temp, EMGD_MMIO(mmio) + 0x3c2);
+
+	if((*vga_mode_data_ptr)[mode_index].misc_reg & 1) {
+		vga_port_offset = 0x20;
+	} else {
+		vga_port_offset = 0;
+	}
+
+	/* Sequencer registers */
+	/*
+	 * Note: Most specs say 0 in SR00 scratch bits but in practice seems
+	 * that everyone uses 3.
+	 */
+	write_vga_reg(mmio, SR_PORT, 0x00, 0x03);
+	/* SR01 is on/off and done in program plane */
+	for (i=2; i<=4; i++) {
+		write_vga_reg(mmio, SR_PORT, i,
+			/* The SR Regs in the table are from SR01-SR04, there is
+			 * no SR00 in the table, so -1. */
+			(*vga_mode_data_ptr)[mode_index].sr_regs[i-1]);
+	}
+
+	/* Graphics control registers 0x0-0x8,0x10 */
+	next_gr = 0;
+	for(i=0; i<=0x8; i++) {
+		write_next_gr_reg((*vga_mode_data_ptr)[mode_index].gr_regs[i]);
+	}
+	/*
+	 * GR10 is a non-standard register that controls the mapping of
+	 * 0xa000 to MMIO or GTT memory.
+	 */
+	next_gr = 0x10;
+	write_next_gr_reg(0x0);
+
+	next_ar = 0;
+	for(i=0; i<=0x13; i++) {
+		write_next_ar_reg((*vga_mode_data_ptr)[mode_index].ar_regs[i]);
+	}
+	/* Spec says 0x8 for text modes, not done in practice */
+	write_next_ar_reg(0x00);
+
+	/* Ensure the Pixel Data Mask Register does not mask the pixel data */
+	EMGD_WRITE8(0xFF, EMGD_MMIO(mmio) + 0x3c6);
+
+	/* set DAC data value */
+	EMGD_WRITE8(0, EMGD_MMIO(mmio) + 0x3c8);
+
+	/* Load RAMDAC*/
+	switch(palette_type[mode_index]){
+	case 0:
+		color_bits = p64_color_bits;
+		colors = normal_colors;
+		palette_hack = 0;
+		break;
+	case 1:
+		color_bits = p16_color_bits;
+		colors = normal_colors;
+		palette_hack = 1;
+		break;
+	case 2:
+		color_bits = mono_color_bits;
+		colors = mono_colors;
+		palette_hack = 0;
+		break;
+	default:
+		break;
+	}
+	/* Program the Palette based on the mode. */
+	if (!vga_disable_default_palette_load) {
+		if (color_bits) {
+			set_palette_vga(mmio, 64, color_bits, colors, palette_hack);
+			set_3f_palette(mmio, 192);
+		} else {
+			set_256_palette(mmio);
+		}
+	}
+
+	/* Timings */
+	next_cr = 0;
+	for(i=0; i<=0x18; i++) {
+		write_next_cr_reg((*vga_mode_data_ptr)[mode_index].crtc_regs[i]);
+	}
+
+	return;
+}
+
+
+/*!
+ * This function programs the Timing registers and clock registers and
+ * other control registers for PIPE.
+ *
  * @param display
  * @param timings
  *
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/plb/clocks_plb.c b/drivers/gpu/drm/emgd/emgd/display/mode/plb/clocks_plb.c
index 7fef510..78471b6 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/plb/clocks_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/plb/clocks_plb.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: clocks_plb.c
- * $Revision: 1.8 $
+ * $Revision: 1.10 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -44,6 +44,7 @@
 #include <pi.h>
 #include <sched.h>
 
+#include "drm_emgd_private.h"
 #include <plb/regs.h>
 
 /*!
@@ -345,6 +346,195 @@ static int get_clock(unsigned long dclk,
 
 /*!
  *
+ * @param emgd_crtc
+ * @param clock
+ * @param dclk
+ *
+ * @return 0 on success
+ * @return 1 on failure
+ */
+int kms_program_clock_plb(emgd_crtc_t *emgd_crtc,
+	igd_clock_t *clock,
+	unsigned long dclk)
+{
+	unsigned long m1, m2, n, p;
+	unsigned long control;
+	unsigned long ref_freq;
+	int ret;
+	unsigned long port_mult, vga_mult;
+	unsigned long dual_channel = 0;
+	unsigned long index;
+	unsigned long pt;
+	struct drm_device  *dev          = NULL;
+	igd_display_pipe_t *pipe         = NULL;
+	igd_context_t      *context      = NULL;
+	igd_display_port_t *port         = NULL;
+	struct drm_encoder *encoder      = NULL;
+	emgd_encoder_t     *emgd_encoder = NULL;
+
+	EMGD_DEBUG("Enter program_clock");
+
+	pipe = emgd_crtc->igd_pipe;
+	dev = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+
+	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+		if (((struct drm_crtc *)(&emgd_crtc->base)) == encoder->crtc) {
+			emgd_encoder = container_of(encoder, emgd_encoder_t, base);
+			port = emgd_encoder->igd_port;
+			pt = port->port_type;
+			break;
+		}
+	}
+	if (!port) {
+		EMGD_ERROR_EXIT("No port");
+		return -1;
+	}
+
+	if (dclk > 100000) {        /*	100-200 MHz	*/
+
+		port_mult = 1;
+	}
+	else if (dclk > 50000) {    /*	50-100 Mhz	*/
+
+		port_mult = 2;
+	}
+	else {                      /*	25-50 Mhz	*/
+
+		port_mult = 4;
+	}
+
+	/*
+	 * Clock Multiplier : sDVO ports on all plb chipsets
+	 */
+	if (pt == IGD_PORT_DIGITAL) {
+
+		dclk *= port_mult;
+	}
+
+	vga_mult = EMGD_READ32(context->device_context.virt_mmadr + clock->dpll_control) & 0x3;
+
+	/* For Int-LVDS need to find out if its dual channel and pass
+	 * that info into caluculating for p2. Apperently halving
+	 * of dot-clock is also required by Ch7017 when operating in
+	 * dual channel
+	 */
+	if (pt == IGD_PORT_LVDS) {
+		/* Find PD_ATTR_ID_2_CHANNEL_PANEL attr value*/
+		pi_pd_find_attr_and_value(port,
+				PD_ATTR_ID_2_CHANNEL_PANEL,
+				0/*no PD_FLAG for 2_channel*/,
+				NULL,
+				&dual_channel);
+	}
+
+	/* For external clock sources always use ref_clock == dclk */
+	if(port->pd_flags & PD_FLAG_CLK_SOURCE) {
+		ref_freq = dclk;
+	} else {
+		ref_freq = 96000;
+	}
+	/* LVDS reference clock can be 96 or 100 MHz. However there
+	 * are no mention in the specification to specify which register
+	 * to select/set this.
+	 */
+
+	/* When the clock source is provided externally by the port driver,
+	 * the allowed error range is 0. */
+	if(port->pd_flags & PD_FLAG_CLK_SOURCE) {
+		ret = get_clock(dclk, ref_freq, &m1, &m2, &n, &p, 0
+				,pt,dual_channel);
+	} else {
+		ret = get_clock(dclk, ref_freq, &m1, &m2, &n, &p, TARGET_ERROR
+				,pt,dual_channel);
+	}
+
+	if(ret) {
+		EMGD_ERROR("Clock %ld could not be programmed", dclk);
+		return ret;
+	}
+
+	/* Disable DPLL, Write an 0x80 into P for saftey */
+	control = 0x10000000 | (0x80<<clock->p_shift) | BIT26 | vga_mult;
+	EMGD_WRITE32(control, context->device_context.virt_mmadr + clock->dpll_control);
+
+	/* Program N, M1,and M2 */
+	EMGD_WRITE32((n<<16) | (m1<<8) | m2, context->device_context.virt_mmadr + clock->mnp);
+
+	/* Enable DPLL, Disable VGAm Mode and sitck in new P values */
+	if(pt == IGD_PORT_LVDS){
+		/* If LVDS set the appropriate bits for mode select */
+		control = (BIT31 | BIT28 | BIT27 )
+			| (p<<clock->p_shift) | vga_mult;
+
+		if(port->attr_list) {
+
+			for(index = 0; index < port->attr_list->num_attrs; index++) {
+
+				/* Set spread spectrum and pulse phase */
+				if(port->attr_list->attr[index].id == PD_ATTR_ID_SSC) {
+
+					/*
+					 * Pulse Phase for Poulsbo only has valid values between
+					 * 3 and 9
+					 */
+					if(port->attr_list->attr[index].value >= 3 &&
+						port->attr_list->attr[index].value <= 9) {
+
+						control |= BIT13 | BIT14;
+						/*
+						 * Set the Pulse Phase to the clock phase specified by
+						 * the user
+						 */
+						control |= (port->attr_list->attr[index].value<<9);
+					}
+					break;
+				}
+			}
+		}
+	} else{
+	/* else DAC/SDVO */
+		control = (BIT31 | BIT28 | BIT26) | (p<<clock->p_shift) | vga_mult;
+	}
+	/*
+	 * Poulsbo has high speed clock on always
+	 */
+	control |= BIT30;
+
+
+
+	/* Set the clock source correctly based on PD settings */
+	if(port->pd_flags & PD_FLAG_CLK_SOURCE) {
+		control |= port->clock_bits;
+	} else {
+		control |= port->clock_bits & ~0x00006000;
+	}
+
+	/* sDVO Multiplier bits[7:0] */
+	if (pt == IGD_PORT_DIGITAL) {
+
+		if (port_mult == 2) {
+
+			control |= (1 << 4);
+
+		} else if (port_mult == 4) {
+
+			control |= (3 << 4);
+		}
+	}
+
+	EMGD_WRITE32(control, context->device_context.virt_mmadr + clock->dpll_control);
+
+	/* We must wait for 150 us for the dpll clock to warm up */
+	OS_SLEEP(150);
+	pipe->dclk = dclk;
+
+	return 0;
+}
+
+
+/*!
+ *
  * @param display
  * @param clock
  * @param dclk
@@ -509,10 +699,3 @@ int program_clock_plb(igd_display_context_t *display,
 
 	return 0;
 }
-
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: clocks_plb.c,v 1.8 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/display/mode/plb/clocks_plb.c,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/plb/kms_mode_plb.c b/drivers/gpu/drm/emgd/emgd/display/mode/plb/kms_mode_plb.c
new file mode 100644
index 0000000..ec1546d
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/plb/kms_mode_plb.c
@@ -0,0 +1,1102 @@
+/*
+ *-----------------------------------------------------------------------------
+ * Filename: kms_mode_plb.c
+ * $Revision: 1.2 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2011, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ * Description:
+ *-----------------------------------------------------------------------------
+ */
+
+#define MODULE_NAME hal.mode
+
+
+#include <igd.h>
+#include <igd_pwr.h>
+#include <vga.h>
+#include <pi.h>
+#include <plb/regs.h>
+#include "drm_emgd_private.h"
+#include "../cmn/mode_dispatch.h"
+#include "../cmn/match.h"
+#include "mode_plb.h"
+#include <math_fix.h>
+#include <memory.h>
+
+
+/*------------------------------------------------------------------------------
+ * Function Prototypes
+ *----------------------------------------------------------------------------*/
+int kms_mode_get_stride_stereo_plb(igd_display_pipe_t *pipe,
+		igd_display_plane_t *plane,
+		unsigned long *stride,
+		unsigned long *stereo,
+		unsigned long flags);
+void kms_program_pipe_vga_plb(emgd_crtc_t *emgd_crtc);
+static void kms_program_pipe_plb(emgd_crtc_t *emgd_crtc);
+static void kms_set_pipe_pwr_plb(emgd_crtc_t *emgd_crtc, unsigned long enable);
+static void kms_program_plane_plb(emgd_crtc_t *emgd_crtc, unsigned long status);
+static void kms_set_plane_pwr_plb(emgd_crtc_t *emgd_crtc, unsigned long enable);
+static int set_color_correct_plb(emgd_crtc_t *emgd_crtc);
+
+
+extern int kms_program_clock_plb(emgd_crtc_t *emgd_crtc,
+	igd_clock_t *clock, unsigned long dclk);
+extern int wait_for_vblank_plb(unsigned char *mmio,
+	unsigned long pipe_reg);
+extern void kms_program_pipe_vga(emgd_crtc_t *emgd_crtc,
+	igd_timing_info_t *timings);
+extern void disable_vga_plb(unsigned char *mmio);
+
+
+/*------------------------------------------------------------------------------
+ * Global Variables
+ *----------------------------------------------------------------------------*/
+extern mode_data_plb_t device_data_plb[1];
+
+
+/*------------------------------------------------------------------------------
+ * KMS Dispatch Table
+ *----------------------------------------------------------------------------*/
+mode_kms_dispatch_t mode_kms_dispatch_plb = {
+	kms_program_pipe_plb,
+	kms_set_pipe_pwr_plb,
+	kms_program_plane_plb,
+	kms_set_plane_pwr_plb,
+	NULL,
+	NULL,
+	NULL,                       /* kms_get_vblank_counter */
+	kms_match_mode,
+};
+
+
+/*!
+ * Get the stride and stereo values based on the display.  This is also used
+ * by the MI instructions.
+ *
+ * @param pipe Pointer to hardware device instance data
+ * @param plane Pointer to hardware device instance data
+ * @param stride
+ * @param stereo
+ * @param flags Should the stereo be for the frontbuffer or backbuffer?
+ *
+ * @return stride - Stride of the display
+ * @return stereo - Stereo address of the display
+ */
+int kms_mode_get_stride_stereo_plb(igd_display_pipe_t *pipe,
+	igd_display_plane_t *plane,
+	unsigned long *stride,
+	unsigned long *stereo,
+	unsigned long flags)
+{
+	unsigned long pitch = plane->fb_info->screen_pitch;
+	igd_timing_info_t *timing = pipe->timing;
+	unsigned long base_offset;
+
+	base_offset = plane->fb_info->visible_offset;
+
+	*stride = pitch;
+	*stereo = 0;
+
+	/* For field replication, valid for interlaced modes only
+	 *     set stereo = fb_base,
+	 *         stride = pitch
+	 */
+	if (timing->mode_info_flags & IGD_SCAN_INTERLACE) {
+
+		if(timing->mode_info_flags & IGD_LINE_DOUBLE) {
+			/* Interlaced + Line double flags means field replication.
+			 * same lines are sent for both fields. Program the
+			 * second eye to be same as the first.
+			 */
+			*stereo = base_offset;
+		} else {
+			/* Regular interlaced. Second eye starts on line 2.
+			 * Skip every other line.
+			 */
+			*stereo = base_offset + pitch;
+			*stride = pitch * 2;
+		}
+	}
+
+	return 0;
+}
+
+
+
+/*!
+ *
+ * @param emgd_crtc
+ *
+ * @return 0 on success
+ * @return -IGD_ERROR_INVAL if color attributes not found
+ */
+static int set_color_correct_plb(emgd_crtc_t *emgd_crtc)
+{
+	const int        MID_PIXEL_VAL    = 125;
+	const int        MAX_PIXEL_VAL    = 255;
+	const int        NUM_PALETTE_ENTRIES = 256;
+
+	struct drm_device  *dev = NULL;
+	igd_context_t      *context = NULL;
+	igd_display_port_t *port = NULL;
+	igd_display_pipe_t *pipe = NULL;
+	struct drm_encoder *encoder = NULL;
+	emgd_encoder_t     *emgd_encoder = NULL;
+
+	unsigned int     gamma_r_max_24i_8f, gamma_r_min_24i_8f;
+	unsigned int     gamma_g_max_24i_8f, gamma_g_min_24i_8f;
+	unsigned int     gamma_b_max_24i_8f, gamma_b_min_24i_8f;
+	unsigned int     new_gamma_r_24i_8f, new_gamma_g_24i_8f;
+	unsigned int     new_gamma_b_24i_8f;
+	unsigned int     gamma_normal_r_24i_8f, gamma_normal_g_24i_8f;
+	unsigned int     gamma_normal_b_24i_8f;
+	int              brightness_factor_r, brightness_factor_g;
+	int              brightness_factor_b;
+	int              contrast_factor_r, contrast_factor_g;
+	int              contrast_factor_b;
+
+	unsigned int      *palette;
+	unsigned int      i;
+
+	igd_range_attr_t *gamma_attr      = NULL, *contrast_attr = NULL;
+	igd_range_attr_t *brightness_attr = NULL;
+	igd_attr_t       *hal_attr_list   = NULL;
+
+	EMGD_TRACE_ENTER;
+
+	pipe = emgd_crtc->igd_pipe;
+	dev = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+		if (((struct drm_crtc *)(&emgd_crtc->base)) == encoder->crtc) {
+			emgd_encoder = container_of(encoder, emgd_encoder_t, base);
+			port = emgd_encoder->igd_port;
+			break;
+		}
+	}
+	if (!port) {
+		EMGD_ERROR_EXIT("No port being used.");
+		return -IGD_ERROR_INVAL;
+	}
+	hal_attr_list  = port->attributes;
+
+	/* Using OS_ALLOC to avoid using > 1024 on stack (frame size warning ) */
+	palette = OS_ALLOC(sizeof (unsigned int) * NUM_PALETTE_ENTRIES);
+
+	/* start with a fresh palette */
+	for (i = 0; i < NUM_PALETTE_ENTRIES; i++) {
+		palette[i] = (i << 16) | (i << 8) | i;
+	}
+
+	/* get a pointer to gamma, contrast, and brightness attr */
+	i = 0;
+
+	while (PD_ATTR_LIST_END != hal_attr_list[i].id) {
+		switch (hal_attr_list[i].id) {
+		case PD_ATTR_ID_FB_GAMMA:
+			gamma_attr      = (igd_range_attr_t *) &hal_attr_list[i];
+			break;
+
+		case PD_ATTR_ID_FB_BRIGHTNESS:
+			brightness_attr = (igd_range_attr_t *) &hal_attr_list[i];
+			break;
+
+		case PD_ATTR_ID_FB_CONTRAST:
+			contrast_attr   = (igd_range_attr_t *) &hal_attr_list[i];
+			break;
+
+		default:
+			break;
+		}
+
+		i++;
+	}
+
+	if(!gamma_attr || !brightness_attr || !contrast_attr) {
+		EMGD_ERROR("Color Correction Atrributes not found!");
+		return -IGD_ERROR_INVAL;
+	}
+
+	/* Get the max and min */
+	gamma_r_max_24i_8f = ((gamma_attr->max >> 16) & 0xFF) << 3;
+	gamma_g_max_24i_8f = ((gamma_attr->max >>  8) & 0xFF) << 3;
+	gamma_b_max_24i_8f =  (gamma_attr->max        & 0xFF) << 3;
+
+	gamma_r_min_24i_8f = ((gamma_attr->min >> 16) & 0xFF) << 3;
+	gamma_g_min_24i_8f = ((gamma_attr->min >>  8) & 0xFF) << 3;
+	gamma_b_min_24i_8f =  (gamma_attr->min        & 0xFF) << 3;
+
+	/* The new gamma values are in 3i.5f format, but we must convert it
+	 * to 24i.8f format before passing it to OS_POW_FIX
+	 */
+	new_gamma_r_24i_8f = ((gamma_attr->current_value >> 16) & 0xFF) << 3;
+	new_gamma_g_24i_8f = ((gamma_attr->current_value >> 8) & 0xFF) << 3;
+	new_gamma_b_24i_8f = (gamma_attr->current_value & 0xFF) << 3;
+
+	/* make sure the new gamma is within range */
+	new_gamma_r_24i_8f = OS_MIN(gamma_r_max_24i_8f, new_gamma_r_24i_8f);
+	new_gamma_r_24i_8f = OS_MAX(gamma_r_min_24i_8f, new_gamma_r_24i_8f);
+	new_gamma_g_24i_8f = OS_MIN(gamma_g_max_24i_8f, new_gamma_g_24i_8f);
+	new_gamma_g_24i_8f = OS_MAX(gamma_g_min_24i_8f, new_gamma_g_24i_8f);
+	new_gamma_b_24i_8f = OS_MIN(gamma_b_max_24i_8f, new_gamma_b_24i_8f);
+	new_gamma_b_24i_8f = OS_MAX(gamma_b_min_24i_8f, new_gamma_b_24i_8f);
+
+
+	gamma_normal_r_24i_8f =
+		OS_POW_FIX(MAX_PIXEL_VAL, (1<<16)/new_gamma_r_24i_8f);
+
+	gamma_normal_g_24i_8f =
+		OS_POW_FIX(MAX_PIXEL_VAL, (1<<16)/new_gamma_g_24i_8f);
+
+	gamma_normal_b_24i_8f =
+		OS_POW_FIX(MAX_PIXEL_VAL, (1<<16)/new_gamma_b_24i_8f);
+
+	for( i = 0; i < NUM_PALETTE_ENTRIES; i++ ) {
+		unsigned int new_gamma;
+		unsigned int cur_color;
+		unsigned int cur_palette = palette[i];
+
+		/* Note that we do not try to calculate the gamma if it
+		 * is 1.0, e.g. 0x100.  This is to avoid round-off errors
+		 */
+
+		/* red: calculate and make sure the result is within range */
+		if (0x100 != new_gamma_r_24i_8f) {
+			cur_color  = (cur_palette >> 16) & 0xFF;
+			new_gamma  = OS_POW_FIX(cur_color, (1<<16)/new_gamma_r_24i_8f);
+			new_gamma  = (MAX_PIXEL_VAL * new_gamma)/gamma_normal_r_24i_8f;
+			palette[i] &= 0x00FFFF;
+			palette[i] |=
+				(OS_MIN(new_gamma, (unsigned) MAX_PIXEL_VAL) & 0xFF) << 16;
+		}
+
+		/* green: calculate and make sure the result is within range */
+		if (0x100 != new_gamma_g_24i_8f) {
+			cur_color  = (cur_palette >> 8) & 0xFF;
+			new_gamma  = OS_POW_FIX(cur_color, (1<<16)/new_gamma_g_24i_8f);
+			new_gamma  = (MAX_PIXEL_VAL * new_gamma)/gamma_normal_g_24i_8f;
+			palette[i] &= 0xFF00FF;
+			palette[i] |=
+				(OS_MIN(new_gamma, (unsigned) MAX_PIXEL_VAL) & 0xFF) << 8;
+		}
+
+		/* blue: calculate and make sure the result is within range */
+		if (0x100 != new_gamma_b_24i_8f) {
+			cur_color  = cur_palette & 0xFF;
+			new_gamma  = OS_POW_FIX(cur_color, (1<<16)/new_gamma_b_24i_8f);
+			new_gamma  = (MAX_PIXEL_VAL * new_gamma)/gamma_normal_b_24i_8f;
+			palette[i] &= 0xFFFF00;
+			palette[i] |=
+				(OS_MIN(new_gamma, (unsigned) MAX_PIXEL_VAL) & 0xFF);
+		}
+	}
+
+
+	/* Brightness correction */
+	brightness_factor_r = (brightness_attr->current_value >> 16) & 0xFF;
+	brightness_factor_g = (brightness_attr->current_value >> 8) & 0xFF;
+	brightness_factor_b = brightness_attr->current_value & 0xFF;
+
+	/* The factors are offset by 0x80 because 0x80 is 0 correction */
+	brightness_factor_r -= 0x80;
+	brightness_factor_g -= 0x80;
+	brightness_factor_b -= 0x80;
+
+	for( i = 0; i < NUM_PALETTE_ENTRIES; i++ ) {
+		int          new_pixel_val;
+		unsigned int cur_color;
+		unsigned int cur_palette = palette[i];
+
+		/* red: calculate and make sure the result is within range */
+		cur_color     =  (cur_palette >> 16) & 0xFF;
+		new_pixel_val =  cur_color + brightness_factor_r;
+		new_pixel_val =  OS_MIN(new_pixel_val, MAX_PIXEL_VAL);
+		palette[i]    &= 0x00FFFF;
+		palette[i]    |= (OS_MAX(new_pixel_val, 0) & 0xFF) << 16;
+
+		/* green: calculate and make sure the result is within range */
+		cur_color     =  (cur_palette >> 8) & 0xFF;
+		new_pixel_val =  cur_color + brightness_factor_g;
+		new_pixel_val =  OS_MIN(new_pixel_val, MAX_PIXEL_VAL);
+		palette[i]    &= 0xFF00FF;
+		palette[i]    |= (OS_MAX(new_pixel_val, 0) & 0xFF) << 8;
+
+		/* blue: calculate and make sure the result is within range */
+		cur_color     =  cur_palette & 0xFF;
+		new_pixel_val =  cur_color + brightness_factor_b;
+		new_pixel_val =  OS_MIN(new_pixel_val, MAX_PIXEL_VAL);
+		palette[i]    &= 0xFFFF00;
+		palette[i]    |= OS_MAX(new_pixel_val, 0) & 0xFF;
+	}
+
+
+	/* contrast correction */
+	contrast_factor_r = (contrast_attr->current_value >> 16) & 0xFF;
+	contrast_factor_g = (contrast_attr->current_value >> 8) & 0xFF;
+	contrast_factor_b = contrast_attr->current_value & 0xFF;
+
+	/* make sure values are within range */
+	contrast_factor_r -= 0x80;
+	contrast_factor_g -= 0x80;
+	contrast_factor_b -= 0x80;
+
+
+	/* We're doing integer division in this loop using 16i.16f
+	 * integers.  The result will then be converted back into a
+	 * regular, 32-bit integer
+	 */
+	for( i = 0; i < NUM_PALETTE_ENTRIES; i++ ) {
+		int new_pixel_val;
+		unsigned int cur_color;
+		unsigned int cur_palette = palette[i];
+
+		/* red: calculate and make sure the result is within range */
+		if (0 != contrast_factor_r ) {
+			cur_color     = (cur_palette >> 16) & 0xFF;
+			new_pixel_val =
+				(MAX_PIXEL_VAL << 16) / (MAX_PIXEL_VAL - contrast_factor_r);
+			new_pixel_val =   new_pixel_val * (cur_color - MID_PIXEL_VAL);
+			new_pixel_val >>= 16;  /* convert back to 32i format */
+			new_pixel_val +=  MID_PIXEL_VAL;
+			new_pixel_val =   OS_MIN(new_pixel_val, MAX_PIXEL_VAL);
+			palette[i]    &=  0x00FFFF;  /* clear out the R color */
+			palette[i]    |=  (OS_MAX(new_pixel_val, 0) & 0xFF) << 16;
+		}
+
+		/* green: calculate and make sure the result is within range */
+		if (0 != contrast_factor_g ) {
+			cur_color     = (cur_palette >> 8) & 0xFF;
+			new_pixel_val =
+				(MAX_PIXEL_VAL << 16) / (MAX_PIXEL_VAL - contrast_factor_g);
+			new_pixel_val =   new_pixel_val * (cur_color - MID_PIXEL_VAL);
+			new_pixel_val >>= 16;  /* convert back to 32i format */
+			new_pixel_val +=  MID_PIXEL_VAL;
+			new_pixel_val =   OS_MIN(new_pixel_val, MAX_PIXEL_VAL);
+			palette[i]    &=  0xFF00FF;  /* clear out the G color */
+			palette[i]    |=  (OS_MAX(new_pixel_val, 0) & 0xFF) << 8;
+		}
+
+		/* blue: calculate and make sure the result is within range */
+		if (0 != contrast_factor_b) {
+			cur_color     = cur_palette & 0xFF;
+			new_pixel_val =
+				(MAX_PIXEL_VAL << 16) / (MAX_PIXEL_VAL - contrast_factor_b);
+			new_pixel_val =   new_pixel_val * (cur_color - MID_PIXEL_VAL);
+			new_pixel_val >>= 16;  /* convert back to 32i format */
+			new_pixel_val +=  MID_PIXEL_VAL;
+			new_pixel_val =   OS_MIN(new_pixel_val, MAX_PIXEL_VAL);
+			palette[i]    &=  0xFFFF00;  /* clear out the B color */
+			palette[i]    |=   OS_MAX(new_pixel_val, 0) & 0xFF;
+		}
+	}
+
+
+	/* write the new values in the palette */
+	for (i = 0; i < NUM_PALETTE_ENTRIES; i++) {
+		EMGD_WRITE32(palette[i], context->device_context.virt_mmadr +
+			pipe->palette_reg + i*4);
+	}
+	OS_FREE(palette);
+
+	return 0;
+}
+
+
+
+/*!
+ *
+ * @param emgd_crtc Pointer to hardware device instance data
+ *
+ * @return void
+ */
+void kms_program_pipe_vga_plb(
+	emgd_crtc_t *emgd_crtc)
+{
+	struct drm_device  *dev          = NULL;
+	igd_timing_info_t  *timing       = NULL;
+	igd_display_pipe_t *pipe         = NULL;
+	igd_context_t      *context      = NULL;
+	struct drm_encoder *encoder      = NULL;
+	emgd_encoder_t     *emgd_encoder = NULL;
+	igd_display_port_t *port         = NULL;
+	unsigned long vga_control;
+	unsigned long upscale = 0;
+	int centering = 1;
+
+	EMGD_TRACE_ENTER;
+
+	pipe = emgd_crtc->igd_pipe;
+	dev = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+		if (((struct drm_crtc *)(&emgd_crtc->base)) == encoder->crtc) {
+			emgd_encoder = container_of(encoder, emgd_encoder_t, base);
+			port = emgd_encoder->igd_port;
+			break;
+		}
+	}
+
+#ifdef CONFIG_MICRO
+	/*
+	 * We cannot set a VGA mode unless the display planes are turned off.
+     * This becomes evident during a Windows BSOD.  Since neither Windows
+     * nor IEGD got a chance to turn off these registers, and the VGA mode was
+     * set by the VBIOS, the screen gets corrupted.  In order to fix this
+     * problem, we will turn the cursor and display planes here.
+     *
+     * Note: Removing previous partial-fix in favor of this complete one.
+	 */
+    /* Cursor A */
+	EMGD_WRITE32(0, context->device_context.virt_mmadr + 0x70080);
+	EMGD_WRITE32(0, context->device_context.virt_mmadr + 0x70084);
+    /* Cursor B */
+	EMGD_WRITE32(0, context->device_context.virt_mmadr + 0x700C0);
+	EMGD_WRITE32(0, context->device_context.virt_mmadr + 0x700C4);
+    /* Display A */
+	EMGD_WRITE32(0, context->device_context.virt_mmadr + 0x70180);
+	EMGD_WRITE32(0, context->device_context.virt_mmadr + 0x70184);
+    /* Display B */
+	EMGD_WRITE32(0, context->device_context.virt_mmadr + 0x71180);
+	EMGD_WRITE32(0, context->device_context.virt_mmadr + 0x71184);
+    /* Display C */
+	EMGD_WRITE32(0, context->device_context.virt_mmadr + 0x72180);
+	EMGD_WRITE32(0, context->device_context.virt_mmadr + 0x72184);
+#endif
+
+	/*
+	 * VGA Plane can attach to only one pipe at a time. LVDS can
+	 * only attach to pipe B. We need to use the display passed to
+	 * determine the pipe number to use. (Plba is same as Alm).
+	 */
+
+	/*
+	 * We can come here with following cases:
+	 *   1. magic->vga    CRT, DVI type displays
+	 *   2. native->vga   int-lvds, and up-scaling lvds displays
+	 *   3. pipe->vga     TV and other unscaled-lvds displays
+	 */
+	vga_control = EMGD_READ32(context->device_context.virt_mmadr + 0x71400);
+	vga_control &= 0x18e3ff00;
+	vga_control |= 0x8e;
+
+	timing = pipe->timing;
+	if(!timing->extn_ptr) {
+		EMGD_ERROR_EXIT("No Extension pointer in program_pipe_vga_plb");
+		return;
+	}
+
+	if (port) {
+		/* Find UPSCALING attr value*/
+		pi_pd_find_attr_and_value(port,
+			PD_ATTR_ID_PANEL_FIT,
+			0,/*no PD_FLAG for UPSCALING */
+			NULL, /* dont need the attr ptr*/
+			&upscale);
+		/* this PI func will not modify value of upscale if attr does not exist */
+	}
+
+	/* magic->vga or native->vga cases */
+	if ((timing->width == 720 && timing->height == 400) || upscale) {
+		centering = 0;
+	}
+
+	/* Enable border */
+	if((timing->width >= 800) && !upscale) {
+		EMGD_DEBUG("Enable VGA Border");
+		vga_control |= (1L<<26);
+	}
+
+	if(timing->width == 640) {
+		EMGD_DEBUG("Enable Nine Dot Disable");
+		vga_control |= (1L<<18);
+	}
+
+	if(centering) {
+		EMGD_DEBUG("Enable VGA Center Centering");
+		vga_control |= 1L<<24;
+
+		if(timing->height >= 960) {
+			if(timing->width >= 1280) {
+				EMGD_DEBUG("Enable VGA 2x (Nine Dot Disable)");
+				vga_control |= (1L<<30) | (1L<<18);
+			}
+		}
+	} else {
+		if (port) {
+			if(port->port_type == IGD_PORT_LVDS) {
+				EMGD_DEBUG("Enable VGA Upper-Left Centering & Nine Dot Disable");
+				vga_control |= (1L<<25 | (1L<<18));
+			} else if (upscale) {
+				EMGD_DEBUG("Enable VGA Center Upper-left for upscale ports");
+				vga_control |= 1L<<25;
+			}
+		}
+	}
+
+	if(pipe->pipe_num) {
+		vga_control |= 1L<<29;
+	}
+
+	kms_program_pipe_vga(emgd_crtc, (igd_timing_info_t *)timing->extn_ptr);
+	EMGD_WRITE32(vga_control, context->device_context.virt_mmadr + 0x71400);
+
+	EMGD_TRACE_EXIT;
+	return;
+}
+
+
+
+/**
+ * kms_set_pipe_pwr_plb
+ *
+ * Turns the pipe ON or OFF depending on the input
+ *
+ * @param emgd_crtc (IN) specifies the pipe to change
+ * @param enable    (IN) TRUE to enable pipe, FALSE to disable
+ *
+ * @return
+ */
+static void kms_set_pipe_pwr_plb(emgd_crtc_t *emgd_crtc, unsigned long enable)
+{
+	unsigned long       pipe_conf;
+	struct drm_device  *dev;
+	igd_display_pipe_t *pipe;
+	igd_context_t      *context;
+
+
+	EMGD_TRACE_ENTER;
+
+
+	dev       = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
+	context   = ((drm_emgd_priv_t *)dev->dev_private)->context;
+
+	pipe      = emgd_crtc->igd_pipe;
+	pipe_conf = device_data_plb->pipe_preserve &
+		EMGD_READ32(context->device_context.virt_mmadr + pipe->pipe_reg);
+
+
+	/* Do nothing if current power state is same as what we want to set */
+	/* The PIPE_ENABLE bit is at bit-position 31 */
+	if ( (enable << 31) == (pipe_conf & PIPE_ENABLE) ){
+
+		EMGD_TRACE_EXIT;
+		return;
+	}
+
+
+	if (!enable) {
+		/* Disable pipe */
+		EMGD_WRITE32(pipe_conf & ~PIPE_ENABLE,
+			context->device_context.virt_mmadr + pipe->pipe_reg);
+
+		EMGD_DEBUG("Set Pipe Power: OFF");
+
+	} else {
+		/* Enable pipe */
+		EMGD_WRITE32(pipe_conf | PIPE_ENABLE,
+			context->device_context.virt_mmadr + pipe->pipe_reg);
+
+		EMGD_DEBUG("Set Pipe Power: ON");
+	}
+
+
+	EMGD_TRACE_EXIT;
+	return;
+}
+
+
+
+/*!
+ * This function programs the Timing registers and clock registers and
+ * other control registers for PIPE.
+ *
+ * @param emgd_crtc
+ * @param status
+ *
+ * @return void
+ */
+static void kms_program_pipe_plb(emgd_crtc_t *emgd_crtc)
+{
+	unsigned long       timing_reg;
+	unsigned long       pipe_conf;
+	unsigned long       hactive, vactive;
+	igd_timing_info_t  *pTimings;
+	unsigned long       temp;
+	struct drm_device  *dev     = NULL;
+	igd_context_t      *context = NULL;
+	igd_display_pipe_t *pipe    = NULL;
+	igd_display_port_t *port    = NULL;
+	int i;
+
+	EMGD_TRACE_ENTER;
+
+
+	pipe = emgd_crtc->igd_pipe;
+	dev = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+
+	EMGD_DEBUG("Device power state: D%ld", context->device_context.power_state);
+
+	pipe_conf = device_data_plb->pipe_preserve &
+		EMGD_READ32(context->device_context.virt_mmadr + pipe->pipe_reg);
+
+	/* Reset the plane of this pipe back to NULL, it will be set on the
+	 * call to program_plane, which is ok, since program_pipe occurs
+	 * before program_plane */
+	pipe->plane = NULL;
+
+	pTimings = pipe->timing;
+
+	/*
+	 * If the mode is VGA and the PD says it handles all VGA modes without
+	 * reprogramming then just set the mode and leave centering off.
+	 */
+	if(pTimings->mode_info_flags & IGD_MODE_VESA) {
+		if (pTimings->mode_number <= VGA_MODE_NUM_MAX) {
+			/* Pipe timings and clocks are not used but it must be on anyway */
+			EMGD_WRITE32(pipe_conf | 0x80000000,
+				context->device_context.virt_mmadr + pipe->pipe_reg);
+
+			kms_program_pipe_vga_plb(emgd_crtc);
+			return;
+		}
+	}
+
+	/* Program dot clock divisors. */
+	kms_program_clock_plb(emgd_crtc, pipe->clock_reg, pTimings->dclk);
+
+	/* Program timing registers for the pipe */
+	timing_reg = pipe->timing_reg;
+	if (pTimings->mode_info_flags & IGD_PIXEL_DOUBLE) {
+		hactive = (unsigned long)pTimings->width*2 - 1;
+	} else {
+		hactive = (unsigned long)pTimings->width - 1;
+	}
+
+	if (pTimings->mode_info_flags & IGD_LINE_DOUBLE) {
+		if (pTimings->mode_info_flags & IGD_SCAN_INTERLACE) {
+			vactive = (unsigned long)pTimings->height - 1;
+		} else {
+			vactive = (unsigned long)pTimings->height*2 - 1;
+		}
+	} else {
+		if (pTimings->mode_info_flags & IGD_SCAN_INTERLACE) {
+			vactive = (unsigned long)pTimings->height/2 - 1;
+		} else {
+			vactive = (unsigned long)pTimings->height - 1;
+		}
+	}
+
+	/*
+	 * DPLL should be on at this point which is required for touching
+	 * the palette.
+	 */
+	/* reset the palette */
+	for (i = 0; i < 256; i++) {
+		EMGD_WRITE32(((i<<16) | (i<<8) | i),
+			context->device_context.virt_mmadr + pipe->palette_reg + i*4);
+	}
+
+	/* apply color correction */
+	for( i = 0; PD_ATTR_LIST_END != port->attributes[i].id; i++ ) {
+
+		if ((PD_ATTR_ID_FB_GAMMA      == (port->attributes[i].id)) ||
+			(PD_ATTR_ID_FB_BRIGHTNESS == (port->attributes[i].id)) ||
+			(PD_ATTR_ID_FB_BRIGHTNESS == (port->attributes[i].id)))  {
+
+			set_color_correct_plb(emgd_crtc);
+		}
+	}
+
+
+	/*
+	 * NOTE: For size reasons the timng table contains unsigned short
+	 * values. Don't shift them past 16. Use a temp instead.
+	 * All register offsets and bit shift are verified for Napa
+	 */
+	temp = ((unsigned long)pTimings->htotal << 16) | hactive;
+	EMGD_WRITE32(temp, context->device_context.virt_mmadr + timing_reg);
+
+	temp = ((unsigned long)pTimings->hblank_end << 16) |
+		(unsigned long)pTimings->hblank_start;
+	EMGD_WRITE32(temp, context->device_context.virt_mmadr + timing_reg + 0x04);
+
+	temp = ((unsigned long)pTimings->hsync_end << 16) |
+		(unsigned long)pTimings->hsync_start;
+	EMGD_WRITE32(temp, context->device_context.virt_mmadr + timing_reg + 0x08);
+
+	temp = ((unsigned long)pTimings->vtotal << 16) | vactive;
+	EMGD_WRITE32(temp, context->device_context.virt_mmadr + timing_reg + 0x0C);
+
+	temp = ((unsigned long)pTimings->vblank_end << 16) |
+		(unsigned long)pTimings->vblank_start;
+	EMGD_WRITE32(temp, context->device_context.virt_mmadr + timing_reg + 0x10);
+
+	temp = ((unsigned long)pTimings->vsync_end << 16) |
+		(unsigned long)pTimings->vsync_start;
+	EMGD_WRITE32(temp, context->device_context.virt_mmadr + timing_reg + 0x14);
+
+	/*
+	 * If there is a linked mode it is either the VGA or a scaled
+	 * mode. If it is scaled then we need to use it as the source size.
+	 */
+	if(pTimings->extn_ptr) {
+		igd_timing_info_t *scaled_timings =
+			(igd_timing_info_t *)pTimings->extn_ptr;
+		if((scaled_timings->mode_info_flags & IGD_MODE_VESA) &&
+			(scaled_timings->mode_number <= VGA_MODE_NUM_MAX)) {
+			temp = (hactive << 16) | vactive;
+		} else {
+			temp = (unsigned long)scaled_timings->width  - 1;
+			temp = (temp << 16) |
+				(unsigned long)(scaled_timings->height - 1);
+		}
+	} else {
+		temp = (hactive << 16) | vactive;
+	}
+	EMGD_WRITE32(temp, context->device_context.virt_mmadr + timing_reg + 0x1C);
+
+	/* Set other registers */
+
+	/*
+	 * FIXME: max_dclk needs to be determined from core clock
+	 * at init time. 915 etc has several skus with different
+	 * clocks for the same device ID.
+	 *
+	 */
+
+	/* These values are derived from the Poulsbo B-Spec as
+	 * the suggested values */
+	EMGD_WRITE32(device_data_plb->fw_blc1,
+		context->device_context.virt_mmadr + FW_BLC1);
+	EMGD_WRITE32(device_data_plb->fw_blc2,
+		context->device_context.virt_mmadr + FW_BLC2);
+	EMGD_WRITE32(device_data_plb->fw_blc3,
+		context->device_context.virt_mmadr + FW_BLC3);
+	EMGD_WRITE32(device_data_plb->fw_self,
+		context->device_context.virt_mmadr + FW_BLC_SELF);
+	EMGD_WRITE32(device_data_plb->dsp_arb,
+		context->device_context.virt_mmadr + PIPEA_DISP_ARB_CTRL);
+
+	/* The SGX 2D engine can saturate the memory bus and starve
+	 * the display engine causing visible screen tearing.
+	 * This reduces the priority of the SGX vs. display engine
+	 */
+	temp = EMGD_READ32(context->device_context.virt_mmadr + G_DEBUG);
+	EMGD_WRITE32((temp | (1 << 11)),
+		context->device_context.virt_mmadr + G_DEBUG);
+
+	EMGD_WRITE32(pipe_conf,
+		context->device_context.virt_mmadr + pipe->pipe_reg);
+
+	/*
+	 * Set the VGA address range to 0xa0000 so that a normal (not VGA)
+	 * mode can be accessed through 0xa0000 in a 16bit world.
+	 */
+	WRITE_AR(context->device_context.virt_mmadr, 0x10, 0xb);
+	WRITE_VGA(context->device_context.virt_mmadr, GR_PORT, 0x06, 0x5);
+	WRITE_VGA(context->device_context.virt_mmadr, GR_PORT, 0x10, 0x1);
+
+	if(pTimings->extn_ptr) {
+		/* This means either internal scaling (LVDS) or centered VGA */
+		pTimings = pTimings->extn_ptr;
+		if(pTimings->extn_ptr) {
+			/* This is both the scaled and centered VGA */
+			pTimings = pTimings->extn_ptr;
+		}
+		if(pTimings->mode_info_flags & IGD_MODE_VESA) {
+			if (pTimings->mode_number <= VGA_MODE_NUM_MAX) {
+				kms_program_pipe_vga_plb(emgd_crtc);
+			}
+		}
+	}
+
+	EMGD_TRACE_EXIT;
+	return;
+}
+
+
+
+/*!
+ * kms_set_plane_pwr_plb
+ *
+ * Enables or disables the plane associated with the given CRTC
+ *
+ * @param enable [IN] turns the plane on or off
+ *
+ * @return void
+ */
+static void kms_set_plane_pwr_plb(emgd_crtc_t *emgd_crtc, unsigned long enable)
+{
+	unsigned long           plane_control;
+	unsigned long           plane_reg;
+	struct drm_device      *dev         = NULL;
+	igd_display_plane_t    *plane       = NULL;
+	igd_display_pipe_t     *pipe        = NULL;
+	igd_context_t          *context     = NULL;
+
+	EMGD_TRACE_ENTER;
+
+	EMGD_DEBUG("Program Plane: %s", enable?"ENABLE":"DISABLE");
+
+	pipe    = emgd_crtc->igd_pipe;
+	dev     = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+	plane   = PLANE(pipe->owner);
+
+	if (!plane) {
+		EMGD_ERROR_EXIT("Trying to set power to a plane that is not tied "
+			" to a crtc.");
+		return;
+	}
+
+	/* In case a plane update is already in progress */
+	wait_for_vblank_plb(context->device_context.virt_mmadr, pipe->pipe_reg);
+
+	/* Get the current value of the plane control register */
+	plane_reg     = plane->plane_reg;
+	plane_control = EMGD_READ32(context->device_context.virt_mmadr + plane_reg);
+
+	if(plane->plane_reg == DSPACNTR) {
+		plane_control &= device_data_plb->plane_a_preserve;
+	} else { /* if it's plane b or plane c */
+		plane_control &= device_data_plb->plane_b_c_preserve;
+	}
+
+
+	if((enable == FALSE) ||
+		(context->device_context.power_state != IGD_POWERSTATE_D0)) {
+
+		/*
+		 * Note: The vga programming code does not have an "off". So
+		 * when programming the plane to off we make sure VGA is off
+		 * as well.
+		 */
+		disable_vga_plb(context->device_context.virt_mmadr);
+
+		/*
+		 * To turn off plane A or B, the program have to trigger the plane A
+		 * or B start register.  Or else, it will not work.
+		 */
+		plane_control &= 0xEFFFFFFF;
+
+		EMGD_WRITE32(plane_control,
+						context->device_context.virt_mmadr + plane_reg);
+
+		EMGD_WRITE32(EMGD_READ32(context->device_context.virt_mmadr +
+			plane_reg + DSP_START_OFFSET),
+			context->device_context.virt_mmadr + plane_reg + DSP_START_OFFSET);
+	} else {
+		/* Enable Pipe */
+		plane_control |= 0x80000000;
+
+		EMGD_WRITE32(plane_control,
+			context->device_context.virt_mmadr + plane_reg);
+	}
+
+
+	wait_for_vblank_plb(context->device_context.virt_mmadr, pipe->pipe_reg);
+	EMGD_TRACE_EXIT;
+
+	return;
+}
+
+
+
+/*!
+ * Program Display Plane Values.
+ *
+ * @param emgd_crtc Pointer to hardware device instance data
+ *
+ * @return void
+ */
+static void kms_program_plane_plb(emgd_crtc_t *emgd_crtc,
+	unsigned long status)
+{
+	unsigned long stereo;
+	unsigned long stride;
+	unsigned long size;
+	unsigned long plane_control;
+	unsigned long plane_reg;
+	unsigned long start_addr_reg;
+	igd_timing_info_t      *timing  = NULL;
+	struct drm_device      *dev     = NULL;
+	igd_display_plane_t    *plane   = NULL;
+	igd_display_pipe_t     *pipe    = NULL;
+	igd_context_t          *context = NULL;
+	igd_framebuffer_info_t *fb_info = NULL;
+
+	EMGD_TRACE_ENTER;
+
+	pipe = emgd_crtc->igd_pipe;
+	dev = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+
+	plane   = PLANE(pipe->owner);
+	fb_info = plane->fb_info;
+	plane_reg = plane->plane_reg;
+	start_addr_reg = DSPAADDR;
+
+	EMGD_DEBUG("Device power state: D%ld", context->device_context.power_state);
+
+	wait_for_vblank_plb(context->device_context.virt_mmadr, pipe->pipe_reg);
+
+	plane_control = EMGD_READ32(context->device_context.virt_mmadr + plane_reg);
+	if(plane->plane_reg == DSPACNTR) {
+		plane_control &= device_data_plb->plane_a_preserve;
+	}
+	else { /* if it's plane b or plane c */
+		plane_control &= device_data_plb->plane_b_c_preserve;
+		start_addr_reg = 0x71184;
+	}
+
+	if((status == FALSE) ||
+		(context->device_context.power_state != IGD_POWERSTATE_D0)) {
+
+		/*
+		 * Note: The vga programming code does not have an "off". So
+		 * when programming the plane to off we make sure VGA is off
+		 * as well.
+		 */
+		disable_vga_plb(context->device_context.virt_mmadr);
+
+		/*
+		 * To turn off plane A or B, the program have to triger the plane A or B
+		 * start register.  Or else, it will not work.
+		 */
+		EMGD_WRITE32(plane_control, context->device_context.virt_mmadr + plane_reg);
+		EMGD_WRITE32(EMGD_READ32(context->device_context.virt_mmadr + start_addr_reg),
+			context->device_context.virt_mmadr + start_addr_reg);
+
+		wait_for_vblank_plb(context->device_context.virt_mmadr, pipe->pipe_reg);
+		return;
+	}
+	/*
+	 * Note: The very first pass through this function will be with
+	 * status false and timings == NULL. Don't use the timings before
+	 * the check above.
+	 */
+	timing = pipe->timing;
+	/* There is a special case code for legacy VGA modes */
+	while (timing->extn_ptr) {
+		timing = (igd_timing_info_t *)timing->extn_ptr;
+	}
+	if(MODE_IS_VGA(timing)) {
+		kms_program_plane_vga(context->device_context.virt_mmadr, timing);
+		return;
+	}
+
+	disable_vga_plb(context->device_context.virt_mmadr);
+
+	size = (((unsigned long)timing->height - 1)<<16) |
+		(unsigned long)(timing->width - 1);
+
+	/* enable plane, select pipe, enable gamma correction logic */
+	plane_control |= 0x80000000 | (pipe->pipe_num<<24);
+	pipe->plane = plane;
+#ifndef CONFIG_MICRO
+	plane_control |= (1<<30);
+#endif
+
+	/* Here the settings:
+	 *   If line + pixel dbling, set 21,20 to 01b, and set Horz Multiply
+	 *   If line dbling only,    set 21,20 to 11b
+	 *   If pixel dbling only,   set 21,20 to 00b, but set Horz Multiply
+	 *   If no doubling,         set 21,20 to 00b (no Horz Multiply)
+	 * For pixel doubling
+	 *           --> both progressive/interlaced modes
+	 * For Line doubling
+	 *           --> progressive modes only
+	 */
+
+	if (!(timing->mode_info_flags & IGD_SCAN_INTERLACE)) {
+		/* Line doubling in progressive mode requires special bits */
+		if (timing->mode_info_flags & IGD_LINE_DOUBLE) {
+			/* BIT 20 for line & pixel doubling*/
+			plane_control |= BIT20;
+			/* check later, if no pixel doubling, set bit 21 too*/
+		}
+	}
+	if (timing->mode_info_flags & IGD_PIXEL_DOUBLE) {
+		/* Horz pixel multiply must be set for double */
+		plane_control |= BIT11;
+		/* TODO -> Plba can more than double,
+		It can 3X, 4X etc. These arent exposed now */
+	}
+	else if(plane_control & BIT20){
+		/* For line ONLY doubling, set bit 21 also '1' */
+		plane_control |= BIT21;
+	}
+
+	kms_mode_get_stride_stereo_plb(pipe, plane, &stride, &stereo, 0);
+
+	/* set color depth */
+	switch (IGD_PF_DEPTH(fb_info->pixel_format)) {
+	case PF_DEPTH_8:
+		plane_control |= BIT27 | BIT30;
+		break;
+	case PF_DEPTH_16:
+		plane_control |= BIT28 | BIT26;
+		break;
+	default:
+	case PF_DEPTH_32:
+		plane_control |= BIT28 | BIT27;
+		break;
+	}
+
+	if(fb_info->flags & IGD_ENABLE_DISPLAY_GAMMA) {
+		plane_control |= (BIT30);
+	}
+
+	EMGD_DEBUG(" Plane Control = 0x%lx", plane_control);
+	EMGD_DEBUG(" Plane Base = 0x%lx", fb_info->visible_offset);
+	EMGD_DEBUG(" Plane Pitch = 0x%lx", stride);
+	EMGD_DEBUG(" Plane Size = 0x%lx", size);
+
+	EMGD_WRITE32(stride, context->device_context.virt_mmadr + plane_reg + DSP_STRIDE_OFFSET);
+	/*
+	 * In reality this only exists for plane B. It doesn't seem to hurt
+	 * plane A so just do it anyway and save us another case.
+	 */
+	EMGD_WRITE32(size, context->device_context.virt_mmadr + plane_reg + DSP_SIZE_OFFSET);
+
+	/*EMGD_WRITE32(stereo, MMIO(display) + plane_reg + DSP_STEREO_OFFSET);
+		- This register is Reserved ON plba */
+	EMGD_WRITE32(fb_info->visible_offset,
+		context->device_context.virt_mmadr + plane_reg + DSP_START_OFFSET);
+
+	/* It seems we need push or trigger plane A/B to start to work
+	 * on Poulsbo, especially for sDVO port. Let's write plane control
+	 * register and start address register at last.
+	 */
+	EMGD_WRITE32(plane_control, context->device_context.virt_mmadr + plane_reg);
+	EMGD_WRITE32(EMGD_READ32(context->device_context.virt_mmadr + start_addr_reg),
+		context->device_context.virt_mmadr + start_addr_reg);
+
+	wait_for_vblank_plb(context->device_context.virt_mmadr, pipe->pipe_reg);
+
+	EMGD_TRACE_EXIT;
+	return;
+}
+
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/plb/micro_mode_plb.c b/drivers/gpu/drm/emgd/emgd/display/mode/plb/micro_mode_plb.c
index 60352e6..21c85bb 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/plb/micro_mode_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/plb/micro_mode_plb.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: micro_mode_plb.c
- * $Revision: 1.19 $
+ * $Revision: 1.21 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -57,9 +57,11 @@
 #include <plb/regs.h>
 #include <plb/context.h>
 #include <plb/mi.h>
+#include "drm_emgd_private.h"
 
 #include "../cmn/match.h"
 #include "../cmn/mode_dispatch.h"
+#include "mode_plb.h"
 
 /*!
  * @addtogroup display_group
@@ -68,19 +70,6 @@
 
 #ifdef CONFIG_PLB
 
-typedef struct _mode_data_plb {
-	unsigned long plane_a_preserve;
-	unsigned long plane_b_c_preserve;
-	unsigned long pipe_preserve;
-	unsigned long port_preserve;
-	unsigned long fw_blc1;
-	unsigned long fw_blc2;
-	unsigned long fw_blc3;
-	unsigned long fw_self;
-	unsigned long mem_mode;
-	unsigned long dsp_arb;
-}mode_data_plb_t;
-
 /*
  * Exports from the other components of this module.
  */
@@ -99,7 +88,7 @@ static unsigned long gpio_plb[] = {
 	0x5028
 };
 
-static mode_data_plb_t device_data[1] = {
+mode_data_plb_t device_data_plb[1] = {
 	{
 		0x000b0000, /* plane a preservation */
 		0x00000000, /* plane b/c preservation */
@@ -114,14 +103,13 @@ static mode_data_plb_t device_data[1] = {
 	}
 };
 
-
 /*!
  *
  * @param mmio
  *
  * @return void
  */
-static void disable_vga_plb (unsigned char *mmio)
+void disable_vga_plb (unsigned char *mmio)
 {
 	unsigned long temp;
 	unsigned char sr01;
@@ -300,6 +288,7 @@ int wait_for_vblank_plb(unsigned char *mmio,
 	return wait_for_vblank_timeout_plb(mmio, pipe_reg, 100);
 } /* wait_for_vblank_plb */
 
+
 /*!
  * This procedure waits for the next vertical blanking (vertical retrace)
  * period. If the display is already in a vertical blanking period, this
@@ -435,11 +424,6 @@ static void program_pipe_vga_plb(
 		return;
 	}
 
-	/*
-	 * FIXME: For CONFIG_NEW_MATCH this should be replaced with a simple
-	 *  check of fp_native_dtd. Do not query the attribute.
-	 */
-
 	/* Find UPSCALING attr value*/
 	pi_pd_find_attr_and_value(PORT_OWNER(display),
 			PD_ATTR_ID_PANEL_FIT,
@@ -495,7 +479,6 @@ static void program_pipe_vga_plb(
 	return;
 }
 
-
 /*!
  * Program Display Plane Values.
  *
@@ -525,10 +508,10 @@ static void program_plane_plb(igd_display_context_t *display,
 
 	plane_control = EMGD_READ32(MMIO(display) + plane_reg);
 	if(PLANE(display)->plane_reg == DSPACNTR) {
-		plane_control &= device_data->plane_a_preserve;
+		plane_control &= device_data_plb->plane_a_preserve;
 	}
 	else { /* if it's plane b or plane c */
-		plane_control &= device_data->plane_b_c_preserve;
+		plane_control &= device_data_plb->plane_b_c_preserve;
 		start_addr_reg = 0x71184;
 	}
 
@@ -687,7 +670,7 @@ static void program_pipe_plb(igd_display_context_t *display,
 	EMGD_DEBUG("Program Pipe: %s", status?"ENABLE":"DISABLE");
 	EMGD_DEBUG("Device power state: D%ld", GET_DEVICE_POWER_STATE(display));
 
-	pipe_conf = device_data->pipe_preserve &
+	pipe_conf = device_data_plb->pipe_preserve &
 		EMGD_READ32(MMIO(display) + PIPE(display)->pipe_reg);
 
 	/* Reset the plane of this pipe back to NULL, it will be set on the
@@ -831,11 +814,11 @@ static void program_pipe_plb(igd_display_context_t *display,
 
 	/* These values are derived from the Poulsbo B-Spec as
 	 * the suggested values */
-	WRITE_MMIO_REG (display, FW_BLC1, device_data->fw_blc1);
-	WRITE_MMIO_REG (display, FW_BLC2, device_data->fw_blc2);
-	WRITE_MMIO_REG (display, FW_BLC3, device_data->fw_blc3);
-	WRITE_MMIO_REG (display, FW_BLC_SELF, device_data->fw_self);
-	WRITE_MMIO_REG (display, DSP_ARB, device_data->dsp_arb);
+	WRITE_MMIO_REG (display, FW_BLC1, device_data_plb->fw_blc1);
+	WRITE_MMIO_REG (display, FW_BLC2, device_data_plb->fw_blc2);
+	WRITE_MMIO_REG (display, FW_BLC3, device_data_plb->fw_blc3);
+	WRITE_MMIO_REG (display, FW_BLC_SELF, device_data_plb->fw_self);
+	WRITE_MMIO_REG (display, PIPEA_DISP_ARB_CTRL, device_data_plb->dsp_arb);
 
 	/* The SGX 2D engine can saturate the memory bus and starve
 	 * the display engine causing visible screen tearing.
@@ -942,6 +925,13 @@ static void reset_plane_pipe_ports_plb(igd_context_t *context)
 		EMGD_WRITE32((temp & ~BIT31), EMGD_MMIO(mmio) + port->port_reg);
 	}
 
+	/* disable plane C */
+	temp = EMGD_READ32(EMGD_MMIO(mmio) + DSPCCNTR);
+	if(temp & BIT31) {
+		EMGD_WRITE32(0x0, EMGD_MMIO(mmio) + DSPCCNTR);
+		EMGD_WRITE32(0x0, EMGD_MMIO(mmio) + DSPCCNTR + DSP_START_OFFSET);
+	}
+
 	plane = NULL;
 	while ((plane = md->dsp_get_next_plane(context, plane, 1)) != NULL) {
 		/* Only display display planes.
@@ -952,11 +942,11 @@ static void reset_plane_pipe_ports_plb(igd_context_t *context)
 		if ((plane->plane_features & IGD_PLANE_DISPLAY)) {
 			if ( temp & BIT31 ) {
 				if(plane->plane_reg == DSPACNTR) {
-					EMGD_WRITE32((temp & device_data->plane_a_preserve),
+					EMGD_WRITE32((temp & device_data_plb->plane_a_preserve),
 						EMGD_MMIO(mmio) + plane->plane_reg);
 				}
 				else { /* if it's plane b or plane c */
-					EMGD_WRITE32((temp & device_data->plane_b_c_preserve),
+					EMGD_WRITE32((temp & device_data_plb->plane_b_c_preserve),
 						EMGD_MMIO(mmio) + plane->plane_reg);
 				}
 				EMGD_WRITE32(0, EMGD_MMIO(mmio) + plane->plane_reg+4);
@@ -974,7 +964,7 @@ static void reset_plane_pipe_ports_plb(igd_context_t *context)
 		wait_for_vblank_plb(EMGD_MMIO(mmio), pipe->pipe_reg);
 		temp = EMGD_READ32(EMGD_MMIO(mmio) + pipe->pipe_reg);
 		if ( temp & BIT31 ) {
-			EMGD_WRITE32((temp & device_data->pipe_preserve),
+			EMGD_WRITE32((temp & device_data_plb->pipe_preserve),
 				EMGD_MMIO(mmio) + pipe->pipe_reg);
 		}
 	}
@@ -1376,7 +1366,7 @@ mode_dispatch_t mode_dispatch_plb = {
 	NULL,
 	NULL,
 	NULL,
-	OPT_MICRO_VALUE(&mode_full_dispatch_plb, NULL)
+	OPT_MICRO_VALUE(&mode_full_dispatch_plb, NULL),
 };
 
 #endif
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c b/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c
index d5eef1f..95973e0 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: mode_plb.c
- * $Revision: 1.29 $
+ * $Revision: 1.33 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -51,6 +51,7 @@
 #include <plb/mi.h>
 #include <plb/cmd.h>
 
+#include "drm_emgd_private.h"
 #include "../cmn/match.h"
 #include "../cmn/mode_dispatch.h"
 
@@ -70,10 +71,16 @@ static emgd_vblank_callback_t interrupt_callbacks_plb[IGD_MAX_PORTS] =
  */
 static unsigned long vblank_interrupt_state = 0;
 
+/* This variables keeps track of the number of clients currently using
+ * the vblank interrupt
+ */
+static int vblank_interrupt_ref_cnt_port2 = 0;
+static int vblank_interrupt_ref_cnt_port4 = 0;
+
 /* Spin lock for synchronization of the vblank_interrupt_state variable,
  * between the VBlank interrupt handler and the non-interrupt handler code:
  */
-static spinlock_t vblank_lock = SPIN_LOCK_UNLOCKED;
+DEFINE_SPINLOCK(vblank_lock_plb);
 
 
 
@@ -86,6 +93,8 @@ int check_flip_pending_plb(unsigned char *mmio, unsigned long pipe_status_reg);
  */
 int wait_for_vblank_plb(unsigned char *mmio, unsigned long pipe_reg);
 
+
+
 /*!
  *
  * @param display
@@ -841,6 +850,11 @@ static int igd_set_surface_plb(igd_display_h display_handle,
 	case IGD_BUFFER_DEPTH:
 		EMGD_TRACE_EXIT;
 		return 0;
+	case IGD_BUFFER_SAVE:
+		PLANE(display)->fb_info->saved_offset = surface->offset;
+		EMGD_DEBUG("saving surface_offset = 0x%08lx", surface->offset);
+		EMGD_TRACE_EXIT;
+		return 0;
 	default:
 		EMGD_ERROR("Invalid type in set_surface");
 		break;
@@ -1423,7 +1437,7 @@ static irqreturn_t interrupt_handler_plb(int irq, void* mmio)
 	/* Detect whether a vblank interrupt occured, and if so, what type of
 	 * processing is needed (do the simple processing now):
 	 */
-	spin_lock_irqsave(&vblank_lock, lock_flags);
+	spin_lock_irqsave(&vblank_lock_plb, lock_flags);
 	if ((port2_interrupt = iir & BIT7 /* Port 2/Pipe A/SDVO-B */) != 0) {
 		if ((tmp = vblank_interrupt_state & VBLANK_INT4_PORT2) != 0) {
 			/* Record "answers" for all requestors: */
@@ -1436,17 +1450,25 @@ static irqreturn_t interrupt_handler_plb(int irq, void* mmio)
 			vblank_interrupt_state |= VBINT_ANSWER4_REQUEST(tmp);
 		}
 	}
-	spin_unlock_irqrestore(&vblank_lock, lock_flags);
+	spin_unlock_irqrestore(&vblank_lock_plb, lock_flags);
 
 	/* Call any registered/enabled callbacks for this interrupt: */
 	cb = &interrupt_callbacks_plb[2];
-	if (cb->callback &&
+	if (port2_interrupt && cb->callback &&
 		(vblank_interrupt_state & VBINT_ANSWER(VBINT_CB, VBINT_PORT2))) {
+		/* Clear the state to indicate the vblank has occured prior to
+		 * invoking the callback.
+		 */
+		vblank_interrupt_state &= ~VBINT_ANSWER(VBINT_CB, VBINT_PORT2);
 		cb->callback(cb->priv);
 	}
 	cb = &interrupt_callbacks_plb[4];
-	if (cb->callback &&
+	if (port4_interrupt && cb->callback &&
 		(vblank_interrupt_state & VBINT_ANSWER(VBINT_CB, VBINT_PORT4))) {
+		/* Clear the state to indicate the vblank has occured prior to
+		 * invoking the callback.
+		 */
+		vblank_interrupt_state &= ~VBINT_ANSWER(VBINT_CB, VBINT_PORT4);
 		cb->callback(cb->priv);
 	}
 
@@ -1522,7 +1544,7 @@ int request_vblanks_plb(unsigned long request_for, unsigned char *mmio)
 	}
 
 	/* Lock here to stop the interrupt handler until after changing bits: */
-	spin_lock_irqsave(&vblank_lock, lock_flags);
+	spin_lock_irqsave(&vblank_lock_plb, lock_flags);
 
 	/* Enable interrupts for the requested purpose/port, actually touching the
 	 * hardware registers if newly enabling interrupts for the given port/pipe:
@@ -1555,6 +1577,7 @@ int request_vblanks_plb(unsigned long request_for, unsigned char *mmio)
 			EMGD_WRITE32((tmp | BIT7), EMGD_MMIO(mmio) + IER);
 		}
 		vblank_interrupt_state |= request_for;
+		vblank_interrupt_ref_cnt_port2++;
 	} else /* if (request_for & VBLANK_INT4_PORT4) */ {
 		if (!VBLANK_INTERRUPTS_ENABLED4_PORT4) {
 			/* 1. Change Pipe Display Status Register for this pipe: set the
@@ -1583,15 +1606,18 @@ int request_vblanks_plb(unsigned long request_for, unsigned char *mmio)
 			EMGD_WRITE32((tmp | BIT5), EMGD_MMIO(mmio) + IER);
 		}
 		vblank_interrupt_state |= request_for;
+		vblank_interrupt_ref_cnt_port4++;
 	}
 
 	/* Unlock to allow the interrupt handler to proceed: */
-	spin_unlock_irqrestore(&vblank_lock, lock_flags);
+	spin_unlock_irqrestore(&vblank_lock_plb, lock_flags);
 
 	EMGD_TRACE_EXIT;
 	return 0;
 }
 
+
+
 /*!
  * Implementation of "protected" function (i.e. for use within the mode
  * module) to end a previous request VBlank interrupts for a particular
@@ -1623,76 +1649,95 @@ int end_request_plb(unsigned long request_for, unsigned char *mmio)
 	}
 
 	/* Lock here to stop the interrupt handler until after changing bits: */
-	spin_lock_irqsave(&vblank_lock, lock_flags);
+	spin_lock_irqsave(&vblank_lock_plb, lock_flags);
 
 	/* Disable interrupts for the requested purpose/port, actually touching the
 	 * hardware registers no software wants interrupts for the given port/pipe:
 	 */
 	if (request_for & VBLANK_INT4_PORT2) {
-		/* Turn off both the request and the answer bits: */
-		tmp = request_for & VBLANK_INT4_PORT2;
-		vblank_interrupt_state &= ~(tmp | VBINT_ANSWER4_REQUEST(tmp));
-		if (!VBLANK_INTERRUPTS_ENABLED4_PORT2) {
-			/* 1. Change Pipe Display Status Register for this pipe: clear the
-			 *    Vertical Blank Interrupt Enable bit & clear (by setting) the
-			 *    Vertical Blank Interrupt Status bit:
-			 */
-			tmp = EMGD_READ32(EMGD_MMIO(mmio) + PIPEA_STAT);
-			/* Clear bits that are written by a 1, so we don't clear them: */
-			tmp = tmp & (~PIPESTAT_STS_BITS);
-			EMGD_WRITE32(((tmp & (~VBLANK_STS_EN)) | VBLANK_STS),
-				EMGD_MMIO(mmio) + PIPEA_STAT);
-			EMGD_READ32(EMGD_MMIO(mmio) + PIPEA_STAT);
-
-			/* 2. Clear the Interrupt Enable Register bit for this pipe: */
-			tmp = EMGD_READ32(EMGD_MMIO(mmio) + IER);
-			EMGD_WRITE32((tmp & (~BIT7)), EMGD_MMIO(mmio) + IER);
-
-			/* 3. Set the Interrupt Mask Register bit for this pipe: */
-			tmp = EMGD_READ32(EMGD_MMIO(mmio) + IMR);
-			EMGD_WRITE32((tmp | BIT7), EMGD_MMIO(mmio) + IMR);
+		/* Decrement reference count */
+		vblank_interrupt_ref_cnt_port2--;
+		if (0 > vblank_interrupt_ref_cnt_port2) {
+			EMGD_DEBUG("WARNING:  Disabled vblank INT too many times.");
+			vblank_interrupt_ref_cnt_port2 = 0;
+		}
 
-			/* 4. Just in case, clear (by setting) the Interrupt Identity
-			 *    Register bit for this pipe:
-			 */
-			tmp = EMGD_READ32(EMGD_MMIO(mmio) + IIR);
-			EMGD_WRITE32((tmp | BIT7), EMGD_MMIO(mmio) + IIR);
+		if (0 == vblank_interrupt_ref_cnt_port2) {
+			/* Turn off both the request and the answer bits: */
+			tmp = request_for & VBLANK_INT4_PORT2;
+			vblank_interrupt_state &= ~(tmp | VBINT_ANSWER4_REQUEST(tmp));
+			if (!VBLANK_INTERRUPTS_ENABLED4_PORT2) {
+				/* 1. Change Pipe Display Status Register for this pipe: clear
+				 *    the Vertical Blank Interrupt Enable bit & clear (by
+				 *    setting) the Vertical Blank Interrupt Status bit:
+				 */
+				 tmp = EMGD_READ32(EMGD_MMIO(mmio) + PIPEA_STAT);
+				 /* Clear bits that are written by a 1, so don't clear them: */
+				 tmp = tmp & (~PIPESTAT_STS_BITS);
+				 EMGD_WRITE32(((tmp & (~VBLANK_STS_EN)) | VBLANK_STS),
+				 	EMGD_MMIO(mmio) + PIPEA_STAT);
+				 EMGD_READ32(EMGD_MMIO(mmio) + PIPEA_STAT);
+
+				 /* 2. Clear the Interrupt Enable Register bit for this pipe: */
+				 tmp = EMGD_READ32(EMGD_MMIO(mmio) + IER);
+				 EMGD_WRITE32((tmp & (~BIT7)), EMGD_MMIO(mmio) + IER);
+
+				 /* 3. Set the Interrupt Mask Register bit for this pipe: */
+				 tmp = EMGD_READ32(EMGD_MMIO(mmio) + IMR);
+				 EMGD_WRITE32((tmp | BIT7), EMGD_MMIO(mmio) + IMR);
+
+				 /* 4. Just in case, clear (by setting) the Interrupt Identity
+				  *    Register bit for this pipe:
+				  */
+				 tmp = EMGD_READ32(EMGD_MMIO(mmio) + IIR);
+				 EMGD_WRITE32((tmp | BIT7), EMGD_MMIO(mmio) + IIR);
+			}
 		}
 	}
-	if (request_for & VBLANK_INT4_PORT4) {
-		/* Turn off both the request and the answer bits: */
-		tmp = request_for & VBLANK_INT4_PORT4;
-		vblank_interrupt_state &= ~(tmp | VBINT_ANSWER4_REQUEST(tmp));
-		if (!VBLANK_INTERRUPTS_ENABLED4_PORT4) {
-			/* 1. Change Pipe Display Status Register for this pipe: clear the
-			 *    Vertical Blank Interrupt Enable bit & clear (by setting) the
-			 *    Vertical Blank Interrupt Status bit:
-			 */
-			tmp = EMGD_READ32(EMGD_MMIO(mmio) + PIPEB_STAT);
-			/* Clear bits that are written by a 1, so we don't clear them: */
-			tmp = tmp & (~PIPESTAT_STS_BITS);
-			EMGD_WRITE32(((tmp & (~VBLANK_STS_EN)) | VBLANK_STS),
-				EMGD_MMIO(mmio) + PIPEB_STAT);
-			EMGD_READ32(EMGD_MMIO(mmio) + PIPEB_STAT);
-
-			/* 2. Clear the Interrupt Enable Register bit for this pipe: */
-			tmp = EMGD_READ32(EMGD_MMIO(mmio) + IER);
-			EMGD_WRITE32((tmp & (~BIT5)), EMGD_MMIO(mmio) + IER);
 
-			/* 3. Set the Interrupt Mask Register bit for this pipe: */
-			tmp = EMGD_READ32(EMGD_MMIO(mmio) + IMR);
-			EMGD_WRITE32((tmp | BIT5), EMGD_MMIO(mmio) + IMR);
+	if (request_for & VBLANK_INT4_PORT4) {
+		/* Decrement reference count */
+		vblank_interrupt_ref_cnt_port4--;
+		if (0 > vblank_interrupt_ref_cnt_port4) {
+			EMGD_DEBUG("WARNING:  Disabled vblank INT too many times.");
+			vblank_interrupt_ref_cnt_port4 = 0;
+		}
 
-			/* 4. Just in case, clear (by setting) the Interrupt Identity
-			 *    Register bit for this pipe:
-			 */
-			tmp = EMGD_READ32(EMGD_MMIO(mmio) + IIR);
-			EMGD_WRITE32((tmp | BIT5), EMGD_MMIO(mmio) + IIR);
+		if (0 == vblank_interrupt_ref_cnt_port4) {
+			/* Turn off both the request and the answer bits: */
+			tmp = request_for & VBLANK_INT4_PORT4;
+			vblank_interrupt_state &= ~(tmp | VBINT_ANSWER4_REQUEST(tmp));
+			if (!VBLANK_INTERRUPTS_ENABLED4_PORT4) {
+				/* 1. Change Pipe Display Status Register for this pipe: clear
+				 *    the Vertical Blank Interrupt Enable bit & clear (by
+				 *    setting the Vertical Blank Interrupt Status bit:
+				 */
+				tmp = EMGD_READ32(EMGD_MMIO(mmio) + PIPEB_STAT);
+				/* Clear bits that are written by a 1, so don't clear them: */
+				tmp = tmp & (~PIPESTAT_STS_BITS);
+				EMGD_WRITE32(((tmp & (~VBLANK_STS_EN)) | VBLANK_STS),
+					EMGD_MMIO(mmio) + PIPEB_STAT);
+				EMGD_READ32(EMGD_MMIO(mmio) + PIPEB_STAT);
+
+				/* 2. Clear the Interrupt Enable Register bit for this pipe: */
+				tmp = EMGD_READ32(EMGD_MMIO(mmio) + IER);
+				EMGD_WRITE32((tmp & (~BIT5)), EMGD_MMIO(mmio) + IER);
+
+				/* 3. Set the Interrupt Mask Register bit for this pipe: */
+				tmp = EMGD_READ32(EMGD_MMIO(mmio) + IMR);
+				EMGD_WRITE32((tmp | BIT5), EMGD_MMIO(mmio) + IMR);
+
+				/* 4. Just in case, clear (by setting) the Interrupt Identity
+				*    Register bit for this pipe:
+				*/
+				tmp = EMGD_READ32(EMGD_MMIO(mmio) + IIR);
+				EMGD_WRITE32((tmp | BIT5), EMGD_MMIO(mmio) + IIR);
+			}
 		}
 	}
 
 	/* Unlock to allow the interrupt handler to proceed: */
-	spin_unlock_irqrestore(&vblank_lock, lock_flags);
+	spin_unlock_irqrestore(&vblank_lock_plb, lock_flags);
 
 	/* If we've completely disabled all causes for interrupts, unregister the
 	 * interrupt handler:
@@ -1827,7 +1872,7 @@ void disable_vblank_callback_plb(emgd_vblank_callback_h callback_h)
 
 	if (callback_h == ALL_PORT_CALLBACKS) {
 		/* Need to do some push-ups in order to get interrupts disabled: */
-		spin_lock_irqsave(&vblank_lock, lock_flags);
+		spin_lock_irqsave(&vblank_lock_plb, lock_flags);
 		enable_for = (VBLANK_INT4_PORT2 | VBLANK_INT4_PORT4);
 		if (!VBLANK_INTERRUPTS_ENABLED) {
 			/* Nothing has enabled interrupts, so there's no interrupt handler
@@ -1839,13 +1884,13 @@ void disable_vblank_callback_plb(emgd_vblank_callback_h callback_h)
 			vblank_interrupt_state = (VBLANK_INT4_PORT2 |
 				VBLANK_INT4_PORT4);
 		}
-		spin_unlock_irqrestore(&vblank_lock, lock_flags);
+		spin_unlock_irqrestore(&vblank_lock_plb, lock_flags);
 
 		end_request_plb(enable_for, mmio);
 
-		spin_lock_irqsave(&vblank_lock, lock_flags);
+		spin_lock_irqsave(&vblank_lock_plb, lock_flags);
 		vblank_interrupt_state = 0;
-		spin_unlock_irqrestore(&vblank_lock, lock_flags);
+		spin_unlock_irqrestore(&vblank_lock_plb, lock_flags);
 	} else {
 		emgd_vblank_callback_t *cb =
 			(emgd_vblank_callback_t *) callback_h;
@@ -1885,8 +1930,3 @@ mode_full_dispatch_t mode_full_dispatch_plb = {
 	vblank_occured_plb,
 };
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: mode_plb.c,v 1.29 2011/03/02 22:47:05 astead Exp $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.h b/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.h
new file mode 100644
index 0000000..0c42d29
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/plb/mode_plb.h
@@ -0,0 +1,47 @@
+/*
+ *-----------------------------------------------------------------------------
+ * Filename: mode_plb.h
+ * $Revision: 1.2 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2011, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+#define MODULE_NAME hal.mode
+
+
+#ifdef CONFIG_PLB
+
+typedef struct _mode_data_plb {
+	unsigned long plane_a_preserve;
+	unsigned long plane_b_c_preserve;
+	unsigned long pipe_preserve;
+	unsigned long port_preserve;
+	unsigned long fw_blc1;
+	unsigned long fw_blc2;
+	unsigned long fw_blc3;
+	unsigned long fw_self;
+	unsigned long mem_mode;
+	unsigned long dsp_arb;
+}mode_data_plb_t;
+
+#endif
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/clocks_tnc.c b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/clocks_tnc.c
index 8c9d595..b786900 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/clocks_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/clocks_tnc.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: clocks_tnc.c
- * $Revision: 1.15 $
+ * $Revision: 1.17 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -45,6 +45,7 @@
 #include <mode.h>
 #include <pi.h>
 #include <intelpci.h>
+#include "drm_emgd_private.h"
 
 #include <tnc/regs.h>
 
@@ -59,10 +60,11 @@ static int flag_enable_cdvo_reset = 1;
 #define FLAG(a) 1
 #endif
 
-
+extern unsigned long get_port_type(int crtc_id);
 static void wait_dpll(void);
 
 static int program_cdvo(igd_display_context_t *display);
+static int kms_program_cdvo(emgd_crtc_t *emgd_crtc);
 
 static cdvo_regs_t cdvo_reset[] = {
            /*turn off the SDVO port*/
@@ -469,6 +471,158 @@ static int get_clock(unsigned long dclk,
 
 /*!
  *
+ * @param emgd_crtc
+ * @param clock
+ * @param dclk
+ *
+ * @return 0 on success
+ * @return 1 on failure
+ */
+int kms_program_clock_lvds_tnc(emgd_crtc_t *emgd_crtc,
+	igd_clock_t *clock,
+	unsigned long dclk)
+{
+	struct drm_device  *dev = NULL;
+	igd_display_pipe_t *pipe = NULL;
+	igd_context_t      *context = NULL;
+	igd_display_port_t *port = NULL;
+	struct drm_encoder *encoder = NULL;
+	emgd_encoder_t     *emgd_encoder = NULL;
+	unsigned long pt;
+	int ret;
+	unsigned long m, n, p1;
+	unsigned long control;
+	unsigned long ref_freq;
+	tnc_limits_t *l = NULL;
+	unsigned long count;
+
+	EMGD_TRACE_ENTER;
+
+	pipe = emgd_crtc->igd_pipe;
+	dev = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+	pt = get_port_type(emgd_crtc->crtc_id);
+
+	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+		if (((struct drm_crtc *)(&emgd_crtc->base)) == encoder->crtc) {
+			emgd_encoder = container_of(encoder, emgd_encoder_t, base);
+			port = emgd_encoder->igd_port;
+			break;
+		}
+	}
+
+
+	/* LNC ref_freq is determined by SKU, convert to KHz */
+#if 0
+	ref_freq = display->context->device_context.gfx_freq * 1000L;
+#else
+	ref_freq = context->device_context.core_freq;
+	ref_freq = ref_freq * 1000;
+#endif
+
+#if 0
+	/* Find m,n,p,vco limits */
+	if (ref_freq == 200000) {
+		l = &tnc_lvds_limits[0];
+	} else if (ref_freq == 100000) {
+		l = &tnc_lvds_limits[1];
+	} else if (ref_freq == 166000) {
+		l = &tnc_lvds_limits[2];
+	}
+#endif
+
+	for(count=0; count<3; count++){
+		if (tnc_lvds_limits[count].ref_freq == ref_freq){
+			l = &tnc_lvds_limits[count];
+			break;
+		}
+	}
+
+/* PO Debug */
+#if 0
+	/* WRITE_PORT80(0xED); */
+
+	if(ref_freq == 166000){
+	WRITE_PORT80(0xEF);
+	}
+
+	if (!l){
+		/* FATAL ERROR */
+		DEAD_LOOP(0xDD);
+	}
+#endif
+
+	/* Per UMG, there is no defined target_error for LVDS, it supposed to
+	 * work for all expected dclks. */
+#if 1
+	if (port) {
+		ret = get_clock(dclk, ref_freq, l, &m, &n, &p1, dclk /* target_error */,
+			port->port_type, &clock->actual_dclk, port->pd_driver->type);
+	} else {
+		ret = 1;
+	}
+	if (ret) {
+		EMGD_ERROR_EXIT("Clock %ld could not be programmed", dclk);
+		/* DEAD_LOOP(0xFF); */
+		return ret;
+	}
+#else
+	/* Hard code the values for now */
+	m = 0x2D;  // ITP uses 0x2E, should change
+	p1 = 2;
+
+#endif
+
+#if 0
+	/* If clocks are already running at required clocks, just return */
+	if (PIPE(display)->dclk == dclk) {
+		return 0;
+	}
+#endif
+
+	/* Disable DPLL */
+#if 0
+	control = BIT28 | (1<<clock->p_shift); //Why are we shifting 1 to P1, GMA carry over???
+#else
+	control = BIT28;
+#endif
+	EMGD_WRITE32(control, context->device_context.virt_mmadr + clock->dpll_control);
+	EMGD_DEBUG("lvds: EMGD_WRITE32: 0x%lx = 0x%lx",
+		clock->dpll_control, control);
+
+	/* Program M */
+	EMGD_WRITE32((m<<8), context->device_context.virt_mmadr + clock->mnp);
+
+	EMGD_WRITE32((m<<8), context->device_context.virt_mmadr + 0xF044); //BUGBUG
+
+	EMGD_DEBUG("lvds: EMGD_WRITE32: 0x%lx = 0x%lx",
+		clock->mnp, (m<<8));
+
+	/* Enable DPLL */
+	control = (BIT31 | BIT28 | BIT27) | (p1<<clock->p_shift);
+
+/* PO Debug..*/
+#if 0
+	/* set VCO select */
+	if (ref_freq == 166000) {
+		control |= BIT16;
+	}
+#endif
+
+
+	EMGD_WRITE32(control, context->device_context.virt_mmadr + clock->dpll_control);
+	EMGD_DEBUG("lvds: EMGD_WRITE32: 0x%lx = 0x%lx",
+		clock->dpll_control, control);
+
+	/* Wait 150us for the DPLL to stabilize */
+	OS_SLEEP(150);
+	pipe->dclk = dclk;
+
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+/*!
+ *
  * @param display
  * @param clock
  * @param dclk
@@ -600,6 +754,135 @@ int program_clock_lvds_tnc(igd_display_context_t *display,
 
 /*!
  *
+ * @param emgd_crtc
+ * @param clock
+ * @param dclk
+ *
+ * @return 0 on success
+ * @return 1 on failure
+ */
+int kms_program_clock_sdvo_tnc(emgd_crtc_t *emgd_crtc,
+	igd_clock_t *clock,
+	unsigned long dclk)
+{
+	struct drm_device  *dev          = NULL;
+	igd_display_pipe_t *pipe         = NULL;
+	igd_context_t      *context      = NULL;
+	igd_display_port_t *port         = NULL;
+	struct drm_encoder *encoder      = NULL;
+	emgd_encoder_t     *emgd_encoder = NULL;
+	unsigned long pt;
+	int ret;
+	unsigned long m, n, p1;
+	unsigned long control;
+	unsigned long ref_freq;
+	unsigned long port_mult, vga_mult;
+	unsigned long target_error, actual_dclk;
+	tnc_limits_t *l;
+
+	EMGD_DEBUG("Enter program_clock");
+
+	pipe = emgd_crtc->igd_pipe;
+	dev = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+	pt = get_port_type(emgd_crtc->crtc_id);
+
+	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+		if (((struct drm_crtc *)(&emgd_crtc->base)) == encoder->crtc) {
+			emgd_encoder = container_of(encoder, emgd_encoder_t, base);
+			port = emgd_encoder->igd_port;
+			break;
+		}
+	}
+	if (!port) {
+		EMGD_ERROR_EXIT("No port");
+		return -1;
+	}
+
+	/* FIXME: No info available in EAS and waiting for info. */
+	if (dclk > 100000) {          /* 100-200 MHz */
+		port_mult = 1;
+	} else if (dclk > 50000) {    /* 50-100 Mhz */
+		port_mult = 2;
+	} else {                      /* 25-50 Mhz */
+		port_mult = 4;
+	}
+
+	dclk *= port_mult;
+
+	l = &tnc_sdvo_limits[0];
+	ref_freq = l->ref_freq;
+
+	vga_mult = READ_MMIO_REG_TNC(IGD_PORT_SDVO, clock->dpll_control) & 0x3;
+
+	target_error = TARGET_ERROR;
+
+	/* For external clock sources always use ref_clock == dclk */
+	if(port->pd_flags & PD_FLAG_CLK_SOURCE) {
+		ref_freq = dclk;
+		/* When clock source sdvo device, allowed error is 0. */
+		target_error = 0;
+	}
+
+	if (port) {
+		ret = get_clock(dclk, ref_freq, l, &m, &n, &p1, target_error,
+			IGD_PORT_SDVO, &actual_dclk, port->pd_driver->type);
+	} else {
+		ret = 1;
+	}
+
+	clock->actual_dclk = actual_dclk/port_mult;
+
+	if (ret) {
+		EMGD_ERROR("Clock %ld could not be programmed", dclk);
+		return ret;
+	}
+
+	/* Disable DPLL, Write 2 into P for saftey */
+	control = BIT28 | (2<<clock->p_shift) | vga_mult;
+
+	WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, clock->dpll_control, control);
+	EMGD_DEBUG("sdvo: EMGD_WRITE32: 0x%lx = 0x%lx",
+		clock->dpll_control, control);
+
+	/* Program N, M */
+	WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, clock->mnp, (n<<16) | m);
+	EMGD_DEBUG("sdvo: EMGD_WRITE32: 0x%lx = 0x%lx",
+		clock->mnp, (n<<16)|m);
+
+	/* Enable DPLL, Disable VGA mode and sitck in new P values */
+	control = BIT31 | BIT30 | BIT28 | (p1<<clock->p_shift) | vga_mult;
+
+	/* Set the clock source correctly based on PD settings */
+	if(port->pd_flags & PD_FLAG_CLK_SOURCE) {
+		control |= port->clock_bits;
+	}
+
+	/* sDVO Multiplier bits[7:0] */
+	if (port_mult == 2) {
+		control |= (1 << 4);
+	} else if (port_mult == 3) {
+		control |= (2 << 4);
+	} else if (port_mult == 4) {
+		control |= (3 << 4);
+	}
+
+	/* Double buffered */
+	WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, clock->dpll_control, control);
+	WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, clock->dpll_control, control);
+	EMGD_DEBUG("sdvo: EMGD_WRITE32: 0x%lx = 0x%lx",
+		clock->dpll_control, control);
+
+	/* We must wait for 150 us for the dpll clock to warm up */
+	//OS_SLEEP(150);
+	wait_dpll();
+
+	kms_program_cdvo(emgd_crtc);
+
+	return 0;
+}
+/*!
+ *
  * @param display
  * @param clock
  * @param dclk
@@ -703,6 +986,21 @@ int program_clock_sdvo_tnc(igd_display_context_t *display,
 	return 0;
 }
 
+int kms_program_clock_tnc(emgd_crtc_t *emgd_crtc,
+	igd_clock_t *clock,
+	unsigned long dclk)
+{
+	EMGD_TRACE_ENTER;
+
+	if (get_port_type(emgd_crtc->crtc_id) == IGD_PORT_LVDS) {
+		EMGD_TRACE_EXIT;
+		return kms_program_clock_lvds_tnc(emgd_crtc, clock, dclk);
+	} else {
+		EMGD_TRACE_EXIT;
+		return kms_program_clock_sdvo_tnc(emgd_crtc, clock, dclk);
+	}
+}
+
 int program_clock_tnc(igd_display_context_t *display,
 	igd_clock_t *clock,
 	unsigned long dclk)
@@ -756,6 +1054,68 @@ static void wait_dpll(void)
 }
 
 
+/* This is the initialization code for B0 stepping */
+static int kms_program_cdvo(emgd_crtc_t *emgd_crtc)
+{
+	int counter = 0;
+	igd_display_pipe_t *pipe = NULL;
+
+	EMGD_TRACE_ENTER;
+
+	pipe = emgd_crtc->igd_pipe;
+
+    #ifndef CONFIG_MICRO
+	/*
+	 * CDVO reset has been done. Check that offset 0x7000 has the value 0x50
+	 * and this would mean that reset has been done. We only need to do cdvo
+	 * reset once per warm reset
+	 */
+	if((READ_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7000) == 0x50) ||
+		!FLAG(flag_enable_cdvo_reset)){
+		EMGD_TRACE_EXIT;
+		return TRUE;
+	}
+
+    #endif
+
+	/* pipe_temp = READ_MMIO_REG_TNC(IGD_PORT_SDVO, PIPE(display)->pipe_reg); */
+
+	/* Disable pipe */
+	WRITE_MMIO_REG_TNC(IGD_PORT_LVDS, pipe->pipe_reg, 0);
+	WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, pipe->pipe_reg, 0);
+
+	/* Sleep for a while to wait for the pipe to disable. There are no
+	* status bits to check if pipe B has been enable */
+	OS_SLEEP(25);
+
+    #if 0
+       /* Disable DPLL */
+       vga_mult = READ_MMIO_REG_TNC(IGD_PORT_SDVO,
+           PIPE(display)->clock_reg->dpll_control) & 0x3;
+       control = BIT28 | (2<<PIPE(display)->clock_reg->p_shift) | vga_mult;
+
+       WRITE_MMIO_REG_TNC(IGD_PORT_SDVO,
+           PIPE(display)->clock_reg->dpll_control, control);
+       WRITE_MMIO_REG_TNC(IGD_PORT_SDVO,
+           PIPE(display)->clock_reg->dpll_control, control);
+    #endif
+
+	/* the checking is needed for VBIOS but not needed for driver */
+	do{
+		WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, cdvo_reset[counter].reg,
+			cdvo_reset[counter].value);
+			counter++;
+	}while(cdvo_reset[counter].reg != 0);
+
+	/* Enable sDVOB port */
+	WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x61140,
+	READ_MMIO_REG_TNC(IGD_PORT_SDVO, 0x61140) | 0xC0000018 );
+
+
+	EMGD_TRACE_EXIT;
+
+	return TRUE;
+}
 
 /* This is the initialization code for B0 stepping */
 static int program_cdvo(igd_display_context_t *display)
@@ -766,10 +1126,10 @@ static int program_cdvo(igd_display_context_t *display)
 
     #ifndef CONFIG_MICRO
 	/*
- 	 * CDVO reset has been done. Check that offset 0x7000 has the value 0x50
+	 * CDVO reset has been done. Check that offset 0x7000 has the value 0x50
 	 * and this would mean that reset has been done. We only need to do cdvo
- 	 * reset once per warm reset
- 	 */
+	 * reset once per warm reset
+	 */
 	if((READ_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7000) == 0x50) ||
 		!FLAG(flag_enable_cdvo_reset)){
 		EMGD_TRACE_EXIT;
@@ -818,11 +1178,3 @@ static int program_cdvo(igd_display_context_t *display)
 }
 #endif
 
-
-
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: clocks_tnc.c,v 1.15 2011/03/11 06:49:32 nanuar Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/display/mode/tnc/clocks_tnc.c,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/kms_mode_tnc.c b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/kms_mode_tnc.c
new file mode 100644
index 0000000..a3aa69d
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/kms_mode_tnc.c
@@ -0,0 +1,1721 @@
+/*
+ *-----------------------------------------------------------------------------
+ * Filename: kms_mode_tnc.c
+ * $Revision: 1.3 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2011, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ * Description:
+ *-----------------------------------------------------------------------------
+ */
+
+#define MODULE_NAME hal.mode
+
+#include <igd_pwr.h>
+#include <utils.h>
+#include <vga.h>
+#include <pi.h>
+
+#include <tnc/regs.h>
+#include <tnc/context.h>
+#include <tnc/mi.h>
+#include <tnc/instr.h>
+#include <tnc/igd_tnc_wa.h>
+#include "drm_emgd_private.h"
+
+#include "../cmn/mode_dispatch.h"
+#include "../cmn/match.h"
+#include "mode_tnc.h"
+#include <math_fix.h>
+#include <memory.h>
+
+
+/*------------------------------------------------------------------------------
+ * Function Prototypes
+ *----------------------------------------------------------------------------*/
+int kms_mode_get_stride_stereo_tnc(igd_display_pipe_t *pipe,
+	igd_display_plane_t *plane,
+	unsigned long *stride,
+	unsigned long *stereo,
+	unsigned long flags);
+void kms_program_pipe_vga_tnc(emgd_crtc_t *emgd_crtc);
+static void kms_program_pipe_tnc(emgd_crtc_t *emgd_crtc);
+static void kms_set_pipe_pwr_tnc(emgd_crtc_t *emgd_crtc, unsigned long enable);
+static void kms_program_plane_tnc(emgd_crtc_t *emgd_crtc, unsigned long status);
+static void kms_set_plane_pwr_tnc(emgd_crtc_t *emgd_crtc, unsigned long enable);
+static int  kms_program_port_tnc(emgd_encoder_t *emgd_encoder,
+	unsigned long status);
+static int  kms_program_port_lvds_tnc(emgd_encoder_t *emgd_encoder,
+	unsigned long status);
+static int  kms_program_port_sdvo_tnc(emgd_encoder_t *emgd_encoder,
+	unsigned long status);
+static int  kms_post_program_port_tnc(emgd_encoder_t *emgd_encoder,
+	unsigned long status);
+static u32  kms_get_vblank_counter_tnc(emgd_crtc_t *emgd_crtc);
+
+
+static int set_color_correct_tnc(emgd_crtc_t *emgd_crtc);
+
+extern unsigned long get_port_type(int crtc_id);
+extern void wait_pipe(unsigned long pt, unsigned long pipe_reg, unsigned long check_on_off);
+extern void disable_vga_tnc (unsigned char *mmio);
+extern int write_bunit_tnc(unsigned long reg, unsigned long val);
+extern int read_bunit_tnc(unsigned long reg, unsigned long *val);
+extern int kms_program_clock_tnc(emgd_crtc_t *emgd_crtc,
+	igd_clock_t *clock, unsigned long dclk);
+extern int wait_for_vblank_tnc(unsigned long pipe_reg);
+extern void initialize_ST_bridge(igd_context_t *context,
+	igd_display_port_t *port);
+
+
+/*------------------------------------------------------------------------------
+ * Global Variables
+ *----------------------------------------------------------------------------*/
+extern int flag_basic_htotal_formula_wa;
+extern int flag_turn_off_port_wa;
+extern int flag_enable_tuning_wa;
+extern unsigned long ports_tnc[2];
+extern int vphase;
+extern tnc_wa_timing_t tune;
+extern mode_data_tnc_t device_data_tnc[1];
+
+
+/*------------------------------------------------------------------------------
+ * KMS Dispatch Table
+ *----------------------------------------------------------------------------*/
+mode_kms_dispatch_t mode_kms_dispatch_tnc = {
+	kms_program_pipe_tnc,
+	kms_set_pipe_pwr_tnc,
+	kms_program_plane_tnc,
+	kms_set_plane_pwr_tnc,
+	kms_program_port_tnc,
+	kms_post_program_port_tnc,
+	kms_get_vblank_counter_tnc,
+	kms_match_mode,
+};
+
+
+
+/*!
+ * Get the stride and stereo values based on the display.
+ *
+ * @param plane Pointer to hardware device instance data
+ * @param pipe  Pointer to hardware device instance data
+ * @param flags Should the stereo be for the frontbuffer or backbuffer?
+ *
+ * @return stride - Stride of the display
+ * @return stereo - Stereo address of the display
+ */
+int kms_mode_get_stride_stereo_tnc(igd_display_pipe_t *pipe,
+		igd_display_plane_t *plane,
+		unsigned long *stride,
+		unsigned long *stereo,
+		unsigned long flags)
+{
+	unsigned long pitch = plane->fb_info->screen_pitch;
+	igd_timing_info_t *timing = pipe->timing;
+	unsigned long base_offset;
+
+	EMGD_TRACE_ENTER;
+
+	base_offset = plane->fb_info->visible_offset;
+	*stride = pitch;
+	*stereo = 0;
+
+	/* For field replication, valid for interlaced modes only
+	 *     set stereo = fb_base
+	 *         stride = pitch
+	 */
+	if (timing->mode_info_flags & IGD_SCAN_INTERLACE) {
+
+		if(timing->mode_info_flags & IGD_LINE_DOUBLE) {
+			/* Interlaced + Line double flags means field replication.
+			 * same lines are sent for both fields. Program the
+			 * second eye to be same as the first
+			 */
+			*stereo = base_offset;
+		} else {
+			/* Regular interlaced. Second eye starts on line 2.
+			 * Skip every other line.
+			 */
+			*stereo = base_offset + pitch;
+			*stride = pitch << 1;
+		}
+	}
+
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+
+
+
+/*!
+ *
+ * @param emgd_crtc
+ *
+ * @return 0 on success
+ * @return -IGD_ERROR_INVAL if color attributes not found
+ */
+static int set_color_correct_tnc(emgd_crtc_t *emgd_crtc)
+{
+	const int        MID_PIXEL_VAL    = 125;
+	const int        MAX_PIXEL_VAL    = 255;
+	const int        NUM_PALETTE_ENTRIES = 256;
+
+	igd_display_port_t *port = NULL;
+	igd_display_pipe_t *pipe = NULL;
+	struct drm_encoder *encoder = NULL;
+	emgd_encoder_t     *emgd_encoder = NULL;
+
+	unsigned int     gamma_r_max_24i_8f, gamma_r_min_24i_8f;
+	unsigned int     gamma_g_max_24i_8f, gamma_g_min_24i_8f;
+	unsigned int     gamma_b_max_24i_8f, gamma_b_min_24i_8f;
+	unsigned int     new_gamma_r_24i_8f, new_gamma_g_24i_8f;
+	unsigned int     new_gamma_b_24i_8f;
+	unsigned int     gamma_normal_r_24i_8f, gamma_normal_g_24i_8f;
+	unsigned int     gamma_normal_b_24i_8f;
+	int              brightness_factor_r, brightness_factor_g;
+	int              brightness_factor_b;
+	int              contrast_factor_r, contrast_factor_g;
+	int              contrast_factor_b;
+
+	unsigned int      *palette;
+	unsigned int       i;
+	struct drm_device *dev = NULL;
+
+	igd_range_attr_t *gamma_attr      = NULL, *contrast_attr = NULL;
+	igd_range_attr_t *brightness_attr = NULL;
+	igd_attr_t       *hal_attr_list   = NULL;
+
+	EMGD_TRACE_ENTER;
+
+	pipe = emgd_crtc->igd_pipe;
+	dev = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
+	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+		if (((struct drm_crtc *)(&emgd_crtc->base)) == encoder->crtc) {
+			emgd_encoder = container_of(encoder, emgd_encoder_t, base);
+			port = emgd_encoder->igd_port;
+			break;
+		}
+	}
+	if (!port) {
+		EMGD_ERROR_EXIT("No port being used.");
+		return -IGD_ERROR_INVAL;
+	}
+	hal_attr_list  = port->attributes;
+
+	/* Using OS_ALLOC to avoid using > 1024 on stack (frame size warning ) */
+	palette = OS_ALLOC(sizeof (unsigned int) * NUM_PALETTE_ENTRIES);
+
+	/* start with a fresh palette */
+	for (i = 0; i < NUM_PALETTE_ENTRIES; i++) {
+		palette[i] = (i << 16) | (i << 8) | i;
+	}
+
+	/* get a pointer to gamma, contrast, and brightness attr */
+	i = 0;
+
+	while (PD_ATTR_LIST_END != hal_attr_list[i].id) {
+		switch (hal_attr_list[i].id) {
+		case PD_ATTR_ID_FB_GAMMA:
+			gamma_attr      = (igd_range_attr_t *) &hal_attr_list[i];
+			break;
+
+		case PD_ATTR_ID_FB_BRIGHTNESS:
+			brightness_attr = (igd_range_attr_t *) &hal_attr_list[i];
+			break;
+
+		case PD_ATTR_ID_FB_CONTRAST:
+			contrast_attr   = (igd_range_attr_t *) &hal_attr_list[i];
+			break;
+
+		default:
+			break;
+		}
+
+		i++;
+	}
+
+	if(!gamma_attr || !brightness_attr || !contrast_attr) {
+		EMGD_ERROR_EXIT("Color Correction Atrributes not found!");
+		return -IGD_ERROR_INVAL;
+	}
+
+	/* Get the max and min */
+	gamma_r_max_24i_8f = ((gamma_attr->max >> 16) & 0xFF) << 3;
+	gamma_g_max_24i_8f = ((gamma_attr->max >>  8) & 0xFF) << 3;
+	gamma_b_max_24i_8f =  (gamma_attr->max        & 0xFF) << 3;
+
+	gamma_r_min_24i_8f = ((gamma_attr->min >> 16) & 0xFF) << 3;
+	gamma_g_min_24i_8f = ((gamma_attr->min >>  8) & 0xFF) << 3;
+	gamma_b_min_24i_8f =  (gamma_attr->min        & 0xFF) << 3;
+
+	/* The new gamma values are in 3i.5f format, but we must convert it
+	 * to 24i.8f format before passing it to OS_POW_FIX
+	 */
+	new_gamma_r_24i_8f = ((gamma_attr->current_value >> 16) & 0xFF) << 3;
+	new_gamma_g_24i_8f = ((gamma_attr->current_value >> 8) & 0xFF) << 3;
+	new_gamma_b_24i_8f = (gamma_attr->current_value & 0xFF) << 3;
+
+	/* make sure the new gamma is within range */
+	new_gamma_r_24i_8f = OS_MIN(gamma_r_max_24i_8f, new_gamma_r_24i_8f);
+	new_gamma_r_24i_8f = OS_MAX(gamma_r_min_24i_8f, new_gamma_r_24i_8f);
+	new_gamma_g_24i_8f = OS_MIN(gamma_g_max_24i_8f, new_gamma_g_24i_8f);
+	new_gamma_g_24i_8f = OS_MAX(gamma_g_min_24i_8f, new_gamma_g_24i_8f);
+	new_gamma_b_24i_8f = OS_MIN(gamma_b_max_24i_8f, new_gamma_b_24i_8f);
+	new_gamma_b_24i_8f = OS_MAX(gamma_b_min_24i_8f, new_gamma_b_24i_8f);
+
+
+	gamma_normal_r_24i_8f =
+		OS_POW_FIX(MAX_PIXEL_VAL, (1<<16)/new_gamma_r_24i_8f);
+
+	gamma_normal_g_24i_8f =
+		OS_POW_FIX(MAX_PIXEL_VAL, (1<<16)/new_gamma_g_24i_8f);
+
+	gamma_normal_b_24i_8f =
+		OS_POW_FIX(MAX_PIXEL_VAL, (1<<16)/new_gamma_b_24i_8f);
+
+	for( i = 0; i < NUM_PALETTE_ENTRIES; i++ ) {
+		unsigned int new_gamma;
+		unsigned int cur_color;
+		unsigned int cur_palette = palette[i];
+
+		/* Note that we do not try to calculate the gamma if it
+		 * is 1.0, e.g. 0x100.  This is to avoid round-off errors
+		 */
+
+		/* red: calculate and make sure the result is within range */
+		if (0x100 != new_gamma_r_24i_8f) {
+			cur_color  = (cur_palette >> 16) & 0xFF;
+			new_gamma  = OS_POW_FIX(cur_color, (1<<16)/new_gamma_r_24i_8f);
+			new_gamma  = (MAX_PIXEL_VAL * new_gamma)/gamma_normal_r_24i_8f;
+			palette[i] &= 0x00FFFF;
+			palette[i] |=
+				(OS_MIN(new_gamma, (unsigned) MAX_PIXEL_VAL) & 0xFF) << 16;
+		}
+
+		/* green: calculate and make sure the result is within range */
+		if (0x100 != new_gamma_g_24i_8f) {
+			cur_color  = (cur_palette >> 8) & 0xFF;
+			new_gamma  = OS_POW_FIX(cur_color, (1<<16)/new_gamma_g_24i_8f);
+			new_gamma  = (MAX_PIXEL_VAL * new_gamma)/gamma_normal_g_24i_8f;
+			palette[i] &= 0xFF00FF;
+			palette[i] |=
+				(OS_MIN(new_gamma, (unsigned) MAX_PIXEL_VAL) & 0xFF) << 8;
+		}
+
+		/* blue: calculate and make sure the result is within range */
+		if (0x100 != new_gamma_b_24i_8f) {
+			cur_color  = cur_palette & 0xFF;
+			new_gamma  = OS_POW_FIX(cur_color, (1<<16)/new_gamma_b_24i_8f);
+			new_gamma  = (MAX_PIXEL_VAL * new_gamma)/gamma_normal_b_24i_8f;
+			palette[i] &= 0xFFFF00;
+			palette[i] |=
+				(OS_MIN(new_gamma, (unsigned) MAX_PIXEL_VAL) & 0xFF);
+		}
+	}
+
+
+	/* Brightness correction */
+	brightness_factor_r = (brightness_attr->current_value >> 16) & 0xFF;
+	brightness_factor_g = (brightness_attr->current_value >> 8) & 0xFF;
+	brightness_factor_b = brightness_attr->current_value & 0xFF;
+
+	/* The factors are offset by 0x80 because 0x80 is 0 correction */
+	brightness_factor_r -= 0x80;
+	brightness_factor_g -= 0x80;
+	brightness_factor_b -= 0x80;
+
+	for( i = 0; i < NUM_PALETTE_ENTRIES; i++ ) {
+		int          new_pixel_val;
+		unsigned int cur_color;
+		unsigned int cur_palette = palette[i];
+
+		/* red: calculate and make sure the result is within range */
+		cur_color     =  (cur_palette >> 16) & 0xFF;
+		new_pixel_val =  cur_color + brightness_factor_r;
+		new_pixel_val =  OS_MIN(new_pixel_val, MAX_PIXEL_VAL);
+		palette[i]    &= 0x00FFFF;
+		palette[i]    |= (OS_MAX(new_pixel_val, 0) & 0xFF) << 16;
+
+		/* green: calculate and make sure the result is within range */
+		cur_color     =  (cur_palette >> 8) & 0xFF;
+		new_pixel_val =  cur_color + brightness_factor_g;
+		new_pixel_val =  OS_MIN(new_pixel_val, MAX_PIXEL_VAL);
+		palette[i]    &= 0xFF00FF;
+		palette[i]    |= (OS_MAX(new_pixel_val, 0) & 0xFF) << 8;
+
+		/* blue: calculate and make sure the result is within range */
+		cur_color     =  cur_palette & 0xFF;
+		new_pixel_val =  cur_color + brightness_factor_b;
+		new_pixel_val =  OS_MIN(new_pixel_val, MAX_PIXEL_VAL);
+		palette[i]    &= 0xFFFF00;
+		palette[i]    |= OS_MAX(new_pixel_val, 0) & 0xFF;
+	}
+
+
+	/* contrast correction */
+	contrast_factor_r = (contrast_attr->current_value >> 16) & 0xFF;
+	contrast_factor_g = (contrast_attr->current_value >> 8) & 0xFF;
+	contrast_factor_b = contrast_attr->current_value & 0xFF;
+
+	/* make sure values are within range */
+	contrast_factor_r -= 0x80;
+	contrast_factor_g -= 0x80;
+	contrast_factor_b -= 0x80;
+
+
+	/* We're doing integer division in this loop using 16i.16f
+	 * integers.  The result will then be converted back into a
+	 * regular, 32-bit integer
+	 */
+	for( i = 0; i < NUM_PALETTE_ENTRIES; i++ ) {
+		int new_pixel_val;
+		unsigned int cur_color;
+		unsigned int cur_palette = palette[i];
+
+		/* red: calculate and make sure the result is within range */
+		if (0 != contrast_factor_r ) {
+			cur_color     = (cur_palette >> 16) & 0xFF;
+			new_pixel_val =
+				(MAX_PIXEL_VAL << 16) / (MAX_PIXEL_VAL - contrast_factor_r);
+			new_pixel_val =   new_pixel_val * (cur_color - MID_PIXEL_VAL);
+			new_pixel_val >>= 16;  /* convert back to 32i format */
+			new_pixel_val +=  MID_PIXEL_VAL;
+			new_pixel_val =   OS_MIN(new_pixel_val, MAX_PIXEL_VAL);
+			palette[i]    &=  0x00FFFF;  /* clear out the R color */
+			palette[i]    |=  (OS_MAX(new_pixel_val, 0) & 0xFF) << 16;
+		}
+
+		/* green: calculate and make sure the result is within range */
+		if (0 != contrast_factor_g ) {
+			cur_color     = (cur_palette >> 8) & 0xFF;
+			new_pixel_val =
+				(MAX_PIXEL_VAL << 16) / (MAX_PIXEL_VAL - contrast_factor_g);
+			new_pixel_val =   new_pixel_val * (cur_color - MID_PIXEL_VAL);
+			new_pixel_val >>= 16;  /* convert back to 32i format */
+			new_pixel_val +=  MID_PIXEL_VAL;
+			new_pixel_val =   OS_MIN(new_pixel_val, MAX_PIXEL_VAL);
+			palette[i]    &=  0xFF00FF;  /* clear out the G color */
+			palette[i]    |=  (OS_MAX(new_pixel_val, 0) & 0xFF) << 8;
+		}
+
+		/* blue: calculate and make sure the result is within range */
+		if (0 != contrast_factor_b) {
+			cur_color     = cur_palette & 0xFF;
+			new_pixel_val =
+				(MAX_PIXEL_VAL << 16) / (MAX_PIXEL_VAL - contrast_factor_b);
+			new_pixel_val =   new_pixel_val * (cur_color - MID_PIXEL_VAL);
+			new_pixel_val >>= 16;  /* convert back to 32i format */
+			new_pixel_val +=  MID_PIXEL_VAL;
+			new_pixel_val =   OS_MIN(new_pixel_val, MAX_PIXEL_VAL);
+			palette[i]    &=  0xFFFF00;  /* clear out the B color */
+			palette[i]    |=   OS_MAX(new_pixel_val, 0) & 0xFF;
+		}
+	}
+
+
+	/* write the new values in the palette */
+	for (i = 0; i < NUM_PALETTE_ENTRIES; i++) {
+		/* SDVO palette register is not accesible */
+		EMGD_WRITE32(palette[i],
+			MMIO_TNC(IGD_PORT_LVDS) +
+			pipe->palette_reg + i*4);
+	}
+
+	OS_FREE(palette);
+
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+
+
+
+/*!
+ * kms_program_pipe_vga_tnc
+ *
+ * @param emgd_crtc Pointer to our private kms crtc structure
+ *
+ * @return void
+ */
+void kms_program_pipe_vga_tnc(
+	emgd_crtc_t *emgd_crtc)
+{
+	struct drm_device  *dev = NULL;
+	igd_timing_info_t  *timing = NULL;
+	igd_display_pipe_t *pipe = NULL;
+	igd_context_t      *context = NULL;
+	struct drm_encoder *encoder = NULL;
+	emgd_encoder_t     *emgd_encoder = NULL;
+	igd_display_port_t *port = NULL;
+	unsigned long       vga_control;
+	unsigned long       upscale = 0;
+	int                 centering = 1;
+	unsigned long       pt;
+
+	EMGD_TRACE_ENTER;
+
+	pipe = emgd_crtc->igd_pipe;
+	dev = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+
+	/*
+	 * VGA Plane can attach to only one pipe at a time. LVDS can
+	 * only attach to pipe B. We need to use the display passed to
+	 * determine the pipe number to use. (Napa is same as Alm).
+	 */
+
+	/*
+	 * We can come here with following cases:
+	 *   1. magic->vga    CRT, DVI type displays
+	 *   2. native->vga   int-lvds, and up-scaling lvds displays
+	 *   3. pipe->vga     TV and other unscaled-lvds displays
+	 */
+	vga_control = EMGD_READ32(context->device_context.virt_mmadr + 0x71400);
+	vga_control &= 0x18e3ff00;
+	vga_control |= 0x8e;
+
+	timing = pipe->timing;
+	if(!timing->extn_ptr) {
+		EMGD_ERROR_EXIT("No Extension pointer in program_pipe_vga_tnc");
+		return;
+	}
+
+	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+		if (((struct drm_crtc *)(&emgd_crtc->base)) == encoder->crtc) {
+			emgd_encoder = container_of(encoder, emgd_encoder_t, base);
+			port = emgd_encoder->igd_port;
+
+		    /* Find UPSCALING attr value*/
+		    pi_pd_find_attr_and_value(port,
+	            PD_ATTR_ID_PANEL_FIT,
+	            0,/*no PD_FLAG for UPSCALING */
+	            NULL, /* dont need the attr ptr*/
+	            &upscale);
+		    /* this PI func will not modify value
+			 * of upscale if attr does not exist
+			 */
+			break;
+		}
+	}
+
+	/* magic->vga || native->vga cases, centering isn't required */
+	if ((timing->width == 720 && timing->height == 400) || upscale) {
+		EMGD_DEBUG("Centering = 0");
+		centering = 0;
+	}
+
+	/* Enable border */
+	if((timing->width >= 800) && !upscale) {
+		EMGD_DEBUG("Enable VGA Border");
+		vga_control |= (1L<<26);
+	}
+
+	if(timing->width == 640) {
+		EMGD_DEBUG("Enable Nine Dot Disable");
+		vga_control |= (1L<<18);
+	}
+
+	if(centering) {
+		EMGD_DEBUG("Enable VGA Center Centering");
+		vga_control |= 1L<<24;
+
+		if(timing->height >= 960) {
+			if(timing->width >= 1280) {
+				EMGD_DEBUG("Enable VGA 2x (Nine Dot Disable)");
+				vga_control |= (1L<<30) | (1L<<18);
+			}
+		}
+	} else {
+		pt = get_port_type(emgd_crtc->crtc_id);
+		if(pt == IGD_PORT_LVDS) {
+			EMGD_DEBUG("Enable VGA Upper-Left Centering & Nine Dot Disable");
+			vga_control |= (1L<<25 | (1L<<18));
+		} else if (upscale) {
+			EMGD_DEBUG("Enable VGA Center Upper-left for upscale ports");
+			vga_control |= 1L<<25;
+		}
+	}
+
+	if(pipe->pipe_num) {
+		vga_control |= 1L<<29;
+	}
+
+	kms_program_pipe_vga(emgd_crtc, (igd_timing_info_t *)timing->extn_ptr);
+	EMGD_WRITE32(vga_control, context->device_context.virt_mmadr + 0x71400);
+
+	EMGD_TRACE_EXIT;
+	return;
+}
+
+
+
+/**
+ * kms_set_pipe_pwr_tnc
+ *
+ * Turns the pipe ON or OFF depending on the input
+ *
+ * @param emgd_crtc (IN) specifies the pipe to change
+ * @param enable    (IN) TRUE to enable pipe, FALSE to disable
+ *
+ * @return
+ */
+static void kms_set_pipe_pwr_tnc(emgd_crtc_t *emgd_crtc, unsigned long enable)
+{
+	unsigned long       pipe_conf;
+	unsigned long       port_type;
+	struct drm_device  *dev;
+	igd_display_pipe_t *pipe;
+	igd_context_t      *context;
+
+
+	EMGD_TRACE_ENTER;
+
+
+	dev       = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
+	context   = ((drm_emgd_priv_t *)dev->dev_private)->context;
+
+	pipe      = emgd_crtc->igd_pipe;
+	port_type = get_port_type(emgd_crtc->crtc_id);
+	pipe_conf = device_data_tnc->pipe_preserve &
+					READ_MMIO_REG_TNC(port_type, pipe->pipe_reg);
+
+	/* Do nothing if current power state is same as what we want to set */
+	/* The PIPE_ENABLE bit is at bit-position 31 */
+	if ( (enable << 31) == (pipe_conf & PIPE_ENABLE) ){
+
+		EMGD_TRACE_EXIT;
+		return;
+	}
+
+
+	if (!enable) {
+
+		/* For SDVO, disable both pipe Bs in 0:2:0 and 0:3:0 */
+		if (IGD_PORT_SDVO == port_type) {
+			WRITE_MMIO_REG_TNC(IGD_PORT_LVDS, pipe->pipe_reg,
+				pipe_conf & ~PIPE_ENABLE);
+		}
+
+		/* Disable pipe */
+		WRITE_MMIO_REG_TNC(port_type, pipe->pipe_reg, pipe_conf & ~PIPE_ENABLE);
+
+		/* check when the pipe is disabled. */
+		wait_pipe(port_type, pipe->pipe_reg, 0);
+
+		/* Disable DPLL */
+		//WRITE_MMIO_REG_TNC(pt, PIPE(display)->clock_reg->dpll_control,
+		//	READ_MMIO_REG_TNC(pt,
+		//		PIPE(display)->clock_reg->dpll_control) & ~0x80000000L);
+
+		EMGD_DEBUG("Set Pipe Power: OFF");
+
+	} else {
+
+		if (IGD_PORT_SDVO == port_type) {
+			WRITE_MMIO_REG_TNC(IGD_PORT_LVDS, pipe->pipe_reg,
+				pipe_conf | PIPE_ENABLE);
+		}
+
+		/* Enable pipe */
+		WRITE_MMIO_REG_TNC(port_type, pipe->pipe_reg, pipe_conf | PIPE_ENABLE);
+
+		EMGD_DEBUG("Set Pipe Power: ON");
+	}
+
+
+	EMGD_TRACE_EXIT;
+	return;
+}
+
+
+
+/**
+ * kms_program_pipe_tnc
+ *
+ * Called before a mode set, takes the input "mode", matches it to the closest
+ * supported mode, then put the supported mode into "adjusted_mode" to let the
+ * caller know.
+ *
+ * @param encoder (IN) Encoder being prepared
+ *
+ * @return true, false (details TBD)
+ */
+static void kms_program_pipe_tnc(emgd_crtc_t *emgd_crtc)
+{
+	unsigned long       timing_reg;
+	unsigned long       pipe_conf;
+	unsigned long       hactive, vactive;
+	short               hactive_tmp, vactive_tmp;
+	igd_timing_info_t  *current_timings;
+	igd_timing_info_t   pTimings_tmp;
+	struct drm_device  *dev          = NULL;
+	igd_display_pipe_t *pipe         = NULL;
+	igd_display_port_t *port         = NULL;
+	igd_context_t      *context      = NULL;
+	struct drm_encoder *encoder      = NULL;
+	emgd_encoder_t     *emgd_encoder = NULL;
+	pd_timing_t        *vga_timing   = NULL;
+
+	unsigned long pipe_reg;
+	unsigned long temp;
+	unsigned long pt;
+	unsigned long dc;
+	unsigned long calc;
+	int           i;
+	tnc_wa_timing_t *wa;
+	/* igd_framebuffer_info_t *fb_info = PLANE(display)->fb_info; */
+
+	EMGD_TRACE_ENTER;
+
+	pipe            = emgd_crtc->igd_pipe;
+	current_timings = pipe->timing;
+	vga_timing      = (pd_timing_t *) current_timings->extn_ptr;
+	pipe_reg        = pipe->pipe_reg;
+
+	pt       = get_port_type(emgd_crtc->crtc_id);
+	dev      = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
+	context  = ((drm_emgd_priv_t *)dev->dev_private)->context;
+
+	EMGD_DEBUG("Device power state: D%ld", context->device_context.power_state);
+
+	pipe_conf = device_data_tnc->pipe_preserve &
+		READ_MMIO_REG_TNC(pt, pipe->pipe_reg);
+
+	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+		if (((struct drm_crtc *)(&emgd_crtc->base)) == encoder->crtc) {
+			emgd_encoder = container_of(encoder, emgd_encoder_t, base);
+			port = emgd_encoder->igd_port;
+			break;
+		}
+	}
+
+	if (NULL == emgd_encoder) {
+		EMGD_ERROR_EXIT("Invalid CRTC selected.");
+		return;
+	}
+
+	/* Debug messages */
+	EMGD_DEBUG("Current timings %ux%u mode_number = %u "
+			   "mode_info_flags = 0x%lx, dclk = %lu",
+			   current_timings->width,
+			   current_timings->height,
+			   current_timings->mode_number,
+			   current_timings->mode_info_flags,
+			   current_timings->dclk);
+
+	if (vga_timing) {
+	  EMGD_DEBUG("ext_timing %ux%u mode_number = %u "
+				 "mode_info_flags= 0x%lx, dclk = %lu",
+				 vga_timing->width,
+				 vga_timing->height,
+				 vga_timing->mode_number,
+				 vga_timing->mode_info_flags,
+				 vga_timing->dclk);
+	}
+
+
+	/*
+	 * If the mode is VGA and the PD says it handles all VGA modes without
+	 * reprogramming then just set the mode and leave centering off.
+	 */
+	if(current_timings->mode_info_flags & IGD_MODE_VESA) {
+		EMGD_DEBUG("IGD_MODE_VESA");
+
+		if (current_timings->mode_number <= VGA_MODE_NUM_MAX) {
+			EMGD_DEBUG("current_timings->mode_number <= VGA_MODE_NUM_MAX");
+			kms_program_pipe_vga_tnc(emgd_crtc);
+
+			EMGD_TRACE_EXIT;
+			return;
+		}
+	}
+
+	/* Program dot clock divisors. */
+	kms_program_clock_tnc(emgd_crtc, pipe->clock_reg, current_timings->dclk);
+
+	/* Program timing registers for the pipe */
+	timing_reg = pipe->timing_reg;
+	if (current_timings->mode_info_flags & IGD_PIXEL_DOUBLE) {
+		hactive = (unsigned long)current_timings->width*2 - 1;
+	} else {
+		hactive = (unsigned long)current_timings->width - 1;
+	}
+
+	if (current_timings->mode_info_flags & IGD_LINE_DOUBLE) {
+		vactive = (unsigned long)current_timings->height*2 - 1;
+	} else {
+		/* For Atom E6xx Hardware will automatically divide by 2 to
+		   get the number of line in each field */
+		vactive = (unsigned long)current_timings->height - 1;
+	}
+
+
+	/* Reset the Palette */
+	for (i = 0; i < 256; i++) {
+		/* Program each of the 256 4-byte palette entries */
+		WRITE_MMIO_REG_TNC(IGD_PORT_LVDS, pipe->palette_reg + (i << 2),
+			((i<<16) | (i<<8) | i));
+	}
+
+	if (port) {
+		/* apply color correction */
+		for( i = 0; PD_ATTR_LIST_END != port->attributes[i].id; i++ ) {
+
+			if ((PD_ATTR_ID_FB_GAMMA      == (port->attributes[i].id)) ||
+				(PD_ATTR_ID_FB_BRIGHTNESS == (port->attributes[i].id)) ||
+				(PD_ATTR_ID_FB_BRIGHTNESS == (port->attributes[i].id)))  {
+
+				set_color_correct_tnc(emgd_crtc);
+			}
+		}
+	}
+
+
+	/*
+	 * NOTE: For size reasons the timng table contains unsigned short
+	 * values. Don't shift them past 16. Use a temp instead.
+	 * All register offsets and bit shift are verified for Gen4
+	 *
+	 * For SDVO display:
+	 * Write values into pipe B registers in both 0:2:0 and 0:3:0
+	 */
+
+	dc = *(context->mod_dispatch.dsp_current_dc);
+
+	wa = WA_TUNE;
+
+	for (i=0; i<2; i++) {
+		/* Temp variable */
+		pTimings_tmp = *current_timings;
+		hactive_tmp  = (short) hactive;
+		vactive_tmp  = (short) vactive;
+
+		/* This work around is only for Atom E6xx B0 */
+		if((IGD_DC_CLONE(dc) || IGD_DC_EXTENDED(dc))
+			&& pt == IGD_PORT_SDVO &&
+			(context->device_context.rid == TNC_B0_RID)
+			&& FLAG(flag_basic_htotal_formula_wa)){
+
+			if(!(current_timings->reserved_dd & TNC_HTOTAL_TUNED)){
+				/* Modify blanks so it always begin after active pixel and ends
+				 * at the end. Do not change it if we are already tuned to
+				 * maintain original timing specification
+				 */
+				pTimings_tmp.hblank_start =
+								(short) (current_timings->width - 1);
+				pTimings_tmp.vblank_start =
+								(short) (current_timings->height - 1);
+				pTimings_tmp.hblank_end = (short) (current_timings->htotal);
+				pTimings_tmp.vblank_end = (short) (current_timings->vtotal);
+			}
+
+			if(i==0){
+				if(current_timings->reserved_dd == 0 ||
+					(wa->counter > LIMIT_TOTAL_CHECK_DISPLAY)){
+					/* First time tuning */
+					if ((mode_context->ref_freq != 0) &&
+							(mode_context->ref_freq >= 190000) &&
+							(mode_context->ref_freq <= 210000)){
+						calc = (current_timings->htotal *
+									mode_context->ref_freq);
+					} else {
+						calc = (current_timings->htotal * LNC_CLOCK);
+					}
+
+					calc = (calc / (pipe->clock_reg->actual_dclk));
+					calc *= (current_timings->vtotal -1);
+					calc /= current_timings->vtotal;
+					pTimings_tmp.htotal = (short)calc;
+					current_timings->reserved_dd = wa->htotal =
+						pTimings_tmp.htotal;
+					EMGD_DEBUG("Delta = %d", wa->htotal);
+				}else if (current_timings->reserved_dd & TNC_HTOTAL_TUNED){
+					pTimings_tmp.htotal =
+						(short)(current_timings->reserved_dd &
+								(~TNC_HTOTAL_TUNED));
+				}else{
+					if(wa->htotal == 0)
+						wa->htotal = (short)current_timings->reserved_dd;
+					pTimings_tmp.htotal = wa->htotal;
+				}
+				/* Use vphase formula if available */
+				if(vphase){
+					pTimings_tmp.vtotal -= (short)vphase;
+					pTimings_tmp.vsync_start -= (short)vphase;
+					pTimings_tmp.vsync_end -= (short)vphase;
+					pTimings_tmp.vblank_end -= (short)vphase;
+				}else{
+					pTimings_tmp.hblank_end +=
+						(short) (pTimings_tmp.htotal - current_timings->htotal);
+				}
+			}
+		}
+
+
+		/* Program Timings */
+		temp = (unsigned long)(pTimings_tmp.htotal) << 16 | hactive_tmp;
+		WRITE_MMIO_REG_TNC(ports_tnc[i], timing_reg, temp);
+
+		temp = ((unsigned long) pTimings_tmp.hblank_end << 16) |
+			(unsigned long)(pTimings_tmp.hblank_start);
+		WRITE_MMIO_REG_TNC(ports_tnc[i], timing_reg + 0x04, temp);
+
+		temp = ((unsigned long)(current_timings->hsync_end) << 16) |
+			(unsigned long)(current_timings->hsync_start);
+		WRITE_MMIO_REG_TNC(ports_tnc[i], timing_reg + 0x08, temp);
+
+		temp = ((unsigned long)(pTimings_tmp.vtotal) << 16) | vactive_tmp;
+		WRITE_MMIO_REG_TNC(ports_tnc[i], timing_reg + 0x0C, temp);
+
+		temp = ((unsigned long)(pTimings_tmp.vblank_end) << 16) |
+			(unsigned long)(pTimings_tmp.vblank_start);
+		WRITE_MMIO_REG_TNC(ports_tnc[i], timing_reg + 0x10, temp);
+
+		temp = ((unsigned long)(pTimings_tmp.vsync_end)<< 16) |
+			(unsigned long)(pTimings_tmp.vsync_start);
+		WRITE_MMIO_REG_TNC(ports_tnc[i], timing_reg + 0x14, temp);
+
+		/*
+		 * If there is a linked mode it is either the VGA or a scaled
+		 * mode. If it is scaled then we need to use it as the source size.
+		 */
+		if (current_timings->extn_ptr) {
+			igd_timing_info_t *scaled_timings =
+				(igd_timing_info_t *)current_timings->extn_ptr;
+
+			if((scaled_timings->mode_info_flags & IGD_MODE_VESA) &&
+				(scaled_timings->mode_number <= VGA_MODE_NUM_MAX)) {
+				temp = (hactive << 16) | vactive;
+			} else {
+				EMGD_DEBUG("scaled_timings->width [%d], "
+						   "scaled_timings->height [%d]\n",
+					scaled_timings->width, scaled_timings->height);
+				temp = (unsigned long)scaled_timings->width  - 1;
+				temp = (temp << 16) |
+					(unsigned long)(scaled_timings->height - 1);
+			}
+		} else {
+			temp = (hactive_tmp << 16) | vactive_tmp;
+		}
+		WRITE_MMIO_REG_TNC(ports_tnc[i], timing_reg + 0x1C, temp);
+
+		/* Put pipe in interlaced mode if requested:
+		 *     should only happen for LVDS display if at all. */
+		if (current_timings->mode_info_flags & IGD_SCAN_INTERLACE) {
+			pipe_conf |= (INTERLACE_EN);
+		} else {
+			pipe_conf &= ~(INTERLACE_EN);
+		}
+
+		WRITE_MMIO_REG_TNC(ports_tnc[i], pipe->pipe_reg, pipe_conf);
+		WRITE_MMIO_REG_TNC(ports_tnc[i], pipe->pipe_reg, pipe_conf);
+
+		/* For LVDS port, don't touch dev3 registers stop after 1st iteration */
+		if (pt == IGD_PORT_LVDS) {
+			break;
+		}
+	}
+
+
+	/* Gen4 can check when the pipe is enabled. */
+	wait_pipe(IGD_PORT_LVDS, pipe->pipe_reg, 0x40000000);
+
+	/*
+	 * Set the VGA address range to 0xa0000 so that a normal (not VGA)
+	 * mode can be accessed through 0xa0000 in a 16bit world.
+	 */
+	WRITE_AR(context->device_context.virt_mmadr, 0x10, 0xb);
+	WRITE_VGA(context->device_context.virt_mmadr, GR_PORT, 0x06, 0x5);
+	WRITE_VGA(context->device_context.virt_mmadr, GR_PORT, 0x10, 0x1);
+
+	if(current_timings->extn_ptr) {
+		/* This means either internal scaling (LVDS) or centered VGA */
+		current_timings = current_timings->extn_ptr;
+		if(current_timings->extn_ptr) {
+			/* This is both the scaled and centered VGA */
+			current_timings = current_timings->extn_ptr;
+		}
+		if (current_timings->mode_info_flags & IGD_MODE_VESA) {
+			if (current_timings->mode_number <= VGA_MODE_NUM_MAX) {
+				kms_program_pipe_vga_tnc(emgd_crtc);
+			}
+		}
+	}
+
+	if (pt == IGD_PORT_SDVO) {
+		/*  Enable Chicken Bit */
+		/*  Setting BIT6 enable Pipe B Palette Write
+         *  to prevent hang during palette write */
+		WRITE_MMIO_REG_TNC(IGD_PORT_LVDS, 0x70400, 0x4088 | BIT6);
+	}
+
+	EMGD_TRACE_EXIT;
+	return;
+}
+
+
+
+static void kms_set_plane_pwr_tnc(emgd_crtc_t *emgd_crtc, unsigned long enable)
+{
+	unsigned long           plane_control;
+	unsigned long           plane_reg;
+	struct drm_device      *dev         = NULL;
+	igd_display_plane_t    *plane       = NULL;
+	igd_display_pipe_t     *pipe        = NULL;
+	igd_context_t          *context     = NULL;
+
+	EMGD_TRACE_ENTER;
+
+	EMGD_DEBUG("Program Plane: %s", enable?"ENABLE":"DISABLE");
+
+	pipe    = emgd_crtc->igd_pipe;
+	dev     = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+	plane   = PLANE(pipe->owner);
+
+	if (!plane) {
+		EMGD_ERROR_EXIT("Trying to set power to a plane that is not tied "
+			" to a crtc.");
+		return;
+	}
+
+	/* In case a plane update is already in progress */
+	wait_for_vblank_tnc(pipe->pipe_reg);
+
+	/* Get the current value of the plane control register */
+	plane_reg     = plane->plane_reg;
+	plane_control = EMGD_READ32(context->device_context.virt_mmadr + plane_reg);
+
+	if(plane->plane_reg == DSPACNTR) {
+		plane_control &= device_data_tnc->plane_a_preserve;
+	} else { /* if it's plane b or plane c */
+		plane_control &= device_data_tnc->plane_b_c_preserve;
+	}
+
+
+	if((enable == FALSE) ||
+		(context->device_context.power_state != IGD_POWERSTATE_D0)) {
+		/*
+		 * Note: The vga programming code does not have an "off". So
+		 * when programming the plane to off we make sure VGA is off
+		 * as well.
+		 */
+		disable_vga_tnc(context->device_context.virt_mmadr);
+
+		/*
+		 * To turn off plane A or B, the program have to trigger the plane A
+		 * or B start register.  Or else, it will not work.
+		 */
+		//plane_control &= 0xEFFFFFFF;
+
+		EMGD_WRITE32(plane_control,
+						context->device_context.virt_mmadr + plane_reg);
+
+		EMGD_WRITE32(EMGD_READ32(context->device_context.virt_mmadr +
+			plane_reg + DSP_START_OFFSET),
+			context->device_context.virt_mmadr + plane_reg + DSP_START_OFFSET);
+	} else {
+		/* Enable Pipe */
+		plane_control |= 0x80000000;
+
+		EMGD_WRITE32(plane_control,
+			context->device_context.virt_mmadr + plane_reg);
+
+		EMGD_WRITE32(EMGD_READ32(context->device_context.virt_mmadr +
+			plane_reg + DSP_START_OFFSET),
+			context->device_context.virt_mmadr + plane_reg + DSP_START_OFFSET);
+	}
+
+
+	wait_for_vblank_tnc(pipe->pipe_reg);
+	EMGD_TRACE_EXIT;
+	return;
+}
+
+
+
+static void kms_program_plane_tnc(emgd_crtc_t *emgd_crtc, unsigned long status)
+{
+	unsigned long stride;
+	unsigned long stereo;
+	unsigned long plane_control;
+	unsigned long other_plane_reg;
+	igd_timing_info_t      *timing      = NULL;
+	igd_framebuffer_info_t *fb_info     = NULL;
+	unsigned long           plane_reg;
+	struct drm_device      *dev         = NULL;
+	igd_display_plane_t    *plane       = NULL;
+	igd_display_pipe_t     *pipe        = NULL;
+	igd_context_t          *context     = NULL;
+	igd_timing_info_t      *pipe_timing = NULL;
+	unsigned long           ulreg       = 0;
+	unsigned long           b_reg       = 0;
+	/* tnc_wa_timing_t *wa = WA_TUNE; */
+
+	EMGD_TRACE_ENTER;
+
+
+	pipe    = emgd_crtc->igd_pipe;
+	dev     = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+
+	plane     = PLANE(pipe->owner);
+	if (!plane) {
+		EMGD_ERROR("Trying to program a plane that is not tied to a crtc.");
+		return;
+	}
+	fb_info   = plane->fb_info;
+	plane_reg = plane->plane_reg;
+
+
+	EMGD_DEBUG("Device power state: D%ld", context->device_context.power_state);
+
+	wait_for_vblank_tnc(pipe->pipe_reg);
+
+	plane_control = EMGD_READ32(context->device_context.virt_mmadr + plane_reg);
+	if(plane->plane_reg == DSPACNTR) {
+		plane_control &= device_data_tnc->plane_a_preserve;
+	} else { /* if it's plane b or plane c */
+		plane_control &= device_data_tnc->plane_b_c_preserve;
+	}
+
+
+	if((status == FALSE) ||
+		(context->device_context.power_state != IGD_POWERSTATE_D0)) {
+
+		/*
+		 * Note: The vga programming code does not have an "off". So
+		 * when programming the plane to off we make sure VGA is off
+		 * as well.
+		 */
+		disable_vga_tnc(context->device_context.virt_mmadr);
+
+		/*
+		 * To turn off plane A or B, the program have to triger the plane A or B
+		 * start register.  Or else, it will not work.
+		 */
+		EMGD_WRITE32(plane_control,
+						context->device_context.virt_mmadr + plane_reg);
+
+		EMGD_WRITE32(EMGD_READ32(context->device_context.virt_mmadr +
+			plane_reg + DSP_START_OFFSET),
+			context->device_context.virt_mmadr + plane_reg + DSP_START_OFFSET);
+
+		wait_for_vblank_tnc(pipe->pipe_reg);
+		EMGD_TRACE_EXIT;
+		return;
+	}
+
+	/*
+	 * Note: The very first pass through this function will be with
+	 * status false and timings == NULL. Don't use the timings before
+	 * the check above.
+	 */
+	timing = pipe->timing;
+	pipe_timing = timing;
+	/* There is a special case code for legacy VGA modes */
+	while (timing->extn_ptr) {
+		timing = (igd_timing_info_t *)timing->extn_ptr;
+	}
+	if(MODE_IS_VGA(timing) && CHECK_VGA(pipe_timing)) {
+		kms_program_plane_vga(context->device_context.virt_mmadr, timing);
+		EMGD_TRACE_EXIT;
+		return;
+	}
+
+	disable_vga_tnc(context->device_context.virt_mmadr);
+
+	/* enable plane, select pipe, enable gamma correction logic */
+	plane_control |= 0x80000000 | (pipe->pipe_num<<24);
+	pipe->plane = plane;
+	plane_control |= (1<<30);
+
+
+	/* Here the settings:
+	 *   If line + pixel dbling, set 21,20 to 01b, and set Horz Multiply
+	 *   If line dbling only,    set 21,20 to 11b
+	 *   If pixel dbling only,   set 21,20 to 00b, but set Horz Multiply
+	 *   If no doubling,         set 21,20 to 00b (no Horz Multiply)
+	 * For pixel doubling
+	 *           --> both progressive/interlaced modes
+	 * For Line doubling
+	 *           --> progressive modes only
+	 */
+
+	if (!(timing->mode_info_flags & IGD_SCAN_INTERLACE)) {
+		/* Line doubling in progressive mode requires special bits */
+		if (timing->mode_info_flags & IGD_LINE_DOUBLE) {
+			/* BIT 20 for line & pixel doubling*/
+			plane_control |= BIT20;
+			/* check later, if no pixel doubling, set bit 21 too*/
+		}
+	}
+	if (timing->mode_info_flags & IGD_PIXEL_DOUBLE) {
+		/* For line ONLY doubling, set bit 21 also '1' */
+		plane_control |= BIT21;
+	}
+
+	kms_mode_get_stride_stereo_tnc(pipe, plane, &stride, &stereo, 0);
+
+	/* set color depth */
+	switch (IGD_PF_DEPTH(fb_info->pixel_format)) {
+	case PF_DEPTH_8:
+		plane_control |= BIT27 | BIT30;
+		break;
+	case PF_DEPTH_16:
+		plane_control |= BIT28 | BIT26;
+		break;
+	default:
+	case PF_DEPTH_32:
+		plane_control |= BIT28 | BIT27;
+		break;
+	}
+
+	if(fb_info->flags & IGD_ENABLE_DISPLAY_GAMMA) {
+		plane_control |= (BIT30);
+	}
+
+	if(fb_info->flags & IGD_SURFACE_TILED) {
+		plane_control |= (BIT10);
+	}
+
+	/* Set watermark for Atom E6xx */
+	if (!mode_context->en_reg_override) {
+		if (plane_reg == DSPACNTR) {
+			other_plane_reg = DSPBCNTR;
+		} else {
+			other_plane_reg = DSPACNTR;
+		}
+
+		if (EMGD_READ32(context->device_context.virt_mmadr + other_plane_reg) &
+				0x80000000) {
+
+			EMGD_WRITE32(device_data_tnc->dsp_arb,
+				context->device_context.virt_mmadr + PIPEA_DISP_ARB_CTRL);
+		} else if (plane_reg == DSPACNTR) {
+			EMGD_WRITE32(0x00003fff,
+				context->device_context.virt_mmadr + PIPEA_DISP_ARB_CTRL);
+		} else {
+			EMGD_WRITE32(0x00003f80,
+				context->device_context.virt_mmadr + PIPEA_DISP_ARB_CTRL);
+		}
+
+		/*
+		 * Setting WM priority level to 11
+		 * to workaround display bouncing issues
+		 * TODO: Mode set from Clone->Single(Primary)
+		 * PIPEA_DISP_ARB_CTRL does not get updated
+		 */
+		ulreg = EMGD_READ32(context->device_context.virt_mmadr + 0x00020f8);
+		EMGD_WRITE32(ulreg | 0x000003f0,
+		context->device_context.virt_mmadr + 0x00020f8);
+
+		EMGD_WRITE32(device_data_tnc->fifo_watermark1,
+			context->device_context.virt_mmadr + FW_1);
+		EMGD_WRITE32(device_data_tnc->fifo_watermark2,
+			context->device_context.virt_mmadr + FW_2);
+		EMGD_WRITE32(device_data_tnc->fifo_watermark3,
+			context->device_context.virt_mmadr + FW_3);
+		EMGD_WRITE32(device_data_tnc->fifo_watermark4,
+			context->device_context.virt_mmadr + FW_4);
+		EMGD_WRITE32(device_data_tnc->fifo_watermark5,
+			context->device_context.virt_mmadr + FW_5);
+		EMGD_WRITE32(device_data_tnc->fifo_watermark6,
+			context->device_context.virt_mmadr + FW_6);
+	} else {
+		/* en_reg_override=1 */
+		/* Override display registers */
+		EMGD_WRITE32(mode_context->gvd_hp_control,
+			context->device_context.virt_mmadr + 0x00020f8);
+		EMGD_WRITE32(mode_context->disp_arb,
+			context->device_context.virt_mmadr + PIPEA_DISP_ARB_CTRL);
+		EMGD_WRITE32(mode_context->fifo_watermark1,
+			context->device_context.virt_mmadr + FW_1);
+		EMGD_WRITE32(mode_context->fifo_watermark2,
+			context->device_context.virt_mmadr + FW_2);
+		EMGD_WRITE32(mode_context->fifo_watermark3,
+			context->device_context.virt_mmadr + FW_3);
+		EMGD_WRITE32(mode_context->fifo_watermark4,
+			context->device_context.virt_mmadr + FW_4);
+		EMGD_WRITE32(mode_context->fifo_watermark5,
+			context->device_context.virt_mmadr + FW_5);
+		EMGD_WRITE32(mode_context->fifo_watermark6,
+			context->device_context.virt_mmadr + FW_6);
+		EMGD_WRITE32(mode_context->disp_chicken_bits,
+			context->device_context.virt_mmadr + 0x0070400);
+
+		/* Override Bunit Chickenbits and BWFLUSH register */
+		write_bunit_tnc(0x30, mode_context->bunit_chicken_bits);
+		write_bunit_tnc(0x02, mode_context->bunit_write_flush);
+	}
+
+	EMGD_DEBUG(" GVD HP_CONTROL: 0x%lx", ulreg);
+	ulreg = EMGD_READ32(context->device_context.virt_mmadr +
+				PIPEA_DISP_ARB_CTRL);
+	EMGD_DEBUG(" Display Arbitration register: 0x%lx", ulreg);
+	ulreg = EMGD_READ32(context->device_context.virt_mmadr + FW_1);
+	EMGD_DEBUG(" FIFO Watermark Control Register 1: 0x%lx", ulreg);
+	ulreg = EMGD_READ32(context->device_context.virt_mmadr + FW_2);
+	EMGD_DEBUG(" FIFO Watermark Control Register 2: 0x%lx", ulreg);
+	ulreg = EMGD_READ32(context->device_context.virt_mmadr + FW_3);
+	EMGD_DEBUG(" FIFO Watermark Control Register 3: 0x%lx", ulreg);
+	ulreg = EMGD_READ32(context->device_context.virt_mmadr + FW_4);
+	EMGD_DEBUG(" FIFO Watermark Control Register 4: 0x%lx", ulreg);
+	ulreg = EMGD_READ32(context->device_context.virt_mmadr + FW_5);
+	EMGD_DEBUG(" FIFO Watermark Control Register 5: 0x%lx", ulreg);
+	ulreg = EMGD_READ32(context->device_context.virt_mmadr + FW_6);
+	EMGD_DEBUG(" FIFO Watermark Control Register 6: 0x%lx", ulreg);
+	ulreg = EMGD_READ32(context->device_context.virt_mmadr + DSP_CHICKENBITS);
+	EMGD_DEBUG(" Display Chicken bits: 0x%lx", ulreg);
+	read_bunit_tnc(0x30, &b_reg);
+	EMGD_DEBUG(" Bunit Chicken bits: 0x%lx", b_reg);
+	read_bunit_tnc(0x02, &b_reg);
+	EMGD_DEBUG(" Bunit Write Flush: 0x%lx", b_reg);
+
+
+	/* FIXME: Not required for TNC.
+	 * The B-Spec states that rendering will be slower if the fences are not
+	 * a power of 2.  So for now, always use a power of 2. */
+	/* EMGD_WRITE32(0x04000400, context->device_context.virt_mmadr + 0x209c); */
+
+	EMGD_DEBUG(" Plane Control:  0x%lx", plane_control);
+	EMGD_DEBUG(" Plane Base:     0x%lx", fb_info->fb_base_offset);
+	EMGD_DEBUG(" Visible Offset: 0x%lx", fb_info->visible_offset);
+	EMGD_DEBUG(" Plane Pitch:    0x%lx", stride);
+
+	EMGD_WRITE32(plane_control, context->device_context.virt_mmadr + plane_reg);
+	EMGD_WRITE32(stride,
+		context->device_context.virt_mmadr + plane_reg + DSP_STRIDE_OFFSET);
+
+	EMGD_WRITE32(fb_info->visible_offset,
+		context->device_context.virt_mmadr + plane_reg + DSP_LINEAR_OFFSET);
+	EMGD_WRITE32(0, context->device_context.virt_mmadr + plane_reg + 0x24);
+	EMGD_WRITE32(fb_info->fb_base_offset,
+		context->device_context.virt_mmadr + plane_reg + DSP_START_OFFSET);
+
+	wait_for_vblank_tnc(pipe->pipe_reg);
+
+	EMGD_TRACE_EXIT;
+}
+
+
+/*!
+ *
+ * @param emgd_encoder
+ * @param status
+ *
+ * @return program_port_lvds_gen4()
+ * @return program_port_sdvo_gen4()
+ * @return -IGD_ERROR_INVAL on failure
+ */
+static int kms_program_port_tnc(emgd_encoder_t *emgd_encoder,
+		unsigned long status)
+{
+	EMGD_TRACE_ENTER;
+
+	if (emgd_encoder->igd_port->port_type == IGD_PORT_LVDS) {
+		EMGD_TRACE_EXIT;
+		return kms_program_port_lvds_tnc(emgd_encoder, status);
+	} else {
+		EMGD_TRACE_EXIT;
+		return kms_program_port_sdvo_tnc(emgd_encoder, status);
+	}
+}
+
+
+/*!
+ *
+ * @param emgd_encoder
+ * @param status
+ *
+ * @return 0 on success
+ * @return -IGD_ERROR_INVAL on failure
+ */
+int kms_program_port_lvds_tnc(emgd_encoder_t *emgd_encoder,
+		unsigned long status)
+{
+	int ret = 0;
+	unsigned long pd_powerstate = PD_POWER_MODE_D3;
+	pd_timing_t        *timing    = NULL;
+	igd_display_port_t *port      = NULL;
+	struct drm_encoder *encoder   = NULL;
+	struct drm_device  *dev       = NULL;
+	igd_context_t      *context   = NULL;
+	struct drm_crtc    *crtc      = NULL;
+	emgd_crtc_t        *emgd_crtc = NULL;
+	igd_display_pipe_t *pipe      = NULL;
+
+	EMGD_TRACE_ENTER;
+
+	encoder = &emgd_encoder->base;
+	port = emgd_encoder->igd_port;
+	dev = encoder->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+
+	EMGD_DEBUG("Program LVDS: (%s)", status?"ENABLE":"DISABLE");
+
+	if (status == TRUE) {
+
+		if(!(port->pt_info->flags & IGD_DISPLAY_ENABLE)) {
+			EMGD_TRACE_EXIT;
+			return 0;
+		}
+
+		pd_powerstate = (context->device_context.power_state > port->power_state) ?
+			context->device_context.power_state : port->power_state;
+
+		if (pd_powerstate == IGD_POWERSTATE_D0) {
+			EMGD_DEBUG("Power State: D0");
+
+			list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+				if (crtc == encoder->crtc) {
+					emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+					pipe = emgd_crtc->igd_pipe;
+					break;
+				}
+			}
+
+			timing = (pd_timing_t *)pipe->timing;
+			/* Reach end timing to get user resolution and pass it to pd */
+			if(timing->extn_ptr) {
+				timing = (pd_timing_t *)timing->extn_ptr;
+			}
+			/* set mode will take care of port control */
+			ret = port->pd_driver->set_mode(
+					port->pd_context,
+					timing,
+					1<<pipe->pipe_num);
+		}
+	}
+
+	/* either status == FALSE, or status == TRUE, but powerstate is D1/D2/D3 */
+	if (pd_powerstate != IGD_POWERSTATE_D0) {
+		ret = port->pd_driver->set_power(
+			port->pd_context, PD_POWER_MODE_D3);
+	}
+
+	if (ret) {
+		EMGD_ERROR_EXIT("PD set_%s returned: 0x%x",
+			(pd_powerstate == IGD_POWERSTATE_D0)?"mode":"power", ret);
+		return -IGD_ERROR_INVAL;
+	}
+
+	EMGD_TRACE_EXIT;
+	return ret;
+}
+
+
+/*!
+ *
+ * @param emgd_encoder
+ * @param status
+ *
+ * @return 0 on success
+ * @return -IGD_ERROR_INVAL on failure
+ */
+static int kms_program_port_sdvo_tnc(emgd_encoder_t *emgd_encoder,
+		unsigned long status)
+{
+	unsigned long port_control;
+	unsigned long pd_powerstate = PD_POWER_MODE_D3;
+	unsigned long preserve = 0;
+	unsigned long upscale = 0;
+	igd_timing_info_t  local_timing;
+	igd_timing_info_t  *timing    = NULL;
+	igd_display_port_t *port      = NULL;
+	struct drm_encoder *encoder   = NULL;
+	struct drm_device  *dev       = NULL;
+	igd_context_t      *context   = NULL;
+	struct drm_crtc    *crtc      = NULL;
+	emgd_crtc_t        *emgd_crtc = NULL;
+	igd_display_pipe_t *pipe      = NULL;
+	unsigned long temp;
+	int ret;
+
+	EMGD_TRACE_ENTER;
+
+	encoder = &emgd_encoder->base;
+	port = emgd_encoder->igd_port;
+	dev = encoder->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+
+	EMGD_DEBUG("Program Port: (%s)", status?"ENABLE":"DISABLE");
+	EMGD_DEBUG("pd_flags: 0x%lx", port->pd_flags);
+
+	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+		if (crtc == encoder->crtc) {
+			emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+			pipe = emgd_crtc->igd_pipe;
+			break;
+		}
+	}
+
+	timing = pipe->timing;
+
+	port_control = preserve & READ_MMIO_REG_TNC(IGD_PORT_SDVO,
+			port->port_reg);
+
+	if (status == TRUE) {
+		if (!(port->pt_info->flags & IGD_DISPLAY_ENABLE)) {
+			EMGD_TRACE_EXIT;
+			return 0;
+		}
+
+		/* Enable VGA syncs for native vga modes */
+		if (port->vga_sync == 1) {
+			EMGD_DEBUG("VGA sync true, is width x height 720 x 400?");
+			if((timing->width == 720) && (timing->height == 400)) {
+				EMGD_DEBUG("Modify port control and multi_port_control");
+				port_control |= (1L<<15);
+			}
+		}
+
+		/* Fact that both IGD_ powerstates and PD_ powermodes have
+		 * same definitions */
+		pd_powerstate =
+			(context->device_context.power_state > port->power_state) ?
+			context->device_context.power_state : port->power_state;
+
+		if (pd_powerstate == IGD_POWERSTATE_D0) {
+			EMGD_DEBUG("Power State: D0");
+			/* Upscale */
+			pi_pd_find_attr_and_value(port,
+				PD_ATTR_ID_PANEL_FIT,
+				0, /*no PD_FLAG for UPSCALING */
+				NULL, /* dont need the attr ptr*/
+				&upscale);
+
+			/* Reach the end timing if upscaling is enabled */
+			if (timing->extn_ptr && upscale) {
+				timing = (pd_timing_t *)timing->extn_ptr;
+			}
+
+			local_timing = *timing;
+			if (upscale) {
+				/* For timings smaller than width 360 and height 200,
+				 * double the size. This is because the active area of the mode
+				 * is double the size of the resolution for these modes
+				 *  - Very tricky huh */
+				if (local_timing.width <= 360) {
+					local_timing.width <<= 1;
+				}
+				if (local_timing.height <= 200) {
+					local_timing.height <<= 1;
+				}
+			}
+
+			/* BIT31 - Enable
+			 * BIT30 - PIPE B
+			 * BIT29 - Stall
+			 * BIT7  - Border
+			 */
+			port_control |= BIT31|BIT30|BIT29|BIT7;
+
+			/* Program cDVO registers:
+			 * Keep default values for
+			 *     7000h - cDVO control register
+			 *     7004h - cDVO slew rate register
+			 *     7008h - cDVO strength register
+			 *     700Ch - cDVO RCOMP update register
+			 *     6102Ch - cDVO stall register = 0xA.
+			 * Note: Though EAS says 6102Ch default value is 6, it is a typo
+			 *     in the spec, based on Si DE hw default value is 10 (0xA),
+			 *     so no need to program explicitly. This saves few bytes for
+			 *     micro.
+			 */
+
+			/* Enable Current Source */
+			temp = READ_MMIO_REG_TNC(IGD_PORT_SDVO, SDVO_BUFF_CTRL_REG);
+			temp |= 0x2000;
+			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, SDVO_BUFF_CTRL_REG, temp);
+		}
+	}
+
+	if (pd_powerstate == PD_POWER_MODE_D0) {
+		ret = port->pd_driver->set_mode(port->pd_context, &local_timing, 0);
+	} else {
+		ret = port->pd_driver->set_power(port->pd_context, pd_powerstate);
+	}
+
+	if (ret) {
+		EMGD_ERROR_EXIT("PD set_%s returned: 0x%x",
+			(pd_powerstate == PD_POWER_MODE_D0)?"mode":"power", ret);
+		return -IGD_ERROR_INVAL;
+	}
+
+	EMGD_DEBUG("Port_control: 0x%lx", port_control);
+
+	WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, port->port_reg, port_control);
+
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+
+
+
+/*!
+ * @param emgd_encoder
+ * @param status
+ *
+ * @return 0 on success
+ * @return 1 on failure
+ */
+static int kms_post_program_port_tnc(emgd_encoder_t * emgd_encoder,
+	unsigned long status)
+{
+	int ret;
+	struct drm_device  *dev       = NULL;
+	igd_context_t      *context   = NULL;
+	igd_display_port_t *port      = NULL;
+	igd_display_pipe_t *pipe      = NULL;
+	struct drm_encoder *encoder   = NULL;
+	struct drm_crtc    *crtc      = NULL;
+	emgd_crtc_t        *emgd_crtc = NULL;
+	igd_timing_info_t  *timings   = NULL;
+	/* unsigned long portreg; */
+
+	EMGD_TRACE_ENTER;
+
+	encoder = &emgd_encoder->base;
+	dev = encoder->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+	port = emgd_encoder->igd_port;
+
+	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+		if (crtc == encoder->crtc) {
+			emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+			pipe = emgd_crtc->igd_pipe;
+			timings = pipe->timing;
+			break;
+		}
+	}
+
+	/*
+	 * The programming found in the common code for all chipsets
+	 * has the device programming sequence as follows:
+	 *  Port
+	 *  Pipe
+	 *  Post Port
+	 *  Plane
+	 * On Gen4, if the port is enabled before the pipe, there is a 10%
+	 * chance that the port will not turn on properly.
+	 * Due to compatability requires with other chipsets, this workaround
+	 * fixes this issue
+	 *
+	 * This is handled by set_power.  This also only seems to apply to a
+	 * chipset that is no longer supported.  Not sure if this will get
+	 * re-introduced with ValleyView and beyond, so I left it here.
+	 *
+	 * portreg = READ_MMIO_REG_TNC(port->port_type, port->port_reg);
+	 * WRITE_MMIO_REG_TNC(port->port_type, port->port_reg, portreg & ~BIT31);
+	 * WRITE_MMIO_REG_TNC(port->port_type, port->port_reg, portreg);
+	 */
+
+	if (port->port_type == IGD_PORT_SDVO) {
+		initialize_ST_bridge(context, port);
+	}
+
+	ret = 0;
+	/* call post_set_mode() if exists */
+	if (port->pd_driver->post_set_mode) {
+		if (port->port_type == IGD_PORT_SDVO){
+			ret = port->pd_driver->post_set_mode(port->pd_context, timings,
+				status); /*Needed for OKI*/
+		} else {
+			ret = port->pd_driver->post_set_mode(port->pd_context, timings,
+				1<<pipe->pipe_num);
+		}
+		if (ret) {
+			EMGD_ERROR_EXIT("PD post_set_mode returned: 0x%x", ret);
+		}
+	}
+
+	EMGD_TRACE_EXIT;
+	return ret;
+}
+
+
+
+/*!
+ * kms_get_vblank_counter_tnc
+ *
+ * This function returns the vblank counter number back to the caller.
+ *
+ * @param emgd_crtc [IN] The pipe to get frame value from
+ *
+ * @return 0 frame number, which can also be used as a vblank counter number
+ */
+static u32 kms_get_vblank_counter_tnc(emgd_crtc_t *emgd_crtc)
+{
+	unsigned long      high1, high2, low;
+	struct drm_device *dev;
+	unsigned long      frame_high_reg, frame_low_reg;
+	igd_context_t     *context;
+
+
+	dev     = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+
+
+	switch (emgd_crtc->igd_pipe->pipe_features & IGD_PORT_MASK) {
+		case IGD_PORT_SHARE_DIGITAL:
+			frame_high_reg = PIPEB_FRAME_HIGH;
+			frame_low_reg  = PIPEB_FRAME_PIXEL;
+			break;
+
+		case IGD_PORT_SHARE_LVDS:
+		default:
+			frame_high_reg = PIPEA_FRAME_HIGH;
+			frame_low_reg  = PIPEA_FRAME_PIXEL;
+			break;
+	}
+
+
+	/*
+	 * High and low register fields are not synchronized so it is possible
+	 * that our low value is actually not from the same high value, e.g.
+	 * going from "99" to "00" when transitioning 499 to 500.  To get
+	 * around this, we will read until the two reads of high values stay
+	 * the same.
+	 */
+	do {
+		high1 = EMGD_READ32(context->device_context.virt_mmadr +
+					frame_high_reg);
+		high1 &= PIPE_FRAME_HIGH_MASK;
+
+		low   = EMGD_READ32(context->device_context.virt_mmadr +
+					frame_low_reg);
+		low   &= PIPE_FRAME_LOW_MASK;
+
+		high2 = EMGD_READ32(context->device_context.virt_mmadr +
+					frame_high_reg);
+		high2 &= PIPE_FRAME_HIGH_MASK;
+	} while (high1 != high2);
+
+
+	/* Frame count low is located at bits 24-31 */
+	low >>= PIPE_FRAME_LOW_SHIFT;
+
+	/* Low value is 8 bits long, so shift high by 8 bits */
+	return (high1 << 8) | low;
+}
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/micro_mode_tnc.c b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/micro_mode_tnc.c
index 1d2b828..8ac057c 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/micro_mode_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/micro_mode_tnc.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: micro_mode_tnc.c
- * $Revision: 1.40 $
+ * $Revision: 1.46 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -59,9 +59,11 @@
 #include <tnc/mi.h>
 #include <tnc/instr.h>
 #include <tnc/igd_tnc_wa.h>
+#include "drm_emgd_private.h"
 
 #include "../cmn/match.h"
 #include "../cmn/mode_dispatch.h"
+#include "mode_tnc.h"
 
 /*
 	Turning on FIB part workaround for all IALs, for vBIOS this will limit
@@ -82,10 +84,12 @@
 extern int program_clock_tnc(igd_display_context_t *display,
 	igd_clock_t *clock, unsigned long dclk);
 
+extern unsigned long get_port_type(int crtc_id);
+
 extern mode_full_dispatch_t mode_full_dispatch_tnc;
 
 int wait_for_vblank_tnc(unsigned long pipe_reg);
-static void wait_pipe(unsigned long pipe_reg, unsigned long check_on_off);
+void wait_pipe(unsigned long pt, unsigned long pipe_reg, unsigned long check_on_off);
 
 void shutdown_ST_bridge(igd_context_t *context);
 void initialize_ST_bridge(igd_context_t *context, igd_display_port_t *port);
@@ -94,36 +98,8 @@ void initialize_ST_bridge(igd_context_t *context, igd_display_port_t *port);
 static void cdvo_signal(void);
 #endif
 
-typedef struct _mode_data_tnc {
-	unsigned long plane_a_preserve;
-	unsigned long plane_b_c_preserve;
-	unsigned long pipe_preserve;
-	unsigned long dsp_arb;
-	unsigned long fifo_watermark1;
-	unsigned long fifo_watermark2;
-	unsigned long fifo_watermark3;
-	unsigned long fifo_watermark4;
-	unsigned long fifo_watermark5;
-	unsigned long fifo_watermark6;
-} mode_data_tnc_t;
-
-static mode_data_tnc_t device_data[1] = {
-	{
-		0x000b0000, /* plane a preservation */
-		0x00000000, /* plane b c preservation */
-		0x60000000, /* pipe preservation */
-		0x00003232, /* DSP FIFO Size A=50 B=50 C=28 May require fine tuning*/
-		0x3f8f0404, /* FIFO watermark control1 */
-		0x04040f04, /* FIFO watermark control2 */
-		0x00000000, /* FIFO watermark control3 */
-		0x04040404, /* FIFO watermark1 control4 */
-		0x04040404, /* FIFO watermark1 control5 */
-		0x00000078, /* FIFO watermark1 control6 */
-	}
-};
-
-/* Do not change the order */
-static const unsigned long ports_tnc[2] = {IGD_PORT_LVDS, IGD_PORT_SDVO};
+static unsigned long flag_clip_fix = IGD_CLIP_FIX_GLOBAL_ENABLE |
+	IGD_CLIP_FIX_DISABLE_THROTTLE;
 
 /* Extern defines for Device2, device3 and device31 iobases.
  * For Atom E6xx all devices are always io_mapped. */
@@ -140,30 +116,38 @@ extern unsigned short io_base_sdvo_st;
 extern unsigned char io_mapped_sdvo_st_gpio;
 extern unsigned short io_base_sdvo_st_gpio;
 
-static tnc_wa_timing_t tune = {0, 0, 0, 0, 0, 0, 0,};
-
-#ifndef CONFIG_MICRO
-#define CHECK_VGA(a) MODE_IS_VGA(a)
 #ifdef DEBUG_BUILD_TYPE
-#define FLAG(a) a
-/* Debug configuration flag for B0 workaround. Workaround is turned on by default */
-static int flag_turn_off_port_wa = 1;			/* Turn off port when sweeping */
-static int flag_enable_tuning_wa = 1;			/* Disable sweeping flag */
-static int flag_basic_htotal_formula_wa = 1;    /* Enable formula workaround flag */
-#else
-/* Turn all workaround for release driver */
-#define FLAG(a) 1
+/* Debug configuration flag for B0 workaround. Workaround is turned on by default. */
+int flag_basic_htotal_formula_wa = 1;    /* Enable formula workaround flag */
+int flag_turn_off_port_wa = 1;           /* Turn off port when sweeping */
+int flag_enable_tuning_wa = 1;           /* Disable sweeping flag */
 #endif
 
-/* VPhase variable */
-static int vphase = 0;							/* The current value to enable  vphase is 5 */
+/* Do not change the order */
+const unsigned long ports_tnc[2] = {IGD_PORT_LVDS, IGD_PORT_SDVO};
+
+tnc_wa_timing_t tune = {0, 0, 0, 0, 0, 0, 0,};
 
 /* Temporary frame buffer */
 static igd_framebuffer_info_t fb_info_tmp = {0,0,0,0,0,0,0};
 
-#else
-#define CHECK_VGA(a) 1
-#endif
+/* VPhase variable */
+int vphase = 0;	/* The current value to enable  vphase is 5 */
+
+mode_data_tnc_t device_data_tnc[1] = {
+	{
+		0x000b0000, /* plane a preservation */
+		0x00000000, /* plane b c preservation */
+		0x60000000, /* pipe preservation */
+		0x00003232, /* DSP FIFO Size A=50 B=50 C=28 May require fine tuning*/
+		0x3f8f0404, /* FIFO watermark control1 */
+		0x04040f04, /* FIFO watermark control2 */
+		0x00000000, /* FIFO watermark control3 */
+		0x04040404, /* FIFO watermark1 control4 */
+		0x04040404, /* FIFO watermark1 control5 */
+		0x00000078, /* FIFO watermark1 control6 */
+	}
+};
 
 pixel_crc_t compute_pixel_crc( pixel_crc_t  pixel, pixel_crc_t  new_pixel)
 {
@@ -234,14 +218,17 @@ int check_display_tnc(igd_display_context_t *display,
 		|| (mode_context->tuning_wa == 0) /*if 0 don't tune*/
 		|| wa->counter > LIMIT_TOTAL_CHECK_DISPLAY
 		|| (MODE_IS_VGA(pTimings_ext))
-		|| (!IGD_DC_CLONE(dc) && !IGD_DC_EXTENDED(dc))){
+		|| (!IGD_DC_CLONE(dc) && !IGD_DC_EXTENDED(dc))
+		|| (platform_context->tnc_dev3_rid != TNC_B0_DEV3_RID)){
 		/* Workaround is specific for SDVO display
 		 * Dont tuned if it isnt B0 silicon
 		 * Dont tuned if it is already tuned
 		 * Dont tuned if bypass is turned on (debug)
 		 * No tuning for VGA modes
 		 * Stop Tuning if above limit LIMIT_TOTAL_CHECK_DISPLAY
+		 * Dont tuned if B1 silicon (based on SDVO Device 3 RID)
 		 */
+
 		if(pt != IGD_PORT_SDVO ||
 			(MODE_IS_VGA(pTimings_ext))){
 			EMGD_DEBUG("Unsupported tuning");
@@ -344,7 +331,7 @@ int check_display_tnc(igd_display_context_t *display,
 	dst_rect.y2 = fb_info_tmp.height;
 
 	/*
- 	// NOT supported in koheo, using software for now
+	// NOT supported in koheo, using software for now
 	display->context->dispatch.color_blt((igd_display_h)display,
 				IGD_PRIORITY_NORMAL,
 				&front_buffer,
@@ -378,7 +365,7 @@ int check_display_tnc(igd_display_context_t *display,
 	dst_rect.y2 = fb_info_tmp.height;
 
 	/*
- 	// NOT supported in koheo, using software for now
+	// NOT supported in koheo, using software for now
 	display->context->dispatch.color_blt((igd_display_h)display,
 				IGD_PRIORITY_NORMAL,
 				&front_buffer,
@@ -566,132 +553,13 @@ int check_display_tnc(igd_display_context_t *display,
 }
 #endif
 
-#if 0
-/* Setting the CDVO Signal */
-static void cdvo_signal()
-{
-	// Low
-	WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x700c, 0x00008000);
-	WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x700c, 0x0008B400);
-	//OS_SLEEP(25);
-
-	// High
-	WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x700c, 0x0008B4FF);
-	//OS_SLEEP(25);
-}
-#endif
-
-#if 0
-/* disable this function now */
-/* This is the initialization code for B0 stepping */
-void program_cdvo(
-	igd_display_context_t *display,
-	unsigned long pipe_reg,
-	unsigned long pd_type)
-{
-	/* unsigned long pipe_conf; */
-	int i;
-	unsigned long pipe_conf;
-
-	EMGD_TRACE_ENTER;
-
-	/* For external lvds, pipe needs to be disabled and
-	 * run cdvo reset sequence only once during boot up.
-	 * All other pd type needs to run cdvo reset sequence
-	 * all the time so no display corruption.
-	 */
-	if ((!(pd_type & PD_DISPLAY_LVDS_EXT)) ||
-		(READ_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7000) != 0x50)) {
-
-		if (READ_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7000) != 0x50) {
-
-			pipe_conf = device_data->pipe_preserve &
-				READ_MMIO_REG_TNC(IGD_PORT_SDVO, PIPE(display)->pipe_reg);
-
-			/* Disable pipe */
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, PIPE(display)->pipe_reg,
-				pipe_conf & (~0x80000000L));
-
-			/* check when the pipe is disabled. */
-			wait_pipe(PIPE(display)->pipe_reg, 0);
-
-			/* Disable DPLL */
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO,
-				PIPE(display)->clock_reg->dpll_control,
-				READ_MMIO_REG_TNC(IGD_PORT_SDVO,
-				PIPE(display)->clock_reg->dpll_control) & ~0x80000000L);
-		}
-
-		if ((!(pd_type & PD_DISPLAY_LVDS_EXT)) ||
-			(READ_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7000) != 0x50)) {
-
-			//programmable cdvo stall
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x6102c, 0xf);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7000, 0x40);
-
-			//reset
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7000, 0x51);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7000, 0x50);
-
-			// High
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7014, 0x00004800);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x700c, 0x000BB4FF);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, SDVO_BUFF_CTRL_REG, 0x20022160);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7010, 0x06000200);
-
-			/* loop 3 pixels, 6 calls to cdvo_signal() */
-			for(i=0;i<6;i++){
-				cdvo_signal();
-			}
-
-			//reset
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7000, 0x51);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7000, 0x50);
-
-			// High
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7014, 0x00004800);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x700c, 0x000BB4FF);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, SDVO_BUFF_CTRL_REG, 0x20022160);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7010, 0x06000200);
-
-			/* loop 3 pixels, 6 calls to cdvo_signal() */
-			for(i=0;i<6;i++){
-				cdvo_signal();
-			}
-
-			//reset
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7000, 0x51);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7000, 0x50);
-
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7010, 0x02000200);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7014, 0x00004000);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, SDVO_BUFF_CTRL_REG, 0x20022160);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7010, 0x02000200);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7014, 0x00000800);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7014, 0x00004800);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7014, 0x00000000);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7000, 0x40);
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7000, 0x50);
-
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, 0x7014, 0x00004000);
-
-			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, SDVO_BUFF_CTRL_REG, 0x20022160);//enable sdvo
-
-			//WRITE_MMIO_REG_TNC(IGD_PORT_LVDS, 0x70400, 0x4088);//enable sdvo
-		}
-	}
-
-	EMGD_TRACE_EXIT;
-}
-#endif
-
 /*!
  *
  * @param mmio dev2 mmio
  *
  * @return void
  */
-static void disable_vga_tnc (unsigned char *mmio)
+void disable_vga_tnc (unsigned char *mmio)
 {
 	unsigned long temp;
 	unsigned char sr01;
@@ -823,6 +691,8 @@ int wait_for_vblank_tnc(unsigned long pipe_reg)
 		OS_SCHEDULE();
 		tmp = mode_context->dispatch->full->vblank_occured(request_for);
 	} while ((tmp == 0x00) && (!OS_TEST_ALARM(timeout)));
+
+
 	if (tmp == 0) {
 		EMGD_ERROR_EXIT("Timeout waiting for VBLANK");
 		ret = 0;
@@ -839,6 +709,8 @@ int wait_for_vblank_tnc(unsigned long pipe_reg)
 	return ret;
 } /* wait_for_vblank_tnc */
 
+
+
 /*!
  * This procedure waits for the next vertical blanking (vertical retrace)
  * period. If the display is already in a vertical blanking period, this
@@ -857,6 +729,7 @@ int igd_wait_vblank_tnc(igd_display_h display_handle)
 
 }
 
+
 /*!
  * Get the stride and stereo values based on the display.  This is also used
  * by the MI instructions.
@@ -974,6 +847,7 @@ int mode_get_stride_stereo_tnc(igd_display_context_t *display,
  * Disable DPLL
  */
 
+
 /*!
  *
  * @param display Pointer to hardware device instance data
@@ -1068,6 +942,55 @@ void program_pipe_vga_tnc(
 	return;
 }
 
+
+#ifndef CONFIG_MICRO
+extern os_pci_dev_t bridge_dev;
+int read_bunit_tnc(unsigned long reg, unsigned long *val)
+{
+	reg <<= 8;
+	reg &= 0x0000ff00;
+	reg |= 0xD00300F0;
+
+	EMGD_TRACE_ENTER;
+
+	if(OS_PCI_WRITE_CONFIG_32(bridge_dev, 0xD0, reg)) {
+		EMGD_ERROR_EXIT("Writing into the MCR Failed\n");
+		return -IGD_ERROR_INVAL;
+	}
+
+	if(OS_PCI_READ_CONFIG_32(bridge_dev, 0xD4, val)) {
+		EMGD_ERROR_EXIT("Reading from MDR Failed\n");
+		return -IGD_ERROR_INVAL;
+	}
+
+	EMGD_TRACE_EXIT;
+
+	return 0;
+}
+
+int write_bunit_tnc(unsigned long reg, unsigned long val)
+{
+	reg <<= 8;
+	reg &= 0x0000ff00;
+	reg |= 0xE00300F0;
+
+	EMGD_TRACE_ENTER;
+
+	if(OS_PCI_WRITE_CONFIG_32(bridge_dev, 0xD4, val)) {
+			EMGD_ERROR_EXIT("Writing into the MDR Failed\n");
+		return -IGD_ERROR_INVAL;
+	}
+
+	if(OS_PCI_WRITE_CONFIG_32(bridge_dev, 0xD0, reg)) {
+		EMGD_ERROR_EXIT("Writing into the MCR Failed\n");
+		return -IGD_ERROR_INVAL;
+	}
+
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+#endif
+
 /*!
  * Program Display Plane Values.
  *
@@ -1087,7 +1010,10 @@ void program_plane_tnc(igd_display_context_t *display,
 	igd_framebuffer_info_t *fb_info = PLANE(display)->fb_info;
 	unsigned long plane_reg = PLANE(display)->plane_reg;
 	igd_timing_info_t *pipe_timing;
-	unsigned long ulreg;
+#ifndef  CONFIG_MICRO
+	unsigned long ulreg = 0;
+#endif
+	unsigned long b_reg;
 	/* tnc_wa_timing_t *wa = WA_TUNE; */
 
 	EMGD_TRACE_ENTER;
@@ -1099,9 +1025,9 @@ void program_plane_tnc(igd_display_context_t *display,
 
 	plane_control = EMGD_READ32(MMIO(display) + plane_reg);
 	if(PLANE(display)->plane_reg == DSPACNTR) {
-		plane_control &= device_data->plane_a_preserve;
+		plane_control &= device_data_tnc->plane_a_preserve;
 	} else { /* if it's plane b or plane c */
-		plane_control &= device_data->plane_b_c_preserve;
+		plane_control &= device_data_tnc->plane_b_c_preserve;
 	}
 
 	/* TODO: Bspec: For EagleLake this Trickle Feed must always disable */
@@ -1204,41 +1130,80 @@ void program_plane_tnc(igd_display_context_t *display,
 
 	/* Set watermark for Atom E6xx */
 #ifndef  CONFIG_MICRO
+	if (!mode_context->en_reg_override) {
+		if (plane_reg == DSPACNTR) {
+			other_plane_reg = DSPBCNTR;
+		} else {
+			other_plane_reg = DSPACNTR;
+		}
 
-	if (plane_reg == DSPACNTR) {
-		other_plane_reg = DSPBCNTR;
-	} else {
-		other_plane_reg = DSPACNTR;
-	}
+		if (EMGD_READ32(MMIO(display) + other_plane_reg) & 0x80000000) {
+			EMGD_WRITE32(device_data_tnc->dsp_arb, MMIO(display) +
+				PIPEA_DISP_ARB_CTRL);
+		} else if (plane_reg == DSPACNTR) {
+			EMGD_WRITE32(0x00003fff, MMIO(display) + PIPEA_DISP_ARB_CTRL);
+		} else {
+			EMGD_WRITE32(0x00003f80, MMIO(display) + PIPEA_DISP_ARB_CTRL);
+		}
 
-	if (EMGD_READ32(MMIO(display) + other_plane_reg) & 0x80000000) {
-		EMGD_WRITE32(device_data->dsp_arb, MMIO(display) + DSP_ARB);
-	} else if (plane_reg == DSPACNTR) {
-		EMGD_WRITE32(0x00003fff, MMIO(display) + DSP_ARB);
+		/*
+		 * Setting WM priority level to 11
+		 * to workaround display bouncing issues
+		 * TODO: Mode set from Clone->Single(Primary)
+		 * PIPEA_DISP_ARB_CTRL does not get updated
+		 */
+		ulreg = EMGD_READ32(MMIO(display) + 0x00020f8);
+		EMGD_WRITE32(ulreg | 0x000003f0, MMIO(display) + 0x00020f8);
+
+		EMGD_WRITE32(device_data_tnc->fifo_watermark1, MMIO(display) + FW_1);
+		EMGD_WRITE32(device_data_tnc->fifo_watermark2, MMIO(display) + FW_2);
+		EMGD_WRITE32(device_data_tnc->fifo_watermark3, MMIO(display) + FW_3);
+		EMGD_WRITE32(device_data_tnc->fifo_watermark4, MMIO(display) + FW_4);
+		EMGD_WRITE32(device_data_tnc->fifo_watermark5, MMIO(display) + FW_5);
+		EMGD_WRITE32(device_data_tnc->fifo_watermark6, MMIO(display) + FW_6);
 	} else {
-		EMGD_WRITE32(0x00003f80, MMIO(display) + DSP_ARB);
-	}
-
-	/*
-	 * Setting WM priority level to 11
-	 * to workaround display bouncing issues
-	 * TODO: Mode set from Clone->Single(Primary)
-	 * DSP_ARB does not get updated
-	 */
-	ulreg = EMGD_READ32(MMIO(display) + 0x00020f8);
-	EMGD_WRITE32(ulreg | 0x000003f0, MMIO(display) + 0x00020f8);
-
-	EMGD_WRITE32(device_data->fifo_watermark1, MMIO(display) + FW_1);
-	EMGD_WRITE32(device_data->fifo_watermark2, MMIO(display) + FW_2);
-	EMGD_WRITE32(device_data->fifo_watermark3, MMIO(display) + FW_3);
-	EMGD_WRITE32(device_data->fifo_watermark4, MMIO(display) + FW_4);
-	EMGD_WRITE32(device_data->fifo_watermark5, MMIO(display) + FW_5);
-	EMGD_WRITE32(device_data->fifo_watermark6, MMIO(display) + FW_6);
-
+		/* en_reg_override=1 */
+		/* Override display registers */
+		EMGD_WRITE32(mode_context->gvd_hp_control, MMIO(display) + 0x00020f8);
+		EMGD_WRITE32(mode_context->disp_arb, MMIO(display) + PIPEA_DISP_ARB_CTRL);
+		EMGD_WRITE32(mode_context->fifo_watermark1, MMIO(display) + FW_1);
+		EMGD_WRITE32(mode_context->fifo_watermark2, MMIO(display) + FW_2);
+		EMGD_WRITE32(mode_context->fifo_watermark3, MMIO(display) + FW_3);
+		EMGD_WRITE32(mode_context->fifo_watermark4, MMIO(display) + FW_4);
+		EMGD_WRITE32(mode_context->fifo_watermark5, MMIO(display) + FW_5);
+		EMGD_WRITE32(mode_context->fifo_watermark6, MMIO(display) + FW_6);
+		EMGD_WRITE32(mode_context->disp_chicken_bits, MMIO(display) + 0x0070400);
+
+		/* Override Bunit Chickenbits and BWFLUSH register */
+		write_bunit_tnc(0x30, mode_context->bunit_chicken_bits);
+		write_bunit_tnc(0x02, mode_context->bunit_write_flush);
+	}
+
+	EMGD_DEBUG(" GVD HP_CONTROL: 0x%lx", ulreg);
+	ulreg = EMGD_READ32(MMIO(display) + PIPEA_DISP_ARB_CTRL);
+	EMGD_DEBUG(" Display Arbitration register: 0x%lx", ulreg);
+	ulreg = EMGD_READ32(MMIO(display) + FW_1);
+	EMGD_DEBUG(" FIFO Watermark Control Register 1: 0x%lx", ulreg);
+	ulreg = EMGD_READ32(MMIO(display) + FW_2);
+	EMGD_DEBUG(" FIFO Watermark Control Register 2: 0x%lx", ulreg);
+	ulreg = EMGD_READ32(MMIO(display) + FW_3);
+	EMGD_DEBUG(" FIFO Watermark Control Register 3: 0x%lx", ulreg);
+	ulreg = EMGD_READ32(MMIO(display) + FW_4);
+	EMGD_DEBUG(" FIFO Watermark Control Register 4: 0x%lx", ulreg);
+	ulreg = EMGD_READ32(MMIO(display) + FW_5);
+	EMGD_DEBUG(" FIFO Watermark Control Register 5: 0x%lx", ulreg);
+	ulreg = EMGD_READ32(MMIO(display) + FW_6);
+	EMGD_DEBUG(" FIFO Watermark Control Register 6: 0x%lx", ulreg);
+	ulreg = EMGD_READ32(MMIO(display) + DSP_CHICKENBITS);
+	EMGD_DEBUG(" Display Chicken bits: 0x%lx", ulreg);
+	read_bunit_tnc(0x30, &b_reg);
+	EMGD_DEBUG(" Bunit Chicken bits: 0x%lx", b_reg);
+	read_bunit_tnc(0x02, &b_reg);
+	EMGD_DEBUG(" Bunit Write Flush: 0x%lx", b_reg);
 #else
 	/* ITP Script is doing this and so go ahead */
-	/* The DSP_ARB set fixed the issue with 32bit vesa modes */
-	EMGD_WRITE32(0x00001FBF, MMIO(display) + DSP_ARB);
+	/* The PIPEA_DISP_ARB_CTRL set fixed the issue with 32bit vesa modes */
+	EMGD_WRITE32(0x00001FBF, MMIO(display) + PIPEA_DISP_ARB_CTRL);
 	EMGD_WRITE32(0x3F8F0F18, MMIO(display) + FW_1);
 #endif
 	/* FIXME: Not required for TNC.
@@ -1277,7 +1242,7 @@ void program_plane_tnc(igd_display_context_t *display,
  *
  * @return void
  */
-static void wait_pipe(unsigned long pipe_reg, unsigned long check_on_off)
+void wait_pipe(unsigned long pt, unsigned long pipe_reg, unsigned long check_on_off)
 {
 	unsigned long temp;
 	os_alarm_t timeout;
@@ -1285,7 +1250,7 @@ static void wait_pipe(unsigned long pipe_reg, unsigned long check_on_off)
 	EMGD_TRACE_ENTER;
 
 	/* 0:3:0 doesn't wait pipe, only LNC device does. */
-	if (pipe_reg == 0x71008) {
+	if (pt == IGD_PORT_SDVO) {
 		return;
 	}
 
@@ -1305,6 +1270,17 @@ static void wait_pipe(unsigned long pipe_reg, unsigned long check_on_off)
 	return;
 }
 
+unsigned long get_port_type(int crtc_id) {
+	if (crtc_id == IGD_KMS_PIPEA) {
+		return IGD_PORT_LVDS;
+	}
+	if (crtc_id == IGD_KMS_PIPEB) {
+		return IGD_PORT_SDVO;
+	}
+	EMGD_ERROR("Unrecognized port type based on crtc_id of %d", crtc_id);
+	return 0;
+}
+
 /*!
  * This function programs the Timing registers and clock registers and
  * other control registers for PIPE.
@@ -1331,13 +1307,21 @@ void program_pipe_tnc(igd_display_context_t *display,
 	int i;
 	tnc_wa_timing_t *wa;
 	/* igd_framebuffer_info_t *fb_info = PLANE(display)->fb_info; */
+	platform_context_tnc_t *platform_context;
 
 	EMGD_TRACE_ENTER;
 
 	EMGD_DEBUG("Program Pipe: %s", status?"ENABLE":"DISABLE");
 	EMGD_DEBUG("Device power state: D%ld", GET_DEVICE_POWER_STATE(display));
 
-	pipe_conf = device_data->pipe_preserve &
+	platform_context = (platform_context_tnc_t *)display->context->platform_context;
+
+	/* For Windows OS, flag_clip_fix will be overridden by configurable parameter in registry.
+	* This section of code is excluded in VBIOS, VBIOS will always use the pre-assigned value.
+	*/
+	flag_clip_fix = mode_context->clip_hw_fix;
+
+	pipe_conf = device_data_tnc->pipe_preserve &
 		READ_MMIO_REG_TNC(pt, PIPE(display)->pipe_reg);
 
 	if((status == FALSE) ||
@@ -1346,13 +1330,16 @@ void program_pipe_tnc(igd_display_context_t *display,
 		if (pt == IGD_PORT_SDVO) {
 			WRITE_MMIO_REG_TNC(IGD_PORT_LVDS, PIPE(display)->pipe_reg,
 				pipe_conf & (~0x80000000L));
+			/* After disable pipe B in 0:2:0, wait_pipe must be
+ 			 * called to ensure the pipe B to be turned off */
+			wait_pipe(IGD_PORT_LVDS, PIPE(display)->pipe_reg, 0);
 		}
 		/* Disable pipe */
 		WRITE_MMIO_REG_TNC(pt, PIPE(display)->pipe_reg,
 			pipe_conf & (~0x80000000L));
 
 		/* check when the pipe is disabled. */
-		wait_pipe(PIPE(display)->pipe_reg, 0);
+		wait_pipe(pt, PIPE(display)->pipe_reg, 0);
 
 		/* Disable DPLL */
 		//WRITE_MMIO_REG_TNC(pt, PIPE(display)->clock_reg->dpll_control,
@@ -1363,6 +1350,34 @@ void program_pipe_tnc(igd_display_context_t *display,
 		return;
 	}
 
+	/* For TNC B1, enable hardware cliping fix*/
+	if((platform_context->tnc_dev3_rid == TNC_B1_DEV3_RID)&&
+		(flag_clip_fix & IGD_CLIP_FIX_GLOBAL_ENABLE)) {
+			/* Disable SDVO Pipe in Device 2 and Device 3 */
+			WRITE_MMIO_REG_TNC(IGD_PORT_LVDS, PIPE(display)->pipe_reg,
+				pipe_conf & (~0x80000000L));
+
+			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, PIPE(display)->pipe_reg,
+				pipe_conf & (~0x80000000L));
+
+			/* check when the pipe is disabled. */
+			wait_pipe(IGD_PORT_LVDS, PIPE(display)->pipe_reg, 0);
+
+			/* Enable clipping hardware fix */
+			temp = READ_MMIO_REG_TNC(IGD_PORT_LVDS, DSP_CHICKENBITS);
+			if(flag_clip_fix & IGD_CLIP_FIX_REPLACE_STALL) {
+				temp |= BIT18;
+			} else {
+				temp &= ~BIT18;
+			}
+			if(flag_clip_fix & IGD_CLIP_FIX_DISABLE_THROTTLE) {
+				temp |= BIT15;
+			} else {
+				temp &= ~BIT15;
+			}
+			WRITE_MMIO_REG_TNC(IGD_PORT_LVDS, DSP_CHICKENBITS, temp);
+	}
+
 
 	port     = PORT_OWNER(display);
 	pTimings = PIPE(display)->timing;
@@ -1472,14 +1487,31 @@ void program_pipe_tnc(igd_display_context_t *display,
 		hactive_tmp = (short) hactive;
 		vactive_tmp = (short) vactive;
 #ifndef CONFIG_MICRO
-		/* Clone and Exteded not Supported in VBIOS for TNC
-		 * This work around is only for Atom E6xx B0
+
+		/* Htotal and tuning wa is not supported in VBIOS for TNC
+		 * TNC B0: Enable Htotal formula and CRC Tuning to fix clipping issue and
+		 * async flip flikering on single display
+		 * TNC B1: Enable Htotal formula without CRC Tuning to fix async flip flikering
+		 * For B0, TVOUT is excluded for htotal workaround to avoid image shifting
+		 * issue happen. Image shifting will be fixed on B1 while ref_freq is lower down
+		 * to 198Mhz
 		 */
-		if((IGD_DC_CLONE(dc) || IGD_DC_EXTENDED(dc))
-			&& pt == IGD_PORT_SDVO && (display->context->device_context.rid == TNC_B0_RID)
-			&& FLAG(flag_basic_htotal_formula_wa)){
 
-			if(!(pTimings->reserved_dd & TNC_HTOTAL_TUNED)){
+
+		if(	(pt == IGD_PORT_SDVO) && FLAG(flag_basic_htotal_formula_wa) &&
+			(   ((platform_context->tnc_dev3_rid == TNC_B1_DEV3_RID) &&
+					(mode_context->async_flip_wa)	)||
+				(   (platform_context->tnc_dev3_rid == TNC_B0_DEV3_RID) &&
+				    (!IGD_DC_SINGLE(dc) || (port->pd_driver->type != PD_DISPLAY_TVOUT))
+				)
+			)){
+
+
+	 		if((!(pTimings->reserved_dd & TNC_HTOTAL_TUNED)) &&
+	 				(wa->counter < LIMIT_TOTAL_CHECK_DISPLAY) &&
+					(platform_context->tnc_dev3_rid == TNC_B0_DEV3_RID) &&
+ 					(FLAG(flag_enable_tuning_wa))) {
+
 				/* Modify blanks so it always begin after active pixel and ends at the
 				 * end. Do not change it if we are already tuned to maintain
 				 * original timing specification
@@ -1490,15 +1522,44 @@ void program_pipe_tnc(igd_display_context_t *display,
 				pTimings_tmp.vblank_end = (short) (pTimings->vtotal);
 			}
 
+#ifndef CONFIG_MICRO
+			/* Delay Frame start while Tuning*/
+			/* Frame start delay is added as plane corruption occurs without delay.
+			 * Pipe would begin fetching data from random memory location causing the delay.
+			 * Silicon could not determine why this is happening but agree that adding a delay
+			 * would not cause any issue unless for a DTD with single vsync line which is
+			 * super unlikely used.
+			 */
+
+			/* B1 stepping does not need to set this bit because it does not need tuning*/
+			if((platform_context->tnc_dev3_rid == TNC_B0_DEV3_RID) &&
+				(IGD_DC_CLONE(dc) || IGD_DC_EXTENDED(dc))){
+				pipe_conf |= BIT27;
+			}
+#endif
+
+
 			if(i==0){
 				if(pTimings->reserved_dd == 0 || (wa->counter > LIMIT_TOTAL_CHECK_DISPLAY)){
 					/* First time tuning */
 					if ((mode_context->ref_freq != 0) &&
 							(mode_context->ref_freq >= 190000) &&
-							(mode_context->ref_freq <= 210000)){
+							(mode_context->ref_freq <= 210000))
+					{
+						if ((platform_context->tnc_dev3_rid == TNC_B1_DEV3_RID)){
+							/* The optimum reference frequency used for 3DMark flickering workaround formula
+							is the LNC clock minus the optimum margin found from experiment */
+							calc = (pTimings->htotal * (mode_context->ref_freq - LNC_B1_OPTIMUM_MARGIN));
+						} else {
 						calc = (pTimings->htotal * mode_context->ref_freq);
+						}
+					} else {
+						if((platform_context->tnc_dev3_rid == TNC_B1_DEV3_RID)){
+							calc = (pTimings->htotal * (LNC_CLOCK - LNC_B1_OPTIMUM_MARGIN));
 					} else {
 						calc = (pTimings->htotal * LNC_CLOCK);
+						}
+
 					}
 
 					calc = (calc / (PIPE(display)->clock_reg->actual_dclk));
@@ -1607,7 +1668,7 @@ void program_pipe_tnc(igd_display_context_t *display,
 
 
 	/* Gen4 can check when the pipe is enabled. */
-	wait_pipe(PIPE(display)->pipe_reg, 0x40000000);
+	wait_pipe(IGD_PORT_LVDS, PIPE(display)->pipe_reg, 0x40000000);
 
 	/*
 	 * Set the VGA address range to 0xa0000 so that a normal (not VGA)
@@ -1646,7 +1707,9 @@ void program_pipe_tnc(igd_display_context_t *display,
 		/*  Enable Chicken Bit */
 		/*  Setting BIT6 enable Pipe B Palette Write
          *  to prevent hang during palette write */
-		WRITE_MMIO_REG_TNC(IGD_PORT_LVDS, 0x70400, 0x4088 | BIT6);
+		/*  Enable Chicken Bit */
+		temp = READ_MMIO_REG_TNC(IGD_PORT_LVDS, DSP_CHICKENBITS);
+		WRITE_MMIO_REG_TNC(IGD_PORT_LVDS, DSP_CHICKENBITS, temp | BIT6);
 	}
 
 	EMGD_TRACE_EXIT;
@@ -1675,7 +1738,7 @@ void reset_plane_pipe_ports_tnc(igd_context_t *context)
 	 * Disable all plane, pipe and port registers because the
 	 * bios may have been using a different set. Only unset the
 	 * enable bit.
-	 */
+ */
 	mmio = EMGD_MMIO(context->device_context.virt_mmadr);
 	md = &context->mod_dispatch;
 	/* Turn off LVDS and SDVO ports */
@@ -1698,26 +1761,19 @@ void reset_plane_pipe_ports_tnc(igd_context_t *context)
 			shutdown_ST_bridge(context);
 		}
 
-		/* Disable WRITE protection on PIPE B for parts with Int-LVDS*/
-		/* This should never happen as the panel power was set to D3 above */
-		if (port->port_reg == LVDSCNTR) {
-			if(EMGD_READ32(EMGD_MMIO(mmio) + LVDS_PNL_PWR_CTL) & 0x1) {
-				EMGD_WRITE32(0xABCD0000, EMGD_MMIO(mmio) + LVDS_PNL_PWR_CTL);
-				i=0;
-				while(i++ < 0x10) {
-					OS_SLEEP(10);
-					if((EMGD_READ32(EMGD_MMIO(mmio)+LVDS_PNL_PWR_STS)&BIT(31))==0) {
-						break;
-					}
-				}
-			}
-		}
 		if (port->pd_driver) {
 			temp = READ_MMIO_REG_TNC(port->port_type, port->port_reg);
 			WRITE_MMIO_REG_TNC(port->port_type, port->port_reg, (temp & ~BIT31));
 		}
 	}
 
+	/* disable plane C */
+	temp = EMGD_READ32(EMGD_MMIO(mmio) + DSPCCNTR);
+	if(temp & BIT31) {
+		EMGD_WRITE32(0x0, EMGD_MMIO(mmio) + DSPCCNTR);
+		EMGD_WRITE32(0x0, EMGD_MMIO(mmio) + DSPCCNTR + DSP_START_OFFSET);
+	}
+
 	/*
 	 * Gen4 appears to require that plane B be shut off prior to
 	 * shutting off plane A.  The normal get_next_plane returns them
@@ -1734,7 +1790,7 @@ void reset_plane_pipe_ports_tnc(igd_context_t *context)
 			i = 0x71008;  /* PIPE B */
 			if (temp & BIT31) {
 				if(plane->plane_reg == DSPACNTR) {
-					temp = temp & device_data->plane_a_preserve;
+					temp = temp & device_data_tnc->plane_a_preserve;
 					i = 0x70008;  /* use i as pipe_reg */
 				}
 				EMGD_WRITE32((temp & ~BIT31), EMGD_MMIO(mmio) + plane->plane_reg);
@@ -1777,10 +1833,10 @@ void reset_plane_pipe_ports_tnc(igd_context_t *context)
 					continue;
 				}
 				WRITE_MMIO_REG_TNC(ports_tnc[i], pipe->pipe_reg,
-					(temp & device_data->pipe_preserve));
+					(temp & device_data_tnc->pipe_preserve));
 
 				/* Gen4 can check when the pipe is disabled. */
-				wait_pipe(pipe->pipe_reg, 0);
+				wait_pipe(ports_tnc[i], pipe->pipe_reg, 0);
 
 				/* Disable VGA display */
 				disable_vga_tnc(EMGD_MMIO(mmio));
@@ -2496,7 +2552,7 @@ mode_dispatch_t mode_dispatch_tnc = {
 	OPT_MICRO_VALUE(check_port_supported, NULL),
 	OPT_MICRO_VALUE(get_refresh_in_border, NULL),
 	OPT_MICRO_VALUE(dsp_is_force_alter_required_tnc, NULL),
-	OPT_MICRO_VALUE(&mode_full_dispatch_tnc, NULL)
+	OPT_MICRO_VALUE(&mode_full_dispatch_tnc, NULL),
 };
 
 /* VBIOS does not use the virtual mapped address
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.c b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.c
index 6928298..06e1903 100644
--- a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: mode_tnc.c
- * $Revision: 1.28 $
+ * $Revision: 1.32 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -52,6 +52,7 @@
 #include <tnc/instr.h>
 #include <tnc/cmd.h>
 
+#include "drm_emgd_private.h"
 #include "../cmn/match.h"
 #include "../cmn/mode_dispatch.h"
 
@@ -81,16 +82,25 @@ static emgd_vblank_callback_t interrupt_callbacks_tnc[IGD_MAX_PORTS] =
  */
 static unsigned long vblank_interrupt_state = 0;
 
+/* This variables keeps track of the number of clients currently using
+ * the vblank interrupt
+ */
+static int vblank_interrupt_ref_cnt_port2 = 0;
+static int vblank_interrupt_ref_cnt_port4 = 0;
+
 /* Spin lock for synchronization of the vblank_interrupt_state variable,
  * between the VBlank interrupt handler and the non-interrupt handler code:
  */
-static spinlock_t vblank_lock = SPIN_LOCK_UNLOCKED;
+DEFINE_SPINLOCK(vblank_lock_tnc);
 
 
 
 int set_flip_pending_tnc(unsigned char *mmio, unsigned long pipe_status_reg);
 int check_flip_pending_tnc(unsigned char *mmio, unsigned long pipe_status_reg);
 
+/* KMS callback from emgd_crtc.c */
+int crtc_pageflip_handler(struct drm_device *dev, int port);
+
 /*!
  * @addtogroup display_group
  * @{
@@ -99,6 +109,8 @@ int check_flip_pending_tnc(unsigned char *mmio, unsigned long pipe_status_reg);
 int mode_get_stride_stereo_tnc(igd_display_context_t *display,
 	unsigned long *stride, unsigned long *stereo, unsigned long flags);
 
+
+
 /*!
  *
  * @param display
@@ -370,19 +382,17 @@ static int set_color_correct_tnc(igd_display_context_t *display)
 static int set_display_base_tnc(igd_display_context_t *display,
 	igd_framebuffer_info_t *fb, unsigned long *x, unsigned long *y)
 {
-	unsigned long base;
-
 	EMGD_TRACE_ENTER;
 
-	EMGD_DEBUG ("Pan linear");
+	EMGD_DEBUG ("Pan linear to (%lu,%lu)", *x, *y);
 
-	/* FIXME/TODO: Compare the difference between the plb/tnc versions of this
-	 * function, as the plb code adds-in the offset of the frame buffer.
-	 */
-	base = ((*y * fb->screen_pitch) + (*x * IGD_PF_BYPP(fb->pixel_format)));
+	/* Update framebuffer's visible offset */
+	PLANE(display)->fb_info->visible_offset =
+		((*y * fb->screen_pitch) + (*x * IGD_PF_BYPP(fb->pixel_format)));
 
 	/* Plane registers are always on 0:2:0 */
-	WRITE_MMIO_REG(display, PLANE(display)->plane_reg+DSP_LINEAR_OFFSET, base);
+	WRITE_MMIO_REG(display, PLANE(display)->plane_reg + DSP_LINEAR_OFFSET,
+		PLANE(display)->fb_info->visible_offset);
 
 	EMGD_TRACE_EXIT;
 	return 0;
@@ -805,7 +815,7 @@ static int igd_set_surface_tnc(igd_display_h display_handle,
 	unsigned int dsp_current;
 	unsigned long plane_reg;
 	unsigned long plane_control;
-	unsigned long surface_offset;
+	unsigned long visible_offset;
 
 	EMGD_TRACE_ENTER;
 	if(!surface) {
@@ -835,12 +845,20 @@ static int igd_set_surface_tnc(igd_display_h display_handle,
 		/*
 		 * Async flips only work when the offset is on a 256kb boundary.
 		 */
-		if(PLANE(display)->fb_info->visible_offset & 0x3ffff) {
-			EMGD_ERROR("FB offset must be 256kb aligned in Poulsbo");
+		if(surface->offset & 0x3ffff) {
+			EMGD_ERROR("Display surface offset %lu is not 256kb aligned", surface->offset);
 		}
 
+		/* calculate the visible offset, taking panning into account */
+		visible_offset =
+			(PORT_OWNER(display)->pt_info->y_offset * surface->pitch) +
+			(PORT_OWNER(display)->pt_info->x_offset *
+				IGD_PF_BYPP(surface->pixel_format));
+		EMGD_DEBUG("visible surface_offset = 0x%08lx", visible_offset);
+
 		/* Save new fb_info */
-		PLANE(display)->fb_info->visible_offset = surface->offset;
+		PLANE(display)->fb_info->fb_base_offset = surface->offset;
+		PLANE(display)->fb_info->visible_offset = visible_offset;
 		PLANE(display)->fb_info->screen_pitch = surface->pitch;
 		PLANE(display)->fb_info->width = surface->width;
 		PLANE(display)->fb_info->height = surface->height;
@@ -851,14 +869,6 @@ static int igd_set_surface_tnc(igd_display_h display_handle,
 		/* TODO - Does Atom E6xx flip need to handle stereo mode? */
 		/*mode_get_stride_stereo_tnc(display, &stride, &stereo, 0);*/
 
-		/* calculate the real offset, taking panning into account */
-		surface_offset = surface->offset;
-		surface_offset +=
-			(PORT_OWNER(display)->pt_info->y_offset * surface->pitch) +
-			(PORT_OWNER(display)->pt_info->x_offset *
-				IGD_PF_BYPP(surface->pixel_format));
-		EMGD_DEBUG("surface_offset = 0x%08lx", surface_offset);
-
 		/* plane registers are always on 0:2:0, so no need to use _TNC macros */
 		plane_reg = PLANE(display)->plane_reg;
 		plane_control = EMGD_READ32(MMIO(display) + plane_reg);
@@ -866,12 +876,18 @@ static int igd_set_surface_tnc(igd_display_h display_handle,
 		/* Perform the flip by doing the following:
 		 *
 		 *   Write the current plane_control value to the plane_reg
-		 *   Write the surface offset to either:
+		 *   Write the surface stride to DSP_STRIDE_OFFSET
+		 *   Write the visible from start of plane to DSP_LINEAR_OFFSET
+		 *   Write the base surface offset to either:
 		 *     1) the plane_reg - 4  if async
 		 *     2) plane_reg + DSP_START_OFFSET (+0x1C) if not async
 		 */
 		EMGD_WRITE32(plane_control, MMIO(display) + plane_reg);
-		EMGD_WRITE32(surface_offset,
+		EMGD_WRITE32(surface->pitch,
+				MMIO(display) + plane_reg + DSP_STRIDE_OFFSET);
+		EMGD_WRITE32(visible_offset,
+			MMIO(display) + plane_reg + DSP_LINEAR_OFFSET);
+		EMGD_WRITE32(surface->offset,
 			MMIO(display) + plane_reg + DSP_START_OFFSET);
 
 		EMGD_TRACE_EXIT;
@@ -882,6 +898,11 @@ static int igd_set_surface_tnc(igd_display_h display_handle,
 	case IGD_BUFFER_DEPTH:
 		EMGD_TRACE_EXIT;
 		return 0;
+	case IGD_BUFFER_SAVE:
+		PLANE(display)->fb_info->saved_offset = surface->offset;
+		EMGD_DEBUG("saving surface_offset = 0x%08lx", surface->offset);
+		EMGD_TRACE_EXIT;
+		return 0;
 	default:
 		EMGD_ERROR("Invalid type in set_surface");
 		break;
@@ -1210,28 +1231,37 @@ static int get_pipe_info_tnc(igd_display_h *display)
 				 */
 				ref_freq = 200000000;  /* 200 MHz */
 
+				dclk = ref_freq * m / (p1*p2);
+
 				/*  FIXME:  This is a workaround to get dclk.  We are supposed
 				 *  to be calculating this based on the formula, but DPLL
 				 *  is somehow locked and does not return the programmed
 				 *  p1 value.  Once this is fixed, we no longer need to have
 				 *  igd_display_handle in the parameter of get_pipe_info
+				 *
+				 *  Update:
+				 *  Now that we initialize the driver before X starts,
+				 *  we want to do a seamless mode-set from firmware to
+				 *  our kernel mode driver. At this point we do not have
+				 *  the igd_display_context_t setup.
+				 *
+				 *	if (NULL != display) {
+				 *		igd_display_context_t *display_context =
+				 *		(igd_display_context_t *) display;
+				 *
+				 *		dclk = ref_freq * m / (p1 * p2);
+				 *
+				 *		PIPE(display)->dclk is in KHhz
+				 *		dclk = PIPE(display)->dclk * 1000;
+				 *	} else {
+				 *		dclk = 0;
+				 *	}
+				 *
+				 *	if( dclk == 0 ) {
+				 *		EMGD_ERROR_EXIT(" Dot Clock/Ref Frequency is Zero!!!");
+				 *		return -IGD_ERROR_INVAL;
+				 *	}
 				 */
-				if (NULL != display) {
-					/*igd_display_context_t *display_context =
-					  (igd_display_context_t *) display;*/
-
-					/* dclk = ref_freq * m / (p1 * p2); */
-
-					/* PIPE(display)->dclk is in KHhz */
-					dclk = PIPE(display)->dclk * 1000;
-				} else {
-					dclk = 0;
-				}
-
-				if( dclk == 0 ) {
-					EMGD_ERROR_EXIT(" Dot Clock/Ref Frequency is Zero!!!");
-					return -IGD_ERROR_INVAL;
-				}
 
 				EMGD_DEBUG("Ref frequency = %lu", ref_freq);
 				EMGD_DEBUG("Pipe A constructed Dot clock is = %lu", dclk);
@@ -1441,10 +1471,11 @@ static irqreturn_t interrupt_handler_tnc(int irq, void* mmio)
 
 	iir = EMGD_READ32(EMGD_MMIO(mmio) + IIR);
 
+
 	/* Detect whether a vblank interrupt occured, and if so, what type of
 	 * processing is needed (do the simple processing now):
 	 */
-	spin_lock_irqsave(&vblank_lock, lock_flags);
+	spin_lock_irqsave(&vblank_lock_tnc, lock_flags);
 	if ((port2_interrupt = iir & BIT5 /* Port 2/Pipe A/SDVO-B */) != 0) {
 		if ((tmp = vblank_interrupt_state & VBLANK_INT4_PORT2) != 0) {
 			/* Record "answers" for all requestors: */
@@ -1457,17 +1488,51 @@ static irqreturn_t interrupt_handler_tnc(int irq, void* mmio)
 			vblank_interrupt_state |= VBINT_ANSWER4_REQUEST(tmp);
 		}
 	}
-	spin_unlock_irqrestore(&vblank_lock, lock_flags);
+	spin_unlock_irqrestore(&vblank_lock_tnc, lock_flags);
+
+	/*
+	 * Call the KMS 'flip complete' handler if we're waiting for a flip to
+	 * complete on this port.  Note that we should do this before the
+	 * drm_handle_vblank() calls below since we need to clear the
+	 * 'flip pending' bit in the CRTC before the vblank waitqueue gets
+	 * woken up.
+	 */
+	if (port4_interrupt) {
+		crtc_pageflip_handler(mode_context->context->drm_dev,
+			IGD_PORT_TYPE_LVDS);
+	} else if (port2_interrupt) {
+		crtc_pageflip_handler(mode_context->context->drm_dev,
+			IGD_PORT_TYPE_SDVOB);
+	}
+
+	/* Notify KMS Hander:  The assignment of CRTC=0 for PIPE A and
+	 * CRTC=1 for PIPE B is not correct if somehow PIPE A is disabled.
+	 */
+	if (port2_interrupt) {
+		drm_handle_vblank(mode_context->context->drm_dev, 1);
+	}
+
+	if (port4_interrupt) {
+		drm_handle_vblank(mode_context->context->drm_dev ,0);
+	}
 
 	/* Call any registered/enabled callbacks for this interrupt: */
 	cb = &interrupt_callbacks_tnc[2];
-	if (cb->callback &&
+	if (port2_interrupt && cb->callback &&
 		(vblank_interrupt_state & VBINT_ANSWER(VBINT_CB, VBINT_PORT2))) {
+		/* Clear the state to indicate the vblank has occured prior to
+		 * invoking the callback.
+		 */
+		vblank_interrupt_state &= ~VBINT_ANSWER(VBINT_CB, VBINT_PORT2);
 		cb->callback(cb->priv);
 	}
 	cb = &interrupt_callbacks_tnc[4];
-	if (cb->callback &&
+	if (port4_interrupt && cb->callback &&
 		(vblank_interrupt_state & VBINT_ANSWER(VBINT_CB, VBINT_PORT4))) {
+		/* Clear the state to indicate the vblank has occured prior to
+		 * invoking the callback.
+		 */
+		vblank_interrupt_state &= ~VBINT_ANSWER(VBINT_CB, VBINT_PORT4);
 		cb->callback(cb->priv);
 	}
 
@@ -1543,7 +1608,7 @@ int request_vblanks_tnc(unsigned long request_for, unsigned char *mmio)
 	}
 
 	/* Lock here to stop the interrupt handler until after changing bits: */
-	spin_lock_irqsave(&vblank_lock, lock_flags);
+	spin_lock_irqsave(&vblank_lock_tnc, lock_flags);
 
 	/* Enable interrupts for the requested purpose/port, actually touching the
 	 * hardware registers if newly enabling interrupts for the given port/pipe:
@@ -1576,6 +1641,7 @@ int request_vblanks_tnc(unsigned long request_for, unsigned char *mmio)
 			EMGD_WRITE32((tmp | BIT5), EMGD_MMIO(mmio) + IER);
 		}
 		vblank_interrupt_state |= request_for;
+		vblank_interrupt_ref_cnt_port2++;
 	} else /* if (request_for & VBLANK_INT4_PORT4) */ {
 		if (!VBLANK_INTERRUPTS_ENABLED4_PORT4) {
 			/* 1. Change Pipe Display Status Register for this pipe: set the
@@ -1604,15 +1670,19 @@ int request_vblanks_tnc(unsigned long request_for, unsigned char *mmio)
 			EMGD_WRITE32((tmp | BIT7), EMGD_MMIO(mmio) + IER);
 		}
 		vblank_interrupt_state |= request_for;
+		vblank_interrupt_ref_cnt_port4++;
 	}
 
+
 	/* Unlock to allow the interrupt handler to proceed: */
-	spin_unlock_irqrestore(&vblank_lock, lock_flags);
+	spin_unlock_irqrestore(&vblank_lock_tnc, lock_flags);
 
 	EMGD_TRACE_EXIT;
 	return 0;
 }
 
+
+
 /*!
  * Implementation of "protected" function (i.e. for use within the mode
  * module) to end a previous request VBlank interrupts for a particular
@@ -1644,76 +1714,95 @@ int end_request_tnc(unsigned long request_for, unsigned char *mmio)
 	}
 
 	/* Lock here to stop the interrupt handler until after changing bits: */
-	spin_lock_irqsave(&vblank_lock, lock_flags);
+	spin_lock_irqsave(&vblank_lock_tnc, lock_flags);
 
 	/* Disable interrupts for the requested purpose/port, actually touching the
 	 * hardware registers no software wants interrupts for the given port/pipe:
 	 */
 	if (request_for & VBLANK_INT4_PORT2) {
-		/* Turn off both the request and the answer bits: */
-		tmp = request_for & VBLANK_INT4_PORT2;
-		vblank_interrupt_state &= ~(tmp | VBINT_ANSWER4_REQUEST(tmp));
-		if (!VBLANK_INTERRUPTS_ENABLED4_PORT2) {
-			/* 1. Change Pipe Display Status Register for this pipe: clear the
-			 *    Vertical Blank Interrupt Enable bit & clear (by setting) the
-			 *    Vertical Blank Interrupt Status bit:
-			 */
-			tmp = EMGD_READ32(EMGD_MMIO(mmio) + PIPEB_STAT);
-			/* Clear bits that are written by a 1, so we don't clear them: */
-			tmp = tmp & (~PIPESTAT_STS_BITS);
-			EMGD_WRITE32(((tmp & (~VBLANK_STS_EN)) | VBLANK_STS),
-				EMGD_MMIO(mmio) + PIPEB_STAT);
-			EMGD_READ32(EMGD_MMIO(mmio) + PIPEB_STAT);
-
-			/* 2. Clear the Interrupt Enable Register bit for this pipe: */
-			tmp = EMGD_READ32(EMGD_MMIO(mmio) + IER);
-			EMGD_WRITE32((tmp & (~BIT5)), EMGD_MMIO(mmio) + IER);
-
-			/* 3. Set the Interrupt Mask Register bit for this pipe: */
-			tmp = EMGD_READ32(EMGD_MMIO(mmio) + IMR);
-			EMGD_WRITE32((tmp | BIT5), EMGD_MMIO(mmio) + IMR);
+		/* Decrement reference count */
+		vblank_interrupt_ref_cnt_port2--;
+		if (0 > vblank_interrupt_ref_cnt_port2) {
+			EMGD_DEBUG("WARNING:  Disabled vblank INT too many times.");
+			vblank_interrupt_ref_cnt_port2 = 0;
+		}
 
-			/* 4. Just in case, clear (by setting) the Interrupt Identity
-			 *    Register bit for this pipe:
-			 */
-			tmp = EMGD_READ32(EMGD_MMIO(mmio) + IIR);
-			EMGD_WRITE32((tmp | BIT5), EMGD_MMIO(mmio) + IIR);
+		if (0 == vblank_interrupt_ref_cnt_port2) {
+			/* Turn off both the request and the answer bits: */
+			tmp = request_for & VBLANK_INT4_PORT2;
+			vblank_interrupt_state &= ~(tmp | VBINT_ANSWER4_REQUEST(tmp));
+			if (!VBLANK_INTERRUPTS_ENABLED4_PORT2) {
+				/* 1. Change Pipe Display Status Register for this pipe: clear
+				 *    the Vertical Blank Interrupt Enable bit & clear (by
+				 *    setting) the Vertical Blank Interrupt Status bit:
+				 */
+				tmp = EMGD_READ32(EMGD_MMIO(mmio) + PIPEB_STAT);
+				/* Clear bits that are written by a 1, so don't clear them: */
+				tmp = tmp & (~PIPESTAT_STS_BITS);
+				EMGD_WRITE32(((tmp & (~VBLANK_STS_EN)) | VBLANK_STS),
+					EMGD_MMIO(mmio) + PIPEB_STAT);
+				EMGD_READ32(EMGD_MMIO(mmio) + PIPEB_STAT);
+
+				/* 2. Clear the Interrupt Enable Register bit for this pipe: */
+				tmp = EMGD_READ32(EMGD_MMIO(mmio) + IER);
+				EMGD_WRITE32((tmp & (~BIT5)), EMGD_MMIO(mmio) + IER);
+
+				/* 3. Set the Interrupt Mask Register bit for this pipe: */
+				tmp = EMGD_READ32(EMGD_MMIO(mmio) + IMR);
+				EMGD_WRITE32((tmp | BIT5), EMGD_MMIO(mmio) + IMR);
+
+				/* 4. Just in case, clear (by setting) the Interrupt Identity
+				*    Register bit for this pipe:
+				*/
+				tmp = EMGD_READ32(EMGD_MMIO(mmio) + IIR);
+				EMGD_WRITE32((tmp | BIT5), EMGD_MMIO(mmio) + IIR);
+			}
 		}
 	}
-	if (request_for & VBLANK_INT4_PORT4) {
-		/* Turn off both the request and the answer bits: */
-		tmp = request_for & VBLANK_INT4_PORT4;
-		vblank_interrupt_state &= ~(tmp | VBINT_ANSWER4_REQUEST(tmp));
-		if (!VBLANK_INTERRUPTS_ENABLED4_PORT4) {
-			/* 1. Change Pipe Display Status Register for this pipe: clear the
-			 *    Vertical Blank Interrupt Enable bit & clear (by setting) the
-			 *    Vertical Blank Interrupt Status bit:
-			 */
-			tmp = EMGD_READ32(EMGD_MMIO(mmio) + PIPEA_STAT);
-			/* Clear bits that are written by a 1, so we don't clear them: */
-			tmp = tmp & (~PIPESTAT_STS_BITS);
-			EMGD_WRITE32(((tmp & (~VBLANK_STS_EN)) | VBLANK_STS),
-				EMGD_MMIO(mmio) + PIPEA_STAT);
-			EMGD_READ32(EMGD_MMIO(mmio) + PIPEA_STAT);
-
-			/* 2. Clear the Interrupt Enable Register bit for this pipe: */
-			tmp = EMGD_READ32(EMGD_MMIO(mmio) + IER);
-			EMGD_WRITE32((tmp & (~BIT7)), EMGD_MMIO(mmio) + IER);
 
-			/* 3. Set the Interrupt Mask Register bit for this pipe: */
-			tmp = EMGD_READ32(EMGD_MMIO(mmio) + IMR);
-			EMGD_WRITE32((tmp | BIT7), EMGD_MMIO(mmio) + IMR);
+	if (request_for & VBLANK_INT4_PORT4) {
+		/* Decrement reference count */
+		vblank_interrupt_ref_cnt_port4--;
+		if (0 > vblank_interrupt_ref_cnt_port4) {
+			EMGD_DEBUG("WARNING:  Disabled vblank INT too many times.");
+			vblank_interrupt_ref_cnt_port4 = 0;
+		}
 
-			/* 4. Just in case, clear (by setting) the Interrupt Identity
-			 *    Register bit for this pipe:
-			 */
-			tmp = EMGD_READ32(EMGD_MMIO(mmio) + IIR);
-			EMGD_WRITE32((tmp | BIT7), EMGD_MMIO(mmio) + IIR);
+		if (0 == vblank_interrupt_ref_cnt_port4) {
+			/* Turn off both the request and the answer bits: */
+			tmp = request_for & VBLANK_INT4_PORT4;
+			vblank_interrupt_state &= ~(tmp | VBINT_ANSWER4_REQUEST(tmp));
+			if (!VBLANK_INTERRUPTS_ENABLED4_PORT4) {
+				/* 1. Change Pipe Display Status Register for this pipe: clear
+				 *    the Vertical Blank Interrupt Enable bit & clear (by
+				 *    setting the Vertical Blank Interrupt Status bit:
+				 */
+				 tmp = EMGD_READ32(EMGD_MMIO(mmio) + PIPEA_STAT);
+				 /* Clear bits that are written by a 1, so don't clear them: */
+				 tmp = tmp & (~PIPESTAT_STS_BITS);
+				 EMGD_WRITE32(((tmp & (~VBLANK_STS_EN)) | VBLANK_STS),
+					 EMGD_MMIO(mmio) + PIPEA_STAT);
+				 EMGD_READ32(EMGD_MMIO(mmio) + PIPEA_STAT);
+
+				 /* 2. Clear the Interrupt Enable Register bit for this pipe: */
+				 tmp = EMGD_READ32(EMGD_MMIO(mmio) + IER);
+				 EMGD_WRITE32((tmp & (~BIT7)), EMGD_MMIO(mmio) + IER);
+
+				 /* 3. Set the Interrupt Mask Register bit for this pipe: */
+				 tmp = EMGD_READ32(EMGD_MMIO(mmio) + IMR);
+				 EMGD_WRITE32((tmp | BIT7), EMGD_MMIO(mmio) + IMR);
+
+				 /* 4. Just in case, clear (by setting) the Interrupt Identity
+				 *    Register bit for this pipe:
+				 */
+				 tmp = EMGD_READ32(EMGD_MMIO(mmio) + IIR);
+				 EMGD_WRITE32((tmp | BIT7), EMGD_MMIO(mmio) + IIR);
+			}
 		}
 	}
 
 	/* Unlock to allow the interrupt handler to proceed: */
-	spin_unlock_irqrestore(&vblank_lock, lock_flags);
+	spin_unlock_irqrestore(&vblank_lock_tnc, lock_flags);
 
 	/* If we've completely disabled all causes for interrupts, unregister the
 	 * interrupt handler:
@@ -1848,7 +1937,7 @@ void disable_vblank_callback_tnc(emgd_vblank_callback_h callback_h)
 
 	if (callback_h == ALL_PORT_CALLBACKS) {
 		/* Need to do some push-ups in order to get interrupts disabled: */
-		spin_lock_irqsave(&vblank_lock, lock_flags);
+		spin_lock_irqsave(&vblank_lock_tnc, lock_flags);
 		enable_for = (VBLANK_INT4_PORT2 | VBLANK_INT4_PORT4);
 		if (!VBLANK_INTERRUPTS_ENABLED) {
 			/* Nothing has enabled interrupts, so there's no interrupt handler
@@ -1860,13 +1949,13 @@ void disable_vblank_callback_tnc(emgd_vblank_callback_h callback_h)
 			vblank_interrupt_state = (VBLANK_INT4_PORT2 |
 				VBLANK_INT4_PORT4);
 		}
-		spin_unlock_irqrestore(&vblank_lock, lock_flags);
+		spin_unlock_irqrestore(&vblank_lock_tnc, lock_flags);
 
 		end_request_tnc(enable_for, mmio);
 
-		spin_lock_irqsave(&vblank_lock, lock_flags);
+		spin_lock_irqsave(&vblank_lock_tnc, lock_flags);
 		vblank_interrupt_state = 0;
-		spin_unlock_irqrestore(&vblank_lock, lock_flags);
+		spin_unlock_irqrestore(&vblank_lock_tnc, lock_flags);
 	} else {
 		emgd_vblank_callback_t *cb =
 			(emgd_vblank_callback_t *) callback_h;
@@ -1906,8 +1995,3 @@ mode_full_dispatch_t mode_full_dispatch_tnc = {
 	vblank_occured_tnc,
 };
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: mode_tnc.c,v 1.28 2011/03/02 22:47:05 astead Exp $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.h b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.h
new file mode 100644
index 0000000..98d667e
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/display/mode/tnc/mode_tnc.h
@@ -0,0 +1,52 @@
+/*
+ *-----------------------------------------------------------------------------
+ * Filename: mode_tnc.h
+ * $Revision: 1.2 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2011, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+#define MODULE_NAME hal.mode
+
+typedef struct _mode_data_tnc {
+	unsigned long plane_a_preserve;
+	unsigned long plane_b_c_preserve;
+	unsigned long pipe_preserve;
+	unsigned long dsp_arb;
+	unsigned long fifo_watermark1;
+	unsigned long fifo_watermark2;
+	unsigned long fifo_watermark3;
+	unsigned long fifo_watermark4;
+	unsigned long fifo_watermark5;
+	unsigned long fifo_watermark6;
+} mode_data_tnc_t;
+
+#define CHECK_VGA(a) MODE_IS_VGA(a)
+
+#ifdef DEBUG_BUILD_TYPE
+#define FLAG(a) a
+#else
+/* Turn all workaround for release driver */
+#define FLAG(a) 1
+#endif
+
diff --git a/drivers/gpu/drm/emgd/emgd/display/pd/cmn/pd.c b/drivers/gpu/drm/emgd/emgd/display/pd/cmn/pd.c
index a1ce39e..0ac0e9c 100644
--- a/drivers/gpu/drm/emgd/emgd/display/pd/cmn/pd.c
+++ b/drivers/gpu/drm/emgd/emgd/display/pd/cmn/pd.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: pd.c
- * $Revision: 1.9 $
+ * $Revision: 1.11 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -514,9 +514,3 @@ int pd_filter_timings(
 }
 
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: pd.c,v 1.9 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/display/pd/cmn/pd.c,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/displayid.c b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/displayid.c
index 0c0d7a5..a2f4547 100644
--- a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/displayid.c
+++ b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/displayid.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: displayid.c
- * $Revision: 1.8 $
+ * $Revision: 1.10 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -1056,9 +1056,3 @@ int displayid_parse(
 
 #endif
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: displayid.c,v 1.8 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/display/pi/cmn/displayid.c,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/edid.c b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/edid.c
index 2fb4c27..d8a3c36 100644
--- a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/edid.c
+++ b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/edid.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: edid.c
- * $Revision: 1.9 $
+ * $Revision: 1.11 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -1185,9 +1185,3 @@ int edid_ext_parse(
 	return 0;
 }/* end edid_parse_ext() */
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: edid.c,v 1.9 2011/03/09 19:53:51 hpang2 Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/display/pi/cmn/edid.c,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/i2c_dispatch.h b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/i2c_dispatch.h
index fcaec6e..ae98630 100644
--- a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/i2c_dispatch.h
+++ b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/i2c_dispatch.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: i2c_dispatch.h
- * $Revision: 1.5 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -53,6 +53,7 @@
  *  write cycle.
  */
 #define IGD_I2C_SERIAL_WRITE 0x1
+#define IGD_I2C_WRITE_FW 0x2
 
 typedef struct _i2c_dispatch {
 	int (*i2c_read_regs)(
@@ -62,7 +63,8 @@ typedef struct _i2c_dispatch {
 		unsigned long dab,
 		unsigned char reg,
 		unsigned char FAR *buffer,
-		unsigned long num_bytes);
+		unsigned long num_bytes,
+		unsigned long flags);
 	int (*i2c_write_reg_list)(
 		igd_context_t *context,
 		unsigned long i2c_bus,
diff --git a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/igd_pi.c b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/igd_pi.c
index fe1209f..1cf54ce 100644
--- a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/igd_pi.c
+++ b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/igd_pi.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_pi.c
- * $Revision: 1.7 $
+ * $Revision: 1.9 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -258,9 +258,3 @@ igd_debug_t *igd_pd_get_igd_debug( void )
 	return emgd_debug;
 }
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: igd_pi.c,v 1.7 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/display/pi/cmn/igd_pi.c,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/mode_table.c b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/mode_table.c
index 98933f8..d698875 100644
--- a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/mode_table.c
+++ b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/mode_table.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: mode_table.c
- * $Revision: 1.6 $
+ * $Revision: 1.8 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -1768,7 +1768,6 @@ igd_timing_info_t crt_timing_table[] =
 
 int crt_timing_table_size = sizeof(crt_timing_table);
 
-#ifndef CONFIG_NEW_MATCH
 /*---------------------------------------------------------------------------
  * Timing tables for VGA modes
  *---------------------------------------------------------------------------
@@ -2222,7 +2221,6 @@ igd_timing_info_t vga_timing_table[] =
 
 	PD_TIMING_TABLE_END
 };
-#endif
 
 /* CEA standard timings: Get them from CEA-861. This is following DPG.
    We will replace the mode number to CEA*/
@@ -2545,10 +2543,3 @@ type_std_t cea_std_lookup[] =
 int cea_std_lookup_size = sizeof(cea_std_lookup)/sizeof(type_std_t);
 
 #endif
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: mode_table.c,v 1.6 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/display/pi/cmn/mode_table.c,v $
- *----------------------------------------------------------------------------
- */
-
diff --git a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/pd_init_all.c b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/pd_init_all.c
index ec8532a..ba70fc8 100644
--- a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/pd_init_all.c
+++ b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/pd_init_all.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: pd_init_all.c
- * $Revision: 1.5 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -175,6 +175,15 @@ extern int hdmi_init(void *handle);
 #define HDMI_INIT(handle)  0
 #endif
 
+/* Enable Chrontel CH7036  port driver */
+#ifdef CONFIG_LINK_PD_CH7036
+extern int ch7036_init(void *handle);
+#define CH7036_INIT(handle)  ch7036_init(handle)
+#else
+#define CH7036_INIT(handle)  0
+#endif
+
+
 /*!
  *
  * @param handle
@@ -193,11 +202,12 @@ int pi_init_all(void *handle)
 	ret = NS387_INIT(handle);
 	ret = FS454_INIT(handle);
 	ret = CH7017_INIT(handle);
-	ret = LVDS_INIT(handle);
 	ret = SDVO_INIT(handle);
 	ret = TI410_INIT(handle);
 	ret = TV_INIT(handle);
 	ret = HDMI_INIT(handle);
+	ret = CH7036_INIT(handle);
+	ret = LVDS_INIT(handle); /*LVDS need to be initiate only after CH7036.*/
 	/* ret = PD000_INIT(handle); */
 
 	return 0;
diff --git a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/pi.c b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/pi.c
index 748b4a6..7b5abe8 100644
--- a/drivers/gpu/drm/emgd/emgd/display/pi/cmn/pi.c
+++ b/drivers/gpu/drm/emgd/emgd/display/pi/cmn/pi.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: pi.c
- * $Revision: 1.20 $
+ * $Revision: 1.24 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -57,6 +57,7 @@
 #include <mode_access.h>
 #include <edid.h>
 #include <displayid.h>
+#include <emgd_drv.h>
 
 #include "i2c_dispatch.h"
 #include <igd_vga.h>
@@ -89,7 +90,7 @@ pd_timing_t *get_user_timings(igd_param_dtd_list_t *in_list);
 
 extern int pi_init_all(void *handle);
 
-
+extern emgd_drm_config_t config_drm;
 extern i2c_dispatch_t i2c_dispatch_plb;
 extern i2c_dispatch_t i2c_dispatch_tnc;
 
@@ -150,6 +151,7 @@ static void pi_shutdown(igd_context_t *context)
 			port->pd_driver = NULL;
 			/* pd_context is freed by port driver */
 			port->pd_context = NULL;
+			/* timing_table is freed by port driver */
 			port->timing_table = NULL;
 			port->num_timing = 0;
 			if (port->fp_info) {
@@ -460,7 +462,12 @@ int pi_pd_register(pd_driver_t *pd_driver)
 
 			/* Call open() for each DAB */
 			while (pd_driver->dab_list[dab_index] != PD_DAB_LIST_END) {
-				port->dab = pd_driver->dab_list[dab_index];
+				if(pd_driver->type == PD_DISPLAY_LVDS_INT) {
+                	port->ddc_dab = pd_driver->dab_list[dab_index];
+					printk ("NUHAIRI: port->ddc_dab\n" );
+                } else {
+					port->dab = pd_driver->dab_list[dab_index];
+                }
 
 				/* Workaround for not to detect 2 encoders if only 1 encoder
 				 * is present and both DVOB and DVOC are using same I2C bus */
@@ -509,7 +516,7 @@ int pi_pd_register(pd_driver_t *pd_driver)
 
 			/* Initialize our port entry */
 			ret = pi_pd_init(port, port_feature, second_port_feature, TRUE);
- 			if (ret) {
+			if (ret) {
 				port->pd_driver = NULL;
 				port->pd_context = NULL;
 				port->dab = prev_dab;
@@ -717,7 +724,8 @@ int pi_pd_init(igd_display_port_t *port,
 			port->ddc_dab,      /* Data Addr Byte*/
 			0,                  /* Register */
 			firmware_data,      /* Values */
-			128);               /* Num bytes to read */
+			128,               /* Num bytes to read */
+			0);
 
 		/* If EDID is present then use EDID.
 		 * edid_flags will be corrected later if display_params are present */
@@ -871,29 +879,13 @@ int pi_pd_init(igd_display_port_t *port,
 
 
 #ifndef CONFIG_MICRO
-	if(pi_context->igd_context->mod_dispatch.reg_get_mod_state) {
-		module_state_h     *state = NULL;
-		unsigned long *flags = NULL;
-		pi_context->igd_context->mod_dispatch.reg_get_mod_state(
-			REG_MODE_STATE,
-			&state,
-			&flags);
-
-		if (state) {
-			mstate = (mode_state_t *)(*state);
-		}
-	}
-
-	/* If mode state is present in register context,
-	 * then call save() function to save the port driver's state */
-	if (mstate) {
-		ret = port->pd_driver->pd_save(port->pd_context,
-				&(mstate->pd_state[pi_context->num_pi_drivers].state), 0);
-		if (ret) {
-			EMGD_ERROR_EXIT("port driver: reg saving error. ret = %d", ret);
-			return ret;
-		}
-		mstate->pd_state[pi_context->num_pi_drivers].port = port;
+	/*
+	 * There is only two states that need to be saved; one is the regular state
+	 * and the other is for the console.
+	 */
+	ret = pi_save_mode_state(port, REG_MODE_STATE_REG);
+	if (config_drm.init) {
+		ret = pi_save_mode_state(port, REG_MODE_STATE_CON);
 	}
 #endif
 
@@ -978,7 +970,28 @@ int pi_read_regs(void *callback_context, pd_reg_t *list, unsigned long type)
 				port->i2c_speed,
 				port->dab,
 				(unsigned char)list->reg,
-				(unsigned char *)&list->value, 1);
+				(unsigned char *)&list->value, 1, 0);
+			if (ret) {
+				EMGD_DEBUG("i2c_read_reg: 0x%lx failed.", list->reg);
+				break;
+			}
+			list++;
+		}
+		if (ret) {
+			return PD_ERR_I2C_READ;
+		}
+		break;
+	case PD_REG_DDC_FW:
+		ret = 0;
+		while (list->reg != PD_REG_LIST_END) {
+			ret = pi_context->i2c_dispatch->i2c_read_regs(
+				pi_context->igd_context,
+				port->ddc_reg,
+				port->ddc_speed,
+				port->ddc_dab,
+				(unsigned char)list->reg,
+				(unsigned char *)&list->value, 1,
+				IGD_I2C_WRITE_FW);
 			if (ret) {
 				EMGD_DEBUG("i2c_read_reg: 0x%lx failed.", list->reg);
 				break;
@@ -998,7 +1011,8 @@ int pi_read_regs(void *callback_context, pd_reg_t *list, unsigned long type)
 				port->ddc_speed,
 				port->ddc_dab,
 				(unsigned char)list->reg,
-				(unsigned char *)&list->value, 1);
+				(unsigned char *)&list->value, 1,
+				0);
 			if (ret) {
 				EMGD_DEBUG("i2c_read_reg: 0x%lx failed.", list->reg);
 				break;
@@ -1121,7 +1135,7 @@ int pi_write_regs(void *callback_context, pd_reg_t *list, unsigned long type)
 	int           ret;
 	unsigned char *mmio;
 
-	/*EMGD_TRACE_ENTER;*/
+	EMGD_TRACE_ENTER;
 
 	if (!port) {
 		EMGD_ERROR_EXIT("Null callback context passed.");
@@ -1133,10 +1147,41 @@ int pi_write_regs(void *callback_context, pd_reg_t *list, unsigned long type)
 		return PD_ERR_NULL_PTR;
 	}
 
+	EMGD_DEBUG("Getting mmio");
 	mmio = EMGD_MMIO(pi_context->igd_context->device_context.virt_mmadr);
+	EMGD_DEBUG("mmio = 0x%lx", (unsigned long)mmio);
 
 	/* Based on the port type either write GMCH registers or I2C registers */
 	switch (type) {
+	case PD_REG_DDC_FW:
+		/*This will use shorter delay than PD_REG_DDC*/
+		ret = pi_context->i2c_dispatch->i2c_write_reg_list(
+			pi_context->igd_context,
+			port->ddc_reg,
+			port->ddc_speed,
+			port->ddc_dab,
+			list,
+			IGD_I2C_WRITE_FW);
+		if (ret) {
+        	EMGD_DEBUG("i2c_write_reg: 0x%lx = 0x%lx failed.",
+       		list->reg, list->value);
+        	return PD_ERR_I2C_WRITE;
+        }
+    	break;
+	case PD_REG_DDC:
+		ret = pi_context->i2c_dispatch->i2c_write_reg_list(
+			pi_context->igd_context,
+			port->ddc_reg,
+			port->ddc_speed,
+			port->ddc_dab,
+			list,
+			0);
+		if (ret) {
+        	EMGD_DEBUG("i2c_write_reg: 0x%lx = 0x%lx failed.",
+       		list->reg, list->value);
+        	return PD_ERR_I2C_WRITE;
+        }
+    	break;
 	case PD_REG_I2C:
 		ret = pi_context->i2c_dispatch->i2c_write_reg_list(
 			pi_context->igd_context,
@@ -1150,24 +1195,28 @@ int pi_write_regs(void *callback_context, pd_reg_t *list, unsigned long type)
 				list->reg, list->value);
 			return PD_ERR_I2C_WRITE;
 		}
+		EMGD_DEBUG("i2c_write_reg success");
 		break;
 	case PD_REG_PIO8:
 		while (list->reg != PD_REG_LIST_END) {
 			EMGD_WRITE_PORT8(list->reg, list->value);
 			list++;
 		}
+		EMGD_DEBUG("EMGD_WRITE_PORT8 seemed successful");
 		break;
 	case PD_REG_PIO16:
 		while (list->reg != PD_REG_LIST_END) {
 			EMGD_WRITE_PORT16(list->reg, list->value);
 			list++;
 		}
+		EMGD_DEBUG("EMGD_WRITE_PORT16 seemed successful");
 		break;
 	case PD_REG_PIO32:
 		while (list->reg != PD_REG_LIST_END) {
 			EMGD_WRITE_PORT32(list->reg, list->value);
 			list++;
 		}
+		EMGD_DEBUG("EMGD_WRITE_PORT32 seemed successful");
 		break;
 	case PD_REG_MIO :
 	case PD_REG_MIO8 :
@@ -1191,6 +1240,7 @@ int pi_write_regs(void *callback_context, pd_reg_t *list, unsigned long type)
 				}
 				list++;
 			}
+			EMGD_DEBUG("complicated write seemed successful");
 		}
 		break;
 #ifdef CONFIG_TNC
@@ -1200,6 +1250,7 @@ int pi_write_regs(void *callback_context, pd_reg_t *list, unsigned long type)
 				WRITE_MMIO_REG_TNC(IGD_PORT_LPC, list->reg, list->value);
 				list++;
 			}
+			EMGD_DEBUG("Write to IGD_PORT_LPC seemed successful");
 		}
 		break;
 #endif
@@ -1209,7 +1260,7 @@ int pi_write_regs(void *callback_context, pd_reg_t *list, unsigned long type)
 		break;
 	}
 
-	/*EMGD_TRACE_EXIT;*/
+	EMGD_TRACE_EXIT;
 	return 0;
 } /* end pi_write_regs */
 
@@ -1342,7 +1393,8 @@ int get_firmware_timings(igd_display_port_t *port,
 					port->ddc_dab,      /* Data Addr Byte*/
 					0x80,                /* Register */
 					&firmware_data[128], /* Values */
-					128);				 /* next 128 bytes include extension */
+					128,
+					0);				 /* next 128 bytes include extension */
 				ret = edid_ext_parse(&firmware_data[128], edid, timing_table,0,
 					(unsigned char)(port->pd_driver->flags&
 					PD_FLAG_UP_SCALING?1:0));
@@ -1380,7 +1432,8 @@ int get_firmware_timings(igd_display_port_t *port,
 				port->ddc_dab,      /* Data Addr Byte*/
 				0,                  /* Register */
 				firmware_data,      /* Values */
-				displayid_size);    /* Num bytes to read */
+				displayid_size,    /* Num bytes to read */
+				0);
 		}
 
 #ifdef DEBUG_FIRMWARE
@@ -1794,9 +1847,37 @@ int pi_get_port_init_attr(igd_display_port_t *port,
 	return -IGD_ERROR_INVAL;
 }
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: pi.c,v 1.20 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/display/pi/cmn/pi.c,v $
- *----------------------------------------------------------------------------
- */
+
+
+int pi_save_mode_state(igd_display_port_t *port, reg_state_id_t reg_state_id)
+{
+	int ret = PD_SUCCESS;
+	mode_state_t  *mstate = NULL;
+	if(pi_context->igd_context->mod_dispatch.reg_get_mod_state) {
+		module_state_h     *state = NULL;
+		unsigned long *flags = NULL;
+		pi_context->igd_context->mod_dispatch.reg_get_mod_state(
+			reg_state_id,
+			&state,
+			&flags);
+
+		if (state) {
+			mstate = (mode_state_t *)(*state);
+		}
+	}
+
+	/* If mode state is present in register context,
+	 * then call save() function to save the port driver's state */
+	if (mstate) {
+		ret = port->pd_driver->pd_save(port->pd_context,
+				&(mstate->pd_state[pi_context->num_pi_drivers].state), 0);
+		if (ret) {
+			EMGD_ERROR_EXIT("port driver: reg saving error. ret = %d", ret);
+			return ret;
+		}
+		mstate->pd_state[pi_context->num_pi_drivers].port = port;
+	}
+
+	return ret;
+}
+
diff --git a/drivers/gpu/drm/emgd/emgd/display/pi/plb/i2c_plb.c b/drivers/gpu/drm/emgd/emgd/display/pi/plb/i2c_plb.c
index 1bae1e9..bfc247a 100644
--- a/drivers/gpu/drm/emgd/emgd/display/pi/plb/i2c_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/display/pi/plb/i2c_plb.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: i2c_plb.c
- * $Revision: 1.11 $
+ * $Revision: 1.13 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -938,9 +938,3 @@ static int gmbus_write_reg(unsigned char *mmio,
 	return 1;
 }
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: i2c_plb.c,v 1.11 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/display/pi/plb/i2c_plb.c,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_bitbash_tnc.c b/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_bitbash_tnc.c
index 0cc89aa..89bf1ed 100644
--- a/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_bitbash_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_bitbash_tnc.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: i2c_bitbash_tnc.c
- * $Revision: 1.7 $
+ * $Revision: 1.10 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -80,7 +80,8 @@ int i2c_read_regs_gpio(
 	unsigned long dab,
 	unsigned char reg,
 	unsigned char FAR *buffer,
-	unsigned long num_bytes);
+	unsigned long num_bytes,
+	unsigned long flags);
 
 int i2c_write_reg_list_gpio(
 	igd_context_t *context,
@@ -177,7 +178,7 @@ static void i2c_set_data(int data,
 	}
 	WRITE_MMIO_REG_TNC(IGD_PORT_LPC, RGLVL, temp);
 
-	OS_SLEEP(hold_time);
+	OS_DELAY(hold_time);
 
 #if 0
 	/* Implementation using Display GPIO
@@ -192,7 +193,7 @@ static void i2c_set_data(int data,
 	 */
 	EMGD_WRITE32(data ? 0x500 : 0x700, EMGD_MMIO(mmio) + i2c_bus);
 	EMGD_WRITE32(data ? 0x400 : 0x600, EMGD_MMIO(mmio) + i2c_bus);
-	OS_SLEEP(hold_time);
+	OS_DELAY(hold_time);
 #endif
 }
 
@@ -225,7 +226,7 @@ static void i2c_set_clock(int clock,
 	}
 	WRITE_MMIO_REG_TNC(IGD_PORT_LPC, RGLVL, temp);
 
-	OS_SLEEP(hold_time);
+	OS_DELAY(hold_time);
 
 #if 0
 	/*
@@ -238,7 +239,7 @@ static void i2c_set_clock(int clock,
 
 	EMGD_WRITE32(clock ? 0x5 : 0x7, EMGD_MMIO(mmio) + i2c_bus);
 	EMGD_WRITE32(clock ? 0x4 : 0x6, EMGD_MMIO(mmio) + i2c_bus);
-	OS_SLEEP(hold_time);
+	OS_DELAY(hold_time);
 #endif
 }
 
@@ -352,7 +353,7 @@ static int i2c_write_byte_tnc(unsigned char value,
 	/* Set data low. Possible inteference in some lvds panel */
 	i2c_set_data(0, hold_time);
 	i2c_set_clock(1, hold_time);
-	OS_SLEEP(hold_time);
+	OS_DELAY(hold_time);
 
 	i2c_get(&sc, &sd);
 
@@ -388,7 +389,7 @@ static int i2c_read_byte_tnc(unsigned char *value,
 	for(i=7; i>=0; i--) {
 		i2c_set_clock(1, hold_time);
 		i2c_get(&sc, &sd);
-		OS_SLEEP(hold_time);
+		OS_DELAY(hold_time);
 		if(!sc) {
 			EMGD_DEBUG("Clock low on read %d", i);
 			i2c_error_recovery_tnc(hold_time);
@@ -435,7 +436,9 @@ int i2c_read_regs_gpio(igd_context_t *context,
 	unsigned long dab,
 	unsigned char reg,
 	unsigned char FAR *buffer,
-	unsigned long num_bytes)
+	unsigned long num_bytes,
+	unsigned long flags
+	)
 {
 	unsigned long hold_time;
 	unsigned char temp;
@@ -449,7 +452,11 @@ int i2c_read_regs_gpio(igd_context_t *context,
 	 * We are holding the clock LOW for "hold_time" and then HIGH for
 	 * "hold_time". Therefore, we double the clock speed in this calculation.
 	 */
+	if (flags & IGD_I2C_WRITE_FW){
+		hold_time = 1;
+	} else {
 	hold_time = 1000/(i2c_speed * 2);
+	}
 
 	/* enable_gpio_tnc(context); */
 
@@ -538,7 +545,11 @@ int i2c_write_reg_list_gpio(igd_context_t *context,
 	 * We are holding the clock LOW for "hold_time" and then HIGH for
 	 * "hold_time". Therefore, we double the clock speed in this calculation.
 	 */
+	if (flags & IGD_I2C_WRITE_FW){
+		hold_time = 1;
+	} else {
 	hold_time = 1000/(i2c_speed * 2);
+	}
 
 	/* enable_gpio_tnc(context); */
 
@@ -586,9 +597,3 @@ int i2c_write_reg_list_gpio(igd_context_t *context,
 	return 0;
 }
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: i2c_bitbash_tnc.c,v 1.7 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/display/pi/tnc/i2c_bitbash_tnc.c,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_gmbus_tnc.c b/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_gmbus_tnc.c
index e8fbb76..ed8cbb9 100644
--- a/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_gmbus_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/display/pi/tnc/i2c_gmbus_tnc.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: i2c_gmbus_tnc.c
- * $Revision: 1.12 $
+ * $Revision: 1.15 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -62,7 +62,8 @@ static int i2c_read_regs_tnc(
 	unsigned long dab,
 	unsigned char reg,
 	unsigned char FAR *buffer,
-	unsigned long num_bytes);
+	unsigned long num_bytes,
+	unsigned long flags);
 
 static int i2c_write_reg_list_tnc(
 	igd_context_t *context,
@@ -179,7 +180,8 @@ extern int i2c_read_regs_gpio(
 	unsigned long dab,
 	unsigned char reg,
 	unsigned char FAR *buffer,
-	unsigned long num_bytes);
+	unsigned long num_bytes,
+	unsigned long flags);
 
 extern int i2c_write_reg_list_gpio(
 	igd_context_t *context,
@@ -210,7 +212,8 @@ static int i2c_read_regs_tnc(igd_context_t *context,
 	unsigned long dab,
 	unsigned char reg,
 	unsigned char FAR *buffer,
-	unsigned long num_bytes)
+	unsigned long num_bytes,
+	unsigned long flags)
 {
 	unsigned long slave_addr = 0;
 
@@ -221,7 +224,7 @@ static int i2c_read_regs_tnc(igd_context_t *context,
 		 */
 
 		EMGD_DEBUG("i2c_read_regs_tnc : Using GPIO to read DDC");
-		return i2c_read_regs_gpio(context, i2c_bus, i2c_speed,	dab, reg, buffer, num_bytes);
+		return i2c_read_regs_gpio(context, i2c_bus, i2c_speed,	dab, reg, buffer, num_bytes, flags);
 
 	} else {
 
@@ -924,9 +927,3 @@ static int gmbus_write_reg(unsigned long slave_addr,
 	return 1;
 }
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: i2c_gmbus_tnc.c,v 1.12 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/display/pi/tnc/i2c_gmbus_tnc.c,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/drm/drm_emgd_private.h b/drivers/gpu/drm/emgd/emgd/drm/drm_emgd_private.h
index df5777a..109f790 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/drm_emgd_private.h
+++ b/drivers/gpu/drm/emgd/emgd/drm/drm_emgd_private.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: drm_emgd_private.h
- * $Revision: 1.18 $
+ * $Revision: 1.20 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -36,10 +36,17 @@
 
 #include <drm/drmP.h>
 #include <drm/drm.h>
+#include <drm/drm_fb_helper.h>
+#include "mode.h"
 #include "context.h"
+#include "emgd_drv.h"
 
+struct _drm_emgd_private;
 
 
+/* FIXME: This define should not be here.  Find a better place to put it */
+#define PSB_GATT_RESOURCE   2
+
 /**
  * This enum is used to record the currently-saved register state (e.g. for VT
  * switching)--either the Linux console's state is saved (i.e. the X server is
@@ -84,9 +91,6 @@ typedef struct _drm_emgd_private {
 	/** Non-zero if the X server is running (i.e. PVR can't do mode changes) */
 	int xserver_running;
 
-	/** Non-zero if emgd_start_pvrsrv() started the PVR services, else zero. */
-	int pvrsrv_started;
-
 	/**
 	 * Function to re-initialize the 3DD's data structures, after calls to
 	 * alter_displays()
@@ -132,15 +136,32 @@ typedef struct _drm_emgd_private {
 	 */
 	igd_init_info_t *init_info;
 
-
 	/** TODO:  May use this in future.
-	* MSVDX
-	*/
+	 * MSVDX
+	 */
 	void *msvdx_private;
 
+	/*
+	 * GTT offset of initial framebuffer.  The initial framebuffer is a special
+	 * case in that it is allocated directly by the GMM at system startup
+	 * before the PVR services are initialized.  As such, it has no PVR
+	 * meminfo that can be used as a handle to refer to it; functions that take
+	 * a framebuffer will treat a handle of 0 as referring to the initial
+	 * framebuffer and then pull the GTT offset from here.
+	 */
+	//unsigned long initfb_offset;
+	igd_framebuffer_info_t initfb_info;
+
 	/* fbdev is removed from drm_framebuffer in 2.6.35 so access it here */
-	struct fb_info *fbdev;
+	struct fb_info    *fbdev;
+	emgd_crtc_t       *crtcs[IGD_MAX_PIPES];
+	int                num_crtc;
+	emgd_fbdev_t      *emgd_fbdev;
+	bool               mode_config_initialized;
+	struct drm_device *ddev;
+	bool               kms_enabled;
+	int qb_seamless; /* Store the state of seamless/quickboot */
+} drm_emgd_priv_t;
 
-} drm_emgd_private;
 
 #endif
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_connector.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_connector.c
new file mode 100644
index 0000000..280f839
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_connector.c
@@ -0,0 +1,512 @@
+/*
+ *-----------------------------------------------------------------------------
+ * Filename: emgd_connector.c
+ * $Revision: 1.2 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2011, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ * Description:
+ *  Connector / kenrel mode setting functions.
+ *-----------------------------------------------------------------------------
+ */
+#define MODULE_NAME hal.oal
+
+
+#include <drmP.h>
+#include <drm_crtc_helper.h>
+#include <linux/version.h>
+
+
+#include "drm_emgd_private.h"
+
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)
+static enum drm_connector_status emgd_connector_detect(
+									struct drm_connector *connector,
+									bool force);
+#else
+static enum drm_connector_status emgd_connector_detect(
+									struct drm_connector *connector);
+#endif
+
+static int  emgd_connector_set_property(struct drm_connector *connector,
+				struct drm_property *property,
+	   			uint64_t value);
+static void emgd_connector_destroy(struct drm_connector *connector);
+static int  emgd_connector_get_modes(struct drm_connector *connector);
+static int  emgd_connector_mode_valid(struct drm_connector *connector,
+				struct drm_display_mode *mode);
+static struct drm_encoder *emgd_connector_best_encoder(
+								struct drm_connector *connector);
+static void emgd_connector_save (struct drm_connector *connector);
+static void emgd_connector_restore (struct drm_connector *connector);
+
+
+
+const struct drm_connector_funcs emgd_connector_funcs = {
+	.save         = emgd_connector_save,
+	.restore      = emgd_connector_restore,
+	.dpms         = drm_helper_connector_dpms,
+	.detect       = emgd_connector_detect,
+	.fill_modes   = drm_helper_probe_single_connector_modes,
+	.set_property = emgd_connector_set_property,
+	.destroy      = emgd_connector_destroy,
+};
+
+const struct drm_connector_helper_funcs emgd_connector_helper_funcs = {
+	.get_modes    = emgd_connector_get_modes,
+	.mode_valid   = emgd_connector_mode_valid,
+	.best_encoder = emgd_connector_best_encoder,
+};
+
+
+
+/**
+ * emgd_mode_to_kms
+ *
+ * Converts an EMGD mode to a DRM KMS mode
+ *
+ * @param emgd_mode (IN)  emgd_mode timing information
+ * @param drm_mode  (OUT) DRM mode
+ */
+static void emgd_mode_to_kms(igd_display_info_t *emgd_mode,
+				struct drm_display_mode *drm_mode)
+{
+	drm_mode->status      = MODE_OK;
+	drm_mode->type        = DRM_MODE_TYPE_DRIVER;
+	drm_mode->clock       = emgd_mode->dclk;
+	drm_mode->hdisplay    = emgd_mode->width;
+	drm_mode->hsync_start = emgd_mode->hsync_start;
+	drm_mode->hsync_end   = emgd_mode->hsync_end;
+	drm_mode->htotal      = emgd_mode->htotal;
+	drm_mode->vdisplay    = emgd_mode->height;
+	drm_mode->vsync_start = emgd_mode->vsync_start;
+	drm_mode->vsync_end   = emgd_mode->vsync_end;
+	drm_mode->vtotal      = emgd_mode->vtotal;
+	drm_mode->flags       = 0;
+	drm_mode->vrefresh    = emgd_mode->refresh;
+
+	drm_mode_set_name(drm_mode);
+}
+
+
+
+/**
+ * emgd_connector_save
+ *
+ * Saves a connector state before a power event.
+ *
+ * @param encoder (IN) Encoder
+ * @param mode    (IN) power mode
+ *
+ * @return None
+ */
+static void emgd_connector_save (struct drm_connector *connector)
+{
+#if 0
+	emgd_connector_t   *emgd_connector;
+	emgd_encoder_t     *emgd_encoder;
+	igd_display_port_t *igd_port;
+
+
+	/* Currently there is no need to do anything in this function because
+	 * CRTC save calls igd_driver_save() which eventually calls mode_save().
+	 * Inside of mode_save() is where encoder state is saved.  In order for
+	 * this function to work properly, we need to take the pd_save() call
+	 * out of mode_save().  Let's wait until Phase 2 to do this.
+	 */
+
+	EMGD_TRACE_ENTER;
+
+	emgd_connector = container_of(connector, emgd_connector_t, base);
+	emgd_encoder   = emgd_connector->encoder;
+	igd_port       = emgd_encoder->igd_port;
+
+	igd_port->pd_driver->pd_save(igd_port->pd_context,
+							&emgd_encoder->state.state, 0);
+
+	EMGD_TRACE_EXIT;
+#else
+	EMGD_TRACE_ENTER;
+	EMGD_TRACE_EXIT;
+#endif
+}
+
+
+
+/**
+ * emgd_connector_restore
+ *
+ * Restores a connector state after a power event
+ *
+ * @param encoder (IN) Encoder
+ * @param mode    (IN) power mode
+ *
+ * @return None
+ */
+static void emgd_connector_restore (struct drm_connector *connector)
+{
+#if 0
+	emgd_connector_t   *emgd_connector;
+	emgd_encoder_t     *emgd_encoder;
+	igd_display_port_t *igd_port;
+
+
+	/* Currently there is no need to do anything in this function because
+	 * CRTC save calls igd_driver_save() which eventually calls mode_save().
+	 * Inside of mode_save() is where encoder state is saved.  In order for
+	 * this function to work properly, we need to take the pd_save() call
+	 * out of mode_save().  Let's wait until Phase 2 to do this.
+	 */
+
+	EMGD_TRACE_ENTER;
+
+	emgd_connector = container_of(connector, emgd_connector_t, base);
+	emgd_encoder   = emgd_connector->encoder;
+	igd_port       = emgd_encoder->igd_port;
+
+	igd_port->pd_driver->pd_restore(igd_port->pd_context,
+							emgd_encoder->state.state, 0);
+	emgd_encoder->state.state = NULL;
+
+	EMGD_TRACE_EXIT;
+#else
+	EMGD_TRACE_ENTER;
+	EMGD_TRACE_EXIT;
+#endif
+}
+
+
+
+/**
+ * emgd_connector_detect
+ *
+ * Checks to see if a display device is attached to the connector.  EMGD
+ * does not currently support hot-plug.
+ *
+ * FIXME: The prototype for this function seemed to change sometime
+ * around the 2.6.35 timeframe however, different distributions
+ * cherrypicked it earlier.
+ *
+ * Fedora 14's 2.6.35.11 kernel has the patch (needs bool force)
+ * MeeGo's 2.6.35.10 kernel doesn't.
+ *
+ * @param encoder (IN) Encoder
+ * @param mode    (IN) power mode
+ *
+ * @return None
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)
+
+static enum drm_connector_status emgd_connector_detect(
+		struct drm_connector *connector, bool force) {
+#else
+static enum drm_connector_status emgd_connector_detect(
+		struct drm_connector *connector) {
+#endif
+	emgd_connector_t          *emgd_connector;
+	enum drm_connector_status  connector_status;
+	igd_display_port_t        *igd_port;
+	pd_port_status_t           port_status;
+
+	EMGD_TRACE_ENTER;
+
+	emgd_connector = container_of(connector, emgd_connector_t, base);
+	igd_port       = emgd_connector->encoder->igd_port;
+
+	memset(&port_status, 0, sizeof(pd_port_status_t));
+
+	/* Get current status from the port driver */
+	igd_port->pd_driver->pd_get_port_status(igd_port->pd_context, &port_status);
+
+	switch (port_status.connected) {
+		case PD_DISP_STATUS_ATTACHED:
+			connector_status = connector_status_connected;
+			break;
+
+		case PD_DISP_STATUS_DETACHED:
+			connector_status = connector_status_disconnected;
+			break;
+
+		case PD_DISP_STATUS_UNKNOWN:
+		default:
+			/*
+             * Technically "unknown" is correct here, but that isn't actually
+			 * what we want to pass back to userspace via KMS.  LVDS panels
+			 * always have unknown connection status, so they'll always be
+			 * ignored by userspace apps that only operate on connected outputs.
+			 * If the driver is configured to use a port, then we should just
+			 * assume that its actually connected when we report back to
+			 * userspace.
+			 */
+
+			connector_status = connector_status_connected;
+			break;
+	}
+
+
+	EMGD_TRACE_EXIT;
+
+	return connector_status;
+}
+
+
+
+/**
+ * emgd_connector_set_property
+ *
+ * Sets a port attribute.
+ *
+ * @param connector (IN) connector
+ * @param property  (IN)
+ * @param value     (IN)
+ *
+ * @return TBD
+ */
+static int emgd_connector_set_property(struct drm_connector *connector,
+			struct drm_property *property,
+			uint64_t value)
+{
+	emgd_connector_t   *emgd_connector;
+	drm_emgd_priv_t    *priv;
+	int                 ret;
+	igd_attr_t		   *attributes, selected_attr;
+	unsigned short      port_number;
+	unsigned long       num_of_attributes, i;
+
+
+	EMGD_TRACE_ENTER;
+
+	/* Set the property value to the new one.  This doesn't actually change
+     * anything on the HW. */
+	ret = drm_connector_property_set_value(connector, property, value);
+	if (ret) {
+		return ret;
+	}
+
+	/* Take care of the HW changes associated with the value change */
+	emgd_connector = container_of(connector, emgd_connector_t, base);
+	port_number    = emgd_connector->encoder->igd_port->port_number;
+	priv           = emgd_connector->priv;
+
+	/* Search port attributes to find the one associated with the property */
+	ret = priv->context->dispatch.get_attrs(priv->context,
+									port_number,
+									&num_of_attributes,
+									&attributes);
+
+	if (ret) {
+		return ret;
+	}
+
+
+	for (i = 0; i < num_of_attributes; i++) {
+
+		if (attributes[i].id == property->values[0]) {
+			/* Copy the content of the attribute */
+			memcpy(&selected_attr, &attributes[i], sizeof(igd_attr_t));
+
+			switch (selected_attr.type) {
+				case PD_ATTR_TYPE_RANGE:
+				case PD_ATTR_TYPE_BOOL:
+					selected_attr.current_value = (unsigned long) value;
+					ret = priv->context->dispatch.set_attrs(priv->context,
+													port_number,
+													1, /* Setting 1 attribute */
+													&selected_attr);
+					break;
+
+				case PD_ATTR_TYPE_LIST:
+				case PD_ATTR_TYPE_LIST_ENTRY:
+				case PD_ATTR_TYPE_BUFFER:
+				default:
+					EMGD_DEBUG("Unsupported PD Attribute type");
+					continue;
+			}
+
+			break;
+		}
+	}
+
+	EMGD_TRACE_EXIT;
+
+	return ret;
+}
+
+
+
+/**
+ * emgd_connector_destroy
+ *
+ * Cleans up the emgd_connector object.
+ *
+ * @param connector (IN) connector to clean up
+ *
+ * @return None
+ */
+static void emgd_connector_destroy(struct drm_connector *connector)
+{
+	struct drm_device *dev = connector->dev;
+	emgd_connector_t  *emgd_connector;
+
+	EMGD_TRACE_ENTER;
+	EMGD_DEBUG("connector=0x%lx",(unsigned long)connector);
+
+	emgd_connector = container_of(connector, emgd_connector_t, base);
+
+	drm_sysfs_connector_remove(connector);
+	drm_connector_cleanup(connector);
+
+	/* Remove the properties */
+	if (emgd_connector->properties) {
+		int i;
+
+		for(i = 0; i < emgd_connector->num_of_properties; i++) {
+			drm_property_destroy(dev, emgd_connector->properties[i]);
+		}
+
+		kfree(emgd_connector->properties);
+		emgd_connector->properties = NULL;
+	}
+
+	kfree(emgd_connector);
+
+	EMGD_TRACE_EXIT;
+}
+
+
+
+/**
+ * emgd_connector_get_modes
+ *
+ * Get the list of supported modes for the given connector
+ *
+ * @param connector (IN) connector to query.
+ *
+ * @return None
+ */
+static int emgd_connector_get_modes(struct drm_connector *connector)
+{
+        emgd_connector_t        *emgd_connector;
+        igd_display_port_t      *igd_port;
+        unsigned long            i;
+        struct drm_display_mode *drm_mode;
+
+
+        EMGD_TRACE_ENTER;
+
+        emgd_connector = container_of(connector, emgd_connector_t, base);
+        igd_port       = emgd_connector->encoder->igd_port;
+
+        EMGD_DEBUG("[EMGD] emgd_connector_get_modes for port %ld\n",
+                igd_port->port_number);
+
+        for (i = 0; i < igd_port->num_timing; i++) {
+                drm_mode = drm_mode_create(emgd_connector->priv->ddev);
+
+                emgd_mode_to_kms((igd_display_info_t *)&igd_port->timing_table[i],
+                        drm_mode);
+
+                /* Add current mode to the connector */
+                drm_mode_probed_add(connector, drm_mode);
+        }
+
+
+        EMGD_TRACE_EXIT;
+
+        return igd_port->num_timing;
+}
+
+
+
+/**
+ * emgd_connector_mode_valid
+ *
+ * Examines the mode given and see if the connector can support it.
+ * Note:  the ModeStatus enum is defined in xorg/hw/xfree86/common/xf86str.h
+ *
+ * @param connector (IN) the connector to be analyzed.
+ * @param mode      (IN) mode to check
+ *
+ * @return MODE_OK if supported, other ModeStatus enum if not
+ */
+static int emgd_connector_mode_valid(struct drm_connector *connector,
+                struct drm_display_mode *mode)
+{
+        emgd_connector_t *emgd_connector;
+
+        EMGD_TRACE_ENTER;
+
+        emgd_connector = container_of(connector, emgd_connector_t, base);
+
+
+        /* Basic checks */
+        if ((0 >= mode->hdisplay) || (mode->hdisplay > mode->hsync_start) ||
+                (mode->hsync_start >= mode->hsync_end) ||
+                (mode->hsync_end >= mode->htotal)) {
+                return MODE_H_ILLEGAL;
+        }
+
+        if ((0 >= mode->vdisplay) || (mode->vdisplay > mode->vsync_start) ||
+                (mode->vsync_start >= mode->vsync_end) ||
+                (mode->vsync_end >= mode->vtotal)) {
+                return MODE_V_ILLEGAL;
+        }
+
+
+        /* We can do some basic checks here, but it is better to call
+     * match_mode() in the display/mode module because that function does
+     * a much more thorough check */
+
+
+
+        EMGD_TRACE_EXIT;
+
+        return MODE_OK;
+}
+
+
+
+/**
+ * emgd_connector_best_encoder
+ *
+ * Returns the best encoder for the given connector.  In EMGD the connector is
+ * fixed to the encoder.
+ *
+ * @param connector (IN) the connector to be analyzed.
+ *
+ * @return Encoder onto which the connector is fixed on.
+ */
+static struct drm_encoder *emgd_connector_best_encoder(
+                struct drm_connector *connector)
+{
+        emgd_connector_t *emgd_connector;
+
+        EMGD_TRACE_ENTER;
+
+        emgd_connector = container_of(connector, emgd_connector_t, base);
+
+        EMGD_TRACE_EXIT;
+
+        return &emgd_connector->encoder->base;
+}
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_crtc.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_crtc.c
new file mode 100644
index 0000000..4dfb1e1
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_crtc.c
@@ -0,0 +1,1004 @@
+/*
+ *-----------------------------------------------------------------------------
+ * Filename: emgd_crtc.c
+ * $Revision: 1.3 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2011, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ * Description:
+ *  CRTC / kernel mode setting functions.
+ *-----------------------------------------------------------------------------
+ */
+#define MODULE_NAME hal.oal
+
+
+#include <drmP.h>
+#include <drm_crtc_helper.h>
+#include <linux/version.h>
+
+
+#include "drm_emgd_private.h"
+
+#include <memory.h>
+#include <mode_dispatch.h>
+#include <igd_pwr.h>
+
+/* Necessary to cursor memory from PVR buffer */
+#include "pvr_bridge_km.h"
+
+/* Maximum cursor size supported by our HAL: 64x64 in ARGB */
+#define MAX_CURSOR_SIZE (64*64*4)
+
+static void emgd_crtc_dpms(struct drm_crtc *crtc, int mode);
+static bool emgd_crtc_mode_fixup(struct drm_crtc *crtc,
+		struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);
+static int emgd_crtc_mode_set(struct drm_crtc *crtc,
+		struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode,
+		int x, int y, struct drm_framebuffer *old_fb);
+static int emgd_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
+		struct drm_framebuffer *old_fb);
+static void emgd_crtc_prepare(struct drm_crtc *crtc);
+static void emgd_crtc_commit(struct drm_crtc *crtc);
+
+static void emgd_crtc_save(struct drm_crtc *crtc);
+static void emgd_crtc_restore(struct drm_crtc *crtc);
+static int emgd_crtc_cursor_set(struct drm_crtc *crtc,
+		struct drm_file *file_priv, uint32_t handle,
+		uint32_t width, uint32_t height);
+static int emgd_crtc_cursor_move(struct drm_crtc *crtc, int x, int y);
+static void emgd_crtc_gamma_set(struct drm_crtc *crtc,
+		unsigned short *red, unsigned short *green, unsigned short *blue,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+		uint32_t start,
+#endif
+		uint32_t size);
+static void emgd_crtc_destroy(struct drm_crtc *crtc);
+static void emgd_crtc_load_lut(struct drm_crtc *crtc);
+static int emgd_crtc_page_flip(struct drm_crtc *crtc,
+                                struct drm_framebuffer *fb,
+                                struct drm_pending_vblank_event *event);
+static int emgd_crtc_set_config(struct drm_mode_set *set);
+
+
+
+const struct drm_crtc_helper_funcs emgd_crtc_helper_funcs = {
+	.dpms          = emgd_crtc_dpms,
+	.mode_fixup    = emgd_crtc_mode_fixup,
+	.mode_set      = emgd_crtc_mode_set,
+	.mode_set_base = emgd_crtc_mode_set_base,
+	.prepare       = emgd_crtc_prepare,
+	.commit        = emgd_crtc_commit,
+	.load_lut      = emgd_crtc_load_lut,
+};
+
+const struct drm_crtc_funcs emgd_crtc_funcs = {
+	.save        = emgd_crtc_save,
+	.restore     = emgd_crtc_restore,
+	.cursor_set  = emgd_crtc_cursor_set,
+	.cursor_move = emgd_crtc_cursor_move,
+	.gamma_set   = emgd_crtc_gamma_set,
+	.set_config  = emgd_crtc_set_config,
+	.destroy     = emgd_crtc_destroy,
+	.page_flip   = emgd_crtc_page_flip,
+};
+
+
+
+static int emgd_crtc_set_config(struct drm_mode_set *set)
+{
+	int ret;
+	struct drm_device  *dev;
+	struct drm_encoder *encoder;
+	struct drm_encoder_helper_funcs *encoder_funcs;
+
+	EMGD_TRACE_ENTER;
+
+	ret = drm_crtc_helper_set_config(set);
+
+	if (ret) {
+		EMGD_ERROR_EXIT("Failed to set config\n");
+		return ret;
+	}
+
+	/*  FIXME: This is a temporary fix for the resume problem:  Screen goes
+	 *  blank after an idling period, then doesn't come back.  At this point
+	 *  it is unclear why KMS is not calling our DPMS functions to re-enable
+	 *  the display.  KMS does call this function on resume, so we will
+	 *  enable the displays here
+	 */
+	emgd_crtc_dpms(set->crtc, DRM_MODE_DPMS_ON);
+
+	dev = set->crtc->dev;
+
+	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+		if (encoder->crtc == set->crtc) {
+			encoder_funcs = encoder->helper_private;
+			encoder_funcs->dpms(encoder, DRM_MODE_DPMS_ON);
+		}
+	}
+
+
+	EMGD_TRACE_EXIT;
+
+	return ret;
+}
+
+/*
+ * Sets the power management mode of the pipe.
+ */
+static void emgd_crtc_dpms(struct drm_crtc *crtc, int mode)
+{
+	emgd_crtc_t           *emgd_crtc = NULL;
+	igd_display_pipe_t    *pipe = NULL;
+
+	EMGD_TRACE_ENTER;
+
+
+	emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+	EMGD_DEBUG("pipe=%d, mode=%d", emgd_crtc->crtc_id, mode);
+	pipe = emgd_crtc->igd_pipe;
+
+
+	switch(mode) {
+	case DRM_MODE_DPMS_ON:
+		EMGD_DEBUG("Checking if we have pipe timings");
+		if (!pipe->timing) {
+			/* If there is no pipe timing, we cannot enable */
+			EMGD_ERROR("No pipe timing, can't enable pipe");
+		} else {
+			EMGD_DEBUG("Calling program pipe");
+			mode_context->kms_dispatch->kms_set_pipe_pwr(emgd_crtc, TRUE);
+
+			EMGD_DEBUG("Calling program plane");
+			//mode_context->kms_dispatch->kms_set_plane_pwr(emgd_crtc, TRUE);
+			mode_context->kms_dispatch->kms_program_plane(emgd_crtc, TRUE);
+			crtc->enabled = true;
+		}
+		break;
+
+	case DRM_MODE_DPMS_STANDBY:
+	case DRM_MODE_DPMS_SUSPEND:
+	case DRM_MODE_DPMS_OFF:
+		if (emgd_crtc->igd_pipe->inuse && crtc->enabled) {
+			EMGD_DEBUG("Calling program plane");
+			//mode_context->kms_dispatch->kms_set_plane_pwr(emgd_crtc, FALSE);
+			mode_context->kms_dispatch->kms_program_plane(emgd_crtc, FALSE);
+
+
+			EMGD_DEBUG("Calling program pipe");
+			mode_context->kms_dispatch->kms_set_pipe_pwr(emgd_crtc, FALSE);
+			crtc->enabled = false;
+		} else {
+			EMGD_ERROR("pipe is already off");
+		}
+		break;
+	default:
+		break;
+	}
+
+	EMGD_TRACE_EXIT;
+}
+
+
+
+static bool emgd_crtc_mode_fixup(struct drm_crtc *crtc,
+				struct drm_display_mode *mode,
+				struct drm_display_mode *adjusted_mode)
+{
+	EMGD_TRACE_ENTER;
+
+	/* Check ajusted mode to see if it's valid.  If not, populate it */
+	if (adjusted_mode->crtc_htotal == 0) {
+		drm_mode_set_crtcinfo(adjusted_mode, 0);
+	}
+
+	EMGD_TRACE_EXIT;
+	return 1;
+}
+
+
+
+/**
+ * emgd_crtc_mode_set
+ *
+ * Sets mode for the selected CRTC.  This function only sets the timings
+ * into the CRTC, but doesn't actually program the timing values into the
+ * registers.  The actual programming is done in emgd_crtc_commit.
+ *
+ * @param crtc   (IN) CRTC to configure
+ * @param x      (IN) starting X position in the frame buffer
+ * @param y      (IN) starting Y position in the frame buffer
+ * @param old_fb (IN) Not used
+ *
+ * @return 0
+ */
+static int emgd_crtc_mode_set(struct drm_crtc *crtc,
+		struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode,
+		int x, int y, struct drm_framebuffer *old_fb)
+{
+	emgd_crtc_t            *emgd_crtc = NULL;
+	struct drm_device      *dev = NULL;
+	igd_context_t          *context = NULL;
+	igd_display_pipe_t     *pipe = NULL;
+	igd_timing_info_t      *timing = NULL;
+
+	EMGD_TRACE_ENTER;
+
+
+	dev = crtc->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+
+	/* Which pipe are we using */
+	EMGD_DEBUG("Getting PIPE");
+	emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+
+	EMGD_DEBUG("\t\tpipe=%d, ->(%dx%d@%d)", emgd_crtc->crtc_id,
+		adjusted_mode->crtc_hdisplay, adjusted_mode->crtc_vdisplay,
+		adjusted_mode->vrefresh);
+
+	pipe  = emgd_crtc->igd_pipe;
+
+
+	if (old_fb) {
+		EMGD_DEBUG("Handling old framebuffer?");
+		/* What do we do with the old framebuffer? */
+	}
+
+	timing = kzalloc(sizeof(igd_timing_info_t), GFP_KERNEL);
+	if (!timing) {
+		EMGD_ERROR_EXIT("unable to allocate a igd_timing_info struct.");
+		return 1;
+	}
+
+	timing->width = adjusted_mode->crtc_hdisplay;
+	timing->height = adjusted_mode->crtc_vdisplay;
+	timing->refresh = adjusted_mode->vrefresh;
+	timing->dclk = adjusted_mode->synth_clock; /* Is this the right variable? */
+	timing->htotal = adjusted_mode->crtc_htotal;
+	timing->hblank_start = adjusted_mode->crtc_hblank_start;
+	timing->hblank_end = adjusted_mode->crtc_hblank_end;
+	timing->hsync_start = adjusted_mode->crtc_hsync_start;
+	timing->hsync_end = adjusted_mode->crtc_hsync_end;
+	timing->vtotal = adjusted_mode->crtc_vtotal;
+	timing->vblank_start = adjusted_mode->crtc_vblank_start;
+	timing->vblank_end = adjusted_mode->crtc_vblank_end;
+	timing->vsync_start = adjusted_mode->crtc_vsync_start;
+	timing->vsync_end = adjusted_mode->crtc_vsync_end;
+	timing->mode_number = adjusted_mode->clock_index;
+	timing->mode_info_flags = adjusted_mode->private_flags;
+	timing->x_offset = x;
+	timing->y_offset = y;
+	timing->mode_info_flags |= IGD_DISPLAY_ENABLE;
+
+	if (pipe->timing) {
+		OS_MEMCPY(pipe->timing, timing, sizeof(igd_timing_info_t));
+		kfree(timing);
+	} else {
+		pipe->timing = timing;
+	}
+
+	/* The code above only sets the CRTC timing, not the plane */
+	emgd_crtc_mode_set_base(crtc, x, y, old_fb);
+
+
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+
+
+
+/**
+ * emgd_crtc_mode_set_base
+ *
+ * Sets the starting position in the framebuffer for the given CRTC.
+ *
+ * @param crtc   (IN) CRTC to configure
+ * @param x      (IN) starting X position in the frame buffer
+ * @param y      (IN) starting Y position in the frame buffer
+ * @param old_fb (IN) Not used
+ *
+ * @return 0
+ */
+static int emgd_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
+		struct drm_framebuffer *old_fb)
+{
+	emgd_crtc_t *emgd_crtc = NULL;
+	igd_display_context_t *display = NULL;
+	emgd_framebuffer_t *emgd_fb;
+	igd_framebuffer_info_t *plane_fb_info;
+	struct drm_framebuffer *fb = NULL;
+	int ret = 0;
+
+	EMGD_TRACE_ENTER;
+
+
+	emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+	fb        = crtc->fb;
+	emgd_fb   = container_of(fb, emgd_framebuffer_t, base);
+	display   = emgd_crtc->igd_pipe->owner;
+
+
+	if (old_fb) {
+		/* We should not need to do anything here. */
+	}
+
+	plane_fb_info = PLANE(display)->fb_info;
+
+	plane_fb_info->width          = fb->width;
+	plane_fb_info->height         = fb->height;
+	plane_fb_info->screen_pitch   = fb->pitch;
+	plane_fb_info->flags          = 0;
+	plane_fb_info->allocated      = 1;
+	plane_fb_info->fb_base_offset = emgd_fb->gtt_offset;
+	plane_fb_info->visible_offset = (y * fb->pitch) +
+		(x * (fb->bits_per_pixel / 8));
+
+
+	PLANE(display)->inuse = 1;
+	PLANE(display)->ref_cnt++;
+
+	mode_context->kms_dispatch->kms_program_plane(emgd_crtc, TRUE);
+
+
+	EMGD_TRACE_EXIT;
+	return ret;
+}
+
+
+
+static void emgd_crtc_prepare(struct drm_crtc *crtc)
+{
+	EMGD_TRACE_ENTER;
+	emgd_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);
+	EMGD_TRACE_EXIT;
+}
+
+static void emgd_crtc_commit(struct drm_crtc *crtc)
+{
+	emgd_crtc_t *emgd_crtc = NULL;
+
+	EMGD_TRACE_ENTER;
+
+	emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+	mode_context->kms_dispatch->kms_program_pipe(emgd_crtc);
+	emgd_crtc_dpms(crtc, DRM_MODE_DPMS_ON);
+
+	EMGD_TRACE_EXIT;
+}
+
+
+static void emgd_crtc_save(struct drm_crtc *crtc)
+{
+	emgd_crtc_t *emgd_crtc = NULL;
+	igd_context_t *context = NULL;
+	unsigned long save_flags;
+
+	/* We should probably break out register save and restore
+	 * so that its specific to a crtc
+	 */
+	EMGD_TRACE_ENTER;
+
+	emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+	context = ((drm_emgd_priv_t *)crtc->dev->dev_private)->context;
+	EMGD_DEBUG("\t\tpipe=%d", emgd_crtc->crtc_id);
+
+	save_flags = (IGD_REG_SAVE_ALL & ~IGD_REG_SAVE_GTT & ~IGD_REG_SAVE_RB) |
+		IGD_REG_SAVE_TYPE_MISC;
+	context->dispatch.driver_save((igd_driver_h)context, save_flags);
+
+	EMGD_TRACE_EXIT;
+}
+
+static void emgd_crtc_restore(struct drm_crtc *crtc)
+{
+	emgd_crtc_t *emgd_crtc = NULL;
+	igd_context_t *context = NULL;
+	unsigned long restore_flags;
+
+	EMGD_TRACE_ENTER;
+
+	emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+	context = ((drm_emgd_priv_t *)crtc->dev->dev_private)->context;
+	EMGD_DEBUG("\t\tpipe=%d", emgd_crtc->crtc_id);
+
+	restore_flags = IGD_REG_SAVE_TYPE_MISC;
+	context->dispatch.driver_restore((igd_driver_h)context, restore_flags);
+
+	EMGD_TRACE_EXIT;
+}
+
+static int emgd_crtc_cursor_set(struct drm_crtc *crtc,
+		struct drm_file *file_priv, uint32_t handle,
+		uint32_t width, uint32_t height)
+{
+	emgd_crtc_t *emgd_crtc = NULL;
+	igd_context_t *context = NULL;
+	igd_display_context_t *display = NULL;
+	igd_cursor_info_t *cursor_info = NULL;
+	PVRSRV_PER_PROCESS_DATA *pvr_perproc;
+	PVRSRV_KERNEL_MEM_INFO *pvr_meminfo;
+	PVRSRV_ERROR ret;
+	unsigned char *tempcurs;
+	unsigned long pid;
+	struct page **pagelist;
+	unsigned long numpages, page_offset, cursor_size = 0;
+	void *pageaddr;
+
+	EMGD_TRACE_ENTER;
+
+	emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+	if (!emgd_crtc->igd_pipe->inuse) {
+		EMGD_ERROR("\t\tpipe %d is not available", emgd_crtc->crtc_id);
+		return 1;
+	}
+	context = ((drm_emgd_priv_t *)crtc->dev->dev_private)->context;
+	display = emgd_crtc->igd_pipe->owner;
+
+	if (!handle) {
+		/* If handle is 0, turn off the cursor */
+		EMGD_DEBUG("Turning off cursor");
+		mode_context->dispatch->full->program_cursor(display, FALSE);
+	} else {
+		/* Fetch PVR services 'per-process' data structure */
+		pid = OSGetCurrentProcessIDKM();
+		pvr_perproc = PVRSRVPerProcessData(pid);
+
+		/* Look up the kernel-side meminfo for the handle passed in*/
+		ret = PVRSRVLookupHandle(pvr_perproc->psHandleBase,
+				(void**)&pvr_meminfo,
+			(IMG_HANDLE)handle, PVRSRV_HANDLE_TYPE_MEM_INFO);
+		if (ret != PVRSRV_OK) {
+			EMGD_ERROR("Buffer handle is not a valid PVR surface.");
+			return -EINVAL;
+		}
+
+		/*
+		 * Now fetch the page list, number of pages, and offset into the first
+		 * page for this buffer.
+		 */
+		ret = PVRSRVGetPageListKM(pvr_meminfo, &pagelist, &numpages,
+				&page_offset);
+		if (ret != PVRSRV_OK) {
+			EMGD_ERROR("Failed to get pagelist for PVR surface.");
+			return -EINVAL;
+		}
+
+		/* Allocate a temporary buffer to hold the cursor image */
+		tempcurs = OS_ALLOC(MAX_CURSOR_SIZE);
+		if (!tempcurs) {
+			return -ENOMEM;
+		}
+
+		/* Map the page list into kernel virtual address space */
+		pageaddr = vmap(pagelist, numpages, VM_MAP, PAGE_KERNEL_UC_MINUS);
+
+		/*
+		 * Our HAL only accepts 64x64 x 4byte cursors.  Only copy the first
+		 * 64x64x4 of the provided buffer if the user tries to pass us
+		 * something too big.
+		 */
+		if (numpages * PAGE_SIZE > MAX_CURSOR_SIZE) {
+			cursor_size = MAX_CURSOR_SIZE;
+		} else {
+			cursor_size = numpages * PAGE_SIZE;
+		}
+
+		OS_MEMCPY(tempcurs, pageaddr, cursor_size);
+
+		vunmap(pageaddr);
+
+		/* Pass the cursor image to the HAL to program the cursor plane */
+		cursor_info = emgd_crtc->igd_pipe->cursor->cursor_info;
+		cursor_info->flags = IGD_CURSOR_LOAD_ARGB_IMAGE | IGD_CURSOR_ON;
+		cursor_info->width = width;
+		cursor_info->height = height;
+		context->dispatch.alter_cursor(display, cursor_info, tempcurs);
+
+		/* Free temporary cursor image */
+		OS_FREE(tempcurs);
+	}
+
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+
+static int emgd_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)
+{
+	emgd_crtc_t *emgd_crtc = NULL;
+	igd_context_t *context = NULL;
+	igd_display_context_t *display = NULL;
+	igd_cursor_info_t *emgd_cursor;
+
+	/* Too spammy; commenting out */
+#if 0
+	EMGD_TRACE_ENTER;
+#endif
+
+	emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+	if (!emgd_crtc->igd_pipe->inuse) {
+		EMGD_ERROR("\t\tpipe %d is not available", emgd_crtc->crtc_id);
+		return 1;
+	}
+	context = ((drm_emgd_priv_t *)crtc->dev->dev_private)->context;
+	display = emgd_crtc->igd_pipe->owner;
+
+    emgd_cursor = emgd_crtc->igd_pipe->cursor->cursor_info;
+	emgd_cursor->x_offset = x;
+	emgd_cursor->y_offset = y;
+	context->dispatch.alter_cursor_pos(display, emgd_cursor);
+
+	/* Too spammy; commenting out */
+#if 0
+	EMGD_TRACE_EXIT;
+#endif
+	return 0;
+}
+
+static void emgd_crtc_gamma_set(struct drm_crtc *crtc,
+		unsigned short *red, unsigned short *green, unsigned short *blue,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+		uint32_t start,
+#endif
+		uint32_t size)
+{
+	int end, i;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
+	int start = 0;
+#endif
+	emgd_crtc_t *emgd_crtc = NULL;
+
+	EMGD_TRACE_ENTER;
+
+	end = (start + size > 256) ? 256 : start + size;
+	emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+
+	for (i=start; i < end; i++) {
+		emgd_crtc->lut_r[i] = red[i] >> 8;
+		emgd_crtc->lut_g[i] = green[i] >> 8;
+		emgd_crtc->lut_b[i] = blue[i] >> 8;
+	}
+
+	emgd_crtc_load_lut(crtc);
+
+	EMGD_TRACE_EXIT;
+}
+
+static void emgd_crtc_destroy(struct drm_crtc *crtc)
+{
+	emgd_crtc_t *emgd_crtc = NULL;
+	igd_context_t *context = NULL;
+	igd_display_pipe_t *igd_pipe = NULL;
+
+	EMGD_TRACE_ENTER;
+
+	emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+	igd_pipe = emgd_crtc->igd_pipe;
+	if (!igd_pipe) {
+		EMGD_ERROR("\t\tpipe %d is not available", emgd_crtc->crtc_id);
+		return;
+	}
+	context = ((drm_emgd_priv_t *)crtc->dev->dev_private)->context;
+
+	EMGD_DEBUG("\t\tpipe=%d", emgd_crtc->crtc_id);
+
+	drm_crtc_cleanup(crtc);
+
+	/* Free our private crtc structure */
+	kfree(emgd_crtc);
+
+	igd_pipe->inuse = 0;
+	igd_pipe->plane = NULL;
+	igd_pipe->timing = NULL;
+	igd_pipe->owner = NULL;
+
+	EMGD_TRACE_EXIT;
+}
+
+static void emgd_crtc_load_lut(struct drm_crtc *crtc)
+{
+	emgd_crtc_t *emgd_crtc = NULL;
+	igd_context_t *context = NULL;
+
+	EMGD_TRACE_ENTER;
+
+	emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+	if (!emgd_crtc->igd_pipe) {
+		EMGD_ERROR("\t\tpipe %d is not available", emgd_crtc->crtc_id);
+		return;
+	}
+	context = ((drm_emgd_priv_t *)crtc->dev->dev_private)->context;
+	EMGD_DEBUG("\t\tpipe=%d", emgd_crtc->crtc_id);
+	/* Call into hal function to set color map. */
+	context->mod_dispatch.reg_crtc_lut_set(context, emgd_crtc);
+
+	EMGD_TRACE_EXIT;
+}
+
+
+/*
+ * crtc_pageflip_handler()
+ *
+ * VBlank handler to be called when a pageflip is complete.  This will send
+ * the vblank event to userspace.
+ *
+ * State upon entry (assuming vblank_expected is set):
+ *  * newfb is non-NULL
+ *  * flip_event is non-NULL
+ *  * flip_work_queued is FALSE
+ *  * vblank_expected is TRUE (based on assumption)
+ *
+ * State upon exit (assuming entered with vblank_expected):
+ *  * newfb is NULL
+ *  * flip_event is NULL
+ *  * flip_work_queued is FALSE
+ *  * vblank_expected is FALSE
+ */
+int crtc_pageflip_handler(struct drm_device *dev, int port)
+{
+	drm_emgd_priv_t *devpriv = dev->dev_private;
+	emgd_crtc_t *emgd_crtc;
+	struct drm_pending_vblank_event *e;
+	struct timeval now;
+	igd_context_t *context = NULL;
+	int crtcnum;
+	unsigned long flags;
+
+	EMGD_TRACE_ENTER;
+
+	/*
+	 * This handler should only be executed if KMS modesetting is
+	 * enabled.  However, the device dependent mode code always hooks
+	 * this up. Abort early if KMS modesetting is disabled.
+	 */
+	if (!devpriv->kms_enabled) {
+		return 0;
+	}
+
+	context = devpriv->context;
+
+	/* Look up which CRTC that this flip is for. */
+	if (port == devpriv->primary_port_number) {
+		crtcnum = 0;
+	} else if (port == devpriv->secondary_port_number) {
+		crtcnum = 1;
+	} else {
+		return 1;
+	}
+
+	emgd_crtc = devpriv->crtcs[crtcnum];
+
+	/* Protect access to CRTC */
+	spin_lock_irqsave(&emgd_crtc->crtc_lock, flags);
+
+	/*
+	 * Were we waiting for a vblank to do flip cleanup?  If not, we
+	 * should just bail out.
+	 */
+	if (!emgd_crtc->vblank_expected) {
+		spin_unlock_irqrestore(&emgd_crtc->crtc_lock, flags);
+		return 1;
+	}
+
+	/* Sanity check: shouldn't be here if we still have flip work queued */
+	if (emgd_crtc->flip_work_queued) {
+		EMGD_ERROR("Flip vblank handler while work queued!");
+		spin_unlock_irqrestore(&emgd_crtc->crtc_lock, flags);
+		return 0;
+	}
+
+	/*
+	 * Sanity check: shouldn't be possible to get to this point without a
+	 * userspace event to send.
+	 */
+	if (!emgd_crtc->flip_event) {
+		EMGD_ERROR("Pageflip vblank handler has no userspace event");
+		spin_unlock_irqrestore(&emgd_crtc->crtc_lock, flags);
+		return 1;
+	}
+
+	/* Release vblank refcount */
+	drm_vblank_put(dev, crtcnum);
+	emgd_crtc->vblank_expected = 0;
+
+	/* Flip is now complete; send userspace event, if requested */
+	e = emgd_crtc->flip_event;
+	do_gettimeofday(&now);
+	e->event.sequence = 0;
+	e->event.tv_sec = now.tv_sec;
+	e->event.tv_usec = now.tv_usec;
+	list_add_tail(&e->base.link, &e->base.file_priv->event_list);
+	wake_up_interruptible(&e->base.file_priv->event_wait);
+
+	/*
+	 * Cleanup; not in process of switching to new FB, no outstanding
+	 * userspace event awaiting our attention.
+	 */
+	emgd_crtc->newfb = NULL;
+	emgd_crtc->flip_event = NULL;
+
+	spin_unlock_irqrestore(&emgd_crtc->crtc_lock, flags);
+
+	EMGD_TRACE_EXIT;
+	return 1;
+}
+
+
+/**
+ * emgd_flip_worker
+ *
+ * Workqueue task to schedule a flip when rendering to the new framebuffer
+ * is complete.  Should check the "cancel" flag and just give up,
+ * regardless of whether rendering is complete or not if set.
+ *
+ * State upon entry:
+ *  * newfb is non-NULL
+ *  * no constraint on flip_event
+ *  * flip_work_queued is TRUE
+ *  * vblank_expected is FALSE
+ *
+ * State upon exit:
+ *  * no constraint on newfb
+ *  * no constraint on flip_event
+ *  * no constraint on flip_work_queued
+ *  * no constraint on vblank_expected
+ */
+void emgd_flip_worker(struct work_struct *w)
+{
+	drm_emgd_priv_t *dev_priv;
+	igd_context_t *igd_context;
+	PVRSRV_KERNEL_MEM_INFO *meminfo;
+	PVRSRV_SYNC_DATA *syncdata = NULL;
+	emgd_crtc_t *crtc;
+	igd_surface_t igd_surface = { 0 };
+	unsigned long flags;
+	unsigned int crtcnum;
+	int ret;
+
+	/* Which CRTC does this work task belong to? */
+	crtc = container_of(w, emgd_crtc_t, flip_work);
+
+	/* Protect updates to the CRTC structure */
+	spin_lock_irqsave(&crtc->crtc_lock, flags);
+
+	/* Sanity check:  flip_work_queued must be TRUE */
+	if (!crtc->flip_work_queued) {
+		EMGD_ERROR("Flip worker running without being queued");
+		spin_unlock_irqrestore(&crtc->crtc_lock, flags);
+		return;
+	}
+
+	/* Sanity check:  newfb must not be NULL */
+	if (!crtc->newfb) {
+		EMGD_ERROR("No newfb in flip worker");
+		spin_unlock_irqrestore(&crtc->crtc_lock, flags);
+		return;
+	}
+
+	/*
+	 * Sanity check: we shouldn't be expecting vblank/cleanup while we're
+	 * still doing flip work (prior flips that may have scheduled a vblank
+	 * were cancelled already.
+	 */
+	if (crtc->vblank_expected) {
+		EMGD_ERROR("Expecting vblank cleanup while flip work in progress");
+		spin_unlock_irqrestore(&crtc->crtc_lock, flags);
+		return;
+	}
+
+	/*
+	 * Grab the PVR meminfo and syncinfo for the surface we're waiting for
+	 * rendering completion on.
+	 */
+	if (crtc->newfb->type == PVR_FRAMEBUFFER) {
+		meminfo = (PVRSRV_KERNEL_MEM_INFO *)crtc->newfb->pvr_meminfo;
+		syncdata = meminfo->psKernelSyncInfo->psSyncData;
+	}
+
+	/*
+	 * Have we completed all the operations that were pending when the flip
+	 * ioctl was called?  If so, proceed with issuing the actual flip.  If
+	 * we're flipping to a GMM framebuffer (i.e., the initial system fb),
+	 * then we don't need to wait for any kind of rendering).
+	 *
+	 * It seems like we should test for wraparound here, but I don't see
+	 * anywhere in PVR's code where they handle wraparound.  It's probably safe
+	 * to ignore for now since even if we perform 60 ops per second against the
+	 * framebuffer, it would still take over two years to overflow the 32-bit
+	 * unsigned int for the operation counter.
+	 */
+	if (crtc->newfb->type == GMM_FRAMEBUFFER ||
+		syncdata->ui32WriteOpsComplete >= crtc->render_complete_at)
+	{
+		dev_priv = (drm_emgd_priv_t *) crtc->base.dev->dev_private;
+		igd_context = dev_priv->context;
+		crtcnum = (crtc == dev_priv->crtcs[0]) ? 0 : 1;
+
+		/* Rendering complete; program the plane registers */
+		igd_surface.flags        = IGD_SURFACE_DISPLAY;
+		igd_surface.offset       = crtc->newfb->gtt_offset;
+		igd_surface.pitch        = crtc->newfb->base.pitch;
+		igd_surface.width        = crtc->newfb->base.width;
+		igd_surface.height       = crtc->newfb->base.height;
+		igd_surface.pixel_format = IGD_PF_ARGB32;
+
+		igd_context->dispatch.set_surface(
+			crtc->igd_pipe->owner,
+			IGD_PRIORITY_NORMAL,
+			IGD_BUFFER_DISPLAY,
+			&igd_surface,
+			NULL, /* Not used */
+			0);
+
+		/* Flip issued.  No need to requeue the work. */
+		crtc->flip_work_queued = 0;
+
+		/*
+		 * If a userspace event was requested for this flip, request vblank
+		 * interrupts if they aren't already on.
+		 */
+		if (crtc->flip_event) {
+			/* Request vblank events (or inc the refcount if they're already on) */
+			ret = drm_vblank_get(crtc->base.dev, crtcnum);
+			if (ret) {
+				EMGD_ERROR("Failed enable vblanks");
+				return;
+			}
+			crtc->vblank_expected = 1;
+		} else {
+			/*
+			 * No userspace event; the flip is complete as far as we're
+			 * concerned.  Clear the "in progress of switching to fb" field.
+			 */
+			crtc->newfb = NULL;
+		}
+
+	} else {
+		/* Rendering not complete.  Requeue the work task. */
+		schedule_work(w);
+	}
+
+	spin_unlock_irqrestore(&crtc->crtc_lock, flags);
+}
+
+
+/**
+ * emgd_crtc_page_flip
+ *
+ * Page flip ioctl handler.  The ioctl simply dispatches a workqueue task
+ * which will wait until current rendering against the new framebuffer
+ * is complete, then issue the actual flip.  This ioctl should return
+ * immediately, allowing pipelining of subsequent CPU execution with
+ * the outstanding rendering happening against this framebuffer.
+ *
+ * @param crtc  (INOUT) The pipe to put the new framebuffer on
+ * @param fb    (IN)    Framebuffer to flip to
+ * @param event (IN)    Event to signal when flip has been completed
+ *
+ * @return
+ *
+ * State upon entry:
+ *  * No constraint on newfb
+ *  * No constraint on flip_event
+ *  * No constraint on flip_work_queued
+ *  * No constraint on vblank_expected
+ *
+ * State upon exit:
+ *  * newfb is non-NULL
+ *  * no constraint on flip_event
+ *  * flip_work_queued is TRUE
+ *  * vblank_expected is FALSE
+ */
+static int emgd_crtc_page_flip(struct drm_crtc *crtc,
+                                struct drm_framebuffer *fb,
+                                struct drm_pending_vblank_event *event)
+{
+	emgd_crtc_t        *emgd_crtc;
+	emgd_framebuffer_t *emgd_fb;
+	drm_emgd_priv_t    *dev_priv;
+	igd_context_t      *igd_context;
+	unsigned int crtcnum;
+	unsigned long flags;
+	struct drm_pending_vblank_event *e;
+	struct timeval now;
+	PVRSRV_KERNEL_MEM_INFO *meminfo;
+	PVRSRV_SYNC_DATA *syncdata;
+
+	EMGD_TRACE_ENTER;
+
+	emgd_crtc   = container_of(crtc, emgd_crtc_t, base);
+	dev_priv    = (drm_emgd_priv_t *) crtc->dev->dev_private;
+	igd_context = dev_priv->context;
+	emgd_fb     = container_of(fb, emgd_framebuffer_t, base);
+	crtcnum = (emgd_crtc == dev_priv->crtcs[0]) ? 0 : 1;
+
+	/*
+	 * Protect updates to the CRTC structure. We don't want this code to
+	 * overlap with either the workqueue task or the vblank handler.
+	 */
+	spin_lock_irqsave(&emgd_crtc->crtc_lock, flags);
+
+	/*
+	 * Was there a pending userspace event for a previous flip request?  If
+	 * so, just send the completion back now.  We're essentially cancelling
+	 * the previous flip (it will never show up on the display), but we don't
+	 * want userspace to get confused by not receiving notification.  We'll
+	 * also decrement our vblank request if we'd already scheduled on for
+	 * cleanup.
+	 */
+	if ((e = emgd_crtc->flip_event) != NULL) {
+		do_gettimeofday(&now);
+		e->event.sequence = 0;
+		e->event.tv_sec = now.tv_sec;
+		e->event.tv_usec = now.tv_usec;
+		list_add_tail(&e->base.link, &e->base.file_priv->event_list);
+		wake_up_interruptible(&e->base.file_priv->event_wait);
+		emgd_crtc->flip_event = NULL;
+
+		/*
+		 * If the work task had completed and actually programmed the
+		 * registers, it had also requested a vblank callback.  Cancel
+		 * that as well since we've already taken care of the necessary
+		 * cleanup.  Note that vblanks are only requested when we actually
+		 * have a userspace event to send back.
+		 */
+		if (emgd_crtc->vblank_expected) {
+			drm_vblank_put(crtc->dev, crtcnum);
+			emgd_crtc->vblank_expected = 0;
+		}
+	}
+
+	/* Update the CRTC's "target framebuffer" field. */
+	emgd_crtc->newfb = emgd_fb;
+	emgd_crtc->flip_event = event;
+
+	/*
+	 * Set the number of rendering operations that need to complete before we
+	 * can flip to this buffer.  I.e., we don't need render to completely
+	 * quiesce, we can flip as soon as any operations that are outstanding
+	 * right now complete, even if more rendering ops get added to the pipeline
+	 * after we return.
+	 */
+	meminfo = (PVRSRV_KERNEL_MEM_INFO *)emgd_fb->pvr_meminfo;
+	syncdata = meminfo->psKernelSyncInfo->psSyncData;
+	emgd_crtc->render_complete_at = syncdata->ui32WriteOpsPending;
+
+	/*
+	 * If work is already scheduled, nothing more to do here; the
+	 * already-scheduled work will see the new values we set next time it wakes
+	 * up and will act upon them.  However if work is not scheduled, then
+	 * we need to schedule it now.
+	 */
+	if (!emgd_crtc->flip_work_queued) {
+		schedule_work(&emgd_crtc->flip_work);
+		emgd_crtc->flip_work_queued = 1;
+	}
+
+	/* Move the FB currently associated with the CRTC to the new FB */
+	crtc->fb = fb;
+
+	/* Done updating CRTC structure */
+	spin_unlock_irqrestore(&emgd_crtc->crtc_lock, flags);
+
+	EMGD_TRACE_EXIT;
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.c
index ed41166..90d256f 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: emgd_drv.c
- * $Revision: 1.125 $
+ * $Revision: 1.139 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -32,8 +32,14 @@
 
 #define MODULE_NAME hal.oal
 
+#include <drm/drmP.h>
+#include <drm/drm.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
 #include <linux/version.h>
+#include <linux/device.h>
 #include <drm/drm_pciids.h>
+#include <intelpci.h>
 #include "drm_emgd_private.h"
 #include "user_config.h"
 #include "emgd_drv.h"
@@ -53,17 +59,24 @@
 #include <linkage.h>
 #include <sysconfig.h>
 
+
+
+/*------------------------------------------------------------------------------
+ * Formal Declaration
+ *------------------------------------------------------------------------------
+ */
 extern void emgd_set_real_handle(igd_driver_h drm_handle);
 extern void emgd_set_real_dispatch(igd_dispatch_t *drm_dispatch);
-extern void emgd_ms_init(struct drm_device *dev);
-extern int msvdx_pre_init_plb(struct drm_device *dev);
+extern void emgd_modeset_init(struct drm_device *dev);
+extern void emgd_modeset_destroy(struct drm_device *dev);
+extern int  msvdx_pre_init_plb(struct drm_device *dev);
 extern emgd_drm_config_t config_drm;
 
 /* This must be defined whether debug or release build */
 igd_debug_t emgd_debug_flag = {
-        {
-                CONFIG_DEBUG_FLAGS
-        }
+	{
+		CONFIG_DEBUG_FLAGS
+	}
 };
 igd_debug_t *emgd_debug = &emgd_debug_flag;
 
@@ -144,6 +157,8 @@ module_param_named(debug_dump_shaders, emgd_debug_flag.hal.dump_shaders, short,
 #endif
 
 
+static struct drm_driver driver;  /* TODO: what? */
+
 /* Note: The following module paramter values are advertised to the root user,
  * via the files in the /sys/module/emgd/parameters directory (e.g. the "init"
  * file contains the value of the "init" module parameter), and so we keep
@@ -192,12 +207,12 @@ unsigned x_started = false;
 /**
  * The primary fb_info to use when the DRM module [re-]initializes the display.
  */
-igd_framebuffer_info_t primary_fb_info;
+igd_framebuffer_info_t *primary_fb_info;
 /**
  * The secondary fb_info to use when the DRM module [re-]initializes the
  * display.
  */
-igd_framebuffer_info_t secondary_fb_info;
+igd_framebuffer_info_t *secondary_fb_info;
 /**
  * The primary display structure (filled in by alter_displays()) to use when
  * the DRM module [re-]initializes the display.
@@ -241,50 +256,63 @@ static struct pci_device_id pciidlist[] = {
 		{.cmd = ioctl, .func = _func, .flags = _flags}
 
 static struct drm_ioctl_desc emgd_ioctl[] = {
-	/* NOTE: The "DRM_ROOT_ONLY" flag value (last parameter) below indicates
-	 * that the ioctl will only work for "root" (super-user) processes (e.g. X
-	 * server).  We don't use the other flag values, because we only want these
-	 * ioctls to be used by the X driver code, running within the X server.
+	/*
+	 * NOTE: The flag "DRM_MASTER" for the final parameter indicates an ioctl
+	 * can only be used by the DRM master process.  In an X environment, the
+	 * X server will be the master, in a Wayland environment, the Wayland
+	 * compositor will be master, and if just running standalone GBM apps,
+	 * they'll gain master.  For ioctl's that we want to run from an X
+	 * client app or a Wayland client app, we instead use DRM_AUTH; these
+	 * clients will get the DRM master to authenticate them, after which
+	 * they'll be able to call the ioctl's.  Random programs that haven't
+	 * authenticated with the DRM master won't be able to call them.
 	 */
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ALTER_CURSOR, emgd_alter_cursor,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ALTER_CURSOR_POS, emgd_alter_cursor_pos,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ALTER_DISPLAYS, emgd_alter_displays,
-		DRM_ROOT_ONLY),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ALTER_OVL, emgd_alter_ovl, DRM_ROOT_ONLY),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ALTER_OVL2, emgd_alter_ovl2, DRM_ROOT_ONLY),
+		DRM_MASTER),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ALTER_OVL, emgd_alter_ovl, DRM_MASTER),
+	/* Making DRM_IOCTL_IGD_ALTER_OVL2 DRM_AUTH so that libva wayland can
+	 * call alter_ovl without going through X server.
+	 */
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ALTER_OVL2, emgd_alter_ovl2, DRM_AUTH),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_APPCTX_ALLOC, emgd_appcontext_alloc,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_APPCTX_FREE, emgd_appcontext_free,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_DRIVER_SAVE_RESTORE, emgd_driver_save_restore,
-		DRM_ROOT_ONLY),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ENABLE_PORT, emgd_enable_port, DRM_ROOT_ONLY),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_ATTRS, emgd_get_attrs, DRM_ROOT_ONLY),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_DISPLAY, emgd_get_display, DRM_ROOT_ONLY),
+		DRM_MASTER),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_ENABLE_PORT, emgd_enable_port, DRM_MASTER),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_ATTRS, emgd_get_attrs, DRM_MASTER),
+	/* Making DRM_IOCTL_IGD_GET_DISPLAY DRM_AUTH so that libva wayland can
+	 * obtain the display handle without going through x server.
+	 */
+    EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_DISPLAY, emgd_get_display, DRM_AUTH),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_DRM_CONFIG, emgd_get_drm_config,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_EDID_BLOCK, emgd_get_EDID_block,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_EDID_INFO, emgd_get_EDID_info,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_PIXELFORMATS, emgd_get_pixelformats,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_PORT_INFO, emgd_get_port_info,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GMM_ALLOC_REGION, emgd_gmm_alloc_region,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GMM_ALLOC_SURFACE, emgd_gmm_alloc_surface,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GMM_GET_NUM_SURFACE, emgd_gmm_get_num_surface,
-		DRM_ROOT_ONLY),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GMM_GET_SURFACE_LIST, emgd_gmm_get_surface_list,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GMM_GET_SURFACE_LIST,
+		emgd_gmm_get_surface_list,
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GMM_FREE, emgd_gmm_free,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GMM_FLUSH_CACHE, emgd_gmm_flush_cache,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	/*
 	 * Externally handled IOCTL's. These are routed to the Imagination Tech
 	 * kernel services.
@@ -297,19 +325,25 @@ static struct drm_ioctl_desc emgd_ioctl[] = {
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_RESERVED_5, PVRDRMUnprivCmd, 0),
 
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_PAN_DISPLAY, emgd_pan_display,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_POWER_DISPLAY, emgd_power_display,
-		DRM_ROOT_ONLY),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_PWR_ALTER, emgd_pwr_alter, DRM_ROOT_ONLY),
+		DRM_MASTER),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_PWR_ALTER, emgd_pwr_alter, DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_QUERY_DC, emgd_query_dc,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_QUERY_MAX_SIZE_OVL, emgd_query_max_size_ovl,
-		DRM_ROOT_ONLY),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_QUERY_OVL, emgd_query_ovl, DRM_ROOT_ONLY),
+		DRM_MASTER),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_QUERY_OVL, emgd_query_ovl, DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_QUERY_MODE_LIST, emgd_query_mode_list,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_GOLDEN_HTOTAL, emgd_get_golden_htotal,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_CONTROL_PLANE_FORMAT, emgd_control_plane_format,
+		DRM_MASTER),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_SET_OVERLAY_DISPLAY, emgd_set_overlay_display,
+		DRM_MASTER),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_QUERY_2D_CAPS_HWHINT, emgd_query_2d_caps_hwhint,
+		DRM_MASTER),
 	/*
 	 * For PDUMP
 	 */
@@ -318,26 +352,26 @@ static struct drm_ioctl_desc emgd_ioctl[] = {
 #else
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_RESERVED_6, NULL, 0),
 #endif
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_SET_ATTRS, emgd_set_attrs, DRM_ROOT_ONLY),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_SET_ATTRS, emgd_set_attrs, DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_SET_PALETTE_ENTRY, emgd_set_palette_entry,
-		DRM_ROOT_ONLY),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_SET_SURFACE, emgd_set_surface, DRM_ROOT_ONLY),
-	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_SYNC, emgd_sync, DRM_ROOT_ONLY),
+		DRM_MASTER),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_SET_SURFACE, emgd_set_surface, DRM_MASTER),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_SYNC, emgd_sync, DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_DRIVER_PRE_INIT, emgd_driver_pre_init,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_DRIVER_GET_PORTS, emgd_driver_get_ports,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_OVL_INIT_PARAMS, emgd_get_ovl_init_params,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_PAGE_LIST, emgd_get_page_list,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_START_PVRSRV, emgd_start_pvrsrv,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_TEST_PVRSRV, emgd_test_pvrsrv,
-		DRM_ROOT_ONLY),
+		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_CHIPSET_INFO, emgd_get_chipset_info,
-		DRM_ROOT_ONLY),
-
+		DRM_MASTER),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_DIHCLONE_SET_SURFACE, emgd_dihclone_set_surface, DRM_MASTER),
 
 	/*
 	 * For VIDEO (MSVDX/TOPAZ
@@ -470,7 +504,8 @@ void emgd_print_params(igd_param_t *params)
 	for (i = 0 ; i < IGD_MAX_PORTS; i++) {
 		int j;
 
-		EMGD_DEBUG("  port_number = %lu", params->display_params[i].port_number);
+		EMGD_DEBUG("  port_number = %lu",
+			params->display_params[i].port_number);
 		EMGD_DEBUG("   present_params = %lu = 0x%lx",
 			params->display_params[i].present_params,
 			params->display_params[i].present_params);
@@ -588,7 +623,7 @@ void emgd_print_params(igd_param_t *params)
  */
 int emgd_startup_hal(struct drm_device *dev, igd_param_t *params)
 {
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
 	int err = 0;
 
 	EMGD_TRACE_ENTER;
@@ -596,6 +631,7 @@ int emgd_startup_hal(struct drm_device *dev, igd_param_t *params)
 
 	/* Initialize the various HAL modules: */
 	EMGD_DEBUG("Calling igd_module_init()");
+
 	err = igd_module_init(drm_HAL_handle, &drm_HAL_dispatch, params);
 	if (err != 0) {
 		return -EIO;
@@ -604,23 +640,16 @@ int emgd_startup_hal(struct drm_device *dev, igd_param_t *params)
 	/* Give the dispatch table to the ioctl-handling "bridge" code: */
 	emgd_set_real_dispatch(drm_HAL_dispatch);
 
-	/* Hook up the drm framebuffer */
-	EMGD_DEBUG("Calling emgd_ms_init()");
-	emgd_ms_init(dev);
-
 	/* Record that the HAL is running now: */
 	priv->hal_running = 1;
 	/* Record that the console's state is saved: */
 	priv->saved_registers = CONSOLE_STATE_SAVED;
 
-	if (priv->pvrsrv_started) {
-		/* Since PVR services is running, we're restarting the HAL, which
-		 * disabled the SGX & MSVDX interrupts.  Need to re-enable those
-		 * interrupts:
-		 */
-		SysReEnableInterrupts();
-	}
-
+	/* Since PVR services is running, we're restarting the HAL, which
+	 * disabled the SGX & MSVDX interrupts.  Need to re-enable those
+	 * interrupts:
+	 */
+	SysReEnableInterrupts();
 
 	EMGD_TRACE_EXIT;
 
@@ -628,6 +657,7 @@ int emgd_startup_hal(struct drm_device *dev, igd_param_t *params)
 } /* emgd_startup_hal() */
 
 
+
 /**
  * A helper function that initializes the display, and potentially merges the
  * module parameters with the pre-compiled parameters.
@@ -636,119 +666,95 @@ int emgd_startup_hal(struct drm_device *dev, igd_param_t *params)
  * merged with the pre-compiled parameters.
  *
  */
-void emgd_init_display(int merge_mod_params)
+void emgd_init_display(int merge_mod_params, drm_emgd_priv_t *priv)
 {
-	int err = 0;
-	igd_display_info_t *mode_list = NULL;
-	igd_display_info_t *mode = NULL;
-	int mode_flags = IGD_QUERY_LIVE_MODES;
-	unsigned char *fb;
-	unsigned long temp_bg_color;
+	int                     err         = 0;
+	igd_display_info_t     *mode_list   = NULL;
+	igd_display_info_t     *mode        = NULL;
+	struct drm_framebuffer *framebuffer = NULL;
+	emgd_framebuffer_t     *emgd_fb     = NULL;
+	unsigned char          *fb          = NULL;
+	int                     mode_flags = IGD_QUERY_LIVE_MODES;
+	unsigned long           temp_bg_color;
 
 	EMGD_TRACE_ENTER;
 
 
 	if (merge_mod_params) {
 		EMGD_DEBUG("Checking other module parameters before initializing the "
-			"display");
+				"display");
 
 		/*************************************
 		 * Get the desired display display config:
 		 *************************************/
 		if (-1 != drm_emgd_dc) {
 			/* Validate and potentially use the module parameter: */
-			EMGD_DEBUG("Value of module parameter \"dc\" = \"%d\"", drm_emgd_dc);
+			EMGD_DEBUG("Value of module parameter \"dc\" = \"%d\"",
+				drm_emgd_dc);
+
 			if ((drm_emgd_dc == 1) || (drm_emgd_dc == 2) ||
-				(drm_emgd_dc == 8)) {
+					(drm_emgd_dc == 8)) {
 				/* Use validated value to override compile-time value: */
 				config_drm.dc = drm_emgd_dc;
 			} else if (drm_emgd_dc == 4) {
 				/* Use validated value to override compile-time value: */
 				EMGD_DEBUG("Module parameter \"dc\" contains unsupported value "
-					"%d.", drm_emgd_dc);
+						"%d.", drm_emgd_dc);
 				EMGD_DEBUG("Overriding and making it 1 (single display).");
 				drm_emgd_dc = 1;
 				config_drm.dc = drm_emgd_dc;
 			} else {
 				/* Use compile-time value: */
 				EMGD_ERROR("Module parameter \"dc\" contains invalid value "
-					"%d (must be 1, 2, or 8).", drm_emgd_dc);
+						"%d (must be 1, 2, or 8).", drm_emgd_dc);
 				if (config_drm.dc == 4) {
 					EMGD_DEBUG("Compile-time setting for module parameter "
-						"\"dc\" contains unsupported value %d.", config_drm.dc);
+						"\"dc\" contains unsupported value %d.",
+						config_drm.dc);
 					EMGD_DEBUG("Overriding and making it 1 (single display).");
+
 					config_drm.dc = 1;
 				} else {
 					EMGD_ERROR("Will use compile-time setting %d instead "
-						"of invalid value %d.\n", config_drm.dc, drm_emgd_dc);
+							"of invalid value %d.\n",
+							config_drm.dc, drm_emgd_dc);
 				}
 				drm_emgd_dc = config_drm.dc;
 			}
 		} else {
 			/* Check and potentially use the compile-time value: */
 			if ((config_drm.dc == 1) || (config_drm.dc == 2) ||
-				(config_drm.dc == 8)) {
+					(config_drm.dc == 8)) {
 				/* Report the compile-time value: */
-				EMGD_DEBUG("Using compile-time setting for the module parameter "
-					"\"dc\" = \"%d\"", config_drm.dc);
+				EMGD_DEBUG("Using compile-time setting for the module parameter"
+						" \"dc\" = \"%d\"", config_drm.dc);
 			} else if (config_drm.dc == 4) {
 				EMGD_DEBUG("Compile-time setting for module parameter "
-					"\"dc\" contains unsupported value %d.", config_drm.dc);
+						"\"dc\" contains unsupported value %d.", config_drm.dc);
 				EMGD_DEBUG("Overriding and making it 1 (single display).");
 				config_drm.dc = 1;
 			} else {
 				EMGD_DEBUG("Compile-time setting for module parameter "
-					"\"dc\" contains invalid value %d.", config_drm.dc);
-				EMGD_DEBUG("Must be 1, 2, or 8.  Making it 1 (single display).");
+						"\"dc\" contains invalid value %d.", config_drm.dc);
+				EMGD_DEBUG("Must be 1, 2, or 8. Making it 1 (single display).");
 				config_drm.dc = 1;
 			}
 			drm_emgd_dc = config_drm.dc;
 		}
-	}
-
-	/*************************************
-	 * Query the DC list (use first one):
-	 *************************************/
-	EMGD_DEBUG("Calling query_dc()");
-	err = drm_HAL_dispatch->query_dc(drm_HAL_handle, drm_emgd_dc,
-		&desired_dc, IGD_QUERY_DC_INIT);
-	EMGD_DEBUG("query_dc() returned %d", err);
-	if (err) {
-		EMGD_ERROR_EXIT("Cannot initialize the display as requested.\n"
-			"The query_dc() function returned %d.", err);
-		return;
-	}
-	port_number = (*desired_dc & 0xf0) >> 4;
-	EMGD_DEBUG("Using DC 0x%lx with port number %d",
-		*desired_dc, port_number);
-
-	/*************************************
-	 * Query the mode list:
-	 *************************************/
-	EMGD_DEBUG("Calling query_mode_list()");
-	err = drm_HAL_dispatch->query_mode_list(drm_HAL_handle, *desired_dc,
-		&mode_list, mode_flags);
-	EMGD_DEBUG("query_mode_list() returned %d", err);
-	if (err) {
-		EMGD_ERROR_EXIT("Cannot initialize the display as requested\n"
-			"The query_mode_list() function returned %d.", err);
-		return;
-	}
 
-	if (merge_mod_params) {
 		/*************************************
 		 * Get the desired display "width":
 		 *************************************/
 		if (-1 != drm_emgd_width) {
 			/* Override the compile-time value with the module parameter: */
 			EMGD_DEBUG("Using the \"width\" module parameter: \"%d\"",
-				drm_emgd_width);
+					drm_emgd_width);
 			config_drm.width = drm_emgd_width;
 		} else {
 			/* Use the compile-time value: */
 			drm_emgd_width = config_drm.width;
 			EMGD_DEBUG("Using the compile-time \"width\" value: \"%d\"",
-				drm_emgd_width);
+					drm_emgd_width);
 		}
 
 		/*************************************
@@ -757,13 +763,13 @@ void emgd_init_display(int merge_mod_params)
 		if (-1 != drm_emgd_height) {
 			/* Override the compile-time value with the module parameter: */
 			EMGD_DEBUG("Using the \"height\" module parameter: \"%d\"",
-				drm_emgd_height);
+					drm_emgd_height);
 			config_drm.height = drm_emgd_height;
 		} else {
 			/* Use the compile-time value: */
 			drm_emgd_height = config_drm.height;
 			EMGD_DEBUG("Using the compile-time \"height\" value: \"%d\"",
-				drm_emgd_height);
+					drm_emgd_height);
 		}
 
 		/*************************************
@@ -772,123 +778,221 @@ void emgd_init_display(int merge_mod_params)
 		if (-1 != drm_emgd_refresh) {
 			/* Override the compile-time value with the module parameter: */
 			EMGD_DEBUG("Using the \"refresh\" module parameter: \"%d\"",
-				drm_emgd_refresh);
+					drm_emgd_refresh);
 			config_drm.refresh = drm_emgd_refresh;
 		} else {
 			/* Use the compile-time value: */
 			drm_emgd_refresh = config_drm.refresh;
 			EMGD_DEBUG("Using the compile-time \"refresh\" value: \"%d\"",
-				drm_emgd_refresh);
+					drm_emgd_refresh);
 		}
 	}
 
-	/*************************************
-	 * Find the desired mode from the list:
-	 *************************************/
-	EMGD_DEBUG("Comparing the mode list with the desired width, height, and "
-		"refresh rate...");
-	mode = mode_list;
-	while (mode && (mode->width != IGD_TIMING_TABLE_END)) {
-		EMGD_DEBUG(" ... Found a mode with width=%d, height=%d, refresh=%d;",
-			mode->width, mode->height, mode->refresh);
-		if ((mode->width == drm_emgd_width) &&
-			(mode->height == drm_emgd_height) &&
-			(mode->refresh == drm_emgd_refresh)) {
-			EMGD_DEBUG("     ... This mode is a match!");
-			desired_mode = mode;
-			break;
+
+	if (config_drm.kms) {
+		priv->num_crtc = 2;
+
+
+		/*************************************
+		 * Initialize kernel mode setting functionality
+		 *************************************/
+		emgd_modeset_init(priv->ddev);
+
+		/* Get Display context */
+		drm_HAL_context->mod_dispatch.dsp_get_dc(NULL,
+							(igd_display_context_t **) &primary,
+							(igd_display_context_t **) &secondary);
+
+
+		/*************************************
+		 * Initialize primary_fb_info
+		 *************************************/
+		framebuffer = list_entry(priv->ddev->mode_config.fb_list.next,
+				struct drm_framebuffer, head);
+		if (!framebuffer) {
+			EMGD_ERROR("Can't display splash screen/video as there is no fb.");
+		} else {
+			emgd_fb = container_of(framebuffer, emgd_framebuffer_t, base);
+			primary_fb_info = &priv->initfb_info;
+			if (priv->fbdev) {
+				fb = priv->fbdev->screen_base;
+			}
 		}
-		mode++;
-	}
-	if (NULL == desired_mode) {
-		EMGD_ERROR("Cannot initialize the display as requested.");
-		EMGD_ERROR("No mode matching the desired width (%d), height "
-			"(%d), and refresh rate (%d) was found.",
-			drm_emgd_width, drm_emgd_height, drm_emgd_refresh);
-		return;
+
+
+		/*
+		 * Update the private data structure
+		 */
+		priv->primary               = primary;
+		priv->secondary             = secondary;
+		priv->primary_port_number   = IGD_DC_PRIMARY(priv->dc);
+		priv->secondary_port_number = IGD_DC_SECONDARY(priv->dc);
 	} else {
-		/* Must set this in order to get the timings setup: */
-		desired_mode->flags |= IGD_DISPLAY_ENABLE;
-	}
 
-	/*************************************
-	 * Call alter_displays():
-	 *************************************/
-	primary_fb_info.width = desired_mode->width;
-	primary_fb_info.height = desired_mode->height;
-	primary_fb_info.pixel_format = IGD_PF_ARGB32;
-	primary_fb_info.flags = 0;
-	primary_fb_info.allocated = 0;
-	memcpy(&secondary_fb_info, &primary_fb_info,
-		sizeof(igd_framebuffer_info_t));
-
-	EMGD_DEBUG("Calling alter_displays()");
-	err = drm_HAL_dispatch->alter_displays(drm_HAL_handle,
-		&primary, desired_mode, &primary_fb_info,
-		&secondary, desired_mode, &secondary_fb_info,
-		*desired_dc, 0);
-	EMGD_DEBUG("alter_displays() returned %d", err);
-	if (err) {
-		EMGD_ERROR_EXIT("Cannot initialize the display as requested.\n"
-			"The alter_displays() function returned %d.", err);
-		return;
-	}
+		/*************************************
+		 * Query the DC list (use first one):
+		 *************************************/
+		EMGD_DEBUG("Calling query_dc()");
+		err = drm_HAL_dispatch->query_dc(drm_HAL_handle, drm_emgd_dc,
+				&desired_dc, IGD_QUERY_DC_INIT);
+		EMGD_DEBUG("query_dc() returned %d", err);
+		if (err) {
+			EMGD_ERROR_EXIT("Cannot initialize the display as requested.\n"
+					"The query_dc() function returned %d.", err);
+			return;
+		}
+		port_number = (*desired_dc & 0xf0) >> 4;
+		EMGD_DEBUG("Using DC 0x%lx with port number %d",
+				*desired_dc, port_number);
 
-	/*************************************
-	 * Call get_display():
-	 *************************************/
-	EMGD_DEBUG("Calling get_display()");
-	err = drm_HAL_dispatch->get_display(primary, port_number,
-		&primary_fb_info, &pt_info, 0);
-	EMGD_DEBUG("get_display() returned %d", err);
-	if (err) {
-		EMGD_ERROR_EXIT("Cannot initialize the display as requested\n"
-			"The get_display() function returned %d.", err);
-		return;
-	}
+		/*************************************
+		 * Query the mode list:
+		 *************************************/
+		EMGD_DEBUG("Calling query_mode_list()");
+		err = drm_HAL_dispatch->query_mode_list(drm_HAL_handle, *desired_dc,
+				&mode_list, mode_flags);
+		EMGD_DEBUG("query_mode_list() returned %d", err);
+		if (err) {
+			EMGD_ERROR_EXIT("Cannot initialize the display as requested\n"
+					"The query_mode_list() function returned %d.", err);
+			return;
+		}
 
-	/*************************************
-	 * Set the framebuffer to the background color:
-	 *************************************/
-	EMGD_DEBUG("Calling full_clear_fb()");
-	fb = mode_context->context->dispatch.gmm_map(
-			primary_fb_info.fb_base_offset);
-	temp_bg_color = mode_context->display_color;
-	mode_context->display_color = config_drm.ss_data->bg_color;
-	full_clear_fb(mode_context, &primary_fb_info, fb);
-	mode_context->display_color = temp_bg_color;
 
-	/*************************************
-	 * Display a splash screen if requested by user
-	 *************************************/
-	if(config_drm.ss_data->width &&
-			config_drm.ss_data->height) {
+		/*************************************
+		 * Find the desired mode from the list:
+		 *************************************/
+		EMGD_DEBUG("Comparing the mode list with the desired width, height, and"
+			" refresh rate...");
+
+		mode = mode_list;
+		while (mode && (mode->width != IGD_TIMING_TABLE_END)) {
+			EMGD_DEBUG(" ...Found a mode with width=%d, height=%d, refresh=%d;",
+					mode->width, mode->height, mode->refresh);
+			if ((mode->width == drm_emgd_width) &&
+					(mode->height == drm_emgd_height) &&
+					(mode->refresh == drm_emgd_refresh)) {
+				EMGD_DEBUG("     ... This mode is a match!");
+				desired_mode = mode;
+				break;
+			}
+			mode++;
+		}
+		if (NULL == desired_mode) {
+			EMGD_ERROR("Cannot initialize the display as requested.");
+			EMGD_ERROR("No mode matching the desired width (%d), height "
+					"(%d), and refresh rate (%d) was found.",
+					drm_emgd_width, drm_emgd_height, drm_emgd_refresh);
+			return;
+		} else {
+			/* Must set this in order to get the timings setup: */
+			desired_mode->flags |= IGD_DISPLAY_ENABLE;
+		}
+
+		/*************************************
+		 * Call alter_displays():
+		 *************************************/
+		primary_fb_info   = kzalloc(sizeof(igd_framebuffer_info_t), GFP_KERNEL);
+		secondary_fb_info = kzalloc(sizeof(igd_framebuffer_info_t), GFP_KERNEL);
+		primary_fb_info->width = desired_mode->width;
+		primary_fb_info->height = desired_mode->height;
+		primary_fb_info->pixel_format = IGD_PF_ARGB32;
+		primary_fb_info->flags = 0;
+		primary_fb_info->allocated = 0;
+		memcpy(secondary_fb_info, primary_fb_info,
+				sizeof(igd_framebuffer_info_t));
+
+		EMGD_DEBUG("Calling alter_displays()");
+		err = drm_HAL_dispatch->alter_displays(drm_HAL_handle,
+				&primary, desired_mode, primary_fb_info,
+				&secondary, desired_mode, secondary_fb_info,
+				*desired_dc, 0);
+		EMGD_DEBUG("alter_displays() returned %d", err);
+		if (err) {
+			EMGD_ERROR_EXIT("Cannot initialize the display as requested.\n"
+					"The alter_displays() function returned %d.", err);
+			return;
+		}
+
+		/*
+		 * Update the private data structure with the values we get
+		 * back from alter displays.
+		 */
+		priv->dc                    = *desired_dc;
+		priv->primary               = primary;
+		priv->secondary             = secondary;
+		priv->primary_port_number   = IGD_DC_PRIMARY(*desired_dc);
+		priv->secondary_port_number = IGD_DC_SECONDARY(*desired_dc);
 
-		/* Display a splash screen */
-		EMGD_DEBUG("Calling disp_splash_screen()");
-		display_splash_screen(&primary_fb_info, fb, config_drm.ss_data);
+		/*************************************
+		 * Call get_display():
+		 *************************************/
+		EMGD_DEBUG("Calling get_display()");
+		err = drm_HAL_dispatch->get_display(primary, port_number,
+				primary_fb_info, &pt_info, 0);
+		EMGD_DEBUG("get_display() returned %d", err);
+		if (err) {
+			EMGD_ERROR_EXIT("Cannot initialize the display as requested\n"
+					"The get_display() function returned %d.", err);
+			return;
+		}
+
+		/*************************************
+		 * Get FB virtual address
+		 *************************************/
+		EMGD_DEBUG("Calling full_clear_fb()");
+		fb = mode_context->context->dispatch.gmm_map(
+				primary_fb_info->fb_base_offset);
 	}
 
-	/*************************************
-	 * Display a splash video if requested by user
-	 *************************************/
-	if(config_drm.sv_data->pixel_format &&
-			config_drm.sv_data->src_width &&
-			config_drm.sv_data->src_height &&
-			config_drm.sv_data->src_pitch &&
-			config_drm.sv_data->dst_width &&
-			config_drm.sv_data->dst_height) {
-
-		/* Display a splash video */
-		EMGD_DEBUG("Calling disp_splash_video()");
-		disp_splash_video(config_drm.sv_data);
+	if (fb) {
+
+		/*************************************
+		 * Set the framebuffer to the background color:
+		 *************************************/
+		temp_bg_color = mode_context->display_color;
+		mode_context->display_color = config_drm.ss_data->bg_color;
+		full_clear_fb(mode_context, primary_fb_info, fb);
+		mode_context->display_color = temp_bg_color;
+
+		/*************************************
+		 * Display a splash screen if requested by user
+		 *************************************/
+		if(config_drm.ss_data->width &&
+				config_drm.ss_data->height) {
+
+			/* Display a splash screen */
+			printk(KERN_ERR "[EMGD] Display splash screen image.\n");
+			EMGD_DEBUG("Calling disp_splash_screen()");
+			display_splash_screen(primary_fb_info, fb, config_drm.ss_data);
+		}
+
+		/*************************************
+		 * Display a splash video if requested by user
+		 *************************************/
+		if(config_drm.sv_data->pixel_format &&
+				config_drm.sv_data->src_width &&
+				config_drm.sv_data->src_height &&
+				config_drm.sv_data->src_pitch &&
+				config_drm.sv_data->dst_width &&
+				config_drm.sv_data->dst_height) {
+
+			/* Display a splash video */
+			EMGD_DEBUG("Calling disp_splash_video()");
+			disp_splash_video(config_drm.sv_data);
+		}
+	} else {
+		EMGD_ERROR("framebuffer base address is 0");
 	}
-	mode_context->context->dispatch.gmm_unmap(fb);
 
+	if (!config_drm.kms) {
+		mode_context->context->dispatch.gmm_unmap(fb);
+	}
 	EMGD_TRACE_EXIT;
 } /* emgd_init_display() */
 
 
+
 /**
  * Function to display a splash video to the user. The splash video data must be
  * provided to the kernel mode driver by another entity (like a driver or FPGA
@@ -975,6 +1079,8 @@ int disp_splash_video(emgd_drm_splash_video_t *sv_data)
 	return 0;
 }
 
+
+
 /**
  * This is the drm_driver.load() function.  It is called when the DRM "loads"
  * (i.e. when our driver loads, it calls drm_init(), which eventually causes
@@ -991,7 +1097,7 @@ int emgd_driver_load(struct drm_device *dev, unsigned long flags)
 {
 	int i, err = 0;
 	igd_param_t *params;
-	drm_emgd_private *priv = NULL;
+	drm_emgd_priv_t *priv = NULL;
 	igd_init_info_t *init_info;
 	int num_hal_params =
 		sizeof(config_drm.hal_params) / sizeof(config_drm.hal_params[0]);
@@ -1141,17 +1247,22 @@ int emgd_driver_load(struct drm_device *dev, unsigned long flags)
 	/* Create the private structure used to communicate to the IMG 3rd-party
 	 * display driver:
 	 */
-	priv = OS_ALLOC(sizeof(drm_emgd_private));
+	priv = OS_ALLOC(sizeof(drm_emgd_priv_t));
 	if (NULL == priv) {
 		OS_FREE(init_info);
 		mutex_unlock(&dev->struct_mutex);
 		return -ENOMEM;
 	}
-	OS_MEMSET(priv, 0, sizeof(drm_emgd_private));
+
+
+	OS_MEMSET(priv, 0, sizeof(drm_emgd_priv_t));
 	priv->hal_running = 0;
-	priv->context = drm_HAL_context;
-	priv->init_info = init_info;
-	dev->dev_private = priv;
+	priv->context     = drm_HAL_context;
+	priv->init_info   = init_info;
+	priv->qb_seamless = params->qb_seamless;
+	dev->dev_private  = priv;
+	priv->ddev        = dev;
+	priv->kms_enabled = 0;
 
 
 	/* Do basic driver initialization & configuration: */
@@ -1165,10 +1276,24 @@ int emgd_driver_load(struct drm_device *dev, unsigned long flags)
 		return -EIO;
 	}
 
+	// PVRSRVDrmLoad() sets up an ISR routine with a pointer to drm_device to be passed every time.  This variable (gpDrmDevice) is initialized in msvdx_pre_init_plb only.
+	// Due to this reason, msvdx_pre_init_plb() is moved before PVRSRVDrmLoad().
+
+	/* Init MSVDX and load firmware */
+	msvdx_pre_init_plb(dev);
 
+	/* Initialize the PVR services if not already initialized */
+	printk(KERN_INFO "Initializing PVR Services.\n");
+	PVRSRVDrmLoad(dev, 0);
 
 	/* Decide if we can defer the rest of the initialization */
-	if (drm_emgd_init) {
+	if (config_drm.init) {
+
+		if (config_drm.kms) {
+			params->preserve_regs = 1;
+			priv->kms_enabled = 1;
+		}
+
 		/* Initialize and configure the driver now */
 		err = emgd_startup_hal(dev, params);
 		if (err != 0) {
@@ -1178,20 +1303,27 @@ int emgd_driver_load(struct drm_device *dev, unsigned long flags)
 			mutex_unlock(&dev->struct_mutex);
 			return err;
 		}
+
+		/* This will get the plane, pipe and port register values and fill up the
+		 * fw_info data structure. This needs to be done at INIT time before the
+		 * user-mode driver loads
+		 */
+		get_pre_driver_info(mode_context);
+
 		/* Per the user's request, initialize the display: */
-		emgd_init_display(TRUE);
+		emgd_init_display(TRUE, priv);
 	}
 
 
-	/* This will get the plane, pipe and port register values and fill up the
-	 * fw_info data structure. This needs to be done at INIT time before the
-	 * user-mode driver loads
-	 */
-	get_pre_driver_info(mode_context);
-
 
-    /* Init MSVDX and load firmware */
-    msvdx_pre_init_plb(dev);
+#ifdef DEBUG_BUILD_TYPE
+	/* Turn on KMS debug messages in the general DRM module if our OAL
+	 * messages are on and it's a debug driver.
+	 */
+	if (emgd_debug->hal.oal) {
+		drm_debug |= DRM_UT_KMS;
+	}
+#endif
 
 	mutex_unlock(&dev->struct_mutex);
 	EMGD_TRACE_EXIT;
@@ -1212,15 +1344,18 @@ int emgd_driver_load(struct drm_device *dev, unsigned long flags)
  */
 int emgd_driver_unload(struct drm_device *dev)
 {
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
+	unsigned long save_flags = 0;
 
 	EMGD_TRACE_ENTER;
 
 	mutex_lock(&dev->struct_mutex);
 
-	if (priv->pvrsrv_started) {
-		PVRSRVDrmUnload(dev);
-		priv->pvrsrv_started = 0;
+	PVRSRVDrmUnload(dev);
+
+	/* KMS cleanup */
+	if (config_drm.init && config_drm.kms) {
+		emgd_modeset_destroy(dev);
 	}
 
 	if (priv->hal_running) {
@@ -1234,11 +1369,13 @@ int emgd_driver_unload(struct drm_device *dev)
 		 * save_restore now, so that this state will still exist after
 		 * igd_driver_shutdown().
 		 */
-		if (priv->saved_registers == X_SERVER_STATE_SAVED) {
+		if (priv->saved_registers == CONSOLE_STATE_SAVED) {
 			EMGD_DEBUG("Need to restore the console's saved register state");
-			drm_HAL_dispatch->driver_save_restore(drm_HAL_handle);
+
+			save_flags = IGD_REG_SAVE_ALL;
+			drm_HAL_dispatch->driver_save_restore(drm_HAL_handle, save_flags);
 			EMGD_DEBUG("State of saved registers is X_SERVER_STATE_SAVED");
-			priv->saved_registers = CONSOLE_STATE_SAVED;
+			priv->saved_registers = X_SERVER_STATE_SAVED;
 		}
 		igd_driver_shutdown_hal(drm_HAL_handle);
 		igd_driver_shutdown(drm_HAL_handle);
@@ -1247,6 +1384,11 @@ int emgd_driver_unload(struct drm_device *dev)
 		igd_driver_shutdown(drm_HAL_handle);
 	}
 
+	if (!config_drm.kms) {
+		kfree(primary_fb_info);
+		kfree(secondary_fb_info);
+	}
+
 	OS_FREE(priv->init_info);
 	OS_FREE(priv);
 
@@ -1277,7 +1419,6 @@ int emgd_driver_unload(struct drm_device *dev)
 int emgd_driver_open(struct drm_device *dev, struct drm_file *priv)
 {
 	int ret = 0;
-	drm_emgd_private *emgd_priv;
 
 	EMGD_TRACE_ENTER;
 
@@ -1294,15 +1435,7 @@ int emgd_driver_open(struct drm_device *dev, struct drm_file *priv)
 	 */
 	mutex_lock(&dev->struct_mutex);
 
-	emgd_priv = dev->dev_private;
-	if ((emgd_priv->hal_running) && (1 == emgd_priv->pvrsrv_started)) {
-		EMGD_DEBUG("Calling PVRSRVOpen()");
-		ret = PVRSRVOpen(dev, priv);
-		EMGD_DEBUG("PVRSRVOpen() returned %d", ret);
-	} else {
-		EMGD_DEBUG("PVRSRVOpen() not called because PVR services not started "
-			"yet");
-	}
+	ret = PVRSRVOpen(dev, priv);
 
 	mutex_unlock(&dev->struct_mutex);
 
@@ -1321,24 +1454,54 @@ int emgd_driver_open(struct drm_device *dev, struct drm_file *priv)
  */
 void emgd_driver_lastclose(struct drm_device *dev)
 {
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
 	igd_init_info_t *init_info;
 	int err = 0;
+	unsigned long restore_flags = 0;
 
 	EMGD_TRACE_ENTER;
 
 	mutex_lock(&dev->struct_mutex);
 
-	/* Don't let the 3rd-party display driver (3DD) re-init too early: */
-	priv->dc = 0;
 
 	if (priv->hal_running) {
-		if (drm_emgd_init) {
+		if (config_drm.init) {
 			if( x_started ) {
-				emgd_init_display(FALSE);
+
+				restore_flags = (IGD_REG_SAVE_ALL & ~IGD_REG_SAVE_GTT)
+									| IGD_REG_SAVE_TYPE_REG;
+
+				if (!config_drm.kms) {
+					restore_flags &= ~IGD_REG_SAVE_RB;
+				}
+
+
+				if (priv->saved_registers == CONSOLE_STATE_SAVED) {
+					EMGD_DEBUG("Need to restore the console's saved "
+						"register state");
+					drm_HAL_dispatch->driver_save_restore(drm_HAL_handle,
+															restore_flags);
+					EMGD_DEBUG("State of saved registers is "
+						"X_SERVER_STATE_SAVED");
+					priv->saved_registers = X_SERVER_STATE_SAVED;
+				}
+
+				if (priv->saved_registers == X_SERVER_STATE_SAVED &&
+					!config_drm.kms && !priv->qb_seamless) {
+					emgd_init_display(FALSE, priv);
+				}
+
+				if (priv->saved_registers == CONSOLE_STATE_SAVED) {
+					EMGD_DEBUG("Need to restore the console's saved register "
+						"state");
+					drm_HAL_dispatch->driver_save_restore(drm_HAL_handle,
+															restore_flags);
+					EMGD_DEBUG("State of saved registers is X_SERVER_STATE_SAVED");
+					priv->saved_registers = X_SERVER_STATE_SAVED;
+				}
 
 				/* Since an alter_displays() was done, re-init the 3DD: */
-				if (priv->pvrsrv_started && priv->reinit_3dd) {
+				if (priv->reinit_3dd) {
 					priv->reinit_3dd(dev);
 				}
 
@@ -1349,10 +1512,14 @@ void emgd_driver_lastclose(struct drm_device *dev)
 			 * currently saved (likely) restore that state, so that the console
 			 * can be seen and work.
 			 */
+			priv->dc = 0; /* Don't let the 3DD re-init too early: */
 			if (priv->saved_registers == CONSOLE_STATE_SAVED) {
 				EMGD_DEBUG("Need to restore the console's saved register "
 					"state");
-				drm_HAL_dispatch->driver_save_restore(drm_HAL_handle);
+				restore_flags = IGD_REG_SAVE_ALL;
+
+				drm_HAL_dispatch->driver_save_restore(drm_HAL_handle,
+														restore_flags);
 				EMGD_DEBUG("State of saved registers is X_SERVER_STATE_SAVED");
 				priv->saved_registers = X_SERVER_STATE_SAVED;
 			}
@@ -1387,7 +1554,9 @@ void emgd_driver_lastclose(struct drm_device *dev)
 			if (priv->saved_registers == X_SERVER_STATE_SAVED) {
 				EMGD_DEBUG("Need to restore the console's saved register "
 					"state");
-				drm_HAL_dispatch->driver_save_restore(drm_HAL_handle);
+				restore_flags = IGD_REG_SAVE_ALL;
+				drm_HAL_dispatch->driver_save_restore(drm_HAL_handle,
+														restore_flags);
 				EMGD_DEBUG("State of saved registers is X_SERVER_STATE_SAVED");
 				priv->saved_registers = CONSOLE_STATE_SAVED;
 			}
@@ -1408,8 +1577,8 @@ void emgd_driver_lastclose(struct drm_device *dev)
 				 * reboot:
 				 */
 				OS_FREE(init_info);
-				printk(KERN_ALERT "While restarting the EMGD graphics HAL, "
-					"call to igd_driver_init() failed!\n");
+				printk(KERN_ALERT "[EMGD] Failed to restart the EMGD graphics "
+						"HAL\n");
 				mutex_unlock(&dev->struct_mutex);
 				return;
 			}
@@ -1449,8 +1618,8 @@ void emgd_driver_lastclose(struct drm_device *dev)
 				 * reboot:
 				 */
 				OS_FREE(init_info);
-				printk(KERN_ALERT "While restarting the EMGD graphics HAL, "
-					"call to igd_driver_config() failed!\n");
+				printk(KERN_ALERT "[EMGD] Failed to restart the EMGD graphics "
+						"HAL.\n");
 				mutex_unlock(&dev->struct_mutex);
 				return;
 			}
@@ -1458,7 +1627,7 @@ void emgd_driver_lastclose(struct drm_device *dev)
 			/* To ensure the devinfo->interrupt_h is NULL, call the
 			 * following:
 			 */
-			if (priv->pvrsrv_started && priv->reinit_3dd) {
+			if (priv->reinit_3dd) {
 				priv->reinit_3dd(dev);
 			}
 		}
@@ -1482,9 +1651,9 @@ void emgd_driver_lastclose(struct drm_device *dev)
  */
 void emgd_driver_preclose(struct drm_device *dev, struct drm_file *priv)
 {
-	drm_emgd_private *emgd_priv = dev->dev_private;
+	drm_emgd_priv_t *emgd_priv = dev->dev_private;
 
-	/* Ian Elliott notes on what to implement in this function.  What this
+	/* Notes on what to implement in this function.  What this
 	 * function does is largely influenced by when/why this can be called:
 	 *
 	 * - We can determine whether the connection was for the X driver vs. for a
@@ -1538,20 +1707,14 @@ void emgd_driver_preclose(struct drm_device *dev, struct drm_file *priv)
  */
 void emgd_driver_postclose(struct drm_device *dev, struct drm_file *priv)
 {
-	drm_emgd_private *emgd_priv = dev->dev_private;
+	int ret = 0;
 
 	EMGD_TRACE_ENTER;
+	mutex_lock(&dev->struct_mutex);
 
-	if ((emgd_priv->hal_running) && (1 == emgd_priv->pvrsrv_started)) {
-		int ret = 0;
-		EMGD_DEBUG("Calling PVRSRVRelease()");
-		ret = PVRSRVRelease(dev, priv);
-		EMGD_DEBUG("PVRSRVRelease() returned %d", ret);
-	} else {
-		EMGD_DEBUG("PVRSRVRelease() not called because PVR services not started "
-			"yet");
-	}
+	ret = PVRSRVRelease(dev, priv);
 
+	mutex_unlock(&dev->struct_mutex);
 	EMGD_TRACE_EXIT;
 } /* emgd_driver_postclose() */
 
@@ -1575,7 +1738,7 @@ int emgd_driver_suspend(struct drm_device *dev, pm_message_t state)
 {
 	int ret;
 	unsigned int pwr_state;
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
 
 	EMGD_TRACE_ENTER;
 
@@ -1655,7 +1818,7 @@ int emgd_driver_suspend(struct drm_device *dev, pm_message_t state)
 int emgd_driver_resume(struct drm_device *dev)
 {
 	int ret;
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
 
 	EMGD_TRACE_ENTER;
 
@@ -1712,89 +1875,222 @@ int emgd_driver_resume(struct drm_device *dev)
  */
 int emgd_driver_device_is_agp(struct drm_device *dev)
 {
-	printk(KERN_INFO "[EMGD] Returning 0 from emgd_driver_device_is_agp()\n");
+	EMGD_DEBUG("[EMGD] Returning 0 from emgd_driver_device_is_agp()\n");
 	return 0;
 } /* emgd_driver_device_is_agp() */
 
 
+
 /**
  * This is the drm_driver.get_vblank_counter() function.  It is called to get
  * the raw hardware vblank counter.  There are 4 places within "drm_irq.c" that
  * call this function.
  *
- * @param dev (IN) DRM per-device (e.g. one GMA) struct (in "drmP.h")
- * @param crtc (IN) counter to fetch (really a pipe for our driver)
+ * @param dev         (IN) DRM per-device (e.g. one GMA) struct (in "drmP.h")
+ * @param crtc_select (IN) Exactly how this is derived is unclear, but
+ *                     for now we are assuming that it is the order
+ *                     in which the CRTCs were creatd.  So 0 for
+ *                     the first CRTC, 1 for the second, and so on.
  *
  * @return raw vblank counter value
  */
-u32 emgd_driver_get_vblank_counter(struct drm_device *dev, int crtc)
+u32 emgd_driver_get_vblank_counter(struct drm_device *dev, int crtc_select)
 {
-	/* Ian Elliott notes on what to implement in this function:
-	 *
-	 * - There isn't an existing HAL interface that corresponds to this
-	 *   functionality.  However, we may use some IMG functionality to
-	 *   implement this (wait till IMG training before deciding).  For now
-	 *   (early driver bring up), a stubbed version is sufficient.
-	 */
+	struct drm_crtc *crtc;
+	emgd_crtc_t     *cur_emgd_crtc, *selected_emgd_crtc = NULL;
 
-	/* TODO -- REPLACE THIS STUB WITH A REAL IMPLEMENTATION THE IMG TRAINING */
-	printk(KERN_INFO "[EMGD] Inside of STUBBED %s()", __FUNCTION__);
 
-	return 0;
+	EMGD_TRACE_ENTER;
+
+	/* Only supported for KMS-enabled driver */
+	if (!config_drm.kms) {
+		/* Since we have previously returned 0 for our non-KMS driver,
+		 * this is left in to prevent any unforeseen problems. */
+		EMGD_TRACE_EXIT;
+		return 0;
+	}
+
+
+	/* Find the CRTC associated with the  */
+	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+		cur_emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+
+		if ((1 << crtc_select) == cur_emgd_crtc->crtc_id) {
+			selected_emgd_crtc = cur_emgd_crtc;
+			break;
+		}
+	}
+
+	if (NULL == selected_emgd_crtc) {
+		EMGD_ERROR_EXIT("Invalid CRTC selected.");
+		return -EINVAL;
+	}
+
+	EMGD_TRACE_EXIT;
+
+	return mode_context->kms_dispatch->kms_get_vblank_counter(
+										selected_emgd_crtc);
 } /* emgd_driver_get_vblank_counter() */
 
 
+
 /**
  * This is the drm_driver.enable_vblank() function.  It is called by
  * drm_vblank_get() (in "drm_irq.c") to enable vblank interrupt events.
+ * This function is only available for KMS
  *
- * @param dev (IN) DRM per-device (e.g. one GMA) struct (in "drmP.h")
- * @param crtc (IN) which irq to enable (really a pipe for our driver)
+ * @param dev         (IN) DRM per-device (e.g. one GMA) struct (in "drmP.h")
+ * @param crtc_select (IN) Exactly how this is derived is unclear, but
+ *                     for now we are assuming that it is the order
+ *                     in which the CRTCs were creatd.  So 0 for
+ *                     the first CRTC, 1 for the second, and so on.
  *
  * @return 0 on Success
  * @return <0 if the given crtc's vblank interrupt cannot be enabled
  */
-int emgd_driver_enable_vblank(struct drm_device *dev, int crtc)
+int emgd_driver_enable_vblank(struct drm_device *dev, int crtc_select)
 {
-	/* Ian Elliott notes on what to implement in this function:
-	 *
-	 * - Ditto the notes in emgd_driver_get_vblank_counter().
-	 *
-	 * - In addition: the open source Intel driver has some simple code for
-	 *   doing this.  It seems to rely on all pipe hardware having mostly the
-	 *   same hardware registers.  If we decide to implement this ourselves,
-	 *   without IMG help, perhaps we could go with a similar approach, or we
-	 *   could create some HAL-like dispatch table that allows future hardware
-	 *   to be different?
-	 */
+	struct drm_crtc *crtc;
+	unsigned char   *mmio;
+	emgd_crtc_t     *cur_emgd_crtc, *selected_emgd_crtc = NULL;
+	unsigned long    request_for;
+	int              ret = 0;
 
-	/* TODO -- REPLACE THIS STUB WITH A REAL IMPLEMENTATION THE IMG TRAINING */
-	printk(KERN_INFO "[EMGD] Inside of STUBBED %s()", __FUNCTION__);
+	EMGD_TRACE_ENTER;
 
-	return 0;
+	/* Only supported for KMS-enabled driver */
+	if (!config_drm.kms) {
+		/* We should return an error here since this is not
+		 * supported.  However, since we have previously returned 0
+		 * for our non-KMS driver, this is left in to prevent any
+		 * unforeseen problems. */
+		EMGD_TRACE_EXIT;
+		return 0;
+	}
+
+
+	/* Find the CRTC associated with the  */
+	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+		cur_emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+
+		if ((1 << crtc_select) == cur_emgd_crtc->crtc_id) {
+			selected_emgd_crtc = cur_emgd_crtc;
+			break;
+		}
+	}
+
+	if (NULL == selected_emgd_crtc) {
+		EMGD_ERROR_EXIT("Invalid CRTC selected.");
+		return -EINVAL;
+	}
+
+
+	switch (selected_emgd_crtc->igd_pipe->pipe_features & IGD_PORT_MASK) {
+		case IGD_PORT_SHARE_LVDS:
+			request_for = VBLANK_INT4_PORT4;
+			break;
+
+		case IGD_PORT_SHARE_DIGITAL:
+			request_for = VBLANK_INT4_PORT2;
+			break;
+
+		default:
+			EMGD_DEBUG("Unsupported port type");
+			request_for = 0;
+			ret         = -EINVAL;
+			break;
+	}
+
+	if (0 == ret) {
+		mmio = EMGD_MMIO(mode_context->context->device_context.virt_mmadr);
+		ret  = mode_context->dispatch->full->request_vblanks(request_for, mmio);
+
+		if (ret) {
+			EMGD_DEBUG("Failed to enable vblank");
+		}
+	}
+
+	EMGD_TRACE_EXIT;
+	return ret;
 } /* emgd_driver_enable_vblank() */
 
 
+
 /**
  * This is the drm_driver.disable_vblank() function.  It is called by
  * vblank_disable_fn() (in "drm_irq.c") to disable vblank interrupt events.
  *
- * @param dev (IN) DRM per-device (e.g. one GMA) struct (in "drmP.h")
- * @param crtc (IN) which irq to disable (really a pipe for our driver)
+ * @param dev         (IN) DRM per-device (e.g. one GMA) struct (in "drmP.h")
+ * @param crtc_select (IN) Exactly how this is derived is unclear, but
+ *                     for now we are assuming that it is the order
+ *                     in which the CRTCs were creatd.  So 0 for
+ *                     the first CRTC, 1 for the second, and so on.
  */
-void emgd_driver_disable_vblank(struct drm_device *dev, int crtc)
+void emgd_driver_disable_vblank(struct drm_device *dev, int crtc_select)
 {
-	/* Ian Elliott notes on what to implement in this function:
-	 *
-	 * - Ditto the notes in emgd_driver_enable_vblank().
-	 */
+	struct drm_crtc *crtc;
+	unsigned char   *mmio;
+	emgd_crtc_t     *cur_emgd_crtc, *selected_emgd_crtc = NULL;
+	unsigned long    request_for;
+	int              ret = 0;
 
-	/* TODO -- REPLACE THIS STUB WITH A REAL IMPLEMENTATION THE IMG TRAINING */
-	printk(KERN_INFO "[EMGD] Inside of STUBBED %s()", __FUNCTION__);
+	EMGD_TRACE_ENTER;
+
+
+	/* Only supported for KMS-enabled driver */
+	if (!config_drm.kms) {
+		EMGD_TRACE_EXIT;
+		return;
+	}
+
+
+	/* Find the CRTC associated with the  */
+	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+		cur_emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+
+		if ((1 << crtc_select) == cur_emgd_crtc->crtc_id) {
+			selected_emgd_crtc = cur_emgd_crtc;
+			break;
+		}
+	}
+
+	if (NULL == selected_emgd_crtc) {
+		EMGD_ERROR_EXIT("Invalid CRTC selected.");
+		return;
+	}
+
+
+	switch (selected_emgd_crtc->igd_pipe->pipe_features & IGD_PORT_MASK) {
+		case IGD_PORT_SHARE_LVDS:
+			request_for = VBLANK_INT4_PORT4;
+			break;
+
+		case IGD_PORT_SHARE_DIGITAL:
+			request_for = VBLANK_INT4_PORT2;
+			break;
 
+		default:
+			EMGD_DEBUG("Unsupported port type");
+			request_for = 0;
+			ret         = -EINVAL;
+			break;
+	}
+
+	if (0 == ret) {
+		mmio = EMGD_MMIO(mode_context->context->device_context.virt_mmadr);
+		ret  = mode_context->dispatch->full->end_request(request_for, mmio);
+
+		if (ret) {
+			EMGD_DEBUG("Failed to disable vblank");
+		}
+	}
+
+	EMGD_TRACE_EXIT;
+	return;
 } /* emgd_driver_disable_vblank() */
 
 
+
 /**
  * This is the drm_driver.irq_preinstall() function.  It is called by
  * drm_irq_install() (in "drm_irq.c") before it installs this driver's IRQ
@@ -1804,7 +2100,7 @@ void emgd_driver_disable_vblank(struct drm_device *dev, int crtc)
  */
 void emgd_driver_irq_preinstall(struct drm_device *dev)
 {
-	/* Ian Elliott notes on what to implement in this function:
+	/* Notes on what to implement in this function:
 	 *
 	 * - Ditto the notes in emgd_driver_enable_vblank().
 	 *
@@ -1830,7 +2126,7 @@ void emgd_driver_irq_preinstall(struct drm_device *dev)
 	 *   different?
 	 */
 
-	/* TODO -- REPLACE THIS STUB WITH A REAL IMPLEMENTATION THE IMG TRAINING */
+	/* TODO -- REPLACE THIS STUB WITH A REAL IMPLEMENTATION  */
 	printk(KERN_INFO "[EMGD] Inside of STUBBED %s()", __FUNCTION__);
 
 } /* emgd_driver_irq_preinstall() */
@@ -1848,14 +2144,6 @@ void emgd_driver_irq_preinstall(struct drm_device *dev)
  */
 int emgd_driver_irq_postinstall(struct drm_device *dev)
 {
-	/* Ian Elliott notes on what to implement in this function:
-	 *
-	 * - Ditto the notes in emgd_driver_irq_preinstall().
-	 */
-
-	/* TODO -- REPLACE THIS STUB WITH A REAL IMPLEMENTATION THE IMG TRAINING */
-	printk(KERN_INFO "[EMGD] Inside of STUBBED %s()", __FUNCTION__);
-
 	return 0;
 } /* emgd_driver_irq_postinstall() */
 
@@ -1869,11 +2157,6 @@ int emgd_driver_irq_postinstall(struct drm_device *dev)
  */
 void emgd_driver_irq_uninstall(struct drm_device *dev)
 {
-	/* Ian Elliott notes on what to implement in this function:
-	 *
-	 * - Ditto the notes in emgd_driver_irq_preinstall().
-	 */
-
 	/* TODO -- REPLACE THIS STUB WITH A REAL IMPLEMENTATION THE IMG TRAINING */
 	printk(KERN_INFO "[EMGD] Inside of STUBBED %s()", __FUNCTION__);
 
@@ -1887,6 +2170,8 @@ void emgd_driver_irq_uninstall(struct drm_device *dev)
  * (implemented in "interrupt.h") with this function as the 2nd parameter.  The
  * return type is an enum (see the Linux header "irqreturn.h").
  *
+ * Our HAL will have already installed an IRQ handler, so we do nothing here.
+ *
  * @param dev (IN) DRM per-device (e.g. one GMA) struct (in "drmP.h")
  *
  * @return IRQ_NONE if the interrupt was not from this device
@@ -1895,11 +2180,6 @@ void emgd_driver_irq_uninstall(struct drm_device *dev)
  */
 irqreturn_t emgd_driver_irq_handler(int irq, void *arg)
 {
-	/* Ian Elliott notes on what to implement in this function:
-	 *
-	 * - Ditto the notes in emgd_driver_irq_preinstall().
-	 */
-
 	/* TODO -- REPLACE THIS STUB WITH A REAL IMPLEMENTATION THE IMG TRAINING */
 	printk(KERN_INFO "[EMGD] Inside of STUBBED %s()", __FUNCTION__);
 
@@ -1907,7 +2187,70 @@ irqreturn_t emgd_driver_irq_handler(int irq, void *arg)
 } /* emgd_driver_irq_handler() */
 
 
+static int __devinit emgd_pci_probe(struct pci_dev *pdev,
+		const struct pci_device_id *ent)
+{
+	if (PCI_FUNC(pdev->devfn)) {
+		return -ENODEV;
+	}
+
+	/*
+	 * Name changed at some point in time.  2.6.35 uses drm_get_dev
+	 * and 2.6.38 uses drm_get_pci_dev  Need to figure what kernel
+	 * version this changed.
+	 */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+	return drm_get_pci_dev(pdev, ent, &driver);
+#else
+	return drm_get_dev(pdev, ent, &driver);
+#endif
+}
+
+static void emgd_pci_remove(struct pci_dev *pdev)
+{
+	struct drm_device *dev = pci_get_drvdata(pdev);
+
+	drm_put_dev(dev);
+}
+
+static int emgd_pm_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int emgd_pm_resume(struct device *dev)
+{
+	return 0;
+}
+
+static int emgd_pm_freeze(struct device *dev)
+{
+	return 0;
+}
+
+static int emgd_pm_thaw(struct device *dev)
+{
+	return 0;
+}
+
+static int emgd_pm_poweroff(struct device *dev)
+{
+	return 0;
+}
+
+static int emgd_pm_restore(struct device *dev)
+{
+	return 0;
+}
 
+static const struct dev_pm_ops emgd_pm_ops = {
+	.suspend = emgd_pm_suspend,
+	.resume = emgd_pm_resume,
+	.freeze = emgd_pm_freeze,
+	.thaw = emgd_pm_thaw,
+	.poweroff = emgd_pm_poweroff,
+	.restore = emgd_pm_restore,
+};
 
 /*
  * NOTE: The remainder of this file is standard kernel module initialization
@@ -1915,6 +2258,25 @@ irqreturn_t emgd_driver_irq_handler(int irq, void *arg)
  */
 
 
+/*
+ * Older kernels kept the PCI driver information directly in the
+ * DRM driver structure.  Newer kernels (2.6.38-rc3 and beyond)
+ * move it outside of the DRM driver structure and pass it to
+ * drm_pci_init instead in order to help pave the way for
+ * USB graphics devices.
+ */
+#define EMGD_PCI_DRIVER {    \
+	.name     = DRIVER_NAME, \
+	.id_table = pciidlist,   \
+	.probe = emgd_pci_probe, \
+	.remove = emgd_pci_remove, \
+	.driver.pm = &emgd_pm_ops, \
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+static struct pci_driver emgd_pci_driver = EMGD_PCI_DRIVER;
+#endif
+
 /**
  * DRM Sub driver entry points
  */
@@ -1954,11 +2316,11 @@ static struct drm_driver driver = {
 		.mmap    = emgd_mmap,
 		.poll    = drm_poll,
 		.fasync  = drm_fasync,
+		.read    = drm_read,
 	},
-	.pci_driver = {
-		.name     = DRIVER_NAME,
-		.id_table = pciidlist,
-	},
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	.pci_driver          = EMGD_PCI_DRIVER,
+#endif
 	.name                = DRIVER_NAME,
 	.desc                = DRIVER_DESC,
 	.date                = DRIVER_DATE,
@@ -1967,18 +2329,50 @@ static struct drm_driver driver = {
 	.patchlevel          = DRIVER_PATCHLEVEL,
 };
 
-
 /**
  * Standard procedure to initialize this kernel module when it is loaded.
  */
 static int __init emgd_init(void) {
 	int ret;
+	struct pci_dev *our_device;
 
-	EMGD_TRACE_ENTER;
+	printk(KERN_INFO "[EMGD] Initializing Driver.\n");
 	driver.num_ioctls = emgd_max_ioctl;
-	ret = drm_init(&driver);
+
+	/* If init == 1 then we should always set KMS to 0 for US15 */
+
+	if(config_drm.init || drm_emgd_init == 1){
+
+		/*  Detecting device */
+
+		/*
+		 * 0x8086 is the intel vendor id and 0x8108 is the
+		 * US15 device id.
+		 * pci_get_device returns NULL if it is not a PLB.
+		 */
+
+		our_device = pci_get_device(PCI_VENDOR_ID_INTEL,
+					PCI_DEVICE_ID_VGA_PLB, NULL);
+
+		if(our_device){
+			EMGD_ERROR("US15 detected. Setting KMS to 0 "
+				"config_drm.kms = %d ", config_drm.kms);
+			config_drm.kms = 0;
+		}
+	}
+
+	if (config_drm.kms && (config_drm.init || drm_emgd_init == 1)) {
+		driver.driver_features |= DRIVER_MODESET;
+	}
+
 	PVRDPFInit();
-	printk(KERN_INFO "[EMGD] drm_init() returning %d\n", ret);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+	ret = drm_pci_init(&driver, &emgd_pci_driver);
+#else
+	ret = drm_init(&driver);
+#endif
+	printk(KERN_INFO "[EMGD] Driver Initialized.\n");
 	EMGD_TRACE_EXIT;
 	return ret;
 }
@@ -1988,7 +2382,11 @@ static int __init emgd_init(void) {
  */
 static void __exit emgd_exit(void) {
 	EMGD_TRACE_ENTER;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+	drm_pci_exit(&driver, &emgd_pci_driver);
+#else
 	drm_exit(&driver);
+#endif
 	EMGD_TRACE_EXIT;
 }
 
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.h b/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.h
index 689b349..2c77866 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.h
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_drv.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: emgd_drv.h
- * $Revision: 1.69 $
+ * $Revision: 1.74 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -33,18 +33,27 @@
 
 #include <linux/io-mapping.h>
 #include <emgd_shared.h>
+#include <igd_version.h>
 #include "user_config.h"
 
 #define DRIVER_AUTHOR     "Intel Corporation."
 #define DRIVER_NAME       EMGD_MODULE_NAME
 #define DRIVER_DESC       "Intel Embedded Media and Grahics Driver"
-#define DRIVER_DATE       "20100723"
-#define DRIVER_MAJOR      1
-#define DRIVER_MINOR      0
-#define DRIVER_PATCHLEVEL 0
+#define DRIVER_DATE       PVR_BUILD_DATE
+#define DRIVER_MAJOR      IGD_MAJOR_NUM
+#define DRIVER_MINOR      IGD_MINOR_NUM
+#define DRIVER_PATCHLEVEL IGD_BUILD_NUM
 
 #define INTELFB_CONN_LIMIT 4
 
+/*
+ *  * Special "handle" that indicates the framebuffer being referred to is the
+ *   * EMGD initial framebuffer (which does not have a PVR meminfo handle that
+ *    * can be passed.
+ *     */
+#define EMGD_INITIAL_FRAMEBUFFER 0
+
+
 /* Function prototypes */
 extern int emgd_driver_load(struct drm_device *dev, unsigned long flags);
 extern int emgd_driver_unload(struct drm_device *dev);
@@ -91,6 +100,8 @@ int emgd_alter_cursor_pos(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv);
 int emgd_alter_displays(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv);
+int emgd_get_display_info(struct drm_device *dev, void *arg,
+	struct drm_file *file_priv);
 int emgd_alter_ovl(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv);
 int emgd_appcontext_alloc(struct drm_device *dev, void *arg,
@@ -151,6 +162,8 @@ int emgd_set_palette_entry(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv);
 int emgd_set_surface(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv);
+int emgd_dihclone_set_surface(struct drm_device *dev, void *arg,
+	struct drm_file *file_priv);
 int emgd_sync(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv);
 int emgd_driver_pre_init(struct drm_device *dev, void *arg,
@@ -177,4 +190,10 @@ int emgd_video_flush_tlb(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv);
 int emgd_get_golden_htotal(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv);
+int emgd_control_plane_format(struct drm_device *dev, void *arg,
+	struct drm_file *file_priv);
+int emgd_set_overlay_display(struct drm_device *dev, void *arg,
+	struct drm_file *file_priv);
+int emgd_query_2d_caps_hwhint(struct drm_device *dev, void *arg,
+	struct drm_file *file_priv);
 #endif
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_encoder.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_encoder.c
new file mode 100644
index 0000000..1413c91
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_encoder.c
@@ -0,0 +1,474 @@
+/*
+ *-----------------------------------------------------------------------------
+ * Filename: emgd_encoder.c
+ * $Revision: 1.2 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2011, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ * Description:
+ *  Encoder / kenrel mode setting functions.
+ *-----------------------------------------------------------------------------
+ */
+#define MODULE_NAME hal.oal
+
+#include <drmP.h>
+#include <drm_crtc_helper.h>
+#include <linux/version.h>
+
+#include <mode_dispatch.h>
+#include "drm_emgd_private.h"
+
+#include <igd_pwr.h>
+
+
+
+/*------------------------------------------------------------------------------
+ * External Functions
+ *------------------------------------------------------------------------------
+ */
+extern int calculate_eld(igd_display_port_t *port,
+				igd_timing_info_t *timing_info);
+
+
+
+static void emgd_encoder_destroy(struct drm_encoder *encoder);
+static void emgd_encoder_dpms(struct drm_encoder *encoder, int mode);
+static bool emgd_encoder_mode_fixup(struct drm_encoder *encoder,
+				struct drm_display_mode *mode,
+				struct drm_display_mode *adjusted_mode);
+static void emgd_encoder_prepare(struct drm_encoder *encoder);
+static void emgd_encoder_mode_set(struct drm_encoder *encoder,
+				struct drm_display_mode *mode,
+				struct drm_display_mode *adjusted_mode);
+static void emgd_encoder_commit(struct drm_encoder *encoder);
+
+
+const struct drm_encoder_funcs emgd_encoder_funcs = {
+	.destroy = emgd_encoder_destroy,
+};
+
+const struct drm_encoder_helper_funcs emgd_encoder_helper_funcs = {
+	.dpms       = emgd_encoder_dpms,
+	.mode_fixup = emgd_encoder_mode_fixup,
+	.prepare    = emgd_encoder_prepare,
+	.mode_set   = emgd_encoder_mode_set,
+	.commit     = emgd_encoder_commit,
+};
+
+
+/**
+ * emgd_encoder_dpms
+ *
+ * This function will put the encoder to either an ON or OFF state.  Anything
+ * that is not DRM_MODE_DPMS_ON is treated as an off-state.
+ *
+ * @param encoder (IN) Encoder
+ * @param mode    (IN) power mode
+ *
+ * @return None
+ */
+static void emgd_encoder_dpms(struct drm_encoder *encoder, int mode)
+{
+	emgd_encoder_t *emgd_encoder = container_of(encoder, emgd_encoder_t, base);
+	igd_display_port_t *igd_port = emgd_encoder->igd_port;
+	unsigned long       new_port_state;
+
+	EMGD_TRACE_ENTER;
+
+
+	switch(mode) {
+		case DRM_MODE_DPMS_ON:
+			new_port_state = IGD_POWERSTATE_D0;
+			break;
+
+		case DRM_MODE_DPMS_STANDBY:
+		case DRM_MODE_DPMS_SUSPEND:
+		case DRM_MODE_DPMS_OFF:
+			new_port_state = IGD_POWERSTATE_D3;
+			break;
+
+		default:
+			EMGD_ERROR_EXIT("Unsupported DPMS mode");
+			return;
+	}
+
+
+	if (new_port_state == IGD_POWERSTATE_D3 &&
+		emgd_encoder->flags & ENCODER_FLAG_FIRST_DPMS) {
+
+		EMGD_DEBUG("Not setting initial port %lx power to %lx",
+			igd_port->port_number, new_port_state);
+		emgd_encoder->flags &= ~ENCODER_FLAG_FIRST_DPMS;
+	} else {
+		EMGD_DEBUG("Setting port %lx power to %lx",
+			igd_port->port_number, new_port_state);
+		igd_port->pd_driver->set_power(igd_port->pd_context,
+			new_port_state);
+
+		if (new_port_state == IGD_POWERSTATE_D0) {
+			mode_context->kms_dispatch->kms_post_program_port(emgd_encoder,
+				TRUE);
+		}
+	}
+
+	EMGD_TRACE_EXIT;
+}
+
+
+
+/**
+ * emgd_encoder_mode_fixup
+ *
+ * Called before a mode set, takes the input "mode", matches it to the closest
+ * supported mode, then put the supported mode into "adjusted_mode" to let the
+ * caller know.
+ *
+ * Note: We cannot handle centered and scaled mode with this.  To handle this
+ *       we need to program the pipe and the port to different sets of timings.
+ *       The CRTC Helper does not allow this.  It wants to send adjusted_mode
+ *       to both the CRTC and the Encoder.  We can maybe get around this by
+ *       modifying the "mode" parameter, but that is not the right approach.
+ *
+ * @param encoder (IN) Encoder being prepared
+ * @param mode    (IN) Requested mode
+ * @param adjusted_mode (IN) Encoder supported mode
+ *
+ * @return true, false (details TBD)
+ */
+static bool emgd_encoder_mode_fixup(struct drm_encoder *encoder,
+		struct drm_display_mode *mode,
+		struct drm_display_mode *adjusted_mode)
+{
+	struct drm_device      *dev          = NULL;
+	igd_context_t          *context      = NULL;
+	igd_display_port_t     *port         = NULL;
+	igd_framebuffer_info_t *fb_info      = NULL;
+	emgd_encoder_t         *emgd_encoder = NULL;
+	igd_timing_info_t      *timing       = NULL;
+	igd_display_info_t     *pt_info      = NULL;
+	emgd_crtc_t            *emgd_crtc    = NULL;
+	igd_display_pipe_t     *pipe         = NULL;
+	unsigned long           existing_height  = 0;
+	unsigned long           existing_width   = 0;
+	unsigned long           existing_refresh = 0;
+	int                     ret;
+
+	EMGD_TRACE_ENTER;
+
+	/* Check ajusted mode to see if it's valid.  If not, populate it */
+	if (adjusted_mode->crtc_htotal == 0) {
+		EMGD_DEBUG("No valid mode in adjusted mode, setting valid mode");
+		drm_mode_set_crtcinfo(adjusted_mode, 0);
+	}
+
+	dev = encoder->dev;
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+	emgd_encoder = container_of(encoder, emgd_encoder_t, base);
+	port = emgd_encoder->igd_port;
+	if (!port->pt_info) {
+		port->pt_info = kzalloc(sizeof(igd_display_info_t), GFP_KERNEL);
+		if (!port->pt_info) {
+			EMGD_DEBUG("Cannot allocate igd_display_into_t");
+			return false;
+		}
+	}
+	existing_height  = port->pt_info->height;
+	existing_width   = port->pt_info->width;
+	existing_refresh = port->pt_info->refresh;
+	pt_info          = port->pt_info;
+
+	fb_info = kzalloc(sizeof(igd_framebuffer_info_t), GFP_KERNEL);
+	if (!fb_info) {
+		EMGD_DEBUG("Cannot allocate framebuffer info");
+		return false;
+	}
+
+	/* Get the dimension of the framebuffer linked to the CRTC.  If it is
+	 * smaller than the resolution, kms_match_mode will either center it
+	 * or let the encoder hardware scale it */
+	fb_info->width  = encoder->crtc->fb->width;
+	fb_info->height = encoder->crtc->fb->height;
+	EMGD_DEBUG("Setting fb_info to: %dx%d", fb_info->width, fb_info->height);
+
+	pt_info->width        = mode->crtc_hdisplay;
+	pt_info->height       = mode->crtc_vdisplay;
+	pt_info->refresh      = mode->vrefresh;
+	pt_info->dclk         = mode->synth_clock;
+	pt_info->htotal       = mode->crtc_htotal;
+	pt_info->hblank_start = mode->crtc_hblank_start;
+	pt_info->hblank_end   = mode->crtc_hblank_end;
+	pt_info->hsync_start  = mode->crtc_hsync_start;
+	pt_info->hsync_end    = mode->crtc_hsync_end;
+	pt_info->vtotal       = mode->crtc_vtotal;
+	pt_info->vblank_start = mode->crtc_vblank_start;
+	pt_info->vblank_end   = mode->crtc_vblank_end;
+	pt_info->vsync_start  = mode->crtc_vsync_start;
+	pt_info->vsync_end    = mode->crtc_vsync_end;
+	pt_info->mode_number  = mode->clock_index;
+	pt_info->flags        = 0;
+	EMGD_DEBUG("Setting pt_info to: %dx%d", pt_info->width, pt_info->height);
+
+	ret = mode_context->kms_dispatch->kms_match_mode((void *)emgd_encoder,
+		(void *)fb_info, &timing);
+
+	if (!ret) {
+		adjusted_mode->crtc_hdisplay     = timing->width;
+		adjusted_mode->crtc_vdisplay     = timing->height;
+		adjusted_mode->vrefresh          = timing->refresh;
+		adjusted_mode->synth_clock       = timing->dclk;
+		adjusted_mode->crtc_htotal       = timing->htotal;
+		adjusted_mode->crtc_hblank_start = timing->hblank_start;
+		adjusted_mode->crtc_hblank_end   = timing->hblank_end;
+		adjusted_mode->crtc_hsync_start  = timing->hsync_start;
+		adjusted_mode->crtc_hsync_end    = timing->hsync_end;
+		adjusted_mode->crtc_vtotal       = timing->vtotal;
+		adjusted_mode->crtc_vblank_start = timing->vblank_start;
+		adjusted_mode->crtc_vblank_end   = timing->vblank_end;
+		adjusted_mode->crtc_vsync_start  = timing->vsync_start;
+		adjusted_mode->crtc_vsync_end    = timing->vsync_end;
+		adjusted_mode->clock_index       = timing->mode_number;
+		adjusted_mode->private_flags     = timing->mode_info_flags;
+
+		EMGD_DEBUG("(%dx%d@%d)->(%dx%d@%d)",
+			mode->crtc_hdisplay, mode->crtc_vdisplay, mode->vrefresh,
+			adjusted_mode->crtc_hdisplay, adjusted_mode->crtc_vdisplay,
+			adjusted_mode->vrefresh);
+
+		/* Check our new mode against what currently there
+		 * to see if we can do a seamless mode-set
+		 */
+		if (emgd_encoder->flags & ENCODER_FLAG_FIRST_ALTER) {
+			if (mode_context->fw_info) {
+
+				emgd_crtc = container_of(encoder->crtc, emgd_crtc_t, base);
+				pipe = emgd_crtc->igd_pipe;
+
+				existing_width = mode_context->fw_info->
+					timing_arr[pipe->pipe_num].width;
+				existing_height = mode_context->fw_info->
+					timing_arr[pipe->pipe_num].height;
+				existing_refresh = mode_context->fw_info->
+					timing_arr[pipe->pipe_num].refresh;
+
+			}
+		}
+
+		if (adjusted_mode->crtc_hdisplay == existing_width &&
+			adjusted_mode->crtc_vdisplay == existing_height) {
+
+			if (abs(adjusted_mode->vrefresh - existing_refresh) <= 1) {
+				emgd_encoder->flags |= ENCODER_FLAG_SEAMLESS;
+			}
+		}
+	}
+
+	kfree(fb_info);
+
+	EMGD_TRACE_EXIT;
+	return (!ret);
+}
+
+
+
+/**
+ * emgd_encoder_prepare
+ *
+ * Based on the available documentation at the moment, this function gets
+ * called right before a mode change.  Its job is to turn off the display.
+ *
+ * @param encoder (IN) Encoder being prepared
+ *
+ * @return None
+ */
+static void emgd_encoder_prepare(struct drm_encoder *encoder)
+{
+	struct drm_encoder_helper_funcs *encoder_funcs;
+	emgd_encoder_t *emgd_encoder;
+
+	EMGD_TRACE_ENTER;
+
+	emgd_encoder = container_of(encoder, emgd_encoder_t, base);
+
+	if (!(emgd_encoder->flags & ENCODER_FLAG_SEAMLESS)) {
+		encoder_funcs = encoder->helper_private;
+		encoder_funcs->dpms(encoder, DRM_MODE_DPMS_OFF);
+	}
+
+	emgd_encoder->flags &= ~ENCODER_FLAG_FIRST_ALTER;
+
+	EMGD_TRACE_EXIT;
+}
+
+
+
+/**
+ * emgd_encoder_commit
+ *
+ * This function commits the mode change sequence by actually programming
+ * the registers.
+ *
+ * @param encoder (IN) Encoder being prepared
+ *
+ * @return None
+ */
+static void emgd_encoder_commit(struct drm_encoder *encoder)
+{
+	struct drm_encoder_helper_funcs *encoder_funcs;
+	emgd_encoder_t     *emgd_encoder = NULL;
+	emgd_crtc_t        *emgd_crtc;
+	igd_display_port_t *port;
+	igd_display_pipe_t *pipe;
+
+	EMGD_TRACE_ENTER;
+
+	emgd_encoder = container_of(encoder, emgd_encoder_t, base);
+
+
+	if (!(emgd_encoder->flags & ENCODER_FLAG_SEAMLESS)) {
+
+		port      = emgd_encoder->igd_port;
+		emgd_crtc = container_of(encoder->crtc, emgd_crtc_t, base);
+		pipe      = emgd_crtc->igd_pipe;
+
+		port->pd_driver->set_mode(port->pd_context, pipe->timing,
+								1<<pipe->pipe_num);
+
+		encoder_funcs = encoder->helper_private;
+		encoder_funcs->dpms(encoder, DRM_MODE_DPMS_ON);
+
+	}
+	/* Reset our seamless variable */
+	emgd_encoder->flags &= ~ENCODER_FLAG_SEAMLESS;
+
+	/* TODO: Add call to check_display */
+
+	EMGD_TRACE_EXIT;
+}
+
+
+
+/**
+ * emgd_encoder_mode_set
+ *
+ * This function saves the requested timings into the Port Timing Info
+ * structure.  At emgd_encoder_commit() time we should be using these
+ * timings to program the port, but currently we are using timings from
+ * the pipe.  This is fine for now, but at one point we should investigate
+ * the centering case in which the port timings may not match the pipe timings.
+ *
+ * @param encoder (IN) Encoder being prepared
+ * @param mode    (IN)
+ * @param adjusted_mode (IN)
+ *
+ * @return None
+ */
+static void emgd_encoder_mode_set(struct drm_encoder *encoder,
+		struct drm_display_mode *mode,
+		struct drm_display_mode *adjusted_mode)
+{
+	emgd_crtc_t        *emgd_crtc    = NULL;
+	emgd_encoder_t     *emgd_encoder = NULL;
+	igd_display_pipe_t *pipe         = NULL;
+	igd_display_port_t *port         = NULL;
+	pd_timing_t        *timing       = NULL;
+
+	EMGD_TRACE_ENTER;
+
+
+	emgd_encoder = container_of(encoder, emgd_encoder_t, base);
+
+	if (!(emgd_encoder->flags & ENCODER_FLAG_SEAMLESS)) {
+		port = emgd_encoder->igd_port;
+		emgd_crtc = container_of(encoder->crtc, emgd_crtc_t, base);
+		pipe = emgd_crtc->igd_pipe;
+
+		if (pipe) {
+			timing = (pd_timing_t *)pipe->timing;
+
+			if (NULL == port->pt_info) {
+				port->pt_info = kzalloc(sizeof(igd_display_info_t), GFP_KERNEL);
+
+				if (!port->pt_info) {
+					EMGD_ERROR_EXIT("Unable to allocate pt_info.");
+					return;
+				}
+			}
+
+			port->pt_info->width        = adjusted_mode->crtc_hdisplay;
+			port->pt_info->height       = adjusted_mode->crtc_vdisplay;
+			port->pt_info->refresh      = adjusted_mode->vrefresh;
+			port->pt_info->dclk         = adjusted_mode->synth_clock;
+			port->pt_info->htotal       = adjusted_mode->crtc_htotal;
+			port->pt_info->hblank_start = adjusted_mode->crtc_hblank_start;
+			port->pt_info->hblank_end   = adjusted_mode->crtc_hblank_end;
+			port->pt_info->hsync_start  = adjusted_mode->crtc_hsync_start;
+			port->pt_info->hsync_end    = adjusted_mode->crtc_hsync_end;
+			port->pt_info->vtotal       = adjusted_mode->crtc_vtotal;
+			port->pt_info->vblank_start = adjusted_mode->crtc_vblank_start;
+			port->pt_info->vblank_end   = adjusted_mode->crtc_vblank_end;
+			port->pt_info->vsync_start  = adjusted_mode->crtc_vsync_start;
+			port->pt_info->vsync_end    = adjusted_mode->crtc_vsync_end;
+			port->pt_info->mode_number  = adjusted_mode->clock_index;
+			port->pt_info->flags        = adjusted_mode->private_flags;
+
+			port->pt_info->x_offset     = timing->x_offset;
+			port->pt_info->y_offset     = timing->y_offset;
+			port->pt_info->flags       |= IGD_DISPLAY_ENABLE;
+
+
+			EMGD_DEBUG("Calculate ELD");
+			if (calculate_eld(port, timing)) {
+				EMGD_DEBUG("Fail to calculate ELD");
+			}
+
+		} else {
+			EMGD_ERROR("Trying to set the mode without a pipe attached.");
+		}
+	}
+
+	EMGD_TRACE_EXIT;
+}
+
+
+
+/**
+ * emgd_encoder_destroy
+ *
+ * Frees the resources allocated for this encoder during "create_encoder()"
+ *
+ * @param encoder (IN) Encoder to be freed
+ *
+ * @return None
+ */
+static void emgd_encoder_destroy(struct drm_encoder *encoder)
+{
+	emgd_encoder_t *emgd_encoder;
+
+	EMGD_TRACE_ENTER;
+	emgd_encoder = container_of(encoder, emgd_encoder_t, base);
+
+	drm_encoder_cleanup(encoder);
+
+	kfree(emgd_encoder);
+
+	EMGD_TRACE_EXIT;
+}
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_fb.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_fb.c
index 0425ff0..83f91bd 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_fb.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_fb.c
@@ -1,9 +1,9 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: emgd_fb.c
- * $Revision: 1.8 $
+ * $Revision: 1.9 $
  *-----------------------------------------------------------------------------
- * Copyright (c) 2002-2010, Intel Corporation.
+ * Copyright (c) 2002-2011, Intel Corporation.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -25,46 +25,34 @@
  *
  *-----------------------------------------------------------------------------
  * Description:
- *  Framebuffer / kenrel mode setting functions.
+ *  Framebuffer / kernel mode setting functions.
  *-----------------------------------------------------------------------------
  */
+#define MODULE_NAME hal.oal
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/fb.h>
+#include <drmP.h>
+#include <drm.h>
+#include <drm_crtc.h>
+#include <drm_crtc_helper.h>
+#include <drm_fb_helper.h>
+#include <linux/version.h>
+#include <linux/vga_switcheroo.h>
+
 #include "drm_emgd_private.h"
 #include "emgd_drv.h"
 #include "emgd_drm.h"
 #include "memory.h"
-/* #include <drmP.h> */
-/* #include <drm.h> */
-/* #include <drm_crtc.h> */
-#include <drm_crtc_helper.h>
-#include <linux/version.h>
+#include "io.h"
+#include "mode_dispatch.h"
 
-
-/*
- * Move this to emgd_drv.h?
- */
-typedef struct _emgd_framebuffer {
-	struct drm_framebuffer base;
-	unsigned long size;
-	unsigned long offset;
-} emgd_framebuffer_t;
-
-typedef struct _emgdfb_par {
-	struct drm_device *dev;
-	emgd_framebuffer_t *emgd_fb;
-} emgdfb_par_t;
+/* Necessary to import page list for a PVR-allocated surface */
+#include "pvr_bridge_km.h"
 
 
-typedef struct _emgd_crtc {
-	struct drm_crtc base;
-	emgd_framebuffer_t *fbdev_fb;
-	struct drm_mode_set mode_set;
-	struct drm_display_mode saved_mode;
-	struct drm_display_mode saved_adjusted_mode;
-	unsigned char lut_r[256];
-	unsigned char lut_g[256];
-	unsigned char lut_b[256];
-	unsigned char lut_a[256];
-} emgd_crtc_t;
 
 #if  (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
 #define RETURN_PROBE_TYPE int
@@ -77,98 +65,101 @@ typedef struct _emgd_crtc {
 #endif
 
 
-static struct drm_framebuffer *emgd_fb_create(struct drm_device *dev,
-		struct drm_file *filp, struct drm_mode_fb_cmd *r);
 
+/*------------------------------------------------------------------------------
+ * Global Variables
+ *------------------------------------------------------------------------------
+ */
+extern igd_framebuffer_info_t primary_fb_info;
+extern mode_context_t         mode_context[1];
+static struct drm_mode_set    panic_mode;
+extern int                    drm_emgd_init;
+extern emgd_drm_config_t      config_drm;
+
+/* CRTC Dispatch Tables */
+extern const struct drm_crtc_funcs emgd_crtc_funcs;
+extern const struct drm_crtc_helper_funcs emgd_crtc_helper_funcs;
+
+/* Encoder Dispatch Tables */
+extern const struct drm_encoder_funcs emgd_encoder_funcs;
+extern const struct drm_encoder_helper_funcs emgd_encoder_helper_funcs;
+
+/* Connector Dispatch Tables */
+extern const struct drm_connector_funcs emgd_connector_funcs;
+extern const struct drm_connector_helper_funcs emgd_connector_helper_funcs;
+
+/* FBCON Dispatch Table */
+extern const struct fb_ops emgd_fb_ops;
+
+
+
+/*------------------------------------------------------------------------------
+ * Formal Declaration
+ *------------------------------------------------------------------------------
+ */
+extern int emgd_fbcon_initial_config(emgd_fbdev_t *emgd_fbdev);
+
+static int emgd_fbdev_init(drm_emgd_priv_t *priv);
+static void emgd_fbdev_destroy(drm_emgd_priv_t *priv);
+
+
+
+/*------------------------------------------------------------------------------
+ * FB Functions
+ *------------------------------------------------------------------------------
+ */
+int emgd_framebuffer_init(struct drm_device *dev,
+			emgd_framebuffer_t *emgd_fb,
+			struct drm_mode_fb_cmd *mode_cmd,
+			unsigned long offset);
+static struct drm_framebuffer *emgd_user_framebuffer_create(
+								struct drm_device *dev,
+								struct drm_file *filp,
+								struct drm_mode_fb_cmd *r);
 RETURN_PROBE_TYPE  emgd_fb_probe(struct drm_device *dev);
-static void emgd_fb_destroy (struct drm_framebuffer *fb);
-static int emgd_fb_create_handle(struct drm_framebuffer *fb,
-		struct drm_file *file_priv, unsigned int *handle);
-static int emgd_fb_check_var(struct fb_var_screeninfo *var,
-		struct fb_info *info);
-static int emgd_fb_set_par(struct fb_info *info);
-static int emgd_fb_setcolreg(unsigned int regno,
-		unsigned int red, unsigned int green, unsigned int blue,
-		unsigned int transp, struct fb_info *info);
-static int emgd_fb_pan_display(struct fb_var_screeninfo *var,
-		struct fb_info *info);
-static int emgd_fb_blank(int blank, struct fb_info *info);
+static int emgd_fb_panic(struct notifier_block *n,
+			unsigned long res,
+			void *panic_str);
+static void emgd_user_framebuffer_destroy (struct drm_framebuffer *fb);
+static int  emgd_user_framebuffer_create_handle(struct drm_framebuffer *fb,
+				struct drm_file *file_priv, unsigned int *handle);
+static void emgd_fb_restore(void);
+
 
 static const struct drm_mode_config_funcs emgd_mode_funcs = {
-	.fb_create = emgd_fb_create,
+	.fb_create  = emgd_user_framebuffer_create,
 	.PROBE_FUNC = emgd_fb_probe,
+	/*.output_poll_changed:  we don't support hotplug */
 };
 
-static const struct drm_framebuffer_funcs emgd_fb_funcs = {
-	.destroy = emgd_fb_destroy,
-	.create_handle = emgd_fb_create_handle,
-};
 
-static const struct fb_ops emgd_fb_ops = {
-	.owner = THIS_MODULE,
-	.fb_check_var = emgd_fb_check_var,
-	.fb_set_par = emgd_fb_set_par,
-	.fb_setcolreg = emgd_fb_setcolreg,
-	.fb_fillrect = cfb_fillrect,
-	.fb_copyarea = cfb_copyarea,
-	.fb_imageblit = cfb_imageblit,
-	.fb_mmap = NULL,
-	.fb_pan_display = emgd_fb_pan_display,
-	.fb_blank = emgd_fb_blank,
+static struct notifier_block paniced = {
+	.notifier_call = emgd_fb_panic,
 };
 
 
-static void emgd_crtc_dpms(struct drm_crtc *crtc, int mode);
-static bool emgd_crtc_mode_fixup(struct drm_crtc *crtc,
-		struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);
-static int emgd_crtc_mode_set(struct drm_crtc *crtc,
-		struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode,
-		int x, int y, struct drm_framebuffer *old_fb);
-static int emgd_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
-		struct drm_framebuffer *old_fb);
-static void emgd_crtc_prepare(struct drm_crtc *crtc);
-static void emgd_crtc_commit(struct drm_crtc *crtc);
-
-static void emgd_crtc_save(struct drm_crtc *crtc);
-static void emgd_crtc_restore(struct drm_crtc *crtc);
-static int emgd_crtc_cursor_set(struct drm_crtc *crtc,
-		struct drm_file *file_priv, uint32_t handle,
-		uint32_t width, uint32_t height);
-static int emgd_crtc_cursor_move(struct drm_crtc *crtc, int x, int y);
-static void emgd_crtc_gamma_set(struct drm_crtc *crtc,
-		unsigned short *red, unsigned short *green, unsigned short *blue,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
-		uint32_t start,
-#endif
-		uint32_t size);
-static void emgd_crtc_destroy(struct drm_crtc *crtc);
-
-
-
-static const struct drm_crtc_helper_funcs emgd_helper_funcs = {
-	.dpms = emgd_crtc_dpms,
-	.mode_fixup = emgd_crtc_mode_fixup,
-	.mode_set = emgd_crtc_mode_set,
-	.mode_set_base = emgd_crtc_mode_set_base,
-	.prepare = emgd_crtc_prepare,
-	.commit = emgd_crtc_commit,
+static const struct drm_framebuffer_funcs emgd_fb_funcs = {
+	.destroy       = emgd_user_framebuffer_destroy,
+	.create_handle = emgd_user_framebuffer_create_handle,
 };
 
-static const struct drm_crtc_funcs emgd_crtc_funcs = {
-	.save = emgd_crtc_save,
-	.restore = emgd_crtc_restore,
-	.cursor_set = emgd_crtc_cursor_set,
-	.cursor_move = emgd_crtc_cursor_move,
-	.gamma_set = emgd_crtc_gamma_set,
-	.set_config = drm_crtc_helper_set_config,
-	.destroy = emgd_crtc_destroy,
-};
 
 
+/*
+ * Called if something fails while trying to set up framebuffer based
+ * console.
+ */
+static int emgd_fb_panic(struct notifier_block *n,
+		unsigned long res,
+		void *panic_str)
+{
+	EMGD_DEBUG("Panic occurred, switch back to text console.");
 
+	emgd_fb_restore();
 
+	return 0;
+}
 
-static struct drm_mode_set panic_mode;
 
 /*
  * emgd_fb_restore
@@ -179,476 +170,1234 @@ void emgd_fb_restore(void)
 {
 	int ret;
 
+	EMGD_TRACE_ENTER;
+
 	/*
 	 * FIXME: Need to have the real crtc saved so it can be restored.
 	 */
 	if ((ret = drm_crtc_helper_set_config(&panic_mode)) != 0) {
-		printk(KERN_ERR "Failed to restore crtc configuration: %d\n", ret);
+		EMGD_ERROR("Failed to restore crtc configuration: %d", ret);
 	}
+
+	EMGD_TRACE_EXIT;
 }
 
 
+/* Workqueue task function; needed during CRTC init */
+void emgd_flip_worker(struct work_struct *w);
+
 /*
- * Called if something fails while trying to set up framebuffer based
- * console.
+ * create_crtcs
+ *
+ * Creates crtcs. This function loops through the valid pipes, creating
+ * one crtc for each pipe.  This function assumes that dsp_alloc() has
+ * been run.
+ *
+ * TODO:  Move this to emgd_crtc.c?
+ *
+ * @param dev     (IN) DRM per-device (e.g. one GMA) struct (in "drmP.h")
+ *
+ * @return None
  */
-static int emgd_fb_panic(struct notifier_block *n,
-		unsigned long res,
-		void *panic_str)
+void create_crtcs(struct drm_device *dev)
 {
-	printk(KERN_ALERT "Panic occurred, switch back to text console.");
+	emgd_crtc_t *emgd_crtc = NULL;
+	drm_emgd_priv_t *dev_priv = NULL;
+	igd_context_t *context = NULL;
+	igd_display_pipe_t *pipe = NULL;
+	int i, index = 0;
+	unsigned short *r, *g, *b;
 
-	emgd_fb_restore();
+	EMGD_TRACE_ENTER;
 
-	return 0;
-}
+	dev_priv = ((drm_emgd_priv_t *)dev->dev_private);
+	context = dev_priv->context;
 
+	while ((pipe = context->mod_dispatch.dsp_get_next_pipe(context, pipe, 0))) {
 
-static struct notifier_block paniced = {
-	.notifier_call = emgd_fb_panic,
-};
+		/* FIXME: Why are we allocating the extra space for the
+		 * connectors here? */
+		emgd_crtc = kzalloc(sizeof(emgd_crtc_t) +
+			(INTELFB_CONN_LIMIT * sizeof(struct drm_connector *)),
+			GFP_KERNEL);
 
+		if (emgd_crtc == NULL) {
+			EMGD_ERROR("create_crtcs: Failed to allocate CRTC structure.");
+			return;
+		}
+
+		spin_lock_init(&emgd_crtc->crtc_lock);
+
+		emgd_crtc->crtc_id     = 1 << index;
+		emgd_crtc->igd_pipe    = pipe;
+		dev_priv->crtcs[index] = emgd_crtc;
+		EMGD_DEBUG("Creating CRTC with ID: 0x%x, igd_pipe=0x%lx",
+			emgd_crtc->crtc_id, (unsigned long)pipe);
+
+
+		/* Hook up crtc functions */
+		drm_crtc_init(dev, &emgd_crtc->base, &emgd_crtc_funcs);
+		EMGD_DEBUG("  Created CRTC [%d]", emgd_crtc->base.base.id);
+
+		/* gamma */
+		drm_mode_crtc_set_gamma_size(&emgd_crtc->base, 256);
+
+		/* Set initial gamma values */
+		r = emgd_crtc->base.gamma_store;
+		g = emgd_crtc->base.gamma_store + 256;
+		b = emgd_crtc->base.gamma_store + 512;
+		for (i = 0; i < 256; i++) {
+			emgd_crtc->lut_r[i] = i;
+			emgd_crtc->lut_g[i] = i;
+			emgd_crtc->lut_b[i] = i;
+			emgd_crtc->lut_a[i] = 0;
+			r[i] = (i << 8);
+			g[i] = (i << 8);
+			b[i] = (i << 8);
+		}
+
+		/* Initialize workqueue task to wait for render completion on flips */
+		INIT_WORK(&emgd_crtc->flip_work, emgd_flip_worker);
+		emgd_crtc->flip_work_queued = 0;
+
+		/* Target FB that we're in the process of changing to */
+		emgd_crtc->newfb = NULL;
+
+		/* Target "ops complete" watermark to allow flip to proceed */
+		emgd_crtc->render_complete_at = 0;
+
+		/*
+		 * Are we expected to perform flip cleanup (sending userspace event
+		 * and such) on next vblank event?
+		 */
+		emgd_crtc->vblank_expected = 0;
+
+		/* Userspace 'flip done' event */
+		emgd_crtc->flip_event = NULL;
+
+		/* TODO: Create connector list */
+		emgd_crtc->mode_set.crtc       = &emgd_crtc->base;
+		emgd_crtc->mode_set.connectors =
+								(struct drm_connector **)(emgd_crtc + 1);
+		emgd_crtc->mode_set.num_connectors = 0;
+
+		/* Hook up crtc helper functions */
+		drm_crtc_helper_add(&emgd_crtc->base, &emgd_crtc_helper_funcs);
+		index++;
+	}
 
+	EMGD_TRACE_EXIT;
+}
 
-/*
- * emgd_ms_init
+
+
+/**
+ * create_encoder
  *
- * This is the main initialization entry point.  Called during driver load
- * and does basic setup.
+ * Creates an encoder for the igd_port in the parameter.
+ *
+ * @param dev      (IN) DRM per-device (e.g. one GMA) struct (in "drmP.h")
+ * @param igd_port (IN) pointer to IGD display port.  (pd_driver must be valid)
+ *
+ * @return None
  */
-void emgd_ms_init(struct drm_device *dev)
+static void create_encoder(struct drm_device *dev, igd_display_port_t *igd_port)
 {
-	emgd_crtc_t *emgd_crtc;
-	unsigned short *r, *g, *b;
-	int i;
+	emgd_encoder_t  *emgd_encoder;
+	emgd_crtc_t     *emgd_crtc;
+	struct drm_crtc *crtc;
+	unsigned long    drm_encoder_type;
 
-	drm_mode_config_init(dev);  /* drm helper function */
 
-	dev->mode_config.min_width = 0;
-	dev->mode_config.max_width = 2048;
-	dev->mode_config.min_height = 0;
-	dev->mode_config.max_height = 2048;
-	dev->mode_config.funcs = (void *)&emgd_mode_funcs;
-	dev->mode_config.fb_base = pci_resource_start(dev->pdev, 2);
+	EMGD_TRACE_ENTER;
 
-	emgd_crtc = kzalloc(sizeof(emgd_crtc_t) +
-			(INTELFB_CONN_LIMIT * sizeof(struct drm_connector *)),
-			GFP_KERNEL);
+	/* Find the corresponding DRM encoder type */
+	switch(igd_port->port_type) {
+		case IGD_PORT_LVDS:
+			drm_encoder_type = DRM_MODE_ENCODER_LVDS;
+			break;
 
-	if (emgd_crtc == NULL) {
-		printk(KERN_ERR "emgd_ms_init: Failed to allocate CRTC structure.\n");
-		return;
-	}
+		case IGD_PORT_DIGITAL:
+			drm_encoder_type = DRM_MODE_ENCODER_TMDS;
+			break;
 
-	drm_crtc_init(dev, &emgd_crtc->base, &emgd_crtc_funcs);
-	drm_mode_crtc_set_gamma_size(&emgd_crtc->base, 256);
-
-	/* Set initial gamma values */
-	r = emgd_crtc->base.gamma_store;
-	g = emgd_crtc->base.gamma_store + 256;
-	b = emgd_crtc->base.gamma_store + 512;
-	for (i = 0; i < 256; i++) {
-		emgd_crtc->lut_r[i] = i;
-		emgd_crtc->lut_g[i] = i;
-		emgd_crtc->lut_b[i] = i;
-		emgd_crtc->lut_a[i] = 0;
-		r[i] = i << 8;
-		g[i] = i << 8;
-		b[i] = i << 8;
+		case IGD_PORT_ANALOG:
+		case IGD_PORT_RGBA:
+		case IGD_PORT_TV:
+		case IGD_PORT_SDVO_ST:
+		case IGD_PORT_SDVO_ST_GPIO:
+		default:
+			EMGD_ERROR("Invalid Port Type");
+			return;
 	}
 
-	drm_crtc_helper_add(&emgd_crtc->base, &emgd_helper_funcs);
 
-	/* TODO: Create connector list */
+	emgd_encoder = kzalloc(sizeof(emgd_encoder_t), GFP_KERNEL);
+	if (!emgd_encoder) {
+		EMGD_ERROR("Out of memory!");
+		return;
+	}
 
 
-	/* TODO: Is there more this needs to do? */
+	/* What we call "TWIN" is what KMS calls "CLONE".  None of the
+	 * platforms we currently support allow TWIN, so just set
+	 * the bits equal to the port type since a port can always
+	 * "TWIN" with itself */
+    emgd_encoder->clone_mask = igd_port->port_type;
 	/*
-	 * i915 driver does the following:
-	 *       Q? what is base?
-	 *   drm_crtc_init(dev, base, crtc_funcs);
-	 *   drm_mode_crtc_set_gamma_size(base, 256);
-	 *   drm_crtc_helper_add(base, helper_funcs);
-	 *   Builds dev->mode_config.connector_list
-	 *
-	 *   crtc_funcs:
-	 *		cursor_set  - probabl a simple wrapper around alter_cursor
-	 *		cursor_move - probabl a simple wrapper around alter_cursor
-	 *		gamma_set   - set palette ?
-	 *		set_config  - drm_crtc_helper_set_config
-	 *		destroy     - clean up
-	 *
-	 *   drm_crtc_helper_funcs
-	 *		dpms         - power management
-	 *		mode_fixup   - ???
-	 *		mode_set     - wrapper around alter_displays ?
-	 *		mode_set_base- noop (handled in alter_displays) ?
-	 *		prepare      - DPMS off
-	 *		commit       - DPMS on
-	 *
-	 * This is a lot of the code that impliments KMS.
+	 * crtc's are identified by a 1 that is shifted over:
+	 * 11
+	 * ||_ pipe 0
+	 * |__ pipe 1
+	 * The order of the pipes is based on how they are initialized
+	 * in the drm.
 	 */
+	emgd_encoder->crtc_mask  = KMS_PIPE_ID(igd_port->port_features);
+	emgd_encoder->igd_port   = igd_port;
+	emgd_encoder->state.port = igd_port;
+	emgd_encoder->flags |= ENCODER_FLAG_FIRST_DPMS | ENCODER_FLAG_FIRST_ALTER;
+
+
+	/* Since we do not support TWIN and pipe assignment is fixed, the
+	 * current configuration is the only possible configuration */
+	emgd_encoder->base.possible_crtcs  = emgd_encoder->crtc_mask;
+	emgd_encoder->base.possible_clones = emgd_encoder->clone_mask;
+
+	/* Initialize the CRTC associated with this encoder.  We should
+	 * probably use the crtc_mask here to do the matching, but we
+	 * have the same info in our internal structures. */
+	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+		emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+
+		if ((emgd_crtc->igd_pipe->pipe_features & IGD_PORT_MASK) ==
+			emgd_encoder->igd_port->port_type) {
+			emgd_encoder->base.crtc = crtc;
+			break;
+		}
+	}
 
+
+	EMGD_DEBUG("Creating encoder=0x%lx on pipe=0x%lx, of port=0x%lx, "
+		"port_type=0x%lx",
+		(unsigned long)&(emgd_encoder->base), emgd_encoder->crtc_mask,
+		igd_port->port_number, igd_port->port_type);
+
+	drm_encoder_init(dev, &emgd_encoder->base, &emgd_encoder_funcs,
+						drm_encoder_type);
+	drm_encoder_helper_add(&emgd_encoder->base, &emgd_encoder_helper_funcs);
 }
 
 
-/*
- * emgd_fb_probe
+
+/**
+ * create_connector_properties
+ *
+ * Creates properties associated with the input connector.  Connector properties
+ * are what EMGD calls "port attributes."  The only difference is EMGD's port
+ * attributes are per-encoder, not per-connector.  For this implementation, we
+ * are assuming one connector per encoder.  With this assumption, we can draw
+ * a direct connection between "port attributes" and "connector properties."
  *
- * Handle changes to the framebuffer.
+ * @param dev            (IN) DRM per-device (e.g. one GMA) struct (in "drmP.h")
+ * @param emgd_connector (IN) Selected connector
+ *
+ * @return None
  */
-RETURN_PROBE_TYPE emgd_fb_probe(struct drm_device *drm)
+static void create_connector_properties(struct drm_device *dev,
+				emgd_connector_t *emgd_connector)
 {
+	igd_display_port_t *igd_port = emgd_connector->encoder->igd_port;
+	drm_emgd_priv_t    *priv     = emgd_connector->priv;
+	unsigned long       num_of_attributes = 0, num_of_properties = 0;
+	unsigned long       i, current_value;
+	pd_attr_t          *attributes;
 
-	/* FIXME: Need to set panic_mode to the a valid mode */
+	struct drm_connector *drm_connector = &emgd_connector->base;
+	struct drm_property  *new_prop;
 
-	/* Register a notifier to switch back to kernel console on panic */
-	atomic_notifier_chain_register(&panic_notifier_list, &paniced);
 
-	RETURN_PROBE;
-}
-EXPORT_SYMBOL(emgd_fb_probe);
+	EMGD_TRACE_ENTER;
 
+	/* Get port attributes from the port driver */
+	priv->context->dispatch.get_attrs(priv->context,
+								igd_port->port_number,
+								&num_of_attributes,
+								&attributes);
 
-/*
- * emgd_fb_remove
- *
- * clean up everything we've done to create the framebuffer instance.
- */
-int emgd_fb_remove(struct drm_device *dev, struct drm_framebuffer *fb)
-{
-	struct fb_info *info;
-	drm_emgd_private *dev_priv = dev->dev_private;
 
-	info = dev_priv->fbdev;
+	/* If the connector has no attributes, then return */
+	if (0 >= num_of_attributes) {
+		EMGD_TRACE_EXIT;
+		return;
+	}
 
-	if (info) {
-		unregister_framebuffer(info);
-		framebuffer_release(info);
+	emgd_connector->properties =
+		(struct drm_property **) kzalloc(sizeof(struct drm_property *) *
+									num_of_attributes, GFP_KERNEL);
+
+	if (NULL == emgd_connector->properties) {
+		EMGD_ERROR_EXIT("Failed to allocate emgd_connector->properties");
 	}
 
-	/* Remove the notifier that checks for failed framebuffers */
-	atomic_notifier_chain_unregister(&panic_notifier_list, &paniced);
-	memset(&panic_mode, 0, sizeof(struct drm_mode_set));
 
-	return 0;
-}
-EXPORT_SYMBOL(emgd_fb_remove);
+	/* Convert port attributes to connector properties and attach them */
+	for(i = 0; i < num_of_attributes; i++) {
 
+		/* Invisible attributes are not settable so don't even report
+		 * it was a property */
+		if (attributes[i].flags & PD_ATTR_FLAG_USER_INVISIBLE) {
+			continue;
+		}
 
-/*
- * emgd_fb_create
- */
-static struct drm_framebuffer *emgd_fb_create(struct drm_device *dev,
-		struct drm_file *filp,
-		struct drm_mode_fb_cmd *r)
-{
-	int ret;
-	struct fb_info *info;
-	emgdfb_par_t *par;
-	emgd_framebuffer_t *emgd_fb;
-	drm_emgd_private *dev_priv;
+		/* Instead of using DRM_MODE_PROP_xxxx types, it may be possible
+         * to use the PD_ATTR_TYPE_xxxx types, since the 2nd parameter
+		 * to drm_property_create is a flag */
+		switch (attributes[i].type) {
+			case PD_ATTR_TYPE_RANGE:
+			{
+				igd_range_attr_t *attr = (igd_range_attr_t *) &attributes[i];
 
-	emgd_fb = kzalloc(sizeof(emgd_framebuffer_t), GFP_KERNEL);
 
-	/*
-	 * TODO: What is drm_mode_fb_cmd?  UMG gets some kind of memory
-	 *       block based on r->handle (psb_get_meminfo_by_handle())
-	 */
+				new_prop = drm_property_create(dev, DRM_MODE_PROP_RANGE,
+									attr->name, 3);
 
-	/* Create a framebuffer instance */
-	ret = drm_framebuffer_init(dev, &emgd_fb->base, &emgd_fb_funcs);
-	if (ret) {
-		printk(KERN_ERR "Failed to create framebuffer instance.\n");
-		return NULL;
-	}
+				if (NULL == new_prop) {
+					EMGD_ERROR("Failed to allocate new property");
+					continue;
+				}
 
-	drm_helper_mode_fill_fb_struct(&emgd_fb->base, r);
+				new_prop->values[0] = attr->id;
+				new_prop->values[1] = attr->min;
+				new_prop->values[2] = attr->max;
+				current_value       = attr->current_value;
 
-	info = framebuffer_alloc(sizeof(emgdfb_par_t), &dev->pdev->dev);
-	if (info == NULL) {
-		printk(KERN_ERR "Failed to allocate framebuffer info.\n");
-		return NULL;
+				break;
+			}
+
+			case PD_ATTR_TYPE_BOOL:
+			{
+				igd_bool_attr_t *attr = (igd_bool_attr_t *) &attributes[i];
+
+
+				new_prop = drm_property_create(dev, DRM_MODE_PROP_RANGE,
+									attr->name, 2);
+
+				if (NULL == new_prop) {
+					EMGD_ERROR("Failed to allocate new property");
+					continue;
+				}
+
+				new_prop->values[0] = false;
+				new_prop->values[1] = true;
+				current_value       = attr->current_value;
+
+				break;
+			}
+
+			case PD_ATTR_TYPE_LIST:
+			case PD_ATTR_TYPE_LIST_ENTRY:
+			case PD_ATTR_TYPE_BUFFER:
+			default:
+				EMGD_ERROR("Unsupported PD Attribute type");
+				continue;
+		}
+
+		drm_connector_attach_property(drm_connector, new_prop, current_value);
+		emgd_connector->properties[num_of_properties++] = new_prop;
 	}
 
-	par = info->par;
-
-	/* Fill in fb info structure */
-	strcpy(info->fix.id, "emgdfb");
-	info->fix.type = FB_TYPE_PACKED_PIXELS;
-	info->fix.visual = FB_VISUAL_TRUECOLOR;
-	info->fix.type_aux = 0;
-	info->fix.xpanstep = 1;
-	info->fix.ypanstep = 1;
-	info->fix.ywrapstep = 0;
-	info->fix.accel = FB_ACCEL_I830;
-	info->fix.line_length = emgd_fb->base.pitch;
-	info->fix.smem_start = dev->mode_config.fb_base;
-	info->fix.smem_len = emgd_fb->size;
-	info->fix.mmio_start = pci_resource_start(dev->pdev, 0);
-	info->fix.mmio_len = pci_resource_len(dev->pdev, 0);
-
-	info->flags = FBINFO_DEFAULT;
-	info->fbops = (struct fb_ops*)&emgd_fb_ops;
-	info->screen_base = 0;  /* FIXME: This is kernel memory address */
-	info->screen_size = emgd_fb->size;
-#if  (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
-	info->pseudo_palette = emgd_fb->base.pseudo_palette;
-#endif
-	info->var.xres_virtual = emgd_fb->base.width;
-	info->var.yres_virtual = emgd_fb->base.height;
-	info->var.bits_per_pixel = emgd_fb->base.bits_per_pixel;
-	info->var.xoffset = 0;
-	info->var.yoffset = 0;
-	info->var.activate = FB_ACTIVATE_NOW;
-	info->var.width = -1;
-	info->var.height = -1;
-	info->var.xres = r->width;
-	info->var.yres = r->height;
-
-	info->pixmap.size = 64 * 1024;
-	info->pixmap.buf_align = 8;
-	info->pixmap.access_align = 32;
-	info->pixmap.flags = FB_PIXMAP_SYSTEM;
-	info->pixmap.scan_align = 1;
-
-	switch (emgd_fb->base.depth) {
-		case 8:
-			info->var.red.offset = 0;
-			info->var.green.offset = 0;
-			info->var.blue.offset = 0;
-			info->var.red.length = 8;
-			info->var.green.length = 8;
-			info->var.blue.length = 8;
-			info->var.transp.offset = 0;
-			info->var.transp.length = 0;
+	EMGD_TRACE_EXIT;
+}
+
+
+
+/**
+ * create_connectors
+ *
+ * Creates connectors associated with the encoder.
+ *
+ * This function currently supports one connector per encoder.  Further
+ * development required in the future to support encoders that have more
+ * than one connector.
+ *
+ * @param dev          (IN) DRM per-device (e.g. one GMA) struct (in "drmP.h")
+ * @param emgd_encoder (IN) Encoder to be examined.
+ *
+ * @return None
+ */
+static void create_connectors(struct drm_device *dev,
+				emgd_encoder_t *emgd_encoder)
+{
+	igd_display_port_t    *port = emgd_encoder->igd_port;
+	pd_driver_t           *pd   = port->pd_driver;
+	unsigned long          connector_type = DRM_MODE_CONNECTOR_LVDS;
+	emgd_connector_t      *emgd_connector;
+
+
+	EMGD_TRACE_ENTER;
+
+	switch (pd->type) {
+		case PD_DISPLAY_LVDS_EXT:
+		case PD_DISPLAY_LVDS_INT:
+			connector_type = DRM_MODE_CONNECTOR_LVDS;
 			break;
-		case 15:
-			info->var.red.offset = 10;
-			info->var.green.offset = 5;
-			info->var.blue.offset = 0;
-			info->var.red.length = 5;
-			info->var.green.length = 5;
-			info->var.blue.length = 5;
-			info->var.transp.offset = 15;
-			info->var.transp.length = 1;
+
+		case PD_DISPLAY_FP:
+			connector_type = DRM_MODE_CONNECTOR_DVID;
 			break;
-		case 16:
-			info->var.red.offset = 11;
-			info->var.green.offset = 5;
-			info->var.blue.offset = 0;
-			info->var.red.length = 5;
-			info->var.green.length = 6;
-			info->var.blue.length = 5;
-			info->var.transp.offset = 0;
-			info->var.transp.length = 0;
+
+		case PD_DISPLAY_CRT_EXT:
+		case PD_DISPLAY_CRT:
+			connector_type = DRM_MODE_CONNECTOR_VGA;
 			break;
-		case 24:
-			info->var.red.offset = 16;
-			info->var.green.offset = 8;
-			info->var.blue.offset = 0;
-			info->var.red.length = 8;
-			info->var.green.length = 8;
-			info->var.blue.length = 8;
-			info->var.transp.offset = 0;
-			info->var.transp.length = 0;
+
+		case PD_DISPLAY_HDMI_INT:
+			connector_type = DRM_MODE_CONNECTOR_HDMIA;
 			break;
-		case 32:
-			info->var.red.offset = 16;
-			info->var.green.offset = 8;
-			info->var.blue.offset = 0;
-			info->var.red.length = 8;
-			info->var.green.length = 8;
-			info->var.blue.length = 8;
-			info->var.transp.offset = 24;
-			info->var.transp.length = 8;
+
+		case PD_DISPLAY_HDMI_EXT:
+			connector_type = DRM_MODE_CONNECTOR_HDMIA;
 			break;
-		default:
+
+		case PD_DISPLAY_DP_INT:
+			connector_type = DRM_MODE_CONNECTOR_DisplayPort;
 			break;
+
+		case PD_DISPLAY_TVOUT:
+		case PD_DISPLAY_TVFP:
+		case PD_DISPLAY_RGBA:
+		case PD_DISPLAY_TVOUT_INT:
+		case PD_DISPLAY_DRGB:
+			EMGD_ERROR("Unsupported connector type");
+			return;
+
+		default:
+			EMGD_ERROR("Unknown connector type");
+			return;
+	}
+
+
+	/* Allocate a new connector */
+	emgd_connector = kzalloc(sizeof(emgd_connector_t), GFP_KERNEL);
+	if (!emgd_connector) {
+		EMGD_ERROR("Out of memory!");
+		return;
 	}
 
-	register_framebuffer(info);
+	drm_connector_init(dev, &emgd_connector->base, &emgd_connector_funcs,
+						connector_type);
+
+	drm_mode_connector_attach_encoder(&emgd_connector->base,
+		&emgd_encoder->base);
+
+	drm_connector_helper_add(&emgd_connector->base,
+		&emgd_connector_helper_funcs);
+
+	EMGD_DEBUG("Creating connector=0x%lx, encoder=0x%lx, type=0x%lx",
+		(unsigned long)&(emgd_connector->base),
+		(unsigned long)&(emgd_encoder->base), connector_type);
 
-	dev_priv = dev->dev_private;
-	dev_priv->fbdev = info;
+	emgd_connector->encoder                          = emgd_encoder;
+	emgd_connector->priv                             = dev->dev_private;
+	emgd_connector->base.display_info.subpixel_order = SubPixelHorizontalRGB;
+	emgd_connector->base.interlace_allowed           = false;
+	emgd_connector->base.doublescan_allowed          = false;
+	emgd_connector->base.encoder                     = &emgd_encoder->base;
 
-	par->emgd_fb = emgd_fb;
-	par->dev = dev;
+	/* Create and attach connector properties */
+	create_connector_properties(dev, emgd_connector);
+
+
+#if 0
+        drm_connector_attach_property(&connector->base,
+                        dev->mode_config.scaling_mode_property,
+                        DRM_MODE_SCALE_FULLSCREEN);
+        drm_connector_attach_property(&connector->base,
+                       dev->mode_config.edid_property, 0);
+        drm_connector_attach_property(&connector->base,
+                       dev->mode_config.dpms_property, 0);
+#endif
 
-	return &(emgd_fb->base);
+
+	drm_sysfs_connector_add(&emgd_connector->base);
+
+	EMGD_TRACE_EXIT;
 }
 
 
 
-/*
- * emgd_fb_destroy
+/**
+ * emgd_setup_outputs
  *
- * clean up and remove a framebuffer instance.
+ * This function enumerates all the available outputs (physical connectors) by
+ * first initializing all the encoders in the system, and then querying
+ * the encoders for the connectors.
+ *
+ * Because we are adapting from EMGD, the real work behind detecting encoders
+ * has already been done by the time we get to this function.  Therefore,
+ * all we need to do is using existing EMGD HAL dispatch functions to complete
+ * the task.
+ *
+ * @param dev (IN) DRM per-device (e.g. one GMA) struct (in "drmP.h")
+ *
+ * @return
  */
-static void emgd_fb_destroy (struct drm_framebuffer *fb)
+void emgd_setup_outputs(struct drm_device *dev)
 {
-	struct drm_device *dev = fb->dev;
-	drm_emgd_private *dev_priv = dev->dev_private;
+	drm_emgd_priv_t         *priv            = dev->dev_private;
+	igd_context_t           *igd_context     = priv->context;
+	inter_module_dispatch_t *module_dispatch = &igd_context->mod_dispatch;
+	igd_display_port_t      *port            = NULL;
+	struct drm_encoder      *encoder;
+
+	EMGD_TRACE_ENTER;
+
+	/* Loop through all available ports.  What KMS calls "encoder" is a
+     * subset of what EMGD calls "port."
+     */
+	while ((port = module_dispatch->dsp_get_next_port(igd_context, port, 0))) {
+
+		/* If there is a port driver, then there's an encoder */
+		if (port->pd_driver) {
+			create_encoder(dev, port);
+		}
+	}
 
-	/* TODO: Unmap any pages mapped to the GTT */
 
-	if (dev_priv->fbdev) {
-		emgd_fb_remove(dev, fb);
-	}
+	/* For each encoder, create the connectors on the encoder */
+	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+		emgd_encoder_t *emgd_encoder;
 
-	drm_framebuffer_cleanup(fb);
+		emgd_encoder = container_of(encoder, emgd_encoder_t, base);
+		create_connectors(dev, emgd_encoder);
+	}
 
-	kfree(fb);
+	EMGD_TRACE_EXIT;
 }
 
 
-/*
- * emgd_fb_create_handle
+
+/**
+ * emgd_modeset_init
  *
- * TODO: Figure out what this is suppose to do. The intel driver creates
- * a handle to a GEM object.  The UMG driver does nothing.
+ * This is the main initialization entry point.  Called during driver load
+ * and does basic setup.
+ *
+ * @param dev      (IN) DRM per-device (e.g. one GMA) struct (in "drmP.h")
+ * @param full_kms (IN) If we are running with KMS enabled, then set this
+ *                      to true to do the full KMS initialization.  If not,
+ *                      then set this to false.
+ *
+ * @return None
  */
-static int emgd_fb_create_handle(struct drm_framebuffer *fb,
-		struct drm_file *file_priv,
-		unsigned int *handle)
+void emgd_modeset_init(struct drm_device *dev)
 {
-	(void)file_priv;
-	*handle = 0;
+	drm_emgd_priv_t *devpriv = (drm_emgd_priv_t *)dev->dev_private;
+	int ret;
 
-	return 0;
-}
+	EMGD_TRACE_ENTER;
+	drm_mode_config_init(dev);  /* drm helper function */
+
+	dev->mode_config.min_width  = 0;
+	dev->mode_config.max_width  = 4096;
+	dev->mode_config.min_height = 0;
+	dev->mode_config.max_height = 2048;
+	dev->mode_config.funcs      = (void *)&emgd_mode_funcs;
 
 
-static int emgd_fb_check_var(struct fb_var_screeninfo *var,
-		struct fb_info *info)
-{
-	printk(KERN_ALERT "STUBED emgd_fb_check_var\n");
-	return 0;
+	/* OTC uses dev->agp->base for fb_base */
+	dev->mode_config.fb_base = pci_resource_start(dev->pdev, PSB_GATT_RESOURCE);
+
+	/* Initialize VBLANK handling */
+	dev->irq_enabled      = true;
+	dev->max_vblank_count = 0xffffff; /* 24-bit frame counter */
+
+	ret = drm_vblank_init(dev, devpriv->num_crtc);
+	if (ret) {
+		EMGD_ERROR("Call to drm_vblank_init() failed.  drmWaitVBlank() "
+			"will not work.");
+		dev->irq_enabled = false;
+	}
+
+
+	/* Create the crtc's */
+	create_crtcs(dev);
+
+	drm_mode_create_scaling_mode_property(dev);
+	emgd_setup_outputs(dev);
+
+	/* Initialize the framebuffer device */
+	emgd_fbdev_init(devpriv);
+
+	EMGD_TRACE_EXIT;
 }
 
-static int emgd_fb_set_par(struct fb_info *info)
+
+
+/**
+ * emgd_modeset_destroy
+ *
+ * Clean up resources allocated in emgd_modeset_init.  Called during driver
+ * unload
+ *
+ * @param dev (IN) DRM per-device (e.g. one GMA) struct (in "drmP.h")
+ *
+ * @return None
+ */
+void emgd_modeset_destroy(struct drm_device *dev)
 {
-	printk(KERN_ALERT "STUBED emgd_fb_set_par\n");
-	return 0;
+	drm_emgd_priv_t *priv = NULL;
+
+	EMGD_TRACE_ENTER;
+
+	priv = dev->dev_private;
+	emgd_fbdev_destroy(priv);
+	kfree(priv->emgd_fbdev);
+	priv->emgd_fbdev = NULL;
+
+	EMGD_TRACE_EXIT;
 }
 
-static int emgd_fb_setcolreg(unsigned int regno,
-		unsigned int red, unsigned int green, unsigned int blue,
-		unsigned int transp, struct fb_info *info)
+
+
+/*
+ * emgd_fb_probe
+ *
+ * Registers panic mode for the DRM to switch to.
+ *
+ * @param dev (IN) DRM per-device (e.g. one GMA) struct (in "drmP.h")
+ *
+ * @return TBD
+ */
+RETURN_PROBE_TYPE emgd_fb_probe(struct drm_device *dev)
 {
-	printk(KERN_ALERT "STUBED emgd_fb_setcolreg\n");
-	return 0;
+	EMGD_TRACE_ENTER;
+
+	/* Set Panic Mode to 1024x768 because it is an acceptably generic mode */
+	//memset(&panic_mode, 0, sizeof(struct drm_mode_set));
+
+	/* In later kernels this function changes to "output_poll_changed", as
+	 * such, it is unclear if we need to implement it at all since we do not
+	 * support hot-plug
+	 */
+
+
+	/* Register a notifier to switch back to kernel console on panic */
+	atomic_notifier_chain_register(&panic_notifier_list, &paniced);
+
+	EMGD_TRACE_EXIT;
+	RETURN_PROBE;
 }
+EXPORT_SYMBOL(emgd_fb_probe);
 
-static int emgd_fb_pan_display(struct fb_var_screeninfo *var,
-		struct fb_info *info)
+
+/**
+ * emgd_user_framebuffer_create
+ *
+ * Creates an instance for the framebuffer.
+ *
+ * @param dev      (IN) DRM per-device (e.g. one GMA) struct (in "drmP.h")
+ * @param filp     (IN)
+ * @param mode_cmd (IN) Input from the DRM_IOCTL_MODE_ADDFB
+ *
+ * @return pointer to allocated FB instance
+ */
+static struct drm_framebuffer *emgd_user_framebuffer_create(
+								struct drm_device *dev,
+								struct drm_file *filp,
+								struct drm_mode_fb_cmd *mode_cmd)
 {
-	printk(KERN_ALERT "STUBED emgd_fb_pan_display\n");
-	return 0;
+	emgd_framebuffer_t *emgd_fb;
+	int                 ret;
+
+	EMGD_TRACE_ENTER;
+
+	emgd_fb = kzalloc(sizeof(emgd_framebuffer_t), GFP_KERNEL);
+	if (!emgd_fb) {
+		EMGD_ERROR("Failed to allocate an emgd_framebuffer_t");
+		return NULL;
+	}
+
+	/* Create a framebuffer instance */
+	ret = emgd_framebuffer_init(dev, emgd_fb, mode_cmd,
+			(unsigned long)mode_cmd->handle);
+	if (ret) {
+		EMGD_ERROR("Failed to create framebuffer instance.");
+		/* TODO: Free the allocation at mode_cmd->handle */
+		kfree(emgd_fb);
+		emgd_fb = NULL;
+		return NULL;
+	}
+
+	EMGD_TRACE_EXIT;
+	return &emgd_fb->base;
 }
 
-static int emgd_fb_blank(int blank, struct fb_info *info)
+
+/**
+ * emgd_framebuffer_init
+ *
+ * Creates an instance for the framebuffer.
+ *
+ * Maps an existing surface, which has been allocated via the PVR services,
+ * into the GTT to make it displayable and returns a 'drm_framebuffer'
+ * struct that can be used to refer to this surface in future KMS
+ * operations.  This function is called as a result of drmModeAddFB()
+ * being called in userspace; the handle passed to drmModeAddFB() should
+ * be the kernel meminfo handle (i.e., meminfo->hKernelMemInfo in userspace).
+ *
+ * @param dev      (IN) DRM per-device (e.g. one GMA) struct (in "drmP.h")
+ * @param emgd_fb  (IN)
+ * @param mode_cmd (IN) Input from the DRM_IOCTL_MODE_ADDFB
+ * @param handle   (IN) Handle of allocation.  The handle will be the
+ *                      PVR meminfo handle.  The initial framebuffer,
+ *                      which is allocated directly by the GMM before
+ *                      the PVR services starts up is a special case;
+ *                      a handle of 0 will refer to the initial framebuffer.
+ *
+ * @return int return value
+ */
+int emgd_framebuffer_init(struct drm_device *dev,
+		emgd_framebuffer_t *emgd_fb,
+		struct drm_mode_fb_cmd *mode_cmd,
+		unsigned long handle)
 {
-	switch(blank) {
-	case FB_BLANK_UNBLANK:
-		printk(KERN_ALERT "Should call turn on display\n");
-		break;
-	case FB_BLANK_NORMAL:
-		printk(KERN_ALERT "Should call standby\n");
-		break;
-	case FB_BLANK_HSYNC_SUSPEND:
-		printk(KERN_ALERT "Should call standby\n");
-		break;
-	case FB_BLANK_VSYNC_SUSPEND:
-		printk(KERN_ALERT "Should call suspend\n");
-		break;
-	case FB_BLANK_POWERDOWN:
-		printk(KERN_ALERT "Should call DRM_MODE_DPMS_OFF\n");
-		break;
+	drm_emgd_priv_t *dev_priv = NULL;
+	igd_context_t *context = NULL;
+	PVRSRV_PER_PROCESS_DATA *pvr_perproc;
+	PVRSRV_KERNEL_MEM_INFO *pvr_meminfo;
+	struct page **pagelist;
+	unsigned long numpages, gtt_offset, page_offset;
+	int ret, pid;
+
+	EMGD_TRACE_ENTER;
+
+	dev_priv = ((drm_emgd_priv_t *)dev->dev_private);
+	context = dev_priv->context;
+
+	if (handle == EMGD_INITIAL_FRAMEBUFFER) {
+		/*
+		 * Special case:  initial EMGD framebuffer is allocated via GTT instead
+		 * of through the PVR services.  It has no PVR meminfo handle.
+		 */
+		ret = drm_framebuffer_init(dev, &emgd_fb->base, &emgd_fb_funcs);
+		if (ret) {
+		    EMGD_ERROR("Failed to create framebuffer instance.");
+		    return -ENOMEM;
+		}
+
+		drm_helper_mode_fill_fb_struct(&emgd_fb->base, mode_cmd);
+
+		/*
+		 * Initial framebuffer offset is stored in the device
+		 * private structure.
+		 */
+		emgd_fb->type       = GMM_FRAMEBUFFER;
+		emgd_fb->gtt_offset = dev_priv->initfb_info.fb_base_offset;
+		emgd_fb->handle     = handle;
+
+	} else {
+		/* Fetch PVR services 'per-process' data structure */
+		pid = OSGetCurrentProcessIDKM();
+		pvr_perproc = PVRSRVPerProcessData(pid);
+
+		/* Look up the kernel-side meminfo for the handle passed in*/
+		ret = PVRSRVLookupHandle(pvr_perproc->psHandleBase,
+				(void**)&pvr_meminfo,
+			(IMG_HANDLE)handle, PVRSRV_HANDLE_TYPE_MEM_INFO);
+		if (ret != PVRSRV_OK) {
+			EMGD_ERROR("Buffer handle is not a valid PVR surface.");
+			return -EINVAL;
+		}
+
+		/*
+		 * Now fetch the page list, number of pages, and offset into the first
+		 * page for this buffer.
+		 */
+		ret = PVRSRVGetPageListKM(pvr_meminfo, &pagelist, &numpages,
+				&page_offset);
+		if (ret != PVRSRV_OK) {
+			EMGD_ERROR("Failed to get pagelist for PVR surface.");
+			return -EINVAL;
+		}
+
+		/* Map this page list into the GTT */
+		ret = context->dispatch.gmm_import_pages((void**)pagelist, &gtt_offset,
+			numpages);
+		if (ret < 0) {
+			EMGD_ERROR("Failed to map pagelist into GTT.");
+			return -ENOMEM;
+		}
+
+		/* Create a framebuffer instance */
+		ret = drm_framebuffer_init(dev, &emgd_fb->base, &emgd_fb_funcs);
+		if (ret) {
+			EMGD_ERROR("Failed to create framebuffer instance.");
+			return -ENOMEM;
+		}
+
+		/* Fill the EMGD framebuffer structure */
+		drm_helper_mode_fill_fb_struct(&emgd_fb->base, mode_cmd);
+
+		emgd_fb->type = PVR_FRAMEBUFFER;
+		emgd_fb->pvr_meminfo = pvr_meminfo;
+		emgd_fb->pagelist = pagelist;
+		emgd_fb->gtt_offset = gtt_offset + page_offset;
+		emgd_fb->handle     = handle;
 	}
 
+	EMGD_TRACE_EXIT;
 	return 0;
 }
 
 
 
-/****************************************************************************
- * CRTC functions
- ****************************************************************************/
-
-static void emgd_crtc_dpms(struct drm_crtc *crtc, int mode)
+/*
+ * emgd_user_framebuffer_destroy
+ *
+ * clean up and remove a framebuffer instance.
+ *
+ */
+static void emgd_user_framebuffer_destroy (struct drm_framebuffer *fb)
 {
-	printk(KERN_ALERT "emgd_crtc_dpms: STUB\n");
-}
+	drm_emgd_priv_t *dev_priv = NULL;
+	emgd_framebuffer_t *emgd_fb = NULL;
+	igd_context_t *context = NULL;
+
+	EMGD_TRACE_ENTER;
+
+	dev_priv = ((drm_emgd_priv_t *)fb->dev->dev_private);
+	context = dev_priv->context;
+	emgd_fb = container_of(fb, emgd_framebuffer_t, base);
+
+	/* Unmap pages from GTT */
+	if (emgd_fb->type == PVR_FRAMEBUFFER) {
+		/* PVR-allocated pages imported into GTT:  just unmap */
+		EMGD_DEBUG("Unmapping imported PVR framebuffer pages at %lu.", emgd_fb->gtt_offset);
+		context->dispatch.gmm_release_import(emgd_fb->gtt_offset);
+	} else {
+		/* GMM-allocated pages (initial framebuffer): unmap and free pages */
+		EMGD_DEBUG("Unmapping and freeing GMM framebuffer pages at %lu.", emgd_fb->gtt_offset);
+		context->dispatch.gmm_free(emgd_fb->gtt_offset);
+	}
 
-static bool emgd_crtc_mode_fixup(struct drm_crtc *crtc,
-		struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode)
-{
-	printk(KERN_ALERT "emgd_crtc_mode_fixup: STUB\n");
-	return 0;
+	drm_framebuffer_cleanup(fb);
+	kfree(emgd_fb);
+
+	EMGD_TRACE_EXIT;
 }
 
-static int emgd_crtc_mode_set(struct drm_crtc *crtc,
-		struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode,
-		int x, int y, struct drm_framebuffer *old_fb)
+
+
+/*
+ * emgd_user_framebuffer_create_handle
+ *
+ * Returns 'a' handle associated with the drm_framebuffer given in the
+ * parameter.  In our case, we return 'the' handle because our handles
+ * are already cross-process compatible, and PVR is keeping track of
+ * the reference count so buffers don't get destroyed unless it is not
+ * used.
+ *
+ * @param fb (IN)        DRM framebuffer to look up
+ * @param file_priv (IN) Not used
+ * @param handle (OUT)
+ *
+ * @return 0 on success
+ * @return -EINVAL on failure
+ */
+static int emgd_user_framebuffer_create_handle(struct drm_framebuffer *fb,
+		struct drm_file *file_priv,
+		unsigned int *handle)
 {
-	printk(KERN_ALERT "emgd_crtc_mode_set: STUB\n");
-	return 0;
+	emgd_framebuffer_t *emgd_fb;
+	int ret = -EINVAL;
+
+	EMGD_TRACE_ENTER;
+
+	/* To avoid compiler warning. */
+	(void)file_priv;
+
+	emgd_fb = container_of(fb, emgd_framebuffer_t, base);
+
+	if (NULL != emgd_fb) {
+		*handle = emgd_fb->handle;
+	}
+
+
+	EMGD_TRACE_EXIT;
+
+	return ret;
 }
 
-static int emgd_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
-		struct drm_framebuffer *old_fb)
+
+
+/**
+ * emgd_fbdev_init
+ *
+ * Allocates and initializes a framebuffer device.  Through
+ * drm_fb_helper_initial_config(), this function will set a sane mode and
+ * allocate a framebuffer surface to go with the framebuffer device.
+ *
+ * @param priv (IN) EMGD private DRM data structure
+ *
+ * @return 0 on success
+ */
+
+static int emgd_fbdev_init(drm_emgd_priv_t *priv)
 {
-	printk(KERN_ALERT "emgd_pipe_set_base: STUB\n");
+	emgd_fbdev_t *emgd_fbdev;
+
+	EMGD_TRACE_ENTER;
+
+	emgd_fbdev = kzalloc(sizeof(emgd_fbdev_t), GFP_KERNEL);
+	if (!emgd_fbdev) {
+		return -ENOMEM;
+	}
+
+	emgd_fbdev->priv         = priv;
+	priv->emgd_fbdev         = emgd_fbdev;
+
+	emgd_fbcon_initial_config(emgd_fbdev);
+
+	EMGD_TRACE_EXIT;
 	return 0;
 }
 
-static void emgd_crtc_prepare(struct drm_crtc *crtc)
-{
-	printk(KERN_ALERT "emgd_crtc_prepare: STUB\n");
-}
 
-static void emgd_crtc_commit(struct drm_crtc *crtc)
+
+/**
+ * emgd_fbdev_destroy
+ *
+ * Cleans up resources allocated during emgd_fbdev_init.
+ * Since emgd_fbdev_init() calls drm_fb_helper_initial_config() which leads
+ * to a call to emgd_fb_find_or_create_single(), we are also cleaning up
+ * resources allocated in that function as well.  It is unclear if this
+ * clean up is necessary because KMS APIs maybe smart enough to call
+ * the corresponding destory function.
+ *
+ * @param priv (IN) EMGD private DRM data structure
+ *
+ * @return None
+ */
+static void emgd_fbdev_destroy(drm_emgd_priv_t *priv)
 {
-	printk(KERN_ALERT "emgd_crtc_commit: STUB\n");
-}
+	emgd_fbdev_t           *emgd_fbdev = NULL;
+	struct drm_framebuffer *fb         = NULL;
+	struct fb_info         *info       = NULL;
 
+	EMGD_TRACE_ENTER;
 
-static void emgd_crtc_save(struct drm_crtc *crtc)
-{
-	printk(KERN_ALERT "emgd_crtc_save: STUB\n");
-}
+	emgd_fbdev = priv->emgd_fbdev;
+	fb         = &emgd_fbdev->emgd_fb->base;
 
-static void emgd_crtc_restore(struct drm_crtc *crtc)
-{
-	printk(KERN_ALERT "emgd_crtc_restore: STUB\n");
+	if (priv->fbdev) {
+		info = priv->fbdev;
+
+		unregister_framebuffer(info);
+
+		if (info->cmap.len) {
+			fb_dealloc_cmap(&info->cmap);
+		}
+
+		priv->context->dispatch.gmm_unmap(info->screen_base);
+		framebuffer_release(info);
+	}
+
+	drm_framebuffer_cleanup(fb); /* Is this the right place to call this? */
+	priv->context->dispatch.gmm_free(priv->initfb_info.fb_base_offset);
+
+	kfree(emgd_fbdev->emgd_fb);
+	emgd_fbdev->emgd_fb = NULL;
+
+	EMGD_TRACE_EXIT;
 }
 
-static int emgd_crtc_cursor_set(struct drm_crtc *crtc,
-		struct drm_file *file_priv, uint32_t handle,
-		uint32_t width, uint32_t height)
+
+
+#if 0
+/*------------------------------------------------------------------------------
+ * drm_fb_helper related functions.  These will be removed once we have our
+ * own version of drm_fb_helper (in emgd_fbcon.c)
+ *------------------------------------------------------------------------------
+ */
+static int emgd_fb_find_or_create_single(struct drm_fb_helper *helper,
+			struct drm_fb_helper_surface_size *sizes);
+static void emgd_fb_gamma_set(struct drm_crtc *crtc,
+				u16 red, u16 green, u16 blue, int regno);
+static void emgd_fb_gamma_get(struct drm_crtc *crtc,
+				u16 *red, u16 *green, u16 *blue, int regno);
+
+
+
+/* FIXME:  This should be removed. */
+static struct drm_fb_helper_funcs emgd_fb_helper_funcs = {
+	.gamma_set = emgd_fb_gamma_set,
+	.gamma_get = emgd_fb_gamma_get,
+	.fb_probe  = emgd_fb_find_or_create_single,
+};
+
+
+
+/**
+ * emgd_fb_create
+ *
+ * This function creates a frame buffer using the surface information contained
+ * in surface_info.  The working assumption is this function will only be
+ * called once at initialization time.  So the buffer allocated here is
+ * for the console.
+ *
+ * @param emgd_fbdev   (IN) Framebuffer devices to attach the new FB to
+ * @param surface_info (IN) Information about the surface to be allocated
+ */
+static int emgd_fb_create(emgd_fbdev_t *emgd_fbdev,
+		struct drm_fb_helper_surface_size *surface_info)
 {
-	printk(KERN_ALERT "emgd_crtc_cursor_set: STUB\n");
+	drm_emgd_priv_t        *priv    = emgd_fbdev->priv;
+	struct drm_device      *dev     = priv->ddev;
+	struct fb_info         *info    = NULL;
+	struct drm_mode_fb_cmd  mode_cmd;
+	struct drm_framebuffer *fb       = NULL;
+	igd_context_t          *context  = NULL;
+	int                     ret;
+	unsigned long           size;
+	unsigned long           offset = 0;
+
+	EMGD_TRACE_ENTER;
+
+
+	context = priv->context;
+
+	priv->initfb_info.width        = surface_info->surface_width;
+	priv->initfb_info.height       = surface_info->surface_height;
+	priv->initfb_info.screen_pitch = 0;
+	priv->initfb_info.pixel_format = IGD_PF_ARGB32;
+
+	ret = context->dispatch.gmm_alloc_surface(
+								&priv->initfb_info.fb_base_offset,
+								 priv->initfb_info.pixel_format,
+								&priv->initfb_info.width,
+								&priv->initfb_info.height,
+								&priv->initfb_info.screen_pitch,
+								&size,
+								IGD_GMM_ALLOC_TYPE_RESERVATION,
+								&priv->initfb_info.flags);
+	if (ret) {
+		EMGD_ERROR_EXIT("Allocation of buffer failed: %d", ret);
+		return -ENOMEM;
+	}
+
+	priv->initfb_info.allocated = 1;
+	priv->initfb_info.visible_offset = priv->initfb_info.fb_base_offset;
+
+	mode_cmd.handle = EMGD_INITIAL_FRAMEBUFFER;
+	mode_cmd.pitch  = priv->initfb_info.screen_pitch;
+	mode_cmd.width  = surface_info->surface_width;
+	mode_cmd.height = surface_info->surface_height;
+	mode_cmd.bpp    = surface_info->surface_bpp;
+	mode_cmd.depth  = surface_info->surface_depth;
+
+	/* Allocate fb_info */
+	info = kzalloc(sizeof(struct fb_info), GFP_KERNEL);
+	if (info == NULL) {
+		EMGD_ERROR_EXIT("Allocation of fb_info failed");
+		context->dispatch.gmm_free(priv->initfb_info.fb_base_offset);
+		return -ENOMEM;
+	}
+	info->par   = emgd_fbdev;
+
+	/* Allocate emgd_framebuffer_t */
+	emgd_fbdev->emgd_fb = kzalloc(sizeof(emgd_framebuffer_t), GFP_KERNEL);
+	if (!emgd_fbdev->emgd_fb) {
+		EMGD_ERROR_EXIT("Allocation of emgd_framebuffer_t failed");
+		context->dispatch.gmm_free(priv->initfb_info.fb_base_offset);
+		kfree(info);
+		info = NULL;
+		return -ENOMEM;
+	}
+
+	/* Initialize the framebuffer */
+	ret = emgd_framebuffer_init(dev, emgd_fbdev->emgd_fb, &mode_cmd,
+			EMGD_INITIAL_FRAMEBUFFER);
+	if (ret) {
+		context->dispatch.gmm_free(priv->initfb_info.fb_base_offset);
+		kfree(info);
+		info = NULL;
+		kfree(emgd_fbdev->emgd_fb);
+		emgd_fbdev->emgd_fb = NULL;
+		return ret;
+	}
+
+
+
+	info->flags = FBINFO_DEFAULT /* | FBINFO_CAN_FORCE_OUTPUT */;
+	info->fbops = (struct fb_ops*) &emgd_fb_ops;
+	strcpy(info->fix.id, "emgdfb"); /* fix.id is 16 bytes long */
+	fb = &emgd_fbdev->emgd_fb->base;
+	emgd_fbdev->helper.fb    = fb;
+	emgd_fbdev->helper.fbdev = info;
+	priv->fbdev              = info;
+
+	EMGD_DEBUG("EMGD: Call fb_alloc_cmap()");
+	ret = fb_alloc_cmap(&info->cmap, 256, 0);
+	if (ret) {
+		EMGD_ERROR("%s: Can't allocate color map", info->fix.id);
+		//mutex_unlock(&dev->struct_mutex);
+		return -ENOMEM;
+	}
+
+	/*
+	 * Does this need to be filled in and if so, with what?  Right now
+	 * I'm trying to reuse the framebuffer that was already configured by
+	 * the EMGD code.
+	 *
+	 * setup aperture base/size for vesafb takeover
+	 */
+	info->apertures = alloc_apertures(1);
+	if (!info->apertures) {
+		EMGD_ERROR("%s: Can't allocate apertures", info->fix.id);
+		//mutex_unlock(&dev->struct_mutex);
+		return -ENOMEM;
+	}
+
+	info->apertures->ranges[0].base =
+		(unsigned long)priv->context->device_context.virt_gttadr;
+	info->apertures->ranges[0].size =
+		priv->context->device_context.gatt_pages << PAGE_SHIFT;
+
+	//mutex_unlock(&dev->struct_mutex);
+	/*
+	 * FIXME: What is fix.smem_start vs screen_base?
+	 *
+	 * smem_start is the start of frame buffer mem (physical address), does
+	 * that mean GTT or that it expects a physical contigous block in real
+	 * memory?
+	 *
+	 * screen_base is a virtual address
+	 *
+	 */
+	/* Set up framebuffer surface */
+	EMGD_DEBUG("EMGD: Call pci_resource_start()");
+	info->fix.smem_start =  pci_resource_start(dev->pdev, PSB_GATT_RESOURCE) +
+		priv->initfb_info.fb_base_offset;
+	info->fix.smem_len = size;
+
+	/* Get kernel virtual memory address of framebuffer */
+	EMGD_DEBUG("EMGD: Call gmm_map()");
+	info->screen_base =
+		priv->context->dispatch.gmm_map(priv->initfb_info.fb_base_offset);
+	if (!info->screen_base) {
+		EMGD_ERROR("%s: Can't map framebuffer surface", info->fix.id);
+		return -ENOSPC;
+	}
+	info->screen_size = size;
+
+	info->pixmap.size         = 64 * 1024;
+	info->pixmap.buf_align    = 8;
+	info->pixmap.access_align = 32;
+	info->pixmap.flags        = FB_PIXMAP_SYSTEM;
+	info->pixmap.scan_align   = 1;
+
+	EMGD_DEBUG("Frame buffer %dx%d @ 0x%08lx",
+			fb->width, fb->height, offset);
+
+	EMGD_DEBUG("EMGD: Call vga_switcheroo_client_fb_set()");
+	vga_switcheroo_client_fb_set(dev->pdev, info);
+
+	EMGD_TRACE_EXIT;
 	return 0;
 }
 
-static int emgd_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)
+
+
+/*
+ * emgd_fb_gamma_set
+ *
+ * Set the gamma values for a framebuffer for a particular
+ * index.
+ *
+ * @param crtc     (IN) the drm pipe
+ * @param red      (IN) red gamma value
+ * @param green    (IN) green gamma value
+ * @param blue     (IN) blue gamma value
+ * @param regno    (IN) index value which we are setting
+ *
+ * @return None
+ */
+static void emgd_fb_gamma_set(struct drm_crtc *crtc,
+		u16 red, u16 green, u16 blue,
+		int regno)
 {
-	printk(KERN_ALERT "emgd_crtc_cursor_move: STUB\n");
-	return 0;
+	emgd_crtc_t *emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+
+	EMGD_TRACE_ENTER;
+	emgd_crtc->lut_r[regno] = red >> 8;
+	emgd_crtc->lut_g[regno] = green >> 8;
+	emgd_crtc->lut_b[regno] = blue >> 8;
+	EMGD_TRACE_EXIT;
 }
 
-static void emgd_crtc_gamma_set(struct drm_crtc *crtc,
-		unsigned short *red, unsigned short *green, unsigned short *blue,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
-		uint32_t start,
-#endif
-		uint32_t size)
+
+/*
+ * emgd_fb_gamma_get
+ *
+ * Set the gamma values for a framebuffer for a particular
+ * index.
+ *
+ * @param crtc     (IN) the drm pipe
+ * @param red      (OUT) red gamma value
+ * @param green    (OUT) green gamma value
+ * @param blue     (OUT) blue gamma value
+ * @param regno    (IN) index value which we are getting
+ *
+ * @return None
+ */
+static void emgd_fb_gamma_get(struct drm_crtc *crtc,
+		u16 *red, u16 *green, u16 *blue,
+		int regno)
 {
-	printk(KERN_ALERT "emgd_crtc_gamma_set: STUB\n");
+	emgd_crtc_t *emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+
+	EMGD_TRACE_ENTER;
+	*red = (emgd_crtc->lut_r[regno] << 8);
+	*blue = (emgd_crtc->lut_b[regno] << 8);
+	*green = (emgd_crtc->lut_g[regno] << 8);
+	EMGD_TRACE_EXIT;
 }
 
-static void emgd_crtc_destroy(struct drm_crtc *crtc)
+
+
+/**
+ * emgd_fb_find_or_create_single
+ *
+ * If there is no frame buffer associated with "helper", then allocate a new
+ * one.  Otherwise, reuse the existing one.
+ *
+ * @param helper       (IN) TBD
+ * @param surface_info (IN) Surface info
+ *
+ * @return None
+ */
+static int emgd_fb_find_or_create_single(struct drm_fb_helper *helper,
+			struct drm_fb_helper_surface_size *surface_info)
 {
-	printk(KERN_ALERT "emgd_crtc_destroy: STUB\n");
+	emgd_fbdev_t *fbdev  = container_of(helper, emgd_fbdev_t, helper);
+	int           new_fb = false;
+
+
+	EMGD_TRACE_ENTER;
+
+	if (!helper->fb) {
+		int ret = emgd_fb_create(fbdev, surface_info);
+		if (ret) {
+			return ret;
+		}
+
+		new_fb = true;
+	}
+
+	EMGD_TRACE_EXIT;
+
+	return new_fb;
 }
+
+#endif
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_fbcon.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_fbcon.c
new file mode 100644
index 0000000..7d0a19b
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_fbcon.c
@@ -0,0 +1,795 @@
+/*
+ *-----------------------------------------------------------------------------
+ * Filename: emgd_fbcon.c
+ * $Revision: 1.2 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2011, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ * Description:
+ *  Framebuffer Console related functions.  This is the equivalent of
+ *  what is in drm_fb_helper.c, a set of functions for configuring the
+ *  framebuffer console.
+ *-----------------------------------------------------------------------------
+ */
+
+#define MODULE_NAME hal.oal
+
+#include <drmP.h>
+#include <drm_crtc_helper.h>
+#include <linux/vga_switcheroo.h>
+
+
+#include "user_config.h"
+#include "drm_emgd_private.h"
+#include "mode_dispatch.h"
+
+
+/*------------------------------------------------------------------------------
+ * Global Variables
+ *------------------------------------------------------------------------------
+ */
+extern emgd_drm_config_t config_drm;
+
+
+
+/*------------------------------------------------------------------------------
+ * Formal Declaration
+ *------------------------------------------------------------------------------
+ */
+extern int emgd_framebuffer_init(struct drm_device *dev,
+			emgd_framebuffer_t *emgd_fb,
+			struct drm_mode_fb_cmd *mode_cmd,
+			unsigned long handle);
+
+
+/* Sets up initial display configuration */
+int  emgd_fbcon_initial_config(emgd_fbdev_t *emgd_fbdev);
+
+
+/*------------------------------------------------------------------------------
+ * These are called by the framebuffer console
+ *------------------------------------------------------------------------------
+ */
+static int  alloc_initial_fb(emgd_fbdev_t *emgd_fbdev);
+static void fill_fix(emgd_fbdev_t *emgd_fbdev, struct fb_info *info);
+static void fill_var(emgd_fbdev_t *emgd_fbdev, struct fb_info *info);
+
+
+
+/*------------------------------------------------------------------------------
+ * FBCON Functions
+ * These are called by the framebuffer console
+ *------------------------------------------------------------------------------
+ */
+static int emgd_fbcon_setcolreg(unsigned int regno,
+			unsigned int red, unsigned int green, unsigned int blue,
+			unsigned int transp, struct fb_info *info);
+static int emgd_fbcon_pan_display(struct fb_var_screeninfo *var,
+			struct fb_info *info);
+static int emgd_fbcon_set_par(struct fb_info *info);
+static int emgd_fbcon_check_var(struct fb_var_screeninfo *var,
+			struct fb_info *info);
+static int emgd_fbcon_blank(int blank, struct fb_info *info);
+static int emgd_fbcon_setcmap(struct fb_cmap *cmap, struct fb_info *info);
+
+
+/* This is called from within FBCON, the framebuffer console */
+const struct fb_ops emgd_fb_ops = {
+	.owner          = THIS_MODULE,
+	.fb_check_var   = emgd_fbcon_check_var,
+	.fb_set_par     = emgd_fbcon_set_par,
+	.fb_setcolreg   = emgd_fbcon_setcolreg,
+	.fb_fillrect    = cfb_fillrect,
+	.fb_copyarea    = cfb_copyarea,
+	.fb_imageblit   = cfb_imageblit,
+	.fb_pan_display = emgd_fbcon_pan_display,
+	.fb_blank       = emgd_fbcon_blank,
+	.fb_setcmap     = emgd_fbcon_setcmap,
+	/* .fb_debug_enter = drm_fb_helper_debug_enter, */
+	/* .fb_debug_leave = drm_fb_helper_debug_leave, */
+};
+
+
+
+static void fill_fix(emgd_fbdev_t *emgd_fbdev, struct fb_info *info)
+{
+	struct drm_framebuffer *fb = &emgd_fbdev->emgd_fb->base;
+
+	info->fix.type        = FB_TYPE_PACKED_PIXELS;
+	info->fix.visual      = FB_VISUAL_TRUECOLOR;
+	info->fix.mmio_start  = 0;
+	info->fix.mmio_len    = 0;
+	info->fix.type_aux    = 0;
+	info->fix.xpanstep    = 1; /* doing it in hw */
+	info->fix.ypanstep    = 1; /* doing it in hw */
+	info->fix.ywrapstep   = 0;
+	info->fix.accel       = FB_ACCEL_NONE;
+	info->fix.type_aux    = 0;
+	info->fix.line_length = fb->pitch;
+}
+
+
+
+/**
+ * fill_var
+ *
+ * Fills in the fb_info structure.  This function is called by alloc_init_fb,
+ * and as such an actual mode would not have been set yet.  This means we
+ * don't really know what "var.xres" and "var.yres" will be, so we have to
+ * make the assumption that "config_drm->width" and "config_drm->height"
+ * sepcify the resolution for the eventual mode.
+ *
+ * @param emgd_fbdev [IN]    FB device that contains the relevant information
+ * @param info       [INOUT] fb_info structure to fill in
+ *
+ * @return 0 on success, an error code otherwise
+ */
+static void fill_var(emgd_fbdev_t *emgd_fbdev, struct fb_info *info)
+{
+	struct drm_framebuffer *fb = &emgd_fbdev->emgd_fb->base;
+
+
+	/* Actual resolution for the mode.  We are assuming here that the
+	 * mode requested through config_drm->width and config_drm->height can
+	 * be set successfully */
+	info->var.xres           = config_drm.width;
+	info->var.yres           = config_drm.height;
+
+	/* Size of the framebuffer */
+	info->var.xres_virtual   = fb->width;
+	info->var.yres_virtual   = fb->height;
+
+	info->pseudo_palette     = emgd_fbdev->pseudo_palette;
+	info->var.bits_per_pixel = fb->bits_per_pixel;
+	info->var.accel_flags    = FB_ACCELF_TEXT;
+	info->var.xoffset        = 0;
+	info->var.yoffset        = 0;
+	info->var.activate       = FB_ACTIVATE_NOW;
+	info->var.height         = -1;
+	info->var.width          = -1;
+
+	switch (fb->depth) {
+	case 8:
+		info->var.red.offset = 0;
+		info->var.green.offset = 0;
+		info->var.blue.offset = 0;
+		info->var.red.length = 8; /* 8bit DAC */
+		info->var.green.length = 8;
+		info->var.blue.length = 8;
+		info->var.transp.offset = 0;
+		info->var.transp.length = 0;
+		break;
+	case 15:
+		info->var.red.offset = 10;
+		info->var.green.offset = 5;
+		info->var.blue.offset = 0;
+		info->var.red.length = 5;
+		info->var.green.length = 5;
+		info->var.blue.length = 5;
+		info->var.transp.offset = 15;
+		info->var.transp.length = 1;
+		break;
+	case 16:
+		info->var.red.offset = 11;
+		info->var.green.offset = 5;
+		info->var.blue.offset = 0;
+		info->var.red.length = 5;
+		info->var.green.length = 6;
+		info->var.blue.length = 5;
+		info->var.transp.offset = 0;
+		break;
+	case 24:
+		info->var.red.offset = 16;
+		info->var.green.offset = 8;
+		info->var.blue.offset = 0;
+		info->var.red.length = 8;
+		info->var.green.length = 8;
+		info->var.blue.length = 8;
+		info->var.transp.offset = 0;
+		info->var.transp.length = 0;
+		break;
+	case 32:
+		info->var.red.offset = 16;
+		info->var.green.offset = 8;
+		info->var.blue.offset = 0;
+		info->var.red.length = 8;
+		info->var.green.length = 8;
+		info->var.blue.length = 8;
+		info->var.transp.offset = 24;
+		info->var.transp.length = 8;
+		break;
+	default:
+		break;
+	}
+}
+
+
+
+/**
+ * alloc_initial_fb
+ *
+ * This function creates a frame buffer using the config_drm.width and
+ * config_drm.height.  The working assumption is this function will only be
+ * called once at initialization time.  So the buffer allocated here is
+ * for the console.
+ * FIXME:  need to make sure resources are freed properly for all the
+ *         failed cases.
+ *
+ * @param emgd_fbdev [IN] Framebuffer device to allocate a buffer for.
+ *
+ * @return 0 on success, an error code otherwise
+ */
+static int alloc_initial_fb(emgd_fbdev_t *emgd_fbdev)
+{
+	struct fb_info         *info     = NULL;
+	struct drm_device      *dev      = emgd_fbdev->priv->ddev;
+	drm_emgd_priv_t        *priv     = emgd_fbdev->priv;
+	igd_context_t          *context;
+	int                     ret;
+	unsigned long           size;
+	struct drm_mode_fb_cmd  mode_cmd;
+
+	EMGD_TRACE_ENTER;
+
+
+	context = priv->context;
+
+	memset(&priv->initfb_info, 0, sizeof(priv->initfb_info));
+   	priv->initfb_info.width        = config_drm.width;
+	priv->initfb_info.height       = config_drm.height;
+	priv->initfb_info.pixel_format = IGD_PF_ARGB32;
+
+	ret = context->dispatch.gmm_alloc_surface(
+								&priv->initfb_info.fb_base_offset,
+								 priv->initfb_info.pixel_format,
+								&priv->initfb_info.width,
+								&priv->initfb_info.height,
+								&priv->initfb_info.screen_pitch,
+								&size,
+								IGD_GMM_ALLOC_TYPE_RESERVATION,
+								&priv->initfb_info.flags);
+	if (ret) {
+		EMGD_ERROR_EXIT("Allocation of buffer failed: %d", ret);
+		return -ENOMEM;
+	}
+
+	priv->initfb_info.allocated      = 1;
+	priv->initfb_info.visible_offset = priv->initfb_info.fb_base_offset;
+
+
+	/* Allocate emgd_framebuffer_t */
+	emgd_fbdev->emgd_fb = kzalloc(sizeof(emgd_framebuffer_t), GFP_KERNEL);
+
+	if (!emgd_fbdev->emgd_fb) {
+		EMGD_ERROR_EXIT("Allocation of emgd_framebuffer_t failed");
+		context->dispatch.gmm_free(priv->initfb_info.fb_base_offset);
+		return -ENOMEM;
+	}
+
+
+	/* Initialize emgd_framebuffer_t */
+	mode_cmd.handle = EMGD_INITIAL_FRAMEBUFFER;
+	mode_cmd.pitch  = priv->initfb_info.screen_pitch;
+	mode_cmd.width  = priv->initfb_info.width;
+	mode_cmd.height = priv->initfb_info.height;
+	mode_cmd.bpp    = IGD_PF_BPP(priv->initfb_info.pixel_format);
+	mode_cmd.depth  = mode_cmd.bpp;  /* Ok for 32bpp, may not work for 16bpp */
+
+	ret = emgd_framebuffer_init(dev, emgd_fbdev->emgd_fb, &mode_cmd,
+			EMGD_INITIAL_FRAMEBUFFER);
+	if (ret) {
+		kfree(emgd_fbdev->emgd_fb);
+		emgd_fbdev->emgd_fb = NULL;
+
+		context->dispatch.gmm_free(priv->initfb_info.fb_base_offset);
+
+		return ret;
+	}
+
+
+	/* Allocate fb_info */
+	info = kzalloc(sizeof(struct fb_info), GFP_KERNEL);
+	if (NULL == info) {
+		EMGD_ERROR_EXIT("Allocation of fb_info failed");
+		drm_framebuffer_cleanup(&emgd_fbdev->emgd_fb->base);
+
+		kfree(emgd_fbdev->emgd_fb);
+		emgd_fbdev->emgd_fb = NULL;
+
+		context->dispatch.gmm_free(priv->initfb_info.fb_base_offset);
+
+		return -ENOMEM;
+	}
+
+
+	info->par   = emgd_fbdev; /* Private data for all FBCON functions  */
+	info->flags = FBINFO_DEFAULT; /* | FBINFO_CAN_FORCE_OUTPUT */
+	info->fbops = (struct fb_ops*) &emgd_fb_ops;
+	strcpy(info->fix.id, "emgdfb"); /* fix.id is 16 bytes long */
+
+	priv->fbdev = info;
+
+	EMGD_DEBUG("EMGD: Call fb_alloc_cmap()");
+	ret = fb_alloc_cmap(&info->cmap, 256, 0);
+	if (ret) {
+		EMGD_ERROR("%s: Can't allocate color map", info->fix.id);
+
+		return -ENOMEM;
+	}
+
+	/*
+	 * Does this need to be filled in and if so, with what?  Right now
+	 * I'm trying to reuse the framebuffer that was already configured by
+	 * the EMGD code.
+	 *
+	 * setup aperture base/size for vesafb takeover
+	 */
+	info->aperture_base =
+		(unsigned long)context->device_context.virt_gttadr;
+	info->aperture_size =
+		context->device_context.gatt_pages << PAGE_SHIFT;
+
+
+	/*
+	 * FIXME: What is fix.smem_start vs screen_base?
+	 *
+	 * smem_start is the start of frame buffer mem (physical address), does
+	 * that mean GTT or that it expects a physical contigous block in real
+	 * memory?
+	 *
+	 * screen_base is a virtual address
+	 *
+	 */
+	/* Set up framebuffer surface */
+	EMGD_DEBUG("EMGD: Call pci_resource_start()");
+	info->fix.smem_start = pci_resource_start(dev->pdev, PSB_GATT_RESOURCE) +
+						   priv->initfb_info.fb_base_offset;
+	info->fix.smem_len   = size;
+
+	/* Get kernel virtual memory address of framebuffer */
+	EMGD_DEBUG("EMGD: Call gmm_map()");
+	info->screen_base =
+			context->dispatch.gmm_map(priv->initfb_info.fb_base_offset);
+	if (!info->screen_base) {
+		EMGD_ERROR("%s: Can't map framebuffer surface", info->fix.id);
+		return -ENOSPC;
+	}
+
+	info->screen_size         = size;
+	info->pixmap.size         = 64 * 1024;
+	info->pixmap.buf_align    = 8;
+	info->pixmap.access_align = 32;
+	info->pixmap.flags        = FB_PIXMAP_SYSTEM;
+	info->pixmap.scan_align   = 1;
+
+	/* Initialize info->fix and info->var */
+	fill_fix(emgd_fbdev, info);
+	fill_var(emgd_fbdev, info);
+
+	EMGD_DEBUG("Frame buffer %dx%d @ 0x%08lx",
+			priv->initfb_info.width,
+			priv->initfb_info.height, priv->initfb_info.fb_base_offset);
+
+	EMGD_DEBUG("EMGD: Call vga_switcheroo_client_fb_set()");
+	vga_switcheroo_client_fb_set(dev->pdev, info);
+
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+
+
+
+/**
+ * emgd_fbcon_setcmap
+ *
+ * Sets color map for the framebuffer console device.  For now, we will set
+ * both CRTC to the same color map, regardless of which display configuration
+ * we are in.  There may be a case in the future where we will have to set
+ * the color map for both CRTCs differently.
+ *
+ * We will also assume that we are dealing with FB_VISUAL_TRUECOLOR because
+ * our alloc_initial_fb() function will only allocate framebuffer of this
+ * type.
+ *
+ * @param cmap [IN] Input color map
+ * @param info [IN] framebuffer to set
+ *
+ * @return 0 on success
+ */
+static int emgd_fbcon_setcmap(struct fb_cmap *cmap, struct fb_info *info)
+{
+	emgd_fbdev_t      *emgd_fbdev = info->par;
+	struct drm_device *dev        = emgd_fbdev->priv->ddev;
+	int                ret = 0;
+	u16               *red, *green, *blue, *transp;
+	u16                hred, hgreen, hblue, htransp;
+	u32                new_value, mask;
+	int                i, start_index;
+	struct drm_crtc   *crtc;
+
+
+	EMGD_TRACE_ENTER;
+
+
+	/* Set all the CRTCs to the same color map */
+	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+		red         = cmap->red;
+		green       = cmap->green;
+		blue        = cmap->blue;
+		transp      = cmap->transp;
+		start_index = cmap->start;
+
+		for(i = 0; i < cmap->len; i++) {
+			htransp = 0xffff;
+			hred    = *red++;
+			hgreen  = *green++;
+			hblue   = *blue++;
+
+			if (transp) {
+				htransp = *transp++;
+			}
+
+			/* The palette only has 17 entries */
+			if (16 < start_index ) {
+				ret = -IGD_ERROR_INVAL_PARAM;
+				break;
+			}
+
+			hred   >>= (16 - info->var.red.length);
+			hgreen >>= (16 - info->var.green.length);
+			hblue  >>= (16 - info->var.blue.length);
+
+			new_value = (hred   << info->var.red.offset)   |
+						(hgreen << info->var.green.offset) |
+						(hblue  << info->var.blue.offset);
+
+			if (info->var.transp.length > 0) {
+				mask = (1 << info->var.transp.length) - 1;
+				mask <<= info->var.transp.offset;
+				new_value |= mask;
+			}
+
+			((u32 *) info->pseudo_palette)[start_index] = new_value;
+
+			start_index++;
+		}
+
+		if (ret) {
+			EMGD_ERROR("Invalid parameter.");
+			break;
+		}
+
+		((struct drm_crtc_helper_funcs *)crtc->helper_private)->load_lut(crtc);
+	}
+
+
+	EMGD_TRACE_EXIT;
+
+	return ret;
+}
+
+
+
+/*
+ * Currently, we are using the device indpendent DRM functions
+ * for these.  If we need to do special processing, then uncomment
+ * these functions and hook them into the function table.
+ */
+static int emgd_fbcon_check_var(struct fb_var_screeninfo *var,
+		struct fb_info *info)
+{
+	int ret = 0;
+
+	EMGD_TRACE_ENTER;
+
+
+
+	EMGD_TRACE_EXIT;
+
+	return ret;
+}
+
+
+
+static int emgd_fbcon_set_par(struct fb_info *info)
+{
+	int ret = 0;
+
+	EMGD_TRACE_ENTER;
+
+	// set mode here:  crtc->set_config
+    // look at drm_fb_helper_set_par for reference
+
+
+	EMGD_TRACE_EXIT;
+
+	return ret;
+}
+
+
+
+static int emgd_fbcon_setcolreg(unsigned int regno,
+		unsigned int red, unsigned int green, unsigned int blue,
+		unsigned int transp, struct fb_info *info)
+{
+	EMGD_TRACE_ENTER;
+
+	EMGD_DEBUG("STUBED emgd_fbcon_setcolreg");
+
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+
+
+
+static int emgd_fbcon_pan_display(struct fb_var_screeninfo *var,
+		struct fb_info *info)
+{
+	int ret = 0;
+
+	EMGD_TRACE_ENTER;
+
+
+
+	EMGD_TRACE_EXIT;
+	return ret;
+}
+
+
+
+/*
+ * Currently, we are using the device indpendent DRM functions
+ * for these.  If we need to do special processing, then uncomment
+ * these functions and hook them into the function table.
+ */
+static int emgd_fbcon_blank(int blank, struct fb_info *info)
+{
+	int ret = 0;
+	struct drm_device *dev;
+	struct drm_crtc *crtc = NULL;
+	struct drm_encoder *encoder = NULL;
+	struct drm_encoder_helper_funcs *encoder_funcs;
+	emgd_fbdev_t *emgd_fbdev;
+
+	EMGD_TRACE_ENTER;
+
+	emgd_fbdev = info->par;
+	dev	       = emgd_fbdev->priv->ddev;
+
+	switch(blank) {
+	case FB_BLANK_UNBLANK:
+		EMGD_DEBUG("Turn on Display");
+
+		list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+
+			((struct drm_crtc_helper_funcs *)crtc->helper_private)->dpms(crtc,
+				DRM_MODE_DPMS_ON);
+
+			list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+				if(encoder->crtc == crtc) {
+					encoder_funcs = encoder->helper_private;
+					encoder_funcs->dpms(encoder, DRM_MODE_DPMS_ON);
+				}
+			}
+		}
+		break;
+	case FB_BLANK_NORMAL:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_POWERDOWN:
+		EMGD_DEBUG("Turn off Display");
+
+		list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+			list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+				if(encoder->crtc == crtc) {
+					encoder_funcs = encoder->helper_private;
+					encoder_funcs->dpms(encoder, DRM_MODE_DPMS_OFF);
+				}
+			}
+
+			((struct drm_crtc_helper_funcs *)crtc->helper_private)->dpms(crtc,
+				DRM_MODE_DPMS_OFF);
+		}
+		break;
+	default:
+		EMGD_DEBUG("ERROR: Incorrect FB_BLANK value passed");
+		break;
+	}
+
+	EMGD_TRACE_EXIT;
+
+	return ret;
+}
+
+
+
+/*
+ * emgd_fbcon_initial_config
+ *
+ * Uses configurations in config_drm to set the start-up configuration.
+ * We will not support configurations that require more than one framebuffer
+ * at DRM boot time.  The fallback configuration is SINGLE.
+ *
+ * @param emgd_fbdev (IN) Framebuffer device to initialize
+ *
+ * @return 0 on success, an error code otherwise
+ */
+int emgd_fbcon_initial_config(emgd_fbdev_t *emgd_fbdev)
+{
+	int                    err;
+	unsigned long         *dc_assigned;
+	igd_context_t         *context;
+	unsigned short         port_number;
+	emgd_crtc_t           *emgd_crtc;
+	struct drm_crtc       *crtc         = NULL;
+	igd_display_context_t *primary      = NULL, *secondary = NULL;
+	bool                   mode_set_ret = FALSE;
+	struct drm_device     *dev          = emgd_fbdev->priv->ddev;
+
+	struct drm_display_mode primary_mode, secondary_mode;
+
+	EMGD_TRACE_ENTER;
+
+
+	context = ((drm_emgd_priv_t *)dev->dev_private)->context;
+
+
+	/* Basic error checking.  SINGLE is the fallback configuration */
+	if( IGD_DISPLAY_CONFIG_CLONE  != config_drm.dc &&
+		IGD_DISPLAY_CONFIG_SINGLE != config_drm.dc ) {
+		config_drm.dc = IGD_DISPLAY_CONFIG_SINGLE;
+	}
+
+
+	/*******************************************************
+	 * Allocate DSP for the desired DC.  This is to make sure the
+	 * display context is valid for subsequent operations.  The
+	 * dc_assigned coming out will contain port info in addition to
+	 * display configuration.
+	 ******************************************************/
+	/* Query for the best DC that matches the request */
+	err = context->dispatch.query_dc(context, config_drm.dc,
+								&dc_assigned, IGD_QUERY_DC_INIT);
+	if (err) {
+		EMGD_ERROR_EXIT("Cannot initialize the display as requested.\n"
+				"The query_dc() function returned %d.", err);
+		return -IGD_ERROR_INVAL;
+	}
+
+	emgd_fbdev->priv->dc = *dc_assigned;
+
+
+	/* Allocate and initialize igd_display_context */
+	err = context->mod_dispatch.dsp_alloc(context, *dc_assigned, 0);
+	if (err) {
+		EMGD_ERROR_EXIT("Cannot initialize display context.\n"
+			"The dsp_alloc() function returned %d.", err);
+		return -IGD_ERROR_INVAL;
+	}
+
+	/* Initialize pipe->owner for PRIMARY and SECONDARY */
+	port_number = IGD_DC_PRIMARY(*dc_assigned);
+
+	primary = context->mod_dispatch.dsp_display_list[port_number];
+	PIPE(primary)->owner = primary;
+
+	if (IGD_DC_SECONDARY(*dc_assigned)) {
+		port_number = IGD_DC_SECONDARY(*dc_assigned);
+		secondary = context->mod_dispatch.dsp_display_list[port_number];
+		PIPE(secondary)->owner = secondary;
+	}
+
+
+
+	/*******************************************************
+	 * Allocate framebuffer
+	 ******************************************************/
+	if (0 == (err = alloc_initial_fb(emgd_fbdev))) {
+
+		/* Attach the frame buffer to the CRTC(s)  */
+		list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+			emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+
+			if (PIPE(primary) == emgd_crtc->igd_pipe) {
+				crtc->fb = &emgd_fbdev->emgd_fb->base;
+			}
+
+			/* Attach frame buffer to the secondary CRTC, if necessary */
+			if (IGD_DC_SECONDARY(*dc_assigned) &&
+				PIPE(secondary) == emgd_crtc->igd_pipe) {
+				crtc->fb = &emgd_fbdev->emgd_fb->base;
+			}
+		}
+
+
+		err = register_framebuffer(emgd_fbdev->priv->fbdev);
+
+		EMGD_DEBUG("fb%d: %s framebuffer device",
+			emgd_fbdev->priv->fbdev->node,
+			emgd_fbdev->priv->fbdev->fix.id);
+	}
+
+
+	/*******************************************************
+	 * Set Mode for Primary
+	 ******************************************************/
+	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+		emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+
+		if (PIPE(primary) == emgd_crtc->igd_pipe) {
+
+			memset(&primary_mode, 0, sizeof(primary_mode));
+			primary_mode.crtc_hdisplay = config_drm.width;
+			primary_mode.crtc_vdisplay = config_drm.height;
+			primary_mode.vrefresh      = config_drm.refresh;
+
+			mode_set_ret = drm_crtc_helper_set_mode(crtc,
+								&primary_mode,
+								0, 0,
+								NULL);
+			break;
+		}
+	}
+
+	if (FALSE == mode_set_ret) {
+		EMGD_ERROR_EXIT("Failed to set mode on primary CRTC.  Abort.");
+		return -IGD_ERROR_INVAL;
+	}
+
+
+	/*******************************************************
+	 * Set Mode for Secondary, if necessary
+	 ******************************************************/
+	if (IGD_DC_SECONDARY(*dc_assigned)) {
+
+		list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+			emgd_crtc = container_of(crtc, emgd_crtc_t, base);
+
+			if (PIPE(secondary) == emgd_crtc->igd_pipe) {
+
+				memset(&secondary_mode, 0, sizeof(secondary_mode));
+				secondary_mode.crtc_hdisplay = config_drm.width;
+				secondary_mode.crtc_vdisplay = config_drm.height;
+				secondary_mode.vrefresh      = config_drm.refresh;
+
+				mode_set_ret = drm_crtc_helper_set_mode(crtc,
+								&primary_mode,
+								0, 0,
+								NULL);
+								break;
+			}
+		}
+
+	}
+
+	if (FALSE == mode_set_ret) {
+		EMGD_ERROR_EXIT("Failed to set mode on secondary CRTC.  Abort.");
+		return -IGD_ERROR_INVAL;
+	}
+
+
+	EMGD_TRACE_EXIT;
+
+	return 0;
+}
+
+
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_interface.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_interface.c
index 56a7669..b0a88a6 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_interface.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_interface.c
@@ -1,7 +1,6 @@
-/* -*- pse-c -*-
- *-----------------------------------------------------------------------------
+/*-----------------------------------------------------------------------------
  * Filename: emgd_interface.c
- * $Revision: 1.168 $
+ * $Revision: 1.182 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -60,6 +59,10 @@
 #include "syscommon.h"
 #include "pvr_drm.h"
 
+#include <linkage.h>
+
+#include "pvrversion.h"
+
 /* Turn on tracing for this file only */
 /*
 #undef EMGD_TRACE_ENTER
@@ -69,10 +72,11 @@
 /* The compile-time configuration found in "user_config.c": */
 extern emgd_drm_config_t config_drm;
 /* Module parameters from "emgd_drv.c": */
-extern int drm_emgd_init;
 extern int drm_emgd_dc;
 extern unsigned x_started;
 
+extern void emgd_init_display(int merge_mod_params, drm_emgd_priv_t *priv);
+
 /**
  * The driver handle for talking with the HAL, within the DRM/kernel code.
  * This is a "real handle" as opposed to the "fake handle" in user-space.
@@ -118,7 +122,7 @@ extern int pi_pd_init(igd_display_port_t *port, unsigned long port_feature,
 #ifdef DEBUG_BUILD_TYPE
 extern void emgd_print_params(igd_param_t *params);
 #endif
-
+extern void emgd_modeset_destroy(struct drm_device *dev);
 
 
 /*
@@ -136,7 +140,7 @@ int emgd_get_chipset_info(struct drm_device *dev, void *arg,
 		struct drm_file *file_priv)
 {
 	emgd_drm_driver_get_chipset_info_t *drm_data = arg;
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
 
 	drm_data->device_id = priv->init_info->device_id;
 	drm_data->revision_id = priv->init_info->vendor_id;
@@ -181,7 +185,6 @@ int emgd_alter_cursor(struct drm_device *dev, void *arg,
 
 
 	/*EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);*/
-	/*EMGD_DEBUG("Returning 0");*/
 	/*EMGD_TRACE_EXIT;*/
 	return 0;
 } /* emgd_alter_cursor() */
@@ -204,11 +207,31 @@ int emgd_alter_cursor_pos(struct drm_device *dev, void *arg,
 
 
 	/*EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);*/
-	/*EMGD_DEBUG("Returning 0");*/
 	/*EMGD_TRACE_EXIT;*/
 	return 0;
 } /* emgd_alter_cursor_pos() */
 
+/*!
+ * IOCTL to bridge the IAL to the HAL's emgd_get_display_info() procedure.
+ */
+int emgd_get_display_info(struct drm_device *dev, void *arg,
+	struct drm_file *file_priv)
+{
+  /*
+	emgd_drm_get_display_info_t *drm_data = arg;
+
+	igd_context_t *context = (igd_context_t *) handle;
+	drm_emgd_priv_t *priv = (drm_emgd_priv_t *)dev->dev_private;
+*/
+	EMGD_TRACE_ENTER;
+/*
+	EMGD_DEBUG("drm_data->primary = 0x%lx",  (unsigned long) drm_data->primary);
+	EMGD_DEBUG("drm_data->secondary = 0x%lx",(unsigned long) drm_data->secondary);
+
+	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn); */
+	EMGD_TRACE_EXIT;
+	return 0;
+} /* emgd_get_display_info() */
 
 /*!
  * IOCTL to bridge the IAL to the HAL's alter_displays() procedure.
@@ -217,7 +240,7 @@ int emgd_alter_displays(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv)
 {
 	emgd_drm_alter_displays_t *drm_data = arg;
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
 
 	EMGD_TRACE_ENTER;
 
@@ -268,7 +291,7 @@ int emgd_alter_displays(struct drm_device *dev, void *arg,
 			priv->must_power_on_ports = 0;
 		}
 
-		if (priv->pvrsrv_started && priv->reinit_3dd) {
+		if (priv->reinit_3dd) {
 			priv->reinit_3dd(dev);
 		}
 	}
@@ -276,7 +299,6 @@ int emgd_alter_displays(struct drm_device *dev, void *arg,
 	EMGD_DEBUG("drm_data->primary = 0x%lx", (unsigned long) drm_data->primary);
 	EMGD_DEBUG("drm_data->secondary = 0x%lx",(unsigned long) drm_data->secondary);
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_alter_displays() */
@@ -302,7 +324,6 @@ int emgd_alter_ovl(struct drm_device *dev, void *arg,
 		drm_data->flags);
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_alter_ovl() */
@@ -369,12 +390,26 @@ int emgd_alter_ovl2(struct drm_device *dev, void *arg,
 		(unsigned int)drm_data->flags
 		);
 	*/
-	drm_data->rtn = dispatch->alter_ovl2(drm_data->display_handle,
-                                         &(drm_data->src_surf),
-                                         &(drm_data->src_rect),
-                                         &(drm_data->dst_rect),
-                                         &(drm_data->ovl_info),
-                                         drm_data->flags);
+	switch (drm_data->cmd) {
+	case CMD_ALTER_OVL2:
+		drm_data->rtn = dispatch->alter_ovl2(drm_data->display_handle,
+											 &(drm_data->src_surf),
+											 &(drm_data->src_rect),
+											 &(drm_data->dst_rect),
+					                         &(drm_data->ovl_info),
+						                     drm_data->flags);
+		break;
+	case CMD_ALTER_OVL2_OSD:
+		drm_data->rtn = dispatch->alter_ovl2_osd(drm_data->display_handle,
+                                             &(drm_data->src_surf),
+                                             &(drm_data->src_rect),
+                                             &(drm_data->dst_rect),
+                                             &(drm_data->ovl_info),
+                                             drm_data->flags);
+   		break;
+	default:
+		break;
+	}
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
 	EMGD_TRACE_EXIT;
@@ -415,7 +450,6 @@ int emgd_get_ovl_init_params(struct drm_device *dev, void *arg,
 	drm_data->rtn = dispatch->get_ovl_init_params(handle, ovl_um_context);
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_get_ovl_init_params() */
@@ -441,7 +475,6 @@ int emgd_appcontext_alloc(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->appcontext_h = %p", drm_data->appcontext_h);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_appcontext_alloc() */
@@ -466,7 +499,6 @@ int emgd_appcontext_free(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("This function has no drm_data->rtn value");
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_appcontext_free() */
@@ -478,14 +510,21 @@ int emgd_appcontext_free(struct drm_device *dev, void *arg,
 int emgd_driver_save_restore(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv)
 {
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
 	emgd_drm_driver_save_restore_t *drm_data = arg;
+	unsigned long save_flags  = 0;
 
 	EMGD_TRACE_ENTER;
 
+	if (config_drm.init) {
+		save_flags = IGD_REG_SAVE_ALL & ~IGD_REG_SAVE_GTT;
+	}
+	else {
+		save_flags = IGD_REG_SAVE_ALL;
+	}
 
 	/* Call the HAL: */
-	drm_data->rtn = dispatch->driver_save_restore(handle);
+	drm_data->rtn = dispatch->driver_save_restore(handle, save_flags);
 
 	/* Change the state of what's saved: */
 	if (priv->saved_registers == CONSOLE_STATE_SAVED) {
@@ -496,9 +535,13 @@ int emgd_driver_save_restore(struct drm_device *dev, void *arg,
 		EMGD_DEBUG("State of saved registers is CONSOLE_STATE_SAVED");
 	}
 
+	if (priv->saved_registers == X_SERVER_STATE_SAVED &&
+		!priv->qb_seamless && !config_drm.kms && config_drm.init) {
+		emgd_init_display(FALSE, priv);
+	}
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
+
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_driver_save_restore() */
@@ -523,7 +566,6 @@ int emgd_enable_port(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_enable_port() */
@@ -608,7 +650,6 @@ int emgd_get_attrs(struct drm_device *dev, void *arg,
 	drm_data->extended = extended;
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_get_attrs() */
@@ -624,7 +665,8 @@ int emgd_get_display(struct drm_device *dev, void *arg,
 	emgd_drm_get_display_t *drm_data = arg;
 	igd_display_context_t *display =
 		(igd_display_context_t *) drm_data->display_handle;
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
+	int dc, port_num;
 
 	EMGD_TRACE_ENTER;
 
@@ -642,6 +684,8 @@ int emgd_get_display(struct drm_device *dev, void *arg,
 		return -IGD_ERROR_INVAL;
 	}
 
+	dc = *(context->mod_dispatch.dsp_current_dc);
+	port_num = drm_data->port_number;
 
 	/* Call the HAL: */
 	drm_data->rtn = dispatch->get_display(drm_data->display_handle,
@@ -655,8 +699,15 @@ int emgd_get_display(struct drm_device *dev, void *arg,
 		drm_data->flags);
 
 	/* In seamless mode this gets called instead of alter_displays */
-	if(mode_context->seamless) {
-		if (priv->pvrsrv_started && priv->reinit_3dd) {
+	/* The reason why we do not want to call reinit_3dd() if the clone mode is
+	 * set and if this function was called to get the secondary handle is because
+	 * reinit_3dd() calls init_display() which in turn calls get_display() and passes
+	 * the handle for secondary, and primary port number hence leading to an incorrect
+	 * combination. Also, we may not have to call reinit_3dd() as this is already done
+	 * as a part of configuring the primary.
+	 */
+	if(mode_context->seamless && !(IGD_DC_CLONE(dc) && port_num == priv->secondary_port_number)) {
+		if (priv->reinit_3dd) {
 			priv->dc = *(context->mod_dispatch.dsp_current_dc);
 			priv->primary = drm_data->display_handle;
 			priv->secondary = NULL;
@@ -668,7 +719,6 @@ int emgd_get_display(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_get_display() */
@@ -699,7 +749,7 @@ int emgd_get_drm_config(struct drm_device *dev, void *arg,
 	} else {
 		params = config_drm.hal_params[drm_emgd_configid-1];
 	}
-	if (drm_emgd_init) {
+	if (config_drm.init) {
 		drm_data->display_config = drm_emgd_dc;
 	} else {
 		drm_data->display_config = config_drm.dc;
@@ -716,6 +766,21 @@ int emgd_get_drm_config(struct drm_device *dev, void *arg,
 	drm_data->params.polling = params->polling;
 	drm_data->params.ref_freq = params->ref_freq;
 	drm_data->params.tuning_wa = params->tuning_wa;
+	drm_data->params.clip_hw_fix = params->clip_hw_fix;
+	drm_data->params.async_flip_wa = params->async_flip_wa;
+	drm_data->params.en_reg_override = params->en_reg_override;
+	drm_data->params.disp_arb = params->disp_arb;
+	drm_data->params.fifo_watermark1 = params->fifo_watermark1;
+	drm_data->params.fifo_watermark2 = params->fifo_watermark2;
+	drm_data->params.fifo_watermark3 = params->fifo_watermark3;
+	drm_data->params.fifo_watermark4 = params->fifo_watermark4;
+	drm_data->params.fifo_watermark5 = params->fifo_watermark5;
+	drm_data->params.fifo_watermark6 = params->fifo_watermark6;
+	drm_data->params.gvd_hp_control = params->gvd_hp_control;
+	drm_data->params.bunit_chicken_bits = params->bunit_chicken_bits;
+	drm_data->params.bunit_write_flush = params->bunit_write_flush;
+	drm_data->params.disp_chicken_bits = params->disp_chicken_bits;
+	drm_data->params.punt_to_3dblit = params->punt_to_3dblit;
 
 	for (i = 0 ; i < IGD_MAX_PORTS ; i++) {
 		drm_data->params.port_order[i] = params->port_order[i];
@@ -774,10 +839,17 @@ int emgd_get_drm_config(struct drm_device *dev, void *arg,
 		}
 	}
 
+	/* Fill in DDK & EMGD version numbers and debug status */
+	drm_data->build_config.ddk_version = PVRVERSION_BUILD;
+	drm_data->build_config.emgd_version = IGD_BUILD_NUM;
+#ifdef DEBUG
+	drm_data->build_config.debug = 1;
+#else
+	drm_data->build_config.debug = 0;
+#endif
 
 	drm_data->rtn = 0;
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_get_drm_config() */
@@ -806,7 +878,6 @@ int emgd_get_EDID_block(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_get_EDID_block() */
@@ -836,7 +907,6 @@ int emgd_get_EDID_info(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_get_EDID_info() */
@@ -917,7 +987,6 @@ int emgd_get_pixelformats(struct drm_device *dev, void *arg,
 	}
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_get_pixelformats() */
@@ -945,7 +1014,6 @@ int emgd_get_port_info(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_get_port_info() */
@@ -975,7 +1043,6 @@ int emgd_gmm_alloc_region(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_gmm_alloc_region() */
@@ -1009,7 +1076,6 @@ int emgd_gmm_alloc_surface(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_gmm_alloc_surface() */
@@ -1024,7 +1090,6 @@ int emgd_gmm_get_num_surface(struct drm_device *dev, void *arg,
 		&(drm_data->count));
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 }
@@ -1051,7 +1116,6 @@ int emgd_gmm_get_surface_list(struct drm_device *dev, void *arg,
 	vfree(surface_list);
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 }
@@ -1073,7 +1137,6 @@ int emgd_gmm_free(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("This function has no drm_data->rtn value");
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_gmm_free() */
@@ -1095,7 +1158,6 @@ int emgd_gmm_flush_cache(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_gmm_flush_cache() */
@@ -1120,7 +1182,6 @@ int emgd_pan_display(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %ld", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_pan_display() */
@@ -1155,7 +1216,6 @@ int emgd_power_display(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_power_display() */
@@ -1177,7 +1237,6 @@ int emgd_pwr_alter(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_pwr_alter() */
@@ -1240,7 +1299,6 @@ int emgd_query_dc(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_query_dc() */
@@ -1269,7 +1327,6 @@ int emgd_query_max_size_ovl(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_query_max_size_ovl() */
@@ -1291,7 +1348,6 @@ int emgd_query_ovl(struct drm_device *dev, void *arg,
 		drm_data->flags);
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_query_ovl() */
@@ -1349,7 +1405,6 @@ int emgd_query_mode_list(struct drm_device *dev, void *arg,
 	}
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_query_mode_list() */
@@ -1379,7 +1434,6 @@ int emgd_set_attrs(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_set_attrs() */
@@ -1403,7 +1457,6 @@ int emgd_set_palette_entry(struct drm_device *dev, void *arg,
 
 
 	/*EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);*/
-	/*EMGD_DEBUG("Returning 0");*/
 	/*EMGD_TRACE_EXIT;*/
 	return 0;
 } /* emgd_set_palette_entry() */
@@ -1430,12 +1483,187 @@ int emgd_set_surface(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_set_surface() */
 
 
+
+/*!
+ * IOCTL to set surface to dih_clone or back to dih.
+ * drm_data->mode = CLONE - sets fake clone clone
+ * drm_data->mode = DIH - reverts back to DIH
+ * drm_data->dih_clone_display = CLONE_PRIMARY, primary cloned
+ * drm_data->dih_clone_display = CLONE_SECONDARY, secondary cloned
+ *
+ */
+int emgd_dihclone_set_surface(struct drm_device *dev, void *arg,
+	struct drm_file *file_priv)
+{
+	emgd_drm_dihclone_set_surface_t *drm_data = arg;
+	igd_context_t *context = (igd_context_t *) handle;
+	igd_plane_t *display_plane1, *display_plane2;
+	igd_display_pipe_t *pipe1, *pipe2;
+	igd_display_context_t *display;
+	igd_surface_t surf;
+	unsigned long dc ;
+
+	EMGD_TRACE_ENTER;
+
+	memset(&surf, 0, sizeof(igd_surface_t));
+	dc = *(context->mod_dispatch.dsp_current_dc);
+
+	context->mod_dispatch.dsp_get_planes_pipes(
+			&display_plane1, &display_plane2,
+			&pipe1, &pipe2);
+
+	/* check if the resolutions match */
+	if((pipe1->plane->fb_info->width != pipe2->plane->fb_info->width) ||
+		(pipe1->plane->fb_info->height != pipe2->plane->fb_info->height)){
+			EMGD_ERROR(" emgd_dihclone_set_surface: resolutions don't match");
+		return -IGD_ERROR_INVAL;
+	}
+
+
+	if( drm_data->dih_clone_display != CLONE_PRIMARY && drm_data->dih_clone_display != CLONE_SECONDARY){
+
+		EMGD_ERROR(" emgd_dihclone_set_surface: Invalid Clone Display number");
+		return -IGD_ERROR_INVAL;
+	}
+
+	surf.pitch = pipe1->plane->fb_info->screen_pitch;
+	surf.width =  pipe1->plane->fb_info->width;
+	surf.height =  pipe1->plane->fb_info->height;
+	surf.pixel_format =  pipe1->plane->fb_info->pixel_format;
+	surf.flags = IGD_SURFACE_RENDER | IGD_SURFACE_DISPLAY;
+
+	display = context->mod_dispatch.dsp_display_list[IGD_DC_PRIMARY(dc)];
+
+	/*reverting back to DIH from fake clone */
+	if( drm_data->mode == DIH){
+		if(context->mod_dispatch.dih_clone_display == CLONE_PRIMARY) {
+
+			EMGD_DEBUG(" emgd_dihclone_set_surface: setting DIH1");
+			surf.offset = pipe1->plane->fb_info->fb_base_offset;
+			/* Call the HAL: */
+			drm_data->rtn = dispatch->set_surface(display,
+				IGD_PRIORITY_NORMAL,
+				IGD_BUFFER_DISPLAY,
+				&surf,
+				NULL,
+				0);
+
+			if(drm_data->rtn) {
+				EMGD_ERROR(" emgd_dihclone_set_surface1: failed");
+				return -IGD_ERROR_INVAL;
+			}
+			display = context->mod_dispatch.dsp_display_list[IGD_DC_SECONDARY(dc)];
+			surf.offset = pipe2->plane->fb_info->saved_offset;
+			/* Call the HAL: */
+			drm_data->rtn = dispatch->set_surface(display,
+					IGD_PRIORITY_NORMAL,
+					IGD_BUFFER_DISPLAY,
+					&surf,
+					NULL,
+					0);
+			if(drm_data->rtn) {
+				EMGD_ERROR(" emgd_dihclone_set_surface2: failed");
+				return -IGD_ERROR_INVAL;
+			}
+
+
+		} else { // if secondary clone
+
+				EMGD_DEBUG(" emgd_dihclone_set_surface: setting DIH2");
+				surf.offset = pipe1->plane->fb_info->saved_offset;
+				/* Call the HAL: */
+				drm_data->rtn = dispatch->set_surface(display,
+						IGD_PRIORITY_NORMAL,
+						IGD_BUFFER_DISPLAY,
+						&surf,
+						NULL,
+						0);
+				display = context->mod_dispatch.dsp_display_list[IGD_DC_SECONDARY(dc)];
+				surf.offset = pipe2->plane->fb_info->fb_base_offset;
+				/* Call the HAL: */
+				drm_data->rtn = dispatch->set_surface(display,
+						IGD_PRIORITY_NORMAL,
+						IGD_BUFFER_DISPLAY,
+				&surf,
+				NULL,
+				0);
+
+		}
+
+		context->mod_dispatch.in_dih_clone_mode = false;
+		return 0;
+
+	}
+
+
+/* setting fake clone (dih clone) mode */
+
+
+	/*first save the display's original offset  */
+	surf.offset = pipe1->plane->fb_info->fb_base_offset;
+	drm_data->rtn = dispatch->set_surface(display,
+			IGD_PRIORITY_NORMAL,
+			IGD_BUFFER_SAVE,
+			&surf,
+			NULL,
+			0);
+
+	display = context->mod_dispatch.dsp_display_list[IGD_DC_SECONDARY(dc)];
+	surf.offset = pipe2->plane->fb_info->fb_base_offset;
+	drm_data->rtn = dispatch->set_surface(display,
+		IGD_PRIORITY_NORMAL,
+		IGD_BUFFER_SAVE,
+		&surf,
+		NULL,
+		0);
+
+	/* primary display */
+
+	if( drm_data->dih_clone_display == CLONE_PRIMARY){
+		surf.offset = pipe1->plane->fb_info->fb_base_offset;
+	} else {
+
+		surf.offset = pipe2->plane->fb_info->fb_base_offset;
+	}
+
+	display = context->mod_dispatch.dsp_display_list[IGD_DC_PRIMARY(dc)];
+	/* Call the HAL: */
+	drm_data->rtn = dispatch->set_surface(display,
+		IGD_PRIORITY_NORMAL,
+		IGD_BUFFER_DISPLAY,
+		&surf,
+		NULL,
+		0);
+
+	/* secondary display */
+
+	display = context->mod_dispatch.dsp_display_list[IGD_DC_SECONDARY(dc)];
+
+	drm_data->rtn = dispatch->set_surface(display,
+		IGD_PRIORITY_NORMAL,
+		IGD_BUFFER_DISPLAY,
+		&surf,
+		NULL,
+		0);
+
+	if(drm_data->rtn == 0){
+		context->mod_dispatch.in_dih_clone_mode = true;
+		context->mod_dispatch.dih_clone_display = drm_data->dih_clone_display;
+	}
+	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
+
+	EMGD_DEBUG("Returning 0");
+	EMGD_TRACE_EXIT;
+	return 0;
+} /* emgd_dihclone_set_surface() */
+
+
+
 /*!
  * IOCTL to bridge the IAL to the HAL's sync() procedure.
  */
@@ -1459,7 +1687,6 @@ int emgd_sync(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_sync() */
@@ -1471,7 +1698,7 @@ int emgd_sync(struct drm_device *dev, void *arg,
 int emgd_driver_pre_init(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv)
 {
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
 	igd_context_t *context = NULL;
 	emgd_drm_driver_pre_init_t *drm_data = (emgd_drm_driver_pre_init_t *) arg;
 	igd_param_t *x_params = NULL;
@@ -1479,11 +1706,12 @@ int emgd_driver_pre_init(struct drm_device *dev, void *arg,
 	igd_fb_caps_t *pf_caps;
 	igd_display_port_t *port = NULL;
 	int i, err = 0, need_to_startup_hal = (!priv->hal_running) ? 1 : 0;
+	unsigned long save_flags;
 
 	EMGD_TRACE_ENTER;
 
 	/* This flag will cause a call to emgd_init_display() in
-	 * emgd_driver_lastclose() if drm_emgd_init is true */
+	 * emgd_driver_lastclose() if config_drm.init is true */
 	x_started = true;
 
 	/*
@@ -1589,6 +1817,18 @@ int emgd_driver_pre_init(struct drm_device *dev, void *arg,
 	context = (igd_context_t *) handle;
 	context->mod_dispatch.init_params = x_params;
 
+	if (config_drm.init) {
+		if (config_drm.kms) {
+			save_flags = (IGD_REG_SAVE_ALL & ~IGD_REG_SAVE_GTT)| IGD_REG_SAVE_TYPE_REG;
+		} else {
+			save_flags = (IGD_REG_SAVE_ALL & ~IGD_REG_SAVE_GTT &
+				~IGD_REG_SAVE_RB) | IGD_REG_SAVE_TYPE_REG;
+		}
+		dispatch->driver_save(handle, save_flags);
+		EMGD_DEBUG("State of saved registers is CONSOLE_STATE_SAVED");
+		priv->saved_registers = CONSOLE_STATE_SAVED;
+	}
+
 	if (!need_to_startup_hal) {
 		/* emgd_driver_load() initialized and configured the driver.
 		 * Therefore, we must now re-initialize and poke x_params values into
@@ -1625,57 +1865,74 @@ int emgd_driver_pre_init(struct drm_device *dev, void *arg,
 		 */
 		if (priv->saved_registers == X_SERVER_STATE_SAVED) {
 			EMGD_DEBUG("Need to restore the X server's saved register state");
-			err = dispatch->driver_save_restore(handle);
+
+			if (config_drm.init) {
+				save_flags = IGD_REG_SAVE_ALL & ~IGD_REG_SAVE_GTT;
+			}
+			else {
+				save_flags = IGD_REG_SAVE_ALL;
+			}
+			err = dispatch->driver_save_restore(handle, save_flags);
 			EMGD_DEBUG("State of saved registers is CONSOLE_STATE_SAVED");
 			priv->saved_registers = CONSOLE_STATE_SAVED;
 		}
 
 		if(!mode_context->seamless) {
-		/* NOTE: In order for some new values to be poked into the port
-		 * drivers' hardware (e.g. the LVDS panel depth), the power must be
-		 * turned off on those devices.  This used to be done during the
-		 * emgd_driver_lastclose() function, but that prevents the console from
-		 * being seen after X quits.
-		 */
-		while ((port = context->mod_dispatch.dsp_get_next_port(context,
-					port, 0)) != NULL) {
-			/* power off LVDS only */
-			if (port->pd_driver &&  (port->port_number == IGD_PORT_TYPE_LVDS) &&
-				!mode_context->seamless) {
-				EMGD_DEBUG("Turning off power for port %lu\n", port->port_number);
-				dispatch->power_display(context, port->port_number,
-					IGD_POWERSTATE_D3);
+			/* NOTE: In order for some new values to be poked into the port
+			 * drivers' hardware (e.g. the LVDS panel depth), the power must be
+			 * turned off on those devices.  This used to be done during the
+			 * emgd_driver_lastclose() function, but that prevents the console from
+			 * being seen after X quits.
+			 */
+			while ((port = context->mod_dispatch.dsp_get_next_port(context,
+						port, 0)) != NULL) {
+				/* power off LVDS only */
+				if (port->pd_driver &&  (port->port_number == IGD_PORT_TYPE_LVDS) &&
+					!mode_context->seamless) {
+					EMGD_DEBUG("Turning off power for port %lu\n", port->port_number);
+					dispatch->power_display(context, port->port_number,
+						IGD_POWERSTATE_D3);
+				}
 			}
-		}
 
-		/* mode_init() calls dsp_init() (in "dsp.c"), which uses the
-		 * display_flags, display_params & port_order params.  In the case of
-		 * display_params, each element of the array contains dtd_list and
-		 * attr_list, both of which point to memory that must be separately
-		 * copied to kernel-space.  The display_flags, display_params &
-		 * port_order params affect the initialization of the DSP module, and
-		 * as such, it may not be easy to simply poke values here.
-		 *
-		 * Thus, it appears that the DSP module must somehow be re-initialized.
-		 *
-		 * Note: dsp_init() also calls full_dsp_init() and the device-specific
-		 * init procedures, none of which uses any params.
-		 */
-		EMGD_DEBUG("Calling dsp_shutdown()");
-		dsp_shutdown(handle);
-
-		EMGD_DEBUG("Calling dsp_init()");
-		dsp_init(handle);
-
-		/* Poke any new port attributes & DTDs into the port drivers: */
-		while ((port = context->mod_dispatch.dsp_get_next_port(context,
-					port, 0)) != NULL) {
-				if (port->pd_driver && !mode_context->seamless) {
-					EMGD_DEBUG("Insert new port attrs/DTDs for port %lu",
-					port->port_number);
-				pi_pd_init(port, 0, 0, FALSE);
+			/* mode_init() calls dsp_init() (in "dsp.c"), which uses the
+			 * display_flags, display_params & port_order params.  In the case of
+			 * display_params, each element of the array contains dtd_list and
+			 * attr_list, both of which point to memory that must be separately
+			 * copied to kernel-space.  The display_flags, display_params &
+			 * port_order params affect the initialization of the DSP module, and
+			 * as such, it may not be easy to simply poke values here.
+			 *
+			 * Thus, it appears that the DSP module must somehow be re-initialized.
+			 *
+			 * Note: dsp_init() also calls full_dsp_init() and the device-specific
+			 * init procedures, none of which uses any params.
+			 */
+			EMGD_DEBUG("Calling dsp_shutdown()");
+			dsp_shutdown(handle);
+
+			EMGD_DEBUG("Calling dsp_init()");
+			dsp_init(handle);
+
+
+			/* Poke any new port attributes & DTDs into the port drivers: */
+			while ((port = context->mod_dispatch.dsp_get_next_port(context,
+						port, 0)) != NULL) {
+					if (port->pd_driver && !mode_context->seamless) {
+						EMGD_DEBUG("Insert new port attrs/DTDs for port %lu",
+						port->port_number);
+					pi_pd_init(port, 0, 0, FALSE);
+				}
 			}
-		}
+
+			/*
+			 * Because dsp_init was called above, a lot of the configuration
+			 * performed by the driver at initializat is now invalid.
+			 *
+			 * Setting the dc to 0 makes sure we don't try to use other
+			 * data structures before alter_displays has been called again.
+			 */
+			priv->dc = 0;
 		}
 
 
@@ -1697,7 +1954,7 @@ int emgd_driver_pre_init(struct drm_device *dev, void *arg,
 		}
 	} /* if (!need_to_startup_hal) */
 
-/* NOTE -- Below is Ian Elliott's original analysis of what values/modules need
+/* NOTE -- Below is our original analysis of what values/modules need
  * to be dealt with (above):
  *
  * - mode_init() (in "micro_mode.c") uses display_color.
@@ -1769,7 +2026,7 @@ int emgd_driver_pre_init(struct drm_device *dev, void *arg,
  *       STRUCT OF TYPE igd_param_attr_list_t, AND SOME OF ITS MEMBERS HAVE
  *       POINTERS WITHIN THEM (i.e. HARDER TO GET ACROSS THE IOCTL BOUNDARY).
  *
- *       Based on the above, it seems that Bob's original idea of
+ *       Based on the above, it seems that the idea of
  *       re-initializing the DSP module seems like the correct approach.  I'm
  *       not quite sure how to do that, but it seems like the right direction
  *       to both keep the HAL code unmodified, and do the user/kernel-space
@@ -1806,7 +2063,7 @@ int emgd_driver_pre_init(struct drm_device *dev, void *arg,
  *   is called by both igd_pd_register() (in "igd_pi.c") and pd_register() (in
  *   "emgd_drm/display/pd/pd.c").  igd_pd_register() is called by
  *   load_port_drivers() (in "emgd_drv/emgd_dpdloader.c") which is no longer
- *   called (was called during PreInit(), but Ian just took it out).
+ *   called (was called during PreInit()).
  *   pd_register() is called by lvds_init() and sdvo_init(), both of which are
  *   called by pi_init_all(), which is not being called.
  *
@@ -1862,7 +2119,6 @@ int emgd_driver_pre_init(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_driver_pre_init() */
@@ -1890,7 +2146,6 @@ int emgd_driver_get_ports(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_driver_get_ports() */
@@ -1927,7 +2182,6 @@ int emgd_get_page_list(struct drm_device *dev, void *arg,
 	}
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_driver_get_page_list() */
@@ -1941,46 +2195,19 @@ int emgd_start_pvrsrv(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv)
 {
 	emgd_drm_start_pvrsrv_t *drm_data = arg;
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
 
 	EMGD_TRACE_ENTER;
 
-
 	/* Tell the 3DD the status of whether the X server is running: */
 	if (!priv->xserver_running && drm_data->xserver) {
 		priv->xserver_running = 1;
-		if (priv->pvrsrv_started && priv->reinit_3dd) {
+		if (priv->reinit_3dd) {
 			priv->reinit_3dd(dev);
 		}
 	}
 
-
-	if (0 == priv->pvrsrv_started) {
-		/* Start the PVR services DRM code: */
-		EMGD_DEBUG("Calling PVRSRVDrmLoad()");
-		drm_data->rtn = (int) PVRSRVDrmLoad(dev, 0);
-		EMGD_DEBUG("PVRSRVDrmLoad() returned %d", drm_data->rtn);
-
-		if (0 == drm_data->rtn) {
-			/* Must also call PVRSRVOpen() on behalf of this process: */
-			EMGD_DEBUG("Calling PVRSRVOpen()");
-			drm_data->rtn = (int) PVRSRVOpen(dev, file_priv);
-			EMGD_DEBUG("PVRSRVOpen() returned %d", drm_data->rtn);
-		}
-
-		if (0 == drm_data->rtn) {
-			priv->pvrsrv_started = 1;
-		}
-	} else {
-		drm_data->rtn = 0;
-		EMGD_DEBUG("Calling PVRSRVOpen()");
-		drm_data->rtn = (int) PVRSRVOpen(dev, file_priv);
-		EMGD_DEBUG("PVRSRVOpen() returned %d", drm_data->rtn);
-	}
-
-
-	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
+	drm_data->rtn = 0;
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_start_pvrsrv() */
@@ -1993,7 +2220,7 @@ int emgd_video_cmd_buf(struct drm_device *dev, void *arg,
 		struct drm_file *file_priv)
 {
 	emgd_drm_video_cmd_buf_t *drm_data = arg;
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
 	igd_context_t *context = priv->context;
 
 
@@ -2017,7 +2244,6 @@ int emgd_video_cmd_buf(struct drm_device *dev, void *arg,
 
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_video_cmd_buf() */
@@ -2030,7 +2256,7 @@ int emgd_get_device_info(struct drm_device *dev, void *arg,
     struct drm_file *file_priv)
 {
     emgd_drm_device_info_t *drm_data = arg;
-    drm_emgd_private *priv = dev->dev_private;
+    drm_emgd_priv_t *priv = dev->dev_private;
     igd_context_t *context = priv->context;
 
     EMGD_TRACE_ENTER;
@@ -2050,7 +2276,7 @@ int emgd_init_video(struct drm_device *dev, void *arg,
 		struct drm_file *file_priv)
 {
 	emgd_drm_init_video_t *drm_data = arg;
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
 	igd_context_t *context = priv->context;
 
 	EMGD_TRACE_ENTER;
@@ -2121,7 +2347,6 @@ int emgd_init_video(struct drm_device *dev, void *arg,
 	}
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 } /* emgd_init_video() */
@@ -2130,7 +2355,7 @@ int emgd_video_get_info(struct drm_device *dev, void *arg,
 			struct drm_file *file_priv)
 {
 	emgd_drm_video_get_info_t *drm_data = arg;
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
 	igd_context_t *context = priv->context;
 
 	EMGD_TRACE_ENTER;
@@ -2142,8 +2367,7 @@ int emgd_video_get_info(struct drm_device *dev, void *arg,
 					drm_data->rtn = msvdx_get_fence_id(context, &(drm_data->fence_id));
 					break;
 				case TNC_ENGINE_ENCODE:
-					drm_data->rtn = topaz_sync_surface(context, &(drm_data->sync_done),
-								&(drm_data->last_frame));
+					drm_data->rtn = topaz_get_fence_id(context, &(drm_data->fence_id));
 					break;
 				default:
 					break;
@@ -2160,12 +2384,15 @@ int emgd_video_get_info(struct drm_device *dev, void *arg,
 					break;
 			}
 			break;
+		case CMD_VIDEO_GET_MSVDX_STATUS:
+			if ((&context->mod_dispatch) && context->mod_dispatch.msvdx_status)
+				drm_data->rtn = context->mod_dispatch.msvdx_status(context, &drm_data->queue_status, &drm_data->mtx_msg_status);
+			break;
 		default:
 			break;
 	}
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 }
@@ -2175,7 +2402,7 @@ int emgd_video_flush_tlb(struct drm_device *dev, void *arg,
 			struct drm_file *file_priv)
 {
 	emgd_drm_video_flush_tlb_t *drm_data = arg;
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
 	igd_context_t *context = priv->context;
 
 	EMGD_TRACE_ENTER;
@@ -2192,42 +2419,41 @@ int emgd_video_flush_tlb(struct drm_device *dev, void *arg,
 	}
 
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
-	EMGD_DEBUG("Returning 0");
 	EMGD_TRACE_EXIT;
 	return 0;
 }
 
 int emgd_get_golden_htotal(struct drm_device *dev, void *arg,
-   	struct drm_file *file_priv){
+		struct drm_file *file_priv){
 
 
 	emgd_drm_get_golden_htotal_t *drm_data = arg;
 	igd_context_t *context = (igd_context_t *) handle;
-    igd_display_context_t *display;
-    pd_timing_t igd_mode_table_in[2];
-    pd_timing_t igd_mode_table_out;
+	igd_display_context_t *display;
+	pd_timing_t igd_mode_table_in[2];
+	pd_timing_t igd_mode_table_out;
 
 	igd_display_info_t *out_mode = (igd_display_info_t *) drm_data->out_mode;
 	igd_display_info_t *in_mode = (igd_display_info_t *) drm_data->in_mode;
 
 
-   	EMGD_DEBUG("emgd_get_golden_htotal : Entry");
+	EMGD_DEBUG("emgd_get_golden_htotal : Entry");
 
-    /* parameters sanity check */
-   	if (out_mode == NULL) {
-          EMGD_ERROR("emgd_get_golden_htotal : NO Output Buffer");
-        return -IGD_ERROR_INVAL;
-    }
+	/* parameters sanity check */
+	if (out_mode == NULL) {
+		EMGD_ERROR("emgd_get_golden_htotal : NO Output Buffer");
+		return -IGD_ERROR_INVAL;
+	}
 
-    if (in_mode == NULL) {
-        EMGD_ERROR("emgD_get_golden_htotal : NO Input Buffer");
+	if (in_mode == NULL) {
+		EMGD_ERROR("emgD_get_golden_htotal : NO Input Buffer");
 		return -IGD_ERROR_INVAL;
 
-    }
+	}
 
-    /* Zero out the data structures so that we can check for error later */
-    memset(igd_mode_table_in, 0, 2 * sizeof(pd_timing_t));
-    memset(&igd_mode_table_out, 0, sizeof(pd_timing_t));
+	/* Zero out the data structures so that we can check for error later */
+	memset(igd_mode_table_in, 0, 2 * sizeof(pd_timing_t));
+	memset(&igd_mode_table_out, 0, sizeof(pd_timing_t));
 
 	/* To prevent a kernel OOPS, ensure the following value is non-NULL: */
 	display = context->mod_dispatch.dsp_display_list[2];
@@ -2268,3 +2494,90 @@ int emgd_get_golden_htotal(struct drm_device *dev, void *arg,
 
     return 0;
 }
+
+int emgd_control_plane_format(struct drm_device *dev, void *arg,
+	struct drm_file *file_priv)
+{
+	emgd_drm_control_plane_format_t *drm_data = arg;
+	igd_context_t *context = (igd_context_t *) handle;
+	igd_plane_t *plane_override;
+
+	EMGD_DEBUG("emgd_control_plane_format : Entry");
+
+	if (drm_data->use_plane == FALSE)
+	{
+		/* Do some error checking first */
+		if((drm_data->enable != 0 && drm_data->enable != 1) ||
+			(drm_data->primary_secondary_dsp == NULL)) {
+			EMGD_ERROR("emgd_control_plane_format: Invalid parameters");
+			return -IGD_ERROR_INVAL;
+		}
+
+		plane_override = ((igd_plane_t *)(PLANE(drm_data->primary_secondary_dsp)));
+	} else {
+		/* Do some error checking first */
+		if((drm_data->enable != 0 && drm_data->enable != 1) ||
+			(drm_data->display_plane != 0 && drm_data->display_plane != 1)) {
+			EMGD_ERROR("emgd_control_plane_format: Invalid parameters");
+			return -IGD_ERROR_INVAL;
+		}
+
+		/* Set plane_override to NULL */
+		plane_override = NULL;
+	}
+
+	/* Call the DSP modules function if no errors */
+	context->mod_dispatch.dsp_control_plane_format(drm_data->enable,
+			drm_data->display_plane, plane_override);
+
+	return 0;
+}
+
+int emgd_set_overlay_display(struct drm_device *dev, void *arg,
+	struct drm_file *file_priv)
+{
+	emgd_drm_set_overlay_display_t *drm_data = arg;
+	igd_context_t *context = (igd_context_t *) handle;
+
+	EMGD_DEBUG("emgd_set_overlay_display : Entry");
+
+	/* Do some error checking first */
+	if((drm_data->ovl_display[OVL_PRIMARY] == 0) ||
+		(drm_data->ovl_display[OVL_SECONDARY] == 0)) {
+		/* Both Ovl displays need to have valid handle
+		 * (i.e. Single mode is not supported) */
+		EMGD_ERROR("emgd_set_overlay_display: Invalid parameters");
+		return -IGD_ERROR_INVAL;
+	}
+
+	/* Call the set_ovl_display if no errors */
+	context->dispatch.set_ovl_display(drm_data->ovl_display);
+
+	return 0;
+}
+
+int emgd_query_2d_caps_hwhint(struct drm_device *dev, void *arg,
+	struct drm_file *file_priv){
+
+
+	emgd_drm_query_2d_caps_hwhint_t *drm_data;
+	unsigned long caps_val;
+	unsigned long *status;
+
+	EMGD_DEBUG("emgd_query_2d_caps_hwhint : Entry");
+
+    /* parameters sanity check */
+	if (arg == NULL) {
+          EMGD_ERROR("emgd_query_2d_caps_hwhint : invalid argument");
+        return -IGD_ERROR_INVAL;
+    }
+
+
+	drm_data = arg;
+	caps_val = (unsigned long) drm_data->caps_val;
+	status = (unsigned long *) drm_data->status;
+
+    igd_query_2d_caps_hwhint(handle, caps_val, status);
+
+    return 0;
+}
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_mmap.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_mmap.c
index 4104261..c1d13a2 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_mmap.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_mmap.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: emgd_mmap.c
- * $Revision: 1.9 $
+ * $Revision: 1.10 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -70,7 +70,7 @@ static struct vm_operations_struct emgd_vm_ops = {
 int emgd_mmap(struct file *filp, struct vm_area_struct *vma)
 {
 	struct drm_file *file_priv;
-	drm_emgd_private *emgd_priv;
+	drm_emgd_priv_t *emgd_priv;
 	gmm_chunk_t *chunk;
 	unsigned long offset;
 
@@ -83,7 +83,7 @@ int emgd_mmap(struct file *filp, struct vm_area_struct *vma)
 	}
 
 	file_priv = (struct drm_file *) filp->private_data;
-	emgd_priv = (drm_emgd_private *)file_priv->minor->dev->dev_private;
+	emgd_priv = (drm_emgd_priv_t *)file_priv->minor->dev->dev_private;
 	offset = vma->vm_pgoff << PAGE_SHIFT;
 
 	/*
diff --git a/drivers/gpu/drm/emgd/emgd/drm/emgd_test_pvrsrv.c b/drivers/gpu/drm/emgd/emgd/drm/emgd_test_pvrsrv.c
index 037ab7e..6ba4567 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/emgd_test_pvrsrv.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/emgd_test_pvrsrv.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: emgd_test_pvrsrv.c
- * $Revision: 1.22 $
+ * $Revision: 1.23 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -94,7 +94,7 @@
  * class members:
  */
 static emgd_drm_test_pvrsrv_t *drm_data;
-static drm_emgd_private *priv;
+static drm_emgd_priv_t *priv;
 
 static PVRSRV_PER_PROCESS_DATA *pp_data = NULL;
 static void *sgx_cookie = NULL;
@@ -144,11 +144,6 @@ static void init_pvrsrv(void)
 	EMGD_TRACE_ENTER;
 
 
-	if (0 == priv->pvrsrv_started) {
-		TEST_ERROR("[EMGD] cannot call emgd_test_pvrsrv() until the PVR "
-			"services have been started!\n");
-		drm_data->rtn = -1;
-	}
 	if (!drm_data->rtn) {
 		/* This is similar to PVRSRVConnect(): */
 		EMGD_DEBUG("Calling PVRSRVPerProcessDataConnect()");
diff --git a/drivers/gpu/drm/emgd/emgd/drm/image_data.h b/drivers/gpu/drm/emgd/emgd/drm/image_data.h
new file mode 100644
index 0000000..6ca9967
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/drm/image_data.h
@@ -0,0 +1,33 @@
+/*
+ *-----------------------------------------------------------------------------
+ * Filename: bitmap_data.h
+ * $Revision: 1.4 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2010, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ * Description:
+ *
+ *-----------------------------------------------------------------------------
+ */
+#define DECODE_PNG
+static unsigned char image_data[] = {
+};
diff --git a/drivers/gpu/drm/emgd/emgd/drm/splash_screen.c b/drivers/gpu/drm/emgd/emgd/drm/splash_screen.c
index ba21436..f429894 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/splash_screen.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/splash_screen.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: splash_screen.c
- * $Revision: 1.4 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -33,8 +33,14 @@
 
 #include <drm/drmP.h>
 #include <drm/drm.h>
+#include <memory.h>
+#include "sched.h"
+#include "image_data.h"
 #include "splash_screen.h"
-#include "bitmap_data.h"
+#include "io.h"
+#include "igd_debug.h"
+
+
 /**
  * Function to display a splash screen to the user. The splash screen must be
  * accessible to the kernel mode driver as it has to be displayed immediately
@@ -42,15 +48,30 @@
  *
  * @param ss_data (IN) a non null pointer to splash screen information like
  * width, height etc.
- *
- * @return 0 on Success
- * @return <0 on Error
  */
 void display_splash_screen(
 	igd_framebuffer_info_t *fb_info,
 	unsigned char *fb,
 	emgd_drm_splash_screen_t *ss_data)
 {
+	if (image_data[0] == 0x89) {
+		display_png_splash_screen(fb_info, fb, ss_data);
+	} else {
+		display_bmp_splash_screen(fb_info, fb, ss_data);
+	}
+}
+
+/*
+ * This is the function to display the bmp splash screen.
+ *
+ * @param ss_data (IN) a non null pointer to splash screen information like
+ * width, height etc.
+ */
+void display_bmp_splash_screen(
+	igd_framebuffer_info_t *fb_info,
+	unsigned char *fb,
+	emgd_drm_splash_screen_t *ss_data)
+{
 	unsigned char *fb_addr, *icon_temp;
 	unsigned long *fb_addr_long, icon_long;
 	unsigned long bitmap_pitch;
@@ -58,6 +79,9 @@ void display_splash_screen(
 	unsigned long init_x_shift, init_y_shift;
 	unsigned long row, col, fb_index;
 	unsigned long bytecount, temp;
+	unsigned long limit_width, limit_height;
+
+	EMGD_TRACE_ENTER;
 
 	x = (short) ss_data->x;
 	y = (short) ss_data->y;
@@ -71,21 +95,32 @@ void display_splash_screen(
 	}
 
 	fb_addr = fb + init_y_shift;
-	bytecount = (unsigned long) bitmap_data[0];
+	bytecount = (unsigned long) image_data[1];
 	bitmap_pitch = ss_data->width * bytecount;
 
-	for(row = 0; row < ss_data->height; row++) {
+	limit_width = ss_data->width;
+	limit_height = ss_data->height;
+
+	if (x+ss_data->width > fb_info->width) {
+		limit_width = fb_info->width - x;
+	}
+	if (y+ss_data->height > fb_info->height) {
+		limit_height = fb_info->height - y;
+	}
+
+	for(row = 0; row < limit_height; row++) {
 		fb_addr_long =
 			(unsigned long *) &fb_addr[fb_info->screen_pitch * row +
 			init_x_shift];
 		/*
-		 * We are adding 2 bytes here, because the first byte is the bytecount
-		 * and the second byte is the palette count
+		 * We are adding 3 bytes here, the first byte indicates BMP or PNG,
+		 * the second byte is the bytecount
+		 * and the third byte is the palette count
 		 */
-		icon_temp = &bitmap_data[2 + (row * bitmap_pitch)];
+		icon_temp = &image_data[3 + (row * bitmap_pitch)];
 		fb_index = 0;
 
-		for(col = 0; col < ss_data->width; col++) {
+		for(col = 0; col < limit_width; col++) {
 
 			icon_long = *((unsigned long *) &icon_temp[col*bytecount]);
 			switch(bytecount) {
@@ -102,10 +137,2085 @@ void display_splash_screen(
 					break;
 			}
 			/*
-			 * For 24 bit we don't really have to do anything as it is already in
-			 * RGB 888 format
+			 * For 24 bit we don't really have to do anything as it is
+			 * already in RGB 888 format
 			 */
 			fb_addr_long[fb_index++] = icon_long & 0x00FFFFFF;
 		}
 	}
+	EMGD_TRACE_EXIT;
+}
+
+
+/*
+ * This is the function to display the png splash screen.
+ *
+ * @param ss_data (IN) a non null pointer to splash screen information like
+ * width, height etc.
+ */
+void display_png_splash_screen(
+	igd_framebuffer_info_t *fb_info,
+	unsigned char *fb,
+	emgd_drm_splash_screen_t *ss_data)
+{
+	unsigned long image_size;
+	unsigned long i;
+	unsigned long chunk_size;
+	unsigned long chunk_type;
+	unsigned long iter = PNG_HEADER_SIZE;
+	png_header image_header;
+	png_frame *frames = NULL;
+	png_frame *default_image = NULL;
+	unsigned long gama = 0;
+	unsigned long palette_size = 0;
+	unsigned char *input_data = NULL;
+	unsigned long input_iter = 0;
+	unsigned long apng_num_frames = 0;
+	unsigned long apng_num_plays = 0;
+	unsigned long sequence_number = 0;
+	unsigned long cur_seq_num = 0;
+	unsigned long orig_x = 0;
+	unsigned long orig_y = 0;
+	unsigned long apng_file = 0;
+	unsigned long cur_frame = 0;
+	unsigned char trans_p = 0;
+	unsigned long prev_dispose_op = 0;
+	unsigned short delay_num, delay_den;
+
+	EMGD_TRACE_ENTER;
+
+	/*
+	 * Just incase there is no background and we have alpha values, lets
+	 * use the background specified in ss_data.
+	 */
+	image_header.background = 0xFF000000 | ss_data->bg_color;
+	image_header.background_r = (image_header.background >> 16) & 0xFF;
+	image_header.background_g = (image_header.background >> 8) & 0xFF;
+	image_header.background_b = image_header.background & 0xFF;
+
+	image_size = sizeof(image_data)/sizeof(unsigned char);
+	input_data = (unsigned char *)vmalloc(sizeof(image_data));
+	if (!input_data) {
+		EMGD_ERROR("Out of memory");
+		return;
+	}
+	OS_MEMSET(input_data, 0, sizeof(image_data));
+
+	orig_x = (short) ss_data->x;
+	orig_y = (short) ss_data->y;
+
+	/*
+	 * Lets get the information for the first chunk, which should be
+	 * the header chunk: IHDR.
+	 */
+	read_int_from_stream(image_data, &iter, &chunk_size);
+	read_int_from_stream(image_data, &iter, &chunk_type);
+
+	/*
+	 * Initialize image_header
+	 */
+	image_header.width = 0;
+	image_header.height = 0;
+	image_header.bit_depth = 0;
+	image_header.colour_type = 0;
+	image_header.compression_method = 0;
+	image_header.filter_method = 0;
+	image_header.interlace_method = 0;
+	image_header.bpp = 0;
+	image_header.bytes_pp = 0;
+	image_header.bytes_pl = 0;
+
+	/* Loop through the PNG chunks */
+	while (iter <= image_size) {
+		switch (chunk_type) {
+		case CHUNK_IHDR:
+			read_int_from_stream(image_data, &iter, &image_header.width);
+			read_int_from_stream(image_data, &iter, &image_header.height);
+			image_header.bit_depth = (unsigned char)image_data[iter++];
+			image_header.colour_type = (unsigned char)image_data[iter++];
+			image_header.compression_method = (unsigned char)image_data[iter++];
+			image_header.filter_method = (unsigned char)image_data[iter++];
+			image_header.interlace_method = (unsigned char)image_data[iter++];
+			image_header.x_offset = orig_x;
+			image_header.y_offset = orig_y;
+
+			/* store bits per pixel based on PNG spec */
+			switch (image_header.colour_type) {
+			case COLOR_GREY:
+				image_header.bpp = image_header.bit_depth;
+				break;
+			case COLOR_TRUE:
+				image_header.bpp = 3 * image_header.bit_depth;
+				break;
+			case COLOR_INDEXED:
+				image_header.bpp = image_header.bit_depth;
+				break;
+			case COLOR_GREY_ALPHA:
+				image_header.bpp = 2 * image_header.bit_depth;
+				break;
+			case COLOR_TRUE_ALPHA:
+				image_header.bpp = 4 * image_header.bit_depth;
+				break;
+			}
+			/*
+			 * Adding 7 to the bits per pixel before we divide by 8
+			 * gives us the ceiling of bytes per pixel instead of the floor.
+			 */
+			image_header.bytes_pp = (image_header.bpp + 7) / 8;
+			image_header.bytes_pl =
+				((image_header.width * image_header.bpp) + 7) / 8;
+			break;
+
+		case CHUNK_TRNS:
+			image_header.using_transparency = 1;
+			switch (image_header.colour_type) {
+				case COLOR_GREY:
+					read_short_from_stream(image_data, &iter,
+						&image_header.transparency_r);
+					break;
+				case COLOR_TRUE:
+					read_short_from_stream(image_data, &iter,
+						&image_header.transparency_r);
+					read_short_from_stream(image_data, &iter,
+						&image_header.transparency_g);
+					read_short_from_stream(image_data, &iter,
+						&image_header.transparency_b);
+					break;
+				case COLOR_INDEXED:
+					if (image_header.image_palette) {
+						if (chunk_size > palette_size) {
+							EMGD_ERROR("Palette size is smaller than "
+								"transparency values for the palette");
+						}
+						for (i=0; i<chunk_size; i++) {
+							read_char_from_stream(image_data, &iter, &trans_p);
+							image_header.image_palette[i] &= 0xFFFFFF |
+								((trans_p << 28) | (trans_p << 24));
+						}
+					} else {
+						EMGD_ERROR("Palette has not been initialized yet");
+					}
+					break;
+			}
+			break;
+
+		case CHUNK_BKGD:
+			/* Truecolor */
+			if (image_header.colour_type == COLOR_TRUE_ALPHA ||
+				image_header.colour_type == COLOR_TRUE) {
+
+				switch (image_header.bit_depth) {
+				case 16:
+					read_char_from_stream(image_data, &iter,
+						&image_header.background_r);
+					iter++;
+					read_char_from_stream(image_data, &iter,
+						&image_header.background_g);
+					iter++;
+					read_char_from_stream(image_data, &iter,
+						&image_header.background_b);
+					iter++;
+					break;
+				case 8:
+					iter++;
+					read_char_from_stream(image_data, &iter,
+						&image_header.background_r);
+					iter++;
+					read_char_from_stream(image_data, &iter,
+						&image_header.background_g);
+					iter++;
+					read_char_from_stream(image_data, &iter,
+						&image_header.background_b);
+					break;
+				}
+			}
+
+			/* Grayscale */
+			if (image_header.colour_type == COLOR_GREY_ALPHA ||
+				image_header.colour_type == COLOR_GREY) {
+
+				switch (image_header.bit_depth) {
+				case 16:
+					read_char_from_stream(image_data, &iter,
+						&image_header.background_r);
+					iter++;
+					break;
+				case 8:
+					iter++;
+					read_char_from_stream(image_data, &iter,
+						&image_header.background_r);
+					break;
+				case 4:
+					iter++;
+					read_char_from_stream(image_data, &iter,
+						&image_header.background_r);
+					image_header.background_r =
+						((image_header.background_r >> 4) << 4) |
+						(image_header.background_r >> 4);
+					break;
+				case 2:
+					iter++;
+					read_char_from_stream(image_data, &iter,
+						&image_header.background_r);
+					image_header.background_r =
+						((image_header.background_r >> 2) << 6) |
+						((image_header.background_r >> 2) << 4) |
+						((image_header.background_r >> 2) << 2) |
+						(image_header.background_r >> 2);
+					break;
+				case 1:
+					iter++;
+					read_char_from_stream(image_data, &iter,
+						&image_header.background_r);
+					image_header.background_r =
+						(image_header.background_r << 7) |
+						(image_header.background_r << 6) |
+						(image_header.background_r << 5) |
+						(image_header.background_r << 4) |
+						(image_header.background_r << 3) |
+						(image_header.background_r << 2) |
+						(image_header.background_r << 1) |
+						image_header.background_r;
+					break;
+				}
+				image_header.background_g = image_header.background_r;
+				image_header.background_b = image_header.background_r;
+			}
+
+			image_header.background = 0xFF000000 |
+				image_header.background_r<<16 |
+				image_header.background_g<<8 |
+				image_header.background_b;
+			break;
+
+		case CHUNK_GAMA:
+			read_int_from_stream(image_data, &iter, &gama);
+			break;
+
+		case CHUNK_PLTE:
+			palette_size = chunk_size/3;
+			image_header.image_palette =
+				vmalloc(sizeof(unsigned long) * palette_size);
+			if (!image_header.image_palette) {
+				EMGD_ERROR("Out of memory");
+				return;
+			}
+			OS_MEMSET(image_header.image_palette, 0,
+				sizeof(unsigned long) * palette_size);
+
+			for (i=0; i<palette_size; i++) {
+				image_header.image_palette[i] = (
+					0xFF000000 |
+					((unsigned char)image_data[iter] << 16) |
+					((unsigned char)image_data[iter+1] << 8) |
+					(unsigned char)image_data[iter+2]);
+				iter += 3;
+			}
+			break;
+
+		case CHUNK_IDAT:
+			if (!default_image) {
+				default_image = vmalloc(sizeof(png_header));
+				if (!default_image) {
+					EMGD_ERROR("Out of memory");
+					return;
+				}
+				OS_MEMSET(default_image, 0, sizeof(png_header));
+				default_image->width = image_header.width;
+				default_image->height = image_header.height;
+				default_image->x_offset = 0;
+				default_image->y_offset = 0;
+				default_image->bytes_pp = image_header.bytes_pp;
+				default_image->bytes_pl = image_header.bytes_pl;
+				default_image->blend_op = APNG_BLEND_OP_SOURCE;
+				default_image->dispose_op = APNG_DISPOSE_OP_NONE;
+			}
+			for (i=0; i<chunk_size; i++) {
+				input_data[input_iter++] = image_data[iter++];
+			}
+			break;
+
+		case CHUNK_ACTL:
+			apng_file = 1;
+			read_int_from_stream(image_data, &iter, &apng_num_frames);
+			read_int_from_stream(image_data, &iter, &apng_num_plays);
+			frames = vmalloc(apng_num_frames * sizeof(png_frame));
+			if (!frames) {
+				EMGD_ERROR("Out of memory.");
+				return;
+			}
+			OS_MEMSET(frames, 0, apng_num_frames * sizeof(png_frame));
+			break;
+
+		case CHUNK_FCTL:
+			if (cur_seq_num > 0) {
+				decode_png_data(&image_header,input_data,&frames[cur_frame-1]);
+			} else {
+				if (default_image) {
+					decode_png_data(&image_header, input_data, default_image);
+				}
+			}
+
+			/* Should we wipe out the input_data buffer? */
+			input_iter = 0;
+
+			read_int_from_stream(image_data, &iter, &sequence_number);
+			read_int_from_stream(image_data, &iter, &frames[cur_frame].width);
+			read_int_from_stream(image_data, &iter, &frames[cur_frame].height);
+			read_int_from_stream(image_data, &iter, &frames[cur_frame].x_offset);
+			read_int_from_stream(image_data, &iter, &frames[cur_frame].y_offset);
+			read_short_from_stream(image_data, &iter, &delay_num);
+			read_short_from_stream(image_data, &iter, &delay_den);
+			read_char_from_stream(image_data, &iter, &frames[cur_frame].dispose_op);
+			read_char_from_stream(image_data, &iter, &frames[cur_frame].blend_op);
+
+			if (delay_num) {
+				if (!delay_den) {
+					frames[cur_frame].delay = 10000 * (unsigned long)delay_num;
+				} else {
+					frames[cur_frame].delay = (1000000 *
+						(unsigned long)delay_num) / (unsigned long)delay_den;
+				}
+			}
+
+			/*
+			 * Adding 7 to the bits per pixel before we divide by 8
+			 * gives us the ceiling of bytes per pixel instead of the floor.
+			 */
+			frames[cur_frame].bytes_pp = (image_header.bpp + 7) / 8;
+			frames[cur_frame].bytes_pl =
+				((frames[cur_frame].width * image_header.bpp) + 7) / 8;
+
+			cur_frame++;
+
+			if (sequence_number != cur_seq_num++) {
+				EMGD_ERROR("Sequence numbers do not match!");
+				return;
+			}
+			break;
+
+		case CHUNK_FDAT:
+			read_int_from_stream(image_data, &iter, &sequence_number);
+			if (sequence_number != cur_seq_num++) {
+				EMGD_ERROR("Sequence numbers do not match!");
+				return;
+			}
+			for (i=4; i<chunk_size; i++) {
+				input_data[input_iter++] = image_data[iter++];
+			}
+			break;
+
+		case CHUNK_IEND:
+			if (!frames && default_image) {
+				decode_png_data(&image_header, input_data,
+					default_image);
+			} else {
+				decode_png_data(&image_header, input_data,
+					&frames[cur_frame-1]);
+			}
+			break;
+
+		default:
+			iter += chunk_size;
+			break;
+		}
+
+		/*
+		 * Skip over the CRC for now, do we actually want to spend
+		 * time checking this? Per the spec, unless there is an a corrupted
+		 * header, the only possible outcome is a corrupted image.  It's
+		 * either that, or we don't display any image, maybe in this case we
+		 * should display a blue screen. :)
+		 */
+		iter += 4;
+
+		/* Get the next chunk */
+		read_int_from_stream(image_data, &iter, &chunk_size);
+		read_int_from_stream(image_data, &iter, &chunk_type);
+	}
+
+	if (input_data) {
+		vfree(input_data);
+		input_data = NULL;
+	}
+
+	if (apng_file && !apng_num_plays) {
+		apng_num_plays = 20;
+	}
+	if (apng_num_frames > 0) {
+		frames[apng_num_frames-1].dispose_op = APNG_DISPOSE_OP_NONE;
+		if (frames[0].dispose_op == APNG_DISPOSE_OP_PREVIOUS) {
+			frames[0].dispose_op = APNG_DISPOSE_OP_BACKGROUND;
+		}
+	}
+	for (i=0; i<apng_num_plays; i++) {
+		for (cur_frame=0; cur_frame<apng_num_frames; cur_frame++) {
+			if (cur_frame > 0) {
+				prev_dispose_op = frames[cur_frame-1].dispose_op;
+			}
+			display_png_frame(fb_info, fb, image_header, &frames[cur_frame],
+				prev_dispose_op);
+		}
+	}
+	if (!apng_file) {
+		display_png_frame(fb_info, fb, image_header, default_image,
+			APNG_DISPOSE_OP_NONE);
+	}
+
+	for (cur_frame=0; cur_frame<apng_num_frames; cur_frame++) {
+		if (frames[cur_frame].output) {
+			vfree(frames[cur_frame].output);
+			frames[cur_frame].output = NULL;
+		}
+	}
+	if (frames) {
+		vfree(frames);
+		frames = NULL;
+	}
+
+	if (default_image->output) {
+		vfree(default_image->output);
+		default_image->output = NULL;
+	}
+
+	if (default_image) {
+		vfree(default_image);
+		default_image = NULL;
+	}
+
+	EMGD_TRACE_EXIT;
+}
+
+void display_png_frame(
+	igd_framebuffer_info_t *fb_info,
+	unsigned char *fb,
+	png_header image_header,
+	png_frame *frame,
+	unsigned long prev_dispose_op)
+{
+	unsigned char *fb_addr = NULL;
+	unsigned long *fb_addr_long = NULL;
+	unsigned long init_x_shift, init_y_shift, row, col, j;
+	unsigned char image_alpha;
+	unsigned char background_alpha;
+	unsigned long *previous = NULL;
+
+	if (frame->dispose_op == APNG_DISPOSE_OP_PREVIOUS) {
+		previous = vmalloc(frame->width*frame->height*sizeof(unsigned long));
+		if (!previous) {
+			EMGD_ERROR("Out of memory.");
+			return;
+		}
+	}
+
+	/* Lets position our image at the supplied offsets on the screen */
+	/* TODO: Need to account for negative offset */
+	init_x_shift = (image_header.x_offset + frame->x_offset) *
+		sizeof(unsigned long);
+	init_y_shift = (image_header.y_offset + frame->y_offset) *
+		fb_info->screen_pitch;
+	fb_addr = fb + init_y_shift;
+	fb_addr_long = (unsigned long *) &fb_addr[init_x_shift];
+
+	row = 0;
+	j = 0;
+
+	switch (frame->blend_op) {
+
+	/* Blending against our background color */
+	case APNG_BLEND_OP_SOURCE:
+		while (row < frame->height){
+			col = 0;
+			fb_addr_long = (unsigned long *)
+				&fb_addr[fb_info->screen_pitch * row + init_x_shift];
+
+			if (frame->dispose_op == APNG_DISPOSE_OP_PREVIOUS) {
+				/* Save the previous since we need to dispose to it */
+				OS_MEMCPY((void *)&previous[j], (void *)fb_addr_long,
+					frame->width * sizeof(unsigned long));
+			}
+
+			/* Put together the pixel and output to framebuffer */
+			while (col < frame->width) {
+				image_alpha = frame->output[j]>>24;
+				if (image_alpha){
+					if (image_alpha != 0xFF){
+						background_alpha = (0xFF - image_alpha) & 0xFF;
+
+						frame->output[j] = 0xFF000000 |
+							((((((frame->output[j]&0xFF0000)>>16) *
+								image_alpha)/0xFF) +
+							((((image_header.background&0xFF0000)>>16) *
+								background_alpha)/0xFF))<<16) |
+							((((((frame->output[j]&0x00FF00)>>8) *
+								image_alpha)/0xFF) +
+							((((image_header.background&0x00FF00)>>8) *
+								background_alpha)/0xFF))<<8) |
+							((((((frame->output[j]&0x0000FF)) *
+								image_alpha)/0xFF) +
+							((((image_header.background&0x0000FF)) *
+								background_alpha)/0xFF)));
+					}
+				} else {
+					frame->output[j] = image_header.background;
+				}
+				fb_addr_long[col] = frame->output[j];
+				col++;
+				j++;
+			}
+			row++;
+		}
+		break;
+
+	/* Blending against previous frame */
+	case APNG_BLEND_OP_OVER:
+		while (row < frame->height){
+			col = 0;
+			fb_addr_long = (unsigned long *)
+				&fb_addr[fb_info->screen_pitch * row + init_x_shift];
+
+			if (frame->dispose_op == APNG_DISPOSE_OP_PREVIOUS) {
+				/* Save the previous isince we need to dispose to it */
+				OS_MEMCPY((void *)&previous[j], (void *)fb_addr_long,
+						frame->width * sizeof(unsigned long));
+			}
+
+			/* Blend the pixel with existing framebuffer pixel */
+			while (col < frame->width) {
+				image_alpha = frame->output[j]>>24;
+
+				if (image_alpha){
+					if (image_alpha != 0xFF){
+						background_alpha = (0xFF - image_alpha) & 0xFF;
+
+						frame->output[j] = 0xFF000000 |
+							((((((frame->output[j]&0xFF0000)>>16) *
+								image_alpha)/0xFF) +
+							  ((((fb_addr_long[col]&0xFF0000)>>16) *
+								background_alpha)/0xFF))<<16) |
+							((((((frame->output[j]&0x00FF00)>>8) *
+								image_alpha)/0xFF) +
+							  ((((fb_addr_long[col]&0x00FF00)>>8) *
+								background_alpha)/0xFF))<<8) |
+							((((((frame->output[j]&0x0000FF)) *
+								image_alpha)/0xFF) +
+							  ((((fb_addr_long[col]&0x0000FF)) *
+								background_alpha)/0xFF)));
+					}
+					fb_addr_long[col] = frame->output[j];
+				}
+				col++;
+				j++;
+			}
+			row++;
+		}
+		break;
+	}
+
+	if (frame->delay) {
+		OS_SLEEP(frame->delay);
+	}
+
+	fb_addr = fb + init_y_shift;
+	fb_addr_long = (unsigned long *) &fb_addr[init_x_shift];
+	row = 0;
+
+	/* TODO: It would be better to only do this to the portions of the
+	 * frame that will not get overwritten by the next frame.
+	 */
+	switch (frame->dispose_op) {
+	case APNG_DISPOSE_OP_PREVIOUS:
+		j = 0;
+		while (row < frame->height){
+			fb_addr_long = (unsigned long *)
+				&fb_addr[fb_info->screen_pitch * row + init_x_shift];
+
+			OS_MEMCPY((void *)fb_addr_long, (void *)&previous[j],
+				frame->width * sizeof(unsigned long));
+
+			j+= frame->width;
+			row++;
+		}
+		if (previous) {
+			vfree(previous);
+			previous = NULL;
+		}
+		break;
+	case APNG_DISPOSE_OP_BACKGROUND:
+		while (row < frame->height){
+			fb_addr_long = (unsigned long *)
+				&fb_addr[fb_info->screen_pitch * row + init_x_shift];
+
+			OS_MEMSET((void *)fb_addr_long, image_header.background,
+				frame->width * sizeof(unsigned long));
+
+			row++;
+		}
+		break;
+	}
+}
+
+
+void decode_png_data(
+	png_header *image_header,
+	unsigned char *input_data,
+	png_frame *frame)
+{
+	unsigned char *output;
+	unsigned long output_iter = 0;
+
+	unsigned long iter = 0;
+	unsigned char bit_iter = 0;
+	unsigned long row = 0, col = 0;
+	unsigned long end_of_row;
+	unsigned long j,k,l;
+
+	unsigned char zlib_cmf = 0;
+	unsigned char zlib_flg = 0;
+	unsigned char zlib_cm = 0;
+	unsigned char zlib_cinfo = 0;
+	unsigned char zlib_fcheck = 0;
+	unsigned char zlib_fdict = 0;
+	unsigned char zlib_flevel = 0;
+	unsigned long zlib_dictid = 0;
+
+	huffman_node *length_tree = NULL;
+	huffman_node *distance_tree = NULL;
+
+	unsigned char paeth_a, paeth_b, paeth_c;
+	unsigned long paeth_p, paeth_pa, paeth_pb, paeth_pc;
+
+	unsigned long filter_type = 0;
+	unsigned long bfinal = 0;
+	unsigned long btype = 0;
+	unsigned char compr_len = 0;
+	unsigned char compr_nlen = 0;
+	unsigned int small_color;
+
+	/* Allocate space for out output buffer */
+	output = (unsigned char *)vmalloc(
+		frame->height * frame->bytes_pl + frame->height);
+	if (!output) {
+		EMGD_ERROR("Out of memory.");
+		return;
+	}
+	OS_MEMSET(output, 0, frame->height * frame->bytes_pl + frame->height);
+
+	frame->size = frame->height * frame->width * sizeof(unsigned long);
+	frame->output = vmalloc(frame->size);
+	if (!frame->output) {
+		frame->size = 0;
+		EMGD_ERROR("Out of memory.");
+		return;
+	}
+	OS_MEMSET(frame->output, 0, frame->size);
+
+	/* Data, this needs to be decompressed per zlib spec */
+	if (!zlib_cmf) {
+		zlib_cmf = (unsigned char)input_data[iter++];
+		zlib_flg = (unsigned char)input_data[iter++];
+		zlib_cm = zlib_cmf & 0xF;
+		zlib_cinfo = (zlib_cmf >> 4) & 0xF;
+		zlib_fcheck = zlib_flg & 0x1F;
+		zlib_fdict = (zlib_flg & 0x20) >> 5;
+		zlib_flevel = (zlib_flg >> 6) & 0x3;
+
+		if (zlib_fdict) {
+			read_int_from_stream(input_data, &iter, &zlib_dictid);
+		}
+	}
+
+	/* Here is where we need to process data as a bit stream */
+	bfinal = 0;
+	while (!bfinal) {
+		read_bits_from_stream(input_data, &iter, &bit_iter, 1, &bfinal);
+		read_bits_from_stream(input_data, &iter, &bit_iter, 2, &btype);
+
+		if (btype == 0){
+
+			if (bit_iter) {
+				iter++;
+				bit_iter = 0;
+			}
+
+			/* No Compression */
+			read_char_from_stream(input_data, &iter, &compr_len);
+			read_char_from_stream(input_data, &iter, &compr_nlen);
+
+			for (j = 0;j < compr_len; j++) {
+				read_char_from_stream(input_data, &iter, &output[j]);
+			}
+
+		} else {
+
+			if (btype == 2){
+
+				/* Compressed with dynamnic Huffman codes */
+				build_dynamic_huffman_tree(
+						input_data,
+						&iter,
+						&bit_iter,
+						&length_tree,
+						&distance_tree);
+			} else {
+
+				/* Compressed with static Huffman codes */
+				build_static_huffman_tree(&length_tree,	&distance_tree);
+			}
+
+			/* Decompress huffman code */
+			decompress_huffman(
+					input_data,
+					&iter,
+					&bit_iter,
+					&length_tree,
+					&distance_tree,
+					output,
+					&output_iter);
+
+			free_node(length_tree);
+			free_node(distance_tree);
+		}
+	}
+
+	row = 0;
+	j = 0;
+	l = 0;
+
+	/*
+	 * Process the scanline filtering
+	 * This filtering works by using a difference from a previous pixel
+	 * instead of full pixel data.
+	 */
+	while (row < frame->height){
+		j = row * frame->bytes_pl + row;
+		end_of_row = j + frame->bytes_pl;
+		filter_type = output[j++];
+
+		switch (filter_type) {
+		case 1:
+			/* Filter type of 1 uses the previous pixel */
+			for (k=j+frame->bytes_pp; k<=end_of_row; k++) {
+				output[k] += output[k-frame->bytes_pp];
+			}
+			break;
+		case 2:
+			/* Filter type of 2 uses the previous row's pixel */
+			if (row) {
+				for (k=j; k<=end_of_row; k++) {
+					output[k] += output[k-frame->bytes_pl-1];
+				}
+			}
+			break;
+		case 3:
+			/*
+			 * Filter type of 3 uses the average of the
+			 * previous pixel and the previous row's pixel
+			 */
+			if (row) {
+				for (k=j; k<j+frame->bytes_pp; k++) {
+					output[k] += output[k-frame->bytes_pl-1]/2;
+				}
+				for (k=j+frame->bytes_pp; k<=end_of_row; k++) {
+					output[k] += (output[k-frame->bytes_pp] +
+						output[k-frame->bytes_pl-1])/2;
+				}
+			} else {
+				for (k=j+frame->bytes_pp; k<=end_of_row; k++) {
+					output[k] = output[k] +
+						output[k-frame->bytes_pp]/2;
+				}
+			}
+			break;
+		case 4:
+			/*
+			 * Filter type of 4 uses this algorithm to
+			 * determine if it should use the previous pixel,
+			 * the previous row's pixel, or the pixel immediately
+			 * before the previous row's pixel.
+			 */
+			for (k=j; k<=end_of_row; k++) {
+
+				if (k >= j + frame->bytes_pp) {
+					paeth_a = output[k-frame->bytes_pp];
+				} else {
+					paeth_a = 0;
+				}
+
+				if (row) {
+					paeth_b = output[k-frame->bytes_pl-1];
+				} else {
+					paeth_b = 0;
+				}
+
+				if (row && k >= j + frame->bytes_pp) {
+					paeth_c = output[k-frame->bytes_pp-frame->bytes_pl-1];
+				} else {
+					paeth_c = 0;
+				}
+
+				paeth_p = paeth_a + paeth_b - paeth_c;
+				paeth_pa = abs(paeth_p - paeth_a);
+				paeth_pb = abs(paeth_p - paeth_b);
+				paeth_pc = abs(paeth_p - paeth_c);
+
+				if (paeth_pa <= paeth_pb && paeth_pa <= paeth_pc) {
+					output[k] += paeth_a;
+				} else if (paeth_pb <= paeth_pc) {
+					output[k] += paeth_b;
+				} else {
+					output[k] += paeth_c;
+				}
+			}
+			break;
+		}
+
+		col = 0;
+
+		/* Put together the pixel and output to framebuffer */
+		while (col < frame->width) {
+
+			/* Truecolor with alpha, 16 bits per component */
+			if (image_header->colour_type == COLOR_TRUE_ALPHA &&
+				image_header->bit_depth == 16) {
+
+				frame->output[l] = (output[j+6]<<24 | output[j]<<16 |
+					output[j+2]<<8 | output[j+4]);
+			}
+
+
+			/* Truecolor with alpha, 8 bits per component */
+			if (image_header->colour_type == COLOR_TRUE_ALPHA &&
+				image_header->bit_depth == 8) {
+
+				frame->output[l] = (output[j+3]<<24 | output[j]<<16 |
+					output[j+1]<<8 | output[j+2]);
+			}
+
+			/* Grayscale with alpha, 16 bits per component */
+			if (image_header->colour_type == COLOR_GREY_ALPHA &&
+				image_header->bit_depth == 16) {
+
+				frame->output[l] = (output[j+2]<<24 | output[j]<<16 |
+					output[j]<<8 | output[j]);
+			}
+
+			/* Grayscale with alpha, 8 bits per component */
+			if (image_header->colour_type == COLOR_GREY_ALPHA &&
+				image_header->bit_depth == 8) {
+
+				frame->output[l] = (output[j+1]<<24 | output[j]<<16 |
+					output[j]<<8 | output[j]);
+
+			}
+
+			/* Truecolor, 16 bits per component */
+			if (image_header->colour_type == COLOR_TRUE &&
+				image_header->bit_depth == 16) {
+
+				if (!image_header->using_transparency ||
+					image_header->transparency_r !=
+					(output[j] | output[j+1]) ||
+					image_header->transparency_g !=
+					(output[j+2] | output[j+3]) ||
+					image_header->transparency_b !=
+					(output[j+4] | output[j+5])) {
+
+					frame->output[l] = (0xFF000000 | output[j]<<16 |
+						output[j+2]<<8 | output[j+4]);
+				}
+			}
+
+			/* Truecolor, 8 bits per component */
+			if (image_header->colour_type == COLOR_TRUE &&
+				image_header->bit_depth == 8) {
+
+				if (!image_header->using_transparency ||
+					image_header->transparency_r != output[j] ||
+					image_header->transparency_g != output[j+1] ||
+					image_header->transparency_b != output[j+2]) {
+
+					frame->output[l] = (0xFF000000 | (output[j]<<16) |
+						(output[j+1]<<8) | (output[j+2]));
+				}
+			}
+
+			/* Grayscale, 16 bits per component */
+			if (image_header->colour_type == COLOR_GREY &&
+				image_header->bit_depth == 16) {
+
+				if (!image_header->using_transparency ||
+					image_header->transparency_r !=
+					(output[j] | output[j+1])) {
+
+					frame->output[l] = (0xFF000000 |(output[j]<<16) |
+						(output[j]<<8) | output[j]);
+				}
+			}
+
+			/* Grayscale, 8 bits per component */
+			if (image_header->colour_type == COLOR_GREY &&
+				 image_header->bit_depth == 8) {
+
+				if (!image_header->using_transparency ||
+					image_header->transparency_r != output[j]) {
+					frame->output[l] = (0xFF000000 | (output[j]<<16) |
+						(output[j]<<8) | output[j]);
+				}
+			}
+
+			/* Grayscale, 4 bits per component */
+			if (image_header->colour_type == COLOR_GREY &&
+				image_header->bit_depth == 4) {
+
+				if (!image_header->using_transparency ||
+					image_header->transparency_r != ((output[j] & 0xF0)>>4)) {
+
+					frame->output[l] =
+						CONV_GS_4_TO_32((output[j] & 0xF0)>>4);
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					if (!image_header->using_transparency ||
+						image_header->transparency_r != (output[j] & 0x0F)) {
+
+						frame->output[l] =
+							CONV_GS_4_TO_32(output[j] & 0x0F);
+					}
+				}
+			}
+
+			/* Grayscale, 2 bits per component */
+			if (image_header->colour_type == COLOR_GREY &&
+				image_header->bit_depth == 2) {
+
+				if (!image_header->using_transparency ||
+					image_header->transparency_r != ((output[j] & 0xC0)>>6)) {
+
+					frame->output[l] =
+						CONV_GS_2_TO_32((output[j] & 0xC0) >> 6);
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					if (!image_header->using_transparency ||
+						image_header->transparency_r != ((output[j] & 0x30)>>4)) {
+
+						frame->output[l] =
+							CONV_GS_2_TO_32((output[j] & 0x30) >> 4);
+					}
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					if (!image_header->using_transparency ||
+						image_header->transparency_r != ((output[j] & 0x0C)>>2)) {
+
+						frame->output[l] =
+							CONV_GS_2_TO_32((output[j] & 0x0C) >> 2);
+					}
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					if (!image_header->using_transparency ||
+						image_header->transparency_r != (output[j] & 0x03)) {
+
+						frame->output[l] =
+							CONV_GS_2_TO_32(output[j] & 0x03);
+					}
+				}
+			}
+
+			/* Grayscale, 1 bit per component */
+			if (image_header->colour_type == COLOR_GREY &&
+				image_header->bit_depth == 1) {
+
+				if (!image_header->using_transparency ||
+					image_header->transparency_r != ((output[j] & 0x80)>>7)) {
+
+					frame->output[l] =
+						CONV_GS_1_TO_32((output[j] & 0x80) >> 7);
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					if (!image_header->using_transparency ||
+						image_header->transparency_r != ((output[j] & 0x40)>>6)) {
+
+						frame->output[l] =
+							CONV_GS_1_TO_32((output[j] & 0x40) >> 6);
+					}
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					if (!image_header->using_transparency ||
+						image_header->transparency_r != ((output[j] & 0x20)>>5)) {
+
+						frame->output[l] =
+							CONV_GS_1_TO_32((output[j] & 0x20) >> 5);
+					}
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					if (!image_header->using_transparency ||
+						image_header->transparency_r != ((output[j] & 0x10)>>4)) {
+
+						frame->output[l] =
+							CONV_GS_1_TO_32((output[j] & 0x10) >> 4);
+					}
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					if (!image_header->using_transparency ||
+						image_header->transparency_r != ((output[j] & 0x08)>>3)) {
+
+						frame->output[l] =
+							CONV_GS_1_TO_32((output[j] & 0x08) >> 3);
+					}
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					if (!image_header->using_transparency ||
+						image_header->transparency_r != ((output[j] & 0x04)>>2)) {
+
+						frame->output[l] =
+							CONV_GS_1_TO_32((output[j] & 0x04) >> 2);
+					}
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					if (!image_header->using_transparency ||
+						image_header->transparency_r != ((output[j] & 0x02)>>1)) {
+
+						frame->output[l] =
+							CONV_GS_1_TO_32((output[j] & 0x02) >> 1);
+					}
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					if (!image_header->using_transparency ||
+						image_header->transparency_r != (output[j] & 0x01)) {
+
+						frame->output[l] =
+							CONV_GS_1_TO_32(output[j] & 0x01);
+					}
+				}
+			}
+
+			/* Palette, 8 bit per component */
+			if (image_header->colour_type == COLOR_INDEXED &&
+				image_header->bit_depth == 8) {
+
+				small_color = output[j];
+				frame->output[l] = 0xFF000000 |
+					image_header->image_palette[small_color];
+			}
+
+			/* Palette, 4 bit per component */
+			if (image_header->colour_type == COLOR_INDEXED &&
+				image_header->bit_depth == 4) {
+
+				small_color = (output[j] & 0xF0) >> 4;
+				frame->output[l] = 0xFF000000 |
+					image_header->image_palette[small_color];
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					small_color = output[j] & 0x0F;
+					frame->output[l] = 0xFF000000 |
+						image_header->image_palette[small_color];
+				}
+			}
+
+			/* Palette, 2 bit per component */
+			if (image_header->colour_type == COLOR_INDEXED &&
+				image_header->bit_depth == 2) {
+
+				small_color = (output[j] & 0xC0) >> 6;
+				frame->output[l] = 0xFF000000 |
+					image_header->image_palette[small_color];
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					small_color = output[j] & 0x30 >> 4;
+					frame->output[l] = 0xFF000000 |
+						image_header->image_palette[small_color];
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					small_color = output[j] & 0x0C >> 2;
+					frame->output[l] = 0xFF000000 |
+						image_header->image_palette[small_color];
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					small_color = output[j] & 0x03;
+					frame->output[l] = 0xFF000000 |
+						image_header->image_palette[small_color];
+				}
+			}
+
+			/* Palette, 1 bit per component */
+			if (image_header->colour_type == COLOR_INDEXED &&
+				image_header->bit_depth == 1) {
+
+				small_color = (output[j] & 0x80) >> 7;
+				frame->output[l] = 0xFF000000 |
+					image_header->image_palette[small_color];
+
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					small_color = (output[j] & 0x40) >> 6;
+					frame->output[l] = 0xFF000000 |
+						image_header->image_palette[small_color];
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					small_color = (output[j] & 0x20) >> 5;
+					frame->output[l] = 0xFF000000 |
+						image_header->image_palette[small_color];
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					small_color = (output[j] & 0x10) >> 4;
+					frame->output[l] = 0xFF000000 |
+						image_header->image_palette[small_color];
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					small_color = (output[j] & 0x08) >> 3;
+					frame->output[l] = 0xFF000000 |
+						image_header->image_palette[small_color];
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					small_color = (output[j] & 0x04) >> 2;
+					frame->output[l] = 0xFF000000 |
+						image_header->image_palette[small_color];
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					small_color = (output[j] & 0x02) >> 1;
+					frame->output[l] = 0xFF000000 |
+						image_header->image_palette[small_color];
+				}
+				if (col + 1 < frame->width) {
+					l++;
+					col++;
+					small_color = (output[j] & 0x01);
+					frame->output[l] = 0xFF000000 |
+						image_header->image_palette[small_color];
+				}
+			}
+
+			j += image_header->bytes_pp;
+			l++;
+			col++;
+			if (l > frame->height * frame->width) {
+				EMGD_ERROR("l is larger than frame output size!");
+				return;
+			}
+		}
+		row++;
+	}
+
+	vfree(output);
+}
+
+/*
+ * This is the function to decompress a huffman tree.
+ *
+ * @param stream (IN) This is the input data stream from which we are reading.
+ * @param iter (IN/OUT) This is the input data stream's char iterator
+ * @param bit_iter (IN/OUT) This is the bit iterator for the particular char we
+ *                          are reading.
+ * @param length_tree (IN) This is the huffman code's length tree.
+ * @param distance_tree (IN) This is the huffman code's distance tree.
+ * @param output (IN/OUT) This is an output stream to which we write out the
+ *                        decompressed huffman data.
+ * @param output_iter (IN/OUT) This is the output iterator.
+ */
+void decompress_huffman(
+	unsigned char *stream,
+	unsigned long *iter,
+	unsigned char *bit_iter,
+	huffman_node **length_tree,
+	huffman_node **distance_tree,
+	unsigned char *output,
+	unsigned long *output_iter)
+{
+
+	unsigned long j,k;
+	huffman_node *final_node;
+	unsigned long extra_value = 0;
+	unsigned long length_value = 0;
+	unsigned long distance_value = 0;
+
+	/* Start going along the bitstream and traversing the tree
+	 * until you get to a leaf
+	 */
+	get_huffman_code(stream, iter, bit_iter, length_tree, &final_node);
+
+	while (final_node->value != 256) {
+
+		if (final_node->value < 256){
+			/* literal value */
+			output[*output_iter] = final_node->value;
+			(*output_iter)++;
+		}
+		if (final_node->value > 256){
+			/* We have the initial length value,
+			 * now get the extra length bits, if any
+			 */
+			extra_value = 0;
+			length_value = 0;
+			for (j=0; j<final_node->extra_bits; j++){
+				extra_value = read_bit_from_stream(stream, iter, bit_iter);
+				length_value += extra_value << j;
+			}
+			length_value += final_node->real;
+
+			/* Now its time to get the distance value */
+			get_huffman_code(stream, iter, bit_iter, distance_tree, &final_node);
+
+			/* Get any extra bits for the distance value */
+			extra_value = 0;
+			distance_value = 0;
+			for (j=0; j<final_node->extra_bits; j++){
+				extra_value = read_bit_from_stream(stream, iter, bit_iter);
+				distance_value += extra_value << j;
+			}
+			distance_value += final_node->real;
+
+			/*
+			 * Now we need to use the distance and length values
+			 * to copy previously existing values
+			 */
+			distance_value = (*output_iter) - distance_value;
+			for (k=0; k<length_value; k++){
+				output[*output_iter] = output[distance_value];
+				(*output_iter)++;
+				distance_value++;
+			}
+		}
+
+		/* Get the next code */
+		get_huffman_code(stream, iter, bit_iter, length_tree, &final_node);
+	}
+}
+
+
+/*
+ * This is the function to build a static huffman tree.
+ *
+ * @param length_tree (OUT) This is the huffman code's length tree.
+ * @param distance_tree (OUT) This is the huffman code's distance tree.
+ */
+void build_static_huffman_tree(
+	huffman_node **length_tree,
+	huffman_node **distance_tree) {
+
+	huffman_node *new_node = NULL;
+	huffman_node *cur_node = NULL;
+	unsigned long j,k;
+	unsigned long running_literal_value = 0;
+	unsigned long running_real_value = 0;
+
+	unsigned long ltree_literal_value[10] =
+		{256,265,269,273,277,  0,280,281,285,144};
+	unsigned long ltree_real_value[10] =
+		{  2, 11, 19, 35, 67,  0,115,131,258,144};
+	unsigned long ltree_literal_length[10] =
+		{  9,  4,  4,  4,  3,144,  1,  4,  3,112};
+	unsigned long ltree_code_start[10] =
+		{  0,  9, 13, 17, 21, 48,192,193,197,400};
+	unsigned long ltree_code_length[10] =
+		{  7,  7,  7,  7,  7,  8,  8,  8,  8,  9};
+	unsigned long ltree_extra_bits[10] =
+		{  0,  1,  2,  3,  4,  0,  4,  5,  0,  0};
+
+	unsigned long dtree_literal_value[15] =
+		{0,4,6, 8,10,12, 14, 16, 18,  20,  22,  24,  26,   28,30};
+	unsigned long dtree_real_value[15] =
+		{1,5,9,17,33,65,129,257,513,1025,2049,4097,8193,16385, 0};
+	unsigned long dtree_literal_length[15] =
+		{4,2,2, 2, 2, 2,  2,  2,  2,   2,   2,   2,   2,    2, 2};
+	unsigned long dtree_code_start[15] =
+		{0,4,6, 8,10,12, 14, 16, 18,  20,  22,  24,  26,   28,30};
+	unsigned long dtree_code_length[15] =
+		{5,5,5, 5, 5, 5,  5,  5,  5,   5,   5,   5,   5,    5, 5};
+	unsigned long dtree_extra_bits[15] =
+		{0,1,2, 3, 4, 5,  6,  7,  8,   9,   10,  11, 12,   13, 0};
+
+	/* Build our Huffman length tree using the fixed codes */
+	new_node = (huffman_node *)kzalloc(sizeof(huffman_node), GFP_KERNEL);
+	if (!new_node) {
+		EMGD_ERROR("Out of memory.");
+		return;
+	}
+
+	*length_tree = new_node;
+
+	for (k=0; k<10; k++){
+		running_literal_value = ltree_literal_value[k];
+		running_real_value = ltree_real_value[k];
+		for (j=0; j<ltree_literal_length[k]; j++) {
+			new_node = (huffman_node *)kzalloc(sizeof(huffman_node),GFP_KERNEL);
+			if (!new_node) {
+				EMGD_ERROR("Out of memory.");
+				return;
+			}
+
+			new_node->extra_bits = (unsigned char)ltree_extra_bits[k];
+			new_node->value = running_literal_value;
+			new_node->real = running_real_value;
+			cur_node = *length_tree;
+			add_node(&cur_node,
+					new_node,
+					ltree_code_start[k] + j,
+					ltree_code_length[k]);
+			running_literal_value++;
+			if (ltree_extra_bits[k]){
+				running_real_value += (1<<ltree_extra_bits[k]);
+			}else{
+				running_real_value++;
+			}
+		}
+	}
+
+	/* Build our Huffman distance tree using the fixed codes */
+	new_node = (huffman_node *)kzalloc(sizeof(huffman_node), GFP_KERNEL);
+	if (!new_node) {
+		EMGD_ERROR("Out of memory.");
+		return;
+	}
+	*distance_tree = new_node;
+
+	for (k=0; k<15; k++){
+		running_literal_value = dtree_literal_value[k];
+		running_real_value = dtree_real_value[k];
+		for (j=0; j<dtree_literal_length[k]; j++) {
+			new_node = (huffman_node *)kzalloc(sizeof(huffman_node),GFP_KERNEL);
+			if (!new_node) {
+				EMGD_ERROR("Out of memory.");
+				return;
+			}
+			new_node->extra_bits = (unsigned char)dtree_extra_bits[k];
+			new_node->value = running_literal_value;
+			new_node->real = running_real_value;
+			cur_node = *distance_tree;
+			add_node(&cur_node,
+				new_node,
+				dtree_code_start[k] + j,
+				dtree_code_length[k]);
+			running_literal_value++;
+			if (dtree_extra_bits[k]){
+				running_real_value += (1<<dtree_extra_bits[k]);
+			}else{
+				running_real_value++;
+			}
+		}
+	}
+}
+
+
+/*
+ * This is the function to build a dynamic huffman tree.
+ *
+ * @param stream (IN) This is the input data stream from which we are reading.
+ * @param iter (IN/OUT) This is the input data stream's char iterator
+ * @param bit_iter (IN/OUT) This is the bit iterator for the particular char we
+ *                          are reading.
+ * @param length_tree (OUT) This is the huffman code's length tree.
+ * @param distance_tree (OUT) This is the huffman code's distance tree.
+ */
+void build_dynamic_huffman_tree(
+	unsigned char *stream,
+	unsigned long *iter,
+	unsigned char *bit_iter,
+	huffman_node **length_tree,
+	huffman_node **distance_tree) {
+
+	unsigned long j,k;
+	unsigned long clc_order[19] =
+	{16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
+	unsigned long clc_lengths[19] =
+	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+	unsigned long clc_extra_bits[19] =
+	{2,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+	unsigned long clc_values[19] =
+	{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18};
+	huffman_node *code_length_tree = NULL;
+	unsigned long dynamic_hlit = 0;
+	unsigned long dynamic_hdist = 0;
+	unsigned long dynamic_hclen = 0;
+
+	unsigned long lit_extra_bits_num[LEN_NUM_DISTINCT_EXTRA_BITS] =
+	{265,4,4,4,4,4,1};
+	unsigned long lit_extra_bits[LEN_NUM_DISTINCT_EXTRA_BITS] =
+	{0,1,2,3,4,5,0};
+	unsigned long *dynamic_lit_code = NULL;
+	unsigned long *dynamic_lit_length = NULL;
+	unsigned long *dynamic_lit_extra_bits = NULL;
+	unsigned long *dynamic_lit_values = NULL;
+	unsigned long *dynamic_lit_real_values = NULL;
+
+	unsigned long dist_extra_bits_num[DIST_NUM_DISTINCT_EXTRA_BITS] =
+	{4,2,2,2,2,2,2,2,2,2,2,2,2,2};
+	unsigned long dist_extra_bits[DIST_NUM_DISTINCT_EXTRA_BITS] =
+	{0,1,2,3,4,5,6,7,8,9,10,11,12,13};
+	unsigned long *dynamic_dist_code = NULL;
+	unsigned long *dynamic_dist_length = NULL;
+	unsigned long *dynamic_dist_extra_bits = NULL;
+	unsigned long *dynamic_dist_values = NULL;
+	unsigned long *dynamic_dist_real_values = NULL;
+
+	unsigned long prev_real = 0;
+	unsigned long code_index;
+	huffman_node *new_node = NULL;
+
+	/* Read some initial information about our dynamic huffman tree */
+	read_bits_from_stream(stream, iter, bit_iter, 5, &dynamic_hlit);
+	read_bits_from_stream(stream, iter, bit_iter, 5, &dynamic_hdist);
+	read_bits_from_stream(stream, iter, bit_iter, 4, &dynamic_hclen);
+
+	dynamic_hlit += 257;
+	dynamic_hdist++;
+	dynamic_hclen += 4;
+
+	/* Build our Huffman length tree using the fixed codes */
+	new_node = (huffman_node *)kzalloc(sizeof(huffman_node), GFP_KERNEL);
+	if (!new_node) {
+		EMGD_ERROR("Out of memory.");
+		return;
+	}
+	code_length_tree = new_node;
+
+	/* Get the code lengths */
+	for (k=0; k<19 && k<dynamic_hclen; k++){
+		read_bits_from_stream(stream,
+				iter, bit_iter,	3, &clc_lengths[clc_order[k]]);
+	}
+
+	/* build the code_length tree */
+	if (create_tree(CLC_MAX_BITS, CLC_NUM_CODES,
+				&clc_lengths[0],
+				&clc_extra_bits[0],
+				&clc_values[0],
+				&clc_values[0],
+				&code_length_tree) == 1) {
+		EMGD_ERROR("ERROR: create tree failed\n");
+		return;
+	}
+
+	/* Build the literal/length alphabet */
+	dynamic_lit_code = (unsigned long *)vmalloc(
+			sizeof(unsigned long) * LEN_NUM_CODES);
+	if (!dynamic_lit_code) {
+		EMGD_ERROR("Out of memory.");
+		return;
+	}
+	OS_MEMSET(dynamic_lit_code, 0, sizeof(unsigned long) * LEN_NUM_CODES);
+
+	dynamic_lit_length = (unsigned long *)vmalloc(
+			sizeof(unsigned long) * LEN_NUM_CODES);
+	if (!dynamic_lit_length) {
+		EMGD_ERROR("Out of memory.");
+		return;
+	}
+	OS_MEMSET(dynamic_lit_length, 0, sizeof(unsigned long) * LEN_NUM_CODES);
+
+	dynamic_lit_extra_bits = (unsigned long *)vmalloc(
+			sizeof(unsigned long) * LEN_NUM_CODES);
+	if (!dynamic_lit_extra_bits) {
+		EMGD_ERROR("Out of memory.");
+		return;
+	}
+	OS_MEMSET(dynamic_lit_extra_bits, 0, sizeof(unsigned long)*LEN_NUM_CODES);
+
+	dynamic_lit_values = (unsigned long *)vmalloc(
+			sizeof(unsigned long) * LEN_NUM_CODES);
+	if (!dynamic_lit_values) {
+		EMGD_ERROR("Out of memory.");
+		return;
+	}
+	OS_MEMSET(dynamic_lit_values, 0, sizeof(unsigned long)*LEN_NUM_CODES);
+
+	dynamic_lit_real_values = (unsigned long *)vmalloc(
+			sizeof(unsigned long) * LEN_NUM_CODES);
+	if (!dynamic_lit_real_values) {
+		EMGD_ERROR("Out of memory.");
+		return;
+	}
+	OS_MEMSET(dynamic_lit_real_values, 0, sizeof(unsigned long)*LEN_NUM_CODES);
+
+	/* build extra information, such as extra bits, values and real_values */
+	prev_real = 2;
+	code_index = 0;
+	for (k=0; k<LEN_NUM_DISTINCT_EXTRA_BITS; k++) {
+		for (j=0; j<lit_extra_bits_num[k]; j++) {
+			dynamic_lit_extra_bits[code_index] = lit_extra_bits[k];
+			dynamic_lit_values[code_index] = code_index;
+
+			if (code_index >= LEN_START_REAL_VALUES){
+				dynamic_lit_real_values[code_index] =
+					prev_real += (1<<dynamic_lit_extra_bits[code_index-1]);
+			} else {
+				dynamic_lit_real_values[code_index] = code_index;
+			}
+			code_index++;
+		}
+	}
+
+	/* Doesn't seem to follow the pattern? */
+	dynamic_lit_real_values[285] = 258;
+
+	/* get code lengths for the literal/length alphabet */
+	get_code_lengths(stream, iter, bit_iter, &code_length_tree,
+			dynamic_hlit, dynamic_lit_length);
+
+	/* allocate tree for literal/length codes */
+	new_node = (huffman_node *)kzalloc(sizeof(huffman_node), GFP_KERNEL);
+	if (!new_node) {
+		EMGD_ERROR("Out of memory.");
+		return;
+	}
+	*length_tree = new_node;
+
+	/* build the literal/length tree */
+	if (create_tree(LEN_MAX_BITS, LEN_NUM_CODES,
+				dynamic_lit_length,
+				dynamic_lit_extra_bits,
+				dynamic_lit_values,
+				dynamic_lit_real_values,
+				length_tree) == 1) {
+		EMGD_ERROR("ERROR: create tree failed\n");
+		return;
+	}
+
+	/* free all the literal/length data we are no longer using */
+	vfree(dynamic_lit_code);
+	vfree(dynamic_lit_length);
+	vfree(dynamic_lit_extra_bits);
+	vfree(dynamic_lit_values);
+	vfree(dynamic_lit_real_values);
+
+
+	/* Build the distance alphabet */
+	dynamic_dist_code = (unsigned long *)vmalloc(
+		sizeof(unsigned long) * DIST_NUM_CODES);
+	if (!dynamic_dist_code) {
+		EMGD_ERROR("Out of memory.");
+		return;
+	}
+	OS_MEMSET(dynamic_dist_code, 0, sizeof(unsigned long) * DIST_NUM_CODES);
+
+	dynamic_dist_length = (unsigned long *)vmalloc(
+		sizeof(unsigned long) * DIST_NUM_CODES);
+	if (!dynamic_dist_length) {
+		EMGD_ERROR("Out of memory.");
+		return;
+	}
+	OS_MEMSET(dynamic_dist_length, 0, sizeof(unsigned long) * DIST_NUM_CODES);
+
+	dynamic_dist_extra_bits = (unsigned long *)vmalloc(
+		sizeof(unsigned long) * DIST_NUM_CODES);
+	if (!dynamic_dist_extra_bits) {
+		EMGD_ERROR("Out of memory.");
+		return;
+	}
+	OS_MEMSET(dynamic_dist_extra_bits, 0,
+		sizeof(unsigned long) * DIST_NUM_CODES);
+
+	dynamic_dist_values = (unsigned long *)vmalloc(
+		sizeof(unsigned long) * DIST_NUM_CODES);
+	if (!dynamic_dist_values) {
+		EMGD_ERROR("Out of memory.");
+		return;
+	}
+	OS_MEMSET(dynamic_dist_values, 0, sizeof(unsigned long) * DIST_NUM_CODES);
+
+	dynamic_dist_real_values = (unsigned long *)vmalloc(
+		sizeof(unsigned long) * DIST_NUM_CODES);
+	if (!dynamic_dist_real_values) {
+		EMGD_ERROR("Out of memory.");
+		return;
+	}
+	OS_MEMSET(dynamic_dist_real_values, 0,
+		sizeof(unsigned long) * DIST_NUM_CODES);
+
+	/* build extra information, such as extra bits, values and real_values */
+	prev_real = 1;
+	code_index = 0;
+	for (k=0; k<DIST_NUM_DISTINCT_EXTRA_BITS; k++) {
+		for (j=0; j<dist_extra_bits_num[k]; j++) {
+			dynamic_dist_extra_bits[code_index] = dist_extra_bits[k];
+			dynamic_dist_values[code_index] = code_index;
+
+			if (code_index >= DIST_START_REAL_VALUES){
+				dynamic_dist_real_values[code_index] =
+					prev_real += (1<<dynamic_dist_extra_bits[code_index-1]);
+			} else {
+				dynamic_dist_real_values[code_index] = code_index+1;
+			}
+			code_index++;
+		}
+	}
+
+	/* get code lengths for the distance alphabet */
+	get_code_lengths(stream, iter, bit_iter, &code_length_tree,
+			dynamic_hdist, dynamic_dist_length);
+
+	/* allocate tree for distance codes */
+	new_node = (huffman_node *)kzalloc(sizeof(huffman_node), GFP_KERNEL);
+	if (!new_node) {
+		EMGD_ERROR("Out of memory.");
+		return;
+	}
+	*distance_tree = new_node;
+
+	/* build the distance tree */
+	if (create_tree(DIST_MAX_BITS, DIST_NUM_CODES,
+				&dynamic_dist_length[0],
+				&dynamic_dist_extra_bits[0],
+				&dynamic_dist_values[0],
+				&dynamic_dist_real_values[0],
+				distance_tree) == 1) {
+		EMGD_ERROR("ERROR: create tree failed.\n");
+		return;
+	}
+
+	/* free all the distance data we are no longer using */
+	vfree(dynamic_dist_code);
+	vfree(dynamic_dist_length);
+	vfree(dynamic_dist_extra_bits);
+	vfree(dynamic_dist_values);
+	vfree(dynamic_dist_real_values);
+
+	/* All done with the code length tree, lets free this memory */
+	free_node(code_length_tree);
+}
+
+
+/*
+ * This is the function to get the dynamic code lengths for a specified
+ * number of code lenths. There is some overuse of the word code and code
+ * lengths, but thats sort of the way the PNG spec is.  This is because
+ * we use codes to decode compressed codes.
+ *
+ * @param stream (IN) This is the input data stream from which we are reading.
+ * @param iter (IN/OUT) This is the input data stream's char iterator
+ * @param bit_iter (IN/OUT) This is the bit iterator for the particular char we
+ *                          are reading.
+ * @param code_length_tree (IN) This is the huffman code length tree, which is
+ *                              used to get the code lengths.
+ * @param num_lengths (IN) The number of code lengths.
+ * @param dynamic_lengths (OUT) Gets the dynamic length for the different
+ *                              code lengths
+ */
+void get_code_lengths(
+	unsigned char *stream,
+	unsigned long *iter,
+	unsigned char *bit_iter,
+	huffman_node **code_length_tree,
+	unsigned long num_lengths,
+	unsigned long *dynamic_lengths) {
+
+	unsigned long j,k;
+	huffman_node *final_node;
+	unsigned long dynamic_repeat_length = 0;
+
+	/* get code lengths for the literal/length alphabet */
+	for (k=0; k<num_lengths; k++) {
+		get_huffman_code(stream, iter, bit_iter,
+			code_length_tree, &final_node);
+
+		if (final_node->value < 16){
+			dynamic_lengths[k] = final_node->value;
+		} else {
+			switch (final_node->value) {
+			case 16:
+				/* get repeat length */
+				read_bits_from_stream(stream,
+					iter, bit_iter, 2, &dynamic_repeat_length);
+				dynamic_repeat_length += 3;
+				for (j=0; j<dynamic_repeat_length; j++){
+					dynamic_lengths[k+j] = dynamic_lengths[k-1];
+				}
+				k += j-1;
+				break;
+			case 17:
+				/* get repeat length */
+				read_bits_from_stream(stream,
+					iter, bit_iter, 3, &dynamic_repeat_length);
+				dynamic_repeat_length += 3;
+				for (j=0; j<dynamic_repeat_length; j++){
+					dynamic_lengths[k+j] = 0;
+				}
+				k += j-1;
+				break;
+			case 18:
+				/* get repeat length */
+				read_bits_from_stream(stream,
+					iter, bit_iter, 7, &dynamic_repeat_length);
+				dynamic_repeat_length += 11;
+				for (j=0; j<dynamic_repeat_length; j++){
+					dynamic_lengths[k+j] = 0;
+				}
+				k += j-1;
+				break;
+			}
+		}
+	}
+}
+
+
+/*
+ * This function creates a tree given the necessary tree information.
+ *
+ * @param max_bits (IN) The maximum number of bits for any code
+ * @param num_codes (IN) The number of codes
+ * @param code_lengths (IN) The code lengths
+ * @param extra_bits (IN) The number of extra bits for each huffman code
+ * @param values (IN) The values for the huffman code
+ * @param real_values (IN) The real values for the huffman code
+ * @param tree (OUT) The resulting huffman tree.
+ *
+ * @return 0 on Success
+ * @return >0 on Error
+ */
+int create_tree(
+	unsigned long max_bits,
+	unsigned long num_codes,
+	unsigned long *code_lengths,
+	unsigned long *extra_bits,
+	unsigned long *values,
+	unsigned long *real_values,
+	huffman_node **tree) {
+
+	unsigned long *clc_count;
+	unsigned long *clc_next_code;
+	unsigned long *codes;
+	unsigned long clc_code;
+	unsigned long k;
+	huffman_node *cur_node;
+	huffman_node *new_node;
+
+	if (!tree) {
+		EMGD_ERROR("Bad tree pointer.");
+		return 1;
+	}
+
+	/* Step 1: Count the number of codes for each code length */
+	clc_count = (unsigned long *)vmalloc(
+		sizeof(unsigned long) * (max_bits+1));
+    if (!clc_count) {
+		EMGD_ERROR("Out of memory.");
+		return 1;
+    }
+    OS_MEMSET(clc_count, 0, sizeof(unsigned long) * (max_bits+1));
+
+	for (k=0; k<num_codes; k++){
+		clc_count[code_lengths[k]]++;
+	}
+
+	/* Step 2: Get numerical value of smallest code for each code length */
+	clc_next_code = (unsigned long *)vmalloc(
+		sizeof(unsigned long) * (max_bits+1));
+    if (!clc_next_code) {
+		EMGD_ERROR("Out of memory.");
+		return 1;
+    }
+    OS_MEMSET(clc_next_code, 0, sizeof(unsigned long) * (max_bits+1));
+
+	clc_code = 0;
+	clc_next_code[0] = 2;
+	for (k=1; k<=max_bits; k++){
+	    clc_code = (clc_code + clc_count[k-1]) << 1;
+	    clc_next_code[k] = clc_code;
+	}
+
+	/* Step 3: Assign numerical values to all codes */
+	codes = (unsigned long *)vmalloc(sizeof(unsigned long) * num_codes);
+    if (!codes) {
+		EMGD_ERROR("Out of memory.");
+		return 1;
+    }
+    OS_MEMSET(codes, 0, sizeof(unsigned long) * num_codes);
+
+	for (k=0; k<num_codes; k++){
+	    if (code_lengths[k] > 0){
+			codes[k] = clc_next_code[code_lengths[k]]++;
+
+			/* Add this node to the code length tree */
+			new_node = (huffman_node *)kzalloc(sizeof(huffman_node),GFP_KERNEL);
+			if (!new_node) {
+				EMGD_ERROR("Out of memory.");
+				return 1;
+			}
+
+			new_node->extra_bits = (unsigned char)extra_bits[k];
+			new_node->value = values[k];
+			new_node->real = real_values[k];
+			cur_node = *tree;
+			add_node(&cur_node, new_node, codes[k], code_lengths[k]);
+	    }
+	}
+
+	vfree(clc_count);
+	vfree(clc_next_code);
+	vfree(codes);
+	return 0;
+}
+
+
+/*
+ * This function recursively frees a huffman node and all its sub nodes.
+ * First we free any sub nodes, then we free itself.
+ *
+ * @param node (IN) The huffman node to free.
+ */
+void free_node(huffman_node *node) {
+	if (node->leaf[0]) {
+		free_node((huffman_node *)(node->leaf[0]));
+	}
+	if (node->leaf[1]) {
+		free_node((huffman_node *)(node->leaf[1]));
+	}
+	kfree(node);
+}
+
+
+/*
+ * This function gets a huffman code by traversing through a bit
+ * stream as if those are directions for traversling through
+ * a binary tree.   When we hit a leaf node, we have our value.
+ *
+ * @param stream (IN) This is the input data stream from which we are reading.
+ * @param iter (IN/OUT) This is the input data stream's char iterator
+ * @param bit_iter (IN/OUT) This is the bit iterator for the particular char we
+ *                          are reading.
+ * @param tree (IN) This is the huffman tree.
+ * @param final_node (OUT) The final leaf node we have reached.
+ */
+void get_huffman_code(
+	unsigned char *stream,
+	unsigned long *iter,
+	unsigned char *bit_iter,
+	huffman_node **tree,
+	huffman_node **final_node){
+
+	*final_node = *tree;
+	while ((*final_node)->leaf[0] || (*final_node)->leaf[1]) {
+		(*final_node) = (huffman_node *)(*final_node)->
+			leaf[((stream[*iter] >> *bit_iter) & 1)];
+
+		if (++(*bit_iter) == 8) {
+			(*iter)++;
+			(*bit_iter) = 0;
+		}
+	}
+}
+
+
+/*
+ * This function adds a node into a tree.
+ *
+ * @param tree (IN/OUT) This is the tree's root to which we'll be adding a
+ *                      node.
+ * @param node (IN) This is the node we'll be adding.
+ * @param code (IN) This is the code which will be used as a map to determine
+ *                  where the new node goes on the tree.
+ * @param code_length (IN) This is the code length for the code passed in.
+ *
+ * @return 0 on Success
+ * @return >0 on Error
+ */
+int add_node(
+	huffman_node **tree,
+	huffman_node *node,
+	unsigned long code,
+	unsigned long code_length){
+
+	huffman_node *new_node;
+
+	if (!(*tree)) {
+		EMGD_ERROR("Invalid tree pointer.");
+		return 1;
+	}
+
+	if (code_length > 1){
+
+		/* Build a leaf node if it doesn't exist */
+		if (!(*tree)->leaf[(code >> (code_length-1)) & 1]){
+			new_node = (huffman_node *)kzalloc(sizeof(huffman_node),GFP_KERNEL);
+			if (!new_node) {
+				EMGD_ERROR("Out of memory");
+				return 1;
+			}
+
+			(*tree)->leaf[(code >> (code_length-1)) & 1] =
+				(struct huffman_node *)new_node;
+			(*tree) = new_node;
+		} else {
+			(*tree) =
+				(huffman_node *)(*tree)->leaf[(code >> (code_length-1)) & 1];
+		}
+
+		/* Recursively add the tree node */
+		add_node(&(*tree), node, code, --code_length);
+
+	} else {
+		/* This is where our leaf node belongs */
+		(*tree)->leaf[code & 1] = (struct huffman_node *)node;
+	}
+	return 0;
+}
+
+
+/*
+ * This function reads a 4 byte value from a given stream.
+ * This assumes the passed in stream is byte aligned.
+ *
+ * @param stream (IN) The stream from which we are reading.
+ * @param iter (IN/OUT) The stream iterator.
+ * @param value (OUT) The value read from the stream.
+ *
+ * @return 0 on Success
+ * @return >0 on Error
+ */
+int read_int_from_stream(
+	unsigned char *stream,
+	unsigned long *iter,
+	unsigned long *value){
+
+	*value = stream[*iter] << 24 |
+		stream[(*iter)+1] << 16 |
+		stream[(*iter)+2] << 8 |
+		stream[(*iter)+3];
+	*iter += 4;
+	return 0;
+}
+
+
+/*
+ * This function reads a 2 byte value from a given stream.
+ * This assumes the passed in stream is byte aligned.
+ *
+ * @param stream (IN) The stream from which we are reading.
+ * @param iter (IN/OUT) The stream iterator.
+ * @param value (OUT) The value read from the stream.
+ *
+ * @return 0 on Success
+ * @return >0 on Error
+ */
+int read_short_from_stream(
+	unsigned char *stream,
+	unsigned long *iter,
+	unsigned short *value){
+
+	*value = stream[(*iter)] << 8 |
+		stream[(*iter)+1];
+	*iter += 2;
+	return 0;
+}
+
+
+/*
+ * This function reads a 1 byte value from a given stream.
+ * This assumes the passed in stream is byte aligned.
+ *
+ * @param stream (IN) The stream from which we are reading.
+ * @param iter (IN/OUT) The stream iterator.
+ * @param value (OUT) The value read from the stream.
+ *
+ * @return 0 on Success
+ * @return >0 on Error
+ */
+int read_char_from_stream(
+	unsigned char *stream,
+	unsigned long *iter,
+	unsigned char *value){
+
+	*value = stream[*iter];
+	(*iter)++;
+
+	return 0;
+}
+
+
+/*
+ * This function reads a given number of bits from a given stream.
+ * This does not assume the passed in stream is byte aligned.
+ *
+ * @param stream (IN) The stream from which we are reading.
+ * @param iter (IN/OUT) The stream iterator.
+ * @param bit_iter (IN/OUT) The stream's bit iterator.
+ * @param num_bits (IN) The number of bits to read.
+ * @param value (OUT) The value read from the stream.
+ *
+ * @return 0 on Success
+ * @return >0 on Error
+ */
+int read_bits_from_stream(
+	unsigned char *stream,
+	unsigned long *iter,
+	unsigned char *bit_iter,
+	unsigned long num_bits,
+	unsigned long *value){
+
+	unsigned long i;
+	*value = 0;
+
+	for (i=0; i<num_bits; i++){
+		*value += read_bit_from_stream(stream, iter, bit_iter) << i;
+	}
+
+	return 0;
+}
+
+
+/*
+ * This function reads a single bit from a given stream.
+ * This does not assume the passed in stream is byte aligned.
+ *
+ * @param stream (IN) The stream from which we are reading.
+ * @param iter (IN/OUT) The stream iterator.
+ * @param bit_iter (IN/OUT) The stream's bit iterator.
+ *
+ * @return The bit value read.
+ */
+unsigned int read_bit_from_stream(
+	unsigned char *stream,
+	unsigned long *iter,
+	unsigned char *bit_iter){
+
+	unsigned int result = 0;
+
+	/* get our bit */
+	result = (stream[*iter] >> *bit_iter) & 1;
+
+	/* This is faster than above */
+	if (++(*bit_iter) == 8) {
+		(*iter)++;
+		(*bit_iter) = 0;
+	}
+
+	return result;
 }
diff --git a/drivers/gpu/drm/emgd/emgd/drm/splash_screen.h b/drivers/gpu/drm/emgd/emgd/drm/splash_screen.h
index a83c84f..5fac725 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/splash_screen.h
+++ b/drivers/gpu/drm/emgd/emgd/drm/splash_screen.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: splash_screen.h
- * $Revision: 1.4 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -36,8 +36,99 @@
 
 #include <user_config.h>
 
-#define CONV_16_TO_32_BIT(a) (((a & 0xF800)<<8) | ((a & 0x7E0)<<5) |\
-						(a & 0x1F)<<3)
+#define CONV_16_TO_32_BIT(a) (0xFF000000 | ((a & 0xF800)<<8) |\
+						((a & 0x7E0)<<5) | (a & 0x1F)<<3)
+#define CONV_GS_4_TO_32(a) (0xFF000000 | ((a)<<20) | ((a)<<16) |\
+						((a)<<12) | ((a)<<8) | ((a)<<4) | ((a)))
+
+#define CONV_GS_2_TO_32(a) (0xFF000000 | ((a)<<22) | ((a)<<20) | ((a)<<18) |\
+						((a)<<16) | ((a)<<14) | ((a)<<12) | ((a)<<10) |\
+						((a)<<8) | ((a)<<6) | ((a)<<4) | ((a)<<2) | ((a)))
+
+#define CONV_GS_1_TO_32(a) (0xFF000000 | ((a)<<23) | ((a)<<22) | ((a)<<21) |\
+						((a)<<20) | ((a)<<19) | ((a)<<18) | ((a)<<17) |\
+						((a)<<16) |	((a)<<15) | ((a)<<14) | ((a)<<13) |\
+						((a)<<12) |	((a)<<11) | ((a)<<10) | ((a)<<9) |\
+						((a)<<8) | ((a)<<7) | ((a)<<6) | ((a)<<5) | ((a)<<4) |\
+						((a)<<3) | ((a)<<2) | ((a)<<1) | ((a)))
+
+/* Colour_type options */
+#define COLOR_GREY       0
+#define COLOR_TRUE       2
+#define COLOR_INDEXED    3
+#define COLOR_GREY_ALPHA 4
+#define COLOR_TRUE_ALPHA 6
+
+#define CONV_GS_4_TO_32(a) (0xFF000000 | ((a)<<20) | ((a)<<16) | ((a)<<12) |\
+						((a)<<8) | ((a)<<4) | ((a)))
+
+#define CONV_GS_2_TO_32(a) (0xFF000000 | ((a)<<22) | ((a)<<20) | ((a)<<18) |\
+						((a)<<16) | ((a)<<14) | ((a)<<12) | ((a)<<10) |\
+						((a)<<8) | ((a)<<6) | ((a)<<4) | ((a)<<2) | ((a)))
+
+#define CONV_GS_1_TO_32(a) (0xFF000000 | ((a)<<23) | ((a)<<22) | ((a)<<21) |\
+						((a)<<20) |	((a)<<19) | ((a)<<18) | ((a)<<17) |\
+						((a)<<16) |	((a)<<15) | ((a)<<14) | ((a)<<13) |\
+						((a)<<12) |	((a)<<11) | ((a)<<10) | ((a)<<9) |\
+						((a)<<8) | ((a)<<7) | ((a)<<6) | ((a)<<5) | ((a)<<4) |\
+						((a)<<3) | ((a)<<2) | ((a)<<1) | ((a)))
+
+#define PNG_HEADER_SIZE                   8
+#define PNG_CRC_SIZE                      4
+#define CLC_MAX_BITS                      7
+#define CLC_NUM_CODES                    19
+#define LEN_MAX_BITS                     15
+#define LEN_NUM_CODES                   288
+#define DIST_MAX_BITS                    15
+#define DIST_NUM_CODES                   32
+#define LEN_NUM_DISTINCT_EXTRA_BITS       7
+#define DIST_NUM_DISTINCT_EXTRA_BITS     14
+#define LEN_START_REAL_VALUES           257
+#define DIST_START_REAL_VALUES            1
+#define DISPLAY_START                  8365
+#define DISPLAY_MAX                    8372
+#define DISPLAY_MAX2                   8372
+
+/* Chunk types */
+#define CHUNK_IHDR 0x49484452
+#define CHUNK_SRGB 0x73524742
+#define CHUNK_PHYS 0x70485973
+#define CHUNK_TIME 0x74494D45
+#define CHUNK_BKGD 0x624B4744
+#define CHUNK_TRNS 0x74524E53
+#define CHUNK_CHRM 0x6348524D
+#define CHUNK_GAMA 0x67414D41
+#define CHUNK_ICCP 0x69434350
+#define CHUNK_SBIT 0x73424954
+#define CHUNK_TEXT 0x74455874
+#define CHUNK_ZTXT 0x7A545874
+#define CHUNK_ITXT 0x69545874
+#define CHUNK_HIST 0x68495354
+#define CHUNK_SPLT 0x73504C54
+#define CHUNK_PLTE 0x504C5445
+#define CHUNK_IDAT 0x49444154
+#define CHUNK_IEND 0x49454E44
+
+/* APNG Chunks */
+#define CHUNK_ACTL 0x6163544C
+#define CHUNK_FCTL 0x6663544C
+#define CHUNK_FDAT 0x66644154
+
+/* Colour_type options */
+#define COLOR_GREY       0
+#define COLOR_TRUE       2
+#define COLOR_INDEXED    3
+#define COLOR_GREY_ALPHA 4
+#define COLOR_TRUE_ALPHA 6
+
+/* APNG dispose_op codes */
+#define APNG_DISPOSE_OP_NONE       0
+#define APNG_DISPOSE_OP_BACKGROUND 1
+#define APNG_DISPOSE_OP_PREVIOUS   2
+
+/* APNG blend_op codes */
+#define APNG_BLEND_OP_SOURCE 0
+#define APNG_BLEND_OP_OVER   1
 
 typedef struct _bitmap_header {
 	/* What is the widht and height of the bitmap */
@@ -51,9 +142,139 @@ typedef struct _bitmap_header {
 	short y_coord;
 } bitmap_header;
 
+typedef struct _png_header {
+	unsigned long width;
+	unsigned long height;
+	unsigned long x_offset;
+	unsigned long y_offset;
+	unsigned char bit_depth;
+	unsigned char colour_type;
+	unsigned char compression_method;
+	unsigned char filter_method;
+	unsigned char interlace_method;
+	unsigned long bpp;
+	unsigned long bytes_pp;
+	unsigned long bytes_pl;
+	unsigned long background;
+	unsigned char background_r;
+	unsigned char background_g;
+	unsigned char background_b;
+	unsigned long *image_palette;
+	unsigned long using_transparency;
+	unsigned short transparency_r;
+	unsigned short transparency_g;
+	unsigned short transparency_b;
+} png_header;
+
+typedef struct _png_frame {
+	unsigned long *output;
+	unsigned long size;
+	unsigned long width;
+	unsigned long height;
+	unsigned long x_offset;
+	unsigned long y_offset;
+	unsigned long bytes_pp;
+	unsigned long bytes_pl;
+	unsigned long delay;
+	unsigned char dispose_op;
+	unsigned char blend_op;
+} png_frame;
+
+typedef struct _huffman_node {
+	unsigned long value;
+	unsigned long real;
+	unsigned char extra_bits;
+	struct huffman_node *leaf[2];
+} huffman_node;
+
+void display_png_frame(
+	igd_framebuffer_info_t *fb_info,
+	unsigned char *fb,
+	png_header image_header,
+	png_frame *frame,
+	unsigned long prev_dispose_op);
+void decode_png_data(
+	png_header *image_header,
+	unsigned char *input_data,
+	png_frame *frame);
+int create_tree(
+    unsigned long max_bits,
+    unsigned long num_codes,
+    unsigned long *code_lengths,
+    unsigned long *extra_bits,
+    unsigned long *values,
+    unsigned long *real_values,
+    huffman_node **tree);
+void free_node(huffman_node *node);
 void display_splash_screen(
 	igd_framebuffer_info_t *fb_info,
 	unsigned char *fb,
 	emgd_drm_splash_screen_t *ss_data);
+void display_bmp_splash_screen(
+	igd_framebuffer_info_t *fb_info,
+	unsigned char *fb,
+	emgd_drm_splash_screen_t *ss_data);
+void display_png_splash_screen(
+	igd_framebuffer_info_t *fb_info,
+	unsigned char *fb,
+	emgd_drm_splash_screen_t *ss_data);
+void decompress_huffman(
+    unsigned char *stream,
+    unsigned long *iter,
+    unsigned char *bit_iter,
+    huffman_node **length_tree,
+    huffman_node **distance_tree,
+	unsigned char *output,
+	unsigned long *output_iter);
+void build_static_huffman_tree(
+    huffman_node **length_tree,
+    huffman_node **distance_tree);
+void build_dynamic_huffman_tree(
+    unsigned char *stream,
+    unsigned long *iter,
+    unsigned char *bit_iter,
+    huffman_node **length_tree,
+    huffman_node **distance_tree);
+void get_code_lengths(
+    unsigned char *stream,
+    unsigned long *iter,
+    unsigned char *bit_iter,
+    huffman_node **code_length_tree,
+    unsigned long num_lengths,
+    unsigned long *dynamic_lengths);
+void get_huffman_code(
+    unsigned char *stream,
+    unsigned long *iter,
+    unsigned char *bit_iter,
+    huffman_node **tree,
+    huffman_node **final_node);
+int add_node(
+    huffman_node **tree,
+    huffman_node *node,
+    unsigned long code,
+    unsigned long code_length);
+int read_int_from_stream(
+	unsigned char *stream,
+	unsigned long *iter,
+	unsigned long *value);
+int read_short_from_stream(
+	unsigned char *stream,
+	unsigned long *iter,
+	unsigned short *value);
+int read_char_from_stream(
+	unsigned char *stream,
+	unsigned long *iter,
+	unsigned char *value);
+int read_bits_from_stream(
+    unsigned char *stream,
+    unsigned long *iter,
+    unsigned char *bit_iter,
+    unsigned long num_bits,
+    unsigned long *value);
+unsigned int read_bit_from_stream(
+    unsigned char *stream,
+    unsigned long *iter,
+    unsigned char *bit_iter);
 
 #endif
+
diff --git a/drivers/gpu/drm/emgd/emgd/drm/user_config.c b/drivers/gpu/drm/emgd/emgd/drm/user_config.c
index e62c130..d64d932 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/user_config.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/user_config.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: user_config.c
- * $Revision: 1.19 $
+ * $Revision: 1.23 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -33,23 +33,13 @@
  */
 #include "user_config.h"
 
-
-/*
- * One array of attribute pairs may exist for each configured port.  See the
- * "include/igd_pd.h" file for attributes.
- */
-static igd_param_attr_t attrs_config1_port2[] = {
-	{PD_ATTR_ID_TVFORMAT, PD_TV_STD_NTSC_M}
-};
-
-static igd_param_attr_t attrs_config1_port4[] = {
-	{0x46, 100},	/* PWM Intensity */
-	{0x47, 20300},	/* Inverter Frequency */
-	{0x1b, 0},		/* Boolean - channel type dual/single channel*/
-	{0x1a, 18},		/* Panel depth 24/18 */
-	{0x3c, 1},		/* Fixed timing */
-};
-
+#warning ****
+#warning **** This driver has NOT been configured your your system.  You are
+#warning **** building with a sample user_config.c configuration that may or
+#warning **** may not meet your needs.  It is recommended that you run CED to
+#warning **** generate an appropriate configuration or see the User Guide
+#warning **** for more information about driver configuration.
+#warning ****
 
 
 /*
@@ -58,80 +48,76 @@ static igd_param_attr_t attrs_config1_port4[] = {
  * information for a given resolution/refresh-rate.  This is especially needed
  * for analog/VGA ports.
  */
+
+#define TUNNELCREEK 1
+#define POULSBO 0
+
+#if TUNNELCREEK
 static igd_display_info_t dtd_config1_port4_dtdlist[] = {
 	{
-		1024,		/* Width */
-		768,		/* Height */
-		60,			/* Refresh Rate */
-		65000,		/* Dot Clock (in KHz) */
-		1343,		/* Horizontal Total (horizontal synch end) */
-		1023,		/* Horizontal Blank Start (h_active-1) */
-		1343,		/* Horizontal Blank End (start + h_blank) */
-		1047,		/* Horizontal Sync Start (h_active+h_synch-1) */
-		1183,		/* Horizontal Sync End (start + h_syncp) */
-		805,		/* Vertical Total (Vertical synch end) */
-		767,		/* Vertical Blank Start (v_active-1) */
-		805,		/* Vertical Blank End (start + v_blank) */
-		770,		/* Vertical Sync Start (v_active+v_synch-1) */
-		776,		/* Vertical Sync End (start + v_synchp) */
-		0,			/* Mode Number */
-		0x20000,	/* Flags */
-		0,			/* X Offset */
-		0,			/* Y Offset */
-		NULL,		/* pd extension pointer */
-		0,0		/* mode extension pointer */
+		1366,   /* Width */
+		768,    /* Height */
+		60,     /* Refresh Rate */
+		72300,  /* Dot Clock */
+		1525,   /* Horizontal Total (horizontal synch end) */
+		1365,   /* Horizontal Blank Start (h_active-1) */
+		1525,   /* Horizontal Blank End (start + h_blank) */
+		1413,   /* Horizontal Sync Start (h_active+h_synch-1) */
+		1445,   /* Horizontal Sync End (start + h_syncp) */
+		789,    /* Vertical Total (Vertical synch end) */
+		767,    /* Vertical Blank Start (v_active-1) */
+		789,    /* Vertical Blank End (start + v_blank) */
+		770,    /* Vertical Sync Start (v_active+v_synch-1) */
+		775,    /* Vertical Sync End (start + v_synchp) */
+		0,  /* Mode Number */
+		0x20000,    /* Flags */
+		0,  /* X Offset */
+		0,  /* Y Offset */
+		NULL,   /* pd extension pointer */
+		0, 0   /* mode extension pointer */
 	},
+};
+#endif
 
-#if 0
-	{
-		1366,		/* Width */
-		768,		/* Height */
-		60,			/* Refresh Rate */
-		72300,		/* Dot Clock (in KHz) */
-		1525,		/* Horizontal Total (horizontal synch end) */
-		1365,		/* Horizontal Blank Start (h_active-1) */
-		1525,		/* Horizontal Blank End (start + h_blank) */
-		1413,		/* Horizontal Sync Start (h_active+h_synch-1) */
-		1445,		/* Horizontal Sync End (start + h_syncp) */
-		789,		/* Vertical Total (Vertical synch end) */
-		767,		/* Vertical Blank Start (v_active-1) */
-		789,		/* Vertical Blank End (start + v_blank) */
-		770,		/* Vertical Sync Start (v_active+v_synch-1) */
-		775,		/* Vertical Sync End (start + v_synchp) */
-		0,			/* Mode Number */
-		0x20000,	/* Flags */
-		0,			/* X Offset */
-		0,			/* Y Offset */
-		NULL,		/* pd extension pointer */
-		0,0		/* mode extension pointer */
-	},
+#if POULSBO
+static igd_display_info_t dtd_config1_port4_dtdlist[] = {
 	{
-		1280,		/* Width */
-		800,		/* Height */
-		60,			/* Refresh Rate */
-		68940,		/* Dot Clock (in KHz) */
-		1407,		/* Horizontal Total (horizontal synch end) */
-		1279,		/* Horizontal Blank Start (h_active-1) */
-		1407,		/* Horizontal Blank End (start + h_blank) */
-		1295,		/* Horizontal Sync Start (h_active+h_synch-1) */
-		1343,		/* Horizontal Sync End (start + h_syncp) */
-		815,		/* Vertical Total (Vertical synch end) */
-		799,		/* Vertical Blank Start (v_active-1) */
-		815,		/* Vertical Blank End (start + v_blank) */
-		800,		/* Vertical Sync Start (v_active+v_synch-1) */
-		803,		/* Vertical Sync End (start + v_synchp) */
-		0,			/* Mode Number */
-		0x20000,	/* Flags */
-		0,			/* X Offset */
-		0,			/* Y Offset */
-		NULL,		/* pd extension pointer */
-		NULL,		/* mode extension pointer */
+		1024,			/* Width */
+		768,				/* Height */
+		60,				/* Refresh Rate */
+		65000,			/* Dot Clock (in KHz) */
+		1343,			/* Horizontal Total (horizontal synch end) */
+		1023,			/* Horizontal Blank Start (h_active-1) */
+		1343,			/* Horizontal Blank End (start + h_blank) */
+		1047,			/* Horizontal Sync Start (h_active+h_synch-1) */
+		1183,			/* Horizontal Sync End (start + h_syncp) */
+		805,				/* Vertical Total (Vertical synch end) */
+		767,				/* Vertical Blank Start (v_active-1) */
+		805,				/* Vertical Blank End (start + v_blank) */
+		770,				/* Vertical Sync Start (v_active+v_synch-1) */
+		776,				/* Vertical Sync End (start + v_synchp) */
+		0,				/* Mode Number */
+		0x20000,			/* Flags */
+		0,				/* X Offset */
+		0,				/* Y Offset */
+		NULL,			/* pd extension pointer */
+		0, 0				/* mode extension pointer */
 	},
+};
+#endif
+
+static igd_param_attr_t attrs_config1_port4[] = {
+	{0x46, 100},
+#if POULSBO
+	{0x1a, 24},
+#endif
+#if TUNNELCREEK
+	{0x47, 20300},
 #endif
 };
 
 static emgd_drm_splash_screen_t splash_screen_data = {
-	0,			/* bg_color */
+	0x000000,		/* bg_color */
 	0,			/* x */
 	0,			/* y */
 	0,			/* width */
@@ -150,142 +136,83 @@ static emgd_drm_splash_video_t splash_video_data = {
 	0,			/* dst_height */
 };
 
-/*
- * The igd_param_t structure contains many configuration values used by the
- * EMGD kernel module.
- */
-igd_param_t config_params_config1 = {
-	1*256*1024,	/* Page request */
-	0,			/* Max frame buffer size (0 = no limit) */
-	1,			/* Preserve registers (should be 1, so VT switches work and so
-				 * that the console will be restored after X server exits).
-				 */
-	0x6,		/* Display flags (bitfield, where:
-				 * - 0x2 = DISPLAY_MULTI_DVO
-				 * - 0x4 = Detect the display(s)
-				 * - 0x8 = DISPLAY_FB_BLEND_OVL
-				 */
-	{ 4, 2, 0, 0, 0 },	/* Display port order (corresponds to the "portorder"
-						 * module parameter, which is a comma-separate list)
-						 */
-	{			/* Display Params: */
-	{				/* Port: */
-		4,				/* Display port number (0 if not configured) */
-		0x180,			/* Parameters present (bitfield, where:
-						 * - 0x001 = DDC GPIO
-						 * - 0x002 = DDC SPEED
-						 * - 0x004 = DDC DAB
-						 * - 0x008 = I2C GPIO
-						 * - 0x010 = I2C SPEED
-						 * - 0x020 = DAB
-						 * - 0x040 = FP INFO
-						 * - 0x080 = DTD LIST
-						 * - 0x100 = ATTR LIST
-						 */
-		0x1,			/* EDID flag */
-		0x3,			/* Flags when EDID is available (bitfield, where:
-						 * - 0x1 = Use built-in standard timings
-						 * - 0x2 = Use EDID block and filter modes
-						 * - 0x4 = Use user-provided DTDs
-						 */
-		0x5,			/* Flags when EDID is not available (bitfield, where:
-						 * - 0x1 = Use built-in standard timings
-						 * - 0x2 = Use EDID block and filter modes
-						 * - 0x4 = Use user-provided DTDs
-						 */
-		0,				/* DDC GPIO pins */
-		0,				/* DDC speed */
-		0,				/* DDC DAB */
-		0,				/* I2C GPIO pins */
-		0,				/* I2C speed */
-		0,				/* I2C DAB */
-		{				/* Flat Panel Info: */
-			0,				/* Flat Panel width */
-			0,				/* Flat Panel height */
-			0,				/* Flat Panel power method */
-			0,				/* VDD active & DVO clock/data active */
-			0,				/* DVO clock/data active & backlight enable */
-			0,				/* backlight disable & DVO clock/data inactive */
-			0,				/* DVO clock/data inactive & VDD inactive */
-			0				/* VDD inactive & VDD active */
-		},
-		{				/* DTD Info */
-			sizeof(dtd_config1_port4_dtdlist)/sizeof(igd_display_info_t),
-			/* number */
-			dtd_config1_port4_dtdlist/* DTD name */
-		},
-		{				/* Attribute Info */
-			sizeof(attrs_config1_port4)/sizeof(igd_param_attr_t), /* number */
-			attrs_config1_port4	/* Attr name */
-		}
-	},
-	{				/* Port: */
-		2,				/* Display port number (0 if not configured) */
-		0x140,			/* Parameters present (see above) */
-		0x1,			/* EDID flag */
-		0x3,			/* Flags when EDID is available (see above) */
-		0x1,			/* Flags when EDID is not available (see above) */
-		0,				/* DDC GPIO pins */
-		0,				/* DDC speed */
-		0,				/* DDC DAB */
-		0,				/* I2C GPIO pins */
-		0,				/* I2C speed */
-		0,				/* I2C DAB */
-		{				/* Flat Panel Info: */
-			0,				/* Flat Panel width */
-			0,				/* Flat Panel height */
-			1,				/* Flat Panel power method */
-			60,				/* VDD active & DVO clock/data active */
-			200,			/* DVO clock/data active & backlight enable */
-			200,			/* backlight disable & DVO clock/data inactive */
-			50,				/* DVO clock/data inactive & VDD inactive */
-			400				/* VDD inactive & VDD active */
+static igd_param_t config_params_config1 = {
+	1*256*1024,		/* Page request */
+	0,		/* Max frame buffer size */
+	1,		/* Preserve registers */
+	0x6,		/* Display flags */
+	{ 4, 2, 0, 0, 0 },		/* Display port order */
+	{		/* Display Params */
+		{		/* Port */
+			4,		/* Display port number */
+			0x180,		/* Parameters present */
+			0x0,		/* EDID flag */
+			0x5,		/* Flags when EDID is available */
+			0x5,		/* Flags when EDID is not available */
+			0,		/* DDC GPIO pins */
+			0,		/* DDC speed */
+			0,		/* DDC DAB */
+			0,		/* I2C GPIO pins */
+			0,		/* I2C speed */
+			0,		/* I2C DAB */
+			{		/* Flat Panel Info */
+				0,		/* Flat Panel width */
+				0,		/* Flat Panel height */
+				0,		/* Flat Panel power method */
+				0,		/* VDD active & DVO clock/data active */
+				0,		/* DVO clock/data active & backlight enable */
+				0,		/* backlight disable & DVO clock/data inactive */
+				0,		/* DVO clock/data inactive & VDD inactive */
+				0			/* VDD inactive & VDD active */
+			},
+			{		/* DTD Info */
+				sizeof(dtd_config1_port4_dtdlist)/sizeof(igd_display_info_t),		/* Number of DTDs */
+				dtd_config1_port4_dtdlist		/* DTD name */
+			},
+			{		/* Attribute Info */
+				sizeof(attrs_config1_port4)/sizeof(igd_param_attr_t),		/* Number of attributes */
+				attrs_config1_port4		/* Attr name */
+			}
 		},
-		{				/* DTD Info */
-			0,				/* number */
-			NULL,			/* DTD name */
+		{		/* Port */
+			2,		/* Display port number */
+			0x0,		/* Parameters present */
+			0x0,		/* EDID flag */
+			0x5,		/* Flags when EDID is available */
+			0x5,		/* Flags when EDID is not available */
+			0,		/* DDC GPIO pins */
+			0,		/* DDC speed */
+			0,		/* DDC DAB */
+			0,		/* I2C GPIO pins */
+			0,		/* I2C speed */
+			0,		/* I2C DAB */
+			{		/* Flat Panel Info */
+				0,		/* Flat Panel width */
+				0,		/* Flat Panel height */
+				0,		/* Flat Panel power method */
+				0,		/* VDD active & DVO clock/data active */
+				0,		/* DVO clock/data active & backlight enable */
+				0,		/* backlight disable & DVO clock/data inactive */
+				0,		/* DVO clock/data inactive & VDD inactive */
+				0			/* VDD inactive & VDD active */
+			},
+			{		/* DTD Info */
+			0, NULL
+			},
+			{		/* Attribute Info */
+			0, NULL
+			}
 		},
-		{				/* Attribute Info */
-			sizeof(attrs_config1_port2)/sizeof(igd_param_attr_t), /* number */
-			attrs_config1_port2	/* Attr name */
-		}
-	},
-	{				/* Port: */
-		0,				/* Display port number (0 if not configured) */
-		0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0,
-		{ 0, 0, 0, 0, 0, 0, 0, 0 },
-		{ 0, NULL },
-		{ 0, NULL }
-	},
-	{				/* Port: */
-		0,				/* Display port number (0 if not configured) */
-		0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0,
-		{ 0, 0, 0, 0, 0, 0, 0, 0 },
-		{ 0, NULL },
-		{ 0, NULL }
-	},
-	{				/* Port: */
-		0,				/* Display port number (0 if not configured) */
-		0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0,
-		{ 0, 0, 0, 0, 0, 0, 0, 0 },
-		{ 0, NULL },
-		{ 0, NULL }
-	},
 	},
 	0,			/* 24-bit RGB color that framebuffer is cleared to */
-	0,			/* Quickboot (1 = enabled) */
+	1,			/* Quickboot (1 = enabled) */
 	0,			/* Quickboot seamless (1 = enabled) */
 	0,			/* Quickboot video input (1 = enabled) */
 	0			/* Polling (1 = override interrupt support and use polling) */
 };
 
-
 igd_param_t *config_params = {&config_params_config1};
 
-
 /*
  * The emgd_drm_config_t structure is the main configuration structure
  * for the EMGD kernel module.
@@ -302,7 +229,7 @@ emgd_drm_config_t config_drm = {
 		 *       Note: Twin is NOT CURRENTLY SUPPORTED
 		 * - 8 = Extended displays (e.g. LVDS + CRT displaying different images)
 		 */
-	1024,/* Display width to use if initializing the display
+	1366,/* Display width to use if initializing the display
 		 * (corresponds to the "width" module parameter)
 		 */
 	768,/* Display height to use if initializing the display
@@ -311,6 +238,7 @@ emgd_drm_config_t config_drm = {
 	60,	/* Display refresh rate to use if initializing the display
 		 * (corresponds to the "refresh" module parameter)
 		 */
+	0,  /* KMS */
 	0,	/* ovl_brightness */
 	0,	/* ovl_contrast */
 	0,	/* ovl_saturation */
@@ -321,3 +249,4 @@ emgd_drm_config_t config_drm = {
 	&splash_video_data,
 	&config_params	/* driver parameters from above */
 };
+
diff --git a/drivers/gpu/drm/emgd/emgd/drm/user_config.h b/drivers/gpu/drm/emgd/emgd/drm/user_config.h
index 9d45720..5aca4d8 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/user_config.h
+++ b/drivers/gpu/drm/emgd/emgd/drm/user_config.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: user_config.h
- * $Revision: 1.7 $
+ * $Revision: 1.8 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -86,6 +86,8 @@ typedef struct _emgd_drm_config {
 	int height;
 	/** The refresh rate to use if initializing the display. */
 	int refresh;
+	/** Enable Kernel Mode Set */
+	int kms;
 	/** Overlay Brightness */
 	unsigned long ovl_brightness;
 	/** Overlay Contrast */
diff --git a/drivers/gpu/drm/emgd/emgd/gmm/gmm.c b/drivers/gpu/drm/emgd/emgd/gmm/gmm.c
index ce65ba1..0b406e9 100644
--- a/drivers/gpu/drm/emgd/emgd/gmm/gmm.c
+++ b/drivers/gpu/drm/emgd/emgd/gmm/gmm.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: gmm.c
- * $Revision: 1.47 $
+ * $Revision: 1.48 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -62,6 +62,10 @@ static int gmm_alloc_chunk_space(gmm_context_t *gmm_context,
 		unsigned long phys,
 		unsigned long flags);
 
+static int gmm_import_pages(void **pagelist,
+		unsigned long *gtt_offset,
+		unsigned long numpages);
+
 static int gmm_get_page_list(unsigned long offset,
 		unsigned long **pages,
 		unsigned long *page_cnt);
@@ -84,10 +88,80 @@ static void gmm_free(unsigned long offset)
 	chunk = gmm_context.head_chunk;
 	while (chunk) {
 		if (chunk->offset == offset) {
-			if (chunk->used == 0) {
+			switch (chunk->usage) {
+			case FREE_ALLOCATED:
 				EMGD_DEBUG("WARNING: The chunk 0x%lx is already freed", offset);
-			} else {
+				break;
+			case INUSE_IMPORTED:
+			case FREE_IMPORTED:
+				EMGD_DEBUG("WARNING: The chunk 0x%lx was allocated externally", offset);
+				return;
+			case INUSE_ALLOCATED:
 				EMGD_DEBUG("Freeing the chunk 0x%lx", offset);
+				break;
+			default:
+				EMGD_DEBUG("Unknown usage %d for chunk 0x%lx.  Memory manager corrupt?",
+					chunk->usage, offset);
+				break;
+			}
+
+			/*
+			 * What to do if the ref count is > 0?  Unmapping is
+			 * probably the right thing since nothing should try
+			 * to use this. If something does, it should probably
+			 * fail.
+			 */
+			if (chunk->ref_cnt > 0) {
+				EMGD_DEBUG("WARNING: The chunk 0x%lx is mapped", offset);
+				/*
+				 * chunk->ref_cnt = 0;
+				 * vunmap(chunk->addr);
+				 */
+				chunk->addr = NULL;
+			}
+			/* Free the array of page address, if applicable: */
+			if (chunk->page_addresses != NULL) {
+				EMGD_DEBUG("About to free chunk->page_addresses = 0x%p",
+					chunk->page_addresses);
+				OS_FREE(chunk->page_addresses);
+				chunk->page_addresses = NULL;
+			}
+
+			chunk->usage = FREE_ALLOCATED;  /* mark as free */
+			return;
+		}
+		chunk = chunk->next;
+	}
+
+	EMGD_ERROR("gmm_free() did not find the chunk 0x%lx to free", offset);
+	return;
+}
+
+static void gmm_release_import(unsigned long offset)
+{
+	gmm_chunk_t *chunk;
+
+	EMGD_DEBUG("Enter gmm_release_import(0x%lx)", offset);
+
+	/* Walk the chunk list */
+	chunk = gmm_context.head_chunk;
+	while (chunk) {
+		if (chunk->offset == offset) {
+			switch (chunk->usage) {
+			case FREE_ALLOCATED:
+			case INUSE_ALLOCATED:
+				EMGD_DEBUG("WARNING: The chunk 0x%lx was not an imported chunk", offset);
+				break;
+			case INUSE_IMPORTED:
+				EMGD_DEBUG("Releasing the chunk 0x%lx", offset);
+				break;
+			case FREE_IMPORTED:
+				EMGD_DEBUG("WARNING: The chunk 0x%lx has already been released", offset);
+				return;
+			default:
+				EMGD_DEBUG("Unknown usage %d for chunk 0x%lx.  Memory manager corrupt?",
+					chunk->usage, offset);
+				break;
 			}
 
 			/*
@@ -110,7 +184,11 @@ static void gmm_free(unsigned long offset)
 				chunk->page_addresses = NULL;
 			}
 
-			chunk->used = 0;  /* mark as free */
+			/* Zero out the gmm_mem_buffer_t */
+			OS_MEMSET(chunk->gtt_mem, 0, sizeof(gmm_mem_buffer_t));
+
+			/* Mark address space as free */
+			chunk->usage = FREE_IMPORTED;
 			return;
 		}
 		chunk = chunk->next;
@@ -322,7 +400,6 @@ static void *gmm_map(unsigned long offset)
 	int i;
 	void *addr = NULL;
 	unsigned long num_pages;
-	unsigned long size;
 
 	EMGD_TRACE_ENTER;
 	EMGD_DEBUG("Parameter: offset=0x%lx", offset);
@@ -349,19 +426,7 @@ static void *gmm_map(unsigned long offset)
 	 * and convert that to a page list.
 	 */
 
-	size = PAGE_ALIGN(chunk->size);
-	num_pages = size / PAGE_SIZE;
-
-	if (num_pages != chunk->gtt_mem->page_count) {
-		printk(KERN_ERR"[EMGD] gmm_map: Num pages don't match %lu vs. %lu\n",
-				num_pages, (unsigned long)chunk->gtt_mem->page_count);
-		return NULL;
-	}
-
-	/*
-	 * chunk->memory is an agp_memory struct
-	 * This has an elements struct page **pages and page_count
-	 */
+	num_pages = chunk->gtt_mem->page_count;
 	page_map = vmalloc(num_pages * sizeof(struct page *));
 	if (page_map == NULL) {
 		printk(KERN_ERR"[EMGD] gmm_map: vmalloc failed.\n");
@@ -421,8 +486,10 @@ int gmm_init(igd_context_t *context,
 
 	context->dispatch.gmm_alloc_surface = gmm_alloc_surface;
 	context->dispatch.gmm_alloc_region = gmm_alloc_region;
+	context->dispatch.gmm_import_pages = gmm_import_pages;
 	context->dispatch.gmm_virt_to_phys = gmm_virt_to_phys;
 	context->dispatch.gmm_free = gmm_free;
+	context->dispatch.gmm_release_import = gmm_release_import;
 	context->dispatch.gmm_memstat = NULL;
 	context->dispatch.gmm_alloc_cached = NULL;
 	context->dispatch.gmm_free_cached = NULL;
@@ -471,7 +538,7 @@ void gmm_shutdown(igd_context_t *context)
 	chunk = gmm_context.head_chunk;
 	while (chunk) {
 		EMGD_DEBUG("process chunk at 0x%lx", chunk->offset);
-		if (chunk->used == 1) {
+		if (chunk->usage == INUSE_ALLOCATED || chunk->usage == INUSE_IMPORTED) {
 			EMGD_ERROR("Chunk at 0x%lx not properly freed", chunk->offset);
 		}
 
@@ -482,7 +549,10 @@ void gmm_shutdown(igd_context_t *context)
 		if (chunk->bound) {
 			emgd_gtt_remove(context, chunk->gtt_mem, chunk->offset);
 		}
-		emgd_free_pages(chunk->gtt_mem);
+
+		if (chunk->usage == INUSE_ALLOCATED) {
+			emgd_free_pages(chunk->gtt_mem);
+		}
 
 		/* Free the array of page address, if applicable: */
 		if (chunk->page_addresses != NULL) {
@@ -533,7 +603,6 @@ static int gmm_alloc_linear_surface(unsigned long *offset,
 	int ret;
 	unsigned long align;
 	unsigned long min_pitch;
-	unsigned long test = 1;
 
 	EMGD_TRACE_ENTER;
 	EMGD_DEBUG("Parameters: pixel_format=0x%08lx,", pixel_format);
@@ -556,11 +625,8 @@ static int gmm_alloc_linear_surface(unsigned long *offset,
 		min_pitch = *pitch;
 	}
 
-	/* Make sure pitch is power of two */
-	while (test < min_pitch) {
-		test <<= 1;
-	}
-	min_pitch = test;
+	/* Pitch for both PLB and TNC requires 64-byte alignment */
+	min_pitch = ALIGN(min_pitch, 64);
 
 	/*
 	 * Size should be based on pixel format and pitch, not just pitch.
@@ -623,9 +689,9 @@ static int gmm_alloc_chunk_space(gmm_context_t *gmm_context,
 	/* Check for a free chunk of sufficent size */
 	chunk = gmm_context->head_chunk;
 	while (chunk) {
-		if ((chunk->used == 0) && (chunk->size >= size) &&
+		if ((chunk->usage == FREE_ALLOCATED) && (chunk->size >= size) &&
 			(chunk->type == (phys ? AGP_PHYS_MEMORY : AGP_NORMAL_MEMORY))) {
-			chunk->used = 1;
+			chunk->usage = INUSE_ALLOCATED;
 			*offset = chunk->offset;
 			EMGD_DEBUG("Re-using old chunk with offset=0x%lx", chunk->offset);
 			EMGD_DEBUG("EXIT  Returning %d", 0);
@@ -679,7 +745,7 @@ static int gmm_alloc_chunk_space(gmm_context_t *gmm_context,
 	}
 
 
-	chunk->used = 1;
+	chunk->usage = INUSE_ALLOCATED;
 	chunk->ref_cnt = 0;
 	chunk->page_addresses = NULL;
 
@@ -763,6 +829,134 @@ static int gmm_alloc_chunk_space(gmm_context_t *gmm_context,
 }
 
 
+/*
+ * Imports a list of pages allocated by an external source (i.e., the PVR
+ * services) into the GMM and maps the pages into the GTT.  Note that
+ * this function is as dumb as gmm_alloc_chunk_space about reusing
+ * previous allocations that have been freed; it will happily use a large
+ * hole in the GTT for a tiny allocation if it's the first hole it finds.
+ *
+ * pagelist is a live page list; it should not be modified or freed by
+ *    the GMM.
+ * gtt_offset is an output only; this is the offset of the beginning of
+ *    the first page from the start of the GTT.  If the actual surface
+ *    data starts partway through a page, the caller may need to add an
+ *    addition offset to where the surface data starts.
+ */
+static int gmm_import_pages(void **pagelist,
+		unsigned long *gtt_offset,
+		unsigned long numpages)
+{
+	gmm_chunk_t *chunk;
+
+	EMGD_TRACE_ENTER;
+
+	EMGD_DEBUG("Importing %lu pages into GTT\n", numpages);
+
+	/*
+	 * Check for a free chunk of sufficent size that does not have allocated
+	 * pages attached to it (i.e., a chunk from a previous import region that's
+	 * been freed.
+	 */
+	chunk = gmm_context.head_chunk;
+	while (chunk) {
+		if ((chunk->usage == FREE_IMPORTED) && (chunk->pages >= numpages))
+		{
+			chunk->usage = INUSE_ALLOCATED;
+			EMGD_DEBUG("Re-using old chunk with offset=0x%lx", chunk->offset);
+			break;
+		}
+		chunk = chunk->next;
+	}
+
+	/* Allocate a new chunk if we didn't find any that we could reuse */
+	if (!chunk) {
+		chunk = (gmm_chunk_t *)OS_ALLOC(sizeof(gmm_chunk_t));
+		if (!chunk) {
+			printk(KERN_ALERT "[EMGD] Cannot allocate gmm_chunk_t");
+			EMGD_ERROR_EXIT("Returning %d", -IGD_ERROR_NOMEM);
+			return -IGD_ERROR_NOMEM;
+		}
+		OS_MEMSET(chunk, 0, sizeof(gmm_chunk_t));
+
+		chunk->pages = numpages;
+		chunk->size = numpages * PAGE_SIZE;
+		chunk->next = NULL;
+
+		/* Create a gmm_mem_buffer_t for the imported memory */
+		chunk->gtt_mem = OS_ALLOC(sizeof(gmm_mem_buffer_t));
+		if (chunk->gtt_mem == NULL) {
+			OS_FREE(chunk);
+			return -IGD_ERROR_NOMEM;
+		}
+
+		/* Stick this chunk after all other GTT chunks */
+		if (gmm_context.tail_chunk == NULL) {
+			/* First chunk ever! */
+			gmm_context.head_chunk = chunk;
+			chunk->offset = 0;
+		} else {
+			chunk->offset = gmm_context.tail_chunk->offset +
+				gmm_context.tail_chunk->size;
+			gmm_context.tail_chunk->next = chunk;
+		}
+		gmm_context.tail_chunk = chunk;
+
+		/*
+		 * Since we're making this a displayable surface, we need to make sure
+		 * it's 256k-aligned.
+		 */
+		chunk->offset = (chunk->offset + 0x3ffff) & ~0x3ffff;
+
+		EMGD_DEBUG("Setting up a new GMM chunk for imported pages");
+	}
+
+	*gtt_offset = chunk->offset;
+
+	chunk->usage = INUSE_IMPORTED;
+	chunk->ref_cnt = 0;
+	chunk->page_addresses = NULL;
+
+	/*
+	 * Note that the underlying gmm_mem_buffer may have a smaller size and
+	 * number of pages if we're reusing a larger chunk than we really needed.
+	 */
+	chunk->gtt_mem->size = numpages * PAGE_SIZE;
+	chunk->gtt_mem->pages = (struct page**)pagelist;
+	chunk->gtt_mem->page_count = numpages;
+
+	/*
+	 * These fields should never be needed since responsibility for actually
+	 * freeing these pages and the page list itself lies with the external
+	 * code that allocated the pages.
+	 */
+	chunk->type = AGP_NORMAL_MEMORY;
+	chunk->gtt_mem->type = AGP_NORMAL_MEMORY;
+	chunk->gtt_mem->vmalloc_flag = 0;
+
+	/*
+	 * This updates the GTT table with the actual imported pages
+	 * so the display hardware can access the memory.
+	 */
+	emgd_gtt_insert(gmm_context.context, chunk->gtt_mem, chunk->offset);
+	chunk->bound = 1;
+
+	/*
+	 * Physical is only meaningfull for single page or contiguous pages.
+	 * It represents the physical address of the first allocated page.
+	 */
+	if (chunk->gtt_mem->physical == 0x0) {
+		chunk->gtt_mem->physical = page_to_phys(chunk->gtt_mem->pages[0]);
+                chunk->gtt_mem->physical += phys_offset;
+	}
+
+	EMGD_DEBUG("Imported chunk @ 0x%lx (0x%lx)", chunk->offset,
+		(unsigned long)chunk->gtt_mem->physical);
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+
+
 static int gmm_get_page_list(unsigned long offset,
 		unsigned long **pages,
 		unsigned long *page_cnt)
diff --git a/drivers/gpu/drm/emgd/emgd/gmm/gtt.c b/drivers/gpu/drm/emgd/emgd/gmm/gtt.c
index aee1130..f530ca6 100644
--- a/drivers/gpu/drm/emgd/emgd/gmm/gtt.c
+++ b/drivers/gpu/drm/emgd/emgd/gmm/gtt.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: gtt.c
- * $Revision: 1.15 $
+ * $Revision: 1.17 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -136,8 +136,9 @@ static void invalidate_vma(unsigned long pg_offset, unsigned long bus_addr) {
 
 
 			if (!page_mapcount(pte_page(*pte))) {
-				printk(KERN_ERR "ERROR No mapcount");
-				printk(KERN_ALERT "ZR %p %08lX %d %d %p", pte_page(*pte),
+				printk(KERN_ERR "[EMGD] ERROR No mapcount\n");
+				printk(KERN_ALERT "[EMGD] ZR %p %08lX %d %d %p\n",
+						pte_page(*pte),
 						pte_page(*pte)->flags, page_count(pte_page(*pte)),
 						page_mapcount(pte_page(*pte)), pte_page(*pte)->mapping);
 			} else {
@@ -146,7 +147,7 @@ static void invalidate_vma(unsigned long pg_offset, unsigned long bus_addr) {
 #if  (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34))
 				dec_mm_counter(entry->vma->vm_mm, file_rss);
 #else
-			 	dec_mm_counter(entry->vma->vm_mm, MM_FILEPAGES);
+				dec_mm_counter(entry->vma->vm_mm, MM_FILEPAGES);
 #endif
 			}
 
@@ -191,7 +192,7 @@ gmm_mem_buffer_t *emgd_alloc_pages(unsigned long num_pages, int type) {
 	}
 
 	if (mem->pages == NULL) {
-		printk(KERN_ERR "Failed to allocate memory info struct.\n");
+		printk(KERN_ERR "[EMGD] Failed to allocate memory info struct.\n");
 		kfree(mem);
 		return NULL;
 	}
@@ -212,7 +213,7 @@ gmm_mem_buffer_t *emgd_alloc_pages(unsigned long num_pages, int type) {
 			page = alloc_page(GFP_KERNEL | GFP_DMA32 | __GFP_ZERO);
 			if (page == NULL) {
 				/* Error! */
-				printk(KERN_ERR "Memory allocation failure!\n");
+				printk(KERN_ERR "[EMGD] Memory allocation failure!\n");
 				if (mem->vmalloc_flag) {
 					vfree(mem->pages);
 				} else {
@@ -224,8 +225,8 @@ gmm_mem_buffer_t *emgd_alloc_pages(unsigned long num_pages, int type) {
 
 			/* Make sure this page isn't cached */
 			if (set_memory_uc((unsigned long) page_address(page), 1) < 0) {
-				printk(KERN_ERR "Unable to set page attributes for newly "
-					"allocated graphics memory.\n");
+				printk(KERN_ERR "[EMGD] Unable to set page attributes for newly"
+					" allocated graphics memory.\n");
 				/* Rely on the fact that we've kept up the data structures: */
 				emgd_free_pages(mem);
 				/* XXX - THIS IS WHAT SOME OLD IEGD CODE DID--A GOOD IDEA??? */
@@ -246,7 +247,7 @@ gmm_mem_buffer_t *emgd_alloc_pages(unsigned long num_pages, int type) {
 		} else if (num_pages == 8) {
 			order = 3;
 		} else {
-			printk(KERN_ERR "Page count is not valid for physical "
+			printk(KERN_ERR "[EMGD] Page count is not valid for physical "
 				"allocation.\n");
 			if (mem->vmalloc_flag) {
 				vfree(mem->pages);
@@ -260,7 +261,7 @@ gmm_mem_buffer_t *emgd_alloc_pages(unsigned long num_pages, int type) {
 		page = alloc_pages(GFP_KERNEL, order);
 		if (page == NULL) {
 			/* Error! */
-			printk(KERN_ERR "Memory allocation failure!\n");
+			printk(KERN_ERR "[EMGD] Memory allocation failure!\n");
 			if (mem->vmalloc_flag) {
 				vfree(mem->pages);
 			} else {
@@ -272,8 +273,8 @@ gmm_mem_buffer_t *emgd_alloc_pages(unsigned long num_pages, int type) {
 			/* Make sure these pages aren't cached */
 			if (set_memory_uc((unsigned long) page_address(page),
 				num_pages) < 0) {
-				printk(KERN_ERR "Unable to set page attributes for newly "
-					"allocated physical graphics memory.\n");
+				printk(KERN_ERR "[EMGD] Unable to set page attributes for newly"
+					" allocated physical graphics memory.\n");
 				/* XXX - THIS IS WHAT SOME OLD IEGD CODE DID--A GOOD IDEA??? */
 				set_memory_wb((unsigned long) page_address(page), num_pages);
 				__free_pages(page, num_pages);
@@ -347,7 +348,7 @@ void emgd_gtt_insert(igd_context_t *context,
 
 	/* Check that the offset is within the gtt's range */
 	if ((pg_off + mem->page_count) > context->device_context.gatt_pages) {
-		printk(KERN_ERR "emgd_gtt_insert: page offset beyond of GTT range.\n");
+		printk(KERN_ERR "[EMGD] Attempt to insert a offset beyond of GTT range.\n");
 		return;
 	}
 
@@ -360,16 +361,6 @@ void emgd_gtt_insert(igd_context_t *context,
 	mutex_lock(&gtt_sem);
 	for (i = 0, j = pg_off; i < mem->page_count; i++, j++) {
 		page = mem->pages[i];
-		/* FIXME: Apparently we don't really need to copy stolen memory pages.
-		 * If so, can we remove the following code?
-		 */
-		if (j < context->device_context.stolen_pages) {
-			/* Inserting over the top of stolen memory */
-			if (j == pg_off) {
-				printk(KERN_ALERT " Inserting over stolen memory.\n");
-			}
-			/* Copy old page to new page */
-		}
 
 		/* Mark the page as valid */
 		pte = page_to_phys(page) | PSB_PTE_VALID;
diff --git a/drivers/gpu/drm/emgd/emgd/include/cmd.h b/drivers/gpu/drm/emgd/emgd/include/cmd.h
index c603301..e1787ec 100644
--- a/drivers/gpu/drm/emgd/emgd/include/cmd.h
+++ b/drivers/gpu/drm/emgd/emgd/include/cmd.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: cmd.h
- * $Revision: 1.6 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/context.h b/drivers/gpu/drm/emgd/emgd/include/context.h
index 63f35ee..07f033d 100644
--- a/drivers/gpu/drm/emgd/emgd/include/context.h
+++ b/drivers/gpu/drm/emgd/emgd/include/context.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: context.h
- * $Revision: 1.14 $
+ * $Revision: 1.21 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -54,7 +54,8 @@ struct _cmd_queue;
  * Flags for reg_set_mod_state and reg_get_mode_state
  */
 typedef enum _reg_state_id {
-	REG_MODE_STATE = 1
+	REG_MODE_STATE_REG = 1,
+	REG_MODE_STATE_CON = 2
 } reg_state_id_t;
 
 /* module_state handle */
@@ -108,6 +109,12 @@ typedef struct _inter_module_dispatch {
 		struct _igd_plane **secondary_display_plane,
 		struct _igd_display_pipe **primary_pipe,
 		struct _igd_display_pipe **secondary_pipe);
+	int (*dsp_alloc)(igd_context_t *context, unsigned long dc,
+		unsigned long flags);
+	void (*dsp_control_plane_format)(int enable, int display_plane, struct _igd_plane *plane_override);
+
+	/* Flag to indicate FB Blend + Overlay override */
+	unsigned int fb_blend_ovl_override;
 
 	unsigned long *dsp_current_dc;
 	/* Firmware  programmed DC. This information needs to be
@@ -115,6 +122,10 @@ typedef struct _inter_module_dispatch {
      */
 	unsigned long dsp_fw_dc;
 
+	/* flag to tell if in dih_clone mode */
+	unsigned long in_dih_clone_mode;
+	unsigned long dih_clone_display;
+
 	struct _igd_display_port **dsp_port_list;
 	struct _igd_display_context **dsp_display_list;
 
@@ -134,19 +145,13 @@ typedef struct _inter_module_dispatch {
 	int (*reg_get_mod_state)(reg_state_id_t id, module_state_h **state,
 		unsigned long **flags);
 
-	/* Command Module Calls */
-	int (*alloc_queues)(igd_context_t *context,
-		struct _igd_display_pipe *pipe, unsigned long flags);
-	void (*free_queues)(igd_context_t *context,
-		struct _igd_display_pipe *pipe);
-	int (*cmd_control)(struct _cmd_queue *cmd_queue, unsigned long flags);
-
-
 	/* Power Module Calls to Reg module */
 	void *(*reg_alloc)(igd_context_t *context, unsigned long flags);
 	void (*reg_free)(igd_context_t *context, void *reg_set);
 	int (*reg_save)(igd_context_t *context, void *reg_set);
 	int (*reg_restore)(igd_context_t *context, void *reg_set);
+	void (*reg_crtc_lut_get)(igd_context_t *context, void *emgd_crtc);
+	void (*reg_crtc_lut_set)(igd_context_t *context, void *emgd_crtc);
 
 	/* Reg Module callbacks */
 	int (*mode_save)(igd_context_t *context, module_state_h *state,
@@ -157,6 +162,8 @@ typedef struct _inter_module_dispatch {
 	/* Power Module Callbacks */
 	int (*mode_pwr)(igd_context_t *context, unsigned long powerstate);
 	int (*overlay_pwr)(igd_context_t *context, unsigned long powerstate);
+	int (*msvdx_pwr)(igd_context_t *context, unsigned long powerstate);
+	int (*msvdx_status)(igd_context_t *context, unsigned long *queue_status, unsigned long *mtx_msg_status);
 
 	/* Shutdown functions for use by init module only */
 	void (*mode_shutdown)(igd_context_t *context);
@@ -172,14 +179,12 @@ typedef struct _inter_module_dispatch {
 	void (*cmd_shutdown)(igd_context_t *context);
 	void (*reg_shutdown)(igd_context_t *context);
 
-    /* MSVDX */
-    int (*process_video_decode)(igd_context_t *context, void *arg);
-
 	/* Mode module Callbacks */
 	int (*get_dd_timing)(struct _igd_display_context *display,
 		struct _pd_timing *in_list);
 	int (*check_port_supported)(void *port_tmp);
 	int (*get_refresh_in_border)(struct _pd_timing *in_list);
+
 } inter_module_dispatch_t;
 
 /*
@@ -247,9 +252,3 @@ typedef struct _igd_display_context {
 
 #endif
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: context.h,v 1.14 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/context.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/debug.h b/drivers/gpu/drm/emgd/emgd/include/debug.h
index f9eda7e..3a12fc1 100644
--- a/drivers/gpu/drm/emgd/emgd/include/debug.h
+++ b/drivers/gpu/drm/emgd/emgd/include/debug.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: debug.h
- * $Revision: 1.7 $
+ * $Revision: 1.9 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -167,10 +167,3 @@
 }
 
 #endif
-
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: debug.h,v 1.7 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/debug.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/decode.h b/drivers/gpu/drm/emgd/emgd/include/decode.h
index a441cdc..ac2415a 100644
--- a/drivers/gpu/drm/emgd/emgd/include/decode.h
+++ b/drivers/gpu/drm/emgd/emgd/include/decode.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: decode.h
- * $Revision: 1.6 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/dispatch.h b/drivers/gpu/drm/emgd/emgd/include/dispatch.h
index f19a30b..c5a371f 100644
--- a/drivers/gpu/drm/emgd/emgd/include/dispatch.h
+++ b/drivers/gpu/drm/emgd/emgd/include/dispatch.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: dispatch.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/dispatch_utils.h b/drivers/gpu/drm/emgd/emgd/include/dispatch_utils.h
index 8183b79..b6e4f73 100644
--- a/drivers/gpu/drm/emgd/emgd/include/dispatch_utils.h
+++ b/drivers/gpu/drm/emgd/emgd/include/dispatch_utils.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: dispatch_utils.h
- * $Revision: 1.6 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/displayid.h b/drivers/gpu/drm/emgd/emgd/include/displayid.h
index 884d043..effc4c9 100644
--- a/drivers/gpu/drm/emgd/emgd/include/displayid.h
+++ b/drivers/gpu/drm/emgd/emgd/include/displayid.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: displayid.h
- * $Revision: 1.7 $
+ * $Revision: 1.9 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -642,9 +642,3 @@ void displayid_dump(unsigned char *buffer, unsigned short size);
 void displayid_print(unsigned char *buffer, displayid_t *displayid);
 
 #endif
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: displayid.h,v 1.7 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/displayid.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/dsp.h b/drivers/gpu/drm/emgd/emgd/include/dsp.h
index c72a248..8a803bf 100644
--- a/drivers/gpu/drm/emgd/emgd/include/dsp.h
+++ b/drivers/gpu/drm/emgd/emgd/include/dsp.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: dsp.h
- * $Revision: 1.5 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -44,9 +44,3 @@ int dsp_display_connected(igd_context_t *context, igd_display_port_t *port);
 
 #endif /* _DSP_H_ */
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: dsp.h,v 1.5 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/dsp.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/edid.h b/drivers/gpu/drm/emgd/emgd/include/edid.h
index e3764e4..829e272 100644
--- a/drivers/gpu/drm/emgd/emgd/include/edid.h
+++ b/drivers/gpu/drm/emgd/emgd/include/edid.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: edid.h
- * $Revision: 1.5 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -128,9 +128,3 @@ int edid_ext_parse(
 		int           count,
 		unsigned char upscale);
 #endif
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: edid.h,v 1.5 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/edid.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/general.h b/drivers/gpu/drm/emgd/emgd/include/general.h
index 6bf622c..159bf23 100644
--- a/drivers/gpu/drm/emgd/emgd/include/general.h
+++ b/drivers/gpu/drm/emgd/emgd/include/general.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: general.h
- * $Revision: 1.5 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -82,9 +82,3 @@
 
 #endif // _GENERAL_H_
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: general.h,v 1.5 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/general.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/instr_common.h b/drivers/gpu/drm/emgd/emgd/include/instr_common.h
index 5b35c25..95c7e38 100644
--- a/drivers/gpu/drm/emgd/emgd/include/instr_common.h
+++ b/drivers/gpu/drm/emgd/emgd/include/instr_common.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: instr_common.h
- * $Revision: 1.7 $
+ * $Revision: 1.8 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/intelpci.h b/drivers/gpu/drm/emgd/emgd/include/intelpci.h
index 48ab360..b389cc7 100644
--- a/drivers/gpu/drm/emgd/emgd/include/intelpci.h
+++ b/drivers/gpu/drm/emgd/emgd/include/intelpci.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: intelpci.h
- * $Revision: 1.9 $
+ * $Revision: 1.11 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -96,9 +96,3 @@
 
 #define INTEL_PTE_ALLIGNMENT                0xFFFFF000
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: intelpci.h,v 1.9 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/intelpci.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/math_fix.h b/drivers/gpu/drm/emgd/emgd/include/math_fix.h
index 664e5f3..91306fe 100644
--- a/drivers/gpu/drm/emgd/emgd/include/math_fix.h
+++ b/drivers/gpu/drm/emgd/emgd/include/math_fix.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: math_fix.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/memlist.h b/drivers/gpu/drm/emgd/emgd/include/memlist.h
index fa43479..34cb2ec 100644
--- a/drivers/gpu/drm/emgd/emgd/include/memlist.h
+++ b/drivers/gpu/drm/emgd/emgd/include/memlist.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: memlist.h
- * $Revision: 1.15 $
+ * $Revision: 1.16 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -117,16 +117,19 @@ typedef struct _gmm_chunk {
 	struct _gmm_chunk *next;
 	/* Previous chunk in the list */
 	struct _gmm_chunk *previous;
-	/* A boolean flag indicating if the chunk's memory is in use or free */
-	unsigned long used;
+	/* Current chunk usage state */
+	enum {
+		INUSE_ALLOCATED,
+		FREE_ALLOCATED,  /* gmm-allocated pages attached */
+		INUSE_IMPORTED,
+		FREE_IMPORTED    /* address space only; no pages attached */
+	} usage;
 	/* The offset of the allocated memory, after alignment */
 	unsigned long offset;
 	/* The number of bytes of memory requested/allocated for this chunk */
 	unsigned long size;
 	/* The number of pages of memory required for "size" bytes */
 	unsigned long pages;
-	/* A pointer to the agp_memory struct that agp_allocate_memory() returns */
-	struct agp_memory *memory;
 	/* A boolean flag indicating if the chunk's memory has been bound by AGP */
 	unsigned long bound;
 	/* Either AGP_PHYS_MEMORY or AGP_NORMAL_MEMORY */
diff --git a/drivers/gpu/drm/emgd/emgd/include/memory.h b/drivers/gpu/drm/emgd/emgd/include/memory.h
index 18a1620..f85477c 100644
--- a/drivers/gpu/drm/emgd/emgd/include/memory.h
+++ b/drivers/gpu/drm/emgd/emgd/include/memory.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: memory.h
- * $Revision: 1.6 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/mode.h b/drivers/gpu/drm/emgd/emgd/include/mode.h
index 7c700c0..1cb8a2c 100644
--- a/drivers/gpu/drm/emgd/emgd/include/mode.h
+++ b/drivers/gpu/drm/emgd/emgd/include/mode.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: mode.h
- * $Revision: 1.7 $
+ * $Revision: 1.9 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -45,6 +45,12 @@
 #include <displayid.h>
 #include <igd_render.h>
 
+/* KMS-related Headers */
+#include <drm/drmP.h>
+#include <drm/drm.h>
+#include <drm/drm_fb_helper.h>
+
+
 #ifndef TRUE
 #define TRUE  1
 #endif
@@ -163,6 +169,16 @@
 	((((pd_timing_t *)t)->mode_info_flags & IGD_MODE_VESA) &&	\
 		(t->mode_number < 0x1D))
 
+#define IGD_KMS_PIPEA (IGD_PIPE_IS_PIPEA >> IGD_PORT_USE_PIPE_MASK_SHIFT)
+#define IGD_KMS_PIPEB (IGD_PIPE_IS_PIPEB >> IGD_PORT_USE_PIPE_MASK_SHIFT)
+
+#define KMS_PIPE_FEATURES(display) \
+	(((igd_display_pipe_t *)((igd_display_context_t *)display)->pipe)->pipe_features)
+
+#define KMS_PIPE_ID(pipe_features) \
+	((pipe_features & IGD_PORT_USE_PIPE_MASK) >> IGD_PORT_USE_PIPE_MASK_SHIFT)
+
+
 /* #define DC_PORT_NUMBER(dc, i) ((dc >> (i * 4)) & 0x0f) */
 #define DC_PORT_NUMBER IGD_DC_PORT_NUMBER
 
@@ -208,10 +224,10 @@ typedef struct _igd_cursor {
 } igd_cursor_t;
 
 typedef struct _igd_clock {
-	unsigned long dpll_control;       /* DPLL control register */
-	unsigned long mnp;                /* FPx0 register */
-	unsigned long p_shift;            /* Bit location of P within control */
-	unsigned long actual_dclk;		  /* The actual dotclock after calculating dpll */
+	unsigned long dpll_control;     /* DPLL control register */
+	unsigned long mnp;              /* FPx0 register */
+	unsigned long p_shift;          /* Bit location of P within control */
+	unsigned long actual_dclk;		/* Actual dotclock after calculating dpll */
 }igd_clock_t;
 
 typedef struct _igd_display_pipe {
@@ -300,12 +316,129 @@ typedef struct _mode_state_t {
 	mode_pd_state_t pd_state[MAX_PORT_DRIVERS];
 } mode_state_t;
 
+
+/**
+ * This holds information about a framebuffer
+ */
+typedef struct _emgd_framebuffer {
+	struct drm_framebuffer base;
+	enum {
+		GMM_FRAMEBUFFER,
+		PVR_FRAMEBUFFER
+	} type;
+	void *pvr_meminfo;
+	struct page **pagelist;
+	unsigned long gtt_offset;
+	unsigned long handle;
+} emgd_framebuffer_t;
+
+typedef struct _emgdfb_par {
+        struct drm_device  *dev;
+        emgd_framebuffer_t *emgd_fb;
+} emgdfb_par_t;
+
+
+/**
+ * This holds information about a CRTC.
+ */
+typedef struct _emgd_crtc {
+        struct drm_crtc         base;
+
+		/* Spinlock to protect access to this structure */
+		spinlock_t              crtc_lock;
+
+        int                     crtc_id;
+        igd_display_pipe_t     *igd_pipe;
+        emgd_framebuffer_t     *fbdev_fb;
+        struct drm_mode_set     mode_set;
+        struct drm_display_mode saved_mode;
+        struct drm_display_mode saved_adjusted_mode;
+        unsigned char           lut_r[256];
+        unsigned char           lut_g[256];
+        unsigned char           lut_b[256];
+        unsigned char           lut_a[256];
+
+		/* Flip request work task */
+		struct work_struct      flip_work;
+		unsigned char           flip_work_queued;
+
+		/*
+		 * Framebuffer that we're in the process of flipping to (may not
+		 * actually show up until rendering is complete, the actual
+		 * registers are programmed, and a vblank happens).
+		 */
+		emgd_framebuffer_t *newfb;
+
+		/*
+		 * Target for rendering completion to allow flip to proceed.
+		 * Rendering operations may continue to be dispatched against this
+		 * FB after the flip ioctl is called, so we need to track the
+		 * number of pending operations at the point the ioctl was called
+		 * and use that as our target to flip on.
+		 */
+		unsigned long render_complete_at;
+
+		/*
+		 * Are we waiting for the next vblank event to perform flip cleanup
+		 * on this CRTC?  Flip cleanup primarily involves sending a
+		 * notification event back to userspace.
+		 */
+		unsigned char vblank_expected;
+
+		/* Userspace event to send back upon flip completion. */
+		struct drm_pending_vblank_event *flip_event;
+} emgd_crtc_t;
+
+
+/**
+ * This holds information about an individual encoder
+ *  */
+typedef struct _emgd_encoder {
+        struct drm_encoder base;
+
+        unsigned long       crtc_mask;
+        unsigned long       clone_mask;
+        igd_display_port_t *igd_port;
+        mode_pd_state_t     state;
+        /* flags is a bit mask. For information
+         * on the different masks, see ENCODER_FLAG_xx
+         */
+		unsigned long       flags;
+} emgd_encoder_t;
+
+#define ENCODER_FLAG_FIRST_DPMS  0x1
+#define ENCODER_FLAG_FIRST_ALTER 0x2
+#define ENCODER_FLAG_SEAMLESS    0x4
+
+/**
+ *  * This holds information about an individual output
+ *   */
+typedef struct _emgd_connector {
+        struct drm_connector  base;
+
+        emgd_encoder_t       *encoder;
+        unsigned long         type;
+        struct drm_property **properties;
+        unsigned long         num_of_properties;
+
+        struct _drm_emgd_private *priv;
+} emgd_connector_t;
+
+/**
+ *  * This holds information on our framebuffer device.
+ *   */
+typedef struct _emgd_fbdev {
+        struct drm_fb_helper      helper;
+
+        emgd_framebuffer_t       *emgd_fb;
+        u32                       pseudo_palette[17];
+        struct list_head          fbdev_list;
+        struct _drm_emgd_private *priv;
+} emgd_fbdev_t;
+
+
+
+
 #endif // _IGD_MODE_H_
 
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: mode.h,v 1.7 2011/03/02 22:47:05 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/mode.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/mode_access.h b/drivers/gpu/drm/emgd/emgd/include/mode_access.h
index bafd348..307739a 100644
--- a/drivers/gpu/drm/emgd/emgd/include/mode_access.h
+++ b/drivers/gpu/drm/emgd/emgd/include/mode_access.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: mode_access.h
- * $Revision: 1.5 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -50,9 +50,3 @@ GET_DEVICE_POWER_STATE(d_h) : ((PORT(d_h, pn))->power_state))
 
 #endif /* _IGD_MODEACCESS_H */
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: mode_access.h,v 1.5 2011/03/02 22:47:05 astead Exp $
- *
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/module_init.h b/drivers/gpu/drm/emgd/emgd/include/module_init.h
index 53baf0d..8feafea 100644
--- a/drivers/gpu/drm/emgd/emgd/include/module_init.h
+++ b/drivers/gpu/drm/emgd/emgd/include/module_init.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: module_init.h
- * $Revision: 1.6 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/msvdx.h b/drivers/gpu/drm/emgd/emgd/include/msvdx.h
index 0f28ab6..88aea1b 100644
--- a/drivers/gpu/drm/emgd/emgd/include/msvdx.h
+++ b/drivers/gpu/drm/emgd/emgd/include/msvdx.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: msvdx.h
- * $Revision: 1.17 $
+ * $Revision: 1.18 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/pci.h b/drivers/gpu/drm/emgd/emgd/include/pci.h
index e8c2d22..9a5fc5c 100644
--- a/drivers/gpu/drm/emgd/emgd/include/pci.h
+++ b/drivers/gpu/drm/emgd/emgd/include/pci.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: pci.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/pd.h b/drivers/gpu/drm/emgd/emgd/include/pd.h
index 7c2f32c..388a2af 100644
--- a/drivers/gpu/drm/emgd/emgd/include/pd.h
+++ b/drivers/gpu/drm/emgd/emgd/include/pd.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: pd.h
- * $Revision: 1.9 $
+ * $Revision: 1.12 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -359,6 +359,7 @@ typedef struct _cea_extension{
 #define PD_REG_MIO8   0x00000009   /* MMIO 8 bits     */
 #define PD_REG_BRIDGE_OPCODE  0x0000000D /* Host bridge read and write */
 #define PD_REG_DDC            0x0000000E /* Read the ddc */
+#define PD_REG_DDC_FW            0x0000000F /* Read the ddc */
 
 typedef int (*pd_read_regs_p)(void *callback_context, pd_reg_t *list,
 		unsigned long type);
@@ -763,9 +764,3 @@ typedef int        (*pd_filter_timings_p)(void *context, pd_timing_t *inlist,
 */
 #endif /* _PD_H_ */
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: pd.h,v 1.9 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/pd.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/pd_init.h b/drivers/gpu/drm/emgd/emgd/include/pd_init.h
index bc26094..eb78285 100644
--- a/drivers/gpu/drm/emgd/emgd/include/pd_init.h
+++ b/drivers/gpu/drm/emgd/emgd/include/pd_init.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: pd_init.h
- * $Revision: 1.5 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -189,9 +189,3 @@ extern int pd000_init(void *handle);
 
 #endif
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: pd_init.h,v 1.5 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/pd_init.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/pi.h b/drivers/gpu/drm/emgd/emgd/include/pi.h
index d2f6a73..d14d39e 100644
--- a/drivers/gpu/drm/emgd/emgd/include/pi.h
+++ b/drivers/gpu/drm/emgd/emgd/include/pi.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: pi.h
- * $Revision: 1.5 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -81,11 +81,6 @@ extern int pi_pd_find_attr_and_value(igd_display_port_t *port,
 extern int pi_get_port_init_attr(igd_display_port_t *port,
 		unsigned long id,
 		unsigned long *value);
+extern int pi_save_mode_state(igd_display_port_t *port,
+		reg_state_id_t reg_state_id);
 #endif /* _PI_H_ */
-
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: pi.h,v 1.5 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/pi.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/plb/appcontext.h b/drivers/gpu/drm/emgd/emgd/include/plb/appcontext.h
index 4466bd1..3a1417c 100644
--- a/drivers/gpu/drm/emgd/emgd/include/plb/appcontext.h
+++ b/drivers/gpu/drm/emgd/emgd/include/plb/appcontext.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: appcontext.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/plb/cmd.h b/drivers/gpu/drm/emgd/emgd/include/plb/cmd.h
index 5652bf3..c4252cb 100644
--- a/drivers/gpu/drm/emgd/emgd/include/plb/cmd.h
+++ b/drivers/gpu/drm/emgd/emgd/include/plb/cmd.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: cmd.h
- * $Revision: 1.12 $
+ * $Revision: 1.13 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/plb/context.h b/drivers/gpu/drm/emgd/emgd/include/plb/context.h
index aca447d..01df47f 100644
--- a/drivers/gpu/drm/emgd/emgd/include/plb/context.h
+++ b/drivers/gpu/drm/emgd/emgd/include/plb/context.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: context.h
- * $Revision: 1.13 $
+ * $Revision: 1.16 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -146,7 +146,7 @@ typedef struct _tnc_topaz_priv {
 	unsigned long *topaz_sync_addr;
 	unsigned long topaz_sync_offset;
 	unsigned long topaz_sync_cmd_seq;
-	unsigned long topaz_sync_val;
+	unsigned long topaz_sync_id;
 	/**
 	 * Virtual address to writeback memory in the aperture space.
 	 */
@@ -164,6 +164,7 @@ typedef struct _platform_context_plb {
 	os_pci_dev_t pcidev1;
 	os_pci_dev_t lpc_dev;
 	os_pci_dev_t bridgedev;
+	unsigned char tnc_dev3_rid;             /* TNC Device 3 RID*/
 	os_pci_dev_t stbridgedev;
 	os_pci_dev_t stgpiodev;
 	unsigned long rendec_base0;
diff --git a/drivers/gpu/drm/emgd/emgd/include/plb/instr.h b/drivers/gpu/drm/emgd/emgd/include/plb/instr.h
index 1030544..791808a 100644
--- a/drivers/gpu/drm/emgd/emgd/include/plb/instr.h
+++ b/drivers/gpu/drm/emgd/emgd/include/plb/instr.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: instr.h
- * $Revision: 1.6 $
+ * $Revision: 1.8 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -222,9 +222,3 @@ typedef struct _igd_vertex {
 	CMD_2D_WRITE_PLB(queue, chroma_color);
 
 #endif
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: instr.h,v 1.6 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/plb/instr.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/plb/mi.h b/drivers/gpu/drm/emgd/emgd/include/plb/mi.h
index 5f3055e..fcbc706 100644
--- a/drivers/gpu/drm/emgd/emgd/include/plb/mi.h
+++ b/drivers/gpu/drm/emgd/emgd/include/plb/mi.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: mi.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/plb/regs.h b/drivers/gpu/drm/emgd/emgd/include/plb/regs.h
index fd82020..95d880f 100644
--- a/drivers/gpu/drm/emgd/emgd/include/plb/regs.h
+++ b/drivers/gpu/drm/emgd/emgd/include/plb/regs.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: regs.h
- * $Revision: 1.6 $
+ * $Revision: 1.10 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -402,9 +402,6 @@
 #define P2D_CG_DIS      0x06200  /* Clock Gating Disable */
 #define P3D_CG_DIS      0x06204  /* Clock Gating Disable */
 
-#define DSP_ARB         0x70030
-#define FW_BLC_AB       0x70034
-#define FW_BLC_C        0x70038
 
 /*-----------------------------------------------------------------------------
  * Display Palette Register Definitions (0A000h - 0AFFFh)
@@ -500,6 +497,16 @@
 #define PIPE_STATUS_OFFSET     0x1C
 #define PIPEA_STAT             0x70024  /* Pipe A Display Status */
 #define PIPEA_DISP_ARB_CTRL    0x70030  /* Display Arbitration Control */
+#define FW_BLC_AB              0x70034
+#define FW_BLC_C               0x70038
+#define PIPEA_FRAME_HIGH       0x70040  /* Pipe A Frame Count High */
+#define PIPEA_FRAME_PIXEL      0x70044  /* Pipe A Frame Cnt Low & pixel count */
+
+#define PIPE_PIXEL_MASK        0x00ffffff
+#define PIPE_FRAME_HIGH_MASK   0x0000ffff
+#define PIPE_FRAME_LOW_MASK    0xff000000
+#define PIPE_FRAME_LOW_SHIFT   24
+
 
 /* following bit flag defs can be re-used for Pipe-B */
 #define PIPE_ENABLE       BIT31
@@ -557,7 +564,7 @@
 /*-----------------------------------------------------------------------------
  * VBIOS Software flags  00h - 0Fh
  *---------------------------------------------------------------------------*/
-#define KFC             0x70400  /* Chicken Bit */
+#define DSP_CHICKENBITS 0x70400  /* Chicken Bit */
 #define SWFABASE        0x70410  /* Software flags A Base Addr */
 #define SWF00           0x70410
 #define SWF01           0x70414
@@ -580,10 +587,13 @@
 /*-----------------------------------------------------------------------------
  * Display Pipeline B Register ( 71000h - 71024h )
  *---------------------------------------------------------------------------*/
-#define PIPEB_SCANLINE_COUNT   0x71000 /* Pipe B Disp Scan Line Count Register */
-#define PIPEB_SCANLINE_COMPARE 0x71004 /* Pipe B Disp Scan Line Count Range Compare */
-#define PIPEB_CONF             0x71008 /* Pipe B Pixel Pipeline Config Register */
+#define PIPEB_SCANLINE_COUNT   0x71000 /* Pipe B Disp Scan Line Count Reg */
+#define PIPEB_SCANLINE_COMPARE 0x71004 /* Pipe B Disp Scan Line Cnt Range Cmp */
+#define PIPEB_CONF             0x71008 /* Pipe B Pixel Pipeline Config Reg */
 #define PIPEB_STAT             0x71024 /* Display Status Select Register */
+#define PIPEB_FRAME_HIGH       0x71040 /* Pipe B Frame Count High */
+#define PIPEB_FRAME_PIXEL      0x71044 /* Pipe B Frame Cnt Low and pixel cnt */
+
 
 #define VBLANK_EVN_STS_EN   BIT20
 #define VBLANK_ODD_STS_EN   BIT21
@@ -604,6 +614,18 @@
 #define DSPBKEYMASK     0x71198  /* Sprite color key mask */
 
 
+
+/*-----------------------------------------------------------------------------
+ * Source Format Definition for DSPxCNTR
+ *---------------------------------------------------------------------------*/
+#define DSPxCNTR_ARGB_8888			0x1C000000
+#define DSPxCNTR_RGB_8888			0x18000000
+#define DSPxCNTR_RGB_565			0x14000000
+#define DSPxCNTR_RGB_555			0x10000000
+#define DSPxCNTR_RGB_8				0x08000000
+#define DSPxCNTR_SRC_FMT_MASK			0x3C000000 /*mask for above*/
+
+
 /*-----------------------------------------------------------------------------
  * VBIOS Software flags  10h - 1Fh
  *---------------------------------------------------------------------------*/
@@ -723,10 +745,3 @@
 #define GMBUS_DVOC_DDC      5
 
 #endif /* _REGS_H_ */
-
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: regs.h,v 1.6 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/plb/regs.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/plb/sgx.h b/drivers/gpu/drm/emgd/emgd/include/plb/sgx.h
index 7feca9b..b882efc 100644
--- a/drivers/gpu/drm/emgd/emgd/include/plb/sgx.h
+++ b/drivers/gpu/drm/emgd/emgd/include/plb/sgx.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: sgx.h
- * $Revision: 1.6 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/plb/state3d.h b/drivers/gpu/drm/emgd/emgd/include/plb/state3d.h
index eda18d4..68f4a80 100644
--- a/drivers/gpu/drm/emgd/emgd/include/plb/state3d.h
+++ b/drivers/gpu/drm/emgd/emgd/include/plb/state3d.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: state3d.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/plb/state3d_plb.h b/drivers/gpu/drm/emgd/emgd/include/plb/state3d_plb.h
index d728af0e..37327bc 100644
--- a/drivers/gpu/drm/emgd/emgd/include/plb/state3d_plb.h
+++ b/drivers/gpu/drm/emgd/emgd/include/plb/state3d_plb.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: state3d_plb.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -161,9 +161,9 @@ typedef struct _state3d_chroma_key_plb {
 typedef struct _state3d_clear_parameters_plb {
 	union {
 		struct {
-        		unsigned int stencil_write_en :1;
-        		unsigned int depth_buffer_write_en :1;
-        		unsigned int color_buffer_write_en :1;
+		unsigned int stencil_write_en :1;
+		unsigned int depth_buffer_write_en :1;
+		unsigned int color_buffer_write_en :1;
 			unsigned int :13;
 			unsigned int clear_primitive_type :1;
 			unsigned int :15;
@@ -175,20 +175,20 @@ typedef struct _state3d_clear_parameters_plb {
 		unsigned int dw2;
 	};
 	union {
-        	unsigned int	clear_depth_buffer_val;
+	unsigned int	clear_depth_buffer_val;
 		unsigned int dw3;
 	};
 	union {
-        	unsigned int	clear_color;
+	unsigned int	clear_color;
 		unsigned int dw4;
 	};
 	union {
-        	unsigned int	clear_depth;
+	unsigned int	clear_depth;
 		unsigned int dw5;
 	};
 	union {
 		struct {
-        		unsigned int clear_stencil :8;
+		unsigned int clear_stencil :8;
 			unsigned int :24;
 		};
 		unsigned int dw6;
@@ -325,32 +325,32 @@ typedef struct _state3d_drawing_rectangle_plb {
 	union {
 		struct {
 			unsigned int :24;
-        		unsigned int y_dither_offset :2;
-        		unsigned int x_dither_offset :2;
+		unsigned int y_dither_offset :2;
+		unsigned int x_dither_offset :2;
 			unsigned int :2;
-        		unsigned int depth_buffer_coord_offset_dis :1;
-        		unsigned int fast_scissor_clip_dis :1;
+		unsigned int depth_buffer_coord_offset_dis :1;
+		unsigned int fast_scissor_clip_dis :1;
 		};
 		unsigned int dw1;
 	};
 	union {
 		struct {
-        		unsigned int clip_draw_rect_x_min :16;
-        		unsigned int clip_draw_rect_y_min :16;
+		unsigned int clip_draw_rect_x_min :16;
+		unsigned int clip_draw_rect_y_min :16;
 		};
 		unsigned int dw2;
 	};
 	union {
 		struct {
-        		unsigned int clip_draw_rect_x_max :16;
-        		unsigned int clip_draw_rect_y_max :16;
+		unsigned int clip_draw_rect_x_max :16;
+		unsigned int clip_draw_rect_y_max :16;
 		};
 		unsigned int dw3;
 	};
 	union {
 		struct {
-        		unsigned int draw_rect_origin_x :16;
-        		unsigned int draw_rect_origin_y :16;
+		unsigned int draw_rect_origin_x :16;
+		unsigned int draw_rect_origin_y :16;
 		};
 		unsigned int dw4;
 	};
diff --git a/drivers/gpu/drm/emgd/emgd/include/psb_regs.h b/drivers/gpu/drm/emgd/emgd/include/psb_regs.h
index 677e117..01edb09 100644
--- a/drivers/gpu/drm/emgd/emgd/include/psb_regs.h
+++ b/drivers/gpu/drm/emgd/emgd/include/psb_regs.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: psb_regs.h
- * $Revision: 1.7 $
+ * $Revision: 1.9 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -656,9 +656,3 @@ extern unsigned long _sgx_base;
 
 #endif /* _REGS_H_ */
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: psb_regs.h,v 1.7 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/psb_regs.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/rb.h b/drivers/gpu/drm/emgd/emgd/include/rb.h
index 7f1bce8..8e0c166 100644
--- a/drivers/gpu/drm/emgd/emgd/include/rb.h
+++ b/drivers/gpu/drm/emgd/emgd/include/rb.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: rb.h
- * $Revision: 1.9 $
+ * $Revision: 1.11 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -151,7 +151,7 @@ static __inline int rb_update(rb_buffer_t *buffer,
 {
 	unsigned long tail_off;
 /*	tail_off = (addr - buffer->virt); */
-   	tail_off = (unsigned long)((unsigned char *)(addr) - buffer->virt);
+	tail_off = (unsigned long)((unsigned char *)(addr) - buffer->virt);
 
 	buffer->reservation = 0;
 	buffer->tail_off = tail_off;
@@ -184,9 +184,3 @@ static __inline int rb_update(rb_buffer_t *buffer,
 
 #endif /* _RB_H */
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: rb.h,v 1.9 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/rb.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/reset.h b/drivers/gpu/drm/emgd/emgd/include/reset.h
index 196d289..809cb52 100644
--- a/drivers/gpu/drm/emgd/emgd/include/reset.h
+++ b/drivers/gpu/drm/emgd/emgd/include/reset.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: reset.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/sched.h b/drivers/gpu/drm/emgd/emgd/include/sched.h
index 9234c70..1abba3c 100644
--- a/drivers/gpu/drm/emgd/emgd/include/sched.h
+++ b/drivers/gpu/drm/emgd/emgd/include/sched.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: sched.h
- * $Revision: 1.9 $
+ * $Revision: 1.11 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -36,17 +36,18 @@
 #include <config.h>
 
 #include <linux/sched.h>
+#include <linux/delay.h>
 
 typedef unsigned long os_alarm_t;
 
 static __inline os_alarm_t _linux_kernel_set_alarm(unsigned long t)
 {
-  return (msecs_to_jiffies(t) + jiffies);
+	return (msecs_to_jiffies(t) + jiffies);
 }
 
 static __inline int _linux_kernel_test_alarm(os_alarm_t t)
 {
-  return (jiffies >= t) ? 1 : 0;
+	return (jiffies >= t) ? 1 : 0;
 }
 
 #define OS_SET_ALARM(t) _linux_kernel_set_alarm(t)
@@ -81,18 +82,33 @@ static __inline int _linux_kernel_test_alarm(os_alarm_t t)
  *  void OS_SCHEDULE( void );
  *---------------------------------------------------------------------------*/
 
-#define OS_SCHEDULE() schedule_timeout(1)
+#define OS_SCHEDULE() {									\
+	__set_current_state(TASK_INTERRUPTIBLE);					\
+	schedule_timeout(1); }
 
 #if 0
-// Implement _OS_SLEEP at a wait-loop
-#define _OS_SLEEP(usec) {					\
+#define OS_DELAY(usec) {					\
     unsigned long j_timeout = usecs_to_jiffies(usec);		\
     unsigned long j_start = jiffies;				\
     unsigned long j_current;					\
     do {							\
       j_current = jiffies;					\
     }while((j_current - j_start) < j_timeout);			\
-  }
+}
+#else
+#define OS_DELAY(usec)	udelay(usec);
+#endif
+
+#if 0
+// Implement _OS_SLEEP at a wait-loop
+#define _OS_SLEEP(usec) {					\
+	unsigned long j_timeout = usecs_to_jiffies(usec);		\
+	unsigned long j_start = jiffies;				\
+	unsigned long j_current;					\
+	do {							\
+		j_current = jiffies;					\
+	}while((j_current - j_start) < j_timeout);			\
+}
 #else
 // Implement _OS_SLEEP as a true sleep
 
@@ -115,8 +131,8 @@ static __inline int _linux_kernel_test_alarm(os_alarm_t t)
  *---------------------------------------------------------------------------*/
 
 #define OS_SLEEP(usec) {									\
-    __set_current_state(TASK_KILLABLE);						\
-    schedule_timeout(usecs_to_jiffies(usec)); }
+	__set_current_state(TASK_KILLABLE);						\
+	schedule_timeout(usecs_to_jiffies(usec)); }
 #endif
 
 /*----------------------------------------------------------------------------
@@ -139,8 +155,8 @@ static __inline int _linux_kernel_test_alarm(os_alarm_t t)
 
 /* un interuuptable sleep */
 #define OS_UISLEEP(usec) {					\
-    __set_current_state(TASK_UNINTERRUPTIBLE);			\
-    schedule_timeout(usecs_to_jiffies(usec)); 			\
+	__set_current_state(TASK_UNINTERRUPTIBLE);			\
+	schedule_timeout(usecs_to_jiffies(usec)); 			\
 }
 
 #ifndef OS_PTHREAD_CREATE
diff --git a/drivers/gpu/drm/emgd/emgd/include/state2d.h b/drivers/gpu/drm/emgd/emgd/include/state2d.h
index ed46551..af04e47 100644
--- a/drivers/gpu/drm/emgd/emgd/include/state2d.h
+++ b/drivers/gpu/drm/emgd/emgd/include/state2d.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: state2d.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/tnc/appcontext.h b/drivers/gpu/drm/emgd/emgd/include/tnc/appcontext.h
index d6dea15..0c76cf1 100644
--- a/drivers/gpu/drm/emgd/emgd/include/tnc/appcontext.h
+++ b/drivers/gpu/drm/emgd/emgd/include/tnc/appcontext.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: appcontext.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/tnc/cmd.h b/drivers/gpu/drm/emgd/emgd/include/tnc/cmd.h
index da3ae91..731c86a 100644
--- a/drivers/gpu/drm/emgd/emgd/include/tnc/cmd.h
+++ b/drivers/gpu/drm/emgd/emgd/include/tnc/cmd.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: cmd.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/tnc/context.h b/drivers/gpu/drm/emgd/emgd/include/tnc/context.h
index d6131d8..bcd73ee 100644
--- a/drivers/gpu/drm/emgd/emgd/include/tnc/context.h
+++ b/drivers/gpu/drm/emgd/emgd/include/tnc/context.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: context.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/tnc/igd_tnc_wa.h b/drivers/gpu/drm/emgd/emgd/include/tnc/igd_tnc_wa.h
index 844cb00..1be15cc 100644
--- a/drivers/gpu/drm/emgd/emgd/include/tnc/igd_tnc_wa.h
+++ b/drivers/gpu/drm/emgd/emgd/include/tnc/igd_tnc_wa.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_tnc_wa.h
- * $Revision: 1.9 $
+ * $Revision: 1.11 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -37,6 +37,7 @@
 #define _IGD_TNC_WA_H
 
 #define LNC_CLOCK 199500
+#define LNC_B1_OPTIMUM_MARGIN 2000
 #define LIMIT_TOTAL_CHECK_DISPLAY 10
 #define T0 0
 #define T1 1
@@ -45,10 +46,38 @@
 /* Graphic core Revision ID for Atom E6xx stepping */
 #define TNC_A0_RID			0x2
 #define TNC_B0_RID			0x3
+#define TNC_B0_DEV3_RID		0x1
+#define TNC_B1_DEV3_RID		0x2
 #define SDVO_CRC_CTRL_REG	0x61050
 #define SDVO_BUFF_CTRL_REG	0x61170
 #define TNC_HTOTAL_TUNED	0x8000
 
+/* flag to enable clipping hardware fix in TNC B1 */
+#define IGD_CLIP_FIX_DISABLE            0x0000
+ /* Completely disable throttling */
+#define IGD_CLIP_FIX_DISABLE_THROTTLE   0x0001
+/* Replaces the original stall_pixel from FSM with external stall from cDVO */
+#define IGD_CLIP_FIX_REPLACE_STALL      0x0002
+#define IGD_CLIP_FIX_GLOBAL_ENABLE      0x8000
+#define CLIP_HW_FIX_DEFAULT             0x8001
+
+/*
+ * These are the register default settings for TC B1
+ * They are used for the undocumented register override feature
+ * when en_reg_override=1
+ */
+#define DISP_ARB                0x00003232
+#define FIFO_WATERMARK_1        0x3f8f0404
+#define FIFO_WATERMARK_2        0x04040f04
+#define FIFO_WATERMARK_3        0x00000000
+#define FIFO_WATERMARK_4        0x04040404
+#define FIFO_WATERMARK_5        0x04040404
+#define FIFO_WATERMARK_6        0x00000078
+#define GVD_HP_CONTROL          0x102003f2
+#define DISP_CHICKENBITS        0x0000c040
+#define BCHICKENBITS            0xffe32004
+#define BWFLUSH                 0x00000408
+
 typedef struct _tnc_wa_timing_t{
 	short htotal;
 	short delta;
diff --git a/drivers/gpu/drm/emgd/emgd/include/tnc/instr.h b/drivers/gpu/drm/emgd/emgd/include/tnc/instr.h
index bbaff60..14bf85f 100644
--- a/drivers/gpu/drm/emgd/emgd/include/tnc/instr.h
+++ b/drivers/gpu/drm/emgd/emgd/include/tnc/instr.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: instr.h
- * $Revision: 1.5 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -38,9 +38,3 @@
 #include<plb/instr.h>
 
 #endif
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: instr.h,v 1.5 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/tnc/instr.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/tnc/mi.h b/drivers/gpu/drm/emgd/emgd/include/tnc/mi.h
index 4b2df7c..2bb8c23 100644
--- a/drivers/gpu/drm/emgd/emgd/include/tnc/mi.h
+++ b/drivers/gpu/drm/emgd/emgd/include/tnc/mi.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: mi.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/tnc/regs.h b/drivers/gpu/drm/emgd/emgd/include/tnc/regs.h
index fea7979..b6f5b1e 100644
--- a/drivers/gpu/drm/emgd/emgd/include/tnc/regs.h
+++ b/drivers/gpu/drm/emgd/emgd/include/tnc/regs.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: regs.h
- * $Revision: 1.11 $
+ * $Revision: 1.15 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -178,7 +178,7 @@
 #define GR07           0x07   /* Color Don't Care Register */
 #define GR08           0x08   /* Bit Mask Register */
 #define GR10           0x10   /* Address Mapping */
-#define PAGING_TARGET  BIT2 + BIT1 /* 00 = Local/Stolen, 01 = Memory mapped regs */
+#define PAGING_TARGET  BIT2 + BIT1 /* 00 = Local/Stolen, 01 = Mem mapped regs */
 #define PAGE_MODE      BIT0   /* Page Map allow access to all FB mem */
 #define GR11           0x11   /* Page Selector */
 #define	GR18           0x18   /* Software Flag */
@@ -470,13 +470,6 @@
 /* Not available in Atom E6xx */
 /* #define P3D_CG_DIS      0x06204 */ /* Clock Gating Disable */
 
-#define DSP_ARB         0x70030
-#define FW_1            0x70034
-#define FW_2            0x70038
-#define FW_3            0x7003C
-#define FW_4            0x70050
-#define FW_5            0x70054
-#define FW_6            0x70058
 
 /*-----------------------------------------------------------------------------
  * Display Palette Register Definitions (0A000h - 0AFFFh)
@@ -581,18 +574,35 @@
 #define PIPEAGCMAXBLU          0x70018  /* Pipe A Gamma Correct. Max Blue */
 #define PIPEA_STAT             0x70024  /* Pipe A Display Status */
 #define PIPEA_DISP_ARB_CTRL    0x70030  /* Display Arbitration Control */
+#define FW_1                   0x70034
+#define FW_2                   0x70038
+#define FW_3                   0x7003C
+#define PIPEA_FRAME_HIGH       0x70040  /* Pipe A Frame Count High */
+#define PIPEA_FRAME_PIXEL      0x70044  /* Pipe A Frame Cnt Low & pixel count */
+#define FW_4                   0x70050
+#define FW_5                   0x70054
+#define FW_6                   0x70058
+
+#define PIPE_PIXEL_MASK        0x00ffffff
+#define PIPE_FRAME_HIGH_MASK   0x0000ffff
+#define PIPE_FRAME_LOW_MASK    0xff000000
+#define PIPE_FRAME_LOW_SHIFT   24
+
 
 /*-----------------------------------------------------------------------------
  * Display Pipeline B Register ( 71000h - 71024h )
  *---------------------------------------------------------------------------*/
-#define PIPEB_SCANLINE_COUNT   0x71000 /* Pipe B Disp Scan Line Count Register */
-#define PIPEB_SCANLINE_COMPARE 0x71004 /* Pipe B Disp Scan Line Count Range Compare */
-#define PIPEB_CONF             0x71008 /* Pipe B Pixel Pipeline Config Register */
+#define PIPEB_SCANLINE_COUNT   0x71000 /* Pipe B Disp Scan Line Count Reg */
+#define PIPEB_SCANLINE_COMPARE 0x71004 /* Pipe B Disp Scan Line Cnt Range Cmp */
+#define PIPEB_CONF             0x71008 /* Pipe B Pixel Pipeline Config Reg */
 #define PIPEBGCMAXRED          0x71010 /* Pipe B Gamma Correct. Max Red */
 #define PIPEBGCMAXGRN          0x71014 /* Pipe B Gamma Correct. Max Green */
 #define PIPEBGCMAXBLU          0x71018 /* Pipe B Gamma Correct. Max Blue */
 #define PIPEB_STAT             0x71024 /* Display Status Select Register */
-#define PROG_STALL	       0x6102C /* Programmable cDVO Stall Register */
+#define PROG_STALL             0x6102C /* Programmable cDVO Stall Register */
+#define PIPEB_FRAME_HIGH       0x71040 /* Pipe B Frame Count High */
+#define PIPEB_FRAME_PIXEL      0x71044 /* Pipe B Frame Cnt Low and pixel cnt */
+
 
 #define VBLANK_EVN_STS_EN   BIT20
 #define VBLANK_ODD_STS_EN   BIT21
@@ -642,8 +652,8 @@
 #define DPLL_MISC	  	  0x06304
 #define DPLL_MONITOR	  	  0x06308
 #define DPLL_MONITOR2	  	  0x0630C
-#define DPLL_TEST_COMPARATOR	  0x06310
-#define SDVOB_TX_LSKEW		  0x06314
+#define DPLL_TEST_COMPARATOR      0x06310
+#define SDVOB_TX_LSKEW	          0x06314
 
 /*-----------------------------------------------------------------------------
  * Hardware Cursor Register Definitions (70080h - 7009Ch)
@@ -696,6 +706,16 @@
 #define DSPBTILEOFF     0x711A4  /* Display B Tiled Offset */
 
 /*-----------------------------------------------------------------------------
+ * Source Format Definition for DSPxCNTR
+ *---------------------------------------------------------------------------*/
+#define DSPxCNTR_ARGB_8888			0x1C000000
+#define DSPxCNTR_RGB_8888			0x18000000
+#define DSPxCNTR_RGB_565			0x14000000
+#define DSPxCNTR_RGB_555			0x10000000
+#define DSPxCNTR_RGB_8				0x08000000
+#define DSPxCNTR_SRC_FMT_MASK			0x3C000000 /*mask for above*/
+
+/*-----------------------------------------------------------------------------
  * Display Plane C Register Definitions (72180h - 72188h)
  *---------------------------------------------------------------------------*/
 #define DSPCCNTR        0x72180  /* Display Plane C */
@@ -763,7 +783,7 @@
 /*-----------------------------------------------------------------------------
  * VBIOS Software flags  00h - 0Fh
  *---------------------------------------------------------------------------*/
-#define KFC             0x70400  /* Chicken Bit */
+#define DSP_CHICKENBITS	0x70400  /* Chicken Bit */
 #define SWFABASE        0x70410  /* Software flags A Base Addr */
 #define SWF00           0x70410
 #define SWF01           0x70414
@@ -866,9 +886,3 @@
 
 #endif /* _REGS_H_ */
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: regs.h,v 1.11 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/tnc/regs.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/tnc/sgx.h b/drivers/gpu/drm/emgd/emgd/include/tnc/sgx.h
index af77736..c43d490 100644
--- a/drivers/gpu/drm/emgd/emgd/include/tnc/sgx.h
+++ b/drivers/gpu/drm/emgd/emgd/include/tnc/sgx.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: sgx.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/tnc/state3d.h b/drivers/gpu/drm/emgd/emgd/include/tnc/state3d.h
index e3938b1..b32aea2 100644
--- a/drivers/gpu/drm/emgd/emgd/include/tnc/state3d.h
+++ b/drivers/gpu/drm/emgd/emgd/include/tnc/state3d.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: state3d.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/tnc/state3d_plb.h b/drivers/gpu/drm/emgd/emgd/include/tnc/state3d_plb.h
index 6b28eb2..fd5e628 100644
--- a/drivers/gpu/drm/emgd/emgd/include/tnc/state3d_plb.h
+++ b/drivers/gpu/drm/emgd/emgd/include/tnc/state3d_plb.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: state3d_plb.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/include/topaz.h b/drivers/gpu/drm/emgd/emgd/include/topaz.h
index 5dac3e4..e14b46c 100644
--- a/drivers/gpu/drm/emgd/emgd/include/topaz.h
+++ b/drivers/gpu/drm/emgd/emgd/include/topaz.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: topaz.h
- * $Revision: 1.14 $
+ * $Revision: 1.16 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -205,6 +205,5 @@ int topaz_init_tnc(unsigned long wb_offset, void *wb_addr, void *firm_addr);
 int topaz_get_fence_id(igd_context_t *context, unsigned long *fence_id);
 int topaz_flush_tnc(igd_context_t *context);
 int topaz_get_frame_skip(igd_context_t *context, unsigned long *frame_skip);
-int topaz_sync_surface(igd_context_t *context, unsigned long *sync_done, int *last_frame);
 
 #endif
diff --git a/drivers/gpu/drm/emgd/emgd/include/utils.h b/drivers/gpu/drm/emgd/emgd/include/utils.h
index faa5b1b..18fe9c3 100644
--- a/drivers/gpu/drm/emgd/emgd/include/utils.h
+++ b/drivers/gpu/drm/emgd/emgd/include/utils.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: utils.h
- * $Revision: 1.9 $
+ * $Revision: 1.11 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -172,9 +172,3 @@ extern void write_mmio_reg_tnc(unsigned long port_type, unsigned long reg,
 
 #endif // _UTILS_H_
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: utils.h,v 1.9 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/include/utils.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/include/vga.h b/drivers/gpu/drm/emgd/emgd/include/vga.h
index 776d9ad..1c9b782 100644
--- a/drivers/gpu/drm/emgd/emgd/include/vga.h
+++ b/drivers/gpu/drm/emgd/emgd/include/vga.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: vga.h
- * $Revision: 1.6 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -34,15 +34,24 @@
 
 #include <igd_vga.h>
 #include <io.h>
+#include "drm_emgd_private.h"
 
 extern void program_pipe_vga(
 	igd_display_context_t *display,
 	igd_timing_info_t *timings);
 
+extern void kms_program_pipe_vga(
+	emgd_crtc_t *emgd_crtc,
+	igd_timing_info_t *timings);
+
 extern void program_plane_vga(
 	igd_display_context_t *display,
 	igd_timing_info_t *timings);
 
+extern void kms_program_plane_vga(
+	unsigned char *mmio,
+	igd_timing_info_t *timings);
+
 extern unsigned long get_vga_color(int i);
 
 extern void set_256_palette(unsigned char *mmio);
diff --git a/drivers/gpu/drm/emgd/emgd/oal/src/math_fix.c b/drivers/gpu/drm/emgd/emgd/oal/src/math_fix.c
index 4eafe9e..84e5811 100644
--- a/drivers/gpu/drm/emgd/emgd/oal/src/math_fix.c
+++ b/drivers/gpu/drm/emgd/emgd/oal/src/math_fix.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: math_fix.c
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/oal/src/memmap.c b/drivers/gpu/drm/emgd/emgd/oal/src/memmap.c
index 0592d24..2ee0812 100644
--- a/drivers/gpu/drm/emgd/emgd/oal/src/memmap.c
+++ b/drivers/gpu/drm/emgd/emgd/oal/src/memmap.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: memmap.c
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/oal/src/pci.c b/drivers/gpu/drm/emgd/emgd/oal/src/pci.c
index 17916c1..ff8a28c 100644
--- a/drivers/gpu/drm/emgd/emgd/oal/src/pci.c
+++ b/drivers/gpu/drm/emgd/emgd/oal/src/pci.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: pci.c
- * $Revision: 1.7 $
+ * $Revision: 1.8 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/pal/Makefile.include b/drivers/gpu/drm/emgd/emgd/pal/Makefile.include
index 91f9afa..c312c51 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/Makefile.include
+++ b/drivers/gpu/drm/emgd/emgd/pal/Makefile.include
@@ -1,8 +1,8 @@
 #----------------------------------------------------------------------------
 # Filename: Makefile.include
-# $Revision: 1.2 $
+# $Revision: 1.3 $
 #----------------------------------------------------------------------------
-# Copyright  2002-2010, Intel Corporation.
+# Copyright (c) 2002-2010, Intel Corporation.
 #
 # Permission is hereby granted, free of charge, to any person obtaining a copy
 # of this software and associated documentation files (the "Software"), to deal
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.c b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.c
new file mode 100644
index 0000000..7c7e708
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.c
@@ -0,0 +1,2349 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036.c
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+
+
+
+#include "ch7036.h"
+#include "ch7036_iic.h"
+#include "asm/div64.h"
+#include <linux/kernel.h>
+
+
+
+static uint32 g_nLastError;
+
+
+
+
+static ch_bool convert_pll1n1_div(ch_bool pll1n1_to_div, uint8* pll1n1_addr, uint8* div_addr);
+static ch_bool convert_pll1n2_div(ch_bool pll1n2_to_div, uint8* pll1n2_addr, uint8* div_addr);
+static ch_bool convert_pll1n3_div(ch_bool pll1n3_to_div, uint8* pll1n3_addr, uint8* div_addr);
+static ch_bool convert_pll2n5_div(ch_bool pll2n5_to_div, uint8* pll2n5_addr, uint8* div_addr);
+static ch_bool convert_pll2n6_div(ch_bool pll2n6_to_div, uint8* pll2n6_addr, uint8* div_addr);
+static ch_bool convert_pll2n7_div(ch_bool pll2n7_to_div, uint8* pll2n7_addr, uint8* div_addr);
+static ch_bool convert_pll3n8_div(ch_bool pll3n8_to_div, uint8* pll3n8_addr, uint8* div_addr);
+static ch_bool convert_dmxtal_div(ch_bool dmxtal_to_div, uint8* dmxtal_addr, uint8* div_addr);
+
+
+static ch_bool set_input_info(INPUT_INFO* pInput_Info);
+
+
+static ch_bool set_output_info(OUTPUT_INFO* pOutput_Info);
+
+
+static ch_bool set_prefer_info(PREFER_INFO* pPrefer_Info);
+
+
+static ch_bool cal_and_set_clk_pll(DEV_CONTEXT* pDevContext);
+
+
+static ch_bool cal_and_set_scaler(DEV_CONTEXT* pDevContext);
+
+
+static ch_bool cal_and_set_power(DEV_CONTEXT* pDevContext);
+
+
+static ch_bool post_cal_and_set(DEV_CONTEXT* pDevContext);
+
+
+extern void ch7036_set_power_lvds(DEV_CONTEXT* pDevContext);
+extern void ch7036_set_power_hdmi(DEV_CONTEXT* pDevContext);
+extern void ch7036_set_power_crt(DEV_CONTEXT* pDevContext);
+
+
+#define  DOUBLE_TO_INT		1000
+
+
+
+
+
+
+
+ch_bool DeviceSetPower(DEV_CONTEXT* pDevContext, unsigned long flags)
+{
+
+	switch (flags) {
+		default:
+			ch7036_set_power_crt(pDevContext);
+			ch7036_set_power_hdmi(pDevContext);
+			ch7036_set_power_lvds(pDevContext);
+			break;
+	}
+
+	return ch_true;
+
+}
+
+ch_bool DevicePrepare(DEV_CONTEXT* pDevContext)
+{
+	uint32 C;
+	uint32 hao_t, vao_t, vai_t, val_t;
+	uint32 hai_down;
+	uint32 hai_sdram;
+	uint32 lnsel;
+	uint32 intlc;
+	uint32 blk_h;
+	uint32 fba_inc;
+	uint32 bandwidth;
+
+	uint32 frame_rate_in, frame_rate_out;
+	uint32  r;
+
+	INPUT_INFO* pInput_Info = pDevContext->pInput_Info;
+	OUTPUT_INFO* pOutput_Info = pDevContext->pOutput_Info;
+	PREFER_INFO* pPrefer_Info = pDevContext->pPrefer_Info;
+
+
+	g_nLastError = ERR_NO_ERROR;
+
+
+	I2CWrite(pDevContext,0x03, 0x04);
+	pDevContext->DeviceID = I2CRead(pDevContext,0x50);
+	if(pDevContext->DeviceID != 0x56)
+	{
+		g_nLastError = ERR_DEVICE_NO_EXIST;
+		return ch_false;
+	}
+
+
+
+	if(pInput_Info->timing.ha % 2)
+	{
+		pInput_Info->timing.ha--;
+	}
+	if(pInput_Info->timing.va % 2)
+	{
+		pInput_Info->timing.va--;
+	}
+
+
+
+	if(pPrefer_Info->dat16_32b)
+	{
+		C = 100;
+	}
+	else if(pPrefer_Info->true24)
+	{
+		C = 100;
+	}
+	else
+	{
+		C = (pPrefer_Info->true_com) ? 75 : 50;
+	}
+	if(pOutput_Info->ds_percent_h)
+	{
+		hao_t = pOutput_Info->timing.ha * (100 - pOutput_Info->ds_percent_h) / 100;
+	}
+	else
+	{
+		hao_t = pOutput_Info->timing.ha;
+	}
+	if(pOutput_Info->ds_percent_v)
+	{
+		vao_t = pOutput_Info->timing.va * (100 - pOutput_Info->ds_percent_v) / 100;
+	}
+	else
+	{
+		vao_t = pOutput_Info->timing.va;
+	}
+	hao_t = hao_t + (hao_t % 2);
+	vao_t = vao_t + (vao_t % 2);
+	hai_down = pInput_Info->timing.ha;
+	if(hai_down > hao_t && pOutput_Info->rotate != ROTATE_90 && pOutput_Info->rotate != ROTATE_270)
+	{
+		hai_down = hao_t;
+	}
+
+	if(pOutput_Info->rotate == ROTATE_90 || pOutput_Info->rotate == ROTATE_270)
+	{
+		val_t = 720;
+	}
+	else
+	{
+		if(pPrefer_Info->dat16_32b)
+		{
+			val_t = 720;
+		}
+		else
+		{
+			val_t = pPrefer_Info->true24 ? 720 : 1440;
+		}
+	}
+	if(hai_down > val_t && (pOutput_Info->rotate != ROTATE_NO || pOutput_Info->h_flip || pOutput_Info->v_flip))
+	{
+		hai_down = val_t;
+	}
+
+	if(pOutput_Info->channel & CHANNEL_HDMI)
+	{
+
+		switch(pOutput_Info->hdmi_fmt.format_index)
+		{
+		case  5:
+		case  6:
+		case  7:
+		case 10:
+		case 11:
+		case 20:
+		case 21:
+		case 22:
+		case 25:
+		case 26:
+			intlc = 1;
+			break;
+		default:
+			intlc = 0;
+			break;
+		}
+	}
+
+
+	if(pOutput_Info->channel & CHANNEL_VGA)
+	{
+       intlc = 0;
+	}
+
+	val_t = intlc ? (vao_t / 2) : vao_t;
+	if(pOutput_Info->rotate == ROTATE_90 || pOutput_Info->rotate == ROTATE_270)
+	{
+		if(hai_down <= val_t)
+			lnsel = 3;
+		else
+			lnsel = 1;
+	}
+	else
+	{
+		if(pInput_Info->timing.va <= val_t)
+			lnsel = 3;
+		else
+			lnsel = 1;
+	}
+	bandwidth = (pInput_Info->rx_clk_khz + pOutput_Info->uclk_khz * pInput_Info->timing.ha / hao_t * (4 - lnsel)) / 85 * C;
+	if(bandwidth > MEM_CLK_FREQ_MAX)
+	{
+		if(lnsel >= 2)
+		{
+			g_nLastError = ERR_BANDWIDTH_OVERFLOW;
+			return ch_false;
+		}
+
+		lnsel++;
+
+
+
+
+
+
+		if(pInput_Info->rx_clk_khz >= 75428 && pOutput_Info->uclk_khz >= 94500)
+			lnsel++;
+
+		bandwidth = (pInput_Info->rx_clk_khz + pOutput_Info->uclk_khz * pInput_Info->timing.ha / hao_t * (4 - lnsel)) / 85 * C;
+		if(bandwidth > MEM_CLK_FREQ_MAX)
+		{
+			g_nLastError = ERR_BANDWIDTH_OVERFLOW;
+			return ch_false;
+		}
+		pPrefer_Info->scale_line_adjust = 1;
+	}
+
+
+	if(pOutput_Info->rotate == ROTATE_90 || pOutput_Info->rotate == ROTATE_270)
+	{
+		val_t = 100;
+	}
+	else
+	{
+		if(pPrefer_Info->dat16_32b)
+		{
+			val_t = 100;
+		}
+		else if(pPrefer_Info->true24)
+		{
+			val_t = 100;
+		}
+		else
+		{
+			val_t = pPrefer_Info->true_com ? 75 : 50;
+		}
+	}
+	if(val_t == 75)
+	{
+		hai_sdram = (hai_down / 4) * 3 + (hai_down % 4);
+	}
+	else
+	{
+		hai_sdram = hai_down * val_t / 100;
+	}
+	if(pOutput_Info->rotate != ROTATE_NO || pOutput_Info->h_flip || pOutput_Info->v_flip)
+	{
+		blk_h = 45;
+	}
+	else if(hai_sdram <= 720 && pInput_Info->timing.va <= 720)
+	{
+		blk_h = 45;
+	}
+	else
+	{
+		blk_h = hai_sdram / 16;
+		blk_h = (hai_sdram % 16) ? (blk_h + 1) : blk_h;
+	}
+
+
+	if((pOutput_Info->rotate == ROTATE_90 || pOutput_Info->rotate == ROTATE_270) && pPrefer_Info->true24 == 0 && pPrefer_Info->true_com == 0 && pPrefer_Info->dat16_32b == 0)
+	{
+		vai_t = pInput_Info->timing.va / 2;
+	}
+	else
+	{
+		vai_t = pInput_Info->timing.va;
+	}
+	val_t = (vai_t % 16) ? (vai_t / 16 + 1) : (vai_t / 16);
+	fba_inc = blk_h * val_t;
+
+
+	frame_rate_in = ((pInput_Info->rx_clk_khz * 10000) / pInput_Info->timing.ht) * 10 / pInput_Info->timing.vt;
+	frame_rate_out = ((pOutput_Info->uclk_khz * 10000) / pOutput_Info->timing.ht) * 10 / pOutput_Info->timing.vt;
+	r = DOUBLE_TO_INT*frame_rate_in / frame_rate_out;
+
+
+	if(pPrefer_Info->dat16_32b)
+	{
+		if(pPrefer_Info->true24)
+		{
+			g_nLastError = ERR_NO_SUPPORT_TRUE24;
+			return ch_false;
+		}
+		if(pPrefer_Info->true_com)
+		{
+			g_nLastError = ERR_NO_SUPPORT_TRUECOM;
+			return ch_false;
+		}
+		if(pOutput_Info->rotate == ROTATE_NO && pOutput_Info->h_flip == 0 && pOutput_Info->v_flip == 0)
+		{
+			if(fba_inc > FBA_INC_MAX)
+			{
+
+
+
+               if (( (DOUBLE_TO_INT/2) <= r) && ( r <= DOUBLE_TO_INT))
+			   {
+					if( ((4096*DOUBLE_TO_INT) / fba_inc) < (2*DOUBLE_TO_INT-r) )
+					{
+						g_nLastError = ERR_RESOLUTION_OVERFLOW;
+						return ch_false;
+					}
+			   }
+
+               if (( DOUBLE_TO_INT < r) && ( r <= (2*DOUBLE_TO_INT)))
+			   {
+					if( ((4096*DOUBLE_TO_INT) / fba_inc)  <
+						(2*DOUBLE_TO_INT - (DOUBLE_TO_INT*DOUBLE_TO_INT)/r) )
+					{
+						g_nLastError = ERR_RESOLUTION_OVERFLOW;
+						return ch_false;
+					}
+			   }
+
+			}
+		}
+		else if(pOutput_Info->rotate != ROTATE_NO)
+		{
+			if(pInput_Info->timing.va > 720)
+			{
+				g_nLastError = ERR_ROTATION_WITH_VAI;
+				return ch_false;
+			}
+		}
+		else
+		{
+			if(pInput_Info->timing.va > 720)
+			{
+				g_nLastError = ERR_FLIP_WITH_VAI;
+				return ch_false;
+			}
+		}
+	}
+
+
+	if(pPrefer_Info->dat16_32b == 0)
+	{
+		if(pOutput_Info->rotate == ROTATE_NO && pOutput_Info->h_flip == 0 && pOutput_Info->v_flip == 0)
+		{
+			if(fba_inc > FBA_INC_MAX)
+			{
+
+                if (( (DOUBLE_TO_INT/2) <= r) && ( r <= DOUBLE_TO_INT))
+			    {
+					if( ((4096*DOUBLE_TO_INT) / fba_inc) < (2*DOUBLE_TO_INT-r) )
+					{
+						g_nLastError = ERR_RESOLUTION_OVERFLOW;
+						return ch_false;
+					}
+			    }
+
+                if (( DOUBLE_TO_INT < r) && ( r <= (2*DOUBLE_TO_INT)))
+			    {
+					if( ((4096*DOUBLE_TO_INT) / fba_inc)  <
+						(2*DOUBLE_TO_INT - (DOUBLE_TO_INT*DOUBLE_TO_INT)/r) )
+					{
+						g_nLastError = ERR_RESOLUTION_OVERFLOW;
+						return ch_false;
+					}
+			    }
+
+
+				if(pPrefer_Info->true24)
+				{
+					g_nLastError = ERR_NO_SUPPORT_TRUE24;
+					return ch_false;
+				}
+				if(pPrefer_Info->true_com)
+				{
+					g_nLastError = ERR_NO_SUPPORT_TRUECOM;
+					return ch_false;
+				}
+				g_nLastError = ERR_RESOLUTION_OVERFLOW;
+				return ch_false;
+			}
+		}
+		if(pOutput_Info->rotate == ROTATE_180)
+		{
+			if(pPrefer_Info->true_com)
+			{
+				g_nLastError = ERR_NO_SUPPORT_TRUECOM;
+				return ch_false;
+			}
+			if(pPrefer_Info->true24)
+			{
+				if(pInput_Info->timing.va > 720)
+				{
+					g_nLastError = ERR_NO_SUPPORT_TRUE24;
+					return ch_false;
+				}
+			}
+			else
+			{
+				if(pInput_Info->timing.va > 720)
+				{
+					g_nLastError = ERR_ROTATION_WITH_VAI;
+					return ch_false;
+				}
+			}
+		}
+		if(pOutput_Info->h_flip || pOutput_Info->v_flip)
+		{
+			if(pPrefer_Info->true_com)
+			{
+				g_nLastError = ERR_NO_SUPPORT_TRUECOM;
+				return ch_false;
+			}
+			if(pInput_Info->timing.va > 720)
+			{
+				g_nLastError = ERR_FLIP_WITH_VAI;
+				return ch_false;
+			}
+		}
+		if(pOutput_Info->rotate == ROTATE_90 || pOutput_Info->rotate == ROTATE_270)
+		{
+			if(pPrefer_Info->true_com)
+			{
+				g_nLastError = ERR_NO_SUPPORT_TRUECOM;
+				return ch_false;
+			}
+			if(pPrefer_Info->true24)
+			{
+				if(pInput_Info->timing.va > 720)
+				{
+					g_nLastError = ERR_NO_SUPPORT_TRUE24;
+					return ch_false;
+				}
+			}
+			else
+			{
+				if(pInput_Info->timing.va > 1440)
+				{
+					g_nLastError = ERR_ROTATION_WITH_VAI;
+					return ch_false;
+				}
+			}
+		}
+	}
+
+
+
+	if(pPrefer_Info->true24 || pPrefer_Info->true_com)
+	{
+		pPrefer_Info->dither_filter_enable = 0;
+	}
+
+
+
+
+	iic_reset();
+
+
+	if(pOutput_Info->channel & CHANNEL_HDMI || pOutput_Info->channel & CHANNEL_VGA)
+	{
+
+		iic_write(0x03, 0x01);
+		iic_write(0x07, 0x7E);
+		iic_write(0x09, 0x0B);
+		iic_write(0x03, 0x00);
+		iic_write_ex(STOP, 1);
+	}
+
+	return ch_true;
+}
+
+ch_bool DeviceConfig(DEV_CONTEXT* pDevContext)
+{
+	if(!set_input_info(pDevContext->pInput_Info))
+		return ch_false;
+
+	if(!set_output_info(pDevContext->pOutput_Info))
+		return ch_false;
+
+	if(!set_prefer_info(pDevContext->pPrefer_Info))
+		return ch_false;
+
+	if(!cal_and_set_clk_pll(pDevContext))
+		return ch_false;
+
+	if(!cal_and_set_scaler(pDevContext))
+		return ch_false;
+
+	if(!cal_and_set_power(pDevContext))
+		return ch_false;
+
+	return ch_true;
+}
+
+ch_bool DeviceRunning(DEV_CONTEXT* pDevContext)
+{
+	uint8 val_t;
+	uint8 reg = 0x00;
+	OUTPUT_INFO* pOutput_Info = pDevContext->pOutput_Info;
+	PREFER_INFO* pPrefer_Info = pDevContext->pPrefer_Info;
+
+	uint8 REFDLY = pPrefer_Info->pll_ref_dly;
+	uint8 FBDLY = pPrefer_Info->pll_ref_fbdly;
+	uint8 TXDRV_IT = pPrefer_Info->lvds_txdrv_ctrl;
+
+
+	DeviceReset(pDevContext);
+
+
+
+	DeviceSetup(pDevContext);
+
+
+	I2CWrite(pDevContext,0x03, 0x01);
+
+
+
+
+	reg = I2CRead(pDevContext,0x24) & 0xFD;
+	I2CWrite(pDevContext,0x24, reg);
+
+	I2CWrite(pDevContext,0x03, 0x04);
+	reg = I2CRead(pDevContext,0x66);
+    reg = reg & 0x1F;
+	reg = reg | ((uint8)REFDLY << 5);
+	I2CWrite(pDevContext,0x66, reg);
+
+	I2CWrite(pDevContext,0x03, 0x04);
+	reg = I2CRead(pDevContext,0x66);
+    reg = reg & 0xE3;
+	reg = reg | ((uint8)FBDLY << 2);
+	I2CWrite(pDevContext,0x66, reg);
+
+    I2CWrite(pDevContext,0x03, 0x04);
+	reg = I2CRead(pDevContext,0x68) & 0xF0;
+    reg = reg | ((uint8)TXDRV_IT);
+	I2CWrite(pDevContext,0x68, reg);
+
+
+
+
+
+
+
+       I2CWrite(pDevContext,0x03, 0x01);
+	   reg = I2CRead(pDevContext,0x0D);
+	   if((pPrefer_Info->eye_dri_pll_rlf >= 0) && (pPrefer_Info->eye_dri_pll_rlf <= 3))
+ 	      reg = (reg & 0x9F) | (pPrefer_Info->eye_dri_pll_rlf << 5);
+	   I2CWrite(pDevContext,0x0D, reg);
+
+	   I2CWrite(pDevContext,0x03, 0x01);
+	   reg = I2CRead(pDevContext,0x0C);
+	   if((pPrefer_Info->eye_dri_pll_cp >= 0) && (pPrefer_Info->eye_dri_pll_cp <= 3))
+ 	      reg = (reg & 0x3F) | (pPrefer_Info->eye_dri_pll_cp << 6);
+	   I2CWrite(pDevContext,0x0C, reg);
+
+	   I2CWrite(pDevContext,0x03, 0x01);
+	   reg = I2CRead(pDevContext,0x0B);
+	   if((pPrefer_Info->eye_dri_damp >= 0) && (pPrefer_Info->eye_dri_damp <= 7))
+ 	      reg = (reg & 0x1F) | (pPrefer_Info->eye_dri_damp << 5);
+	   I2CWrite(pDevContext,0x0B, reg);
+
+       I2CWrite(pDevContext,0x03, 0x01);
+	   reg = I2CRead(pDevContext,0x0A);
+	   if((reg & 0x01)==0x00)
+ 	      reg = (reg | 0x01);
+	   I2CWrite(pDevContext,0x0A, reg);
+
+       I2CWrite(pDevContext,0x03, 0x01);
+	   reg = I2CRead(pDevContext,0x0A);
+	   if((pPrefer_Info->eye_dri_demp >= 0) && (pPrefer_Info->eye_dri_demp <= 15))
+ 	      reg = (reg & 0xE1) | (pPrefer_Info->eye_dri_demp << 1);
+	   I2CWrite(pDevContext,0x0A, reg);
+
+	   I2CWrite(pDevContext,0x03, 0x01);
+	   reg = I2CRead(pDevContext,0x08);
+	   if((pPrefer_Info->eye_dacg >= 0) && (pPrefer_Info->eye_dacg <= 3))
+ 	      reg = (reg & 0x3F) | (pPrefer_Info->eye_dacg << 6);
+	   I2CWrite(pDevContext,0x08, reg);
+
+	   I2CWrite(pDevContext,0x03, 0x01);
+	   reg = I2CRead(pDevContext,0x0F);
+	   if((pPrefer_Info->eye_rdac >= 0) && (pPrefer_Info->eye_rdac <= 7))
+ 	      reg = (reg & 0xC7) | (pPrefer_Info->eye_rdac << 3);
+	   I2CWrite(pDevContext,0x0F, reg);
+
+	   I2CWrite(pDevContext,0x03, 0x04);
+	   reg = I2CRead(pDevContext,0x54);
+	   if((pPrefer_Info->eye_bgtrim >= 0) && (pPrefer_Info->eye_bgtrim <= 3))
+ 	      reg = (reg & 0xF3) | (pPrefer_Info->eye_bgtrim << 2);
+	   I2CWrite(pDevContext,0x54, reg);
+
+
+
+
+
+	if(pOutput_Info->channel & CHANNEL_HDMI || pOutput_Info->channel & CHANNEL_VGA)
+	{
+
+		if(!post_cal_and_set(pDevContext)){
+		   return ch_false;
+	    }
+
+
+		I2CWrite(pDevContext,0x03, 0x00);
+		val_t = I2CRead(pDevContext,0x0A);
+		I2CWrite(pDevContext,0x0A, val_t | 0x80);
+		I2CWrite(pDevContext,0x0A, val_t & 0x7F);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+		I2CWrite(pDevContext,0x03, 0x00);
+		val_t = I2CRead(pDevContext,0x0A);
+		I2CWrite(pDevContext,0x0A, val_t & 0xEF);
+
+
+
+	}
+
+	return ch_true;
+}
+
+uint32 GetLastErrorMessage()
+{
+	return g_nLastError;
+}
+
+
+
+ch_bool set_input_info(INPUT_INFO* pInput_Info)
+{
+
+	iic_write_ex(HTI, pInput_Info->timing.ht);
+	iic_write_ex(HAI, pInput_Info->timing.ha);
+	iic_write_ex(HOI, pInput_Info->timing.ho);
+	iic_write_ex(HWI, pInput_Info->timing.hw);
+	iic_write_ex(VTI, pInput_Info->timing.vt);
+	iic_write_ex(VAI, pInput_Info->timing.va);
+	iic_write_ex(VOI, pInput_Info->timing.vo);
+	iic_write_ex(VWI, pInput_Info->timing.vw);
+
+	iic_write_ex(RCLK, pInput_Info->rx_clk_khz);
+
+
+	switch(pInput_Info->pixel_fmt)
+	{
+		  case 0:
+			 iic_write_ex(DITHER_SEL0_SPP, 0);
+		     iic_write_ex(DITHER_SEL1_SPP, 0);
+			 break;
+		  case 1:
+			 iic_write_ex(DITHER_SEL0_SPP, 1);
+		     iic_write_ex(DITHER_SEL1_SPP, 0);
+			 break;
+		  case 2:
+			 iic_write_ex(DITHER_SEL0_SPP, 0);
+		     iic_write_ex(DITHER_SEL1_SPP, 1);
+			 break;
+		  case 3:
+			 iic_write_ex(DITHER_SEL0_SPP, 1);
+		     iic_write_ex(DITHER_SEL1_SPP, 1);
+			 break;
+		  default:
+			iic_write_ex(DITHER_SEL0_SPP, 0);
+		    iic_write_ex(DITHER_SEL1_SPP, 0);
+			break;
+	}
+
+
+
+	iic_write_ex(HSYNCP_SPP, pInput_Info->hs_pol);
+	iic_write_ex(VSYNCP_SPP, pInput_Info->vs_pol);
+
+	iic_write_ex(HPO_I, pInput_Info->hs_pol);
+	iic_write_ex(VPO_I, pInput_Info->vs_pol);
+	iic_write_ex(DEPO_I, pInput_Info->de_pol);
+
+	iic_write_ex(NP_INV0_SPP, (pInput_Info->data_ch_pol & (1 << 0)) ? 1 : 0);
+	iic_write_ex(NP_INV1_SPP, (pInput_Info->data_ch_pol & (1 << 1)) ? 1 : 0);
+	iic_write_ex(NP_INV2_SPP, (pInput_Info->data_ch_pol & (1 << 2)) ? 1 : 0);
+	iic_write_ex(NP_INV3_SPP, (pInput_Info->data_ch_pol & (1 << 3)) ? 1 : 0);
+
+	iic_write_ex(LVDS_IN_ORDER, pInput_Info->data_ch_invert);
+
+	iic_write_ex(I2S_SPDIFB, pInput_Info->audio_type);
+	if(pInput_Info->audio_type == AUDIO_I2S) {
+		iic_write_ex(I2SPOL, pInput_Info->i2s_pol);
+		iic_write_ex(I2S_LENGTH, pInput_Info->i2s_len);
+		iic_write_ex(I2SFMT, pInput_Info->i2s_fmt);
+	}
+
+	return ch_true;
+}
+
+ch_bool set_output_info(OUTPUT_INFO* pOutput_Info)
+{
+	uint8 lvds0_seq, lvds1_seq, lvds2_seq, lvds3_seq, lvdsclk_seq;
+	uint8 lvds0_pol, lvds1_pol, lvds2_pol, lvds3_pol, lvdsclk_pol;
+	uint8 hpo_o, vpo_o, depo_o;
+	uint8 hd_dvib, intlc, copy, hd_lv_pol, hd_lv_seq, hdmi_lvds_sel, hsp, vsp, m1m0, c1c0, vic;
+	uint32 hao_down, vao_down;
+
+
+	LVDS_FMT* pLvdsFmt = &pOutput_Info->lvds_fmt;
+	HDMI_FMT* pHdmiFmt = &pOutput_Info->hdmi_fmt;
+	VGA_FMT* pVgaFmt = &pOutput_Info->vga_fmt;
+
+
+
+
+
+
+
+
+
+
+
+	if(pOutput_Info->channel & CHANNEL_VGA || pOutput_Info->channel & CHANNEL_HDMI) {
+		iic_write_ex(VP,pOutput_Info->v_position);
+		iic_write_ex(HP,pOutput_Info->h_position);
+	}
+
+
+
+	if(pOutput_Info->channel & CHANNEL_HDMI || pOutput_Info->channel & CHANNEL_VGA)
+	{
+		iic_write_ex(HTO, pOutput_Info->timing.ht);
+		iic_write_ex(HAO, pOutput_Info->timing.ha);
+		iic_write_ex(HOO_HDMI, pOutput_Info->timing.ho);
+		iic_write_ex(HWO_HDMI, pOutput_Info->timing.hw);
+		iic_write_ex(VTO, pOutput_Info->timing.vt);
+		iic_write_ex(VAO, pOutput_Info->timing.va);
+		iic_write_ex(VOO_HDMI, pOutput_Info->timing.vo);
+		iic_write_ex(VWO_HDMI, pOutput_Info->timing.vw);
+
+		iic_write_ex(UCLK, pOutput_Info->uclk_khz);
+		iic_write_ex(ROTATE, pOutput_Info->rotate);
+		iic_write_ex(HFLIP, pOutput_Info->h_flip);
+		iic_write_ex(VFLIP, pOutput_Info->v_flip);
+
+		hao_down = pOutput_Info->timing.ha * (100 - pOutput_Info->ds_percent_h) / 100;
+		hao_down = hao_down + (hao_down % 2);
+		vao_down = pOutput_Info->timing.va * (100 - pOutput_Info->ds_percent_v) / 100;
+		vao_down = vao_down + (vao_down % 2);
+		if(pOutput_Info->ds_percent_h || pOutput_Info->ds_percent_v)
+		{
+			iic_write_ex(SCAN_EN, 1);
+			iic_write_ex(HAO_SCL, hao_down);
+			iic_write_ex(VAO_SCL, vao_down);
+		}
+
+		iic_write_ex(ROTATE, pOutput_Info->rotate);
+		iic_write_ex(HFLIP, pOutput_Info->h_flip);
+		iic_write_ex(VFLIP, pOutput_Info->v_flip);
+	}
+
+	if(pOutput_Info->channel & CHANNEL_LVDS)
+	{
+
+		lvds0_seq = (pLvdsFmt->channel_swap >>  0) & 0xF;
+		lvds1_seq = (pLvdsFmt->channel_swap >>  4) & 0xF;
+		lvds2_seq = (pLvdsFmt->channel_swap >>  8) & 0xF;
+		lvds3_seq = (pLvdsFmt->channel_swap >> 12) & 0xF;
+		lvdsclk_seq = (pLvdsFmt->channel_swap >>  16) & 0xF;
+		iic_write_ex(LVDS0_SEQ_SPP, lvds0_seq);
+		iic_write_ex(LVDS1_SEQ_SPP, lvds1_seq);
+		iic_write_ex(LVDS2_SEQ_SPP, lvds2_seq);
+		iic_write_ex(LVDS3_SEQ_SPP, lvds3_seq);
+		iic_write_ex(LVDSCLK_SEQ_SPP, lvdsclk_seq);
+
+		lvds0_pol = (pLvdsFmt->channel_pol >> 0) & 0x1;
+		lvds1_pol = (pLvdsFmt->channel_pol >> 1) & 0x1;
+		lvds2_pol = (pLvdsFmt->channel_pol >> 2) & 0x1;
+		lvds3_pol = (pLvdsFmt->channel_pol >> 3) & 0x1;
+		lvdsclk_pol = (pLvdsFmt->channel_pol >> 4) & 0x1;
+		iic_write_ex(LVDS0_POL_SPP, lvds0_pol);
+		iic_write_ex(LVDS1_POL_SPP, lvds1_pol);
+		iic_write_ex(LVDS2_POL_SPP, lvds2_pol);
+		iic_write_ex(LVDS3_POL_SPP, lvds3_pol);
+		iic_write_ex(LVDSCLK_POL_SPP, lvdsclk_pol);
+
+
+		switch(pLvdsFmt->pixel_fmt){
+		  case 0:
+			 iic_write_ex(DITHER_SEL0_SPP, 0);
+		     iic_write_ex(DITHER_SEL1_SPP, 0);
+			 break;
+		  case 1:
+			 iic_write_ex(DITHER_SEL0_SPP, 1);
+		     iic_write_ex(DITHER_SEL1_SPP, 0);
+			 break;
+		  case 2:
+			 iic_write_ex(DITHER_SEL0_SPP, 0);
+		     iic_write_ex(DITHER_SEL1_SPP, 1);
+			 break;
+		  case 3:
+			 iic_write_ex(DITHER_SEL0_SPP, 1);
+		     iic_write_ex(DITHER_SEL1_SPP, 1);
+			 break;
+		  default:
+			iic_write_ex(DITHER_SEL0_SPP, 0);
+		    iic_write_ex(DITHER_SEL1_SPP, 0);
+			break;
+	    }
+
+	}
+
+	if((pOutput_Info->channel & CHANNEL_VGA)&&((pOutput_Info->channel & CHANNEL_HDMI)==0x00))
+	{
+
+
+		iic_write_ex(HPO_O, 1);
+		iic_write_ex(VPO_O, 1);
+		iic_write_ex(DEPO_O, 0);
+	}
+	else if((pOutput_Info->channel & CHANNEL_VGA)&&(pOutput_Info->channel & CHANNEL_HDMI))
+	{
+
+        iic_write_ex(HPO_O, 1);
+		iic_write_ex(VPO_O, 0);
+		iic_write_ex(DEPO_O, 0);
+	}
+
+	if((pOutput_Info->channel & CHANNEL_HDMI) && ((pOutput_Info->channel & CHANNEL_VGA) == 0x00))
+	{
+		 iic_write_ex(HDMIIN_HSP, pHdmiFmt->hs_pol ? 1:0);
+		 iic_write_ex(HDMIIN_VSP, pHdmiFmt->vs_pol ? 1:0);
+		 iic_write_ex(HDMIIN_DEP, 0);
+	}
+	if((pOutput_Info->channel & CHANNEL_HDMI)&&(pOutput_Info->channel & CHANNEL_VGA))
+	{
+		 iic_write_ex(HDMIIN_HSP, 0);
+		 iic_write_ex(HDMIIN_VSP, 1);
+		 iic_write_ex(HDMIIN_DEP, 1);
+	}
+
+
+	if(pOutput_Info->channel & CHANNEL_HDMI)
+	{
+
+		hd_dvib = pHdmiFmt->is_dvi_mode ? 0 : 1;
+		iic_write_ex(HD_DVIB, hd_dvib);
+
+		switch(pHdmiFmt->format_index)
+		{
+		case  5:
+		case  6:
+		case  7:
+		case 10:
+		case 11:
+		case 20:
+		case 21:
+		case 22:
+		case 25:
+		case 26:
+			intlc = 1;
+			break;
+		default:
+			intlc = 0;
+			break;
+		}
+		iic_write_ex(INTLC, intlc);
+
+		copy = 1;
+		iic_write_ex(COPY, copy);
+
+		hd_lv_pol = pHdmiFmt->data_pol_invert;
+		iic_write_ex(HD_LV_POL, hd_lv_pol);
+
+		hd_lv_seq = pHdmiFmt->channel_swap;
+		iic_write_ex(HD_LV_SEQ, hd_lv_seq);
+
+		hdmi_lvds_sel = 1;
+		iic_write_ex(HDMI_LVDS_SEL, hdmi_lvds_sel);
+
+
+		if (pOutput_Info->timing.ha > 720) {
+			pOutput_Info->hdmi_fmt.hs_pol = POL_HIGH;
+			pOutput_Info->hdmi_fmt.vs_pol = POL_HIGH;
+			if(pOutput_Info->timing.ha == 1440)
+			{
+              pOutput_Info->hdmi_fmt.hs_pol = POL_LOW;
+			  pOutput_Info->hdmi_fmt.vs_pol = POL_LOW;
+			}
+		}
+		else {
+
+			pOutput_Info->hdmi_fmt.hs_pol = POL_LOW;
+			pOutput_Info->hdmi_fmt.vs_pol = POL_LOW;
+		}
+
+		hsp = pHdmiFmt->hs_pol;
+		vsp = pHdmiFmt->vs_pol;
+		iic_write_ex(HSP, hsp);
+		iic_write_ex(VSP, vsp);
+
+
+		switch(pHdmiFmt->format_index)
+		{
+		case 1:
+		case 2:
+		case 17:
+			{
+				if(pHdmiFmt->aspect_ratio == AS_RATIO_16_9)
+				{
+					g_nLastError = ERR_ASPECT_RATIO_NOMATCH;
+					return ch_false;
+				}
+			}
+			break;
+		case 4:
+		case 5:
+		case 16:
+		case 19:
+		case 20:
+		case 31:
+		case 32:
+		case 33:
+		case 34:
+			{
+				if(pHdmiFmt->aspect_ratio == AS_RATIO_4_3)
+				{
+					g_nLastError = ERR_ASPECT_RATIO_NOMATCH;
+					return ch_false;
+				}
+			}
+			break;
+		default:
+			break;
+		}
+		m1m0 = pHdmiFmt->aspect_ratio;
+		iic_write_ex(M1M0, m1m0);
+
+		c1c0 = 2;
+		iic_write_ex(C1C0, c1c0);
+
+		vic = pHdmiFmt->format_index;
+		iic_write_ex(VIC, vic);
+	}
+
+	if(pOutput_Info->channel & CHANNEL_VGA){
+       intlc = 0;
+	}
+
+	iic_write_ex(INTLC, intlc);
+
+
+	iic_write( 0x3,  0x1);
+	iic_write( 0x23, 0x63);
+	iic_write( 0x3,  0x0);
+
+	return ch_true;
+}
+
+ch_bool set_prefer_info(PREFER_INFO* pPrefer_Info)
+{
+	uint8 hsync_cnt_th, prbs_set_sel;
+	uint8 dbp, hpo_o, vpo_o, depo_o;
+
+
+	iic_write_ex(MCLK, pPrefer_Info->mclk_khz);
+
+	iic_write_ex(UCLKOD_SEL, pPrefer_Info->uclkod_sel);
+	iic_write_ex(DAT16_32B, pPrefer_Info->dat16_32b);
+	iic_write_ex(TRUE24, pPrefer_Info->true24);
+	iic_write_ex(TRUE_COM, pPrefer_Info->true_com);
+
+	hsync_cnt_th = pPrefer_Info->lvds_out_hs_tolerance;
+	iic_write_ex(HSYNC_CNT_TH_SPP, hsync_cnt_th);
+	prbs_set_sel = pPrefer_Info->lvds_out_reset_bit_sel;
+	iic_write_ex(PRBS_SET_SEL_SPP, prbs_set_sel);
+
+	dbp = pPrefer_Info->dither_filter_enable ? 0 : 1;
+	iic_write_ex(DBP, dbp);
+
+
+
+	iic_write_ex(TXTEN, pPrefer_Info->text_enhancement);
+
+
+
+
+
+
+	return ch_true;
+}
+
+
+ch_bool cal_and_set_clk_pll(DEV_CONTEXT* pDevContext)
+{
+	uint8 pll1n2_reg, pll1n2_div;
+	uint8 pll1n3_reg, pll1n3_div;
+	uint8 pll1n1_reg, pll1n1_div;
+	uint8 pll3n8_reg, pll3n8_div;
+	uint8 pll2n5_reg, pll2n5_div;
+	uint8 pll2n6_reg, pll2n6_div;
+	uint8 pll2n7_reg, pll2n7_div;
+	uint8 dmxtal_reg, dmxtal_div;
+
+	uint32 a2_reg;
+	uint32 a1_reg;
+	uint32 a3_reg;
+	uint32 uclk2d_reg;
+	uint8 uclksec_reg;
+	uint8 dri_pll_n1_reg;
+	uint8 dri_pll_n3_reg;
+
+	uint32 val_t;
+	uint32 val_t1, val_t2;
+
+	uint8 gcksel;
+	uint8 tsten1;
+    uint8 REV_ID;
+	uint64 temp1;
+
+
+	INPUT_INFO* pInput_Info = pDevContext->pInput_Info;
+	OUTPUT_INFO* pOutput_Info = pDevContext->pOutput_Info;
+	PREFER_INFO* pPrefer_Info = pDevContext->pPrefer_Info;
+
+	I2CWrite(pDevContext,0x03, 0x04);
+	REV_ID = I2CRead(pDevContext,0x51) & 0x0F;
+
+
+	if(pPrefer_Info->reset == 1)
+	{
+      I2CWrite(pDevContext,0x03, 0x01);
+	  I2CWrite(pDevContext,0x14, I2CRead(pDevContext,0x14) | 0x40);
+	  I2CWrite(pDevContext,0x03, 0x04);
+	  I2CWrite(pDevContext,0x54, I2CRead(pDevContext,0x54) | 0x40);
+	  tsten1 = 0x40;
+	  gcksel = 0x40;
+	  iic_write_ex(GCKSEL, 1);
+	  iic_write_ex(TSTEN1, 1);
+	}
+
+
+	else if((pPrefer_Info->reset == 0) || (REV_ID >= 0x01))
+	{
+	  I2CWrite(pDevContext,0x03, 0x01);
+	  I2CWrite(pDevContext,0x14, I2CRead(pDevContext,0x14) & 0xBF);
+	  I2CWrite(pDevContext,0x03, 0x04);
+	  I2CWrite(pDevContext,0x54, 0x40 | (I2CRead(pDevContext,0x54) & 0xBF));
+	  tsten1=0x00;
+	  gcksel=0x00;
+	  iic_write_ex(GCKSEL, 1);
+	  iic_write_ex(TSTEN1, 0);
+	}
+
+
+	pll1n2_div = 4;
+	pll1n3_div = 8;
+	if(!convert_pll1n2_div(ch_false, &pll1n2_reg, &pll1n2_div))
+	{
+		g_nLastError = ERR_PLL1N2_WRONG;
+		return ch_false;
+	}
+	if(!convert_pll1n3_div(ch_false, &pll1n3_reg, &pll1n3_div))
+	{
+		g_nLastError = ERR_PLL1N3_WRONG;
+		return ch_false;
+	}
+	iic_write_ex(PLL1N2, pll1n2_reg);
+	iic_write_ex(PLL1N3, pll1n3_reg);
+
+
+
+	if(((gcksel == 0x40)&&(tsten1 == 0x00)) || ((gcksel == 0x00)&&(tsten1 == 0x00)))
+	{
+
+
+
+
+			pll1n1_div = 8;
+		    pll1n1_reg = 3;
+
+
+
+
+
+
+
+	}
+	else if((gcksel == 0x40)&&(tsten1 == 0x40)){
+	  for(pll1n1_div=1; pll1n1_div<=64; pll1n1_div<<=1)
+	  {
+	 	val_t = pInput_Info->rx_clk_khz / pll1n1_div;
+	    if(val_t >= 2300 && val_t <= 4600)
+			break;
+	  }
+	  if(pll1n1_div > 64)
+	  {
+		g_nLastError = ERR_PLL1N1_WRONG;
+		return ch_false;
+	  }
+	  if(!convert_pll1n1_div(ch_false, &pll1n1_reg, &pll1n1_div))
+	  {
+		g_nLastError = ERR_PLL1N1_WRONG;
+		return ch_false;
+	  }
+	}
+
+	iic_write_ex(PLL1N1, pll1n1_reg);
+
+
+	for(pll3n8_div=1; pll3n8_div<=8; pll3n8_div<<=1)
+	{
+		val_t = pPrefer_Info->mclk_khz * pll3n8_div / 64;
+		if(val_t >= 2300 && val_t <= 2600)
+			break;
+	}
+	if(pll3n8_div > 8)
+	{
+		g_nLastError = ERR_PLL3N8_WRONG;
+		return ch_false;
+	}
+	if(!convert_pll3n8_div(ch_false, &pll3n8_reg, &pll3n8_div))
+	{
+		g_nLastError = ERR_PLL3N8_WRONG;
+		return ch_false;
+	}
+	iic_write_ex(PLL3N8, pll3n8_reg);
+
+
+
+	if((gcksel == 0x40)&&(tsten1 == 0x40)){
+		 val_t1 = (pInput_Info->rx_clk_khz << 12);
+		 val_t2 = (pll1n1_div * pll3n8_div * pPrefer_Info->mclk_khz);
+		 a2_reg = (val_t1 % val_t2) ? (val_t1 / val_t2 + 1) : (val_t1 / val_t2);
+
+	}else if(((gcksel == 0x40)&&(tsten1 == 0x00))||((gcksel == 0x00)&&(tsten1 == 0x00))){
+	  val_t1 = (27000 << 12);
+	  val_t2 = (pll1n1_div * pll3n8_div * pPrefer_Info->mclk_khz);
+
+
+
+
+	  a2_reg = (val_t1 % val_t2) ? (val_t1 / val_t2 + 1) : (val_t1 / val_t2);
+	  if(pOutput_Info->uclk_khz == 148500){
+         a2_reg = 0x73;
+	  }
+	}
+
+	iic_write_ex(A2, a2_reg);
+
+
+	if(pInput_Info->audio_type)
+	{
+		uclksec_reg = pOutput_Info->uclk_khz / 10;
+	}
+	else
+	{
+
+
+
+
+
+		if( (0x40==gcksel)&&(0x40==tsten1) )
+		{
+			uclk2d_reg = (pInput_Info->rx_clk_khz * 2 * pll1n2_div * pll1n3_div) / (pll1n1_div * 10);
+		}
+		if(0x00==tsten1 )
+		{
+			uclk2d_reg = (27000 * 2 * pll1n2_div * pll1n3_div) / (pll1n1_div * 10);
+		}
+
+	}
+	iic_write_ex(PCLK_NUM, uclk2d_reg);
+
+
+
+
+
+	if((pOutput_Info->uclk_khz == 54000	||
+												  pOutput_Info->uclk_khz == 72000	||
+												  pOutput_Info->uclk_khz == 74250	||
+												  pOutput_Info->uclk_khz == 108000	||
+												  pOutput_Info->uclk_khz == 148500  ))
+	{
+		uclksec_reg = 1;
+	}
+	else
+	{
+		uclksec_reg = 0;
+	}
+	iic_write_ex(UCLKSEC, uclksec_reg);
+
+
+	if(uclksec_reg == 0)
+	{
+		pll2n6_div = 8;
+		pll2n7_div = 8;
+		for(pll2n5_div=1; pll2n5_div<=8; ++pll2n5_div)
+		{
+			val_t = pOutput_Info->uclk_khz * pll2n5_div / 64;
+			if(val_t >= 2300 && val_t <= 4600)
+				break;
+		}
+		if(pll2n5_div > 8)
+		{
+			g_nLastError = ERR_PLL2N5_WRONG;
+			return ch_false;
+		}
+		dmxtal_div = 1;
+
+		if(pPrefer_Info->uclkod_sel == 1)
+		{
+			if((gcksel == 0x40)&&(tsten1 == 0x40)){
+				temp1 = (((uint64)pOutput_Info->uclk_khz) * pll1n1_div * pll2n5_div * (1 << 20));
+	        	do_div(temp1 , pInput_Info->rx_clk_khz);
+				a1_reg = (uint32)temp1;
+			} else if((gcksel == 0x40)&&(tsten1 == 0x00)){
+				temp1 = (((uint64)pOutput_Info->uclk_khz) * pll1n1_div * pll2n5_div * (1 << 20));
+	        	do_div(temp1 , (uint32)27000);
+				a1_reg = (uint32)temp1;
+	       	}else if((gcksel == 0x00)&&(tsten1 == 0x00)){
+				temp1 = (((uint64)pOutput_Info->uclk_khz) * pll1n1_div * pll2n5_div * (1 << 20));
+	        	do_div(temp1 , (uint32)27000);
+				a1_reg = (uint32)temp1;
+			}
+		   iic_write_ex(A1, a1_reg);
+		}
+		else
+		{
+			if((gcksel == 0x40)&&(tsten1 == 0x40))
+	       a3_reg = pInput_Info->rx_clk_khz * (1 << 12) / (pOutput_Info->uclk_khz * pll1n1_div * pll2n5_div);
+          else if((gcksel == 0x40)&&(tsten1 == 0x00))
+	       a3_reg = 27000 * (1 << 12) / (pOutput_Info->uclk_khz * pll1n1_div * pll2n5_div);
+          else if((gcksel == 0x00)&&(tsten1 == 0x00))
+	       a3_reg = 27000 * (1 << 12) / (pOutput_Info->uclk_khz * pll1n1_div * pll2n5_div);
+
+			iic_write_ex(A3, a3_reg);
+		}
+	}
+	else
+	{
+		switch(pOutput_Info->uclk_khz)
+		{
+		case 54000:
+			dmxtal_div = 6;
+			pll2n7_div = 8;
+			pll2n6_div = 6;
+			pll2n5_div = 4;
+			break;
+		case 72000:
+			dmxtal_div = 6;
+			pll2n7_div = 8;
+			pll2n6_div = 6;
+			pll2n5_div = 3;
+			break;
+		case 74250:
+			dmxtal_div = 6;
+			pll2n7_div = 11;
+			pll2n6_div = 6;
+			pll2n5_div = 4;
+			break;
+		case 108000:
+			dmxtal_div = 6;
+			pll2n7_div = 8;
+			pll2n6_div = 6;
+			pll2n5_div = 2;
+			break;
+		case 148500:
+
+
+
+
+			dmxtal_div = 6;
+			pll2n6_div = 6;
+
+
+
+
+
+			pll2n7_div = 11;
+			pll2n5_div = 2;
+			break;
+		default:
+			return ch_false;
+		}
+	}
+	if(!convert_pll2n5_div(ch_false, &pll2n5_reg, &pll2n5_div))
+	{
+		g_nLastError = ERR_PLL2N5_WRONG;
+		return ch_false;
+	}
+	iic_write_ex(PLL2N5, pll2n5_reg & 0x07);
+	iic_write_ex(PLL2N53, pll2n5_reg >> 3 & 0x01);
+	if(!convert_pll2n6_div(ch_false, &pll2n6_reg, &pll2n6_div))
+	{
+		g_nLastError = ERR_PLL2N6_WRONG;
+		return ch_false;
+	}
+	iic_write_ex(PLL2N6, pll2n6_reg);
+	if(!convert_pll2n7_div(ch_false, &pll2n7_reg, &pll2n7_div))
+	{
+		g_nLastError = ERR_PLL2N7_WRONG;
+		return ch_false;
+	}
+	iic_write_ex(PLL2N7, pll2n7_reg);
+	if(!convert_dmxtal_div(ch_false, &dmxtal_reg, &dmxtal_div))
+	{
+		g_nLastError = ERR_DMXTAL_WRONG;
+		return ch_false;
+	}
+	iic_write_ex(DIVXTAL, dmxtal_reg);
+
+
+	if(pInput_Info->rx_clk_khz > 40000)
+	{
+		iic_write_ex(TXPLL_FFD, 1);
+	}
+
+
+	if(pOutput_Info->channel & CHANNEL_HDMI)
+	{
+		val_t = pOutput_Info->uclk_khz;
+		if(val_t < 25000 || val_t > 165000)
+		{
+			g_nLastError = ERR_HDMI_CLOCK_NO_SUPPORT;
+			return ch_false;
+		}
+		if(val_t <= 40000)
+		{
+			dri_pll_n1_reg = 0;
+			dri_pll_n3_reg = 0;
+		}
+		else if(val_t < 80000)
+		{
+			dri_pll_n1_reg = 1;
+			dri_pll_n3_reg = 1;
+		}
+		else
+		{
+			dri_pll_n1_reg = 2;
+			dri_pll_n3_reg = 2;
+		}
+		iic_write_ex(DRI_PLL_N1, dri_pll_n1_reg);
+		iic_write_ex(DRI_PLL_N3, dri_pll_n3_reg);
+	}
+
+
+	iic_write_ex(CK_TVINV, 1);
+
+	return ch_true;
+}
+
+ch_bool cal_and_set_scaler(DEV_CONTEXT* pDevContext)
+{
+	uint8 wrlen_reg;
+	uint32 frame_rate_in, frame_rate_out, field_rate_out;
+	uint32 hai_down, hai_sdram;
+	uint8 fltbp2_reg, fltbp1_reg;
+	uint8 dnsmpen_reg;
+	uint32 hadwn_reg;
+	uint8 blk_h_reg;
+	uint32 fba_inc_reg;
+	uint8 sfm_reg;
+	uint8 thren_reg;
+	uint32 thrrl_reg;
+	uint8 lnsel_reg;
+	uint8 wrfast_reg;
+	uint8 chg_hl_reg;
+	uint8 vsmst_reg;
+
+	uint32 val_t;
+	uint32 hao_t;
+	uint32 vao_t;
+	uint32 vai_t;
+
+
+	INPUT_INFO* pInput_Info = pDevContext->pInput_Info;
+	OUTPUT_INFO* pOutput_Info = pDevContext->pOutput_Info;
+	PREFER_INFO* pPrefer_Info = pDevContext->pPrefer_Info;
+
+
+	wrlen_reg = 0;
+	iic_write_ex(WRLEN, wrlen_reg);
+
+
+	frame_rate_in = ((pInput_Info->rx_clk_khz * 10000) / pInput_Info->timing.ht) * 10 / pInput_Info->timing.vt;
+	frame_rate_out = ((pOutput_Info->uclk_khz * 10000) / pOutput_Info->timing.ht) * 10 / pOutput_Info->timing.vt;
+	field_rate_out = iic_read_ex(INTLC) ? (frame_rate_out * 2) : (frame_rate_out);
+
+
+	hai_down = pInput_Info->timing.ha;
+	if(pOutput_Info->ds_percent_h)
+	{
+		hao_t = pOutput_Info->timing.ha * (100 - pOutput_Info->ds_percent_h) / 100;
+	}
+	else
+	{
+		hao_t = pOutput_Info->timing.ha;
+	}
+	hao_t = hao_t + (hao_t % 2);
+	if(hai_down > hao_t)
+	{
+		dnsmpen_reg = 1;
+		hadwn_reg = hao_t;
+		hai_down = hadwn_reg;
+		fltbp2_reg = 1;
+		fltbp1_reg = 1;
+	}
+	else
+	{
+		dnsmpen_reg = 0;
+		fltbp2_reg = 1;
+		fltbp1_reg = 1;
+	}
+	if(pOutput_Info->rotate == ROTATE_90 || pOutput_Info->rotate == ROTATE_270)
+	{
+		val_t = 720;
+	}
+	else
+	{
+		if(pPrefer_Info->dat16_32b)
+		{
+			val_t = 720;
+		}
+		else
+		{
+			val_t = pPrefer_Info->true24 ? 720 : 1440;
+		}
+	}
+	if(hai_down > val_t && (pOutput_Info->rotate != ROTATE_NO || pOutput_Info->h_flip || pOutput_Info->v_flip))
+	{
+		dnsmpen_reg = 1;
+		hadwn_reg = val_t;
+		hai_down = hadwn_reg;
+		fltbp2_reg = 1;
+		fltbp1_reg = 1;
+	}
+	iic_write_ex(DNSMPEN, dnsmpen_reg);
+	iic_write_ex(HADWSPP, hadwn_reg);
+
+	if(pInput_Info->timing.ha * 100 / hao_t > pPrefer_Info->hscale_ratio_gate)
+	{
+		fltbp1_reg = 0;
+	}
+	iic_write_ex(FLTBP2, fltbp2_reg);
+	iic_write_ex(FLTBP1, fltbp1_reg);
+
+
+	if(pOutput_Info->rotate == ROTATE_90 || pOutput_Info->rotate == ROTATE_270)
+	{
+		val_t = 100;
+	}
+	else
+	{
+		if(pPrefer_Info->dat16_32b)
+		{
+			val_t = 100;
+		}
+		else if(pPrefer_Info->true24)
+		{
+			val_t = 100;
+		}
+		else
+		{
+			val_t = pPrefer_Info->true_com ? 75 : 50;
+		}
+	}
+	if(val_t == 75)
+	{
+		hai_sdram = (hai_down / 4) * 3 + (hai_down % 4);
+	}
+	else
+	{
+		hai_sdram = hai_down * val_t / 100;
+	}
+	if(pOutput_Info->rotate != ROTATE_NO || pOutput_Info->h_flip || pOutput_Info->v_flip)
+	{
+		blk_h_reg = 45;
+	}
+	else if(hai_sdram <= 720 && pInput_Info->timing.va <= 720)
+	{
+		blk_h_reg = 45;
+	}
+	else
+	{
+		blk_h_reg = hai_sdram / 16;
+		blk_h_reg = (hai_sdram % 16) ? (blk_h_reg + 1) : blk_h_reg;
+	}
+	iic_write_ex(BLK_H, blk_h_reg);
+
+
+	if((pOutput_Info->rotate == ROTATE_90 || pOutput_Info->rotate == ROTATE_270) && pPrefer_Info->true24 == 0 && pPrefer_Info->true_com == 0 && pPrefer_Info->dat16_32b == 0)
+	{
+		vai_t = pInput_Info->timing.va / 2;
+	}
+	else
+	{
+		vai_t = pInput_Info->timing.va;
+	}
+	val_t = (vai_t % 16) ? (vai_t / 16 + 1) : (vai_t / 16);
+	fba_inc_reg = blk_h_reg * val_t;
+	if(fba_inc_reg > 2048)
+	{
+		sfm_reg = 1;
+		thren_reg = 1;
+		val_t = (frame_rate_in * 100) / field_rate_out;
+		if(val_t > 100)
+		{
+
+
+			thrrl_reg = pInput_Info->timing.vt * (100 - 10000 / val_t) / 100 + THRRL_ADJUST_DEF;
+		}
+		else
+		{
+			thrrl_reg = pInput_Info->timing.vt * (100 - val_t) / 100 + THRRL_ADJUST_DEF;
+		}
+	}
+	else
+	{
+		sfm_reg = 0;
+		thren_reg = 0;
+		thrrl_reg = 0;
+	}
+	iic_write_ex(FBA_INC, fba_inc_reg);
+	iic_write_ex(SFM, sfm_reg);
+	iic_write_ex(THREN, thren_reg);
+	iic_write_ex(THRRL, thrrl_reg);
+
+
+	if(pOutput_Info->ds_percent_v)
+	{
+		vao_t = pOutput_Info->timing.va * (100 - pOutput_Info->ds_percent_v) / 100;
+	}
+	else
+	{
+		vao_t = pOutput_Info->timing.va;
+	}
+	vao_t = vao_t + (vao_t % 2);
+	val_t = iic_read_ex(INTLC) ? (vao_t / 2) : vao_t;
+	if(pOutput_Info->rotate == ROTATE_90 || pOutput_Info->rotate == ROTATE_270)
+	{
+		if(hai_down <= val_t)
+			lnsel_reg = 3;
+		else
+			lnsel_reg = 1;
+	}
+	else
+	{
+		if(pInput_Info->timing.va <= val_t)
+			lnsel_reg = 3;
+		else
+			lnsel_reg = 1;
+	}
+	if(pPrefer_Info->scale_line_adjust)
+	{
+		lnsel_reg++;
+		if((pOutput_Info->ds_percent_v >= 2) && (pOutput_Info->ds_percent_v <= 12) &&
+            (pOutput_Info->ds_percent_h <= 12) &&
+
+			(pOutput_Info->channel & CHANNEL_VGA) &&
+			(pOutput_Info->timing.ha == 1280) && (pOutput_Info->timing.va == 960) &&
+			(pOutput_Info->timing.hz == 60) && (pInput_Info->rx_clk_khz >= 75428)&&
+			(pInput_Info->timing.ha == 1280) && (pInput_Info->timing.va == 1024)&&
+			(pInput_Info->timing.hz >= 49)){
+
+				lnsel_reg++;
+
+		}
+
+
+
+
+		if((pOutput_Info->ds_percent_v >= 2) && (pOutput_Info->ds_percent_v <= 12) &&
+            (pOutput_Info->ds_percent_h >= 0) && (pOutput_Info->ds_percent_h <= 12) &&
+			(pOutput_Info->channel & CHANNEL_VGA) &&
+			(pOutput_Info->timing.ha == 1280) && (pOutput_Info->timing.va == 1024) &&
+			(pOutput_Info->timing.hz == 60) && (pInput_Info->rx_clk_khz >= 75428)){
+
+				lnsel_reg++;
+
+		}
+
+		if((pOutput_Info->ds_percent_v >= 2 ) &&
+            (pOutput_Info->ds_percent_h >= 2 ) && (pOutput_Info->channel & CHANNEL_VGA) &&
+			(pOutput_Info->timing.ha == 1280) && (pOutput_Info->timing.va == 1024) &&
+			(pOutput_Info->timing.hz == 75) && (pInput_Info->rx_clk_khz >= 75428)){
+
+				lnsel_reg++;
+		}
+
+		if((pOutput_Info->ds_percent_v >= 6 ) &&
+            (pOutput_Info->ds_percent_h >= 6 ) && (pOutput_Info->channel & CHANNEL_HDMI) &&
+			(pOutput_Info->timing.ha == 1920) && (pOutput_Info->timing.va == 1080) &&
+			(pOutput_Info->timing.hz == 50) && (pInput_Info->rx_clk_khz >= 75428)){
+
+				lnsel_reg++;
+		}
+		if((pOutput_Info->ds_percent_v >= 6 ) &&
+            (pOutput_Info->ds_percent_h >= 6 ) && (pOutput_Info->channel & CHANNEL_HDMI) &&
+			(pOutput_Info->timing.ha == 1920) && (pOutput_Info->timing.va == 1080) &&
+			(pOutput_Info->timing.hz == 59) && (pInput_Info->rx_clk_khz >= 75428)){
+
+				lnsel_reg++;
+		}
+		if((pOutput_Info->ds_percent_v >= 6 ) &&
+            (pOutput_Info->ds_percent_h >= 6 ) && (pOutput_Info->channel & CHANNEL_HDMI) &&
+			(pOutput_Info->timing.ha == 1920) && (pOutput_Info->timing.va == 1080) &&
+			(pOutput_Info->timing.hz == 60) && (pInput_Info->rx_clk_khz >= 75428)){
+
+				lnsel_reg++;
+		}
+	}
+	iic_write_ex(LNSEL, lnsel_reg);
+
+
+	if(frame_rate_in >= field_rate_out)
+		wrfast_reg = 1;
+	else
+		wrfast_reg = 0;
+	iic_write_ex(WRFAST, wrfast_reg);
+
+
+	chg_hl_reg = (	(pPrefer_Info->dat16_32b == 0)		&&
+					(pPrefer_Info->true24 == 0)			&&
+					(pPrefer_Info->true_com == 0)		&&
+					(	(pOutput_Info->rotate == 0)	&&
+						(pOutput_Info->h_flip == 1)	||
+						(pOutput_Info->rotate == 1)	&&
+						(pOutput_Info->h_flip == 0)	||
+						(pOutput_Info->rotate == 3) &&
+						(pOutput_Info->h_flip == 1) ||
+						(pOutput_Info->rotate == 2) &&
+						(pOutput_Info->h_flip == 0)  )   ) ? 1 : 0;
+	iic_write_ex(CHG_HL, chg_hl_reg);
+
+
+	vsmst_reg = 2;
+	iic_write_ex(VSMST, vsmst_reg);
+
+	return ch_true;
+}
+
+ch_bool post_cal_and_set(DEV_CONTEXT* pDevContext)
+{
+	uint32 hdinc_reg, hdinca_reg, hdincb_reg;
+	uint32 hinc_reg, hinca_reg, hincb_reg;
+	uint32 vinc_reg, vinca_reg, vincb_reg;
+
+	uint32 val_t;
+	uint64 temp1;
+	uint32 temp2;
+
+
+	I2CWrite(pDevContext,0x03, 0x04);
+
+	val_t = I2CRead(pDevContext,0x2A);
+	hinca_reg = (val_t << 3) | (I2CRead(pDevContext,0x2B) & 0x07);
+
+	val_t = I2CRead(pDevContext,0x2C);
+	hincb_reg = (val_t << 3) | (I2CRead(pDevContext,0x2D) & 0x07);
+
+	val_t = I2CRead(pDevContext,0x2E);
+	vinca_reg = (val_t << 3) | (I2CRead(pDevContext,0x2F) & 0x07);
+
+	val_t = I2CRead(pDevContext,0x30);
+	vincb_reg = (val_t << 3) | (I2CRead(pDevContext,0x31) & 0x07);
+
+	val_t = I2CRead(pDevContext,0x32);
+	hdinca_reg = (val_t << 3) | (I2CRead(pDevContext,0x33) & 0x07);
+
+	val_t = I2CRead(pDevContext,0x34);
+	hdincb_reg = (val_t << 3) | (I2CRead(pDevContext,0x35) & 0x07);
+
+
+	I2CWrite(pDevContext,0x03, 0x04);
+
+
+	if(iic_read_ex(DNSMPEN))
+	{
+		if(hdincb_reg == 0)
+		{
+			g_nLastError = ERR_CAL_INC_DIV_ZERO;
+			return ch_false;
+		}
+		temp1 = ((uint64)hdinca_reg) * (1 << 20);
+		do_div(temp1 , hdincb_reg);
+		hdinc_reg = (uint32)temp1;
+
+
+		I2CWrite(pDevContext,0x3C, (hdinc_reg >> 16) & 0xFF);
+		I2CWrite(pDevContext,0x3D, (hdinc_reg >>  8) & 0xFF);
+		I2CWrite(pDevContext,0x3E, (hdinc_reg >>  0) & 0xFF);
+	}
+	if(hincb_reg == 0 || vincb_reg == 0)
+	{
+		g_nLastError = ERR_CAL_INC_DIV_ZERO;
+		return ch_false;
+	}
+
+	if(hinca_reg > hincb_reg)
+	{
+		g_nLastError = ERR_CAL_INC_NO_MATH;
+		return ch_false;
+	}
+
+	temp1 = (uint64)hinca_reg * (1 << 20);
+	do_div(temp1 , hincb_reg);
+	hinc_reg = (uint32)temp1;
+
+	temp1 = (uint64)vinca_reg * (1 << 20);
+	do_div( temp1 , vincb_reg);
+	vinc_reg = (uint32)temp1;
+
+	I2CWrite(pDevContext,0x36, (hinc_reg >> 16) & 0xFF);
+	I2CWrite(pDevContext,0x37, (hinc_reg >>  8) & 0xFF);
+	I2CWrite(pDevContext,0x38, (hinc_reg >>  0) & 0xFF);
+
+	I2CWrite(pDevContext,0x39, (vinc_reg >> 16) & 0xFF);
+	I2CWrite(pDevContext,0x3A, (vinc_reg >>  8) & 0xFF);
+	I2CWrite(pDevContext,0x3B, (vinc_reg >>  0) & 0xFF);
+
+	return ch_true;
+}
+
+
+
+
+
+
+ch_bool cal_and_set_power(DEV_CONTEXT* pDevContext)
+{
+
+	uint8 hdmi_pd = 1;
+	uint8 i2s_pd = 1;
+	uint8 spdif_pd = 1;
+	uint8 auddac=1;
+	uint8 dri_pd = 1;
+	uint8 dri_pd_ser = 1;
+	uint8 dri_pd_pll = 1;
+	uint8 dri_pddri = 7;
+	uint8 cec_pd = 1;
+	uint8 pd_ddc = 1;
+
+
+	uint8 lvds_pd = 1;
+	uint8 rx_pd = 63;
+	uint8 rxpll_pd = 1;
+	uint8 txpll_pd = 1;
+	uint8 txdrv_pd = 1;
+	uint8 txser_pd = 1;
+
+
+
+
+
+	uint8 icen0 =1;
+
+
+
+	uint8 vga_pd = 1;
+	uint8 pddac = 7;
+
+	uint8 pdpll1 = 1;
+	uint8 pdpll0 = 1;
+
+
+	uint8 pd_prom = 0;
+	uint8 pdmio = 1;
+	uint8 pdio = 1;
+	uint8 hpd_pd = 0;
+
+
+	uint8 sclpd = 1;
+	uint8 sdpd = 1;
+	uint8 mempd = 1;
+	uint8 dacsence = 1;
+
+	uint8 gckoff = 0;
+
+
+	uint8 dispon = 0;
+
+
+
+
+
+	INPUT_INFO* pInput_Info = pDevContext->pInput_Info;
+	OUTPUT_INFO* pOutput_Info = pDevContext->pOutput_Info;
+	PREFER_INFO* pPrefer_Info = pDevContext->pPrefer_Info;
+
+
+	iic_write_ex(CRYS_FREQ_SPP, 27000);
+	iic_write_ex(I2SCK_SEC, 1);
+	iic_write_ex(SP_EN, 0);
+	iic_write_ex(HARD_SOFTB, 1);
+	iic_write_ex(MULT_I2CEN, 0);
+
+
+
+	if(pOutput_Info->channel & CHANNEL_LVDS)
+	{
+		lvds_pd = 0;
+		rx_pd = 0;
+		rxpll_pd = 0;
+		txpll_pd = 0;
+		txdrv_pd = 0;
+		txser_pd = 0;
+		pdio = 0;
+
+
+
+
+
+
+
+
+	}
+	if(pOutput_Info->channel & CHANNEL_HDMI)
+	{
+		hdmi_pd = 0;
+		if(pInput_Info->audio_type == 1)
+			i2s_pd = 0;
+		else {
+			spdif_pd = 0;
+			auddac=0;
+		}
+		dri_pd = 0;
+		dri_pddri = 0;
+		dri_pd_ser = 0;
+		dri_pd_pll = 0;
+		pd_ddc = 0;
+
+
+		vga_pd = 0;
+		pdmio = 0;
+		sclpd = 0;
+		sdpd = 0;
+		gckoff = 0;
+		mempd = 0;
+
+		rx_pd = 0;
+		rxpll_pd = 0;
+
+		pdpll0 = 0;
+		pdpll1 = 0;
+		icen0 =0;
+
+		pdio = 0;
+		hpd_pd = 0;
+
+	}
+	if(pOutput_Info->channel & CHANNEL_VGA)
+	{
+		rx_pd = 0;
+		rxpll_pd = 0;
+		vga_pd = 0;
+		pddac = 0;
+
+		pdpll0 = 0;
+		pdpll1 = 0;
+		icen0 =0;
+
+		pdmio = 0;
+		pdio = 0;
+		sclpd = 0;
+		sdpd = 0;
+		gckoff = 0;
+
+		mempd = 0;
+		dispon = 1;
+		dri_pd_pll = 0;
+
+
+		dacsence=1;
+	}else{
+
+
+
+		if(pPrefer_Info->vga_enable)
+           dispon = 0;
+	}
+
+
+	iic_write_ex(HDMI_PD,		hdmi_pd);
+	iic_write_ex(I2S_PD,		i2s_pd);
+	iic_write_ex(SPDIF_PD,		spdif_pd);
+
+	iic_write_ex(AUDDAC,        auddac);
+
+	iic_write_ex(DRI_PD,		dri_pd);
+	iic_write_ex(DRI_PD_SER,	dri_pd_ser);
+	iic_write_ex(DRI_PD_PLL,	dri_pd_pll);
+	iic_write_ex(DRI_PDDRI,		dri_pddri);
+	iic_write_ex(CEC_PD,		cec_pd);
+	iic_write_ex(PD_DDC,		pd_ddc);
+	iic_write_ex(LVDS_PD,		lvds_pd);
+	iic_write_ex(RX_PD,			rx_pd);
+	iic_write_ex(RXPLL_PD,		rxpll_pd);
+	iic_write_ex(TXPLL_PD,		txpll_pd);
+	iic_write_ex(TXDRV_PD,		txdrv_pd);
+	iic_write_ex(TXSER_PD,		txser_pd);
+	iic_write_ex(VGA_PD,		vga_pd);
+	iic_write_ex(PDDAC,			pddac);
+	iic_write_ex(PDPLL1,		pdpll1);
+	iic_write_ex(PDPLL0,		pdpll0);
+	iic_write_ex(ICEN0,			icen0);
+	iic_write_ex(PD_PROM,		pd_prom);
+	iic_write_ex(PDMIO,			pdmio);
+	iic_write_ex(PDIO,			pdio);
+	iic_write_ex(HPD_PD,		hpd_pd);
+	iic_write_ex(SCLPD,			sclpd);
+	iic_write_ex(SDPD,			sdpd);
+	iic_write_ex(MEMPD,			mempd);
+	iic_write_ex(DISPON,		dispon);
+
+	iic_write_ex(DACSENCE,			dacsence);
+	iic_write_ex(GCKOFF,			gckoff);
+	iic_write_ex(ZRCTS, 0);
+
+	return ch_true;
+}
+
+ch_bool convert_pll1n1_div(ch_bool pll1n1_to_div, uint8* pll1n1_addr, uint8* div_addr)
+{
+	uint8 val_t;
+
+	if(pll1n1_to_div)
+	{
+		if((*pll1n1_addr) <= 5)
+		{
+			(*div_addr)= 1<<(*pll1n1_addr);
+		}
+		else if((*pll1n1_addr) == 6 || (*pll1n1_addr) == 7)
+		{
+			(*div_addr) = 64;
+		}
+		else
+		{
+			return ch_false;
+		}
+	}
+	else
+	{
+		for(val_t=1; val_t<=6; ++val_t)
+		{
+			if(*div_addr == (1 << val_t))
+			{
+				*pll1n1_addr = val_t;
+				return ch_true;
+			}
+		}
+		return ch_false;
+	}
+	return ch_true;
+}
+
+ch_bool convert_pll1n2_div(ch_bool pll1n2_to_div, uint8* pll1n2_addr, uint8* div_addr)
+{
+	uint8 val_t;
+
+	if(pll1n2_to_div)
+	{
+		if((*pll1n2_addr) <= 3)
+		{
+			*div_addr = 1 << (*pll1n2_addr);
+		}
+		else if((4 == (*pll1n2_addr)) || (6 == (*pll1n2_addr)))
+		{
+			(*div_addr) = 16;
+		}
+		else if((5 == (*pll1n2_addr)) || (7 == (*pll1n2_addr)))
+		{
+			(*div_addr) = 32;
+		}
+		else
+		{
+			return ch_false;
+		}
+	}
+	else
+	{
+		for(val_t=0; val_t<=5; ++val_t)
+		{
+			if(*div_addr == (1 << val_t))
+			{
+				*pll1n2_addr = val_t;
+				return ch_true;
+			}
+		}
+		return ch_false;
+	}
+	return ch_true;
+}
+
+ch_bool convert_pll1n3_div(ch_bool pll1n3_to_div, uint8* pll1n3_addr, uint8* div_addr)
+{
+	uint8 val_t;
+
+	if(pll1n3_to_div)
+	{
+		if((*pll1n3_addr) <= 3)
+		{
+			*div_addr = 1 << (*pll1n3_addr);
+		}
+		else if((4 == (*pll1n3_addr)) || (6 == (*pll1n3_addr)))
+		{
+			(*div_addr) = 16;
+		}
+		else if((5 == (*pll1n3_addr)) || (7 == (*pll1n3_addr)))
+		{
+			(*div_addr) = 32;
+		}
+		else
+		{
+			return ch_false;
+		}
+	}
+	else
+	{
+		for(val_t=0; val_t<=5; ++val_t)
+		{
+			if(*div_addr == (1 << val_t))
+			{
+				*pll1n3_addr = val_t;
+				return ch_true;
+			}
+		}
+		return ch_false;
+	}
+	return ch_true;
+}
+
+ch_bool convert_pll2n5_div(ch_bool pll2n5_to_div, uint8* pll2n5_addr, uint8* div_addr)
+{
+	if(pll2n5_to_div)
+	{
+		switch(*pll2n5_addr)
+		{
+		case 0:
+			*div_addr = 1;
+			break;
+		case 4:
+			*div_addr = 2;
+			break;
+		case 1:
+			*div_addr = 3;
+			break;
+		case 8:
+			*div_addr = 4;
+			break;
+		case 2:
+			*div_addr = 5;
+			break;
+		case 5:
+			*div_addr = 6;
+			break;
+		case 3:
+			*div_addr = 7;
+			break;
+		case 12:
+			*div_addr = 8;
+			break;
+		default :
+			return ch_false;
+		}
+	}
+	else
+	{
+		switch(*div_addr)
+		{
+		case 1:
+			*pll2n5_addr = 0;
+			break;
+		case 2:
+			*pll2n5_addr = 4;
+			break;
+		case 3:
+			*pll2n5_addr = 1;
+			break;
+		case 4:
+			*pll2n5_addr = 8;
+			break;
+		case 5:
+			*pll2n5_addr = 2;
+			break;
+		case 6:
+			*pll2n5_addr = 5;
+			break;
+		case 7:
+			*pll2n5_addr = 3;
+			break;
+		case 8:
+			*pll2n5_addr = 0x0C;
+			break;
+		default :
+			return ch_false;
+		}
+	}
+	return ch_true;
+}
+
+ch_bool convert_pll2n6_div(ch_bool pll2n6_to_div, uint8* pll2n6_addr, uint8* div_addr)
+{
+	if(pll2n6_to_div)
+	{
+		if(*pll2n6_addr <= 3)
+		{
+			(*div_addr)= (*pll2n6_addr) + 5;
+			return ch_true;
+		}
+		return ch_false;
+	}
+	else
+	{
+		if(*div_addr >= 5 && *div_addr <= 8)
+		{
+			*pll2n6_addr = (*div_addr) - 5;
+			return ch_true;
+		}
+		return ch_false;
+	}
+	return ch_true;
+}
+
+ch_bool convert_pll2n7_div(ch_bool pll2n7_to_div, uint8* pll2n7_addr, uint8* div_addr)
+{
+	if(pll2n7_to_div)
+	{
+		if(*pll2n7_addr <= 3)
+		{
+			(*div_addr)= (*pll2n7_addr) + 8;
+			return ch_true;
+		}
+		return ch_false;
+	}
+	else
+	{
+		if(*div_addr >= 8 && *div_addr <= 11)
+		{
+			*pll2n7_addr = (*div_addr) - 8;
+			return ch_true;
+		}
+		return ch_false;
+	}
+	return ch_true;
+}
+
+ch_bool convert_pll3n8_div(ch_bool pll3n8_to_div, uint8* pll3n8_addr, uint8* div_addr)
+{
+	uint8 val_t;
+
+	if(pll3n8_to_div)
+	{
+		if(*pll3n8_addr <= 3)
+		{
+			*div_addr= 1 << (*pll3n8_addr);
+			return ch_true;
+		}
+		return ch_false;
+	}
+	else
+	{
+		for(val_t=0; val_t<=3; ++val_t)
+		{
+			if(*div_addr == (1 << val_t))
+			{
+				*pll3n8_addr = val_t;
+				return ch_true;
+			}
+		}
+        return ch_false;
+	}
+
+	return ch_true;
+}
+
+ch_bool convert_dmxtal_div(ch_bool dmxtal_to_div, uint8* dmxtal_addr, uint8* div_addr)
+{
+	if(dmxtal_to_div)
+	{
+		switch(*dmxtal_addr)
+		{
+		case 0x00:
+			*div_addr = 1;
+			break;
+		case 0x04:
+			*div_addr = 2;
+			break;
+		case 0x08:
+			*div_addr = 3;
+			break;
+		case 0x0C:
+			*div_addr = 4;
+			break;
+		case 0x10:
+			*div_addr = 5;
+			break;
+		case 0x11:
+			*div_addr = 6;
+			break;
+		case 0x12:
+			*div_addr = 7;
+			break;
+		case 0x13:
+			*div_addr = 8;
+			break;
+		case 0x01:
+			*div_addr = 9;
+			break;
+		case 0x14:
+			*div_addr = 10;
+			break;
+		case 0x02:
+			*div_addr = 11;
+			break;
+		case 0x15:
+			*div_addr = 12;
+			break;
+		case 0x03:
+			*div_addr = 13;
+			break;
+		case 0x16:
+			*div_addr = 14;
+			break;
+		case 0x18:
+			*div_addr = 15;
+			break;
+		case 0x17:
+			*div_addr = 16;
+			break;
+		default:
+			return ch_false;
+		}
+	}
+	else
+	{
+		switch(*div_addr)
+		{
+		case 1:
+			*dmxtal_addr = 0x00;
+			break;
+		case 2:
+			*dmxtal_addr = 0x04;
+			break;
+		case 3:
+			*dmxtal_addr = 0x08;
+			break;
+		case 4:
+			*dmxtal_addr = 0x0C;
+			break;
+		case 5:
+			*dmxtal_addr = 0x10;
+			break;
+		case  6:
+			*dmxtal_addr = 0x11;
+			break;
+		case 7:
+			*dmxtal_addr = 0x12;
+			break;
+		case 8:
+			*dmxtal_addr = 0x13;
+			break;
+		case 9:
+			*dmxtal_addr = 0x01;
+			break;
+		case 10:
+			*dmxtal_addr = 0x14;
+			break;
+		case 11:
+			*dmxtal_addr = 0x02;
+			break;
+		case 12:
+			*dmxtal_addr = 0x15;
+			break;
+		case 13:
+			*dmxtal_addr = 0x03;
+			break;
+		case 14:
+			*dmxtal_addr = 0x16;
+			break;
+		case 15:
+			*dmxtal_addr = 0x18;
+			break;
+		case 16:
+			*dmxtal_addr = 0x17;
+			break;
+		default:
+			return ch_false;
+		}
+	}
+	return ch_true;
+}
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.def b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.def
new file mode 100644
index 0000000..566e872
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.def
@@ -0,0 +1,5 @@
+LIBRARY ch7036
+
+EXPORTS
+    get_version
+    dpd_init
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.h
new file mode 100644
index 0000000..85ad2a3
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.h
@@ -0,0 +1,51 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036.h
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+#ifndef _CH7036_H
+#define _CH7036_H
+
+#include "ch7036_typedef.h"
+
+
+
+ch_bool DevicePrepare(DEV_CONTEXT* pDevContext);
+
+
+ch_bool DeviceConfig(DEV_CONTEXT* pDevContext);
+
+
+ch_bool DeviceRunning(DEV_CONTEXT* pDevContext);
+
+
+ch_bool DeviceSetPower(DEV_CONTEXT* pDevContext, unsigned long flags);
+
+
+uint32 GetLastErrorMessage(void);
+
+
+
+#endif
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.c b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.c
new file mode 100644
index 0000000..8317a09
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.c
@@ -0,0 +1,933 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_attr.c
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+
+
+
+#include "ch7036_intf.h"
+#include "ch7036_attr.h"
+#include "ch7036_fw.h"
+#include "lvds/lvds.h"
+
+
+static pd_attr_t g_ch7036_attrs[] =
+{
+
+
+
+	PD_MAKE_ATTR (PD_ATTR_ID_HPOSITION,   PD_ATTR_TYPE_RANGE, "H Pos.",  0, DEFAULT_POSITION,	DEFAULT_POSITION,                    0,  4096,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_VPOSITION,   PD_ATTR_TYPE_RANGE, "V Pos.",  0, DEFAULT_POSITION,	DEFAULT_POSITION,                    0,  4096,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_HSCALE,   PD_ATTR_TYPE_RANGE, "H_Scale",  0, HDMI_DEFAULT_UNDERSCAN,   HDMI_DEFAULT_UNDERSCAN,  0,  20,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_VSCALE,   PD_ATTR_TYPE_RANGE, "V_Scale",  0, HDMI_DEFAULT_UNDERSCAN,     HDMI_DEFAULT_UNDERSCAN,   0,  20,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_HSCALE_CRT,   PD_ATTR_TYPE_RANGE, "H_Scale",  0, CRT_DEFAULT_UNDERSCAN,   CRT_DEFAULT_UNDERSCAN,  0,  20,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_VSCALE_CRT,   PD_ATTR_TYPE_RANGE, "V_Scale",  0, CRT_DEFAULT_UNDERSCAN,   CRT_DEFAULT_UNDERSCAN,  0,  20,  1),
+
+
+
+	PD_MAKE_ATTR (PD_ATTR_ID_DITHER_BYPASS, PD_ATTR_TYPE_BOOL, "Quality Enhancement",  0, 0,                 1,                 0, 0, 0),
+
+	PD_MAKE_ATTR (PD_ATTR_ID_PLL_REF_DLY, PD_ATTR_TYPE_BOOL, "Pll Reference Delay",PD_ATTR_FLAG_USER_INVISIBLE, 0,0,0, 0, 0),
+	PD_MAKE_ATTR (PD_ATTR_ID_PLL_REF_FBDLY,PD_ATTR_TYPE_BOOL, "Pll Reference FBDelay",PD_ATTR_FLAG_USER_INVISIBLE, 1,   1, 0, 0, 0),
+
+	PD_MAKE_ATTR (PD_ATTR_ID_LOAD_FIRMWARE,PD_ATTR_TYPE_BOOL, "Load Firmware",PD_ATTR_FLAG_USER_INVISIBLE, 0,   1, 0, 0, 0),
+	PD_MAKE_ATTR (PD_ATTR_ID_REFRESH,PD_ATTR_TYPE_BOOL, "Refresh",0, 0,   0, 0, 0, 0),
+
+
+};
+
+
+
+
+static ch7036_attr_list_entry_t g_list_entry_hdmi[] =
+{
+	{OUT_HDMI_720x480P_59,		"720x480p_59",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_720x480P_60,		"720x480p_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_1280x720P_59,    "1280x720p_59",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_1280x720P_60,    "1280x720p_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_1920x1080I_59,   "1920x1080i_59",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_1920x1080I_60,   "1920x1080i_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_1920x1080P_59,   "1920x1080p_59",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_1920x1080P_60,   "1920x1080p_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_720x576P_50,     "720x576p_50",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_1280x720P_50,    "1280x720p_50",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_1920x1080I_50,   "1920x1080i_50",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_1920x1080P_50,   "1920x1080i_50",PD_ATTR_FLAG_DYNAMIC},
+	{0, NULL,0}
+};
+
+
+
+static ch7036_attr_list_entry_t g_list_entry_dvi[] =
+{
+
+	{OUT_DVI_800x600_60,	"800x600_60",PD_ATTR_FLAG_DYNAMIC},
+
+
+	{OUT_DVI_1024x768_60,	"1024x768_60",PD_ATTR_FLAG_DYNAMIC},
+
+
+
+
+	{OUT_DVI_1280x720_60,   "1280x720_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1280x800_60,   "1280x800_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1280x960_60,    "1280x960_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1280x1024_60,   "1280x1024_60",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_DVI_1360x768_60,    "1360x768_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1366x768_60,    "1366x768_60",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_DVI_1400x1050_60,   "1400x1050_60",PD_ATTR_FLAG_DYNAMIC},
+
+
+
+	{OUT_DVI_1600x900_60,    "1600x900_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1600x1200_60,   "1600x1200_60",PD_ATTR_FLAG_DYNAMIC},
+
+
+	{OUT_DVI_1920x1080_60,   "1920x1080_60",PD_ATTR_FLAG_DYNAMIC},
+	{0, NULL,0}
+};
+
+
+
+static ch7036_attr_list_entry_t g_list_entry_crt[] =
+{
+	{OUT_CRT_800x600_60, "800x600_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_800x600_72, "800x600_72",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_800x600_75, "800x600_75",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_1024x768_60,"1024x768_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1024x768_70,"1024x768_70",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1024x768_75,"1024x768_75",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1280x1024_60,"1280x1024_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1600x1200_60,"1600x1200_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1920x1080_60,"1920x1080_60",PD_ATTR_FLAG_DYNAMIC},
+	{0, NULL,0}
+};
+
+
+static ch7036_attr_list_entry_t g_list_entry_channel[] =
+{
+	{CHANNEL_LVDS_HDMI, "LVDS_HDMI",PD_ATTR_FLAG_DYNAMIC},
+	{CHANNEL_LVDS_DVI, "LVDS_DVI",PD_ATTR_FLAG_DYNAMIC},
+	{CHANNEL_LVDS_VGA,  "LVDS_VGA",PD_ATTR_FLAG_DYNAMIC},
+	{0, NULL,0}
+};
+
+static ch7036_attr_list_header_t g_list_header[] =
+{
+	{3, PD_ATTR_ID_DISPLAY,"Display Channel", 1,1,
+	g_list_entry_channel},
+
+	{12, PD_ATTR_ID_HDMI_OUT_MODE, "HDMI",4,4,
+	 g_list_entry_hdmi},
+
+	{12, PD_ATTR_ID_DVI_OUT_MODE,"DVI", 2,2,
+	 g_list_entry_dvi},
+
+	{9, PD_ATTR_ID_CRT_OUT_MODE, "VGA", 4,4,
+	 g_list_entry_crt},
+
+	{ 0 }
+};
+
+
+
+ch7036_status_t ch7036_init_attribute_table(ch7036_device_context_t *p_ctx, ch7036_attr_list_header_t* p_list_header)
+{
+	unsigned long ch7036_num_attrs, num_attrs;
+	unsigned char *p_table;
+	/* ch7036_status_t status; */
+
+
+
+	ch7036_num_attrs = ch7036_enumerate_attr_table(p_ctx, NULL, p_list_header);
+	PD_DEBUG("ch7036_init_attribute_table- ch7036 num_attr = [%u]\n",ch7036_num_attrs);
+
+
+	p_ctx->ch7036_num_attrs =  ch7036_num_attrs ;
+
+
+	if(p_ctx->p_ch7036_attr_table) {
+		pd_free(p_ctx->p_ch7036_attr_table);
+		p_ctx->p_ch7036_attr_table = NULL;
+	}
+
+
+	if(p_ctx->p_ch7036_attr_table == NULL) {
+
+		p_ctx->p_ch7036_attr_table = pd_malloc((p_ctx->ch7036_num_attrs + 1) * sizeof(pd_attr_t));
+
+		if (p_ctx->p_ch7036_attr_table == NULL) {
+			PD_ERROR("ch7036: Error ! ch7036_init_attribute_table: pd_malloc() failed allocating ch7036_attr_table");
+
+			return SS_MEM_ALLOC_ERR;
+		}
+
+		pd_memset(p_ctx->p_ch7036_attr_table, 0, (p_ctx->ch7036_num_attrs + 1) *
+			sizeof(pd_attr_t));
+
+	}
+
+
+	p_table = (unsigned char *)p_ctx->p_ch7036_attr_table;
+
+
+	if (p_ctx->ch7036_num_attrs  > 0) {
+
+		num_attrs = ch7036_enumerate_attr_table(p_ctx, (pd_attr_t *)p_table, p_list_header);
+
+
+		PD_DEBUG("ch7036_init_attribute_table: ch7036_enumerate_attr_table()- returned %ld entries, expected %ld\n",
+					  num_attrs, p_ctx->ch7036_num_attrs) ;
+
+	}
+
+
+	return SS_SUCCESS;
+
+}
+
+
+
+unsigned long ch7036_enumerate_attr_table (ch7036_device_context_t *p_ctx,
+	pd_attr_t *p_attr, ch7036_attr_list_header_t* p_list_header)
+{
+
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	/*OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info; */
+
+	unsigned long num_attrs, i, j, num_attrs_static;
+	/*ch7036_status_t status;*/
+	ch7036_attr_list_entry_t *list_item;
+	int ret;
+	pd_attr_t *p_table;
+
+	list_item = NULL;
+	num_attrs = 0;
+	i = j = 0;
+
+
+	PD_DEBUG("ch7036_enumerate_attr_table- enter\n");
+
+
+
+	if ( p_list_header == NULL ){
+		p_list_header = g_list_header;
+	}
+
+	if (p_attr == NULL) {
+
+		if(p_ctx->p_ch7036_attr_table == NULL) {
+			ret = PD_INTERNAL_LVDS_MODULE_GET_ATTRIBUTES(ch7036_lvds_get_attrs,(p_ctx->internal_lvds,&(p_ctx->lvds_num_attrs),&(p_ctx->p_lvds_attr_table)));
+
+			if(ret != PD_SUCCESS)
+				PD_DEBUG("ch7036_enumerate_attr_table: lvds_get_attributes() return ERROR! check this routine\n");
+			else
+				PD_DEBUG("ch7036_enumerate_attr_table: lvds_get_attributes()- lvds num_attr = [%u]\n",p_ctx->lvds_num_attrs);
+		}
+
+
+
+		while (p_list_header[i].num_entries) {
+
+
+			num_attrs += (p_list_header[i].num_entries + 1);
+			++i;
+		}
+
+		num_attrs += ((sizeof(g_ch7036_attrs)/sizeof(pd_attr_t)) + p_ctx->lvds_num_attrs) ;
+
+		return num_attrs;
+	}
+
+
+	if(p_ctx->lvds_num_attrs > 0) {
+
+		pd_attr_t *p_lvds_des, *p_lvds_src ;
+
+
+		p_lvds_src=  (pd_attr_t *)p_ctx->p_lvds_attr_table;
+		p_lvds_des = (pd_attr_t *)p_attr;
+
+		pd_memcpy(p_lvds_des, p_lvds_src, (p_ctx->lvds_num_attrs)*sizeof(pd_attr_t));
+		num_attrs += p_ctx->lvds_num_attrs;
+
+		for (i=0 ; i < p_ctx->lvds_num_attrs; i++, p_lvds_des++) {
+
+			PD_DEBUG("ch7036 : ch7036_enumerate_attr_table : \n"
+				  "adding lvds attr='%s', id=%ld, default=%ld, current=%ld, \n",
+				  p_lvds_des->name, p_lvds_des->id, p_lvds_des->default_value, p_lvds_des->current_value);
+		}
+
+	}
+
+	PD_DEBUG("ch7036 : ch7036_enumerate_attr_table adding lvds num attrs = %ld \n", num_attrs);
+
+	i=0;
+
+	while (p_list_header[i].num_entries) {
+
+		pd_list_attr_t *p_hdr = (pd_list_attr_t *) &p_attr[num_attrs - 1];
+
+		p_hdr->type	= PD_ATTR_TYPE_LIST;
+		p_hdr->id = p_list_header[i].id;
+		p_hdr->num_entries = p_list_header[i].num_entries;
+		p_hdr->flags |= PD_ATTR_FLAG_DYNAMIC;
+
+		p_hdr->current_index = p_list_header[i].current_index;
+		pd_strcpy(p_hdr->name, p_list_header[i].p_name);
+
+		p_hdr->default_index = p_list_header[i].default_index;
+
+		PD_DEBUG("ch7036 : ch7036_enumerate_attr_table : \n"
+				  "adding attr - list header='%s', id=%ld, default=%ld, current=%ld, \n"
+				  "num_entries=%ld\n",
+				  p_hdr->name, p_hdr->id, p_hdr->default_index, p_hdr->current_index,
+				  p_hdr->num_entries);
+
+		++num_attrs;
+
+
+
+		list_item = p_list_header[i].attr_list;
+		for (j = 0; j < p_list_header[i].num_entries; ++j, ++num_attrs) {
+
+			pd_list_entry_attr_t *p_entry =
+				(pd_list_entry_attr_t *)&p_attr[num_attrs - 1];
+
+			p_entry->id		= p_list_header[i].id;
+			p_entry->type	= PD_ATTR_TYPE_LIST_ENTRY;
+			p_entry->value	= list_item[j].id;
+
+
+			p_entry->flags  = list_item[j].flags;
+
+
+
+
+
+
+
+
+			pd_strcpy(p_entry->name, list_item[j].p_name);
+
+
+
+			PD_DEBUG("ch7036 : ch7036_enumerate_attr_table : list entry[%ld]=%s, id=%ld, "
+					  "value=%ld, flags=0x%x \n",
+					  j, p_entry->name, p_entry->id,
+					  p_entry->value, (unsigned char)p_entry->flags);
+
+		}
+
+		++i;
+	}
+
+
+	p_table = (pd_attr_t *)&p_attr[num_attrs - 1];
+
+	num_attrs_static = sizeof(g_ch7036_attrs)/sizeof(pd_attr_t);
+	pd_memcpy(p_table, g_ch7036_attrs,num_attrs_static*sizeof(pd_attr_t));
+
+	for (i=0 ; i < num_attrs_static; i++, p_table++) {
+
+		PD_DEBUG("ch7036 : ch7036_enumerate_attr_table : \n"
+				  "adding ch7036 static attr='%s', id=%ld, default=%ld, current=%ld, \n",
+				  p_table->name, p_table->id, p_table->default_value, p_table->current_value);
+
+	}
+
+	num_attrs += num_attrs_static;
+
+
+	return num_attrs;
+
+}
+
+
+
+void ch7036_set_dither(ch7036_device_context_t* p_ctx)
+{
+	uint8 reg=0x00;
+	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
+
+	I2CWrite(p_ch_ctx,0x03, 0x04);
+	reg = I2CRead(p_ch_ctx,0x57);
+    reg = reg & 0x3F;
+
+
+	switch(p_ctx->dither_select)
+	{
+		  case DITHER_18_TO_18:
+			  break;
+		  case DITHER_18_TO_24:
+			  reg = reg | 0x40;
+			  break;
+		  case DITHER_24_TO_18:
+			  reg = reg | 0x80;
+			  break;
+		  case DITHER_24_TO_24:
+			  reg = reg | 0xC0;
+			  break;
+		  default:
+			 break;
+    }
+	I2CWrite(p_ch_ctx,0x57, reg);
+
+	return;
+}
+
+
+
+void ch7036_set_audio_type(INPUT_INFO* pInput_Info, uint8 id)
+{
+
+	pInput_Info->audio_type = id;
+
+	if(pInput_Info->audio_type == AUDIO_I2S) {
+
+
+
+
+		pInput_Info->i2s_pol = 0;
+		pInput_Info->i2s_len = 0;
+		pInput_Info->i2s_fmt = 0;
+
+	}
+}
+
+
+
+ch7036_status_t ch7036_set_output_channel(void* p_context, uint32 channel)
+{
+	ch7036_device_context_t * p_ctx= (ch7036_device_context_t *)p_context;
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+	pd_attr_t *p_attr_hdmi, *p_attr_crt, *p_attr_dvi;
+	pd_attr_t *p_attr_hscale, *p_attr_vscale, *p_attr_hscale_crt, *p_attr_vscale_crt, *p_attr_hp, *p_attr_vp, *p_attr_disp;
+	pd_attr_t* p_attr_dither;
+	/*unsigned long id;*/
+
+
+	PD_DEBUG("ch7036_set_output_channel- channel [%x]\n", channel);
+
+
+	pOutput_Info->channel = channel;
+
+
+	p_attr_disp = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+				PD_ATTR_ID_DISPLAY, PD_GET_ATTR_LIST);
+
+	p_attr_disp->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+	p_attr_dvi = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+				PD_ATTR_ID_DVI_OUT_MODE, PD_GET_ATTR_LIST);
+
+	p_attr_hdmi = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+				PD_ATTR_ID_HDMI_OUT_MODE, PD_GET_ATTR_LIST);
+
+
+	p_attr_crt = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+			PD_ATTR_ID_CRT_OUT_MODE, PD_GET_ATTR_LIST);
+
+
+	p_attr_hscale_crt = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+			PD_ATTR_ID_HSCALE_CRT, 0);
+	p_attr_vscale_crt = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+			PD_ATTR_ID_VSCALE_CRT, 0);
+
+	p_attr_hscale = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+			PD_ATTR_ID_HSCALE, 0);
+	p_attr_vscale = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+			PD_ATTR_ID_VSCALE, 0);
+
+	p_attr_hp = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+				PD_ATTR_ID_HPOSITION, 0);
+	p_attr_vp = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+				PD_ATTR_ID_VPOSITION, 0);
+
+	p_attr_dither = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+				PD_ATTR_ID_DITHER_BYPASS, 0);
+
+
+
+	if(pOutput_Info->channel & CHANNEL_HDMI) {
+
+		if(pOutput_Info->hdmi_fmt.is_dvi_mode) {
+
+			if(p_attr_hdmi)
+				p_attr_hdmi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+			p_attr_dvi->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+
+			p_attr_dvi += p_attr_dvi->current_value;
+			p_ctx->dvi_mode_index = ((pd_list_entry_attr_t *)p_attr_dvi)->value;
+
+			PD_DEBUG("ch7036_set_output_channel- dvi mode index [%ld]\n",p_ctx->dvi_mode_index);
+
+
+
+		}
+		else {
+
+			p_attr_hdmi->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+			if(p_attr_dvi)
+				p_attr_dvi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+
+			p_attr_hdmi += p_attr_hdmi->current_value;
+			p_ctx->hdmi_mode_index = ((pd_list_entry_attr_t *)p_attr_hdmi)->value;
+
+			PD_DEBUG("ch7036_set_output_channel- hdmi mode index [%ld]\n",p_ctx->hdmi_mode_index);
+
+		}
+
+
+
+		if(p_attr_crt)
+			p_attr_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+		//hdmi/dvi- hide it from user
+		p_attr_hscale_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vscale_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		//h/v pos scale- hide it
+		p_attr_hp->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vp->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+
+		//show it
+		p_attr_hscale->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vscale->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+
+		p_attr_dither->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+
+		PD_DEBUG("ch7036_set_output_channel-current hscale value [%d]\n",(uint8)p_attr_hscale->current_value);
+		PD_DEBUG("ch7036_set_output_channel-current vscale value [%d]\n",(uint8)p_attr_vscale->current_value);
+
+		ch7036_set_scaling(pOutput_Info,PD_ATTR_ID_HSCALE,(uint8)p_attr_hscale->current_value);
+		ch7036_set_scaling(pOutput_Info,PD_ATTR_ID_VSCALE,(uint8)p_attr_vscale->current_value);
+
+
+
+
+	} else if (pOutput_Info->channel & CHANNEL_VGA) {
+
+		p_attr_crt->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+		if(p_attr_hdmi)
+			p_attr_hdmi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+		if(p_attr_dvi)
+			p_attr_dvi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+		p_attr_crt += p_attr_crt->current_value;
+		p_ctx->crt_mode_index = ((pd_list_entry_attr_t *)p_attr_crt)->value;
+
+		PD_DEBUG("ch7036_set_output_channel- crt mode index [%ld\n",p_ctx->crt_mode_index);
+
+
+		p_attr_hscale_crt->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vscale_crt->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+		p_attr_hp->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vp->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+		p_attr_dither->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+
+		p_attr_hscale->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vscale->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+		PD_DEBUG("ch7036_set_output_channel-current hscale_crt value [%d]\n",(uint8)p_attr_hscale_crt->current_value);
+		PD_DEBUG("ch7036_set_output_channel-current vscale_crt value [%d]\n",(uint8)p_attr_vscale_crt->current_value);
+
+
+		ch7036_set_scaling(pOutput_Info,PD_ATTR_ID_HSCALE_CRT,(uint8)p_attr_hscale_crt->current_value);
+		ch7036_set_scaling(pOutput_Info,PD_ATTR_ID_VSCALE_CRT,(uint8)p_attr_vscale_crt->current_value);
+
+
+	} else {
+
+		if(p_attr_crt)
+			p_attr_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		if(p_attr_hdmi)
+			p_attr_hdmi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		if(p_attr_dvi)
+			p_attr_dvi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+
+		p_attr_hscale->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vscale->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+		p_attr_hscale_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vscale_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+		p_attr_hp->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vp->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+		p_attr_dither->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+
+	}
+
+
+	return SS_SUCCESS;
+}
+unsigned long ch7036_get_output_channel(void* p_context)
+{
+	ch7036_device_context_t * p_ctx= (ch7036_device_context_t *)p_context;
+	pd_list_entry_attr_t *p_attr;
+
+	PD_DEBUG("ch7036_get_output_channel- enter\n");
+
+	p_attr = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+			PD_ATTR_ID_DISPLAY, PD_GET_ATTR_LIST_ENTRY);
+
+	return (p_attr->value);
+}
+
+ch7036_status_t ch7036_set_position(ch7036_device_context_t *p_ctx, uint8 attr_id, uint16 pos)
+{
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	/*OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;*/
+	uint8 reg;
+
+	PD_DEBUG("ch7036_set_position- enter\n");
+	I2CWrite(p_ch7xxx_context,0x03, 0x00);
+	reg = I2CRead(p_ch7xxx_context,0x39);
+
+	if(attr_id == PD_ATTR_ID_HPOSITION) {
+		reg = reg & 0xF0;
+		I2CWrite(p_ch7xxx_context,0x3A, (pos & 0x00FF));
+		reg = ((pos >> 8) & 0x0F) | reg;
+		iic_write_ex(HP,pos);
+	}
+	else {
+		reg = reg & 0x0F;
+		I2CWrite(p_ch7xxx_context,0x3B, (pos & 0x00FF));
+		reg = (((pos >> 8) & 0x0F) << 4) | reg;
+		iic_write_ex(VP,pos);
+	}
+
+	I2CWrite(p_ch7xxx_context,0x39, reg);
+
+	return SS_SUCCESS;
+}
+
+
+void ch7036_set_hdmi_sync_polarity(OUTPUT_INFO* pOutput_Info)
+{
+
+	if((pOutput_Info->channel & CHANNEL_HDMI)&&(pOutput_Info->channel & CHANNEL_VGA))
+	{
+		if (pOutput_Info->timing.ha > 720) {
+			pOutput_Info->hdmi_fmt.hs_pol = POL_HIGH;
+			pOutput_Info->hdmi_fmt.vs_pol = POL_HIGH;
+			if(pOutput_Info->timing.ha == 1440 )
+			{
+              pOutput_Info->hdmi_fmt.hs_pol = POL_LOW;
+			  pOutput_Info->hdmi_fmt.vs_pol = POL_LOW;
+			}
+		}
+		else if(pOutput_Info->timing.ha <= 720){
+
+			pOutput_Info->hdmi_fmt.hs_pol = POL_LOW;
+			pOutput_Info->hdmi_fmt.vs_pol = POL_LOW;
+		}
+	}
+
+
+	if((pOutput_Info->channel & CHANNEL_HDMI) && ((pOutput_Info->channel & CHANNEL_VGA) == 0x00))
+	{
+		pOutput_Info->hdmi_fmt.hs_pol = POL_LOW;
+		pOutput_Info->hdmi_fmt.vs_pol = POL_LOW;
+	}
+
+}
+
+void ch7036_set_quality_enhancement(ch7036_device_context_t *p_ctx, uint8 checked)
+{
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	PREFER_INFO* pPrefer_Info = p_ch7xxx_context->pPrefer_Info;
+	uint8 reg;
+
+	PD_DEBUG("ch7036_set_quality_enhancement- enter\n");
+	I2CWrite(p_ch7xxx_context,0x03, 0x00);
+	reg = I2CRead(p_ch7xxx_context,0x19);
+
+	if(checked)
+		reg = reg & 0xBF;
+	else
+		reg = reg | 0x40;
+
+	I2CWrite(p_ch7xxx_context,0x19, reg);
+
+
+	pPrefer_Info->dither_filter_enable = checked?DITHER_ENABLE:DITHER_BYPASS;
+
+
+	iic_write_ex(DBP, checked?DITHER_ENABLE:DITHER_BYPASS);
+
+}
+
+void ch7036_set_scaling (OUTPUT_INFO* pOutput_Info, unsigned long id, uint8 value)
+{
+	uint8* p_scale;
+
+	PD_DEBUG("ch7036_set_scaling- enter- value [%d]\n", value);
+
+	if(id == PD_ATTR_ID_HSCALE || id == PD_ATTR_ID_HSCALE_CRT)
+		p_scale= &(pOutput_Info->ds_percent_h);
+	else
+		p_scale= &(pOutput_Info->ds_percent_v);
+
+	switch(value) {
+		case 20: *p_scale = 0; break;
+		case 19: *p_scale = 1; break;
+		case 18: *p_scale = 2; break;
+		case 17: *p_scale = 3; break;
+		case 16: *p_scale = 4; break;
+		case 15: *p_scale = 5; break;
+		case 14: *p_scale = 6; break;
+		case 13: *p_scale = 7; break;
+		case 12: *p_scale = 8; break;
+		case 11: *p_scale = 9; break;
+		case 10: *p_scale = 10; break;
+
+		case 9: *p_scale = 11; break;
+		case 8: *p_scale = 12; break;
+		case 7: *p_scale = 13; break;
+		case 6: *p_scale = 14; break;
+		case 5: *p_scale = 15; break;
+		case 4: *p_scale = 16; break;
+		case 3: *p_scale = 17; break;
+		case 2: *p_scale = 18; break;
+		case 1: *p_scale = 19; break;
+		case 0: *p_scale = 20; break;
+		default: break;
+
+	}
+
+	return;
+
+}
+
+void ch7036_set_rotate (OUTPUT_INFO* pOutput_Info)
+{
+
+
+	pOutput_Info->rotate = DEFAULT_ROTATE;
+}
+
+void ch7036_set_hflip (OUTPUT_INFO* pOutput_Info)
+{
+
+
+	pOutput_Info->h_flip = DEFAULT_HFLIP;
+}
+void ch7036_set_vflip (OUTPUT_INFO* pOutput_Info)
+{
+
+
+	pOutput_Info->v_flip = DEFAULT_VFLIP;
+}
+
+void ch7036_set_text_enhancement (PREFER_INFO* pPrefer_Info)
+{
+
+
+	pPrefer_Info->text_enhancement = DEFAULT_TEXT_ENHANCE;
+}
+
+
+void ch7036_set_pll_refdly(PREFER_INFO* pPrefer_Info)
+{
+	pPrefer_Info->pll_ref_dly = DEF_PLL_REF_DLY;
+}
+
+void ch7036_set_pll_fbdly(PREFER_INFO* pPrefer_Info)
+{
+	pPrefer_Info->pll_ref_fbdly = DEF_PLL_REF_FBDLY;
+}
+
+void ch7036_set_lvds_txdrv_ctrl(PREFER_INFO* pPrefer_Info)
+{
+	pPrefer_Info->lvds_txdrv_ctrl = DEF_LVDS_TXDRV_CTRL;
+}
+
+
+
+ch7036_status_t ch7036_alter_display_list (ch7036_device_context_t *p_ctx)
+{
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	/*OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;*/
+
+
+	pd_list_entry_attr_t  *list_item;
+
+	ch7036_edid_blk_t* p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
+	ch7036_edid_blk_t* p_cedid = (ch7036_edid_blk_t *)p_ctx->cedid;
+
+	PD_DEBUG("ch7036_alter_display_list- enter\n");
+
+
+	switch (p_ctx->hpd & 0x22) {
+
+		case 0x22:
+		case 0x20:
+
+			if(p_ctx->hpd & 0x40) {
+
+				ch7036_read_edid(p_ctx);
+
+				if( p_hedid && p_hedid->is_edid) {
+					ch7036_get_hdvi_display_modes_supported(p_ctx);
+
+					PD_DEBUG("ch7036_alter_display_list=> hdmi-dvi hpd is good,edid success- proceed to alter attr table...\n");
+				}
+				else {
+
+					PD_DEBUG("ch7036_alter_display_list=> hpd hdmi-dvi is good, edid failed- use default attr table- show all modes..\n");
+
+				}
+
+
+			}
+			else {
+
+				PD_DEBUG("ch7036_alter_display_list=> hpd hdmi/dvi status is not change, attached... check if edid read needed...\n");
+				ch7036_redo_edid_if_needed(p_ctx, (void *)p_hedid);
+			}
+
+
+			list_item = ch7036_get_updated_display_ouput_entry(p_ctx, CHANNEL_HDMI);
+			ch7036_set_output_channel((void *)p_ctx, (uint32)list_item->value );
+
+			break;
+
+		case 0x02:
+
+			PD_DEBUG("ch7036_alter_display_list=> crt only, no hdmi/dvi- hide hdmi/dvi list entry...\n");
+
+			if(p_ctx->hpd & 0x04) {
+
+				ch7036_read_edid(p_ctx);
+
+				if(p_cedid->is_edid) {
+
+					PD_DEBUG("ch7036_alter_display_list=> hpd crt status changed, edid is a success, proceed ..\n");
+
+				}
+				else {
+
+					PD_DEBUG("ch7036_alter_display_list=> hpd crt is good, edid failed- use default attr table- show all modes..\n");
+
+				}
+
+
+			}
+
+			else  {
+				PD_DEBUG("ch7036_alter_display_list=> crt hpd status is not change, attached... check if edid read needed...\n");
+				ch7036_redo_edid_if_needed(p_ctx, (void *)p_cedid);
+			}
+
+
+			list_item = ch7036_get_updated_display_ouput_entry(p_ctx, CHANNEL_VGA);
+			ch7036_set_output_channel((void *)p_ctx, (uint32)list_item->value );
+
+			break;
+
+		default:
+
+			PD_DEBUG("ch7036_alter_display_list=> hdmi/dvi/vga devices appeared detached...\n");
+
+			if (!p_ctx->init_done)
+				list_item = ch7036_get_updated_display_ouput_entry(p_ctx, CHANNEL_VGA);
+			else
+				list_item = ch7036_get_updated_display_ouput_entry(p_ctx, CHANNEL_LVDS);
+
+			ch7036_set_output_channel((void *)p_ctx, (uint32)list_item->value );
+
+
+#if 0
+			if (p_ctx->init_done)
+				ch7036_device_set_power(p_ctx, (uint32)list_item->value);
+#endif
+
+		break;
+
+
+	}
+
+
+	return SS_SUCCESS;
+
+}
+
+pd_list_entry_attr_t *ch7036_get_updated_display_ouput_entry(ch7036_device_context_t *p_ctx, uint32 channel)
+{
+
+	pd_list_entry_attr_t  *list_item;
+
+	list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DISPLAY,
+					PD_GET_ATTR_LIST_ENTRY);
+
+	list_item->value = (list_item->value & 0xF1) | channel;
+
+	return list_item;
+}
+
+void ch7036_redo_edid_if_needed(ch7036_device_context_t *p_ctx, void* p_edidblk)
+{
+	ch7036_edid_blk_t* p_edid = (ch7036_edid_blk_t *)p_edidblk;
+
+	if (!p_ctx->init_done) {
+
+			PD_DEBUG("ch7036_alter_list: ch7036_check_if_edid_read_needed=> attached, hpd status is not changed at init., read edid...\n");
+			ch7036_read_edid(p_ctx);
+	}
+	else {
+
+		if(!p_edid->is_edid) {
+			PD_DEBUG("ch7036_alter_list: ch7036_check_if_edid_read_needed=>attached, hpd status is not changed, never read edid or edid failed, read it now..\n");
+			ch7036_read_edid(p_ctx);
+		}
+		else
+			PD_DEBUG("ch7036_alter_list: ch7036_check_if_edid_read_needed=> attached, hpd status is not changed, edid was read, abort read edid request...\n");
+	}
+
+}
+
+
+
+
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.h
new file mode 100644
index 0000000..6745088
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.h
@@ -0,0 +1,85 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_attr.h
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+
+
+#include <linux/kernel.h>
+
+#ifndef _CH7036_ATTR_H_
+#define _CH7036_ATTR_H_
+
+typedef struct {
+	unsigned long id;
+	char *p_name;
+	unsigned long flags;
+
+} ch7036_attr_list_entry_t;
+
+typedef struct {
+	unsigned char num_entries;
+	unsigned long id;
+	char *p_name;
+	unsigned long default_index;
+	unsigned long current_index;
+	ch7036_attr_list_entry_t *attr_list;
+
+} ch7036_attr_list_header_t;
+
+
+unsigned long ch7036_enumerate_attr_table(ch7036_device_context_t *p_ctx,pd_attr_t *p_attr,ch7036_attr_list_header_t* p_list_header);
+ch7036_status_t ch7036_init_attribute_table(ch7036_device_context_t *p_ctx,ch7036_attr_list_header_t* p_list_header);
+
+
+void ch7036_set_hdmi_sync_polarity(OUTPUT_INFO* pOutput_Info);
+void ch7036_set_audio_type(INPUT_INFO* pInput_Info, uint8 id);
+void ch7036_set_scaling (OUTPUT_INFO* pOutput_Info, unsigned long id, uint8 value );
+ch7036_status_t ch7036_set_position(ch7036_device_context_t *p_ctx, uint8 attr_id, uint16 pos);
+
+
+void ch7036_set_rotate (OUTPUT_INFO* pOutput_Info);
+void ch7036_set_hflip (OUTPUT_INFO* pOutput_Info);
+void ch7036_set_vflip (OUTPUT_INFO* pOutput_Info);
+
+ch7036_status_t ch7036_set_output_channel(void* p_context, uint32 channel);
+unsigned long ch7036_get_output_channel(void* p_context);
+ch7036_status_t ch7036_alter_display_list (ch7036_device_context_t *p_ctx);
+
+pd_list_entry_attr_t * ch7036_get_updated_display_ouput_entry(ch7036_device_context_t *p_ctx, uint32 channel);
+
+void ch7036_set_text_enhancement (PREFER_INFO* pPrefer_Info);
+void ch7036_set_quality_enhancement(ch7036_device_context_t *p_ctx, uint8 val);
+
+void ch7036_set_pll_refdly(PREFER_INFO* pPrefer_Info);
+void ch7036_set_pll_fbdly(PREFER_INFO* pPrefer_Info);
+void ch7036_set_lvds_txdrv_ctrl(PREFER_INFO* pPrefer_Info);
+
+void ch7036_set_dither(ch7036_device_context_t* p_ctx);
+
+void ch7036_redo_edid_if_needed(ch7036_device_context_t *p_ctx, void* p_edidblk);
+
+
+#endif
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_def_regmap.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_def_regmap.h
new file mode 100644
index 0000000..4858c63
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_def_regmap.h
@@ -0,0 +1,700 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_def_regmap.h
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+#ifndef _CH7036_DEF_REGMAP_H
+#define _CH7036_DEF_REGMAP_H
+
+#include "ch7036_typedef.h"
+
+
+
+#define REG_PAGE_NUM		5
+#define REG_NUM_PER_PAGE	0x80
+
+static uint8 g_DefRegMap[5][0x80] = {
+
+	{
+	0x56,
+	0xF0,
+	0xF3,
+	0x00,
+	0x36,
+	0x58,
+	0xAC,
+	0xDD,
+	0x0F,
+	0x1F,
+	0xB4,
+	0x1A,
+	0x80,
+	0x20,
+	0x00,
+	0x10,
+	0x60,
+	0x11,
+	0xE0,
+	0x0D,
+	0x00,
+	0x0A,
+	0x02,
+	0x00,
+	0x00,
+	0xF8,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x1A,
+	0x80,
+	0x20,
+	0x00,
+	0x10,
+	0x60,
+	0x11,
+	0xE0,
+	0x0D,
+	0x00,
+	0x0A,
+	0x02,
+	0x08,
+	0x00,
+	0x00,
+	0x3C,
+	0x00,
+	0x01,
+	0x01,
+	0xC0,
+	0x01,
+	0x01,
+	0x80,
+	0x40,
+	0x40,
+	0x47,
+	0x88,
+	0x00,
+	0x00,
+	0x00,
+	0x86,
+	0x00,
+	0x11,
+	0x0E,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x40,
+	0x40,
+	0x80,
+	0x00,
+	0x00,
+	0x00,
+	0x1F,
+	0xFF,
+	0x00,
+	0x80,
+	0x10,
+	0x60,
+	0x00,
+	0x0A,
+	0x02,
+	0x08,
+	0x00,
+	0x00,
+	0x00,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x2D,
+	0x90,
+	0x20,
+	0x22,
+	0x44,
+	0x24,
+	0x40,
+	0x00,
+	0x10,
+	0x00,
+	0xA0,
+	0x4B,
+	0x18,
+	0x01,
+	0x00,
+	0x00,
+	0x20,
+	0x80,
+	0x18,
+	0x00,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0x0F,
+	0x00,
+	},
+
+
+	{
+	0x56,
+	0xF0,
+	0xF3,
+	0x01,
+	0x36,
+	0x58,
+	0xAC,
+	0x20,
+	0x00,
+	0x4B,
+	0x00,
+	0x6D,
+	0x6A,
+	0x51,
+	0x93,
+	0x1C,
+	0x00,
+	0x08,
+	0xC5,
+	0xA8,
+	0x91,
+	0x68,
+	0x29,
+	0x0E,
+	0xC8,
+	0x42,
+	0x6C,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x10,
+	0x07,
+	0xFF,
+	0xB6,
+	0x10,
+	0x00,
+	0x00,
+	0x15,
+	0x18,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x0B,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x08,
+	0x60,
+	0x14,
+	0x20,
+	0x00,
+	0x00,
+	0x20,
+	0x00,
+	0x49,
+	0x10,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x00,
+	0x08,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xA0,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x7A,
+	0x5E,
+	0x6E,
+	0x1F,
+	0x1F,
+	0x00,
+	0x00,
+	0x00,
+	0x20,
+	0x40,
+	0x40,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x50,
+	0x00,
+	0x00,
+	0x09,
+	0x00,
+	0x00,
+	0x70,
+	0x00,
+	0x50,
+	0x00,
+	0x98,
+	0x00,
+	0x98,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	},
+
+
+	{
+	0x56,
+	0xF0,
+	0xF3,
+	0xFF,
+	0x36,
+	0x58,
+	0xAC,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	},
+
+
+	{
+	0x56,
+	0xF0,
+	0xF3,
+	0x03,
+	0x36,
+	0x58,
+	0xAC,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0x00,
+	0x03,
+	0x19,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x11,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x09,
+	0x1D,
+	0x0F,
+	0x00,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x00,
+	0x00,
+	0xFF,
+	0xF8,
+	0xFF,
+	0x00,
+	0x02,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	},
+
+
+	{
+	0x56,
+	0xF0,
+	0xF3,
+	0x04,
+	0x36,
+	0x58,
+	0xAC,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xC0,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x00,
+	0x00,
+	0x4F,
+	0x07,
+	0x4F,
+	0x07,
+	0x3B,
+	0x07,
+	0x3B,
+	0x07,
+	0x50,
+	0x00,
+	0x50,
+	0x00,
+	0x10,
+	0x00,
+	0x00,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x00,
+	0x03,
+	0x00,
+	0x00,
+	0x00,
+	0x24,
+	0x00,
+	0x40,
+	0xFF,
+	0xFF,
+	0x7F,
+	0x56,
+	0x80,
+	0x2F,
+	0x00,
+	0x84,
+	0x60,
+	0xAF,
+	0x00,
+	0x00,
+	0x80,
+	0x94,
+	0x00,
+	0x80,
+	0x00,
+	0x05,
+	0x38,
+	0x01,
+	0x83,
+	0x11,
+	0x01,
+	0x80,
+	0x90,
+	0x00,
+	0x40,
+	0x40,
+	0xE4,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x89,
+	0x10,
+	0xAC,
+	0x00,
+	0xE0,
+	0x80,
+	0x80,
+	0x19,
+	0x7D,
+	0x00,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x00,
+	0x0C,
+	},
+};
+
+#endif
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.c b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.c
new file mode 100644
index 0000000..d439d66
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.c
@@ -0,0 +1,502 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_fw.c
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+
+
+#include "ch7036_intf.h"
+#include "ch7036_fw.h"
+
+#include "hdcp7036.car"
+
+
+#define EDID_RETRY_MAX_TIMES 5
+#define HPD_LOOP_MAX 10
+
+
+
+#define SLEEP_TIME 40
+
+
+#define lhfm_size  sizeof(lhfm_array)
+
+
+#define LHFM_TIMEOUT	0x1F
+
+static unsigned char es_map[16] = {
+	0x26,0x27,0x42,0x43,0x44,0x45,0x46,0x47,
+	0x6A,0x51,0x52,0x53,0x57,0x58,0x59,0x5A
+};
+
+
+
+established_timings_t et_I[8] = {
+	{0,"800x600_60"},
+	{0,"800x600_56"},
+	{0,"640x480_75"},
+	{0,"640x480_72"},
+	{0,"640x480_67"},
+	{0,"640x480_60"},
+	{0,"720x400_88"},
+	{0,"720x400_70"}
+};
+
+established_timings_t et_II[8] ={
+	{0, "1280x1024_75"},
+	{0, "1024x768_75"},
+	{0, "1024x768_70"},
+	{0, "1024x768_60"},
+	{0, "1024x768_87"},
+	{0, "832x624_75"},
+	{0, "800x600_75"},
+	{0, "800x600_72"}
+};
+
+established_timings_t et_man = {
+	0, "1152x870_75"
+};
+
+extern OUT_FMT hdmi_timing_table[OUT_HDMI_END];
+extern OUT_FMT dvi_timing_table[OUT_DVI_END];
+extern OUT_FMT ch_vga_timing_table[OUT_CRT_END];
+
+
+int LHFM_get_version(DEV_CONTEXT* p_ch7xxx_context,struct _FW7036_CFG* cfg)
+{
+
+	unsigned char reg;
+	unsigned wj;
+
+		 I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		 reg = I2CRead(p_ch7xxx_context,0x4F);
+
+
+		 if (0==(LHFM_REQUEST & reg)) {
+			 I2CWrite(p_ch7xxx_context,0x4F, (LHFM_REQUEST+LHFM_GET_VERSION));
+			 wj = 0;
+			 while (wj++< LHFM_TIMEOUT) {
+
+
+				 I2CWrite(p_ch7xxx_context,0x03, 0x00);
+				 pd_usleep(SLEEP_TIME );
+				 PD_DEBUG("LHFM_get_version [%x]\r\n", wj);
+
+				 reg = I2CRead(p_ch7xxx_context,0x4F);
+				 if(reg == LHFM_GET_VERSION) {
+					 reg = I2CRead(p_ch7xxx_context,0x50);
+					 if (!(LHFM_RET_ERROR & reg)) {
+						    I2CWrite(p_ch7xxx_context,0x03, 0x01);
+						    cfg->size = I2CRead(p_ch7xxx_context,es_map[0]);
+							cfg->ver_major = I2CRead(p_ch7xxx_context,es_map[1]);
+							cfg->ver_minor = I2CRead(p_ch7xxx_context,es_map[2]);
+							cfg->did = I2CRead(p_ch7xxx_context,es_map[3]);
+							cfg->rid = I2CRead(p_ch7xxx_context,es_map[4]);
+							cfg->capbility = I2CRead(p_ch7xxx_context,es_map[5]);
+							cfg->reserved = I2CRead(p_ch7xxx_context,es_map[6]);
+						    I2CWrite(p_ch7xxx_context,0x03, 0x00);
+							return 0;
+					 } else return -2;
+
+				 }
+
+
+
+
+			 }
+
+		 }
+
+	return -1;
+}
+
+
+
+ch7036_status_t LHFM_get_hdmi_hpd(DEV_CONTEXT* p_ch7xxx_context,uint8 *hpd)
+{
+
+	unsigned char reg;
+	unsigned wj, count=0;
+	ch7036_status_t status = SS_FIRMWARE_TIMEOUT;
+
+
+	do {
+
+
+		 I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		 reg = I2CRead(p_ch7xxx_context,0x4F);
+
+
+		 if (0==(LHFM_REQUEST & reg)) {
+
+			 I2CWrite(p_ch7xxx_context,0x4F, (LHFM_REQUEST+ LHFM_GET_HPD));
+			 wj = 0;
+
+			 while (wj++< LHFM_TIMEOUT) {
+				 I2CWrite(p_ch7xxx_context,0x03, 0x00);
+				 reg = I2CRead(p_ch7xxx_context,0x4F);
+
+				 if(reg == LHFM_GET_HPD) {
+
+					 reg = I2CRead(p_ch7xxx_context,0x50);
+
+					 if (!(LHFM_RET_ERROR & reg)) {
+
+						    I2CWrite(p_ch7xxx_context,0x03, 0x01);
+						    reg = I2CRead(p_ch7xxx_context,es_map[0]);
+
+							if (hpd) *hpd = reg;
+
+							PD_DEBUG("ch7036: LHFM_get_hdmi_hpd- SUCCESS- hpd [%x]\n", *hpd);
+							return SS_SUCCESS;
+					 } else {
+
+						 status = SS_FIRMWARE_ERR;
+					 }
+
+				 }
+
+				if(status == SS_FIRMWARE_ERR)  break;
+				pd_usleep(SLEEP_TIME);
+
+			 }
+
+		 }
+
+		pd_usleep(SLEEP_TIME);
+		PD_DEBUG("ch7036: LHFM_get_hdmi_hpd- NOT SUCCESS-status = [%s]\n",status==SS_FIRMWARE_ERR?"firmware error":"timeout");
+
+	} while ( ( (status== SS_FIRMWARE_ERR) || (status== SS_FIRMWARE_TIMEOUT) ) && ( (++count) < HPD_LOOP_MAX) );
+
+
+	return status;
+}
+
+
+void LHFM_enable_crt_hpd(DEV_CONTEXT* p_ch7xxx_context)
+{
+	uint8 reg;
+
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x04);
+	reg = I2CRead(p_ch7xxx_context,0x57);
+	I2CWrite(p_ch7xxx_context,0x57, reg | 0x02);
+
+
+	pd_usleep(SLEEP_TIME);
+
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x00);
+	reg = I2CRead(p_ch7xxx_context,0x74);
+	I2CWrite(p_ch7xxx_context,0x74, reg | 0x02);
+
+	pd_usleep(SLEEP_TIME);
+
+
+}
+
+
+ch7036_status_t LHFM_get_crt_hpd(DEV_CONTEXT* p_ch7xxx_context)
+{
+
+	unsigned char reg, count =0;
+	ch7036_status_t status = SS_CRT_HPD_NOTCONNECTED;
+
+
+	do {
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x74);
+		I2CWrite(p_ch7xxx_context,0x74, reg & 0xFD);
+
+		pd_usleep(SLEEP_TIME);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x74);
+		I2CWrite(p_ch7xxx_context,0x74, reg | 0x02);
+
+		pd_usleep(SLEEP_TIME);
+
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x01);
+		reg = I2CRead(p_ch7xxx_context,0x7C);
+
+
+
+		PD_DEBUG("ch7036: LHFM_get_crt_hpd- DAC sense- reg dump [%x]\n", reg);
+
+		if( (reg & 0xFC) == 0x54 || (reg & 0xFC) == 0x50 ){
+
+			status= SS_SUCCESS;
+
+		}
+		else
+			LHFM_enable_crt_hpd(p_ch7xxx_context);
+
+		pd_usleep(SLEEP_TIME+100000);
+
+
+	} while ( (status == SS_CRT_HPD_NOTCONNECTED) && ( (++count) < HPD_LOOP_MAX ) );
+
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x00);
+	reg = I2CRead(p_ch7xxx_context,0x74);
+	I2CWrite(p_ch7xxx_context,0x74, reg & 0xFD);
+
+	return status;
+
+}
+
+
+ch7036_status_t LHFM_get_hdmi_modeinfo(DEV_CONTEXT* p_ch7xxx_context,unsigned char *minfo)
+{
+	unsigned char reg;
+	unsigned wj;
+	unsigned i;
+
+		 I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		 reg = I2CRead(p_ch7xxx_context,0x4F);
+
+		 if (0==(LHFM_REQUEST & reg)) {
+			 I2CWrite(p_ch7xxx_context,0x4F, (LHFM_REQUEST+ LHFM_GET_MODEINFO));
+			 wj = 0;
+			 while (wj++< LHFM_TIMEOUT) {
+				 I2CWrite(p_ch7xxx_context,0x03, 0x00);
+				 pd_usleep(SLEEP_TIME);
+
+				 reg = I2CRead(p_ch7xxx_context,0x4F);
+				 if(reg == LHFM_GET_MODEINFO) {
+					 reg = I2CRead(p_ch7xxx_context,0x50);
+					 if (!(LHFM_RET_ERROR & reg)) {
+						 if (minfo) {
+						    I2CWrite(p_ch7xxx_context,0x03, 0x01);
+							for (i=0; i<15; i++) minfo[i] = I2CRead(p_ch7xxx_context,es_map[i]);
+						}
+						return SS_SUCCESS;
+					 } else return SS_FIRMWARE_ERR;
+
+				 }
+
+
+
+
+			 }
+
+		 }
+
+	return SS_FIRMWARE_TIMEOUT;
+
+}
+
+
+
+ch7036_status_t LHFM_get_edid(DEV_CONTEXT* p_ch7xxx_context,unsigned char* edid, unsigned char* ebn, unsigned char flag)
+{
+
+	unsigned i,j, ie;
+	unsigned k1, k2;
+	unsigned char reg;
+	unsigned wj;
+
+	ch7036_status_t status = SS_SUCCESS;
+
+
+	*ebn = 0;
+
+
+	for (i=0; i<512; i++) edid[i]=0;
+
+	 I2CWrite(p_ch7xxx_context,0x03, 0x00);
+	 reg = I2CRead(p_ch7xxx_context,0x4F);
+
+
+	 if (0==(LHFM_REQUEST & reg)) {
+
+
+		 for(i=0,j=0; i < 8; i++,j+=16) {
+
+		    I2CWrite(p_ch7xxx_context,0x03, 0x00);
+			I2CWrite(p_ch7xxx_context,0x50, i + flag);
+			I2CWrite(p_ch7xxx_context,0x4F, (LHFM_REQUEST+LHFM_GET_EDID));
+			wj = 0;
+
+			status = SS_FIRMWARE_TIMEOUT;
+
+			while (wj++< (2*LHFM_TIMEOUT) ) {
+				 I2CWrite(p_ch7xxx_context,0x03, 0x00);
+				 pd_usleep(SLEEP_TIME);
+
+				 reg = I2CRead(p_ch7xxx_context,0x4F);
+
+				 if(reg == LHFM_GET_EDID) {
+
+					 reg = I2CRead(p_ch7xxx_context,0x50);
+
+					 if (!(LHFM_RET_ERROR & reg)) {
+							I2CWrite(p_ch7xxx_context,0x03, 0x01);
+							for (ie=0; ie<16; ie++) edid[j+ie] = I2CRead(p_ch7xxx_context,es_map[ie] );
+
+
+							break;
+					 }
+					 else {
+
+
+
+
+						return SS_FIRMWARE_ERR;
+
+					 }
+
+				 }
+
+
+			}
+
+			status = SS_SUCCESS;
+
+
+		}
+
+
+		(*ebn)++;
+
+
+		k2 = edid[0x7E];
+
+		k2 = (k2 > 3)? 3 : k2;
+		if (k2>0) {
+		  for (k1=1; k1<=k2; k1++) {
+
+
+
+		    for(i=k1*8; i < 8+k1*8; i++,j+=16){
+				I2CWrite(p_ch7xxx_context,0x03, 0x00);
+			    I2CWrite(p_ch7xxx_context,0x50, i + flag);
+				I2CWrite(p_ch7xxx_context,0x4F, (LHFM_REQUEST+LHFM_GET_EDID));
+				wj = 0;
+
+				status = SS_FIRMWARE_TIMEOUT;
+
+				while (wj++< (2*LHFM_TIMEOUT)) {
+					 I2CWrite(p_ch7xxx_context,0x03, 0x00);
+					 pd_usleep(SLEEP_TIME);
+
+					 reg = I2CRead(p_ch7xxx_context,0x4F);
+
+					 if(reg == LHFM_GET_EDID) {
+						 reg = I2CRead(p_ch7xxx_context,0x50);
+						 if (!(LHFM_RET_ERROR & reg)) {
+								I2CWrite(p_ch7xxx_context,0x03, 0x01);
+								for (ie=0; ie<16; ie++) edid[j+ie] = I2CRead(p_ch7xxx_context,es_map[ie] );
+
+
+								break;
+						 }
+						 else {
+
+							return SS_FIRMWARE_ERR;
+						 }
+					 }
+
+
+
+
+				 }
+
+				status = SS_SUCCESS;
+			}
+
+			(*ebn)++;
+		  }
+
+		}
+
+
+
+	 }
+
+	return status;
+
+}
+
+
+int LHFM_load_firmware(DEV_CONTEXT* p_ch7xxx_context)
+{
+
+
+	unsigned fs1;
+	unsigned char ch;
+
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x04);
+
+	ch = 0x29 | I2CRead(p_ch7xxx_context,0x52);
+	I2CWrite(p_ch7xxx_context,0x52, ch & 0xFB);
+
+
+
+	I2CWrite(p_ch7xxx_context,0x5B, 0x9E);
+
+	I2CWrite(p_ch7xxx_context,0x5B, 0xB3);
+
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x04);
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x07);
+
+
+	for (fs1=0; fs1<lhfm_size; fs1++) {
+
+		I2CWrite(p_ch7xxx_context, 0x07, lhfm_array[fs1]);
+	}
+
+	I2CWrite(p_ch7xxx_context, 0x03, 0x03);
+	ch = I2CRead(p_ch7xxx_context,0x74);
+	if (ch & 0x1) {
+
+		return -1;
+	}
+	else {
+
+		I2CWrite( p_ch7xxx_context,0x03, 0x04);
+		ch = I2CRead(p_ch7xxx_context,0x52);
+		I2CWrite(p_ch7xxx_context, 0x52, ch | 0x24);
+	}
+
+
+	I2CWrite(p_ch7xxx_context, 0x03, 0x00);
+
+
+	return 0;
+}
+
+void ch7036_dump( char *s, int size, unsigned char *regdata)
+{
+
+    return;
+}
+
+
+
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.h
new file mode 100644
index 0000000..0a30f1a
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.h
@@ -0,0 +1,217 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_fw.h
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+
+#ifndef H_FW_OPER_H
+#define H_FW_OPER_H
+
+#include "ch7036_typedef.h"
+
+
+#include <linux/kernel.h>
+
+#define	CFG_CAP_EDID	0x01
+#define CFG_CAP_HDCP	0x02
+
+
+
+typedef struct _FW7036_CFG {
+    unsigned char size;
+	unsigned char ver_major;
+	unsigned char ver_minor;
+	unsigned char did;
+	unsigned char rid;
+	unsigned char capbility;
+	unsigned char reserved;
+} FW7036_CFG;
+
+
+#define LHFM_GET_VERSION		0x1F
+#define LHFM_GET_HPD			0x06
+#define LHFM_GET_EDID			0x01
+#define LHFM_GET_MODEINFO		0x03
+#define LHFM_GET_VGA_MODEINFO	0x33
+
+#define LHFM_HDMI_ONOFF		0x04
+
+
+#define LHFM_REQUEST		0x40
+#define LHFM_RET_ERROR		0x80
+
+int LHFM_get_version(DEV_CONTEXT* p_ch7xxx_context,struct _FW7036_CFG* cfg);
+
+
+
+
+
+ch7036_status_t LHFM_get_hdmi_hpd(DEV_CONTEXT* p_ch7xxx_context,uint8 *hpd);
+void LHFM_enable_crt_hpd(DEV_CONTEXT* p_ch7xxx_context);
+ch7036_status_t LHFM_get_crt_hpd(DEV_CONTEXT* p_ch7xxx_context);
+
+
+
+int LHFM_hdmi_onoff(int turnon);
+
+
+
+
+
+
+ch7036_status_t LHFM_get_hdmi_modeinfo(DEV_CONTEXT* p_ch7xxx_context,unsigned char *minfo);
+
+
+
+
+
+
+ch7036_status_t LHFM_get_edid(DEV_CONTEXT* p_ch7xxx_context,unsigned char*edid, unsigned char* ebn, unsigned char flag);
+
+
+
+
+
+
+int LHFM_load_firmware(DEV_CONTEXT* pDevContext);
+
+
+void test_fw(DEV_CONTEXT* p_ch7xxx_context,int oper);
+void ch7036_dump( char *s, int size, unsigned char *regdata);
+
+#define GET_VER					0x01
+#define GET_HPD					0x02
+#define GET_EDID				0x04
+#define GET_HDMI_DISPLAY_MODES	0x08
+
+#define GET_CRT_HPD				0x10
+#define GET_CRT_EDID			0x20
+
+#define CH7036_HDMI_DDC			0
+#define CH7036_VGA_DDC			0x80
+
+#define MAX_EDID_BLOCKS			4
+
+
+
+
+#define NUM_OF_BLOCKS                         0x0F
+#define DTD_SIZE                              0x12
+#define EDID_SIZE                             0x0100
+#define EDID_STRUCTURE_VERSION                0x12
+#define EDID_STRUCTURE_REVISION               0x13
+#define EDID_FEATURE_SUPPORT                  0x18
+#define EDID_ESTABLISHED_TIMINGS_1            0x23
+#define EDID_ESTABLISHED_TIMINGS_2            0x24
+#define EDID_MANUFACTURERS_RESERVED_TIMINGS   0x25
+#define EDID_STANDARD_TIMINGS                 0x26
+#define EDID_STANDARD_TIMINGS_BIT_DESCRIPTION 0x27
+#define EDID_DETAILED_TIMING_DESCRIPTION_1    0x36
+#define EDID_DETAILED_TIMING_DESCRIPTION_2    0x48
+#define EDID_DETAILED_TIMING_DESCRIPTION_3    0x5A
+
+#define EDID_EXTENSION_FLAG                   0x7E
+
+#define EDID_CEA_TAG                          0x80
+#define EDID_CEA_REVISION                     0x81
+#define EDID_CEA_DETAILED_TIMING_DATA_OFFSET  0x82
+#define EDID_CEA_VIDEO_DATA_BLOCK             0x84
+
+#define EDID_CEA_VIDEO_DATA_BLOCK_2           0x96
+#define EDID_CEA_VIDEO_DATA_BLOCK_3           0xA8
+#define EDID_CEA_VIDEO_DATA_BLOCK_4           0xBA
+#define EDID_CEA_VIDEO_DATA_BLOCK_5           0xCC
+#define EDID_CEA_VIDEO_DATA_BLOCK_6           0xDE
+
+#define EDID_SPACE_INDEX_START                0x18
+
+typedef struct {
+    unsigned char  is_supported;
+    char* mode_name;
+}established_timings_t, *p_established_timings;
+
+typedef struct {
+	unsigned int ha;
+	unsigned int va;
+	unsigned char refresh_rate;
+}standard_timings_t, *p_standard_timings;
+
+
+
+typedef struct {
+	unsigned char pclk_lobyte;
+	unsigned char pclk_hibyte;
+	unsigned char hactive_lobyte;
+	unsigned char hblank_lobyte;
+	unsigned char hactive_blank;
+	unsigned char vactive_lobyte;
+	unsigned char vblank_lobyte;
+	unsigned char vactive_blank;
+	unsigned char hsync_off_lobyte;
+	unsigned char hsync_pulse_width;
+	unsigned char vsync_off_pulse_width;
+
+	unsigned char hsopw_vsopw;
+
+
+
+	unsigned char himage_size_lobyte;
+	unsigned char vimage_size_lobyte;
+	unsigned char hvimage_size;
+
+	unsigned char hborder;
+	unsigned char vborder;
+	unsigned char flags;
+}dtd_t, *p_dtd;
+
+typedef struct edid_blk {
+
+
+	unsigned char						is_edid;
+	unsigned char						ebn;
+	unsigned char						edidblk[512];
+
+	established_timings_t				etiming_I[8];
+	established_timings_t				etiming_II[8];
+	established_timings_t				etiming_man;
+
+	standard_timings_t					stiming[8];
+
+	unsigned char						supported_modes[15];
+
+} ch7036_edid_blk_t;
+
+
+extern ch7036_edid_blk_t crt_edid;
+extern ch7036_edid_blk_t hdvi_edid;
+
+
+
+
+
+
+
+
+#endif
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_iic.c b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_iic.c
new file mode 100644
index 0000000..f057952
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_iic.c
@@ -0,0 +1,335 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_iic.c
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+
+#include "ch7036_iic.h"
+#include "ch7036_def_regmap.h"
+
+
+static uint8 g_nCurPage = 0;
+static uint8 g_nCurRegmap[REG_PAGE_NUM][REG_NUM_PER_PAGE];
+
+int g_verbose = 0;
+
+
+
+
+void SetPower(DEV_CONTEXT* pDevContext);
+
+
+
+
+void DeviceReset(DEV_CONTEXT* pDevContext)
+{
+
+	uint8 reg=0x00;
+
+   I2CWrite(pDevContext,0x03, 0x04);
+
+   I2CWrite(pDevContext,0x52, 0x2B);
+   I2CWrite(pDevContext,0x5a, 0x06);
+   I2CWrite(pDevContext,0x5a, 0x04);
+   I2CWrite(pDevContext,0x5a, 0x06);
+
+   I2CWrite(pDevContext,0x52, 0x29);
+   I2CWrite(pDevContext,0x52, 0x2b);
+
+   I2CWrite(pDevContext,0x5a, 0x04);
+
+
+   I2CWrite(pDevContext,0x03, 0x01);
+   reg = I2CRead(pDevContext,0x16);
+
+   reg = reg & 0xF7;
+   I2CWrite(pDevContext,0x16, reg);
+
+
+
+}
+
+
+void DeviceSetup(DEV_CONTEXT* pDevContext)
+{
+	if (g_verbose) {
+			uint8 page, index;
+			uint16 k =0;
+			uint16 rc[5];
+			for(page=0; page<REG_PAGE_NUM; ++page)
+			{
+				rc[page]=0;
+				if(page == 0x02) continue;
+				I2CWrite(pDevContext,0x03, page);
+				for(index=0x07; index<REG_NUM_PER_PAGE; ++index)
+				{
+					if(g_nCurRegmap[page][index] != g_DefRegMap[page][index])
+					{
+
+						k++;
+						rc[page]++;
+						I2CWrite(pDevContext,index, g_nCurRegmap[page][index]);
+
+					}
+				}
+			}
+
+			for(page=0; page<REG_PAGE_NUM; ++page)
+
+				;
+
+	}
+	else {
+			uint8 page, index;
+			for(page=0; page<REG_PAGE_NUM; ++page)
+			{
+				if(page == 0x02) continue;
+				I2CWrite(pDevContext,0x03, page);
+				for(index=0x07; index<REG_NUM_PER_PAGE; ++index)
+				{
+					if(g_nCurRegmap[page][index] != g_DefRegMap[page][index])
+					{
+						I2CWrite(pDevContext,index, g_nCurRegmap[page][index]);
+					}
+				}
+			}
+	}
+}
+
+
+#if 0
+void SetPower(DEV_CONTEXT* pDevContext)
+{
+	uint8 page =0;
+	uint8 index;
+	uint32 reg_id, end;
+
+
+
+	reg_id = (uint32)HDMI_PD;
+	end = (uint32)MUL_ID_END;
+
+	I2CWrite(pDevContext,0x03, page);
+
+	while (reg_id < end)
+	{
+		if (page != g_MultiRegTable[reg_id].PageIndex)
+		{
+			page = g_MultiRegTable[reg_id ].PageIndex;
+			I2CWrite(pDevContext,0x03, page);
+		}
+		index = g_MultiRegTable[reg_id ].LowRegIndex;
+		I2CWrite(pDevContext,index, g_nCurRegmap[page][index]);
+		reg_id++;
+	}
+
+	I2CWrite(pDevContext,0x03, 0);
+	I2CWrite(pDevContext,0x1C, g_nCurRegmap[0][0x1C]);
+	I2CWrite(pDevContext,0x1D, g_nCurRegmap[0][0x1D]);
+
+}
+#endif
+
+
+
+
+uint8 iic_read(uint8 index)
+{
+	return g_nCurRegmap[g_nCurPage][index];
+}
+
+void iic_write(uint8 index, uint8 value)
+{
+	if(index == 0x03)
+	{
+		g_nCurPage = value;
+	}
+	else
+	{
+		g_nCurRegmap[g_nCurPage][index] = value;
+	}
+}
+
+void iic_reset()
+{
+	uint8 page, index;
+	for(page=0; page<REG_PAGE_NUM; ++page)
+	{
+		for(index=0; index<REG_NUM_PER_PAGE; ++index)
+		{
+			g_nCurRegmap[page][index] = g_DefRegMap[page][index];
+		}
+	}
+	g_nCurPage = 0x00;
+}
+
+uint32 iic_read_ex(MULTI_REG_ID reg_id)
+{
+	uint8 oldpage;
+	uint32 n0, n1, n2, n3, mask, i, value;
+
+
+	n0 = n1 = n2 = n3 = value = mask = 0;
+
+
+	i = (uint32)reg_id;
+
+
+	oldpage = iic_read(0x03);
+	iic_write(0x03, g_MultiRegTable[i].PageIndex);
+
+	if(-1 != g_MultiRegTable[i].TopRegIndex)
+		n0 = iic_read(g_MultiRegTable[i].TopRegIndex);
+
+	if(-1 != g_MultiRegTable[i].HighRegIndex)
+		n1 = iic_read(g_MultiRegTable[i].HighRegIndex);
+
+	if(-1 != g_MultiRegTable[i].MiddleRegIndex)
+		n2 = iic_read(g_MultiRegTable[i].MiddleRegIndex);
+
+	n3 = iic_read(g_MultiRegTable[i].LowRegIndex);
+
+	iic_write(0x03, oldpage);
+
+	if(0 != n0)
+	{
+		mask = 1;
+		mask <<= g_MultiRegTable[i].TopEndBit - g_MultiRegTable[i].TopStartBit + 1;
+		mask -= 1;
+		mask <<= g_MultiRegTable[i].TopStartBit;
+		n0 &= mask;
+		n0 >>= g_MultiRegTable[i].TopStartBit;
+		n0 <<= (g_MultiRegTable[i].HighEndBit - g_MultiRegTable[i].HighStartBit + 1)+(g_MultiRegTable[i].MiddleEndBit - g_MultiRegTable[i].MiddleStartBit + 1) + (g_MultiRegTable[i].LowEndBit - g_MultiRegTable[i].LowStartBit + 1);
+	}
+	if(0 != n1)
+	{
+		mask = 1;
+		mask <<= g_MultiRegTable[i].HighEndBit - g_MultiRegTable[i].HighStartBit + 1;
+		mask -= 1;
+		mask <<= g_MultiRegTable[i].HighStartBit;
+		n1 &= mask;
+		n1 >>= g_MultiRegTable[i].HighStartBit;
+		n1 <<= (g_MultiRegTable[i].MiddleEndBit - g_MultiRegTable[i].MiddleStartBit + 1) + (g_MultiRegTable[i].LowEndBit - g_MultiRegTable[i].LowStartBit + 1);
+	}
+
+	if(0 != n2)
+	{
+		mask = 1;
+		mask <<= g_MultiRegTable[i].MiddleEndBit - g_MultiRegTable[i].MiddleStartBit + 1;
+		mask -= 1;
+		mask <<= g_MultiRegTable[i].MiddleStartBit;
+		n2 &= mask;
+		n2 >>= g_MultiRegTable[i].MiddleStartBit;
+		n2 <<= g_MultiRegTable[i].LowEndBit - g_MultiRegTable[i].LowStartBit + 1;
+	}
+
+	if(0 != n3)
+	{
+		mask = 1;
+		mask <<= g_MultiRegTable[i].LowEndBit - g_MultiRegTable[i].LowStartBit + 1;
+		mask -= 1;
+		mask <<= g_MultiRegTable[i].LowStartBit;
+		n3 &= mask;
+		n3 >>= g_MultiRegTable[i].LowStartBit;
+	}
+
+	value = n0 | n1 | n2 | n3;
+	return value;
+}
+
+void iic_write_ex(MULTI_REG_ID reg_id, uint32 value)
+{
+	uint8 oldpage;
+	uint32 n1, n2, n3, n4, mask, nOrigin, i, value_local;
+
+
+	n1 = n2 = n3 = n4 = mask = nOrigin = i = 0;
+	value_local = value;
+
+
+	i = (uint32)reg_id;
+
+
+	oldpage = iic_read(0x03);
+	iic_write(0x03, g_MultiRegTable[i].PageIndex);
+
+	mask = 1;
+	mask <<= g_MultiRegTable[i].LowEndBit - g_MultiRegTable[i].LowStartBit + 1;
+	mask -= 1;
+	n1 = value_local & mask;
+	n1 <<= g_MultiRegTable[i].LowStartBit;
+	nOrigin = iic_read(g_MultiRegTable[i].LowRegIndex);
+	mask <<= g_MultiRegTable[i].LowStartBit;
+	nOrigin &= ~mask;
+	n1 |= nOrigin;
+	iic_write(g_MultiRegTable[i].LowRegIndex, (uint8)n1);
+	value_local >>= g_MultiRegTable[i].LowEndBit - g_MultiRegTable[i].LowStartBit + 1;
+
+	if(-1 != g_MultiRegTable[i].MiddleRegIndex)
+	{
+		mask = 1;
+		mask <<= g_MultiRegTable[i].MiddleEndBit - g_MultiRegTable[i].MiddleStartBit + 1;
+		mask -= 1;
+		n2 = value_local & mask;
+		n2 <<= g_MultiRegTable[i].MiddleStartBit;
+		nOrigin = iic_read(g_MultiRegTable[i].MiddleRegIndex);
+		mask <<= g_MultiRegTable[i].MiddleStartBit;
+		nOrigin &= ~mask;
+		n2 |= nOrigin;
+		iic_write(g_MultiRegTable[i].MiddleRegIndex, (uint8)n2);
+		value_local >>= g_MultiRegTable[i].MiddleEndBit - g_MultiRegTable[i].MiddleStartBit + 1;
+
+		if(-1 != g_MultiRegTable[i].HighRegIndex)
+		{
+			mask = 1;
+			mask <<= g_MultiRegTable[i].HighEndBit - g_MultiRegTable[i].HighStartBit + 1;
+			mask -= 1;
+			n3 = value_local & mask;
+			n3 <<= g_MultiRegTable[i].HighStartBit;
+			nOrigin = iic_read(g_MultiRegTable[i].HighRegIndex);
+			mask <<= g_MultiRegTable[i].HighStartBit;
+			nOrigin &= ~mask;
+			n3 |= nOrigin;
+			iic_write(g_MultiRegTable[i].HighRegIndex, (uint8)n3);
+			value_local >>= g_MultiRegTable[i].HighEndBit - g_MultiRegTable[i].HighStartBit + 1;
+
+			if(-1 != g_MultiRegTable[i].TopRegIndex)
+			{
+				mask = 1;
+				mask <<= g_MultiRegTable[i].TopEndBit - g_MultiRegTable[i].TopStartBit +1;
+				mask -= 1;
+				n4 = value_local & mask;
+				n4 <<= g_MultiRegTable[i].TopStartBit;
+				nOrigin = iic_read(g_MultiRegTable[i].TopRegIndex);
+				mask <<= g_MultiRegTable[i].TopStartBit;
+				nOrigin &= ~mask;
+				n4 |= nOrigin;
+				iic_write(g_MultiRegTable[i].TopRegIndex,(uint8)n4);
+			}
+		}
+	}
+
+	iic_write(0x03, oldpage);
+}
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_iic.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_iic.h
new file mode 100644
index 0000000..ebfb06b
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_iic.h
@@ -0,0 +1,62 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_iic.h
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+#ifndef _CH7036_IIC_H
+#define _CH7036_IIC_H
+
+#include "ch7036_typedef.h"
+#include "ch7036_reg_table.h"
+
+
+
+
+uint8 I2CRead(DEV_CONTEXT* pDevContext, uint8 index);
+void I2CWrite(DEV_CONTEXT* pDevContext, uint8 index, uint8 value);
+
+void I2CBlockWrite(DEV_CONTEXT* pDevContext,uint8 index, uint8* value, uint16 len);
+
+
+void DeviceReset(DEV_CONTEXT* pDevContext);
+
+
+void DeviceSetup(DEV_CONTEXT* pDevContext);
+
+
+
+
+
+uint8 iic_read(uint8 index);
+void iic_write(uint8 index, uint8 value);
+void iic_reset(void);
+
+
+uint32 iic_read_ex(MULTI_REG_ID reg_id);
+void iic_write_ex(MULTI_REG_ID reg_id, uint32 reg_val);
+
+extern int g_verbose;
+
+#endif
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.c b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.c
new file mode 100644
index 0000000..6ede568
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.c
@@ -0,0 +1,922 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_intf.c
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+#include "ch7036_intf.h"
+#include "ch7036_attr.h"
+#include "ch7036_fw.h"
+
+
+
+
+
+OUT_FMT hdmi_timing_table[OUT_HDMI_END] = {
+
+
+	{1,     25175,  1, {800,   640, 16,  96, 525,  480, 10,  2, 59, SCANTYPE_PROGRESSIVE} },
+    {1,     25250,  1, {800,   640, 16,  96, 525,  480, 10,  2, 60, SCANTYPE_PROGRESSIVE} },
+    {2,     27000,  1, {858,   720, 16,  62, 525,  480,  9,  6, 59, SCANTYPE_PROGRESSIVE} },
+    {2,     27027,  1, {858,   720, 16,  62, 525,  480,  9,  6, 60, SCANTYPE_PROGRESSIVE} },
+
+    {4,     74176,  2, {1650, 1280, 110, 40, 750,  720,  5,  5, 59, SCANTYPE_PROGRESSIVE} },
+    {4,     74250,  2, {1650, 1280, 110, 40, 750,  720,  5,  5, 60, SCANTYPE_PROGRESSIVE} },
+    {5,     74176,  2, {2200, 1920, 88,  44, 1125, 1080, 2,  5, 59, SCANTYPE_INTERLACED} },
+    {5,     74250,  2, {2200, 1920, 88,  44, 1125, 1080, 2,  5, 60, SCANTYPE_INTERLACED} },
+
+
+   {16,    148350,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 59, SCANTYPE_PROGRESSIVE} },
+   {16,    148500,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 60, SCANTYPE_PROGRESSIVE} },
+
+   {17,     27000,  1, {864,  720,  12,  64, 625,  576,  5,  5, 50, SCANTYPE_PROGRESSIVE} },
+   {19,     74250,  2, {1980, 1280, 440, 40, 750,  720,  5,  5, 50, SCANTYPE_PROGRESSIVE} },
+
+   {20,     74250,  2, {2640, 1920, 528, 44, 1125, 1080, 2, 5, 50, SCANTYPE_INTERLACED} },
+
+
+   {31,    148500,  2, {2640, 1920, 528, 44, 1125, 1080, 4,  5, 50, SCANTYPE_PROGRESSIVE} },
+   {32,     74175,  2, {2750, 1920, 638, 44, 1125, 1080, 4,  5, 23, SCANTYPE_PROGRESSIVE} },
+   {32,     74250,  2, {2750, 1920, 638, 44, 1125, 1080, 4,  5, 24, SCANTYPE_PROGRESSIVE} },
+   {33,     74250,  2, {2640, 1920, 528, 44, 1125, 1080, 4,  5, 25, SCANTYPE_PROGRESSIVE} },
+   {34,     74175,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 29, SCANTYPE_PROGRESSIVE} },
+   {34,     74250,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 30, SCANTYPE_PROGRESSIVE} },
+
+   {40,    148500,  2, {2640, 1920, 528, 44, 1124, 1080, 4, 10, 100, SCANTYPE_INTERLACED} },
+   {41,    148500,  2, {1980, 1280, 440, 40, 750,  720,  5,  5, 100, SCANTYPE_PROGRESSIVE} },
+   {42,     54000,  1, {864,   720, 12,  64, 625,  576,  5,  5, 100, SCANTYPE_PROGRESSIVE} },
+
+
+   {46,    148352,  2, {2200, 1920, 88,  44, 1124, 1080, 4, 10, 119, SCANTYPE_INTERLACED} },
+   {46,    148500,  2, {2200, 1920, 88,  44, 1124, 1080, 4, 10, 120, SCANTYPE_INTERLACED} },
+
+   {47,    148352,  2, {1650, 1280, 110, 40, 750,  720,  5,  5, 119, SCANTYPE_PROGRESSIVE} },
+   {47,    148500,  2, {1650, 1280, 110, 40, 750,  720,  5,  5, 120, SCANTYPE_PROGRESSIVE} },
+
+   {48,     54000,  1, {858,   720, 16,  62, 525,  480,  9,  6, 119, SCANTYPE_PROGRESSIVE} },
+   {48,     54054,  1, {858,   720, 16,  62, 525,  480,  9,  6, 120, SCANTYPE_PROGRESSIVE} },
+
+   {52,    108000,  1, {864,   720, 12,  64, 625,  576,  5,  5, 200, SCANTYPE_PROGRESSIVE} },
+
+   {56,    108000,  1, {858,   720, 16,  62, 525,  480,  9,  6, 239, SCANTYPE_PROGRESSIVE} },
+   {56,    108108,  1, {858,   720, 16,  62, 525,  480,  9,  6, 240, SCANTYPE_PROGRESSIVE} },
+
+};
+
+OUT_FMT dvi_timing_table[OUT_DVI_END] = {
+
+
+
+	{0,     25170,  0, { 800,  640, 16,  96, 525,  480, 10,  2,  60, SCANTYPE_PROGRESSIVE}	},
+	{0,     31500,  0, { 832,  640, 24,  40, 520,  480,  9,  3,  72, SCANTYPE_PROGRESSIVE}	},
+    {0,     31500,  0, { 800,  640, 16,  96, 525,  480, 11,  2,  75, SCANTYPE_PROGRESSIVE}	},
+
+	{0,     28322,  0, { 900,  720, 15, 108, 449,  400, 11,  2,  70, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		38100,	0, {1088,  800,	32, 128, 619,  600,  1,  4,  56, SCANTYPE_PROGRESSIVE}	},
+
+
+	{0,		40000,	0, {1056,  800,	40, 128, 628,  600,  1,  4,  60, SCANTYPE_PROGRESSIVE}	},
+	{0,		50000,	0, {1040,  800,	56, 120, 666,  600, 37,  6,  72, SCANTYPE_PROGRESSIVE}	},
+	{0,		49500,	0, {1056,  800,	16,  80, 624,  600,  1,  2,  75, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		65000,	0, {1344, 1024,	24,	136, 806,  768,	 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
+    {0,		75000,	0, {1328, 1024,	24,	136, 806,  768,	 3,	 6,  70, SCANTYPE_PROGRESSIVE}	},
+	{0,		78750,	0, {1312, 1024,	16,	 96, 800,  768,	 1,	 3,  75, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		81517,	0, {1688, 1152,	48,112,1066,  864,	 1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		83460,	0, {1680, 1280,	64,	136, 828,  720,  1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		83865,	0, {1680, 1280,	64,	136, 828,  800,  1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		100638,	0, {1688, 1280,	48,	112, 1066, 960,  1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		108000,	0, {1688, 1280,	48,	112, 1066, 1024, 1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+	{0,		135000,	0, {1688, 1280,	16,	144, 1066, 1024, 1,	 3,  75, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		85543,	0, {2256, 1360,104, 184, 1087, 768,  1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+	{0,		85920,	0, {2256, 1366,104, 184, 1087, 768,  1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		121750,	0, {1864, 1400,	88,144,1089,  1050,	 3,	 4,  60, SCANTYPE_PROGRESSIVE}	},
+    {0,		156000,	0, {1896, 1400,104,144,1099,  1050,	 3,	 4,  75, SCANTYPE_PROGRESSIVE}	},
+
+
+	{0,		88750,	0, {1600, 1440,	48,	32,	 926,  900,	 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
+	{0,		119000,	0, {1840, 1440,	48,	32,	 1080, 1050, 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		117936,	0, {2256, 1600,104,	184, 1250,  900, 1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+	{0,		162000,	0, {2160, 1600,	64,	192, 1250, 1200, 1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		147130,	0, {2256, 1680,104,	184, 1087, 1050, 1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+	{0,     148500, 0, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 60, SCANTYPE_PROGRESSIVE} },
+	{0,		154000,	0, {2080, 1920,	48,	 32, 1235, 1200, 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
+
+};
+
+
+OUT_FMT ch_vga_timing_table[OUT_CRT_END] = {
+
+
+   {100,    31500,  1, {832,   640, 32,  64,  445,  400, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
+
+   {100,    25175,  1, {800,   640,  8,  96,  525,  480, 2,  2,  60, SCANTYPE_PROGRESSIVE}  },
+   {100,    31500,  1, {832,   640, 16,  40,  520,  480, 1,  3,  72, SCANTYPE_PROGRESSIVE}  },
+   {100,    31500,  1, {840,   640, 16,  64,  500,  480, 1,  3,  75, SCANTYPE_PROGRESSIVE}  },
+   {100,    36000,  1, {832,   640, 56,  56,  509,  480, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
+
+   {100,    35500,  1, {936,   720, 36,  72,  446,  400, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
+
+
+
+   {100,    36000,  1, {1024,  800, 24,  72,  625,  600, 1,  2,  56, SCANTYPE_PROGRESSIVE}  },
+
+
+   {100,    38250,  1, {1024,  800, 32,  80,  624,  600, 3,  4,  60, SCANTYPE_PROGRESSIVE}  },
+   {100,    50000,  1, {1040,  800, 56, 120,  666,  600, 37, 6,  72, SCANTYPE_PROGRESSIVE}  },
+   {100,    49000,  1, {1040,  800, 40,  80,  629,  600, 3,  4,  75, SCANTYPE_PROGRESSIVE}  },
+   {100,    56750,  1, {1056,  800, 48,  80,  633,  600, 3,  4,  85, SCANTYPE_PROGRESSIVE}  },
+
+
+   {100,    65000,  1, {1344, 1024, 24, 136,  806,  768, 3,  6,  60, SCANTYPE_PROGRESSIVE}  },
+   {100,    75000,  1, {1328, 1024, 24, 136,  806,  768, 3,  6,  70, SCANTYPE_PROGRESSIVE}  },
+   {100,    78750,  1, {1312, 1024, 16,  96,  800,  768, 1,  3,  75, SCANTYPE_PROGRESSIVE}  },
+
+   {100,    94500,  1, {1376, 1024, 48,  96,  808,  768, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
+
+
+   {100,   108000,  1, {1600, 1152, 64, 128,  900,  864, 1,  2,  75, SCANTYPE_PROGRESSIVE}  },
+
+
+   {100,    79500,  1, {1664, 1280, 64, 128,  798,  768, 3,  7,  60, SCANTYPE_PROGRESSIVE}  },
+   {100,   102250,  1, {1696, 1280, 80, 128,  805,  768, 3,  7,  75, SCANTYPE_PROGRESSIVE}  },
+   {100,   117500,  1, {1712, 1280, 80, 136,  809,  768, 3,  7,  85, SCANTYPE_PROGRESSIVE}  },
+
+
+   {100,   108000,  1, {1800, 1280, 96, 112, 1000,  960, 1,  3,  60, SCANTYPE_PROGRESSIVE}  },
+   {100,   148500,  1, {1728, 1280, 64, 160, 1011,  960, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
+
+
+   {100,   108000,  1, {1688, 1280, 48, 112, 1066, 1024, 1,  3,  60, SCANTYPE_PROGRESSIVE}  },
+   {100,   135000,  1, {1688, 1280, 16, 144, 1066, 1024, 1,  3,  75, SCANTYPE_PROGRESSIVE}  },
+   {100,   157500,  1, {1728, 1280, 64, 160, 1072, 1024, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
+
+
+   {100,    85500,	1, {1792, 1360,	64, 112,  795,  768, 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
+
+
+   {100,   121750,	1, {1864, 1400,	88,144,1089,  1050,	 3,	 4,  60, SCANTYPE_PROGRESSIVE}	},
+   {100,   156000,	1, {1896, 1400,104,144,1099,  1050,	 3,	 4,  75, SCANTYPE_PROGRESSIVE}	},
+
+
+   {100,	88750,	1, {1600, 1440,	48,	32,	 926,  900,	 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
+
+
+   {100,   119000,	1, {1840, 1440,	48,	32,	 1080, 1050, 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
+
+
+   {100,   117936,	1, {2256, 1600,104,	184, 1250,  900, 1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+
+
+   {100,   162000,  1, {2160, 1600, 64, 192, 1250, 1200, 1,  3,  60, SCANTYPE_PROGRESSIVE}  },
+
+
+
+   {100,   148500, 1, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 60, SCANTYPE_PROGRESSIVE} },
+
+
+
+};
+
+
+uint8 I2CRead(DEV_CONTEXT* pDevContext,uint8 index)
+{
+
+	ch7036_device_context_t *p_ctx= pDevContext->pd_context;
+	pd_reg_t reg_list[2];
+
+
+
+	reg_list[0].reg = (i2c_reg_t)index;
+	reg_list[1].reg = PD_REG_LIST_END;
+
+	p_ctx->p_callback->read_regs(p_ctx->p_callback->callback_context, reg_list,PD_REG_DDC_FW);
+
+	return (uint8)(reg_list[0].value);
+}
+
+void I2CWrite(DEV_CONTEXT* pDevContext,uint8 index, uint8 value)
+{
+	ch7036_device_context_t *p_ctx= pDevContext->pd_context;
+	pd_reg_t reg_list[2];
+
+
+
+	reg_list[0].reg = (i2c_reg_t)index;
+	reg_list[0].value = (i2c_reg_t)value;
+
+	reg_list[1].reg = PD_REG_LIST_END;
+
+	p_ctx->p_callback->write_regs(p_ctx->p_callback->callback_context, reg_list,PD_REG_DDC_FW);
+
+	return;
+}
+
+
+void I2CBlockWrite(DEV_CONTEXT* pDevContext,uint8 index, uint8* value, uint16 len)
+{
+	ch7036_device_context_t *p_ctx= pDevContext->pd_context;
+	pd_reg_t reg_list[33];
+	uint16 i=0;
+
+
+
+	for(i=0;i<len;i++) {
+		reg_list[i].reg = (i2c_reg_t)index;
+		reg_list[i].value = (i2c_reg_t)value[i];
+	}
+
+	reg_list[len].reg = PD_REG_LIST_END;
+
+	p_ctx->p_callback->write_regs(p_ctx->p_callback->callback_context, reg_list,PD_REG_DDC_FW);
+
+	return;
+}
+
+ch7036_status_t ch7036_device_prepare(ch7036_device_context_t* p_ctx)
+{
+	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
+	ch7036_status_t status = SS_SUCCESS;
+
+	PD_DEBUG("ch7036_intf: ch7036_device_prepare()\n");
+
+
+	if(!DevicePrepare(p_ch_ctx))
+	{
+		p_ctx->last_emsg = GetLastErrorMessage();
+		status = SS_UNSUCCESSFUL;
+	}
+
+	return status;
+}
+
+ch7036_status_t ch7036_device_config(ch7036_device_context_t* p_ctx)
+{
+	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
+	ch7036_status_t status = SS_SUCCESS;
+
+	PD_DEBUG("ch7036_intf: ch7036_device_config()\n");
+#if 0
+	printk ("p_ch_ctx->DeviceID = 0x%X\n", p_ch_ctx->DeviceID);
+	printk ("p_ch_ctx->pInput_Info->timing->ht = 0x%X\n", p_ch_ctx->pInput_Info->timing.ht);
+	printk ("p_ch_ctx->pInput_Info->timing->ha = 0x%X\n", p_ch_ctx->pInput_Info->timing.ha);
+	printk ("p_ch_ctx->pInput_Info->timing->ho = 0x%X\n", p_ch_ctx->pInput_Info->timing.ho);
+	printk ("p_ch_ctx->pInput_Info->timing->hw = 0x%X\n", p_ch_ctx->pInput_Info->timing.hw);
+	printk ("p_ch_ctx->pInput_Info->timing->vt = 0x%X\n", p_ch_ctx->pInput_Info->timing.vt);
+	printk ("p_ch_ctx->pInput_Info->timing->va = 0x%X\n", p_ch_ctx->pInput_Info->timing.va);
+	printk ("p_ch_ctx->pInput_Info->timing->vo = 0x%X\n", p_ch_ctx->pInput_Info->timing.vo);
+	printk ("p_ch_ctx->pInput_Info->timing->vw = 0x%X\n", p_ch_ctx->pInput_Info->timing.vw);
+	printk ("p_ch_ctx->pInput_Info->timing->hz = 0x%X\n", p_ch_ctx->pInput_Info->timing.hz);
+	printk ("p_ch_ctx->pInput_Info->timing->stype = 0x%X\n", p_ch_ctx->pInput_Info->timing.stype);
+	printk ("p_ch_ctx->pInput_Info->rx_clk_khz = 0x%X\n", p_ch_ctx->pInput_Info->rx_clk_khz);
+	printk ("p_ch_ctx->pInput_Info->pixel_fmt = 0x%X\n", p_ch_ctx->pInput_Info->pixel_fmt);
+	printk ("p_ch_ctx->pInput_Info->hs_pol = 0x%X\n", p_ch_ctx->pInput_Info->hs_pol);
+	printk ("p_ch_ctx->pInput_Info->vs_pol = 0x%X\n", p_ch_ctx->pInput_Info->vs_pol);
+	printk ("p_ch_ctx->pInput_Info->de_pol = 0x%X\n", p_ch_ctx->pInput_Info->de_pol);
+	printk ("p_ch_ctx->pInput_Info->data_ch_pol = 0x%X\n", p_ch_ctx->pInput_Info->data_ch_pol);
+	printk ("p_ch_ctx->pInput_Info->data_ch_invert = 0x%X\n", p_ch_ctx->pInput_Info->data_ch_invert);
+	printk ("p_ch_ctx->pInput_Info->audio_type = 0x%X\n", p_ch_ctx->pInput_Info->audio_type);
+	printk ("p_ch_ctx->pInput_Info->i2s_pol = 0x%X\n", p_ch_ctx->pInput_Info->i2s_pol);
+	printk ("p_ch_ctx->pInput_Info->i2s_len = 0x%X\n", p_ch_ctx->pInput_Info->i2s_len);
+	printk ("p_ch_ctx->pInput_Info->i2s_fmt = 0x%X\n", p_ch_ctx->pInput_Info->i2s_fmt);
+
+	printk ("\n\n");
+
+	printk ("p_ch_ctx->pOutput_Info->channel = 0x%X\n", p_ch_ctx->pOutput_Info->channel );
+	printk ("p_ch_ctx->pOutput_Info->uclk_khz = 0x%X\n", p_ch_ctx->pOutput_Info->uclk_khz );
+	printk ("p_ch_ctx->pOutput_Info->ds_percent_h = 0x%X\n", p_ch_ctx->pOutput_Info->ds_percent_h );
+	printk ("p_ch_ctx->pOutput_Info->ds_percent_v = 0x%X\n", p_ch_ctx->pOutput_Info->ds_percent_v );
+	printk ("p_ch_ctx->pOutput_Info->rotate = 0x%X\n", p_ch_ctx->pOutput_Info->rotate );
+	printk ("p_ch_ctx->pOutput_Info->h_flip = 0x%X\n", p_ch_ctx->pOutput_Info->h_flip );
+	printk ("p_ch_ctx->pOutput_Info->v_flip = 0x%X\n", p_ch_ctx->pOutput_Info->v_flip );
+	printk ("p_ch_ctx->pOutput_Info->h_position = 0x%X\n", p_ch_ctx->pOutput_Info->h_position );
+	printk ("p_ch_ctx->pOutput_Info->v_position = 0x%X\n", p_ch_ctx->pOutput_Info->v_position );
+#endif
+	if(!DeviceConfig(p_ch_ctx))
+	{
+		p_ctx->last_emsg = GetLastErrorMessage();
+		status = SS_UNSUCCESSFUL;
+	}
+
+	return status;
+
+}
+
+ch7036_status_t ch7036_device_start(ch7036_device_context_t* p_ctx)
+{
+
+	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
+	ch7036_status_t status = SS_SUCCESS;
+
+	PD_DEBUG("ch7036_intf: ch7036_device_start()\n");
+
+	if(!DeviceRunning(p_ch_ctx))
+	{
+		p_ctx->last_emsg = GetLastErrorMessage();
+		status = SS_UNSUCCESSFUL;
+	}
+
+	return status;
+
+}
+
+ch7036_status_t ch7036_device_set_power(ch7036_device_context_t* p_ctx, unsigned long channel)
+{
+	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
+	ch7036_status_t status = SS_SUCCESS;
+
+	PD_DEBUG("ch7036_intf: ch7036_device_set_power()- channel [%ld]\n", channel);
+
+	if(!DeviceSetPower(p_ch_ctx,channel))
+	{
+		p_ctx->last_emsg = GetLastErrorMessage();
+		status = SS_UNSUCCESSFUL;
+	}
+
+	return status;
+}
+
+
+
+ch7036_status_t ch7036_load_firmware(ch7036_device_context_t* p_ctx)
+{
+
+	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
+
+	/*unsigned fs1;*/
+	/*uint8 ch;*/
+	ch7036_status_t status = SS_UNSUCCESSFUL;
+
+	PD_DEBUG("ch7036: ch7036_load_firmware()\n");
+
+
+	if(LHFM_load_firmware(p_ch_ctx) == -1) {
+
+		PD_DEBUG("ch7036_load_firmware: LHFM_load_firmware()- firmware loading FAILED\n");
+		p_ctx->last_emsg = GetLastErrorMessage();
+
+	}
+	else  {
+		PD_DEBUG("ch7036_load_firmware: LHFM_load_firmware()- firmware loading is a SUCCESS\n");
+		status = SS_SUCCESS;
+	}
+
+
+	return status;
+
+
+}
+
+
+ch7036_status_t ch7036_get_hdvi_display_modes_supported(ch7036_device_context_t* p_ctx)
+{
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	ch7036_status_t status;
+	ch7036_edid_blk_t* p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
+
+
+	PD_DEBUG("ch7036_get_hdvi_display_modes_supported()- enter\n");
+
+	status = LHFM_get_hdmi_modeinfo(p_ch7xxx_context,p_hedid->supported_modes);
+
+	if (status == SS_SUCCESS) {
+
+		PD_DEBUG("HDMI_Modes=%02X. Vesa_Modes=%02x\r\n", p_hedid->supported_modes[13], p_hedid->supported_modes[14]);
+		ch7036_dump("Prefered Mode Timing", 13, p_hedid->supported_modes);
+
+
+	}
+	else {
+		PD_DEBUG("ch7036_get_hdvi_display_modes_supported()-- failed!\r\n");
+		PD_DEBUG("status: [%s]\n",status == SS_FIRMWARE_TIMEOUT?"timeout!":"firmware_error!");
+
+
+	}
+
+	return status;
+}
+
+
+ch7036_status_t ch7036_read_edid(ch7036_device_context_t* p_ctx)
+{
+
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+	ch7036_status_t status = SS_UNSUCCESSFUL;
+	/*uint8 ebn;*/
+
+	/*int i;*/
+
+	ch7036_edid_blk_t* p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
+	ch7036_edid_blk_t* p_cedid = (ch7036_edid_blk_t *)p_ctx->cedid;
+
+	/*ch7036_attr_list_header_t* p_list_header;*/
+
+	unsigned char* hedidblk = p_hedid->edidblk;
+	unsigned char* cedidblk = p_cedid->edidblk;
+
+
+
+
+	if((p_ctx->hpd & 0x22) == 0) {
+
+		p_ctx->hpd &= 0xCC;
+		p_hedid->is_edid =0;
+		p_cedid->is_edid =0;
+		p_hedid->ebn = 0;
+		p_cedid->ebn = 0;
+
+
+		return status;
+
+	}
+
+
+	if( (p_ctx->hpd & 0x20) == 0x20  ) {
+
+
+		status = LHFM_get_edid(p_ch7xxx_context,hedidblk, &(p_hedid->ebn), CH7036_HDMI_DDC);
+
+		if(status == SS_SUCCESS) {
+
+			PD_DEBUG("ch7036_read_edid()- attached, hdmi-dvi edid read is a SUCCESS\n");
+			PD_DEBUG("ch7036_read_edid()- number of blocks read [%x]\n", p_hedid->ebn);
+
+			p_hedid->is_edid = 1;
+			if(p_hedid->ebn == 1)
+				pOutput_Info->hdmi_fmt.is_dvi_mode =1;
+			else
+				pOutput_Info->hdmi_fmt.is_dvi_mode =0;
+		}
+
+
+		else {
+				p_hedid->is_edid = 0;
+				PD_DEBUG("ch7036_read_edid()- attached, hdmi-dvi edid read is UNSUCCESSFUL\n");
+
+		}
+
+	}
+
+
+
+	else  {
+		PD_DEBUG("ch7036_read_edid()- hdmi HPD status has-or has NOT-  changed, and not attached- no edid needed...\n");
+		p_hedid->is_edid =0;
+
+	}
+
+
+
+
+
+	if( (p_ctx->hpd & 0x02) == 0x02) {
+		status = LHFM_get_edid(p_ch7xxx_context,cedidblk, &(p_cedid->ebn), CH7036_VGA_DDC);
+		if (status== SS_SUCCESS ) {
+			p_cedid->is_edid =1;
+			PD_DEBUG("ch7036_read_edid()- attached, crt edid read is a SUCCESS\n");
+			PD_DEBUG("ch7036_read_edid()- number of blocks read [%x]\n", p_cedid->ebn);
+
+		}
+		else {
+			p_cedid->is_edid =0;
+			PD_DEBUG("ch7036_read_edid()- crt edid read is UNSUCCESSFUL\n");
+		}
+
+	}
+	else {
+		PD_DEBUG("ch7036_read_edid()- crt HPD status has-or has NOT-  changed, and not attached- no edid needed...\n");
+		p_cedid->is_edid =0;
+	}
+
+	if( (p_hedid->is_edid == 0) && (p_cedid->is_edid ==0) )
+		return SS_UNSUCCESSFUL;
+	else
+		return SS_SUCCESS;
+}
+
+
+ch7036_status_t ch7036_get_attached_device(ch7036_device_context_t* p_ctx)
+{
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	/*OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;*/
+	uint8 reg;
+	ch7036_status_t status;
+
+	uint8 hpd;
+	/*uint8 ebn;*/
+
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x04);
+	reg = I2CRead(p_ch7xxx_context,0x52);
+	reg = reg & 0xEF;
+	I2CWrite(p_ch7xxx_context,0x52, reg);
+
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x01);
+	reg = I2CRead(p_ch7xxx_context,0x0F);
+	reg = reg & 0x7F;
+	I2CWrite(p_ch7xxx_context,0x0F, reg);
+
+
+	LHFM_enable_crt_hpd(p_ch7xxx_context);
+
+
+
+	status = LHFM_get_hdmi_hpd(p_ch7xxx_context, &hpd);
+
+
+
+	if(status == SS_SUCCESS) {
+
+
+		if( hpd == 0x81 ) {
+			if(p_ctx->hpd & CH7036HPD_HDVI_ATTACHED)  {
+				p_ctx->hpd = (p_ctx->hpd  & 0x0F) & (~CH7036HPD_HDVI_STATUS_CHANGED) | CH7036HPD_HDVI_ATTACHED | CH7036HPD_HDVI_HPD_STATUS;
+				PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status has not changed since last query and it's HIGH\n");
+			}
+			else {
+
+				p_ctx->hpd = (p_ctx->hpd  & 0x0F) | CH7036HPD_HDVI_STATUS_CHANGED | CH7036HPD_HDVI_ATTACHED | CH7036HPD_HDVI_HPD_STATUS;
+				PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status changed since last query and it's HIGH\n");
+			}
+		}
+		else if (hpd ==0x80) {
+			if( (p_ctx->hpd & CH7036HPD_HDVI_ATTACHED) ==0 )  {
+				p_ctx->hpd = (p_ctx->hpd  & 0x0F) & (~ CH7036HPD_HDVI_STATUS_CHANGED) & (~CH7036HPD_HDVI_ATTACHED) & (~CH7036HPD_HDVI_HPD_STATUS);
+			PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status not changed since last query and it's LOW\n");
+			}
+			else {
+				p_ctx->hpd = (p_ctx->hpd  & 0x0F) | CH7036HPD_HDVI_STATUS_CHANGED & (~CH7036HPD_HDVI_ATTACHED) & (~CH7036HPD_HDVI_HPD_STATUS);
+				PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status changed since last query and it's LOW\n");
+			}
+
+		}
+		else if (hpd == 0x01) {
+			p_ctx->hpd = (p_ctx->hpd  & 0x0F) & (~CH7036HPD_HDVI_STATUS_CHANGED) | CH7036HPD_HDVI_ATTACHED | CH7036HPD_HDVI_HPD_STATUS;
+			PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status has not changed since last query and it's HIGH\n");
+		}
+		else {
+			p_ctx->hpd &= 0x0F;
+			PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status has not changed since last query and it's LOW\n");
+		}
+
+
+
+		PD_DEBUG("ch7036: ch7036_get_attached_device()- SUCCESS- hdmi hpd [0x%x]\n", hpd);
+
+
+
+	}
+	else {
+		PD_DEBUG("ch7036: ch7036_get_attached_device()- NOT SUCCESS- hdmi hpd [0x%x]\n", hpd);
+		PD_DEBUG("status: [%s]\n",status == SS_FIRMWARE_TIMEOUT?"timeout!":"firmware_error!");
+
+
+		if ( (!p_ctx->init_done) &&  (hpd == 0x86) )  {
+
+			p_ctx->hpd |= CH7036HPD_HDVI_ATTACHED;
+			PD_DEBUG("ch7036_get_attached_device()- special case when status is unsuccessful, it's attached...\n");
+
+		}
+
+		else
+			p_ctx->hpd &= ~CH7036HPD_HDVI_ATTACHED;
+
+
+
+		PD_DEBUG("ch7036_get_attached_device()- not attached\n");
+		PD_DEBUG("ch7036_get_attached_device()- p_ctx-hpd [0x%x]\n",p_ctx->hpd);
+	}
+
+
+
+
+
+	status = LHFM_get_crt_hpd(p_ch7xxx_context);
+
+
+	if(status == SS_SUCCESS) {
+		if( (p_ctx->hpd & CH7036HPD_CRT_ATTACHED )== CH7036HPD_CRT_ATTACHED) {
+
+				p_ctx->hpd = ((p_ctx->hpd  & 0xF0) & (~CH7036HPD_CRT_STATUS_CHANGED) ) | CH7036HPD_CRT_ATTACHED | CH7036HPD_CRT_HPD_STATUS;
+				PD_DEBUG("ch7036_get_attached_device()- crt HPD status has NOT changed since last query and it's attached\n");
+				PD_DEBUG("ch7036_get_attached_device()- p_ctx-hpd [0x%x]\n",p_ctx->hpd);
+		}
+		else {
+
+			p_ctx->hpd = (p_ctx->hpd  & 0xF0) | CH7036HPD_CRT_STATUS_CHANGED | CH7036HPD_CRT_ATTACHED | CH7036HPD_CRT_HPD_STATUS;
+
+			PD_DEBUG("ch7036_get_attached_device()- crt HPD status has changed since last query and it's attached\n");
+			PD_DEBUG("ch7036_get_attached_device()- p_ctx-hpd [0x%x]\n",p_ctx->hpd);
+
+		}
+
+
+	}
+	else  {
+
+		if( (p_ctx->hpd & CH7036HPD_CRT_ATTACHED ) == 0 ) {
+			p_ctx->hpd = p_ctx->hpd & 0xF8;
+			PD_DEBUG("ch7036_get_attached_device()- crt HPD not changed, connected to ground- not attached\n");
+			PD_DEBUG("ch7036_get_attached_device()- p_ctx-hpd [0x%x]\n",p_ctx->hpd);
+		}
+		else {
+
+			p_ctx->hpd = (p_ctx->hpd & 0xF8) |  CH7036HPD_CRT_STATUS_CHANGED;
+			PD_DEBUG("ch7036_get_attached_device()- crt HPD status changed, connected to ground- not attached, LOW\n");
+			PD_DEBUG("ch7036_get_attached_device()- p_ctx-hpd [0x%x]\n",p_ctx->hpd);
+
+		}
+
+
+	}
+
+
+	return SS_SUCCESS;
+}
+
+
+void ch7036_reset(ch7036_device_context_t* p_ctx)
+{
+	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
+
+	ch7036_reset_mcu(p_ch_ctx);
+	ch7036_reset_datapath(p_ch_ctx);
+
+	return;
+}
+
+void ch7036_reset_datapath(DEV_CONTEXT* p_ch_ctx)
+{
+	uint8 reg=0x00;
+	PD_DEBUG("ch7036: ch7036_reset_datapath()- enter\n");
+
+    I2CWrite(p_ch_ctx,0x03, 0x04);
+	reg = I2CRead(p_ch_ctx,0x52);
+	reg = reg & 0xFE;
+
+	I2CWrite(p_ch_ctx,0x52, reg);
+
+
+	I2CWrite(p_ch_ctx,0x52, 0x2F);
+
+	return;
+}
+
+void ch7036_reset_mcu(DEV_CONTEXT* p_ch_ctx)
+{
+	uint8 reg=0x00;
+
+    I2CWrite(p_ch_ctx,0x03, 0x04);
+	reg = I2CRead(p_ch_ctx,0x52);
+	reg = reg & 0xFB;
+	I2CWrite(p_ch_ctx,0x52, reg);
+
+	I2CWrite(p_ch_ctx,0x52, 0x2F);
+
+	return;
+}
+
+
+
+
+
+void ch7036_set_input_timing_info(ch7036_device_context_t *p_ctx, INPUT_INFO* pInput_Info)
+{
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+
+	pd_timing_t * p_current_mode = p_ctx->native_dtd;
+	uint8 audio_id = AUDIO_SPDIF;
+	PD_DEBUG("ch7036_intf: ch7036_set_input_timing_info()-\n");
+
+
+	if (p_ctx->init_done) {
+
+
+		pInput_Info->timing.ht = p_current_mode->htotal+1;
+
+		pInput_Info->timing.ha = p_current_mode->width;
+		pInput_Info->timing.ho = p_current_mode->hsync_start - p_current_mode->hblank_start;
+		pInput_Info->timing.hw = p_current_mode->hsync_end - p_current_mode->hsync_start;
+		pInput_Info->timing.vt = p_current_mode->vtotal+1;
+
+		pInput_Info->timing.va = p_current_mode->height;
+		pInput_Info->timing.vo = p_current_mode->vsync_start - p_current_mode->vblank_start;
+		pInput_Info->timing.vw = p_current_mode->vsync_end - p_current_mode->vsync_start;
+
+
+		pInput_Info->rx_clk_khz = p_current_mode->dclk;
+
+
+		pInput_Info->hs_pol = ((uint8)(((p_current_mode)->mode_info_flags & PD_HSYNC_HIGH) >> 24 ))?1:0;
+		pInput_Info->vs_pol = ((uint8)(((p_current_mode)->mode_info_flags & PD_VSYNC_HIGH) >> 24))?1:0;
+
+	}
+
+
+
+
+
+	pInput_Info->pixel_fmt = PIXEL_FMT_18BIT;
+
+
+	pInput_Info->data_ch_pol = POL_NO_INV;
+
+
+	pInput_Info->data_ch_invert = POL_NO_INV;
+
+
+
+
+
+	pInput_Info->de_pol = POL_HIGH;
+
+
+
+
+
+	if(pOutput_Info->channel & CHANNEL_HDMI)
+		ch7036_set_audio_type(pInput_Info, audio_id);
+
+}
+
+void ch7036_set_output_timing_info(ch7036_device_context_t *p_ctx, OUTPUT_INFO* pOutput_Info)
+{
+
+
+	PD_DEBUG("ch7036: ch7036_set_output_timing_info()\n");
+
+	PD_DEBUG("ch7036_set_output_timing_info()- p_ctx = %X \n", p_ctx);
+
+
+	pOutput_Info->lvds_fmt.channel_swap = LVDS_CHANNEL_SWAP_DEF;
+	pOutput_Info->lvds_fmt.channel_pol = (POL_LOW << 4) | (POL_LOW << 3) | (POL_LOW << 2) | (POL_LOW << 1) | (POL_LOW << 0);
+	pOutput_Info->lvds_fmt.pixel_fmt = p_ctx->dither_select;
+
+
+
+	pOutput_Info->hdmi_fmt.channel_swap = 0;
+	pOutput_Info->hdmi_fmt.data_pol_invert = POL_NO_INV;
+	pOutput_Info->hdmi_fmt.protect_enable = 0;
+
+
+
+
+	if (pOutput_Info->channel & CHANNEL_HDMI)
+	{
+
+		if(!(pOutput_Info->hdmi_fmt.is_dvi_mode))
+		{
+
+
+			PD_DEBUG("ch7036_set_output_timing_info- hdmi mode index is [%x]\n",p_ctx->hdmi_mode_index);
+			pOutput_Info->hdmi_fmt.format_index = (uint8)hdmi_timing_table[p_ctx->hdmi_mode_index].fmt_index;
+			pOutput_Info->hdmi_fmt.aspect_ratio = (uint8)hdmi_timing_table[p_ctx->hdmi_mode_index].aspect;
+
+			pOutput_Info->timing.ht = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.ht;
+			pOutput_Info->timing.ha = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.ha;
+			pOutput_Info->timing.ho = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.ho;
+			pOutput_Info->timing.hw = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.hw;
+			pOutput_Info->timing.vt = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.vt;
+			pOutput_Info->timing.va = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.va;
+			pOutput_Info->timing.vo = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.vo;
+			pOutput_Info->timing.vw = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.vw;
+			pOutput_Info->uclk_khz = hdmi_timing_table[p_ctx->hdmi_mode_index].clk_freq;
+		}
+		else
+		{
+			pOutput_Info->hdmi_fmt.format_index = (uint8)dvi_timing_table[p_ctx->dvi_mode_index].fmt_index;
+			pOutput_Info->hdmi_fmt.aspect_ratio = (uint8)dvi_timing_table[p_ctx->dvi_mode_index].aspect;
+
+			pOutput_Info->timing.ht = dvi_timing_table[p_ctx->dvi_mode_index].timing.ht;
+			pOutput_Info->timing.ha = dvi_timing_table[p_ctx->dvi_mode_index].timing.ha;
+			pOutput_Info->timing.ho = dvi_timing_table[p_ctx->dvi_mode_index].timing.ho;
+			pOutput_Info->timing.hw = dvi_timing_table[p_ctx->dvi_mode_index].timing.hw;
+			pOutput_Info->timing.vt = dvi_timing_table[p_ctx->dvi_mode_index].timing.vt;
+			pOutput_Info->timing.va = dvi_timing_table[p_ctx->dvi_mode_index].timing.va;
+			pOutput_Info->timing.vo = dvi_timing_table[p_ctx->dvi_mode_index].timing.vo;
+			pOutput_Info->timing.vw = dvi_timing_table[p_ctx->dvi_mode_index].timing.vw;
+			pOutput_Info->uclk_khz = dvi_timing_table[p_ctx->dvi_mode_index].clk_freq;
+
+		}
+
+
+
+	} else if((pOutput_Info->channel & CHANNEL_VGA) && ((pOutput_Info->channel & CHANNEL_HDMI)==0x00) )
+	{
+
+
+
+		PD_DEBUG("ch7036_set_output_timing_info- crt mode index is [%ld]\n",p_ctx->crt_mode_index);
+		pOutput_Info->timing.ht = ch_vga_timing_table[p_ctx->crt_mode_index].timing.ht;
+		pOutput_Info->timing.ha = ch_vga_timing_table[p_ctx->crt_mode_index].timing.ha;
+		pOutput_Info->timing.ho = ch_vga_timing_table[p_ctx->crt_mode_index].timing.ho;
+		pOutput_Info->timing.hw = ch_vga_timing_table[p_ctx->crt_mode_index].timing.hw;
+		pOutput_Info->timing.vt = ch_vga_timing_table[p_ctx->crt_mode_index].timing.vt;
+		pOutput_Info->timing.va = ch_vga_timing_table[p_ctx->crt_mode_index].timing.va;
+		pOutput_Info->timing.vo = ch_vga_timing_table[p_ctx->crt_mode_index].timing.vo;
+		pOutput_Info->timing.vw = ch_vga_timing_table[p_ctx->crt_mode_index].timing.vw;
+		pOutput_Info->uclk_khz = ch_vga_timing_table[p_ctx->crt_mode_index].clk_freq;
+
+
+	} else
+		;
+
+
+	if(pOutput_Info->channel & CHANNEL_HDMI)
+		ch7036_set_hdmi_sync_polarity(pOutput_Info);
+
+	if(pOutput_Info->channel & CHANNEL_HDMI || pOutput_Info->channel & CHANNEL_VGA) {
+
+		ch7036_set_rotate (pOutput_Info);
+		ch7036_set_hflip (pOutput_Info);
+		ch7036_set_vflip (pOutput_Info);
+	}
+}
+
+void ch7036_set_prefer_timing_info(ch7036_device_context_t *p_ctx, PREFER_INFO* pPrefer_Info)
+{
+
+
+
+
+	PD_DEBUG("ch7036_intf: ch7036_set_prefer_timing_info()\n");
+
+
+	if (!p_ctx->init_done) {
+
+	pPrefer_Info->mclk_khz = 166000;
+	pPrefer_Info->uclkod_sel = 1;
+	pPrefer_Info->dat16_32b = 0;
+	pPrefer_Info->true24 = 0;
+	pPrefer_Info->true_com = 0;
+	pPrefer_Info->lvds_out_hs_tolerance = HS_TOLERANCE_LEVEL0;
+	pPrefer_Info->lvds_out_reset_bit_sel = RST_BIT_VSYNC;
+	pPrefer_Info->dither_filter_enable = DITHER_ENABLE;
+
+	pPrefer_Info->hscale_ratio_gate = 130;
+	pPrefer_Info->reset=0;
+	pPrefer_Info->vga_enable=0;
+
+	pPrefer_Info->text_enhancement = DEFAULT_TEXT_ENHANCE;
+	pPrefer_Info->pll_ref_dly = DEF_PLL_REF_DLY;
+	pPrefer_Info->pll_ref_fbdly = DEF_PLL_REF_FBDLY;
+	pPrefer_Info->lvds_txdrv_ctrl = DEF_LVDS_TXDRV_CTRL;
+
+	pPrefer_Info->eye_bgtrim=0;
+	pPrefer_Info->eye_dacg=0;
+	pPrefer_Info->eye_dri_demp=0;
+	pPrefer_Info->eye_dri_pll_cp=0;
+	pPrefer_Info->eye_dri_damp=0;
+	pPrefer_Info->eye_dri_pll_rlf=0;
+	pPrefer_Info->eye_rdac=0;
+
+	}
+
+	pPrefer_Info->scale_line_adjust = 0;
+
+
+
+}
+
+
+
+
+
+
+
+
+
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.h
new file mode 100644
index 0000000..11ce054
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.h
@@ -0,0 +1,216 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_intf.h
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+
+
+#ifndef _CH7036_INTF_H_
+#define _CH7036_INTF_H_
+
+#include <config.h>
+#include <igd_pd.h>
+#include <pd.h>
+#include <pd_print.h>
+
+
+#include "ch7036_typedef.h"
+#include "ch7036_iic.h"
+#include "ch7036.h"
+
+
+#include "config_.h"
+
+
+#include <linux/kernel.h>
+
+typedef unsigned char i2c_reg_t;
+
+
+
+#define DITHER_18_TO_18					0
+#define DITHER_18_TO_24					1
+#define DITHER_24_TO_18					2
+#define DITHER_24_TO_24					3
+
+
+#define DEFAULT_POSITION				2048
+#define DEFAULT_H_1080P_POSITION		2137
+#define HDMI_DEFAULT_UNDERSCAN			15
+#define CRT_DEFAULT_UNDERSCAN			18
+#define DEFAULT_ROTATE					0
+#define DEFAULT_HFLIP					0
+#define DEFAULT_VFLIP					0
+#define DEFAULT_TEXT_ENHANCE			7
+#define DEF_PLL_REF_DLY					0
+#define DEF_PLL_REF_FBDLY				1
+#define DEF_LVDS_TXDRV_CTRL				0
+#define DITHER_ENABLE					0
+#define DITHER_BYPASS					1
+
+
+typedef struct {
+    i2c_reg_t dev_D0 :1;
+    i2c_reg_t dev_D1 :1;
+    i2c_reg_t dev_D2 :1;
+    i2c_reg_t dev_D3 :1;
+    i2c_reg_t disp_D0:1;
+    i2c_reg_t disp_D1:1;
+    i2c_reg_t disp_D2:1;
+    i2c_reg_t disp_D3:1;
+} ch7036_power_states_t;
+
+
+
+typedef unsigned char ch7036_hpd_t;
+
+
+#define CH7036HPD_CRT_HPD_STATUS		0x01
+#define CH7036HPD_CRT_ATTACHED			0x02
+#define CH7036HPD_CRT_STATUS_CHANGED	0x04
+
+
+#define CH7036HPD_HDVI_HPD_STATUS		0x10
+#define CH7036HPD_HDVI_ATTACHED			0x20
+#define CH7036HPD_HDVI_STATUS_CHANGED	0x40
+
+
+
+typedef struct ch7036_s3_state {
+	unsigned long pwr_state;
+	pd_timing_t cur_timing;
+} ch7036_s3_state_t;
+
+
+
+
+typedef struct _ch7036_device_context {
+
+
+	void						*internal_lvds;
+	DEV_CONTEXT					*p_ch7xxx_context;
+    pd_callback_t				*p_callback;
+
+
+	pd_attr_t					*p_ch7036_attr_table;
+	pd_attr_t					*p_lvds_attr_table;
+
+	unsigned long				ch7036_num_attrs;
+	unsigned long				lvds_num_attrs;
+
+
+	HDMI_OUT_MODE 				hdmi_mode_index;
+	DVI_OUT_MODE 				dvi_mode_index;
+	CRT_OUT_MODE				crt_mode_index;
+
+
+	pd_timing_t					*p_lvds_table;
+
+	pd_timing_t					*native_dtd;
+	pd_timing_t					*p_cur_mode;
+
+	unsigned short				fp_width;
+	unsigned short				fp_height;
+
+	unsigned char				dither_select;
+
+
+	unsigned long				pwr_state;
+
+	unsigned char				init_done;
+
+
+	uint8						req_ddc;
+	uint8						lvds_only;
+	uint8						use_firmware;
+
+	ch7036_hpd_t				hpd;
+
+	uint32						prev_outchannel;
+
+	void*						fw;
+	void*						cedid;
+	void*						hedid;
+
+
+
+	uint32						last_emsg;
+
+} ch7036_device_context_t;
+
+
+
+
+#define PD_INTERNAL_LVDS_MODULE_OPEN(name, params) internal_lvds_open params
+#define PD_INTERNAL_LVDS_MODULE_POST_SET_MODE(name, params) internal_lvds_post_set_mode params
+#define PD_INTERNAL_LVDS_MODULE_SET_MODE(name, params) internal_lvds_set_mode params
+#define PD_INTERNAL_LVDS_MODULE_SET_POWER(name, params) internal_lvds_set_power params
+#define PD_INTERNAL_LVDS_MODULE_GET_POWER(name, params) internal_lvds_get_power params
+#define PD_INTERNAL_LVDS_MODULE_INIT_DEVICE(name, params) internal_lvds_init_device params
+#define PD_INTERNAL_LVDS_MODULE_CLOSE(name, params) internal_lvds_close params
+#define PD_INTERNAL_LVDS_MODULE_GET_ATTRIBUTES(name, params) internal_lvds_get_attrs params
+#define PD_INTERNAL_LVDS_MODULE_SET_ATTRIBUTES(name, params) internal_lvds_set_attrs params
+#define PD_INTERNAL_LVDS_MODULE_GET_TIMING_LIST(name, params) internal_lvds_get_timing_list params
+#define PD_INTERNAL_LVDS_MODULE_SAVE(name, params) internal_lvds_save params
+#define PD_INTERNAL_LVDS_MODULE_RESTORE(name, params) internal_lvds_restore params
+#define PD_INTERNAL_LVDS_MODULE_GET_PORT_STATUS(name, params) internal_lvds_get_port_status params
+
+
+
+ch7036_status_t ch7036_device_prepare(ch7036_device_context_t* p_ctx);
+ch7036_status_t ch7036_device_config(ch7036_device_context_t* p_ctx);
+ch7036_status_t ch7036_device_start(ch7036_device_context_t* p_ctx);
+ch7036_status_t ch7036_device_set_power(ch7036_device_context_t* p_ctx,unsigned long channel);
+
+
+void ch7036_set_input_timing_info(ch7036_device_context_t *p_ctx,INPUT_INFO* pInput_Info);
+void ch7036_set_output_timing_info (ch7036_device_context_t *p_ctx, OUTPUT_INFO* pOutput_Info);
+void ch7036_set_prefer_timing_info(ch7036_device_context_t *p_ctx,PREFER_INFO* pPrefer_Info);
+
+
+
+ch7036_status_t ch7036_load_firmware(ch7036_device_context_t* p_ctx);
+ch7036_status_t ch7036_get_attached_device(ch7036_device_context_t* p_ctx);
+ch7036_status_t ch7036_read_edid(ch7036_device_context_t* p_ctx);
+ch7036_status_t ch7036_get_hdvi_display_modes_supported(ch7036_device_context_t* p_ctx);
+
+
+
+
+
+
+void ch7036_reset_mcu(DEV_CONTEXT* p_ch_ctx);
+void ch7036_reset_datapath(DEV_CONTEXT* p_ch_ctx);
+void ch7036_reset(ch7036_device_context_t* p_ctx);
+
+
+
+extern uint32 GetLastErrorMessage(void);
+
+
+
+
+
+#endif
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_pm.c b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_pm.c
new file mode 100644
index 0000000..311905d
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_pm.c
@@ -0,0 +1,512 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_pm.c
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+
+#include "ch7036_typedef.h"
+#include "ch7036_iic.h"
+
+
+
+
+void ch7036_set_power_lvds(DEV_CONTEXT* pDevContext);
+void ch7036_set_power_hdmi(DEV_CONTEXT* pDevContext);
+void ch7036_set_power_crt(DEV_CONTEXT* pDevContext);
+
+void ch7036_set_power_lvds(DEV_CONTEXT* p_ch7xxx_context)
+{
+
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+	uint8 reg=0x00;
+
+
+	if(pOutput_Info->channel & CHANNEL_LVDS)
+	{
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x01);
+		reg = I2CRead(p_ch7xxx_context,0x1A);
+		reg = reg & 0xEF;
+		I2CWrite(p_ch7xxx_context,0x1A, reg);
+
+		reg = I2CRead(p_ch7xxx_context,0x11);
+		reg = reg & 0xEF;
+	  if(((pOutput_Info->channel & CHANNEL_HDMI)==0x00)&&
+		 ((pOutput_Info->channel & CHANNEL_VGA) == 0x00))
+	    {
+		 reg = reg | 0x80;
+	    }
+		 I2CWrite(p_ch7xxx_context,0x11, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x04);
+		reg = I2CRead(p_ch7xxx_context,0x66);
+		reg = reg & 0xFD;
+		I2CWrite(p_ch7xxx_context,0x66, reg);
+
+        reg = I2CRead(p_ch7xxx_context,0x64);
+		reg = reg & 0xFE;
+		I2CWrite(p_ch7xxx_context,0x64, reg);
+
+        reg = I2CRead(p_ch7xxx_context,0x63);
+		reg = reg & 0x03;
+		I2CWrite(p_ch7xxx_context,0x63, reg);
+
+        I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x0A);
+		reg = reg & 0xF7;
+        I2CWrite(p_ch7xxx_context,0x0A, reg);
+
+
+
+		if((pOutput_Info->channel & CHANNEL_HDMI) == 0x00 && (pOutput_Info->channel & CHANNEL_VGA) == 0x00){
+		 I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		 reg = I2CRead(p_ch7xxx_context,0x07);
+		 reg = reg | 0x02;
+		 I2CWrite(p_ch7xxx_context,0x07, reg);
+
+		 I2CWrite(p_ch7xxx_context,0x03, 0x04);
+		 reg = I2CRead(p_ch7xxx_context,0x54);
+		 reg = reg | 0x10;
+		 I2CWrite(p_ch7xxx_context,0x54, reg);
+
+		 I2CWrite(p_ch7xxx_context,0x03, 0x02);
+		 reg = I2CRead(p_ch7xxx_context,0x16);
+		 reg = reg | 0x08;
+
+
+		 I2CWrite(p_ch7xxx_context,0x16, reg);
+
+		}
+
+
+
+	}
+
+	if((pOutput_Info->channel & CHANNEL_LVDS) == 0x00)
+	{
+
+
+        I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x0A);
+		reg = reg | 0x08;
+        I2CWrite(p_ch7xxx_context,0x0A, reg);
+
+		if((pOutput_Info->channel & CHANNEL_HDMI) == 0x00 && (pOutput_Info->channel & CHANNEL_VGA)==0x00)
+		{
+		 I2CWrite(p_ch7xxx_context,0x03, 0x04);
+		 reg = I2CRead(p_ch7xxx_context,0x63);
+		 reg = reg | 0xFC;
+		 I2CWrite(p_ch7xxx_context,0x63, reg);
+
+		 reg = I2CRead(p_ch7xxx_context,0x64);
+		 reg = reg | 0x01;
+		 I2CWrite(p_ch7xxx_context,0x64, reg);
+		}
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x04);
+		reg = I2CRead(p_ch7xxx_context,0x66);
+		reg = reg | 0x02;
+		I2CWrite(p_ch7xxx_context,0x66, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x01);
+		reg = I2CRead(p_ch7xxx_context,0x11);
+		reg = reg | 0x10;
+		I2CWrite(p_ch7xxx_context,0x11, reg);
+
+		reg = I2CRead(p_ch7xxx_context,0x1A);
+		reg = reg | 0x10;
+		I2CWrite(p_ch7xxx_context,0x1A, reg);
+
+	}
+
+
+}
+
+void ch7036_set_power_hdmi(DEV_CONTEXT* p_ch7xxx_context)
+{
+
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+	INPUT_INFO* pInput_Info = p_ch7xxx_context->pInput_Info;
+	uint8 reg=0x00;
+
+
+   if(pOutput_Info->channel  & CHANNEL_HDMI)
+   {
+
+        I2CWrite(p_ch7xxx_context,0x03, 0x04);
+		reg = I2CRead(p_ch7xxx_context,0x52);
+		reg = reg & 0xEF;
+		I2CWrite(p_ch7xxx_context,0x52, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x0A);
+		reg = reg & 0xDF;
+		I2CWrite(p_ch7xxx_context,0x0A, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x09);
+		reg = reg & 0xBF;
+		I2CWrite(p_ch7xxx_context,0x09, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x09);
+		reg = reg & 0xF7;
+		I2CWrite(p_ch7xxx_context,0x09, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x09);
+		reg = reg & 0xEF;
+		I2CWrite(p_ch7xxx_context,0x09, reg);
+
+
+
+	   I2CWrite(p_ch7xxx_context,0x03, 0x01);
+		reg = I2CRead(p_ch7xxx_context,0x11);
+		reg = reg & 0x7F;
+	    I2CWrite(p_ch7xxx_context,0x11, reg);
+
+		 I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		 reg = I2CRead(p_ch7xxx_context,0x07);
+		 reg = reg & 0xFD;
+		 I2CWrite(p_ch7xxx_context,0x07, reg);
+
+		 I2CWrite(p_ch7xxx_context,0x03, 0x04);
+		reg = I2CRead(p_ch7xxx_context,0x54);
+		reg = reg & 0xEF;
+		I2CWrite(p_ch7xxx_context,0x54, reg);
+
+
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x07);
+		reg = reg & 0xFB;
+		I2CWrite(p_ch7xxx_context,0x07, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x09);
+		reg = reg & 0xFB;
+		I2CWrite(p_ch7xxx_context,0x09, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x01);
+		reg = I2CRead(p_ch7xxx_context,0x0E);
+		reg = reg & 0x7F;
+		I2CWrite(p_ch7xxx_context,0x0E, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x07);
+
+		if(pInput_Info->audio_type == AUDIO_I2S){
+
+		   reg = reg & 0xBF;
+		   reg = reg | 0x01;
+		}else{
+
+           reg = reg | 0x40;
+		   reg = reg & 0xFE;
+		}
+		I2CWrite(p_ch7xxx_context,0x07, reg);
+
+
+
+
+
+
+
+
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x01);
+		reg = I2CRead(p_ch7xxx_context,0x16);
+		reg = reg & 0xF7;
+		I2CWrite(p_ch7xxx_context,0x16, reg);
+
+		reg = I2CRead(p_ch7xxx_context,0x16);
+		reg = reg & 0xFE;
+		I2CWrite(p_ch7xxx_context,0x16, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x08);
+		reg = reg & 0x0F;
+		I2CWrite(p_ch7xxx_context,0x08, reg);
+
+		reg = I2CRead(p_ch7xxx_context,0x07);
+		reg = reg & 0xF7;
+		I2CWrite(p_ch7xxx_context,0x07, reg);
+
+		reg = I2CRead(p_ch7xxx_context,0x07);
+		reg = reg | 0x10;
+		I2CWrite(p_ch7xxx_context,0x07, reg);
+
+		reg = I2CRead(p_ch7xxx_context,0x09);
+		reg = reg & 0xFE;
+		I2CWrite(p_ch7xxx_context,0x09, reg);
+
+
+
+
+
+
+
+
+
+
+   }else {
+
+
+
+
+
+
+
+
+	   if((pOutput_Info->channel  & CHANNEL_VGA) == 0x00){
+
+        I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x0A);
+		reg = reg | 0x20;
+		I2CWrite(p_ch7xxx_context,0x0A, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x09);
+		reg = reg | 0x40;
+		I2CWrite(p_ch7xxx_context,0x09, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x09);
+		reg = reg | 0x08;
+		I2CWrite(p_ch7xxx_context,0x09, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x09);
+		reg = reg | 0x10;
+		I2CWrite(p_ch7xxx_context,0x09, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x07);
+		reg = reg | 0x04;
+		I2CWrite(p_ch7xxx_context,0x07, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x01);
+		 reg = I2CRead(p_ch7xxx_context,0x11);
+		 reg = reg | 0x80;
+		 I2CWrite(p_ch7xxx_context,0x11, reg);
+
+
+		 I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		 reg = I2CRead(p_ch7xxx_context,0x07);
+		 reg = reg | 0x02;
+		 I2CWrite(p_ch7xxx_context,0x07, reg);
+
+
+		 I2CWrite(p_ch7xxx_context,0x03, 0x04);
+		 reg = I2CRead(p_ch7xxx_context,0x54);
+		 reg = reg | 0x10;
+		 I2CWrite(p_ch7xxx_context,0x54, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		 reg = I2CRead(p_ch7xxx_context,0x09);
+		 reg = reg | 0x04;
+		 I2CWrite(p_ch7xxx_context,0x09, reg);
+
+		}
+
+
+
+
+
+
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x07);
+		reg = reg | 0x40;
+		reg = reg | 0x01;
+		I2CWrite(p_ch7xxx_context,0x07, reg);
+
+
+
+
+
+
+
+		if((pOutput_Info->channel  & CHANNEL_LVDS) == 0x00)
+		{
+		 I2CWrite(p_ch7xxx_context,0x03, 0x01);
+		 reg = I2CRead(p_ch7xxx_context,0x16);
+		 reg = reg | 0x08;
+		 I2CWrite(p_ch7xxx_context,0x16, reg);
+		}
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x01);
+		reg = I2CRead(p_ch7xxx_context,0x16);
+		reg = reg | 0x01;
+		I2CWrite(p_ch7xxx_context,0x16, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x08);
+		reg = reg | 0xF0;
+		I2CWrite(p_ch7xxx_context,0x08, reg);
+
+		reg = I2CRead(p_ch7xxx_context,0x07);
+		reg = reg | 0x08;
+		I2CWrite(p_ch7xxx_context,0x07, reg);
+
+		reg = I2CRead(p_ch7xxx_context,0x07);
+		reg = reg | 0x10;
+		I2CWrite(p_ch7xxx_context,0x07, reg);
+
+		reg = I2CRead(p_ch7xxx_context,0x09);
+		reg = reg | 0x01;
+		I2CWrite(p_ch7xxx_context,0x09, reg);
+
+
+   }
+
+}
+
+void ch7036_set_power_crt(DEV_CONTEXT* p_ch7xxx_context)
+{
+
+
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+	uint8 reg=0x00;
+
+
+	if(pOutput_Info->channel & CHANNEL_VGA)
+	 {
+
+	   I2CWrite(p_ch7xxx_context,0x03, 0x01);
+		reg = I2CRead(p_ch7xxx_context,0x11);
+		reg = reg & 0x7F;
+	    I2CWrite(p_ch7xxx_context,0x11, reg);
+
+
+
+
+
+
+
+
+
+
+
+
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x0A);
+		reg = reg & 0xDF;
+		I2CWrite(p_ch7xxx_context,0x0A, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x09);
+		reg = reg & 0xBF;
+		I2CWrite(p_ch7xxx_context,0x09, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x09);
+		reg = reg & 0xF7;
+		I2CWrite(p_ch7xxx_context,0x09, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x09);
+		reg = reg & 0xEF;
+		I2CWrite(p_ch7xxx_context,0x09, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x07);
+		reg = reg & 0xF9;
+		I2CWrite(p_ch7xxx_context,0x07, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x04);
+		reg = I2CRead(p_ch7xxx_context,0x54);
+		reg = reg & 0xEF;
+		I2CWrite(p_ch7xxx_context,0x54, reg);
+
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x08);
+		reg = reg & 0xF1;
+		I2CWrite(p_ch7xxx_context,0x08, reg);
+
+		reg = I2CRead(p_ch7xxx_context,0x09);
+		reg = reg & 0xFB;
+		I2CWrite(p_ch7xxx_context,0x09, reg);
+
+	}else if((pOutput_Info->channel & CHANNEL_VGA) == 0x00){
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+
+		 reg = I2CRead(p_ch7xxx_context,0x08);
+		reg = reg | 0x0E;
+		I2CWrite(p_ch7xxx_context,0x08, reg);
+
+
+
+		if((pOutput_Info->channel & CHANNEL_HDMI)==0x00){
+	     I2CWrite(p_ch7xxx_context,0x03, 0x01);
+		 reg = I2CRead(p_ch7xxx_context,0x11);
+		 reg = reg | 0x80;
+	     I2CWrite(p_ch7xxx_context,0x11, reg);
+
+		  I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		 reg = I2CRead(p_ch7xxx_context,0x07);
+		 reg = reg | 0x02;
+		 I2CWrite(p_ch7xxx_context,0x07, reg);
+
+
+		 I2CWrite(p_ch7xxx_context,0x03, 0x04);
+		 reg = I2CRead(p_ch7xxx_context,0x54);
+		 reg = reg | 0x10;
+		 I2CWrite(p_ch7xxx_context,0x54, reg);
+
+
+        I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x0A);
+		reg = reg | 0x20;
+		I2CWrite(p_ch7xxx_context,0x0A, reg);
+
+		reg = I2CRead(p_ch7xxx_context,0x09);
+		reg = reg | 0x40;
+		I2CWrite(p_ch7xxx_context,0x09, reg);
+
+		reg = I2CRead(p_ch7xxx_context,0x09);
+		reg = reg | 0x08;
+		I2CWrite(p_ch7xxx_context,0x09, reg);
+
+		reg = I2CRead(p_ch7xxx_context,0x09);
+		reg = reg | 0x10;
+		I2CWrite(p_ch7xxx_context,0x09, reg);
+
+		reg = I2CRead(p_ch7xxx_context,0x07);
+		reg = reg | 0x04;
+		I2CWrite(p_ch7xxx_context,0x07, reg);
+
+
+		 reg = I2CRead(p_ch7xxx_context,0x09);
+		 reg = reg | 0x04;
+		 I2CWrite(p_ch7xxx_context,0x09, reg);
+	   }
+	}
+
+	return;
+}
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.c b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.c
new file mode 100644
index 0000000..7a59f64
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.c
@@ -0,0 +1,1164 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_port.c
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+
+
+
+#include "ch7036_port.h"
+#include "ch7036_fw.h"
+#include "lvds/lvds.h"
+#include <linux/kernel.h>
+
+
+
+
+static pd_version_t  g_ch7036_version = {1, 0, 0, 0};
+static unsigned long g_ch7036_dab_list[] = {0xEC,PD_DAB_LIST_END};
+
+
+void ch7036_update_position(ch7036_device_context_t *p_ctx, OUTPUT_INFO* pOutput_Info);
+int ch7036_initialize_device(ch7036_device_context_t *p_ctx);
+
+
+static pd_driver_t	 g_ch7036_drv = {
+	PD_SDK_VERSION,
+	"Chrontel CH7036 Port Driver",
+	0,
+	&g_ch7036_version,
+	PD_DISPLAY_LVDS_INT,
+	PD_FLAG_UP_SCALING,
+	g_ch7036_dab_list,
+	100,
+	ch7036_validate,
+	ch7036_open,
+	ch7036_init_device,
+	ch7036_close,
+	ch7036_set_mode,
+	ch7036_post_set_mode,
+	ch7036_set_attributes,
+	ch7036_get_attributes,
+	ch7036_get_timing_list,
+	ch7036_set_power,
+	ch7036_get_power,
+	ch7036_save,
+	ch7036_restore,
+	ch7036_get_port_status
+};
+
+
+
+ch7036_edid_blk_t crt_edid;
+ch7036_edid_blk_t hdvi_edid;
+
+
+
+
+
+int PD_MODULE_INIT(ch7036_init, (void *handle))
+{
+	int status;
+
+	PD_DEBUG("ch7036: ch7036_init()\n");
+
+	status = pd_register(handle, &g_ch7036_drv);
+	if (status != PD_SUCCESS) {
+		PD_DEBUG("ch7036: Error ! ch7036_init: pd_register() failed with "
+				  "status=%#x\n", status);
+	}
+	return status;
+}
+
+
+
+int PD_MODULE_EXIT(ch7036_exit, (void))
+{
+	PD_DEBUG("ch7036: ch7036_exit()\n");
+
+	return (PD_SUCCESS);
+}
+
+
+unsigned long ch7036_validate(unsigned long cookie)
+{
+	PD_DEBUG("ch7036: ch7036_validate()\n");
+	return cookie;
+}
+
+
+int ch7036_open(pd_callback_t *p_callback, void **pp_context)
+{
+	uint8 device_ID;
+	/*uint8 reg;*/
+	ch7036_device_context_t* p_ctx;
+	DEV_CONTEXT* p_ch7xxx_context;
+
+	/*uint8 page, n;*/
+
+	int ret;
+
+
+	PD_DEBUG("ch7036: ch7036_open()\n");
+
+	ret = PD_INTERNAL_LVDS_MODULE_OPEN(ch7036_internal_lvds_open,(p_callback, pp_context));
+	if ( ret != PD_SUCCESS)
+	{
+		pd_free(p_ctx->fw);
+		pd_free(p_ctx);
+		return ret;
+	}
+
+
+	p_ctx = pd_malloc(sizeof(ch7036_device_context_t));
+	if (p_ctx == NULL) {
+		goto exit6;
+	}
+
+	pd_memset(p_ctx, 0, sizeof(ch7036_device_context_t));
+
+	p_ctx->fw = (FW7036_CFG *)(pd_malloc(sizeof(FW7036_CFG)));
+
+	if (p_ctx == NULL) {
+		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating FW7036_CFG struct\n");
+		goto exit5;
+	}
+
+
+	if (p_ctx == NULL || *pp_context == NULL || p_callback == NULL) {
+		goto exit5;
+	}
+
+	p_ctx->internal_lvds = *pp_context;
+
+	p_ctx->p_callback = p_callback;
+
+
+	p_ctx->p_ch7xxx_context = pd_malloc(sizeof(DEV_CONTEXT));
+	if (p_ctx->p_ch7xxx_context == NULL) {
+		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating DEV_CONTEXT struct");
+		goto exit4;
+	}
+
+	p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+
+	p_ch7xxx_context->pd_context = (void *)p_ctx;
+
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x04);
+
+	device_ID = I2CRead(p_ch7xxx_context,0x50);
+
+	PD_DEBUG("ch7036: ch7036_open()- read device ID= 0x%.2X\n", device_ID);
+
+
+
+	if(device_ID != 0x56)
+	{
+		PD_DEBUG("ch7036: ch7036_open()- device is NOT found...\n");
+
+		if(p_ch7xxx_context->pd_context)
+			p_ch7xxx_context->pd_context=NULL;
+		pd_free(p_ch7xxx_context);
+		if(p_ctx->internal_lvds) {
+			p_ctx->internal_lvds=NULL;
+
+		}
+		pd_free(p_ctx->fw);
+		pd_free(p_ctx);
+		return PD_ERR_NODEV;
+
+	}
+	else
+	{
+		PD_DEBUG("ch7036: ch7036_open()- ch7036 device is found...\n");
+
+
+	}
+
+
+	p_ch7xxx_context->DeviceID = device_ID;
+
+
+	p_ctx->hpd = 0;
+
+	if (ch7036_load_firmware(p_ctx) != SS_SUCCESS)   {
+		p_ctx->use_firmware =0;
+		p_ctx->cedid = NULL;
+		p_ctx->hedid = NULL;
+
+
+	}
+	else {
+		p_ctx->use_firmware =1;
+		p_ctx->cedid = (ch7036_edid_blk_t *)&crt_edid;
+		p_ctx->hedid = (ch7036_edid_blk_t *)&hdvi_edid;
+
+	}
+
+
+
+	p_ch7xxx_context->pInput_Info = pd_malloc(sizeof(INPUT_INFO));
+	if (p_ch7xxx_context->pInput_Info == NULL) {
+		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating INPUT_INFO struct");
+
+		goto exit3;
+	}
+
+	p_ch7xxx_context->pOutput_Info = pd_malloc(sizeof(OUTPUT_INFO));
+	if (p_ch7xxx_context->pOutput_Info == NULL) {
+		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating OUTPUT_INFO struct");
+
+		goto exit2;
+	}
+
+	p_ch7xxx_context->pPrefer_Info = pd_malloc(sizeof(PREFER_INFO));
+	if (p_ch7xxx_context->pPrefer_Info == NULL) {
+		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating PREFER_INFO struct");
+
+		goto exit1;
+	}
+
+
+
+
+	p_ctx->p_ch7036_attr_table = NULL;
+
+	if( ch7036_init_attribute_table(p_ctx, NULL) == SS_MEM_ALLOC_ERR)
+	{
+		pd_free(p_ch7xxx_context->pPrefer_Info);
+		goto exit1;
+	}
+
+	ch7036_initialize_device(p_ctx);
+
+
+	g_ch7036_drv.type = PD_DISPLAY_LVDS_INT;
+
+
+	*pp_context = (void *)p_ctx;
+
+	return (PD_SUCCESS);
+
+exit1:
+	pd_free(p_ch7xxx_context->pOutput_Info);
+exit2:
+	pd_free(p_ch7xxx_context->pInput_Info);
+exit3:
+	p_ch7xxx_context->pd_context=NULL;
+	pd_free(p_ch7xxx_context);
+exit4:
+	pd_free(p_ctx->internal_lvds);
+	pd_free(p_ctx->fw);
+exit5:
+	pd_free(p_ctx);
+exit6:
+	return PD_ERR_NOMEM;
+}
+
+
+int ch7036_init_device(void *p_context)
+{
+	ch7036_device_context_t* p_ctx  = (ch7036_device_context_t*)p_context;
+
+	PD_DEBUG("ch7036: ch7036_init_device()-enter\n");
+
+	p_ctx->init_done = 1;
+
+	return (PD_INTERNAL_LVDS_MODULE_INIT_DEVICE(ch7036_init_device, (p_ctx->internal_lvds)));
+
+}
+
+
+
+int ch7036_set_mode(void *p_context, pd_timing_t *p_mode, unsigned long flags)
+{
+
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t*)p_context;
+
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	INPUT_INFO* pInput_Info = p_ch7xxx_context->pInput_Info;
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+	PREFER_INFO* pPrefer_Info = p_ch7xxx_context->pPrefer_Info;
+	int ret, channel_on=0;
+
+
+	PD_DEBUG("ch7036: ch7036_set_mode()-enter\n");
+
+
+
+	if (!p_ctx || !p_mode) {
+		return (PD_ERR_NULL_PTR);
+	}
+
+	if (p_ch7xxx_context->DeviceID != 0x56)
+	{
+		return (PD_ERR_NULL_PTR);
+	}
+	PD_DEBUG("ch7036_set_mode: requested width = %u height = %u\n",
+		p_mode->width, p_mode->height);
+
+
+	if (
+		(p_ctx->fp_width && (p_mode->width > p_ctx->fp_width)) ||
+		(p_ctx->fp_height && (p_mode->height > p_ctx->fp_height))
+		) {
+		return PD_ERR_MODE_NOTSUPP;
+	}
+
+
+	p_ctx->p_cur_mode = p_mode;
+
+
+	if(pOutput_Info->channel  == CHANNEL_LVDS_HDMI_VGA_OFF) {
+
+		pOutput_Info->channel = ch7036_get_output_channel(p_ctx);
+		channel_on =1;
+	}
+
+
+
+
+	if(pOutput_Info->channel == CHANNEL_LVDS && p_ctx->use_firmware ) {
+		pOutput_Info->channel = CHANNEL_LVDS_HDMI;
+		p_ctx->req_ddc =1;
+	}
+	if (pOutput_Info->channel == CHANNEL_LVDS) {
+		pOutput_Info->channel = CHANNEL_LVDS_HDMI;
+		p_ctx->lvds_only =1;
+	}
+
+
+	ch7036_set_input_timing_info(p_ctx,pInput_Info);
+	ch7036_set_output_timing_info(p_ctx, pOutput_Info);
+	ch7036_set_prefer_timing_info(p_ctx,pPrefer_Info);
+
+
+	if(ch7036_device_prepare(p_ctx)== SS_UNSUCCESSFUL)
+	{
+		PD_DEBUG("ch7036_set_mode: ch7036_device_prepare()- NOT SUCCESS\n");
+		return PD_ERR_UNSUCCESSFUL;
+	}
+
+
+	ch7036_update_position(p_ctx, pOutput_Info);
+
+	if(ch7036_device_config(p_ctx) == SS_UNSUCCESSFUL)
+	{
+		PD_DEBUG("ch7036_set_mode: ch7036_device_config()- NOT SUCCESS\n");
+		return PD_ERR_UNSUCCESSFUL;
+	}
+
+	if(channel_on)
+		pOutput_Info->channel = CHANNEL_LVDS_HDMI_VGA_OFF;
+
+	ret = PD_INTERNAL_LVDS_MODULE_SET_MODE(ch7036_internal_lvds_set_mode,(p_ctx->internal_lvds,p_mode,flags));
+	if(ret != PD_SUCCESS)
+		return ret;
+
+
+	return PD_SUCCESS;
+}
+//thua- 10/24/11- when user switches back and forth from VGA to HDMI or vice versa
+//need to set h/v pos. accordingly
+void ch7036_update_position(ch7036_device_context_t *p_ctx, OUTPUT_INFO* pOutput_Info)
+{
+
+	PD_DEBUG("ch7036: ch7036_update_position()- enter\n");
+
+
+	if(pOutput_Info->channel & CHANNEL_HDMI) {
+
+		pOutput_Info->h_position = DEFAULT_POSITION;
+		pOutput_Info->v_position = DEFAULT_POSITION;
+
+	}
+	else {//pOutput_Info->channel & CHANNEL_VGA; CHANNEL_LVDS would never come here
+
+			pOutput_Info->h_position =  pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_HPOSITION,
+					PD_GET_ATTR_LIST)->current_value;
+			pOutput_Info->v_position = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_VPOSITION,
+					PD_GET_ATTR_LIST)->current_value;
+
+	}
+
+	PD_DEBUG("ch7036: ch7036_update_position()- h pos [%d]\n",pOutput_Info->h_position);
+	PD_DEBUG("ch7036: ch7036_update_position()- v pos [%d]\n",pOutput_Info->v_position);
+
+	return;
+}
+
+
+int ch7036_post_set_mode(void *p_context, pd_timing_t *p_mode,
+						  unsigned long flags)
+{
+
+
+	ch7036_device_context_t* p_ctx  = (ch7036_device_context_t*)p_context;
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+
+	int ret;
+	/*uint8 page, n;*/
+	pd_list_entry_attr_t  *list_entry;
+
+
+
+	if (!p_ctx || !p_mode ) {
+		return (PD_ERR_NULL_PTR);
+	}
+
+	if (p_ch7xxx_context->DeviceID != 0x56)
+	{
+		return (PD_ERR_NULL_PTR);
+	}
+
+	list_entry = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs, PD_ATTR_ID_DISPLAY, PD_GET_ATTR_LIST_ENTRY);
+	ch7036_set_output_channel(p_ctx,(uint32)(list_entry->value));
+
+
+	PD_DEBUG("ch7036_post_set_mode- current output channel is [%x]\n",pOutput_Info->channel);
+
+	if(ch7036_device_start(p_ctx) == SS_UNSUCCESSFUL)
+	{
+		PD_DEBUG("ch7036_post_set_mode: ch7036_device_start()- NOT SUCCESS\n");
+		return PD_ERR_UNSUCCESSFUL;
+	}
+
+
+
+	p_ctx->req_ddc = 0;
+	p_ctx->lvds_only = 0;
+
+#if 0
+	if(p_ctx->req_ddc && pOutput_Info->channel == CHANNEL_LVDS_HDMI && p_ctx->use_firmware) {
+
+		pOutput_Info->channel = CHANNEL_LVDS;
+		p_ctx->req_ddc = 0;
+	}
+
+	if (p_ctx->lvds_only  && pOutput_Info->channel == CHANNEL_LVDS_HDMI) {
+		pOutput_Info->channel = CHANNEL_LVDS;
+		p_ctx->lvds_only = 0;
+	}
+
+#endif
+
+	ret = PD_INTERNAL_LVDS_MODULE_POST_SET_MODE(ch7036_post_set_mode,(p_ctx->internal_lvds,p_mode,flags));
+
+	if(ret != PD_SUCCESS)
+		return ret;
+	else
+	{
+		ch7036_reset_datapath(p_ch7xxx_context);
+		pd_usleep(50);
+		ch7036_device_set_power(p_ctx, pOutput_Info->channel);
+	}
+
+
+	return PD_SUCCESS;
+}
+
+
+
+
+
+int ch7036_close(void *p_context)
+{
+
+	ch7036_device_context_t* p_ctx  = (ch7036_device_context_t*)p_context;
+
+	PD_DEBUG("ch7036: ch7036_close()\n");
+
+	PD_INTERNAL_LVDS_MODULE_CLOSE(ch7036_internal_lvds_close, (p_ctx->internal_lvds));
+
+	if (p_ctx!= NULL)
+	{
+
+		pd_free(p_ctx->p_ch7xxx_context->pInput_Info);
+		pd_free(p_ctx->p_ch7xxx_context->pOutput_Info);
+		pd_free(p_ctx->p_ch7xxx_context->pPrefer_Info);
+		pd_free(p_ctx->p_ch7xxx_context);
+		pd_free(p_ctx->p_ch7036_attr_table);
+		pd_free(p_ctx);
+	}
+
+	return PD_SUCCESS;
+}
+
+
+int ch7036_get_timing_list(void *p_context, pd_timing_t *p_in_list,
+	pd_timing_t **pp_out_list)
+{
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	/*OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;*/
+
+	int ret;
+//	int i;
+//	pd_timing_t * p_table;
+//	internal_lvds_context_t * p_lvds = (internal_lvds_context_t *)(p_ctx->internal_lvds);
+
+	PD_DEBUG("ch7036: ch7036_get_timing_list()-enter\n");
+
+	if (p_ch7xxx_context->DeviceID != 0x56)
+	{
+		return (PD_ERR_NULL_PTR);
+	}
+
+
+	if ( (g_ch7036_drv.type & PD_DISPLAY_LVDS_INT) || (g_ch7036_drv.type & PD_DISPLAY_LVDS_LHDV) )
+	{
+		ret = PD_INTERNAL_LVDS_MODULE_GET_TIMING_LIST(ch7036_internal_lvds_get_timing_list, (p_ctx->internal_lvds,p_in_list,pp_out_list));
+		PD_ERROR("ch7036: ch7036_get_timing_list()- ret = %X\n", ret);
+
+
+
+		p_ctx->p_lvds_table = *pp_out_list;
+
+#ifdef T_PANEL_NATIVE_DTD
+
+
+
+		p_ctx->native_dtd = ((internal_lvds_context_t *)(p_ctx->internal_lvds))->native_dtd;
+		p_ctx->fp_width = ((internal_lvds_context_t *)(p_ctx->internal_lvds))->fp_width;
+		p_ctx->fp_height = ((internal_lvds_context_t *)(p_ctx->internal_lvds))->fp_height;
+
+		if( (p_ctx->fp_width == 0) || (p_ctx->fp_height == 0) )
+		{	PD_ERROR("ch7036: ch7036_get_timing_list()- ret = PD_ERR_NO_TIMINGS\n" );
+			return PD_ERR_NO_TIMINGS ;
+		}
+#else
+
+		for(i=0,p_table = *pp_out_list;i< 30;i++)
+			{
+
+				if((p_table->width == 1024) && (p_table->height == 768 )&&
+					(p_table->refresh == 60) )
+				{
+
+					p_ctx->native_dtd =  p_table;
+					p_ctx->fp_width = p_table->width;
+					p_ctx->fp_height = p_table->height;
+
+					break;
+				}
+
+				p_table= (pd_timing_t*)((uint8*)p_table + (sizeof(pd_timing_t)+4));
+
+			}
+
+			p_lvds->native_dtd = p_ctx->native_dtd;
+			p_lvds->fp_width = p_ctx->fp_width;
+			p_lvds->fp_height = p_ctx->fp_height;
+
+#endif
+
+	}
+
+	PD_ERROR("ch7036: ch7036_get_timing_list()- return ret=%X;\n", ret);
+	return ret;
+
+}
+
+
+
+int ch7036_get_attributes(void *p_context, unsigned long *p_num_attr,
+	pd_attr_t **pp_list)
+{
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	/*int ret;*/
+
+	PD_DEBUG("ch7036: ch7036_get_attributes()-enter\n");
+
+	if (p_ch7xxx_context->DeviceID != 0x56)
+	{
+		return (PD_ERR_NULL_PTR);
+	}
+
+
+	if (!p_ctx || !p_num_attr || !pp_list) {
+		return PD_ERR_NULL_PTR;
+	}
+
+	*pp_list = p_ctx->p_ch7036_attr_table;
+
+
+	*p_num_attr  = p_ctx->ch7036_num_attrs;
+
+	PD_DEBUG("ch7036: ch7036_get_attributes()- total num_attrs = [%u]\n",*p_num_attr);
+
+	return PD_SUCCESS;
+}
+
+
+int ch7036_set_attributes(void *p_context, unsigned long num_attrs,
+	pd_attr_t *p_list)
+{
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+	pd_list_entry_attr_t* list_item;
+
+	pd_port_status_t port_status;
+
+
+	pd_attr_t        *p_curr, *p_attr;
+	int ret;
+	unsigned long i;
+
+	PD_DEBUG("ch7036: ch7036_set_attributes()-enter: num_attrs=%u\n", num_attrs);
+
+	if (p_ch7xxx_context->DeviceID != 0x56)
+	{
+		return (PD_ERR_NULL_PTR);
+	}
+
+
+	ret = PD_INTERNAL_LVDS_MODULE_SET_ATTRIBUTES(ch7036_set_attrs, (p_ctx->internal_lvds,num_attrs,p_list));
+
+
+
+	if(ret != PD_SUCCESS)
+		return ret;
+
+
+
+	#ifdef LVDS_ONLY
+		return PD_SUCCESS;
+	#endif
+
+
+	if (!p_ctx->init_done) {
+
+		PD_DEBUG("ch7036: ch7036_set_attributes()- at bootup...\n");
+
+		PD_DEBUG("ch7036: ch7036_set_attributes()- p_ctx->hpd [%x}\n", p_ctx->hpd);
+
+		p_attr = pd_get_attr(p_list, num_attrs, PD_ATTR_ID_DISPLAY, 0);
+		if (p_attr && (p_attr->flags & PD_ATTR_FLAG_VALUE_CHANGED) ) {
+
+
+			pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DISPLAY,
+				PD_GET_ATTR_LIST)->current_value
+			= p_attr->current_value;
+
+		}
+
+
+
+		p_attr = pd_get_attr(p_list, num_attrs, PD_ATTR_ID_HDMI_OUT_MODE, 0);
+		p_curr = pd_get_attr(p_ctx->p_ch7036_attr_table, num_attrs, PD_ATTR_ID_HDMI_OUT_MODE, 0);
+
+		if (p_attr && (p_attr->flags & PD_ATTR_FLAG_VALUE_CHANGED) ) {
+
+			if(p_curr) {
+				pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_HDMI_OUT_MODE,
+					PD_GET_ATTR_LIST)->current_value
+				= p_attr->current_value;
+				p_curr->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+			}
+
+
+		}
+
+
+		p_attr = pd_get_attr(p_list, num_attrs, PD_ATTR_ID_DVI_OUT_MODE, 0);
+		p_curr = pd_get_attr(p_ctx->p_ch7036_attr_table, num_attrs, PD_ATTR_ID_DVI_OUT_MODE, 0);
+
+		if (p_attr && (p_attr->flags & PD_ATTR_FLAG_VALUE_CHANGED) ) {
+
+
+
+			if(p_curr) {
+				pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DVI_OUT_MODE,
+					PD_GET_ATTR_LIST)->current_value
+				= p_attr->current_value;
+				p_curr->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+			}
+
+
+		}
+
+
+		p_attr = pd_get_attr(p_list, num_attrs, PD_ATTR_ID_CRT_OUT_MODE, 0);
+		p_curr = pd_get_attr(p_ctx->p_ch7036_attr_table, num_attrs, PD_ATTR_ID_CRT_OUT_MODE, 0);
+
+		if (p_attr && (p_attr->flags & PD_ATTR_FLAG_VALUE_CHANGED) ) {
+
+			if(p_curr) {
+				pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_CRT_OUT_MODE,
+						PD_GET_ATTR_LIST)->current_value
+					= p_attr->current_value;
+
+				p_curr->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+			}
+
+
+		}
+
+
+
+	}
+
+
+	for (i = 0, p_attr = p_list; i < num_attrs; i++,p_attr++)
+	{
+
+
+		if (!(p_attr->flags & PD_ATTR_FLAG_VALUE_CHANGED)) {
+
+			continue;
+		}
+
+
+		p_attr->flags &= ~PD_ATTR_FLAG_VALUE_CHANGED;
+
+		if (p_attr->flags & PD_ATTR_FLAG_USER_INVISIBLE)
+			continue;
+
+
+
+		if (p_attr->name == NULL)
+		{
+			continue;
+		}
+		if ((p_attr->id != PD_ATTR_ID_DISPLAY)
+			&& (p_attr->id != PD_ATTR_ID_HDMI_OUT_MODE)
+			&& (p_attr->id != PD_ATTR_ID_DVI_OUT_MODE)
+			&& (p_attr->id != PD_ATTR_ID_CRT_OUT_MODE)
+			&& (p_attr->id != PD_ATTR_ID_HPOSITION)
+			&& (p_attr->id != PD_ATTR_ID_VPOSITION)
+
+			&& (p_attr->id != PD_ATTR_ID_HSCALE)
+			&& (p_attr->id !=  PD_ATTR_ID_VSCALE)
+			&& (p_attr->id !=  PD_ATTR_ID_HSCALE_CRT)
+			&& (p_attr->id !=  PD_ATTR_ID_VSCALE_CRT)
+			&& (p_attr->id !=  PD_ATTR_ID_DITHER_BYPASS)
+			&& (p_attr->id !=  PD_ATTR_ID_LOAD_FIRMWARE)
+			&& (p_attr->id !=  PD_ATTR_ID_REFRESH))
+		{
+			continue;
+		}
+
+		p_curr = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,p_attr->id,
+				PD_GET_ATTR_LIST);
+
+
+		p_curr->current_value = p_attr->current_value;
+		switch (p_attr->id) {
+			case PD_ATTR_ID_DISPLAY:
+
+				list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DISPLAY,
+							PD_GET_ATTR_LIST_ENTRY);
+
+				if(list_item->value & CHANNEL_DVI) {
+
+					pOutput_Info->hdmi_fmt.is_dvi_mode=1;
+					list_item->value = (list_item->value & 0xF7) | CHANNEL_HDMI;
+				}
+
+
+				ch7036_set_output_channel(p_ctx,(uint32)list_item->value);
+
+				if (pOutput_Info->channel == CHANNEL_LVDS)
+
+
+					ch7036_set_power((void *)p_ctx,PD_POWER_MODE_D0);
+				else
+					p_attr->flags |= PD_ATTR_FLAG_SETMODE;
+
+
+
+				break;
+
+			case PD_ATTR_ID_HDMI_OUT_MODE:
+				list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_HDMI_OUT_MODE,
+							PD_GET_ATTR_LIST_ENTRY);
+				p_ctx->hdmi_mode_index = list_item->value;
+				PD_DEBUG("ch7036_set_attributes(): updated hdmi_mode_index is: value [%ld]\n",p_ctx->hdmi_mode_index);
+				p_attr->flags |= PD_ATTR_FLAG_SETMODE;
+				break;
+
+			case PD_ATTR_ID_DVI_OUT_MODE:
+				list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DVI_OUT_MODE,
+							PD_GET_ATTR_LIST_ENTRY);
+				p_ctx->dvi_mode_index = list_item->value;
+				PD_DEBUG("ch7036_set_attributes(): updated dvi_mode_index is: value [%ld]\n",p_ctx->dvi_mode_index);
+				p_attr->flags |= PD_ATTR_FLAG_SETMODE;
+				break;
+
+			case PD_ATTR_ID_CRT_OUT_MODE:
+				list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_CRT_OUT_MODE,
+							PD_GET_ATTR_LIST_ENTRY);
+				p_ctx->crt_mode_index = list_item->value;
+				PD_DEBUG("ch7036_set_attributes(): updated crt_mode_index is: value [%ld]\n",p_ctx->crt_mode_index);
+				p_attr->flags |= PD_ATTR_FLAG_SETMODE;
+				break;
+
+			case PD_ATTR_ID_HPOSITION:
+			case PD_ATTR_ID_VPOSITION:
+				if(pOutput_Info->channel & CHANNEL_HDMI)
+					p_curr->current_value = DEFAULT_POSITION;
+				else {
+					if(p_curr->current_value > ((pd_range_attr_t *)p_curr)->max)
+						p_curr->current_value = ((pd_range_attr_t *)p_curr)->max;
+					else if (p_curr->current_value < ((pd_range_attr_t *)p_curr)->min)
+						p_curr->current_value = ((pd_range_attr_t *)p_curr)->min;
+				}
+
+				if (p_attr->id == PD_ATTR_ID_HPOSITION)
+					pOutput_Info->h_position = (uint16)(p_curr->current_value);
+				else
+					pOutput_Info->v_position = (uint16)(p_curr->current_value);
+				PD_DEBUG("ch7036_set_attributes(): updated position is: value [%d]\n",p_curr->current_value);
+				ch7036_set_position(p_ctx, (uint8)p_attr->id, (uint16)(p_curr->current_value));
+				break;
+			case PD_ATTR_ID_HSCALE:
+			case PD_ATTR_ID_VSCALE:
+			case PD_ATTR_ID_HSCALE_CRT:
+			case PD_ATTR_ID_VSCALE_CRT:
+
+				if(p_curr->current_value > ((pd_range_attr_t *)p_curr)->max)
+					p_curr->current_value = ((pd_range_attr_t *)p_curr)->max;
+				else if (p_curr->current_value < ((pd_range_attr_t *)p_curr)->min)
+					p_curr->current_value = ((pd_range_attr_t *)p_curr)->min;
+
+
+				if(p_attr->id== PD_ATTR_ID_HSCALE || p_attr->id== PD_ATTR_ID_HSCALE_CRT)
+					ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_HSCALE, (uint8)p_curr->current_value);
+				else
+					ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_VSCALE, (uint8)p_curr->current_value);
+				PD_DEBUG("ch7036_set_attributes(): updated scale value is: value [%ld]\n",p_curr->current_value);
+
+				p_attr->flags |= PD_ATTR_FLAG_SETMODE;
+
+				break;
+			case PD_ATTR_ID_DITHER_BYPASS:
+
+
+				PD_DEBUG("ch7036_set_attributes(): updated quality enhance value is: value [%ld]\n",p_curr->current_value);
+				ch7036_set_quality_enhancement(p_ctx,(uint8)p_curr->current_value);
+				break;
+
+			case PD_ATTR_ID_LOAD_FIRMWARE:
+				PD_DEBUG("ch7036_set_attributes(): updated [load-firmware] value is: value [%ld]\n",p_curr->current_value);
+#if 0
+				if(p_curr->current_value)
+					p_ctx->use_firmware =1;
+				else
+					p_ctx->use_firmware =0;
+#endif
+				break;
+
+			case PD_ATTR_ID_REFRESH:
+				PD_DEBUG("ch7036_set_attributes(): refresh value is: value [%ld]\n",p_curr->current_value);
+
+				ch7036_get_port_status((void *)p_ctx, &port_status);
+				p_attr->flags |= PD_ATTR_FLAG_SETMODE;
+				if(p_curr->current_value ) {
+					p_curr->current_value= 0;
+
+				}
+				break;
+
+			default:
+
+				PD_DEBUG("ch7036_set_attr(): unhandled attr name[%s]id[%ld]curr_index[%ld]\n",p_attr->name, p_attr->id,p_attr->current_value);
+				break;
+
+		}
+
+
+	}
+
+
+
+	PD_DEBUG("ch7036: ch7036_set_attributes()-exit\n");
+
+	return ret;
+}
+
+
+
+
+int ch7036_set_power(void *p_context, unsigned long state)
+{
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = (p_ctx->p_ch7xxx_context)->pOutput_Info;
+
+
+	pd_list_entry_attr_t  *list_entry;
+	int ret;
+
+
+	PD_DEBUG("ch7036: ch7036_set_power()-enter: requested state=%x\n", state);
+
+	if (!p_ctx)
+		return PD_ERR_NULL_PTR;
+
+	if (p_ch7xxx_context->DeviceID != 0x56)
+	{
+		return (PD_ERR_NULL_PTR);
+	}
+
+	if (state > PD_POWER_MODE_D3)
+		return PD_ERR_INVALID_POWER;
+
+	if (state != PD_POWER_MODE_D0) {
+
+
+		pOutput_Info->channel = CHANNEL_LVDS_HDMI_VGA_OFF;
+
+		#ifndef LVDS_ONLY
+		ch7036_device_set_power(p_ctx,CHANNEL_LVDS_HDMI_VGA_OFF);
+		#endif
+
+		ret = PD_INTERNAL_LVDS_MODULE_SET_POWER(ch7036_internal_lvds_set_power, (p_ctx->internal_lvds,state));
+
+
+	}
+	else {
+
+
+		list_entry = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs, PD_ATTR_ID_DISPLAY, PD_GET_ATTR_LIST_ENTRY);
+		ch7036_set_output_channel(p_ctx,(uint32)(list_entry->value));
+
+		PD_DEBUG("ch7036: ch7036_set_power()- p->ctx-hpd [0x%x]\n",p_ctx->hpd);
+		PD_DEBUG("ch7036: ch7036_set_power()- requested output channel- [%x]\n", pOutput_Info->channel);
+
+
+		PD_INTERNAL_LVDS_MODULE_SET_POWER(ch7036_internal_lvds_set_power, (p_ctx->internal_lvds,state));
+
+		#ifndef LVDS_ONLY
+		ch7036_device_set_power(p_ctx,pOutput_Info->channel);
+		#endif
+	}
+
+
+	p_ctx->pwr_state = state;
+
+	return PD_SUCCESS;
+}
+
+
+int ch7036_get_power(void *p_context, unsigned long *p_state)
+{
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
+
+
+	PD_DEBUG("ch7036: ch7036_get_power()\n");
+
+
+	*p_state = p_ctx->pwr_state;
+
+	return PD_SUCCESS;
+}
+
+int ch7036_save(void *p_context, void **state, unsigned long flags)
+{
+
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
+
+
+	PD_DEBUG("ch7036: ch7036_save()\n");
+
+
+	p_ctx->prev_outchannel = ch7036_get_output_channel(p_context);
+
+
+
+	*state = NULL;
+
+	return PD_SUCCESS;
+
+}
+
+int ch7036_restore(void *p_context, void *state, unsigned long flags)
+{
+
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
+	unsigned long i;
+
+
+	PD_DEBUG("ch7036: ch7036_restore()\n");
+
+
+	if (ch7036_load_firmware(p_ctx) != SS_SUCCESS)   {
+		PD_DEBUG("ch7036: ch7036_restore()-  load fw is NOT a SUCCESS\n");
+		return PD_ERR_UNSUCCESSFUL;
+
+	}
+	else {
+		PD_DEBUG("ch7036: ch7036_restore()-  load fw is a SUCCESS\n");
+	}
+
+
+	if(p_ctx->prev_outchannel == CHANNEL_LVDS_HDMI) {
+
+		ch7036_set_output_channel(p_context, p_ctx->prev_outchannel);
+		ch7036_set_mode(p_context, &(p_ctx->native_dtd), 0);
+		ch7036_post_set_mode(p_context, &(p_ctx->native_dtd), 0);
+	}
+
+
+
+	for(i=0;i<p_ctx->ch7036_num_attrs;i++) {
+
+		if( p_ctx->p_ch7036_attr_table[i].id == PD_ATTR_ID_REFRESH ) {
+
+
+			p_ctx->p_ch7036_attr_table[i].flags |= PD_ATTR_FLAG_VALUE_CHANGED;
+			p_ctx->p_ch7036_attr_table[i].current_value = 1;
+
+			ch7036_set_attributes(p_context, 1, &p_ctx->p_ch7036_attr_table[i]);
+			break;
+		}
+
+	}
+
+
+	return PD_SUCCESS;
+
+}
+
+
+int ch7036_get_port_status(void *context, pd_port_status_t *port_status)
+{
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)context;
+//	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+//	OUTPUT_INFO* pOutput_Info = (p_ctx->p_ch7xxx_context)->pOutput_Info;
+
+
+
+	port_status->display_type = PD_DISPLAY_LVDS_INT;
+	port_status->connected    = PD_DISP_STATUS_UNKNOWN;
+
+	PD_DEBUG("ch7036: ch7036_get_port_status()-enter..\n");
+
+
+	if(p_ctx->use_firmware) {
+
+		ch7036_get_attached_device(p_ctx);
+
+		if(p_ctx ->hpd & 0x22)
+			port_status->connected = PD_DISP_STATUS_ATTACHED;
+
+
+		ch7036_alter_display_list(p_ctx);
+
+	}
+
+
+	PD_DEBUG("ch7036: ch7036_get_port_status()-exit. p_ctx->hpd [%x}\n", p_ctx->hpd);
+
+
+	return PD_SUCCESS;
+
+}
+
+
+int ch7036_initialize_device(ch7036_device_context_t *p_ctx)
+{
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = (p_ctx->p_ch7xxx_context)->pOutput_Info;
+	PREFER_INFO* pPrefer_Info = p_ch7xxx_context->pPrefer_Info;
+	//pd_attr_t *p_attr;
+	uint8 reg;
+
+	ch7036_edid_blk_t* p_hedid;
+	ch7036_edid_blk_t* p_cedid ;
+
+
+	PD_DEBUG("ch7036: ch7036_initialize_device()- ENTER...\n");
+
+
+	if (p_ch7xxx_context->DeviceID != 0x56)
+	{
+		return (PD_ERR_NULL_PTR);
+	}
+	p_ctx->init_done = 0;
+
+
+	if(p_ctx->hedid) {
+		p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
+		p_cedid = (ch7036_edid_blk_t *)p_ctx->cedid;
+
+		p_cedid->is_edid = 0;
+		p_hedid->is_edid = 0;
+		p_cedid->ebn = 0;
+		p_hedid->ebn = 0;
+
+	}
+
+
+
+	pOutput_Info->hdmi_fmt.is_dvi_mode = 0;
+
+	pOutput_Info->channel = CHANNEL_LVDS | CHANNEL_HDMI;
+	p_ctx->req_ddc = 0;
+	p_ctx->lvds_only = 0;
+
+	PD_DEBUG("ch7036: ch7036_initialize_device()- set output channel to [%ld]\n",pOutput_Info->channel);
+
+
+
+	pOutput_Info->h_position = DEFAULT_POSITION;
+	pOutput_Info->v_position = DEFAULT_POSITION;
+
+
+	p_ctx->dither_select = DITHER_18_TO_18;
+
+	ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_HSCALE, HDMI_DEFAULT_UNDERSCAN);
+	ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_VSCALE, HDMI_DEFAULT_UNDERSCAN);
+
+	ch7036_set_prefer_timing_info(p_ctx,pPrefer_Info);
+
+
+	if(p_ctx->use_firmware) {
+
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x04);
+		reg = I2CRead(p_ch7xxx_context,0x52);
+		reg = reg & 0xEF;
+		I2CWrite(p_ch7xxx_context,0x52, reg);
+
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x01);
+		reg = I2CRead(p_ch7xxx_context,0x0F);
+		reg = reg & 0x7F;
+		I2CWrite(p_ch7xxx_context,0x0F, reg);
+
+
+		ch7036_get_attached_device(p_ctx);
+
+	}
+
+
+	return PD_SUCCESS;
+}
+
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.h
new file mode 100644
index 0000000..78e33d3
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.h
@@ -0,0 +1,59 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_port.h
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+
+#ifndef _CH7036_PORT_H_
+#define _CH7036_PORT_H_
+
+
+
+#include "ch7036_intf.h"
+#include "ch7036_attr.h"
+
+int ch7036_open(pd_callback_t *p_callback, void **p_context);
+int ch7036_init_device(void *p_context);
+int ch7036_get_timing_list(void *p_context, pd_timing_t *p_in_list,
+	pd_timing_t **pp_out_list);
+int ch7036_set_mode(void *p_context, pd_timing_t *p_mode, unsigned long flags);
+int ch7036_post_set_mode(void *p_context, pd_timing_t *p_mode,
+	unsigned long flags);
+
+int ch7036_get_attributes(void *p_context, unsigned long *p_num_attr,
+	pd_attr_t **pp_list);
+int ch7036_set_attributes(void *p_context, unsigned long num_attr,
+	pd_attr_t *p_list);
+unsigned long ch7036_validate(unsigned long cookie);
+int ch7036_close(void *p_context);
+
+int ch7036_set_power(void *p_context, unsigned long state);
+int ch7036_get_power(void *p_context, unsigned long *p_state);
+int ch7036_save(void *p_context, void **pp_state, unsigned long flags);
+int ch7036_restore(void *p_context, void *p_state, unsigned long flags);
+int ch7036_get_port_status(void *context, pd_port_status_t *port_status);
+
+
+#endif
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_reg_table.c b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_reg_table.c
new file mode 100644
index 0000000..80993a5
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_reg_table.c
@@ -0,0 +1,220 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_reg_table.c
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+
+#include "ch7036_reg_table.h"
+
+
+
+MULTI_REG g_MultiRegTable[MUL_ID_END] =
+{
+	{BASE_FLAG,       -1,  0, 0,	-1,  0, 0,	-1,  3, 6,	-1,   0, 7,		0},
+
+	{HTI,		      -1,  0, 0,	-1,  0, 0,	0x0B,3, 6,	0x0D, 0, 7,		0},
+	{VTI,		      -1,  0, 0,	-1,  0, 0,	0x11,3, 5,	0x13, 0, 7,		0},
+	{HAI,		      -1,  0, 0,	-1,  0, 0,	0x0B,0, 2,	0x0C, 0, 7,		0},
+	{VAI,		      -1,  0, 0,	-1,  0, 0,	0x11,0, 2,	0x12, 0, 7,		0},
+	{HOI,		      -1,  0, 0,	-1,  0, 0,	0x0E,0, 2,	0x0F, 0, 7,		0},
+	{VOI,		      -1,  0, 0,	-1,  0, 0,	0x14,0, 2,	0x15, 0, 7,		0},
+	{HWI,		      -1,  0, 0,	-1,  0, 0,	0x0E,3, 5,	0x10, 0, 7,		0},
+	{VWI,		      -1,  0, 0,	-1,  0, 0,	0x14,3, 5,	0x16, 0, 7,		0},
+	{RCLK,            -1,  0, 0,	0x0F,0, 1,  0x14,0, 7,  0x15, 0, 7,     4},
+	{DITHER_SEL1_SPP, -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x57, 7, 7,		4},
+	{DITHER_SEL0_SPP, -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x57, 6, 6,		4},
+	{HSYNCP_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x41, 6, 6,		1},
+	{VSYNCP_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x41, 5, 5,		1},
+	{NP_INV0_SPP,     -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x58, 4, 4,		4},
+	{NP_INV1_SPP,     -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x58, 3, 3,		4},
+	{NP_INV2_SPP,     -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x58, 2, 2,		4},
+	{NP_INV3_SPP,     -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x58, 1, 1,		4},
+	{LVDS_IN_ORDER,	  -1,  0, 0,	-1,	 0, 0,  -1,  0, 0,  0x5F, 0, 0,		4},
+
+	{LVDS0_SEQ_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x5E, 5, 7,		4},
+	{LVDS1_SEQ_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x5E, 2, 4,		4},
+	{LVDS2_SEQ_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,	 0, 0,  0x5F, 7, 7,		4},
+	{LVDS3_SEQ_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x5F, 4, 6,		4},
+	{LVDSCLK_SEQ_SPP, -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x5F, 1, 3,		4},
+	{HSYNC_CNT_TH_SPP,-1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x59, 5, 6,		4},
+	{PRBS_SET_SEL_SPP,-1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x61, 1, 1,		4},
+	{LVDS0_POL_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x59, 4, 4,		4},
+    {LVDS1_POL_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x59, 3, 3,		4},
+	{LVDS2_POL_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x59, 2, 2,		4},
+	{LVDS3_POL_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x59, 1, 1,		4},
+	{LVDSCLK_POL_SPP, -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x59, 0, 0,		4},
+
+	{HTO,			  -1,  0, 0,	-1,  0, 0,	0x1F,3, 6,	0x21, 0, 7,		0},
+	{VTO,			  -1,  0, 0,	-1,  0, 0,	0x25,3, 5,	0x27, 0, 7,		0},
+	{HAO,			  -1,  0, 0,	-1,  0, 0,	0x1F,0, 2,	0x20, 0, 7,		0},
+	{VAO,			  -1,  0, 0,	-1,  0, 0,	0x25,0, 2,	0x26, 0, 7,		0},
+	{HOO_HDMI,	      -1,  0, 0,	-1,  0, 0,	0x54,0, 2,	0x55, 0, 7,		0},
+	{VOO_HDMI,	      -1,  0, 0,	-1,  0, 0,	0x57,0, 2,	0x58, 0, 7,		0},
+	{HWO_HDMI,	      -1,  0, 0,	-1,  0, 0,	0x54,3, 5,	0x56, 0, 7,		0},
+	{VWO_HDMI,	      -1,  0, 0,	-1,  0, 0,	0x57,3, 5,	0x59, 0, 7,		0},
+	{HPO_I,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x19, 5, 5,		0},
+	{VPO_I,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x19, 4, 4,		0},
+	{DEPO_I,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x19, 3, 3,		0},
+	{HPO_O,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2E, 4, 4,		0},
+	{VPO_O,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2E, 3, 3,		0},
+	{DEPO_O,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2E, 5, 5,		0},
+
+	{HD_DVIB,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0A, 2, 2,		0},
+	{INTLC,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x1E, 5, 5,		0},
+	{HD_LV_POL,       -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x4C, 5, 5,		0},
+	{HD_LV_SEQ,       -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x4C, 0, 4,		0},
+	{HDMI_LVDS_SEL,   -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x7E, 7, 7,		0},
+	{VSP,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x24, 5, 5,		1},
+	{HSP,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x24, 4, 4,		1},
+	{HDMIIN_HSP,	  -1,  0, 0,    -1,  0, 0,	-1,  0, 0,	0x61, 6, 6,		4},
+	{HDMIIN_VSP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x61, 5, 5,		4},
+	{HDMIIN_DEP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x61, 4, 4,		4},
+	{M1M0,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x3D, 2, 3,		0},
+	{C1C0,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x3D, 0, 1,		0},
+	{VIC,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x40, 0, 5,		0},
+	{COPY,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x4B, 6, 6,		0},
+	{SCAN_EN,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x6C, 0, 0,		4},
+	{HAO_SCL,		  -1,  0, 0,	-1,  0, 0,	0x6A,0, 7,	0x6B, 5, 7,		4},
+	{VAO_SCL,		  -1,  0, 0,	-1,  0, 0,	0x6B,0, 4,	0x6C, 2, 7,		4},
+
+	{I2SPOL,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x1E, 7, 7,		0},
+	{I2S_SPDIFB,      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x1E, 6, 6,		0},
+	{I2S_LENGTH,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x1E, 2, 3,		0},
+	{I2SFMT,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x1E, 0, 1,		0},
+	{UCLK,            -1,  0, 0,	0x0F,4, 5,  0x10,0, 7,  0x11, 0, 7 ,    4},
+
+	{PCLK_NUM,		  -1,  0, 0,	-1,  0, 0,	0x28,  0, 7,0x29, 0, 7,		1},
+
+	{UCLKSEC,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x12, 4, 4,		1},
+	{PLL1N1,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x55, 3, 5,		4},
+	{PLL1N2,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x55, 0, 2,		4},
+	{PLL1N3,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x56, 5, 7,		4},
+	{PLL3N8,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x13, 1, 2,		1},
+	{A2,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x5E, 0, 7,		0},
+	{MCLK,            -1,  0, 0,	0x0F,2, 3,  0x12,0, 7,  0x13, 0, 7,     4},
+	{PLL2N5,		  -1,  0, 0,	-1,  0, 0,  0x12,0, 1,	0x13, 7, 7,		1},
+	{PLL2N54,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x6E, 2, 2,		4},
+	{PLL2N53,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x6E, 1, 1,		4},
+	{PLL2N6,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x69, 5, 6,		4},
+	{PLL2N7,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x69, 3, 4,		4},
+	{DIVXTAL,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x6E, 3, 7,		4},
+	{A1,			  0x5A,0, 7,	0x5B,0, 7,	0x5C,0, 7,	0x5D, 0, 7,		0},
+	{A3,		      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x60, 0, 7,		4},
+	{TXPLL_FFD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x67, 7, 7,		4},
+	{DRI_PLL_N1,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0C, 3, 4,		1},
+	{DRI_PLL_N3,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0C, 1, 2,		1},
+	{UCLKOD_SEL,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x61, 7, 7,		4},
+
+	{GCKSEL,          -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x54, 6, 6,		4},
+	{TSTEN1,          -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x14, 6, 6,		1},
+
+	{LNSEL,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x68, 1, 2,		0},
+	{DAT16_32B,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x74, 7, 7,		0},
+	{TRUE24,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x74, 3, 3,		0},
+	{TRUE_COM,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x74, 4, 4,		0},
+	{WRLEN,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2D, 6, 7,		0},
+	{ROTATE,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2D, 4, 5,		0},
+	{HFLIP,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2E, 7, 7,		0},
+	{VFLIP,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2E, 6, 6,		0},
+	{DNSMPEN,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x25, 6, 6,		0},
+	{HADWSPP,	      -1,  0, 0,	-1,  0, 0,	0x60,0, 7,	0x61, 0, 2,		0},
+	{FLTBP2,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x32, 7, 7,		0},
+	{FLTBP1,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x32, 6, 6,		0},
+	{BLK_H,		      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x64, 0, 6,		0},
+	{FBA_INC,		  -1,  0, 0,	-1,  0, 0,	0x6B,0, 7,	0x6C, 0, 3,		0},
+	{SFM,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x6A, 0, 0,		0},
+	{THREN,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x6A, 2, 2,		0},
+	{THRRL,			  -1,  0, 0,	-1,  0, 0,	0x6D,0, 7,	0x6E, 0, 2,		0},
+	{WRFAST,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x6E, 3, 3,		0},
+	{CHG_HL,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2F, 7, 7,		0},
+	{HINCA,			  -1,  0, 0,	-1,  0, 0,	0x2A,0, 7,	0x2B, 0, 2,		4},
+	{HINCB,			  -1,  0, 0,	-1,  0, 0,	0x2C,0, 7,	0x2D, 0, 2,		4},
+	{VINCA,			  -1,  0, 0,	-1,  0, 0,	0x2E,0, 7,	0x2F, 0, 2,		4},
+	{VINCB,			  -1,  0, 0,	-1,  0, 0,	0x30,0, 7,	0x31, 0, 2,		4},
+	{HDINCA,		  -1,  0, 0,	-1,  0, 0,	0x32,0, 7,	0x33, 0, 2,		4},
+	{HDINCB,		  -1,  0, 0,	-1,  0, 0,	0x34,0, 7,	0x35, 0, 2,		4},
+	{HINC,			  -1,  0, 0,	0x36,0, 4,	0x37,0, 7,	0x38, 0, 7,		4},
+	{VINC,			  -1,  0, 0,	0x39,0, 7,	0x3A,0, 7,  0x3B, 0, 7,		4},
+	{HDINC,		      -1,  0, 0,	0x3C,0, 7,	0x3D,0, 7,	0x3E, 0, 7,		4},
+	{VSMST,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x70, 6, 7,		0},
+	{MEMINIT,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0A, 7, 7,		0},
+	{STOP,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0A, 4, 4,		0},
+
+	{HDMI_PD,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x09, 0, 0,		0},
+	{I2S_PD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 6, 6,		0},
+	{SPDIF_PD,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 0, 0,		0},
+	{DRI_PD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 3, 3,		0},
+	{DRI_PD_SER,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x16, 0, 0,		1},
+	{DRI_PD_PLL,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x16, 3, 3,		1},
+	{DRI_PDDRI,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x08, 4, 7,		0},
+	{CEC_PD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 4, 4,		0},
+	{PD_DDC,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0E, 7, 7,		1},
+
+	{LVDS_PD,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0A, 3, 3,		0},
+	{RX_PD,		      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x63, 4, 7,		4},
+	{RXPLL_PD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x64, 0, 0,		4},
+    {TXPLL_PD,		  -1,  0, 0,    -1,  0, 0,	-1,  0, 0,	0x66, 1, 1,		4},
+	{TXDRV_PD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x11, 4, 4,		1},
+	{TXSER_PD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x1A, 4, 4,		1},
+
+	{VGA_PD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x09, 2, 2,		0},
+	{PDDAC,		      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x08, 1, 3,		0},
+	{DACSENCE,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x57, 1, 1,		4},
+	{GCKOFF,          -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x09, 6, 6,		0},
+	{TV_BP,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x09, 5, 5,		0},
+	{PDPLL1,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 1, 1,		0},
+	{PDPLL0,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x54, 4, 4,		4},
+
+	{ICEN0,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x11, 7, 7,		1},
+
+	{PD_PROM,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0F, 7, 7,		1},
+	{PDMIO,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 2, 2,		0},
+	{PDIO,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 5, 5,		0},
+	{HPD_PD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 7, 7,		0},
+	{SCLPD,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x09, 4, 4,		0},
+	{SDPD,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x09, 3, 3,		0},
+	{MEMPD,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0A, 5, 5,		0},
+	{AUDDAC,          -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x5C, 2, 2,		4},
+
+	{CRYS_FREQ_SPP,	  -1,  0, 0,	-1,  0, 0,0x1C,	 0,	7,  0x1D, 0, 7,		0},
+	{I2SCK_SEC, 	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 2, 2,		1},
+	{SP_EN,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x21, 7, 7,		1},
+	{HARD_SOFTB,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x58, 5, 5,		4},
+	{MULT_I2CEN,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x4E, 0, 0,		1},
+	{RXPLL_REFDLY,    -1,  0, 0,    -1,  0, 0,  -1,  0, 0,  0x66, 5, 7,     4},
+	{RXPLL_FBDLY,     -1,  0, 0,    -1,  0, 0,  -1,  0, 0,  0x66, 2, 4,     4},
+	{VFMT,            -1,  0, 0,    -1,  0, 0,  -1,  0, 0,  0x2B, 0, 3,     0},
+
+	{DBP,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x19, 6, 6,		0},
+	{CK_TVINV,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 1, 1,		1},
+	{DISPON,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x08, 0, 0,		1},
+
+	{VP,			  -1,  0, 0,	-1,  0, 0,	0x39,4, 7,	0x3B, 0, 7,		0},
+	{HP,			  -1,  0, 0,	-1,  0, 0,	0x39,0, 3,	0x3A, 0, 7,		0},
+
+	{TXTEN,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2E, 0, 2,		0},
+	{ZRCTS,           -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x24, 1, 1,		1},
+
+};
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_reg_table.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_reg_table.h
new file mode 100644
index 0000000..d2e45bf
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_reg_table.h
@@ -0,0 +1,118 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_reg_table.h
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+#ifndef _CH7036_REG_TABLE_H
+#define _CH7036_REG_TABLE_H
+
+#include "ch7036_typedef.h"
+
+typedef enum{
+	BASE_FLAG = 0,
+
+
+	HTI,	VTI,	HAI,	VAI,	HOI,	VOI,	HWI,	VWI,	RCLK,
+	DITHER_SEL1_SPP,		DITHER_SEL0_SPP,		HSYNCP_SPP,		VSYNCP_SPP,
+	NP_INV0_SPP,	NP_INV1_SPP,	NP_INV2_SPP,	NP_INV3_SPP,	LVDS_IN_ORDER,
+
+
+	LVDS0_SEQ_SPP,	LVDS1_SEQ_SPP,	LVDS2_SEQ_SPP,	LVDS3_SEQ_SPP,	LVDSCLK_SEQ_SPP,
+	HSYNC_CNT_TH_SPP,				PRBS_SET_SEL_SPP,
+	LVDS0_POL_SPP,	LVDS1_POL_SPP,	LVDS2_POL_SPP,	LVDS3_POL_SPP,	LVDSCLK_POL_SPP,
+
+
+	HTO,	VTO,	HAO,	VAO,	HOO_HDMI,		VOO_HDMI,		HWO_HDMI,	VWO_HDMI,
+	HPO_I,	VPO_I,	DEPO_I,	HPO_O,	VPO_O,			DEPO_O,
+
+
+	HD_DVIB,		INTLC,			HD_LV_POL,		HD_LV_SEQ,		HDMI_LVDS_SEL,
+	VSP,			HSP,			HDMIIN_HSP,		HDMIIN_VSP,		HDMIIN_DEP,
+	M1M0,			C1C0,			VIC,
+	COPY,			SCAN_EN,		HAO_SCL,		VAO_SCL,
+
+
+	I2SPOL,			I2S_SPDIFB,		I2S_LENGTH,		I2SFMT,
+	UCLK,			PCLK_NUM,
+
+
+	UCLKSEC,		PLL1N1,			PLL1N2,			PLL1N3,			PLL3N8,		A2,			MCLK,
+	PLL2N5,			PLL2N54,		PLL2N53,		PLL2N6,			PLL2N7,		DIVXTAL,
+	A1,				A3,				TXPLL_FFD,		DRI_PLL_N1,		DRI_PLL_N3, UCLKOD_SEL,
+	GCKSEL,         TSTEN1,
+
+
+	LNSEL,			DAT16_32B,		TRUE24,			TRUE_COM,		WRLEN,
+	ROTATE,			HFLIP,			VFLIP,
+	DNSMPEN,		HADWSPP,		FLTBP2,			FLTBP1,			BLK_H,
+	FBA_INC,		SFM,			THREN,			THRRL,			WRFAST,		CHG_HL,
+	HINCA,			HINCB,			VINCA,			VINCB,			HDINCA,		HDINCB,
+	HINC,			VINC,			HDINC,
+	VSMST,			MEMINIT,		STOP,
+
+
+	HDMI_PD,		I2S_PD,			SPDIF_PD,		DRI_PD,			DRI_PD_SER,
+	DRI_PD_PLL,		DRI_PDDRI,		CEC_PD,			PD_DDC,
+	LVDS_PD,		RX_PD,			RXPLL_PD,		TXPLL_PD,		TXDRV_PD,	TXSER_PD,
+	VGA_PD,			PDDAC,			DACSENCE,       GCKOFF,
+	TV_BP,			PDPLL1,			PDPLL0,			ICEN0,			PD_PROM,		PDMIO,		PDIO,		HPD_PD,
+	SCLPD,			SDPD,			MEMPD,			AUDDAC,
+
+
+	CRYS_FREQ_SPP,	I2SCK_SEC,		SP_EN,			HARD_SOFTB,		MULT_I2CEN,	RXPLL_REFDLY,
+	RXPLL_FBDLY, VFMT,
+
+
+	DBP,			CK_TVINV,		DISPON,
+
+	VP,	HP,
+
+	TXTEN,
+	ZRCTS,
+
+	MUL_ID_END,
+
+}MULTI_REG_ID;
+
+typedef struct{
+	MULTI_REG_ID RegId;
+	uint8 TopRegIndex;
+	uint8 TopStartBit;
+	uint8 TopEndBit;
+	uint8 HighRegIndex;
+	uint8 HighStartBit;
+	uint8 HighEndBit;
+	uint8 MiddleRegIndex;
+	uint8 MiddleStartBit;
+	uint8 MiddleEndBit;
+	uint8 LowRegIndex;
+	uint8 LowStartBit;
+	uint8 LowEndBit;
+	uint8 PageIndex;
+}MULTI_REG, *PMULTI_REG;
+
+extern MULTI_REG g_MultiRegTable[];
+
+#endif
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_typedef.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_typedef.h
new file mode 100644
index 0000000..5bb9b40
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_typedef.h
@@ -0,0 +1,464 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_typedef.h
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+
+#ifndef _CH7036_TYPEDEF_H
+#define _CH7036_TYPEDEF_H
+
+
+
+typedef unsigned char			uint8;
+typedef unsigned short			uint16;
+typedef unsigned int			uint32;
+
+
+typedef unsigned long long int 		uint64;
+
+typedef signed char				int8;
+typedef signed short			int16;
+typedef signed int				int32;
+typedef signed long long int			int64;
+
+typedef uint32					ch_bool;
+#define ch_true					1
+#define ch_false				0
+
+
+
+typedef struct{
+	uint16 ht;
+	uint16 ha;
+	uint16 ho;
+	uint16 hw;
+	uint16 vt;
+	uint16 va;
+	uint16 vo;
+	uint16 vw;
+	uint16 hz;
+	uint16 stype;
+
+}TIMING, *PTIMING;
+
+
+#define PIXEL_FMT_18BIT		0
+#define PIXEL_FMT_24BIT		1
+
+#define POL_HIGH			1
+#define POL_LOW				0
+#define POL_INVERT			1
+#define POL_NO_INV			0
+
+#define AUDIO_I2S			1
+#define AUDIO_SPDIF			0
+
+#define SCANTYPE_INTERLACED		0
+#define SCANTYPE_PROGRESSIVE	1
+#define TIMING_LIST_END			2
+
+typedef struct{
+
+	TIMING timing;
+	uint32 rx_clk_khz;
+	uint8  pixel_fmt;
+	uint8  hs_pol;
+	uint8  vs_pol;
+	uint8  de_pol;
+	uint8  data_ch_pol;
+	uint8  data_ch_invert;
+
+	uint8  audio_type;
+	uint8  i2s_pol;
+	uint8  i2s_len;
+	uint8  i2s_fmt;
+}INPUT_INFO, *PINPUT_INFO;
+
+
+
+
+#define LVDS_DATA0_SEL			0
+#define LVDS_DATA1_SEL			1
+#define LVDS_DATA2_SEL			2
+#define LVDS_DATA3_SEL			3
+#define LVDS_CLOCK_SEL			4
+
+
+#define LVDS_CHANNEL_SWAP_DEF		(LVDS_DATA0_SEL << 0) | (LVDS_DATA1_SEL << 4) | (LVDS_DATA2_SEL << 8) | (LVDS_DATA3_SEL << 12) | (LVDS_CLOCK_SEL << 16)
+#define LVDS_CHANNEL_SWAP_OP1		(LVDS_DATA1_SEL << 0) | (LVDS_DATA2_SEL << 4) | (LVDS_DATA3_SEL << 8) | (LVDS_CLOCK_SEL << 12) | (LVDS_DATA0_SEL << 16)
+#define LVDS_CHANNEL_SWAP_OP2		(LVDS_DATA2_SEL << 0) | (LVDS_DATA3_SEL << 4) | (LVDS_CLOCK_SEL << 8) | (LVDS_DATA0_SEL << 12) | (LVDS_DATA1_SEL << 16)
+#define LVDS_CHANNEL_SWAP_OP3		(LVDS_DATA3_SEL << 0) | (LVDS_CLOCK_SEL << 4) | (LVDS_DATA0_SEL << 8) | (LVDS_DATA1_SEL << 12) | (LVDS_DATA2_SEL << 16)
+#define LVDS_CHANNEL_SWAP_OP4		(LVDS_CLOCK_SEL << 0) | (LVDS_DATA0_SEL << 4) | (LVDS_DATA1_SEL << 8) | (LVDS_DATA2_SEL << 12) | (LVDS_DATA3_SEL << 16)
+#define LVDS_CHANNAL_SWAP_OP5		(LVDS_DATA3_SEL << 0) | (LVDS_CLOCK_SEL << 4) | (LVDS_DATA2_SEL << 8) | (LVDS_DATA1_SEL << 12) | (LVDS_DATA0_SEL << 16)
+
+typedef struct{
+	uint32 channel_swap;
+	uint32 channel_pol;
+	uint32 pixel_fmt;
+}LVDS_FMT, *PLVDS_FMT;
+
+#define AS_RATIO_4_3		1
+#define AS_RATIO_16_9		2
+
+typedef struct{
+	uint8 is_dvi_mode;
+	uint8 format_index;
+	uint8 aspect_ratio;
+	uint8 channel_swap;
+	uint8 data_pol_invert;
+	uint8 hs_pol;
+	uint8 vs_pol;
+	uint8 protect_enable;
+}HDMI_FMT, *PHDMI_FMT;
+
+typedef struct{
+	uint8 channel_swap;
+	uint8 hs_pol;
+	uint8 vs_pol;
+	uint8 de_pol;
+}VGA_FMT, *PVGA_FMT;
+
+
+#define CHANNEL_LVDS		(1 << 0)
+#define CHANNEL_HDMI		(1 << 1)
+#define CHANNEL_VGA			(1 << 2)
+#define CHANNEL_DVI			(1 << 3)
+#define CHANNEL_LVDS_HDMI 	(CHANNEL_LVDS | CHANNEL_HDMI)
+#define CHANNEL_LVDS_VGA 	(CHANNEL_LVDS | CHANNEL_VGA)
+#define CHANNEL_LVDS_DVI 	(CHANNEL_LVDS | CHANNEL_DVI)
+
+
+#define CHANNEL_LVDS_HDMI_VGA_OFF	0x0000
+
+
+
+#define ROTATE_0			0
+#define ROTATE_NO			0
+#define ROTATE_90			1
+#define ROTATE_180			2
+#define ROTATE_270			3
+
+typedef struct{
+	uint32 channel;
+	LVDS_FMT lvds_fmt;
+	HDMI_FMT hdmi_fmt;
+	VGA_FMT vga_fmt;
+	TIMING timing;
+	uint32 uclk_khz;
+	uint8  ds_percent_h;
+	uint8  ds_percent_v;
+	uint8  rotate;
+	uint8  h_flip;
+	uint8  v_flip;
+	uint16  h_position;
+	uint16  v_position;
+}OUTPUT_INFO, *POUTPUT_INFO;
+
+
+#define HS_TOLERANCE_LEVEL0			0
+#define HS_TOLERANCE_LEVEL1			1
+#define HS_TOLERANCE_LEVEL2			3
+#define HS_TOLERANCE_LEVEL3			7
+
+#define RST_BIT_HSYNC				0
+#define RST_BIT_VSYNC				1
+
+#define MEM_CLK_FREQ_MAX			166000
+#define FBA_INC_MAX					3000
+
+#define THRRL_ADJUST_DEF			200
+
+#define THRRL_ADJUST_OP1			250
+#define THRRL_ADJUST_OP2			300
+
+typedef struct{
+	uint32 mclk_khz;
+
+	uint8 uclkod_sel;
+	uint8 dat16_32b;
+	uint8 true24;
+	uint8 true_com;
+
+	uint8 lvds_out_hs_tolerance;
+	uint8 lvds_out_reset_bit_sel;
+
+	uint8 dither_filter_enable;
+	uint8 hscale_ratio_gate;
+
+	uint8 scale_line_adjust;
+	uint8  text_enhancement;
+
+	uint8 pll_ref_dly;
+	uint8 pll_ref_fbdly;
+	uint8 lvds_txdrv_ctrl;
+
+	uint8 eye_bgtrim ;
+	uint8 eye_dacg;
+	uint8 eye_dri_demp;
+	uint8 eye_dri_pll_cp;
+	uint8 eye_dri_damp;
+	uint8 eye_dri_pll_rlf;
+	uint8 eye_rdac;
+
+	uint8 reset;
+	uint8 vga_enable;
+
+}PREFER_INFO, *PPREFER_INFO;
+
+
+
+typedef struct{
+	uint32 DeviceID;
+	INPUT_INFO* pInput_Info;
+	OUTPUT_INFO* pOutput_Info;
+	PREFER_INFO* pPrefer_Info;
+	void*	pd_context;
+}DEV_CONTEXT, *PDEV_CONTEXT;
+
+typedef struct{
+	uint32 fmt_index;
+	uint32 clk_freq;
+	uint32 aspect;
+	TIMING timing;
+}OUT_FMT, *POUT_FMT;
+
+typedef enum hdmi{
+
+	OUT_HDMI_640x480P_59 = 0,
+	OUT_HDMI_640x480P_60,
+
+	OUT_HDMI_720x480P_59,
+	OUT_HDMI_720x480P_60,
+
+	OUT_HDMI_1280x720P_59,
+	OUT_HDMI_1280x720P_60,
+
+	OUT_HDMI_1920x1080I_59,
+	OUT_HDMI_1920x1080I_60,
+
+
+
+
+
+
+
+	OUT_HDMI_1920x1080P_59,
+	OUT_HDMI_1920x1080P_60,
+
+	OUT_HDMI_720x576P_50,
+	OUT_HDMI_1280x720P_50,
+	OUT_HDMI_1920x1080I_50,
+
+	OUT_HDMI_1920x1080P_50,
+
+	OUT_HDMI_1920x1080P_23,
+	OUT_HDMI_1920x1080P_24,
+	OUT_HDMI_1920x1080P_25,
+	OUT_HDMI_1920x1080P_29,
+	OUT_HDMI_1920x1080P_30,
+
+	OUT_HDMI_1920x1080I_100,
+	OUT_HDMI_1280x720P_100,
+	OUT_HDMI_720x576P_100,
+
+	OUT_HDMI_1920x1080I_119,
+	OUT_HDMI_1920x1080I_120,
+
+	OUT_HDMI_1280x720P_119,
+	OUT_HDMI_1280x720P_120,
+
+	OUT_HDMI_720x480P_119,
+	OUT_HDMI_720x480P_120,
+
+	OUT_HDMI_720x576P_200,
+    OUT_HDMI_1280x720P_239,
+	OUT_HDMI_1280x720P_240,
+	OUT_HDMI_END,
+}HDMI_OUT_MODE;
+
+typedef enum dvi {
+
+	OUT_DVI_640x480_60 = 0,
+
+	OUT_DVI_640x480_72,
+	OUT_DVI_640x480_75,
+	OUT_DVI_720x400_70,
+
+	OUT_DVI_800x600_56,
+    OUT_DVI_800x600_60,
+	OUT_DVI_800x600_72,
+	OUT_DVI_800x600_75,
+
+	OUT_DVI_1024x768_60,
+	OUT_DVI_1024x768_70,
+	OUT_DVI_1024x768_75,
+
+    OUT_DVI_1152x864_60,
+    OUT_DVI_1280x720_60,
+	OUT_DVI_1280x800_60,
+	OUT_DVI_1280x960_60,
+	OUT_DVI_1280x1024_60,
+	OUT_DVI_1280x1024_75,
+	OUT_DVI_1360x768_60,
+	OUT_DVI_1366x768_60,
+
+	OUT_DVI_1400x1050_60,
+	OUT_DVI_1400x1050_75,
+
+
+	OUT_DVI_1440x900_60,
+	OUT_DVI_1440x1050_60,
+	OUT_DVI_1600x900_60,
+	OUT_DVI_1600x1200_60,
+	OUT_DVI_1680x1050_60,
+
+	OUT_DVI_1920x1080_60,
+
+	OUT_DVI_1920x1200_60,
+	OUT_DVI_END,
+} DVI_OUT_MODE;
+
+typedef enum crt{
+
+	OUT_CRT_640x400_85 = 0,
+
+	OUT_CRT_640x480_60,
+
+	OUT_CRT_640x480_72,
+	OUT_CRT_640x480_75,
+	OUT_CRT_640x480_85,
+
+	OUT_CRT_720x400_85,
+
+	OUT_CRT_800x600_56,
+
+
+	OUT_CRT_800x600_60,
+	OUT_CRT_800x600_72,
+	OUT_CRT_800x600_75,
+	OUT_CRT_800x600_85,
+
+	OUT_CRT_1024x768_60,
+	OUT_CRT_1024x768_70,
+	OUT_CRT_1024x768_75,
+	OUT_CRT_1024x768_85,
+
+
+
+	OUT_CRT_1152x864_75,
+
+	OUT_CRT_1280x768_60,
+	OUT_CRT_1280x768_75,
+	OUT_CRT_1280x768_85,
+
+	OUT_CRT_1280x960_60,
+	OUT_CRT_1280x960_85,
+
+	OUT_CRT_1280x1024_60,
+	OUT_CRT_1280x1024_75,
+	OUT_CRT_1280x1024_85,
+
+	OUT_CRT_1360x768_60,
+
+	OUT_CRT_1400x1050_60,
+	OUT_CRT_1400x1050_75,
+
+
+
+	OUT_CRT_1440x900_60,
+	OUT_CRT_1440x1050_60,
+
+	OUT_CRT_1600x900_60,
+	OUT_CRT_1600x1200_60,
+
+	OUT_CRT_1920x1080_60,
+
+
+
+	OUT_CRT_END,
+}CRT_OUT_MODE;
+
+
+
+
+#define ERR_NO_ERROR						0
+
+#define ERR_DEVICE_PREPARE					100
+#define ERR_RESOLUTION_H_ODD				101
+#define ERR_RESOLUTION_V_ODD				102
+#define ERR_BANDWIDTH_OVERFLOW				103
+#define ERR_RESOLUTION_OVERFLOW				104
+#define ERR_DEVICE_NO_EXIST					105
+#define ERR_NO_SUPPORT_TRUE24				106
+#define ERR_NO_SUPPORT_TRUECOM				107
+#define ERR_ROTATION_WITH_VAI				108
+#define ERR_FLIP_WITH_VAI					109
+
+#define ERR_DEVICE_CONFIG					200
+#define ERR_ASPECT_RATIO_NOMATCH			201
+#define ERR_PLL1N2_WRONG					202
+#define ERR_PLL1N3_WRONG					203
+#define ERR_PLL1N1_WRONG					204
+#define ERR_PLL3N8_WRONG					205
+#define ERR_PLL2N5_WRONG					206
+#define ERR_PLL2N6_WRONG					207
+#define ERR_PLL2N7_WRONG					208
+#define ERR_DMXTAL_WRONG					209
+#define ERR_HDMI_CLOCK_NO_SUPPORT			210
+
+#define ERR_DEVICE_RUNNING					300
+#define ERR_CAL_INC_DIV_ZERO				301
+#define	ERR_CAL_INC_NO_MATH					302
+
+
+
+typedef enum {
+    SS_POWER_ON_STATE,
+    SS_SUCCESS,
+    SS_NOT_SUPPORTED,
+    SS_INVALID_ARGUMENT,
+    SS_PENDING,
+    SS_TARGET_UNSPECIFIED,
+    SS_SCALING_UNSUPPORTED,
+
+	SS_MEM_ALLOC_ERR,
+
+
+    SS_UNSUCCESSFUL = 10,
+    SS_INVALID_RETURN,
+    SS_WRITE_FAILED,
+    SS_READ_FAILED,
+
+	SS_FIRMWARE_ERR,
+	SS_FIRMWARE_TIMEOUT,
+
+	SS_CRT_HPD_NOTCONNECTED,
+	SS_CRT_HPD_CONNECTED_TO_GRD,
+
+
+} ch7036_status_t;
+
+
+#endif
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/config_.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/config_.h
new file mode 100644
index 0000000..ebc92eb
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/config_.h
@@ -0,0 +1,87 @@
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  config_.h
+* @version 1.1.4
+*-----------------------------------------------------------------------------
+*/
+
+#ifndef _CONFIG_H_
+#define _CONFIG_H_
+
+
+#define T_LVDS_OPEN
+#define T_LVDS_INIT
+#define T_POST_SETMODE
+#define T_LVDS_CLOSE
+
+
+
+
+#define T_SET_TIMING
+
+
+
+
+#define T_PD_DISPLAY_LVDS_INT
+
+
+
+
+#define T_DEVICE_DETECTION
+#define T_RES_DEALLOC
+
+
+
+
+
+
+#define T_TEST_HW
+#define T_RESET
+
+
+
+#define T_HDMI_TIMING_TABLE
+#define T_VGA_TIMING_TABLE
+#define T_PANEL_NATIVE_DTD
+
+
+#define T_LH_POWER_ON_OFF
+
+
+
+
+
+#define T_CH7036_USE_LVDS_ATTR_TABLE
+
+#define T_CH7036_INIT_ATTR_TABLE
+
+
+#define T_CH7036_USE_FIRMWARE
+
+
+#define T_LINUX
+
+
+
+
+#endif
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/hdcp7036.car b/drivers/gpu/drm/emgd/emgd/pal/ch7036/hdcp7036.car
new file mode 100644
index 0000000..9920ce4
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/hdcp7036.car
@@ -0,0 +1,6782 @@
+unsigned char lhfm_array[]= {
+	0x02,
+	0x13,
+	0xCC,
+	0x02,
+	0x16,
+	0xFE,
+	0x01,
+	0x24,
+	0x00,
+	0x00,
+	0xFF,
+	0x02,
+	0x15,
+	0x4C,
+	0xA2,
+	0x04,
+	0x82,
+	0x12,
+	0x40,
+	0x03,
+	0x02,
+	0x05,
+	0xC4,
+	0xC2,
+	0x05,
+	0xE4,
+	0xF5,
+	0x5C,
+	0x12,
+	0x1A,
+	0x6D,
+	0x50,
+	0x05,
+	0xE5,
+	0x2B,
+	0x20,
+	0xE5,
+	0x11,
+	0x12,
+	0x1A,
+	0x33,
+	0x30,
+	0x03,
+	0x02,
+	0xC3,
+	0x22,
+	0x05,
+	0x5C,
+	0xE5,
+	0x5C,
+	0xC3,
+	0x94,
+	0x32,
+	0x40,
+	0xE5,
+	0xE5,
+	0x2B,
+	0x20,
+	0xE5,
+	0x05,
+	0x7F,
+	0x10,
+	0x02,
+	0x05,
+	0xBF,
+	0x7B,
+	0x02,
+	0x7D,
+	0x41,
+	0x12,
+	0x17,
+	0x8B,
+	0x85,
+	0x2B,
+	0x59,
+	0x85,
+	0x2C,
+	0x5A,
+	0xE5,
+	0x2B,
+	0x54,
+	0x7F,
+	0xF5,
+	0x5B,
+	0xE5,
+	0x2C,
+	0x20,
+	0xE3,
+	0x0C,
+	0xE5,
+	0x2B,
+	0x20,
+	0xE7,
+	0x07,
+	0xE5,
+	0x5B,
+	0xD3,
+	0x94,
+	0x09,
+	0x40,
+	0x0C,
+	0x7D,
+	0x01,
+	0x7F,
+	0x10,
+	0x12,
+	0x11,
+	0xB3,
+	0x7F,
+	0x20,
+	0x02,
+	0x05,
+	0xBF,
+	0x7D,
+	0x08,
+	0x7F,
+	0x0D,
+	0x12,
+	0x11,
+	0xBD,
+	0x75,
+	0x5D,
+	0x74,
+	0xE4,
+	0xF5,
+	0x58,
+	0xE5,
+	0x5D,
+	0x25,
+	0x58,
+	0xF8,
+	0xE4,
+	0xF6,
+	0x05,
+	0x58,
+	0xE5,
+	0x58,
+	0xB4,
+	0x40,
+	0xF2,
+	0xE5,
+	0x5B,
+	0x75,
+	0xF0,
+	0x05,
+	0xA4,
+	0xF5,
+	0x5C,
+	0xE5,
+	0x5B,
+	0x60,
+	0x1C,
+	0xAB,
+	0x5C,
+	0x7D,
+	0x43,
+	0x7C,
+	0x00,
+	0x7F,
+	0x3A,
+	0x7E,
+	0x00,
+	0x12,
+	0x16,
+	0xA3,
+	0xAD,
+	0x5D,
+	0xE4,
+	0xFF,
+	0x12,
+	0x12,
+	0xAC,
+	0xEF,
+	0x60,
+	0x05,
+	0x7F,
+	0x40,
+	0x02,
+	0x05,
+	0xBF,
+	0xAF,
+	0x5C,
+	0x05,
+	0x5C,
+	0xE5,
+	0x5D,
+	0x2F,
+	0xF8,
+	0xA6,
+	0x59,
+	0xAF,
+	0x5C,
+	0x05,
+	0x5C,
+	0xE5,
+	0x5D,
+	0x2F,
+	0xF8,
+	0xA6,
+	0x5A,
+	0x75,
+	0x58,
+	0x21,
+	0xAF,
+	0x58,
+	0x12,
+	0x19,
+	0x8F,
+	0xAE,
+	0x5C,
+	0x05,
+	0x5C,
+	0xE5,
+	0x5D,
+	0x2E,
+	0xF8,
+	0xA6,
+	0x07,
+	0x15,
+	0x58,
+	0xE5,
+	0x58,
+	0xD3,
+	0x94,
+	0x19,
+	0x50,
+	0xE8,
+	0xE5,
+	0x5D,
+	0x25,
+	0x5C,
+	0xF8,
+	0x76,
+	0x80,
+	0x75,
+	0x5E,
+	0x00,
+	0x85,
+	0x5B,
+	0x5F,
+	0xAE,
+	0x5E,
+	0xAF,
+	0x5F,
+	0x7C,
+	0x00,
+	0x7D,
+	0x28,
+	0x12,
+	0x0E,
+	0x74,
+	0xEF,
+	0x24,
+	0x50,
+	0xF5,
+	0x5F,
+	0xE4,
+	0x3E,
+	0xF5,
+	0x5E,
+	0xFF,
+	0xE5,
+	0x5D,
+	0x24,
+	0x3E,
+	0xF8,
+	0xA6,
+	0x07,
+	0xE5,
+	0x5D,
+	0x24,
+	0x3F,
+	0xF8,
+	0xA6,
+	0x5F,
+	0x78,
+	0xC4,
+	0x12,
+	0x0E,
+	0xFD,
+	0x67,
+	0x45,
+	0x23,
+	0x01,
+	0x78,
+	0xC8,
+	0x12,
+	0x0E,
+	0xFD,
+	0xEF,
+	0xCD,
+	0xAB,
+	0x89,
+	0x78,
+	0xCC,
+	0x12,
+	0x0E,
+	0xFD,
+	0x98,
+	0xBA,
+	0xDC,
+	0xFE,
+	0x78,
+	0xD0,
+	0x12,
+	0x0E,
+	0xFD,
+	0x10,
+	0x32,
+	0x54,
+	0x76,
+	0x78,
+	0xD4,
+	0x12,
+	0x0E,
+	0xFD,
+	0xC3,
+	0xD2,
+	0xE1,
+	0xF0,
+	0xE4,
+	0xF5,
+	0x58,
+	0xE5,
+	0x58,
+	0x54,
+	0x0F,
+	0xF5,
+	0x5D,
+	0xE5,
+	0x58,
+	0xD3,
+	0x94,
+	0x13,
+	0x50,
+	0x5C,
+	0x78,
+	0xC8,
+	0x12,
+	0x0E,
+	0xD8,
+	0x12,
+	0x0E,
+	0x86,
+	0x78,
+	0xD0,
+	0x12,
+	0x0E,
+	0xE4,
+	0xEF,
+	0x5B,
+	0xFF,
+	0xEE,
+	0x5A,
+	0xFE,
+	0xED,
+	0x59,
+	0xFD,
+	0xEC,
+	0x58,
+	0xFC,
+	0xC0,
+	0x04,
+	0xC0,
+	0x05,
+	0xC0,
+	0x06,
+	0xC0,
+	0x07,
+	0x78,
+	0xCC,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0xC8,
+	0x12,
+	0x0E,
+	0xE4,
+	0xEB,
+	0x5F,
+	0xFF,
+	0xEA,
+	0x5E,
+	0xFE,
+	0xE9,
+	0x5D,
+	0xFD,
+	0xE8,
+	0x5C,
+	0xFC,
+	0xD0,
+	0x03,
+	0xD0,
+	0x02,
+	0xD0,
+	0x01,
+	0xD0,
+	0x00,
+	0xEF,
+	0x6B,
+	0xFF,
+	0xEE,
+	0x6A,
+	0xFE,
+	0xED,
+	0x69,
+	0xFD,
+	0xEC,
+	0x68,
+	0xFC,
+	0x78,
+	0xBC,
+	0x12,
+	0x0E,
+	0xF1,
+	0x78,
+	0xC0,
+	0x12,
+	0x0E,
+	0xFD,
+	0x5A,
+	0x82,
+	0x79,
+	0x99,
+	0x02,
+	0x02,
+	0xBB,
+	0xE5,
+	0x58,
+	0xD3,
+	0x94,
+	0x27,
+	0x50,
+	0x38,
+	0x78,
+	0xCC,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0xC8,
+	0x12,
+	0x0E,
+	0xE4,
+	0xEB,
+	0x6F,
+	0xFF,
+	0xEA,
+	0x6E,
+	0xFE,
+	0xE9,
+	0x6D,
+	0xFD,
+	0xE8,
+	0x6C,
+	0xFC,
+	0x78,
+	0xD0,
+	0x12,
+	0x0E,
+	0xE4,
+	0xEF,
+	0x6B,
+	0xFF,
+	0xEE,
+	0x6A,
+	0xFE,
+	0xED,
+	0x69,
+	0xFD,
+	0xEC,
+	0x68,
+	0xFC,
+	0x78,
+	0xBC,
+	0x12,
+	0x0E,
+	0xF1,
+	0x78,
+	0xC0,
+	0x12,
+	0x0E,
+	0xFD,
+	0x6E,
+	0xD9,
+	0xEB,
+	0xA1,
+	0x02,
+	0x02,
+	0xBB,
+	0xE5,
+	0x58,
+	0xD3,
+	0x94,
+	0x3B,
+	0x40,
+	0x03,
+	0x02,
+	0x02,
+	0x7F,
+	0x78,
+	0xD0,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0xC8,
+	0x12,
+	0x0E,
+	0xE4,
+	0xEB,
+	0x5F,
+	0xFF,
+	0xEA,
+	0x5E,
+	0xFE,
+	0xE9,
+	0x5D,
+	0xFD,
+	0xE8,
+	0x5C,
+	0xFC,
+	0xC0,
+	0x04,
+	0xC0,
+	0x05,
+	0xC0,
+	0x06,
+	0xC0,
+	0x07,
+	0x78,
+	0xCC,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0xC8,
+	0x12,
+	0x0E,
+	0xE4,
+	0xEB,
+	0x5F,
+	0xFF,
+	0xEA,
+	0x5E,
+	0xFE,
+	0xE9,
+	0x5D,
+	0xFD,
+	0xE8,
+	0x5C,
+	0xFC,
+	0xD0,
+	0x03,
+	0xD0,
+	0x02,
+	0xD0,
+	0x01,
+	0xD0,
+	0x00,
+	0xEF,
+	0x6B,
+	0xFF,
+	0xEE,
+	0x6A,
+	0xFE,
+	0xED,
+	0x69,
+	0xFD,
+	0xEC,
+	0x68,
+	0xFC,
+	0xC0,
+	0x04,
+	0xC0,
+	0x05,
+	0xC0,
+	0x06,
+	0xC0,
+	0x07,
+	0x78,
+	0xD0,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0xCC,
+	0x12,
+	0x0E,
+	0xE4,
+	0xEB,
+	0x5F,
+	0xFF,
+	0xEA,
+	0x5E,
+	0xFE,
+	0xE9,
+	0x5D,
+	0xFD,
+	0xE8,
+	0x5C,
+	0xFC,
+	0xD0,
+	0x03,
+	0xD0,
+	0x02,
+	0xD0,
+	0x01,
+	0xD0,
+	0x00,
+	0xEB,
+	0x6F,
+	0xFF,
+	0xEA,
+	0x6E,
+	0xFE,
+	0xE9,
+	0x6D,
+	0xFD,
+	0xE8,
+	0x6C,
+	0xFC,
+	0x78,
+	0xBC,
+	0x12,
+	0x0E,
+	0xF1,
+	0x78,
+	0xC0,
+	0x12,
+	0x0E,
+	0xFD,
+	0x8F,
+	0x1B,
+	0xBC,
+	0xDC,
+	0x80,
+	0x3C,
+	0xE5,
+	0x58,
+	0xC3,
+	0x94,
+	0x3C,
+	0x40,
+	0x35,
+	0x78,
+	0xCC,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0xC8,
+	0x12,
+	0x0E,
+	0xE4,
+	0xEB,
+	0x6F,
+	0xFF,
+	0xEA,
+	0x6E,
+	0xFE,
+	0xE9,
+	0x6D,
+	0xFD,
+	0xE8,
+	0x6C,
+	0xFC,
+	0x78,
+	0xD0,
+	0x12,
+	0x0E,
+	0xE4,
+	0xEF,
+	0x6B,
+	0xFF,
+	0xEE,
+	0x6A,
+	0xFE,
+	0xED,
+	0x69,
+	0xFD,
+	0xEC,
+	0x68,
+	0xFC,
+	0x78,
+	0xBC,
+	0x12,
+	0x0E,
+	0xF1,
+	0x78,
+	0xC0,
+	0x12,
+	0x0E,
+	0xFD,
+	0xCA,
+	0x62,
+	0xC1,
+	0xD6,
+	0xE5,
+	0x58,
+	0xC3,
+	0x94,
+	0x10,
+	0x50,
+	0x03,
+	0x02,
+	0x03,
+	0x66,
+	0xE5,
+	0x5D,
+	0x24,
+	0x08,
+	0x54,
+	0x0F,
+	0x25,
+	0xE0,
+	0x25,
+	0xE0,
+	0x24,
+	0x74,
+	0xF8,
+	0x12,
+	0x0E,
+	0xD8,
+	0xE5,
+	0x5D,
+	0x24,
+	0x0D,
+	0x54,
+	0x0F,
+	0x25,
+	0xE0,
+	0x25,
+	0xE0,
+	0x24,
+	0x74,
+	0xF8,
+	0x12,
+	0x0E,
+	0xE4,
+	0xEB,
+	0x6F,
+	0xFF,
+	0xEA,
+	0x6E,
+	0xFE,
+	0xE9,
+	0x6D,
+	0xFD,
+	0xE8,
+	0x6C,
+	0xFC,
+	0xE5,
+	0x5D,
+	0x24,
+	0x02,
+	0x54,
+	0x0F,
+	0x25,
+	0xE0,
+	0x25,
+	0xE0,
+	0x24,
+	0x74,
+	0xF8,
+	0x12,
+	0x0E,
+	0xE4,
+	0xEF,
+	0x6B,
+	0xFF,
+	0xEE,
+	0x6A,
+	0xFE,
+	0xED,
+	0x69,
+	0xFD,
+	0xEC,
+	0x68,
+	0xFC,
+	0xE5,
+	0x5D,
+	0x25,
+	0xE0,
+	0x25,
+	0xE0,
+	0x24,
+	0x74,
+	0xF8,
+	0x12,
+	0x0E,
+	0xE4,
+	0xEF,
+	0x6B,
+	0xFF,
+	0xEE,
+	0x6A,
+	0xFE,
+	0xED,
+	0x69,
+	0xFD,
+	0xEC,
+	0x68,
+	0xFC,
+	0x78,
+	0xB4,
+	0x12,
+	0x0E,
+	0xF1,
+	0x78,
+	0xB4,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0x01,
+	0x12,
+	0x0E,
+	0xC5,
+	0xC0,
+	0x04,
+	0xC0,
+	0x05,
+	0xC0,
+	0x06,
+	0xC0,
+	0x07,
+	0x78,
+	0xB4,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0x1F,
+	0x12,
+	0x0E,
+	0xB2,
+	0xD0,
+	0x03,
+	0xD0,
+	0x02,
+	0xD0,
+	0x01,
+	0xD0,
+	0x00,
+	0xEF,
+	0x4B,
+	0xFF,
+	0xEE,
+	0x4A,
+	0xFE,
+	0xED,
+	0x49,
+	0xFD,
+	0xEC,
+	0x48,
+	0xFC,
+	0xE5,
+	0x5D,
+	0x25,
+	0xE0,
+	0x25,
+	0xE0,
+	0x24,
+	0x74,
+	0xF8,
+	0x12,
+	0x0E,
+	0xF1,
+	0x78,
+	0xC4,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0x05,
+	0x12,
+	0x0E,
+	0xC5,
+	0xC0,
+	0x04,
+	0xC0,
+	0x05,
+	0xC0,
+	0x06,
+	0xC0,
+	0x07,
+	0x78,
+	0xC4,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0x1B,
+	0x12,
+	0x0E,
+	0xB2,
+	0xD0,
+	0x03,
+	0xD0,
+	0x02,
+	0xD0,
+	0x01,
+	0xD0,
+	0x00,
+	0xEF,
+	0x4B,
+	0xFF,
+	0xEE,
+	0x4A,
+	0xFE,
+	0xED,
+	0x49,
+	0xFD,
+	0xEC,
+	0x48,
+	0xFC,
+	0x78,
+	0xBC,
+	0x12,
+	0x0E,
+	0xE4,
+	0xEF,
+	0x2B,
+	0xFF,
+	0xEE,
+	0x3A,
+	0xFE,
+	0xED,
+	0x39,
+	0xFD,
+	0xEC,
+	0x38,
+	0xFC,
+	0x78,
+	0xD4,
+	0x12,
+	0x0E,
+	0xE4,
+	0xEF,
+	0x2B,
+	0xFF,
+	0xEE,
+	0x3A,
+	0xFE,
+	0xED,
+	0x39,
+	0xFD,
+	0xEC,
+	0x38,
+	0xFC,
+	0x78,
+	0xC0,
+	0x12,
+	0x0E,
+	0xE4,
+	0xEF,
+	0x2B,
+	0xFF,
+	0xEE,
+	0x3A,
+	0xFE,
+	0xED,
+	0x39,
+	0xFD,
+	0xEC,
+	0x38,
+	0xFC,
+	0xE5,
+	0x5D,
+	0x25,
+	0xE0,
+	0x25,
+	0xE0,
+	0x24,
+	0x74,
+	0xF8,
+	0x12,
+	0x0E,
+	0xE4,
+	0xEF,
+	0x2B,
+	0xFF,
+	0xEE,
+	0x3A,
+	0xFE,
+	0xED,
+	0x39,
+	0xFD,
+	0xEC,
+	0x38,
+	0xFC,
+	0x78,
+	0xB8,
+	0x12,
+	0x0E,
+	0xF1,
+	0x78,
+	0xD0,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0xD4,
+	0x12,
+	0x0E,
+	0xF1,
+	0x78,
+	0xCC,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0xD0,
+	0x12,
+	0x0E,
+	0xF1,
+	0x78,
+	0xC8,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0x1E,
+	0x12,
+	0x0E,
+	0xC5,
+	0xC0,
+	0x04,
+	0xC0,
+	0x05,
+	0xC0,
+	0x06,
+	0xC0,
+	0x07,
+	0x78,
+	0xC8,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0x02,
+	0x12,
+	0x0E,
+	0xB2,
+	0xD0,
+	0x03,
+	0xD0,
+	0x02,
+	0xD0,
+	0x01,
+	0xD0,
+	0x00,
+	0xEF,
+	0x4B,
+	0xFF,
+	0xEE,
+	0x4A,
+	0xFE,
+	0xED,
+	0x49,
+	0xFD,
+	0xEC,
+	0x48,
+	0xFC,
+	0x78,
+	0xCC,
+	0x12,
+	0x0E,
+	0xF1,
+	0x78,
+	0xC4,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0xC8,
+	0x12,
+	0x0E,
+	0xF1,
+	0x78,
+	0xB8,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0xC4,
+	0x12,
+	0x0E,
+	0xF1,
+	0x05,
+	0x58,
+	0xE5,
+	0x58,
+	0x64,
+	0x50,
+	0x60,
+	0x03,
+	0x02,
+	0x01,
+	0x43,
+	0x78,
+	0xC4,
+	0x12,
+	0x0E,
+	0xD8,
+	0xEF,
+	0x24,
+	0x01,
+	0xFF,
+	0xEE,
+	0x34,
+	0x23,
+	0xFE,
+	0xED,
+	0x34,
+	0x45,
+	0xFD,
+	0xEC,
+	0x34,
+	0x67,
+	0xFC,
+	0x78,
+	0xC4,
+	0x12,
+	0x0E,
+	0xF1,
+	0x78,
+	0xC8,
+	0x12,
+	0x0E,
+	0xD8,
+	0xEF,
+	0x24,
+	0x89,
+	0xFF,
+	0xEE,
+	0x34,
+	0xAB,
+	0xFE,
+	0xED,
+	0x34,
+	0xCD,
+	0xFD,
+	0xEC,
+	0x34,
+	0xEF,
+	0xFC,
+	0x78,
+	0xC8,
+	0x12,
+	0x0E,
+	0xF1,
+	0x78,
+	0xCC,
+	0x12,
+	0x0E,
+	0xD8,
+	0xEF,
+	0x24,
+	0xFE,
+	0xFF,
+	0xEE,
+	0x34,
+	0xDC,
+	0xFE,
+	0xED,
+	0x34,
+	0xBA,
+	0xFD,
+	0xEC,
+	0x34,
+	0x98,
+	0xFC,
+	0x78,
+	0xCC,
+	0x12,
+	0x0E,
+	0xF1,
+	0x78,
+	0xD0,
+	0x12,
+	0x0E,
+	0xD8,
+	0xEF,
+	0x24,
+	0x76,
+	0xFF,
+	0xEE,
+	0x34,
+	0x54,
+	0xFE,
+	0xED,
+	0x34,
+	0x32,
+	0xFD,
+	0xEC,
+	0x34,
+	0x10,
+	0xFC,
+	0x78,
+	0xD0,
+	0x12,
+	0x0E,
+	0xF1,
+	0x78,
+	0xD4,
+	0x12,
+	0x0E,
+	0xD8,
+	0xEF,
+	0x24,
+	0xF0,
+	0xFF,
+	0xEE,
+	0x34,
+	0xE1,
+	0xFE,
+	0xED,
+	0x34,
+	0xD2,
+	0xFD,
+	0xEC,
+	0x34,
+	0xC3,
+	0xFC,
+	0x78,
+	0xD4,
+	0x12,
+	0x0E,
+	0xF1,
+	0x7D,
+	0x20,
+	0x12,
+	0x17,
+	0x89,
+	0x78,
+	0xB0,
+	0xA6,
+	0x2E,
+	0x08,
+	0xA6,
+	0x2D,
+	0x08,
+	0xA6,
+	0x2C,
+	0x08,
+	0xA6,
+	0x2B,
+	0x7D,
+	0x24,
+	0x12,
+	0x17,
+	0x89,
+	0x78,
+	0xAC,
+	0xA6,
+	0x2E,
+	0x08,
+	0xA6,
+	0x2D,
+	0x08,
+	0xA6,
+	0x2C,
+	0x08,
+	0xA6,
+	0x2B,
+	0x7B,
+	0x04,
+	0x7D,
+	0x28,
+	0x12,
+	0x17,
+	0x8B,
+	0x78,
+	0xA8,
+	0xA6,
+	0x2E,
+	0x08,
+	0xA6,
+	0x2D,
+	0x08,
+	0xA6,
+	0x2C,
+	0x08,
+	0xA6,
+	0x2B,
+	0x7B,
+	0x04,
+	0x7D,
+	0x2C,
+	0x12,
+	0x17,
+	0x8B,
+	0x78,
+	0xA4,
+	0xA6,
+	0x2E,
+	0x08,
+	0xA6,
+	0x2D,
+	0x08,
+	0xA6,
+	0x2C,
+	0x08,
+	0xA6,
+	0x2B,
+	0x7B,
+	0x04,
+	0x7D,
+	0x30,
+	0x12,
+	0x17,
+	0x8B,
+	0x78,
+	0xA0,
+	0xA6,
+	0x2E,
+	0x08,
+	0xA6,
+	0x2D,
+	0x08,
+	0xA6,
+	0x2C,
+	0x08,
+	0xA6,
+	0x2B,
+	0x78,
+	0xAC,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0xC8,
+	0x12,
+	0x0E,
+	0xE4,
+	0xC3,
+	0x12,
+	0x0E,
+	0xA1,
+	0x70,
+	0x06,
+	0x7F,
+	0x01,
+	0xC0,
+	0x07,
+	0x80,
+	0x04,
+	0x7F,
+	0x00,
+	0xC0,
+	0x07,
+	0x78,
+	0xB0,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0xC4,
+	0x12,
+	0x0E,
+	0xE4,
+	0xC3,
+	0x12,
+	0x0E,
+	0xA1,
+	0x70,
+	0x04,
+	0x7E,
+	0x01,
+	0x80,
+	0x02,
+	0x7E,
+	0x00,
+	0xD0,
+	0xE0,
+	0x5E,
+	0xFF,
+	0xC0,
+	0x07,
+	0x78,
+	0xA8,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0xCC,
+	0x12,
+	0x0E,
+	0xE4,
+	0xC3,
+	0x12,
+	0x0E,
+	0xA1,
+	0x70,
+	0x04,
+	0x7E,
+	0x01,
+	0x80,
+	0x02,
+	0x7E,
+	0x00,
+	0xD0,
+	0xE0,
+	0x5E,
+	0xFF,
+	0xC0,
+	0x07,
+	0x78,
+	0xA4,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0xD0,
+	0x12,
+	0x0E,
+	0xE4,
+	0xC3,
+	0x12,
+	0x0E,
+	0xA1,
+	0x70,
+	0x04,
+	0x7E,
+	0x01,
+	0x80,
+	0x02,
+	0x7E,
+	0x00,
+	0xD0,
+	0xE0,
+	0x5E,
+	0xFF,
+	0xC0,
+	0x07,
+	0x78,
+	0xA0,
+	0x12,
+	0x0E,
+	0xD8,
+	0x78,
+	0xD4,
+	0x12,
+	0x0E,
+	0xE4,
+	0xC3,
+	0x12,
+	0x0E,
+	0xA1,
+	0x70,
+	0x04,
+	0x7E,
+	0x01,
+	0x80,
+	0x02,
+	0x7E,
+	0x00,
+	0xD0,
+	0xE0,
+	0x5E,
+	0x60,
+	0x04,
+	0xD2,
+	0x05,
+	0x80,
+	0x07,
+	0x7F,
+	0x40,
+	0x12,
+	0x1A,
+	0x75,
+	0xC3,
+	0x22,
+	0xD3,
+	0x22,
+	0x7D,
+	0x01,
+	0x7F,
+	0x0F,
+	0x12,
+	0x11,
+	0x9E,
+	0xD2,
+	0x1B,
+	0x12,
+	0x19,
+	0xAA,
+	0x7F,
+	0xC8,
+	0x7E,
+	0x00,
+	0x12,
+	0x1A,
+	0x37,
+	0x12,
+	0x1A,
+	0x6D,
+	0x40,
+	0x05,
+	0x7F,
+	0x04,
+	0x02,
+	0x08,
+	0x6B,
+	0x7F,
+	0x0D,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x58,
+	0xE5,
+	0x2B,
+	0x30,
+	0xE6,
+	0x0C,
+	0xD2,
+	0x12,
+	0x43,
+	0x58,
+	0x04,
+	0x7F,
+	0x02,
+	0x12,
+	0x1A,
+	0x75,
+	0x80,
+	0x05,
+	0xC2,
+	0x12,
+	0x53,
+	0x58,
+	0xFB,
+	0xAD,
+	0x58,
+	0x7F,
+	0x0D,
+	0x12,
+	0x11,
+	0x72,
+	0x7F,
+	0x0F,
+	0x12,
+	0x19,
+	0x8F,
+	0xEF,
+	0x54,
+	0xEF,
+	0xF5,
+	0x58,
+	0xE5,
+	0x2B,
+	0x20,
+	0xE1,
+	0x09,
+	0x7F,
+	0x0A,
+	0x12,
+	0x19,
+	0x87,
+	0xEF,
+	0x30,
+	0xE2,
+	0x03,
+	0x43,
+	0x58,
+	0x10,
+	0xAD,
+	0x58,
+	0x7F,
+	0x0F,
+	0x12,
+	0x11,
+	0x72,
+	0xE4,
+	0xF5,
+	0x4A,
+	0x7B,
+	0x01,
+	0x7D,
+	0x15,
+	0xFC,
+	0x7F,
+	0x3A,
+	0x12,
+	0x18,
+	0xE1,
+	0x75,
+	0x59,
+	0x02,
+	0xC2,
+	0x19,
+	0xAF,
+	0x59,
+	0x15,
+	0x59,
+	0xEF,
+	0x60,
+	0x16,
+	0x7B,
+	0x05,
+	0xE4,
+	0xFD,
+	0xFC,
+	0x7F,
+	0x3A,
+	0x12,
+	0x17,
+	0x8F,
+	0x50,
+	0xED,
+	0x7F,
+	0x2B,
+	0x12,
+	0x19,
+	0x0D,
+	0x92,
+	0x19,
+	0x30,
+	0x19,
+	0xE3,
+	0x85,
+	0x2B,
+	0x44,
+	0x85,
+	0x2C,
+	0x45,
+	0x85,
+	0x2D,
+	0x46,
+	0x85,
+	0x2E,
+	0x47,
+	0x85,
+	0x2F,
+	0x48,
+	0x7F,
+	0x10,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x58,
+	0x30,
+	0x19,
+	0x09,
+	0x7D,
+	0x10,
+	0x7F,
+	0x10,
+	0x12,
+	0x11,
+	0x9E,
+	0x80,
+	0x0C,
+	0x7D,
+	0x10,
+	0x7F,
+	0x10,
+	0x12,
+	0x11,
+	0xB3,
+	0x7F,
+	0x08,
+	0x02,
+	0x08,
+	0x6B,
+	0x7D,
+	0x10,
+	0x7F,
+	0x0D,
+	0x12,
+	0x11,
+	0xBD,
+	0x75,
+	0x59,
+	0xFA,
+	0xAF,
+	0x59,
+	0x15,
+	0x59,
+	0xEF,
+	0x60,
+	0x09,
+	0x7F,
+	0x11,
+	0x12,
+	0x19,
+	0x8F,
+	0xEF,
+	0x30,
+	0xE7,
+	0xF0,
+	0xE5,
+	0x59,
+	0x70,
+	0x05,
+	0x7F,
+	0x04,
+	0x12,
+	0x1A,
+	0x75,
+	0x7F,
+	0x12,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x51,
+	0x7F,
+	0x13,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x50,
+	0x7F,
+	0x14,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x4F,
+	0x7F,
+	0x15,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x4E,
+	0x7F,
+	0x16,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x4D,
+	0x7F,
+	0x17,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x4C,
+	0x7F,
+	0x18,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x4B,
+	0x7F,
+	0x19,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x4A,
+	0x7B,
+	0x08,
+	0x7D,
+	0x18,
+	0x7C,
+	0x00,
+	0x7F,
+	0x3A,
+	0x12,
+	0x18,
+	0xE1,
+	0x85,
+	0x3F,
+	0x4A,
+	0x85,
+	0x40,
+	0x4B,
+	0x85,
+	0x41,
+	0x4C,
+	0x85,
+	0x42,
+	0x4D,
+	0x85,
+	0x43,
+	0x4E,
+	0x7B,
+	0x05,
+	0x7D,
+	0x10,
+	0x7C,
+	0x00,
+	0x7F,
+	0x3A,
+	0x12,
+	0x18,
+	0xE1,
+	0x7D,
+	0x01,
+	0x7F,
+	0x09,
+	0x7E,
+	0x00,
+	0x12,
+	0x18,
+	0xB5,
+	0x53,
+	0x2B,
+	0xE0,
+	0xE5,
+	0x2B,
+	0x13,
+	0x13,
+	0x13,
+	0x54,
+	0x1F,
+	0xF5,
+	0x2B,
+	0x7F,
+	0x17,
+	0x12,
+	0x19,
+	0x93,
+	0x8F,
+	0x58,
+	0xE5,
+	0x2B,
+	0x42,
+	0x58,
+	0xAD,
+	0x58,
+	0x7F,
+	0x17,
+	0x12,
+	0x11,
+	0x76,
+	0xE4,
+	0xF5,
+	0x59,
+	0x74,
+	0x44,
+	0x25,
+	0x59,
+	0xF8,
+	0xE6,
+	0xF5,
+	0x5D,
+	0xE4,
+	0xF5,
+	0x5A,
+	0xE5,
+	0x5D,
+	0x7D,
+	0x80,
+	0x7F,
+	0x17,
+	0x30,
+	0xE0,
+	0x05,
+	0x12,
+	0x11,
+	0xB7,
+	0x80,
+	0x03,
+	0x12,
+	0x11,
+	0xA2,
+	0xE5,
+	0x5D,
+	0xC3,
+	0x13,
+	0xF5,
+	0x5D,
+	0xE5,
+	0x59,
+	0x75,
+	0xF0,
+	0x08,
+	0xA4,
+	0x7C,
+	0x00,
+	0x25,
+	0x5A,
+	0xFF,
+	0xEC,
+	0x35,
+	0xF0,
+	0xFE,
+	0xEF,
+	0x78,
+	0x03,
+	0xC3,
+	0x33,
+	0xCE,
+	0x33,
+	0xCE,
+	0xD8,
+	0xF9,
+	0x24,
+	0x10,
+	0xF5,
+	0x5C,
+	0xE4,
+	0x3E,
+	0xF5,
+	0x5B,
+	0x7D,
+	0x08,
+	0xAF,
+	0x5C,
+	0xFE,
+	0x12,
+	0x18,
+	0xB5,
+	0xAD,
+	0x2B,
+	0x7F,
+	0x16,
+	0x12,
+	0x11,
+	0x76,
+	0xAD,
+	0x2C,
+	0x7F,
+	0x15,
+	0x12,
+	0x11,
+	0x76,
+	0xAD,
+	0x2D,
+	0x7F,
+	0x14,
+	0x12,
+	0x11,
+	0x76,
+	0xAD,
+	0x2E,
+	0x7F,
+	0x13,
+	0x12,
+	0x11,
+	0x76,
+	0xAD,
+	0x2F,
+	0x7F,
+	0x12,
+	0x12,
+	0x11,
+	0x76,
+	0xAD,
+	0x30,
+	0x7F,
+	0x11,
+	0x12,
+	0x11,
+	0x76,
+	0xAD,
+	0x31,
+	0x7F,
+	0x10,
+	0x12,
+	0x11,
+	0x76,
+	0xAD,
+	0x32,
+	0x7F,
+	0x0F,
+	0x12,
+	0x11,
+	0x76,
+	0xE5,
+	0x59,
+	0x70,
+	0x04,
+	0xE5,
+	0x5A,
+	0x60,
+	0x04,
+	0x7D,
+	0x20,
+	0x80,
+	0x02,
+	0x7D,
+	0x40,
+	0x7F,
+	0x17,
+	0x12,
+	0x11,
+	0xC1,
+	0x05,
+	0x5A,
+	0xE5,
+	0x5A,
+	0xD3,
+	0x94,
+	0x07,
+	0x50,
+	0x03,
+	0x02,
+	0x07,
+	0x3B,
+	0x05,
+	0x59,
+	0xE5,
+	0x59,
+	0xD3,
+	0x94,
+	0x04,
+	0x50,
+	0x03,
+	0x02,
+	0x07,
+	0x30,
+	0x7D,
+	0x08,
+	0x7F,
+	0x10,
+	0x12,
+	0x11,
+	0x9E,
+	0x7D,
+	0x40,
+	0x7F,
+	0x0D,
+	0x12,
+	0x11,
+	0x9E,
+	0x7D,
+	0x08,
+	0x7F,
+	0x10,
+	0x12,
+	0x11,
+	0xB3,
+	0x7D,
+	0x40,
+	0x7F,
+	0x0D,
+	0x12,
+	0x11,
+	0xB3,
+	0x7D,
+	0x08,
+	0x7F,
+	0x10,
+	0x12,
+	0x11,
+	0x9E,
+	0x7D,
+	0x40,
+	0x7F,
+	0x0D,
+	0x12,
+	0x11,
+	0x9E,
+	0x12,
+	0x1A,
+	0x33,
+	0x30,
+	0x03,
+	0x02,
+	0xC3,
+	0x22,
+	0x12,
+	0x1A,
+	0x53,
+	0x75,
+	0x59,
+	0xFA,
+	0xAF,
+	0x59,
+	0x15,
+	0x59,
+	0xEF,
+	0x60,
+	0x09,
+	0x7F,
+	0x25,
+	0x12,
+	0x19,
+	0x8F,
+	0xEF,
+	0x30,
+	0xE7,
+	0xF0,
+	0xE5,
+	0x59,
+	0x70,
+	0x05,
+	0x7F,
+	0x04,
+	0x12,
+	0x1A,
+	0x75,
+	0x7F,
+	0x23,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x2D,
+	0x7F,
+	0x24,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x2E,
+	0xE5,
+	0x2E,
+	0xB5,
+	0x2B,
+	0x04,
+	0x7F,
+	0x01,
+	0x80,
+	0x02,
+	0x7F,
+	0x00,
+	0xE5,
+	0x2D,
+	0xB5,
+	0x2C,
+	0x04,
+	0x7E,
+	0x01,
+	0x80,
+	0x02,
+	0x7E,
+	0x00,
+	0xEE,
+	0x5F,
+	0x60,
+	0x0B,
+	0xD2,
+	0x04,
+	0x7D,
+	0x22,
+	0x7F,
+	0x0D,
+	0x12,
+	0x11,
+	0xBD,
+	0x80,
+	0x0E,
+	0x7D,
+	0x01,
+	0x7F,
+	0x10,
+	0x12,
+	0x11,
+	0xB3,
+	0x7F,
+	0x80,
+	0x12,
+	0x1A,
+	0x75,
+	0xC3,
+	0x22,
+	0xD2,
+	0x05,
+	0xD3,
+	0x22,
+	0x75,
+	0x5E,
+	0x74,
+	0xE4,
+	0xF5,
+	0x28,
+	0xF5,
+	0x29,
+	0xC2,
+	0x01,
+	0xF5,
+	0x27,
+	0xF5,
+	0x2A,
+	0xFF,
+	0x12,
+	0x16,
+	0x36,
+	0x40,
+	0x01,
+	0x22,
+	0xE5,
+	0x5E,
+	0x24,
+	0x3E,
+	0xF8,
+	0xE6,
+	0xF5,
+	0x58,
+	0x7B,
+	0x02,
+	0x7D,
+	0x23,
+	0xE4,
+	0xFF,
+	0x12,
+	0x15,
+	0xC8,
+	0x40,
+	0x01,
+	0x22,
+	0xA8,
+	0x5E,
+	0xE6,
+	0x30,
+	0xE0,
+	0x03,
+	0x43,
+	0x2A,
+	0x01,
+	0xE8,
+	0x04,
+	0xF8,
+	0xE6,
+	0xFF,
+	0x54,
+	0x0E,
+	0x60,
+	0x03,
+	0x43,
+	0x2A,
+	0x02,
+	0xEF,
+	0x30,
+	0xE0,
+	0x03,
+	0x43,
+	0x2A,
+	0x04,
+	0x75,
+	0x59,
+	0x26,
+	0xE4,
+	0xF5,
+	0x5D,
+	0x7B,
+	0x02,
+	0xAD,
+	0x59,
+	0xE4,
+	0xFF,
+	0x12,
+	0x15,
+	0xC8,
+	0x50,
+	0x36,
+	0x05,
+	0x59,
+	0x05,
+	0x59,
+	0xA8,
+	0x5E,
+	0xE6,
+	0xFF,
+	0xB4,
+	0x01,
+	0x08,
+	0xE8,
+	0x04,
+	0xF8,
+	0xE6,
+	0x64,
+	0x01,
+	0x60,
+	0x23,
+	0xE5,
+	0x5E,
+	0x04,
+	0xF8,
+	0x74,
+	0xC0,
+	0x56,
+	0xF6,
+	0xEF,
+	0xB4,
+	0x81,
+	0x09,
+	0xE5,
+	0x5E,
+	0x04,
+	0xF8,
+	0x76,
+	0x80,
+	0x43,
+	0x2A,
+	0x04,
+	0xA8,
+	0x5E,
+	0xE6,
+	0xB4,
+	0xA9,
+	0x08,
+	0xE8,
+	0x04,
+	0xF8,
+	0x76,
+	0x40,
+	0x43,
+	0x2A,
+	0x10,
+	0x05,
+	0x5D,
+	0xE5,
+	0x5D,
+	0xC3,
+	0x94,
+	0x08,
+	0x40,
+	0xB6,
+	0x7B,
+	0x06,
+	0x7D,
+	0x38,
+	0xE4,
+	0xFF,
+	0x12,
+	0x15,
+	0xC8,
+	0x40,
+	0x03,
+	0x02,
+	0x09,
+	0x96,
+	0xE5,
+	0x5E,
+	0x24,
+	0x02,
+	0xF8,
+	0xE6,
+	0x54,
+	0xF0,
+	0xFF,
+	0xE5,
+	0x5E,
+	0x04,
+	0xF8,
+	0xA6,
+	0x07,
+	0xE5,
+	0x5E,
+	0x24,
+	0x03,
+	0xF8,
+	0xE6,
+	0xFF,
+	0xE5,
+	0x5E,
+	0x24,
+	0x02,
+	0xF8,
+	0xA6,
+	0x07,
+	0xE5,
+	0x5E,
+	0x24,
+	0x05,
+	0xF8,
+	0xE6,
+	0x54,
+	0xF0,
+	0xFF,
+	0xE5,
+	0x5E,
+	0x24,
+	0x03,
+	0xF8,
+	0xA6,
+	0x07,
+	0xE4,
+	0xF5,
+	0x5D,
+	0xE4,
+	0xF5,
+	0x5A,
+	0xE5,
+	0x5D,
+	0x75,
+	0xF0,
+	0x05,
+	0xA4,
+	0x24,
+	0x02,
+	0xF5,
+	0x82,
+	0xE4,
+	0x34,
+	0x11,
+	0xF5,
+	0x83,
+	0xE5,
+	0x82,
+	0x25,
+	0x5A,
+	0xF5,
+	0x82,
+	0xE4,
+	0x35,
+	0x83,
+	0xF5,
+	0x83,
+	0xE4,
+	0x93,
+	0xFF,
+	0xE5,
+	0x5E,
+	0x25,
+	0x5A,
+	0xF8,
+	0xE6,
+	0xB5,
+	0x07,
+	0x07,
+	0x05,
+	0x5A,
+	0xE5,
+	0x5A,
+	0xB4,
+	0x04,
+	0xD3,
+	0xE5,
+	0x5A,
+	0xB4,
+	0x04,
+	0x13,
+	0xE5,
+	0x5D,
+	0x75,
+	0xF0,
+	0x05,
+	0xA4,
+	0x24,
+	0x07,
+	0xF5,
+	0x82,
+	0xE4,
+	0x34,
+	0x11,
+	0xF5,
+	0x83,
+	0xE4,
+	0x93,
+	0x42,
+	0x2A,
+	0x05,
+	0x5D,
+	0xE5,
+	0x5D,
+	0xB4,
+	0x03,
+	0xB1,
+	0xD2,
+	0x08,
+	0xE5,
+	0x58,
+	0x70,
+	0x02,
+	0xC3,
+	0x22,
+	0x75,
+	0x5D,
+	0x01,
+	0xE5,
+	0x5D,
+	0xD3,
+	0x95,
+	0x58,
+	0x40,
+	0x03,
+	0x02,
+	0x0A,
+	0xC7,
+	0xE5,
+	0x5D,
+	0x30,
+	0xE0,
+	0x04,
+	0x7F,
+	0x80,
+	0x80,
+	0x02,
+	0x7F,
+	0x00,
+	0x8F,
+	0x5F,
+	0xAF,
+	0x5D,
+	0x12,
+	0x16,
+	0x36,
+	0x40,
+	0x01,
+	0x22,
+	0xE5,
+	0x5D,
+	0xC3,
+	0x13,
+	0xF5,
+	0x5C,
+	0x7B,
+	0x05,
+	0xAD,
+	0x5F,
+	0xFF,
+	0x12,
+	0x15,
+	0xC8,
+	0x40,
+	0x01,
+	0x22,
+	0xA8,
+	0x5E,
+	0xE6,
+	0x64,
+	0x02,
+	0x60,
+	0x03,
+	0x02,
+	0x0A,
+	0xC2,
+	0xE8,
+	0x04,
+	0xF8,
+	0xE6,
+	0x64,
+	0x03,
+	0x60,
+	0x03,
+	0x02,
+	0x0A,
+	0xC2,
+	0xE5,
+	0x5E,
+	0x24,
+	0x02,
+	0xF8,
+	0xE6,
+	0xFF,
+	0xD3,
+	0x94,
+	0x04,
+	0x50,
+	0x03,
+	0x02,
+	0x0A,
+	0xC2,
+	0x8F,
+	0x59,
+	0xE5,
+	0x5E,
+	0x24,
+	0x04,
+	0xF8,
+	0xE6,
+	0xF5,
+	0x5A,
+	0x75,
+	0x5B,
+	0x04,
+	0xE5,
+	0x5A,
+	0x54,
+	0xE0,
+	0x64,
+	0x60,
+	0x70,
+	0x37,
+	0xE5,
+	0x5B,
+	0x7B,
+	0x06,
+	0x12,
+	0x15,
+	0xC3,
+	0x40,
+	0x01,
+	0x22,
+	0xE5,
+	0x5E,
+	0x04,
+	0xF8,
+	0xE6,
+	0x64,
+	0x03,
+	0x70,
+	0x24,
+	0xE5,
+	0x5E,
+	0x24,
+	0x02,
+	0xF8,
+	0xE6,
+	0x64,
+	0x0C,
+	0x70,
+	0x1A,
+	0xE5,
+	0x5E,
+	0x24,
+	0x03,
+	0xF8,
+	0xE6,
+	0x70,
+	0x12,
+	0xE5,
+	0x5E,
+	0x24,
+	0x04,
+	0xF8,
+	0xE6,
+	0xF5,
+	0x28,
+	0xE5,
+	0x5E,
+	0x24,
+	0x05,
+	0xF8,
+	0xE6,
+	0xF5,
+	0x29,
+	0xD2,
+	0x01,
+	0xE5,
+	0x5A,
+	0x54,
+	0xE0,
+	0x64,
+	0x40,
+	0x70,
+	0x59,
+	0xE5,
+	0x5A,
+	0x54,
+	0x1F,
+	0xF5,
+	0x60,
+	0xE5,
+	0x5B,
+	0x25,
+	0x5F,
+	0x04,
+	0xFD,
+	0xAB,
+	0x60,
+	0xAF,
+	0x5C,
+	0x12,
+	0x15,
+	0xC8,
+	0x50,
+	0x64,
+	0xE4,
+	0xF5,
+	0x61,
+	0xE5,
+	0x61,
+	0xC3,
+	0x95,
+	0x60,
+	0x50,
+	0x3A,
+	0xE4,
+	0xF5,
+	0x62,
+	0xE5,
+	0x5E,
+	0x25,
+	0x61,
+	0xF8,
+	0xE6,
+	0x54,
+	0x7F,
+	0xFF,
+	0xE5,
+	0x62,
+	0x25,
+	0xE0,
+	0x24,
+	0xEE,
+	0xF5,
+	0x82,
+	0xE4,
+	0x34,
+	0x10,
+	0xF5,
+	0x83,
+	0xE4,
+	0x93,
+	0xB5,
+	0x07,
+	0x11,
+	0xE5,
+	0x62,
+	0x25,
+	0xE0,
+	0x24,
+	0xEF,
+	0xF5,
+	0x82,
+	0xE4,
+	0x34,
+	0x10,
+	0xF5,
+	0x83,
+	0xE4,
+	0x93,
+	0x42,
+	0x27,
+	0x05,
+	0x62,
+	0xE5,
+	0x62,
+	0xB4,
+	0x0A,
+	0xCD,
+	0x05,
+	0x61,
+	0x80,
+	0xBF,
+	0xE5,
+	0x5A,
+	0x54,
+	0x1F,
+	0x25,
+	0x5B,
+	0x04,
+	0xF5,
+	0x5B,
+	0x7B,
+	0x01,
+	0x12,
+	0x15,
+	0xC3,
+	0x40,
+	0x01,
+	0x22,
+	0xA8,
+	0x5E,
+	0xE6,
+	0xF5,
+	0x5A,
+	0xE5,
+	0x5B,
+	0xC3,
+	0x95,
+	0x59,
+	0x50,
+	0x03,
+	0x02,
+	0x0A,
+	0x02,
+	0x05,
+	0x5D,
+	0x02,
+	0x09,
+	0xA1,
+	0xA2,
+	0x01,
+	0x22,
+	0xE4,
+	0xF5,
+	0xA8,
+	0xF5,
+	0xA0,
+	0x75,
+	0x90,
+	0xC0,
+	0xD2,
+	0x8A,
+	0xD2,
+	0x88,
+	0xD2,
+	0xA8,
+	0xD2,
+	0xB8,
+	0x7D,
+	0x40,
+	0x7F,
+	0x4F,
+	0x12,
+	0x11,
+	0xAB,
+	0xC2,
+	0x15,
+	0xC2,
+	0x08,
+	0xC2,
+	0x0B,
+	0xC2,
+	0x0E,
+	0xC2,
+	0x02,
+	0xC2,
+	0x13,
+	0xC2,
+	0x06,
+	0xC2,
+	0x17,
+	0xC2,
+	0x03,
+	0xE4,
+	0xF5,
+	0x55,
+	0xD2,
+	0x10,
+	0xD2,
+	0x00,
+	0xD2,
+	0x0F,
+	0xD2,
+	0x14,
+	0xC2,
+	0x09,
+	0xC2,
+	0x0C,
+	0xC2,
+	0x11,
+	0x7E,
+	0x10,
+	0x7F,
+	0xC9,
+	0x12,
+	0x11,
+	0xD2,
+	0x7F,
+	0x0A,
+	0x12,
+	0x19,
+	0xEF,
+	0x12,
+	0x12,
+	0x0E,
+	0x7D,
+	0x06,
+	0x7F,
+	0x0A,
+	0x7E,
+	0x00,
+	0x12,
+	0x18,
+	0xB5,
+	0xE5,
+	0x30,
+	0x25,
+	0xE0,
+	0x25,
+	0xE0,
+	0x54,
+	0xF8,
+	0xFF,
+	0xE5,
+	0x2F,
+	0xC4,
+	0x13,
+	0x54,
+	0x07,
+	0x2F,
+	0xF5,
+	0x43,
+	0xE5,
+	0x2F,
+	0x33,
+	0x33,
+	0x33,
+	0x54,
+	0xF0,
+	0xFF,
+	0xE5,
+	0x2E,
+	0xC4,
+	0x54,
+	0x0F,
+	0x2F,
+	0xF5,
+	0x42,
+	0xE5,
+	0x2E,
+	0xC4,
+	0x54,
+	0xE0,
+	0xFF,
+	0xE5,
+	0x2D,
+	0x13,
+	0x13,
+	0x13,
+	0x54,
+	0x1F,
+	0x2F,
+	0xF5,
+	0x41,
+	0xE5,
+	0x2D,
+	0xC4,
+	0x33,
+	0x54,
+	0xC0,
+	0xFF,
+	0xE5,
+	0x2C,
+	0x13,
+	0x13,
+	0x54,
+	0x3F,
+	0x2F,
+	0xF5,
+	0x40,
+	0xE5,
+	0x2C,
+	0xC4,
+	0x33,
+	0x33,
+	0x54,
+	0x80,
+	0xFF,
+	0xE5,
+	0x2B,
+	0xC3,
+	0x13,
+	0x2F,
+	0xF5,
+	0x3F,
+	0x20,
+	0x0E,
+	0x08,
+	0x7F,
+	0x3F,
+	0x12,
+	0x19,
+	0x0D,
+	0xB3,
+	0x92,
+	0x0E,
+	0x30,
+	0x0E,
+	0x05,
+	0x7F,
+	0x08,
+	0x12,
+	0x1A,
+	0x75,
+	0x75,
+	0x15,
+	0x19,
+	0x75,
+	0x16,
+	0x19,
+	0x75,
+	0x17,
+	0x0C,
+	0x12,
+	0x19,
+	0x61,
+	0x7F,
+	0x0A,
+	0x12,
+	0x19,
+	0xCD,
+	0xE5,
+	0x55,
+	0x24,
+	0xFF,
+	0x92,
+	0x09,
+	0x7D,
+	0xC0,
+	0x7F,
+	0x6E,
+	0x12,
+	0x11,
+	0xBD,
+	0xAF,
+	0x55,
+	0x12,
+	0x19,
+	0x39,
+	0xC2,
+	0x0A,
+	0x7D,
+	0x40,
+	0x7F,
+	0x4F,
+	0x12,
+	0x11,
+	0x96,
+	0x75,
+	0x25,
+	0x00,
+	0x75,
+	0x26,
+	0x01,
+	0xE4,
+	0xF5,
+	0x54,
+	0x12,
+	0x0F,
+	0x16,
+	0x30,
+	0x15,
+	0x05,
+	0x7F,
+	0xFF,
+	0x12,
+	0x14,
+	0xD3,
+	0x30,
+	0x0B,
+	0x30,
+	0x20,
+	0x08,
+	0x0C,
+	0x7F,
+	0x25,
+	0x12,
+	0x19,
+	0x8F,
+	0xEF,
+	0x30,
+	0xE4,
+	0x03,
+	0x12,
+	0x08,
+	0x74,
+	0x7B,
+	0x12,
+	0x7D,
+	0x36,
+	0x7C,
+	0x00,
+	0x7F,
+	0x50,
+	0x12,
+	0x17,
+	0x8F,
+	0x92,
+	0x18,
+	0x85,
+	0x3C,
+	0x37,
+	0x85,
+	0x27,
+	0x38,
+	0x85,
+	0x2A,
+	0x39,
+	0xA2,
+	0x18,
+	0x92,
+	0x1B,
+	0x7F,
+	0x0F,
+	0x12,
+	0x17,
+	0x51,
+	0xC2,
+	0x0B,
+	0xE5,
+	0x16,
+	0x60,
+	0x03,
+	0x02,
+	0x0C,
+	0x80,
+	0x30,
+	0x03,
+	0x2F,
+	0xC2,
+	0xA8,
+	0x7F,
+	0x0A,
+	0x12,
+	0x19,
+	0xCD,
+	0xC2,
+	0x03,
+	0x30,
+	0x09,
+	0x0E,
+	0xE5,
+	0x55,
+	0x60,
+	0x06,
+	0xD2,
+	0x02,
+	0xD2,
+	0x07,
+	0x80,
+	0x0C,
+	0xAF,
+	0x55,
+	0x80,
+	0x05,
+	0xE5,
+	0x55,
+	0x60,
+	0x04,
+	0xFF,
+	0x12,
+	0x19,
+	0x39,
+	0xE5,
+	0x55,
+	0x24,
+	0xFF,
+	0x92,
+	0x09,
+	0x75,
+	0x16,
+	0x19,
+	0xD2,
+	0xA8,
+	0x80,
+	0x54,
+	0x20,
+	0x11,
+	0x1A,
+	0x30,
+	0x09,
+	0x09,
+	0x7F,
+	0x09,
+	0x12,
+	0x19,
+	0x87,
+	0xEF,
+	0x13,
+	0x92,
+	0x0F,
+	0xD2,
+	0x14,
+	0x7F,
+	0x08,
+	0x12,
+	0x19,
+	0x87,
+	0xEF,
+	0x54,
+	0x0E,
+	0x70,
+	0x02,
+	0xC2,
+	0x14,
+	0xE5,
+	0x55,
+	0x60,
+	0x22,
+	0x7F,
+	0x09,
+	0x12,
+	0x19,
+	0x87,
+	0xEF,
+	0x20,
+	0xE0,
+	0x19,
+	0x7F,
+	0x0A,
+	0x12,
+	0x19,
+	0x87,
+	0xEF,
+	0x30,
+	0xE2,
+	0x10,
+	0x7D,
+	0x04,
+	0x7F,
+	0x5C,
+	0x12,
+	0x11,
+	0xB7,
+	0x7D,
+	0x01,
+	0x7F,
+	0x07,
+	0x12,
+	0x11,
+	0x96,
+	0x80,
+	0x0E,
+	0x7D,
+	0x04,
+	0x7F,
+	0x5C,
+	0x12,
+	0x11,
+	0xA2,
+	0x7D,
+	0x01,
+	0x7F,
+	0x07,
+	0x12,
+	0x11,
+	0xAB,
+	0x75,
+	0x16,
+	0x4B,
+	0x30,
+	0x02,
+	0x30,
+	0x20,
+	0x0E,
+	0x2D,
+	0x30,
+	0x07,
+	0x2C,
+	0xC2,
+	0x07,
+	0xC2,
+	0x06,
+	0xC2,
+	0x13,
+	0xE4,
+	0xF5,
+	0x57,
+	0x74,
+	0x44,
+	0x25,
+	0x57,
+	0xF8,
+	0xE4,
+	0xF6,
+	0x05,
+	0x57,
+	0xE5,
+	0x57,
+	0xB4,
+	0x05,
+	0xF2,
+	0x12,
+	0x05,
+	0xC6,
+	0x50,
+	0x10,
+	0x12,
+	0x00,
+	0x0E,
+	0x50,
+	0x0B,
+	0x12,
+	0x18,
+	0x57,
+	0x50,
+	0x06,
+	0xC2,
+	0x02,
+	0x80,
+	0x02,
+	0xC2,
+	0x02,
+	0x30,
+	0x13,
+	0x09,
+	0x12,
+	0x14,
+	0x58,
+	0x40,
+	0x04,
+	0xD2,
+	0x02,
+	0xD2,
+	0x07,
+	0xE5,
+	0x17,
+	0x70,
+	0x2C,
+	0x7F,
+	0x7F,
+	0x12,
+	0x19,
+	0x93,
+	0xEF,
+	0x54,
+	0x04,
+	0xF5,
+	0x57,
+	0x65,
+	0x49,
+	0x60,
+	0x1B,
+	0x85,
+	0x49,
+	0x57,
+	0x7F,
+	0x0A,
+	0x12,
+	0x19,
+	0xEF,
+	0xE5,
+	0x49,
+	0x65,
+	0x57,
+	0x60,
+	0x0D,
+	0xE5,
+	0x49,
+	0x70,
+	0x03,
+	0xD3,
+	0x80,
+	0x01,
+	0xC3,
+	0x92,
+	0x19,
+	0x12,
+	0x18,
+	0x87,
+	0x75,
+	0x17,
+	0x19,
+	0x05,
+	0x26,
+	0xE5,
+	0x26,
+	0xAE,
+	0x25,
+	0x70,
+	0x02,
+	0x05,
+	0x25,
+	0x14,
+	0x4E,
+	0x60,
+	0x03,
+	0x02,
+	0x0B,
+	0xB5,
+	0x75,
+	0x13,
+	0x07,
+	0x75,
+	0x14,
+	0xD0,
+	0x05,
+	0x54,
+	0xE5,
+	0x54,
+	0x20,
+	0xE0,
+	0x03,
+	0x02,
+	0x0B,
+	0xB5,
+	0x02,
+	0x0B,
+	0xB5,
+	0x02,
+	0x0E,
+	0x69,
+	0xEC,
+	0x5D,
+	0x04,
+	0x60,
+	0x05,
+	0xE8,
+	0x59,
+	0x04,
+	0x70,
+	0x03,
+	0x02,
+	0x0E,
+	0x5F,
+	0x12,
+	0x0E,
+	0x2A,
+	0x58,
+	0x04,
+	0x60,
+	0xF6,
+	0xEC,
+	0x48,
+	0x60,
+	0xF2,
+	0xEC,
+	0x70,
+	0x04,
+	0xFD,
+	0xFE,
+	0xFF,
+	0x22,
+	0xC8,
+	0x60,
+	0xDB,
+	0x24,
+	0x81,
+	0xC8,
+	0x50,
+	0x09,
+	0xC3,
+	0x98,
+	0x60,
+	0x02,
+	0x50,
+	0x06,
+	0x02,
+	0x0E,
+	0x66,
+	0x98,
+	0x50,
+	0xCA,
+	0xF5,
+	0x82,
+	0xE9,
+	0x29,
+	0x4B,
+	0x4A,
+	0x70,
+	0x05,
+	0xAB,
+	0x82,
+	0x02,
+	0x0E,
+	0x55,
+	0x75,
+	0xF0,
+	0x00,
+	0x7C,
+	0x1A,
+	0x78,
+	0x80,
+	0xC3,
+	0xEF,
+	0x9B,
+	0xEE,
+	0x9A,
+	0xED,
+	0x99,
+	0x40,
+	0x0D,
+	0xC3,
+	0xEF,
+	0x9B,
+	0xFF,
+	0xEE,
+	0x9A,
+	0xFE,
+	0xED,
+	0x99,
+	0xFD,
+	0xE8,
+	0x42,
+	0xF0,
+	0xDC,
+	0x23,
+	0xAC,
+	0xF0,
+	0xD0,
+	0xE0,
+	0xFF,
+	0xD0,
+	0xE0,
+	0xFE,
+	0xD0,
+	0xE0,
+	0xFD,
+	0xAB,
+	0x82,
+	0x20,
+	0xE7,
+	0x10,
+	0x1B,
+	0xEB,
+	0x60,
+	0xBA,
+	0xEC,
+	0x2C,
+	0xFC,
+	0xEF,
+	0x33,
+	0xFF,
+	0xEE,
+	0x33,
+	0xFE,
+	0xED,
+	0x33,
+	0xFD,
+	0x02,
+	0x0E,
+	0x41,
+	0xE8,
+	0x03,
+	0xF8,
+	0x30,
+	0xE7,
+	0x05,
+	0xC0,
+	0xF0,
+	0x75,
+	0xF0,
+	0x00,
+	0xEF,
+	0x2F,
+	0xFF,
+	0xEE,
+	0x33,
+	0xFE,
+	0xED,
+	0x33,
+	0xFD,
+	0x40,
+	0xB8,
+	0x30,
+	0xE7,
+	0xC2,
+	0x80,
+	0xAA,
+	0x75,
+	0xF0,
+	0x20,
+	0x80,
+	0x0E,
+	0x75,
+	0xF0,
+	0x10,
+	0x80,
+	0x05,
+	0x75,
+	0xF0,
+	0x08,
+	0x7D,
+	0x00,
+	0x7E,
+	0x00,
+	0x7F,
+	0x00,
+	0x33,
+	0x92,
+	0xD5,
+	0x30,
+	0xD5,
+	0x03,
+	0x12,
+	0x0E,
+	0x93,
+	0xEC,
+	0x33,
+	0x40,
+	0x10,
+	0xEF,
+	0x33,
+	0xFF,
+	0xEE,
+	0x33,
+	0xFE,
+	0xED,
+	0x33,
+	0xFD,
+	0xEC,
+	0x33,
+	0xFC,
+	0xD5,
+	0xF0,
+	0xED,
+	0x22,
+	0xE5,
+	0xF0,
+	0x24,
+	0x7E,
+	0xA2,
+	0xD5,
+	0x13,
+	0xCC,
+	0x92,
+	0xE7,
+	0xCD,
+	0xCE,
+	0xFF,
+	0x22,
+	0xED,
+	0xD2,
+	0xE7,
+	0xCD,
+	0x33,
+	0xEC,
+	0x33,
+	0x92,
+	0xD5,
+	0x24,
+	0x81,
+	0x40,
+	0x06,
+	0xE4,
+	0xFF,
+	0xFE,
+	0xFD,
+	0xFC,
+	0x22,
+	0xFC,
+	0xE4,
+	0xCF,
+	0xCE,
+	0xCD,
+	0xCC,
+	0x24,
+	0xE0,
+	0x50,
+	0x11,
+	0x74,
+	0xFF,
+	0x80,
+	0xED,
+	0xC3,
+	0xCC,
+	0x13,
+	0xCC,
+	0xCD,
+	0x13,
+	0xCD,
+	0xCE,
+	0x13,
+	0xCE,
+	0xCF,
+	0x13,
+	0xCF,
+	0x04,
+	0x70,
+	0xF0,
+	0x30,
+	0xD5,
+	0xDE,
+	0x02,
+	0x0E,
+	0x93,
+	0xE9,
+	0xD2,
+	0xE7,
+	0xC9,
+	0x33,
+	0xE8,
+	0x33,
+	0xF8,
+	0x92,
+	0xD5,
+	0xED,
+	0xD2,
+	0xE7,
+	0xCD,
+	0x33,
+	0xEC,
+	0x33,
+	0xFC,
+	0x50,
+	0x02,
+	0xB2,
+	0xD5,
+	0x22,
+	0xEC,
+	0x30,
+	0xE7,
+	0x10,
+	0x0F,
+	0xBF,
+	0x00,
+	0x0C,
+	0x0E,
+	0xBE,
+	0x00,
+	0x08,
+	0x0D,
+	0xBD,
+	0x00,
+	0x04,
+	0x0B,
+	0xEB,
+	0x60,
+	0x14,
+	0xA2,
+	0xD5,
+	0xEB,
+	0x13,
+	0xFC,
+	0xED,
+	0x92,
+	0xE7,
+	0xFD,
+	0x22,
+	0x74,
+	0xFF,
+	0xFC,
+	0xFD,
+	0xFE,
+	0xFF,
+	0x22,
+	0xE4,
+	0x80,
+	0xF8,
+	0xA2,
+	0xD5,
+	0x74,
+	0xFF,
+	0x13,
+	0xFC,
+	0x7D,
+	0x80,
+	0xE4,
+	0x80,
+	0xEF,
+	0xEF,
+	0x8D,
+	0xF0,
+	0xA4,
+	0xA8,
+	0xF0,
+	0xCF,
+	0x8C,
+	0xF0,
+	0xA4,
+	0x28,
+	0xCE,
+	0x8D,
+	0xF0,
+	0xA4,
+	0x2E,
+	0xFE,
+	0x22,
+	0xCF,
+	0xF4,
+	0xCF,
+	0xCE,
+	0xF4,
+	0xCE,
+	0xCD,
+	0xF4,
+	0xCD,
+	0xCC,
+	0xF4,
+	0xCC,
+	0x22,
+	0xC3,
+	0xE4,
+	0x9F,
+	0xFF,
+	0xE4,
+	0x9E,
+	0xFE,
+	0xE4,
+	0x9D,
+	0xFD,
+	0xE4,
+	0x9C,
+	0xFC,
+	0x22,
+	0xEB,
+	0x9F,
+	0xF5,
+	0xF0,
+	0xEA,
+	0x9E,
+	0x42,
+	0xF0,
+	0xE9,
+	0x9D,
+	0x42,
+	0xF0,
+	0xE8,
+	0x9C,
+	0x45,
+	0xF0,
+	0x22,
+	0xE8,
+	0x60,
+	0x0F,
+	0xEC,
+	0xC3,
+	0x13,
+	0xFC,
+	0xED,
+	0x13,
+	0xFD,
+	0xEE,
+	0x13,
+	0xFE,
+	0xEF,
+	0x13,
+	0xFF,
+	0xD8,
+	0xF1,
+	0x22,
+	0xE8,
+	0x60,
+	0x0F,
+	0xEF,
+	0xC3,
+	0x33,
+	0xFF,
+	0xEE,
+	0x33,
+	0xFE,
+	0xED,
+	0x33,
+	0xFD,
+	0xEC,
+	0x33,
+	0xFC,
+	0xD8,
+	0xF1,
+	0x22,
+	0xE6,
+	0xFC,
+	0x08,
+	0xE6,
+	0xFD,
+	0x08,
+	0xE6,
+	0xFE,
+	0x08,
+	0xE6,
+	0xFF,
+	0x22,
+	0xE6,
+	0xFB,
+	0x08,
+	0xE6,
+	0xF9,
+	0x08,
+	0xE6,
+	0xFA,
+	0x08,
+	0xE6,
+	0xCB,
+	0xF8,
+	0x22,
+	0xEC,
+	0xF6,
+	0x08,
+	0xED,
+	0xF6,
+	0x08,
+	0xEE,
+	0xF6,
+	0x08,
+	0xEF,
+	0xF6,
+	0x22,
+	0xD0,
+	0x83,
+	0xD0,
+	0x82,
+	0xE4,
+	0x93,
+	0xF6,
+	0x08,
+	0x74,
+	0x01,
+	0x93,
+	0xF6,
+	0x08,
+	0x74,
+	0x02,
+	0x93,
+	0xF6,
+	0x08,
+	0x74,
+	0x03,
+	0x93,
+	0xF6,
+	0x74,
+	0x04,
+	0x73,
+	0xD2,
+	0x19,
+	0xD2,
+	0x1A,
+	0x30,
+	0x0A,
+	0x03,
+	0x02,
+	0x10,
+	0xAF,
+	0x7F,
+	0x4F,
+	0x12,
+	0x19,
+	0x87,
+	0x8F,
+	0x58,
+	0xE5,
+	0x58,
+	0x20,
+	0xE6,
+	0x03,
+	0x02,
+	0x10,
+	0xAF,
+	0xD2,
+	0x0A,
+	0x53,
+	0x58,
+	0x3F,
+	0xE5,
+	0x58,
+	0x24,
+	0xED,
+	0x70,
+	0x03,
+	0x02,
+	0x10,
+	0x01,
+	0x24,
+	0xF4,
+	0x70,
+	0x03,
+	0x02,
+	0x10,
+	0x63,
+	0x24,
+	0x1E,
+	0xB4,
+	0x06,
+	0x00,
+	0x40,
+	0x03,
+	0x02,
+	0x10,
+	0x9E,
+	0x90,
+	0x0F,
+	0x5C,
+	0x75,
+	0xF0,
+	0x03,
+	0xA4,
+	0xC5,
+	0x83,
+	0x25,
+	0xF0,
+	0xC5,
+	0x83,
+	0x73,
+	0x02,
+	0x0F,
+	0x6E,
+	0x02,
+	0x0F,
+	0x75,
+	0x02,
+	0x0F,
+	0xDB,
+	0x02,
+	0x10,
+	0x9E,
+	0x02,
+	0x0F,
+	0xB2,
+	0x02,
+	0x0F,
+	0xE2,
+	0xD2,
+	0x15,
+	0xC2,
+	0x19,
+	0x02,
+	0x10,
+	0xA3,
+	0xE4,
+	0xF5,
+	0x59,
+	0x74,
+	0x3F,
+	0x25,
+	0x59,
+	0xF8,
+	0xE6,
+	0xFF,
+	0x74,
+	0x2B,
+	0x25,
+	0x59,
+	0xF8,
+	0xA6,
+	0x07,
+	0x05,
+	0x59,
+	0xE5,
+	0x59,
+	0xB4,
+	0x05,
+	0xEB,
+	0xE4,
+	0xF5,
+	0x59,
+	0x74,
+	0x44,
+	0x25,
+	0x59,
+	0xF8,
+	0xE6,
+	0xFF,
+	0x74,
+	0x30,
+	0x25,
+	0x59,
+	0xF8,
+	0xA6,
+	0x07,
+	0x05,
+	0x59,
+	0xE5,
+	0x59,
+	0xB4,
+	0x05,
+	0xEB,
+	0x7F,
+	0x53,
+	0x12,
+	0x19,
+	0x93,
+	0x8F,
+	0x35,
+	0x75,
+	0x58,
+	0x0B,
+	0x02,
+	0x10,
+	0xA3,
+	0x7F,
+	0x23,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x2B,
+	0x7F,
+	0x24,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x2C,
+	0x7F,
+	0x6F,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x2D,
+	0x7F,
+	0x70,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x2E,
+	0x7F,
+	0x53,
+	0x12,
+	0x19,
+	0x93,
+	0x8F,
+	0x2F,
+	0x75,
+	0x58,
+	0x05,
+	0x02,
+	0x10,
+	0xA3,
+	0xD2,
+	0x0B,
+	0xC2,
+	0x19,
+	0x02,
+	0x10,
+	0xA3,
+	0x30,
+	0x10,
+	0x04,
+	0x7F,
+	0x80,
+	0x80,
+	0x02,
+	0x7F,
+	0x00,
+	0x8F,
+	0x2B,
+	0x7F,
+	0x25,
+	0x12,
+	0x19,
+	0x8F,
+	0xEF,
+	0x30,
+	0xE4,
+	0x03,
+	0x43,
+	0x2B,
+	0x01,
+	0xC2,
+	0x10,
+	0x75,
+	0x58,
+	0x01,
+	0x02,
+	0x10,
+	0xA3,
+	0x7F,
+	0x50,
+	0x12,
+	0x19,
+	0x87,
+	0x8F,
+	0x59,
+	0xE4,
+	0xF5,
+	0x58,
+	0xE5,
+	0x59,
+	0xB4,
+	0x41,
+	0x16,
+	0x85,
+	0x8A,
+	0x2B,
+	0x85,
+	0x8C,
+	0x2C,
+	0xE5,
+	0x2B,
+	0x64,
+	0x63,
+	0xF5,
+	0x52,
+	0xE5,
+	0x2C,
+	0x65,
+	0x2B,
+	0x64,
+	0x68,
+	0xF5,
+	0x53,
+	0x80,
+	0x31,
+	0xE5,
+	0x59,
+	0x64,
+	0x42,
+	0x70,
+	0x30,
+	0x90,
+	0x10,
+	0xB2,
+	0x93,
+	0xFF,
+	0x12,
+	0x19,
+	0x8B,
+	0xEF,
+	0x65,
+	0x52,
+	0x70,
+	0x23,
+	0x90,
+	0x10,
+	0xB3,
+	0x93,
+	0xFF,
+	0x12,
+	0x19,
+	0x8B,
+	0xEF,
+	0xB5,
+	0x53,
+	0x17,
+	0xC2,
+	0x1B,
+	0x12,
+	0x19,
+	0xAA,
+	0xC2,
+	0x02,
+	0x85,
+	0x8A,
+	0x52,
+	0x85,
+	0x8C,
+	0x53,
+	0xE4,
+	0xF5,
+	0x2B,
+	0xF5,
+	0x2C,
+	0x75,
+	0x58,
+	0x02,
+	0x80,
+	0x47,
+	0x20,
+	0x13,
+	0x44,
+	0xD2,
+	0x02,
+	0x80,
+	0x40,
+	0x75,
+	0x5A,
+	0x10,
+	0x75,
+	0x5B,
+	0xC2,
+	0xE4,
+	0xF5,
+	0x59,
+	0xE5,
+	0x5B,
+	0x25,
+	0x59,
+	0xF5,
+	0x82,
+	0xE4,
+	0x35,
+	0x5A,
+	0xF5,
+	0x83,
+	0xE4,
+	0x93,
+	0xFF,
+	0x74,
+	0x2B,
+	0x25,
+	0x59,
+	0xF8,
+	0xA6,
+	0x07,
+	0x05,
+	0x59,
+	0xE5,
+	0x59,
+	0xB4,
+	0x07,
+	0xE4,
+	0x7F,
+	0x50,
+	0x12,
+	0x19,
+	0x93,
+	0x8F,
+	0x2E,
+	0x7F,
+	0x51,
+	0x12,
+	0x19,
+	0x93,
+	0xEF,
+	0x54,
+	0x0F,
+	0xF5,
+	0x2F,
+	0x75,
+	0x58,
+	0x07,
+	0x80,
+	0x05,
+	0xE4,
+	0xF5,
+	0x58,
+	0xC2,
+	0x1A,
+	0x30,
+	0x19,
+	0x09,
+	0xA2,
+	0x1A,
+	0x92,
+	0x1B,
+	0xAF,
+	0x58,
+	0x12,
+	0x17,
+	0x51,
+	0xA2,
+	0x0A,
+	0x22,
+	0x26,
+	0x27,
+	0x42,
+	0x43,
+	0x44,
+	0x45,
+	0x46,
+	0x47,
+	0x6A,
+	0x51,
+	0x52,
+	0x53,
+	0x57,
+	0x58,
+	0x59,
+	0x5A,
+	0x07,
+	0x01,
+	0x2B,
+	0x00,
+	0x00,
+	0x03,
+	0x00,
+	0x14,
+	0x5A,
+	0x10,
+	0x20,
+	0x07,
+	0x10,
+	0x11,
+	0x0E,
+	0x80,
+	0x14,
+	0x59,
+	0xE0,
+	0x24,
+	0x59,
+	0x60,
+	0x10,
+	0x19,
+	0x04,
+	0x00,
+	0x1C,
+	0x69,
+	0x00,
+	0x1D,
+	0x78,
+	0x04,
+	0x76,
+	0x00,
+	0x04,
+	0x77,
+	0x20,
+	0x04,
+	0x75,
+	0x08,
+	0x14,
+	0x52,
+	0x10,
+	0xF0,
+	0x10,
+	0x80,
+	0x1F,
+	0x40,
+	0x04,
+	0x20,
+	0x13,
+	0x10,
+	0x05,
+	0x08,
+	0x14,
+	0x04,
+	0x03,
+	0x02,
+	0x02,
+	0x02,
+	0x12,
+	0x01,
+	0x11,
+	0x01,
+	0x00,
+	0x50,
+	0x00,
+	0x40,
+	0x04,
+	0x66,
+	0x50,
+	0x00,
+	0x30,
+	0x08,
+	0x40,
+	0x60,
+	0xB0,
+	0x40,
+	0x10,
+	0x20,
+	0x09,
+	0x01,
+	0x20,
+	0x08,
+	0xF0,
+	0x20,
+	0x07,
+	0x19,
+	0x21,
+	0x0D,
+	0x80,
+	0x21,
+	0x16,
+	0x01,
+	0xF0,
+	0x10,
+	0x08,
+	0x0E,
+	0x10,
+	0x09,
+	0x04,
+	0xF0,
+	0x20,
+	0x08,
+	0x0E,
+	0x20,
+	0x09,
+	0x04,
+	0xF0,
+	0x20,
+	0x09,
+	0x5D,
+	0x20,
+	0x08,
+	0xFE,
+	0x20,
+	0x07,
+	0x1D,
+	0x20,
+	0x0A,
+	0x20,
+	0x20,
+	0x07,
+	0x02,
+	0x24,
+	0x54,
+	0x10,
+	0x21,
+	0x11,
+	0x80,
+	0x10,
+	0x0A,
+	0x04,
+	0xF0,
+	0x11,
+	0x11,
+	0x80,
+	0x10,
+	0x07,
+	0x02,
+	0x14,
+	0x54,
+	0x10,
+	0x10,
+	0x07,
+	0x1D,
+	0x10,
+	0x0A,
+	0x20,
+	0x11,
+	0x16,
+	0x01,
+	0x11,
+	0x0D,
+	0x80,
+	0x10,
+	0x08,
+	0xF0,
+	0x10,
+	0x09,
+	0x5D,
+	0x14,
+	0x52,
+	0x01,
+	0x24,
+	0x52,
+	0x01,
+	0xF0,
+	0x7B,
+	0x00,
+	0x80,
+	0x0A,
+	0x7B,
+	0x01,
+	0x80,
+	0x06,
+	0x7B,
+	0x03,
+	0x80,
+	0x02,
+	0x7B,
+	0x04,
+	0x7C,
+	0x00,
+	0x80,
+	0x00,
+	0x12,
+	0x11,
+	0x8A,
+	0xE2,
+	0x5C,
+	0x4D,
+	0xF2,
+	0x78,
+	0x03,
+	0xEB,
+	0xF2,
+	0xD2,
+	0xAF,
+	0x22,
+	0xC2,
+	0xAF,
+	0x78,
+	0x83,
+	0xE2,
+	0xCB,
+	0xF2,
+	0x74,
+	0x80,
+	0x2F,
+	0xF8,
+	0x22,
+	0x7B,
+	0x00,
+	0x80,
+	0x0A,
+	0x7B,
+	0x01,
+	0x80,
+	0x06,
+	0x7B,
+	0x03,
+	0x80,
+	0x02,
+	0x7B,
+	0x04,
+	0xED,
+	0xF4,
+	0xFC,
+	0x7D,
+	0x00,
+	0x80,
+	0xD1,
+	0x7B,
+	0x00,
+	0x80,
+	0x0A,
+	0x7B,
+	0x01,
+	0x80,
+	0x06,
+	0x7B,
+	0x03,
+	0x80,
+	0x02,
+	0x7B,
+	0x04,
+	0x7C,
+	0xFF,
+	0x80,
+	0xBF,
+	0x7B,
+	0x03,
+	0x80,
+	0x02,
+	0x7B,
+	0x04,
+	0x12,
+	0x11,
+	0x8A,
+	0xED,
+	0xF4,
+	0xFF,
+	0xE2,
+	0x5F,
+	0xF2,
+	0x4D,
+	0xF2,
+	0x5F,
+	0xF2,
+	0x80,
+	0xB1,
+	0x8E,
+	0x83,
+	0x8F,
+	0x82,
+	0xE4,
+	0x93,
+	0xA3,
+	0xFB,
+	0x54,
+	0x0F,
+	0xCB,
+	0x54,
+	0xF0,
+	0xB4,
+	0xF0,
+	0x01,
+	0x22,
+	0xFD,
+	0xE4,
+	0x93,
+	0xA3,
+	0xFF,
+	0xE4,
+	0x93,
+	0xA3,
+	0xCD,
+	0xB4,
+	0x00,
+	0x05,
+	0x12,
+	0x11,
+	0x78,
+	0x80,
+	0xE2,
+	0xB4,
+	0x10,
+	0x05,
+	0x12,
+	0x11,
+	0xA4,
+	0x80,
+	0xDA,
+	0xB4,
+	0x20,
+	0x05,
+	0x12,
+	0x11,
+	0xB9,
+	0x80,
+	0xD2,
+	0xB4,
+	0x30,
+	0x05,
+	0x12,
+	0x11,
+	0xC3,
+	0x80,
+	0xCA,
+	0x80,
+	0xC8,
+	0xC2,
+	0x96,
+	0xD2,
+	0x97,
+	0xD2,
+	0x96,
+	0x22,
+	0x22,
+	0xC2,
+	0x97,
+	0xD2,
+	0x96,
+	0x74,
+	0x28,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xD2,
+	0x97,
+	0x74,
+	0x1E,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0x22,
+	0xC2,
+	0x97,
+	0xD2,
+	0x97,
+	0x74,
+	0x1E,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xD2,
+	0x96,
+	0x74,
+	0x28,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0x22,
+	0xD2,
+	0x97,
+	0xD2,
+	0x96,
+	0x74,
+	0x28,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xC2,
+	0x97,
+	0x74,
+	0x1E,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xC2,
+	0x96,
+	0x74,
+	0x1E,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0x22,
+	0xEF,
+	0x7E,
+	0x08,
+	0x33,
+	0xC0,
+	0xE0,
+	0x40,
+	0x04,
+	0xC2,
+	0x97,
+	0x80,
+	0x02,
+	0xD2,
+	0x97,
+	0x74,
+	0x11,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xD2,
+	0x96,
+	0x74,
+	0x11,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xC2,
+	0x96,
+	0x74,
+	0x11,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xD0,
+	0xE0,
+	0xDE,
+	0xD8,
+	0xD2,
+	0x97,
+	0x74,
+	0x11,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xD2,
+	0x96,
+	0x74,
+	0x11,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xA2,
+	0x97,
+	0xE4,
+	0x92,
+	0xE0,
+	0xFE,
+	0xC2,
+	0x96,
+	0x74,
+	0x11,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xEE,
+	0x22,
+	0x8F,
+	0x6C,
+	0x8D,
+	0x6D,
+	0x7F,
+	0x5A,
+	0x12,
+	0x19,
+	0x93,
+	0xEF,
+	0x54,
+	0x80,
+	0xF5,
+	0x70,
+	0xE5,
+	0x6C,
+	0xB4,
+	0x01,
+	0x04,
+	0x7F,
+	0x40,
+	0x80,
+	0x02,
+	0x7F,
+	0x00,
+	0x8F,
+	0x6E,
+	0x43,
+	0x6E,
+	0x80,
+	0xAD,
+	0x6E,
+	0x7F,
+	0x0A,
+	0x12,
+	0x11,
+	0x76,
+	0xE5,
+	0x6E,
+	0x44,
+	0x20,
+	0xFD,
+	0x7F,
+	0x0A,
+	0x12,
+	0x11,
+	0x76,
+	0xAD,
+	0x6E,
+	0x7F,
+	0x0A,
+	0x12,
+	0x11,
+	0x76,
+	0x7F,
+	0x0E,
+	0x12,
+	0x19,
+	0x93,
+	0xEF,
+	0x20,
+	0xE7,
+	0x4E,
+	0x7F,
+	0x5A,
+	0x12,
+	0x19,
+	0x93,
+	0xEF,
+	0x54,
+	0x80,
+	0x65,
+	0x70,
+	0x60,
+	0x03,
+	0x7F,
+	0xFF,
+	0x22,
+	0x7F,
+	0x0E,
+	0x12,
+	0x19,
+	0x93,
+	0xEF,
+	0x30,
+	0xE6,
+	0x03,
+	0x7F,
+	0x01,
+	0x22,
+	0x85,
+	0x6E,
+	0x6F,
+	0x7F,
+	0x0C,
+	0x12,
+	0x19,
+	0x93,
+	0x8F,
+	0x6E,
+	0xE5,
+	0x6F,
+	0x65,
+	0x6E,
+	0x60,
+	0x04,
+	0x7F,
+	0x01,
+	0x80,
+	0x02,
+	0x7F,
+	0x00,
+	0xE5,
+	0x6E,
+	0x60,
+	0x04,
+	0x7E,
+	0x01,
+	0x80,
+	0x02,
+	0x7E,
+	0x00,
+	0xEE,
+	0x5F,
+	0x60,
+	0xB8,
+	0x7F,
+	0x0D,
+	0x12,
+	0x19,
+	0x93,
+	0xE5,
+	0x6E,
+	0x14,
+	0x25,
+	0x6D,
+	0xF8,
+	0xA6,
+	0x07,
+	0x80,
+	0xA9,
+	0x7F,
+	0x00,
+	0x22,
+	0x8F,
+	0x63,
+	0x7F,
+	0x5A,
+	0x12,
+	0x19,
+	0x93,
+	0xEF,
+	0x54,
+	0x80,
+	0xF5,
+	0x66,
+	0xE5,
+	0x63,
+	0xB4,
+	0x01,
+	0x04,
+	0x7F,
+	0x40,
+	0x80,
+	0x02,
+	0x7F,
+	0x00,
+	0x8F,
+	0x64,
+	0xAD,
+	0x4A,
+	0x7F,
+	0x09,
+	0x12,
+	0x11,
+	0x76,
+	0xAD,
+	0x64,
+	0x7F,
+	0x0A,
+	0x12,
+	0x11,
+	0x76,
+	0xE5,
+	0x64,
+	0x44,
+	0x20,
+	0xFD,
+	0x7F,
+	0x0A,
+	0x12,
+	0x11,
+	0x76,
+	0xAD,
+	0x64,
+	0x7F,
+	0x0A,
+	0x80,
+	0x51,
+	0x7F,
+	0x0E,
+	0x12,
+	0x19,
+	0x93,
+	0xEF,
+	0x20,
+	0xE7,
+	0x4D,
+	0x7F,
+	0x5A,
+	0x12,
+	0x19,
+	0x93,
+	0xEF,
+	0x54,
+	0x80,
+	0x65,
+	0x66,
+	0x60,
+	0x03,
+	0x7F,
+	0xFF,
+	0x22,
+	0x7F,
+	0x0E,
+	0x12,
+	0x19,
+	0x93,
+	0xEF,
+	0x30,
+	0xE6,
+	0x03,
+	0x7F,
+	0x01,
+	0x22,
+	0x85,
+	0x64,
+	0x65,
+	0x7F,
+	0x0B,
+	0x12,
+	0x19,
+	0x93,
+	0x8F,
+	0x64,
+	0xE5,
+	0x65,
+	0x65,
+	0x64,
+	0x60,
+	0x04,
+	0x7F,
+	0x01,
+	0x80,
+	0x02,
+	0x7F,
+	0x00,
+	0xE5,
+	0x64,
+	0x60,
+	0x04,
+	0x7E,
+	0x01,
+	0x80,
+	0x02,
+	0x7E,
+	0x00,
+	0xEE,
+	0x5F,
+	0x60,
+	0xB8,
+	0x74,
+	0x4A,
+	0x25,
+	0x64,
+	0xF8,
+	0xE6,
+	0xFD,
+	0x7F,
+	0x09,
+	0x12,
+	0x11,
+	0x76,
+	0x80,
+	0xAA,
+	0x7F,
+	0x00,
+	0x22,
+	0x78,
+	0x7F,
+	0xE4,
+	0xF6,
+	0xD8,
+	0xFD,
+	0x75,
+	0x81,
+	0xD7,
+	0x02,
+	0x14,
+	0x13,
+	0x02,
+	0x0A,
+	0xCA,
+	0xE4,
+	0x93,
+	0xA3,
+	0xF8,
+	0xE4,
+	0x93,
+	0xA3,
+	0x40,
+	0x03,
+	0xF6,
+	0x80,
+	0x01,
+	0xF2,
+	0x08,
+	0xDF,
+	0xF4,
+	0x80,
+	0x29,
+	0xE4,
+	0x93,
+	0xA3,
+	0xF8,
+	0x54,
+	0x07,
+	0x24,
+	0x0C,
+	0xC8,
+	0xC3,
+	0x33,
+	0xC4,
+	0x54,
+	0x0F,
+	0x44,
+	0x20,
+	0xC8,
+	0x83,
+	0x40,
+	0x04,
+	0xF4,
+	0x56,
+	0x80,
+	0x01,
+	0x46,
+	0xF6,
+	0xDF,
+	0xE4,
+	0x80,
+	0x0B,
+	0x01,
+	0x02,
+	0x04,
+	0x08,
+	0x10,
+	0x20,
+	0x40,
+	0x80,
+	0x90,
+	0x00,
+	0x06,
+	0xE4,
+	0x7E,
+	0x01,
+	0x93,
+	0x60,
+	0xBC,
+	0xA3,
+	0xFF,
+	0x54,
+	0x3F,
+	0x30,
+	0xE5,
+	0x09,
+	0x54,
+	0x1F,
+	0xFE,
+	0xE4,
+	0x93,
+	0xA3,
+	0x60,
+	0x01,
+	0x0E,
+	0xCF,
+	0x54,
+	0xC0,
+	0x25,
+	0xE0,
+	0x60,
+	0xA8,
+	0x40,
+	0xB8,
+	0xE4,
+	0x93,
+	0xA3,
+	0xFA,
+	0xE4,
+	0x93,
+	0xA3,
+	0xF8,
+	0xE4,
+	0x93,
+	0xA3,
+	0xC8,
+	0xC5,
+	0x82,
+	0xC8,
+	0xCA,
+	0xC5,
+	0x83,
+	0xCA,
+	0xF0,
+	0xA3,
+	0xC8,
+	0xC5,
+	0x82,
+	0xC8,
+	0xCA,
+	0xC5,
+	0x83,
+	0xCA,
+	0xDF,
+	0xE9,
+	0xDE,
+	0xE7,
+	0x80,
+	0xBE,
+	0x30,
+	0x16,
+	0x76,
+	0xC2,
+	0x16,
+	0xE4,
+	0xF5,
+	0x5C,
+	0xE5,
+	0x5C,
+	0x70,
+	0x6D,
+	0x7F,
+	0x23,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x58,
+	0x7F,
+	0x24,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x59,
+	0x30,
+	0x13,
+	0x06,
+	0x12,
+	0x1A,
+	0x53,
+	0x40,
+	0x03,
+	0x22,
+	0xC3,
+	0x22,
+	0x7F,
+	0x23,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x5A,
+	0x7F,
+	0x24,
+	0x12,
+	0x19,
+	0x8F,
+	0x8F,
+	0x5B,
+	0xE5,
+	0x59,
+	0xB5,
+	0x5B,
+	0x04,
+	0x7F,
+	0x01,
+	0x80,
+	0x02,
+	0x7F,
+	0x00,
+	0xE5,
+	0x58,
+	0xB5,
+	0x5A,
+	0x04,
+	0x7E,
+	0x01,
+	0x80,
+	0x02,
+	0x7E,
+	0x00,
+	0xEE,
+	0x5F,
+	0x60,
+	0xBB,
+	0x75,
+	0x5C,
+	0x01,
+	0xE5,
+	0x2C,
+	0xB5,
+	0x5A,
+	0x04,
+	0x7F,
+	0x01,
+	0x80,
+	0x02,
+	0x7F,
+	0x00,
+	0xE5,
+	0x2B,
+	0xB5,
+	0x5B,
+	0x04,
+	0x7E,
+	0x01,
+	0x80,
+	0x02,
+	0x7E,
+	0x00,
+	0xEE,
+	0x5F,
+	0x60,
+	0x05,
+	0xE4,
+	0xF5,
+	0x24,
+	0x80,
+	0x99,
+	0x05,
+	0x24,
+	0xE5,
+	0x24,
+	0xD3,
+	0x94,
+	0x02,
+	0x40,
+	0x90,
+	0x22,
+	0xD3,
+	0x22,
+	0xAD,
+	0x07,
+	0x8D,
+	0x58,
+	0xBD,
+	0xFF,
+	0x07,
+	0x7F,
+	0x50,
+	0x12,
+	0x19,
+	0x87,
+	0xAD,
+	0x07,
+	0xED,
+	0x54,
+	0x80,
+	0xFF,
+	0x53,
+	0x05,
+	0x7F,
+	0xED,
+	0xC4,
+	0x54,
+	0x0F,
+	0xFE,
+	0xED,
+	0x54,
+	0x0F,
+	0xC4,
+	0x54,
+	0xF0,
+	0xFD,
+	0xEF,
+	0x4E,
+	0xFF,
+	0x7B,
+	0x10,
+	0x12,
+	0x15,
+	0xC8,
+	0x92,
+	0x19,
+	0xAD,
+	0x58,
+	0x7F,
+	0x74,
+	0xE4,
+	0xF5,
+	0x58,
+	0x30,
+	0x19,
+	0x08,
+	0xEF,
+	0x25,
+	0x58,
+	0xF8,
+	0xE6,
+	0xFE,
+	0x80,
+	0x02,
+	0x7E,
+	0x00,
+	0x74,
+	0x2B,
+	0x25,
+	0x58,
+	0xF8,
+	0xA6,
+	0x06,
+	0x05,
+	0x58,
+	0xE5,
+	0x58,
+	0xB4,
+	0x10,
+	0xE5,
+	0xED,
+	0xF4,
+	0x70,
+	0x25,
+	0xA2,
+	0x19,
+	0x92,
+	0x1B,
+	0x7F,
+	0x10,
+	0x12,
+	0x17,
+	0x51,
+	0xC2,
+	0x15,
+	0x7D,
+	0x40,
+	0x7F,
+	0x4F,
+	0x12,
+	0x11,
+	0x96,
+	0x30,
+	0x19,
+	0x09,
+	0x7D,
+	0x80,
+	0x7F,
+	0x50,
+	0x12,
+	0x11,
+	0x96,
+	0x80,
+	0x07,
+	0x7D,
+	0x40,
+	0x7F,
+	0x50,
+	0x12,
+	0x11,
+	0xAB,
+	0xA2,
+	0x19,
+	0x22,
+	0xC0,
+	0xE0,
+	0xC0,
+	0xD0,
+	0xC2,
+	0x8C,
+	0x75,
+	0x8A,
+	0x40,
+	0x75,
+	0x8C,
+	0x7C,
+	0xD2,
+	0x8C,
+	0x05,
+	0x18,
+	0xE5,
+	0x18,
+	0x70,
+	0x1F,
+	0x05,
+	0x10,
+	0xE5,
+	0x10,
+	0xD3,
+	0x94,
+	0x02,
+	0x40,
+	0x05,
+	0x75,
+	0x10,
+	0x00,
+	0xD2,
+	0x16,
+	0xE5,
+	0x10,
+	0xB4,
+	0x01,
+	0x03,
+	0xD3,
+	0x80,
+	0x01,
+	0xC3,
+	0x92,
+	0x07,
+	0xE5,
+	0x10,
+	0x70,
+	0x02,
+	0xD2,
+	0x06,
+	0xE5,
+	0x11,
+	0x60,
+	0x02,
+	0x15,
+	0x11,
+	0xE5,
+	0x12,
+	0x60,
+	0x02,
+	0x15,
+	0x12,
+	0xE5,
+	0x15,
+	0x60,
+	0x02,
+	0x15,
+	0x15,
+	0xE5,
+	0x16,
+	0x60,
+	0x02,
+	0x15,
+	0x16,
+	0xE5,
+	0x17,
+	0x60,
+	0x02,
+	0x15,
+	0x17,
+	0xE5,
+	0x14,
+	0x45,
+	0x13,
+	0x60,
+	0x0A,
+	0xE5,
+	0x14,
+	0x15,
+	0x14,
+	0x70,
+	0x0C,
+	0x15,
+	0x13,
+	0x80,
+	0x08,
+	0xC2,
+	0xAF,
+	0x12,
+	0x19,
+	0xA9,
+	0x02,
+	0x00,
+	0x00,
+	0x74,
+	0x81,
+	0xB5,
+	0x81,
+	0x00,
+	0x40,
+	0x02,
+	0x80,
+	0xEF,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xE0,
+	0x32,
+	0x25,
+	0x5F,
+	0xFD,
+	0xAF,
+	0x5C,
+	0x8F,
+	0x67,
+	0x8D,
+	0x68,
+	0x8B,
+	0x69,
+	0x75,
+	0x6A,
+	0x03,
+	0xE5,
+	0x67,
+	0x30,
+	0xE7,
+	0x04,
+	0x7F,
+	0x01,
+	0x80,
+	0x02,
+	0x7F,
+	0x00,
+	0x8F,
+	0x6B,
+	0x53,
+	0x67,
+	0x7F,
+	0xAF,
+	0x6A,
+	0x15,
+	0x6A,
+	0xEF,
+	0x60,
+	0x4C,
+	0xE5,
+	0x6B,
+	0x70,
+	0x1D,
+	0xE5,
+	0x67,
+	0xD3,
+	0x94,
+	0x00,
+	0x40,
+	0x16,
+	0x12,
+	0x12,
+	0x15,
+	0x12,
+	0x12,
+	0x40,
+	0x7F,
+	0x60,
+	0x12,
+	0x12,
+	0x5E,
+	0xAF,
+	0x67,
+	0x12,
+	0x12,
+	0x5E,
+	0x12,
+	0x12,
+	0x2B,
+	0x12,
+	0x12,
+	0x15,
+	0xE5,
+	0x6B,
+	0x60,
+	0x0D,
+	0xE5,
+	0x68,
+	0xFD,
+	0x7C,
+	0x00,
+	0xAB,
+	0x69,
+	0x7F,
+	0x50,
+	0x7E,
+	0x02,
+	0x80,
+	0x0B,
+	0xE5,
+	0x68,
+	0xFD,
+	0x7C,
+	0x00,
+	0xAB,
+	0x69,
+	0x7F,
+	0x50,
+	0x7E,
+	0x00,
+	0x12,
+	0x16,
+	0xA3,
+	0x7D,
+	0x74,
+	0xE4,
+	0xFF,
+	0x12,
+	0x12,
+	0xAC,
+	0xEF,
+	0x70,
+	0xAF,
+	0xD3,
+	0x22,
+	0xC3,
+	0x22,
+	0x8F,
+	0x63,
+	0x75,
+	0x66,
+	0x74,
+	0xE4,
+	0xF5,
+	0x64,
+	0xE5,
+	0x63,
+	0xC3,
+	0x13,
+	0xFF,
+	0xE5,
+	0x63,
+	0x30,
+	0xE0,
+	0x04,
+	0x7D,
+	0x80,
+	0x80,
+	0x02,
+	0x7D,
+	0x00,
+	0x7B,
+	0x40,
+	0x12,
+	0x15,
+	0xC8,
+	0x40,
+	0x01,
+	0x22,
+	0xE4,
+	0xF5,
+	0x65,
+	0xE5,
+	0x66,
+	0x25,
+	0x65,
+	0xF8,
+	0xE6,
+	0x25,
+	0x64,
+	0xF5,
+	0x64,
+	0x05,
+	0x65,
+	0xE5,
+	0x65,
+	0xB4,
+	0x40,
+	0xEF,
+	0xE5,
+	0x63,
+	0xC3,
+	0x13,
+	0xFF,
+	0xE5,
+	0x63,
+	0x30,
+	0xE0,
+	0x04,
+	0x7E,
+	0x80,
+	0x80,
+	0x02,
+	0x7E,
+	0x00,
+	0xEE,
+	0x24,
+	0x40,
+	0xFD,
+	0x7B,
+	0x40,
+	0x12,
+	0x15,
+	0xC8,
+	0x40,
+	0x01,
+	0x22,
+	0xE4,
+	0xF5,
+	0x65,
+	0xE5,
+	0x66,
+	0x25,
+	0x65,
+	0xF8,
+	0xE6,
+	0x25,
+	0x64,
+	0xF5,
+	0x64,
+	0x05,
+	0x65,
+	0xE5,
+	0x65,
+	0xB4,
+	0x40,
+	0xEF,
+	0xE5,
+	0x64,
+	0x70,
+	0x03,
+	0xD3,
+	0x80,
+	0x01,
+	0xC3,
+	0x22,
+	0x8E,
+	0x6C,
+	0x8F,
+	0x6D,
+	0x8C,
+	0x6E,
+	0x8D,
+	0x6F,
+	0x8B,
+	0x70,
+	0xE5,
+	0x6C,
+	0xF5,
+	0x71,
+	0xEF,
+	0xF5,
+	0x72,
+	0xE5,
+	0x71,
+	0x7D,
+	0x80,
+	0x7F,
+	0x5A,
+	0x30,
+	0xE1,
+	0x05,
+	0x12,
+	0x11,
+	0xB7,
+	0x80,
+	0x03,
+	0x12,
+	0x11,
+	0xA2,
+	0x53,
+	0x71,
+	0x01,
+	0xE5,
+	0x71,
+	0x70,
+	0x0B,
+	0xE5,
+	0x6E,
+	0x25,
+	0x72,
+	0xF5,
+	0x72,
+	0xE4,
+	0xF5,
+	0x73,
+	0x80,
+	0x04,
+	0xE5,
+	0x6E,
+	0xF5,
+	0x73,
+	0xAD,
+	0x72,
+	0x7F,
+	0x28,
+	0x12,
+	0x11,
+	0x76,
+	0xAD,
+	0x73,
+	0x7F,
+	0x40,
+	0x12,
+	0x11,
+	0x76,
+	0xE5,
+	0x6F,
+	0xF5,
+	0x73,
+	0xAD,
+	0x73,
+	0x7F,
+	0x29,
+	0x12,
+	0x11,
+	0x76,
+	0xAD,
+	0x70,
+	0x7F,
+	0x08,
+	0x12,
+	0x11,
+	0x76,
+	0xAF,
+	0x71,
+	0x22,
+	0xC0,
+	0xE0,
+	0xC0,
+	0xF0,
+	0xC0,
+	0x83,
+	0xC0,
+	0x82,
+	0xC0,
+	0xD0,
+	0x75,
+	0xD0,
+	0x08,
+	0x7F,
+	0x25,
+	0x12,
+	0x19,
+	0x8F,
+	0xEF,
+	0x54,
+	0x10,
+	0xF5,
+	0x56,
+	0x7D,
+	0x40,
+	0x7F,
+	0x6E,
+	0x12,
+	0x11,
+	0xBD,
+	0x30,
+	0x00,
+	0x27,
+	0xE5,
+	0x56,
+	0x65,
+	0x55,
+	0x60,
+	0x21,
+	0x85,
+	0x56,
+	0x55,
+	0xD2,
+	0x03,
+	0xD2,
+	0x10,
+	0xE5,
+	0x16,
+	0xD3,
+	0x94,
+	0x03,
+	0x40,
+	0x03,
+	0x75,
+	0x16,
+	0x03,
+	0xC2,
+	0x13,
+	0x7D,
+	0x01,
+	0x7F,
+	0x10,
+	0x12,
+	0x11,
+	0xB3,
+	0x7D,
+	0x20,
+	0x7F,
+	0x0F,
+	0x12,
+	0x11,
+	0x9E,
+	0xD0,
+	0xD0,
+	0xD0,
+	0x82,
+	0xD0,
+	0x83,
+	0xD0,
+	0xF0,
+	0xD0,
+	0xE0,
+	0x32,
+	0x8F,
+	0x5C,
+	0xE4,
+	0xF5,
+	0x5D,
+	0xE5,
+	0x5D,
+	0xC3,
+	0x95,
+	0x5C,
+	0x50,
+	0x15,
+	0xE5,
+	0x5D,
+	0x90,
+	0x10,
+	0xB2,
+	0x93,
+	0xFF,
+	0x74,
+	0x2B,
+	0x25,
+	0x5D,
+	0xF8,
+	0xE6,
+	0xFD,
+	0x12,
+	0x11,
+	0x6E,
+	0x05,
+	0x5D,
+	0x80,
+	0xE4,
+	0x20,
+	0x1B,
+	0x03,
+	0x43,
+	0x5C,
+	0x80,
+	0xAD,
+	0x5C,
+	0x7F,
+	0x50,
+	0x12,
+	0x11,
+	0x6A,
+	0x7D,
+	0x40,
+	0x7F,
+	0x4F,
+	0x12,
+	0x11,
+	0x96,
+	0xC2,
+	0x0A,
+	0x22,
+	0x7B,
+	0x04,
+	0x7C,
+	0x00,
+	0x7F,
+	0x3A,
+	0x8F,
+	0x60,
+	0x8C,
+	0x61,
+	0x8D,
+	0x62,
+	0x8B,
+	0x63,
+	0xE4,
+	0xF5,
+	0x64,
+	0xAF,
+	0x60,
+	0x7E,
+	0x00,
+	0xAB,
+	0x63,
+	0xAD,
+	0x62,
+	0xAC,
+	0x61,
+	0x12,
+	0x16,
+	0xA3,
+	0x7D,
+	0x2B,
+	0xE4,
+	0xFF,
+	0x12,
+	0x12,
+	0xAC,
+	0xEF,
+	0x70,
+	0x02,
+	0xD3,
+	0x22,
+	0x05,
+	0x64,
+	0xE5,
+	0x64,
+	0xD3,
+	0x94,
+	0x02,
+	0x40,
+	0xDE,
+	0x22,
+	0x20,
+	0x1A,
+	0x15,
+	0x7D,
+	0x08,
+	0x7F,
+	0x0A,
+	0x12,
+	0x11,
+	0xAB,
+	0x7D,
+	0xFC,
+	0x7F,
+	0x63,
+	0x12,
+	0x11,
+	0xB7,
+	0x7D,
+	0x01,
+	0x7F,
+	0x64,
+	0x12,
+	0x11,
+	0xB7,
+	0x7D,
+	0x02,
+	0x7F,
+	0x66,
+	0x12,
+	0x11,
+	0xB7,
+	0x7D,
+	0x10,
+	0x7F,
+	0x11,
+	0x12,
+	0x11,
+	0xAF,
+	0x7D,
+	0x10,
+	0x7F,
+	0x1A,
+	0x12,
+	0x11,
+	0xAF,
+	0x7D,
+	0x08,
+	0x7F,
+	0x16,
+	0x02,
+	0x11,
+	0xAF,
+	0x20,
+	0x1A,
+	0x15,
+	0x7D,
+	0x08,
+	0x7F,
+	0x0A,
+	0x12,
+	0x11,
+	0x96,
+	0x7D,
+	0xFC,
+	0x7F,
+	0x63,
+	0x12,
+	0x11,
+	0xA2,
+	0x7D,
+	0x01,
+	0x7F,
+	0x64,
+	0x12,
+	0x11,
+	0xA2,
+	0x7D,
+	0x02,
+	0x7F,
+	0x66,
+	0x12,
+	0x11,
+	0xA2,
+	0x7D,
+	0x10,
+	0x7F,
+	0x11,
+	0x12,
+	0x11,
+	0x9A,
+	0x7D,
+	0x10,
+	0x7F,
+	0x1A,
+	0x12,
+	0x11,
+	0x9A,
+	0x7D,
+	0x08,
+	0x7F,
+	0x16,
+	0x02,
+	0x11,
+	0x9A,
+	0xC2,
+	0x1B,
+	0x12,
+	0x19,
+	0xAA,
+	0xE4,
+	0xFD,
+	0x7F,
+	0x53,
+	0x12,
+	0x11,
+	0x76,
+	0x7E,
+	0x11,
+	0x7F,
+	0x11,
+	0x12,
+	0x11,
+	0xD2,
+	0x7F,
+	0x08,
+	0x12,
+	0x19,
+	0x87,
+	0xEF,
+	0x54,
+	0x0E,
+	0x60,
+	0x07,
+	0x7E,
+	0x11,
+	0x7F,
+	0x28,
+	0x12,
+	0x11,
+	0xD2,
+	0x7D,
+	0x04,
+	0x7F,
+	0x5C,
+	0x12,
+	0x11,
+	0xA2,
+	0x7D,
+	0x01,
+	0x7F,
+	0x07,
+	0x02,
+	0x11,
+	0xAB,
+	0xA2,
+	0x05,
+	0x82,
+	0x04,
+	0x50,
+	0x1E,
+	0x7D,
+	0x80,
+	0x7F,
+	0x0D,
+	0x12,
+	0x11,
+	0xBD,
+	0x7D,
+	0x20,
+	0x7F,
+	0x0F,
+	0x12,
+	0x11,
+	0xB3,
+	0x7F,
+	0x01,
+	0x12,
+	0x1A,
+	0x75,
+	0x7D,
+	0xFC,
+	0x7F,
+	0x53,
+	0x12,
+	0x11,
+	0xA2,
+	0xD2,
+	0x13,
+	0x80,
+	0x09,
+	0x7D,
+	0x01,
+	0x7F,
+	0x10,
+	0x12,
+	0x11,
+	0xB3,
+	0xC2,
+	0x13,
+	0xA2,
+	0x13,
+	0x22,
+	0xA2,
+	0x19,
+	0x92,
+	0x11,
+	0x30,
+	0x19,
+	0x0F,
+	0x12,
+	0x18,
+	0x25,
+	0x7E,
+	0x11,
+	0x7F,
+	0x28,
+	0x12,
+	0x11,
+	0xD2,
+	0xD2,
+	0x1A,
+	0x02,
+	0x17,
+	0xBD,
+	0xD2,
+	0x1A,
+	0x12,
+	0x17,
+	0xF1,
+	0x20,
+	0x0F,
+	0x03,
+	0x12,
+	0x1A,
+	0x11,
+	0x20,
+	0x14,
+	0x07,
+	0x7E,
+	0x11,
+	0x7F,
+	0x21,
+	0x12,
+	0x11,
+	0xD2,
+	0xD2,
+	0x02,
+	0x22,
+	0x8E,
+	0x5E,
+	0x8F,
+	0x5F,
+	0x8D,
+	0x60,
+	0xE4,
+	0xF5,
+	0x61,
+	0xAB,
+	0x60,
+	0xAD,
+	0x5F,
+	0xAC,
+	0x5E,
+	0x7F,
+	0x52,
+	0x7E,
+	0x00,
+	0x12,
+	0x16,
+	0xA3,
+	0x7D,
+	0x2B,
+	0xE4,
+	0xFF,
+	0x12,
+	0x12,
+	0xAC,
+	0xEF,
+	0x70,
+	0x02,
+	0xD3,
+	0x22,
+	0x05,
+	0x61,
+	0xE5,
+	0x61,
+	0xD3,
+	0x94,
+	0x02,
+	0x40,
+	0xDE,
+	0x22,
+	0x8F,
+	0x5E,
+	0x8C,
+	0x5F,
+	0x8D,
+	0x60,
+	0x8B,
+	0x61,
+	0xE4,
+	0xF5,
+	0x62,
+	0xAF,
+	0x5E,
+	0x7E,
+	0x00,
+	0xAB,
+	0x61,
+	0xAD,
+	0x60,
+	0xAC,
+	0x5F,
+	0x12,
+	0x16,
+	0xA3,
+	0xE4,
+	0xFF,
+	0x12,
+	0x13,
+	0x3C,
+	0xEF,
+	0x70,
+	0x02,
+	0xD3,
+	0x22,
+	0x05,
+	0x62,
+	0xE5,
+	0x62,
+	0xD3,
+	0x94,
+	0x02,
+	0x40,
+	0xE0,
+	0x22,
+	0xE4,
+	0xFE,
+	0xFD,
+	0xEF,
+	0x2D,
+	0xF8,
+	0xE6,
+	0xF5,
+	0x5E,
+	0xE4,
+	0xF5,
+	0x5F,
+	0xE5,
+	0x5E,
+	0x30,
+	0xE7,
+	0x01,
+	0x0E,
+	0xE5,
+	0x5E,
+	0x25,
+	0xE0,
+	0xF5,
+	0x5E,
+	0x05,
+	0x5F,
+	0xE5,
+	0x5F,
+	0xB4,
+	0x08,
+	0xED,
+	0x0D,
+	0xBD,
+	0x05,
+	0xE0,
+	0xEE,
+	0xB4,
+	0x14,
+	0x03,
+	0xD3,
+	0x80,
+	0x01,
+	0xC3,
+	0x22,
+	0xC2,
+	0x08,
+	0xEF,
+	0x60,
+	0x18,
+	0x7D,
+	0x80,
+	0x7F,
+	0x0E,
+	0x12,
+	0x11,
+	0x9A,
+	0x12,
+	0x1A,
+	0x33,
+	0x12,
+	0x08,
+	0x74,
+	0x20,
+	0x0F,
+	0x03,
+	0x12,
+	0x1A,
+	0x11,
+	0xD2,
+	0x02,
+	0xD2,
+	0x07,
+	0x22,
+	0x12,
+	0x18,
+	0x25,
+	0x7D,
+	0x80,
+	0x7F,
+	0x0E,
+	0x12,
+	0x11,
+	0xAF,
+	0x22,
+	0xC2,
+	0xAF,
+	0xE4,
+	0xF5,
+	0x11,
+	0xF5,
+	0x12,
+	0x75,
+	0x13,
+	0x07,
+	0x75,
+	0x14,
+	0xD0,
+	0xF5,
+	0x18,
+	0xF5,
+	0x10,
+	0xC2,
+	0x8C,
+	0x53,
+	0x89,
+	0xF0,
+	0x43,
+	0x89,
+	0x01,
+	0x75,
+	0x8A,
+	0x40,
+	0x75,
+	0x8C,
+	0x7C,
+	0xD2,
+	0xA9,
+	0xD2,
+	0x8C,
+	0xD2,
+	0xAF,
+	0x22,
+	0x7D,
+	0x00,
+	0x80,
+	0x0A,
+	0x7D,
+	0x01,
+	0x80,
+	0x06,
+	0x7D,
+	0x03,
+	0x80,
+	0x02,
+	0x7D,
+	0x04,
+	0xC2,
+	0xAF,
+	0x78,
+	0x83,
+	0xE2,
+	0xCD,
+	0xF2,
+	0x74,
+	0x80,
+	0x2F,
+	0xF8,
+	0xE2,
+	0x78,
+	0x03,
+	0xFF,
+	0xED,
+	0xF2,
+	0xD2,
+	0xAF,
+	0x22,
+	0x32,
+	0x7D,
+	0x01,
+	0x7F,
+	0x10,
+	0x12,
+	0x11,
+	0xB3,
+	0x7D,
+	0x20,
+	0x7F,
+	0x0F,
+	0x12,
+	0x11,
+	0x9E,
+	0x30,
+	0x1B,
+	0x04,
+	0x7F,
+	0x42,
+	0x80,
+	0x02,
+	0x7F,
+	0x40,
+	0x8F,
+	0x5E,
+	0xAD,
+	0x5E,
+	0x7F,
+	0x10,
+	0x12,
+	0x11,
+	0x72,
+	0xC2,
+	0x13,
+	0x22,
+	0x8F,
+	0x58,
+	0x80,
+	0x18,
+	0xE5,
+	0x5A,
+	0x60,
+	0x19,
+	0x7F,
+	0x25,
+	0x12,
+	0x19,
+	0x8F,
+	0xEF,
+	0x54,
+	0x10,
+	0xF5,
+	0x59,
+	0xB5,
+	0x55,
+	0x04,
+	0x15,
+	0x5A,
+	0x80,
+	0xEB,
+	0x85,
+	0x59,
+	0x55,
+	0x85,
+	0x58,
+	0x5A,
+	0x80,
+	0xE3,
+	0x22,
+	0x8F,
+	0x58,
+	0x80,
+	0x18,
+	0xE5,
+	0x5A,
+	0x60,
+	0x19,
+	0x7F,
+	0x7F,
+	0x12,
+	0x19,
+	0x93,
+	0xEF,
+	0x54,
+	0x04,
+	0xF5,
+	0x59,
+	0xB5,
+	0x49,
+	0x04,
+	0x15,
+	0x5A,
+	0x80,
+	0xEB,
+	0x85,
+	0x59,
+	0x49,
+	0x85,
+	0x58,
+	0x5A,
+	0x80,
+	0xE3,
+	0x22,
+	0x7E,
+	0x11,
+	0x7F,
+	0x48,
+	0x12,
+	0x11,
+	0xD2,
+	0x7D,
+	0x04,
+	0x7F,
+	0x0A,
+	0x30,
+	0x01,
+	0x10,
+	0x12,
+	0x11,
+	0xAB,
+	0x7D,
+	0x04,
+	0x7F,
+	0x5C,
+	0x12,
+	0x11,
+	0xB7,
+	0x7D,
+	0x01,
+	0x7F,
+	0x07,
+	0x80,
+	0x00,
+	0x12,
+	0x11,
+	0x96,
+	0x22,
+	0x7F,
+	0x64,
+	0x7E,
+	0x00,
+	0xAD,
+	0x07,
+	0xAC,
+	0x06,
+	0xE4,
+	0x12,
+	0x0D,
+	0xBA,
+	0xE4,
+	0xFB,
+	0xFA,
+	0x79,
+	0x20,
+	0x78,
+	0x40,
+	0x12,
+	0x0D,
+	0x18,
+	0x12,
+	0x0D,
+	0xF3,
+	0x8F,
+	0x11,
+	0xE5,
+	0x11,
+	0x70,
+	0xFC,
+	0x22,
+	0x7B,
+	0x02,
+	0x7D,
+	0x08,
+	0x12,
+	0x17,
+	0x8B,
+	0x92,
+	0x1A,
+	0xAD,
+	0x2C,
+	0x7F,
+	0x6F,
+	0x12,
+	0x11,
+	0x72,
+	0xAD,
+	0x2B,
+	0x7F,
+	0x70,
+	0x12,
+	0x11,
+	0x72,
+	0xA2,
+	0x1A,
+	0x22,
+	0x7B,
+	0x01,
+	0x7D,
+	0x40,
+	0x12,
+	0x17,
+	0x8B,
+	0x22,
+	0xAD,
+	0x07,
+	0x7F,
+	0x53,
+	0x02,
+	0x11,
+	0xB7 
+};
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/lvds/lvds.c b/drivers/gpu/drm/emgd/emgd/pal/ch7036/lvds/lvds.c
new file mode 100644
index 0000000..db8b198
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/lvds/lvds.c
@@ -0,0 +1,1563 @@
+/* -*- pse-c -*-
+ *-----------------------------------------------------------------------------
+ * Filename: lvds.c
+ * $Revision: 1.2 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2010, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ * Description:
+ *  This file is contains all necessary functions for Internal
+ *  LVDS PORT DRIVER.
+ *  This is written according to the port interface defined in pd.h.
+ *-----------------------------------------------------------------------------
+ */
+#include <linux/kernel.h>
+
+#include <config.h>
+#include <igd_pd.h>
+#include <pd.h>
+#include <pd_print.h>
+
+#include "lvds.h"
+
+/* One space between the #define and the backslash,else compilers complain */
+#define PTR_OFFSET_UCHAR(ptr,offset)   (*((unsigned char *)ptr + offset))
+#define PTR_OFFSET_USHORT(ptr, offset) (*(unsigned short *)((unsigned char *)ptr + offset))
+
+#define PTR_OFFSET_ULONG(ptr, offset) (*(unsigned long *)((unsigned char *)ptr + offset))
+/* END OF OPTIMIZATION MACROS */
+
+/* This constant = 10,000,000.  The value is used to
+ * get effective results from the integer math, and
+ * to not divide by 0. */
+#define PWM_FREQ_CALC_CONSTANT_1        0x00989680
+/* This constant is 1,000,000 - to multiply to get
+ * the Display Clock Frequency to the order of Mhz */
+#define PWM_FREQ_CALC_CONSTANT_2        0x000F4240
+
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(p) (sizeof(p)/sizeof((p)[0]))
+#endif
+
+static pd_version_t  internal_lvds_version = {11, 0, 0, 0}; /* driver version */
+static unsigned long internal_lvds_dab_list[] = {
+	PD_DAB_LIST_END
+}; /* dab list */
+
+static unsigned long supported_chipset[] =
+{
+#ifdef CONFIG_855
+	PCI_DEVICE_ID_VGA_855,
+#endif
+#ifdef CONFIG_915AL
+	PCI_DEVICE_ID_VGA_915AL,
+#endif
+#ifdef CONFIG_945GM
+	PCI_DEVICE_ID_VGA_945GM,
+	PCI_DEVICE_ID_VGA_945GME,
+#endif
+#ifdef CONFIG_965GM
+	PCI_DEVICE_ID_VGA_GM965,
+	PCI_DEVICE_ID_VGA_GME965,
+#endif
+#ifdef CONFIG_CTG
+	PCI_DEVICE_ID_VGA_CTG,
+#endif
+#ifdef CONFIG_PLB
+	PCI_DEVICE_ID_VGA_PLB,
+#endif
+#ifdef CONFIG_TNC
+	PCI_DEVICE_ID_VGA_TNC,
+	PCI_DEVICE_ID_VGA_TNC_A0,
+	PCI_DEVICE_ID_VGA_LNC,
+#endif
+};
+
+static pd_driver_t  internal_lvds_driver  = {
+	PD_SDK_VERSION,
+	"Internal LVDS Port Driver",
+	0,
+	&internal_lvds_version,
+	PD_DISPLAY_LVDS_INT,
+	PD_FLAG_UP_SCALING,
+	internal_lvds_dab_list,
+	100,
+	internal_lvds_validate,
+	internal_lvds_open,
+	internal_lvds_init_device,
+	internal_lvds_close,
+	internal_lvds_set_mode,
+	internal_lvds_post_set_mode,
+	internal_lvds_set_attrs,
+	internal_lvds_get_attrs,
+	internal_lvds_get_timing_list,
+	internal_lvds_set_power,
+	internal_lvds_get_power,
+	internal_lvds_save,
+	internal_lvds_restore,
+	internal_lvds_get_port_status
+};
+
+/* This is a common attribute table for all chipsets. At the end of the table
+ * there are multiple end entries to add chipset specific attributes.
+ * Chipset specific attributes:
+ *     965GM/GM45- Maintain aspect ratio
+ * Note:
+ *    1. Make sure to update the chipset_attr_index whenever adding a
+ *       chipset specific new attr.
+ */
+static pd_attr_t internal_lvds_attrs[] =
+{
+	/* Range attributes */
+
+	/*<-------ID----------->              <----TYPE-------->  <---NAME----->  <----flag---->               <---DEF_VAL---->       <--CURR_VALUE-->      min max  st */
+	PD_MAKE_ATTR (PD_ATTR_ID_FP_PWR_T1,   PD_ATTR_TYPE_RANGE, "FP Power T1",  PD_ATTR_FLAG_USER_INVISIBLE, 0,                     0,                    0,  819,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_FP_PWR_T2,   PD_ATTR_TYPE_RANGE, "FP Power T2",  PD_ATTR_FLAG_USER_INVISIBLE, 0,                     0,                    0,  819,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_FP_PWR_T3,   PD_ATTR_TYPE_RANGE, "FP Power T3",  PD_ATTR_FLAG_USER_INVISIBLE, 0,                     0,                    0,  819,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_FP_PWR_T4,   PD_ATTR_TYPE_RANGE, "FP Power T4",  PD_ATTR_FLAG_USER_INVISIBLE, 0,                     0,                    0,  819,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_FP_PWR_T5,   PD_ATTR_TYPE_RANGE, "FP Power T5",  PD_ATTR_FLAG_USER_INVISIBLE, 400,                 400,                    0,  3000, 1),
+	PD_MAKE_ATTR (PD_ATTR_ID_PANEL_DEPTH, PD_ATTR_TYPE_RANGE, "Panel Depth",  PD_ATTR_FLAG_USER_INVISIBLE, LVDS_DEF_PANEL_DEPTH,  LVDS_DEF_PANEL_DEPTH, 18, 24,   6),
+
+	PD_MAKE_ATTR (PD_ATTR_ID_PWM_INTENSITY,	  PD_ATTR_TYPE_RANGE, "PWM cycle",			  PD_ATTR_FLAG_USER_INVISIBLE,		100,		0,				  0,  100,  0),
+	PD_MAKE_ATTR (PD_ATTR_ID_INVERTER_FREQ,	  PD_ATTR_TYPE_RANGE, "Inverter Frequency",	  PD_ATTR_FLAG_USER_INVISIBLE,		100,		0,				  0,  0,  0),
+	PD_MAKE_ATTR (PD_ATTR_ID_BLM_LEGACY_MODE, PD_ATTR_TYPE_BOOL,  "Backlight Legacy mode",	  PD_ATTR_FLAG_USER_INVISIBLE,		0,		0,					  0,  0,  0),
+
+	/*<-------ID------------>                 <----TYPE--------> <---NAME----->        <------flag--------------->  <---DEF_VAL---->   <--CURR_VALUE-->   <---pad--> */
+	PD_MAKE_ATTR (PD_ATTR_ID_2_CHANNEL_PANEL, PD_ATTR_TYPE_BOOL, "Dual-channel panel", PD_ATTR_FLAG_USER_INVISIBLE, 0,                 0,                 0, 0, 0),
+	PD_MAKE_ATTR (PD_ATTR_ID_LVDS_PANEL_TYPE, PD_ATTR_TYPE_BOOL, "Panel Type",         PD_ATTR_FLAG_USER_INVISIBLE, 0,                 0,                 0, 0, 0),
+	PD_MAKE_ATTR (PD_ATTR_ID_PANEL_FIT,       PD_ATTR_TYPE_BOOL, "Panel Upscale",      PD_ATTR_FLAG_USER_INVISIBLE, LVDS_DEF_PANEL_FIT,LVDS_DEF_PANEL_FIT,0, 0, 0),
+	PD_MAKE_ATTR (PD_ATTR_ID_DITHER,          PD_ATTR_TYPE_BOOL, "Dither",             PD_ATTR_FLAG_USER_INVISIBLE, LVDS_DEF_DITHER,   LVDS_DEF_DITHER,   0, 0, 0),
+	PD_MAKE_ATTR (LVDS_ATTR_ID_TC_LVDS_CLK,   PD_ATTR_TYPE_BOOL, "TC LVDS CLK 110MHz", PD_ATTR_FLAG_USER_INVISIBLE, 0,                 0,                 0, 0, 0),
+
+	/* Start of chipset specific attributes */
+	/* Maintain aspect ratio */
+	PD_MAKE_ATTR (PD_ATTR_LIST_END,       0,                   "",            0,                           0,                0,               0,     0, 0),
+	/* Text tuning */
+	PD_MAKE_ATTR (PD_ATTR_LIST_END,       0,                   "",            0,                           0,                0,               0,     0, 0),
+
+	/* Attribute list end */
+	PD_MAKE_ATTR (PD_ATTR_LIST_END,       0,                   "",            0,                           0,                0,               0,     0, 0)
+};
+
+/* Rightnow it is -3 to reach starting of chipset specific attributes */
+static unsigned short chipset_attr_index = (unsigned short)
+	sizeof(internal_lvds_attrs)/sizeof(pd_attr_t) - 3;
+
+#if 0
+static pd_attr_t internal_lvds_965gm_attrs[] = {
+	PD_MAKE_ATTR (PD_ATTR_ID_MAINTAIN_ASPECT_RATIO,PD_ATTR_TYPE_BOOL,      "Maintain Aspect Ratio",0,             0,               0,               0,     0, 0),
+	PD_MAKE_ATTR (PD_ATTR_ID_TEXT_TUNING,          PD_ATTR_TYPE_RANGE,     "Text Enhancement",     0,             0,               0,               0,     2, 1),
+};
+#endif
+
+static void internal_lvds_write_reg(internal_lvds_context_t *pd_context, unsigned long reg,
+		unsigned long value, unsigned long change_bits, unsigned long reg_type);
+
+static unsigned long internal_lvds_read_reg(internal_lvds_context_t *pd_context,
+		unsigned long reg, unsigned long reg_type);
+static void internal_lvds_panel_fit(internal_lvds_context_t *pd_context);
+
+static void internal_lvds_get_dclk(internal_lvds_context_t *pd_context, pd_dvo_info_t *internal_lvds_info);
+
+/*----------------------------------------------------------------------------
+ *
+ * Function: PD_MODULE_INIT(internal_lvds_init)
+ *
+ * Description:
+ *    This is the entry function into LVDS port driver when
+ *    it first loads. This will call pd_register() to register
+ *    with Display driver.  Only the driver object is initialized in this
+ *    function, similar to DrverEntry() in a WDM driver.
+ *
+ * Parameters:
+ *    [OUT] *handle:  Not used.  Place holder for supporting dynamic pd
+ *
+ * Return:
+ *    PD_SUCCESS(0)  success
+ *    PD_ERR_XXXXXX  otherwise
+ *
+ *----------------------------------------------------------------------------
+ */
+
+int PD_MODULE_INIT(internal_lvds_init, (void *handle))
+{
+	/* register the LVDS driver */
+	return pd_register(handle, &internal_lvds_driver);
+}
+
+/*----------------------------------------------------------------------------
+ *
+ * Function: PD_MODULE_EXIT(internal_lvds_exit, (void))
+ *
+ * Description:
+ *    This function cleans up resources used by the LVDS driver
+ *
+ * Parameters:
+ *    None
+ *
+ * Return:
+ *    PD_SUCCESS(0):  always returns this
+ *
+ *----------------------------------------------------------------------------
+ */
+
+int PD_MODULE_EXIT(internal_lvds_exit, (void))
+{
+	return PD_SUCCESS;
+}
+
+/*----------------------------------------------------------------------------
+ *
+ * Function: internal_lvds_validate
+ *
+ * Description:
+ *    Place holder for a future function
+ *
+ * Parameters:
+ *    TBD
+ *
+ * Return:
+ *    TBD
+ *
+ *----------------------------------------------------------------------------
+ */
+
+unsigned long internal_lvds_validate (unsigned long cookie)
+{                                                          /* internal_lvds_validate */
+	/* Validate magic cookie */
+	/* TODO: Implement the magic cookie algorithm */
+	return cookie;
+}                                                          /* internal_lvds_validate */
+
+/*----------------------------------------------------------------------------
+ *
+ * Function: internal_lvds_open
+ *
+ * Description:
+ *    This function creates an LVDS context and intialize it with LVDS
+ *    attributes.
+ *
+ *    Internal LVDS port is available only on MGM platform, this port driver
+ *    reads the GMCH device ID with pd_read_regs(PD_REG_PCI) to verify that
+ *    it is supported on the current platform.
+ *
+ * Parameters:
+ *    [IN] callback:    callback context
+ *    [INOUT] context:  Device context.  This function will set the attributes
+ *                      for this context, provided it is already allocated,
+ *                      i.e. not NULL.
+ *
+ * Return:
+ *    PD_ERR_NULL_PTR:  if either of the parameters is NULL
+ *    PD_ERR_NODEV:     if an LVDS device is already up and running
+ *    PD_ERR_NOMEM:     if a memory allocation failed
+ *    PD_SUCCESS:       if successful
+ *
+ *----------------------------------------------------------------------------
+ */
+
+/* lvds context structure being declared and initialized */
+
+static internal_lvds_context_t internal_lvds_context = {  /* lvds context structure */
+	0,                   /* fp_width     */
+	0,                   /* fp_height    */
+	0,                   /* dual_channel: Default single channel */
+	0,                   /* panel_type : 0-SPWG 1-OpenLDI*/
+	LVDS_DEF_PANEL_FIT,  /* panel_fit    */
+	LVDS_DEF_PANEL_DEPTH,/* panel_depth  */
+	0xFFFF,              /* dither       */
+	0,                   /* Main aspect ratio, default no */
+	0,                   /* panel filter: Default fuzzy filtering */
+	100,                 /* PWM Intensity */
+	0xFFFF,              /* Inverter Frequency*/
+	0,                   /* BLM Legacy Mode */
+
+	PD_POWER_MODE_D0,    /* power_state   */
+	0,                   /* chipset       */
+	0,                   /* init_done     */
+	0,                   /* num_attrs */
+	0,                   /* PIPE flags    */
+	0,                   /* Graphics Frequency */
+	0,                   /* is gn4 based LVDS controller? */
+	0,                   /* is pwm_done? */
+	0,                   /* is tc_110MHz_clk? i.e., TC max LVDS to 110MHz*/
+
+	NULL,                /* ptr to callback       */
+	NULL,                /* ptr to timing table   */
+	internal_lvds_attrs,          /* ptr to attribute list */
+	NULL,                /* ptr to native timing  */
+	NULL,                /* current mode */
+};
+
+int internal_lvds_open(pd_callback_t *callback, void **context)
+{                                                              /* internal_lvds_open */
+	internal_lvds_context_t *pd_context = (internal_lvds_context_t*) &(internal_lvds_context); /* static Global */
+	pd_reg_t reg_list[2];
+	int ret, i, valid_chipset = 0;
+	unsigned short chipset;
+
+	PD_TRACE_ENTER;
+
+
+
+	/* make sure parameters are valid */
+	if (!callback || !context) {
+		PD_ERROR("invalid parameter");
+		return (PD_ERR_NULL_PTR);
+	}
+	/* GMCH cannot support more than one device */
+	if (internal_lvds_driver.num_devices > 0) {
+		return (PD_ERR_NODEV);
+	}
+	/* Verify that this is an GMCH with Internal LVDS available */
+	reg_list[0].reg = 2;
+	reg_list[1].reg = PD_REG_LIST_END;
+	ret = callback->read_regs(callback->callback_context, reg_list, PD_REG_PCI);
+	if(ret != PD_SUCCESS) {
+		return ret;
+	}
+	chipset = (unsigned short)(reg_list[0].value & 0xffff);
+	for (i = 0; i < ARRAY_SIZE(supported_chipset); i++) {
+		if (chipset == supported_chipset[i]){
+			valid_chipset = 1;
+			break;
+		}
+	}
+	if(!valid_chipset){
+		return PD_ERR_NODEV;
+	}
+
+	/* Special handling for gn4 and beyond chipsets */
+	if (chipset == PCI_DEVICE_ID_VGA_GM965 ||
+		chipset == PCI_DEVICE_ID_VGA_GME965 ||
+		chipset == PCI_DEVICE_ID_VGA_CTG ||
+		chipset == PCI_DEVICE_ID_VGA_TNC ||
+		chipset == PCI_DEVICE_ID_VGA_TNC_A0 ||
+		chipset == PCI_DEVICE_ID_VGA_LNC) {
+		internal_lvds_context.gn4_plus = 1;
+	}
+
+	/* Initialize number of attributes */
+	/* +1 is to include the end attribute */
+	internal_lvds_context.num_attrs = (unsigned char)chipset_attr_index + 1;
+
+#if 0
+	/* Add chipset specific attrbutes.
+	 * This can be expanded into a switch statement in future if required. */
+	if (internal_lvds_context.gn4_plus) {
+		internal_lvds_context.num_attrs += sizeof(internal_lvds_965gm_attrs)/sizeof(pd_attr_t);
+		for (i=0; i < sizeof(internal_lvds_965gm_attrs)/sizeof(pd_attr_t); i++) {
+			internal_lvds_attrs[chipset_attr_index+i] = internal_lvds_965gm_attrs[i];
+		}
+	}
+#endif
+
+	/* Make this a compile time so that size of vBIOS doesn't become > 64KB */
+#if defined(CONFIG_PLB) || defined(CONFIG_TNC)
+	/* pwm backlight control needs graphics frequency. we currently implement
+	 * pwm backlight control for pouslbo only to limit the vbios lvds size. Each
+	 * chipset have a different method of getting this value and chipset has a
+	 * different multiplier. */
+	if (chipset == PCI_DEVICE_ID_VGA_PLB ||
+	    chipset == PCI_DEVICE_ID_VGA_TNC ||
+	    chipset == PCI_DEVICE_ID_VGA_TNC_A0 ||
+	    chipset == PCI_DEVICE_ID_VGA_LNC) {
+
+		/* For plb/tnc, graphics frequency is obtained by sending an opcode to
+		 * port 5 in the SCH Message Network. We call the read_regs with
+		 * PD_REG_BRIDGE_OPCODE specifically for this purpose only.
+		 *
+		 * The input for this read_reg is the opcode that register data that
+		 * we send into the Message control register*/
+		reg_list[1].reg = PD_REG_LIST_END;
+		ret = callback->read_regs(callback->callback_context,
+			reg_list, PD_REG_BRIDGE_OPCODE);
+		if(ret != PD_SUCCESS) {
+			return ret;
+		}
+
+		/*set the graphics frequency*/
+		pd_context->gfx_freq = (unsigned short) reg_list[0].value;
+	}
+#endif
+
+	pd_context->callback = callback;           /* Save callback context */
+	pd_context->chipset = chipset;            /* save the chipset ID   */
+	*context = (void *) pd_context;
+
+	PD_TRACE_EXIT;
+	return PD_SUCCESS;
+}                                                              /* internal_lvds_open */
+
+/*----------------------------------------------------------------------------
+ *
+ * Function: internal_lvds_init_device
+ *
+ * Description:
+ *    Initializes the LVDS device, using the device context from the parameter
+ *
+ * Parameters:
+ *    [INOUT] context:  device context
+ *
+ * Return:
+ *    PD_ERR_NULL_PTR:  if parameter is invalid
+ *    PD_SUCCESS:       if successful
+ *
+ *----------------------------------------------------------------------------
+ */
+
+int internal_lvds_init_device (void *context)
+{                                                       /* internal_lvds_init_device */
+	if (!context) {
+		return (PD_ERR_NULL_PTR);
+	}
+
+	/* Don't need to do much to initialize this device */
+	((internal_lvds_context_t *)context)->init_done = 1;
+	internal_lvds_driver.num_devices++;
+
+	return (PD_SUCCESS);
+}                                                       /* internal_lvds_init_device */
+
+
+/*----------------------------------------------------------------------------
+ *
+ * Function: internal_lvds_close
+ *
+ * Description:
+ *    Releases resources allocated during internal_lvds_open().  This function
+ *    essentially frees a device object.
+ *
+ * Parameters:
+ *    [INOUT] device_context:  device to be freed
+ *
+ * Return:
+ *    PD_SUCCESS: always returns this
+ *
+ *----------------------------------------------------------------------------
+ */
+
+int internal_lvds_close(void *device_context)
+{
+#ifndef CONFIG_MICRO
+
+	internal_lvds_context_t *pd_context = (internal_lvds_context_t *)device_context;
+
+	/* internal_lvds_close */
+
+	PD_TRACE_ENTER;
+
+	/* Deallocate memory occupied by this device */
+	if (device_context) {
+		if ( NULL != pd_context->timing_table) {
+			pd_free(pd_context->timing_table);
+		}
+
+		/* Free attribute list, if necessary */
+		/* FIXME -- The following test will never call pd_free(), because the
+		 * expression "!internal_lvds_driver.num_devices" will yield 0 or 1, and that
+		 * will never be greater than 1.  This is a potentially small memory
+		 * leak, unless some other code frees it.
+		 */
+		if (!internal_lvds_driver.num_devices > 1) {
+			pd_free(pd_context->attr_list);
+		}
+		/* This allocated statically no need to free it */
+		/* pd_free(device_context); */
+		internal_lvds_driver.num_devices--;
+		pd_context->init_done = 0;
+	}
+
+	PD_TRACE_EXIT;
+#endif
+	return (PD_SUCCESS);
+}                                                             /* internal_lvds_close */
+
+/*----------------------------------------------------------------------------
+ *
+ * Function: internal_lvds_set_mode
+ *
+ * Description:
+ *    Sets LVDS to a new mode, specified by "mode".
+ *
+ * Parameters:
+ *    [INOUT] context:  device context
+ *    [IN]    mode:     information about the mode to switch to
+ *    [IN]    flags:    can contain the following value
+ *                PD_SET_MODE_FLAG_TEST:  only testing to see if mode is supported
+ *
+ * Return:
+ *    PD_ERR_NULL_PTR:     if invalid parameter detected
+ *    PD_ERR_MODE_NOTSUPP: if mode specified is not supported
+ *    PD_SUCCESS:          if successful
+ *
+ *----------------------------------------------------------------------------
+ */
+int internal_lvds_set_mode(void *context, pd_timing_t *mode, unsigned long flags)
+{
+	internal_lvds_context_t *pd_context  = NULL;
+
+	PD_DEBUG("internal_lvds_set_mode)\n");
+	PD_TRACE_ENTER;
+
+	pd_context = (internal_lvds_context_t *)context;
+
+	/* Make sure these parameters are valid */
+	if (!pd_context || !mode) {
+		return (PD_ERR_NULL_PTR);
+	}
+	PD_DEBUG("internal_lvds_set_mode: %ux%u", mode->width, mode->height);
+
+	/* Make sure specified mode is supported */
+	if ((pd_context->fp_width && (mode->width > pd_context->fp_width)) ||
+		(pd_context->fp_height && (mode->height > pd_context->fp_height))) {
+		PD_ERROR("internal_lvds_set_mode: ERROR #1\n");
+		return PD_ERR_MODE_NOTSUPP;
+	}
+
+	/* Do nothing if we are only want to know if a mode is supported */
+	if (flags & PD_SET_MODE_FLAG_TEST) {
+		PD_ERROR("internal_lvds_set_mode: SUPPORTED #2\n");
+		return PD_SUCCESS;
+	}
+
+	pd_context->current_mode = mode;
+	pd_context->pipe = flags;
+	/* Enable panel fitting and return */
+	internal_lvds_panel_fit(pd_context);
+
+	PD_ERROR("internal_lvds_set_mode: EXIT #3\n");
+	PD_TRACE_EXIT;
+
+	return PD_SUCCESS;
+}
+
+int internal_lvds_post_set_mode(void *context, pd_timing_t *mode, unsigned long flags)
+{                                                          /* internal_lvds_set_mode */
+	internal_lvds_context_t *pd_context  = NULL;
+	unsigned long  port_control = 0;
+	unsigned long  preserve     = 0;
+	int            ret          = 0;
+
+	PD_TRACE_ENTER;
+	pd_context = (internal_lvds_context_t *)context;
+
+	PD_DEBUG("internal_lvds_post_set_mode)\n");
+	/* Make sure these parameters are valide */
+	if (!pd_context || !mode) {
+		PD_DEBUG("internal_lvds_post_set_mode: EXIT #1\n");
+		return (PD_ERR_NULL_PTR);
+	}
+
+	/* Before enabling the LVDS port, make sure that display PLL for this pipe
+	 * is enabled and the port is power sequenced on using the panel power
+	 * sequencing logic. */
+
+	preserve = 0x3E007803;
+	port_control = preserve & internal_lvds_read_reg(pd_context, 0x61180, PD_REG_MIO);
+	port_control |= BIT(31);          /* enable LVDS port */
+	if (flags & PD_SET_MODE_PIPE_B) {
+		port_control |= BIT(30);
+	}
+	port_control |= (BIT(9)|BIT(8));  /* power up */
+	port_control &= ~(BIT(21)|BIT(20)); /* Default sync polarites active high */
+
+	/* For gn4+, dither moved to port_control from panel_fit reg */
+	if (pd_context->gn4_plus) {
+		if (pd_context->panel_depth == 18) {
+			port_control |= BIT(25);
+		}
+
+		if (pd_context->dither != 0xFFFF) {
+			if (pd_context->dither) {
+				port_control |= BIT(25);
+			} else {
+				port_control &= ~BIT(25);
+			}
+		}
+	}
+
+	if((!pd_context->panel_fit) &&
+	   ( mode->width < pd_context->fp_width ||
+	     mode->height < pd_context->fp_height ) ){
+		port_control |= BIT(15); /* enable border in active for centering */
+	}
+
+	/*
+	 * Bit 24 for OpenLDI should be set to a 0 (1x18.0, 2x18.0, 1x24.0, 2x24.0).
+	 * From (B-Spec, Ref# 22316, section 1.15.3.8.3)
+	 *
+	 * Bit 24 for SPWG should be set to a 1 (1x24.1 or 2x24.1).
+	 *
+	 * This was verified by comparing the timing diagram for 1x24.0 in
+	 * OpenLDI spec (5.4.2.2 24-bit Single Pixel Mode, Unbalanced) with the
+	 * same diagram in the Display BSpec for Napa or Gen4.
+	 * A0  A3 signals match the 1x24.0.
+	 *
+	 * From the OpenLDI spec (bit mappings are different):
+	 *
+	 * Table 5-2, Bit Number Mappings
+	 * 18 bpp bit# 24 bpp bit# OpenLDI bit#
+	 * 5           7           5
+	 * 4           6           4
+	 * 3           5           3
+	 * 2           4           2
+	 * 1           3           1
+	 * 0           2           0
+	 *             1           7
+	 *             0           6
+	 */
+
+	/* Attribute panel_type description:
+	 *  Attr ID    Attr Value        IntLVDS dataformat
+	 *  =======    ===============   ==================
+	 *    49       0  (SPWG)           1 (value of Bit 24)
+	 *    49       1  (OpenLDI)        0 (value of Bit 24)
+	 */
+	if (pd_context->panel_type == 0) {
+		port_control |= BIT(24); /* Dataformat 0 = SPWG, 1 = OpenLDI */
+	}
+
+	/* If the dual-channel is required, then power up second channel
+	 * ClkB and B0, B1, B2, (B3) */
+	if (pd_context->dual_channel) {
+		port_control |= (BIT(5)|BIT(4));  /* ClkB */
+		port_control |= (BIT(3)|BIT(2));  /* B0, B1, B2, (B3) */
+	}
+
+	/* Check for 18 or 24 bit panel */
+	if (pd_context->panel_depth == 24) {
+		/* If the panel is 24-bit (8-bpp), enable A3, (B3) pair. */
+		port_control |= (BIT(7)|BIT(6));
+	}
+
+	/* Set the sync polarities correctly if there is a native dtd */
+	if (pd_context->native_dtd) {
+		/* Set bit 20 for hsync active low */
+		if ((pd_context->native_dtd->mode_info_flags & PD_HSYNC_HIGH) == 0) {
+			port_control |= BIT(20);
+		}
+		/* Set bit 21 for vsync active low */
+		if ((pd_context->native_dtd->mode_info_flags & PD_VSYNC_HIGH) == 0) {
+			port_control |= BIT(21);
+		}
+	}
+
+    internal_lvds_write_reg(pd_context, 0x61204, 0xABCD0000, 0xFFFFFFFF, PD_REG_MIO);
+
+	internal_lvds_write_reg(pd_context, 0x61180, port_control, 0xFFFFFFFF, PD_REG_MIO);
+	ret = internal_lvds_set_power(pd_context, PD_POWER_MODE_D0);
+	if (ret) {
+		PD_ERROR("PD set_power (D0) returned: 0x%x", ret);
+		return ret;
+	}
+
+    internal_lvds_write_reg(pd_context, 0x61204, BIT(1), BIT(1), PD_REG_MIO);
+
+	PD_DEBUG("internal_lvds_post_set_mode: EXIT SUCCESS\n");
+
+	PD_TRACE_EXIT;
+	/* Set the mode as per given timings */
+	return PD_SUCCESS;
+}                                                          /* internal_lvds_set_mode */
+
+/*----------------------------------------------------------------------------
+ *
+ * Function: internal_lvds_set_attrs
+ *
+ * Description:
+ *    Incorporate attributes in "list" into the device context.  This function
+ *    will override the initial attributes set by init_attrs.
+ *
+ * Parameters:
+ *    [INOUT] context:  device context
+ *    [IN] num:         not used, but must not be 0.
+ *    [IN] list:        list of attributes to incorporate into device context
+ *
+ * Return:
+ *    PD_ERR_NULL_PTR:          if one of the parameters is invalid
+ *    PD_ERR_ATTR_CANT_CHANGE:  attributes cannot be modified
+ *    PD_SUCCESS: if successful
+ *
+ *----------------------------------------------------------------------------
+ */
+/* Tables required by Optimization Code. internal_lvds_set_attrs() */
+typedef struct _opt_table_data {
+	unsigned long id;
+	unsigned short block;
+	unsigned short offset;
+} internal_lvds_opt_table_data_t;
+static internal_lvds_opt_table_data_t table_opt_data1[] = {
+
+	/*<--- id ---------->  <---block---> <------ offset -------------------> */
+	{PD_ATTR_ID_PANEL_DEPTH,     1, PD_OFFSETOF(internal_lvds_context_t, panel_depth) },
+
+	{PD_ATTR_ID_2_CHANNEL_PANEL, 1, PD_OFFSETOF(internal_lvds_context_t, dual_channel)},
+	{PD_ATTR_ID_LVDS_PANEL_TYPE, 1, PD_OFFSETOF(internal_lvds_context_t, panel_type) },
+	{PD_ATTR_ID_PANEL_FIT,       1, PD_OFFSETOF(internal_lvds_context_t, panel_fit)   },
+	{PD_ATTR_ID_DITHER,          1, PD_OFFSETOF(internal_lvds_context_t, dither)      },
+	{PD_ATTR_ID_MAINTAIN_ASPECT_RATIO,1,PD_OFFSETOF(internal_lvds_context_t,aspect_ratio)},
+	{PD_ATTR_ID_TEXT_TUNING,     1, PD_OFFSETOF(internal_lvds_context_t, text_tune)},
+	{PD_ATTR_ID_PWM_INTENSITY,   1, PD_OFFSETOF(internal_lvds_context_t, pwm_intensity)},
+	{PD_ATTR_ID_INVERTER_FREQ,   1, PD_OFFSETOF(internal_lvds_context_t, inverter_freq)},
+	{PD_ATTR_ID_BLM_LEGACY_MODE, 1, PD_OFFSETOF(internal_lvds_context_t, blm_legacy_mode)},
+	{LVDS_ATTR_ID_TC_LVDS_CLK,   1, PD_OFFSETOF(internal_lvds_context_t, tc_110MHz_clk)},
+
+	/*<--- id ---------->  <---block---> <------ offset -------------------> */
+	{PD_ATTR_ID_FP_PWR_T1,       2,     0 }, /* 6 */
+	{PD_ATTR_ID_FP_PWR_T2,       2,     0 }, /* 7 */
+	{PD_ATTR_ID_FP_PWR_T3,       2,     0 }, /* 8 */
+	{PD_ATTR_ID_FP_PWR_T4,       2,     0 }, /* 9 */
+	{PD_ATTR_ID_FP_PWR_T5,       2,     0 }  /* 10 */
+};
+/* End of Tables required by Optimization Code. internal_lvds_set_attrs() */
+
+int internal_lvds_set_attrs (void *context, unsigned long num, pd_attr_t *list)
+{
+	internal_lvds_context_t *pd_context = (internal_lvds_context_t *) context;
+	pd_attr_t      *attr       = NULL;
+	unsigned short i           = 0;
+	unsigned short j           = 0;
+	int            ret         = PD_SUCCESS;
+	/* no of case IDs in the global table */
+	int num_case_ids = sizeof(table_opt_data1)/sizeof(internal_lvds_opt_table_data_t);
+
+	/* basic parameter check */
+	if (!context || !num || !list) {
+		return PD_ERR_NULL_PTR;
+	}
+
+	PD_DEBUG("internal_lvds_set_attrs()\n");
+	for (i = 0; i < num; i++, list++) {
+
+		/* do nothing if the attribute has not been changed */
+		if (!(list->flags & PD_ATTR_FLAG_VALUE_CHANGED)) {
+			continue;
+		}
+
+		/* attributes can't be changed after init has been completed */
+		if (list->flags & PD_ATTR_FLAG_USER_INVISIBLE &&
+			pd_context->init_done) {
+			return PD_ERR_ATTR_CANT_CHANGE;
+		}
+
+		/* Set the internal attributes' list.  Note that although get_attr() can
+		 * return NULL theortically, it will not do so here because all the
+		 * attribute IDs in this switch statement comes from internal_lvds_attrs[],
+		 * a list that is automatically initialized into pd_context.  This is
+		 * why we are not checking for NULL after calling get_attr().
+		 */
+#if 0	/* ORIGINAL SWITCH STATEMENT */
+		switch (list->id) {
+			case PD_ATTR_ID_FP_PWR_T1:
+			case PD_ATTR_ID_FP_PWR_T2:
+			case PD_ATTR_ID_FP_PWR_T3:
+			case PD_ATTR_ID_FP_PWR_T4:
+			case PD_ATTR_ID_FP_PWR_T5:
+				/* current_value should not exceed the predefined max value */
+				attr = pd_get_attr(pd_context->attr_list, pd_context->num_attrs,
+					list->id, 0);
+				attr->current_value = LVDS_MIN(
+						((pd_range_attr_t *)list)->current_value,
+						attr->_pad1);
+				break;
+
+			case PD_ATTR_ID_PANEL_DEPTH:
+				attr = pd_get_attr(pd_context->attr_list, pd_context->num_attrs,
+					list->id, 0);
+				attr->current_value = list->current_value;
+				pd_context->panel_depth = (unsigned char) attr->current_value;
+				break;
+
+			case PD_ATTR_ID_2_CHANNEL_PANEL:
+				attr = pd_get_attr(pd_context->attr_list, pd_context->num_attrs,
+					list->id, 0);
+				attr->current_value = ((pd_bool_attr_t *)list)->current_value;
+				pd_context->dual_channel = (attr->current_value?1:0);
+				break;
+
+			case PD_ATTR_ID_LVDS_PANEL_TYPE:
+				attr = pd_get_attr(pd_context->attr_list, pd_context->num_attrs,
+					list->id, 0);
+				attr->current_value = ((pd_bool_attr_t *)list)->current_value;
+				pd_context->panel_type = (attr->current_value?1:0);
+				break;
+
+			case PD_ATTR_ID_PANEL_FIT:
+				attr = pd_get_attr(pd_context->attr_list, pd_context->num_attrs,
+					list->id, 0);
+				attr->current_value = ((pd_bool_attr_t *)list)->current_value;
+				pd_context->panel_fit = (attr->current_value?1:0);
+				break;
+
+			default:
+				/* do nothing if we have an unknown ID */
+				break;
+		}
+#endif
+		/* OPTIMIZATION CODE BEGINS FOR THE ABOVE SWITCH
+		 *----------------------------------------------
+		 * Step 1: First identify the code common to all case blocks.
+		 *         This we call it "common code block" Since this is to be
+		 *         executed by all the case blocks.
+		 *
+		 * Step 2: Group the cases into blocks based on how we can combine them
+		 *
+		 *         Eg: case 0: ptr->x = 1; break; // similar code
+		 *        case 1: ptr->y = 1; break; // similar code
+		 *  ------Combined block ----
+		 *        case 0:
+		 *        case 1: PTR_OFFSET_TYPE(ptr, table[i].offset) = 1; break;
+		 *        This is an important step because we save code space by
+		 *        mapping many cases to smaller number of blocks. In the above
+		 *        we use index to get the right offset of the ptr.
+		 *
+		 * Step 3: Assign block IDs to each block. Put the case ID, block ID
+		 *         and other information such as offsets of ptr in a global
+		 *         table.
+		 *
+		 * Step 4: During run-time , search through the global table, find the
+		 *         matching case ID, and execute the common code. Next get the
+		 *         block ID and execute the block specific code. For the index,
+		 *         retrieve it from the table for the corresponding case ID.
+		 *
+		 * Step 5: If no matching case ID is found, error it out.
+		 *
+		 * Let's look at the optimization code for the above switch.
+		 * The code below searches for the list->id in a global table where
+		 * we store all the case values along with block numbers and other
+		 * information. After we find a valid id in the table , we execute the
+		 * common code for all cases first and then we retrieve the block id.
+		 * The block id is necesary to determine which block does the id belong
+		 * to. This is used to execute block specific code. Similar to switch
+		 * cases ONLY here we try to minimize the no of blocks.
+		 *
+		 * In this example , we store the offsets of field names of a ptr in the
+		 * global table.This is necessary to combine cases with "similar" but
+		 * not "same" codes.
+		 *
+		 * Eg: case 0: ptr->x = 1; break; // similar code
+		 *     case 1: ptr->y = 1; break; // similar code
+		 *  -- Combined block ----
+		 *    case 0:
+		 *    case 1: PTR_OFFSET_TYPE(ptr, table[i].offset) = 1; break;
+		 *
+		 * By reducing the number of blocks we save on Code space. After we
+		 * finish our work , we exit the for loop and check for invalid ID
+		 * passed by the upper layer. This is akin to default in the
+		 * switch block
+		 *
+		 * CAUTION: If there is any change in the switch above, this code
+		 * along with the tables have to be re-written and changed according
+		 * to the new behaviour of the switch. Examples include adding a new
+		 * case in the switch. The reason for all this mumbo-jumbo is to
+		 * reduce code size in VBIOS, where we are running out of code space.
+		 */
+		for(j = 0; j < num_case_ids; j++) {
+			/* Search for the attribute ID in the global table */
+			if(list->id == table_opt_data1[j].id) {
+				/* Run the common code for all the blocks */
+				attr = pd_get_attr(pd_context->attr_list, pd_context->num_attrs,
+					list->id, 0);
+				/* Once we get a valid ID, need to find out which block it
+				 *  belongs so we can execute block specific code.
+				 */
+				if(table_opt_data1[j].block == 1) { /* block 1 */
+					/* Got the block. Need the offset to the struct for that ID
+					* so we can store value at corresponding offset to get the
+					* desired behaviour for that ID.This is the code that makes
+					* the whole optimization work because we are combining the
+					* case IDs into a single block which saves code.
+					*/
+					attr->current_value = list->current_value;
+					PTR_OFFSET_USHORT(pd_context, table_opt_data1[j].offset) =
+					(unsigned short) attr->current_value;
+
+				} else { /* block 2. We only have two blocks. */
+					attr->current_value = LVDS_MIN(
+						list->current_value, ((pd_range_attr_t *)attr)->max);
+				}
+				break; /* We found a valid ID, so break inner for loop */
+			}
+		}
+	}
+	/* panel_type 0 (SPWG) isn't available for 18-bit depth */
+	PD_DEBUG("in LVDS_set_attributes()\n");
+	if (pd_context->panel_depth == 18) {
+		pd_context->panel_type = 1;
+	}
+	PD_DEBUG("IntLVDS: dual_channel=%u", pd_context->dual_channel);
+	PD_DEBUG("IntLVDS: panel_type=%u panel_fit=%u panel_dep=%u dither=%u",
+		pd_context->panel_type, pd_context->panel_fit,
+		pd_context->panel_depth, pd_context->dither);
+	PD_DEBUG("IntLVDS: keep_aspect_ratio=%u text_tune=%lu",
+		pd_context->aspect_ratio, pd_context->text_tune);
+	PD_DEBUG("IntLVDS: PWM Intensity=%u Inverter Freq=%u, BLM legacy mode =%u",
+		pd_context->pwm_intensity, pd_context->inverter_freq,
+		pd_context->blm_legacy_mode);
+	PD_DEBUG("IntLVDS: tc_110MHz_clk = %u", pd_context->tc_110MHz_clk);
+
+	if (pd_context->init_done) {
+		/* When emgd_driver_pre_init() pokes new attrs into this port driver,
+		 * pd_context->current_mode must be set before calling
+		 * internal_lvds_panel_fit(), so set it to the first entry in the timing table:
+		 */
+		if (pd_context->current_mode == NULL) {
+			pd_context->current_mode = pd_context->timing_table;
+		}
+		internal_lvds_panel_fit(pd_context);
+	}
+
+	return ret;
+} /* internal_lvds_set_attrs */
+
+/*----------------------------------------------------------------------------
+ *
+ * Function: internal_lvds_get_attrs
+ *
+ * Description:
+ *    Extracts the attribute list and the number of elements in the list
+ *    from the device context.
+ *
+ * Parameters:
+ *    [IN] context: device context to extract information from
+ *    [OUT] num:    number of elements in list
+ *    [OUT] list:   list of attributes from the device context
+ *
+ * Return:
+ *    PD_ERR_NULL_PTR: if one of the parameters is invalid
+ *    PD_SUCCESS:      if successful
+ *
+ *----------------------------------------------------------------------------
+ */
+int internal_lvds_get_attrs (void *context, unsigned long *num, pd_attr_t **list)
+{                                                         /* internal_lvds_get_attrs */
+	/* basic parameter check */
+	if (!context || !num || !list) {
+		return PD_ERR_NULL_PTR;
+	}
+
+	PD_DEBUG("internal_lvds_get_attrs()\n");
+	/* Nothing fancy, just extracting the elements from the list */
+	*list = ((internal_lvds_context_t *)context)->attr_list;
+	*num  = ((internal_lvds_context_t *)context)->num_attrs;
+
+	return PD_SUCCESS;
+}                                                         /* internal_lvds_get_attrs */
+
+/*----------------------------------------------------------------------------
+ *
+ * Function: internal_lvds_get_timing_list
+ *
+ * Description:
+ *
+ *
+ * Parameters:
+ *    [IN] context: device context to extract information from
+ *    [OUT] in_list:
+ *    [OUT] list:
+ *
+ * Return:
+ *    PD_ERR_NULL_PTR: if one of the parameters is invalid
+ *    PD_ERR_NOMEM:    if internal memory allocate failed
+ *    PD_SUCCESS:      if successful
+ *
+ *----------------------------------------------------------------------------
+ */
+int internal_lvds_get_timing_list (void *context, pd_timing_t *in_list,
+	pd_timing_t **list)
+{                                                   /* internal_lvds_get_timing_list */
+	internal_lvds_context_t *pd_context = (internal_lvds_context_t *)context;
+	pd_dvo_info_t internal_lvds_info = {0, 0, 1, 0, 0, 0, 0, 0};
+	pd_display_info_t internal_lvds_display_info = {0, 0, 0, 0, NULL};
+	int ret;
+
+	PD_DEBUG("internal_lvds_get_timing_list()\n");
+
+	internal_lvds_get_dclk( pd_context, &internal_lvds_info );
+
+	PD_DEBUG("chipset = 0x%x", pd_context->chipset);
+	internal_lvds_display_info.panel_fit = (unsigned char) pd_context->panel_fit;
+	ret = pd_filter_timings(pd_context->callback->callback_context,
+		in_list, &pd_context->timing_table, &internal_lvds_info, &internal_lvds_display_info);
+
+	/* Helper function will return the below values */
+	pd_context->native_dtd = internal_lvds_display_info.native_dtd;
+	pd_context->fp_width = internal_lvds_display_info.width;
+	pd_context->fp_height = internal_lvds_display_info.height;
+
+	*list = pd_context->timing_table;
+	return ret;
+}                                                   /* internal_lvds_get_timing_list */
+
+/*----------------------------------------------------------------------------
+ *
+ * Function: internal_lvds_set_power
+ *
+ * Description:
+ *  Sets LVDS to the specified power state
+ *
+ *  Conversion between IEGD timer values to LVDS port timer values
+ *
+ *  SEPG(?) IEGD    LVDS Port    Program bits     min     max
+ *  ----    ------- ------------ ---------------- ------ ---------
+ *  T1+T2   T1 ms   T1+T2 100us  0x61208 [28:16]  0 ms   819.2 ms
+ *  T5      T2 ms   T5    100us  0x61208 [12:00]  0 ms   819.2 ms
+ *  T6      T3 ms   Tx    100us  0x6120C [12:00]  0 ms   819.2 ms
+ *  T3      T4 ms   T3    100us  0x6120C [28:16]  0 ms   819.2 ms
+ *  T4      T5 ms   T4    100ms  0x61210 [04:00]  0 ms   3200  ms
+ *
+ *  Reg     = Value
+ *  ------    -------
+ *  0x61208 = [T1 T2]
+ *  0x6120C = [T4 T3]
+ *  0x61210 = [   T5]
+ *
+ * Parameters:
+ *    [IN] context: device context to extract information from
+ *    [OUT] in_list:
+ *    [OUT] list:
+ *
+ * Return:
+ *    PD_ERR_NULL_PTR:      if context is NULL
+ *    PD_ERR_INVALID_POWER: if "state" is invalid
+ *    PD_SUCCESS:           if successful
+ *
+ *----------------------------------------------------------------------------
+ */
+/* Tables required by the optimization codes in internal_lvds_set_power() */
+typedef struct {
+	unsigned char id1;
+	unsigned char id2;
+	unsigned char bit;
+	unsigned long reg;
+} opt_set_power_t;
+
+static opt_set_power_t table_set_power[] = {
+	/* id1                  id2                   bit    reg */
+	{ PD_ATTR_ID_FP_PWR_T1, PD_ATTR_ID_FP_PWR_T2, 1,     0x61208 },  /* D0 */
+	{ PD_ATTR_ID_FP_PWR_T4, PD_ATTR_ID_FP_PWR_T3, 0,     0x6120C },  /* Dx */
+};
+
+int internal_lvds_set_power(void *context, unsigned long state)
+{                                                         /* internal_lvds_set_power */
+	unsigned long  i           = 0;
+	internal_lvds_context_t *pd_context = (internal_lvds_context_t *)context;
+	pd_attr_t      *tattr      = NULL;  /* holds time delay b/ pwr transition */
+	unsigned long            delay = 0, delay1;
+
+	PD_DEBUG("state = %lu", state);
+
+	PD_DEBUG("internal_lvds_set_power() to state = %lu\n",state);
+	/* Basic parameter check */
+	if (!context) {
+		return PD_ERR_NULL_PTR;
+	}
+
+	/* Check for invalid state */
+	if (state > PD_POWER_MODE_D3) {
+		return PD_ERR_INVALID_POWER;
+	}
+
+	/* Get the index into above table */
+	if (state == PD_POWER_MODE_D0) {
+		i = 0;
+	} else {
+		i = 1;
+	}
+
+	internal_lvds_write_reg(pd_context, 0x61204, 0xABCD0000, 0xFFFFFFFF, PD_REG_MIO);
+
+	/* Program panel power up/down delays: Either T1/T2 or T3/T4*/
+	tattr = pd_get_attr(pd_context->attr_list,
+		pd_context->num_attrs, table_set_power[i].id1, 0);
+	/* Convert ms to 100us */
+	delay1 = tattr->current_value;
+	delay = (tattr->current_value * 10) << 16;
+	tattr = pd_get_attr(pd_context->attr_list,
+		pd_context->num_attrs, table_set_power[i].id2, 0);
+	delay1 += tattr->current_value;
+	delay |= tattr->current_value * 10;
+
+	internal_lvds_write_reg(pd_context, table_set_power[i].reg, delay, 0x1FFF1FFF, PD_REG_MIO);
+
+	/* Program power cycle delay: convert ms to 100ms */
+	delay = pd_get_attr(pd_context->attr_list,
+		pd_context->num_attrs, PD_ATTR_ID_FP_PWR_T5, 0)->current_value;
+	delay1 += delay;
+	/* TODO: Write reference divider [31:8] */
+	delay = ((delay/100+1) & 0xFF) | ((pd_context->gfx_freq*100/2-1)<<8);
+	internal_lvds_write_reg(pd_context, 0x61210, delay, 0xFFFFFFFF, PD_REG_MIO);
+
+	/* Power state target */
+	internal_lvds_write_reg(pd_context, 0x61204, table_set_power[i].bit, BIT(0), PD_REG_MIO);
+
+	/* Power down on reset available on crestline onwards */
+		internal_lvds_write_reg(pd_context, 0x61204, BIT(1), BIT(1), PD_REG_MIO);
+
+/* Make this a compile time so that size of vBIOS doesn't become > 64KB */
+#if defined(CONFIG_PLB) || defined(CONFIG_TNC)
+	/* PWM is a method of controlling the backlight intensity.
+	 * It is not method to turn on baclkight.
+	 * We still need the PD method to turn on the backlight.
+	 *
+	 * This feature is for Pouslbo Only. We check that the user has set the
+	 * inverter frequency. Default intensity, if not set, is 100%
+	 *
+	 * Due to the high amount of calculation, we want to only set this register
+	 * if it has not been ser previously. The register could be
+	 * "brought forward" from VBIOS.
+	 */
+	if(pd_context->inverter_freq != 0xFFFF &&  /* Overwritten by set_attr */
+		(pd_context->chipset == PCI_DEVICE_ID_VGA_PLB ||
+		 pd_context->chipset == PCI_DEVICE_ID_VGA_TNC ||
+		 pd_context->chipset == PCI_DEVICE_ID_VGA_TNC_A0 ||
+		 pd_context->chipset == PCI_DEVICE_ID_VGA_LNC) &&
+		 !pd_context->pwm_done) {
+		unsigned long reg_value = 0;
+		unsigned long percentage = 0;
+		unsigned long calculation = 0;
+		unsigned long blc_pwm_ctl2 = 0;
+
+		/* We first need to get the graphics frequency, which will be used to
+		 * calculate Backlight Modulation Frequency[BMF]. BMF will be used to
+		 * fill up the 15 MSB in the 0x61254 register
+		 *
+		 * The calculation for the Modulation Frequency field in the
+		 * BLC_PWM_CTL Register is:
+		 *
+         *     Reference Clock Freq               1
+         *     -----------------------   x    ------------------
+         *            Divider                   PWM Freq in Hz
+		 *
+		 */
+#if 0
+		/* GMA accurate calculation that requires "calculation" to be an
+		 * unsigned long long typedef */
+		calculation = pd_context->gfx_freq * PWM_FREQ_CALC_CONSTANT_2;
+		calculation = calculation / 0x20; /*pouslbo specific divider*/
+		calculation = calculation * PWM_FREQ_CALC_CONSTANT_1;
+		calculation = calculation / pd_context->inverter_freq;
+		calculation = calculation / PWM_FREQ_CALC_CONSTANT_1;
+#endif
+		/* Some system bios cannot take 64 bit data type. Using a more
+		 * simplified calculation that is not too accurate if the inputs
+		 * are not round numbers */
+		calculation = pd_context->inverter_freq * 0x20; /* plb/tnc divider */
+		calculation = (pd_context->gfx_freq * PWM_FREQ_CALC_CONSTANT_2) /
+			calculation;
+
+		/* Writing the register: 15 MSB is the max lvds clock / 32.
+		* Bit 16 can either be legacy or non legacy depending upon Attr #72. */
+		if (pd_context->gn4_plus) {
+			blc_pwm_ctl2 = (1L << 31) |
+				(pd_context->blm_legacy_mode << 30) |
+				((pd_context->pipe == PD_SET_MODE_PIPE_B)?1L:0L << 29);
+			internal_lvds_write_reg(pd_context, 0x61250, blc_pwm_ctl2, 0xFFFFFFFF, PD_REG_MIO);
+			reg_value = (calculation & 0xFFFF)<<16;
+		} else {
+			reg_value = ((calculation & 0xFFFE) |
+				pd_context->blm_legacy_mode)<<16;
+		}
+
+		/* The 16 LSB is a value that the user sets in configuration.
+		 * user sets the value in percentage.
+		 * We convert it into the clock speed */
+		percentage = ( pd_context->pwm_intensity * (unsigned long)calculation);
+		reg_value |= (unsigned long)( percentage / (int)100 ) & 0xFFFE;
+		internal_lvds_write_reg(pd_context, 0x61254, reg_value, 0xFFFFFFFF, PD_REG_MIO);
+
+		/* set the flag so that we only do this function once */
+		pd_context->pwm_done = 1;
+	}
+#endif
+
+	if (state != PD_POWER_MODE_D0) {
+		/* Wait until the current power up/down sequence is complete */
+		i = 0;
+		while(internal_lvds_read_reg(pd_context, 0x61200, PD_REG_MIO) & 0x80000000L) {
+			i++;
+			if(i > 0x100000L) {
+				break;
+			}
+		}
+		internal_lvds_write_reg(pd_context, 0x61180, 0, BIT(31), PD_REG_MIO);
+		//pd_usleep(delay1*1000);
+	}
+
+#ifdef CONFIG_TNC
+#if 0
+
+/*-----------------------------------------------------------------------------
+ * LPC Register Offsets. Used for LVDS BKLT control. Registers are part
+ * Atom E6xx [D31:F0]
+ ----------------------------------------------------------------------------*/
+#define RGEN    0x20
+#define RGIO    0x24
+#define RGLVL   0x28
+#define TNC_LVDS_VDDEN	 BIT(0)
+#define TNC_LVDS_BKLTEN  BIT(1)
+#define TNC_LVDS_BKLTCTL BIT(2)
+
+	if (pd_context->chipset == PCI_DEVICE_ID_VGA_TNC ||
+		pd_context->chipset == PCI_DEVICE_ID_VGA_TNC_A0 ||
+		pd_context->chipset == PCI_DEVICE_ID_VGA_LNC) {
+		unsigned long value;
+
+		/* Enable backlight for LVDS: based on observed si behavior:
+		 * Subject to change based on si DE feedback */
+		if (state == PD_POWER_MODE_D0) {
+			value = TNC_LVDS_BKLTCTL|TNC_LVDS_BKLTEN|TNC_LVDS_BKLTCTL;
+		} else {
+			value = 0;
+		}
+		internal_lvds_write_reg(pd_context, RGEN, value,
+			TNC_LVDS_BKLTCTL|TNC_LVDS_BKLTEN|TNC_LVDS_BKLTCTL, PD_REG_LPC);
+		internal_lvds_write_reg(pd_context, RGIO, value,
+			TNC_LVDS_BKLTCTL|TNC_LVDS_BKLTEN|TNC_LVDS_BKLTCTL, PD_REG_LPC);
+	}
+#endif
+#endif
+
+	/* update power state */
+	pd_context->power_state = state;
+	return PD_SUCCESS;
+}                                                         /* internal_lvds_set_power */
+
+/*----------------------------------------------------------------------------
+ *
+ * Function: internal_lvds_get_power
+ *
+ * Description:
+ *   Returns the current LVDS power state back to the caller.
+ *
+ * Parameters:
+ *    [IN] context: device context to extract information from
+ *    [OUT] state:  current power state
+ *
+ * Return:
+ *    PD_ERR_NULL_PTR:      if one of the parameters is invalid
+ *    PD_SUCCESS:           if successful
+ *
+ *----------------------------------------------------------------------------
+ */
+
+int internal_lvds_get_power (void *context, unsigned long *state)
+{                                                         /* internal_lvds_get_power */
+	if ((NULL == context) || (NULL == state)) {
+		return PD_ERR_NULL_PTR;
+	}
+	PD_DEBUG("internal_lvds_get_power()\n");
+	/* The caller should be able to do this himself, but whatever */
+	*state = ((internal_lvds_context_t *) context)->power_state;
+	return PD_SUCCESS;
+}                                                         /* internal_lvds_get_power */
+
+int internal_lvds_save(void *context, void **state, unsigned long flags)
+{
+	*state = NULL;
+	return PD_SUCCESS;
+}
+
+int internal_lvds_restore(void *context, void *state, unsigned long flags)
+{
+	int ret = PD_SUCCESS;
+	return ret;
+}
+
+/*----------------------------------------------------------------------
+ * Function: internal_lvds_get_port_status()
+ *
+ * Description:  It is called to get the information about the display
+ *
+ * Parameters:  context - Port driver's context
+ *				port_status - Returns the display type and connection state
+ *
+ * Return:      PD_SUCCESS(0)  success
+ *              PD_ERR_XXXXXX  otherwise
+ *----------------------------------------------------------------------*/
+int internal_lvds_get_port_status(void *context, pd_port_status_t *port_status)
+{
+	/* Display connection cannot be determined */
+	port_status->display_type = PD_DISPLAY_LVDS_INT;
+	port_status->connected    = PD_DISP_STATUS_UNKNOWN;
+	return PD_SUCCESS;
+}
+
+static unsigned long internal_lvds_read_reg(internal_lvds_context_t *pd_context,unsigned long reg,
+	unsigned long reg_type)
+{
+	pd_reg_t list[2];
+	int ret;
+
+	list[0].reg = reg;
+	list[0].value = 0;
+	list[1].reg = PD_REG_LIST_END;
+	ret = pd_context->callback->read_regs(
+		pd_context->callback->callback_context, list, reg_type);
+	if (ret) {
+		PD_ERROR("LVDS read regs: Failed.");
+	}
+	return list[0].value;
+}
+
+/*----------------------------------------------------------------------------
+ *
+ * Function: internal_lvds_write_reg
+ *
+ * Description:
+ *    Writes bits in "value" into a register.  Bits written are dictated by
+ *    the "change_bits" mask.
+ *
+ * Parameters:
+ *    [IN] pd_context:  device context, dispatcher to the actual write_reg
+ *                      function
+ *    [IN] reg:  register to write value to
+ *    [IN] value:  value to change the register to
+ *    [IN] change_bits:  bit mask, the bits set to "1" will be modified by
+ *                       the corresponding bits in "value"
+ *
+ * Return:
+ *    None
+ *
+ *----------------------------------------------------------------------------
+ */
+static void internal_lvds_write_reg(internal_lvds_context_t *pd_context, unsigned long reg,
+		unsigned long value,
+		unsigned long change_bits,
+		unsigned long reg_type)
+{                                                         /* internal_lvds_write_reg */
+	pd_reg_t list[2];
+	int ret;
+
+	list[0].reg = reg;
+	list[0].value = (internal_lvds_read_reg(pd_context, reg, PD_REG_MIO) & ~change_bits) | value;
+	list[1].reg = PD_REG_LIST_END;
+	ret = pd_context->callback->write_regs(
+		pd_context->callback->callback_context, list, reg_type);
+	if (ret) {
+		PD_ERROR("LVDS write regs: Failed.");
+	}
+	return;
+}                                                         /* internal_lvds_write_reg */
+
+/*----------------------------------------------------------------------------
+ *
+ * Function: internal_lvds_panel_fit
+ *
+ * Description:
+ *    Enables panel fitting
+ *
+ * Parameters:
+ *    [IN] pd_context:  device context
+ *
+ * Return:
+ *    None
+ *
+ *----------------------------------------------------------------------------
+ */
+static void internal_lvds_panel_fit(internal_lvds_context_t *pd_context)
+{
+	/* enable auto vertical ratio */
+	/* enable auto horizantal ratio */
+	/* no dither */
+	unsigned long panel_fit_reg = 0x00000220;
+	PD_DEBUG("internal_lvds_panel_fit() \n");
+
+	PD_TRACE_ENTER;
+
+	if (pd_context->current_mode->width != pd_context->fp_width ||
+		pd_context->current_mode->height != pd_context->fp_height) {
+		/* Enable panel fitting */
+		/* vertical interpolation = bilinear */
+		/* horizontal interpolation = bilinear */
+		panel_fit_reg |= 0x80000440;
+	}
+	/* Enable dither based on default/user-set value:
+	 *   By default
+	 *        dither = 1 for 18-bit panels
+	 *               = 0 for 24-bit panels.
+	 *   But this behavior can be changed by setting the DITHER attribute.
+	 *        When user sets the attribute, dither will be updated
+	 *        as part of attribute processing in set attributes. */
+	/* For gn4 based chipsets dither is controlled in port_control register */
+	if (!pd_context->gn4_plus) {
+		/* Default behavior */
+		if (pd_context->panel_depth == 18) {
+			panel_fit_reg |= BIT(3);
+		}
+
+		/* Overwritten by set attribute */
+		if (pd_context->dither != 0xFFFF) {
+			if (pd_context->dither) {
+				panel_fit_reg |= BIT(3);
+			} else {
+				panel_fit_reg &= ~BIT(3);
+			}
+		}
+	}
+
+	if (pd_context->gn4_plus) {
+		unsigned long src_ratio, dest_ratio;
+		panel_fit_reg = 0;
+		if (pd_context->native_dtd &&
+			(pd_context->current_mode->width != pd_context->native_dtd->width ||
+			pd_context->current_mode->height !=
+				pd_context->native_dtd->height)) {
+			/* Enable panel fitter */
+			panel_fit_reg = 0x80000000;
+
+			/* Select the pipe */
+			if (pd_context->pipe & PD_SET_MODE_PIPE_B) {
+				panel_fit_reg |= BIT(29);   /* bits[30:29] = 01 for pipe B */
+			}
+
+			/* Scaling mode:
+			 *    Default - Auto scaling src_ratio == dest_ratio
+			 *    Piller box scaling - src_ratio < dest_ratio
+			 *    Letter box scaling - src_ratio > dest_ratio */
+
+			/* To make this work correctly, port driver shall know the
+			 * size of the framebuffer, not the src mode. Most of the
+			 * times the src mode is fb, but not all the cases.
+			 * User has an attribute to change
+			 *    1. Between Pillerbox and auto, and vice versa
+			 *                and
+			 *    2. Between Letterbox and auto, and vice versa.
+			 */
+			if (pd_context->aspect_ratio) {
+				src_ratio = (pd_context->current_mode->width << 10)/
+					(pd_context->current_mode->height);
+				dest_ratio = (pd_context->native_dtd->width << 10)/
+					(pd_context->native_dtd->height);
+
+				if (dest_ratio > src_ratio) {
+					/* Pillarbox scaling */
+					panel_fit_reg |= BIT(27);
+				} else if (dest_ratio < src_ratio) {
+					/* Letterbox scaling */
+					panel_fit_reg |= BIT(27) | BIT(26);
+				}
+			}
+
+			/* Filter coefficient select: pd_context->text_tune = 0,1,2 */
+			panel_fit_reg |= (pd_context->text_tune << 24);
+		}
+	}
+
+	internal_lvds_write_reg(pd_context, 0x61230, panel_fit_reg, 0xFFFFFFFF, PD_REG_MIO);
+	PD_DEBUG("panel_fit_reg 0x61230 = 0x%lx", panel_fit_reg);
+}
+
+
+/*----------------------------------------------------------------------------
+ *
+ * Function: internal_lvds_get_dclk
+ *
+ * Description:
+ *    Gets the Dclk for LVDS
+ *
+ * Parameters:
+ *    [IN] pd_context:  device context
+ *	  [OUT]internal_lvds_info:   Structure that contains the min and max dclk
+ *
+ * Return:
+ *    None
+ *
+ *----------------------------------------------------------------------------
+ */
+static void internal_lvds_get_dclk(internal_lvds_context_t *pd_context, pd_dvo_info_t *internal_lvds_info )
+{
+	PD_DEBUG("internal_lvds_get_dclk()\n");
+	/* Get the min and max dclks for lvds */
+	if (pd_context->dual_channel) {
+		internal_lvds_info->min_dclk = LVDS_MIN_DCLK * 2 ;
+		internal_lvds_info->max_dclk = LVDS_MAX_DCLK * 2;
+	} else {
+		internal_lvds_info->min_dclk = LVDS_MIN_DCLK;
+		internal_lvds_info->max_dclk = LVDS_MAX_DCLK;
+	}
+	/* This #define is the result of code size reduction effort. */
+#ifdef CONFIG_CTG
+	/* Set dclk for GM965 */
+	if(pd_context->chipset==PCI_DEVICE_ID_VGA_CTG){
+		/* Set dclk for GM965/CTG */
+		if (pd_context->dual_channel) {
+			internal_lvds_info->min_dclk = LVDS_GM965_DUAL_MIN_DCLK ;
+			internal_lvds_info->max_dclk = LVDS_GM965_DUAL_MAX_DCLK;
+		} else {
+			internal_lvds_info->min_dclk = LVDS_GM965_SINGLE_MIN_DCLK;
+			internal_lvds_info->max_dclk = LVDS_GM965_SINGLE_MAX_DCLK;
+		}
+	}
+#else
+
+	/* Set dclk for 915GM */
+	if(pd_context->chipset==PCI_DEVICE_ID_VGA_915AL){
+		if (pd_context->dual_channel) {
+			internal_lvds_info->min_dclk = LVDS_915GM_DUAL_MIN_DCLK ;
+			internal_lvds_info->max_dclk = LVDS_915GM_DUAL_MAX_DCLK;
+		} else {
+			internal_lvds_info->min_dclk = LVDS_915GM_SINGLE_MIN_DCLK;
+			internal_lvds_info->max_dclk = LVDS_915GM_SINGLE_MAX_DCLK;
+		}
+	} else if(pd_context->chipset==PCI_DEVICE_ID_VGA_945GM ||
+				pd_context->chipset==PCI_DEVICE_ID_VGA_945GME){
+		/* Set dclk for 945GM */
+		if (pd_context->dual_channel) {
+			internal_lvds_info->min_dclk = LVDS_945GM_DUAL_MIN_DCLK ;
+			internal_lvds_info->max_dclk = LVDS_945GM_DUAL_MAX_DCLK;
+		} else {
+			internal_lvds_info->min_dclk = LVDS_945GM_SINGLE_MIN_DCLK;
+			internal_lvds_info->max_dclk = LVDS_945GM_SINGLE_MAX_DCLK;
+		}
+	} else if(pd_context->chipset==PCI_DEVICE_ID_VGA_GM965 ||
+				pd_context->chipset==PCI_DEVICE_ID_VGA_GME965){
+		/* Set dclk for GM965 */
+		if (pd_context->dual_channel) {
+			internal_lvds_info->min_dclk = LVDS_GM965_DUAL_MIN_DCLK ;
+			internal_lvds_info->max_dclk = LVDS_GM965_DUAL_MAX_DCLK;
+		} else {
+			internal_lvds_info->min_dclk = LVDS_GM965_SINGLE_MIN_DCLK;
+			internal_lvds_info->max_dclk = LVDS_GM965_SINGLE_MAX_DCLK;
+		}
+	}
+#endif
+
+#ifdef CONFIG_TNC
+	/* Get the min and max dclks for Atom E6xx lvds */
+	if ((pd_context->chipset == PCI_DEVICE_ID_VGA_TNC) ||
+	    (pd_context->chipset == PCI_DEVICE_ID_VGA_TNC_A0) ||
+	    (pd_context->chipset == PCI_DEVICE_ID_VGA_LNC)) {
+		internal_lvds_info->min_dclk = LVDS_TNC_SINGLE_MIN_DCLK;
+		/* Experimental feature to raise TC LVDS clk to 110MHz. */
+		if (pd_context->tc_110MHz_clk) {
+			internal_lvds_info->max_dclk = 110000L;
+		} else {
+			internal_lvds_info->max_dclk = LVDS_TNC_SINGLE_MAX_DCLK;
+		}
+
+	}
+#endif
+
+}
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/lvds/lvds.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/lvds/lvds.h
new file mode 100644
index 0000000..4f6c6d10
--- /dev/null
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/lvds/lvds.h
@@ -0,0 +1,167 @@
+/* -*- pse-c -*-
+ *-----------------------------------------------------------------------------
+ * Filename: lvds.h
+ * $Revision: 1.2 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2010, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ * Description:
+ *  This is header file for Internal LVDS PORT DRIVER.
+ *-----------------------------------------------------------------------------
+ */
+
+#ifndef _PD_LVDS_H
+#define _PD_LVDS_H
+
+#include <pd.h>
+#include <pci.h>
+
+/* Values received from DPG hardware engineer. These are for single channel.  */
+
+#ifndef PCI_DEVICE_ID_VGA_855
+#define PCI_DEVICE_ID_VGA_855      0x3582
+#endif
+#ifndef PCI_DEVICE_ID_VGA_915AL
+#define PCI_DEVICE_ID_VGA_915AL    0x2592
+#endif
+#ifndef PCI_DEVICE_ID_VGA_945GM
+#define PCI_DEVICE_ID_VGA_945GM    0x27A2
+#endif
+#ifndef PCI_DEVICE_ID_VGA_945GME
+#define PCI_DEVICE_ID_VGA_945GME   0x27AE
+#endif
+#ifndef PCI_DEVICE_ID_VGA_GM965
+#define PCI_DEVICE_ID_VGA_GM965    0x2A02
+#endif
+#ifndef PCI_DEVICE_ID_VGA_GME965
+#define PCI_DEVICE_ID_VGA_GME965   0x2A12
+#endif
+#ifndef PCI_DEVICE_ID_VGA_CTG
+#define PCI_DEVICE_ID_VGA_CTG      0x2A42
+#endif
+#ifndef PCI_DEVICE_ID_VGA_PLB
+#define PCI_DEVICE_ID_VGA_PLB      0x8108
+#endif
+#ifndef PCI_DEVICE_ID_VGA_PNVM
+#define PCI_DEVICE_ID_VGA_PNVM     0xA011
+#endif
+#ifndef PCI_DEVICE_ID_VGA_TNC
+#define PCI_DEVICE_ID_VGA_TNC      0x4108
+#endif
+#ifndef PCI_DEVICE_ID_VGA_TNC_A0
+#define PCI_DEVICE_ID_VGA_TNC_A0   0x4100
+#endif
+#ifndef PCI_DEVICE_ID_VGA_LNC
+#define PCI_DEVICE_ID_VGA_LNC      0x4102
+#endif
+
+
+#define LVDS_MIN_DCLK 12000L    /* in KHz */
+#define LVDS_MAX_DCLK 112000L   /* in KHz */
+/* definition for 915GM */
+#define LVDS_915GM_SINGLE_MIN_DCLK   20000L
+#define LVDS_915GM_SINGLE_MAX_DCLK  112000L
+#define LVDS_915GM_DUAL_MIN_DCLK     25000L
+#define LVDS_915GM_DUAL_MAX_DCLK    224000L
+
+/* definition for 945GM */
+#define LVDS_945GM_SINGLE_MIN_DCLK   25000L
+#define LVDS_945GM_SINGLE_MAX_DCLK  112000L
+#define LVDS_945GM_DUAL_MIN_DCLK     25000L
+#define LVDS_945GM_DUAL_MAX_DCLK    224000L
+
+/* definition for GM965 */
+#define LVDS_GM965_SINGLE_MIN_DCLK   25000L
+#define LVDS_GM965_SINGLE_MAX_DCLK  112000L
+#define LVDS_GM965_DUAL_MIN_DCLK     25000L
+#define LVDS_GM965_DUAL_MAX_DCLK    224000L
+
+/* definition for Atom E6xx */
+#define LVDS_TNC_SINGLE_MIN_DCLK     19750L
+#define LVDS_TNC_SINGLE_MAX_DCLK     79500L
+
+#define LVDS_MIN(a, b)       ((a)<(b)?(a):(b))
+
+/* Local attributes
+ * BIT15 of attribute Id specifies that it is a local attribute */
+#define LVDS_ATTR_ID_DATA_FORMAT   (BIT(15)|1)
+#define LVDS_ATTR_ID_TC_LVDS_CLK   (BIT(15)|2)
+
+/* Default values */
+#define LVDS_DEF_PANEL_DEPTH    18      /* Default panel depth */
+#define LVDS_DEF_DITHER          1      /* default=1 as default panel depth=18*/
+#define LVDS_DEF_SCALE_ON        1      /* Default scaling is on */
+#define LVDS_DEF_PANEL_FIT       1      /* Default panel fit in on */
+
+typedef struct _internal_lvds_context {
+	unsigned short fp_width;
+	unsigned short fp_height;
+	unsigned short dual_channel;
+	unsigned short panel_type;
+	unsigned short panel_fit;
+	unsigned short panel_depth;
+	unsigned short dither;
+	unsigned short aspect_ratio;
+	unsigned long  text_tune;
+	unsigned long  pwm_intensity;
+	unsigned long  inverter_freq;
+	unsigned long  blm_legacy_mode;
+
+	unsigned long power_state;
+	unsigned short chipset;
+	unsigned char init_done;
+	unsigned char num_attrs;
+	unsigned long pipe;
+	unsigned short gfx_freq;
+	unsigned char gn4_plus;
+	unsigned char pwm_done;
+	unsigned char tc_110MHz_clk;
+
+	pd_callback_t *callback;
+	pd_timing_t   *timing_table;
+	pd_attr_t     *attr_list;
+	pd_timing_t   *native_dtd;
+	pd_timing_t   *current_mode;
+} internal_lvds_context_t;
+
+extern int PD_MODULE_INIT(internal_lvds_init, (void *handle));
+extern int PD_MODULE_EXIT(internal_lvds_exit, (void));
+extern unsigned long internal_lvds_validate(unsigned long cookie);
+extern int internal_lvds_open(pd_callback_t *callback, void **context);
+extern int internal_lvds_init_device(void *context);
+extern int internal_lvds_close(void *context);
+extern int internal_lvds_set_mode(void *context, pd_timing_t *mode,
+			unsigned long flags);
+extern int internal_lvds_post_set_mode(void *context, pd_timing_t *mode,
+			unsigned long flags);
+extern int internal_lvds_set_attrs(void *context, unsigned long num, pd_attr_t *list);
+extern int internal_lvds_get_attrs(void *context, unsigned long*num, pd_attr_t **list);
+extern int internal_lvds_get_timing_list(void *context, pd_timing_t *in_list,
+			pd_timing_t **list);
+extern int internal_lvds_set_power(void *context, unsigned long state);
+extern int internal_lvds_get_power(void *context, unsigned long *state);
+extern int internal_lvds_save(void *context, void **state, unsigned long flags);
+extern int internal_lvds_restore(void *context, void *state, unsigned long flags);
+extern int internal_lvds_get_port_status(void *context, pd_port_status_t *port_status);
+
+#endif
+
diff --git a/drivers/gpu/drm/emgd/emgd/pal/lpd/lpd.c b/drivers/gpu/drm/emgd/emgd/pal/lpd/lpd.c
index af277d5..a180772 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/lpd/lpd.c
+++ b/drivers/gpu/drm/emgd/emgd/pal/lpd/lpd.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: lpd.c
- * $Revision: 1.9 $
+ * $Revision: 1.10 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/pal/lpd/pd_print.h b/drivers/gpu/drm/emgd/emgd/pal/lpd/pd_print.h
index 672194c..8893e1b 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/lpd/pd_print.h
+++ b/drivers/gpu/drm/emgd/emgd/pal/lpd/pd_print.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: pd_print.h
- * $Revision: 1.7 $
+ * $Revision: 1.9 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -63,9 +63,3 @@ extern void pd_trace_exit(const char *funcname);
 
 #endif
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: pd_print.h,v 1.7 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/pal/lpd/pd_print.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/pal/lvds/lvds.c b/drivers/gpu/drm/emgd/emgd/pal/lvds/lvds.c
index 2be8e22..b67a992 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/lvds/lvds.c
+++ b/drivers/gpu/drm/emgd/emgd/pal/lvds/lvds.c
@@ -1,9 +1,9 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: lvds.c
- * $Revision: 1.15 $
+ * $Revision: 1.18 $
  *-----------------------------------------------------------------------------
- * Copyright  2002-2010, Intel Corporation.
+ * Copyright (c) 2002-2010, Intel Corporation.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -466,6 +466,7 @@ int lvds_close(void *device_context)
 	if (device_context) {
 		if ( NULL != pd_context->timing_table) {
 			pd_free(pd_context->timing_table);
+			pd_context->timing_table = NULL;
 		}
 
 		/* Free attribute list, if necessary */
@@ -654,6 +655,8 @@ int lvds_post_set_mode(void *context, pd_timing_t *mode, unsigned long flags)
 		}
 	}
 
+    lvds_write_reg(pd_context, 0x61204, 0xABCD0000, 0xFFFFFFFF, PD_REG_MIO);
+
 	lvds_write_reg(pd_context, 0x61180, port_control, 0xFFFFFFFF, PD_REG_MIO);
 	ret = lvds_set_power(pd_context, PD_POWER_MODE_D0);
 	if (ret) {
@@ -661,6 +664,9 @@ int lvds_post_set_mode(void *context, pd_timing_t *mode, unsigned long flags)
 		return ret;
 	}
 
+    lvds_write_reg(pd_context, 0x61204, BIT(1), BIT(1), PD_REG_MIO);
+
+
 	PD_TRACE_EXIT;
 	/* Set the mode as per given timings */
 	return PD_SUCCESS;
@@ -885,6 +891,11 @@ int lvds_set_attrs (void *context, unsigned long num, pd_attr_t *list)
 			}
 		}
 	}
+	/* panel_type 0 (SPWG) isn't available for 18-bit depth */
+	PD_DEBUG("in LVDS_set_attributes()\n");
+	if (pd_context->panel_depth == 18) {
+		pd_context->panel_type = 1;
+	}
 	PD_DEBUG("IntLVDS: dual_channel=%u", pd_context->dual_channel);
 	PD_DEBUG("IntLVDS: panel_type=%u panel_fit=%u panel_dep=%u dither=%u",
 		pd_context->panel_type, pd_context->panel_fit,
@@ -896,13 +907,6 @@ int lvds_set_attrs (void *context, unsigned long num, pd_attr_t *list)
 		pd_context->blm_legacy_mode);
 	PD_DEBUG("IntLVDS: tc_110MHz_clk = %u", pd_context->tc_110MHz_clk);
 
-	/* panel_type 0 (SPWG) isn't available for 18-bit depth */
-
-	PD_DEBUG("in LVDS_set_attributes()\n");
-	if (pd_context->panel_depth == 18) {
-		pd_context->panel_type = 1;
-	}
-
 	if (pd_context->init_done) {
 		/* When emgd_driver_pre_init() pokes new attrs into this port driver,
 		 * pd_context->current_mode must be set before calling
@@ -1056,11 +1060,14 @@ int lvds_set_power(void *context, unsigned long state)
 	PD_DEBUG("lvds_set_power() to state = %lu\n",state);
 	/* Basic parameter check */
 	if (!context) {
+		PD_DEBUG("No context");
 		return PD_ERR_NULL_PTR;
 	}
+	PD_DEBUG("pd_context=0x%lx", (unsigned long)pd_context);
 
 	/* Check for invalid state */
 	if (state > PD_POWER_MODE_D3) {
+		PD_DEBUG("Invalid power state");
 		return PD_ERR_INVALID_POWER;
 	}
 
@@ -1071,6 +1078,8 @@ int lvds_set_power(void *context, unsigned long state)
 		i = 1;
 	}
 
+	lvds_write_reg(pd_context, 0x61204, 0xABCD0000, 0xFFFFFFFF, PD_REG_MIO);
+
 	/* Program panel power up/down delays: Either T1/T2 or T3/T4*/
 	tattr = pd_get_attr(pd_context->attr_list,
 		pd_context->num_attrs, table_set_power[i].id1, 0);
@@ -1096,9 +1105,7 @@ int lvds_set_power(void *context, unsigned long state)
 	lvds_write_reg(pd_context, 0x61204, table_set_power[i].bit, BIT(0), PD_REG_MIO);
 
 	/* Power down on reset available on crestline onwards */
-	if (pd_context->gn4_plus) {
-		lvds_write_reg(pd_context, 0x61204, BIT(1), BIT(1), PD_REG_MIO);
-	}
+	lvds_write_reg(pd_context, 0x61204, BIT(1), BIT(1), PD_REG_MIO);
 
 /* Make this a compile time so that size of vBIOS doesn't become > 64KB */
 #if defined(CONFIG_PLB) || defined(CONFIG_TNC)
@@ -1334,6 +1341,8 @@ static void lvds_write_reg(lvds_context_t *pd_context, unsigned long reg,
 	pd_reg_t list[2];
 	int ret;
 
+	PD_DEBUG("ENTER");
+
 	list[0].reg = reg;
 	list[0].value = (lvds_read_reg(pd_context, reg, PD_REG_MIO) & ~change_bits) | value;
 	list[1].reg = PD_REG_LIST_END;
@@ -1342,6 +1351,7 @@ static void lvds_write_reg(lvds_context_t *pd_context, unsigned long reg,
 	if (ret) {
 		PD_ERROR("LVDS write regs: Failed.");
 	}
+	PD_DEBUG("EXIT");
 	return;
 }                                                         /* lvds_write_reg */
 
@@ -1543,9 +1553,3 @@ static void lvds_get_dclk(lvds_context_t *pd_context, pd_dvo_info_t *lvds_info )
 	}
 #endif
 }
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: lvds.c,v 1.15 2011/02/16 17:04:49 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/pal/lvds/lvds.c,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/pal/lvds/lvds.h b/drivers/gpu/drm/emgd/emgd/pal/lvds/lvds.h
index e23fc70..dd9cc87 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/lvds/lvds.h
+++ b/drivers/gpu/drm/emgd/emgd/pal/lvds/lvds.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: lvds.h
- * $Revision: 1.6 $
+ * $Revision: 1.8 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -162,9 +162,3 @@ extern int lvds_get_port_status(void *context, pd_port_status_t *port_status);
 
 #endif
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: lvds.h,v 1.6 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/pal/lvds/lvds.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo.def b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo.def
index ace81c6..f271b16 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo.def
+++ b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo.def
@@ -1,3 +1,23 @@
+# Copyright (c) 2002-2011, Intel Corporation.
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+# THE SOFTWARE.
+
 LIBRARY sdvo
 
 EXPORTS
diff --git a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_attr.c b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_attr.c
index 010f318..6d2d3c8 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_attr.c
+++ b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_attr.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: sdvo_attr.c
- * $Revision: 1.14 $
+ * $Revision: 1.16 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -1087,11 +1087,11 @@ unsigned long sdvo_get_bool_attrs(sdvo_device_context_t *p_ctx,
 		for (i = 0; i < ARRAY_SIZE(g_bool_data); i++) {
 			if((p_ctx->dev_cap.vendor_id == VENDOR_ID_OKI) &&
 				(p_ctx->dev_cap.device_id == 0x1) &&
-  	            ((g_bool_data[i].id == PD_ATTR_ID_PANEL_PROTECT_HSYNC) ||
-  	            (g_bool_data[i].id == PD_ATTR_ID_PANEL_PROTECT_VSYNC))) {
+	            ((g_bool_data[i].id == PD_ATTR_ID_PANEL_PROTECT_HSYNC) ||
+	            (g_bool_data[i].id == PD_ATTR_ID_PANEL_PROTECT_VSYNC))) {
 
-  	            continue;
-  	        }
+	            continue;
+	        }
 			status = sdvo_execute_command(p_ctx, g_bool_data[i].opcode_get,
 						 0, NULL,
 						 1, &ret_value);
@@ -1119,11 +1119,11 @@ unsigned long sdvo_get_bool_attrs(sdvo_device_context_t *p_ctx,
 
 		if((p_ctx->dev_cap.vendor_id == VENDOR_ID_OKI) &&
 			(p_ctx->dev_cap.device_id == 0x1) &&
-  	        ((g_bool_data[i].id == PD_ATTR_ID_PANEL_PROTECT_HSYNC) ||
-  	        (g_bool_data[i].id == PD_ATTR_ID_PANEL_PROTECT_VSYNC))) {
+	        ((g_bool_data[i].id == PD_ATTR_ID_PANEL_PROTECT_HSYNC) ||
+	        (g_bool_data[i].id == PD_ATTR_ID_PANEL_PROTECT_VSYNC))) {
 
-  	        continue;
-  	    }
+	        continue;
+	    }
 
 
 		status = sdvo_query_bool_attr(p_ctx, p_attr_cur);
@@ -1482,9 +1482,3 @@ sdvo_status_t sdvo_alter_list_attr(sdvo_device_context_t *p_ctx,
 #endif
 	return SS_INVALID_ARGUMENT;
 }
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: sdvo_attr.c,v 1.14 2011/03/12 10:56:13 nanuar Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/pal/sdvo/sdvo_attr.c,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_attr.h b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_attr.h
index 8f98570..4c58315 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_attr.h
+++ b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_attr.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: sdvo_attr.h
- * $Revision: 1.6 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_hdmi.c b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_hdmi.c
index 941c36d..81dd8f7 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_hdmi.c
+++ b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_hdmi.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: sdvo_hdmi.c
- * $Revision: 1.6 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_hdmi.h b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_hdmi.h
index 7c80f1a..64c06c1 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_hdmi.h
+++ b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_hdmi.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: sdvo_hdmi.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_intf.c b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_intf.c
index ada6e8d..e2fb741 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_intf.c
+++ b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_intf.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: sdvo_intf.c
- * $Revision: 1.11 $
+ * $Revision: 1.12 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_intf.h b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_intf.h
index 49331ec..ba29814 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_intf.h
+++ b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_intf.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: sdvo_intf.h
- * $Revision: 1.7 $
+ * $Revision: 1.9 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -479,9 +479,3 @@ sdvo_status_t sdvo_execute_command_read(sdvo_device_context_t *p_ctx,
 
 #endif  /*  _SDVO_INTF_H_ */
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: sdvo_intf.h,v 1.7 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/pal/sdvo/sdvo_intf.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.c b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.c
index 8d42000..861ba5c 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.c
+++ b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: sdvo_port.c
- * $Revision: 1.23 $
+ * $Revision: 1.28 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -30,6 +30,9 @@
  */
 #include "sdvo_port.h"
 
+
+#include <linux/kernel.h>
+
 /* .......................................................................... */
 
 int sdvo_open(pd_callback_t *p_callback, void **p_context);
@@ -1829,6 +1832,14 @@ int sdvo_open(pd_callback_t *p_callback, void **pp_context)
 	*pp_context = p_ctx;
 	p_ctx->p_callback = p_callback;
 
+#ifndef CONFIG_MICRO
+	/* reset context to avoid wrong timing list */
+	if ((p_ctx->dev_cap.vendor_id != VENDOR_ID_OKI)
+		&& (p_ctx->dev_cap.device_id != 0x1)){
+		sdvo_reset_encoder(p_ctx);
+	}
+#endif
+
 	status = sdvo_get_device_capabilities(p_ctx, &p_ctx->dev_cap);
 	if (status != SS_SUCCESS) {
 
@@ -1865,7 +1876,20 @@ int sdvo_open(pd_callback_t *p_callback, void **pp_context)
 
 	/* ...................................................................... */
 	p_ctx->out_type = p_ctx->dev_cap.output;
-	status = sdvo_set_target_output(p_ctx, p_ctx->out_type);
+
+	/*Workaround:
+	 * st_sdvo has two potential modes lvds and rgba
+	 * As we dont have the relevant information from xorg (attr/9(
+	 * at this point to correctly identify which one the user wants
+	 * and as set target will fail if sent 2 output types
+	 * This if has been added
+	 */
+	if(!p_ctx->st_sdvo)
+	{
+		status = sdvo_set_target_output(p_ctx, p_ctx->out_type);
+
+	}
+
 	status = sdvo_get_supported_power_states(p_ctx, &p_ctx->supp_pwr_states);
 	if (status == SS_SUCCESS) {
 		PD_DEBUG("sdvo: Supported Power States = %#x",
@@ -1893,13 +1917,25 @@ int sdvo_open(pd_callback_t *p_callback, void **pp_context)
 			return PD_ERR_INTERNAL;
 		}
 
-		status = sdvo_set_target_output(p_ctx, p_ctx->out_type);
+
+
+		/*Workaround:
+			 * st_sdvo has two potential modes lvds and rgba
+			 * As we dont have the relevant information from xorg (attr/9(
+			 * at this point to correctly identify which one the user wants
+			 * and as set target will fail if sent 2 output types
+			 * This if has been added
+			 */
+		if(!p_ctx->st_sdvo)
+			status = sdvo_set_target_output(p_ctx, p_ctx->out_type);
+
 		if (status != SS_SUCCESS) {
 			PD_ERROR("sdvo: Error ! sdvo_set_mode: sdvo_set_target_output()"
 				"failed with status=%d", status);
 			return PD_ERR_INTERNAL;
 		}
 
+
 		/* ...................................................................... */
 		status = sdvo_get_supported_power_states(p_ctx, &p_ctx->supp_pwr_states);
 		if (status == SS_SUCCESS) {
@@ -2080,11 +2116,6 @@ int sdvo_get_timing_list(void *p_context, pd_timing_t *p_in_list,
 
 	PD_DEBUG("sdvo: sdvo_get_timing_list()");
 
-#ifndef CONFIG_MICRO
-	/* reset context to avoid wrong timing list */
-	sdvo_reset_encoder(p_context);
-#endif
-
 	/* ...................................................................... */
 	status = sdvo_set_target_input(p_ctx, p_ctx->inp_dev);
 	if (status != SS_SUCCESS) {
@@ -2251,7 +2282,16 @@ int sdvo_set_mode(void *p_context, pd_timing_t *p_mode, unsigned long flags)
 		return PD_ERR_INTERNAL;
 	}
 
-	status = sdvo_set_target_output(p_ctx, p_ctx->out_type);
+	/*Workaround:
+		 * st_sdvo has two potential modes lvds and rgba
+		 * As we dont have the relevant information from xorg (attr/9(
+		 * at this point to correctly identify which one the user wants
+		 * and as set target will fail if sent 2 output types
+		 * This if has been added
+		 */
+	if(!p_ctx->st_sdvo)
+		status = sdvo_set_target_output(p_ctx, p_ctx->out_type);
+
 	if (status != SS_SUCCESS) {
 		PD_ERROR("sdvo: Error ! sdvo_set_mode: sdvo_set_target_output()"
 				  "failed with status=%d", status);
@@ -2361,7 +2401,7 @@ int sdvo_set_mode(void *p_context, pd_timing_t *p_mode, unsigned long flags)
 	/*We want this in (Windows XP driver) AND
 	(in VBIOS when LVDS is not linked.)*/
 	/* This workaround needed for OKI solution only.
- 	It would probably give problem if the SDVO is connected to
+	It would probably give problem if the SDVO is connected to
 	analog display, but that is not the usage model for OKI.
 	*/
 	if ((p_ctx->dev_cap.vendor_id == VENDOR_ID_OKI)
@@ -2463,17 +2503,8 @@ int sdvo_post_set_mode(void *p_context, pd_timing_t *p_mode,
 						pd_get_attr(p_ctx->p_attr_table, p_ctx->num_attrs,
 						PD_ATTR_ID_RB_SWAP_MODE, 0 );
 
-			/*TODO: FIXME:*/
-			/* RB SWAP: We have more problem with SDVO
- 			* corruption when we write if the value is 1
- 			* on OKI board.However this current code is
- 			* not robust enough to handle if OKI decide
- 			* to change the default value. May need to fix
- 			* this in the future.*/
-
-			if (p_attr_temp->current_value == 0){
-				sdvo_alter_static_attr(p_ctx, p_attr_temp, p_attr_temp->current_value);
-			}
+			/* RB SWAP */
+			sdvo_alter_static_attr(p_ctx, p_attr_temp, p_attr_temp->current_value);
 
 			sdvo_set_mode(p_context, &local_p_mode,0);
 		} else {
@@ -2614,9 +2645,9 @@ int sdvo_get_attributes(void *p_context, unsigned long *p_num_attr,
 		&& p_ctx->dev_cap.device_id == 0x1){
 		/* 	TODO: sdvo_set_target_output return pending when the power state is D3 on
 		* 	ML7213 A0. other sdvo cards don't have this problem and OKI don't see
- 		* 	this problem on their site. verify this on A1 and remove the code if
- 		* 	it return success */
-  		sdvo_set_power(p_ctx, PD_POWER_MODE_D0);
+		* 	this problem on their site. verify this on A1 and remove the code if
+		* 	it return success */
+		sdvo_set_power(p_ctx, PD_POWER_MODE_D0);
 	}
 #endif
 
@@ -2712,8 +2743,10 @@ int sdvo_set_tv_settings(void *p_context, i2c_reg_t tv_format)
 int sdvo_set_attributes(void *p_context, unsigned long num_attrs,
 	pd_attr_t *p_list)
 {
+
 	sdvo_device_context_t *p_ctx = (sdvo_device_context_t *)p_context;
 	sdvo_status_t status;
+	sdvo_output_flags_t out_flags;
 	unsigned long i;
 	static unsigned char set_tvformat = 1;
 	unsigned short tvformat = 1;      /* Index 1 is for NTSC */
@@ -2721,6 +2754,7 @@ int sdvo_set_attributes(void *p_context, unsigned long num_attrs,
 	PD_DEBUG("sdvo: sdvo_set_attributes(): num_attrs=%ld", num_attrs);
 	/* Search for PD_ATTR_ID_DISPLAY in the incoming attribute table, if it   */
 	/* present and if sDVO supports > 1 displays use it to set TargetOutput   */
+	int found_display_setting = 0;
 	for (i = 0; i < num_attrs; i++) {
 		if ((p_list[i].flags & PD_ATTR_FLAG_VALUE_CHANGED) == 0) {
 			continue;
@@ -2736,10 +2770,75 @@ int sdvo_set_attributes(void *p_context, unsigned long num_attrs,
 				p_list[i].current_value);
 			/*	Clear attribute changed flag */
 			p_list[i].flags &= ~PD_ATTR_FLAG_VALUE_CHANGED;
+			found_display_setting = 1;
 			break;
 		}
 	}
 
+
+	/*in the situation where we have 2 potential outputs (e.g. lvds and drgb_
+	 * and a preference has not been set in the xorg
+	 * then we try and set an appropriate default, while outputting an error
+	 * message
+	 */
+	if(!found_display_setting && p_ctx->st_sdvo){
+			int defaultFound = 0;
+			printk("\n[EMGD] SDVO: ERROR !\n"
+					"\n\tALL/1/Port/2/Attr/9 is NOT set!"
+					"\n\tYou may want to set the value to either"
+					"\n\t\t0x40: for lvds "
+					"\n\tor"
+					"\n\t\t0x00: for VGA"
+					"\n\tCurrent Value: %x ",
+					 p_ctx->out_type.flags);
+
+			/*attempt default setting*/
+			out_flags.flags = p_ctx->out_type.flags;
+			if(out_flags.out0.lvds){
+				/*clear*/
+				out_flags.flags = 0x0;
+				/*set just lvds*/
+				out_flags.out0.lvds = 1;
+				defaultFound = 1;
+
+			}
+			else if(out_flags.out0.drgb){
+				/*clear*/
+				out_flags.flags = 0x0;
+				/*set just lvds*/
+				out_flags.out0.drgb = 1;
+				defaultFound = 1;
+			}
+			/*Should out1 be allowed a seperate set up? */
+			else if(out_flags.out1.drgb){
+				/*clear*/
+				out_flags.flags = 0x0;
+				/*set just lvds*/
+				out_flags.out1.drgb = 1;
+				defaultFound = 1;
+
+			}
+			else if(out_flags.out1.drgb){
+				/*clear*/
+				out_flags.flags = 0x0;
+				/*set just lvds*/
+				out_flags.out1.drgb = 1;
+				defaultFound = 1;
+
+			}
+
+			if(defaultFound)
+			{
+				printk("\n[EMGD] SDVO: Defaulting To: %x\n", out_flags.flags);
+				p_ctx->out_type.flags = out_flags.flags;
+			}
+			else
+			{
+				printk("\n[EMGD] SDVO: Error ! no appropriate default for p_ctx->out_type.flags!\n");
+			}
+
+	}
+
 	/* ...................................................................... */
 	status = sdvo_set_target_output(p_ctx, p_ctx->out_type);
 	if (status != SS_SUCCESS) {
@@ -2748,6 +2847,7 @@ int sdvo_set_attributes(void *p_context, unsigned long num_attrs,
 		return PD_ERR_INTERNAL;
 	}
 
+
 	/* Here will try to get the supported power states again.  For multiple
 	 * displays functionality card, the supported power state will only can get
       * succesfully after the output display type been seted.
@@ -3107,6 +3207,12 @@ int sdvo_save(void *p_context, void **pp_state, unsigned long flags)
 	}
 	sdvo_convert_dtd_to_pd_timing(&p_dtd, &(reg_state->timing));
 
+	/* In case someone calls save again without restore, free the previous
+     * state */
+	if (NULL != *pp_state) {
+		pd_free(*pp_state);
+	}
+
 	*pp_state = (void *)reg_state;
 
 	/* restore power state, just in case */
@@ -3229,6 +3335,8 @@ int sdvo_restore(void *p_context, void *p_state, unsigned long flags)
 	}
 
 	pd_free(p_state);
+	p_state = NULL;
+
 	return PD_SUCCESS;
 }
 
@@ -3278,6 +3386,7 @@ int sdvo_close(void *p_context)
 
 	if (p_ctx->p_mode_table) {
 		pd_free(p_ctx->p_mode_table);
+		p_ctx->p_mode_table = NULL;
 	}
 	pd_free(p_ctx);
 #endif
@@ -3732,9 +3841,3 @@ static sdvo_status_t sdvo_reset_encoder(sdvo_device_context_t *p_ctx)
 }
 #endif
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: sdvo_port.c,v 1.23 2011/04/04 03:18:48 nanuar Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/pal/sdvo/sdvo_port.c,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.h b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.h
index dc82f57..b06fc73b 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.h
+++ b/drivers/gpu/drm/emgd/emgd/pal/sdvo/sdvo_port.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: sdvo_port.h
- * $Revision: 1.8 $
+ * $Revision: 1.9 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/state/appcontext/cmn/appcontext_dispatch.h b/drivers/gpu/drm/emgd/emgd/state/appcontext/cmn/appcontext_dispatch.h
index ef165ca..3da03e0 100644
--- a/drivers/gpu/drm/emgd/emgd/state/appcontext/cmn/appcontext_dispatch.h
+++ b/drivers/gpu/drm/emgd/emgd/state/appcontext/cmn/appcontext_dispatch.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: appcontext_dispatch.h
- * $Revision: 1.6 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/state/appcontext/cmn/igd_appcontext.c b/drivers/gpu/drm/emgd/emgd/state/appcontext/cmn/igd_appcontext.c
index a938a64..c5ee392 100644
--- a/drivers/gpu/drm/emgd/emgd/state/appcontext/cmn/igd_appcontext.c
+++ b/drivers/gpu/drm/emgd/emgd/state/appcontext/cmn/igd_appcontext.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_appcontext.c
- * $Revision: 1.8 $
+ * $Revision: 1.10 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -146,9 +146,3 @@ int appcontext_init(igd_context_t *context)
 	return 0;
 }
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: igd_appcontext.c,v 1.8 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/state/appcontext/cmn/igd_appcontext.c,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/state/appcontext/plb/appcontext_plb.c b/drivers/gpu/drm/emgd/emgd/state/appcontext/plb/appcontext_plb.c
index 533cf17..568e24f 100644
--- a/drivers/gpu/drm/emgd/emgd/state/appcontext/plb/appcontext_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/state/appcontext/plb/appcontext_plb.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: appcontext_plb.c
- * $Revision: 1.8 $
+ * $Revision: 1.10 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -205,10 +205,3 @@ static void appcontext_shutdown_plb(igd_context_t *context)
 	return;
 }
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: appcontext_plb.c,v 1.8 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/state/appcontext/plb/appcontext_plb.c,v $
- *----------------------------------------------------------------------------
- */
-
diff --git a/drivers/gpu/drm/emgd/emgd/state/power/cmn/igd_pwr.c b/drivers/gpu/drm/emgd/emgd/state/power/cmn/igd_pwr.c
index f41c6e9..5b8c151 100644
--- a/drivers/gpu/drm/emgd/emgd/state/power/cmn/igd_pwr.c
+++ b/drivers/gpu/drm/emgd/emgd/state/power/cmn/igd_pwr.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_pwr.c
- * $Revision: 1.9 $
+ * $Revision: 1.14 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -129,19 +129,15 @@ static int igd_pwr_alter(igd_driver_h driver_handle, unsigned int dwPowerState)
 		/* Officially change the power state after registers are restored */
 		context->device_context.power_state = IGD_POWERSTATE_D0;
 
-		/* restore power to plane, pipe and port */
-		if(context->mod_dispatch.mode_pwr) {
-			retval = context->mod_dispatch.mode_pwr(context,
-				IGD_POWERSTATE_D0);
-			if (retval) {
-				return retval;
-			}
-		}
-
 		/* enable overlay */
 		if(context->mod_dispatch.overlay_pwr) {
 			context->mod_dispatch.overlay_pwr(context, IGD_POWERSTATE_D0);
 		}
+
+		/* enable msvdx */
+		if(context->mod_dispatch.msvdx_pwr) {
+			context->mod_dispatch.msvdx_pwr(context, IGD_POWERSTATE_D0);
+		}
 		break;
 
 	case IGD_POWERSTATE_D1:
@@ -152,6 +148,12 @@ static int igd_pwr_alter(igd_driver_h driver_handle, unsigned int dwPowerState)
 			dwPowerState = IGD_POWERSTATE_D1;
 		}
 
+
+		/* Turn off the msvdx */
+		if(context->mod_dispatch.msvdx_pwr) {
+			context->mod_dispatch.msvdx_pwr(context, dwPowerState);
+		}
+
 		/* Turn off the overlay */
 		if(context->mod_dispatch.overlay_pwr) {
 			context->mod_dispatch.overlay_pwr(context, dwPowerState);
@@ -185,6 +187,11 @@ static int igd_pwr_alter(igd_driver_h driver_handle, unsigned int dwPowerState)
 	case IGD_POWERSTATE_D3:
 		/* Suspend to memory - ACPI S3 */
 
+		/* diable msvdx */
+		if(context->mod_dispatch.msvdx_pwr) {
+			context->mod_dispatch.msvdx_pwr(context, dwPowerState);
+		}
+
 		/* disable overlay */
 		if(context->mod_dispatch.overlay_pwr) {
 			context->mod_dispatch.overlay_pwr(context, dwPowerState);
@@ -288,8 +295,3 @@ int _pwr_init(igd_context_t *context)
 	return 0;
 }                                                               /* _pwr_init */
 
-/*-----------------------------------------------------------------------------
- * $Id: igd_pwr.c,v 1.9 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/state/power/cmn/igd_pwr.c,v $
- *-----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/state/power/cmn/pwr_dispatch.h b/drivers/gpu/drm/emgd/emgd/state/power/cmn/pwr_dispatch.h
index 481ba1b..34043ba 100644
--- a/drivers/gpu/drm/emgd/emgd/state/power/cmn/pwr_dispatch.h
+++ b/drivers/gpu/drm/emgd/emgd/state/power/cmn/pwr_dispatch.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: pwr_dispatch.h
- * $Revision: 1.6 $
+ * $Revision: 1.8 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -50,8 +50,3 @@ extern pwr_dispatch_t pwr_dispatch_plb;
 
 #endif
 
-/*-----------------------------------------------------------------------------
- * $Id: pwr_dispatch.h,v 1.6 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/state/power/cmn/pwr_dispatch.h,v $
- *-----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/state/power/plb/pwr_plb.c b/drivers/gpu/drm/emgd/emgd/state/power/plb/pwr_plb.c
index 8ff8c1a..22d3280 100644
--- a/drivers/gpu/drm/emgd/emgd/state/power/plb/pwr_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/state/power/plb/pwr_plb.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: pwr_plb.c
- * $Revision: 1.6 $
+ * $Revision: 1.8 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -121,9 +121,3 @@ static int pwr_init_plb(igd_context_t *context)
 	return 0;
 }
 
-
-/*-----------------------------------------------------------------------------
- * $Id: pwr_plb.c,v 1.6 2011/03/02 22:47:06 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/emgd/state/power/plb/pwr_plb.c,v $
- *-----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/emgd/state/reg/cmn/reg.c b/drivers/gpu/drm/emgd/emgd/state/reg/cmn/reg.c
index 35c9b89..e030f0d 100644
--- a/drivers/gpu/drm/emgd/emgd/state/reg/cmn/reg.c
+++ b/drivers/gpu/drm/emgd/emgd/state/reg/cmn/reg.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: reg.c
- * $Revision: 1.13 $
+ * $Revision: 1.16 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -62,8 +62,12 @@ typedef struct _reg_context {
 	void *gmm_state;
 } reg_context_t;
 
+extern emgd_drm_config_t config_drm;
 static reg_context_t reg_ctx[1];
-
+static reg_buffer_t *console_state;
+void *console_gmm_state;
+static reg_buffer_t *misc_state;
+void *misc_gmm_state;
 
 static dispatch_table_t reg_dispatch_list[] = {
 
@@ -104,6 +108,18 @@ int reg_restore(igd_context_t *context,
 		reg_ctx->dispatch->platform_context);
 }
 
+void reg_crtc_lut_get(igd_context_t *context,
+	void *emgd_crtc)
+{
+	reg_ctx->dispatch->reg_crtc_lut_get(context, (emgd_crtc_t *)emgd_crtc);
+}
+
+void reg_crtc_lut_set(igd_context_t *context,
+	void *emgd_crtc)
+{
+	reg_ctx->dispatch->reg_crtc_lut_set(context, (emgd_crtc_t *)emgd_crtc);
+}
+
 /*!
  * This function calls reg_save() to save the state of the graphics engine
  * and then reg_restore to restore the previous state.
@@ -113,12 +129,12 @@ int reg_restore(igd_context_t *context,
  * @return 0 on success
  * @return -IGD_INVAL on failure
  */
-static int igd_driver_save_restore(igd_driver_h driver_handle)
+static int igd_driver_save_restore(igd_driver_h driver_handle,
+	unsigned long flags)
 {
 	igd_context_t *context = (igd_context_t *)driver_handle;
 	reg_buffer_t *reg_state;
 	short restored = 0;
-	unsigned long save_flags;
 
 	EMGD_ASSERT(context, "Null driver_handle!\n", -IGD_ERROR_INVAL);
 
@@ -131,15 +147,13 @@ static int igd_driver_save_restore(igd_driver_h driver_handle)
 	 * and appcontext.
 	 */
 	if (reg_ctx->gmm_state) {
-		save_flags = IGD_REG_SAVE_ALL & ~IGD_REG_SAVE_GTT & ~IGD_REG_SAVE_RB;
-	} else {
-		save_flags = IGD_REG_SAVE_ALL;
+		flags = flags & ~IGD_REG_SAVE_GTT & ~IGD_REG_SAVE_RB;
 	}
 
 	/* Save current state. We have to save the current state first before
 	 * restoring the GART bindings. Otherwise we will end up restoring wrong
 	 * pages when return back to the graphic mode console */
-	reg_state = reg_ctx->dispatch->reg_alloc(context, save_flags,
+	reg_state = reg_ctx->dispatch->reg_alloc(context, flags,
 		reg_ctx->dispatch->platform_context);
 	reg_ctx->dispatch->reg_save(context, reg_state,
 		reg_ctx->dispatch->platform_context);
@@ -190,17 +204,44 @@ static int igd_driver_save(igd_driver_h driver_handle,
 {
 	igd_context_t *context = (igd_context_t *)driver_handle;
 	reg_buffer_t *reg_state;
+	reg_buffer_t **reg_location = NULL;
 
 	EMGD_ASSERT(context, "Null driver_handle!\n", -IGD_ERROR_INVAL);
 
+	switch (flags & IGD_REG_SAVE_TYPE_MASK) {
+	case IGD_REG_SAVE_TYPE_REG:
+		reg_location = &reg_ctx->device_state;
+		break;
+	case IGD_REG_SAVE_TYPE_CON:
+		reg_location = &console_state;
+		break;
+	case IGD_REG_SAVE_TYPE_MISC:
+		reg_location = &misc_state;
+		break;
+	default:
+		EMGD_ERROR("Called igd_driver_save without a valid save flag.");
+		return 0;
+	}
+
+	if (*reg_location) {
+		reg_ctx->dispatch->reg_free(context, *reg_location,
+			reg_ctx->dispatch->platform_context);
+	}
+
 	/* Save current state */
 	reg_state = reg_ctx->dispatch->reg_alloc(context, flags,
 		reg_ctx->dispatch->platform_context);
 	reg_ctx->dispatch->reg_save(context, reg_state,
 		reg_ctx->dispatch->platform_context);
 
-	reg_ctx->device_state = reg_state;
+	*reg_location = reg_state;
 
+	/* Free GART bindings, if not already saved */
+	if ((flags & IGD_REG_SAVE_TYPE_REG) &&
+		!reg_ctx->gmm_state &&
+		context->mod_dispatch.gmm_save) {
+		context->mod_dispatch.gmm_save(context, &(reg_ctx->gmm_state));
+	}
 	return 0;
 }
 /* igd_driver_save */
@@ -213,25 +254,54 @@ static int igd_driver_save(igd_driver_h driver_handle,
  * @return 0 on success
  * @return -IGD_INVAL on failure
  */
-static int igd_driver_restore(igd_driver_h driver_handle)
+static int igd_driver_restore(igd_driver_h driver_handle,
+	const unsigned long flags)
 {
 	igd_context_t *context;
+	reg_buffer_t *reg_state = NULL;
 
 	EMGD_ASSERT(driver_handle, "Null driver_handle!\n", -IGD_ERROR_INVAL);
 
 	context = (igd_context_t *)driver_handle;
+	switch (flags & IGD_REG_SAVE_TYPE_MASK) {
+	case IGD_REG_SAVE_TYPE_REG:
+		reg_state = reg_ctx->device_state;
+		break;
+	case IGD_REG_SAVE_TYPE_CON:
+		reg_state = console_state;
+		break;
+	case IGD_REG_SAVE_TYPE_MISC:
+		reg_state = misc_state;
+		break;
+	default:
+		EMGD_ERROR("Not a valida restore flag specified.");
+		return 0;
+	}
 
 	/*
 	 * NAPA class seems to work much better all the display stuff is
 	 * turned off prior to restoring the registers.
+	 * context->mod_dispatch.mode_reset_plane_pipe_ports(context);
 	 */
 	context->mod_dispatch.mode_reset_plane_pipe_ports(context);
 
 	/* restore previously saved state */
-	reg_ctx->dispatch->reg_restore(context, reg_ctx->device_state,
-		reg_ctx->dispatch->platform_context);
-	reg_ctx->dispatch->reg_free(context, reg_ctx->device_state,
-		reg_ctx->dispatch->platform_context);
+	if (reg_state) {
+		reg_ctx->dispatch->reg_restore(context, reg_state,
+			reg_ctx->dispatch->platform_context);
+		reg_ctx->dispatch->reg_free(context, reg_state,
+			reg_ctx->dispatch->platform_context);
+
+		/* Restore GART bindings, if saved */
+		if ((flags & IGD_REG_SAVE_TYPE_REG) &&
+			reg_ctx->gmm_state &&
+			context->mod_dispatch.gmm_restore) {
+			context->mod_dispatch.gmm_restore(context, reg_ctx->gmm_state);
+			reg_ctx->gmm_state = NULL;
+		}
+	} else {
+		EMGD_ERROR("Previous state was not saved, so can't restore.");
+	}
 
 	return 0;
 }
@@ -248,18 +318,26 @@ static int igd_driver_restore(igd_driver_h driver_handle)
 static int reg_get_mod_state(reg_state_id_t id, module_state_h **state,
 	unsigned long **flags)
 {
-	if(!reg_ctx->device_state) {
+	if(!reg_ctx->device_state && !console_state) {
 		return 0;
 	}
 
-	*flags = &reg_ctx->device_state->flags;
 	switch(id) {
-	case REG_MODE_STATE:
-		if((**flags & IGD_REG_SAVE_MODE)){
-			*state = &reg_ctx->device_state->mode_buffer;
-		} else {
-			state = NULL;
-		}
+	case REG_MODE_STATE_REG:
+		*flags = &reg_ctx->device_state->flags;
+			if((**flags & IGD_REG_SAVE_MODE)){
+				*state = &reg_ctx->device_state->mode_buffer;
+			} else {
+				state = NULL;
+			}
+		break;
+	case REG_MODE_STATE_CON:
+		*flags = &console_state->flags;
+			if((**flags & IGD_REG_SAVE_MODE)){
+				*state = &console_state->mode_buffer;
+			} else {
+				state = NULL;
+			}
 		break;
 	default:
 		state = NULL;
@@ -278,15 +356,27 @@ static int reg_get_mod_state(reg_state_id_t id, module_state_h **state,
  */
 void _reg_shutdown(igd_context_t *context)
 {
-
+	reg_buffer_t *restore_state;
 	EMGD_TRACE_ENTER;
 
+	if (!config_drm.init) {
+		restore_state = reg_ctx[0].device_state;
+	} else {
+		if (config_drm.kms) {
+			restore_state = console_state;
+		} else {
+			restore_state = console_state;
+			//restore_state = reg_ctx[0].device_state;
+		}
+	}
+
+	if(restore_state) {
+		context->mod_dispatch.mode_reset_plane_pipe_ports(context);
 
-	if(reg_ctx->device_state) {
 		EMGD_DEBUG("Restoring register values prior to exit...");
-		reg_ctx->dispatch->reg_restore(context, reg_ctx->device_state,
+		reg_ctx->dispatch->reg_restore(context, restore_state,
 			reg_ctx->dispatch->platform_context);
-		reg_ctx->dispatch->reg_free(context, reg_ctx->device_state,
+		reg_ctx->dispatch->reg_free(context, restore_state,
 			reg_ctx->dispatch->platform_context);
 
 	}
@@ -323,27 +413,37 @@ int _reg_init(igd_context_t *context, unsigned long flags)
 	/*
 	 * Hook up functions in dispatch table.
 	 */
-	context->dispatch.driver_save_restore = igd_driver_save_restore;
-	context->dispatch.driver_save         = igd_driver_save;
-	context->dispatch.driver_restore      = igd_driver_restore;
+	context->dispatch.driver_save_restore   = igd_driver_save_restore;
+	context->dispatch.driver_save           = igd_driver_save;
+	context->dispatch.driver_restore        = igd_driver_restore;
 	context->mod_dispatch.reg_get_mod_state = reg_get_mod_state;
-	context->mod_dispatch.reg_alloc   = reg_alloc;
-	context->mod_dispatch.reg_free    = reg_free;
-	context->mod_dispatch.reg_save    = reg_save;
-	context->mod_dispatch.reg_restore = reg_restore;
-	context->mod_dispatch.reg_shutdown = _reg_shutdown;
+	context->mod_dispatch.reg_alloc         = reg_alloc;
+	context->mod_dispatch.reg_free          = reg_free;
+	context->mod_dispatch.reg_save          = reg_save;
+	context->mod_dispatch.reg_restore       = reg_restore;
+	context->mod_dispatch.reg_shutdown      = _reg_shutdown;
+	context->mod_dispatch.reg_crtc_lut_get  = reg_crtc_lut_get;
+	context->mod_dispatch.reg_crtc_lut_set  = reg_crtc_lut_set;
 
 	if(flags & IGD_DRIVER_SAVE_RESTORE) {
 		reg_ctx->flags |= IGD_DRIVER_SAVE_RESTORE;
 		EMGD_DEBUG("Saving Device State");
 
 		reg_ctx->device_state = reg_ctx->dispatch->reg_alloc(context,
-			IGD_REG_SAVE_STATE|IGD_REG_SAVE_MODE,
+			IGD_REG_SAVE_STATE|IGD_REG_SAVE_MODE|IGD_REG_SAVE_TYPE_REG,
 			reg_ctx->dispatch->platform_context);
 		reg_ctx->dispatch->reg_save(context, reg_ctx->device_state,
 			reg_ctx->dispatch->platform_context);
 	}
 
+	if (config_drm.init) {
+		console_state = reg_ctx->dispatch->reg_alloc(context,
+			IGD_REG_SAVE_STATE|IGD_REG_SAVE_MODE|IGD_REG_SAVE_TYPE_CON,
+			reg_ctx->dispatch->platform_context);
+		reg_ctx->dispatch->reg_save(context, console_state,
+			reg_ctx->dispatch->platform_context);
+	}
+
 	EMGD_TRACE_EXIT;
 
 	return 0;
diff --git a/drivers/gpu/drm/emgd/emgd/state/reg/cmn/reg_dispatch.h b/drivers/gpu/drm/emgd/emgd/state/reg/cmn/reg_dispatch.h
index 7d48324..985fa44 100644
--- a/drivers/gpu/drm/emgd/emgd/state/reg/cmn/reg_dispatch.h
+++ b/drivers/gpu/drm/emgd/emgd/state/reg/cmn/reg_dispatch.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: reg_dispatch.h
- * $Revision: 1.6 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -34,6 +34,7 @@
 #define _REG_DISPATCH_H
 
 #include <context.h>
+#include <drm_emgd_private.h>
 
 typedef struct _reg_buffer {
 	unsigned long flags;
@@ -55,6 +56,8 @@ typedef struct _reg_dispatch {
 		void *_platform_context);
 	int (*reg_restore)(igd_context_t *context, reg_buffer_t *reg_set,
 		void *_platform_context);
+	void (*reg_crtc_lut_get)(igd_context_t *context, emgd_crtc_t *emgd_crtc);
+	void (*reg_crtc_lut_set)(igd_context_t *context, emgd_crtc_t *emgd_crtc);
 	void *platform_context;
 } reg_dispatch_t;
 
diff --git a/drivers/gpu/drm/emgd/emgd/state/reg/plb/reg_plb.c b/drivers/gpu/drm/emgd/emgd/state/reg/plb/reg_plb.c
index ed9f34d..d262ad6 100644
--- a/drivers/gpu/drm/emgd/emgd/state/reg/plb/reg_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/state/reg/plb/reg_plb.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: reg_plb.c
- * $Revision: 1.12 $
+ * $Revision: 1.14 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -72,6 +72,10 @@ static int reg_save_plb(igd_context_t *context, reg_buffer_t *reg_buffer,
 	void *_platform_context);
 static int reg_restore_plb(igd_context_t *context, reg_buffer_t *reg_buffer,
 	void *_platform_context);
+static void reg_crtc_lut_get_plb(igd_context_t *context,
+    emgd_crtc_t *emgd_crtc);
+static void reg_crtc_lut_set_plb(igd_context_t *context,
+    emgd_crtc_t *emgd_crtc);
 
 /* GR registers being saved */
 static unsigned char gr_regs_plb[] = {
@@ -282,6 +286,8 @@ reg_dispatch_t reg_dispatch_plb = {
 	reg_free_plb,
 	reg_save_plb,
 	reg_restore_plb,
+	reg_crtc_lut_get_plb,
+	reg_crtc_lut_set_plb,
 	&reg_platform_context_plb
 };
 
@@ -596,6 +602,82 @@ static int reg_save_dac_plb(
 	return 0;
 }
 
+static void reg_crtc_lut_set_plb(
+    igd_context_t *context,
+    emgd_crtc_t *emgd_crtc)
+{
+    int i;
+	unsigned long pal_reg;
+    unsigned char *mmio;
+
+    EMGD_TRACE_ENTER;
+
+    mmio = context->device_context.virt_mmadr;
+
+    if (emgd_crtc->crtc_id == 0) {
+        /* If Pipe is enabled, restore Palette */
+        if ((emgd_crtc->crtc_id == 0 &&
+            ((EMGD_READ32(mmio + PIPEA_CONF) & PIPE_ENABLE) &&
+            (EMGD_READ32(mmio + PIPEASRC)))) ||
+            (emgd_crtc->crtc_id == 1 &&
+            ((EMGD_READ32(mmio + PIPEB_CONF) & PIPE_ENABLE) &&
+            (EMGD_READ32(mmio + PIPEBSRC))))) {
+
+            pal_reg = (unsigned long)(mmio + DPALETTE_A +
+                (emgd_crtc->crtc_id * (DPALETTE_B - DPALETTE_A)));
+
+            /* Restore Pipe A Palette */
+            for (i=0; i<DAC_DATA_COUNT; i++)  {
+                EMGD_WRITE32((emgd_crtc->lut_r[i] << 16) |
+                    (emgd_crtc->lut_g[i] << 8) |
+                    emgd_crtc->lut_b[i],
+                    pal_reg + i*4);
+            }
+        }
+    }
+
+    EMGD_TRACE_EXIT;
+}
+
+static void reg_crtc_lut_get_plb(
+    igd_context_t *context,
+    emgd_crtc_t *emgd_crtc)
+{
+    int i;
+	unsigned long pal_reg;
+    unsigned char *mmio;
+    unsigned long lut_value;
+
+    EMGD_TRACE_ENTER;
+
+    mmio = context->device_context.virt_mmadr;
+
+    if (emgd_crtc->crtc_id == 0) {
+        /* If Pipe is enabled, restore Palette */
+        if ((emgd_crtc->crtc_id == 0 &&
+            ((EMGD_READ32(mmio + PIPEA_CONF) & PIPE_ENABLE) &&
+            (EMGD_READ32(mmio + PIPEASRC)))) ||
+            (emgd_crtc->crtc_id == 1 &&
+            ((EMGD_READ32(mmio + PIPEB_CONF) & PIPE_ENABLE) &&
+            (EMGD_READ32(mmio + PIPEBSRC))))) {
+
+            pal_reg = (unsigned long)(mmio + DPALETTE_A +
+                (emgd_crtc->crtc_id * (DPALETTE_B - DPALETTE_A)));
+
+            /* Restore Pipe A Palette */
+            for (i=0; i<DAC_DATA_COUNT; i++)  {
+                lut_value = EMGD_READ32(pal_reg + i*4);
+                emgd_crtc->lut_r[i] = (lut_value & 0xFF0000) >> 16;
+                emgd_crtc->lut_g[i] = (lut_value & 0x00FF00) >> 8;
+                emgd_crtc->lut_b[i] = (lut_value & 0x0000FF);
+            }
+        }
+    }
+
+    EMGD_TRACE_EXIT;
+}
+
+
 /*!
  * Restore previously saved DAC palette from the specifed state buffer.
  *
@@ -829,7 +911,9 @@ static int reg_save_plb(igd_context_t *context,
 			*buffer++ = EMGD_READ32(mmio + platform_context->mmio_regs[i]);
 		}
 
+		if (reg_buffer->flags & IGD_REG_SAVE_GTT) {
 			reg_save_gtt_plb(context, mmio, reg_args);
+		}
 	}
 
 	/* Save DAC registers */
@@ -927,7 +1011,10 @@ int reg_restore_plb(igd_context_t *context,
 				EMGD_WRITE32(*buffer++, mmio + platform_context->mmio_regs[i]);
 			}
 		}
-		reg_restore_gtt_plb(context, reg_args);
+
+		if (reg_buffer->flags & IGD_REG_SAVE_GTT) {
+			reg_restore_gtt_plb(context, reg_args);
+		}
 	}
 
 #if 0
diff --git a/drivers/gpu/drm/emgd/emgd/state/reg/tnc/reg_tnc.c b/drivers/gpu/drm/emgd/emgd/state/reg/tnc/reg_tnc.c
index 5700b08..cf5861b 100644
--- a/drivers/gpu/drm/emgd/emgd/state/reg/tnc/reg_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/state/reg/tnc/reg_tnc.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: reg_tnc.c
- * $Revision: 1.15 $
+ * $Revision: 1.17 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -72,6 +72,10 @@ static int reg_save_tnc(igd_context_t *context, reg_buffer_t *reg_buffer,
 	void *_platform_context);
 static int reg_restore_tnc(igd_context_t *context, reg_buffer_t *reg_buffer,
 	void *_platform_context);
+static void reg_crtc_lut_get_tnc(igd_context_t *context,
+    emgd_crtc_t *emgd_crtc);
+static void reg_crtc_lut_set_tnc(igd_context_t *context,
+    emgd_crtc_t *emgd_crtc);
 
 /* GR registers being saved */
 static unsigned char gr_regs_tnc[] = {
@@ -175,13 +179,13 @@ static unsigned long mmio_regs_tnc[] = {
 	DPYC_GAMC4, DPYC_GAMC3, DPYC_GAMC2, DPYC_GAMC1, DPYC_GAMC0,
 
 	/* Enable Plane C */
-	DSPCCNTR, DSPCLINOFF,
+	DSPCCNTR, DSPCLINOFF, DSPCSURF,
 
 	/* Enable Plane B */
-	DSPBCNTR, DSPBLINOFF,
+	DSPBCNTR, DSPBLINOFF, DSPBSURF,
 
 	/* Enable Plane A */
-	DSPACNTR, DSPALINOFF,
+	DSPACNTR, DSPALINOFF, DSPASURF,
 
 	/* Enable VGA Plane */
 	VGACNTRL,
@@ -319,6 +323,8 @@ reg_dispatch_t reg_dispatch_tnc = {
 	reg_free_tnc,
 	reg_save_tnc,
 	reg_restore_tnc,
+	reg_crtc_lut_get_tnc,
+	reg_crtc_lut_set_tnc,
 	&reg_platform_context_tnc
 };
 
@@ -634,6 +640,76 @@ static int reg_save_dac_tnc(
 	return 0;
 }
 
+static void reg_crtc_lut_set_tnc(
+	igd_context_t *context,
+	emgd_crtc_t *emgd_crtc)
+{
+	int i;
+	unsigned long pal_reg;
+	unsigned char *mmio;
+
+	EMGD_TRACE_ENTER;
+
+	mmio = context->device_context.virt_mmadr;
+
+    /* Check if the pipe is enabled */
+    if ((emgd_crtc->crtc_id == IGD_KMS_PIPEA &&
+		((EMGD_READ32(mmio + PIPEA_CONF) & PIPE_ENABLE) &&
+        (EMGD_READ32(mmio + PIPEASRC)))) ||
+		(emgd_crtc->crtc_id == IGD_KMS_PIPEB &&
+		((EMGD_READ32(mmio + PIPEB_CONF) & PIPE_ENABLE) &&
+        (EMGD_READ32(mmio + PIPEBSRC))))) {
+
+		pal_reg = (unsigned long)(mmio + DPALETTE_A +
+			(emgd_crtc->crtc_id * (DPALETTE_B - DPALETTE_A)));
+
+        for (i=0; i<DAC_DATA_COUNT; i++)  {
+            EMGD_WRITE32((emgd_crtc->lut_r[i] << 16) |
+				(emgd_crtc->lut_g[i] << 8) |
+				emgd_crtc->lut_b[i],
+				pal_reg + i*4);
+        }
+    }
+
+	EMGD_TRACE_EXIT;
+}
+
+static void reg_crtc_lut_get_tnc(
+	igd_context_t *context,
+	emgd_crtc_t *emgd_crtc)
+{
+	int i;
+	unsigned long pal_reg;
+	unsigned char *mmio;
+	unsigned long lut_value;
+
+	EMGD_TRACE_ENTER;
+
+	mmio = context->device_context.virt_mmadr;
+
+    /* Check if the pipe is enabled, is this necessary? */
+    if ((emgd_crtc->crtc_id == IGD_KMS_PIPEA &&
+		((EMGD_READ32(mmio + PIPEA_CONF) & PIPE_ENABLE) &&
+        (EMGD_READ32(mmio + PIPEASRC)))) ||
+		(emgd_crtc->crtc_id == IGD_KMS_PIPEB &&
+		((EMGD_READ32(mmio + PIPEB_CONF) & PIPE_ENABLE) &&
+        (EMGD_READ32(mmio + PIPEBSRC))))) {
+
+		pal_reg = (unsigned long)(mmio + DPALETTE_A +
+			(emgd_crtc->crtc_id * (DPALETTE_B - DPALETTE_A)));
+
+        for (i=0; i<DAC_DATA_COUNT; i++)  {
+            lut_value = EMGD_READ32(pal_reg + i*4);
+			emgd_crtc->lut_r[i] = (lut_value & 0xFF0000) >> 16;
+			emgd_crtc->lut_g[i] = (lut_value & 0x00FF00) >> 8;
+			emgd_crtc->lut_b[i] = (lut_value & 0x0000FF);
+		}
+    }
+
+	EMGD_TRACE_EXIT;
+}
+
+
 /*!
  * Restore previously saved DAC palette from the specifed state buffer.
  *
@@ -888,7 +964,9 @@ static int reg_save_tnc(igd_context_t *context,
 			*buffer_sdvo++ = EMGD_READ32(mmio_sdvo + platform_context->mmio_regs_sdvo[i]);
 		}
 
+		if (reg_buffer->flags & IGD_REG_SAVE_GTT) {
 			reg_save_gtt_tnc(context, mmio, reg_args);
+		}
 	}
 
 	/* Save DAC registers */
@@ -1008,7 +1086,10 @@ int reg_restore_tnc(igd_context_t *context,
 				EMGD_WRITE32(*buffer_sdvo++, mmio_sdvo + platform_context->mmio_regs_sdvo[i]);
 			}
 		}
-		reg_restore_gtt_tnc(context, reg_args);
+
+		if (reg_buffer->flags & IGD_REG_SAVE_GTT) {
+			reg_restore_gtt_tnc(context, reg_args);
+		}
 	}
 
 #if 0
diff --git a/drivers/gpu/drm/emgd/emgd/utils/math_fix.c b/drivers/gpu/drm/emgd/emgd/utils/math_fix.c
index 4eafe9e..84e5811 100644
--- a/drivers/gpu/drm/emgd/emgd/utils/math_fix.c
+++ b/drivers/gpu/drm/emgd/emgd/utils/math_fix.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: math_fix.c
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/utils/memmap.c b/drivers/gpu/drm/emgd/emgd/utils/memmap.c
index 0592d24..2ee0812 100644
--- a/drivers/gpu/drm/emgd/emgd/utils/memmap.c
+++ b/drivers/gpu/drm/emgd/emgd/utils/memmap.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: memmap.c
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/utils/pci.c b/drivers/gpu/drm/emgd/emgd/utils/pci.c
index ff58069..969fc6d 100644
--- a/drivers/gpu/drm/emgd/emgd/utils/pci.c
+++ b/drivers/gpu/drm/emgd/emgd/utils/pci.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: pci.c
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx.c b/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx.c
index a4577b4..e2de95c 100644
--- a/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx.c
+++ b/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: msvdx.c
- * $Revision: 1.22 $
+ * $Revision: 1.25 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -106,6 +106,7 @@ unsigned long save_msg_cnt;
  */
 unsigned long jiffies_at_last_dequeue = 0;
 
+int mtx_message_complete = 1;
 int msvdx_dequeue_send(igd_context_t *context)
 {
     platform_context_plb_t *platform;
@@ -117,7 +118,7 @@ int msvdx_dequeue_send(igd_context_t *context)
     platform = (platform_context_plb_t *)context->platform_context;
 
     if (list_empty(&platform->msvdx_queue)) {
-       	//printk(KERN_ERR "MSVDXQUE: msvdx list empty\n");
+	//printk(KERN_ERR "MSVDXQUE: msvdx list empty\n");
         platform->msvdx_busy = 0;
         return -EINVAL;
     }
@@ -252,6 +253,7 @@ int send_to_mtx(igd_context_t *context, unsigned long *msg)
 	int padding_flag = 0;
 
 	EMGD_TRACE_ENTER;
+	mtx_message_complete = 0;
 
 	/* Enable all clocks before touching VEC local ram */
 	EMGD_WRITE32(PSB_CLK_ENABLE_ALL, mmio + PSB_MSVDX_MAN_CLK_ENABLE);
@@ -380,6 +382,13 @@ int send_to_mtx(igd_context_t *context, unsigned long *msg)
 	/* Send an interrupt to the MTX to let it know about the message */
 	EMGD_WRITE32(1, mmio + PSB_MSVDX_MTX_KICK);
 
+	/* Read MSVDX Register several times in case idle signal assert */
+	EMGD_READ32(mmio + PSB_MSVDX_INTERRUPT_STATUS);
+	EMGD_READ32(mmio + PSB_MSVDX_INTERRUPT_STATUS);
+	EMGD_READ32(mmio + PSB_MSVDX_INTERRUPT_STATUS);
+	EMGD_READ32(mmio + PSB_MSVDX_INTERRUPT_STATUS);
+
+
 #if 0
 	DEBUG_DUMP(context); /* For lots of additional debugging info */
 #endif
@@ -419,7 +428,7 @@ void msvdx_mtx_interrupt_plb(igd_context_t *context)
 			/* Read the first waiting message from the buffer */
 			msg_offset = 0;
 			msg[msg_offset] = EMGD_READ32(mmio + (platform->host_buf_offset +
- 						(read_idx << 2)));
+						(read_idx << 2)));
 
 			/* Size of message rounded to nearest number of words */
 			num_words = ((msg[0] & 0x000000ff) + 3) / 4;
@@ -430,7 +439,7 @@ void msvdx_mtx_interrupt_plb(igd_context_t *context)
 
 			for (msg_offset++; msg_offset < num_words; msg_offset++) {
 				msg[msg_offset] = EMGD_READ32(mmio + platform->host_buf_offset +
- 						(read_idx << 2));
+						(read_idx << 2));
 
 				if (++read_idx >= platform->host_buf_size) {
 					read_idx = 0;
@@ -439,6 +448,7 @@ void msvdx_mtx_interrupt_plb(igd_context_t *context)
 
 			EMGD_WRITE32(read_idx, mmio + PSB_MSVDX_COMMS_TO_HOST_RD_INDEX);
 
+			mtx_message_complete = 1;
 			/* Check message ID */
 			switch ((msg[0] & 0x0000ff00) >> 8) {
 			case IGD_MSGID_CMD_FAILED:
@@ -491,7 +501,7 @@ void msvdx_mtx_interrupt_plb(igd_context_t *context)
 	} while (read_idx != write_idx);
 
 done:
-	if (1) { };
+	return;
 }
 
 
@@ -610,7 +620,7 @@ int msvdx_poll_mtx_irq(igd_context_t *context)
 IMG_BOOL msvdx_mtx_isr(IMG_VOID *pvData)
 {
     struct drm_device *dev;
-    drm_emgd_private *priv;
+    drm_emgd_priv_t *priv;
     igd_context_t *context;
 	unsigned char *mmio;
 	platform_context_plb_t *platform;
@@ -797,7 +807,7 @@ static void debug_dump(igd_context_t *context)
 	write_idx = EMGD_READ32(mmio + PSB_MSVDX_COMMS_TO_HOST_WRT_INDEX);
 	EMGD_DEBUG("HOST buffer: RDIDX 0x%08lx   WRIDX 0x%08lx, %lu",
 		read_idx, write_idx, platform->host_buf_size);
- 	for (i = 0; (i < read_idx || i < write_idx); i++) {
+	for (i = 0; (i < read_idx || i < write_idx); i++) {
 		unsigned long value =
 			EMGD_READ32(mmio + platform->host_buf_offset + (i <<2));
 		EMGD_DEBUG("   %02lx: 0x%08lx", i, value);
diff --git a/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_init.c b/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_init.c
index e9feb61..4af14f6 100644
--- a/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_init.c
+++ b/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_init.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: msvdx_init.c
- * $Revision: 1.25 $
+ * $Revision: 1.29 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -90,6 +90,7 @@ void msvdx_reset_plb(igd_context_t *context);
 static msvdx_fw_t *priv_fw = NULL;
 
 extern unsigned long jiffies_at_last_dequeue;
+extern int mtx_message_complete;
 
 
 int msvdx_query_plb(igd_context_t *context,
@@ -114,11 +115,48 @@ int msvdx_query_plb(igd_context_t *context,
 	return 0;
 }
 
+int msvdx_status(igd_context_t *context, unsigned long *queue_status, unsigned long *mtx_msg_status)
+{
+	platform_context_plb_t *platform = NULL;
+	platform = (platform_context_plb_t *)context->platform_context;
+	if (init_msvdx_first_time) {
+		*queue_status = 1;
+		*mtx_msg_status = 1;
+	} else {
+			*queue_status = list_empty(&platform->msvdx_queue);
+			*mtx_msg_status = mtx_message_complete;
+	}
+	return IGD_SUCCESS;
+}
+int msvdx_pwr_plb(
+	igd_context_t *context,
+	unsigned long power_state)
+{
+	platform_context_plb_t *platform = (platform_context_plb_t *)context->platform_context;
+
+	/* NOTE: The MSVDX need to reset after resume */
+	EMGD_TRACE_ENTER;
+	if(power_state != IGD_POWERSTATE_D0){
+		platform->msvdx_needs_reset = 1;
+	}
+
+	EMGD_TRACE_EXIT;
+	return IGD_SUCCESS;
+}
+
 int msvdx_pre_init_plb(struct drm_device *dev)
 {
+    drm_emgd_priv_t *priv;
+    igd_context_t *context;
+
 	EMGD_TRACE_ENTER;
 
     gpDrmDevice = dev;
+	priv = gpDrmDevice->dev_private;
+	context = priv->context;
+
+	context->mod_dispatch.msvdx_pwr = msvdx_pwr_plb;
+	context->mod_dispatch.msvdx_status = msvdx_status;
 
 	EMGD_TRACE_EXIT;
 	return IGD_SUCCESS;
@@ -127,7 +165,7 @@ int msvdx_pre_init_plb(struct drm_device *dev)
 int msvdx_init_plb(unsigned long base0, unsigned long base1,
 		           void *msvdx_fw, unsigned long msvdx_fw_size)
 {
-    drm_emgd_private *priv;
+    drm_emgd_priv_t *priv;
     igd_context_t *context;
     unsigned char *mmio;
     unsigned long ram_bank;
@@ -252,7 +290,7 @@ int msvdx_init_plb(unsigned long base0, unsigned long base1,
         platform->rendec_base1 = base_addr1;
 
 		init_msvdx_first_time = 0;
-    	INIT_LIST_HEAD(&platform->msvdx_queue);
+	INIT_LIST_HEAD(&platform->msvdx_queue);
 		spin_lock_init(&platform->msvdx_lock);
     } else {
         /* restore offsets. */
@@ -260,7 +298,7 @@ int msvdx_init_plb(unsigned long base0, unsigned long base1,
         base_addr0 = platform->rendec_base0;
         base_addr1 = platform->rendec_base1;
 
-        /* Init link list to fix HSD202831 */
+        /* Init link list */
         if(!context_count) {
 			INIT_LIST_HEAD(&platform->msvdx_queue);
 		}
@@ -524,7 +562,7 @@ int msvdx_uninit_plb(igd_context_t *context)
 
 	if(!context_count) {
 		msvdx_reset_plb(context);
- 	}
+	}
 	EMGD_TRACE_EXIT;
 	return 0;
 }
diff --git a/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_pvr.c b/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_pvr.c
index 1d6f9fd..99ccec1 100644
--- a/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_pvr.c
+++ b/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_pvr.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: msvdx_pvr.c
- * $Revision: 1.8 $
+ * $Revision: 1.9 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_pvr.h b/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_pvr.h
index 1621838..3f28f81 100644
--- a/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_pvr.h
+++ b/drivers/gpu/drm/emgd/emgd/video/msvdx/msvdx_pvr.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: msvdx_pvr.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/igd_ovl.c b/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/igd_ovl.c
index 0bd99c8..299c781 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/igd_ovl.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/igd_ovl.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_ovl.c
- * $Revision: 1.24 $
+ * $Revision: 1.28 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -81,10 +81,23 @@ ovl_context_t ovl_context[1];
 void igd_reset_fw_ovl(igd_display_context_t *display)
 {
 	ovl_dispatch_t	*ovl_dispatch = (ovl_dispatch_t *)ovl_context->dispatch;
+	if(NULL == ovl_dispatch){
+		EMGD_DEBUG("ovl_dispatch_t	*ovl_dispatch == NULL");
+		return ;
+	}
 	ovl_dispatch[OVL_SECONDARY].alter_ovl(display,
 								NULL, NULL, NULL, NULL, IGD_OVL_ALTER_OFF);
 }
 
+static int igd_ovl_set_display(igd_display_h ovl_display[])
+{
+	ovl_context->ovl_display_km[OVL_PRIMARY] = (igd_display_context_t *)ovl_display[OVL_PRIMARY];
+	ovl_context->ovl_display_km[OVL_SECONDARY] = (igd_display_context_t *)ovl_display[OVL_SECONDARY];
+
+	ovl_context->ovl_display_swapped = 1;
+	return 0;
+}
+
 static int ovl_get_display(igd_display_context_t *display,
 	igd_display_context_t *(ovl_displays[]),
 	unsigned long flags)
@@ -112,16 +125,21 @@ static int ovl_get_display(igd_display_context_t *display,
 		return 0;
 	}
 
-	if (dc & IGD_DISPLAY_CONFIG_CLONE) {
+	if (dc & IGD_DISPLAY_CONFIG_CLONE || display->context->mod_dispatch.in_dih_clone_mode) {
 		/* CLONE or Vertical Extended
 		 * Primary Overlay uses the display from the primary pipe.
 		 * Secondary Overlay uses the display from the secondary pipe. */
-		ovl_displays[OVL_PRIMARY]   = primary;
-		ovl_displays[OVL_SECONDARY] = secondary;
+		/* The above is TRUE on init, but subsequent
+		 * video plane override calls will change the overlay plane assignment.
+		 * Use ovl_um_context->ovl_display_km[OVL_PRIMARY] &
+		 * ovl_um_context->ovl_display_km[OVL_SECONDARY] to retrieve
+		 * HW overlay(PRIMARY) & SpriteC(SECONDARY) plane to display
+		 * handle assignment respectively */
+		ovl_displays[OVL_PRIMARY]   = ovl_context->ovl_display_km[OVL_PRIMARY];
+		ovl_displays[OVL_SECONDARY] = ovl_context->ovl_display_km[OVL_SECONDARY];
 	} else {
 		/* Single, Twin, Extended */
-
-		if (display == primary) {
+		if (ovl_context->ovl_display_km[OVL_PRIMARY] == display) {
 			ovl_displays[OVL_PRIMARY]   = display;
 			ovl_displays[OVL_SECONDARY] = NULL;
 		} else {
@@ -145,11 +163,17 @@ static int igd_alter_ovl2(igd_display_h display_h,
 	ovl_dispatch_t    *ovl_dispatch =
 		(ovl_dispatch_t *)ovl_context->dispatch;
 	int cur_ovl, ret = 0;
-	unsigned long dc;
 	igd_display_context_t *primary, *secondary;
+	unsigned long dc;
+	igd_display_context_t *ovl_displays[OVL_MAX_HW];
 
 	EMGD_TRACE_ENTER;
 
+	if(NULL == ovl_dispatch) {
+		EMGD_DEBUG("ovl_dispatch == NULL");
+		return IGD_SUCCESS;
+	}
+
 	if(flags == IGD_FW_VIDEO_OFF)
 	{
 		igd_reset_fw_ovl(display);
@@ -157,10 +181,27 @@ static int igd_alter_ovl2(igd_display_h display_h,
 	}
 
 	/* Determine which display this overlay belongs to */
+	if(display->context == NULL){
+		EMGD_DEBUG("display->context == NULL");
+		return -IGD_ERROR_INVAL;
+	}
 	display->context->mod_dispatch.dsp_get_dc(&dc, &primary, &secondary);
-	if(display == primary) {
+
+	if ((ovl_context->ovl_display_km[OVL_PRIMARY] == NULL) &&
+		(ovl_context->ovl_display_km[OVL_SECONDARY] == NULL)) {
+		/* One time initialization of ovl_display_km */
+		ovl_displays[OVL_PRIMARY] = primary;
+		ovl_displays[OVL_SECONDARY] = secondary;
+		igd_ovl_set_display((igd_display_h)ovl_displays);
+	}
+
+	/* Determine which overlays belong to which displays */
+	ovl_get_display(display, ovl_displays, flags);
+
+	/* Determine which display this overlay belongs to */
+	if(display == ovl_displays[OVL_PRIMARY]) {
 		cur_ovl = 0;
-	} else if (display == secondary) {
+	} else if (display == ovl_displays[OVL_SECONDARY]) {
 		cur_ovl = 1;
 	} else {
 		/* shouldn't get here. */
@@ -206,6 +247,7 @@ static int igd_alter_ovl2(igd_display_h display_h,
 }
 
 
+
 static int igd_query_ovl(igd_display_h display_h,
 	unsigned int flags)
 {
@@ -287,6 +329,36 @@ static int igd_query_max_size_ovl(igd_display_h display_h,
 	return ret;
 }
 
+
+
+/* This is a wrapper function that will call the device specific alter_ovl2_osd
+ * function. Currently this function is used by video driver to map the subpicture
+ * surface to second overlay so that it blends with the video surface on first
+ * overlay. Furthermore, this is only enabled for PLB device only.
+ */
+static int igd_alter_ovl2_osd(igd_display_h display_h,
+	igd_surface_t *sub_surface,
+	igd_rect_t *sub_src_rect,
+	igd_rect_t *sub_dest_rect,
+	igd_ovl_info_t      *ovl_info,
+	unsigned int         flags)
+{
+	ovl_dispatch_t  *ovl_dispatch =
+		(ovl_dispatch_t *)ovl_context->dispatch;
+	igd_display_context_t *display =
+		(igd_display_context_t *)display_h;
+
+	int ret = 0;
+
+	ret = ovl_dispatch[1].alter_ovl(display,
+			sub_surface, sub_src_rect, sub_dest_rect,
+			ovl_info, flags);
+
+	return ret;
+}
+
+
+
 /*----------------------------------------------------------------------
  * Function: igd_get_ovl_init_params(ovl_um_context_t *ovl_um_context)
  * Description:
@@ -346,7 +418,7 @@ int ovl_full_init(igd_context_t *context,
 		return -IGD_ERROR_NOMEM;
 	}
 	ovl_context->reg_allocated = 1;
-
+	ovl_context->ovl_display_swapped = 0;
 
 	/* Get the register update physical address in RAM */
 	if(context->dispatch.gmm_virt_to_phys(
@@ -382,8 +454,11 @@ int ovl_full_init(igd_context_t *context,
 	context->dispatch.get_ovl_init_params = igd_get_ovl_init_params;
 	context->dispatch.alter_ovl = NULL;
 	context->dispatch.alter_ovl2 = igd_alter_ovl2;
+//	context->dispatch.alter_ovl2_dihclone = igd_alter_ovl2_dihclone;
 	context->dispatch.query_ovl = igd_query_ovl;
 	context->dispatch.query_max_size_ovl = igd_query_max_size_ovl;
+	context->dispatch.alter_ovl2_osd = igd_alter_ovl2_osd;
+	context->dispatch.set_ovl_display = igd_ovl_set_display;
 
 	/* Hook up optional inter-module functions */
 	context->mod_dispatch.overlay_shutdown = _overlay_shutdown;
@@ -392,6 +467,14 @@ int ovl_full_init(igd_context_t *context,
 	if(params->display_flags & IGD_DISPLAY_FB_BLEND_OVL){
 		ovl_context->fb_blend_ovl = 1;
 	}
+	ovl_context->saved_src_surf = NULL;
+	ovl_context->saved_src_rect = NULL;
+	ovl_context->saved_dest_rect = NULL;
+	ovl_context->saved_ovl_info = NULL;
+	ovl_context->saved_flags	=  0;
+	ovl_context->ovl_display_km[OVL_PRIMARY] = NULL;
+	ovl_context->ovl_display_km[OVL_SECONDARY] = NULL;
+
 
 	EMGD_TRACE_EXIT;
 	return IGD_SUCCESS;
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/micro_ovl.c b/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/micro_ovl.c
index 0961089..7a15220 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/micro_ovl.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/micro_ovl.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: micro_ovl.c
- * $Revision: 1.12 $
+ * $Revision: 1.13 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_coeff.c b/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_coeff.c
index 3ebfce4..fc08f0e 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_coeff.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_coeff.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: ovl_coeff.c
- * $Revision: 1.7 $
+ * $Revision: 1.8 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -953,7 +953,7 @@ void ovl_update_coeff_regs(
 	int val, sinc, window, sum, x, y;
 	int dCoeff[5*32];
 	int dDiff;
-   	unsigned short wTap2Fix;
+	unsigned short wTap2Fix;
 
 	const int pi = 0x3243f; /* = 3.141586 << 16 */
 				  /*+- 3.1415926535; */
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_coeff.h b/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_coeff.h
index fb9e928..60cadb7 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_coeff.h
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_coeff.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: ovl_coeff.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_dispatch.h b/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_dispatch.h
index 1ae494b..4487071 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_dispatch.h
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_dispatch.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: ovl_dispatch.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_virt.h b/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_virt.h
index 8fac10d..7b0a998 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_virt.h
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/cmn/ovl_virt.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: ovl_virt.h
- * $Revision: 1.6 $
+ * $Revision: 1.9 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -59,6 +59,16 @@
 #define OVL_HW_MAX_GAMMA       500L
 #define OVL_HW_MIN_GAMMA       1L
 
+#define OVL_REPROG_OP_NONE            0
+#define OVL_REPROG_OP_TURNON_PRIM     1
+#define OVL_REPROG_OP_TURNON_SECND    2
+#define OVL_REPROG_OP_TURNOFF_PRIM    3
+#define OVL_REPROG_OP_TURNOFF_SECND   4
+#define OVL_REPROG_OP_SWITCH_TO_PRIM  5
+#define OVL_REPROG_OP_SWITCH_TO_SECND 6
+#define OVL_REPROG_OP_REVERT_SECND	  7
+#define OVL_REPROG_OP_REVERT_PRIM	  8
+
 enum {
 	OVL_STATE_OFF = 0,
 	OVL_STATE_ON,
@@ -83,6 +93,13 @@ typedef struct _ovl_context{
 	unsigned int ovl_buff;
 	unsigned int fb_blend_ovl;
 	unsigned short reg_allocated;
+	igd_surface_t  *saved_src_surf;
+	igd_rect_t     *saved_src_rect;
+	igd_rect_t     *saved_dest_rect;
+	igd_ovl_info_t *saved_ovl_info;
+	unsigned int   saved_flags;
+	igd_display_context_t * ovl_display_km[OVL_MAX_HW];
+	unsigned int ovl_display_swapped;
 } ovl_context_t;
 
 extern ovl_context_t ovl_context[];
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/micro_ovl_plb.c b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/micro_ovl_plb.c
index 4f24d65..c58e890 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/micro_ovl_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/micro_ovl_plb.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: micro_ovl_plb.c
- * $Revision: 1.15 $
+ * $Revision: 1.17 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -106,6 +106,8 @@ unsigned int micro_spritec_update_src_plb(igd_display_context_t *display,
 		spritec_regs_plb->control |= OVL2_CMD_YUV_422 | OVL2_CMD_UYVY;
 		break;
 	case IGD_PF_ARGB32_8888:
+		spritec_regs_plb->control |= OVL2_CMD_ARGB_8888;
+		break;
 	case IGD_PF_xRGB32_8888:
 		spritec_regs_plb->control |= OVL2_CMD_RGB_8888;
 		break;
@@ -587,16 +589,18 @@ static unsigned int micro_spritec_update_regs_plb(
 	}
 
 	/* Color control information */
-	ret = micro_spritec_update_video_quality_plb(display, src_surf,
-		&ovl_info->video_quality);
-	if (ret) {
-		EMGD_ERROR_EXIT("Overlay2 video quality failed");
-		return ret;
-	}
-	ret = micro_spritec_update_gamma_plb(display, spritec_regs_plb, &ovl_info->gamma);
-	if (ret) {
-		EMGD_ERROR("Overlay2 gamma failed");
-		return ret;
+	if (!(flags & IGD_OVL_OSD_ON_SPRITEC)) {
+		ret = micro_spritec_update_video_quality_plb(display, src_surf,
+			&ovl_info->video_quality);
+		if (ret) {
+			EMGD_ERROR_EXIT("Overlay2 video quality failed");
+			return ret;
+		}
+		ret = micro_spritec_update_gamma_plb(display, spritec_regs_plb, &ovl_info->gamma);
+		if (ret) {
+			EMGD_ERROR("Overlay2 gamma failed");
+			return ret;
+		}
 	}
 
 	/* Destination color key */
@@ -638,10 +642,14 @@ static unsigned int micro_spritec_update_regs_plb(
 			display->context->dispatch.wait_vblank((igd_display_h)display);
 		}
 
-		/* Sprite C should be on the bottom of the Z order.
-		 * Plane B should be above Sprite C */
-		spritec_regs_plb->control |= 6;
-
+		if (flags & IGD_OVL_OSD_ON_SPRITEC) {
+			/* Sprite C should be below plane and above overlay. */
+			spritec_regs_plb->control |= 1;
+		} else {
+			/* Sprite C should be on the bottom of the Z order.
+			 * Plane B should be above Sprite C */
+			spritec_regs_plb->control |= 6;
+		}
 	} else {
 		EMGD_DEBUG("Overlay Disable Dest Color Key");
 		plane_control =
@@ -761,6 +769,8 @@ unsigned int micro_spritec_update_src_plb(igd_surface_t *src_surf,
 		ovl_cache.ovl2_regs.control |= OVL2_CMD_YUV_422 | OVL2_CMD_UYVY;
 		break;
 	case IGD_PF_ARGB32_8888:
+		ovl_cache.ovl2_regs.control |= OVL2_CMD_ARGB_8888;
+		break;
 	case IGD_PF_xRGB32_8888:
 		ovl_cache.ovl2_regs.control |= OVL2_CMD_RGB_8888;
 		break;
@@ -1510,9 +1520,13 @@ static unsigned int micro_spritec_update_regs_plb(
 	}
 
 	if (ovl_info->color_key.flags & IGD_OVL_DST_COLOR_KEY_ENABLE) {
-		/* Sprite C should be on the bottom of the Z order.
-		 * Plane B should be above Sprite C */
-		ovl_cache.ovl2_regs.control |= 6;
+		if (flags & IGD_OVL_OSD_ON_SPRITEC) {
+			ovl_cache.ovl2_regs.control |= 1;
+		} else {
+			/* Sprite C should be on the bottom of the Z order.
+			 * Plane B should be above Sprite C */
+			ovl_cache.ovl2_regs.control |= 6;
+		}
 	}
 
 	/* General overlay information.  Turn the second overlay on. */
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl2_plb.c b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl2_plb.c
index d4d4508..816c3ab 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl2_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl2_plb.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: ovl2_plb.c
- * $Revision: 1.20 $
+ * $Revision: 1.22 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -157,8 +157,9 @@ unsigned int ovl2_check_plb(igd_display_context_t *display,
 		return IGD_SUCCESS;
 	}
 
-	/* DCT-PC99TA ure the framebuffer dotclock does not exceed the board SKU max dotclock
-	 ** This is to address TIBET#1741106 (workaround)
+	/*************************************************************************
+	 * Ensure the framebuffer dotclock does not exceed the board SKU
+	 * max dotclock
 	 **************************************************************************/
         /* Make it chipset-specific */
         /* DCT-PC99TA crashes with dotclock > 300MHz */
@@ -308,7 +309,7 @@ unsigned int ovl2_send_instr_plb(
 
         if(md && md->set_flip_pending){
                 /* For second overlay, Poulsbo has no ISR bit
- 	         * to reflect the flip pending for Display
+	         * to reflect the flip pending for Display
                  * Sprite C. So we use Pipe-B vblank status
                  * as a substitute
                  */
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl2_plb.h b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl2_plb.h
index fee9b83..dca46bc 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl2_plb.h
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl2_plb.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: ovl2_plb.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl2_regs_plb.h b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl2_regs_plb.h
index b8ed4d4..6460560 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl2_regs_plb.h
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl2_regs_plb.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: ovl2_regs_plb.h
- * $Revision: 1.5 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -52,6 +52,7 @@ typedef struct _ovl2_reg_plb{
 #define OVL2_CMD_VYUY				0x00030000
 
 /* Source Format */
+#define OVL2_CMD_ARGB_8888          0x1C000000
 #define OVL2_CMD_RGB_8888			0x18000000
 #define OVL2_CMD_RGB_565			0x14000000
 #define OVL2_CMD_RGB_555			0x10000000
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_plb.c b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_plb.c
index 89995e7..56a50fa 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_plb.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_plb.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: ovl_plb.c
- * $Revision: 1.24 $
+ * $Revision: 1.27 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -1414,10 +1414,19 @@ static unsigned int ovl_update_regs_plb(
 		ovl_cache_plb->command |= OVL_CMD_FIELD_MODE;
 		/* Need to enable FIELD SYNC OVERLAY FLIP in field mode. */
 		ovl_cache_plb->command |= OVL_CMD_FIELD_SYNC_FLIP;
+		/* HSD# 203821 Mplayer outputs single one buffer including both even and odd fields */
 		if (flags & IGD_OVL_ALTER_FLIP_ODD) {
 			ovl_cache_plb->command |= OVL_CMD_ACT_FLD1;
+			/* HSD# 203821 To display odd field, starts from first odd field. */
+			if (0 == src_rect->y1 & 1) {
+				src_rect->y1 += 1;
+			}
 		} else {
 			ovl_cache_plb->command |= OVL_CMD_ACT_FLD0;
+			/* HSD# 203821 To display even field, starts from first even field. */
+			if (0 != src_rect->y1 & 1) {
+				src_rect->y1 += 1;
+			}
 		}
 	} else {
 		ovl_cache_plb->command |= OVL_CMD_FRAME_MODE;
@@ -1433,7 +1442,7 @@ static unsigned int ovl_update_regs_plb(
 
 	/* Src rect and surface information */
 
-       	ret = ovl_update_src_ptr_plb(display, ovl_cache_plb, src_surf, src_rect);
+	ret = ovl_update_src_ptr_plb(display, ovl_cache_plb, src_surf, src_rect);
 	if (ret) {
 		OS_FREE(ovl_cache_plb);
 		EMGD_ERROR_EXIT("Overlay updating src pointers failed");
@@ -1657,10 +1666,19 @@ static unsigned int ovl_update_regs_plb(
 			ovl_cache_regs->command |= OVL_CMD_FIELD_MODE;
 			/* enable FIELD SYNC OVERLAY FLIP in field mode. */
 			ovl_cache_regs->command |= OVL_CMD_FIELD_SYNC_FLIP;
+			/* HSD# 203821 Mplayer outputs single one buffer including both even and odd fields */
 			if (flags & IGD_OVL_ALTER_FLIP_ODD) {
 				ovl_cache_regs->command |= OVL_CMD_ACT_FLD1;
+				/* HSD# 203821 To display odd field, starts from first odd field. */
+				if (0 == (src_rect->y1 & 1)) {
+					src_rect->y1 += 1;
+				}
 			} else {
 				ovl_cache_regs->command |= OVL_CMD_ACT_FLD0;
+				/* HSD# 203821 To display even field, starts from first even field. */
+				if (0 != (src_rect->y1 & 1)) {
+					src_rect->y1 += 1;
+				}
 			}
 		} else {
 			ovl_cache_regs->command |= OVL_CMD_FRAME_MODE;
@@ -2060,7 +2078,7 @@ static int alter_ovl_plb(igd_display_context_t *display,
 	if (ret) {
 		EMGD_ERROR_EXIT("Overlay Update Registers failed");
 		return ret;
-  	}
+	}
 
 	/* Send the instructions to the command queue */
 	ret = ovl_send_instr_plb(display, flags);
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_plb_cache.c b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_plb_cache.c
index 7f454d3..d05c475 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_plb_cache.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_plb_cache.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: ovl_plb_cache.c
- * $Revision: 1.4 $
+ * $Revision: 1.5 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_plb_cache.h b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_plb_cache.h
index df89fa9..b8bb2ef 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_plb_cache.h
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_plb_cache.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *----------------------------------------------------------------------------
  * Filename: ovl_plb_cache.h
- * $Revision: 1.4 $
+ * $Revision: 1.5 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_regs_plb.h b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_regs_plb.h
index 2bd7c1e..34b24c4 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_regs_plb.h
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/plb/ovl_regs_plb.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: ovl_regs_plb.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/micro_ovl_tnc.c b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/micro_ovl_tnc.c
index 393482f..5cf24ad 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/micro_ovl_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/micro_ovl_tnc.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: micro_ovl_tnc.c
- * $Revision: 1.13 $
+ * $Revision: 1.17 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -78,6 +78,7 @@ unsigned int micro_spritec_send_instr_tnc(
 	igd_display_context_t     *display,
 	unsigned long regs,
 	unsigned long value);
+extern ovl_context_t ovl_context[1];
 
 #ifndef CONFIG_MICRO_OVERLAY
 #define	OVL2_CHECK_TNC_RET(ret,a, b, c, d, e,f) ret = ovl2_check_tnc(a ,b ,c ,d ,e ,f)
@@ -139,6 +140,8 @@ unsigned int micro_spritec_update_src_tnc(igd_display_context_t *display,
 		spritec_regs_tnc->control |= OVL2_CMD_YUV_422 | OVL2_CMD_UYVY;
 		break;
 	case IGD_PF_ARGB32_8888:
+		spritec_regs_tnc->control |= OVL2_CMD_ARGB_8888;
+		break;
 	case IGD_PF_xRGB32_8888:
 		spritec_regs_tnc->control |= OVL2_CMD_RGB_8888;
 		break;
@@ -563,7 +566,7 @@ static unsigned int micro_spritec_update_regs_tnc(
 		if ((plane_control & (3<<22)) != 0) {
 			plane_control &= ~(3<<22);
 		}
-		if((plane_control & 0x3c000000) == 0x1c000000) {
+		if((plane_control & DSPxCNTR_SRC_FMT_MASK) == DSPxCNTR_ARGB_8888) {
 			plane_control &= ~0x04000000;
 		}
 		if(plane_control != orig_plane_control) {
@@ -615,16 +618,18 @@ static unsigned int micro_spritec_update_regs_tnc(
 	}
 
 	/* Color control information */
-	ret = micro_spritec_update_video_quality_tnc(display, src_surf,
-		&ovl_info->video_quality);
-	if (ret) {
-		EMGD_ERROR_EXIT("Overlay2 video quality failed");
-		return ret;
-	}
-	ret = micro_spritec_update_gamma_tnc(display, spritec_regs_tnc, &ovl_info->gamma);
-	if (ret) {
-		EMGD_ERROR("Overlay2 gamma failed");
-		return ret;
+	if (!(flags & IGD_OVL_OSD_ON_SPRITEC)) {
+		ret = micro_spritec_update_video_quality_tnc(display, src_surf,
+			&ovl_info->video_quality);
+		if (ret) {
+			EMGD_ERROR_EXIT("Overlay2 video quality failed");
+			return ret;
+		}
+		ret = micro_spritec_update_gamma_tnc(display, spritec_regs_tnc, &ovl_info->gamma);
+		if (ret) {
+			EMGD_ERROR("Overlay2 gamma failed");
+			return ret;
+		}
 	}
 
 	/* Destination color key */
@@ -651,8 +656,13 @@ static unsigned int micro_spritec_update_regs_tnc(
 		 * Plane A/B */
 		plane_control |= (3<<22);
 
-		/* Sprite C should be on the bottom of the Z order. */
-		spritec_regs_tnc->control |= 4;
+		if (flags & IGD_OVL_OSD_ON_SPRITEC) {
+			/* Sprite C should be below plane and above first overlay */
+			spritec_regs_tnc->control |= 1;
+		} else {
+			/* Sprite C should be on the bottom of the Z order. */
+			spritec_regs_tnc->control |= 4;
+		}
 	} else {
 		EMGD_DEBUG("Overlay Disable Dest Color Key");
 		plane_control &= ~(3<<22);
@@ -663,14 +673,14 @@ static unsigned int micro_spritec_update_regs_tnc(
 		 * If Overlay + FB Blend is requested and the FB is xRGB
 		 * turn on the ARGB format.
 		 */
-		if((plane_control & 0x3c000000) == 0x18000000) {
-			plane_control |= 0x1c000000;
+		if((plane_control & DSPxCNTR_SRC_FMT_MASK) == DSPxCNTR_RGB_8888) {
+			plane_control |= DSPxCNTR_ARGB_8888;
 		}
 
 		/* Dest Blend requires Plane C on the bottom of the Z order */
 		spritec_regs_tnc->control |= 4;
 	} else {
-		if((plane_control & 0x3c000000) == 0x1c000000) {
+		if((plane_control & DSPxCNTR_SRC_FMT_MASK) == DSPxCNTR_ARGB_8888) {
 			plane_control &= ~0x04000000;
 		}
 	}
@@ -801,6 +811,8 @@ unsigned int micro_spritec_update_src_tnc(
 		ovl_cache.ovl2_regs.control |= OVL2_CMD_YUV_422 | OVL2_CMD_UYVY;
 		break;
 	case IGD_PF_ARGB32_8888:
+		ovl_cache.ovl2_regs.control |= OVL2_CMD_ARGB_8888;
+		break;
 	case IGD_PF_xRGB32_8888:
 		ovl_cache.ovl2_regs.control |= OVL2_CMD_RGB_8888;
 		break;
@@ -1153,7 +1165,10 @@ static unsigned int micro_spritec_disable_ovl_tnc(
 	if ((plane_control & (3<<22)) != 0) {
 		plane_control &= ~(3<<22);
 	}
-	if((plane_control & 0x3c000000) == 0x1c000000) {
+	if(((plane_control & DSPxCNTR_SRC_FMT_MASK) == DSPxCNTR_ARGB_8888) &&
+		(!display->context->mod_dispatch.fb_blend_ovl_override)) {
+		/* Preserve the state of the register if FB blend +
+		 * Ovl override is invoked */
 		plane_control &= ~0x04000000;
 	}
 	if(plane_control != orig_plane_control) {
@@ -1266,11 +1281,14 @@ static void micro_spritec_update_colorkey_tnc(
 		 * If Overlay + FB Blend is requested and the FB is xRGB
 		 * turn on the ARGB format.
 		 */
-		if((ovl_cache.ovl2_regs.plane_control & 0x3c000000) == 0x18000000) {
-			ovl_cache.ovl2_regs.plane_control |= 0x1c000000;
+		if((ovl_cache.ovl2_regs.plane_control & DSPxCNTR_SRC_FMT_MASK) == DSPxCNTR_RGB_8888) {
+			ovl_cache.ovl2_regs.plane_control |= DSPxCNTR_ARGB_8888;
 		}
 	} else {
-		if((ovl_cache.ovl2_regs.plane_control & 0x3c000000) == 0x1c000000) {
+		if(((ovl_cache.ovl2_regs.plane_control & DSPxCNTR_SRC_FMT_MASK) == DSPxCNTR_ARGB_8888) &&
+			(!display->context->mod_dispatch.fb_blend_ovl_override)){
+			/* Preserve the state of the register if FB blend +
+			 * Ovl override is invoked */
 			ovl_cache.ovl2_regs.plane_control &= ~0x04000000;
 		}
 	}
@@ -1475,8 +1493,9 @@ static unsigned int micro_spritec_update_regs_tnc(
 	}
 
 	/* Init the cache if needed */
-	if (ovl_cache_needs_init) {
+	if ((ovl_cache_needs_init) || (ovl_context->ovl_display_swapped)){
 		micro_spritec_clear_cache_tnc(display, flags);
+		ovl_context->ovl_display_swapped = 0;
 	}
 
 	/* See what has changed in the cache */
@@ -1577,17 +1596,22 @@ static unsigned int micro_spritec_update_regs_tnc(
 
 	if ((ovl_info->color_key.flags & IGD_OVL_DST_COLOR_KEY_ENABLE) ||
 		(ovl_info->color_key.flags & IGD_OVL_DST_BLEND_ENABLE)) {
-
-		/* Sprite C should be on the bottom of the Z order.
-		 * Plane B should be above Sprite C */
-		ovl_cache.ovl2_regs.control |= 4;
+		if (flags & IGD_OVL_OSD_ON_SPRITEC) {
+			ovl_cache.ovl2_regs.control |= 1;
+		} else {
+			/* Sprite C should be on the bottom of the Z order.
+			 * Plane B should be above Sprite C */
+			ovl_cache.ovl2_regs.control |= 4;
+		}
 	}
 
 	/* General overlay information.  Turn the second overlay on. */
 	ovl_cache.ovl2_regs.control |= (1<<31);
-	ovl_cache.ovl2_regs.control |= PIPE(display)->pipe_num ?
-		(1<<24)/*Pipe B*/ :
-		(0<<24)/*Pipe A*/;
+	if (PIPE(display)->pipe_num == 1) {
+		ovl_cache.ovl2_regs.control |= (1<<24);/*Pipe B*/
+	} else {
+		ovl_cache.ovl2_regs.control &= ~(1<<24);/*Pipe A*/
+	}
 
 	/*
 	 * Now write all the changes to the part
@@ -1643,7 +1667,7 @@ int micro_prepare_ovl2_tnc(
 										dest_rect, ovl_info,flags)) )
 	{
 		if (ret) {
-			EMGD_ERROR_EXIT("Overlay2 Check failed");
+			printk(KERN_ERR "Overlay2 Check failed\n");
 			return ret;
 		}
 	}
@@ -1656,6 +1680,7 @@ int micro_prepare_ovl2_tnc(
 	if( (QUERY_OVL2_TNC_RET(ret,(igd_display_h)display,
 								IGD_OVL_QUERY_WAIT_LAST_FLIP_DONE)) )
 	{
+		printk(KERN_ERR "QEURY_OVL2_TNC_RET failedi\n");
 		if ((FALSE == ret) &&
 			(flags & IGD_OVL_ALTER_ON)) {
 			/* Only return an error if the overlay is on.  If turning it off,
@@ -1669,7 +1694,7 @@ int micro_prepare_ovl2_tnc(
 		src_surf, src_rect, dest_rect, ovl_info,
 		flags);
 	if (ret) {
-		EMGD_ERROR_EXIT("Sprite C update Registers failed");
+		printk(KERN_ERR "Sprite C update Registers failed");
 		return ret;
 	}
 
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_regs_tnc.h b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_regs_tnc.h
index e558eb3..9f2ac10 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_regs_tnc.h
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_regs_tnc.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: ovl2_regs_tnc.h
- * $Revision: 1.5 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -52,6 +52,7 @@ typedef struct _ovl2_reg_tnc{
 #define OVL2_CMD_VYUY				0x00030000
 
 /* Source Format */
+#define OVL2_CMD_ARGB_8888			0x1C000000
 #define OVL2_CMD_RGB_8888			0x18000000
 #define OVL2_CMD_RGB_565			0x14000000
 #define OVL2_CMD_RGB_555			0x10000000
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_tnc.c b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_tnc.c
index 92a4dfe..4239d7c 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_tnc.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: ovl2_tnc.c
- * $Revision: 1.17 $
+ * $Revision: 1.20 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -178,7 +178,6 @@ unsigned int ovl2_check_tnc(igd_display_context_t *display,
 	/*************************************************************************
 	 * Ensure the framebuffer dotclock does not exceed the board SKU
 	 * max dotclock
-	 * This is to address TIBET#1741106 (workaround)
 	 *************************************************************************/
 	/* Make it chipset-specific */
 	/* DCT-PC99TA crashes with dotclock > 300MHz */
@@ -354,7 +353,7 @@ int alter_ovl2_tnc(igd_display_context_t *display,
 
 	/* Send the instructions to the command queue */
 	ret = ovl2_send_instr_tnc(display, &spritec_regs_tnc, flags);
-
+	EMGD_DEBUG("Sprite C= %s",flags & IGD_OVL_ALTER_ON?"ON":"OFF");
 	EMGD_TRACE_EXIT;
 	return ret;
 }
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_tnc.h b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_tnc.h
index e49e28b..300e826 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_tnc.h
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl2_tnc.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: ovl2_tnc.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_regs_tnc.h b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_regs_tnc.h
index 6de6491..06e85f7 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_regs_tnc.h
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_regs_tnc.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: ovl_regs_tnc.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc.c b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc.c
index c9908ea..5f8958b 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: ovl_tnc.c
- * $Revision: 1.23 $
+ * $Revision: 1.27 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -457,7 +457,6 @@ static unsigned int ovl_update_src_tnc(igd_display_context_t *display,
 	ovl_regs_tnc->source_uv_width        = src_w >> src_uv_shift_x;
 
 	/* src width swords - This equation follows the B-Spec */
-	/* HSD 200138 - saw folding effect when partial of video display on left screen. */
 	/* Equation in B-spec is cancelling out fixed point round-up when -1.
 	   Explain below:
 	   [[(offset + width + 63)/128 - offset/128] * 2 ] - 1
@@ -1481,10 +1480,19 @@ static unsigned int ovl_update_regs_tnc(
 		ovl_cache_tnc->command |= OVL_CMD_FIELD_MODE;
 		/* Need to enable FIELD SYNC OVERLAY FLIP in field mode. */
 		ovl_cache_tnc->command |= OVL_CMD_FIELD_SYNC_FLIP;
+		/* HSD# 203821 Mplayer outputs single buffer including both even and odd fields. */
 		if (flags & IGD_OVL_ALTER_FLIP_ODD) {
 			ovl_cache_tnc->command |= OVL_CMD_ACT_FLD1;
+			/* HSD# 203821 To display odd field, starts from first odd field. */
+			if (0 == src_rect->y1 & 1) {
+				src_rect->y1 += 1;
+			}
 		} else {
 			ovl_cache_tnc->command |= OVL_CMD_ACT_FLD0;
+			/* HSD# 203821 To display even field, starts from first even field. */
+			if (0 != src_rect->y1 & 1) {
+				src_rect->y1 += 1;
+			}
 		}
 	} else {
 		ovl_cache_tnc->command |= OVL_CMD_FRAME_MODE;
@@ -1716,10 +1724,19 @@ static unsigned int ovl_update_regs_tnc(
 			ovl_cache_regs->command |= OVL_CMD_FIELD_MODE;
 			/* enable FIELD SYNC OVERLAY FLIP in field mode. */
 			ovl_cache_regs->command |= OVL_CMD_FIELD_SYNC_FLIP;
+			/* HSD# 203821 Mplayer outputs single buffer including both even and odd fields. */
 			if (flags & IGD_OVL_ALTER_FLIP_ODD) {
 				ovl_cache_regs->command |= OVL_CMD_ACT_FLD1;
+				/* HSD: 203821 To display odd field, starts from first odd field. */
+				if (0 == (src_rect->y1 & 1)) {
+					src_rect->y1 += 1;
+				}
 			} else {
 				ovl_cache_regs->command |= OVL_CMD_ACT_FLD0;
+				/* HSD: 203821 To display even field, starts from first even field. */
+				if (0 != (src_rect->y1 & 1)) {
+					src_rect->y1 += 1;
+				}
 			}
 		} else {
 			ovl_cache_regs->command |= OVL_CMD_FRAME_MODE;
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc_cache.c b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc_cache.c
index 3d788ae..734e0d6 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc_cache.c
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc_cache.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: ovl_tnc_cache.c
- * $Revision: 1.4 $
+ * $Revision: 1.5 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc_cache.h b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc_cache.h
index c91ef07..0df413a 100644
--- a/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc_cache.h
+++ b/drivers/gpu/drm/emgd/emgd/video/overlay/tnc/ovl_tnc_cache.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *----------------------------------------------------------------------------
  * Filename: ovl_tnc_cache.h
- * $Revision: 1.4 $
+ * $Revision: 1.5 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/video/topaz/topaz.c b/drivers/gpu/drm/emgd/emgd/video/topaz/topaz.c
index c66c00b..2c1d4ff 100644
--- a/drivers/gpu/drm/emgd/emgd/video/topaz/topaz.c
+++ b/drivers/gpu/drm/emgd/emgd/video/topaz/topaz.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: topaz.c
- * $Revision: 1.11 $
+ * $Revision: 1.13 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -184,6 +184,7 @@ void topaz_sync_tnc(igd_context_t *context)
 	platform = (platform_context_tnc_t *)context->platform_context;
 	topaz_priv = &platform->tpz_private_data;
 	sync_p = (unsigned long *)topaz_priv->topaz_sync_addr;
+	topaz_priv->topaz_sync_id++;
 
 	/* insert a SYNC command here */
 	topaz_priv->topaz_sync_cmd_seq = (1 << 15) |
@@ -191,7 +192,7 @@ void topaz_sync_tnc(igd_context_t *context)
 	sync_cmd[0] = (MTX_CMDID_SYNC << 1) | (3 << 8) |
 		(topaz_priv->topaz_sync_cmd_seq << 16);
 	sync_cmd[1] = topaz_priv->topaz_sync_offset;
-	sync_cmd[2] = topaz_priv->topaz_sync_cmd_seq;
+	sync_cmd[2] = topaz_priv->topaz_sync_id;
 	temp_ret = mtx_send_tnc(context, sync_cmd);
 	if (0 != temp_ret){
 	    EMGD_DEBUG("TOPAZ: sync error: %ld\n", temp_ret);
@@ -203,14 +204,14 @@ void topaz_sync_tnc(igd_context_t *context)
 	/* debug code to make sure SYNC can be done */
 	{
 		int count = 1000;
-		while (count && *sync_p != topaz_priv->topaz_sync_cmd_seq) {
+		while (count && *sync_p != topaz_priv->topaz_sync_id) {
 		OS_SLEEP(1000);
 		--count;
 	}
 	if ((count == 0) && (*sync_p != 0x45)) {
 		EMGD_ERROR("TOPAZ: wait sync timeout (0x%08x),"
 			"actual 0x%08x\n",
-			topaz_priv->topaz_sync_cmd_seq, *sync_p);
+			topaz_priv->topaz_sync_id, *sync_p);
 		}
 		}
 #endif
@@ -235,7 +236,6 @@ int process_encode_mtx_messages(igd_context_t *context,
 	unsigned long codec;
 	tnc_topaz_priv_t *topaz_priv;
 	platform_context_tnc_t *platform;
-	int first_frame = 0;
 
 	platform = (platform_context_tnc_t *)context->platform_context;
 	topaz_priv = &platform->tpz_private_data;
@@ -244,16 +244,6 @@ int process_encode_mtx_messages(igd_context_t *context,
 	cur_cmd_size = cur_cmd_header->size;
 	cur_cmd_id = cur_cmd_header->id;
 
-	if(cur_cmd_id != MTX_CMDID_SW_NEW_CODEC){
-		if( (topaz_priv->topaz_cur_codec == FW_H264_NO_RC) ||
-            	    (topaz_priv->topaz_cur_codec == FW_MPEG4_NO_RC) ||
-            	    (topaz_priv->topaz_cur_codec == FW_H263_NO_RC) ){
-			topaz_priv->topaz_sync_val = topaz_priv->topaz_sync_cmd_seq;
-		}
-	}else{
-		first_frame=1;
-	}
-
 	while (cur_cmd_id != MTX_CMDID_NULL) {
 
 		switch (cur_cmd_id) {
@@ -306,14 +296,5 @@ int process_encode_mtx_messages(igd_context_t *context,
 	}
 	topaz_sync_tnc(context);
 
-	if(first_frame){
-		/* For no rate-control, POLL special for first frame */
-                if( (topaz_priv->topaz_cur_codec == FW_H264_NO_RC) ||
-                    (topaz_priv->topaz_cur_codec == FW_MPEG4_NO_RC) ||
-                    (topaz_priv->topaz_cur_codec == FW_H263_NO_RC) ){
-			topaz_priv->topaz_sync_val = topaz_priv->topaz_sync_cmd_seq;
-		}
-	}
-
 	return 0;
 }
diff --git a/drivers/gpu/drm/emgd/emgd/video/topaz/topaz_hdr.h b/drivers/gpu/drm/emgd/emgd/video/topaz/topaz_hdr.h
index 5844b17..3545684 100644
--- a/drivers/gpu/drm/emgd/emgd/video/topaz/topaz_hdr.h
+++ b/drivers/gpu/drm/emgd/emgd/video/topaz/topaz_hdr.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: topaz_hdr.h
- * $Revision: 1.10 $
+ * $Revision: 1.11 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/emgd/video/topaz/topaz_init.c b/drivers/gpu/drm/emgd/emgd/video/topaz/topaz_init.c
index db45085..aab5b2a 100644
--- a/drivers/gpu/drm/emgd/emgd/video/topaz/topaz_init.c
+++ b/drivers/gpu/drm/emgd/emgd/video/topaz/topaz_init.c
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: topaz_init.c
- * $Revision: 1.21 $
+ * $Revision: 1.23 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -395,7 +395,7 @@ static enc_fw_info_t firmware[10] = {
 
 int topaz_init_tnc(unsigned long wb_offset, void *wb_addr, void *firmware_addr)
 {
-	drm_emgd_private *priv;
+	drm_emgd_priv_t *priv;
 	igd_context_t *context;
 	unsigned char *mmio;
 	unsigned long size;
@@ -411,7 +411,7 @@ int topaz_init_tnc(unsigned long wb_offset, void *wb_addr, void *firmware_addr)
 
 	/* Only support Atom E6xx */
 	if ((PCI_DEVICE_ID_VGA_TNC != context->device_context.did)||
-  	   (context->device_context.bid == PCI_DEVICE_ID_BRIDGE_TNC_ULP)) {
+	   (context->device_context.bid == PCI_DEVICE_ID_BRIDGE_TNC_ULP)) {
 		return -1;
 	}
 
@@ -441,7 +441,8 @@ int topaz_init_tnc(unsigned long wb_offset, void *wb_addr, void *firmware_addr)
 	printk(KERN_INFO "Topaz write back sync offset = %lx", topaz_priv->topaz_sync_offset);
 	*/
 
-	*(topaz_priv->topaz_sync_addr) = ~0; /*reset sync seq */
+	*(topaz_priv->topaz_sync_addr) = 0; /*reset sync seq */
+	topaz_priv->topaz_sync_id = 0; /*reset sync id */
 
 	/* firmware part */
 	/* allocate memory for all firmwares */
@@ -613,80 +614,6 @@ int topaz_setup_fw(igd_context_t *context, enum tnc_topaz_encode_fw codec)
 
 	topaz_flush_tnc(context);
 
-#if 0
- 	unsigned long reg = EMGD_READ32(mmio+TNC_TOPAZ_IMG_TOPAZ_INTSTAT);
-	printk( KERN_INFO "sync: TOPAZ_INTSTAT= 0x%08x ", reg);
-	reg = EMGD_READ32(mmio+TNC_TOPAZ_MMU_STATUS);
-	printk( KERN_INFO "sync: TOPAZ_MMU_STATUS= 0x%08x ", reg);
-#endif
-
-#if 0
-/* DEBUG ONLY */
-/* test sync command */
-{
-		unsigned long value;
-		unsigned long sync_cmd[3];
-		unsigned long *sync_p = (unsigned long *)topaz_priv->topaz_sync_addr;
-		int count = 1000, k=0, r=0;
-
-	for(k=0;k<3;k++){
-
-		/* insert a SYNC command here */
-        	topaz_priv->topaz_sync_cmd_seq = (1 << 15) |
-                                topaz_priv->topaz_cmd_seq++;
-        	sync_cmd[0] = (MTX_CMDID_SYNC << 1) | (3 << 8) |
-                	(topaz_priv->topaz_sync_cmd_seq << 16);
-        	sync_cmd[1] = topaz_priv->topaz_sync_offset;
-        	sync_cmd[2] = topaz_priv->topaz_sync_cmd_seq;
-
-		printk(KERN_INFO "sync test: RI before sync =%ld", CCB_CTRL_RINDEX(context));
-		TOPAZ_BEGIN_CCB(context);
-		TOPAZ_OUT_CCB(context, sync_cmd[0]);
-		TOPAZ_OUT_CCB(context, sync_cmd[1]);
-		TOPAZ_OUT_CCB(context, sync_cmd[2]);
-
-		reg = EMGD_READ32(mmio+TNC_TOPAZ_IMG_TOPAZ_INTSTAT);
-		printk( KERN_INFO "sync: TOPAZ_INTSTAT= 0x%08x ", reg);
-
-		TOPAZ_END_CCB(context, 1);
-		/*
-		for(count_reg=0; count_reg<352; count_reg+=4){
-                        value = EMGD_READ32(mmio+TOPAZ_BASE+count_reg);
-                        printk(KERN_INFO "MTX reg: ofs=0x%04x, value=0x%08x", count_reg, value);
-                }
-         */
-
-
-
-		while (count && *sync_p != topaz_priv->topaz_sync_cmd_seq) {
-			OS_SLEEP(1000);
-			--count;
-		}
-		if ((count == 0) && (*sync_p != topaz_priv->topaz_sync_cmd_seq)) {
-			printk(KERN_INFO "TOPAZ: wait sycn timeout (0x%08x),"
-				"actual 0x%08x\n",
-				topaz_priv->topaz_sync_cmd_seq, *sync_p);
-		}else{
-			printk(KERN_INFO "TOPAZ: SYNC done, seq=0x%08x\n", *sync_p);
-		}
-
-		printk(KERN_INFO "RI after sync =%ld", CCB_CTRL_RINDEX(context));
-
-		reg = EMGD_READ32(mmio+TNC_TOPAZ_IMG_TOPAZ_INTSTAT);
-		printk( KERN_INFO "sync: TOPAZ_INTSTAT= 0x%08x ", reg);
-		reg = EMGD_READ32(mmio+TNC_TOPAZ_MMU_STATUS);
-		printk( KERN_INFO "sync: TOPAZ_MMU_STATUS= 0x%08x ", reg);
-	}
-
-/*
-                for(r=0;r<100;r++){
-                        printk(KERN_INFO "syncp=0x%08x",*sync_p);
-                        sync_p++;
-                }
-*/
-}
-#endif
-
 	return 0;
 }
 
@@ -969,7 +896,7 @@ void release_mtx_control_from_dash(igd_context_t *context)
 
 int process_video_encode_tnc(igd_context_t *context, unsigned long offset, void *virt_addr, unsigned long *fence_id)
 {
-        unsigned long *mtx_buf;
+    unsigned long *mtx_buf;
 	unsigned long size=0;
 	int ret = 0;
 	platform_context_plb_t *platform;
@@ -981,26 +908,21 @@ int process_video_encode_tnc(igd_context_t *context, unsigned long offset, void
 	topaz_priv = &platform->tpz_private_data;
 	mtx_buf = (unsigned long *) virt_addr;
 
-        EMGD_DEBUG("process_video_encode_tnc where buf=%p, offset=%lx\n",
-				mtx_buf, offset);
+	EMGD_DEBUG("process_video_encode_tnc where buf=%p, offset=%lx\n",
+		mtx_buf, offset);
 
 	platform->topaz_busy = 1;
 	ret = process_encode_mtx_messages(context, mtx_buf, size);
 	if (ret){
- 		printk(KERN_INFO "Invalid topaz encode cmd");
-               	ret = -EINVAL;
+		printk(KERN_INFO "Invalid topaz encode cmd");
+	ret = -EINVAL;
         }
 
-	*fence_id = topaz_priv->topaz_sync_cmd_seq;
+	*fence_id = topaz_priv->topaz_sync_id;
 	platform->topaz_busy = 0;
 	return ret;
 }
 
-int topaz_get_fence_id(igd_context_t *context, unsigned long *fence_id)
-{
-	return 0;
-}
-
 int topaz_flush_tnc(igd_context_t *context)
 {
 	unsigned char *mmio = context->device_context.virt_mmadr;
@@ -1008,7 +930,7 @@ int topaz_flush_tnc(igd_context_t *context)
 
 	/* Only support Atom E6xx */
 	if ((PCI_DEVICE_ID_VGA_TNC != context->device_context.did)||
-  	   (context->device_context.bid == PCI_DEVICE_ID_BRIDGE_TNC_ULP)) {
+	   (context->device_context.bid == PCI_DEVICE_ID_BRIDGE_TNC_ULP)) {
 		return -1;
 	}
 
@@ -1047,52 +969,17 @@ int topaz_get_frame_skip(igd_context_t *context, unsigned long *frame_skip)
 	return 0;
 }
 
-int topaz_sync_surface(igd_context_t *context, unsigned long *sync_done, int *last_frame)
+int topaz_get_fence_id(igd_context_t *context, unsigned long *fence_id)
 {
 	tnc_topaz_priv_t *topaz_priv;
-	platform_context_tnc_t *platform;
 	unsigned long *sync_p;
+	platform_context_tnc_t *platform;
 
 	platform = (platform_context_tnc_t *)context->platform_context;
 	topaz_priv = &platform->tpz_private_data;
 	sync_p = (unsigned long *)topaz_priv->topaz_sync_addr;
 
-	if(*last_frame){
-		if( CCB_CTRL_SEQ(context) == *sync_p ) {
-			*sync_done = 1;
-		} else {
-			*sync_done = 0;
-		}
-		return 0;
-	}
-
-
-	/* For rate-control, will check the sync by matching the current CCB_CTRL_SEQ
- 	 * with current frame sync value. */
-	/* For NO rate-control, will check the sync by using topaz_sync_val which is the sync
- 	 * value for the previous frame */
-	if( (topaz_priv->topaz_cur_codec != FW_H264_NO_RC) &&
-            (topaz_priv->topaz_cur_codec != FW_MPEG4_NO_RC) &&
-            (topaz_priv->topaz_cur_codec != FW_H263_NO_RC) ){
-		if( CCB_CTRL_SEQ(context) == topaz_priv->topaz_sync_cmd_seq ){
-			*sync_done = 1;
-		}else{
-			*sync_done = 0;
-		}
-	}else{
-		EMGD_DEBUG("\nctrl_c=0x%08lx, sync_p=0x%08lx, s_val=0x%08lx, s_seq=0x%08lx", CCB_CTRL_SEQ(context),
-			*sync_p, topaz_priv->topaz_sync_val, topaz_priv->topaz_sync_cmd_seq);
-		if( CCB_CTRL_SEQ(context) == topaz_priv->topaz_sync_val ){
-			/* If currect CCB_CTRL_SEQ is sync_val, then the previou frame encode already done */
-                       *sync_done = 1;
-                }else if( (CCB_CTRL_SEQ(context) & ~0x8000) > (topaz_priv->topaz_sync_val & ~0x8000) ){
-			/* If the sync_val is smaller than the CTRL_SEQ, then the previous frame encode
- 			 * already done	*/
-			*sync_done = 1;
-		}else{
-			*sync_done = 0;
-		}
-	}
+	*fence_id = *sync_p;
 
 	return 0;
 }
diff --git a/drivers/gpu/drm/emgd/include/emgd_drm.h b/drivers/gpu/drm/emgd/include/emgd_drm.h
index b24bf27..06e30ec 100644
--- a/drivers/gpu/drm/emgd/include/emgd_drm.h
+++ b/drivers/gpu/drm/emgd/include/emgd_drm.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: emgd_drm.h
- * $Revision: 1.49 $
+ * $Revision: 1.58 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -79,11 +79,16 @@ enum {
 #define CMD_VIDEO_SHUTDOWN        6
 #define CMD_VIDEO_GET_FENCE_ID    7
 #define CMD_VIDOE_GET_FRAME_SKIP  8
+#define CMD_VIDEO_GET_MSVDX_STATUS  	  9
 
 /* Video state */
 #define VIDEO_STATE_FW_LOADED     	0x00000001
 #define VIDEO_STATE_RENDEC_FREED        0x00000002
 
+/* Different command for alter_ovl2 */
+#define CMD_ALTER_OVL2			1
+#define CMD_ALTER_OVL2_OSD		2
+
 typedef enum _kdrm_test_pvrsrv_opcodes {
 	SINGLE_DC_SWAPING        = 0,
 	DIH_DC_DRAW_OPEN_DEV1    = 1,
@@ -145,7 +150,7 @@ typedef struct _kdrm_alter_ovl {
 	/* NOTE: igd_surface_t contains a pointer to an igd_palette_info_t struct
 	 * (member name "palette_info"), which contains a pointer to an "unsigned
 	 * long" "palette".  Normally, each of these values must be copied from
-	 * user to kernel space.  However, Ian's investigation found that the
+	 * user to kernel space.  However, an investigation found that the
 	 * igd_palette_info_t struct is not used for either alter_ovl() or
 	 * set_surface() (and igd_get_surface_plb() sets the value to 0,
 	 * a.k.a. NULL).  Thus, we're okay not copying this value.
@@ -165,6 +170,7 @@ typedef struct _kdrm_alter_ovl2 {
 	igd_rect_t dst_rect; /* (DOWN) */
 	igd_ovl_info_t ovl_info; /* (DOWN) */
 	unsigned long flags; /* (DOWN) */
+	int cmd; /* (DOWN) */
 } emgd_drm_alter_ovl2_t;
 
 
@@ -241,6 +247,12 @@ typedef struct _kdrm_get_drm_config {
 	igd_param_t params; /* (UP) */
 	/** The display config (e.g. 8 for DIH). */
 	int display_config; /* (UP) */
+	/*
+	 * Build configuration (e.g., DDK version used, debug vs release, etc.);
+	 * if these don't match what userspace was built with, the driver may not
+	 * run properly.  (UP)
+	 */
+	igd_build_config_t build_config;
 } emgd_drm_get_drm_config_t;
 
 
@@ -389,7 +401,8 @@ typedef struct _kdrm_video_get_info {
 	int last_frame;
 	unsigned long fence_id;
 	unsigned long frame_skip;
-	unsigned long sync_done;
+	unsigned long queue_status; /* (UP) - return 1 if msvdx queue empty, else 0 */
+	unsigned long mtx_msg_status; /* (UP) - return 1 if msvdx current message complete, else 0 */
 } emgd_drm_video_get_info_t;
 
 typedef struct _kdrm_video_flush_tlb {
@@ -397,6 +410,19 @@ typedef struct _kdrm_video_flush_tlb {
 	int engine;
 } emgd_drm_video_flush_tlb_t;
 
+typedef struct _kdrm_get_display_info {
+	int rtn; /* (UP) - return value of HAL procedure */
+	igd_display_info_t primary_pt_info; /* (UP) */
+	igd_display_info_t secondary_pt_info; /* (UP) */
+	igd_framebuffer_info_t primary_fb_info; /* (UP) */
+	igd_framebuffer_info_t secondary_fb_info; /* (UP) */
+	unsigned long dc; /* (UP) */
+	unsigned long flags; /* (UP) */
+
+	igd_display_h primary; /* (UP) Generated "opaque handle" */
+	igd_display_h secondary; /* (UP) Generated "opaque handle" */
+} emgd_drm_get_display_info_t;
+
 typedef struct _kdrm_pan_display {
 	/* Note: the return value is a long this time: */
 	long rtn; /* (UP) - return value of HAL procedure */
@@ -505,6 +531,46 @@ typedef struct _kdrm_set_surface {
 	unsigned long flags; /* (DOWN) */
 } emgd_drm_set_surface_t;
 
+#define CLONE_PRIMARY 0
+#define CLONE_SECONDARY 1
+#define CLONE 0
+#define DIH   1
+
+
+typedef struct _kdrm_dihclone_set_surface {
+	int rtn; /* (UP) - return value of HAL procedure */
+	unsigned long dih_clone_display; /* (DOWN) - primary or secondary display to clone */
+	unsigned long mode; /* (DOWN) - dih to clone or back to dih */
+} emgd_drm_dihclone_set_surface_t;
+
+typedef struct _kdrm_control_plane_format {
+	/* Note on modification to the structure to accomodate both
+	 * Use PRIMARY/SECONDARY to indicate which display
+	 * FB blend + overlay to turn ON/OFF. The relationship between
+	 * plane, pipe and port is transparent to the user.
+	 * A qualifier (use_plane) is used to decide which model the user wants.
+	 */
+	int rtn; /* (UP) - return value of HAL procedure */
+	/* 	(DOWN) Turn off transparency by switching to XRGB format = 0
+		Turn on transparency by switching to ARGB format = 1 */
+	int enable;
+	union {
+		/* 	(DOWN) Plane A = 0
+			Plane B = 1 */
+		int display_plane;
+		/* 	(DOWN) Primary/Secondary display handle */
+		igd_display_h primary_secondary_dsp;
+	};
+	/* If set, KMD will use the plane convention */
+	unsigned int use_plane;
+} emgd_drm_control_plane_format_t;
+
+
+typedef struct _kdrm_set_overlay_display{
+	int rtn; /* (UP) - return value of HAL procedure */
+	igd_display_h ovl_display[OVL_MAX_HW]; /* (DOWN) Overlay display handles */
+} emgd_drm_set_overlay_display_t;
+
 
 typedef struct _kdrm_sync {
 	int rtn; /* (UP) - return value of HAL procedure */
@@ -566,6 +632,10 @@ typedef struct _kdrm_test_pvrsrv {
 } emgd_drm_test_pvrsrv_t;
 
 
+typedef struct _kdrm_query_2d_caps_hwhint {
+	unsigned long caps_val; /* (DOWN) */
+	unsigned long *status; /* (UP) */
+} emgd_drm_query_2d_caps_hwhint_t;
 
 /*
  * This is where all the IOCTL's used by the egd DRM interface are
@@ -601,7 +671,12 @@ typedef struct _kdrm_test_pvrsrv {
 #define DRM_IGD_GMM_FLUSH_CACHE      0x11
 #define DRM_IGD_GMM_GET_NUM_SURFACE  0x31
 #define DRM_IGD_GMM_GET_SURFACE_LIST 0x32
-#define DRM_IGD_GET_GOLDEN_HTOTAL	 0x33
+#define DRM_IGD_GET_GOLDEN_HTOTAL    0x33
+#define DRM_IGD_CONTROL_PLANE_FORMAT 0x34
+#define DRM_IGD_QUERY_2D_CAPS_HWHINT 0x35
+#define DRM_IGD_DIHCLONE_SET_SURFACE 0x36
+#define DRM_IGD_SET_OVERLAY_DISPLAY  0x37
+
 /*
  * The EMGD DRM includes the PVR DRM, and as such, includes the following PVR
  * DRM ioctls.  The numbering must be kept in sync with what is defined in
@@ -644,6 +719,7 @@ typedef struct _kdrm_test_pvrsrv {
 #define DRM_IGD_GET_OVL_INIT_PARAMS 0x2e
 #define DRM_IGD_ALTER_OVL2          0x2f
 #define DRM_IGD_GET_CHIPSET_INFO    0x30
+#define DRM_IGD_GET_DISPLAY_INFO    0x38
 
 /*
  * egd IOCTLs.
@@ -718,6 +794,10 @@ typedef struct _kdrm_test_pvrsrv {
 		emgd_drm_query_mode_list_t)
 #define DRM_IOCTL_IGD_GET_GOLDEN_HTOTAL  DRM_IOWR(DRM_IGD_GET_GOLDEN_HTOTAL + BASE,\
 		emgd_drm_get_golden_htotal_t)
+#define DRM_IOCTL_IGD_CONTROL_PLANE_FORMAT DRM_IOWR(DRM_IGD_CONTROL_PLANE_FORMAT + BASE,\
+		emgd_drm_control_plane_format_t)
+#define DRM_IOCTL_IGD_SET_OVERLAY_DISPLAY DRM_IOWR(DRM_IGD_SET_OVERLAY_DISPLAY + BASE,\
+		emgd_drm_set_overlay_display_t)
 #define DRM_IOCTL_IGD_SET_ATTRS        DRM_IOWR(DRM_IGD_SET_ATTRS + BASE,\
 		emgd_drm_set_attrs_t)
 #define DRM_IOCTL_IGD_SET_PALETTE_ENTRY DRM_IOWR(DRM_IGD_SET_PALETTE_ENTRY +\
@@ -740,6 +820,13 @@ typedef struct _kdrm_test_pvrsrv {
 		emgd_drm_get_ovl_init_params_t)
 #define DRM_IOCTL_IGD_GET_CHIPSET_INFO DRM_IOWR(DRM_IGD_GET_CHIPSET_INFO + BASE,\
 		emgd_drm_driver_get_chipset_info_t)
+#define DRM_IOCTL_IGD_QUERY_2D_CAPS_HWHINT DRM_IOWR(DRM_IGD_QUERY_2D_CAPS_HWHINT + BASE,\
+		emgd_drm_query_2d_caps_hwhint_t)
+#define DRM_IOCTL_IGD_GET_DISPLAY_INFO  DRM_IOR(DRM_IGD_GET_DISPLAY_INFO + BASE,\
+		emgd_drm_get_display_info_t)
+
+#define DRM_IOCTL_IGD_DIHCLONE_SET_SURFACE	DRM_IOWR(DRM_IGD_DIHCLONE_SET_SURFACE + BASE,\
+		emgd_drm_dihclone_set_surface_t)
 
 
 /* From pvr_bridge.h */
@@ -765,4 +852,6 @@ typedef struct _kdrm_test_pvrsrv {
 		emgd_drm_video_get_info_t)
 #define DRM_IOCTL_IGD_VIDEO_FLUSH_TLB  DRM_IOR(DRM_IGD_VIDEO_FLUSH_TLB + BASE,\
 		emgd_drm_video_flush_tlb_t)
+#define DRM_IOCTL_IGD_GET_DISPLAY_INFO  DRM_IOR(DRM_IGD_GET_DISPLAY_INFO + BASE,\
+		emgd_drm_get_display_info_t)
 #endif
diff --git a/drivers/gpu/drm/emgd/include/emgd_shared.h b/drivers/gpu/drm/emgd/include/emgd_shared.h
index 2139334..fe576ed 100644
--- a/drivers/gpu/drm/emgd/include/emgd_shared.h
+++ b/drivers/gpu/drm/emgd/include/emgd_shared.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: emgd_shared.h
- * $Revision: 1.13 $
+ * $Revision: 1.14 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/include/gart.h b/drivers/gpu/drm/emgd/include/gart.h
index c1f12cb..228ac41 100644
--- a/drivers/gpu/drm/emgd/include/gart.h
+++ b/drivers/gpu/drm/emgd/include/gart.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: gart.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/include/igd.h b/drivers/gpu/drm/emgd/include/igd.h
index 2829358..51084ee 100644
--- a/drivers/gpu/drm/emgd/include/igd.h
+++ b/drivers/gpu/drm/emgd/include/igd.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd.h
- * $Revision: 1.14 $
+ * $Revision: 1.21 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -77,7 +77,8 @@ typedef struct _igd_dispatch {
 	 * @param driver_handle The driver handle returned from igd_driver_init().
 	 *
 	 * @param flags Any combination of the @ref driver_save_flags
-	 *  flags which control the types of state to be saved.
+	 *  flags which control the types of state to be saved. Also used to
+	 *  specify where we save the register data.
 	 *
 	 * @return 0 on Success
 	 * @return <0 on Error
@@ -92,10 +93,14 @@ typedef struct _igd_dispatch {
 	 *
 	 * @param driver_handle The driver handle returned from igd_driver_init().
 	 *
+	 * @param flags Used to specify where we are restoring from,
+	 *  @ref driver_save_flags
+	 *
 	 * @return 0 on Success
 	 * @return <0 on Error
 	 */
-	int (*driver_restore)(igd_driver_h driver_handle);
+	int (*driver_restore)(igd_driver_h driver_handle,
+		const unsigned long flags);
 
 	/*!
 	 * Save all driver registers and then restore all
@@ -104,11 +109,12 @@ typedef struct _igd_dispatch {
 	 * is non-null before calling.
 	 *
 	 * @param driver_handle The driver handle returned from igd_driver_init().
+	 * @param flags Flags indicating what registers to save
 	 *
 	 * @return 0 on Success
 	 * @return <0 on Error
 	 */
-	int (*driver_save_restore)(igd_driver_h driver_handle);
+	int (*driver_save_restore)(igd_driver_h driver_handle, unsigned long flags);
 
 	/*!
 	 * Gets the value of a runtime driver parameter. These parameters are
@@ -272,6 +278,41 @@ typedef struct _igd_dispatch {
 		unsigned long flags);
 
 	/*!
+	 * igd_configure_display() Modifies the modes associated with one display
+	 *  pipes according to the dc provided.
+	 *
+	 *  @param driver_handle - required.  This is returned from a call to
+	 *   igd_init_driver().
+	 *
+	 *  @param display A pointer to a display handle that will be used
+	 *   during the call. This handle should be used for all rendering
+	 *   tasks directed to the secondary framebuffer or pipe.
+	 *
+	 *  @param pt_info The display timing information to be used for
+	 *    the display pipe.
+	 *
+	 *  @param fb_info The framebuffer parameters to be used for the
+	 *   display. This data may be larger or smaller than the display
+	 *   timings to allow for centered/panned or scaled modes.
+	 *
+	 *  @param dc A unique identifer to describe the configuration of the
+	 *   displays to be used. This identifier should be one returned from
+	 *   the _igd_dispatch::query_dc() call. See @ref dc_defines.
+	 *
+	 *  @param fb_index What is the 0-based framebuffer index
+	 *
+	 *  @param flags Bitfield to alter the behavior of the call.
+	 */
+	int (*igd_configure_display)(
+	    igd_driver_h driver_handle,
+	    igd_display_h *display,
+	    igd_display_info_t *pt_info,
+	    igd_framebuffer_info_t *fb_info,
+	    unsigned long dc,
+	    int fb_index,
+		unsigned long flags);
+
+	/*!
 	 *  pan_display() pans the display on the display device.
 	 *  It takes a @a x_offset, @a y_offset into the frame buffer and
 	 *  sets the display from (x_offset, y_offset) to
@@ -702,6 +743,23 @@ typedef struct _igd_dispatch {
 		unsigned int type,
 		unsigned long *flags);
 
+	/*!
+	 * This function maps an existing list of pages into the GTT.
+	 *
+	 * @param pagelist The live list of pages to be mapped.  The GMM
+	 *   should not modify or release this list.
+	 * @param gtt_offset The offset into the Gtt memory space at which the
+	 *   pages begin.  This is an output only.
+	 *
+	 * @param numpages The number of pages to map (i.e., length of pagelist).
+	 *
+	 * @returns 0 on Success
+	 * @returns <0 Error
+	 */
+	int (*gmm_import_pages)(void **pagelist,
+			unsigned long *gtt_offset,
+			unsigned long numpages);
+
 	int (*gmm_get_num_surface)(unsigned long *count);
 	int (*gmm_get_surface_list)(unsigned long allocated_size,
 		unsigned long *list_size,
@@ -769,6 +827,23 @@ typedef struct _igd_dispatch {
 	void (*gmm_free)(unsigned long offset);
 
 	/*!
+	 *  This function should be used to release externally-allocated
+	 *  page lists that have been imported into the GMM.  This will
+	 *  simply unmap the pages from the GTT; the pages themselves
+	 *  should subsequently be freed by the external source.
+	 *  Calling with offsets that were not obtained via a
+	 *  prior call to _igd_dispatch::gmm_import_pages() or
+	 *  are invalid and will produce undefined results.
+	 *  Calls to this function are only valid after the igd_module_init()
+	 *  function has been called.
+	 *
+	 * @param offset The offset as provided by the allocation function.
+	 *
+	 * @returns void
+	 */
+	void (*gmm_release_import)(unsigned long offset);
+
+	/*!
 	 * This function returns current memory statistics.
 	 *
 	 * @param memstat An _igd_memstat structure to be populated during the call
@@ -1320,6 +1395,14 @@ typedef struct _igd_dispatch {
 		igd_ovl_info_t      *ovl_info,
 		unsigned int         flags);
 
+/*	int (*alter_ovl2_dihclone)(igd_display_h display_h,
+		igd_surface_t       *src_surf,
+		igd_rect_t          *src_rect,
+		igd_rect_t          *dest_rect,
+		igd_ovl_info_t      *ovl_info,
+		unsigned int         flags);*/
+
+
 	/* igd_ovl.h */
 	/*!
 	 *  Retrieve the kernel mode initialization parameters for overlay.
@@ -1366,6 +1449,24 @@ typedef struct _igd_dispatch {
 		unsigned int *max_width,
 		unsigned int *max_height);
 
+	/*!
+	 * Alter the sprite C plane with the associated osd/subpicture data
+	 */
+    int (*alter_ovl_osd)(igd_display_h display_h,
+        igd_appcontext_h     appcontext_h,
+        igd_surface_t *sub_surface,
+        igd_rect_t *sub_src_rect,
+        igd_rect_t *sub_dest_rect,
+        igd_ovl_info_t      *ovl_info,
+        unsigned int         flags);
+
+	int (*alter_ovl2_osd)(igd_display_h display_h,
+		igd_surface_t *sub_surface,
+		igd_rect_t *sub_src_rect,
+		igd_rect_t *sub_dest_rect,
+		igd_ovl_info_t      *ovl_info,
+		unsigned int         flags);
+
 	/* igd_render.h */
 	_igd_get_surface_fn_t get_surface;
 	_igd_set_surface_fn_t set_surface;
@@ -1474,6 +1575,40 @@ typedef struct _igd_dispatch {
 	 */
 	void (*video_shutdown)(void);
 
+
+	/*!
+	 * Query the hardware on for given 2D Caps.
+	 */
+	void (*query_2d_caps_hwhint)(unsigned long caps_val,
+		unsigned long *status);
+
+	int (*dihclone_set_surface)(
+	unsigned long display_number,
+	unsigned long mode);
+
+	/*!
+	 *  Allows a user mode application to change pixel format of a display
+	 *  plane from XRGB to ARGB and vice versa.
+	 *
+	 * @param enable (IN). Whether to turn on transparency or not with the
+	 *  assumption that XRGB turns off transparency and ARGB turns it on.
+	 *  0 = disable
+	 *  1 = enable
+	 * @param display_plane (IN). Which display plane to change pixel_format of
+	 *  0 = Plane A
+	 *  1 = Plane B
+	 */
+	int (*control_plane_format)(int enable, igd_display_h display_handle);
+
+	/*!
+	 * Overlay Plane assignment override.
+	 */
+	int (*set_ovl_display)(igd_display_h ovl_displays[]);
+
+/*!
+	 * Get MSVDX status.
+	 */
+	int (*msvdx_status)(igd_driver_h driver_handle, unsigned long *queue_status, unsigned long *mtx_msg_status);
 } igd_dispatch_t;
 
 #endif
diff --git a/drivers/gpu/drm/emgd/include/igd_2d.h b/drivers/gpu/drm/emgd/include/igd_2d.h
index 4a2a0d6..f7ee253 100644
--- a/drivers/gpu/drm/emgd/include/igd_2d.h
+++ b/drivers/gpu/drm/emgd/include/igd_2d.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_2d.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/include/igd_appcontext.h b/drivers/gpu/drm/emgd/include/igd_appcontext.h
index 18c38f8..d987937 100644
--- a/drivers/gpu/drm/emgd/include/igd_appcontext.h
+++ b/drivers/gpu/drm/emgd/include/igd_appcontext.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_appcontext.h
- * $Revision: 1.5 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -70,10 +70,3 @@ typedef void *igd_appcontext_h;
 
 
 #endif
-
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: igd_appcontext.h,v 1.5 2011/03/02 22:47:07 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/include/igd_appcontext.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/include/igd_blend.h b/drivers/gpu/drm/emgd/include/igd_blend.h
index 2ea2856..2ea3eb6 100644
--- a/drivers/gpu/drm/emgd/include/igd_blend.h
+++ b/drivers/gpu/drm/emgd/include/igd_blend.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_blend.h
- * $Revision: 1.5 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -71,10 +71,3 @@
  */
 
 #endif /* _IGD_BLEND_H */
-
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: igd_blend.h,v 1.5 2011/03/02 22:47:07 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/include/igd_blend.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/include/igd_debug.h b/drivers/gpu/drm/emgd/include/igd_debug.h
index 2b9d747..b16eeb6 100644
--- a/drivers/gpu/drm/emgd/include/igd_debug.h
+++ b/drivers/gpu/drm/emgd/include/igd_debug.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_debug.h
- * $Revision: 1.8 $
+ * $Revision: 1.9 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/include/igd_errno.h b/drivers/gpu/drm/emgd/include/igd_errno.h
index 9acd760..ee0c69c 100644
--- a/drivers/gpu/drm/emgd/include/igd_errno.h
+++ b/drivers/gpu/drm/emgd/include/igd_errno.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_errno.h
- * $Revision: 1.5 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -33,13 +33,20 @@
 #define _IGD_ERRNO_H
 
 /* Error values, must be <64kb for vBIOS */
-#define IGD_ERROR_NOMEM      0x0001
-#define IGD_ERROR_INVAL      0x0002
-#define IGD_ERROR_BUSY       0x0003
-#define IGD_ERROR_PWRDOWN    0x0004
-#define IGD_ERROR_NODEV      0x0005
-#define IGD_ERROR_HWERROR    0x0006
-#define IGD_ERROR_EDID       0x0007
+#define IGD_ERROR_NOMEM           0x0001
+#define IGD_ERROR_INVAL           0x0002
+#define IGD_ERROR_BUSY            0x0003
+#define IGD_ERROR_PWRDOWN         0x0004
+#define IGD_ERROR_NODEV           0x0005
+#define IGD_ERROR_HWERROR         0x0006
+#define IGD_ERROR_EDID            0x0007
+#define IGD_ERROR_INVAL_CONTEXT   0x0008
+#define IGD_ERROR_INVAL_PARAM     0x0009
+#define IGD_ERROR_IOCTL           0x000A
+#define IGD_ERROR_GENERIC         0x000B
+#define IGD_ERROR_BLT_NOTCOMPLETE 0x000B
+#define IGD_ERROR_NOT_IMPLEMENTED 0x000C
+#define IGD_ERROR_MAPPING_FAILED  0x000D
 
 #define IGD_NO_MEM           IGD_ERROR_NOMEM
 #define IGD_INVAL            IGD_ERROR_INVAL
diff --git a/drivers/gpu/drm/emgd/include/igd_gart.h b/drivers/gpu/drm/emgd/include/igd_gart.h
index 0d3c0f9..568e271f9 100644
--- a/drivers/gpu/drm/emgd/include/igd_gart.h
+++ b/drivers/gpu/drm/emgd/include/igd_gart.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_gart.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/include/igd_gmm.h b/drivers/gpu/drm/emgd/include/igd_gmm.h
index 16e3a6a..db2b2a8 100644
--- a/drivers/gpu/drm/emgd/include/igd_gmm.h
+++ b/drivers/gpu/drm/emgd/include/igd_gmm.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_gmm.h
- * $Revision: 1.10 $
+ * $Revision: 1.12 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -67,6 +67,9 @@
  *   engine. This flag must be set for any render target that may later
  *   be flipped to the front buffer.
  * - IGD_SURFACE_DEPTH The surface may be used as a depth (Z) buffer.
+ * - IGD_SURFACE_DRI2 The surface is a DRI2 allocation (back buffer,
+ *   fake front buffer, etc.).  It should be allocated on the general
+ *   heap rather than the default '2D' heap.
  *
  * - IGD_SURFACE_YMAJOR If the surface is tiled, it is tiled with the
  *     walk in the YMajor direction. This flag is output only unless the
@@ -92,6 +95,7 @@
 #define IGD_SURFACE_DEPTH     0x00000020
 #define IGD_SURFACE_VIDEO     0x00000040
 #define IGD_SURFACE_VIDEO_ENCODE     0x00000080
+#define IGD_SURFACE_DRI2      0x00000100
 
 #define IGD_SURFACE_WALK_MASK 0x00001000
 #define IGD_SURFACE_YMAJOR    0x00001000
diff --git a/drivers/gpu/drm/emgd/include/igd_init.h b/drivers/gpu/drm/emgd/include/igd_init.h
index c2fdbab..011cf93 100644
--- a/drivers/gpu/drm/emgd/include/igd_init.h
+++ b/drivers/gpu/drm/emgd/include/igd_init.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_init.h
- * $Revision: 1.10 $
+ * $Revision: 1.14 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -502,9 +502,39 @@ typedef struct _igd_param {
 	int                 polling;
 	unsigned long 		ref_freq;
 	int 				tuning_wa;
+	unsigned long 		clip_hw_fix;
+
+
+	/* Async flip flickering workaround enable */
+	unsigned long		async_flip_wa;
+
+	/*
+	 * Enable override of following registers when en_reg_override=1.
+	 * Display Arbitration, FIFO Watermark Control, GVD HP_CONTROL,
+	 * Bunit Chickenbits, Bunit Write Flush, Display Chickenbits
+	 */
+	unsigned long		en_reg_override;
+	unsigned long		disp_arb;
+	unsigned long		fifo_watermark1;
+	unsigned long		fifo_watermark2;
+	unsigned long		fifo_watermark3;
+	unsigned long		fifo_watermark4;
+	unsigned long		fifo_watermark5;
+	unsigned long		fifo_watermark6;
+	unsigned long		gvd_hp_control;
+	unsigned long		bunit_chicken_bits;
+	unsigned long		bunit_write_flush;
+	unsigned long		disp_chicken_bits;
+	int					punt_to_3dblit;
 
 } igd_param_t;
 
+typedef struct {
+	unsigned debug : 1;
+	unsigned ddk_version : 16;
+	unsigned emgd_version : 15;
+} igd_build_config_t;
+
 /*! @} */
 
 /*!
@@ -790,6 +820,33 @@ void igd_driver_shutdown_hal(igd_driver_h driver_handle);
 
 
 /*!
+ * @ingroup cleanup
+ * @brief Query 2D capability of the hardware.
+ *
+ * This function query the hardware whether given capabilities value
+ * (caps_val) is supported by hardware.
+ *
+ * @param driver_handle The driver handle returned from igd_driver_init().
+ *
+ * @return void
+ */
+void igd_query_2d_caps_hwhint(igd_driver_h driver_handle,
+			unsigned long caps_val,
+			unsigned long *status);
+
+
+
+/* 2D capabilities to query */
+#define IGD_2D_CAPS_BLT                 0
+
+/* Output of 2D capabilities to query */
+#define IGD_2D_HW_DISABLE                       0
+#define IGD_2D_HW_ENABLE                        1
+#define IGD_2D_CAPS_UNKNOWN                     2
+
+
+
+/*!
  * @addtogroup power_group
  * @{
  */
@@ -801,15 +858,19 @@ void igd_driver_shutdown_hal(igd_driver_h driver_handle);
  * Flags for use with dispatch->driver_save()
  * @{
  */
-#define IGD_REG_SAVE_VGA       0x001
-#define IGD_REG_SAVE_DAC       0x002
-#define IGD_REG_SAVE_MMIO      0x004
-#define IGD_REG_SAVE_RB        0x008
-#define IGD_REG_SAVE_VGA_MEM   0x010
-#define IGD_REG_SAVE_MODE      0x020
-#define IGD_REG_SAVE_BACKLIGHT 0x040
-#define IGD_REG_SAVE_3D        0x080
-#define IGD_REG_SAVE_GTT       0x100
+#define IGD_REG_SAVE_VGA       0x00001
+#define IGD_REG_SAVE_DAC       0x00002
+#define IGD_REG_SAVE_MMIO      0x00004
+#define IGD_REG_SAVE_RB        0x00008
+#define IGD_REG_SAVE_VGA_MEM   0x00010
+#define IGD_REG_SAVE_MODE      0x00020
+#define IGD_REG_SAVE_BACKLIGHT 0x00040
+#define IGD_REG_SAVE_3D        0x00080
+#define IGD_REG_SAVE_GTT       0x00100
+#define IGD_REG_SAVE_TYPE_REG  0x10000
+#define IGD_REG_SAVE_TYPE_CON  0x20000
+#define IGD_REG_SAVE_TYPE_MISC 0x40000
+#define IGD_REG_SAVE_TYPE_MASK 0xF0000
 
 #define IGD_REG_SAVE_ALL (IGD_REG_SAVE_VGA | IGD_REG_SAVE_DAC |  \
 		IGD_REG_SAVE_MMIO | IGD_REG_SAVE_RB | IGD_REG_SAVE_VGA_MEM | \
@@ -828,14 +889,4 @@ void igd_driver_shutdown_hal(igd_driver_h driver_handle);
 
 /*! @} */
 
-
-
-
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: igd_init.h,v 1.10 2011/03/02 22:47:07 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/include/igd_init.h,v $
- *----------------------------------------------------------------------------
- */
-
 #endif /* _IGD_INIT_H_ */
diff --git a/drivers/gpu/drm/emgd/include/igd_interrupt.h b/drivers/gpu/drm/emgd/include/igd_interrupt.h
index 175bcad..6886a20 100644
--- a/drivers/gpu/drm/emgd/include/igd_interrupt.h
+++ b/drivers/gpu/drm/emgd/include/igd_interrupt.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_interrupt.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/include/igd_mode.h b/drivers/gpu/drm/emgd/include/igd_mode.h
index 997a3ed..dcaf863 100644
--- a/drivers/gpu/drm/emgd/include/igd_mode.h
+++ b/drivers/gpu/drm/emgd/include/igd_mode.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_mode.h
- * $Revision: 1.10 $
+ * $Revision: 1.14 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -164,6 +164,7 @@ typedef unsigned long igd_pf_t;
 #define IGD_PF_YUV422_PACKED_UYVY (PF_DEPTH_16| PF_TYPE_YUV_PACKED| 0x000e0000)
 #define IGD_PF_YUV422_PACKED_VYUY (PF_DEPTH_16| PF_TYPE_YUV_PACKED| 0x000f0000)
 #define IGD_PF_YUV411_PACKED_Y41P (PF_DEPTH_12| PF_TYPE_YUV_PACKED| 0x00100000)
+#define IGD_PF_YUV444_PACKED_AYUV (PF_DEPTH_32| PF_TYPE_YUV_PACKED| 0x00340000)
 /*! @} */
 
 /*!
@@ -273,7 +274,7 @@ typedef unsigned long igd_pf_t;
  * unsigned long lookup_table[IGD_PF_NEXT] = {...}; and will then generate
  * compile warnings if the pixel format list length changes.
  */
-#define IGD_PF_NEXT 0x34
+#define IGD_PF_NEXT 0x35
 /*!
  * @name Helper Macros
  * @{
@@ -321,6 +322,11 @@ typedef unsigned long igd_pf_t;
 typedef void* igd_display_h;
 
 /*!
+ * The opaque timing_info handle.
+ */
+typedef void* igd_timing_info_h;
+
+/*!
  * The maximum number of displays available in the display configurations
  * below.
  */
@@ -537,6 +543,12 @@ typedef struct _igd_framebuffer_info {
 	 * (e.g. a PVR services swap-chain buffer) and not the frame buffer.
 	 */
 	unsigned long visible_offset;
+
+	/* this is the offset that will be restored when swithcing back to dih mode from
+	 * dihclone mode
+	 */
+
+	unsigned long saved_offset;
 	/*!
 	 * @brief pixel format of the fb. See @ref pixel_formats
 	 *
@@ -893,11 +905,4 @@ typedef int (*_igd_query_modes_fn_t)(igd_display_h display_handle,
 	igd_display_info_t **mode_list);
 /*! @} */
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: igd_mode.h,v 1.10 2011/03/02 22:47:07 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/include/igd_mode.h,v $
- *----------------------------------------------------------------------------
- */
-
 #endif /* _IGD_MODE_H_ */
diff --git a/drivers/gpu/drm/emgd/include/igd_ovl.h b/drivers/gpu/drm/emgd/include/igd_ovl.h
index 442644b..6a4f355 100644
--- a/drivers/gpu/drm/emgd/include/igd_ovl.h
+++ b/drivers/gpu/drm/emgd/include/igd_ovl.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_ovl.h
- * $Revision: 1.9 $
+ * $Revision: 1.13 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -81,6 +81,7 @@
 #define IGD_FW_VIDEO_OFF	        8
 
 #define IGD_OVL_FORCE_USE_DISP   0x10
+#define IGD_OVL_OSD_ON_SPRITEC   0x20
 #define IGD_OVL_GET_SURFACE_DATA 0x50
 /*! @} */
 
@@ -225,6 +226,9 @@ typedef struct _igd_ovl_video_quality_info{
  */
 #define IGD_OVL_GAMMA_DISABLE               0x00000000
 #define IGD_OVL_GAMMA_ENABLE				0x00000001
+/* UM only flag to indicate individual
+ * plane color correction values should be applied */
+#define IGD_OVL_GAMMA_OVERRIDE               0x00000002
 /*! @} */
 
 /*!
@@ -287,6 +291,8 @@ typedef struct _video_surface_data {
 /* User mode overlay context */
 typedef struct _ovl_um_context {
 	/* OVLADD add additional overlay initialization parameters here. */
+
+	int in_dihclone;
 	int chiptype;
 	void *dispatch; /* can't make this igd_dispatch_t due to circular reference */
 	unsigned long dc;
@@ -302,7 +308,9 @@ typedef struct _ovl_um_context {
 	igd_surface_t blend_surf[OVL_MAX_HW][MAX_BLEND_SURF];
 
 	vid_surf_data_t *vid_surf_data_ptr;
-
+	igd_display_h ovl_display_um[OVL_MAX_HW];
+	igd_ovl_info_t ovl_info_um[OVL_MAX_HW];
+	igd_display_h active_single_ovl;
 } ovl_um_context_t;
 
 
diff --git a/drivers/gpu/drm/emgd/include/igd_pd.h b/drivers/gpu/drm/emgd/include/igd_pd.h
index b226543..21c4a99 100644
--- a/drivers/gpu/drm/emgd/include/igd_pd.h
+++ b/drivers/gpu/drm/emgd/include/igd_pd.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_pd.h
- * $Revision: 1.8 $
+ * $Revision: 1.11 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -231,7 +231,42 @@
 #define PD_ATTR_ID_INVERTER_FREQ		0x47
 #define PD_ATTR_ID_BLM_LEGACY_MODE		0x48
 #define PD_ATTR_ID_RB_SWAP_MODE			0x49
-#define PD_ATTR_ID_NUM_IDS			0x4A  /* Always make this last */
+//************ port driver attributes defined for ch7036 port driver **************//
+#define PD_ATTR_ID_HFLIP			0x54
+#define PD_ATTR_ID_VFLIP			0x55
+
+//hdmi audio
+#define PD_ATTR_ID_AUDIO_I2S_FORMAT		0x56
+#define PD_ATTR_ID_AUDIO_I2S_POLARITY           0x57
+#define PD_ATTR_ID_AUDIO_I2S_LENGH		0x58
+
+#define PD_ATTR_ID_AUDIO_TYPE			0x59 //1- I2S, 0: SPDIF
+
+//display mode tables supported by ch7036
+#define PD_ATTR_ID_HDMI_OUT_MODE		0x5A
+#define PD_ATTR_ID_DVI_OUT_MODE			0x5B
+#define PD_ATTR_ID_CRT_OUT_MODE			0x5C
+
+
+#define PD_ATTR_ID_DITHER_BYPASS		0x5D //to bypass Dither block - note: PD_ATTR_ID_DITHER is for dither selection: 18-18, 18-24, etc...
+#define PD_ATTR_ID_EDID_BYPASS			0x5E //1: bypass (use fixed built-in table, 0: read panel EDID)
+
+//1:hdmi, 0: dvi- note: PD_ATTR_ID_HDMI_CHANNEL will be  inactive after EDID reading is
+//implemented and selected, e.g. PD_ATTR_ID_EDID_BYPASS =0
+#define PD_ATTR_ID_HDMI_CHANNEL			0x5F
+#define PD_ATTR_ID_PLL_REF_DLY			0x60
+#define PD_ATTR_ID_PLL_REF_FBDLY		0x61
+#define PD_ATTR_ID_ROTATE			0x62
+#define PD_ATTR_ID_HSCALE_CRT			0x63
+#define PD_ATTR_ID_VSCALE_CRT			0x64
+
+#define PD_ATTR_ID_LOAD_FIRMWARE		0x65
+#define PD_ATTR_ID_REFRESH			0x66
+
+
+//************ end of ch7036 defined port driver attribute ********** //
+
+#define PD_ATTR_ID_NUM_IDS			0x67  /* Always make this last */
 
 /*! @} */
 
@@ -379,6 +414,10 @@
 #define PD_DISPLAY_HDMI_EXT    0x00000200    /* External HDMI */
 #define PD_DISPLAY_DP_INT      0x00000400    /* Display Port on board */
 #define PD_DISPLAY_DRGB        0x00000800    /* SDVO DRGB display */
+/* new display types introduced by LVDS converter chip, CH7036 */
+#define PD_DISPLAY_LVDS_LHDV   0x00001000  /* lvds converter- converts lvds signals to
+												lvds pass-thru, hdmi, dvi, or vga */
+
 
 #ifdef CONFIG_MICRO
 #define PD_MAKE_ATTR(id, type, name, flags, def, cur, a, b, c) \
@@ -496,11 +535,4 @@ typedef struct _igd_extension_attr {
 
 /*! @} */
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: igd_pd.h,v 1.8 2011/03/12 10:56:24 nanuar Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/include/igd_pd.h,v $
- *----------------------------------------------------------------------------
- */
-
 #endif /* _IGD_PD_H_ */
diff --git a/drivers/gpu/drm/emgd/include/igd_pi.h b/drivers/gpu/drm/emgd/include/igd_pi.h
index 1c97674..bc12a5b 100644
--- a/drivers/gpu/drm/emgd/include/igd_pi.h
+++ b/drivers/gpu/drm/emgd/include/igd_pi.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_pi.h
- * $Revision: 1.7 $
+ * $Revision: 1.9 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -128,10 +128,3 @@ int igd_pd_filter_timings(
 void *igd_pd_get_igd_debug( void );
 
 #endif /* _IGD_PI_H */
-
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: igd_pi.h,v 1.7 2011/03/02 22:47:07 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/include/igd_pi.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/include/igd_pwr.h b/drivers/gpu/drm/emgd/include/igd_pwr.h
index fa3cb2c..3564031 100644
--- a/drivers/gpu/drm/emgd/include/igd_pwr.h
+++ b/drivers/gpu/drm/emgd/include/igd_pwr.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_pwr.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/include/igd_rb.h b/drivers/gpu/drm/emgd/include/igd_rb.h
index 92e9344..3008870 100644
--- a/drivers/gpu/drm/emgd/include/igd_rb.h
+++ b/drivers/gpu/drm/emgd/include/igd_rb.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_rb.h
- * $Revision: 1.5 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -89,11 +89,4 @@ typedef int (*_igd_get_sync_slot_fn_t)(igd_display_h display_handle,
 	unsigned int priority,
 	unsigned int *offset);
 
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: igd_rb.h,v 1.5 2011/03/02 22:47:07 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/include/igd_rb.h,v $
- *----------------------------------------------------------------------------
- */
-
 #endif /* _IGD_RB_H */
diff --git a/drivers/gpu/drm/emgd/include/igd_render.h b/drivers/gpu/drm/emgd/include/igd_render.h
index 74aae11..ee2f099 100644
--- a/drivers/gpu/drm/emgd/include/igd_render.h
+++ b/drivers/gpu/drm/emgd/include/igd_render.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_render.h
- * $Revision: 1.12 $
+ * $Revision: 1.17 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -61,11 +61,33 @@
 #define IGD_PRIORITY_BB        0x4
 
 
+typedef struct _igd_yuv_coeffs {
+	char ry;
+	char ru;
+	char rv;
+   	char gy;
+	char gu;
+	char gv;
+	char by;
+	char bu;
+	char bv;
+
+	short r_const;
+	short g_const;
+	short b_const;
+
+	unsigned char r_shift;
+	unsigned char g_shift;
+	unsigned char b_shift;
+} igd_yuv_coeffs, *pigd_yuv_coeffs;
+
 typedef struct _igd_palette_info {
 	unsigned long *palette;
 	int palette_id;
 	int palette_type;
 	int size;
+
+	igd_yuv_coeffs yuv_coeffs;
 } igd_palette_info_t, *pigd_palette_info_t;
 
 /*
@@ -202,6 +224,7 @@ typedef struct _igd_surface_list {
 #define IGD_RENDER_OP_ROT_270    0x000300
 #define IGD_RENDER_OP_FLIP       0x000400
 #define IGD_RENDER_OP_SKIP_ROT	 0x000800
+#define IGD_RENDER_OP_SKIP_FLIP	 0x008000
 
 /*
  * flags for post process - Deinterlacing and ProcAmpControl.
@@ -247,7 +270,8 @@ typedef struct _igd_dma {
 typedef enum _igd_buffertype {
 	IGD_BUFFER_DISPLAY = 0,
 	IGD_BUFFER_COLOR,
-	IGD_BUFFER_DEPTH
+	IGD_BUFFER_DEPTH,
+	IGD_BUFFER_SAVE
 } igd_buffertype_t;
 
 /*----------------------------------------------------------------------
@@ -504,10 +528,3 @@ typedef int (*_igd_rb_update_fn_t)(
 
 
 #endif /* _IGD_RENDER_H */
-
-/*----------------------------------------------------------------------------
- * File Revision History
- * $Id: igd_render.h,v 1.12 2011/03/02 22:47:07 astead Exp $
- * $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux/egd_drm/include/igd_render.h,v $
- *----------------------------------------------------------------------------
- */
diff --git a/drivers/gpu/drm/emgd/include/igd_reset.h b/drivers/gpu/drm/emgd/include/igd_reset.h
index 82060cb..6150b6c 100644
--- a/drivers/gpu/drm/emgd/include/igd_reset.h
+++ b/drivers/gpu/drm/emgd/include/igd_reset.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_reset.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/include/igd_version.h b/drivers/gpu/drm/emgd/include/igd_version.h
index 9c1fc1c..e846742 100644
--- a/drivers/gpu/drm/emgd/include/igd_version.h
+++ b/drivers/gpu/drm/emgd/include/igd_version.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_version.h
- * $Revision: 1.115.2.3 $
+ * $Revision: 1.175 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -34,8 +34,8 @@
 #define _IGD_VERSION_H
 
 #define IGD_MAJOR_NUM  1
-#define IGD_MINOR_NUM  6
-#define IGD_BUILD_NUM  1922
+#define IGD_MINOR_NUM  10
+#define IGD_BUILD_NUM  2209
 
 #define IGD_PCF_VERSION   0x00000400
 #endif
diff --git a/drivers/gpu/drm/emgd/include/igd_vga.h b/drivers/gpu/drm/emgd/include/igd_vga.h
index 7ac5506..1f232f0 100644
--- a/drivers/gpu/drm/emgd/include/igd_vga.h
+++ b/drivers/gpu/drm/emgd/include/igd_vga.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: igd_vga.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/include/io.h b/drivers/gpu/drm/emgd/include/io.h
index 871ecab..9b534df 100644
--- a/drivers/gpu/drm/emgd/include/io.h
+++ b/drivers/gpu/drm/emgd/include/io.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: io.h
- * $Revision: 1.6 $
+ * $Revision: 1.8 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -364,13 +364,13 @@ static __inline const char *os_get_funcname( const char *name )
 #else
 // Linux kernel mode port I/O
 #define EMGD_READ_PORT8(port)          inb(port)
-#define EMGD_WRITE_PORT8(port, value)  outb(port, value)
+#define EMGD_WRITE_PORT8(port, value)  outb(value, port)
 
 #define EMGD_READ_PORT16(port)         inw(port)
-#define EMGD_WRITE_PORT16(port, value) outw(port, value)
+#define EMGD_WRITE_PORT16(port, value) outw(value, port)
 
 #define EMGD_READ_PORT32(port)         inl(port)
-#define EMGD_WRITE_PORT32(port, value) outl(port, value)
+#define EMGD_WRITE_PORT32(port, value) outl(value, port)
 #endif
 
 #ifdef DEBUG_MEM
diff --git a/drivers/gpu/drm/emgd/include/memmap.h b/drivers/gpu/drm/emgd/include/memmap.h
index 5ad9e38..a02e943 100644
--- a/drivers/gpu/drm/emgd/include/memmap.h
+++ b/drivers/gpu/drm/emgd/include/memmap.h
@@ -1,7 +1,7 @@
-/* -*- pse-c -*-
+/*
  *-----------------------------------------------------------------------------
  * Filename: memmap.h
- * $Revision: 1.5 $
+ * $Revision: 1.6 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
diff --git a/drivers/gpu/drm/emgd/pvr/include4/services.h b/drivers/gpu/drm/emgd/pvr/include4/services.h
index 27904da..0b8efbb 100644
--- a/drivers/gpu/drm/emgd/pvr/include4/services.h
+++ b/drivers/gpu/drm/emgd/pvr/include4/services.h
@@ -283,7 +283,7 @@ typedef struct _PVRSRV_CLIENT_MEM_INFO_
 	#endif
 #endif
 
- 	IMG_HANDLE							hOSMapInfo;
+	IMG_HANDLE							hOSMapInfo;
 
 	struct _PVRSRV_CLIENT_MEM_INFO_		*psNext;
 
diff --git a/drivers/gpu/drm/emgd/pvr/include4/servicesext.h b/drivers/gpu/drm/emgd/pvr/include4/servicesext.h
index 6e014c9..7729e10 100644
--- a/drivers/gpu/drm/emgd/pvr/include4/servicesext.h
+++ b/drivers/gpu/drm/emgd/pvr/include4/servicesext.h
@@ -147,7 +147,7 @@ typedef enum _PVRSRV_PIXEL_FORMAT_ {
 	PVRSRV_PIXEL_FORMAT_YV12			= 22,
 	PVRSRV_PIXEL_FORMAT_I420			= 23,
     PVRSRV_PIXEL_FORMAT_IMC2            = 25,
-	PVRSRV_PIXEL_FORMAT_XRGB8888,
+	PVRSRV_PIXEL_FORMAT_XRGB8888        = 26,
 	PVRSRV_PIXEL_FORMAT_XBGR8888,
 	PVRSRV_PIXEL_FORMAT_BGRA8888,
 	PVRSRV_PIXEL_FORMAT_XRGB4444,
diff --git a/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.c b/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.c
index e3d18b1..6979ce1 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.c
@@ -47,7 +47,7 @@ static emgd_error_t disable_event_notification(emgddc_devinfo_t *devinfo);
 static void flush_flip_queue(emgddc_swapchain_t *swap_chain);
 static PVRSRV_ERROR do_mode_change(igd_context_t *context,
 		emgddc_devinfo_t *devinfo,
-		drm_emgd_private *priv,
+		drm_emgd_priv_t *priv,
 		DISPLAY_SURF_ATTRIBUTES *dst_surf_attrib);
 
 
@@ -473,6 +473,7 @@ static PVRSRV_ERROR GetDCBufferAddr(IMG_HANDLE device_h,
 
 
 	if (!device_h) {
+		printk(KERN_ERR "[EMGD] %s() Null device handle.\n", __FUNCTION__);
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
@@ -484,8 +485,13 @@ static PVRSRV_ERROR GetDCBufferAddr(IMG_HANDLE device_h,
 	}
 
 	context = devinfo->priv->context;
+	if (!context || (context->dispatch.gmm_get_page_list == NULL)) {
+		printk(KERN_ERR "[EMGD] %s() HAL not configured.\n", __FUNCTION__);
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
 
 	if (!buffer_h) {
+		printk(KERN_ERR "[EMGD] %s() Null buffer handle.\n", __FUNCTION__);
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
@@ -497,6 +503,7 @@ static PVRSRV_ERROR GetDCBufferAddr(IMG_HANDLE device_h,
 
 	EMGD_DEBUG("  phys_addr = 0x%p", phys_addr);
 	EMGD_DEBUG("  *phys_addr = 0x%p", (*phys_addr));
+
 	if ((ret = context->dispatch.gmm_get_page_list(system_buffer->offset,
 		(unsigned long **) phys_addr, &page_count)) != 0) {
 		printk(KERN_ERR"Cannot get the page addresses for the buffer at offset "
@@ -727,7 +734,7 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE device_h,
 	unsigned long lock_flags;
 
 	struct drm_device* drm_dev;
-	drm_emgd_private *priv;
+	drm_emgd_priv_t *priv;
 	igd_context_t *context;
 	igd_dispatch_t *dispatch;
 	int flipable;
@@ -1026,7 +1033,7 @@ static PVRSRV_ERROR DestroyDCSwapChain(IMG_HANDLE device_h,
 	IMG_HANDLE swap_chain_h)
 {
 	emgddc_devinfo_t	*devinfo;
-	drm_emgd_private *priv;
+	drm_emgd_priv_t *priv;
 	igd_context_t *context;
 	igd_dispatch_t *dispatch;
 	emgddc_swapchain_t *swap_chain;
@@ -1528,7 +1535,7 @@ static IMG_VOID SetDCState(IMG_HANDLE device_h, IMG_UINT32 state)
 	}
 
 	switch (state) {
-  	case DC_STATE_FLUSH_COMMANDS:
+	case DC_STATE_FLUSH_COMMANDS:
 		set_flush_state_external(devinfo, EMGD_TRUE);
 		break;
 	case DC_STATE_NO_FLUSH_COMMANDS:
@@ -1834,8 +1841,8 @@ static IMG_BOOL emgddc_process_flip(IMG_HANDLE cmd_cookie_h,
 	swap_chain = (emgddc_swapchain_t *) flip_cmd->hExtSwapChain;
 
 	if (!is_valid_swap_chain(devinfo, swap_chain, 1)) {
-		/* Note: I (Ian Elliott) have noticed with hardware video decode, that
-		 * it creates pixmap swap chains, and when they are being destroyed (at
+		/* Note: Hardware video decode creates pixmap swap chains,
+		 * and when they are being destroyed (at
 		 * the end of video playback), something tries to flip these
 		 * non-flipable swap chains.  The only way to avoid a hang is to
 		 * "complete" the flip command.
@@ -2014,7 +2021,7 @@ void emgddc_free_all_devinfos(void)
 static emgd_error_t emgddc_init_devinfo(struct drm_device *dev,
 	emgddc_devinfo_t *devinfo, int which_devinfo)
 {
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
 	PVRSRV_DC_DISP2SRV_KMJTABLE	*pvr_jtable;
 	PFN_CMD_PROC cmd_proc_list[EMGDDC_COMMAND_COUNT];
 	IMG_UINT32 sync_count_list[EMGDDC_COMMAND_COUNT][2];
@@ -2098,7 +2105,7 @@ static emgd_error_t emgddc_init_devinfo(struct drm_device *dev,
 	 */
 	cmd_proc_list[DC_FLIP_COMMAND] = emgddc_process_flip;
 
-	/* XXX - Not sure what these are for: */
+	/* FIXME:  Not sure what these are for: */
 	sync_count_list[DC_FLIP_COMMAND][0] = 0;
 	sync_count_list[DC_FLIP_COMMAND][1] = 2;
 
@@ -2132,7 +2139,7 @@ static emgd_error_t init_display(emgddc_devinfo_t *devinfo,
 	igd_display_h display,
 	unsigned short port_number)
 {
-	drm_emgd_private *priv = devinfo->priv;
+	drm_emgd_priv_t *priv = devinfo->priv;
 	igd_context_t *context = priv->context;
 	unsigned long dc = priv->dc;
 	igd_framebuffer_info_t fb_info;
@@ -2349,7 +2356,7 @@ static emgd_error_t init_display(emgddc_devinfo_t *devinfo,
 static int emgddc_reinit_3dd(struct drm_device *dev)
 {
 	emgddc_devinfo_t *devinfo;
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
 	int ret;
 
 	EMGD_TRACE_ENTER;
@@ -2433,7 +2440,7 @@ static int emgddc_reinit_3dd(struct drm_device *dev)
 emgd_error_t emgddc_init(struct drm_device *dev)
 {
 	emgddc_devinfo_t *devinfo;
-	drm_emgd_private *priv = dev->dev_private;
+	drm_emgd_priv_t *priv = dev->dev_private;
 	int ret;
 
 	EMGD_TRACE_ENTER;
@@ -2562,7 +2569,7 @@ emgd_error_t emgddc_deinit(void)
  */
 static PVRSRV_ERROR do_mode_change(igd_context_t *context,
 		emgddc_devinfo_t *devinfo,
-		drm_emgd_private *priv,
+		drm_emgd_priv_t *priv,
 		DISPLAY_SURF_ATTRIBUTES *dst_surf_attrib)
 {
 	struct drm_device* drm_dev;
diff --git a/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.h b/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.h
index 42b5ee9..81b6254 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.h
+++ b/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.h
@@ -71,7 +71,7 @@ typedef struct _emgddc_pixelformat_translator
 typedef struct _emgddc_buffer
 {
 	/** A copy of the drm_emgd_private associated with this buffer. */
-	drm_emgd_private *priv;
+	drm_emgd_priv_t *priv;
 
 	/** The GMM offset of this buffer's memory. */
 	unsigned long offset;
@@ -255,7 +255,7 @@ struct _emgddc_devinfo
 	int which_devinfo;
 
 	/** A copy of the drm_emgd_private associated with this devinfo. */
-	drm_emgd_private *priv;
+	drm_emgd_priv_t *priv;
 
 	/** Private copy of the drm_device associated with this devinfo. */
 	struct drm_device *drm_device;
diff --git a/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc_linux.c b/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc_linux.c
index badb07b..c8d8cdf 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc_linux.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc_linux.c
@@ -97,7 +97,7 @@ void MAKENAME(_Cleanup)(struct drm_device unref__ *dev)
  */
 void emgddc_flip(emgddc_swapchain_t *swap_chain, emgddc_buffer_t *buffer)
 {
-	drm_emgd_private *priv = buffer->priv;
+	drm_emgd_priv_t *priv = buffer->priv;
 	igd_context_t *context = priv->context;
 	igd_surface_t surf;
 	int ret;
diff --git a/drivers/gpu/drm/emgd/pvr/services4/include/pvr_bridge_km.h b/drivers/gpu/drm/emgd/pvr/services4/include/pvr_bridge_km.h
index 4f72792..616e51f 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/include/pvr_bridge_km.h
+++ b/drivers/gpu/drm/emgd/pvr/services4/include/pvr_bridge_km.h
@@ -276,6 +276,11 @@ PVRSRVFreeSharedSysMemoryKM(PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo);
 IMG_IMPORT PVRSRV_ERROR
 PVRSRVDissociateMemFromResmanKM(PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo);
 
+IMG_IMPORT PVRSRV_ERROR
+PVRSRVGetPageListKM(PVRSRV_KERNEL_MEM_INFO *psMemInfo, struct page ***pvPageList,
+	unsigned long *numpages,
+	unsigned long *offset);
+
 #if defined (__cplusplus)
 }
 #endif
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/bridged/bridged_pvr_bridge.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/bridged/bridged_pvr_bridge.c
index e3e3742..7160014 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/bridged/bridged_pvr_bridge.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/bridged/bridged_pvr_bridge.c
@@ -2778,7 +2778,7 @@ PVRSRVInitSrvConnectBW(IMG_UINT32 ui32BridgeID,
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_INITSRV_CONNECT);
 	PVR_UNREFERENCED_PARAMETER(psBridgeIn);
 
-	if(!OSProcHasPrivSrvInit() || PVRSRVGetInitServerState(PVRSRV_INIT_SERVER_RUNNING) || PVRSRVGetInitServerState(PVRSRV_INIT_SERVER_RAN))
+	if(PVRSRVGetInitServerState(PVRSRV_INIT_SERVER_RUNNING) || PVRSRVGetInitServerState(PVRSRV_INIT_SERVER_RAN))
 	{
 		psRetOUT->eError = PVRSRV_ERROR_GENERIC;
 		return 0;
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/bridged/sgx/bridged_sgx_bridge.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/bridged/sgx/bridged_sgx_bridge.c
index d8d6467..de4e697 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/bridged/sgx/bridged_sgx_bridge.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/bridged/sgx/bridged_sgx_bridge.c
@@ -676,7 +676,7 @@ SGXGetMiscInfoBW(IMG_UINT32 ui32BridgeID,
 	IMG_HANDLE hDevMemContextInt = 0;
 	PVRSRV_SGXDEV_INFO *psDevInfo;
 	SGX_MISC_INFO        sMiscInfo;
- 	PVRSRV_DEVICE_NODE *psDeviceNode;
+	PVRSRV_DEVICE_NODE *psDeviceNode;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 							PVRSRV_BRIDGE_SGX_GETMISCINFO);
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/common/deviceclass.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/common/deviceclass.c
index 67e3652..6404db9 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/common/deviceclass.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/common/deviceclass.c
@@ -660,7 +660,7 @@ PVRSRV_ERROR PVRSRVOpenDCDeviceKM (PVRSRV_PER_PROCESS_DATA	*psPerProc,
 
 
 		eError = psDCInfo->psFuncTable->pfnOpenDCDevice(ui32DeviceID,
-                                                        	&psDCInfo->hExtDevice,
+	&psDCInfo->hExtDevice,
 								(PVRSRV_SYNC_DATA*)psDCInfo->sSystemBuffer.sDeviceClassBuffer.psKernelSyncInfo->psSyncDataMemInfoKM->pvLinAddrKM);
 		if(eError != PVRSRV_OK)
 		{
@@ -988,7 +988,7 @@ PVRSRV_ERROR PVRSRVCreateDCSwapChainKM (PVRSRV_PER_PROCESS_DATA	*psPerProc,
 		return PVRSRV_ERROR_TOOMANYBUFFERS;
 	}
 
-#if 0 /* BOB: Removing limiation  to allow 1 buffer allocations */
+#if 0 /* Removing limiation  to allow 1 buffer allocations */
 	if (ui32BufferCount < 2)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVCreateDCSwapChainKM: Too few buffers"));
@@ -1004,7 +1004,7 @@ PVRSRV_ERROR PVRSRVCreateDCSwapChainKM (PVRSRV_PER_PROCESS_DATA	*psPerProc,
 		psSwapChain = PVRSRVFindSharedDCSwapChainKM(psDCInfo, *pui32SwapChainID );
 		if( psSwapChain  )
 		{
-			PVR_DPF((PVR_DBG_ERROR,"PVRSRVCreateDCSwapChainKM: found query"));
+			PVR_DPF((PVR_DBG_MESSAGE,"PVRSRVCreateDCSwapChainKM: found query"));
 
 			eError = PVRSRVCreateDCSwapChainRefKM(psPerProc,
 												  psSwapChain,
@@ -1114,7 +1114,7 @@ PVRSRV_ERROR PVRSRVCreateDCSwapChainKM (PVRSRV_PER_PROCESS_DATA	*psPerProc,
 
 	if( ui32Flags & PVRSRV_CREATE_SWAPCHAIN_SHARED )
 	{
-   		if(! psDCInfo->psDCSwapChainShared )
+		if(! psDCInfo->psDCSwapChainShared )
 		{
 			psDCInfo->psDCSwapChainShared = psSwapChain;
 		}
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/common/devicemem.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/common/devicemem.c
index e2a7c92..42e9366 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/common/devicemem.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/common/devicemem.c
@@ -26,6 +26,7 @@
 #include "buffer_manager.h"
 #include "pdump_km.h"
 #include "pvr_bridge_km.h"
+#include "mm.h"
 
 static PVRSRV_ERROR AllocDeviceMem(IMG_HANDLE		hDevCookie,
 									IMG_HANDLE		hDevMemHeap,
@@ -288,7 +289,7 @@ static PVRSRV_ERROR AllocDeviceMem(IMG_HANDLE		hDevCookie,
 									IMG_SIZE_T		ui32Alignment,
 									PVRSRV_KERNEL_MEM_INFO	**ppsMemInfo)
 {
- 	PVRSRV_KERNEL_MEM_INFO	*psMemInfo;
+	PVRSRV_KERNEL_MEM_INFO	*psMemInfo;
 	BM_HANDLE 		hBuffer;
 
 	PVRSRV_MEMBLK	*psMemBlock;
@@ -1450,3 +1451,90 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceClassMemoryKM(PVRSRV_PER_PROCESS_DATA	*
 	return PVRSRV_OK;
 }
 
+
+/*
+ * PVRSRVGetPageListKM()
+ *
+ * This is an EMGD addition to PVR services.  Given a PowerVR meminfo,
+ * returns a list of pages for that allocation.  This can then be used
+ * by EMGD code for things like mapping into the GTT if the surface
+ * is going to be displayed.
+ *
+ * Note that the page list returned is the live page list and should
+ * not be modified or freed by the caller.
+ */
+IMG_EXPORT
+PVRSRV_ERROR IMG_CALLCONV PVRSRVGetPageListKM(PVRSRV_KERNEL_MEM_INFO *psMemInfo,
+	struct page ***pvPageList,
+	unsigned long *numpages,
+	unsigned long *offset)
+{
+	LinuxMemArea *ma;
+	unsigned long skippages, total_offset;
+
+	/* Sanity check the parameters */
+	if (!psMemInfo || !pvPageList || !numpages) {
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVMapDeviceMemoryKM: invalid parameters"));
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	ma = (LinuxMemArea*)psMemInfo->sMemBlk.hOSMemHandle;
+
+	/* # of pages isn't stored; needs to be calculated from number of bytes */
+	*numpages = (ma->ui32ByteSize + 4095) / 4096;
+
+	/*
+	 * What type of memarea is this?  We can handle ALLOC_PAGES, or SUB_ALLOC
+	 * areas whose earliest ancestor is an ALLOC_PAGES.
+	 */
+	switch (ma->eAreaType) {
+	case LINUX_MEM_AREA_ALLOC_PAGES:
+		*pvPageList = ma->uData.sPageList.pvPageList;
+		*offset = 0;
+		break;
+	case LINUX_MEM_AREA_SUB_ALLOC:
+		/*
+		 * This allocation may be a subarea of a larger allocation.  We'll need to
+		 * figure out the details of the parent allocation first so that we can
+		 * calculate our subset of the page list and appropriate offset into the
+		 * first page.
+		 */
+		total_offset = 0;
+		while (ma->eAreaType == LINUX_MEM_AREA_SUB_ALLOC) {
+			total_offset += ma->uData.sSubAlloc.ui32ByteOffset;
+			ma = ma->uData.sSubAlloc.psParentLinuxMemArea;
+		}
+
+		/*
+		 * We should now have the original ALLOC_PAGES memarea.  Make sure
+		 * it's actually the type we expect.
+		 */
+		if (ma->eAreaType != LINUX_MEM_AREA_ALLOC_PAGES) {
+			PVR_DPF((PVR_DBG_ERROR,
+				"PVRSRVGetPageListKM: meminfo for suballocation did not "
+				"originate from a a page-based allocation (type=%d)",
+				ma->eAreaType));
+			*numpages = 0;
+			return PVRSRV_ERROR_GENERIC;
+		}
+
+		/*
+		 * After taking all nested suballocations into account, figure out
+		 * where in the page list the allocation we care about really starts.
+		 */
+		skippages = total_offset / 4096;
+		*offset = total_offset % 4096;
+		*pvPageList = &(ma->uData.sPageList.pvPageList)[skippages];
+
+		break;
+
+	default:
+		PVR_DPF((PVR_DBG_ERROR,
+			"PVRSRVGetPageListKM: meminfo not a page-based allocation or sub-allocation (type=%d)",
+			ma->eAreaType));
+		*numpages = 0;
+		return PVRSRV_ERROR_GENERIC;
+	}
+
+	return PVRSRV_OK;
+}
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/common/hash.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/common/hash.c
index 5ab0e26..981702b 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/common/hash.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/common/hash.c
@@ -446,8 +446,8 @@ HASH_Dump (HASH_TABLE *pHash)
 		if (pHash->ppBucketTable[uIndex] == IMG_NULL)
 			uEmptyCount++;
 		for (pBucket=pHash->ppBucketTable[uIndex];
-             		pBucket != IMG_NULL;
-             		pBucket = pBucket->pNext)
+		pBucket != IMG_NULL;
+		pBucket = pBucket->pNext)
 				uLength++;
 		uMaxLength = PRIVATE_MAX (uMaxLength, uLength);
 	}
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/common/resman.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/common/resman.c
index b6a8022..14b16fe 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/common/resman.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/common/resman.c
@@ -24,9 +24,6 @@
 #include "resman.h"
 
 #ifdef __linux__
-#ifndef AUTOCONF_INCLUDED
- #include <linux/config.h>
-#endif
 
 #include <linux/version.h>
 #include <linux/sched.h>
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/devices/sgx/mmu.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/devices/sgx/mmu.c
index 1057d09..ad24b6f 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/devices/sgx/mmu.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/devices/sgx/mmu.c
@@ -2741,7 +2741,7 @@ static IMG_VOID PageTest(IMG_VOID* pMem, IMG_DEV_PHYADDR sDevPAddr)
 			PVR_DBG_BREAK;
 			bOK = IMG_FALSE;
 		}
- 	}
+	}
 
 	ui32WriteData = 0;
 
@@ -2757,7 +2757,7 @@ static IMG_VOID PageTest(IMG_VOID* pMem, IMG_DEV_PHYADDR sDevPAddr)
 			PVR_DBG_BREAK;
 			bOK = IMG_FALSE;
 		}
- 	}
+	}
 
 	if (bOK)
 	{
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/devices/sgx/sgxinfokm.h b/drivers/gpu/drm/emgd/pvr/services4/srvkm/devices/sgx/sgxinfokm.h
index 165c1de..b4fd589 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/devices/sgx/sgxinfokm.h
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/devices/sgx/sgxinfokm.h
@@ -106,7 +106,7 @@ typedef struct _PVRSRV_SGXDEV_INFO_
 #if defined(PDUMP)
 	IMG_UINT32				ui32KernelCCBEventKickerDumpVal;
 #endif
- 	PVRSRV_KERNEL_MEM_INFO	*psKernelSGXMiscMemInfo;
+	PVRSRV_KERNEL_MEM_INFO	*psKernelSGXMiscMemInfo;
 	IMG_UINT32				aui32HostKickAddr[SGXMKIF_CMD_MAX];
 #if defined(SGX_SUPPORT_HWPROFILING)
 	PPVRSRV_KERNEL_MEM_INFO psKernelHWProfilingMemInfo;
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/devices/sgx/sgxinit.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/devices/sgx/sgxinit.c
index ca22441..45c16dc 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/devices/sgx/sgxinit.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/devices/sgx/sgxinit.c
@@ -135,7 +135,7 @@ static PVRSRV_ERROR InitDevInfo(PVRSRV_PER_PROCESS_DATA *psPerProc,
 
 	psDevInfo->psKernelSGXTA3DCtlMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelSGXTA3DCtlMemInfo;
 
- 	psDevInfo->psKernelSGXMiscMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelSGXMiscMemInfo;
+	psDevInfo->psKernelSGXMiscMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelSGXMiscMemInfo;
 
 #if defined(SGX_SUPPORT_HWPROFILING)
 	psDevInfo->psKernelHWProfilingMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelHWProfilingMemInfo;
@@ -184,7 +184,7 @@ static PVRSRV_ERROR InitDevInfo(PVRSRV_PER_PROCESS_DATA *psPerProc,
 	OSMemCopy(psDevInfo->aui32HostKickAddr, psInitInfo->aui32HostKickAddr,
 			  SGXMKIF_CMD_MAX * sizeof(psDevInfo->aui32HostKickAddr[0]));
 
- 	psDevInfo->bForcePTOff = IMG_FALSE;
+	psDevInfo->bForcePTOff = IMG_FALSE;
 
 	psDevInfo->ui32CacheControl = psInitInfo->ui32CacheControl;
 
@@ -1807,8 +1807,8 @@ PVRSRV_ERROR SGXGetMiscInfoUkernel(PVRSRV_SGXDEV_INFO	*psDevInfo,
 IMG_EXPORT
 PVRSRV_ERROR SGXGetMiscInfoKM(PVRSRV_SGXDEV_INFO	*psDevInfo,
 							  SGX_MISC_INFO			*psMiscInfo,
- 							  PVRSRV_DEVICE_NODE 	*psDeviceNode,
- 							  IMG_HANDLE 			 hDevMemContext)
+							  PVRSRV_DEVICE_NODE 	*psDeviceNode,
+							  IMG_HANDLE 			 hDevMemContext)
 {
 	PPVRSRV_KERNEL_MEM_INFO	psMemInfo = psDevInfo->psKernelSGXMiscMemInfo;
 	IMG_UINT32	*pui32MiscInfoFlags = &((PVRSRV_SGX_MISCINFO_INFO*)(psMemInfo->pvLinAddrKM))->ui32MiscInfoFlags;
@@ -2127,7 +2127,7 @@ PVRSRV_ERROR SGXReadDiffCountersKM(IMG_HANDLE				hDevHandle,
 								   IMG_UINT32				ui32CountersReg,
 								   IMG_UINT32				ui32Reg2,
 								   IMG_BOOL					*pbActive,
- 								   PVRSRV_SGXDEV_DIFF_INFO	*psDiffs)
+								   PVRSRV_SGXDEV_DIFF_INFO	*psDiffs)
 {
 	PVRSRV_ERROR    	eError;
 	SYS_DATA			*psSysData;
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/event.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/event.c
index 472067d..db7d5f3 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/event.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/event.c
@@ -20,10 +20,6 @@
  THE SOFTWARE.
  ******************************************************************************/
 
-#ifndef AUTOCONF_INCLUDED
- #include <linux/config.h>
-#endif
-
 #include <linux/version.h>
 #include <asm/io.h>
 #include <asm/page.h>
@@ -65,8 +61,8 @@ typedef struct PVRSRV_LINUX_EVENT_OBJECT_LIST_TAG
 
 typedef struct PVRSRV_LINUX_EVENT_OBJECT_TAG
 {
-   	atomic_t	sTimeStamp;
-   	IMG_UINT32  ui32TimeStampPrevious;
+	atomic_t	sTimeStamp;
+	IMG_UINT32  ui32TimeStampPrevious;
 #if defined(DEBUG)
 	IMG_UINT	ui32Stats;
 #endif
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mm.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mm.c
index 1bdfe00..69667c5 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mm.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mm.c
@@ -20,10 +20,6 @@
  THE SOFTWARE.
  ******************************************************************************/
 
-#ifndef AUTOCONF_INCLUDED
- #include <linux/config.h>
-#endif
-
 #include <linux/version.h>
 #include <linux/mm.h>
 #include <linux/vmalloc.h>
@@ -997,7 +993,7 @@ NewAllocPagesLinuxMemArea(IMG_UINT32 ui32Bytes, IMG_UINT32 ui32AreaFlags)
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15))
 
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0))
-    	SetPageReserved(pvPageList[i]);
+	SetPageReserved(pvPageList[i]);
 #else
         mem_map_reserve(pvPageList[i]);
 #endif
@@ -1420,7 +1416,7 @@ DebugLinuxMemAreaRecordRemove(LinuxMemArea *psLinuxMemArea)
 	else
 	{
 		PVR_DPF((PVR_DBG_ERROR, "%s: couldn't find an entry for psLinuxMemArea=%p\n",
-        	     __FUNCTION__, psLinuxMemArea));
+	     __FUNCTION__, psLinuxMemArea));
 	}
 
     mutex_unlock(&g_sDebugMutex);
@@ -1485,7 +1481,7 @@ LinuxMemAreaToCpuPAddr(LinuxMemArea *psLinuxMemArea, IMG_UINT32 ui32ByteOffset)
 		CpuPAddr = SysSysPAddrToCpuPAddr(SysPAddr);
                 CpuPAddr.uiAddr += ADDR_TO_PAGE_OFFSET(ui32ByteOffset);
 		if (0 == CpuPAddr.uiAddr) {
-			/* FIXME: REPLACE THIS WITH A DIFFERENT FIX SOMEDAY.  Ian Elliott
+			/* FIXME: REPLACE THIS WITH A DIFFERENT FIX SOMEDAY.
 			 * has only seen this code path be triggered when
 			 * DestroyOffsetStruct() calls this as a parameter for a debug
 			 * statement.  The times its been seen has been when the user-mode
@@ -1676,7 +1672,7 @@ static void ProcSeqShowMemArea(struct seq_file *sfile,void* el)
 
 #if !defined(DEBUG_LINUX_XML_PROC_FILES)
         seq_printf( sfile,
-              			  "Number of Linux Memory Areas: %lu\n"
+			  "Number of Linux Memory Areas: %lu\n"
                           "At the current water mark these areas correspond to %lu bytes (excluding SUB areas)\n"
                           "At the highest water mark these areas corresponded to %lu bytes (excluding SUB areas)\n"
                           "\nDetails for all Linux Memory Areas:\n"
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mm.h b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mm.h
index 7b98876..78f3d14 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mm.h
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mm.h
@@ -23,10 +23,6 @@
 #ifndef __IMG_LINUX_MM_H__
 #define __IMG_LINUX_MM_H__
 
-#ifndef AUTOCONF_INCLUDED
- #include <linux/config.h>
-#endif
-
 #include <linux/version.h>
 #include <linux/slab.h>
 #include <linux/mm.h>
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mmap.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mmap.c
index cdce7e4..a273689 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mmap.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mmap.c
@@ -20,10 +20,6 @@
  THE SOFTWARE.
  ******************************************************************************/
 
-#ifndef AUTOCONF_INCLUDED
- #include <linux/config.h>
-#endif
-
 #include <linux/version.h>
 #include <linux/mm.h>
 #include <linux/module.h>
@@ -785,7 +781,7 @@ static void ProcSeqShowMMapRegistrations(struct seq_file *sfile,void* el)
 		return;
 	}
 
-   	psLinuxMemArea = psOffsetStruct->psLinuxMemArea;
+	psLinuxMemArea = psOffsetStruct->psLinuxMemArea;
 
 	DetermineUsersSizeAndByteOffset(psLinuxMemArea,
 									&ui32RealByteSize,
@@ -870,7 +866,7 @@ PrintMMapRegistrations(IMG_CHAR *buffer, size_t size, off_t off)
     {
         PKV_OFFSET_STRUCT psOffsetStruct;
 
- 	list_for_each_entry(psOffsetStruct, &psLinuxMemArea->sMMapOffsetStructList, sAreaItem)
+	list_for_each_entry(psOffsetStruct, &psLinuxMemArea->sMMapOffsetStructList, sAreaItem)
         {
 	    off--;
 	    if (off == 0)
@@ -880,7 +876,7 @@ PrintMMapRegistrations(IMG_CHAR *buffer, size_t size, off_t off)
 
 		PVR_ASSERT(psOffsetStruct->psLinuxMemArea == psLinuxMemArea);
 
-    		DetermineUsersSizeAndByteOffset(psLinuxMemArea,
+		DetermineUsersSizeAndByteOffset(psLinuxMemArea,
                                    &ui32RealByteSize,
                                    &ui32ByteOffset);
 
@@ -1123,7 +1119,7 @@ PVRMMapCleanup(IMG_VOID)
 	PVR_DPF((PVR_DBG_ERROR, "%s: Memory areas are still registered with MMap", __FUNCTION__));
 
 	PVR_TRACE(("%s: Unregistering memory areas", __FUNCTION__));
- 	list_for_each_entry_safe(psLinuxMemArea, psTmpMemArea, &g_sMMapAreaList, sMMapItem)
+	list_for_each_entry_safe(psLinuxMemArea, psTmpMemArea, &g_sMMapAreaList, sMMapItem)
 	{
 		eError = PVRMMapRemoveRegisteredArea(psLinuxMemArea);
 		if (eError != PVRSRV_OK)
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/module.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/module.c
index 297b4aa..0fd336b 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/module.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/module.c
@@ -20,10 +20,6 @@
  THE SOFTWARE.
  ******************************************************************************/
 
-#ifndef AUTOCONF_INCLUDED
- #include <linux/config.h>
-#endif
-
 #if !defined(SUPPORT_DRI_DRM)
 
 	#if defined(LDM_PLATFORM)
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mutils.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mutils.c
index f6ab483..ce010bf 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mutils.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mutils.c
@@ -20,9 +20,6 @@
  THE SOFTWARE.
  ******************************************************************************/
 
-#ifndef AUTOCONF_INCLUDED
-#include <linux/config.h>
-#endif
 #include <linux/version.h>
 
 #include <linux/spinlock.h>
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mutils.h b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mutils.h
index 4a929e0..625041b 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mutils.h
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/mutils.h
@@ -23,10 +23,6 @@
 #ifndef __IMG_LINUX_MUTILS_H__
 #define __IMG_LINUX_MUTILS_H__
 
-#ifndef AUTOCONF_INCLUDED
-#include <linux/config.h>
-#endif
-
 #include <linux/version.h>
 
 #if !(defined(__i386__) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)))
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/osfunc.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/osfunc.c
index 07084ae..93438ac 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/osfunc.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/osfunc.c
@@ -20,10 +20,6 @@
  THE SOFTWARE.
  ******************************************************************************/
 
-#ifndef AUTOCONF_INCLUDED
- #include <linux/config.h>
-#endif
-
 #include <linux/version.h>
 #include <asm/io.h>
 #include <asm/page.h>
@@ -1692,12 +1688,16 @@ PVRSRV_ERROR OSPCIResumeDev(PVRSRV_PCI_DEV_HANDLE hPVRPCI)
             return PVRSRV_ERROR_GENERIC;
     }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
+	pci_restore_state(psPVRPCI->psPCIDev);
+#else
     err = pci_restore_state(psPVRPCI->psPCIDev);
     if (err != 0)
     {
         PVR_DPF((PVR_DBG_ERROR, "OSPCIResumeDev: pci_restore_state failed (%d)", err));
         return PVRSRV_ERROR_GENERIC;
     }
+#endif
 
     err = pci_enable_device(psPVRPCI->psPCIDev);
     if (err != 0)
@@ -1752,7 +1752,7 @@ static TIMER_CALLBACK_DATA sTimers[OS_MAX_TIMERS];
 #if defined(PVR_LINUX_TIMERS_USING_WORKQUEUES)
 DEFINE_MUTEX(sTimerStructLock);
 #else
-static spinlock_t sTimerStructLock = SPIN_LOCK_UNLOCKED;
+DEFINE_SPINLOCK(sTimerStructLock);
 #endif
 
 static void OSTimerCallbackBody(TIMER_CALLBACK_DATA *psTimerCBData)
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/proc.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/proc.c
index 1559d2e..50245a1 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/proc.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/proc.c
@@ -20,10 +20,6 @@
  THE SOFTWARE.
  ******************************************************************************/
 
-#ifndef AUTOCONF_INCLUDED
- #include <linux/config.h>
-#endif
-
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/version.h>
@@ -221,7 +217,7 @@ static int pvr_proc_seq_show (struct seq_file *proc_seq_file, void *v)
 static struct proc_dir_entry* CreateProcEntryInDirSeq(
 									   struct proc_dir_entry *pdir,
 									   const IMG_CHAR * name,
-    								   IMG_VOID* data,
+								   IMG_VOID* data,
 									   pvr_next_proc_seq_t next_handler,
 									   pvr_show_proc_seq_t show_handler,
 									   pvr_off2element_proc_seq_t off2element_handler,
@@ -275,7 +271,7 @@ static struct proc_dir_entry* CreateProcEntryInDirSeq(
 			seq_handlers->startstop = startstop_handler;
 			seq_handlers->data = data;
 
-        	return file;
+	return file;
 		}
     }
 
@@ -328,7 +324,7 @@ struct proc_dir_entry* CreateProcEntrySeq (
 
 struct proc_dir_entry* CreatePerProcessProcEntrySeq (
 									  const IMG_CHAR * name,
-    								  IMG_VOID* data,
+								  IMG_VOID* data,
 									  pvr_next_proc_seq_t next_handler,
 									  pvr_show_proc_seq_t show_handler,
 									  pvr_off2element_proc_seq_t off2element_handler,
@@ -760,7 +756,7 @@ static void ProcSeqShowVersion(struct seq_file *sfile,void* el)
 
     if(psSysData->pszVersionString)
 	{
-    	pszSystemVersionString = psSysData->pszVersionString;
+	pszSystemVersionString = psSysData->pszVersionString;
     }
 
 	seq_printf( sfile, "System Version String: %s\n", pszSystemVersionString);
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/pvr_bridge_k.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/pvr_bridge_k.c
index c9218eb..8342891 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/pvr_bridge_k.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/pvr_bridge_k.c
@@ -446,7 +446,7 @@ PVRSRV_BridgeDispatchKM(struct file *pFile, IMG_UINT unref__ ioctlCmd, IMG_UINT3
 
 
 		case PVRSRV_BRIDGE_SERVICES_TEST_POWERMGMT:
-    			{
+			{
 				PVRSRV_ERROR eError = PowerMgmtTest();
 				if (psBridgePackageKM->ui32OutBufferSize == sizeof(PVRSRV_BRIDGE_RETURN))
 				{
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/pvr_debug.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/pvr_debug.c
index 0a60896..56d1046 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/pvr_debug.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/pvr_debug.c
@@ -21,10 +21,6 @@
  ******************************************************************************/
 
 
-#ifndef AUTOCONF_INCLUDED
- #include <linux/config.h>
-#endif
-
 #include <asm/io.h>
 #include <asm/uaccess.h>
 #include <linux/kernel.h>
@@ -56,7 +52,7 @@ static IMG_CHAR gszBufferIRQ[PVR_MAX_MSG_LEN + 1];
 
 static struct mutex gsDebugMutexNonIRQ;
 
-static spinlock_t gsDebugLockIRQ = SPIN_LOCK_UNLOCKED;
+DEFINE_SPINLOCK(gsDebugLockIRQ);
 
 #define	USE_SPIN_LOCK (in_interrupt() || !preemptible())
 
@@ -290,7 +286,7 @@ IMG_VOID PVRSRVDebugPrintf	(
 
 				static IMG_CHAR szFileNameRewrite[PVR_MAX_FILEPATH_LEN];
 
-   				IMG_CHAR* pszTruncIter;
+				IMG_CHAR* pszTruncIter;
 				IMG_CHAR* pszTruncBackInter;
 
 
diff --git a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/pvr_drm.c b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/pvr_drm.c
index 36ddf6b..f31f989 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/pvr_drm.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/srvkm/env/linux/pvr_drm.c
@@ -22,10 +22,6 @@
 
 #if defined(SUPPORT_DRI_DRM)
 
-#ifndef AUTOCONF_INCLUDED
- #include <linux/config.h>
-#endif
-
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
diff --git a/drivers/gpu/drm/emgd/pvr/services4/system/common/sysconfig.c b/drivers/gpu/drm/emgd/pvr/services4/system/common/sysconfig.c
index d47e3c4..7d0b989 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/system/common/sysconfig.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/system/common/sysconfig.c
@@ -1,9 +1,9 @@
 /* -*- syscommon-c -*-
  *-----------------------------------------------------------------------------
  * Filename: syscommon.c
- * $Revision: 1.7 $
+ * $Revision: 1.9 $
  *-----------------------------------------------------------------------------
- * Copyright  2002-2010, Intel Corporation.
+ * Copyright (c) 2002-2010, Intel Corporation.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -27,9 +27,6 @@
  * Description: platform detection, and sharing of correct platform interface.
  *
  *-----------------------------------------------------------------------------
- * Authors:
- *  Marcin Tomczyk
- *-----------------------------------------------------------------------------
  */
 
 #include <linux/pci.h>
diff --git a/drivers/gpu/drm/emgd/pvr/services4/system/include/sysconfig.h b/drivers/gpu/drm/emgd/pvr/services4/system/include/sysconfig.h
index da5c906..56abae7 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/system/include/sysconfig.h
+++ b/drivers/gpu/drm/emgd/pvr/services4/system/include/sysconfig.h
@@ -58,11 +58,11 @@ typedef struct _SYS_DATA_TAG_
     PVRSRV_DEVICE_NODE		*psDeviceNodeList;
     PVRSRV_POWER_DEV		*psPowerDeviceList;
 	PVRSRV_RESOURCE			sPowerStateChangeResource;
-   	PVRSRV_SYS_POWER_STATE	eCurrentPowerState;
-   	PVRSRV_SYS_POWER_STATE	eFailedPowerState;
-   	IMG_UINT32		 		ui32CurrentOSPowerState;
+	PVRSRV_SYS_POWER_STATE	eCurrentPowerState;
+	PVRSRV_SYS_POWER_STATE	eFailedPowerState;
+	IMG_UINT32		 		ui32CurrentOSPowerState;
     PVRSRV_QUEUE_INFO		*psQueueList;
-   	PVRSRV_KERNEL_SYNC_INFO *psSharedSyncInfoList;
+	PVRSRV_KERNEL_SYNC_INFO *psSharedSyncInfoList;
     IMG_PVOID				pvEnvSpecificData;
     IMG_PVOID				pvSysSpecificData;
 	PVRSRV_RESOURCE			sQProcessResource;
@@ -274,7 +274,7 @@ static INLINE PVRSRV_ERROR SysAcquireData(SYS_DATA **ppsSysData)
 	if (!gpsSysData)
 	{
 		return PVRSRV_ERROR_GENERIC;
-   	}
+	}
 
 	return PVRSRV_OK;
 }
diff --git a/drivers/gpu/drm/emgd/pvr/services4/system/plb/sysconfig.c b/drivers/gpu/drm/emgd/pvr/services4/system/plb/sysconfig.c
index e480a27..ec0222c 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/system/plb/sysconfig.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/system/plb/sysconfig.c
@@ -1,9 +1,9 @@
 /* -*- syscommon-c -*-
  *-----------------------------------------------------------------------------
  * Filename: syscommon.c
- * $Revision: 1.3 $
+ * $Revision: 1.4 $
  *-----------------------------------------------------------------------------
- * Copyright  2002-2010, Intel Corporation.
+ * Copyright (c) 2002-2010, Intel Corporation.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -27,9 +27,6 @@
  * Description: platform detection, and sharing of correct platform interface.
  *
  *-----------------------------------------------------------------------------
- * Authors:
- *  Marcin Tomczyk
- *-----------------------------------------------------------------------------
  */
 
 #include "sysconfig.h"
diff --git a/drivers/gpu/drm/emgd/pvr/services4/system/tnc/sysconfig.c b/drivers/gpu/drm/emgd/pvr/services4/system/tnc/sysconfig.c
index 1a01069..09e7997 100644
--- a/drivers/gpu/drm/emgd/pvr/services4/system/tnc/sysconfig.c
+++ b/drivers/gpu/drm/emgd/pvr/services4/system/tnc/sysconfig.c
@@ -1,9 +1,9 @@
 /* -*- syscommon-c -*-
  *-----------------------------------------------------------------------------
  * Filename: syscommon.c
- * $Revision: 1.3 $
+ * $Revision: 1.4 $
  *-----------------------------------------------------------------------------
- * Copyright  2002-2010, Intel Corporation.
+ * Copyright (c) 2002-2010, Intel Corporation.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -27,9 +27,6 @@
  * Description: platform detection, and sharing of correct platform interface.
  *
  *-----------------------------------------------------------------------------
- * Authors:
- *  Marcin Tomczyk
- *-----------------------------------------------------------------------------
  */
 
 #include "sysconfig.h"
diff --git a/drivers/gpu/drm/emgd/pvr/tools/intern/debug/dbgdriv/linux/hostfunc.c b/drivers/gpu/drm/emgd/pvr/tools/intern/debug/dbgdriv/linux/hostfunc.c
index f102314..29c3427 100644
--- a/drivers/gpu/drm/emgd/pvr/tools/intern/debug/dbgdriv/linux/hostfunc.c
+++ b/drivers/gpu/drm/emgd/pvr/tools/intern/debug/dbgdriv/linux/hostfunc.c
@@ -133,7 +133,7 @@ void PVRSRVDebugPrintf	(
 
 
 
- 		if (!bTrace)
+		if (!bTrace)
 		{
 			sprintf (&szBuffer[strlen(szBuffer)], " [%d, %s]", (int)ui32Line, pszFileName);
 		}
-- 
1.7.9.7

