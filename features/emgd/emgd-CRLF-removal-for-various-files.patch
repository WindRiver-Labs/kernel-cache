From dd3cb64e723f52f117da75f851a1b3a1786a8c9b Mon Sep 17 00:00:00 2001
From: Donn Seeley <donn.seeley@windriver.com>
Date: Tue, 12 Jun 2012 11:05:33 -0600
Subject: [PATCH 18/19] emgd: CRLF removal for various files.

Many files in EMGD also assume 4-space hard tabs, but that's too annoying
(and inconsistent) to fix.

Signed-off-by: Donn Seeley <donn.seeley@windriver.com>
---
 drivers/gpu/drm/emgd/emgd/drm/image_data.h         |   66 +-
 drivers/gpu/drm/emgd/emgd/pal/ch7036/Makefile.gnu  |   88 +-
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.def    |   10 +-
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.h      |   56 +-
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.c | 2120 +++++------
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.h |  170 +-
 .../drm/emgd/emgd/pal/ch7036/ch7036_def_regmap.h   | 1342 +++----
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.c   |  936 ++---
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.h   |  426 +--
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_iic.h  |   54 +-
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.c | 3976 ++++++++++----------
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.h |  486 +--
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.c | 3096 +++++++--------
 drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.h |  118 +-
 .../drm/emgd/emgd/pal/ch7036/ch7036_reg_table.h    |  114 +-
 .../gpu/drm/emgd/emgd/pal/ch7036/ch7036_typedef.h  |  284 +-
 drivers/gpu/drm/emgd/emgd/pal/ch7036/config_.h     |  146 +-
 drivers/gpu/drm/emgd/include/igd_gmm.h             |  766 ++--
 drivers/gpu/drm/emgd/include/igd_init.h            | 1790 ++++-----
 19 files changed, 8022 insertions(+), 8022 deletions(-)

diff --git a/drivers/gpu/drm/emgd/emgd/drm/image_data.h b/drivers/gpu/drm/emgd/emgd/drm/image_data.h
index b48fc0c..6ca9967 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/image_data.h
+++ b/drivers/gpu/drm/emgd/emgd/drm/image_data.h
@@ -1,33 +1,33 @@
-﻿/*
- *-----------------------------------------------------------------------------
- * Filename: bitmap_data.h
- * $Revision: 1.4 $
- *-----------------------------------------------------------------------------
- * Copyright (c) 2002-2010, Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- *
- *-----------------------------------------------------------------------------
- * Description:
- *
- *-----------------------------------------------------------------------------
- */
-#define DECODE_PNG
-static unsigned char image_data[] = {
-};
+﻿/*
+ *-----------------------------------------------------------------------------
+ * Filename: bitmap_data.h
+ * $Revision: 1.4 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2010, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ * Description:
+ *
+ *-----------------------------------------------------------------------------
+ */
+#define DECODE_PNG
+static unsigned char image_data[] = {
+};
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/Makefile.gnu b/drivers/gpu/drm/emgd/emgd/pal/ch7036/Makefile.gnu
index cb82fd6..83c4c89 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/Makefile.gnu
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/Makefile.gnu
@@ -1,44 +1,44 @@
-#----------------------------------------------------------------------------
-# Filename: Makefile.gnu
-# $Revision: 1.1.2.1 $
-#----------------------------------------------------------------------------
-# INTEL CONFIDENTIAL
-# Copyright (2002-2008) Intel Corporation All Rights Reserved.
-# The source code contained or described herein and all documents related to
-# the source code ("Material") are owned by Intel Corporation or its suppliers
-# or licensors. Title to the Material remains with Intel Corporation or its
-# suppliers and licensors. The Material contains trade secrets and proprietary
-# and confidential information of Intel or its suppliers and licensors. The
-# Material is protected by worldwide copyright and trade secret laws and
-# treaty provisions. No part of the Material may be used, copied, reproduced,
-# modified, published, uploaded, posted, transmitted, distributed, or
-# disclosed in any way without Intel's prior express written permission.
-# 
-# No license under any patent, copyright, trade secret or other intellectual
-# property right is granted to or conferred upon you by disclosure or
-# delivery of the Materials, either expressly, by implication, inducement,
-# estoppel or otherwise. Any license under such intellectual property rights
-# must be express and approved by Intel in writing.
-# 
-#----------------------------------------------------------------------------
-DRV     = ch7036
-SOURCES = \
-            ch7036_port.c \
-            ch7036_intf.c \
-            ch7036_attr.c \
-			ch7036_fw.c \
-            ch7036.c \
-            ch7036_iic.c \
-            ch7036_pm.c \
-            ch7036_reg_table.c \
-            lvds.c
-
-
-include ../Makefile.include
-
-#----------------------------------------------------------------------------
-# File Revision History
-# $Id: Makefile.gnu,v 1.1.2.1 2011/09/13 08:50:22 nanuar Exp $
-# $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux.nonredistributable/ch7036/ch7036pd_src/Attic/Makefile.gnu,v $
-#----------------------------------------------------------------------------
-
+#----------------------------------------------------------------------------
+# Filename: Makefile.gnu
+# $Revision: 1.1.2.1 $
+#----------------------------------------------------------------------------
+# INTEL CONFIDENTIAL
+# Copyright (2002-2008) Intel Corporation All Rights Reserved.
+# The source code contained or described herein and all documents related to
+# the source code ("Material") are owned by Intel Corporation or its suppliers
+# or licensors. Title to the Material remains with Intel Corporation or its
+# suppliers and licensors. The Material contains trade secrets and proprietary
+# and confidential information of Intel or its suppliers and licensors. The
+# Material is protected by worldwide copyright and trade secret laws and
+# treaty provisions. No part of the Material may be used, copied, reproduced,
+# modified, published, uploaded, posted, transmitted, distributed, or
+# disclosed in any way without Intel's prior express written permission.
+#
+# No license under any patent, copyright, trade secret or other intellectual
+# property right is granted to or conferred upon you by disclosure or
+# delivery of the Materials, either expressly, by implication, inducement,
+# estoppel or otherwise. Any license under such intellectual property rights
+# must be express and approved by Intel in writing.
+#
+#----------------------------------------------------------------------------
+DRV     = ch7036
+SOURCES = \
+            ch7036_port.c \
+            ch7036_intf.c \
+            ch7036_attr.c \
+			ch7036_fw.c \
+            ch7036.c \
+            ch7036_iic.c \
+            ch7036_pm.c \
+            ch7036_reg_table.c \
+            lvds.c
+
+
+include ../Makefile.include
+
+#----------------------------------------------------------------------------
+# File Revision History
+# $Id: Makefile.gnu,v 1.1.2.1 2011/09/13 08:50:22 nanuar Exp $
+# $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux.nonredistributable/ch7036/ch7036pd_src/Attic/Makefile.gnu,v $
+#----------------------------------------------------------------------------
+
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.def b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.def
index 49af6a5..566e872 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.def
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.def
@@ -1,5 +1,5 @@
-LIBRARY ch7036
-
-EXPORTS
-    get_version
-    dpd_init
+LIBRARY ch7036
+
+EXPORTS
+    get_version
+    dpd_init
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.h
index 9452854..b138174 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.h
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036.h
@@ -1,30 +1,30 @@
-/*-----------------------------------------------------------------------------
-* Copyright (c) Chrontel Inc.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy
-* of this software and associated documentation files (the "Software"), to deal
-* in the Software without restriction, including without limitation the rights
-* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-* copies of the Software, and to permit persons to whom the Software is
-* furnished to do so, subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in
-* all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-* THE SOFTWARE.
-*
-*-----------------------------------------------------------------------------
-* @file  ch7036.h
-* @version 1.2.2
-*-----------------------------------------------------------------------------
-*/
-
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036.h
+* @version 1.2.2
+*-----------------------------------------------------------------------------
+*/
+
 #ifndef _CH7036_H
 #define _CH7036_H
 
@@ -33,7 +33,7 @@
 
 
 ch_bool DevicePrepare(DEV_CONTEXT* pDevContext);
-	
+
 
 ch_bool DeviceConfig(DEV_CONTEXT* pDevContext);
 
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.c b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.c
index fb5cdfe..a183d19 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.c
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.c
@@ -1,1061 +1,1061 @@
-/*-----------------------------------------------------------------------------
-* Copyright (c) Chrontel Inc.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy
-* of this software and associated documentation files (the "Software"), to deal
-* in the Software without restriction, including without limitation the rights
-* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-* copies of the Software, and to permit persons to whom the Software is
-* furnished to do so, subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in
-* all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-* THE SOFTWARE.
-*
-*-----------------------------------------------------------------------------
-* @file  ch7036_attr.c
-* @version 1.2.5
-*-----------------------------------------------------------------------------
-*/
- 
-
-
-
-#include "ch7036_intf.h"
-#include "ch7036_attr.h"
-
-
-#ifdef T_LINUX
-	#include "lvds/lvds.h"
-#else
-	#include "lvds.h"
-#endif
-
-
-
-static pd_attr_t g_ch7036_attrs[] =
-{
-	
-
-	
-	PD_MAKE_ATTR (PD_ATTR_ID_HPOSITION,   PD_ATTR_TYPE_RANGE, "H Pos.",  0, DEFAULT_POSITION,	DEFAULT_POSITION,                    DEFAULT_POSITION - 40,  DEFAULT_POSITION + 40,  1),
-	PD_MAKE_ATTR (PD_ATTR_ID_VPOSITION,   PD_ATTR_TYPE_RANGE, "V Pos.",  0, DEFAULT_POSITION,	DEFAULT_POSITION,                    DEFAULT_POSITION - 30,  DEFAULT_POSITION + 30,  1),
-	PD_MAKE_ATTR (PD_ATTR_ID_HSCALE,   PD_ATTR_TYPE_RANGE, "H_Scale",  0, HDMI_DEFAULT_UNDERSCAN,   HDMI_DEFAULT_UNDERSCAN,  10,  20,  1),
-	PD_MAKE_ATTR (PD_ATTR_ID_VSCALE,   PD_ATTR_TYPE_RANGE, "V_Scale",  0, HDMI_DEFAULT_UNDERSCAN,     HDMI_DEFAULT_UNDERSCAN,   10,  20,  1),
-	PD_MAKE_ATTR (PD_ATTR_ID_HSCALE_CRT,   PD_ATTR_TYPE_RANGE, "H_Scale",  0, CRT_DEFAULT_UNDERSCAN,   CRT_DEFAULT_UNDERSCAN,  10,  20,  1),
-	PD_MAKE_ATTR (PD_ATTR_ID_VSCALE_CRT,   PD_ATTR_TYPE_RANGE, "V_Scale",  0, CRT_DEFAULT_UNDERSCAN,   CRT_DEFAULT_UNDERSCAN,  10,  20,  1),
-	PD_MAKE_ATTR (PD_ATTR_ID_DITHER,   PD_ATTR_TYPE_RANGE, "Dither", PD_ATTR_FLAG_USER_INVISIBLE, 0,   0,  0,  3,  1),
-	
-	PD_MAKE_ATTR (PD_ATTR_ID_TEXT_FILTER,   PD_ATTR_TYPE_RANGE, "Text Tuning", PD_ATTR_FLAG_USER_INVISIBLE, 4,   DEFAULT_TEXT_ENHANCE,  0,  7,  1),
-	
-
-	PD_MAKE_ATTR (PD_ATTR_ID_DITHER_BYPASS, PD_ATTR_TYPE_BOOL, "Quality Enhance",  0, 0,                 0,                 0, 0, 0),
-	
-	PD_MAKE_ATTR (PD_ATTR_ID_PLL_REF_DLY, PD_ATTR_TYPE_BOOL, "Pll Reference Delay",PD_ATTR_FLAG_USER_INVISIBLE, 0,0,0, 0, 0),
-	PD_MAKE_ATTR (PD_ATTR_ID_PLL_REF_FBDLY,PD_ATTR_TYPE_BOOL, "Pll Reference FBDelay",PD_ATTR_FLAG_USER_INVISIBLE, 1,   1, 0, 0, 0),
-	
-	PD_MAKE_ATTR (PD_ATTR_ID_LOAD_FIRMWARE,PD_ATTR_TYPE_BOOL, "Load Firmware",PD_ATTR_FLAG_USER_INVISIBLE, 0, 1, 0, 0, 0),
-	PD_MAKE_ATTR (PD_ATTR_ID_REFRESH,PD_ATTR_TYPE_BOOL, "Refresh",0, 0,   0, 0, 0, 0),
-	PD_MAKE_ATTR (PD_ATTR_ID_DWNSCAL_BYPASS,PD_ATTR_TYPE_BOOL, "Remove_DS",PD_ATTR_FLAG_USER_INVISIBLE, 0, 1, 0, 0, 0),
-	
-};
-
-
-static ch7036_attr_list_entry_t g_list_entry_hdmi[] =
-{
-	{OUT_HDMI_640x480P_59,		"640x480p_59",PD_ATTR_FLAG_DYNAMIC}, 
-	{OUT_HDMI_640x480P_60,		"640x480p_60",PD_ATTR_FLAG_DYNAMIC}, 
-	{OUT_HDMI_720x480P_59,		"720x480p_59",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_HDMI_720x480P_60,		"720x480p_60",PD_ATTR_FLAG_DYNAMIC},
-
-	{OUT_HDMI_720x576P_50,     "720x576p_50",PD_ATTR_FLAG_DYNAMIC},
-
-	{OUT_HDMI_1280x720P_59,    "1280x720p_59",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_HDMI_1280x720P_60,    "1280x720p_60",PD_ATTR_FLAG_DYNAMIC}, 
-	{OUT_HDMI_1920x1080I_59,   "1920x1080i_59",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_HDMI_1920x1080I_60,   "1920x1080i_60",PD_ATTR_FLAG_DYNAMIC}, 
-	{OUT_HDMI_1920x1080P_59,   "1920x1080p_59",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_HDMI_1920x1080P_60,   "1920x1080p_60",PD_ATTR_FLAG_DYNAMIC}, 
-	
-	{OUT_HDMI_1280x720P_50,    "1280x720p_50",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_HDMI_1920x1080I_50,   "1920x1080i_50",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_HDMI_1920x1080P_50,   "1920x1080p_50",PD_ATTR_FLAG_DYNAMIC},
-	{0, NULL,0}
-};
-
-
-
-static ch7036_attr_list_entry_t g_list_entry_dvi[] =
-{
-
-	{OUT_DVI_640x480_60,	"640x480_60",PD_ATTR_FLAG_DYNAMIC}, 
-	{OUT_DVI_640x480_72,	"640x480_72",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_DVI_640x480_75,	"640x480_75",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_DVI_720x400_70,	"720x400_70",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_DVI_800x600_56,	"800x600_56",PD_ATTR_FLAG_DYNAMIC},
-
-	{OUT_DVI_800x600_60,	"800x600_60",PD_ATTR_FLAG_DYNAMIC}, 
-	{OUT_DVI_800x600_72,	"800x600_72",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_DVI_800x600_75,	"800x600_75",PD_ATTR_FLAG_DYNAMIC},
-
-	{OUT_DVI_1024x768_60,	"1024x768_60",PD_ATTR_FLAG_DYNAMIC}, 
-	{OUT_DVI_1024x768_70,	"1024x768_70",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_DVI_1024x768_75,	"1024x768_75",PD_ATTR_FLAG_DYNAMIC},
-
-	{OUT_DVI_1152x864_60,	"1152x864_60",PD_ATTR_FLAG_DYNAMIC}, 
-
-	{OUT_DVI_1280x720_60,   "1280x720_60",PD_ATTR_FLAG_DYNAMIC}, 
-	{OUT_DVI_1280x800_60,   "1280x800_60",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_DVI_1280x960_60,    "1280x960_60",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_DVI_1280x1024_60,   "1280x1024_60",PD_ATTR_FLAG_DYNAMIC}, 
-	{OUT_DVI_1280x1024_75,   "1280x1024_75",PD_ATTR_FLAG_DYNAMIC},
-
-	{OUT_DVI_1360x768_60,    "1360x768_60",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_DVI_1366x768_60,    "1366x768_60",PD_ATTR_FLAG_DYNAMIC},
-
-	{OUT_DVI_1400x1050_60,   "1400x1050_60",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_DVI_1400x1050_75,   "1400x1050_75",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_DVI_1440x900_60,    "1440x900_60",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_DVI_1440x1050_60,   "1440x1050_60",PD_ATTR_FLAG_DYNAMIC},
-
-	{OUT_DVI_1600x900_60,    "1600x900_60",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_DVI_1600x1200_60,   "1600x1200_60",PD_ATTR_FLAG_DYNAMIC}, 
-	{OUT_DVI_1680x1050_60,   "1680x1050_60",PD_ATTR_FLAG_DYNAMIC},
-
-	{OUT_DVI_1920x1080_60,   "1920x1080_60",PD_ATTR_FLAG_DYNAMIC}, 
-	{0, NULL,0}
-};
-
-
-
-static ch7036_attr_list_entry_t g_list_entry_crt[] =
-{
-	{OUT_CRT_640x400_85, "640x400_85",PD_ATTR_FLAG_DYNAMIC}, 
-
-	{OUT_CRT_640x480_60, "640x480_60",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_CRT_640x480_72, "640x480_72",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_CRT_640x480_75, "640x480_75",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_CRT_640x480_85, "640x480_85",PD_ATTR_FLAG_DYNAMIC},
-
-	{OUT_CRT_720x400_85, "720x400_85",PD_ATTR_FLAG_DYNAMIC},
-
-	{OUT_CRT_800x600_56, "800x600_56",PD_ATTR_FLAG_DYNAMIC},
-	
-	{OUT_CRT_800x600_60, "800x600_60",PD_ATTR_FLAG_DYNAMIC}, 
-	{OUT_CRT_800x600_72, "800x600_72",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_CRT_800x600_75, "800x600_75",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_CRT_800x600_85, "800x600_85",PD_ATTR_FLAG_DYNAMIC}, 
-	
-	{OUT_CRT_1024x768_60,"1024x768_60",PD_ATTR_FLAG_DYNAMIC}, 
-	{OUT_CRT_1024x768_70,"1024x768_70",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_CRT_1024x768_75,"1024x768_75",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_CRT_1024x768_85,"1024x768_85",PD_ATTR_FLAG_DYNAMIC},
-	
-
-	{OUT_CRT_1152x864_75,"1152x864_75",PD_ATTR_FLAG_DYNAMIC}, 
-
-	{OUT_CRT_1280x768_60,"1280x768_60",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_CRT_1280x768_75,"1280x768_75",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_CRT_1280x768_85,"1280x768_85",PD_ATTR_FLAG_DYNAMIC},
-
-	{OUT_CRT_1280x960_60,"1280x960_60",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_CRT_1280x960_85,"1280x960_85",PD_ATTR_FLAG_DYNAMIC},
-
-
-	{OUT_CRT_1280x1024_60,"1280x1024_60",PD_ATTR_FLAG_DYNAMIC}, 
-	{OUT_CRT_1280x1024_75,"1280x1024_75",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_CRT_1280x1024_85,"1280x1024_85",PD_ATTR_FLAG_DYNAMIC},
-
-	{OUT_CRT_1360x768_60,"1360x768_60",PD_ATTR_FLAG_DYNAMIC},
-
-	{OUT_CRT_1400x1050_60,"1400x1050_60",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_CRT_1400x1050_75,"1400x1050_75",PD_ATTR_FLAG_DYNAMIC},
-
-	{OUT_CRT_1440x900_60,"1440x900_60",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_CRT_1440x1050_60,"1440x1050_60",PD_ATTR_FLAG_DYNAMIC},
-
-	{OUT_CRT_1600x900_60,"1600x900_60",PD_ATTR_FLAG_DYNAMIC},
-	
-	{OUT_CRT_1600x1200_60,"1600x1200_60",PD_ATTR_FLAG_DYNAMIC}, 
-	{OUT_CRT_1920x1080_60,"1920x1080_60",PD_ATTR_FLAG_DYNAMIC}, 
-	{0, NULL,0}
-};
-
-
-static ch7036_attr_list_entry_t g_list_entry_channel[] =
-{
-	{CHANNEL_AUTO_DETECT,"Auto Detect",PD_ATTR_FLAG_DYNAMIC},
-	{CHANNEL_LVDS_HDMI, "LVDS_HDMI",PD_ATTR_FLAG_DYNAMIC}, 
-	{CHANNEL_LVDS_DVI, "LVDS_DVI",PD_ATTR_FLAG_DYNAMIC},
-	{CHANNEL_LVDS_VGA,  "LVDS_VGA",PD_ATTR_FLAG_DYNAMIC},
-	{CHANNEL_HDMI, "HDMI",PD_ATTR_FLAG_DYNAMIC}, 
-	{CHANNEL_DVI, "DVI",PD_ATTR_FLAG_DYNAMIC},
-	{CHANNEL_VGA,  "VGA",PD_ATTR_FLAG_DYNAMIC},
-	{0, NULL,0}	
-};
-
-static ch7036_attr_list_header_t g_list_header[] =
-{
-	{7, PD_ATTR_ID_DISPLAY,"Display Channel", 1,1, 
-	g_list_entry_channel},
-
-	{14, PD_ATTR_ID_HDMI_OUT_MODE, "HDMI",7,7,
-	 g_list_entry_hdmi},
-
-	{27, PD_ATTR_ID_DVI_OUT_MODE,"DVI", 9,9,
-	 g_list_entry_dvi},
-
-	{32, PD_ATTR_ID_CRT_OUT_MODE, "VGA", 12,12,
-	 g_list_entry_crt},
-
-	{ 0 }
-};
-
-
-
-ch7036_status_t ch7036_init_attribute_table(ch7036_device_context_t *p_ctx, ch7036_attr_list_header_t* p_list_header)
-{
-	unsigned long ch7036_num_attrs, num_attrs;
-	unsigned char *p_table;
-	
-
-	
-	ch7036_num_attrs = ch7036_enumerate_attr_table(p_ctx, NULL, p_list_header);
-	PD_DEBUG("ch7036_init_attribute_table- ch7036 num_attr = [%lu]\n",ch7036_num_attrs);
-
-	
-	p_ctx->ch7036_num_attrs =  ch7036_num_attrs ;  
-
-
-	if(p_ctx->p_ch7036_attr_table) {
-		pd_free(p_ctx->p_ch7036_attr_table);
-		p_ctx->p_ch7036_attr_table = NULL;
-	}
-
-	
-	if(p_ctx->p_ch7036_attr_table == NULL) {
-	
-		p_ctx->p_ch7036_attr_table = pd_malloc((p_ctx->ch7036_num_attrs + 1) * sizeof(pd_attr_t)); 
-
-		if (p_ctx->p_ch7036_attr_table == NULL) {
-			PD_ERROR("ch7036: Error ! ch7036_init_attribute_table: pd_malloc() failed allocating ch7036_attr_table");
-		
-			return SS_MEM_ALLOC_ERR;
-		}
-
-		pd_memset(p_ctx->p_ch7036_attr_table, 0, (p_ctx->ch7036_num_attrs + 1) *
-			sizeof(pd_attr_t));
-
-	}
-
-
-	p_table = (unsigned char *)p_ctx->p_ch7036_attr_table;
-
-
-	if (p_ctx->ch7036_num_attrs  > 0) {
-
-		num_attrs = ch7036_enumerate_attr_table(p_ctx, (pd_attr_t *)p_table, p_list_header);
-
-
-		PD_DEBUG("ch7036_init_attribute_table: ch7036_enumerate_attr_table()- returned %lu entries, expected %lu\n",
-					  num_attrs, p_ctx->ch7036_num_attrs) ;
-
-	}
-
-	
-	return SS_SUCCESS;
-
-}
-
-
-
-unsigned long ch7036_enumerate_attr_table (ch7036_device_context_t *p_ctx,
-	pd_attr_t *p_attr, ch7036_attr_list_header_t* p_list_header)
-{
-
-	
-	unsigned long num_attrs, i, j, num_attrs_static;
-	ch7036_attr_list_entry_t *list_item;
-	int ret;
-	pd_attr_t *p_table;
-
-	list_item = NULL;
-	num_attrs = 0;
-	i = j = 0;
-
-	
-	PD_DEBUG("ch7036_enumerate_attr_table- enter\n");
-
-
-	
-	if ( p_list_header == NULL )
-			p_list_header = g_list_header; 
-		
-	
-	if (p_attr == NULL) {
-
-		if(p_ctx->p_ch7036_attr_table == NULL) { 
-			ret = PD_INTERNAL_LVDS_MODULE_GET_ATTRIBUTES(ch7036_lvds_get_attrs,(p_ctx->internal_lvds,&(p_ctx->lvds_num_attrs),&(p_ctx->p_lvds_attr_table))); 
-
-			if(ret != PD_SUCCESS)
-				PD_DEBUG("ch7036_enumerate_attr_table: lvds_get_attributes() return ERROR! check this routine\n");
-			else
-				PD_DEBUG("ch7036_enumerate_attr_table: lvds_get_attributes()- lvds num_attr = [%lu]\n",p_ctx->lvds_num_attrs);
-		}
-		
-				
-
-		while (p_list_header[i].num_entries) {
-
-
-			num_attrs += (p_list_header[i].num_entries + 1); 
-			++i;	 
-		}
-
-		num_attrs += ((sizeof(g_ch7036_attrs)/sizeof(pd_attr_t)) + p_ctx->lvds_num_attrs) ;
-
-		return num_attrs; 
-	}
-
-	
-	if(p_ctx->lvds_num_attrs > 0) {
-
-		pd_attr_t *p_lvds_des, *p_lvds_src ;
-
-		
-		p_lvds_src=  (pd_attr_t *)p_ctx->p_lvds_attr_table;
-		p_lvds_des = (pd_attr_t *)p_attr;
-
-		pd_memcpy(p_lvds_des, p_lvds_src, (p_ctx->lvds_num_attrs)*sizeof(pd_attr_t));
-		num_attrs += p_ctx->lvds_num_attrs;
-
-		for (i=0 ; i < p_ctx->lvds_num_attrs; i++, p_lvds_des++) {
-
-			PD_DEBUG("ch7036 : ch7036_enumerate_attr_table : \n"
-				  "adding lvds attr='%s', id=%lu, default=%lu, current=%lu, \n",
-				  p_lvds_des->name, p_lvds_des->id, p_lvds_des->default_value, p_lvds_des->current_value);
-		}
-
-	}
-
-	PD_DEBUG("ch7036 : ch7036_enumerate_attr_table adding lvds num attrs = %lu \n", num_attrs);
-
-	
-
-	i=0;
-
-
-	while (p_list_header[i].num_entries) {
-
-		pd_list_attr_t *p_hdr = (pd_list_attr_t *) &p_attr[num_attrs];
-
-	
-		p_hdr->type	= PD_ATTR_TYPE_LIST;
-		p_hdr->id = p_list_header[i].id;
-		p_hdr->num_entries = p_list_header[i].num_entries;
-		p_hdr->flags |= PD_ATTR_FLAG_DYNAMIC;
-
-		p_hdr->current_index = p_list_header[i].current_index;
-		pd_strcpy(p_hdr->name, p_list_header[i].p_name);
-
-		p_hdr->default_index = p_list_header[i].default_index;
-
-		PD_DEBUG("ch7036 : ch7036_enumerate_attr_table : \n"
-				  "adding attr - list header='%s', id=%lu, default=%lu, current=%lu, \n"
-				  "num_entries=%lu\n",
-				  p_hdr->name, p_hdr->id, p_hdr->default_index, p_hdr->current_index,
-				  p_hdr->num_entries);
-
-		++num_attrs;
-
-
-
-		list_item = p_list_header[i].attr_list;
-		for (j = 0; j < p_list_header[i].num_entries; ++j, ++num_attrs) {
-
-			pd_list_entry_attr_t *p_entry =
-				(pd_list_entry_attr_t *)&p_attr[num_attrs];
-
-			p_entry->id		= p_list_header[i].id;  
-			p_entry->type	= PD_ATTR_TYPE_LIST_ENTRY;
-			p_entry->value	= list_item[j].id;     
-			
-
-			p_entry->flags  = list_item[j].flags; 
-
-			
-			
-			
-			
-
-			
-
-			pd_strcpy(p_entry->name, list_item[j].p_name);
-
-			
-
-			PD_DEBUG("ch7036 : ch7036_enumerate_attr_table : list entry[%lu]=%s, id=[%lu], "
-					  "value=%lu, flags=0x%x \n",
-					  j, p_entry->name, p_entry->id,
-					  p_entry->value, (unsigned char)p_entry->flags);
-					  
-		}
-
-		++i;   
-	}
-
-	
-	p_table = (pd_attr_t *)&p_attr[num_attrs];
-	num_attrs_static = sizeof(g_ch7036_attrs)/sizeof(pd_attr_t);
-	pd_memcpy(p_table, g_ch7036_attrs,num_attrs_static*sizeof(pd_attr_t));
-
-	for (i=0 ; i < num_attrs_static; i++, p_table++) {
-
-		PD_DEBUG("ch7036 : ch7036_enumerate_attr_table : \n"
-				  "adding ch7036 static attr='%s', id=%lu, default=%lu, current=%lu, \n",
-				  p_table->name, p_table->id, p_table->default_value, p_table->current_value);
-
-	}
-
-	num_attrs += num_attrs_static;
-
-
-	return num_attrs;
-
-}
-
-void ch7036_set_dither(ch7036_device_context_t* p_ctx)
-{
-	uint8 reg=0x00;
-	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
-	
-	I2CWrite(p_ch_ctx,0x03, 0x04);
-	reg = I2CRead(p_ch_ctx,0x57);
-    reg = reg & 0x3F;
-
-
-	switch(p_ctx->dither_select)
-	{
-		  case DITHER_18_TO_18: 
-			  reg &= 0x3F;
-			  break;
-		  case DITHER_18_TO_24: 
-			  reg = reg | 0x40;
-			  break;
-		  case DITHER_24_TO_18: 
-			  reg = reg | 0x80;		    
-			  break;
-		  case DITHER_24_TO_24: 
-			  reg = reg | 0xC0;
-			  break;
-		  default:
-			 break;
-    }
-	I2CWrite(p_ch_ctx,0x57, reg);
-
-	return;
-}
-
-
-
-void ch7036_set_audio_type(INPUT_INFO* pInput_Info, uint8 id)
-{
-	
-	pInput_Info->audio_type = id; 
-	
-	if(pInput_Info->audio_type == AUDIO_I2S) {
-		
-		
-		
-		
-		pInput_Info->i2s_pol = 0; 
-		pInput_Info->i2s_len = 0; 
-		pInput_Info->i2s_fmt = 0; 
-		
-	}
-}
-
-
-
-ch7036_status_t ch7036_set_output_channel(void* p_context, uint32 channel)
-{
-	ch7036_device_context_t * p_ctx= (ch7036_device_context_t *)p_context;
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
-	pd_attr_t *p_attr_hdmi, *p_attr_crt, *p_attr_dvi;
-	pd_attr_t *p_attr_hscale, *p_attr_vscale, *p_attr_hscale_crt, *p_attr_vscale_crt, *p_attr_hp, *p_attr_vp;
-	pd_attr_t* p_attr_dither;
-
-
-	
-	PD_DEBUG("ch7036_set_output_channel- channel [%x]\n", channel);
-	
-	pOutput_Info->channel = channel;
-
-
-
-	p_attr_dvi = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
-				PD_ATTR_ID_DVI_OUT_MODE, PD_GET_ATTR_LIST);
-
-	p_attr_hdmi = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
-				PD_ATTR_ID_HDMI_OUT_MODE, PD_GET_ATTR_LIST);
-	
-
-	p_attr_crt = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
-			PD_ATTR_ID_CRT_OUT_MODE, PD_GET_ATTR_LIST);
-
-	
-	p_attr_hscale_crt = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
-			PD_ATTR_ID_HSCALE_CRT, 0);
-	p_attr_vscale_crt = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
-			PD_ATTR_ID_VSCALE_CRT, 0);
-	
-	p_attr_hscale = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
-			PD_ATTR_ID_HSCALE, 0);
-	p_attr_vscale = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
-			PD_ATTR_ID_VSCALE, 0);
-
-	p_attr_hp = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
-				PD_ATTR_ID_HPOSITION, 0);
-	p_attr_vp = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
-				PD_ATTR_ID_VPOSITION, 0);
-
-	p_attr_dither = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
-				PD_ATTR_ID_DITHER_BYPASS, 0);
-			
-	
-
-	if(pOutput_Info->channel & CHANNEL_HDMI) {
-
-		if(pOutput_Info->hdmi_fmt.is_dvi_mode) {
-
-			if(p_attr_hdmi) 
-				p_attr_hdmi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;  
-
-			p_attr_dvi->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE; 
-
-			
-			p_attr_dvi += p_attr_dvi->current_value; 
-			p_ctx->dvi_mode_index = ((pd_list_entry_attr_t *)p_attr_dvi)->value;
-
-			PD_DEBUG("ch7036_set_output_channel- dvi mode index [%hu]\n",p_ctx->dvi_mode_index);
-
-
-
-		}
-		else { 
-			
-			p_attr_hdmi->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE; 
-
-			if(p_attr_dvi) 
-				p_attr_dvi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;  
-
-			
-			p_attr_hdmi += p_attr_hdmi->current_value; 
-			p_ctx->hdmi_mode_index = ((pd_list_entry_attr_t *)p_attr_hdmi)->value;
-
-			PD_DEBUG("ch7036_set_output_channel- hdmi mode index [%hu]\n",p_ctx->hdmi_mode_index);
-
-		}
-
-		if(p_attr_crt)
-			p_attr_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-		
-		//hdmi/dvi- hide it from user
-		p_attr_hscale_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-		p_attr_vscale_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-		//h/v pos scale- hide it
-		p_attr_hp->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-		p_attr_vp->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-		
-		//show it
-		p_attr_hscale->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
-		p_attr_vscale->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
-
-
-		p_attr_dither->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
-
-
-		PD_DEBUG("ch7036_set_output_channel-current hscale value [%d]\n",(uint8)p_attr_hscale->current_value);
-		PD_DEBUG("ch7036_set_output_channel-current vscale value [%d]\n",(uint8)p_attr_vscale->current_value);
-		
-		ch7036_set_scaling(pOutput_Info,PD_ATTR_ID_HSCALE,(uint8)p_attr_hscale->current_value);
-		ch7036_set_scaling(pOutput_Info,PD_ATTR_ID_VSCALE,(uint8)p_attr_vscale->current_value);
-
-
-	} else if (pOutput_Info->channel & CHANNEL_VGA) {
-		
-		p_attr_crt->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
-		
-		if(p_attr_hdmi)
-			p_attr_hdmi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-
-		if(p_attr_dvi)
-			p_attr_dvi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-
-		p_attr_crt += p_attr_crt->current_value; 
-		p_ctx->crt_mode_index = ((pd_list_entry_attr_t *)p_attr_crt)->value;
-	
-		PD_DEBUG("ch7036_set_output_channel- crt mode index [%hu]\n",p_ctx->crt_mode_index);
-
-		
-		p_attr_hscale_crt->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
-		p_attr_vscale_crt->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
-		
-		p_attr_hp->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
-		p_attr_vp->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
-
-		p_attr_dither->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
-
-
-		p_attr_hscale->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-		p_attr_vscale->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-
-		PD_DEBUG("ch7036_set_output_channel-current hscale_crt value [%d]\n",(uint8)p_attr_hscale_crt->current_value);
-		PD_DEBUG("ch7036_set_output_channel-current vscale_crt value [%d]\n",(uint8)p_attr_vscale_crt->current_value);
-
-		
-		ch7036_set_scaling(pOutput_Info,PD_ATTR_ID_HSCALE_CRT,(uint8)p_attr_hscale_crt->current_value);
-		ch7036_set_scaling(pOutput_Info,PD_ATTR_ID_VSCALE_CRT,(uint8)p_attr_vscale_crt->current_value);
-
-		
-	} else {
-
-		if(p_attr_crt)
-			p_attr_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-		if(p_attr_hdmi)
-			p_attr_hdmi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-		if(p_attr_dvi)
-			p_attr_dvi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-
-		
-		p_attr_hscale->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-		p_attr_vscale->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-
-		p_attr_hscale_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-		p_attr_vscale_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-	
-		p_attr_hp->flags |= PD_ATTR_FLAG_USER_INVISIBLE;		
-		p_attr_vp->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-
-		p_attr_dither->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
-
-
-	}
-	
-
-	return SS_SUCCESS;
-}
-unsigned long ch7036_get_output_channel(void* p_context)
-{
-	ch7036_device_context_t * p_ctx= (ch7036_device_context_t *)p_context;
-	pd_list_entry_attr_t *p_attr;
-	uint32 channel = 0;
-
-	PD_DEBUG("ch7036_get_output_channel- enter\n");
-
-	p_attr = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
-			PD_ATTR_ID_DISPLAY, PD_GET_ATTR_LIST_ENTRY);
-
-	if(p_attr->value & CHANNEL_DVI)
-		channel = (p_attr->value & 0xF7) | CHANNEL_HDMI;
-
-	return channel;
-}
-
-ch7036_status_t ch7036_set_position(ch7036_device_context_t *p_ctx, uint8 attr_id, uint16 pos)
-{
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-
-	uint8 reg;
-
-	PD_DEBUG("ch7036_set_position- enter\n");
-	I2CWrite(p_ch7xxx_context,0x03, 0x00);
-	reg = I2CRead(p_ch7xxx_context,0x39);
-	
-	if(attr_id == PD_ATTR_ID_HPOSITION) {
-		reg = reg & 0xF0; 
-		I2CWrite(p_ch7xxx_context,0x3A, (pos & 0x00FF));
-		reg = ((pos >> 8) & 0x0F) | reg;	
-		iic_write_ex(HP,pos);
-	} 
-	else { 
-		reg = reg & 0x0F;
-		I2CWrite(p_ch7xxx_context,0x3B, (pos & 0x00FF));
-		reg = (((pos >> 8) & 0x0F) << 4) | reg;	
-		iic_write_ex(VP,pos);
-	}
-
-	I2CWrite(p_ch7xxx_context,0x39, reg);
-	
-	return SS_SUCCESS;
-}
-
-
-void ch7036_set_hdmi_sync_polarity(OUTPUT_INFO* pOutput_Info)
-{
-	
-	if((pOutput_Info->channel & CHANNEL_HDMI)&&(pOutput_Info->channel & CHANNEL_VGA))
-	{
-		if (pOutput_Info->timing.ha > 720) {
-			pOutput_Info->hdmi_fmt.hs_pol = POL_HIGH;
-			pOutput_Info->hdmi_fmt.vs_pol = POL_HIGH;
-			if(pOutput_Info->timing.ha == 1440 )
-			{
-              pOutput_Info->hdmi_fmt.hs_pol = POL_LOW;
-			  pOutput_Info->hdmi_fmt.vs_pol = POL_LOW;
-			}
-		}
-		else if(pOutput_Info->timing.ha <= 720){
-			
-			pOutput_Info->hdmi_fmt.hs_pol = POL_LOW;
-			pOutput_Info->hdmi_fmt.vs_pol = POL_LOW;
-		}
-	}
-	
-	
-	if((pOutput_Info->channel & CHANNEL_HDMI) && ((pOutput_Info->channel & CHANNEL_VGA) == 0x00))
-	{	
-		pOutput_Info->hdmi_fmt.hs_pol = POL_LOW;
-		pOutput_Info->hdmi_fmt.vs_pol = POL_LOW;
-	}
-
-}
-
-void ch7036_set_quality_enhancement(ch7036_device_context_t *p_ctx, uint8 checked)
-{
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	PREFER_INFO* pPrefer_Info = p_ch7xxx_context->pPrefer_Info;
-	uint8 reg;
-
-	PD_DEBUG("ch7036_set_quality_enhancement- enter\n");
-	I2CWrite(p_ch7xxx_context,0x03, 0x00);	
-	reg = I2CRead(p_ch7xxx_context,0x19); 
-	
-	if(checked) 
-		reg = reg & 0xBF; 
-	else
-		reg = reg | 0x40; 
-	
-	I2CWrite(p_ch7xxx_context,0x19, reg);
-
-	
-	pPrefer_Info->dither_filter_enable = checked?DITHER_ENABLE:DITHER_BYPASS;
-
-	
-	iic_write_ex(DBP, checked?DITHER_ENABLE:DITHER_BYPASS);
-	
-}
-
-void ch7036_set_scaling (OUTPUT_INFO* pOutput_Info, unsigned long id, uint8 value)
-{
-	uint8* p_scale;
-
-	PD_DEBUG("ch7036_set_scaling- enter- value [%d]\n", value);
-		
-	if(id == PD_ATTR_ID_HSCALE || id == PD_ATTR_ID_HSCALE_CRT)
-		p_scale= &(pOutput_Info->ds_percent_h);
-	else 
-		p_scale= &(pOutput_Info->ds_percent_v);
-		
-	switch(value) {
-		case 20: *p_scale = 0; break; 
-		case 19: *p_scale = 1; break; 
-		case 18: *p_scale = 2; break;
-		case 17: *p_scale = 3; break;
-		case 16: *p_scale = 4; break;
-		case 15: *p_scale = 5; break;
-		case 14: *p_scale = 6; break;
-		case 13: *p_scale = 7; break;
-		case 12: *p_scale = 8; break;
-		case 11: *p_scale = 9; break;
-		case 10: *p_scale = 10; break;
-		
-		case 9: *p_scale = 11; break;
-		case 8: *p_scale = 12; break;
-		case 7: *p_scale = 13; break;
-		case 6: *p_scale = 14; break;
-		case 5: *p_scale = 15; break;
-		case 4: *p_scale = 16; break;
-		case 3: *p_scale = 17; break;
-		case 2: *p_scale = 18; break;
-		case 1: *p_scale = 19; break;
-		case 0: *p_scale = 20; break;
-		default: break;
-			
-	}
-
-	return;
-
-}
-
-void ch7036_set_rotate (OUTPUT_INFO* pOutput_Info)
-{
-	
-	
-	pOutput_Info->rotate = DEFAULT_ROTATE; 
-}
-
-void ch7036_set_hflip (OUTPUT_INFO* pOutput_Info)
-{
-	
-	
-	pOutput_Info->h_flip = DEFAULT_HFLIP; 
-}
-void ch7036_set_vflip (OUTPUT_INFO* pOutput_Info)
-{
-	
-	
-	pOutput_Info->v_flip = DEFAULT_VFLIP; 
-}
-
-void ch7036_set_text_enhancement (ch7036_device_context_t *p_ctx, uint8 val)
-{
-	
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	PREFER_INFO* pPrefer_Info = p_ch7xxx_context->pPrefer_Info;
-	
-
-	PD_DEBUG("ch7036_set_text_enhancement- enter\n");
-
-
-	I2CWrite(p_ch7xxx_context,0x03, 0x00);
-	I2CWrite(p_ch7xxx_context,0x2E, (I2CRead(p_ch7xxx_context,0x2E) & 0xF8) |  val);
-	
-	pPrefer_Info->text_enhancement = val; 
-	iic_write_ex(TXTEN, val);
-}
-
-
-void ch7036_set_pll_refdly(PREFER_INFO* pPrefer_Info)
-{
-	pPrefer_Info->pll_ref_dly = DEF_PLL_REF_DLY;
-}
-
-void ch7036_set_pll_fbdly(PREFER_INFO* pPrefer_Info)
-{
-	pPrefer_Info->pll_ref_fbdly = DEF_PLL_REF_FBDLY;
-}
-
-void ch7036_set_lvds_txdrv_ctrl(PREFER_INFO* pPrefer_Info)
-{
-	pPrefer_Info->lvds_txdrv_ctrl = DEF_LVDS_TXDRV_CTRL;
-}
-
-
-
-ch7036_status_t ch7036_alter_display_channel (ch7036_device_context_t *p_ctx) 
-{
-
-
-	ch7036_status_t status;
-
-
-	pd_list_entry_attr_t  *list_item;
-
-	ch7036_edid_blk_t* p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
-	ch7036_edid_blk_t* p_cedid = (ch7036_edid_blk_t *)p_ctx->cedid;
-
-
-	list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DISPLAY,
-					PD_GET_ATTR_LIST_ENTRY); 
-	
-	PD_DEBUG("ch7036_alter_display_channel=> enter- list_item->value [0x%lu]\n",list_item->value);
-	
-	switch (p_ctx->hpd & 0x22) {
-	
-		case 0x22: 
-		case 0x20:
-			PD_DEBUG("ch7036_alter_display_channel=> hdmi-dvi hpd status: attached... \n");
-			if(p_ctx->hpd & 0x41 ) { 
-
-				status = ch7036_read_edid(p_ctx, CHANNEL_LVDS_HDMI);
-
-		
-				if (status == SS_SUCCESS) {
-
-					if( p_ctx->man_sel_out==1 ) 
-						p_ctx->hpd &= 0x3F; //need parsing but dont do edid again
-					else													
-						p_ctx->hpd &= 0x7F; 
-					
-					
-					PD_DEBUG("ch7036_alter_display_channel=> hdmi-dvi, status changed,edid read is a success- proceed to alter attr table...\n");
-					
-				}
-				else { 
-
-					PD_DEBUG("ch7036_alter_display_channel=> hdmi-dvi, status changed,edid read failed- use default attr table- show all modes..\n");
-					
-
-				}
-
-					
-
-			}
-			else {
-
-				PD_DEBUG("ch7036_alter_display_channel=> hdmi/dvi, status unchanged,check if edid read needed...\n"); 
-				ch7036_redo_edid_if_needed(p_ctx, (void *)p_hedid, CHANNEL_LVDS_HDMI);
-			}
-
-	
-
-
-			if(list_item->value == CHANNEL_AUTO_DETECT) {
-				if(p_ctx->prev_outchannel != CHANNEL_LVDS_HDMI)	
-					ch7036_set_output_channel((void *)p_ctx, CHANNEL_LVDS_HDMI);
-			}
-			else { 
-
-	
-
-				
-				if(list_item->value & CHANNEL_DVI) 
-					//	map DVI to HDMI output channel;										
-					ch7036_set_output_channel((void *)p_ctx, (list_item->value & 0x01) | CHANNEL_HDMI);
-				
-				else 
-					
-					ch7036_set_output_channel((void *)p_ctx, (uint32)list_item->value );
-				
-
-			}
-	
-
-			break;
-
-		case 0x02: 
-			
-			PD_DEBUG("ch7036_alter_display_channel=> crt hpd status: attached... \n");
-		
-			if(p_ctx->hpd & 0x05) { 
-				
-				status = ch7036_read_edid(p_ctx, CHANNEL_LVDS_VGA);
-
-			
-				if (status == SS_SUCCESS) {
-
-					PD_DEBUG("ch7036_alter_display_channel=> crt only, status changed, edid is a success, proceed ..\n");
-					if( p_ctx->man_sel_out==1 ) 
-						p_ctx->hpd &= 0xF3; //need parsing,hpd manually updated to 'unchanged',dont do edid again
-					else
-						p_ctx->hpd &= 0xF7; 
-										
-				
-				}
-				else {
-
-					PD_DEBUG("ch7036_alter_display_channel=> crt only, status changed, edid failed- use default attr table- show all modes..\n");
-
-				} 
-							
-
-			} 
-			
-			else  {
-				PD_DEBUG("ch7036_alter_display_channel=> crt only, status unchange,check if edid read needed...\n"); 
-				ch7036_redo_edid_if_needed(p_ctx, (void *)p_cedid, CHANNEL_LVDS_VGA);
-			}
-				
-			if(list_item->value == CHANNEL_AUTO_DETECT)
-					ch7036_set_output_channel((void *)p_ctx, CHANNEL_LVDS_VGA);
-			else {
-
-				//set output channel, correct display choice if needed 				
-				ch7036_set_output_channel((void *)p_ctx, (uint32)list_item->value );
-			}
-			
-
-			break;
-
-		default: 
-
-			if(list_item->value == CHANNEL_AUTO_DETECT) {
-				if (!p_ctx->init_done) { 					
-					ch7036_set_output_channel((void *)p_ctx, CHANNEL_LVDS_VGA); 
-				}
-				else
-					ch7036_set_output_channel((void *)p_ctx, CHANNEL_LVDS);
-			}
-			else 		
-				ch7036_set_output_channel((void *)p_ctx, (uint32)list_item->value );
-			
-
-		break;
-
-
-	} 
-
-	PD_DEBUG("ch7036_alter_display_channel=> exit- list_item->value [0x%x]\n",list_item->value);
-	return SS_SUCCESS;
-
-}
-
-
-pd_list_entry_attr_t *ch7036_get_updated_display_ouput_entry(ch7036_device_context_t *p_ctx, uint32 channel)
-{
-		
-	pd_list_entry_attr_t  *list_item;
-
-	list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DISPLAY,
-					PD_GET_ATTR_LIST_ENTRY); 
-
-	list_item->value = (list_item->value & 0x01) | channel; 
-
-	return list_item;			
-}
-
-
-void ch7036_redo_edid_if_needed(ch7036_device_context_t *p_ctx, void* p_edidblk, uint32 channel)
-{
-	ch7036_edid_blk_t* p_edid = (ch7036_edid_blk_t *)p_edidblk;
-	ch7036_status_t status = SS_UNSUCCESSFUL;;
-	
-	
-	
-	if (!p_ctx->init_done) { 
-					
-			PD_DEBUG("ch7036_alter_list: ch7036_check_if_edid_read_needed=> attached, status unchanged at init, read edid NOW...\n"); 
-			status = ch7036_read_edid(p_ctx, channel); 
-			
-	}
-	else {
-				
-		if(!p_edid->is_edid) { 
-			PD_DEBUG("ch7036_alter_list: ch7036_check_if_edid_read_needed=>attached, status unchanged, never read edid or edid failed, read it NOW..\n");
-			status= ch7036_read_edid(p_ctx, channel);
-
-
-		}
-		else 
-			PD_DEBUG("ch7036_alter_list: ch7036_check_if_edid_read_needed=> attached, status unchanged, edid read was done, edid read is NOT needed...\n");
-	}
-
-	if(status == SS_SUCCESS) { 
-
-		if(channel & CHANNEL_HDMI) 
-			if( p_ctx->man_sel_out==1 ) 
-				p_ctx->hpd &= 0x3F; 
-			else
-				p_ctx->hpd &= 0x7F;
-		
-		else 
-			if( p_ctx->man_sel_out==1 ) 
-				p_ctx->hpd &= 0xF3; 
-			else
-				p_ctx->hpd &= 0xF7;
-		
-	} 
-
-
-
-}
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_attr.c
+* @version 1.2.5
+*-----------------------------------------------------------------------------
+*/
+
+
+
+
+#include "ch7036_intf.h"
+#include "ch7036_attr.h"
+
+
+#ifdef T_LINUX
+	#include "lvds/lvds.h"
+#else
+	#include "lvds.h"
+#endif
+
+
+
+static pd_attr_t g_ch7036_attrs[] =
+{
+
+
+
+	PD_MAKE_ATTR (PD_ATTR_ID_HPOSITION,   PD_ATTR_TYPE_RANGE, "H Pos.",  0, DEFAULT_POSITION,	DEFAULT_POSITION,                    DEFAULT_POSITION - 40,  DEFAULT_POSITION + 40,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_VPOSITION,   PD_ATTR_TYPE_RANGE, "V Pos.",  0, DEFAULT_POSITION,	DEFAULT_POSITION,                    DEFAULT_POSITION - 30,  DEFAULT_POSITION + 30,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_HSCALE,   PD_ATTR_TYPE_RANGE, "H_Scale",  0, HDMI_DEFAULT_UNDERSCAN,   HDMI_DEFAULT_UNDERSCAN,  10,  20,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_VSCALE,   PD_ATTR_TYPE_RANGE, "V_Scale",  0, HDMI_DEFAULT_UNDERSCAN,     HDMI_DEFAULT_UNDERSCAN,   10,  20,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_HSCALE_CRT,   PD_ATTR_TYPE_RANGE, "H_Scale",  0, CRT_DEFAULT_UNDERSCAN,   CRT_DEFAULT_UNDERSCAN,  10,  20,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_VSCALE_CRT,   PD_ATTR_TYPE_RANGE, "V_Scale",  0, CRT_DEFAULT_UNDERSCAN,   CRT_DEFAULT_UNDERSCAN,  10,  20,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_DITHER,   PD_ATTR_TYPE_RANGE, "Dither", PD_ATTR_FLAG_USER_INVISIBLE, 0,   0,  0,  3,  1),
+
+	PD_MAKE_ATTR (PD_ATTR_ID_TEXT_FILTER,   PD_ATTR_TYPE_RANGE, "Text Tuning", PD_ATTR_FLAG_USER_INVISIBLE, 4,   DEFAULT_TEXT_ENHANCE,  0,  7,  1),
+
+
+	PD_MAKE_ATTR (PD_ATTR_ID_DITHER_BYPASS, PD_ATTR_TYPE_BOOL, "Quality Enhance",  0, 0,                 0,                 0, 0, 0),
+
+	PD_MAKE_ATTR (PD_ATTR_ID_PLL_REF_DLY, PD_ATTR_TYPE_BOOL, "Pll Reference Delay",PD_ATTR_FLAG_USER_INVISIBLE, 0,0,0, 0, 0),
+	PD_MAKE_ATTR (PD_ATTR_ID_PLL_REF_FBDLY,PD_ATTR_TYPE_BOOL, "Pll Reference FBDelay",PD_ATTR_FLAG_USER_INVISIBLE, 1,   1, 0, 0, 0),
+
+	PD_MAKE_ATTR (PD_ATTR_ID_LOAD_FIRMWARE,PD_ATTR_TYPE_BOOL, "Load Firmware",PD_ATTR_FLAG_USER_INVISIBLE, 0, 1, 0, 0, 0),
+	PD_MAKE_ATTR (PD_ATTR_ID_REFRESH,PD_ATTR_TYPE_BOOL, "Refresh",0, 0,   0, 0, 0, 0),
+	PD_MAKE_ATTR (PD_ATTR_ID_DWNSCAL_BYPASS,PD_ATTR_TYPE_BOOL, "Remove_DS",PD_ATTR_FLAG_USER_INVISIBLE, 0, 1, 0, 0, 0),
+
+};
+
+
+static ch7036_attr_list_entry_t g_list_entry_hdmi[] =
+{
+	{OUT_HDMI_640x480P_59,		"640x480p_59",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_640x480P_60,		"640x480p_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_720x480P_59,		"720x480p_59",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_720x480P_60,		"720x480p_60",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_HDMI_720x576P_50,     "720x576p_50",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_HDMI_1280x720P_59,    "1280x720p_59",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_1280x720P_60,    "1280x720p_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_1920x1080I_59,   "1920x1080i_59",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_1920x1080I_60,   "1920x1080i_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_1920x1080P_59,   "1920x1080p_59",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_1920x1080P_60,   "1920x1080p_60",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_HDMI_1280x720P_50,    "1280x720p_50",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_1920x1080I_50,   "1920x1080i_50",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_1920x1080P_50,   "1920x1080p_50",PD_ATTR_FLAG_DYNAMIC},
+	{0, NULL,0}
+};
+
+
+
+static ch7036_attr_list_entry_t g_list_entry_dvi[] =
+{
+
+	{OUT_DVI_640x480_60,	"640x480_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_640x480_72,	"640x480_72",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_640x480_75,	"640x480_75",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_720x400_70,	"720x400_70",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_800x600_56,	"800x600_56",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_DVI_800x600_60,	"800x600_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_800x600_72,	"800x600_72",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_800x600_75,	"800x600_75",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_DVI_1024x768_60,	"1024x768_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1024x768_70,	"1024x768_70",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1024x768_75,	"1024x768_75",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_DVI_1152x864_60,	"1152x864_60",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_DVI_1280x720_60,   "1280x720_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1280x800_60,   "1280x800_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1280x960_60,    "1280x960_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1280x1024_60,   "1280x1024_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1280x1024_75,   "1280x1024_75",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_DVI_1360x768_60,    "1360x768_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1366x768_60,    "1366x768_60",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_DVI_1400x1050_60,   "1400x1050_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1400x1050_75,   "1400x1050_75",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1440x900_60,    "1440x900_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1440x1050_60,   "1440x1050_60",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_DVI_1600x900_60,    "1600x900_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1600x1200_60,   "1600x1200_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1680x1050_60,   "1680x1050_60",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_DVI_1920x1080_60,   "1920x1080_60",PD_ATTR_FLAG_DYNAMIC},
+	{0, NULL,0}
+};
+
+
+
+static ch7036_attr_list_entry_t g_list_entry_crt[] =
+{
+	{OUT_CRT_640x400_85, "640x400_85",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_640x480_60, "640x480_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_640x480_72, "640x480_72",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_640x480_75, "640x480_75",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_640x480_85, "640x480_85",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_720x400_85, "720x400_85",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_800x600_56, "800x600_56",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_800x600_60, "800x600_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_800x600_72, "800x600_72",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_800x600_75, "800x600_75",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_800x600_85, "800x600_85",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_1024x768_60,"1024x768_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1024x768_70,"1024x768_70",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1024x768_75,"1024x768_75",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1024x768_85,"1024x768_85",PD_ATTR_FLAG_DYNAMIC},
+
+
+	{OUT_CRT_1152x864_75,"1152x864_75",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_1280x768_60,"1280x768_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1280x768_75,"1280x768_75",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1280x768_85,"1280x768_85",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_1280x960_60,"1280x960_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1280x960_85,"1280x960_85",PD_ATTR_FLAG_DYNAMIC},
+
+
+	{OUT_CRT_1280x1024_60,"1280x1024_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1280x1024_75,"1280x1024_75",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1280x1024_85,"1280x1024_85",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_1360x768_60,"1360x768_60",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_1400x1050_60,"1400x1050_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1400x1050_75,"1400x1050_75",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_1440x900_60,"1440x900_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1440x1050_60,"1440x1050_60",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_1600x900_60,"1600x900_60",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_1600x1200_60,"1600x1200_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1920x1080_60,"1920x1080_60",PD_ATTR_FLAG_DYNAMIC},
+	{0, NULL,0}
+};
+
+
+static ch7036_attr_list_entry_t g_list_entry_channel[] =
+{
+	{CHANNEL_AUTO_DETECT,"Auto Detect",PD_ATTR_FLAG_DYNAMIC},
+	{CHANNEL_LVDS_HDMI, "LVDS_HDMI",PD_ATTR_FLAG_DYNAMIC},
+	{CHANNEL_LVDS_DVI, "LVDS_DVI",PD_ATTR_FLAG_DYNAMIC},
+	{CHANNEL_LVDS_VGA,  "LVDS_VGA",PD_ATTR_FLAG_DYNAMIC},
+	{CHANNEL_HDMI, "HDMI",PD_ATTR_FLAG_DYNAMIC},
+	{CHANNEL_DVI, "DVI",PD_ATTR_FLAG_DYNAMIC},
+	{CHANNEL_VGA,  "VGA",PD_ATTR_FLAG_DYNAMIC},
+	{0, NULL,0}
+};
+
+static ch7036_attr_list_header_t g_list_header[] =
+{
+	{7, PD_ATTR_ID_DISPLAY,"Display Channel", 1,1,
+	g_list_entry_channel},
+
+	{14, PD_ATTR_ID_HDMI_OUT_MODE, "HDMI",7,7,
+	 g_list_entry_hdmi},
+
+	{27, PD_ATTR_ID_DVI_OUT_MODE,"DVI", 9,9,
+	 g_list_entry_dvi},
+
+	{32, PD_ATTR_ID_CRT_OUT_MODE, "VGA", 12,12,
+	 g_list_entry_crt},
+
+	{ 0 }
+};
+
+
+
+ch7036_status_t ch7036_init_attribute_table(ch7036_device_context_t *p_ctx, ch7036_attr_list_header_t* p_list_header)
+{
+	unsigned long ch7036_num_attrs, num_attrs;
+	unsigned char *p_table;
+
+
+
+	ch7036_num_attrs = ch7036_enumerate_attr_table(p_ctx, NULL, p_list_header);
+	PD_DEBUG("ch7036_init_attribute_table- ch7036 num_attr = [%lu]\n",ch7036_num_attrs);
+
+
+	p_ctx->ch7036_num_attrs =  ch7036_num_attrs ;
+
+
+	if(p_ctx->p_ch7036_attr_table) {
+		pd_free(p_ctx->p_ch7036_attr_table);
+		p_ctx->p_ch7036_attr_table = NULL;
+	}
+
+
+	if(p_ctx->p_ch7036_attr_table == NULL) {
+
+		p_ctx->p_ch7036_attr_table = pd_malloc((p_ctx->ch7036_num_attrs + 1) * sizeof(pd_attr_t));
+
+		if (p_ctx->p_ch7036_attr_table == NULL) {
+			PD_ERROR("ch7036: Error ! ch7036_init_attribute_table: pd_malloc() failed allocating ch7036_attr_table");
+
+			return SS_MEM_ALLOC_ERR;
+		}
+
+		pd_memset(p_ctx->p_ch7036_attr_table, 0, (p_ctx->ch7036_num_attrs + 1) *
+			sizeof(pd_attr_t));
+
+	}
+
+
+	p_table = (unsigned char *)p_ctx->p_ch7036_attr_table;
+
+
+	if (p_ctx->ch7036_num_attrs  > 0) {
+
+		num_attrs = ch7036_enumerate_attr_table(p_ctx, (pd_attr_t *)p_table, p_list_header);
+
+
+		PD_DEBUG("ch7036_init_attribute_table: ch7036_enumerate_attr_table()- returned %lu entries, expected %lu\n",
+					  num_attrs, p_ctx->ch7036_num_attrs) ;
+
+	}
+
+
+	return SS_SUCCESS;
+
+}
+
+
+
+unsigned long ch7036_enumerate_attr_table (ch7036_device_context_t *p_ctx,
+	pd_attr_t *p_attr, ch7036_attr_list_header_t* p_list_header)
+{
+
+
+	unsigned long num_attrs, i, j, num_attrs_static;
+	ch7036_attr_list_entry_t *list_item;
+	int ret;
+	pd_attr_t *p_table;
+
+	list_item = NULL;
+	num_attrs = 0;
+	i = j = 0;
+
+
+	PD_DEBUG("ch7036_enumerate_attr_table- enter\n");
+
+
+
+	if ( p_list_header == NULL )
+			p_list_header = g_list_header;
+
+
+	if (p_attr == NULL) {
+
+		if(p_ctx->p_ch7036_attr_table == NULL) {
+			ret = PD_INTERNAL_LVDS_MODULE_GET_ATTRIBUTES(ch7036_lvds_get_attrs,(p_ctx->internal_lvds,&(p_ctx->lvds_num_attrs),&(p_ctx->p_lvds_attr_table)));
+
+			if(ret != PD_SUCCESS)
+				PD_DEBUG("ch7036_enumerate_attr_table: lvds_get_attributes() return ERROR! check this routine\n");
+			else
+				PD_DEBUG("ch7036_enumerate_attr_table: lvds_get_attributes()- lvds num_attr = [%lu]\n",p_ctx->lvds_num_attrs);
+		}
+
+
+
+		while (p_list_header[i].num_entries) {
+
+
+			num_attrs += (p_list_header[i].num_entries + 1);
+			++i;
+		}
+
+		num_attrs += ((sizeof(g_ch7036_attrs)/sizeof(pd_attr_t)) + p_ctx->lvds_num_attrs) ;
+
+		return num_attrs;
+	}
+
+
+	if(p_ctx->lvds_num_attrs > 0) {
+
+		pd_attr_t *p_lvds_des, *p_lvds_src ;
+
+
+		p_lvds_src=  (pd_attr_t *)p_ctx->p_lvds_attr_table;
+		p_lvds_des = (pd_attr_t *)p_attr;
+
+		pd_memcpy(p_lvds_des, p_lvds_src, (p_ctx->lvds_num_attrs)*sizeof(pd_attr_t));
+		num_attrs += p_ctx->lvds_num_attrs;
+
+		for (i=0 ; i < p_ctx->lvds_num_attrs; i++, p_lvds_des++) {
+
+			PD_DEBUG("ch7036 : ch7036_enumerate_attr_table : \n"
+				  "adding lvds attr='%s', id=%lu, default=%lu, current=%lu, \n",
+				  p_lvds_des->name, p_lvds_des->id, p_lvds_des->default_value, p_lvds_des->current_value);
+		}
+
+	}
+
+	PD_DEBUG("ch7036 : ch7036_enumerate_attr_table adding lvds num attrs = %lu \n", num_attrs);
+
+
+
+	i=0;
+
+
+	while (p_list_header[i].num_entries) {
+
+		pd_list_attr_t *p_hdr = (pd_list_attr_t *) &p_attr[num_attrs];
+
+
+		p_hdr->type	= PD_ATTR_TYPE_LIST;
+		p_hdr->id = p_list_header[i].id;
+		p_hdr->num_entries = p_list_header[i].num_entries;
+		p_hdr->flags |= PD_ATTR_FLAG_DYNAMIC;
+
+		p_hdr->current_index = p_list_header[i].current_index;
+		pd_strcpy(p_hdr->name, p_list_header[i].p_name);
+
+		p_hdr->default_index = p_list_header[i].default_index;
+
+		PD_DEBUG("ch7036 : ch7036_enumerate_attr_table : \n"
+				  "adding attr - list header='%s', id=%lu, default=%lu, current=%lu, \n"
+				  "num_entries=%lu\n",
+				  p_hdr->name, p_hdr->id, p_hdr->default_index, p_hdr->current_index,
+				  p_hdr->num_entries);
+
+		++num_attrs;
+
+
+
+		list_item = p_list_header[i].attr_list;
+		for (j = 0; j < p_list_header[i].num_entries; ++j, ++num_attrs) {
+
+			pd_list_entry_attr_t *p_entry =
+				(pd_list_entry_attr_t *)&p_attr[num_attrs];
+
+			p_entry->id		= p_list_header[i].id;
+			p_entry->type	= PD_ATTR_TYPE_LIST_ENTRY;
+			p_entry->value	= list_item[j].id;
+
+
+			p_entry->flags  = list_item[j].flags;
+
+
+
+
+
+
+
+
+			pd_strcpy(p_entry->name, list_item[j].p_name);
+
+
+
+			PD_DEBUG("ch7036 : ch7036_enumerate_attr_table : list entry[%lu]=%s, id=[%lu], "
+					  "value=%lu, flags=0x%x \n",
+					  j, p_entry->name, p_entry->id,
+					  p_entry->value, (unsigned char)p_entry->flags);
+
+		}
+
+		++i;
+	}
+
+
+	p_table = (pd_attr_t *)&p_attr[num_attrs];
+	num_attrs_static = sizeof(g_ch7036_attrs)/sizeof(pd_attr_t);
+	pd_memcpy(p_table, g_ch7036_attrs,num_attrs_static*sizeof(pd_attr_t));
+
+	for (i=0 ; i < num_attrs_static; i++, p_table++) {
+
+		PD_DEBUG("ch7036 : ch7036_enumerate_attr_table : \n"
+				  "adding ch7036 static attr='%s', id=%lu, default=%lu, current=%lu, \n",
+				  p_table->name, p_table->id, p_table->default_value, p_table->current_value);
+
+	}
+
+	num_attrs += num_attrs_static;
+
+
+	return num_attrs;
+
+}
+
+void ch7036_set_dither(ch7036_device_context_t* p_ctx)
+{
+	uint8 reg=0x00;
+	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
+
+	I2CWrite(p_ch_ctx,0x03, 0x04);
+	reg = I2CRead(p_ch_ctx,0x57);
+    reg = reg & 0x3F;
+
+
+	switch(p_ctx->dither_select)
+	{
+		  case DITHER_18_TO_18:
+			  reg &= 0x3F;
+			  break;
+		  case DITHER_18_TO_24:
+			  reg = reg | 0x40;
+			  break;
+		  case DITHER_24_TO_18:
+			  reg = reg | 0x80;
+			  break;
+		  case DITHER_24_TO_24:
+			  reg = reg | 0xC0;
+			  break;
+		  default:
+			 break;
+    }
+	I2CWrite(p_ch_ctx,0x57, reg);
+
+	return;
+}
+
+
+
+void ch7036_set_audio_type(INPUT_INFO* pInput_Info, uint8 id)
+{
+
+	pInput_Info->audio_type = id;
+
+	if(pInput_Info->audio_type == AUDIO_I2S) {
+
+
+
+
+		pInput_Info->i2s_pol = 0;
+		pInput_Info->i2s_len = 0;
+		pInput_Info->i2s_fmt = 0;
+
+	}
+}
+
+
+
+ch7036_status_t ch7036_set_output_channel(void* p_context, uint32 channel)
+{
+	ch7036_device_context_t * p_ctx= (ch7036_device_context_t *)p_context;
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+	pd_attr_t *p_attr_hdmi, *p_attr_crt, *p_attr_dvi;
+	pd_attr_t *p_attr_hscale, *p_attr_vscale, *p_attr_hscale_crt, *p_attr_vscale_crt, *p_attr_hp, *p_attr_vp;
+	pd_attr_t* p_attr_dither;
+
+
+
+	PD_DEBUG("ch7036_set_output_channel- channel [%x]\n", channel);
+
+	pOutput_Info->channel = channel;
+
+
+
+	p_attr_dvi = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+				PD_ATTR_ID_DVI_OUT_MODE, PD_GET_ATTR_LIST);
+
+	p_attr_hdmi = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+				PD_ATTR_ID_HDMI_OUT_MODE, PD_GET_ATTR_LIST);
+
+
+	p_attr_crt = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+			PD_ATTR_ID_CRT_OUT_MODE, PD_GET_ATTR_LIST);
+
+
+	p_attr_hscale_crt = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+			PD_ATTR_ID_HSCALE_CRT, 0);
+	p_attr_vscale_crt = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+			PD_ATTR_ID_VSCALE_CRT, 0);
+
+	p_attr_hscale = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+			PD_ATTR_ID_HSCALE, 0);
+	p_attr_vscale = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+			PD_ATTR_ID_VSCALE, 0);
+
+	p_attr_hp = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+				PD_ATTR_ID_HPOSITION, 0);
+	p_attr_vp = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+				PD_ATTR_ID_VPOSITION, 0);
+
+	p_attr_dither = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+				PD_ATTR_ID_DITHER_BYPASS, 0);
+
+
+
+	if(pOutput_Info->channel & CHANNEL_HDMI) {
+
+		if(pOutput_Info->hdmi_fmt.is_dvi_mode) {
+
+			if(p_attr_hdmi)
+				p_attr_hdmi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+			p_attr_dvi->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+
+			p_attr_dvi += p_attr_dvi->current_value;
+			p_ctx->dvi_mode_index = ((pd_list_entry_attr_t *)p_attr_dvi)->value;
+
+			PD_DEBUG("ch7036_set_output_channel- dvi mode index [%hu]\n",p_ctx->dvi_mode_index);
+
+
+
+		}
+		else {
+
+			p_attr_hdmi->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+			if(p_attr_dvi)
+				p_attr_dvi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+
+			p_attr_hdmi += p_attr_hdmi->current_value;
+			p_ctx->hdmi_mode_index = ((pd_list_entry_attr_t *)p_attr_hdmi)->value;
+
+			PD_DEBUG("ch7036_set_output_channel- hdmi mode index [%hu]\n",p_ctx->hdmi_mode_index);
+
+		}
+
+		if(p_attr_crt)
+			p_attr_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+		//hdmi/dvi- hide it from user
+		p_attr_hscale_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vscale_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		//h/v pos scale- hide it
+		p_attr_hp->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vp->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+		//show it
+		p_attr_hscale->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vscale->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+
+		p_attr_dither->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+
+		PD_DEBUG("ch7036_set_output_channel-current hscale value [%d]\n",(uint8)p_attr_hscale->current_value);
+		PD_DEBUG("ch7036_set_output_channel-current vscale value [%d]\n",(uint8)p_attr_vscale->current_value);
+
+		ch7036_set_scaling(pOutput_Info,PD_ATTR_ID_HSCALE,(uint8)p_attr_hscale->current_value);
+		ch7036_set_scaling(pOutput_Info,PD_ATTR_ID_VSCALE,(uint8)p_attr_vscale->current_value);
+
+
+	} else if (pOutput_Info->channel & CHANNEL_VGA) {
+
+		p_attr_crt->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+		if(p_attr_hdmi)
+			p_attr_hdmi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+		if(p_attr_dvi)
+			p_attr_dvi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+		p_attr_crt += p_attr_crt->current_value;
+		p_ctx->crt_mode_index = ((pd_list_entry_attr_t *)p_attr_crt)->value;
+
+		PD_DEBUG("ch7036_set_output_channel- crt mode index [%hu]\n",p_ctx->crt_mode_index);
+
+
+		p_attr_hscale_crt->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vscale_crt->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+		p_attr_hp->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vp->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+		p_attr_dither->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+
+		p_attr_hscale->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vscale->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+		PD_DEBUG("ch7036_set_output_channel-current hscale_crt value [%d]\n",(uint8)p_attr_hscale_crt->current_value);
+		PD_DEBUG("ch7036_set_output_channel-current vscale_crt value [%d]\n",(uint8)p_attr_vscale_crt->current_value);
+
+
+		ch7036_set_scaling(pOutput_Info,PD_ATTR_ID_HSCALE_CRT,(uint8)p_attr_hscale_crt->current_value);
+		ch7036_set_scaling(pOutput_Info,PD_ATTR_ID_VSCALE_CRT,(uint8)p_attr_vscale_crt->current_value);
+
+
+	} else {
+
+		if(p_attr_crt)
+			p_attr_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		if(p_attr_hdmi)
+			p_attr_hdmi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		if(p_attr_dvi)
+			p_attr_dvi->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+
+		p_attr_hscale->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vscale->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+		p_attr_hscale_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vscale_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+		p_attr_hp->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+		p_attr_vp->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+		p_attr_dither->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+
+	}
+
+
+	return SS_SUCCESS;
+}
+unsigned long ch7036_get_output_channel(void* p_context)
+{
+	ch7036_device_context_t * p_ctx= (ch7036_device_context_t *)p_context;
+	pd_list_entry_attr_t *p_attr;
+	uint32 channel = 0;
+
+	PD_DEBUG("ch7036_get_output_channel- enter\n");
+
+	p_attr = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
+			PD_ATTR_ID_DISPLAY, PD_GET_ATTR_LIST_ENTRY);
+
+	if(p_attr->value & CHANNEL_DVI)
+		channel = (p_attr->value & 0xF7) | CHANNEL_HDMI;
+
+	return channel;
+}
+
+ch7036_status_t ch7036_set_position(ch7036_device_context_t *p_ctx, uint8 attr_id, uint16 pos)
+{
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+
+	uint8 reg;
+
+	PD_DEBUG("ch7036_set_position- enter\n");
+	I2CWrite(p_ch7xxx_context,0x03, 0x00);
+	reg = I2CRead(p_ch7xxx_context,0x39);
+
+	if(attr_id == PD_ATTR_ID_HPOSITION) {
+		reg = reg & 0xF0;
+		I2CWrite(p_ch7xxx_context,0x3A, (pos & 0x00FF));
+		reg = ((pos >> 8) & 0x0F) | reg;
+		iic_write_ex(HP,pos);
+	}
+	else {
+		reg = reg & 0x0F;
+		I2CWrite(p_ch7xxx_context,0x3B, (pos & 0x00FF));
+		reg = (((pos >> 8) & 0x0F) << 4) | reg;
+		iic_write_ex(VP,pos);
+	}
+
+	I2CWrite(p_ch7xxx_context,0x39, reg);
+
+	return SS_SUCCESS;
+}
+
+
+void ch7036_set_hdmi_sync_polarity(OUTPUT_INFO* pOutput_Info)
+{
+
+	if((pOutput_Info->channel & CHANNEL_HDMI)&&(pOutput_Info->channel & CHANNEL_VGA))
+	{
+		if (pOutput_Info->timing.ha > 720) {
+			pOutput_Info->hdmi_fmt.hs_pol = POL_HIGH;
+			pOutput_Info->hdmi_fmt.vs_pol = POL_HIGH;
+			if(pOutput_Info->timing.ha == 1440 )
+			{
+              pOutput_Info->hdmi_fmt.hs_pol = POL_LOW;
+			  pOutput_Info->hdmi_fmt.vs_pol = POL_LOW;
+			}
+		}
+		else if(pOutput_Info->timing.ha <= 720){
+
+			pOutput_Info->hdmi_fmt.hs_pol = POL_LOW;
+			pOutput_Info->hdmi_fmt.vs_pol = POL_LOW;
+		}
+	}
+
+
+	if((pOutput_Info->channel & CHANNEL_HDMI) && ((pOutput_Info->channel & CHANNEL_VGA) == 0x00))
+	{
+		pOutput_Info->hdmi_fmt.hs_pol = POL_LOW;
+		pOutput_Info->hdmi_fmt.vs_pol = POL_LOW;
+	}
+
+}
+
+void ch7036_set_quality_enhancement(ch7036_device_context_t *p_ctx, uint8 checked)
+{
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	PREFER_INFO* pPrefer_Info = p_ch7xxx_context->pPrefer_Info;
+	uint8 reg;
+
+	PD_DEBUG("ch7036_set_quality_enhancement- enter\n");
+	I2CWrite(p_ch7xxx_context,0x03, 0x00);
+	reg = I2CRead(p_ch7xxx_context,0x19);
+
+	if(checked)
+		reg = reg & 0xBF;
+	else
+		reg = reg | 0x40;
+
+	I2CWrite(p_ch7xxx_context,0x19, reg);
+
+
+	pPrefer_Info->dither_filter_enable = checked?DITHER_ENABLE:DITHER_BYPASS;
+
+
+	iic_write_ex(DBP, checked?DITHER_ENABLE:DITHER_BYPASS);
+
+}
+
+void ch7036_set_scaling (OUTPUT_INFO* pOutput_Info, unsigned long id, uint8 value)
+{
+	uint8* p_scale;
+
+	PD_DEBUG("ch7036_set_scaling- enter- value [%d]\n", value);
+
+	if(id == PD_ATTR_ID_HSCALE || id == PD_ATTR_ID_HSCALE_CRT)
+		p_scale= &(pOutput_Info->ds_percent_h);
+	else
+		p_scale= &(pOutput_Info->ds_percent_v);
+
+	switch(value) {
+		case 20: *p_scale = 0; break;
+		case 19: *p_scale = 1; break;
+		case 18: *p_scale = 2; break;
+		case 17: *p_scale = 3; break;
+		case 16: *p_scale = 4; break;
+		case 15: *p_scale = 5; break;
+		case 14: *p_scale = 6; break;
+		case 13: *p_scale = 7; break;
+		case 12: *p_scale = 8; break;
+		case 11: *p_scale = 9; break;
+		case 10: *p_scale = 10; break;
+
+		case 9: *p_scale = 11; break;
+		case 8: *p_scale = 12; break;
+		case 7: *p_scale = 13; break;
+		case 6: *p_scale = 14; break;
+		case 5: *p_scale = 15; break;
+		case 4: *p_scale = 16; break;
+		case 3: *p_scale = 17; break;
+		case 2: *p_scale = 18; break;
+		case 1: *p_scale = 19; break;
+		case 0: *p_scale = 20; break;
+		default: break;
+
+	}
+
+	return;
+
+}
+
+void ch7036_set_rotate (OUTPUT_INFO* pOutput_Info)
+{
+
+
+	pOutput_Info->rotate = DEFAULT_ROTATE;
+}
+
+void ch7036_set_hflip (OUTPUT_INFO* pOutput_Info)
+{
+
+
+	pOutput_Info->h_flip = DEFAULT_HFLIP;
+}
+void ch7036_set_vflip (OUTPUT_INFO* pOutput_Info)
+{
+
+
+	pOutput_Info->v_flip = DEFAULT_VFLIP;
+}
+
+void ch7036_set_text_enhancement (ch7036_device_context_t *p_ctx, uint8 val)
+{
+
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	PREFER_INFO* pPrefer_Info = p_ch7xxx_context->pPrefer_Info;
+
+
+	PD_DEBUG("ch7036_set_text_enhancement- enter\n");
+
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x00);
+	I2CWrite(p_ch7xxx_context,0x2E, (I2CRead(p_ch7xxx_context,0x2E) & 0xF8) |  val);
+
+	pPrefer_Info->text_enhancement = val;
+	iic_write_ex(TXTEN, val);
+}
+
+
+void ch7036_set_pll_refdly(PREFER_INFO* pPrefer_Info)
+{
+	pPrefer_Info->pll_ref_dly = DEF_PLL_REF_DLY;
+}
+
+void ch7036_set_pll_fbdly(PREFER_INFO* pPrefer_Info)
+{
+	pPrefer_Info->pll_ref_fbdly = DEF_PLL_REF_FBDLY;
+}
+
+void ch7036_set_lvds_txdrv_ctrl(PREFER_INFO* pPrefer_Info)
+{
+	pPrefer_Info->lvds_txdrv_ctrl = DEF_LVDS_TXDRV_CTRL;
+}
+
+
+
+ch7036_status_t ch7036_alter_display_channel (ch7036_device_context_t *p_ctx)
+{
+
+
+	ch7036_status_t status;
+
+
+	pd_list_entry_attr_t  *list_item;
+
+	ch7036_edid_blk_t* p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
+	ch7036_edid_blk_t* p_cedid = (ch7036_edid_blk_t *)p_ctx->cedid;
+
+
+	list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DISPLAY,
+					PD_GET_ATTR_LIST_ENTRY);
+
+	PD_DEBUG("ch7036_alter_display_channel=> enter- list_item->value [0x%lu]\n",list_item->value);
+
+	switch (p_ctx->hpd & 0x22) {
+
+		case 0x22:
+		case 0x20:
+			PD_DEBUG("ch7036_alter_display_channel=> hdmi-dvi hpd status: attached... \n");
+			if(p_ctx->hpd & 0x41 ) {
+
+				status = ch7036_read_edid(p_ctx, CHANNEL_LVDS_HDMI);
+
+
+				if (status == SS_SUCCESS) {
+
+					if( p_ctx->man_sel_out==1 )
+						p_ctx->hpd &= 0x3F; //need parsing but dont do edid again
+					else
+						p_ctx->hpd &= 0x7F;
+
+
+					PD_DEBUG("ch7036_alter_display_channel=> hdmi-dvi, status changed,edid read is a success- proceed to alter attr table...\n");
+
+				}
+				else {
+
+					PD_DEBUG("ch7036_alter_display_channel=> hdmi-dvi, status changed,edid read failed- use default attr table- show all modes..\n");
+
+
+				}
+
+
+
+			}
+			else {
+
+				PD_DEBUG("ch7036_alter_display_channel=> hdmi/dvi, status unchanged,check if edid read needed...\n");
+				ch7036_redo_edid_if_needed(p_ctx, (void *)p_hedid, CHANNEL_LVDS_HDMI);
+			}
+
+
+
+
+			if(list_item->value == CHANNEL_AUTO_DETECT) {
+				if(p_ctx->prev_outchannel != CHANNEL_LVDS_HDMI)
+					ch7036_set_output_channel((void *)p_ctx, CHANNEL_LVDS_HDMI);
+			}
+			else {
+
+
+
+
+				if(list_item->value & CHANNEL_DVI)
+					//	map DVI to HDMI output channel;
+					ch7036_set_output_channel((void *)p_ctx, (list_item->value & 0x01) | CHANNEL_HDMI);
+
+				else
+
+					ch7036_set_output_channel((void *)p_ctx, (uint32)list_item->value );
+
+
+			}
+
+
+			break;
+
+		case 0x02:
+
+			PD_DEBUG("ch7036_alter_display_channel=> crt hpd status: attached... \n");
+
+			if(p_ctx->hpd & 0x05) {
+
+				status = ch7036_read_edid(p_ctx, CHANNEL_LVDS_VGA);
+
+
+				if (status == SS_SUCCESS) {
+
+					PD_DEBUG("ch7036_alter_display_channel=> crt only, status changed, edid is a success, proceed ..\n");
+					if( p_ctx->man_sel_out==1 )
+						p_ctx->hpd &= 0xF3; //need parsing,hpd manually updated to 'unchanged',dont do edid again
+					else
+						p_ctx->hpd &= 0xF7;
+
+
+				}
+				else {
+
+					PD_DEBUG("ch7036_alter_display_channel=> crt only, status changed, edid failed- use default attr table- show all modes..\n");
+
+				}
+
+
+			}
+
+			else  {
+				PD_DEBUG("ch7036_alter_display_channel=> crt only, status unchange,check if edid read needed...\n");
+				ch7036_redo_edid_if_needed(p_ctx, (void *)p_cedid, CHANNEL_LVDS_VGA);
+			}
+
+			if(list_item->value == CHANNEL_AUTO_DETECT)
+					ch7036_set_output_channel((void *)p_ctx, CHANNEL_LVDS_VGA);
+			else {
+
+				//set output channel, correct display choice if needed
+				ch7036_set_output_channel((void *)p_ctx, (uint32)list_item->value );
+			}
+
+
+			break;
+
+		default:
+
+			if(list_item->value == CHANNEL_AUTO_DETECT) {
+				if (!p_ctx->init_done) {
+					ch7036_set_output_channel((void *)p_ctx, CHANNEL_LVDS_VGA);
+				}
+				else
+					ch7036_set_output_channel((void *)p_ctx, CHANNEL_LVDS);
+			}
+			else
+				ch7036_set_output_channel((void *)p_ctx, (uint32)list_item->value );
+
+
+		break;
+
+
+	}
+
+	PD_DEBUG("ch7036_alter_display_channel=> exit- list_item->value [0x%x]\n",list_item->value);
+	return SS_SUCCESS;
+
+}
+
+
+pd_list_entry_attr_t *ch7036_get_updated_display_ouput_entry(ch7036_device_context_t *p_ctx, uint32 channel)
+{
+
+	pd_list_entry_attr_t  *list_item;
+
+	list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DISPLAY,
+					PD_GET_ATTR_LIST_ENTRY);
+
+	list_item->value = (list_item->value & 0x01) | channel;
+
+	return list_item;
+}
+
+
+void ch7036_redo_edid_if_needed(ch7036_device_context_t *p_ctx, void* p_edidblk, uint32 channel)
+{
+	ch7036_edid_blk_t* p_edid = (ch7036_edid_blk_t *)p_edidblk;
+	ch7036_status_t status = SS_UNSUCCESSFUL;;
+
+
+
+	if (!p_ctx->init_done) {
+
+			PD_DEBUG("ch7036_alter_list: ch7036_check_if_edid_read_needed=> attached, status unchanged at init, read edid NOW...\n");
+			status = ch7036_read_edid(p_ctx, channel);
+
+	}
+	else {
+
+		if(!p_edid->is_edid) {
+			PD_DEBUG("ch7036_alter_list: ch7036_check_if_edid_read_needed=>attached, status unchanged, never read edid or edid failed, read it NOW..\n");
+			status= ch7036_read_edid(p_ctx, channel);
+
+
+		}
+		else
+			PD_DEBUG("ch7036_alter_list: ch7036_check_if_edid_read_needed=> attached, status unchanged, edid read was done, edid read is NOT needed...\n");
+	}
+
+	if(status == SS_SUCCESS) {
+
+		if(channel & CHANNEL_HDMI)
+			if( p_ctx->man_sel_out==1 )
+				p_ctx->hpd &= 0x3F;
+			else
+				p_ctx->hpd &= 0x7F;
+
+		else
+			if( p_ctx->man_sel_out==1 )
+				p_ctx->hpd &= 0xF3;
+			else
+				p_ctx->hpd &= 0xF7;
+
+	}
+
+
+
+}
 
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.h
index 4917394..8c3aa21 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.h
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_attr.h
@@ -1,85 +1,85 @@
-/*-----------------------------------------------------------------------------
-* Copyright (c) Chrontel Inc.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy
-* of this software and associated documentation files (the "Software"), to deal
-* in the Software without restriction, including without limitation the rights
-* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-* copies of the Software, and to permit persons to whom the Software is
-* furnished to do so, subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in
-* all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-* THE SOFTWARE.
-*
-*-----------------------------------------------------------------------------
-* @file  ch7036_attr.h
-* @version 1.2.5
-*-----------------------------------------------------------------------------
-*/
-
-
-
-//#include <linux/kernel.h>
-
-#ifndef _CH7036_ATTR_H_
-#define _CH7036_ATTR_H_
-
-typedef struct {
-	unsigned long id;
-	char *p_name;
-	unsigned long flags; 
-
-} ch7036_attr_list_entry_t;
-
-typedef struct {
-	unsigned char num_entries;
-	unsigned long id;
-	char *p_name;
-	unsigned long default_index; 
-	unsigned long current_index;
-	ch7036_attr_list_entry_t *attr_list;
-	
-} ch7036_attr_list_header_t;
-
-
-unsigned long ch7036_enumerate_attr_table(ch7036_device_context_t *p_ctx,pd_attr_t *p_attr,ch7036_attr_list_header_t* p_list_header);
-ch7036_status_t ch7036_init_attribute_table(ch7036_device_context_t *p_ctx,ch7036_attr_list_header_t* p_list_header);
-
-
-void ch7036_set_hdmi_sync_polarity(OUTPUT_INFO* pOutput_Info);
-void ch7036_set_audio_type(INPUT_INFO* pInput_Info, uint8 id);
-void ch7036_set_scaling (OUTPUT_INFO* pOutput_Info, unsigned long id, uint8 value );
-ch7036_status_t ch7036_set_position(ch7036_device_context_t *p_ctx, uint8 attr_id, uint16 pos);
-
-
-void ch7036_set_rotate (OUTPUT_INFO* pOutput_Info);
-void ch7036_set_hflip (OUTPUT_INFO* pOutput_Info);
-void ch7036_set_vflip (OUTPUT_INFO* pOutput_Info);
-
-ch7036_status_t ch7036_set_output_channel(void* p_context, uint32 channel);
-unsigned long ch7036_get_output_channel(void* p_context);
-ch7036_status_t ch7036_alter_display_channel (ch7036_device_context_t *p_ctx);
-
-pd_list_entry_attr_t * ch7036_get_updated_display_ouput_entry(ch7036_device_context_t *p_ctx, uint32 channel);
-
-void ch7036_set_text_enhancement (ch7036_device_context_t *p_ctx, uint8 val);
-void ch7036_set_quality_enhancement(ch7036_device_context_t *p_ctx, uint8 val);
-
-void ch7036_set_pll_refdly(PREFER_INFO* pPrefer_Info);
-void ch7036_set_pll_fbdly(PREFER_INFO* pPrefer_Info);
-void ch7036_set_lvds_txdrv_ctrl(PREFER_INFO* pPrefer_Info);
-
-void ch7036_set_dither(ch7036_device_context_t* p_ctx);
-
-void ch7036_redo_edid_if_needed(ch7036_device_context_t *p_ctx, void* p_edidblk, uint32 channel);
-
-
-#endif 
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_attr.h
+* @version 1.2.5
+*-----------------------------------------------------------------------------
+*/
+
+
+
+//#include <linux/kernel.h>
+
+#ifndef _CH7036_ATTR_H_
+#define _CH7036_ATTR_H_
+
+typedef struct {
+	unsigned long id;
+	char *p_name;
+	unsigned long flags;
+
+} ch7036_attr_list_entry_t;
+
+typedef struct {
+	unsigned char num_entries;
+	unsigned long id;
+	char *p_name;
+	unsigned long default_index;
+	unsigned long current_index;
+	ch7036_attr_list_entry_t *attr_list;
+
+} ch7036_attr_list_header_t;
+
+
+unsigned long ch7036_enumerate_attr_table(ch7036_device_context_t *p_ctx,pd_attr_t *p_attr,ch7036_attr_list_header_t* p_list_header);
+ch7036_status_t ch7036_init_attribute_table(ch7036_device_context_t *p_ctx,ch7036_attr_list_header_t* p_list_header);
+
+
+void ch7036_set_hdmi_sync_polarity(OUTPUT_INFO* pOutput_Info);
+void ch7036_set_audio_type(INPUT_INFO* pInput_Info, uint8 id);
+void ch7036_set_scaling (OUTPUT_INFO* pOutput_Info, unsigned long id, uint8 value );
+ch7036_status_t ch7036_set_position(ch7036_device_context_t *p_ctx, uint8 attr_id, uint16 pos);
+
+
+void ch7036_set_rotate (OUTPUT_INFO* pOutput_Info);
+void ch7036_set_hflip (OUTPUT_INFO* pOutput_Info);
+void ch7036_set_vflip (OUTPUT_INFO* pOutput_Info);
+
+ch7036_status_t ch7036_set_output_channel(void* p_context, uint32 channel);
+unsigned long ch7036_get_output_channel(void* p_context);
+ch7036_status_t ch7036_alter_display_channel (ch7036_device_context_t *p_ctx);
+
+pd_list_entry_attr_t * ch7036_get_updated_display_ouput_entry(ch7036_device_context_t *p_ctx, uint32 channel);
+
+void ch7036_set_text_enhancement (ch7036_device_context_t *p_ctx, uint8 val);
+void ch7036_set_quality_enhancement(ch7036_device_context_t *p_ctx, uint8 val);
+
+void ch7036_set_pll_refdly(PREFER_INFO* pPrefer_Info);
+void ch7036_set_pll_fbdly(PREFER_INFO* pPrefer_Info);
+void ch7036_set_lvds_txdrv_ctrl(PREFER_INFO* pPrefer_Info);
+
+void ch7036_set_dither(ch7036_device_context_t* p_ctx);
+
+void ch7036_redo_edid_if_needed(ch7036_device_context_t *p_ctx, void* p_edidblk, uint32 channel);
+
+
+#endif
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_def_regmap.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_def_regmap.h
index d2e82fc..fe2e79a 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_def_regmap.h
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_def_regmap.h
@@ -1,29 +1,29 @@
-/*-----------------------------------------------------------------------------
-* Copyright (c) Chrontel Inc.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy
-* of this software and associated documentation files (the "Software"), to deal
-* in the Software without restriction, including without limitation the rights
-* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-* copies of the Software, and to permit persons to whom the Software is
-* furnished to do so, subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in
-* all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-* THE SOFTWARE.
-*
-*-----------------------------------------------------------------------------
-* @file  ch7036_def_regmap.h
-* @version 1.2.2
-*-----------------------------------------------------------------------------
-*/
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_def_regmap.h
+* @version 1.2.2
+*-----------------------------------------------------------------------------
+*/
 
 #ifndef _CH7036_DEF_REGMAP_H
 #define _CH7036_DEF_REGMAP_H
@@ -36,664 +36,664 @@
 #define REG_NUM_PER_PAGE	0x80
 
 static uint8 g_DefRegMap[5][0x80] = {
-	
+
 	{
-	0x56, 
-	0xF0, 
-	0xF3, 
-	0x00, 
-	0x36, 
-	0x58, 
-	0xAC, 
-	0xDD, 
-	0x0F, 
-	0x1F, 
-	0xB4, 
-	0x1A, 
-	0x80, 
-	0x20, 
-	0x00, 
-	0x10, 
-	0x60, 
-	0x11, 
-	0xE0, 
-	0x0D, 
-	0x00, 
-	0x0A, 
-	0x02, 
-	0x00, 
-	0x00, 
-	0xF8, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x1A, 
-	0x80, 
-	0x20, 
-	0x00, 
-	0x10, 
-	0x60, 
-	0x11, 
-	0xE0, 
-	0x0D, 
-	0x00, 
-	0x0A, 
-	0x02, 
-	0x08, 
-	0x00, 
-	0x00, 
-	0x3C, 
-	0x00, 
-	0x01, 
-	0x01, 
-	0xC0, 
-	0x01, 
-	0x01, 
-	0x80, 
-	0x40, 
-	0x40, 
-	0x47, 
-	0x88, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x86, 
-	0x00, 
-	0x11, 
-	0x0E, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x40, 
-	0x40, 
-	0x80, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x1F, 
-	0xFF, 
-	0x00, 
-	0x80, 
-	0x10, 
-	0x60, 
-	0x00, 
-	0x0A, 
-	0x02, 
-	0x08, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x40, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x01, 
-	0x2D, 
-	0x90, 
-	0x20, 
-	0x22, 
-	0x44, 
-	0x24, 
-	0x40, 
-	0x00, 
-	0x10, 
-	0x00, 
-	0xA0, 
-	0x4B, 
-	0x18, 
-	0x01, 
-	0x00, 
-	0x00, 
-	0x20, 
-	0x80, 
-	0x18, 
-	0x00, 
-	0x00, 
-	0x01, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0xFF, 
-	0x0F, 
-	0x00, 
+	0x56,
+	0xF0,
+	0xF3,
+	0x00,
+	0x36,
+	0x58,
+	0xAC,
+	0xDD,
+	0x0F,
+	0x1F,
+	0xB4,
+	0x1A,
+	0x80,
+	0x20,
+	0x00,
+	0x10,
+	0x60,
+	0x11,
+	0xE0,
+	0x0D,
+	0x00,
+	0x0A,
+	0x02,
+	0x00,
+	0x00,
+	0xF8,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x1A,
+	0x80,
+	0x20,
+	0x00,
+	0x10,
+	0x60,
+	0x11,
+	0xE0,
+	0x0D,
+	0x00,
+	0x0A,
+	0x02,
+	0x08,
+	0x00,
+	0x00,
+	0x3C,
+	0x00,
+	0x01,
+	0x01,
+	0xC0,
+	0x01,
+	0x01,
+	0x80,
+	0x40,
+	0x40,
+	0x47,
+	0x88,
+	0x00,
+	0x00,
+	0x00,
+	0x86,
+	0x00,
+	0x11,
+	0x0E,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x40,
+	0x40,
+	0x80,
+	0x00,
+	0x00,
+	0x00,
+	0x1F,
+	0xFF,
+	0x00,
+	0x80,
+	0x10,
+	0x60,
+	0x00,
+	0x0A,
+	0x02,
+	0x08,
+	0x00,
+	0x00,
+	0x00,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x2D,
+	0x90,
+	0x20,
+	0x22,
+	0x44,
+	0x24,
+	0x40,
+	0x00,
+	0x10,
+	0x00,
+	0xA0,
+	0x4B,
+	0x18,
+	0x01,
+	0x00,
+	0x00,
+	0x20,
+	0x80,
+	0x18,
+	0x00,
+	0x00,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0x0F,
+	0x00,
 	},
 
-	
+
 	{
-	0x56, 
-	0xF0, 
-	0xF3, 
-	0x01, 
-	0x36, 
-	0x58, 
-	0xAC, 
-	0x20, 
-	0x00, 
-	0x4B, 
-	0x00, 
-	0x6D, 
-	0x6A, 
-	0x51, 
-	0x93, 
-	0x1C, 
-	0x00, 
-	0x08, 
-	0xC5, 
-	0xA8, 
-	0x91, 
-	0x68, 
-	0x29, 
-	0x0E, 
-	0xC8, 
-	0x42, 
-	0x6C, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x10, 
-	0x07, 
-	0xFF, 
-	0xB6, 
-	0x10, 
-	0x00, 
-	0x00, 
-	0x15, 
-	0x18, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x0B, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x08, 
-	0x60, 
-	0x14, 
-	0x20, 
-	0x00, 
-	0x00, 
-	0x20, 
-	0x00, 
-	0x49, 
-	0x10, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0x00, 
-	0x08, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0xA0, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x7A, 
-	0x5E, 
-	0x6E, 
-	0x1F, 
-	0x1F, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x20, 
-	0x40, 
-	0x40, 
-	0x40, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0x50, 
-	0x00, 
-	0x00, 
-	0x09, 
-	0x00, 
-	0x00, 
-	0x70, 
-	0x00, 
-	0x50, 
-	0x00, 
-	0x98, 
-	0x00, 
-	0x98, 
-	0xFF, 
-	0x00, 
-	0x00, 
-	0x00, 
+	0x56,
+	0xF0,
+	0xF3,
+	0x01,
+	0x36,
+	0x58,
+	0xAC,
+	0x20,
+	0x00,
+	0x4B,
+	0x00,
+	0x6D,
+	0x6A,
+	0x51,
+	0x93,
+	0x1C,
+	0x00,
+	0x08,
+	0xC5,
+	0xA8,
+	0x91,
+	0x68,
+	0x29,
+	0x0E,
+	0xC8,
+	0x42,
+	0x6C,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x10,
+	0x07,
+	0xFF,
+	0xB6,
+	0x10,
+	0x00,
+	0x00,
+	0x15,
+	0x18,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x0B,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x08,
+	0x60,
+	0x14,
+	0x20,
+	0x00,
+	0x00,
+	0x20,
+	0x00,
+	0x49,
+	0x10,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x00,
+	0x08,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xA0,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x7A,
+	0x5E,
+	0x6E,
+	0x1F,
+	0x1F,
+	0x00,
+	0x00,
+	0x00,
+	0x20,
+	0x40,
+	0x40,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x50,
+	0x00,
+	0x00,
+	0x09,
+	0x00,
+	0x00,
+	0x70,
+	0x00,
+	0x50,
+	0x00,
+	0x98,
+	0x00,
+	0x98,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
 	},
 
-	
+
 	{
-	0x56, 
-	0xF0, 
-	0xF3, 
-	0xFF, 
-	0x36, 
-	0x58, 
-	0xAC, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
+	0x56,
+	0xF0,
+	0xF3,
+	0xFF,
+	0x36,
+	0x58,
+	0xAC,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
 	},
 
-	
+
 	{
-	0x56, 
-	0xF0, 
-	0xF3, 
-	0x03, 
-	0x36, 
-	0x58, 
-	0xAC, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0xFF, 
-	0x00, 
-	0x03, 
-	0x19, 
-	0x40, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x11, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0x09, 
-	0x1D, 
-	0x0F, 
-	0x00, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0x00, 
-	0x00, 
-	0xFF, 
-	0xF8, 
-	0xFF, 
-	0x00, 
-	0x02, 
-	0xFF, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
+	0x56,
+	0xF0,
+	0xF3,
+	0x03,
+	0x36,
+	0x58,
+	0xAC,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0x00,
+	0x03,
+	0x19,
+	0x40,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x11,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x09,
+	0x1D,
+	0x0F,
+	0x00,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x00,
+	0x00,
+	0xFF,
+	0xF8,
+	0xFF,
+	0x00,
+	0x02,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
 	},
 
-	
+
 	{
-	0x56, 
-	0xF0, 
-	0xF3, 
-	0x04, 
-	0x36, 
-	0x58, 
-	0xAC, 
-	0xFF, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0xC0, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0x00, 
-	0x00, 
-	0x4F, 
-	0x07, 
-	0x4F, 
-	0x07, 
-	0x3B, 
-	0x07, 
-	0x3B, 
-	0x07, 
-	0x50, 
-	0x00, 
-	0x50, 
-	0x00, 
-	0x10, 
-	0x00, 
-	0x00, 
-	0x10, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0x00, 
-	0x03, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x24, 
-	0x00, 
-	0x40, 
-	0xFF, 
-	0xFF, 
-	0x7F, 
-	0x56, 
-	0x80, 
-	0x2F, 
-	0x00, 
-	0x84, 
-	0x60, 
-	0xAF, 
-	0x00, 
-	0x00, 
-	0x80, 
-	0x94, 
-	0x00, 
-	0x80, 
-	0x00, 
-	0x05, 
-	0x38, 
-	0x01, 
-	0x83, 
-	0x11, 
-	0x01, 
-	0x80, 
-	0x90, 
-	0x00, 
-	0x40, 
-	0x40, 
-	0xE4, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x00, 
-	0x89, 
-	0x10, 
-	0xAC, 
-	0x00, 
-	0xE0, 
-	0x80, 
-	0x80, 
-	0x19, 
-	0x7D, 
-	0x00, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0xFF, 
-	0x00, 
-	0x0C, 
+	0x56,
+	0xF0,
+	0xF3,
+	0x04,
+	0x36,
+	0x58,
+	0xAC,
+	0xFF,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xC0,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x00,
+	0x00,
+	0x4F,
+	0x07,
+	0x4F,
+	0x07,
+	0x3B,
+	0x07,
+	0x3B,
+	0x07,
+	0x50,
+	0x00,
+	0x50,
+	0x00,
+	0x10,
+	0x00,
+	0x00,
+	0x10,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x00,
+	0x03,
+	0x00,
+	0x00,
+	0x00,
+	0x24,
+	0x00,
+	0x40,
+	0xFF,
+	0xFF,
+	0x7F,
+	0x56,
+	0x80,
+	0x2F,
+	0x00,
+	0x84,
+	0x60,
+	0xAF,
+	0x00,
+	0x00,
+	0x80,
+	0x94,
+	0x00,
+	0x80,
+	0x00,
+	0x05,
+	0x38,
+	0x01,
+	0x83,
+	0x11,
+	0x01,
+	0x80,
+	0x90,
+	0x00,
+	0x40,
+	0x40,
+	0xE4,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x89,
+	0x10,
+	0xAC,
+	0x00,
+	0xE0,
+	0x80,
+	0x80,
+	0x19,
+	0x7D,
+	0x00,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x00,
+	0x0C,
 	},
 };
 
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.c b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.c
index 23490d7..d262e48 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.c
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.c
@@ -1,468 +1,468 @@
-/*-----------------------------------------------------------------------------
-* Copyright (c) Chrontel Inc.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy
-* of this software and associated documentation files (the "Software"), to deal
-* in the Software without restriction, including without limitation the rights
-* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-* copies of the Software, and to permit persons to whom the Software is
-* furnished to do so, subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in
-* all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-* THE SOFTWARE.
-*
-*-----------------------------------------------------------------------------
-* @file  ch7036_fw.c
-* @version 1.2.5
-*-----------------------------------------------------------------------------
-*/
-
-
-
-#include "ch7036_intf.h"
-
-#include "edid7036.car"
-
-
-#define EDID_RETRY_MAX_TIMES 5
-#define HPD_LOOP_MAX 10
-
-
-#define SLEEP_TIME 200 
-
-
-#define lhfm_size  sizeof(lhfm_array)
-
-#define LHFM_TIMEOUT	10  
-
-static unsigned char edid_header[8]={0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00};
-
-static unsigned char es_map[16] = {   
-	0x26,0x27,0x42,0x43,0x44,0x45,0x46,0x47,
-	0x6A,0x51,0x52,0x53,0x57,0x58,0x59,0x5A	
-};
-
-
-
-
-
-established_timings_t et_I[8] = {
-	{0,"800x600_60", {OUT_DVI_800x600_60,OUT_HDMI_END, OUT_CRT_800x600_60} },
-	{0,"800x600_56", {OUT_DVI_800x600_56,OUT_HDMI_END, OUT_CRT_800x600_56} },
-	{0,"640x480_75", {OUT_DVI_640x480_75, OUT_HDMI_END, OUT_CRT_640x480_75} },
-	{0,"640x480_72", {OUT_DVI_640x480_72, OUT_HDMI_END, OUT_CRT_640x480_72} },
-	{0,"640x480_67", {OUT_DVI_END, OUT_HDMI_END, OUT_CRT_END } },
-	{0,"640x480_60", {OUT_DVI_640x480_60, OUT_HDMI_640x480P_60, OUT_CRT_640x480_60} },
-	{0,"720x400_88", {OUT_DVI_END, OUT_HDMI_END, OUT_CRT_END } },
-	{0,"720x400_70", {OUT_DVI_720x400_70, OUT_HDMI_END, OUT_CRT_END} },
-};
-
-established_timings_t et_II[8] ={
-	{0, "1280x1024_75", {OUT_DVI_1280x1024_75, OUT_HDMI_END, OUT_CRT_1280x1024_75} },
-	{0, "1024x768_75", {OUT_DVI_1024x768_75, OUT_HDMI_END, OUT_CRT_1024x768_75} },
-	{0, "1024x768_70", {OUT_DVI_1024x768_70, OUT_HDMI_END, OUT_CRT_1024x768_70} },
-	{0, "1024x768_60", {OUT_DVI_1024x768_60, OUT_HDMI_END, OUT_CRT_1024x768_60} },
-	{0, "1024x768_87", {OUT_DVI_END, OUT_HDMI_END, OUT_CRT_END} },
-	{0, "832x624_75", {OUT_DVI_END, OUT_HDMI_END, OUT_CRT_END} },
-	{0, "800x600_75", {OUT_DVI_800x600_75, OUT_HDMI_END, OUT_CRT_800x600_75} },
-	{0, "800x600_72", {OUT_DVI_800x600_72, OUT_HDMI_END, OUT_CRT_800x600_72} }
-};
-
-established_timings_t et_man = {
-	0, "1152x870_75", {OUT_DVI_END, OUT_HDMI_END, OUT_CRT_END} 
-};
-
-
-int LHFM_get_version(DEV_CONTEXT* p_ch7xxx_context,struct _FW7036_CFG* cfg)
-{
-
-	unsigned char reg;
-	unsigned wj;
-
-		 I2CWrite(p_ch7xxx_context,0x03, 0x00); 
-		 reg = I2CRead(p_ch7xxx_context,0x4F);
-		 
-
-		 if (0==(LHFM_REQUEST & reg)) { 
-			 I2CWrite(p_ch7xxx_context,0x4F, (LHFM_REQUEST+LHFM_GET_VERSION)); 
-			 wj = 0;
-			 while (wj++< LHFM_TIMEOUT) {
-			 
-			 				
-				 I2CWrite(p_ch7xxx_context,0x03, 0x00); 
-				 pd_usleep(SLEEP_TIME );
-				 PD_DEBUG("LHFM_get_version [%x]\r\n", wj);
-
-				 reg = I2CRead(p_ch7xxx_context,0x4F);
-				 if(reg == LHFM_GET_VERSION) {
-					 reg = I2CRead(p_ch7xxx_context,0x50);			
-					 if (!(LHFM_RET_ERROR & reg)) {
-						    I2CWrite(p_ch7xxx_context,0x03, 0x01); 
-						    cfg->size = I2CRead(p_ch7xxx_context,es_map[0]);	 
-							cfg->ver_major = I2CRead(p_ch7xxx_context,es_map[1]);
-							cfg->ver_minor = I2CRead(p_ch7xxx_context,es_map[2]);
-							cfg->did = I2CRead(p_ch7xxx_context,es_map[3]);
-							cfg->rid = I2CRead(p_ch7xxx_context,es_map[4]);
-							cfg->capbility = I2CRead(p_ch7xxx_context,es_map[5]);
-							cfg->reserved = I2CRead(p_ch7xxx_context,es_map[6]);
-						    I2CWrite(p_ch7xxx_context,0x03, 0x00); 
-							return 0;
-					 } else return -2;
-
-				 } 
-				 				 				
-			 }  
-
-		 } 
-
-	return -1; 
-}
-
-
-void LHFM_enable_crt_hpd(DEV_CONTEXT* p_ch7xxx_context)
-{
-	uint8 reg;
-	
-	PD_DEBUG("ch7036: LHFM_enable_crt_hpd-enter\n");
-
-	I2CWrite(p_ch7xxx_context,0x03, 0x04); 
-	reg = I2CRead(p_ch7xxx_context,0x57);
-	I2CWrite(p_ch7xxx_context,0x57, reg | 0x02); 
-	   
-	pd_usleep(SLEEP_TIME);
-
-	I2CWrite(p_ch7xxx_context,0x03, 0x00); 
-	I2CWrite(p_ch7xxx_context,0x08, I2CRead(p_ch7xxx_context,0x08) & 0xF1);
-	
-	pd_usleep(SLEEP_TIME);
-}
-
-
-ch7036_status_t LHFM_get_crt_hpd(DEV_CONTEXT* p_ch7xxx_context)
-{
-
-	unsigned char reg, count =0;
-	ch7036_status_t status = SS_CRT_HPD_NOTCONNECTED;
-
-	do {
-		
-		I2CWrite(p_ch7xxx_context,0x03, 0x00); 
-		reg = I2CRead(p_ch7xxx_context,0x74); 
-		I2CWrite(p_ch7xxx_context,0x74, reg & 0xFD); 
-		pd_usleep(SLEEP_TIME);
-
-		I2CWrite(p_ch7xxx_context,0x03, 0x00); 
-		reg = I2CRead(p_ch7xxx_context,0x74);
-		I2CWrite(p_ch7xxx_context,0x74, reg | 0x02); 		
-		pd_usleep(SLEEP_TIME);
-
-		I2CWrite(p_ch7xxx_context,0x03, 0x01); 
-		reg = I2CRead(p_ch7xxx_context,0x7C); 		
-		
-		if( (reg & 0xF0) == 0x50  || (reg & 0xF4) == 0x14 || (reg & 0xF4) == 0x44) 
-			status= SS_SUCCESS;
-					      	   	    
-	} while ( (status == SS_CRT_HPD_NOTCONNECTED) && ( (++count) < HPD_LOOP_MAX ) );
-
-          
-	I2CWrite(p_ch7xxx_context,0x03, 0x00); 	        
-	reg = I2CRead(p_ch7xxx_context,0x74);	        
-	I2CWrite(p_ch7xxx_context,0x74, reg & 0xFD);	 
-
-	I2CWrite(p_ch7xxx_context,0x08, I2CRead(p_ch7xxx_context,0x08) | 0x0E);
-		
-	return status;
-
-}
-
-
-ch7036_status_t LHFM_get_hdmi_modeinfo(DEV_CONTEXT* p_ch7xxx_context,unsigned char *minfo)
-{
-	unsigned char reg;
-	unsigned wj;
-	unsigned i;
-
-		 I2CWrite(p_ch7xxx_context,0x03, 0x00); 
-		 reg = I2CRead(p_ch7xxx_context,0x4F);
-		 
-		 if (0==(LHFM_REQUEST & reg)) {
-			 I2CWrite(p_ch7xxx_context,0x4F, (LHFM_REQUEST+ LHFM_GET_MODEINFO)); 
-			 wj = 0;
-			 while (wj++< LHFM_TIMEOUT) {
-				 I2CWrite(p_ch7xxx_context,0x03, 0x00); 
-				 pd_usleep(SLEEP_TIME);
-
-				 reg = I2CRead(p_ch7xxx_context,0x4F);
-				 if(reg == LHFM_GET_MODEINFO) {					 
-					 reg = I2CRead(p_ch7xxx_context,0x50);			
-					 if (!(LHFM_RET_ERROR & reg)) {
-						 if (minfo) {
-						    I2CWrite(p_ch7xxx_context,0x03, 0x01); 
-							for (i=0; i<15; i++) minfo[i] = I2CRead(p_ch7xxx_context,es_map[i]);	 
-						}
-						return SS_SUCCESS;
-					 } else return SS_FIRMWARE_ERR;
-
-				 } 
-				 			
-			 } 
-
-		 } 
-
-	return SS_FIRMWARE_TIMEOUT;
-
-}
-
-
-ch7036_status_t LHFM_get_edid(DEV_CONTEXT* p_ch7xxx_context,unsigned char* edid, unsigned char* ebn, unsigned char flag)
-{
-
-	unsigned i,j, ie;
-	unsigned k1, k2;
-	unsigned char reg;
-	unsigned wj;
-
-	ch7036_status_t status;
-
-
-
-	status = SS_SUCCESS;
-	*ebn = 0;    
-
-	pd_memset(edid, 0, EDID_SIZE); 
-
-	I2CWrite(p_ch7xxx_context,0x03, 0x00); 
-	reg = I2CRead(p_ch7xxx_context,0x4F);
-
-	if( (reg & LHFM_REQUEST) != 0 )
-		return SS_FIRMWARE_ERR; //mcu is busy
-	else { //mcu is ready to serve host request
-       
-		for(i=0,j=0; i < 8; i++,j+=16) {
-
-		    I2CWrite(p_ch7xxx_context,0x03, 0x00); 
-			I2CWrite(p_ch7xxx_context,0x50, i | flag); 
-			I2CWrite(p_ch7xxx_context,0x4F, (LHFM_REQUEST+LHFM_GET_EDID)); 
-			wj = 0;
-
-			status = SS_FIRMWARE_TIMEOUT;
-			PD_DEBUG("ch7036: LHFM_get_edid- block [%d] - getting [%d]- 16 bytes - wj=[0x%x]\n",*ebn,i+1,wj);
-			while (wj++< (2*LHFM_TIMEOUT) ) { 
-				 I2CWrite(p_ch7xxx_context,0x03, 0x00); 
-				 pd_usleep(SLEEP_TIME);
-				 
-				 reg = I2CRead(p_ch7xxx_context,0x4F);
-				 
-				 if(reg == LHFM_GET_EDID) { 
-					 
-					 reg = I2CRead(p_ch7xxx_context,0x50);	
-					 
-					 if (!(LHFM_RET_ERROR & reg)) { 
-							I2CWrite(p_ch7xxx_context,0x03, 0x01); 
-							for (ie=0; ie<16; ie++) edid[j+ie] = I2CRead(p_ch7xxx_context,es_map[ie] );								
-							break; 
-					 }
-					 else 						
-							return SS_FIRMWARE_ERR; 															 
-
-				 } 
-				 
-				 				 
-			} //while block
-			
-			status = SS_SUCCESS; 
-
-		} //for
-
-		for(i=0;i<8;i++)
-			if (edid_header[i] != edid[i]) {
-				return SS_FIRMWARE_ERR;
-			}
-		
-		(*ebn)++;
-		
-		if(flag & 0x80 && (edid[0x7E] > 0) ) { 
-			PD_DEBUG("ch7036: LHFM_get_edid- incorrect # of VGA EDID blocks read [%x]\n",edid[0x7E]); 
-			return SS_FIRMWARE_ERR;
-		}
-		
-		k2 = edid[0x7E];
-
-		k2 = (k2 > 3)? 3 : k2;  
-		
-		if (k2>0) { //case: there are more than 1 blocks
-			for (k1=1; k1<=k2; k1++) {
-
-				for(i=k1*8; i < 8+k1*8; i++,j+=16){
-					I2CWrite(p_ch7xxx_context,0x03, 0x00); 
-					I2CWrite(p_ch7xxx_context,0x50, i + flag);  
-					I2CWrite(p_ch7xxx_context,0x4F, (LHFM_REQUEST+LHFM_GET_EDID)); 
-					wj = 0;
-				
-					status = SS_FIRMWARE_TIMEOUT;
-					PD_DEBUG("ch7036: LHFM_get_edid- block [%d] - getting [%d]- 16 bytes - wj=[0x%x]\n",k1,i+1,wj);
-					while (wj++< (2*LHFM_TIMEOUT)) {
-						I2CWrite(p_ch7xxx_context,0x03, 0x00); 
-						pd_usleep(SLEEP_TIME);
-					 
-						reg = I2CRead(p_ch7xxx_context,0x4F);
-					 
-						if(reg == LHFM_GET_EDID) {						 
-							reg = I2CRead(p_ch7xxx_context,0x50);			
-							if (!(LHFM_RET_ERROR & reg)) {
-								I2CWrite(p_ch7xxx_context,0x03, 0x01); 
-								for (ie=0; ie<16; ie++) edid[j+ie] = I2CRead(p_ch7xxx_context,es_map[ie] );			
-								break;
-							}
-							else 
-								return SS_FIRMWARE_ERR;
-	
-
-						} 
-					 
-					} //while
-
-					status = SS_SUCCESS;
-
-				}//nested for 
-
-				(*ebn)++;
-
-			} //outermost for
-
-
-		} //if- case: there are more than 1 blocks
-
-	} //else - case:  mcu is ready to serve host request
-	
-	return status; 
-				
-}
-
-
-int LHFM_load_firmware(DEV_CONTEXT* p_ch7xxx_context)
-{
-
-
-	unsigned fs1;
-	unsigned char ch;
-
-	PD_DEBUG("ch7036: LHFM_load_firmware- firmware size [0x%.8X]\n",lhfm_size);
-	
-	I2CWrite(p_ch7xxx_context,0x03, 0x04);
-	ch = 0x29 | I2CRead(p_ch7xxx_context,0x52);
-	I2CWrite(p_ch7xxx_context,0x52, ch & 0xFB); 
-   
-
-	I2CWrite(p_ch7xxx_context,0x5B, 0x9E); 
-	I2CWrite(p_ch7xxx_context,0x5B, 0xB3);
-
-	I2CWrite(p_ch7xxx_context,0x03, 0x04);
-	I2CWrite(p_ch7xxx_context,0x03, 0x07);
-
-	for (fs1=0; fs1<lhfm_size; fs1++) 
-		I2CWrite(p_ch7xxx_context, 0x07, lhfm_array[fs1]);  
-
-
-
-	I2CWrite(p_ch7xxx_context, 0x03, 0x03); 
-	ch = I2CRead(p_ch7xxx_context,0x74); 
-	if (ch & 0x1) { 
-		
-		return -1;
-	}
-	else {
-		
-		I2CWrite( p_ch7xxx_context,0x03, 0x04); 
-		ch = I2CRead(p_ch7xxx_context,0x52);
-		I2CWrite(p_ch7xxx_context, 0x52, ch | 0x24);  
-	}
-
-	I2CWrite(p_ch7xxx_context, 0x03, 0x00);
-
-	return 0;
-}
-#if 0
-void ch7036_dump( char *s, int size, unsigned char *regdata)
-{
-	char temp[18];
-    int ch;
-
-    int i,j, size1;
-    
-    temp[16] = '?'; 
-    temp[17] = '\n';
-
-	PD_DEBUG("\n");
-    PD_DEBUG("+--------------------------------------------------------------------+\n");
-    PD_DEBUG("|%s |\n",s);
-    PD_DEBUG("+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-----------------+\n");
-    PD_DEBUG("|  | 0| 1| 2| 3| 4| 5| 6| 7| 8| 9| A| B| C| D| E| F|                 |\n");
-    PD_DEBUG("++++--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-----------------+\n");
-    
-    size1 = size % 16; 
-    size = size/16; 
-
-    for (i=0; i<size; i++) {
-
-       
-       PD_DEBUG("|%02x>", 0xFF & i*16);
-
-       
-	   for (j=0; j<16; j++) {
-           ch = regdata[i*16+j];
-           PD_DEBUG("%02X|", ch);
-
-#if 0
-		   
-          
-		   if( (ch >= 0x30 && ch <= 0x39) || (ch >= 0x61 && ch <= 0x7A) || (ch >= 0x41 && ch <= 0x5C) ) 
-				temp[j]='.';
-		   else
-			   temp[j]=(char)ch; 
-#endif
-		   
-        }
-             
-	   PD_DEBUG("\n");
-	}
-
-	if (size1) {
-	
-        PD_DEBUG( "|%02x>", 0xFF & size*16);
-
-		for (j=0; j<size1; j++) {
-           ch = regdata[size*16+j];
-           PD_DEBUG("%02X|", ch);
-#if 0
-         
-			if( (ch >= 0x30 && ch <= 0x39) || (ch >= 0x61 && ch <= 0x7A) || (ch >= 0x41 && ch <= 0x5C) ) 
-				temp[j]='.';
-		   else
-			   temp[j]=(char)ch; 
-#endif
-
-        }
-		for (j=size1; j<16; j++) {
-     
-           PD_DEBUG("   ");
-      
-        }
-    
-	}
-   
-	PD_DEBUG("\n");
-
-    return;
-}
-#endif
-
-
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_fw.c
+* @version 1.2.5
+*-----------------------------------------------------------------------------
+*/
+
+
+
+#include "ch7036_intf.h"
+
+#include "edid7036.car"
+
+
+#define EDID_RETRY_MAX_TIMES 5
+#define HPD_LOOP_MAX 10
+
+
+#define SLEEP_TIME 200
+
+
+#define lhfm_size  sizeof(lhfm_array)
+
+#define LHFM_TIMEOUT	10
+
+static unsigned char edid_header[8]={0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00};
+
+static unsigned char es_map[16] = {
+	0x26,0x27,0x42,0x43,0x44,0x45,0x46,0x47,
+	0x6A,0x51,0x52,0x53,0x57,0x58,0x59,0x5A
+};
+
+
+
+
+
+established_timings_t et_I[8] = {
+	{0,"800x600_60", {OUT_DVI_800x600_60,OUT_HDMI_END, OUT_CRT_800x600_60} },
+	{0,"800x600_56", {OUT_DVI_800x600_56,OUT_HDMI_END, OUT_CRT_800x600_56} },
+	{0,"640x480_75", {OUT_DVI_640x480_75, OUT_HDMI_END, OUT_CRT_640x480_75} },
+	{0,"640x480_72", {OUT_DVI_640x480_72, OUT_HDMI_END, OUT_CRT_640x480_72} },
+	{0,"640x480_67", {OUT_DVI_END, OUT_HDMI_END, OUT_CRT_END } },
+	{0,"640x480_60", {OUT_DVI_640x480_60, OUT_HDMI_640x480P_60, OUT_CRT_640x480_60} },
+	{0,"720x400_88", {OUT_DVI_END, OUT_HDMI_END, OUT_CRT_END } },
+	{0,"720x400_70", {OUT_DVI_720x400_70, OUT_HDMI_END, OUT_CRT_END} },
+};
+
+established_timings_t et_II[8] ={
+	{0, "1280x1024_75", {OUT_DVI_1280x1024_75, OUT_HDMI_END, OUT_CRT_1280x1024_75} },
+	{0, "1024x768_75", {OUT_DVI_1024x768_75, OUT_HDMI_END, OUT_CRT_1024x768_75} },
+	{0, "1024x768_70", {OUT_DVI_1024x768_70, OUT_HDMI_END, OUT_CRT_1024x768_70} },
+	{0, "1024x768_60", {OUT_DVI_1024x768_60, OUT_HDMI_END, OUT_CRT_1024x768_60} },
+	{0, "1024x768_87", {OUT_DVI_END, OUT_HDMI_END, OUT_CRT_END} },
+	{0, "832x624_75", {OUT_DVI_END, OUT_HDMI_END, OUT_CRT_END} },
+	{0, "800x600_75", {OUT_DVI_800x600_75, OUT_HDMI_END, OUT_CRT_800x600_75} },
+	{0, "800x600_72", {OUT_DVI_800x600_72, OUT_HDMI_END, OUT_CRT_800x600_72} }
+};
+
+established_timings_t et_man = {
+	0, "1152x870_75", {OUT_DVI_END, OUT_HDMI_END, OUT_CRT_END}
+};
+
+
+int LHFM_get_version(DEV_CONTEXT* p_ch7xxx_context,struct _FW7036_CFG* cfg)
+{
+
+	unsigned char reg;
+	unsigned wj;
+
+		 I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		 reg = I2CRead(p_ch7xxx_context,0x4F);
+
+
+		 if (0==(LHFM_REQUEST & reg)) {
+			 I2CWrite(p_ch7xxx_context,0x4F, (LHFM_REQUEST+LHFM_GET_VERSION));
+			 wj = 0;
+			 while (wj++< LHFM_TIMEOUT) {
+
+
+				 I2CWrite(p_ch7xxx_context,0x03, 0x00);
+				 pd_usleep(SLEEP_TIME );
+				 PD_DEBUG("LHFM_get_version [%x]\r\n", wj);
+
+				 reg = I2CRead(p_ch7xxx_context,0x4F);
+				 if(reg == LHFM_GET_VERSION) {
+					 reg = I2CRead(p_ch7xxx_context,0x50);
+					 if (!(LHFM_RET_ERROR & reg)) {
+						    I2CWrite(p_ch7xxx_context,0x03, 0x01);
+						    cfg->size = I2CRead(p_ch7xxx_context,es_map[0]);
+							cfg->ver_major = I2CRead(p_ch7xxx_context,es_map[1]);
+							cfg->ver_minor = I2CRead(p_ch7xxx_context,es_map[2]);
+							cfg->did = I2CRead(p_ch7xxx_context,es_map[3]);
+							cfg->rid = I2CRead(p_ch7xxx_context,es_map[4]);
+							cfg->capbility = I2CRead(p_ch7xxx_context,es_map[5]);
+							cfg->reserved = I2CRead(p_ch7xxx_context,es_map[6]);
+						    I2CWrite(p_ch7xxx_context,0x03, 0x00);
+							return 0;
+					 } else return -2;
+
+				 }
+
+			 }
+
+		 }
+
+	return -1;
+}
+
+
+void LHFM_enable_crt_hpd(DEV_CONTEXT* p_ch7xxx_context)
+{
+	uint8 reg;
+
+	PD_DEBUG("ch7036: LHFM_enable_crt_hpd-enter\n");
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x04);
+	reg = I2CRead(p_ch7xxx_context,0x57);
+	I2CWrite(p_ch7xxx_context,0x57, reg | 0x02);
+
+	pd_usleep(SLEEP_TIME);
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x00);
+	I2CWrite(p_ch7xxx_context,0x08, I2CRead(p_ch7xxx_context,0x08) & 0xF1);
+
+	pd_usleep(SLEEP_TIME);
+}
+
+
+ch7036_status_t LHFM_get_crt_hpd(DEV_CONTEXT* p_ch7xxx_context)
+{
+
+	unsigned char reg, count =0;
+	ch7036_status_t status = SS_CRT_HPD_NOTCONNECTED;
+
+	do {
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x74);
+		I2CWrite(p_ch7xxx_context,0x74, reg & 0xFD);
+		pd_usleep(SLEEP_TIME);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		reg = I2CRead(p_ch7xxx_context,0x74);
+		I2CWrite(p_ch7xxx_context,0x74, reg | 0x02);
+		pd_usleep(SLEEP_TIME);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x01);
+		reg = I2CRead(p_ch7xxx_context,0x7C);
+
+		if( (reg & 0xF0) == 0x50  || (reg & 0xF4) == 0x14 || (reg & 0xF4) == 0x44)
+			status= SS_SUCCESS;
+
+	} while ( (status == SS_CRT_HPD_NOTCONNECTED) && ( (++count) < HPD_LOOP_MAX ) );
+
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x00);
+	reg = I2CRead(p_ch7xxx_context,0x74);
+	I2CWrite(p_ch7xxx_context,0x74, reg & 0xFD);
+
+	I2CWrite(p_ch7xxx_context,0x08, I2CRead(p_ch7xxx_context,0x08) | 0x0E);
+
+	return status;
+
+}
+
+
+ch7036_status_t LHFM_get_hdmi_modeinfo(DEV_CONTEXT* p_ch7xxx_context,unsigned char *minfo)
+{
+	unsigned char reg;
+	unsigned wj;
+	unsigned i;
+
+		 I2CWrite(p_ch7xxx_context,0x03, 0x00);
+		 reg = I2CRead(p_ch7xxx_context,0x4F);
+
+		 if (0==(LHFM_REQUEST & reg)) {
+			 I2CWrite(p_ch7xxx_context,0x4F, (LHFM_REQUEST+ LHFM_GET_MODEINFO));
+			 wj = 0;
+			 while (wj++< LHFM_TIMEOUT) {
+				 I2CWrite(p_ch7xxx_context,0x03, 0x00);
+				 pd_usleep(SLEEP_TIME);
+
+				 reg = I2CRead(p_ch7xxx_context,0x4F);
+				 if(reg == LHFM_GET_MODEINFO) {
+					 reg = I2CRead(p_ch7xxx_context,0x50);
+					 if (!(LHFM_RET_ERROR & reg)) {
+						 if (minfo) {
+						    I2CWrite(p_ch7xxx_context,0x03, 0x01);
+							for (i=0; i<15; i++) minfo[i] = I2CRead(p_ch7xxx_context,es_map[i]);
+						}
+						return SS_SUCCESS;
+					 } else return SS_FIRMWARE_ERR;
+
+				 }
+
+			 }
+
+		 }
+
+	return SS_FIRMWARE_TIMEOUT;
+
+}
+
+
+ch7036_status_t LHFM_get_edid(DEV_CONTEXT* p_ch7xxx_context,unsigned char* edid, unsigned char* ebn, unsigned char flag)
+{
+
+	unsigned i,j, ie;
+	unsigned k1, k2;
+	unsigned char reg;
+	unsigned wj;
+
+	ch7036_status_t status;
+
+
+
+	status = SS_SUCCESS;
+	*ebn = 0;
+
+	pd_memset(edid, 0, EDID_SIZE);
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x00);
+	reg = I2CRead(p_ch7xxx_context,0x4F);
+
+	if( (reg & LHFM_REQUEST) != 0 )
+		return SS_FIRMWARE_ERR; //mcu is busy
+	else { //mcu is ready to serve host request
+
+		for(i=0,j=0; i < 8; i++,j+=16) {
+
+		    I2CWrite(p_ch7xxx_context,0x03, 0x00);
+			I2CWrite(p_ch7xxx_context,0x50, i | flag);
+			I2CWrite(p_ch7xxx_context,0x4F, (LHFM_REQUEST+LHFM_GET_EDID));
+			wj = 0;
+
+			status = SS_FIRMWARE_TIMEOUT;
+			PD_DEBUG("ch7036: LHFM_get_edid- block [%d] - getting [%d]- 16 bytes - wj=[0x%x]\n",*ebn,i+1,wj);
+			while (wj++< (2*LHFM_TIMEOUT) ) {
+				 I2CWrite(p_ch7xxx_context,0x03, 0x00);
+				 pd_usleep(SLEEP_TIME);
+
+				 reg = I2CRead(p_ch7xxx_context,0x4F);
+
+				 if(reg == LHFM_GET_EDID) {
+
+					 reg = I2CRead(p_ch7xxx_context,0x50);
+
+					 if (!(LHFM_RET_ERROR & reg)) {
+							I2CWrite(p_ch7xxx_context,0x03, 0x01);
+							for (ie=0; ie<16; ie++) edid[j+ie] = I2CRead(p_ch7xxx_context,es_map[ie] );
+							break;
+					 }
+					 else
+							return SS_FIRMWARE_ERR;
+
+				 }
+
+
+			} //while block
+
+			status = SS_SUCCESS;
+
+		} //for
+
+		for(i=0;i<8;i++)
+			if (edid_header[i] != edid[i]) {
+				return SS_FIRMWARE_ERR;
+			}
+
+		(*ebn)++;
+
+		if(flag & 0x80 && (edid[0x7E] > 0) ) {
+			PD_DEBUG("ch7036: LHFM_get_edid- incorrect # of VGA EDID blocks read [%x]\n",edid[0x7E]);
+			return SS_FIRMWARE_ERR;
+		}
+
+		k2 = edid[0x7E];
+
+		k2 = (k2 > 3)? 3 : k2;
+
+		if (k2>0) { //case: there are more than 1 blocks
+			for (k1=1; k1<=k2; k1++) {
+
+				for(i=k1*8; i < 8+k1*8; i++,j+=16){
+					I2CWrite(p_ch7xxx_context,0x03, 0x00);
+					I2CWrite(p_ch7xxx_context,0x50, i + flag);
+					I2CWrite(p_ch7xxx_context,0x4F, (LHFM_REQUEST+LHFM_GET_EDID));
+					wj = 0;
+
+					status = SS_FIRMWARE_TIMEOUT;
+					PD_DEBUG("ch7036: LHFM_get_edid- block [%d] - getting [%d]- 16 bytes - wj=[0x%x]\n",k1,i+1,wj);
+					while (wj++< (2*LHFM_TIMEOUT)) {
+						I2CWrite(p_ch7xxx_context,0x03, 0x00);
+						pd_usleep(SLEEP_TIME);
+
+						reg = I2CRead(p_ch7xxx_context,0x4F);
+
+						if(reg == LHFM_GET_EDID) {
+							reg = I2CRead(p_ch7xxx_context,0x50);
+							if (!(LHFM_RET_ERROR & reg)) {
+								I2CWrite(p_ch7xxx_context,0x03, 0x01);
+								for (ie=0; ie<16; ie++) edid[j+ie] = I2CRead(p_ch7xxx_context,es_map[ie] );
+								break;
+							}
+							else
+								return SS_FIRMWARE_ERR;
+
+
+						}
+
+					} //while
+
+					status = SS_SUCCESS;
+
+				}//nested for
+
+				(*ebn)++;
+
+			} //outermost for
+
+
+		} //if- case: there are more than 1 blocks
+
+	} //else - case:  mcu is ready to serve host request
+
+	return status;
+
+}
+
+
+int LHFM_load_firmware(DEV_CONTEXT* p_ch7xxx_context)
+{
+
+
+	unsigned fs1;
+	unsigned char ch;
+
+	PD_DEBUG("ch7036: LHFM_load_firmware- firmware size [0x%.8X]\n",lhfm_size);
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x04);
+	ch = 0x29 | I2CRead(p_ch7xxx_context,0x52);
+	I2CWrite(p_ch7xxx_context,0x52, ch & 0xFB);
+
+
+	I2CWrite(p_ch7xxx_context,0x5B, 0x9E);
+	I2CWrite(p_ch7xxx_context,0x5B, 0xB3);
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x04);
+	I2CWrite(p_ch7xxx_context,0x03, 0x07);
+
+	for (fs1=0; fs1<lhfm_size; fs1++)
+		I2CWrite(p_ch7xxx_context, 0x07, lhfm_array[fs1]);
+
+
+
+	I2CWrite(p_ch7xxx_context, 0x03, 0x03);
+	ch = I2CRead(p_ch7xxx_context,0x74);
+	if (ch & 0x1) {
+
+		return -1;
+	}
+	else {
+
+		I2CWrite( p_ch7xxx_context,0x03, 0x04);
+		ch = I2CRead(p_ch7xxx_context,0x52);
+		I2CWrite(p_ch7xxx_context, 0x52, ch | 0x24);
+	}
+
+	I2CWrite(p_ch7xxx_context, 0x03, 0x00);
+
+	return 0;
+}
+#if 0
+void ch7036_dump( char *s, int size, unsigned char *regdata)
+{
+	char temp[18];
+    int ch;
+
+    int i,j, size1;
+
+    temp[16] = '?';
+    temp[17] = '\n';
+
+	PD_DEBUG("\n");
+    PD_DEBUG("+--------------------------------------------------------------------+\n");
+    PD_DEBUG("|%s |\n",s);
+    PD_DEBUG("+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-----------------+\n");
+    PD_DEBUG("|  | 0| 1| 2| 3| 4| 5| 6| 7| 8| 9| A| B| C| D| E| F|                 |\n");
+    PD_DEBUG("++++--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-----------------+\n");
+
+    size1 = size % 16;
+    size = size/16;
+
+    for (i=0; i<size; i++) {
+
+
+       PD_DEBUG("|%02x>", 0xFF & i*16);
+
+
+	   for (j=0; j<16; j++) {
+           ch = regdata[i*16+j];
+           PD_DEBUG("%02X|", ch);
+
+#if 0
+
+
+		   if( (ch >= 0x30 && ch <= 0x39) || (ch >= 0x61 && ch <= 0x7A) || (ch >= 0x41 && ch <= 0x5C) )
+				temp[j]='.';
+		   else
+			   temp[j]=(char)ch;
+#endif
+
+        }
+
+	   PD_DEBUG("\n");
+	}
+
+	if (size1) {
+
+        PD_DEBUG( "|%02x>", 0xFF & size*16);
+
+		for (j=0; j<size1; j++) {
+           ch = regdata[size*16+j];
+           PD_DEBUG("%02X|", ch);
+#if 0
+
+			if( (ch >= 0x30 && ch <= 0x39) || (ch >= 0x61 && ch <= 0x7A) || (ch >= 0x41 && ch <= 0x5C) )
+				temp[j]='.';
+		   else
+			   temp[j]=(char)ch;
+#endif
+
+        }
+		for (j=size1; j<16; j++) {
+
+           PD_DEBUG("   ");
+
+        }
+
+	}
+
+	PD_DEBUG("\n");
+
+    return;
+}
+#endif
+
+
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.h
index cc4a321..1dc77ee 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.h
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_fw.h
@@ -1,213 +1,213 @@
-/*-----------------------------------------------------------------------------
-* Copyright (c) Chrontel Inc.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy
-* of this software and associated documentation files (the "Software"), to deal
-* in the Software without restriction, including without limitation the rights
-* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-* copies of the Software, and to permit persons to whom the Software is
-* furnished to do so, subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in
-* all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-* THE SOFTWARE.
-*
-*-----------------------------------------------------------------------------
-* @file  ch7036_fw.h
-* @version 1.2.2
-*-----------------------------------------------------------------------------
-*/
-
-
-#ifndef H_FW_OPER_H
-#define H_FW_OPER_H
-
-#include "ch7036_typedef.h"
-
-
-//#include <linux/kernel.h>
-
-#define	CFG_CAP_EDID	0x01
-#define CFG_CAP_HDCP	0x02
-
-typedef unsigned char ch7036_attr_table_index_t;
-
-
-typedef struct _FW7036_CFG {
-    unsigned char size;	 
-	unsigned char ver_major;
-	unsigned char ver_minor;
-	unsigned char did;
-	unsigned char rid;
-	unsigned char capbility;
-	unsigned char reserved;
-} FW7036_CFG;
-
-
-#define LHFM_GET_VERSION		0x1F
-#define LHFM_GET_HPD			0x06
-#define LHFM_GET_EDID			0x01
-#define LHFM_GET_MODEINFO		0x03
-#define LHFM_GET_VGA_MODEINFO	0x33
-#define LHFM_HDMI_ONOFF		0x04 
-#define LHFM_REQUEST		0x40
-#define LHFM_RET_ERROR		0x80
-
-int LHFM_get_version(DEV_CONTEXT* p_ch7xxx_context,struct _FW7036_CFG* cfg);
-
-void LHFM_enable_crt_hpd(DEV_CONTEXT* p_ch7xxx_context);
-ch7036_status_t LHFM_get_crt_hpd(DEV_CONTEXT* p_ch7xxx_context);
-int LHFM_hdmi_onoff(int turnon);
-ch7036_status_t LHFM_get_hdmi_modeinfo(DEV_CONTEXT* p_ch7xxx_context,unsigned char *minfo);
-ch7036_status_t LHFM_get_edid(DEV_CONTEXT* p_ch7xxx_context,unsigned char*edid, unsigned char* ebn, unsigned char flag);
-int LHFM_load_firmware(DEV_CONTEXT* pDevContext);
-void ch7036_dump( char *s, int size, unsigned char *regdata);
-
-#define GET_VER					0x01
-#define GET_HPD					0x02
-#define GET_EDID				0x04
-#define GET_HDMI_DISPLAY_MODES	0x08
-
-#define GET_CRT_HPD				0x10
-#define GET_CRT_EDID			0x20
-
-#define CH7036_HDMI_DDC			0
-#define CH7036_VGA_DDC			0x80
-
-#define MAX_EDID_BLOCKS			2
-
-#define MAX_I2C_BLOCK_SIZE		32
-
-
-
-
-#define NUM_OF_BLOCKS                         0x0F  
-#define DTD_SIZE                              0x12  
-#define EDID_SIZE                             0x0100
-#define EDID_STRUCTURE_VERSION                0x12
-#define EDID_STRUCTURE_REVISION               0x13
-#define EDID_FEATURE_SUPPORT                  0x18
-#define EDID_ESTABLISHED_TIMINGS_1            0x23  
-#define EDID_ESTABLISHED_TIMINGS_2            0x24  
-#define EDID_MANUFACTURERS_RESERVED_TIMINGS   0x25  
-#define EDID_STANDARD_TIMINGS                 0x26  
-#define EDID_STANDARD_TIMINGS_BIT_DESCRIPTION 0x27  
-#define EDID_DETAILED_TIMING_DESCRIPTION_1    0x36  
-#define EDID_DETAILED_TIMING_DESCRIPTION_2    0x48  
-#define EDID_DETAILED_TIMING_DESCRIPTION_3    0x5A  
-
-#define EDID_EXTENSION_FLAG                   0x7E  
-
-#define EDID_CEA_TAG                          0x80  
-#define EDID_CEA_REVISION                     0x81  
-#define EDID_CEA_DETAILED_TIMING_DATA_OFFSET  0x82  
-#define EDID_CEA_VIDEO_DATA_BLOCK             0x84  
-#define EDID_CEA_DATA_BLOCK					  0x84
-
-#define EDID_CEA_VIDEO_DATA_BLOCK_2           0x96  
-#define EDID_CEA_VIDEO_DATA_BLOCK_3           0xA8  
-#define EDID_CEA_VIDEO_DATA_BLOCK_4           0xBA  
-#define EDID_CEA_VIDEO_DATA_BLOCK_5           0xCC  
-#define EDID_CEA_VIDEO_DATA_BLOCK_6           0xDE  
-
-#define EDID_SPACE_INDEX_START                0x18  
-
-
-
-
-
-typedef struct {
-    unsigned char  is_supported;
-    char mode_name[13];
-	unsigned long index[3]; 
-
-}established_timings_t, *p_established_timings;
-
-typedef struct {
-	unsigned int ha; 
-	unsigned int va; 
-	unsigned char refresh_rate;
-}standard_timings_t, *p_standard_timings;
-
-
-
-typedef struct {
-	unsigned char pclk_lobyte;
-	unsigned char pclk_hibyte;
-	unsigned char hactive_lobyte;
-	unsigned char hblank_lobyte;
-	unsigned char hactive_blank;			
-	unsigned char vactive_lobyte;
-	unsigned char vblank_lobyte;
-	unsigned char vactive_blank;			
-	unsigned char hsync_off_lobyte;			
-	unsigned char hsync_pulse_width;         
-	unsigned char vsync_off_pulse_width;	
-											
-	unsigned char hsopw_vsopw;				
-											
-											 
-											
-	unsigned char himage_size_lobyte;		
-	unsigned char vimage_size_lobyte;       
-	unsigned char hvimage_size;				
-											
-	unsigned char hborder;
-	unsigned char vborder; 
-	unsigned char flags;
-}dtd_t, *p_dtd;
-
-
-typedef struct monitor_range {
-
-	unsigned char  hrate_min;           
-	unsigned char  hrate_max;            
-	unsigned char  vrate_min;           
-	unsigned char  vrate_max;            
-
-	unsigned long  pclk_max;           
-
-}monitor_range_t;
-
-
-typedef struct detailed_timing_block {
-	unsigned long data_tag; 
-	OUT_FMT		dtiming; 
-} dtblks_t;
-
-
-typedef struct edid_blk {
-	
-
-	unsigned char						is_edid; 
-	unsigned char						is_preferred_timing;  
-
-	unsigned char						ebn; 
-	unsigned char						edidblk[EDID_SIZE]; 
-
-	established_timings_t				*etiming_I;
-	established_timings_t				*etiming_II;
-	established_timings_t				*etiming_man;
-
-	standard_timings_t					stiming[8];
-
-	standard_timings_t					stiming_x[6]; 
-	monitor_range_t						rtiming; 
-
-	dtblks_t							dtblk[4];
-	
-	
-	unsigned char						supported_modes[15]; 
-	ch7036_attr_table_index_t			modes[MAX_ATTR_LIST_SIZE]; 
-
-} ch7036_edid_blk_t;
-
-
-#endif
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_fw.h
+* @version 1.2.2
+*-----------------------------------------------------------------------------
+*/
+
+
+#ifndef H_FW_OPER_H
+#define H_FW_OPER_H
+
+#include "ch7036_typedef.h"
+
+
+//#include <linux/kernel.h>
+
+#define	CFG_CAP_EDID	0x01
+#define CFG_CAP_HDCP	0x02
+
+typedef unsigned char ch7036_attr_table_index_t;
+
+
+typedef struct _FW7036_CFG {
+    unsigned char size;
+	unsigned char ver_major;
+	unsigned char ver_minor;
+	unsigned char did;
+	unsigned char rid;
+	unsigned char capbility;
+	unsigned char reserved;
+} FW7036_CFG;
+
+
+#define LHFM_GET_VERSION		0x1F
+#define LHFM_GET_HPD			0x06
+#define LHFM_GET_EDID			0x01
+#define LHFM_GET_MODEINFO		0x03
+#define LHFM_GET_VGA_MODEINFO	0x33
+#define LHFM_HDMI_ONOFF		0x04
+#define LHFM_REQUEST		0x40
+#define LHFM_RET_ERROR		0x80
+
+int LHFM_get_version(DEV_CONTEXT* p_ch7xxx_context,struct _FW7036_CFG* cfg);
+
+void LHFM_enable_crt_hpd(DEV_CONTEXT* p_ch7xxx_context);
+ch7036_status_t LHFM_get_crt_hpd(DEV_CONTEXT* p_ch7xxx_context);
+int LHFM_hdmi_onoff(int turnon);
+ch7036_status_t LHFM_get_hdmi_modeinfo(DEV_CONTEXT* p_ch7xxx_context,unsigned char *minfo);
+ch7036_status_t LHFM_get_edid(DEV_CONTEXT* p_ch7xxx_context,unsigned char*edid, unsigned char* ebn, unsigned char flag);
+int LHFM_load_firmware(DEV_CONTEXT* pDevContext);
+void ch7036_dump( char *s, int size, unsigned char *regdata);
+
+#define GET_VER					0x01
+#define GET_HPD					0x02
+#define GET_EDID				0x04
+#define GET_HDMI_DISPLAY_MODES	0x08
+
+#define GET_CRT_HPD				0x10
+#define GET_CRT_EDID			0x20
+
+#define CH7036_HDMI_DDC			0
+#define CH7036_VGA_DDC			0x80
+
+#define MAX_EDID_BLOCKS			2
+
+#define MAX_I2C_BLOCK_SIZE		32
+
+
+
+
+#define NUM_OF_BLOCKS                         0x0F
+#define DTD_SIZE                              0x12
+#define EDID_SIZE                             0x0100
+#define EDID_STRUCTURE_VERSION                0x12
+#define EDID_STRUCTURE_REVISION               0x13
+#define EDID_FEATURE_SUPPORT                  0x18
+#define EDID_ESTABLISHED_TIMINGS_1            0x23
+#define EDID_ESTABLISHED_TIMINGS_2            0x24
+#define EDID_MANUFACTURERS_RESERVED_TIMINGS   0x25
+#define EDID_STANDARD_TIMINGS                 0x26
+#define EDID_STANDARD_TIMINGS_BIT_DESCRIPTION 0x27
+#define EDID_DETAILED_TIMING_DESCRIPTION_1    0x36
+#define EDID_DETAILED_TIMING_DESCRIPTION_2    0x48
+#define EDID_DETAILED_TIMING_DESCRIPTION_3    0x5A
+
+#define EDID_EXTENSION_FLAG                   0x7E
+
+#define EDID_CEA_TAG                          0x80
+#define EDID_CEA_REVISION                     0x81
+#define EDID_CEA_DETAILED_TIMING_DATA_OFFSET  0x82
+#define EDID_CEA_VIDEO_DATA_BLOCK             0x84
+#define EDID_CEA_DATA_BLOCK					  0x84
+
+#define EDID_CEA_VIDEO_DATA_BLOCK_2           0x96
+#define EDID_CEA_VIDEO_DATA_BLOCK_3           0xA8
+#define EDID_CEA_VIDEO_DATA_BLOCK_4           0xBA
+#define EDID_CEA_VIDEO_DATA_BLOCK_5           0xCC
+#define EDID_CEA_VIDEO_DATA_BLOCK_6           0xDE
+
+#define EDID_SPACE_INDEX_START                0x18
+
+
+
+
+
+typedef struct {
+    unsigned char  is_supported;
+    char mode_name[13];
+	unsigned long index[3];
+
+}established_timings_t, *p_established_timings;
+
+typedef struct {
+	unsigned int ha;
+	unsigned int va;
+	unsigned char refresh_rate;
+}standard_timings_t, *p_standard_timings;
+
+
+
+typedef struct {
+	unsigned char pclk_lobyte;
+	unsigned char pclk_hibyte;
+	unsigned char hactive_lobyte;
+	unsigned char hblank_lobyte;
+	unsigned char hactive_blank;
+	unsigned char vactive_lobyte;
+	unsigned char vblank_lobyte;
+	unsigned char vactive_blank;
+	unsigned char hsync_off_lobyte;
+	unsigned char hsync_pulse_width;
+	unsigned char vsync_off_pulse_width;
+
+	unsigned char hsopw_vsopw;
+
+
+
+	unsigned char himage_size_lobyte;
+	unsigned char vimage_size_lobyte;
+	unsigned char hvimage_size;
+
+	unsigned char hborder;
+	unsigned char vborder;
+	unsigned char flags;
+}dtd_t, *p_dtd;
+
+
+typedef struct monitor_range {
+
+	unsigned char  hrate_min;
+	unsigned char  hrate_max;
+	unsigned char  vrate_min;
+	unsigned char  vrate_max;
+
+	unsigned long  pclk_max;
+
+}monitor_range_t;
+
+
+typedef struct detailed_timing_block {
+	unsigned long data_tag;
+	OUT_FMT		dtiming;
+} dtblks_t;
+
+
+typedef struct edid_blk {
+
+
+	unsigned char						is_edid;
+	unsigned char						is_preferred_timing;
+
+	unsigned char						ebn;
+	unsigned char						edidblk[EDID_SIZE];
+
+	established_timings_t				*etiming_I;
+	established_timings_t				*etiming_II;
+	established_timings_t				*etiming_man;
+
+	standard_timings_t					stiming[8];
+
+	standard_timings_t					stiming_x[6];
+	monitor_range_t						rtiming;
+
+	dtblks_t							dtblk[4];
+
+
+	unsigned char						supported_modes[15];
+	ch7036_attr_table_index_t			modes[MAX_ATTR_LIST_SIZE];
+
+} ch7036_edid_blk_t;
+
+
+#endif
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_iic.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_iic.h
index 593aee8..fd168db 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_iic.h
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_iic.h
@@ -1,30 +1,30 @@
-/*-----------------------------------------------------------------------------
-* Copyright (c) Chrontel Inc.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy
-* of this software and associated documentation files (the "Software"), to deal
-* in the Software without restriction, including without limitation the rights
-* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-* copies of the Software, and to permit persons to whom the Software is
-* furnished to do so, subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in
-* all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-* THE SOFTWARE.
-*
-*-----------------------------------------------------------------------------
-* @file  ch7036_iic.h
-* @version 1.2.2
-*-----------------------------------------------------------------------------
-*/
-
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_iic.h
+* @version 1.2.2
+*-----------------------------------------------------------------------------
+*/
+
 #ifndef _CH7036_IIC_H
 #define _CH7036_IIC_H
 
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.c b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.c
index bc7b8a9..33c275d 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.c
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.c
@@ -1,1994 +1,1994 @@
-/*-----------------------------------------------------------------------------
-* Copyright (c) Chrontel Inc.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy
-* of this software and associated documentation files (the "Software"), to deal
-* in the Software without restriction, including without limitation the rights
-* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-* copies of the Software, and to permit persons to whom the Software is
-* furnished to do so, subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in
-* all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-* THE SOFTWARE.
-*
-*-----------------------------------------------------------------------------
-* @file  ch7036_intf.c
-* @version 1.2.5
-*-----------------------------------------------------------------------------
-*/
-
-
-#include "ch7036_intf.h"
-#include "ch7036_attr.h"
-
-
-#ifdef T_LINUX
-	#include "lvds/lvds.h"
-#else
-	#include "lvds.h"
-#endif
-
-
-ch7036_status_t ch7036_get_hdmi_hpd(ch7036_device_context_t* p_ctx, uint8 *hpd);
-
-unsigned long ch7036_invis_6x4_modes_table_size[3] = {2,3,5}; 
-unsigned long ch7036_invis_8x6_7x4_table_size[3] = {3,5,6};
-
-OUT_FMT hdmi_timing_table[OUT_HDMI_END] = {
-	
-		                    
-	{1,     25175,  1, {800,   640, 16,  96, 525,  480, 10,  2, 59, SCANTYPE_PROGRESSIVE} }, 
-    {1,     25250,  1, {800,   640, 16,  96, 525,  480, 10,  2, 60, SCANTYPE_PROGRESSIVE} },
-    {2,     27000,  1, {858,   720, 16,  62, 525,  480,  9,  6, 59, SCANTYPE_PROGRESSIVE} },
-    {2,     27027,  1, {858,   720, 16,  62, 525,  480,  9,  6, 60, SCANTYPE_PROGRESSIVE} },
-	{17,     27000,  1, {864,  720,  12,  64, 625,  576,  5,  5, 50, SCANTYPE_PROGRESSIVE} },
-
-    {4,     74176,  2, {1650, 1280, 110, 40, 750,  720,  5,  5, 59, SCANTYPE_PROGRESSIVE} },
-    {4,     74250,  2, {1650, 1280, 110, 40, 750,  720,  5,  5, 60, SCANTYPE_PROGRESSIVE} },
-    {5,     74176,  2, {2200, 1920, 88,  44, 1125, 1080, 2,  5, 59, SCANTYPE_INTERLACED} },
-    {5,     74250,  2, {2200, 1920, 88,  44, 1125, 1080, 2,  5, 60, SCANTYPE_INTERLACED} },
-	{16,    148350,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 59, SCANTYPE_PROGRESSIVE} },
-//   {16,    148352,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 59, SCANTYPE_PROGRESSIVE} }, 
-   {16,    148500,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 60, SCANTYPE_PROGRESSIVE} }, 
- 
-//   {17,     27000,  1, {864,  720,  12,  64, 625,  576,  5,  5, 50, SCANTYPE_PROGRESSIVE} }, 
-   {19,     74250,  2, {1980, 1280, 440, 40, 750,  720,  5,  5, 50, SCANTYPE_PROGRESSIVE} }, 
-   
-   {20,     74250,  2, {2640, 1920, 528, 44, 1125, 1080, 2, 5, 50, SCANTYPE_INTERLACED} },
-
-
-   {31,    148500,  2, {2640, 1920, 528, 44, 1125, 1080, 4,  5, 50, SCANTYPE_PROGRESSIVE} },
-   {32,     74175,  2, {2750, 1920, 638, 44, 1125, 1080, 4,  5, 23, SCANTYPE_PROGRESSIVE} },
-   {32,     74250,  2, {2750, 1920, 638, 44, 1125, 1080, 4,  5, 24, SCANTYPE_PROGRESSIVE} },
-   {33,     74250,  2, {2640, 1920, 528, 44, 1125, 1080, 4,  5, 25, SCANTYPE_PROGRESSIVE} },
-   {34,     74175,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 29, SCANTYPE_PROGRESSIVE} },
-   {34,     74250,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 30, SCANTYPE_PROGRESSIVE} }, 
-
-   {40,    148500,  2, {2640, 1920, 528, 44, 1124, 1080, 4, 10, 100, SCANTYPE_INTERLACED} },
-   {41,    148500,  2, {1980, 1280, 440, 40, 750,  720,  5,  5, 100, SCANTYPE_PROGRESSIVE} },
-   {42,     54000,  1, {864,   720, 12,  64, 625,  576,  5,  5, 100, SCANTYPE_PROGRESSIVE} },
-
-
-   {46,    148352,  2, {2200, 1920, 88,  44, 1124, 1080, 4, 10, 119, SCANTYPE_INTERLACED} },
-   {46,    148500,  2, {2200, 1920, 88,  44, 1124, 1080, 4, 10, 120, SCANTYPE_INTERLACED} },
-
-   {47,    148352,  2, {1650, 1280, 110, 40, 750,  720,  5,  5, 119, SCANTYPE_PROGRESSIVE} },
-   {47,    148500,  2, {1650, 1280, 110, 40, 750,  720,  5,  5, 120, SCANTYPE_PROGRESSIVE} },
-   
-   {48,     54000,  1, {858,   720, 16,  62, 525,  480,  9,  6, 119, SCANTYPE_PROGRESSIVE} },
-   {48,     54054,  1, {858,   720, 16,  62, 525,  480,  9,  6, 120, SCANTYPE_PROGRESSIVE} }, 
-  
-   {52,    108000,  1, {864,   720, 12,  64, 625,  576,  5,  5, 200, SCANTYPE_PROGRESSIVE} },
-
-   {56,    108000,  1, {858,   720, 16,  62, 525,  480,  9,  6, 239, SCANTYPE_PROGRESSIVE} },
-   {56,    108108,  1, {858,   720, 16,  62, 525,  480,  9,  6, 240, SCANTYPE_PROGRESSIVE} }, 
-  
-};
-
-OUT_FMT dvi_timing_table[OUT_DVI_END] = {
-	
-
-
-	{0,     25170,  0, { 800,  640, 16,  96, 525,  480, 10,  2,  60, SCANTYPE_PROGRESSIVE}	}, 
-	{0,     31500,  0, { 832,  640, 24,  40, 520,  480,  9,  3,  72, SCANTYPE_PROGRESSIVE}	},  
-    {0,     31500,  0, { 800,  640, 16,  96, 525,  480, 11,  2,  75, SCANTYPE_PROGRESSIVE}	},  
-
-	{0,     28322,  0, { 900,  720, 15, 108, 449,  400, 11,  2,  70, SCANTYPE_PROGRESSIVE}	},  
-	
-	{0,		38100,	0, {1088,  800,	32, 128, 619,  600,  1,  4,  56, SCANTYPE_PROGRESSIVE}	},
-	
-
-	{0,		40000,	0, {1056,  800,	40, 128, 628,  600,  1,  4,  60, SCANTYPE_PROGRESSIVE}	},
-	{0,		50000,	0, {1040,  800,	56, 120, 666,  600, 37,  6,  72, SCANTYPE_PROGRESSIVE}	},
-	{0,		49500,	0, {1056,  800,	16,  80, 624,  600,  1,  2,  75, SCANTYPE_PROGRESSIVE}	},
-
-	{0,		65000,	0, {1344, 1024,	24,	136, 806,  768,	 3,	 6,  60, SCANTYPE_PROGRESSIVE}	}, 
-    {0,		75000,	0, {1328, 1024,	24,	136, 806,  768,	 3,	 6,  70, SCANTYPE_PROGRESSIVE}	},
-	{0,		78750,	0, {1312, 1024,	16,	 96, 800,  768,	 1,	 3,  75, SCANTYPE_PROGRESSIVE}	},
-
-	{0,		81517,	0, {1688, 1152,	48,112,1066,  864,	 1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
-
-	{0,		83460,	0, {1680, 1280,	64,	136, 828,  720,  1,	 3,  60, SCANTYPE_PROGRESSIVE}	}, 
-	
-	{0,		83865,	0, {1680, 1280,	64,	136, 828,  800,  1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
-	
-	{0,		100638,	0, {1688, 1280,	48,	112, 1066, 960,  1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
-
-	{0,		108000,	0, {1688, 1280,	48,	112, 1066, 1024, 1,	 3,  60, SCANTYPE_PROGRESSIVE}	}, 
-	{0,		135000,	0, {1688, 1280,	16,	144, 1066, 1024, 1,	 3,  75, SCANTYPE_PROGRESSIVE}	},
-
-	{0,		85543,	0, {2256, 1360,104, 184, 1087, 768,  1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
-	{0,		85920,	0, {2256, 1366,104, 184, 1087, 768,  1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
-
-	{0,		121750,	0, {1864, 1400,	88,144,1089,  1050,	 3,	 4,  60, SCANTYPE_PROGRESSIVE}	}, 
-    {0,		156000,	0, {1896, 1400,104,144,1099,  1050,	 3,	 4,  75, SCANTYPE_PROGRESSIVE}	},
-
-
-	{0,		88750,	0, {1600, 1440,	48,	32,	 926,  900,	 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
-	{0,		119000,	0, {1840, 1440,	48,	32,	 1080, 1050, 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
- 	
-	{0,		117936,	0, {2256, 1600,104,	184, 1250,  900, 1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
-	{0,		162000,	0, {2160, 1600,	64,	192, 1250, 1200, 1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
-
-	{0,		147130,	0, {2256, 1680,104,	184, 1087, 1050, 1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
-	{0,     148500, 0, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 60, SCANTYPE_PROGRESSIVE} },
-	{0,		154000,	0, {2080, 1920,	48,	 32, 1235, 1200, 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
-
-};
-
-
-
-
-OUT_FMT ch7036_crt_timing_table[OUT_CRT_END] = {
-   
-   
-   {100,    31500,  1, {832,   640, 32,  64,  445,  400, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
-	 
-   {100,    25175,  1, {800,   640,  8,  96,  525,  480, 2,  2,  60, SCANTYPE_PROGRESSIVE}  },
-   {100,    31500,  1, {832,   640, 16,  40,  520,  480, 1,  3,  72, SCANTYPE_PROGRESSIVE}  },
-   {100,    31500,  1, {840,   640, 16,  64,  500,  480, 1,  3,  75, SCANTYPE_PROGRESSIVE}  },
-   {100,    36000,  1, {832,   640, 56,  56,  509,  480, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
-   
-   {100,    35500,  1, {936,   720, 36,  72,  446,  400, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
-   
-
-   
-   {100,    36000,  1, {1024,  800, 24,  72,  625,  600, 1,  2,  56, SCANTYPE_PROGRESSIVE}  },
-   
-
-   {100,    38250,  1, {1024,  800, 32,  80,  624,  600, 3,  4,  60, SCANTYPE_PROGRESSIVE}  },
-   {100,    50000,  1, {1040,  800, 56, 120,  666,  600, 37, 6,  72, SCANTYPE_PROGRESSIVE}  },
-   {100,    49000,  1, {1040,  800, 40,  80,  629,  600, 3,  4,  75, SCANTYPE_PROGRESSIVE}  },
-   {100,    56750,  1, {1056,  800, 48,  80,  633,  600, 3,  4,  85, SCANTYPE_PROGRESSIVE}  },
-
-    
-   {100,    65000,  1, {1344, 1024, 24, 136,  806,  768, 3,  6,  60, SCANTYPE_PROGRESSIVE}  },
-   {100,    75000,  1, {1328, 1024, 24, 136,  806,  768, 3,  6,  70, SCANTYPE_PROGRESSIVE}  },
-   {100,    78750,  1, {1312, 1024, 16,  96,  800,  768, 1,  3,  75, SCANTYPE_PROGRESSIVE}  }, 
-   
-   {100,    94500,  1, {1376, 1024, 48,  96,  808,  768, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
-   
-    
-   {100,   108000,  1, {1600, 1152, 64, 128,  900,  864, 1,  2,  75, SCANTYPE_PROGRESSIVE}  },
-
-   
-   {100,    79500,  1, {1664, 1280, 64, 128,  798,  768, 3,  7,  60, SCANTYPE_PROGRESSIVE}  },
-   {100,   102250,  1, {1696, 1280, 80, 128,  805,  768, 3,  7,  75, SCANTYPE_PROGRESSIVE}  },
-   {100,   117500,  1, {1712, 1280, 80, 136,  809,  768, 3,  7,  85, SCANTYPE_PROGRESSIVE}  },
-  
-   
-   {100,   108000,  1, {1800, 1280, 96, 112, 1000,  960, 1,  3,  60, SCANTYPE_PROGRESSIVE}  },
-   {100,   148500,  1, {1728, 1280, 64, 160, 1011,  960, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
-
-    
-   {100,   108000,  1, {1688, 1280, 48, 112, 1066, 1024, 1,  3,  60, SCANTYPE_PROGRESSIVE}  },
-   {100,   135000,  1, {1688, 1280, 16, 144, 1066, 1024, 1,  3,  75, SCANTYPE_PROGRESSIVE}  },
-   {100,   157500,  1, {1728, 1280, 64, 160, 1072, 1024, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
-
-   
-   {100,    85500,	1, {1792, 1360,	64, 112,  795,  768, 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
-
-   
-   {100,   121750,	1, {1864, 1400,	88,144,1089,  1050,	 3,	 4,  60, SCANTYPE_PROGRESSIVE}	},
-   {100,   156000,	1, {1896, 1400,104,144,1099,  1050,	 3,	 4,  75, SCANTYPE_PROGRESSIVE}	},
-
-   
-   {100,	88750,	1, {1600, 1440,	48,	32,	 926,  900,	 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
-
-   
-   {100,   119000,	1, {1840, 1440,	48,	32,	 1080, 1050, 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
-
-   
-   {100,   117936,	1, {2256, 1600,104,	184, 1250,  900, 1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
-   
-   
-   {100,   162000,  1, {2160, 1600, 64, 192, 1250, 1200, 1,  3,  60, SCANTYPE_PROGRESSIVE}  },
-   
-   
-   
-   {100,   148500, 1, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 60, SCANTYPE_PROGRESSIVE} },
-   
-   
-   
-};
-
-
-
-
-
-uint8 I2CRead(DEV_CONTEXT* pDevContext,uint8 index)
-{	
-	
-	ch7036_device_context_t *p_ctx= pDevContext->pd_context;
-	pd_reg_t reg_list[2];
-
-	reg_list[0].reg = (i2c_reg_t)index;
-	reg_list[1].reg = PD_REG_LIST_END;
-
-	p_ctx->p_callback->read_regs(p_ctx->p_callback->callback_context, reg_list,PD_REG_DDC);
-
-	return (uint8)(reg_list[0].value);
-}
-
-void I2CWrite(DEV_CONTEXT* pDevContext,uint8 index, uint8 value)
-{
-	ch7036_device_context_t *p_ctx= pDevContext->pd_context;
-	pd_reg_t reg_list[2];
-
-	
-
-	reg_list[0].reg = (i2c_reg_t)index;
-	reg_list[0].value = (i2c_reg_t)value;
-
-	reg_list[1].reg = PD_REG_LIST_END;
-
-	p_ctx->p_callback->write_regs(p_ctx->p_callback->callback_context, reg_list,PD_REG_DDC);
-
-	return;
-}
-
-
-void I2CBlockWrite(DEV_CONTEXT* pDevContext,uint8 index, uint8* value, uint16 len)
-{
-	ch7036_device_context_t *p_ctx= pDevContext->pd_context;
-	pd_reg_t reg_list[MAX_I2C_BLOCK_SIZE +1]; 
-	uint16 i=0;
-	
-
-	for(i=0;i<len;i++) {
-		reg_list[i].reg = (i2c_reg_t)index;
-		reg_list[i].value = (i2c_reg_t)value[i];
-	}
-
-	reg_list[len].reg = PD_REG_LIST_END;
-
-	p_ctx->p_callback->write_regs(p_ctx->p_callback->callback_context, reg_list,PD_REG_DDC);
-
-	return;
-}
-
-ch7036_status_t ch7036_device_prepare(ch7036_device_context_t* p_ctx)
-{
-	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
-	ch7036_status_t status = SS_SUCCESS;
-
-	PD_DEBUG("ch7036_intf: ch7036_device_prepare()\n");
-
-
-	if(!DevicePrepare(p_ch_ctx))
-	{
-		p_ctx->last_emsg = GetLastErrorMessage(); 
-		status = SS_UNSUCCESSFUL; 
-	}
-	
-	return status;
-}
-
-ch7036_status_t ch7036_device_config(ch7036_device_context_t* p_ctx)
-{
-	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
-	ch7036_status_t status = SS_SUCCESS;
-
-	PD_DEBUG("ch7036_intf: ch7036_device_config()\n");
-
-	
-	if(!DeviceConfig(p_ch_ctx))
-	{
-		p_ctx->last_emsg = GetLastErrorMessage();
-		status = SS_UNSUCCESSFUL;
-	}
-	
-	return status;
-	
-}
-
-ch7036_status_t ch7036_device_start(ch7036_device_context_t* p_ctx)
-{
-	
-	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
-	ch7036_status_t status = SS_SUCCESS;
-
-	PD_DEBUG("ch7036_intf: ch7036_device_start()\n");
-	
-	if(!DeviceRunning(p_ch_ctx))
-	{
-		p_ctx->last_emsg = GetLastErrorMessage();
-		status = SS_UNSUCCESSFUL;
-	}
-	
-	return status;
-	
-}
-
-ch7036_status_t ch7036_device_set_power(ch7036_device_context_t* p_ctx, unsigned long channel)
-{
-	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
-	ch7036_status_t status = SS_SUCCESS;
-
-	PD_DEBUG("ch7036_intf: ch7036_device_set_power()- channel [%x]\n", channel);
-	
-	if(!DeviceSetPower(p_ch_ctx,channel))
-	{
-		p_ctx->last_emsg = GetLastErrorMessage();
-		status = SS_UNSUCCESSFUL;
-	}
-	
-	return status;
-}
-
-
-
-ch7036_status_t ch7036_load_firmware(ch7036_device_context_t* p_ctx)
-{
-	
-	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
-
-	ch7036_status_t status = SS_UNSUCCESSFUL;
-
-	PD_DEBUG("ch7036: ch7036_load_firmware()\n");
-
-	
-	if(LHFM_load_firmware(p_ch_ctx) == -1) {
-		PD_DEBUG("ch7036_load_firmware: LHFM_load_firmware()- firmware loading FAILED...\n");
-		
-	}
-	else  {
-		PD_DEBUG("ch7036_load_firmware: LHFM_load_firmware()- firmware loading is a SUCCESS\n");
-		status = SS_SUCCESS;
-	}
-	
-
-	return status;
-
-}
-
-
-
-
-
-
-ch7036_status_t ch7036_get_hdvi_display_modes_supported(ch7036_device_context_t* p_ctx) 
-{
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	ch7036_status_t status;
-	ch7036_edid_blk_t* p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
-
-
-	PD_DEBUG("ch7036_get_hdvi_display_modes_supported()- enter\n");
-
-	status = LHFM_get_hdmi_modeinfo(p_ch7xxx_context,p_hedid->supported_modes);
-
-	if (status == SS_SUCCESS) {
-
-		PD_DEBUG("HDMI_Modes=%02X. Vesa_Modes=%02x\r\n", p_hedid->supported_modes[13], p_hedid->supported_modes[14]);
-
-						
-	}
-	else {
-		PD_DEBUG("ch7036_get_hdvi_display_modes_supported()-- failed!\r\n");
-		PD_DEBUG("status: [%s]\n",status == SS_FIRMWARE_TIMEOUT?"timeout!":"firmware_error!");
-
-		
-	}
-	
-	return status;
-}
-
-
-
-ch7036_status_t ch7036_read_edid(ch7036_device_context_t* p_ctx, uint32 channel)
-{
-	
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
-	ch7036_status_t status = SS_UNSUCCESSFUL; 
-	
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_intf.c
+* @version 1.2.5
+*-----------------------------------------------------------------------------
+*/
+
+
+#include "ch7036_intf.h"
+#include "ch7036_attr.h"
+
+
+#ifdef T_LINUX
+	#include "lvds/lvds.h"
+#else
+	#include "lvds.h"
+#endif
+
+
+ch7036_status_t ch7036_get_hdmi_hpd(ch7036_device_context_t* p_ctx, uint8 *hpd);
+
+unsigned long ch7036_invis_6x4_modes_table_size[3] = {2,3,5};
+unsigned long ch7036_invis_8x6_7x4_table_size[3] = {3,5,6};
+
+OUT_FMT hdmi_timing_table[OUT_HDMI_END] = {
+
+
+	{1,     25175,  1, {800,   640, 16,  96, 525,  480, 10,  2, 59, SCANTYPE_PROGRESSIVE} },
+    {1,     25250,  1, {800,   640, 16,  96, 525,  480, 10,  2, 60, SCANTYPE_PROGRESSIVE} },
+    {2,     27000,  1, {858,   720, 16,  62, 525,  480,  9,  6, 59, SCANTYPE_PROGRESSIVE} },
+    {2,     27027,  1, {858,   720, 16,  62, 525,  480,  9,  6, 60, SCANTYPE_PROGRESSIVE} },
+	{17,     27000,  1, {864,  720,  12,  64, 625,  576,  5,  5, 50, SCANTYPE_PROGRESSIVE} },
+
+    {4,     74176,  2, {1650, 1280, 110, 40, 750,  720,  5,  5, 59, SCANTYPE_PROGRESSIVE} },
+    {4,     74250,  2, {1650, 1280, 110, 40, 750,  720,  5,  5, 60, SCANTYPE_PROGRESSIVE} },
+    {5,     74176,  2, {2200, 1920, 88,  44, 1125, 1080, 2,  5, 59, SCANTYPE_INTERLACED} },
+    {5,     74250,  2, {2200, 1920, 88,  44, 1125, 1080, 2,  5, 60, SCANTYPE_INTERLACED} },
+	{16,    148350,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 59, SCANTYPE_PROGRESSIVE} },
+//   {16,    148352,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 59, SCANTYPE_PROGRESSIVE} },
+   {16,    148500,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 60, SCANTYPE_PROGRESSIVE} },
+
+//   {17,     27000,  1, {864,  720,  12,  64, 625,  576,  5,  5, 50, SCANTYPE_PROGRESSIVE} },
+   {19,     74250,  2, {1980, 1280, 440, 40, 750,  720,  5,  5, 50, SCANTYPE_PROGRESSIVE} },
+
+   {20,     74250,  2, {2640, 1920, 528, 44, 1125, 1080, 2, 5, 50, SCANTYPE_INTERLACED} },
+
+
+   {31,    148500,  2, {2640, 1920, 528, 44, 1125, 1080, 4,  5, 50, SCANTYPE_PROGRESSIVE} },
+   {32,     74175,  2, {2750, 1920, 638, 44, 1125, 1080, 4,  5, 23, SCANTYPE_PROGRESSIVE} },
+   {32,     74250,  2, {2750, 1920, 638, 44, 1125, 1080, 4,  5, 24, SCANTYPE_PROGRESSIVE} },
+   {33,     74250,  2, {2640, 1920, 528, 44, 1125, 1080, 4,  5, 25, SCANTYPE_PROGRESSIVE} },
+   {34,     74175,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 29, SCANTYPE_PROGRESSIVE} },
+   {34,     74250,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 30, SCANTYPE_PROGRESSIVE} },
+
+   {40,    148500,  2, {2640, 1920, 528, 44, 1124, 1080, 4, 10, 100, SCANTYPE_INTERLACED} },
+   {41,    148500,  2, {1980, 1280, 440, 40, 750,  720,  5,  5, 100, SCANTYPE_PROGRESSIVE} },
+   {42,     54000,  1, {864,   720, 12,  64, 625,  576,  5,  5, 100, SCANTYPE_PROGRESSIVE} },
+
+
+   {46,    148352,  2, {2200, 1920, 88,  44, 1124, 1080, 4, 10, 119, SCANTYPE_INTERLACED} },
+   {46,    148500,  2, {2200, 1920, 88,  44, 1124, 1080, 4, 10, 120, SCANTYPE_INTERLACED} },
+
+   {47,    148352,  2, {1650, 1280, 110, 40, 750,  720,  5,  5, 119, SCANTYPE_PROGRESSIVE} },
+   {47,    148500,  2, {1650, 1280, 110, 40, 750,  720,  5,  5, 120, SCANTYPE_PROGRESSIVE} },
+
+   {48,     54000,  1, {858,   720, 16,  62, 525,  480,  9,  6, 119, SCANTYPE_PROGRESSIVE} },
+   {48,     54054,  1, {858,   720, 16,  62, 525,  480,  9,  6, 120, SCANTYPE_PROGRESSIVE} },
+
+   {52,    108000,  1, {864,   720, 12,  64, 625,  576,  5,  5, 200, SCANTYPE_PROGRESSIVE} },
+
+   {56,    108000,  1, {858,   720, 16,  62, 525,  480,  9,  6, 239, SCANTYPE_PROGRESSIVE} },
+   {56,    108108,  1, {858,   720, 16,  62, 525,  480,  9,  6, 240, SCANTYPE_PROGRESSIVE} },
+
+};
+
+OUT_FMT dvi_timing_table[OUT_DVI_END] = {
+
+
+
+	{0,     25170,  0, { 800,  640, 16,  96, 525,  480, 10,  2,  60, SCANTYPE_PROGRESSIVE}	},
+	{0,     31500,  0, { 832,  640, 24,  40, 520,  480,  9,  3,  72, SCANTYPE_PROGRESSIVE}	},
+    {0,     31500,  0, { 800,  640, 16,  96, 525,  480, 11,  2,  75, SCANTYPE_PROGRESSIVE}	},
+
+	{0,     28322,  0, { 900,  720, 15, 108, 449,  400, 11,  2,  70, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		38100,	0, {1088,  800,	32, 128, 619,  600,  1,  4,  56, SCANTYPE_PROGRESSIVE}	},
+
+
+	{0,		40000,	0, {1056,  800,	40, 128, 628,  600,  1,  4,  60, SCANTYPE_PROGRESSIVE}	},
+	{0,		50000,	0, {1040,  800,	56, 120, 666,  600, 37,  6,  72, SCANTYPE_PROGRESSIVE}	},
+	{0,		49500,	0, {1056,  800,	16,  80, 624,  600,  1,  2,  75, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		65000,	0, {1344, 1024,	24,	136, 806,  768,	 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
+    {0,		75000,	0, {1328, 1024,	24,	136, 806,  768,	 3,	 6,  70, SCANTYPE_PROGRESSIVE}	},
+	{0,		78750,	0, {1312, 1024,	16,	 96, 800,  768,	 1,	 3,  75, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		81517,	0, {1688, 1152,	48,112,1066,  864,	 1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		83460,	0, {1680, 1280,	64,	136, 828,  720,  1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		83865,	0, {1680, 1280,	64,	136, 828,  800,  1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		100638,	0, {1688, 1280,	48,	112, 1066, 960,  1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		108000,	0, {1688, 1280,	48,	112, 1066, 1024, 1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+	{0,		135000,	0, {1688, 1280,	16,	144, 1066, 1024, 1,	 3,  75, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		85543,	0, {2256, 1360,104, 184, 1087, 768,  1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+	{0,		85920,	0, {2256, 1366,104, 184, 1087, 768,  1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		121750,	0, {1864, 1400,	88,144,1089,  1050,	 3,	 4,  60, SCANTYPE_PROGRESSIVE}	},
+    {0,		156000,	0, {1896, 1400,104,144,1099,  1050,	 3,	 4,  75, SCANTYPE_PROGRESSIVE}	},
+
+
+	{0,		88750,	0, {1600, 1440,	48,	32,	 926,  900,	 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
+	{0,		119000,	0, {1840, 1440,	48,	32,	 1080, 1050, 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		117936,	0, {2256, 1600,104,	184, 1250,  900, 1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+	{0,		162000,	0, {2160, 1600,	64,	192, 1250, 1200, 1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+
+	{0,		147130,	0, {2256, 1680,104,	184, 1087, 1050, 1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+	{0,     148500, 0, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 60, SCANTYPE_PROGRESSIVE} },
+	{0,		154000,	0, {2080, 1920,	48,	 32, 1235, 1200, 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
+
+};
+
+
+
+
+OUT_FMT ch7036_crt_timing_table[OUT_CRT_END] = {
+
+
+   {100,    31500,  1, {832,   640, 32,  64,  445,  400, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
+
+   {100,    25175,  1, {800,   640,  8,  96,  525,  480, 2,  2,  60, SCANTYPE_PROGRESSIVE}  },
+   {100,    31500,  1, {832,   640, 16,  40,  520,  480, 1,  3,  72, SCANTYPE_PROGRESSIVE}  },
+   {100,    31500,  1, {840,   640, 16,  64,  500,  480, 1,  3,  75, SCANTYPE_PROGRESSIVE}  },
+   {100,    36000,  1, {832,   640, 56,  56,  509,  480, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
+
+   {100,    35500,  1, {936,   720, 36,  72,  446,  400, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
+
+
+
+   {100,    36000,  1, {1024,  800, 24,  72,  625,  600, 1,  2,  56, SCANTYPE_PROGRESSIVE}  },
+
+
+   {100,    38250,  1, {1024,  800, 32,  80,  624,  600, 3,  4,  60, SCANTYPE_PROGRESSIVE}  },
+   {100,    50000,  1, {1040,  800, 56, 120,  666,  600, 37, 6,  72, SCANTYPE_PROGRESSIVE}  },
+   {100,    49000,  1, {1040,  800, 40,  80,  629,  600, 3,  4,  75, SCANTYPE_PROGRESSIVE}  },
+   {100,    56750,  1, {1056,  800, 48,  80,  633,  600, 3,  4,  85, SCANTYPE_PROGRESSIVE}  },
+
+
+   {100,    65000,  1, {1344, 1024, 24, 136,  806,  768, 3,  6,  60, SCANTYPE_PROGRESSIVE}  },
+   {100,    75000,  1, {1328, 1024, 24, 136,  806,  768, 3,  6,  70, SCANTYPE_PROGRESSIVE}  },
+   {100,    78750,  1, {1312, 1024, 16,  96,  800,  768, 1,  3,  75, SCANTYPE_PROGRESSIVE}  },
+
+   {100,    94500,  1, {1376, 1024, 48,  96,  808,  768, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
+
+
+   {100,   108000,  1, {1600, 1152, 64, 128,  900,  864, 1,  2,  75, SCANTYPE_PROGRESSIVE}  },
+
+
+   {100,    79500,  1, {1664, 1280, 64, 128,  798,  768, 3,  7,  60, SCANTYPE_PROGRESSIVE}  },
+   {100,   102250,  1, {1696, 1280, 80, 128,  805,  768, 3,  7,  75, SCANTYPE_PROGRESSIVE}  },
+   {100,   117500,  1, {1712, 1280, 80, 136,  809,  768, 3,  7,  85, SCANTYPE_PROGRESSIVE}  },
+
+
+   {100,   108000,  1, {1800, 1280, 96, 112, 1000,  960, 1,  3,  60, SCANTYPE_PROGRESSIVE}  },
+   {100,   148500,  1, {1728, 1280, 64, 160, 1011,  960, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
+
+
+   {100,   108000,  1, {1688, 1280, 48, 112, 1066, 1024, 1,  3,  60, SCANTYPE_PROGRESSIVE}  },
+   {100,   135000,  1, {1688, 1280, 16, 144, 1066, 1024, 1,  3,  75, SCANTYPE_PROGRESSIVE}  },
+   {100,   157500,  1, {1728, 1280, 64, 160, 1072, 1024, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
+
+
+   {100,    85500,	1, {1792, 1360,	64, 112,  795,  768, 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
+
+
+   {100,   121750,	1, {1864, 1400,	88,144,1089,  1050,	 3,	 4,  60, SCANTYPE_PROGRESSIVE}	},
+   {100,   156000,	1, {1896, 1400,104,144,1099,  1050,	 3,	 4,  75, SCANTYPE_PROGRESSIVE}	},
+
+
+   {100,	88750,	1, {1600, 1440,	48,	32,	 926,  900,	 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
+
+
+   {100,   119000,	1, {1840, 1440,	48,	32,	 1080, 1050, 3,	 6,  60, SCANTYPE_PROGRESSIVE}	},
+
+
+   {100,   117936,	1, {2256, 1600,104,	184, 1250,  900, 1,	 3,  60, SCANTYPE_PROGRESSIVE}	},
+
+
+   {100,   162000,  1, {2160, 1600, 64, 192, 1250, 1200, 1,  3,  60, SCANTYPE_PROGRESSIVE}  },
+
+
+
+   {100,   148500, 1, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 60, SCANTYPE_PROGRESSIVE} },
+
+
+
+};
+
+
+
+
+
+uint8 I2CRead(DEV_CONTEXT* pDevContext,uint8 index)
+{
+
+	ch7036_device_context_t *p_ctx= pDevContext->pd_context;
+	pd_reg_t reg_list[2];
+
+	reg_list[0].reg = (i2c_reg_t)index;
+	reg_list[1].reg = PD_REG_LIST_END;
+
+	p_ctx->p_callback->read_regs(p_ctx->p_callback->callback_context, reg_list,PD_REG_DDC);
+
+	return (uint8)(reg_list[0].value);
+}
+
+void I2CWrite(DEV_CONTEXT* pDevContext,uint8 index, uint8 value)
+{
+	ch7036_device_context_t *p_ctx= pDevContext->pd_context;
+	pd_reg_t reg_list[2];
+
+
+
+	reg_list[0].reg = (i2c_reg_t)index;
+	reg_list[0].value = (i2c_reg_t)value;
+
+	reg_list[1].reg = PD_REG_LIST_END;
+
+	p_ctx->p_callback->write_regs(p_ctx->p_callback->callback_context, reg_list,PD_REG_DDC);
+
+	return;
+}
+
+
+void I2CBlockWrite(DEV_CONTEXT* pDevContext,uint8 index, uint8* value, uint16 len)
+{
+	ch7036_device_context_t *p_ctx= pDevContext->pd_context;
+	pd_reg_t reg_list[MAX_I2C_BLOCK_SIZE +1];
+	uint16 i=0;
+
+
+	for(i=0;i<len;i++) {
+		reg_list[i].reg = (i2c_reg_t)index;
+		reg_list[i].value = (i2c_reg_t)value[i];
+	}
+
+	reg_list[len].reg = PD_REG_LIST_END;
+
+	p_ctx->p_callback->write_regs(p_ctx->p_callback->callback_context, reg_list,PD_REG_DDC);
+
+	return;
+}
+
+ch7036_status_t ch7036_device_prepare(ch7036_device_context_t* p_ctx)
+{
+	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
+	ch7036_status_t status = SS_SUCCESS;
+
+	PD_DEBUG("ch7036_intf: ch7036_device_prepare()\n");
+
+
+	if(!DevicePrepare(p_ch_ctx))
+	{
+		p_ctx->last_emsg = GetLastErrorMessage();
+		status = SS_UNSUCCESSFUL;
+	}
+
+	return status;
+}
+
+ch7036_status_t ch7036_device_config(ch7036_device_context_t* p_ctx)
+{
+	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
+	ch7036_status_t status = SS_SUCCESS;
+
+	PD_DEBUG("ch7036_intf: ch7036_device_config()\n");
+
+
+	if(!DeviceConfig(p_ch_ctx))
+	{
+		p_ctx->last_emsg = GetLastErrorMessage();
+		status = SS_UNSUCCESSFUL;
+	}
+
+	return status;
+
+}
+
+ch7036_status_t ch7036_device_start(ch7036_device_context_t* p_ctx)
+{
+
+	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
+	ch7036_status_t status = SS_SUCCESS;
+
+	PD_DEBUG("ch7036_intf: ch7036_device_start()\n");
+
+	if(!DeviceRunning(p_ch_ctx))
+	{
+		p_ctx->last_emsg = GetLastErrorMessage();
+		status = SS_UNSUCCESSFUL;
+	}
+
+	return status;
+
+}
+
+ch7036_status_t ch7036_device_set_power(ch7036_device_context_t* p_ctx, unsigned long channel)
+{
+	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
+	ch7036_status_t status = SS_SUCCESS;
+
+	PD_DEBUG("ch7036_intf: ch7036_device_set_power()- channel [%x]\n", channel);
+
+	if(!DeviceSetPower(p_ch_ctx,channel))
+	{
+		p_ctx->last_emsg = GetLastErrorMessage();
+		status = SS_UNSUCCESSFUL;
+	}
+
+	return status;
+}
+
+
+
+ch7036_status_t ch7036_load_firmware(ch7036_device_context_t* p_ctx)
+{
+
+	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
+
+	ch7036_status_t status = SS_UNSUCCESSFUL;
+
+	PD_DEBUG("ch7036: ch7036_load_firmware()\n");
+
+
+	if(LHFM_load_firmware(p_ch_ctx) == -1) {
+		PD_DEBUG("ch7036_load_firmware: LHFM_load_firmware()- firmware loading FAILED...\n");
+
+	}
+	else  {
+		PD_DEBUG("ch7036_load_firmware: LHFM_load_firmware()- firmware loading is a SUCCESS\n");
+		status = SS_SUCCESS;
+	}
+
+
+	return status;
+
+}
+
+
+
+
+
+
+ch7036_status_t ch7036_get_hdvi_display_modes_supported(ch7036_device_context_t* p_ctx)
+{
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	ch7036_status_t status;
+	ch7036_edid_blk_t* p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
+
+
+	PD_DEBUG("ch7036_get_hdvi_display_modes_supported()- enter\n");
+
+	status = LHFM_get_hdmi_modeinfo(p_ch7xxx_context,p_hedid->supported_modes);
+
+	if (status == SS_SUCCESS) {
+
+		PD_DEBUG("HDMI_Modes=%02X. Vesa_Modes=%02x\r\n", p_hedid->supported_modes[13], p_hedid->supported_modes[14]);
+
+
+	}
+	else {
+		PD_DEBUG("ch7036_get_hdvi_display_modes_supported()-- failed!\r\n");
+		PD_DEBUG("status: [%s]\n",status == SS_FIRMWARE_TIMEOUT?"timeout!":"firmware_error!");
+
+
+	}
+
+	return status;
+}
+
+
+
+ch7036_status_t ch7036_read_edid(ch7036_device_context_t* p_ctx, uint32 channel)
+{
+
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+	ch7036_status_t status = SS_UNSUCCESSFUL;
+
 #ifdef T_CH7036_EDID_DUMP
-	uint8 ebn;
+	uint8 ebn;
 	int i;
-#endif
-
-	ch7036_edid_blk_t* p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
-	ch7036_edid_blk_t* p_cedid = (ch7036_edid_blk_t *)p_ctx->cedid;
-
-
-	unsigned char* hedidblk = p_hedid->edidblk;
-	unsigned char* cedidblk = p_cedid->edidblk;
-
-
-
-	switch (channel) {
-
-		case CHANNEL_LVDS_HDMI:
-		case CHANNEL_HDMI:
-
-			
-			status = LHFM_get_edid(p_ch7xxx_context,hedidblk, &(p_hedid->ebn), CH7036_HDMI_DDC);
-
-			if(status == SS_SUCCESS) {	
-			
-				PD_DEBUG("ch7036_read_edid()-hdmi-dvi hpd status- attached, hdmi-dvi edid read is a SUCCESS\n");
-				PD_DEBUG("ch7036_read_edid()- number of blocks read [%x]\n", p_hedid->ebn);
-			
-				p_hedid->is_edid = 1;
-				if(p_hedid->ebn == 1)  
-					pOutput_Info->hdmi_fmt.is_dvi_mode =1;
-							
-				else 
-					pOutput_Info->hdmi_fmt.is_dvi_mode =0;
-				
-
-		
+#endif
+
+	ch7036_edid_blk_t* p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
+	ch7036_edid_blk_t* p_cedid = (ch7036_edid_blk_t *)p_ctx->cedid;
+
+
+	unsigned char* hedidblk = p_hedid->edidblk;
+	unsigned char* cedidblk = p_cedid->edidblk;
+
+
+
+	switch (channel) {
+
+		case CHANNEL_LVDS_HDMI:
+		case CHANNEL_HDMI:
+
+
+			status = LHFM_get_edid(p_ch7xxx_context,hedidblk, &(p_hedid->ebn), CH7036_HDMI_DDC);
+
+			if(status == SS_SUCCESS) {
+
+				PD_DEBUG("ch7036_read_edid()-hdmi-dvi hpd status- attached, hdmi-dvi edid read is a SUCCESS\n");
+				PD_DEBUG("ch7036_read_edid()- number of blocks read [%x]\n", p_hedid->ebn);
+
+				p_hedid->is_edid = 1;
+				if(p_hedid->ebn == 1)
+					pOutput_Info->hdmi_fmt.is_dvi_mode =1;
+
+				else
+					pOutput_Info->hdmi_fmt.is_dvi_mode =0;
+
+
+
+#ifdef T_CH7036_EDID_DUMP
+
+				if (p_hedid->ebn <= MAX_EDID_BLOCKS) {
+					for (i=0; i<p_hedid->ebn; i++)
+						ch7036_dump("HDMI-DVI EDID Data", 128, &hedidblk[i*128]);
+
+				}
+
+#endif
+
+			}
+
+			else {
+				p_hedid->is_edid = 0;
+
+				status = SS_UNSUCCESSFUL;
+
+			}
+
+			break;
+
+		case CHANNEL_LVDS_VGA:
+		case CHANNEL_VGA:
+
+			I2CWrite(p_ch7xxx_context,0x03, 0x01);
+			I2CWrite(p_ch7xxx_context,0x0F, I2CRead(p_ch7xxx_context,0x0F) & 0x7F);
+			pd_usleep(200);
+
+			status = LHFM_get_edid(p_ch7xxx_context,cedidblk, &(p_cedid->ebn), CH7036_VGA_DDC);
+			if (status== SS_SUCCESS) {
+				p_cedid->is_edid =1;
+				PD_DEBUG("ch7036_read_edid()- crt hpd status- attached, crt edid read is a SUCCESS\n");
+				PD_DEBUG("ch7036_read_edid()- number of blocks read [%x]\n", p_cedid->ebn);
+
 #ifdef T_CH7036_EDID_DUMP
-	
-				if (p_hedid->ebn <= MAX_EDID_BLOCKS) { 
-					for (i=0; i<p_hedid->ebn; i++) 
-						ch7036_dump("HDMI-DVI EDID Data", 128, &hedidblk[i*128]);
-								
-				}
-
-#endif
-
-			} 
-
-			else { 
-				p_hedid->is_edid = 0;
-				
-				status = SS_UNSUCCESSFUL;
-
-			}	
-
-			break;
-
-		case CHANNEL_LVDS_VGA:
-		case CHANNEL_VGA:
-			
-			I2CWrite(p_ch7xxx_context,0x03, 0x01);			
-			I2CWrite(p_ch7xxx_context,0x0F, I2CRead(p_ch7xxx_context,0x0F) & 0x7F);		
-			pd_usleep(200);
-
-			status = LHFM_get_edid(p_ch7xxx_context,cedidblk, &(p_cedid->ebn), CH7036_VGA_DDC);
-			if (status== SS_SUCCESS) {
-				p_cedid->is_edid =1;
-				PD_DEBUG("ch7036_read_edid()- crt hpd status- attached, crt edid read is a SUCCESS\n");
-				PD_DEBUG("ch7036_read_edid()- number of blocks read [%x]\n", p_cedid->ebn);
-
-#ifdef T_CH7036_EDID_DUMP
-				if (p_cedid->ebn <= MAX_EDID_BLOCKS) 
-					for (i=0; i<p_cedid->ebn; i++) 
-						ch7036_dump("VGA EDID Data", 128, &cedidblk[i*128]);
-
-
-#endif
-
-			}
-			else {
-				p_cedid->is_edid =0;
-					
-				status = SS_UNSUCCESSFUL;
-			}
-
-	
-			break;
-
-		default:
-			break;
-
-
-	} 
-
-
-	return status;
-}
-
-ch7036_status_t ch7036_get_hdmi_hpd(ch7036_device_context_t* p_ctx, uint8 *hpd)
-{
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	ch7036_status_t status= SS_SUCCESS;
-	unsigned char reg, reg_hpdpw;
-
-	I2CWrite(p_ch7xxx_context,0x03, 0x03);
-	reg = I2CRead(p_ch7xxx_context,0x25);
-
-	I2CWrite(p_ch7xxx_context,0x03, 0x04);
-	reg_hpdpw = I2CRead(p_ch7xxx_context,0x51);
-
-#ifdef T_CONFIG_PLB	
-	if(!(reg & 0x10) && (reg_hpdpw & 0x80) ){
-		reg= 0x10;
-	}
-#endif
-
-	switch (reg & 0x10) {
-		case 0x10:
-			if(p_ctx->hpd & CH7036HPD_HDVI_ATTACHED)
-				*hpd = 0x01;
-			else
-				*hpd = 0x81;
-			break;
-		case 0x00:
-			if(p_ctx->hpd & CH7036HPD_HDVI_ATTACHED)
-				*hpd = 0x80;
-			else
-				*hpd = 0x00;
-			break;
-	}
-	
-
-	PD_DEBUG("ch7036: ch7036_get_hdmi_hpd- exit...*hpd [0x%x]\n",*hpd);
-
-	return status;
-
-}
-ch7036_status_t ch7036_get_attached_device(ch7036_device_context_t* p_ctx)
-{
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
-	uint8 reg;
+				if (p_cedid->ebn <= MAX_EDID_BLOCKS)
+					for (i=0; i<p_cedid->ebn; i++)
+						ch7036_dump("VGA EDID Data", 128, &cedidblk[i*128]);
+
+
+#endif
+
+			}
+			else {
+				p_cedid->is_edid =0;
+
+				status = SS_UNSUCCESSFUL;
+			}
+
+
+			break;
+
+		default:
+			break;
+
+
+	}
+
+
+	return status;
+}
+
+ch7036_status_t ch7036_get_hdmi_hpd(ch7036_device_context_t* p_ctx, uint8 *hpd)
+{
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	ch7036_status_t status= SS_SUCCESS;
+	unsigned char reg, reg_hpdpw;
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x03);
+	reg = I2CRead(p_ch7xxx_context,0x25);
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x04);
+	reg_hpdpw = I2CRead(p_ch7xxx_context,0x51);
+
+#ifdef T_CONFIG_PLB
+	if(!(reg & 0x10) && (reg_hpdpw & 0x80) ){
+		reg= 0x10;
+	}
+#endif
+
+	switch (reg & 0x10) {
+		case 0x10:
+			if(p_ctx->hpd & CH7036HPD_HDVI_ATTACHED)
+				*hpd = 0x01;
+			else
+				*hpd = 0x81;
+			break;
+		case 0x00:
+			if(p_ctx->hpd & CH7036HPD_HDVI_ATTACHED)
+				*hpd = 0x80;
+			else
+				*hpd = 0x00;
+			break;
+	}
+
+
+	PD_DEBUG("ch7036: ch7036_get_hdmi_hpd- exit...*hpd [0x%x]\n",*hpd);
+
+	return status;
+
+}
+ch7036_status_t ch7036_get_attached_device(ch7036_device_context_t* p_ctx)
+{
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+	uint8 reg;
 	ch7036_status_t status = SS_SUCCESS;
-	ch7036_status_t status_hdmi, status_crt;
-
-	ch7036_edid_blk_t * p_hedid = (ch7036_edid_blk_t *)(p_ctx->hedid);
-
-	uint8 hpd = 0;
-
-
-	
-	I2CWrite(p_ch7xxx_context,0x03, 0x04);
-	reg = I2CRead(p_ch7xxx_context,0x52);
-	
-	reg = reg & 0xEF; 
-	I2CWrite(p_ch7xxx_context,0x52, reg);
-
-	
-	I2CWrite(p_ch7xxx_context,0x03, 0x0);
-	reg = I2CRead(p_ch7xxx_context,0x07);
-	
-	reg = reg & 0x70; 
-	I2CWrite(p_ch7xxx_context,0x07, reg);
-	
-	I2CWrite(p_ch7xxx_context,0x03, 0x01);
-	reg = I2CRead(p_ch7xxx_context,0x0F);
-	
-	reg = reg & 0x7F; 	
-	I2CWrite(p_ch7xxx_context,0x0F, reg); 
-
-	I2CWrite(p_ch7xxx_context,0x0E, I2CRead(p_ch7xxx_context,0x0E) & 0x7F);
-		
-	PD_DEBUG("ch7036_get_attached_device()- enter- p_ctx->hpd= [0x%x]\n", p_ctx->hpd);
-
-	status_hdmi = ch7036_get_hdmi_hpd(p_ctx,&hpd);
-	LHFM_enable_crt_hpd(p_ch7xxx_context);  
-	status_crt = LHFM_get_crt_hpd(p_ch7xxx_context);
-
-	PD_DEBUG("ch7036_get_attached_device()- enter- pOutput_Info->channel = [0x%x]\n", pOutput_Info->channel);
-	
-	if(p_ctx->man_sel_out==1) { //manual selection
-
-		
-		if( (status_crt == SS_SUCCESS) || ( (hpd & 0x01)== 1 ) ) { 
-
-			switch (pOutput_Info->channel) {				
-				case CHANNEL_LVDS_DVI: 
-				case CHANNEL_DVI: 
-				case CHANNEL_LVDS_HDMI:
-				case CHANNEL_HDMI: 
-
-					 
-					if( (status_crt == SS_SUCCESS) && ( (hpd & 0x01)== 0 ) ) { 
-
-						p_ctx->hpd = 0x16; //bit 4=1 to indicate SS_DISPLAY_CHOICE_NOT_ALLOWED,  check edid and parse it												
-						status = SS_DISPLAY_CHOICE_NOT_ALLOWED;
-
-					}
-					else {
-
-						if (!p_ctx->init_done || ((p_ctx->prev_outchannel & pOutput_Info->channel) & 0x02) != 0x02 ) 
-							p_ctx->hpd = 0x60;
-						else 
-							p_ctx->hpd = ( ((p_ctx->prev_outchannel & pOutput_Info->channel) & 0x02) == 0x02)?0xA0:0x60;							
-											
-						status = SS_SUCCESS;
-					}
-										
-					break;
-
-				case CHANNEL_LVDS_VGA: 
-				case CHANNEL_VGA:
-					
-					
-					if((status_crt != SS_SUCCESS) && ((hpd & 0x01)==1 ) ) { 
-						
-						if(!p_ctx->init_done) { 
-							p_ctx->hpd = 0x06; 
-							status = SS_SUCCESS;
-							
-						}else {					
-							p_ctx->hpd = (hpd & 0x80)?0x70:0x30; 
-							status = SS_DISPLAY_CHOICE_NOT_ALLOWED;
-						}
-						
-					}
-					else { 
-
-						if ( (!p_ctx->init_done) || ((p_ctx->prev_outchannel & pOutput_Info->channel) & 0x04) != 0x04 )//at init, need to read edid, and parse it
-							p_ctx->hpd = 0x06;
-						else {							
-							p_ctx->hpd = ( ((p_ctx->prev_outchannel & pOutput_Info->channel) & 0x04) == 0x04)?0x0A:0x06;
-													
-						}
-
-						status = SS_SUCCESS;
-					}
-															
-					break;
-			} //switch
-
-			if(status == SS_DISPLAY_CHOICE_NOT_ALLOWED)
-				PD_DEBUG("ch7036_get_attached_device()- manual selection- display choice is not allowed...\n");
-
-		}
-		else {
-			
-			if (!p_ctx->init_done) { 
-				p_ctx->hpd = 0x06; 
-				status = SS_SUCCESS;
-				
-			}else {
-
-				PD_DEBUG("ch7036_get_attached_device()- manual selection- none is connected- not allowed...\n");
-				
-				status = SS_DISPLAY_CHOICE_NOT_ALLOWED;
-				p_ctx->hpd = 0x50;
-
-			}
-
-
-		}
-
-		PD_DEBUG("ch7036_get_attached_device()- manual selection- exit- p_ctx->hpd= [0x%x]\n", p_ctx->hpd);
-		PD_DEBUG("ch7036_get_attached_device()- exit- pOutput_Info->channel = [0x%x]\n", pOutput_Info->channel);
-
-		I2CWrite(p_ch7xxx_context,0x03, 0x03);
-		reg = I2CRead(p_ch7xxx_context,0x25);
-
-		PD_DEBUG("ch7036_get_attached_device()- manual selection- exit...HPD_MCU [0x%x]\n",reg);
-
-		return status;
-	}
-
-	//auto detection 
-
-	if(status_hdmi == SS_SUCCESS) { 
-			
-			if( hpd == 0x81 ) { 
-				if(p_ctx->hpd & CH7036HPD_HDVI_ATTACHED)  {
-
-					p_ctx->hpd = (p_ctx->hpd  & 0x9F) & ((~CH7036HPD_HDVI_STATUS_CHANGED) | CH7036HPD_HDVI_ATTACHED); 
-										
-					ch7036_get_hdvi_display_modes_supported(p_ctx);
-				
-					if ( 
-						((pOutput_Info->hdmi_fmt.is_dvi_mode== 0) && (p_hedid->supported_modes[13] == 0) )||
-						((pOutput_Info->hdmi_fmt.is_dvi_mode== 1) && (p_hedid->supported_modes[13] > 0))
-					) {
-
-						p_ctx->hpd = (p_ctx->hpd  & 0x9F) | (CH7036HPD_HDVI_STATUS_CHANGED | CH7036HPD_HDVI_ATTACHED);
-						PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status changed [HDMI<->DVI] since last query and it's HIGH\n");
-
-					}
-					else					
-						PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status has not changed since last query and it's HIGH\n"); 
-				}
-				else {
-
-
-					p_ctx->hpd = (p_ctx->hpd  & 0x9F) | (CH7036HPD_HDVI_STATUS_CHANGED | CH7036HPD_HDVI_ATTACHED);
-					PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status changed since last query and it's HIGH\n");
-				}
-			}
-			else if (hpd ==0x80) {	
-				if( (p_ctx->hpd & CH7036HPD_HDVI_ATTACHED) ==0 )  {
-
-					p_ctx->hpd = (p_ctx->hpd  & 0x9F) & ((~ CH7036HPD_HDVI_STATUS_CHANGED) & (~CH7036HPD_HDVI_ATTACHED)) ;
-					PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status not changed since last query and it's LOW\n");
-				}
-				else {
-
-					p_ctx->hpd = (p_ctx->hpd  & 0x9F) | (CH7036HPD_HDVI_STATUS_CHANGED & (~CH7036HPD_HDVI_ATTACHED)) ;
-					PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status changed since last query and it's LOW\n");
-				}
-		
-			}
-			else if (hpd == 0x01) {
-
-				p_ctx->hpd = (p_ctx->hpd  & 0x9F) & ((~CH7036HPD_HDVI_STATUS_CHANGED) | CH7036HPD_HDVI_ATTACHED);
-				PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status has not changed since last query and it's HIGH\n");
-			}
-			else { 
-
-				p_ctx->hpd &= 0x9F; 
-				PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status has not changed since last query and it's LOW\n");
-			}
-			
-
-			
-			PD_DEBUG("ch7036: ch7036_get_attached_device()- SUCCESS- hdmi hpd [0x%x]\n", hpd);
-			
-	}
-	else {
-
-		
-		if ( (!p_ctx->init_done) &&  (hpd == 0x86) )  {
-
-			p_ctx->hpd |= CH7036HPD_HDVI_ATTACHED;
-							
-		}
-
-		else {
-			p_ctx->hpd &= ~CH7036HPD_HDVI_ATTACHED;
-			
-		}
-		
-	}
-
-	if(status_crt == SS_SUCCESS) {  
-		
-		if( (p_ctx->hpd & CH7036HPD_CRT_ATTACHED )== CH7036HPD_CRT_ATTACHED)  
-			p_ctx->hpd = (p_ctx->hpd  & 0xF9) & ((~CH7036HPD_CRT_STATUS_CHANGED)  | CH7036HPD_CRT_ATTACHED);
-					
-		else 
-			p_ctx->hpd = ((p_ctx->hpd  & 0xF9) | ( CH7036HPD_CRT_STATUS_CHANGED | CH7036HPD_CRT_ATTACHED));
-									
-	} 
-	else  {  
-		
-		if( (p_ctx->hpd & CH7036HPD_CRT_ATTACHED ) == 0 ) { 
-			p_ctx->hpd &= 0xF9; 
-
-			if( (p_ctx->hpd & CH7036HPD_HDVI_ATTACHED)== 0  ) 
-				p_ctx->hpd |= 0x06; 
-										
-		}
-		else  {
-			
-			if ( (p_ctx->hpd & CH7036HPD_HDVI_ATTACHED) ==0 )
-				p_ctx->hpd &= 0xFB; 
-			else
-				p_ctx->hpd = (p_ctx->hpd & 0xF9) |  CH7036HPD_CRT_STATUS_CHANGED;		
-		}
-			
-	}
-
-	PD_DEBUG("ch7036_get_attached_device()- auto detection - exit- p_ctx->hpd= [0x%x]\n", p_ctx->hpd);	
-	return SS_SUCCESS;
-}
-
-
-void ch7036_reset(ch7036_device_context_t* p_ctx)
-{
-	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
-
-	ch7036_reset_mcu(p_ch_ctx); 
-	ch7036_reset_datapath(p_ch_ctx);
-
-	return;
-}
-
-void ch7036_reset_datapath(DEV_CONTEXT* p_ch_ctx)
-{
-
-	PD_DEBUG("ch7036: ch7036_reset_datapath()-enter\n");
-    I2CWrite(p_ch_ctx,0x03, 0x04); 
-	I2CWrite(p_ch_ctx,0x52, 0x2E);
-	
-	pd_usleep(50); 
-	I2CWrite(p_ch_ctx,0x52, 0x2F);
-	
-	return;
-}
-
-void ch7036_reset_mcu(DEV_CONTEXT* p_ch_ctx)
-{
-
-	PD_DEBUG("ch7036: ch7036_reset_mcu()-enter\n");
-
-    I2CWrite(p_ch_ctx,0x03, 0x04);
-	I2CWrite(p_ch_ctx,0x52, 0x2B);
-	
-	pd_usleep(50); 	
-	I2CWrite(p_ch_ctx,0x52, 0x2F);
-	
-	
-	PD_DEBUG("ch7036: ch7036_reset_mcu()-exit-\n");
-	return;
-}
-
-
-
-
-
-void ch7036_set_input_timing_info(ch7036_device_context_t *p_ctx, INPUT_INFO* pInput_Info)
-{
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
-
-	pd_timing_t * p_current_mode = &(p_ctx->native_dtd);
-	uint8 audio_id = AUDIO_SPDIF;
-	PD_DEBUG("ch7036_intf: ch7036_set_input_timing_info()-\n");
-
-	
-	if (p_ctx->init_done) { 
-
-	
-		pInput_Info->timing.ht = p_current_mode->htotal+1;
-	
-		pInput_Info->timing.ha = p_current_mode->width;
-		pInput_Info->timing.ho = p_current_mode->hsync_start - p_current_mode->hblank_start;
-		pInput_Info->timing.hw = p_current_mode->hsync_end - p_current_mode->hsync_start;
-		pInput_Info->timing.vt = p_current_mode->vtotal+1;
-	
-		pInput_Info->timing.va = p_current_mode->height;
-		pInput_Info->timing.vo = p_current_mode->vsync_start - p_current_mode->vblank_start;
-		pInput_Info->timing.vw = p_current_mode->vsync_end - p_current_mode->vsync_start;
-
-	
-		pInput_Info->rx_clk_khz = p_current_mode->dclk; 
-
-		
-		pInput_Info->hs_pol = ((uint8)(((p_current_mode)->mode_info_flags & PD_HSYNC_HIGH) >> 24 ))?1:0;  
-		pInput_Info->vs_pol = ((uint8)(((p_current_mode)->mode_info_flags & PD_VSYNC_HIGH) >> 24))?1:0; 
-
-	}
-
-
-	
-	
-	
-	pInput_Info->pixel_fmt = ((lvds_context_t *)p_ctx->internal_lvds)->panel_depth == 18?PIXEL_FMT_18BIT:3; 
-
-	
-	pInput_Info->data_ch_pol = POL_NO_INV;
-
-	
-	pInput_Info->data_ch_invert = POL_NO_INV;
-
-	
-
-	
-
-	pInput_Info->de_pol = POL_HIGH;  
-	
-	
-	
-	
-	
-	if(pOutput_Info->channel & CHANNEL_HDMI)
-		ch7036_set_audio_type(pInput_Info, audio_id);
-	
-}
-
-void ch7036_set_output_timing_info(ch7036_device_context_t *p_ctx, OUTPUT_INFO* pOutput_Info)
-{
-
-
-	PD_DEBUG("ch7036: ch7036_set_output_timing_info()\n");
-		
-	
-	PD_DEBUG("ch7036_set_output_timing_info()- output channel from pd context[%u]\n",pOutput_Info->channel);
-
-	
-	pOutput_Info->lvds_fmt.channel_swap = LVDS_CHANNEL_SWAP_DEF; 
-	pOutput_Info->lvds_fmt.channel_pol = (POL_LOW << 4) | (POL_LOW << 3) | (POL_LOW << 2) | (POL_LOW << 1) | (POL_LOW << 0);
-	pOutput_Info->lvds_fmt.pixel_fmt = p_ctx->dither_select;
-
-	
-	
-	pOutput_Info->hdmi_fmt.channel_swap = 0;
-	pOutput_Info->hdmi_fmt.data_pol_invert = POL_NO_INV;
-	pOutput_Info->hdmi_fmt.protect_enable = 0;
-
-
-	
-	
-	if (pOutput_Info->channel & CHANNEL_HDMI) 
-	{
-		
-		if(!(pOutput_Info->hdmi_fmt.is_dvi_mode))
-		{
-			PD_DEBUG("ch7036_set_output_timing_info- hdmi mode index is [0x%x]\n",p_ctx->hdmi_mode_index);
-			pOutput_Info->hdmi_fmt.format_index = (uint8)hdmi_timing_table[p_ctx->hdmi_mode_index].fmt_index; 
-			pOutput_Info->hdmi_fmt.aspect_ratio = (uint8)hdmi_timing_table[p_ctx->hdmi_mode_index].aspect;
-
-			pOutput_Info->timing.ht = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.ht;
-			pOutput_Info->timing.ha = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.ha;
-			pOutput_Info->timing.ho = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.ho;
-			pOutput_Info->timing.hw = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.hw;
-			pOutput_Info->timing.vt = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.vt;
-			pOutput_Info->timing.va = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.va;
-			pOutput_Info->timing.vo = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.vo;
-			pOutput_Info->timing.vw = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.vw;
-			pOutput_Info->uclk_khz = hdmi_timing_table[p_ctx->hdmi_mode_index].clk_freq;
-		}
-		else 
-		{
-			pOutput_Info->hdmi_fmt.format_index = (uint8)dvi_timing_table[p_ctx->dvi_mode_index].fmt_index; 
-			pOutput_Info->hdmi_fmt.aspect_ratio = (uint8)dvi_timing_table[p_ctx->dvi_mode_index].aspect;
-
-			pOutput_Info->timing.ht = dvi_timing_table[p_ctx->dvi_mode_index].timing.ht;
-			pOutput_Info->timing.ha = dvi_timing_table[p_ctx->dvi_mode_index].timing.ha;
-			pOutput_Info->timing.ho = dvi_timing_table[p_ctx->dvi_mode_index].timing.ho;
-			pOutput_Info->timing.hw = dvi_timing_table[p_ctx->dvi_mode_index].timing.hw;
-			pOutput_Info->timing.vt = dvi_timing_table[p_ctx->dvi_mode_index].timing.vt;
-			pOutput_Info->timing.va = dvi_timing_table[p_ctx->dvi_mode_index].timing.va;
-			pOutput_Info->timing.vo = dvi_timing_table[p_ctx->dvi_mode_index].timing.vo;
-			pOutput_Info->timing.vw = dvi_timing_table[p_ctx->dvi_mode_index].timing.vw;
-			pOutput_Info->uclk_khz = dvi_timing_table[p_ctx->dvi_mode_index].clk_freq;
-
-		}
-
-
-
-	} else if((pOutput_Info->channel & CHANNEL_VGA) && ((pOutput_Info->channel & CHANNEL_HDMI)==0x00) ) 
-	{
-		
-		
-		
-		PD_DEBUG("ch7036_set_output_timing_info- crt mode index is [0x%x]\n",p_ctx->crt_mode_index);
-		pOutput_Info->timing.ht = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.ht;
-		pOutput_Info->timing.ha = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.ha;
-		pOutput_Info->timing.ho = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.ho;
-		pOutput_Info->timing.hw = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.hw;
-		pOutput_Info->timing.vt = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.vt;
-		pOutput_Info->timing.va = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.va;
-		pOutput_Info->timing.vo = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.vo;
-		pOutput_Info->timing.vw = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.vw;
-		pOutput_Info->uclk_khz = ch7036_crt_timing_table[p_ctx->crt_mode_index].clk_freq;
-
-		
-	} else
-		; 
-
-	
-	if(pOutput_Info->channel & CHANNEL_HDMI)
-		ch7036_set_hdmi_sync_polarity(pOutput_Info);
-
-	if(pOutput_Info->channel & CHANNEL_HDMI || pOutput_Info->channel & CHANNEL_VGA) {
-		
-		ch7036_set_rotate (pOutput_Info);
-		ch7036_set_hflip (pOutput_Info);
-		ch7036_set_vflip (pOutput_Info);
-	}
-}
-
-void ch7036_set_prefer_timing_info(ch7036_device_context_t *p_ctx, PREFER_INFO* pPrefer_Info)
-{
-	
-	
-	
-
-	PD_DEBUG("ch7036_intf: ch7036_set_prefer_timing_info()\n");
-
-	
-	if (!p_ctx->init_done) {
-
-	pPrefer_Info->mclk_khz = 166000; 
-	pPrefer_Info->uclkod_sel = 1;
-	pPrefer_Info->dat16_32b = 0;
-	pPrefer_Info->true24 = 0;
-	pPrefer_Info->true_com = 0;
-	pPrefer_Info->lvds_out_hs_tolerance = HS_TOLERANCE_LEVEL0;
-	pPrefer_Info->lvds_out_reset_bit_sel = RST_BIT_VSYNC;
-	pPrefer_Info->dither_filter_enable = DITHER_ENABLE;  
-		
-	pPrefer_Info->hscale_ratio_gate = 130;	
-	pPrefer_Info->reset=0; 
-	pPrefer_Info->vga_enable=0;
-
-	pPrefer_Info->text_enhancement = DEFAULT_TEXT_ENHANCE; 
-	pPrefer_Info->pll_ref_dly = DEF_PLL_REF_DLY;
-	pPrefer_Info->pll_ref_fbdly = DEF_PLL_REF_FBDLY;
-	pPrefer_Info->lvds_txdrv_ctrl = DEF_LVDS_TXDRV_CTRL;
-
-	pPrefer_Info->eye_bgtrim=0;
-	pPrefer_Info->eye_dacg=0;
-	pPrefer_Info->eye_dri_demp=0;
-	pPrefer_Info->eye_dri_pll_cp=0;
-	pPrefer_Info->eye_dri_damp=0;
-	pPrefer_Info->eye_dri_pll_rlf=0;
-	pPrefer_Info->eye_rdac=0;
-
-	}
-
-	pPrefer_Info->scale_line_adjust = 0;
-
-
-	
-}
-
-
-ch7036_status_t ch7036_parse_standard_edid(ch7036_device_context_t* p_ctx, uint32 channel)
-{
-	uint8 i, index = 0;
-	
-	ch7036_edid_blk_t* p_edid = (ch7036_edid_blk_t *)p_ctx->cedid;
-	unsigned char* p_edidblk = p_edid->edidblk;
-
-	
-	OUT_FMT* p_table = ch7036_crt_timing_table;
-	TIMING* p_timing;
-
-	unsigned char j=0;
-
-
-
-
-	
-	established_timings_t *p_etiming_I = p_edid->etiming_I;
-	established_timings_t *p_etiming_II = p_edid->etiming_II;
-
-
-	
-	standard_timings_t	*stiming = p_edid->stiming; 
-	ch7036_attr_table_index_t* p_modes =  p_edid->modes;
-
-	unsigned long idx = 2; 
-
-
-	PD_DEBUG("ch7036_parse_stardard_edid() channel [0x%x] - enter...\n", channel);
-
-
-	if(channel == CHANNEL_LVDS_HDMI) {
-
-		p_edid = (ch7036_edid_blk_t *)p_ctx->hedid;
-		p_edidblk = p_edid->edidblk;
-		p_etiming_I = p_edid->etiming_I;
-		p_etiming_II = p_edid->etiming_II;
-
-		stiming = p_edid->stiming; 
-		p_modes =  p_edid->modes;
-
-		
-		if (p_edid->ebn > 1) { 
-			idx = 1;
-			p_table = hdmi_timing_table;
-		}
-		else { 
-			idx = 0;
-			p_table = dvi_timing_table;
-			channel = 7; 
-		}
-
-
-	}
-
-	
-	while (index < MAX_ATTR_LIST_SIZE)
-		p_modes[index++] = FALSE; 
-
-
-	if (p_edidblk[EDID_EXTENSION_FLAG] == 0x00 ) {
-			
-
-		ch7036_parse_standard_timing(p_edid,0);
-
-		
-		ch7036_parse_established_timing(p_ctx, p_edid);
-		
-
-		
-		ch7036_parse_detailed_descriptor_blocks(p_ctx, p_edid);
-				
-
-		
-		for(i=0; i<8;i++) { 
-
-
-			index=0;
-			while (index < MAX_ATTR_LIST_SIZE ) {
-				if(p_modes[index]== TRUE) {
-					index++; 
-					continue;
-				}
-				p_timing = &(p_table[index].timing);
-
-				if ( (p_edid->dtblk[j]).data_tag & 0x00FFFFFF ) { 
-					OUT_FMT* p_dtd = &((p_edid->dtblk[j]).dtiming);
-					
-					if( (p_dtd->timing.ha == p_timing->ha) && (p_dtd->timing.va == p_timing->va) && (p_dtd->timing.hz >= p_timing->hz) ) {
-						p_modes[index] = TRUE;
-						j= j> 3?3:j+1;
-
-						PD_DEBUG("ch7036_parse_standard_edid()- detailed timing mode supported- index [%d] name [%s]...\n",index,ch7036_get_mode_name(channel,index) );
-
-					}
-
-				}
-							
-				
-				if( (stiming[i].ha == p_timing->ha) && (stiming[i].va == p_timing->va) && (stiming[i].refresh_rate >= p_timing->hz) ) {
-					p_modes[index] = TRUE;
-					PD_DEBUG("ch7036_parse_standard_edid()- std_timing mode supported- index [%d] name [%s]...\n",index,ch7036_get_mode_name(channel,index) );
-				}
-				
-				index++;
-
-			}
-
-		}
-
-		
-		for(i=0;i<4;i++) {
-			if ( (p_edid->dtblk[i]).data_tag == 0xFA000000) {
-				; 
-				continue;
-			}
-		}
-
-		
-
-		for(i=0; i<8;i++) { 
-
-			
-			
-			if( (p_etiming_I[i].is_supported == TRUE) && (p_etiming_I[i].index[idx] != OUT_CRT_END) ) {
-				p_modes[p_etiming_I[i].index[idx]] = TRUE; 
-				PD_DEBUG("ch7036_parse_standard_edid()- et1 mode supported- index [%d] name [%s]...\n",p_etiming_I[i].index[idx],p_etiming_I[i].mode_name);
-				continue;
-
-			}
-
-			
-			if( (i==7) && (channel ==7) && (p_etiming_I[i].is_supported == TRUE) ) {
-				p_modes[p_etiming_I[i].index[idx]] = TRUE; 
-				PD_DEBUG("ch7036_parse_standard_edid()- et1 mode supported- index [%d] name [%s]...\n",p_etiming_I[i].index[idx],p_etiming_I[i].mode_name);
-			}
-
-			
-		}
-
-		for(i=0; i<8;i++) { 
-		
-			if( (p_etiming_II[i].is_supported == TRUE) && (p_etiming_II[i].index[idx] != OUT_CRT_END) ) {
-				p_modes[p_etiming_II[i].index[idx]] = TRUE; 
-				PD_DEBUG("ch7036_parse_standard_edid()- et2 mode supported- index [%d] name [%s]...\n",p_etiming_II[i].index[idx],p_etiming_II[i].mode_name);
-				continue;
-
-			}
-
-		}
-
-		
-
-	}
-	else { 
-		PD_DEBUG("ch7036_parse_standard_edid()- vga/dvi has more than one 128 byte block\n");
-	}
-
-
-	PD_DEBUG("ch7036_parse_stardard_edid()-channel [0x%x] - exit...\n", channel);
-
-	return SS_SUCCESS;
-
-}
-
-void ch7036_parse_detailed_descriptor_blocks(ch7036_device_context_t* p_ctx, ch7036_edid_blk_t* p_edid)
-{
-	unsigned long *monitor_descriptor;
-	unsigned char* p_ebuf, *p_st;
-	unsigned char* p_edidblk = p_edid->edidblk;
-	unsigned char i;
-	OUT_FMT* p_dt;
-	
-
-	p_ebuf = &(p_edidblk[EDID_DETAILED_TIMING_DESCRIPTION_1]);
-
-	PD_DEBUG("parse_detailed_descriptor_blocks()- enter...\n");
-
-	for(i=0;i<4;i++) {
-
-		monitor_descriptor = (unsigned long *) p_ebuf;
-
-		if((*monitor_descriptor) & 0x00FFFFFF ) { 
-			
-			
-			p_dt = &(p_edid->dtblk[i].dtiming);				
-			ch7036_parse_detailed_timing(p_dt, p_ebuf);
-			
-		}
-			
-		else { 
-
-			p_st = p_ebuf;
-			p_st +=5;
-
-			switch (*monitor_descriptor) {
-				case 0xFA000000: 
-					ch7036_parse_standard_timing(p_edid,p_st); 
-					break;
-
-				case 0xFD000000: 
-					(p_edid->rtiming).vrate_min = *p_st; 
-					(p_edid->rtiming).vrate_max = *(p_st+1);
-					(p_edid->rtiming).hrate_min = *(p_st+2); 
-					(p_edid->rtiming).hrate_max = *(p_st+3); 
-					(p_edid->rtiming).pclk_max = (unsigned long)(*(p_st+4))*10000L;	
-					
-					
-					break;
-
-				case 0xFC000000: 
-				case 0xFF000000: 
-				default: 
-					break;
-			}
-		}
-
-		(p_edid->dtblk[i]).data_tag = *monitor_descriptor;
-
-		p_ebuf += 18;
-	}
-	
-	return;
-}
-
-void ch7036_parse_detailed_timing(OUT_FMT *p_dt, unsigned char* p_ebuf)
-{
-
-	unsigned short blanking;
-
-	PD_DEBUG("ch7036_parse_detailed_descriptor_timing()- enter...\n");
-
-
-	p_dt->clk_freq = ((uint32)(p_ebuf[1]<<8) | p_ebuf[0]) * 10; 
-
-	p_dt->timing.ha = ((uint16)(p_ebuf[4] & 0xF0) << 4) | p_ebuf[2];
-
-	PD_DEBUG("ch7036_parse_detailed_timing() byte 3 [%x] byte 5 [%x]\n",p_ebuf[2],p_ebuf[4]);
-
-	blanking = ((uint16)(p_ebuf[4] & 0x0F) << 8) | p_ebuf[3]; 
-	p_dt->timing.ht = p_dt->timing.ha + blanking;
-
-	p_dt->timing.va = ((uint16)(p_ebuf[7] & 0xF0) << 4) | p_ebuf[5];
-
-	PD_DEBUG("ch7036_parse_detailed_timing() byte 6 [%x] byte 8 [%x]\n",p_ebuf[5],p_ebuf[7]);
-
-	blanking = ((uint16)(p_ebuf[7] & 0x0F) << 8) | p_ebuf[6]; 
-	p_dt->timing.vt = p_dt->timing.va + blanking;
-
-	PD_DEBUG("ch7036_parse_detailed_timing()- pclk [%d] Khz ha [%d] va [%d] ht [%d] vt [%d]\n",p_dt->clk_freq,p_dt->timing.ha,p_dt->timing.va,p_dt->timing.ht,p_dt->timing.vt);
-
-	p_dt->timing.hz = 	(((p_dt->clk_freq / p_dt->timing.ht) + 1 ) * 1000) / p_dt->timing.vt; 
-
-	p_dt->timing.stype = (p_ebuf[17] & 0x80)?0:1; 
-
-	PD_DEBUG("ch7036_parse_detailed_timing()- refresh [%d] scantype [%d]\n",
-		p_dt->timing.hz,p_dt->timing.stype);
-
-	return;	
-}
-
-
-
-void ch7036_parse_standard_timing(ch7036_edid_blk_t* p_edid, unsigned char* p_addtional_st)
-{
-	standard_timings_t *stiming = p_edid->stiming;
-	unsigned char i, max=8;
-
-	unsigned char* p_edidblk = &(p_edid->edidblk[EDID_STANDARD_TIMINGS]);
-
-	
-	PD_DEBUG("ch7036_parse_standard_timing()- enter\n");
-	
-	if(p_addtional_st) {
-		p_edidblk = p_addtional_st;
-		stiming = p_edid->stiming_x;
-		max = 6;
-	}
-
-	for(i = 0; i < max; stiming++,i++) {
-			
-	
-		if( (*p_edidblk) == 0x01 &&  *(p_edidblk+1) == 0x01) 
-			continue;
-	
-		stiming->ha = ((*p_edidblk) + 31) << 3 ;
-		 
-		stiming->refresh_rate = (*(p_edidblk + 1) & 0x3F) + 60;
-
-		switch(*(p_edidblk +1) >> 6) {
-	
-		   case 0: 
-			   stiming->va =  (stiming->ha *10) >> 4;
-			   break;
-		   case 1: 
-			   stiming->va =  (stiming->ha *3) >> 2;
-			   break;
-		   case 2: 
-			   stiming->va =  (stiming->ha << 2) / 5;			       
-			   break;
-		   case 3: 
-			   stiming->va =  (stiming->ha* 9) >>4;			       
-			   break;
-		   default:
-			   break;
-		} 
-
-		p_edidblk +=2;
-
-		PD_DEBUG("ch7036_parse_standard_timing()- ha [%d] va [%d] refresh [%d]\n",stiming->ha,stiming->va,stiming->refresh_rate);
-
-	} 
-	
-	return;
-}
-
-
-
-
-void ch7036_parse_established_timing(ch7036_device_context_t* p_ctx, ch7036_edid_blk_t* p_edid) 
-{
-
-	unsigned char* p_edidblk = p_edid->edidblk;
-
-	
-
-	established_timings_t *p_etiming_I = p_edid->etiming_I;
-	established_timings_t *p_etiming_II = p_edid->etiming_II;
-	established_timings_t *p_etiming_man = p_edid->etiming_man;
-
-	unsigned char i=0;
-	unsigned char et1, et2;
-
-	PD_DEBUG("ch7036_parse_established_timing()- enter...\n");
-
-	et1 = p_edidblk[EDID_ESTABLISHED_TIMINGS_1];
-	et2 = p_edidblk[EDID_ESTABLISHED_TIMINGS_2];
-
-
-
-	for(i=0; i<8;i++) {
-	  p_etiming_I[i].is_supported = FALSE;
-	  p_etiming_II[i].is_supported = FALSE;
-	}
-
-
-
-	p_etiming_man->is_supported = FALSE;
- 
-
-	for(i=0;i<8;i++) {
-
-
-		
-		if(et1 & 0x01) {   
-			p_etiming_I[i].is_supported = TRUE;
-	
-		}
-		
-		
-		if(et2 & 0x01) {   
-			p_etiming_II[i].is_supported = TRUE;
-	
-		}
-
-		et1 >>=  1;
-		et2 >>=  1;
-
-	}
-
-
-	
-	if (p_edidblk[EDID_MANUFACTURERS_RESERVED_TIMINGS] & 0x80) {
-
-		p_etiming_man->is_supported = TRUE;
-	 
-	}
-
-
-	return;
-
-}
-
-
-ch7036_status_t ch7036_parse_cea_edid(ch7036_device_context_t* p_ctx)
-{
-	uint8 tag, blk_size =0; 
-	uint8 index = 0;
-	
-	uint16 count;
-
-	uint8*  p_buff;
-
-
-	ch7036_edid_blk_t* p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
-
-	unsigned char* p_edidblk = p_hedid->edidblk;
-	ch7036_attr_table_index_t* p_modes =  p_hedid->modes;
-
-	
-	PD_DEBUG("ch7036_parse_cea_edid()- enter...\n");
-
-	while (index < MAX_ATTR_LIST_SIZE )
-		p_modes[index++] = FALSE; 
-	
-		
-	if(p_edidblk[EDID_CEA_DETAILED_TIMING_DATA_OFFSET] == 0 ||  p_edidblk[EDID_CEA_DETAILED_TIMING_DATA_OFFSET] > 124) {
-		PD_DEBUG("ch7036_parse_cea_edid()- invalid data block size [%d]\n", p_edidblk[EDID_CEA_DETAILED_TIMING_DATA_OFFSET]);
-		return SS_UNSUCCESSFUL;
-	}
-
-	
-
-	PD_DEBUG("ch7036_parse_cea_edid()- CEA revision [0x%x]...\n",p_edidblk[EDID_CEA_REVISION]);
-	
-	if(p_edidblk[EDID_CEA_TAG] == 0x02 && p_edidblk[EDID_CEA_REVISION] == 0x03)
-	{
-		
-		p_buff = &(p_edidblk[EDID_CEA_DATA_BLOCK]);
-
-		
-
-		count=4 ; 
-		for(; count < p_edidblk[EDID_CEA_DETAILED_TIMING_DATA_OFFSET]; p_buff += blk_size) {
-
-			blk_size = (*p_buff) & 0x1F; 
-			tag = (*p_buff) & 0xE0; 
-
-			PD_DEBUG("ch7036_parse_cea_edid()- data type [0x%x] block_size [%d]\n", tag, blk_size);
-
-			p_buff++;
-			switch (tag) { 
-			
-				case 0x20: 
-				
-					break;
-
-				case 0x40: 
-					ch7036_parse_cea_video_data_block(blk_size, p_buff, p_hedid);
-					break;
-
-				case 0x60: 
-					break;
-
-				case 0x80: 
-					break;
-
-				default:
-					break;
-
-			}
-
-			count += (blk_size + 1); 
-					
-
-		} 
-	
-	} 
-	
-
-	PD_DEBUG("ch7036_parse_cea_edid()- exit...\n");
-
-	return SS_SUCCESS;
-
-	
-}
-
-
-void ch7036_parse_cea_video_data_block(uint8 blk_size, uint8* p_buff, ch7036_edid_blk_t* p_edid)
-{
-	uint8 i, index;
-
-	ch7036_attr_table_index_t* p_modes =  p_edid->modes;
-
-	for(i=1; i <= blk_size; i++, p_buff++ ) {
-		
-			index=0;
-
-			PD_DEBUG("ch7036_parse_cea_video_data_block()- HDMI display video code [0x%x]\n",(*p_buff) & 0x7F);
-			
-			while (index < OUT_HDMI_END) { 
-			
-				
-				if( p_modes[index] == TRUE  ) {
-					index++;
-					continue;
-				}
-				
-
-				if( ((*p_buff) & 0x7F) == hdmi_timing_table[index].fmt_index  ) {				
-					
-					p_modes[index] = TRUE;
-					PD_DEBUG("ch7036_parse_cea_video_data_block()- mode supported: global table index [%d] name [%s]...\n",index, ch7036_get_mode_name(CHANNEL_LVDS_HDMI,index) );
-					
-					if( hdmi_timing_table[index-1].fmt_index == hdmi_timing_table[index].fmt_index) {						 
-		
-						break; 
-					}
-
-				}  
-				
-				index++;
-								   
-			} 
-	} 
-
-	return;
-}
-
-
-ch7036_status_t ch7036_parse_edid(ch7036_device_context_t* p_ctx)
-{
-
-
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
-
-	ch7036_edid_blk_t* p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
-	ch7036_edid_blk_t* p_cedid = (ch7036_edid_blk_t *)p_ctx->cedid;
-
-	unsigned char* p_edidblk=0; 
-	ch7036_attr_table_index_t* p_modes = 0;
-	pd_attr_t  *p_attr = NULL ;
-	int RESET =1;
-
-	PD_DEBUG("ch7036_parse_edid()- enter...\n");
-
-	
-	//hpd checking schemes
-	if(p_ctx->hpd == 0) 
-		return SS_SUCCESS;
-
-
-	if ( 
-		( (pOutput_Info->channel & 0x02) &&  (p_ctx->hpd & 0x80) )||
-		( (pOutput_Info->channel & 0x04) &&  (p_ctx->hpd & 0x08) )
-		)
-		//parsing is already done
-		return SS_SUCCESS;
-
-	
-	switch (pOutput_Info->channel) {
-		case CHANNEL_LVDS_HDMI:
-		case CHANNEL_HDMI:
-			if(p_hedid->is_edid) { 
-				p_edidblk = p_hedid->edidblk;	
-
-				p_hedid->is_preferred_timing = (p_edidblk[EDID_FEATURE_SUPPORT] >> 1) & 0x1;
-
-				
-				if(pOutput_Info->hdmi_fmt.is_dvi_mode == 0) {
-					p_attr = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs, PD_ATTR_ID_HDMI_OUT_MODE, 0);
-					ch7036_parse_cea_edid(p_ctx);
-				}
-				else {
-					p_attr = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs, PD_ATTR_ID_DVI_OUT_MODE, 0);
-					ch7036_parse_standard_edid(p_ctx, CHANNEL_LVDS_HDMI);
-				}
-
-								
-				
-				p_ctx->hpd |= 0x80; //don't parse again next time
-							
-			}
-			else { 
-
-				PD_DEBUG("ch7036_parse_edid()- hdmi edid read failed or never done...use default...\n");
-				ch7036_set_edid_display_supported_attr( (void *)p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,p_ctx->downscaled,p_hedid->modes,RESET);
-				p_ctx->hpd &= 0x7F; //allow to enter parsing block again
-
-			}
-
-			p_modes = p_hedid->modes;
-			
-			break;
-
-		case CHANNEL_LVDS_VGA:
-		case CHANNEL_VGA:
-			if(p_cedid->is_edid) { 
-				p_edidblk = p_cedid->edidblk;
-
-				p_cedid->is_preferred_timing = (p_edidblk[EDID_FEATURE_SUPPORT] >> 1) & 0x1;
-				p_attr = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs, PD_ATTR_ID_CRT_OUT_MODE, 0);
-								
-				ch7036_parse_standard_edid(p_ctx, CHANNEL_LVDS_VGA);
-				p_ctx->hpd |= 0x08;
-			}
-			else {
-				PD_DEBUG("ch7036_parse_edid()- vga edid read failed or never done...use default...\n");
-				ch7036_set_edid_display_supported_attr( (void *)p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,p_ctx->downscaled,p_cedid->modes,RESET);
-				p_ctx->hpd &= 0x7F; //allow to enter parsing block again
-			}
-			p_modes = p_cedid->modes;
-			
-			break;
-		default:
-			//there is no separate DVI display channel, or LVDS edid reading at this time
-			//DVI display option should already be mapped to HDMI channel
-			p_edidblk = 0;
-
-	}
-
-	if(p_edidblk) {
-
-		ch7036_set_edid_display_supported_attr( (void *)p_attr,0,p_ctx->downscaled,p_modes,0);
-
-	}
-
-	PD_DEBUG("ch7036_parse_edid()- exit...\n");
-
-	return SS_SUCCESS;
-}
-
-
-void ch7036_alter_display_table(int all, void *p_table,unsigned char* p_modes, void* val,unsigned long* p_invis,unsigned char is_invis,unsigned char is_6x4)
-{
-	pd_attr_t  *p_attr;
-	unsigned long i,j;
-	
-
-	PD_DEBUG("ch7036_alter_display_table()-enter...\n");
-
-	if(all) { 
-		unsigned long* num_attrs = (unsigned long *)val;
-		for(i=0;i<3;i++) { //all 3 tables: hdmi, dvi, vga
-			
-			p_attr = pd_get_attr((pd_attr_t *)p_table, *num_attrs, PD_ATTR_ID_HDMI_OUT_MODE+i, 0);
-			if(is_6x4) 
-				p_attr++;  		
-			else 
-				p_attr= p_attr + ch7036_invis_6x4_modes_table_size[i] + 1; //1 is to skip header
-
-					
-			for(j=0; j < *p_invis;j++) { 
-				if(is_invis)
-					p_attr->flags  |= PD_ATTR_FLAG_USER_INVISIBLE;  
-				else 
-					p_attr->flags  &= ~PD_ATTR_FLAG_USER_INVISIBLE; 
-
-
-				p_attr++;
-			}
-			p_invis++; //now, grab dvi, then vga table size
-			
-
-		}
-
-	}
-	else { 
-		unsigned long id= 0,k;
-		p_attr = (pd_attr_t *)p_table;
-		id = p_attr->id;
-
-		if(is_6x4) {
-			p_attr++;  
-			j=0;
-		}
-		else {
-			p_attr= p_attr + ch7036_invis_6x4_modes_table_size[id - PD_ATTR_ID_HDMI_OUT_MODE] + 1; //point to the first 7x4 entry			
-			j= ch7036_invis_6x4_modes_table_size[id - PD_ATTR_ID_HDMI_OUT_MODE];
-		}
-		p_invis = p_invis + (id - PD_ATTR_ID_HDMI_OUT_MODE);
-		k= *p_invis + j;
-
-		for(; j < k;j++) { 
-			if(is_invis) {
-				p_attr->flags  |= PD_ATTR_FLAG_USER_INVISIBLE;  
-				p_modes[j]=FALSE;
-			} 
-	
-			p_attr++;
-		}
-			
-	}
-}
-
-
-ch7036_status_t ch7036_set_edid_display_supported_attr(void *p_table, unsigned long num_attrs, unsigned char* p_downscaled, unsigned char* p_modes, int is_reset)
-{
-
-	pd_list_attr_t *p_hdr = (pd_list_attr_t *)p_table;
-	pd_attr_t *p_entry = (pd_attr_t *)p_table; 
-	
-	uint8 i=0;
+	ch7036_status_t status_hdmi, status_crt;
+
+	ch7036_edid_blk_t * p_hedid = (ch7036_edid_blk_t *)(p_ctx->hedid);
+
+	uint8 hpd = 0;
+
+
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x04);
+	reg = I2CRead(p_ch7xxx_context,0x52);
+
+	reg = reg & 0xEF;
+	I2CWrite(p_ch7xxx_context,0x52, reg);
+
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x0);
+	reg = I2CRead(p_ch7xxx_context,0x07);
+
+	reg = reg & 0x70;
+	I2CWrite(p_ch7xxx_context,0x07, reg);
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x01);
+	reg = I2CRead(p_ch7xxx_context,0x0F);
+
+	reg = reg & 0x7F;
+	I2CWrite(p_ch7xxx_context,0x0F, reg);
+
+	I2CWrite(p_ch7xxx_context,0x0E, I2CRead(p_ch7xxx_context,0x0E) & 0x7F);
+
+	PD_DEBUG("ch7036_get_attached_device()- enter- p_ctx->hpd= [0x%x]\n", p_ctx->hpd);
+
+	status_hdmi = ch7036_get_hdmi_hpd(p_ctx,&hpd);
+	LHFM_enable_crt_hpd(p_ch7xxx_context);
+	status_crt = LHFM_get_crt_hpd(p_ch7xxx_context);
+
+	PD_DEBUG("ch7036_get_attached_device()- enter- pOutput_Info->channel = [0x%x]\n", pOutput_Info->channel);
+
+	if(p_ctx->man_sel_out==1) { //manual selection
+
+
+		if( (status_crt == SS_SUCCESS) || ( (hpd & 0x01)== 1 ) ) {
+
+			switch (pOutput_Info->channel) {
+				case CHANNEL_LVDS_DVI:
+				case CHANNEL_DVI:
+				case CHANNEL_LVDS_HDMI:
+				case CHANNEL_HDMI:
+
+
+					if( (status_crt == SS_SUCCESS) && ( (hpd & 0x01)== 0 ) ) {
+
+						p_ctx->hpd = 0x16; //bit 4=1 to indicate SS_DISPLAY_CHOICE_NOT_ALLOWED,  check edid and parse it
+						status = SS_DISPLAY_CHOICE_NOT_ALLOWED;
+
+					}
+					else {
+
+						if (!p_ctx->init_done || ((p_ctx->prev_outchannel & pOutput_Info->channel) & 0x02) != 0x02 )
+							p_ctx->hpd = 0x60;
+						else
+							p_ctx->hpd = ( ((p_ctx->prev_outchannel & pOutput_Info->channel) & 0x02) == 0x02)?0xA0:0x60;
+
+						status = SS_SUCCESS;
+					}
+
+					break;
+
+				case CHANNEL_LVDS_VGA:
+				case CHANNEL_VGA:
+
+
+					if((status_crt != SS_SUCCESS) && ((hpd & 0x01)==1 ) ) {
+
+						if(!p_ctx->init_done) {
+							p_ctx->hpd = 0x06;
+							status = SS_SUCCESS;
+
+						}else {
+							p_ctx->hpd = (hpd & 0x80)?0x70:0x30;
+							status = SS_DISPLAY_CHOICE_NOT_ALLOWED;
+						}
+
+					}
+					else {
+
+						if ( (!p_ctx->init_done) || ((p_ctx->prev_outchannel & pOutput_Info->channel) & 0x04) != 0x04 )//at init, need to read edid, and parse it
+							p_ctx->hpd = 0x06;
+						else {
+							p_ctx->hpd = ( ((p_ctx->prev_outchannel & pOutput_Info->channel) & 0x04) == 0x04)?0x0A:0x06;
+
+						}
+
+						status = SS_SUCCESS;
+					}
+
+					break;
+			} //switch
+
+			if(status == SS_DISPLAY_CHOICE_NOT_ALLOWED)
+				PD_DEBUG("ch7036_get_attached_device()- manual selection- display choice is not allowed...\n");
+
+		}
+		else {
+
+			if (!p_ctx->init_done) {
+				p_ctx->hpd = 0x06;
+				status = SS_SUCCESS;
+
+			}else {
+
+				PD_DEBUG("ch7036_get_attached_device()- manual selection- none is connected- not allowed...\n");
+
+				status = SS_DISPLAY_CHOICE_NOT_ALLOWED;
+				p_ctx->hpd = 0x50;
+
+			}
+
+
+		}
+
+		PD_DEBUG("ch7036_get_attached_device()- manual selection- exit- p_ctx->hpd= [0x%x]\n", p_ctx->hpd);
+		PD_DEBUG("ch7036_get_attached_device()- exit- pOutput_Info->channel = [0x%x]\n", pOutput_Info->channel);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x03);
+		reg = I2CRead(p_ch7xxx_context,0x25);
+
+		PD_DEBUG("ch7036_get_attached_device()- manual selection- exit...HPD_MCU [0x%x]\n",reg);
+
+		return status;
+	}
+
+	//auto detection
+
+	if(status_hdmi == SS_SUCCESS) {
+
+			if( hpd == 0x81 ) {
+				if(p_ctx->hpd & CH7036HPD_HDVI_ATTACHED)  {
+
+					p_ctx->hpd = (p_ctx->hpd  & 0x9F) & ((~CH7036HPD_HDVI_STATUS_CHANGED) | CH7036HPD_HDVI_ATTACHED);
+
+					ch7036_get_hdvi_display_modes_supported(p_ctx);
+
+					if (
+						((pOutput_Info->hdmi_fmt.is_dvi_mode== 0) && (p_hedid->supported_modes[13] == 0) )||
+						((pOutput_Info->hdmi_fmt.is_dvi_mode== 1) && (p_hedid->supported_modes[13] > 0))
+					) {
+
+						p_ctx->hpd = (p_ctx->hpd  & 0x9F) | (CH7036HPD_HDVI_STATUS_CHANGED | CH7036HPD_HDVI_ATTACHED);
+						PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status changed [HDMI<->DVI] since last query and it's HIGH\n");
+
+					}
+					else
+						PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status has not changed since last query and it's HIGH\n");
+				}
+				else {
+
+
+					p_ctx->hpd = (p_ctx->hpd  & 0x9F) | (CH7036HPD_HDVI_STATUS_CHANGED | CH7036HPD_HDVI_ATTACHED);
+					PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status changed since last query and it's HIGH\n");
+				}
+			}
+			else if (hpd ==0x80) {
+				if( (p_ctx->hpd & CH7036HPD_HDVI_ATTACHED) ==0 )  {
+
+					p_ctx->hpd = (p_ctx->hpd  & 0x9F) & ((~ CH7036HPD_HDVI_STATUS_CHANGED) & (~CH7036HPD_HDVI_ATTACHED)) ;
+					PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status not changed since last query and it's LOW\n");
+				}
+				else {
+
+					p_ctx->hpd = (p_ctx->hpd  & 0x9F) | (CH7036HPD_HDVI_STATUS_CHANGED & (~CH7036HPD_HDVI_ATTACHED)) ;
+					PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status changed since last query and it's LOW\n");
+				}
+
+			}
+			else if (hpd == 0x01) {
+
+				p_ctx->hpd = (p_ctx->hpd  & 0x9F) & ((~CH7036HPD_HDVI_STATUS_CHANGED) | CH7036HPD_HDVI_ATTACHED);
+				PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status has not changed since last query and it's HIGH\n");
+			}
+			else {
+
+				p_ctx->hpd &= 0x9F;
+				PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status has not changed since last query and it's LOW\n");
+			}
+
+
+
+			PD_DEBUG("ch7036: ch7036_get_attached_device()- SUCCESS- hdmi hpd [0x%x]\n", hpd);
+
+	}
+	else {
+
+
+		if ( (!p_ctx->init_done) &&  (hpd == 0x86) )  {
+
+			p_ctx->hpd |= CH7036HPD_HDVI_ATTACHED;
+
+		}
+
+		else {
+			p_ctx->hpd &= ~CH7036HPD_HDVI_ATTACHED;
+
+		}
+
+	}
+
+	if(status_crt == SS_SUCCESS) {
+
+		if( (p_ctx->hpd & CH7036HPD_CRT_ATTACHED )== CH7036HPD_CRT_ATTACHED)
+			p_ctx->hpd = (p_ctx->hpd  & 0xF9) & ((~CH7036HPD_CRT_STATUS_CHANGED)  | CH7036HPD_CRT_ATTACHED);
+
+		else
+			p_ctx->hpd = ((p_ctx->hpd  & 0xF9) | ( CH7036HPD_CRT_STATUS_CHANGED | CH7036HPD_CRT_ATTACHED));
+
+	}
+	else  {
+
+		if( (p_ctx->hpd & CH7036HPD_CRT_ATTACHED ) == 0 ) {
+			p_ctx->hpd &= 0xF9;
+
+			if( (p_ctx->hpd & CH7036HPD_HDVI_ATTACHED)== 0  )
+				p_ctx->hpd |= 0x06;
+
+		}
+		else  {
+
+			if ( (p_ctx->hpd & CH7036HPD_HDVI_ATTACHED) ==0 )
+				p_ctx->hpd &= 0xFB;
+			else
+				p_ctx->hpd = (p_ctx->hpd & 0xF9) |  CH7036HPD_CRT_STATUS_CHANGED;
+		}
+
+	}
+
+	PD_DEBUG("ch7036_get_attached_device()- auto detection - exit- p_ctx->hpd= [0x%x]\n", p_ctx->hpd);
+	return SS_SUCCESS;
+}
+
+
+void ch7036_reset(ch7036_device_context_t* p_ctx)
+{
+	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
+
+	ch7036_reset_mcu(p_ch_ctx);
+	ch7036_reset_datapath(p_ch_ctx);
+
+	return;
+}
+
+void ch7036_reset_datapath(DEV_CONTEXT* p_ch_ctx)
+{
+
+	PD_DEBUG("ch7036: ch7036_reset_datapath()-enter\n");
+    I2CWrite(p_ch_ctx,0x03, 0x04);
+	I2CWrite(p_ch_ctx,0x52, 0x2E);
+
+	pd_usleep(50);
+	I2CWrite(p_ch_ctx,0x52, 0x2F);
+
+	return;
+}
+
+void ch7036_reset_mcu(DEV_CONTEXT* p_ch_ctx)
+{
+
+	PD_DEBUG("ch7036: ch7036_reset_mcu()-enter\n");
+
+    I2CWrite(p_ch_ctx,0x03, 0x04);
+	I2CWrite(p_ch_ctx,0x52, 0x2B);
+
+	pd_usleep(50);
+	I2CWrite(p_ch_ctx,0x52, 0x2F);
+
+
+	PD_DEBUG("ch7036: ch7036_reset_mcu()-exit-\n");
+	return;
+}
+
+
+
+
+
+void ch7036_set_input_timing_info(ch7036_device_context_t *p_ctx, INPUT_INFO* pInput_Info)
+{
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+
+	pd_timing_t * p_current_mode = &(p_ctx->native_dtd);
+	uint8 audio_id = AUDIO_SPDIF;
+	PD_DEBUG("ch7036_intf: ch7036_set_input_timing_info()-\n");
+
+
+	if (p_ctx->init_done) {
+
+
+		pInput_Info->timing.ht = p_current_mode->htotal+1;
+
+		pInput_Info->timing.ha = p_current_mode->width;
+		pInput_Info->timing.ho = p_current_mode->hsync_start - p_current_mode->hblank_start;
+		pInput_Info->timing.hw = p_current_mode->hsync_end - p_current_mode->hsync_start;
+		pInput_Info->timing.vt = p_current_mode->vtotal+1;
+
+		pInput_Info->timing.va = p_current_mode->height;
+		pInput_Info->timing.vo = p_current_mode->vsync_start - p_current_mode->vblank_start;
+		pInput_Info->timing.vw = p_current_mode->vsync_end - p_current_mode->vsync_start;
+
+
+		pInput_Info->rx_clk_khz = p_current_mode->dclk;
+
+
+		pInput_Info->hs_pol = ((uint8)(((p_current_mode)->mode_info_flags & PD_HSYNC_HIGH) >> 24 ))?1:0;
+		pInput_Info->vs_pol = ((uint8)(((p_current_mode)->mode_info_flags & PD_VSYNC_HIGH) >> 24))?1:0;
+
+	}
+
+
+
+
+
+	pInput_Info->pixel_fmt = ((lvds_context_t *)p_ctx->internal_lvds)->panel_depth == 18?PIXEL_FMT_18BIT:3;
+
+
+	pInput_Info->data_ch_pol = POL_NO_INV;
+
+
+	pInput_Info->data_ch_invert = POL_NO_INV;
+
+
+
+
+
+	pInput_Info->de_pol = POL_HIGH;
+
+
+
+
+
+	if(pOutput_Info->channel & CHANNEL_HDMI)
+		ch7036_set_audio_type(pInput_Info, audio_id);
+
+}
+
+void ch7036_set_output_timing_info(ch7036_device_context_t *p_ctx, OUTPUT_INFO* pOutput_Info)
+{
+
+
+	PD_DEBUG("ch7036: ch7036_set_output_timing_info()\n");
+
+
+	PD_DEBUG("ch7036_set_output_timing_info()- output channel from pd context[%u]\n",pOutput_Info->channel);
+
+
+	pOutput_Info->lvds_fmt.channel_swap = LVDS_CHANNEL_SWAP_DEF;
+	pOutput_Info->lvds_fmt.channel_pol = (POL_LOW << 4) | (POL_LOW << 3) | (POL_LOW << 2) | (POL_LOW << 1) | (POL_LOW << 0);
+	pOutput_Info->lvds_fmt.pixel_fmt = p_ctx->dither_select;
+
+
+
+	pOutput_Info->hdmi_fmt.channel_swap = 0;
+	pOutput_Info->hdmi_fmt.data_pol_invert = POL_NO_INV;
+	pOutput_Info->hdmi_fmt.protect_enable = 0;
+
+
+
+
+	if (pOutput_Info->channel & CHANNEL_HDMI)
+	{
+
+		if(!(pOutput_Info->hdmi_fmt.is_dvi_mode))
+		{
+			PD_DEBUG("ch7036_set_output_timing_info- hdmi mode index is [0x%x]\n",p_ctx->hdmi_mode_index);
+			pOutput_Info->hdmi_fmt.format_index = (uint8)hdmi_timing_table[p_ctx->hdmi_mode_index].fmt_index;
+			pOutput_Info->hdmi_fmt.aspect_ratio = (uint8)hdmi_timing_table[p_ctx->hdmi_mode_index].aspect;
+
+			pOutput_Info->timing.ht = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.ht;
+			pOutput_Info->timing.ha = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.ha;
+			pOutput_Info->timing.ho = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.ho;
+			pOutput_Info->timing.hw = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.hw;
+			pOutput_Info->timing.vt = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.vt;
+			pOutput_Info->timing.va = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.va;
+			pOutput_Info->timing.vo = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.vo;
+			pOutput_Info->timing.vw = hdmi_timing_table[p_ctx->hdmi_mode_index].timing.vw;
+			pOutput_Info->uclk_khz = hdmi_timing_table[p_ctx->hdmi_mode_index].clk_freq;
+		}
+		else
+		{
+			pOutput_Info->hdmi_fmt.format_index = (uint8)dvi_timing_table[p_ctx->dvi_mode_index].fmt_index;
+			pOutput_Info->hdmi_fmt.aspect_ratio = (uint8)dvi_timing_table[p_ctx->dvi_mode_index].aspect;
+
+			pOutput_Info->timing.ht = dvi_timing_table[p_ctx->dvi_mode_index].timing.ht;
+			pOutput_Info->timing.ha = dvi_timing_table[p_ctx->dvi_mode_index].timing.ha;
+			pOutput_Info->timing.ho = dvi_timing_table[p_ctx->dvi_mode_index].timing.ho;
+			pOutput_Info->timing.hw = dvi_timing_table[p_ctx->dvi_mode_index].timing.hw;
+			pOutput_Info->timing.vt = dvi_timing_table[p_ctx->dvi_mode_index].timing.vt;
+			pOutput_Info->timing.va = dvi_timing_table[p_ctx->dvi_mode_index].timing.va;
+			pOutput_Info->timing.vo = dvi_timing_table[p_ctx->dvi_mode_index].timing.vo;
+			pOutput_Info->timing.vw = dvi_timing_table[p_ctx->dvi_mode_index].timing.vw;
+			pOutput_Info->uclk_khz = dvi_timing_table[p_ctx->dvi_mode_index].clk_freq;
+
+		}
+
+
+
+	} else if((pOutput_Info->channel & CHANNEL_VGA) && ((pOutput_Info->channel & CHANNEL_HDMI)==0x00) )
+	{
+
+
+
+		PD_DEBUG("ch7036_set_output_timing_info- crt mode index is [0x%x]\n",p_ctx->crt_mode_index);
+		pOutput_Info->timing.ht = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.ht;
+		pOutput_Info->timing.ha = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.ha;
+		pOutput_Info->timing.ho = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.ho;
+		pOutput_Info->timing.hw = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.hw;
+		pOutput_Info->timing.vt = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.vt;
+		pOutput_Info->timing.va = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.va;
+		pOutput_Info->timing.vo = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.vo;
+		pOutput_Info->timing.vw = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.vw;
+		pOutput_Info->uclk_khz = ch7036_crt_timing_table[p_ctx->crt_mode_index].clk_freq;
+
+
+	} else
+		;
+
+
+	if(pOutput_Info->channel & CHANNEL_HDMI)
+		ch7036_set_hdmi_sync_polarity(pOutput_Info);
+
+	if(pOutput_Info->channel & CHANNEL_HDMI || pOutput_Info->channel & CHANNEL_VGA) {
+
+		ch7036_set_rotate (pOutput_Info);
+		ch7036_set_hflip (pOutput_Info);
+		ch7036_set_vflip (pOutput_Info);
+	}
+}
+
+void ch7036_set_prefer_timing_info(ch7036_device_context_t *p_ctx, PREFER_INFO* pPrefer_Info)
+{
+
+
+
+
+	PD_DEBUG("ch7036_intf: ch7036_set_prefer_timing_info()\n");
+
+
+	if (!p_ctx->init_done) {
+
+	pPrefer_Info->mclk_khz = 166000;
+	pPrefer_Info->uclkod_sel = 1;
+	pPrefer_Info->dat16_32b = 0;
+	pPrefer_Info->true24 = 0;
+	pPrefer_Info->true_com = 0;
+	pPrefer_Info->lvds_out_hs_tolerance = HS_TOLERANCE_LEVEL0;
+	pPrefer_Info->lvds_out_reset_bit_sel = RST_BIT_VSYNC;
+	pPrefer_Info->dither_filter_enable = DITHER_ENABLE;
+
+	pPrefer_Info->hscale_ratio_gate = 130;
+	pPrefer_Info->reset=0;
+	pPrefer_Info->vga_enable=0;
+
+	pPrefer_Info->text_enhancement = DEFAULT_TEXT_ENHANCE;
+	pPrefer_Info->pll_ref_dly = DEF_PLL_REF_DLY;
+	pPrefer_Info->pll_ref_fbdly = DEF_PLL_REF_FBDLY;
+	pPrefer_Info->lvds_txdrv_ctrl = DEF_LVDS_TXDRV_CTRL;
+
+	pPrefer_Info->eye_bgtrim=0;
+	pPrefer_Info->eye_dacg=0;
+	pPrefer_Info->eye_dri_demp=0;
+	pPrefer_Info->eye_dri_pll_cp=0;
+	pPrefer_Info->eye_dri_damp=0;
+	pPrefer_Info->eye_dri_pll_rlf=0;
+	pPrefer_Info->eye_rdac=0;
+
+	}
+
+	pPrefer_Info->scale_line_adjust = 0;
+
+
+
+}
+
+
+ch7036_status_t ch7036_parse_standard_edid(ch7036_device_context_t* p_ctx, uint32 channel)
+{
+	uint8 i, index = 0;
+
+	ch7036_edid_blk_t* p_edid = (ch7036_edid_blk_t *)p_ctx->cedid;
+	unsigned char* p_edidblk = p_edid->edidblk;
+
+
+	OUT_FMT* p_table = ch7036_crt_timing_table;
+	TIMING* p_timing;
+
+	unsigned char j=0;
+
+
+
+
+
+	established_timings_t *p_etiming_I = p_edid->etiming_I;
+	established_timings_t *p_etiming_II = p_edid->etiming_II;
+
+
+
+	standard_timings_t	*stiming = p_edid->stiming;
+	ch7036_attr_table_index_t* p_modes =  p_edid->modes;
+
+	unsigned long idx = 2;
+
+
+	PD_DEBUG("ch7036_parse_stardard_edid() channel [0x%x] - enter...\n", channel);
+
+
+	if(channel == CHANNEL_LVDS_HDMI) {
+
+		p_edid = (ch7036_edid_blk_t *)p_ctx->hedid;
+		p_edidblk = p_edid->edidblk;
+		p_etiming_I = p_edid->etiming_I;
+		p_etiming_II = p_edid->etiming_II;
+
+		stiming = p_edid->stiming;
+		p_modes =  p_edid->modes;
+
+
+		if (p_edid->ebn > 1) {
+			idx = 1;
+			p_table = hdmi_timing_table;
+		}
+		else {
+			idx = 0;
+			p_table = dvi_timing_table;
+			channel = 7;
+		}
+
+
+	}
+
+
+	while (index < MAX_ATTR_LIST_SIZE)
+		p_modes[index++] = FALSE;
+
+
+	if (p_edidblk[EDID_EXTENSION_FLAG] == 0x00 ) {
+
+
+		ch7036_parse_standard_timing(p_edid,0);
+
+
+		ch7036_parse_established_timing(p_ctx, p_edid);
+
+
+
+		ch7036_parse_detailed_descriptor_blocks(p_ctx, p_edid);
+
+
+
+		for(i=0; i<8;i++) {
+
+
+			index=0;
+			while (index < MAX_ATTR_LIST_SIZE ) {
+				if(p_modes[index]== TRUE) {
+					index++;
+					continue;
+				}
+				p_timing = &(p_table[index].timing);
+
+				if ( (p_edid->dtblk[j]).data_tag & 0x00FFFFFF ) {
+					OUT_FMT* p_dtd = &((p_edid->dtblk[j]).dtiming);
+
+					if( (p_dtd->timing.ha == p_timing->ha) && (p_dtd->timing.va == p_timing->va) && (p_dtd->timing.hz >= p_timing->hz) ) {
+						p_modes[index] = TRUE;
+						j= j> 3?3:j+1;
+
+						PD_DEBUG("ch7036_parse_standard_edid()- detailed timing mode supported- index [%d] name [%s]...\n",index,ch7036_get_mode_name(channel,index) );
+
+					}
+
+				}
+
+
+				if( (stiming[i].ha == p_timing->ha) && (stiming[i].va == p_timing->va) && (stiming[i].refresh_rate >= p_timing->hz) ) {
+					p_modes[index] = TRUE;
+					PD_DEBUG("ch7036_parse_standard_edid()- std_timing mode supported- index [%d] name [%s]...\n",index,ch7036_get_mode_name(channel,index) );
+				}
+
+				index++;
+
+			}
+
+		}
+
+
+		for(i=0;i<4;i++) {
+			if ( (p_edid->dtblk[i]).data_tag == 0xFA000000) {
+				;
+				continue;
+			}
+		}
+
+
+
+		for(i=0; i<8;i++) {
+
+
+
+			if( (p_etiming_I[i].is_supported == TRUE) && (p_etiming_I[i].index[idx] != OUT_CRT_END) ) {
+				p_modes[p_etiming_I[i].index[idx]] = TRUE;
+				PD_DEBUG("ch7036_parse_standard_edid()- et1 mode supported- index [%d] name [%s]...\n",p_etiming_I[i].index[idx],p_etiming_I[i].mode_name);
+				continue;
+
+			}
+
+
+			if( (i==7) && (channel ==7) && (p_etiming_I[i].is_supported == TRUE) ) {
+				p_modes[p_etiming_I[i].index[idx]] = TRUE;
+				PD_DEBUG("ch7036_parse_standard_edid()- et1 mode supported- index [%d] name [%s]...\n",p_etiming_I[i].index[idx],p_etiming_I[i].mode_name);
+			}
+
+
+		}
+
+		for(i=0; i<8;i++) {
+
+			if( (p_etiming_II[i].is_supported == TRUE) && (p_etiming_II[i].index[idx] != OUT_CRT_END) ) {
+				p_modes[p_etiming_II[i].index[idx]] = TRUE;
+				PD_DEBUG("ch7036_parse_standard_edid()- et2 mode supported- index [%d] name [%s]...\n",p_etiming_II[i].index[idx],p_etiming_II[i].mode_name);
+				continue;
+
+			}
+
+		}
+
+
+
+	}
+	else {
+		PD_DEBUG("ch7036_parse_standard_edid()- vga/dvi has more than one 128 byte block\n");
+	}
+
+
+	PD_DEBUG("ch7036_parse_stardard_edid()-channel [0x%x] - exit...\n", channel);
+
+	return SS_SUCCESS;
+
+}
+
+void ch7036_parse_detailed_descriptor_blocks(ch7036_device_context_t* p_ctx, ch7036_edid_blk_t* p_edid)
+{
+	unsigned long *monitor_descriptor;
+	unsigned char* p_ebuf, *p_st;
+	unsigned char* p_edidblk = p_edid->edidblk;
+	unsigned char i;
+	OUT_FMT* p_dt;
+
+
+	p_ebuf = &(p_edidblk[EDID_DETAILED_TIMING_DESCRIPTION_1]);
+
+	PD_DEBUG("parse_detailed_descriptor_blocks()- enter...\n");
+
+	for(i=0;i<4;i++) {
+
+		monitor_descriptor = (unsigned long *) p_ebuf;
+
+		if((*monitor_descriptor) & 0x00FFFFFF ) {
+
+
+			p_dt = &(p_edid->dtblk[i].dtiming);
+			ch7036_parse_detailed_timing(p_dt, p_ebuf);
+
+		}
+
+		else {
+
+			p_st = p_ebuf;
+			p_st +=5;
+
+			switch (*monitor_descriptor) {
+				case 0xFA000000:
+					ch7036_parse_standard_timing(p_edid,p_st);
+					break;
+
+				case 0xFD000000:
+					(p_edid->rtiming).vrate_min = *p_st;
+					(p_edid->rtiming).vrate_max = *(p_st+1);
+					(p_edid->rtiming).hrate_min = *(p_st+2);
+					(p_edid->rtiming).hrate_max = *(p_st+3);
+					(p_edid->rtiming).pclk_max = (unsigned long)(*(p_st+4))*10000L;
+
+
+					break;
+
+				case 0xFC000000:
+				case 0xFF000000:
+				default:
+					break;
+			}
+		}
+
+		(p_edid->dtblk[i]).data_tag = *monitor_descriptor;
+
+		p_ebuf += 18;
+	}
+
+	return;
+}
+
+void ch7036_parse_detailed_timing(OUT_FMT *p_dt, unsigned char* p_ebuf)
+{
+
+	unsigned short blanking;
+
+	PD_DEBUG("ch7036_parse_detailed_descriptor_timing()- enter...\n");
+
+
+	p_dt->clk_freq = ((uint32)(p_ebuf[1]<<8) | p_ebuf[0]) * 10;
+
+	p_dt->timing.ha = ((uint16)(p_ebuf[4] & 0xF0) << 4) | p_ebuf[2];
+
+	PD_DEBUG("ch7036_parse_detailed_timing() byte 3 [%x] byte 5 [%x]\n",p_ebuf[2],p_ebuf[4]);
+
+	blanking = ((uint16)(p_ebuf[4] & 0x0F) << 8) | p_ebuf[3];
+	p_dt->timing.ht = p_dt->timing.ha + blanking;
+
+	p_dt->timing.va = ((uint16)(p_ebuf[7] & 0xF0) << 4) | p_ebuf[5];
+
+	PD_DEBUG("ch7036_parse_detailed_timing() byte 6 [%x] byte 8 [%x]\n",p_ebuf[5],p_ebuf[7]);
+
+	blanking = ((uint16)(p_ebuf[7] & 0x0F) << 8) | p_ebuf[6];
+	p_dt->timing.vt = p_dt->timing.va + blanking;
+
+	PD_DEBUG("ch7036_parse_detailed_timing()- pclk [%d] Khz ha [%d] va [%d] ht [%d] vt [%d]\n",p_dt->clk_freq,p_dt->timing.ha,p_dt->timing.va,p_dt->timing.ht,p_dt->timing.vt);
+
+	p_dt->timing.hz = 	(((p_dt->clk_freq / p_dt->timing.ht) + 1 ) * 1000) / p_dt->timing.vt;
+
+	p_dt->timing.stype = (p_ebuf[17] & 0x80)?0:1;
+
+	PD_DEBUG("ch7036_parse_detailed_timing()- refresh [%d] scantype [%d]\n",
+		p_dt->timing.hz,p_dt->timing.stype);
+
+	return;
+}
+
+
+
+void ch7036_parse_standard_timing(ch7036_edid_blk_t* p_edid, unsigned char* p_addtional_st)
+{
+	standard_timings_t *stiming = p_edid->stiming;
+	unsigned char i, max=8;
+
+	unsigned char* p_edidblk = &(p_edid->edidblk[EDID_STANDARD_TIMINGS]);
+
+
+	PD_DEBUG("ch7036_parse_standard_timing()- enter\n");
+
+	if(p_addtional_st) {
+		p_edidblk = p_addtional_st;
+		stiming = p_edid->stiming_x;
+		max = 6;
+	}
+
+	for(i = 0; i < max; stiming++,i++) {
+
+
+		if( (*p_edidblk) == 0x01 &&  *(p_edidblk+1) == 0x01)
+			continue;
+
+		stiming->ha = ((*p_edidblk) + 31) << 3 ;
+
+		stiming->refresh_rate = (*(p_edidblk + 1) & 0x3F) + 60;
+
+		switch(*(p_edidblk +1) >> 6) {
+
+		   case 0:
+			   stiming->va =  (stiming->ha *10) >> 4;
+			   break;
+		   case 1:
+			   stiming->va =  (stiming->ha *3) >> 2;
+			   break;
+		   case 2:
+			   stiming->va =  (stiming->ha << 2) / 5;
+			   break;
+		   case 3:
+			   stiming->va =  (stiming->ha* 9) >>4;
+			   break;
+		   default:
+			   break;
+		}
+
+		p_edidblk +=2;
+
+		PD_DEBUG("ch7036_parse_standard_timing()- ha [%d] va [%d] refresh [%d]\n",stiming->ha,stiming->va,stiming->refresh_rate);
+
+	}
+
+	return;
+}
+
+
+
+
+void ch7036_parse_established_timing(ch7036_device_context_t* p_ctx, ch7036_edid_blk_t* p_edid)
+{
+
+	unsigned char* p_edidblk = p_edid->edidblk;
+
+
+
+	established_timings_t *p_etiming_I = p_edid->etiming_I;
+	established_timings_t *p_etiming_II = p_edid->etiming_II;
+	established_timings_t *p_etiming_man = p_edid->etiming_man;
+
+	unsigned char i=0;
+	unsigned char et1, et2;
+
+	PD_DEBUG("ch7036_parse_established_timing()- enter...\n");
+
+	et1 = p_edidblk[EDID_ESTABLISHED_TIMINGS_1];
+	et2 = p_edidblk[EDID_ESTABLISHED_TIMINGS_2];
+
+
+
+	for(i=0; i<8;i++) {
+	  p_etiming_I[i].is_supported = FALSE;
+	  p_etiming_II[i].is_supported = FALSE;
+	}
+
+
+
+	p_etiming_man->is_supported = FALSE;
+
+
+	for(i=0;i<8;i++) {
+
+
+
+		if(et1 & 0x01) {
+			p_etiming_I[i].is_supported = TRUE;
+
+		}
+
+
+		if(et2 & 0x01) {
+			p_etiming_II[i].is_supported = TRUE;
+
+		}
+
+		et1 >>=  1;
+		et2 >>=  1;
+
+	}
+
+
+
+	if (p_edidblk[EDID_MANUFACTURERS_RESERVED_TIMINGS] & 0x80) {
+
+		p_etiming_man->is_supported = TRUE;
+
+	}
+
+
+	return;
+
+}
+
+
+ch7036_status_t ch7036_parse_cea_edid(ch7036_device_context_t* p_ctx)
+{
+	uint8 tag, blk_size =0;
+	uint8 index = 0;
+
+	uint16 count;
+
+	uint8*  p_buff;
+
+
+	ch7036_edid_blk_t* p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
+
+	unsigned char* p_edidblk = p_hedid->edidblk;
+	ch7036_attr_table_index_t* p_modes =  p_hedid->modes;
+
+
+	PD_DEBUG("ch7036_parse_cea_edid()- enter...\n");
+
+	while (index < MAX_ATTR_LIST_SIZE )
+		p_modes[index++] = FALSE;
+
+
+	if(p_edidblk[EDID_CEA_DETAILED_TIMING_DATA_OFFSET] == 0 ||  p_edidblk[EDID_CEA_DETAILED_TIMING_DATA_OFFSET] > 124) {
+		PD_DEBUG("ch7036_parse_cea_edid()- invalid data block size [%d]\n", p_edidblk[EDID_CEA_DETAILED_TIMING_DATA_OFFSET]);
+		return SS_UNSUCCESSFUL;
+	}
+
+
+
+	PD_DEBUG("ch7036_parse_cea_edid()- CEA revision [0x%x]...\n",p_edidblk[EDID_CEA_REVISION]);
+
+	if(p_edidblk[EDID_CEA_TAG] == 0x02 && p_edidblk[EDID_CEA_REVISION] == 0x03)
+	{
+
+		p_buff = &(p_edidblk[EDID_CEA_DATA_BLOCK]);
+
+
+
+		count=4 ;
+		for(; count < p_edidblk[EDID_CEA_DETAILED_TIMING_DATA_OFFSET]; p_buff += blk_size) {
+
+			blk_size = (*p_buff) & 0x1F;
+			tag = (*p_buff) & 0xE0;
+
+			PD_DEBUG("ch7036_parse_cea_edid()- data type [0x%x] block_size [%d]\n", tag, blk_size);
+
+			p_buff++;
+			switch (tag) {
+
+				case 0x20:
+
+					break;
+
+				case 0x40:
+					ch7036_parse_cea_video_data_block(blk_size, p_buff, p_hedid);
+					break;
+
+				case 0x60:
+					break;
+
+				case 0x80:
+					break;
+
+				default:
+					break;
+
+			}
+
+			count += (blk_size + 1);
+
+
+		}
+
+	}
+
+
+	PD_DEBUG("ch7036_parse_cea_edid()- exit...\n");
+
+	return SS_SUCCESS;
+
+
+}
+
+
+void ch7036_parse_cea_video_data_block(uint8 blk_size, uint8* p_buff, ch7036_edid_blk_t* p_edid)
+{
+	uint8 i, index;
+
+	ch7036_attr_table_index_t* p_modes =  p_edid->modes;
+
+	for(i=1; i <= blk_size; i++, p_buff++ ) {
+
+			index=0;
+
+			PD_DEBUG("ch7036_parse_cea_video_data_block()- HDMI display video code [0x%x]\n",(*p_buff) & 0x7F);
+
+			while (index < OUT_HDMI_END) {
+
+
+				if( p_modes[index] == TRUE  ) {
+					index++;
+					continue;
+				}
+
+
+				if( ((*p_buff) & 0x7F) == hdmi_timing_table[index].fmt_index  ) {
+
+					p_modes[index] = TRUE;
+					PD_DEBUG("ch7036_parse_cea_video_data_block()- mode supported: global table index [%d] name [%s]...\n",index, ch7036_get_mode_name(CHANNEL_LVDS_HDMI,index) );
+
+					if( hdmi_timing_table[index-1].fmt_index == hdmi_timing_table[index].fmt_index) {
+
+						break;
+					}
+
+				}
+
+				index++;
+
+			}
+	}
+
+	return;
+}
+
+
+ch7036_status_t ch7036_parse_edid(ch7036_device_context_t* p_ctx)
+{
+
+
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+
+	ch7036_edid_blk_t* p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
+	ch7036_edid_blk_t* p_cedid = (ch7036_edid_blk_t *)p_ctx->cedid;
+
+	unsigned char* p_edidblk=0;
+	ch7036_attr_table_index_t* p_modes = 0;
+	pd_attr_t  *p_attr = NULL ;
+	int RESET =1;
+
+	PD_DEBUG("ch7036_parse_edid()- enter...\n");
+
+
+	//hpd checking schemes
+	if(p_ctx->hpd == 0)
+		return SS_SUCCESS;
+
+
+	if (
+		( (pOutput_Info->channel & 0x02) &&  (p_ctx->hpd & 0x80) )||
+		( (pOutput_Info->channel & 0x04) &&  (p_ctx->hpd & 0x08) )
+		)
+		//parsing is already done
+		return SS_SUCCESS;
+
+
+	switch (pOutput_Info->channel) {
+		case CHANNEL_LVDS_HDMI:
+		case CHANNEL_HDMI:
+			if(p_hedid->is_edid) {
+				p_edidblk = p_hedid->edidblk;
+
+				p_hedid->is_preferred_timing = (p_edidblk[EDID_FEATURE_SUPPORT] >> 1) & 0x1;
+
+
+				if(pOutput_Info->hdmi_fmt.is_dvi_mode == 0) {
+					p_attr = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs, PD_ATTR_ID_HDMI_OUT_MODE, 0);
+					ch7036_parse_cea_edid(p_ctx);
+				}
+				else {
+					p_attr = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs, PD_ATTR_ID_DVI_OUT_MODE, 0);
+					ch7036_parse_standard_edid(p_ctx, CHANNEL_LVDS_HDMI);
+				}
+
+
+
+				p_ctx->hpd |= 0x80; //don't parse again next time
+
+			}
+			else {
+
+				PD_DEBUG("ch7036_parse_edid()- hdmi edid read failed or never done...use default...\n");
+				ch7036_set_edid_display_supported_attr( (void *)p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,p_ctx->downscaled,p_hedid->modes,RESET);
+				p_ctx->hpd &= 0x7F; //allow to enter parsing block again
+
+			}
+
+			p_modes = p_hedid->modes;
+
+			break;
+
+		case CHANNEL_LVDS_VGA:
+		case CHANNEL_VGA:
+			if(p_cedid->is_edid) {
+				p_edidblk = p_cedid->edidblk;
+
+				p_cedid->is_preferred_timing = (p_edidblk[EDID_FEATURE_SUPPORT] >> 1) & 0x1;
+				p_attr = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs, PD_ATTR_ID_CRT_OUT_MODE, 0);
+
+				ch7036_parse_standard_edid(p_ctx, CHANNEL_LVDS_VGA);
+				p_ctx->hpd |= 0x08;
+			}
+			else {
+				PD_DEBUG("ch7036_parse_edid()- vga edid read failed or never done...use default...\n");
+				ch7036_set_edid_display_supported_attr( (void *)p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,p_ctx->downscaled,p_cedid->modes,RESET);
+				p_ctx->hpd &= 0x7F; //allow to enter parsing block again
+			}
+			p_modes = p_cedid->modes;
+
+			break;
+		default:
+			//there is no separate DVI display channel, or LVDS edid reading at this time
+			//DVI display option should already be mapped to HDMI channel
+			p_edidblk = 0;
+
+	}
+
+	if(p_edidblk) {
+
+		ch7036_set_edid_display_supported_attr( (void *)p_attr,0,p_ctx->downscaled,p_modes,0);
+
+	}
+
+	PD_DEBUG("ch7036_parse_edid()- exit...\n");
+
+	return SS_SUCCESS;
+}
+
+
+void ch7036_alter_display_table(int all, void *p_table,unsigned char* p_modes, void* val,unsigned long* p_invis,unsigned char is_invis,unsigned char is_6x4)
+{
+	pd_attr_t  *p_attr;
+	unsigned long i,j;
+
+
+	PD_DEBUG("ch7036_alter_display_table()-enter...\n");
+
+	if(all) {
+		unsigned long* num_attrs = (unsigned long *)val;
+		for(i=0;i<3;i++) { //all 3 tables: hdmi, dvi, vga
+
+			p_attr = pd_get_attr((pd_attr_t *)p_table, *num_attrs, PD_ATTR_ID_HDMI_OUT_MODE+i, 0);
+			if(is_6x4)
+				p_attr++;
+			else
+				p_attr= p_attr + ch7036_invis_6x4_modes_table_size[i] + 1; //1 is to skip header
+
+
+			for(j=0; j < *p_invis;j++) {
+				if(is_invis)
+					p_attr->flags  |= PD_ATTR_FLAG_USER_INVISIBLE;
+				else
+					p_attr->flags  &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+
+				p_attr++;
+			}
+			p_invis++; //now, grab dvi, then vga table size
+
+
+		}
+
+	}
+	else {
+		unsigned long id= 0,k;
+		p_attr = (pd_attr_t *)p_table;
+		id = p_attr->id;
+
+		if(is_6x4) {
+			p_attr++;
+			j=0;
+		}
+		else {
+			p_attr= p_attr + ch7036_invis_6x4_modes_table_size[id - PD_ATTR_ID_HDMI_OUT_MODE] + 1; //point to the first 7x4 entry
+			j= ch7036_invis_6x4_modes_table_size[id - PD_ATTR_ID_HDMI_OUT_MODE];
+		}
+		p_invis = p_invis + (id - PD_ATTR_ID_HDMI_OUT_MODE);
+		k= *p_invis + j;
+
+		for(; j < k;j++) {
+			if(is_invis) {
+				p_attr->flags  |= PD_ATTR_FLAG_USER_INVISIBLE;
+				p_modes[j]=FALSE;
+			}
+
+			p_attr++;
+		}
+
+	}
+}
+
+
+ch7036_status_t ch7036_set_edid_display_supported_attr(void *p_table, unsigned long num_attrs, unsigned char* p_downscaled, unsigned char* p_modes, int is_reset)
+{
+
+	pd_list_attr_t *p_hdr = (pd_list_attr_t *)p_table;
+	pd_attr_t *p_entry = (pd_attr_t *)p_table;
+
+	uint8 i=0;
+
+#ifdef T_SHOW_EDID_DISPLAY_ATTR
+	pd_list_entry_attr_t *list_entry;
+#endif
+
+	PD_DEBUG("ch7036_set_edid_display_supported_attr()-enter... is_reset status = [%d]\n", is_reset);
+
+	if(is_reset) {
+		while (i < MAX_ATTR_LIST_SIZE ) {
+			p_modes[i++] = TRUE;
+		}
+
+
+
+		//special handling for 1080i/p @ 59Hz
+		p_entry = pd_get_attr((pd_attr_t *)p_table, num_attrs, PD_ATTR_ID_HDMI_OUT_MODE, 0);
+		p_entry++;
+		p_entry = p_entry + OUT_HDMI_1920x1080I_59;
+		p_entry->flags  |= PD_ATTR_FLAG_USER_INVISIBLE;
+		p_entry += 2;
+		p_entry->flags  |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+	}
+	else {
+
+		PD_DEBUG("ch7036_set_edid_display_supported_attr()-start to build edid display mode list...\n");
+
+		p_entry++;
+
+		for (i = 0; i < p_hdr->num_entries ; ++i,++p_entry) {
+			if(
+				(p_modes[i] == FALSE) ||
+				//1080 i/p @ 59 Hz
+				((p_hdr->id == PD_ATTR_ID_HDMI_OUT_MODE) && (i == OUT_HDMI_1920x1080I_59 || i== OUT_HDMI_1920x1080P_59) ) ){
+
+				p_entry->flags  |= PD_ATTR_FLAG_USER_INVISIBLE;
+				continue;
+			}
+
+
+			p_entry->flags  &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+		}
+
+
+	}
+
+	//special handling for 8x6,7x4,6x4-
+	ch7036_alter_display_table(is_reset,p_table,p_modes,(void *)&num_attrs,ch7036_invis_6x4_modes_table_size,*p_downscaled,1);
+	p_downscaled++;
+	ch7036_alter_display_table(is_reset,p_table,p_modes,(void *)&num_attrs,ch7036_invis_8x6_7x4_table_size,*p_downscaled,0);
+
+#ifdef T_SHOW_EDID_DISPLAY_ATTR
+
+	list_entry = (pd_list_entry_attr_t *)(p_table);
+
+	for (i = 0,++list_entry; i < p_hdr->num_entries; ++i, ++list_entry)
+		PD_DEBUG("ch7036 : ch7036_set_edid_display_supported_attr : \n"
+				  "list entry[%hhu]=%s, id=%lu, "
+					  "value=%lu, flags=0x%x \n",
+					  i, list_entry->name, list_entry->id,
+					  list_entry->value, (unsigned char)list_entry->flags);
+#endif
+
+
+	return SS_SUCCESS;
+}
+
+
+uint8 * ch7036_get_mode_name(uint32 channel, uint8 index)
+{
+	uint8* str = "Name String Is Not Yet Converted";
+
+	switch (channel) {
+
+		case CHANNEL_LVDS_HDMI:
+			switch (index) {
+				case OUT_HDMI_640x480P_59:
+					return ("OUT_HDMI_640x480P_59");
+				case OUT_HDMI_640x480P_60:
+					return ("OUT_HDMI_640x480P_60");
+				case OUT_HDMI_720x480P_59:
+					return ("OUT_HDMI_720x480P_59");
+				case OUT_HDMI_720x480P_60:
+					return ("OUT_HDMI_720x480P_60");
+				case OUT_HDMI_1280x720P_59:
+					return ("OUT_HDMI_1280x720P_59");
+				case OUT_HDMI_1280x720P_60:
+					return ("OUT_HDMI_1280x720P_60");
+				case OUT_HDMI_1920x1080I_59:
+					return ("OUT_HDMI_1920x1080I_59");
+				case OUT_HDMI_1920x1080I_60:
+					return ("OUT_HDMI_1920x1080I_60");
+				case OUT_HDMI_1920x1080P_59:
+					return ("OUT_HDMI_1920x1080P_59");
+				case OUT_HDMI_1920x1080P_60:
+					return ("OUT_HDMI_1920x1080P_60");
+
+
+			}
+			break;
+
+		case CHANNEL_LVDS_VGA:
+
+			switch (index) {
+
+				case OUT_CRT_640x400_85:
+					return ("OUT_CRT_640x400_85");
+
+				case OUT_CRT_640x480_60:
+					return ("OUT_CRT_640x480_60");
+				case OUT_CRT_640x480_72:
+					return ("OUT_CRT_640x480_72");
+				case OUT_CRT_640x480_75:
+					return ("OUT_CRT_640x480_75");
+				case OUT_CRT_640x480_85:
+					return ("OUT_CRT_640x480_85");
+
+				case OUT_CRT_720x400_85:
+					return ("OUT_CRT_720x400_85");
+
+				case OUT_CRT_800x600_56:
+					return ("OUT_CRT_800x600_56");
+				case OUT_CRT_800x600_60:
+					return ("OUT_CRT_800x600_60");
+				case OUT_CRT_800x600_72:
+					return ("OUT_CRT_800x600_72");
+				case OUT_CRT_800x600_75:
+					return ("OUT_CRT_800x600_75");
+
+				case OUT_CRT_800x600_85:
+					return ("OUT_CRT_800x600_85");
+
+				case OUT_CRT_1024x768_60:
+					return ("OUT_CRT_1024x768_60");
+				case OUT_CRT_1024x768_70:
+					return ("OUT_CRT_1024x768_70");
+				case OUT_CRT_1024x768_75:
+					return ("OUT_CRT_1024x768_75");
+				case OUT_CRT_1024x768_85:
+					return ("OUT_CRT_1024x768_85");
+
+				case OUT_CRT_1152x864_75:
+					return ("OUT_CRT_1152x864_75");
+
+				case OUT_CRT_1280x768_60:
+					return ("OUT_CRT_1280x768_60");
+				case OUT_CRT_1280x768_75:
+					return ("OUT_CRT_1280x768_75");
+				case OUT_CRT_1280x768_85:
+					return ("OUT_CRT_1280x768_85");
+
+				case OUT_CRT_1280x960_60:
+					return ("OUT_CRT_1280x960_60");
+				case OUT_CRT_1280x960_85:
+					return ("OUT_CRT_1280x960_85");
+
+				case OUT_CRT_1280x1024_60:
+					return ("OUT_CRT_1280x1024_60");
+				case OUT_CRT_1280x1024_75:
+					return ("OUT_CRT_1280x1024_75");
+				case OUT_CRT_1280x1024_85:
+					return ("OUT_CRT_1280x1024_85");
+
+				case OUT_CRT_1360x768_60:
+					return ("OUT_CRT_1360x768_60");
+
+				case OUT_CRT_1400x1050_60:
+					return ("OUT_CRT_1400x1050_60");
+				case OUT_CRT_1400x1050_75:
+					return ("OUT_CRT_1400x1050_75");
+
+				case OUT_CRT_1440x900_60:
+					return ("OUT_CRT_1440x900_60");
+
+				case OUT_CRT_1440x1050_60:
+					return ("OUT_CRT_1440x1050_60");
+
+				case OUT_CRT_1600x900_60:
+					return ("OUT_CRT_1600x900_60");
+
+				case OUT_CRT_1600x1200_60:
+					return ("OUT_CRT_1600x1200_60");
+
+				case OUT_CRT_1920x1080_60:
+					return ("OUT_CRT_1920x1080_60");
+
+			}
+			break;
+
+		default:
+			switch (index) {
+				case OUT_DVI_640x480_60:
+					return ("OUT_DVI_640x480_60");
+				case OUT_DVI_640x480_72:
+					return ("OUT_DVI_640x480_72");
+
+				case OUT_DVI_720x400_70:
+					return ("OUT_DVI_720x400_70");
+
+				case OUT_DVI_800x600_56:
+					return ("OUT_DVI_800x600_56");
+				case OUT_DVI_800x600_60:
+					return ("OUT_DVI_800x600_60");
+				case OUT_DVI_800x600_72:
+					return ("OUT_DVI_800x600_72");
+				case OUT_DVI_800x600_75:
+					return ("OUT_DVI_800x600_75");
+
+				case OUT_DVI_1024x768_60:
+					return ("OUT_DVI_1024x768_60");
+				case OUT_DVI_1024x768_70:
+					return ("OUT_DVI_1024x768_70");
+				case OUT_DVI_1024x768_75:
+					return ("OUT_DVI_1024x768_75");
+
+				case OUT_DVI_1152x864_60:
+					return ("OUT_CRT_1152x864_60");
+
+				case OUT_DVI_1280x720_60:
+					return ("OUT_DVI_1280x720_60");
+
+				case OUT_DVI_1280x800_60:
+					return ("OUT_DVI_1280x800_60");
+
+				case OUT_DVI_1280x960_60:
+					return ("OUT_DVI_1280x960_60");
+
+				case OUT_DVI_1280x1024_60:
+					return ("OUT_DVI_1280x1024_60");
+				case OUT_DVI_1280x1024_75:
+					return ("OUT_DVI_1280x1024_75");
+
+				case OUT_DVI_1360x768_60:
+					return ("OUT_DVI_1360x768_60");
+
+				case OUT_DVI_1366x768_60:
+					return ("OUT_DVI_1366x768_60");
+
+				case OUT_DVI_1400x1050_60:
+					return ("OUT_DVI_1400x1050_60");
+				case OUT_DVI_1400x1050_75:
+					return ("OUT_DVI_1400x1050_75");
+
+				case OUT_DVI_1440x900_60:
+					return ("OUT_DVI_1440x900_60");
+
+				case OUT_DVI_1440x1050_60:
+					return ("OUT_DVI_1440x1050_60");
+
+				case OUT_DVI_1600x900_60:
+					return ("OUT_DVI_1600x900_60");
+
+				case OUT_DVI_1600x1200_60:
+					return ("OUT_DVI_1600x1200_60");
+
+				case OUT_DVI_1680x1050_60:
+					return ("OUT_DVI_1680x1050_60");
+
+				case OUT_DVI_1920x1080_60:
+					return ("OUT_DVI_1920x1080_60");
+			}
+			break;
+
+
+	}
+
+
+	return str;
+
+}
 
-#ifdef T_SHOW_EDID_DISPLAY_ATTR
-	pd_list_entry_attr_t *list_entry;
-#endif
-	
-	PD_DEBUG("ch7036_set_edid_display_supported_attr()-enter... is_reset status = [%d]\n", is_reset);
-
-	if(is_reset) {
-		while (i < MAX_ATTR_LIST_SIZE ) {
-			p_modes[i++] = TRUE; 
-		}
-
-		
-		
-		//special handling for 1080i/p @ 59Hz
-		p_entry = pd_get_attr((pd_attr_t *)p_table, num_attrs, PD_ATTR_ID_HDMI_OUT_MODE, 0);
-		p_entry++;
-		p_entry = p_entry + OUT_HDMI_1920x1080I_59;
-		p_entry->flags  |= PD_ATTR_FLAG_USER_INVISIBLE;  
-		p_entry += 2;
-		p_entry->flags  |= PD_ATTR_FLAG_USER_INVISIBLE;  
-
-	}
-	else { 
-
-		PD_DEBUG("ch7036_set_edid_display_supported_attr()-start to build edid display mode list...\n");
-	
-		p_entry++; 
-
-		for (i = 0; i < p_hdr->num_entries ; ++i,++p_entry) { 
-			if( 
-				(p_modes[i] == FALSE) ||
-				//1080 i/p @ 59 Hz
-				((p_hdr->id == PD_ATTR_ID_HDMI_OUT_MODE) && (i == OUT_HDMI_1920x1080I_59 || i== OUT_HDMI_1920x1080P_59) ) ){
-
-				p_entry->flags  |= PD_ATTR_FLAG_USER_INVISIBLE;  
-				continue;
-			}
-		
-
-			p_entry->flags  &= ~PD_ATTR_FLAG_USER_INVISIBLE; 
-
-		}
-
-
-	}
-	
-	//special handling for 8x6,7x4,6x4- 
-	ch7036_alter_display_table(is_reset,p_table,p_modes,(void *)&num_attrs,ch7036_invis_6x4_modes_table_size,*p_downscaled,1);			
-	p_downscaled++;
-	ch7036_alter_display_table(is_reset,p_table,p_modes,(void *)&num_attrs,ch7036_invis_8x6_7x4_table_size,*p_downscaled,0);
-
-#ifdef T_SHOW_EDID_DISPLAY_ATTR
-
-	list_entry = (pd_list_entry_attr_t *)(p_table);
-
-	for (i = 0,++list_entry; i < p_hdr->num_entries; ++i, ++list_entry) 
-		PD_DEBUG("ch7036 : ch7036_set_edid_display_supported_attr : \n"
-				  "list entry[%hhu]=%s, id=%lu, "
-					  "value=%lu, flags=0x%x \n",
-					  i, list_entry->name, list_entry->id,
-					  list_entry->value, (unsigned char)list_entry->flags);
-#endif
-
-
-	return SS_SUCCESS;
-}
-
-
-uint8 * ch7036_get_mode_name(uint32 channel, uint8 index)
-{
-	uint8* str = "Name String Is Not Yet Converted";
-
-	switch (channel) {
-
-		case CHANNEL_LVDS_HDMI:
-			switch (index) {
-				case OUT_HDMI_640x480P_59:
-					return ("OUT_HDMI_640x480P_59");					
-				case OUT_HDMI_640x480P_60:
-					return ("OUT_HDMI_640x480P_60");
-				case OUT_HDMI_720x480P_59:
-					return ("OUT_HDMI_720x480P_59");
-				case OUT_HDMI_720x480P_60:
-					return ("OUT_HDMI_720x480P_60");
-				case OUT_HDMI_1280x720P_59:
-					return ("OUT_HDMI_1280x720P_59");					
-				case OUT_HDMI_1280x720P_60:
-					return ("OUT_HDMI_1280x720P_60");
-				case OUT_HDMI_1920x1080I_59:
-					return ("OUT_HDMI_1920x1080I_59");					
-				case OUT_HDMI_1920x1080I_60:
-					return ("OUT_HDMI_1920x1080I_60");
-				case OUT_HDMI_1920x1080P_59:
-					return ("OUT_HDMI_1920x1080P_59");
-				case OUT_HDMI_1920x1080P_60:
-					return ("OUT_HDMI_1920x1080P_60");
-				
-
-			}
-			break;
-
-		case CHANNEL_LVDS_VGA:
-
-			switch (index) {
-
-				case OUT_CRT_640x400_85:
-					return ("OUT_CRT_640x400_85");
-
-				case OUT_CRT_640x480_60:
-					return ("OUT_CRT_640x480_60");
-				case OUT_CRT_640x480_72:
-					return ("OUT_CRT_640x480_72");
-				case OUT_CRT_640x480_75:
-					return ("OUT_CRT_640x480_75");
-				case OUT_CRT_640x480_85:
-					return ("OUT_CRT_640x480_85");
-
-				case OUT_CRT_720x400_85:
-					return ("OUT_CRT_720x400_85");
-
-				case OUT_CRT_800x600_56:
-					return ("OUT_CRT_800x600_56");
-				case OUT_CRT_800x600_60:
-					return ("OUT_CRT_800x600_60");
-				case OUT_CRT_800x600_72:
-					return ("OUT_CRT_800x600_72");
-				case OUT_CRT_800x600_75:
-					return ("OUT_CRT_800x600_75");
-					
-				case OUT_CRT_800x600_85:
-					return ("OUT_CRT_800x600_85");
-
-				case OUT_CRT_1024x768_60:
-					return ("OUT_CRT_1024x768_60");
-				case OUT_CRT_1024x768_70:
-					return ("OUT_CRT_1024x768_70");
-				case OUT_CRT_1024x768_75:
-					return ("OUT_CRT_1024x768_75");
-				case OUT_CRT_1024x768_85:
-					return ("OUT_CRT_1024x768_85");
-
-				case OUT_CRT_1152x864_75:
-					return ("OUT_CRT_1152x864_75");
-
-				case OUT_CRT_1280x768_60:
-					return ("OUT_CRT_1280x768_60");
-				case OUT_CRT_1280x768_75:
-					return ("OUT_CRT_1280x768_75");
-				case OUT_CRT_1280x768_85:
-					return ("OUT_CRT_1280x768_85");
-
-				case OUT_CRT_1280x960_60:
-					return ("OUT_CRT_1280x960_60");
-				case OUT_CRT_1280x960_85:
-					return ("OUT_CRT_1280x960_85");	
-					
-				case OUT_CRT_1280x1024_60:
-					return ("OUT_CRT_1280x1024_60");
-				case OUT_CRT_1280x1024_75:
-					return ("OUT_CRT_1280x1024_75");
-				case OUT_CRT_1280x1024_85:
-					return ("OUT_CRT_1280x1024_85");
-
-				case OUT_CRT_1360x768_60:
-					return ("OUT_CRT_1360x768_60");
-
-				case OUT_CRT_1400x1050_60:
-					return ("OUT_CRT_1400x1050_60");
-				case OUT_CRT_1400x1050_75:
-					return ("OUT_CRT_1400x1050_75");
-
-				case OUT_CRT_1440x900_60:
-					return ("OUT_CRT_1440x900_60");
-
-				case OUT_CRT_1440x1050_60:
-					return ("OUT_CRT_1440x1050_60");
-
-				case OUT_CRT_1600x900_60:
-					return ("OUT_CRT_1600x900_60");
-
-				case OUT_CRT_1600x1200_60:
-					return ("OUT_CRT_1600x1200_60");	
-					
-				case OUT_CRT_1920x1080_60:
-					return ("OUT_CRT_1920x1080_60");
-
-			}
-			break;
-
-		default: 
-			switch (index) {
-				case OUT_DVI_640x480_60:
-					return ("OUT_DVI_640x480_60"); 
-				case OUT_DVI_640x480_72:
-					return ("OUT_DVI_640x480_72"); 
-
-				case OUT_DVI_720x400_70:
-					return ("OUT_DVI_720x400_70"); 
-
-				case OUT_DVI_800x600_56:
-					return ("OUT_DVI_800x600_56");
-				case OUT_DVI_800x600_60:
-					return ("OUT_DVI_800x600_60"); 
-				case OUT_DVI_800x600_72:
-					return ("OUT_DVI_800x600_72");
-				case OUT_DVI_800x600_75:
-					return ("OUT_DVI_800x600_75");
-
-				case OUT_DVI_1024x768_60:
-					return ("OUT_DVI_1024x768_60");
-				case OUT_DVI_1024x768_70:
-					return ("OUT_DVI_1024x768_70");
-				case OUT_DVI_1024x768_75:
-					return ("OUT_DVI_1024x768_75");
-
-				case OUT_DVI_1152x864_60:
-					return ("OUT_CRT_1152x864_60");
-
-				case OUT_DVI_1280x720_60:
-					return ("OUT_DVI_1280x720_60");
-
-				case OUT_DVI_1280x800_60:
-					return ("OUT_DVI_1280x800_60");
-
-				case OUT_DVI_1280x960_60:
-					return ("OUT_DVI_1280x960_60");
-
-				case OUT_DVI_1280x1024_60:
-					return ("OUT_DVI_1280x1024_60");
-				case OUT_DVI_1280x1024_75:
-					return ("OUT_DVI_1280x1024_75");
-
-				case OUT_DVI_1360x768_60:
-					return ("OUT_DVI_1360x768_60");
-
-				case OUT_DVI_1366x768_60:
-					return ("OUT_DVI_1366x768_60");
-
-				case OUT_DVI_1400x1050_60:
-					return ("OUT_DVI_1400x1050_60");
-				case OUT_DVI_1400x1050_75:
-					return ("OUT_DVI_1400x1050_75");
-
-				case OUT_DVI_1440x900_60:
-					return ("OUT_DVI_1440x900_60");
-
-				case OUT_DVI_1440x1050_60:
-					return ("OUT_DVI_1440x1050_60");
-
-				case OUT_DVI_1600x900_60:
-					return ("OUT_DVI_1600x900_60");
-
-				case OUT_DVI_1600x1200_60:
-					return ("OUT_DVI_1600x1200_60");
-					
-				case OUT_DVI_1680x1050_60:
-					return ("OUT_DVI_1680x1050_60");
-					
-				case OUT_DVI_1920x1080_60:
-					return ("OUT_DVI_1920x1080_60");
-			}
-			break;
-			
-
-	} 
-
-
-	return str;
-
-}
-
 
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.h
index d031396..0efb4da 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.h
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_intf.h
@@ -1,243 +1,243 @@
-/*-----------------------------------------------------------------------------
-* Copyright (c) Chrontel Inc.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy
-* of this software and associated documentation files (the "Software"), to deal
-* in the Software without restriction, including without limitation the rights
-* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-* copies of the Software, and to permit persons to whom the Software is
-* furnished to do so, subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in
-* all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-* THE SOFTWARE.
-*
-*-----------------------------------------------------------------------------
-* @file  ch7036_intf.h
-* @version 1.2.5
-*-----------------------------------------------------------------------------
-*/
-
-
-
-#ifndef _CH7036_INTF_H_
-#define _CH7036_INTF_H_
-
-
-#include <config.h>
-#include <igd_pd.h>
-#include <pd.h>
-#include <pd_print.h>
-
-
-#include "ch7036_typedef.h"
-#include "ch7036_iic.h"
-#include "ch7036.h"
-
-#include "ch7036_fw.h"
-
-
-#include "config_.h"
-
-#ifdef T_LINUX
-#include "asm/div64.h"
-#endif
-
-
-#define internal_lvds_context_t lvds_context_t
-
-typedef unsigned char i2c_reg_t;
-
-
-
-#define DITHER_18_TO_18					0
-#define DITHER_18_TO_24					1
-#define DITHER_24_TO_18					2
-#define DITHER_24_TO_24					3
-
-
-#define DEFAULT_POSITION				2048
-#define DEFAULT_H_1080P_POSITION		2137
-#define HDMI_DEFAULT_UNDERSCAN			15
-#define CRT_DEFAULT_UNDERSCAN			18
-#define DEFAULT_ROTATE					0
-#define DEFAULT_HFLIP					0
-#define DEFAULT_VFLIP					0
-#define DEFAULT_TEXT_ENHANCE			7
-#define DEF_PLL_REF_DLY					0
-#define DEF_PLL_REF_FBDLY				1
-#define DEF_LVDS_TXDRV_CTRL				0
-#define DITHER_ENABLE					0
-#define DITHER_BYPASS					1
-#define MODE_6x4_BYPASS					0
-#define MODE_8x6_7x4_BYPASS				1
-
-
-typedef struct {
-    i2c_reg_t dev_D0 :1; 
-    i2c_reg_t dev_D1 :1;
-    i2c_reg_t dev_D2 :1;
-    i2c_reg_t dev_D3 :1; 
-    i2c_reg_t disp_D0:1; 
-    i2c_reg_t disp_D1:1; 
-    i2c_reg_t disp_D2:1; 
-    i2c_reg_t disp_D3:1; 
-} ch7036_power_states_t;
-
-
-
-typedef unsigned char ch7036_hpd_t;
-
-#define CH7036HPD_RESERVED1						0x01  //force port status inquiry bit
-#define CH7036HPD_CRT_ATTACHED					0x02 
-#define CH7036HPD_CRT_STATUS_CHANGED			0x04 
-#define CH7036HPD_CRT_EDID_PARSING_STATUS		0x08 
-
-#define CH7036HPD_RESERVED2						0x10 //incorrect display choice bit
-#define CH7036HPD_HDVI_ATTACHED					0x20 
-#define CH7036HPD_HDVI_STATUS_CHANGED			0x40 
-#define CH7036HPD_HDVI_EDID_PARSING_STATUS		0x80 
-
-
-typedef struct _ch7036_device_context {
-
-	
-	void						*internal_lvds;	
-	DEV_CONTEXT					*p_ch7xxx_context;  
-    pd_callback_t				*p_callback;
-
-	
-	pd_attr_t					*p_ch7036_attr_table;	
-	pd_attr_t					*p_lvds_attr_table;		
-
-	unsigned long				ch7036_num_attrs; 
-	unsigned long				lvds_num_attrs;	
-	
-	
-	HDMI_OUT_MODE 				hdmi_mode_index;
-	DVI_OUT_MODE 				dvi_mode_index;
-	CRT_OUT_MODE				crt_mode_index;
-
-	
-	pd_timing_t					*p_lvds_table; 
-	
-	
-	
-	
-	pd_timing_t					native_dtd; 
-
-	
-	unsigned short				fp_width;		
-	unsigned short				fp_height;		
-
-	unsigned char				dither_select; 
-
-	
-	unsigned long				pwr_state;		
-	
-	unsigned char				init_done;		
-	
-	
-
-
-	uint8						use_firmware; 
-
-	ch7036_hpd_t				hpd;
-	uint8						man_sel_out;  //auto or manually select display output channel
-
-	uint32						prev_outchannel;  
-	
-	void*						fw;
-	void*						cedid; 
-	void*						hedid; 
-	uint8						downscaled[2]; 
-	uint8						dwnscal_bypass; //1: remove 8x6,&7x4 when downscaling, 0: keep them
-	
-	uint32						last_emsg;	
-	
-} ch7036_device_context_t;
-
-
-
-
-#if 0
-#define PD_INTERNAL_LVDS_MODULE_OPEN(name, params) lvds_open params
-#define PD_INTERNAL_LVDS_MODULE_POST_SET_MODE(name, params) lvds_post_set_mode params
-#define PD_INTERNAL_LVDS_MODULE_SET_MODE(name, params) lvds_set_mode params
-#define PD_INTERNAL_LVDS_MODULE_SET_POWER(name, params) lvds_set_power params
-#define PD_INTERNAL_LVDS_MODULE_INIT_DEVICE(name, params) lvds_init_device params
-#define PD_INTERNAL_LVDS_MODULE_CLOSE(name, params) lvds_close params
-#define PD_INTERNAL_LVDS_MODULE_GET_ATTRIBUTES(name, params) lvds_get_attrs params
-#define PD_INTERNAL_LVDS_MODULE_SET_ATTRIBUTES(name, params) lvds_set_attrs params
-#define PD_INTERNAL_LVDS_MODULE_GET_TIMING_LIST(name, params) lvds_get_timing_list params
-
-#endif
-
-
-
-#define PD_INTERNAL_LVDS_MODULE_OPEN(name, params) internal_lvds_open params
-#define PD_INTERNAL_LVDS_MODULE_POST_SET_MODE(name, params) internal_lvds_post_set_mode params
-#define PD_INTERNAL_LVDS_MODULE_SET_MODE(name, params) internal_lvds_set_mode params
-#define PD_INTERNAL_LVDS_MODULE_SET_POWER(name, params) internal_lvds_set_power params
-#define PD_INTERNAL_LVDS_MODULE_GET_POWER(name, params) internal_lvds_get_power params
-#define PD_INTERNAL_LVDS_MODULE_INIT_DEVICE(name, params) internal_lvds_init_device params
-#define PD_INTERNAL_LVDS_MODULE_CLOSE(name, params) internal_lvds_close params
-#define PD_INTERNAL_LVDS_MODULE_GET_ATTRIBUTES(name, params) internal_lvds_get_attrs params
-#define PD_INTERNAL_LVDS_MODULE_SET_ATTRIBUTES(name, params) internal_lvds_set_attrs params
-#define PD_INTERNAL_LVDS_MODULE_GET_TIMING_LIST(name, params) internal_lvds_get_timing_list params
-#define PD_INTERNAL_LVDS_MODULE_SAVE(name, params) internal_lvds_save params
-#define PD_INTERNAL_LVDS_MODULE_RESTORE(name, params) internal_lvds_restore params
-#define PD_INTERNAL_LVDS_MODULE_GET_PORT_STATUS(name, params) internal_lvds_get_port_status params
-
-
-
-
-ch7036_status_t ch7036_device_prepare(ch7036_device_context_t* p_ctx);
-ch7036_status_t ch7036_device_config(ch7036_device_context_t* p_ctx);
-ch7036_status_t ch7036_device_start(ch7036_device_context_t* p_ctx);
-ch7036_status_t ch7036_device_set_power(ch7036_device_context_t* p_ctx,unsigned long channel);
-
-
-void ch7036_set_input_timing_info(ch7036_device_context_t *p_ctx,INPUT_INFO* pInput_Info);
-void ch7036_set_output_timing_info (ch7036_device_context_t *p_ctx, OUTPUT_INFO* pOutput_Info);
-void ch7036_set_prefer_timing_info(ch7036_device_context_t *p_ctx,PREFER_INFO* pPrefer_Info);
-
-
-
-ch7036_status_t ch7036_load_firmware(ch7036_device_context_t* p_ctx);
-ch7036_status_t ch7036_get_attached_device(ch7036_device_context_t* p_ctx);
-ch7036_status_t ch7036_read_edid(ch7036_device_context_t* p_ctx, uint32 channel);
-ch7036_status_t ch7036_get_hdvi_display_modes_supported(ch7036_device_context_t* p_ctx);
-
-
-uint8 * ch7036_get_mode_name(uint32 channel, uint8 index);
-//void ch7036_reset_edid_supported_modes(unsigned char *p_modes);
-ch7036_status_t ch7036_parse_edid(ch7036_device_context_t* p_ctx);
-ch7036_status_t ch7036_parse_cea_edid(ch7036_device_context_t* p_ctx);
-void ch7036_parse_cea_video_data_block(uint8 blk_size, uint8* p_buff, ch7036_edid_blk_t* p_edid);
-ch7036_status_t ch7036_set_edid_display_supported_attr(void *p_table, unsigned long num_attrs, unsigned char* p_downscaled, unsigned char* p_modes,int is_reset);
-void ch7036_alter_display_table(int all, void *p_table,unsigned char* p_modes, void* val,unsigned long* p_invis,unsigned char is_invis,unsigned char is_6x4);
-
-ch7036_status_t ch7036_parse_standard_edid(ch7036_device_context_t* p_ctx, uint32 channel);
-
-void ch7036_parse_standard_timing(ch7036_edid_blk_t* p_edid, unsigned char* p_addtional_st);
-
-void ch7036_parse_established_timing(ch7036_device_context_t* p_ctx, ch7036_edid_blk_t* p_edid);
-void ch7036_parse_detailed_descriptor_blocks(ch7036_device_context_t* p_ctx, ch7036_edid_blk_t* p_edid);
-void ch7036_parse_detailed_timing(OUT_FMT *p_dt, unsigned char* p_ebuf);
-
-
-void ch7036_reset_mcu(DEV_CONTEXT* p_ch_ctx);
-void ch7036_reset_datapath(DEV_CONTEXT* p_ch_ctx);
-void ch7036_reset(ch7036_device_context_t* p_ctx);
-
-extern uint32 GetLastErrorMessage(void);
-
-#endif  
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_intf.h
+* @version 1.2.5
+*-----------------------------------------------------------------------------
+*/
+
+
+
+#ifndef _CH7036_INTF_H_
+#define _CH7036_INTF_H_
+
+
+#include <config.h>
+#include <igd_pd.h>
+#include <pd.h>
+#include <pd_print.h>
+
+
+#include "ch7036_typedef.h"
+#include "ch7036_iic.h"
+#include "ch7036.h"
+
+#include "ch7036_fw.h"
+
+
+#include "config_.h"
+
+#ifdef T_LINUX
+#include "asm/div64.h"
+#endif
+
+
+#define internal_lvds_context_t lvds_context_t
+
+typedef unsigned char i2c_reg_t;
+
+
+
+#define DITHER_18_TO_18					0
+#define DITHER_18_TO_24					1
+#define DITHER_24_TO_18					2
+#define DITHER_24_TO_24					3
+
+
+#define DEFAULT_POSITION				2048
+#define DEFAULT_H_1080P_POSITION		2137
+#define HDMI_DEFAULT_UNDERSCAN			15
+#define CRT_DEFAULT_UNDERSCAN			18
+#define DEFAULT_ROTATE					0
+#define DEFAULT_HFLIP					0
+#define DEFAULT_VFLIP					0
+#define DEFAULT_TEXT_ENHANCE			7
+#define DEF_PLL_REF_DLY					0
+#define DEF_PLL_REF_FBDLY				1
+#define DEF_LVDS_TXDRV_CTRL				0
+#define DITHER_ENABLE					0
+#define DITHER_BYPASS					1
+#define MODE_6x4_BYPASS					0
+#define MODE_8x6_7x4_BYPASS				1
+
+
+typedef struct {
+    i2c_reg_t dev_D0 :1;
+    i2c_reg_t dev_D1 :1;
+    i2c_reg_t dev_D2 :1;
+    i2c_reg_t dev_D3 :1;
+    i2c_reg_t disp_D0:1;
+    i2c_reg_t disp_D1:1;
+    i2c_reg_t disp_D2:1;
+    i2c_reg_t disp_D3:1;
+} ch7036_power_states_t;
+
+
+
+typedef unsigned char ch7036_hpd_t;
+
+#define CH7036HPD_RESERVED1						0x01  //force port status inquiry bit
+#define CH7036HPD_CRT_ATTACHED					0x02
+#define CH7036HPD_CRT_STATUS_CHANGED			0x04
+#define CH7036HPD_CRT_EDID_PARSING_STATUS		0x08
+
+#define CH7036HPD_RESERVED2						0x10 //incorrect display choice bit
+#define CH7036HPD_HDVI_ATTACHED					0x20
+#define CH7036HPD_HDVI_STATUS_CHANGED			0x40
+#define CH7036HPD_HDVI_EDID_PARSING_STATUS		0x80
+
+
+typedef struct _ch7036_device_context {
+
+
+	void						*internal_lvds;
+	DEV_CONTEXT					*p_ch7xxx_context;
+    pd_callback_t				*p_callback;
+
+
+	pd_attr_t					*p_ch7036_attr_table;
+	pd_attr_t					*p_lvds_attr_table;
+
+	unsigned long				ch7036_num_attrs;
+	unsigned long				lvds_num_attrs;
+
+
+	HDMI_OUT_MODE 				hdmi_mode_index;
+	DVI_OUT_MODE 				dvi_mode_index;
+	CRT_OUT_MODE				crt_mode_index;
+
+
+	pd_timing_t					*p_lvds_table;
+
+
+
+
+	pd_timing_t					native_dtd;
+
+
+	unsigned short				fp_width;
+	unsigned short				fp_height;
+
+	unsigned char				dither_select;
+
+
+	unsigned long				pwr_state;
+
+	unsigned char				init_done;
+
+
+
+
+	uint8						use_firmware;
+
+	ch7036_hpd_t				hpd;
+	uint8						man_sel_out;  //auto or manually select display output channel
+
+	uint32						prev_outchannel;
+
+	void*						fw;
+	void*						cedid;
+	void*						hedid;
+	uint8						downscaled[2];
+	uint8						dwnscal_bypass; //1: remove 8x6,&7x4 when downscaling, 0: keep them
+
+	uint32						last_emsg;
+
+} ch7036_device_context_t;
+
+
+
+
+#if 0
+#define PD_INTERNAL_LVDS_MODULE_OPEN(name, params) lvds_open params
+#define PD_INTERNAL_LVDS_MODULE_POST_SET_MODE(name, params) lvds_post_set_mode params
+#define PD_INTERNAL_LVDS_MODULE_SET_MODE(name, params) lvds_set_mode params
+#define PD_INTERNAL_LVDS_MODULE_SET_POWER(name, params) lvds_set_power params
+#define PD_INTERNAL_LVDS_MODULE_INIT_DEVICE(name, params) lvds_init_device params
+#define PD_INTERNAL_LVDS_MODULE_CLOSE(name, params) lvds_close params
+#define PD_INTERNAL_LVDS_MODULE_GET_ATTRIBUTES(name, params) lvds_get_attrs params
+#define PD_INTERNAL_LVDS_MODULE_SET_ATTRIBUTES(name, params) lvds_set_attrs params
+#define PD_INTERNAL_LVDS_MODULE_GET_TIMING_LIST(name, params) lvds_get_timing_list params
+
+#endif
+
+
+
+#define PD_INTERNAL_LVDS_MODULE_OPEN(name, params) internal_lvds_open params
+#define PD_INTERNAL_LVDS_MODULE_POST_SET_MODE(name, params) internal_lvds_post_set_mode params
+#define PD_INTERNAL_LVDS_MODULE_SET_MODE(name, params) internal_lvds_set_mode params
+#define PD_INTERNAL_LVDS_MODULE_SET_POWER(name, params) internal_lvds_set_power params
+#define PD_INTERNAL_LVDS_MODULE_GET_POWER(name, params) internal_lvds_get_power params
+#define PD_INTERNAL_LVDS_MODULE_INIT_DEVICE(name, params) internal_lvds_init_device params
+#define PD_INTERNAL_LVDS_MODULE_CLOSE(name, params) internal_lvds_close params
+#define PD_INTERNAL_LVDS_MODULE_GET_ATTRIBUTES(name, params) internal_lvds_get_attrs params
+#define PD_INTERNAL_LVDS_MODULE_SET_ATTRIBUTES(name, params) internal_lvds_set_attrs params
+#define PD_INTERNAL_LVDS_MODULE_GET_TIMING_LIST(name, params) internal_lvds_get_timing_list params
+#define PD_INTERNAL_LVDS_MODULE_SAVE(name, params) internal_lvds_save params
+#define PD_INTERNAL_LVDS_MODULE_RESTORE(name, params) internal_lvds_restore params
+#define PD_INTERNAL_LVDS_MODULE_GET_PORT_STATUS(name, params) internal_lvds_get_port_status params
+
+
+
+
+ch7036_status_t ch7036_device_prepare(ch7036_device_context_t* p_ctx);
+ch7036_status_t ch7036_device_config(ch7036_device_context_t* p_ctx);
+ch7036_status_t ch7036_device_start(ch7036_device_context_t* p_ctx);
+ch7036_status_t ch7036_device_set_power(ch7036_device_context_t* p_ctx,unsigned long channel);
+
+
+void ch7036_set_input_timing_info(ch7036_device_context_t *p_ctx,INPUT_INFO* pInput_Info);
+void ch7036_set_output_timing_info (ch7036_device_context_t *p_ctx, OUTPUT_INFO* pOutput_Info);
+void ch7036_set_prefer_timing_info(ch7036_device_context_t *p_ctx,PREFER_INFO* pPrefer_Info);
+
+
+
+ch7036_status_t ch7036_load_firmware(ch7036_device_context_t* p_ctx);
+ch7036_status_t ch7036_get_attached_device(ch7036_device_context_t* p_ctx);
+ch7036_status_t ch7036_read_edid(ch7036_device_context_t* p_ctx, uint32 channel);
+ch7036_status_t ch7036_get_hdvi_display_modes_supported(ch7036_device_context_t* p_ctx);
+
+
+uint8 * ch7036_get_mode_name(uint32 channel, uint8 index);
+//void ch7036_reset_edid_supported_modes(unsigned char *p_modes);
+ch7036_status_t ch7036_parse_edid(ch7036_device_context_t* p_ctx);
+ch7036_status_t ch7036_parse_cea_edid(ch7036_device_context_t* p_ctx);
+void ch7036_parse_cea_video_data_block(uint8 blk_size, uint8* p_buff, ch7036_edid_blk_t* p_edid);
+ch7036_status_t ch7036_set_edid_display_supported_attr(void *p_table, unsigned long num_attrs, unsigned char* p_downscaled, unsigned char* p_modes,int is_reset);
+void ch7036_alter_display_table(int all, void *p_table,unsigned char* p_modes, void* val,unsigned long* p_invis,unsigned char is_invis,unsigned char is_6x4);
+
+ch7036_status_t ch7036_parse_standard_edid(ch7036_device_context_t* p_ctx, uint32 channel);
+
+void ch7036_parse_standard_timing(ch7036_edid_blk_t* p_edid, unsigned char* p_addtional_st);
+
+void ch7036_parse_established_timing(ch7036_device_context_t* p_ctx, ch7036_edid_blk_t* p_edid);
+void ch7036_parse_detailed_descriptor_blocks(ch7036_device_context_t* p_ctx, ch7036_edid_blk_t* p_edid);
+void ch7036_parse_detailed_timing(OUT_FMT *p_dt, unsigned char* p_ebuf);
+
+
+void ch7036_reset_mcu(DEV_CONTEXT* p_ch_ctx);
+void ch7036_reset_datapath(DEV_CONTEXT* p_ch_ctx);
+void ch7036_reset(ch7036_device_context_t* p_ctx);
+
+extern uint32 GetLastErrorMessage(void);
+
+#endif
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.c b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.c
index 7d4e496..1467b7b 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.c
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.c
@@ -1,1548 +1,1548 @@
-/*-----------------------------------------------------------------------------
-* Copyright (c) Chrontel Inc.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy
-* of this software and associated documentation files (the "Software"), to deal
-* in the Software without restriction, including without limitation the rights
-* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-* copies of the Software, and to permit persons to whom the Software is
-* furnished to do so, subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in
-* all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-* THE SOFTWARE.
-*
-*-----------------------------------------------------------------------------
-* @file  ch7036_port.c
-* @version 1.2.5
-*-----------------------------------------------------------------------------
-*/
-
-
-#include <linux/kernel.h>
-
-#include "ch7036_port.h"
-
-
-#ifdef T_LINUX
-	#include "lvds/lvds.h"
-#else
-	#include "lvds.h"
-#endif
-
-
-
-static pd_version_t  g_ch7036_version = {1, 2, 5, 0};
-static unsigned long g_ch7036_dab_list[] = {0xEC,PD_DAB_LIST_END};
-
-
-void ch7036_update_position(ch7036_device_context_t *p_ctx, OUTPUT_INFO* pOutput_Info);
-int ch7036_initialize_device(ch7036_device_context_t *p_ctx);
-
-
-static pd_driver_t	 g_ch7036_drv = {
-	PD_SDK_VERSION,
-	"Chrontel CH7036 Port Driver",
-	0,
-	&g_ch7036_version,
-	PD_DISPLAY_LVDS_INT,
-	PD_FLAG_UP_SCALING,
-	g_ch7036_dab_list,
-	100,
-	ch7036_validate,
-	ch7036_open,
-	ch7036_init_device,
-	ch7036_close,
-	ch7036_set_mode,
-	ch7036_post_set_mode,
-	ch7036_set_attributes,
-	ch7036_get_attributes,
-	ch7036_get_timing_list,
-	ch7036_set_power,
-	ch7036_get_power,
-	ch7036_save,
-	ch7036_restore,
-	ch7036_get_port_status
-};
-
-
-extern established_timings_t et_I[8];
-extern established_timings_t et_II[8];
-extern established_timings_t et_man;
-
-
-int PD_MODULE_INIT(ch7036_init, (void *handle))
-{
-	int status;
-
-	PD_DEBUG("ch7036: ch7036_init()\n");
-
-	status = pd_register(handle, &g_ch7036_drv);
-	if (status != PD_SUCCESS) {
-		PD_DEBUG("ch7036: Error ! ch7036_init: pd_register() failed with "
-				  "status=%#x\n", status);  
-	}
-	return status;
-}
-
-
-
-int PD_MODULE_EXIT(ch7036_exit, (void))
-{
-	PD_DEBUG("ch7036: ch7036_exit()\n");
-
-	return (PD_SUCCESS);
-} 
-
-
-unsigned long ch7036_validate(unsigned long cookie)
-{
-	PD_DEBUG("ch7036: ch7036_validate()\n");
-	
-	return cookie;
-}
-
-
-int ch7036_open(pd_callback_t *p_callback, void **pp_context)
-{
-	uint8 device_ID;
-	ch7036_device_context_t* p_ctx;
-	DEV_CONTEXT* p_ch7xxx_context;
-
-	ch7036_edid_blk_t *p_edid1, *p_edid2;
-
-		
-	int ret;
-
-
-	
-	PD_DEBUG("ch7036: ch7036_open()- enter- ch7036 pd release- major [%x] minor [%x] patch [%x]\n",
-		g_ch7036_version.major,g_ch7036_version.minor,g_ch7036_version.patch);
-	
-	ret = PD_INTERNAL_LVDS_MODULE_OPEN(ch7036_lvds_open,(p_callback, pp_context));
-	if ( ret != PD_SUCCESS)
-	{
-
-
-		PD_ERROR("ch7036: ch7036_open: EXIT#1\n");
-		return ret;	
-	}
-	
-	p_ctx = pd_malloc(sizeof(ch7036_device_context_t));
-	if (p_ctx == NULL) {
-		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed\n");
-		goto exit6;
-	}
-
-	pd_memset(p_ctx, 0, sizeof(ch7036_device_context_t));
-	
-	/* per EMGD request */
-	p_edid1 = (ch7036_edid_blk_t *)p_ctx->cedid;
-	p_edid2 = (ch7036_edid_blk_t *)p_ctx->hedid;
-
-
-	p_ctx->fw = (FW7036_CFG *)(pd_malloc(sizeof(FW7036_CFG)));
-	
-	if (p_ctx->fw == NULL) {
-		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating FW7036_CFG struct\n");
-		goto exit5;
-	}
-
-#if 0	
-	ret = PD_INTERNAL_LVDS_MODULE_OPEN(ch7036_lvds_open,(p_callback, pp_context));
-	if ( ret != PD_SUCCESS)
-	{
-		pd_free(p_ctx->fw);
-		pd_free(p_ctx);		
-		return ret;	
-	}
-#endif
-	
-	p_ctx->internal_lvds = *pp_context; 
-
-	p_ctx->p_callback = p_callback;
-
-#ifdef LVDS_ONLY
-	*pp_context = (void *)p_ctx;
-	return (PD_SUCCESS);
-#endif
-
-	
-	
-	p_ctx->p_ch7xxx_context = pd_malloc(sizeof(DEV_CONTEXT));
-	if (p_ctx->p_ch7xxx_context == NULL) {
-		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating DEV_CONTEXT struct");
-		goto exit4;
-	}
-	
-	p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	
-	p_ch7xxx_context->pd_context = (void *)p_ctx;
-
-
-	
-	I2CWrite(p_ch7xxx_context,0x03, 0x04); 
-	
-	device_ID = I2CRead(p_ch7xxx_context,0x50); 	
-  
-	PD_DEBUG("ch7036: ch7036_open()- read device ID= 0x%.2X\n", device_ID);
-
-
-	if(device_ID != 0x56)
-	{
-		PD_DEBUG("ch7036: ch7036_open()- device is NOT found...\n");
-
-		if(p_ch7xxx_context->pd_context)
-			p_ch7xxx_context->pd_context=NULL;
-		pd_free(p_ch7xxx_context);
-		if(p_ctx->internal_lvds) {
-			p_ctx->internal_lvds=NULL;
-
-		}
-		pd_free(p_ctx->fw);
-		pd_free(p_ctx);
-		return PD_ERR_NODEV;
-		
-	}
-	else
-	{
-		PD_DEBUG("ch7036: ch7036_open()- ch7036 device is found...\n");
-
-		
-	}
-
-	p_ch7xxx_context->DeviceID = device_ID;
-
-	ch7036_reset(p_ctx);
-	pd_usleep(50); 	
-		
-	if (ch7036_load_firmware(p_ctx) != SS_SUCCESS)   { 
-		p_ctx->use_firmware =0;
-		p_ctx->cedid = NULL;
-		p_ctx->hedid = NULL;
-		
-	}
-	else {
-		p_ctx->use_firmware =1;
-
-
-		p_ctx->cedid = (ch7036_edid_blk_t *)pd_malloc(sizeof(ch7036_edid_blk_t));
-
-		if (p_ctx->cedid == NULL) {
-			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating ch7036_edid_blk_t struct for crt");
-			goto exit3;
-		}
-
-		p_edid1 = (ch7036_edid_blk_t *)p_ctx->cedid ;
-
-		p_edid1->etiming_I = (established_timings_t *)pd_malloc(8 * sizeof(established_timings_t));
-		if (p_edid1->etiming_I == NULL) {
-			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating established_timings_t struct I for crt");
-			pd_free(p_ctx->cedid);
-			goto exit3;
-		}
-		p_edid1->etiming_II = (established_timings_t *)pd_malloc(8 * sizeof(established_timings_t));
-		if (p_edid1->etiming_II == NULL) {
-			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating established_timings_t struct II for crt");
-			pd_free(p_edid1->etiming_I);
-			pd_free(p_ctx->cedid);
-			goto exit3;
-		}
-
-		p_ctx->hedid = (ch7036_edid_blk_t *)pd_malloc(sizeof(ch7036_edid_blk_t));
-
-		if (p_ctx->hedid == NULL) {
-			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating ch7036_edid_blk_t struct for hdvi");
-			pd_free(p_edid1->etiming_I);
-			pd_free(p_edid1->etiming_II);
-			pd_free(p_ctx->cedid);
-
-			goto exit3;
-		}
-
-		p_edid2 = (ch7036_edid_blk_t *)p_ctx->hedid ;
-
-		p_edid2->etiming_I = (established_timings_t *)pd_malloc(8 * sizeof(established_timings_t));
-		if (p_edid2->etiming_I == NULL) {
-			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating established_timings_t struct I for crt");
-			pd_free(p_edid1->etiming_I);
-			pd_free(p_edid1->etiming_II);
-			pd_free(p_ctx->cedid);
-			pd_free(p_ctx->hedid);
-
-			goto exit3;
-		}
-
-		p_edid2->etiming_II = (established_timings_t *)pd_malloc(8 * sizeof(established_timings_t));
-
-		if (p_edid2->etiming_II == NULL) {
-			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating established_timings_t struct for hdvi");
-			pd_free(p_edid1->etiming_I);
-			pd_free(p_edid1->etiming_II);
-			pd_free(p_ctx->cedid);
-			pd_free(p_edid2->etiming_I);
-
-			pd_free(p_ctx->hedid);
-
-			goto exit3;
-		}
-
-
-	}
-
-	
-	pd_memset(p_edid1->etiming_I, 0, 8 *
-			sizeof(established_timings_t));
-	pd_memset(p_edid1->etiming_II, 0, 8 *
-			sizeof(established_timings_t));
-
-	pd_memset(p_edid2->etiming_I, 0, 8 *
-			sizeof(established_timings_t));
-	pd_memset(p_edid2->etiming_II, 0, 8 *
-			sizeof(established_timings_t));
-
-
-
-
-
-
-	
-	p_ch7xxx_context->pInput_Info = pd_malloc(sizeof(INPUT_INFO));
-	if (p_ch7xxx_context->pInput_Info == NULL) {
-		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating INPUT_INFO struct");
-
-		goto exit23; 
-	}
-
-	p_ch7xxx_context->pOutput_Info = pd_malloc(sizeof(OUTPUT_INFO));
-	if (p_ch7xxx_context->pOutput_Info == NULL) {
-		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating OUTPUT_INFO struct");
-
-		goto exit2;
-	}
-
-	p_ch7xxx_context->pPrefer_Info = pd_malloc(sizeof(PREFER_INFO));
-	if (p_ch7xxx_context->pPrefer_Info == NULL) {
-		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating PREFER_INFO struct");
-		
-		goto exit1;
-	}
-
-	
-
-
-	p_ctx->p_ch7036_attr_table = NULL;
-	
-	if( ch7036_init_attribute_table(p_ctx, NULL) == SS_MEM_ALLOC_ERR)
-	{
-		pd_free(p_ch7xxx_context->pPrefer_Info);
-		goto exit1;
-	}
-
-	
-	ch7036_initialize_device(p_ctx);
-	
-	g_ch7036_drv.type = PD_DISPLAY_LVDS_INT; 
-
-	
-	*pp_context = (void *)p_ctx;
-
-	PD_DEBUG("ch7036: ch7036_open: EXIT w/ SUCCESS...ch7036 pd release- major [%x] minor [%x] patch [%x]\n",
-		g_ch7036_version.major,g_ch7036_version.minor,g_ch7036_version.patch);
-	return (PD_SUCCESS);
-
-exit1:
-	pd_free(p_ch7xxx_context->pOutput_Info);
-exit2:
-	pd_free(p_ch7xxx_context->pInput_Info);
-
-exit23:
-	pd_free(p_edid1->etiming_I);
-	pd_free(p_edid1->etiming_II);
-	pd_free(p_ctx->cedid);
-	pd_free(p_edid2->etiming_I);
-	pd_free(p_edid2->etiming_II);
-	pd_free(p_ctx->hedid);
-
-exit3:
-	p_ch7xxx_context->pd_context=NULL; 
-	pd_free(p_ch7xxx_context);
-exit4:
-
-	p_ctx->internal_lvds = NULL;
-	pd_free(p_ctx->fw);
-exit5:
-	pd_free(p_ctx);
-exit6:
-	PD_ERROR("ch7036: ch7036_open: EXIT- PD_ERR_NOMEM\n");
-	return PD_ERR_NOMEM;
-}
-
-
-int ch7036_init_device(void *p_context)
-{
-	ch7036_device_context_t* p_ctx  = (ch7036_device_context_t*)p_context;
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
-	int ret;
-
-	PD_DEBUG("ch7036: ch7036_init_device()-enter\n");
-
-	p_ctx->init_done = 1;
-	ret= PD_INTERNAL_LVDS_MODULE_INIT_DEVICE(ch7036_lvds_init_device, (p_ctx->internal_lvds));
-
-	p_ctx->prev_outchannel = pOutput_Info->channel;
-	PD_DEBUG("ch7036: ch7036_init_device()-p_ctx->prev_outchannel = pOutput_Info->channel = [0x%x]\n",pOutput_Info->channel);
-
-	PD_DEBUG("ch7036: ch7036_init_device()-exit\n");
-	return ret;
-	
-}
-
-
-
-int ch7036_set_mode(void *p_context, pd_timing_t *p_mode, unsigned long flags)
-{
-
-	ch7036_device_context_t *p_ctx = (ch7036_device_context_t*)p_context;
-	
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	INPUT_INFO* pInput_Info = p_ch7xxx_context->pInput_Info;
-	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
-	PREFER_INFO* pPrefer_Info = p_ch7xxx_context->pPrefer_Info;
-	int ret, channel_on=0;
-
-	
-	PD_DEBUG("ch7036: ch7036_set_mode()-enter\n");
-
-
-	if (!p_ctx || !p_mode) {
-		return (PD_ERR_NULL_PTR);
-	}
-
-	if (p_ch7xxx_context->DeviceID != 0x56)
-	{
-		return (PD_ERR_NULL_PTR);
-	}
-
-	PD_DEBUG("ch7036_set_mode: requested width = %u height = %u\n",
-		p_mode->width, p_mode->height);
-
-#ifndef LVDS_ONLY	
-	if (
-		(p_ctx->fp_width && (p_mode->width > p_ctx->fp_width)) ||
-		(p_ctx->fp_height && (p_mode->height > p_ctx->fp_height))
-		) {
-		return PD_ERR_MODE_NOTSUPP;
-	}
-	
-	if( (p_ctx->fp_width == 640) && (p_ctx->fp_height == 480) ) {
-		p_ctx->downscaled[MODE_6x4_BYPASS] = 0;
-	}
-	else { 
-		p_ctx->downscaled[MODE_6x4_BYPASS] = 1;
-		if( (!p_ctx->dwnscal_bypass) || ((p_ctx->fp_width <= 800) && (p_ctx->fp_height <= 600) )  ) 
-			p_ctx->downscaled[MODE_8x6_7x4_BYPASS] = 0;
-		else
-			p_ctx->downscaled[MODE_8x6_7x4_BYPASS] = 1;
-
-	}
-
-	if(pOutput_Info->channel  == CHANNEL_LVDS_HDMI_VGA_OFF) { 
-		
-		pOutput_Info->channel = p_ctx->prev_outchannel; //restore output channel before temp. power down
-		channel_on =1;
-	}
-	
-	
-	if (pOutput_Info->channel == CHANNEL_LVDS) {  
-
-		pOutput_Info->channel = CHANNEL_LVDS_HDMI;	//force both channel on before setting in/out timing
-
-	}
-
-
-	ch7036_set_input_timing_info(p_ctx,pInput_Info);
-	ch7036_set_output_timing_info(p_ctx, pOutput_Info);
-	ch7036_set_prefer_timing_info(p_ctx,pPrefer_Info);
-
-	
-	if(ch7036_device_prepare(p_ctx)== SS_UNSUCCESSFUL)
-	{
-		PD_DEBUG("ch7036_set_mode: ch7036_device_prepare()- NOT SUCCESS... ERROR CODE [%lu]\n", p_ctx->last_emsg);		
-		return PD_ERR_UNSUCCESSFUL;  
-	}
-
-	
-	ch7036_update_position(p_ctx, pOutput_Info);
-
-	if(ch7036_device_config(p_ctx) == SS_UNSUCCESSFUL)
-	{
-		PD_DEBUG("ch7036_set_mode: ch7036_device_config()- NOT SUCCESS...ERROR CODE [%lu]\n", p_ctx->last_emsg);
-		return PD_ERR_UNSUCCESSFUL; 
-	}
-
-	if(channel_on) {
-		
-		pOutput_Info->channel = CHANNEL_LVDS_HDMI_VGA_OFF; //now, power down if it's tmp. powered up
-		
-	}
-
-#endif
-
-	ret = PD_INTERNAL_LVDS_MODULE_SET_MODE(ch7036_lvds_set_mode,(p_ctx->internal_lvds,p_mode,flags));
-	if(ret != PD_SUCCESS)
-		return ret; 
-
-	
-	return PD_SUCCESS;
-}
-//thua- 10/24/11- when user switches back and forth from VGA to HDMI or vice versa
-//need to set h/v pos. accordingly
-void ch7036_update_position(ch7036_device_context_t *p_ctx, OUTPUT_INFO* pOutput_Info)
-{
-	
-	PD_DEBUG("ch7036: ch7036_update_position()- enter\n");
-
-	
-	if(pOutput_Info->channel & CHANNEL_HDMI) {	 	
-		pOutput_Info->h_position = DEFAULT_POSITION; 
-		pOutput_Info->v_position = DEFAULT_POSITION;
-				
-	}
-
-	else { //pOutput_Info->channel & CHANNEL_VGA; note that CHANNEL_LVDS would never come here
-		
-			pOutput_Info->h_position = (uint16)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_HPOSITION,
-					PD_GET_ATTR_LIST)->current_value;
-
-			pOutput_Info->v_position = (uint16)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_VPOSITION,
-					PD_GET_ATTR_LIST)->current_value;
-		
-	}
-
-	PD_DEBUG("ch7036: ch7036_update_position()- h pos [%d]\n",pOutput_Info->h_position);
-	PD_DEBUG("ch7036: ch7036_update_position()- v pos [%d]\n",pOutput_Info->v_position);
-
-	return;
-}
-
-
-int ch7036_post_set_mode(void *p_context, pd_timing_t *p_mode,
-						  unsigned long flags)
-{
-	
-
-	ch7036_device_context_t* p_ctx  = (ch7036_device_context_t*)p_context;
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
-	int ret;
-	
-	
-	
-	
-
-	if (!p_ctx || !p_mode ) {
-		return (PD_ERR_NULL_PTR);
-	}
-
-	if (p_ch7xxx_context->DeviceID != 0x56)
-	{
-		return (PD_ERR_NULL_PTR);
-	}
-
-#ifndef LVDS_ONLY
-
-	
-		
-	ch7036_set_output_channel(p_ctx, p_ctx->prev_outchannel);	
-	PD_DEBUG("ch7036_post_set_mode- now, current pOutput_Info->channel is [%x]\n",pOutput_Info->channel);
-
-	if(ch7036_device_start(p_ctx) == SS_UNSUCCESSFUL)
-	{
-		PD_DEBUG("ch7036_post_set_mode: ch7036_device_start()- NOT SUCCESS\n");
-		return PD_ERR_UNSUCCESSFUL; 
-	}
-
-	
-	
-
-
-#endif
-
-	
-	ret = PD_INTERNAL_LVDS_MODULE_POST_SET_MODE(ch7036_lvds_post_set_mode,(p_ctx->internal_lvds,p_mode,flags));
-
-#ifndef LVDS_ONLY	
-	if(ret != PD_SUCCESS)
-		return ret; 
-	else
-	{
-		
-		ch7036_reset_datapath(p_ch7xxx_context);
-		pd_usleep(50); 
-
-			
-		ch7036_device_set_power(p_ctx, pOutput_Info->channel);	
-		
-		p_ctx->prev_outchannel = pOutput_Info->channel; 
-	}
-
-#endif
-
-	return PD_SUCCESS;
-}
-
-
-
-
-
-int ch7036_close(void *p_context)
-{
-	
-	ch7036_device_context_t* p_ctx  = (ch7036_device_context_t*)p_context;
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	ch7036_edid_blk_t *p_edid1, *p_edid2;
-
-	p_edid1 = (ch7036_edid_blk_t *)p_ctx->cedid;
-	p_edid2 = (ch7036_edid_blk_t *)p_ctx->hedid;
-
-
-	PD_DEBUG("ch7036: ch7036_close()\n");
-
-#ifndef LVDS_ONLY
-	
-	ch7036_set_power(p_context, PD_POWER_MODE_D3);	
-#endif
-
-	PD_INTERNAL_LVDS_MODULE_CLOSE(ch7036_lvds_close, (p_ctx->internal_lvds));
-
-	if (p_ctx!= NULL) 
-	{
-		
-		if(p_ctx->p_ch7xxx_context) {
-
-			pd_free(p_ch7xxx_context->pInput_Info);
-			p_ch7xxx_context->pInput_Info = NULL;
-
-			pd_free(p_ch7xxx_context->pOutput_Info);
-			p_ch7xxx_context->pOutput_Info = NULL;
-
-			pd_free(p_ch7xxx_context->pPrefer_Info);
-			p_ch7xxx_context->pPrefer_Info = NULL;
-
-			pd_free(p_ctx->p_ch7xxx_context);
-			p_ch7xxx_context = NULL;
-		}
-
-		
-		if(p_edid1) {
-			pd_free(p_edid1->etiming_I);
-			pd_free(p_edid1->etiming_II);
-			pd_free(p_ctx->cedid);
-
-			p_edid1->etiming_I=NULL;
-			p_edid1->etiming_II=NULL;
-			p_ctx->cedid = NULL;
-
-		}
-		if(p_edid2) {
-			pd_free(p_edid2->etiming_I);
-			pd_free(p_edid2->etiming_II);
-			pd_free(p_ctx->hedid);
-
-			p_edid2->etiming_I=NULL;
-			p_edid2->etiming_II=NULL;
-			p_ctx->hedid = NULL;
-
-		}
-
-		if ( p_ctx->p_ch7036_attr_table) {
-			pd_free(p_ctx->p_ch7036_attr_table);
-			p_ctx->p_ch7036_attr_table = NULL;
-			p_ctx->ch7036_num_attrs = 0;
-		}
-
-		if(p_ctx->fw) {
-			pd_free(p_ctx->fw);
-			p_ctx->fw = NULL;
-		}
-
-
-		pd_free(p_ctx);
-		p_ctx = NULL;
-	}
-	
-	return PD_SUCCESS;
-}
-
-
-int ch7036_get_timing_list(void *p_context, pd_timing_t *p_in_list,
-	pd_timing_t **pp_out_list)
-{
-	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-		
-	int ret = 0;
-	
-
-#ifndef T_PANEL_NATIVE_DTD
-	int i;
-	pd_timing_t * p_table;
-	lvds_context_t * p_lvds = (lvds_context_t *)(p_ctx->internal_lvds);
-
-#endif
-
-	pd_port_status_t port_status;
-
-
-
-	PD_DEBUG("ch7036: ch7036_get_timing_list()-enter\n");
-
-	if (p_ch7xxx_context->DeviceID != 0x56)
-	{
-		return (PD_ERR_NODEV);
-	}
-
-#ifdef LVDS_ONLY
-	PD_DEBUG("NUHAIRI: p_ctx->internal_lvds = %lu\n", p_ctx->internal_lvds);
-	if (p_ctx->internal_lvds != NULL){
-		PD_DEBUG("NUHAIRI: p_ctx->internal_lvds = %lu\n", p_ctx->internal_lvds);
-		return PD_INTERNAL_LVDS_MODULE_GET_TIMING_LIST(ch7036_get_timing_list, (p_ctx->internal_lvds,p_in_list,pp_out_list));
-	}
-	return PD_SUCCESS;
-#endif
-
-
-	
-	if ( (g_ch7036_drv.type & PD_DISPLAY_LVDS_INT) || (g_ch7036_drv.type & PD_DISPLAY_LVDS_LHDV) )
-	{
-		ret = PD_INTERNAL_LVDS_MODULE_GET_TIMING_LIST(ch7036_lvds_get_timing_list, (p_ctx->internal_lvds,p_in_list,pp_out_list));
-
-		if(((lvds_context_t *)(p_ctx->internal_lvds))->native_dtd == 0 )
-			return PD_ERR_NO_TIMINGS;
-
-		p_ctx->p_lvds_table = *pp_out_list; 
-
-#ifdef T_PANEL_NATIVE_DTD	
-
-		
-		pd_memcpy(&(p_ctx->native_dtd),((lvds_context_t *)(p_ctx->internal_lvds))->native_dtd,sizeof(pd_timing_t));
-
-		p_ctx->fp_width = ((lvds_context_t *)(p_ctx->internal_lvds))->fp_width;
-		p_ctx->fp_height = ((lvds_context_t *)(p_ctx->internal_lvds))->fp_height;	
-		
-		if( (p_ctx->fp_width == 0) || (p_ctx->fp_height == 0) ) 
-			return PD_ERR_NO_TIMINGS ;
-			
-#else
-		
-		for(i=0,p_table = *pp_out_list;i< 30;i++) 
-			{
-				
-				if((p_table->width == 1024) && (p_table->height == 768 )&& 
-					(p_table->refresh == 60) )
-				{
-				
-				
-
-					pd_memcpy(&(p_ctx->native_dtd),p_table,sizeof(pd_timing_t));
-					p_ctx->fp_width = p_table->width;
-					p_ctx->fp_height = p_table->height;
-					
-					break;
-				}
-				
-				p_table= (pd_timing_t*)((uint8*)p_table + (sizeof(pd_timing_t)+4)); 
-							
-			}
-
-	
-			pd_memcpy(p_lvds->native_dtd,&(p_ctx->native_dtd),sizeof(pd_timing_t));
-			p_lvds->fp_width = p_ctx->fp_width;
-			p_lvds->fp_height = p_ctx->fp_height;
-
-#endif
-			
-	} 
-	
-
-
-	if ( !p_ctx->init_done) {  
-		PD_DEBUG("ch7036: ch7036_get_timing_list()-init is not done- inquire port status...\n");		
-		ch7036_get_port_status((void *)p_ctx, &port_status);
-
-	}
-
-	
-	ch7036_parse_edid(p_ctx);
-
-	return ret;
-
-}
-
-
-
-int ch7036_get_attributes(void *p_context, unsigned long *p_num_attr,
-	pd_attr_t **pp_list)
-{
-	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
-		
-	
-
-	PD_DEBUG("ch7036: ch7036_get_attributes()-enter\n");
-
-	
-	
-	if (!p_ctx || !p_num_attr || !pp_list) {
-		return PD_ERR_NULL_PTR;
-	}
-	
-	*pp_list = p_ctx->p_ch7036_attr_table;
-
-	
-	*p_num_attr  = p_ctx->ch7036_num_attrs;
-
-	PD_DEBUG("ch7036: ch7036_get_attributes()- total num_attrs = [%u]\n",*p_num_attr);
-
-	return PD_SUCCESS;
-}
-
-
-int ch7036_set_attributes(void *p_context, unsigned long num_attrs,
-	pd_attr_t *p_list)
-{
-	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
-	pd_list_entry_attr_t* list_item;
-
-	pd_port_status_t port_status;
-
-	pd_attr_t        *p_curr, *p_attr;
-	int ret;
-	unsigned long i,temp=0;
-	uint32 temp_chan;
-	ch7036_status_t status;
-
-	
-	PD_DEBUG("ch7036: ch7036_set_attributes()-enter: num_attrs=%u\n", num_attrs);
-	
-	
-	ret = PD_INTERNAL_LVDS_MODULE_SET_ATTRIBUTES(ch7036_lvds_set_attrs, (p_ctx->internal_lvds,num_attrs,p_list));
-
-	
-	
-	if(ret != PD_SUCCESS)
-		return ret;
-
-#ifdef LVDS_ONLY
-		return PD_SUCCESS;
-#endif	
-		
-	
-	if (!p_ctx->init_done) {
-
-		PD_DEBUG("ch7036: ch7036_set_attributes()- at bootup...\n");
-
-		PD_DEBUG("ch7036: ch7036_set_attributes()- p_ctx->hpd [%x]\n", p_ctx->hpd);
-
-		p_attr = pd_get_attr(p_list, num_attrs, PD_ATTR_ID_DISPLAY, 0);
-		if (p_attr && (p_attr->flags & PD_ATTR_FLAG_VALUE_CHANGED) ) {
-			
-		
-			pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DISPLAY,
-				PD_GET_ATTR_LIST)->current_value
-			= p_attr->current_value; 
-
-
-		}
-
-		
-		p_attr = pd_get_attr(p_list, num_attrs, PD_ATTR_ID_HDMI_OUT_MODE, 0);
-		p_curr = pd_get_attr(p_ctx->p_ch7036_attr_table, num_attrs, PD_ATTR_ID_HDMI_OUT_MODE, 0);
-
-		if (p_attr && (p_attr->flags & PD_ATTR_FLAG_VALUE_CHANGED) ) {
-					
-			if(p_curr) {
-				pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_HDMI_OUT_MODE,
-					PD_GET_ATTR_LIST)->current_value
-				= p_attr->current_value;
-				p_curr->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE; 
-			}
-
-
-		}
-		
-						
-		p_attr = pd_get_attr(p_list, num_attrs, PD_ATTR_ID_DVI_OUT_MODE, 0);
-		p_curr = pd_get_attr(p_ctx->p_ch7036_attr_table, num_attrs, PD_ATTR_ID_DVI_OUT_MODE, 0);
-
-		if (p_attr && (p_attr->flags & PD_ATTR_FLAG_VALUE_CHANGED) ) {
-			
-
-			
-			if(p_curr) {
-				pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DVI_OUT_MODE,
-					PD_GET_ATTR_LIST)->current_value
-				= p_attr->current_value;
-				p_curr->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE; 
-			}
-
-
-		}
-	
-		
-		
-		
-		p_attr = pd_get_attr(p_list, num_attrs, PD_ATTR_ID_CRT_OUT_MODE, 0);
-		p_curr = pd_get_attr(p_ctx->p_ch7036_attr_table, num_attrs, PD_ATTR_ID_CRT_OUT_MODE, 0);
-
-		if (p_attr && (p_attr->flags & PD_ATTR_FLAG_VALUE_CHANGED) ) {
-			
-			if(p_curr) {
-				pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_CRT_OUT_MODE,
-						PD_GET_ATTR_LIST)->current_value
-					= p_attr->current_value;
-
-				p_curr->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE; 
-			}
-
-
-		}
-		
-	
-		
-	} 
-
-	
-	for (i = 0, p_attr = p_list; i < num_attrs; i++,p_attr++) 
-	{
-		
-		
-		if (!(p_attr->flags & PD_ATTR_FLAG_VALUE_CHANGED)) {
-
-			continue;	
-		}
-
-		
-		p_attr->flags &= ~PD_ATTR_FLAG_VALUE_CHANGED;
-	
-		if (p_attr->flags & PD_ATTR_FLAG_USER_INVISIBLE)
-			continue;
-
-		
-		if( (p_attr->id == 0x1A) || (p_attr->id == 0x1B) ||
-			(p_attr->id == 0x3C) || (p_attr->id == 0x46) ||
-			(p_attr->id == 0x47) )
-			continue;
-		
-#if 0		
-		
-		p_curr = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,p_attr->id,
-				PD_GET_ATTR_LIST); 
-#endif 
-		
-		
-		p_curr = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,p_attr->id,
-				0); 
-		PD_DEBUG("ch7036_set_attributes(): attribute changed is of type [%ld] name [%s] id [%ld]\n",p_attr->type, p_attr->name, p_attr->id);
-
-		PD_DEBUG("ch7036_set_attributes():current value [%ld] requested value [%ld]\n",p_curr->current_value, p_attr->current_value); 	
-			
-		
-		temp = p_curr->current_value; 
-		p_curr->current_value = p_attr->current_value;
-		switch (p_attr->id) {
-			case PD_ATTR_ID_DISPLAY:
-				
-				list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DISPLAY,
-							PD_GET_ATTR_LIST_ENTRY); 			
-				
-				p_attr->flags |= PD_ATTR_FLAG_SETMODE;  
-
-				if(list_item->value == CHANNEL_AUTO_DETECT) { 
-					p_ctx->man_sel_out = 0;
-
-					if(p_ctx->init_done) { 
-						p_ctx->hpd |= CH7036HPD_RESERVED1; //force port status inquiry
-						ch7036_get_port_status((void *)p_ctx, &port_status);
-	
-					}
-					break; 
-				}
-				//end of CHANNEL_AUTO_DETECT, manual selection of display output begins
-				
-				
-				p_ctx->man_sel_out = 1; 
-
-				//1- save a copy
-				temp_chan = p_ctx->prev_outchannel;
-				p_ctx->prev_outchannel = pOutput_Info->channel;
-
-				PD_DEBUG("ch7036_set_attributes():current list item value [0x%x]\n",list_item->value);
-
-				//2- get requested output channel- assume it's allowed		
-
-				if(list_item->value & CHANNEL_DVI) { 					
-					pOutput_Info->channel = (list_item->value & 0x01) | CHANNEL_HDMI;
-				}
-				else	 	
-					pOutput_Info->channel = list_item->value;
-
-				PD_DEBUG("ch7036_set_attributes():current output channel value [0x%x]\n",pOutput_Info->channel);
-
-				//3- check requested selection vs what is available
-				status = ch7036_get_attached_device(p_ctx); //manual mode- verify its selection and correct if needed
-				
-				//4- NOT allowed display choice- also include when none is connected
-				if( status == SS_DISPLAY_CHOICE_NOT_ALLOWED) {  //restore previous states
-					PD_DEBUG("ch7036_set_attributes(): display choice is not allowed- restore prev. states...\n");
-							
-					p_ctx->hpd &= 0xEF;	 //reset												
-					
-					if(p_ctx->init_done){ 																		
-						pOutput_Info->channel = p_ctx->prev_outchannel;
-						p_ctx->prev_outchannel = temp_chan; 
-						p_curr->current_value = temp; 
-						//when system is restarted right after this point, need to provide main driver w/ a valid 
-						//restored choice
-						p_attr->current_value = p_curr->current_value;
-						if(p_curr->current_value==1)
-							p_ctx->man_sel_out = 0; 
-
-					}
-					else { //at installation, when init is not done, if manual choice is not valid, revert to auto
-					
-						p_curr->current_value = 1; 
-						p_ctx->man_sel_out = 0; 
-						
-						if (pOutput_Info->channel & CHANNEL_HDMI) //DVI mapped to CHANNEL_HDMI
-						{
-							pOutput_Info->channel = (pOutput_Info->channel & 0x01) | CHANNEL_VGA;
-							p_ctx->prev_outchannel = pOutput_Info->channel;
-						
-						} 
-						else { //VGA
-							pOutput_Info->channel = (pOutput_Info->channel & 0x01) | CHANNEL_HDMI;
-							p_ctx->prev_outchannel = pOutput_Info->channel;
-						}
-						
-						
-					}
-
-					PD_DEBUG("ch7036_set_attributes(): p_curr->current_value is: [%x]\n",p_curr->current_value);
-					if(p_ctx->hpd == 0x50) {//none is attached
-						pOutput_Info->channel &= CHANNEL_LVDS; 
-						p_ctx->prev_outchannel = pOutput_Info->channel;
-					}
-
-										
-				}
-				PD_DEBUG("ch7036_set_attributes(): now- output display channel is: value [%ld]\n",pOutput_Info->channel);
-
-
-				//special case channel CHANNEL_xxx_HDMI: 
-				//incoming dvi format => convert to hdmi format- or- incoming hdmi format => convert to dvi format 
-				if( ( (pOutput_Info->hdmi_fmt.is_dvi_mode==1) && ((list_item->value & 0x02) == CHANNEL_HDMI) ) ||
-					( (pOutput_Info->hdmi_fmt.is_dvi_mode==0) && ((list_item->value & 0x08) == CHANNEL_DVI) )
-					)
-					p_ctx->hpd |= 0x40; //request edid read again to update hdmi/dvi format accordingly
-
-
-				//base on 'new' attached info, read edid and set proper display output channel, including DVI
-				//case: manual selection w/ hpd change
-				if(p_ctx->hpd & 0x44) 	{		
-					ch7036_alter_display_channel(p_ctx); 
-				}
-				
-				if( (pOutput_Info->channel & 0x04) == CHANNEL_VGA || p_curr->current_value==1  /* Coerced Auto Detect */ ) 
-					break;
-
-				//case: 
-				//channel CHANNEL_xxx_HDMI- update list item xxx_DVI or xxx_HDMI accordingly
-				if((pOutput_Info->channel & CHANNEL_HDMI) && (pOutput_Info->hdmi_fmt.is_dvi_mode==1) )
-					p_curr->current_value = (pOutput_Info->channel & 0x01) == CHANNEL_LVDS?3:6;//lvds-dvi:dvi
-				
-				else 
-					if((pOutput_Info->channel & CHANNEL_HDMI) && (pOutput_Info->hdmi_fmt.is_dvi_mode==0) )
-						p_curr->current_value = (pOutput_Info->channel & 0x01) == CHANNEL_LVDS?2:5;//lvds-hdmi:hdmi
-
-				PD_DEBUG("ch7036_set_attributes(): after alter channel- output display channel is: value [%ld]\n",pOutput_Info->channel);
-
-				break;
-
-			case PD_ATTR_ID_HDMI_OUT_MODE:
-				list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_HDMI_OUT_MODE,
-							PD_GET_ATTR_LIST_ENTRY); 
-				p_ctx->hdmi_mode_index = list_item->value;
-				PD_DEBUG("ch7036_set_attributes(): updated hdmi_mode_index is: value [%ld]\n",p_ctx->hdmi_mode_index);
-				p_attr->flags |= PD_ATTR_FLAG_SETMODE;
-				break;
-				
-			case PD_ATTR_ID_DVI_OUT_MODE:
-				list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DVI_OUT_MODE,
-							PD_GET_ATTR_LIST_ENTRY); 
-				p_ctx->dvi_mode_index = list_item->value;
-				PD_DEBUG("ch7036_set_attributes(): updated dvi_mode_index is: value [%ld]\n",p_ctx->dvi_mode_index);
-				p_attr->flags |= PD_ATTR_FLAG_SETMODE;
-				break;
-
-			case PD_ATTR_ID_CRT_OUT_MODE:
-				list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_CRT_OUT_MODE,
-							PD_GET_ATTR_LIST_ENTRY); 
-				p_ctx->crt_mode_index = list_item->value;
-				PD_DEBUG("ch7036_set_attributes(): updated crt_mode_index is: value [%ld]\n",p_ctx->crt_mode_index);
-				p_attr->flags |= PD_ATTR_FLAG_SETMODE;
-				break;
-
-			case PD_ATTR_ID_HPOSITION: //these attributes are for vga only
-			case PD_ATTR_ID_VPOSITION:
-			
-				PD_DEBUG("ch7036_set_attributes(): set vga h/v position...\n");
-				 
-				//save vga h/v attribute context
-				if(p_curr->current_value > ((pd_range_attr_t *)p_curr)->max)
-					p_curr->current_value = ((pd_range_attr_t *)p_curr)->max;
-				else if (p_curr->current_value < ((pd_range_attr_t *)p_curr)->min)
-					p_curr->current_value = ((pd_range_attr_t *)p_curr)->min;
-	
-				
-				if( pOutput_Info->channel & CHANNEL_HDMI)
-					break;
-
-				if (p_attr->id == PD_ATTR_ID_HPOSITION) 
-					pOutput_Info->h_position = (uint16)(p_curr->current_value);
-				else
-					pOutput_Info->v_position = (uint16)(p_curr->current_value);
-					
-				ch7036_set_position(p_ctx, (uint8)p_attr->id, (uint16)(p_curr->current_value));
-				
-				PD_DEBUG("ch7036_set_attributes(): updated and set vga position: value [%d]\n",p_curr->current_value);
-		
-				break;
-			case PD_ATTR_ID_HSCALE:
-			case PD_ATTR_ID_VSCALE:
-			case PD_ATTR_ID_HSCALE_CRT:
-			case PD_ATTR_ID_VSCALE_CRT:
-				
-				if(p_curr->current_value > ((pd_range_attr_t *)p_curr)->max)
-					p_curr->current_value = ((pd_range_attr_t *)p_curr)->max;
-				else if (p_curr->current_value < ((pd_range_attr_t *)p_curr)->min)
-					p_curr->current_value = ((pd_range_attr_t *)p_curr)->min;
-				
-			
-				if(p_attr->id== PD_ATTR_ID_HSCALE || p_attr->id== PD_ATTR_ID_HSCALE_CRT)
-					ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_HSCALE, (uint8)p_curr->current_value);
-				else 
-					ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_VSCALE, (uint8)p_curr->current_value);				
-				PD_DEBUG("ch7036_set_attributes(): updated scale value is: value [%lu]\n",p_curr->current_value);
-			
-				p_attr->flags |= PD_ATTR_FLAG_SETMODE; 
-
-				break;
-			case PD_ATTR_ID_DITHER_BYPASS: 
-				
-			
-				PD_DEBUG("ch7036_set_attributes(): updated quality enhance value is: value [%lu]\n",p_curr->current_value);
-				ch7036_set_quality_enhancement(p_ctx,(uint8)p_curr->current_value);
-				break;
-			
-			case PD_ATTR_ID_DITHER: 
-				p_ctx->dither_select = (uint8)p_curr->current_value;
-				PD_DEBUG("ch7036_set_attributes(): updated dither select value is: value [%lu]\n",p_curr->current_value);
-				ch7036_set_dither(p_ctx);
-
-				break;
-
-			case PD_ATTR_ID_TEXT_FILTER:
-				
-				if(p_curr->current_value > ((pd_range_attr_t *)p_curr)->max)
-					p_curr->current_value = ((pd_range_attr_t *)p_curr)->max;
-				else if (p_curr->current_value < ((pd_range_attr_t *)p_curr)->min)
-					p_curr->current_value = ((pd_range_attr_t *)p_curr)->min;
-				
-				PD_DEBUG("ch7036_set_attributes(): update text tuning value...\n");
-				ch7036_set_text_enhancement (p_ctx, (uint8) p_curr->current_value);
-
-				break;
-
-			case PD_ATTR_ID_LOAD_FIRMWARE:
-				PD_DEBUG("ch7036_set_attributes(): updated [reload-firmware] value is: value [%lu]\n",p_curr->current_value);
-
-				break;
-
-			case PD_ATTR_ID_DWNSCAL_BYPASS:
-				PD_DEBUG("ch7036_set_attributes(): updated [dwnscal_bypass] value is: value [%lu]\n",p_curr->current_value);
-				if(p_curr->current_value ) { 
-					p_ctx->dwnscal_bypass = 1; 
-					p_ctx->downscaled[MODE_8x6_7x4_BYPASS]=1;
-				}
-				else {
-					p_ctx->dwnscal_bypass = 0; 
-					p_ctx->downscaled[MODE_8x6_7x4_BYPASS]=0;
-				}
-
-				break;
-
-			case PD_ATTR_ID_REFRESH:
-				PD_DEBUG("ch7036_set_attributes(): refresh value is: value [%lu]\n",p_curr->current_value);
-				
-				if(p_curr->current_value ) 
-						p_curr->current_value= 0; 
-				
-				if(p_ctx->init_done && !p_ctx->man_sel_out ) {
-
-						p_ctx->hpd |= CH7036HPD_RESERVED1; //force port status inquiry- edid read bit
-
-						ch7036_get_port_status((void *)p_ctx, &port_status);
-
-						p_attr->flags |= PD_ATTR_FLAG_SETMODE; 					
-					
-				}
-				break;
-
-			default:
-				
-				PD_DEBUG("ch7036_set_attr(): unhandled attr name[%s]id[%ld]curr_index[%lu]\n",p_attr->name, p_attr->id,p_attr->current_value);
-				break;
-
-		}
-		
-	}
-
-	PD_DEBUG("ch7036: ch7036_set_attributes()-p_ctx->man_sel_out at exit [0x%x]\n",p_ctx->man_sel_out);
-	
-	PD_DEBUG("ch7036: ch7036_set_attributes()-p_ctx->hpd at exit [0x%x]\n",p_ctx->hpd);
-
-	PD_DEBUG("ch7036: ch7036_set_attributes()-exit\n");
-
-	return ret;
-}
-
-int ch7036_set_power(void *p_context, unsigned long state)
-{
-	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
-	OUTPUT_INFO* pOutput_Info = (p_ctx->p_ch7xxx_context)->pOutput_Info;
-
-
-	int ret;
-
-
-	PD_DEBUG("ch7036: ch7036_set_power()-enter: requested state=%x\n", state);
-
-#ifdef LVDS_ONLY
-	return	PD_INTERNAL_LVDS_MODULE_SET_POWER(ch7036_set_power, (p_ctx->internal_lvds,state));
-#endif
-		
-	if (!p_ctx) 
-		return PD_ERR_NULL_PTR;
-	
-	if (state > PD_POWER_MODE_D3)
-		return PD_ERR_INVALID_POWER;
-	
-	if (state != PD_POWER_MODE_D0) {
-	
-		if(pOutput_Info->channel != CHANNEL_LVDS_HDMI_VGA_OFF)  
-			p_ctx->prev_outchannel = pOutput_Info->channel; //store current output channel before temporarily powered down
-		pOutput_Info->channel = CHANNEL_LVDS_HDMI_VGA_OFF; 
-
-		
-		ch7036_device_set_power(p_ctx,pOutput_Info->channel);
-				
-		ret = PD_INTERNAL_LVDS_MODULE_SET_POWER(ch7036_lvds_set_power, (p_ctx->internal_lvds,state));
-		
-	
-	}
-	else {
-		
-
-		ch7036_set_output_channel(p_ctx,p_ctx->prev_outchannel); //restore previous output channel
-
-		PD_DEBUG("ch7036: ch7036_set_power()- p->ctx-hpd [0x%x]\n",p_ctx->hpd);
-		PD_DEBUG("ch7036: ch7036_set_power()- requested output channel- [%x]\n", pOutput_Info->channel);
-
-
-		PD_INTERNAL_LVDS_MODULE_SET_POWER(ch7036_lvds_set_power, (p_ctx->internal_lvds,state));
-		
-		ch7036_device_set_power(p_ctx,pOutput_Info->channel);
-						
-	}
-
-	
-	p_ctx->pwr_state = state;
-
-	return PD_SUCCESS;
-}
-
-
-int ch7036_get_power(void *p_context, unsigned long *p_state)
-{
-	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
-	
-
-	PD_DEBUG("ch7036: ch7036_get_power()\n");
-
-#ifdef LVDS_ONLY
-	return PD_INTERNAL_LVDS_MODULE_GET_POWER(ch7036_get_power, (p_ctx->internal_lvds,p_state));
-#endif
-
-	*p_state = p_ctx->pwr_state;
-
-	return PD_SUCCESS;
-}
-
-int ch7036_save(void *p_context, void **state, unsigned long flags)
-{
-	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
-	OUTPUT_INFO* pOutput_Info = (p_ctx->p_ch7xxx_context)->pOutput_Info;
-
-	PD_DEBUG("ch7036: ch7036_save()\n"); 
-
-#ifdef LVDS_ONLY
-	
-	return PD_INTERNAL_LVDS_MODULE_SAVE(ch7036_save,(p_ctx->internal_lvds, state, flags));
-#endif
-
-	//in Linux, when being called @ init, it incorrectly assigned unintialized global attribute value to prev outchannel	
-	//p_ctx->prev_outchannel = ch7036_get_output_channel(p_context); 
-	//fixed
-	p_ctx->prev_outchannel = pOutput_Info->channel; 
-	
-
-	*state = NULL;
-
-	return PD_SUCCESS;
-}
-
-
-
-int ch7036_restore(void *p_context, void *state, unsigned long flags)
-{
-	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
-
-	unsigned long i;
-
-	
-
-	PD_DEBUG("ch7036: ch7036_restore()\n");
-
-#ifdef LVDS_ONLY
-	
-	return PD_INTERNAL_LVDS_MODULE_RESTORE(ch7036_restore,(p_ctx->internal_lvds, state, flags));
-#endif
-
-	
-	if (ch7036_load_firmware(p_ctx) != SS_SUCCESS)   { 
-		PD_DEBUG("ch7036: ch7036_restore()-  load fw is NOT a SUCCESS\n");
-		return PD_ERR_UNSUCCESSFUL;
-		
-	}
-	else {
-		PD_DEBUG("ch7036: ch7036_restore()-  load fw is a SUCCESS\n");
-	}
-
-
-
-	if(p_ctx->prev_outchannel == CHANNEL_LVDS_HDMI) {
-
-		ch7036_set_output_channel(p_context, p_ctx->prev_outchannel);
-		ch7036_set_mode(p_context, &(p_ctx->native_dtd), 0);  
-		ch7036_post_set_mode(p_context, &(p_ctx->native_dtd), 0);
-	}
-
-	
-	for(i=0;i<p_ctx->ch7036_num_attrs;i++) {
-
-		if( p_ctx->p_ch7036_attr_table[i].id == PD_ATTR_ID_REFRESH ) {
-
-			
-			p_ctx->p_ch7036_attr_table[i].flags |= PD_ATTR_FLAG_VALUE_CHANGED;
-			p_ctx->p_ch7036_attr_table[i].current_value = 1;
-
-			ch7036_set_attributes(p_context, 1, &p_ctx->p_ch7036_attr_table[i]);
-			break;
-		}
-
-	}
-
-	
-	return PD_SUCCESS;
-
-}
-
-
-int ch7036_get_port_status(void *context, pd_port_status_t *port_status)
-{
-	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)context;
-	OUTPUT_INFO* pOutput_Info = (p_ctx->p_ch7xxx_context)->pOutput_Info;
-
-#if 0
-	FW7036_CFG* fv = (FW7036_CFG*) p_ctx->fw;
-	int ret;
-#endif
-	
-	port_status->display_type = PD_DISPLAY_LVDS_INT;
-	port_status->connected    = PD_DISP_STATUS_UNKNOWN;
-	
-	
-	PD_DEBUG("ch7036: ch7036_get_port_status()-enter... p_ctx->hpd [%x]\n", p_ctx->hpd);
-
-#if 0
-	PD_DEBUG("Get LHFM Version Information.\r\n");
-	ret = LHFM_get_version(p_ch7xxx_context, fv);
-	if (0==ret) {
-		PD_DEBUG("Ma_ver=%d, mi_ver=%d, did=%02X, rid= %02X, capability=%s\r\n",
-			fv->ver_major, fv->ver_minor, fv->did, fv->rid, (fv->capbility & 0x2) ? "EDID+HDCP" : "EDID"); 
-	}
-	else {
-		PD_DEBUG("--- failed!\r\n");
-		PD_DEBUG("status: [%s]\n",ret ==-1?"timeout!":"firmware_error!");
-	}
-#endif
-
-	
-#ifdef LVDS_ONLY
-	
-	return PD_INTERNAL_LVDS_MODULE_GET_PORT_STATUS(ch7036_get_port_status,(p_ctx->internal_lvds, port_status));
-#endif
-	
-	if(! (p_ctx->hpd & CH7036HPD_RESERVED1) ) {  
-		//note: main driver check port status several times, this block is to speed things up a little 
-		if ((p_ctx->init_done) && (pOutput_Info->channel == p_ctx->prev_outchannel ) ) {
-			if(p_ctx ->hpd & 0x22)
-				port_status->connected = PD_DISP_STATUS_ATTACHED;
-			PD_DEBUG("ch7036: ch7036_get_port_status()-output channel UNCHANGED- exit. p_ctx->hpd [%x]\n", p_ctx->hpd);
-			return PD_SUCCESS;
-		}
-
-	}
-
-	if(p_ctx->use_firmware) {
-
-		ch7036_get_attached_device(p_ctx);		
-		if(p_ctx ->hpd & 0x22)
-			port_status->connected = PD_DISP_STATUS_ATTACHED;
-
-		ch7036_alter_display_channel(p_ctx); 
-			
-		}
-
-	
-	p_ctx->hpd &= 0xEE; 
-	
-	PD_DEBUG("ch7036: ch7036_get_port_status()-exit. p_ctx->hpd [%x]\n", p_ctx->hpd);
-	return PD_SUCCESS;
-}
-
-
-
-
-int ch7036_initialize_device(ch7036_device_context_t *p_ctx)
-{
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	OUTPUT_INFO* pOutput_Info = (p_ctx->p_ch7xxx_context)->pOutput_Info;
-	PREFER_INFO* pPrefer_Info = p_ch7xxx_context->pPrefer_Info;
-	uint8 reg; //,i=0;
-
-	ch7036_edid_blk_t* p_hedid; 
-	ch7036_edid_blk_t* p_cedid ;
-
-
-	PD_DEBUG("ch7036: ch7036_initialize_device()- ENTER...\n");
-	
-
-	p_ctx->init_done = 0;
-	p_ctx->hpd = 0;	
-
-	p_ctx->downscaled[MODE_6x4_BYPASS] = 1; 
-	p_ctx->downscaled[MODE_8x6_7x4_BYPASS] = 1;
-	p_ctx->dwnscal_bypass = 1; 
-
-	if(p_ctx->use_firmware) {
-
-		p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
-		p_cedid = (ch7036_edid_blk_t *)p_ctx->cedid;
-
-		
-		
-		pd_memcpy(p_cedid->etiming_I,et_I,8* sizeof(established_timings_t));  
-		pd_memcpy(p_cedid->etiming_II,et_II,8* sizeof(established_timings_t)); 
-		
-		
-		p_cedid->etiming_man = &et_man;
-
-
-		
-		pd_memcpy(p_hedid->etiming_I,et_I,8* sizeof(established_timings_t));  
-		pd_memcpy(p_hedid->etiming_II,et_II,8* sizeof(established_timings_t)); 
-
-		p_hedid->etiming_man = &et_man;
-
-		
-		p_cedid->is_edid = 0;
-		p_hedid->is_edid = 0;
-		p_cedid->ebn = 0;
-		p_hedid->ebn = 0;
-
-		
-		I2CWrite(p_ch7xxx_context,0x03, 0x04);
-		reg = I2CRead(p_ch7xxx_context,0x52);
-		reg = reg & 0xEF; 
-		I2CWrite(p_ch7xxx_context,0x52, reg);
-
-
-		I2CWrite(p_ch7xxx_context,0x03, 0x0);
-		reg = I2CRead(p_ch7xxx_context,0x07);
-		reg = reg & 0x70; 
-		I2CWrite(p_ch7xxx_context,0x07, reg);
-
-		I2CWrite(p_ch7xxx_context,0x4E, I2CRead(p_ch7xxx_context,0x4E) & 0x7F); 
-		
-		I2CWrite(p_ch7xxx_context,0x03, 0x01);
-		reg = I2CRead(p_ch7xxx_context,0x0F); 
-		reg = reg & 0x7F; 
-		I2CWrite(p_ch7xxx_context,0x0F, reg);
-	
-		I2CWrite(p_ch7xxx_context,0x03, 0x03);		
-		reg = I2CRead(p_ch7xxx_context,0x6E);
-		reg = reg & 0xBF; 
-		I2CWrite(p_ch7xxx_context,0x6E, reg | 0x40);
-
-
-	}
-
-	
-	pOutput_Info->hdmi_fmt.is_dvi_mode = 0;  
-	
-	pOutput_Info->channel = CHANNEL_LVDS | CHANNEL_HDMI;
-
-
-
-	PD_DEBUG("ch7036: ch7036_initialize_device()- default output channel is [%u]\n",pOutput_Info->channel);
-
-
-	
-	pOutput_Info->h_position = DEFAULT_POSITION;
-	pOutput_Info->v_position = DEFAULT_POSITION;
-
-
-	p_ctx->dither_select = DITHER_18_TO_18; 
-	p_ctx->man_sel_out= 0; 
-
-	ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_HSCALE, HDMI_DEFAULT_UNDERSCAN);
-	ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_VSCALE, HDMI_DEFAULT_UNDERSCAN);
-
-	ch7036_set_prefer_timing_info(p_ctx,pPrefer_Info); 
-	
-	return PD_SUCCESS;
-}
-
-
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_port.c
+* @version 1.2.5
+*-----------------------------------------------------------------------------
+*/
+
+
+#include <linux/kernel.h>
+
+#include "ch7036_port.h"
+
+
+#ifdef T_LINUX
+	#include "lvds/lvds.h"
+#else
+	#include "lvds.h"
+#endif
+
+
+
+static pd_version_t  g_ch7036_version = {1, 2, 5, 0};
+static unsigned long g_ch7036_dab_list[] = {0xEC,PD_DAB_LIST_END};
+
+
+void ch7036_update_position(ch7036_device_context_t *p_ctx, OUTPUT_INFO* pOutput_Info);
+int ch7036_initialize_device(ch7036_device_context_t *p_ctx);
+
+
+static pd_driver_t	 g_ch7036_drv = {
+	PD_SDK_VERSION,
+	"Chrontel CH7036 Port Driver",
+	0,
+	&g_ch7036_version,
+	PD_DISPLAY_LVDS_INT,
+	PD_FLAG_UP_SCALING,
+	g_ch7036_dab_list,
+	100,
+	ch7036_validate,
+	ch7036_open,
+	ch7036_init_device,
+	ch7036_close,
+	ch7036_set_mode,
+	ch7036_post_set_mode,
+	ch7036_set_attributes,
+	ch7036_get_attributes,
+	ch7036_get_timing_list,
+	ch7036_set_power,
+	ch7036_get_power,
+	ch7036_save,
+	ch7036_restore,
+	ch7036_get_port_status
+};
+
+
+extern established_timings_t et_I[8];
+extern established_timings_t et_II[8];
+extern established_timings_t et_man;
+
+
+int PD_MODULE_INIT(ch7036_init, (void *handle))
+{
+	int status;
+
+	PD_DEBUG("ch7036: ch7036_init()\n");
+
+	status = pd_register(handle, &g_ch7036_drv);
+	if (status != PD_SUCCESS) {
+		PD_DEBUG("ch7036: Error ! ch7036_init: pd_register() failed with "
+				  "status=%#x\n", status);
+	}
+	return status;
+}
+
+
+
+int PD_MODULE_EXIT(ch7036_exit, (void))
+{
+	PD_DEBUG("ch7036: ch7036_exit()\n");
+
+	return (PD_SUCCESS);
+}
+
+
+unsigned long ch7036_validate(unsigned long cookie)
+{
+	PD_DEBUG("ch7036: ch7036_validate()\n");
+
+	return cookie;
+}
+
+
+int ch7036_open(pd_callback_t *p_callback, void **pp_context)
+{
+	uint8 device_ID;
+	ch7036_device_context_t* p_ctx;
+	DEV_CONTEXT* p_ch7xxx_context;
+
+	ch7036_edid_blk_t *p_edid1, *p_edid2;
+
+
+	int ret;
+
+
+
+	PD_DEBUG("ch7036: ch7036_open()- enter- ch7036 pd release- major [%x] minor [%x] patch [%x]\n",
+		g_ch7036_version.major,g_ch7036_version.minor,g_ch7036_version.patch);
+
+	ret = PD_INTERNAL_LVDS_MODULE_OPEN(ch7036_lvds_open,(p_callback, pp_context));
+	if ( ret != PD_SUCCESS)
+	{
+
+
+		PD_ERROR("ch7036: ch7036_open: EXIT#1\n");
+		return ret;
+	}
+
+	p_ctx = pd_malloc(sizeof(ch7036_device_context_t));
+	if (p_ctx == NULL) {
+		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed\n");
+		goto exit6;
+	}
+
+	pd_memset(p_ctx, 0, sizeof(ch7036_device_context_t));
+
+	/* per EMGD request */
+	p_edid1 = (ch7036_edid_blk_t *)p_ctx->cedid;
+	p_edid2 = (ch7036_edid_blk_t *)p_ctx->hedid;
+
+
+	p_ctx->fw = (FW7036_CFG *)(pd_malloc(sizeof(FW7036_CFG)));
+
+	if (p_ctx->fw == NULL) {
+		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating FW7036_CFG struct\n");
+		goto exit5;
+	}
+
+#if 0
+	ret = PD_INTERNAL_LVDS_MODULE_OPEN(ch7036_lvds_open,(p_callback, pp_context));
+	if ( ret != PD_SUCCESS)
+	{
+		pd_free(p_ctx->fw);
+		pd_free(p_ctx);
+		return ret;
+	}
+#endif
+
+	p_ctx->internal_lvds = *pp_context;
+
+	p_ctx->p_callback = p_callback;
+
+#ifdef LVDS_ONLY
+	*pp_context = (void *)p_ctx;
+	return (PD_SUCCESS);
+#endif
+
+
+
+	p_ctx->p_ch7xxx_context = pd_malloc(sizeof(DEV_CONTEXT));
+	if (p_ctx->p_ch7xxx_context == NULL) {
+		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating DEV_CONTEXT struct");
+		goto exit4;
+	}
+
+	p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+
+	p_ch7xxx_context->pd_context = (void *)p_ctx;
+
+
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x04);
+
+	device_ID = I2CRead(p_ch7xxx_context,0x50);
+
+	PD_DEBUG("ch7036: ch7036_open()- read device ID= 0x%.2X\n", device_ID);
+
+
+	if(device_ID != 0x56)
+	{
+		PD_DEBUG("ch7036: ch7036_open()- device is NOT found...\n");
+
+		if(p_ch7xxx_context->pd_context)
+			p_ch7xxx_context->pd_context=NULL;
+		pd_free(p_ch7xxx_context);
+		if(p_ctx->internal_lvds) {
+			p_ctx->internal_lvds=NULL;
+
+		}
+		pd_free(p_ctx->fw);
+		pd_free(p_ctx);
+		return PD_ERR_NODEV;
+
+	}
+	else
+	{
+		PD_DEBUG("ch7036: ch7036_open()- ch7036 device is found...\n");
+
+
+	}
+
+	p_ch7xxx_context->DeviceID = device_ID;
+
+	ch7036_reset(p_ctx);
+	pd_usleep(50);
+
+	if (ch7036_load_firmware(p_ctx) != SS_SUCCESS)   {
+		p_ctx->use_firmware =0;
+		p_ctx->cedid = NULL;
+		p_ctx->hedid = NULL;
+
+	}
+	else {
+		p_ctx->use_firmware =1;
+
+
+		p_ctx->cedid = (ch7036_edid_blk_t *)pd_malloc(sizeof(ch7036_edid_blk_t));
+
+		if (p_ctx->cedid == NULL) {
+			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating ch7036_edid_blk_t struct for crt");
+			goto exit3;
+		}
+
+		p_edid1 = (ch7036_edid_blk_t *)p_ctx->cedid ;
+
+		p_edid1->etiming_I = (established_timings_t *)pd_malloc(8 * sizeof(established_timings_t));
+		if (p_edid1->etiming_I == NULL) {
+			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating established_timings_t struct I for crt");
+			pd_free(p_ctx->cedid);
+			goto exit3;
+		}
+		p_edid1->etiming_II = (established_timings_t *)pd_malloc(8 * sizeof(established_timings_t));
+		if (p_edid1->etiming_II == NULL) {
+			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating established_timings_t struct II for crt");
+			pd_free(p_edid1->etiming_I);
+			pd_free(p_ctx->cedid);
+			goto exit3;
+		}
+
+		p_ctx->hedid = (ch7036_edid_blk_t *)pd_malloc(sizeof(ch7036_edid_blk_t));
+
+		if (p_ctx->hedid == NULL) {
+			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating ch7036_edid_blk_t struct for hdvi");
+			pd_free(p_edid1->etiming_I);
+			pd_free(p_edid1->etiming_II);
+			pd_free(p_ctx->cedid);
+
+			goto exit3;
+		}
+
+		p_edid2 = (ch7036_edid_blk_t *)p_ctx->hedid ;
+
+		p_edid2->etiming_I = (established_timings_t *)pd_malloc(8 * sizeof(established_timings_t));
+		if (p_edid2->etiming_I == NULL) {
+			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating established_timings_t struct I for crt");
+			pd_free(p_edid1->etiming_I);
+			pd_free(p_edid1->etiming_II);
+			pd_free(p_ctx->cedid);
+			pd_free(p_ctx->hedid);
+
+			goto exit3;
+		}
+
+		p_edid2->etiming_II = (established_timings_t *)pd_malloc(8 * sizeof(established_timings_t));
+
+		if (p_edid2->etiming_II == NULL) {
+			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating established_timings_t struct for hdvi");
+			pd_free(p_edid1->etiming_I);
+			pd_free(p_edid1->etiming_II);
+			pd_free(p_ctx->cedid);
+			pd_free(p_edid2->etiming_I);
+
+			pd_free(p_ctx->hedid);
+
+			goto exit3;
+		}
+
+
+	}
+
+
+	pd_memset(p_edid1->etiming_I, 0, 8 *
+			sizeof(established_timings_t));
+	pd_memset(p_edid1->etiming_II, 0, 8 *
+			sizeof(established_timings_t));
+
+	pd_memset(p_edid2->etiming_I, 0, 8 *
+			sizeof(established_timings_t));
+	pd_memset(p_edid2->etiming_II, 0, 8 *
+			sizeof(established_timings_t));
+
+
+
+
+
+
+
+	p_ch7xxx_context->pInput_Info = pd_malloc(sizeof(INPUT_INFO));
+	if (p_ch7xxx_context->pInput_Info == NULL) {
+		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating INPUT_INFO struct");
+
+		goto exit23;
+	}
+
+	p_ch7xxx_context->pOutput_Info = pd_malloc(sizeof(OUTPUT_INFO));
+	if (p_ch7xxx_context->pOutput_Info == NULL) {
+		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating OUTPUT_INFO struct");
+
+		goto exit2;
+	}
+
+	p_ch7xxx_context->pPrefer_Info = pd_malloc(sizeof(PREFER_INFO));
+	if (p_ch7xxx_context->pPrefer_Info == NULL) {
+		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating PREFER_INFO struct");
+
+		goto exit1;
+	}
+
+
+
+
+	p_ctx->p_ch7036_attr_table = NULL;
+
+	if( ch7036_init_attribute_table(p_ctx, NULL) == SS_MEM_ALLOC_ERR)
+	{
+		pd_free(p_ch7xxx_context->pPrefer_Info);
+		goto exit1;
+	}
+
+
+	ch7036_initialize_device(p_ctx);
+
+	g_ch7036_drv.type = PD_DISPLAY_LVDS_INT;
+
+
+	*pp_context = (void *)p_ctx;
+
+	PD_DEBUG("ch7036: ch7036_open: EXIT w/ SUCCESS...ch7036 pd release- major [%x] minor [%x] patch [%x]\n",
+		g_ch7036_version.major,g_ch7036_version.minor,g_ch7036_version.patch);
+	return (PD_SUCCESS);
+
+exit1:
+	pd_free(p_ch7xxx_context->pOutput_Info);
+exit2:
+	pd_free(p_ch7xxx_context->pInput_Info);
+
+exit23:
+	pd_free(p_edid1->etiming_I);
+	pd_free(p_edid1->etiming_II);
+	pd_free(p_ctx->cedid);
+	pd_free(p_edid2->etiming_I);
+	pd_free(p_edid2->etiming_II);
+	pd_free(p_ctx->hedid);
+
+exit3:
+	p_ch7xxx_context->pd_context=NULL;
+	pd_free(p_ch7xxx_context);
+exit4:
+
+	p_ctx->internal_lvds = NULL;
+	pd_free(p_ctx->fw);
+exit5:
+	pd_free(p_ctx);
+exit6:
+	PD_ERROR("ch7036: ch7036_open: EXIT- PD_ERR_NOMEM\n");
+	return PD_ERR_NOMEM;
+}
+
+
+int ch7036_init_device(void *p_context)
+{
+	ch7036_device_context_t* p_ctx  = (ch7036_device_context_t*)p_context;
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+	int ret;
+
+	PD_DEBUG("ch7036: ch7036_init_device()-enter\n");
+
+	p_ctx->init_done = 1;
+	ret= PD_INTERNAL_LVDS_MODULE_INIT_DEVICE(ch7036_lvds_init_device, (p_ctx->internal_lvds));
+
+	p_ctx->prev_outchannel = pOutput_Info->channel;
+	PD_DEBUG("ch7036: ch7036_init_device()-p_ctx->prev_outchannel = pOutput_Info->channel = [0x%x]\n",pOutput_Info->channel);
+
+	PD_DEBUG("ch7036: ch7036_init_device()-exit\n");
+	return ret;
+
+}
+
+
+
+int ch7036_set_mode(void *p_context, pd_timing_t *p_mode, unsigned long flags)
+{
+
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t*)p_context;
+
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	INPUT_INFO* pInput_Info = p_ch7xxx_context->pInput_Info;
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+	PREFER_INFO* pPrefer_Info = p_ch7xxx_context->pPrefer_Info;
+	int ret, channel_on=0;
+
+
+	PD_DEBUG("ch7036: ch7036_set_mode()-enter\n");
+
+
+	if (!p_ctx || !p_mode) {
+		return (PD_ERR_NULL_PTR);
+	}
+
+	if (p_ch7xxx_context->DeviceID != 0x56)
+	{
+		return (PD_ERR_NULL_PTR);
+	}
+
+	PD_DEBUG("ch7036_set_mode: requested width = %u height = %u\n",
+		p_mode->width, p_mode->height);
+
+#ifndef LVDS_ONLY
+	if (
+		(p_ctx->fp_width && (p_mode->width > p_ctx->fp_width)) ||
+		(p_ctx->fp_height && (p_mode->height > p_ctx->fp_height))
+		) {
+		return PD_ERR_MODE_NOTSUPP;
+	}
+
+	if( (p_ctx->fp_width == 640) && (p_ctx->fp_height == 480) ) {
+		p_ctx->downscaled[MODE_6x4_BYPASS] = 0;
+	}
+	else {
+		p_ctx->downscaled[MODE_6x4_BYPASS] = 1;
+		if( (!p_ctx->dwnscal_bypass) || ((p_ctx->fp_width <= 800) && (p_ctx->fp_height <= 600) )  )
+			p_ctx->downscaled[MODE_8x6_7x4_BYPASS] = 0;
+		else
+			p_ctx->downscaled[MODE_8x6_7x4_BYPASS] = 1;
+
+	}
+
+	if(pOutput_Info->channel  == CHANNEL_LVDS_HDMI_VGA_OFF) {
+
+		pOutput_Info->channel = p_ctx->prev_outchannel; //restore output channel before temp. power down
+		channel_on =1;
+	}
+
+
+	if (pOutput_Info->channel == CHANNEL_LVDS) {
+
+		pOutput_Info->channel = CHANNEL_LVDS_HDMI;	//force both channel on before setting in/out timing
+
+	}
+
+
+	ch7036_set_input_timing_info(p_ctx,pInput_Info);
+	ch7036_set_output_timing_info(p_ctx, pOutput_Info);
+	ch7036_set_prefer_timing_info(p_ctx,pPrefer_Info);
+
+
+	if(ch7036_device_prepare(p_ctx)== SS_UNSUCCESSFUL)
+	{
+		PD_DEBUG("ch7036_set_mode: ch7036_device_prepare()- NOT SUCCESS... ERROR CODE [%lu]\n", p_ctx->last_emsg);
+		return PD_ERR_UNSUCCESSFUL;
+	}
+
+
+	ch7036_update_position(p_ctx, pOutput_Info);
+
+	if(ch7036_device_config(p_ctx) == SS_UNSUCCESSFUL)
+	{
+		PD_DEBUG("ch7036_set_mode: ch7036_device_config()- NOT SUCCESS...ERROR CODE [%lu]\n", p_ctx->last_emsg);
+		return PD_ERR_UNSUCCESSFUL;
+	}
+
+	if(channel_on) {
+
+		pOutput_Info->channel = CHANNEL_LVDS_HDMI_VGA_OFF; //now, power down if it's tmp. powered up
+
+	}
+
+#endif
+
+	ret = PD_INTERNAL_LVDS_MODULE_SET_MODE(ch7036_lvds_set_mode,(p_ctx->internal_lvds,p_mode,flags));
+	if(ret != PD_SUCCESS)
+		return ret;
+
+
+	return PD_SUCCESS;
+}
+//thua- 10/24/11- when user switches back and forth from VGA to HDMI or vice versa
+//need to set h/v pos. accordingly
+void ch7036_update_position(ch7036_device_context_t *p_ctx, OUTPUT_INFO* pOutput_Info)
+{
+
+	PD_DEBUG("ch7036: ch7036_update_position()- enter\n");
+
+
+	if(pOutput_Info->channel & CHANNEL_HDMI) {
+		pOutput_Info->h_position = DEFAULT_POSITION;
+		pOutput_Info->v_position = DEFAULT_POSITION;
+
+	}
+
+	else { //pOutput_Info->channel & CHANNEL_VGA; note that CHANNEL_LVDS would never come here
+
+			pOutput_Info->h_position = (uint16)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_HPOSITION,
+					PD_GET_ATTR_LIST)->current_value;
+
+			pOutput_Info->v_position = (uint16)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_VPOSITION,
+					PD_GET_ATTR_LIST)->current_value;
+
+	}
+
+	PD_DEBUG("ch7036: ch7036_update_position()- h pos [%d]\n",pOutput_Info->h_position);
+	PD_DEBUG("ch7036: ch7036_update_position()- v pos [%d]\n",pOutput_Info->v_position);
+
+	return;
+}
+
+
+int ch7036_post_set_mode(void *p_context, pd_timing_t *p_mode,
+						  unsigned long flags)
+{
+
+
+	ch7036_device_context_t* p_ctx  = (ch7036_device_context_t*)p_context;
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+	int ret;
+
+
+
+
+
+	if (!p_ctx || !p_mode ) {
+		return (PD_ERR_NULL_PTR);
+	}
+
+	if (p_ch7xxx_context->DeviceID != 0x56)
+	{
+		return (PD_ERR_NULL_PTR);
+	}
+
+#ifndef LVDS_ONLY
+
+
+
+	ch7036_set_output_channel(p_ctx, p_ctx->prev_outchannel);
+	PD_DEBUG("ch7036_post_set_mode- now, current pOutput_Info->channel is [%x]\n",pOutput_Info->channel);
+
+	if(ch7036_device_start(p_ctx) == SS_UNSUCCESSFUL)
+	{
+		PD_DEBUG("ch7036_post_set_mode: ch7036_device_start()- NOT SUCCESS\n");
+		return PD_ERR_UNSUCCESSFUL;
+	}
+
+
+
+
+
+#endif
+
+
+	ret = PD_INTERNAL_LVDS_MODULE_POST_SET_MODE(ch7036_lvds_post_set_mode,(p_ctx->internal_lvds,p_mode,flags));
+
+#ifndef LVDS_ONLY
+	if(ret != PD_SUCCESS)
+		return ret;
+	else
+	{
+
+		ch7036_reset_datapath(p_ch7xxx_context);
+		pd_usleep(50);
+
+
+		ch7036_device_set_power(p_ctx, pOutput_Info->channel);
+
+		p_ctx->prev_outchannel = pOutput_Info->channel;
+	}
+
+#endif
+
+	return PD_SUCCESS;
+}
+
+
+
+
+
+int ch7036_close(void *p_context)
+{
+
+	ch7036_device_context_t* p_ctx  = (ch7036_device_context_t*)p_context;
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	ch7036_edid_blk_t *p_edid1, *p_edid2;
+
+	p_edid1 = (ch7036_edid_blk_t *)p_ctx->cedid;
+	p_edid2 = (ch7036_edid_blk_t *)p_ctx->hedid;
+
+
+	PD_DEBUG("ch7036: ch7036_close()\n");
+
+#ifndef LVDS_ONLY
+
+	ch7036_set_power(p_context, PD_POWER_MODE_D3);
+#endif
+
+	PD_INTERNAL_LVDS_MODULE_CLOSE(ch7036_lvds_close, (p_ctx->internal_lvds));
+
+	if (p_ctx!= NULL)
+	{
+
+		if(p_ctx->p_ch7xxx_context) {
+
+			pd_free(p_ch7xxx_context->pInput_Info);
+			p_ch7xxx_context->pInput_Info = NULL;
+
+			pd_free(p_ch7xxx_context->pOutput_Info);
+			p_ch7xxx_context->pOutput_Info = NULL;
+
+			pd_free(p_ch7xxx_context->pPrefer_Info);
+			p_ch7xxx_context->pPrefer_Info = NULL;
+
+			pd_free(p_ctx->p_ch7xxx_context);
+			p_ch7xxx_context = NULL;
+		}
+
+
+		if(p_edid1) {
+			pd_free(p_edid1->etiming_I);
+			pd_free(p_edid1->etiming_II);
+			pd_free(p_ctx->cedid);
+
+			p_edid1->etiming_I=NULL;
+			p_edid1->etiming_II=NULL;
+			p_ctx->cedid = NULL;
+
+		}
+		if(p_edid2) {
+			pd_free(p_edid2->etiming_I);
+			pd_free(p_edid2->etiming_II);
+			pd_free(p_ctx->hedid);
+
+			p_edid2->etiming_I=NULL;
+			p_edid2->etiming_II=NULL;
+			p_ctx->hedid = NULL;
+
+		}
+
+		if ( p_ctx->p_ch7036_attr_table) {
+			pd_free(p_ctx->p_ch7036_attr_table);
+			p_ctx->p_ch7036_attr_table = NULL;
+			p_ctx->ch7036_num_attrs = 0;
+		}
+
+		if(p_ctx->fw) {
+			pd_free(p_ctx->fw);
+			p_ctx->fw = NULL;
+		}
+
+
+		pd_free(p_ctx);
+		p_ctx = NULL;
+	}
+
+	return PD_SUCCESS;
+}
+
+
+int ch7036_get_timing_list(void *p_context, pd_timing_t *p_in_list,
+	pd_timing_t **pp_out_list)
+{
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+
+	int ret = 0;
+
+
+#ifndef T_PANEL_NATIVE_DTD
+	int i;
+	pd_timing_t * p_table;
+	lvds_context_t * p_lvds = (lvds_context_t *)(p_ctx->internal_lvds);
+
+#endif
+
+	pd_port_status_t port_status;
+
+
+
+	PD_DEBUG("ch7036: ch7036_get_timing_list()-enter\n");
+
+	if (p_ch7xxx_context->DeviceID != 0x56)
+	{
+		return (PD_ERR_NODEV);
+	}
+
+#ifdef LVDS_ONLY
+	PD_DEBUG("NUHAIRI: p_ctx->internal_lvds = %lu\n", p_ctx->internal_lvds);
+	if (p_ctx->internal_lvds != NULL){
+		PD_DEBUG("NUHAIRI: p_ctx->internal_lvds = %lu\n", p_ctx->internal_lvds);
+		return PD_INTERNAL_LVDS_MODULE_GET_TIMING_LIST(ch7036_get_timing_list, (p_ctx->internal_lvds,p_in_list,pp_out_list));
+	}
+	return PD_SUCCESS;
+#endif
+
+
+
+	if ( (g_ch7036_drv.type & PD_DISPLAY_LVDS_INT) || (g_ch7036_drv.type & PD_DISPLAY_LVDS_LHDV) )
+	{
+		ret = PD_INTERNAL_LVDS_MODULE_GET_TIMING_LIST(ch7036_lvds_get_timing_list, (p_ctx->internal_lvds,p_in_list,pp_out_list));
+
+		if(((lvds_context_t *)(p_ctx->internal_lvds))->native_dtd == 0 )
+			return PD_ERR_NO_TIMINGS;
+
+		p_ctx->p_lvds_table = *pp_out_list;
+
+#ifdef T_PANEL_NATIVE_DTD
+
+
+		pd_memcpy(&(p_ctx->native_dtd),((lvds_context_t *)(p_ctx->internal_lvds))->native_dtd,sizeof(pd_timing_t));
+
+		p_ctx->fp_width = ((lvds_context_t *)(p_ctx->internal_lvds))->fp_width;
+		p_ctx->fp_height = ((lvds_context_t *)(p_ctx->internal_lvds))->fp_height;
+
+		if( (p_ctx->fp_width == 0) || (p_ctx->fp_height == 0) )
+			return PD_ERR_NO_TIMINGS ;
+
+#else
+
+		for(i=0,p_table = *pp_out_list;i< 30;i++)
+			{
+
+				if((p_table->width == 1024) && (p_table->height == 768 )&&
+					(p_table->refresh == 60) )
+				{
+
+
+
+					pd_memcpy(&(p_ctx->native_dtd),p_table,sizeof(pd_timing_t));
+					p_ctx->fp_width = p_table->width;
+					p_ctx->fp_height = p_table->height;
+
+					break;
+				}
+
+				p_table= (pd_timing_t*)((uint8*)p_table + (sizeof(pd_timing_t)+4));
+
+			}
+
+
+			pd_memcpy(p_lvds->native_dtd,&(p_ctx->native_dtd),sizeof(pd_timing_t));
+			p_lvds->fp_width = p_ctx->fp_width;
+			p_lvds->fp_height = p_ctx->fp_height;
+
+#endif
+
+	}
+
+
+
+	if ( !p_ctx->init_done) {
+		PD_DEBUG("ch7036: ch7036_get_timing_list()-init is not done- inquire port status...\n");
+		ch7036_get_port_status((void *)p_ctx, &port_status);
+
+	}
+
+
+	ch7036_parse_edid(p_ctx);
+
+	return ret;
+
+}
+
+
+
+int ch7036_get_attributes(void *p_context, unsigned long *p_num_attr,
+	pd_attr_t **pp_list)
+{
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
+
+
+
+	PD_DEBUG("ch7036: ch7036_get_attributes()-enter\n");
+
+
+
+	if (!p_ctx || !p_num_attr || !pp_list) {
+		return PD_ERR_NULL_PTR;
+	}
+
+	*pp_list = p_ctx->p_ch7036_attr_table;
+
+
+	*p_num_attr  = p_ctx->ch7036_num_attrs;
+
+	PD_DEBUG("ch7036: ch7036_get_attributes()- total num_attrs = [%u]\n",*p_num_attr);
+
+	return PD_SUCCESS;
+}
+
+
+int ch7036_set_attributes(void *p_context, unsigned long num_attrs,
+	pd_attr_t *p_list)
+{
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+	pd_list_entry_attr_t* list_item;
+
+	pd_port_status_t port_status;
+
+	pd_attr_t        *p_curr, *p_attr;
+	int ret;
+	unsigned long i,temp=0;
+	uint32 temp_chan;
+	ch7036_status_t status;
+
+
+	PD_DEBUG("ch7036: ch7036_set_attributes()-enter: num_attrs=%u\n", num_attrs);
+
+
+	ret = PD_INTERNAL_LVDS_MODULE_SET_ATTRIBUTES(ch7036_lvds_set_attrs, (p_ctx->internal_lvds,num_attrs,p_list));
+
+
+
+	if(ret != PD_SUCCESS)
+		return ret;
+
+#ifdef LVDS_ONLY
+		return PD_SUCCESS;
+#endif
+
+
+	if (!p_ctx->init_done) {
+
+		PD_DEBUG("ch7036: ch7036_set_attributes()- at bootup...\n");
+
+		PD_DEBUG("ch7036: ch7036_set_attributes()- p_ctx->hpd [%x]\n", p_ctx->hpd);
+
+		p_attr = pd_get_attr(p_list, num_attrs, PD_ATTR_ID_DISPLAY, 0);
+		if (p_attr && (p_attr->flags & PD_ATTR_FLAG_VALUE_CHANGED) ) {
+
+
+			pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DISPLAY,
+				PD_GET_ATTR_LIST)->current_value
+			= p_attr->current_value;
+
+
+		}
+
+
+		p_attr = pd_get_attr(p_list, num_attrs, PD_ATTR_ID_HDMI_OUT_MODE, 0);
+		p_curr = pd_get_attr(p_ctx->p_ch7036_attr_table, num_attrs, PD_ATTR_ID_HDMI_OUT_MODE, 0);
+
+		if (p_attr && (p_attr->flags & PD_ATTR_FLAG_VALUE_CHANGED) ) {
+
+			if(p_curr) {
+				pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_HDMI_OUT_MODE,
+					PD_GET_ATTR_LIST)->current_value
+				= p_attr->current_value;
+				p_curr->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+			}
+
+
+		}
+
+
+		p_attr = pd_get_attr(p_list, num_attrs, PD_ATTR_ID_DVI_OUT_MODE, 0);
+		p_curr = pd_get_attr(p_ctx->p_ch7036_attr_table, num_attrs, PD_ATTR_ID_DVI_OUT_MODE, 0);
+
+		if (p_attr && (p_attr->flags & PD_ATTR_FLAG_VALUE_CHANGED) ) {
+
+
+
+			if(p_curr) {
+				pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DVI_OUT_MODE,
+					PD_GET_ATTR_LIST)->current_value
+				= p_attr->current_value;
+				p_curr->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+			}
+
+
+		}
+
+
+
+
+		p_attr = pd_get_attr(p_list, num_attrs, PD_ATTR_ID_CRT_OUT_MODE, 0);
+		p_curr = pd_get_attr(p_ctx->p_ch7036_attr_table, num_attrs, PD_ATTR_ID_CRT_OUT_MODE, 0);
+
+		if (p_attr && (p_attr->flags & PD_ATTR_FLAG_VALUE_CHANGED) ) {
+
+			if(p_curr) {
+				pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_CRT_OUT_MODE,
+						PD_GET_ATTR_LIST)->current_value
+					= p_attr->current_value;
+
+				p_curr->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+			}
+
+
+		}
+
+
+
+	}
+
+
+	for (i = 0, p_attr = p_list; i < num_attrs; i++,p_attr++)
+	{
+
+
+		if (!(p_attr->flags & PD_ATTR_FLAG_VALUE_CHANGED)) {
+
+			continue;
+		}
+
+
+		p_attr->flags &= ~PD_ATTR_FLAG_VALUE_CHANGED;
+
+		if (p_attr->flags & PD_ATTR_FLAG_USER_INVISIBLE)
+			continue;
+
+
+		if( (p_attr->id == 0x1A) || (p_attr->id == 0x1B) ||
+			(p_attr->id == 0x3C) || (p_attr->id == 0x46) ||
+			(p_attr->id == 0x47) )
+			continue;
+
+#if 0
+
+		p_curr = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,p_attr->id,
+				PD_GET_ATTR_LIST);
+#endif
+
+
+		p_curr = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,p_attr->id,
+				0);
+		PD_DEBUG("ch7036_set_attributes(): attribute changed is of type [%ld] name [%s] id [%ld]\n",p_attr->type, p_attr->name, p_attr->id);
+
+		PD_DEBUG("ch7036_set_attributes():current value [%ld] requested value [%ld]\n",p_curr->current_value, p_attr->current_value);
+
+
+		temp = p_curr->current_value;
+		p_curr->current_value = p_attr->current_value;
+		switch (p_attr->id) {
+			case PD_ATTR_ID_DISPLAY:
+
+				list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DISPLAY,
+							PD_GET_ATTR_LIST_ENTRY);
+
+				p_attr->flags |= PD_ATTR_FLAG_SETMODE;
+
+				if(list_item->value == CHANNEL_AUTO_DETECT) {
+					p_ctx->man_sel_out = 0;
+
+					if(p_ctx->init_done) {
+						p_ctx->hpd |= CH7036HPD_RESERVED1; //force port status inquiry
+						ch7036_get_port_status((void *)p_ctx, &port_status);
+
+					}
+					break;
+				}
+				//end of CHANNEL_AUTO_DETECT, manual selection of display output begins
+
+
+				p_ctx->man_sel_out = 1;
+
+				//1- save a copy
+				temp_chan = p_ctx->prev_outchannel;
+				p_ctx->prev_outchannel = pOutput_Info->channel;
+
+				PD_DEBUG("ch7036_set_attributes():current list item value [0x%x]\n",list_item->value);
+
+				//2- get requested output channel- assume it's allowed
+
+				if(list_item->value & CHANNEL_DVI) {
+					pOutput_Info->channel = (list_item->value & 0x01) | CHANNEL_HDMI;
+				}
+				else
+					pOutput_Info->channel = list_item->value;
+
+				PD_DEBUG("ch7036_set_attributes():current output channel value [0x%x]\n",pOutput_Info->channel);
+
+				//3- check requested selection vs what is available
+				status = ch7036_get_attached_device(p_ctx); //manual mode- verify its selection and correct if needed
+
+				//4- NOT allowed display choice- also include when none is connected
+				if( status == SS_DISPLAY_CHOICE_NOT_ALLOWED) {  //restore previous states
+					PD_DEBUG("ch7036_set_attributes(): display choice is not allowed- restore prev. states...\n");
+
+					p_ctx->hpd &= 0xEF;	 //reset
+
+					if(p_ctx->init_done){
+						pOutput_Info->channel = p_ctx->prev_outchannel;
+						p_ctx->prev_outchannel = temp_chan;
+						p_curr->current_value = temp;
+						//when system is restarted right after this point, need to provide main driver w/ a valid
+						//restored choice
+						p_attr->current_value = p_curr->current_value;
+						if(p_curr->current_value==1)
+							p_ctx->man_sel_out = 0;
+
+					}
+					else { //at installation, when init is not done, if manual choice is not valid, revert to auto
+
+						p_curr->current_value = 1;
+						p_ctx->man_sel_out = 0;
+
+						if (pOutput_Info->channel & CHANNEL_HDMI) //DVI mapped to CHANNEL_HDMI
+						{
+							pOutput_Info->channel = (pOutput_Info->channel & 0x01) | CHANNEL_VGA;
+							p_ctx->prev_outchannel = pOutput_Info->channel;
+
+						}
+						else { //VGA
+							pOutput_Info->channel = (pOutput_Info->channel & 0x01) | CHANNEL_HDMI;
+							p_ctx->prev_outchannel = pOutput_Info->channel;
+						}
+
+
+					}
+
+					PD_DEBUG("ch7036_set_attributes(): p_curr->current_value is: [%x]\n",p_curr->current_value);
+					if(p_ctx->hpd == 0x50) {//none is attached
+						pOutput_Info->channel &= CHANNEL_LVDS;
+						p_ctx->prev_outchannel = pOutput_Info->channel;
+					}
+
+
+				}
+				PD_DEBUG("ch7036_set_attributes(): now- output display channel is: value [%ld]\n",pOutput_Info->channel);
+
+
+				//special case channel CHANNEL_xxx_HDMI:
+				//incoming dvi format => convert to hdmi format- or- incoming hdmi format => convert to dvi format
+				if( ( (pOutput_Info->hdmi_fmt.is_dvi_mode==1) && ((list_item->value & 0x02) == CHANNEL_HDMI) ) ||
+					( (pOutput_Info->hdmi_fmt.is_dvi_mode==0) && ((list_item->value & 0x08) == CHANNEL_DVI) )
+					)
+					p_ctx->hpd |= 0x40; //request edid read again to update hdmi/dvi format accordingly
+
+
+				//base on 'new' attached info, read edid and set proper display output channel, including DVI
+				//case: manual selection w/ hpd change
+				if(p_ctx->hpd & 0x44) 	{
+					ch7036_alter_display_channel(p_ctx);
+				}
+
+				if( (pOutput_Info->channel & 0x04) == CHANNEL_VGA || p_curr->current_value==1  /* Coerced Auto Detect */ )
+					break;
+
+				//case:
+				//channel CHANNEL_xxx_HDMI- update list item xxx_DVI or xxx_HDMI accordingly
+				if((pOutput_Info->channel & CHANNEL_HDMI) && (pOutput_Info->hdmi_fmt.is_dvi_mode==1) )
+					p_curr->current_value = (pOutput_Info->channel & 0x01) == CHANNEL_LVDS?3:6;//lvds-dvi:dvi
+
+				else
+					if((pOutput_Info->channel & CHANNEL_HDMI) && (pOutput_Info->hdmi_fmt.is_dvi_mode==0) )
+						p_curr->current_value = (pOutput_Info->channel & 0x01) == CHANNEL_LVDS?2:5;//lvds-hdmi:hdmi
+
+				PD_DEBUG("ch7036_set_attributes(): after alter channel- output display channel is: value [%ld]\n",pOutput_Info->channel);
+
+				break;
+
+			case PD_ATTR_ID_HDMI_OUT_MODE:
+				list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_HDMI_OUT_MODE,
+							PD_GET_ATTR_LIST_ENTRY);
+				p_ctx->hdmi_mode_index = list_item->value;
+				PD_DEBUG("ch7036_set_attributes(): updated hdmi_mode_index is: value [%ld]\n",p_ctx->hdmi_mode_index);
+				p_attr->flags |= PD_ATTR_FLAG_SETMODE;
+				break;
+
+			case PD_ATTR_ID_DVI_OUT_MODE:
+				list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DVI_OUT_MODE,
+							PD_GET_ATTR_LIST_ENTRY);
+				p_ctx->dvi_mode_index = list_item->value;
+				PD_DEBUG("ch7036_set_attributes(): updated dvi_mode_index is: value [%ld]\n",p_ctx->dvi_mode_index);
+				p_attr->flags |= PD_ATTR_FLAG_SETMODE;
+				break;
+
+			case PD_ATTR_ID_CRT_OUT_MODE:
+				list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_CRT_OUT_MODE,
+							PD_GET_ATTR_LIST_ENTRY);
+				p_ctx->crt_mode_index = list_item->value;
+				PD_DEBUG("ch7036_set_attributes(): updated crt_mode_index is: value [%ld]\n",p_ctx->crt_mode_index);
+				p_attr->flags |= PD_ATTR_FLAG_SETMODE;
+				break;
+
+			case PD_ATTR_ID_HPOSITION: //these attributes are for vga only
+			case PD_ATTR_ID_VPOSITION:
+
+				PD_DEBUG("ch7036_set_attributes(): set vga h/v position...\n");
+
+				//save vga h/v attribute context
+				if(p_curr->current_value > ((pd_range_attr_t *)p_curr)->max)
+					p_curr->current_value = ((pd_range_attr_t *)p_curr)->max;
+				else if (p_curr->current_value < ((pd_range_attr_t *)p_curr)->min)
+					p_curr->current_value = ((pd_range_attr_t *)p_curr)->min;
+
+
+				if( pOutput_Info->channel & CHANNEL_HDMI)
+					break;
+
+				if (p_attr->id == PD_ATTR_ID_HPOSITION)
+					pOutput_Info->h_position = (uint16)(p_curr->current_value);
+				else
+					pOutput_Info->v_position = (uint16)(p_curr->current_value);
+
+				ch7036_set_position(p_ctx, (uint8)p_attr->id, (uint16)(p_curr->current_value));
+
+				PD_DEBUG("ch7036_set_attributes(): updated and set vga position: value [%d]\n",p_curr->current_value);
+
+				break;
+			case PD_ATTR_ID_HSCALE:
+			case PD_ATTR_ID_VSCALE:
+			case PD_ATTR_ID_HSCALE_CRT:
+			case PD_ATTR_ID_VSCALE_CRT:
+
+				if(p_curr->current_value > ((pd_range_attr_t *)p_curr)->max)
+					p_curr->current_value = ((pd_range_attr_t *)p_curr)->max;
+				else if (p_curr->current_value < ((pd_range_attr_t *)p_curr)->min)
+					p_curr->current_value = ((pd_range_attr_t *)p_curr)->min;
+
+
+				if(p_attr->id== PD_ATTR_ID_HSCALE || p_attr->id== PD_ATTR_ID_HSCALE_CRT)
+					ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_HSCALE, (uint8)p_curr->current_value);
+				else
+					ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_VSCALE, (uint8)p_curr->current_value);
+				PD_DEBUG("ch7036_set_attributes(): updated scale value is: value [%lu]\n",p_curr->current_value);
+
+				p_attr->flags |= PD_ATTR_FLAG_SETMODE;
+
+				break;
+			case PD_ATTR_ID_DITHER_BYPASS:
+
+
+				PD_DEBUG("ch7036_set_attributes(): updated quality enhance value is: value [%lu]\n",p_curr->current_value);
+				ch7036_set_quality_enhancement(p_ctx,(uint8)p_curr->current_value);
+				break;
+
+			case PD_ATTR_ID_DITHER:
+				p_ctx->dither_select = (uint8)p_curr->current_value;
+				PD_DEBUG("ch7036_set_attributes(): updated dither select value is: value [%lu]\n",p_curr->current_value);
+				ch7036_set_dither(p_ctx);
+
+				break;
+
+			case PD_ATTR_ID_TEXT_FILTER:
+
+				if(p_curr->current_value > ((pd_range_attr_t *)p_curr)->max)
+					p_curr->current_value = ((pd_range_attr_t *)p_curr)->max;
+				else if (p_curr->current_value < ((pd_range_attr_t *)p_curr)->min)
+					p_curr->current_value = ((pd_range_attr_t *)p_curr)->min;
+
+				PD_DEBUG("ch7036_set_attributes(): update text tuning value...\n");
+				ch7036_set_text_enhancement (p_ctx, (uint8) p_curr->current_value);
+
+				break;
+
+			case PD_ATTR_ID_LOAD_FIRMWARE:
+				PD_DEBUG("ch7036_set_attributes(): updated [reload-firmware] value is: value [%lu]\n",p_curr->current_value);
+
+				break;
+
+			case PD_ATTR_ID_DWNSCAL_BYPASS:
+				PD_DEBUG("ch7036_set_attributes(): updated [dwnscal_bypass] value is: value [%lu]\n",p_curr->current_value);
+				if(p_curr->current_value ) {
+					p_ctx->dwnscal_bypass = 1;
+					p_ctx->downscaled[MODE_8x6_7x4_BYPASS]=1;
+				}
+				else {
+					p_ctx->dwnscal_bypass = 0;
+					p_ctx->downscaled[MODE_8x6_7x4_BYPASS]=0;
+				}
+
+				break;
+
+			case PD_ATTR_ID_REFRESH:
+				PD_DEBUG("ch7036_set_attributes(): refresh value is: value [%lu]\n",p_curr->current_value);
+
+				if(p_curr->current_value )
+						p_curr->current_value= 0;
+
+				if(p_ctx->init_done && !p_ctx->man_sel_out ) {
+
+						p_ctx->hpd |= CH7036HPD_RESERVED1; //force port status inquiry- edid read bit
+
+						ch7036_get_port_status((void *)p_ctx, &port_status);
+
+						p_attr->flags |= PD_ATTR_FLAG_SETMODE;
+
+				}
+				break;
+
+			default:
+
+				PD_DEBUG("ch7036_set_attr(): unhandled attr name[%s]id[%ld]curr_index[%lu]\n",p_attr->name, p_attr->id,p_attr->current_value);
+				break;
+
+		}
+
+	}
+
+	PD_DEBUG("ch7036: ch7036_set_attributes()-p_ctx->man_sel_out at exit [0x%x]\n",p_ctx->man_sel_out);
+
+	PD_DEBUG("ch7036: ch7036_set_attributes()-p_ctx->hpd at exit [0x%x]\n",p_ctx->hpd);
+
+	PD_DEBUG("ch7036: ch7036_set_attributes()-exit\n");
+
+	return ret;
+}
+
+int ch7036_set_power(void *p_context, unsigned long state)
+{
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
+	OUTPUT_INFO* pOutput_Info = (p_ctx->p_ch7xxx_context)->pOutput_Info;
+
+
+	int ret;
+
+
+	PD_DEBUG("ch7036: ch7036_set_power()-enter: requested state=%x\n", state);
+
+#ifdef LVDS_ONLY
+	return	PD_INTERNAL_LVDS_MODULE_SET_POWER(ch7036_set_power, (p_ctx->internal_lvds,state));
+#endif
+
+	if (!p_ctx)
+		return PD_ERR_NULL_PTR;
+
+	if (state > PD_POWER_MODE_D3)
+		return PD_ERR_INVALID_POWER;
+
+	if (state != PD_POWER_MODE_D0) {
+
+		if(pOutput_Info->channel != CHANNEL_LVDS_HDMI_VGA_OFF)
+			p_ctx->prev_outchannel = pOutput_Info->channel; //store current output channel before temporarily powered down
+		pOutput_Info->channel = CHANNEL_LVDS_HDMI_VGA_OFF;
+
+
+		ch7036_device_set_power(p_ctx,pOutput_Info->channel);
+
+		ret = PD_INTERNAL_LVDS_MODULE_SET_POWER(ch7036_lvds_set_power, (p_ctx->internal_lvds,state));
+
+
+	}
+	else {
+
+
+		ch7036_set_output_channel(p_ctx,p_ctx->prev_outchannel); //restore previous output channel
+
+		PD_DEBUG("ch7036: ch7036_set_power()- p->ctx-hpd [0x%x]\n",p_ctx->hpd);
+		PD_DEBUG("ch7036: ch7036_set_power()- requested output channel- [%x]\n", pOutput_Info->channel);
+
+
+		PD_INTERNAL_LVDS_MODULE_SET_POWER(ch7036_lvds_set_power, (p_ctx->internal_lvds,state));
+
+		ch7036_device_set_power(p_ctx,pOutput_Info->channel);
+
+	}
+
+
+	p_ctx->pwr_state = state;
+
+	return PD_SUCCESS;
+}
+
+
+int ch7036_get_power(void *p_context, unsigned long *p_state)
+{
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
+
+
+	PD_DEBUG("ch7036: ch7036_get_power()\n");
+
+#ifdef LVDS_ONLY
+	return PD_INTERNAL_LVDS_MODULE_GET_POWER(ch7036_get_power, (p_ctx->internal_lvds,p_state));
+#endif
+
+	*p_state = p_ctx->pwr_state;
+
+	return PD_SUCCESS;
+}
+
+int ch7036_save(void *p_context, void **state, unsigned long flags)
+{
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
+	OUTPUT_INFO* pOutput_Info = (p_ctx->p_ch7xxx_context)->pOutput_Info;
+
+	PD_DEBUG("ch7036: ch7036_save()\n");
+
+#ifdef LVDS_ONLY
+
+	return PD_INTERNAL_LVDS_MODULE_SAVE(ch7036_save,(p_ctx->internal_lvds, state, flags));
+#endif
+
+	//in Linux, when being called @ init, it incorrectly assigned unintialized global attribute value to prev outchannel
+	//p_ctx->prev_outchannel = ch7036_get_output_channel(p_context);
+	//fixed
+	p_ctx->prev_outchannel = pOutput_Info->channel;
+
+
+	*state = NULL;
+
+	return PD_SUCCESS;
+}
+
+
+
+int ch7036_restore(void *p_context, void *state, unsigned long flags)
+{
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
+
+	unsigned long i;
+
+
+
+	PD_DEBUG("ch7036: ch7036_restore()\n");
+
+#ifdef LVDS_ONLY
+
+	return PD_INTERNAL_LVDS_MODULE_RESTORE(ch7036_restore,(p_ctx->internal_lvds, state, flags));
+#endif
+
+
+	if (ch7036_load_firmware(p_ctx) != SS_SUCCESS)   {
+		PD_DEBUG("ch7036: ch7036_restore()-  load fw is NOT a SUCCESS\n");
+		return PD_ERR_UNSUCCESSFUL;
+
+	}
+	else {
+		PD_DEBUG("ch7036: ch7036_restore()-  load fw is a SUCCESS\n");
+	}
+
+
+
+	if(p_ctx->prev_outchannel == CHANNEL_LVDS_HDMI) {
+
+		ch7036_set_output_channel(p_context, p_ctx->prev_outchannel);
+		ch7036_set_mode(p_context, &(p_ctx->native_dtd), 0);
+		ch7036_post_set_mode(p_context, &(p_ctx->native_dtd), 0);
+	}
+
+
+	for(i=0;i<p_ctx->ch7036_num_attrs;i++) {
+
+		if( p_ctx->p_ch7036_attr_table[i].id == PD_ATTR_ID_REFRESH ) {
+
+
+			p_ctx->p_ch7036_attr_table[i].flags |= PD_ATTR_FLAG_VALUE_CHANGED;
+			p_ctx->p_ch7036_attr_table[i].current_value = 1;
+
+			ch7036_set_attributes(p_context, 1, &p_ctx->p_ch7036_attr_table[i]);
+			break;
+		}
+
+	}
+
+
+	return PD_SUCCESS;
+
+}
+
+
+int ch7036_get_port_status(void *context, pd_port_status_t *port_status)
+{
+	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)context;
+	OUTPUT_INFO* pOutput_Info = (p_ctx->p_ch7xxx_context)->pOutput_Info;
+
+#if 0
+	FW7036_CFG* fv = (FW7036_CFG*) p_ctx->fw;
+	int ret;
+#endif
+
+	port_status->display_type = PD_DISPLAY_LVDS_INT;
+	port_status->connected    = PD_DISP_STATUS_UNKNOWN;
+
+
+	PD_DEBUG("ch7036: ch7036_get_port_status()-enter... p_ctx->hpd [%x]\n", p_ctx->hpd);
+
+#if 0
+	PD_DEBUG("Get LHFM Version Information.\r\n");
+	ret = LHFM_get_version(p_ch7xxx_context, fv);
+	if (0==ret) {
+		PD_DEBUG("Ma_ver=%d, mi_ver=%d, did=%02X, rid= %02X, capability=%s\r\n",
+			fv->ver_major, fv->ver_minor, fv->did, fv->rid, (fv->capbility & 0x2) ? "EDID+HDCP" : "EDID");
+	}
+	else {
+		PD_DEBUG("--- failed!\r\n");
+		PD_DEBUG("status: [%s]\n",ret ==-1?"timeout!":"firmware_error!");
+	}
+#endif
+
+
+#ifdef LVDS_ONLY
+
+	return PD_INTERNAL_LVDS_MODULE_GET_PORT_STATUS(ch7036_get_port_status,(p_ctx->internal_lvds, port_status));
+#endif
+
+	if(! (p_ctx->hpd & CH7036HPD_RESERVED1) ) {
+		//note: main driver check port status several times, this block is to speed things up a little
+		if ((p_ctx->init_done) && (pOutput_Info->channel == p_ctx->prev_outchannel ) ) {
+			if(p_ctx ->hpd & 0x22)
+				port_status->connected = PD_DISP_STATUS_ATTACHED;
+			PD_DEBUG("ch7036: ch7036_get_port_status()-output channel UNCHANGED- exit. p_ctx->hpd [%x]\n", p_ctx->hpd);
+			return PD_SUCCESS;
+		}
+
+	}
+
+	if(p_ctx->use_firmware) {
+
+		ch7036_get_attached_device(p_ctx);
+		if(p_ctx ->hpd & 0x22)
+			port_status->connected = PD_DISP_STATUS_ATTACHED;
+
+		ch7036_alter_display_channel(p_ctx);
+
+		}
+
+
+	p_ctx->hpd &= 0xEE;
+
+	PD_DEBUG("ch7036: ch7036_get_port_status()-exit. p_ctx->hpd [%x]\n", p_ctx->hpd);
+	return PD_SUCCESS;
+}
+
+
+
+
+int ch7036_initialize_device(ch7036_device_context_t *p_ctx)
+{
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = (p_ctx->p_ch7xxx_context)->pOutput_Info;
+	PREFER_INFO* pPrefer_Info = p_ch7xxx_context->pPrefer_Info;
+	uint8 reg; //,i=0;
+
+	ch7036_edid_blk_t* p_hedid;
+	ch7036_edid_blk_t* p_cedid ;
+
+
+	PD_DEBUG("ch7036: ch7036_initialize_device()- ENTER...\n");
+
+
+	p_ctx->init_done = 0;
+	p_ctx->hpd = 0;
+
+	p_ctx->downscaled[MODE_6x4_BYPASS] = 1;
+	p_ctx->downscaled[MODE_8x6_7x4_BYPASS] = 1;
+	p_ctx->dwnscal_bypass = 1;
+
+	if(p_ctx->use_firmware) {
+
+		p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
+		p_cedid = (ch7036_edid_blk_t *)p_ctx->cedid;
+
+
+
+		pd_memcpy(p_cedid->etiming_I,et_I,8* sizeof(established_timings_t));
+		pd_memcpy(p_cedid->etiming_II,et_II,8* sizeof(established_timings_t));
+
+
+		p_cedid->etiming_man = &et_man;
+
+
+
+		pd_memcpy(p_hedid->etiming_I,et_I,8* sizeof(established_timings_t));
+		pd_memcpy(p_hedid->etiming_II,et_II,8* sizeof(established_timings_t));
+
+		p_hedid->etiming_man = &et_man;
+
+
+		p_cedid->is_edid = 0;
+		p_hedid->is_edid = 0;
+		p_cedid->ebn = 0;
+		p_hedid->ebn = 0;
+
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x04);
+		reg = I2CRead(p_ch7xxx_context,0x52);
+		reg = reg & 0xEF;
+		I2CWrite(p_ch7xxx_context,0x52, reg);
+
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x0);
+		reg = I2CRead(p_ch7xxx_context,0x07);
+		reg = reg & 0x70;
+		I2CWrite(p_ch7xxx_context,0x07, reg);
+
+		I2CWrite(p_ch7xxx_context,0x4E, I2CRead(p_ch7xxx_context,0x4E) & 0x7F);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x01);
+		reg = I2CRead(p_ch7xxx_context,0x0F);
+		reg = reg & 0x7F;
+		I2CWrite(p_ch7xxx_context,0x0F, reg);
+
+		I2CWrite(p_ch7xxx_context,0x03, 0x03);
+		reg = I2CRead(p_ch7xxx_context,0x6E);
+		reg = reg & 0xBF;
+		I2CWrite(p_ch7xxx_context,0x6E, reg | 0x40);
+
+
+	}
+
+
+	pOutput_Info->hdmi_fmt.is_dvi_mode = 0;
+
+	pOutput_Info->channel = CHANNEL_LVDS | CHANNEL_HDMI;
+
+
+
+	PD_DEBUG("ch7036: ch7036_initialize_device()- default output channel is [%u]\n",pOutput_Info->channel);
+
+
+
+	pOutput_Info->h_position = DEFAULT_POSITION;
+	pOutput_Info->v_position = DEFAULT_POSITION;
+
+
+	p_ctx->dither_select = DITHER_18_TO_18;
+	p_ctx->man_sel_out= 0;
+
+	ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_HSCALE, HDMI_DEFAULT_UNDERSCAN);
+	ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_VSCALE, HDMI_DEFAULT_UNDERSCAN);
+
+	ch7036_set_prefer_timing_info(p_ctx,pPrefer_Info);
+
+	return PD_SUCCESS;
+}
+
+
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.h
index 6798815..64ea9a5 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.h
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_port.h
@@ -1,59 +1,59 @@
-/*-----------------------------------------------------------------------------
-* Copyright (c) Chrontel Inc.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy
-* of this software and associated documentation files (the "Software"), to deal
-* in the Software without restriction, including without limitation the rights
-* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-* copies of the Software, and to permit persons to whom the Software is
-* furnished to do so, subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in
-* all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-* THE SOFTWARE.
-*
-*-----------------------------------------------------------------------------
-* @file  ch7036_port.h
-* @version 1.2.2
-*-----------------------------------------------------------------------------
-*/
-
-
-#ifndef _CH7036_PORT_H_
-#define _CH7036_PORT_H_
-
-
-
-#include "ch7036_intf.h"
-#include "ch7036_attr.h"
-
-int ch7036_open(pd_callback_t *p_callback, void **p_context);
-int ch7036_init_device(void *p_context);
-int ch7036_get_timing_list(void *p_context, pd_timing_t *p_in_list,
-	pd_timing_t **pp_out_list);
-int ch7036_set_mode(void *p_context, pd_timing_t *p_mode, unsigned long flags);
-int ch7036_post_set_mode(void *p_context, pd_timing_t *p_mode,
-	unsigned long flags);
-
-int ch7036_get_attributes(void *p_context, unsigned long *p_num_attr,
-	pd_attr_t **pp_list);
-int ch7036_set_attributes(void *p_context, unsigned long num_attr,
-	pd_attr_t *p_list);
-unsigned long ch7036_validate(unsigned long cookie);
-int ch7036_close(void *p_context);
-
-int ch7036_set_power(void *p_context, unsigned long state);
-int ch7036_get_power(void *p_context, unsigned long *p_state);
-int ch7036_save(void *p_context, void **pp_state, unsigned long flags);
-int ch7036_restore(void *p_context, void *p_state, unsigned long flags);
-int ch7036_get_port_status(void *context, pd_port_status_t *port_status);
-
-
-#endif 
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_port.h
+* @version 1.2.2
+*-----------------------------------------------------------------------------
+*/
+
+
+#ifndef _CH7036_PORT_H_
+#define _CH7036_PORT_H_
+
+
+
+#include "ch7036_intf.h"
+#include "ch7036_attr.h"
+
+int ch7036_open(pd_callback_t *p_callback, void **p_context);
+int ch7036_init_device(void *p_context);
+int ch7036_get_timing_list(void *p_context, pd_timing_t *p_in_list,
+	pd_timing_t **pp_out_list);
+int ch7036_set_mode(void *p_context, pd_timing_t *p_mode, unsigned long flags);
+int ch7036_post_set_mode(void *p_context, pd_timing_t *p_mode,
+	unsigned long flags);
+
+int ch7036_get_attributes(void *p_context, unsigned long *p_num_attr,
+	pd_attr_t **pp_list);
+int ch7036_set_attributes(void *p_context, unsigned long num_attr,
+	pd_attr_t *p_list);
+unsigned long ch7036_validate(unsigned long cookie);
+int ch7036_close(void *p_context);
+
+int ch7036_set_power(void *p_context, unsigned long state);
+int ch7036_get_power(void *p_context, unsigned long *p_state);
+int ch7036_save(void *p_context, void **pp_state, unsigned long flags);
+int ch7036_restore(void *p_context, void *p_state, unsigned long flags);
+int ch7036_get_port_status(void *context, pd_port_status_t *port_status);
+
+
+#endif
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_reg_table.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_reg_table.h
index 8e0c18d..cc12975 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_reg_table.h
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_reg_table.h
@@ -1,30 +1,30 @@
-/*-----------------------------------------------------------------------------
-* Copyright (c) Chrontel Inc.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy
-* of this software and associated documentation files (the "Software"), to deal
-* in the Software without restriction, including without limitation the rights
-* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-* copies of the Software, and to permit persons to whom the Software is
-* furnished to do so, subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in
-* all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-* THE SOFTWARE.
-*
-*-----------------------------------------------------------------------------
-* @file  ch7036_reg_table.h
-* @version 1.2
-*-----------------------------------------------------------------------------
-*/
-
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_reg_table.h
+* @version 1.2
+*-----------------------------------------------------------------------------
+*/
+
 #ifndef _CH7036_REG_TABLE_H
 #define _CH7036_REG_TABLE_H
 
@@ -33,67 +33,67 @@
 typedef enum{
 	BASE_FLAG = 0,
 
-	
-	HTI,	VTI,	HAI,	VAI,	HOI,	VOI,	HWI,	VWI,	RCLK, 
+
+	HTI,	VTI,	HAI,	VAI,	HOI,	VOI,	HWI,	VWI,	RCLK,
 	DITHER_SEL1_SPP,		DITHER_SEL0_SPP,		HSYNCP_SPP,		VSYNCP_SPP,
 	NP_INV0_SPP,	NP_INV1_SPP,	NP_INV2_SPP,	NP_INV3_SPP,	LVDS_IN_ORDER,
 
-	
+
 	LVDS0_SEQ_SPP,	LVDS1_SEQ_SPP,	LVDS2_SEQ_SPP,	LVDS3_SEQ_SPP,	LVDSCLK_SEQ_SPP,
-	HSYNC_CNT_TH_SPP,				PRBS_SET_SEL_SPP,				
-	LVDS0_POL_SPP,	LVDS1_POL_SPP,	LVDS2_POL_SPP,	LVDS3_POL_SPP,	LVDSCLK_POL_SPP,		
+	HSYNC_CNT_TH_SPP,				PRBS_SET_SEL_SPP,
+	LVDS0_POL_SPP,	LVDS1_POL_SPP,	LVDS2_POL_SPP,	LVDS3_POL_SPP,	LVDSCLK_POL_SPP,
+
 
-	
-	HTO,	VTO,	HAO,	VAO,	HOO_HDMI,		VOO_HDMI,		HWO_HDMI,	VWO_HDMI,	
-	HPO_I,	VPO_I,	DEPO_I,	HPO_O,	VPO_O,			DEPO_O,	
+	HTO,	VTO,	HAO,	VAO,	HOO_HDMI,		VOO_HDMI,		HWO_HDMI,	VWO_HDMI,
+	HPO_I,	VPO_I,	DEPO_I,	HPO_O,	VPO_O,			DEPO_O,
 
-	
-	HD_DVIB,		INTLC,			HD_LV_POL,		HD_LV_SEQ,		HDMI_LVDS_SEL, 
+
+	HD_DVIB,		INTLC,			HD_LV_POL,		HD_LV_SEQ,		HDMI_LVDS_SEL,
 	VSP,			HSP,			HDMIIN_HSP,		HDMIIN_VSP,		HDMIIN_DEP,
 	M1M0,			C1C0,			VIC,
 	COPY,			SCAN_EN,		HAO_SCL,		VAO_SCL,
 
-	
-	I2SPOL,			I2S_SPDIFB,		I2S_LENGTH,		I2SFMT,		
+
+	I2SPOL,			I2S_SPDIFB,		I2S_LENGTH,		I2SFMT,
 	UCLK,			PCLK_NUM,
 
-	
-	UCLKSEC,		PLL1N1,			PLL1N2,			PLL1N3,			PLL3N8,		A2,			MCLK, 
+
+	UCLKSEC,		PLL1N1,			PLL1N2,			PLL1N3,			PLL3N8,		A2,			MCLK,
 	PLL2N5,			PLL2N54,		PLL2N53,		PLL2N6,			PLL2N7,		DIVXTAL,
 	A1,				A3,				TXPLL_FFD,		DRI_PLL_N1,		DRI_PLL_N3, UCLKOD_SEL,
-	GCKSEL,         TSTEN1, 
+	GCKSEL,         TSTEN1,
+
 
-	
-	LNSEL,			DAT16_32B,		TRUE24,			TRUE_COM,		WRLEN,	
+	LNSEL,			DAT16_32B,		TRUE24,			TRUE_COM,		WRLEN,
 	ROTATE,			HFLIP,			VFLIP,
 	DNSMPEN,		HADWSPP,		FLTBP2,			FLTBP1,			BLK_H,
 	FBA_INC,		SFM,			THREN,			THRRL,			WRFAST,		CHG_HL,
 	HINCA,			HINCB,			VINCA,			VINCB,			HDINCA,		HDINCB,
 	HINC,			VINC,			HDINC,
-	VSMST,			MEMINIT,		STOP,						
-	
-	
+	VSMST,			MEMINIT,		STOP,
+
+
 	HDMI_PD,		I2S_PD,			SPDIF_PD,		DRI_PD,			DRI_PD_SER,
-	DRI_PD_PLL,		DRI_PDDRI,		CEC_PD,			PD_DDC,	
-	LVDS_PD,		RX_PD,			RXPLL_PD,		TXPLL_PD,		TXDRV_PD,	TXSER_PD,	
-	VGA_PD,			PDDAC,			DACSENCE,       GCKOFF, 
+	DRI_PD_PLL,		DRI_PDDRI,		CEC_PD,			PD_DDC,
+	LVDS_PD,		RX_PD,			RXPLL_PD,		TXPLL_PD,		TXDRV_PD,	TXSER_PD,
+	VGA_PD,			PDDAC,			DACSENCE,       GCKOFF,
 	TV_BP,			PDPLL1,			PDPLL0,			ICEN0,			PD_PROM,		PDMIO,		PDIO,		HPD_PD,
 	SCLPD,			SDPD,			MEMPD,			AUDDAC,
 
-	
+
 	CRYS_FREQ_SPP,	I2SCK_SEC,		SP_EN,			HARD_SOFTB,		MULT_I2CEN,	RXPLL_REFDLY,
 	RXPLL_FBDLY, VFMT,
 
-	
+
 	DBP,			CK_TVINV,		DISPON,
-	
+
 	VP,	HP,
-	
+
 	TXTEN,
 	ZRCTS,
-	
+
 	MUL_ID_END,
-	
+
 }MULTI_REG_ID;
 
 typedef struct{
@@ -115,7 +115,7 @@ typedef struct{
 
 extern MULTI_REG g_MultiRegTable[];
 
-//issue- 11/15/11- thua 
+//issue- 11/15/11- thua
 //Intel C compiler complained negative constant (-1) comparison to unsigned char for checked build verion
 //for free build, these warnings are treated as compiling error
 //solution:
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_typedef.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_typedef.h
index 57c987b..35e3f91 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_typedef.h
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/ch7036_typedef.h
@@ -1,31 +1,31 @@
-/*-----------------------------------------------------------------------------
-* Copyright (c) Chrontel Inc.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy
-* of this software and associated documentation files (the "Software"), to deal
-* in the Software without restriction, including without limitation the rights
-* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-* copies of the Software, and to permit persons to whom the Software is
-* furnished to do so, subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in
-* all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-* THE SOFTWARE.
-*
-*-----------------------------------------------------------------------------
-* @file  ch7036_typedef.h
-* @version 1.2
-*-----------------------------------------------------------------------------
-*/
-
-
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  ch7036_typedef.h
+* @version 1.2
+*-----------------------------------------------------------------------------
+*/
+
+
 #ifndef _CH7036_TYPEDEF_H
 #define _CH7036_TYPEDEF_H
 
@@ -66,8 +66,8 @@ typedef struct{
 	uint16 va;
 	uint16 vo;
 	uint16 vw;
-	uint16 hz;  
-	uint16 stype; 
+	uint16 hz;
+	uint16 stype;
 
 }TIMING, *PTIMING;
 
@@ -88,17 +88,17 @@ typedef struct{
 #define TIMING_LIST_END			2
 
 typedef struct{
-	
+
 	TIMING timing;
 	uint32 rx_clk_khz;
-	uint8  pixel_fmt;	
-	uint8  hs_pol;		
+	uint8  pixel_fmt;
+	uint8  hs_pol;
 	uint8  vs_pol;
 	uint8  de_pol;
-	uint8  data_ch_pol;	
+	uint8  data_ch_pol;
 	uint8  data_ch_invert;
-	
-	uint8  audio_type;	
+
+	uint8  audio_type;
 	uint8  i2s_pol;
 	uint8  i2s_len;
 	uint8  i2s_fmt;
@@ -122,30 +122,30 @@ typedef struct{
 #define LVDS_CHANNAL_SWAP_OP5		(LVDS_DATA3_SEL << 0) | (LVDS_CLOCK_SEL << 4) | (LVDS_DATA2_SEL << 8) | (LVDS_DATA1_SEL << 12) | (LVDS_DATA0_SEL << 16)
 
 typedef struct{
-	uint32 channel_swap;	
-	uint32 channel_pol;		
-	uint32 pixel_fmt;		
+	uint32 channel_swap;
+	uint32 channel_pol;
+	uint32 pixel_fmt;
 }LVDS_FMT, *PLVDS_FMT;
 
 #define AS_RATIO_4_3		1
 #define AS_RATIO_16_9		2
 
 typedef struct{
-	uint8 is_dvi_mode;		
-	uint8 format_index;		
-	uint8 aspect_ratio;		
-	uint8 channel_swap;		
-	uint8 data_pol_invert;	
-	uint8 hs_pol;			
-	uint8 vs_pol;			
-	uint8 protect_enable;	
+	uint8 is_dvi_mode;
+	uint8 format_index;
+	uint8 aspect_ratio;
+	uint8 channel_swap;
+	uint8 data_pol_invert;
+	uint8 hs_pol;
+	uint8 vs_pol;
+	uint8 protect_enable;
 }HDMI_FMT, *PHDMI_FMT;
 
 typedef struct{
-	uint8 channel_swap;		
-	uint8 hs_pol;			
-	uint8 vs_pol;			
-	uint8 de_pol;			
+	uint8 channel_swap;
+	uint8 hs_pol;
+	uint8 vs_pol;
+	uint8 de_pol;
 }VGA_FMT, *PVGA_FMT;
 
 
@@ -155,11 +155,11 @@ typedef struct{
 #define CHANNEL_DVI			(1 << 3)
 #define CHANNEL_LVDS_HDMI 	(CHANNEL_LVDS | CHANNEL_HDMI)
 #define CHANNEL_LVDS_VGA 	(CHANNEL_LVDS | CHANNEL_VGA)
-#define CHANNEL_LVDS_DVI 	(CHANNEL_LVDS | CHANNEL_DVI)  
-#define CHANNEL_AUTO_DETECT	0x10 
+#define CHANNEL_LVDS_DVI 	(CHANNEL_LVDS | CHANNEL_DVI)
+#define CHANNEL_AUTO_DETECT	0x10
 
 
-#define CHANNEL_LVDS_HDMI_VGA_OFF	0x0000  
+#define CHANNEL_LVDS_HDMI_VGA_OFF	0x0000
 
 
 
@@ -170,19 +170,19 @@ typedef struct{
 #define ROTATE_270			3
 
 typedef struct{
-	uint32 channel;			
-	LVDS_FMT lvds_fmt;		
-	HDMI_FMT hdmi_fmt;		
-	VGA_FMT vga_fmt;		
-	TIMING timing;			
-	uint32 uclk_khz;		
-	uint8  ds_percent_h;	
-	uint8  ds_percent_v;	
-	uint8  rotate;			
-	uint8  h_flip;			
-	uint8  v_flip;			
-	uint16  h_position;			
-	uint16  v_position;			
+	uint32 channel;
+	LVDS_FMT lvds_fmt;
+	HDMI_FMT hdmi_fmt;
+	VGA_FMT vga_fmt;
+	TIMING timing;
+	uint32 uclk_khz;
+	uint8  ds_percent_h;
+	uint8  ds_percent_v;
+	uint8  rotate;
+	uint8  h_flip;
+	uint8  v_flip;
+	uint16  h_position;
+	uint16  v_position;
 }OUTPUT_INFO, *POUTPUT_INFO;
 
 
@@ -194,31 +194,31 @@ typedef struct{
 #define RST_BIT_HSYNC				0
 #define RST_BIT_VSYNC				1
 
-#define MEM_CLK_FREQ_MAX			166000	
-#define FBA_INC_MAX					3000	
+#define MEM_CLK_FREQ_MAX			166000
+#define FBA_INC_MAX					3000
 
-#define THRRL_ADJUST_DEF			200	
+#define THRRL_ADJUST_DEF			200
 
-#define THRRL_ADJUST_OP1			250		
-#define THRRL_ADJUST_OP2			300		
+#define THRRL_ADJUST_OP1			250
+#define THRRL_ADJUST_OP2			300
 
 typedef struct{
-	uint32 mclk_khz;		
-	
-	uint8 uclkod_sel;		
-	uint8 dat16_32b;		
-	uint8 true24;			
-	uint8 true_com;			
-	
-	uint8 lvds_out_hs_tolerance;	
-	uint8 lvds_out_reset_bit_sel;	
-	
-	uint8 dither_filter_enable;		
-	uint8 hscale_ratio_gate;		
-	
-	uint8 scale_line_adjust;		
-	uint8  text_enhancement;	
-			
+	uint32 mclk_khz;
+
+	uint8 uclkod_sel;
+	uint8 dat16_32b;
+	uint8 true24;
+	uint8 true_com;
+
+	uint8 lvds_out_hs_tolerance;
+	uint8 lvds_out_reset_bit_sel;
+
+	uint8 dither_filter_enable;
+	uint8 hscale_ratio_gate;
+
+	uint8 scale_line_adjust;
+	uint8  text_enhancement;
+
 	uint8 pll_ref_dly;
 	uint8 pll_ref_fbdly;
 	uint8 lvds_txdrv_ctrl;
@@ -230,8 +230,8 @@ typedef struct{
 	uint8 eye_dri_damp;
 	uint8 eye_dri_pll_rlf;
 	uint8 eye_rdac;
-	
-	uint8 reset; 
+
+	uint8 reset;
 	uint8 vga_enable;
 
 }PREFER_INFO, *PPREFER_INFO;
@@ -243,7 +243,7 @@ typedef struct{
 	INPUT_INFO* pInput_Info;
 	OUTPUT_INFO* pOutput_Info;
 	PREFER_INFO* pPrefer_Info;
-	void*	pd_context; 
+	void*	pd_context;
 }DEV_CONTEXT, *PDEV_CONTEXT;
 
 typedef struct{
@@ -259,23 +259,23 @@ typedef enum hdmi{
 	OUT_HDMI_640x480P_60,
 
 	OUT_HDMI_720x480P_59,
-	OUT_HDMI_720x480P_60, 
+	OUT_HDMI_720x480P_60,
 
 	OUT_HDMI_720x576P_50,
 
 	OUT_HDMI_1280x720P_59,
-	OUT_HDMI_1280x720P_60, 
+	OUT_HDMI_1280x720P_60,
 
-	OUT_HDMI_1920x1080I_59, 
-	OUT_HDMI_1920x1080I_60, 
+	OUT_HDMI_1920x1080I_59,
+	OUT_HDMI_1920x1080I_60,
 
 	OUT_HDMI_1920x1080P_59,
-	OUT_HDMI_1920x1080P_60, 
+	OUT_HDMI_1920x1080P_60,
 
 //	OUT_HDMI_720x576P_50, //2/2/12 grouped to downscaling modes < 13x7
 	OUT_HDMI_1280x720P_50,
 	OUT_HDMI_1920x1080I_50,
-	
+
 	OUT_HDMI_1920x1080P_50,
 
 	OUT_HDMI_1920x1080P_23,
@@ -287,10 +287,10 @@ typedef enum hdmi{
 	OUT_HDMI_1920x1080I_100,
 	OUT_HDMI_1280x720P_100,
 	OUT_HDMI_720x576P_100,
-	
+
 	OUT_HDMI_1920x1080I_119,
 	OUT_HDMI_1920x1080I_120,
-    
+
 	OUT_HDMI_1280x720P_119,
 	OUT_HDMI_1280x720P_120,
 
@@ -299,7 +299,7 @@ typedef enum hdmi{
 
 	OUT_HDMI_720x576P_200,
     OUT_HDMI_1280x720P_239,
-	OUT_HDMI_1280x720P_240, 
+	OUT_HDMI_1280x720P_240,
 	OUT_HDMI_END,
 }HDMI_OUT_MODE;
 
@@ -330,8 +330,8 @@ typedef enum dvi {
 	OUT_DVI_1366x768_60,
 
 	OUT_DVI_1400x1050_60,
-	OUT_DVI_1400x1050_75, 
-	
+	OUT_DVI_1400x1050_75,
+
 
 	OUT_DVI_1440x900_60,
 	OUT_DVI_1440x1050_60,
@@ -339,9 +339,9 @@ typedef enum dvi {
 	OUT_DVI_1600x1200_60,
 	OUT_DVI_1680x1050_60,
 
-	OUT_DVI_1920x1080_60, 
+	OUT_DVI_1920x1080_60,
 
-	OUT_DVI_1920x1200_60, 
+	OUT_DVI_1920x1200_60,
 
 	OUT_DVI_END,
 } DVI_OUT_MODE;
@@ -351,57 +351,57 @@ typedef enum crt{
 	OUT_CRT_640x400_85 = 0,
 
 	OUT_CRT_640x480_60,
-	
+
 	OUT_CRT_640x480_72,
 	OUT_CRT_640x480_75,
 	OUT_CRT_640x480_85,
-	
+
 	OUT_CRT_720x400_85,
 
 	OUT_CRT_800x600_56,
 
-	    
-	OUT_CRT_800x600_60, 
+
+	OUT_CRT_800x600_60,
 	OUT_CRT_800x600_72,
 	OUT_CRT_800x600_75,
-	OUT_CRT_800x600_85, 
+	OUT_CRT_800x600_85,
 
 	OUT_CRT_1024x768_60,
 	OUT_CRT_1024x768_70,
-	OUT_CRT_1024x768_75, 
-	OUT_CRT_1024x768_85, 
-	
+	OUT_CRT_1024x768_75,
+	OUT_CRT_1024x768_85,
+
+
 
-	
 	OUT_CRT_1152x864_75,
-	
-	OUT_CRT_1280x768_60,  
-	OUT_CRT_1280x768_75,  
-	OUT_CRT_1280x768_85,  
-	
+
+	OUT_CRT_1280x768_60,
+	OUT_CRT_1280x768_75,
+	OUT_CRT_1280x768_85,
+
 	OUT_CRT_1280x960_60,
-	OUT_CRT_1280x960_85, 
+	OUT_CRT_1280x960_85,
 
 	OUT_CRT_1280x1024_60,
 	OUT_CRT_1280x1024_75,
-	OUT_CRT_1280x1024_85, 
+	OUT_CRT_1280x1024_85,
 
-	OUT_CRT_1360x768_60,   
+	OUT_CRT_1360x768_60,
 
 	OUT_CRT_1400x1050_60,
 	OUT_CRT_1400x1050_75,
-	
+
 
 
 	OUT_CRT_1440x900_60,
 	OUT_CRT_1440x1050_60,
 
-	OUT_CRT_1600x900_60, 
-	OUT_CRT_1600x1200_60,  
-	
-	OUT_CRT_1920x1080_60, 
+	OUT_CRT_1600x900_60,
+	OUT_CRT_1600x1200_60,
+
+	OUT_CRT_1920x1080_60,
+
 
-	
 
 	OUT_CRT_END,
 }CRT_OUT_MODE;
@@ -421,7 +421,7 @@ typedef enum crt{
 #define ERR_DEVICE_NO_EXIST					105
 #define ERR_NO_SUPPORT_TRUE24				106
 #define ERR_NO_SUPPORT_TRUECOM				107
-#define ERR_ROTATION_WITH_VAI				108 
+#define ERR_ROTATION_WITH_VAI				108
 #define ERR_FLIP_WITH_VAI					109
 
 #define ERR_DEVICE_CONFIG					200
@@ -434,30 +434,30 @@ typedef enum crt{
 #define ERR_PLL2N6_WRONG					207
 #define ERR_PLL2N7_WRONG					208
 #define ERR_DMXTAL_WRONG					209
-#define ERR_HDMI_CLOCK_NO_SUPPORT			210	
+#define ERR_HDMI_CLOCK_NO_SUPPORT			210
 
 #define ERR_DEVICE_RUNNING					300
-#define ERR_CAL_INC_DIV_ZERO				301		
+#define ERR_CAL_INC_DIV_ZERO				301
 #define	ERR_CAL_INC_NO_MATH					302
 
 
 
 typedef enum {
-    SS_POWER_ON_STATE,       
-    SS_SUCCESS,              
-    SS_NOT_SUPPORTED,        
-    SS_INVALID_ARGUMENT,     
-    SS_PENDING,              
-    SS_TARGET_UNSPECIFIED,   
-    SS_SCALING_UNSUPPORTED,  
+    SS_POWER_ON_STATE,
+    SS_SUCCESS,
+    SS_NOT_SUPPORTED,
+    SS_INVALID_ARGUMENT,
+    SS_PENDING,
+    SS_TARGET_UNSPECIFIED,
+    SS_SCALING_UNSUPPORTED,
 
 	SS_MEM_ALLOC_ERR,
 
-    
-    SS_UNSUCCESSFUL = 10,    
-    SS_INVALID_RETURN,       
-    SS_WRITE_FAILED,         
-    SS_READ_FAILED,          
+
+    SS_UNSUCCESSFUL = 10,
+    SS_INVALID_RETURN,
+    SS_WRITE_FAILED,
+    SS_READ_FAILED,
 
 	SS_FIRMWARE_ERR,
 	SS_FIRMWARE_TIMEOUT,
diff --git a/drivers/gpu/drm/emgd/emgd/pal/ch7036/config_.h b/drivers/gpu/drm/emgd/emgd/pal/ch7036/config_.h
index 99949e8..c0c43bb 100644
--- a/drivers/gpu/drm/emgd/emgd/pal/ch7036/config_.h
+++ b/drivers/gpu/drm/emgd/emgd/pal/ch7036/config_.h
@@ -1,73 +1,73 @@
-/*-----------------------------------------------------------------------------
-* Copyright (c) Chrontel Inc.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy
-* of this software and associated documentation files (the "Software"), to deal
-* in the Software without restriction, including without limitation the rights
-* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-* copies of the Software, and to permit persons to whom the Software is
-* furnished to do so, subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in
-* all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-* THE SOFTWARE.
-*
-*-----------------------------------------------------------------------------
-* @file  config_.h
-* @version 1.2.3
-*-----------------------------------------------------------------------------
-*/
-
-#ifndef _CONFIG_H_
-#define _CONFIG_H_
-
-
-#define T_LVDS_OPEN
-#define T_LVDS_INIT
-#define T_POST_SETMODE
-#define T_LVDS_CLOSE
-
-#define T_SET_TIMING
-
-#define T_PD_DISPLAY_LVDS_INT 
-
-#define T_DEVICE_DETECTION 
-#define T_RES_DEALLOC
-
-#define T_TEST_HW
-#define T_RESET
-
-
-#define T_HDMI_TIMING_TABLE
-#define T_VGA_TIMING_TABLE
-#define T_PANEL_NATIVE_DTD
-
-
-#define T_LH_POWER_ON_OFF
-
-#define T_CH7036_USE_LVDS_ATTR_TABLE
-
-#define T_CH7036_INIT_ATTR_TABLE
-
-
-#define T_CH7036_USE_FIRMWARE
-
-#define T_CH7036_EDID_DUMP
-#undef T_CH7036_EDID_DUMP
-
-#define T_SHOW_EDID_DISPLAY_ATTR
-#undef T_SHOW_EDID_DISPLAY_ATTR
-
-#define T_LINUX
-//#undef T_LINUX
-
-#define T_CONFIG_PLB
-
-#endif
+/*-----------------------------------------------------------------------------
+* Copyright (c) Chrontel Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*-----------------------------------------------------------------------------
+* @file  config_.h
+* @version 1.2.3
+*-----------------------------------------------------------------------------
+*/
+
+#ifndef _CONFIG_H_
+#define _CONFIG_H_
+
+
+#define T_LVDS_OPEN
+#define T_LVDS_INIT
+#define T_POST_SETMODE
+#define T_LVDS_CLOSE
+
+#define T_SET_TIMING
+
+#define T_PD_DISPLAY_LVDS_INT
+
+#define T_DEVICE_DETECTION
+#define T_RES_DEALLOC
+
+#define T_TEST_HW
+#define T_RESET
+
+
+#define T_HDMI_TIMING_TABLE
+#define T_VGA_TIMING_TABLE
+#define T_PANEL_NATIVE_DTD
+
+
+#define T_LH_POWER_ON_OFF
+
+#define T_CH7036_USE_LVDS_ATTR_TABLE
+
+#define T_CH7036_INIT_ATTR_TABLE
+
+
+#define T_CH7036_USE_FIRMWARE
+
+#define T_CH7036_EDID_DUMP
+#undef T_CH7036_EDID_DUMP
+
+#define T_SHOW_EDID_DISPLAY_ATTR
+#undef T_SHOW_EDID_DISPLAY_ATTR
+
+#define T_LINUX
+//#undef T_LINUX
+
+#define T_CONFIG_PLB
+
+#endif
diff --git a/drivers/gpu/drm/emgd/include/igd_gmm.h b/drivers/gpu/drm/emgd/include/igd_gmm.h
index e28a809..b262a14 100644
--- a/drivers/gpu/drm/emgd/include/igd_gmm.h
+++ b/drivers/gpu/drm/emgd/include/igd_gmm.h
@@ -1,383 +1,383 @@
-/*
- *-----------------------------------------------------------------------------
- * Filename: igd_gmm.h
- * $Revision: 1.13 $
- *-----------------------------------------------------------------------------
- * Copyright (c) 2002-2010, Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- *
- *-----------------------------------------------------------------------------
- * Description:
- *  This is the public header file for gmm. It should be included by any
- *  client driver or igd module that requires gmm interaction.
- *-----------------------------------------------------------------------------
- */
-
-#ifndef _IGD_MM_H
-#define _IGD_MM_H
-
-#include <igd_mode.h>
-#include <igd_render.h>
-
-/*!
- * @addtogroup gmm_group
- *
- * <B>Relavent Dispatch Functions</B>
- *  - _igd_dispatch::gmm_alloc_surface()
- *  - _igd_dispatch::gmm_alloc_region()
- *  - _igd_dispatch::gmm_free()
- *  - _igd_dispatch::gmm_memstat()
- *  - _igd_dispatch::gmm_alloc_cached()
- *  - _igd_dispatch::gmm_free_cached()
- *  - _igd_dispatch::gmm_flush_cache()
- *
- * @{
- */
-
-/*!
- * @name Surface Alignment Flags
- * @anchor surface_info_flags
- *
- * Surface Alignment Flags are passed to the _igd_dispatch::gmm_alloc_surface()
- * function as an indicator for how the surface will be used.
- *
- * - IGD_SURFACE_RENDER The surface may be used as a rendering target,
- *     this must be set for all color buffers.
- * - IGD_SURFACE_TEXTURE The surface may be used as a texture input.
- * - IGD_SURFACE_CURSOR Surface may be used as a cursor
- * - IGD_SURFACE_OVERLAY Surface may be used with the overlay
- * - IGD_SURFACE_DISPLAY This surface is suitable for use with the display
- *   engine. This flag must be set for any render target that may later
- *   be flipped to the front buffer.
- * - IGD_SURFACE_DEPTH The surface may be used as a depth (Z) buffer.
- * - IGD_SURFACE_DRI2 The surface is a DRI2 allocation (back buffer,
- *   fake front buffer, etc.).  It should be allocated on the general
- *   heap rather than the default '2D' heap.
- *
- * - IGD_SURFACE_YMAJOR If the surface is tiled, it is tiled with the
- *     walk in the YMajor direction. This flag is output only unless the
- *     allocation type is Fixed TF.
- * - IGD_SURFACE_XMAJOR If the surface is tiled, it is tiled with the
- *     walk in the YMajor direction. This flag is output only unless the
- *     allocation type is Fixed TF.
- * - IGD_SURFACE_TILED Surface is tiled. This flag is output only unless
- *     the allocation type is Fixed TF.
- * - IGD_SURFACE_FENCED Surface is fenced. This flaf is output only unless
- *     the allocation type is Fixed TF.
- *
- * Additionally all FB flags can be populated
- * See: @ref fb_info_flags
- *
- * @{
- */
-#define IGD_SURFACE_RENDER    0x00000001
-#define IGD_SURFACE_TEXTURE   0x00000002
-#define IGD_SURFACE_CURSOR    0x00000004
-#define IGD_SURFACE_OVERLAY   0x00000008
-#define IGD_SURFACE_DISPLAY   0x00000010
-#define IGD_SURFACE_DEPTH     0x00000020
-#define IGD_SURFACE_VIDEO     0x00000040
-#define IGD_SURFACE_VIDEO_ENCODE     0x00000080
-#define IGD_SURFACE_DRI2      0x00000100
-
-#define IGD_SURFACE_WALK_MASK 0x00001000
-#define IGD_SURFACE_YMAJOR    0x00001000
-#define IGD_SURFACE_XMAJOR    0x00000000
-#define IGD_SURFACE_TILED     0x00002000
-#define IGD_SURFACE_FENCED    0x00004000
-#define IGD_SURFACE_SYS_MEM   0x00008000
-#define IGD_SURFACE_PHYS_PTR  0x00010000
-#define IGD_SURFACE_CI		0x00020000
-#define IGD_SURFACE_CI_V4L2_MAP	0x00040000		/*will be set when map_method=0 without WA*/
-/*
- * Mipmap flags are only valid on mipmap surfaces.
- * Planes flags are only valid on volume surfaces.
- */
-#define IGD_MIPLEVEL_SHIFT    16
-#define IGD_MIPLEVEL_MASK     (0xf<<IGD_MIPLEVEL_SHIFT)
-#define IGD_NUMPLANES_SHIFT   20
-#define IGD_NUMPLANES_MASK    (0x0ff00000UL)
-
-/*
- * These flags exist in the Framebuffer info data structure also.
- * They are here to insure that no overlap of flags happens.
- */
-#define IGD_SURFACE_RESERVED_FLAGS 0xf0000000
-
-/*! @} */
-
-/*!
- * @name Surface Allocation Types
- * @anchor alloc_surface_types
- *
- * These types are used with the _igd_dispatch::alloc_surface() call to
- * control the allocation behavior.
- *
- *  - IGD_GMM_ALLOC_TYPE_NORMAL Normal surface allocation. GMM will
- *      determine the best tiling and fencing options and return that
- *      information in the surface flags.
- *  - IGD_GMM_ALLOC_TYPE_FIXED_TF Surface allocation will be done using
- *      the tiled and fenced options from the surface flags. GMM will
- *      not override these flags but will fail an allocation if the
- *      tiling options would result in an unusable surface.
- *  - IGD_GMM_ALLOC_TYPE_RESERVATION The offset provided in the call
- *      was reserved earlier. The provided offset must be used. This
- *      may be used with the Fixed bit enabled.
- * @{
- */
-#define IGD_GMM_ALLOC_TYPE_NORMAL       0x0000
-#define IGD_GMM_ALLOC_TYPE_FIXED_TF     0x0001
-#define IGD_GMM_ALLOC_TYPE_RESERVATION  0x0002
-
-/*! @} */
-
-/*!
- * @name Mipmap layout type
- * @anchor alloc_mipmap
- *
- * These constants are used when allocating surfaces to know how many
- * offsets to expect GMM to return.
- *
- * - IGD_GMM_SURFACE_LAYOUT_RIGHT LOD1 be on the right of LOD0
- * - IGD_GMM_SURFACE_LAYOUT_BELOW LOD1 is below LOD0
- * - IGD_GMM_SURFACE_LAYOUT_LEGACY Traditional format, used by 
- *   915 and below
- * @{
- */
-
-#define IGD_GMM_SURFACE_LAYOUT_RIGHT    0x0001
-#define IGD_GMM_SURFACE_LAYOUT_BELOW    0x0002
-#define IGD_GMM_SURFACE_LAYOUT_LEGACY   0x0003
-/*! @} */
-
-/*!
- * @name Surface Allocation Constants
- * @anchor alloc_surface_constants
- *
- * These constants are used when allocating surfaces to know how many
- * offsets to expect GMM to return.
- *
- * - IGD_MAX_MIPLEVELS The maximum number of miplevels returned by GMM.
- * - IGD_MAX_VOLUME_PLANES The maximum number of planes in a volume map.
- * - IGD_MAX_VOLUME_SLICES The maximum number of slices in a mipped volume map.
- *    There are 50% fewer planes with each successive mip level.
- *    The number of slices can be calculated as,
- *     (planes*2 - 1) - ((planes>>lod) - 1)
- * @{
- */
-#define IGD_MAX_MIPLEVELS 12
-#define IGD_MAX_VOLUME_PLANES 256
-#define IGD_MAX_VOLUME_SLICES 511
-/*! @} */
-
-/*!
- * @name Region Alignment Flags
- * @anchor alloc_region_flags
- *
- * @{
- */
-#define IGD_GMM_REGION_ALIGN_MMAP       0x00000001
-#define IGD_GMM_REGION_ALIGN_SIZE       0x00000002 /* Size Aligned */
-#define IGD_GMM_REGION_ALIGN_CONTEXT    0x00000003
-#ifdef D3D_DPM_ALLOC
-#define IGD_GMM_DOUBLE_MAP              0x00000004 /* mapped to SGX/DPM space */
-#endif
-#define IGD_GMM_REGION_ALIGN_64K        0x00000010
-/*! @} */
-
-/*!
- * @name Region Allocation Types
- * @anchor alloc_region_types
- *
- * @{
- */
-#define IGD_GMM_REGION_TYPE_DMA         0x00000001
-#define IGD_GMM_REGION_TYPE_RING        0x00000002
-#define IGD_GMM_REGION_TYPE_OVLREG      0x00000003
-#define IGD_GMM_REGION_TYPE_CONTEXT     0x00000004
-#define IGD_GMM_REGION_TYPE_HWSTATUS    0x00000005
-#define IGD_GMM_REGION_TYPE_BPL			0x00000006
-#define IGD_GMM_REGION_TYPE_PERSISTENT	0x00000007
-#define IGD_GMM_REGION_TYPE_OVLREG64	0x00000008
-#define IGD_GMM_REGION_TYPE_RANDEC0		0x00000009
-#define IGD_GMM_REGION_TYPE_RANDEC1		0x0000000A
-/*! @} */
-
-/*!
- * @name Reservation Flags
- * @anchor alloc_reservation_flags
- *
- * @{
- */
-#define IGD_GMM_RESERVATION_FENCED       0x00000001
-/*! @} */
-
-
-/*!
- * @brief Memory stats returned from _igd_dispatch::gmm_memstat()
- *
- *  This data structure is used to retrieve the memory usage statistics
- *  from the HAL with a dispatch->gmm_memstat() function call.
- */
-typedef struct _igd_memstat {
-	/*! @brief The total memory space available (Bytes) */
-	unsigned long total_avail;
-	/*! @brief Total memory used (Bytes) */
-	unsigned long total_used;
-	/*! @brief Maximum offscreen memory allowed (Bytes) */
-	unsigned long offscreen_max;
-	/*! @brief The amount of offscreen memory currently used (Bytes) */
-	unsigned long offscreen_used;
-	unsigned long offscreen_static_used;
-} igd_memstat_t;
-
-
-
-/*!
- * @name GMM Alloc Cached Flags
- * @anchor gmm_alloc_cached_flags
- *
- * These flags are used with the _igd_dispatch::gmm_alloc_cached() dispatch
- * function.
- *
- * - IGD_GMM_FLUSH_ALL: Flush out all cached surfaces if needed.
- * - 0: Flush out no surfaces.
- *
- * @{
- */
-#define IGD_GMM_FLUSH_ALL    0x1
-/*! @} */
-
-typedef unsigned long (*_gmm_get_pvtheap_size)(void);
-typedef unsigned long (*_gmm_gmm_get_cache_mem)(void);
-
-typedef int (*_gmm_alloc_surface_fn_t)(
-	unsigned long *offset,
-	unsigned long pixel_format,
-	unsigned int *width,
-	unsigned int *height,
-	unsigned int *pitch,
-	unsigned long *size,
-	unsigned int type,
-	unsigned long *flags);
-
-typedef int (*_gmm_get_num_surface_fn_t)(
-	unsigned long *count);
-
-typedef int (*_gmm_get_surface_list_fn_t)(
-	unsigned long allocated_size,
-	unsigned long *list_size,
-	igd_surface_list_t **surface_list);
-
-typedef int (*_gmm_alloc_region_fn_t)(
-	unsigned long *offset,
-	unsigned long *size,
-	unsigned int type,
-	unsigned long flags);
-
-typedef int (*_gmm_virt_to_phys_fn_t)(
-	unsigned long offset,
-	unsigned long *physical);
-
-typedef void (*_gmm_free_fn_t)(unsigned long offset);
-
-typedef int (*_gmm_memstat_fn_t)(igd_memstat_t *memstat);
-
-typedef int (*_gmm_alloc_cached_fn_t)(igd_display_h display_handle,
-	igd_surface_t *surface, unsigned int flags);
-
-typedef void (*_gmm_free_cached_fn_t)(igd_display_h display_handle,
-	igd_surface_t *surface,
-	unsigned long sync_id);
-
-typedef int (*_gmm_alloc_cached_region_fn_t)(igd_display_h display_handle,
-	unsigned long *offset, 
-	unsigned long *size,
-	unsigned int type,
-	unsigned int region_flags,
-	unsigned int flags);
-
-typedef void (*_gmm_free_cached_region_fn_t)(igd_display_h display_handle,
-	unsigned long offset, 
-	unsigned long size,
-	unsigned int type,
-	unsigned int region_flags,
-	unsigned long sync_id_write,
-	unsigned long sync_id_read);
-
-typedef int (*_gmm_flush_cache_fn_t)(void);
-
-
-/*
- * This interface is used in debug driver only. An IAL or HAL component
- * may point this at a string (char[80]) prior to a surface/region
- * allocation. A copy of this string will be stored with the allocation
- * information and will be seen in a GMM dump.
- */
-#define GMM_DEBUG_DESC_SIZE 80
-extern char gmm_debug_desc[];
-
-#if defined(DEBUG_BUILD_TYPE) && defined(CONFIG_GMM)
-
-/*
- * This function is only used to copy the debug description name into
- * the debug string. This way we don't have to worry about a strcpy
- * being available.
- * Note: This function is not a real strcpy. It is hardcoded for the
- * needs of the gmm debug string copy.
- */
-static __inline void _gmm_strcpy(const char *src)
-{
-	int i;
-
-	for(i=0; i<GMM_DEBUG_DESC_SIZE; i++) {
-		gmm_debug_desc[i] = src[i];
-		if(!gmm_debug_desc[i]) {
-			return;
-		}
-	}
-	gmm_debug_desc[GMM_DEBUG_DESC_SIZE-1] = '\0';
-	return;
-}
-
-static __inline void _gmm_strcpy2(char *dest, const char *src)
-{
-	int i;
-
-	for(i=0; i<GMM_DEBUG_DESC_SIZE; i++) {
-		dest[i] = src[i];
-		if(!dest[i]) {
-			return;
-		}
-	}
-	dest[GMM_DEBUG_DESC_SIZE-1] = '\0';
-	return;
-}
-
-#define GMM_SET_DEBUG_NAME(src) _gmm_strcpy(src)
-#define GMM_SET_DEBUG_NAME2(dest, src) _gmm_strcpy2(dest, src)
-#else
-#define GMM_SET_DEBUG_NAME(src)
-#define GMM_SET_DEBUG_NAME2(dest, src)
-#endif
-
-/*! @} */
-
-#endif
+/*
+ *-----------------------------------------------------------------------------
+ * Filename: igd_gmm.h
+ * $Revision: 1.13 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2010, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ * Description:
+ *  This is the public header file for gmm. It should be included by any
+ *  client driver or igd module that requires gmm interaction.
+ *-----------------------------------------------------------------------------
+ */
+
+#ifndef _IGD_MM_H
+#define _IGD_MM_H
+
+#include <igd_mode.h>
+#include <igd_render.h>
+
+/*!
+ * @addtogroup gmm_group
+ *
+ * <B>Relavent Dispatch Functions</B>
+ *  - _igd_dispatch::gmm_alloc_surface()
+ *  - _igd_dispatch::gmm_alloc_region()
+ *  - _igd_dispatch::gmm_free()
+ *  - _igd_dispatch::gmm_memstat()
+ *  - _igd_dispatch::gmm_alloc_cached()
+ *  - _igd_dispatch::gmm_free_cached()
+ *  - _igd_dispatch::gmm_flush_cache()
+ *
+ * @{
+ */
+
+/*!
+ * @name Surface Alignment Flags
+ * @anchor surface_info_flags
+ *
+ * Surface Alignment Flags are passed to the _igd_dispatch::gmm_alloc_surface()
+ * function as an indicator for how the surface will be used.
+ *
+ * - IGD_SURFACE_RENDER The surface may be used as a rendering target,
+ *     this must be set for all color buffers.
+ * - IGD_SURFACE_TEXTURE The surface may be used as a texture input.
+ * - IGD_SURFACE_CURSOR Surface may be used as a cursor
+ * - IGD_SURFACE_OVERLAY Surface may be used with the overlay
+ * - IGD_SURFACE_DISPLAY This surface is suitable for use with the display
+ *   engine. This flag must be set for any render target that may later
+ *   be flipped to the front buffer.
+ * - IGD_SURFACE_DEPTH The surface may be used as a depth (Z) buffer.
+ * - IGD_SURFACE_DRI2 The surface is a DRI2 allocation (back buffer,
+ *   fake front buffer, etc.).  It should be allocated on the general
+ *   heap rather than the default '2D' heap.
+ *
+ * - IGD_SURFACE_YMAJOR If the surface is tiled, it is tiled with the
+ *     walk in the YMajor direction. This flag is output only unless the
+ *     allocation type is Fixed TF.
+ * - IGD_SURFACE_XMAJOR If the surface is tiled, it is tiled with the
+ *     walk in the YMajor direction. This flag is output only unless the
+ *     allocation type is Fixed TF.
+ * - IGD_SURFACE_TILED Surface is tiled. This flag is output only unless
+ *     the allocation type is Fixed TF.
+ * - IGD_SURFACE_FENCED Surface is fenced. This flaf is output only unless
+ *     the allocation type is Fixed TF.
+ *
+ * Additionally all FB flags can be populated
+ * See: @ref fb_info_flags
+ *
+ * @{
+ */
+#define IGD_SURFACE_RENDER    0x00000001
+#define IGD_SURFACE_TEXTURE   0x00000002
+#define IGD_SURFACE_CURSOR    0x00000004
+#define IGD_SURFACE_OVERLAY   0x00000008
+#define IGD_SURFACE_DISPLAY   0x00000010
+#define IGD_SURFACE_DEPTH     0x00000020
+#define IGD_SURFACE_VIDEO     0x00000040
+#define IGD_SURFACE_VIDEO_ENCODE     0x00000080
+#define IGD_SURFACE_DRI2      0x00000100
+
+#define IGD_SURFACE_WALK_MASK 0x00001000
+#define IGD_SURFACE_YMAJOR    0x00001000
+#define IGD_SURFACE_XMAJOR    0x00000000
+#define IGD_SURFACE_TILED     0x00002000
+#define IGD_SURFACE_FENCED    0x00004000
+#define IGD_SURFACE_SYS_MEM   0x00008000
+#define IGD_SURFACE_PHYS_PTR  0x00010000
+#define IGD_SURFACE_CI		0x00020000
+#define IGD_SURFACE_CI_V4L2_MAP	0x00040000		/*will be set when map_method=0 without WA*/
+/*
+ * Mipmap flags are only valid on mipmap surfaces.
+ * Planes flags are only valid on volume surfaces.
+ */
+#define IGD_MIPLEVEL_SHIFT    16
+#define IGD_MIPLEVEL_MASK     (0xf<<IGD_MIPLEVEL_SHIFT)
+#define IGD_NUMPLANES_SHIFT   20
+#define IGD_NUMPLANES_MASK    (0x0ff00000UL)
+
+/*
+ * These flags exist in the Framebuffer info data structure also.
+ * They are here to insure that no overlap of flags happens.
+ */
+#define IGD_SURFACE_RESERVED_FLAGS 0xf0000000
+
+/*! @} */
+
+/*!
+ * @name Surface Allocation Types
+ * @anchor alloc_surface_types
+ *
+ * These types are used with the _igd_dispatch::alloc_surface() call to
+ * control the allocation behavior.
+ *
+ *  - IGD_GMM_ALLOC_TYPE_NORMAL Normal surface allocation. GMM will
+ *      determine the best tiling and fencing options and return that
+ *      information in the surface flags.
+ *  - IGD_GMM_ALLOC_TYPE_FIXED_TF Surface allocation will be done using
+ *      the tiled and fenced options from the surface flags. GMM will
+ *      not override these flags but will fail an allocation if the
+ *      tiling options would result in an unusable surface.
+ *  - IGD_GMM_ALLOC_TYPE_RESERVATION The offset provided in the call
+ *      was reserved earlier. The provided offset must be used. This
+ *      may be used with the Fixed bit enabled.
+ * @{
+ */
+#define IGD_GMM_ALLOC_TYPE_NORMAL       0x0000
+#define IGD_GMM_ALLOC_TYPE_FIXED_TF     0x0001
+#define IGD_GMM_ALLOC_TYPE_RESERVATION  0x0002
+
+/*! @} */
+
+/*!
+ * @name Mipmap layout type
+ * @anchor alloc_mipmap
+ *
+ * These constants are used when allocating surfaces to know how many
+ * offsets to expect GMM to return.
+ *
+ * - IGD_GMM_SURFACE_LAYOUT_RIGHT LOD1 be on the right of LOD0
+ * - IGD_GMM_SURFACE_LAYOUT_BELOW LOD1 is below LOD0
+ * - IGD_GMM_SURFACE_LAYOUT_LEGACY Traditional format, used by
+ *   915 and below
+ * @{
+ */
+
+#define IGD_GMM_SURFACE_LAYOUT_RIGHT    0x0001
+#define IGD_GMM_SURFACE_LAYOUT_BELOW    0x0002
+#define IGD_GMM_SURFACE_LAYOUT_LEGACY   0x0003
+/*! @} */
+
+/*!
+ * @name Surface Allocation Constants
+ * @anchor alloc_surface_constants
+ *
+ * These constants are used when allocating surfaces to know how many
+ * offsets to expect GMM to return.
+ *
+ * - IGD_MAX_MIPLEVELS The maximum number of miplevels returned by GMM.
+ * - IGD_MAX_VOLUME_PLANES The maximum number of planes in a volume map.
+ * - IGD_MAX_VOLUME_SLICES The maximum number of slices in a mipped volume map.
+ *    There are 50% fewer planes with each successive mip level.
+ *    The number of slices can be calculated as,
+ *     (planes*2 - 1) - ((planes>>lod) - 1)
+ * @{
+ */
+#define IGD_MAX_MIPLEVELS 12
+#define IGD_MAX_VOLUME_PLANES 256
+#define IGD_MAX_VOLUME_SLICES 511
+/*! @} */
+
+/*!
+ * @name Region Alignment Flags
+ * @anchor alloc_region_flags
+ *
+ * @{
+ */
+#define IGD_GMM_REGION_ALIGN_MMAP       0x00000001
+#define IGD_GMM_REGION_ALIGN_SIZE       0x00000002 /* Size Aligned */
+#define IGD_GMM_REGION_ALIGN_CONTEXT    0x00000003
+#ifdef D3D_DPM_ALLOC
+#define IGD_GMM_DOUBLE_MAP              0x00000004 /* mapped to SGX/DPM space */
+#endif
+#define IGD_GMM_REGION_ALIGN_64K        0x00000010
+/*! @} */
+
+/*!
+ * @name Region Allocation Types
+ * @anchor alloc_region_types
+ *
+ * @{
+ */
+#define IGD_GMM_REGION_TYPE_DMA         0x00000001
+#define IGD_GMM_REGION_TYPE_RING        0x00000002
+#define IGD_GMM_REGION_TYPE_OVLREG      0x00000003
+#define IGD_GMM_REGION_TYPE_CONTEXT     0x00000004
+#define IGD_GMM_REGION_TYPE_HWSTATUS    0x00000005
+#define IGD_GMM_REGION_TYPE_BPL			0x00000006
+#define IGD_GMM_REGION_TYPE_PERSISTENT	0x00000007
+#define IGD_GMM_REGION_TYPE_OVLREG64	0x00000008
+#define IGD_GMM_REGION_TYPE_RANDEC0		0x00000009
+#define IGD_GMM_REGION_TYPE_RANDEC1		0x0000000A
+/*! @} */
+
+/*!
+ * @name Reservation Flags
+ * @anchor alloc_reservation_flags
+ *
+ * @{
+ */
+#define IGD_GMM_RESERVATION_FENCED       0x00000001
+/*! @} */
+
+
+/*!
+ * @brief Memory stats returned from _igd_dispatch::gmm_memstat()
+ *
+ *  This data structure is used to retrieve the memory usage statistics
+ *  from the HAL with a dispatch->gmm_memstat() function call.
+ */
+typedef struct _igd_memstat {
+	/*! @brief The total memory space available (Bytes) */
+	unsigned long total_avail;
+	/*! @brief Total memory used (Bytes) */
+	unsigned long total_used;
+	/*! @brief Maximum offscreen memory allowed (Bytes) */
+	unsigned long offscreen_max;
+	/*! @brief The amount of offscreen memory currently used (Bytes) */
+	unsigned long offscreen_used;
+	unsigned long offscreen_static_used;
+} igd_memstat_t;
+
+
+
+/*!
+ * @name GMM Alloc Cached Flags
+ * @anchor gmm_alloc_cached_flags
+ *
+ * These flags are used with the _igd_dispatch::gmm_alloc_cached() dispatch
+ * function.
+ *
+ * - IGD_GMM_FLUSH_ALL: Flush out all cached surfaces if needed.
+ * - 0: Flush out no surfaces.
+ *
+ * @{
+ */
+#define IGD_GMM_FLUSH_ALL    0x1
+/*! @} */
+
+typedef unsigned long (*_gmm_get_pvtheap_size)(void);
+typedef unsigned long (*_gmm_gmm_get_cache_mem)(void);
+
+typedef int (*_gmm_alloc_surface_fn_t)(
+	unsigned long *offset,
+	unsigned long pixel_format,
+	unsigned int *width,
+	unsigned int *height,
+	unsigned int *pitch,
+	unsigned long *size,
+	unsigned int type,
+	unsigned long *flags);
+
+typedef int (*_gmm_get_num_surface_fn_t)(
+	unsigned long *count);
+
+typedef int (*_gmm_get_surface_list_fn_t)(
+	unsigned long allocated_size,
+	unsigned long *list_size,
+	igd_surface_list_t **surface_list);
+
+typedef int (*_gmm_alloc_region_fn_t)(
+	unsigned long *offset,
+	unsigned long *size,
+	unsigned int type,
+	unsigned long flags);
+
+typedef int (*_gmm_virt_to_phys_fn_t)(
+	unsigned long offset,
+	unsigned long *physical);
+
+typedef void (*_gmm_free_fn_t)(unsigned long offset);
+
+typedef int (*_gmm_memstat_fn_t)(igd_memstat_t *memstat);
+
+typedef int (*_gmm_alloc_cached_fn_t)(igd_display_h display_handle,
+	igd_surface_t *surface, unsigned int flags);
+
+typedef void (*_gmm_free_cached_fn_t)(igd_display_h display_handle,
+	igd_surface_t *surface,
+	unsigned long sync_id);
+
+typedef int (*_gmm_alloc_cached_region_fn_t)(igd_display_h display_handle,
+	unsigned long *offset,
+	unsigned long *size,
+	unsigned int type,
+	unsigned int region_flags,
+	unsigned int flags);
+
+typedef void (*_gmm_free_cached_region_fn_t)(igd_display_h display_handle,
+	unsigned long offset,
+	unsigned long size,
+	unsigned int type,
+	unsigned int region_flags,
+	unsigned long sync_id_write,
+	unsigned long sync_id_read);
+
+typedef int (*_gmm_flush_cache_fn_t)(void);
+
+
+/*
+ * This interface is used in debug driver only. An IAL or HAL component
+ * may point this at a string (char[80]) prior to a surface/region
+ * allocation. A copy of this string will be stored with the allocation
+ * information and will be seen in a GMM dump.
+ */
+#define GMM_DEBUG_DESC_SIZE 80
+extern char gmm_debug_desc[];
+
+#if defined(DEBUG_BUILD_TYPE) && defined(CONFIG_GMM)
+
+/*
+ * This function is only used to copy the debug description name into
+ * the debug string. This way we don't have to worry about a strcpy
+ * being available.
+ * Note: This function is not a real strcpy. It is hardcoded for the
+ * needs of the gmm debug string copy.
+ */
+static __inline void _gmm_strcpy(const char *src)
+{
+	int i;
+
+	for(i=0; i<GMM_DEBUG_DESC_SIZE; i++) {
+		gmm_debug_desc[i] = src[i];
+		if(!gmm_debug_desc[i]) {
+			return;
+		}
+	}
+	gmm_debug_desc[GMM_DEBUG_DESC_SIZE-1] = '\0';
+	return;
+}
+
+static __inline void _gmm_strcpy2(char *dest, const char *src)
+{
+	int i;
+
+	for(i=0; i<GMM_DEBUG_DESC_SIZE; i++) {
+		dest[i] = src[i];
+		if(!dest[i]) {
+			return;
+		}
+	}
+	dest[GMM_DEBUG_DESC_SIZE-1] = '\0';
+	return;
+}
+
+#define GMM_SET_DEBUG_NAME(src) _gmm_strcpy(src)
+#define GMM_SET_DEBUG_NAME2(dest, src) _gmm_strcpy2(dest, src)
+#else
+#define GMM_SET_DEBUG_NAME(src)
+#define GMM_SET_DEBUG_NAME2(dest, src)
+#endif
+
+/*! @} */
+
+#endif
diff --git a/drivers/gpu/drm/emgd/include/igd_init.h b/drivers/gpu/drm/emgd/include/igd_init.h
index 47045b6..c382b0d 100644
--- a/drivers/gpu/drm/emgd/include/igd_init.h
+++ b/drivers/gpu/drm/emgd/include/igd_init.h
@@ -1,895 +1,895 @@
-/*
- *-----------------------------------------------------------------------------
- * Filename: igd_init.h
- * $Revision: 1.15 $
- *-----------------------------------------------------------------------------
- * Copyright (c) 2002-2010, Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- *
- *-----------------------------------------------------------------------------
- * Description:
- *  
- *-----------------------------------------------------------------------------
- */
-
-#ifndef _IGD_INIT_H_
-#define _IGD_INIT_H_
-
-#include <igd.h>
-
-
-/*!
- * @addtogroup init_group
- *
- * The init module contains the entry points and data structures
- * necessary to initialize the graphics driver HAL.
- * The IAL will call several initialization functions to bring the HAL
- * to a usable state, after which, the HAL is accessed through a dispatch
- * table (data structure of function pointers).
- *
- * Typical initialization will follow these steps:
- * - Initialize the HAL by calling igd_driver_init() to
- *   detect supported chipsets without altering the hardware. If a
- *   supported device is found the _igd_init_info data structure will be
- *   populated indicating the chipset name and PCI information for the device.
- *   A driver handle that should be used during the rest of the
- *   initialization process will be returned.
- *
- * - Call igd_driver_config() to prepare the hardware for use. Until this
- *   point there has been no alteration of the hardware. After the
- *   driver has been configured the igd_get_config_info() function can
- *   be used. Only a subset of the _igd_config_info data will be available
- *   at this time as the modular HAL components have not been initialized.
- *
- * - Call igd_module_init() to initialize the modular components of the
- *   driver. This function accepts a set of parameters that can alter
- *   default behavior. A provided dispatch table will be populated with
- *   the entry points used for hardware operations during the life of
- *   the driver. igd_get_config_info() may now be used to return full
- *   configuration details.
- *
- * @{
- */
-
-/*!
- * @brief Data populated by igd_driver_init().
- *
- * The init info is used as input/output to igd_driver_init(). Any non-zero
- * members (with the exception of the name) will be used to limit the search
- * for available devices, if all members are zero the first supported
- * device found on the system will be used. In either case the data returned
- * will reflect the to-be-controlled device found by the HAL.
- *
- * The name is a ASCII string that may be used in human readable output
- * dialogs.
- */
-typedef struct _igd_init_info {
-	/*! @brief PCI Vendor ID */
-	unsigned int vendor_id;
-	/*! @brief PCI Device ID */
-	unsigned int device_id;
-	/*! @brief PCI Bus ID */
-	unsigned int bus;
-	/*! @brief PCI Slot ID */
-	unsigned int slot;
-	/*! @brief PCI Function ID */
-	unsigned int func;
-	/*! @brief ASCII chipset name */
-	char *name;
-	/*! @brief ASCII chipset ID */
-	char *chipset;
-	/*! @brief ASCII default port driver list */
-	char *default_pd_list;
-} igd_init_info_t;
-
-/*!
- * @brief Function to initialize the HAL and detect supported chipset.
- *
- * Initialize the driver and determine if the hardware is supported without
- * altering the hardware state in any way. Init info is populated based on
- * collected data.
- *
- * A driver handle is returned. This handle is an opaque data structure
- * used with future HAL calls. The contents or meaning of the value are
- * not known outside the HAL; however, a NULL value should be considered
- * a failure.
- *
- * @param init_info Device details returned from the init process. This
- *   structure will be populated by the HAL during the call.
- *
- * @return igd_driver_h (Non-NULL) on Success
- * @return NULL on failure
- */
-igd_driver_h igd_driver_init(igd_init_info_t *init_info);
-
-
-/*!
- *  Configure the driver. This sets the driver for future operation, it
- * may alter the hardware state. Must be called after driver init and
- * before ANY other driver commands.
- *
- * @param driver_handle: A driver handle as returned by igd_driver_init()
- *
- * @return <0 on Error
- * @return 0 On Success
- */
-int igd_driver_config(igd_driver_h driver_handle);
-
-
-
-/*!
- * @defgroup init_param Initialization Parameters
- *
- * Initialization parameters are passed to igd_module_init() to control
- * configurable behavior of the HAL. Some parameters are global in that
- * they have an effect on the entire driver. In addition, there are
- * parameters that are specific to a display. These parameters are provided
- * in a list with each list entry representing a defined "port number" as
- * follows shown here:
- *
-<PRE>
-                                        /|-----------|
-                                       / | Fp Info   |
-                                      /  |-----------|
-        |----------|   /|---------|  /
-        | Params   |  / | Display | /    |-----------|
-        |          | /  | Param 1 |/     | DTD Array |
-        |          |/   |---------|\     |-----------|
-        |----------|\               \
-                     \  |---------|  \   |-----------|
-                      \ | Display |   \  | Attribute |
-                       \| Param N |    \ | Array     |
-                        |---------|     \|-----------|
-</PRE>
- *
- * The port numbers are mapped to hardware specific outputs as defined
- * here:
- *
- * 830M and later Port numbers:
- *   - 1 DVO A port
- *   - 2 DVO B port
- *   - 3 DVO C port
- *   - 4 Internal LVDS port
- *   - 5 Analog port
- *
- *   On 835: If RGBA is used (DVO B & C together), then use DVO B number
- *   to specify any parameter for it.
- *
- * 810/815 Port numbers:
- *   - 3 DVO port
- *   - 5 Analog port
- *
- * NOTE: The permanence of the Params data structure that is passed from
- * the IAL to the HAL in igd_module_init API is not guaranteed by the IAL
- * Therefore, the different HAL modules should use the data out of this
- * data structure only until igd_module_init and not after that.
- * @{
- */
-
-/*!
- * This parameter, when set, will cause the driver to save the current
- * register state of the device prior to altering it in any way. This
- * will allow the state of the device to be reapplied at exit time.
- */
-#define IGD_DRIVER_SAVE_RESTORE   0x01
-
-/*!
- * @name Per-Display Present Params Flags
- * @anchor present_params_flags
- *
- * These flags are used to identify which parameters are being provided to
- * the HAL. If a bit is not set in the _igd_display_params::present_params
- * variable the parameters will not be read by the HAL and the default
- * behavior will be used instead.
- *
- * - IGD_PARAM_DDC_GPIO Parameter to select non-standard GPIO pair for DDC.
- * - IGD_PARAM_DDC_SPEED Parameter to select non-standard DDC speed.
- * - IGD_PARAM_DDC_DAB Parameter to select the Device Address Byte to use for
- *     DDC communication
- * - IGD_PARAM_I2C_GPIO Parameter to select non-standard GPIO pair for i2c.
- * - IGD_PARAM_I2C_SPEED Parameter to select non-standard I2C speed.
- * - IGD_PARAM_DAB Parameter to select the Device Address Byte to use for I2C
- *     communication.
- * - IGD_PARAM_FP_INFO Parameter to provide non-detectable Flat Panel
- *     configuration data.
- * - IGD_PARAM_DTD_LIST Parameter to provide a Detailed Timing List for a
- *     display.
- * - IGD_PARAM_ATTR_LIST Parameter to provide a set of Port Driver Attributes
- *     to use during init.
- *
- * @{
- */
-#define IGD_PARAM_DDC_GPIO        0x00000001
-#define IGD_PARAM_DDC_SPEED       0x00000002
-#define IGD_PARAM_DDC_DAB         0x00000004
-#define IGD_PARAM_I2C_GPIO        0x00000008
-#define IGD_PARAM_I2C_SPEED       0x00000010
-#define IGD_PARAM_DAB             0x00000020
-#define IGD_PARAM_FP_INFO         0x00000040
-#define IGD_PARAM_DTD_LIST        0x00000080
-#define IGD_PARAM_ATTR_LIST       0x00000100
-/*! @} */
-
-
-/*!
- *
- *
- *
- * @note Any changes to the above number assignment will break the driver.
- *       If change is required, make sure to change the port numbers in
- *       port tables.
- *
- */
-
-/* The method for controlling the flat panel power. The options include:
- * no support or the Port Driver handles flat panel power. */
-#define IGD_PARAM_FP_PWR_METHOD_NONE 0
-#define IGD_PARAM_FP_PWR_METHOD_PD   1
-
-/*!
- * @brief Port-specific color correction information
- *
- * Initialization parameter passed as part of igd_module_init() to provide
- * information about an attached display device. One color_correct_info
- * is provided for each display port.
- *
- */
-typedef struct _igd_param_color_correct_info {
-	/*! @brief RED value for GAMMA */
-	unsigned short gamma_r;
-	/*! @brief GREEN value for GAMMA */
-	unsigned short gamma_g;
-	/*! @brief BLUE value for GAMMA */
-	unsigned short gamma_b;
-	/*! @brief RED value for BRIGHTNESS */
-	unsigned short brightness_r;
-	/*! @brief GREEN value for BRIGHTNESS */
-	unsigned short brightness_g;
-	/*! @brief BLUE value for BRIGHTNESS */
-	unsigned short brightness_b;
-	/*! @brief RED value for CONTRAST */
-	unsigned short constrast_r;
-	/*! @brief GREEN value for CONTRAST */
-	unsigned short constrast_g;
-	/*! @brief BLUE value for CONTRAST */
-	unsigned short constrast_b;
-} igd_param_color_correct_info_t;
-
-
-
-/*!
- * @brief Flat Panel Information
- *
- * Initialization parameter passed as part of igd_module_init() to provide
- * information about an attached Flat Panel (typically LVDS). One fp_info
- * is provided for each display port, and is only used when the
- * IGD_PARAM_FP_INFO flag is set in the _igd_display_params::present_params
- *
- */
-typedef struct _igd_param_fp_info {
-	/*! @brief Flat panel width */
-	unsigned long fp_width;
-	/*! @brief Flat panel height */
-	unsigned long fp_height;
-	/*! @brief Flat Panel Power Method */
-	unsigned long fp_pwr_method;
-	/*!
-	 * @brief Min time delay in miliseconds between VDD active and clock/data
-	 * active.
-	 */
-	unsigned long fp_pwr_t1;
-	/*!
-	 * @brief Min time delay in miliseconds between clock/data active and
-	 * backlight enable.
-	 */
-	unsigned long fp_pwr_t2;
-	/*!
-	 * @brief Min time delay in miliseconds between Backlight disable and
-	 * clock/data inactive
-	 */
-	unsigned long  fp_pwr_t3;
-	/*!
-	 * @brief Min time delay in miliseconds between clock/data inactive and
-	 * VDD inactive.
-	 */
-	unsigned long  fp_pwr_t4;
-	/*!
-	 * @brief Min time delay in miliseconds between VDD inactive and
-	 * VDD active.
-	 */
-	unsigned long  fp_pwr_t5;
-} igd_param_fp_info_t;
-
-/*!
- * @brief Per-display init-time list of DTDs.
- *
- * In the case of EDID-less display device, this parameter provides
- * the DTD (Detailed Timing Descriptor) list to the HAL during initialization.
- */
-typedef struct _igd_param_dtd_list {
-	/*! @brief number of DTDs */
-	unsigned long  num_dtds;
-	/*! @brief DTD list */
-	igd_display_info_t  *dtd;
-} igd_param_dtd_list_t;
-
-/*!
- * @brief Port driver attribute
- */
-typedef struct _igd_param_attr {
-	/*! @brief See @ref attr_id_defs for predefined IDs */
-	unsigned long  id;
-	/*! @brief value or index(incase of list type attr) */
-	unsigned long  value;
-} igd_param_attr_t;
-
-/*!
- * @brief Port driver init-time attribute list
- *
- * This data structure is used during HAL initialization. It should be
- * populated with any port driver attributes that were modified and saved
- * in a prior use of the HAL.
- */
-typedef struct _igd_param_attr_list {
-	/*! @brief  number of attributes in the list */
-	unsigned long  num_attrs;
-	/*! @brief IAL allocated attribute list */
-	igd_param_attr_t *attr;
-} igd_param_attr_list_t;
-
-
-
-/*!
- * @brief Per-Display Init-time configuration parameters.
- *
- * These parameters are provided as an array during igd_module_init().
- * They allow the default behavior of the driver to be altered on a
- * per-display basis. They are input-only to provide data
- * about non-standard hardware configurations and persistant driver state.
- */
-typedef struct _igd_display_params {
-	/*! @brief Port to which these parameters apply. See @ref init_param */
-	unsigned long port_number;
-	/*! @brief parameters present bitfield: See @ref present_params_flags */
-	unsigned long present_params;
-	unsigned long flags;
-	/*!
-	 * @brief Timing sources to use with Edid displays.
-	 * See @ref advanced_edid
-	 */
-	unsigned short edid_avail;
-	/*!
-	 * @brief Timings sources to use with Edid-less displays.
-	 * See @ref advanced_edid
-	 */
-	unsigned short edid_not_avail;
-	unsigned long ddc_gpio;       /* DDC GPIO pin pair number 0..6 */
-	unsigned long ddc_speed;      /* DDC speed in KHz to read EDID */
-	unsigned long ddc_dab;        /* DDC DAB to read EDID from display device */
-	unsigned long i2c_gpio;       /* I2C GPIO pin pair number 0..6 */
-	unsigned long i2c_speed;      /* I2C speed in KHz to read EDID */
-	unsigned long i2c_dab;        /* I2C DAB to communicate with DVO device */
-	igd_param_fp_info_t fp_info;  /* Connected FP Info */
-	/*!
-	 * DTD parameter: Incase of EDID-less display device, this parameter
-	 * provides the DTD (Detailed Timing Descriptor) list
-	 */
-	igd_param_dtd_list_t dtd_list;
-
-	igd_param_attr_list_t attr_list;
-} igd_display_params_t;
-
-/*!
- * @name Advanced Edid Flags
- * @anchor advanced_edid
- *
- * Flags to use with edid_avail and edid_not_avail:
- * perport edid_avail/edid_not_avail
- *
- * IGD_DISPLAY_USE_STD_TIMINGS:
- *   If not set: Do not use driver built-in standard timings
- *   If set:     Use driver built-in standard timings
- *
- * IGD_DISPLAY_USE_EDID:  not applicable to edid_not_avail
- *   If not set: Do not use EDID block
- *   If set:     Use EDID block and filter modes
- *
- * IGD_DISPLAY_USE_USERDTDS:
- *   If not set: Do not use user-DTDs
- *   If set:     Use user-DTDs.
- *
- * @{
- */
-#define IGD_DISPLAY_USE_STD_TIMINGS    0x1
-#define IGD_DISPLAY_USE_EDID           0x2
-#define IGD_DISPLAY_USE_USERDTDS       0x4
-/*! @} */
-
-
-/* Flags for igd_display_params_t->flags*/
-#define IGD_DISPLAY_READ_EDID     0x00000001  /* igd_display_params_t.flags */
-
-/*!
- * @anchor display_flags_def
- *
- * These flags may be used in the display_flags member of the
- * igd_params_t data structure.
- *
- */
-#define IGD_DISPLAY_MULTI_DVO     0x00000002  /* igd_param_t.display_flags  */
-#define IGD_DISPLAY_DETECT        0x00000004  /* igd_param_t.display_flags  */
-#define IGD_DISPLAY_FB_BLEND_OVL  0x00000008  /* igd_param_t.display_flags  */
-#define IGD_DISPLAY_BATCH_BLITS   0x00000010
-	/*! @brief enable dynamic blending of display frame buffer with overlay */
-
-
-
-/*!
- * @brief Init-Time Driver Parameters
- *
- * The igd_param_t data structure contains  global init-time static parameters
- * to impact the behavior of the whole driver. They are provided to the driver
- * during module initialization to control overall driver behavior.
- *
- *
- *           VERY IMPORTANT!!! CHANGES TO DEFINITION OF THIS STRUCTURE AND
- *           ITS MEMBER STRUCTURES MUST BE FOLLOWED BY UPDATES TO THE
- *           FOLLOWING COMPONENTS / FILES:
- *                       1. ssigd/ial/vbios/usrbld/igd_uinit.h
- *                       2. ssigd/ial/vbios/src/core/user_config.c
- *                       3. pcf2iegd tool (gens user_config.c/h for usr-bld)
- *                       4. CED tool (generates user_config.c/h for usr-bld)
- *
- *
- *
- * See igd_module_init()
- */
-typedef struct _igd_param {
-	/*! @brief Maximum pages taken by the driver for offscreen memory */
-	unsigned long        page_request;
-	/*! @brief Maximum pages reserved for the framebuffer. */
-	unsigned long        max_fb_size;
-	/*! @brief Boolean option to preserve initial hardware state */
-	unsigned char        preserve_regs;
-	/*! @ref display_flags_def "Display Flags" */
-	unsigned long        display_flags;
-	/*!
-	 * @brief Port detection order.
-	 *
-	 * HAL will detect the displays in the  order mentioned and also allocate
-	 * in the same order if found.
-	 *
-	 * Example: To detect/allocate in the order on 855:
-	 * -# DVOB PORT
-	 * -# ANALOG PORT
-	 * -# LVDS PORT
-	 * then specify port_number[] = {2, 5, 4, 0};
-	 *
-	 * @note Set port_number[] = {0, 0, 0, 0}; to work in the default order.
-	 *
-	 * @note If a invalid number is specified then it will be skipped.
-	 */
-	unsigned long port_order[IGD_MAX_PORTS];
-
-	/*! Contains the Per-Display init-time parameters. */
-	igd_display_params_t display_params[IGD_MAX_PORTS];
-
-	/*! @brief RGB color that will be used while clearing the framebuffer */
-	unsigned long        display_color;
-
-    unsigned long       quickboot;
-    int                 qb_seamless;
-    unsigned long       qb_video_input;
-    int                 qb_splash;
-
-	/*! Override interrupt support and revert to polling */
-	int                 polling;
-	unsigned long 		ref_freq;
-	int 				tuning_wa;
-	unsigned long 		clip_hw_fix;
-
-	
-	/* Async flip flickering workaround enable */
-	unsigned long		async_flip_wa;
-	
-	/*
-	 * Enable override of following registers when en_reg_override=1.
-	 * Display Arbitration, FIFO Watermark Control, GVD HP_CONTROL,
-	 * Bunit Chickenbits, Bunit Write Flush, Display Chickenbits
-	 */
-	unsigned long		en_reg_override;
-	unsigned long		disp_arb;
-	unsigned long		fifo_watermark1;
-	unsigned long		fifo_watermark2;
-	unsigned long		fifo_watermark3;
-	unsigned long		fifo_watermark4;
-	unsigned long		fifo_watermark5;
-	unsigned long		fifo_watermark6;
-	unsigned long		gvd_hp_control;
-	unsigned long		bunit_chicken_bits;
-	unsigned long		bunit_write_flush;
-	unsigned long		disp_chicken_bits;
-	int					punt_to_3dblit;
-
-} igd_param_t;
-
-typedef struct {
-	unsigned debug : 1;
-	unsigned ddk_version : 16;
-	unsigned emgd_version : 15;
-} igd_build_config_t;
-
-/*! @} */
-
-/*!
- *
- *  Initializes individual modules to a runable state. Init time parameters
- * may be provided to alter the default behavior of the driver.
- * See @ref init_param
- *
- * The dispatch table for all graphics operations is returned. The dispatch
- * table may return NULL pointers for unsupported functions due to
- * optional modules. This dispatch table is used to access HAL functionality
- * throughout the life of the driver.
- * See @ref _igd_dispatch
- *
- * @param driver_handle as returned from igd_driver_init().
- * @param dsp dispatch table to be populated during the call.
- * @param params Input parameters to alter default behavior.
- *   See @ref init_param
- *
- * @return 0 Success
- * @return <0 on Error
- */
-int igd_module_init(igd_driver_h driver_handle,
-	igd_dispatch_t **dsp,
-	igd_param_t *params);
-
-
-
-/*!
- * @name Framebuffer Capabilities
- * @anchor fb_caps
- *
- * FB caps are an indication of large feature sets that will or will not
- * be available based on FB pixel format. This allows an IAL to intelligently
- * configure itself to the appropriate setup before setting a display
- * mode.
- * FB caps are returned from a call to igd_get_config_info().
- *
- * - IGD_CAP_BASIC_2D This capability bit indicates that the device is capable
- *    of performing basic 2d acceleration.
- * - IGD_CAP_FULL_2D This capability bit indicates that the device is capable
- *    of performing full 2d acceleration.
- * - IGD_CAP_BLEND This capability bit indicates that the device is capable of
- *    performing the blend() function to the framebuffer.
- *
- * @{
- */
-#define IGD_CAP_BASIC_2D  0x01
-#define IGD_CAP_FULL_2D  (0x02 | IGD_CAP_BASIC_2D)
-#define IGD_CAP_BLEND     0x04
-/*! @} */
-
-
-/*!
- * @brief Device Capabilities based on FB mode
- *
- * This structure reports the Framebuffer capabilities on a pixel format
- * basis. An IAL should check these capabilities before using acceleration
- * features. This structure is returned as part of the _igd_config_info
- * information from the igd_get_config_info() call.
- *
- * @see pixel_formats
- */
-typedef struct _igd_fb_caps {
-	/*! @brief The framebuffer pixel format that these caps reference */
-	unsigned long pixel_format;
-	/*! @brief The capability bits as defined by @ref fb_caps */
-	unsigned long caps;
-} igd_fb_caps_t;
-
-/*!
- * @brief Static HAL configuration data
- *
- * Config info contains the static configuration information for the device
- * that is found during the call to igd_driver_config(). It is obtained
- * with a call to igd_get_config_info() which may be done before or after
- * module configuration with limited success.
- */
-typedef struct _igd_config_info {
-	/*! @brief The Base MMIO physical (Bus) address. */
-	unsigned long mmio_base_phys;
-	/*! @brief The Base MMIO virtual address. */
-	unsigned char *mmio_base_virt;
-	/*! @brief The Base Video Memory physical (Bus) address. */
-	unsigned long gtt_memory_base_phys;
-	/*! @brief The Base Video Memory virtual address. */
-	unsigned char *gtt_memory_base_virt;
-	/*! @brief The Video Memory Size. */
-	unsigned long gtt_memory_size;
-	/*! @brief The number of display planes supported by the device. */
-	unsigned long num_dsp_planes;
-	/*! @brief The number of display pipes supported by the device. */
-	unsigned long num_dsp_pipes;
-	/*! @brief The number of currently active display ports. */
-	unsigned long num_act_dsp_ports;
-	/*! @brief Caps, terminated with PF = 0 */
-	igd_fb_caps_t *fb_caps;
-	/*! @brief The device revision id. */
-	unsigned long revision_id;
-	/*! @brief HW status page offset (priviledged use only) */
-	unsigned long hw_status_offset;
-	/*! @brief The base of stolen memory */
-	unsigned long stolen_memory_base_virt;
-	/* pixel format that matches the bpp that was passed in */
-	unsigned long pixel_format;
-	/* port-specific rotation read from DisplayID */
-	igd_DID_rotation_info_t displayid_rotation[IGD_MAX_PORTS];
-} igd_config_info_t;
-
-
-/*!
- * @brief Static GTT configuration data
- *
- * This holds the configuration of the GTT and the information
- * required to handle video memory allocation/free.
- *
- * FIXME: There is a lot of duplication with information stored
- * else were (like igd_config_info_t) that needs to be cleaned up.
- */
-typedef struct _igd_gtt_info_t {
-	unsigned long gatt_start;
-	unsigned long gatt_pages;
-	unsigned long gtt_start;
-	unsigned long gtt_pages;
-	unsigned long gtt_phys_start;
-	unsigned long stolen_mem_base;
-	unsigned long stolen_mem_size;
-	unsigned long stolen_pages;
-	unsigned long pge_ctl;
-	unsigned short gmch_ctl;
-	unsigned long *gtt_mmap;
-	void *vram_virt;
-	unsigned long initialzied;
-	void *scratch_page;
-} igd_gtt_info_t;
-
-
-
-/*!
- * The igd_get_config_info() function call can be used to get static
- * configuration information details that the IAL may need. This
- * function may be called prior to igd_module_init() with limited
- * success; however, it is recommeneded that it be called after the
- * modular HAL components have been initialized.
- *
- * In addition to static configuration there may be dynamic configuration
- * details that can be queried at any time after igd_driver_config().
- * These are defined with unique identifiers and are queried one at a
- * time with igd_get_param().
- *
- *  @param driver_handle as retuned from igd_driver_init()
- *  @param config_info Populated with hardware information during the call..
- *
- *  @return 0 Success
- *  @return -IGD_INVAL Error
- */
-int igd_get_config_info(igd_driver_h driver_handle,
-	igd_config_info_t *config_info);
-
-
-
-/*!
- * @defgroup runtime_param Runtime Parameter Control
- *
- * HAL parameters may be queried and set at runtime using the
- * _igd_dispatch::get_param() and _igd_dispatch::set_param() dispatch functions
- * (when called after initialization) or the
- * igd_get_param() and igd_set_param() functions when called during
- * initialization.
- * Some implemtations may not support all parameters so IAL's must handle
- * errors. Additionally, some parameters are hardware specific and of no use to
- * general purpose IALs. These should only be used by IALs with extensive
- * hardware knowledge (OpenGL, D3D, etc)
- *
- * @{
- */
-
-/*!
- * @name Runtime Parameter Defines
- *
- * - IGD_PARAM_PANEL_ID Primary Panel ID
- *    This is a unique Flat Panel Identifier that is obtained from firmware.
- *    The IAL may use this information to send in Detailed Timing Descriptors
- *    to igd_module_init(). This facilitates the use of multiple local Flat
- *    panel configurations without EDID. When available this parameter may
- *    be queried prior to igd_module_init().
- * - IGD_PARAM_MEM_RESERVATION Bios memory reservation.
- *    This is the amount (in bytes?) of memory that the bios has already
- *    installed in the Gart prior to driver load. It is used when a
- *    non-standard bios or firmware has pre-allocated an undetectable amount
- *    of video memory for splash screen use. When available this parameter can
- *    be queried prior to igd_module_init().
- * - IGD_PARAM_DEBUG_MASK Debug Printing Mask.
- *    This parameter is read/write and may be altered at any time after
- *    igd_driver_init(). It is a bitfield to control different printing
- *    groups for debug builds.
- * - IGD_PARAM_PORT_LIST A bitfield used by the vBIOS to override the
- *    display detect capabilities in the driver.
- * - IGD_PARAM_HW_CONFIG Hardware configuration Bitfield
- *    contains one of these dependeing on platform:
- *    IGD_ALM_HW_CONFIG_BIN or IGD_NAP_HW_CONFIG_BIN both of which indicate
- *    the presence and availability of the hardware binner. This value should
- *    be queried and set (removing the bit) by an IAL claiming use of the
- *    binner.
- * - IGD_PARAM_INTR_STATUS Unknown FIXME document this
- *
- * @{
- */
-#define IGD_PARAM_PANEL_ID        0x01
-#define IGD_PARAM_MEM_RESERVATION 0x02
-#define IGD_PARAM_DEBUG_MASK 0x03
-#define IGD_PARAM_PORT_LIST  0x04
-#define IGD_PARAM_GFX_FREQ  0x05
-#define IGD_PARAM_SET_LVDS  0x06
-#define IGD_PARAM_HW_CONFIG 0x1000
-#define  IGD_ALM_HW_CONFIG_BIN 0x1
-#define  IGD_NAP_HW_CONFIG_BIN 0x1
-#define IGD_PARAM_INTR_STATUS 0x1001
-
-/*! @} */
-
-/*!
- * Gets the value of a runtime driver parameter. These parameters are
- * each defined with a unique ID and may be altered at runtime.
- *
- * Note: There is a wrapper for this function in the dispatch table that
- * takes a display instead of a driver handle. This version is for use
- * when displays are not yet available.
- *
- * @bug Runtime parameter documentation needs updates
- *
- * @return 0 Success
- * @return -IGD_INVAL Error
- */
-int igd_get_param(igd_driver_h driver_handle,
-	unsigned long id,
-	unsigned long *value);
-
-/*!
- * Sets the value of a runtime driver parameter. These parameters are
- * each defined with a unique ID and may be altered at runtime.
- *
- * Note: There is a wrapper for this function in the dispatch table that
- * takes a display instead of a driver handle. This version is for use
- * when displays are not yet available.
- *
- * @return 0 Success
- * @return  -IGD_INVAL Error
- */
-int igd_set_param(igd_driver_h driver_handle,
-	unsigned long id,
-	unsigned long value);
-
-/*! @} Runtime Param Group */
-/*! @} Init Group */
-
-
-/*!
- * @ingroup cleanup
- * @brief Shuts down the HAL
- *
- * This function shuts down the HAL and frees and remaining resources.
- * It should be called at driver exit to leave the hardware in a safe
- * configuration.
- *
- * @param driver_handle The driver handle returned from igd_driver_init().
- *
- * @return void
- */
-void igd_driver_shutdown(igd_driver_h driver_handle);
-
-/*!
- * @ingroup cleanup
- * @brief Shuts down the HAL
- *
- * This function shuts down the HAL and frees and remaining resources.
- * It should be called at driver exit to leave the hardware in a safe
- * configuration.
- *
- * @param driver_handle The driver handle returned from igd_driver_init().
- *
- * @return void
- */
-void igd_driver_shutdown_hal(igd_driver_h driver_handle);
-
-
-/*!
- * @ingroup cleanup
- * @brief Query 2D capability of the hardware.
- *
- * This function query the hardware whether given capabilities value 
- * (caps_val) is supported by hardware.
- *
- * @param driver_handle The driver handle returned from igd_driver_init().
- *
- * @return void
- */
-void igd_query_2d_caps_hwhint(igd_driver_h driver_handle, 
-			unsigned long caps_val,
-			unsigned long *status);
-
-
-
-/* 2D capabilities to query */
-#define IGD_2D_CAPS_BLT                 0
-  	 
-/* Output of 2D capabilities to query */
-#define IGD_2D_HW_DISABLE                       0
-#define IGD_2D_HW_ENABLE                        1
-#define IGD_2D_CAPS_UNKNOWN                     2
-  	 
-
-
-/*!
- * @addtogroup power_group
- * @{
- */
-
-/*!
- * @name Driver Save Flags
- * @anchor driver_save_flags
- *
- * Flags for use with dispatch->driver_save()
- * @{
- */
-#define IGD_REG_SAVE_VGA       0x00001
-#define IGD_REG_SAVE_DAC       0x00002
-#define IGD_REG_SAVE_MMIO      0x00004
-#define IGD_REG_SAVE_RB        0x00008
-#define IGD_REG_SAVE_VGA_MEM   0x00010
-#define IGD_REG_SAVE_MODE      0x00020
-#define IGD_REG_SAVE_BACKLIGHT 0x00040
-#define IGD_REG_SAVE_3D        0x00080
-#define IGD_REG_SAVE_GTT       0x00100
-#define IGD_REG_SAVE_TYPE_REG  0x10000
-#define IGD_REG_SAVE_TYPE_CON  0x20000
-#define IGD_REG_SAVE_TYPE_MISC 0x40000
-#define IGD_REG_SAVE_TYPE_MASK 0xF0000
-
-#define IGD_REG_SAVE_ALL (IGD_REG_SAVE_VGA | IGD_REG_SAVE_DAC |  \
-		IGD_REG_SAVE_MMIO | IGD_REG_SAVE_RB | IGD_REG_SAVE_VGA_MEM | \
-		IGD_REG_SAVE_MODE | IGD_REG_SAVE_BACKLIGHT | IGD_REG_SAVE_3D | \
-		IGD_REG_SAVE_GTT )
-
-/*!
- * @note: This macro does not save the mode (i2c) regs. You have to
- * explicitly ask for that too if you want it.
- */
-#define IGD_REG_SAVE_STATE (IGD_REG_SAVE_VGA | IGD_REG_SAVE_DAC | \
-		IGD_REG_SAVE_MMIO | IGD_REG_SAVE_RB | IGD_REG_SAVE_VGA_MEM | \
-		IGD_REG_SAVE_GTT )
-/*! @} */
-
-
-/*! @} */
-
-#endif /* _IGD_INIT_H_ */
+/*
+ *-----------------------------------------------------------------------------
+ * Filename: igd_init.h
+ * $Revision: 1.15 $
+ *-----------------------------------------------------------------------------
+ * Copyright (c) 2002-2010, Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *-----------------------------------------------------------------------------
+ * Description:
+ *
+ *-----------------------------------------------------------------------------
+ */
+
+#ifndef _IGD_INIT_H_
+#define _IGD_INIT_H_
+
+#include <igd.h>
+
+
+/*!
+ * @addtogroup init_group
+ *
+ * The init module contains the entry points and data structures
+ * necessary to initialize the graphics driver HAL.
+ * The IAL will call several initialization functions to bring the HAL
+ * to a usable state, after which, the HAL is accessed through a dispatch
+ * table (data structure of function pointers).
+ *
+ * Typical initialization will follow these steps:
+ * - Initialize the HAL by calling igd_driver_init() to
+ *   detect supported chipsets without altering the hardware. If a
+ *   supported device is found the _igd_init_info data structure will be
+ *   populated indicating the chipset name and PCI information for the device.
+ *   A driver handle that should be used during the rest of the
+ *   initialization process will be returned.
+ *
+ * - Call igd_driver_config() to prepare the hardware for use. Until this
+ *   point there has been no alteration of the hardware. After the
+ *   driver has been configured the igd_get_config_info() function can
+ *   be used. Only a subset of the _igd_config_info data will be available
+ *   at this time as the modular HAL components have not been initialized.
+ *
+ * - Call igd_module_init() to initialize the modular components of the
+ *   driver. This function accepts a set of parameters that can alter
+ *   default behavior. A provided dispatch table will be populated with
+ *   the entry points used for hardware operations during the life of
+ *   the driver. igd_get_config_info() may now be used to return full
+ *   configuration details.
+ *
+ * @{
+ */
+
+/*!
+ * @brief Data populated by igd_driver_init().
+ *
+ * The init info is used as input/output to igd_driver_init(). Any non-zero
+ * members (with the exception of the name) will be used to limit the search
+ * for available devices, if all members are zero the first supported
+ * device found on the system will be used. In either case the data returned
+ * will reflect the to-be-controlled device found by the HAL.
+ *
+ * The name is a ASCII string that may be used in human readable output
+ * dialogs.
+ */
+typedef struct _igd_init_info {
+	/*! @brief PCI Vendor ID */
+	unsigned int vendor_id;
+	/*! @brief PCI Device ID */
+	unsigned int device_id;
+	/*! @brief PCI Bus ID */
+	unsigned int bus;
+	/*! @brief PCI Slot ID */
+	unsigned int slot;
+	/*! @brief PCI Function ID */
+	unsigned int func;
+	/*! @brief ASCII chipset name */
+	char *name;
+	/*! @brief ASCII chipset ID */
+	char *chipset;
+	/*! @brief ASCII default port driver list */
+	char *default_pd_list;
+} igd_init_info_t;
+
+/*!
+ * @brief Function to initialize the HAL and detect supported chipset.
+ *
+ * Initialize the driver and determine if the hardware is supported without
+ * altering the hardware state in any way. Init info is populated based on
+ * collected data.
+ *
+ * A driver handle is returned. This handle is an opaque data structure
+ * used with future HAL calls. The contents or meaning of the value are
+ * not known outside the HAL; however, a NULL value should be considered
+ * a failure.
+ *
+ * @param init_info Device details returned from the init process. This
+ *   structure will be populated by the HAL during the call.
+ *
+ * @return igd_driver_h (Non-NULL) on Success
+ * @return NULL on failure
+ */
+igd_driver_h igd_driver_init(igd_init_info_t *init_info);
+
+
+/*!
+ *  Configure the driver. This sets the driver for future operation, it
+ * may alter the hardware state. Must be called after driver init and
+ * before ANY other driver commands.
+ *
+ * @param driver_handle: A driver handle as returned by igd_driver_init()
+ *
+ * @return <0 on Error
+ * @return 0 On Success
+ */
+int igd_driver_config(igd_driver_h driver_handle);
+
+
+
+/*!
+ * @defgroup init_param Initialization Parameters
+ *
+ * Initialization parameters are passed to igd_module_init() to control
+ * configurable behavior of the HAL. Some parameters are global in that
+ * they have an effect on the entire driver. In addition, there are
+ * parameters that are specific to a display. These parameters are provided
+ * in a list with each list entry representing a defined "port number" as
+ * follows shown here:
+ *
+<PRE>
+                                        /|-----------|
+                                       / | Fp Info   |
+                                      /  |-----------|
+        |----------|   /|---------|  /
+        | Params   |  / | Display | /    |-----------|
+        |          | /  | Param 1 |/     | DTD Array |
+        |          |/   |---------|\     |-----------|
+        |----------|\               \
+                     \  |---------|  \   |-----------|
+                      \ | Display |   \  | Attribute |
+                       \| Param N |    \ | Array     |
+                        |---------|     \|-----------|
+</PRE>
+ *
+ * The port numbers are mapped to hardware specific outputs as defined
+ * here:
+ *
+ * 830M and later Port numbers:
+ *   - 1 DVO A port
+ *   - 2 DVO B port
+ *   - 3 DVO C port
+ *   - 4 Internal LVDS port
+ *   - 5 Analog port
+ *
+ *   On 835: If RGBA is used (DVO B & C together), then use DVO B number
+ *   to specify any parameter for it.
+ *
+ * 810/815 Port numbers:
+ *   - 3 DVO port
+ *   - 5 Analog port
+ *
+ * NOTE: The permanence of the Params data structure that is passed from
+ * the IAL to the HAL in igd_module_init API is not guaranteed by the IAL
+ * Therefore, the different HAL modules should use the data out of this
+ * data structure only until igd_module_init and not after that.
+ * @{
+ */
+
+/*!
+ * This parameter, when set, will cause the driver to save the current
+ * register state of the device prior to altering it in any way. This
+ * will allow the state of the device to be reapplied at exit time.
+ */
+#define IGD_DRIVER_SAVE_RESTORE   0x01
+
+/*!
+ * @name Per-Display Present Params Flags
+ * @anchor present_params_flags
+ *
+ * These flags are used to identify which parameters are being provided to
+ * the HAL. If a bit is not set in the _igd_display_params::present_params
+ * variable the parameters will not be read by the HAL and the default
+ * behavior will be used instead.
+ *
+ * - IGD_PARAM_DDC_GPIO Parameter to select non-standard GPIO pair for DDC.
+ * - IGD_PARAM_DDC_SPEED Parameter to select non-standard DDC speed.
+ * - IGD_PARAM_DDC_DAB Parameter to select the Device Address Byte to use for
+ *     DDC communication
+ * - IGD_PARAM_I2C_GPIO Parameter to select non-standard GPIO pair for i2c.
+ * - IGD_PARAM_I2C_SPEED Parameter to select non-standard I2C speed.
+ * - IGD_PARAM_DAB Parameter to select the Device Address Byte to use for I2C
+ *     communication.
+ * - IGD_PARAM_FP_INFO Parameter to provide non-detectable Flat Panel
+ *     configuration data.
+ * - IGD_PARAM_DTD_LIST Parameter to provide a Detailed Timing List for a
+ *     display.
+ * - IGD_PARAM_ATTR_LIST Parameter to provide a set of Port Driver Attributes
+ *     to use during init.
+ *
+ * @{
+ */
+#define IGD_PARAM_DDC_GPIO        0x00000001
+#define IGD_PARAM_DDC_SPEED       0x00000002
+#define IGD_PARAM_DDC_DAB         0x00000004
+#define IGD_PARAM_I2C_GPIO        0x00000008
+#define IGD_PARAM_I2C_SPEED       0x00000010
+#define IGD_PARAM_DAB             0x00000020
+#define IGD_PARAM_FP_INFO         0x00000040
+#define IGD_PARAM_DTD_LIST        0x00000080
+#define IGD_PARAM_ATTR_LIST       0x00000100
+/*! @} */
+
+
+/*!
+ *
+ *
+ *
+ * @note Any changes to the above number assignment will break the driver.
+ *       If change is required, make sure to change the port numbers in
+ *       port tables.
+ *
+ */
+
+/* The method for controlling the flat panel power. The options include:
+ * no support or the Port Driver handles flat panel power. */
+#define IGD_PARAM_FP_PWR_METHOD_NONE 0
+#define IGD_PARAM_FP_PWR_METHOD_PD   1
+
+/*!
+ * @brief Port-specific color correction information
+ *
+ * Initialization parameter passed as part of igd_module_init() to provide
+ * information about an attached display device. One color_correct_info
+ * is provided for each display port.
+ *
+ */
+typedef struct _igd_param_color_correct_info {
+	/*! @brief RED value for GAMMA */
+	unsigned short gamma_r;
+	/*! @brief GREEN value for GAMMA */
+	unsigned short gamma_g;
+	/*! @brief BLUE value for GAMMA */
+	unsigned short gamma_b;
+	/*! @brief RED value for BRIGHTNESS */
+	unsigned short brightness_r;
+	/*! @brief GREEN value for BRIGHTNESS */
+	unsigned short brightness_g;
+	/*! @brief BLUE value for BRIGHTNESS */
+	unsigned short brightness_b;
+	/*! @brief RED value for CONTRAST */
+	unsigned short constrast_r;
+	/*! @brief GREEN value for CONTRAST */
+	unsigned short constrast_g;
+	/*! @brief BLUE value for CONTRAST */
+	unsigned short constrast_b;
+} igd_param_color_correct_info_t;
+
+
+
+/*!
+ * @brief Flat Panel Information
+ *
+ * Initialization parameter passed as part of igd_module_init() to provide
+ * information about an attached Flat Panel (typically LVDS). One fp_info
+ * is provided for each display port, and is only used when the
+ * IGD_PARAM_FP_INFO flag is set in the _igd_display_params::present_params
+ *
+ */
+typedef struct _igd_param_fp_info {
+	/*! @brief Flat panel width */
+	unsigned long fp_width;
+	/*! @brief Flat panel height */
+	unsigned long fp_height;
+	/*! @brief Flat Panel Power Method */
+	unsigned long fp_pwr_method;
+	/*!
+	 * @brief Min time delay in miliseconds between VDD active and clock/data
+	 * active.
+	 */
+	unsigned long fp_pwr_t1;
+	/*!
+	 * @brief Min time delay in miliseconds between clock/data active and
+	 * backlight enable.
+	 */
+	unsigned long fp_pwr_t2;
+	/*!
+	 * @brief Min time delay in miliseconds between Backlight disable and
+	 * clock/data inactive
+	 */
+	unsigned long  fp_pwr_t3;
+	/*!
+	 * @brief Min time delay in miliseconds between clock/data inactive and
+	 * VDD inactive.
+	 */
+	unsigned long  fp_pwr_t4;
+	/*!
+	 * @brief Min time delay in miliseconds between VDD inactive and
+	 * VDD active.
+	 */
+	unsigned long  fp_pwr_t5;
+} igd_param_fp_info_t;
+
+/*!
+ * @brief Per-display init-time list of DTDs.
+ *
+ * In the case of EDID-less display device, this parameter provides
+ * the DTD (Detailed Timing Descriptor) list to the HAL during initialization.
+ */
+typedef struct _igd_param_dtd_list {
+	/*! @brief number of DTDs */
+	unsigned long  num_dtds;
+	/*! @brief DTD list */
+	igd_display_info_t  *dtd;
+} igd_param_dtd_list_t;
+
+/*!
+ * @brief Port driver attribute
+ */
+typedef struct _igd_param_attr {
+	/*! @brief See @ref attr_id_defs for predefined IDs */
+	unsigned long  id;
+	/*! @brief value or index(incase of list type attr) */
+	unsigned long  value;
+} igd_param_attr_t;
+
+/*!
+ * @brief Port driver init-time attribute list
+ *
+ * This data structure is used during HAL initialization. It should be
+ * populated with any port driver attributes that were modified and saved
+ * in a prior use of the HAL.
+ */
+typedef struct _igd_param_attr_list {
+	/*! @brief  number of attributes in the list */
+	unsigned long  num_attrs;
+	/*! @brief IAL allocated attribute list */
+	igd_param_attr_t *attr;
+} igd_param_attr_list_t;
+
+
+
+/*!
+ * @brief Per-Display Init-time configuration parameters.
+ *
+ * These parameters are provided as an array during igd_module_init().
+ * They allow the default behavior of the driver to be altered on a
+ * per-display basis. They are input-only to provide data
+ * about non-standard hardware configurations and persistant driver state.
+ */
+typedef struct _igd_display_params {
+	/*! @brief Port to which these parameters apply. See @ref init_param */
+	unsigned long port_number;
+	/*! @brief parameters present bitfield: See @ref present_params_flags */
+	unsigned long present_params;
+	unsigned long flags;
+	/*!
+	 * @brief Timing sources to use with Edid displays.
+	 * See @ref advanced_edid
+	 */
+	unsigned short edid_avail;
+	/*!
+	 * @brief Timings sources to use with Edid-less displays.
+	 * See @ref advanced_edid
+	 */
+	unsigned short edid_not_avail;
+	unsigned long ddc_gpio;       /* DDC GPIO pin pair number 0..6 */
+	unsigned long ddc_speed;      /* DDC speed in KHz to read EDID */
+	unsigned long ddc_dab;        /* DDC DAB to read EDID from display device */
+	unsigned long i2c_gpio;       /* I2C GPIO pin pair number 0..6 */
+	unsigned long i2c_speed;      /* I2C speed in KHz to read EDID */
+	unsigned long i2c_dab;        /* I2C DAB to communicate with DVO device */
+	igd_param_fp_info_t fp_info;  /* Connected FP Info */
+	/*!
+	 * DTD parameter: Incase of EDID-less display device, this parameter
+	 * provides the DTD (Detailed Timing Descriptor) list
+	 */
+	igd_param_dtd_list_t dtd_list;
+
+	igd_param_attr_list_t attr_list;
+} igd_display_params_t;
+
+/*!
+ * @name Advanced Edid Flags
+ * @anchor advanced_edid
+ *
+ * Flags to use with edid_avail and edid_not_avail:
+ * perport edid_avail/edid_not_avail
+ *
+ * IGD_DISPLAY_USE_STD_TIMINGS:
+ *   If not set: Do not use driver built-in standard timings
+ *   If set:     Use driver built-in standard timings
+ *
+ * IGD_DISPLAY_USE_EDID:  not applicable to edid_not_avail
+ *   If not set: Do not use EDID block
+ *   If set:     Use EDID block and filter modes
+ *
+ * IGD_DISPLAY_USE_USERDTDS:
+ *   If not set: Do not use user-DTDs
+ *   If set:     Use user-DTDs.
+ *
+ * @{
+ */
+#define IGD_DISPLAY_USE_STD_TIMINGS    0x1
+#define IGD_DISPLAY_USE_EDID           0x2
+#define IGD_DISPLAY_USE_USERDTDS       0x4
+/*! @} */
+
+
+/* Flags for igd_display_params_t->flags*/
+#define IGD_DISPLAY_READ_EDID     0x00000001  /* igd_display_params_t.flags */
+
+/*!
+ * @anchor display_flags_def
+ *
+ * These flags may be used in the display_flags member of the
+ * igd_params_t data structure.
+ *
+ */
+#define IGD_DISPLAY_MULTI_DVO     0x00000002  /* igd_param_t.display_flags  */
+#define IGD_DISPLAY_DETECT        0x00000004  /* igd_param_t.display_flags  */
+#define IGD_DISPLAY_FB_BLEND_OVL  0x00000008  /* igd_param_t.display_flags  */
+#define IGD_DISPLAY_BATCH_BLITS   0x00000010
+	/*! @brief enable dynamic blending of display frame buffer with overlay */
+
+
+
+/*!
+ * @brief Init-Time Driver Parameters
+ *
+ * The igd_param_t data structure contains  global init-time static parameters
+ * to impact the behavior of the whole driver. They are provided to the driver
+ * during module initialization to control overall driver behavior.
+ *
+ *
+ *           VERY IMPORTANT!!! CHANGES TO DEFINITION OF THIS STRUCTURE AND
+ *           ITS MEMBER STRUCTURES MUST BE FOLLOWED BY UPDATES TO THE
+ *           FOLLOWING COMPONENTS / FILES:
+ *                       1. ssigd/ial/vbios/usrbld/igd_uinit.h
+ *                       2. ssigd/ial/vbios/src/core/user_config.c
+ *                       3. pcf2iegd tool (gens user_config.c/h for usr-bld)
+ *                       4. CED tool (generates user_config.c/h for usr-bld)
+ *
+ *
+ *
+ * See igd_module_init()
+ */
+typedef struct _igd_param {
+	/*! @brief Maximum pages taken by the driver for offscreen memory */
+	unsigned long        page_request;
+	/*! @brief Maximum pages reserved for the framebuffer. */
+	unsigned long        max_fb_size;
+	/*! @brief Boolean option to preserve initial hardware state */
+	unsigned char        preserve_regs;
+	/*! @ref display_flags_def "Display Flags" */
+	unsigned long        display_flags;
+	/*!
+	 * @brief Port detection order.
+	 *
+	 * HAL will detect the displays in the  order mentioned and also allocate
+	 * in the same order if found.
+	 *
+	 * Example: To detect/allocate in the order on 855:
+	 * -# DVOB PORT
+	 * -# ANALOG PORT
+	 * -# LVDS PORT
+	 * then specify port_number[] = {2, 5, 4, 0};
+	 *
+	 * @note Set port_number[] = {0, 0, 0, 0}; to work in the default order.
+	 *
+	 * @note If a invalid number is specified then it will be skipped.
+	 */
+	unsigned long port_order[IGD_MAX_PORTS];
+
+	/*! Contains the Per-Display init-time parameters. */
+	igd_display_params_t display_params[IGD_MAX_PORTS];
+
+	/*! @brief RGB color that will be used while clearing the framebuffer */
+	unsigned long        display_color;
+
+    unsigned long       quickboot;
+    int                 qb_seamless;
+    unsigned long       qb_video_input;
+    int                 qb_splash;
+
+	/*! Override interrupt support and revert to polling */
+	int                 polling;
+	unsigned long 		ref_freq;
+	int 				tuning_wa;
+	unsigned long 		clip_hw_fix;
+
+
+	/* Async flip flickering workaround enable */
+	unsigned long		async_flip_wa;
+
+	/*
+	 * Enable override of following registers when en_reg_override=1.
+	 * Display Arbitration, FIFO Watermark Control, GVD HP_CONTROL,
+	 * Bunit Chickenbits, Bunit Write Flush, Display Chickenbits
+	 */
+	unsigned long		en_reg_override;
+	unsigned long		disp_arb;
+	unsigned long		fifo_watermark1;
+	unsigned long		fifo_watermark2;
+	unsigned long		fifo_watermark3;
+	unsigned long		fifo_watermark4;
+	unsigned long		fifo_watermark5;
+	unsigned long		fifo_watermark6;
+	unsigned long		gvd_hp_control;
+	unsigned long		bunit_chicken_bits;
+	unsigned long		bunit_write_flush;
+	unsigned long		disp_chicken_bits;
+	int					punt_to_3dblit;
+
+} igd_param_t;
+
+typedef struct {
+	unsigned debug : 1;
+	unsigned ddk_version : 16;
+	unsigned emgd_version : 15;
+} igd_build_config_t;
+
+/*! @} */
+
+/*!
+ *
+ *  Initializes individual modules to a runable state. Init time parameters
+ * may be provided to alter the default behavior of the driver.
+ * See @ref init_param
+ *
+ * The dispatch table for all graphics operations is returned. The dispatch
+ * table may return NULL pointers for unsupported functions due to
+ * optional modules. This dispatch table is used to access HAL functionality
+ * throughout the life of the driver.
+ * See @ref _igd_dispatch
+ *
+ * @param driver_handle as returned from igd_driver_init().
+ * @param dsp dispatch table to be populated during the call.
+ * @param params Input parameters to alter default behavior.
+ *   See @ref init_param
+ *
+ * @return 0 Success
+ * @return <0 on Error
+ */
+int igd_module_init(igd_driver_h driver_handle,
+	igd_dispatch_t **dsp,
+	igd_param_t *params);
+
+
+
+/*!
+ * @name Framebuffer Capabilities
+ * @anchor fb_caps
+ *
+ * FB caps are an indication of large feature sets that will or will not
+ * be available based on FB pixel format. This allows an IAL to intelligently
+ * configure itself to the appropriate setup before setting a display
+ * mode.
+ * FB caps are returned from a call to igd_get_config_info().
+ *
+ * - IGD_CAP_BASIC_2D This capability bit indicates that the device is capable
+ *    of performing basic 2d acceleration.
+ * - IGD_CAP_FULL_2D This capability bit indicates that the device is capable
+ *    of performing full 2d acceleration.
+ * - IGD_CAP_BLEND This capability bit indicates that the device is capable of
+ *    performing the blend() function to the framebuffer.
+ *
+ * @{
+ */
+#define IGD_CAP_BASIC_2D  0x01
+#define IGD_CAP_FULL_2D  (0x02 | IGD_CAP_BASIC_2D)
+#define IGD_CAP_BLEND     0x04
+/*! @} */
+
+
+/*!
+ * @brief Device Capabilities based on FB mode
+ *
+ * This structure reports the Framebuffer capabilities on a pixel format
+ * basis. An IAL should check these capabilities before using acceleration
+ * features. This structure is returned as part of the _igd_config_info
+ * information from the igd_get_config_info() call.
+ *
+ * @see pixel_formats
+ */
+typedef struct _igd_fb_caps {
+	/*! @brief The framebuffer pixel format that these caps reference */
+	unsigned long pixel_format;
+	/*! @brief The capability bits as defined by @ref fb_caps */
+	unsigned long caps;
+} igd_fb_caps_t;
+
+/*!
+ * @brief Static HAL configuration data
+ *
+ * Config info contains the static configuration information for the device
+ * that is found during the call to igd_driver_config(). It is obtained
+ * with a call to igd_get_config_info() which may be done before or after
+ * module configuration with limited success.
+ */
+typedef struct _igd_config_info {
+	/*! @brief The Base MMIO physical (Bus) address. */
+	unsigned long mmio_base_phys;
+	/*! @brief The Base MMIO virtual address. */
+	unsigned char *mmio_base_virt;
+	/*! @brief The Base Video Memory physical (Bus) address. */
+	unsigned long gtt_memory_base_phys;
+	/*! @brief The Base Video Memory virtual address. */
+	unsigned char *gtt_memory_base_virt;
+	/*! @brief The Video Memory Size. */
+	unsigned long gtt_memory_size;
+	/*! @brief The number of display planes supported by the device. */
+	unsigned long num_dsp_planes;
+	/*! @brief The number of display pipes supported by the device. */
+	unsigned long num_dsp_pipes;
+	/*! @brief The number of currently active display ports. */
+	unsigned long num_act_dsp_ports;
+	/*! @brief Caps, terminated with PF = 0 */
+	igd_fb_caps_t *fb_caps;
+	/*! @brief The device revision id. */
+	unsigned long revision_id;
+	/*! @brief HW status page offset (priviledged use only) */
+	unsigned long hw_status_offset;
+	/*! @brief The base of stolen memory */
+	unsigned long stolen_memory_base_virt;
+	/* pixel format that matches the bpp that was passed in */
+	unsigned long pixel_format;
+	/* port-specific rotation read from DisplayID */
+	igd_DID_rotation_info_t displayid_rotation[IGD_MAX_PORTS];
+} igd_config_info_t;
+
+
+/*!
+ * @brief Static GTT configuration data
+ *
+ * This holds the configuration of the GTT and the information
+ * required to handle video memory allocation/free.
+ *
+ * FIXME: There is a lot of duplication with information stored
+ * else were (like igd_config_info_t) that needs to be cleaned up.
+ */
+typedef struct _igd_gtt_info_t {
+	unsigned long gatt_start;
+	unsigned long gatt_pages;
+	unsigned long gtt_start;
+	unsigned long gtt_pages;
+	unsigned long gtt_phys_start;
+	unsigned long stolen_mem_base;
+	unsigned long stolen_mem_size;
+	unsigned long stolen_pages;
+	unsigned long pge_ctl;
+	unsigned short gmch_ctl;
+	unsigned long *gtt_mmap;
+	void *vram_virt;
+	unsigned long initialzied;
+	void *scratch_page;
+} igd_gtt_info_t;
+
+
+
+/*!
+ * The igd_get_config_info() function call can be used to get static
+ * configuration information details that the IAL may need. This
+ * function may be called prior to igd_module_init() with limited
+ * success; however, it is recommeneded that it be called after the
+ * modular HAL components have been initialized.
+ *
+ * In addition to static configuration there may be dynamic configuration
+ * details that can be queried at any time after igd_driver_config().
+ * These are defined with unique identifiers and are queried one at a
+ * time with igd_get_param().
+ *
+ *  @param driver_handle as retuned from igd_driver_init()
+ *  @param config_info Populated with hardware information during the call..
+ *
+ *  @return 0 Success
+ *  @return -IGD_INVAL Error
+ */
+int igd_get_config_info(igd_driver_h driver_handle,
+	igd_config_info_t *config_info);
+
+
+
+/*!
+ * @defgroup runtime_param Runtime Parameter Control
+ *
+ * HAL parameters may be queried and set at runtime using the
+ * _igd_dispatch::get_param() and _igd_dispatch::set_param() dispatch functions
+ * (when called after initialization) or the
+ * igd_get_param() and igd_set_param() functions when called during
+ * initialization.
+ * Some implemtations may not support all parameters so IAL's must handle
+ * errors. Additionally, some parameters are hardware specific and of no use to
+ * general purpose IALs. These should only be used by IALs with extensive
+ * hardware knowledge (OpenGL, D3D, etc)
+ *
+ * @{
+ */
+
+/*!
+ * @name Runtime Parameter Defines
+ *
+ * - IGD_PARAM_PANEL_ID Primary Panel ID
+ *    This is a unique Flat Panel Identifier that is obtained from firmware.
+ *    The IAL may use this information to send in Detailed Timing Descriptors
+ *    to igd_module_init(). This facilitates the use of multiple local Flat
+ *    panel configurations without EDID. When available this parameter may
+ *    be queried prior to igd_module_init().
+ * - IGD_PARAM_MEM_RESERVATION Bios memory reservation.
+ *    This is the amount (in bytes?) of memory that the bios has already
+ *    installed in the Gart prior to driver load. It is used when a
+ *    non-standard bios or firmware has pre-allocated an undetectable amount
+ *    of video memory for splash screen use. When available this parameter can
+ *    be queried prior to igd_module_init().
+ * - IGD_PARAM_DEBUG_MASK Debug Printing Mask.
+ *    This parameter is read/write and may be altered at any time after
+ *    igd_driver_init(). It is a bitfield to control different printing
+ *    groups for debug builds.
+ * - IGD_PARAM_PORT_LIST A bitfield used by the vBIOS to override the
+ *    display detect capabilities in the driver.
+ * - IGD_PARAM_HW_CONFIG Hardware configuration Bitfield
+ *    contains one of these dependeing on platform:
+ *    IGD_ALM_HW_CONFIG_BIN or IGD_NAP_HW_CONFIG_BIN both of which indicate
+ *    the presence and availability of the hardware binner. This value should
+ *    be queried and set (removing the bit) by an IAL claiming use of the
+ *    binner.
+ * - IGD_PARAM_INTR_STATUS Unknown FIXME document this
+ *
+ * @{
+ */
+#define IGD_PARAM_PANEL_ID        0x01
+#define IGD_PARAM_MEM_RESERVATION 0x02
+#define IGD_PARAM_DEBUG_MASK 0x03
+#define IGD_PARAM_PORT_LIST  0x04
+#define IGD_PARAM_GFX_FREQ  0x05
+#define IGD_PARAM_SET_LVDS  0x06
+#define IGD_PARAM_HW_CONFIG 0x1000
+#define  IGD_ALM_HW_CONFIG_BIN 0x1
+#define  IGD_NAP_HW_CONFIG_BIN 0x1
+#define IGD_PARAM_INTR_STATUS 0x1001
+
+/*! @} */
+
+/*!
+ * Gets the value of a runtime driver parameter. These parameters are
+ * each defined with a unique ID and may be altered at runtime.
+ *
+ * Note: There is a wrapper for this function in the dispatch table that
+ * takes a display instead of a driver handle. This version is for use
+ * when displays are not yet available.
+ *
+ * @bug Runtime parameter documentation needs updates
+ *
+ * @return 0 Success
+ * @return -IGD_INVAL Error
+ */
+int igd_get_param(igd_driver_h driver_handle,
+	unsigned long id,
+	unsigned long *value);
+
+/*!
+ * Sets the value of a runtime driver parameter. These parameters are
+ * each defined with a unique ID and may be altered at runtime.
+ *
+ * Note: There is a wrapper for this function in the dispatch table that
+ * takes a display instead of a driver handle. This version is for use
+ * when displays are not yet available.
+ *
+ * @return 0 Success
+ * @return  -IGD_INVAL Error
+ */
+int igd_set_param(igd_driver_h driver_handle,
+	unsigned long id,
+	unsigned long value);
+
+/*! @} Runtime Param Group */
+/*! @} Init Group */
+
+
+/*!
+ * @ingroup cleanup
+ * @brief Shuts down the HAL
+ *
+ * This function shuts down the HAL and frees and remaining resources.
+ * It should be called at driver exit to leave the hardware in a safe
+ * configuration.
+ *
+ * @param driver_handle The driver handle returned from igd_driver_init().
+ *
+ * @return void
+ */
+void igd_driver_shutdown(igd_driver_h driver_handle);
+
+/*!
+ * @ingroup cleanup
+ * @brief Shuts down the HAL
+ *
+ * This function shuts down the HAL and frees and remaining resources.
+ * It should be called at driver exit to leave the hardware in a safe
+ * configuration.
+ *
+ * @param driver_handle The driver handle returned from igd_driver_init().
+ *
+ * @return void
+ */
+void igd_driver_shutdown_hal(igd_driver_h driver_handle);
+
+
+/*!
+ * @ingroup cleanup
+ * @brief Query 2D capability of the hardware.
+ *
+ * This function query the hardware whether given capabilities value
+ * (caps_val) is supported by hardware.
+ *
+ * @param driver_handle The driver handle returned from igd_driver_init().
+ *
+ * @return void
+ */
+void igd_query_2d_caps_hwhint(igd_driver_h driver_handle,
+			unsigned long caps_val,
+			unsigned long *status);
+
+
+
+/* 2D capabilities to query */
+#define IGD_2D_CAPS_BLT                 0
+
+/* Output of 2D capabilities to query */
+#define IGD_2D_HW_DISABLE                       0
+#define IGD_2D_HW_ENABLE                        1
+#define IGD_2D_CAPS_UNKNOWN                     2
+
+
+
+/*!
+ * @addtogroup power_group
+ * @{
+ */
+
+/*!
+ * @name Driver Save Flags
+ * @anchor driver_save_flags
+ *
+ * Flags for use with dispatch->driver_save()
+ * @{
+ */
+#define IGD_REG_SAVE_VGA       0x00001
+#define IGD_REG_SAVE_DAC       0x00002
+#define IGD_REG_SAVE_MMIO      0x00004
+#define IGD_REG_SAVE_RB        0x00008
+#define IGD_REG_SAVE_VGA_MEM   0x00010
+#define IGD_REG_SAVE_MODE      0x00020
+#define IGD_REG_SAVE_BACKLIGHT 0x00040
+#define IGD_REG_SAVE_3D        0x00080
+#define IGD_REG_SAVE_GTT       0x00100
+#define IGD_REG_SAVE_TYPE_REG  0x10000
+#define IGD_REG_SAVE_TYPE_CON  0x20000
+#define IGD_REG_SAVE_TYPE_MISC 0x40000
+#define IGD_REG_SAVE_TYPE_MASK 0xF0000
+
+#define IGD_REG_SAVE_ALL (IGD_REG_SAVE_VGA | IGD_REG_SAVE_DAC |  \
+		IGD_REG_SAVE_MMIO | IGD_REG_SAVE_RB | IGD_REG_SAVE_VGA_MEM | \
+		IGD_REG_SAVE_MODE | IGD_REG_SAVE_BACKLIGHT | IGD_REG_SAVE_3D | \
+		IGD_REG_SAVE_GTT )
+
+/*!
+ * @note: This macro does not save the mode (i2c) regs. You have to
+ * explicitly ask for that too if you want it.
+ */
+#define IGD_REG_SAVE_STATE (IGD_REG_SAVE_VGA | IGD_REG_SAVE_DAC | \
+		IGD_REG_SAVE_MMIO | IGD_REG_SAVE_RB | IGD_REG_SAVE_VGA_MEM | \
+		IGD_REG_SAVE_GTT )
+/*! @} */
+
+
+/*! @} */
+
+#endif /* _IGD_INIT_H_ */
-- 
1.7.9.7

