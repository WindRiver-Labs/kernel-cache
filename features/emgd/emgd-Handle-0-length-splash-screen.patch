From 718ea1a3cc5a7e3e7fef167b58c36b51f7d475b0 Mon Sep 17 00:00:00 2001
From: Donn Seeley <donn.seeley@windriver.com>
Date: Tue, 12 Jun 2012 10:26:09 -0600
Subject: [PATCH 09/19] emgd: Handle 0-length splash screen.

The splash-screen code assumes that the compiled-in splash screen image
is non-empty, but in fact it's empty in the distributed version of EMGD,
as exposed by compiler warnings.  I changed the code to reduce the
contexts in which we assume that the screen image is non-empty, which
involved changing some (unused) APIs.  This eliminated the warnings.
I did not test the new code with a non-empty splash screen image.

Signed-off-by: Donn Seeley <donn.seeley@windriver.com>
---
 drivers/gpu/drm/emgd/emgd/drm/splash_screen.c |  113 +++++++++++++------------
 drivers/gpu/drm/emgd/emgd/drm/splash_screen.h |    7 +-
 2 files changed, 63 insertions(+), 57 deletions(-)

diff --git a/drivers/gpu/drm/emgd/emgd/drm/splash_screen.c b/drivers/gpu/drm/emgd/emgd/drm/splash_screen.c
index f429894..8aeac3b 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/splash_screen.c
+++ b/drivers/gpu/drm/emgd/emgd/drm/splash_screen.c
@@ -54,10 +54,12 @@ void display_splash_screen(
 	unsigned char *fb,
 	emgd_drm_splash_screen_t *ss_data)
 {
+        if (sizeof image_data > 0) {
 	if (image_data[0] == 0x89) {
-		display_png_splash_screen(fb_info, fb, ss_data);
+                        display_png_splash_screen(fb_info, fb, ss_data, image_data, sizeof image_data);
 	} else {
-		display_bmp_splash_screen(fb_info, fb, ss_data);
+                        display_bmp_splash_screen(fb_info, fb, ss_data, image_data);
+                }
 	}
 }
 
@@ -70,7 +72,8 @@ void display_splash_screen(
 void display_bmp_splash_screen(
 	igd_framebuffer_info_t *fb_info,
 	unsigned char *fb,
-	emgd_drm_splash_screen_t *ss_data)
+        emgd_drm_splash_screen_t *ss_data,
+        unsigned char *idata)
 {
 	unsigned char *fb_addr, *icon_temp;
 	unsigned long *fb_addr_long, icon_long;
@@ -95,7 +98,7 @@ void display_bmp_splash_screen(
 	}
 
 	fb_addr = fb + init_y_shift;
-	bytecount = (unsigned long) image_data[1];
+        bytecount = (unsigned long) idata[1];
 	bitmap_pitch = ss_data->width * bytecount;
 
 	limit_width = ss_data->width;
@@ -117,7 +120,7 @@ void display_bmp_splash_screen(
 		 * the second byte is the bytecount
 		 * and the third byte is the palette count
 		 */
-		icon_temp = &image_data[3 + (row * bitmap_pitch)];
+                icon_temp = &idata[3 + (row * bitmap_pitch)];
 		fb_index = 0;
 
 		for(col = 0; col < limit_width; col++) {
@@ -156,9 +159,10 @@ void display_bmp_splash_screen(
 void display_png_splash_screen(
 	igd_framebuffer_info_t *fb_info,
 	unsigned char *fb,
-	emgd_drm_splash_screen_t *ss_data)
+        emgd_drm_splash_screen_t *ss_data,
+        unsigned char *idata,
+        size_t image_size)
 {
-	unsigned long image_size;
 	unsigned long i;
 	unsigned long chunk_size;
 	unsigned long chunk_type;
@@ -193,13 +197,12 @@ void display_png_splash_screen(
 	image_header.background_g = (image_header.background >> 8) & 0xFF;
 	image_header.background_b = image_header.background & 0xFF;
 
-	image_size = sizeof(image_data)/sizeof(unsigned char);
-	input_data = (unsigned char *)vmalloc(sizeof(image_data));
+        input_data = (unsigned char *)vmalloc(image_size);
 	if (!input_data) {
 		EMGD_ERROR("Out of memory");
 		return;
 	}
-	OS_MEMSET(input_data, 0, sizeof(image_data));
+        OS_MEMSET(input_data, 0, image_size);
 
 	orig_x = (short) ss_data->x;
 	orig_y = (short) ss_data->y;
@@ -208,8 +211,8 @@ void display_png_splash_screen(
 	 * Lets get the information for the first chunk, which should be
 	 * the header chunk: IHDR.
 	 */
-	read_int_from_stream(image_data, &iter, &chunk_size);
-	read_int_from_stream(image_data, &iter, &chunk_type);
+        read_int_from_stream(idata, &iter, &chunk_size);
+        read_int_from_stream(idata, &iter, &chunk_type);
 
 	/*
 	 * Initialize image_header
@@ -229,13 +232,13 @@ void display_png_splash_screen(
 	while (iter <= image_size) {
 		switch (chunk_type) {
 		case CHUNK_IHDR:
-			read_int_from_stream(image_data, &iter, &image_header.width);
-			read_int_from_stream(image_data, &iter, &image_header.height);
-			image_header.bit_depth = (unsigned char)image_data[iter++];
-			image_header.colour_type = (unsigned char)image_data[iter++];
-			image_header.compression_method = (unsigned char)image_data[iter++];
-			image_header.filter_method = (unsigned char)image_data[iter++];
-			image_header.interlace_method = (unsigned char)image_data[iter++];
+                        read_int_from_stream(idata, &iter, &image_header.width);
+                        read_int_from_stream(idata, &iter, &image_header.height);
+                        image_header.bit_depth = (unsigned char)idata[iter++];
+                        image_header.colour_type = (unsigned char)idata[iter++];
+                        image_header.compression_method = (unsigned char)idata[iter++];
+                        image_header.filter_method = (unsigned char)idata[iter++];
+                        image_header.interlace_method = (unsigned char)idata[iter++];
 			image_header.x_offset = orig_x;
 			image_header.y_offset = orig_y;
 
@@ -270,15 +273,15 @@ void display_png_splash_screen(
 			image_header.using_transparency = 1;
 			switch (image_header.colour_type) {
 				case COLOR_GREY:
-					read_short_from_stream(image_data, &iter,
+                                        read_short_from_stream(idata, &iter,
 						&image_header.transparency_r);
 					break;
 				case COLOR_TRUE:
-					read_short_from_stream(image_data, &iter,
+                                        read_short_from_stream(idata, &iter,
 						&image_header.transparency_r);
-					read_short_from_stream(image_data, &iter,
+                                        read_short_from_stream(idata, &iter,
 						&image_header.transparency_g);
-					read_short_from_stream(image_data, &iter,
+                                        read_short_from_stream(idata, &iter,
 						&image_header.transparency_b);
 					break;
 				case COLOR_INDEXED:
@@ -288,7 +291,7 @@ void display_png_splash_screen(
 								"transparency values for the palette");
 						}
 						for (i=0; i<chunk_size; i++) {
-							read_char_from_stream(image_data, &iter, &trans_p);
+                                                        read_char_from_stream(idata, &iter, &trans_p);
 							image_header.image_palette[i] &= 0xFFFFFF |
 								((trans_p << 28) | (trans_p << 24));
 						}
@@ -306,25 +309,25 @@ void display_png_splash_screen(
 
 				switch (image_header.bit_depth) {
 				case 16:
-					read_char_from_stream(image_data, &iter,
+                                        read_char_from_stream(idata, &iter,
 						&image_header.background_r);
 					iter++;
-					read_char_from_stream(image_data, &iter,
+                                        read_char_from_stream(idata, &iter,
 						&image_header.background_g);
 					iter++;
-					read_char_from_stream(image_data, &iter,
+                                        read_char_from_stream(idata, &iter,
 						&image_header.background_b);
 					iter++;
 					break;
 				case 8:
 					iter++;
-					read_char_from_stream(image_data, &iter,
+                                        read_char_from_stream(idata, &iter,
 						&image_header.background_r);
 					iter++;
-					read_char_from_stream(image_data, &iter,
+                                        read_char_from_stream(idata, &iter,
 						&image_header.background_g);
 					iter++;
-					read_char_from_stream(image_data, &iter,
+                                        read_char_from_stream(idata, &iter,
 						&image_header.background_b);
 					break;
 				}
@@ -336,18 +339,18 @@ void display_png_splash_screen(
 
 				switch (image_header.bit_depth) {
 				case 16:
-					read_char_from_stream(image_data, &iter,
+                                        read_char_from_stream(idata, &iter,
 						&image_header.background_r);
 					iter++;
 					break;
 				case 8:
 					iter++;
-					read_char_from_stream(image_data, &iter,
+                                        read_char_from_stream(idata, &iter,
 						&image_header.background_r);
 					break;
 				case 4:
 					iter++;
-					read_char_from_stream(image_data, &iter,
+                                        read_char_from_stream(idata, &iter,
 						&image_header.background_r);
 					image_header.background_r =
 						((image_header.background_r >> 4) << 4) |
@@ -355,7 +358,7 @@ void display_png_splash_screen(
 					break;
 				case 2:
 					iter++;
-					read_char_from_stream(image_data, &iter,
+                                        read_char_from_stream(idata, &iter,
 						&image_header.background_r);
 					image_header.background_r =
 						((image_header.background_r >> 2) << 6) |
@@ -365,7 +368,7 @@ void display_png_splash_screen(
 					break;
 				case 1:
 					iter++;
-					read_char_from_stream(image_data, &iter,
+                                        read_char_from_stream(idata, &iter,
 						&image_header.background_r);
 					image_header.background_r =
 						(image_header.background_r << 7) |
@@ -389,7 +392,7 @@ void display_png_splash_screen(
 			break;
 
 		case CHUNK_GAMA:
-			read_int_from_stream(image_data, &iter, &gama);
+                        read_int_from_stream(idata, &iter, &gama);
 			break;
 
 		case CHUNK_PLTE:
@@ -406,9 +409,9 @@ void display_png_splash_screen(
 			for (i=0; i<palette_size; i++) {
 				image_header.image_palette[i] = (
 					0xFF000000 |
-					((unsigned char)image_data[iter] << 16) |
-					((unsigned char)image_data[iter+1] << 8) |
-					(unsigned char)image_data[iter+2]);
+                                        ((unsigned char)idata[iter] << 16) |
+                                        ((unsigned char)idata[iter+1] << 8) |
+                                        (unsigned char)idata[iter+2]);
 				iter += 3;
 			}
 			break;
@@ -431,14 +434,14 @@ void display_png_splash_screen(
 				default_image->dispose_op = APNG_DISPOSE_OP_NONE;
 			}
 			for (i=0; i<chunk_size; i++) {
-				input_data[input_iter++] = image_data[iter++];
+                                input_data[input_iter++] = idata[iter++];
 			}
 			break;
 
 		case CHUNK_ACTL:
 			apng_file = 1;
-			read_int_from_stream(image_data, &iter, &apng_num_frames);
-			read_int_from_stream(image_data, &iter, &apng_num_plays);
+                        read_int_from_stream(idata, &iter, &apng_num_frames);
+                        read_int_from_stream(idata, &iter, &apng_num_plays);
 			frames = vmalloc(apng_num_frames * sizeof(png_frame));
 			if (!frames) {
 				EMGD_ERROR("Out of memory.");
@@ -459,15 +462,15 @@ void display_png_splash_screen(
 			/* Should we wipe out the input_data buffer? */
 			input_iter = 0;
 
-			read_int_from_stream(image_data, &iter, &sequence_number);
-			read_int_from_stream(image_data, &iter, &frames[cur_frame].width);
-			read_int_from_stream(image_data, &iter, &frames[cur_frame].height);
-			read_int_from_stream(image_data, &iter, &frames[cur_frame].x_offset);
-			read_int_from_stream(image_data, &iter, &frames[cur_frame].y_offset);
-			read_short_from_stream(image_data, &iter, &delay_num);
-			read_short_from_stream(image_data, &iter, &delay_den);
-			read_char_from_stream(image_data, &iter, &frames[cur_frame].dispose_op);
-			read_char_from_stream(image_data, &iter, &frames[cur_frame].blend_op);
+                        read_int_from_stream(idata, &iter, &sequence_number);
+                        read_int_from_stream(idata, &iter, &frames[cur_frame].width);
+                        read_int_from_stream(idata, &iter, &frames[cur_frame].height);
+                        read_int_from_stream(idata, &iter, &frames[cur_frame].x_offset);
+                        read_int_from_stream(idata, &iter, &frames[cur_frame].y_offset);
+                        read_short_from_stream(idata, &iter, &delay_num);
+                        read_short_from_stream(idata, &iter, &delay_den);
+                        read_char_from_stream(idata, &iter, &frames[cur_frame].dispose_op);
+                        read_char_from_stream(idata, &iter, &frames[cur_frame].blend_op);
 
 			if (delay_num) {
 				if (!delay_den) {
@@ -495,13 +498,13 @@ void display_png_splash_screen(
 			break;
 
 		case CHUNK_FDAT:
-			read_int_from_stream(image_data, &iter, &sequence_number);
+                        read_int_from_stream(idata, &iter, &sequence_number);
 			if (sequence_number != cur_seq_num++) {
 				EMGD_ERROR("Sequence numbers do not match!");
 				return;
 			}
 			for (i=4; i<chunk_size; i++) {
-				input_data[input_iter++] = image_data[iter++];
+                                input_data[input_iter++] = idata[iter++];
 			}
 			break;
 
@@ -530,8 +533,8 @@ void display_png_splash_screen(
 		iter += 4;
 
 		/* Get the next chunk */
-		read_int_from_stream(image_data, &iter, &chunk_size);
-		read_int_from_stream(image_data, &iter, &chunk_type);
+                read_int_from_stream(idata, &iter, &chunk_size);
+                read_int_from_stream(idata, &iter, &chunk_type);
 	}
 
 	if (input_data) {
diff --git a/drivers/gpu/drm/emgd/emgd/drm/splash_screen.h b/drivers/gpu/drm/emgd/emgd/drm/splash_screen.h
index 5fac725..530085a 100644
--- a/drivers/gpu/drm/emgd/emgd/drm/splash_screen.h
+++ b/drivers/gpu/drm/emgd/emgd/drm/splash_screen.h
@@ -213,11 +213,14 @@ void display_splash_screen(
 void display_bmp_splash_screen(
 	igd_framebuffer_info_t *fb_info,
 	unsigned char *fb,
-	emgd_drm_splash_screen_t *ss_data);
+        emgd_drm_splash_screen_t *ss_data,
+        unsigned char *idata);
 void display_png_splash_screen(
 	igd_framebuffer_info_t *fb_info,
 	unsigned char *fb,
-	emgd_drm_splash_screen_t *ss_data);
+        emgd_drm_splash_screen_t *ss_data,
+        unsigned char *idata,
+        size_t image_size);
 void decompress_huffman(
     unsigned char *stream,
     unsigned long *iter,
-- 
1.7.9.7

