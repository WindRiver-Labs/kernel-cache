From 15b238f62edddf96be9093b78cce35d5256a60c8 Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@freescale.com>
Date: Tue, 19 Nov 2013 15:42:32 +0800
Subject: [PATCH 0628/1074] ENGR00288578-4 usb: chipidea: using timer to delay
 decreasing power.usage_count

We need to keep controller as active until the udc or host driver
requests its power.usage_count, otherwise, the system will hang
due to access register at low power mode.

Signed-off-by: Peter Chen <peter.chen@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/usb/chipidea/ci.h   |    3 +++
 drivers/usb/chipidea/core.c |   11 ++++++++++-
 2 files changed, 13 insertions(+), 1 deletions(-)

diff --git a/drivers/usb/chipidea/ci.h b/drivers/usb/chipidea/ci.h
index 163c57b..867bcdf 100644
--- a/drivers/usb/chipidea/ci.h
+++ b/drivers/usb/chipidea/ci.h
@@ -167,6 +167,8 @@ struct hw_bank {
  * @imx28_write_fix: Freescale imx28 needs swp instruction for writing
  * @supports_runtime_pm: if runtime pm is supported
  * @in_lpm: if the core in low power mode
+ * @wakeup_int: if wakeup interrupt occur
+ * @timer: timer to delay clock closing
  */
 struct ci_hdrc {
 	struct device			*dev;
@@ -209,6 +211,7 @@ struct ci_hdrc {
 	bool				supports_runtime_pm;
 	bool				in_lpm;
 	bool				wakeup_int;
+	struct timer_list		timer;
 };
 
 static inline struct ci_role_driver *ci_role(struct ci_hdrc *ci)
diff --git a/drivers/usb/chipidea/core.c b/drivers/usb/chipidea/core.c
index 46ed297..f531c7c 100644
--- a/drivers/usb/chipidea/core.c
+++ b/drivers/usb/chipidea/core.c
@@ -171,6 +171,13 @@ static void hw_wait_phy_stable(void)
 	usleep_range(2000, 2500);
 }
 
+static void delay_runtime_pm_put_timer(unsigned long arg)
+{
+	struct ci_hdrc *ci = (struct ci_hdrc *)arg;
+
+	pm_runtime_put(ci->dev);
+}
+
 /* The PHY enters/leaves low power mode */
 static void ci_hdrc_enter_lpm(struct ci_hdrc *ci, bool enable)
 {
@@ -672,6 +679,8 @@ static int ci_hdrc_probe(struct platform_device *pdev)
 		pm_runtime_enable(&pdev->dev);
 	}
 
+	setup_timer(&ci->timer, delay_runtime_pm_put_timer,
+			(unsigned long)ci);
 	ret = dbg_create_files(ci);
 	if (!ret)
 		return 0;
@@ -752,7 +761,7 @@ static int ci_controller_resume(struct device *dev)
 	if (ci->wakeup_int) {
 		ci->wakeup_int = false;
 		enable_irq(ci->irq);
-		pm_runtime_put(ci->dev);
+		mod_timer(&ci->timer, jiffies + msecs_to_jiffies(2000));
 	}
 
 	return 0;
-- 
1.7.5.4

