From d1c45cf400da76c30b85f5c8151b28face2e6361 Mon Sep 17 00:00:00 2001
From: Fugang Duan <B38611@freescale.com>
Date: Mon, 17 Mar 2014 16:03:06 +0800
Subject: [PATCH 1071/1074] net: fec: fix the error to get the previous BD
 entry

Bug: error to get the previous BD entry. When the current BD
is the first BD, the previous BD entry must be the last BD,
not "bdp - 1" in current logic.

V4:
  * Optimize fec_enet_get_nextdesc() for code clean.
    Replace "ex_new_bd - ring_size" with "ex_base".
    Replace "new_bd - ring_size" with "base".

V3:
  * Restore the API name because David suggest to use fec_enet_
    prefix for all function in fec driver.
    So, change next_bd() -> fec_enet_get_nextdesc()
        change pre_bd()  -> fec_enet_get_prevdesc()
    * Reduce the two APIs parameters for easy to call.

V2:
  * Add tx_ring_size and rx_ring_size to struct fec_enet_private.
  * Replace api fec_enet_get_nextdesc() with next_bd().
    Replace api fec_enet_get_prevdesc() with pre_bd().

  * Move all ring size check logic to next_bd() and pre_bd(), which
    simplifies the code redundancy.

V1:
  * Add BD ring size check to get the previous BD entry in correctly.

Reviewed-by: Li Frank <B20596@freescale.com>
Signed-off-by: Fugang Duan  <B38611@freescale.com>
Acked-by: Frank Li <frank.li@freescale.net>
Signed-off-by: David S. Miller <davem@davemloft.net>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git,
fix context to apply to WRL kernel.]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/net/ethernet/freescale/fec.h      |    4 +-
 drivers/net/ethernet/freescale/fec_main.c |   73 +++++++++++++----------------
 drivers/net/ethernet/freescale/fec_ptp.c  |   16 +------
 3 files changed, 35 insertions(+), 58 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fec.h b/drivers/net/ethernet/freescale/fec.h
index 22d9e10..896b688 100644
--- a/drivers/net/ethernet/freescale/fec.h
+++ b/drivers/net/ethernet/freescale/fec.h
@@ -646,8 +646,6 @@ void fec_ptp_store_txstamp(struct fec_enet_private *priv,
 void fec_ptp_store_rxstamp(struct fec_enet_private *priv,
 				struct sk_buff *skb,
 				struct bufdesc *bdp);
-int fec_ptp_set(struct net_device *ndev, struct ifreq *ifr);
-int fec_ptp_get(struct net_device *ndev, struct ifreq *ifr);
-
+int fec_ptp_ioctl(struct net_device *ndev, struct ifreq *ifr, int cmd);
 /****************************************************************************/
 #endif /* FEC_H */
diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c
index 4e37c33..2680d1c 100644
--- a/drivers/net/ethernet/freescale/fec_main.c
+++ b/drivers/net/ethernet/freescale/fec_main.c
@@ -207,22 +207,24 @@ MODULE_PARM_DESC(macaddr, "FEC Ethernet MAC address");
 static int mii_cnt;
 
 static inline
-struct bufdesc *fec_enet_get_nextdesc(struct bufdesc *bdp, struct fec_enet_private *fep)
+struct bufdesc *fec_enet_get_nextdesc(struct bufdesc *bdp, struct fec_enet_private *fep, int queue_id)
 {
 	struct bufdesc *new_bd = bdp + 1;
 	struct bufdesc_ex *ex_new_bd = (struct bufdesc_ex *)bdp + 1;
+	struct fec_enet_priv_tx_q *tx_queue = fep->tx_queue[queue_id];
+        struct fec_enet_priv_rx_q *rx_queue = fep->rx_queue[queue_id];
 	struct bufdesc_ex *ex_base;
 	struct bufdesc *base;
 	int ring_size;
 
-	if (bdp >= fep->tx_bd_base) {
-		base = fep->tx_bd_base;
-		ring_size = fep->tx_ring_size;
-		ex_base = (struct bufdesc_ex *)fep->tx_bd_base;
+	if (bdp >= tx_queue->tx_bd_base) {
+		base = tx_queue->tx_bd_base;
+		ring_size = tx_queue->tx_ring_size;
+		ex_base = (struct bufdesc_ex *)tx_queue->tx_bd_base;
 	} else {
-		base = fep->rx_bd_base;
-		ring_size = fep->rx_ring_size;
-		ex_base = (struct bufdesc_ex *)fep->rx_bd_base;
+		base = rx_queue->rx_bd_base;
+		ring_size = rx_queue->rx_ring_size;
+		ex_base = (struct bufdesc_ex *)rx_queue->rx_bd_base;
 	}
 
 	if (fep->bufdesc_ex)
@@ -234,22 +236,24 @@ struct bufdesc *fec_enet_get_nextdesc(struct bufdesc *bdp, struct fec_enet_priva
 }
 
 static inline
-struct bufdesc *fec_enet_get_prevdesc(struct bufdesc *bdp, struct fec_enet_private *fep)
+struct bufdesc *fec_enet_get_prevdesc(struct bufdesc *bdp, struct fec_enet_private *fep, int queue_id)
 {
 	struct bufdesc *new_bd = bdp - 1;
 	struct bufdesc_ex *ex_new_bd = (struct bufdesc_ex *)bdp - 1;
+	struct fec_enet_priv_tx_q *tx_queue = fep->tx_queue[queue_id];
+	struct fec_enet_priv_rx_q *rx_queue = fep->rx_queue[queue_id];
 	struct bufdesc_ex *ex_base;
 	struct bufdesc *base;
 	int ring_size;
 
-	if (bdp >= fep->tx_bd_base) {
-		base = fep->tx_bd_base;
-		ring_size = fep->tx_ring_size;
-		ex_base = (struct bufdesc_ex *)fep->tx_bd_base;
+	if (bdp >= tx_queue->tx_bd_base) {
+		base = tx_queue->tx_bd_base;
+		ring_size = tx_queue->tx_ring_size;
+		ex_base = (struct bufdesc_ex *)tx_queue->tx_bd_base;
 	} else {
-		base = fep->rx_bd_base;
-		ring_size = fep->rx_ring_size;
-		ex_base = (struct bufdesc_ex *)fep->rx_bd_base;
+		base = rx_queue->rx_bd_base;
+		ring_size = rx_queue->rx_ring_size;
+		ex_base = (struct bufdesc_ex *)rx_queue->rx_bd_base;
 	}
 
 	if (fep->bufdesc_ex)
@@ -473,7 +477,6 @@ static int fec_enet_txq_submit_skb(struct fec_enet_priv_tx_q *txq,
 	bdp->cbd_bufaddr = dma_map_single(&fep->pdev->dev, bufaddr,
 					buflen, DMA_TO_DEVICE);
 	if (dma_mapping_error(&fep->pdev->dev, bdp->cbd_bufaddr)) {
-		fep->tx_skbuff[index] = NULL;
 		dev_kfree_skb_any(skb);
 		if (net_ratelimit())
 			netdev_err(ndev, "Tx DMA memory map failed\n");
@@ -804,11 +807,11 @@ static void fec_enet_bd_init(struct net_device *dev)
 				bdp->cbd_sc = BD_ENET_RX_EMPTY;
 			else
 				bdp->cbd_sc = 0;
-			bdp = fec_enet_get_nextdesc(bdp, fep->bufdesc_ex);
+			bdp = fec_enet_get_nextdesc(bdp, fep, i);
 		}
 
 		/* Set the last buffer to wrap */
-		bdp = fec_enet_get_prevdesc(bdp, fep->bufdesc_ex);
+		bdp = fec_enet_get_prevdesc(bdp, fep, i);
 		bdp->cbd_sc |= BD_SC_WRAP;
 
 		rx_queue->cur_rx = rx_queue->rx_bd_base;
@@ -829,11 +832,11 @@ static void fec_enet_bd_init(struct net_device *dev)
 				tx_queue->tx_skbuff[i] = NULL;
 			}
 			bdp->cbd_bufaddr = 0;
-			bdp = fec_enet_get_nextdesc(bdp, fep);
+			bdp = fec_enet_get_nextdesc(bdp, fep, i);
 		}
 
 		/* Set the last buffer to wrap */
-		bdp = fec_enet_get_prevdesc(bdp, fep);
+		bdp = fec_enet_get_prevdesc(bdp, fep, i);
 		bdp->cbd_sc |= BD_SC_WRAP;
 		tx_queue->dirty_tx = bdp;
 	}
@@ -1197,10 +1200,7 @@ fec_enet_tx(struct net_device *ndev)
 		bdp = txq->dirty_tx;
 
 		/* get next bdp of dirty_tx */
-		if (bdp->cbd_sc & BD_ENET_TX_WRAP)
-			bdp = txq->tx_bd_base;
- 		else
-			bdp = fec_enet_get_nextdesc(bdp, fep->bufdesc_ex);
+		bdp = fec_enet_get_nextdesc(bdp, fep, queue_id);
 
 		while (((status = bdp->cbd_sc) & BD_ENET_TX_READY) == 0) {
 
@@ -1272,10 +1272,7 @@ fec_enet_tx(struct net_device *ndev)
 			txq->dirty_tx = bdp;
  
 			/* Update pointer to next buffer descriptor to be transmitted */
-			if (status & BD_ENET_TX_WRAP)
-				bdp = txq->tx_bd_base;
-			else
-				bdp = fec_enet_get_nextdesc(bdp, fep->bufdesc_ex);
+			bdp = fec_enet_get_nextdesc(bdp, fep, queue_id);
 
 			/* Since we have freed up a buffer, the ring is no longer full
 			 */
@@ -2324,12 +2321,8 @@ static int fec_enet_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)
 	if (!phydev)
 		return -ENODEV;
 
-	if (fep->bufdesc_ex) {
-		if (cmd == SIOCSHWTSTAMP)
-			return fec_ptp_set(ndev, rq);
-		if (cmd == SIOCGHWTSTAMP)
-			return fec_ptp_get(ndev, rq);
-	}
+	if (cmd == SIOCSHWTSTAMP && fep->bufdesc_ex)
+		return fec_ptp_ioctl(ndev, rq, cmd);
 
 	return phy_mii_ioctl(phydev, rq, cmd);
 }
@@ -2356,7 +2349,7 @@ static void fec_enet_free_buffers(struct net_device *ndev)
 						DMA_FROM_DEVICE);
 			if (skb)
 				dev_kfree_skb(skb);
-			bdp = fec_enet_get_nextdesc(bdp, fep->bufdesc_ex);
+			bdp = fec_enet_get_nextdesc(bdp, fep, j);
 		}
 	}
 
@@ -2400,11 +2393,11 @@ static int fec_enet_alloc_buffers(struct net_device *ndev)
 				ebdp->cbd_esc = BD_ENET_RX_INT;
 			}
 
-			bdp = fec_enet_get_nextdesc(bdp, fep->bufdesc_ex);
+			bdp = fec_enet_get_nextdesc(bdp, fep, j);
 		}
 
 		/* Set the last buffer to wrap. */
-		bdp = fec_enet_get_prevdesc(bdp, fep->bufdesc_ex);
+		bdp = fec_enet_get_prevdesc(bdp, fep, j);
 		bdp->cbd_sc |= BD_SC_WRAP;
 	}
 
@@ -2430,11 +2423,11 @@ static int fec_enet_alloc_buffers(struct net_device *ndev)
 				ebdp->cbd_esc = BD_ENET_TX_INT;
 			}
 
-			bdp = fec_enet_get_nextdesc(bdp, fep);
+			bdp = fec_enet_get_nextdesc(bdp, fep, j);
 		}
 
 		/* Set the last buffer to wrap. */
-		bdp = fec_enet_get_prevdesc(bdp, fep);
+		bdp = fec_enet_get_prevdesc(bdp, fep, j);
 		bdp->cbd_sc |= BD_SC_WRAP;
 	}
 
diff --git a/drivers/net/ethernet/freescale/fec_ptp.c b/drivers/net/ethernet/freescale/fec_ptp.c
index 0e0ba20..f13a89e 100644
--- a/drivers/net/ethernet/freescale/fec_ptp.c
+++ b/drivers/net/ethernet/freescale/fec_ptp.c
@@ -745,7 +745,7 @@ static int fec_ptp_enable(struct ptp_clock_info *ptp,
  * @ifreq: ioctl data
  * @cmd: particular ioctl requested
  */
-int fec_ptp_set(struct net_device *ndev, struct ifreq *ifr)
+int fec_ptp_ioctl(struct net_device *ndev, struct ifreq *ifr, int cmd)
 {
 	struct fec_enet_private *fep = netdev_priv(ndev);
 	struct hwtstamp_config config;
@@ -889,20 +889,6 @@ int fec_ptp_set(struct net_device *ndev, struct ifreq *ifr)
 	return retval;
 }
 
-int fec_ptp_get(struct net_device *ndev, struct ifreq *ifr)
-{
-	struct fec_enet_private *fep = netdev_priv(ndev);
-	struct hwtstamp_config config;
-
-	config.flags = 0;
-	config.tx_type = fep->hwts_tx_en ? HWTSTAMP_TX_ON : HWTSTAMP_TX_OFF;
-	config.rx_filter = (fep->hwts_rx_en ?
-			    HWTSTAMP_FILTER_ALL : HWTSTAMP_FILTER_NONE);
-
-	return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?
-		-EFAULT : 0;
-}
-
 /**
  * fec_time_keep - call timecounter_read every second to avoid timer overrun
  *                 because ENET just support 32bit counter, will timeout in 4s
-- 
1.7.5.4

