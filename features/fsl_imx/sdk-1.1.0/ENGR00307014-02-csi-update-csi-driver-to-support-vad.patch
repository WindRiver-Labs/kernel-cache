From 143227f477a5a14606b72b167649de01ffcf75da Mon Sep 17 00:00:00 2001
From: Sandor Yu <R01008@freescale.com>
Date: Fri, 4 Apr 2014 13:37:32 +0800
Subject: [PATCH 0804/1074] ENGR00307014-02 csi: update csi driver to support
 vadc

-Add csi control register 18 define.
-Add csi_tvdec_enable and csi_deinterlace_mode for vadc.
-Add csi_set_32bit_imagpara function to support YUV444 format.

Signed-off-by: Sandor Yu <R01008@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/media/platform/mxc/capture/fsl_csi.c |   83 ++++++++++++++++++++++---
 drivers/media/platform/mxc/capture/fsl_csi.h |   15 ++++-
 2 files changed, 86 insertions(+), 12 deletions(-)

diff --git a/drivers/media/platform/mxc/capture/fsl_csi.c b/drivers/media/platform/mxc/capture/fsl_csi.c
index 0a17706..2839e9f 100644
--- a/drivers/media/platform/mxc/capture/fsl_csi.c
+++ b/drivers/media/platform/mxc/capture/fsl_csi.c
@@ -126,9 +126,7 @@ void csi_init_interface(void)
 	val |= BIT_REDGE;
 	val |= BIT_GCLK_MODE;
 	val |= BIT_HSYNC_POL;
-	val |= BIT_PACK_DIR;
 	val |= BIT_FCC;
-	val |= BIT_SWAP16_EN;
 	val |= 1 << SHIFT_MCLKDIV;
 	val |= BIT_MCLKEN;
 	__raw_writel(val, CSI_CSICR1);
@@ -142,23 +140,22 @@ void csi_init_interface(void)
 }
 EXPORT_SYMBOL(csi_init_interface);
 
-void csi_init_format(int fmt)
+void csi_format_swap16(bool enable)
 {
 	unsigned int val;
 
 	val = __raw_readl(CSI_CSICR1);
-	if (fmt == V4L2_PIX_FMT_YUYV) {
-		val &= ~BIT_PACK_DIR;
-		val &= ~BIT_SWAP16_EN;
-	} else if (fmt == V4L2_PIX_FMT_UYVY) {
+	if (enable) {
 		val |= BIT_PACK_DIR;
 		val |= BIT_SWAP16_EN;
-	} else
-		pr_warning("unsupported format, old format remains.\n");
+	} else {
+		val &= ~BIT_PACK_DIR;
+		val &= ~BIT_SWAP16_EN;
+	}
 
 	__raw_writel(val, CSI_CSICR1);
 }
-EXPORT_SYMBOL(csi_init_format);
+EXPORT_SYMBOL(csi_format_swap16);
 
 /*!
  * csi_read_mclk_flag
@@ -226,6 +223,72 @@ void csi_enable(int arg)
 }
 EXPORT_SYMBOL(csi_enable);
 
+void csi_buf_stride_set(u32 stride)
+{
+	__raw_writel(stride, CSI_CSIFBUF_PARA);
+}
+EXPORT_SYMBOL(csi_buf_stride_set);
+
+void csi_deinterlace_enable(bool enable)
+{
+	unsigned long cr18 = __raw_readl(CSI_CSICR18);
+
+	if (enable == true)
+		cr18 |= BIT_DEINTERLACE_EN;
+	else
+		cr18 &= ~BIT_DEINTERLACE_EN;
+
+	__raw_writel(cr18, CSI_CSICR18);
+}
+EXPORT_SYMBOL(csi_deinterlace_enable);
+
+void csi_deinterlace_mode(int mode)
+{
+	unsigned long cr18 = __raw_readl(CSI_CSICR18);
+
+	if (mode == V4L2_STD_NTSC)
+		cr18 |= BIT_NTSC_EN;
+	else
+		cr18 &= ~BIT_NTSC_EN;
+
+	__raw_writel(cr18, CSI_CSICR18);
+}
+EXPORT_SYMBOL(csi_deinterlace_mode);
+
+void csi_tvdec_enable(bool enable)
+{
+	unsigned long cr18 = __raw_readl(CSI_CSICR18);
+	unsigned long cr1 = __raw_readl(CSI_CSICR1);
+
+	if (enable == true) {
+		cr18 |= (BIT_TVDECODER_IN_EN | BIT_BASEADDR_SWITCH_EN);
+		cr1 |= BIT_CCIR_MODE | BIT_EXT_VSYNC;
+		cr1 &= ~(BIT_SOF_POL | BIT_REDGE);
+	} else {
+		cr18 &= ~(BIT_TVDECODER_IN_EN | BIT_BASEADDR_SWITCH_EN);
+		cr1 &= ~(BIT_CCIR_MODE | BIT_EXT_VSYNC);
+		cr1 |= BIT_SOF_POL | BIT_REDGE;
+	}
+
+	__raw_writel(cr18, CSI_CSICR18);
+	__raw_writel(cr1, CSI_CSICR1);
+}
+EXPORT_SYMBOL(csi_tvdec_enable);
+
+void csi_set_32bit_imagpara(int width, int height)
+{
+	int imag_para = 0;
+	unsigned long cr3 = __raw_readl(CSI_CSICR3);
+
+	imag_para = (width << 16) | height;
+	__raw_writel(imag_para, CSI_CSIIMAG_PARA);
+
+
+	/* reflash the embeded DMA controller */
+	__raw_writel(cr3 | BIT_DMA_REFLASH_RFF, CSI_CSICR3);
+}
+EXPORT_SYMBOL(csi_set_32bit_imagpara);
+
 void csi_set_16bit_imagpara(int width, int height)
 {
 	int imag_para = 0;
diff --git a/drivers/media/platform/mxc/capture/fsl_csi.h b/drivers/media/platform/mxc/capture/fsl_csi.h
index d9d179b..78b393e 100644
--- a/drivers/media/platform/mxc/capture/fsl_csi.h
+++ b/drivers/media/platform/mxc/capture/fsl_csi.h
@@ -96,7 +96,13 @@
 #define BIT_DRDY		(0x1 << 0)
 
 /* csi control reg 18 */
-#define BIT_CSI_ENABLE		(0x1 << 31)
+#define BIT_CSI_ENABLE			(0x1 << 31)
+#define BIT_BASEADDR_SWITCH_SEL	(0x1 << 5)
+#define BIT_BASEADDR_SWITCH_EN	(0x1 << 4)
+#define BIT_PARALLEL24_EN		(0x1 << 3)
+#define BIT_DEINTERLACE_EN		(0x1 << 2)
+#define BIT_TVDECODER_IN_EN		(0x1 << 1)
+#define BIT_NTSC_EN				(0x1 << 0)
 
 #define CSI_MCLK_VF		1
 #define CSI_MCLK_ENC		2
@@ -190,13 +196,18 @@ struct csi_config_t {
 typedef void (*csi_irq_callback_t) (void *data, unsigned long status);
 
 void csi_init_interface(void);
-void csi_init_format(int fmt);
+void csi_set_32bit_imagpara(int width, int height);
 void csi_set_16bit_imagpara(int width, int height);
 void csi_set_12bit_imagpara(int width, int height);
+void csi_format_swap16(bool enable);
 int csi_read_mclk_flag(void);
 void csi_start_callback(void *data);
 void csi_stop_callback(void *data);
 void csi_enable_int(int arg);
+void csi_buf_stride_set(u32 stride);
+void csi_deinterlace_mode(int mode);
+void csi_deinterlace_enable(bool enable);
+void csi_tvdec_enable(bool enable);
 void csi_enable(int arg);
 void csi_disable_int(void);
 void csi_clk_enable(void);
-- 
1.7.5.4

