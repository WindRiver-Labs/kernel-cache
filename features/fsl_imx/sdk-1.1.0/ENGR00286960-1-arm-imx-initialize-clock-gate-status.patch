From 92c8758d74a4b8b4f35060b90fa6cc3ffa7754ed Mon Sep 17 00:00:00 2001
From: Anson Huang <b20788@freescale.com>
Date: Fri, 8 Nov 2013 14:54:31 -0500
Subject: [PATCH 0234/1074] ENGR00286960-1 arm: imx: initialize clock gate
 status

Some clocks gates need to be set to 2b'01 to allow CCM
auto disabling them when system enters WAIT mode, this
setting can save many runtime power. These clock gates
are normally always enabled, so no need to add another
status for clk gate enable function, just set them to
right status when system boot up is good enough.

Signed-off-by: Anson Huang <b20788@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 arch/arm/mach-imx/clk-imx6q.c  |   27 +++++++++++++++++++++++++++
 arch/arm/mach-imx/clk-imx6sl.c |   21 +++++++++++++++++++++
 2 files changed, 48 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-imx/clk-imx6q.c b/arch/arm/mach-imx/clk-imx6q.c
index 5d53dad..5dd885b 100644
--- a/arch/arm/mach-imx/clk-imx6q.c
+++ b/arch/arm/mach-imx/clk-imx6q.c
@@ -24,6 +24,8 @@
 #include "common.h"
 #include "hardware.h"
 
+#define CCM_CCGR_OFFSET(index)	(index * 2)
+
 static const char *step_sels[]	= { "osc", "pll2_pfd2_396m", };
 static const char *pll1_sw_sels[]	= { "pll1_sys", "step", };
 static const char *periph_pre_sels[]	= { "pll2_bus", "pll2_pfd2_396m", "pll2_pfd0_352m", "pll2_198m", };
@@ -445,6 +447,31 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 			pr_err("i.MX6q clk %d: register failed with %ld\n",
 				i, PTR_ERR(clk[i]));
 
+	/* Initialize clock gate status */
+	writel_relaxed(1 << CCM_CCGR_OFFSET(11) |
+		3 << CCM_CCGR_OFFSET(1) |
+		3 << CCM_CCGR_OFFSET(0), base + 0x68);
+	if (cpu_is_imx6q() && imx_get_soc_revision() == IMX_CHIP_REVISION_1_0)
+		writel_relaxed(3 << CCM_CCGR_OFFSET(11) |
+			3 << CCM_CCGR_OFFSET(10), base + 0x6c);
+	else
+		writel_relaxed(3 << CCM_CCGR_OFFSET(10), base + 0x6c);
+	writel_relaxed(1 << CCM_CCGR_OFFSET(12) |
+		3 << CCM_CCGR_OFFSET(11) |
+		3 << CCM_CCGR_OFFSET(10) |
+		3 << CCM_CCGR_OFFSET(9) |
+		3 << CCM_CCGR_OFFSET(8), base + 0x70);
+	writel_relaxed(3 << CCM_CCGR_OFFSET(14) |
+		1 << CCM_CCGR_OFFSET(13) |
+		3 << CCM_CCGR_OFFSET(12) |
+		1 << CCM_CCGR_OFFSET(11) |
+		3 << CCM_CCGR_OFFSET(10), base + 0x74);
+	writel_relaxed(3 << CCM_CCGR_OFFSET(7) |
+		3 << CCM_CCGR_OFFSET(6) |
+		3 << CCM_CCGR_OFFSET(4), base + 0x78);
+	writel_relaxed(1 << CCM_CCGR_OFFSET(0), base + 0x7c);
+	writel_relaxed(0, base + 0x80);
+
 	clk_data.clks = clk;
 	clk_data.clk_num = ARRAY_SIZE(clk);
 	of_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);
diff --git a/arch/arm/mach-imx/clk-imx6sl.c b/arch/arm/mach-imx/clk-imx6sl.c
index b05ec41..a57cf83 100644
--- a/arch/arm/mach-imx/clk-imx6sl.c
+++ b/arch/arm/mach-imx/clk-imx6sl.c
@@ -7,6 +7,8 @@
  *
  */
 
+#define CCM_CCGR_OFFSET(index)  (index * 2)
+
 #include <linux/clk.h>
 #include <linux/clkdev.h>
 #include <linux/err.h>
@@ -279,6 +281,25 @@ static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 			pr_err("i.MX6SL clk %d: register failed with %ld\n",
 				i, PTR_ERR(clks[i]));
 
+	/* Initialize clock gate status */
+	writel_relaxed(1 << CCM_CCGR_OFFSET(11) |
+		3 << CCM_CCGR_OFFSET(1) |
+		3 << CCM_CCGR_OFFSET(0), base + 0x68);
+	writel_relaxed(3 << CCM_CCGR_OFFSET(10), base + 0x6c);
+	writel_relaxed(1 << CCM_CCGR_OFFSET(11) |
+		3 << CCM_CCGR_OFFSET(10) |
+		3 << CCM_CCGR_OFFSET(9) |
+		3 << CCM_CCGR_OFFSET(8), base + 0x70);
+	writel_relaxed(3 << CCM_CCGR_OFFSET(14) |
+		3 << CCM_CCGR_OFFSET(13) |
+		3 << CCM_CCGR_OFFSET(12) |
+		3 << CCM_CCGR_OFFSET(11) |
+		3 << CCM_CCGR_OFFSET(10), base + 0x74);
+	writel_relaxed(3 << CCM_CCGR_OFFSET(7) |
+		3 << CCM_CCGR_OFFSET(4), base + 0x78);
+	writel_relaxed(1 << CCM_CCGR_OFFSET(0), base + 0x7c);
+	writel_relaxed(0, base + 0x80);
+
 	clk_data.clks = clks;
 	clk_data.clk_num = ARRAY_SIZE(clks);
 	of_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);
-- 
1.7.5.4

