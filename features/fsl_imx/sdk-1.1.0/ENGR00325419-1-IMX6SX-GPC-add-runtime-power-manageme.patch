From 446113aabbedb9f73f7cf505c4cf708e7bb500a1 Mon Sep 17 00:00:00 2001
From: Fancy Fang <chen.fang@freescale.com>
Date: Thu, 16 Oct 2014 15:21:53 +0800
Subject: [PATCH 0494/1074] ENGR00325419-1 IMX6SX/GPC: add runtime power
 management for display mix

Add a dummy regulator for display power domain. Use the regulator
framework to share the display mix between different modules which
are attached to display mix.

Signed-off-by: Fancy Fang <chen.fang@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 arch/arm/boot/dts/imx6sx-sdb.dts |    2 +
 arch/arm/boot/dts/imx6sx.dtsi    |    5 ++
 arch/arm/mach-imx/gpc.c          |   85 +++++++++++++++++++++++++++++++++++++-
 3 files changed, 91 insertions(+), 1 deletions(-)

diff --git a/arch/arm/boot/dts/imx6sx-sdb.dts b/arch/arm/boot/dts/imx6sx-sdb.dts
index 60fffbb..ff8903a 100644
--- a/arch/arm/boot/dts/imx6sx-sdb.dts
+++ b/arch/arm/boot/dts/imx6sx-sdb.dts
@@ -507,6 +507,7 @@
 	pinctrl-0 = <&pinctrl_lcdif_dat_0
 		     &pinctrl_lcdif_ctrl_0>;
 	lcd-supply = <&reg_lcd_3v3>;
+	disp-supply = <&disp_dummy>;
 	display = <&display0>;
 	status = "disabled";
 
@@ -537,6 +538,7 @@
 
 &lcdif2 {
 	display = <&display1>;
+	disp-supply = <&disp_dummy>;
 	disp-dev = "ldb";
 	status = "okay";
 
diff --git a/arch/arm/boot/dts/imx6sx.dtsi b/arch/arm/boot/dts/imx6sx.dtsi
index dc00eee..5d37cf9 100644
--- a/arch/arm/boot/dts/imx6sx.dtsi
+++ b/arch/arm/boot/dts/imx6sx.dtsi
@@ -181,6 +181,10 @@
 			status = "disabled";
 		};
 
+		disp_dummy: disp-regulator {
+			compatible = "fsl,imx6-display-regulator"; /* for display power domain */
+		};
+
 		aips-bus@02000000 { /* AIPS1 */
 			compatible = "fsl,aips-bus", "simple-bus";
 			#address-cells = <1>;
@@ -919,6 +923,7 @@
 					clocks = <&clks IMX6SX_CLK_PXP_AXI>,
 						<&clks IMX6SX_CLK_DISPLAY_AXI>;
 					clock-names = "pxp-axi", "disp-axi";
+					disp-supply = <&disp_dummy>;
 					status = "disabled";
 				};
 
diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 3ec2398..f19a35c 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -67,7 +67,7 @@ static struct device *gpc_dev;
 static struct regulator *pu_reg;
 static struct notifier_block nb;
 static struct notifier_block nb_pcie;
-static struct regulator_dev *pu_dummy_regulator_rdev;
+static struct regulator_dev *pu_dummy_regulator_rdev, *disp_regulator_rdev;
 static struct regulator_init_data pu_dummy_initdata = {
 	.constraints = {
 		.max_uV = 1450000,	/* allign with real max of anatop */
@@ -75,7 +75,16 @@ static struct regulator_init_data pu_dummy_initdata = {
 				REGULATOR_CHANGE_VOLTAGE,
 	},
 };
+static struct regulator_init_data dispreg_initdata = {
+	.constraints = {
+		.max_uV = 0, /* anyvalue */
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS |
+				REGULATOR_CHANGE_VOLTAGE,
+	},
+};
+
 static int pu_dummy_enable;
+static int dispreg_enable;
 
 static void imx_disp_clk(bool enable)
 {
@@ -541,6 +550,74 @@ static struct platform_driver pu_dummy_driver = {
 	},
 };
 
+static int imx_dispreg_enable(struct regulator_dev *rdev)
+{
+	imx_gpc_dispmix_on();
+	dispreg_enable = 1;
+
+	return 0;
+}
+
+static int imx_dispreg_disable(struct regulator_dev *rdev)
+{
+	imx_gpc_dispmix_off();
+	dispreg_enable = 0;
+
+	return 0;
+}
+
+static int imx_dispreg_is_enable(struct regulator_dev *rdev)
+{
+	return dispreg_enable;
+}
+
+static struct regulator_ops dispreg_ops = {
+	.enable = imx_dispreg_enable,
+	.disable = imx_dispreg_disable,
+	.is_enabled = imx_dispreg_is_enable,
+};
+
+static struct regulator_desc dispreg_desc = {
+	.name = "disp-regulator",
+	.id = -1,
+	.type = REGULATOR_VOLTAGE,
+	.owner = THIS_MODULE,
+	.ops = &dispreg_ops,
+};
+
+static int dispreg_probe(struct platform_device *pdev)
+{
+	struct regulator_config config = {};
+	int ret = 0;
+
+	config.dev = &pdev->dev;
+	config.init_data = &dispreg_initdata;
+	config.of_node = pdev->dev.of_node;
+
+	disp_regulator_rdev = regulator_register(&dispreg_desc, &config);
+	if (IS_ERR(disp_regulator_rdev)) {
+		ret = PTR_ERR(disp_regulator_rdev);
+		dev_err(&pdev->dev, "Failed to register regulator: %d\n", ret);
+	}
+
+	return ret;
+}
+
+static const struct of_device_id imx_dispreg_ids[] = {
+	{ .compatible = "fsl,imx6-display-regulator" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, imx_dispreg_ids);
+
+static struct platform_driver dispreg_driver = {
+	.probe  = dispreg_probe,
+	.driver = {
+		.name   = "disp-regulator",
+		.owner  = THIS_MODULE,
+		.of_match_table = imx_dispreg_ids,
+	},
+};
+
 static int imx_gpc_probe(struct platform_device *pdev)
 {
 	int ret;
@@ -658,6 +735,12 @@ static int __init imx6_pudummy_init(void)
 }
 fs_initcall(imx6_pudummy_init);
 
+static int __init imx6_dispreg_init(void)
+{
+	return platform_driver_probe(&dispreg_driver, dispreg_probe);
+}
+fs_initcall(imx6_dispreg_init);
+
 MODULE_AUTHOR("Anson Huang <b20788@freescale.com>");
 MODULE_DESCRIPTION("Freescale i.MX GPC driver");
 MODULE_LICENSE("GPL");
-- 
1.7.5.4

