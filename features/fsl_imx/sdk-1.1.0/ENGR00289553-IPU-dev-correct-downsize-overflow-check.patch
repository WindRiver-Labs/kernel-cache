From 1cb45f9cdeaf708271bddd7f4f2aa6541ba670c1 Mon Sep 17 00:00:00 2001
From: Liu Ying <Ying.Liu@freescale.com>
Date: Mon, 25 Nov 2013 18:34:40 +0800
Subject: [PATCH 0640/1074] ENGR00289553 IPU dev:correct downsize overflow
 check in rot case

In rotation cases, the width and height of IPUv3 IC scaling block's
output should align with the width and height of IPUv3 IC rotation
block. And, users only tell the IPUv3 device driver about the parameters
of scaling block's input and rotation block's output. So, we need to
swap the width and height of rotation block in cache before we do
downsize(a functionality of the scaling block) overflow check.

This patch fixes the issue which can be reproduced by this unit test case:
/unit_tests/mxc_v4l2_output.out -iw 128 -ih 128 -ow 176 -oh 10 -r 90

Signed-off-by: Liu Ying <Ying.Liu@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/mxc/ipu3/ipu_device.c |   29 ++++++++++++++++++++++-------
 1 files changed, 22 insertions(+), 7 deletions(-)

diff --git a/drivers/mxc/ipu3/ipu_device.c b/drivers/mxc/ipu3/ipu_device.c
index b5d92dd..bdd1d70 100644
--- a/drivers/mxc/ipu3/ipu_device.c
+++ b/drivers/mxc/ipu3/ipu_device.c
@@ -943,6 +943,7 @@ static int check_task(struct ipu_task_entry *t)
 	int ret = IPU_CHECK_OK;
 	int timeout;
 	bool vdi_split = false;
+	int ocw, och;
 
 	if ((IPU_PIX_FMT_TILED_NV12 == t->overlay.format) ||
 		(IPU_PIX_FMT_TILED_NV12F == t->overlay.format) ||
@@ -979,12 +980,25 @@ static int check_task(struct ipu_task_entry *t)
 				&t->set.o_off, &t->set.o_uoff,
 				&t->set.o_voff, &t->set.ostride);
 
-	if (t->output.crop.w * 8 <= t->input.crop.w) {
+	if (t->output.rotate >= IPU_ROTATE_90_RIGHT) {
+		/*
+		 * Cache output width and height and
+		 * swap them so that we may check
+		 * downsize overflow correctly.
+		 */
+		ocw = t->output.crop.h;
+		och = t->output.crop.w;
+	} else {
+		ocw = t->output.crop.w;
+		och = t->output.crop.h;
+	}
+
+	if (ocw * 8 <= t->input.crop.w) {
 		ret = IPU_CHECK_ERR_W_DOWNSIZE_OVER;
 		goto done;
 	}
 
-	if (t->output.crop.h * 8 <= t->input.crop.h) {
+	if (och * 8 <= t->input.crop.h) {
 		ret = IPU_CHECK_ERR_H_DOWNSIZE_OVER;
 		goto done;
 	}
@@ -1019,14 +1033,15 @@ static int check_task(struct ipu_task_entry *t)
 			ret = IPU_CHECK_ERR_OVERLAY_CROP;
 			goto done;
 		} else {
-			int ow = t->output.crop.w;
-			int oh = t->output.crop.h;
+			ocw = t->output.crop.w;
+			och = t->output.crop.h;
 
 			if (t->output.rotate >= IPU_ROTATE_90_RIGHT) {
-				ow = t->output.crop.h;
-				oh = t->output.crop.w;
+				ocw = t->output.crop.h;
+				och = t->output.crop.w;
 			}
-			if ((t->overlay.crop.w != ow) || (t->overlay.crop.h != oh)) {
+			if ((t->overlay.crop.w != ocw) ||
+			    (t->overlay.crop.h != och)) {
 				ret = IPU_CHECK_ERR_OV_OUT_NO_FIT;
 				goto done;
 			}
-- 
1.7.5.4

