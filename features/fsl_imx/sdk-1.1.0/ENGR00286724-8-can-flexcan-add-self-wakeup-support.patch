From cf303094cc0fc52d9c49d606bb6f70f17e5484fc Mon Sep 17 00:00:00 2001
From: Dong Aisheng <b29396@freescale.com>
Date: Wed, 6 Nov 2013 19:10:28 +0800
Subject: [PATCH 1002/1074] ENGR00286724-8 can: flexcan: add self wakeup
 support

If wakeup is enabled, enter stop mode, else enter disabled mode.
Self wake can only work on stop mode.
For imx6q, the stop request has to be mannually assert on
IOMUX GPR13[28:29] register, we use syscon to control that bit.

Signed-off-by: Dong Aisheng <b29396@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/net/can/flexcan.c |   86 ++++++++++++++++++++++++++++++++++++++++----
 1 files changed, 78 insertions(+), 8 deletions(-)

diff --git a/drivers/net/can/flexcan.c b/drivers/net/can/flexcan.c
index 9250e28..1b0ad49 100644
--- a/drivers/net/can/flexcan.c
+++ b/drivers/net/can/flexcan.c
@@ -32,11 +32,14 @@
 #include <linux/io.h>
 #include <linux/kernel.h>
 #include <linux/list.h>
+#include <linux/mfd/syscon.h>
+#include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/regulator/consumer.h>
+#include <linux/regmap.h>
 
 #define DRV_NAME			"flexcan"
 
@@ -122,7 +125,8 @@
 	(FLEXCAN_ESR_ERR_BUS | FLEXCAN_ESR_ERR_STATE)
 #define FLEXCAN_ESR_ALL_INT \
 	(FLEXCAN_ESR_TWRN_INT | FLEXCAN_ESR_RWRN_INT | \
-	 FLEXCAN_ESR_BOFF_INT | FLEXCAN_ESR_ERR_INT)
+	 FLEXCAN_ESR_BOFF_INT | FLEXCAN_ESR_ERR_INT) | \
+	 FLEXCAN_ESR_WAK_INT)
 
 /* FLEXCAN interrupt flag register (IFLAG) bits */
 #define FLEXCAN_RESERVED_BUF_ID		8
@@ -216,6 +220,8 @@ struct flexcan_priv {
 	struct flexcan_platform_data *pdata;
 	const struct flexcan_devtype_data *devtype_data;
 	struct regulator *reg_xceiver;
+	struct regmap *gpr;
+	int id;
 };
 
 static struct flexcan_devtype_data fsl_p1010_devtype_data = {
@@ -266,6 +272,32 @@ static inline void flexcan_write(u32 val, void __iomem *addr)
 }
 #endif
 
+static inline void flexcan_enter_stop_mode(struct flexcan_priv *priv)
+{
+	int val;
+
+	/* enable stop request */
+	if (priv->devtype_data->features & FLEXCAN_HAS_V10_FEATURES) {
+		val = priv->id ? IMX6Q_GPR13_CAN2_STOP_REQ :
+				IMX6Q_GPR13_CAN1_STOP_REQ;
+		regmap_update_bits(priv->gpr, IOMUXC_GPR13,
+			val, val);
+	}
+}
+
+static inline void flexcan_exit_stop_mode(struct flexcan_priv *priv)
+{
+	int val;
+
+	/* remove stop request */
+	if (priv->devtype_data->features & FLEXCAN_HAS_V10_FEATURES) {
+		val = priv->id ? IMX6Q_GPR13_CAN2_STOP_REQ :
+				IMX6Q_GPR13_CAN1_STOP_REQ;
+		regmap_update_bits(priv->gpr, IOMUXC_GPR13,
+			val, 0);
+	}
+}
+
 static inline int flexcan_transceiver_enable(const struct flexcan_priv *priv)
 {
 	if (!priv->reg_xceiver)
@@ -711,6 +743,9 @@ static irqreturn_t flexcan_irq(int irq, void *dev_id)
 	if (reg_esr & FLEXCAN_ESR_ALL_INT)
 		flexcan_write(reg_esr & FLEXCAN_ESR_ALL_INT, &regs->esr);
 
+	if (reg_esr & FLEXCAN_ESR_WAK_INT)
+		flexcan_exit_stop_mode(priv);
+
 	/*
 	 * schedule NAPI in case of:
 	 * - rx IRQ
@@ -824,13 +859,14 @@ static int flexcan_chip_start(struct net_device *dev)
 	 * enable warning int
 	 * choose format C
 	 * disable local echo
-	 *
+	 * enable self wakeup
 	 */
 	reg_mcr = flexcan_read(&regs->mcr);
 	reg_mcr &= ~FLEXCAN_MCR_MAXMB(0xff);
 	reg_mcr |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_FEN | FLEXCAN_MCR_HALT |
 		FLEXCAN_MCR_SUPV | FLEXCAN_MCR_WRN_EN |
 		FLEXCAN_MCR_IDAM_C | FLEXCAN_MCR_SRX_DIS |
+		FLEXCAN_MCR_WAK_MSK | FLEXCAN_MCR_SLF_WAK |
 		FLEXCAN_MCR_MAXMB(FLEXCAN_TX_BUF_ID);
 	netdev_dbg(dev, "%s: writing mcr=0x%08x", __func__, reg_mcr);
 	flexcan_write(reg_mcr, &regs->mcr);
@@ -1107,6 +1143,7 @@ static int flexcan_probe(struct platform_device *pdev)
 	void __iomem *base;
 	int err, irq;
 	u32 clock_freq = 0;
+	int wakeup = 1;
 
 	if (pdev->dev.of_node)
 		of_property_read_u32(pdev->dev.of_node,
@@ -1186,6 +1223,23 @@ static int flexcan_probe(struct platform_device *pdev)
 
 	devm_can_led_init(dev);
 
+	if (priv->devtype_data->features & FLEXCAN_HAS_V10_FEATURES) {
+		priv->gpr = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
+				"gpr");
+		if (IS_ERR(priv->gpr)) {
+			wakeup = 0;
+			dev_dbg(&pdev->dev, "can not get grp\n");
+		}
+
+		priv->id = of_alias_get_id(pdev->dev.of_node, "flexcan");
+		if (priv->id < 0) {
+			wakeup = 0;
+			dev_dbg(&pdev->dev, "can not get alias id\n");
+		}
+	}
+
+	device_set_wakeup_capable(&pdev->dev, wakeup);
+
 	dev_info(&pdev->dev, "device registered (reg_base=%p, irq=%d)\n",
 		 priv->base, dev->irq);
 
@@ -1213,15 +1267,22 @@ static int flexcan_suspend(struct device *device)
 {
 	struct net_device *dev = dev_get_drvdata(device);
 	struct flexcan_priv *priv = netdev_priv(dev);
-	int err;
-
-	err = flexcan_chip_disable(priv);
-	if (err)
-		return err;
 
 	if (netif_running(dev)) {
 		netif_stop_queue(dev);
 		netif_device_detach(dev);
+		/*
+		* if wakeup is enabled, enter stop mode
+		* else enter disabled mode.
+		*/
+		if (device_may_wakeup(&pdev->dev)) {
+			enable_irq_wake(dev->irq);
+			flexcan_enter_stop_mode(priv);
+		} else {
+			flexcan_chip_disable(priv);
+		}
+	} else {
+		flexcan_chip_disable(priv);
 	}
 	priv->can.state = CAN_STATE_SLEEPING;
 
@@ -1237,8 +1298,17 @@ static int flexcan_resume(struct device *device)
 	if (netif_running(dev)) {
 		netif_device_attach(dev);
 		netif_start_queue(dev);
+
+		if (device_may_wakeup(&pdev->dev)) {
+			disable_irq_wake(dev->irq);
+			flexcan_exit_stop_mode(priv);
+		} else {
+			flexcan_chip_enable(priv);
+		}
+	} else {
+		flexcan_chip_enable(priv);
 	}
-	return flexcan_chip_enable(priv);
+ 	return 0;
 }
 #endif /* CONFIG_PM_SLEEP */
 
-- 
1.7.5.4

