From 25a4e52dc90a836cd4eb26ade7e661ded833562f Mon Sep 17 00:00:00 2001
From: Nimrod Andy <B38611@freescale.com>
Date: Thu, 12 Jun 2014 08:16:18 +0800
Subject: [PATCH 1057/1074] net: fec: Factorize the .xmit transmit function

commit 61a4427b955f79dfaa735788511ce558962c9d70 upstream

Make the code more readable and easy to support other features like
SG, TSO, moving the common transmit function to one api.

And the patch also factorize the getting BD index to it own function.

CC: David Laight <David.Laight@ACULAB.COM>
Signed-off-by: Fugang Duan <B38611@freescale.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
[Fix context to apply to WRL kernel]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/net/ethernet/freescale/fec_main.c |   88 ++++++++++++++++------------
 1 files changed, 50 insertions(+), 38 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c
index c7b57b8..ae418e2 100644
--- a/drivers/net/ethernet/freescale/fec_main.c
+++ b/drivers/net/ethernet/freescale/fec_main.c
@@ -249,6 +249,12 @@ struct bufdesc *fec_enet_get_prevdesc(struct bufdesc *bdp, struct fec_enet_priva
 		return (new_bd < base) ? (new_bd + ring_size) : new_bd;
 }
 
+static int fec_enet_get_bd_index(struct bufdesc *base, struct bufdesc *bdp,
+                               struct fec_enet_private *fep)
+{
+       return ((const char *)bdp - (const char *)base) / fep->bufdesc_size;
+}
+
 static void *swap_buffer(void *bufaddr, int len)
 {
 	int i;
@@ -275,15 +281,13 @@ fec_enet_clear_csum(struct sk_buff *skb, struct net_device *ndev)
 	return 0;
 }
 
-static netdev_tx_t
-fec_enet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+static int fec_enet_txq_submit_skb(struct fec_enet_priv_tx_q *txq,
+			struct sk_buff *skb, struct net_device *ndev)
 {
 	struct fec_enet_private *fep = netdev_priv(ndev);
 	const struct platform_device_id *id_entry =
 				platform_get_device_id(fep->pdev);
 	struct bufdesc *bdp, *bdp_pre;
-	struct fec_enet_priv_tx_q *txq;
-	struct netdev_queue *nq;
 	unsigned short queue;
 	void *bufaddr;
 	unsigned short	status;
@@ -293,22 +297,12 @@ fec_enet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 	unsigned int index;
 
 	queue = skb_get_queue_mapping(skb);
-	txq = fep->tx_queue[queue];
-	nq = netdev_get_tx_queue(ndev, queue);
 
 	/* Fill in a Tx ring entry */
 	bdp = txq->cur_tx;
 
 	status = bdp->cbd_sc;
 
-	if (status & BD_ENET_TX_READY) {
-		/* Ooops.  All transmit buffers are full.  Bail out.
-		 * This should not happen, since ndev->tbusy should be set.
-		 */
-		netdev_err(ndev, "tx queue full!\n");
-		return NETDEV_TX_BUSY;
-	}
-
 	/* Protocol checksum off-load for TCP and UDP. */
 	if (fec_enet_clear_csum(skb, ndev)) {
 		kfree_skb(skb);
@@ -322,16 +316,7 @@ fec_enet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 	bufaddr = skb->data;
 	bdbuf_len = skb->len;
 
-	/*
-	 * On some FEC implementations data must be aligned on
-	 * 4-byte boundaries. Use bounce buffers to copy data
-	 * and get it aligned. Ugh.
-	 */
-	if (fep->bufdesc_ex)
-		index = (struct bufdesc_ex *)bdp -
-			(struct bufdesc_ex *)txq->tx_bd_base;
-	else
-		index = bdp - txq->tx_bd_base;
+	index = fec_enet_get_bd_index(bdp, fep, queue);
 
 	if (!(id_entry->driver_data & FEC_QUIRK_HAS_AVB) &&
 		((unsigned long) bufaddr) & FEC_ALIGNMENT) {
@@ -417,9 +402,6 @@ fec_enet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 
 	txq->cur_tx = bdp;
 
-	if (txq->cur_tx == txq->dirty_tx)
-		netif_tx_stop_queue(nq);
-
 	/* Trigger transmission start */
 	if (!(id_entry->driver_data & FEC_QUIRK_TKT210582) ||
 		!__raw_readl(fep->hwp + FEC_X_DES_ACTIVE(queue)) ||
@@ -430,6 +412,44 @@ fec_enet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 		__raw_writel(0, fep->hwp + FEC_X_DES_ACTIVE(queue));
 	}
 
+	return 0;
+}
+
+static netdev_tx_t
+fec_enet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct fec_enet_private *fep = netdev_priv(ndev);
+	struct fec_enet_priv_tx_q *txq;
+	struct netdev_queue *nq;
+	unsigned short queue;
+	struct bufdesc *bdp;
+	unsigned short  status;
+	int ret;
+
+	queue = skb_get_queue_mapping(skb);
+	txq = fep->tx_queue[queue];
+	nq = netdev_get_tx_queue(ndev, queue);
+
+	/* Fill in a Tx ring entry */
+	bdp = txq->cur_tx;
+
+	status = bdp->cbd_sc;
+
+	if (status & BD_ENET_TX_READY) {
+		/* Ooops.  All transmit buffers are full.  Bail out.
+		 * This should not happen, since ndev->tbusy should be set.
+		 */
+		netdev_err(ndev, "tx queue full!\n");
+		return NETDEV_TX_BUSY;
+	}
+
+	ret = fec_enet_txq_submit_skb(txq, skb, ndev);
+	if (ret == -EBUSY)
+		return NETDEV_TX_BUSY;
+
+	if (txq->cur_tx == txq->dirty_tx)
+		netif_tx_stop_queue(nq);
+
 	return NETDEV_TX_OK;
 }
 
@@ -856,12 +876,8 @@ fec_enet_tx(struct net_device *ndev)
 			if (bdp == txq->cur_tx)
 				break;
 
-			if (fep->bufdesc_ex)
-				index = (struct bufdesc_ex *)bdp -
-					(struct bufdesc_ex *)txq->tx_bd_base;
-			else
-				index = bdp - txq->tx_bd_base;
- 
+			index = fec_enet_get_bd_index(bdp, fep, queue_id);
+
 			dma_unmap_single(&fep->pdev->dev, bdp->cbd_bufaddr,
 					FEC_ENET_TX_FRSIZE, DMA_TO_DEVICE);
 			bdp->cbd_bufaddr = 0;
@@ -1001,11 +1017,7 @@ fec_enet_rx(struct net_device *ndev, int budget)
 				break;
 			pkt_received++;
 
-			if (fep->bufdesc_ex)
-				index = (struct bufdesc_ex *)bdp -
-						(struct bufdesc_ex *)rxq->rx_bd_base;
-			else
-				index = bdp - rxq->rx_bd_base;
+			index = fec_enet_get_bd_index(bdp, fep, queue_id);
 
 			/* Since we have allocated space to hold a complete frame,
 			 * the last indicator should be set.
-- 
1.7.5.4

