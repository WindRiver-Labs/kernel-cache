From 530ca5824e0a20142ff6b71c761acec4766fefa2 Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@freescale.com>
Date: Tue, 18 Mar 2014 09:05:42 +0800
Subject: [PATCH 0774/1074] ENGR00303795-4 usb: chipidea: imx: add hsic
 support for imx6sx

Some improvements and bug-fixes for imx6sx:
- Add one bit for sending resume signal using 32K OSC
- Add board level pad regulator
- HSIC also needs host quirk, add this fix for imx6sl too

Signed-off-by: Peter Chen <peter.chen@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/usb/chipidea/ci_hdrc_imx.c |   41 +++++++++++++++++++++++++++++++++--
 drivers/usb/chipidea/usbmisc_imx.c |    5 +++-
 2 files changed, 42 insertions(+), 4 deletions(-)

diff --git a/drivers/usb/chipidea/ci_hdrc_imx.c b/drivers/usb/chipidea/ci_hdrc_imx.c
index 65711b3..2360600 100644
--- a/drivers/usb/chipidea/ci_hdrc_imx.c
+++ b/drivers/usb/chipidea/ci_hdrc_imx.c
@@ -23,6 +23,7 @@
 #include <linux/regmap.h>
 #include <linux/mfd/syscon.h>
 #include <linux/power/imx6_usb_charger.h>
+#include <linux/regulator/consumer.h>
 
 #include "ci.h"
 #include "ci_hdrc_imx.h"
@@ -56,11 +57,13 @@ static const struct ci_hdrc_imx_platform_flag imx6q_usb_data = {
 
 static const struct ci_hdrc_imx_platform_flag imx6sl_usb_data = {
 	.flags = CI_HDRC_IMX_SUPPORT_RUNTIME_PM |
+		CI_HDRC_IMX_HOST_QUIRK |
 		CI_HDRC_IMX_HAS_HSIC,
 };
 
 static const struct ci_hdrc_imx_platform_flag imx6sx_usb_data = {
 	.flags = CI_HDRC_IMX_SUPPORT_RUNTIME_PM |
+		CI_HDRC_IMX_HOST_QUIRK |
 		CI_HDRC_IMX_HAS_HSIC,
 };
 
@@ -87,6 +90,7 @@ struct ci_hdrc_imx_data {
 	struct regmap *anatop;
 	struct pinctrl *pinctrl;
 	struct pinctrl_state *pinctrl_hsic_active;
+	struct regulator *hsic_pad_regulator;
 };
 
 /* Common functions shared by usbmisc drivers */
@@ -300,9 +304,35 @@ static int ci_hdrc_imx_probe(struct platform_device *pdev)
 		pdata.flags |= CI_HDRC_IMX_EHCI_QUIRK;
 
 	if (data->usbmisc_data && data->usbmisc_data->index > 1 &&
-		(imx_platform_flag->flags & CI_HDRC_IMX_HAS_HSIC))
+		(imx_platform_flag->flags & CI_HDRC_IMX_HAS_HSIC)) {
 		pdata.flags |= CI_HDRC_IMX_IS_HSIC;
 
+		data->hsic_pad_regulator =
+			devm_regulator_get(&pdev->dev, "pad");
+		if (PTR_ERR(data->hsic_pad_regulator) == -EPROBE_DEFER) {
+			ret = -EPROBE_DEFER;
+			goto err_clk;
+		} else if (PTR_ERR(data->hsic_pad_regulator) == -ENODEV) {
+			/* no pad regualator is needed */
+			data->hsic_pad_regulator = NULL;
+		} else if (IS_ERR(data->hsic_pad_regulator)) {
+			dev_err(&pdev->dev,
+				"Get hsic pad regulator error: %ld\n",
+				PTR_ERR(data->hsic_pad_regulator));
+			ret = PTR_ERR(data->hsic_pad_regulator);
+			goto err_clk;
+		}
+
+		if (data->hsic_pad_regulator) {
+			ret = regulator_enable(data->hsic_pad_regulator);
+			if (ret) {
+				dev_err(&pdev->dev,
+					"Fail to enable hsic pad regulator\n");
+				goto err_clk;
+			}
+		}
+	}
+
 	if (of_find_property(np, "imx6-usb-charger-detection", NULL))
 		data->imx6_usb_charger_detection = true;
 
@@ -313,7 +343,7 @@ static int ci_hdrc_imx_probe(struct platform_device *pdev)
 			dev_dbg(&pdev->dev,
 				"failed to find regmap for anatop\n");
 			ret = PTR_ERR(data->anatop);
-			goto err_clk;
+			goto disable_hsic_regulator;
 		}
 		if (data->usbmisc_data)
 			data->usbmisc_data->anatop = data->anatop;
@@ -323,7 +353,7 @@ static int ci_hdrc_imx_probe(struct platform_device *pdev)
 			ret = imx6_usb_create_charger(&data->charger,
 				"imx6_usb_charger");
 			if (ret && ret != -ENODEV)
-				goto err_clk;
+				goto disable_hsic_regulator;
 			if (!ret)
 				dev_dbg(&pdev->dev,
 					"USB Charger is created\n");
@@ -387,6 +417,9 @@ disable_device:
 remove_charger:
 	if (data->imx6_usb_charger_detection)
 		imx6_usb_remove_charger(&data->charger);
+disable_hsic_regulator:
+	if (data->hsic_pad_regulator)
+		ret = regulator_disable(data->hsic_pad_regulator);
 err_phy:
 	if (data->phy)
 		usb_phy_shutdown(data->phy);
@@ -408,6 +441,8 @@ static int ci_hdrc_imx_remove(struct platform_device *pdev)
 	clk_disable_unprepare(data->clk);
 	if (data->imx6_usb_charger_detection)
 		imx6_usb_remove_charger(&data->charger);
+	if (data->hsic_pad_regulator)
+		regulator_disable(data->hsic_pad_regulator);
 	return 0;
 }
 
diff --git a/drivers/usb/chipidea/usbmisc_imx.c b/drivers/usb/chipidea/usbmisc_imx.c
index 364c119..38034dd 100644
--- a/drivers/usb/chipidea/usbmisc_imx.c
+++ b/drivers/usb/chipidea/usbmisc_imx.c
@@ -57,6 +57,8 @@
 #define MX6_BM_HSIC_EN			BIT(12)
 /* Force HSIC module 480M clock on, even when in Host is in suspend mode */
 #define MX6_BM_HSIC_CLK_ON		BIT(11)
+/* Send resume signal without 480Mhz PHY clock */
+#define MX6SX_BM_HSIC_AUTO_RESUME	BIT(23)
 
 #define ANADIG_ANA_MISC0		0x150
 #define ANADIG_ANA_MISC0_SET		0x154
@@ -196,7 +198,8 @@ static int usbmisc_imx6q_init(struct imx_usbmisc_data *data)
 			usbmisc->base + data->index * 4);
 		val = readl(usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET
 			+ (data->index - 2) * 4);
-		val |= MX6_BM_HSIC_EN | MX6_BM_HSIC_CLK_ON;
+		val |= MX6_BM_HSIC_EN | MX6_BM_HSIC_CLK_ON
+			| MX6SX_BM_HSIC_AUTO_RESUME;
 		writel(val, usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET
 			+ (data->index - 2) * 4);
 		spin_unlock_irqrestore(&usbmisc->lock, flags);
-- 
1.7.5.4

