From 25a1065289243f8334165db0e15bfb8a972db4c4 Mon Sep 17 00:00:00 2001
From: Fugang Duan <B38611@freescale.com>
Date: Sun, 29 Sep 2013 17:40:31 +0800
Subject: [PATCH 0199/1074] ENGR00281804 ARM: imx6: init enet MAC address

Enet get MAC address order:
From module parameters or kernel command line -> device tree ->
pfuse -> mac registers set by bootloader -> random mac address.

When there have no "fec.macaddr" parameters set in kernel command
line, enet driver get MAC address from device tree. And then if
the MAC address set in device tree and is valid, enet driver get
MAC address from device tree. Otherwise,enet get MAC address from
pfuse. So, in the condition, update the MAC address (read from pfuse)
to device tree.

Signed-off-by: Fugang Duan <B38611@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 arch/arm/mach-imx/common.h      |    1 +
 arch/arm/mach-imx/mach-imx6q.c  |   70 +++++++++++++++++++++++++++++++++++++-
 arch/arm/mach-imx/mach-imx6sl.c |    8 ++++-
 3 files changed, 76 insertions(+), 3 deletions(-)

diff --git a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h
index 368dd90..3572fdc 100644
--- a/arch/arm/mach-imx/common.h
+++ b/arch/arm/mach-imx/common.h
@@ -143,6 +143,7 @@ void imx_anatop_pu_enable(bool enable);
 int imx6q_set_lpm(enum mxc_cpu_pwr_mode mode);
 void imx6q_set_cache_lpm_in_wait(bool enable);
 void imx6sl_set_wait_clk(bool enter);
+void imx6_enet_mac_init(const char *compatible);
 
 void imx_cpu_die(unsigned int cpu);
 int imx_cpu_kill(unsigned int cpu);
diff --git a/arch/arm/mach-imx/mach-imx6q.c b/arch/arm/mach-imx/mach-imx6q.c
index e26f34b..a3fdf38 100644
--- a/arch/arm/mach-imx/mach-imx6q.c
+++ b/arch/arm/mach-imx/mach-imx6q.c
@@ -33,6 +33,7 @@
 #include <linux/micrel_phy.h>
 #include <linux/mfd/syscon.h>
 #include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>
+#include <linux/of_net.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 #include <asm/system_misc.h>
@@ -265,6 +266,72 @@ static void __init imx6q_lvds_cabc_init(void)
 	}
 }
 
+#define OCOTP_MACn(n)	(0x00000620 + (n) * 0x10)
+void __init imx6_enet_mac_init(const char *compatible)
+{
+	struct device_node *ocotp_np, *enet_np;
+	void __iomem *base;
+	struct property *newmac;
+	u32 macaddr_low, macaddr_high;
+	u8 *macaddr;
+
+	enet_np = of_find_compatible_node(NULL, NULL, compatible);
+	if (!enet_np)
+		return;
+
+	if (of_get_mac_address(enet_np))
+		goto put_enet_node;
+
+	ocotp_np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-ocotp");
+	if (!ocotp_np) {
+		pr_warn("failed to find ocotp node\n");
+		goto put_enet_node;
+	}
+
+	base = of_iomap(ocotp_np, 0);
+	if (!base) {
+		pr_warn("failed to map ocotp\n");
+		goto put_ocotp_node;
+	}
+
+	macaddr_high = readl_relaxed(base + OCOTP_MACn(0));
+	macaddr_low = readl_relaxed(base + OCOTP_MACn(1));
+
+	newmac = kzalloc(sizeof(*newmac) + 6, GFP_KERNEL);
+	if (!newmac)
+		goto put_ocotp_node;
+
+	newmac->value = newmac + 1;
+	newmac->length = 6;
+	newmac->name = kstrdup("local-mac-address", GFP_KERNEL);
+	if (!newmac->name) {
+		kfree(newmac);
+		goto put_ocotp_node;
+	}
+
+	macaddr = newmac->value;
+	macaddr[5] = macaddr_high & 0xff;
+	macaddr[4] = (macaddr_high >> 8) & 0xff;
+	macaddr[3] = (macaddr_high >> 16) & 0xff;
+	macaddr[2] = (macaddr_high >> 24) & 0xff;
+	macaddr[1] = macaddr_low & 0xff;
+	macaddr[0] = (macaddr_low >> 8) & 0xff;
+
+	of_update_property(enet_np, newmac);
+
+put_ocotp_node:
+	of_node_put(ocotp_np);
+put_enet_node:
+	of_node_put(enet_np);
+}
+
+static inline void imx6q_enet_init(void)
+{
+	imx6_enet_mac_init("fsl,imx6q-fec");
+	imx6q_enet_phy_init();
+	imx6q_1588_init();
+}
+
 static void __init imx6q_init_machine(void)
 {
 	struct device *parent;
@@ -278,13 +345,12 @@ static void __init imx6q_init_machine(void)
 	if (parent == NULL)
 		pr_warn("failed to initialize soc device\n");
 
-	imx6q_enet_phy_init();
+	imx6q_enet_init();
 
 	of_platform_populate(NULL, of_default_bus_match_table, NULL, parent);
 
 	imx_anatop_init();
 	imx6q_pm_init();
-	imx6q_1588_init();
 	imx6q_csi_mux_init();
 	imx6q_lvds_cabc_init();
 }
diff --git a/arch/arm/mach-imx/mach-imx6sl.c b/arch/arm/mach-imx/mach-imx6sl.c
index d93b47f..dce6892 100644
--- a/arch/arm/mach-imx/mach-imx6sl.c
+++ b/arch/arm/mach-imx/mach-imx6sl.c
@@ -19,7 +19,7 @@
 #include "common.h"
 #include "cpuidle.h"
 
-static void __init imx6sl_fec_init(void)
+static void __init imx6sl_fec_clk_init(void)
 {
 	struct regmap *gpr;
 
@@ -45,6 +45,12 @@ static void __init imx6sl_init_late(void)
 		platform_device_register_simple("imx6q-cpufreq", -1, NULL, 0);
 }
 
+static inline void imx6sl_fec_init(void)
+{
+	imx6sl_fec_clk_init();
+	imx6_enet_mac_init("fsl,imx6sl-fec");
+}
+
 static void __init imx6sl_init_machine(void)
 {
 	struct device *parent;
-- 
1.7.5.4

