From 294b9f00113c3bcffa6d464c1259aa969ca5ae8e Mon Sep 17 00:00:00 2001
From: Sandor Yu <R01008@freescale.com>
Date: Mon, 11 Aug 2014 19:05:11 +0800
Subject: [PATCH 0908/1074] ENGR00322859 CSI: some frames crrouption issue

Sometimes csi will capture a corruption frame from vadc.
There are two reasons will cause such issue.

1. CSI base address switch error
When base address switch error occur, though csi will recovery
in few frames, but the error will cause csi miss field sync signal later,
and two fields of one frame will write to different base address.
Fix with following code change:
-Enable csi base address switch error interrupter.
-Reset csi DMA rxfifo when base address switch error interrupter occur.
-Setting RXFIFO level to 16 words and DMA burst size to INCR16.
-setting csi switching base address at the edge of the first data of
each frame.

2. CSI IP issue PDM TKT230775
CSI not protect base address between field0 and field1.
So software have chance to change base address during csi capture
field0 data and field1 will write to new base address.
Software workaround:
-Skip FB1 and FB2 DMA transfer done interrupter if both of them detected
in csi ISR.

Signed-off-by: Sandor Yu <R01008@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/media/platform/mxc/capture/fsl_csi.c |   57 ++++++++++++++++++++++----
 drivers/media/platform/mxc/capture/fsl_csi.h |    5 ++
 2 files changed, 54 insertions(+), 8 deletions(-)

diff --git a/drivers/media/platform/mxc/capture/fsl_csi.c b/drivers/media/platform/mxc/capture/fsl_csi.c
index 0121234..721e668 100644
--- a/drivers/media/platform/mxc/capture/fsl_csi.c
+++ b/drivers/media/platform/mxc/capture/fsl_csi.c
@@ -63,13 +63,42 @@ static irqreturn_t csi_irq_handler(int irq, void *data)
 	cam_data *cam = (cam_data *) data;
 	struct csi_soc *csi = &csi_array[cam->csi];
 	unsigned long status = __raw_readl(csi->regbase + CSI_CSISR);
+	u32 cr3, cr18;
 
 	__raw_writel(status, csi->regbase + CSI_CSISR);
 
 	if (status & BIT_HRESP_ERR_INT)
 		pr_warning("Hresponse error is detected.\n");
 
-	if (status & BIT_DMA_TSF_DONE_FB1) {
+	if (status & BIT_ADDR_CH_ERR_INT) {
+		/* Disable csi  */
+		cr18 = __raw_readl(csi->regbase + CSI_CSICR18);
+		cr18 &= ~BIT_CSI_ENABLE;
+		__raw_writel(cr18, csi->regbase + CSI_CSICR18);
+
+		/* DMA reflash */
+		cr3 = __raw_readl(csi->regbase + CSI_CSICR3);
+		cr3 |= BIT_DMA_REFLASH_RFF;
+		__raw_writel(cr3, csi->regbase + CSI_CSICR3);
+
+		/* Ensable csi  */
+		cr18 |= BIT_CSI_ENABLE;
+		__raw_writel(cr18, csi->regbase + CSI_CSICR18);
+
+		pr_debug("base address switching Change Err.\n");
+	}
+
+	if ((status & BIT_DMA_TSF_DONE_FB1) &&
+		(status & BIT_DMA_TSF_DONE_FB2)) {
+		/* For both FB1 and FB2 interrupter bits set case,
+		 * CSI DMA is work in one of FB1 and FB2 buffer,
+		 * but software can not know the state.
+		 * Skip it to avoid base address updated
+		 * when csi work in field0 and field1 will write to
+		 * new base address.
+		 * PDM TKT230775 */
+		pr_debug("Skip two frames\n");
+	} else if (status & BIT_DMA_TSF_DONE_FB1) {
 		if (cam->capture_on) {
 			spin_lock(&cam->queue_int_lock);
 			cam->ping_pong_csi = 1;
@@ -79,9 +108,7 @@ static irqreturn_t csi_irq_handler(int irq, void *data)
 			cam->still_counter++;
 			wake_up_interruptible(&cam->still_queue);
 		}
-	}
-
-	if (status & BIT_DMA_TSF_DONE_FB2) {
+	} else if (status & BIT_DMA_TSF_DONE_FB2) {
 		if (cam->capture_on) {
 			spin_lock(&cam->queue_int_lock);
 			cam->ping_pong_csi = 2;
@@ -272,12 +299,18 @@ void csi_tvdec_enable(cam_data *cam, bool enable)
 	unsigned long cr1 = __raw_readl(csi->regbase + CSI_CSICR1);
 
 	if (enable == true) {
-		cr18 |= (BIT_TVDECODER_IN_EN | BIT_BASEADDR_SWITCH_EN);
-		cr1 |= BIT_CCIR_MODE | BIT_EXT_VSYNC;
+		cr18 |= (BIT_TVDECODER_IN_EN |
+				BIT_BASEADDR_SWITCH_EN |
+				BIT_BASEADDR_SWITCH_SEL |
+				BIT_BASEADDR_CHG_ERR_EN);
+		cr1 |= BIT_CCIR_MODE;
 		cr1 &= ~(BIT_SOF_POL | BIT_REDGE);
 	} else {
-		cr18 &= ~(BIT_TVDECODER_IN_EN | BIT_BASEADDR_SWITCH_EN);
-		cr1 &= ~(BIT_CCIR_MODE | BIT_EXT_VSYNC);
+		cr18 &= ~(BIT_TVDECODER_IN_EN |
+				BIT_BASEADDR_SWITCH_EN |
+				BIT_BASEADDR_SWITCH_SEL |
+				BIT_BASEADDR_CHG_ERR_EN);
+		cr1 &= ~BIT_CCIR_MODE;
 		cr1 |= BIT_SOF_POL | BIT_REDGE;
 	}
 
@@ -332,10 +365,18 @@ EXPORT_SYMBOL(csi_set_12bit_imagpara);
 void csi_dmareq_rff_enable(struct csi_soc *csi)
 {
 	unsigned long cr3 = __raw_readl(csi->regbase + CSI_CSICR3);
+	unsigned long cr2 = __raw_readl(csi->regbase + CSI_CSICR2);
+
+	/* Burst Type of DMA Transfer from RxFIFO. INCR16 */
+	cr2 |= 0xC0000000;
 
 	cr3 |= BIT_DMA_REQ_EN_RFF;
 	cr3 |= BIT_HRESP_ERR_EN;
+	cr3 &= ~BIT_RXFF_LEVEL;
+	cr3 |= 0x2 << 4;
+
 	__raw_writel(cr3, csi->regbase + CSI_CSICR3);
+	__raw_writel(cr2, csi->regbase + CSI_CSICR2);
 }
 EXPORT_SYMBOL(csi_dmareq_rff_enable);
 
diff --git a/drivers/media/platform/mxc/capture/fsl_csi.h b/drivers/media/platform/mxc/capture/fsl_csi.h
index 95ed13e..62bf4c9 100644
--- a/drivers/media/platform/mxc/capture/fsl_csi.h
+++ b/drivers/media/platform/mxc/capture/fsl_csi.h
@@ -77,8 +77,12 @@
 #define BIT_ECC_AUTO_EN		(0x1 << 0)
 
 #define SHIFT_FRMCNT		16
+#define SHIFT_RXFIFO_LEVEL	4
 
 /* csi status reg */
+#define BIT_ADDR_CH_ERR_INT (0x1 << 28)
+#define BIT_FIELD0_INT      (0x1 << 27)
+#define BIT_FIELD1_INT      (0x1 << 26)
 #define BIT_SFF_OR_INT		(0x1 << 25)
 #define BIT_RFF_OR_INT		(0x1 << 24)
 #define BIT_DMA_TSF_DONE_SFF	(0x1 << 22)
@@ -97,6 +101,7 @@
 
 /* csi control reg 18 */
 #define BIT_CSI_ENABLE			(0x1 << 31)
+#define BIT_BASEADDR_CHG_ERR_EN	(0x1 << 9)
 #define BIT_BASEADDR_SWITCH_SEL	(0x1 << 5)
 #define BIT_BASEADDR_SWITCH_EN	(0x1 << 4)
 #define BIT_PARALLEL24_EN		(0x1 << 3)
-- 
1.7.5.4

