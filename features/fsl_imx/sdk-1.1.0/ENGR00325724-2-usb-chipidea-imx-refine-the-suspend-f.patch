From c9b517d9da1b6f9fd8e2f0fbd9243808fac622b4 Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@freescale.com>
Date: Thu, 11 Sep 2014 17:02:10 +0800
Subject: [PATCH 0927/1074] ENGR00325724-2 usb: chipidea: imx: refine the
 suspend function

- The system suspend routine only enables wakeup setting if the
user enables usb as wakeup source
- struct ci_hdrc_imx_data.in_lpm seems to be useless. During the
system suspend routine, the ci core makes sure the controller
is active before the controller system suspend routine run.
And the runtime power management framework should make sure
its device's pm routine not re-enter. We use an WARN_ON to
trigger if pm code is not in our expectation.
The .ln_lpm flag can be deleted after one release cycle.

Signed-off-by: Peter Chen <peter.chen@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/usb/chipidea/ci_hdrc_imx.c |   49 ++++++++++++++++++++++-------------
 1 files changed, 31 insertions(+), 18 deletions(-)

diff --git a/drivers/usb/chipidea/ci_hdrc_imx.c b/drivers/usb/chipidea/ci_hdrc_imx.c
index 9b57240..79da43b 100644
--- a/drivers/usb/chipidea/ci_hdrc_imx.c
+++ b/drivers/usb/chipidea/ci_hdrc_imx.c
@@ -454,23 +454,13 @@ static int imx_controller_suspend(struct device *dev)
 
 	dev_dbg(dev, "at %s\n", __func__);
 
-	if (data->in_lpm)
-		return 0;
-
 	if (data->usbmisc_data) {
-		ret = imx_usbmisc_set_wakeup(data->usbmisc_data, true);
-		if (ret) {
-			dev_err(dev,
-				"usbmisc set_wakeup failed, ret=%d\n",
-				ret);
-			return ret;
-		}
 		ret = imx_usbmisc_hsic_set_clk(data->usbmisc_data, false);
 		if (ret) {
 			dev_err(dev,
 				"usbmisc hsic_set_clk failed, ret=%d\n",
 				ret);
-			goto hsic_set_clk_fail;
+			return ret;
 		}
 	}
 
@@ -479,11 +469,6 @@ static int imx_controller_suspend(struct device *dev)
 	data->in_lpm = true;
 
 	return 0;
-
-hsic_set_clk_fail:
-	imx_usbmisc_set_wakeup(data->usbmisc_data, false);
-
-	return ret;
 }
 
 static int imx_controller_resume(struct device *dev)
@@ -493,8 +478,7 @@ static int imx_controller_resume(struct device *dev)
 
 	dev_dbg(dev, "at %s\n", __func__);
 
-	if (!data->in_lpm)
-		return 0;
+	WARN_ON(!data->in_lpm);
 
 	ret = clk_prepare_enable(data->clk);
 	if (ret)
@@ -542,6 +526,20 @@ clk_disable:
 #ifdef CONFIG_PM_SLEEP
 static int ci_hdrc_imx_suspend(struct device *dev)
 {
+	struct ci_hdrc_imx_data *data = dev_get_drvdata(dev);
+	int ret;
+	/* The core should make sure the controller is active now */
+	WARN_ON(data->in_lpm);
+
+	if (device_may_wakeup(dev) && data->usbmisc_data) {
+		ret = imx_usbmisc_set_wakeup(data->usbmisc_data, true);
+		if (ret) {
+			dev_err(dev,
+				"usbmisc set_wakeup failed, ret=%d\n",
+				ret);
+			return ret;
+		}
+	}
 	return imx_controller_suspend(dev);
 }
 
@@ -564,6 +562,21 @@ static int ci_hdrc_imx_resume(struct device *dev)
 #ifdef CONFIG_PM_RUNTIME
 static int ci_hdrc_imx_runtime_suspend(struct device *dev)
 {
+	struct ci_hdrc_imx_data *data = dev_get_drvdata(dev);
+	int ret;
+
+	WARN_ON(data->in_lpm);
+
+	if (data->usbmisc_data) {
+		ret = imx_usbmisc_set_wakeup(data->usbmisc_data, true);
+		if (ret) {
+			dev_err(dev,
+				"usbmisc set_wakeup failed, ret=%d\n",
+				ret);
+			return ret;
+		}
+	}
+
 	return imx_controller_suspend(dev);
 }
 
-- 
1.7.5.4

