From b1dd87603d4ba3103da605292759042bcd8897a1 Mon Sep 17 00:00:00 2001
From: Ranjani Vaidyanathan <ra5478@freescale.com>
Date: Tue, 15 Oct 2013 12:36:42 -0500
Subject: [PATCH 1001/1074] ENGR00281769 [iMX6SL] Allow uart to be sourced
 from 24MHz XTAL

In order to optmize low power IDLE numbers all PLLs should be in bypass.
On imx6sl, UART can be sourced directly from the 24MHz XTAL. Its frequency
is limited to 4MHz due to an internal divide by 6 divider.
For customer who don't require higher uart speeds add "uart_at_4M"
to the kernel command line.

Signed-off-by: Ranjani Vaidyanathan <ra5478@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 arch/arm/mach-imx/clk-imx6sl.c           |   29 ++++++++++++++++++++++-------
 include/dt-bindings/clock/imx6sl-clock.h |    3 ++-
 2 files changed, 24 insertions(+), 8 deletions(-)

diff --git a/arch/arm/mach-imx/clk-imx6sl.c b/arch/arm/mach-imx/clk-imx6sl.c
index e5f9d9a..837bed2 100644
--- a/arch/arm/mach-imx/clk-imx6sl.c
+++ b/arch/arm/mach-imx/clk-imx6sl.c
@@ -15,6 +15,7 @@
 #include <linux/clk.h>
 #include <linux/clkdev.h>
 #include <linux/err.h>
+#include <linux/init.h>
 #include <linux/io.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
@@ -24,6 +25,7 @@
 #include "clk.h"
 #include "common.h"
 
+static bool uart_from_osc;
 static const char const *step_sels[]		= { "osc", "pll2_pfd2", };
 static const char const *pll1_sw_sels[]		= { "pll1_sys", "step", };
 static const char const *ocram_alt_sels[]	= { "pll2_pfd2", "pll3_pfd1", };
@@ -47,7 +49,7 @@ static const char const *lcdif_pix_sels[]	= { "pll2_bus", "pll3_usb_otg", "pll5_
 static const char const *epdc_pix_sels[]	= { "pll2_bus", "pll3_usb_otg", "pll5_video_div", "pll2_pfd0", "pll2_pfd1", "pll3_pfd1", };
 static const char const *audio_sels[]		= { "pll4_audio_div", "pll3_pfd2", "pll3_pfd3", "pll3_usb_otg", };
 static const char const *ecspi_sels[]		= { "pll3_60m", "osc", };
-static const char const *uart_sels[]		= { "pll3_80m", "osc", };
+static const char const *uart_sels[]		= { "pll3_80m", "uart_osc_4M", };
 
 static struct clk_div_table clk_enet_ref_table[] = {
 	{ .val = 0, .div = 20, },
@@ -76,7 +78,7 @@ static struct clk *clks[IMX6SL_CLK_END];
 static struct clk_onecell_data clk_data;
 static u32 cur_arm_podf;
 
-extern int low_bus_freq_mode;
+int low_bus_freq_mode = 1;
 
 /*
  * On MX6SL, need to ensure that the ARM:IPG clock ratio is maintained
@@ -121,6 +123,14 @@ void imx6sl_set_wait_clk(bool enter)
 	}
 }
 
+static int __init setup_uart_clk(char *uart_rate)
+{
+	uart_from_osc = true;
+	return 1;
+}
+
+__setup("uart_at_4M", setup_uart_clk);
+
 static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 {
 	struct device_node *np;
@@ -175,11 +185,12 @@ static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 	clks[IMX6SL_CLK_PLL3_PFD2] = imx_clk_pfd("pll3_pfd2", "pll3_usb_otg", base + 0xf0,  2);
 	clks[IMX6SL_CLK_PLL3_PFD3] = imx_clk_pfd("pll3_pfd3", "pll3_usb_otg", base + 0xf0,  3);
 
-	/*                                                name         parent_name     mult div */
-	clks[IMX6SL_CLK_PLL2_198M] = imx_clk_fixed_factor("pll2_198m", "pll2_pfd2",      1, 2);
-	clks[IMX6SL_CLK_PLL3_120M] = imx_clk_fixed_factor("pll3_120m", "pll3_usb_otg",   1, 4);
-	clks[IMX6SL_CLK_PLL3_80M]  = imx_clk_fixed_factor("pll3_80m",  "pll3_usb_otg",   1, 6);
-	clks[IMX6SL_CLK_PLL3_60M]  = imx_clk_fixed_factor("pll3_60m",  "pll3_usb_otg",   1, 8);
+	/*                                                       name         parent_name     mult div */
+	clks[IMX6SL_CLK_PLL2_198M]    = imx_clk_fixed_factor("pll2_198m", "pll2_pfd2",      1, 2);
+	clks[IMX6SL_CLK_PLL3_120M]    = imx_clk_fixed_factor("pll3_120m", "pll3_usb_otg",   1, 4);
+	clks[IMX6SL_CLK_PLL3_80M]     = imx_clk_fixed_factor("pll3_80m",  "pll3_usb_otg",   1, 6);
+	clks[IMX6SL_CLK_PLL3_60M]     = imx_clk_fixed_factor("pll3_60m",  "pll3_usb_otg",   1, 8);
+	clks[IMX6SL_CLK_UART_OSC_4M]  = imx_clk_fixed_factor("uart_osc_4M", "osc",          1, 6);
 
 	np = ccm_node;
 	base = of_iomap(np, 0);
@@ -401,6 +412,10 @@ static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 	 * as needed
 	 */
 
+	/* Set the UART parent if needed. */
+	if (uart_from_osc)
+		ret = clk_set_parent(clks[IMX6SL_CLK_UART_SEL], clks[IMX6SL_CLK_UART_OSC_4M]);
+
 	np = of_find_compatible_node(NULL, NULL, "fsl,imx6sl-gpt");
 	base = of_iomap(np, 0);
 	WARN_ON(!base);
diff --git a/include/dt-bindings/clock/imx6sl-clock.h b/include/dt-bindings/clock/imx6sl-clock.h
index e0c9f80..b8b4689 100644
--- a/include/dt-bindings/clock/imx6sl-clock.h
+++ b/include/dt-bindings/clock/imx6sl-clock.h
@@ -147,6 +147,7 @@
 #define IMX6SL_CLK_SPBA			134
 #define IMX6SL_CLK_GPT_3M		135
 #define IMX6SL_CLK_ENET			136
-#define IMX6SL_CLK_END			137
+#define IMX6SL_CLK_UART_OSC_4M		137
+#define IMX6SL_CLK_END			138
 
 #endif /* __DT_BINDINGS_CLOCK_IMX6SL_H */
-- 
1.7.5.4

