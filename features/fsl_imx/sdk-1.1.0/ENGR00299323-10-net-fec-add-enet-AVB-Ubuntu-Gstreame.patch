From 38c983d8b576d5c85e92360170b58066cac45e32 Mon Sep 17 00:00:00 2001
From: Fugang Duan <B38611@freescale.com>
Date: Wed, 15 Jan 2014 14:21:06 +0800
Subject: [PATCH 1034/1074] ENGR00299323-10 net:fec: add enet AVB Ubuntu
 Gstreamer demo support

Support Gstreamer AVB demo support.

ring1 -> ClassA, ring2 -> ClassB, ring0 -> Best Effort

For QoS: ring1 > ring2 > ring0
For bandwidth reverse:
	50% bandwidth -> ClassA
	33% bandwidth -> ClassB
	17% bandwidth -> Best effort queue

In general, ClassA run audio, ClassB run video.
Since AVB demo use big bandwidth streaming, video cost more than
33Mbps bandwidth, and with Qos limitation: ClassA >= ClassB > Best effort,
so we have to change ring2 bandwidth equal to ring1 bandwidth (50%).
After validate on FPGA, AVB demo can work fine for audio and video.

Signed-off-by: Fugang Duan <B38611@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/net/ethernet/freescale/fec.h      |    2 +-
 drivers/net/ethernet/freescale/fec_main.c |   29 ++++++++++++++++++++++++++++-
 2 files changed, 29 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fec.h b/drivers/net/ethernet/freescale/fec.h
index 18db3e8..a1685fc 100644
--- a/drivers/net/ethernet/freescale/fec.h
+++ b/drivers/net/ethernet/freescale/fec.h
@@ -326,7 +326,7 @@ struct bufdesc_ex {
 #define DMA_CLASS_EN		(1 << 16)
 #define IDLE_SLOPE_MASK		0xFFFF
 #define IDLE_SLOPE_1		0x200 /* BW fraction: 0.5 */
-#define IDLE_SLOPE_2		0x100 /* BW fraction: 0.33 */
+#define IDLE_SLOPE_2		0x200 /* BW fraction: 0.5 */
 #define IDLE_SLOPE(X)		((X == 1) ? (IDLE_SLOPE_1 & IDLE_SLOPE_MASK) : \
 				(IDLE_SLOPE_2 & IDLE_SLOPE_MASK))
 #define RCMR_MATCHEN		(0x1 << 16)
diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c
index 5c9208f..5066783 100644
--- a/drivers/net/ethernet/freescale/fec_main.c
+++ b/drivers/net/ethernet/freescale/fec_main.c
@@ -72,6 +72,8 @@ static void fec_enet_itr_coal_init(struct net_device *ndev);
 #define DRIVER_NAME	"fec"
 #define FEC_ENET_GET_QUQUE(_x) ((_x == 0) ? 1 : ((_x == 1) ? 2 : 0))
 
+static const u16 fec_enet_vlan_pri_to_queue[8] = {1, 1, 1, 1, 2, 2, 2, 2};
+
 /* Pause frame feild and FIFO threshold */
 #define FEC_ENET_FCE	(1 << 5)
 #define FEC_ENET_RSEM_V	0x84
@@ -2276,9 +2278,34 @@ static int fec_set_features(struct net_device *netdev,
 	return 0;
 }
 
+u16 fec_enet_get_raw_vlan_tci(struct sk_buff *skb)
+{
+	struct vlan_ethhdr *vhdr;
+	unsigned short vlan_TCI = 0;
+
+	if (skb->protocol == ntohs(ETH_P_ALL)) {
+		vhdr = (struct vlan_ethhdr *)(skb->data);
+		vlan_TCI = ntohs(vhdr->h_vlan_TCI);
+	}
+
+	return vlan_TCI;
+}
+
 u16 fec_enet_select_queue(struct net_device *ndev, struct sk_buff *skb)
 {
-	return skb_tx_hash(ndev, skb);
+	struct fec_enet_private *fep = netdev_priv(ndev);
+	const struct platform_device_id *id_entry =
+				platform_get_device_id(fep->pdev);
+	u16 vlan_tag;
+
+	if (!(id_entry->driver_data & FEC_QUIRK_HAS_AVB))
+		return skb_tx_hash(ndev, skb);
+
+	vlan_tag = fec_enet_get_raw_vlan_tci(skb);
+	if (!vlan_tag)
+		return vlan_tag;
+
+	return  fec_enet_vlan_pri_to_queue[vlan_tag >> 13];
 }
 
 static const struct net_device_ops fec_netdev_ops = {
-- 
1.7.5.4

