From 3d724cb16742f1d11f70993e0538bf65c81dcae6 Mon Sep 17 00:00:00 2001
From: Fancy Fang <B47543@freescale.com>
Date: Wed, 8 Jan 2014 10:32:52 +0800
Subject: [PATCH 0695/1074] ENGR00294114 PXP: correct the PS U/V buffer
 settings when format is YVU420P

The PXP itself doesn't support YVU420P default. But we can get the
U and V address according to the format when we try to set PS_UBUF
and PS_VBUF registers. So the YVU420P can be supported indirectly.

Signed-off-by: Fancy Fang <B47543@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/dma/pxp/pxp_dma_v2.c |    9 +++++++--
 1 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/drivers/dma/pxp/pxp_dma_v2.c b/drivers/dma/pxp/pxp_dma_v2.c
index 7cc70bc..e0e4cd3 100644
--- a/drivers/dma/pxp/pxp_dma_v2.c
+++ b/drivers/dma/pxp/pxp_dma_v2.c
@@ -920,8 +920,13 @@ static void pxp_set_s0buf(struct pxps *pxp)
 		U1 = U + offset;
 		V = U + ((s0_params->width * s0_params->height) >> s);
 		V1 = V + offset;
-		__raw_writel(U1, pxp->base + HW_PXP_PS_UBUF);
-		__raw_writel(V1, pxp->base + HW_PXP_PS_VBUF);
+		if (s0_params->pixel_fmt == PXP_PIX_FMT_YVU420P) {
+			__raw_writel(V1, pxp->base + HW_PXP_PS_UBUF);
+			__raw_writel(U1, pxp->base + HW_PXP_PS_VBUF);
+		} else {
+			__raw_writel(U1, pxp->base + HW_PXP_PS_UBUF);
+			__raw_writel(V1, pxp->base + HW_PXP_PS_VBUF);
+		}
 	} else if ((s0_params->pixel_fmt == PXP_PIX_FMT_NV12) ||
 		 (s0_params->pixel_fmt == PXP_PIX_FMT_NV21) ||
 		 (s0_params->pixel_fmt == PXP_PIX_FMT_NV16) ||
-- 
1.7.5.4

