From de9bad8f699bd89589e4d3ef68758f3e547d8936 Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@freescale.com>
Date: Thu, 26 Dec 2013 10:45:42 +0800
Subject: [PATCH 0689/1074] ENGR00291282-4 usb: chipidea: imx: add HSIC
 support

Add imx6 HSIC support

Signed-off-by: Peter Chen <peter.chen@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/usb/chipidea/ci_hdrc_imx.c |  154 ++++++++++++++++++++++++++++++------
 drivers/usb/chipidea/ci_hdrc_imx.h |   11 +++-
 drivers/usb/chipidea/host.c        |   33 ++++++++
 drivers/usb/chipidea/usbmisc_imx.c |  116 ++++++++++++++++++++++++++-
 include/linux/usb/chipidea.h       |    3 +
 5 files changed, 289 insertions(+), 28 deletions(-)

diff --git a/drivers/usb/chipidea/ci_hdrc_imx.c b/drivers/usb/chipidea/ci_hdrc_imx.c
index f77fbfa..873e300 100644
--- a/drivers/usb/chipidea/ci_hdrc_imx.c
+++ b/drivers/usb/chipidea/ci_hdrc_imx.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2012-2014 Freescale Semiconductor, Inc.
  * Copyright (C) 2012 Marek Vasut <marex@denx.de>
  * on behalf of DENX Software Engineering GmbH
  *
@@ -30,6 +30,7 @@
 #define CI_HDRC_IMX_IMX28_WRITE_FIX		BIT(0)
 #define CI_HDRC_IMX_SUPPORT_RUNTIME_PM		BIT(1)
 #define CI_HDRC_IMX_MXS_PHY_EHCI_QUIRK		BIT(2)
+#define CI_HDRC_IMX_HAS_HSIC			BIT(3)
 
 struct ci_hdrc_imx_platform_flag {
 	unsigned int flags;
@@ -49,11 +50,13 @@ static const struct ci_hdrc_imx_platform_flag imx28_usb_data = {
 
 static const struct ci_hdrc_imx_platform_flag imx6q_usb_data = {
 	.flags = CI_HDRC_IMX_SUPPORT_RUNTIME_PM |
-		CI_HDRC_IMX_MXS_PHY_EHCI_QUIRK,
+		CI_HDRC_IMX_MXS_PHY_EHCI_QUIRK |
+		CI_HDRC_IMX_HAS_HSIC,
 };
 
 static const struct ci_hdrc_imx_platform_flag imx6sl_usb_data = {
-	.flags = CI_HDRC_IMX_SUPPORT_RUNTIME_PM,
+	.flags = CI_HDRC_IMX_SUPPORT_RUNTIME_PM |
+		CI_HDRC_IMX_HAS_HSIC,
 };
 
 static const struct of_device_id ci_hdrc_imx_dt_ids[] = {
@@ -75,6 +78,9 @@ struct ci_hdrc_imx_data {
 	bool in_lpm;
 	bool imx6_usb_charger_detection;
 	struct usb_charger charger;
+	struct regmap *anatop;
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pinctrl_hsic_active;
 };
 
 /* Common functions shared by usbmisc drivers */
@@ -114,6 +120,26 @@ static struct imx_usbmisc_data *usbmisc_get_init_data(struct device *dev)
 	if (of_find_property(np, "external-vbus-divider", NULL))
 		data->evdo = 1;
 
+	if (of_find_property(np, "osc-clkgate-delay", NULL)) {
+		ret = of_property_read_u32(np, "osc-clkgate-delay",
+			&data->osc_clkgate_delay);
+		if (ret) {
+			dev_err(dev,
+				"failed to get osc-clkgate-delay value\n");
+			return ERR_PTR(ret);
+		}
+		/*
+		 * 0 <= osc_clkgate_delay <=7
+		 * - 0x0 (default) is 0.5ms,
+		 * - 0x1-0x7: 1-7ms
+		 */
+		if (data->osc_clkgate_delay > 7) {
+			dev_err(dev,
+				"value of osc-clkgate-delay is incorrect\n");
+			return ERR_PTR(-EINVAL);
+		}
+	}
+
 	return data;
 }
 
@@ -143,6 +169,28 @@ static int ci_hdrc_imx_notify_event(struct ci_hdrc *ci, unsigned event)
 			return ret;
 		imx6_usb_charger_detect_post(&data->charger);
 		break;
+	case CI_HDRC_IMX_HSIC_ACTIVE_EVENT:
+		if (!IS_ERR(data->pinctrl) &&
+			!IS_ERR(data->pinctrl_hsic_active)) {
+			ret = pinctrl_select_state(data->pinctrl
+				, data->pinctrl_hsic_active);
+			if (ret)
+				dev_err(dev,
+					 "hsic_active select failed, err=%d\n",
+					 ret);
+			return ret;
+		}
+		break;
+	case CI_HDRC_IMX_HSIC_SUSPEND_EVENT:
+		if (data->usbmisc_data) {
+			ret = imx_usbmisc_hsic_set_connect(data->usbmisc_data);
+			if (ret)
+				dev_err(dev,
+					 "hsic_set_connect failed, err=%d\n",
+					 ret);
+			return ret;
+		}
+		break;
 	default:
 		dev_dbg(dev, "unknown event\n");
 	}
@@ -165,6 +213,7 @@ static int ci_hdrc_imx_probe(struct platform_device *pdev)
 			of_match_device(ci_hdrc_imx_dt_ids, &pdev->dev);
 	const struct ci_hdrc_imx_platform_flag *imx_platform_flag = of_id->data;
 	struct device_node *np = pdev->dev.of_node;
+	struct pinctrl_state *pinctrl_hsic_idle;
 
 	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
 	if (!data) {
@@ -178,6 +227,35 @@ static int ci_hdrc_imx_probe(struct platform_device *pdev)
 	if (IS_ERR(data->usbmisc_data))
 		return PTR_ERR(data->usbmisc_data);
 
+	data->pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR(data->pinctrl)) {
+		dev_dbg(&pdev->dev, "pinctrl get failed, err=%ld\n",
+			PTR_ERR(data->pinctrl));
+	} else {
+		pinctrl_hsic_idle = pinctrl_lookup_state(data->pinctrl, "idle");
+		if (IS_ERR(pinctrl_hsic_idle)) {
+			dev_dbg(&pdev->dev,
+				 "pinctrl_hsic_idle lookup failed, err=%ld\n",
+				 PTR_ERR(pinctrl_hsic_idle));
+		} else {
+			ret = pinctrl_select_state(data->pinctrl,
+					pinctrl_hsic_idle);
+			if (ret) {
+				dev_err(&pdev->dev,
+					 "hsic_idle select failed, err=%d\n",
+					 ret);
+				return ret;
+			}
+		}
+
+		data->pinctrl_hsic_active = pinctrl_lookup_state
+			(data->pinctrl, "active");
+		if (IS_ERR(data->pinctrl_hsic_active))
+			dev_dbg(&pdev->dev,
+				 "pinctrl_hsic_active lookup failed, err=%ld\n",
+				 PTR_ERR(data->pinctrl_hsic_active));
+	}
+
 	data->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(data->clk)) {
 		dev_err(&pdev->dev,
@@ -215,34 +293,44 @@ static int ci_hdrc_imx_probe(struct platform_device *pdev)
 	if (imx_platform_flag->flags & CI_HDRC_IMX_MXS_PHY_EHCI_QUIRK)
 		pdata.flags |= CI_HDRC_IMX_EHCI_QUIRK;
 
-	if (data->usbmisc_data) {
-		ret = imx_usbmisc_init(data->usbmisc_data);
-		if (ret) {
-			dev_err(&pdev->dev, "usbmisc init failed, ret=%d\n",
-					ret);
-			goto err_phy;
-		}
-	}
+	if (data->usbmisc_data && data->usbmisc_data->index > 1 &&
+		(imx_platform_flag->flags & CI_HDRC_IMX_HAS_HSIC))
+		pdata.flags |= CI_HDRC_IMX_IS_HSIC;
 
 	if (of_find_property(np, "imx6-usb-charger-detection", NULL))
 		data->imx6_usb_charger_detection = true;
 
-	if (data->imx6_usb_charger_detection) {
-		data->charger.anatop = syscon_regmap_lookup_by_phandle
+	if (of_find_property(np, "fsl,anatop", NULL)) {
+		data->anatop = syscon_regmap_lookup_by_phandle
 			(np, "fsl,anatop");
-		if (IS_ERR(data->charger.anatop)) {
+		if (IS_ERR(data->anatop)) {
 			dev_dbg(&pdev->dev,
 				"failed to find regmap for anatop\n");
-			ret = PTR_ERR(data->charger.anatop);
+			ret = PTR_ERR(data->anatop);
 			goto err_clk;
 		}
-		data->charger.dev = &pdev->dev;
-		ret = imx6_usb_create_charger(&data->charger,
-			"imx6_usb_charger");
-		if (ret && ret != -ENODEV)
-			goto err_clk;
-		if (!ret)
-			dev_dbg(&pdev->dev, "USB Charger is created\n");
+		if (data->usbmisc_data)
+			data->usbmisc_data->anatop = data->anatop;
+		if (data->imx6_usb_charger_detection) {
+			data->charger.anatop = data->anatop;
+			data->charger.dev = &pdev->dev;
+			ret = imx6_usb_create_charger(&data->charger,
+				"imx6_usb_charger");
+			if (ret && ret != -ENODEV)
+				goto err_clk;
+			if (!ret)
+				dev_dbg(&pdev->dev,
+					"USB Charger is created\n");
+		}
+	}
+
+	if (data->usbmisc_data) {
+		ret = imx_usbmisc_init(data->usbmisc_data);
+		if (ret) {
+			dev_err(&pdev->dev, "usbmisc init failed, ret=%d\n",
+					ret);
+			goto remove_charger;
+		}
 	}
 
 	data->ci_pdev = ci_hdrc_add_device(&pdev->dev,
@@ -331,6 +419,13 @@ static int imx_controller_suspend(struct device *dev)
 				ret);
 			return ret;
 		}
+		ret = imx_usbmisc_hsic_set_clk(data->usbmisc_data, false);
+		if (ret) {
+			dev_err(dev,
+				"usbmisc hsic_set_clk failed, ret=%d\n",
+				ret);
+			goto hsic_set_clk_fail;
+		}
 	}
 
 	clk_disable_unprepare(data->clk);
@@ -338,6 +433,11 @@ static int imx_controller_suspend(struct device *dev)
 	data->in_lpm = true;
 
 	return 0;
+
+hsic_set_clk_fail:
+	imx_usbmisc_set_wakeup(data->usbmisc_data, false);
+
+	return ret;
 }
 
 static int imx_controller_resume(struct device *dev)
@@ -362,13 +462,21 @@ static int imx_controller_resume(struct device *dev)
 			dev_err(dev,
 				"usbmisc set_wakeup failed, ret=%d\n",
 				ret);
-			ret = -EINVAL;
 			goto clk_disable;
 		}
+		ret = imx_usbmisc_hsic_set_clk(data->usbmisc_data, true);
+		if (ret) {
+			dev_err(dev,
+				"usbmisc hsic_set_clk failed, ret=%d\n",
+				ret);
+			goto hsic_set_clk_fail;
+		}
 	}
 
 	return 0;
 
+hsic_set_clk_fail:
+	imx_usbmisc_set_wakeup(data->usbmisc_data, true);
 clk_disable:
 	clk_disable_unprepare(data->clk);
 
diff --git a/drivers/usb/chipidea/ci_hdrc_imx.h b/drivers/usb/chipidea/ci_hdrc_imx.h
index fb507c0..b85f433 100644
--- a/drivers/usb/chipidea/ci_hdrc_imx.h
+++ b/drivers/usb/chipidea/ci_hdrc_imx.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2013 Freescale Semiconductor, Inc.
+ * Copyright 2012-2014 Freescale Semiconductor, Inc.
  *
  * The code contained herein is licensed under the GNU General Public
  * License. You may obtain a copy of the GNU General Public License
@@ -17,10 +17,19 @@ struct imx_usbmisc_data {
 
 	unsigned int disable_oc:1; /* over current detect disabled */
 	unsigned int evdo:1; /* set external vbus divider option */
+	/*
+	 * Specifies the delay between powering up the xtal 24MHz clock
+	 * and release the clock to the digital logic inside the analog block
+	 */
+	unsigned int osc_clkgate_delay;
+	struct regmap *anatop;
 };
 
 int imx_usbmisc_init(struct imx_usbmisc_data *);
 int imx_usbmisc_init_post(struct imx_usbmisc_data *);
 int imx_usbmisc_set_wakeup(struct imx_usbmisc_data *, bool);
+/* Call it before setting portsc.suspendM */
+int imx_usbmisc_hsic_set_connect(struct imx_usbmisc_data *);
+int imx_usbmisc_hsic_set_clk(struct imx_usbmisc_data *, bool);
 
 #endif /* __DRIVER_USB_CHIPIDEA_CI_HDRC_IMX_H */
diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index d9e9c01..ce3dc73 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -39,11 +39,27 @@ static int (*orig_hub_control)(struct usb_hcd *hcd,
 				u16 typeReq, u16 wValue, u16 wIndex,
 				char *buf, u16 wLength);
 
+/* This function is used to override WKCN, WKDN, and WKOC */
+static void ci_ehci_override_wakeup_flag(struct ehci_hcd *ehci,
+		u32 __iomem *reg, u32 flags, bool set)
+{
+	u32 val = ehci_readl(ehci, reg);
+
+	if (set)
+		val |= flags;
+	else
+		val &= ~flags;
+
+	ehci_writel(ehci, val, reg);
+}
+
 static int ci_ehci_bus_suspend(struct usb_hcd *hcd)
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	int port;
 	u32 tmp;
+	struct device *dev = hcd->self.controller;
+	struct ci_hdrc *ci = dev_get_drvdata(dev);
 
 	int ret = orig_bus_suspend(hcd);
 
@@ -89,6 +105,9 @@ static int ci_ehci_bus_suspend(struct usb_hcd *hcd)
 				usb_phy_notify_suspend(hcd->phy,
 					USB_SPEED_HIGH);
 		}
+		if (ci->platdata->flags & CI_HDRC_IMX_IS_HSIC)
+			ci_ehci_override_wakeup_flag(ehci, reg,
+				PORT_WKDISC_E | PORT_WKCONN_E, false);
 	}
 
 	return 0;
@@ -145,6 +164,8 @@ static int ci_imx_ehci_hub_control(
 	spin_lock_irqsave(&ehci->lock, flags);
 
 	if (typeReq == SetPortFeature && wValue == USB_PORT_FEAT_SUSPEND) {
+		struct device *dev = hcd->self.controller;
+		struct ci_hdrc *ci = dev_get_drvdata(dev);
 		temp = ehci_readl(ehci, status_reg);
 		if ((temp & PORT_PE) == 0 || (temp & PORT_RESET) != 0) {
 			retval = -EPIPE;
@@ -155,6 +176,13 @@ static int ci_imx_ehci_hub_control(
 		temp |= PORT_WKDISC_E | PORT_WKOC_E;
 		ehci_writel(ehci, temp | PORT_SUSPEND, status_reg);
 
+		if (ci->platdata->flags & CI_HDRC_IMX_IS_HSIC) {
+			if (ci->platdata->notify_event)
+				ci->platdata->notify_event
+					(ci, CI_HDRC_IMX_HSIC_SUSPEND_EVENT);
+			ci_ehci_override_wakeup_flag(ehci, status_reg,
+				PORT_WKDISC_E | PORT_WKCONN_E, false);
+		}
 		/*
 		 * If a transaction is in progress, there may be a delay in
 		 * suspending the port. Poll until the port is suspended.
@@ -252,6 +280,11 @@ static int host_start(struct ci_hdrc *ci)
 	else
 		ci->hcd = hcd;
 
+	if (ci->platdata->notify_event &&
+		(ci->platdata->flags & CI_HDRC_IMX_IS_HSIC))
+		ci->platdata->notify_event
+			(ci, CI_HDRC_IMX_HSIC_ACTIVE_EVENT);
+
 	if (ci->platdata->flags & CI_HDRC_DISABLE_STREAMING)
 		hw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);
 
diff --git a/drivers/usb/chipidea/usbmisc_imx.c b/drivers/usb/chipidea/usbmisc_imx.c
index 89d3bcc..14f97b0 100644
--- a/drivers/usb/chipidea/usbmisc_imx.c
+++ b/drivers/usb/chipidea/usbmisc_imx.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2013 Freescale Semiconductor, Inc.
+ * Copyright 2012-2014 Freescale Semiconductor, Inc.
  *
  * The code contained herein is licensed under the GNU General Public
  * License. You may obtain a copy of the GNU General Public License
@@ -14,6 +14,7 @@
 #include <linux/err.h>
 #include <linux/io.h>
 #include <linux/delay.h>
+#include <linux/regmap.h>
 
 #include "ci_hdrc_imx.h"
 
@@ -33,10 +34,25 @@
 
 #define MX6_BM_OVER_CUR_DIS		BIT(7)
 #define MX6_BM_WAKEUP_ENABLE		BIT(10)
+#define MX6_BM_UTMI_ON_CLOCK		BIT(13)
 #define MX6_BM_ID_WAKEUP		BIT(16)
 #define MX6_BM_VBUS_WAKEUP		BIT(17)
 #define MX6_BM_WAKEUP_INTR		BIT(31)
 
+#define MX6_USB_HSIC_CTRL_OFFSET	0x10
+/* Indicating whether HSIC clock is valid */
+#define MX6_BM_HSIC_CLK_VLD		BIT(31)
+/* set before portsc.suspendM = 1 */
+#define MX6_BM_HSIC_DEV_CONN		BIT(21)
+/* HSIC enable */
+#define MX6_BM_HSIC_EN			BIT(12)
+/* Force HSIC module 480M clock on, even when in Host is in suspend mode */
+#define MX6_BM_HSIC_CLK_ON		BIT(11)
+
+#define ANADIG_ANA_MISC0		0x150
+#define ANADIG_ANA_MISC0_SET		0x154
+#define ANADIG_ANA_MISC0_CLK_DELAY(x)	((x >> 26) & 0x7)
+
 struct usbmisc_ops {
 	/* It's called once when probe a usb device */
 	int (*init)(struct imx_usbmisc_data *data);
@@ -44,6 +60,10 @@ struct usbmisc_ops {
 	int (*post)(struct imx_usbmisc_data *data);
 	/* It's called when we need to enable usb wakeup */
 	int (*set_wakeup)(struct imx_usbmisc_data *data, bool enabled);
+	/* It's called before setting portsc.suspendM */
+	int (*hsic_set_connect)(struct imx_usbmisc_data *data);
+	/* It's called during suspend/resume */
+	int (*hsic_set_clk)(struct imx_usbmisc_data *data, bool enabled);
 };
 
 struct imx_usbmisc {
@@ -146,19 +166,85 @@ static int usbmisc_imx53_init(struct imx_usbmisc_data *data)
 static int usbmisc_imx6q_init(struct imx_usbmisc_data *data)
 {
 	unsigned long flags;
-	u32 reg;
+	u32 val;
 
 	if (data->index > 3)
 		return -EINVAL;
 
 	if (data->disable_oc) {
 		spin_lock_irqsave(&usbmisc->lock, flags);
-		reg = readl(usbmisc->base + data->index * 4);
-		writel(reg | MX6_BM_OVER_CUR_DIS,
+		val = readl(usbmisc->base + data->index * 4);
+		writel(val | MX6_BM_OVER_CUR_DIS,
 			usbmisc->base + data->index * 4);
 		spin_unlock_irqrestore(&usbmisc->lock, flags);
 	}
 
+	/* For HSIC controller */
+	if (data->index == 2 || data->index == 3) {
+		spin_lock_irqsave(&usbmisc->lock, flags);
+		val = readl(usbmisc->base + data->index * 4);
+		writel(val | MX6_BM_UTMI_ON_CLOCK,
+			usbmisc->base + data->index * 4);
+		val = readl(usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET
+			+ (data->index - 2) * 4);
+		val |= MX6_BM_HSIC_EN | MX6_BM_HSIC_CLK_ON;
+		writel(val, usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET
+			+ (data->index - 2) * 4);
+		spin_unlock_irqrestore(&usbmisc->lock, flags);
+
+		/*
+		 * Need to add delay to wait 24M OSC to be stable,
+		 * It is board specific.
+		 */
+		regmap_read(data->anatop, ANADIG_ANA_MISC0, &val);
+		/* 0 <= data->osc_clkgate_delay <= 7 */
+		if (data->osc_clkgate_delay > ANADIG_ANA_MISC0_CLK_DELAY(val))
+			regmap_write(data->anatop, ANADIG_ANA_MISC0_SET,
+				(data->osc_clkgate_delay) << 26);
+	}
+
+	return 0;
+}
+
+static int usbmisc_imx6q_hsic_set_connect(struct imx_usbmisc_data *data)
+{
+	unsigned long flags;
+	u32 val;
+
+	spin_lock_irqsave(&usbmisc->lock, flags);
+	if (data->index == 2 || data->index == 3) {
+		val = readl(usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET
+			+ (data->index - 2) * 4);
+		if (!(val & MX6_BM_HSIC_DEV_CONN))
+			writel(val | MX6_BM_HSIC_DEV_CONN,
+				usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET
+				+ (data->index - 2) * 4);
+	}
+	spin_unlock_irqrestore(&usbmisc->lock, flags);
+
+	return 0;
+}
+
+static int usbmisc_imx6q_hsic_set_clk
+	(struct imx_usbmisc_data *data, bool on)
+{
+	unsigned long flags;
+	u32 val;
+
+	spin_lock_irqsave(&usbmisc->lock, flags);
+	if (data->index == 2 || data->index == 3) {
+		val = readl(usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET
+			+ (data->index - 2) * 4);
+		val |= MX6_BM_HSIC_EN | MX6_BM_HSIC_CLK_ON;
+		if (on)
+			val |= MX6_BM_HSIC_CLK_ON;
+		else
+			val &= ~MX6_BM_HSIC_CLK_ON;
+		writel(val, usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET
+			+ (data->index - 2) * 4);
+	}
+	spin_unlock_irqrestore(&usbmisc->lock, flags);
+
 	return 0;
 }
 
@@ -201,6 +287,8 @@ static const struct usbmisc_ops imx53_usbmisc_ops = {
 static const struct usbmisc_ops imx6q_usbmisc_ops = {
 	.init = usbmisc_imx6q_init,
 	.set_wakeup = usbmisc_imx6q_set_wakeup,
+	.hsic_set_connect = usbmisc_imx6q_hsic_set_connect,
+	.hsic_set_clk	= usbmisc_imx6q_hsic_set_clk,
 };
 
 int imx_usbmisc_init(struct imx_usbmisc_data *data)
@@ -233,6 +321,26 @@ int imx_usbmisc_set_wakeup(struct imx_usbmisc_data *data, bool enabled)
 }
 EXPORT_SYMBOL_GPL(imx_usbmisc_set_wakeup);
 
+int imx_usbmisc_hsic_set_connect(struct imx_usbmisc_data *data)
+{
+	if (!usbmisc)
+		return -ENODEV;
+	if (!usbmisc->ops->hsic_set_connect)
+		return 0;
+	return usbmisc->ops->hsic_set_connect(data);
+}
+EXPORT_SYMBOL_GPL(imx_usbmisc_hsic_set_connect);
+
+int imx_usbmisc_hsic_set_clk(struct imx_usbmisc_data *data, bool on)
+{
+	if (!usbmisc)
+		return -ENODEV;
+	if (!usbmisc->ops->hsic_set_clk)
+		return 0;
+	return usbmisc->ops->hsic_set_clk(data, on);
+}
+EXPORT_SYMBOL_GPL(imx_usbmisc_hsic_set_clk);
+
 static const struct of_device_id usbmisc_imx_dt_ids[] = {
 	{
 		.compatible = "fsl,imx25-usbmisc",
diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index c75433e..2006d8e 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -27,11 +27,14 @@ struct ci_hdrc_platform_data {
 #define CI_HDRC_DUAL_ROLE_NOT_OTG	BIT(4)
 #define CI_HDRC_IMX28_WRITE_FIX		BIT(5)
 #define CI_HDRC_IMX_EHCI_QUIRK		BIT(6)
+#define CI_HDRC_IMX_IS_HSIC		BIT(7)
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1
 #define CI_HDRC_CONTROLLER_CHARGER_EVENT	2
 #define CI_HDRC_CONTROLLER_CHARGER_POST_EVENT	3
+#define CI_HDRC_IMX_HSIC_ACTIVE_EVENT		4
+#define CI_HDRC_IMX_HSIC_SUSPEND_EVENT		5
 	int	(*notify_event) (struct ci_hdrc *ci, unsigned event);
 #define CI_HDRC_NOTIFY_RET_DEFER_EVENT		1
 	struct regulator	*reg_vbus;
-- 
1.7.5.4

