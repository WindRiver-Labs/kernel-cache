From 558a8e8a719f60ee10390c17168adf7793f86876 Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@freescale.com>
Date: Tue, 19 Nov 2013 14:25:04 +0800
Subject: [PATCH 0626/1074] ENGR00288578-1 usb: chipidea: using correct low
 power timing

After PHY leaves low power mode, the controller needs 2ms
to reflect PHY's status correctly.

Signed-off-by: Peter Chen <peter.chen@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/usb/chipidea/core.c |   40 ++++++++++++++++------------------------
 1 files changed, 16 insertions(+), 24 deletions(-)

diff --git a/drivers/usb/chipidea/core.c b/drivers/usb/chipidea/core.c
index 09c487b..46ed297 100644
--- a/drivers/usb/chipidea/core.c
+++ b/drivers/usb/chipidea/core.c
@@ -165,32 +165,23 @@ u8 hw_port_test_get(struct ci_hdrc *ci)
 	return hw_read(ci, OP_PORTSC, PORTSC_PTC) >> __ffs(PORTSC_PTC);
 }
 
+static void hw_wait_phy_stable(void)
+{
+	/* The controller needs at least 1ms to reflect PHY's status */
+	usleep_range(2000, 2500);
+}
+
 /* The PHY enters/leaves low power mode */
 static void ci_hdrc_enter_lpm(struct ci_hdrc *ci, bool enable)
 {
 	enum ci_hw_regs reg = ci->hw_bank.lpm ? OP_DEVLC : OP_PORTSC;
 	bool lpm = !!(hw_read(ci, reg, PORTSC_PHCD(ci->hw_bank.lpm)));
 
-	if (enable && !lpm) {
+	if (enable && !lpm)
 		hw_write(ci, reg, PORTSC_PHCD(ci->hw_bank.lpm),
 				PORTSC_PHCD(ci->hw_bank.lpm));
-	} else  if (!enable && lpm) {
-		hw_write(ci, reg, PORTSC_PHCD(ci->hw_bank.lpm),
-				0);
-		/* 
-		 * The controller needs at least 1ms to reflect
-		 * PHY's status, the PHY also needs some time (less
-		 * than 1ms) to leave low power mode.
-		 */
-		usleep_range(1500, 2000);
-	} else if (!enable) {
-		/*
-		 * At wakeup interrupt, the phcd will be cleared by hardware
-		 * automatically, but the controller needs at least 1ms
-		 * to reflect PHY's status.
-		 */
-		usleep_range(1200, 1800);
-	}
+	else if (!enable && lpm)
+		hw_write(ci, reg, PORTSC_PHCD(ci->hw_bank.lpm), 0);
 }
 
 static int hw_device_init(struct ci_hdrc *ci, void __iomem *base)
@@ -512,9 +503,14 @@ static void ci_get_otg_capable(struct ci_hdrc *ci)
 
 static int ci_usb_phy_init(struct ci_hdrc *ci)
 {
+	int ret;
+
 	if (ci->platdata->phy) {
 		ci->transceiver = ci->platdata->phy;
-		return usb_phy_init(ci->transceiver);
+		ret = usb_phy_init(ci->transceiver);
+		if (!ret)
+			hw_wait_phy_stable();
+		return ret;
 	} else {
 		ci->global_phy = true;
 		ci->transceiver = usb_get_phy(USB_PHY_TYPE_USB2);
@@ -637,11 +633,6 @@ static int ci_hdrc_probe(struct platform_device *pdev)
 
 	if (ci->roles[CI_ROLE_HOST] && ci->roles[CI_ROLE_GADGET]) {
 		if (ci->is_otg) {
-			/*
-			 * ID pin needs 1ms debouce time,
-			 * we delay 2ms for safe.
-			 */
-			mdelay(2);
 			ci->role = ci_otg_role(ci);
 			ci_enable_otg_interrupt(ci, OTGSC_IDIE);
 		} else {
@@ -753,6 +744,7 @@ static int ci_controller_resume(struct device *dev)
 	if (ci->transceiver) {
 		usb_phy_set_suspend(ci->transceiver, 0);
 		usb_phy_set_wakeup(ci->transceiver, false);
+		hw_wait_phy_stable();
 	}
 
 	ci->in_lpm = false;
-- 
1.7.5.4

