From 150541ffce50c7095674e8e03f70f8e6d6e5e99b Mon Sep 17 00:00:00 2001
From: Fancy Fang <B47543@freescale.com>
Date: Mon, 6 Jan 2014 16:26:52 +0800
Subject: [PATCH 0688/1074] ENGR00293898 PXP: set the pxp_dispatch kernel
 thread to be freezable to avoid hang

By default, the kernel thread cannot be freezed during pm suspend.
So during pm suspend, the pxp_dipatch thread is still handling pxp
task and setting pxp registers. And in some time, this pxp register
setting may happen after the pxp_suspend done. So the hang issue
happens. This patch set the thread to be freezable to freeze it
before pxp_suspend called to avoid this hang issue.

Signed-off-by: Fancy Fang <B47543@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/dma/pxp/pxp_device.c |    5 +----
 drivers/dma/pxp/pxp_dma_v2.c |   26 +++++++++++++++-----------
 2 files changed, 16 insertions(+), 15 deletions(-)

diff --git a/drivers/dma/pxp/pxp_device.c b/drivers/dma/pxp/pxp_device.c
index 2b52ee1..09b2add 100644
--- a/drivers/dma/pxp/pxp_device.c
+++ b/drivers/dma/pxp/pxp_device.c
@@ -707,11 +707,8 @@ static long pxp_device_ioctl(struct file *filp,
 			ret = wait_event_interruptible
 			    (irq_info[chan_id].waitq,
 			     (atomic_read(&irq_info[chan_id].irq_pending) == 0));
-			if (ret < 0) {
-				printk(KERN_WARNING
-				       "WAIT4CMPLT: signal received.\n");
+			if (ret < 0)
 				return -ERESTARTSYS;
-			}
 
 			chan_handle.hist_status = irq_info[chan_id].hist_status;
 			ret = copy_to_user((struct pxp_chan_handle *)arg,
diff --git a/drivers/dma/pxp/pxp_dma_v2.c b/drivers/dma/pxp/pxp_dma_v2.c
index 42f6f83..7cc70bc 100644
--- a/drivers/dma/pxp/pxp_dma_v2.c
+++ b/drivers/dma/pxp/pxp_dma_v2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -21,24 +21,25 @@
  * Copyright 2008-2009 Embedded Alley Solutions, Inc All Rights Reserved.
  */
 
+#include <linux/clk.h>
 #include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/freezer.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/kernel.h>
+#include <linux/kthread.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
+#include <linux/of.h>
 #include <linux/platform_device.h>
-#include <linux/slab.h>
-#include <linux/vmalloc.h>
-#include <linux/dmaengine.h>
 #include <linux/pxp_dma.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
 #include <linux/timer.h>
-#include <linux/clk.h>
+#include <linux/vmalloc.h>
 #include <linux/workqueue.h>
-#include <linux/sched.h>
-#include <linux/of.h>
-#include <linux/kthread.h>
 
 #include "regs-pxp_v2.h"
 
@@ -1661,11 +1662,14 @@ static int pxp_dispatch_thread(void *argv)
 	struct pxp_channel *pending = NULL;
 	unsigned long flags;
 
+	set_freezable();
+
 	while (!kthread_should_stop()) {
 		int ret;
-		ret = wait_event_interruptible(pxp->thread_waitq,
-					has_pending_task(pxp, pending));
-		if (signal_pending(current))
+		ret = wait_event_freezable(pxp->thread_waitq,
+					has_pending_task(pxp, pending) ||
+					kthread_should_stop());
+		if (ret < 0)
 			continue;
 
 		spin_lock_irqsave(&pxp->lock, flags);
-- 
1.7.5.4

