From 263efccce89856124edc3bc587c68357c65ba096 Mon Sep 17 00:00:00 2001
From: Sandor Yu <R01008@freescale.com>
Date: Mon, 12 May 2014 13:50:15 +0800
Subject: [PATCH 0821/1074] ENGR00311686 csi v4l2 capture: enable swap
 function

Enable csi data swap function when csi v4l2 need do csc
between YUYV and UYVY.

Signed-off-by: Sandor Yu <R01008@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 .../media/platform/mxc/capture/csi_v4l2_capture.c  |   15 ++++++++++++++-
 1 files changed, 14 insertions(+), 1 deletions(-)

diff --git a/drivers/media/platform/mxc/capture/csi_v4l2_capture.c b/drivers/media/platform/mxc/capture/csi_v4l2_capture.c
index 98c9f21..c9a8fe0 100644
--- a/drivers/media/platform/mxc/capture/csi_v4l2_capture.c
+++ b/drivers/media/platform/mxc/capture/csi_v4l2_capture.c
@@ -49,6 +49,7 @@ static int csi_v4l2_master_attach(struct v4l2_int_device *slave);
 static void csi_v4l2_master_detach(struct v4l2_int_device *slave);
 static u8 camera_power(cam_data *cam, bool cameraOn);
 static struct v4l2_format cam_input_fmt;
+static bool bswapenable;
 
 /*! Information about this driver. */
 static struct v4l2_int_master csi_v4l2_master = {
@@ -942,6 +943,9 @@ static int csi_v4l2_s_fmt(cam_data *cam, struct v4l2_format *f)
 			       "resize to %d.\n", *height);
 		}
 
+		/* disable swap function */
+		csi_format_swap16(false);
+
 		switch (f->fmt.pix.pixelformat) {
 		case V4L2_PIX_FMT_RGB565:
 			size = f->fmt.pix.width * f->fmt.pix.height * 2;
@@ -954,10 +958,18 @@ static int csi_v4l2_s_fmt(cam_data *cam, struct v4l2_format *f)
 		case V4L2_PIX_FMT_UYVY:
 			size = f->fmt.pix.width * f->fmt.pix.height * 2;
 			bytesperline = f->fmt.pix.width * 2;
+			if (cam_input_fmt.fmt.pix.pixelformat == V4L2_PIX_FMT_YUYV) {
+				csi_format_swap16(true);
+				bswapenable = true;
+			}
 			break;
 		case V4L2_PIX_FMT_YUYV:
 			size = f->fmt.pix.width * f->fmt.pix.height * 2;
 			bytesperline = f->fmt.pix.width * 2;
+			if (cam_input_fmt.fmt.pix.pixelformat == V4L2_PIX_FMT_UYVY) {
+				csi_format_swap16(true);
+				bswapenable = true;
+			}
 			break;
 		case V4L2_PIX_FMT_YUV420:
 			size = f->fmt.pix.width * f->fmt.pix.height * 3 / 2;
@@ -1316,7 +1328,8 @@ static int csi_v4l_dqueue(cam_data *cam, struct v4l2_buffer *buf)
 	 * If want to do preview on LCD, use PxP CSC to convert from UYVY
 	 * to RGB565; but for encoding, usually we don't use RGB format.
 	 */
-	if (cam->v2f.fmt.pix.pixelformat != cam_input_fmt.fmt.pix.pixelformat) {
+	if (cam->v2f.fmt.pix.pixelformat != cam_input_fmt.fmt.pix.pixelformat
+			&& !bswapenable) {
 		sg_dma_address(&cam->sg[0]) = buf->m.offset;
 		/* last frame buffer as pxp output buffer  */
 		sg_dma_address(&cam->sg[1]) =
-- 
1.7.5.4

