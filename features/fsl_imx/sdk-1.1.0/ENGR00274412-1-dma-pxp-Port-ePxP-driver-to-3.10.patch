From c83dbcbb19e376f66c12223a2b2899fa6f2a1328 Mon Sep 17 00:00:00 2001
From: Robby Cai <R63905@freescale.com>
Date: Thu, 8 Aug 2013 11:23:54 +0800
Subject: [PATCH 0061/1074] ENGR00274412-1 dma: pxp: Port ePxP driver to 3.10

It's ported from v3.5.7, which contains ePxP DMAENGINE driver and
a client driver named pxp_device. This patch also includes the changes:
- use uapi header file
- remove VM_RESERVED since it's deprecated, and drop redundant VM_IO flag
  since it's automatically set in remap_pfn_range()
- use <linux/platform_data/dma-imx.h> instead of <mach/dma.h>
- use devm_kzalloc() instead in pxp_probe()
- use macro __KERNEL__ in pxp_dma uapi header to avoid definition conflict

Signed-off-by: Robby Cai <R63905@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/dma/Kconfig                   |   13 +
 drivers/dma/Makefile                  |    1 +
 drivers/dma/pxp/Makefile              |    2 +
 drivers/dma/pxp/pxp_device.c          |  491 ++++++++++
 drivers/dma/pxp/pxp_dma_v2.c          | 1680 +++++++++++++++++++++++++++++++++
 drivers/dma/pxp/regs-pxp_v2.h         | 1152 ++++++++++++++++++++++
 include/linux/platform_data/dma-imx.h |    7 +-
 include/uapi/linux/pxp_dma.h          |    2 +
 8 files changed, 3347 insertions(+), 1 deletions(-)
 create mode 100644 drivers/dma/pxp/Makefile
 create mode 100644 drivers/dma/pxp/pxp_device.c
 create mode 100644 drivers/dma/pxp/pxp_dma_v2.c
 create mode 100644 drivers/dma/pxp/regs-pxp_v2.h

diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index 605b016..88a4988 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -137,6 +137,19 @@ config MX3_IPU_IRQS
 	  To avoid bloating the irq_desc[] array we allocate a sufficient
 	  number of IRQ slots and map them dynamically to specific sources.
 
+config MXC_PXP_V2
+	bool "MXC PxP V2 support"
+	depends on ARM
+	select DMA_ENGINE
+	help
+          Support the PxP (Pixel Pipeline) on i.MX6 DualLite and i.MX6 SoloLite.
+	  If unsure, select N.
+
+config MXC_PXP_CLIENT_DEVICE
+	bool "MXC PxP Client Device"
+	default y
+	depends on MXC_PXP_V2
+
 config TXX9_DMAC
 	tristate "Toshiba TXx9 SoC DMA support"
 	depends on MACH_TX49XX || MACH_TX39XX
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index a029d0f4..0c5ef31 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -18,6 +18,7 @@ obj-$(CONFIG_MV_XOR) += mv_xor.o
 obj-$(CONFIG_DW_DMAC_CORE) += dw/
 obj-$(CONFIG_AT_HDMAC) += at_hdmac.o
 obj-$(CONFIG_MX3_IPU) += ipu/
+obj-$(CONFIG_MXC_PXP_V2) += pxp/
 obj-$(CONFIG_TXX9_DMAC) += txx9dmac.o
 obj-$(CONFIG_SH_DMAE_BASE) += sh/
 obj-$(CONFIG_COH901318) += coh901318.o coh901318_lli.o
diff --git a/drivers/dma/pxp/Makefile b/drivers/dma/pxp/Makefile
new file mode 100644
index 0000000..498ccca
--- /dev/null
+++ b/drivers/dma/pxp/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_MXC_PXP_V2) += pxp_dma_v2.o
+obj-$(CONFIG_MXC_PXP_CLIENT_DEVICE) += pxp_device.o
diff --git a/drivers/dma/pxp/pxp_device.c b/drivers/dma/pxp/pxp_device.c
new file mode 100644
index 0000000..140dce0
--- /dev/null
+++ b/drivers/dma/pxp/pxp_device.c
@@ -0,0 +1,491 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#include <linux/interrupt.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/pxp_dma.h>
+#include <linux/atomic.h>
+#include <linux/platform_data/dma-imx.h>
+
+static atomic_t open_count = ATOMIC_INIT(0);
+
+static DEFINE_SPINLOCK(pxp_mem_lock);
+static DEFINE_SPINLOCK(pxp_chan_lock);
+static LIST_HEAD(head);
+static LIST_HEAD(list);
+static struct pxp_irq_info irq_info[NR_PXP_VIRT_CHANNEL];
+
+struct pxp_chan_handle {
+	int chan_id;
+	int hist_status;
+};
+
+/* To track the allocated memory buffer */
+struct memalloc_record {
+	struct list_head list;
+	struct pxp_mem_desc mem;
+};
+
+struct pxp_chan_info {
+	int chan_id;
+	struct dma_chan *dma_chan;
+	struct list_head list;
+};
+
+static int pxp_alloc_dma_buffer(struct pxp_mem_desc *mem)
+{
+	mem->cpu_addr = (unsigned long)
+	    dma_alloc_coherent(NULL, PAGE_ALIGN(mem->size),
+			       (dma_addr_t *) (&mem->phys_addr),
+			       GFP_DMA | GFP_KERNEL);
+	pr_debug("[ALLOC] mem alloc phys_addr = 0x%x\n", mem->phys_addr);
+	if ((void *)(mem->cpu_addr) == NULL) {
+		printk(KERN_ERR "Physical memory allocation error!\n");
+		return -1;
+	}
+	return 0;
+}
+
+static void pxp_free_dma_buffer(struct pxp_mem_desc *mem)
+{
+	if (mem->cpu_addr != 0) {
+		dma_free_coherent(0, PAGE_ALIGN(mem->size),
+				  (void *)mem->cpu_addr, mem->phys_addr);
+	}
+}
+
+static int pxp_free_buffers(void)
+{
+	struct memalloc_record *rec, *n;
+	struct pxp_mem_desc mem;
+
+	list_for_each_entry_safe(rec, n, &head, list) {
+		mem = rec->mem;
+		if (mem.cpu_addr != 0) {
+			pxp_free_dma_buffer(&mem);
+			pr_debug("[FREE] freed paddr=0x%08X\n", mem.phys_addr);
+			/* delete from list */
+			list_del(&rec->list);
+			kfree(rec);
+		}
+	}
+
+	return 0;
+}
+
+/* Callback function triggered after PxP receives an EOF interrupt */
+static void pxp_dma_done(void *arg)
+{
+	struct pxp_tx_desc *tx_desc = to_tx_desc(arg);
+	struct dma_chan *chan = tx_desc->txd.chan;
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	int chan_id = pxp_chan->dma_chan.chan_id;
+
+	pr_debug("DMA Done ISR, chan_id %d\n", chan_id);
+
+	irq_info[chan_id].irq_pending++;
+	irq_info[chan_id].hist_status = tx_desc->hist_status;
+
+	wake_up_interruptible(&(irq_info[chan_id].waitq));
+}
+
+static int pxp_ioc_config_chan(unsigned long arg)
+{
+	struct scatterlist sg[3];
+	struct pxp_tx_desc *desc;
+	struct dma_async_tx_descriptor *txd;
+	struct pxp_chan_info *info;
+	struct pxp_config_data pxp_conf;
+	dma_cookie_t cookie;
+	int chan_id;
+	int i, length, ret;
+
+	ret = copy_from_user(&pxp_conf,
+			     (struct pxp_config_data *)arg,
+			     sizeof(struct pxp_config_data));
+	if (ret)
+		return -EFAULT;
+
+	chan_id = pxp_conf.chan_id;
+	if (chan_id < 0 || chan_id >= NR_PXP_VIRT_CHANNEL)
+		return -ENODEV;
+
+	init_waitqueue_head(&(irq_info[chan_id].waitq));
+
+	/* find the channel */
+	spin_lock(&pxp_chan_lock);
+	list_for_each_entry(info, &list, list) {
+		if (info->dma_chan->chan_id == chan_id)
+			break;
+	}
+	spin_unlock(&pxp_chan_lock);
+
+	sg_init_table(sg, 3);
+
+	txd =
+	    info->dma_chan->device->device_prep_slave_sg(info->dma_chan,
+							 sg, 3,
+							 DMA_TO_DEVICE,
+							 DMA_PREP_INTERRUPT,
+							 NULL);
+	if (!txd) {
+		pr_err("Error preparing a DMA transaction descriptor.\n");
+		return -EIO;
+	}
+
+	txd->callback_param = txd;
+	txd->callback = pxp_dma_done;
+
+	desc = to_tx_desc(txd);
+
+	length = desc->len;
+	for (i = 0; i < length; i++) {
+		if (i == 0) {	/* S0 */
+			memcpy(&desc->proc_data,
+			       &pxp_conf.proc_data,
+			       sizeof(struct pxp_proc_data));
+			memcpy(&desc->layer_param.s0_param,
+			       &pxp_conf.s0_param,
+			       sizeof(struct pxp_layer_param));
+		} else if (i == 1) {	/* Output */
+			memcpy(&desc->layer_param.out_param,
+			       &pxp_conf.out_param,
+			       sizeof(struct pxp_layer_param));
+		} else {
+			/* OverLay */
+			memcpy(&desc->layer_param.ol_param,
+			       &pxp_conf.ol_param,
+			       sizeof(struct pxp_layer_param));
+		}
+
+		desc = desc->next;
+	}
+
+	cookie = txd->tx_submit(txd);
+	if (cookie < 0) {
+		pr_err("Error tx_submit\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int pxp_device_open(struct inode *inode, struct file *filp)
+{
+	atomic_inc(&open_count);
+
+	return 0;
+}
+
+static int pxp_device_release(struct inode *inode, struct file *filp)
+{
+	if (atomic_dec_and_test(&open_count))
+		pxp_free_buffers();
+
+	return 0;
+}
+
+static int pxp_device_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct memalloc_record *rec, *n;
+	int request_size, found;
+
+	request_size = vma->vm_end - vma->vm_start;
+	found = 0;
+
+	pr_debug("start=0x%x, pgoff=0x%x, size=0x%x\n",
+		 (unsigned int)(vma->vm_start), (unsigned int)(vma->vm_pgoff),
+		 request_size);
+
+	spin_lock(&pxp_mem_lock);
+	list_for_each_entry_safe(rec, n, &head, list) {
+		if (rec->mem.phys_addr == (vma->vm_pgoff << PAGE_SHIFT) &&
+			(rec->mem.size <= request_size)) {
+			found = 1;
+			break;
+		}
+	}
+	spin_unlock(&pxp_mem_lock);
+
+	if (found == 0)
+		return -ENOMEM;
+
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	return remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+			       request_size, vma->vm_page_prot) ? -EAGAIN : 0;
+}
+
+static bool chan_filter(struct dma_chan *chan, void *arg)
+{
+	if (imx_dma_is_pxp(chan))
+		return true;
+	else
+		return false;
+}
+
+static long pxp_device_ioctl(struct file *filp,
+			    unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case PXP_IOC_GET_CHAN:
+		{
+			struct pxp_chan_info *info;
+			dma_cap_mask_t mask;
+
+			pr_debug("drv: PXP_IOC_GET_CHAN Line %d\n", __LINE__);
+			info = kzalloc(sizeof(*info), GFP_KERNEL);
+			if (!info) {
+				pr_err("%d: alloc err\n", __LINE__);
+				return -ENOMEM;
+			}
+
+			dma_cap_zero(mask);
+			dma_cap_set(DMA_SLAVE, mask);
+			dma_cap_set(DMA_PRIVATE, mask);
+			info->dma_chan =
+				dma_request_channel(mask, chan_filter, NULL);
+			if (!info->dma_chan) {
+				pr_err("Unsccessfully received channel!\n");
+				kfree(info);
+				return -EBUSY;
+			}
+			pr_debug("Successfully received channel."
+				 "chan_id %d\n", info->dma_chan->chan_id);
+
+			spin_lock(&pxp_chan_lock);
+			list_add_tail(&info->list, &list);
+			spin_unlock(&pxp_chan_lock);
+
+			if (put_user
+			    (info->dma_chan->chan_id, (u32 __user *) arg))
+				return -EFAULT;
+
+			break;
+		}
+	case PXP_IOC_PUT_CHAN:
+		{
+			int chan_id;
+			struct pxp_chan_info *info;
+
+			if (get_user(chan_id, (u32 __user *) arg))
+				return -EFAULT;
+
+			if (chan_id < 0 || chan_id >= NR_PXP_VIRT_CHANNEL)
+				return -ENODEV;
+
+			spin_lock(&pxp_chan_lock);
+			list_for_each_entry(info, &list, list) {
+				if (info->dma_chan->chan_id == chan_id)
+					break;
+			}
+			spin_unlock(&pxp_chan_lock);
+
+			pr_debug("%d release chan_id %d\n", __LINE__,
+				 info->dma_chan->chan_id);
+			/* REVISIT */
+			dma_release_channel(info->dma_chan);
+			spin_lock(&pxp_chan_lock);
+			list_del_init(&info->list);
+			spin_unlock(&pxp_chan_lock);
+			kfree(info);
+
+			break;
+		}
+	case PXP_IOC_CONFIG_CHAN:
+		{
+
+			int ret;
+
+			ret = pxp_ioc_config_chan(arg);
+			if (ret)
+				return ret;
+
+			break;
+		}
+	case PXP_IOC_START_CHAN:
+		{
+			struct pxp_chan_info *info;
+			int chan_id;
+
+			if (get_user(chan_id, (u32 __user *) arg))
+				return -EFAULT;
+
+			/* find the channel */
+			spin_lock(&pxp_chan_lock);
+			list_for_each_entry(info, &list, list) {
+				if (info->dma_chan->chan_id == chan_id)
+					break;
+			}
+			spin_unlock(&pxp_chan_lock);
+
+			dma_async_issue_pending(info->dma_chan);
+
+			break;
+		}
+	case PXP_IOC_GET_PHYMEM:
+		{
+			struct memalloc_record *rec;
+
+			rec = kzalloc(sizeof(*rec), GFP_KERNEL);
+			if (!rec)
+				return -ENOMEM;
+
+			ret = copy_from_user(&(rec->mem),
+					     (struct pxp_mem_desc *)arg,
+					     sizeof(struct pxp_mem_desc));
+			if (ret) {
+				kfree(rec);
+				return -EFAULT;
+			}
+
+			pr_debug("[ALLOC] mem alloc size = 0x%x\n",
+				 rec->mem.size);
+
+			ret = pxp_alloc_dma_buffer(&(rec->mem));
+			if (ret == -1) {
+				kfree(rec);
+				printk(KERN_ERR
+				       "Physical memory allocation error!\n");
+				break;
+			}
+			ret = copy_to_user((void __user *)arg, &(rec->mem),
+					   sizeof(struct pxp_mem_desc));
+			if (ret) {
+				kfree(rec);
+				ret = -EFAULT;
+				break;
+			}
+
+			spin_lock(&pxp_mem_lock);
+			list_add(&rec->list, &head);
+			spin_unlock(&pxp_mem_lock);
+
+			break;
+		}
+	case PXP_IOC_PUT_PHYMEM:
+		{
+			struct memalloc_record *rec, *n;
+			struct pxp_mem_desc pxp_mem;
+
+			ret = copy_from_user(&pxp_mem,
+					     (struct pxp_mem_desc *)arg,
+					     sizeof(struct pxp_mem_desc));
+			if (ret)
+				return -EACCES;
+
+			pr_debug("[FREE] mem freed cpu_addr = 0x%x\n",
+				 pxp_mem.cpu_addr);
+			if ((void *)pxp_mem.cpu_addr != NULL)
+				pxp_free_dma_buffer(&pxp_mem);
+
+			spin_lock(&pxp_mem_lock);
+			list_for_each_entry_safe(rec, n, &head, list) {
+				if (rec->mem.cpu_addr == pxp_mem.cpu_addr) {
+					/* delete from list */
+					list_del(&rec->list);
+					kfree(rec);
+					break;
+				}
+			}
+			spin_unlock(&pxp_mem_lock);
+
+			break;
+		}
+	case PXP_IOC_WAIT4CMPLT:
+		{
+			struct pxp_chan_handle chan_handle;
+			int ret, chan_id;
+
+			ret = copy_from_user(&chan_handle,
+					     (struct pxp_chan_handle *)arg,
+					     sizeof(struct pxp_chan_handle));
+			if (ret)
+				return -EFAULT;
+
+			chan_id = chan_handle.chan_id;
+			if (chan_id < 0 || chan_id >= NR_PXP_VIRT_CHANNEL)
+				return -ENODEV;
+
+			if (!wait_event_interruptible_timeout
+			    (irq_info[chan_id].waitq,
+			     (irq_info[chan_id].irq_pending != 0), 2 * HZ)) {
+				pr_warning("pxp blocking: timeout.\n");
+				return -ETIME;
+			} else if (signal_pending(current)) {
+				printk(KERN_WARNING
+				       "pxp interrupt received.\n");
+				return -ERESTARTSYS;
+			} else
+				irq_info[chan_id].irq_pending--;
+
+			chan_handle.hist_status = irq_info[chan_id].hist_status;
+			ret = copy_to_user((struct pxp_chan_handle *)arg,
+					   &chan_handle,
+					   sizeof(struct pxp_chan_handle));
+			if (ret)
+				return -EFAULT;
+			break;
+		}
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static const struct file_operations pxp_device_fops = {
+	.open = pxp_device_open,
+	.release = pxp_device_release,
+	.unlocked_ioctl = pxp_device_ioctl,
+	.mmap = pxp_device_mmap,
+};
+
+static struct miscdevice pxp_device_miscdev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "pxp_device",
+	.fops = &pxp_device_fops,
+};
+
+int register_pxp_device(void)
+{
+	int ret;
+
+	ret = misc_register(&pxp_device_miscdev);
+	if (ret)
+		return ret;
+
+	pr_debug("PxP_Device registered Successfully\n");
+	return 0;
+}
+
+void unregister_pxp_device(void)
+{
+	misc_deregister(&pxp_device_miscdev);
+}
diff --git a/drivers/dma/pxp/pxp_dma_v2.c b/drivers/dma/pxp/pxp_dma_v2.c
new file mode 100644
index 0000000..9641adc
--- /dev/null
+++ b/drivers/dma/pxp/pxp_dma_v2.c
@@ -0,0 +1,1680 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+/*
+ * Based on STMP378X PxP driver
+ * Copyright 2008-2009 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/dmaengine.h>
+#include <linux/pxp_dma.h>
+#include <linux/timer.h>
+#include <linux/clk.h>
+#include <linux/workqueue.h>
+#include <linux/sched.h>
+#include <linux/of.h>
+
+#include "regs-pxp_v2.h"
+
+#define	PXP_DOWNSCALE_THRESHOLD		0x4000
+
+static LIST_HEAD(head);
+static int timeout_in_ms = 600;
+
+struct pxp_dma {
+	struct dma_device dma;
+};
+
+struct pxps {
+	struct platform_device *pdev;
+	struct clk *clk;
+	void __iomem *base;
+	int irq;		/* PXP IRQ to the CPU */
+
+	spinlock_t lock;
+	struct mutex clk_mutex;
+	int clk_stat;
+#define	CLK_STAT_OFF		0
+#define	CLK_STAT_ON		1
+	int pxp_ongoing;
+	int lut_state;
+
+	struct device *dev;
+	struct pxp_dma pxp_dma;
+	struct pxp_channel channel[NR_PXP_VIRT_CHANNEL];
+	wait_queue_head_t done;
+	struct work_struct work;
+
+	/* describes most recent processing configuration */
+	struct pxp_config_data pxp_conf_state;
+
+	/* to turn clock off when pxp is inactive */
+	struct timer_list clk_timer;
+};
+
+#define to_pxp_dma(d) container_of(d, struct pxp_dma, dma)
+#define to_tx_desc(tx) container_of(tx, struct pxp_tx_desc, txd)
+#define to_pxp_channel(d) container_of(d, struct pxp_channel, dma_chan)
+#define to_pxp(id) container_of(id, struct pxps, pxp_dma)
+
+#define PXP_DEF_BUFS	2
+#define PXP_MIN_PIX	8
+
+#define PXP_WAITCON	((__raw_readl(pxp->base + HW_PXP_STAT) & \
+				BM_PXP_STAT_IRQ) != BM_PXP_STAT_IRQ)
+
+static uint32_t pxp_s0_formats[] = {
+	PXP_PIX_FMT_RGB24,
+	PXP_PIX_FMT_RGB565,
+	PXP_PIX_FMT_RGB555,
+	PXP_PIX_FMT_YUV420P,
+	PXP_PIX_FMT_YUV422P,
+};
+
+/*
+ * PXP common functions
+ */
+static void dump_pxp_reg(struct pxps *pxp)
+{
+	dev_dbg(pxp->dev, "PXP_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CTRL));
+	dev_dbg(pxp->dev, "PXP_STAT 0x%x",
+		__raw_readl(pxp->base + HW_PXP_STAT));
+	dev_dbg(pxp->dev, "PXP_OUT_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_CTRL));
+	dev_dbg(pxp->dev, "PXP_OUT_BUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_BUF));
+	dev_dbg(pxp->dev, "PXP_OUT_BUF2 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_BUF2));
+	dev_dbg(pxp->dev, "PXP_OUT_PITCH 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_PITCH));
+	dev_dbg(pxp->dev, "PXP_OUT_LRC 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_LRC));
+	dev_dbg(pxp->dev, "PXP_OUT_PS_ULC 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_PS_ULC));
+	dev_dbg(pxp->dev, "PXP_OUT_PS_LRC 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_PS_LRC));
+	dev_dbg(pxp->dev, "PXP_OUT_AS_ULC 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_AS_ULC));
+	dev_dbg(pxp->dev, "PXP_OUT_AS_LRC 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUT_AS_LRC));
+	dev_dbg(pxp->dev, "PXP_PS_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_CTRL));
+	dev_dbg(pxp->dev, "PXP_PS_BUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_BUF));
+	dev_dbg(pxp->dev, "PXP_PS_UBUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_UBUF));
+	dev_dbg(pxp->dev, "PXP_PS_VBUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_VBUF));
+	dev_dbg(pxp->dev, "PXP_PS_PITCH 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_PITCH));
+	dev_dbg(pxp->dev, "PXP_PS_BACKGROUND 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_BACKGROUND));
+	dev_dbg(pxp->dev, "PXP_PS_SCALE 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_SCALE));
+	dev_dbg(pxp->dev, "PXP_PS_OFFSET 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_OFFSET));
+	dev_dbg(pxp->dev, "PXP_PS_CLRKEYLOW 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_CLRKEYLOW));
+	dev_dbg(pxp->dev, "PXP_PS_CLRKEYHIGH 0x%x",
+		__raw_readl(pxp->base + HW_PXP_PS_CLRKEYHIGH));
+	dev_dbg(pxp->dev, "PXP_AS_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_AS_CTRL));
+	dev_dbg(pxp->dev, "PXP_AS_BUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_AS_BUF));
+	dev_dbg(pxp->dev, "PXP_AS_PITCH 0x%x",
+		__raw_readl(pxp->base + HW_PXP_AS_PITCH));
+	dev_dbg(pxp->dev, "PXP_AS_CLRKEYLOW 0x%x",
+		__raw_readl(pxp->base + HW_PXP_AS_CLRKEYLOW));
+	dev_dbg(pxp->dev, "PXP_AS_CLRKEYHIGH 0x%x",
+		__raw_readl(pxp->base + HW_PXP_AS_CLRKEYHIGH));
+	dev_dbg(pxp->dev, "PXP_CSC1_COEF0 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC1_COEF0));
+	dev_dbg(pxp->dev, "PXP_CSC1_COEF1 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC1_COEF1));
+	dev_dbg(pxp->dev, "PXP_CSC1_COEF2 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC1_COEF2));
+	dev_dbg(pxp->dev, "PXP_CSC2_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2_CTRL));
+	dev_dbg(pxp->dev, "PXP_CSC2_COEF0 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2_COEF0));
+	dev_dbg(pxp->dev, "PXP_CSC2_COEF1 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2_COEF1));
+	dev_dbg(pxp->dev, "PXP_CSC2_COEF2 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2_COEF2));
+	dev_dbg(pxp->dev, "PXP_CSC2_COEF3 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2_COEF3));
+	dev_dbg(pxp->dev, "PXP_CSC2_COEF4 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2_COEF4));
+	dev_dbg(pxp->dev, "PXP_CSC2_COEF5 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2_COEF5));
+	dev_dbg(pxp->dev, "PXP_LUT_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_LUT_CTRL));
+	dev_dbg(pxp->dev, "PXP_LUT_ADDR 0x%x",
+		__raw_readl(pxp->base + HW_PXP_LUT_ADDR));
+	dev_dbg(pxp->dev, "PXP_LUT_DATA 0x%x",
+		__raw_readl(pxp->base + HW_PXP_LUT_DATA));
+	dev_dbg(pxp->dev, "PXP_LUT_EXTMEM 0x%x",
+		__raw_readl(pxp->base + HW_PXP_LUT_EXTMEM));
+	dev_dbg(pxp->dev, "PXP_CFA 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CFA));
+	dev_dbg(pxp->dev, "PXP_HIST_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST_CTRL));
+	dev_dbg(pxp->dev, "PXP_HIST2_PARAM 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST2_PARAM));
+	dev_dbg(pxp->dev, "PXP_HIST4_PARAM 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST4_PARAM));
+	dev_dbg(pxp->dev, "PXP_HIST8_PARAM0 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST8_PARAM0));
+	dev_dbg(pxp->dev, "PXP_HIST8_PARAM1 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST8_PARAM1));
+	dev_dbg(pxp->dev, "PXP_HIST16_PARAM0 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST16_PARAM0));
+	dev_dbg(pxp->dev, "PXP_HIST16_PARAM1 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST16_PARAM1));
+	dev_dbg(pxp->dev, "PXP_HIST16_PARAM2 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST16_PARAM2));
+	dev_dbg(pxp->dev, "PXP_HIST16_PARAM3 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST16_PARAM3));
+	dev_dbg(pxp->dev, "PXP_POWER 0x%x",
+		__raw_readl(pxp->base + HW_PXP_POWER));
+	dev_dbg(pxp->dev, "PXP_NEXT 0x%x",
+		__raw_readl(pxp->base + HW_PXP_NEXT));
+	dev_dbg(pxp->dev, "PXP_DEBUGCTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_DEBUGCTRL));
+	dev_dbg(pxp->dev, "PXP_DEBUG 0x%x",
+		__raw_readl(pxp->base + HW_PXP_DEBUG));
+	dev_dbg(pxp->dev, "PXP_VERSION 0x%x",
+		__raw_readl(pxp->base + HW_PXP_VERSION));
+}
+
+static bool is_yuv(u32 pix_fmt)
+{
+	if ((pix_fmt == PXP_PIX_FMT_YUYV) |
+	    (pix_fmt == PXP_PIX_FMT_UYVY) |
+	    (pix_fmt == PXP_PIX_FMT_Y41P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV444) |
+	    (pix_fmt == PXP_PIX_FMT_NV12) |
+	    (pix_fmt == PXP_PIX_FMT_GREY) |
+	    (pix_fmt == PXP_PIX_FMT_GY04) |
+	    (pix_fmt == PXP_PIX_FMT_YVU410P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV410P) |
+	    (pix_fmt == PXP_PIX_FMT_YVU420P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV420P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV420P2) |
+	    (pix_fmt == PXP_PIX_FMT_YVU422P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV422P)) {
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static void pxp_set_ctrl(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
+	u32 ctrl;
+	u32 fmt_ctrl;
+
+	/* Configure S0 input format */
+	switch (pxp_conf->s0_param.pixel_fmt) {
+	case PXP_PIX_FMT_RGB24:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__RGB888;
+		break;
+	case PXP_PIX_FMT_RGB565:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__RGB565;
+		break;
+	case PXP_PIX_FMT_RGB555:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__RGB555;
+		break;
+	case PXP_PIX_FMT_YUV420P:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__YUV420;
+		break;
+	case PXP_PIX_FMT_GREY:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__Y8;
+		break;
+	case PXP_PIX_FMT_GY04:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__Y4;
+		break;
+	case PXP_PIX_FMT_YUV422P:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__YUV422;
+		break;
+	case PXP_PIX_FMT_UYVY:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__UYVY1P422;
+		break;
+	default:
+		fmt_ctrl = 0;
+	}
+
+	ctrl = BF_PXP_PS_CTRL_FORMAT(fmt_ctrl);
+	__raw_writel(ctrl, pxp->base + HW_PXP_PS_CTRL);
+
+	/* Configure output format based on out_channel format */
+	switch (pxp_conf->out_param.pixel_fmt) {
+	case PXP_PIX_FMT_RGB24:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__RGB888;
+		break;
+	case PXP_PIX_FMT_RGB565:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__RGB565;
+		break;
+	case PXP_PIX_FMT_RGB555:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__RGB555;
+		break;
+	case PXP_PIX_FMT_YUV420P:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__YUV2P420;
+		break;
+	case PXP_PIX_FMT_YUV422P:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__YUV2P422;
+		break;
+	case PXP_PIX_FMT_GREY:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__Y8;
+		break;
+	case PXP_PIX_FMT_GY04:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__Y4;
+		break;
+	default:
+		fmt_ctrl = 0;
+	}
+
+	ctrl = BF_PXP_OUT_CTRL_FORMAT(fmt_ctrl);
+	__raw_writel(ctrl, pxp->base + HW_PXP_OUT_CTRL);
+
+	ctrl = 0;
+	if (proc_data->scaling)
+		;
+	if (proc_data->vflip)
+		ctrl |= BM_PXP_CTRL_VFLIP;
+	if (proc_data->hflip)
+		ctrl |= BM_PXP_CTRL_HFLIP;
+	if (proc_data->rotate)
+		ctrl |= BF_PXP_CTRL_ROTATE(proc_data->rotate / 90);
+
+	/* H/W support: controls where rotation will occur in the PXP datapath,
+	 * will export an interfance if needed
+	 */
+	/* ctrl |= BM_PXP_CTRL_ROT_POS; post rotation */
+
+	__raw_writel(ctrl, pxp->base + HW_PXP_CTRL);
+}
+
+static int pxp_start(struct pxps *pxp)
+{
+	__raw_writel(BM_PXP_CTRL_IRQ_ENABLE, pxp->base + HW_PXP_CTRL_SET);
+	__raw_writel(BM_PXP_CTRL_ENABLE, pxp->base + HW_PXP_CTRL_SET);
+	dump_pxp_reg(pxp);
+
+	return 0;
+}
+
+static void pxp_set_outbuf(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *out_params = &pxp_conf->out_param;
+
+	__raw_writel(out_params->paddr, pxp->base + HW_PXP_OUT_BUF);
+
+	__raw_writel(BF_PXP_OUT_LRC_X(out_params->width - 1) |
+		     BF_PXP_OUT_LRC_Y(out_params->height - 1),
+		     pxp->base + HW_PXP_OUT_LRC);
+
+	if (out_params->pixel_fmt == PXP_PIX_FMT_RGB24)
+		__raw_writel(out_params->stride << 2,
+				pxp->base + HW_PXP_OUT_PITCH);
+	else if (out_params->pixel_fmt == PXP_PIX_FMT_RGB565)
+		__raw_writel(out_params->stride << 1,
+				pxp->base + HW_PXP_OUT_PITCH);
+	else
+		__raw_writel(out_params->stride, pxp->base + HW_PXP_OUT_PITCH);
+}
+
+static void pxp_set_s0colorkey(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *s0_params = &pxp_conf->s0_param;
+
+	/* Low and high are set equal. V4L does not allow a chromakey range */
+	if (s0_params->color_key == -1) {
+		/* disable color key */
+		__raw_writel(0xFFFFFF, pxp->base + HW_PXP_PS_CLRKEYLOW);
+		__raw_writel(0, pxp->base + HW_PXP_PS_CLRKEYHIGH);
+	} else {
+		__raw_writel(s0_params->color_key,
+			     pxp->base + HW_PXP_PS_CLRKEYLOW);
+		__raw_writel(s0_params->color_key,
+			     pxp->base + HW_PXP_PS_CLRKEYHIGH);
+	}
+}
+
+static void pxp_set_olcolorkey(int layer_no, struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *ol_params = &pxp_conf->ol_param[layer_no];
+
+	/* Low and high are set equal. V4L does not allow a chromakey range */
+	if (ol_params->color_key_enable != 0 && ol_params->color_key != -1) {
+		__raw_writel(ol_params->color_key,
+			     pxp->base + HW_PXP_AS_CLRKEYLOW);
+		__raw_writel(ol_params->color_key,
+			     pxp->base + HW_PXP_AS_CLRKEYHIGH);
+	} else {
+		/* disable color key */
+		__raw_writel(0xFFFFFF, pxp->base + HW_PXP_AS_CLRKEYLOW);
+		__raw_writel(0, pxp->base + HW_PXP_AS_CLRKEYHIGH);
+	}
+}
+
+static void pxp_set_oln(int layer_no, struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *olparams_data = &pxp_conf->ol_param[layer_no];
+	dma_addr_t phys_addr = olparams_data->paddr;
+	__raw_writel(phys_addr, pxp->base + HW_PXP_AS_BUF);
+
+	/* Fixme */
+	__raw_writel(0x0, pxp->base + HW_PXP_OUT_AS_ULC);
+	__raw_writel(BF_PXP_OUT_AS_LRC_X(olparams_data->width) |
+		     BF_PXP_OUT_AS_LRC_Y(olparams_data->height),
+		     pxp->base + HW_PXP_OUT_AS_LRC);
+
+	if (olparams_data->pixel_fmt == PXP_PIX_FMT_RGB24)
+		__raw_writel(olparams_data->width << 2,
+				pxp->base + HW_PXP_AS_PITCH);
+	else
+		__raw_writel(olparams_data->width << 1,
+				pxp->base + HW_PXP_AS_PITCH);
+}
+
+static void pxp_set_olparam(int layer_no, struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *olparams_data = &pxp_conf->ol_param[layer_no];
+	u32 olparam;
+
+	olparam = BF_PXP_AS_CTRL_ALPHA(olparams_data->global_alpha);
+	if (olparams_data->pixel_fmt == PXP_PIX_FMT_RGB24)
+		olparam |=
+		    BF_PXP_AS_CTRL_FORMAT(BV_PXP_AS_CTRL_FORMAT__RGB888);
+	else
+		olparam |=
+		    BF_PXP_AS_CTRL_FORMAT(BV_PXP_AS_CTRL_FORMAT__RGB565);
+	if (olparams_data->global_alpha_enable)
+		olparam |=
+		    BF_PXP_AS_CTRL_ALPHA_CTRL
+		    (BV_PXP_AS_CTRL_ALPHA_CTRL__Override);
+	if (olparams_data->color_key_enable)
+		olparam |= BM_PXP_AS_CTRL_ENABLE_COLORKEY;
+	if (olparams_data->combine_enable)
+		;
+	__raw_writel(olparam, pxp->base + HW_PXP_AS_CTRL);
+}
+
+static void pxp_set_s0param(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
+	u32 s0param;
+
+	/* contains the coordinate for the PS in the OUTPUT buffer. */
+	s0param = BF_PXP_OUT_PS_ULC_X(proc_data->drect.left);
+	s0param |= BF_PXP_OUT_PS_ULC_Y(proc_data->drect.top);
+	__raw_writel(s0param, pxp->base + HW_PXP_OUT_PS_ULC);
+	s0param = BF_PXP_OUT_PS_LRC_X(proc_data->drect.left +
+					proc_data->drect.width - 1);
+	s0param |= BF_PXP_OUT_PS_LRC_Y(proc_data->drect.top +
+					proc_data->drect.height - 1);
+	__raw_writel(s0param, pxp->base + HW_PXP_OUT_PS_LRC);
+}
+
+/* crop behavior is re-designed in h/w. */
+static void pxp_set_s0crop(struct pxps *pxp)
+{
+	/*
+	 * place-holder, it's implemented in other functions in this driver.
+	 * Refer to "Clipping source images" section in RM for detail.
+	 */
+}
+
+static int pxp_set_scaling(struct pxps *pxp)
+{
+	int ret = 0;
+	u32 xscale, yscale, s0scale;
+	struct pxp_proc_data *proc_data = &pxp->pxp_conf_state.proc_data;
+
+	if ((proc_data->srect.width == proc_data->drect.width) &&
+	    (proc_data->srect.height == proc_data->drect.height)) {
+		proc_data->scaling = 0;
+		__raw_writel(0x10001000, pxp->base + HW_PXP_PS_SCALE);
+		goto out;
+	}
+
+	proc_data->scaling = 1;
+	xscale = proc_data->srect.width * 0x1000 / proc_data->drect.width;
+	yscale = proc_data->srect.height * 0x1000 / proc_data->drect.height;
+	if (xscale > PXP_DOWNSCALE_THRESHOLD)
+		xscale = PXP_DOWNSCALE_THRESHOLD;
+	if (yscale > PXP_DOWNSCALE_THRESHOLD)
+		yscale = PXP_DOWNSCALE_THRESHOLD;
+	s0scale = BF_PXP_PS_SCALE_YSCALE(yscale) |
+		BF_PXP_PS_SCALE_XSCALE(xscale);
+	__raw_writel(s0scale, pxp->base + HW_PXP_PS_SCALE);
+
+out:
+	pxp_set_ctrl(pxp);
+
+	return ret;
+}
+
+static void pxp_set_bg(struct pxps *pxp)
+{
+	__raw_writel(pxp->pxp_conf_state.proc_data.bgcolor,
+		     pxp->base + HW_PXP_PS_BACKGROUND);
+}
+
+static void pxp_set_lut(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	int lut_op = pxp_conf->proc_data.lut_transform;
+	u32 reg_val;
+	int i;
+	bool use_cmap = (lut_op & PXP_LUT_USE_CMAP) ? true : false;
+	u8 *cmap = pxp_conf->proc_data.lut_map;
+	u32 entry_src;
+	u32 pix_val;
+	u8 entry[4];
+
+	/*
+	 * If LUT already configured as needed, return...
+	 * Unless CMAP is needed and it has been updated.
+	 */
+	if ((pxp->lut_state == lut_op) &&
+		!(use_cmap && pxp_conf->proc_data.lut_map_updated))
+		return;
+
+	if (lut_op == PXP_LUT_NONE) {
+		__raw_writel(BM_PXP_LUT_CTRL_BYPASS,
+			     pxp->base + HW_PXP_LUT_CTRL);
+	} else if (((lut_op & PXP_LUT_INVERT) != 0)
+		&& ((lut_op & PXP_LUT_BLACK_WHITE) != 0)) {
+		/* Fill out LUT table with inverted monochromized values */
+
+		/* clear bypass bit, set lookup mode & out mode */
+		__raw_writel(BF_PXP_LUT_CTRL_LOOKUP_MODE
+				(BV_PXP_LUT_CTRL_LOOKUP_MODE__DIRECT_Y8) |
+				BF_PXP_LUT_CTRL_OUT_MODE
+				(BV_PXP_LUT_CTRL_OUT_MODE__Y8),
+				pxp->base + HW_PXP_LUT_CTRL);
+
+		/* Initialize LUT address to 0 and set NUM_BYTES to 0 */
+		__raw_writel(0, pxp->base + HW_PXP_LUT_ADDR);
+
+		/* LUT address pointer auto-increments after each data write */
+		for (pix_val = 0; pix_val < 256; pix_val += 4) {
+			for (i = 0; i < 4; i++) {
+				entry_src = use_cmap ?
+					cmap[pix_val + i] : pix_val + i;
+				entry[i] = (entry_src < 0x80) ? 0xFF : 0x00;
+			}
+			reg_val = (entry[3] << 24) | (entry[2] << 16) |
+				(entry[1] << 8) | entry[0];
+			__raw_writel(reg_val, pxp->base + HW_PXP_LUT_DATA);
+		}
+	} else if ((lut_op & PXP_LUT_INVERT) != 0) {
+		/* Fill out LUT table with 8-bit inverted values */
+
+		/* clear bypass bit, set lookup mode & out mode */
+		__raw_writel(BF_PXP_LUT_CTRL_LOOKUP_MODE
+				(BV_PXP_LUT_CTRL_LOOKUP_MODE__DIRECT_Y8) |
+				BF_PXP_LUT_CTRL_OUT_MODE
+				(BV_PXP_LUT_CTRL_OUT_MODE__Y8),
+				pxp->base + HW_PXP_LUT_CTRL);
+
+		/* Initialize LUT address to 0 and set NUM_BYTES to 0 */
+		__raw_writel(0, pxp->base + HW_PXP_LUT_ADDR);
+
+		/* LUT address pointer auto-increments after each data write */
+		for (pix_val = 0; pix_val < 256; pix_val += 4) {
+			for (i = 0; i < 4; i++) {
+				entry_src = use_cmap ?
+					cmap[pix_val + i] : pix_val + i;
+				entry[i] = ~entry_src & 0xFF;
+			}
+			reg_val = (entry[3] << 24) | (entry[2] << 16) |
+				(entry[1] << 8) | entry[0];
+			__raw_writel(reg_val, pxp->base + HW_PXP_LUT_DATA);
+		}
+	} else if ((lut_op & PXP_LUT_BLACK_WHITE) != 0) {
+		/* Fill out LUT table with 8-bit monochromized values */
+
+		/* clear bypass bit, set lookup mode & out mode */
+		__raw_writel(BF_PXP_LUT_CTRL_LOOKUP_MODE
+				(BV_PXP_LUT_CTRL_LOOKUP_MODE__DIRECT_Y8) |
+				BF_PXP_LUT_CTRL_OUT_MODE
+				(BV_PXP_LUT_CTRL_OUT_MODE__Y8),
+				pxp->base + HW_PXP_LUT_CTRL);
+
+		/* Initialize LUT address to 0 and set NUM_BYTES to 0 */
+		__raw_writel(0, pxp->base + HW_PXP_LUT_ADDR);
+
+		/* LUT address pointer auto-increments after each data write */
+		for (pix_val = 0; pix_val < 256; pix_val += 4) {
+			for (i = 0; i < 4; i++) {
+				entry_src = use_cmap ?
+					cmap[pix_val + i] : pix_val + i;
+				entry[i] = (entry_src < 0x80) ? 0x00 : 0xFF;
+			}
+			reg_val = (entry[3] << 24) | (entry[2] << 16) |
+				(entry[1] << 8) | entry[0];
+			__raw_writel(reg_val, pxp->base + HW_PXP_LUT_DATA);
+		}
+	} else if (use_cmap) {
+		/* Fill out LUT table using colormap values */
+
+		/* clear bypass bit, set lookup mode & out mode */
+		__raw_writel(BF_PXP_LUT_CTRL_LOOKUP_MODE
+				(BV_PXP_LUT_CTRL_LOOKUP_MODE__DIRECT_Y8) |
+				BF_PXP_LUT_CTRL_OUT_MODE
+				(BV_PXP_LUT_CTRL_OUT_MODE__Y8),
+				pxp->base + HW_PXP_LUT_CTRL);
+
+		/* Initialize LUT address to 0 and set NUM_BYTES to 0 */
+		__raw_writel(0, pxp->base + HW_PXP_LUT_ADDR);
+
+		/* LUT address pointer auto-increments after each data write */
+		for (pix_val = 0; pix_val < 256; pix_val += 4) {
+			for (i = 0; i < 4; i++)
+				entry[i] = cmap[pix_val + i];
+			reg_val = (entry[3] << 24) | (entry[2] << 16) |
+				(entry[1] << 8) | entry[0];
+			__raw_writel(reg_val, pxp->base + HW_PXP_LUT_DATA);
+		}
+	}
+
+	pxp->lut_state = lut_op;
+}
+
+static void pxp_set_csc(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *s0_params = &pxp_conf->s0_param;
+	struct pxp_layer_param *ol_params = &pxp_conf->ol_param[0];
+	struct pxp_layer_param *out_params = &pxp_conf->out_param;
+
+	bool input_is_YUV = is_yuv(s0_params->pixel_fmt);
+	bool output_is_YUV = is_yuv(out_params->pixel_fmt);
+
+	if (input_is_YUV && output_is_YUV) {
+		/*
+		 * Input = YUV, Output = YUV
+		 * No CSC unless we need to do combining
+		 */
+		if (ol_params->combine_enable) {
+			/* Must convert to RGB for combining with RGB overlay */
+
+			/* CSC1 - YUV->RGB */
+			__raw_writel(0x04030000, pxp->base + HW_PXP_CSC1_COEF0);
+			__raw_writel(0x01230208, pxp->base + HW_PXP_CSC1_COEF1);
+			__raw_writel(0x076b079c, pxp->base + HW_PXP_CSC1_COEF2);
+
+			/* CSC2 - RGB->YUV */
+			__raw_writel(0x4, pxp->base + HW_PXP_CSC2_CTRL);
+			__raw_writel(0x0096004D, pxp->base + HW_PXP_CSC2_COEF0);
+			__raw_writel(0x05DA001D, pxp->base + HW_PXP_CSC2_COEF1);
+			__raw_writel(0x007005B6, pxp->base + HW_PXP_CSC2_COEF2);
+			__raw_writel(0x057C009E, pxp->base + HW_PXP_CSC2_COEF3);
+			__raw_writel(0x000005E6, pxp->base + HW_PXP_CSC2_COEF4);
+			__raw_writel(0x00000000, pxp->base + HW_PXP_CSC2_COEF5);
+		} else {
+			/* Input & Output both YUV, so bypass both CSCs */
+
+			/* CSC1 - Bypass */
+			__raw_writel(0x40000000, pxp->base + HW_PXP_CSC1_COEF0);
+
+			/* CSC2 - Bypass */
+			__raw_writel(0x1, pxp->base + HW_PXP_CSC2_CTRL);
+		}
+	} else if (input_is_YUV && !output_is_YUV) {
+		/*
+		 * Input = YUV, Output = RGB
+		 * Use CSC1 to convert to RGB
+		 */
+
+		/* CSC1 - YUV->RGB */
+		__raw_writel(0x84ab01f0, pxp->base + HW_PXP_CSC1_COEF0);
+		__raw_writel(0x01980204, pxp->base + HW_PXP_CSC1_COEF1);
+		__raw_writel(0x0730079c, pxp->base + HW_PXP_CSC1_COEF2);
+
+		/* CSC2 - Bypass */
+		__raw_writel(0x1, pxp->base + HW_PXP_CSC2_CTRL);
+	} else if (!input_is_YUV && output_is_YUV) {
+		/*
+		 * Input = RGB, Output = YUV
+		 * Use CSC2 to convert to YUV
+		 */
+
+		/* CSC1 - Bypass */
+		__raw_writel(0x40000000, pxp->base + HW_PXP_CSC1_COEF0);
+
+		/* CSC2 - RGB->YUV */
+		__raw_writel(0x4, pxp->base + HW_PXP_CSC2_CTRL);
+		__raw_writel(0x0096004D, pxp->base + HW_PXP_CSC2_COEF0);
+		__raw_writel(0x05DA001D, pxp->base + HW_PXP_CSC2_COEF1);
+		__raw_writel(0x007005B6, pxp->base + HW_PXP_CSC2_COEF2);
+		__raw_writel(0x057C009E, pxp->base + HW_PXP_CSC2_COEF3);
+		__raw_writel(0x000005E6, pxp->base + HW_PXP_CSC2_COEF4);
+		__raw_writel(0x00000000, pxp->base + HW_PXP_CSC2_COEF5);
+	} else {
+		/*
+		 * Input = RGB, Output = RGB
+		 * Input & Output both RGB, so bypass both CSCs
+		 */
+
+		/* CSC1 - Bypass */
+		__raw_writel(0x40000000, pxp->base + HW_PXP_CSC1_COEF0);
+
+		/* CSC2 - Bypass */
+		__raw_writel(0x1, pxp->base + HW_PXP_CSC2_CTRL);
+	}
+
+	/* YCrCb colorspace */
+	/* Not sure when we use this...no YCrCb formats are defined for PxP */
+	/*
+	   __raw_writel(0x84ab01f0, HW_PXP_CSCCOEFF0_ADDR);
+	   __raw_writel(0x01230204, HW_PXP_CSCCOEFF1_ADDR);
+	   __raw_writel(0x0730079c, HW_PXP_CSCCOEFF2_ADDR);
+	 */
+
+}
+
+static void pxp_set_s0buf(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *s0_params = &pxp_conf->s0_param;
+	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
+	dma_addr_t Y, U, V;
+	dma_addr_t Y1, U1, V1;
+	u32 offset, bpp = 1;
+
+	Y = s0_params->paddr;
+
+	if (s0_params->pixel_fmt == PXP_PIX_FMT_RGB565)
+		bpp = 2;
+	else if (s0_params->pixel_fmt == PXP_PIX_FMT_RGB24)
+		bpp = 4;
+	offset = (proc_data->srect.top * s0_params->width +
+		 proc_data->srect.left) * bpp;
+	/* clipping or cropping */
+	Y1 = Y + offset;
+	__raw_writel(Y1, pxp->base + HW_PXP_PS_BUF);
+	if ((s0_params->pixel_fmt == PXP_PIX_FMT_YUV420P) ||
+	    (s0_params->pixel_fmt == PXP_PIX_FMT_YVU420P) ||
+	    (s0_params->pixel_fmt == PXP_PIX_FMT_GREY)) {
+		/* Set to 1 if YUV format is 4:2:2 rather than 4:2:0 */
+		int s = 2;
+
+		offset = proc_data->srect.top * s0_params->width / 4 +
+			 proc_data->srect.left / 2;
+		U = Y + (s0_params->width * s0_params->height);
+		U1 = U + offset;
+		V = U + ((s0_params->width * s0_params->height) >> s);
+		V1 = V + offset;
+		__raw_writel(U1, pxp->base + HW_PXP_PS_UBUF);
+		__raw_writel(V1, pxp->base + HW_PXP_PS_VBUF);
+	}
+
+	/* TODO: only support RGB565, Y8, Y4, YUV420 */
+	if (s0_params->pixel_fmt == PXP_PIX_FMT_GREY ||
+	    s0_params->pixel_fmt == PXP_PIX_FMT_YUV420P)
+		__raw_writel(s0_params->width, pxp->base + HW_PXP_PS_PITCH);
+	else if (s0_params->pixel_fmt == PXP_PIX_FMT_GY04)
+		__raw_writel(s0_params->width >> 1,
+				pxp->base + HW_PXP_PS_PITCH);
+	else
+		__raw_writel(s0_params->width * 2, pxp->base + HW_PXP_PS_PITCH);
+}
+
+/**
+ * pxp_config() - configure PxP for a processing task
+ * @pxps:	PXP context.
+ * @pxp_chan:	PXP channel.
+ * @return:	0 on success or negative error code on failure.
+ */
+static int pxp_config(struct pxps *pxp, struct pxp_channel *pxp_chan)
+{
+	struct pxp_config_data *pxp_conf_data = &pxp->pxp_conf_state;
+	int ol_nr;
+	int i;
+
+	/* Configure PxP regs */
+	pxp_set_ctrl(pxp);
+	pxp_set_s0param(pxp);
+	pxp_set_s0crop(pxp);
+	pxp_set_scaling(pxp);
+	ol_nr = pxp_conf_data->layer_nr - 2;
+	while (ol_nr > 0) {
+		i = pxp_conf_data->layer_nr - 2 - ol_nr;
+		pxp_set_oln(i, pxp);
+		pxp_set_olparam(i, pxp);
+		/* only the color key in higher overlay will take effect. */
+		pxp_set_olcolorkey(i, pxp);
+		ol_nr--;
+	}
+	pxp_set_s0colorkey(pxp);
+	pxp_set_csc(pxp);
+	pxp_set_bg(pxp);
+	pxp_set_lut(pxp);
+
+	pxp_set_s0buf(pxp);
+	pxp_set_outbuf(pxp);
+
+	return 0;
+}
+
+static void pxp_clk_enable(struct pxps *pxp)
+{
+	mutex_lock(&pxp->clk_mutex);
+
+	if (pxp->clk_stat == CLK_STAT_ON) {
+		mutex_unlock(&pxp->clk_mutex);
+		return;
+	}
+
+	clk_prepare_enable(pxp->clk);
+	pxp->clk_stat = CLK_STAT_ON;
+
+	mutex_unlock(&pxp->clk_mutex);
+}
+
+static void pxp_clk_disable(struct pxps *pxp)
+{
+	unsigned long flags;
+
+	mutex_lock(&pxp->clk_mutex);
+
+	if (pxp->clk_stat == CLK_STAT_OFF) {
+		mutex_unlock(&pxp->clk_mutex);
+		return;
+	}
+
+	spin_lock_irqsave(&pxp->lock, flags);
+	if ((pxp->pxp_ongoing == 0) && list_empty(&head)) {
+		spin_unlock_irqrestore(&pxp->lock, flags);
+		clk_disable_unprepare(pxp->clk);
+		pxp->clk_stat = CLK_STAT_OFF;
+	} else
+		spin_unlock_irqrestore(&pxp->lock, flags);
+
+	mutex_unlock(&pxp->clk_mutex);
+}
+
+static inline void clkoff_callback(struct work_struct *w)
+{
+	struct pxps *pxp = container_of(w, struct pxps, work);
+
+	pxp_clk_disable(pxp);
+}
+
+static void pxp_clkoff_timer(unsigned long arg)
+{
+	struct pxps *pxp = (struct pxps *)arg;
+
+	if ((pxp->pxp_ongoing == 0) && list_empty(&head))
+		schedule_work(&pxp->work);
+	else
+		mod_timer(&pxp->clk_timer,
+			  jiffies + msecs_to_jiffies(timeout_in_ms));
+}
+
+static struct pxp_tx_desc *pxpdma_first_active(struct pxp_channel *pxp_chan)
+{
+	return list_entry(pxp_chan->active_list.next, struct pxp_tx_desc, list);
+}
+
+static struct pxp_tx_desc *pxpdma_first_queued(struct pxp_channel *pxp_chan)
+{
+	return list_entry(pxp_chan->queue.next, struct pxp_tx_desc, list);
+}
+
+/* called with pxp_chan->lock held */
+static void __pxpdma_dostart(struct pxp_channel *pxp_chan)
+{
+	struct pxp_dma *pxp_dma = to_pxp_dma(pxp_chan->dma_chan.device);
+	struct pxps *pxp = to_pxp(pxp_dma);
+	struct pxp_tx_desc *desc;
+	struct pxp_tx_desc *child;
+	int i = 0;
+
+	/* so far we presume only one transaction on active_list */
+	/* S0 */
+	desc = pxpdma_first_active(pxp_chan);
+	memcpy(&pxp->pxp_conf_state.s0_param,
+	       &desc->layer_param.s0_param, sizeof(struct pxp_layer_param));
+	memcpy(&pxp->pxp_conf_state.proc_data,
+	       &desc->proc_data, sizeof(struct pxp_proc_data));
+
+	/* Save PxP configuration */
+	list_for_each_entry(child, &desc->tx_list, list) {
+		if (i == 0) {	/* Output */
+			memcpy(&pxp->pxp_conf_state.out_param,
+			       &child->layer_param.out_param,
+			       sizeof(struct pxp_layer_param));
+		} else {	/* Overlay */
+			memcpy(&pxp->pxp_conf_state.ol_param[i - 1],
+			       &child->layer_param.ol_param,
+			       sizeof(struct pxp_layer_param));
+		}
+
+		i++;
+	}
+	pr_debug("%s:%d S0 w/h %d/%d paddr %08x\n", __func__, __LINE__,
+		 pxp->pxp_conf_state.s0_param.width,
+		 pxp->pxp_conf_state.s0_param.height,
+		 pxp->pxp_conf_state.s0_param.paddr);
+	pr_debug("%s:%d OUT w/h %d/%d paddr %08x\n", __func__, __LINE__,
+		 pxp->pxp_conf_state.out_param.width,
+		 pxp->pxp_conf_state.out_param.height,
+		 pxp->pxp_conf_state.out_param.paddr);
+}
+
+static void pxpdma_dostart_work(struct pxps *pxp)
+{
+	struct pxp_channel *pxp_chan = NULL;
+	unsigned long flags, flags1;
+
+	while (__raw_readl(pxp->base + HW_PXP_CTRL) & BM_PXP_CTRL_ENABLE)
+		;
+
+	spin_lock_irqsave(&pxp->lock, flags);
+	if (list_empty(&head)) {
+		pxp->pxp_ongoing = 0;
+		spin_unlock_irqrestore(&pxp->lock, flags);
+		return;
+	}
+
+	pxp_chan = list_entry(head.next, struct pxp_channel, list);
+
+	spin_lock_irqsave(&pxp_chan->lock, flags1);
+	if (!list_empty(&pxp_chan->active_list)) {
+		struct pxp_tx_desc *desc;
+		/* REVISIT */
+		desc = pxpdma_first_active(pxp_chan);
+		__pxpdma_dostart(pxp_chan);
+	}
+	spin_unlock_irqrestore(&pxp_chan->lock, flags1);
+
+	/* Configure PxP */
+	pxp_config(pxp, pxp_chan);
+
+	pxp_start(pxp);
+
+	spin_unlock_irqrestore(&pxp->lock, flags);
+}
+
+static void pxpdma_dequeue(struct pxp_channel *pxp_chan, struct list_head *list)
+{
+	struct pxp_tx_desc *desc = NULL;
+	do {
+		desc = pxpdma_first_queued(pxp_chan);
+		list_move_tail(&desc->list, list);
+	} while (!list_empty(&pxp_chan->queue));
+}
+
+static dma_cookie_t pxp_tx_submit(struct dma_async_tx_descriptor *tx)
+{
+	struct pxp_tx_desc *desc = to_tx_desc(tx);
+	struct pxp_channel *pxp_chan = to_pxp_channel(tx->chan);
+	dma_cookie_t cookie;
+	unsigned long flags;
+
+	dev_dbg(&pxp_chan->dma_chan.dev->device, "received TX\n");
+
+	mutex_lock(&pxp_chan->chan_mutex);
+
+	cookie = pxp_chan->dma_chan.cookie;
+
+	if (++cookie < 0)
+		cookie = 1;
+
+	/* from dmaengine.h: "last cookie value returned to client" */
+	pxp_chan->dma_chan.cookie = cookie;
+	tx->cookie = cookie;
+
+	/* pxp_chan->lock can be taken under ichan->lock, but not v.v. */
+	spin_lock_irqsave(&pxp_chan->lock, flags);
+
+	/* Here we add the tx descriptor to our PxP task queue. */
+	list_add_tail(&desc->list, &pxp_chan->queue);
+
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
+
+	dev_dbg(&pxp_chan->dma_chan.dev->device, "done TX\n");
+
+	mutex_unlock(&pxp_chan->chan_mutex);
+	return cookie;
+}
+
+/* Called with pxp_chan->chan_mutex held */
+static int pxp_desc_alloc(struct pxp_channel *pxp_chan, int n)
+{
+	struct pxp_tx_desc *desc = vmalloc(n * sizeof(struct pxp_tx_desc));
+
+	if (!desc)
+		return -ENOMEM;
+
+	pxp_chan->n_tx_desc = n;
+	pxp_chan->desc = desc;
+	INIT_LIST_HEAD(&pxp_chan->active_list);
+	INIT_LIST_HEAD(&pxp_chan->queue);
+	INIT_LIST_HEAD(&pxp_chan->free_list);
+
+	while (n--) {
+		struct dma_async_tx_descriptor *txd = &desc->txd;
+
+		memset(txd, 0, sizeof(*txd));
+		INIT_LIST_HEAD(&desc->tx_list);
+		dma_async_tx_descriptor_init(txd, &pxp_chan->dma_chan);
+		txd->tx_submit = pxp_tx_submit;
+
+		list_add(&desc->list, &pxp_chan->free_list);
+
+		desc++;
+	}
+
+	return 0;
+}
+
+/**
+ * pxp_init_channel() - initialize a PXP channel.
+ * @pxp_dma:   PXP DMA context.
+ * @pchan:  pointer to the channel object.
+ * @return      0 on success or negative error code on failure.
+ */
+static int pxp_init_channel(struct pxp_dma *pxp_dma,
+			    struct pxp_channel *pxp_chan)
+{
+	unsigned long flags;
+	struct pxps *pxp = to_pxp(pxp_dma);
+	int ret = 0, n_desc = 0;
+
+	/*
+	 * We are using _virtual_ channel here.
+	 * Each channel contains all parameters of corresponding layers
+	 * for one transaction; each layer is represented as one descriptor
+	 * (i.e., pxp_tx_desc) here.
+	 */
+
+	spin_lock_irqsave(&pxp->lock, flags);
+
+	/* max desc nr: S0+OL+OUT = 1+8+1 */
+	n_desc = 16;
+
+	spin_unlock_irqrestore(&pxp->lock, flags);
+
+	if (n_desc && !pxp_chan->desc)
+		ret = pxp_desc_alloc(pxp_chan, n_desc);
+
+	return ret;
+}
+
+/**
+ * pxp_uninit_channel() - uninitialize a PXP channel.
+ * @pxp_dma:   PXP DMA context.
+ * @pchan:  pointer to the channel object.
+ * @return      0 on success or negative error code on failure.
+ */
+static int pxp_uninit_channel(struct pxp_dma *pxp_dma,
+			      struct pxp_channel *pxp_chan)
+{
+	int ret = 0;
+
+	if (pxp_chan->desc)
+		vfree(pxp_chan->desc);
+
+	pxp_chan->desc = NULL;
+
+	return ret;
+}
+
+static irqreturn_t pxp_irq(int irq, void *dev_id)
+{
+	struct pxps *pxp = dev_id;
+	struct pxp_channel *pxp_chan;
+	struct pxp_tx_desc *desc;
+	dma_async_tx_callback callback;
+	void *callback_param;
+	unsigned long flags;
+	u32 hist_status;
+
+	dump_pxp_reg(pxp);
+
+	hist_status =
+	    __raw_readl(pxp->base + HW_PXP_HIST_CTRL) & BM_PXP_HIST_CTRL_STATUS;
+
+	__raw_writel(BM_PXP_STAT_IRQ, pxp->base + HW_PXP_STAT_CLR);
+
+	spin_lock_irqsave(&pxp->lock, flags);
+
+	if (list_empty(&head)) {
+		pxp->pxp_ongoing = 0;
+		spin_unlock_irqrestore(&pxp->lock, flags);
+		return IRQ_NONE;
+	}
+
+	pxp_chan = list_entry(head.next, struct pxp_channel, list);
+	list_del_init(&pxp_chan->list);
+
+	if (list_empty(&pxp_chan->active_list)) {
+		pr_debug("PXP_IRQ pxp_chan->active_list empty. chan_id %d\n",
+			 pxp_chan->dma_chan.chan_id);
+		pxp->pxp_ongoing = 0;
+		spin_unlock_irqrestore(&pxp->lock, flags);
+		return IRQ_NONE;
+	}
+
+	/* Get descriptor and call callback */
+	desc = pxpdma_first_active(pxp_chan);
+
+	pxp_chan->completed = desc->txd.cookie;
+
+	callback = desc->txd.callback;
+	callback_param = desc->txd.callback_param;
+
+	/* Send histogram status back to caller */
+	desc->hist_status = hist_status;
+
+	if ((desc->txd.flags & DMA_PREP_INTERRUPT) && callback)
+		callback(callback_param);
+
+	pxp_chan->status = PXP_CHANNEL_INITIALIZED;
+
+	list_splice_init(&desc->tx_list, &pxp_chan->free_list);
+	list_move(&desc->list, &pxp_chan->free_list);
+
+	wake_up(&pxp->done);
+	pxp->pxp_ongoing = 0;
+	mod_timer(&pxp->clk_timer, jiffies + msecs_to_jiffies(timeout_in_ms));
+
+	spin_unlock_irqrestore(&pxp->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/* called with pxp_chan->lock held */
+static struct pxp_tx_desc *pxpdma_desc_get(struct pxp_channel *pxp_chan)
+{
+	struct pxp_tx_desc *desc, *_desc;
+	struct pxp_tx_desc *ret = NULL;
+
+	list_for_each_entry_safe(desc, _desc, &pxp_chan->free_list, list) {
+		list_del_init(&desc->list);
+		ret = desc;
+		break;
+	}
+
+	return ret;
+}
+
+/* called with pxp_chan->lock held */
+static void pxpdma_desc_put(struct pxp_channel *pxp_chan,
+			    struct pxp_tx_desc *desc)
+{
+	if (desc) {
+		struct device *dev = &pxp_chan->dma_chan.dev->device;
+		struct pxp_tx_desc *child;
+
+		list_for_each_entry(child, &desc->tx_list, list)
+		    dev_info(dev, "moving child desc %p to freelist\n", child);
+		list_splice_init(&desc->tx_list, &pxp_chan->free_list);
+		dev_info(dev, "moving desc %p to freelist\n", desc);
+		list_add(&desc->list, &pxp_chan->free_list);
+	}
+}
+
+/* Allocate and initialise a transfer descriptor. */
+static struct dma_async_tx_descriptor *pxp_prep_slave_sg(struct dma_chan *chan,
+							 struct scatterlist
+							 *sgl,
+							 unsigned int sg_len,
+							 enum
+							 dma_transfer_direction
+							 direction,
+							 unsigned long tx_flags,
+							 void *context)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxp_dma *pxp_dma = to_pxp_dma(chan->device);
+	struct pxps *pxp = to_pxp(pxp_dma);
+	struct pxp_tx_desc *desc = NULL;
+	struct pxp_tx_desc *first = NULL, *prev = NULL;
+	struct scatterlist *sg;
+	unsigned long flags;
+	dma_addr_t phys_addr;
+	int i;
+
+	if (direction != DMA_DEV_TO_MEM && direction != DMA_MEM_TO_DEV) {
+		dev_err(chan->device->dev, "Invalid DMA direction %d!\n",
+			direction);
+		return NULL;
+	}
+
+	if (unlikely(sg_len < 2))
+		return NULL;
+
+	spin_lock_irqsave(&pxp_chan->lock, flags);
+	for_each_sg(sgl, sg, sg_len, i) {
+		desc = pxpdma_desc_get(pxp_chan);
+		if (!desc) {
+			pxpdma_desc_put(pxp_chan, first);
+			dev_err(chan->device->dev, "Can't get DMA desc.\n");
+			spin_unlock_irqrestore(&pxp_chan->lock, flags);
+			return NULL;
+		}
+
+		phys_addr = sg_dma_address(sg);
+
+		if (!first) {
+			first = desc;
+
+			desc->layer_param.s0_param.paddr = phys_addr;
+		} else {
+			list_add_tail(&desc->list, &first->tx_list);
+			prev->next = desc;
+			desc->next = NULL;
+
+			if (i == 1)
+				desc->layer_param.out_param.paddr = phys_addr;
+			else
+				desc->layer_param.ol_param.paddr = phys_addr;
+		}
+
+		prev = desc;
+	}
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
+
+	pxp->pxp_conf_state.layer_nr = sg_len;
+	first->txd.flags = tx_flags;
+	first->len = sg_len;
+	pr_debug("%s:%d first %p, first->len %d, flags %08x\n",
+		 __func__, __LINE__, first, first->len, first->txd.flags);
+
+	return &first->txd;
+}
+
+static void pxp_issue_pending(struct dma_chan *chan)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxp_dma *pxp_dma = to_pxp_dma(chan->device);
+	struct pxps *pxp = to_pxp(pxp_dma);
+	unsigned long flags0, flags;
+
+	spin_lock_irqsave(&pxp->lock, flags0);
+	spin_lock_irqsave(&pxp_chan->lock, flags);
+
+	if (!list_empty(&pxp_chan->queue)) {
+		pxpdma_dequeue(pxp_chan, &pxp_chan->active_list);
+		pxp_chan->status = PXP_CHANNEL_READY;
+		list_add_tail(&pxp_chan->list, &head);
+	} else {
+		spin_unlock_irqrestore(&pxp_chan->lock, flags);
+		spin_unlock_irqrestore(&pxp->lock, flags0);
+		return;
+	}
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
+	spin_unlock_irqrestore(&pxp->lock, flags0);
+
+	pxp_clk_enable(pxp);
+	if (!wait_event_interruptible_timeout(pxp->done, PXP_WAITCON, 2 * HZ) ||
+		signal_pending(current)) {
+		pxp_clk_disable(pxp);
+		return;
+	}
+
+	spin_lock_irqsave(&pxp->lock, flags);
+	pxp->pxp_ongoing = 1;
+	spin_unlock_irqrestore(&pxp->lock, flags);
+	pxpdma_dostart_work(pxp);
+}
+
+static void __pxp_terminate_all(struct dma_chan *chan)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	unsigned long flags;
+
+	/* pchan->queue is modified in ISR, have to spinlock */
+	spin_lock_irqsave(&pxp_chan->lock, flags);
+	list_splice_init(&pxp_chan->queue, &pxp_chan->free_list);
+	list_splice_init(&pxp_chan->active_list, &pxp_chan->free_list);
+
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
+
+	pxp_chan->status = PXP_CHANNEL_INITIALIZED;
+}
+
+static int pxp_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
+			unsigned long arg)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+
+	/* Only supports DMA_TERMINATE_ALL */
+	if (cmd != DMA_TERMINATE_ALL)
+		return -ENXIO;
+
+	mutex_lock(&pxp_chan->chan_mutex);
+	__pxp_terminate_all(chan);
+	mutex_unlock(&pxp_chan->chan_mutex);
+
+	return 0;
+}
+
+static int pxp_alloc_chan_resources(struct dma_chan *chan)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxp_dma *pxp_dma = to_pxp_dma(chan->device);
+	int ret;
+
+	/* dmaengine.c now guarantees to only offer free channels */
+	BUG_ON(chan->client_count > 1);
+	WARN_ON(pxp_chan->status != PXP_CHANNEL_FREE);
+
+	chan->cookie = 1;
+	pxp_chan->completed = -ENXIO;
+
+	pr_debug("%s dma_chan.chan_id %d\n", __func__, chan->chan_id);
+	ret = pxp_init_channel(pxp_dma, pxp_chan);
+	if (ret < 0)
+		goto err_chan;
+
+	pxp_chan->status = PXP_CHANNEL_INITIALIZED;
+
+	dev_dbg(&chan->dev->device, "Found channel 0x%x, irq %d\n",
+		chan->chan_id, pxp_chan->eof_irq);
+
+	return ret;
+
+err_chan:
+	return ret;
+}
+
+static void pxp_free_chan_resources(struct dma_chan *chan)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxp_dma *pxp_dma = to_pxp_dma(chan->device);
+
+	mutex_lock(&pxp_chan->chan_mutex);
+
+	__pxp_terminate_all(chan);
+
+	pxp_chan->status = PXP_CHANNEL_FREE;
+
+	pxp_uninit_channel(pxp_dma, pxp_chan);
+
+	mutex_unlock(&pxp_chan->chan_mutex);
+}
+
+static enum dma_status pxp_tx_status(struct dma_chan *chan,
+				     dma_cookie_t cookie,
+				     struct dma_tx_state *txstate)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+
+	if (cookie != chan->cookie)
+		return DMA_ERROR;
+
+	if (txstate) {
+		txstate->last = pxp_chan->completed;
+		txstate->used = chan->cookie;
+		txstate->residue = 0;
+	}
+	return DMA_SUCCESS;
+}
+
+static int pxp_hw_init(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
+	u32 reg_val;
+
+	/* Pull PxP out of reset */
+	__raw_writel(0, pxp->base + HW_PXP_CTRL);
+
+	/* Config defaults */
+
+	/* Initialize non-channel-specific PxP parameters */
+	proc_data->drect.left = proc_data->srect.left = 0;
+	proc_data->drect.top = proc_data->srect.top = 0;
+	proc_data->drect.width = proc_data->srect.width = 0;
+	proc_data->drect.height = proc_data->srect.height = 0;
+	proc_data->scaling = 0;
+	proc_data->hflip = 0;
+	proc_data->vflip = 0;
+	proc_data->rotate = 0;
+	proc_data->bgcolor = 0;
+
+	/* Initialize S0 channel parameters */
+	pxp_conf->s0_param.pixel_fmt = pxp_s0_formats[0];
+	pxp_conf->s0_param.width = 0;
+	pxp_conf->s0_param.height = 0;
+	pxp_conf->s0_param.color_key = -1;
+	pxp_conf->s0_param.color_key_enable = false;
+
+	/* Initialize OL channel parameters */
+	pxp_conf->ol_param[0].combine_enable = false;
+	pxp_conf->ol_param[0].width = 0;
+	pxp_conf->ol_param[0].height = 0;
+	pxp_conf->ol_param[0].pixel_fmt = PXP_PIX_FMT_RGB565;
+	pxp_conf->ol_param[0].color_key_enable = false;
+	pxp_conf->ol_param[0].color_key = -1;
+	pxp_conf->ol_param[0].global_alpha_enable = false;
+	pxp_conf->ol_param[0].global_alpha = 0;
+	pxp_conf->ol_param[0].local_alpha_enable = false;
+
+	/* Initialize Output channel parameters */
+	pxp_conf->out_param.width = 0;
+	pxp_conf->out_param.height = 0;
+	pxp_conf->out_param.pixel_fmt = PXP_PIX_FMT_RGB565;
+
+	proc_data->overlay_state = 0;
+
+	/* Write default h/w config */
+	pxp_set_ctrl(pxp);
+	pxp_set_s0param(pxp);
+	pxp_set_s0crop(pxp);
+	/*
+	 * simply program the ULC to a higher value than the LRC
+	 * to avoid any AS pixels to show up in the output buffer.
+	 */
+	__raw_writel(0xFFFFFFFF, pxp->base + HW_PXP_OUT_AS_ULC);
+	pxp_set_olparam(0, pxp);
+	pxp_set_olcolorkey(0, pxp);
+
+	pxp_set_s0colorkey(pxp);
+	pxp_set_csc(pxp);
+	pxp_set_bg(pxp);
+	pxp_set_lut(pxp);
+
+	/* One-time histogram configuration */
+	reg_val =
+	    BF_PXP_HIST_CTRL_PANEL_MODE(BV_PXP_HIST_CTRL_PANEL_MODE__GRAY16);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST_CTRL);
+
+	reg_val = BF_PXP_HIST2_PARAM_VALUE0(0x00) |
+	    BF_PXP_HIST2_PARAM_VALUE1(0x00F);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST2_PARAM);
+
+	reg_val = BF_PXP_HIST4_PARAM_VALUE0(0x00) |
+	    BF_PXP_HIST4_PARAM_VALUE1(0x05) |
+	    BF_PXP_HIST4_PARAM_VALUE2(0x0A) | BF_PXP_HIST4_PARAM_VALUE3(0x0F);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST4_PARAM);
+
+	reg_val = BF_PXP_HIST8_PARAM0_VALUE0(0x00) |
+	    BF_PXP_HIST8_PARAM0_VALUE1(0x02) |
+	    BF_PXP_HIST8_PARAM0_VALUE2(0x04) | BF_PXP_HIST8_PARAM0_VALUE3(0x06);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST8_PARAM0);
+	reg_val = BF_PXP_HIST8_PARAM1_VALUE4(0x09) |
+	    BF_PXP_HIST8_PARAM1_VALUE5(0x0B) |
+	    BF_PXP_HIST8_PARAM1_VALUE6(0x0D) | BF_PXP_HIST8_PARAM1_VALUE7(0x0F);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST8_PARAM1);
+
+	reg_val = BF_PXP_HIST16_PARAM0_VALUE0(0x00) |
+	    BF_PXP_HIST16_PARAM0_VALUE1(0x01) |
+	    BF_PXP_HIST16_PARAM0_VALUE2(0x02) |
+	    BF_PXP_HIST16_PARAM0_VALUE3(0x03);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST16_PARAM0);
+	reg_val = BF_PXP_HIST16_PARAM1_VALUE4(0x04) |
+	    BF_PXP_HIST16_PARAM1_VALUE5(0x05) |
+	    BF_PXP_HIST16_PARAM1_VALUE6(0x06) |
+	    BF_PXP_HIST16_PARAM1_VALUE7(0x07);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST16_PARAM1);
+	reg_val = BF_PXP_HIST16_PARAM2_VALUE8(0x08) |
+	    BF_PXP_HIST16_PARAM2_VALUE9(0x09) |
+	    BF_PXP_HIST16_PARAM2_VALUE10(0x0A) |
+	    BF_PXP_HIST16_PARAM2_VALUE11(0x0B);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST16_PARAM2);
+	reg_val = BF_PXP_HIST16_PARAM3_VALUE12(0x0C) |
+	    BF_PXP_HIST16_PARAM3_VALUE13(0x0D) |
+	    BF_PXP_HIST16_PARAM3_VALUE14(0x0E) |
+	    BF_PXP_HIST16_PARAM3_VALUE15(0x0F);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST16_PARAM3);
+
+	return 0;
+}
+
+static int pxp_dma_init(struct pxps *pxp)
+{
+	struct pxp_dma *pxp_dma = &pxp->pxp_dma;
+	struct dma_device *dma = &pxp_dma->dma;
+	int i;
+
+	dma_cap_set(DMA_SLAVE, dma->cap_mask);
+	dma_cap_set(DMA_PRIVATE, dma->cap_mask);
+
+	/* Compulsory common fields */
+	dma->dev = pxp->dev;
+	dma->device_alloc_chan_resources = pxp_alloc_chan_resources;
+	dma->device_free_chan_resources = pxp_free_chan_resources;
+	dma->device_tx_status = pxp_tx_status;
+	dma->device_issue_pending = pxp_issue_pending;
+
+	/* Compulsory for DMA_SLAVE fields */
+	dma->device_prep_slave_sg = pxp_prep_slave_sg;
+	dma->device_control = pxp_control;
+
+	/* Initialize PxP Channels */
+	INIT_LIST_HEAD(&dma->channels);
+	for (i = 0; i < NR_PXP_VIRT_CHANNEL; i++) {
+		struct pxp_channel *pxp_chan = pxp->channel + i;
+		struct dma_chan *dma_chan = &pxp_chan->dma_chan;
+
+		spin_lock_init(&pxp_chan->lock);
+		mutex_init(&pxp_chan->chan_mutex);
+
+		/* Only one EOF IRQ for PxP, shared by all channels */
+		pxp_chan->eof_irq = pxp->irq;
+		pxp_chan->status = PXP_CHANNEL_FREE;
+		pxp_chan->completed = -ENXIO;
+		snprintf(pxp_chan->eof_name, sizeof(pxp_chan->eof_name),
+			 "PXP EOF %d", i);
+
+		dma_chan->device = &pxp_dma->dma;
+		dma_chan->cookie = 1;
+		dma_chan->chan_id = i;
+		list_add_tail(&dma_chan->device_node, &dma->channels);
+	}
+
+	return dma_async_device_register(&pxp_dma->dma);
+}
+
+static ssize_t clk_off_timeout_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", timeout_in_ms);
+}
+
+static ssize_t clk_off_timeout_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	int val;
+	if (sscanf(buf, "%d", &val) > 0) {
+		timeout_in_ms = val;
+		return count;
+	}
+	return -EINVAL;
+}
+
+static DEVICE_ATTR(clk_off_timeout, 0644, clk_off_timeout_show,
+		   clk_off_timeout_store);
+
+static const struct of_device_id imx_pxpdma_dt_ids[] = {
+	{ .compatible = "fsl,imx6dl-pxp-dma", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx_pxpdma_dt_ids);
+
+static int pxp_probe(struct platform_device *pdev)
+{
+	struct pxps *pxp;
+	struct resource *res;
+	int irq;
+	int err = 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_get_irq(pdev, 0);
+	if (!res || irq < 0) {
+		err = -ENODEV;
+		goto exit;
+	}
+
+	pxp = devm_kzalloc(&pdev->dev, sizeof(*pxp), GFP_KERNEL);
+	if (!pxp) {
+		dev_err(&pdev->dev, "failed to allocate control object\n");
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	pxp->dev = &pdev->dev;
+
+	platform_set_drvdata(pdev, pxp);
+	pxp->irq = irq;
+
+	pxp->pxp_ongoing = 0;
+	pxp->lut_state = 0;
+
+	spin_lock_init(&pxp->lock);
+	mutex_init(&pxp->clk_mutex);
+
+	pxp->base = devm_request_and_ioremap(&pdev->dev, res);
+	if (pxp->base == NULL) {
+		dev_err(&pdev->dev, "Couldn't ioremap regs\n");
+		err = -ENODEV;
+		goto exit;
+	}
+
+	pxp->pdev = pdev;
+
+	pxp->clk = devm_clk_get(&pdev->dev, "pxp-axi");
+	clk_prepare_enable(pxp->clk);
+
+	err = pxp_hw_init(pxp);
+	clk_disable_unprepare(pxp->clk);
+	if (err) {
+		dev_err(&pdev->dev, "failed to initialize hardware\n");
+		goto exit;
+	}
+
+	err = devm_request_irq(&pdev->dev, pxp->irq, pxp_irq, 0,
+				"pxp-dmaengine", pxp);
+	if (err)
+		goto exit;
+	/* Initialize DMA engine */
+	err = pxp_dma_init(pxp);
+	if (err < 0)
+		goto exit;
+
+	if (device_create_file(&pdev->dev, &dev_attr_clk_off_timeout)) {
+		dev_err(&pdev->dev,
+			"Unable to create file from clk_off_timeout\n");
+		goto exit;
+	}
+	dump_pxp_reg(pxp);
+
+	INIT_WORK(&pxp->work, clkoff_callback);
+	init_waitqueue_head(&pxp->done);
+	init_timer(&pxp->clk_timer);
+	pxp->clk_timer.function = pxp_clkoff_timer;
+	pxp->clk_timer.data = (unsigned long)pxp;
+
+	register_pxp_device();
+
+exit:
+	if (err)
+		dev_err(&pdev->dev, "Exiting (unsuccessfully) pxp_probe()\n");
+	return err;
+}
+
+static int pxp_remove(struct platform_device *pdev)
+{
+	struct pxps *pxp = platform_get_drvdata(pdev);
+
+	unregister_pxp_device();
+	cancel_work_sync(&pxp->work);
+	del_timer_sync(&pxp->clk_timer);
+	clk_disable_unprepare(pxp->clk);
+	device_remove_file(&pdev->dev, &dev_attr_clk_off_timeout);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int pxp_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct pxps *pxp = platform_get_drvdata(pdev);
+
+	pxp_clk_enable(pxp);
+	while (__raw_readl(pxp->base + HW_PXP_CTRL) & BM_PXP_CTRL_ENABLE)
+		;
+
+	__raw_writel(BM_PXP_CTRL_SFTRST, pxp->base + HW_PXP_CTRL);
+	pxp_clk_disable(pxp);
+
+	return 0;
+}
+
+static int pxp_resume(struct platform_device *pdev)
+{
+	struct pxps *pxp = platform_get_drvdata(pdev);
+
+	pxp_clk_enable(pxp);
+	/* Pull PxP out of reset */
+	__raw_writel(0, pxp->base + HW_PXP_CTRL);
+	pxp_clk_disable(pxp);
+
+	return 0;
+}
+#else
+#define	pxp_suspend	NULL
+#define	pxp_resume	NULL
+#endif
+
+static struct platform_driver pxp_driver = {
+	.driver = {
+			.name = "imx-pxp",
+			.of_match_table = of_match_ptr(imx_pxpdma_dt_ids),
+		   },
+	.probe = pxp_probe,
+	.remove = pxp_remove,
+	.suspend = pxp_suspend,
+	.resume = pxp_resume,
+};
+
+module_platform_driver(pxp_driver);
+
+
+MODULE_DESCRIPTION("i.MX PxP driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/dma/pxp/regs-pxp_v2.h b/drivers/dma/pxp/regs-pxp_v2.h
new file mode 100644
index 0000000..37c832d
--- /dev/null
+++ b/drivers/dma/pxp/regs-pxp_v2.h
@@ -0,0 +1,1152 @@
+/*
+ * Freescale PXP Register Definitions
+ *
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.29
+ * Template revision: 1.3
+ */
+
+#ifndef __ARCH_ARM___PXP_H
+#define __ARCH_ARM___PXP_H
+
+#define HW_PXP_CTRL	(0x00000000)
+#define HW_PXP_CTRL_SET	(0x00000004)
+#define HW_PXP_CTRL_CLR	(0x00000008)
+#define HW_PXP_CTRL_TOG	(0x0000000c)
+
+#define BM_PXP_CTRL_SFTRST 0x80000000
+#define BM_PXP_CTRL_CLKGATE 0x40000000
+#define BM_PXP_CTRL_RSVD4 0x20000000
+#define BM_PXP_CTRL_EN_REPEAT 0x10000000
+#define BP_PXP_CTRL_RSVD3      26
+#define BM_PXP_CTRL_RSVD3 0x0C000000
+#define BF_PXP_CTRL_RSVD3(v)  \
+	(((v) << 26) & BM_PXP_CTRL_RSVD3)
+#define BP_PXP_CTRL_INTERLACED_INPUT	  24
+#define BM_PXP_CTRL_INTERLACED_INPUT 0x03000000
+#define BF_PXP_CTRL_INTERLACED_INPUT(v)  \
+	(((v) << 24) & BM_PXP_CTRL_INTERLACED_INPUT)
+#define BV_PXP_CTRL_INTERLACED_INPUT__PROGRESSIVE 0x0
+#define BV_PXP_CTRL_INTERLACED_INPUT__FIELD0	  0x2
+#define BV_PXP_CTRL_INTERLACED_INPUT__FIELD1	  0x3
+#define BM_PXP_CTRL_BLOCK_SIZE 0x00800000
+#define BV_PXP_CTRL_BLOCK_SIZE__8X8   0x0
+#define BV_PXP_CTRL_BLOCK_SIZE__16X16 0x1
+#define BM_PXP_CTRL_ROT_POS 0x00400000
+#define BM_PXP_CTRL_IN_PLACE 0x00200000
+#define BP_PXP_CTRL_RSVD1      12
+#define BM_PXP_CTRL_RSVD1 0x001FF000
+#define BF_PXP_CTRL_RSVD1(v)  \
+	(((v) << 12) & BM_PXP_CTRL_RSVD1)
+#define BM_PXP_CTRL_VFLIP 0x00000800
+#define BM_PXP_CTRL_HFLIP 0x00000400
+#define BP_PXP_CTRL_ROTATE	8
+#define BM_PXP_CTRL_ROTATE 0x00000300
+#define BF_PXP_CTRL_ROTATE(v)  \
+	(((v) << 8) & BM_PXP_CTRL_ROTATE)
+#define BV_PXP_CTRL_ROTATE__ROT_0   0x0
+#define BV_PXP_CTRL_ROTATE__ROT_90  0x1
+#define BV_PXP_CTRL_ROTATE__ROT_180 0x2
+#define BV_PXP_CTRL_ROTATE__ROT_270 0x3
+#define BP_PXP_CTRL_RSVD0      5
+#define BM_PXP_CTRL_RSVD0 0x000000E0
+#define BF_PXP_CTRL_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_CTRL_RSVD0)
+#define BM_PXP_CTRL_ENABLE_LCD_HANDSHAKE 0x00000010
+#define BM_PXP_CTRL_LUT_DMA_IRQ_ENABLE 0x00000008
+#define BM_PXP_CTRL_NEXT_IRQ_ENABLE 0x00000004
+#define BM_PXP_CTRL_IRQ_ENABLE 0x00000002
+#define BM_PXP_CTRL_ENABLE 0x00000001
+
+#define HW_PXP_STAT	(0x00000010)
+#define HW_PXP_STAT_SET	(0x00000014)
+#define HW_PXP_STAT_CLR	(0x00000018)
+#define HW_PXP_STAT_TOG	(0x0000001c)
+
+#define BP_PXP_STAT_BLOCKX	24
+#define BM_PXP_STAT_BLOCKX 0xFF000000
+#define BF_PXP_STAT_BLOCKX(v) \
+	(((v) << 24) & BM_PXP_STAT_BLOCKX)
+#define BP_PXP_STAT_BLOCKY	16
+#define BM_PXP_STAT_BLOCKY 0x00FF0000
+#define BF_PXP_STAT_BLOCKY(v)  \
+	(((v) << 16) & BM_PXP_STAT_BLOCKY)
+#define BP_PXP_STAT_RSVD2      9
+#define BM_PXP_STAT_RSVD2 0x0000FE00
+#define BF_PXP_STAT_RSVD2(v)  \
+	(((v) << 9) & BM_PXP_STAT_RSVD2)
+#define BM_PXP_STAT_LUT_DMA_LOAD_DONE_IRQ 0x00000100
+#define BP_PXP_STAT_AXI_ERROR_ID      4
+#define BM_PXP_STAT_AXI_ERROR_ID 0x000000F0
+#define BF_PXP_STAT_AXI_ERROR_ID(v)  \
+	(((v) << 4) & BM_PXP_STAT_AXI_ERROR_ID)
+#define BM_PXP_STAT_NEXT_IRQ 0x00000008
+#define BM_PXP_STAT_AXI_READ_ERROR 0x00000004
+#define BM_PXP_STAT_AXI_WRITE_ERROR 0x00000002
+#define BM_PXP_STAT_IRQ 0x00000001
+
+#define HW_PXP_OUT_CTRL	(0x00000020)
+#define HW_PXP_OUT_CTRL_SET	(0x00000024)
+#define HW_PXP_OUT_CTRL_CLR	(0x00000028)
+#define HW_PXP_OUT_CTRL_TOG	(0x0000002c)
+
+#define BP_PXP_OUT_CTRL_ALPHA	   24
+#define BM_PXP_OUT_CTRL_ALPHA 0xFF000000
+#define BF_PXP_OUT_CTRL_ALPHA(v) \
+	(((v) << 24) & BM_PXP_OUT_CTRL_ALPHA)
+#define BM_PXP_OUT_CTRL_ALPHA_OUTPUT 0x00800000
+#define BP_PXP_OUT_CTRL_RSVD1	   10
+#define BM_PXP_OUT_CTRL_RSVD1 0x007FFC00
+#define BF_PXP_OUT_CTRL_RSVD1(v)  \
+	(((v) << 10) & BM_PXP_OUT_CTRL_RSVD1)
+#define BP_PXP_OUT_CTRL_INTERLACED_OUTPUT      8
+#define BM_PXP_OUT_CTRL_INTERLACED_OUTPUT 0x00000300
+#define BF_PXP_OUT_CTRL_INTERLACED_OUTPUT(v)  \
+	(((v) << 8) & BM_PXP_OUT_CTRL_INTERLACED_OUTPUT)
+#define BV_PXP_OUT_CTRL_INTERLACED_OUTPUT__PROGRESSIVE 0x0
+#define BV_PXP_OUT_CTRL_INTERLACED_OUTPUT__FIELD0      0x1
+#define BV_PXP_OUT_CTRL_INTERLACED_OUTPUT__FIELD1      0x2
+#define BV_PXP_OUT_CTRL_INTERLACED_OUTPUT__INTERLACED  0x3
+#define BP_PXP_OUT_CTRL_RSVD0	   5
+#define BM_PXP_OUT_CTRL_RSVD0 0x000000E0
+#define BF_PXP_OUT_CTRL_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_OUT_CTRL_RSVD0)
+#define BP_PXP_OUT_CTRL_FORMAT	    0
+#define BM_PXP_OUT_CTRL_FORMAT 0x0000001F
+#define BF_PXP_OUT_CTRL_FORMAT(v)  \
+	(((v) << 0) & BM_PXP_OUT_CTRL_FORMAT)
+#define BV_PXP_OUT_CTRL_FORMAT__ARGB8888  0x0
+#define BV_PXP_OUT_CTRL_FORMAT__RGB888	  0x4
+#define BV_PXP_OUT_CTRL_FORMAT__RGB888P   0x5
+#define BV_PXP_OUT_CTRL_FORMAT__ARGB1555  0x8
+#define BV_PXP_OUT_CTRL_FORMAT__ARGB4444  0x9
+#define BV_PXP_OUT_CTRL_FORMAT__RGB555	  0xC
+#define BV_PXP_OUT_CTRL_FORMAT__RGB444	  0xD
+#define BV_PXP_OUT_CTRL_FORMAT__RGB565	  0xE
+#define BV_PXP_OUT_CTRL_FORMAT__YUV1P444  0x10
+#define BV_PXP_OUT_CTRL_FORMAT__UYVY1P422 0x12
+#define BV_PXP_OUT_CTRL_FORMAT__VYUY1P422 0x13
+#define BV_PXP_OUT_CTRL_FORMAT__Y8	  0x14
+#define BV_PXP_OUT_CTRL_FORMAT__Y4	  0x15
+#define BV_PXP_OUT_CTRL_FORMAT__YUV2P422  0x18
+#define BV_PXP_OUT_CTRL_FORMAT__YUV2P420  0x19
+#define BV_PXP_OUT_CTRL_FORMAT__YVU2P422  0x1A
+#define BV_PXP_OUT_CTRL_FORMAT__YVU2P420  0x1B
+
+#define HW_PXP_OUT_BUF	(0x00000030)
+
+#define BP_PXP_OUT_BUF_ADDR	 0
+#define BM_PXP_OUT_BUF_ADDR 0xFFFFFFFF
+#define BF_PXP_OUT_BUF_ADDR(v)	 (v)
+
+#define HW_PXP_OUT_BUF2	(0x00000040)
+
+#define BP_PXP_OUT_BUF2_ADDR	  0
+#define BM_PXP_OUT_BUF2_ADDR 0xFFFFFFFF
+#define BF_PXP_OUT_BUF2_ADDR(v)   (v)
+
+#define HW_PXP_OUT_PITCH	(0x00000050)
+
+#define BP_PXP_OUT_PITCH_RSVD	   16
+#define BM_PXP_OUT_PITCH_RSVD 0xFFFF0000
+#define BF_PXP_OUT_PITCH_RSVD(v) \
+	(((v) << 16) & BM_PXP_OUT_PITCH_RSVD)
+#define BP_PXP_OUT_PITCH_PITCH	    0
+#define BM_PXP_OUT_PITCH_PITCH 0x0000FFFF
+#define BF_PXP_OUT_PITCH_PITCH(v)  \
+	(((v) << 0) & BM_PXP_OUT_PITCH_PITCH)
+
+#define HW_PXP_OUT_LRC	(0x00000060)
+
+#define BP_PXP_OUT_LRC_RSVD1	  30
+#define BM_PXP_OUT_LRC_RSVD1 0xC0000000
+#define BF_PXP_OUT_LRC_RSVD1(v) \
+	(((v) << 30) & BM_PXP_OUT_LRC_RSVD1)
+#define BP_PXP_OUT_LRC_X      16
+#define BM_PXP_OUT_LRC_X 0x3FFF0000
+#define BF_PXP_OUT_LRC_X(v)  \
+	(((v) << 16) & BM_PXP_OUT_LRC_X)
+#define BP_PXP_OUT_LRC_RSVD0	  14
+#define BM_PXP_OUT_LRC_RSVD0 0x0000C000
+#define BF_PXP_OUT_LRC_RSVD0(v)  \
+	(((v) << 14) & BM_PXP_OUT_LRC_RSVD0)
+#define BP_PXP_OUT_LRC_Y      0
+#define BM_PXP_OUT_LRC_Y 0x00003FFF
+#define BF_PXP_OUT_LRC_Y(v)  \
+	(((v) << 0) & BM_PXP_OUT_LRC_Y)
+
+#define HW_PXP_OUT_PS_ULC	(0x00000070)
+
+#define BP_PXP_OUT_PS_ULC_RSVD1      30
+#define BM_PXP_OUT_PS_ULC_RSVD1 0xC0000000
+#define BF_PXP_OUT_PS_ULC_RSVD1(v) \
+	(((v) << 30) & BM_PXP_OUT_PS_ULC_RSVD1)
+#define BP_PXP_OUT_PS_ULC_X	 16
+#define BM_PXP_OUT_PS_ULC_X 0x3FFF0000
+#define BF_PXP_OUT_PS_ULC_X(v)	\
+	(((v) << 16) & BM_PXP_OUT_PS_ULC_X)
+#define BP_PXP_OUT_PS_ULC_RSVD0      14
+#define BM_PXP_OUT_PS_ULC_RSVD0 0x0000C000
+#define BF_PXP_OUT_PS_ULC_RSVD0(v)  \
+	(((v) << 14) & BM_PXP_OUT_PS_ULC_RSVD0)
+#define BP_PXP_OUT_PS_ULC_Y	 0
+#define BM_PXP_OUT_PS_ULC_Y 0x00003FFF
+#define BF_PXP_OUT_PS_ULC_Y(v)	\
+	(((v) << 0) & BM_PXP_OUT_PS_ULC_Y)
+
+#define HW_PXP_OUT_PS_LRC	(0x00000080)
+
+#define BP_PXP_OUT_PS_LRC_RSVD1      30
+#define BM_PXP_OUT_PS_LRC_RSVD1 0xC0000000
+#define BF_PXP_OUT_PS_LRC_RSVD1(v) \
+	(((v) << 30) & BM_PXP_OUT_PS_LRC_RSVD1)
+#define BP_PXP_OUT_PS_LRC_X	 16
+#define BM_PXP_OUT_PS_LRC_X 0x3FFF0000
+#define BF_PXP_OUT_PS_LRC_X(v)	\
+	(((v) << 16) & BM_PXP_OUT_PS_LRC_X)
+#define BP_PXP_OUT_PS_LRC_RSVD0      14
+#define BM_PXP_OUT_PS_LRC_RSVD0 0x0000C000
+#define BF_PXP_OUT_PS_LRC_RSVD0(v)  \
+	(((v) << 14) & BM_PXP_OUT_PS_LRC_RSVD0)
+#define BP_PXP_OUT_PS_LRC_Y	 0
+#define BM_PXP_OUT_PS_LRC_Y 0x00003FFF
+#define BF_PXP_OUT_PS_LRC_Y(v)	\
+	(((v) << 0) & BM_PXP_OUT_PS_LRC_Y)
+
+#define HW_PXP_OUT_AS_ULC	(0x00000090)
+
+#define BP_PXP_OUT_AS_ULC_RSVD1      30
+#define BM_PXP_OUT_AS_ULC_RSVD1 0xC0000000
+#define BF_PXP_OUT_AS_ULC_RSVD1(v) \
+	(((v) << 30) & BM_PXP_OUT_AS_ULC_RSVD1)
+#define BP_PXP_OUT_AS_ULC_X	 16
+#define BM_PXP_OUT_AS_ULC_X 0x3FFF0000
+#define BF_PXP_OUT_AS_ULC_X(v)	\
+	(((v) << 16) & BM_PXP_OUT_AS_ULC_X)
+#define BP_PXP_OUT_AS_ULC_RSVD0      14
+#define BM_PXP_OUT_AS_ULC_RSVD0 0x0000C000
+#define BF_PXP_OUT_AS_ULC_RSVD0(v)  \
+	(((v) << 14) & BM_PXP_OUT_AS_ULC_RSVD0)
+#define BP_PXP_OUT_AS_ULC_Y	 0
+#define BM_PXP_OUT_AS_ULC_Y 0x00003FFF
+#define BF_PXP_OUT_AS_ULC_Y(v)	\
+	(((v) << 0) & BM_PXP_OUT_AS_ULC_Y)
+
+#define HW_PXP_OUT_AS_LRC	(0x000000a0)
+
+#define BP_PXP_OUT_AS_LRC_RSVD1      30
+#define BM_PXP_OUT_AS_LRC_RSVD1 0xC0000000
+#define BF_PXP_OUT_AS_LRC_RSVD1(v) \
+	(((v) << 30) & BM_PXP_OUT_AS_LRC_RSVD1)
+#define BP_PXP_OUT_AS_LRC_X	 16
+#define BM_PXP_OUT_AS_LRC_X 0x3FFF0000
+#define BF_PXP_OUT_AS_LRC_X(v)	\
+	(((v) << 16) & BM_PXP_OUT_AS_LRC_X)
+#define BP_PXP_OUT_AS_LRC_RSVD0      14
+#define BM_PXP_OUT_AS_LRC_RSVD0 0x0000C000
+#define BF_PXP_OUT_AS_LRC_RSVD0(v)  \
+	(((v) << 14) & BM_PXP_OUT_AS_LRC_RSVD0)
+#define BP_PXP_OUT_AS_LRC_Y	 0
+#define BM_PXP_OUT_AS_LRC_Y 0x00003FFF
+#define BF_PXP_OUT_AS_LRC_Y(v)	\
+	(((v) << 0) & BM_PXP_OUT_AS_LRC_Y)
+
+#define HW_PXP_PS_CTRL	(0x000000b0)
+#define HW_PXP_PS_CTRL_SET	(0x000000b4)
+#define HW_PXP_PS_CTRL_CLR	(0x000000b8)
+#define HW_PXP_PS_CTRL_TOG	(0x000000bc)
+
+#define BP_PXP_PS_CTRL_RSVD1	  12
+#define BM_PXP_PS_CTRL_RSVD1 0xFFFFF000
+#define BF_PXP_PS_CTRL_RSVD1(v) \
+	(((v) << 12) & BM_PXP_PS_CTRL_RSVD1)
+#define BP_PXP_PS_CTRL_DECX	 10
+#define BM_PXP_PS_CTRL_DECX 0x00000C00
+#define BF_PXP_PS_CTRL_DECX(v)	\
+	(((v) << 10) & BM_PXP_PS_CTRL_DECX)
+#define BV_PXP_PS_CTRL_DECX__DISABLE 0x0
+#define BV_PXP_PS_CTRL_DECX__DECX2   0x1
+#define BV_PXP_PS_CTRL_DECX__DECX4   0x2
+#define BV_PXP_PS_CTRL_DECX__DECX8   0x3
+#define BP_PXP_PS_CTRL_DECY	 8
+#define BM_PXP_PS_CTRL_DECY 0x00000300
+#define BF_PXP_PS_CTRL_DECY(v)	\
+	(((v) << 8) & BM_PXP_PS_CTRL_DECY)
+#define BV_PXP_PS_CTRL_DECY__DISABLE 0x0
+#define BV_PXP_PS_CTRL_DECY__DECY2   0x1
+#define BV_PXP_PS_CTRL_DECY__DECY4   0x2
+#define BV_PXP_PS_CTRL_DECY__DECY8   0x3
+#define BP_PXP_PS_CTRL_RSVD0	  5
+#define BM_PXP_PS_CTRL_RSVD0 0x000000E0
+#define BF_PXP_PS_CTRL_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_PS_CTRL_RSVD0)
+#define BP_PXP_PS_CTRL_FORMAT	   0
+#define BM_PXP_PS_CTRL_FORMAT 0x0000001F
+#define BF_PXP_PS_CTRL_FORMAT(v)  \
+	(((v) << 0) & BM_PXP_PS_CTRL_FORMAT)
+#define BV_PXP_PS_CTRL_FORMAT__RGB888	 0x4
+#define BV_PXP_PS_CTRL_FORMAT__RGB555	 0xC
+#define BV_PXP_PS_CTRL_FORMAT__RGB444	 0xD
+#define BV_PXP_PS_CTRL_FORMAT__RGB565	 0xE
+#define BV_PXP_PS_CTRL_FORMAT__YUV1P444  0x10
+#define BV_PXP_PS_CTRL_FORMAT__UYVY1P422 0x12
+#define BV_PXP_PS_CTRL_FORMAT__VYUY1P422 0x13
+#define BV_PXP_PS_CTRL_FORMAT__Y8	 0x14
+#define BV_PXP_PS_CTRL_FORMAT__Y4	 0x15
+#define BV_PXP_PS_CTRL_FORMAT__YUV2P422  0x18
+#define BV_PXP_PS_CTRL_FORMAT__YUV2P420  0x19
+#define BV_PXP_PS_CTRL_FORMAT__YVU2P422  0x1A
+#define BV_PXP_PS_CTRL_FORMAT__YVU2P420  0x1B
+#define BV_PXP_PS_CTRL_FORMAT__YUV422	 0x1E
+#define BV_PXP_PS_CTRL_FORMAT__YUV420	 0x1F
+
+#define HW_PXP_PS_BUF	(0x000000c0)
+
+#define BP_PXP_PS_BUF_ADDR	0
+#define BM_PXP_PS_BUF_ADDR 0xFFFFFFFF
+#define BF_PXP_PS_BUF_ADDR(v)	(v)
+
+#define HW_PXP_PS_UBUF	(0x000000d0)
+
+#define BP_PXP_PS_UBUF_ADDR	 0
+#define BM_PXP_PS_UBUF_ADDR 0xFFFFFFFF
+#define BF_PXP_PS_UBUF_ADDR(v)	 (v)
+
+#define HW_PXP_PS_VBUF	(0x000000e0)
+
+#define BP_PXP_PS_VBUF_ADDR	 0
+#define BM_PXP_PS_VBUF_ADDR 0xFFFFFFFF
+#define BF_PXP_PS_VBUF_ADDR(v)	 (v)
+
+#define HW_PXP_PS_PITCH	(0x000000f0)
+
+#define BP_PXP_PS_PITCH_RSVD	  16
+#define BM_PXP_PS_PITCH_RSVD 0xFFFF0000
+#define BF_PXP_PS_PITCH_RSVD(v) \
+	(((v) << 16) & BM_PXP_PS_PITCH_RSVD)
+#define BP_PXP_PS_PITCH_PITCH	   0
+#define BM_PXP_PS_PITCH_PITCH 0x0000FFFF
+#define BF_PXP_PS_PITCH_PITCH(v)  \
+	(((v) << 0) & BM_PXP_PS_PITCH_PITCH)
+
+#define HW_PXP_PS_BACKGROUND	(0x00000100)
+
+#define BP_PXP_PS_BACKGROUND_RSVD      24
+#define BM_PXP_PS_BACKGROUND_RSVD 0xFF000000
+#define BF_PXP_PS_BACKGROUND_RSVD(v) \
+	(((v) << 24) & BM_PXP_PS_BACKGROUND_RSVD)
+#define BP_PXP_PS_BACKGROUND_COLOR	0
+#define BM_PXP_PS_BACKGROUND_COLOR 0x00FFFFFF
+#define BF_PXP_PS_BACKGROUND_COLOR(v)  \
+	(((v) << 0) & BM_PXP_PS_BACKGROUND_COLOR)
+
+#define HW_PXP_PS_SCALE	(0x00000110)
+
+#define BM_PXP_PS_SCALE_RSVD2 0x80000000
+#define BP_PXP_PS_SCALE_YSCALE	    16
+#define BM_PXP_PS_SCALE_YSCALE 0x7FFF0000
+#define BF_PXP_PS_SCALE_YSCALE(v)  \
+	(((v) << 16) & BM_PXP_PS_SCALE_YSCALE)
+#define BM_PXP_PS_SCALE_RSVD1 0x00008000
+#define BP_PXP_PS_SCALE_XSCALE	    0
+#define BM_PXP_PS_SCALE_XSCALE 0x00007FFF
+#define BF_PXP_PS_SCALE_XSCALE(v)  \
+	(((v) << 0) & BM_PXP_PS_SCALE_XSCALE)
+
+#define HW_PXP_PS_OFFSET	(0x00000120)
+
+#define BP_PXP_PS_OFFSET_RSVD2	    28
+#define BM_PXP_PS_OFFSET_RSVD2 0xF0000000
+#define BF_PXP_PS_OFFSET_RSVD2(v) \
+	(((v) << 28) & BM_PXP_PS_OFFSET_RSVD2)
+#define BP_PXP_PS_OFFSET_YOFFSET      16
+#define BM_PXP_PS_OFFSET_YOFFSET 0x0FFF0000
+#define BF_PXP_PS_OFFSET_YOFFSET(v)  \
+	(((v) << 16) & BM_PXP_PS_OFFSET_YOFFSET)
+#define BP_PXP_PS_OFFSET_RSVD1	    12
+#define BM_PXP_PS_OFFSET_RSVD1 0x0000F000
+#define BF_PXP_PS_OFFSET_RSVD1(v)  \
+	(((v) << 12) & BM_PXP_PS_OFFSET_RSVD1)
+#define BP_PXP_PS_OFFSET_XOFFSET      0
+#define BM_PXP_PS_OFFSET_XOFFSET 0x00000FFF
+#define BF_PXP_PS_OFFSET_XOFFSET(v)  \
+	(((v) << 0) & BM_PXP_PS_OFFSET_XOFFSET)
+
+#define HW_PXP_PS_CLRKEYLOW	(0x00000130)
+
+#define BP_PXP_PS_CLRKEYLOW_RSVD1      24
+#define BM_PXP_PS_CLRKEYLOW_RSVD1 0xFF000000
+#define BF_PXP_PS_CLRKEYLOW_RSVD1(v) \
+	(((v) << 24) & BM_PXP_PS_CLRKEYLOW_RSVD1)
+#define BP_PXP_PS_CLRKEYLOW_PIXEL      0
+#define BM_PXP_PS_CLRKEYLOW_PIXEL 0x00FFFFFF
+#define BF_PXP_PS_CLRKEYLOW_PIXEL(v)  \
+	(((v) << 0) & BM_PXP_PS_CLRKEYLOW_PIXEL)
+
+#define HW_PXP_PS_CLRKEYHIGH	(0x00000140)
+
+#define BP_PXP_PS_CLRKEYHIGH_RSVD1	24
+#define BM_PXP_PS_CLRKEYHIGH_RSVD1 0xFF000000
+#define BF_PXP_PS_CLRKEYHIGH_RSVD1(v) \
+	(((v) << 24) & BM_PXP_PS_CLRKEYHIGH_RSVD1)
+#define BP_PXP_PS_CLRKEYHIGH_PIXEL	0
+#define BM_PXP_PS_CLRKEYHIGH_PIXEL 0x00FFFFFF
+#define BF_PXP_PS_CLRKEYHIGH_PIXEL(v)  \
+	(((v) << 0) & BM_PXP_PS_CLRKEYHIGH_PIXEL)
+
+#define HW_PXP_AS_CTRL	(0x00000150)
+
+#define BP_PXP_AS_CTRL_RSVD1	  21
+#define BM_PXP_AS_CTRL_RSVD1 0xFFE00000
+#define BF_PXP_AS_CTRL_RSVD1(v) \
+	(((v) << 21) & BM_PXP_AS_CTRL_RSVD1)
+#define BM_PXP_AS_CTRL_ALPHA_INVERT 0x00100000
+#define BP_PXP_AS_CTRL_ROP	16
+#define BM_PXP_AS_CTRL_ROP 0x000F0000
+#define BF_PXP_AS_CTRL_ROP(v)  \
+	(((v) << 16) & BM_PXP_AS_CTRL_ROP)
+#define BV_PXP_AS_CTRL_ROP__MASKAS     0x0
+#define BV_PXP_AS_CTRL_ROP__MASKNOTAS  0x1
+#define BV_PXP_AS_CTRL_ROP__MASKASNOT  0x2
+#define BV_PXP_AS_CTRL_ROP__MERGEAS    0x3
+#define BV_PXP_AS_CTRL_ROP__MERGENOTAS 0x4
+#define BV_PXP_AS_CTRL_ROP__MERGEASNOT 0x5
+#define BV_PXP_AS_CTRL_ROP__NOTCOPYAS  0x6
+#define BV_PXP_AS_CTRL_ROP__NOT        0x7
+#define BV_PXP_AS_CTRL_ROP__NOTMASKAS  0x8
+#define BV_PXP_AS_CTRL_ROP__NOTMERGEAS 0x9
+#define BV_PXP_AS_CTRL_ROP__XORAS      0xA
+#define BV_PXP_AS_CTRL_ROP__NOTXORAS   0xB
+#define BP_PXP_AS_CTRL_ALPHA	  8
+#define BM_PXP_AS_CTRL_ALPHA 0x0000FF00
+#define BF_PXP_AS_CTRL_ALPHA(v)  \
+	(((v) << 8) & BM_PXP_AS_CTRL_ALPHA)
+#define BP_PXP_AS_CTRL_FORMAT	   4
+#define BM_PXP_AS_CTRL_FORMAT 0x000000F0
+#define BF_PXP_AS_CTRL_FORMAT(v)  \
+	(((v) << 4) & BM_PXP_AS_CTRL_FORMAT)
+#define BV_PXP_AS_CTRL_FORMAT__ARGB8888 0x0
+#define BV_PXP_AS_CTRL_FORMAT__RGB888	0x4
+#define BV_PXP_AS_CTRL_FORMAT__ARGB1555 0x8
+#define BV_PXP_AS_CTRL_FORMAT__ARGB4444 0x9
+#define BV_PXP_AS_CTRL_FORMAT__RGB555	0xC
+#define BV_PXP_AS_CTRL_FORMAT__RGB444	0xD
+#define BV_PXP_AS_CTRL_FORMAT__RGB565	0xE
+#define BM_PXP_AS_CTRL_ENABLE_COLORKEY 0x00000008
+#define BP_PXP_AS_CTRL_ALPHA_CTRL      1
+#define BM_PXP_AS_CTRL_ALPHA_CTRL 0x00000006
+#define BF_PXP_AS_CTRL_ALPHA_CTRL(v)  \
+	(((v) << 1) & BM_PXP_AS_CTRL_ALPHA_CTRL)
+#define BV_PXP_AS_CTRL_ALPHA_CTRL__Embedded 0x0
+#define BV_PXP_AS_CTRL_ALPHA_CTRL__Override 0x1
+#define BV_PXP_AS_CTRL_ALPHA_CTRL__Multiply 0x2
+#define BV_PXP_AS_CTRL_ALPHA_CTRL__ROPs     0x3
+#define BM_PXP_AS_CTRL_RSVD0 0x00000001
+
+#define HW_PXP_AS_BUF	(0x00000160)
+
+#define BP_PXP_AS_BUF_ADDR	0
+#define BM_PXP_AS_BUF_ADDR 0xFFFFFFFF
+#define BF_PXP_AS_BUF_ADDR(v)	(v)
+
+#define HW_PXP_AS_PITCH	(0x00000170)
+
+#define BP_PXP_AS_PITCH_RSVD	  16
+#define BM_PXP_AS_PITCH_RSVD 0xFFFF0000
+#define BF_PXP_AS_PITCH_RSVD(v) \
+	(((v) << 16) & BM_PXP_AS_PITCH_RSVD)
+#define BP_PXP_AS_PITCH_PITCH	   0
+#define BM_PXP_AS_PITCH_PITCH 0x0000FFFF
+#define BF_PXP_AS_PITCH_PITCH(v)  \
+	(((v) << 0) & BM_PXP_AS_PITCH_PITCH)
+
+#define HW_PXP_AS_CLRKEYLOW	(0x00000180)
+
+#define BP_PXP_AS_CLRKEYLOW_RSVD1      24
+#define BM_PXP_AS_CLRKEYLOW_RSVD1 0xFF000000
+#define BF_PXP_AS_CLRKEYLOW_RSVD1(v) \
+	(((v) << 24) & BM_PXP_AS_CLRKEYLOW_RSVD1)
+#define BP_PXP_AS_CLRKEYLOW_PIXEL      0
+#define BM_PXP_AS_CLRKEYLOW_PIXEL 0x00FFFFFF
+#define BF_PXP_AS_CLRKEYLOW_PIXEL(v)  \
+	(((v) << 0) & BM_PXP_AS_CLRKEYLOW_PIXEL)
+
+#define HW_PXP_AS_CLRKEYHIGH	(0x00000190)
+
+#define BP_PXP_AS_CLRKEYHIGH_RSVD1	24
+#define BM_PXP_AS_CLRKEYHIGH_RSVD1 0xFF000000
+#define BF_PXP_AS_CLRKEYHIGH_RSVD1(v) \
+	(((v) << 24) & BM_PXP_AS_CLRKEYHIGH_RSVD1)
+#define BP_PXP_AS_CLRKEYHIGH_PIXEL	0
+#define BM_PXP_AS_CLRKEYHIGH_PIXEL 0x00FFFFFF
+#define BF_PXP_AS_CLRKEYHIGH_PIXEL(v)  \
+	(((v) << 0) & BM_PXP_AS_CLRKEYHIGH_PIXEL)
+
+#define HW_PXP_CSC1_COEF0	(0x000001a0)
+
+#define BM_PXP_CSC1_COEF0_YCBCR_MODE 0x80000000
+#define BM_PXP_CSC1_COEF0_BYPASS 0x40000000
+#define BM_PXP_CSC1_COEF0_RSVD1 0x20000000
+#define BP_PXP_CSC1_COEF0_C0	  18
+#define BM_PXP_CSC1_COEF0_C0 0x1FFC0000
+#define BF_PXP_CSC1_COEF0_C0(v)  \
+	(((v) << 18) & BM_PXP_CSC1_COEF0_C0)
+#define BP_PXP_CSC1_COEF0_UV_OFFSET	 9
+#define BM_PXP_CSC1_COEF0_UV_OFFSET 0x0003FE00
+#define BF_PXP_CSC1_COEF0_UV_OFFSET(v)	\
+	(((v) << 9) & BM_PXP_CSC1_COEF0_UV_OFFSET)
+#define BP_PXP_CSC1_COEF0_Y_OFFSET	0
+#define BM_PXP_CSC1_COEF0_Y_OFFSET 0x000001FF
+#define BF_PXP_CSC1_COEF0_Y_OFFSET(v)  \
+	(((v) << 0) & BM_PXP_CSC1_COEF0_Y_OFFSET)
+
+#define HW_PXP_CSC1_COEF1	(0x000001b0)
+
+#define BP_PXP_CSC1_COEF1_RSVD1      27
+#define BM_PXP_CSC1_COEF1_RSVD1 0xF8000000
+#define BF_PXP_CSC1_COEF1_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC1_COEF1_RSVD1)
+#define BP_PXP_CSC1_COEF1_C1	  16
+#define BM_PXP_CSC1_COEF1_C1 0x07FF0000
+#define BF_PXP_CSC1_COEF1_C1(v)  \
+	(((v) << 16) & BM_PXP_CSC1_COEF1_C1)
+#define BP_PXP_CSC1_COEF1_RSVD0      11
+#define BM_PXP_CSC1_COEF1_RSVD0 0x0000F800
+#define BF_PXP_CSC1_COEF1_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC1_COEF1_RSVD0)
+#define BP_PXP_CSC1_COEF1_C4	  0
+#define BM_PXP_CSC1_COEF1_C4 0x000007FF
+#define BF_PXP_CSC1_COEF1_C4(v)  \
+	(((v) << 0) & BM_PXP_CSC1_COEF1_C4)
+
+#define HW_PXP_CSC1_COEF2	(0x000001c0)
+
+#define BP_PXP_CSC1_COEF2_RSVD1      27
+#define BM_PXP_CSC1_COEF2_RSVD1 0xF8000000
+#define BF_PXP_CSC1_COEF2_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC1_COEF2_RSVD1)
+#define BP_PXP_CSC1_COEF2_C2	  16
+#define BM_PXP_CSC1_COEF2_C2 0x07FF0000
+#define BF_PXP_CSC1_COEF2_C2(v)  \
+	(((v) << 16) & BM_PXP_CSC1_COEF2_C2)
+#define BP_PXP_CSC1_COEF2_RSVD0      11
+#define BM_PXP_CSC1_COEF2_RSVD0 0x0000F800
+#define BF_PXP_CSC1_COEF2_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC1_COEF2_RSVD0)
+#define BP_PXP_CSC1_COEF2_C3	  0
+#define BM_PXP_CSC1_COEF2_C3 0x000007FF
+#define BF_PXP_CSC1_COEF2_C3(v)  \
+	(((v) << 0) & BM_PXP_CSC1_COEF2_C3)
+
+#define HW_PXP_CSC2_CTRL	(0x000001d0)
+
+#define BP_PXP_CSC2_CTRL_RSVD	   3
+#define BM_PXP_CSC2_CTRL_RSVD 0xFFFFFFF8
+#define BF_PXP_CSC2_CTRL_RSVD(v) \
+	(((v) << 3) & BM_PXP_CSC2_CTRL_RSVD)
+#define BP_PXP_CSC2_CTRL_CSC_MODE      1
+#define BM_PXP_CSC2_CTRL_CSC_MODE 0x00000006
+#define BF_PXP_CSC2_CTRL_CSC_MODE(v)  \
+	(((v) << 1) & BM_PXP_CSC2_CTRL_CSC_MODE)
+#define BV_PXP_CSC2_CTRL_CSC_MODE__YUV2RGB   0x0
+#define BV_PXP_CSC2_CTRL_CSC_MODE__YCbCr2RGB 0x1
+#define BV_PXP_CSC2_CTRL_CSC_MODE__RGB2YUV   0x2
+#define BV_PXP_CSC2_CTRL_CSC_MODE__RGB2YCbCr 0x3
+#define BM_PXP_CSC2_CTRL_BYPASS 0x00000001
+
+#define HW_PXP_CSC2_COEF0	(0x000001e0)
+
+#define BP_PXP_CSC2_COEF0_RSVD1      27
+#define BM_PXP_CSC2_COEF0_RSVD1 0xF8000000
+#define BF_PXP_CSC2_COEF0_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC2_COEF0_RSVD1)
+#define BP_PXP_CSC2_COEF0_A2	  16
+#define BM_PXP_CSC2_COEF0_A2 0x07FF0000
+#define BF_PXP_CSC2_COEF0_A2(v)  \
+	(((v) << 16) & BM_PXP_CSC2_COEF0_A2)
+#define BP_PXP_CSC2_COEF0_RSVD0      11
+#define BM_PXP_CSC2_COEF0_RSVD0 0x0000F800
+#define BF_PXP_CSC2_COEF0_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2_COEF0_RSVD0)
+#define BP_PXP_CSC2_COEF0_A1	  0
+#define BM_PXP_CSC2_COEF0_A1 0x000007FF
+#define BF_PXP_CSC2_COEF0_A1(v)  \
+	(((v) << 0) & BM_PXP_CSC2_COEF0_A1)
+
+#define HW_PXP_CSC2_COEF1	(0x000001f0)
+
+#define BP_PXP_CSC2_COEF1_RSVD1      27
+#define BM_PXP_CSC2_COEF1_RSVD1 0xF8000000
+#define BF_PXP_CSC2_COEF1_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC2_COEF1_RSVD1)
+#define BP_PXP_CSC2_COEF1_B1	  16
+#define BM_PXP_CSC2_COEF1_B1 0x07FF0000
+#define BF_PXP_CSC2_COEF1_B1(v)  \
+	(((v) << 16) & BM_PXP_CSC2_COEF1_B1)
+#define BP_PXP_CSC2_COEF1_RSVD0      11
+#define BM_PXP_CSC2_COEF1_RSVD0 0x0000F800
+#define BF_PXP_CSC2_COEF1_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2_COEF1_RSVD0)
+#define BP_PXP_CSC2_COEF1_A3	  0
+#define BM_PXP_CSC2_COEF1_A3 0x000007FF
+#define BF_PXP_CSC2_COEF1_A3(v)  \
+	(((v) << 0) & BM_PXP_CSC2_COEF1_A3)
+
+#define HW_PXP_CSC2_COEF2	(0x00000200)
+
+#define BP_PXP_CSC2_COEF2_RSVD1      27
+#define BM_PXP_CSC2_COEF2_RSVD1 0xF8000000
+#define BF_PXP_CSC2_COEF2_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC2_COEF2_RSVD1)
+#define BP_PXP_CSC2_COEF2_B3	  16
+#define BM_PXP_CSC2_COEF2_B3 0x07FF0000
+#define BF_PXP_CSC2_COEF2_B3(v)  \
+	(((v) << 16) & BM_PXP_CSC2_COEF2_B3)
+#define BP_PXP_CSC2_COEF2_RSVD0      11
+#define BM_PXP_CSC2_COEF2_RSVD0 0x0000F800
+#define BF_PXP_CSC2_COEF2_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2_COEF2_RSVD0)
+#define BP_PXP_CSC2_COEF2_B2	  0
+#define BM_PXP_CSC2_COEF2_B2 0x000007FF
+#define BF_PXP_CSC2_COEF2_B2(v)  \
+	(((v) << 0) & BM_PXP_CSC2_COEF2_B2)
+
+#define HW_PXP_CSC2_COEF3	(0x00000210)
+
+#define BP_PXP_CSC2_COEF3_RSVD1      27
+#define BM_PXP_CSC2_COEF3_RSVD1 0xF8000000
+#define BF_PXP_CSC2_COEF3_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC2_COEF3_RSVD1)
+#define BP_PXP_CSC2_COEF3_C2	  16
+#define BM_PXP_CSC2_COEF3_C2 0x07FF0000
+#define BF_PXP_CSC2_COEF3_C2(v)  \
+	(((v) << 16) & BM_PXP_CSC2_COEF3_C2)
+#define BP_PXP_CSC2_COEF3_RSVD0      11
+#define BM_PXP_CSC2_COEF3_RSVD0 0x0000F800
+#define BF_PXP_CSC2_COEF3_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2_COEF3_RSVD0)
+#define BP_PXP_CSC2_COEF3_C1	  0
+#define BM_PXP_CSC2_COEF3_C1 0x000007FF
+#define BF_PXP_CSC2_COEF3_C1(v)  \
+	(((v) << 0) & BM_PXP_CSC2_COEF3_C1)
+
+#define HW_PXP_CSC2_COEF4	(0x00000220)
+
+#define BP_PXP_CSC2_COEF4_RSVD1      25
+#define BM_PXP_CSC2_COEF4_RSVD1 0xFE000000
+#define BF_PXP_CSC2_COEF4_RSVD1(v) \
+	(((v) << 25) & BM_PXP_CSC2_COEF4_RSVD1)
+#define BP_PXP_CSC2_COEF4_D1	  16
+#define BM_PXP_CSC2_COEF4_D1 0x01FF0000
+#define BF_PXP_CSC2_COEF4_D1(v)  \
+	(((v) << 16) & BM_PXP_CSC2_COEF4_D1)
+#define BP_PXP_CSC2_COEF4_RSVD0      11
+#define BM_PXP_CSC2_COEF4_RSVD0 0x0000F800
+#define BF_PXP_CSC2_COEF4_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2_COEF4_RSVD0)
+#define BP_PXP_CSC2_COEF4_C3	  0
+#define BM_PXP_CSC2_COEF4_C3 0x000007FF
+#define BF_PXP_CSC2_COEF4_C3(v)  \
+	(((v) << 0) & BM_PXP_CSC2_COEF4_C3)
+
+#define HW_PXP_CSC2_COEF5	(0x00000230)
+
+#define BP_PXP_CSC2_COEF5_RSVD1      25
+#define BM_PXP_CSC2_COEF5_RSVD1 0xFE000000
+#define BF_PXP_CSC2_COEF5_RSVD1(v) \
+	(((v) << 25) & BM_PXP_CSC2_COEF5_RSVD1)
+#define BP_PXP_CSC2_COEF5_D3	  16
+#define BM_PXP_CSC2_COEF5_D3 0x01FF0000
+#define BF_PXP_CSC2_COEF5_D3(v)  \
+	(((v) << 16) & BM_PXP_CSC2_COEF5_D3)
+#define BP_PXP_CSC2_COEF5_RSVD0      9
+#define BM_PXP_CSC2_COEF5_RSVD0 0x0000FE00
+#define BF_PXP_CSC2_COEF5_RSVD0(v)  \
+	(((v) << 9) & BM_PXP_CSC2_COEF5_RSVD0)
+#define BP_PXP_CSC2_COEF5_D2	  0
+#define BM_PXP_CSC2_COEF5_D2 0x000001FF
+#define BF_PXP_CSC2_COEF5_D2(v)  \
+	(((v) << 0) & BM_PXP_CSC2_COEF5_D2)
+
+#define HW_PXP_LUT_CTRL	(0x00000240)
+
+#define BM_PXP_LUT_CTRL_BYPASS 0x80000000
+#define BP_PXP_LUT_CTRL_RSVD3	   26
+#define BM_PXP_LUT_CTRL_RSVD3 0x7C000000
+#define BF_PXP_LUT_CTRL_RSVD3(v)  \
+	(((v) << 26) & BM_PXP_LUT_CTRL_RSVD3)
+#define BP_PXP_LUT_CTRL_LOOKUP_MODE	 24
+#define BM_PXP_LUT_CTRL_LOOKUP_MODE 0x03000000
+#define BF_PXP_LUT_CTRL_LOOKUP_MODE(v)	\
+	(((v) << 24) & BM_PXP_LUT_CTRL_LOOKUP_MODE)
+#define BV_PXP_LUT_CTRL_LOOKUP_MODE__CACHE_RGB565  0x0
+#define BV_PXP_LUT_CTRL_LOOKUP_MODE__DIRECT_Y8	   0x1
+#define BV_PXP_LUT_CTRL_LOOKUP_MODE__DIRECT_RGB444 0x2
+#define BV_PXP_LUT_CTRL_LOOKUP_MODE__DIRECT_RGB454 0x3
+#define BP_PXP_LUT_CTRL_RSVD2	   18
+#define BM_PXP_LUT_CTRL_RSVD2 0x00FC0000
+#define BF_PXP_LUT_CTRL_RSVD2(v)  \
+	(((v) << 18) & BM_PXP_LUT_CTRL_RSVD2)
+#define BP_PXP_LUT_CTRL_OUT_MODE      16
+#define BM_PXP_LUT_CTRL_OUT_MODE 0x00030000
+#define BF_PXP_LUT_CTRL_OUT_MODE(v)  \
+	(((v) << 16) & BM_PXP_LUT_CTRL_OUT_MODE)
+#define BV_PXP_LUT_CTRL_OUT_MODE__RESERVED    0x0
+#define BV_PXP_LUT_CTRL_OUT_MODE__Y8	      0x1
+#define BV_PXP_LUT_CTRL_OUT_MODE__RGBW4444CFA 0x2
+#define BV_PXP_LUT_CTRL_OUT_MODE__RGB888      0x3
+#define BP_PXP_LUT_CTRL_RSVD1	   11
+#define BM_PXP_LUT_CTRL_RSVD1 0x0000F800
+#define BF_PXP_LUT_CTRL_RSVD1(v)  \
+	(((v) << 11) & BM_PXP_LUT_CTRL_RSVD1)
+#define BM_PXP_LUT_CTRL_SEL_8KB 0x00000400
+#define BM_PXP_LUT_CTRL_LRU_UPD 0x00000200
+#define BM_PXP_LUT_CTRL_INVALID 0x00000100
+#define BP_PXP_LUT_CTRL_RSVD0	   1
+#define BM_PXP_LUT_CTRL_RSVD0 0x000000FE
+#define BF_PXP_LUT_CTRL_RSVD0(v)  \
+	(((v) << 1) & BM_PXP_LUT_CTRL_RSVD0)
+#define BM_PXP_LUT_CTRL_DMA_START 0x00000001
+
+#define HW_PXP_LUT_ADDR	(0x00000250)
+
+#define BM_PXP_LUT_ADDR_RSVD2 0x80000000
+#define BP_PXP_LUT_ADDR_NUM_BYTES      16
+#define BM_PXP_LUT_ADDR_NUM_BYTES 0x7FFF0000
+#define BF_PXP_LUT_ADDR_NUM_BYTES(v)  \
+	(((v) << 16) & BM_PXP_LUT_ADDR_NUM_BYTES)
+#define BP_PXP_LUT_ADDR_RSVD1	   14
+#define BM_PXP_LUT_ADDR_RSVD1 0x0000C000
+#define BF_PXP_LUT_ADDR_RSVD1(v)  \
+	(((v) << 14) & BM_PXP_LUT_ADDR_RSVD1)
+#define BP_PXP_LUT_ADDR_ADDR	  0
+#define BM_PXP_LUT_ADDR_ADDR 0x00003FFF
+#define BF_PXP_LUT_ADDR_ADDR(v)  \
+	(((v) << 0) & BM_PXP_LUT_ADDR_ADDR)
+
+#define HW_PXP_LUT_DATA	(0x00000260)
+
+#define BP_PXP_LUT_DATA_DATA	  0
+#define BM_PXP_LUT_DATA_DATA 0xFFFFFFFF
+#define BF_PXP_LUT_DATA_DATA(v)   (v)
+
+#define HW_PXP_LUT_EXTMEM	(0x00000270)
+
+#define BP_PXP_LUT_EXTMEM_ADDR	    0
+#define BM_PXP_LUT_EXTMEM_ADDR 0xFFFFFFFF
+#define BF_PXP_LUT_EXTMEM_ADDR(v)   (v)
+
+#define HW_PXP_CFA	(0x00000280)
+
+#define BP_PXP_CFA_DATA      0
+#define BM_PXP_CFA_DATA 0xFFFFFFFF
+#define BF_PXP_CFA_DATA(v)   (v)
+
+#define HW_PXP_HIST_CTRL	(0x00000290)
+
+#define BP_PXP_HIST_CTRL_RSVD	   6
+#define BM_PXP_HIST_CTRL_RSVD 0xFFFFFFC0
+#define BF_PXP_HIST_CTRL_RSVD(v) \
+	(((v) << 6) & BM_PXP_HIST_CTRL_RSVD)
+#define BP_PXP_HIST_CTRL_PANEL_MODE	 4
+#define BM_PXP_HIST_CTRL_PANEL_MODE 0x00000030
+#define BF_PXP_HIST_CTRL_PANEL_MODE(v)	\
+	(((v) << 4) & BM_PXP_HIST_CTRL_PANEL_MODE)
+#define BV_PXP_HIST_CTRL_PANEL_MODE__GRAY4  0x0
+#define BV_PXP_HIST_CTRL_PANEL_MODE__GRAY8  0x1
+#define BV_PXP_HIST_CTRL_PANEL_MODE__GRAY16 0x2
+#define BV_PXP_HIST_CTRL_PANEL_MODE__GRAY32 0x3
+#define BP_PXP_HIST_CTRL_STATUS      0
+#define BM_PXP_HIST_CTRL_STATUS 0x0000000F
+#define BF_PXP_HIST_CTRL_STATUS(v)  \
+	(((v) << 0) & BM_PXP_HIST_CTRL_STATUS)
+
+#define HW_PXP_HIST2_PARAM	(0x000002a0)
+
+#define BP_PXP_HIST2_PARAM_RSVD      16
+#define BM_PXP_HIST2_PARAM_RSVD 0xFFFF0000
+#define BF_PXP_HIST2_PARAM_RSVD(v) \
+	(((v) << 16) & BM_PXP_HIST2_PARAM_RSVD)
+#define BP_PXP_HIST2_PARAM_RSVD1      13
+#define BM_PXP_HIST2_PARAM_RSVD1 0x0000E000
+#define BF_PXP_HIST2_PARAM_RSVD1(v)  \
+	(((v) << 13) & BM_PXP_HIST2_PARAM_RSVD1)
+#define BP_PXP_HIST2_PARAM_VALUE1      8
+#define BM_PXP_HIST2_PARAM_VALUE1 0x00001F00
+#define BF_PXP_HIST2_PARAM_VALUE1(v)  \
+	(((v) << 8) & BM_PXP_HIST2_PARAM_VALUE1)
+#define BP_PXP_HIST2_PARAM_RSVD0      5
+#define BM_PXP_HIST2_PARAM_RSVD0 0x000000E0
+#define BF_PXP_HIST2_PARAM_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_HIST2_PARAM_RSVD0)
+#define BP_PXP_HIST2_PARAM_VALUE0      0
+#define BM_PXP_HIST2_PARAM_VALUE0 0x0000001F
+#define BF_PXP_HIST2_PARAM_VALUE0(v)  \
+	(((v) << 0) & BM_PXP_HIST2_PARAM_VALUE0)
+
+#define HW_PXP_HIST4_PARAM	(0x000002b0)
+
+#define BP_PXP_HIST4_PARAM_RSVD3      29
+#define BM_PXP_HIST4_PARAM_RSVD3 0xE0000000
+#define BF_PXP_HIST4_PARAM_RSVD3(v) \
+	(((v) << 29) & BM_PXP_HIST4_PARAM_RSVD3)
+#define BP_PXP_HIST4_PARAM_VALUE3      24
+#define BM_PXP_HIST4_PARAM_VALUE3 0x1F000000
+#define BF_PXP_HIST4_PARAM_VALUE3(v)  \
+	(((v) << 24) & BM_PXP_HIST4_PARAM_VALUE3)
+#define BP_PXP_HIST4_PARAM_RSVD2      21
+#define BM_PXP_HIST4_PARAM_RSVD2 0x00E00000
+#define BF_PXP_HIST4_PARAM_RSVD2(v)  \
+	(((v) << 21) & BM_PXP_HIST4_PARAM_RSVD2)
+#define BP_PXP_HIST4_PARAM_VALUE2      16
+#define BM_PXP_HIST4_PARAM_VALUE2 0x001F0000
+#define BF_PXP_HIST4_PARAM_VALUE2(v)  \
+	(((v) << 16) & BM_PXP_HIST4_PARAM_VALUE2)
+#define BP_PXP_HIST4_PARAM_RSVD1      13
+#define BM_PXP_HIST4_PARAM_RSVD1 0x0000E000
+#define BF_PXP_HIST4_PARAM_RSVD1(v)  \
+	(((v) << 13) & BM_PXP_HIST4_PARAM_RSVD1)
+#define BP_PXP_HIST4_PARAM_VALUE1      8
+#define BM_PXP_HIST4_PARAM_VALUE1 0x00001F00
+#define BF_PXP_HIST4_PARAM_VALUE1(v)  \
+	(((v) << 8) & BM_PXP_HIST4_PARAM_VALUE1)
+#define BP_PXP_HIST4_PARAM_RSVD0      5
+#define BM_PXP_HIST4_PARAM_RSVD0 0x000000E0
+#define BF_PXP_HIST4_PARAM_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_HIST4_PARAM_RSVD0)
+#define BP_PXP_HIST4_PARAM_VALUE0      0
+#define BM_PXP_HIST4_PARAM_VALUE0 0x0000001F
+#define BF_PXP_HIST4_PARAM_VALUE0(v)  \
+	(((v) << 0) & BM_PXP_HIST4_PARAM_VALUE0)
+
+#define HW_PXP_HIST8_PARAM0	(0x000002c0)
+
+#define BP_PXP_HIST8_PARAM0_RSVD3      29
+#define BM_PXP_HIST8_PARAM0_RSVD3 0xE0000000
+#define BF_PXP_HIST8_PARAM0_RSVD3(v) \
+	(((v) << 29) & BM_PXP_HIST8_PARAM0_RSVD3)
+#define BP_PXP_HIST8_PARAM0_VALUE3	24
+#define BM_PXP_HIST8_PARAM0_VALUE3 0x1F000000
+#define BF_PXP_HIST8_PARAM0_VALUE3(v)  \
+	(((v) << 24) & BM_PXP_HIST8_PARAM0_VALUE3)
+#define BP_PXP_HIST8_PARAM0_RSVD2      21
+#define BM_PXP_HIST8_PARAM0_RSVD2 0x00E00000
+#define BF_PXP_HIST8_PARAM0_RSVD2(v)  \
+	(((v) << 21) & BM_PXP_HIST8_PARAM0_RSVD2)
+#define BP_PXP_HIST8_PARAM0_VALUE2	16
+#define BM_PXP_HIST8_PARAM0_VALUE2 0x001F0000
+#define BF_PXP_HIST8_PARAM0_VALUE2(v)  \
+	(((v) << 16) & BM_PXP_HIST8_PARAM0_VALUE2)
+#define BP_PXP_HIST8_PARAM0_RSVD1      13
+#define BM_PXP_HIST8_PARAM0_RSVD1 0x0000E000
+#define BF_PXP_HIST8_PARAM0_RSVD1(v)  \
+	(((v) << 13) & BM_PXP_HIST8_PARAM0_RSVD1)
+#define BP_PXP_HIST8_PARAM0_VALUE1	8
+#define BM_PXP_HIST8_PARAM0_VALUE1 0x00001F00
+#define BF_PXP_HIST8_PARAM0_VALUE1(v)  \
+	(((v) << 8) & BM_PXP_HIST8_PARAM0_VALUE1)
+#define BP_PXP_HIST8_PARAM0_RSVD0      5
+#define BM_PXP_HIST8_PARAM0_RSVD0 0x000000E0
+#define BF_PXP_HIST8_PARAM0_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_HIST8_PARAM0_RSVD0)
+#define BP_PXP_HIST8_PARAM0_VALUE0	0
+#define BM_PXP_HIST8_PARAM0_VALUE0 0x0000001F
+#define BF_PXP_HIST8_PARAM0_VALUE0(v)  \
+	(((v) << 0) & BM_PXP_HIST8_PARAM0_VALUE0)
+
+#define HW_PXP_HIST8_PARAM1	(0x000002d0)
+
+#define BP_PXP_HIST8_PARAM1_RSVD7      29
+#define BM_PXP_HIST8_PARAM1_RSVD7 0xE0000000
+#define BF_PXP_HIST8_PARAM1_RSVD7(v) \
+	(((v) << 29) & BM_PXP_HIST8_PARAM1_RSVD7)
+#define BP_PXP_HIST8_PARAM1_VALUE7	24
+#define BM_PXP_HIST8_PARAM1_VALUE7 0x1F000000
+#define BF_PXP_HIST8_PARAM1_VALUE7(v)  \
+	(((v) << 24) & BM_PXP_HIST8_PARAM1_VALUE7)
+#define BP_PXP_HIST8_PARAM1_RSVD6      21
+#define BM_PXP_HIST8_PARAM1_RSVD6 0x00E00000
+#define BF_PXP_HIST8_PARAM1_RSVD6(v)  \
+	(((v) << 21) & BM_PXP_HIST8_PARAM1_RSVD6)
+#define BP_PXP_HIST8_PARAM1_VALUE6	16
+#define BM_PXP_HIST8_PARAM1_VALUE6 0x001F0000
+#define BF_PXP_HIST8_PARAM1_VALUE6(v)  \
+	(((v) << 16) & BM_PXP_HIST8_PARAM1_VALUE6)
+#define BP_PXP_HIST8_PARAM1_RSVD5      13
+#define BM_PXP_HIST8_PARAM1_RSVD5 0x0000E000
+#define BF_PXP_HIST8_PARAM1_RSVD5(v)  \
+	(((v) << 13) & BM_PXP_HIST8_PARAM1_RSVD5)
+#define BP_PXP_HIST8_PARAM1_VALUE5	8
+#define BM_PXP_HIST8_PARAM1_VALUE5 0x00001F00
+#define BF_PXP_HIST8_PARAM1_VALUE5(v)  \
+	(((v) << 8) & BM_PXP_HIST8_PARAM1_VALUE5)
+#define BP_PXP_HIST8_PARAM1_RSVD4      5
+#define BM_PXP_HIST8_PARAM1_RSVD4 0x000000E0
+#define BF_PXP_HIST8_PARAM1_RSVD4(v)  \
+	(((v) << 5) & BM_PXP_HIST8_PARAM1_RSVD4)
+#define BP_PXP_HIST8_PARAM1_VALUE4	0
+#define BM_PXP_HIST8_PARAM1_VALUE4 0x0000001F
+#define BF_PXP_HIST8_PARAM1_VALUE4(v)  \
+	(((v) << 0) & BM_PXP_HIST8_PARAM1_VALUE4)
+
+#define HW_PXP_HIST16_PARAM0	(0x000002e0)
+
+#define BP_PXP_HIST16_PARAM0_RSVD3	29
+#define BM_PXP_HIST16_PARAM0_RSVD3 0xE0000000
+#define BF_PXP_HIST16_PARAM0_RSVD3(v) \
+	(((v) << 29) & BM_PXP_HIST16_PARAM0_RSVD3)
+#define BP_PXP_HIST16_PARAM0_VALUE3	 24
+#define BM_PXP_HIST16_PARAM0_VALUE3 0x1F000000
+#define BF_PXP_HIST16_PARAM0_VALUE3(v)	\
+	(((v) << 24) & BM_PXP_HIST16_PARAM0_VALUE3)
+#define BP_PXP_HIST16_PARAM0_RSVD2	21
+#define BM_PXP_HIST16_PARAM0_RSVD2 0x00E00000
+#define BF_PXP_HIST16_PARAM0_RSVD2(v)  \
+	(((v) << 21) & BM_PXP_HIST16_PARAM0_RSVD2)
+#define BP_PXP_HIST16_PARAM0_VALUE2	 16
+#define BM_PXP_HIST16_PARAM0_VALUE2 0x001F0000
+#define BF_PXP_HIST16_PARAM0_VALUE2(v)	\
+	(((v) << 16) & BM_PXP_HIST16_PARAM0_VALUE2)
+#define BP_PXP_HIST16_PARAM0_RSVD1	13
+#define BM_PXP_HIST16_PARAM0_RSVD1 0x0000E000
+#define BF_PXP_HIST16_PARAM0_RSVD1(v)  \
+	(((v) << 13) & BM_PXP_HIST16_PARAM0_RSVD1)
+#define BP_PXP_HIST16_PARAM0_VALUE1	 8
+#define BM_PXP_HIST16_PARAM0_VALUE1 0x00001F00
+#define BF_PXP_HIST16_PARAM0_VALUE1(v)	\
+	(((v) << 8) & BM_PXP_HIST16_PARAM0_VALUE1)
+#define BP_PXP_HIST16_PARAM0_RSVD0	5
+#define BM_PXP_HIST16_PARAM0_RSVD0 0x000000E0
+#define BF_PXP_HIST16_PARAM0_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_HIST16_PARAM0_RSVD0)
+#define BP_PXP_HIST16_PARAM0_VALUE0	 0
+#define BM_PXP_HIST16_PARAM0_VALUE0 0x0000001F
+#define BF_PXP_HIST16_PARAM0_VALUE0(v)	\
+	(((v) << 0) & BM_PXP_HIST16_PARAM0_VALUE0)
+
+#define HW_PXP_HIST16_PARAM1	(0x000002f0)
+
+#define BP_PXP_HIST16_PARAM1_RSVD7	29
+#define BM_PXP_HIST16_PARAM1_RSVD7 0xE0000000
+#define BF_PXP_HIST16_PARAM1_RSVD7(v) \
+	(((v) << 29) & BM_PXP_HIST16_PARAM1_RSVD7)
+#define BP_PXP_HIST16_PARAM1_VALUE7	 24
+#define BM_PXP_HIST16_PARAM1_VALUE7 0x1F000000
+#define BF_PXP_HIST16_PARAM1_VALUE7(v)	\
+	(((v) << 24) & BM_PXP_HIST16_PARAM1_VALUE7)
+#define BP_PXP_HIST16_PARAM1_RSVD6	21
+#define BM_PXP_HIST16_PARAM1_RSVD6 0x00E00000
+#define BF_PXP_HIST16_PARAM1_RSVD6(v)  \
+	(((v) << 21) & BM_PXP_HIST16_PARAM1_RSVD6)
+#define BP_PXP_HIST16_PARAM1_VALUE6	 16
+#define BM_PXP_HIST16_PARAM1_VALUE6 0x001F0000
+#define BF_PXP_HIST16_PARAM1_VALUE6(v)	\
+	(((v) << 16) & BM_PXP_HIST16_PARAM1_VALUE6)
+#define BP_PXP_HIST16_PARAM1_RSVD5	13
+#define BM_PXP_HIST16_PARAM1_RSVD5 0x0000E000
+#define BF_PXP_HIST16_PARAM1_RSVD5(v)  \
+	(((v) << 13) & BM_PXP_HIST16_PARAM1_RSVD5)
+#define BP_PXP_HIST16_PARAM1_VALUE5	 8
+#define BM_PXP_HIST16_PARAM1_VALUE5 0x00001F00
+#define BF_PXP_HIST16_PARAM1_VALUE5(v)	\
+	(((v) << 8) & BM_PXP_HIST16_PARAM1_VALUE5)
+#define BP_PXP_HIST16_PARAM1_RSVD4	5
+#define BM_PXP_HIST16_PARAM1_RSVD4 0x000000E0
+#define BF_PXP_HIST16_PARAM1_RSVD4(v)  \
+	(((v) << 5) & BM_PXP_HIST16_PARAM1_RSVD4)
+#define BP_PXP_HIST16_PARAM1_VALUE4	 0
+#define BM_PXP_HIST16_PARAM1_VALUE4 0x0000001F
+#define BF_PXP_HIST16_PARAM1_VALUE4(v)	\
+	(((v) << 0) & BM_PXP_HIST16_PARAM1_VALUE4)
+
+#define HW_PXP_HIST16_PARAM2	(0x00000300)
+
+#define BP_PXP_HIST16_PARAM2_RSVD11	 29
+#define BM_PXP_HIST16_PARAM2_RSVD11 0xE0000000
+#define BF_PXP_HIST16_PARAM2_RSVD11(v) \
+	(((v) << 29) & BM_PXP_HIST16_PARAM2_RSVD11)
+#define BP_PXP_HIST16_PARAM2_VALUE11	  24
+#define BM_PXP_HIST16_PARAM2_VALUE11 0x1F000000
+#define BF_PXP_HIST16_PARAM2_VALUE11(v)  \
+	(((v) << 24) & BM_PXP_HIST16_PARAM2_VALUE11)
+#define BP_PXP_HIST16_PARAM2_RSVD10	 21
+#define BM_PXP_HIST16_PARAM2_RSVD10 0x00E00000
+#define BF_PXP_HIST16_PARAM2_RSVD10(v)	\
+	(((v) << 21) & BM_PXP_HIST16_PARAM2_RSVD10)
+#define BP_PXP_HIST16_PARAM2_VALUE10	  16
+#define BM_PXP_HIST16_PARAM2_VALUE10 0x001F0000
+#define BF_PXP_HIST16_PARAM2_VALUE10(v)  \
+	(((v) << 16) & BM_PXP_HIST16_PARAM2_VALUE10)
+#define BP_PXP_HIST16_PARAM2_RSVD9	13
+#define BM_PXP_HIST16_PARAM2_RSVD9 0x0000E000
+#define BF_PXP_HIST16_PARAM2_RSVD9(v)  \
+	(((v) << 13) & BM_PXP_HIST16_PARAM2_RSVD9)
+#define BP_PXP_HIST16_PARAM2_VALUE9	 8
+#define BM_PXP_HIST16_PARAM2_VALUE9 0x00001F00
+#define BF_PXP_HIST16_PARAM2_VALUE9(v)	\
+	(((v) << 8) & BM_PXP_HIST16_PARAM2_VALUE9)
+#define BP_PXP_HIST16_PARAM2_RSVD8	5
+#define BM_PXP_HIST16_PARAM2_RSVD8 0x000000E0
+#define BF_PXP_HIST16_PARAM2_RSVD8(v)  \
+	(((v) << 5) & BM_PXP_HIST16_PARAM2_RSVD8)
+#define BP_PXP_HIST16_PARAM2_VALUE8	 0
+#define BM_PXP_HIST16_PARAM2_VALUE8 0x0000001F
+#define BF_PXP_HIST16_PARAM2_VALUE8(v)	\
+	(((v) << 0) & BM_PXP_HIST16_PARAM2_VALUE8)
+
+#define HW_PXP_HIST16_PARAM3	(0x00000310)
+
+#define BP_PXP_HIST16_PARAM3_RSVD15	 29
+#define BM_PXP_HIST16_PARAM3_RSVD15 0xE0000000
+#define BF_PXP_HIST16_PARAM3_RSVD15(v) \
+	(((v) << 29) & BM_PXP_HIST16_PARAM3_RSVD15)
+#define BP_PXP_HIST16_PARAM3_VALUE15	  24
+#define BM_PXP_HIST16_PARAM3_VALUE15 0x1F000000
+#define BF_PXP_HIST16_PARAM3_VALUE15(v)  \
+	(((v) << 24) & BM_PXP_HIST16_PARAM3_VALUE15)
+#define BP_PXP_HIST16_PARAM3_RSVD14	 21
+#define BM_PXP_HIST16_PARAM3_RSVD14 0x00E00000
+#define BF_PXP_HIST16_PARAM3_RSVD14(v)	\
+	(((v) << 21) & BM_PXP_HIST16_PARAM3_RSVD14)
+#define BP_PXP_HIST16_PARAM3_VALUE14	  16
+#define BM_PXP_HIST16_PARAM3_VALUE14 0x001F0000
+#define BF_PXP_HIST16_PARAM3_VALUE14(v)  \
+	(((v) << 16) & BM_PXP_HIST16_PARAM3_VALUE14)
+#define BP_PXP_HIST16_PARAM3_RSVD13	 13
+#define BM_PXP_HIST16_PARAM3_RSVD13 0x0000E000
+#define BF_PXP_HIST16_PARAM3_RSVD13(v)	\
+	(((v) << 13) & BM_PXP_HIST16_PARAM3_RSVD13)
+#define BP_PXP_HIST16_PARAM3_VALUE13	  8
+#define BM_PXP_HIST16_PARAM3_VALUE13 0x00001F00
+#define BF_PXP_HIST16_PARAM3_VALUE13(v)  \
+	(((v) << 8) & BM_PXP_HIST16_PARAM3_VALUE13)
+#define BP_PXP_HIST16_PARAM3_RSVD12	 5
+#define BM_PXP_HIST16_PARAM3_RSVD12 0x000000E0
+#define BF_PXP_HIST16_PARAM3_RSVD12(v)	\
+	(((v) << 5) & BM_PXP_HIST16_PARAM3_RSVD12)
+#define BP_PXP_HIST16_PARAM3_VALUE12	  0
+#define BM_PXP_HIST16_PARAM3_VALUE12 0x0000001F
+#define BF_PXP_HIST16_PARAM3_VALUE12(v)  \
+	(((v) << 0) & BM_PXP_HIST16_PARAM3_VALUE12)
+
+#define HW_PXP_POWER	(0x00000320)
+
+#define BP_PXP_POWER_CTRL      12
+#define BM_PXP_POWER_CTRL 0xFFFFF000
+#define BF_PXP_POWER_CTRL(v) \
+	(((v) << 12) & BM_PXP_POWER_CTRL)
+#define BP_PXP_POWER_ROT_MEM_LP_STATE	   9
+#define BM_PXP_POWER_ROT_MEM_LP_STATE 0x00000E00
+#define BF_PXP_POWER_ROT_MEM_LP_STATE(v)  \
+	(((v) << 9) & BM_PXP_POWER_ROT_MEM_LP_STATE)
+#define BV_PXP_POWER_ROT_MEM_LP_STATE__NONE 0x0
+#define BV_PXP_POWER_ROT_MEM_LP_STATE__LS   0x1
+#define BV_PXP_POWER_ROT_MEM_LP_STATE__DS   0x2
+#define BV_PXP_POWER_ROT_MEM_LP_STATE__SD   0x4
+#define BP_PXP_POWER_LUT_LP_STATE_WAY1_BANKN	  6
+#define BM_PXP_POWER_LUT_LP_STATE_WAY1_BANKN 0x000001C0
+#define BF_PXP_POWER_LUT_LP_STATE_WAY1_BANKN(v)  \
+	(((v) << 6) & BM_PXP_POWER_LUT_LP_STATE_WAY1_BANKN)
+#define BV_PXP_POWER_LUT_LP_STATE_WAY1_BANKN__NONE 0x0
+#define BV_PXP_POWER_LUT_LP_STATE_WAY1_BANKN__LS   0x1
+#define BV_PXP_POWER_LUT_LP_STATE_WAY1_BANKN__DS   0x2
+#define BV_PXP_POWER_LUT_LP_STATE_WAY1_BANKN__SD   0x4
+#define BP_PXP_POWER_LUT_LP_STATE_WAY0_BANKN	  3
+#define BM_PXP_POWER_LUT_LP_STATE_WAY0_BANKN 0x00000038
+#define BF_PXP_POWER_LUT_LP_STATE_WAY0_BANKN(v)  \
+	(((v) << 3) & BM_PXP_POWER_LUT_LP_STATE_WAY0_BANKN)
+#define BV_PXP_POWER_LUT_LP_STATE_WAY0_BANKN__NONE 0x0
+#define BV_PXP_POWER_LUT_LP_STATE_WAY0_BANKN__LS   0x1
+#define BV_PXP_POWER_LUT_LP_STATE_WAY0_BANKN__DS   0x2
+#define BV_PXP_POWER_LUT_LP_STATE_WAY0_BANKN__SD   0x4
+#define BP_PXP_POWER_LUT_LP_STATE_WAY0_BANK0	  0
+#define BM_PXP_POWER_LUT_LP_STATE_WAY0_BANK0 0x00000007
+#define BF_PXP_POWER_LUT_LP_STATE_WAY0_BANK0(v)  \
+	(((v) << 0) & BM_PXP_POWER_LUT_LP_STATE_WAY0_BANK0)
+#define BV_PXP_POWER_LUT_LP_STATE_WAY0_BANK0__NONE 0x0
+#define BV_PXP_POWER_LUT_LP_STATE_WAY0_BANK0__LS   0x1
+#define BV_PXP_POWER_LUT_LP_STATE_WAY0_BANK0__DS   0x2
+#define BV_PXP_POWER_LUT_LP_STATE_WAY0_BANK0__SD   0x4
+
+#define HW_PXP_NEXT	(0x00000400)
+
+#define BP_PXP_NEXT_POINTER	 2
+#define BM_PXP_NEXT_POINTER 0xFFFFFFFC
+#define BF_PXP_NEXT_POINTER(v) \
+	(((v) << 2) & BM_PXP_NEXT_POINTER)
+#define BM_PXP_NEXT_RSVD 0x00000002
+#define BM_PXP_NEXT_ENABLED 0x00000001
+
+#define HW_PXP_DEBUGCTRL	(0x00000410)
+
+#define BP_PXP_DEBUGCTRL_RSVD	   12
+#define BM_PXP_DEBUGCTRL_RSVD 0xFFFFF000
+#define BF_PXP_DEBUGCTRL_RSVD(v) \
+	(((v) << 12) & BM_PXP_DEBUGCTRL_RSVD)
+#define BP_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT      8
+#define BM_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT 0x00000F00
+#define BF_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT(v)  \
+	(((v) << 8) & BM_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT)
+#define BV_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT__NONE     0x0
+#define BV_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT__MISS_CNT 0x1
+#define BV_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT__HIT_CNT  0x2
+#define BV_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT__LAT_CNT  0x4
+#define BV_PXP_DEBUGCTRL_LUT_CLR_STAT_CNT__MAX_LAT  0x8
+#define BP_PXP_DEBUGCTRL_SELECT      0
+#define BM_PXP_DEBUGCTRL_SELECT 0x000000FF
+#define BF_PXP_DEBUGCTRL_SELECT(v)  \
+	(((v) << 0) & BM_PXP_DEBUGCTRL_SELECT)
+#define BV_PXP_DEBUGCTRL_SELECT__NONE	     0x0
+#define BV_PXP_DEBUGCTRL_SELECT__CTRL	     0x1
+#define BV_PXP_DEBUGCTRL_SELECT__PSBUF	     0x2
+#define BV_PXP_DEBUGCTRL_SELECT__PSBAX	     0x3
+#define BV_PXP_DEBUGCTRL_SELECT__PSBAY	     0x4
+#define BV_PXP_DEBUGCTRL_SELECT__ASBUF	     0x5
+#define BV_PXP_DEBUGCTRL_SELECT__ROTATION    0x6
+#define BV_PXP_DEBUGCTRL_SELECT__OUTBUF0     0x7
+#define BV_PXP_DEBUGCTRL_SELECT__OUTBUF1     0x8
+#define BV_PXP_DEBUGCTRL_SELECT__OUTBUF2     0x9
+#define BV_PXP_DEBUGCTRL_SELECT__LUT_STAT    0x10
+#define BV_PXP_DEBUGCTRL_SELECT__LUT_MISS    0x11
+#define BV_PXP_DEBUGCTRL_SELECT__LUT_HIT     0x12
+#define BV_PXP_DEBUGCTRL_SELECT__LUT_LAT     0x13
+#define BV_PXP_DEBUGCTRL_SELECT__LUT_MAX_LAT 0x14
+
+#define HW_PXP_DEBUG	(0x00000420)
+
+#define BP_PXP_DEBUG_DATA      0
+#define BM_PXP_DEBUG_DATA 0xFFFFFFFF
+#define BF_PXP_DEBUG_DATA(v)   (v)
+
+#define HW_PXP_VERSION	(0x00000430)
+
+#define BP_PXP_VERSION_MAJOR	  24
+#define BM_PXP_VERSION_MAJOR 0xFF000000
+#define BF_PXP_VERSION_MAJOR(v) \
+	(((v) << 24) & BM_PXP_VERSION_MAJOR)
+#define BP_PXP_VERSION_MINOR	  16
+#define BM_PXP_VERSION_MINOR 0x00FF0000
+#define BF_PXP_VERSION_MINOR(v)  \
+	(((v) << 16) & BM_PXP_VERSION_MINOR)
+#define BP_PXP_VERSION_STEP	 0
+#define BM_PXP_VERSION_STEP 0x0000FFFF
+#define BF_PXP_VERSION_STEP(v)	\
+	(((v) << 0) & BM_PXP_VERSION_STEP)
+#endif /* __ARCH_ARM___PXP_H */
diff --git a/include/linux/platform_data/dma-imx.h b/include/linux/platform_data/dma-imx.h
index bcbc6c3..0eff734 100644
--- a/include/linux/platform_data/dma-imx.h
+++ b/include/linux/platform_data/dma-imx.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -59,6 +59,11 @@ static inline int imx_dma_is_ipu(struct dma_chan *chan)
 	return !strcmp(dev_name(chan->device->dev), "ipu-core");
 }
 
+static inline int imx_dma_is_pxp(struct dma_chan *chan)
+{
+	return strstr(dev_name(chan->device->dev), "pxp") != NULL;
+}
+
 static inline int imx_dma_is_general_purpose(struct dma_chan *chan)
 {
 	return !strcmp(chan->device->dev->driver->name, "imx-sdma") ||
diff --git a/include/uapi/linux/pxp_dma.h b/include/uapi/linux/pxp_dma.h
index 87fcdc7..bc280a7 100644
--- a/include/uapi/linux/pxp_dma.h
+++ b/include/uapi/linux/pxp_dma.h
@@ -21,8 +21,10 @@
 
 #include <linux/posix_types.h>
 
+#ifndef __KERNEL__
 typedef unsigned long dma_addr_t;
 typedef unsigned char bool;
+#endif
 
 /*  PXP Pixel format definitions */
 /*  Four-character-code (FOURCC) */
-- 
1.7.5.4

