From 6a9a07c8894f426c5058f491d22442fa3c6413af Mon Sep 17 00:00:00 2001
From: "haibo.chen" <haibo.chen@freescale.com>
Date: Tue, 26 Aug 2014 11:27:48 +0800
Subject: [PATCH 0915/1074] ENGR00329448 i2c: imx: add arbitration lost check

According to the spec, for multimaster mode, if I2C is enabled
when the bus is busy and asserts start, hardware inhibits the
transmission, clears MSTA without signaling a stop, generate
an interrupt, and set I2C_I2SR[IAL] to indicate a failed attempt
to engage the bus, which means arbitration lost. In this case,
we should first test I2C_I2SR[IAL], and clear this bit if it is
set, and then I2C controller default to slave receive mode.

This patch check the IAL bit every time before an I2c transmission.
if IAL is set, clear it and make I2C controller to default mode.

Signed-off-by: haibo.chen <haibo.chen@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/i2c/busses/i2c-imx.c |    7 +++++++
 1 files changed, 7 insertions(+), 0 deletions(-)

diff --git a/drivers/i2c/busses/i2c-imx.c b/drivers/i2c/busses/i2c-imx.c
index 584e002..fc934d5 100644
--- a/drivers/i2c/busses/i2c-imx.c
+++ b/drivers/i2c/busses/i2c-imx.c
@@ -266,6 +266,13 @@ static int i2c_imx_bus_busy(struct imx_i2c_struct *i2c_imx, int for_busy)
 
 	while (1) {
 		temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);
+
+		/** check for arbitration lost  **/
+		if (temp & I2SR_IAL) {
+			writeb(temp & (~I2SR_IAL), i2c_imx->base + IMX_I2C_I2CR);
+			return -EIO;
+		}
+
 		if (for_busy && (temp & I2SR_IBB))
 			break;
 		if (!for_busy && !(temp & I2SR_IBB))
-- 
1.7.5.4

