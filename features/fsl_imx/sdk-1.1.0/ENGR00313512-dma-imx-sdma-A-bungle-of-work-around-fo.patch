From 15507dbadfd0837e41efff56030442ad7e81cd8d Mon Sep 17 00:00:00 2001
From: Nicolin Chen <Guangyu.Chen@freescale.com>
Date: Wed, 16 Jul 2014 12:16:31 +0800
Subject: [PATCH 0929/1074] ENGR00313512 dma: imx-sdma: A bungle of work
 around for BUG ON issue

The BUG ON issue could be triggered by such scenarios:

A)
issue_pending(1) ->
                <- SDMA irq(1)
                <- SDMA tasklet(1)   //Normal case
issue_pending(2) ->
terminate_all(2) ->
... system suspend/resume
issue_pending(3) ->
                <- SDMA irq(2)
                <- SDMA irq(3)     //might also happen after tasklet(2)
                <- SDMA tasklet(2)
                <- SDMA tasklet(3) //BUG ON

B)
issue_pending(1) ->
                <- SDMA irq(1)
                <- SDMA tasklet(1)   //Normal case
issue_pending(2) ->
                <- SDMA irq(2)   //might also happen after terminate_all(2)
terminate_all(2) ->
... system suspend/resume
issue_pending(3) ->
                <- SDMA irq(3)     //might also happen after tasklet(2)
                <- SDMA tasklet(2)
                <- SDMA tasklet(3) //BUG ON

The best fix for this issue is to eradicate irq(2) or tasklet(2).

However, currently we couldn't find an effective fix for both cases above.

Thus this fix could be treated as a work around. It fixes this issue by Reduce
the possiblity of irq(2) and tasklet(3).

Signed-off-by: Nicolin Chen <Guangyu.Chen@freescale.com>
Signed-off-by: Robin Gong <b38343@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/dma/imx-sdma.c |   21 ++++++++++++++++++---
 1 files changed, 18 insertions(+), 3 deletions(-)

diff --git a/drivers/dma/imx-sdma.c b/drivers/dma/imx-sdma.c
index c77287a..708ae23 100644
--- a/drivers/dma/imx-sdma.c
+++ b/drivers/dma/imx-sdma.c
@@ -703,6 +703,14 @@ static void sdma_tasklet(unsigned long data)
 {
 	struct sdma_channel *sdmac = (struct sdma_channel *) data;
 	struct sdma_engine *sdma = sdmac->sdma;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sdmac->lock, flags);
+	if (sdmac->status != DMA_IN_PROGRESS) {
+		spin_unlock_irqrestore(&sdmac->lock, flags);
+		return;
+	}
+	spin_unlock_irqrestore(&sdmac->lock, flags);
 
 	switch (sdmac->mode) {
 	case SDMA_MODE_LOOP:
@@ -723,7 +731,7 @@ static void sdma_tasklet(unsigned long data)
 static irqreturn_t sdma_int_handler(int irq, void *dev_id)
 {
 	struct sdma_engine *sdma = dev_id;
-	unsigned long stat;
+	unsigned long stat, flags;
 
 	stat = readl_relaxed(sdma->regs + SDMA_H_INTR);
 	/* not interested in channel 0 interrupts */
@@ -734,7 +742,10 @@ static irqreturn_t sdma_int_handler(int irq, void *dev_id)
 		int channel = fls(stat) - 1;
 		struct sdma_channel *sdmac = &sdma->channel[channel];
 
-		tasklet_schedule(&sdmac->tasklet);
+		spin_lock_irqsave(&sdmac->lock, flags);
+		if (sdmac->status == DMA_IN_PROGRESS)
+			tasklet_schedule(&sdmac->tasklet);
+		spin_unlock_irqrestore(&sdmac->lock, flags);
 
 		__clear_bit(channel, &stat);
 	}
@@ -909,9 +920,13 @@ static void sdma_disable_channel(struct sdma_channel *sdmac)
 {
 	struct sdma_engine *sdma = sdmac->sdma;
 	int channel = sdmac->channel;
+	unsigned long flags;
 
-	writel_relaxed(BIT(channel), sdma->regs + SDMA_H_STATSTOP);
+	spin_lock_irqsave(&sdmac->lock, flags);
 	sdmac->status = DMA_ERROR;
+	spin_unlock_irqrestore(&sdmac->lock, flags);
+
+	writel_relaxed(BIT(channel), sdma->regs + SDMA_H_STATSTOP);
 }
 
 static int sdma_config_channel(struct sdma_channel *sdmac)
-- 
1.7.5.4

