From 45cd4f55b437273ef3c6e8fc6f3904550fbd81be Mon Sep 17 00:00:00 2001
From: Fugang Duan <B38611@freescale.com>
Date: Thu, 17 Apr 2014 15:40:00 +0800
Subject: [PATCH 1054/1074] ENGR00309045 net: fec_ptp: fix timestamp errors
 when do stress test

"FSL_stressPTP" tool is supposed to test the capability characteristics of
a ptp stack porting. The stresstest shall measure the overall load of the
stack under test by sending delay request and signalling messages.The higher
the overall load on the stack is, the higher your packet loss will be.

The patch fix the timestamp error in high overall load stress test like:
./FSL_stressPTP -u -b 10.192.242.10 -d 10.192.242.6 -e eth0 -m 00:01:02:04:04:19
 -i 100 -t 10 -f -6 -s -6 -c 10

And enet interrupt coalescing feature introduce ptp packet latency, which may
cause that the timestamp don't store the related timestamp buffer when stack
use ioctl interface to access the message. So add some 4ms delay after getting
timestamp fail to let the next looking up success. Suggest to disable interrupt
coalescing feature by ethtool when run 1588 cases.

Signed-off-by: Fugang Duan <B38611@freescale.com>
(cherry picked from commit 11107938cc5a4a7cb4e5fc5e00d248183ed43d93)
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/net/ethernet/freescale/fec_ptp.c |   37 +++++++++++++++++-------------
 1 files changed, 21 insertions(+), 16 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fec_ptp.c b/drivers/net/ethernet/freescale/fec_ptp.c
index 98f702f..0e0ba20 100644
--- a/drivers/net/ethernet/freescale/fec_ptp.c
+++ b/drivers/net/ethernet/freescale/fec_ptp.c
@@ -129,12 +129,12 @@ static int fec_ptp_insert(struct fec_ptp_circular *ptp_buf,
 {
 	struct fec_ptp_ts_data *tmp;
 
-	if (fec_ptp_is_full(ptp_buf))
-		ptp_buf->end = fec_ptp_calc_index(ptp_buf->size,
-						ptp_buf->end, 1);
-
 	tmp = (ptp_buf->data_buf + ptp_buf->end);
 	memcpy(tmp, data, sizeof(struct fec_ptp_ts_data));
+	if (fec_ptp_is_full(ptp_buf))
+		/* drop one in front */
+		ptp_buf->front =
+			fec_ptp_calc_index(ptp_buf->size, ptp_buf->front, 1);
 	ptp_buf->end = fec_ptp_calc_index(ptp_buf->size, ptp_buf->end, 1);
 
 	return 0;
@@ -185,7 +185,6 @@ static int fec_ptp_find_and_remove(struct fec_ptp_circular *ptp_buf,
 		return 1;
 	}
 	*ts = (ptp_buf->data_buf + i)->ts;
-	ptp_buf->front = fec_ptp_calc_index(size, ptp_buf->front, 1);
 
 	return 0;
 }
@@ -822,11 +821,14 @@ int fec_ptp_set(struct net_device *ndev, struct ifreq *ifr)
 		if (0 != copy_from_user(&p_ts.ident,
 			&p_ts_user->ident, sizeof(p_ts.ident)))
 			return -EINVAL;
-		retval = fec_ptp_find_and_remove(&fep->rx_timestamps,
-				&p_ts.ident, &rx_time);
-		if (retval == 0 &&
-			copy_to_user((void __user *)(&p_ts_user->ts),
-				&rx_time, sizeof(rx_time)))
+
+		if (fec_ptp_find_and_remove(&fep->rx_timestamps,
+			&p_ts.ident, &rx_time)) {
+			usleep_range(4000, 5000);
+			return -EAGAIN;
+		}
+		if (copy_to_user((void __user *)(&p_ts_user->ts),
+			&rx_time, sizeof(rx_time)))
 			return -EFAULT;
 		break;
 	case PTP_GET_TX_TIMESTAMP:
@@ -834,12 +836,15 @@ int fec_ptp_set(struct net_device *ndev, struct ifreq *ifr)
 		if (0 != copy_from_user(&p_ts.ident,
 			&p_ts_user->ident, sizeof(p_ts.ident)))
 			return -EINVAL;
-		retval = fec_ptp_find_and_remove(&fep->tx_timestamps,
-				&p_ts.ident, &tx_time);
-		if (retval == 0 &&
-			copy_to_user((void __user *)(&p_ts_user->ts),
-				&tx_time, sizeof(tx_time)))
-			retval = -EFAULT;
+
+		if (fec_ptp_find_and_remove(&fep->tx_timestamps,
+			&p_ts.ident, &tx_time)) {
+			usleep_range(4000, 5000);
+			return -EAGAIN;
+		}
+		if (copy_to_user((void __user *)(&p_ts_user->ts),
+			&tx_time, sizeof(tx_time)))
+			return -EFAULT;
 		break;
 	case PTP_GET_CURRENT_TIME:
 		fec_get_curr_cnt(fep, &curr_time);
-- 
1.7.5.4

