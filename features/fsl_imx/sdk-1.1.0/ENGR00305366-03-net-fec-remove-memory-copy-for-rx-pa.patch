From 4288248f7decbc6ba0023a3d2f51b45d93b3d2e5 Mon Sep 17 00:00:00 2001
From: Fugang Duan <B38611@freescale.com>
Date: Mon, 31 Mar 2014 10:30:12 +0800
Subject: [PATCH 1050/1074] ENGR00305366-03 net: fec: remove memory copy for
 rx path

Re-allocate skb instead of memory copy skb in rx path to improve
imx6sx enet rx performance. After the patch, rx performance can
reach at 940Mbps (cpu loading is near to 100%) with below interrupt
coalescing setting and cpu frequency is 996Mhz.
	enet reg 0x021880F0=C4000B00
	enet reg 0x02188100=C5000900

Signed-off-by: Fugang Duan <B38611@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/net/ethernet/freescale/fec.h      |   11 ++-
 drivers/net/ethernet/freescale/fec_main.c |   89 +++++++++++++++-------------
 2 files changed, 55 insertions(+), 45 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fec.h b/drivers/net/ethernet/freescale/fec.h
index 05cc10d..ca3e08a 100644
--- a/drivers/net/ethernet/freescale/fec.h
+++ b/drivers/net/ethernet/freescale/fec.h
@@ -251,6 +251,11 @@ struct bufdesc_ex {
 #define BD_ENET_TX_PINS         0x10000000
 #define BD_ENET_TX_IINS         0x08000000
 
+#if defined(CONFIG_ARM)
+#define FEC_ALIGNMENT   0x3f
+#else
+#define FEC_ALIGNMENT   0x3
+#endif
 
 /* This device has up to three irqs on some platforms */
 #define FEC_IRQ_NUM		3
@@ -270,10 +275,8 @@ struct bufdesc_ex {
  * the skbuffer directly.
  */
 
-#define FEC_ENET_RX_PAGES	256
-#define FEC_ENET_RX_FRSIZE	2048
-#define FEC_ENET_RX_FRPPG	(PAGE_SIZE / FEC_ENET_RX_FRSIZE)
-#define RX_RING_SIZE		(FEC_ENET_RX_FRPPG * FEC_ENET_RX_PAGES)
+#define FEC_ENET_RX_FRSIZE	(1522 + FEC_ALIGNMENT)
+#define RX_RING_SIZE		256
 #define FEC_ENET_TX_FRSIZE	2048
 #define FEC_ENET_TX_FRPPG	(PAGE_SIZE / FEC_ENET_TX_FRSIZE)
 #define TX_RING_SIZE		512	/* Must be power of two */
diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c
index 1e9c1dd..208a483 100644
--- a/drivers/net/ethernet/freescale/fec_main.c
+++ b/drivers/net/ethernet/freescale/fec_main.c
@@ -63,12 +63,6 @@ static void set_multicast_list(struct net_device *ndev);
 static void fec_reset_phy(struct platform_device *pdev);
 static void fec_enet_itr_coal_init(struct net_device *ndev);
 
-#if defined(CONFIG_ARM)
-#define FEC_ALIGNMENT	0x3f
-#else
-#define FEC_ALIGNMENT	0x3
-#endif
-
 #define DRIVER_NAME	"fec"
 #define FEC_ENET_GET_QUQUE(_x) ((_x == 0) ? 1 : ((_x == 1) ? 2 : 0))
 
@@ -930,6 +924,25 @@ fec_enet_tx(struct net_device *ndev)
 	return;
 }
 
+static int
+fec_new_rxbdp(struct net_device *ndev, struct bufdesc *bdp, struct sk_buff *skb)
+{
+	struct  fec_enet_private *fep = netdev_priv(ndev);
+	int off;
+
+	off = ((unsigned long)skb->data) & FEC_ALIGNMENT;
+	if (off)
+		skb_reserve(skb, FEC_ALIGNMENT + 1 - off);
+
+	bdp->cbd_bufaddr = dma_map_single(&fep->pdev->dev, skb->data,
+		FEC_ENET_RX_FRSIZE - FEC_ALIGNMENT, DMA_FROM_DEVICE);
+	if (dma_mapping_error(&fep->pdev->dev, bdp->cbd_bufaddr)) {
+		netdev_err(ndev, "Rx DMA memory map failed\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
 
 /* During a receive, the cur_rx points to the current incoming buffer.
  * When we update through the ring, if the next incoming buffer has
@@ -945,7 +958,8 @@ fec_enet_rx(struct net_device *ndev, int budget)
 	struct fec_enet_priv_rx_q *rxq;
 	struct bufdesc *bdp;
 	unsigned short status;
-	struct	sk_buff	*skb;
+	struct	sk_buff	*skb_new = NULL;
+	struct  sk_buff *skb_cur;
 	ushort	pkt_len;
 	__u8 *data;
 	int	pkt_received = 0;
@@ -953,6 +967,7 @@ fec_enet_rx(struct net_device *ndev, int budget)
 	bool	vlan_packet_rcvd = false;
 	u16	vlan_tag = 0;
 	u16	queue_id;
+	int     index = 0;
 
 #ifdef CONFIG_M532x
 	flush_cache_all();
@@ -974,6 +989,12 @@ fec_enet_rx(struct net_device *ndev, int budget)
 				break;
 			pkt_received++;
 
+			if (fep->bufdesc_ex)
+				index = (struct bufdesc_ex *)bdp -
+						(struct bufdesc_ex *)rxq->rx_bd_base;
+			else
+				index = bdp - rxq->rx_bd_base;
+
 			/* Since we have allocated space to hold a complete frame,
 			 * the last indicator should be set.
 			 */
@@ -1014,6 +1035,7 @@ fec_enet_rx(struct net_device *ndev, int budget)
 			pkt_len = bdp->cbd_datlen;
 			ndev->stats.rx_bytes += pkt_len;
 			data = (__u8 *)__va(bdp->cbd_bufaddr);
+			skb_cur = rxq->rx_skbuff[index];
 
 			dma_unmap_single(&fep->pdev->dev, bdp->cbd_bufaddr,
 					FEC_ENET_RX_FRSIZE - FEC_ALIGNMENT,
@@ -1045,31 +1067,26 @@ fec_enet_rx(struct net_device *ndev, int budget)
 			 * include that when passing upstream as it messes up
 			 * bridging applications.
 			 */
-			skb = __netdev_alloc_skb_ip_align(ndev, pkt_len - 4,
+			skb_new = __netdev_alloc_skb_ip_align(ndev, FEC_ENET_RX_FRSIZE,
 				GFP_ATOMIC | __GFP_NOWARN);
 
-			if (unlikely(!skb)) {
+			if (unlikely(!skb_new)) {
 				ndev->stats.rx_dropped++;
 			} else {
-				int payload_offset = (2 * ETH_ALEN);
-				skb_put(skb, pkt_len - 4);	/* Make room */
+				skb_put(skb_cur, pkt_len - 4);	/* Make room */
 
 				/* Extract the frame data without the VLAN header. */
 				if (ndev->features & NETIF_F_HW_VLAN_CTAG_RX &&
 					vlan_packet_rcvd) {
-					skb_copy_to_linear_data(skb, data, (2 * ETH_ALEN));
-					payload_offset = (2 * ETH_ALEN) + VLAN_HLEN;
-					skb_copy_to_linear_data_offset(skb, (2 * ETH_ALEN),
-								data + payload_offset,
-								pkt_len - 4 - (2 * ETH_ALEN));
-				} else {
-					skb_copy_to_linear_data(skb, data, pkt_len - 4);
+					skb_copy_to_linear_data_offset(skb_cur, VLAN_HLEN,
+								data, (2 * ETH_ALEN));
+					skb_pull(skb_cur, VLAN_HLEN);
 				}
 
 				/* Get receive timestamp from the skb */
 				if (fep->hwts_rx_en && fep->bufdesc_ex) {
 					struct skb_shared_hwtstamps *shhwtstamps =
-							    skb_hwtstamps(skb);
+							    skb_hwtstamps(skb_cur);
 					unsigned long flags;
 
 					memset(shhwtstamps, 0, sizeof(*shhwtstamps));
@@ -1080,36 +1097,34 @@ fec_enet_rx(struct net_device *ndev, int budget)
 					spin_unlock_irqrestore(&fep->tmreg_lock, flags);
 				} else if (unlikely(fep->hwts_rx_en_ioctl) &&
 						fep->bufdesc_ex)
-					fec_ptp_store_rxstamp(fep, skb, bdp);
+					fec_ptp_store_rxstamp(fep, skb_cur, bdp);
 
-				skb->protocol = eth_type_trans(skb, ndev);
+				skb_cur->protocol = eth_type_trans(skb_cur, ndev);
 				if (fep->bufdesc_ex &&
 				    (fep->csum_flags & FLAG_RX_CSUM_ENABLED)) {
 					if (!(ebdp->cbd_esc & FLAG_RX_CSUM_ERROR)) {
 						/* don't check it */
-						skb->ip_summed = CHECKSUM_UNNECESSARY;
+						skb_cur->ip_summed = CHECKSUM_UNNECESSARY;
 					} else {
-						skb_checksum_none_assert(skb);
+						skb_checksum_none_assert(skb_cur);
 					}
 				}
 
 				/* Handle received VLAN packets */
 				if (vlan_packet_rcvd)
-					__vlan_hwaccel_put_tag(skb,
+					__vlan_hwaccel_put_tag(skb_cur,
 						       htons(ETH_P_8021Q),
 						       vlan_tag);
 
-				if (!skb_defer_rx_timestamp(skb))
-					napi_gro_receive(&fep->napi, skb);
+				if (!skb_defer_rx_timestamp(skb_cur))
+					napi_gro_receive(&fep->napi, skb_cur);
 			}
 
-			bdp->cbd_bufaddr = dma_map_single(&fep->pdev->dev, data,
-						FEC_ENET_RX_FRSIZE - FEC_ALIGNMENT,
-						DMA_FROM_DEVICE);
-			/* here dma mapping shouldn't be error, just avoid kernel dump */
-			if (dma_mapping_error(&fep->pdev->dev, bdp->cbd_bufaddr))
-				netdev_err(ndev, "Rx DMA memory map failed\n");
 rx_processing_done:
+			/* set the new skb */
+			rxq->rx_skbuff[index] = skb_new;
+			fec_new_rxbdp(ndev, bdp, skb_new);
+
 			/* Clear the status flags for this buffer */
 			status &= ~BD_ENET_RX_STATS;
 
@@ -1988,7 +2003,6 @@ static int fec_enet_alloc_buffers(struct net_device *ndev)
 	unsigned int i, j;
 	struct sk_buff *skb;
 	struct bufdesc	*bdp;
-	int off;
 
 	for (j = 0; j < fep->num_rx_queues; j++) {
 		rx_queue = fep->rx_queue[j];
@@ -2002,15 +2016,8 @@ static int fec_enet_alloc_buffers(struct net_device *ndev)
 			}
 			rx_queue->rx_skbuff[i] = skb;
 
-			off = ((unsigned long)skb->data) & FEC_ALIGNMENT;
-			if (off)
-				skb_reserve(skb, FEC_ALIGNMENT + 1 - off);
-
-			bdp->cbd_bufaddr = dma_map_single(&fep->pdev->dev, skb->data,
-				FEC_ENET_RX_FRSIZE - FEC_ALIGNMENT, DMA_FROM_DEVICE);
-			if (dma_mapping_error(&fep->pdev->dev, bdp->cbd_bufaddr)) {
+			if (fec_new_rxbdp(ndev, bdp, skb)) {
 				fec_enet_free_buffers(ndev);
-				netdev_err(ndev, "Rx DMA memory map failed\n");
 				return -ENOMEM;
 			}
 			bdp->cbd_sc = BD_ENET_RX_EMPTY;
-- 
1.7.5.4

