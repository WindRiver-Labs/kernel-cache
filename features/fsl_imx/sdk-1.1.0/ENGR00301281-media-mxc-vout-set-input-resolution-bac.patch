From d2765513ff6bb5e7bb2dc6ca0874e589c90270a0 Mon Sep 17 00:00:00 2001
From: Liu Ying <Ying.Liu@freescale.com>
Date: Mon, 21 Apr 2014 14:12:49 +0800
Subject: [PATCH 0812/1074] ENGR00301281 media: mxc vout: set input resolution
 back after PP check/process

In VDOA PP mode, the input resolution would be changed to be VDOA's output
for PP to use as its input resolution to go on to do resizing or color space
conversion.  The input resolution will be different from the original one
when VDOA input cropping is enabled.  And, this finally causes a wrong input
resolution being used if the users do rotation by calling the S_CTRL ioctrl
in runtime.  In order to fix this issue, this patch sets the original input
resolution back after PP task check and process.  The issue can be reproduced
by the following command line(enable VDOA mode in the gst plugin configuration
file first):

gplay AVC_MP30_854x356_23.976_679_AACLC_44.1_96_2_TRON_LEGACY.flv
(Enter 't 90' to change to rotate 90 degrees in runtime.)

In this case, VDOA input cropping(854x356 -> 848x352) is enabled because VDOA
input resolution should align to macro block size.

Signed-off-by: Liu Ying <Ying.Liu@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/media/platform/mxc/output/mxc_vout.c |   18 +++++++++++++++---
 1 files changed, 15 insertions(+), 3 deletions(-)

diff --git a/drivers/media/platform/mxc/output/mxc_vout.c b/drivers/media/platform/mxc/output/mxc_vout.c
index bd7d1f0..6ebecf3 100644
--- a/drivers/media/platform/mxc/output/mxc_vout.c
+++ b/drivers/media/platform/mxc/output/mxc_vout.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2014 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -577,7 +577,7 @@ static void disp_work_func(struct work_struct *work)
 	unsigned long flags = 0;
 	struct ipu_pos ipos;
 	int ret = 0;
-	u32 in_fmt = 0;
+	u32 in_fmt = 0, in_width = 0, in_height = 0;
 	u32 vdi_cnt = 0;
 	u32 vdi_frame;
 	u32 index = 0;
@@ -689,7 +689,11 @@ vdi_frame_rate_double:
 			}
 			vout->task.input.paddr = vout->vdoa_task.output.paddr;
 			in_fmt = vout->task.input.format;
+			in_width = vout->task.input.width;
+			in_height = vout->task.input.height;
 			vout->task.input.format = vout->vdoa_task.output.format;
+			vout->task.input.width = vout->vdoa_task.output.width;
+			vout->task.input.height = vout->vdoa_task.output.height;
 			if (vout->task.input.deinterlace.enable) {
 				tiled_interlaced = 1;
 				vout->task.input.deinterlace.enable = 0;
@@ -698,8 +702,11 @@ vdi_frame_rate_double:
 					"tiled queue task\n");
 		}
 		ret = ipu_queue_task(&vout->task);
-		if ((!vout->tiled_bypass_pp) && tiled_fmt)
+		if ((!vout->tiled_bypass_pp) && tiled_fmt) {
 			vout->task.input.format = in_fmt;
+			vout->task.input.width = in_width;
+			vout->task.input.height = in_height;
+		}
 		if (tiled_interlaced)
 			vout->task.input.deinterlace.enable = 1;
 		if (ret < 0) {
@@ -1101,6 +1108,7 @@ static inline int vdoaipu_try_task(struct mxc_vout_output *vout)
 {
 	int ret;
 	int is_1080p_stream;
+	int in_width, in_height;
 	size_t size;
 	struct ipu_task *ipu_task = &vout->task;
 	struct ipu_crop *icrop = &ipu_task->input.crop;
@@ -1146,6 +1154,8 @@ static inline int vdoaipu_try_task(struct mxc_vout_output *vout)
 	if (is_1080p_stream)
 		ipu_task->input.crop.h = VALID_HEIGHT_1080P;
 	in_fmt = ipu_task->input.format;
+	in_width = ipu_task->input.width;
+	in_height = ipu_task->input.height;
 	ipu_task->input.format = vdoa_task->output.format;
 	ipu_task->input.height = vdoa_task->output.height;
 	ipu_task->input.width = vdoa_task->output.width;
@@ -1155,6 +1165,8 @@ static inline int vdoaipu_try_task(struct mxc_vout_output *vout)
 	if (deinterlace)
 		ipu_task->input.deinterlace.enable = 1;
 	ipu_task->input.format = in_fmt;
+	ipu_task->input.width = in_width;
+	ipu_task->input.height = in_height;
 
 	return ret;
 }
-- 
1.7.5.4

