From 25d3f30810acd17b24f30a9bff87af7a679bcca6 Mon Sep 17 00:00:00 2001
From: Fancy Fang <B47543@freescale.com>
Date: Wed, 11 Dec 2013 18:21:10 +0800
Subject: [PATCH 0659/1074] ENGR00291729 PXP: remove a mutex lock from pxp
 channel

This mutex lock is no longer necessary in PXP dma driver. After
the commit "ENGR00291400 PXP: Organize PXP task queue to be FIFO",
protection fields can be protected by the spin lock in PXP channel
now.

Signed-off-by: Fancy Fang <B47543@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/dma/pxp/pxp_dma_v2.c |   18 ++++++++----------
 include/linux/pxp_dma.h      |    5 +++--
 2 files changed, 11 insertions(+), 12 deletions(-)

diff --git a/drivers/dma/pxp/pxp_dma_v2.c b/drivers/dma/pxp/pxp_dma_v2.c
index 30d6a14..4cbcde5 100644
--- a/drivers/dma/pxp/pxp_dma_v2.c
+++ b/drivers/dma/pxp/pxp_dma_v2.c
@@ -1149,7 +1149,8 @@ static dma_cookie_t pxp_tx_submit(struct dma_async_tx_descriptor *tx)
 
 	dev_dbg(&pxp_chan->dma_chan.dev->device, "received TX\n");
 
-	mutex_lock(&pxp_chan->chan_mutex);
+	/* pxp_chan->lock can be taken under ichan->lock, but not v.v. */
+	spin_lock_irqsave(&pxp_chan->lock, flags);
 
 	cookie = pxp_chan->dma_chan.cookie;
 
@@ -1160,9 +1161,6 @@ static dma_cookie_t pxp_tx_submit(struct dma_async_tx_descriptor *tx)
 	pxp_chan->dma_chan.cookie = cookie;
 	tx->cookie = cookie;
 
-	/* pxp_chan->lock can be taken under ichan->lock, but not v.v. */
-	spin_lock_irqsave(&pxp_chan->lock, flags);
-
 	/* Here we add the tx descriptor to our PxP task queue. */
 	list_add_tail(&desc->list, &pxp_chan->queue);
 
@@ -1170,7 +1168,6 @@ static dma_cookie_t pxp_tx_submit(struct dma_async_tx_descriptor *tx)
 
 	dev_dbg(&pxp_chan->dma_chan.dev->device, "done TX\n");
 
-	mutex_unlock(&pxp_chan->chan_mutex);
 	return cookie;
 }
 
@@ -1379,15 +1376,16 @@ static void __pxp_terminate_all(struct dma_chan *chan)
 static int pxp_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 			unsigned long arg)
 {
+	unsigned long flags;
 	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
 
 	/* Only supports DMA_TERMINATE_ALL */
 	if (cmd != DMA_TERMINATE_ALL)
 		return -ENXIO;
 
-	mutex_lock(&pxp_chan->chan_mutex);
+	spin_lock_irqsave(&pxp_chan->lock, flags);
 	__pxp_terminate_all(chan);
-	mutex_unlock(&pxp_chan->chan_mutex);
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
 
 	return 0;
 }
@@ -1423,15 +1421,16 @@ err_chan:
 
 static void pxp_free_chan_resources(struct dma_chan *chan)
 {
+	unsigned long flags;
 	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
 
-	mutex_lock(&pxp_chan->chan_mutex);
+	spin_lock_irqsave(&pxp_chan->lock, flags);
 
 	__pxp_terminate_all(chan);
 
 	pxp_chan->status = PXP_CHANNEL_FREE;
 
-	mutex_unlock(&pxp_chan->chan_mutex);
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
 }
 
 static enum dma_status pxp_tx_status(struct dma_chan *chan,
@@ -1589,7 +1588,6 @@ static int pxp_dma_init(struct pxps *pxp)
 		struct dma_chan *dma_chan = &pxp_chan->dma_chan;
 
 		spin_lock_init(&pxp_chan->lock);
-		mutex_init(&pxp_chan->chan_mutex);
 
 		/* Only one EOF IRQ for PxP, shared by all channels */
 		pxp_chan->eof_irq = pxp->irq;
diff --git a/include/linux/pxp_dma.h b/include/linux/pxp_dma.h
index 61b3e7d..613d89f 100644
--- a/include/linux/pxp_dma.h
+++ b/include/linux/pxp_dma.h
@@ -47,8 +47,9 @@ struct pxp_channel {
 	struct pxp_tx_desc *desc;	/* allocated tx-descriptors */
 	struct list_head queue;	/* queued tx-descriptors */
 	struct list_head list;	/* track queued channel number */
-	spinlock_t lock;	/* protects sg[0,1], queue */
-	struct mutex chan_mutex;	/* protects status, cookie, free_list */
+	spinlock_t lock;	/* protects sg[0,1], queue,
+				 * status, cookie, free_list
+				 */
 	int active_buffer;
 	unsigned int eof_irq;
 	char eof_name[16];	/* EOF IRQ name for request_irq()  */
-- 
1.7.5.4

