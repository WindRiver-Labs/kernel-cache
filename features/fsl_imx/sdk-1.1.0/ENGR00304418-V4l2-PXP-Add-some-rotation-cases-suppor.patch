From 393f2a893fd1f2c4ea6d57df0c2806aa49c3d0b8 Mon Sep 17 00:00:00 2001
From: Fancy Fang <chen.fang@freescale.com>
Date: Mon, 31 Mar 2014 17:56:53 +0800
Subject: [PATCH 0788/1074] ENGR00304418 [V4l2][PXP] Add some rotation cases
 support for V4L app.

Some V4L2 apps require that playing rotated fullscreen video on
the screen. In recent PXP driver, this is not supported yet. So
this patch adds it on through combining rotation and resize together.

Signed-off-by: Fancy Fang <chen.fang@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/dma/pxp/pxp_dma_v2.c                     |   55 +++++++++++++++++++---
 drivers/media/platform/mxc/output/mxc_pxp_v4l2.c |   24 +++++----
 2 files changed, 61 insertions(+), 18 deletions(-)

diff --git a/drivers/dma/pxp/pxp_dma_v2.c b/drivers/dma/pxp/pxp_dma_v2.c
index 7b80787..2fb81d0 100644
--- a/drivers/dma/pxp/pxp_dma_v2.c
+++ b/drivers/dma/pxp/pxp_dma_v2.c
@@ -400,12 +400,23 @@ static void pxp_set_outbuf(struct pxps *pxp)
 {
 	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
 	struct pxp_layer_param *out_params = &pxp_conf->out_param;
+	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
 
 	__raw_writel(out_params->paddr, pxp->base + HW_PXP_OUT_BUF);
 
-	__raw_writel(BF_PXP_OUT_LRC_X(out_params->width - 1) |
-		     BF_PXP_OUT_LRC_Y(out_params->height - 1),
-		     pxp->base + HW_PXP_OUT_LRC);
+	if (proc_data->rotate == 90 || proc_data->rotate == 270) {
+		if (proc_data->rot_pos == 0)
+			__raw_writel(BF_PXP_OUT_LRC_X(proc_data->drect.width - 1) |
+					BF_PXP_OUT_LRC_Y(proc_data->drect.height - 1),
+					pxp->base + HW_PXP_OUT_LRC);
+		else
+			__raw_writel(BF_PXP_OUT_LRC_X(proc_data->drect.width - 1) |
+					BF_PXP_OUT_LRC_Y(proc_data->drect.height - 1),
+					pxp->base + HW_PXP_OUT_LRC);
+	} else
+		__raw_writel(BF_PXP_OUT_LRC_X(proc_data->drect.width - 1) |
+				BF_PXP_OUT_LRC_Y(proc_data->drect.height - 1),
+				pxp->base + HW_PXP_OUT_LRC);
 
 	if (out_params->pixel_fmt == PXP_PIX_FMT_RGB24) {
 		__raw_writel(out_params->stride * 3,
@@ -572,8 +583,27 @@ static void pxp_set_s0param(struct pxps *pxp)
 {
 	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
 	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
+	struct pxp_layer_param *out_params = &pxp_conf->out_param;
 	u32 s0param;
 
+	if (proc_data->drect.left != 0 || proc_data->drect.top != 0) {
+		out_params->paddr += (proc_data->drect.top * out_params->stride +
+				proc_data->drect.left) * 2;
+		proc_data->drect.left = proc_data->drect.top = 0;
+	}
+
+	/* Since user apps always pass the rotated drect
+	 * to this driver, we need to first swap the width
+	 * and height which is used to calculate the scale
+	 * factors later.
+	 */
+	if (proc_data->rotate == 90 || proc_data->rotate == 270) {
+		int temp;
+		temp = proc_data->drect.width;
+		proc_data->drect.width = proc_data->drect.height;
+		proc_data->drect.height = temp;
+	}
+
 	/* contains the coordinate for the PS in the OUTPUT buffer. */
 	if ((pxp_conf->s0_param).width == 0 &&
 		(pxp_conf->s0_param).height == 0) {
@@ -583,10 +613,21 @@ static void pxp_set_s0param(struct pxps *pxp)
 		s0param = BF_PXP_OUT_PS_ULC_X(proc_data->drect.left);
 		s0param |= BF_PXP_OUT_PS_ULC_Y(proc_data->drect.top);
 		__raw_writel(s0param, pxp->base + HW_PXP_OUT_PS_ULC);
-		s0param = BF_PXP_OUT_PS_LRC_X(proc_data->drect.left +
-				proc_data->drect.width - 1);
-		s0param |= BF_PXP_OUT_PS_LRC_Y(proc_data->drect.top +
-				proc_data->drect.height - 1);
+		/* In PXP, the two different rotation
+		 * position requires different settings
+		 * on OUT_PS_LRC register
+		 */
+		if (proc_data->rot_pos == 1) {
+			s0param = BF_PXP_OUT_PS_LRC_X(proc_data->drect.left +
+					proc_data->drect.height - 1);
+			s0param |= BF_PXP_OUT_PS_LRC_Y(proc_data->drect.top +
+					proc_data->drect.width - 1);
+		} else {
+			s0param = BF_PXP_OUT_PS_LRC_X(proc_data->drect.left +
+					proc_data->drect.width - 1);
+			s0param |= BF_PXP_OUT_PS_LRC_Y(proc_data->drect.top +
+					proc_data->drect.height - 1);
+		}
 		__raw_writel(s0param, pxp->base + HW_PXP_OUT_PS_LRC);
 	}
 }
diff --git a/drivers/media/platform/mxc/output/mxc_pxp_v4l2.c b/drivers/media/platform/mxc/output/mxc_pxp_v4l2.c
index 56a09d3..64c06fc 100644
--- a/drivers/media/platform/mxc/output/mxc_pxp_v4l2.c
+++ b/drivers/media/platform/mxc/output/mxc_pxp_v4l2.c
@@ -450,6 +450,7 @@ static int pxp_s_output(struct file *file, void *fh,
 		if (ret < 0)
 			return ret;
 	}
+	memset(pxp->outbuf.vaddr, 0x0, pxp->outbuf.size);
 
 	pxp->pxp_conf.out_param.width = fmt->width;
 	pxp->pxp_conf.out_param.height = fmt->height;
@@ -811,17 +812,14 @@ static int pxp_buf_prepare(struct videobuf_queue *q,
 					&pxp_conf->s0_param,
 					sizeof(struct pxp_layer_param));
 			} else if (i == 1) { /* Output */
-				if (proc_data->rotate % 180) {
-					pxp_conf->out_param.width =
-						pxp->fb.fmt.height;
-					pxp_conf->out_param.height =
-						pxp->fb.fmt.width;
-				} else {
-					pxp_conf->out_param.width =
-						pxp->fb.fmt.width;
-					pxp_conf->out_param.height =
-						pxp->fb.fmt.height;
-				}
+				/* we should always pass the output
+				 * width and height which is the value
+				 * after been rotated.
+				 */
+				pxp_conf->out_param.width =
+					pxp->fb.fmt.width;
+				pxp_conf->out_param.height =
+					pxp->fb.fmt.height;
 
 				pxp_conf->out_param.paddr = pxp->outbuf.paddr;
 				memcpy(&desc->layer_param.out_param,
@@ -1036,6 +1034,8 @@ static int pxp_s_crop(struct file *file, void *fh,
 	pxp->pxp_conf.proc_data.drect.width = w;
 	pxp->pxp_conf.proc_data.drect.height = h;
 
+	memset(pxp->outbuf.vaddr, 0x0, pxp->outbuf.size);
+
 	return 0;
 }
 
@@ -1081,6 +1081,8 @@ static int pxp_s_ctrl(struct file *file, void *priv,
 			return pxp_set_cstate(pxp, vc);
 		}
 
+	memset(pxp->outbuf.vaddr, 0x0, pxp->outbuf.size);
+
 	return -EINVAL;
 }
 
-- 
1.7.5.4

