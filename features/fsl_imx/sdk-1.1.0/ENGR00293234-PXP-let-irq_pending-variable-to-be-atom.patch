From 5caf24354d0597f8b37faf50616dfba0c624f40b Mon Sep 17 00:00:00 2001
From: Fancy Fang <B47543@freescale.com>
Date: Tue, 24 Dec 2013 17:42:22 +0800
Subject: [PATCH 0685/1074] ENGR00293234 PXP: let irq_pending variable to be
 atomic

Change irq_pending field in struct pxp_irq_info to a atomic
type. So the spin lock in pxp_irq_info is unnecessary.

Signed-off-by: Fancy Fang <B47543@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/dma/pxp/pxp_device.c |   17 ++++-------------
 include/linux/pxp_device.h   |    3 +--
 2 files changed, 5 insertions(+), 15 deletions(-)

diff --git a/drivers/dma/pxp/pxp_device.c b/drivers/dma/pxp/pxp_device.c
index 43c3fa8..2b101d6 100644
--- a/drivers/dma/pxp/pxp_device.c
+++ b/drivers/dma/pxp/pxp_device.c
@@ -282,14 +282,11 @@ static void pxp_dma_done(void *arg)
 	struct dma_chan *chan = tx_desc->txd.chan;
 	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
 	int chan_id = pxp_chan->dma_chan.chan_id;
-	unsigned long flags;
 
 	pr_debug("DMA Done ISR, chan_id %d\n", chan_id);
 
-	spin_lock_irqsave(&(irq_info[chan_id].lock), flags);
-	irq_info[chan_id].irq_pending--;
+	atomic_dec(&irq_info[chan_id].irq_pending);
 	irq_info[chan_id].hist_status = tx_desc->hist_status;
-	spin_unlock_irqrestore(&(irq_info[chan_id].lock), flags);
 
 	wake_up_interruptible(&(irq_info[chan_id].waitq));
 }
@@ -303,7 +300,6 @@ static int pxp_ioc_config_chan(struct pxp_file *priv, unsigned long arg)
 	dma_cookie_t cookie;
 	int handle, chan_id;
 	int i, length, ret;
-	unsigned long flags;
 	struct dma_chan *chan;
 	struct pxp_chan_obj *obj;
 
@@ -366,9 +362,7 @@ static int pxp_ioc_config_chan(struct pxp_file *priv, unsigned long arg)
 		return -EIO;
 	}
 
-	spin_lock_irqsave(&(irq_info[chan_id].lock), flags);
-	irq_info[chan_id].irq_pending++;
-	spin_unlock_irqrestore(&(irq_info[chan_id].lock), flags);
+	atomic_inc(&irq_info[chan_id].irq_pending);
 
 	return 0;
 }
@@ -638,7 +632,7 @@ static long pxp_device_ioctl(struct file *filp,
 
 			ret = wait_event_interruptible
 			    (irq_info[chan_id].waitq,
-			     (irq_info[chan_id].irq_pending == 0));
+			     (atomic_read(&irq_info[chan_id].irq_pending) == 0));
 			if (ret < 0) {
 				printk(KERN_WARNING
 				       "WAIT4CMPLT: signal received.\n");
@@ -675,15 +669,12 @@ static struct miscdevice pxp_device_miscdev = {
 
 int register_pxp_device(void)
 {
-	int i, ret;
+	int ret;
 
 	ret = misc_register(&pxp_device_miscdev);
 	if (ret)
 		return ret;
 
-	for (i = 0; i < NR_PXP_VIRT_CHANNEL; i++)
-		spin_lock_init(&(irq_info[i].lock));
-
 	ret = pxp_ht_create(&bufhash, BUFFER_HASH_ORDER);
 	if (ret)
 		return ret;
diff --git a/include/linux/pxp_device.h b/include/linux/pxp_device.h
index 5881deb..df185c4 100644
--- a/include/linux/pxp_device.h
+++ b/include/linux/pxp_device.h
@@ -25,9 +25,8 @@
 
 struct pxp_irq_info {
 	wait_queue_head_t waitq;
-	int irq_pending;
+	atomic_t irq_pending;
 	int hist_status;
-	spinlock_t lock;
 };
 
 struct pxp_buffer_hash {
-- 
1.7.5.4

