From 42ce32eca030e87fea233679745039edda188adb Mon Sep 17 00:00:00 2001
From: Shawn Guo <shawn.guo@freescale.com>
Date: Thu, 5 Jun 2014 14:45:24 +0800
Subject: [PATCH 0423/1074] ENGR00318063-7: ARM: imx6q: mmdc_ch_axi clock
 should be non-gateable

Per the updated CCM chapter, there is no gate for clock mmdc_ch1_axi.
And there is a gate for mmdc_ch0_axi, but the gate also controls FABRIC
clock, which means the gate cannot be gated anyway.  That said,
implementing these two clocks as gate does not make too much sense.

Since the clocks are already referenced in quite some places, to
minimize the impact of dropping the gate, instead of removing the clocks
completely, we choose to point the clocks to their dividers.

Signed-off-by: Shawn Guo <shawn.guo@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 arch/arm/mach-imx/clk-imx6q.c |   10 ++++++++--
 1 files changed, 8 insertions(+), 2 deletions(-)

diff --git a/arch/arm/mach-imx/clk-imx6q.c b/arch/arm/mach-imx/clk-imx6q.c
index b9fd487..1324b27 100644
--- a/arch/arm/mach-imx/clk-imx6q.c
+++ b/arch/arm/mach-imx/clk-imx6q.c
@@ -518,8 +518,6 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 		clk[mlb] = imx_clk_gate2("mlb",            "gpu2d_core_podf",   base + 0x74, 18);
 	else
 		clk[mlb] = imx_clk_gate2("mlb",            "axi",               base + 0x74, 18);
-	clk[mmdc_ch0_axi] = imx_clk_gate2("mmdc_ch0_axi",  "mmdc_ch0_axi_podf", base + 0x74, 20);
-	clk[mmdc_ch1_axi] = imx_clk_gate2("mmdc_ch1_axi",  "mmdc_ch1_axi_podf", base + 0x74, 22);
 	clk[ocram]        = imx_clk_gate2("ocram",         "ahb",               base + 0x74, 28);
 	clk[openvg_axi]   = imx_clk_gate2("openvg_axi",    "axi",               base + 0x74, 30);
 	clk[pcie_axi]     = imx_clk_gate2("pcie_axi",      "pcie_axi_sel",      base + 0x78, 0);
@@ -556,6 +554,14 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 	clk[cko1]         = imx_clk_gate("cko1",           "cko1_podf",         base + 0x60, 7);
 	clk[cko2]         = imx_clk_gate("cko2",           "cko2_podf",         base + 0x60, 24);
 
+	/*
+	 * These two clocks (mmdc_ch0_axi and mmdc_ch1_axi) were incorrectly
+	 * implemented as gate at the beginning.  To fix them with the minimized
+	 * impact, let's point them to their dividers.
+	 */
+	clk[mmdc_ch0_axi] = clk[mmdc_ch0_axi_podf];
+	clk[mmdc_ch1_axi] = clk[mmdc_ch1_axi_podf];
+
 	for (i = 0; i < ARRAY_SIZE(clk); i++)
 		if (IS_ERR(clk[i]))
 			pr_err("i.MX6q clk %d: register failed with %ld\n",
-- 
1.7.5.4

