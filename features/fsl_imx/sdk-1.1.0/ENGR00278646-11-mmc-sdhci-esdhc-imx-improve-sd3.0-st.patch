From dadec8310e851b3e9e63ef8f9e1f0c8e041fa6ff Mon Sep 17 00:00:00 2001
From: Dong Aisheng <b29396@freescale.com>
Date: Fri, 6 Sep 2013 23:10:55 +0800
Subject: [PATCH 0177/1074] ENGR00278646-11 mmc: sdhci-esdhc-imx: improve
 sd3.0 stability

We observed on some sd3.0 cards(Toshiba SDHC U1) that it may require
to reset host controller before sending the next tuning command
or the tuning may fail and cause the card can not work on uhs mode.
The root cause why the card fails on tuning without reset is still unknow.
This could be treated as a workaround before finding root cause.

Signed-off-by: Dong Aisheng <b29396@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/mmc/host/sdhci-esdhc-imx.c |   43 ++++++++++++++++++++++++++++++++++++
 drivers/mmc/host/sdhci-esdhc.h     |    1 +
 2 files changed, 44 insertions(+), 0 deletions(-)

diff --git a/drivers/mmc/host/sdhci-esdhc-imx.c b/drivers/mmc/host/sdhci-esdhc-imx.c
index b841bb7..dd64978 100644
--- a/drivers/mmc/host/sdhci-esdhc-imx.c
+++ b/drivers/mmc/host/sdhci-esdhc-imx.c
@@ -690,10 +690,53 @@ static int esdhc_pltfm_bus_width(struct sdhci_host *host, int width)
 	return 0;
 }
 
+static void esdhc_reset(struct sdhci_host *host, u32 rst_bits)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct pltfm_imx_data *imx_data = pltfm_host->priv;
+	u32 timeout;
+	u32 reg;
+
+	reg = readl(host->ioaddr + ESDHC_SYSTEM_CONTROL);
+	reg |= rst_bits;
+	writel(reg, host->ioaddr + ESDHC_SYSTEM_CONTROL);
+
+	/* Wait for max 100ms */
+	timeout = 100;
+
+	/* hw clears the bit when it's done */
+	while (readl(host->ioaddr + ESDHC_SYSTEM_CONTROL) & rst_bits) {
+		if (timeout == 0) {
+			dev_err(mmc_dev(host->mmc),
+				"Reset never completes!\n");
+			return;
+		}
+		timeout--;
+		mdelay(1);
+	}
+
+	/*
+	* The RSTA, reset all, on usdhc will not clear following regs:
+	* > SDHCI_MIX_CTRL
+	* > SDHCI_TUNE_CTRL_STATUS
+	*
+	* Do it manually here.
+	*/
+	if ((rst_bits & ESDHC_SYS_CTRL_RSTA) && is_imx6q_usdhc(imx_data)) {
+		writel(0, host->ioaddr + ESDHC_MIX_CTRL);
+		writel(0, host->ioaddr + ESDHC_TUNE_CTRL_STATUS);
+		/* FIXME: delay for clear tuning status or some cards may not work */
+		mdelay(1);
+	}
+}
+
 static void esdhc_prepare_tuning(struct sdhci_host *host, u32 val)
 {
 	u32 reg;
 
+	/* reset controller before tuning or it may fail on some cards */
+	esdhc_reset(host, ESDHC_SYS_CTRL_RSTA);
+
 	/* FIXME: delay a bit for card to be ready for next tuning due to errors */
 	mdelay(1);
 
diff --git a/drivers/mmc/host/sdhci-esdhc.h b/drivers/mmc/host/sdhci-esdhc.h
index a7d9f95..03fb648 100644
--- a/drivers/mmc/host/sdhci-esdhc.h
+++ b/drivers/mmc/host/sdhci-esdhc.h
@@ -26,6 +26,7 @@
 				SDHCI_QUIRK_RESTORE_IRQS_AFTER_RESET)
 
 #define ESDHC_SYSTEM_CONTROL	0x2c
+#define ESDHC_SYS_CTRL_RSTA	(1 << 24)
 #define ESDHC_CLOCK_MASK	0x0000fff0
 #define ESDHC_PREDIV_SHIFT	8
 #define ESDHC_DIVIDER_SHIFT	4
-- 
1.7.5.4

