From 82ccd5b2d91989060296580f038565101c8f1a4f Mon Sep 17 00:00:00 2001
From: Shawn Guo <shawn.guo@freescale.com>
Date: Fri, 27 Jun 2014 14:31:26 +0800
Subject: [PATCH 0434/1074] ENGR00318063-12: ARM: imx6: enable clocks only
 after all parent and rate are initialized

Since flag CLK_SET_PARENT_GATE is introduced, clk_set_parent() and
clk_set_rate() could possibly fail when clock is prepared/enabled
beforehand.  Let's move the prepare/enable of clocks after parent and
rate setup to avoid such possible failures.

Signed-off-by: Shawn Guo <shawn.guo@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 arch/arm/mach-imx/clk-imx6q.c  |   20 ++++++++++++--------
 arch/arm/mach-imx/clk-imx6sl.c |    5 +++++
 arch/arm/mach-imx/clk-imx6sx.c |   18 +++++++++++-------
 3 files changed, 28 insertions(+), 15 deletions(-)

diff --git a/arch/arm/mach-imx/clk-imx6q.c b/arch/arm/mach-imx/clk-imx6q.c
index 2996b0b..f3b5d10 100644
--- a/arch/arm/mach-imx/clk-imx6q.c
+++ b/arch/arm/mach-imx/clk-imx6q.c
@@ -667,14 +667,6 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 	 */
 	clk_set_parent(clk[enfc_sel], clk[pll2_pfd2_396m]);
 
-	for (i = 0; i < ARRAY_SIZE(clks_init_on); i++)
-		clk_prepare_enable(clk[clks_init_on[i]]);
-
-	if (IS_ENABLED(CONFIG_USB_MXS_PHY)) {
-		clk_prepare_enable(clk[usbphy1_gate]);
-		clk_prepare_enable(clk[usbphy2_gate]);
-	}
-
 	/* ipu clock initialization */
 	init_ldb_clks();
 	clk_set_parent(clk[ipu1_di0_pre_sel], clk[pll5_video_div]);
@@ -739,6 +731,18 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 	pr_info("VPU 352M is enabled!\n");
 #endif
 
+	/*
+	 * Enable clocks only after both parent and rate are all initialized
+	 * as needed
+	 */
+	for (i = 0; i < ARRAY_SIZE(clks_init_on); i++)
+		clk_prepare_enable(clk[clks_init_on[i]]);
+
+	if (IS_ENABLED(CONFIG_USB_MXS_PHY)) {
+		clk_prepare_enable(clk[usbphy1_gate]);
+		clk_prepare_enable(clk[usbphy2_gate]);
+	}
+
 	/* Set initial power mode */
 	imx6q_set_lpm(WAIT_CLOCKED);
 
diff --git a/arch/arm/mach-imx/clk-imx6sl.c b/arch/arm/mach-imx/clk-imx6sl.c
index 9535acf..2450162 100644
--- a/arch/arm/mach-imx/clk-imx6sl.c
+++ b/arch/arm/mach-imx/clk-imx6sl.c
@@ -358,6 +358,11 @@ static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 	/* Set initial power mode */
 	imx6q_set_lpm(WAIT_CLOCKED);
 
+	/*
+	 * Enable clocks only after both parent and rate are all initialized
+	 * as needed
+	 */
+
 	np = of_find_compatible_node(NULL, NULL, "fsl,imx6sl-gpt");
 	base = of_iomap(np, 0);
 	WARN_ON(!base);
diff --git a/arch/arm/mach-imx/clk-imx6sx.c b/arch/arm/mach-imx/clk-imx6sx.c
index be65d78..c4bcc27 100644
--- a/arch/arm/mach-imx/clk-imx6sx.c
+++ b/arch/arm/mach-imx/clk-imx6sx.c
@@ -442,13 +442,6 @@ static void __init imx6sx_clocks_init(struct device_node *ccm_node)
 	clk_register_clkdev(clks[IMX6SX_CLK_CKO1], "cko1", NULL);
 	clk_register_clkdev(clks[IMX6SX_CLK_ARM], NULL, "cpu0");
 
-	for (i = 0; i < ARRAY_SIZE(clks_init_on); i++)
-		clk_prepare_enable(clks[clks_init_on[i]]);
-
-	if (IS_ENABLED(CONFIG_USB_MXS_PHY)) {
-		clk_prepare_enable(clks[IMX6SX_CLK_USBPHY1_GATE]);
-		clk_prepare_enable(clks[IMX6SX_CLK_USBPHY2_GATE]);
-	}
 
 	/* Set the default 132MHz for EIM module */
 	clk_set_parent(clks[IMX6SX_CLK_EIM_SLOW_SEL], clks[IMX6SX_CLK_PLL2_PFD2]);
@@ -481,6 +474,17 @@ static void __init imx6sx_clocks_init(struct device_node *ccm_node)
 	clk_set_rate(clks[IMX6SX_CLK_SSI2_PODF], 24576000);
 	clk_set_rate(clks[IMX6SX_CLK_SSI3_PODF], 24576000);
 
+	/*
+	* Enable clocks only after both parent and rate are all initialized
+	* as needed
+	*/
+	for (i = 0; i < ARRAY_SIZE(clks_init_on); i++)
+		clk_prepare_enable(clks[clks_init_on[i]]);
+
+	if (IS_ENABLED(CONFIG_USB_MXS_PHY)) {
+		clk_prepare_enable(clks[IMX6SX_CLK_USBPHY1_GATE]);
+		clk_prepare_enable(clks[IMX6SX_CLK_USBPHY2_GATE]);
+	}
 
 	/* Set initial power mode */
 	imx6q_set_lpm(WAIT_CLOCKED);
-- 
1.7.5.4

