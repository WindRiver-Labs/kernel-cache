From 868978ffd8e545140ef6c96f455873feb8b03efe Mon Sep 17 00:00:00 2001
From: Li Jun <b47624@freescale.com>
Date: Fri, 27 Jun 2014 09:52:29 +0800
Subject: [PATCH 0884/1074] ENGR00320439-1 usb: chipidea: imx: usb resume from
 power lost during system sleep

i.MX6SX mega off can shutdown domain power supply if none of peripheral
in this domain is registered as wakeup source, this patch adds usb controller
imx specific re-init after resume from such power lost during system sleep.

Acked-by: Peter Chen <peter.chen@freescale.com>
Signed-off-by: Li Jun <b47624@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/usb/chipidea/ci_hdrc_imx.c |   10 ++++++++++
 drivers/usb/chipidea/ci_hdrc_imx.h |    1 +
 drivers/usb/chipidea/usbmisc_imx.c |   31 +++++++++++++++++++++++++++++++
 3 files changed, 42 insertions(+), 0 deletions(-)

diff --git a/drivers/usb/chipidea/ci_hdrc_imx.c b/drivers/usb/chipidea/ci_hdrc_imx.c
index 8e5628f..9b57240 100644
--- a/drivers/usb/chipidea/ci_hdrc_imx.c
+++ b/drivers/usb/chipidea/ci_hdrc_imx.c
@@ -503,6 +503,16 @@ static int imx_controller_resume(struct device *dev)
 	data->in_lpm = false;
 
 	if (data->usbmisc_data) {
+		ret = imx_usbmisc_power_lost_check(data->usbmisc_data);
+		/* re-init if resume from power lost */
+		if (ret > 0) {
+			ret = imx_usbmisc_init(data->usbmisc_data);
+			if (ret) {
+				dev_err(dev, "usbmisc init failed, ret=%d\n",
+						ret);
+				goto clk_disable;
+			}
+		}
 		ret = imx_usbmisc_set_wakeup(data->usbmisc_data, false);
 		if (ret) {
 			dev_err(dev,
diff --git a/drivers/usb/chipidea/ci_hdrc_imx.h b/drivers/usb/chipidea/ci_hdrc_imx.h
index 3376c88..a195a89 100644
--- a/drivers/usb/chipidea/ci_hdrc_imx.h
+++ b/drivers/usb/chipidea/ci_hdrc_imx.h
@@ -34,5 +34,6 @@ int imx_usbmisc_set_wakeup(struct imx_usbmisc_data *, bool);
 /* Call it before setting portsc.suspendM */
 int imx_usbmisc_hsic_set_connect(struct imx_usbmisc_data *);
 int imx_usbmisc_hsic_set_clk(struct imx_usbmisc_data *, bool);
+int imx_usbmisc_power_lost_check(struct imx_usbmisc_data *);
 
 #endif /* __DRIVER_USB_CHIPIDEA_CI_HDRC_IMX_H */
diff --git a/drivers/usb/chipidea/usbmisc_imx.c b/drivers/usb/chipidea/usbmisc_imx.c
index 38034dd..6b8d610 100644
--- a/drivers/usb/chipidea/usbmisc_imx.c
+++ b/drivers/usb/chipidea/usbmisc_imx.c
@@ -75,6 +75,8 @@ struct usbmisc_ops {
 	int (*hsic_set_connect)(struct imx_usbmisc_data *data);
 	/* It's called during suspend/resume */
 	int (*hsic_set_clk)(struct imx_usbmisc_data *data, bool enabled);
+	/* It's called when system resume from usb power lost */
+	int (*power_lost_check)(struct imx_usbmisc_data *data);
 };
 
 struct imx_usbmisc {
@@ -277,6 +279,24 @@ static int usbmisc_imx6sx_init(struct imx_usbmisc_data *data)
 	return 0;
 }
 
+static int usbmisc_imx6sx_power_lost_check(struct imx_usbmisc_data *data)
+{
+	unsigned long flags;
+	u32 val;
+
+	spin_lock_irqsave(&usbmisc->lock, flags);
+	val = readl(usbmisc->base + data->index * 4);
+	spin_unlock_irqrestore(&usbmisc->lock, flags);
+	/*
+	 * Here use a power on reset value to judge
+	 * if the controller experienced a power lost
+	 */
+	if (val == 0x30001000)
+		return 1;
+	else
+		return 0;
+}
+
 static int usbmisc_imx6q_hsic_set_connect(struct imx_usbmisc_data *data)
 {
 	unsigned long flags;
@@ -379,6 +399,7 @@ static const struct usbmisc_ops imx6sx_usbmisc_ops = {
 	.set_wakeup = usbmisc_imx6q_set_wakeup,
 	.hsic_set_connect = usbmisc_imx6q_hsic_set_connect,
 	.hsic_set_clk	= usbmisc_imx6q_hsic_set_clk,
+	.power_lost_check = usbmisc_imx6sx_power_lost_check,
 };
 
 int imx_usbmisc_init(struct imx_usbmisc_data *data)
@@ -431,6 +452,16 @@ int imx_usbmisc_hsic_set_clk(struct imx_usbmisc_data *data, bool on)
 }
 EXPORT_SYMBOL_GPL(imx_usbmisc_hsic_set_clk);
 
+int imx_usbmisc_power_lost_check(struct imx_usbmisc_data *data)
+{
+	if (!usbmisc)
+		return -ENODEV;
+	if (!usbmisc->ops->power_lost_check)
+		return 0;
+	return usbmisc->ops->power_lost_check(data);
+}
+EXPORT_SYMBOL_GPL(imx_usbmisc_power_lost_check);
+
 static const struct of_device_id usbmisc_imx_dt_ids[] = {
 	{
 		.compatible = "fsl,imx25-usbmisc",
-- 
1.7.5.4

