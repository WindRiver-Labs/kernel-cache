From f5a0eb48c74f3e65307ca565edf92e0807096fee Mon Sep 17 00:00:00 2001
From: Robert Baldyga <r.baldyga@samsung.com>
Date: Thu, 20 Feb 2014 07:30:13 +0100
Subject: [PATCH 0851/1074] drivers: usb: udc-core: add deferred bind for
 gadget driver

This patch adds support for deferred gadget driver bind as a remedy
for situation when UDC drivers and gadget drivers are builded into
the kernel, and gadget driver is loaded as first.

Till now, in that case gadget driver loading failed with "No such device"
and gadget driver didn't start.

Now gadget drivers are added to driver_list and binded later, when UDC
drivers will register in udc-core.

Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
Signed-off-by: Peter Chen <peter.chen@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/usb/gadget/udc-core.c |   29 ++++++++++++++++++++++++++++-
 include/linux/usb/gadget.h    |    3 +++
 2 files changed, 31 insertions(+), 1 deletions(-)

diff --git a/drivers/usb/gadget/udc-core.c b/drivers/usb/gadget/udc-core.c
index 9ce0b13..9333478 100644
--- a/drivers/usb/gadget/udc-core.c
+++ b/drivers/usb/gadget/udc-core.c
@@ -47,6 +47,7 @@ struct usb_udc {
 
 static struct class *udc_class;
 static LIST_HEAD(udc_list);
+static LIST_HEAD(driver_list);
 static DEFINE_MUTEX(udc_lock);
 
 /* ------------------------------------------------------------------------- */
@@ -184,6 +185,9 @@ static void usb_udc_nop_release(struct device *dev)
 	dev_vdbg(dev, "%s\n", __func__);
 }
 
+static int udc_bind_to_driver(struct usb_udc *udc,
+			      struct usb_gadget_driver *driver);
+
 /**
  * usb_add_gadget_udc_release - adds a new gadget to the udc class driver list
  * @parent: the parent device to this udc. Usually the controller driver's
@@ -242,6 +246,20 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 
 	usb_gadget_set_state(gadget, USB_STATE_NOTATTACHED);
 
+	if (!list_empty(&driver_list)) {
+		struct usb_gadget_driver *driver;
+		list_for_each_entry(driver, &driver_list, list) {
+			if (driver->attached)
+				continue;
+			ret = udc_bind_to_driver(udc, driver);
+			if (ret)
+				goto err4;
+			else
+				break;
+		}
+
+	}
+
 	mutex_unlock(&udc_lock);
 
 	return 0;
@@ -352,6 +370,7 @@ static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *dri
 		goto err1;
 	}
 	usb_gadget_connect(udc->gadget);
+	driver->attached = true;
 
 	kobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);
 	return 0;
@@ -408,8 +427,13 @@ int usb_gadget_probe_driver(struct usb_gadget_driver *driver)
 
 	pr_debug("couldn't find an available UDC\n");
 	mutex_unlock(&udc_lock);
-	return -ENODEV;
+
+	driver->attached = false;
+	list_add_tail(&driver->list, &driver_list);
+
+	return 0;
 found:
+	list_add_tail(&driver->list, &driver_list);
 	ret = udc_bind_to_driver(udc, driver);
 	mutex_unlock(&udc_lock);
 	return ret;
@@ -432,6 +456,9 @@ int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 			break;
 		}
 
+	driver->attached = false;
+	list_del(&driver->list);
+
 	mutex_unlock(&udc_lock);
 	return ret;
 }
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index c3a6185..09893f9 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -876,6 +876,9 @@ struct usb_gadget_driver {
 
 	/* FIXME support safe rmmod */
 	struct device_driver	driver;
+
+	bool			attached;
+	struct list_head	list;
 };
 
 
-- 
1.7.5.4

