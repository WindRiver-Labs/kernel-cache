From 47fa84a45a8a20d855b01c8ee3590ae5a6137d92 Mon Sep 17 00:00:00 2001
From: Anson Huang <b20788@freescale.com>
Date: Tue, 6 Aug 2013 15:19:21 -0400
Subject: [PATCH 0217/1074] ENGR00274009 ARM: imx: gpt clk on i.mx6sl can NOT
 source from OSC

There is no OSC clock source option for gpt on i.mx6sl, it
can only source from perclk, and perclk can be from OSC.

As perclk is clock source of many low speed devices, set
it to be from OSC, this can avoid freq varying when bus
clk(ipg) is scaled.

Signed-off-by: Anson Huang <b20788@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 arch/arm/mach-imx/clk-imx6sl.c |    4 ++--
 arch/arm/mach-imx/time.c       |   24 ++++++++++++------------
 2 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/arch/arm/mach-imx/clk-imx6sl.c b/arch/arm/mach-imx/clk-imx6sl.c
index 9084059..e99111e 100644
--- a/arch/arm/mach-imx/clk-imx6sl.c
+++ b/arch/arm/mach-imx/clk-imx6sl.c
@@ -150,7 +150,6 @@ static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 	clks[IMX6SL_CLK_PLL3_120M] = imx_clk_fixed_factor("pll3_120m", "pll3_usb_otg",   1, 4);
 	clks[IMX6SL_CLK_PLL3_80M]  = imx_clk_fixed_factor("pll3_80m",  "pll3_usb_otg",   1, 6);
 	clks[IMX6SL_CLK_PLL3_60M]  = imx_clk_fixed_factor("pll3_60m",  "pll3_usb_otg",   1, 8);
-	clks[IMX6SL_CLK_GPT_3M]    = imx_clk_fixed_factor("gpt_3m",    "osc",            1, 8);
 
 	np = ccm_node;
 	base = of_iomap(np, 0);
@@ -286,7 +285,6 @@ static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 
 	clk_register_clkdev(clks[IMX6SL_CLK_GPT], "ipg", "imx-gpt.0");
 	clk_register_clkdev(clks[IMX6SL_CLK_GPT_SERIAL], "per", "imx-gpt.0");
-	clk_register_clkdev(clks[IMX6SL_CLK_GPT_3M], "gpt_3m", "imx-gpt.0");
 
 	/* Ensure the AHB clk is at 132MHz. */
 	ret = clk_set_rate(clks[IMX6SL_CLK_AHB], 132000000);
@@ -323,6 +321,8 @@ static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 	clk_set_rate(clks[IMX6SL_CLK_PXP_AXI], 200000000);
 	clk_set_parent(clks[IMX6SL_CLK_LCDIF_AXI_SEL], clks[IMX6SL_CLK_PLL2_PFD2]);
 	clk_set_rate(clks[IMX6SL_CLK_LCDIF_AXI], 200000000);
+	/* set perclk to source from OSC 24MHz */
+	clk_set_parent(clks[IMX6SL_CLK_PERCLK_SEL], clks[IMX6SL_CLK_OSC]);
 
 	/* Set initial power mode */
 	imx6q_set_lpm(WAIT_CLOCKED);
diff --git a/arch/arm/mach-imx/time.c b/arch/arm/mach-imx/time.c
index 051a98e..cd3bb32 100644
--- a/arch/arm/mach-imx/time.c
+++ b/arch/arm/mach-imx/time.c
@@ -286,14 +286,14 @@ void __init mxc_timer_init(void __iomem *base, int irq)
 	struct clk *timer_ipg_clk;
 
 	/*
-	 * gpt clk source from 24M OSC on imx6 series SOCs except
-	 * imx6q TO1.0, others from per clk.
+	 * gpt clk source from 24M OSC on imx6q > TO1.0 and
+	 * imx6dl, others from per clk.
 	 */
-	if ((cpu_is_imx6q() && imx_get_soc_revision() == IMX_CHIP_REVISION_1_0)
-		|| !cpu_is_imx6())
-		timer_clk = clk_get_sys("imx-gpt.0", "per");
-	else
+	if ((cpu_is_imx6q() && imx_get_soc_revision() > IMX_CHIP_REVISION_1_0)
+		|| cpu_is_imx6dl())
 		timer_clk = clk_get_sys("imx-gpt.0", "gpt_3m");
+	else
+		timer_clk = clk_get_sys("imx-gpt.0", "per");
 
 	if (IS_ERR(timer_clk)) {
 		pr_err("i.MX timer: unable to get clk\n");
@@ -316,19 +316,19 @@ void __init mxc_timer_init(void __iomem *base, int irq)
 	__raw_writel(0, timer_base + MXC_TPRER); /* see datasheet note */
 
 	if (timer_is_v2()) {
-		if ((cpu_is_imx6q() && imx_get_soc_revision() ==
-			IMX_CHIP_REVISION_1_0) || !cpu_is_imx6()) {
-			tctl_val = V2_TCTL_CLK_PER | V2_TCTL_FRR |
-				V2_TCTL_WAITEN | MXC_TCTL_TEN;
-		} else {
+		if ((cpu_is_imx6q() && imx_get_soc_revision() >
+			IMX_CHIP_REVISION_1_0) || cpu_is_imx6dl()) {
 			tctl_val = V2_TCTL_CLK_OSC_DIV8 | V2_TCTL_FRR |
 				V2_TCTL_WAITEN | MXC_TCTL_TEN;
-			if (cpu_is_imx6dl() || cpu_is_imx6sl()) {
+			if (cpu_is_imx6dl()) {
 				/* 24 / 8 = 3 MHz */
 				tprer_val = 7 << V2_TPRER_PRE24M;
 				__raw_writel(tprer_val, timer_base + MXC_TPRER);
 				tctl_val |= V2_TCTL_24MEN;
 			}
+		} else {
+			tctl_val = V2_TCTL_CLK_PER | V2_TCTL_FRR |
+				V2_TCTL_WAITEN | MXC_TCTL_TEN;
 		}
 	} else {
 		tctl_val = MX1_2_TCTL_FRR | MX1_2_TCTL_CLK_PCLK1 | MXC_TCTL_TEN;
-- 
1.7.5.4

