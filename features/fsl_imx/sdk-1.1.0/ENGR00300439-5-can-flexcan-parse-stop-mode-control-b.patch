From a67d724d3076e4deffa29d7449c9ccf154abf820 Mon Sep 17 00:00:00 2001
From: Dong Aisheng <b29396@freescale.com>
Date: Mon, 24 Feb 2014 14:25:12 +0800
Subject: [PATCH 1006/1074] ENGR00300439-5 can: flexcan: parse stop mode
 control bits from device tree

Starting from IMX6, the flexcan stop mode control bits is SoC specific,
move it out of IP driver and parse it from devicetree.
It's good from maintain perspective and can avoid adding too many SoC
specifi bits in driver but with no IP changes when the IMX SoC series
keep growing.

Signed-off-by: Dong Aisheng <b29396@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git,fix
the context to apply to WRL kernel]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 .../devicetree/bindings/net/can/fsl-flexcan.txt    |    7 ++
 arch/arm/boot/dts/imx6qdl-sabresd.dtsi             |    1 -
 arch/arm/boot/dts/imx6qdl.dtsi                     |   11 +--
 drivers/net/can/flexcan.c                          |   94 ++++++++++++++------
 4 files changed, 78 insertions(+), 35 deletions(-)

diff --git a/Documentation/devicetree/bindings/net/can/fsl-flexcan.txt b/Documentation/devicetree/bindings/net/can/fsl-flexcan.txt
index a0ef78a..3248007 100644
--- a/Documentation/devicetree/bindings/net/can/fsl-flexcan.txt
+++ b/Documentation/devicetree/bindings/net/can/fsl-flexcan.txt
@@ -17,6 +17,13 @@ Optional properties:
 - clock-frequency : The oscillator frequency driving the flexcan device
 
 - xceiver-supply: Regulator that powers the CAN transceiver
+- stop-mode: register bits of stop mode control, the format is
+  <&gpr req_gpr req_bit ack_gpr ack_bit>.
+  gpr is the phandle to general purpose register node.
+  req_gpr is the gpr register offset of CAN stop request.
+  req_bit is the bit offset of CAN stop request.
+  ack_gpr is the gpr register offset of CAN stop acknowledge.
+  ack_bit is the bit offset of CAN stop acknowledge.
 
 Below are gpios for tranceiver:
 - trx_en_gpio : enable gpio
diff --git a/arch/arm/boot/dts/imx6qdl-sabresd.dtsi b/arch/arm/boot/dts/imx6qdl-sabresd.dtsi
index 97749aa..2e7b921 100644
--- a/arch/arm/boot/dts/imx6qdl-sabresd.dtsi
+++ b/arch/arm/boot/dts/imx6qdl-sabresd.dtsi
@@ -271,7 +271,6 @@
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_enet_1>;
 	phy-mode = "rgmii";
-	phy-reset-gpios = <&gpio1 25 0>;
 	status = "okay";
 };
 
diff --git a/arch/arm/boot/dts/imx6qdl.dtsi b/arch/arm/boot/dts/imx6qdl.dtsi
index 126cf4e..4d7f42e 100644
--- a/arch/arm/boot/dts/imx6qdl.dtsi
+++ b/arch/arm/boot/dts/imx6qdl.dtsi
@@ -12,11 +12,9 @@
 
 #include "skeleton.dtsi"
 #include <dt-bindings/gpio/gpio.h>
-
+ 
 / {
 	aliases {
-		flexcan0 = &flexcan1;
-		flexcan1 = &flexcan2;
 		gpio0 = &gpio1;
 		gpio1 = &gpio2;
 		gpio2 = &gpio3;
@@ -360,7 +358,7 @@
 				interrupts = <0 110 0x04>;
 				clocks = <&clks 108>, <&clks 109>;
 				clock-names = "ipg", "per";
-				gpr = <&gpr>;
+				stop-mode = <&gpr 0x34 28 0x10 17>;
 				status = "disabled";
 			};
 
@@ -370,7 +368,7 @@
 				interrupts = <0 111 0x04>;
 				clocks = <&clks 110>, <&clks 111>;
 				clock-names = "ipg", "per";
-				gpr = <&gpr>;
+				stop-mode = <&gpr 0x34 29 0x10 18>;
 				status = "disabled";
 			};
 
@@ -1568,8 +1566,7 @@
 			fec: ethernet@02188000 {
 				compatible = "fsl,imx6q-fec";
 				reg = <0x02188000 0x4000>;
-				interrupts-extended = <&intc 0 118 0x04>,
-						      <&intc 0 119 0x04>;
+				interrupts = <0 118 0x04 0 119 0x04>;
 				clocks = <&clks 117>, <&clks 117>, <&clks 190>;
 				clock-names = "ipg", "ahb", "ptp";
 				status = "disabled";
diff --git a/drivers/net/can/flexcan.c b/drivers/net/can/flexcan.c
index 1b0ad49..f8d9e70 100644
--- a/drivers/net/can/flexcan.c
+++ b/drivers/net/can/flexcan.c
@@ -206,6 +206,13 @@ struct flexcan_devtype_data {
 	u32 features;	/* hardware controller features */
 };
 
+struct flexcan_stop_mode {
+	struct regmap *gpr;
+	u8 req_gpr;
+	u8 req_bit;
+	u8 ack_gpr;
+	u8 ack_bit;
+};
 struct flexcan_priv {
 	struct can_priv can;
 	struct net_device *dev;
@@ -220,7 +227,7 @@ struct flexcan_priv {
 	struct flexcan_platform_data *pdata;
 	const struct flexcan_devtype_data *devtype_data;
 	struct regulator *reg_xceiver;
-	struct regmap *gpr;
+	struct flexcan_stop_mode stm;
 	int id;
 };
 
@@ -274,28 +281,18 @@ static inline void flexcan_write(u32 val, void __iomem *addr)
 
 static inline void flexcan_enter_stop_mode(struct flexcan_priv *priv)
 {
-	int val;
-
 	/* enable stop request */
-	if (priv->devtype_data->features & FLEXCAN_HAS_V10_FEATURES) {
-		val = priv->id ? IMX6Q_GPR13_CAN2_STOP_REQ :
-				IMX6Q_GPR13_CAN1_STOP_REQ;
-		regmap_update_bits(priv->gpr, IOMUXC_GPR13,
-			val, val);
-	}
+	if (priv->devtype_data->features & FLEXCAN_HAS_V10_FEATURES)
+		regmap_update_bits(priv->stm.gpr, priv->stm.req_gpr,
+			1 << priv->stm.req_bit, 1 << priv->stm.req_bit);
 }
 
 static inline void flexcan_exit_stop_mode(struct flexcan_priv *priv)
 {
-	int val;
-
 	/* remove stop request */
-	if (priv->devtype_data->features & FLEXCAN_HAS_V10_FEATURES) {
-		val = priv->id ? IMX6Q_GPR13_CAN2_STOP_REQ :
-				IMX6Q_GPR13_CAN1_STOP_REQ;
-		regmap_update_bits(priv->gpr, IOMUXC_GPR13,
-			val, 0);
-	}
+	if (priv->devtype_data->features & FLEXCAN_HAS_V10_FEATURES)
+		regmap_update_bits(priv->stm.gpr, priv->stm.req_gpr,
+			1 << priv->stm.req_bit, 0);
 }
 
 static inline int flexcan_transceiver_enable(const struct flexcan_priv *priv)
@@ -1118,6 +1115,56 @@ static void unregister_flexcandev(struct net_device *dev)
 	unregister_candev(dev);
 }
 
+static int flexcan_of_parse_stop_mode(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *node;
+	struct flexcan_priv *priv;
+	phandle phandle;
+	u32 out_val[5];
+	int ret;
+
+	if (!np)
+		return -EINVAL;
+	/*
+	 * stop mode property format is:
+	 * <&gpr req_gpr req_bit ack_gpr ack_bit>.
+	 */
+	ret = of_property_read_u32_array(np, "stop-mode", out_val, 5);
+	if (ret) {
+		dev_dbg(&pdev->dev, "no stop-mode property\n");
+		return ret;
+	}
+	phandle = *out_val;
+
+	node = of_find_node_by_phandle(phandle);
+	if (!node) {
+		dev_dbg(&pdev->dev, "could not find gpr node by phandle\n");
+		return PTR_ERR(node);
+	}
+
+	priv = netdev_priv(dev);
+	priv->stm.gpr = syscon_node_to_regmap(node);
+	if (IS_ERR(priv->stm.gpr)) {
+		dev_dbg(&pdev->dev, "could not find gpr regmap\n");
+		return PTR_ERR(priv->stm.gpr);
+	}
+
+	of_node_put(node);
+
+	priv->stm.req_gpr = out_val[1];
+	priv->stm.req_bit = out_val[2];
+	priv->stm.ack_gpr = out_val[3];
+	priv->stm.ack_bit = out_val[4];
+
+	dev_dbg(&pdev->dev, "gpr %s req_gpr 0x%x req_bit %u ack_gpr 0x%x ack_bit %u\n",
+			node->full_name, priv->stm.req_gpr,
+			priv->stm.req_bit, priv->stm.ack_gpr,
+			priv->stm.ack_bit);
+	return 0;
+}
+
 static const struct of_device_id flexcan_of_match[] = {
 	{ .compatible = "fsl,imx6q-flexcan", .data = &fsl_imx6q_devtype_data, },
 	{ .compatible = "fsl,imx28-flexcan", .data = &fsl_imx28_devtype_data, },
@@ -1224,17 +1271,10 @@ static int flexcan_probe(struct platform_device *pdev)
 	devm_can_led_init(dev);
 
 	if (priv->devtype_data->features & FLEXCAN_HAS_V10_FEATURES) {
-		priv->gpr = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
-				"gpr");
-		if (IS_ERR(priv->gpr)) {
-			wakeup = 0;
-			dev_dbg(&pdev->dev, "can not get grp\n");
-		}
-
-		priv->id = of_alias_get_id(pdev->dev.of_node, "flexcan");
-		if (priv->id < 0) {
+		err = flexcan_of_parse_stop_mode(pdev);
+		if (err) {
 			wakeup = 0;
-			dev_dbg(&pdev->dev, "can not get alias id\n");
+			dev_dbg(&pdev->dev, "failed to parse stop-mode\n");
 		}
 	}
 
-- 
1.7.5.4

