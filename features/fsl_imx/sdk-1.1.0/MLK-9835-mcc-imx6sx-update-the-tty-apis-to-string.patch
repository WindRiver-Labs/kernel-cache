From d18a4505f000d783e4ab1f157bbef198009414b0 Mon Sep 17 00:00:00 2001
From: Richard Zhu <Richard.Zhu@freescale.com>
Date: Fri, 31 Oct 2014 14:16:49 +0800
Subject: [PATCH 1014/1074] MLK-9835 mcc: imx6sx: update the tty apis to
 string

- change the msg type of the mcc tty interface from
unsigned int to the string, and set the limitation
on the length < 1000
- let mcc test bulit-in in default
- Co-operated with "MCC Virtual TTY EXAMPLE" of MQX/M4,
and use the unit_test named mxc_mcc_tty_test.out, to
do the unit tests.
- MQX/M4 would send back the spring sent by userspace of
the Linux/A9 directly.

useage howto:
first of all, start the "MCC Virtual TTY EXAMPLE" before
the begin of the unit test at MQX/M4 side.
Linux/A9:
step1: use unit test to configure ttyMCC.
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
--------------------------------------------------------
./mxc_mcc_tty_test.out /dev/ttyMCCp0 115200 R 100 1000 &

Serial port /dev/ttyMCCp0 opened

step2: write string to ttyMCC from user space.
and the string would be sent back by MQX/M4 and received by
mxc_mcc_tty_test directly.
--------------------------------------------------------
echo abcd > /dev/ttyMCCp0

root@imx6sxsabresd:~# imx mcc tty receive abcd
.
[1] READ finished :5 bytes

abcd

Log of MQX/M4:
***** MCC Virtual TTY EXAMPLE *****
Please wait :
1) A9 peer is ready
Then press "S" to start the demo
********************************

Press "S" to start the demo : s

Responder task started, MCC version is 002.000
Responder task received a msg from [0,0,1] endpoint
Message: Size=3e8, DATA = "abcd
"

Signed-off-by: Richard Zhu <Richard.Zhu@freescale.com>
(cherry picked from commit e440a7331c493526ee8a1b146a6da0312bc2dc0c)
---
 drivers/char/imx_mcc/Kconfig       |   14 ++++---
 drivers/char/imx_mcc/imx_mcc_tty.c |   64 ++++++++++++++++++-----------------
 2 files changed, 41 insertions(+), 37 deletions(-)

diff --git a/drivers/char/imx_mcc/Kconfig b/drivers/char/imx_mcc/Kconfig
index b12f400..3810400 100644
--- a/drivers/char/imx_mcc/Kconfig
+++ b/drivers/char/imx_mcc/Kconfig
@@ -11,18 +11,20 @@ config IMX_SEMA4
 config IMX_MCC_TEST
 	bool "IMX MCC test driver"
 	depends on SOC_IMX6SX && IMX_SEMA4
+	default y
 	help
-	  Support for IMX MCC ping pong test and so on, most people
- 	  should say N here.
+	  If you say Y here, you will get support for IMX MCC ping pong
+	  test and CAN test. Say N here, if the IMX_MCC_TTY interface is
+	  mandatory required.
+
+	  If unsure, it is safe to say Y.
 
 config IMX_MCC_TTY
 	bool "IMX PTY for MCC interface"
 	depends on SOC_IMX6SX && IMX_SEMA4 && !IMX_MCC_TEST
-	default y
 	help
 	  This enables a PTY node for IMX6SX MCC, used as interface
-	  between kernel space and user space, and flush the message
-	  received from M4 side to user space, most people
-	  should say N here.
+ 	  between kernel space and user space. Say N here, if the
+	  interface is not required.
 
 #end imx mcc
diff --git a/drivers/char/imx_mcc/imx_mcc_tty.c b/drivers/char/imx_mcc/imx_mcc_tty.c
index a40243c..bd302f5 100644
--- a/drivers/char/imx_mcc/imx_mcc_tty.c
+++ b/drivers/char/imx_mcc/imx_mcc_tty.c
@@ -52,8 +52,8 @@ enum {
 /* mcc tty/pingpong demo */
 static MCC_ENDPOINT mcc_endpoint_a9_pingpong = {0, MCC_NODE_A9, MCC_A9_PORT};
 static MCC_ENDPOINT mcc_endpoint_m4_pingpong = {1, MCC_NODE_M4, MCC_M4_PORT};
-struct mcc_pp_msg {
-	unsigned int data;
+struct mcc_tty_msg {
+	char data[MCC_ATTR_BUFFER_SIZE_IN_BYTES - 24];
 };
 
 static void mcctty_delay_work(struct work_struct *work)
@@ -61,7 +61,7 @@ static void mcctty_delay_work(struct work_struct *work)
 	struct mcctty_port *cport = &mcc_tty_port;
 	int ret, space;
 	unsigned char *cbuf;
-	struct mcc_pp_msg pp_msg;
+	struct mcc_tty_msg tty_msg;
 	MCC_MEM_SIZE num_of_received_bytes;
 	MCC_INFO_STRUCT mcc_info;
 
@@ -84,25 +84,26 @@ static void mcctty_delay_work(struct work_struct *work)
 
 	while (1) {
 		ret = mcc_recv(&mcc_endpoint_m4_pingpong,
-				&mcc_endpoint_a9_pingpong, &pp_msg,
-				sizeof(struct mcc_pp_msg),
+				&mcc_endpoint_a9_pingpong, &tty_msg,
+				sizeof(struct mcc_tty_msg),
 				&num_of_received_bytes, 0xffffffff);
 
 		if (MCC_SUCCESS != ret) {
 			pr_err("A9 Main task receive error: %d\n", ret);
 		} else {
+			pr_info("imx mcc tty receive %s.\n", tty_msg.data);
 			/* flush the recv-ed data to tty node */
 			spin_lock_bh(&cport->rx_lock);
 			space = tty_prepare_flip_string(&cport->port, &cbuf,
-							num_of_received_bytes);
+							strlen(tty_msg.data));
 			if ((space <= 0) || (cport->rx_buf == NULL))
-				goto pp_unlock;
+				goto tty_unlock;
 
-			memcpy(cport->rx_buf, &pp_msg.data,
-					num_of_received_bytes);
+			memcpy(cport->rx_buf, &tty_msg.data,
+					strlen(tty_msg.data));
 			memcpy(cbuf, cport->rx_buf, space);
 			tty_flip_buffer_push(&cport->port);
-pp_unlock:
+tty_unlock:
 			spin_unlock_bh(&cport->rx_lock);
 		}
 	}
@@ -128,32 +129,33 @@ static void mcctty_close(struct tty_struct *tty, struct file *filp)
 static int mcctty_write(struct tty_struct *tty, const unsigned char *buf,
 			 int total)
 {
-	int i, ret = 0;
-	struct mcc_pp_msg pp_msg;
+	int ret = 0;
+	struct mcc_tty_msg tty_msg;
+
+	if ((NULL == buf) || (total > 1000)) {
+		pr_err("shouldn't be null and the length should"
+				" be less than 1000 bytes.\n");
+		return -ENOMEM;
+	}
 
-	if (NULL == buf)
-		return 0;
+	strlcpy(tty_msg.data, buf, total + 1);
 
-	for (i = 0; i < total; i++) {
-		pp_msg.data = (unsigned int)buf[i];
+	/*
+	 * wait until the remote endpoint is created by
+	 * the other core
+	 */
+	ret = mcc_send(&mcc_endpoint_a9_pingpong,
+			&mcc_endpoint_m4_pingpong, &tty_msg,
+			sizeof(struct mcc_tty_msg),
+			0xffffffff);
 
-		/*
-		 * wait until the remote endpoint is created by
-		 * the other core
-		 */
+	while (MCC_ERR_ENDPOINT == ret) {
+		pr_err("\n send err ret %d, re-send\n", ret);
 		ret = mcc_send(&mcc_endpoint_a9_pingpong,
-				&mcc_endpoint_m4_pingpong, &pp_msg,
-				sizeof(struct mcc_pp_msg),
+				&mcc_endpoint_m4_pingpong, &tty_msg,
+				sizeof(struct mcc_tty_msg),
 				0xffffffff);
-
-		while (MCC_ERR_ENDPOINT == ret) {
-			pr_err("\n send err ret %d, re-send\n", ret);
-			ret = mcc_send(&mcc_endpoint_a9_pingpong,
-					&mcc_endpoint_m4_pingpong, &pp_msg,
-					sizeof(struct mcc_pp_msg),
-					0xffffffff);
-			msleep(5000);
-		}
+		msleep(5000);
 	}
 
 	return total;
-- 
1.7.5.4

