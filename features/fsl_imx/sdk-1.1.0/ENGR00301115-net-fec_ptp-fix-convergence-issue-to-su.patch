From 889ebdcd0d7352f95a93e6305fa14116f3454308 Mon Sep 17 00:00:00 2001
From: Fugang Duan <B38611@freescale.com>
Date: Thu, 27 Feb 2014 15:29:09 +0800
Subject: [PATCH 1045/1074] ENGR00301115 net: fec_ptp: fix convergence issue
 to support IXXAT and LinuxPTP stack

IEEE 1588 module has one hw issue in capturing the ATVR register. According
to the user manual it is:
	ENET0->ATCR |= ENET_ATCR_CAPTURE_MASK;
	while(ENET0->ATCR & ENET_ATCR_CAPTURE_MASK);
	ts_counter_ns = ENET0->ATVR;

Incorrect behavior for ENET_ATCR[Capture and Restart Bits]. These bits will always
read a value zero. According to SPEC, when these bits are set to 1'b1, these should
hold value 1'b1 until the counter value is capture in the register clock domain.

Unfortunately there is a bug with the way the bit "ENET_ATCR_CAPTURE" clears.
So need something like:
	ENET0->ATCR |= ENET_ATCR_CAPTURE_MASK;
	wait();
	ts_counter_ns = ENET0->ATVR;

The wait-time to be at least 6 clock cycle of the slower clock between the register
clock and the 1588 clock. The 1588 ts_clk is 25Mhz, register clock is 66Mhz, so the
wait-time must be greater than 240ns (40ns * 6). The workaround is that adding 1us
delay before read ATVR.

Signed-off-by: Fugang Duan <B38611@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/net/ethernet/freescale/fec.h      |   61 +++++++++++++++++++++++++++++
 drivers/net/ethernet/freescale/fec_main.c |   46 +---------------------
 drivers/net/ethernet/freescale/fec_ptp.c  |   12 ++++-
 3 files changed, 71 insertions(+), 48 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fec.h b/drivers/net/ethernet/freescale/fec.h
index 9cb330c..478e85d 100644
--- a/drivers/net/ethernet/freescale/fec.h
+++ b/drivers/net/ethernet/freescale/fec.h
@@ -390,6 +390,67 @@ struct bufdesc_ex {
 #define FEC_PTP_TIMEOUT_TS		10
 #define FEC_PTP_TIMEOUT_EVENT		1000
 
+/* Controller is ENET-MAC */
+#define FEC_QUIRK_ENET_MAC              (1 << 0)
+/* Controller needs driver to swap frame */
+#define FEC_QUIRK_SWAP_FRAME            (1 << 1)
+/* Controller uses gasket */
+#define FEC_QUIRK_USE_GASKET            (1 << 2)
+/* Controller has GBIT support */
+#define FEC_QUIRK_HAS_GBIT              (1 << 3)
+/* Controller has extend desc buffer */
+#define FEC_QUIRK_HAS_BUFDESC_EX        (1 << 4)
+/* Controller has hardware checksum support */
+#define FEC_QUIRK_HAS_CSUM              (1 << 5)
+/* Controller has hardware vlan support */
+#define FEC_QUIRK_HAS_VLAN              (1 << 6)
+/* Controller is FEC-MAC */
+#define FEC_QUIRK_FEC_MAC              (1 << 7)
+/* ENET IP errata ERR006358
+ *
+ * If the ready bit in the transmit buffer descriptor (TxBD[R]) is previously
+ * detected as not set during a prior frame transmission, then the
+ * ENET_TDAR[TDAR] bit is cleared at a later time, even if additional TxBDs
+ * were added to the ring and the ENET_TDAR[TDAR] bit is set. This results in
+ * If the ready bit in the transmit buffer descriptor (TxBD[R]) is previously
+ * detected as not set during a prior frame transmission, then the
+ * ENET_TDAR[TDAR] bit is cleared at a later time, even if additional TxBDs
+ * were added to the ring and the ENET_TDAR[TDAR] bit is set. This results in
+ * frames not being transmitted until there is a 0-to-1 transition on
+ * ENET_TDAR[TDAR].
+ */
+#define FEC_QUIRK_ERR006358            (1 << 8)
+/*
+ * i.MX6Q/DL ENET cannot wake up system in wait mode because ENET tx & rx
+ * interrupt signal don't connect to GPC. So use pm qos to avoid cpu enter
+ * to wait mode.
+ */
+#define FEC_QUIRK_BUG_WAITMODE          (1 << 9)
+/*
+ * i.MX6SX ENET IP add Audio Video Bridging (AVB) feature support.
+ * ENET IP hw AVB main function:
+ * - Two class indicators on receive with configurable priority
+ * - Two class indicators and line speed timer on transmit allowing
+ *   implementation class credit based shapers externally
+ * - Additional DMA registers provisioned to allow managing up to 3
+ *   independent rings
+ */
+#define FEC_QUIRK_HAS_AVB               (1 << 10)
+/*
+ * There is a TDAR race condition for mutliQ when the software sets TDAR
+ * and the UDMA clears TDAR simultaneously or in a small window (2-4 cycles).
+ * This will cause the udma_tx and udma_tx_arbiter state machines to hang.
+ * The issue exist at i.MX6SX enet IP.
+ */
+#define FEC_QUIRK_TKT210582             (1 << 11)
+/*
+ * Incorrect behavior for ENET_ATCR[Capture and Restart Bits].
+ * These bits will always read a value zero. According to SPEC, when these
+ * bits are set to 1'b1, these should hold value 1'b1 until the counter value
+ * is capture in the register clock domain.
+ */
+#define FEC_QUIRK_TKT210590             (1 << 12)
+
 /* PTP standard time representation structure */
 struct ptp_time{
 	u64 sec;        /* seconds */
diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c
index 2427b9b..395705d 100644
--- a/drivers/net/ethernet/freescale/fec_main.c
+++ b/drivers/net/ethernet/freescale/fec_main.c
@@ -82,50 +82,6 @@ static const u16 fec_enet_vlan_pri_to_queue[8] = {1, 1, 1, 1, 2, 2, 2, 2};
 #define FEC_ENET_RAFL_V	0x8
 #define FEC_ENET_OPD_V	0xFFF0
 
-/* Controller is ENET-MAC */
-#define FEC_QUIRK_ENET_MAC		(1 << 0)
-/* Controller needs driver to swap frame */
-#define FEC_QUIRK_SWAP_FRAME		(1 << 1)
-/* Controller uses gasket */
-#define FEC_QUIRK_USE_GASKET		(1 << 2)
-/* Controller has GBIT support */
-#define FEC_QUIRK_HAS_GBIT		(1 << 3)
-/* Controller has extend desc buffer */
-#define FEC_QUIRK_HAS_BUFDESC_EX	(1 << 4)
-/* Controller has hardware checksum support */
-#define FEC_QUIRK_HAS_CSUM		(1 << 5)
-/* Controller has hardware vlan support */
-#define FEC_QUIRK_HAS_VLAN		(1 << 6)
-/* Controller is FEC-MAC */
-#define FEC_QUIRK_FEC_MAC              (1 << 7)
-/* ENET IP errata ERR006358
- *
- * If the ready bit in the transmit buffer descriptor (TxBD[R]) is previously
- * detected as not set during a prior frame transmission, then the
- * ENET_TDAR[TDAR] bit is cleared at a later time, even if additional TxBDs
- * were added to the ring and the ENET_TDAR[TDAR] bit is set. This results in
- * frames not being transmitted until there is a 0-to-1 transition on
- * ENET_TDAR[TDAR].
- */
-#define FEC_QUIRK_ERR006358            (1 << 7)
-/*
- * i.MX6SX ENET IP add Audio Video Bridging (AVB) feature support.
- * ENET IP hw AVB main function:
- * - Two class indicators on receive with configurable priority
- * - Two class indicators and line speed timer on transmit allowing
- *   implementation class credit based shapers externally
- * - Additional DMA registers provisioned to allow managing up to 3
- *   independent rings
- */
-#define FEC_QUIRK_HAS_AVB		(1 << 10)
-/*
- * There is a TDAR race condition for mutliQ when the software sets TDAR
- * and the UDMA clears TDAR simultaneously or in a small window (2-4 cycles).
- * This will cause the udma_tx and udma_tx_arbiter state machines to hang.
- * The issue exist at i.MX6SX enet IP.
- */
-#define FEC_QUIRK_TKT210582		(1 << 11)
-
 static struct platform_device_id fec_devtype[] = {
 	{
 		/* keep it for coldfire */
@@ -153,7 +109,7 @@ static struct platform_device_id fec_devtype[] = {
 		.driver_data = FEC_QUIRK_ENET_MAC | FEC_QUIRK_HAS_GBIT |
 				FEC_QUIRK_HAS_BUFDESC_EX | FEC_QUIRK_HAS_CSUM |
 				FEC_QUIRK_HAS_VLAN | FEC_QUIRK_HAS_AVB |
-				FEC_QUIRK_TKT210582,
+				FEC_QUIRK_TKT210582 | FEC_QUIRK_TKT210590,
 	}, {
 		/* sentinel */
 	}
diff --git a/drivers/net/ethernet/freescale/fec_ptp.c b/drivers/net/ethernet/freescale/fec_ptp.c
index 55f2370..94e9b32 100644
--- a/drivers/net/ethernet/freescale/fec_ptp.c
+++ b/drivers/net/ethernet/freescale/fec_ptp.c
@@ -228,6 +228,8 @@ static void fec_get_curr_cnt(struct fec_enet_private *priv,
 {
 	u32 tempval, old_sec;
 	u32 timeout_event, timeout_ts = 0;
+	const struct platform_device_id *id_entry =
+			platform_get_device_id(priv->pdev);
 
 	do {
 		old_sec = priv->prtc;
@@ -236,7 +238,8 @@ static void fec_get_curr_cnt(struct fec_enet_private *priv,
 		tempval = readl(priv->hwp + FEC_ATIME_CTRL);
 		tempval |= FEC_T_CTRL_CAPTURE;
 		writel(tempval, priv->hwp + FEC_ATIME_CTRL);
-
+		if (id_entry->driver_data & FEC_QUIRK_TKT210590)
+			udelay(1);
 		curr_time->rtc_time.nsec = readl(priv->hwp + FEC_ATIME);
 
 		while (readl(priv->hwp + FEC_IEVENT) & FEC_ENET_TS_TIMER) {
@@ -519,7 +522,7 @@ static void fec_handle_ptpdrift(struct fec_enet_private *priv,
 }
 
 static void fec_set_drift(struct fec_enet_private *priv,
-			  struct ptp_set_comp *comp)
+			struct ptp_set_comp *comp)
 {
 	struct ptp_time_correct	tc;
 	u32 tmp, corr_ns;
@@ -554,12 +557,15 @@ static cycle_t fec_ptp_read(const struct cyclecounter *cc)
 {
 	struct fec_enet_private *fep =
 		container_of(cc, struct fec_enet_private, cc);
+	const struct platform_device_id *id_entry =
+			platform_get_device_id(fep->pdev);
 	u32 tempval;
 
 	tempval = readl(fep->hwp + FEC_ATIME_CTRL);
 	tempval |= FEC_T_CTRL_CAPTURE;
 	writel(tempval, fep->hwp + FEC_ATIME_CTRL);
-
+	if (id_entry->driver_data & FEC_QUIRK_TKT210590)
+		udelay(1);
 	return readl(fep->hwp + FEC_ATIME);
 }
 
-- 
1.7.5.4

