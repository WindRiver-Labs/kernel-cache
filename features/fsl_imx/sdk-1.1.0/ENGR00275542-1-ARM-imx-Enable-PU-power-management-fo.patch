From 6928809129886293a26b814b4f1876f6da9d39ed Mon Sep 17 00:00:00 2001
From: Anson Huang <b20788@freescale.com>
Date: Mon, 19 Aug 2013 15:14:43 -0400
Subject: [PATCH 0085/1074] ENGR00275542-1 ARM: imx: Enable PU power
 management for i.MX6SL

Enable dynamical PU power management for i.MX6SL.

Signed-off-by: Anson Huang <b20788@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 arch/arm/boot/dts/imx6sl.dtsi  |    5 ++-
 arch/arm/mach-imx/clk-imx6sl.c |    4 ++
 arch/arm/mach-imx/gpc.c        |   72 ++++++++++++++++++++++++++--------------
 3 files changed, 55 insertions(+), 26 deletions(-)

diff --git a/arch/arm/boot/dts/imx6sl.dtsi b/arch/arm/boot/dts/imx6sl.dtsi
index dbd5b0a..910d460 100644
--- a/arch/arm/boot/dts/imx6sl.dtsi
+++ b/arch/arm/boot/dts/imx6sl.dtsi
@@ -454,7 +454,6 @@
 					regulator-name = "vddpu";
 					regulator-min-microvolt = <725000>;
 					regulator-max-microvolt = <1450000>;
-					regulator-always-on;
 					anatop-reg-offset = <0x140>;
 					anatop-vol-bit-shift = <9>;
 					anatop-vol-bit-width = <5>;
@@ -532,6 +531,10 @@
 				compatible = "fsl,imx6sl-gpc", "fsl,imx6q-gpc";
 				reg = <0x020dc000 0x4000>;
 				interrupts = <0 89 0x04>;
+				clocks = <&clks IMX6SL_CLK_GPU2D_PODF>, <&clks IMX6SL_CLK_GPU2D_OVG>,
+					<&clks IMX6SL_CLK_IPG>;
+				clock-names = "gpu2d_podf", "gpu2d_ovg", "ipg";
+				pu-supply = <&reg_pu>;
 			};
 
 			gpr: iomuxc-gpr@020e0000 {
diff --git a/arch/arm/mach-imx/clk-imx6sl.c b/arch/arm/mach-imx/clk-imx6sl.c
index 7c97ba2..ba5c80a 100644
--- a/arch/arm/mach-imx/clk-imx6sl.c
+++ b/arch/arm/mach-imx/clk-imx6sl.c
@@ -275,6 +275,10 @@ static void __init imx6sl_clocks_init(struct device_node *ccm_node)
 		clk_prepare_enable(clks[IMX6SL_CLK_USBPHY2_GATE]);
 	}
 
+	clk_set_parent(clks[IMX6SL_CLK_GPU2D_OVG_SEL],
+		clks[IMX6SL_CLK_PLL2_BUS]);
+	clk_set_parent(clks[IMX6SL_CLK_GPU2D_SEL], clks[IMX6SL_CLK_PLL2_BUS]);
+
 	/* Audio-related clocks configuration */
 	clk_set_parent(clks[IMX6SL_CLK_SPDIF0_SEL], clks[IMX6SL_CLK_PLL3_PFD3]);
 
diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 00d2cb0..1dc0815 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -22,6 +22,7 @@
 #include <linux/irqchip/arm-gic.h>
 #include <linux/regulator/consumer.h>
 #include "common.h"
+#include "hardware.h"
 
 #define GPC_IMR1		0x008
 #define GPC_PGC_CPU_PDN		0x2a0
@@ -149,19 +150,29 @@ void imx_gpc_irq_mask(struct irq_data *d)
 static void imx_pu_clk(bool enable)
 {
 	if (enable) {
-		clk_prepare_enable(gpu3d_clk);
-		clk_prepare_enable(gpu3d_shader_clk);
-		clk_prepare_enable(vpu_clk);
-		clk_prepare_enable(gpu2d_clk);
-		clk_prepare_enable(gpu2d_axi_clk);
-		clk_prepare_enable(openvg_axi_clk);
+		if (cpu_is_imx6sl()) {
+			clk_prepare_enable(gpu2d_clk);
+			clk_prepare_enable(openvg_axi_clk);
+		} else {
+			clk_prepare_enable(gpu3d_clk);
+			clk_prepare_enable(gpu3d_shader_clk);
+			clk_prepare_enable(vpu_clk);
+			clk_prepare_enable(gpu2d_clk);
+			clk_prepare_enable(gpu2d_axi_clk);
+			clk_prepare_enable(openvg_axi_clk);
+		}
 	} else {
-		clk_disable_unprepare(gpu3d_clk);
-		clk_disable_unprepare(gpu3d_shader_clk);
-		clk_disable_unprepare(vpu_clk);
-		clk_disable_unprepare(gpu2d_clk);
-		clk_disable_unprepare(gpu2d_axi_clk);
-		clk_disable_unprepare(openvg_axi_clk);
+		if (cpu_is_imx6sl()) {
+			clk_disable_unprepare(gpu2d_clk);
+			clk_disable_unprepare(openvg_axi_clk);
+		} else {
+			clk_disable_unprepare(gpu3d_clk);
+			clk_disable_unprepare(gpu3d_shader_clk);
+			clk_disable_unprepare(vpu_clk);
+			clk_disable_unprepare(gpu2d_clk);
+			clk_disable_unprepare(gpu2d_axi_clk);
+			clk_disable_unprepare(openvg_axi_clk);
+		}
 	}
 }
 
@@ -306,19 +317,30 @@ static int imx_gpc_probe(struct platform_device *pdev)
 	nb.notifier_call = &imx_gpc_regulator_notify;
 
 	/* Get gpu&vpu clk for power up PU by GPC */
-	gpu3d_clk = devm_clk_get(gpc_dev, "gpu3d_core");
-	gpu3d_shader_clk = devm_clk_get(gpc_dev, "gpu3d_shader");
-	gpu2d_clk = devm_clk_get(gpc_dev, "gpu2d_core");
-	gpu2d_axi_clk = devm_clk_get(gpc_dev, "gpu2d_axi");
-	openvg_axi_clk = devm_clk_get(gpc_dev, "openvg_axi");
-	vpu_clk = devm_clk_get(gpc_dev, "vpu_axi");
-	ipg_clk = devm_clk_get(gpc_dev, "ipg");
-	if (IS_ERR(gpu3d_clk) || IS_ERR(gpu3d_shader_clk)
-		|| IS_ERR(gpu2d_clk) || IS_ERR(gpu2d_axi_clk)
-		|| IS_ERR(openvg_axi_clk) || IS_ERR(vpu_clk)
-		|| IS_ERR(ipg_clk)) {
-		dev_err(gpc_dev, "failed to get clk!\n");
-		return -ENOENT;
+	if (cpu_is_imx6sl()) {
+		gpu2d_clk = devm_clk_get(gpc_dev, "gpu2d_podf");
+		openvg_axi_clk = devm_clk_get(gpc_dev, "gpu2d_ovg");
+		ipg_clk = devm_clk_get(gpc_dev, "ipg");
+		if (IS_ERR(gpu2d_clk) || IS_ERR(openvg_axi_clk)
+			|| IS_ERR(ipg_clk)) {
+			dev_err(gpc_dev, "failed to get clk!\n");
+			return -ENOENT;
+		}
+	} else {
+		gpu3d_clk = devm_clk_get(gpc_dev, "gpu3d_core");
+		gpu3d_shader_clk = devm_clk_get(gpc_dev, "gpu3d_shader");
+		gpu2d_clk = devm_clk_get(gpc_dev, "gpu2d_core");
+		gpu2d_axi_clk = devm_clk_get(gpc_dev, "gpu2d_axi");
+		openvg_axi_clk = devm_clk_get(gpc_dev, "openvg_axi");
+		vpu_clk = devm_clk_get(gpc_dev, "vpu_axi");
+		ipg_clk = devm_clk_get(gpc_dev, "ipg");
+		if (IS_ERR(gpu3d_clk) || IS_ERR(gpu3d_shader_clk)
+			|| IS_ERR(gpu2d_clk) || IS_ERR(gpu2d_axi_clk)
+			|| IS_ERR(openvg_axi_clk) || IS_ERR(vpu_clk)
+			|| IS_ERR(ipg_clk)) {
+			dev_err(gpc_dev, "failed to get clk!\n");
+			return -ENOENT;
+		}
 	}
 
 	ret = regulator_register_notifier(pu_reg, &nb);
-- 
1.7.5.4

