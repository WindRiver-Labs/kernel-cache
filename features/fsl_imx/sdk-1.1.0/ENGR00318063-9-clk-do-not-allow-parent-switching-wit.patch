From d5d48d0cd609ff60466229980656df36bccb4673 Mon Sep 17 00:00:00 2001
From: Shawn Guo <shawn.guo@freescale.com>
Date: Thu, 5 Jun 2014 16:54:31 +0800
Subject: [PATCH 0865/1074] ENGR00318063-9: clk: do not allow parent switching
 with another mux being child

When switching parent clock with another basic mux clock being its
child, a glitch might be generated and propagated to downstream clocks
through this child mux.

The patch adds a flag CLK_IS_BASIC_MUX to identify the basic mux clocks,
and prohibit the parent switching when the clock itself is the parent of
any basic mux clock.  With this check, the parent switching of a clock
has to happen before the child mux switches to this clock path.

Signed-off-by: Shawn Guo <shawn.guo@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/clk/clk-mux.c        |    2 +-
 drivers/clk/clk.c            |   13 +++++++++++++
 include/linux/clk-provider.h |    6 ++++++
 3 files changed, 20 insertions(+), 1 deletions(-)

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 4f96ff3..d3a8f94 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -143,7 +143,7 @@ struct clk *clk_register_mux_table(struct device *dev, const char *name,
 		init.ops = &clk_mux_ro_ops;
 	else
 		init.ops = &clk_mux_ops;
-	init.flags = flags | CLK_IS_BASIC;
+	init.flags = flags | CLK_IS_BASIC | CLK_IS_BASIC_MUX;
 	init.parent_names = parent_names;
 	init.num_parents = num_parents;
 
diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 4ea3c06..e7dcbd9 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1707,6 +1707,7 @@ void __clk_reparent(struct clk *clk, struct clk *new_parent)
  */
 int clk_set_parent(struct clk *clk, struct clk *parent)
 {
+	struct clk *child;
 	int ret = 0;
 	int p_index = 0;
 	unsigned long p_rate = 0;
@@ -1733,6 +1734,18 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 		goto out;
 	}
 
+	/* check two consecutive basic mux clocks */
+	if (clk->flags & CLK_IS_BASIC_MUX) {
+		hlist_for_each_entry(child, &clk->children, child_node) {
+			if (child->flags & CLK_IS_BASIC_MUX) {
+				pr_err("%s: failed to switch parent of %s due to child mux %s\n",
+					__func__, clk->name, child->name);
+				ret = -EBUSY;
+				goto out;
+			}
+		}
+	}
+
 	/* try finding the new parent index */
 	if (parent) {
 		p_index = clk_fetch_parent_index(clk, parent);
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index 939533d..4a72620 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -30,6 +30,12 @@
 #define CLK_GET_RATE_NOCACHE	BIT(6) /* do not use the cached clk rate */
 #define CLK_SET_RATE_NO_REPARENT BIT(7) /* don't re-parent on rate change */
 #define CLK_GET_ACCURACY_NOCACHE BIT(8) /* do not use the cached clk accuracy */
+/*
+ * Basic mux clk, can't switch parent while there is another basic mux clk
+ * being its child.  Otherwise, a glitch might be propagated to downstream
+ * clocks through this child mux.
+ */
+#define CLK_IS_BASIC_MUX	BIT(8)
 
 struct clk_hw;
 
-- 
1.7.5.4

