From c0a16423cf06fbc2d0f8e118e3529629b0ebd1ad Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@freescale.com>
Date: Tue, 28 Jan 2014 19:50:27 +0800
Subject: [PATCH 0740/1074] ENGR00301290-3 usb: chipidea: enable usb for
 imx6sx

Add imx6sx compatible string, and enable bvalid as vbus wakeup
source. When vbus as system wakeup source, only bvalid can be
vbus wakeup source, the weak2p5 is needed to enable for vbus wakeup.

Signed-off-by: Peter Chen <peter.chen@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/usb/chipidea/ci_hdrc_imx.c |    6 +++
 drivers/usb/chipidea/usbmisc_imx.c |   71 ++++++++++++++++++++++++++++++++++++
 2 files changed, 77 insertions(+), 0 deletions(-)

diff --git a/drivers/usb/chipidea/ci_hdrc_imx.c b/drivers/usb/chipidea/ci_hdrc_imx.c
index 5afca2d..e118714 100644
--- a/drivers/usb/chipidea/ci_hdrc_imx.c
+++ b/drivers/usb/chipidea/ci_hdrc_imx.c
@@ -59,7 +59,13 @@ static const struct ci_hdrc_imx_platform_flag imx6sl_usb_data = {
 		CI_HDRC_IMX_HAS_HSIC,
 };
 
+static const struct ci_hdrc_imx_platform_flag imx6sx_usb_data = {
+	.flags = CI_HDRC_IMX_SUPPORT_RUNTIME_PM |
+		CI_HDRC_IMX_HAS_HSIC,
+};
+
 static const struct of_device_id ci_hdrc_imx_dt_ids[] = {
+	{ .compatible = "fsl,imx6sx-usb", .data = &imx6sx_usb_data},
 	{ .compatible = "fsl,imx6sl-usb", .data = &imx6sl_usb_data},
 	{ .compatible = "fsl,imx6q-usb", .data = &imx6q_usb_data},
 	{ .compatible = "fsl,imx28-usb", .data = &imx28_usb_data},
diff --git a/drivers/usb/chipidea/usbmisc_imx.c b/drivers/usb/chipidea/usbmisc_imx.c
index d3c9725..de6bbad 100644
--- a/drivers/usb/chipidea/usbmisc_imx.c
+++ b/drivers/usb/chipidea/usbmisc_imx.c
@@ -32,6 +32,14 @@
 #define MX53_BM_OVER_CUR_DIS_OTG	BIT(8)
 #define MX53_BM_OVER_CUR_DIS_UHx	BIT(30)
 
+#define MX6SX_USB_OTG1_PHY_CTRL		0x18
+#define MX6SX_USB_OTG2_PHY_CTRL		0x1c
+#define MX6SX_USB_VBUS_WAKEUP_SOURCE(v)	(v << 8)
+#define MX6SX_USB_VBUS_WAKEUP_SOURCE_VBUS	MX6SX_USB_VBUS_WAKEUP_SOURCE(0)
+#define MX6SX_USB_VBUS_WAKEUP_SOURCE_AVALID	MX6SX_USB_VBUS_WAKEUP_SOURCE(1)
+#define MX6SX_USB_VBUS_WAKEUP_SOURCE_BVALID	MX6SX_USB_VBUS_WAKEUP_SOURCE(2)
+#define MX6SX_USB_VBUS_WAKEUP_SOURCE_SESS_END	MX6SX_USB_VBUS_WAKEUP_SOURCE(3)
+
 #define MX6_BM_OVER_CUR_DIS		BIT(7)
 #define MX6_BM_WAKEUP_ENABLE		BIT(10)
 #define MX6_BM_UTMI_ON_CLOCK		BIT(13)
@@ -205,6 +213,58 @@ static int usbmisc_imx6q_init(struct imx_usbmisc_data *data)
 
 	return 0;
 }
+static int usbmisc_imx6sx_init(struct imx_usbmisc_data *data)
+{
+	unsigned long flags;
+	u32 val;
+	void __iomem *reg;
+
+	if (data->index > 2)
+		return -EINVAL;
+
+	if (data->disable_oc) {
+		spin_lock_irqsave(&usbmisc->lock, flags);
+		val = readl(usbmisc->base + data->index * 4);
+		writel(val | MX6_BM_OVER_CUR_DIS,
+			usbmisc->base + data->index * 4);
+		spin_unlock_irqrestore(&usbmisc->lock, flags);
+	}
+
+	/* For HSIC controller */
+	if (data->index == 2) {
+		spin_lock_irqsave(&usbmisc->lock, flags);
+		val = readl(usbmisc->base + data->index * 4);
+		writel(val | MX6_BM_UTMI_ON_CLOCK,
+			usbmisc->base + data->index * 4);
+		val = readl(usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET
+			+ (data->index - 2) * 4);
+		val |= MX6_BM_HSIC_EN | MX6_BM_HSIC_CLK_ON;
+		writel(val, usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET
+			+ (data->index - 2) * 4);
+		spin_unlock_irqrestore(&usbmisc->lock, flags);
+
+		/*
+		 * Need to add delay to wait 24M OSC to be stable,
+		 * It is board specific.
+		 */
+		regmap_read(data->anatop, ANADIG_ANA_MISC0, &val);
+		/* 0 <= data->osc_clkgate_delay <= 7 */
+		if (data->osc_clkgate_delay > ANADIG_ANA_MISC0_CLK_DELAY(val))
+			regmap_write(data->anatop, ANADIG_ANA_MISC0_SET,
+				(data->osc_clkgate_delay) << 26);
+	}
+
+	if (data->index == 0 || data->index == 1) {
+		reg = usbmisc->base + MX6SX_USB_OTG1_PHY_CTRL + data->index * 4;
+		spin_lock_irqsave(&usbmisc->lock, flags);
+		/* Set vbus wakeup source as bvalid */
+		val = readl(reg);
+		writel(val | MX6SX_USB_VBUS_WAKEUP_SOURCE_BVALID, reg);
+		spin_unlock_irqrestore(&usbmisc->lock, flags);
+	}
+
+	return 0;
+}
 
 static int usbmisc_imx6q_hsic_set_connect(struct imx_usbmisc_data *data)
 {
@@ -303,6 +363,13 @@ static const struct usbmisc_ops imx6q_usbmisc_ops = {
 	.hsic_set_clk	= usbmisc_imx6q_hsic_set_clk,
 };
 
+static const struct usbmisc_ops imx6sx_usbmisc_ops = {
+	.init = usbmisc_imx6sx_init,
+	.set_wakeup = usbmisc_imx6q_set_wakeup,
+	.hsic_set_connect = usbmisc_imx6q_hsic_set_connect,
+	.hsic_set_clk	= usbmisc_imx6q_hsic_set_clk,
+};
+
 int imx_usbmisc_init(struct imx_usbmisc_data *data)
 {
 	if (!usbmisc)
@@ -374,6 +441,10 @@ static const struct of_device_id usbmisc_imx_dt_ids[] = {
 		.compatible = "fsl,imx6q-usbmisc",
 		.data = &imx6q_usbmisc_ops,
 	},
+	{
+		.compatible = "fsl,imx6sx-usbmisc",
+		.data = &imx6sx_usbmisc_ops,
+	},
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, usbmisc_imx_dt_ids);
-- 
1.7.5.4

