From b0e4c96f3e02ebdcd719ebb83611540c0c3dfb92 Mon Sep 17 00:00:00 2001
From: Sandor Yu <R01008@freescale.com>
Date: Tue, 9 Dec 2014 15:09:20 +0800
Subject: [PATCH 0982/1074] MLK-9970: CSI: VADC image corrupted

If vadc unit test abnormal exit, such as kill -9 pid,
next time run the unit test the image corrupted.

In original implement, restore VADC specific register code in
streamoff function.
In specifical case, vadc unit test abnormal exit,
the code in streamoff function will been executed in the next run.
It is called from VIDIOC_REQBUFS.
So csi will lose vadc configuration, and image is corrupted.

Move restore VADC specific register code from streamoff function
to device close function. Issue resolved.

Signed-off-by: Sandor Yu <R01008@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 .../media/platform/mxc/capture/csi_v4l2_capture.c  |   14 ++++++++------
 1 files changed, 8 insertions(+), 6 deletions(-)

diff --git a/drivers/media/platform/mxc/capture/csi_v4l2_capture.c b/drivers/media/platform/mxc/capture/csi_v4l2_capture.c
index 2ad7385..6132a92 100644
--- a/drivers/media/platform/mxc/capture/csi_v4l2_capture.c
+++ b/drivers/media/platform/mxc/capture/csi_v4l2_capture.c
@@ -782,12 +782,6 @@ static int csi_streamoff(cam_data *cam)
 	csi_write(cam->csi_soc, 0, CSI_CSIDMASA_FB1);
 	csi_write(cam->csi_soc, 0, CSI_CSIDMASA_FB2);
 
-	if (strcmp(csi_capture_inputs[cam->current_input].name,
-		   "Vadc") == 0) {
-		csi_buf_stride_set(cam, 0);
-		csi_deinterlace_enable(cam, false);
-		csi_tvdec_enable(cam, false);
-	}
 	csi_enable(cam, 0);
 
 	csi_free_frames(cam);
@@ -1468,6 +1462,14 @@ static int csi_v4l_close(struct file *file)
 		cam->overlay_on = false;
 	}
 
+	/* restore vadc specific register to default value */
+	if (strcmp(csi_capture_inputs[cam->current_input].name,
+		   "Vadc") == 0) {
+		csi_buf_stride_set(cam, 0);
+		csi_deinterlace_enable(cam, false);
+		csi_tvdec_enable(cam, false);
+	}
+
 	if (--cam->open_count == 0) {
 		wait_event_interruptible(cam->power_queue,
 					 cam->low_power == false);
-- 
1.7.5.4

