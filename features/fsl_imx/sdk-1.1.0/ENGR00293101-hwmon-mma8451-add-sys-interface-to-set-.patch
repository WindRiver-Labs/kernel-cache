From 018042cf5cb02199cbfa2cd4d01f45ada011d4eb Mon Sep 17 00:00:00 2001
From: Luwei Zhou <b45643@freescale.com>
Date: Mon, 23 Dec 2013 14:09:25 +0800
Subject: [PATCH 0676/1074] ENGR00293101 hwmon: mma8451: add sys interface to
 set sensor scale mode.

mma8451 sensor driver on i.MX6Q/DL SabreSD/AUTO doesn't provide the
interface to set sensor scale. The new sys interface name is "scalemode".
The mode is defined as:
MODE_2G : 0, MODE_4G : 1, MODE_8G : 2

Signed-off-by: Luwei Zhou <b45643@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/hwmon/mxc_mma8451.c |   70 +++++++++++++++++++++++++++++++++++++++---
 1 files changed, 65 insertions(+), 5 deletions(-)

diff --git a/drivers/hwmon/mxc_mma8451.c b/drivers/hwmon/mxc_mma8451.c
index ddac67d..f4407bc 100644
--- a/drivers/hwmon/mxc_mma8451.c
+++ b/drivers/hwmon/mxc_mma8451.c
@@ -179,14 +179,14 @@ static int mma8451_change_mode(struct i2c_client *client, int mode)
 	result = i2c_smbus_write_byte_data(client, MMA8451_CTRL_REG1, 0);
 	if (result < 0)
 		goto out;
+	mma_status.active = MMA_STANDBY;
 
-	mma_status.mode = mode;
 	result = i2c_smbus_write_byte_data(client, MMA8451_XYZ_DATA_CFG,
-					   mma_status.mode);
+					   mode);
 	if (result < 0)
 		goto out;
-	mma_status.active = MMA_STANDBY;
 	mdelay(MODE_CHANGE_DELAY_MS);
+	mma_status.mode = mode;
 
 	return 0;
 out:
@@ -331,14 +331,74 @@ static ssize_t mma8451_position_store(struct device *dev,
 	return count;
 }
 
+static ssize_t mma8451_scalemode_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int mode = 0;
+	mutex_lock(&mma8451_lock);
+	mode = (int)mma_status.mode;
+	mutex_unlock(&mma8451_lock);
+
+	return sprintf(buf, "%d\n", mode);
+}
+
+static ssize_t mma8451_scalemode_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	unsigned long  mode;
+	int ret, active_save;
+	struct i2c_client *client = mma8451_i2c_client;
+
+	ret = strict_strtoul(buf, 10, &mode);
+	if (ret) {
+		dev_err(dev, "string transform error\n");
+		goto out;
+	}
+
+	if (mode > MODE_8G) {
+		dev_warn(dev, "not supported mode\n");
+		ret = count;
+		goto out;
+	}
+
+	mutex_lock(&mma8451_lock);
+	if (mode == mma_status.mode) {
+		ret = count;
+		goto out_unlock;
+	}
+
+	active_save = mma_status.active;
+	ret = mma8451_change_mode(client, mode);
+	if (ret)
+		goto out_unlock;
+
+	if (active_save == MMA_ACTIVED) {
+		ret = i2c_smbus_write_byte_data(client, MMA8451_CTRL_REG1, 1);
+
+		if (ret)
+			goto out_unlock;
+		mma_status.active = active_save;
+	}
+
+out_unlock:
+	mutex_unlock(&mma8451_lock);
+out:
+	return ret;
+}
+
 static DEVICE_ATTR(enable, S_IWUSR | S_IRUGO,
-		   mma8451_enable_show, mma8451_enable_store);
+			mma8451_enable_show, mma8451_enable_store);
 static DEVICE_ATTR(position, S_IWUSR | S_IRUGO,
-		   mma8451_position_show, mma8451_position_store);
+			mma8451_position_show, mma8451_position_store);
+static DEVICE_ATTR(scalemode, S_IWUSR | S_IRUGO,
+			mma8451_scalemode_show, mma8451_scalemode_store);
 
 static struct attribute *mma8451_attributes[] = {
 	&dev_attr_enable.attr,
 	&dev_attr_position.attr,
+	&dev_attr_scalemode.attr,
 	NULL
 };
 
-- 
1.7.5.4

