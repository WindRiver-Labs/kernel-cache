From a92ebbe18fabb8eae9398b30085a1703f8bfad45 Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@freescale.com>
Date: Thu, 14 Nov 2013 14:38:20 +0800
Subject: [PATCH 0616/1074] ENGR00287992-4 usb: chipidea: Add usb charger
 detect notify

- Change .notify's return value from void to int.
- Add CI_HDRC_CONTROLLER_CHARGER_EVENT and
CI_HDRC_CONTROLLER_CHARGER_POST_EVENT to finish the USB charger
detection flow.
- Add usb_gadget_vbus_connect for only notify udc when vbus
is on, the main reason we add it is we don't want the first
notification when the vbus is off, it causes the
dev->power.usage_count equals -1 when do charger detection.

Signed-off-by: Peter Chen <peter.chen@freescale.com>
[Original patch taken from git://git.freescale.com/imx/linux-2.6-imx.git]
Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 drivers/usb/chipidea/otg.c   |   18 ++++++++++++++++++
 drivers/usb/chipidea/otg.h   |    1 +
 drivers/usb/chipidea/udc.c   |   29 +++++++++++++++++++++++++++++
 include/linux/usb/chipidea.h |    5 ++++-
 4 files changed, 52 insertions(+), 1 deletions(-)

diff --git a/drivers/usb/chipidea/otg.c b/drivers/usb/chipidea/otg.c
index 54bc7c0..0b1191f 100644
--- a/drivers/usb/chipidea/otg.c
+++ b/drivers/usb/chipidea/otg.c
@@ -37,6 +37,24 @@ enum ci_role ci_otg_role(struct ci_hdrc *ci)
 	return role;
 }
 
+void ci_handle_vbus_connected(struct ci_hdrc *ci)
+{
+	u32 otgsc;
+
+	/*
+	 * TODO: if the platform does not supply 5v to udc, or use other way
+	 * to supply 5v, it needs to use other conditions to call
+	 * usb_gadget_vbus_connect.
+	 */
+	if (!ci->is_otg)
+		return;
+
+	otgsc = hw_read(ci, OP_OTGSC, ~0);
+
+	if (otgsc & OTGSC_BSV)
+		usb_gadget_vbus_connect(&ci->gadget);
+}
+
 void ci_handle_vbus_change(struct ci_hdrc *ci)
 {
 	u32 otgsc;
diff --git a/drivers/usb/chipidea/otg.h b/drivers/usb/chipidea/otg.h
index 449bee0..311d64c 100644
--- a/drivers/usb/chipidea/otg.h
+++ b/drivers/usb/chipidea/otg.h
@@ -31,5 +31,6 @@ int ci_hdrc_otg_init(struct ci_hdrc *ci);
 void ci_hdrc_otg_destroy(struct ci_hdrc *ci);
 enum ci_role ci_otg_role(struct ci_hdrc *ci);
 void ci_handle_vbus_change(struct ci_hdrc *ci);
+void ci_handle_vbus_connected(struct ci_hdrc *ci);
 
 #endif /* __DRIVERS_USB_CHIPIDEA_OTG_H */
diff --git a/drivers/usb/chipidea/udc.c b/drivers/usb/chipidea/udc.c
index 86b1fd6..0da9837 100644
--- a/drivers/usb/chipidea/udc.c
+++ b/drivers/usb/chipidea/udc.c
@@ -1470,6 +1470,7 @@ static int ci_udc_vbus_session(struct usb_gadget *_gadget, int is_active)
 	struct ci_hdrc *ci = container_of(_gadget, struct ci_hdrc, gadget);
 	unsigned long flags;
 	int gadget_ready = 0;
+	int ret;
 
 	spin_lock_irqsave(&ci->lock, flags);
 	ci->vbus_active = is_active;
@@ -1477,6 +1478,31 @@ static int ci_udc_vbus_session(struct usb_gadget *_gadget, int is_active)
 		gadget_ready = 1;
 	spin_unlock_irqrestore(&ci->lock, flags);
 
+	/* Charger Detection */
+	if (ci->platdata->notify_event) {
+		/*
+		 * Keep controller active when the cable is connected,
+		 * It can make disconnect interrupt (BSV 1->0) occur when
+		 * the cable is disconnected.
+		 */
+		if (is_active)
+			pm_runtime_get_sync(&_gadget->dev);
+		else
+			pm_runtime_put_sync(&_gadget->dev);
+
+		ret = ci->platdata->notify_event
+			(ci, CI_HDRC_CONTROLLER_CHARGER_EVENT);
+		if (ret == CI_HDRC_NOTIFY_RET_DEFER_EVENT) {
+			hw_device_reset(ci, USBMODE_CM_DC);
+			/* Pull up dp */
+			hw_write(ci, OP_USBCMD, USBCMD_RS, USBCMD_RS);
+			ci->platdata->notify_event
+				(ci, CI_HDRC_CONTROLLER_CHARGER_POST_EVENT);
+			/* Pull down dp */
+			hw_write(ci, OP_USBCMD, USBCMD_RS, 0);
+		}
+	}
+
 	if (gadget_ready) {
 		if (is_active) {
 			pm_runtime_get_sync(&_gadget->dev);
@@ -1816,6 +1842,9 @@ static int udc_start(struct ci_hdrc *ci)
 
 	pm_runtime_no_callbacks(&ci->gadget.dev);
 	pm_runtime_enable(&ci->gadget.dev);
+ 
+	/* Notify vbus connected event if it is existed */
+	ci_handle_vbus_connected(ci);
 
 	return retval;
 
diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 8c3b7e2..c75433e 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -30,7 +30,10 @@ struct ci_hdrc_platform_data {
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1
-	void	(*notify_event) (struct ci_hdrc *ci, unsigned event);
+#define CI_HDRC_CONTROLLER_CHARGER_EVENT	2
+#define CI_HDRC_CONTROLLER_CHARGER_POST_EVENT	3
+	int	(*notify_event) (struct ci_hdrc *ci, unsigned event);
+#define CI_HDRC_NOTIFY_RET_DEFER_EVENT		1
 	struct regulator	*reg_vbus;
 };
 
-- 
1.7.5.4

