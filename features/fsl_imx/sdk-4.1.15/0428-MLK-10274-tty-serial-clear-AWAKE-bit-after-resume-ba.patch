From 650f0af4c01447192eb0126a58a0c2f586296c26 Mon Sep 17 00:00:00 2001
From: Fugang Duan <b38611@freescale.com>
Date: Mon, 30 Mar 2015 10:47:23 +0800
Subject: [PATCH 0428/1691] MLK-10274 tty: serial: clear AWAKE bit after resume
 back

commit 650f0af4c01447192eb0126a58a0c2f586296c26 from
git://git.freescale.com/imx/linux-2.6-imx.git imx_4.1.15_1.0.0_ga

When uart port (non-console port) in dma mode and use uart as remote wakeup
source, after resume back, the AWAKE bit is not cleared most of interrupts
are disabled. And then let system suspend state, system resume back immediately
without any wake up action. So we need to clear the AWAKE bit after resume
back in DMA mode.

Signed-off-by: Fugang Duan <B38611@freescale.com>
(cherry picked from commit: c0a665e33dd69276a2142933354e18d4f3b20453)
---
 drivers/tty/serial/imx.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
index b3f61129..d25c78b 100644
--- a/drivers/tty/serial/imx.c
+++ b/drivers/tty/serial/imx.c
@@ -1848,6 +1848,9 @@ static int serial_imx_suspend(struct platform_device *dev, pm_message_t state)
 
 	uart_suspend_port(&imx_reg, &sport->port);
 
+	if (sport->port.irq_wake)
+		disable_irq(sport->port.irq);
+
 	/* Save necessary regs */
 	sport->saved_reg[0] = readl(sport->port.membase + UCR1);
 	sport->saved_reg[1] = readl(sport->port.membase + UCR2);
@@ -1883,6 +1886,11 @@ static int serial_imx_resume(struct platform_device *dev)
 	val = readl(sport->port.membase + UCR3);
 	val &= ~UCR3_AWAKEN;
 	writel(val, sport->port.membase + UCR3);
+	val = readl(sport->port.membase + USR1);
+	if (val & USR1_AWAKE)
+		writel(USR1_AWAKE, sport->port.membase + USR1);
+	if (sport->port.irq_wake)
+		enable_irq(sport->port.irq);
 
 	uart_resume_port(&imx_reg, &sport->port);
 
-- 
1.9.1

