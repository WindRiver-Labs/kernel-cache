From 6e9e34aeddd645b25ae4efff55305688d7778e0b Mon Sep 17 00:00:00 2001
From: Peter Chen <peter.chen@nxp.com>
Date: Mon, 1 Feb 2016 14:23:44 +0800
Subject: [PATCH 1612/1691] usb: chipidea: add system interface for ttctrl.ttha

commit 6e9e34aeddd645b25ae4efff55305688d7778e0b from
git://git.freescale.com/imx/linux-2.6-imx.git imx_4.1.15_1.0.0_ga

In chipidea IP RTL, there is a very limited design for siTD, the detail
like below:
There is no Max Packet Size at siTD, so it uses one constant for both
Max Packet Size for packet and the packet size for the last transaction
when considering schedule.
If the ttctrl.ttha does not match against Hub Address field in siTD,
this constant is 188 bytes, else this constant is 1023 bytes.

If the ttctrl.ttha is non-zero value, RTL will use 188 as this constant,
so it will lose the data if the packet size is larger than 188 bytes, eg,
if we playback a wav which format is 48khz, 16 bits, 2 channels, the
packet size will be 192bytes, but the controller will only send 188 bytes
for this packet, the noise will be heared using USB audio card.
The use case is single transaction, but higher frame rate.

If the ttctr.ttha is zero value, we can send 1023 bytes within one
transaction, but the controller will not accept the coming tranaction
if it considers the schedule time is less than 1023 bytes. So the
limitation is we can't schedule as many as transactions within frame.
If the total bytes is already 256 bytes for previous transactions within
frame, it can't accept another transaction. The use case is multiple
transactions, but less frame rate.

Signed-off-by: Peter Chen <peter.chen@kernel.org>
Signed-off-by: Peter Chen <peter.chen@nxp.com>
(cherry picked from commit 5e07ea7f812f2216263da2acd4f5e677de97fd62)
---
 drivers/usb/chipidea/core.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/drivers/usb/chipidea/core.c b/drivers/usb/chipidea/core.c
index a5936e2..3b77b04 100644
--- a/drivers/usb/chipidea/core.c
+++ b/drivers/usb/chipidea/core.c
@@ -661,6 +661,9 @@ static int ci_get_platdata(struct device *dev,
 		}
 	}
 
+	if (of_find_property(dev->of_node, "non-zero-ttctrl-ttha", NULL))
+		platdata->flags |= CI_HDRC_SET_NON_ZERO_TTHA;
+
 	if (of_find_property(dev->of_node, "ahb-burst-config", NULL)) {
 		ret = of_property_read_u32(dev->of_node, "ahb-burst-config",
 			&platdata->ahb_burst_config);
-- 
1.9.1

