From 8d8e95992367069ba48d0d7d57aa9391c77314e5 Mon Sep 17 00:00:00 2001
From: Fancy Fang <chen.fang@freescale.com>
Date: Tue, 4 Aug 2015 17:23:45 +0800
Subject: [PATCH 0079/1691] MLK-11318-5: video: mxsfb: porting mxsfb driver to
 imx_4.1.y branch

commit 8d8e95992367069ba48d0d7d57aa9391c77314e5 from
git://git.freescale.com/imx/linux-2.6-imx.git imx_4.1.15_1.0.0_ga

Porting mxsfb driver to imx_4.1.y branch.

Signed-off-by: Fancy Fang <chen.fang@freescale.com>
[Delete modifications about defconfig files]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/video/fbdev/Kconfig           |   4 +
 drivers/video/fbdev/Makefile          |   1 +
 drivers/video/fbdev/mxc/Kconfig       |  19 +
 drivers/video/fbdev/mxc/Makefile      |   1 +
 drivers/video/fbdev/mxc/crtc.h        |  57 +++
 drivers/video/fbdev/mxc/mxc_dispdrv.c | 148 ++++++
 drivers/video/fbdev/mxc/mxc_dispdrv.h |  52 ++
 drivers/video/fbdev/mxsfb.c           | 918 ++++++++++++++++++++++++++++------
 include/linux/mxcfb.h                 |  46 ++
 include/uapi/linux/mxcfb.h            | 198 ++++++++
 11 files changed, 1283 insertions(+), 162 deletions(-)
 create mode 100644 drivers/video/fbdev/mxc/Kconfig
 create mode 100644 drivers/video/fbdev/mxc/Makefile
 create mode 100644 drivers/video/fbdev/mxc/crtc.h
 create mode 100644 drivers/video/fbdev/mxc/mxc_dispdrv.c
 create mode 100644 drivers/video/fbdev/mxc/mxc_dispdrv.h
 create mode 100644 include/linux/mxcfb.h
 create mode 100644 include/uapi/linux/mxcfb.h

diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig
index d1e1e17..e5f51df 100644
--- a/drivers/video/fbdev/Kconfig
+++ b/drivers/video/fbdev/Kconfig
@@ -2455,6 +2455,10 @@ source "drivers/video/fbdev/omap2/Kconfig"
 source "drivers/video/fbdev/exynos/Kconfig"
 source "drivers/video/fbdev/mmp/Kconfig"
 
+if ARCH_MXC
+source "drivers/video/fbdev/mxc/Kconfig"
+endif
+
 config FB_SH_MOBILE_MERAM
 	tristate "SuperH Mobile MERAM read ahead support"
 	depends on (SUPERH || ARCH_SHMOBILE)
diff --git a/drivers/video/fbdev/Makefile b/drivers/video/fbdev/Makefile
index 1979aff..fe1d960 100644
--- a/drivers/video/fbdev/Makefile
+++ b/drivers/video/fbdev/Makefile
@@ -34,6 +34,7 @@ obj-$(CONFIG_FB_KYRO)             += kyro/
 obj-$(CONFIG_FB_SAVAGE)		  += savage/
 obj-$(CONFIG_FB_GEODE)		  += geode/
 obj-$(CONFIG_FB_MBX)		  += mbx/
+obj-$(CONFIG_FB_MXC)              += mxc/
 obj-$(CONFIG_FB_NEOMAGIC)         += neofb.o
 obj-$(CONFIG_FB_3DFX)             += tdfxfb.o
 obj-$(CONFIG_FB_CONTROL)          += controlfb.o
diff --git a/drivers/video/fbdev/mxc/Kconfig b/drivers/video/fbdev/mxc/Kconfig
new file mode 100644
index 0000000..e9feb18
--- /dev/null
+++ b/drivers/video/fbdev/mxc/Kconfig
@@ -0,0 +1,19 @@
+config FB_MXC
+        tristate "MXC Framebuffer support"
+        depends on FB
+        select FB_CFB_FILLRECT
+        select FB_CFB_COPYAREA
+        select FB_CFB_IMAGEBLIT
+        select FB_MODE_HELPERS
+        default y
+        help
+          This is a framebuffer device for the MXC LCD Controller.
+          See <http://www.linux-fbdev.org/> for information on framebuffer
+          devices.
+
+          If you plan to use the LCD display with your MXC system, say
+          Y here.
+
+config FB_MXC_SYNC_PANEL
+        depends on FB_MXC
+        tristate "Synchronous Panel Framebuffer"
diff --git a/drivers/video/fbdev/mxc/Makefile b/drivers/video/fbdev/mxc/Makefile
new file mode 100644
index 0000000..568574e
--- /dev/null
+++ b/drivers/video/fbdev/mxc/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_FB_MXC_SYNC_PANEL) += mxc_dispdrv.o
diff --git a/drivers/video/fbdev/mxc/crtc.h b/drivers/video/fbdev/mxc/crtc.h
new file mode 100644
index 0000000..8bd1c1b
--- /dev/null
+++ b/drivers/video/fbdev/mxc/crtc.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __CRTC__
+#define __CRTC__
+
+enum crtc {
+	CRTC_IPU_DI0,
+	CRTC_IPU_DI1,
+	CRTC_IPU1_DI0,
+	CRTC_IPU1_DI1,
+	CRTC_IPU2_DI0,
+	CRTC_IPU2_DI1,
+	CRTC_LCDIF,
+	CRTC_LCDIF1,
+	CRTC_LCDIF2,
+	CRTC_MAX,
+};
+
+struct ipu_di_crtc_map {
+	enum crtc crtc;
+	int ipu_id;
+	int ipu_di;
+};
+
+static const struct ipu_di_crtc_map ipu_di_crtc_maps[] = {
+	{CRTC_IPU1_DI0, 0 , 0}, {CRTC_IPU1_DI1, 0 , 1},
+	{CRTC_IPU2_DI0, 1 , 0}, {CRTC_IPU2_DI1, 1 , 1},
+};
+
+static inline int ipu_di_to_crtc(struct device *dev, int ipu_id,
+				 int ipu_di, enum crtc *crtc)
+{
+	int i = 0;
+
+	for (; i < ARRAY_SIZE(ipu_di_crtc_maps); i++)
+		if (ipu_di_crtc_maps[i].ipu_id == ipu_id &&
+		    ipu_di_crtc_maps[i].ipu_di == ipu_di) {
+			*crtc = ipu_di_crtc_maps[i].crtc;
+			return 0;
+		}
+
+	dev_err(dev, "failed to get valid ipu di crtc "
+		     "ipu_id %d, ipu_di %d\n", ipu_id, ipu_di);
+	return -EINVAL;
+}
+
+#endif
diff --git a/drivers/video/fbdev/mxc/mxc_dispdrv.c b/drivers/video/fbdev/mxc/mxc_dispdrv.c
new file mode 100644
index 0000000..805c1c9
--- /dev/null
+++ b/drivers/video/fbdev/mxc/mxc_dispdrv.c
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2011-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_dispdrv.c
+ * @brief mxc display driver framework.
+ *
+ * A display device driver could call mxc_dispdrv_register(drv) in its dev_probe() function.
+ * Move all dev_probe() things into mxc_dispdrv_driver->init(), init() function should init
+ * and feedback setting;
+ * Move all dev_remove() things into mxc_dispdrv_driver->deinit();
+ * Move all dev_suspend() things into fb_notifier for SUSPEND, if there is;
+ * Move all dev_resume() things into fb_notifier for RESUME, if there is;
+ *
+ * mxc fb driver could call mxc_dispdrv_gethandle(name, setting) before a fb
+ * need be added, with fbi param passing by setting, after
+ * mxc_dispdrv_gethandle() return, FB driver should get the basic setting
+ * about fbi info and crtc.
+ *
+ * @ingroup Framebuffer
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include "mxc_dispdrv.h"
+
+static LIST_HEAD(dispdrv_list);
+static DEFINE_MUTEX(dispdrv_lock);
+
+struct mxc_dispdrv_entry {
+	/* Note: drv always the first element */
+	struct mxc_dispdrv_driver *drv;
+	bool active;
+	void *priv;
+	struct list_head list;
+};
+
+struct mxc_dispdrv_handle *mxc_dispdrv_register(struct mxc_dispdrv_driver *drv)
+{
+	struct mxc_dispdrv_entry *new;
+
+	mutex_lock(&dispdrv_lock);
+
+	new = kzalloc(sizeof(struct mxc_dispdrv_entry), GFP_KERNEL);
+	if (!new) {
+		mutex_unlock(&dispdrv_lock);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	new->drv = drv;
+	list_add_tail(&new->list, &dispdrv_list);
+
+	mutex_unlock(&dispdrv_lock);
+
+	return (struct mxc_dispdrv_handle *)new;
+}
+EXPORT_SYMBOL_GPL(mxc_dispdrv_register);
+
+int mxc_dispdrv_unregister(struct mxc_dispdrv_handle *handle)
+{
+	struct mxc_dispdrv_entry *entry = (struct mxc_dispdrv_entry *)handle;
+
+	if (entry) {
+		mutex_lock(&dispdrv_lock);
+		list_del(&entry->list);
+		mutex_unlock(&dispdrv_lock);
+		kfree(entry);
+		return 0;
+	} else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(mxc_dispdrv_unregister);
+
+struct mxc_dispdrv_handle *mxc_dispdrv_gethandle(char *name,
+	struct mxc_dispdrv_setting *setting)
+{
+	int ret, found = 0;
+	struct mxc_dispdrv_entry *entry;
+
+	mutex_lock(&dispdrv_lock);
+	list_for_each_entry(entry, &dispdrv_list, list) {
+		if (!strcmp(entry->drv->name, name) && (entry->drv->init)) {
+			ret = entry->drv->init((struct mxc_dispdrv_handle *)
+				entry, setting);
+			if (ret >= 0) {
+				entry->active = true;
+				found = 1;
+				break;
+			}
+		}
+	}
+	mutex_unlock(&dispdrv_lock);
+
+	return found ? (struct mxc_dispdrv_handle *)entry:ERR_PTR(-ENODEV);
+}
+EXPORT_SYMBOL_GPL(mxc_dispdrv_gethandle);
+
+void mxc_dispdrv_puthandle(struct mxc_dispdrv_handle *handle)
+{
+	struct mxc_dispdrv_entry *entry = (struct mxc_dispdrv_entry *)handle;
+
+	mutex_lock(&dispdrv_lock);
+	if (entry && entry->active && entry->drv->deinit) {
+		entry->drv->deinit(handle);
+		entry->active = false;
+	}
+	mutex_unlock(&dispdrv_lock);
+
+}
+EXPORT_SYMBOL_GPL(mxc_dispdrv_puthandle);
+
+int mxc_dispdrv_setdata(struct mxc_dispdrv_handle *handle, void *data)
+{
+	struct mxc_dispdrv_entry *entry = (struct mxc_dispdrv_entry *)handle;
+
+	if (entry) {
+		entry->priv = data;
+		return 0;
+	} else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(mxc_dispdrv_setdata);
+
+void *mxc_dispdrv_getdata(struct mxc_dispdrv_handle *handle)
+{
+	struct mxc_dispdrv_entry *entry = (struct mxc_dispdrv_entry *)handle;
+
+	if (entry) {
+		return entry->priv;
+	} else
+		return ERR_PTR(-EINVAL);
+}
+EXPORT_SYMBOL_GPL(mxc_dispdrv_getdata);
diff --git a/drivers/video/fbdev/mxc/mxc_dispdrv.h b/drivers/video/fbdev/mxc/mxc_dispdrv.h
new file mode 100644
index 0000000..58d8a07
--- /dev/null
+++ b/drivers/video/fbdev/mxc/mxc_dispdrv.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2011-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __MXC_DISPDRV_H__
+#define __MXC_DISPDRV_H__
+#include <linux/fb.h>
+#include "crtc.h"
+
+struct mxc_dispdrv_handle {
+	struct mxc_dispdrv_driver *drv;
+};
+
+struct mxc_dispdrv_setting {
+	/*input-feedback parameter*/
+	struct fb_info *fbi;
+	int if_fmt;
+	int default_bpp;
+	char *dft_mode_str;
+
+	/* feedback parameter */
+	enum crtc crtc;
+};
+
+struct mxc_dispdrv_driver {
+	const char *name;
+	int (*init) (struct mxc_dispdrv_handle *, struct mxc_dispdrv_setting *);
+	void (*deinit) (struct mxc_dispdrv_handle *);
+	/* display driver enable function for extension */
+	int (*enable) (struct mxc_dispdrv_handle *, struct fb_info *);
+	/* display driver disable function, called at early part of fb_blank */
+	void (*disable) (struct mxc_dispdrv_handle *, struct fb_info *);
+	/* display driver setup function, called at early part of fb_set_par */
+	int (*setup) (struct mxc_dispdrv_handle *, struct fb_info *fbi);
+};
+
+struct mxc_dispdrv_handle *mxc_dispdrv_register(struct mxc_dispdrv_driver *drv);
+int mxc_dispdrv_unregister(struct mxc_dispdrv_handle *handle);
+struct mxc_dispdrv_handle *mxc_dispdrv_gethandle(char *name,
+	struct mxc_dispdrv_setting *setting);
+void mxc_dispdrv_puthandle(struct mxc_dispdrv_handle *handle);
+int mxc_dispdrv_setdata(struct mxc_dispdrv_handle *handle, void *data);
+void *mxc_dispdrv_getdata(struct mxc_dispdrv_handle *handle);
+#endif
diff --git a/drivers/video/fbdev/mxsfb.c b/drivers/video/fbdev/mxsfb.c
index 0f64165..fa95cb9 100644
--- a/drivers/video/fbdev/mxsfb.c
+++ b/drivers/video/fbdev/mxsfb.c
@@ -4,7 +4,7 @@
  * This code is based on:
  * Author: Vitaly Wool <vital@embeddedalley.com>
  *
- * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2015 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or
@@ -39,18 +39,25 @@
  * the required value in the imx_fb_videomode structure.
  */
 
+#include <linux/console.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/interrupt.h>
 #include <linux/clk.h>
 #include <linux/dma-mapping.h>
 #include <linux/io.h>
+#include <linux/pinctrl/consumer.h>
 #include <linux/fb.h>
+#include <linux/mxcfb.h>
 #include <linux/regulator/consumer.h>
 #include <video/of_display_timing.h>
-#include <video/of_videomode.h>
 #include <video/videomode.h>
+#include <linux/uaccess.h>
+
+#include "mxc/mxc_dispdrv.h"
 
 #define REG_SET	4
 #define REG_CLR	8
@@ -96,9 +103,30 @@
 #define CTRL_DF24			(1 << 1)
 #define CTRL_RUN			(1 << 0)
 
-#define CTRL1_FIFO_CLEAR		(1 << 21)
-#define CTRL1_SET_BYTE_PACKAGING(x)	(((x) & 0xf) << 16)
-#define CTRL1_GET_BYTE_PACKAGING(x)	(((x) >> 16) & 0xf)
+#define CTRL1_RECOVERY_ON_UNDERFLOW		(1 << 24)
+#define CTRL1_FIFO_CLEAR				(1 << 21)
+#define CTRL1_SET_BYTE_PACKAGING(x)		(((x) & 0xf) << 16)
+#define CTRL1_GET_BYTE_PACKAGING(x)		(((x) >> 16) & 0xf)
+#define CTRL1_OVERFLOW_IRQ_EN			(1 << 15)
+#define CTRL1_UNDERFLOW_IRQ_EN			(1 << 14)
+#define CTRL1_CUR_FRAME_DONE_IRQ_EN		(1 << 13)
+#define CTRL1_VSYNC_EDGE_IRQ_EN			(1 << 12)
+#define CTRL1_OVERFLOW_IRQ				(1 << 11)
+#define CTRL1_UNDERFLOW_IRQ				(1 << 10)
+#define CTRL1_CUR_FRAME_DONE_IRQ		(1 << 9)
+#define CTRL1_VSYNC_EDGE_IRQ			(1 << 8)
+#define CTRL1_IRQ_ENABLE_MASK			(CTRL1_OVERFLOW_IRQ_EN | \
+						 CTRL1_UNDERFLOW_IRQ_EN | \
+						 CTRL1_CUR_FRAME_DONE_IRQ_EN | \
+						 CTRL1_VSYNC_EDGE_IRQ_EN)
+#define CTRL1_IRQ_ENABLE_SHIFT			12
+#define CTRL1_IRQ_STATUS_MASK			(CTRL1_OVERFLOW_IRQ | \
+						 CTRL1_UNDERFLOW_IRQ | \
+						 CTRL1_CUR_FRAME_DONE_IRQ | \
+						 CTRL1_VSYNC_EDGE_IRQ)
+#define CTRL1_IRQ_STATUS_SHIFT			8
+
+#define CTRL2_OUTSTANDING_REQS__REQ_16		(3 << 21)
 
 #define TRANSFER_COUNT_SET_VCOUNT(x)	(((x) & 0xffff) << 16)
 #define TRANSFER_COUNT_GET_VCOUNT(x)	(((x) >> 16) & 0xffff)
@@ -149,8 +177,8 @@
 #define STMLCDIF_18BIT 2 /** pixel data bus to the display is of 18 bit width */
 #define STMLCDIF_24BIT 3 /** pixel data bus to the display is of 24 bit width */
 
-#define MXSFB_SYNC_DATA_ENABLE_HIGH_ACT	(1 << 6)
-#define MXSFB_SYNC_DOTCLK_FALLING_ACT	(1 << 7) /* negtive edge sampling */
+#define FB_SYNC_OE_LOW_ACT		0x80000000
+#define FB_SYNC_CLK_LAT_FALL	0x40000000
 
 enum mxsfb_devtype {
 	MXSFB_V3,
@@ -171,17 +199,30 @@ struct mxsfb_devdata {
 struct mxsfb_info {
 	struct fb_info fb_info;
 	struct platform_device *pdev;
-	struct clk *clk;
+	struct clk *clk_pix;
 	struct clk *clk_axi;
 	struct clk *clk_disp_axi;
+	bool clk_pix_enabled;
+	bool clk_axi_enabled;
+	bool clk_disp_axi_enabled;
 	void __iomem *base;	/* registers */
+	u32 sync;		/* record display timing polarities */
 	unsigned allocated_size;
 	int enabled;
 	unsigned ld_intf_width;
 	unsigned dotclk_delay;
 	const struct mxsfb_devdata *devdata;
-	u32 sync;
 	struct regulator *reg_lcd;
+	bool wait4vsync;
+	struct completion vsync_complete;
+	ktime_t vsync_nf_timestamp;
+	struct semaphore flip_sem;
+	int cur_blank;
+	int restore_blank;
+	char disp_dev[32];
+	struct mxc_dispdrv_handle *dispdrv;
+	int id;
+	struct fb_var_screeninfo var;
 };
 
 #define mxsfb_is_v3(host) (host->devdata->ipversion == 3)
@@ -210,6 +251,64 @@ static const struct mxsfb_devdata mxsfb_devdata[] = {
 
 #define to_imxfb_host(x) (container_of(x, struct mxsfb_info, fb_info))
 
+static int mxsfb_map_videomem(struct fb_info *info);
+static int mxsfb_unmap_videomem(struct fb_info *info);
+static int mxsfb_set_par(struct fb_info *fb_info);
+
+/* enable lcdif pix clock */
+static inline void clk_enable_pix(struct mxsfb_info *host)
+{
+	if (!host->clk_pix_enabled && (host->clk_pix != NULL)) {
+		clk_prepare_enable(host->clk_pix);
+		host->clk_pix_enabled = true;
+	}
+}
+
+/* disable lcdif pix clock */
+static inline void clk_disable_pix(struct mxsfb_info *host)
+{
+	if (host->clk_pix_enabled && (host->clk_pix != NULL)) {
+		clk_disable_unprepare(host->clk_pix);
+		host->clk_pix_enabled = false;
+	}
+}
+
+/* enable lcdif axi clock */
+static inline void clk_enable_axi(struct mxsfb_info *host)
+{
+	if (!host->clk_axi_enabled && (host->clk_axi != NULL)) {
+		clk_prepare_enable(host->clk_axi);
+		host->clk_axi_enabled = true;
+	}
+}
+
+/* disable lcdif axi clock */
+static inline void clk_disable_axi(struct mxsfb_info *host)
+{
+	if (host->clk_axi_enabled && (host->clk_axi != NULL)) {
+		clk_disable_unprepare(host->clk_axi);
+		host->clk_axi_enabled = false;
+	}
+}
+
+/* enable DISP axi clock */
+static inline void clk_enable_disp_axi(struct mxsfb_info *host)
+{
+	if (!host->clk_disp_axi_enabled && (host->clk_disp_axi != NULL)) {
+		clk_prepare_enable(host->clk_disp_axi);
+		host->clk_disp_axi_enabled = true;
+	}
+}
+
+/* disable DISP axi clock */
+static inline void clk_disable_disp_axi(struct mxsfb_info *host)
+{
+	if (host->clk_disp_axi_enabled && (host->clk_disp_axi != NULL)) {
+		clk_disable_unprepare(host->clk_disp_axi);
+		host->clk_disp_axi_enabled = false;
+	}
+}
+
 /* mask and shift depends on architecture */
 static inline u32 set_hsync_pulse_width(struct mxsfb_info *host, unsigned val)
 {
@@ -241,6 +340,24 @@ static const struct fb_bitfield def_rgb565[] = {
 	}
 };
 
+static const struct fb_bitfield def_rgb666[] = {
+	[RED] = {
+		.offset = 16,
+		.length = 6,
+	},
+	[GREEN] = {
+		.offset = 8,
+		.length = 6,
+	},
+	[BLUE] = {
+		.offset = 0,
+		.length = 6,
+	},
+	[TRANSP] = {	/* no support for transparency */
+		.length = 0,
+	}
+};
+
 static const struct fb_bitfield def_rgb888[] = {
 	[RED] = {
 		.offset = 16,
@@ -259,6 +376,19 @@ static const struct fb_bitfield def_rgb888[] = {
 	}
 };
 
+#define bitfield_is_equal(f1, f2)  (!memcmp(&(f1), &(f2), sizeof(f1)))
+
+static inline bool pixfmt_is_equal(struct fb_var_screeninfo *var,
+				   const struct fb_bitfield *f)
+{
+	if (bitfield_is_equal(var->red, f[RED]) &&
+	    bitfield_is_equal(var->green, f[GREEN]) &&
+	    bitfield_is_equal(var->blue, f[BLUE]))
+		return true;
+
+	return false;
+}
+
 static inline unsigned chan_to_field(unsigned chan, struct fb_bitfield *bf)
 {
 	chan &= 0xffff;
@@ -266,6 +396,43 @@ static inline unsigned chan_to_field(unsigned chan, struct fb_bitfield *bf)
 	return chan << bf->offset;
 }
 
+static irqreturn_t mxsfb_irq_handler(int irq, void *dev_id)
+{
+	struct mxsfb_info *host = dev_id;
+	u32 ctrl1, enable, status, acked_status;
+
+	ctrl1 = readl(host->base + LCDC_CTRL1);
+	enable = (ctrl1 & CTRL1_IRQ_ENABLE_MASK) >> CTRL1_IRQ_ENABLE_SHIFT;
+	status = (ctrl1 & CTRL1_IRQ_STATUS_MASK) >> CTRL1_IRQ_STATUS_SHIFT;
+	acked_status = (enable & status) << CTRL1_IRQ_STATUS_SHIFT;
+
+	if ((acked_status & CTRL1_VSYNC_EDGE_IRQ) && host->wait4vsync) {
+		writel(CTRL1_VSYNC_EDGE_IRQ,
+				host->base + LCDC_CTRL1 + REG_CLR);
+		writel(CTRL1_VSYNC_EDGE_IRQ_EN,
+			     host->base + LCDC_CTRL1 + REG_CLR);
+		host->wait4vsync = 0;
+		host->vsync_nf_timestamp = ktime_get();
+		complete(&host->vsync_complete);
+	}
+
+	if (acked_status & CTRL1_CUR_FRAME_DONE_IRQ) {
+		writel(CTRL1_CUR_FRAME_DONE_IRQ,
+				host->base + LCDC_CTRL1 + REG_CLR);
+		writel(CTRL1_CUR_FRAME_DONE_IRQ_EN,
+			     host->base + LCDC_CTRL1 + REG_CLR);
+		up(&host->flip_sem);
+	}
+
+	if (acked_status & CTRL1_UNDERFLOW_IRQ)
+		writel(CTRL1_UNDERFLOW_IRQ, host->base + LCDC_CTRL1 + REG_CLR);
+
+	if (acked_status & CTRL1_OVERFLOW_IRQ)
+		writel(CTRL1_OVERFLOW_IRQ, host->base + LCDC_CTRL1 + REG_CLR);
+
+	return IRQ_HANDLED;
+}
+
 static int mxsfb_check_var(struct fb_var_screeninfo *var,
 		struct fb_info *fb_info)
 {
@@ -277,9 +444,18 @@ static int mxsfb_check_var(struct fb_var_screeninfo *var,
 	if (var->yres < MIN_YRES)
 		var->yres = MIN_YRES;
 
-	var->xres_virtual = var->xres;
+	if (var->xres_virtual > var->xres) {
+		dev_dbg(fb_info->device, "stride not supported\n");
+		return -EINVAL;
+	}
 
-	var->yres_virtual = var->yres;
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+
+	if ((var->bits_per_pixel != 32) && (var->bits_per_pixel != 16))
+		var->bits_per_pixel = 32;
 
 	switch (var->bits_per_pixel) {
 	case 16:
@@ -292,7 +468,16 @@ static int mxsfb_check_var(struct fb_var_screeninfo *var,
 			pr_debug("Unsupported LCD bus width mapping\n");
 			break;
 		case STMLCDIF_16BIT:
+			/* 24 bit to 18 bit mapping */
+			rgb = def_rgb666;
+			break;
 		case STMLCDIF_18BIT:
+			if (pixfmt_is_equal(var, def_rgb666))
+				/* 24 bit to 18 bit mapping */
+				rgb = def_rgb666;
+			else
+				rgb = def_rgb888;
+			break;
 		case STMLCDIF_24BIT:
 			/* real 24 bit */
 			rgb = def_rgb888;
@@ -300,7 +485,7 @@ static int mxsfb_check_var(struct fb_var_screeninfo *var,
 		}
 		break;
 	default:
-		pr_err("Unsupported colour depth: %u\n", var->bits_per_pixel);
+		pr_debug("Unsupported colour depth: %u\n", var->bits_per_pixel);
 		return -EINVAL;
 	}
 
@@ -316,18 +501,6 @@ static int mxsfb_check_var(struct fb_var_screeninfo *var,
 	return 0;
 }
 
-static inline void mxsfb_enable_axi_clk(struct mxsfb_info *host)
-{
-	if (host->clk_axi)
-		clk_prepare_enable(host->clk_axi);
-}
-
-static inline void mxsfb_disable_axi_clk(struct mxsfb_info *host)
-{
-	if (host->clk_axi)
-		clk_disable_unprepare(host->clk_axi);
-}
-
 static void mxsfb_enable_controller(struct fb_info *fb_info)
 {
 	struct mxsfb_info *host = to_imxfb_host(fb_info);
@@ -336,6 +509,16 @@ static void mxsfb_enable_controller(struct fb_info *fb_info)
 
 	dev_dbg(&host->pdev->dev, "%s\n", __func__);
 
+	if (host->dispdrv && host->dispdrv->drv->setup) {
+		ret = host->dispdrv->drv->setup(host->dispdrv, fb_info);
+		if (ret < 0) {
+			dev_err(&host->pdev->dev, "failed to setup"
+				"dispdrv:%s\n", host->dispdrv->drv->name);
+			return;
+		}
+		host->sync = fb_info->var.sync;
+	}
+
 	if (host->reg_lcd) {
 		ret = regulator_enable(host->reg_lcd);
 		if (ret) {
@@ -345,12 +528,31 @@ static void mxsfb_enable_controller(struct fb_info *fb_info)
 		}
 	}
 
-	if (host->clk_disp_axi)
-		clk_prepare_enable(host->clk_disp_axi);
-	clk_prepare_enable(host->clk);
-	clk_set_rate(host->clk, PICOS2KHZ(fb_info->var.pixclock) * 1000U);
+	pm_runtime_get_sync(&host->pdev->dev);
 
-	mxsfb_enable_axi_clk(host);
+	/* the pixel clock should be disabled before
+	 * trying to set its clock rate successfully.
+	 */
+	clk_disable_pix(host);
+	ret = clk_set_rate(host->clk_pix,
+			 PICOS2KHZ(fb_info->var.pixclock) * 1000U);
+	if (ret) {
+		dev_err(&host->pdev->dev,
+			"lcd pixel rate set failed: %d\n", ret);
+
+		if (host->reg_lcd) {
+			ret = regulator_disable(host->reg_lcd);
+			if (ret)
+				dev_err(&host->pdev->dev,
+					"lcd regulator disable failed: %d\n",
+					ret);
+		}
+		return;
+	}
+	clk_enable_pix(host);
+
+	writel(CTRL2_OUTSTANDING_REQS__REQ_16,
+		host->base + LCDC_V4_CTRL2 + REG_SET);
 
 	/* if it was disabled, re-enable the mode again */
 	writel(CTRL_DOTCLK_MODE, host->base + LCDC_CTRL + REG_SET);
@@ -360,9 +562,20 @@ static void mxsfb_enable_controller(struct fb_info *fb_info)
 	reg |= VDCTRL4_SYNC_SIGNALS_ON;
 	writel(reg, host->base + LCDC_VDCTRL4);
 
+	writel(CTRL_MASTER, host->base + LCDC_CTRL + REG_SET);
 	writel(CTRL_RUN, host->base + LCDC_CTRL + REG_SET);
 
+	/* Recovery on underflow */
+	writel(CTRL1_RECOVERY_ON_UNDERFLOW, host->base + LCDC_CTRL1 + REG_SET);
+
 	host->enabled = 1;
+
+	if (host->dispdrv && host->dispdrv->drv->enable) {
+		ret = host->dispdrv->drv->enable(host->dispdrv, fb_info);
+		if (ret < 0)
+			dev_err(&host->pdev->dev, "failed to enable "
+				"dispdrv:%s\n", host->dispdrv->drv->name);
+	}
 }
 
 static void mxsfb_disable_controller(struct fb_info *fb_info)
@@ -374,6 +587,9 @@ static void mxsfb_disable_controller(struct fb_info *fb_info)
 
 	dev_dbg(&host->pdev->dev, "%s\n", __func__);
 
+	if (host->dispdrv && host->dispdrv->drv->disable)
+		host->dispdrv->drv->disable(host->dispdrv, fb_info);
+
 	/*
 	 * Even if we disable the controller here, it will still continue
 	 * until its FIFOs are running out of data
@@ -388,14 +604,12 @@ static void mxsfb_disable_controller(struct fb_info *fb_info)
 		loop--;
 	}
 
+	writel(CTRL_MASTER, host->base + LCDC_CTRL + REG_CLR);
+
 	reg = readl(host->base + LCDC_VDCTRL4);
 	writel(reg & ~VDCTRL4_SYNC_SIGNALS_ON, host->base + LCDC_VDCTRL4);
 
-	mxsfb_disable_axi_clk(host);
-
-	clk_disable_unprepare(host->clk);
-	if (host->clk_disp_axi)
-		clk_disable_unprepare(host->clk_disp_axi);
+	pm_runtime_put_sync_suspend(&host->pdev->dev);
 
 	host->enabled = 0;
 
@@ -407,6 +621,28 @@ static void mxsfb_disable_controller(struct fb_info *fb_info)
 	}
 }
 
+/**
+   This function compare the fb parameter see whether it was different
+   parameter for hardware, if it was different parameter, the hardware
+   will reinitialize. All will compared except x/y offset.
+ */
+static bool mxsfb_par_equal(struct fb_info *fbi, struct mxsfb_info *host)
+{
+	/* Here we set the xoffset, yoffset to zero, and compare two
+	 * var see have different or not. */
+	struct fb_var_screeninfo oldvar = host->var;
+	struct fb_var_screeninfo newvar = fbi->var;
+
+	if ((fbi->var.activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW &&
+	    fbi->var.activate & FB_ACTIVATE_FORCE)
+		return false;
+
+	oldvar.xoffset = newvar.xoffset = 0;
+	oldvar.yoffset = newvar.yoffset = 0;
+
+	return memcmp(&oldvar, &newvar, sizeof(struct fb_var_screeninfo)) == 0;
+}
+
 static int mxsfb_set_par(struct fb_info *fb_info)
 {
 	struct mxsfb_info *host = to_imxfb_host(fb_info);
@@ -414,13 +650,18 @@ static int mxsfb_set_par(struct fb_info *fb_info)
 	int line_size, fb_size;
 	int reenable = 0;
 
-	line_size =  fb_info->var.xres * (fb_info->var.bits_per_pixel >> 3);
-	fb_size = fb_info->var.yres_virtual * line_size;
+	/* If parameter no change, don't reconfigure. */
+	if (mxsfb_par_equal(fb_info, host))
+		return 0;
 
-	if (fb_size > fb_info->fix.smem_len)
-		return -ENOMEM;
+	dev_dbg(&host->pdev->dev, "%s\n", __func__);
 
-	fb_info->fix.line_length = line_size;
+	/* If fb is in blank mode, it is
+	 * unnecessary to really set par here.
+	 * It can be delayed when unblank fb
+	 */
+	if (host->cur_blank != FB_BLANK_UNBLANK)
+		return 0;
 
 	/*
 	 * It seems, you can't re-program the controller if it is still running.
@@ -432,11 +673,24 @@ static int mxsfb_set_par(struct fb_info *fb_info)
 		mxsfb_disable_controller(fb_info);
 	}
 
-	mxsfb_enable_axi_clk(host);
+	sema_init(&host->flip_sem, 1);
 
 	/* clear the FIFOs */
 	writel(CTRL1_FIFO_CLEAR, host->base + LCDC_CTRL1 + REG_SET);
 
+	line_size =  fb_info->var.xres * (fb_info->var.bits_per_pixel >> 3);
+	fb_info->fix.line_length = line_size;
+	fb_size = fb_info->var.yres_virtual * line_size;
+
+	/* Reallocate memory */
+	if (!fb_info->fix.smem_start || (fb_size > fb_info->fix.smem_len)) {
+		if (fb_info->fix.smem_start)
+			mxsfb_unmap_videomem(fb_info);
+
+		if (mxsfb_map_videomem(fb_info) < 0)
+			return -ENOMEM;
+	}
+
 	ctrl = CTRL_BYPASS_COUNT | CTRL_MASTER |
 		CTRL_SET_BUS_WIDTH(host->ld_intf_width);
 
@@ -451,12 +705,22 @@ static int mxsfb_set_par(struct fb_info *fb_info)
 		ctrl |= CTRL_SET_WORD_LENGTH(3);
 		switch (host->ld_intf_width) {
 		case STMLCDIF_8BIT:
-			mxsfb_disable_axi_clk(host);
-			dev_err(&host->pdev->dev,
+			dev_dbg(&host->pdev->dev,
 					"Unsupported LCD bus width mapping\n");
 			return -EINVAL;
 		case STMLCDIF_16BIT:
+			/* 24 bit to 18 bit mapping */
+			ctrl |= CTRL_DF24; /* ignore the upper 2 bits in
+					    *  each colour component
+					    */
+			break;
 		case STMLCDIF_18BIT:
+			if (pixfmt_is_equal(&fb_info->var, def_rgb666))
+				/* 24 bit to 18 bit mapping */
+				ctrl |= CTRL_DF24; /* ignore the upper 2 bits in
+						    *  each colour component
+						    */
+			break;
 		case STMLCDIF_24BIT:
 			/* real 24 bit */
 			break;
@@ -465,8 +729,7 @@ static int mxsfb_set_par(struct fb_info *fb_info)
 		writel(CTRL1_SET_BYTE_PACKAGING(0x7), host->base + LCDC_CTRL1);
 		break;
 	default:
-		mxsfb_disable_axi_clk(host);
-		dev_err(&host->pdev->dev, "Unhandled color depth of %u\n",
+		dev_dbg(&host->pdev->dev, "Unhandled color depth of %u\n",
 				fb_info->var.bits_per_pixel);
 		return -EINVAL;
 	}
@@ -481,13 +744,14 @@ static int mxsfb_set_par(struct fb_info *fb_info)
 		VDCTRL0_VSYNC_PERIOD_UNIT |
 		VDCTRL0_VSYNC_PULSE_WIDTH_UNIT |
 		VDCTRL0_SET_VSYNC_PULSE_WIDTH(fb_info->var.vsync_len);
-	if (fb_info->var.sync & FB_SYNC_HOR_HIGH_ACT)
+	/* use the saved sync to avoid wrong sync information */
+	if (host->sync & FB_SYNC_HOR_HIGH_ACT)
 		vdctrl0 |= VDCTRL0_HSYNC_ACT_HIGH;
-	if (fb_info->var.sync & FB_SYNC_VERT_HIGH_ACT)
+	if (host->sync & FB_SYNC_VERT_HIGH_ACT)
 		vdctrl0 |= VDCTRL0_VSYNC_ACT_HIGH;
-	if (host->sync & MXSFB_SYNC_DATA_ENABLE_HIGH_ACT)
+	if (!(host->sync & FB_SYNC_OE_LOW_ACT))
 		vdctrl0 |= VDCTRL0_ENABLE_ACT_HIGH;
-	if (host->sync & MXSFB_SYNC_DOTCLK_FALLING_ACT)
+	if (host->sync & FB_SYNC_CLK_LAT_FALL)
 		vdctrl0 |= VDCTRL0_DOTCLK_ACT_FALLING;
 
 	writel(vdctrl0, host->base + LCDC_VDCTRL0);
@@ -519,11 +783,15 @@ static int mxsfb_set_par(struct fb_info *fb_info)
 			fb_info->fix.line_length * fb_info->var.yoffset,
 			host->base + host->devdata->next_buf);
 
-	mxsfb_disable_axi_clk(host);
-
 	if (reenable)
 		mxsfb_enable_controller(fb_info);
 
+	/* Clear activate as not Reconfiguring framebuffer again */
+	if ((fb_info->var.activate & FB_ACTIVATE_FORCE) &&
+		(fb_info->var.activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW)
+		fb_info->var.activate = FB_ACTIVATE_NOW;
+
+	host->var = fb_info->var;
 	return 0;
 }
 
@@ -567,10 +835,65 @@ static int mxsfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
 	return ret;
 }
 
+static int mxsfb_wait_for_vsync(struct fb_info *fb_info)
+{
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+	int ret = 0;
+
+	if (host->cur_blank != FB_BLANK_UNBLANK) {
+		dev_err(fb_info->device, "can't wait for VSYNC when fb "
+			"is blank\n");
+		return -EINVAL;
+	}
+
+	init_completion(&host->vsync_complete);
+
+	host->wait4vsync = 1;
+	writel(CTRL1_VSYNC_EDGE_IRQ_EN,
+		host->base + LCDC_CTRL1 + REG_SET);
+	ret = wait_for_completion_interruptible_timeout(
+				&host->vsync_complete, 1 * HZ);
+	if (ret == 0) {
+		dev_err(fb_info->device,
+			"mxs wait for vsync timeout\n");
+		host->wait4vsync = 0;
+		ret = -ETIME;
+	} else if (ret > 0) {
+		ret = 0;
+	}
+	return ret;
+}
+
+static int mxsfb_ioctl(struct fb_info *fb_info, unsigned int cmd,
+			unsigned long arg)
+{
+	int ret = -EINVAL;
+
+	switch (cmd) {
+	case MXCFB_WAIT_FOR_VSYNC:
+		{
+			long long timestamp;
+			struct mxsfb_info *host = to_imxfb_host(fb_info);
+			ret = mxsfb_wait_for_vsync(fb_info);
+			timestamp = ktime_to_ns(host->vsync_nf_timestamp);
+			if ((ret == 0) && copy_to_user((void *)arg,
+				&timestamp, sizeof(timestamp))) {
+			    ret = -EFAULT;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
 static int mxsfb_blank(int blank, struct fb_info *fb_info)
 {
 	struct mxsfb_info *host = to_imxfb_host(fb_info);
 
+	host->cur_blank = blank;
+
 	switch (blank) {
 	case FB_BLANK_POWERDOWN:
 	case FB_BLANK_VSYNC_SUSPEND:
@@ -578,11 +901,24 @@ static int mxsfb_blank(int blank, struct fb_info *fb_info)
 	case FB_BLANK_NORMAL:
 		if (host->enabled)
 			mxsfb_disable_controller(fb_info);
+
+		clk_disable_disp_axi(host);
+		clk_disable_axi(host);
+		clk_disable_pix(host);
 		break;
 
 	case FB_BLANK_UNBLANK:
-		if (!host->enabled)
+		fb_info->var.activate = (fb_info->var.activate & ~FB_ACTIVATE_MASK) |
+				FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;
+		if (!host->enabled) {
+			clk_enable_pix(host);
+			clk_enable_axi(host);
+			clk_enable_disp_axi(host);
+
+			writel(0, host->base + LCDC_CTRL);
+			mxsfb_set_par(&host->fb_info);
 			mxsfb_enable_controller(fb_info);
+		}
 		break;
 	}
 	return 0;
@@ -594,18 +930,63 @@ static int mxsfb_pan_display(struct fb_var_screeninfo *var,
 	struct mxsfb_info *host = to_imxfb_host(fb_info);
 	unsigned offset;
 
-	if (var->xoffset != 0)
+	if (host->cur_blank != FB_BLANK_UNBLANK) {
+		dev_dbg(fb_info->device, "can't do pan display when fb "
+			"is blank\n");
+		return -EINVAL;
+	}
+
+	if (var->xoffset > 0) {
+		dev_dbg(fb_info->device, "x panning not supported\n");
+		return -EINVAL;
+	}
+
+	if ((var->yoffset + var->yres > var->yres_virtual)) {
+		dev_err(fb_info->device, "y panning exceeds\n");
 		return -EINVAL;
+	}
 
 	offset = fb_info->fix.line_length * var->yoffset;
 
-	mxsfb_enable_axi_clk(host);
+	if (down_timeout(&host->flip_sem, HZ / 2)) {
+		dev_err(fb_info->device, "timeout when waiting for flip irq\n");
+		return -ETIMEDOUT;
+	}
 
 	/* update on next VSYNC */
 	writel(fb_info->fix.smem_start + offset,
 			host->base + host->devdata->next_buf);
 
-	mxsfb_disable_axi_clk(host);
+	writel(CTRL1_CUR_FRAME_DONE_IRQ_EN,
+		host->base + LCDC_CTRL1 + REG_SET);
+
+	return 0;
+}
+
+static int mxsfb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+	u32 len;
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+
+	if (offset < info->fix.smem_len) {
+		/* mapping framebuffer memory */
+		len = info->fix.smem_len - offset;
+		vma->vm_pgoff = (info->fix.smem_start + offset) >> PAGE_SHIFT;
+	} else
+		return -EINVAL;
+
+	len = PAGE_ALIGN(len);
+	if (vma->vm_end - vma->vm_start > len)
+		return -EINVAL;
+
+	/* make buffers bufferable */
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+
+	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+			    vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
+		dev_dbg(info->device, "mmap remap_pfn_range failed\n");
+		return -ENOBUFS;
+	}
 
 	return 0;
 }
@@ -615,31 +996,39 @@ static struct fb_ops mxsfb_ops = {
 	.fb_check_var = mxsfb_check_var,
 	.fb_set_par = mxsfb_set_par,
 	.fb_setcolreg = mxsfb_setcolreg,
+	.fb_ioctl = mxsfb_ioctl,
 	.fb_blank = mxsfb_blank,
 	.fb_pan_display = mxsfb_pan_display,
+	.fb_mmap = mxsfb_mmap,
 	.fb_fillrect = cfb_fillrect,
 	.fb_copyarea = cfb_copyarea,
 	.fb_imageblit = cfb_imageblit,
 };
 
-static int mxsfb_restore_mode(struct mxsfb_info *host,
-			struct fb_videomode *vmode)
+static int mxsfb_restore_mode(struct mxsfb_info *host)
 {
 	struct fb_info *fb_info = &host->fb_info;
 	unsigned line_count;
 	unsigned period;
 	unsigned long pa, fbsize;
-	int bits_per_pixel, ofs, ret = 0;
+	int bits_per_pixel, ofs;
 	u32 transfer_count, vdctrl0, vdctrl2, vdctrl3, vdctrl4, ctrl;
+	struct fb_videomode vmode;
 
-	mxsfb_enable_axi_clk(host);
+	clk_enable_axi(host);
+	clk_enable_disp_axi(host);
+
+	/* Enable pixel clock earlier since in 7D
+	 * the lcdif registers should be accessed
+	 * when the pixel clock is enabled, otherwise
+	 * the bus will be hang.
+	 */
+	clk_enable_pix(host);
 
 	/* Only restore the mode when the controller is running */
 	ctrl = readl(host->base + LCDC_CTRL);
-	if (!(ctrl & CTRL_RUN)) {
-		ret = -EINVAL;
-		goto err;
-	}
+	if (!(ctrl & CTRL_RUN))
+		return -EINVAL;
 
 	vdctrl0 = readl(host->base + LCDC_VDCTRL0);
 	vdctrl2 = readl(host->base + LCDC_VDCTRL2);
@@ -648,8 +1037,8 @@ static int mxsfb_restore_mode(struct mxsfb_info *host,
 
 	transfer_count = readl(host->base + host->devdata->transfer_count);
 
-	vmode->xres = TRANSFER_COUNT_GET_HCOUNT(transfer_count);
-	vmode->yres = TRANSFER_COUNT_GET_VCOUNT(transfer_count);
+	vmode.xres = TRANSFER_COUNT_GET_HCOUNT(transfer_count);
+	vmode.yres = TRANSFER_COUNT_GET_VCOUNT(transfer_count);
 
 	switch (CTRL_GET_WORD_LENGTH(ctrl)) {
 	case 0:
@@ -657,56 +1046,51 @@ static int mxsfb_restore_mode(struct mxsfb_info *host,
 		break;
 	case 3:
 		bits_per_pixel = 32;
-		break;
 	case 1:
 	default:
-		ret = -EINVAL;
-		goto err;
+		return -EINVAL;
 	}
 
 	fb_info->var.bits_per_pixel = bits_per_pixel;
 
-	vmode->pixclock = KHZ2PICOS(clk_get_rate(host->clk) / 1000U);
-	vmode->hsync_len = get_hsync_pulse_width(host, vdctrl2);
-	vmode->left_margin = GET_HOR_WAIT_CNT(vdctrl3) - vmode->hsync_len;
-	vmode->right_margin = VDCTRL2_GET_HSYNC_PERIOD(vdctrl2) -
-		vmode->hsync_len - vmode->left_margin - vmode->xres;
-	vmode->vsync_len = VDCTRL0_GET_VSYNC_PULSE_WIDTH(vdctrl0);
+	vmode.pixclock = KHZ2PICOS(clk_get_rate(host->clk_pix) / 1000U);
+	vmode.hsync_len = get_hsync_pulse_width(host, vdctrl2);
+	vmode.left_margin = GET_HOR_WAIT_CNT(vdctrl3) - vmode.hsync_len;
+	vmode.right_margin = VDCTRL2_GET_HSYNC_PERIOD(vdctrl2) - vmode.hsync_len -
+		vmode.left_margin - vmode.xres;
+	vmode.vsync_len = VDCTRL0_GET_VSYNC_PULSE_WIDTH(vdctrl0);
 	period = readl(host->base + LCDC_VDCTRL1);
-	vmode->upper_margin = GET_VERT_WAIT_CNT(vdctrl3) - vmode->vsync_len;
-	vmode->lower_margin = period - vmode->vsync_len -
-		vmode->upper_margin - vmode->yres;
+	vmode.upper_margin = GET_VERT_WAIT_CNT(vdctrl3) - vmode.vsync_len;
+	vmode.lower_margin = period - vmode.vsync_len - vmode.upper_margin - vmode.yres;
 
-	vmode->vmode = FB_VMODE_NONINTERLACED;
+	vmode.vmode = FB_VMODE_NONINTERLACED;
 
-	vmode->sync = 0;
+	vmode.sync = 0;
 	if (vdctrl0 & VDCTRL0_HSYNC_ACT_HIGH)
-		vmode->sync |= FB_SYNC_HOR_HIGH_ACT;
+		vmode.sync |= FB_SYNC_HOR_HIGH_ACT;
 	if (vdctrl0 & VDCTRL0_VSYNC_ACT_HIGH)
-		vmode->sync |= FB_SYNC_VERT_HIGH_ACT;
+		vmode.sync |= FB_SYNC_VERT_HIGH_ACT;
 
 	pr_debug("Reconstructed video mode:\n");
 	pr_debug("%dx%d, hsync: %u left: %u, right: %u, vsync: %u, upper: %u, lower: %u\n",
-		vmode->xres, vmode->yres, vmode->hsync_len, vmode->left_margin,
-		vmode->right_margin, vmode->vsync_len, vmode->upper_margin,
-		vmode->lower_margin);
-	pr_debug("pixclk: %ldkHz\n", PICOS2KHZ(vmode->pixclock));
+			vmode.xres, vmode.yres,
+			vmode.hsync_len, vmode.left_margin, vmode.right_margin,
+			vmode.vsync_len, vmode.upper_margin, vmode.lower_margin);
+	pr_debug("pixclk: %ldkHz\n", PICOS2KHZ(vmode.pixclock));
+
+	fb_add_videomode(&vmode, &fb_info->modelist);
 
 	host->ld_intf_width = CTRL_GET_BUS_WIDTH(ctrl);
 	host->dotclk_delay = VDCTRL4_GET_DOTCLK_DLY(vdctrl4);
 
-	fb_info->fix.line_length = vmode->xres * (bits_per_pixel >> 3);
+	fb_info->fix.line_length = vmode.xres * (bits_per_pixel >> 3);
 
 	pa = readl(host->base + host->devdata->cur_buf);
-	fbsize = fb_info->fix.line_length * vmode->yres;
-	if (pa < fb_info->fix.smem_start) {
-		ret = -EINVAL;
-		goto err;
-	}
-	if (pa + fbsize > fb_info->fix.smem_start + fb_info->fix.smem_len) {
-		ret = -EINVAL;
-		goto err;
-	}
+	fbsize = fb_info->fix.line_length * vmode.yres;
+	if (pa < fb_info->fix.smem_start)
+		return -EINVAL;
+	if (pa + fbsize > fb_info->fix.smem_start + fb_info->fix.smem_len)
+		return -EINVAL;
 	ofs = pa - fb_info->fix.smem_start;
 	if (ofs) {
 		memmove(fb_info->screen_base, fb_info->screen_base + ofs, fbsize);
@@ -715,28 +1099,28 @@ static int mxsfb_restore_mode(struct mxsfb_info *host,
 
 	line_count = fb_info->fix.smem_len / fb_info->fix.line_length;
 	fb_info->fix.ypanstep = 1;
+	fb_info->fix.ywrapstep = 1;
 
-	clk_prepare_enable(host->clk);
 	host->enabled = 1;
 
-err:
-	if (ret)
-		mxsfb_disable_axi_clk(host);
-
-	return ret;
+	return 0;
 }
 
-static int mxsfb_init_fbinfo_dt(struct mxsfb_info *host,
-				struct fb_videomode *vmode)
+static int mxsfb_init_fbinfo_dt(struct mxsfb_info *host)
 {
 	struct fb_info *fb_info = &host->fb_info;
 	struct fb_var_screeninfo *var = &fb_info->var;
 	struct device *dev = &host->pdev->dev;
 	struct device_node *np = host->pdev->dev.of_node;
 	struct device_node *display_np;
-	struct videomode vm;
+	struct device_node *timings_np;
+	struct display_timings *timings;
+	const char *disp_dev;
 	u32 width;
-	int ret;
+	int i;
+	int ret = 0;
+
+	host->id = of_alias_get_id(np, "lcdif");
 
 	display_np = of_parse_phandle(np, "display", 0);
 	if (!display_np) {
@@ -776,76 +1160,189 @@ static int mxsfb_init_fbinfo_dt(struct mxsfb_info *host,
 		goto put_display_node;
 	}
 
-	ret = of_get_videomode(display_np, &vm, OF_USE_NATIVE_MODE);
-	if (ret) {
-		dev_err(dev, "failed to get videomode from DT\n");
+	ret = of_property_read_string(np, "disp-dev", &disp_dev);
+	if (!ret) {
+		memcpy(host->disp_dev, disp_dev, strlen(disp_dev));
+		/* Timing is from encoder driver */
 		goto put_display_node;
 	}
 
-	ret = fb_videomode_from_videomode(&vm, vmode);
-	if (ret < 0)
+	timings = of_get_display_timings(display_np);
+	if (!timings) {
+		dev_err(dev, "failed to get display timings\n");
+		ret = -ENOENT;
 		goto put_display_node;
+	}
+
+	timings_np = of_find_node_by_name(display_np,
+					  "display-timings");
+	if (!timings_np) {
+		dev_err(dev, "failed to find display-timings node\n");
+		ret = -ENOENT;
+		goto put_display_node;
+	}
 
-	if (vm.flags & DISPLAY_FLAGS_DE_HIGH)
-		host->sync |= MXSFB_SYNC_DATA_ENABLE_HIGH_ACT;
-	if (vm.flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE)
-		host->sync |= MXSFB_SYNC_DOTCLK_FALLING_ACT;
+	for (i = 0; i < of_get_child_count(timings_np); i++) {
+		struct videomode vm;
+		struct fb_videomode fb_vm;
+
+		ret = videomode_from_timings(timings, &vm, i);
+		if (ret < 0)
+			goto put_timings_node;
+		ret = fb_videomode_from_videomode(&vm, &fb_vm);
+		if (ret < 0)
+			goto put_timings_node;
+
+		if (!(vm.flags & DISPLAY_FLAGS_DE_HIGH))
+			fb_vm.sync |= FB_SYNC_OE_LOW_ACT;
+		if (vm.flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE)
+			fb_vm.sync |= FB_SYNC_CLK_LAT_FALL;
+		fb_add_videomode(&fb_vm, &fb_info->modelist);
+	}
 
+put_timings_node:
+	of_node_put(timings_np);
 put_display_node:
 	of_node_put(display_np);
 	return ret;
 }
 
-static int mxsfb_init_fbinfo(struct mxsfb_info *host,
-			struct fb_videomode *vmode)
+static int mxsfb_init_fbinfo(struct mxsfb_info *host)
 {
-	int ret;
 	struct fb_info *fb_info = &host->fb_info;
 	struct fb_var_screeninfo *var = &fb_info->var;
-	dma_addr_t fb_phys;
-	void *fb_virt;
-	unsigned fb_size;
+	struct fb_modelist *modelist;
+	int ret;
 
 	fb_info->fbops = &mxsfb_ops;
 	fb_info->flags = FBINFO_FLAG_DEFAULT | FBINFO_READS_FAST;
-	strlcpy(fb_info->fix.id, "mxs", sizeof(fb_info->fix.id));
 	fb_info->fix.type = FB_TYPE_PACKED_PIXELS;
 	fb_info->fix.ypanstep = 1;
+	fb_info->fix.ywrapstep = 1;
 	fb_info->fix.visual = FB_VISUAL_TRUECOLOR,
 	fb_info->fix.accel = FB_ACCEL_NONE;
 
-	ret = mxsfb_init_fbinfo_dt(host, vmode);
+	ret = mxsfb_init_fbinfo_dt(host);
 	if (ret)
 		return ret;
 
+	if (host->id < 0)
+		sprintf(fb_info->fix.id, "mxs-lcdif");
+	else
+		sprintf(fb_info->fix.id, "mxs-lcdif%d", host->id);
+
+	/* first video mode in the modelist as default video mode  */
+	modelist = list_first_entry(&fb_info->modelist,
+			struct fb_modelist, list);
+	fb_videomode_to_var(var, &modelist->mode);
+	/* save the sync value getting from dtb */
+	host->sync = fb_info->var.sync;
+
 	var->nonstd = 0;
 	var->activate = FB_ACTIVATE_NOW;
 	var->accel_flags = 0;
 	var->vmode = FB_VMODE_NONINTERLACED;
 
-	/* Memory allocation for framebuffer */
-	fb_size = SZ_2M;
-	fb_virt = alloc_pages_exact(fb_size, GFP_DMA);
-	if (!fb_virt)
-		return -ENOMEM;
+	/* init the color fields */
+	mxsfb_check_var(var, fb_info);
 
-	fb_phys = virt_to_phys(fb_virt);
+	fb_info->fix.line_length =
+		fb_info->var.xres * (fb_info->var.bits_per_pixel >> 3);
 
-	fb_info->fix.smem_start = fb_phys;
-	fb_info->screen_base = fb_virt;
-	fb_info->screen_size = fb_info->fix.smem_len = fb_size;
+	/* Memory allocation for framebuffer */
+	if (mxsfb_map_videomem(fb_info) < 0)
+		return -ENOMEM;
 
-	if (mxsfb_restore_mode(host, vmode))
-		memset(fb_virt, 0, fb_size);
+	if (mxsfb_restore_mode(host))
+		memset((char *)fb_info->screen_base, 0, fb_info->fix.smem_len);
 
 	return 0;
 }
 
+static void mxsfb_dispdrv_init(struct platform_device *pdev,
+			      struct fb_info *fbi)
+{
+	struct mxsfb_info *host = to_imxfb_host(fbi);
+	struct mxc_dispdrv_setting setting;
+	struct device *dev = &pdev->dev;
+	char disp_dev[32];
+
+	memset(&setting, 0x0, sizeof(setting));
+	setting.fbi = fbi;
+	memcpy(disp_dev, host->disp_dev, strlen(host->disp_dev));
+	disp_dev[strlen(host->disp_dev)] = '\0';
+
+	host->dispdrv = mxc_dispdrv_gethandle(disp_dev, &setting);
+	if (IS_ERR(host->dispdrv)) {
+		host->dispdrv = NULL;
+		dev_info(dev, "failed to find mxc display driver %s\n",
+			 disp_dev);
+	} else {
+		dev_info(dev, "registered mxc display driver %s\n",
+			 disp_dev);
+	}
+}
+
 static void mxsfb_free_videomem(struct mxsfb_info *host)
 {
 	struct fb_info *fb_info = &host->fb_info;
 
-	free_pages_exact(fb_info->screen_base, fb_info->fix.smem_len);
+	mxsfb_unmap_videomem(fb_info);
+}
+
+/*!
+ * Allocates the DRAM memory for the frame buffer.      This buffer is remapped
+ * into a non-cached, non-buffered, memory region to allow palette and pixel
+ * writes to occur without flushing the cache.  Once this area is remapped,
+ * all virtual memory access to the video memory should occur at the new region.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxsfb_map_videomem(struct fb_info *fbi)
+{
+	if (fbi->fix.smem_len < fbi->var.yres_virtual * fbi->fix.line_length)
+		fbi->fix.smem_len = fbi->var.yres_virtual *
+				    fbi->fix.line_length;
+
+	fbi->screen_base = dma_alloc_writecombine(fbi->device,
+				fbi->fix.smem_len,
+				(dma_addr_t *)&fbi->fix.smem_start,
+				GFP_DMA | GFP_KERNEL);
+	if (fbi->screen_base == 0) {
+		dev_err(fbi->device, "Unable to allocate framebuffer memory\n");
+		fbi->fix.smem_len = 0;
+		fbi->fix.smem_start = 0;
+		return -EBUSY;
+	}
+
+	dev_dbg(fbi->device, "allocated fb @ paddr=0x%08X, size=%d.\n",
+		(uint32_t) fbi->fix.smem_start, fbi->fix.smem_len);
+
+	fbi->screen_size = fbi->fix.smem_len;
+
+	/* Clear the screen */
+	memset((char *)fbi->screen_base, 0, fbi->fix.smem_len);
+
+	return 0;
+}
+
+/*!
+ * De-allocates the DRAM memory for the frame buffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxsfb_unmap_videomem(struct fb_info *fbi)
+{
+	dma_free_writecombine(fbi->device, fbi->fix.smem_len,
+			      fbi->screen_base, fbi->fix.smem_start);
+	fbi->screen_base = 0;
+	fbi->fix.smem_start = 0;
+	fbi->fix.smem_len = 0;
+	return 0;
 }
 
 static struct platform_device_id mxsfb_devtype[] = {
@@ -875,28 +1372,38 @@ static int mxsfb_probe(struct platform_device *pdev)
 	struct resource *res;
 	struct mxsfb_info *host;
 	struct fb_info *fb_info;
-	struct fb_videomode *mode;
+	struct pinctrl *pinctrl;
+	int irq = platform_get_irq(pdev, 0);
 	int ret;
 
 	if (of_id)
 		pdev->id_entry = of_id->data;
 
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "Cannot get memory IO resource\n");
+		return -ENODEV;
+	}
+
 	fb_info = framebuffer_alloc(sizeof(struct mxsfb_info), &pdev->dev);
 	if (!fb_info) {
 		dev_err(&pdev->dev, "Failed to allocate fbdev\n");
 		return -ENOMEM;
 	}
 
-	mode = devm_kzalloc(&pdev->dev, sizeof(struct fb_videomode),
-			GFP_KERNEL);
-	if (mode == NULL)
-		return -ENOMEM;
-
 	host = to_imxfb_host(fb_info);
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	ret = devm_request_irq(&pdev->dev, irq, mxsfb_irq_handler, 0,
+			  dev_name(&pdev->dev), host);
+	if (ret) {
+		dev_err(&pdev->dev, "request_irq (%d) failed with error %d\n",
+				irq, ret);
+		return -ENODEV;
+	}
+
 	host->base = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(host->base)) {
+		dev_err(&pdev->dev, "ioremap failed\n");
 		ret = PTR_ERR(host->base);
 		goto fb_release;
 	}
@@ -906,19 +1413,26 @@ static int mxsfb_probe(struct platform_device *pdev)
 
 	host->devdata = &mxsfb_devdata[pdev->id_entry->driver_data];
 
-	host->clk = devm_clk_get(&host->pdev->dev, NULL);
-	if (IS_ERR(host->clk)) {
-		ret = PTR_ERR(host->clk);
+	host->clk_pix = devm_clk_get(&host->pdev->dev, "pix");
+	if (IS_ERR(host->clk_pix)) {
+		host->clk_pix = NULL;
+		ret = PTR_ERR(host->clk_pix);
 		goto fb_release;
 	}
 
 	host->clk_axi = devm_clk_get(&host->pdev->dev, "axi");
-	if (IS_ERR(host->clk_axi))
+	if (IS_ERR(host->clk_axi)) {
 		host->clk_axi = NULL;
+		ret = PTR_ERR(host->clk_axi);
+		goto fb_release;
+	}
 
 	host->clk_disp_axi = devm_clk_get(&host->pdev->dev, "disp_axi");
-	if (IS_ERR(host->clk_disp_axi))
+	if (IS_ERR(host->clk_disp_axi)) {
 		host->clk_disp_axi = NULL;
+		ret = PTR_ERR(host->clk_disp_axi);
+		goto fb_release;
+	}
 
 	host->reg_lcd = devm_regulator_get(&pdev->dev, "lcd");
 	if (IS_ERR(host->reg_lcd))
@@ -931,38 +1445,58 @@ static int mxsfb_probe(struct platform_device *pdev)
 		goto fb_release;
 	}
 
-	ret = mxsfb_init_fbinfo(host, mode);
+	INIT_LIST_HEAD(&fb_info->modelist);
+
+	pm_runtime_enable(&host->pdev->dev);
+
+	ret = mxsfb_init_fbinfo(host);
 	if (ret != 0)
-		goto fb_release;
+		goto fb_pm_runtime_disable;
 
-	fb_videomode_to_var(&fb_info->var, mode);
+	mxsfb_dispdrv_init(pdev, fb_info);
 
-	/* init the color fields */
-	mxsfb_check_var(&fb_info->var, fb_info);
+	if (!host->dispdrv) {
+		pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+		if (IS_ERR(pinctrl)) {
+			ret = PTR_ERR(pinctrl);
+			goto fb_pm_runtime_disable;
+		}
+	}
 
 	platform_set_drvdata(pdev, fb_info);
 
+	if (!host->enabled) {
+		writel(0, host->base + LCDC_CTRL);
+		mxsfb_set_par(fb_info);
+		mxsfb_enable_controller(fb_info);
+	}
+
 	ret = register_framebuffer(fb_info);
 	if (ret != 0) {
-		dev_err(&pdev->dev,"Failed to register framebuffer\n");
+		dev_err(&pdev->dev, "Failed to register framebuffer\n");
 		goto fb_destroy;
 	}
 
-	if (!host->enabled) {
-		mxsfb_enable_axi_clk(host);
-		writel(0, host->base + LCDC_CTRL);
-		mxsfb_disable_axi_clk(host);
-		mxsfb_set_par(fb_info);
-		mxsfb_enable_controller(fb_info);
+	console_lock();
+	ret = fb_blank(fb_info, FB_BLANK_UNBLANK);
+	console_unlock();
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to unblank framebuffer\n");
+		goto fb_unregister;
 	}
 
 	dev_info(&pdev->dev, "initialized\n");
 
 	return 0;
 
+fb_unregister:
+	unregister_framebuffer(fb_info);
 fb_destroy:
 	if (host->enabled)
-		clk_disable_unprepare(host->clk);
+		clk_disable_unprepare(host->clk_pix);
+	fb_destroy_modelist(&fb_info->modelist);
+fb_pm_runtime_disable:
+	pm_runtime_disable(&host->pdev->dev);
 fb_release:
 	framebuffer_release(fb_info);
 
@@ -977,11 +1511,14 @@ static int mxsfb_remove(struct platform_device *pdev)
 	if (host->enabled)
 		mxsfb_disable_controller(fb_info);
 
+	pm_runtime_disable(&host->pdev->dev);
 	unregister_framebuffer(fb_info);
 	mxsfb_free_videomem(host);
 
 	framebuffer_release(fb_info);
 
+	platform_set_drvdata(pdev, NULL);
+
 	return 0;
 }
 
@@ -990,17 +1527,73 @@ static void mxsfb_shutdown(struct platform_device *pdev)
 	struct fb_info *fb_info = platform_get_drvdata(pdev);
 	struct mxsfb_info *host = to_imxfb_host(fb_info);
 
-	mxsfb_enable_axi_clk(host);
-
 	/*
 	 * Force stop the LCD controller as keeping it running during reboot
 	 * might interfere with the BootROM's boot mode pads sampling.
 	 */
-	writel(CTRL_RUN, host->base + LCDC_CTRL + REG_CLR);
+	if (host->cur_blank == FB_BLANK_UNBLANK) {
+		writel(CTRL_RUN, host->base + LCDC_CTRL + REG_CLR);
+		writel(CTRL_MASTER, host->base + LCDC_CTRL + REG_CLR);
+	}
+}
+
+#ifdef CONFIG_PM_RUNTIME
+static int mxsfb_runtime_suspend(struct device *dev)
+{
+	dev_dbg(dev, "mxsfb busfreq high release.\n");
+
+	return 0;
+}
+
+static int mxsfb_runtime_resume(struct device *dev)
+{
+	dev_dbg(dev, "mxsfb busfreq high request.\n");
 
-	mxsfb_disable_axi_clk(host);
+	return 0;
+}
+#else
+#define	mxsfb_runtime_suspend	NULL
+#define	mxsfb_runtime_resume	NULL
+#endif
+
+#ifdef CONFIG_PM
+static int mxsfb_suspend(struct device *pdev)
+{
+	struct fb_info *fb_info = dev_get_drvdata(pdev);
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+	int saved_blank;
+
+	console_lock();
+	fb_set_suspend(fb_info, 1);
+	saved_blank = host->cur_blank;
+	mxsfb_blank(FB_BLANK_POWERDOWN, fb_info);
+	host->restore_blank = saved_blank;
+	console_unlock();
+	return 0;
 }
 
+static int mxsfb_resume(struct device *pdev)
+{
+	struct fb_info *fb_info = dev_get_drvdata(pdev);
+	struct mxsfb_info *host = to_imxfb_host(fb_info);
+
+	console_lock();
+	mxsfb_blank(host->restore_blank, fb_info);
+	fb_set_suspend(fb_info, 0);
+	console_unlock();
+
+	return 0;
+}
+#else
+#define	mxsfb_suspend	NULL
+#define	mxsfb_resume	NULL
+#endif
+
+static const struct dev_pm_ops mxsfb_pm_ops = {
+	SET_RUNTIME_PM_OPS(mxsfb_runtime_suspend, mxsfb_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(mxsfb_suspend, mxsfb_resume)
+};
+
 static struct platform_driver mxsfb_driver = {
 	.probe = mxsfb_probe,
 	.remove = mxsfb_remove,
@@ -1009,6 +1602,7 @@ static struct platform_driver mxsfb_driver = {
 	.driver = {
 		   .name = DRIVER_NAME,
 		   .of_match_table = mxsfb_dt_ids,
+		   .pm = &mxsfb_pm_ops,
 	},
 };
 
diff --git a/include/linux/mxcfb.h b/include/linux/mxcfb.h
new file mode 100644
index 0000000..67db5ee
--- /dev/null
+++ b/include/linux/mxcfb.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*
+ * @file linux/mxcfb.h
+ *
+ * @brief Global header file for the MXC Frame buffer
+ *
+ * @ingroup Framebuffer
+ */
+#ifndef __LINUX_MXCFB_H__
+#define __LINUX_MXCFB_H__
+
+#include <uapi/linux/mxcfb.h>
+
+extern struct fb_videomode mxcfb_modedb[];
+extern int mxcfb_modedb_sz;
+
+enum {
+	MXC_DISP_SPEC_DEV = 0,
+	MXC_DISP_DDC_DEV = 1,
+};
+
+enum {
+	MXCFB_REFRESH_OFF,
+	MXCFB_REFRESH_AUTO,
+	MXCFB_REFRESH_PARTIAL,
+};
+
+int mxcfb_set_refresh_mode(struct fb_info *fbi, int mode,
+			   struct mxcfb_rect *update_region);
+int mxc_elcdif_frame_addr_setup(dma_addr_t phys);
+void mxcfb_elcdif_register_mode(const struct fb_videomode *modedb,
+		int num_modes, int dev_mode);
+
+#endif
diff --git a/include/uapi/linux/mxcfb.h b/include/uapi/linux/mxcfb.h
new file mode 100644
index 0000000..3a98409
--- /dev/null
+++ b/include/uapi/linux/mxcfb.h
@@ -0,0 +1,198 @@
+/*
+ * Copyright (C) 2013-2015 Freescale Semiconductor, Inc. All Rights Reserved
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*
+ * @file uapi/linux/mxcfb.h
+ *
+ * @brief Global header file for the MXC frame buffer
+ *
+ * @ingroup Framebuffer
+ */
+#ifndef __ASM_ARCH_MXCFB_H__
+#define __ASM_ARCH_MXCFB_H__
+
+#include <linux/fb.h>
+
+#define FB_SYNC_OE_LOW_ACT	0x80000000
+#define FB_SYNC_CLK_LAT_FALL	0x40000000
+#define FB_SYNC_DATA_INVERT	0x20000000
+#define FB_SYNC_CLK_IDLE_EN	0x10000000
+#define FB_SYNC_SHARP_MODE	0x08000000
+#define FB_SYNC_SWAP_RGB	0x04000000
+#define FB_ACCEL_TRIPLE_FLAG	0x00000000
+#define FB_ACCEL_DOUBLE_FLAG	0x00000001
+
+struct mxcfb_gbl_alpha {
+	int enable;
+	int alpha;
+};
+
+struct mxcfb_loc_alpha {
+	int enable;
+	int alpha_in_pixel;
+	unsigned long alpha_phy_addr0;
+	unsigned long alpha_phy_addr1;
+};
+
+struct mxcfb_color_key {
+	int enable;
+	__u32 color_key;
+};
+
+struct mxcfb_pos {
+	__u16 x;
+	__u16 y;
+};
+
+struct mxcfb_gamma {
+	int enable;
+	int constk[16];
+	int slopek[16];
+};
+
+struct mxcfb_gpu_split_fmt {
+	struct fb_var_screeninfo var;
+	unsigned long offset;
+};
+
+struct mxcfb_rect {
+	__u32 top;
+	__u32 left;
+	__u32 width;
+	__u32 height;
+};
+
+#define GRAYSCALE_8BIT				0x1
+#define GRAYSCALE_8BIT_INVERTED			0x2
+#define GRAYSCALE_4BIT                          0x3
+#define GRAYSCALE_4BIT_INVERTED                 0x4
+
+#define AUTO_UPDATE_MODE_REGION_MODE		0
+#define AUTO_UPDATE_MODE_AUTOMATIC_MODE		1
+
+#define UPDATE_SCHEME_SNAPSHOT			0
+#define UPDATE_SCHEME_QUEUE			1
+#define UPDATE_SCHEME_QUEUE_AND_MERGE		2
+
+#define UPDATE_MODE_PARTIAL			0x0
+#define UPDATE_MODE_FULL			0x1
+
+#define WAVEFORM_MODE_GLR16			4
+#define WAVEFORM_MODE_GLD16			5
+#define WAVEFORM_MODE_AUTO			257
+
+#define TEMP_USE_AMBIENT			0x1000
+
+#define EPDC_FLAG_ENABLE_INVERSION		0x01
+#define EPDC_FLAG_FORCE_MONOCHROME		0x02
+#define EPDC_FLAG_USE_CMAP			0x04
+#define EPDC_FLAG_USE_ALT_BUFFER		0x100
+#define EPDC_FLAG_TEST_COLLISION		0x200
+#define EPDC_FLAG_GROUP_UPDATE			0x400
+#define EPDC_FLAG_USE_DITHERING_Y1		0x2000
+#define EPDC_FLAG_USE_DITHERING_Y4		0x4000
+#define EPDC_FLAG_USE_REGAL				0x8000
+
+enum mxcfb_dithering_mode {
+	EPDC_FLAG_USE_DITHERING_PASSTHROUGH = 0x0,
+	EPDC_FLAG_USE_DITHERING_FLOYD_STEINBERG,
+	EPDC_FLAG_USE_DITHERING_ATKINSON,
+	EPDC_FLAG_USE_DITHERING_ORDERED,
+	EPDC_FLAG_USE_DITHERING_QUANT_ONLY,
+	EPDC_FLAG_USE_DITHERING_MAX,
+};
+
+#define FB_POWERDOWN_DISABLE			-1
+
+struct mxcfb_alt_buffer_data {
+	__u32 phys_addr;
+	__u32 width;	/* width of entire buffer */
+	__u32 height;	/* height of entire buffer */
+	struct mxcfb_rect alt_update_region;	/* region within buffer to update */
+};
+
+struct mxcfb_update_data {
+	struct mxcfb_rect update_region;
+	__u32 waveform_mode;
+	__u32 update_mode;
+	__u32 update_marker;
+	int temp;
+	unsigned int flags;
+	int dither_mode;
+	int quant_bit;
+	struct mxcfb_alt_buffer_data alt_buffer_data;
+};
+
+struct mxcfb_update_marker_data {
+	__u32 update_marker;
+	__u32 collision_test;
+};
+
+/*
+ * Structure used to define waveform modes for driver
+ * Needed for driver to perform auto-waveform selection
+ */
+struct mxcfb_waveform_modes {
+	int mode_init;
+	int mode_du;
+	int mode_gc4;
+	int mode_gc8;
+	int mode_gc16;
+	int mode_gc32;
+};
+
+/*
+ * Structure used to define a 5*3 matrix of parameters for
+ * setting IPU DP CSC module related to this framebuffer.
+ */
+struct mxcfb_csc_matrix {
+	int param[5][3];
+};
+
+#define MXCFB_WAIT_FOR_VSYNC	_IOW('F', 0x20, u_int32_t)
+#define MXCFB_SET_GBL_ALPHA     _IOW('F', 0x21, struct mxcfb_gbl_alpha)
+#define MXCFB_SET_CLR_KEY       _IOW('F', 0x22, struct mxcfb_color_key)
+#define MXCFB_SET_OVERLAY_POS   _IOWR('F', 0x24, struct mxcfb_pos)
+#define MXCFB_GET_FB_IPU_CHAN 	_IOR('F', 0x25, u_int32_t)
+#define MXCFB_SET_LOC_ALPHA     _IOWR('F', 0x26, struct mxcfb_loc_alpha)
+#define MXCFB_SET_LOC_ALP_BUF    _IOW('F', 0x27, unsigned long)
+#define MXCFB_SET_GAMMA	       _IOW('F', 0x28, struct mxcfb_gamma)
+#define MXCFB_GET_FB_IPU_DI 	_IOR('F', 0x29, u_int32_t)
+#define MXCFB_GET_DIFMT	       _IOR('F', 0x2A, u_int32_t)
+#define MXCFB_GET_FB_BLANK     _IOR('F', 0x2B, u_int32_t)
+#define MXCFB_SET_DIFMT		_IOW('F', 0x2C, u_int32_t)
+#define MXCFB_CSC_UPDATE	_IOW('F', 0x2D, struct mxcfb_csc_matrix)
+#define MXCFB_SET_GPU_SPLIT_FMT	_IOW('F', 0x2F, struct mxcfb_gpu_split_fmt)
+#define MXCFB_SET_PREFETCH	_IOW('F', 0x30, int)
+#define MXCFB_GET_PREFETCH	_IOR('F', 0x31, int)
+
+/* IOCTLs for E-ink panel updates */
+#define MXCFB_SET_WAVEFORM_MODES	_IOW('F', 0x2B, struct mxcfb_waveform_modes)
+#define MXCFB_SET_TEMPERATURE		_IOW('F', 0x2C, int32_t)
+#define MXCFB_SET_AUTO_UPDATE_MODE	_IOW('F', 0x2D, __u32)
+#define MXCFB_SEND_UPDATE		_IOW('F', 0x2E, struct mxcfb_update_data)
+#define MXCFB_WAIT_FOR_UPDATE_COMPLETE	_IOWR('F', 0x2F, struct mxcfb_update_marker_data)
+#define MXCFB_SET_PWRDOWN_DELAY		_IOW('F', 0x30, int32_t)
+#define MXCFB_GET_PWRDOWN_DELAY		_IOR('F', 0x31, int32_t)
+#define MXCFB_SET_UPDATE_SCHEME		_IOW('F', 0x32, __u32)
+#define MXCFB_GET_WORK_BUFFER		_IOWR('F', 0x34, unsigned long)
+#define MXCFB_DISABLE_EPDC_ACCESS	_IO('F', 0x35)
+#define MXCFB_ENABLE_EPDC_ACCESS	_IO('F', 0x36)
+#endif
-- 
1.9.1

