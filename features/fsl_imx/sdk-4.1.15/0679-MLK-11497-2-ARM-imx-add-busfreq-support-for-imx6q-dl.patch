From 1fa181af22b39cc6755acc4ac5a4f40182acc3b4 Mon Sep 17 00:00:00 2001
From: Anson Huang <b20788@freescale.com>
Date: Sun, 6 Sep 2015 13:36:55 +0800
Subject: [PATCH 0679/1691] MLK-11497-2 ARM: imx: add busfreq support for
 imx6q/dl

commit 1fa181af22b39cc6755acc4ac5a4f40182acc3b4 from
git://git.freescale.com/imx/linux-2.6-imx.git imx_4.1.15_1.0.0_ga

Add busfreq support for i.MX6Q/DL, 3 setpoints supported:

HIGH: MMDC = 528MHz on i.MX6Q, = 396MHz on i.MX6DL; AHB = AXI = 24MHz;
AUDIO: MMDC = 50MHz, AXI = 50MHz, AHB = 25MHz;
LOW: MMDC = AXI = AHB = 24MHz.

Signed-off-by: Anson Huang <b20788@freescale.com>
---
 arch/arm/mach-imx/Makefile         |    3 +-
 arch/arm/mach-imx/busfreq-imx.c    |  119 +++-
 arch/arm/mach-imx/busfreq_ddr3.c   |  276 ++++++++-
 arch/arm/mach-imx/ddr3_freq_imx6.S | 1156 ++++++++++++++++++++++++++++++++++++
 arch/arm/mach-imx/mach-imx6q.c     |    1 +
 arch/arm/mach-imx/platsmp.c        |    2 +-
 6 files changed, 1535 insertions(+), 22 deletions(-)
 create mode 100644 arch/arm/mach-imx/ddr3_freq_imx6.S

diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile
index 0f26412..ebdaea4 100644
--- a/arch/arm/mach-imx/Makefile
+++ b/arch/arm/mach-imx/Makefile
@@ -92,7 +92,8 @@ AFLAGS_headsmp.o :=-Wa,-march=armv7-a
 obj-$(CONFIG_SMP) += headsmp.o platsmp.o
 obj-$(CONFIG_HOTPLUG_CPU) += hotplug.o
 endif
-obj-$(CONFIG_SOC_IMX6Q) += clk-imx6q.o mach-imx6q.o
+AFLAGS_ddr3_freq_imx6.o :=-Wa,-march=armv7-a
+obj-$(CONFIG_SOC_IMX6Q) += clk-imx6q.o mach-imx6q.o ddr3_freq_imx6.o
 obj-$(CONFIG_SOC_IMX6SL) += clk-imx6sl.o mach-imx6sl.o
 AFLAGS_ddr3_freq_imx6sx.o :=-Wa,-march=armv7-a
 AFLAGS_lpddr2_freq_imx6sx.o :=-Wa,-march=armv7-a
diff --git a/arch/arm/mach-imx/busfreq-imx.c b/arch/arm/mach-imx/busfreq-imx.c
index 9abda65..e40175c 100644
--- a/arch/arm/mach-imx/busfreq-imx.c
+++ b/arch/arm/mach-imx/busfreq-imx.c
@@ -65,6 +65,7 @@ extern int unsigned long iram_tlb_base_addr;
 
 extern int init_mmdc_lpddr2_settings(struct platform_device *dev);
 extern int init_mmdc_ddr3_settings_imx6_up(struct platform_device *dev);
+extern int init_mmdc_ddr3_settings_imx6_smp(struct platform_device *dev);
 extern int init_ddrc_ddr_settings(struct platform_device *dev);
 extern int update_ddr_freq_imx_smp(int ddr_rate);
 extern int update_ddr_freq_imx6_up(int ddr_rate);
@@ -102,6 +103,8 @@ static struct clk *periph2_clk;
 static struct clk *periph2_pre_clk;
 static struct clk *periph2_clk2_clk;
 static struct clk *periph2_clk2_sel_clk;
+static struct clk *axi_alt_sel_clk;
+static struct clk *pll3_pfd1_540m_clk;
 
 static struct delayed_work low_bus_freq_handler;
 static struct delayed_work bus_freq_daemon;
@@ -200,6 +203,37 @@ static void enter_lpm_imx6_up(void)
 	}
 }
 
+static void enter_lpm_imx6_smp(void)
+{
+	if (cpu_is_imx6dl())
+		/* Set axi to periph_clk */
+		imx_clk_set_parent(axi_sel_clk, periph_clk);
+
+	if (audio_bus_count) {
+		/* Need to ensure that PLL2_PFD_400M is kept ON. */
+		clk_prepare_enable(pll2_400_clk);
+		update_ddr_freq_imx_smp(LOW_AUDIO_CLK);
+		/* Make sure periph clk's parent also got updated */
+		imx_clk_set_parent(periph_clk2_sel_clk, pll3_clk);
+		imx_clk_set_parent(periph_pre_clk, pll2_200_clk);
+		imx_clk_set_parent(periph_clk, periph_pre_clk);
+		audio_bus_freq_mode = 1;
+		low_bus_freq_mode = 0;
+		cur_bus_freq_mode = BUS_FREQ_AUDIO;
+	} else {
+		update_ddr_freq_imx_smp(LPAPM_CLK);
+		/* Make sure periph clk's parent also got updated */
+		imx_clk_set_parent(periph_clk2_sel_clk, osc_clk);
+		/* Set periph_clk parent to OSC via periph_clk2_sel */
+		imx_clk_set_parent(periph_clk, periph_clk2_clk);
+		if (audio_bus_freq_mode)
+			clk_disable_unprepare(pll2_400_clk);
+		low_bus_freq_mode = 1;
+		audio_bus_freq_mode = 0;
+		cur_bus_freq_mode = BUS_FREQ_LOW;
+	}
+}
+
 static void exit_lpm_imx6_up(void)
 {
 	clk_prepare_enable(pll2_400_clk);
@@ -251,6 +285,31 @@ static void exit_lpm_imx6_up(void)
 		clk_disable_unprepare(pll2_400_clk);
 }
 
+static void exit_lpm_imx6_smp(void)
+{
+	struct clk *periph_clk_parent;
+
+	if (cpu_is_imx6q())
+		periph_clk_parent = pll2_bus_clk;
+	else
+		periph_clk_parent = pll2_400_clk;
+
+	clk_prepare_enable(pll2_400_clk);
+	update_ddr_freq_imx_smp(ddr_normal_rate);
+	/* Make sure periph clk's parent also got updated */
+	imx_clk_set_parent(periph_clk2_sel_clk, pll3_clk);
+	imx_clk_set_parent(periph_pre_clk, periph_clk_parent);
+	imx_clk_set_parent(periph_clk, periph_pre_clk);
+	if (cpu_is_imx6dl()) {
+		/* Set axi to pll3_pfd1_540m */
+		imx_clk_set_parent(axi_alt_sel_clk, pll3_pfd1_540m_clk);
+		imx_clk_set_parent(axi_sel_clk, axi_alt_sel_clk);
+	}
+	clk_disable_unprepare(pll2_400_clk);
+	if (audio_bus_freq_mode)
+		clk_disable_unprepare(pll2_400_clk);
+}
+
 static void enter_lpm_imx7d(void)
 {
 	if (audio_bus_count) {
@@ -309,6 +368,8 @@ static void reduce_bus_freq(void)
 		enter_lpm_imx7d();
 	else if (cpu_is_imx6sx() || cpu_is_imx6ul())
 		enter_lpm_imx6_up();
+	else if (cpu_is_imx6q() || cpu_is_imx6dl())
+		enter_lpm_imx6_smp();
 
 	med_bus_freq_mode = 0;
 	high_bus_freq_mode = 0;
@@ -372,19 +433,12 @@ int set_low_bus_freq(void)
  */
 static int set_high_bus_freq(int high_bus_freq)
 {
-	struct clk *periph_clk_parent;
-
 	if (bus_freq_scaling_initialized && bus_freq_scaling_is_active)
 		cancel_delayed_work_sync(&low_bus_freq_handler);
 
 	if (busfreq_suspended)
 		return 0;
 
-	if (cpu_is_imx6q())
-		periph_clk_parent = pll2_bus_clk;
-	else
-		periph_clk_parent = pll2_400_clk;
-
 	if (!bus_freq_scaling_initialized || !bus_freq_scaling_is_active)
 		return 0;
 
@@ -405,6 +459,8 @@ static int set_high_bus_freq(int high_bus_freq)
 		exit_lpm_imx7d();
 	else if (cpu_is_imx6sx() || cpu_is_imx6ul())
 		exit_lpm_imx6_up();
+	else if (cpu_is_imx6q() || cpu_is_imx6dl())
+		exit_lpm_imx6_smp();
 
 	high_bus_freq_mode = 1;
 	med_bus_freq_mode = 0;
@@ -720,25 +776,52 @@ static int busfreq_probe(struct platform_device *pdev)
 	if (!ddr_freq_change_iram_base)
 		return -ENOMEM;
 
-	if (cpu_is_imx6sx()) {
-		m4_clk = devm_clk_get(&pdev->dev, "m4");
-		arm_clk = devm_clk_get(&pdev->dev, "arm");
+	if (cpu_is_imx6q() || cpu_is_imx6dl() || cpu_is_imx6sx()) {
 		osc_clk = devm_clk_get(&pdev->dev, "osc");
-		ahb_clk = devm_clk_get(&pdev->dev, "ahb");
-		pll3_clk = devm_clk_get(&pdev->dev, "pll3_usb_otg");
-		step_clk = devm_clk_get(&pdev->dev, "step");
-		mmdc_clk = devm_clk_get(&pdev->dev, "mmdc");
-		ocram_clk = devm_clk_get(&pdev->dev, "ocram");
 		pll2_400_clk = devm_clk_get(&pdev->dev, "pll2_pfd2_396m");
 		pll2_200_clk = devm_clk_get(&pdev->dev, "pll2_198m");
 		pll2_bus_clk = devm_clk_get(&pdev->dev, "pll2_bus");
+		arm_clk = devm_clk_get(&pdev->dev, "arm");
+		pll3_clk = devm_clk_get(&pdev->dev, "pll3_usb_otg");
 		periph_clk = devm_clk_get(&pdev->dev, "periph");
 		periph_pre_clk = devm_clk_get(&pdev->dev, "periph_pre");
 		periph_clk2_clk = devm_clk_get(&pdev->dev, "periph_clk2");
+		periph_clk2_sel_clk = devm_clk_get(&pdev->dev,
+			"periph_clk2_sel");
+
+		if (IS_ERR(osc_clk) || IS_ERR(pll2_400_clk)
+			|| IS_ERR(pll2_200_clk) || IS_ERR(pll2_bus_clk)
+			|| IS_ERR(arm_clk) || IS_ERR(pll3_clk)
+			|| IS_ERR(periph_clk) || IS_ERR(periph_pre_clk)
+			|| IS_ERR(periph_clk2_clk)
+			|| IS_ERR(periph_clk2_sel_clk)) {
+			dev_err(busfreq_dev,
+				"%s: failed to get busfreq clk\n", __func__);
+			return -EINVAL;
+		}
+	}
+
+	if (cpu_is_imx6dl()) {
+		axi_alt_sel_clk = devm_clk_get(&pdev->dev, "axi_alt_sel");
+		axi_sel_clk = devm_clk_get(&pdev->dev, "axi_sel");
+		pll3_pfd1_540m_clk = devm_clk_get(&pdev->dev, "pll3_pfd1_540m");
+		if (IS_ERR(axi_alt_sel_clk) || IS_ERR(axi_sel_clk)
+			|| IS_ERR(pll3_pfd1_540m_clk)) {
+			dev_err(busfreq_dev,
+				"%s: failed to get busfreq clk\n", __func__);
+			return -EINVAL;
+		}
+	}
+
+	if (cpu_is_imx6sx()) {
+		m4_clk = devm_clk_get(&pdev->dev, "m4");
+		ahb_clk = devm_clk_get(&pdev->dev, "ahb");
+		step_clk = devm_clk_get(&pdev->dev, "step");
+		mmdc_clk = devm_clk_get(&pdev->dev, "mmdc");
+		ocram_clk = devm_clk_get(&pdev->dev, "ocram");
+		periph_clk2_clk = devm_clk_get(&pdev->dev, "periph_clk2");
 		periph_clk2_sel_clk =
 			devm_clk_get(&pdev->dev, "periph_clk2_sel");
-		periph2_clk = devm_clk_get(&pdev->dev, "periph2");
-		periph2_pre_clk = devm_clk_get(&pdev->dev, "periph2_pre");
 		periph2_clk2_clk = devm_clk_get(&pdev->dev, "periph2_clk2");
 		periph2_clk2_sel_clk =
 			devm_clk_get(&pdev->dev, "periph2_clk2_sel");
@@ -850,6 +933,8 @@ static int busfreq_probe(struct platform_device *pdev)
 		if (imx_src_is_m4_enabled() &&
 			(clk_get_rate(m4_clk) > LPAPM_CLK))
 				high_bus_count++;
+	} else if (cpu_is_imx6q() || cpu_is_imx6dl()) {
+		err = init_mmdc_ddr3_settings_imx6_smp(pdev);
 	}
 
 	if (err) {
diff --git a/arch/arm/mach-imx/busfreq_ddr3.c b/arch/arm/mach-imx/busfreq_ddr3.c
index 4a08a64..0f058f9 100644
--- a/arch/arm/mach-imx/busfreq_ddr3.c
+++ b/arch/arm/mach-imx/busfreq_ddr3.c
@@ -93,6 +93,9 @@ void (*imx7d_change_ddr_freq)(u32 freq) = NULL;
 extern void imx7d_ddr3_freq_change(u32 freq);
 extern void imx_lpddr3_freq_change(u32 freq);
 
+void (*mx6_change_ddr_freq)(u32 freq, void *ddr_settings,
+	bool dll_mode, void *iomux_offsets) = NULL;
+
 extern unsigned int ddr_normal_rate;
 extern int low_bus_freq_mode;
 extern int audio_bus_freq_mode;
@@ -112,6 +115,7 @@ extern unsigned long imx6_up_ddr3_freq_change_start asm("imx6_up_ddr3_freq_chang
 extern unsigned long imx6_up_ddr3_freq_change_end asm("imx6_up_ddr3_freq_change_end");
 
 #ifdef CONFIG_SMP
+static unsigned long wfe_freq_change_iram_base;
 volatile u32 *wait_for_ddr_freq_update;
 static unsigned int online_cpus;
 static u32 *irqs_used;
@@ -123,6 +127,7 @@ extern void imx7_smp_wfe(u32 cpuid, u32 ocram_base);
 extern unsigned long wfe_ddr3_freq_change_start
 	asm("wfe_ddr3_freq_change_start");
 extern unsigned long wfe_ddr3_freq_change_end asm("wfe_ddr3_freq_change_end");
+extern void __iomem *imx_scu_base;
 #endif
 
 unsigned long ddr3_dll_mx6sx[][2] = {
@@ -154,6 +159,59 @@ unsigned long iomux_offsets_mx6ul[][2] = {
 	{0x284, 0x0},
 };
 
+unsigned long ddr3_dll_mx6q[][2] = {
+	{0x0c, 0x0},
+	{0x10, 0x0},
+	{0x1C, 0x04088032},
+	{0x1C, 0x0408803a},
+	{0x1C, 0x08408030},
+	{0x1C, 0x08408038},
+	{0x818, 0x0},
+};
+
+unsigned long ddr3_calibration[][2] = {
+	{0x83c, 0x0},
+	{0x840, 0x0},
+	{0x483c, 0x0},
+	{0x4840, 0x0},
+	{0x848, 0x0},
+	{0x4848, 0x0},
+	{0x850, 0x0},
+	{0x4850, 0x0},
+};
+
+unsigned long iomux_offsets_mx6q[][2] = {
+	{0x5A8, 0x0},
+	{0x5B0, 0x0},
+	{0x524, 0x0},
+	{0x51C, 0x0},
+	{0x518, 0x0},
+	{0x50C, 0x0},
+	{0x5B8, 0x0},
+	{0x5C0, 0x0},
+};
+
+unsigned long ddr3_dll_mx6dl[][2] = {
+	{0x0c, 0x0},
+	{0x10, 0x0},
+	{0x1C, 0x04008032},
+	{0x1C, 0x0400803a},
+	{0x1C, 0x07208030},
+	{0x1C, 0x07208038},
+	{0x818, 0x0},
+};
+
+unsigned long iomux_offsets_mx6dl[][2] = {
+	{0x4BC, 0x0},
+	{0x4C0, 0x0},
+	{0x4C4, 0x0},
+	{0x4C8, 0x0},
+	{0x4CC, 0x0},
+	{0x4D0, 0x0},
+	{0x4D4, 0x0},
+	{0x4D8, 0x0},
+};
+
 int can_change_ddr_freq(void)
 {
 	return 1;
@@ -178,7 +236,9 @@ static irqreturn_t wait_in_wfe_irq(int irq, void *dev_id)
 	if (cpu_is_imx7d())
 		imx7_wfe_change_ddr_freq(0x8 * me,
 			(u32)ddr_freq_change_iram_base);
-
+	else
+		wfe_change_ddr_freq(0xff << (me * 8),
+			(u32 *)&iram_iomux_settings[0][1]);
 #ifdef CONFIG_LOCAL_TIMERS
 	clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_EXIT,
 		&me);
@@ -193,10 +253,13 @@ int update_ddr_freq_imx_smp(int ddr_rate)
 {
 	int me = 0;
 	unsigned long ttbr1;
+	bool dll_off = false;
+	int i;
 #ifdef CONFIG_SMP
 	unsigned int reg = 0;
 	int cpu = 0;
 #endif
+	int mode = get_bus_freq_mode();
 
 	if (!can_change_ddr_freq())
 		return -1;
@@ -206,6 +269,22 @@ int update_ddr_freq_imx_smp(int ddr_rate)
 
 	printk(KERN_DEBUG "\nBus freq set to %d start...\n", ddr_rate);
 
+	if (cpu_is_imx6()) {
+		if ((mode == BUS_FREQ_LOW) || (mode == BUS_FREQ_AUDIO))
+			dll_off = true;
+
+		iram_ddr_settings[0][0] = ddr_settings_size;
+		iram_iomux_settings[0][0] = iomux_settings_size;
+		if (ddr_rate == ddr_normal_rate) {
+			for (i = 0; i < iram_ddr_settings[0][0]; i++) {
+				iram_ddr_settings[i + 1][0] =
+						normal_mmdc_settings[i][0];
+				iram_ddr_settings[i + 1][1] =
+						normal_mmdc_settings[i][1];
+			}
+		}
+	}
+
 	/* ensure that all Cores are in WFE. */
 	local_irq_disable();
 
@@ -220,6 +299,8 @@ int update_ddr_freq_imx_smp(int ddr_rate)
 		for_each_online_cpu(cpu) {
 			if (cpu_is_imx7d())
 				reg = *(wait_for_ddr_freq_update + 1);
+			else if (cpu_is_imx6())
+				reg = __raw_readl(imx_scu_base + 0x08);
 
 			if (reg & (0x02 << (cpu * 8)))
 				not_exited_busfreq = true;
@@ -233,7 +314,8 @@ int update_ddr_freq_imx_smp(int ddr_rate)
 	dsb();
 	if (cpu_is_imx7d())
 		online_cpus = *(wait_for_ddr_freq_update + 1);
-
+	else if (cpu_is_imx6())
+		online_cpus = readl_relaxed(imx_scu_base + 0x08);
 	for_each_online_cpu(cpu) {
 		*((char *)(&online_cpus) + (u8)cpu) = 0x02;
 		if (cpu != me) {
@@ -249,6 +331,8 @@ int update_ddr_freq_imx_smp(int ddr_rate)
 
 		if (cpu_is_imx7d())
 			reg = *(wait_for_ddr_freq_update + 1);
+		else if (cpu_is_imx6())
+			reg = readl_relaxed(imx_scu_base + 0x08);
 		reg |= (0x02 << (me * 8));
 		if (reg == online_cpus)
 			break;
@@ -258,12 +342,17 @@ int update_ddr_freq_imx_smp(int ddr_rate)
 	/* Ensure iram_tlb_phys_addr is flushed to DDR. */
 	__cpuc_flush_dcache_area(&iram_tlb_phys_addr,
 		sizeof(iram_tlb_phys_addr));
+	if (cpu_is_imx6())
+		outer_clean_range(virt_to_phys(&iram_tlb_phys_addr),
+			virt_to_phys(&iram_tlb_phys_addr + 1));
 
 	ttbr1 = save_ttbr1();
 	/* Now we can change the DDR frequency. */
 	if (cpu_is_imx7d())
 		imx7d_change_ddr_freq(ddr_rate);
-
+	else if (cpu_is_imx6())
+		mx6_change_ddr_freq(ddr_rate, iram_ddr_settings,
+			dll_off, iram_iomux_settings);
 	restore_ttbr1(ttbr1);
 	curr_ddr_rate = ddr_rate;
 
@@ -498,3 +587,184 @@ int init_mmdc_ddr3_settings_imx6_up(struct platform_device *busfreq_pdev)
 
 	return 0;
 }
+
+int init_mmdc_ddr3_settings_imx6_smp(struct platform_device *busfreq_pdev)
+{
+	int i;
+	struct device_node *node;
+	unsigned long ddr_code_size;
+	unsigned long wfe_code_size = 0;
+#ifdef CONFIG_SMP
+	u32 cpu;
+	struct device *dev = &busfreq_pdev->dev;
+	int err;
+	struct irq_data *d;
+#endif
+
+	node = of_find_compatible_node(NULL, NULL, "fsl,imx6q-mmdc-combine");
+	if (!node) {
+		printk(KERN_ERR "failed to find imx6q-mmdc device tree data!\n");
+		return -EINVAL;
+	}
+	mmdc_base = of_iomap(node, 0);
+	WARN(!mmdc_base, "unable to map mmdc registers\n");
+
+	node = NULL;
+	if (cpu_is_imx6q())
+		node = of_find_compatible_node(NULL, NULL, "fsl,imx6q-iomuxc");
+	if (cpu_is_imx6dl())
+		node = of_find_compatible_node(NULL, NULL,
+			"fsl,imx6dl-iomuxc");
+	if (!node) {
+		printk(KERN_ERR "failed to find imx6q-iomux device tree data!\n");
+		return -EINVAL;
+	}
+	iomux_base = of_iomap(node, 0);
+	WARN(!iomux_base, "unable to map iomux registers\n");
+
+	node = NULL;
+	node = of_find_compatible_node(NULL, NULL, "arm,cortex-a9-gic");
+	if (!node) {
+		printk(KERN_ERR "failed to find imx6q-a9-gic device tree data!\n");
+		return -EINVAL;
+	}
+	gic_dist_base = of_iomap(node, 0);
+	WARN(!gic_dist_base, "unable to map gic dist registers\n");
+
+	if (cpu_is_imx6q())
+		ddr_settings_size = ARRAY_SIZE(ddr3_dll_mx6q) +
+			ARRAY_SIZE(ddr3_calibration);
+	if (cpu_is_imx6dl())
+		ddr_settings_size = ARRAY_SIZE(ddr3_dll_mx6dl) +
+			ARRAY_SIZE(ddr3_calibration);
+
+	normal_mmdc_settings = kmalloc((ddr_settings_size * 8), GFP_KERNEL);
+	if (cpu_is_imx6q()) {
+		memcpy(normal_mmdc_settings, ddr3_dll_mx6q,
+			sizeof(ddr3_dll_mx6q));
+		memcpy(((char *)normal_mmdc_settings + sizeof(ddr3_dll_mx6q)),
+			ddr3_calibration, sizeof(ddr3_calibration));
+	}
+	if (cpu_is_imx6dl()) {
+		memcpy(normal_mmdc_settings, ddr3_dll_mx6dl,
+			sizeof(ddr3_dll_mx6dl));
+		memcpy(((char *)normal_mmdc_settings + sizeof(ddr3_dll_mx6dl)),
+			ddr3_calibration, sizeof(ddr3_calibration));
+	}
+	/* store the original DDR settings at boot. */
+	for (i = 0; i < ddr_settings_size; i++) {
+		/*
+		 * writes via command mode register cannot be read back.
+		 * hence hardcode them in the initial static array.
+		 * this may require modification on a per customer basis.
+		 */
+		if (normal_mmdc_settings[i][0] != 0x1C)
+			normal_mmdc_settings[i][1] =
+				readl_relaxed(mmdc_base
+				+ normal_mmdc_settings[i][0]);
+	}
+
+#ifdef CONFIG_SMP
+	irqs_used = devm_kzalloc(dev, sizeof(u32) * num_present_cpus(),
+					GFP_KERNEL);
+
+	for_each_online_cpu(cpu) {
+		int irq;
+
+		/*
+		 * set up a reserved interrupt to get all
+		 * the active cores into a WFE state
+		 * before changing the DDR frequency.
+		 */
+		irq = platform_get_irq(busfreq_pdev, cpu);
+		err = request_irq(irq, wait_in_wfe_irq,
+			IRQF_PERCPU, "mmdc_1", NULL);
+		if (err) {
+			dev_err(dev,
+				"Busfreq:request_irq failed %d, err = %d\n",
+				irq, err);
+			return err;
+		}
+		err = irq_set_affinity(irq, cpumask_of(cpu));
+		if (err) {
+			dev_err(dev,
+				"Busfreq: Cannot set irq affinity irq=%d,\n",
+				irq);
+			return err;
+		}
+		d = irq_get_irq_data(irq);
+		irqs_used[cpu] = d->hwirq + 32;
+	}
+#endif
+	iomux_settings_size = ARRAY_SIZE(iomux_offsets_mx6q);
+
+	ddr_code_size = (&mx6_ddr3_freq_change_end -
+		&mx6_ddr3_freq_change_start) * 4;
+
+	mx6_change_ddr_freq = (void *)fncpy((void *)ddr_freq_change_iram_base,
+		&mx6_ddr3_freq_change, ddr_code_size);
+
+	/*
+	 * Store the size of the array in iRAM also,
+	 * increase the size by 8 bytes.
+	 */
+	iram_iomux_settings = (void *)(ddr_freq_change_iram_base +
+		ddr_code_size);
+	iram_ddr_settings = iram_iomux_settings + (iomux_settings_size * 8) + 8;
+#ifdef CONFIG_SMP
+	wfe_freq_change_iram_base = (unsigned long)((u32 *)iram_ddr_settings +
+		(ddr_settings_size * 8) + 8);
+
+	if (wfe_freq_change_iram_base & (FNCPY_ALIGN - 1))
+			wfe_freq_change_iram_base += FNCPY_ALIGN -
+			((uintptr_t)wfe_freq_change_iram_base % (FNCPY_ALIGN));
+
+	wfe_code_size = (&wfe_ddr3_freq_change_end -
+		&wfe_ddr3_freq_change_start) *4;
+
+	wfe_change_ddr_freq = (void *)fncpy((void *)wfe_freq_change_iram_base,
+		&wfe_ddr3_freq_change, wfe_code_size);
+
+	/*
+	 * Store the variable used to communicate
+	 * between cores in a non-cacheable IRAM area
+	 */
+	wait_for_ddr_freq_update = (u32 *)&iram_iomux_settings[0][1];
+#endif
+
+	if ((ddr_code_size + wfe_code_size + (iomux_settings_size +
+		ddr_settings_size) * 8 + 16)
+		> ddr_freq_change_total_size) {
+		printk(KERN_ERR "Not enough memory for DDR Freq scale.\n");
+		return EINVAL;
+	}
+
+	if (cpu_is_imx6q()) {
+		/* store the IOMUX settings at boot. */
+		for (i = 0; i < iomux_settings_size; i++) {
+			iomux_offsets_mx6q[i][1] =
+				readl_relaxed(iomux_base +
+					iomux_offsets_mx6q[i][0]);
+			iram_iomux_settings[i + 1][0] =
+				iomux_offsets_mx6q[i][0];
+			iram_iomux_settings[i + 1][1] =
+				iomux_offsets_mx6q[i][1];
+		}
+	}
+
+	if (cpu_is_imx6dl()) {
+		for (i = 0; i < iomux_settings_size; i++) {
+			iomux_offsets_mx6dl[i][1] =
+				readl_relaxed(iomux_base +
+					iomux_offsets_mx6dl[i][0]);
+			iram_iomux_settings[i + 1][0] =
+				iomux_offsets_mx6dl[i][0];
+			iram_iomux_settings[i + 1][1] =
+				iomux_offsets_mx6dl[i][1];
+		}
+	}
+
+	curr_ddr_rate = ddr_normal_rate;
+
+	return 0;
+}
diff --git a/arch/arm/mach-imx/ddr3_freq_imx6.S b/arch/arm/mach-imx/ddr3_freq_imx6.S
new file mode 100644
index 0000000..9e503ff
--- /dev/null
+++ b/arch/arm/mach-imx/ddr3_freq_imx6.S
@@ -0,0 +1,1156 @@
+/*
+ * Copyright (C) 2011-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/linkage.h>
+#include <asm/smp_scu.h>
+#include "hardware.h"
+
+#define MMDC0_MDPDC		0x4
+#define MMDC0_MDCF0			0x0c
+#define MMDC0_MDCF1			0x10
+#define MMDC0_MDMISC		0x18
+#define MMDC0_MDSCR		0x1c
+#define MMDC0_MAARCR		0x400
+#define MMDC0_MAPSR			0x404
+#define MMDC0_MADPCR0		0x410
+#define MMDC0_MPZQHWCTRL	0x800
+#define MMDC1_MPZQHWCTRL	0x4800
+#define MMDC0_MPODTCTRL	0x818
+#define MMDC1_MPODTCTRL	0x4818
+#define MMDC0_MPDGCTRL0	0x83c
+#define MMDC1_MPDGCTRL0	0x483c
+#define MMDC0_MPMUR0		0x8b8
+#define MMDC1_MPMUR0		0x48b8
+
+#define CCM_CBCDR			0x14
+#define CCM_CBCMR			0x18
+#define CCM_CSCMR1			0x1c
+#define CCM_CDHIPR			0x48
+
+#define L2_CACHE_SYNC		0x730
+
+#define IMX6QP_REVISION_ID 0x630100
+#define ANADIG_DIGPROG     0x260
+
+.extern iram_tlb_phys_addr
+#ifdef CONFIG_SMP
+.extern imx_scu_base
+#endif
+
+.globl mx6_ddr3_freq_change_start
+.globl mx6_ddr3_freq_change_end
+.globl wfe_ddr3_freq_change_start
+.globl wfe_ddr3_freq_change_end
+
+	.align 3
+
+	.macro is_mx6qp
+
+	/* check if the SOC is i.MX6QP */
+	ldr	r0, =IMX_IO_P2V(MX6Q_ANATOP_BASE_ADDR)
+	ldr	r1, [r0, #ANADIG_DIGPROG]
+	ldr	r2, =IMX6QP_REVISION_ID
+	cmp	r1, r2
+
+	.endm
+
+	.macro	switch_to_528MHz
+
+	/* check if periph_clk_sel is already set */
+	ldr	r0, [r6, #CCM_CBCDR]
+	and	r0, r0, #(1 << 25)
+	cmp	r0, #(1 << 25)
+	beq	set_ahb_podf_before_switch
+
+	/* change periph_clk to be sourced from pll3_clk. */
+	ldr	r0, [r6, #CCM_CBCMR]
+	bic	r0, r0, #(3 << 12)
+	str	r0, [r6, #CCM_CBCMR]
+
+	ldr	r0, [r6, #CCM_CBCDR]
+	bic	r0, r0, #(0x38 << 20)
+	str	r0, [r6, #CCM_CBCDR]
+
+	/*
+	 * set the AHB dividers before the switch,
+	 * don't change AXI clock divider,
+	 * set the MMDC_DIV=1, AXI_DIV = 2, AHB_DIV=4,
+	 */
+	ldr	r0, [r6, #CCM_CBCDR]
+	ldr	r2, =0x3f1f00
+	bic	r0, r0, r2
+	orr	r0, r0, #0xd00
+	orr	r0, r0, #(1 << 16)
+	str	r0, [r6, #CCM_CBCDR]
+
+wait_div_update528:
+	ldr	r0, [r6, #CCM_CDHIPR]
+	cmp	r0, #0
+	bne	wait_div_update528
+
+	/* now switch periph_clk to pll3_main_clk. */
+	ldr	r0, [r6, #CCM_CBCDR]
+	orr	r0, r0, #(1 << 25)
+	str	r0, [r6, #CCM_CBCDR]
+
+periph_clk_switch3:
+	ldr	r0, [r6, #CCM_CDHIPR]
+	cmp	r0, #0
+	bne	periph_clk_switch3
+
+	b	switch_pre_periph_clk_528
+
+set_ahb_podf_before_switch:
+	/*
+	 * set the MMDC_DIV=1, AXI_DIV = 2, AHB_DIV=4,
+	 */
+	ldr	r0, [r6, #CCM_CBCDR]
+	ldr	r2, =0x3f1f00
+	bic	r0, r0, r2
+	orr	r0, r0, #0xd00
+	orr	r0, r0, #(1 << 16)
+	str	r0, [r6, #CCM_CBCDR]
+
+wait_div_update528_1:
+	ldr	r0, [r6, #CCM_CDHIPR]
+	cmp	r0, #0
+	bne	wait_div_update528_1
+
+switch_pre_periph_clk_528:
+
+	/* now switch pre_periph_clk to PLL2_528MHz. */
+	ldr	r0, [r6, #CCM_CBCMR]
+	bic	r0, r0, #(0xc << 16)
+	str	r0, [r6, #CCM_CBCMR]
+
+	/* now switch periph_clk back. */
+	ldr	r0, [r6, #CCM_CBCDR]
+	bic	r0, r0, #(1 << 25)
+	str	r0, [r6, #CCM_CBCDR]
+
+periph_clk_switch4:
+	ldr	r0, [r6, #CCM_CDHIPR]
+	cmp	r0, #0
+	bne	periph_clk_switch4
+
+	.endm
+
+	.macro	switch_to_400MHz
+
+	/* check if periph_clk_sel is already set. */
+	ldr	r0, [r6, #CCM_CBCDR]
+	and	r0, r0, #(1 << 25)
+	cmp	r0, #(1 << 25)
+	beq	set_ahb_podf_before_switch1
+
+	/* change periph_clk to be sourced from pll3_clk. */
+	ldr	r0, [r6, #CCM_CBCMR]
+	bic	r0, r0, #(3 << 12)
+	str	r0, [r6, #CCM_CBCMR]
+
+	ldr	r0, [r6, #CCM_CBCDR]
+	bic	r0, r0, #(0x38 << 24)
+	str	r0, [r6, #CCM_CBCDR]
+
+	/* now switch periph_clk to pll3_main_clk. */
+	ldr	r0, [r6, #CCM_CBCDR]
+	orr	r0, r0, #(1 << 25)
+	str	r0, [r6, #CCM_CBCDR]
+
+periph_clk_switch5:
+	ldr	r0, [r6, #CCM_CDHIPR]
+	cmp	r0, #0
+	bne	periph_clk_switch5
+
+	b	switch_pre_periph_clk_400
+
+set_ahb_podf_before_switch1:
+	/*
+	 * set the MMDC_DIV=1, AXI_DIV = 2, AHB_DIV=4,
+	 */
+	ldr	r0, [r6, #CCM_CBCDR]
+	ldr	r2, =0x3f1f00
+	bic	r0, r0, r2
+	orr	r0, r0, #(0x9 << 8)
+	orr	r0, r0, #(1 << 16)
+	str	r0, [r6, #CCM_CBCDR]
+
+wait_div_update400_1:
+	ldr	r0, [r6, #CCM_CDHIPR]
+	cmp	r0, #0
+	bne	wait_div_update400_1
+
+switch_pre_periph_clk_400:
+
+	/* now switch pre_periph_clk to PFD_400MHz. */
+	ldr	r0, [r6, #CCM_CBCMR]
+	bic	r0, r0, #(0xc << 16)
+	orr	r0, r0, #(0x4 << 16)
+	str	r0, [r6, #CCM_CBCMR]
+
+	/* now switch periph_clk back. */
+	ldr	r0, [r6, #CCM_CBCDR]
+	bic	r0, r0, #(1 << 25)
+	str	r0, [r6, #CCM_CBCDR]
+
+periph_clk_switch6:
+	ldr	r0, [r6, #CCM_CDHIPR]
+	cmp	r0, #0
+	bne	periph_clk_switch6
+
+	/*
+	 * change AHB divider so that we are at 400/3=133MHz.
+	 * don't change AXI clock divider.
+	 * set the MMDC_DIV=1, AXI_DIV=2, AHB_DIV=3,
+	 */
+	ldr	r0, [r6, #CCM_CBCDR]
+	ldr	r2, =0x3f1f00
+	bic	r0, r0, r2
+	orr	r0, r0, #(0x9 << 8)
+	orr	r0, r0, #(1 << 16)
+	str	r0, [r6, #CCM_CBCDR]
+
+wait_div_update400_2:
+	ldr	r0, [r6, #CCM_CDHIPR]
+	cmp	r0, #0
+	bne	wait_div_update400_2
+
+	.endm
+
+	.macro	switch_to_50MHz
+
+	/* check if periph_clk_sel is already set. */
+	ldr	r0, [r6, #CCM_CBCDR]
+	and	r0, r0, #(1 << 25)
+	cmp	r0, #(1 << 25)
+	beq	switch_pre_periph_clk_50
+
+	/*
+	 * set the periph_clk to be sourced from PLL2_PFD_200M
+	 * change periph_clk to be sourced from pll3_clk.
+	 * ensure PLL3 is the source and set the divider to 1.
+	 */
+	ldr	r0, [r6, #CCM_CBCMR]
+	bic	r0, r0, #(0x3 << 12)
+	str	r0, [r6, #CCM_CBCMR]
+
+	ldr	r0, [r6, #CCM_CBCDR]
+	bic	r0, r0, #(0x38 << 24)
+	str	r0, [r6, #CCM_CBCDR]
+
+	/* now switch periph_clk to pll3_main_clk. */
+	ldr	r0, [r6, #CCM_CBCDR]
+	orr	r0, r0, #(1 << 25)
+	str	r0, [r6, #CCM_CBCDR]
+
+periph_clk_switch_50:
+	ldr	r0, [r6, #CCM_CDHIPR]
+	cmp	r0, #0
+	bne	periph_clk_switch_50
+
+switch_pre_periph_clk_50:
+
+	/* now switch pre_periph_clk to PFD_200MHz. */
+	ldr	r0, [r6, #CCM_CBCMR]
+	orr	r0, r0, #(0xc << 16)
+	str	r0, [r6, #CCM_CBCMR]
+
+	/*
+	 * set the MMDC_DIV=4, AXI_DIV = 4, AHB_DIV=8,
+	 */
+	ldr	r0, [r6, #CCM_CBCDR]
+	ldr	r2, =0x3f1f00
+	bic	r0, r0, r2
+	orr	r0, r0, #(0x18 << 16)
+	orr	r0, r0, #(0x3 << 16)
+
+	/*
+	 * if changing AHB divider remember to change
+	 * the IPGPER divider too below.
+	 */
+	orr	r0, r0, #0x1d00
+	str	r0, [r6, #CCM_CBCDR]
+
+wait_div_update_50:
+	ldr	r0, [r6, #CCM_CDHIPR]
+	cmp	r0, #0
+	bne	wait_div_update_50
+
+	/* now switch periph_clk back. */
+	ldr	r0, [r6, #CCM_CBCDR]
+	bic	r0, r0, #(1 << 25)
+	str	r0, [r6, #CCM_CBCDR]
+
+periph_clk_switch2:
+	ldr	r0, [r6, #CCM_CDHIPR]
+	cmp	r0, #0
+	bne	periph_clk_switch2
+
+	.endm
+
+	.macro	switch_to_24MHz
+	/*
+	 * change the freq now try setting DDR to 24MHz.
+	 * source it from the periph_clk2 ensure the
+	 * periph_clk2 is sourced from 24MHz and the
+	 * divider is 1.
+	 */
+
+	ldr	r0, [r6, #CCM_CBCMR]
+	bic	r0, r0, #(0x3 << 12)
+	orr	r0, r0, #(1 << 12)
+	str	r0, [r6, #CCM_CBCMR]
+
+	ldr	r0, [r6, #CCM_CBCDR]
+	bic	r0, r0, #(0x38 << 24)
+	str	r0, [r6, #CCM_CBCDR]
+
+	/* now switch periph_clk to 24MHz. */
+	ldr	r0, [r6, #CCM_CBCDR]
+	orr	r0, r0, #(1 << 25)
+	str	r0, [r6, #CCM_CBCDR]
+
+periph_clk_switch1:
+	ldr	r0, [r6, #CCM_CDHIPR]
+	cmp	r0, #0
+	bne	periph_clk_switch1
+
+	/* change all the dividers to 1. */
+	ldr	r0, [r6, #CCM_CBCDR]
+	ldr	r2, =0x3f1f00
+	bic	r0, r0, r2
+	orr	r0, r0, #(1 << 8)
+	str	r0, [r6, #CCM_CBCDR]
+
+	/* Wait for the divider to change. */
+wait_div_update:
+	ldr	r0, [r6, #CCM_CDHIPR]
+	cmp	r0, #0
+	bne	wait_div_update
+
+	.endm
+
+	.macro	disable_l1_dcache
+
+	/*
+	 * Flush all data from the L1 data cache before disabling
+	 * SCTLR.C bit.
+	 */
+	push	{r0 - r11, lr}
+
+	ldr	r7, =v7_flush_kern_cache_all
+	mov	lr, pc
+	mov	pc, r7
+	pop	{r0 - r11, lr}
+
+	/* disable d-cache */
+	mrc	p15, 0, r6, c1, c0, 0
+	bic	r6, r6, #0x4
+	mcr	p15, 0, r6, c1, c0, 0
+	dsb
+	isb
+
+	push	{r0 - r11, lr}
+
+	ldr	r7, =v7_flush_kern_cache_all
+	mov	lr, pc
+	mov	pc, r7
+	pop	{r0 - r11, lr}
+
+	.endm
+
+/*
+ *  mx6_ddr3_freq_change
+ *
+ *  idle the processor (eg, wait for interrupt).
+ *  make sure DDR is in self-refresh.
+ *  IRQs are already disabled.
+ */
+ENTRY(mx6_ddr3_freq_change)
+
+mx6_ddr3_freq_change_start:
+	stmfd	sp!, {r4-r12}
+
+	/*
+	 * r5 -> mmdc_base
+	 * r6 -> ccm_base
+	 * r7 -> iomux_base
+	 * r12 -> l2_base
+	 */
+	mov	r4, r0
+	mov	r8, r1
+	mov	r9, r2
+	mov	r11, r3
+
+	/* flush the TLB */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c8, c3, 0
+
+	ldr	r6, =iram_tlb_phys_addr
+	ldr	r7, [r6]
+
+	/*
+	  * Need to flush and disable L1 before
+	  * disabling L2, we need data to
+	  * coherent. Flushing L1 pushes
+	  * everyhting to L2. We sync L2 later, but
+	  * it can still have dirty lines.
+	  * While exiting, we need to enable L2 first
+	  * and then L1.
+	  */
+	disable_l1_dcache
+
+#ifdef CONFIG_CACHE_L2X0
+	/*
+	 * Make sure the L2 buffers are drained.
+	 * Sync operation on L2 drains the buffers.
+	 */
+	ldr	r12, =IMX_IO_P2V(MX6Q_L2_BASE_ADDR)
+
+	/* Wait for background operations to complete. */
+wait_for_l2_to_idle:
+	ldr	r1, [r12, #L2_CACHE_SYNC]
+	cmp	r1, #0x0
+	bne	wait_for_l2_to_idle
+
+	mov	r1, #0x0
+	str	r1, [r12, #L2_CACHE_SYNC]
+
+	/* Disable L2. */
+	str	r1, [r12, #0x100]
+
+	dsb
+	isb
+#endif
+
+	/*
+	 * To ensure no page table walks occur in DDR, we
+	 * have a another page table stored in IRAM that only
+	 * contains entries pointing to IRAM, AIPS1 and AIPS2.
+	 * We need to set the TTBR1 to the new IRAM TLB.
+	 * Do the following steps:
+	 * 1. Flush the Branch Target Address Cache (BTAC)
+	 * 2. Set TTBR1 to point to IRAM page table.
+	 * 3. Disable page table walks in TTBR0 (PD0 = 1)
+	 * 4. Set TTBR0.N=1, implying 0-2G is translated by TTBR0
+	 *     and 2-4G is translated by TTBR1.
+	 */
+
+
+	/* Now switch the TTBR. */
+	/* Disable Branch Prediction, Z bit in SCTLR. */
+	mrc	p15, 0, r6, c1, c0, 0
+	bic	r6, r6, #0x800
+	mcr	p15, 0, r6, c1, c0, 0
+
+	/* Flush the Branch Target Address Cache (BTAC) */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c7, c1, 6
+
+	dsb
+	isb
+
+	/* Store the IRAM table in TTBR1 */
+	mcr	p15, 0, r7, c2, c0, 1
+
+	/* Read TTBCR and set PD0=1, N = 1 */
+	mrc	p15, 0, r6, c2, c0, 2
+	orr	r6, r6, #0x11
+	mcr	p15, 0, r6, c2, c0, 2
+
+	dsb
+	isb
+
+	/* flush the TLB */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c8, c3, 0
+
+	dsb
+	isb
+
+
+	ldr	r5, =IMX_IO_P2V(MX6Q_MMDC_P0_BASE_ADDR)
+	ldr	r6, =IMX_IO_P2V(MX6Q_CCM_BASE_ADDR)
+	ldr	r7, =IMX_IO_P2V(MX6Q_IOMUXC_BASE_ADDR)
+
+	/* Read the Original MU delay value */
+	ldr	r1, [r5, #MMDC0_MPMUR0]
+	mov	r10, r1, lsr #16
+	ldr	r1, =0x3ff
+	and	r10, r10, r1
+
+	/* disable automatic power saving. */
+	ldr	r0, [r5, #MMDC0_MAPSR]
+	orr	r0, r0, #0x01
+	str	r0, [r5, #MMDC0_MAPSR]
+
+	/* disable MMDC power down timer. */
+	ldr	r0, [r5, #MMDC0_MDPDC]
+	bic	r0, r0, #(0xff << 8)
+	str	r0, [r5, #MMDC0_MDPDC]
+
+	/* delay for a while */
+	ldr	r1, =4
+delay1:
+	ldr	r2, =0
+cont1:
+	ldr	r0, [r5, r2]
+	add	r2, r2, #4
+	cmp	r2, #16
+	bne	cont1
+	sub	r1, r1, #1
+	cmp	r1, #0
+	bgt	delay1
+
+	/* set CON_REG */
+	ldr	r0, =0x8000
+	str	r0, [r5, #MMDC0_MDSCR]
+poll_conreq_set_1:
+	ldr	r0, [r5, #MMDC0_MDSCR]
+	and	r0, r0, #(0x4 << 12)
+	cmp	r0, #(0x4 << 12)
+	bne	poll_conreq_set_1
+
+	/*
+	 * if requested frequency is great than
+	 * 300MHz, skip setting bypass adopt mode.
+	 */
+	ldr	r1, =300000000
+	cmp	r4, r1
+	bge	1f
+
+	is_mx6qp
+	bne	1f
+	/* Switch to adopt mode, set MMDC0_MAARCR bit25~26 to 2b'01 */
+	ldr	r0, [r5, #MMDC0_MAARCR]
+	bic	r0, r0, #(0x3 << 25)
+	orr	r0, #(0x01 << 25)
+	str	r0 , [r5, #MMDC0_MAARCR]
+1:
+	ldr	r0, =0x00008050
+	str	r0, [r5, #MMDC0_MDSCR]
+	ldr	r0, =0x00008058
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	/*
+	 * if requested frequency is greater than
+	 * 300MHz go to DLL on mode.
+	 */
+	ldr	r1, =300000000
+	cmp	r4, r1
+	bge	dll_on_mode
+
+dll_off_mode:
+
+	/* if DLL is currently on, turn it off. */
+	cmp	r9, #1
+	beq	continue_dll_off_1
+
+	ldr	r0, =0x00018031
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	ldr	r0, =0x00018039
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	ldr	r1, =10
+delay1a:
+	ldr	r2, =0
+cont1a:
+	ldr	r0, [r5, r2]
+	add	r2, r2, #4
+	cmp	r2, #16
+	bne	cont1a
+	sub	r1, r1, #1
+	cmp	r1, #0
+	bgt	delay1a
+
+continue_dll_off_1:
+	/* set DVFS - enter self refresh mode */
+	ldr	r0, [r5, #MMDC0_MAPSR]
+	orr	r0, r0, #(1 << 21)
+	str	r0, [r5, #MMDC0_MAPSR]
+
+	/* de-assert con_req */
+	mov	r0, #0x0
+	str	r0, [r5, #MMDC0_MDSCR]
+
+poll_dvfs_set_1:
+	ldr	r0, [r5, #MMDC0_MAPSR]
+	and	r0, r0, #(1 << 25)
+	cmp	r0, #(1 << 25)
+	bne	poll_dvfs_set_1
+
+	ldr	r1, =24000000
+	cmp	r4, r1
+	beq	switch_freq_24
+
+	switch_to_50MHz
+	b	continue_dll_off_2
+
+switch_freq_24:
+	switch_to_24MHz
+
+continue_dll_off_2:
+
+	/* set SBS - block ddr accesses */
+	ldr	r0, [r5, #MMDC0_MADPCR0]
+	orr	r0, r0, #(1 << 8)
+	str	r0, [r5, #MMDC0_MADPCR0]
+
+	/* clear DVFS - exit from self refresh mode */
+	ldr	r0, [r5, #MMDC0_MAPSR]
+	bic	r0, r0, #(1 << 21)
+	str	r0, [r5, #MMDC0_MAPSR]
+
+poll_dvfs_clear_1:
+	ldr	r0, [r5, #MMDC0_MAPSR]
+	and	r0, r0, #(1 << 25)
+	cmp	r0, #(1 << 25)
+	beq	poll_dvfs_clear_1
+
+	/* if DLL was previously on, continue DLL off routine. */
+	cmp    	r9, #1
+	beq 	continue_dll_off_3
+
+	ldr	r0, =0x00018031
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	ldr	r0, =0x00018039
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	ldr	r0, =0x08208030
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	ldr	r0, =0x08208038
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	ldr	r0, =0x00088032
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	ldr	r0, =0x0008803A
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	/* delay for a while. */
+	ldr	r1, =4
+delay_1:
+	ldr	r2, =0
+cont_1:
+	ldr	r0, [r5, r2]
+	add	r2, r2, #4
+	cmp	r2, #16
+	bne	cont_1
+	sub	r1, r1, #1
+	cmp	r1, #0
+	bgt	delay_1
+
+	ldr	r0, [r5, #MMDC0_MDCF0]
+	bic	r0, r0, #0xf
+	orr	r0, r0, #0x3
+	str	r0, [r5, #MMDC0_MDCF0]
+
+	ldr	r0, [r5, #MMDC0_MDCF1]
+	bic	r0, r0, #0x7
+	orr	r0, r0, #0x4
+	str	r0, [r5, #MMDC0_MDCF1]
+
+	ldr	r0, =0x00011680
+	str	r0, [r5, #MMDC0_MDMISC]
+
+	/* enable dqs pull down in the IOMUX. */
+	ldr	r1, [r11]
+	add	r11, r11, #8
+	ldr	r2, =0x3028
+update_iomux:
+	ldr	r0, [r11, #0x0]
+	ldr	r3, [r7, r0]
+	bic	r3, r3, r2
+	orr	r3, r3, #(0x3 << 12)
+	orr	r3, r3, #0x28
+	str	r3, [r7, r0]
+	add	r11, r11, #8
+	sub	r1, r1, #1
+	cmp	r1, #0
+	bgt	update_iomux
+
+	/*  ODT disabled. */
+	ldr	r0, =0x0
+	ldr	r2, =MMDC0_MPODTCTRL
+	str	r0, [r5, r2]
+	ldr	r2, =MMDC1_MPODTCTRL
+	str	r0, [r5, r2]
+
+	/* DQS gating disabled. */
+	ldr	r2, =MMDC0_MPDGCTRL0
+	ldr	r0, [r5, r2]
+	orr	r0, r0, #(1 << 29)
+	str	r0, [r5, r2]
+
+	ldr	r2, =MMDC1_MPDGCTRL0
+	ldr	r0, [r5, r2]
+	orr	r0, r0, #(0x1 << 29)
+	str	r0, [r5, r2]
+
+	/* Add workaround for ERR005778.*/
+	/* double the original MU_UNIT_DEL_NUM. */
+	lsl	r10, r10, #1
+
+	/* Bypass the automatic MU by setting the mu_byp_en */
+	ldr	r2, [r5, #MMDC0_MPMUR0]
+	orr	r2, r2, #0x400
+	orr	r2, r2, r10
+	str	r2, [r5, #MMDC0_MPMUR0]
+	ldr	r0, =MMDC1_MPMUR0
+	str	r2, [r5, r0]
+
+	/* Now perform a force measure */
+	ldr	r0, [r5, #MMDC0_MPMUR0]
+	orr	r0, r0, #0x800
+	str	r0, [r5, #MMDC0_MPMUR0]
+	ldr	r2, =MMDC1_MPMUR0
+	str	r0, [r5, r2]
+	/* Wait for FRC_MSR to clear. */
+1:
+	ldr	r0, [r5, #MMDC0_MPMUR0]
+	and	r0, r0, #0x800
+	ldr	r1, [r5, r2]
+	and	r1, r1, #0x800
+	orr	r0, r0, r1
+	cmp	r0, #0x0
+	bne	1b
+
+continue_dll_off_3:
+	/* clear SBS - unblock accesses to DDR. */
+	ldr	r0, [r5, #MMDC0_MADPCR0]
+	bic	r0, r0, #(0x1 << 8)
+	str	r0, [r5, #MMDC0_MADPCR0]
+
+	mov	r0, #0x0
+	str	r0, [r5, #MMDC0_MDSCR]
+poll_conreq_clear_1:
+	ldr	r0, [r5, #MMDC0_MDSCR]
+	and	r0, r0, #(0x4 << 12)
+	cmp	r0, #(0x4 << 12)
+	beq	poll_conreq_clear_1
+
+	b	done
+
+dll_on_mode:
+	/* assert DVFS - enter self refresh mode. */
+	ldr	r0, [r5, #MMDC0_MAPSR]
+	orr	r0, r0, #(1 << 21)
+	str	r0, [r5, #MMDC0_MAPSR]
+
+	/* de-assert CON_REQ. */
+	mov	r0, #0x0
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	/* poll DVFS ack. */
+poll_dvfs_set_2:
+	ldr	r0, [r5, #MMDC0_MAPSR]
+	and	r0, r0, #(1 << 25)
+	cmp	r0, #(1 << 25)
+	bne	poll_dvfs_set_2
+
+	ldr	r1, =528000000
+	cmp	r4, r1
+	beq	switch_freq_528
+
+	switch_to_400MHz
+
+	b	continue_dll_on
+
+switch_freq_528:
+	switch_to_528MHz
+
+continue_dll_on:
+
+	/* set SBS step-by-step mode. */
+	ldr	r0, [r5, #MMDC0_MADPCR0]
+	orr	r0, r0, #( 1 << 8)
+	str	r0, [r5, #MMDC0_MADPCR0]
+
+	/* clear DVFS - exit self refresh mode. */
+	ldr	r0, [r5, #MMDC0_MAPSR]
+	bic	r0, r0, #(1 << 21)
+	str	r0, [r5, #MMDC0_MAPSR]
+
+poll_dvfs_clear_2:
+	ldr	r0, [r5, #MMDC0_MAPSR]
+	and	r0, r0, #(1 << 25)
+	cmp	r0, #(1 << 25)
+	beq	poll_dvfs_clear_2
+
+	/* if DLL is currently off, turn it back on. */
+	cmp	r9, #0
+	beq	update_calibration_only
+
+	ldr	r0, =0xa1390003
+	str	r0, [r5, #MMDC0_MPZQHWCTRL]
+	ldr	r2, =MMDC1_MPZQHWCTRL
+	str	r0, [r5, r2]
+
+	/* enable DQS gating. */
+	ldr	r2, =MMDC0_MPDGCTRL0
+	ldr	r0, [r5, r2]
+	bic	r0, r0, #(1 << 29)
+	str	r0, [r5, r2]
+
+	ldr	r2, =MMDC1_MPDGCTRL0
+	ldr	r0, [r5, r2]
+	bic	r0, r0, #(1 << 29)
+	str	r0, [r5, r2]
+
+	/* force measure. */
+	ldr	r0, =0x00000800
+	str	r0, [r5, #MMDC0_MPMUR0]
+	ldr	r2, =MMDC1_MPMUR0
+	str	r0, [r5, r2]
+
+	/* Wait for FRC_MSR to clear. */
+1:
+	ldr	r0, [r5, #MMDC0_MPMUR0]
+	and	r0, r0, #0x800
+	ldr	r1, [r5, r2]
+	and	r1, r1, #0x800
+	orr	r0, r0, r1
+	cmp	r0, #0x0
+	bne	1b
+
+	/* disable dqs pull down in the IOMUX. */
+	ldr	r1, [r11]
+	add	r11, r11, #8
+update_iomux1:
+	ldr	r0, [r11, #0x0]
+	ldr	r3, [r11, #0x4]
+	str	r3, [r7, r0]
+	add	r11, r11, #8
+	sub	r1, r1, #1
+	cmp	r1, #0
+	bgt	update_iomux1
+
+	/* config MMDC timings to 528MHz. */
+	ldr	r9, [r8]
+	add	r8, r8, #8
+	ldr	r0, [r8, #0x0]
+	ldr	r3, [r8, #0x4]
+	str	r3, [r5, r0]
+	add	r8, r8, #8
+
+	ldr	r0, [r8, #0x0]
+	ldr	r3, [r8, #0x4]
+	str	r3, [r5, r0]
+	add	r8, r8, #8
+
+	/* update MISC register: WALAT, RALAT */
+	ldr	r0, =0x00001740
+	str	r0, [r5, #MMDC0_MDMISC]
+
+	/* configure ddr devices to dll on, odt. */
+	ldr	r0, =0x00048031
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	ldr	r0, =0x00048039
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	/* delay for while. */
+	ldr	r1, =4
+delay7:
+	ldr	r2, =0
+cont7:
+	ldr	r0, [r5, r2]
+	add	r2, r2, #4
+	cmp	r2, #16
+	bne	cont7
+	sub	r1, r1, #1
+	cmp	r1, #0
+	bgt	delay7
+
+	/* reset dll. */
+	ldr	r0, =0x09408030
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	ldr	r0, =0x09408038
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	/* delay for while. */
+	ldr	r1, =100
+delay8:
+	ldr	r2, =0
+cont8:
+	ldr	r0, [r5, r2]
+	add	r2, r2, #4
+	cmp	r2, #16
+	bne	cont8
+	sub	r1, r1, #1
+	cmp	r1, #0
+	bgt	delay8
+
+	ldr	r0, [r8, #0x0]
+	ldr	r3, [r8, #0x4]
+	str	r3, [r5, r0]
+	add	r8, r8, #8
+
+	ldr	r0, [r8, #0x0]
+	ldr	r3, [r8, #0x4]
+	str	r3, [r5, r0]
+	add	r8, r8, #8
+
+	ldr	r0, =0x00428031
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	ldr	r0, =0x00428039
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	ldr	r0, [r8, #0x0]
+	ldr	r3, [r8, #0x4]
+	str	r3, [r5, r0]
+	add	r8, r8, #8
+
+	ldr	r0, [r8, #0x0]
+	ldr	r3, [r8, #0x4]
+	str	r3, [r5, r0]
+	add	r8, r8, #8
+
+	/* issue a zq command. */
+	ldr	r0, =0x04008040
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	ldr	r0, =0x04008048
+	str	r0, [r5, #MMDC0_MDSCR]
+
+	/* MMDC ODT enable. */
+	ldr	r0, [r8, #0x0]
+	ldr	r3, [r8, #0x4]
+	str	r3, [r5, r0]
+	add	r8, r8, #8
+
+	ldr	r2, =0x4818
+	str	r3, [r5, r2]
+
+	/* delay for while. */
+	ldr	r1, =40
+delay15:
+	ldr	r2, =0
+cont15:
+	ldr	r0, [r5, r2]
+	add	r2, r2, #4
+	cmp	r2, #16
+	bne	cont15
+	sub	r1, r1, #1
+	cmp	r1, #0
+	bgt	delay15
+
+	/* enable MMDC power down timer. */
+	ldr	r0, [r5, #MMDC0_MDPDC]
+	orr	r0, r0, #(0x55 << 8)
+	str	r0, [r5, #MMDC0_MDPDC]
+
+	b	update_calibration
+
+update_calibration_only:
+	ldr	r1, [r8]
+	sub	r1, r1, #7
+	add	r8, r8, #64
+	b	update_calib
+
+update_calibration:
+	/* write the new calibration values. */
+	mov	r1, r9
+	sub	r1, r1, #7
+
+update_calib:
+	ldr	r0, [r8, #0x0]
+	ldr	r3, [r8, #0x4]
+	str	r3, [r5, r0]
+	add	r8, r8, #8
+	sub	r1, r1, #1
+	cmp	r1, #0
+	bgt	update_calib
+
+	/* perform a force measurement. */
+	ldr	r0, =0x800
+	str	r0, [r5, #MMDC0_MPMUR0]
+	ldr	r2, =MMDC1_MPMUR0
+	str	r0, [r5, r2]
+
+	/* Wait for FRC_MSR to clear. */
+1:
+	ldr	r0, [r5, #MMDC0_MPMUR0]
+	and	r0, r0, #0x800
+	ldr	r1, [r5, r2]
+	and	r1, r1, #0x800
+	orr	r0, r0, r1
+	cmp	r0, #0x0
+	bne	1b
+
+	/* clear SBS - unblock DDR accesses. */
+	ldr	r0, [r5, #MMDC0_MADPCR0]
+	bic	r0, r0, #(1 << 8)
+	str	r0, [r5, #MMDC0_MADPCR0]
+
+	is_mx6qp
+	bne	3f
+	/*
+	 * Switch back to adopt_bp mode, set MMDC0_MAARCR
+	 * bit25~26 to 2b'10.
+	 */
+	ldr	r0, [r5, #MMDC0_MAARCR]
+	bic	r0, r0, #(0x3 << 25)
+	orr	r0, r0, #(0x2 << 25)
+	str	r0, [r5, #MMDC0_MAARCR]
+3:
+	mov	r0, #0x0
+	str	r0, [r5, #MMDC0_MDSCR]
+poll_conreq_clear_2:
+	ldr	r0, [r5, #MMDC0_MDSCR]
+	and	r0, r0, #(0x4 << 12)
+	cmp	r0, #(0x4 << 12)
+	beq	poll_conreq_clear_2
+
+done:
+	/* MMDC0_MAPSR adopt power down enable. */
+	ldr	r0, [r5, #MMDC0_MAPSR]
+	bic	r0, r0, #0x01
+	str	r0, [r5, #MMDC0_MAPSR]
+
+#ifdef CONFIG_CACHE_L2X0
+	/* Enable L2. */
+	ldr	r7, =IMX_IO_P2V(MX6Q_L2_BASE_ADDR)
+	ldr	r6, =0x1
+	str	r6, [r7, #0x100]
+	isb
+	dsb
+#endif
+
+	/* Enable L1 data cache. */
+	mrc	p15, 0, r6, c1, c0, 0
+	orr	r6, r6, #0x4
+	mcr	p15, 0, r6, c1, c0, 0
+
+	/* Restore the TTBCR */
+	dsb
+	isb
+
+	/* Read TTBCR and set PD0=0, N = 0 */
+	mrc	p15, 0, r6, c2, c0, 2
+	bic	r6, r6, #0x11
+	mcr	p15, 0, r6, c2, c0, 2
+	dsb
+	isb
+
+	/* flush the TLB */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c8, c3, 0
+
+	dsb
+	isb
+
+	/* Enable Branch Prediction, Z bit in SCTLR. */
+	mrc	p15, 0, r6, c1, c0, 0
+	orr	r6, r6, #0x800
+	mcr	p15, 0, r6, c1, c0, 0
+
+	isb
+
+	/* Flush the Branch Target Address Cache (BTAC) */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c7, c1, 6
+	isb
+	dsb
+
+	/* restore registers */
+	ldmfd	sp!, {r4-r12}
+	mov	pc, lr
+
+	/*
+	 * Add ltorg here to ensure that all
+	 * literals are stored here and are
+	 * within the text space.
+	 */
+	.ltorg
+mx6_ddr3_freq_change_end:
+
+#ifdef CONFIG_SMP
+	.align 3
+
+ENTRY(wfe_ddr3_freq_change)
+wfe_ddr3_freq_change_start:
+	push	{r4 - r11, lr}
+
+	mov	r6, r0
+	mov	r7, r1
+
+	dsb
+	isb
+
+	disable_l1_dcache
+
+	isb
+
+	/* Turn off SMP bit. */
+	mrc	p15, 0, r8, c1, c0, 1
+	bic	r8, r8, #0x40
+	mcr	p15, 0, r8, c1, c0, 1
+
+	isb
+
+	/* Inform the SCU we are going to enter WFE. */
+	push	{r0 - r11, lr}
+
+	ldr	r0,=imx_scu_base
+	ldr	r0, [r0]
+	mov	r1, #SCU_PM_DORMANT
+	ldr	r3, =scu_power_mode
+	mov	lr, pc
+	mov	pc, r3
+
+	pop	{r0 - r11, lr}
+
+go_back_wfe:
+	wfe
+
+	ldr	r3, [r7]
+	cmp	r3, #1
+	beq	go_back_wfe
+
+	/* Turn ON SMP bit. */
+	mrc	p15, 0, r8, c1, c0, 1
+	orr	r8, r8, #0x40
+	mcr	p15, 0, r8, c1, c0, 1
+
+	isb
+	/* Enable L1 data cache. */
+	mrc	p15, 0, r8, c1, c0, 0
+	orr	r8, r8, #0x4
+	mcr	p15, 0, r8, c1, c0, 0
+	isb
+
+	/* Inform the SCU we have exited WFE. */
+	push	{r0 - r11, lr}
+
+	ldr	r0,=imx_scu_base
+	ldr	r0, [r0]
+	mov	r1, #SCU_PM_NORMAL
+	ldr	r3, =scu_power_mode
+	mov	lr, pc
+	mov	pc, r3
+
+	pop	{r0 - r11, lr}
+
+	/* Pop all saved registers. */
+	pop	{r4 - r11, lr}
+	mov	pc, lr
+	.ltorg
+wfe_ddr3_freq_change_end:
+#endif
diff --git a/arch/arm/mach-imx/mach-imx6q.c b/arch/arm/mach-imx/mach-imx6q.c
index de96f17..cb418ff 100644
--- a/arch/arm/mach-imx/mach-imx6q.c
+++ b/arch/arm/mach-imx/mach-imx6q.c
@@ -485,6 +485,7 @@ static void __init imx6q_map_io(void)
 	debug_ll_io_init();
 	imx_scu_map_io();
 	imx6_pm_map_io();
+	imx_busfreq_map_io();
 }
 
 static void __init imx6q_init_irq(void)
diff --git a/arch/arm/mach-imx/platsmp.c b/arch/arm/mach-imx/platsmp.c
index dc97b17..03230d8 100644
--- a/arch/arm/mach-imx/platsmp.c
+++ b/arch/arm/mach-imx/platsmp.c
@@ -24,7 +24,7 @@
 #include "hardware.h"
 
 u32 g_diag_reg;
-static void __iomem *imx_scu_base;
+void __iomem *imx_scu_base;
 
 static struct map_desc scu_io_desc __initdata = {
 	/* .virtual and .pfn are run-time assigned */
-- 
1.9.1

