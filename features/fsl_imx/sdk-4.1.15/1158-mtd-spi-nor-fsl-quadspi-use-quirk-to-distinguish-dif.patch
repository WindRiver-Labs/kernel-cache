From 251e3a8e0dca1b7785f53248584a66fb46fc05a2 Mon Sep 17 00:00:00 2001
From: Han Xu <han.xu@freescale.com>
Date: Tue, 4 Aug 2015 10:25:29 -0500
Subject: [PATCH 1158/1691] mtd: spi-nor: fsl-quadspi: use quirk to distinguish
 different qspi version

commit 251e3a8e0dca1b7785f53248584a66fb46fc05a2 from
git://git.freescale.com/imx/linux-2.6-imx.git imx_4.1.15_1.0.0_ga

add several quirk to distinguish different version of qspi module.

add the ddr delay quirk as well

Signed-off-by: Han Xu <han.xu@freescale.com>
Signed-off-by: Brian Norris <computersforpeace@gmail.com>
---
 drivers/mtd/spi-nor/fsl-quadspi.c | 36 +++++++++++++++++++++++++++---------
 1 file changed, 27 insertions(+), 9 deletions(-)

diff --git a/drivers/mtd/spi-nor/fsl-quadspi.c b/drivers/mtd/spi-nor/fsl-quadspi.c
index 57b063c..b1cd4a9 100644
--- a/drivers/mtd/spi-nor/fsl-quadspi.c
+++ b/drivers/mtd/spi-nor/fsl-quadspi.c
@@ -28,6 +28,14 @@
 #include <linux/mtd/spi-nor.h>
 #include <linux/mutex.h>
 
+/* Controller needs driver to swap endian */
+#define QUADSPI_QUIRK_SWAP_ENDIAN	(1 << 0)
+/* Controller needs 4x internal clock */
+#define QUADSPI_QUIRK_4X_INT_CLK	(1 << 1)
+/* Controller needs DDR delay */
+#define QUADSPI_QUIRK_DDR_DELAY		(1 << 2)
+
+
 /* The registers */
 #define QUADSPI_MCR			0x00
 #define MX6SX_QUADSPI_MCR_TX_DDR_DELAY_EN_SHIFT	29
@@ -207,20 +215,24 @@ struct fsl_qspi_devtype_data {
 	int rxfifo;
 	int txfifo;
 	int ahb_buf_size;
+	int driver_data;
 };
 
 static struct fsl_qspi_devtype_data vybrid_data = {
 	.devtype = FSL_QUADSPI_VYBRID,
 	.rxfifo = 128,
 	.txfifo = 64,
-	.ahb_buf_size = 1024
+	.ahb_buf_size = 1024,
+	.driver_data = QUADSPI_QUIRK_SWAP_ENDIAN,
 };
 
 static struct fsl_qspi_devtype_data imx6sx_data = {
 	.devtype = FSL_QUADSPI_IMX6SX,
 	.rxfifo = 128,
 	.txfifo = 512,
-	.ahb_buf_size = 1024
+	.ahb_buf_size = 1024,
+	.driver_data = QUADSPI_QUIRK_4X_INT_CLK
+		| QUADSPI_QUIRK_DDR_DELAY,
 };
 
 #define FSL_QSPI_MAX_CHIP	4
@@ -244,14 +256,19 @@ struct fsl_qspi {
 	struct mutex lock;
 };
 
-static inline int is_vybrid_qspi(struct fsl_qspi *q)
+static inline int needs_swap_endian(struct fsl_qspi *q)
+{
+	return q->devtype_data->driver_data & QUADSPI_QUIRK_SWAP_ENDIAN;
+}
+
+static inline int needs_ddr_delay(struct fsl_qspi *q)
 {
-	return q->devtype_data->devtype == FSL_QUADSPI_VYBRID;
+	return q->devtype_data->driver_data & QUADSPI_QUIRK_DDR_DELAY;
 }
 
-static inline int is_imx6sx_qspi(struct fsl_qspi *q)
+static inline int needs_4x_clock(struct fsl_qspi *q)
 {
-	return q->devtype_data->devtype == FSL_QUADSPI_IMX6SX;
+	return q->devtype_data->driver_data & QUADSPI_QUIRK_4X_INT_CLK;
 }
 
 /*
@@ -260,7 +277,7 @@ static inline int is_imx6sx_qspi(struct fsl_qspi *q)
  */
 static inline u32 fsl_qspi_endian_xchg(struct fsl_qspi *q, u32 a)
 {
-	return is_vybrid_qspi(q) ? __swab32(a) : a;
+	return needs_swap_endian(q) ? __swab32(a) : a;
 }
 
 static inline void fsl_qspi_unlock_lut(struct fsl_qspi *q)
@@ -646,7 +663,8 @@ static void fsl_qspi_init_abh_read(struct fsl_qspi *q)
 
 		/* Enable the module again (enable the DDR too) */
 		reg |= QUADSPI_MCR_DDR_EN_MASK;
-		if (is_imx6sx_qspi(q))
+		if (needs_ddr_delay(q) &&
+			(q->devtype_data->devtype == FSL_QUADSPI_IMX6SX))
 			reg |= MX6SX_QUADSPI_MCR_TX_DDR_DELAY_EN_MASK;
 
 		writel(reg, q->iobase + QUADSPI_MCR);
@@ -693,7 +711,7 @@ static int fsl_qspi_nor_setup_last(struct fsl_qspi *q)
 	unsigned long rate = q->clk_rate;
 	int ret;
 
-	if (is_imx6sx_qspi(q))
+	if (needs_4x_clock(q))
 		rate *= 4;
 
 	ret = clk_set_rate(q->clk, rate);
-- 
1.9.1

