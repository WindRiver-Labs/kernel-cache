From b3fb214bdc10883ed65b6e3f27f8767199a55ab7 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Mon, 3 Aug 2015 17:13:19 +0800
Subject: [PATCH] arm: imx: gpc: change gpc_lock to raw spin lock

The gpc_lock is introduced by commit 6c4da44dfc37 ("MLK-9955-9 arm: imx:
add A9-M4 clk shared management") to sync between A9 and M4. But the
function imx_gpc_irq_set_wake() maybe invoked in irq context. And the
normal spinlock will become sleepable in rt kernel and will trigger
the following call trace:
    BUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:907
    in_atomic(): 1, irqs_disabled(): 128, pid: 466, name: sh
    Preemption disabled at:[<  (null)>]   (null)

    CPU: 1 PID: 466 Comm: sh Not tainted 3.14.29ltsi-rt22-WR7.0.0.0_preempt-rt #65
    [<80018158>] (unwind_backtrace) from [<8001286c>] (show_stack+0x20/0x24)
    [<8001286c>] (show_stack) from [<8080ffb4>] (dump_stack+0x74/0xcc)
    [<8080ffb4>] (dump_stack) from [<8005cd10>] (__might_sleep+0x134/0x160)
    [<8005cd10>] (__might_sleep) from [<80815110>] (rt_spin_lock+0x28/0x74)
    [<80815110>] (rt_spin_lock) from [<80023128>] (imx_gpc_irq_set_wake+0x44/0x8c)
    [<80023128>] (imx_gpc_irq_set_wake) from [<80383d00>] (gic_set_wake+0x28/0x38)
    [<80383d00>] (gic_set_wake) from [<8007cc00>] (set_irq_wake_real+0x40/0x54)
    [<8007cc00>] (set_irq_wake_real) from [<8007d094>] (irq_set_irq_wake+0x6c/0x100)
    [<8007d094>] (irq_set_irq_wake) from [<8038e89c>] (gpio_set_wake_irq+0x50/0x58)
    [<8038e89c>] (gpio_set_wake_irq) from [<8007cc00>] (set_irq_wake_real+0x40/0x54)
    [<8007cc00>] (set_irq_wake_real) from [<8007d094>] (irq_set_irq_wake+0x6c/0x100)
    [<8007d094>] (irq_set_irq_wake) from [<8052cfc8>] (gpio_keys_suspend+0x70/0xac)
    [<8052cfc8>] (gpio_keys_suspend) from [<8042fc04>] (platform_pm_suspend+0x44/0x64)
    [<8042fc04>] (platform_pm_suspend) from [<80434f2c>] (dpm_run_callback+0x38/0x74)
    [<80434f2c>] (dpm_run_callback) from [<80435d64>] (__device_suspend+0x1a8/0x244)
    [<80435d64>] (__device_suspend) from [<8043663c>] (dpm_suspend+0xcc/0x238)
    [<8043663c>] (dpm_suspend) from [<80436a44>] (dpm_suspend_start+0x6c/0x74)
    [<80436a44>] (dpm_suspend_start) from [<80078004>] (suspend_devices_and_enter+0xb4/0x454)
    [<80078004>] (suspend_devices_and_enter) from [<80078488>] (pm_suspend+0xe4/0x1c4)
    [<80078488>] (pm_suspend) from [<8007715c>] (state_store+0xc8/0xec)
    [<8007715c>] (state_store) from [<8036695c>] (kobj_attr_store+0x1c/0x28)
    [<8036695c>] (kobj_attr_store) from [<8019abdc>] (sysfs_kf_write+0x4c/0x58)
    [<8019abdc>] (sysfs_kf_write) from [<8019de3c>] (kernfs_fop_write+0x100/0x148)
    [<8019de3c>] (kernfs_fop_write) from [<8013bd6c>] (vfs_write+0xe4/0x178)
    [<8013bd6c>] (vfs_write) from [<8013c2fc>] (SyS_write+0x58/0x98)
    [<8013c2fc>] (SyS_write) from [<8000e260>] (ret_fast_syscall+0x0/0x30)

Change the gpc_lock to raw spin lock to fix this issue.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/arm/mach-imx/gpc.c |   14 +++++++-------
 1 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 84098d0..ca545ee 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -73,7 +73,7 @@ static u32 gpc_wake_irqs[IMR_NUM];
 static u32 gpc_saved_imrs[IMR_NUM];
 static u32 gpc_mf_request_on[IMR_NUM];
 static u32 bypass;
-static DEFINE_SPINLOCK(gpc_lock);
+static DEFINE_RAW_SPINLOCK(gpc_lock);
 static struct notifier_block nb_pcie;
 
 void imx_gpc_add_m4_wake_up_irq(u32 irq, bool enable)
@@ -87,10 +87,10 @@ void imx_gpc_add_m4_wake_up_irq(u32 irq, bool enable)
 		return;
 
 	mask = 1 << irq % 32;
-	spin_lock_irqsave(&gpc_lock, flags);
+	raw_spin_lock_irqsave(&gpc_lock, flags);
 	gpc_wake_irqs[idx] = enable ? gpc_wake_irqs[idx] | mask :
 		gpc_wake_irqs[idx] & ~mask;
-	spin_unlock_irqrestore(&gpc_lock, flags);
+	raw_spin_unlock_irqrestore(&gpc_lock, flags);
 }
 
 void imx_gpc_hold_m4_in_sleep(void)
@@ -199,10 +199,10 @@ static int imx_gpc_irq_set_wake(struct irq_data *d, unsigned int on)
 		return -EINVAL;
 
 	mask = 1 << d->irq % 32;
-	spin_lock_irqsave(&gpc_lock, flags);
+	raw_spin_lock_irqsave(&gpc_lock, flags);
 	gpc_wake_irqs[idx] = on ? gpc_wake_irqs[idx] | mask :
 				  gpc_wake_irqs[idx] & ~mask;
-	spin_unlock_irqrestore(&gpc_lock, flags);
+	raw_spin_unlock_irqrestore(&gpc_lock, flags);
 
 	return 0;
 }
@@ -289,10 +289,10 @@ int imx_gpc_mf_request_on(unsigned int irq, unsigned int on)
 	u32 mask;
 
 	mask = 1 << (irq % 32);
-	spin_lock_irqsave(&gpc_lock, flags);
+	raw_spin_lock_irqsave(&gpc_lock, flags);
 	gpc_mf_request_on[idx] = on ? gpc_mf_request_on[idx] | mask :
 				  gpc_mf_request_on[idx] & ~mask;
-	spin_unlock_irqrestore(&gpc_lock, flags);
+	raw_spin_unlock_irqrestore(&gpc_lock, flags);
 
 	return 0;
 }
-- 
1.7.5.4

