From 14446c16638912ffb72bf0a7d72d18849fae9aeb Mon Sep 17 00:00:00 2001
From: Loren Huang <b02279@freescale.com>
Date: Mon, 22 Sep 2014 17:38:28 +0800
Subject: [PATCH 0959/1543] ENGR00329409 gpu:5.0.11.p3 gpu driver kernel part
 integration

commit 5640df8db76d3ebfd3904f66feed0a796993108b from
git://git.freescale.com/imx/linux-2.6-imx.git

Integrate p2 and p3 kernel change together.

Date: Sep 22, 2014
Signed-off-by: Loren Huang <b02279@freescale.com>
Acked-by: Shawn Guo
(cherry picked from commit 0667c47bcf0717e96d1d8a95965de8c21466777e)

Conflicts:
	drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
---
 drivers/mxc/gpu-viv/Kbuild                         |   49 +-
 drivers/mxc/gpu-viv/config                         |    7 +-
 .../hal/kernel/arch/gc_hal_kernel_context.c        |  422 +++++++++--
 .../hal/kernel/arch/gc_hal_kernel_context.h        |   23 +
 .../hal/kernel/arch/gc_hal_kernel_hardware.c       |  502 +++++++++++--
 .../hal/kernel/arch/gc_hal_kernel_hardware.h       |   29 +
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c     |  480 +++++++------
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h     |   29 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c |   12 +-
 .../gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c  |   85 +--
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c  |   25 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c   |   33 +
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c   |   59 +--
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c  |  143 ++++
 .../hal/kernel/gc_hal_kernel_video_memory.c        |  276 +++----
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h        |   39 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h   |  187 ++++--
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h |   14 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h |   97 ++-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h  |  298 ++++++++
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h   |   87 ++-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h    |    4 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h    |   85 ++-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h   |    4 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h |   15 +
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h  |   41 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h    |    4 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h     |   12 +
 .../default/gc_hal_kernel_allocator_array.h        |   34 +
 .../freescale/gc_hal_kernel_allocator_array.h      |   45 ++
 .../freescale/gc_hal_kernel_allocator_cma.c        |  410 +++++++++++
 .../hal/os/linux/kernel/gc_hal_kernel_allocator.c  |  393 +++++------
 .../hal/os/linux/kernel/gc_hal_kernel_allocator.h  |   17 +-
 .../linux/kernel/gc_hal_kernel_allocator_array.h   |   43 --
 .../hal/os/linux/kernel/gc_hal_kernel_debugfs.c    |  128 +++-
 .../hal/os/linux/kernel/gc_hal_kernel_debugfs.h    |   52 ++-
 .../hal/os/linux/kernel/gc_hal_kernel_device.c     |  315 +++++++-
 .../hal/os/linux/kernel/gc_hal_kernel_device.h     |   17 +-
 .../hal/os/linux/kernel/gc_hal_kernel_linux.h      |   34 +-
 .../gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c |  776 ++++----------------
 .../gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h |    3 +-
 .../hal/os/linux/kernel/gc_hal_kernel_platform.h   |   22 +-
 .../hal/os/linux/kernel/gc_hal_kernel_probe.c      |  208 +-----
 .../linux/kernel/gc_hal_kernel_security_channel.c  |   27 +-
 .../hal/os/linux/kernel/gc_hal_kernel_sync.c       |    2 +-
 .../freescale/gc_hal_kernel_platform_imx6q14.c     |  106 ++--
 .../gc_hal_kernel_platform_imx6q14.config          |    3 +
 47 files changed, 3649 insertions(+), 2047 deletions(-)
 create mode 100644 drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_array.h
 create mode 100644 drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_array.h
 create mode 100644 drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_cma.c
 delete mode 100644 drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator_array.h
 create mode 100644 drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx6q14.config

diff --git a/drivers/mxc/gpu-viv/Kbuild b/drivers/mxc/gpu-viv/Kbuild
index 582d3d5..a81a9d5 100644
--- a/drivers/mxc/gpu-viv/Kbuild
+++ b/drivers/mxc/gpu-viv/Kbuild
@@ -34,7 +34,25 @@ ARCH_KERNEL_DIR := hal/kernel/arch
 ARCH_VG_KERNEL_DIR := hal/kernel/archvg
 HAL_KERNEL_DIR  := hal/kernel
 
-CUSTOMER_ALLOCATOR_OBJS :=
+# Check and include platform config.
+ifneq ($(PLATFORM),)
+
+# Get platform config path.
+PLATFORM_CONFIG ?= $(AQROOT)/$(OS_KERNEL_DIR)/platform/$(PLATFORM).config
+
+# Check whether it exists.
+PLATFORM_CONFIG := $(wildcard $(PLATFORM_CONFIG))
+
+# Include it if exists.
+ifneq ($(PLATFORM_CONFIG),)
+include $(PLATFORM_CONFIG)
+endif
+
+endif
+
+MODULE_NAME ?= galcore
+CUSTOMER_ALLOCATOR_OBJS    ?=
+ALLOCATOR_ARRAY_H_LOCATION ?= $(OS_KERNEL_DIR)/allocator/default/
 
 EXTRA_CFLAGS += -Werror
 
@@ -81,6 +99,10 @@ EXTRA_CFLAGS += -Idrivers/staging/android
 OBJS += $(OS_KERNEL_DIR)/gc_hal_kernel_sync.o
 endif
 
+ifneq ($(CONFIG_ANDROID),)
+EXTRA_CFLAGS += -DANDROID
+endif
+
 ifeq ($(SECURITY), 1)
 OBJS += $(OS_KERNEL_DIR)/gc_hal_kernel_security_channel.o \
         $(HAL_KERNEL_DIR)/gc_hal_kernel_security.o
@@ -174,20 +196,28 @@ else
 EXTRA_CFLAGS += -DgcdCACHE_FUNCTION_UNIMPLEMENTED=0
 endif
 
-ifeq ($(VIVANTE_ENABLE_VG), 1)
-EXTRA_CFLAGS += -DgcdENABLE_VG=1
-else
-EXTRA_CFLAGS += -DgcdENABLE_VG=0
-endif
-
 ifeq ($(CONFIG_SMP), y)
 EXTRA_CFLAGS += -DgcdSMP=1
 else
 EXTRA_CFLAGS += -DgcdSMP=0
 endif
 
-ifeq ($(VIVANTE_NO_3D),1)
-EXTRA_CFLAGS += -DVIVANTE_NO_3D
+ifeq ($(VIVANTE_ENABLE_3D),0)
+EXTRA_CFLAGS += -DgcdENABLE_3D=0
+else
+EXTRA_CFLAGS += -DgcdENABLE_3D=1
+endif
+
+ifeq ($(VIVANTE_ENABLE_2D),0)
+EXTRA_CFLAGS += -DgcdENABLE_2D=0
+else
+EXTRA_CFLAGS += -DgcdENABLE_2D=1
+endif
+
+ifeq ($(VIVANTE_ENABLE_VG),0)
+EXTRA_CFLAGS += -DgcdENABLE_VG=0
+else
+EXTRA_CFLAGS += -DgcdENABLE_VG=1
 endif
 
 ifeq ($(ENABLE_OUTER_CACHE_PATCH), 1)
@@ -225,6 +255,7 @@ EXTRA_CFLAGS += -I$(AQROOT)/hal/kernel
 EXTRA_CFLAGS += -I$(AQROOT)/hal/kernel/arch
 EXTRA_CFLAGS += -I$(AQROOT)/hal/kernel/inc
 EXTRA_CFLAGS += -I$(AQROOT)/hal/os/linux/kernel
+EXTRA_CFLAGS += -I$(AQROOT)/$(ALLOCATOR_ARRAY_H_LOCATION)
 
 ifeq ($(VIVANTE_ENABLE_VG), 1)
 EXTRA_CFLAGS += -I$(AQROOT)/hal/kernel/archvg
diff --git a/drivers/mxc/gpu-viv/config b/drivers/mxc/gpu-viv/config
index 3003051..9484141 100644
--- a/drivers/mxc/gpu-viv/config
+++ b/drivers/mxc/gpu-viv/config
@@ -21,17 +21,16 @@
 
 ARCH_TYPE                         ?= arm
 SDK_DIR                           ?= $(AQROOT)/build/sdk
-USE_3D_VG                         ?= 1
+VIVANTE_ENABLE_3D                 ?= 1
+VIVANTE_ENABLE_2D                 ?= 1
+VIVANTE_ENABLE_VG              ?= 1
 FORCE_ALL_VIDEO_MEMORY_CACHED     ?= 0
 NONPAGED_MEMORY_CACHEABLE         ?= 0
 NONPAGED_MEMORY_BUFFERABLE        ?= 1
 CACHE_FUNCTION_UNIMPLEMENTED      ?= 0
-VIVANTE_ENABLE_VG                 ?= 1
-VIVANTE_NO_3D                     ?= 0
 ENABLE_OUTER_CACHE_PATCH          ?= 1
 USE_BANK_ALIGNMENT                ?= 1
 BANK_BIT_START                    ?= 13
 BANK_BIT_END                      ?= 15
 BANK_CHANNEL_BIT                  ?= 12
 PLATFORM                          ?= freescale/gc_hal_kernel_platform_imx6q14
-
diff --git a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.c b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.c
index 4fa0c96..3d8e062 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.c
@@ -140,7 +140,7 @@
 #define gcdSTATE_MASK \
     (((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x03 | 0xC0FFEE & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))))
 
-#if !defined(VIVANTE_NO_3D)
+#if gcdENABLE_3D
 static gctUINT32
 _TerminateStateBlock(
     IN gckCONTEXT Context,
@@ -174,6 +174,7 @@ _TerminateStateBlock(
 #endif
 
 
+#if (gcdENABLE_3D || gcdENABLE_2D)
 static gctUINT32
 _FlushPipe(
     IN gckCONTEXT Context,
@@ -183,11 +184,26 @@ _FlushPipe(
 {
     gctBOOL fcFlushStall;
     gctUINT32 flushSlots;
+    gctBOOL iCacheInvalidate;
 
     fcFlushStall
         = gckHARDWARE_IsFeatureAvailable(Context->hardware, gcvFEATURE_FC_FLUSH_STALL);
 
-    flushSlots = fcFlushStall ? 8 : 6;
+    iCacheInvalidate
+        = ((((gctUINT32) (Context->hardware->identity.chipMinorFeatures3)) >> (0 ? 3:3) & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1)))))));
+
+    flushSlots = 6;
+
+    if (fcFlushStall)
+    {
+        /* Flush tile status cache. */
+        flushSlots += 6;
+    }
+
+    if (iCacheInvalidate)
+    {
+        flushSlots += 12;
+    }
 
     if (Context->buffer != gcvNULL)
     {
@@ -207,18 +223,8 @@ _FlushPipe(
                 ?   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3)))
                 :   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))
                   | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)))
-                  | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2)));
-
-        if (fcFlushStall)
-        {
-            *buffer++
-                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0594) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
-
-            *buffer++
-                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)));
-        }
+                  | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2)))
+                  | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5)));
 
         /* Semaphore from FE to PE. */
         *buffer++
@@ -234,16 +240,102 @@ _FlushPipe(
         *buffer++
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x09 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)));
 
-        *buffer
+        *buffer++
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
+
+        if (fcFlushStall)
+        {
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0594) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
+
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)));
+
+            /* Semaphore from FE to PE. */
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E02) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
+
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
+
+            /* Stall from FE to PE. */
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x09 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)));
+
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
+        }
+
+        if (iCacheInvalidate)
+        {
+            /* Invalidate I$ after pipe is stalled */
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0218) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
+
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)));
+
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x021A) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
+
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4)));
+
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0218) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
+
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)));
+
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x021A) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
+
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5)));
+
+            /* Semaphore from FE to PE. */
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E02) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
+
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
+
+            /* Stall from FE to PE. */
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x09 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)));
+
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
+        }
     }
 
     /* Number of slots taken by flushing pipe. */
     return flushSlots;
 }
+#endif
 
-#if !defined(VIVANTE_NO_3D)
+#if gcdENABLE_3D
 static gctUINT32
 _SemaphoreStall(
     IN gckCONTEXT Context,
@@ -281,6 +373,7 @@ _SemaphoreStall(
 }
 #endif
 
+#if (gcdENABLE_3D || gcdENABLE_2D)
 static gctUINT32
 _SwitchPipe(
     IN gckCONTEXT Context,
@@ -288,6 +381,8 @@ _SwitchPipe(
     IN gcePIPE_SELECT Pipe
     )
 {
+    gctUINT32 slots = 6;
+
     if (Context->buffer != gcvNULL)
     {
         gctUINT32_PTR buffer;
@@ -301,16 +396,37 @@ _SwitchPipe(
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E00) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
 
-        *buffer
+        *buffer++
             = (Pipe == gcvPIPE_2D)
                 ? 0x1
                 : 0x0;
+
+        /* Semaphore from FE to PE. */
+        *buffer++
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E02) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
+
+        *buffer++
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
+
+        /* Stall from FE to PE. */
+        *buffer++
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x09 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)));
+
+        *buffer++
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
     }
 
-    return 2;
+    Context->pipeSelectBytes = slots * gcmSIZEOF(gctUINT32);
+
+    return slots;
 }
+#endif
 
-#if !defined(VIVANTE_NO_3D)
+#if gcdENABLE_3D
 static gctUINT32
 _State(
     IN gckCONTEXT Context,
@@ -461,6 +577,7 @@ _StateMirror(
 }
 #endif
 
+#if (gcdENABLE_3D || gcdENABLE_2D)
 static gceSTATUS
 _InitializeContextBuffer(
     IN gckCONTEXT Context
@@ -469,7 +586,7 @@ _InitializeContextBuffer(
     gctUINT32_PTR buffer;
     gctUINT32 index;
 
-#if !defined(VIVANTE_NO_3D)
+#if gcdENABLE_3D
     gctBOOL halti0, halti1, halti2, halti3;
     gctUINT i;
     gctUINT vertexUniforms, fragmentUniforms, unifiedConst, vsConstBase, psConstBase, constMax;
@@ -493,7 +610,7 @@ _InitializeContextBuffer(
     /* Build 2D states. *******************************************************/
 
 
-#if !defined(VIVANTE_NO_3D)
+#if gcdENABLE_3D
     /**************************************************************************/
     /* Build 3D states. *******************************************************/
 
@@ -517,9 +634,6 @@ _InitializeContextBuffer(
     /* Store the 3D entry index. */
     Context->entryOffset3D = (gctUINT)index * gcmSIZEOF(gctUINT32);
 
-    /* Flush 2D pipe. */
-    index += _FlushPipe(Context, index, gcvPIPE_2D);
-
     /* Switch to 3D pipe. */
     index += _SwitchPipe(Context, index, gcvPIPE_3D);
 
@@ -573,21 +687,35 @@ _InitializeContextBuffer(
         index += _State(Context, index, 0x14680 >> 2, 0x00000000, 16, gcvFALSE, gcvFALSE);
     }
 
+    /* This register is programed by all chips, which program all DECODE_SELECT as VS
+    ** except SAMPLER_DECODE_SELECT.
+    */
+    index += _State(Context, index, 0x00860 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
 
+    if (((((gctUINT32) (Context->hardware->identity.chipMinorFeatures3)) >> (0 ? 3:3) & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))))
+    {
+        /* I-Cache states. */
+        index += _State(Context, index, 0x00868 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
+        index += _State(Context, index, 0x0086C >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
+        index += _State(Context, index, 0x0304C >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
+        index += _State(Context, index, 0x01028 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
+        index += _CLOSE_RANGE();
+
+        if (halti3)
+        {
+            index += _State(Context, index, 0x00890 >> 2, 0x00000000, 1, gcvFALSE, gcvTRUE);
+            index += _State(Context, index, 0x0104C >> 2, 0x00000000, 1, gcvFALSE, gcvTRUE);
+            index += _CLOSE_RANGE();
+        }
+    }
 
     /* Vertex Shader states. */
-    index += _State(Context, index, 0x00800 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x00804 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x00808 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x0080C >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x00810 >> 2, 0x00000000, 4, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x00820 >> 2, 0x00000000, 4, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x00830 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
-    index += _State(Context, index, 0x00838 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
-    if (Context->hardware->identity.instructionCount <= 256)
-    {
-        index += _State(Context, index, 0x04000 >> 2, 0x00000000, 1024, gcvFALSE, gcvFALSE);
-    }
 
     index += _CLOSE_RANGE();
 
@@ -644,19 +772,12 @@ _InitializeContextBuffer(
     }
 
     /* Pixel Shader states. */
-    index += _State(Context, index, 0x01000 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x01004 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x01008 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x0100C >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x01010 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
-    index += _State(Context, index, 0x01018 >> 2, 0x01000000, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x01030 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
 
-    if (Context->hardware->identity.instructionCount <= 256)
-    {
-        index += _State(Context, index, 0x06000 >> 2, 0x00000000, 1024, gcvFALSE, gcvFALSE);
-    }
-
     index += _CLOSE_RANGE();
 
     /* Texture states. */
@@ -792,56 +913,67 @@ _InitializeContextBuffer(
 
     index += _CLOSE_RANGE();
 
-    if (((((gctUINT32) (Context->hardware->identity.chipMinorFeatures3)) >> (0 ? 3:3) & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))))
+    if (!halti3)
     {
-        /* I-Cache states. */
-        index += _State(Context, index, 0x0086C >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
-        index += _State(Context, index, 0x0304C >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
-        index += _State(Context, index, 0x01028 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
-        index += _State(Context, index, 0x00874 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
-        index += _State(Context, index, 0x0087C >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
-        index += _State(Context, index, 0x00878 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
-        index += _State(Context, index, 0x00880 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
-        index += _State(Context, index, 0x00868 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
-        index += _CLOSE_RANGE();
-    }
+        if (Context->hardware->identity.instructionCount > 1024)
+        {
+            /* New Shader instruction PC registers. */
+            index += _State(Context, index, 0x0085C >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
+            index += _State(Context, index, 0x0101C >> 2, 0x00000100, 1, gcvFALSE, gcvFALSE);
+            index += _CLOSE_RANGE();
 
-    /* This register is programed by all chips. */
-    index += _State(Context, index, 0x00860 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
-    if (Context->hardware->identity.instructionCount > 1024)
-    {
-        /* New Shader instruction memory. */
-        index += _State(Context, index, 0x0085C >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
-        index += _State(Context, index, 0x0101C >> 2, 0x00000100, 1, gcvFALSE, gcvFALSE);
-        index += _CLOSE_RANGE();
+            for (i = 0;
+                 i < Context->hardware->identity.instructionCount << 2;
+                 i += 256 << 2
+                 )
+            {
+                index += _State(Context, index, (0x20000 >> 2) + i, 0x00000000, 256 << 2, gcvFALSE, gcvFALSE);
+                index += _CLOSE_RANGE();
+            }
+        }
+        else if (Context->hardware->identity.instructionCount > 256)
+        {
+            /* New Shader instruction PC registers. */
+            index += _State(Context, index, 0x0085C >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
+            index += _State(Context, index, 0x0101C >> 2, 0x00000100, 1, gcvFALSE, gcvFALSE);
+            index += _CLOSE_RANGE();
 
-        for (i = 0;
-             i < Context->hardware->identity.instructionCount << 2;
-             i += 256 << 2
-             )
+            /* VX instruction memory. */
+            for (i = 0;
+                 i < Context->hardware->identity.instructionCount << 2;
+                 i += 256 << 2
+                 )
+            {
+                index += _State(Context, index, (0x0C000 >> 2) + i, 0x00000000, 256 << 2, gcvFALSE, gcvFALSE);
+                index += _CLOSE_RANGE();
+            }
+
+            _StateMirror(Context, 0x08000 >> 2, Context->hardware->identity.instructionCount << 2 , 0x0C000 >> 2);
+        }
+        else /* if (Context->hardware->identity.instructionCount <= 256) */
         {
-            index += _State(Context, index, (0x20000 >> 2) + i, 0x00000000, 256 << 2, gcvFALSE, gcvFALSE);
+            /* old shader instruction PC registers */
+            index += _State(Context, index, 0x00800 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
+            index += _State(Context, index, 0x00838 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
+            index += _CLOSE_RANGE();
+
+            index += _State(Context, index, 0x01000 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
+            index += _State(Context, index, 0x01018 >> 2, 0x01000000, 1, gcvFALSE, gcvFALSE);
+            index += _CLOSE_RANGE();
+
+            index += _State(Context, index, 0x04000 >> 2, 0x00000000, 1024, gcvFALSE, gcvFALSE);
+            index += _CLOSE_RANGE();
+            index += _State(Context, index, 0x06000 >> 2, 0x00000000, 1024, gcvFALSE, gcvFALSE);
             index += _CLOSE_RANGE();
         }
     }
-    else if (Context->hardware->identity.instructionCount > 256)
+    /* I cache use the new instruction PC registers */
+    else
     {
-        /* New Shader instruction memory. */
+        /* New Shader instruction PC registers. */
         index += _State(Context, index, 0x0085C >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x0101C >> 2, 0x00000100, 1, gcvFALSE, gcvFALSE);
         index += _CLOSE_RANGE();
-
-        /* VX instruction memory. */
-        for (i = 0;
-             i < Context->hardware->identity.instructionCount << 2;
-             i += 256 << 2
-             )
-        {
-            index += _State(Context, index, (0x0C000 >> 2) + i, 0x00000000, 256 << 2, gcvFALSE, gcvFALSE);
-            index += _CLOSE_RANGE();
-        }
-
-        _StateMirror(Context, 0x08000 >> 2, Context->hardware->identity.instructionCount << 2 , 0x0C000 >> 2);
     }
 
     if (unifiedUniform)
@@ -956,7 +1088,7 @@ _InitializeContextBuffer(
     index += _State(Context, index, 0x016B4 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
     index += _CLOSE_RANGE();
 
-    if (Context->hardware->identity.pixelPipes > 1)
+    if ((Context->hardware->identity.pixelPipes > 1) || halti1)
     {
         index += _State(Context, index, (0x016C0 >> 2) + (0 << 3), 0x00000000, Context->hardware->identity.pixelPipes, gcvFALSE, gcvTRUE);
 
@@ -1116,6 +1248,7 @@ _InitializeContextBuffer(
     /* Success. */
     return gcvSTATUS_OK;
 }
+#endif
 
 static gceSTATUS
 _DestroyContext(
@@ -1195,10 +1328,27 @@ _DestroyContext(
         }
 #endif
         /* Free record array copy. */
+#if REMOVE_DUPLICATED_COPY_FROM_USER
+        if (Context->recordArrayMap != gcvNULL)
+        {
+            gcsRECORD_ARRAY_MAP_PTR map = Context->recordArrayMap;
+
+            do
+            {
+                /* Free record array. */
+                gcmkONERROR(gcmkOS_SAFE_FREE(Context->os, map->kData));
+                map = map->next;
+            }
+            while (map != Context->recordArrayMap);
+
+            gcmkONERROR(gcmkOS_SAFE_FREE(Context->os, Context->recordArrayMap));
+        }
+#else
         if (Context->recordArray != gcvNULL)
         {
             gcmkONERROR(gcmkOS_SAFE_FREE(Context->os, Context->recordArray));
         }
+#endif
 
         /* Free the state mapping. */
         if (Context->map != gcvNULL)
@@ -1245,6 +1395,7 @@ OnError:
 **          Pointer to a variable thet will receive the gckCONTEXT object
 **          pointer.
 */
+#if (gcdENABLE_3D || gcdENABLE_2D)
 gceSTATUS
 gckCONTEXT_Construct(
     IN gckOS Os,
@@ -1289,7 +1440,7 @@ gckCONTEXT_Construct(
     context->hardware    = Hardware;
 
 
-#if defined(VIVANTE_NO_3D)
+#if !gcdENABLE_3D
     context->entryPipe = gcvPIPE_2D;
     context->exitPipe  = gcvPIPE_2D;
 #elif gcdCMD_NO_2D_CONTEXT
@@ -1555,6 +1706,7 @@ OnError:
     gcmkFOOTER();
     return status;
 }
+#endif
 
 /******************************************************************************\
 **
@@ -1619,7 +1771,7 @@ gckCONTEXT_Update(
     IN gcsSTATE_DELTA_PTR StateDelta
     )
 {
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
     gceSTATUS status = gcvSTATUS_OK;
     gcsSTATE_DELTA _stateDelta;
     gckKERNEL kernel;
@@ -1631,6 +1783,9 @@ gckCONTEXT_Update(
     gcsSTATE_DELTA_PTR kDelta = gcvNULL;
     gcsSTATE_DELTA_RECORD_PTR record;
     gcsSTATE_DELTA_RECORD_PTR recordArray = gcvNULL;
+#if REMOVE_DUPLICATED_COPY_FROM_USER
+    gcsRECORD_ARRAY_MAP_PTR recordArrayMap = gcvNULL;
+#endif
     gctUINT elementCount;
     gctUINT address;
     gctUINT32 mask;
@@ -1657,6 +1812,36 @@ gckCONTEXT_Update(
     gcmkONERROR(gckOS_QueryNeedCopy(Context->os, ProcessID, &needCopy));
 
     /* Allocate the copy buffer for the user record array. */
+#if REMOVE_DUPLICATED_COPY_FROM_USER
+    if (needCopy && (Context->recordArrayMap == gcvNULL))
+    {
+        /* Allocate enough maps. */
+        gcmkONERROR(gckOS_Allocate(
+            Context->os,
+            gcmSIZEOF(gcsRECORD_ARRAY_MAP_PTR) * gcdCONTEXT_BUFFER_COUNT,
+            (gctPOINTER *) &Context->recordArrayMap
+            ));
+
+        for (i = 0; i < gcdCONTEXT_BUFFER_COUNT; i++)
+        {
+            /* Next mapping id. */
+            gctUINT n = (i + 1) % gcdCONTEXT_BUFFER_COUNT;
+
+            recordArrayMap = &Context->recordArrayMap[i];
+
+            /* Allocate the buffer. */
+            gcmkONERROR(gckOS_Allocate(
+                Context->os,
+                Context->recordArraySize,
+                (gctPOINTER *) &recordArrayMap->kData
+                ));
+
+            /* Initialize fields. */
+            recordArrayMap->key  = 0;
+            recordArrayMap->next = &Context->recordArrayMap[n];
+        }
+    }
+#else
     if (needCopy && (Context->recordArray == gcvNULL))
     {
         /* Allocate the buffer. */
@@ -1666,6 +1851,7 @@ gckCONTEXT_Update(
             (gctPOINTER *) &Context->recordArray
             ));
     }
+#endif
 
     /* Get the current context buffer. */
     buffer = Context->buffer;
@@ -1681,7 +1867,7 @@ gckCONTEXT_Update(
     gcmkONERROR(gckKERNEL_GetProcessDBCache(kernel, ProcessID, &cache));
 #endif
 
-#if gcmIS_DEBUG(gcdDEBUG_CODE) && 1 && !defined(VIVANTE_NO_3D)
+#if gcmIS_DEBUG(gcdDEBUG_CODE) && 1 && gcdENABLE_3D
     /* Update current context token. */
     buffer->logical[Context->map[0x0E14].index]
         = (gctUINT32)gcmPTR2INT32(Context);
@@ -1710,6 +1896,58 @@ gckCONTEXT_Update(
                 (gctPOINTER *) &kDelta
                 ));
 
+#if REMOVE_DUPLICATED_COPY_FROM_USER
+            if (needCopy)
+            {
+                recordArray    = gcvNULL;
+                recordArrayMap = Context->recordArrayMap;
+
+                do
+                {
+                    /* Check if recordArray is alreay opened. */
+                    if (recordArrayMap->key == kDelta->recordArray)
+                    {
+                        /* Found. */
+                        recordArray = recordArrayMap->kData;
+                        break;
+                    }
+
+                    recordArrayMap = recordArrayMap->next;
+                }
+                while (recordArrayMap != Context->recordArrayMap);
+
+                if (recordArray == gcvNULL)
+                {
+                    while (recordArrayMap->key != 0)
+                    {
+                        /* Found an empty slot. */
+                        recordArrayMap = recordArrayMap->next;
+                    }
+
+                    /* Get access to the state records. */
+                    gcmkONERROR(gckOS_CopyFromUserData(
+                        kernel->os,
+                        recordArrayMap->kData,
+                        gcmUINT64_TO_PTR(kDelta->recordArray),
+                        Context->recordArraySize
+                        ));
+
+                    /* Save user pointer as key. */
+                    recordArrayMap->key = kDelta->recordArray;
+                    recordArray         = recordArrayMap->kData;
+                }
+            }
+            else
+            {
+                /* Get access to the state records. */
+                gcmkONERROR(gckOS_MapUserPointer(
+                    kernel->os,
+                    gcmUINT64_TO_PTR(kDelta->recordArray),
+                    Context->recordArraySize,
+                    (gctPOINTER *) &recordArray
+                    ));
+            }
+#else
             /* Get access to the state records. */
             gcmkONERROR(gckKERNEL_OpenUserData(
                 kernel, needCopy,
@@ -1717,6 +1955,7 @@ gckCONTEXT_Update(
                 gcmUINT64_TO_PTR(kDelta->recordArray), Context->recordArraySize,
                 (gctPOINTER *) &recordArray
                 ));
+#endif
 
             /* Merge all pending states. */
             for (j = 0; j < kDelta->recordCount; j += 1)
@@ -1809,6 +2048,28 @@ gckCONTEXT_Update(
             /* Get the next state delta. */
             nDelta = gcmUINT64_TO_PTR(kDelta->next);
 
+#if REMOVE_DUPLICATED_COPY_FROM_USER
+            if (needCopy)
+            {
+                if (kDelta->refCount == 0)
+                {
+                    /* No other reference, reset the mapping. */
+                    recordArrayMap->key = 0;
+                }
+            }
+            else
+            {
+                /* Close access to the state records. */
+                gcmkONERROR(gckOS_UnmapUserPointer(
+                    kernel->os,
+                    gcmUINT64_TO_PTR(kDelta->recordArray),
+                    Context->recordArraySize,
+                    (gctPOINTER *) recordArray
+                    ));
+
+                recordArray = gcvNULL;
+            }
+#else
             /* Get access to the state records. */
             gcmkONERROR(gckKERNEL_CloseUserData(
                 kernel, needCopy,
@@ -1816,6 +2077,7 @@ gckCONTEXT_Update(
                 gcmUINT64_TO_PTR(kDelta->recordArray), Context->recordArraySize,
                 (gctPOINTER *) &recordArray
                 ));
+#endif
 
             /* Close access to the current state delta. */
             gcmkONERROR(gckKERNEL_CloseUserData(
diff --git a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.h b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.h
index fe6cf5d..29e6a53 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.h
@@ -24,6 +24,9 @@
 
 #include "gc_hal_kernel_buffer.h"
 
+/* Exprimental optimization. */
+#define REMOVE_DUPLICATED_COPY_FROM_USER 1
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -79,6 +82,20 @@ typedef struct _gcsCONTEXT
 }
 gcsCONTEXT;
 
+typedef struct _gcsRECORD_ARRAY_MAP * gcsRECORD_ARRAY_MAP_PTR;
+struct  _gcsRECORD_ARRAY_MAP
+{
+    /* User pointer key. */
+    gctUINT64                   key;
+
+    /* Kernel memory buffer. */
+    gcsSTATE_DELTA_RECORD_PTR   kData;
+
+    /* Next map. */
+    gcsRECORD_ARRAY_MAP_PTR     next;
+
+};
+
 /* gckCONTEXT structure that hold the current context. */
 struct _gckCONTEXT
 {
@@ -121,7 +138,11 @@ struct _gckCONTEXT
 
     /* A copy of the user record array. */
     gctUINT                     recordArraySize;
+#if REMOVE_DUPLICATED_COPY_FROM_USER
+    gcsRECORD_ARRAY_MAP_PTR     recordArrayMap;
+#else
     gcsSTATE_DELTA_RECORD_PTR   recordArray;
+#endif
 
     /* Requested pipe select for context. */
     gcePIPE_SELECT              entryPipe;
@@ -133,6 +154,8 @@ struct _gckCONTEXT
     gctUINT32                   lastIndex;
     gctBOOL                     lastFixed;
 
+    gctUINT32                   pipeSelectBytes;
+
     /* Hint array. */
 #if gcdSECURE_USER
     gctBOOL_PTR                 hint;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c
index a565ca3..cb88684 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c
@@ -174,6 +174,11 @@ _IdentifyHardware(
                 Identity->chipRevision = 0x1051;
             }
         }
+
+        gcmkONERROR(
+            gckOS_ReadRegisterEx(Os, Core,
+                                 0x000A8,
+                                 &Identity->productID));
     }
 
     gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
@@ -195,7 +200,7 @@ _IdentifyHardware(
                              0x0001C,
                              &Identity->chipFeatures));
 
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
     /* Disable fast clear on GC700. */
     if (Identity->chipModel == gcv700)
     {
@@ -531,10 +536,13 @@ _IdentifyHardware(
      }
 
      /* For some cores, it consumes two varying for position, so the max varying vectors should minus one. */
-     if ((Identity->chipModel == gcv4000 && Identity->chipRevision == 0x5222) ||
+     if ((Identity->chipModel == gcv5000 && Identity->chipRevision == 0x5434) ||
+         (Identity->chipModel == gcv4000 && Identity->chipRevision == 0x5222) ||
          (Identity->chipModel == gcv4000 && Identity->chipRevision == 0x5208) ||
          (Identity->chipModel == gcv4000 && Identity->chipRevision == 0x5245) ||
+         (Identity->chipModel == gcv3000 && Identity->chipRevision == 0x5435) ||
          (Identity->chipModel == gcv2200 && Identity->chipRevision == 0x5244) ||
+         (Identity->chipModel == gcv1500 && Identity->chipRevision == 0x5246) ||
          ((Identity->chipModel == gcv2100 || Identity->chipModel == gcv2000) && Identity->chipRevision == 0x5108) ||
          (Identity->chipModel == gcv880 && (Identity->chipRevision == 0x5107 || Identity->chipRevision == 0x5106)))
      {
@@ -881,6 +889,22 @@ OnError:
     return status;
 }
 
+gctBOOL
+_IsGPUIdle(
+    IN gctUINT32 Idle
+    )
+{
+   return  (((((gctUINT32) (Idle)) >> (0 ? 0:0)) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1)))))) )
+        && (((((gctUINT32) (Idle)) >> (0 ? 1:1)) & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1)))))) )
+        && (((((gctUINT32) (Idle)) >> (0 ? 3:3)) & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1)))))) )
+        && (((((gctUINT32) (Idle)) >> (0 ? 4:4)) & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1)))))) )
+        && (((((gctUINT32) (Idle)) >> (0 ? 5:5)) & ((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1)))))) )
+        && (((((gctUINT32) (Idle)) >> (0 ? 6:6)) & ((gctUINT32) ((((1 ? 6:6) - (0 ? 6:6) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 6:6) - (0 ? 6:6) + 1)))))) )
+        && (((((gctUINT32) (Idle)) >> (0 ? 7:7)) & ((gctUINT32) ((((1 ? 7:7) - (0 ? 7:7) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:7) - (0 ? 7:7) + 1)))))) )
+        && (((((gctUINT32) (Idle)) >> (0 ? 2:2)) & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1)))))) )
+        ;
+}
+
 /******************************************************************************\
 ****************************** gckHARDWARE API code *****************************
 \******************************************************************************/
@@ -1072,6 +1096,7 @@ gckHARDWARE_Construct(
 #endif
 
     gcmkONERROR(gckOS_AtomConstruct(Os, &hardware->pageTableDirty));
+    gcmkONERROR(gckOS_AtomConstruct(Os, &hardware->pendingEvent));
 
 #if gcdLINK_QUEUE_SIZE
     hardware->linkQueue.front = 0;
@@ -1138,6 +1163,11 @@ OnError:
             gcmkVERIFY_OK(gckOS_AtomDestroy(Os, hardware->pageTableDirty));
         }
 
+        if (hardware->pendingEvent != gcvNULL)
+        {
+            gcmkVERIFY_OK(gckOS_AtomDestroy(Os, hardware->pendingEvent));
+        }
+
         gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Os, hardware));
     }
 
@@ -1187,6 +1217,15 @@ gckHARDWARE_Destroy(
 
     gcmkVERIFY_OK(gckOS_AtomDestroy(Hardware->os, Hardware->pageTableDirty));
 
+    gcmkVERIFY_OK(gckOS_AtomDestroy(Hardware->os, Hardware->pendingEvent));
+
+    gcmkVERIFY_OK(gckOS_FreeNonPagedMemory(
+        Hardware->os,
+        Hardware->functionBytes,
+        Hardware->functionPhysical,
+        Hardware->functionLogical
+        ));
+
     /* Mark the object as unknown. */
     Hardware->object.type = gcvOBJ_UNKNOWN;
 
@@ -1359,7 +1398,7 @@ gckHARDWARE_InitializeHardware(
                                           + 0x00100,
                                           data));
 
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
         /* Disable PE clock gating on revs < 5.0 when HZ is present without a
         ** bug fix. */
         if ((Hardware->identity.chipRevision < 0x5000)
@@ -1581,6 +1620,27 @@ gckHARDWARE_InitializeHardware(
                                           0x00002200));
     }
 
+
+    if ((Hardware->identity.chipRevision > 0x5420)
+     && gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_PIPE_3D))
+    {
+        gctUINT clock =
+            ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:1) - (0 ? 7:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:1) - (0 ? 7:1) + 1))))))) << (0 ? 7:1))) | (((gctUINT32) ((gctUINT32) (64) & ((gctUINT32) ((((1 ? 7:1) - (0 ? 7:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:1) - (0 ? 7:1) + 1))))))) << (0 ? 7:1)));
+
+        clock |= ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))) << (0 ? 16:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))) << (0 ? 16:16)));
+        clock |= ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 17:17) - (0 ? 17:17) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 17:17) - (0 ? 17:17) + 1))))))) << (0 ? 17:17))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 17:17) - (0 ? 17:17) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 17:17) - (0 ? 17:17) + 1))))))) << (0 ? 17:17)));
+
+        /* Write the clock control register. */
+        gckOS_WriteRegister(Hardware->os,
+                            0x0010C,
+                            ((((gctUINT32) (clock)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))));
+
+        /* Done loading the frequency scaler. */
+        gckOS_WriteRegister(Hardware->os,
+                            0x0010C,
+                            ((((gctUINT32) (clock)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))));
+    }
+
 #if gcdDEBUG_MODULE_CLOCK_GATING
     _ConfigureModuleLevelClockGating(Hardware);
 #endif
@@ -1791,6 +1851,8 @@ gckHARDWARE_QueryChipIdentity(
 #endif
     Identity->chip2DControl          = Hardware->identity.chip2DControl;
 
+    Identity->productID              = Hardware->identity.productID;
+
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
@@ -2457,6 +2519,13 @@ gckHARDWARE_Event(
             logical[6] = 0;
             logical[7] = 0;
         }
+
+#if gcdINTERRUPT_STATISTIC
+        if (Event < gcmCOUNTOF(Hardware->kernel->eventObj->queues))
+        {
+            gckOS_AtomSetMask(Hardware->pendingEvent, 1 << Event);
+        }
+#endif
     }
 
     if (Bytes != gcvNULL)
@@ -2954,6 +3023,11 @@ gckHARDWARE_Interrupt(
         }
         else
         {
+
+#if gcdINTERRUPT_STATISTIC
+            gckOS_AtomClearMask(Hardware->pendingEvent, data);
+#endif
+
             /* Inform gckEVENT of the interrupt. */
             status = gckEVENT_Interrupt(eventObj,
 #if gcdMULTI_GPU
@@ -3087,7 +3161,7 @@ gckHARDWARE_QuerySystemMemory(
     return gcvSTATUS_OK;
 }
 
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
 /*******************************************************************************
 **
 **  gckHARDWARE_QueryShaderCaps
@@ -3405,6 +3479,174 @@ OnError:
     return status;
 }
 
+gceSTATUS
+gckHARDWARE_SetMMUStates(
+    IN gckHARDWARE Hardware,
+    IN gctPOINTER MtlbAddress,
+    IN gceMMU_MODE Mode,
+    IN gctPOINTER SafeAddress,
+    IN gctPOINTER Logical,
+    IN OUT gctUINT32 * Bytes
+    )
+{
+    gceSTATUS status;
+    gctUINT32 config, address;
+    gctUINT32_PTR buffer;
+    gctBOOL ace;
+    gctUINT32 reserveBytes = 16 + 4 * 4;
+
+    gctBOOL config2D;
+
+    gcmkHEADER_ARG("Hardware=0x%x", Hardware);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+    gcmkVERIFY_ARGUMENT(Hardware->mmuVersion != 0);
+
+    ace = gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_ACE);
+
+    if (ace)
+    {
+        reserveBytes += 8;
+    }
+
+    config2D =  gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_PIPE_3D)
+             && gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_PIPE_2D);
+
+    if (config2D)
+    {
+        reserveBytes +=
+            /* Pipe Select. */
+            4 * 4
+            /* Configure MMU States. */
+          + 4 * 4
+            /* Semaphore stall */
+          + 4 * 8;
+    }
+
+    /* Convert logical address into physical address. */
+    gcmkONERROR(
+        gckOS_GetPhysicalAddress(Hardware->os, MtlbAddress, &config));
+
+    gcmkONERROR(
+        gckOS_GetPhysicalAddress(Hardware->os, SafeAddress, &address));
+
+    if (address & 0x3F)
+    {
+        gcmkONERROR(gcvSTATUS_NOT_ALIGNED);
+    }
+
+    switch (Mode)
+    {
+    case gcvMMU_MODE_1K:
+        if (config & 0x3FF)
+        {
+            gcmkONERROR(gcvSTATUS_NOT_ALIGNED);
+        }
+
+        config |= ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)));
+
+        break;
+
+    case gcvMMU_MODE_4K:
+        if (config & 0xFFF)
+        {
+            gcmkONERROR(gcvSTATUS_NOT_ALIGNED);
+        }
+
+        config |= ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)));
+
+        break;
+
+    default:
+        gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+    }
+
+    if (Logical != gcvNULL)
+    {
+        buffer = Logical;
+
+        *buffer++
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0061) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
+
+        *buffer++ = config;
+
+        *buffer++
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0060) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
+
+        *buffer++ = address;
+
+        if (ace)
+        {
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0068) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
+
+            *buffer++ = 0;
+        }
+
+        do{*buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E02) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))); *buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))); *buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x09 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))); *buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));} while(0);;
+
+        if (config2D)
+        {
+            /* LoadState(AQPipeSelect, 1), pipe. */
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E00) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
+
+            *buffer++ = 0x1;
+
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0061) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
+
+            *buffer++ = config;
+
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0060) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
+
+            *buffer++ = address;
+
+            do{*buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E02) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))); *buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))); *buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x09 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))); *buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));} while(0);;
+
+            /* LoadState(AQPipeSelect, 1), pipe. */
+            *buffer++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E00) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
+
+            *buffer++ = 0x0;
+
+            do{*buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E02) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))); *buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))); *buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x09 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))); *buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));} while(0);;
+        }
+
+    }
+
+    if (Bytes != gcvNULL)
+    {
+        *Bytes = reserveBytes;
+    }
+
+    /* Return the status. */
+    gcmkFOOTER_NO();
+    return status;
+
+OnError:
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
+}
+
+
 /*******************************************************************************
 **
 **  gckHARDWARE_SetMMUv2
@@ -4035,7 +4277,7 @@ gckHARDWARE_GetIdle(
 
 
             /* See if we have to wait for FE idle. */
-            if ((((((gctUINT32) (idle)) >> (0 ? 0:0)) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1)))))) )
+            if (_IsGPUIdle(idle)
              && (address == Hardware->lastEnd + 8)
              )
             {
@@ -4045,7 +4287,7 @@ gckHARDWARE_GetIdle(
         }
 
         /* Check if we need to wait for FE and FE is busy. */
-        if (Wait && !(((((gctUINT32) (idle)) >> (0 ? 0:0)) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1)))))) ))
+        if (Wait && !_IsGPUIdle(idle))
         {
             /* Wait a little. */
             gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
@@ -4250,7 +4492,7 @@ gckHARDWARE_SetFastClear(
     IN gctINT Compression
     )
 {
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
     gctUINT32 debug;
     gceSTATUS status;
 
@@ -4515,12 +4757,6 @@ gckHARDWARE_SetPowerManagementState(
     command = Hardware->kernel->command;
     gcmkVERIFY_OBJECT(command, gcvOBJ_COMMAND);
 
-    if (Hardware->powerManagement == gcvFALSE)
-    {
-        gcmkFOOTER_NO();
-        return gcvSTATUS_OK;
-    }
-
     /* Start profiler. */
     gcmkPROFILE_INIT(freq, time);
 
@@ -4591,6 +4827,14 @@ gckHARDWARE_SetPowerManagementState(
         break;
     }
 
+    if (Hardware->powerManagement == gcvFALSE
+     && State != gcvPOWER_ON
+    )
+    {
+        gcmkFOOTER_NO();
+        return gcvSTATUS_OK;
+    }
+
     /* Get current process and thread IDs. */
     gcmkONERROR(gckOS_GetProcessID(&process));
     gcmkONERROR(gckOS_GetThreadID(&thread));
@@ -5284,8 +5528,13 @@ gckHARDWARE_SetPowerManagement(
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
 
+    gcmkVERIFY_OK(
+        gckOS_AcquireMutex(Hardware->os, Hardware->powerMutex, gcvINFINITE));
+
     Hardware->powerManagement = PowerManagement;
 
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Hardware->os, Hardware->powerMutex));
+
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
@@ -6610,97 +6859,90 @@ gckHARDWARE_Reset(
     )
 {
     gceSTATUS status;
-    gckCOMMAND command;
-    gctBOOL acquired = gcvFALSE;
-    gctBOOL mutexAcquired = gcvFALSE;
-    gctUINT32 process, thread;
+    gctUINT32 idle;
+    gctUINT32 timer = 0, delay = 1;
 
     gcmkHEADER_ARG("Hardware=0x%x", Hardware);
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
     gcmkVERIFY_OBJECT(Hardware->kernel, gcvOBJ_KERNEL);
-    command = Hardware->kernel->command;
-    gcmkVERIFY_OBJECT(command, gcvOBJ_COMMAND);
 
-    if (Hardware->identity.chipRevision < 0x4600)
-    {
-        /* Not supported - we need the isolation bit. */
-        gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
-    }
+    /* Hardware reset. */
+    status = gckOS_ResetGPU(Hardware->os, Hardware->core);
 
-    status = gckOS_AcquireMutex(Hardware->os, Hardware->powerMutex, 0);
-    if (status == gcvSTATUS_TIMEOUT)
+    if (gcmIS_ERROR(status))
     {
-        gcmkONERROR(gckOS_GetProcessID(&process));
-        gcmkONERROR(gckOS_GetThreadID(&thread));
-
-        if ((Hardware->powerProcess == process)
-        &&  (Hardware->powerThread  == thread))
+        if (Hardware->identity.chipRevision < 0x4600)
         {
-            /* No way to recovery from a error in power management. */
-            gcmkFOOTER_NO();
-            return gcvSTATUS_OK;
+            /* Not supported - we need the isolation bit. */
+            gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
         }
-    }
-    else
-    {
-        mutexAcquired = gcvTRUE;
-    }
 
-    if (Hardware->chipPowerState == gcvPOWER_ON)
-    {
-        /* Acquire the power management semaphore. */
-        gcmkONERROR(
-            gckOS_AcquireSemaphore(Hardware->os, command->powerSemaphore));
-        acquired = gcvTRUE;
+        /* Soft reset. */
+        gcmkONERROR(_ResetGPU(Hardware, Hardware->os, Hardware->core));
     }
 
-    if ((Hardware->chipPowerState == gcvPOWER_ON)
-    ||  (Hardware->chipPowerState == gcvPOWER_IDLE)
-    )
-    {
-        /* Stop the command processor. */
-        gcmkONERROR(gckCOMMAND_Stop(command, gcvTRUE));
-    }
+    /* Initialize hardware. */
+    gcmkONERROR(gckHARDWARE_InitializeHardware(Hardware));
 
-    /* Stop isr, we will start it again when power on GPU. */
-    if (Hardware->stopIsr)
+    /* TODO: Move mmu setting to gckHARDWARE_InitializeHardware. */
+    if (Hardware->mmuVersion)
     {
-        gcmkONERROR(Hardware->stopIsr(Hardware->isrContext));
-    }
+        /* Execute prepared command sequence. */
+        gcmkONERROR(gckHARDWARE_Execute(
+            Hardware,
+            Hardware->functions[gcvHARDWARE_FUNCTION_MMU].address,
+            Hardware->functions[gcvHARDWARE_FUNCTION_MMU].bytes
+            ));
 
-    /* Hardware reset. */
-    status = gckOS_ResetGPU(Hardware->os, Hardware->core);
+        /* Wait until MMU configure finishes. */
+        do
+        {
+            gckOS_Delay(Hardware->os, delay);
 
-    if (gcmIS_ERROR(status))
-    {
-        /* Soft reset. */
-        gcmkONERROR(_ResetGPU(Hardware, Hardware->os, Hardware->core));
+            gcmkONERROR(gckOS_ReadRegisterEx(
+                Hardware->os,
+                Hardware->core,
+                0x00004,
+                &idle));
+
+            timer += delay;
+            delay *= 2;
+
+#if gcdGPU_TIMEOUT
+            if (timer >= Hardware->kernel->timeOut)
+            {
+                /* Even if hardware is not reset correctly, let software
+                ** continue to avoid software stuck. Software will timeout again
+                ** and try to recover GPU in next timeout.
+                */
+                gcmkONERROR(gcvSTATUS_DEVICE);
+            }
+#endif
+        }
+        while (!(((((gctUINT32) (idle)) >> (0 ? 0:0)) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1)))))) ));
+
+        /* Enable MMU. */
+        gcmkONERROR(gckOS_WriteRegisterEx(
+            Hardware->os,
+            Hardware->core,
+            0x0018C,
+            ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) ((gctUINT32) (gcvTRUE) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))
+            ));
     }
 
-    /* Force an OFF to ON power switch. */
-    Hardware->chipPowerState = gcvPOWER_OFF;
+    /* Jump to address into which GPU should run if it doesn't stuck. */
+    gcmkONERROR(gckHARDWARE_Execute(Hardware, Hardware->kernel->restoreAddress, 16));
 
-    gcmkONERROR(gckOS_ReleaseMutex(Hardware->os, Hardware->powerMutex));
-    mutexAcquired = gcvFALSE;
+    gcmkPRINT("[galcore]: recovery done");
 
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 
 OnError:
-    if (acquired)
-    {
-        /* Release the power management semaphore. */
-        gcmkVERIFY_OK(
-            gckOS_ReleaseSemaphore(Hardware->os, command->powerSemaphore));
-    }
-
-    if (mutexAcquired)
-    {
-        gckOS_ReleaseMutex(Hardware->os, Hardware->powerMutex);
-    }
+    gcmkPRINT("[galcore]: Hardware not reset successfully, give up");
 
     /* Return the error. */
     gcmkFOOTER();
@@ -6761,7 +7003,7 @@ gckHARDWARE_NeedBaseAddress(
     /* Make sure this is a load state. */
     if (((((gctUINT32) (State)) >> (0 ? 31:27) & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1)))))) == (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))))
     {
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
         /* Get the state address. */
         switch ((((((gctUINT32) (State)) >> (0 ? 15:0)) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1)))))) ))
         {
@@ -6849,7 +7091,7 @@ gckHARDWARE_Compose(
     IN gctUINT8 EventID
     )
 {
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
     gceSTATUS status;
     gctUINT32_PTR triggerState;
 
@@ -6988,7 +7230,7 @@ gckHARDWARE_IsFeatureAvailable(
         break;
 
     case gcvFEATURE_PIPE_3D:
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
         available = ((((gctUINT32) (Hardware->identity.chipFeatures)) >> (0 ? 2:2) & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1)))))) == (0x1  & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1)))))));
 #else
         available = gcvFALSE;
@@ -7951,4 +8193,104 @@ OnError:
 }
 #endif
 
+/*******************************************************************************
+**
+**  gckHARDWARE_PrepareFunctions
+**
+**  Generate command buffer snippets which will be used by gckHARDWARE, by which
+**  gckHARDWARE can manipulate GPU by FE command without using gckCOMMAND to avoid
+**  race condition and deadlock.
+**
+**  Notice:
+**  1. Each snippet can only be executed when GPU is idle.
+**  2. Execution is triggered by AHB (0x658)
+**  3. Each snippet followed by END so software can sync with GPU by checking GPU
+**     idle
+**  4. It is transparent to gckCOMMAND command buffer.
+**
+**  Existing Snippets:
+**  1. MMU Configure
+**     For new MMU, after GPU is reset, FE execute this command sequence to enble MMU.
+*/
+gceSTATUS
+gckHARDWARE_PrepareFunctions(
+    gckHARDWARE Hardware
+    )
+{
+    gceSTATUS status;
+    gckOS os;
+    gctUINT32 offset = 0;
+    gctUINT32 mmuBytes;
+    gctUINT32 endBytes;
+    gctUINT8_PTR logical;
+
+    gcmkHEADER_ARG("%x", Hardware);
+
+    os = Hardware->os;
+
+    gcmkVERIFY_OK(gckOS_GetPageSize(os, &Hardware->functionBytes));
+
+    /* Allocate a command buffer. */
+    gcmkONERROR(gckOS_AllocateNonPagedMemory(
+        os,
+        gcvFALSE,
+        &Hardware->functionBytes,
+        &Hardware->functionPhysical,
+        &Hardware->functionLogical
+        ));
+
+    gcmkONERROR(gckOS_GetPhysicalAddress(
+        os,
+        Hardware->functionLogical,
+        &Hardware->functionAddress
+        ));
+
+    if (Hardware->mmuVersion > 0)
+    {
+        /* MMU configure command sequence. */
+        logical = (gctUINT8_PTR)Hardware->functionLogical + offset;
+
+        Hardware->functions[gcvHARDWARE_FUNCTION_MMU].address
+            = Hardware->functionAddress + offset;
+
+        gcmkONERROR(gckHARDWARE_SetMMUStates(
+            Hardware,
+            Hardware->kernel->mmu->mtlbLogical,
+            gcvMMU_MODE_4K,
+            (gctUINT8_PTR)Hardware->kernel->mmu->mtlbLogical + gcdMMU_MTLB_SIZE,
+            logical,
+            &mmuBytes
+            ));
+
+        offset += mmuBytes;
+
+        logical = (gctUINT8_PTR)Hardware->functionLogical + offset;
+
+        gcmkONERROR(gckHARDWARE_End(
+            Hardware,
+            gcvNULL,
+            &endBytes
+            ));
+
+        gcmkONERROR(gckHARDWARE_End(
+            Hardware,
+            logical,
+            &endBytes
+            ));
+
+        offset += endBytes;
+
+        Hardware->functions[gcvHARDWARE_FUNCTION_MMU].bytes = mmuBytes + endBytes;
+    }
+
+    gcmkASSERT(offset < Hardware->functionBytes);
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    gcmkFOOTER();
+    return status;
+}
+
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.h b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.h
index 58247d7..54784f1 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.h
@@ -30,6 +30,25 @@
 extern "C" {
 #endif
 
+typedef enum {
+    gcvHARDWARE_FUNCTION_MMU,
+    gcvHARDWARE_FUNCTION_FLUSH,
+
+    gcvHARDWARE_FUNCTION_NUM,
+}
+gceHARDWARE_FUNCTION;
+
+
+typedef struct _gcsHARWARE_FUNCTION
+{
+    /* Entry of the function. */
+    gctUINT32                   address;
+
+    /* Bytes of the function. */
+    gctUINT32                   bytes;
+}
+gcsHARDWARE_FUNCTION;
+
 /* gckHARDWARE object. */
 struct _gckHARDWARE
 {
@@ -96,6 +115,16 @@ struct _gckHARDWARE
     gctBOOL                     endAfterFlushMmuCache;
 
     gctUINT32                   minFscaleValue;
+
+    gctPOINTER                  pendingEvent;
+
+    /* Function used by gckHARDWARE. */
+    gctPHYS_ADDR                functionPhysical;
+    gctPOINTER                  functionLogical;
+    gctUINT32                   functionAddress;
+    gctSIZE_T                   functionBytes;
+
+    gcsHARDWARE_FUNCTION        functions[gcvHARDWARE_FUNCTION_NUM];
 };
 
 gceSTATUS
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
index 15b518d..adbff2a 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
@@ -110,15 +110,101 @@ gctCONST_STRING _DispatchText[] =
 };
 #endif
 
+#if gcdGPU_TIMEOUT && gcdINTERRUPT_STATISTIC
 void
-_ResetFinishFunction(
+_MonitorTimerFunction(
     gctPOINTER Data
     )
 {
     gckKERNEL kernel = (gckKERNEL)Data;
+    gctUINT32 pendingInterrupt;
+    gctBOOL reset = gcvFALSE;
+    gctUINT32 mask;
+    gctUINT32 advance = kernel->timeOut/2;
 
-    gckOS_AtomSet(kernel->os, kernel->resetAtom, 0);
+#if gcdENABLE_VG
+    if (kernel->core == gcvCORE_VG)
+    {
+        return;
+    }
+#endif
+
+    if (kernel->monitorTimerStop)
+    {
+        /* Stop. */
+        return;
+    }
+
+    gckOS_AtomGet(kernel->os, kernel->eventObj->interruptCount, &pendingInterrupt);
+
+    if (kernel->monitoring == gcvFALSE)
+    {
+        if (pendingInterrupt)
+        {
+            /* Begin to mointor GPU state. */
+            kernel->monitoring = gcvTRUE;
+
+            /* Record current state. */
+            kernel->lastCommitStamp = kernel->eventObj->lastCommitStamp;
+            kernel->restoreAddress  = kernel->hardware->lastWaitLink;
+            gcmkVERIFY_OK(gckOS_AtomGet(
+                kernel->os,
+                kernel->hardware->pendingEvent,
+                &kernel->restoreMask
+                ));
+
+            /* Clear timeout. */
+            kernel->timer = 0;
+        }
+    }
+    else
+    {
+        if (pendingInterrupt)
+        {
+            gcmkVERIFY_OK(gckOS_AtomGet(
+                kernel->os,
+                kernel->hardware->pendingEvent,
+                &mask
+                ));
+
+            if (kernel->eventObj->lastCommitStamp == kernel->lastCommitStamp
+             && kernel->hardware->lastWaitLink    == kernel->restoreAddress
+             && mask                              == kernel->restoreMask
+            )
+            {
+                /* GPU state is not changed, accumlate timeout. */
+                kernel->timer += advance;
+
+                if (kernel->timer >= kernel->timeOut)
+                {
+                    /* GPU stuck, trigger reset. */
+                    reset = gcvTRUE;
+                }
+            }
+            else
+            {
+                /* GPU state changed, cancel current timeout.*/
+                kernel->monitoring = gcvFALSE;
+            }
+        }
+        else
+        {
+            /* GPU finish all jobs, cancel current timeout*/
+            kernel->monitoring = gcvFALSE;
+        }
+    }
+
+    if (reset)
+    {
+        gckKERNEL_Recovery(kernel);
+
+        /* Work in this timeout is done. */
+        kernel->monitoring = gcvFALSE;
+    }
+
+    gcmkVERIFY_OK(gckOS_StartTimer(kernel->os, kernel->monitorTimer, advance));
 }
+#endif
 
 #if gcdPROCESS_ADDRESS_SPACE
 gceSTATUS
@@ -248,6 +334,7 @@ gckKERNEL_Construct(
 #if gcdDVFS
     kernel->dvfs         = gcvNULL;
 #endif
+    kernel->monitorTimer = gcvNULL;
 
     kernel->vidmemMutex  = gcvNULL;
 
@@ -304,8 +391,6 @@ gckKERNEL_Construct(
         kernel->timers[i].stopTime = 0;
     }
 
-    kernel->timeOut      = gcdGPU_TIMEOUT;
-
     /* Save context. */
     kernel->context = Context;
 
@@ -360,15 +445,6 @@ gckKERNEL_Construct(
         gcmkONERROR(
             gckMMU_Construct(kernel, gcdMMU_SIZE, &kernel->mmu));
 
-        gcmkONERROR(
-            gckOS_AtomConstruct(Os, &kernel->resetAtom));
-
-        gcmkVERIFY_OK(
-            gckOS_CreateTimer(Os,
-                              (gctTIMERFUNCTION)_ResetFinishFunction,
-                              (gctPOINTER)kernel,
-                              &kernel->resetFlagClearTimer));
-
         gcmkVERIFY_OK(gckOS_GetTime(&kernel->resetTimeStamp));
 
 #if gcdDVFS
@@ -379,6 +455,8 @@ gckKERNEL_Construct(
             gcmkONERROR(gckDVFS_Start(kernel->dvfs));
         }
 #endif
+
+        gcmkONERROR(gckHARDWARE_PrepareFunctions(kernel->hardware));
     }
 
 #if VIVANTE_PROFILER
@@ -387,10 +465,24 @@ gckKERNEL_Construct(
     kernel->profileCleanRegister = gcvTRUE;
 #endif
 
-#if gcdANDROID_NATIVE_FENCE_SYNC
+#if gcdANDROID_NATIVE_FENCE_SYNC && defined(ANDROID)
     gcmkONERROR(gckOS_CreateSyncTimeline(Os, &kernel->timeline));
 #endif
 
+#if gcdENABLE_VG
+    if (Core == gcvCORE_VG)
+    {
+        kernel->timeOut = gcdGPU_TIMEOUT;
+    }
+    else
+#endif
+    {
+        kernel->timeOut = kernel->hardware->type == gcvHARDWARE_2D
+                        ? gcdGPU_2D_TIMEOUT
+                        : gcdGPU_TIMEOUT
+                        ;
+    }
+
     kernel->recovery      = gcvTRUE;
     kernel->stuckDump     = 1;
 
@@ -407,6 +499,28 @@ gckKERNEL_Construct(
     /* Construct a video memory mutex. */
     gcmkONERROR(gckOS_GetVideoMemoryMutex(Os, &kernel->vidmemMutex));
 
+#if gcdGPU_TIMEOUT && gcdINTERRUPT_STATISTIC
+    if (kernel->timeOut)
+    {
+        gcmkVERIFY_OK(gckOS_CreateTimer(
+            Os,
+            (gctTIMERFUNCTION)_MonitorTimerFunction,
+            (gctPOINTER)kernel,
+            &kernel->monitorTimer
+            ));
+
+        kernel->monitoring  = gcvFALSE;
+
+        kernel->monitorTimerStop = gcvFALSE;
+
+        gcmkVERIFY_OK(gckOS_StartTimer(
+            Os,
+            kernel->monitorTimer,
+            100
+            ));
+    }
+#endif
+
     /* Return pointer to the gckKERNEL object. */
     *Kernel = kernel;
 
@@ -447,17 +561,6 @@ OnError:
             gcmkVERIFY_OK(gckOS_AtomDestroy(Os, kernel->atomClients));
         }
 
-        if (kernel->resetAtom != gcvNULL)
-        {
-            gcmkVERIFY_OK(gckOS_AtomDestroy(Os, kernel->resetAtom));
-        }
-
-        if (kernel->resetFlagClearTimer)
-        {
-            gcmkVERIFY_OK(gckOS_StopTimer(Os, kernel->resetFlagClearTimer));
-            gcmkVERIFY_OK(gckOS_DestroyTimer(Os, kernel->resetFlagClearTimer));
-        }
-
         if (kernel->dbCreated && kernel->db != gcvNULL)
         {
             if (kernel->db->dbMutex != gcvNULL)
@@ -483,13 +586,19 @@ OnError:
         }
 #endif
 
-#if gcdANDROID_NATIVE_FENCE_SYNC
+#if gcdANDROID_NATIVE_FENCE_SYNC && defined(ANDROID)
         if (kernel->timeline)
         {
             gcmkVERIFY_OK(gckOS_DestroySyncTimeline(Os, kernel->timeline));
         }
 #endif
 
+        if (kernel->monitorTimer)
+        {
+            gcmkVERIFY_OK(gckOS_StopTimer(Os, kernel->monitorTimer));
+            gcmkVERIFY_OK(gckOS_DestroyTimer(Os, kernel->monitorTimer));
+        }
+
         gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Os, kernel));
     }
 
@@ -582,6 +691,9 @@ gckKERNEL_Destroy(
 
         /* Destroy the database. */
         gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Kernel->os, Kernel->db));
+
+        /* Notify stuck timer to quit. */
+        Kernel->monitorTimerStop = gcvTRUE;
     }
 
 #if gcdENABLE_VG
@@ -603,14 +715,6 @@ gckKERNEL_Destroy(
 
         /* Destroy the gckHARDWARE object. */
         gcmkVERIFY_OK(gckHARDWARE_Destroy(Kernel->hardware));
-
-        gcmkVERIFY_OK(gckOS_AtomDestroy(Kernel->os, Kernel->resetAtom));
-
-        if (Kernel->resetFlagClearTimer)
-        {
-            gcmkVERIFY_OK(gckOS_StopTimer(Kernel->os, Kernel->resetFlagClearTimer));
-            gcmkVERIFY_OK(gckOS_DestroyTimer(Kernel->os, Kernel->resetFlagClearTimer));
-        }
     }
 
     /* Detsroy the client atom. */
@@ -626,7 +730,7 @@ gckKERNEL_Destroy(
     }
 #endif
 
-#if gcdANDROID_NATIVE_FENCE_SYNC
+#if gcdANDROID_NATIVE_FENCE_SYNC && defined(ANDROID)
     gcmkVERIFY_OK(gckOS_DestroySyncTimeline(Kernel->os, Kernel->timeline));
 #endif
 
@@ -634,6 +738,12 @@ gckKERNEL_Destroy(
     gcmkVERIFY_OK(gckKERNEL_SecurityClose(Kernel->securityChannel));
 #endif
 
+    if (Kernel->monitorTimer)
+    {
+        gcmkVERIFY_OK(gckOS_StopTimer(Kernel->os, Kernel->monitorTimer));
+        gcmkVERIFY_OK(gckOS_DestroyTimer(Kernel->os, Kernel->monitorTimer));
+    }
+
     /* Mark the gckKERNEL object as unknown. */
     Kernel->object.type = gcvOBJ_UNKNOWN;
 
@@ -690,8 +800,6 @@ gckKERNEL_AllocateLinearMemory(
     gctSIZE_T bytes = Bytes;
     gctUINT32 handle = 0;
     gceDATABASE_TYPE type;
-    gctBOOL memlimit = gcvFALSE;
-
 
     gcmkHEADER_ARG("Kernel=0x%x *Pool=%d Bytes=%lu Alignment=%lu Type=%d",
                    Kernel, *Pool, Bytes, Alignment, Type);
@@ -705,14 +813,12 @@ gckKERNEL_AllocateLinearMemory(
     /* Check flags. */
     contiguous = Flag & gcvALLOC_FLAG_CONTIGUOUS;
     cacheable  = Flag & gcvALLOC_FLAG_CACHEABLE;
-    memlimit = Flag & gcvALLOC_FLAG_MEMLIMIT;
+
 AllocateMemory:
 
     /* Get initial pool. */
     switch (pool = *Pool)
     {
-    case gcvPOOL_DEFAULT_FORCE_CONTIGUOUS:
-        contiguous = gcvTRUE;
     case gcvPOOL_DEFAULT:
     case gcvPOOL_LOCAL:
         pool      = gcvPOOL_LOCAL_INTERNAL;
@@ -726,14 +832,6 @@ AllocateMemory:
 
     case gcvPOOL_CONTIGUOUS:
         loopCount = (gctINT) gcvPOOL_NUMBER_OF_POOLS;
-        cacheable = gcvTRUE; /*For be compatiable with android usage*/
-        break;
-
-    case gcvPOOL_DEFAULT_FORCE_CONTIGUOUS_CACHEABLE:
-        pool      = gcvPOOL_CONTIGUOUS;
-        loopCount = 1;
-        contiguous = gcvTRUE;
-        cacheable = gcvTRUE;
         break;
 
     default:
@@ -747,7 +845,7 @@ AllocateMemory:
         {
             /* Create a gcuVIDMEM_NODE for virtual memory. */
             gcmkONERROR(
-                gckVIDMEM_ConstructVirtual(Kernel, ( memlimit ? (gcvFALSE + gcvALLOC_FLAG_MEMLIMIT):gcvFALSE), Bytes, gcvTRUE, &node));
+                gckVIDMEM_ConstructVirtual(Kernel, Flag | gcvALLOC_FLAG_NON_CONTIGUOUS, Bytes, &node));
 
             bytes = node->Virtual.bytes;
             node->Virtual.type = Type;
@@ -768,7 +866,11 @@ AllocateMemory:
 #endif
             {
                 /* Create a gcuVIDMEM_NODE from contiguous memory. */
-                status = gckVIDMEM_ConstructVirtual(Kernel, ( memlimit ? (gcvTRUE + gcvALLOC_FLAG_MEMLIMIT):gcvTRUE), Bytes, cacheable, &node);
+                status = gckVIDMEM_ConstructVirtual(
+                            Kernel,
+                            Flag | gcvALLOC_FLAG_CONTIGUOUS,
+                            Bytes,
+                            &node);
             }
 
             if (gcmIS_SUCCESS(status))
@@ -791,13 +893,23 @@ AllocateMemory:
             if (gcmIS_SUCCESS(status))
             {
                 /* Allocate memory. */
-                status = gckVIDMEM_AllocateLinear(Kernel,
-                                                  videoMemory,
-                                                  Bytes,
-                                                  Alignment,
-                                                  Type,
-                                                  (*Pool == gcvPOOL_SYSTEM),
-                                                  &node);
+#if defined(gcdLINEAR_SIZE_LIMIT)
+                /* 512 KB */
+                if (Bytes > gcdLINEAR_SIZE_LIMIT)
+                {
+                    status = gcvSTATUS_OUT_OF_MEMORY;
+                }
+                else
+#endif
+                {
+                    status = gckVIDMEM_AllocateLinear(Kernel,
+                                                      videoMemory,
+                                                      Bytes,
+                                                      Alignment,
+                                                      Type,
+                                                      (*Pool == gcvPOOL_SYSTEM),
+                                                      &node);
+                }
 
                 if (gcmIS_SUCCESS(status))
                 {
@@ -852,7 +964,6 @@ AllocateMemory:
 
             if (contiguous)
             {
-                status = gcvSTATUS_OUT_OF_MEMORY;
                 break;
             }
 
@@ -928,8 +1039,8 @@ OnError:
     /* For some case like chrome with webgl test, it needs too much memory so that it invokes oom_killer
     * And the case is killed by oom_killer, the user wants not to see the crash and hope the case iteself handles the condition
     * So the patch reports the out_of_memory to the case */
-    if (status == gcvSTATUS_OUT_OF_MEMORY)
-	gcmkPRINT("OUT of memory\n");
+    if ( status == gcvSTATUS_OUT_OF_MEMORY && (Flag & gcvALLOC_FLAG_MEMLIMIT) )
+        gcmkPRINT("The running case is out_of_memory");
 
     /* Return the status. */
     gcmkFOOTER();
@@ -1049,12 +1160,15 @@ gckKERNEL_LockVideoMemory(
 
     node = nodeObject->node;
 
+    Interface->u.LockVideoMemory.gid = 0;
+
     /* Lock video memory. */
     gcmkONERROR(
             gckVIDMEM_Lock(Kernel,
-                node,
+                nodeObject,
                 Interface->u.LockVideoMemory.cacheable,
                 &Interface->u.LockVideoMemory.address,
+                &Interface->u.LockVideoMemory.gid,
                 &Interface->u.LockVideoMemory.physicalAddress));
 
     locked = gcvTRUE;
@@ -1127,7 +1241,7 @@ OnError:
     {
         /* Roll back the lock. */
         gcmkVERIFY_OK(gckVIDMEM_Unlock(Kernel,
-                    node,
+                    nodeObject,
                     gcvSURF_TYPE_UNKNOWN,
                     &asynchronous));
 
@@ -1135,7 +1249,7 @@ OnError:
         {
             /* Bottom Half */
             gcmkVERIFY_OK(gckVIDMEM_Unlock(Kernel,
-                        node,
+                        nodeObject,
                         gcvSURF_TYPE_UNKNOWN,
                         gcvNULL));
         }
@@ -1214,7 +1328,7 @@ gckKERNEL_UnlockVideoMemory(
     /* Unlock video memory. */
     gcmkONERROR(gckVIDMEM_Unlock(
         Kernel,
-        node,
+        nodeObject,
         Interface->u.UnlockVideoMemory.type,
         &Interface->u.UnlockVideoMemory.asynchroneous));
 
@@ -1246,7 +1360,6 @@ gckKERNEL_QueryDatabase(
 {
     gceSTATUS status;
     gctINT i;
-    gcuDATABASE_INFO tmp;
 
     gceDATABASE_TYPE type[3] = {
         gcvDB_VIDEO_MEMORY | (gcvPOOL_SYSTEM << gcdDB_VIDEO_MEMORY_POOL_SHIFT),
@@ -1304,15 +1417,7 @@ gckKERNEL_QueryDatabase(
                                  Interface->u.Database.processID,
                                  !Interface->u.Database.validProcessID,
                                  gcvDB_COMMAND_BUFFER,
-                                 &tmp));
-
-    Interface->u.Database.vidMemPool[2].counters.bytes += tmp.counters.bytes;
-    Interface->u.Database.vidMemPool[2].counters.maxBytes += tmp.counters.maxBytes;
-    Interface->u.Database.vidMemPool[2].counters.totalBytes += tmp.counters.totalBytes;
-
-    Interface->u.Database.vidMem.counters.bytes += tmp.counters.bytes;
-    Interface->u.Database.vidMem.counters.maxBytes += tmp.counters.maxBytes;
-    Interface->u.Database.vidMem.counters.totalBytes += tmp.counters.totalBytes;
+                                 &Interface->u.Database.vidMemPool[2]));
 
 #if gcmIS_DEBUG(gcdDEBUG_TRACE)
     gckKERNEL_DumpVidMemUsage(Kernel, Interface->u.Database.processID);
@@ -1326,6 +1431,33 @@ OnError:
     return status;
 }
 
+gceSTATUS
+gckKERNEL_ConfigPowerManagement(
+    IN gckKERNEL Kernel,
+    IN OUT gcsHAL_INTERFACE * Interface
+)
+{
+    gceSTATUS status;
+    gctBOOL enable = Interface->u.ConfigPowerManagement.enable;
+
+    gcmkHEADER();
+
+    gcmkONERROR(gckHARDWARE_SetPowerManagement(Kernel->hardware, enable));
+
+    if (enable == gcvTRUE)
+    {
+        gcmkONERROR(
+            gckHARDWARE_SetPowerManagementState(Kernel->hardware, gcvPOWER_ON));
+    }
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    gcmkFOOTER();
+    return status;
+}
+
 /*******************************************************************************
 **
 **  gckKERNEL_Dispatch
@@ -1362,7 +1494,9 @@ gckKERNEL_Dispatch(
     gctSIZE_T bytes;
     gctPOINTER logical = gcvNULL;
     gctPOINTER info = gcvNULL;
+#if (gcdENABLE_3D || gcdENABLE_2D)
     gckCONTEXT context = gcvNULL;
+#endif
     gckKERNEL kernel = Kernel;
     gctUINT32 address;
     gctUINT32 processID;
@@ -1800,69 +1934,10 @@ gckKERNEL_Dispatch(
             break;
 
         case gcvUSER_SIGNAL_WAIT:
-#if gcdGPU_TIMEOUT
-            if (Interface->u.UserSignal.wait == gcvINFINITE)
-            {
-                gckHARDWARE hardware;
-                gctUINT32 timer = 0;
-
-                for(;;)
-                {
-                    /* Wait on the signal. */
-                    status = gckOS_WaitUserSignal(Kernel->os,
-                                                  Interface->u.UserSignal.id,
-                                                  gcdGPU_ADVANCETIMER);
-
-                    if (status == gcvSTATUS_TIMEOUT)
-                    {
-                        gcmkONERROR(
-                            gckOS_SignalQueryHardware(Kernel->os,
-                                                      (gctSIGNAL)(gctUINTPTR_T)Interface->u.UserSignal.id,
-                                                      &hardware));
-
-                        if (hardware)
-                        {
-                            /* This signal is bound to a hardware,
-                            ** so the timeout is limited by gcdGPU_TIMEOUT.
-                            */
-                            timer += gcdGPU_ADVANCETIMER;
-                        }
-
-                        if (timer >= Kernel->timeOut)
-                        {
-                            gcmkONERROR(
-                                gckOS_Broadcast(Kernel->os,
-                                                hardware,
-                                                gcvBROADCAST_GPU_STUCK));
-
-                            timer = 0;
-
-                            /* If a few process try to reset GPU, only one
-                            ** of them can do the real reset, other processes
-                            ** still need to wait for this signal is triggered,
-                            ** which menas reset is finished.
-                            */
-                            continue;
-                        }
-                    }
-                    else
-                    {
-                        /* Bail out on other error. */
-                        gcmkONERROR(status);
-
-                        /* Wait for signal successfully. */
-                        break;
-                    }
-                }
-            }
-            else
-#endif
-            {
-                /* Wait on the signal. */
-                status = gckOS_WaitUserSignal(Kernel->os,
-                                              Interface->u.UserSignal.id,
-                                              Interface->u.UserSignal.wait);
-            }
+            /* Wait on the signal. */
+            status = gckOS_WaitUserSignal(Kernel->os,
+                                          Interface->u.UserSignal.id,
+                                          Interface->u.UserSignal.wait);
 
             break;
 
@@ -2137,7 +2212,8 @@ gckKERNEL_Dispatch(
         {
             Kernel->profileEnable = Interface->u.SetProfileSetting.enable;
 #if VIVANTE_PROFILER_NEW
-            gckHARDWARE_InitProfiler(Kernel->hardware);
+            if (Kernel->profileEnable)
+                gckHARDWARE_InitProfiler(Kernel->hardware);
 #endif
         }
         else
@@ -2351,6 +2427,7 @@ gckKERNEL_Dispatch(
         Interface->u.ChipInfo.types[0] = Kernel->hardware->type;
         break;
 
+#if (gcdENABLE_3D || gcdENABLE_2D)
     case gcvHAL_ATTACH:
         /* Attach user process. */
         gcmkONERROR(
@@ -2378,6 +2455,7 @@ gckKERNEL_Dispatch(
                                    gcvNULL,
                                    0));
         break;
+#endif
 
     case gcvHAL_DETACH:
         gcmkVERIFY_OK(
@@ -2478,7 +2556,7 @@ gckKERNEL_Dispatch(
         gcmRELEASE_NAME(Interface->u.FreeVirtualCommandBuffer.physical);
         break;
 
-#if gcdANDROID_NATIVE_FENCE_SYNC
+#if gcdANDROID_NATIVE_FENCE_SYNC && defined(ANDROID)
     case gcvHAL_SYNC_POINT:
         {
             gctSYNC_POINT syncPoint;
@@ -2620,6 +2698,10 @@ gckKERNEL_Dispatch(
         }
         break;
 
+    case gcvHAL_CONFIG_POWER_MANAGEMENT:
+        gcmkONERROR(gckKERNEL_ConfigPowerManagement(Kernel, Interface));
+        break;
+
     default:
         /* Invalid command. */
         gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
@@ -3335,18 +3417,20 @@ gckKERNEL_Recovery(
     IN gckKERNEL Kernel
     )
 {
-#define gcdEVENT_MASK 0x3FFFFFFF
     gceSTATUS status;
     gckEVENT eventObj;
     gckHARDWARE hardware;
-#if gcdMULTI_GPU
-    gctSIZE_T i = 0;
-#endif
 #if gcdSECURE_USER
     gctUINT32 processID;
     gcskSECURE_CACHE_PTR cache;
 #endif
-    gctUINT32 oldValue;
+    gctUINT32 mask = 0;
+    gckCOMMAND command;
+    gckENTRYDATA data;
+    gctUINT32 i = 0, count = 0;
+#if gcdINTERRUPT_STATISTIC
+    gctINT32 oldValue;
+#endif
 
     gcmkHEADER_ARG("Kernel=0x%x", Kernel);
 
@@ -3361,6 +3445,10 @@ gckKERNEL_Recovery(
     hardware = Kernel->hardware;
     gcmkVERIFY_OBJECT(hardware, gcvOBJ_HARDWARE);
 
+    /* Grab gckCOMMAND object. */
+    command = Kernel->command;
+    gcmkVERIFY_OBJECT(command, gcvOBJ_COMMAND);
+
 #if gcdSECURE_USER
     /* Flush the secure mapping cache. */
     gcmkONERROR(gckOS_GetProcessID(&processID));
@@ -3368,15 +3456,6 @@ gckKERNEL_Recovery(
     gcmkONERROR(gckKERNEL_FlushTranslationCache(Kernel, cache, gcvNULL, 0));
 #endif
 
-    gcmkONERROR(
-        gckOS_AtomicExchange(Kernel->os, Kernel->resetAtom, 1, &oldValue));
-
-    if (oldValue)
-    {
-        /* Some one else will recovery GPU. */
-        return gcvSTATUS_OK;
-    }
-
     if (Kernel->stuckDump == gcdSTUCK_DUMP_MINIMAL)
     {
         gcmkPRINT("[galcore]: GPU[%d] hang, automatic recovery.", Kernel->core);
@@ -3397,27 +3476,24 @@ gckKERNEL_Recovery(
         }
     }
 
-    /* Start a timer to clear reset flag, before timer is expired,
-    ** other recovery request is ignored. */
-    gcmkVERIFY_OK(
-        gckOS_StartTimer(Kernel->os,
-                         Kernel->resetFlagClearTimer,
-                         Kernel->timeOut * 39 / 40));
-
-    /* Try issuing a soft reset for the GPU. */
-    status = gckHARDWARE_Reset(hardware);
-    if (status == gcvSTATUS_NOT_SUPPORTED)
+    /* Clear queue. */
+    do
     {
-        /* Switch to OFF power.  The next submit should return the GPU to ON
-        ** state. */
-        gcmkONERROR(
-            gckHARDWARE_SetPowerManagementState(hardware,
-                                                gcvPOWER_OFF_RECOVERY));
+        status = gckENTRYQUEUE_Dequeue(&command->queue, &data);
     }
-    else
+    while (status == gcvSTATUS_OK);
+
+    /* Issuing a soft reset for the GPU. */
+    gcmkONERROR(gckHARDWARE_Reset(hardware));
+
+    mask = Kernel->restoreMask;
+
+    for (i = 0; i < 32; i++)
     {
-        /* Bail out on reset error. */
-        gcmkONERROR(status);
+        if (mask & (1 << i))
+        {
+            count++;
+        }
     }
 
     /* Handle all outstanding events now. */
@@ -3427,15 +3503,15 @@ gckKERNEL_Recovery(
     {
         for (i = 0; i < gcdMULTI_GPU; i++)
         {
-            gcmkONERROR(gckOS_AtomSet(Kernel->os, eventObj->pending3D[i], gcdEVENT_MASK));
+            gcmkONERROR(gckOS_AtomSet(Kernel->os, eventObj->pending3D[i], mask));
         }
     }
     else
     {
-        gcmkONERROR(gckOS_AtomSet(Kernel->os, eventObj->pending, gcdEVENT_MASK));
+        gcmkONERROR(gckOS_AtomSet(Kernel->os, eventObj->pending, mask));
     }
 #else
-    gcmkONERROR(gckOS_AtomSet(Kernel->os, eventObj->pending, gcdEVENT_MASK));
+    gcmkONERROR(gckOS_AtomSet(Kernel->os, eventObj->pending, mask));
 #endif
 #else
 #if gcdMULTI_GPU
@@ -3443,58 +3519,32 @@ gckKERNEL_Recovery(
     {
         for (i = 0; i < gcdMULTI_GPU; i++)
         {
-            eventObj->pending3D[i] = gcdEVENT_MASK;
+            eventObj->pending3D[i] = mask;
         }
     }
     else
     {
-        eventObj->pending = gcdEVENT_MASK;
+        eventObj->pending = mask;
     }
 #else
-    eventObj->pending = gcdEVENT_MASK;
+    eventObj->pending = mask;
 #endif
 #endif
 
 #if gcdINTERRUPT_STATISTIC
-    gcmkONERROR(gckOS_AtomSet(Kernel->os, eventObj->interruptCount, 0));
-#endif
-    gcmkONERROR(gckEVENT_Notify(eventObj, 1));
-
-    /* Again in case more events got submitted. */
-#if gcdSMP
-#if gcdMULTI_GPU
-    if (Kernel->core == gcvCORE_MAJOR)
+    while (count--)
     {
-        for (i = 0; i < gcdMULTI_GPU; i++)
-        {
-            gcmkONERROR(gckOS_AtomSet(Kernel->os, eventObj->pending3D[i], gcdEVENT_MASK));
-        }
-    }
-    else
-    {
-        gcmkONERROR(gckOS_AtomSet(Kernel->os, eventObj->pending, gcdEVENT_MASK));
-    }
-#else
-    gcmkONERROR(gckOS_AtomSet(Kernel->os, eventObj->pending, gcdEVENT_MASK));
-#endif
-#else
-#if gcdMULTI_GPU
-    if (Kernel->core == gcvCORE_MAJOR)
-    {
-        for (i = 0; i < gcdMULTI_GPU; i++)
-        {
-            eventObj->pending3D[i] = gcdEVENT_MASK;
-        }
-    }
-    else
-    {
-        eventObj->pending = gcdEVENT_MASK;
+        gcmkONERROR(gckOS_AtomDecrement(
+            Kernel->os,
+            eventObj->interruptCount,
+            &oldValue
+            ));
     }
-#else
-    eventObj->pending = gcdEVENT_MASK;
-#endif
+
+    gckOS_AtomClearMask(Kernel->hardware->pendingEvent, mask);
 #endif
-    gcmkONERROR(gckEVENT_Notify(eventObj, 2));
+
+    gcmkONERROR(gckEVENT_Notify(eventObj, 1));
 
     gcmkVERIFY_OK(gckOS_GetTime(&Kernel->resetTimeStamp));
 
@@ -3711,6 +3761,7 @@ gckKERNEL_AllocateVirtualCommandBuffer(
 #if gcdPROCESS_ADDRESS_SPACE
     gckMMU mmu;
 #endif
+    gctUINT32 flag = gcvALLOC_FLAG_NON_CONTIGUOUS;
 
     gcmkHEADER_ARG("Os=0x%X InUserSpace=%d *Bytes=%lu",
                    os, InUserSpace, gcmOPT_VALUE(Bytes));
@@ -3731,8 +3782,9 @@ gckKERNEL_AllocateVirtualCommandBuffer(
     buffer->bytes = bytes;
 
     gcmkONERROR(gckOS_AllocatePagedMemoryEx(os,
-                                            gcvFALSE,
+                                            flag,
                                             bytes,
+                                            gcvNULL,
                                             &buffer->physical));
 
     if (InUserSpace)
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
index 7e0d2b8..1e0b4a3 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
@@ -210,14 +210,12 @@ typedef struct _gcsDATABASE
     gcsDATABASE_COUNTERS                contiguous;
     gcsDATABASE_COUNTERS                mapUserMemory;
     gcsDATABASE_COUNTERS                mapMemory;
+    gcsDATABASE_COUNTERS                virtualCommandBuffer;
 
     gcsDATABASE_COUNTERS                vidMemType[gcvSURF_NUM_TYPES];
     /* Counter for each video memory pool. */
     gcsDATABASE_COUNTERS                vidMemPool[gcvPOOL_NUMBER_OF_POOLS];
 
-    /* Virtual command buffer */
-    gcsDATABASE_COUNTERS                virtCMDBuf;
-
     /* Idle time management. */
     gctUINT64                           lastIdle;
     gctUINT64                           idle;
@@ -518,8 +516,6 @@ struct _gckKERNEL
     gckDB                       db;
     gctBOOL                     dbCreated;
 
-    gctPOINTER                  resetFlagClearTimer;
-    gctPOINTER                  resetAtom;
     gctUINT64                   resetTimeStamp;
 
     /* Pointer to gckEVENT object. */
@@ -542,7 +538,7 @@ struct _gckKERNEL
     gckDVFS                     dvfs;
 #endif
 
-#if gcdANDROID_NATIVE_FENCE_SYNC
+#if gcdANDROID_NATIVE_FENCE_SYNC && defined(ANDROID)
     gctHANDLE                   timeline;
 #endif
 
@@ -556,6 +552,19 @@ struct _gckKERNEL
     gctUINT32                   securityChannel;
 #endif
 
+    /* Timer to monitor GPU stuck. */
+    gctPOINTER                  monitorTimer;
+
+    /* Flag to quit monitor timer. */
+    gctBOOL                     monitorTimerStop;
+
+    /* Monitor states. */
+    gctBOOL                     monitoring;
+    gctUINT32                   lastCommitStamp;
+    gctUINT32                   timer;
+    gctUINT32                   restoreAddress;
+    gctUINT32                   restoreMask;
+
     gctPOINTER                  vidmemMutex;
 };
 
@@ -748,7 +757,7 @@ struct _gckEVENT
 
     /* Time stamp. */
     gctUINT64                   stamp;
-    gctUINT64                   lastCommitStamp;
+    gctUINT32                   lastCommitStamp;
 
     /* Queue mutex. */
     gctPOINTER                  eventQueueMutex;
@@ -887,8 +896,6 @@ typedef union _gcuVIDMEM_NODE
         /* Information for this node. */
         /* Contiguously allocated? */
         gctBOOL                 contiguous;
-        /* cacheable vidmem ? */
-        gctBOOL                 cacheable;
         /* mdl record pointer... a kmalloc address. Process agnostic. */
         gctPHYS_ADDR            physical;
         gctSIZE_T               bytes;
@@ -903,6 +910,9 @@ typedef union _gcuVIDMEM_NODE
         gctPOINTER              kernelVirtual;
 #endif
 
+        /* Customer private handle */
+        gctUINT32               gid;
+
         /* Page table information. */
         /* Used only when node is not contiguous */
         gctSIZE_T               pageCount;
@@ -951,7 +961,6 @@ struct _gckVIDMEM
     gctSIZE_T                   threshold;
 };
 
-typedef struct _gcsVIDMEM_NODE * gckVIDMEM_NODE;
 typedef struct _gcsVIDMEM_NODE
 {
     /* Pointer to gcuVIDMEM_NODE. */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
index 22c603e..9c59525 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
@@ -358,7 +358,7 @@ _FlushMMU(
     if (pause)
     {
         /* Query size. */
-        gcmkONERROR(gckHARDWARE_Event(hardware, gcvNULL, 0, 0, &eventBytes));
+        gcmkONERROR(gckHARDWARE_Event(hardware, gcvNULL, 0, gcvKERNEL_PIXEL, &eventBytes));
         gcmkONERROR(gckHARDWARE_End(hardware, gcvNULL, &endBytes));
 
         executeBytes = eventBytes + endBytes;
@@ -1713,7 +1713,7 @@ gckCOMMAND_Commit(
                 offset = (Command->pipeSelect == gcvPIPE_3D)
 
                     /* Skip pipe switching sequence. */
-                    ? Context->entryOffset3D + pipeBytes
+                    ? Context->entryOffset3D + Context->pipeSelectBytes
 
                     /* Do not skip pipe switching sequence. */
                     : Context->entryOffset3D;
@@ -2902,11 +2902,7 @@ gckCOMMAND_Stall(
         }
 
     }
-    while (gcmIS_ERROR(status)
-#if gcdGPU_TIMEOUT
-           && (timer < Command->kernel->timeOut)
-#endif
-           );
+    while (gcmIS_ERROR(status));
 
     /* Bail out on timeout. */
     if (gcmIS_ERROR(status))
@@ -2961,6 +2957,7 @@ OnError:
 **          Pointer to a variable that will receive the number of states
 **          in the context buffer.
 */
+#if (gcdENABLE_3D || gcdENABLE_2D)
 gceSTATUS
 gckCOMMAND_Attach(
     IN gckCOMMAND Command,
@@ -3015,6 +3012,7 @@ OnError:
     gcmkFOOTER();
     return status;
 }
+#endif
 
 /*******************************************************************************
 **
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
index 7186ce7..0eafaf6 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
@@ -1070,63 +1070,40 @@ _AllocateLinear(
     )
 {
     gceSTATUS status, last;
-    gcuVIDMEM_NODE_PTR node = gcvNULL;
-    gctUINT32 address = (gctUINT32)~0;
+    gctPOINTER logical;
+    gctPHYS_ADDR physical;
+    gctUINT32 address;
+    gctSIZE_T size = Size;
 
     do
     {
-        gctINT32 i;
-        gctPOINTER pointer = gcvNULL;
-        gcuVIDMEM_NODE_PTR node = gcvNULL;
-
-        gcmkERR_BREAK(gckOS_Allocate(Command->os, gcmSIZEOF(gcuVIDMEM_NODE), &pointer));
-
-        node = pointer;
-
-        /* Initialize gcuVIDMEM_NODE union for virtual memory. */
-        node->Virtual.kernel        = Command->kernel->kernel;
-        node->Virtual.contiguous    = gcvTRUE;
-        node->Virtual.logical       = gcvNULL;
-
-        for (i = 0; i < gcdMAX_GPU_COUNT; i++)
-        {
-            node->Virtual.lockeds[i]        = 0;
-            node->Virtual.pageTables[i]     = gcvNULL;
-            node->Virtual.lockKernels[i]    = gcvNULL;
-        }
-
-        node->Virtual.processID = 0;
-
-        node->Virtual.bytes    = ((Size + Alignment -1)/ Alignment)*Alignment;;
-
-            gcmkERR_BREAK(gckOS_AllocateNonPagedMemory(
-                Command->os,
-                gcvFALSE,
-                &node->Virtual.bytes,
-                &node->Virtual.physical,
-                &node->Virtual.logical
-                ));
+        gcmkERR_BREAK(gckOS_AllocateContiguous(
+            Command->os,
+            gcvFALSE,
+            &size,
+            &physical,
+            &logical
+            ));
 
-        gcmkERR_BREAK(gckOS_GetPhysicalAddress(Command->os,
-                    node->Virtual.logical,&address));
+        gcmkERR_BREAK(gckOS_GetPhysicalAddress(Command->os, logical, &address));
 
         /* Set return values. */
-        * Node    = node;
+        * Node    = physical;
         * Address = address;
-        * Logical = node->Virtual.logical;
-        gcmkPRINT("Allocate success\n");
+        * Logical = logical;
+
         /* Success. */
         return gcvSTATUS_OK;
     }
     while (gcvFALSE);
+
     /* Roll back. */
-    if (node != gcvNULL)
+    if (physical != gcvNULL)
     {
-        /* Free the structure. */
-        gcmkCHECK_STATUS(gcmkOS_SAFE_FREE(Command->os, node));
+        /* Free the command buffer. */
+        gcmkCHECK_STATUS(gckOS_FreeContiguous(Command->os, physical, logical, size));
     }
 
-
     /* Return status. */
     return status;
 }
@@ -1134,23 +1111,15 @@ _AllocateLinear(
 static gceSTATUS
 _FreeLinear(
     IN gckVGKERNEL Kernel,
-    IN gcuVIDMEM_NODE_PTR Node
+    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctPOINTER Logical
     )
 {
-    gceSTATUS status;
+    gceSTATUS status = gcvSTATUS_OK;
 
     do
     {
-
-    /* Free the virtual memory. */
-    gcmkERR_BREAK(gckOS_FreeNonPagedMemory(
-                                    Kernel->kernel->os,
-                                    Node->Virtual.bytes,
-                                    Node->Virtual.physical,
-                                    Node->Virtual.logical));
-
-    /* Destroy the gcuVIDMEM_NODE union. */
-    gcmkERR_BREAK(gckVIDMEM_DestroyVirtual(Node));
+        gcmkERR_BREAK(gckOS_FreeContiguous(Kernel->os, Node, Logical, 1));
     }
     while (gcvFALSE);
 
@@ -1167,6 +1136,7 @@ _AllocateCommandBuffer(
 {
     gceSTATUS status, last;
     gcuVIDMEM_NODE_PTR node = gcvNULL;
+    gcsCMDBUFFER_PTR commandBuffer = gcvNULL;
 
     do
     {
@@ -1174,7 +1144,6 @@ _AllocateCommandBuffer(
         gctUINT requestedSize;
         gctUINT allocationSize;
         gctUINT32 address = 0;
-        gcsCMDBUFFER_PTR commandBuffer = gcvNULL;
         gctUINT8_PTR endCommand;
 
         /* Determine the aligned header size. */
@@ -1242,7 +1211,7 @@ _AllocateCommandBuffer(
     if (node != gcvNULL)
     {
         /* Free the command buffer. */
-        gcmkCHECK_STATUS(_FreeLinear(Command->kernel, node));
+        gcmkCHECK_STATUS(_FreeLinear(Command->kernel, node, commandBuffer));
     }
 
     /* Return status. */
@@ -1258,7 +1227,7 @@ _FreeCommandBuffer(
     gceSTATUS status;
 
     /* Free the buffer. */
-    status = _FreeLinear(Kernel, CommandBuffer->node);
+    status = _FreeLinear(Kernel, CommandBuffer->node, CommandBuffer);
 
     /* Return status. */
     return status;
@@ -1713,7 +1682,7 @@ _TaskUnlockVideoMemory(
         /* Unlock video memory. */
         gcmkERR_BREAK(gckVIDMEM_Unlock(
             Command->kernel->kernel,
-            ((gckVIDMEM_NODE)gcmUINT64_TO_PTR(task->node))->node,
+            (gckVIDMEM_NODE)gcmUINT64_TO_PTR(task->node),
             gcvSURF_TYPE_UNKNOWN,
             gcvNULL));
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
index f2f03e2..c31d465 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
@@ -631,9 +631,9 @@ gckKERNEL_CreateProcessDB(
     database->mapUserMemory.bytes      = 0;
     database->mapUserMemory.maxBytes   = 0;
     database->mapUserMemory.totalBytes = 0;
-    database->virtCMDBuf.bytes = 0;
-    database->virtCMDBuf.maxBytes = 0;
-    database->virtCMDBuf.totalBytes = 0;
+    database->virtualCommandBuffer.bytes = 0;
+    database->virtualCommandBuffer.maxBytes = 0;
+    database->virtualCommandBuffer.totalBytes = 0;
 
     for (i = 0; i < gcmCOUNTOF(database->list); i++)
     {
@@ -895,7 +895,7 @@ gckKERNEL_AddProcessDB(
         break;
 
     case gcvDB_COMMAND_BUFFER:
-        count = &database->virtCMDBuf;
+        count = &database->virtualCommandBuffer;
         break;
 
     default:
@@ -1048,7 +1048,7 @@ gckKERNEL_RemoveProcessDB(
         break;
 
     case gcvDB_COMMAND_BUFFER:
-        database->virtCMDBuf.bytes -= bytes;
+        database->virtualCommandBuffer.bytes -= bytes;
         break;
 
     default:
@@ -1344,7 +1344,7 @@ gckKERNEL_DestroyProcessDB(
 
             /* Unlock what we still locked */
             status = gckVIDMEM_Unlock(record->kernel,
-                                      nodeObject->node,
+                                      nodeObject,
                                       nodeObject->type,
                                       &asynchronous);
 
@@ -1355,7 +1355,7 @@ gckKERNEL_DestroyProcessDB(
                 {
                     /* TODO: we maybe need to schedule a event here */
                     status = gckVIDMEM_Unlock(record->kernel,
-                                              nodeObject->node,
+                                              nodeObject,
                                               nodeObject->type,
                                               gcvNULL);
                 }
@@ -1430,7 +1430,7 @@ gckKERNEL_DestroyProcessDB(
                            gcmPTR2INT32(record->data), status);
             break;
 
-#if gcdANDROID_NATIVE_FENCE_SYNC
+#if gcdANDROID_NATIVE_FENCE_SYNC && defined(ANDROID)
         case gcvDB_SYNC_POINT:
             /* Free the user signal. */
             status = gckOS_DestroySyncPoint(Kernel->os,
@@ -1553,9 +1553,8 @@ gckKERNEL_QueryProcessDB(
     acquired = gcvTRUE;
 
     /* Find the database. */
-    if(Type != gcvDB_IDLE)
-        gcmkONERROR(
-            gckKERNEL_FindDatabase(Kernel, ProcessID, LastProcessID, &database));
+    gcmkONERROR(
+        gckKERNEL_FindDatabase(Kernel, ProcessID, LastProcessID, &database));
 
     /* Get pointer to counters. */
     switch (Type)
@@ -1606,8 +1605,8 @@ gckKERNEL_QueryProcessDB(
 
     case gcvDB_COMMAND_BUFFER:
         gckOS_MemCopy(&Info->counters,
-                                  &database->virtCMDBuf,
-                                  gcmSIZEOF(database->virtCMDBuf));
+                                  &database->virtualCommandBuffer,
+                                  gcmSIZEOF(database->virtualCommandBuffer));
         break;
 
     default:
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
index 780d7e3..7813441 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
@@ -2559,6 +2559,39 @@ gckOS_DebugStatus2Name(
         return "gcvSTATUS_NAME_MISMATCH";
     case gcvSTATUS_INVALID_INDEX:
         return "gcvSTATUS_INVALID_INDEX";
+    case gcvSTATUS_UNIFORM_MISMATCH:
+        return "gcvSTATUS_UNIFORM_MISMATCH";
+    case gcvSTATUS_UNSAT_LIB_SYMBOL:
+        return "gcvSTATUS_UNSAT_LIB_SYMBOL";
+    case gcvSTATUS_TOO_MANY_SHADERS:
+        return "gcvSTATUS_TOO_MANY_SHADERS";
+    case gcvSTATUS_LINK_INVALID_SHADERS:
+        return "gcvSTATUS_LINK_INVALID_SHADERS";
+    case gcvSTATUS_CS_NO_WORKGROUP_SIZE:
+        return "gcvSTATUS_CS_NO_WORKGROUP_SIZE";
+    case gcvSTATUS_LINK_LIB_ERROR:
+        return "gcvSTATUS_LINK_LIB_ERROR";
+    case gcvSTATUS_SHADER_VERSION_MISMATCH:
+        return "gcvSTATUS_SHADER_VERSION_MISMATCH";
+    case gcvSTATUS_TOO_MANY_INSTRUCTION:
+        return "gcvSTATUS_TOO_MANY_INSTRUCTION";
+    case gcvSTATUS_SSBO_MISMATCH:
+        return "gcvSTATUS_SSBO_MISMATCH";
+    case gcvSTATUS_TOO_MANY_OUTPUT:
+        return "gcvSTATUS_TOO_MANY_OUTPUT";
+    case gcvSTATUS_TOO_MANY_INPUT:
+        return "gcvSTATUS_TOO_MANY_INPUT";
+    case gcvSTATUS_NOT_SUPPORT_CL:
+        return "gcvSTATUS_NOT_SUPPORT_CL";
+    case gcvSTATUS_NOT_SUPPORT_INTEGER:
+        return "gcvSTATUS_NOT_SUPPORT_INTEGER";
+
+    /* Compiler errors. */
+    case gcvSTATUS_COMPILER_FE_PREPROCESSOR_ERROR:
+        return "gcvSTATUS_COMPILER_FE_PREPROCESSOR_ERROR";
+    case gcvSTATUS_COMPILER_FE_PARSER_ERROR:
+        return "gcvSTATUS_COMPILER_FE_PARSER_ERROR";
+
     default:
         return "nil";
     }
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
index e7b157c..3ceff80 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
@@ -803,10 +803,6 @@ gckEVENT_GetEvent(
     gctINT j;
 #endif
 
-#if gcdGPU_TIMEOUT
-    gctUINT32 timer = 0;
-#endif
-
     gcmkHEADER_ARG("Event=0x%x Source=%d", Event, Source);
 
     while (gcvTRUE)
@@ -911,42 +907,6 @@ gckEVENT_GetEvent(
 
         /* Delay a while. */
         gcmkONERROR(gckOS_Delay(Event->os, 1));
-
-#if gcdGPU_TIMEOUT
-        /* Increment the wait timer. */
-        timer += 1;
-
-        if (timer == Event->kernel->timeOut)
-        {
-            /* Try to call any outstanding events. */
-#if gcdMULTI_GPU
-            gcmkONERROR(gckHARDWARE_Interrupt(Event->kernel->hardware,
-                                              gcvCORE_3D_0_ID,
-                                              gcvTRUE));
-#if gcdMULTI_GPU > 1
-            gcmkONERROR(gckHARDWARE_Interrupt(Event->kernel->hardware,
-                                              gcvCORE_3D_1_ID,
-                                              gcvTRUE));
-
-#endif
-#else
-            gcmkONERROR(gckHARDWARE_Interrupt(Event->kernel->hardware,
-                                              gcvTRUE));
-#endif
-        }
-        else if (timer > Event->kernel->timeOut)
-        {
-            gcmkTRACE_N(
-                gcvLEVEL_ERROR,
-                gcmSIZEOF(gctCONST_STRING) + gcmSIZEOF(gctINT),
-                "%s(%d): no available events\n",
-                __FUNCTION__, __LINE__
-                );
-
-            /* Bail out. */
-            gcmkONERROR(gcvSTATUS_GPU_NOT_RESPONDING);
-        }
-#endif
     }
 
 OnError:
@@ -1713,6 +1673,8 @@ gckEVENT_Submit(
 
     gcmkVERIFY_OBJECT(hardware, gcvOBJ_HARDWARE);
 
+    gckOS_GetTicks(&Event->lastCommitStamp);
+
     /* Are there event queues? */
     if (Event->queueHead != gcvNULL)
     {
@@ -1885,18 +1847,18 @@ gckEVENT_Submit(
     return gcvSTATUS_OK;
 
 OnError:
-    if (commitEntered)
-    {
-        /* Release the command queue mutex. */
-        gcmkVERIFY_OK(gckCOMMAND_ExitCommit(command, FromPower));
-    }
-
     if (acquired)
     {
         /* Need to unroll the mutex acquire. */
         gcmkVERIFY_OK(gckOS_ReleaseMutex(Event->os, Event->eventListMutex));
     }
 
+    if (commitEntered)
+    {
+        /* Release the command queue mutex. */
+        gcmkVERIFY_OK(gckCOMMAND_ExitCommit(command, FromPower));
+    }
+
     if (id != 0xFF)
     {
         /* Need to unroll the event allocation. */
@@ -2487,7 +2449,6 @@ gckEVENT_Notify(
         if (pending & 0x80000000)
         {
             gcmkPRINT("AXI BUS ERROR");
-            gckHARDWARE_DumpMMUException(Event->kernel->hardware);
             pending &= 0x7FFFFFFF;
         }
 
@@ -2879,7 +2840,7 @@ gckEVENT_Notify(
                 /* Unlock. */
                 status = gckVIDMEM_Unlock(
                     Event->kernel,
-                    node,
+                    nodeObject,
                     record->info.u.UnlockVideoMemory.type,
                     gcvNULL);
 
@@ -3026,7 +2987,7 @@ gckEVENT_Notify(
                  gcmRELEASE_NAME(record->info.u.FreeVirtualCommandBuffer.physical);
                  break;
 
-#if gcdANDROID_NATIVE_FENCE_SYNC
+#if gcdANDROID_NATIVE_FENCE_SYNC && defined(ANDROID)
             case gcvHAL_SYNC_POINT:
                 {
                     gctSYNC_POINT syncPoint;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
index c5494e0..eac565c 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
@@ -218,6 +218,147 @@ gceSTATUS gckVGKERNEL_Destroy(
 
 /*******************************************************************************
 **
+**  gckKERNEL_AllocateLinearMemory
+**
+**  Function walks all required memory pools and allocates the requested
+**  amount of video memory.
+**
+**  INPUT:
+**
+**      gckKERNEL Kernel
+**          Pointer to an gckKERNEL object.
+**
+**      gcePOOL * Pool
+**          Pointer the desired memory pool.
+**
+**      gctSIZE_T Bytes
+**          Number of bytes to allocate.
+**
+**      gctSIZE_T Alignment
+**          Required buffer alignment.
+**
+**      gceSURF_TYPE Type
+**          Surface type.
+**
+**  OUTPUT:
+**
+**      gcePOOL * Pool
+**          Pointer to the actual pool where the memory was allocated.
+**
+**      gcuVIDMEM_NODE_PTR * Node
+**          Allocated node.
+*/
+gceSTATUS
+gckVGKERNEL_AllocateLinearMemory(
+    IN gckKERNEL Kernel,
+    IN OUT gcePOOL * Pool,
+    IN gctSIZE_T Bytes,
+    IN gctUINT32 Alignment,
+    IN gceSURF_TYPE Type,
+    OUT gcuVIDMEM_NODE_PTR * Node
+    )
+{
+    gcePOOL pool;
+    gceSTATUS status;
+    gckVIDMEM videoMemory;
+
+    /* Get initial pool. */
+    switch (pool = *Pool)
+    {
+    case gcvPOOL_DEFAULT:
+    case gcvPOOL_LOCAL:
+        pool = gcvPOOL_LOCAL_INTERNAL;
+        break;
+
+    case gcvPOOL_UNIFIED:
+        pool = gcvPOOL_SYSTEM;
+        break;
+
+    default:
+        break;
+    }
+
+    do
+    {
+        /* Verify the number of bytes to allocate. */
+        if (Bytes == 0)
+        {
+            status = gcvSTATUS_INVALID_ARGUMENT;
+            break;
+        }
+
+        if (pool == gcvPOOL_VIRTUAL)
+        {
+            /* Create a gcuVIDMEM_NODE for virtual memory. */
+            gcmkERR_BREAK(gckVIDMEM_ConstructVirtual(Kernel, gcvFALSE, Bytes, Node));
+
+            /* Success. */
+            break;
+        }
+
+        else
+        {
+            /* Get pointer to gckVIDMEM object for pool. */
+            status = gckKERNEL_GetVideoMemoryPool(Kernel, pool, &videoMemory);
+
+            if (status == gcvSTATUS_OK)
+            {
+                /* Allocate memory. */
+                status = gckVIDMEM_AllocateLinear(Kernel,
+                                                  videoMemory,
+                                                  Bytes,
+                                                  Alignment,
+                                                  Type,
+                                                  (*Pool == gcvPOOL_SYSTEM),
+                                                  Node);
+
+                if (status == gcvSTATUS_OK)
+                {
+                    /* Memory allocated. */
+                    break;
+                }
+            }
+        }
+
+        if (pool == gcvPOOL_LOCAL_INTERNAL)
+        {
+            /* Advance to external memory. */
+            pool = gcvPOOL_LOCAL_EXTERNAL;
+        }
+        else if (pool == gcvPOOL_LOCAL_EXTERNAL)
+        {
+            /* Advance to contiguous system memory. */
+            pool = gcvPOOL_SYSTEM;
+        }
+        else if (pool == gcvPOOL_SYSTEM)
+        {
+            /* Advance to virtual memory. */
+            pool = gcvPOOL_VIRTUAL;
+        }
+        else
+        {
+            /* Out of pools. */
+            break;
+        }
+    }
+    /* Loop only for multiple selection pools. */
+    while ((*Pool == gcvPOOL_DEFAULT)
+    ||     (*Pool == gcvPOOL_LOCAL)
+    ||     (*Pool == gcvPOOL_UNIFIED)
+    );
+
+    if (gcmIS_SUCCESS(status))
+    {
+        /* Return pool used for allocation. */
+        *Pool = pool;
+    }
+
+    /* Return status. */
+    return status;
+}
+
+/*******************************************************************************
+**
 **  gckKERNEL_Dispatch
 **
 **  Dispatch a command received from the user HAL layer.
@@ -443,6 +584,7 @@ gceSTATUS gckVGKERNEL_Dispatch(
 
         gcmRELEASE_NAME(kernelInterface->u.UnmapUserMemory.info);
         break;
+
     case gcvHAL_LOCK_VIDEO_MEMORY:
         gcmkONERROR(gckKERNEL_LockVideoMemory(Kernel, gcvCORE_VG, processID, FromUser, Interface));
         break;
@@ -450,6 +592,7 @@ gceSTATUS gckVGKERNEL_Dispatch(
     case gcvHAL_UNLOCK_VIDEO_MEMORY:
         gcmkONERROR(gckKERNEL_UnlockVideoMemory(Kernel, processID, Interface));
         break;
+
     case gcvHAL_USER_SIGNAL:
 #if !USE_NEW_LINUX_SIGNAL
         /* Dispatch depends on the user signal subcommands. */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
index 41f335e..4b03f1d7 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
@@ -23,21 +23,6 @@
 
 #define _GC_OBJ_ZONE    gcvZONE_VIDMEM
 
-
-#if LINUX_CMA_FSL
-extern gceSTATUS
-gckOS_AllocateCMAMemoryFSL(
-    IN gckOS Os,
-    IN OUT gctSIZE_T * Bytes,
-    OUT gctPHYS_ADDR * Physical
-    );
-extern gceSTATUS 
-gckOS_FreeCMAMemoryFSL(
-    IN gckOS Os,
-    IN gctSIZE_T Bytes,
-    IN gctPHYS_ADDR Physical
-    );   
-#endif
 /******************************************************************************\
 ******************************* Private Functions ******************************
 \******************************************************************************/
@@ -208,9 +193,8 @@ _Merge(
 gceSTATUS
 gckVIDMEM_ConstructVirtual(
     IN gckKERNEL Kernel,
-    IN gctBOOL Contiguous,
+    IN gctUINT32 Flag,
     IN gctSIZE_T Bytes,
-    IN gctBOOL cacheable,
     OUT gcuVIDMEM_NODE_PTR * Node
     )
 {
@@ -219,9 +203,8 @@ gckVIDMEM_ConstructVirtual(
     gcuVIDMEM_NODE_PTR node = gcvNULL;
     gctPOINTER pointer = gcvNULL;
     gctINT i;
-    gctBOOL tempContiguous = Contiguous;
 
-    gcmkHEADER_ARG("Kernel=0x%x Contiguous=%d Bytes=%lu", Kernel, Contiguous, Bytes);
+    gcmkHEADER_ARG("Kernel=0x%x Flag=%x Bytes=%lu", Kernel, Flag, Bytes);
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
@@ -237,17 +220,10 @@ gckVIDMEM_ConstructVirtual(
 
     node = pointer;
 
-    if ( Contiguous == (gcvFALSE + gcvALLOC_FLAG_MEMLIMIT)
-    || Contiguous == (gcvTRUE + gcvALLOC_FLAG_MEMLIMIT))
-    {
-        tempContiguous = Contiguous - gcvALLOC_FLAG_MEMLIMIT;
-    }
-
     /* Initialize gcuVIDMEM_NODE union for virtual memory. */
     node->Virtual.kernel        = Kernel;
-    node->Virtual.contiguous    = tempContiguous;
+    node->Virtual.contiguous    = Flag & gcvALLOC_FLAG_CONTIGUOUS;
     node->Virtual.logical       = gcvNULL;
-    node->Virtual.cacheable      = cacheable;
 #if gcdENABLE_VG
     node->Virtual.kernelVirtual = gcvNULL;
 #endif
@@ -261,36 +237,14 @@ gckVIDMEM_ConstructVirtual(
 
     gcmkONERROR(gckOS_GetProcessID(&node->Virtual.processID));
 
-#if LINUX_CMA_FSL
-    if(node->Virtual.contiguous && (!node->Virtual.cacheable))
-    {
-        gctSIZE_T size;
-        gceSTATUS ret;
-   
-        node->Virtual.bytes = Bytes;
-        size = Bytes;
-        ret = gckOS_AllocateCMAMemoryFSL(os,
-                                        &size,
-                                        &node->Virtual.physical);
-        if(ret == gcvSTATUS_OUT_OF_MEMORY)
-        {
-            /*CMA memory is used up, try to use high memory*/
-            node->Virtual.cacheable = gcvTRUE;
-        }
-        else 
-        {
-            gcmkONERROR(ret);
-        }
-    }
-    if((!node->Virtual.contiguous) || node->Virtual.cacheable)
-#endif
-    {
-        gcmkONERROR(
-            gckOS_AllocatePagedMemoryEx(os,
-                                        Contiguous,
-                                        node->Virtual.bytes = Bytes,
-                                        &node->Virtual.physical));
-    }
+    /* Allocate the virtual memory. */
+    gcmkONERROR(
+        gckOS_AllocatePagedMemoryEx(os,
+                                    Flag,
+                                    node->Virtual.bytes = Bytes,
+                                    &node->Virtual.gid,
+                                    &node->Virtual.physical));
+
     /* Return pointer to the gcuVIDMEM_NODE union. */
     *Node = node;
 
@@ -892,7 +846,7 @@ gckVIDMEM_AllocateLinear(
     gcmkVERIFY_ARGUMENT(Type < gcvSURF_NUM_TYPES);
 
     /* Acquire the mutex. */
-    gcmkONERROR(gckOS_AcquireMutex(Memory->os, Kernel->vidmemMutex, gcvINFINITE));
+    gcmkONERROR(gckOS_AcquireMutex(Kernel->os, Kernel->vidmemMutex, gcvINFINITE));
 
     acquired = gcvTRUE;
 
@@ -1008,7 +962,7 @@ gckVIDMEM_AllocateLinear(
 #endif
 
     /* Release the mutex. */
-    gcmkVERIFY_OK(gckOS_ReleaseMutex(Memory->os, Kernel->vidmemMutex));
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->vidmemMutex));
 
     /* Return the pointer to the node. */
     *Node = node;
@@ -1025,7 +979,7 @@ OnError:
     if (acquired)
     {
      /* Release the mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(Memory->os, Kernel->vidmemMutex));
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->vidmemMutex));
     }
 
     /* Return the status. */
@@ -1206,21 +1160,11 @@ gckVIDMEM_Free(
     }
 #endif
 
-#if LINUX_CMA_FSL
-    if(Node->Virtual.contiguous  && (!Node->Virtual.cacheable))
-    {
-        gcmkVERIFY_OK(gckOS_FreeCMAMemoryFSL(kernel->os,
-                                        Node->Virtual.bytes,
-                                        Node->Virtual.physical));
-    }
-    else
-#endif
-    {
-        /* Free the virtual memory. */
-        gcmkVERIFY_OK(gckOS_FreePagedMemory(kernel->os,
-                                            Node->Virtual.physical,
-                                            Node->Virtual.bytes));
-    }
+    /* Free the virtual memory. */
+    gcmkVERIFY_OK(gckOS_FreePagedMemory(kernel->os,
+                                        Node->Virtual.physical,
+                                        Node->Virtual.bytes));
+
     /* Destroy the gcuVIDMEM_NODE union. */
     gcmkVERIFY_OK(gckVIDMEM_DestroyVirtual(Node));
 
@@ -1457,9 +1401,10 @@ _DestroyGPUMap(
 gceSTATUS
 gckVIDMEM_Lock(
     IN gckKERNEL Kernel,
-    IN gcuVIDMEM_NODE_PTR Node,
+    IN gckVIDMEM_NODE Node,
     IN gctBOOL Cacheable,
     OUT gctUINT32 * Address,
+    OUT gctUINT32 * Gid,
     OUT gctUINT64 * PhysicalAddress
     )
 {
@@ -1472,18 +1417,24 @@ gckVIDMEM_Lock(
 #endif
     gctUINT32 baseAddress;
     gctUINT32 physicalAddress;
+    gcuVIDMEM_NODE_PTR node = Node->node;
 
     gcmkHEADER_ARG("Node=0x%x", Node);
 
     /* Verify the arguments. */
     gcmkVERIFY_ARGUMENT(Address != gcvNULL);
+    gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
+
+    /* Extract the gckOS object pointer. */
+    os = Kernel->os;
+    gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
 
     /* Grab the mutex. */
     gcmkONERROR(gckOS_AcquireMutex(Kernel->os, Kernel->vidmemMutex, gcvINFINITE));
     acquired = gcvTRUE;
 
-    if ((Node == gcvNULL)
-    ||  (Node->VidMem.memory == gcvNULL)
+    if ((node == gcvNULL)
+    ||  (node->VidMem.memory == gcvNULL)
     )
     {
         /* Invalid object. */
@@ -1492,7 +1443,7 @@ gckVIDMEM_Lock(
 
     /**************************** Video Memory ********************************/
 
-    if (Node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
+    if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
     {
         gctUINT32 offset;
 
@@ -1502,14 +1453,14 @@ gckVIDMEM_Lock(
         }
 
         /* Increment the lock count. */
-        Node->VidMem.locked ++;
+        node->VidMem.locked ++;
 
         /* Return the physical address of the node. */
-        gcmkSAFECASTSIZET(offset, Node->VidMem.offset);
+        gcmkSAFECASTSIZET(offset, node->VidMem.offset);
 
-        *Address = Node->VidMem.memory->baseAddress
+        *Address = node->VidMem.memory->baseAddress
                  + offset
-                 + Node->VidMem.alignment;
+                 + node->VidMem.alignment;
 
         physicalAddress = *Address;
 
@@ -1535,8 +1486,8 @@ gckVIDMEM_Lock(
 
         gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
                       "Locked node 0x%x (%d) @ 0x%08X",
-                      Node,
-                      Node->VidMem.locked,
+                      node,
+                      node->VidMem.locked,
                       *Address);
     }
 
@@ -1544,12 +1495,8 @@ gckVIDMEM_Lock(
 
     else
     {
-        /* Verify the gckKERNEL object pointer. */
-        gcmkVERIFY_OBJECT(Node->Virtual.kernel, gcvOBJ_KERNEL);
 
-        /* Extract the gckOS object pointer. */
-        os = Node->Virtual.kernel->os;
-        gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
+        *Gid = node->Virtual.gid;
 
 #if gcdPAGED_MEMORY_CACHEABLE
         /* Force video memory cacheable. */
@@ -1558,29 +1505,29 @@ gckVIDMEM_Lock(
 
         gcmkONERROR(
             gckOS_LockPages(os,
-                            Node->Virtual.physical,
-                            Node->Virtual.bytes,
+                            node->Virtual.physical,
+                            node->Virtual.bytes,
                             Cacheable,
-                            &Node->Virtual.logical,
-                            &Node->Virtual.pageCount));
+                            &node->Virtual.logical,
+                            &node->Virtual.pageCount));
 
         gcmkONERROR(gckOS_GetPhysicalAddress(
             os,
-            Node->Virtual.logical,
+            node->Virtual.logical,
             &physicalAddress
             ));
 
 #if gcdENABLE_VG
-        Node->Virtual.physicalAddress = physicalAddress;
+        node->Virtual.physicalAddress = physicalAddress;
 #endif
 
 #if !gcdPROCESS_ADDRESS_SPACE
         /* Increment the lock count. */
-        if (Node->Virtual.lockeds[Kernel->core] ++ == 0)
+        if (node->Virtual.lockeds[Kernel->core] ++ == 0)
         {
             locked = gcvTRUE;
 
-            gcmkONERROR(_NeedVirtualMapping(Kernel, Kernel->core, Node, &needMapping));
+            gcmkONERROR(_NeedVirtualMapping(Kernel, Kernel->core, node, &needMapping));
 
             if (needMapping == gcvFALSE)
             {
@@ -1590,18 +1537,18 @@ gckVIDMEM_Lock(
                 {
                     gcmkONERROR(gckVGHARDWARE_ConvertLogical(
                                 Kernel->vg->hardware,
-                                Node->Virtual.logical,
+                                node->Virtual.logical,
                                 gcvTRUE,
-                                &Node->Virtual.addresses[Kernel->core]));
+                                &node->Virtual.addresses[Kernel->core]));
                 }
                 else
 #endif
                 {
                     gcmkONERROR(gckHARDWARE_ConvertLogical(
                                 Kernel->hardware,
-                                Node->Virtual.logical,
+                                node->Virtual.logical,
                                 gcvTRUE,
-                                &Node->Virtual.addresses[Kernel->core]));
+                                &node->Virtual.addresses[Kernel->core]));
                 }
             }
             else
@@ -1612,8 +1559,8 @@ gckVIDMEM_Lock(
 
                 gcmkONERROR(gckOS_AllocatePageArray(
                     os,
-                    Node->Virtual.physical,
-                    Node->Virtual.pageCount,
+                    node->Virtual.physical,
+                    node->Virtual.pageCount,
                     &physicalArrayLogical,
                     &physicalArrayPhysical
                     ));
@@ -1621,8 +1568,8 @@ gckVIDMEM_Lock(
                 gcmkONERROR(gckKERNEL_SecurityMapMemory(
                     Kernel,
                     physicalArrayLogical,
-                    Node->Virtual.pageCount,
-                    &Node->Virtual.addresses[Kernel->core]
+                    node->Virtual.pageCount,
+                    &node->Virtual.addresses[Kernel->core]
                     ));
 
                 gcmkONERROR(gckOS_FreeNonPagedMemory(
@@ -1638,9 +1585,9 @@ gckVIDMEM_Lock(
                     /* Allocate pages inside the MMU. */
                     gcmkONERROR(
                         gckVGMMU_AllocatePages(Kernel->vg->mmu,
-                                             Node->Virtual.pageCount,
-                                             &Node->Virtual.pageTables[Kernel->core],
-                                             &Node->Virtual.addresses[Kernel->core]));
+                                             node->Virtual.pageCount,
+                                             &node->Virtual.pageTables[Kernel->core],
+                                             &node->Virtual.addresses[Kernel->core]));
                 }
                 else
 #endif
@@ -1648,21 +1595,21 @@ gckVIDMEM_Lock(
                     /* Allocate pages inside the MMU. */
                     gcmkONERROR(
                         gckMMU_AllocatePagesEx(Kernel->mmu,
-                                             Node->Virtual.pageCount,
-                                             Node->Virtual.type,
-                                             &Node->Virtual.pageTables[Kernel->core],
-                                             &Node->Virtual.addresses[Kernel->core]));
+                                             node->Virtual.pageCount,
+                                             node->Virtual.type,
+                                             &node->Virtual.pageTables[Kernel->core],
+                                             &node->Virtual.addresses[Kernel->core]));
                 }
 
-                Node->Virtual.lockKernels[Kernel->core] = Kernel;
+                node->Virtual.lockKernels[Kernel->core] = Kernel;
 
                 /* Map the pages. */
                 gcmkONERROR(
                     gckOS_MapPagesEx(os,
                                      Kernel->core,
-                                     Node->Virtual.physical,
-                                     Node->Virtual.pageCount,
-                                     Node->Virtual.pageTables[Kernel->core]));
+                                     node->Virtual.physical,
+                                     node->Virtual.pageCount,
+                                     node->Virtual.pageTables[Kernel->core]));
 
 #if gcdENABLE_VG
                 if (Kernel->core == gcvCORE_VG)
@@ -1672,20 +1619,19 @@ gckVIDMEM_Lock(
                 else
 #endif
                 {
-                    gcmkONERROR(gckMMU_Flush(Kernel->mmu, Node->Virtual.type));
+                    gcmkONERROR(gckMMU_Flush(Kernel->mmu, node->Virtual.type));
                 }
 #endif
             }
             gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
                            "Mapped virtual node 0x%x to 0x%08X",
-                           Node,
-                           Node->Virtual.addresses[Kernel->core]);
+                           node,
+                           node->Virtual.addresses[Kernel->core]);
         }
 
         /* Return hardware address. */
-        *Address = Node->Virtual.addresses[Kernel->core];
+        *Address = node->Virtual.addresses[Kernel->core];
 #endif
-
     }
 
     *PhysicalAddress = (gctUINT64)physicalAddress;
@@ -1700,7 +1646,7 @@ gckVIDMEM_Lock(
 OnError:
     if (locked)
     {
-        if (Node->Virtual.pageTables[Kernel->core] != gcvNULL)
+        if (node->Virtual.pageTables[Kernel->core] != gcvNULL)
         {
 #if gcdENABLE_VG
             if (Kernel->vg != gcvNULL)
@@ -1708,8 +1654,8 @@ OnError:
                 /* Free the pages from the MMU. */
                 gcmkVERIFY_OK(
                     gckVGMMU_FreePages(Kernel->vg->mmu,
-                                     Node->Virtual.pageTables[Kernel->core],
-                                     Node->Virtual.pageCount));
+                                     node->Virtual.pageTables[Kernel->core],
+                                     node->Virtual.pageCount));
             }
             else
 #endif
@@ -1717,22 +1663,22 @@ OnError:
                 /* Free the pages from the MMU. */
                 gcmkVERIFY_OK(
                     gckMMU_FreePages(Kernel->mmu,
-                                     Node->Virtual.pageTables[Kernel->core],
-                                     Node->Virtual.pageCount));
+                                     node->Virtual.pageTables[Kernel->core],
+                                     node->Virtual.pageCount));
             }
-            Node->Virtual.pageTables[Kernel->core]  = gcvNULL;
-            Node->Virtual.lockKernels[Kernel->core] = gcvNULL;
+            node->Virtual.pageTables[Kernel->core]  = gcvNULL;
+            node->Virtual.lockKernels[Kernel->core] = gcvNULL;
         }
 
         /* Unlock the pages. */
         gcmkVERIFY_OK(
             gckOS_UnlockPages(os,
-                              Node->Virtual.physical,
-                              Node->Virtual.bytes,
-                              Node->Virtual.logical
+                              node->Virtual.physical,
+                              node->Virtual.bytes,
+                              node->Virtual.logical
                               ));
 
-        Node->Virtual.lockeds[Kernel->core]--;
+        node->Virtual.lockeds[Kernel->core]--;
     }
 
     if (acquired)
@@ -1777,7 +1723,7 @@ OnError:
 gceSTATUS
 gckVIDMEM_Unlock(
     IN gckKERNEL Kernel,
-    IN gcuVIDMEM_NODE_PTR Node,
+    IN gckVIDMEM_NODE Node,
     IN gceSURF_TYPE Type,
     IN OUT gctBOOL * Asynchroneous
     )
@@ -1785,17 +1731,24 @@ gckVIDMEM_Unlock(
     gceSTATUS status;
     gckOS os = gcvNULL;
     gctBOOL acquired = gcvFALSE;
+    gcuVIDMEM_NODE_PTR node = Node->node;
 
     gcmkHEADER_ARG("Node=0x%x Type=%d *Asynchroneous=%d",
                    Node, Type, gcmOPT_VALUE(Asynchroneous));
 
+    gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
+
+    /* Get the gckOS object pointer. */
+    os = Kernel->os;
+    gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
+
     /* Grab the mutex. */
     gcmkONERROR(gckOS_AcquireMutex(Kernel->os, Kernel->vidmemMutex, gcvINFINITE));
     acquired = gcvTRUE;
 
     /* Verify the arguments. */
-    if ((Node == gcvNULL)
-    ||  (Node->VidMem.memory == gcvNULL)
+    if ((node == gcvNULL)
+    ||  (node->VidMem.memory == gcvNULL)
     )
     {
         /* Invalid object. */
@@ -1804,9 +1757,9 @@ gckVIDMEM_Unlock(
 
     /**************************** Video Memory ********************************/
 
-    if (Node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
+    if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
     {
-        if (Node->VidMem.locked <= 0)
+        if (node->VidMem.locked <= 0)
         {
             /* The surface was not locked. */
             status = gcvSTATUS_MEMORY_UNLOCKED;
@@ -1821,77 +1774,74 @@ gckVIDMEM_Unlock(
         else
         {
             /* Decrement the lock count. */
-            Node->VidMem.locked --;
+            node->VidMem.locked --;
         }
 
         gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
                       "Unlocked node 0x%x (%d)",
-                      Node,
-                      Node->VidMem.locked);
+                      node,
+                      node->VidMem.locked);
     }
 
     /*************************** Virtual Memory *******************************/
 
     else
     {
-        /* Get the gckOS object pointer. */
-        os = Kernel->os;
-        gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
 
         if (Asynchroneous == gcvNULL)
         {
 #if !gcdPROCESS_ADDRESS_SPACE
-            if (Node->Virtual.lockeds[Kernel->core] == 0)
+            if (node->Virtual.lockeds[Kernel->core] == 0)
             {
                 status = gcvSTATUS_MEMORY_UNLOCKED;
                 goto OnError;
             }
 
             /* Decrement lock count. */
-            -- Node->Virtual.lockeds[Kernel->core];
+            -- node->Virtual.lockeds[Kernel->core];
 
             /* See if we can unlock the resources. */
-            if (Node->Virtual.lockeds[Kernel->core] == 0)
+            if (node->Virtual.lockeds[Kernel->core] == 0)
             {
 #if gcdSECURITY
-                if (Node->Virtual.addresses[Kernel->core] > 0x80000000)
+                if (node->Virtual.addresses[Kernel->core] > 0x80000000)
                 {
                     gcmkONERROR(gckKERNEL_SecurityUnmapMemory(
                         Kernel,
-                        Node->Virtual.addresses[Kernel->core],
-                        Node->Virtual.pageCount
+                        node->Virtual.addresses[Kernel->core],
+                        node->Virtual.pageCount
                         ));
                 }
 #else
                 /* Free the page table. */
-                if (Node->Virtual.pageTables[Kernel->core] != gcvNULL)
+                if (node->Virtual.pageTables[Kernel->core] != gcvNULL)
                 {
 #if gcdENABLE_VG
                     if (Kernel->vg != gcvNULL)
                     {
                         gcmkONERROR(
                             gckVGMMU_FreePages(Kernel->vg->mmu,
-                                             Node->Virtual.pageTables[Kernel->core],
-                                             Node->Virtual.pageCount));
+                                             node->Virtual.pageTables[Kernel->core],
+                                             node->Virtual.pageCount));
                     }
                     else
 #endif
                     {
                         gcmkONERROR(
                             gckMMU_FreePages(Kernel->mmu,
-                                             Node->Virtual.pageTables[Kernel->core],
-                                             Node->Virtual.pageCount));
+                                             node->Virtual.pageTables[Kernel->core],
+                                             node->Virtual.pageCount));
                     }
                     /* Mark page table as freed. */
-                    Node->Virtual.pageTables[Kernel->core] = gcvNULL;
-                    Node->Virtual.lockKernels[Kernel->core] = gcvNULL;
+                    node->Virtual.pageTables[Kernel->core] = gcvNULL;
+                    node->Virtual.lockKernels[Kernel->core] = gcvNULL;
                 }
 #endif
             }
 
             gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
                            "Unmapped virtual node 0x%x from 0x%08X",
-                           Node, Node->Virtual.addresses[Kernel->core]);
+                           node, node->Virtual.addresses[Kernel->core]);
 #endif
 
         }
@@ -1900,13 +1850,13 @@ gckVIDMEM_Unlock(
         {
             gcmkONERROR(
                 gckOS_UnlockPages(os,
-                              Node->Virtual.physical,
-                              Node->Virtual.bytes,
-                              Node->Virtual.logical));
+                              node->Virtual.physical,
+                              node->Virtual.bytes,
+                              node->Virtual.logical));
 
             gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
                            "Scheduled unlock for virtual node 0x%x",
-                           Node);
+                           node);
 
             /* Schedule the surface to be unlocked. */
             *Asynchroneous = gcvTRUE;
@@ -2530,7 +2480,7 @@ OnError:
 #if gcdPROCESS_ADDRESS_SPACE
         if (node->mapMutex != gcvNULL)
         {
-            gcmkVERIFY_OK(gckOS_AtomDestroy(os, node->mapMutex));
+            gcmkVERIFY_OK(gckOS_DeleteMutex(os, node->mapMutex));
         }
 #endif
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
index b4743b3..9e39fa1 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
@@ -28,7 +28,7 @@
 #include "gc_hal_base.h"
 #include "gc_hal_profiler.h"
 #include "gc_hal_driver.h"
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
 #include "gc_hal_statistics.h"
 #endif
 
@@ -200,6 +200,9 @@ gceCORE;
 #endif
 
 #define gcdMAX_SURF_LAYER              4
+
+#define gcdMAX_DRAW_BUFFERS            4
+
 /*******************************************************************************
 **
 **  gcmVERIFY_OBJECT
@@ -357,8 +360,9 @@ gckOS_AllocatePagedMemory(
 gceSTATUS
 gckOS_AllocatePagedMemoryEx(
     IN gckOS Os,
-    IN gctBOOL Contiguous,
+    IN gctUINT32 Flag,
     IN gctSIZE_T Bytes,
+    OUT gctUINT32 * Gid,
     OUT gctPHYS_ADDR * Physical
     );
 
@@ -499,6 +503,14 @@ gckOS_UnmapPhysical(
     IN gctSIZE_T Bytes
     );
 
+/* Get real physical address from descriptor. */
+gceSTATUS
+gckOS_PhysicalToPhysicalAddress(
+    IN gckOS Os,
+    IN gctPOINTER Physical,
+    OUT gctUINT32 * PhysicalAddress
+    );
+
 /* Read data from a hardware register. */
 gceSTATUS
 gckOS_ReadRegister(
@@ -1664,9 +1676,10 @@ gckVIDMEM_Free(
 gceSTATUS
 gckVIDMEM_Lock(
     IN gckKERNEL Kernel,
-    IN gcuVIDMEM_NODE_PTR Node,
+    IN gckVIDMEM_NODE Node,
     IN gctBOOL Cacheable,
     OUT gctUINT32 * Address,
+    OUT gctUINT32 * Gid,
     OUT gctUINT64 * PhysicalAddress
     );
 
@@ -1674,7 +1687,7 @@ gckVIDMEM_Lock(
 gceSTATUS
 gckVIDMEM_Unlock(
     IN gckKERNEL Kernel,
-    IN gcuVIDMEM_NODE_PTR Node,
+    IN gckVIDMEM_NODE Node,
     IN gceSURF_TYPE Type,
     IN OUT gctBOOL * Asynchroneous
     );
@@ -1683,9 +1696,8 @@ gckVIDMEM_Unlock(
 gceSTATUS
 gckVIDMEM_ConstructVirtual(
     IN gckKERNEL Kernel,
-    IN gctBOOL Contiguous,
+    IN gctUINT32 Flag,
     IN gctSIZE_T Bytes,
-    IN gctBOOL Cacheable,
     OUT gcuVIDMEM_NODE_PTR * Node
     );
 
@@ -2350,6 +2362,21 @@ gckHARDWARE_SetDVFSPeroid(
     IN gctUINT32 Frequency
     );
 
+gceSTATUS
+gckHARDWARE_PrepareFunctions(
+    gckHARDWARE Hardware
+    );
+
+gceSTATUS
+gckHARDWARE_SetMMUStates(
+    IN gckHARDWARE Hardware,
+    IN gctPOINTER MtlbAddress,
+    IN gceMMU_MODE Mode,
+    IN gctPOINTER SafeAddress,
+    IN gctPOINTER Logical,
+    IN OUT gctUINT32 * Bytes
+    );
+
 #if !gcdENABLE_VG
 /******************************************************************************\
 ***************************** gckINTERRUPT Object ******************************
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
index 5885722..709c8a7 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
@@ -18,7 +18,6 @@
 *
 *****************************************************************************/
 
-
 #ifndef __gc_hal_base_h_
 #define __gc_hal_base_h_
 
@@ -40,7 +39,7 @@ typedef struct _gcoOS *                 gcoOS;
 typedef struct _gco2D *                 gco2D;
 typedef struct gcsATOM *                gcsATOM_PTR;
 
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
 typedef struct _gco3D *                 gco3D;
 typedef struct _gcoCL *                 gcoCL;
 typedef struct _gcsFAST_FLUSH *         gcsFAST_FLUSH_PTR;
@@ -57,6 +56,7 @@ typedef struct _gcsBOUNDARY *           gcsBOUNDARY_PTR;
 typedef struct _gcoDUMP *               gcoDUMP;
 typedef struct _gcoHARDWARE *           gcoHARDWARE;
 typedef union  _gcuVIDMEM_NODE *        gcuVIDMEM_NODE_PTR;
+typedef struct _gcsVIDMEM_NODE *        gckVIDMEM_NODE;
 
 #if gcdENABLE_VG
 typedef struct _gcoVG *                 gcoVG;
@@ -81,7 +81,7 @@ typedef struct _gcoOS_SymbolsList gcoOS_SymbolsList;
 
 typedef struct _gcsPLS * gcsPLS_PTR;
 
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
 /******************************************************************************
 **
 ** Patch defines which should be moved to dedicate file later
@@ -90,6 +90,7 @@ typedef struct _gcsPLS * gcsPLS_PTR;
 *******************************************************************************/
 typedef enum _gcePATCH_ID
 {
+    gcvPATCH_NOTINIT = -1,
     gcvPATCH_INVALID = 0,
 
 #if gcdDEBUG_OPTION
@@ -167,10 +168,21 @@ typedef enum _gcePATCH_ID
     gcvPATCH_AFTERBURNER,
     gcvPATCH_UIMARK,
     gcvPATCH_FM_OES_PLAYER,
+    gcvPATCH_SUMSUNG_BENCH,
+    gcvPATCH_ROCKSTAR_MAXPAYNE,
+    gcvPATCH_TITANPACKING,
+    gcvPATCH_BASEMARKOSIICN,
+    gcvPATCH_FRUITNINJA,
+    gcvPATCH_QUICINC_VELLAMO,
+#if defined(ANDROID)
+    gcePATCH_ANDROID_CTS_MEDIA_PRESENTATIONTIME,
+#endif
+    gcvPATCH_ANDROID_COMPOSITOR,
+    gcvPATCH_CTS_TEXTUREVIEW,
 
     gcvPATCH_COUNT
 } gcePATCH_ID;
-#endif /* VIVANTE_NO_3D */
+#endif /* gcdENABLE_3D */
 
 typedef void (* gctPLS_DESTRUCTOR) (
     gcsPLS_PTR
@@ -220,7 +232,7 @@ typedef struct _gcsPLS
     ** We can use this mutex for every PLS access.
     */
     gctPOINTER                  accessLock;
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
     /* Global patchID to overwrite the detection */
     gcePATCH_ID                 patchID;
 #endif
@@ -229,7 +241,7 @@ gcsPLS;
 
 extern gcsPLS gcPLS;
 
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
 #define gcPLS_INITIALIZER \
 { \
     gcvNULL,         /* gcoOS object.      */ \
@@ -253,7 +265,7 @@ extern gcsPLS gcPLS;
     gcvFALSE,        /* Special flag for NP2 texture. */ \
     gcvNULL,         /* destructor        */ \
     gcvNULL,         /* accessLock        */ \
-    gcvPATCH_INVALID,/* global patchID    */ \
+    gcvPATCH_NOTINIT,/* global patchID    */ \
 }
 #else
 #define gcPLS_INITIALIZER \
@@ -308,10 +320,12 @@ typedef struct _gcsTLS
     gcoVGHARDWARE               vg;
     gcoVG                       engineVG;
 #endif /* gcdENABLE_VG */
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
     gco3D                       engine3D;
 #endif
+#if gcdENABLE_2D
     gco2D                       engine2D;
+#endif
 
     /*thread data */
     gctPOINTER                  context;
@@ -352,14 +366,12 @@ typedef enum _gcePOOL
     gcvPOOL_VIRTUAL,
     gcvPOOL_USER,
     gcvPOOL_CONTIGUOUS,
-    gcvPOOL_DEFAULT_FORCE_CONTIGUOUS,
-    gcvPOOL_DEFAULT_FORCE_CONTIGUOUS_CACHEABLE,
 
     gcvPOOL_NUMBER_OF_POOLS
 }
 gcePOOL;
 
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
 /* Blending functions. */
 typedef enum _gceBLEND_FUNCTION
 {
@@ -392,6 +404,17 @@ typedef enum _gceBLEND_MODE
 }
 gceBLEND_MODE;
 
+/* Depth modes. */
+typedef enum _gceDEPTH_MODE
+{
+    gcvDEPTH_NONE,
+    gcvDEPTH_Z,
+    gcvDEPTH_W,
+}
+gceDEPTH_MODE;
+#endif /* gcdENABLE_3D */
+
+#if (gcdENABLE_3D || gcdENABLE_VG)
 /* API flags. */
 typedef enum _gceAPI
 {
@@ -404,16 +427,8 @@ typedef enum _gceAPI
     gcvAPI_OPENCL,
 }
 gceAPI;
+#endif
 
-/* Depth modes. */
-typedef enum _gceDEPTH_MODE
-{
-    gcvDEPTH_NONE,
-    gcvDEPTH_Z,
-    gcvDEPTH_W,
-}
-gceDEPTH_MODE;
-#endif /* VIVANTE_NO_3D */
 
 typedef enum _gceWHERE
 {
@@ -437,8 +452,6 @@ typedef enum _gceSignalHandlerType
 }
 gceSignalHandlerType;
 
-
-#if gcdENABLE_VG
 /* gcsHAL_Limits*/
 typedef struct _gcsHAL_LIMITS
 {
@@ -455,7 +468,6 @@ typedef struct _gcsHAL_LIMITS
     gctUINT32         maxSamples;
 
 }gcsHAL_LIMITS;
-#endif
 
 /******************************************************************************\
 *********** Generic Memory Allocation Optimization Using Containers ************
@@ -558,28 +570,36 @@ gcoHAL_GetOption(
      IN gceOPTION Option
      );
 
-/* Get pointer to gco2D object. */
 gceSTATUS
-gcoHAL_Get2DEngine(
+gcoHAL_FrameInfoOps(
     IN gcoHAL Hal,
-    OUT gco2D * Engine
+    IN gceFRAMEINFO FrameInfo,
+    IN gceFRAMEINFO_OP Op,
+    IN OUT gctUINT * Val
     );
 
-#ifndef VIVANTE_NO_3D
+
 gceSTATUS
-gcoHAL_GetSpecialHintData(
+gcoHAL_GetHardware(
     IN gcoHAL Hal,
-    OUT gctINT * Hint
+    OUT gcoHARDWARE* Hw
     );
-#endif
 
+#if gcdENABLE_2D
+/* Get pointer to gco2D object. */
 gceSTATUS
-gcoHAL_GetHardware(
+gcoHAL_Get2DEngine(
     IN gcoHAL Hal,
-    OUT gcoHARDWARE* Hw
+    OUT gco2D * Engine
     );
+#endif
 
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
+gceSTATUS
+gcoHAL_GetSpecialHintData(
+    IN gcoHAL Hal,
+    OUT gctINT * Hint
+    );
 /*
 ** Deprecated(Don't use it), keep it here for external library(libgcu.so)
 */
@@ -588,7 +608,14 @@ gcoHAL_Get3DEngine(
     IN gcoHAL Hal,
     OUT gco3D * Engine
     );
-#endif /* VIVANTE_NO_3D */
+#endif /* gcdEANBLE_3D */
+
+
+gceSTATUS
+gcoHAL_GetProductName(
+    IN gcoHAL Hal,
+    OUT gctSTRING *ProductName
+    );
 
 gceSTATUS
 gcoHAL_SetFscaleValue(
@@ -655,6 +682,13 @@ gceSTATUS gcoHAL_QueryChipMinorFeatures(
     OUT gctUINT32* ChipMinorFeatures
     );
 
+gctINT32
+gcoOS_EndRecordAllocation(void);
+void
+gcoOS_RecordAllocation(void);
+void
+gcoOS_AddRecordAllocation(gctSIZE_T Size);
+
 /* Query the amount of video memory. */
 gceSTATUS
 gcoHAL_QueryVideoMemory(
@@ -749,13 +783,13 @@ gcoHAL_Commit(
     IN gctBOOL Stall
     );
 
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
 /* Sencd fence command. */
 gceSTATUS
 gcoHAL_SendFence(
     IN gcoHAL Hal
     );
-#endif /* VIVANTE_NO_3D */
+#endif /* gcdENABLE_3D */
 
 /* Query the tile capabilities. */
 gceSTATUS
@@ -811,7 +845,7 @@ gcoHAL_GetDump(
     OUT gcoDUMP * Dump
     );
 
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
 gceSTATUS
 gcoHAL_SetPatchID(
     IN  gcoHAL Hal,
@@ -830,7 +864,7 @@ gcoHAL_SetGlobalPatchID(
     IN  gcoHAL Hal,
     IN  gcePATCH_ID PatchID
     );
-#endif /* VIVANTE_NO_3D */
+#endif /* gcdENABLE_3D */
 /* Call the kernel HAL layer. */
 gceSTATUS
 gcoHAL_Call(
@@ -916,7 +950,6 @@ gcoHAL_GetVGEngine(
     OUT gcoVG * Engine
     );
 
-#if gcdENABLE_VG
 gceSTATUS
 gcoHAL_QueryChipLimits(
     IN gcoHAL           Hal,
@@ -929,8 +962,6 @@ gcoHAL_QueryChipFeature(
     IN gctINT32     Chip,
     IN gceFEATURE   Feature);
 
-#endif
-
 /*----------------------------------------------------------------------------*/
 /*----- Shared Buffer --------------------------------------------------------*/
 
@@ -970,6 +1001,23 @@ gcoHAL_ReadShBuffer(
     OUT gctUINT32 * BytesRead
     );
 
+/* Config power management to be enabled or disabled. */
+gceSTATUS
+gcoHAL_ConfigPowerManagement(
+    IN gctBOOL Enable
+    );
+
+#if gcdENABLE_3D || gcdENABLE_VG
+/* Query the target capabilities. */
+gceSTATUS
+gcoHAL_QueryTargetCaps(
+    IN gcoHAL Hal,
+    OUT gctUINT * MaxWidth,
+    OUT gctUINT * MaxHeight,
+    OUT gctUINT * MultiTargetCount,
+    OUT gctUINT * MaxSamples
+    );
+#endif
 
 /******************************************************************************\
 ********************************** gcoOS Object *********************************
@@ -1565,6 +1613,22 @@ gcoOS_AtomDestroy(
     IN gcsATOM_PTR Atom
     );
 
+/* Get the 32-bit value protected by an atom. */
+gceSTATUS
+gcoOS_AtomGet(
+    IN gcoOS Os,
+    IN gcsATOM_PTR Atom,
+    OUT gctINT32_PTR Value
+    );
+
+/* Set the 32-bit value protected by an atom. */
+gceSTATUS
+gcoOS_AtomSet(
+    IN gcoOS Os,
+    IN gcsATOM_PTR Atom,
+    IN gctINT32 Value
+    );
+
 /* Increment an atom. */
 gceSTATUS
 gcoOS_AtomIncrement(
@@ -2308,13 +2372,25 @@ gcoSURF_IsValid(
     IN gcoSURF Surface
     );
 
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
 /* Verify and return the state of the tile status mechanism. */
 gceSTATUS
 gcoSURF_IsTileStatusSupported(
     IN gcoSURF Surface
     );
 
+/* Verify if surface has tile status enabled. */
+gceSTATUS
+gcoSURF_IsTileStatusEnabled(
+    IN gcoSURF Surface
+    );
+
+/* Verify if surface is compressed. */
+gceSTATUS
+gcoSURF_IsCompressed(
+    IN gcoSURF Surface
+    );
+
 /* Enable tile status for the specified surface on zero slot. */
 gceSTATUS
 gcoSURF_EnableTileStatus(
@@ -2341,7 +2417,7 @@ gcoSURF_FlushTileStatus(
     IN gcoSURF Surface,
     IN gctBOOL Decompress
     );
-#endif /* VIVANTE_NO_3D */
+#endif /* gcdENABLE_3D */
 
 /* Get surface size. */
 gceSTATUS
@@ -2682,6 +2758,29 @@ gcoSURF_PopSharedInfo(
     IN gcoSURF Surface
     );
 
+#if (gcdENABLE_3D || gcdENABLE_VG)
+/* Copy surface. */
+gceSTATUS
+gcoSURF_Copy(
+    IN gcoSURF Surface,
+    IN gcoSURF Source
+    );
+
+/* Set number of samples for a gcoSURF object. */
+gceSTATUS
+gcoSURF_SetSamples(
+    IN gcoSURF Surface,
+    IN gctUINT Samples
+    );
+
+/* Get the number of samples per pixel. */
+gceSTATUS
+gcoSURF_GetSamples(
+    IN gcoSURF Surface,
+    OUT gctUINT_PTR Samples
+    );
+#endif
+
 /******************************************************************************\
 ********************************* gcoDUMP Object ********************************
 \******************************************************************************/
@@ -4618,7 +4717,7 @@ gcGetUserDebugOption(
 #if defined(ANDROID)
 struct _gcoOS_SymbolsList
 {
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
     gcePATCH_ID patchId;
 #endif
     const char * symList[10];
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
index 78bd8d2..cf2227d 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
@@ -18,7 +18,6 @@
 *
 *****************************************************************************/
 
-
 #ifndef __gc_hal_driver_h_
 #define __gc_hal_driver_h_
 
@@ -184,6 +183,8 @@ typedef enum _gceHAL_COMMAND_CODES
     /* Shared buffer. */
     gcvHAL_SHBUF,
 
+    /* Config power management. */
+    gcvHAL_CONFIG_POWER_MANAGEMENT,
 }
 gceHAL_COMMAND_CODES;
 
@@ -277,6 +278,9 @@ typedef struct _gcsHAL_QUERY_CHIP_IDENTITY
 
     /* Special control bits for 2D chip. */
     gctUINT32                   chip2DControl;
+
+    /* Product ID */
+    gctUINT32                   productID;
 }
 gcsHAL_QUERY_CHIP_IDENTITY;
 
@@ -475,6 +479,9 @@ typedef struct _gcsHAL_INTERFACE
             /* Mapped logical address. */
             OUT gctUINT64               memory;
 
+            /* Customer priviate handle*/
+            OUT gctUINT32               gid;
+
             /* Bus address of a contiguous video node. */
             OUT gctUINT64               physicalAddress;
         }
@@ -1101,6 +1108,11 @@ typedef struct _gcsHAL_INTERFACE
         }
         ShBuf;
 
+        struct _gcsHAL_CONFIG_POWER_MANAGEMENT
+        {
+            IN gctBOOL                  enable;
+        }
+        ConfigPowerManagement;
     }
     u;
 }
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
index 0934e02..775dec8 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
@@ -22,10 +22,10 @@
 #ifndef __gc_hal_engine_h_
 #define __gc_hal_engine_h_
 
-#ifndef VIVANTE_NO_3D
 #include "gc_hal_types.h"
 #include "gc_hal_enum.h"
 
+#if gcdENABLE_3D
 #if gcdENABLE_VG
 #include "gc_hal_engine_vg.h"
 #endif
@@ -48,20 +48,36 @@ typedef struct _gcoBUFOBJ *             gcoBUFOBJ;
 
 #define gcdATTRIBUTE_COUNT              16
 
+typedef enum _gcePROGRAM_STAGE
+{
+    gcvPROGRAM_STAGE_VERTEX   = 0x0,
+    gcvPROGRAM_STAGE_TES      = 0x1,
+    gcvPROGRAM_STAGE_TCS      = 0x2,
+    gcvPROGRAM_STAGE_GEOMETRY = 0x3,
+    gcvPROGRAM_STAGE_FRAGMENT = 0x4,
+    gcvPROGRAM_STAGE_COMPUTE  = 0x5,
+    gcvPROGRAM_STAGE_OPENCL   = 0x6,
+    gcvPROGRAM_STAGE_LAST
+}
+gcePROGRAM_STAGE;
+
+typedef enum _gcePROGRAM_STAGE_BIT
+{
+    gcvPROGRAM_STAGE_VERTEX_BIT   = 1 << gcvPROGRAM_STAGE_VERTEX,
+    gcvPROGRAM_STAGE_TES_BIT      = 1 << gcvPROGRAM_STAGE_TES,
+    gcvPROGRAM_STAGE_TCS_BIT      = 1 << gcvPROGRAM_STAGE_TCS,
+    gcvPROGRAM_STAGE_GEOMETRY_BIT = 1 << gcvPROGRAM_STAGE_GEOMETRY,
+    gcvPROGRAM_STAGE_FRAGMENT_BIT = 1 << gcvPROGRAM_STAGE_FRAGMENT,
+    gcvPROGRAM_STAGE_COMPUTE_BIT  = 1 << gcvPROGRAM_STAGE_COMPUTE,
+    gcvPROGRAM_STAGE_OPENCL_BIT   = 1 << gcvPROGRAM_STAGE_OPENCL,
+}
+gcePROGRAM_STAGE_BIT;
+
+
 /******************************************************************************\
 ********************************* gcoHAL Object *********************************
 \******************************************************************************/
 
-/* Query the target capabilities. */
-gceSTATUS
-gcoHAL_QueryTargetCaps(
-    IN gcoHAL Hal,
-    OUT gctUINT * MaxWidth,
-    OUT gctUINT * MaxHeight,
-    OUT gctUINT * MultiTargetCount,
-    OUT gctUINT * MaxSamples
-    );
-
 gceSTATUS
 gcoHAL_QueryShaderCaps(
     IN gcoHAL Hal,
@@ -299,15 +315,11 @@ gceSTATUS
 gcoSURF_BlitDraw(
     IN gcsSURF_BLITDRAW_ARGS *args
     );
+#endif  /* gcdENABLE_3D */
 
 
-/* Copy surface. */
-gceSTATUS
-gcoSURF_Copy(
-    IN gcoSURF Surface,
-    IN gcoSURF Source
-    );
 
+#if gcdENABLE_3D
 /* Clear surface function. */
 gceSTATUS
 gcoSURF_Clear(
@@ -323,19 +335,6 @@ gcoSURF_Preserve(
     IN gcsRECT_PTR MaskRect
     );
 
-/* Set number of samples for a gcoSURF object. */
-gceSTATUS
-gcoSURF_SetSamples(
-    IN gcoSURF Surface,
-    IN gctUINT Samples
-    );
-
-/* Get the number of samples per pixel. */
-gceSTATUS
-gcoSURF_GetSamples(
-    IN gcoSURF Surface,
-    OUT gctUINT_PTR Samples
-    );
 
 /* TO BE REMOVED */
     gceSTATUS
@@ -1305,6 +1304,12 @@ gco3D_Semaphore(
     IN gceWHERE To,
     IN gceHOW How);
 
+/* Explicitly flush shader L1 cache */
+gceSTATUS
+gco3D_FlushSHL1Cache(
+    IN gco3D Engine
+    );
+
 /* Set the subpixels center. */
 gceSTATUS
 gco3D_SetCentroids(
@@ -1322,11 +1327,24 @@ gco3D_SetLogicOp(
 gceSTATUS
 gco3D_SetOQ(
     IN gco3D Engine,
-    IN gctUINT32 ResultAddress,
+    INOUT gctPOINTER * Result,
     IN gctBOOL Enable
     );
 
 gceSTATUS
+gco3D_GetOQ(
+    IN gco3D Engine,
+    IN gctPOINTER Result,
+    OUT gctINT64 * Logical
+    );
+
+gceSTATUS
+gco3D_DeleteOQ(
+    IN gco3D Engine,
+    INOUT gctPOINTER Result
+    );
+
+gceSTATUS
 gco3D_SetColorOutCount(
     IN gco3D Engine,
     IN gctUINT32 ColorOutCount
@@ -1802,6 +1820,21 @@ gcoTEXTURE_AddMipMap(
     );
 
 gceSTATUS
+gcoTEXTURE_AddMipMapWithFlag(
+    IN gcoTEXTURE Texture,
+    IN gctINT Level,
+    IN gctINT InternalFormat,
+    IN gceSURF_FORMAT Format,
+    IN gctSIZE_T Width,
+    IN gctSIZE_T Height,
+    IN gctSIZE_T Depth,
+    IN gctUINT Faces,
+    IN gcePOOL Pool,
+    IN gctBOOL Protected,
+    OUT gcoSURF * Surface
+    );
+
+gceSTATUS
 gcoTEXTURE_AddMipMapFromClient(
     IN gcoTEXTURE Texture,
     IN gctINT     Level,
@@ -2536,5 +2569,5 @@ gcoBUFOBJ_Dump(
 }
 #endif
 
-#endif /* VIVANTE_NO_3D */
+#endif /* gcdENABLE_3D */
 #endif /* __gc_hal_engine_h_ */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
index 950bbc7..7e98d05 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
@@ -465,6 +465,12 @@ gcsPATH_DATA;
 gceSTATUS
 gcoHAL_QueryPathStorage(
     IN gcoHAL Hal,
+#if GC355_PROFILER
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     OUT gcsPATH_BUFFER_INFO_PTR Information
     );
 
@@ -472,6 +478,12 @@ gcoHAL_QueryPathStorage(
 gceSTATUS
 gcoHAL_AssociateCompletion(
     IN gcoHAL Hal,
+#if GC355_PROFILER
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gcsPATH_DATA_PTR PathData
     );
 
@@ -479,6 +491,12 @@ gcoHAL_AssociateCompletion(
 gceSTATUS
 gcoHAL_DeassociateCompletion(
     IN gcoHAL Hal,
+#if GC355_PROFILER
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gcsPATH_DATA_PTR PathData
     );
 
@@ -486,6 +504,12 @@ gcoHAL_DeassociateCompletion(
 gceSTATUS
 gcoHAL_CheckCompletion(
     IN gcoHAL Hal,
+#if GC355_PROFILER
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gcsPATH_DATA_PTR PathData
     );
 
@@ -493,6 +517,12 @@ gcoHAL_CheckCompletion(
 gceSTATUS
 gcoHAL_WaitCompletion(
     IN gcoHAL Hal,
+#if GC355_PROFILER
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gcsPATH_DATA_PTR PathData
     );
 
@@ -500,12 +530,25 @@ gcoHAL_WaitCompletion(
 gceSTATUS
 gcoHAL_Flush(
     IN gcoHAL Hal
+#if GC355_PROFILER
+    ,
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth
+#endif
     );
 
 /* Split a harwdare address into pool and offset. */
 gceSTATUS
 gcoHAL_SplitAddress(
     IN gcoHAL Hal,
+#if GC355_PROFILER
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctUINT32 Address,
     OUT gcePOOL * Pool,
     OUT gctUINT32 * Offset
@@ -515,6 +558,12 @@ gcoHAL_SplitAddress(
 gceSTATUS
 gcoHAL_CombineAddress(
     IN gcoHAL Hal,
+#if GC355_PROFILER
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gcePOOL Pool,
     IN gctUINT32 Offset,
     OUT gctUINT32 * Address
@@ -524,6 +573,12 @@ gcoHAL_CombineAddress(
 gceSTATUS
 gcoHAL_ScheduleVideoMemory(
     IN gcoHAL Hal,
+#if GC355_PROFILER
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctUINT32 Node
     );
 
@@ -531,6 +586,12 @@ gcoHAL_ScheduleVideoMemory(
 gceSTATUS
 gcoHAL_FreeVideoMemory(
     IN gcoHAL Hal,
+#if GC355_PROFILER
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctUINT32 Node
     );
 
@@ -538,12 +599,24 @@ gcoHAL_FreeVideoMemory(
 gceSTATUS
 gcoHAL_QueryCommandBuffer(
     IN gcoHAL Hal,
+#if GC355_PROFILER
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     OUT gcsCOMMAND_BUFFER_INFO_PTR Information
     );
 /* Allocate and lock linear video memory. */
 gceSTATUS
 gcoHAL_AllocateLinearVideoMemory(
     IN gcoHAL Hal,
+#if GC355_PROFILER
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctUINT Size,
     IN gctUINT Alignment,
     IN gcePOOL Pool,
@@ -556,6 +629,12 @@ gcoHAL_AllocateLinearVideoMemory(
 gceSTATUS
 gcoHAL_GetAlignedSurfaceSize(
     IN gcoHAL Hal,
+#if GC355_PROFILER
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gceSURF_TYPE Type,
     IN OUT gctUINT32_PTR Width,
     IN OUT gctUINT32_PTR Height
@@ -564,6 +643,12 @@ gcoHAL_GetAlignedSurfaceSize(
 gceSTATUS
 gcoHAL_ReserveTask(
     IN gcoHAL Hal,
+#if GC355_PROFILER
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gceBLOCK Block,
     IN gctUINT TaskCount,
     IN gctUINT32 Bytes,
@@ -577,23 +662,69 @@ gcoHAL_ReserveTask(
 **
 **  The gcoVG object abstracts the VG hardware pipe.
 */
+#if GC355_PROFILER
+void
+gcoVG_ProfilerEnableDisable(
+    IN gcoVG Vg,
+    IN gctUINT enableGetAPITimes,
+    IN gctFILE apiTimeFile
+    );
+
+void
+gcoVG_ProfilerTreeDepth(
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth
+    );
+
+void
+gcoVG_ProfilerSetStates(
+    IN gcoVG Vg,
+    IN gctUINT treeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth
+    );
+#endif
 
 gctBOOL
 gcoVG_IsMaskSupported(
+#if GC355_PROFILER
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gceSURF_FORMAT Format
     );
 
 gctBOOL
 gcoVG_IsTargetSupported(
+#if GC355_PROFILER
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gceSURF_FORMAT Format
     );
 
 gctBOOL
 gcoVG_IsImageSupported(
+#if GC355_PROFILER
+    IN gcoVG Vg,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gceSURF_FORMAT Format
     );
 
 gctUINT8 gcoVG_PackColorComponent(
+#if GC355_PROFILER
+    gcoVG Vg,
+    gctUINT TreeDepth,
+    gctUINT saveLayerTreeDepth,
+    gctUINT varTreeDepth,
+#endif
     gctFLOAT Value
     );
 
@@ -606,64 +737,121 @@ gcoVG_Construct(
 gceSTATUS
 gcoVG_Destroy(
     IN gcoVG Vg
+#if GC355_PROFILER
+    ,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth
+#endif
     );
 
 gceSTATUS
 gcoVG_SetTarget(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gcoSURF Target
     );
 
 gceSTATUS
 gcoVG_UnsetTarget(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gcoSURF Surface
     );
 
 gceSTATUS
 gcoVG_SetUserToSurface(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctFLOAT UserToSurface[9]
     );
 
 gceSTATUS
 gcoVG_SetSurfaceToImage(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctFLOAT SurfaceToImage[9]
     );
 
 gceSTATUS
 gcoVG_EnableMask(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctBOOL Enable
     );
 
 gceSTATUS
 gcoVG_SetMask(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gcoSURF Mask
     );
 
 gceSTATUS
 gcoVG_UnsetMask(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gcoSURF Surface
     );
 
 gceSTATUS
 gcoVG_FlushMask(
     IN gcoVG Vg
+#if GC355_PROFILER
+    ,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth
+#endif
     );
 
 gceSTATUS
 gcoVG_EnableScissor(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctBOOL Enable
     );
 
 gceSTATUS
 gcoVG_SetScissor(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctSIZE_T RectangleCount,
     IN gcsVG_RECT_PTR Rectangles
     );
@@ -671,18 +859,33 @@ gcoVG_SetScissor(
 gceSTATUS
 gcoVG_EnableColorTransform(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctBOOL Enable
     );
 
 gceSTATUS
 gcoVG_SetColorTransform(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctFLOAT ColorTransform[8]
     );
 
 gceSTATUS
 gcoVG_SetTileFillColor(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctFLOAT Red,
     IN gctFLOAT Green,
     IN gctFLOAT Blue,
@@ -692,6 +895,11 @@ gcoVG_SetTileFillColor(
 gceSTATUS
 gcoVG_SetSolidPaint(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctUINT8 Red,
     IN gctUINT8 Green,
     IN gctUINT8 Blue,
@@ -701,6 +909,11 @@ gcoVG_SetSolidPaint(
 gceSTATUS
 gcoVG_SetLinearPaint(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctFLOAT Constant,
     IN gctFLOAT StepX,
     IN gctFLOAT StepY
@@ -709,6 +922,11 @@ gcoVG_SetLinearPaint(
 gceSTATUS
 gcoVG_SetRadialPaint(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctFLOAT LinConstant,
     IN gctFLOAT LinStepX,
     IN gctFLOAT LinStepY,
@@ -723,6 +941,11 @@ gcoVG_SetRadialPaint(
 gceSTATUS
 gcoVG_SetPatternPaint(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctFLOAT UConstant,
     IN gctFLOAT UStepX,
     IN gctFLOAT UStepY,
@@ -735,6 +958,11 @@ gcoVG_SetPatternPaint(
 gceSTATUS
 gcoVG_SetColorRamp(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gcoSURF ColorRamp,
     IN gceTILE_MODE ColorRampSpreadMode
     );
@@ -742,6 +970,11 @@ gcoVG_SetColorRamp(
 gceSTATUS
 gcoVG_SetPattern(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctINT32 width,
     IN gctINT32 height,
     IN gcoSURF Pattern,
@@ -752,24 +985,44 @@ gcoVG_SetPattern(
 gceSTATUS
 gcoVG_SetImageMode(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gceVG_IMAGE Mode
     );
 
 gceSTATUS
 gcoVG_SetBlendMode(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gceVG_BLEND Mode
     );
 
 gceSTATUS
 gcoVG_SetRenderingQuality(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gceRENDER_QUALITY Quality
     );
 
 gceSTATUS
 gcoVG_SetFillRule(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gceFILL_RULE FillRule
     );
 
@@ -782,6 +1035,11 @@ gcoVG_FinalizePath(
 gceSTATUS
 gcoVG_Clear(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctINT X,
     IN gctINT Y,
     IN gctINT Width,
@@ -791,6 +1049,11 @@ gcoVG_Clear(
 gceSTATUS
 gcoVG_DrawPath(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gcsPATH_DATA_PTR PathData,
     IN gctFLOAT Scale,
     IN gctFLOAT Bias,
@@ -805,6 +1068,11 @@ gcoVG_DrawPath(
 gceSTATUS
 gcoVG_DrawImage(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gcoSURF Source,
     IN gcsPOINT_PTR SourceOrigin,
     IN gcsPOINT_PTR TargetOrigin,
@@ -822,6 +1090,11 @@ gcoVG_DrawImage(
 gceSTATUS
 gcoVG_TesselateImage(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gcoSURF Image,
     IN gcsVG_RECT_PTR Rectangle,
     IN gceIMAGE_FILTER Filter,
@@ -837,6 +1110,11 @@ gcoVG_TesselateImage(
 gceSTATUS
 gcoVG_Blit(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gcoSURF Source,
     IN gcoSURF Target,
     IN gcsVG_RECT_PTR SrcRect,
@@ -848,6 +1126,11 @@ gcoVG_Blit(
 gceSTATUS
 gcoVG_ColorMatrix(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gcoSURF Source,
     IN gcoSURF Target,
     IN const gctFLOAT * Matrix,
@@ -863,6 +1146,11 @@ gcoVG_ColorMatrix(
 gceSTATUS
 gcoVG_SeparableConvolve(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gcoSURF Source,
     IN gcoSURF Target,
     IN gctINT KernelWidth,
@@ -888,6 +1176,11 @@ gcoVG_SeparableConvolve(
 gceSTATUS
 gcoVG_GaussianBlur(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gcoSURF Source,
     IN gcoSURF Target,
     IN gctFLOAT StdDeviationX,
@@ -907,6 +1200,11 @@ gcoVG_GaussianBlur(
 gceSTATUS
 gcoVG_EnableDither(
     IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
     IN gctBOOL Enable
     );
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
index 5b7ed41..236c39b 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
@@ -41,6 +41,7 @@ typedef enum _gceCHIPMODEL
     gcv428  = 0x0428,
     gcv450  = 0x0450,
     gcv500  = 0x0500,
+    gcv520  = 0x0520,
     gcv530  = 0x0530,
     gcv600  = 0x0600,
     gcv700  = 0x0700,
@@ -48,6 +49,7 @@ typedef enum _gceCHIPMODEL
     gcv860  = 0x0860,
     gcv880  = 0x0880,
     gcv1000 = 0x1000,
+    gcv1500 = 0x1500,
     gcv2000 = 0x2000,
     gcv2100 = 0x2100,
     gcv2200 = 0x2200,
@@ -113,6 +115,7 @@ typedef enum _gceFEATURE
     gcvFEATURE_2D_FILTERBLIT_PLUS_ALPHABLEND,
     gcvFEATURE_2D_DITHER,
     gcvFEATURE_2D_A8_TARGET,
+    gcvFEATURE_2D_A8_NO_ALPHA,
     gcvFEATURE_2D_FILTERBLIT_FULLROTATION,
     gcvFEATURE_2D_BITBLIT_FULLROTATION,
     gcvFEATURE_WIDE_LINE,
@@ -151,6 +154,7 @@ typedef enum _gceFEATURE
     gcvFEATURE_2D_NO_COLORBRUSH_INDEX8,
     gcvFEATURE_RS_YUV_TARGET,
     gcvFEATURE_2D_FC_SOURCE,
+    gcvFEATURE_2D_CC_NOAA_SOURCE,
     gcvFEATURE_PE_DITHER_FIX,
     gcvFEATURE_2D_YUV_SEPARATE_STRIDE,
     gcvFEATURE_FRUSTUM_CLIP_FIX,
@@ -189,6 +193,7 @@ typedef enum _gceFEATURE
     gcvFEATURE_DUAL_16,
     gcvFEATURE_BRANCH_ON_IMMEDIATE_REG,
     gcvFEATURE_2D_COMPRESSION,
+    gcvFEATURE_TPC_COMPRESSION,
     gcvFEATURE_2D_OPF_YUV_OUTPUT,
     gcvFEATURE_2D_MULTI_SRC_BLT_TO_UNIFIED_DST_RECT,
     gcvFEATURE_V2_COMPRESSION_Z16_FIX,
@@ -246,6 +251,23 @@ typedef enum _gceFEATURE
     gcvFEATURE_BUG_FIXES8,
     gcvFEATURE_2D_ALL_QUAD,
 
+    gcvFEATURE_SINGLE_PIPE_HALTI1,
+
+    gcvFEATURE_BLOCK_SIZE_16x16,
+
+    gcvFEATURE_NO_USER_CSC,
+    gcvFEATURE_ANDROID_ONLY,
+    gcvFEATURE_HAS_PRODUCTID,
+
+    gcvFEATURE_V2_MSAA_COMP_FIX,
+
+    gcvFEATURE_S8_ONLY_RENDERING,
+
+    gcvFEATURE_SEPARATE_SRC_DST,
+
+    gcvFEATURE_FE_START_VERTEX_SUPPORT,
+    gcvFEATURE_RS_DEPTHSTENCIL_NATIVE_SUPPORT,
+
     /* Insert features above this comment only. */
     gcvFEATURE_COUNT                /* Not a feature. */
 }
@@ -280,6 +302,31 @@ typedef enum _gceOPITON
 }
 gceOPTION;
 
+typedef enum _gceFRAMEINFO
+{
+    gcvFRAMEINFO_FRAME_NUM       = 0,
+    gcvFRAMEINFO_DRAW_NUM        = 1,
+    gcvFRAMEINFO_DRAW_DUAL16_NUM = 2,
+    gcvFRAMEINFO_DRAW_FL32_NUM   = 3,
+
+
+    gcvFRAMEINFO_COUNT,
+}
+gceFRAMEINFO;
+
+typedef enum _gceFRAMEINFO_OP
+{
+    gcvFRAMEINFO_OP_INC       = 0,
+    gcvFRAMEINFO_OP_DEC       = 1,
+    gcvFRAMEINFO_OP_ZERO      = 2,
+    gcvFRAMEINFO_OP_GET       = 3,
+
+
+    gcvFRAMEINFO_OP_COUNT,
+}
+gceFRAMEINFO_OP;
+
+
 /* Chip Power Status. */
 typedef enum _gceCHIPPOWERSTATE
 {
@@ -341,6 +388,11 @@ typedef enum _gceSURF_TYPE
 
     gcvSURF_PROTECTED_CONTENT  = 0x8000,  /* create it as content protected */
 
+    /* Create it as no compression, valid on when it has tile status. */
+    gcvSURF_NO_COMPRESSION     = 0x40000,
+
+    gcvSURF_CONTIGUOUS         = 0x20000,      /*create it as contiguous */
+
     gcvSURF_TEXTURE_LINEAR               = gcvSURF_TEXTURE
                                          | gcvSURF_LINEAR,
 
@@ -430,6 +482,8 @@ typedef enum _gceSURF_FLAG
     gcvSURF_FLAG_CONTENT_YINVERTED   = 0x4,
     /* content is protected */
     gcvSURF_FLAG_CONTENT_PROTECTED   = 0x8,
+    /* surface is contiguous. */
+    gcvSURF_FLAG_CONTIGUOUS          = (1 << 4),
 }
 gceSURF_FLAG;
 
@@ -551,6 +605,7 @@ typedef enum _gceSURF_FORMAT
     gcvSURF_S8D32F_1_G32R32F,
     gcvSURF_S8D32F_2_A8R8G8B8,
     gcvSURF_D24S8_1_A8R8G8B8,
+    gcvSURF_S8,
 
     /* Alpha formats. */
     gcvSURF_A4                  = 700,
@@ -984,6 +1039,7 @@ typedef enum _gce2D_TILE_STATUS_CONFIG
     gcv2D_TSC_COMPRESSED    = 0x00000002,
     gcv2D_TSC_DOWN_SAMPLER  = 0x00000004,
     gcv2D_TSC_2D_COMPRESSED = 0x00000008,
+    gcv2D_TSC_TPC_COMPRESSED = 0x00000010,
 }
 gce2D_TILE_STATUS_CONFIG;
 
@@ -1044,7 +1100,7 @@ typedef enum _gceTEXTURE_TYPE
 }
 gceTEXTURE_TYPE;
 
-#ifndef VIVANTE_NO_3D
+#if gcdENABLE_3D
 /* Texture functions. */
 typedef enum _gceTEXTURE_FUNCTION
 {
@@ -1078,7 +1134,7 @@ typedef enum _gceTEXTURE_CHANNEL
     gcvFROM_ONE_MINUS_ALPHA
 }
 gceTEXTURE_CHANNEL;
-#endif /* VIVANTE_NO_3D */
+#endif /* gcdENABLE_3D */
 
 /* Filter types. */
 typedef enum _gceFILTER_TYPE
@@ -1485,11 +1541,28 @@ typedef enum _gceHAL_ARG_VERSION
 gceHAL_ARG_VERSION;
 
 
-#define gcvALLOC_FLAG_NONE       (0)
-#define gcvALLOC_FLAG_CONTIGUOUS (1 << 0)
-#define gcvALLOC_FLAG_CACHEABLE  (1 << 1)
-#define gcvALLOC_FLAG_SECURITY   (1 << 2)
-#define gcvALLOC_FLAG_MEMLIMIT (1<<3)
+/*
+* Bit of a requirment is 1 means requirement is a must, 0 means requirement can
+* be ignored.
+*/
+#define gcvALLOC_FLAG_CONTIGUOUS_BIT        0
+#define gcvALLOC_FLAG_CACHEABLE_BIT         1
+#define gcvALLOC_FLAG_SECURITY_BIT          2
+#define gcvALLOC_FLAG_NON_CONTIGUOUS_BIT    3
+#define gcvALLOC_FLAG_MEMLIMIT_BIT    4
+
+/* No special needs. */
+#define gcvALLOC_FLAG_NONE              (0)
+/* Physical contiguous. */
+#define gcvALLOC_FLAG_CONTIGUOUS        (1 << gcvALLOC_FLAG_CONTIGUOUS_BIT)
+/* Can be remapped as cacheable. */
+#define gcvALLOC_FLAG_CACHEABLE         (1 << gcvALLOC_FLAG_CACHEABLE_BIT)
+/* Secure buffer. */
+#define gcvALLOC_FLAG_SECURITY          (1 << gcvALLOC_FLAG_SECURITY_BIT)
+/* Physical non contiguous. */
+#define gcvALLOC_FLAG_NON_CONTIGUOUS    (1 << gcvALLOC_FLAG_NON_CONTIGUOUS_BIT)
+#define gcvALLOC_FLAG_MEMLIMIT    (1 << gcvALLOC_FLAG_MEMLIMIT_BIT)
+
 /* GL_VIV internal usage */
 #ifndef GL_MAP_BUFFER_OBJ_VIV
 #define GL_MAP_BUFFER_OBJ_VIV       0x10000
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
index 6258527..df35019 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
@@ -25,7 +25,7 @@
 
 #ifndef __gc_hal_mem_h_
 #define __gc_hal_mem_h_
-#ifndef VIVANTE_NO_3D
+#if (gcdENABLE_3D || gcdENABLE_VG)
 
 #ifdef __cplusplus
 extern "C" {
@@ -526,5 +526,5 @@ gcfMEM_AFSMemPoolFreeANode(
 }
 #endif
 
-#endif /* VIVANTE_NO_3D */
+#endif /* (gcdENABLE_3D || gcdENABLE_VG) */
 #endif /* __gc_hal_mem_h_ */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
index a40ec70..2b416aa 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
@@ -18,7 +18,6 @@
 *
 *****************************************************************************/
 
-
 #ifndef __gc_hal_options_h_
 #define __gc_hal_options_h_
 
@@ -73,6 +72,10 @@
 #ifndef VIVANTE_PROFILER_NEW
 #   define VIVANTE_PROFILER_NEW                 0
 #endif
+
+#ifndef VIVANTE_PROFILER_PM
+#   define VIVANTE_PROFILER_PM                  1
+#endif
 /*
     gcdUSE_VG
 
@@ -494,8 +497,10 @@
 #ifndef gcdGPU_TIMEOUT
 #if gcdFPGA_BUILD
 #       define gcdGPU_TIMEOUT                   0
+#       define gcdGPU_2D_TIMEOUT                0
 #   else
 #       define gcdGPU_TIMEOUT                   20000
+#       define gcdGPU_2D_TIMEOUT                4000
 #   endif
 #endif
 
@@ -643,14 +648,6 @@
 #endif
 
 /*
-    gcdENABLE_VG
-            enable the 2D openVG
-*/
-#ifndef gcdENABLE_VG
-#   define gcdENABLE_VG                         0
-#endif
-
-/*
     gcdDISABLE_CORES_2D3D
             disable the 2D3D cores for 2D openVG
 */
@@ -703,14 +700,6 @@
 #endif
 
 /*
-    gcdENABLE_TS_DOUBLE_BUFFER
-            enable the TS double buffer, this is for 2D openVG
-*/
-#ifndef gcdENABLE_TS_DOUBLE_BUFFER
-#   define gcdENABLE_TS_DOUBLE_BUFFER           1
-#endif
-
-/*
     gcdMULTI_GPU
 
     Enable/disable multi-GPU support.
@@ -963,9 +952,10 @@
 
         Enable Direct-rendering (ie, No-Resolve) with tile status.
         This is expremental and in development stage.
+        This will dynamically check if color compression is available.
 */
 #ifndef gcdENABLE_RENDER_INTO_WINDOW_WITH_FC
-#   define gcdENABLE_RENDER_INTO_WINDOW_WITH_FC 0
+#   define gcdENABLE_RENDER_INTO_WINDOW_WITH_FC 1
 #endif
 
 /*
@@ -998,7 +988,7 @@
              'acquireFenceFd' for framebuffer target for DC
  */
 #ifndef gcdANDROID_NATIVE_FENCE_SYNC
-#   define gcdANDROID_NATIVE_FENCE_SYNC         0
+#   define gcdANDROID_NATIVE_FENCE_SYNC         3
 #endif
 
 /*
@@ -1108,13 +1098,15 @@
 #ifndef gcdMOVG
 #   define gcdMOVG                              0
 #if gcdMOVG
-#       undef  gcdENABLE_TS_DOUBLE_BUFFER
-#       define gcdENABLE_TS_DOUBLE_BUFFER       0
+#       define GC355_PROFILER                   1
 #   endif
+#       define gcdENABLE_TS_DOUBLE_BUFFER       1
 #else
 #if gcdMOVG
-#       undef  gcdENABLE_TS_DOUBLE_BUFFER
+#       define GC355_PROFILER                   1
 #       define gcdENABLE_TS_DOUBLE_BUFFER       0
+#else
+#       define gcdENABLE_TS_DOUBLE_BUFFER       1
 #endif
 #endif
 
@@ -1199,7 +1191,52 @@
 #ifndef gcdUSE_INPUT_DEVICE
 #   define gcdUSE_INPUT_DEVICE        1
 #endif
-#define LINUX_CMA_FSL 1
-#define DYNAMIC_MEMORY_RECORD 1
+
+
+/*
+    gcdFRAMEINFO_STATISTIC
+        When enable, collect frame information.
+*/
+#ifndef gcdFRAMEINFO_STATISTIC
+
+#if (defined(DBG) && DBG) || defined(DEBUG) || defined(_DEBUG) || gcdDUMP
+#   define gcdFRAMEINFO_STATISTIC      1
+#else
+#   define gcdFRAMEINFO_STATISTIC      0
+#endif
+
+#endif
+
+/*
+    gcdPACKED_OUTPUT_ADDRESS
+        When it's not zero, ps output is already packed after linked
+*/
+#ifndef gcdPACKED_OUTPUT_ADDRESS
+#   define gcdPACKED_OUTPUT_ADDRESS             1
+#endif
+
+/*
+    gcdENABLE_THIRD_PARTY_OPERATION
+        Enable third party operation like tpc or not.
+*/
+#ifndef gcdENABLE_THIRD_PARTY_OPERATION
+#   define gcdENABLE_THIRD_PARTY_OPERATION      1
+#endif
+
+
+/*
+    Core configurations. By default enable all cores.
+*/
+#ifndef gcdENABLE_3D
+#   define gcdENABLE_3D                         1
+#endif
+
+#ifndef gcdENABLE_2D
+#   define gcdENABLE_2D                         1
+#endif
+
+#ifndef gcdENABLE_VG
+#   define gcdENABLE_VG                         0
+#endif
 
 #endif /* __gc_hal_options_h_ */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
index d3428ee..d2abf9a 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
@@ -433,6 +433,7 @@ typedef struct _gcsPROFILER
     gctBOOL         enableHW;
     gctBOOL         enableSH;
     gctBOOL         isSyncMode;
+    gctBOOL         disableOutputCounter;
 
     gctBOOL         useSocket;
     gctINT          sockFd;
@@ -518,7 +519,8 @@ struct _gcsSHADER_PROFILER
 /* Initialize the gcsProfiler. */
 gceSTATUS
 gcoPROFILER_Initialize(
-    IN gcoHAL Hal
+    IN gcoHAL Hal,
+    IN gctBOOL Enable
     );
 
 /* Destroy the gcProfiler. */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
index 8462385..035b76e 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
@@ -1016,6 +1016,21 @@ gco2D_SetTargetRect(
     IN gcsRECT_PTR Rect
     );
 
+gceSTATUS
+gco2D_Set2DEngine(
+    IN gco2D Engine
+    );
+
+gceSTATUS
+gco2D_UnSet2DEngine(
+    IN gco2D Engine
+    );
+
+gceSTATUS
+gco2D_Get2DEngine(
+    OUT gco2D * Engine
+    );
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
index 4fa42ef..9325b10 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
@@ -444,20 +444,37 @@ typedef enum _gceSTATUS
     gcvSTATUS_NOT_MULTI_PIPE_ALIGNED =   -28,
 
     /* Linker errors. */
-    gcvSTATUS_GLOBAL_TYPE_MISMATCH  =   -1000,
-    gcvSTATUS_TOO_MANY_ATTRIBUTES   =   -1001,
-    gcvSTATUS_TOO_MANY_UNIFORMS     =   -1002,
-    gcvSTATUS_TOO_MANY_VARYINGS     =   -1003,
-    gcvSTATUS_UNDECLARED_VARYING    =   -1004,
-    gcvSTATUS_VARYING_TYPE_MISMATCH =   -1005,
-    gcvSTATUS_MISSING_MAIN          =   -1006,
-    gcvSTATUS_NAME_MISMATCH         =   -1007,
-    gcvSTATUS_INVALID_INDEX         =   -1008,
-    gcvSTATUS_UNIFORM_TYPE_MISMATCH =   -1009,
+    gcvSTATUS_GLOBAL_TYPE_MISMATCH              =   -1000,
+    gcvSTATUS_TOO_MANY_ATTRIBUTES               =   -1001,
+    gcvSTATUS_TOO_MANY_UNIFORMS                 =   -1002,
+    gcvSTATUS_TOO_MANY_VARYINGS                 =   -1003,
+    gcvSTATUS_UNDECLARED_VARYING                =   -1004,
+    gcvSTATUS_VARYING_TYPE_MISMATCH             =   -1005,
+    gcvSTATUS_MISSING_MAIN                      =   -1006,
+    gcvSTATUS_NAME_MISMATCH                     =   -1007,
+    gcvSTATUS_INVALID_INDEX                     =   -1008,
+    gcvSTATUS_UNIFORM_MISMATCH                  =   -1009,
+    gcvSTATUS_UNSAT_LIB_SYMBOL                  =   -1010,
+    gcvSTATUS_TOO_MANY_SHADERS                  =   -1011,
+    gcvSTATUS_LINK_INVALID_SHADERS              =   -1012,
+    gcvSTATUS_CS_NO_WORKGROUP_SIZE              =   -1013,
+    gcvSTATUS_LINK_LIB_ERROR                    =   -1014,
+
+    gcvSTATUS_SHADER_VERSION_MISMATCH           =   -1015,
+    gcvSTATUS_TOO_MANY_INSTRUCTION              =   -1016,
+    gcvSTATUS_SSBO_MISMATCH                     =   -1017,
+    gcvSTATUS_TOO_MANY_OUTPUT                   =   -1018,
+    gcvSTATUS_TOO_MANY_INPUT                    =   -1019,
+    gcvSTATUS_NOT_SUPPORT_CL                    =   -1020,
+    gcvSTATUS_NOT_SUPPORT_INTEGER               =   -1021,
+    gcvSTATUS_UNIFORM_TYPE_MISMATCH             =   -1022,
 
     /* Compiler errors. */
-    gcvSTATUS_COMPILER_FE_PREPROCESSOR_ERROR = -2000,
-    gcvSTATUS_COMPILER_FE_PARSER_ERROR = -2001,
+    gcvSTATUS_COMPILER_FE_PREPROCESSOR_ERROR    =   -2000,
+    gcvSTATUS_COMPILER_FE_PARSER_ERROR          =   -2001,
+
+    /* Recompilation Errors */
+    gcvSTATUS_RECOMPILER_CONVERT_UNIMPLEMENTED  =   -3000,
 }
 gceSTATUS;
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
index c21b41d..7e281d2 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
@@ -28,9 +28,9 @@
 
 #define gcvVERSION_PATCH        11
 
-#define gcvVERSION_BUILD     19959
+#define gcvVERSION_BUILD     23085
 
-#define gcvVERSION_STRING    "5.0.11.p1.19959"
+#define gcvVERSION_STRING    "5.0.11.p3.23085"
 
 #define gcvVERSION_DATE      __DATE__
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
index 11b8499..09e8b96 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
@@ -343,6 +343,18 @@ gceSTATUS
 gckVGKERNEL_Destroy(
     IN gckVGKERNEL Kernel
     );
+
+/* Allocate linear video memory. */
+gceSTATUS
+gckVGKERNEL_AllocateLinearMemory(
+    IN gckKERNEL Kernel,
+    IN OUT gcePOOL * Pool,
+    IN gctSIZE_T Bytes,
+    IN gctUINT32 Alignment,
+    IN gceSURF_TYPE Type,
+    OUT gcuVIDMEM_NODE_PTR * Node
+    );
+
 /* Unmap memory. */
 gceSTATUS
 gckKERNEL_UnmapMemory(
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_array.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_array.h
new file mode 100644
index 0000000..fa2190f
--- /dev/null
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_array.h
@@ -0,0 +1,34 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+extern gceSTATUS
+_DefaultAlloctorInit(
+    IN gckOS Os,
+    OUT gckALLOCATOR * Allocator
+    );
+
+gcsALLOCATOR_DESC allocatorArray[] =
+{
+    /* Default allocator. */
+    gcmkDEFINE_ALLOCATOR_DESC("default", _DefaultAlloctorInit),
+};
+
+
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_array.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_array.h
new file mode 100644
index 0000000..acdd929
--- /dev/null
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_array.h
@@ -0,0 +1,45 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+extern gceSTATUS
+_DefaultAlloctorInit(
+    IN gckOS Os,
+    OUT gckALLOCATOR * Allocator
+    );
+
+#if LINUX_CMA_FSL
+gceSTATUS
+_CMAFSLAlloctorInit(
+    IN gckOS Os,
+    OUT gckALLOCATOR * Allocator
+    );
+#endif
+
+gcsALLOCATOR_DESC allocatorArray[] =
+{
+#if LINUX_CMA_FSL
+    gcmkDEFINE_ALLOCATOR_DESC("cmafsl", _CMAFSLAlloctorInit),
+#endif
+    /* Default allocator. */
+    gcmkDEFINE_ALLOCATOR_DESC("default", _DefaultAlloctorInit),
+};
+
+
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_cma.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_cma.c
new file mode 100644
index 0000000..d4611d0
--- /dev/null
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_cma.c
@@ -0,0 +1,410 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+#include "gc_hal_kernel_linux.h"
+#include "gc_hal_kernel_allocator.h"
+
+#include <linux/pagemap.h>
+#include <linux/seq_file.h>
+#include <linux/mman.h>
+#include <asm/atomic.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+typedef struct _gcsCMA_PRIV * gcsCMA_PRIV_PTR;
+typedef struct _gcsCMA_PRIV {
+    gctUINT32 cmasize;
+}
+gcsCMA_PRIV;
+
+struct mdl_cma_priv {
+    gctPOINTER kvaddr;
+    dma_addr_t physical;
+};
+
+int gc_cma_usage_show(struct seq_file* m, void* data)
+{
+    gcsINFO_NODE *node = m->private;
+    gckALLOCATOR Allocator = node->device;
+    gcsCMA_PRIV_PTR priv = Allocator->privateData;
+
+    seq_printf(m, "cma:  %u bytes\n", priv->cmasize);
+
+    return 0;
+}
+
+static gcsINFO InfoList[] =
+{
+    {"cmausage", gc_cma_usage_show},
+};
+
+static void
+_DefaultAllocatorDebugfsInit(
+    IN gckALLOCATOR Allocator,
+    IN gckDEBUGFS_DIR Root
+    )
+{
+    gcmkVERIFY_OK(
+        gckDEBUGFS_DIR_Init(&Allocator->debugfsDir, Root->root, "cma"));
+
+    gcmkVERIFY_OK(gckDEBUGFS_DIR_CreateFiles(
+        &Allocator->debugfsDir,
+        InfoList,
+        gcmCOUNTOF(InfoList),
+        Allocator
+        ));
+}
+
+static void
+_DefaultAllocatorDebugfsCleanup(
+    IN gckALLOCATOR Allocator
+    )
+{
+    gcmkVERIFY_OK(gckDEBUGFS_DIR_RemoveFiles(
+        &Allocator->debugfsDir,
+        InfoList,
+        gcmCOUNTOF(InfoList)
+        ));
+
+    gckDEBUGFS_DIR_Deinit(&Allocator->debugfsDir);
+}
+
+static gceSTATUS
+_CMAFSLAlloc(
+    IN gckALLOCATOR Allocator,
+    INOUT PLINUX_MDL Mdl,
+    IN gctSIZE_T NumPages,
+    IN gctUINT32 Flags
+    )
+{
+    gceSTATUS status;
+    gctPOINTER addr = gcvNULL;
+    gcsCMA_PRIV_PTR priv = (gcsCMA_PRIV_PTR)Allocator->privateData;
+
+    struct mdl_cma_priv *mdl_priv=gcvNULL;
+    gckOS os = Allocator->os;
+
+    gcmkHEADER_ARG("Mdl=%p NumPages=%d", Mdl, NumPages);
+
+    gcmkONERROR(gckOS_Allocate(os, sizeof(struct mdl_cma_priv), (gctPOINTER *)&mdl_priv));
+
+    mdl_priv->kvaddr = dma_alloc_writecombine(gcvNULL,
+            NumPages * PAGE_SIZE,
+            &mdl_priv->physical,
+            GFP_KERNEL | gcdNOWARN);
+
+    if (addr == gcvNULL)
+    {
+        gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+    }
+
+    Mdl->priv = mdl_priv;
+    priv->cmasize += NumPages * PAGE_SIZE;
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    if(mdl_priv)
+        gckOS_Free(os, mdl_priv);
+    gcmkFOOTER();
+    return status;
+}
+
+static void
+_CMAFSLFree(
+    IN gckALLOCATOR Allocator,
+    IN OUT PLINUX_MDL Mdl
+    )
+{
+    gckOS os = Allocator->os;
+    struct mdl_cma_priv *mdl_priv=(struct mdl_cma_priv *)Mdl->priv;
+    gcsCMA_PRIV_PTR priv = (gcsCMA_PRIV_PTR)Allocator->privateData;
+    dma_free_writecombine(gcvNULL,
+            Mdl->numPages * PAGE_SIZE,
+            mdl_priv->kvaddr,
+            mdl_priv->physical);
+     gckOS_Free(os, mdl_priv);
+    priv->cmasize -= Mdl->numPages * PAGE_SIZE;
+}
+
+gctINT
+_CMAFSLMapUser(
+    gckALLOCATOR Allocator,
+    PLINUX_MDL Mdl,
+    PLINUX_MDL_MAP MdlMap,
+    gctBOOL Cacheable
+    )
+{
+
+    PLINUX_MDL      mdl = Mdl;
+    PLINUX_MDL_MAP  mdlMap = MdlMap;
+    struct mdl_cma_priv *mdl_priv=(struct mdl_cma_priv *)Mdl->priv;
+
+    gcmkHEADER_ARG("Allocator=%p Mdl=%p MdlMap=%p gctBOOL=%d", Allocator, Mdl, MdlMap, Cacheable);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+    mdlMap->vmaAddr = (gctSTRING)vm_mmap(gcvNULL,
+                    0L,
+                    mdl->numPages * PAGE_SIZE,
+                    PROT_READ | PROT_WRITE,
+                    MAP_SHARED,
+                    0);
+#else
+    down_write(&current->mm->mmap_sem);
+
+    mdlMap->vmaAddr = (gctSTRING)do_mmap_pgoff(gcvNULL,
+                    0L,
+                    mdl->numPages * PAGE_SIZE,
+                    PROT_READ | PROT_WRITE,
+                    MAP_SHARED,
+                    0);
+
+    up_write(&current->mm->mmap_sem);
+#endif
+
+    gcmkTRACE_ZONE(
+        gcvLEVEL_INFO, gcvZONE_OS,
+        "%s(%d): vmaAddr->0x%X for phys_addr->0x%X",
+        __FUNCTION__, __LINE__,
+        (gctUINT32)(gctUINTPTR_T)mdlMap->vmaAddr,
+        (gctUINT32)(gctUINTPTR_T)mdl
+        );
+
+    if (IS_ERR(mdlMap->vmaAddr))
+    {
+        gcmkTRACE_ZONE(
+            gcvLEVEL_INFO, gcvZONE_OS,
+            "%s(%d): do_mmap_pgoff error",
+            __FUNCTION__, __LINE__
+            );
+
+        mdlMap->vmaAddr = gcvNULL;
+
+        gcmkFOOTER_ARG("*status=%d", gcvSTATUS_OUT_OF_MEMORY);
+        return gcvSTATUS_OUT_OF_MEMORY;
+    }
+
+    down_write(&current->mm->mmap_sem);
+
+    mdlMap->vma = find_vma(current->mm, (unsigned long)mdlMap->vmaAddr);
+
+    if (mdlMap->vma == gcvNULL)
+    {
+        up_write(&current->mm->mmap_sem);
+
+        gcmkTRACE_ZONE(
+            gcvLEVEL_INFO, gcvZONE_OS,
+            "%s(%d): find_vma error",
+            __FUNCTION__, __LINE__
+            );
+
+        mdlMap->vmaAddr = gcvNULL;
+
+        gcmkFOOTER_ARG("*status=%d", gcvSTATUS_OUT_OF_RESOURCES);
+        return gcvSTATUS_OUT_OF_RESOURCES;
+    }
+
+    /* Now map all the vmalloc pages to this user address. */
+    if (mdl->contiguous)
+    {
+        /* map kernel memory to user space.. */
+        if (dma_mmap_writecombine(gcvNULL,
+                mdlMap->vma,
+                mdl_priv->kvaddr,
+                mdl_priv->physical,
+                mdl->numPages * PAGE_SIZE) < 0)
+        {
+            up_write(&current->mm->mmap_sem);
+
+            gcmkTRACE_ZONE(
+                gcvLEVEL_WARNING, gcvZONE_OS,
+                "%s(%d): dma_mmap_attrs error",
+                __FUNCTION__, __LINE__
+                );
+
+             mdlMap->vmaAddr = gcvNULL;
+
+            gcmkFOOTER_ARG("*status=%d", gcvSTATUS_OUT_OF_MEMORY);
+            return gcvSTATUS_OUT_OF_MEMORY;
+        }
+    }
+    else
+    {
+        gckOS_Print("incorrect mdl:conti%d\n",mdl->contiguous);
+    }
+
+    up_write(&current->mm->mmap_sem);
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+void
+_CMAUnmapUser(
+    IN gckALLOCATOR Allocator,
+    IN gctPOINTER Logical,
+    IN gctUINT32 Size
+    )
+{
+    if (unlikely(current->mm == gcvNULL))
+    {
+        /* Do nothing if process is exiting. */
+        return;
+    }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+    if (vm_munmap((unsigned long)Logical, Size) < 0)
+    {
+        gcmkTRACE_ZONE(
+                gcvLEVEL_WARNING, gcvZONE_OS,
+                "%s(%d): vm_munmap failed",
+                __FUNCTION__, __LINE__
+                );
+    }
+#else
+    down_write(&current->mm->mmap_sem);
+    if (do_munmap(current->mm, (unsigned long)Logical, Size) < 0)
+    {
+        gcmkTRACE_ZONE(
+                gcvLEVEL_WARNING, gcvZONE_OS,
+                "%s(%d): do_munmap failed",
+                __FUNCTION__, __LINE__
+                );
+    }
+    up_write(&current->mm->mmap_sem);
+#endif
+}
+
+gceSTATUS
+_CMAMapKernel(
+    IN gckALLOCATOR Allocator,
+    IN PLINUX_MDL Mdl,
+    OUT gctPOINTER *Logical
+    )
+{
+    struct mdl_cma_priv *mdl_priv=(struct mdl_cma_priv *)Mdl->priv;
+    *Logical =mdl_priv->kvaddr;
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+_CMAUnmapKernel(
+    IN gckALLOCATOR Allocator,
+    IN PLINUX_MDL Mdl,
+    IN gctPOINTER Logical
+    )
+{
+    return gcvSTATUS_OK;
+}
+
+extern gceSTATUS
+_DefaultLogicalToPhysical(
+    IN gckALLOCATOR Allocator,
+    IN PLINUX_MDL Mdl,
+    IN gctPOINTER Logical,
+    IN gctUINT32 ProcessID,
+    OUT gctUINT32_PTR Physical
+    );
+
+extern gceSTATUS
+_DefaultCache(
+    IN gckALLOCATOR Allocator,
+    IN PLINUX_MDL Mdl,
+    IN gctPOINTER Logical,
+    IN gctUINT32 Physical,
+    IN gctUINT32 Bytes,
+    IN gceCACHEOPERATION Operation
+    );
+
+gceSTATUS
+_CMAPhysical(
+    IN gckALLOCATOR Allocator,
+    IN PLINUX_MDL Mdl,
+    IN gctUINT32 Offset,
+    OUT gctUINT32_PTR Physical
+    )
+{
+    struct mdl_cma_priv *mdl_priv=(struct mdl_cma_priv *)Mdl->priv;
+     gcmkASSERT(!Offset);
+    *Physical = mdl_priv->physical;
+
+    return gcvSTATUS_OK;
+}
+
+
+extern void
+_DefaultAllocatorDestructor(
+    IN void* PrivateData
+    );
+
+/* Default allocator operations. */
+gcsALLOCATOR_OPERATIONS CMAFSLAllocatorOperations = {
+    .Alloc              = _CMAFSLAlloc,
+    .Free               = _CMAFSLFree,
+    .MapUser            = _CMAFSLMapUser,
+    .UnmapUser          = _CMAUnmapUser,
+    .MapKernel          = _CMAMapKernel,
+    .UnmapKernel        = _CMAUnmapKernel,
+    .LogicalToPhysical  = _DefaultLogicalToPhysical,
+    .Cache              = _DefaultCache,
+    .Physical           = _CMAPhysical,
+};
+
+/* Default allocator entry. */
+gceSTATUS
+_CMAFSLAlloctorInit(
+    IN gckOS Os,
+    OUT gckALLOCATOR * Allocator
+    )
+{
+    gceSTATUS status;
+    gckALLOCATOR allocator;
+    gcsCMA_PRIV_PTR priv = gcvNULL;
+
+    gcmkONERROR(
+        gckALLOCATOR_Construct(Os, &CMAFSLAllocatorOperations, &allocator));
+
+    priv = kzalloc(gcmSIZEOF(gcsCMA_PRIV), GFP_KERNEL | gcdNOWARN);
+
+    if (!priv)
+    {
+        gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+    }
+
+    /* Register private data. */
+    allocator->privateData = priv;
+    allocator->privateDataDestructor = _DefaultAllocatorDestructor;
+
+    allocator->debugfsInit = _DefaultAllocatorDebugfsInit;
+    allocator->debugfsCleanup = _DefaultAllocatorDebugfsCleanup;
+
+    allocator->capability = gcvALLOC_FLAG_CONTIGUOUS;
+
+    *Allocator = allocator;
+
+    return gcvSTATUS_OK;
+
+OnError:
+    return status;
+}
+
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.c
index 9e04c05..193b5d9 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.c
@@ -33,6 +33,66 @@
 
 #define _GC_OBJ_ZONE    gcvZONE_OS
 
+typedef struct _gcsDEFAULT_PRIV * gcsDEFAULT_PRIV_PTR;
+typedef struct _gcsDEFAULT_PRIV {
+    gctUINT32 low;
+    gctUINT32 high;
+}
+gcsDEFAULT_PRIV;
+
+/******************************************************************************\
+************************** Default Allocator Debugfs ***************************
+\******************************************************************************/
+
+int gc_usage_show(struct seq_file* m, void* data)
+{
+    gcsINFO_NODE *node = m->private;
+    gckALLOCATOR Allocator = node->device;
+    gcsDEFAULT_PRIV_PTR priv = Allocator->privateData;
+
+    seq_printf(m, "low:  %u bytes\n", priv->low);
+    seq_printf(m, "high: %u bytes\n", priv->high);
+
+    return 0;
+}
+
+static gcsINFO InfoList[] =
+{
+    {"lowHighUsage", gc_usage_show},
+};
+
+static void
+_DefaultAllocatorDebugfsInit(
+    IN gckALLOCATOR Allocator,
+    IN gckDEBUGFS_DIR Root
+    )
+{
+    gcmkVERIFY_OK(
+        gckDEBUGFS_DIR_Init(&Allocator->debugfsDir, Root->root, "default"));
+
+    gcmkVERIFY_OK(gckDEBUGFS_DIR_CreateFiles(
+        &Allocator->debugfsDir,
+        InfoList,
+        gcmCOUNTOF(InfoList),
+        Allocator
+        ));
+}
+
+static void
+_DefaultAllocatorDebugfsCleanup(
+    IN gckALLOCATOR Allocator
+    )
+{
+    gcmkVERIFY_OK(gckDEBUGFS_DIR_RemoveFiles(
+        &Allocator->debugfsDir,
+        InfoList,
+        gcmCOUNTOF(InfoList)
+        ));
+
+    gckDEBUGFS_DIR_Deinit(&Allocator->debugfsDir);
+}
+
+
 static void
 _NonContiguousFree(
     IN struct page ** Pages,
@@ -227,7 +287,6 @@ _UnmapUserLogical(
 ************************ Default Allocator **********************************
 \***************************************************************************/
 #define C_MAX_PAGENUM  (50*1024)
-
 static gceSTATUS
 _DefaultAlloc(
     IN gckALLOCATOR Allocator,
@@ -245,23 +304,25 @@ _DefaultAlloc(
     gctUINT32 numPages;
     gctUINT i = 0;
     gctBOOL contiguous = Flags & gcvALLOC_FLAG_CONTIGUOUS;
-
     struct sysinfo temsysinfo;
+    gcsDEFAULT_PRIV_PTR priv = (gcsDEFAULT_PRIV_PTR)Allocator->privateData;
 
     gcmkHEADER_ARG("Mdl=%p NumPages=%d", Mdl, NumPages);
 
     numPages = NumPages;
     bytes = NumPages * PAGE_SIZE;
     order = get_order(bytes);
+
     si_meminfo(&temsysinfo);
-    if ((Flags & gcvALLOC_FLAG_MEMLIMIT))
+
+    if (Flags & gcvALLOC_FLAG_MEMLIMIT)
     {
         if ( (temsysinfo.freeram < NumPages) || ((temsysinfo.freeram-NumPages) < C_MAX_PAGENUM) )
         {
             gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
         }
     }
-     
+
     if (contiguous)
     {
         if (order >= MAX_ORDER)
@@ -295,7 +356,7 @@ _DefaultAlloc(
     }
     else
     {
-       Mdl->u.nonContiguousPages = _NonContiguousAlloc(numPages);
+        Mdl->u.nonContiguousPages = _NonContiguousAlloc(numPages);
     }
 
     if (Mdl->u.contiguousPages == gcvNULL && Mdl->u.nonContiguousPages == gcvNULL)
@@ -325,6 +386,8 @@ _DefaultAlloc(
                                  page_to_phys(page),
                                  page_address(page),
                                  PAGE_SIZE));
+
+            priv->low += PAGE_SIZE;
         }
         else
         {
@@ -342,6 +405,8 @@ _DefaultAlloc(
                     );
             }
 #endif
+
+            priv->high += PAGE_SIZE;
         }
     }
 
@@ -360,16 +425,29 @@ _DefaultFree(
     )
 {
     gctINT i;
+    struct page * page;
+    gcsDEFAULT_PRIV_PTR priv = (gcsDEFAULT_PRIV_PTR)Allocator->privateData;
 
     for (i = 0; i < Mdl->numPages; i++)
     {
         if (Mdl->contiguous)
         {
-            ClearPageReserved(nth_page(Mdl->u.contiguousPages, i));
+            page = nth_page(Mdl->u.contiguousPages, i);
+        }
+        else
+        {
+            page = _NonContiguousToPage(Mdl->u.nonContiguousPages, i);
+        }
+
+        ClearPageReserved(page);
+
+        if (PageHighMem(page))
+        {
+            priv->high -= PAGE_SIZE;
         }
         else
         {
-            ClearPageReserved(_NonContiguousToPage(Mdl->u.nonContiguousPages, i));
+            priv->low -= PAGE_SIZE;
         }
     }
 
@@ -475,8 +553,13 @@ _DefaultMapUser(
         return gcvSTATUS_OUT_OF_RESOURCES;
     }
 
+    mdlMap->vma->vm_flags |= gcdVM_FLAGS;
 
-
+    if (Cacheable == gcvFALSE)
+    {
+        /* Make this mapping non-cached. */
+        mdlMap->vma->vm_page_prot = gcmkPAGED_MEMROY_PROT(mdlMap->vma->vm_page_prot);
+    }
 
     if (platform && platform->ops->adjustProt)
     {
@@ -489,14 +572,6 @@ _DefaultMapUser(
     if (mdl->contiguous)
     {
         /* map kernel memory to user space.. */
-        mdlMap->vma->vm_flags |= gcdVM_FLAGS;
-
-        if (Cacheable == gcvFALSE)
-        {
-            /* Make this mapping non-cached. */
-            mdlMap->vma->vm_page_prot = gcmkPAGED_MEMROY_PROT(mdlMap->vma->vm_page_prot);
-        }
-
         if (remap_pfn_range(mdlMap->vma,
                             mdlMap->vma->vm_start,
                             page_to_pfn(mdl->u.contiguousPages),
@@ -519,14 +594,6 @@ _DefaultMapUser(
     }
     else
     {
-        mdlMap->vma->vm_flags |= gcdVM_FLAGS;
-
-        if (Cacheable == gcvFALSE)
-        {
-            /* Make this mapping non-cached. */
-            mdlMap->vma->vm_page_prot = gcmkPAGED_MEMROY_PROT(mdlMap->vma->vm_page_prot);
-        }
-
         start = mdlMap->vma->vm_start;
 
         for (i = 0; i < mdl->numPages; i++)
@@ -630,6 +697,14 @@ _DefaultPhysical(
     return gcvSTATUS_OK;
 }
 
+void
+_DefaultAllocatorDestructor(
+    IN void* PrivateData
+    )
+{
+    kfree(PrivateData);
+}
+
 /* Default allocator operations. */
 gcsALLOCATOR_OPERATIONS DefaultAllocatorOperations = {
     .Alloc              = _DefaultAlloc,
@@ -652,208 +727,25 @@ _DefaultAlloctorInit(
 {
     gceSTATUS status;
     gckALLOCATOR allocator;
+    gcsDEFAULT_PRIV_PTR priv = gcvNULL;
 
     gcmkONERROR(
         gckALLOCATOR_Construct(Os, &DefaultAllocatorOperations, &allocator));
 
-    *Allocator = allocator;
-
-    return gcvSTATUS_OK;
-
-OnError:
-    return status;
-}
-#if LINUX_CMA_FSL
+    priv = kzalloc(gcmSIZEOF(gcsDEFAULT_PRIV), GFP_KERNEL | gcdNOWARN);
 
-static gceSTATUS
-_CMAFSLAlloc(
-    IN gckALLOCATOR Allocator,
-    INOUT PLINUX_MDL Mdl,
-    IN gctSIZE_T NumPages,
-    IN gctUINT32 Flags
-    )
-{
-    gceSTATUS status;
-    gctPOINTER addr = gcvNULL;
-
-    gcmkHEADER_ARG("Mdl=%p NumPages=%d", Mdl, NumPages);
-
-    addr = dma_alloc_writecombine(gcvNULL,
-            NumPages * PAGE_SIZE,
-            &Mdl->dmaHandle,
-            GFP_KERNEL | gcdNOWARN);
-
-    if (addr == gcvNULL)
+    if (!priv)
     {
         gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
     }
 
-    Mdl->addr = addr;
-
-    gcmkFOOTER_NO();
-    return gcvSTATUS_OK;
-
-OnError:
-    gcmkFOOTER();
-    return status;
-}
+    /* Register private data. */
+    allocator->privateData = priv;
+    allocator->privateDataDestructor = _DefaultAllocatorDestructor;
 
-static void
-_CMAFSLFree(
-    IN gckALLOCATOR Allocator,
-    IN OUT PLINUX_MDL Mdl
-    )
-{
-    dma_free_writecombine(gcvNULL,
-            Mdl->numPages * PAGE_SIZE,
-            Mdl->addr,
-            Mdl->dmaHandle);
-}
+    allocator->debugfsInit = _DefaultAllocatorDebugfsInit;
+    allocator->debugfsCleanup = _DefaultAllocatorDebugfsCleanup;
 
-gctINT
-_CMAFSLMapUser(
-    gckALLOCATOR Allocator,
-    PLINUX_MDL Mdl,
-    PLINUX_MDL_MAP MdlMap,
-    gctBOOL Cacheable
-    )
-{
-
-    gctSTRING       addr;
-    PLINUX_MDL      mdl = Mdl;
-    PLINUX_MDL_MAP  mdlMap = MdlMap;
-
-    gcmkHEADER_ARG("Allocator=%p Mdl=%p MdlMap=%p gctBOOL=%d", Allocator, Mdl, MdlMap, Cacheable);
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
-    mdlMap->vmaAddr = (gctSTRING)vm_mmap(gcvNULL,
-                    0L,
-                    mdl->numPages * PAGE_SIZE,
-                    PROT_READ | PROT_WRITE,
-                    MAP_SHARED,
-                    0);
-#else
-    down_write(&current->mm->mmap_sem);
-
-    mdlMap->vmaAddr = (gctSTRING)do_mmap_pgoff(gcvNULL,
-                    0L,
-                    mdl->numPages * PAGE_SIZE,
-                    PROT_READ | PROT_WRITE,
-                    MAP_SHARED,
-                    0);
-
-    up_write(&current->mm->mmap_sem);
-#endif
-
-    gcmkTRACE_ZONE(
-        gcvLEVEL_INFO, gcvZONE_OS,
-        "%s(%d): vmaAddr->0x%X for phys_addr->0x%X",
-        __FUNCTION__, __LINE__,
-        (gctUINT32)(gctUINTPTR_T)mdlMap->vmaAddr,
-        (gctUINT32)(gctUINTPTR_T)mdl
-        );
-
-    if (IS_ERR(mdlMap->vmaAddr))
-    {
-        gcmkTRACE_ZONE(
-            gcvLEVEL_INFO, gcvZONE_OS,
-            "%s(%d): do_mmap_pgoff error",
-            __FUNCTION__, __LINE__
-            );
-
-        mdlMap->vmaAddr = gcvNULL;
-
-        gcmkFOOTER_ARG("*status=%d", gcvSTATUS_OUT_OF_MEMORY);
-        return gcvSTATUS_OUT_OF_MEMORY;
-    }
-
-    down_write(&current->mm->mmap_sem);
-
-    mdlMap->vma = find_vma(current->mm, (unsigned long)mdlMap->vmaAddr);
-
-    if (mdlMap->vma == gcvNULL)
-    {
-        up_write(&current->mm->mmap_sem);
-
-        gcmkTRACE_ZONE(
-            gcvLEVEL_INFO, gcvZONE_OS,
-            "%s(%d): find_vma error",
-            __FUNCTION__, __LINE__
-            );
-
-        mdlMap->vmaAddr = gcvNULL;
-
-        gcmkFOOTER_ARG("*status=%d", gcvSTATUS_OUT_OF_RESOURCES);
-        return gcvSTATUS_OUT_OF_RESOURCES;
-    }
-
-    addr = mdl->addr;
-
-    /* Now map all the vmalloc pages to this user address. */
-    if (mdl->contiguous && (!mdl->cacheable))
-    {
-        /* map kernel memory to user space.. */
-        if (dma_mmap_writecombine(gcvNULL,
-                mdlMap->vma,
-                mdl->addr,
-                mdl->dmaHandle,
-                mdl->numPages * PAGE_SIZE) < 0)
-        {
-            up_write(&current->mm->mmap_sem);
-
-            gcmkTRACE_ZONE(
-                gcvLEVEL_WARNING, gcvZONE_OS,
-                "%s(%d): dma_mmap_attrs error",
-                __FUNCTION__, __LINE__
-                );
-
-             mdlMap->vmaAddr = gcvNULL;
-
-            gcmkFOOTER_ARG("*status=%d", gcvSTATUS_OUT_OF_MEMORY);
-            return gcvSTATUS_OUT_OF_MEMORY;
-        }
-    }
-    else
-    {
-        gckOS_Print("incorrect mdl:conti%d:cachable:%d\n",mdl->contiguous, mdl->cacheable);        
-    }
-
-    up_write(&current->mm->mmap_sem);
-
-    gcmkFOOTER_NO();
-    return gcvSTATUS_OK;
-}
-
-
-
-/* Default allocator operations. */
-gcsALLOCATOR_OPERATIONS CMAFSLAllocatorOperations = {
-    .Alloc              = _CMAFSLAlloc,
-    .Free               = _CMAFSLFree,
-    .MapUser            = _CMAFSLMapUser,
-    .UnmapUser          = _DefaultUnmapUser,
-    .MapKernel          = _DefaultMapKernel,
-    .UnmapKernel        = _DefaultUnmapKernel,
-    .LogicalToPhysical  = _DefaultLogicalToPhysical,
-    .Cache              = _DefaultCache,
-    .Physical           = _DefaultPhysical,
-};
-
-/* Default allocator entry. */
-gceSTATUS
-_CMAFSLAlloctorInit(
-    IN gckOS Os,
-    OUT gckALLOCATOR * Allocator
-    )
-{
-    gceSTATUS status;
-    gckALLOCATOR allocator;
-
-    gcmkONERROR(
-        gckALLOCATOR_Construct(Os, &CMAFSLAllocatorOperations, &allocator));
-
-    allocator->privateData = (void *)1;
-        
     *Allocator = allocator;
 
     return gcvSTATUS_OK;
@@ -862,7 +754,6 @@ OnError:
     return status;
 }
 
-#endif
 /***************************************************************************\
 ************************ Allocator helper ***********************************
 \***************************************************************************/
@@ -906,6 +797,12 @@ gckALLOCATOR_Construct(
     /* Set operations. */
     allocator->ops = Operations;
 
+    allocator->capability = gcvALLOC_FLAG_CONTIGUOUS
+                          | gcvALLOC_FLAG_NON_CONTIGUOUS
+                          | gcvALLOC_FLAG_CACHEABLE
+                          | gcvALLOC_FLAG_MEMLIMIT;
+                          ;
+
     *Allocator = allocator;
 
     gcmkFOOTER_NO();
@@ -916,6 +813,38 @@ OnError:
     return status;
 }
 
+/******************************************************************************\
+******************************** Debugfs Support *******************************
+\******************************************************************************/
+
+static gceSTATUS
+_AllocatorDebugfsInit(
+    IN gckOS Os
+    )
+{
+    gceSTATUS status;
+    gckGALDEVICE device = Os->device;
+
+    gckDEBUGFS_DIR dir = &Os->allocatorDebugfsDir;
+
+    gcmkONERROR(gckDEBUGFS_DIR_Init(dir, device->debugfsDir.root, "allocators"));
+
+    return gcvSTATUS_OK;
+
+OnError:
+    return status;
+}
+
+static void
+_AllocatorDebugfsCleanup(
+    IN gckOS Os
+    )
+{
+    gckDEBUGFS_DIR dir = &Os->allocatorDebugfsDir;
+
+    gckDEBUGFS_DIR_Deinit(dir);
+}
+
 /***************************************************************************\
 ************************ Allocator management *******************************
 \***************************************************************************/
@@ -929,6 +858,8 @@ gckOS_ImportAllocators(
     gctUINT i;
     gckALLOCATOR allocator;
 
+    _AllocatorDebugfsInit(Os);
+
     INIT_LIST_HEAD(&Os->allocatorList);
 
     for (i = 0; i < gcmCOUNTOF(allocatorArray); i++)
@@ -946,10 +877,30 @@ gckOS_ImportAllocators(
                 continue;
             }
 
-            list_add(&allocator->head, &Os->allocatorList);
+            allocator->name = allocatorArray[i].name;
+
+            if (allocator->debugfsInit)
+            {
+                /* Init allocator's debugfs. */
+                allocator->debugfsInit(allocator, &Os->allocatorDebugfsDir);
+            }
+
+            list_add_tail(&allocator->head, &Os->allocatorList);
         }
     }
 
+#if gcdDEBUG
+    list_for_each_entry(allocator, &Os->allocatorList, head)
+    {
+        gcmkTRACE_ZONE(
+            gcvLEVEL_WARNING, gcvZONE_OS,
+            "%s(%d) Allocator: %s",
+            __FUNCTION__, __LINE__,
+            allocator->name
+            );
+    }
+#endif
+
     return gcvSTATUS_OK;
 }
 
@@ -965,6 +916,12 @@ gckOS_FreeAllocators(
     {
         list_del(&allocator->head);
 
+        if (allocator->debugfsCleanup)
+        {
+            /* Clean up allocator's debugfs. */
+            allocator->debugfsCleanup(allocator);
+        }
+
         /* Free private data. */
         if (allocator->privateDataDestructor && allocator->privateData)
         {
@@ -974,6 +931,8 @@ gckOS_FreeAllocators(
         gckOS_Free(Os, allocator);
     }
 
+    _AllocatorDebugfsCleanup(Os);
+
     return gcvSTATUS_OK;
 }
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.h
index f0bf974..f36e1b0 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.h
@@ -22,7 +22,7 @@
 #ifndef __gc_hal_kernel_allocator_h_
 #define __gc_hal_kernel_allocator_h_
 
-#include <linux/list.h>
+#include "gc_hal_kernel_linux.h"
 
 typedef struct _gcsALLOCATOR * gckALLOCATOR;
 
@@ -309,11 +309,26 @@ typedef struct _gcsALLOCATOR
     /* Pointer to gckOS Object. */
     gckOS                     os;
 
+    /* Name. */
+    gctSTRING                 name;
+
     /* Operations. */
     gcsALLOCATOR_OPERATIONS*  ops;
 
+    /* Capability of this allocator. */
+    gctUINT32                 capability;
+
     struct list_head          head;
 
+    /* Debugfs entry of this allocator. */
+    gcsDEBUGFS_DIR            debugfsDir;
+
+    /* Init allocator debugfs. */
+    void                      (*debugfsInit)(gckALLOCATOR, gckDEBUGFS_DIR);
+
+    /* Cleanup allocator debugfs. */
+    void                      (*debugfsCleanup)(gckALLOCATOR);
+
     /* Private data used by customer allocator. */
     void *                    privateData;
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator_array.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator_array.h
deleted file mode 100644
index 0cd5579..0000000
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator_array.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/****************************************************************************
-*
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
-*
-*    This program is free software; you can redistribute it and/or modify
-*    it under the terms of the GNU General Public License as published by
-*    the Free Software Foundation; either version 2 of the license, or
-*    (at your option) any later version.
-*
-*    This program is distributed in the hope that it will be useful,
-*    but WITHOUT ANY WARRANTY; without even the implied warranty of
-*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public License for more details.
-*
-*    You should have received a copy of the GNU General Public License
-*    along with this program; if not write to the Free Software
-*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*
-*****************************************************************************/
-
-
-extern gceSTATUS
-_DefaultAlloctorInit(
-    IN gckOS Os,
-    OUT gckALLOCATOR * Allocator
-    );
-
-extern gceSTATUS
-_CMAFSLAlloctorInit(
-    IN gckOS Os,
-    OUT gckALLOCATOR * Allocator
-    );
-
-gcsALLOCATOR_DESC allocatorArray[] =
-{
-    /* Default allocator. */
-    gcmkDEFINE_ALLOCATOR_DESC("default", _DefaultAlloctorInit),
-#if LINUX_CMA_FSL
-    gcmkDEFINE_ALLOCATOR_DESC("cmafsl", _CMAFSLAlloctorInit),
-#endif
-};
-
-
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c
index c0d6171..d496593 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c
@@ -61,19 +61,19 @@
         2.a)If the debugfs is not mounted, you must do "mount -t debugfs none /sys/kernel/debug"
 
    3) To read what is being printed in the debugfs file system:
-        Ex : cat /sys/kernel/debug/gpu/galcore_trace
+        Ex : cat /sys/kernel/debug/gc/galcore_trace
 
    4)To write into the debug file system from user side :
-        Ex: echo "hello" > cat /sys/kernel/debug/gpu/galcore_trace
+        Ex: echo "hello" > cat /sys/kernel/debug/gc/galcore_trace
 
    5)To write into debugfs from kernel side, Use the function called gckDEBUGFS_Print
 
    How to Get Video Memory Usage:
    1) Select a process whose video memory usage can be dump, no need to reset it until <pid> is needed to be change.
-        echo <pid>  > /sys/kernel/debug/gpu/vidmem
+        echo <pid>  > /sys/kernel/debug/gc/vidmem
 
    2) Get video memory usage.
-        cat /sys/kernel/debug/gpu/vidmem
+        cat /sys/kernel/debug/gc/vidmem
 
    USECASE Kernel Dump:
 
@@ -151,11 +151,120 @@ typedef struct _gcsDEBUGFS_
     int isInited ;
 } gcsDEBUGFS_ ;
 
-
 /*debug file system*/
 static gcsDEBUGFS_ gc_dbgfs ;
 
+static int gc_debugfs_open(struct inode *inode, struct file *file)
+{
+    gcsINFO_NODE *node = inode->i_private;
+
+    return single_open(file, node->info->show, node);
+}
+
+static const struct file_operations gc_debugfs_operations = {
+    .owner = THIS_MODULE,
+    .open = gc_debugfs_open,
+    .read = seq_read,
+    .llseek = seq_lseek,
+    .release = single_release,
+};
+
+gceSTATUS
+gckDEBUGFS_DIR_Init(
+    IN gckDEBUGFS_DIR Dir,
+    IN struct dentry *root,
+    IN gctCONST_STRING Name
+    )
+{
+    Dir->root = debugfs_create_dir(Name, root);
+
+    if (!Dir->root)
+    {
+        return gcvSTATUS_NOT_SUPPORTED;
+    }
 
+    INIT_LIST_HEAD(&Dir->nodeList);
+
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckDEBUGFS_DIR_CreateFiles(
+    IN gckDEBUGFS_DIR Dir,
+    IN gcsINFO * List,
+    IN int count,
+    IN gctPOINTER Data
+    )
+{
+    int i;
+    gcsINFO_NODE * node;
+    gceSTATUS status;
+
+    for (i = 0; i < count; i++)
+    {
+        /* Create a node. */
+        node = (gcsINFO_NODE *)kzalloc(sizeof(gcsINFO_NODE), GFP_KERNEL);
+
+        node->info   = &List[i];
+        node->device = Data;
+
+        /* Bind to a file. TODO: clean up when fail. */
+        node->entry = debugfs_create_file(
+            List[i].name, S_IRUGO|S_IWUSR, Dir->root, node, &gc_debugfs_operations);
+
+        if (!node->entry)
+        {
+            gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+        }
+
+        list_add(&(node->head), &(Dir->nodeList));
+    }
+
+    return gcvSTATUS_OK;
+
+OnError:
+    gcmkVERIFY_OK(gckDEBUGFS_DIR_RemoveFiles(Dir, List, count));
+    return status;
+}
+
+gceSTATUS
+gckDEBUGFS_DIR_RemoveFiles(
+    IN gckDEBUGFS_DIR Dir,
+    IN gcsINFO * List,
+    IN int count
+    )
+{
+    int i;
+    gcsINFO_NODE * node;
+    gcsINFO_NODE * temp;
+
+    for (i = 0; i < count; i++)
+    {
+        list_for_each_entry_safe(node, temp, &Dir->nodeList, head)
+        {
+            if (node->info == &List[i])
+            {
+                debugfs_remove(node->entry);
+                list_del(&node->head);
+                kfree(node);
+            }
+        }
+    }
+
+    return gcvSTATUS_OK;
+}
+
+void
+gckDEBUGFS_DIR_Deinit(
+    IN gckDEBUGFS_DIR Dir
+    )
+{
+    if (Dir->root != NULL)
+    {
+        debugfs_remove(Dir->root);
+        Dir->root = NULL;
+    }
+}
 
 /*******************************************************************************
  **
@@ -771,7 +880,7 @@ gctINT
 gckDEBUGFS_CreateNode (
     IN gctPOINTER Device,
     IN gctINT SizeInKB ,
-    IN gctCONST_STRING ParentName ,
+    IN struct dentry * Root ,
     IN gctCONST_STRING NodeName ,
     OUT gcsDEBUGFS_Node **Node
     )
@@ -800,7 +909,7 @@ gckDEBUGFS_CreateNode (
     /*End the sync primitives*/
 
     /*creating the debug file system*/
-    node->parent = debugfs_create_dir(ParentName, NULL);
+    node->parent = Root;
 
     if (SizeInKB)
     {
@@ -821,6 +930,7 @@ gckDEBUGFS_CreateNode (
     node->next = gc_dbgfs.linkedlist ;
     gc_dbgfs.linkedlist = node ;
 
+
     /* pass the struct back */
     *Node = node ;
     return 0 ;
@@ -870,10 +980,6 @@ gckDEBUGFS_FreeNode (
     {
         debugfs_remove ( Node->filen ) ;
     }
-    if ( Node->parent )
-    {
-        debugfs_remove ( Node->parent ) ;
-    }
 
     /* now delete the node from the linked list */
     ptr = & ( gc_dbgfs.linkedlist ) ;
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h
index dbe4e84..9d17e87 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h
@@ -29,6 +29,56 @@
 
  typedef struct _gcsDEBUGFS_Node gcsDEBUGFS_Node;
 
+typedef struct _gcsDEBUGFS_DIR *gckDEBUGFS_DIR;
+typedef struct _gcsDEBUGFS_DIR
+{
+    struct dentry *     root;
+    struct list_head    nodeList;
+}
+gcsDEBUGFS_DIR;
+
+typedef struct _gcsINFO
+{
+    const char *        name;
+    int                 (*show)(struct seq_file*, void*);
+}
+gcsINFO;
+
+typedef struct _gcsINFO_NODE
+{
+    gcsINFO *          info;
+    gctPOINTER         device;
+    struct dentry *    entry;
+    struct list_head   head;
+}
+gcsINFO_NODE;
+
+gceSTATUS
+gckDEBUGFS_DIR_Init(
+    IN gckDEBUGFS_DIR Dir,
+    IN struct dentry *root,
+    IN gctCONST_STRING Name
+    );
+
+gceSTATUS
+gckDEBUGFS_DIR_CreateFiles(
+    IN gckDEBUGFS_DIR Dir,
+    IN gcsINFO * List,
+    IN int count,
+    IN gctPOINTER Data
+    );
+
+gceSTATUS
+gckDEBUGFS_DIR_RemoveFiles(
+    IN gckDEBUGFS_DIR Dir,
+    IN gcsINFO * List,
+    IN int count
+    );
+
+void
+gckDEBUGFS_DIR_Deinit(
+    IN gckDEBUGFS_DIR Dir
+    );
 
 /*******************************************************************************
  **
@@ -53,7 +103,7 @@ gctINT
 gckDEBUGFS_CreateNode(
     IN gctPOINTER Device,
     IN gctINT SizeInKB,
-    IN gctCONST_STRING ParentName,
+    IN struct dentry * Root,
     IN gctCONST_STRING NodeName,
     OUT gcsDEBUGFS_Node **Node
     );
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
index b063c75..719ba33 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
@@ -35,7 +35,267 @@
     static struct dove_gpio_irq_handler gc500_handle;
 #endif
 
-#define gcmIS_CORE_PRESENT(Device, Core) (Device->irqLines[Core] > 0)
+gckKERNEL
+_GetValidKernel(
+    gckGALDEVICE Device
+    )
+{
+    if (Device->kernels[gcvCORE_MAJOR])
+    {
+        return Device->kernels[gcvCORE_MAJOR];
+    }
+    else
+    if (Device->kernels[gcvCORE_2D])
+    {
+        return Device->kernels[gcvCORE_2D];
+    }
+    else
+    if (Device->kernels[gcvCORE_VG])
+    {
+        return Device->kernels[gcvCORE_VG];
+    }
+    else
+    {
+        return gcvNULL;
+    }
+}
+
+/******************************************************************************\
+******************************** Debugfs Support *******************************
+\******************************************************************************/
+
+/******************************************************************************\
+***************************** DEBUG SHOW FUNCTIONS *****************************
+\******************************************************************************/
+
+int gc_info_show(struct seq_file* m, void* data)
+{
+    gcsINFO_NODE *node = m->private;
+    gckGALDEVICE device = node->device;
+    int i = 0;
+    gceCHIPMODEL chipModel;
+    gctUINT32 chipRevision;
+
+    for (i = 0; i < gcdMAX_GPU_COUNT; i++)
+    {
+        if (device->irqLines[i] != -1)
+        {
+#if gcdENABLE_VG
+            if (i == gcvCORE_VG)
+            {
+                chipModel = device->kernels[i]->vg->hardware->chipModel;
+                chipRevision = device->kernels[i]->vg->hardware->chipRevision;
+            }
+            else
+#endif
+            {
+                chipModel = device->kernels[i]->hardware->identity.chipModel;
+                chipRevision = device->kernels[i]->hardware->identity.chipRevision;
+            }
+
+            seq_printf(m, "gpu      : %d\n", i);
+            seq_printf(m, "model    : %4x\n", chipModel);
+            seq_printf(m, "revision : %4x\n", chipRevision);
+            seq_printf(m, "\n");
+        }
+    }
+
+    return 0;
+}
+
+int gc_clients_show(struct seq_file* m, void* data)
+{
+    gcsINFO_NODE *node = m->private;
+    gckGALDEVICE device = node->device;
+
+    gckKERNEL kernel = _GetValidKernel(device);
+
+    gcsDATABASE_PTR database;
+    gctINT i, pid;
+    gctUINT8 name[24];
+
+    seq_printf(m, "%-8s%s\n", "PID", "NAME");
+    seq_printf(m, "------------------------\n");
+
+    /* Acquire the database mutex. */
+    gcmkVERIFY_OK(
+        gckOS_AcquireMutex(kernel->os, kernel->db->dbMutex, gcvINFINITE));
+
+    /* Walk the databases. */
+    for (i = 0; i < gcmCOUNTOF(kernel->db->db); ++i)
+    {
+        for (database = kernel->db->db[i];
+             database != gcvNULL;
+             database = database->next)
+        {
+            pid = database->processID;
+
+            gcmkVERIFY_OK(gckOS_ZeroMemory(name, gcmSIZEOF(name)));
+
+            gcmkVERIFY_OK(gckOS_GetProcessNameByPid(pid, gcmSIZEOF(name), name));
+
+            seq_printf(m, "%-8d%s\n", pid, name);
+        }
+    }
+
+    /* Release the database mutex. */
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(kernel->os, kernel->db->dbMutex));
+
+    /* Success. */
+    return 0;
+}
+
+static void
+_CounterAdd(
+    gcsDATABASE_COUNTERS * Dest,
+    gcsDATABASE_COUNTERS * Src
+    )
+{
+    Dest->bytes += Src->bytes;
+    Dest->maxBytes += Src->maxBytes;
+    Dest->totalBytes += Src->totalBytes;
+}
+
+static void
+_CounterPrint(
+    gcsDATABASE_COUNTERS * Counter,
+    gctCONST_STRING Name,
+    struct seq_file* m
+    )
+{
+    seq_printf(m, "    %s:\n", Name);
+    seq_printf(m, "        Used  : %10llu B\n", Counter->bytes);
+}
+
+int gc_meminfo_show(struct seq_file* m, void* data)
+{
+    gcsINFO_NODE *node = m->private;
+    gckGALDEVICE device = node->device;
+    gckKERNEL kernel = _GetValidKernel(device);
+    gckVIDMEM memory;
+    gceSTATUS status;
+    gcsDATABASE_PTR database;
+    gctUINT32 i;
+
+    gctUINT32 free = 0, used = 0, total = 0;
+
+    gcsDATABASE_COUNTERS contiguousCounter = {0, 0, 0};
+    gcsDATABASE_COUNTERS virtualCounter = {0, 0, 0};
+    gcsDATABASE_COUNTERS nonPagedCounter = {0, 0, 0};
+
+    status = gckKERNEL_GetVideoMemoryPool(kernel, gcvPOOL_SYSTEM, &memory);
+
+    if (gcmIS_SUCCESS(status))
+    {
+        gcmkVERIFY_OK(
+            gckOS_AcquireMutex(kernel->os, kernel->vidmemMutex, gcvINFINITE));
+
+        free  = memory->freeBytes;
+        used  = memory->bytes - memory->freeBytes;
+        total = memory->bytes;
+
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(kernel->os, kernel->vidmemMutex));
+    }
+
+    seq_printf(m, "VIDEO MEMORY:\n");
+    seq_printf(m, "    gcvPOOL_SYSTEM:\n");
+    seq_printf(m, "        Free  : %10u B\n", free);
+    seq_printf(m, "        Used  : %10u B\n", used);
+    seq_printf(m, "        Total : %10u B\n", total);
+
+    /* Acquire the database mutex. */
+    gcmkVERIFY_OK(
+        gckOS_AcquireMutex(kernel->os, kernel->db->dbMutex, gcvINFINITE));
+
+    /* Walk the databases. */
+    for (i = 0; i < gcmCOUNTOF(kernel->db->db); ++i)
+    {
+        for (database = kernel->db->db[i];
+             database != gcvNULL;
+             database = database->next)
+        {
+            gcsDATABASE_COUNTERS * counter = &database->vidMemPool[gcvPOOL_CONTIGUOUS];
+            _CounterAdd(&contiguousCounter, counter);
+
+            counter = &database->vidMemPool[gcvPOOL_VIRTUAL];
+            _CounterAdd(&virtualCounter, counter);
+
+
+            counter = &database->nonPaged;
+            _CounterAdd(&nonPagedCounter, counter);
+        }
+    }
+
+    /* Release the database mutex. */
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(kernel->os, kernel->db->dbMutex));
+
+    _CounterPrint(&contiguousCounter, "gcvPOOL_CONTIGUOUS", m);
+    _CounterPrint(&virtualCounter, "gcvPOOL_VIRTUAL", m);
+
+    seq_printf(m, "\n");
+
+    seq_printf(m, "NON PAGED MEMORY:\n");
+    seq_printf(m, "    Used  : %10llu B\n", nonPagedCounter.bytes);
+
+    return 0;
+}
+
+int gc_idle_show(struct seq_file* m, void* data)
+{
+    gcsINFO_NODE *node = m->private;
+    gckGALDEVICE device = node->device;
+    gckKERNEL kernel = _GetValidKernel(device);
+    gcuDATABASE_INFO info;
+
+    gckKERNEL_QueryProcessDB(kernel, 0, gcvFALSE, gcvDB_IDLE, &info);
+
+    seq_printf(m, "%llu ns\n", info.time);
+
+    return 0;
+}
+
+static gcsINFO InfoList[] =
+{
+    {"info", gc_info_show},
+    {"clients", gc_clients_show},
+    {"meminfo", gc_meminfo_show},
+    {"idle", gc_idle_show},
+};
+
+static gceSTATUS
+_DebugfsInit(
+    IN gckGALDEVICE Device
+    )
+{
+    gceSTATUS status;
+
+    gckDEBUGFS_DIR dir = &Device->debugfsDir;
+
+    gcmkONERROR(gckDEBUGFS_DIR_Init(dir, gcvNULL, "gc"));
+
+    gcmkONERROR(gckDEBUGFS_DIR_CreateFiles(dir, InfoList, gcmCOUNTOF(InfoList), Device));
+
+    return gcvSTATUS_OK;
+
+OnError:
+    return status;
+}
+
+static void
+_DebugfsCleanup(
+    IN gckGALDEVICE Device
+    )
+{
+    gckDEBUGFS_DIR dir = &Device->debugfsDir;
+
+    if (Device->debugfsDir.root)
+    {
+        gcmkVERIFY_OK(gckDEBUGFS_DIR_RemoveFiles(dir, InfoList, gcmCOUNTOF(InfoList)));
+
+        gckDEBUGFS_DIR_Deinit(dir);
+    }
+}
+
 
 /******************************************************************************\
 *************************** Memory Allocation Wrappers *************************
@@ -51,7 +311,6 @@ _AllocateMemory(
     )
 {
     gceSTATUS status;
-    gckKERNEL kernel;
 
     gcmkHEADER_ARG("Device=0x%x Bytes=%lu", Device, Bytes);
 
@@ -64,13 +323,7 @@ _AllocateMemory(
         Device->os, gcvFALSE, &Bytes, Physical, Logical
         ));
 
-    kernel = Device->kernels[gcvCORE_MAJOR] != gcvNULL ?
-                Device->kernels[gcvCORE_MAJOR] : Device->kernels[gcvCORE_2D];
-
-    if (kernel->hardware->mmuVersion == 0)
-        *PhysAddr = ((PLINUX_MDL)*Physical)->dmaHandle - Device->baseAddress;
-    else
-        *PhysAddr = ((PLINUX_MDL)*Physical)->dmaHandle;
+    *PhysAddr = ((PLINUX_MDL)*Physical)->dmaHandle;
 
     /* Success. */
     gcmkFOOTER_ARG(
@@ -243,8 +496,6 @@ static irqreturn_t isrRoutine3D0(int irq, void *ctxt)
 
     if (gcmIS_SUCCESS(status))
     {
-        device->dataReadys[gcvCORE_MAJOR] = gcvTRUE;
-
         up(&device->semas[gcvCORE_MAJOR]);
 
         return IRQ_HANDLED;
@@ -267,7 +518,6 @@ static int threadRoutine3D0(void *ctxt)
 
         down = down_interruptible(&device->semas[gcvCORE_MAJOR]);
         if (down); /*To make gcc 4.6 happye*/
-        device->dataReadys[gcvCORE_MAJOR] = gcvFALSE;
 
         if (device->killThread == gcvTRUE)
         {
@@ -298,8 +548,6 @@ static irqreturn_t isrRoutine3D1(int irq, void *ctxt)
 
     if (gcmIS_SUCCESS(status))
     {
-        device->dataReadys[gcvCORE_OCL] = gcvTRUE;
-
         up(&device->semas[gcvCORE_OCL]);
 
         return IRQ_HANDLED;
@@ -322,7 +570,6 @@ static int threadRoutine3D1(void *ctxt)
 
         down = down_interruptible(&device->semas[gcvCORE_OCL]);
         if (down); /*To make gcc 4.6 happye*/
-        device->dataReadys[gcvCORE_OCL] = gcvFALSE;
 
         if (device->killThread == gcvTRUE)
         {
@@ -353,8 +600,6 @@ static irqreturn_t isrRoutine(int irq, void *ctxt)
 
     if (gcmIS_SUCCESS(status))
     {
-        device->dataReadys[gcvCORE_MAJOR] = gcvTRUE;
-
         up(&device->semas[gcvCORE_MAJOR]);
 
         return IRQ_HANDLED;
@@ -377,7 +622,6 @@ static int threadRoutine(void *ctxt)
 
         down = down_interruptible(&device->semas[gcvCORE_MAJOR]);
         if (down); /*To make gcc 4.6 happye*/
-        device->dataReadys[gcvCORE_MAJOR] = gcvFALSE;
 
         if (device->killThread == gcvTRUE)
         {
@@ -413,8 +657,6 @@ static irqreturn_t isrRoutine2D(int irq, void *ctxt)
                               gcvTRUE);
     if (gcmIS_SUCCESS(status))
     {
-        device->dataReadys[gcvCORE_2D] = gcvTRUE;
-
         up(&device->semas[gcvCORE_2D]);
 
         return IRQ_HANDLED;
@@ -437,7 +679,6 @@ static int threadRoutine2D(void *ctxt)
 
         down = down_interruptible(&device->semas[gcvCORE_2D]);
         if (down); /*To make gcc 4.6 happye*/
-        device->dataReadys[gcvCORE_2D] = gcvFALSE;
 
         if (device->killThread == gcvTRUE)
         {
@@ -492,7 +733,6 @@ static int threadRoutineVG(void *ctxt)
 
         down = down_interruptible(&device->semas[gcvCORE_VG]);
         if (down); /*To make gcc 4.6 happye*/
-        device->dataReadys[gcvCORE_VG] = gcvFALSE;
 
         if (device->killThread == gcvTRUE)
         {
@@ -625,8 +865,10 @@ gckGALDEVICE_Construct(
 
     device->platform = Args->platform;
 
+    gcmkONERROR(_DebugfsInit(device));
+
     if (gckDEBUGFS_CreateNode(
-            device, LogFileSize, PARENT_FILE,DEBUG_FILE, &(device->dbgNode)))
+            device, LogFileSize, device->debugfsDir.root ,DEBUG_FILE, &(device->dbgNode)))
     {
         gcmkTRACE_ZONE(
             gcvLEVEL_ERROR, gcvZONE_DRIVER,
@@ -1277,6 +1519,7 @@ gckGALDEVICE_Construct(
 
                 device->requestedContiguousBase  = ContiguousBase;
                 device->requestedContiguousSize  = ContiguousSize;
+                device->contiguousRequested      = Args->contiguousRequested;
 
                 device->contiguousPhysical = gcvNULL;
                 device->contiguousPhysicalName = 0;
@@ -1326,7 +1569,6 @@ gckGALDEVICE_Destroy(
 #if gcdMULTI_GPU
     gctINT j;
 #endif
-    gceSTATUS status = gcvSTATUS_OK;
     gckKERNEL kernel = gcvNULL;
 
     gcmkHEADER_ARG("Device=0x%x", Device);
@@ -1418,7 +1660,7 @@ gckGALDEVICE_Destroy(
         {
             if (Device->contiguousMapped == gcvFALSE)
             {
-                gcmkONERROR(_FreeMemory(
+                gcmkVERIFY_OK(_FreeMemory(
                     Device,
                     Device->contiguousBase,
                     Device->contiguousPhysical
@@ -1429,7 +1671,9 @@ gckGALDEVICE_Destroy(
             Device->contiguousPhysical = gcvNULL;
         }
 
-        if ((Device->contiguousRequested == gcvFALSE) &&  (Device->requestedContiguousBase != 0))
+        if (Device->requestedContiguousBase != 0
+         && Device->contiguousRequested == gcvFALSE
+        )
         {
             release_mem_region(Device->requestedContiguousBase, Device->requestedContiguousSize);
             Device->requestedContiguousBase = 0;
@@ -1443,14 +1687,15 @@ gckGALDEVICE_Destroy(
             Device->contiguousVidMem = gcvNULL;
         }
 
-        if(gckDEBUGFS_IsEnabled())
+        if (Device->dbgNode)
         {
             gckDEBUGFS_FreeNode(Device->dbgNode);
-         if(Device->dbgNode != gcvNULL)
-             {
-               kfree(Device->dbgNode);
-               Device->dbgNode = gcvNULL;
-             }
+
+            if(Device->dbgNode != gcvNULL)
+            {
+                kfree(Device->dbgNode);
+                Device->dbgNode = gcvNULL;
+            }
         }
 
         for (i = 0; i < gcdMAX_GPU_COUNT; i++)
@@ -1503,16 +1748,14 @@ gckGALDEVICE_Destroy(
             Device->os = gcvNULL;
         }
 
+        _DebugfsCleanup(Device);
+
         /* Free the device. */
         kfree(Device);
     }
 
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
-
-OnError:
-    gcmkFOOTER();
-    return status;
 }
 
 /*******************************************************************************
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
index 2a7bf0d..9567225 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
@@ -22,6 +22,8 @@
 #ifndef __gc_hal_kernel_device_h_
 #define __gc_hal_kernel_device_h_
 
+#include "gc_hal_kernel_debugfs.h"
+
 /******************************************************************************\
 ******************************* gckGALDEVICE Structure *******************************
 \******************************************************************************/
@@ -52,6 +54,7 @@ typedef struct _gckGALDEVICE
     gctSIZE_T           contiguousSize;
     gctBOOL             contiguousMapped;
     gctPOINTER          contiguousMappedUser;
+    gctBOOL             contiguousRequested;
     gctSIZE_T           systemMemorySize;
     gctUINT32           systemMemoryBaseAddress;
 #if gcdMULTI_GPU
@@ -69,7 +72,6 @@ typedef struct _gckGALDEVICE
     gctSIZE_T           requestedRegisterMemSizes[gcdMAX_GPU_COUNT];
     gctUINT32           requestedContiguousBase;
     gctSIZE_T           requestedContiguousSize;
-    gctUINT32           contiguousRequested;
 
     /* IRQ management. */
 #if gcdMULTI_GPU
@@ -79,7 +81,6 @@ typedef struct _gckGALDEVICE
 #endif
     gctINT              irqLines[gcdMAX_GPU_COUNT];
     gctBOOL             isrInitializeds[gcdMAX_GPU_COUNT];
-    gctBOOL             dataReadys[gcdMAX_GPU_COUNT];
 
     /* Thread management. */
 #if gcdMULTI_GPU
@@ -104,17 +105,7 @@ typedef struct _gckGALDEVICE
     /* Device Debug File System Entry in kernel. */
     struct _gcsDEBUGFS_Node * dbgNode;
 
-#if DYNAMIC_MEMORY_RECORD
-    gctSIZE_T cachedsize;
-    gctSIZE_T nonpagedmemorysize;
-#if LINUX_CMA_FSL
-    gctSIZE_T cmasize;
-#endif
-    gctSIZE_T contiguouslowmemsize;
-    gctSIZE_T contiguoushighmemsize;
-    gctSIZE_T noncontiguouslowmemsize;
-    gctSIZE_T noncontiguoushighmemsize;
-#endif
+    gcsDEBUGFS_DIR      debugfsDir;
 }
 * gckGALDEVICE;
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
index 1dc29a3..576ca30 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
@@ -72,11 +72,13 @@
 
 #define countof(a)                    (sizeof(a) / sizeof(a[0]))
 
+#ifndef DEVICE_NAME
 #ifdef CONFIG_DOVE_GPU
 #   define DEVICE_NAME              "dove_gpu"
 #else
 #   define DEVICE_NAME              "galcore"
 #endif
+#endif
 
 #define GetPageCount(size, offset)     ((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
 
@@ -105,29 +107,9 @@
 #define gcdNOWARN 0
 #endif
 
-#define gcdUSE_NON_PAGED_MEMORY_CACHE 0
-
 /******************************************************************************\
 ********************************** Structures **********************************
 \******************************************************************************/
-#if gcdUSE_NON_PAGED_MEMORY_CACHE
-typedef struct _gcsNonPagedMemoryCache
-{
-#ifndef NO_DMA_COHERENT
-    gctINT                           size;
-    gctSTRING                        addr;
-    dma_addr_t                       dmaHandle;
-#else
-    long                             order;
-    struct page *                    page;
-#endif
-
-    struct _gcsNonPagedMemoryCache * prev;
-    struct _gcsNonPagedMemoryCache * next;
-}
-gcsNonPagedMemoryCache;
-#endif /* gcdUSE_NON_PAGED_MEMORY_CACHE */
-
 typedef struct _gcsUSER_MAPPING * gcsUSER_MAPPING_PTR;
 typedef struct _gcsUSER_MAPPING
 {
@@ -186,7 +168,7 @@ struct _gckOS
     /* signal id database. */
     gcsINTEGER_DB               signalDB;
 
-#if gcdANDROID_NATIVE_FENCE_SYNC
+#if gcdANDROID_NATIVE_FENCE_SYNC && defined(ANDROID)
     /* Lock. */
     gctPOINTER                  syncPointMutex;
 
@@ -197,12 +179,6 @@ struct _gckOS
     gcsUSER_MAPPING_PTR         userMap;
     gctPOINTER                  debugLock;
 
-#if gcdUSE_NON_PAGED_MEMORY_CACHE
-    gctUINT                      cacheSize;
-    gcsNonPagedMemoryCache *     cacheHead;
-    gcsNonPagedMemoryCache *     cacheTail;
-#endif
-
     /* workqueue for os timer. */
     struct workqueue_struct *   workqueue;
 
@@ -214,6 +190,8 @@ struct _gckOS
 
     struct list_head            allocatorList;
 
+    gcsDEBUGFS_DIR              allocatorDebugfsDir;
+
     /* Lock for register access check. */
     struct mutex                registerAccessLocks[gcdMAX_GPU_COUNT];
 
@@ -248,7 +226,7 @@ typedef struct _gcsSIGNAL
 }
 gcsSIGNAL;
 
-#if gcdANDROID_NATIVE_FENCE_SYNC
+#if gcdANDROID_NATIVE_FENCE_SYNC && defined(ANDROID)
 typedef struct _gcsSYNC_POINT * gcsSYNC_POINT_PTR;
 typedef struct _gcsSYNC_POINT
 {
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
index 2fbf02b..a576dea 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
@@ -34,7 +34,7 @@
 #endif
 #include <linux/delay.h>
 
-#if gcdANDROID_NATIVE_FENCE_SYNC
+#if gcdANDROID_NATIVE_FENCE_SYNC && defined(ANDROID)
 #include <linux/file.h>
 #include "gc_hal_kernel_sync.h"
 #endif
@@ -225,224 +225,6 @@ FindMdlMap(
     return gcvNULL;
 }
 
-#if gcdUSE_NON_PAGED_MEMORY_CACHE
-
-static gctBOOL
-_AddNonPagedMemoryCache(
-    gckOS Os,
-#ifndef NO_DMA_COHERENT
-    gctINT Size,
-    gctSTRING Addr,
-    dma_addr_t DmaHandle
-#else
-    long Order,
-    struct page * Page
-#endif
-    )
-{
-    gcsNonPagedMemoryCache *cache;
-
-    if (Os->cacheSize >= gcdUSE_NON_PAGED_MEMORY_CACHE)
-    {
-        return gcvFALSE;
-    }
-
-    /* Allocate the cache record */
-    cache = (gcsNonPagedMemoryCache *)kmalloc(sizeof(gcsNonPagedMemoryCache), GFP_ATOMIC);
-
-    if (cache == gcvNULL) return gcvFALSE;
-
-#ifndef NO_DMA_COHERENT
-    cache->size  = Size;
-    cache->addr  = Addr;
-    cache->dmaHandle = DmaHandle;
-#else
-    cache->order = Order;
-    cache->page  = Page;
-#endif
-
-    /* Add to list */
-    if (Os->cacheHead == gcvNULL)
-    {
-        cache->prev   = gcvNULL;
-        cache->next   = gcvNULL;
-        Os->cacheHead =
-        Os->cacheTail = cache;
-    }
-    else
-    {
-        /* Add to the tail. */
-        cache->prev         = Os->cacheTail;
-        cache->next         = gcvNULL;
-        Os->cacheTail->next = cache;
-        Os->cacheTail       = cache;
-    }
-
-    Os->cacheSize++;
-
-#if DYNAMIC_MEMORY_RECORD
-    Os->device->cachedsize+=Size;
-#endif
-
-    return gcvTRUE;
-}
-
-#ifndef NO_DMA_COHERENT
-static gctSTRING
-_GetNonPagedMemoryCache(
-    gckOS Os,
-    gctINT Size,
-    dma_addr_t * DmaHandle
-    )
-#else
-static struct page *
-_GetNonPagedMemoryCache(
-    gckOS Os,
-    long Order
-    )
-#endif
-{
-    gcsNonPagedMemoryCache *cache;
-#ifndef NO_DMA_COHERENT
-    gctSTRING addr;
-#else
-    struct page * page;
-#endif
-
-    if (Os->cacheHead == gcvNULL) return gcvNULL;
-
-    /* Find the right cache */
-    cache = Os->cacheHead;
-
-    while (cache != gcvNULL)
-    {
-#ifndef NO_DMA_COHERENT
-        if (cache->size == Size) break;
-#else
-        if (cache->order == Order) break;
-#endif
-
-        cache = cache->next;
-    }
-
-    if (cache == gcvNULL) return gcvNULL;
-
-    /* Remove the cache from list */
-    if (cache == Os->cacheHead)
-    {
-        Os->cacheHead = cache->next;
-
-        if (Os->cacheHead == gcvNULL)
-        {
-            Os->cacheTail = gcvNULL;
-        }
-    }
-    else
-    {
-        cache->prev->next = cache->next;
-
-        if (cache == Os->cacheTail)
-        {
-            Os->cacheTail = cache->prev;
-        }
-        else
-        {
-            cache->next->prev = cache->prev;
-        }
-    }
-
-    /* Destroy cache */
-#ifndef NO_DMA_COHERENT
-    addr       = cache->addr;
-    *DmaHandle = cache->dmaHandle;
-#else
-    page       = cache->page;
-#endif
-
-    kfree(cache);
-
-    Os->cacheSize--;
-
-#if DYNAMIC_MEMORY_RECORD
-    Os->device->cachedsize-=Size;
-#endif
-
-#ifndef NO_DMA_COHERENT
-    return addr;
-#else
-    return page;
-#endif
-}
-
-static void
-_FreeAllNonPagedMemoryCache(
-    gckOS Os
-    )
-{
-    gcsNonPagedMemoryCache *cache, *nextCache;
-
-    MEMORY_LOCK(Os);
-
-    cache = Os->cacheHead;
-
-    while (cache != gcvNULL)
-    {
-        if (cache != Os->cacheTail)
-        {
-            nextCache = cache->next;
-        }
-        else
-        {
-            nextCache = gcvNULL;
-        }
-
-        /* Remove the cache from list */
-        if (cache == Os->cacheHead)
-        {
-            Os->cacheHead = cache->next;
-
-            if (Os->cacheHead == gcvNULL)
-            {
-                Os->cacheTail = gcvNULL;
-            }
-        }
-        else
-        {
-            cache->prev->next = cache->next;
-
-            if (cache == Os->cacheTail)
-            {
-                Os->cacheTail = cache->prev;
-            }
-            else
-            {
-                cache->next->prev = cache->prev;
-            }
-        }
-
-#ifndef NO_DMA_COHERENT
-    dma_free_coherent(gcvNULL,
-                    cache->size,
-                    cache->addr,
-                    cache->dmaHandle);
-#else
-    free_pages((unsigned long)page_address(cache->page), cache->order);
-#endif
-
-        kfree(cache);
-
-        cache = nextCache;
-    }
-
-#if DYNAMIC_MEMORY_RECORD
-    Os->device->cachedsize = 0;
-#endif
-
-    MEMORY_UNLOCK(Os);
-}
-
-#endif /* gcdUSE_NON_PAGED_MEMORY_CACHE */
-
 /*******************************************************************************
 ** Integer Id Management.
 */
@@ -869,7 +651,7 @@ gckOS_Construct(
     /* Initialize signal id database. */
     idr_init(&os->signalDB.idr);
 
-#if gcdANDROID_NATIVE_FENCE_SYNC
+#if gcdANDROID_NATIVE_FENCE_SYNC && defined(ANDROID)
     /*
      * Initialize the sync point manager.
      */
@@ -884,12 +666,6 @@ gckOS_Construct(
     idr_init(&os->syncPointDB.idr);
 #endif
 
-#if gcdUSE_NON_PAGED_MEMORY_CACHE
-    os->cacheSize = 0;
-    os->cacheHead = gcvNULL;
-    os->cacheTail = gcvNULL;
-#endif
-
     /* Create a workqueue for os timer. */
     os->workqueue = create_singlethread_workqueue("galcore workqueue");
 
@@ -929,7 +705,7 @@ gckOS_Construct(
 
 OnError:
 
-#if gcdANDROID_NATIVE_FENCE_SYNC
+#if gcdANDROID_NATIVE_FENCE_SYNC && defined(ANDROID)
     if (os->syncPointMutex != gcvNULL)
     {
         gcmkVERIFY_OK(
@@ -1005,11 +781,7 @@ gckOS_Destroy(
         Os->paddingPage = gcvNULL;
     }
 
-#if gcdUSE_NON_PAGED_MEMORY_CACHE
-    _FreeAllNonPagedMemoryCache(Os);
-#endif
-
-#if gcdANDROID_NATIVE_FENCE_SYNC
+#if gcdANDROID_NATIVE_FENCE_SYNC && defined(ANDROID)
     /*
      * Destroy the sync point manager.
      */
@@ -1453,7 +1225,7 @@ gckOS_MapMemory(
         }
 
 #ifndef NO_DMA_COHERENT
-        if (dma_mmap_coherent(gcvNULL,
+        if (dma_mmap_writecombine(gcvNULL,
                     mdlMap->vma,
                     mdl->addr,
                     mdl->dmaHandle,
@@ -1688,242 +1460,6 @@ gckOS_UnmapUserLogical(
 
 }
 
-
-#if LINUX_CMA_FSL
-/*******************************************************************************
-**
-**  gckOS_gckOS_AllocateCMAMemoryFSL
-**
-**  Allocate a number of pages from non-paged memory.
-**
-**  INPUT:
-**
-**      gckOS Os
-**          Pointer to an gckOS object.
-**
-**      gctSIZE_T * Bytes
-**          Pointer to a variable that holds the number of bytes to allocate.
-**
-**  OUTPUT:
-**
-**      gctSIZE_T * Bytes
-**          Pointer to a variable that hold the number of bytes allocated.
-**
-**      gctPHYS_ADDR * Physical
-**          Pointer to a variable that will hold the physical address of the
-**          allocation.
-**
-*/
-gceSTATUS
-gckOS_AllocateCMAMemoryFSL(
-    IN gckOS Os,
-    IN OUT gctSIZE_T * Bytes,
-    OUT gctPHYS_ADDR * Physical
-    )
-{
-    gctSIZE_T bytes;
-    gctINT numPages;
-    PLINUX_MDL mdl = gcvNULL;
-    gctBOOL locked = gcvFALSE;
-    gceSTATUS status = gcvSTATUS_OUT_OF_MEMORY;
-    gckALLOCATOR allocator;
-    gctUINT32 flag = 0;
-
-    gcmkHEADER_ARG("Os=0x%X *Bytes=%lu",
-                   Os, gcmOPT_VALUE(Bytes));
-
-    /* Verify the arguments. */
-    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT(Bytes != gcvNULL);
-    gcmkVERIFY_ARGUMENT(*Bytes > 0);
-    gcmkVERIFY_ARGUMENT(Physical != gcvNULL);
-
-    /* Align number of bytes to page size. */
-    bytes = gcmALIGN(*Bytes, PAGE_SIZE);
-
-    /* Get total number of pages.. */
-    numPages = GetPageCount(bytes, 0);
-
-    /* Allocate mdl+vector structure */
-    mdl = _CreateMdl();
-    if (mdl == gcvNULL)
-    {
-        gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
-    }
-
-    /* Walk all default allocators. */
-    list_for_each_entry(allocator, &Os->allocatorList, head)
-    {
-        if(allocator->privateData)
-        {
-            status = allocator->ops->Alloc(allocator, mdl, numPages, flag);
-
-            if (gcmIS_SUCCESS(status))
-            {
-                mdl->allocator = allocator;
-                break;
-            }
-        }
-    }
-
-    /* Check status. */
-    gcmkONERROR(status);
-
-    mdl->pagedMem = 0;
-    mdl->numPages = numPages;
-    mdl->contiguous = gcvTRUE;
-    mdl->cacheable=gcvFALSE;
-
-    if ((Os->device->baseAddress & 0x80000000) != (mdl->dmaHandle & 0x80000000))
-    {
-        gckOS_Print("Incorrect memory address allocated from CMA.0x%X!!\n",mdl->dmaHandle);
-        allocator->ops->Free(allocator, mdl);
-        gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
-    }
-
-
-
-    MEMORY_LOCK(Os);
-    locked = gcvTRUE;
-
-    /* Return allocated memory. */
-    *Bytes = bytes;
-    *Physical = (gctPHYS_ADDR) mdl;
-
-#if DYNAMIC_MEMORY_RECORD
-    Os->device->cmasize+=bytes;
-#endif
-
-    /*
-     * Add this to a global list.
-     * Will be used by get physical address
-     * and mapuser pointer functions.
-     */
-
-    if (!Os->mdlHead)
-    {
-        /* Initialize the queue. */
-        Os->mdlHead = Os->mdlTail = mdl;
-    }
-    else
-    {
-        /* Add to the tail. */
-        mdl->prev = Os->mdlTail;
-        Os->mdlTail->next = mdl;
-        Os->mdlTail = mdl;
-    }
-
-    MEMORY_UNLOCK(Os);
-
-    /* Success. */
-    gcmkFOOTER_ARG("*Bytes=%lu *Physical=0x%X",
-                   *Bytes, *Physical);
-    return gcvSTATUS_OK;
-
-OnError:
-    if (mdl != gcvNULL)
-    {
-        /* Free LINUX_MDL. */
-        gcmkVERIFY_OK(_DestroyMdl(mdl));
-    }
-
-    if (locked)
-    {
-        /* Unlock memory. */
-        MEMORY_UNLOCK(Os);
-    }
-
-    /* Return the status. */
-    gcmkFOOTER();
-    return status;
-}
-
-/*******************************************************************************
-**
-**  gckOS_FreeCMAMemoryFSL
-**
-**  Free previously allocated and mapped pages from non-paged memory.
-**
-**  INPUT:
-**
-**      gckOS Os
-**          Pointer to an gckOS object.
-**
-**      gctSIZE_T Bytes
-**          Number of bytes allocated.
-**
-**      gctPHYS_ADDR Physical
-**          Physical address of the allocated memory.
-**
-**  OUTPUT:
-**
-**      Nothing.
-*/
-gceSTATUS gckOS_FreeCMAMemoryFSL(
-    IN gckOS Os,
-    IN gctSIZE_T Bytes,
-    IN gctPHYS_ADDR Physical
-    )
-{
-    PLINUX_MDL mdl;
-    gckALLOCATOR allocator;
-
-    gcmkHEADER_ARG("Os=0x%X Bytes=%lu Physical=0x%X",
-                   Os, Bytes, Physical);
-
-    /* Verify the arguments. */
-    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT(Bytes > 0);
-    gcmkVERIFY_ARGUMENT(Physical != 0);
-
-    /* Convert physical address into a pointer to a MDL. */
-    mdl = (PLINUX_MDL) Physical;
-    allocator = (gckALLOCATOR)mdl->allocator;
-    
-    MEMORY_LOCK(Os);
-
-#if DYNAMIC_MEMORY_RECORD
-    Os->device->cmasize-=(mdl->numPages * PAGE_SIZE);
-#endif
-
-    /* Remove the node from global list.. */
-    if (mdl == Os->mdlHead)
-    {
-        if ((Os->mdlHead = mdl->next) == gcvNULL)
-        {
-            Os->mdlTail = gcvNULL;
-        }
-    }
-    else
-    {
-        mdl->prev->next = mdl->next;
-        if (mdl == Os->mdlTail)
-        {
-            Os->mdlTail = mdl->prev;
-        }
-        else
-        {
-            mdl->next->prev = mdl->prev;
-        }
-    }
-
-    MEMORY_UNLOCK(Os);
-
-    allocator->ops->Free(allocator, mdl);
-
-    gcmkVERIFY_OK(_DestroyMdl(mdl));
-
-    /* Success. */
-    gcmkFOOTER_NO();
-    return gcvSTATUS_OK;
-   
-}
-#endif
-
-
-
-
-
 /*******************************************************************************
 **
 **  gckOS_AllocateNonPagedMemory
@@ -2007,47 +1543,19 @@ gckOS_AllocateNonPagedMemory(
     locked = gcvTRUE;
 
 #ifndef NO_DMA_COHERENT
-#if gcdUSE_NON_PAGED_MEMORY_CACHE
-    addr = _GetNonPagedMemoryCache(Os,
-                mdl->numPages * PAGE_SIZE,
-                &mdl->dmaHandle);
-
-    if (addr == gcvNULL)
-#endif
-    {
-        addr = dma_alloc_coherent(gcvNULL,
-                mdl->numPages * PAGE_SIZE,
-                &mdl->dmaHandle,
-                GFP_KERNEL | gcdNOWARN);
-    }
-#if gcdUSE_NON_PAGED_MEMORY_CACHE
-    if(addr == gcvNULL)
-    {
-            MEMORY_UNLOCK(Os);
-            locked = gcvFALSE;
-            /*Free all cache and try again*/
-            _FreeAllNonPagedMemoryCache(Os);
-            MEMORY_LOCK(Os);
-            locked = gcvTRUE;
-            addr = dma_alloc_coherent(gcvNULL,
-                mdl->numPages * PAGE_SIZE,
-                &mdl->dmaHandle,
-                GFP_KERNEL | gcdNOWARN);
-    }
+#ifdef CONFIG_ARM64
+    addr = dma_alloc_coherent(gcvNULL,
+#else
+    addr = dma_alloc_writecombine(gcvNULL,
 #endif
-    mdl->contiguous = gcvTRUE;
-    mdl->cacheable = gcvFALSE;
+            mdl->numPages * PAGE_SIZE,
+            &mdl->dmaHandle,
+            GFP_KERNEL | gcdNOWARN);
 #else
     size    = mdl->numPages * PAGE_SIZE;
     order   = get_order(size);
-#if gcdUSE_NON_PAGED_MEMORY_CACHE
-    page = _GetNonPagedMemoryCache(Os, order);
 
-    if (page == gcvNULL)
-#endif
-    {
-        page = alloc_pages(GFP_KERNEL | gcdNOWARN, order);
-    }
+    page = alloc_pages(GFP_KERNEL | gcdNOWARN, order);
 
     if (page == gcvNULL)
     {
@@ -2102,10 +1610,6 @@ gckOS_AllocateNonPagedMemory(
     *Bytes = bytes;
     *Physical = (gctPHYS_ADDR) mdl;
 
-#if DYNAMIC_MEMORY_RECORD
-    Os->device->nonpagedmemorysize+=bytes;
-#endif
-
     if (InUserSpace)
     {
         mdlMap = _CreateMdlMap(mdl, _GetProcessID());
@@ -2326,23 +1830,14 @@ gceSTATUS gckOS_FreeNonPagedMemory(
     MEMORY_LOCK(Os);
 
 #ifndef NO_DMA_COHERENT
-#if gcdUSE_NON_PAGED_MEMORY_CACHE
-    if (!_AddNonPagedMemoryCache(Os,
-                                 mdl->numPages * PAGE_SIZE,
-                                 mdl->addr,
-                                 mdl->dmaHandle))
-#endif
-    {
-        dma_free_coherent(gcvNULL,
-                mdl->numPages * PAGE_SIZE,
-                mdl->addr,
-                mdl->dmaHandle);
-    }
-
-#if DYNAMIC_MEMORY_RECORD
-        Os->device->nonpagedmemorysize-=Bytes;
+#ifdef CONFIG_ARM64
+    dma_free_coherent(gcvNULL,
+#else
+    dma_free_writecombine(gcvNULL,
 #endif
-
+            mdl->numPages * PAGE_SIZE,
+            mdl->addr,
+            mdl->dmaHandle);
 #else
     size    = mdl->numPages * PAGE_SIZE;
     vaddr   = mdl->kaddr;
@@ -2355,14 +1850,7 @@ gceSTATUS gckOS_FreeNonPagedMemory(
         size    -= PAGE_SIZE;
     }
 
-#if gcdUSE_NON_PAGED_MEMORY_CACHE
-    if (!_AddNonPagedMemoryCache(Os,
-                                 get_order(mdl->numPages * PAGE_SIZE),
-                                 virt_to_page(mdl->kaddr)))
-#endif
-    {
-        free_pages((unsigned long)mdl->kaddr, get_order(mdl->numPages * PAGE_SIZE));
-    }
+    free_pages((unsigned long)mdl->kaddr, get_order(mdl->numPages * PAGE_SIZE));
 
     _DestoryKernelVirtualMapping(mdl->addr);
 #endif /* NO_DMA_COHERENT */
@@ -4070,7 +3558,7 @@ gckOS_AllocatePagedMemory(
     gcmkVERIFY_ARGUMENT(Physical != gcvNULL);
 
     /* Allocate the memory. */
-    gcmkONERROR(gckOS_AllocatePagedMemoryEx(Os, gcvFALSE, Bytes, Physical));
+    gcmkONERROR(gckOS_AllocatePagedMemoryEx(Os, gcvALLOC_FLAG_NONE, Bytes, gcvNULL, Physical));
 
     /* Success. */
     gcmkFOOTER_ARG("*Physical=0x%X", *Physical);
@@ -4093,14 +3581,17 @@ OnError:
 **      gckOS Os
 **          Pointer to an gckOS object.
 **
-**      gctBOOL Contiguous
-**          Need contiguous memory or not.
+**      gctUINT32 Flag
+**          Allocation attribute.
 **
 **      gctSIZE_T Bytes
 **          Number of bytes to allocate.
 **
 **  OUTPUT:
 **
+**      gctUINT32 * Gid
+**          Save the global ID for the piece of allocated memory.
+**
 **      gctPHYS_ADDR * Physical
 **          Pointer to a variable that receives the physical address of the
 **          memory allocation.
@@ -4108,8 +3599,9 @@ OnError:
 gceSTATUS
 gckOS_AllocatePagedMemoryEx(
     IN gckOS Os,
-    IN gctBOOL Contiguous,
+    IN gctUINT32 Flag,
     IN gctSIZE_T Bytes,
+    OUT gctUINT32 * Gid,
     OUT gctPHYS_ADDR * Physical
     )
 {
@@ -4118,10 +3610,8 @@ gckOS_AllocatePagedMemoryEx(
     gctSIZE_T bytes;
     gceSTATUS status = gcvSTATUS_OUT_OF_MEMORY;
     gckALLOCATOR allocator;
-    gctUINT32 flag = 0;
-    gctBOOL tempContiguous = Contiguous;
 
-    gcmkHEADER_ARG("Os=0x%X Contiguous=%d Bytes=%lu", Os, Contiguous, Bytes);
+    gcmkHEADER_ARG("Os=0x%X Flag=%x Bytes=%lu", Os, Flag, Bytes);
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
@@ -4138,30 +3628,24 @@ gckOS_AllocatePagedMemoryEx(
         gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
     }
 
-    if ( (Contiguous == gcvFALSE + gcvALLOC_FLAG_MEMLIMIT)
-    || (Contiguous == gcvTRUE + gcvALLOC_FLAG_MEMLIMIT))
-    {
-        tempContiguous = Contiguous - gcvALLOC_FLAG_MEMLIMIT;
-        flag |= gcvALLOC_FLAG_MEMLIMIT;
-    }
-
-    if (tempContiguous)
-	{
-        flag |= gcvALLOC_FLAG_CONTIGUOUS;
-    }
-
-    /* Walk all default allocators. */
+    /* Walk all allocators. */
     list_for_each_entry(allocator, &Os->allocatorList, head)
     {
-        if(!allocator->privateData)
+        gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_OS,
+                       "%s(%d) flag = %x allocator->capability = %x",
+                        __FUNCTION__, __LINE__, Flag, allocator->capability);
+
+        if ((Flag & allocator->capability) != Flag)
         {
-            status = allocator->ops->Alloc(allocator, mdl, numPages, flag);
+            continue;
+        }
 
-            if (gcmIS_SUCCESS(status))
-            {
-                mdl->allocator = allocator;
-                break;
-            }
+        status = allocator->ops->Alloc(allocator, mdl, numPages, Flag);
+
+        if (gcmIS_SUCCESS(status))
+        {
+            mdl->allocator = allocator;
+            break;
         }
     }
 
@@ -4172,28 +3656,16 @@ gckOS_AllocatePagedMemoryEx(
     mdl->addr       = 0;
     mdl->numPages   = numPages;
     mdl->pagedMem   = 1;
-    mdl->contiguous = tempContiguous;
-    mdl->cacheable=gcvTRUE;
+    mdl->contiguous = Flag & gcvALLOC_FLAG_CONTIGUOUS;
 
-#if DYNAMIC_MEMORY_RECORD
-        if(mdl->contiguous)
-        {
-            if(!PageHighMem(nth_page(mdl->u.contiguousPages, 0)))
-               Os->device->contiguouslowmemsize+= bytes;
-            else
-                Os->device->contiguoushighmemsize+= bytes;
-        }
-        else
-        {
-            if(!PageHighMem(_NonContiguousToPage(mdl->u.nonContiguousPages, 0)))
-               Os->device->noncontiguouslowmemsize+= bytes;
-            else
-               Os->device->noncontiguoushighmemsize+= bytes;
-         }
-#endif
     /* Return physical address. */
     *Physical = (gctPHYS_ADDR) mdl;
 
+    if (Gid != gcvNULL)
+    {
+        *Gid = mdl->gid;
+    }
+
     MEMORY_LOCK(Os);
 
     /*
@@ -4228,7 +3700,7 @@ OnError:
     }
 
     /* Return the status. */
-    gcmkFOOTER();
+    gcmkFOOTER_ARG("Os=0x%X Flag=%x Bytes=%lu", Os, Flag, Bytes);
     return status;
 }
 
@@ -4272,23 +3744,6 @@ gckOS_FreePagedMemory(
 
     MEMORY_LOCK(Os);
 
-#if DYNAMIC_MEMORY_RECORD
-        if(mdl->contiguous)
-        {
-            if(!PageHighMem(nth_page(mdl->u.contiguousPages, 0)))
-               Os->device->contiguouslowmemsize-= mdl->numPages * PAGE_SIZE;
-            else
-                Os->device->contiguoushighmemsize-= mdl->numPages * PAGE_SIZE;
-        }
-        else
-        {
-            if(!PageHighMem(_NonContiguousToPage(mdl->u.nonContiguousPages, 0)))
-               Os->device->noncontiguouslowmemsize-= mdl->numPages * PAGE_SIZE;
-            else
-               Os->device->noncontiguoushighmemsize-= mdl->numPages * PAGE_SIZE;
-         }
-#endif
-
     /* Remove the node from global list. */
     if (mdl == Os->mdlHead)
     {
@@ -4421,17 +3876,16 @@ gckOS_LockPages(
     *PageCount = mdl->numPages * (PAGE_SIZE / 4096);
 
     MEMORY_UNLOCK(Os);
-    if(mdl->cacheable)
-    {
-        gcmkVERIFY_OK(gckOS_CacheFlush(
-            Os,
-            _GetProcessID(),
-            Physical,
-            gcvINVALID_ADDRESS,
-            (gctPOINTER)mdlMap->vmaAddr,
-            mdl->numPages * PAGE_SIZE
-            ));
-    }
+
+    gcmkVERIFY_OK(gckOS_CacheFlush(
+        Os,
+        _GetProcessID(),
+        Physical,
+        gcvINVALID_ADDRESS,
+        (gctPOINTER)mdlMap->vmaAddr,
+        mdl->numPages * PAGE_SIZE
+        ));
+
     /* Success. */
     gcmkFOOTER_ARG("*Logical=0x%X *PageCount=%lu", *Logical, *PageCount);
     return gcvSTATUS_OK;
@@ -4675,20 +4129,15 @@ gckOS_UnlockPages(
     gcmkVERIFY_ARGUMENT(Physical != gcvNULL);
     gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
 
-    /* Make sure there is already a mapping...*/
-    gcmkVERIFY_ARGUMENT(mdl->u.nonContiguousPages != gcvNULL
-                       || mdl->u.contiguousPages != gcvNULL || mdl->maps);
-
     MEMORY_LOCK(Os);
 
     mdlMap = mdl->maps;
 
     while (mdlMap != gcvNULL)
     {
-         if ((mdlMap->vmaAddr != gcvNULL) && (_GetProcessID() == mdlMap->pid))
+        if ((mdlMap->vmaAddr != gcvNULL) && (_GetProcessID() == mdlMap->pid))
         {
-            --mdlMap->count;
-             if (mdlMap->count == 0)
+            if (--mdlMap->count == 0)
             {
                 allocator->ops->UnmapUser(
                     allocator,
@@ -6270,6 +5719,8 @@ gckOS_CacheClean(
     IN gctSIZE_T Bytes
     )
 {
+    gcsPLATFORM * platform;
+
     gcmkHEADER_ARG("Os=0x%X ProcessID=%d Handle=0x%X Logical=0x%X Bytes=%lu",
                    Os, ProcessID, Handle, Logical, Bytes);
 
@@ -6278,6 +5729,25 @@ gckOS_CacheClean(
     gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
     gcmkVERIFY_ARGUMENT(Bytes > 0);
 
+    platform = Os->device->platform;
+
+    if (platform && platform->ops->cache)
+    {
+        platform->ops->cache(
+            platform,
+            ProcessID,
+            Handle,
+            Physical,
+            Logical,
+            Bytes,
+            gcvCACHE_CLEAN
+            );
+
+        /* Success. */
+        gcmkFOOTER_NO();
+        return gcvSTATUS_OK;
+    }
+
 #if !gcdCACHE_FUNCTION_UNIMPLEMENTED
 #ifdef CONFIG_ARM
 
@@ -6353,6 +5823,8 @@ gckOS_CacheInvalidate(
     IN gctSIZE_T Bytes
     )
 {
+    gcsPLATFORM * platform;
+
     gcmkHEADER_ARG("Os=0x%X ProcessID=%d Handle=0x%X Logical=0x%X Bytes=%lu",
                    Os, ProcessID, Handle, Logical, Bytes);
 
@@ -6361,6 +5833,25 @@ gckOS_CacheInvalidate(
     gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
     gcmkVERIFY_ARGUMENT(Bytes > 0);
 
+    platform = Os->device->platform;
+
+    if (platform && platform->ops->cache)
+    {
+        platform->ops->cache(
+            platform,
+            ProcessID,
+            Handle,
+            Physical,
+            Logical,
+            Bytes,
+            gcvCACHE_INVALIDATE
+            );
+
+        /* Success. */
+        gcmkFOOTER_NO();
+        return gcvSTATUS_OK;
+    }
+
 #if !gcdCACHE_FUNCTION_UNIMPLEMENTED
 #ifdef CONFIG_ARM
 
@@ -6432,6 +5923,8 @@ gckOS_CacheFlush(
     IN gctSIZE_T Bytes
     )
 {
+    gcsPLATFORM * platform;
+
     gcmkHEADER_ARG("Os=0x%X ProcessID=%d Handle=0x%X Logical=0x%X Bytes=%lu",
                    Os, ProcessID, Handle, Logical, Bytes);
 
@@ -6440,6 +5933,25 @@ gckOS_CacheFlush(
     gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
     gcmkVERIFY_ARGUMENT(Bytes > 0);
 
+    platform = Os->device->platform;
+
+    if (platform && platform->ops->cache)
+    {
+        platform->ops->cache(
+            platform,
+            ProcessID,
+            Handle,
+            Physical,
+            Logical,
+            Bytes,
+            gcvCACHE_FLUSH
+            );
+
+        /* Success. */
+        gcmkFOOTER_NO();
+        return gcvSTATUS_OK;
+    }
+
 #if !gcdCACHE_FUNCTION_UNIMPLEMENTED
 #ifdef CONFIG_ARM
     /* Inner cache. */
@@ -7054,7 +6566,7 @@ gckOS_SetGPUPower(
         mutex_unlock(&Os->registerAccessLocks[Core]);
     }
 
-	if (powerChange && (Power == gcvFALSE))
+    if (powerChange && (Power == gcvFALSE))
     {
         if (platform && platform->ops->setPower)
         {
@@ -7569,7 +7081,11 @@ gckOS_Signal(
     else
     {
         /* Set the event to an unsignaled state. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,13,0)
         reinit_completion(&signal->obj);
+#else
+        INIT_COMPLETION(signal->obj);
+#endif
     }
 
     gcmkVERIFY_OK(gckOS_ReleaseMutex(Os, Os->signalMutex));
@@ -8581,7 +8097,7 @@ gckOS_DetectProcessByName(
                               : gcvSTATUS_FALSE;
 }
 
-#if gcdANDROID_NATIVE_FENCE_SYNC
+#if gcdANDROID_NATIVE_FENCE_SYNC && defined(ANDROID)
 
 gceSTATUS
 gckOS_CreateSyncPoint(
@@ -8936,6 +8452,7 @@ gckOS_AllocatePageArray(
     gctUINT32*  table;
     gctUINT32   offset;
     gctSIZE_T   bytes;
+    gckALLOCATOR allocator;
 
     gcmkHEADER_ARG("Os=0x%X Physical=0x%X PageCount=%u",
                    Os, Physical, PageCount);
@@ -8959,6 +8476,8 @@ gckOS_AllocatePageArray(
     /* Convert pointer to MDL. */
     mdl = (PLINUX_MDL)Physical;
 
+    allocator = mdl->allocator;
+
      /* Get all the physical addresses and store them in the page table. */
 
     offset = 0;
@@ -8971,7 +8490,12 @@ gckOS_AllocatePageArray(
 
         if (mdl->pagedMem && !mdl->contiguous)
         {
-            phys = _NonContiguousToPhys(mdl->u.nonContiguousPages, offset);
+            if (allocator)
+            {
+                gctUINT32 phys_addr;
+                allocator->ops->Physical(allocator, mdl, offset, &phys_addr);
+                phys = (unsigned long)phys_addr;
+            }
         }
         else
         {
@@ -9042,6 +8566,24 @@ gckOS_GPUPhysicalToCPUPhysical(
 }
 
 gceSTATUS
+gckOS_PhysicalToPhysicalAddress(
+    IN gckOS Os,
+    IN gctPOINTER Physical,
+    OUT gctUINT32 * PhysicalAddress
+    )
+{
+    PLINUX_MDL mdl = (PLINUX_MDL)Physical;
+    gckALLOCATOR allocator = mdl->allocator;
+
+    if (allocator)
+    {
+        return allocator->ops->Physical(allocator, mdl, 0, PhysicalAddress);
+    }
+
+    return gcvSTATUS_NOT_SUPPORTED;
+}
+
+gceSTATUS
 gckOS_GetVideoMemoryMutex(
     IN gckOS Os,
     OUT gctPOINTER *Mutex
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
index 4bee13a..9d3126d 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
@@ -57,7 +57,6 @@ typedef struct _LINUX_MDL
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
     gctBOOL                 exact;
 #endif
-    gctBOOL                 cacheable;
     dma_addr_t              dmaHandle;
     PLINUX_MDL_MAP          maps;
     struct _LINUX_MDL *     prev;
@@ -68,6 +67,8 @@ typedef struct _LINUX_MDL
 
     /* Private data used by allocator. */
     void *                  priv;
+
+    uint                    gid;
 }
 LINUX_MDL, *PLINUX_MDL;
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_platform.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_platform.h
index e2c4c8a..5d71937 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_platform.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_platform.h
@@ -169,7 +169,7 @@ typedef struct _gcsPLATFORM_OPERATIONS
 
     /*******************************************************************************
     **
-    **  setPower
+    **  setClock
     **
     **  Set clock state of specified GPU.
     **
@@ -223,14 +223,13 @@ typedef struct _gcsPLATFORM_OPERATIONS
     **
     **  adjustProt
     **
-    **  Adjust Prot, it's for Cache on gc5000(0x5434) and gc3000(0x5435).
+    **  Override Prot flag when mapping paged memory to userspace.
     */
     gceSTATUS
     (*adjustProt)(
         IN struct vm_area_struct * vma
         );
 
-
     /*******************************************************************************
     **
     **  shrinkMemory
@@ -241,6 +240,23 @@ typedef struct _gcsPLATFORM_OPERATIONS
     (*shrinkMemory)(
         IN gckPLATFORM Platform
         );
+
+    /*******************************************************************************
+    **
+    **  cache
+    **
+    **  Cache operation.
+    */
+    gceSTATUS
+    (*cache)(
+        IN gckPLATFORM Platform,
+        IN gctUINT32 ProcessID,
+        IN gctPHYS_ADDR Handle,
+        IN gctUINT32 Physical,
+        IN gctPOINTER Logical,
+        IN gctSIZE_T Bytes,
+        IN gceCACHEOPERATION Operation
+        );
 }
 gcsPLATFORM_OPERATIONS;
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_probe.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_probe.c
index d55b623..8d6ed15 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_probe.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_probe.c
@@ -97,7 +97,10 @@ module_param(registerMemBaseVG, ulong, 0644);
 static ulong registerMemSizeVG = 2 << 10;
 module_param(registerMemSizeVG, ulong, 0644);
 
-static ulong contiguousSize = 4 << 20;
+#ifndef gcdDEFAULT_CONTIGUOUS_SIZE
+#define gcdDEFAULT_CONTIGUOUS_SIZE (4 << 20)
+#endif
+static ulong contiguousSize = gcdDEFAULT_CONTIGUOUS_SIZE;
 module_param(contiguousSize, ulong, 0644);
 
 static ulong contiguousBase = 0;
@@ -180,170 +183,6 @@ static struct file_operations driver_fops =
     .mmap       = drv_mmap,
 };
 
-static ssize_t show_meminfo(struct device_driver *dev, char *buf)
-{
-    gckKERNEL  kernel;
-    size_t size =0;
-
-    if(galDevice->kernels[gcvCORE_MAJOR])
-    {
-        kernel = galDevice->kernels[gcvCORE_MAJOR];
-    }
-    else if(galDevice->kernels[gcvCORE_VG])
-    {
-        kernel = galDevice->kernels[gcvCORE_VG];
-    }
-    else
-    {
-        kernel = galDevice->kernels[gcvCORE_2D];
-    }
-
-    size+= snprintf(buf+size, PAGE_SIZE-size,"Reseverd memory information:\n");
-    size+= snprintf(buf+size, PAGE_SIZE-size,"Type\r\tbaseaddress\r\t\t\tsize(bytes)\r\t\t\t\t\tused(bytes)\r\t\t\t\t\t\t\tfree(bytes)\n");
-    if(galDevice->internalVidMem)
-       size+= snprintf(buf+size, PAGE_SIZE-size,"Internal\r\t0x%x\r\t\t\t%u\r\t\t\t\t\t%u\r\t\t\t\t\t\t\t%u\n",
-            galDevice->internalVidMem->baseAddress,galDevice->internalVidMem->bytes,
-            galDevice->internalVidMem->bytes-galDevice->internalVidMem->freeBytes,
-            galDevice->internalVidMem->freeBytes);
-    if(galDevice->externalVidMem)
-       size+= snprintf(buf+size, PAGE_SIZE-size,"External\r\t0x%x\r\t\t\t%u\r\t\t\t\t\t%u\r\t\t\t\t\t\t\t%u\n",
-            galDevice->externalVidMem->baseAddress,galDevice->externalVidMem->bytes,
-            galDevice->externalVidMem->bytes-galDevice->externalVidMem->freeBytes,
-            galDevice->externalVidMem->freeBytes);
-    if(galDevice->contiguousVidMem)
-       size+= snprintf(buf+size, PAGE_SIZE-size,"System\r\t0x%x\r\t\t\t%u\r\t\t\t\t\t%u\r\t\t\t\t\t\t\t%u\n",
-            galDevice->contiguousVidMem ->baseAddress,galDevice->contiguousVidMem->bytes,
-            galDevice->contiguousVidMem->bytes-galDevice->contiguousVidMem->freeBytes,
-            galDevice->contiguousVidMem->freeBytes);
-
-#if DYNAMIC_MEMORY_RECORD
-    size+= snprintf(buf+size, PAGE_SIZE-size,"Dynamic memory information:\n");
-
-    size+= snprintf(buf+size, PAGE_SIZE-size,"Type\r\t\t\t\t\tused size(bytes)\n");
-    size+= snprintf(buf+size, PAGE_SIZE-size,"Cached memory\r\t\t\t\t\t%u\n",  galDevice->cachedsize);
-    size+= snprintf(buf+size, PAGE_SIZE-size,"Non paged memory\r\t\t\t\t\t%u\n",  galDevice->nonpagedmemorysize);
-#if LINUX_CMA_FSL
-    size+= snprintf(buf+size, PAGE_SIZE-size,"CMA memory\r\t\t\t\t\t%u\n",  galDevice->cmasize);
-#endif
-    size+= snprintf(buf+size, PAGE_SIZE-size,"Contiguous paged memory(low)\r\t\t\t\t\t%u\n",  galDevice->contiguouslowmemsize);
-    size+= snprintf(buf+size, PAGE_SIZE-size,"Contiguous paged memory(high)\r\t\t\t\t\t%u\n",  galDevice->contiguoushighmemsize);
-    size+= snprintf(buf+size, PAGE_SIZE-size,"NonContiguous paged memory(low)\r\t\t\t\t\t%u\n",  galDevice->noncontiguouslowmemsize);
-    size+= snprintf(buf+size, PAGE_SIZE-size,"NonContiguous paged memory(high)\r\t\t\t\t\t%u\n",  galDevice->noncontiguoushighmemsize);
-#endif
-    return strlen(buf);
-}
-
-static DRIVER_ATTR(meminfo, S_IRUGO | S_IWUSR, show_meminfo, NULL);
-
-static ssize_t show_pid(struct device_driver *dev, char *buf)
-{
-    gckKERNEL  kernel;
-    size_t size =0;
-    gcsDATABASE_PTR database;
-    gctINT i, pid;
-    gctUINT8 name[24];
-
-    if(galDevice->kernels[gcvCORE_MAJOR])
-    {
-        kernel = galDevice->kernels[gcvCORE_MAJOR];
-    }
-    else if(galDevice->kernels[gcvCORE_VG])
-    {
-        kernel = galDevice->kernels[gcvCORE_VG];
-    }
-    else
-    {
-        kernel = galDevice->kernels[gcvCORE_2D];
-    }
-
-    gckOS_AcquireMutex(kernel->os, kernel->db->dbMutex, gcvINFINITE);
-
-    size+= snprintf(buf+size, PAGE_SIZE-size, "**************************\n");
-    size+= snprintf(buf+size, PAGE_SIZE-size, "***  PROCESS DB DUMP   ***\n");
-    size+= snprintf(buf+size, PAGE_SIZE-size, "**************************\n");
-
-    size+= snprintf(buf+size, PAGE_SIZE-size, "%-8s%s\n", "PID", "NAME");
-    /* Walk the databases. */
-    for (i = 0; i < gcmCOUNTOF(kernel->db->db); ++i)
-    {
-        for (database = kernel->db->db[i];
-             database != gcvNULL;
-             database = database->next)
-        {
-            pid = database->processID;
-
-            gcmkVERIFY_OK(gckOS_GetProcessNameByPid(pid, gcmSIZEOF(name), name));
-
-            size+= snprintf(buf+size, PAGE_SIZE-size, "%-8d%s\n", pid, name);
-        }
-    }
-    gckOS_ReleaseMutex(kernel->os, kernel->db->dbMutex);
-    return size;
-}
-
-static DRIVER_ATTR(pid, S_IRUGO | S_IWUSR, show_pid, NULL);
-
-static ssize_t show_idletime(struct device_driver *dev, char *buf)
-{
-    gcuDATABASE_INFO info;
-    gckKERNEL  kernel;
-
-    memset(&info, 0, sizeof(info));
-
-    if(galDevice->kernels[gcvCORE_MAJOR])
-    {
-        kernel = galDevice->kernels[gcvCORE_MAJOR];
-    }
-    else if(galDevice->kernels[gcvCORE_VG])
-    {
-        kernel = galDevice->kernels[gcvCORE_VG];
-    }
-    else
-    {
-        kernel = galDevice->kernels[gcvCORE_2D];
-    }
-
-    if(gckKERNEL_QueryProcessDB(kernel,0,gcvFALSE,gcvDB_IDLE,&info)==gcvSTATUS_OK)
-        snprintf(buf, PAGE_SIZE, "GPU idle time since last query: %llu ns\n", info.time);
-
-    return strlen(buf);
-}
-
-
-static DRIVER_ATTR(idletime, S_IRUGO | S_IWUSR, show_idletime, gcvNULL);
-
-#if gcdENABLE_FSCALE_VAL_ADJUST
-static ssize_t show_gpu3DMinClock(struct device_driver *dev, char *buf)
-{
-    gctUINT currentf,minf,maxf;
-    if(galDevice->kernels[gcvCORE_MAJOR])
-    {
-         gckHARDWARE_GetFscaleValue(galDevice->kernels[gcvCORE_MAJOR]->hardware,
-            &currentf, &minf, &maxf);
-    }
-    snprintf(buf, PAGE_SIZE, "%d\n", minf);
-    return strlen(buf);
-}
-
-static ssize_t update_gpu3DMinClock(struct device_driver *dev, const char *buf, size_t count)
-{
-
-    gctINT fields;
-    gctUINT MinFscaleValue;
-   if(galDevice->kernels[gcvCORE_MAJOR])
-   {
-        fields = sscanf(buf, "%d", &MinFscaleValue);
-        if (fields < 1)
-            return -EINVAL;
-
-        gckHARDWARE_SetMinFscaleValue(galDevice->kernels[gcvCORE_MAJOR]->hardware,MinFscaleValue);
-   }
-
-    return count;
-}
-
-static DRIVER_ATTR(gpu3DMinClock, S_IRUGO | S_IWUSR, show_gpu3DMinClock, update_gpu3DMinClock);
-#endif
 void
 _UpdateModuleParam(
     gcsMODULE_PARAMETERS *Param
@@ -481,7 +320,7 @@ int drv_open(
     }
     attached = gcvTRUE;
 
-    if ((!galDevice->contiguousMapped) && galDevice->contiguousSize)
+    if (!galDevice->contiguousMapped)
     {
         if (galDevice->contiguousPhysical != gcvNULL)
         {
@@ -580,7 +419,7 @@ int drv_release(
         gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
     }
 
-    if ((!device->contiguousMapped) && device->contiguousSize)
+    if (!device->contiguousMapped)
     {
         if (data->contiguousLogical != gcvNULL)
         {
@@ -979,11 +818,13 @@ static int drv_init(void)
     printk(KERN_INFO "Galcore version %d.%d.%d.%d\n",
         gcvVERSION_MAJOR, gcvVERSION_MINOR, gcvVERSION_PATCH, gcvVERSION_BUILD);
 
+#if !VIVANTE_PROFILER_PM
     /* when enable gpu profiler, we need to turn off gpu powerMangement */
     if (gpuProfiler)
     {
         powerManagement = 0;
     }
+#endif
 
     if (showArgs)
     {
@@ -1156,7 +997,6 @@ static void drv_exit(void)
 
     unregister_chrdev(major, DEVICE_NAME);
 
-    galDevice->contiguousRequested = contiguousRequested;
     gcmkVERIFY_OK(gckGALDEVICE_Stop(galDevice));
     gcmkVERIFY_OK(gckGALDEVICE_Destroy(galDevice));
 
@@ -1237,23 +1077,6 @@ static int __devinit gpu_probe(struct platform_device *pdev)
     {
         platform_set_drvdata(pdev, galDevice);
 
-        ret = driver_create_file(pdev->dev.driver, &driver_attr_meminfo);
-        if(ret)
-            dev_err(&pdev->dev, "create meminfo attr failed (%d)\n", ret);
-
-        ret = driver_create_file(pdev->dev.driver, &driver_attr_pid);
-        if(ret)
-            dev_err(&pdev->dev, "create pid attr failed (%d)\n", ret);
-
-        ret = driver_create_file(pdev->dev.driver, &driver_attr_idletime);
-        if(ret)
-            dev_err(&pdev->dev, "create idletime attr failed (%d)\n", ret);
-
-#if gcdENABLE_FSCALE_VAL_ADJUST
-        ret = driver_create_file(pdev->dev.driver, &driver_attr_gpu3DMinClock);
-        if(ret)
-            dev_err(&pdev->dev, "create gpu3DMinClock attr failed (%d)\n", ret);
-#endif
         gcmkFOOTER_NO();
         return ret;
     }
@@ -1270,13 +1093,6 @@ static int __devexit gpu_remove(struct platform_device *pdev)
 {
     gcmkHEADER();
 
-    driver_remove_file(pdev->dev.driver, &driver_attr_meminfo);
-    driver_remove_file(pdev->dev.driver, &driver_attr_pid);
-    driver_remove_file(pdev->dev.driver, &driver_attr_idletime);
-#if gcdENABLE_FSCALE_VAL_ADJUST
-    driver_remove_file(pdev->dev.driver, &driver_attr_gpu3DMinClock);
-#endif
-
     drv_exit();
 
     if (platform.ops->putPower)
@@ -1420,7 +1236,7 @@ static int gpu_resume(struct platform_device *dev)
     return 0;
 }
 
-#ifdef CONFIG_PM
+#if defined(CONFIG_PM) && LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 30)
 #ifdef CONFIG_PM_SLEEP
 static int gpu_system_suspend(struct device *dev)
 {
@@ -1452,7 +1268,7 @@ static struct platform_driver gpu_driver = {
 
     .driver     = {
         .name   = DEVICE_NAME,
-#if CONFIG_PM
+#if defined(CONFIG_PM) && LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 30)
         .pm     = &gpu_pm_ops,
 #endif
     }
@@ -1528,6 +1344,8 @@ out:
 
 static void __exit gpu_exit(void)
 {
+    platform_driver_unregister(&gpu_driver);
+
     if (platform.ops->needAddDevice
      && platform.ops->needAddDevice(&platform))
     {
@@ -1539,8 +1357,6 @@ static void __exit gpu_exit(void)
         /* Free platform private data. */
         platform.ops->freePriv(&platform);
     }
-
-    platform_driver_unregister(&gpu_driver);
 }
 
 module_init(gpu_init);
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_security_channel.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_security_channel.c
index 007a694..e745a6f 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_security_channel.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_security_channel.c
@@ -63,11 +63,23 @@ gpu3d_allocate_secure_mem(
 
     memset(shm, 0, sizeof(TEEC_SharedMemory));
 
-    status = gckOS_AllocateIonMemory(Os,
-                            gcvTRUE,
-                            &bytes,
-                            (gctPHYS_ADDR *)&handle,
-                            &phyAddr);
+    status = gckOS_AllocatePagedMemoryEx(
+                Os,
+                gcvALLOC_FLAG_SECURITY,
+                bytes,
+                gcvNULL,
+                (gctPHYS_ADDR *)&handle);
+
+    if (gcmIS_ERROR(status))
+    {
+         kfree(shm);
+         return NULL;
+    }
+
+    status = gckOS_PhysicalToPhysicalAddress(
+                Os,
+                handle,
+                &phyAddr);
 
     if (gcmIS_ERROR(status))
     {
@@ -91,7 +103,7 @@ gpu3d_allocate_secure_mem(
 
     if (result != TEEC_SUCCESS)
     {
-        gckOS_FreeIonMemory(Os, (gctPHYS_ADDR)handle);
+        gckOS_FreePagedMemory(Os, (gctPHYS_ADDR)handle, shm->size);
         kfree(shm);
         return NULL;
     }
@@ -115,8 +127,7 @@ void gpu3d_release_secure_mem(
     handle = shm->userdata;
 
     TEEC_ReleaseSharedMemory(shm);
-
-    gckOS_FreeIonMemory(Os, (gctPHYS_ADDR)handle);
+    gckOS_FreePagedMemory(Os, (gctPHYS_ADDR)handle, shm->size);
 
     kfree(shm);
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.c
index 0e5a816..8354173 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.c
@@ -22,7 +22,7 @@
 #include <gc_hal.h>
 #include <gc_hal_base.h>
 
-#if gcdANDROID_NATIVE_FENCE_SYNC
+#if gcdANDROID_NATIVE_FENCE_SYNC && defined(ANDROID)
 
 #include <linux/kernel.h>
 #include <linux/file.h>
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx6q14.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx6q14.c
index a73c440..3f3c666 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx6q14.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx6q14.c
@@ -113,7 +113,7 @@ static int force_contiguous_lowmem_shrink(IN gckKERNEL Kernel)
 		return 0;
 	selected_oom_adj = min_adj;
 
-	read_lock(&tasklist_lock);
+       rcu_read_lock();
 	for_each_process(p) {
 		struct mm_struct *mm;
 		struct signal_struct *sig;
@@ -135,7 +135,7 @@ static int force_contiguous_lowmem_shrink(IN gckKERNEL Kernel)
 
 		tasksize = 0;
 		task_unlock(p);
-		read_unlock(&tasklist_lock);
+               rcu_read_unlock();
 
 		if (gckKERNEL_QueryProcessDB(Kernel, p->pid, gcvFALSE, gcvDB_VIDEO_MEMORY, &info) == gcvSTATUS_OK){
 			tasksize += info.counters.bytes / PAGE_SIZE;
@@ -144,7 +144,7 @@ static int force_contiguous_lowmem_shrink(IN gckKERNEL Kernel)
 			tasksize += info.counters.bytes / PAGE_SIZE;
 		}
 
-                read_lock(&tasklist_lock);
+               rcu_read_lock();
 
 		if (tasksize <= 0)
 			continue;
@@ -171,7 +171,7 @@ static int force_contiguous_lowmem_shrink(IN gckKERNEL Kernel)
 		force_sig(SIGKILL, selected);
 		ret = 0;
 	}
-	read_unlock(&tasklist_lock);
+       rcu_read_unlock();
 	return ret;
 }
 
@@ -253,8 +253,48 @@ static int thermal_hot_pm_notify(struct notifier_block *nb, unsigned long event,
 static struct notifier_block thermal_hot_pm_notifier = {
     .notifier_call = thermal_hot_pm_notify,
     };
+
+static ssize_t show_gpu3DMinClock(struct device_driver *dev, char *buf)
+{
+    gctUINT currentf,minf,maxf;
+    gckGALDEVICE galDevice;
+
+    galDevice = platform_get_drvdata(pdevice);
+    if(galDevice->kernels[gcvCORE_MAJOR])
+    {
+         gckHARDWARE_GetFscaleValue(galDevice->kernels[gcvCORE_MAJOR]->hardware,
+            &currentf, &minf, &maxf);
+    }
+    snprintf(buf, PAGE_SIZE, "%d\n", minf);
+    return strlen(buf);
+}
+
+static ssize_t update_gpu3DMinClock(struct device_driver *dev, const char *buf, size_t count)
+{
+
+    gctINT fields;
+    gctUINT MinFscaleValue;
+    gckGALDEVICE galDevice;
+
+    galDevice = platform_get_drvdata(pdevice);
+    if(galDevice->kernels[gcvCORE_MAJOR])
+    {
+         fields = sscanf(buf, "%d", &MinFscaleValue);
+         if (fields < 1)
+             return -EINVAL;
+
+         gckHARDWARE_SetMinFscaleValue(galDevice->kernels[gcvCORE_MAJOR]->hardware,MinFscaleValue);
+    }
+
+    return count;
+}
+
+static DRIVER_ATTR(gpu3DMinClock, S_IRUGO | S_IWUSR, show_gpu3DMinClock, update_gpu3DMinClock);
 #endif
 
+
+
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
 static const struct of_device_id mxs_gpu_dt_ids[] = {
     { .compatible = "fsl,imx6q-gpu", },
@@ -305,9 +345,6 @@ gckPLATFORM_AdjustParam(
      struct resource* res;
      struct platform_device* pdev = Platform->device;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
-     struct imx_priv *priv = Platform->priv;
-
-       struct contiguous_mem_pool *pool;
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
        struct device_node *dn =pdev->dev.of_node;
        const u32 *prop;
@@ -353,34 +390,7 @@ gckPLATFORM_AdjustParam(
     }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
-       pool = devm_kzalloc(&pdev->dev, sizeof(*pool), GFP_KERNEL);
-       if (!pool)
-               return gcvSTATUS_OUT_OF_MEMORY;
-       if(Args->contiguousSize)
-       {
-            if(Args->contiguousSize == 4 << 20)
-                /*Update the default setting*/
-               Args->contiguousSize = pool->size = 128 * 1024 * 1024;
-            else
-               pool->size = Args->contiguousSize;
-
-           init_dma_attrs(&pool->attrs);
-           dma_set_attr(DMA_ATTR_WRITE_COMBINE, &pool->attrs);
-           pool->virt = dma_alloc_attrs(&pdev->dev, pool->size, &pool->phys,
-                                        GFP_KERNEL, &pool->attrs);
-           if (!pool->virt) {
-                   dev_err(&pdev->dev, "Failed to allocate contiguous memory\n");
-
-                   devm_kfree(&pdev->dev, pool);
-
-                   return gcvSTATUS_OUT_OF_MEMORY;
-           }
-           Args->contiguousBase = pool->phys;
-       }
-       Args->contiguousRequested = gcvTRUE;
-
-       priv->pool = pool;
-
+       Args->contiguousBase = 0;
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
        prop = of_get_property(dn, "contiguousbase", NULL);
        if(prop)
@@ -419,24 +429,6 @@ _FreePriv(
     IN gckPLATFORM Platform
     )
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
-    struct imx_priv *priv = Platform->priv;
-    struct platform_device *pdev = Platform->device;
-
-   struct contiguous_mem_pool *pool = priv->pool;
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
-    if (pool && pool->size)
-    {
-        dma_free_attrs(&pdev->dev, pool->size, pool->virt, pool->phys,
-                   &pool->attrs);
-
-        devm_kfree(&pdev->dev, pool);
-        priv->pool = NULL;
-    }
-#endif
-
 #ifdef CONFIG_GPU_LOW_MEMORY_KILLER
     task_free_unregister(&task_nb);
 #endif
@@ -538,6 +530,12 @@ _GetPower(
 #if gcdENABLE_FSCALE_VAL_ADJUST
     pdevice = Platform->device;
     REG_THERMAL_NOTIFIER(&thermal_hot_pm_notifier);
+    {
+        int ret = 0;
+        ret = driver_create_file(pdevice->dev.driver, &driver_attr_gpu3DMinClock);
+        if(ret)
+            dev_err(&pdevice->dev, "create gpu3DMinClock attr failed (%d)\n", ret);
+    }
 #endif
 
     return gcvSTATUS_OK;
@@ -592,6 +590,8 @@ _PutPower(
 
 #if gcdENABLE_FSCALE_VAL_ADJUST
     UNREG_THERMAL_NOTIFIER(&thermal_hot_pm_notifier);
+
+    driver_remove_file(pdevice->dev.driver, &driver_attr_gpu3DMinClock);
 #endif
 
     return gcvSTATUS_OK;
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx6q14.config b/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx6q14.config
new file mode 100644
index 0000000..08db2eb
--- /dev/null
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx6q14.config
@@ -0,0 +1,3 @@
+EXTRA_CFLAGS += -DgcdDEFAULT_CONTIGUOUS_SIZE=134217728 -DLINUX_CMA_FSL=1
+ALLOCATOR_ARRAY_H_LOCATION := $(OS_KERNEL_DIR)/allocator/freescale/
+CUSTOMER_ALLOCATOR_OBJS := $(ALLOCATOR_ARRAY_H_LOCATION)/gc_hal_kernel_allocator_cma.o
-- 
1.7.5.4

