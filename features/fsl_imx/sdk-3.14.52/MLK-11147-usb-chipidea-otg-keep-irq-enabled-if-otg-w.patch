From f05c1960f4a962491ed5e0bced426d6b113ccc10 Mon Sep 17 00:00:00 2001
From: Li Jun <jun.li@freescale.com>
Date: Tue, 23 Jun 2015 10:46:44 +0800
Subject: [PATCH 0856/1221] MLK-11147 usb: chipidea: otg: keep irq enabled if
 otg work had been queued

If the otg work had been queued, current code will disable irq again
but the otg work will be done only once, so the irq enable and disable
cannot be balanced, this patch is to fix this.

Signed-off-by: Li Jun <b47624@freescale.com>
[zou:Original patch taken from
git.freescale.com/imx/fsl-arm-yocto-bsp.git-b imx-3.14.52-1.1.0_ga]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/usb/chipidea/otg.h |   12 +++++++-----
 1 files changed, 7 insertions(+), 5 deletions(-)

diff --git a/drivers/usb/chipidea/otg.h b/drivers/usb/chipidea/otg.h
index 43296cd..95fa6c2 100644
--- a/drivers/usb/chipidea/otg.h
+++ b/drivers/usb/chipidea/otg.h
@@ -21,11 +21,13 @@ void ci_handle_id_switch(struct ci_hdrc *ci);
 void ci_handle_vbus_connected(struct ci_hdrc *ci);
 static inline void ci_otg_queue_work(struct ci_hdrc *ci)
 {
-	WARN_ON(!ci->wq);
-
-	disable_irq_nosync(ci->irq);
-	if (ci->wq)
-		queue_work(ci->wq, &ci->work);
+	if (ci->wq) {
+		disable_irq_nosync(ci->irq);
+		if (!queue_work(ci->wq, &ci->work))
+			enable_irq(ci->irq);
+	} else {
+		WARN_ON(!ci->wq);
+	}
 }
 
 #endif /* __DRIVERS_USB_CHIPIDEA_OTG_H */
-- 
1.7.5.4

