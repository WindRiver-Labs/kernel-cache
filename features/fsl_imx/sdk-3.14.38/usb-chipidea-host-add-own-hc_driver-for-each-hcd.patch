From e412dfaba3ae7eee5b538ed27a8cd3616d02fa91 Mon Sep 17 00:00:00 2001
From: Limeng <Meng.Li@windriver.com>
Date: Fri, 29 Jan 2016 11:53:41 +0800
Subject: [PATCH 1575/1594] usb: chipidea: host: add own hc_driver for each
 hcd

There are several benefits for doing like this:

- hc_driver can be customized for each hcd
- Other hcd hc_driver's initialization will not affect current one.
We run out NULL pointer dereference problem when one hcd is started
by module_init, and the other is started by otg thread at SMP platform.
The reason for this problem is ehci_init_driver will do memory copy
for current uniform hc_driver, and this memory copy will do memset (as 0)
first, so when the first hcd is running usb_add_hcd, and the second
hcd may clear the uniform hc_driver's space (at ehci_init_driver),
then the first hcd will meet NULL pointer at the same time.

Detial core trace info as below:
ci_hdrc ci_hdrc.0: EHCI Host Controller
ci_hdrc ci_hdrc.0: new USB bus registered, assigned bus number 1
ci_hdrc ci_hdrc.1: doesn't support gadget
Unable to handle kernel NULL pointer dereference at virtual address 00000000
pgd = 80004000
[00000000] *pgd=00000000
In Online 00:00ternal e      Offline rror: Oops: 80000005 [#1] PREEMPT SMP ARM
Modules linked in:
CPU: 0 PID: 108 Comm: kworker/u8:2 Not tainted 3.14.38-02007-g24b2734-dirty #127
Workque Online 00:00ue: ci_o      Offline tg ci_otg_work
Online 00:00task: d8      Offline 39ec00 ti: d83ea000 task.ti: d83ea000
PC is at 0x0
LR is at usb_add_hcd+0x248/0x6e8
pc : [<00000000>]    lr : [<8040f644>]    psr: 60000113
sp : d83ebe60  ip : 00000000  fp : d8004400
r10: 00000001  r9 : 00000001  r8 : d85fd4b0
r7 : 00000000  r6 : 00000000  r5 : 00000000  r4 : d85fd400
r3 : 00000000  r2 : d85fd4f4  r1 : 80410178  r0 : d85fd400
Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
Control: 10c53c7d  Table: 1000404a  DAC: 00000015
Process kworker/u8:2 (pid: 108, stack limit = 0xd83ea238)
Stack: (0xd83ebe60 to 0xd83ec000)
be60: 00000000 80dd920c d8654e10 d85fd800 d803e010 d85fd400 00000000 00000000
be80: d8004400 00000000 d83ea008 80430e34 80430d14 d803e100 d803e010 d803e1ac
bea0: 00000000 80431dc8 80431d74 d803e100 00000001 80435858 80e130bc d803e100
bec0: 00000006 80435df8 00000000 d803e100 80e98ec8 804368e4 d803e010 d803e100
bee0: d86e8100 804322cc d86cf050 d803e1f4 d803e010 8042d79c 8042d758 d83cf900
bf00: d803e1f4 80042b78 00000000 00000003 00000001 00000001 800545e8 d83cf900
bf20: d8004400 d83cf918 d8004414 d83ea000 80e3f57b 00000089 d8004400 8004382c
bf40: d839ec00 00000000 d8393780 d83cf900 800436fc 00000000 00000000 00000000
bf60: 00000000 80048f50 80e019f4 00000000 0000264c d83cf900 00000000 00000000
bf80: d83ebf80 d83ebf80 00000000 00000000 d83ebf90 d83ebf90 d83ebfac d8393780
bfa0: 80048e84 00000000 00000000 8000e538 00000000 00000000 00000000 00000000
bfc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
bfe0: 00000000 00000000 00000000 00000000 00000013 00000000 ee66e85d 133ebd03
[<804 Online 00:000f644>]       Offline (usb_add_hcd) from [<80430e34>] (host_start+0x120/0x2e4)
[<80430e34>] (host_start) from [<80431dc8>] (ci_otg_start_host+0x54/0xbc)
[<80431dc8>] (ci_otg_start_host) from [<80435858>] (otg_set_protocol+0xa4/0xd0)
[<80435858>] (otg_set_protocol) from [<80435df8>] (otg_set_state+0x574/0xc58)
[<80435df8>] (otg_set_state) from [<804368e4>] (otg_statemachine+0x408/0x46c)
[<804368e4>] (otg_statemachine) from [<804322cc>] (ci_otg_fsm_work+0x3c/0x190)
[<804322cc>] (ci_otg_fsm_work) from [<8042d79c>] (ci_otg_work+0x44/0x1c4)
[<8042d79c>] (ci_otg_work) from [<80042b78>] (process_one_work+0xf4/0x35c)
[<80042b78>] (process_one_work) from [<8004382c>] (worker_thread+0x130/0x3bc)
[<8004382c>] (worker_thread) from [<80048f50>] (kthread+0xcc/0xe4)
[<80048f50>] (kthread) from [<8000e538>] (ret_from_fork+0x14/0x3c)
Code: bad PC value

Because in current kernel, file drivers/usb/chipidea/core.c and
drivers/usb/chipidea/host.c are quite different from the two ones in SDK kernel,
so I fix this issue manually. When fix this issue, I refer to commit
(cde81c01d8af) in SDK kernel.

Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/usb/chipidea/core.c |    1 -
 drivers/usb/chipidea/host.c |   30 +++++++++++++++++-------------
 drivers/usb/chipidea/host.h |    6 ------
 3 files changed, 17 insertions(+), 20 deletions(-)

diff --git a/drivers/usb/chipidea/core.c b/drivers/usb/chipidea/core.c
index e4b0807..0cfc565 100644
--- a/drivers/usb/chipidea/core.c
+++ b/drivers/usb/chipidea/core.c
@@ -1162,7 +1162,6 @@ static struct platform_driver ci_hdrc_driver = {
 
 static int __init ci_hdrc_platform_register(void)
 {
-	ci_hdrc_host_driver_init();
 	return platform_driver_register(&ci_hdrc_driver);
 }
 module_init(ci_hdrc_platform_register);
diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c
index ef80b9d..143e1b5 100644
--- a/drivers/usb/chipidea/host.c
+++ b/drivers/usb/chipidea/host.c
@@ -26,6 +26,8 @@
 #include <linux/usb/chipidea.h>
 #include <linux/regulator/consumer.h>
 #include <linux/imx_gpc.h>
+#include <linux/platform_device.h>
+
 
 #include "../host/ehci.h"
 
@@ -33,7 +35,8 @@
 #include "bits.h"
 #include "host.h"
 
-static struct hc_driver __read_mostly ci_ehci_hc_driver;
+#define MAX_CI_NUM	8
+static struct hc_driver __read_mostly ci_ehci_hc_driver[MAX_CI_NUM];
 static int (*orig_bus_suspend)(struct usb_hcd *hcd);
 static int (*orig_bus_resume)(struct usb_hcd *hcd);
 static int (*orig_hub_control)(struct usb_hcd *hcd,
@@ -257,11 +260,13 @@ static int host_start(struct ci_hdrc *ci)
 	struct ehci_hcd *ehci;
 	struct ehci_ci_priv *priv;
 	int ret;
+	struct platform_device *pdev = to_platform_device(ci->dev);
 
 	if (usb_disabled())
 		return -ENODEV;
 
-	hcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));
+	hcd = usb_create_hcd(&ci_ehci_hc_driver[pdev->id],
+					ci->dev, dev_name(ci->dev));
 	if (!hcd)
 		return -ENOMEM;
 
@@ -535,6 +540,8 @@ static int ci_ehci_bus_suspend(struct usb_hcd *hcd)
 int ci_hdrc_host_init(struct ci_hdrc *ci)
 {
 	struct ci_role_driver *rdrv;
+	struct platform_device *pdev = to_platform_device(ci->dev);
+	struct hc_driver *ci_ehci_driver = &ci_ehci_hc_driver[pdev->id];
 
 	if (!hw_read(ci, CAP_DCCPARAMS, DCCPARAMS_HC))
 		return -ENXIO;
@@ -551,21 +558,18 @@ int ci_hdrc_host_init(struct ci_hdrc *ci)
 	rdrv->name	= "host";
 	ci->roles[CI_ROLE_HOST] = rdrv;
 
-	orig_bus_resume = ci_ehci_hc_driver.bus_resume;
-	orig_hub_control = ci_ehci_hc_driver.hub_control;
+	ehci_init_driver(ci_ehci_driver, &ehci_ci_overrides);
+	orig_bus_suspend = ci_ehci_driver->bus_suspend;
+	orig_bus_resume = ci_ehci_driver->bus_resume;
+	orig_hub_control = ci_ehci_driver->hub_control;
 
+	ci_ehci_driver->bus_suspend = ci_ehci_bus_suspend;
 	if (ci->platdata->flags & CI_HDRC_IMX_EHCI_QUIRK) {
-		ci_ehci_hc_driver.bus_resume = ci_imx_ehci_bus_resume;
-		ci_ehci_hc_driver.hub_control = ci_imx_ehci_hub_control;
+		ci_ehci_driver->bus_resume = ci_imx_ehci_bus_resume;
+		ci_ehci_driver->hub_control = ci_imx_ehci_hub_control;
 	}
-	ci_ehci_hc_driver.start_port_reset = ci_start_port_reset;
+	ci_ehci_driver->start_port_reset = ci_start_port_reset;
 
 	return 0;
 }
 
-void ci_hdrc_host_driver_init(void)
-{
-	ehci_init_driver(&ci_ehci_hc_driver, &ehci_ci_overrides);
-	orig_bus_suspend = ci_ehci_hc_driver.bus_suspend;
-	ci_ehci_hc_driver.bus_suspend = ci_ehci_bus_suspend;
-}
diff --git a/drivers/usb/chipidea/host.h b/drivers/usb/chipidea/host.h
index 527c960..0b01b63 100644
--- a/drivers/usb/chipidea/host.h
+++ b/drivers/usb/chipidea/host.h
@@ -5,7 +5,6 @@
 
 int ci_hdrc_host_init(struct ci_hdrc *ci);
 void ci_hdrc_host_destroy(struct ci_hdrc *ci);
-void ci_hdrc_host_driver_init(void);
 bool ci_hdrc_host_has_device(struct ci_hdrc *ci);
 
 #else
@@ -20,11 +19,6 @@ static inline void ci_hdrc_host_destroy(struct ci_hdrc *ci)
 
 }
 
-static void ci_hdrc_host_driver_init(void)
-{
-
-}
-
 static inline bool ci_hdrc_host_has_device(struct ci_hdrc *ci)
 {
 	return false;
-- 
1.7.5.4

