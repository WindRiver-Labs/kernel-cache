From f14a4ceebaa8cf8cd28ba1481d8cc46cec1e2e52 Mon Sep 17 00:00:00 2001
From: Limeng <Meng.Li@windriver.com>
Date: Fri, 26 Feb 2016 17:30:09 +0800
Subject: [PATCH 1591/1594] arm: imx: gpc: change gpc_lock to raw spin lock

The gpc_lock is used to sync between A9 and M4. But the function
imx_gpc_irq_set_wake() maybe invoked in irq context. And the normal
spinlock will become sleepable in rt kernel and will trigger the following
call trace:
BUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:917
in_atomic(): 1, irqs_disabled(): 128, pid: 508, name: sh
Preemption disabled at:[<  (null)>]   (null)

CPU: 0 PID: 508 Comm: sh Not tainted 4.1.17-rt13-WR8.0.0.0_preempt-rt #1
Hardware name: Freescale i.MX6 Quad/DualLite (Device Tree)
[<80019814>] (unwind_backtrace) from [<80013ac8>] (show_stack+0x20/0x24)
[<80013ac8>] (show_stack) from [<809ba0bc>] (dump_stack+0x78/0x98)
[<809ba0bc>] (dump_stack) from [<8005df08>] (___might_sleep+0x184/0x1b8)
[<8005df08>] (___might_sleep) from [<809c0b70>] (rt_spin_lock+0x28/0x78)
[<809c0b70>] (rt_spin_lock) from [<80027248>] (imx_gpc_irq_set_wake+0x38/0x78)
[<80027248>] (imx_gpc_irq_set_wake) from [<80082870>] (set_irq_wake_real+0x40/0x54)
[<80082870>] (set_irq_wake_real) from [<80082cac>] (irq_set_irq_wake+0x6c/0xfc)
[<80082cac>] (irq_set_irq_wake) from [<80455a80>] (gpio_set_wake_irq+0x3c/0x44)
[<80455a80>] (gpio_set_wake_irq) from [<80082870>] (set_irq_wake_real+0x40/0x54)
[<80082870>] (set_irq_wake_real) from [<80082cac>] (irq_set_irq_wake+0x6c/0xfc)
[<80082cac>] (irq_set_irq_wake) from [<806331a8>] (gpio_keys_suspend+0x64/0xa4)
[<806331a8>] (gpio_keys_suspend) from [<805242a8>] (platform_pm_suspend+0x44/0x64)
[<805242a8>] (platform_pm_suspend) from [<8052cf70>] (dpm_run_callback+0xc4/0x204)
[<8052cf70>] (dpm_run_callback) from [<8052da5c>] (__device_suspend+0x1f4/0x2c0)
[<8052da5c>] (__device_suspend) from [<8052f860>] (dpm_suspend+0x15c/0x390)
[<8052f860>] (dpm_suspend) from [<80530040>] (dpm_suspend_start+0x6c/0x74)
[<80530040>] (dpm_suspend_start) from [<8007d49c>] (suspend_devices_and_enter+0x7c/0x8a4)
[<8007d49c>] (suspend_devices_and_enter) from [<8007e284>] (pm_suspend+0x5c0/0x63c)
[<8007e284>] (pm_suspend) from [<8007c408>] (state_store+0xb8/0xcc)
[<8007c408>] (state_store) from [<8041f700>] (kobj_attr_store+0x1c/0x28)
[<8041f700>] (kobj_attr_store) from [<801c8104>] (sysfs_kf_write+0x48/0x54)
[<801c8104>] (sysfs_kf_write) from [<801c75f4>] (kernfs_fop_write+0x128/0x188)
[<801c75f4>] (kernfs_fop_write) from [<8015e4cc>] (__vfs_write+0x28/0x48)
[<8015e4cc>] (__vfs_write) from [<8015ebd8>] (vfs_write+0xbc/0x144)
[<8015ebd8>] (vfs_write) from [<8015f33c>] (SyS_write+0x58/0x98)
[<8015f33c>] (SyS_write) from [<8000f420>] (ret_fast_syscall+0x0/0x3c)

Change the gpc_lock to raw spin lock to fix this issue.

Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm/mach-imx/gpc.c |   14 +++++++-------
 1 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 022a30a..302900e 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -89,7 +89,7 @@ static u32 gpc_wake_irqs[IMR_NUM];
 static u32 gpc_saved_imrs[IMR_NUM];
 static u32 gpc_mf_request_on[IMR_NUM];
 static u32 bypass;
-static DEFINE_SPINLOCK(gpc_lock);
+static DEFINE_RAW_SPINLOCK(gpc_lock);
 static struct notifier_block nb_pcie;
 static struct pu_domain imx6q_pu_domain;
 static bool pu_on;	/* keep always on i.mx6qp */
@@ -107,10 +107,10 @@ void imx_gpc_add_m4_wake_up_irq(u32 irq, bool enable)
 		return;
 
 	mask = 1 << irq % 32;
-	spin_lock_irqsave(&gpc_lock, flags);
+	raw_spin_lock_irqsave(&gpc_lock, flags);
 	gpc_wake_irqs[idx] = enable ? gpc_wake_irqs[idx] | mask :
 		gpc_wake_irqs[idx] & ~mask;
-	spin_unlock_irqrestore(&gpc_lock, flags);
+	raw_spin_unlock_irqrestore(&gpc_lock, flags);
 }
 
 void imx_gpc_hold_m4_in_sleep(void)
@@ -256,10 +256,10 @@ static int imx_gpc_irq_set_wake(struct irq_data *d, unsigned int on)
 	u32 mask;
 
 	mask = 1 << d->hwirq % 32;
-	spin_lock_irqsave(&gpc_lock, flags);
+	raw_spin_lock_irqsave(&gpc_lock, flags);
 	gpc_wake_irqs[idx] = on ? gpc_wake_irqs[idx] | mask :
 				  gpc_wake_irqs[idx] & ~mask;
-	spin_unlock_irqrestore(&gpc_lock, flags);
+	raw_spin_unlock_irqrestore(&gpc_lock, flags);
 
 	/*
 	 * Do *not* call into the parent, as the GIC doesn't have any
@@ -418,10 +418,10 @@ int imx_gpc_mf_power_on(unsigned int irq, unsigned int on)
 	u32 mask;
 
 	mask = 1 << (irq % 32);
-	spin_lock_irqsave(&gpc_lock, flags);
+	raw_spin_lock_irqsave(&gpc_lock, flags);
 	gpc_mf_request_on[idx] = on ? gpc_mf_request_on[idx] | mask :
 				  gpc_mf_request_on[idx] & ~mask;
-	spin_unlock_irqrestore(&gpc_lock, flags);
+	raw_spin_unlock_irqrestore(&gpc_lock, flags);
 
 	return 0;
 }
-- 
1.7.5.4

