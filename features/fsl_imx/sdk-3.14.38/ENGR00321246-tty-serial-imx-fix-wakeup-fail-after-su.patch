From fc7b77fa387a3056031f10bcdab25608623e035c Mon Sep 17 00:00:00 2001
From: Fugang Duan <b38611@freescale.com>
Date: Thu, 3 Jul 2014 14:03:27 +0800
Subject: [PATCH 0109/1594] ENGR00321246 tty: serial: imx: fix wakeup fail
 after suspend for more than 30s

commit 90ad75d5b42b28d797e533d941ac0873b8d33b40 from
git://git.freescale.com/imx/linux-2.6-imx.git

Before DMA finish, we have to disable flow control, otherwise
there have one corner issue like:
Flow control enable, RTS always is high while there have no uart
terminal connect to imx uart, and then user transmit data by the
uart, after some time, TX FIFO is _FULL_, SDMA still don't complete
the current transcation, so hold on. There no SDMA interrupt generate,
the "dma_wait" event cannot be waked up.

(cherry picked from commit a614a7d01705e1db69956913c810b62bc7f0c83e)

Signed-off-by: Fugang Duan <B38611@freescale.com>
---
 drivers/tty/serial/imx.c |   20 ++++++++++++++++++--
 1 files changed, 18 insertions(+), 2 deletions(-)

diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
index 099a417..87df975 100644
--- a/drivers/tty/serial/imx.c
+++ b/drivers/tty/serial/imx.c
@@ -1180,9 +1180,25 @@ static void imx_shutdown(struct uart_port *port)
 	if (sport->dma_is_enabled) {
 		int ret;
 
+		/*
+		 * Before DMA finish, we have to disable flow control, otherwise
+		 * there have one corner issue like:
+		 * Flow control enable, RTS always is high while there have no uart
+		 * terminal connect to imx uart, and then user transmit data by the
+		 * uart, after some time, TX FIFO is _FULL_, SDMA still don't complete
+		 * the current transcation, so hold on. There no SDMA interrupt generate,
+		 * the "dma_wait" event cannot be waked up.
+		 */
+		 if (sport->have_rtscts) {
+			temp = readl(sport->port.membase + UCR2) & ~UCR2_CTSC;
+			temp |= UCR2_CTS;
+			writel(temp, sport->port.membase + UCR2);
+		}
+
 		/* We have to wait for the DMA to finish. */
-		ret = wait_event_interruptible(sport->dma_wait,
-			!sport->dma_is_rxing && !sport->dma_is_txing);
+		ret = wait_event_interruptible_timeout(sport->dma_wait,
+			!sport->dma_is_rxing && !sport->dma_is_txing,
+			msecs_to_jiffies(1));
 		if (ret != 0) {
 			sport->dma_is_rxing = 0;
 			sport->dma_is_txing = 0;
-- 
1.7.5.4

