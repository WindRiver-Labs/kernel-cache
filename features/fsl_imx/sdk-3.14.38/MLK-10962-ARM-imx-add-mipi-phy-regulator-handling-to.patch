From 34b7258f02eeda5c5c103cd360636a4c20674bf0 Mon Sep 17 00:00:00 2001
From: Fancy Fang <chen.fang@freescale.com>
Date: Fri, 22 May 2015 16:29:18 +0800
Subject: [PATCH 0613/1594] MLK-10962 ARM: imx: add mipi phy regulator
 handling to gpcv2.

commit 13efae98a44713f8dbd142b24be818f1e5e2c7a9 from
git://git.freescale.com/imx/linux-2.6-imx.git

Add mipi phy regulator notify callback to power on
or power off this phy along with the regulator
enable/disable called. This will be used by mipi
dsi/csi later.

Signed-off-by: Fancy Fang <chen.fang@freescale.com>
---
 arch/arm/boot/dts/imx7d.dtsi |    1 +
 arch/arm/mach-imx/gpcv2.c    |  238 +++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 237 insertions(+), 2 deletions(-)

diff --git a/arch/arm/boot/dts/imx7d.dtsi b/arch/arm/boot/dts/imx7d.dtsi
index d3d0742..bbf8a17 100644
--- a/arch/arm/boot/dts/imx7d.dtsi
+++ b/arch/arm/boot/dts/imx7d.dtsi
@@ -646,6 +646,7 @@
 				fsl,mf-mix-wakeup-irq = <0x54010000 0xc00 0x0 0x1000040>;
 				#power-domain-cells = <1>;
 				pcie-phy-supply = <&reg_1p0d>;
+				mipi-phy-supply = <&reg_1p0d>;
 			};
 		};
 
diff --git a/arch/arm/mach-imx/gpcv2.c b/arch/arm/mach-imx/gpcv2.c
index c620f23..f876c71 100644
--- a/arch/arm/mach-imx/gpcv2.c
+++ b/arch/arm/mach-imx/gpcv2.c
@@ -20,10 +20,13 @@
 #include <linux/pm_domain.h>
 #include <linux/regulator/consumer.h>
 #include <linux/irqchip/arm-gic.h>
+#include <linux/syscore_ops.h>
+#include <linux/slab.h>
 #include "common.h"
 #include "hardware.h"
 
 #define IMR_NUM			4
+#define GPC_MAX_IRQS            (IMR_NUM * 32)
 #define GPC_LPCR_A7_BSC		0x0
 #define GPC_LPCR_A7_AD		0x4
 #define GPC_LPCR_M4		0x8
@@ -100,13 +103,77 @@ enum imx_gpc_slot {
 	CORE0_M4,
 };
 
+struct gpcv2_irqchip_data {
+	struct raw_spinlock     rlock;
+	void __iomem            *gpc_base;
+	u32                     wakeup_sources[IMR_NUM];
+	u32                     saved_irq_mask[IMR_NUM];
+	u32                     cpu2wakeup;
+};
+
+static struct gpcv2_irqchip_data *imx_gpcv2_instance;
+
 static void __iomem *gpc_base;
 static u32 gpcv2_wake_irqs[IMR_NUM];
 static u32 gpcv2_saved_imrs[IMR_NUM];
 static u32 gpcv2_mf_irqs[IMR_NUM];
 static u32 gpcv2_mf_request_on[IMR_NUM];
 static DEFINE_SPINLOCK(gpcv2_lock);
-static struct notifier_block nb_pcie;
+static struct notifier_block nb_pcie, nb_mipi;
+
+/*
+ * Interface for the low level wakeup code.
+ */
+u32 imx_gpcv2_get_wakeup_source(u32 **sources)
+{
+       if (!imx_gpcv2_instance)
+               return 0;
+
+       if (sources)
+               *sources = imx_gpcv2_instance->wakeup_sources;
+
+       return IMR_NUM;
+}
+
+static int gpcv2_wakeup_source_save(void)
+{
+       struct gpcv2_irqchip_data *cd;
+       void __iomem *reg;
+       int i;
+
+       cd = imx_gpcv2_instance;
+       if (!cd)
+               return 0;
+
+       for (i = 0; i < IMR_NUM; i++) {
+               reg = cd->gpc_base + cd->cpu2wakeup + i * 4;
+               cd->saved_irq_mask[i] = readl_relaxed(reg);
+               writel_relaxed(cd->wakeup_sources[i], reg);
+       }
+
+       return 0;
+}
+
+static void gpcv2_wakeup_source_restore(void)
+{
+       struct gpcv2_irqchip_data *cd;
+       void __iomem *reg;
+       int i;
+
+       cd = imx_gpcv2_instance;
+       if (!cd)
+               return;
+
+       for (i = 0; i < IMR_NUM; i++) {
+               reg = cd->gpc_base + cd->cpu2wakeup + i * 4;
+               writel_relaxed(cd->saved_irq_mask[i], reg);
+       }
+}
+
+static struct syscore_ops imx_gpcv2_syscore_ops = {
+       .suspend        = gpcv2_wakeup_source_save,
+       .resume         = gpcv2_wakeup_source_restore,
+};
 
 void imx_gpcv2_set_slot_ack(u32 index, enum imx_gpc_slot m_core,
 				bool mode, bool ack)
@@ -535,20 +602,167 @@ static int imx_pcie_regulator_notify(struct notifier_block *nb,
 	return NOTIFY_OK;
 }
 
+static int imx_mipi_regulator_notify(struct notifier_block *nb,
+					unsigned long event,
+					void *ignored)
+{
+	u32 val = 0;
+
+	switch (event) {
+	case REGULATOR_EVENT_PRE_ENABLE:
+		val = readl_relaxed(gpc_base + GPC_PGC_CPU_MAPPING);
+		writel_relaxed(val | BIT(2), gpc_base + GPC_PGC_CPU_MAPPING);
+
+		val = readl_relaxed(gpc_base + GPC_PU_PGC_SW_PUP_REQ);
+		writel_relaxed(val | BIT(0), gpc_base + GPC_PU_PGC_SW_PUP_REQ);
+		break;
+	case REGULATOR_EVENT_PRE_DISABLE:
+		val = readl_relaxed(gpc_base + GPC_PU_PGC_SW_PDN_REQ);
+		writel_relaxed(val | BIT(0), gpc_base + GPC_PU_PGC_SW_PDN_REQ);
+
+		val = readl_relaxed(gpc_base + GPC_PGC_MIPI_PHY);
+		writel_relaxed(val | BIT(0), gpc_base + GPC_PGC_MIPI_PHY);
+
+		val = readl_relaxed(gpc_base + GPC_PGC_CPU_MAPPING);
+		writel_relaxed(val & ~BIT(2), gpc_base + GPC_PGC_CPU_MAPPING);
+		break;
+	default:
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct irq_chip gpcv2_irqchip_data_chip = {
+       .name                   = "GPCv2",
+       .irq_eoi                = irq_chip_eoi_parent,
+       .irq_mask               = imx_gpcv2_irq_mask,
+       .irq_unmask             = imx_gpcv2_irq_unmask,
+       .irq_set_wake           = imx_gpcv2_irq_set_wake,
+       .irq_retrigger          = irq_chip_retrigger_hierarchy,
+#ifdef CONFIG_SMP
+       .irq_set_affinity       = irq_chip_set_affinity_parent,
+#endif
+};
+
+static int imx_gpcv2_domain_xlate(struct irq_domain *domain,
+                               struct device_node *controller,
+                               const u32 *intspec,
+                               unsigned int intsize,
+                               unsigned long *out_hwirq,
+                               unsigned int *out_type)
+{
+       /* Shouldn't happen, really... */
+       if (domain->of_node != controller)
+               return -EINVAL;
+
+       /* Not GIC compliant */
+       if (intsize != 3)
+               return -EINVAL;
+
+       /* No PPI should point to this domain */
+       if (intspec[0] != 0)
+               return -EINVAL;
+
+       *out_hwirq = intspec[1];
+       *out_type = intspec[2];
+       return 0;
+}
+
+static int imx_gpcv2_domain_alloc(struct irq_domain *domain,
+                                 unsigned int irq, unsigned int nr_irqs,
+                                 void *data)
+{
+       struct of_phandle_args *args = data;
+       struct of_phandle_args parent_args;
+       irq_hw_number_t hwirq;
+       int i;
+
+       /* Not GIC compliant */
+       if (args->args_count != 3)
+               return -EINVAL;
+
+       /* No PPI should point to this domain */
+       if (args->args[0] != 0)
+               return -EINVAL;
+
+       /* Can't deal with this */
+       hwirq = args->args[1];
+       if (hwirq >= GPC_MAX_IRQS)
+               return -EINVAL;
+
+       for (i = 0; i < nr_irqs; i++) {
+               irq_domain_set_hwirq_and_chip(domain, irq + i, hwirq + i,
+                               &gpcv2_irqchip_data_chip, domain->host_data);
+       }
+
+       parent_args = *args;
+       parent_args.np = domain->parent->of_node;
+       return irq_domain_alloc_irqs_parent(domain, irq, nr_irqs, &parent_args);
+}
+
+static struct irq_domain_ops gpcv2_irqchip_data_domain_ops = {
+       .xlate  = imx_gpcv2_domain_xlate,
+       .alloc  = imx_gpcv2_domain_alloc,
+       .free   = irq_domain_free_irqs_common,
+};
+
 void __init imx_gpcv2_init(void)
 {
 	struct device_node *np;
 	int i, val;
+	struct irq_domain *parent_domain, *domain;
+	struct gpcv2_irqchip_data *cd;
+	struct device_node *np_parent;
 
 	np = of_find_compatible_node(NULL, NULL, "fsl,imx7d-gpc");
 	gpc_base = of_iomap(np, 0);
 	WARN_ON(!gpc_base);
+	np_parent = of_get_parent(np);
+	if (!np_parent) {
+	       pr_err("%s: no parent, giving up\n", np->full_name);
+	       return;
+	}
+	
+	parent_domain = irq_find_host(np_parent);
+	if (!parent_domain) {
+		pr_err("%s: unable to get parent domain\n", np->full_name);
+		of_node_put(np_parent);
+		return;
+	}
+
+	cd = kzalloc(sizeof(struct gpcv2_irqchip_data), GFP_KERNEL);
+	if (!cd) {
+		pr_err("kzalloc failed!\n");
+		of_node_put(np_parent);
+		return;
+	}
 
+	cd->gpc_base = of_iomap(np, 0);
+	if (!cd->gpc_base) {
+		pr_err("fsl-gpcv2: unable to map gpc registers\n");
+		kfree(cd);
+		of_node_put(np_parent);
+		return;
+	}
+
+	domain = irq_domain_add_hierarchy(parent_domain, 0, GPC_MAX_IRQS,
+					np, &gpcv2_irqchip_data_domain_ops, cd);
+	if (!domain) {
+		iounmap(cd->gpc_base);
+		kfree(cd);
+		of_node_put(np_parent);
+		return;
+	}
+	irq_set_default_host(domain);
+	
 	/* Initially mask all interrupts */
 	for (i = 0; i < IMR_NUM; i++) {
 		writel_relaxed(~0, gpc_base + GPC_IMR1_CORE0 + i * 4);
 		writel_relaxed(~0, gpc_base + GPC_IMR1_CORE1 + i * 4);
+		cd->wakeup_sources[i] = ~0;
 	}
+	cd->cpu2wakeup = GPC_IMR1_CORE0;
 	/*
 	 * Due to hardware design requirement, need to make sure GPR
 	 * interrupt(#32) is unmasked during RUN mode to avoid entering
@@ -598,12 +812,17 @@ void __init imx_gpcv2_init(void)
 	val = readl_relaxed(gpc_base + GPC_MLPCR);
 	val |= BM_GPC_MLPCR_MEMLP_CTL_DIS;
 	writel_relaxed(val, gpc_base + GPC_MLPCR);
+
+	imx_gpcv2_instance = cd;
+	register_syscore_ops(&imx_gpcv2_syscore_ops);
+	
+	of_node_put(np_parent);
 }
 
 static int imx_gpcv2_probe(struct platform_device *pdev)
 {
 	int ret;
-	struct regulator *pcie_reg;
+	struct regulator *pcie_reg, *mipi_reg;
 
 	if (cpu_is_imx7d()) {
 		pcie_reg = devm_regulator_get(&pdev->dev, "pcie-phy");
@@ -620,6 +839,21 @@ static int imx_gpcv2_probe(struct platform_device *pdev)
 				"pcie regulator notifier request failed\n");
 			return ret;
 		}
+
+		mipi_reg = devm_regulator_get(&pdev->dev, "mipi-phy");
+		if (IS_ERR(mipi_reg)) {
+			ret = PTR_ERR(mipi_reg);
+			dev_info(&pdev->dev, "mipi regulator not ready.\n");
+			return ret;
+		}
+		nb_mipi.notifier_call = &imx_mipi_regulator_notify;
+
+		ret = regulator_register_notifier(mipi_reg, &nb_mipi);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"mipi regulator notifier request failed.\n");
+			return ret;
+		}
 	}
 	return 0;
 }
-- 
1.7.5.4

