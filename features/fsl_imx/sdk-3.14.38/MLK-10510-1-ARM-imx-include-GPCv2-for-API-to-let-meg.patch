From 1ea9e55698c429ace7970c95cba8b2e30b9e39ba Mon Sep 17 00:00:00 2001
From: Anson Huang <b20788@freescale.com>
Date: Thu, 26 Mar 2015 10:46:51 +0800
Subject: [PATCH 0479/1594] MLK-10510-1 ARM: imx: include GPCv2 for API to let
 mega/fast mix always on

commit 99c7319cea43d19dd4bb2e0e39ac752c7bea420c from
git://git.freescale.com/imx/linux-2.6-imx.git

Some drivers have special requirement that Mega/Fast MIX can NOT be off in DSM
and it can NOT be done by wakeup irq enabled, there is already an API to achieve
this which is only for GPCv1, this patch enhance the API to cover GPCv2.

Acked-by: Peter Chen <peter.chen@freescale.com>
Signed-off-by: Anson Huang <b20788@freescale.com>
Signed-off-by: Li Jun <jun.li@freescale.com>
---
 arch/arm/mach-imx/common.h |    2 ++
 arch/arm/mach-imx/gpc.c    |   12 +++++++++++-
 arch/arm/mach-imx/gpcv2.c  |   19 ++++++++++++++++++-
 3 files changed, 31 insertions(+), 2 deletions(-)

diff --git a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h
index c1fc037..19ef7f3 100644
--- a/arch/arm/mach-imx/common.h
+++ b/arch/arm/mach-imx/common.h
@@ -81,6 +81,8 @@ unsigned int imx_gpc_is_m4_sleeping(void);
 bool imx_mu_is_m4_in_low_freq(void);
 void imx_gpcv2_set_core1_pdn_pup_by_software(bool pdn);
 unsigned int imx_gpcv2_is_mf_mix_off(void);
+int imx_gpc_mf_power_on(unsigned int irq, unsigned int on);
+int imx_gpcv2_mf_power_on(unsigned int irq, unsigned int on);
 void imx6_enable_rbc(bool enable);
 void imx_gpc_check_dt(void);
 void imx_gpc_set_arm_power_in_lpm(bool power_off);
diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index d7c8a38..aa64190 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -381,7 +381,7 @@ static int imx_pcie_regulator_notify(struct notifier_block *nb,
 	return NOTIFY_OK;
 }
 
-int imx_gpc_mf_request_on(unsigned int irq, unsigned int on)
+int imx_gpc_mf_power_on(unsigned int irq, unsigned int on)
 {
 	unsigned int idx = irq / 32 - 1;
 	unsigned long flags;
@@ -395,6 +395,16 @@ int imx_gpc_mf_request_on(unsigned int irq, unsigned int on)
 
 	return 0;
 }
+
+int imx_gpc_mf_request_on(unsigned int irq, unsigned int on)
+{
+	if (cpu_is_imx6sx())
+		return imx_gpc_mf_power_on(irq, on);
+	else if (cpu_is_imx7d())
+		return imx_gpcv2_mf_power_on(irq, on);
+	else
+		return 0;
+}
 EXPORT_SYMBOL_GPL(imx_gpc_mf_request_on);
 
 static int __init imx_gpc_init(struct device_node *node,
diff --git a/arch/arm/mach-imx/gpcv2.c b/arch/arm/mach-imx/gpcv2.c
index 1c2aefc..de627fc 100644
--- a/arch/arm/mach-imx/gpcv2.c
+++ b/arch/arm/mach-imx/gpcv2.c
@@ -100,6 +100,7 @@ static void __iomem *gpc_base;
 static u32 gpcv2_wake_irqs[IMR_NUM];
 static u32 gpcv2_saved_imrs[IMR_NUM];
 static u32 gpcv2_mf_irqs[IMR_NUM];
+static u32 gpcv2_mf_request_on[IMR_NUM];
 static DEFINE_SPINLOCK(gpcv2_lock);
 static struct notifier_block nb_pcie;
 
@@ -315,7 +316,8 @@ static void imx_gpcv2_mf_mix_off(void)
 	int i;
 
 	for (i = 0; i < IMR_NUM; i++)
-		if ((gpcv2_wake_irqs[i] & gpcv2_mf_irqs[i]) != 0)
+		if (((gpcv2_wake_irqs[i] | gpcv2_mf_request_on[i]) &
+						gpcv2_mf_irqs[i]) != 0)
 			return;
 
 	pr_info("Turn off Mega/Fast mix in DSM\n");
@@ -323,6 +325,21 @@ static void imx_gpcv2_mf_mix_off(void)
 	imx_gpcv2_set_m_core_pgc(true, GPC_PGC_FM);
 }
 
+int imx_gpcv2_mf_power_on(unsigned int irq, unsigned int on)
+{
+	unsigned int idx = irq / 32 - 1;
+	unsigned long flags;
+	u32 mask;
+
+	mask = 1 << (irq % 32);
+	spin_lock_irqsave(&gpcv2_lock, flags);
+	gpcv2_mf_request_on[idx] = on ? gpcv2_mf_request_on[idx] | mask :
+				  gpcv2_mf_request_on[idx] & ~mask;
+	spin_unlock_irqrestore(&gpcv2_lock, flags);
+
+	return 0;
+}
+
 void imx_gpcv2_pre_suspend(bool arm_power_off)
 {
 	void __iomem *reg_imr1 = gpc_base + GPC_IMR1_CORE0;
-- 
1.7.5.4

