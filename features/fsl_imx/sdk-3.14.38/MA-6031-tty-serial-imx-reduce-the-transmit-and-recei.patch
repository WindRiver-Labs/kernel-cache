From 88b7cfd00bfed49fe4c4cee30e9036f89308a17e Mon Sep 17 00:00:00 2001
From: Fugang Duan <b38611@freescale.com>
Date: Tue, 30 Dec 2014 15:02:58 +0800
Subject: [PATCH 0129/1594] MA-6031 tty: serial: imx: reduce the transmit and
 receive latency

commit 15e3a53b678ebcd39322022a5b962afae5248582 from
git://git.freescale.com/imx/linux-2.6-imx.git

Current driver use work queue for tx and rx dma task, which bring some schdule
latency. Remove the work queue since the work task don't cost much cpu loading.

Signed-off-by: Fugang Duan <B38611@freescale.com>
---
 drivers/tty/serial/imx.c |   24 ++++--------------------
 1 files changed, 4 insertions(+), 20 deletions(-)

diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
index 3d16aed..a08be0a 100644
--- a/drivers/tty/serial/imx.c
+++ b/drivers/tty/serial/imx.c
@@ -234,8 +234,6 @@ struct imx_port {
 	struct imx_dma_rxbuf	rx_buf;
 	unsigned int		tx_bytes;
 	unsigned int		dma_tx_nents;
-	struct delayed_work	tsk_dma_tx;
-	struct work_struct	tsk_dma_rx;
 	wait_queue_head_t	dma_wait;
 	unsigned int            saved_reg[11];
 #define DMA_TX_IS_WORKING 1
@@ -526,8 +524,6 @@ static void dma_tx_callback(void *data)
 	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
 		uart_write_wakeup(&sport->port);
 
-	schedule_delayed_work(&sport->tsk_dma_tx, msecs_to_jiffies(1));
-
 	if (waitqueue_active(&sport->dma_wait)) {
 		wake_up(&sport->dma_wait);
 		dev_dbg(sport->port.dev, "exit in %s.\n", __func__);
@@ -540,17 +536,14 @@ static void dma_tx_callback(void *data)
 	spin_unlock_irqrestore(&sport->port.lock, flags);
 }
 
-static void dma_tx_work(struct work_struct *w)
+static void imx_dma_tx(struct imx_port *sport)
 {
-	struct delayed_work *delay_work = to_delayed_work(w);
-	struct imx_port *sport = container_of(delay_work, struct imx_port, tsk_dma_tx);
 	struct circ_buf *xmit = &sport->port.state->xmit;
 	struct scatterlist *sgl = sport->tx_sgl;
 	struct dma_async_tx_descriptor *desc;
 	struct dma_chan	*chan = sport->dma_chan_tx;
 	struct device *dev = sport->port.dev;
 	unsigned long temp;
-	unsigned long flags;
 	int ret;
 
 	if (sport->dma_is_txing)
@@ -559,7 +552,6 @@ static void dma_tx_work(struct work_struct *w)
 	if (test_and_set_bit(DMA_TX_IS_WORKING, &sport->flags))
 		return;
 
-	spin_lock_irqsave(&sport->port.lock, flags);
 	sport->tx_bytes = uart_circ_chars_pending(xmit);
 
 	if (sport->tx_bytes > 0) {
@@ -573,7 +565,6 @@ static void dma_tx_work(struct work_struct *w)
 					UART_XMIT_SIZE - xmit->tail);
 			sg_set_buf(sgl + 1, xmit->buf, xmit->head);
 		}
-		spin_unlock_irqrestore(&sport->port.lock, flags);
 
 		ret = dma_map_sg(dev, sgl, sport->dma_tx_nents, DMA_TO_DEVICE);
 		if (ret == 0) {
@@ -606,7 +597,6 @@ static void dma_tx_work(struct work_struct *w)
 		return;
 	}
 
-	spin_unlock_irqrestore(&sport->port.lock, flags);
 err_out:
 	clear_bit(DMA_TX_IS_WORKING, &sport->flags);
 	smp_mb__after_clear_bit();
@@ -652,7 +642,7 @@ static void imx_start_tx(struct uart_port *port)
 
 		if (!uart_circ_empty(&port->state->xmit) &&
 		    !uart_tx_stopped(port))
-			schedule_delayed_work(&sport->tsk_dma_tx, 0);
+			imx_dma_tx(sport);
 		return;
 	}
 }
@@ -918,9 +908,8 @@ static void dma_rx_push_data(struct imx_port *sport, struct tty_struct *tty,
 	spin_unlock_irqrestore(&sport->port.lock, flags);
 }
 
-static void dma_rx_work(struct work_struct *w)
+static void dma_rx_work(struct imx_port *sport)
 {
-	struct imx_port *sport = container_of(w, struct imx_port, tsk_dma_rx);
 	struct tty_struct *tty = sport->port.state->port.tty;
 	unsigned int cur_idx = sport->rx_buf.cur_idx;
 
@@ -994,7 +983,7 @@ static void dma_rx_callback(void *data)
 		dev_err(sport->port.dev, "overwrite!\n");
 
 	if (count)
-		schedule_work(&sport->tsk_dma_rx);
+		dma_rx_work(sport);
 }
 
 static int start_rx_dma(struct imx_port *sport)
@@ -1197,11 +1186,6 @@ static int imx_startup(struct uart_port *port)
 		&& !sport->dma_is_inited)
 		imx_uart_dma_init(sport);
 
-	if (sport->dma_is_inited) {
-		INIT_DELAYED_WORK(&sport->tsk_dma_tx, dma_tx_work);
-		INIT_WORK(&sport->tsk_dma_rx, dma_rx_work);
-	}
-
 	spin_lock_irqsave(&sport->port.lock, flags);
 
 	/*
-- 
1.7.5.4

