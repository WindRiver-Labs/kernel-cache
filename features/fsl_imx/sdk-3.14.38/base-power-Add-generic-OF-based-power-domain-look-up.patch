From f128b8681a53b78d1f0786ee66cf430807a0d7e0 Mon Sep 17 00:00:00 2001
From: Tomasz Figa <t.figa@samsung.com>
Date: Thu, 8 May 2014 14:49:13 +0200
Subject: [PATCH 0025/1594] base: power: Add generic OF-based power domain
 look-up

commit 47b16538fa1d10cb7ddf16129493bae9fb87cad5 from
git://git.freescale.com/imx/linux-2.6-imx.git

This patch introduces generic code to perform power domain look-up using
device tree and automatically bind devices to their power domains.
Generic device tree binding is introduced to specify power domains of
devices in their device tree nodes.

Backwards compatibility with legacy Samsung-specific power domain
bindings is provided, but for now the new code is not compiled when
CONFIG_ARCH_EXYNOS is selected to avoid collision with legacy code. This
will change as soon as Exynos power domain code gets converted to use
the generic framework in further patch.

Signed-off-by: Tomasz Figa <t.figa@samsung.com>
Reviewed-by: Mark Brown <broonie@linaro.org>
Reviewed-by: Kevin Hilman <khilman@linaro.org>
Reviewed-by: Philipp Zabel <philipp.zabel@gmail.com>
[on i.MX6 GK802]
Tested-by: Philipp Zabel <philipp.zabel@gmail.com>
Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
[shawn.guo: http://thread.gmane.org/gmane.linux.kernel.samsung-soc/31029]
Signed-off-by: Shawn Guo <shawn.guo@freescale.com>
---
 drivers/base/power/domain.c |  112 +++++++++++++++++++++++++++++++++++++++++++
 include/linux/pm_domain.h   |   12 +++++
 kernel/power/Kconfig        |    2 +-
 3 files changed, 125 insertions(+), 1 deletions(-)

diff --git a/drivers/base/power/domain.c b/drivers/base/power/domain.c
index 2327613..d231c26 100644
--- a/drivers/base/power/domain.c
+++ b/drivers/base/power/domain.c
@@ -2110,6 +2110,118 @@ struct generic_pm_domain *of_genpd_get_from_provider(
 }
 EXPORT_SYMBOL_GPL(of_genpd_get_from_provider);
 
+/*
+ * Device<->domain binding using Device Tree look-up.
+ *
+ * The purpose of code below is to manage assignment of devices to their
+ * power domains in an automatic fashion, based on data read from device tree.
+ * The two functions, genpd_bind_domain() and genpd_unbind_domain() are
+ * intended to be called by higher level code that manages devices, i.e.
+ * really_probe() and __device_release_driver() to respectively bind and
+ * unbind device from its power domain.
+ *
+ * Both generic and legacy Samsung-specific DT bindings are supported to
+ * keep backwards compatibility with existing DTBs.
+ */
+
+/**
+ * genpd_bind_domain - Bind device to its power domain using Device Tree.
+ * @dev: Device to bind to its power domain.
+ *
+ * Tries to parse power domain specifier from device's OF node and if succeeds
+ * attaches the device to retrieved power domain.
+ *
+ * Returns 0 on success or negative error code otherwise.
+ */
+int genpd_bind_domain(struct device *dev)
+{
+	struct of_phandle_args pd_args;
+	struct generic_pm_domain *pd;
+	int ret;
+
+	if (!dev->of_node)
+		return 0;
+
+	ret = of_parse_phandle_with_args(dev->of_node, "power-domains",
+					"#power-domain-cells", 0, &pd_args);
+	if (ret < 0) {
+		if (ret != -ENOENT)
+			return ret;
+
+		/*
+		 * Try legacy Samsung-specific bindings
+		 * (for backwards compatibility of DT ABI)
+		 */
+		pd_args.args_count = 0;
+		pd_args.np = of_parse_phandle(dev->of_node,
+						"samsung,power-domain", 0);
+		if (!pd_args.np)
+			return 0;
+	}
+
+	pd = of_genpd_get_from_provider(&pd_args);
+	if (IS_ERR(pd)) {
+		if (PTR_ERR(pd) != -EPROBE_DEFER)
+			dev_err(dev, "failed to find power domain: %ld\n",
+				PTR_ERR(pd));
+		return PTR_ERR(pd);
+	}
+
+	dev_dbg(dev, "adding to power domain %s\n", pd->name);
+
+	while (1) {
+		ret = pm_genpd_add_device(pd, dev);
+		if (ret != -EAGAIN)
+			break;
+		cond_resched();
+	}
+
+	if (ret < 0) {
+		dev_err(dev, "failed to add to power domain %s: %d",
+			pd->name, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * genpd_unbind_domain - Unbind device from its power domain.
+ * @dev: Device to unbind from its power domain.
+ *
+ * Unbinds device from power domain previously bound to it.
+ *
+ * Returns 0 on success or negative error code otherwise.
+ */
+int genpd_unbind_domain(struct device *dev)
+{
+	struct generic_pm_domain *pd = dev_to_genpd(dev);
+	int ret;
+
+	if (!dev->of_node || IS_ERR(pd))
+		return 0;
+
+	dev_dbg(dev, "removing from power domain %s\n", pd->name);
+
+	while (1) {
+		ret = pm_genpd_remove_device(pd, dev);
+		if (ret != -EAGAIN)
+			break;
+		cond_resched();
+	}
+
+	if (ret < 0) {
+		dev_err(dev, "failed to remove from power domain %s: %d",
+			pd->name, ret);
+		return ret;
+	}
+
+	/* Check if domain can be powered off after removing this device. */
+	genpd_queue_power_off_work(pd);
+
+	return 0;
+}
+
 /**
  * genpd_dev_pm_detach - Detach a device from its PM domain.
  * @dev: Device to attach.
diff --git a/include/linux/pm_domain.h b/include/linux/pm_domain.h
index 681ccb0..ec8f2d9 100644
--- a/include/linux/pm_domain.h
+++ b/include/linux/pm_domain.h
@@ -278,6 +278,8 @@ struct generic_pm_domain *__of_genpd_xlate_onecell(
 					void *data);
 
 int genpd_dev_pm_attach(struct device *dev);
+int genpd_bind_domain(struct device *dev);
+int genpd_unbind_domain(struct device *dev);
 #else /* !CONFIG_PM_GENERIC_DOMAINS_OF */
 static inline int __of_genpd_add_provider(struct device_node *np,
 					genpd_xlate_t xlate, void *data)
@@ -299,6 +301,16 @@ static inline int genpd_dev_pm_attach(struct device *dev)
 {
 	return -ENODEV;
 }
+
+static inline int genpd_bind_domain(struct device *dev)
+{
+	return 0;
+}
+
+static inline int genpd_unbind_domain(struct device *dev)
+{
+	return 0;
+}
 #endif /* CONFIG_PM_GENERIC_DOMAINS_OF */
 
 static inline int of_genpd_add_provider_simple(struct device_node *np,
diff --git a/kernel/power/Kconfig b/kernel/power/Kconfig
index 9e30231..c276e75 100644
--- a/kernel/power/Kconfig
+++ b/kernel/power/Kconfig
@@ -297,7 +297,7 @@ config PM_GENERIC_DOMAINS_SLEEP
 
 config PM_GENERIC_DOMAINS_OF
 	def_bool y
-	depends on PM_GENERIC_DOMAINS && OF
+	depends on PM_GENERIC_DOMAINS && OF && !ARCH_EXYNOS
 
 config CPU_PM
 	bool
-- 
1.7.5.4

