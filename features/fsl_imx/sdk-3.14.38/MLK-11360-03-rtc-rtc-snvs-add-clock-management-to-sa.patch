From a00bd0f759fec4c005dc574a80ac4c40ac8bc16c Mon Sep 17 00:00:00 2001
From: Fugang Duan <b38611@freescale.com>
Date: Fri, 14 Aug 2015 15:08:06 +0800
Subject: [PATCH 3/3] MLK-11360-03 rtc: rtc-snvs: add clock management to save
 power

Add snvs clock management for the driver to save power.

Signed-off-by: Fugang Duan <B38611@freescale.com>
[zou:Original patch taken from
git.freescale.com/imx/fsl-arm-yocto-bsp.git-b
imx-3.14.52-1.1.0_ga]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/rtc/rtc-snvs.c |   33 ++++++++++++++++++++++++++++++++-
 1 files changed, 32 insertions(+), 1 deletions(-)

diff --git a/drivers/rtc/rtc-snvs.c b/drivers/rtc/rtc-snvs.c
index e3f952f..df97749 100644
--- a/drivers/rtc/rtc-snvs.c
+++ b/drivers/rtc/rtc-snvs.c
@@ -123,9 +123,12 @@ static int snvs_rtc_enable(struct snvs_rtc_data *data, bool enable)
 static int snvs_rtc_read_time(struct device *dev, struct rtc_time *tm)
 {
 	struct snvs_rtc_data *data = dev_get_drvdata(dev);
-	unsigned long time = rtc_read_lp_counter(data->ioaddr);
+	unsigned long time;
 
+	clk_enable(data->clk);
+	time = rtc_read_lp_counter(data->ioaddr);
 	rtc_time_to_tm(time, tm);
+	clk_disable(data->clk);
 
 	return 0;
 }
@@ -135,6 +138,7 @@ static int snvs_rtc_set_time(struct device *dev, struct rtc_time *tm)
 	struct snvs_rtc_data *data = dev_get_drvdata(dev);
 	unsigned long time;
 
+	clk_enable(data->clk);
 	rtc_tm_to_time(tm, &time);
 
 	/* Disable RTC first */
@@ -146,6 +150,7 @@ static int snvs_rtc_set_time(struct device *dev, struct rtc_time *tm)
 
 	/* Enable RTC again */
 	snvs_rtc_enable(data, true);
+	clk_disable(data->clk);
 
 	return 0;
 }
@@ -155,11 +160,13 @@ static int snvs_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)
 	struct snvs_rtc_data *data = dev_get_drvdata(dev);
 	u32 lptar, lpsr;
 
+	clk_enable(data->clk);
 	lptar = readl(data->ioaddr + SNVS_LPTAR);
 	rtc_time_to_tm(lptar, &alrm->time);
 
 	lpsr = readl(data->ioaddr + SNVS_LPSR);
 	alrm->pending = (lpsr & SNVS_LPSR_LPTA) ? 1 : 0;
+	clk_disable(data->clk);
 
 	return 0;
 }
@@ -170,6 +177,7 @@ static int snvs_rtc_alarm_irq_enable(struct device *dev, unsigned int enable)
 	u32 lpcr;
 	unsigned long flags;
 
+	clk_enable(data->clk);
 	spin_lock_irqsave(&data->lock, flags);
 
 	lpcr = readl(data->ioaddr + SNVS_LPCR);
@@ -182,6 +190,7 @@ static int snvs_rtc_alarm_irq_enable(struct device *dev, unsigned int enable)
 	spin_unlock_irqrestore(&data->lock, flags);
 
 	rtc_write_sync_lp(data->ioaddr);
+	clk_disable(data->clk);
 
 	return 0;
 }
@@ -196,6 +205,7 @@ static int snvs_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
 
 	rtc_tm_to_time(alrm_tm, &time);
 
+	clk_enable(data->clk);
 	spin_lock_irqsave(&data->lock, flags);
 
 	/* Have to clear LPTA_EN before programming new alarm time in LPTAR */
@@ -209,6 +219,7 @@ static int snvs_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
 
 	/* Clear alarm interrupt status bit */
 	writel(SNVS_LPSR_LPTA, data->ioaddr + SNVS_LPSR);
+	clk_disable(data->clk);
 
 	return snvs_rtc_alarm_irq_enable(dev, alrm->enabled);
 }
@@ -228,6 +239,7 @@ static irqreturn_t snvs_rtc_irq_handler(int irq, void *dev_id)
 	u32 lpsr;
 	u32 events = 0;
 
+	clk_enable(data->clk);
 	lpsr = readl(data->ioaddr + SNVS_LPSR);
 
 	if (lpsr & SNVS_LPSR_LPTA) {
@@ -241,6 +253,7 @@ static irqreturn_t snvs_rtc_irq_handler(int irq, void *dev_id)
 
 	/* clear interrupt status */
 	writel(lpsr, data->ioaddr + SNVS_LPSR);
+	clk_disable(data->clk);
 
 	return events ? IRQ_HANDLED : IRQ_NONE;
 }
@@ -248,10 +261,14 @@ static irqreturn_t snvs_rtc_irq_handler(int irq, void *dev_id)
 static void snvs_poweroff(void)
 {
 	u32 value;
+	struct snvs_rtc_data *data = container_of(snvs_base, struct snvs_rtc_data,
+						  ioaddr);
 
+	clk_enable(data->clk);
 	value = readl(snvs_base + SNVS_LPCR);
 	/* set TOP and DP_EN bit */
 	writel(value | 0x60, snvs_base + SNVS_LPCR);
+	clk_disable(data->clk);
 }
 
 static int snvs_rtc_probe(struct platform_device *pdev)
@@ -269,6 +286,12 @@ static int snvs_rtc_probe(struct platform_device *pdev)
 	if (IS_ERR(data->ioaddr))
 		return PTR_ERR(data->ioaddr);
 
+	data->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(data->clk)) {
+		dev_err(&pdev->dev, "can't get snvs-rtc clock\n");
+		data->clk = NULL;
+	}
+
 	data->irq = platform_get_irq(pdev, 0);
 	if (data->irq < 0)
 		return data->irq;
@@ -289,6 +312,12 @@ static int snvs_rtc_probe(struct platform_device *pdev)
 
 	spin_lock_init(&data->lock);
 
+	ret = clk_prepare_enable(data->clk);
+	if (ret) {
+		dev_err(&pdev->dev, "can't enable snvs-rtc clock\n");
+		return ret;
+	}
+
 	/* Initialize glitch detect */
 	writel(SNVS_LPPGDR_INIT, data->ioaddr + SNVS_LPPGDR);
 
@@ -324,6 +353,8 @@ static int snvs_rtc_probe(struct platform_device *pdev)
 	if (!pm_power_off)
 		pm_power_off = snvs_poweroff;
 
+	clk_disable(data->clk);
+
 	return 0;
 
 error_rtc_device_register:
-- 
1.7.5.4

