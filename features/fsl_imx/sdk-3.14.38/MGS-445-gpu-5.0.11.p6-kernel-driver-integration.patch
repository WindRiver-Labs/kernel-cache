From befd8cf758bd420cdf296798553091ecc3cf7323 Mon Sep 17 00:00:00 2001
From: Xianzhong <b07117@freescale.com>
Date: Wed, 21 Jan 2015 13:31:22 +0800
Subject: [PATCH 1385/1594] MGS-445 gpu 5.0.11.p6 kernel driver integration

commit e64e27bec6cfa3e027198380987a03a860aae24e from
git://git.freescale.com/imx/linux-2.6-imx.git

Integrate 5.0.11.p6 kernel driver for 3.14 kernel

Source git: gpu-viv5.git
Source branch: origin/fsl_5.0.11.p6
Source commit: 07cd58ca5da881422181c0fb6d9265c0ed3e7f8e

Signed-off-by: Xianzhong <b07117@freescale.com>
Acked-by: Jason Liu
---
 drivers/mxc/gpu-viv/Kbuild                         |    2 +-
 .../hal/kernel/arch/gc_hal_kernel_context.c        |   21 +-
 .../hal/kernel/arch/gc_hal_kernel_context.h        |   23 +-
 .../hal/kernel/arch/gc_hal_kernel_hardware.c       |  348 ++++++++++----
 .../hal/kernel/arch/gc_hal_kernel_hardware.h       |    2 +-
 .../hal/kernel/arch/gc_hal_kernel_recorder.c       |    2 +-
 .../archvg/gc_hal_kernel_hardware_command_vg.c     |    2 +-
 .../archvg/gc_hal_kernel_hardware_command_vg.h     |    2 +-
 .../hal/kernel/archvg/gc_hal_kernel_hardware_vg.c  |  109 ++++-
 .../hal/kernel/archvg/gc_hal_kernel_hardware_vg.h  |    2 +-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c     |   79 ++--
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h     |   36 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c |  513 +++++++++++---------
 .../gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c  |   57 ++-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c  |  111 +++---
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c   |   20 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c   |   43 ++-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c    |    2 +-
 .../hal/kernel/gc_hal_kernel_interrupt_vg.c        |    2 +-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c |   47 ++-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c  |    2 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c   |    2 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h |    2 +-
 .../gpu-viv/hal/kernel/gc_hal_kernel_security.c    |   21 +-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c  |   32 ++-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h  |    2 +-
 .../hal/kernel/gc_hal_kernel_video_memory.c        |   26 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h        |   60 ++--
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h   |  132 +++++-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h |    6 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h  |    2 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h   |    2 +-
 .../gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h    |   15 +-
 .../hal/kernel/inc/gc_hal_eglplatform_type.h       |   38 ++-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h |   77 +++-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h  |   81 +++-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h   |   26 +-
 .../gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h  |    4 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h    |    2 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h    |   44 ++-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h   |    2 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h |    8 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h |    2 +-
 .../hal/kernel/inc/gc_hal_security_interface.h     |    2 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h |    2 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h  |    6 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h    |   10 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h     |    3 +-
 .../default/gc_hal_kernel_allocator_array.h        |    2 +-
 .../freescale/gc_hal_kernel_allocator_array.h      |    2 +-
 .../freescale/gc_hal_kernel_allocator_cma.c        |    6 +-
 .../hal/os/linux/kernel/gc_hal_kernel_allocator.c  |    6 +-
 .../hal/os/linux/kernel/gc_hal_kernel_allocator.h  |    6 +-
 .../hal/os/linux/kernel/gc_hal_kernel_debug.h      |    2 +-
 .../hal/os/linux/kernel/gc_hal_kernel_debugfs.c    |   10 +-
 .../hal/os/linux/kernel/gc_hal_kernel_debugfs.h    |    2 +-
 .../hal/os/linux/kernel/gc_hal_kernel_device.c     |  152 ++++---
 .../hal/os/linux/kernel/gc_hal_kernel_device.h     |   30 ++-
 .../hal/os/linux/kernel/gc_hal_kernel_iommu.c      |    2 +-
 .../hal/os/linux/kernel/gc_hal_kernel_linux.c      |    7 +-
 .../hal/os/linux/kernel/gc_hal_kernel_linux.h      |    8 +-
 .../hal/os/linux/kernel/gc_hal_kernel_math.c       |    2 +-
 .../hal/os/linux/kernel/gc_hal_kernel_mutex.h      |   55 +++
 .../gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c |  340 ++++++-------
 .../gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h |    2 +-
 .../hal/os/linux/kernel/gc_hal_kernel_platform.h   |    8 +-
 .../hal/os/linux/kernel/gc_hal_kernel_probe.c      |   18 +-
 .../linux/kernel/gc_hal_kernel_security_channel.c  |   10 +-
 .../hal/os/linux/kernel/gc_hal_kernel_sync.c       |    2 +-
 .../hal/os/linux/kernel/gc_hal_kernel_sync.h       |    2 +-
 .../freescale/gc_hal_kernel_platform_imx6q14.c     |    8 +-
 .../gc_hal_kernel_platform_imx6q14.config          |    3 +
 72 files changed, 1786 insertions(+), 933 deletions(-)
 create mode 100644 drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_mutex.h

diff --git a/drivers/mxc/gpu-viv/Kbuild b/drivers/mxc/gpu-viv/Kbuild
index c39444c..955b146 100644
--- a/drivers/mxc/gpu-viv/Kbuild
+++ b/drivers/mxc/gpu-viv/Kbuild
@@ -1,6 +1,6 @@
 ##############################################################################
 #
-#    Copyright (C) 2005 - 2014 by Vivante Corp.
+#    Copyright (C) 2005 - 2015 by Vivante Corp.
 #
 #    This program is free software; you can redistribute it and/or modify
 #    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.c b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.c
index 08644a7..caae97b 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -223,6 +223,7 @@ _FlushPipe(
                 ?   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3)))
                 :   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))
                   | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)))
+                  | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4)))
                   | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2)))
                   | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5)));
 
@@ -620,7 +621,7 @@ _InitializeContextBuffer(
     halti3 = (((((gctUINT32) (Context->hardware->identity.chipMinorFeatures5)) >> (0 ? 9:9)) & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1)))))) );
 
     /* Query how many uniforms can support for non-unified uniform mode. */
-    {if (Context->hardware->identity.numConstants > 256){    unifiedUniform = gcvTRUE;    vsConstBase  = 0xC000;    psConstBase  = 0xC000;    constMax     = Context->hardware->identity.numConstants;    vertexUniforms   = 256;    fragmentUniforms   = constMax - vertexUniforms;}else if (Context->hardware->identity.numConstants == 256){    if (Context->hardware->identity.chipModel == gcv2000 && Context->hardware->identity.chipRevision == 0x5118)    {        unifiedUniform = gcvFALSE;        vsConstBase  = 0x1400;        psConstBase  = 0x1C00;        vertexUniforms   = 256;        fragmentUniforms   = 64;        constMax     = 320;    }    else    {        unifiedUniform = gcvFALSE;        vsConstBase  = 0x1400;        psConstBase  = 0x1C00;        vertexUniforms   = 256;        fragmentUniforms   = 256;        constMax     = 512;    }}else{    unifiedUniform = gcvFALSE;    vsConstBase  = 0x1400;    psConstBase  = 0x1C00;    vertexUniforms   = 168;    fragmentUniforms   = 64;    constMax     = 232;}};
+    {if (Context->hardware->identity.numConstants > 256){    unifiedUniform = gcvTRUE;    vsConstBase  = 0xC000;    psConstBase  = 0xC000;    vertexUniforms   = gcmMIN(512, Context->hardware->identity.numConstants - 64);    fragmentUniforms   = gcmMIN(512, Context->hardware->identity.numConstants - 64);    constMax     = Context->hardware->identity.numConstants;}else if (Context->hardware->identity.numConstants == 256){    if (Context->hardware->identity.chipModel == gcv2000 && Context->hardware->identity.chipRevision == 0x5118)    {        unifiedUniform = gcvFALSE;        vsConstBase  = 0x1400;        psConstBase  = 0x1C00;        vertexUniforms   = 256;        fragmentUniforms   = 64;        constMax     = 320;    }    else    {        unifiedUniform = gcvFALSE;        vsConstBase  = 0x1400;        psConstBase  = 0x1C00;        vertexUniforms   = 256;        fragmentUniforms   = 256;        constMax     = 512;    }}else{    unifiedUniform = gcvFALSE;    vsConstBase  = 0x1400;    psConstBase  = 0x1C00;    vertexUniforms   = 168;    fragmentUniforms   = 64;    constMax     = 232;}};
 
 #if !gcdENABLE_UNIFIED_CONSTANT
     if (Context->hardware->identity.numConstants > 256)
@@ -764,7 +765,7 @@ _InitializeContextBuffer(
     index += _State(Context, index, 0x00E10 >> 2, 0x00000000, 4, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x00E04 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x00E40 >> 2, 0x00000000, 16, gcvFALSE, gcvFALSE);
-    index += _State(Context, index, 0x00E08 >> 2, 0x00000031, 1, gcvFALSE, gcvFALSE);
+    index += _State(Context, index, 0x00E08 >> 2, 0x17000031, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x00E24 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x00E20 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
 
@@ -780,6 +781,13 @@ _InitializeContextBuffer(
     index += _State(Context, index, 0x01010 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
     index += _State(Context, index, 0x01030 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
 
+    if (halti2)
+    {
+        index += _State(Context, index, 0x0102C >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
+        index += _State(Context, index, 0x01034 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
+        index += _State(Context, index, 0x01038 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
+    }
+
     index += _CLOSE_RANGE();
 
     /* Texture states. */
@@ -1587,6 +1595,7 @@ gckCONTEXT_Construct(
                 context->hardware->kernel,
                 pointer,
                 gcvFALSE,
+                buffer->physical,
                 &address
                 ));
         }
@@ -1646,7 +1655,7 @@ gckCONTEXT_Construct(
 
             /* Query LINK size. */
             gcmkONERROR(gckHARDWARE_Link(
-                Hardware, gcvNULL, 0, 0, &linkBytes
+                Hardware, gcvNULL, 0, 0, &linkBytes, gcvNULL, gcvNULL
                 ));
 
             /* Generate a LINK. */
@@ -1655,7 +1664,9 @@ gckCONTEXT_Construct(
                 xdLink,
                 xdEntryAddress,
                 xdEntrySize,
-                &linkBytes
+                &linkBytes,
+                gcvNULL,
+                gcvNULL
                 ));
         }
     }
diff --git a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.h b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.h
index 29e6a53..4deeef9 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -96,6 +96,8 @@ struct  _gcsRECORD_ARRAY_MAP
 
 };
 
+#define USE_SW_RESET 1
+
 /* gckCONTEXT structure that hold the current context. */
 struct _gckCONTEXT
 {
@@ -164,6 +166,8 @@ struct _gckCONTEXT
 #if VIVANTE_PROFILER_CONTEXT
     gcsPROFILER_COUNTERS        latestProfiler;
     gcsPROFILER_COUNTERS        histroyProfiler;
+
+    /* SH */
     gctUINT32                   prevVSInstCount;
     gctUINT32                   prevVSBranchInstCount;
     gctUINT32                   prevVSTexInstCount;
@@ -172,6 +176,23 @@ struct _gckCONTEXT
     gctUINT32                   prevPSBranchInstCount;
     gctUINT32                   prevPSTexInstCount;
     gctUINT32                   prevPSPixelCount;
+
+#if USE_SW_RESET
+    /* RA */
+    gctUINT32                   prevRaValidPixelCount;
+    gctUINT32                   prevRaTotalQuadCount;
+    gctUINT32                   prevRaValidQuadCountAfterEarlyZ;
+    gctUINT32                   prevRaTotalPrimitiveCount;
+    gctUINT32                   prevRaPipeCacheMissCounter;
+    gctUINT32                   prevRaPrefetchCacheMissCounter;
+
+    /* PE */
+    gctUINT32                   prevPePixelCountKilledByColorPipe;
+    gctUINT32                   prevPePixelCountKilledByDepthPipe;
+    gctUINT32                   prevPePixelCountDrawnByColorPipe;
+    gctUINT32                   prevPePixelCountDrawnByDepthPipe;
+#endif
+
 #endif
 };
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c
index c5759a1..b71e079 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -109,6 +109,7 @@ _IdentifyHardware(
 #if gcdMULTI_GPU
     gctUINT32 gpuCoreCount = 0;
 #endif
+    gctUINT32 debugControl0 = 0;
 
     gcmkHEADER_ARG("Os=0x%x", Os);
 
@@ -593,6 +594,18 @@ _IdentifyHardware(
 #endif
 #endif
 
+    Identity->ecoFlags = 0;
+
+    gcmkONERROR(
+            gckOS_ReadRegisterEx(Os, Core,
+                                 0x00470,
+                                 &debugControl0));
+
+    if (debugControl0 & (1 << 16))
+    {
+        Identity->ecoFlags |= gcvECO_FLAG_MSAA_COHERENCEY;
+    }
+
     /* Success. */
     gcmkFOOTER();
     return gcvSTATUS_OK;
@@ -1855,6 +1868,7 @@ gckHARDWARE_QueryChipIdentity(
     Identity->chip2DControl          = Hardware->identity.chip2DControl;
 
     Identity->productID              = Hardware->identity.productID;
+    Identity->ecoFlags               = Hardware->identity.ecoFlags;
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -2500,7 +2514,7 @@ gckHARDWARE_Event(
 
 #if gcmIS_DEBUG(gcdDEBUG_TRACE)
         {
-            gctUINT32 phys;
+            gctPHYS_ADDR_T phys;
             gckOS_GetPhysicalAddress(Hardware->os, Logical, &phys);
             gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
                            "0x%08x: EVENT %d", phys, Event);
@@ -2713,7 +2727,9 @@ gckHARDWARE_Link(
     IN gctPOINTER Logical,
     IN gctUINT32 FetchAddress,
     IN gctUINT32 FetchSize,
-    IN OUT gctUINT32 * Bytes
+    IN OUT gctUINT32 * Bytes,
+    OUT gctUINT32 * Low,
+    OUT gctUINT32 * High
     )
 {
     gceSTATUS status;
@@ -2741,6 +2757,11 @@ gckHARDWARE_Link(
         gcmkONERROR(
             gckOS_WriteMemory(Hardware->os, logical + 1, FetchAddress));
 
+        if (High)
+        {
+            *High = FetchAddress;
+        }
+
         /* Make sure the address got written before the LINK command. */
         gcmkONERROR(
             gckOS_MemoryBarrier(Hardware->os, logical + 1));
@@ -2755,30 +2776,14 @@ gckHARDWARE_Link(
         gcmkONERROR(
             gckOS_WriteMemory(Hardware->os, logical, link));
 
+        if (Low)
+        {
+            *Low = link;
+        }
+
         /* Memory barrier. */
         gcmkONERROR(
             gckOS_MemoryBarrier(Hardware->os, logical));
-
-#if gcdLINK_QUEUE_SIZE && !gcdPROCESS_ADDRESS_SPACE
-        if ((Hardware->kernel->virtualCommandBuffer)
-         && (Hardware->kernel->stuckDump > 2)
-        )
-        {
-            gctBOOL in;
-
-            gcmkVERIFY_OK(gckCOMMAND_AddressInKernelCommandBuffer(
-                Hardware->kernel->command, FetchAddress, &in));
-
-            if (in == gcvFALSE)
-            {
-                /* Record user command buffer and context buffer link
-                ** information for stuck dump.
-                **/
-                gckLINKQUEUE_Enqueue(
-                    &Hardware->linkQueue, FetchAddress, FetchAddress + (gctUINT)bytes);
-            }
-        }
-#endif
     }
 
     if (Bytes != gcvNULL)
@@ -2901,6 +2906,7 @@ gckHARDWARE_ConvertLogical(
     gctUINT32 address;
     gceSTATUS status;
     gctUINT32 baseAddress;
+    gctPHYS_ADDR_T physical;
 
     gcmkHEADER_ARG("Hardware=0x%x Logical=0x%x InUserSpace=%d",
                    Hardware, Logical, InUserSpace);
@@ -2913,13 +2919,15 @@ gckHARDWARE_ConvertLogical(
     /* Convert logical address into a physical address. */
     if (InUserSpace)
     {
-        gcmkONERROR(gckOS_UserLogicalToPhysical(Hardware->os, Logical, &address));
+        gcmkONERROR(gckOS_UserLogicalToPhysical(Hardware->os, Logical, &physical));
     }
     else
     {
-        gcmkONERROR(gckOS_GetPhysicalAddress(Hardware->os, Logical, &address));
+        gcmkONERROR(gckOS_GetPhysicalAddress(Hardware->os, Logical, &physical));
     }
 
+    gcmkSAFECASTPHYSADDRT(address, physical);
+
     /* For old MMU, get GPU address according to baseAddress. */
     if (Hardware->mmuVersion == 0)
     {
@@ -3208,7 +3216,7 @@ gckHARDWARE_QueryShaderCaps(
                    Hardware, VertexUniforms,
                    FragmentUniforms, UnifiedUnforms);
 
-    {if (Hardware->identity.numConstants > 256){    unifiedConst = gcvTRUE;    vsConstBase  = 0xC000;    psConstBase  = 0xC000;    ConstMax     = Hardware->identity.numConstants;    vsConstMax   = 256;    psConstMax   = ConstMax - vsConstMax;}else if (Hardware->identity.numConstants == 256){    if (Hardware->identity.chipModel == gcv2000 && Hardware->identity.chipRevision == 0x5118)    {        unifiedConst = gcvFALSE;        vsConstBase  = 0x1400;        psConstBase  = 0x1C00;        vsConstMax   = 256;        psConstMax   = 64;        ConstMax     = 320;    }    else    {        unifiedConst = gcvFALSE;        vsConstBase  = 0x1400;        psConstBase  = 0x1C00;        vsConstMax   = 256;        psConstMax   = 256;        ConstMax     = 512;    }}else{    unifiedConst = gcvFALSE;    vsConstBase  = 0x1400;    psConstBase  = 0x1C00;    vsConstMax   = 168;    psConstMax   = 64;    ConstMax     = 232;}};
+    {if (Hardware->identity.numConstants > 256){    unifiedConst = gcvTRUE;    vsConstBase  = 0xC000;    psConstBase  = 0xC000;    vsConstMax   = gcmMIN(512, Hardware->identity.numConstants - 64);    psConstMax   = gcmMIN(512, Hardware->identity.numConstants - 64);    ConstMax     = Hardware->identity.numConstants;}else if (Hardware->identity.numConstants == 256){    if (Hardware->identity.chipModel == gcv2000 && Hardware->identity.chipRevision == 0x5118)    {        unifiedConst = gcvFALSE;        vsConstBase  = 0x1400;        psConstBase  = 0x1C00;        vsConstMax   = 256;        psConstMax   = 64;        ConstMax     = 320;    }    else    {        unifiedConst = gcvFALSE;        vsConstBase  = 0x1400;        psConstBase  = 0x1C00;        vsConstMax   = 256;        psConstMax   = 256;        ConstMax     = 512;    }}else{    unifiedConst = gcvFALSE;    vsConstBase  = 0x1400;    psConstBase  = 0x1C00;    vsConstMax   = 168;    psConstMax   = 64;    ConstMax     = 232;}};
 
     if (VertexUniforms != gcvNULL)
     {
@@ -3262,6 +3270,7 @@ gckHARDWARE_SetMMU(
     gctUINT32 address = 0;
     gctUINT32 idle;
     gctUINT32 timer = 0, delay = 1;
+    gctPHYS_ADDR_T physical;
 
     gcmkHEADER_ARG("Hardware=0x%x Logical=0x%x", Hardware, Logical);
 
@@ -3273,7 +3282,9 @@ gckHARDWARE_SetMMU(
         gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
 
         /* Convert the logical address into physical address. */
-        gcmkONERROR(gckOS_GetPhysicalAddress(Hardware->os, Logical, &address));
+        gcmkONERROR(gckOS_GetPhysicalAddress(Hardware->os, Logical, &physical));
+
+        gcmkSAFECASTPHYSADDRT(address, physical);
 
         gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
                        "Setting page table to 0x%08X",
@@ -3397,7 +3408,8 @@ gckHARDWARE_FlushMMU(
     gctPOINTER pointer = gcvNULL;
     gctUINT32 flushSize;
     gctUINT32 count;
-    gctUINT32 physical;
+    gctPHYS_ADDR_T physical;
+    gctUINT32 address;
 
     gcmkHEADER_ARG("Hardware=0x%x", Hardware);
 
@@ -3432,7 +3444,7 @@ gckHARDWARE_FlushMMU(
     }
     else
     {
-        flushSize =  16 * 4;
+        flushSize =  20 * 4;
 
         gcmkONERROR(gckCOMMAND_Reserve(
             command, flushSize, &pointer, &bufferSize
@@ -3444,79 +3456,100 @@ gckHARDWARE_FlushMMU(
 
         gcmkONERROR(gckOS_GetPhysicalAddress(command->os, buffer, &physical));
 
-        /* Flush cache. */
+        gcmkSAFECASTPHYSADDRT(address, physical);
+
+        /* Arm the PE-FE Semaphore. */
         buffer[0]
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)))
-            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E03) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E02) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
 
         buffer[1]
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
+
+        /* STALL FE until PE is done flushing. */
+        buffer[2]
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x09 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)));
+
+        buffer[3]
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
+
+        /* Flush cache. */
+        buffer[4]
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E03) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
+
+        buffer[5]
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 6:6) - (0 ? 6:6) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 6:6) - (0 ? 6:6) + 1))))))) << (0 ? 6:6))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 6:6) - (0 ? 6:6) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 6:6) - (0 ? 6:6) + 1))))))) << (0 ? 6:6)));
 
         /* Arm the PE-FE Semaphore. */
-        buffer[2]
+        buffer[6]
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E02) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
 
-        buffer[3]
+        buffer[7]
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
 
         /* STALL FE until PE is done flushing. */
-        buffer[4]
+        buffer[8]
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x09 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)));
 
-        buffer[5]
+        buffer[9]
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
 
         /* LINK to next slot to flush FE FIFO. */
-        buffer[6]
+        buffer[10]
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x08 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (4) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
 
-        buffer[7]
-            = physical + 8 * gcmSIZEOF(gctUINT32);
+        buffer[11]
+            = address + 12 * gcmSIZEOF(gctUINT32);
 
         /* Flush MMU cache. */
-        buffer[8]
+        buffer[12]
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0061) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
 
-        buffer[9]
+        buffer[13]
             = (((((gctUINT32) (~0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) &  ((((gctUINT32) (~0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:7) - (0 ? 7:7) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:7) - (0 ? 7:7) + 1))))))) << (0 ? 7:7))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 7:7) - (0 ? 7:7) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:7) - (0 ? 7:7) + 1))))))) << (0 ? 7:7))));
 
         /* Arm the PE-FE Semaphore. */
-        buffer[10]
+        buffer[14]
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E02) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
 
-        buffer[11]
+        buffer[15]
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
 
         /* STALL FE until PE is done flushing. */
-        buffer[12]
+        buffer[16]
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x09 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)));
 
-        buffer[13]
+        buffer[17]
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
 
         /* LINK to next slot to flush FE FIFO. */
-        buffer[14]
+        buffer[18]
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x08 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (count) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
 
-        buffer[15]
-            = physical + flushSize;
+        buffer[19]
+            = address + flushSize;
 
         gcmkONERROR(gckCOMMAND_Execute(command, flushSize));
     }
@@ -3544,6 +3577,8 @@ gckHARDWARE_SetMMUStates(
 {
     gceSTATUS status;
     gctUINT32 config, address;
+    gctUINT32 extMtlb, extSafeAddrss, configEx = 0;
+    gctPHYS_ADDR_T physical;
     gctUINT32_PTR buffer;
     gctBOOL ace;
     gctUINT32 reserveBytes = 16 + 4 * 4;
@@ -3575,14 +3610,25 @@ gckHARDWARE_SetMMUStates(
           + 4 * 4
             /* Semaphore stall */
           + 4 * 8;
+
+        if (ace)
+        {
+            reserveBytes += 8;
+        }
     }
 
     /* Convert logical address into physical address. */
     gcmkONERROR(
-        gckOS_GetPhysicalAddress(Hardware->os, MtlbAddress, &config));
+        gckOS_GetPhysicalAddress(Hardware->os, MtlbAddress, &physical));
+
+    config  = (gctUINT32)(physical & 0xFFFFFFFF);
+    extMtlb = (gctUINT32)(physical >> 32);
 
     gcmkONERROR(
-        gckOS_GetPhysicalAddress(Hardware->os, SafeAddress, &address));
+        gckOS_GetPhysicalAddress(Hardware->os, SafeAddress, &physical));
+
+    address = (gctUINT32)(physical & 0xFFFFFFFF);
+    extSafeAddrss = (gctUINT32)(physical >> 32);
 
     if (address & 0x3F)
     {
@@ -3615,6 +3661,12 @@ gckHARDWARE_SetMMUStates(
         gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
     }
 
+    if (ace)
+    {
+        configEx = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (extSafeAddrss) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0)))
+                 | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (extMtlb) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)));
+    }
+
     if (Logical != gcvNULL)
     {
         buffer = Logical;
@@ -3640,7 +3692,8 @@ gckHARDWARE_SetMMUStates(
                 | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0068) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
                 | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
 
-            *buffer++ = 0;
+            *buffer++
+                = configEx;
         }
 
         do{*buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E02) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))); *buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))); *buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x09 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))); *buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));} while(0);;
@@ -3669,6 +3722,17 @@ gckHARDWARE_SetMMUStates(
 
             *buffer++ = address;
 
+            if (ace)
+            {
+                *buffer++
+                    = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+                    | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0068) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
+                    | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
+
+                *buffer++
+                    = configEx;
+            }
+
             do{*buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E02) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))); *buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))); *buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x09 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))); *buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));} while(0);;
 
             /* LoadState(AQPipeSelect, 1), pipe. */
@@ -3794,7 +3858,7 @@ gckHARDWARE_ConfigMMU(
 
     bytes
         /* Flush cache states. */
-        = 18 * 4
+        = 22 * 4
         /* MMU configuration states. */
         + 6 * 4
         /* EVENT. */
@@ -3823,6 +3887,24 @@ gckHARDWARE_ConfigMMU(
         config |= ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))
                 | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4)));
 
+        /* Arm the PE-FE Semaphore. */
+        *buffer++
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E02) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
+
+        *buffer++
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
+
+        /* STALL FE until PE is done flushing. */
+        *buffer++
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x09 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)));
+
+        *buffer++
+            = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
+            | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
+
         /* Flush cache. */
         *buffer++
             = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
@@ -4125,7 +4207,7 @@ gckHARDWARE_Flush(
     gceSTATUS status;
     gctUINT32 reserveBytes
         /* Semaphore/Stall */
-        = 4 * gcmSIZEOF(gctUINT32);
+        = 8 * gcmSIZEOF(gctUINT32);
 
     gcmkHEADER_ARG("Hardware=0x%x Flush=0x%x Logical=0x%x *Bytes=%lu",
                    Hardware, Flush, Logical, gcmOPT_VALUE(Bytes));
@@ -4155,6 +4237,7 @@ gckHARDWARE_Flush(
     if ((Flush & gcvFLUSH_TEXTURE) && (pipe == 0x0))
     {
         flush |= ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2)));
+        flush |= ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4)));
     }
 
     /* Flush 2D cache. */
@@ -4203,6 +4286,24 @@ gckHARDWARE_Flush(
                 gcmkONERROR(gcvSTATUS_BUFFER_TOO_SMALL);
             }
 
+            /* Semaphore. */
+            *logical++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E02) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)));
+
+            *logical++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
+
+            /* Stall. */
+            *logical++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x09 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)));
+
+            *logical++
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
+                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
+
             if (flush)
             {
                 /* Append LOAD_STATE to AQFlush. */
@@ -4247,7 +4348,7 @@ gckHARDWARE_Flush(
                 = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x09 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)));
 
             *logical++
-                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x05 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
+                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)))
                 | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8))) | (((gctUINT32) (0x07 & ((gctUINT32) ((((1 ? 12:8) - (0 ? 12:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:8) - (0 ? 12:8) + 1))))))) << (0 ? 12:8)));
         }
 
@@ -5759,7 +5860,7 @@ OnError:
                              GC_DEBUG_SIGNALS_##block##_Address, \
                              &data))
 
-#define gcmkRESET_DEBUG_REGISTER(control, block) \
+#define gcmkRESET_DEBUG_REGISTER(control, block, value) \
     gcmkONERROR(\
         gckOS_WriteRegisterEx(Hardware->os, \
                               Hardware->core, \
@@ -5767,7 +5868,7 @@ OnError:
                               gcmSETFIELD(0, \
                                           GC_DEBUG_CONTROL##control, \
                                           block, \
-                                          15))); \
+                                          value))); \
     gcmkONERROR(\
         gckOS_WriteRegisterEx(Hardware->os, \
                               Hardware->core, \
@@ -5852,12 +5953,22 @@ gckHARDWARE_QueryProfileRegisters(
     gctUINT i, clock;
     gctUINT32 colorKilled, colorDrawn, depthKilled, depthDrawn;
     gctUINT32 totalRead, totalWrite;
+    gceCHIPMODEL chipModel;
+    gctUINT32 chipRevision;
+    gctUINT32 resetValue = 0xF;
 
     gcmkHEADER_ARG("Hardware=0x%x Counters=0x%x", Hardware, Counters);
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
 
+    chipModel = Hardware->identity.chipModel;
+    chipRevision = Hardware->identity.chipRevision;
+    if ((chipModel == gcv5000 && chipRevision == 0x5434) || (chipModel == gcv3000 && chipRevision == 0x5435))
+    {
+        resetValue = 0xFF;
+    }
+
     /* Read the counters. */
     gcmkONERROR(
         gckOS_ReadRegisterEx(Hardware->os,
@@ -5942,7 +6053,7 @@ gckHARDWARE_QueryProfileRegisters(
         gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00438, 0));
     gcmkONERROR(
         gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00078, 0));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (resetValue) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))
 ));
 
@@ -5963,7 +6074,7 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->pxl_branch_inst_counter));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (14) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->pxl_texld_inst_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (resetValue) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24)))
 ));
 
@@ -5980,7 +6091,7 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_trivial_rejected_counter));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (8) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_culled_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (resetValue) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0)))
 ));
 
@@ -5989,7 +6100,7 @@ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((g
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00464, &profiler->se_culled_triangle_count));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00464, &profiler->se_culled_lines_count));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (resetValue) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8)))
 ));
 
@@ -6006,7 +6117,7 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_pipe_cache_miss_counter));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (10) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_prefetch_cache_miss_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (resetValue) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))
 ));
 
@@ -6029,7 +6140,7 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_cache_hit_texel_count));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (9) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_cache_miss_texel_count));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (resetValue) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24)))
 ));
 
@@ -6040,7 +6151,7 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00468, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00468, &profiler->mc_total_read_req_8B_from_IP));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00468, &profiler->mc_total_write_req_8B_from_pipeline));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (resetValue) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0)))
 ));
 
@@ -6051,7 +6162,7 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0046C, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0046C, &profiler->hi_axi_cycles_write_request_stalled));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0046C, &profiler->hi_axi_cycles_write_data_stalled));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (resetValue) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8)))
 ));
 
@@ -6133,6 +6244,14 @@ CalcDelta(
     }
 }
 
+#if USE_SW_RESET
+#define gcmkRESET_PROFILE_DATA(counterName, prevCounterName) \
+    temp = profiler->counterName; \
+    profiler->counterName = CalcDelta(temp, Context->prevCounterName); \
+    Context->prevCounterName = temp
+
+#endif
+
 gceSTATUS
 gckHARDWARE_UpdateContextProfile(
     IN gckHARDWARE Hardware,
@@ -6149,6 +6268,7 @@ gckHARDWARE_UpdateContextProfile(
     gctUINT32 chipRevision;
     gctUINT32 temp;
     gctBOOL needResetShader = gcvFALSE;
+    gctUINT32 resetValue = 0xF;
 
     gcmkHEADER_ARG("Hardware=0x%x Context=0x%x", Hardware, Context);
 
@@ -6158,10 +6278,14 @@ gckHARDWARE_UpdateContextProfile(
 
     chipModel = Hardware->identity.chipModel;
     chipRevision = Hardware->identity.chipRevision;
-    if (chipModel == gcv2000 || (chipModel == gcv2100 && chipRevision == 0x5118))
+    if (chipModel == gcv2000 || chipModel == gcv2100 || chipModel == gcv400 )
     {
         needResetShader = gcvTRUE;
     }
+    if ((chipModel == gcv5000 && chipRevision == 0x5434) || (chipModel == gcv3000 && chipRevision == 0x5435))
+    {
+        resetValue = 0xFF;
+    }
 
     /* Read the counters. */
     gcmkONERROR(
@@ -6221,8 +6345,6 @@ gckHARDWARE_UpdateContextProfile(
 
         profiler->gpuTotalRead64BytesPerFrame += totalRead;
         profiler->gpuTotalWrite64BytesPerFrame += totalWrite;
-        gcmkUPDATE_PROFILE_DATA(gpuTotalRead64BytesPerFrame);
-        gcmkUPDATE_PROFILE_DATA(gpuTotalWrite64BytesPerFrame);
 
         /* PE */
         gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))));gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &colorKilled));
@@ -6234,19 +6356,27 @@ gckHARDWARE_UpdateContextProfile(
         profiler->pe_pixel_count_killed_by_depth_pipe += depthKilled;
         profiler->pe_pixel_count_drawn_by_color_pipe += colorDrawn;
         profiler->pe_pixel_count_drawn_by_depth_pipe += depthDrawn;
-        gcmkUPDATE_PROFILE_DATA(pe_pixel_count_killed_by_color_pipe);
-        gcmkUPDATE_PROFILE_DATA(pe_pixel_count_killed_by_depth_pipe);
-        gcmkUPDATE_PROFILE_DATA(pe_pixel_count_drawn_by_color_pipe);
-        gcmkUPDATE_PROFILE_DATA(pe_pixel_count_drawn_by_depth_pipe);
     }
 
+    gcmkUPDATE_PROFILE_DATA(gpuTotalRead64BytesPerFrame);
+    gcmkUPDATE_PROFILE_DATA(gpuTotalWrite64BytesPerFrame);
+#if USE_SW_RESET
+    gcmkRESET_PROFILE_DATA(pe_pixel_count_killed_by_color_pipe, prevPePixelCountKilledByColorPipe);
+    gcmkRESET_PROFILE_DATA(pe_pixel_count_killed_by_depth_pipe, prevPePixelCountKilledByDepthPipe);
+    gcmkRESET_PROFILE_DATA(pe_pixel_count_drawn_by_color_pipe, prevPePixelCountDrawnByColorPipe);
+    gcmkRESET_PROFILE_DATA(pe_pixel_count_drawn_by_depth_pipe, prevPePixelCountDrawnByDepthPipe);
+#endif
+    gcmkUPDATE_PROFILE_DATA(pe_pixel_count_killed_by_color_pipe);
+    gcmkUPDATE_PROFILE_DATA(pe_pixel_count_killed_by_depth_pipe);
+    gcmkUPDATE_PROFILE_DATA(pe_pixel_count_drawn_by_color_pipe);
+    gcmkUPDATE_PROFILE_DATA(pe_pixel_count_drawn_by_depth_pipe);
+
     /* Reset clock control register. */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
                                       Hardware->core,
                                       0x00000,
                                       clock));
 
-
     /* Reset counters. */
     gcmkONERROR(
         gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x0003C, 1));
@@ -6256,10 +6386,11 @@ gckHARDWARE_UpdateContextProfile(
         gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00438, 0));
     gcmkONERROR(
         gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00078, 0));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+#if !USE_SW_RESET
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (resetValue) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))
 ));
-
+#endif
     /* SH */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (7) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->ps_inst_counter));
@@ -6341,7 +6472,8 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profile
     }
     gcmkUPDATE_PROFILE_DATA(pxl_texld_inst_counter);
 
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+    if (!needResetShader)
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (resetValue) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24)))
 ));
 
@@ -6364,7 +6496,7 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profile
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (8) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_culled_counter));
     gcmkUPDATE_PROFILE_DATA(pa_culled_counter);
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (resetValue) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0)))
 ));
 
@@ -6375,32 +6507,42 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00464, &profile
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00464, &profiler->se_culled_lines_count));
     gcmkUPDATE_PROFILE_DATA(se_culled_lines_count);
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (resetValue) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8)))
 ));
 
     /* RA */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_valid_pixel_count));
-    gcmkUPDATE_PROFILE_DATA(ra_valid_pixel_count);
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_total_quad_count));
-    gcmkUPDATE_PROFILE_DATA(ra_total_quad_count);
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_valid_quad_count_after_early_z));
-    gcmkUPDATE_PROFILE_DATA(ra_valid_quad_count_after_early_z);
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_total_primitive_count));
-    gcmkUPDATE_PROFILE_DATA(ra_total_primitive_count);
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (9) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_pipe_cache_miss_counter));
-    gcmkUPDATE_PROFILE_DATA(ra_pipe_cache_miss_counter);
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (10) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_prefetch_cache_miss_counter));
+#if USE_SW_RESET
+    gcmkRESET_PROFILE_DATA(ra_valid_pixel_count, prevRaValidPixelCount);
+    gcmkRESET_PROFILE_DATA(ra_total_quad_count, prevRaTotalQuadCount);
+    gcmkRESET_PROFILE_DATA(ra_valid_quad_count_after_early_z, prevRaValidQuadCountAfterEarlyZ);
+    gcmkRESET_PROFILE_DATA(ra_total_primitive_count, prevRaTotalPrimitiveCount);
+    gcmkRESET_PROFILE_DATA(ra_pipe_cache_miss_counter, prevRaPipeCacheMissCounter);
+    gcmkRESET_PROFILE_DATA(ra_prefetch_cache_miss_counter, prevRaPrefetchCacheMissCounter);
+#endif
+    gcmkUPDATE_PROFILE_DATA(ra_valid_pixel_count);
+    gcmkUPDATE_PROFILE_DATA(ra_total_quad_count);
+    gcmkUPDATE_PROFILE_DATA(ra_valid_quad_count_after_early_z);
+    gcmkUPDATE_PROFILE_DATA(ra_total_primitive_count);
+    gcmkUPDATE_PROFILE_DATA(ra_pipe_cache_miss_counter);
     gcmkUPDATE_PROFILE_DATA(ra_prefetch_cache_miss_counter);
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+#if !USE_SW_RESET
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (resetValue) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))
 ));
+#endif
 
     /* TX */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
@@ -6430,7 +6572,7 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profile
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (9) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_cache_miss_texel_count));
     gcmkUPDATE_PROFILE_DATA(tx_cache_miss_texel_count);
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (resetValue) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24)))
 ));
 
@@ -6444,7 +6586,7 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00468, &profile
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00468, &profiler->mc_total_write_req_8B_from_pipeline));
     gcmkUPDATE_PROFILE_DATA(mc_total_write_req_8B_from_pipeline);
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (resetValue) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0)))
 ));
 
@@ -6458,7 +6600,7 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0046C, &profile
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0046C, &profiler->hi_axi_cycles_write_data_stalled));
     gcmkUPDATE_PROFILE_DATA(hi_axi_cycles_write_data_stalled);
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (resetValue) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8)))
 ));
 
@@ -7119,8 +7261,6 @@ gckHARDWARE_DumpMMUException(
 #endif
     }
 
-    gckHARDWARE_DumpGPUState(Hardware);
-
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 }
@@ -7182,16 +7322,16 @@ gckHARDWARE_DumpGPUState(
 
     static gcsiDEBUG_REGISTERS _dbgRegs[] =
     {
-        { "RA", 0x474, 16, 0x448, 16, 0x12344321 },
-        { "TX", 0x474, 24, 0x44C, 16, 0x12211221 },
-        { "FE", 0x470, 0, 0x450, 16, 0xBABEF00D },
-        { "PE", 0x470, 16, 0x454, 16, 0xBABEF00D },
-        { "DE", 0x470, 8, 0x458, 16, 0xBABEF00D },
-        { "SH", 0x470, 24, 0x45C, 16, 0xDEADBEEF },
-        { "PA", 0x474, 0, 0x460, 16, 0x0000AAAA },
-        { "SE", 0x474, 8, 0x464, 16, 0x5E5E5E5E },
-        { "MC", 0x478, 0, 0x468, 16, 0x12345678 },
-        { "HI", 0x478, 8, 0x46C, 16, 0xAAAAAAAA }
+        { "RA", 0x474, 16, 0x448, 32, 0x12344321 },
+        { "TX", 0x474, 24, 0x44C, 32, 0x12211221 },
+        { "FE", 0x470, 0, 0x450, 32, 0xBABEF00D },
+        { "PE", 0x470, 16, 0x454, 48, 0xBABEF00D },
+        { "DE", 0x470, 8, 0x458, 32, 0xBABEF00D },
+        { "SH", 0x470, 24, 0x45C, 32, 0xDEADBEEF },
+        { "PA", 0x474, 0, 0x460, 32, 0x0000AAAA },
+        { "SE", 0x474, 8, 0x464, 32, 0x5E5E5E5E },
+        { "MC", 0x478, 0, 0x468, 32, 0x12345678 },
+        { "HI", 0x478, 8, 0x46C, 32, 0xAAAAAAAA }
     };
 
     static gctUINT32 _otherRegs[] =
@@ -7330,6 +7470,13 @@ gckHARDWARE_DumpGPUState(
             gcmkONERROR(gckOS_ReadRegisterEx(os, core, _otherRegs[i], &read));
             gcmkPRINT_N(12, "      [0x%04X] 0x%08X\n", _otherRegs[i], read);
         }
+
+        if (Hardware->mmuVersion)
+        {
+            gcmkPRINT("    MMU status from MC[%d]:", pipe);
+
+            gckHARDWARE_DumpMMUException(Hardware);
+        }
     }
 
     if (kernel->hardware->identity.chipFeatures & (1 << 4))
@@ -7976,6 +8123,7 @@ gckHARDWARE_PrepareFunctions(
     gctUINT32 mmuBytes;
     gctUINT32 endBytes;
     gctUINT8_PTR logical;
+    gctPHYS_ADDR_T physical;
 
     gcmkHEADER_ARG("%x", Hardware);
 
@@ -7995,9 +8143,11 @@ gckHARDWARE_PrepareFunctions(
     gcmkONERROR(gckOS_GetPhysicalAddress(
         os,
         Hardware->functionLogical,
-        &Hardware->functionAddress
+        &physical
         ));
 
+    gcmkSAFECASTPHYSADDRT(Hardware->functionAddress, physical);
+
     if (Hardware->mmuVersion > 0)
     {
         /* MMU configure command sequence. */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.h b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.h
index 2ffa146..5272aae 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_recorder.c b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_recorder.c
index 087fa83..d8e8913 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_recorder.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_recorder.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_command_vg.c b/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_command_vg.c
index 0013e63..1d88e2d 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_command_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_command_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_command_vg.h b/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_command_vg.h
index 22093a9..47d289f 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_command_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_command_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_vg.c b/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_vg.c
index 3cb47dd..1cf519f 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -1060,6 +1060,7 @@ gckVGHARDWARE_ConvertLogical(
     OUT gctUINT32 * Address
     )
 {
+    gctPHYS_ADDR_T physical;
     gctUINT32 address;
     gceSTATUS status;
 
@@ -1077,16 +1078,18 @@ gckVGHARDWARE_ConvertLogical(
         if (InUserSpace)
         {
             gcmkERR_BREAK(gckOS_UserLogicalToPhysical(
-                Hardware->os, Logical, &address
+                Hardware->os, Logical, &physical
                 ));
         }
         else
         {
             gcmkERR_BREAK(gckOS_GetPhysicalAddress(
-                Hardware->os, Logical, &address
+                Hardware->os, Logical, &physical
                 ));
         }
 
+        gcmkSAFECASTPHYSADDRT(address, physical);
+
         /* Return hardware specific address. */
         *Address = ((((gctUINT32) (address)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:0) - (0 ? 1:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:0) - (0 ? 1:0) + 1))))))) << (0 ? 1:0))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 1:0) - (0 ? 1:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:0) - (0 ? 1:0) + 1))))))) << (0 ? 1:0)));
 
@@ -1272,6 +1275,11 @@ gceSTATUS gckVGHARDWARE_FlushMMU(
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3)))
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4)));
+
+        gcmkERR_BREAK(gckVGCOMMAND_Execute(
+            command,
+            commandBuffer
+            ));
     }
     while(gcvFALSE);
 
@@ -1461,6 +1469,63 @@ static gceSTATUS _CommandStall(
     return status;
 }
 
+static gceSTATUS
+_IsGPUPresent(
+    IN gckVGHARDWARE Hardware
+    )
+{
+    gceSTATUS status;
+    gceCHIPMODEL chipModel;
+    gctUINT32 chipRev, chipFeatures, chipMinorFeatures, chipMinorFeatures2;
+    /*gcsHAL_QUERY_CHIP_IDENTITY identity;*/
+    gctUINT32 control;
+
+    gcmkHEADER_ARG("Hardware=0x%x", Hardware);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+
+    gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                     gcvCORE_VG,
+                                     0x00000,
+                                     &control));
+
+    control = ((((gctUINT32) (control)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)));
+
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                      gcvCORE_VG,
+                                      0x00000,
+                                      control));
+
+    /* Identify the hardware. */
+    gcmkONERROR(_IdentifyHardware(Hardware->os,
+                                  &chipModel, &chipRev,
+                                  &chipFeatures,
+                                  &chipMinorFeatures,
+                                  &chipMinorFeatures2
+                                  ));
+    /* Check if these are the same values as saved before. */
+    if ((Hardware->chipModel          != chipModel)
+    ||  (Hardware->chipRevision       != chipRev)
+    ||  (Hardware->chipFeatures       != chipFeatures)
+    ||  (Hardware->chipMinorFeatures  != chipMinorFeatures)
+    ||  (Hardware->chipMinorFeatures2 != chipMinorFeatures2)
+    )
+    {
+        gcmkPRINT("[galcore]: GPU is not present.");
+        gcmkONERROR(gcvSTATUS_GPU_NOT_RESPONDING);
+    }
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Return the error. */
+    gcmkFOOTER();
+    return status;
+}
+
 /*******************************************************************************
 **
 **  gckHARDWARE_SetPowerManagementState
@@ -1786,6 +1851,44 @@ gckVGHARDWARE_SetPowerManagementState(
         Hardware->powerState = gcvTRUE;
     }
 
+    for (;;)
+    {
+        /* Check if GPU is present and awake. */
+        status = _IsGPUPresent(Hardware);
+
+        /* Check if the GPU is not responding. */
+        if (status == gcvSTATUS_GPU_NOT_RESPONDING)
+        {
+            /* Turn off the power and clock. */
+            gcmkONERROR(gckOS_SetGPUPower(os, gcvCORE_VG, gcvFALSE, gcvFALSE));
+
+            Hardware->clockState = gcvFALSE;
+            Hardware->powerState = gcvFALSE;
+
+            /* Wait a little. */
+            gckOS_Delay(os, 1);
+
+            /* Turn on the power and clock. */
+            gcmkONERROR(gckOS_SetGPUPower(os, gcvCORE_VG, gcvTRUE, gcvTRUE));
+
+            Hardware->clockState = gcvTRUE;
+            Hardware->powerState = gcvTRUE;
+
+            /* We need to initialize the hardware and start the command
+                * processor. */
+            flag |= gcvPOWER_FLAG_INITIALIZE | gcvPOWER_FLAG_START;
+        }
+        else
+        {
+            /* Test for error. */
+            gcmkONERROR(status);
+
+            /* Break out of loop. */
+            break;
+        }
+    }
+
+
     /* Get time until powered on. */
     gcmkPROFILE_QUERY(time, onTime);
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_vg.h b/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_vg.h
index ce54910..aebbcc6 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
index 4f1ae0a..ecbc387 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -260,10 +260,7 @@ _DumpState(
     /* Dump GPU Debug registers. */
     gcmkVERIFY_OK(gckHARDWARE_DumpGPUState(Kernel->hardware));
 
-    if (Kernel->virtualCommandBuffer)
-    {
-        gcmkVERIFY_OK(gckCOMMAND_DumpExecutingBuffer(Kernel->command));
-    }
+    gcmkVERIFY_OK(gckCOMMAND_DumpExecutingBuffer(Kernel->command));
 
     /* Dump Pending event. */
     gcmkVERIFY_OK(gckEVENT_Dump(Kernel->eventObj));
@@ -1509,7 +1506,7 @@ gckKERNEL_Dispatch(
     gcskSECURE_CACHE_PTR cache;
     gctPOINTER logical;
 #endif
-    gctUINT32 paddr = gcvINVALID_ADDRESS;
+    gctUINT64 paddr = gcvINVALID_ADDRESS;
 #if !USE_NEW_LINUX_SIGNAL
     gctSIGNAL   signal;
 #endif
@@ -2330,8 +2327,8 @@ gckKERNEL_Dispatch(
             )
             {
                 /* If memory is contiguous, get physical address. */
-                gcmkONERROR(gckOS_GetPhysicalAddress(
-                    Kernel->os, logical, (gctUINT32*)&paddr));
+                gcmkONERROR(gckOS_UserLogicalToPhysical(
+                    Kernel->os, logical, &paddr));
             }
         }
 
@@ -2422,9 +2419,9 @@ gckKERNEL_Dispatch(
         Interface->u.Version.build = gcvVERSION_BUILD;
 #if gcmIS_DEBUG(gcdDEBUG_TRACE)
         gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_KERNEL,
-                       "KERNEL version %d.%d.%d build %u %s %s",
-                       gcvVERSION_MAJOR, gcvVERSION_MINOR, gcvVERSION_PATCH,
-                       gcvVERSION_BUILD, gcvVERSION_DATE, gcvVERSION_TIME);
+                       "KERNEL version %d.%d.%d build %u",
+                       gcvVERSION_MAJOR, gcvVERSION_MINOR,
+                       gcvVERSION_PATCH, gcvVERSION_BUILD);
 #endif
         break;
 
@@ -3475,7 +3472,7 @@ gckKERNEL_Recovery(
     gcmkONERROR(gckKERNEL_FlushTranslationCache(Kernel, cache, gcvNULL, 0));
 #endif
 
-    if (Kernel->stuckDump == gcdSTUCK_DUMP_MINIMAL)
+    if (Kernel->stuckDump == gcvSTUCK_DUMP_NONE)
     {
         gcmkPRINT("[galcore]: GPU[%d] hang, automatic recovery.", Kernel->core);
     }
@@ -3993,54 +3990,31 @@ gckKERNEL_GetGPUAddress(
     IN gckKERNEL Kernel,
     IN gctPOINTER Logical,
     IN gctBOOL InUserSpace,
+    IN gckVIRTUAL_COMMAND_BUFFER_PTR Buffer,
     OUT gctUINT32 * Address
     )
 {
-    gceSTATUS status;
-    gckVIRTUAL_COMMAND_BUFFER_PTR buffer;
+    gckVIRTUAL_COMMAND_BUFFER_PTR buffer = Buffer;
     gctPOINTER start;
-    gctUINT32 pid;
 
     gcmkHEADER_ARG("Logical = %x InUserSpace=%d.", Logical, InUserSpace);
 
-    gcmkVERIFY_OK(gckOS_GetProcessID(&pid));
-
-    status = gcvSTATUS_INVALID_ADDRESS;
-
-    gcmkVERIFY_OK(gckOS_AcquireMutex(Kernel->os, Kernel->virtualBufferLock, gcvINFINITE));
-
-    /* Walk all command buffer. */
-    for (buffer = Kernel->virtualBufferHead; buffer != gcvNULL; buffer = buffer->next)
+    if (InUserSpace)
     {
-        if (InUserSpace)
-        {
-            start = buffer->userLogical;
-        }
-        else
-        {
-            start = buffer->kernelLogical;
-        }
-
-        if (start == gcvNULL)
-        {
-            continue;
-        }
-
-        if (Logical >= start
-        && (Logical < (gctPOINTER)((gctUINT8_PTR)start + buffer->pageCount * 4096))
-        && pid == buffer->pid
-        )
-        {
-            * Address = buffer->gpuAddress + (gctUINT32)((gctUINT8_PTR)Logical - (gctUINT8_PTR)start);
-            status = gcvSTATUS_OK;
-            break;
-        }
+        start = buffer->userLogical;
+    }
+    else
+    {
+        start = buffer->kernelLogical;
     }
 
-    gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->virtualBufferLock));
+    gcmkASSERT(Logical >= start
+           && (Logical < (gctPOINTER)((gctUINT8_PTR)start + buffer->pageCount * 4096)));
+
+    * Address = buffer->gpuAddress + (gctUINT32)((gctUINT8_PTR)Logical - (gctUINT8_PTR)start);
 
     gcmkFOOTER_NO();
-    return status;
+    return gcvSTATUS_OK;
 }
 
 gceSTATUS
@@ -4091,7 +4065,9 @@ void
 gckLINKQUEUE_Enqueue(
     IN gckLINKQUEUE LinkQueue,
     IN gctUINT32 start,
-    IN gctUINT32 end
+    IN gctUINT32 end,
+    IN gctUINT32 LinkLow,
+    IN gctUINT32 LinkHigh
     )
 {
     if (LinkQueue->count == gcdLINK_QUEUE_SIZE)
@@ -4105,6 +4081,9 @@ gckLINKQUEUE_Enqueue(
 
     LinkQueue->data[LinkQueue->rear].start = start;
     LinkQueue->data[LinkQueue->rear].end = end;
+    LinkQueue->data[LinkQueue->rear].linkLow = LinkLow;
+    LinkQueue->data[LinkQueue->rear].linkHigh = LinkHigh;
+
 
     gcmkVERIFY_OK(
         gckOS_GetProcessID(&LinkQueue->data[LinkQueue->rear].pid));
@@ -4545,7 +4524,7 @@ gckKERNEL_SetRecovery(
     if (Recovery == gcvFALSE)
     {
         /* Dump stuck information if Recovery is disabled. */
-        Kernel->stuckDump = gcmMAX(StuckDump, gcdSTUCK_DUMP_MIDDLE);
+        Kernel->stuckDump = gcmMAX(StuckDump, gcvSTUCK_DUMP_USER_COMMAND);
     }
 
     return gcvSTATUS_OK;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
index 9376487..99491ab 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -26,6 +26,8 @@
 #include "gc_hal_kernel_hardware.h"
 #include "gc_hal_driver.h"
 
+#include "gc_hal_kernel_mutex.h"
+
 #if gcdENABLE_VG
 #include "gc_hal_kernel_vg.h"
 #endif
@@ -38,7 +40,6 @@
 extern "C" {
 #endif
 
-
 /*******************************************************************************
 ***** New MMU Defination *******************************************************/
 #define gcdMMU_MTLB_SHIFT           22
@@ -83,9 +84,21 @@ extern "C" {
 /*******************************************************************************
 ***** Stuck Dump Level ********************************************************/
 
-#define gcdSTUCK_DUMP_MINIMAL       1
-#define gcdSTUCK_DUMP_MIDDLE        2
-#define gcdSTUCK_DUMP_MAXIMAL       3
+/* Dump nonthing when stuck happens. */
+#define gcvSTUCK_DUMP_NONE          0
+
+/* Dump GPU state and memory near stuck point. */
+#define gcvSTUCK_DUMP_NEARBY_MEMORY 1
+
+/* Beside gcvSTUCK_DUMP_NEARBY_MEMORY, dump context buffer and user command buffer. */
+#define gcvSTUCK_DUMP_USER_COMMAND  2
+
+/* Beside gcvSTUCK_DUMP_USER_COMMAND, commit will be stall
+** to make sure command causing stuck isn't missed. */
+#define gcvSTUCK_DUMP_STALL_COMMAND 3
+
+/* Beside gcvSTUCK_DUMP_USER_COMMAND, dump kernel command buffer. */
+#define gcvSTUCK_DUMP_ALL_COMMAND   4
 
 /*******************************************************************************
 ***** Process Secure Cache ****************************************************/
@@ -643,7 +656,7 @@ struct _gckCOMMAND
     }
     queues[gcdCOMMAND_QUEUES];
 
-    gctPHYS_ADDR                physical;
+    gctUINT32                   physical;
     gctPOINTER                  logical;
     gctUINT32                   address;
     gctUINT32                   offset;
@@ -659,7 +672,7 @@ struct _gckCOMMAND
     gckCONTEXT                  currContext;
 
     /* Pointer to last WAIT command. */
-    gctPHYS_ADDR                waitPhysical;
+    gctUINT32                   waitPhysical;
     gctPOINTER                  waitLogical;
     gctUINT32                   waitSize;
 
@@ -829,7 +842,7 @@ gceSTATUS
 gckEVENT_Stop(
     IN gckEVENT Event,
     IN gctUINT32 ProcessID,
-    IN gctPHYS_ADDR Handle,
+    IN gctUINT32 Handle,
     IN gctPOINTER Logical,
     IN gctSIGNAL Signal,
     IN OUT gctUINT32 * waitSize
@@ -916,7 +929,7 @@ typedef union _gcuVIDMEM_NODE
 
 #if gcdENABLE_VG
         /* Physical address of this node, only meaningful when it is contiguous. */
-        gctUINT32               physicalAddress;
+        gctUINT64               physicalAddress;
 
         /* Kernel logical of this node. */
         gctPOINTER              kernelVirtual;
@@ -1233,6 +1246,7 @@ gckKERNEL_GetGPUAddress(
     IN gckKERNEL Kernel,
     IN gctPOINTER Logical,
     IN gctBOOL InUserSpace,
+    IN gckVIRTUAL_COMMAND_BUFFER_PTR Buffer,
     OUT gctUINT32 * Address
     );
 
@@ -1414,7 +1428,9 @@ void
 gckLINKQUEUE_Enqueue(
     IN gckLINKQUEUE LinkQueue,
     IN gctUINT32 start,
-    IN gctUINT32 end
+    IN gctUINT32 end,
+    IN gctUINT32 LinkLow,
+    IN gctUINT32 LinkHigh
     );
 
 void
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
index 72aa966..ea2504a 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -51,6 +51,7 @@ _NewQueue(
 {
     gceSTATUS status;
     gctINT currentIndex, newIndex;
+    gctPHYS_ADDR_T physical;
 
     gcmkHEADER_ARG("Command=0x%x", Command);
 
@@ -107,9 +108,11 @@ _NewQueue(
     gcmkONERROR(gckOS_GetPhysicalAddress(
         Command->os,
         Command->logical,
-        (gctUINT32 *) &Command->physical
+       &physical
         ));
 
+    gcmkSAFECASTPHYSADDRT(Command->physical, physical);
+
     if (currentIndex != -1)
     {
         /* Mark the command queue as available. */
@@ -472,7 +475,8 @@ _DumpKernelCommandBuffer(
     )
 {
     gctINT i;
-    gctUINT32 physical = 0;
+    gctUINT64 physical = 0;
+    gctUINT32 address;
     gctPOINTER entry   = gcvNULL;
 
     for (i = 0; i < gcdCOMMAND_QUEUES; i++)
@@ -483,7 +487,9 @@ _DumpKernelCommandBuffer(
 
         gcmkPRINT("Kernel command buffer %d\n", i);
 
-        _DumpBuffer(entry, physical, Command->pageSize);
+        gcmkSAFECASTPHYSADDRT(address, physical);
+
+        _DumpBuffer(entry, address, Command->pageSize);
     }
 }
 
@@ -992,7 +998,7 @@ gckCOMMAND_Start(
         ));
 
     Command->waitLogical  = (gctUINT8_PTR) Command->logical  + waitOffset;
-    Command->waitPhysical = (gctUINT8_PTR) Command->physical + waitOffset;
+    Command->waitPhysical =                Command->physical + waitOffset;
 
 #if gcdNONPAGED_MEMORY_CACHEABLE
     /* Flush the cache for the wait/link. */
@@ -1204,11 +1210,12 @@ gckCOMMAND_Commit(
     gcsQUEUE_PTR nextEventRecord;
     gctBOOL commandBufferMapped = gcvFALSE;
     gcoCMDBUF commandBufferObject = gcvNULL;
+    gctBOOL stall = gcvFALSE;
 
 #if !gcdNULL_DRIVER
     gcsCONTEXT_PTR contextBuffer;
     struct _gcoCMDBUF _commandBufferObject;
-    gctPHYS_ADDR commandBufferPhysical;
+    gctPHYS_ADDR_T commandBufferPhysical;
     gctUINT8_PTR commandBufferLogical = gcvNULL;
     gctUINT32 commandBufferAddress = 0;
     gctUINT8_PTR commandBufferLink = gcvNULL;
@@ -1230,11 +1237,11 @@ gckCOMMAND_Commit(
     gctPOINTER exitLogical;
     gctUINT32 exitAddress;
     gctUINT32 exitBytes;
-    gctPHYS_ADDR waitLinkPhysical;
+    gctUINT32 waitLinkPhysical;
     gctPOINTER waitLinkLogical;
     gctUINT32 waitLinkAddress;
     gctUINT32 waitLinkBytes;
-    gctPHYS_ADDR waitPhysical;
+    gctUINT32 waitPhysical;
     gctPOINTER waitLogical;
     gctUINT32 waitOffset;
     gctUINT32 waitSize;
@@ -1275,6 +1282,12 @@ gckCOMMAND_Commit(
     gctSIZE_T chipEnableBytes;
 #endif
 
+    gctUINT32 exitLinkLow = 0, exitLinkHigh = 0;
+    gctUINT32 entryLinkLow = 0, entryLinkHigh = 0;
+    gctUINT32 commandLinkLow = 0, commandLinkHigh = 0;
+
+    gckVIRTUAL_COMMAND_BUFFER_PTR virtualCommandBuffer = gcvNULL;
+
     gcmkHEADER_ARG(
         "Command=0x%x CommandBuffer=0x%x ProcessID=%d",
         Command, CommandBuffer, ProcessID
@@ -1377,7 +1390,7 @@ gckCOMMAND_Commit(
 
     /* Query the size of LINK command. */
     gcmkONERROR(gckHARDWARE_Link(
-        hardware, gcvNULL, 0, 0, &linkBytes
+        hardware, gcvNULL, 0, 0, &linkBytes, gcvNULL, gcvNULL
         ));
 
 #if gcdMULTI_GPU
@@ -1395,10 +1408,20 @@ gckCOMMAND_Commit(
     /* Get the hardware address. */
     if (Command->kernel->virtualCommandBuffer)
     {
+        gckKERNEL kernel = Command->kernel;
+
+        virtualCommandBuffer = gcmNAME_TO_PTR(commandBufferObject->physical);
+
+        if (virtualCommandBuffer == gcvNULL)
+        {
+            gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+        }
+
         gcmkONERROR(gckKERNEL_GetGPUAddress(
             Command->kernel,
             commandBufferLogical,
             gcvTRUE,
+            virtualCommandBuffer,
             &commandBufferAddress
             ));
     }
@@ -1416,7 +1439,7 @@ gckCOMMAND_Commit(
     gcmkONERROR(gckOS_UserLogicalToPhysical(
         Command->os,
         commandBufferLogical,
-        (gctUINT32_PTR)&commandBufferPhysical
+        &commandBufferPhysical
         ));
 
 #ifdef __QNXNTO__
@@ -1508,7 +1531,7 @@ gckCOMMAND_Commit(
     }
 
     /* Compute the location if WAIT/LINK command sequence. */
-    waitLinkPhysical = (gctUINT8_PTR) Command->physical + offset;
+    waitLinkPhysical =                Command->physical + offset;
     waitLinkLogical  = (gctUINT8_PTR) Command->logical  + offset;
     waitLinkAddress  =                Command->address  + offset;
 
@@ -1629,7 +1652,9 @@ gckCOMMAND_Commit(
                     contextBuffer->link3D,
                     commandBufferAddress + offset,
                     commandBufferSize    - offset,
-                    &linkBytes
+                    &linkBytes,
+                    &commandLinkLow,
+                    &commandLinkHigh
                     ));
 
                 /* Mark context as not dirty. */
@@ -1696,7 +1721,9 @@ gckCOMMAND_Commit(
                     contextBuffer->link2D,
                     commandBufferAddress + offset,
                     commandBufferSize    - offset,
-                    &linkBytes
+                    &linkBytes,
+                    &commandLinkLow,
+                    &commandLinkHigh
                     ));
             }
         }
@@ -1763,7 +1790,9 @@ gckCOMMAND_Commit(
                     contextBuffer->link3D,
                     commandBufferAddress + offset,
                     commandBufferSize    - offset,
-                    &linkBytes
+                    &linkBytes,
+                    &commandLinkLow,
+                    &commandLinkHigh
                     ));
             }
             else
@@ -1844,7 +1873,9 @@ gckCOMMAND_Commit(
                     contextBuffer->link3D,
                     commandBufferAddress + offset,
                     commandBufferSize    - offset,
-                    &linkBytes
+                    &linkBytes,
+                    &commandLinkLow,
+                    &commandLinkHigh
                     ));
             }
         }
@@ -1963,7 +1994,9 @@ gckCOMMAND_Commit(
                     contextBuffer->link3D,
                     commandBufferAddress + offset,
                     commandBufferSize    - offset,
-                    &linkBytes
+                    &linkBytes,
+                    &commandLinkLow,
+                    &commandLinkHigh
                     ));
             }
             else
@@ -2017,7 +2050,9 @@ gckCOMMAND_Commit(
                     contextBuffer->link2D,
                     commandBufferAddress + offset,
                     commandBufferSize    - offset,
-                    &linkBytes
+                    &linkBytes,
+                    &commandLinkLow,
+                    &commandLinkHigh
                     ));
             }
         }
@@ -2077,7 +2112,9 @@ gckCOMMAND_Commit(
                     contextBuffer->link3D,
                     commandBufferAddress + offset,
                     commandBufferSize    - offset,
-                    &linkBytes
+                    &linkBytes,
+                    &commandLinkLow,
+                    &commandLinkHigh
                     ));
             }
             else
@@ -2162,7 +2199,7 @@ gckCOMMAND_Commit(
         ));
 
     /* Compute the location if WAIT command. */
-    waitPhysical = (gctUINT8_PTR) waitLinkPhysical + waitOffset;
+    waitPhysical =                waitLinkPhysical + waitOffset;
     waitLogical  = (gctUINT8_PTR) waitLinkLogical  + waitOffset;
 
 #if gcdNONPAGED_MEMORY_CACHEABLE
@@ -2215,7 +2252,9 @@ gckCOMMAND_Commit(
         commandBufferLink,
         exitAddress,
         exitBytes,
-        &linkBytes
+        &linkBytes,
+        &exitLinkLow,
+        &exitLinkHigh
         ));
 #endif
 
@@ -2273,10 +2312,48 @@ gckCOMMAND_Commit(
         Command->waitLogical,
         entryAddress,
         entryBytes,
-        &Command->waitSize
+        &Command->waitSize,
+        &entryLinkLow,
+        &entryLinkHigh
         ));
 #endif
 
+#if gcdLINK_QUEUE_SIZE
+    if (Command->kernel->stuckDump >= gcvSTUCK_DUMP_USER_COMMAND)
+    {
+        gckLINKQUEUE_Enqueue(
+            &hardware->linkQueue,
+            entryAddress,
+            entryAddress + entryBytes,
+            entryLinkLow,
+            entryLinkHigh
+            );
+
+        if (commandBufferAddress + offset != entryAddress)
+        {
+            gckLINKQUEUE_Enqueue(
+                &hardware->linkQueue,
+                commandBufferAddress + offset,
+                commandBufferAddress + commandBufferSize,
+                commandLinkLow,
+                commandLinkHigh
+                );
+        }
+
+        if (Command->kernel->stuckDump >= gcvSTUCK_DUMP_ALL_COMMAND)
+        {
+            /* Dump kernel command.*/
+            gckLINKQUEUE_Enqueue(
+                &hardware->linkQueue,
+                exitAddress,
+                exitAddress + exitBytes,
+                exitLinkLow,
+                exitLinkHigh
+                );
+        }
+    }
+#endif
+
 #if gcdNONPAGED_MEMORY_CACHEABLE
     /* Flush the cache for the link. */
     gcmkONERROR(gckOS_CacheClean(
@@ -2347,10 +2424,38 @@ gckCOMMAND_Commit(
     gcmkONERROR(gckOS_ReleaseMutex(Command->os, Command->mutexContext));
     contextAcquired = gcvFALSE;
 
+    Command->commitStamp++;
+
+    stall = gcvFALSE;
+
+#if gcdLINK_QUEUE_SIZE
+    if (Command->kernel->stuckDump == gcvSTUCK_DUMP_STALL_COMMAND)
+    {
+        if ((Command->commitStamp % (gcdLINK_QUEUE_SIZE/2)) == 0)
+        {
+            /* If only context buffer and command buffer is recorded,
+            ** each commit costs 2 slot in queue, to make sure command
+            ** causing stuck is recorded, number of pending command buffer
+            ** is limited to (gckLINK_QUEUE_SIZE/2)
+            */
+            stall = gcvTRUE;
+        }
+    }
+#endif
+
     /* Release the command queue. */
     gcmkONERROR(gckCOMMAND_ExitCommit(Command, gcvFALSE));
     commitEntered = gcvFALSE;
 
+    if (stall)
+    {
+#if gcdMULTI_GPU
+        gcmkONERROR(gckCOMMAND_Stall(Command, gcvFALSE, ChipEnable));
+#else
+        gcmkONERROR(gckCOMMAND_Stall(Command, gcvFALSE));
+#endif
+    }
+
 #if VIVANTE_PROFILER_CONTEXT
     if(sequenceAcquired)
     {
@@ -2668,16 +2773,18 @@ gckCOMMAND_Execute(
 {
     gceSTATUS status;
 
-    gctPHYS_ADDR waitLinkPhysical;
+    gctUINT32 waitLinkPhysical;
     gctUINT8_PTR waitLinkLogical;
     gctUINT32 waitLinkOffset;
     gctUINT32 waitLinkBytes;
 
-    gctPHYS_ADDR waitPhysical;
+    gctUINT32 waitPhysical;
     gctPOINTER waitLogical;
     gctUINT32 waitOffset;
     gctUINT32 waitBytes;
 
+    gctUINT32 linkLow, linkHigh;
+
 #if gcdNONPAGED_MEMORY_CACHEABLE
     gctPHYS_ADDR execPhysical;
 #endif
@@ -2697,7 +2804,7 @@ gckCOMMAND_Execute(
     waitLinkBytes = Command->pageSize - waitLinkOffset;
 
     /* Compute the location if WAIT/LINK command sequence. */
-    waitLinkPhysical = (gctUINT8_PTR) Command->physical + waitLinkOffset;
+    waitLinkPhysical =                Command->physical + waitLinkOffset;
     waitLinkLogical  = (gctUINT8_PTR) Command->logical  + waitLinkOffset;
 
     /* Append WAIT/LINK in command queue. */
@@ -2711,8 +2818,8 @@ gckCOMMAND_Execute(
         ));
 
     /* Compute the location if WAIT command. */
-    waitPhysical = (gctUINT8_PTR) waitLinkPhysical + waitOffset;
-    waitLogical  =                waitLinkLogical  + waitOffset;
+    waitPhysical = waitLinkPhysical + waitOffset;
+    waitLogical  = waitLinkLogical  + waitOffset;
 
     /* Determine the location to jump to for the command buffer being
     ** scheduled. */
@@ -2756,9 +2863,24 @@ gckCOMMAND_Execute(
         Command->waitLogical,
         execAddress,
         execBytes,
-        &Command->waitSize
+        &Command->waitSize,
+        &linkLow,
+        &linkHigh
         ));
 
+#if gcdLINK_QUEUE_SIZE
+    if (Command->kernel->stuckDump >= gcvSTUCK_DUMP_ALL_COMMAND)
+    {
+        gckLINKQUEUE_Enqueue(
+            &Command->kernel->hardware->linkQueue,
+            execAddress,
+            execAddress + execBytes,
+            linkLow,
+            linkHigh
+            );
+    }
+#endif
+
 #if gcdNONPAGED_MEMORY_CACHEABLE
     /* Flush the cache. */
     gcmkONERROR(gckOS_CacheClean(
@@ -3136,20 +3258,19 @@ gckCOMMAND_DumpExecutingBuffer(
     )
 {
     gceSTATUS status;
-    gckVIRTUAL_COMMAND_BUFFER_PTR buffer;
+    gckVIRTUAL_COMMAND_BUFFER_PTR buffer = gcvNULL;
     gctUINT32 gpuAddress;
     gctSIZE_T pageCount;
     gctPOINTER entry;
     gckOS os = Command->os;
     gckKERNEL kernel = Command->kernel;
-    gctINT pid;
-    gctUINT32 i, rear;
-    gctUINT32 start, end;
+    gctUINT32 i;
     gctUINT32 dumpFront, dumpRear;
     gckLINKQUEUE queue = &kernel->hardware->linkQueue;
-    gckLINKQUEUE queueMirror;
-    gctUINT32 bytes;
+    gctSIZE_T bytes;
     gckLINKDATA linkData;
+    gctUINT32 offset;
+    gctPOINTER entryDump;
 
     gcmkPRINT("**************************\n");
     gcmkPRINT("**** COMMAND BUF DUMP ****\n");
@@ -3157,254 +3278,170 @@ gckCOMMAND_DumpExecutingBuffer(
 
     gcmkVERIFY_OK(gckOS_ReadRegisterEx(os, kernel->core, 0x664, &gpuAddress));
 
-    gcmkPRINT("DMA Address 0x%08X", gpuAddress);
+    gcmkPRINT("DMA Address 0x%08X, memory around:", gpuAddress);
 
-    if (Command->kernel->stuckDump > gcdSTUCK_DUMP_MIDDLE)
+    /* Search and dump memory around DMA address. */
+    if (kernel->virtualCommandBuffer)
     {
-        gcmkPRINT("Dump Level is %d", Command->kernel->stuckDump);
-
-        /* Duplicate queue because it will be changed.*/
-        gcmkONERROR(gckOS_AllocateMemory(os,
-                                         sizeof(struct _gckLINKQUEUE),
-                                         (gctPOINTER *)&queueMirror));
-
-        gckOS_MemCopy(queueMirror,
-                                  queue,
-                                  sizeof(struct _gckLINKQUEUE));
+        status = gckKERNEL_QueryGPUAddress(kernel, gpuAddress, &buffer);
+    }
+    else
+    {
+        status = gcvSTATUS_OK;
+    }
 
-        /* If kernel command buffer link to a context buffer, then link to a user command
-        ** buffer, the second link will be in queue first, so we must fix this.
-        **     In Queue:    C1 U1 U2 C2 U3 U4 U5 C3
-        **         Real: C1 X1 U1 C2 U2 U3 U4 C3 U5
-        ** Command buffer X1 which is after C1 is out of queue, so C1 is meaningless.
-        */
-        for (i = 0; i < gcdLINK_QUEUE_SIZE; i++)
+    if (gcmIS_SUCCESS(status))
+    {
+        if (kernel->virtualCommandBuffer)
         {
-            gckLINKQUEUE_GetData(queueMirror, i, &linkData);
-
-            status = gckKERNEL_QueryGPUAddress(kernel, linkData->start, &buffer);
-
-            if (gcmIS_ERROR(status))
-            {
-                /* Can't find it in virtual command buffer list, ignore it. */
-                continue;
-            }
-
-            if (buffer->kernelLogical)
-            {
-                /* It is a context buffer. */
-                if (i == 0)
-                {
-                    /* The real command buffer is out, so clear this slot. */
-                    linkData->start = 0;
-                    linkData->end = 0;
-                    linkData->pid = 0;
-                }
-                else
-                {
-                    /* switch context buffer and command buffer. */
-                    struct _gckLINKDATA tmp = *linkData;
-                    gckLINKDATA linkDataPrevious;
-
-                    gckLINKQUEUE_GetData(queueMirror, i - 1, &linkDataPrevious);
-                    *linkData = *linkDataPrevious;
-                    *linkDataPrevious = tmp;
-               }
-            }
-        }
+            gcmkVERIFY_OK(gckOS_CreateKernelVirtualMapping(
+                os, buffer->physical, buffer->bytes, &entry, &pageCount));
 
-        /* Clear search result. */
-        dumpFront = dumpRear = gcvINFINITE;
+            offset = gpuAddress - buffer->gpuAddress;
 
-        gcmkPRINT("Link Stack:");
+            entryDump  = entry;
 
-        /* Search stuck address in link queue from rear. */
-        rear = gcdLINK_QUEUE_SIZE - 1;
-        for (i = 0; i < gcdLINK_QUEUE_SIZE; i++)
-        {
-            gckLINKQUEUE_GetData(queueMirror, rear, &linkData);
-
-            start = linkData->start;
-            end = linkData->end;
-            pid = linkData->pid;
+            /* Dump one pages. */
+            bytes = 4096;
 
-            if (gpuAddress >= start && gpuAddress < end)
-            {
-                /* Find latest matched command buffer. */
-                gcmkPRINT("  %d, [%08X - %08X]", pid, start, end);
-
-                /* Initiliaze dump information. */
-                dumpFront = dumpRear = rear;
-            }
+            /* Align to page. */
+            offset &= 0xfffff000;
 
-            /* Advance to previous one. */
-            rear--;
+            /* Kernel address of page where stall point stay. */
+            entryDump = (gctUINT8_PTR)entryDump + offset;
 
-            if (dumpFront != gcvINFINITE)
-            {
-                break;
-            }
+            /* Align to page. */
+            gpuAddress &= 0xfffff000;
         }
-
-        if (dumpFront == gcvINFINITE)
+        else
         {
-            /* Can't find matched record in link queue, dump kernel command buffer. */
-            _DumpKernelCommandBuffer(Command);
+            gcmkVERIFY_OK(gckOS_MapPhysical(os, gpuAddress, 4096, &entry));
 
-            /* Free local copy. */
-            gcmkOS_SAFE_FREE(os, queueMirror);
-            return gcvSTATUS_OK;
+            /* Align to page start. */
+            entryDump  = (gctPOINTER)((gctUINTPTR_T)entry & ~0xFFF);
+            gpuAddress = gpuAddress & ~0xFFF;
+            bytes      = 4096;
         }
 
-        /* Search the last context buffer linked. */
-        while (rear > 0)
-        {
-            gckLINKQUEUE_GetData(queueMirror, rear, &linkData);
-
-            gcmkPRINT("  %d, [%08X - %08X]",
-                      linkData->pid,
-                      linkData->start,
-                      linkData->end);
+        gcmkPRINT("User Command Buffer:\n");
+        _DumpBuffer(entryDump, gpuAddress, bytes);
 
-            status = gckKERNEL_QueryGPUAddress(kernel, linkData->start, &buffer);
-
-            if (gcmIS_SUCCESS(status) && buffer->kernelLogical)
-            {
-                /* Find a context buffer. */
-                dumpFront = rear;
-                break;
-            }
-
-            rear--;
+        if (kernel->virtualCommandBuffer)
+        {
+            gcmkVERIFY_OK(gckOS_DestroyKernelVirtualMapping(
+                os, buffer->physical, buffer->bytes, entry));
         }
-
-        if (dumpFront == dumpRear)
+        else
         {
-            /* No context buffer is found, dump all we got.*/
-            dumpFront = 0;
+             gcmkVERIFY_OK(gckOS_UnmapPhysical(os, entry, 4096));
         }
+    }
+    else
+    {
+        _DumpKernelCommandBuffer(Command);
+    }
+
+    /* Dump link queue. */
+    if (Command->kernel->stuckDump >= gcvSTUCK_DUMP_USER_COMMAND)
+    {
+        gcmkPRINT("Dump Level is %d, dump link queue:",
+                  Command->kernel->stuckDump);
+
+        dumpRear  = gcdLINK_QUEUE_SIZE - 1;
+        dumpFront = 0;
 
-        /* Dump from last context buffer to last command buffer where hang happens. */
         for (i = dumpFront; i <= dumpRear; i++)
         {
-            gckLINKQUEUE_GetData(queueMirror, i, &linkData);
+            gckLINKQUEUE_GetData(queue, i, &linkData);
 
             /* Get gpu address of this command buffer. */
             gpuAddress = linkData->start;
             bytes = linkData->end - gpuAddress;
 
-            /* Get the whole buffer. */
-            status = gckKERNEL_QueryGPUAddress(kernel, gpuAddress, &buffer);
-
-            if (gcmIS_ERROR(status))
-            {
-                gcmkPRINT("Buffer [%08X - %08X] is lost or not belong to current process",
-                          linkData->start,
-                          linkData->end);
-                continue;
-            }
-
-            /* Get kernel logical for dump. */
-            if (buffer->kernelLogical)
+            if (kernel->virtualCommandBuffer)
             {
-                /* Get kernel logical directly if it is a context buffer. */
-                entry = buffer->kernelLogical;
-                gcmkPRINT("Context Buffer:");
-            }
-            else
-            {
-                /* Make it accessiable by kernel if it is a user command buffer. */
-                gcmkVERIFY_OK(
-                    gckOS_CreateKernelVirtualMapping(os,
-                                                     buffer->physical,
-                                                     buffer->bytes,
-                                                     &entry,
-                                                     &pageCount));
-                gcmkPRINT("User Command Buffer:");
-            }
+                buffer = gcvNULL;
 
-            /* Dump from the entry. */
-            _DumpBuffer((gctUINT8_PTR)entry + (gpuAddress - buffer->gpuAddress), gpuAddress, bytes);
+                /* Get the whole buffer. */
+                status = gckKERNEL_QueryGPUAddress(kernel, gpuAddress, &buffer);
 
-            /* Release kernel logical address if neccessary. */
-            if (!buffer->kernelLogical)
-            {
-                gcmkVERIFY_OK(
-                    gckOS_DestroyKernelVirtualMapping(os,
-                                                      buffer->physical,
-                                                      buffer->bytes,
-                                                      entry));
-            }
-        }
+                if (gcmIS_ERROR(status))
+                {
+                    /* Get kernel address of kernel command buffer. */
+                    status = gckCOMMAND_AddressInKernelCommandBuffer(
+                             kernel->command, gpuAddress, &entry);
+
+                    if (gcmIS_ERROR(status))
+                    {
+                        gcmkPRINT("Buffer [%08X - %08X] not found, may be freed",
+                                  linkData->start,
+                                  linkData->end);
+                        continue;
+                    }
 
-        /* Free local copy. */
-        gcmkOS_SAFE_FREE(os, queueMirror);
-        return gcvSTATUS_OK;
-    OnError:
-        return status;
-    }
-    else
-    {
-        gcmkPRINT("Dump Level is %d, dump memory near the stuck address",
-                  Command->kernel->stuckDump);
+                    offset = 0;
+                    gcmkPRINT("Kernel Command Buffer: %08X, %08X", linkData->linkLow, linkData->linkHigh);
+                }
+                else
+                {
+                    /* Get kernel logical for dump. */
+                    if (buffer->kernelLogical)
+                    {
+                        /* Get kernel logical directly if it is a context buffer. */
+                        entry = buffer->kernelLogical;
+                        gcmkPRINT("Context Buffer: %08X, %08X", linkData->linkLow, linkData->linkHigh);
+                    }
+                    else
+                    {
+                        /* Make it accessiable by kernel if it is a user command buffer. */
+                        gcmkVERIFY_OK(
+                            gckOS_CreateKernelVirtualMapping(os,
+                                                             buffer->physical,
+                                                             buffer->bytes,
+                                                             &entry,
+                                                             &pageCount));
+                         gcmkPRINT("User Command Buffer: %08X, %08X", linkData->linkLow, linkData->linkHigh);
+                    }
+
+                    offset = gpuAddress - buffer->gpuAddress;
+                }
 
-        /* Without link queue information, we don't know the entry of last command
-        ** buffer, just dump the page where GPU stuck. */
-        status = gckKERNEL_QueryGPUAddress(kernel, gpuAddress, &buffer);
+                /* Dump from the entry. */
+                _DumpBuffer((gctUINT8_PTR)entry + offset, gpuAddress, bytes);
 
-        if (gcmIS_SUCCESS(status))
-        {
-            gcmkVERIFY_OK(
-                gckOS_CreateKernelVirtualMapping(os,
-                                                 buffer->physical,
-                                                 buffer->bytes,
-                                                 &entry,
-                                                 &pageCount));
-
-            if (entry)
+                /* Release kernel logical address if neccessary. */
+                if (buffer && !buffer->kernelLogical)
+                {
+                    gcmkVERIFY_OK(
+                        gckOS_DestroyKernelVirtualMapping(os,
+                                                          buffer->physical,
+                                                          buffer->bytes,
+                                                          entry));
+                }
+            }
+            else
             {
-                gctUINT32 offset = gpuAddress - buffer->gpuAddress;
-                gctPOINTER entryDump = entry;
-
-                /* Dump one pages. */
-                gctUINT32 bytes = 4096;
-
-                /* Align to page. */
-                offset &= 0xfffff000;
+                gcmkVERIFY_OK(gckOS_MapPhysical(os, gpuAddress, bytes, &entry));
 
-                /* Kernel address of page where stall point stay. */
-                entryDump = (gctUINT8_PTR)entryDump + offset;
+                gcmkPRINT("Command Buffer: %08X, %08X", linkData->linkLow, linkData->linkHigh);
 
-                /* Align to page. */
-                gpuAddress &= 0xfffff000;
+                _DumpBuffer((gctUINT8_PTR)entry, gpuAddress, bytes);
 
-                gcmkPRINT("User Command Buffer:\n");
-                _DumpBuffer(entryDump, gpuAddress, bytes);
+                gcmkVERIFY_OK(gckOS_UnmapPhysical(os, entry, bytes));
             }
-
-            gcmkVERIFY_OK(
-                gckOS_DestroyKernelVirtualMapping(os,
-                                                  buffer->physical,
-                                                  buffer->bytes,
-                                                  entry));
-        }
-        else
-        {
-            _DumpKernelCommandBuffer(Command);
         }
-
-        return gcvSTATUS_OK;
     }
+
+    return gcvSTATUS_OK;
 }
 
 gceSTATUS
 gckCOMMAND_AddressInKernelCommandBuffer(
     IN gckCOMMAND Command,
     IN gctUINT32 Address,
-    OUT gctBOOL *In
+    OUT gctPOINTER * Pointer
     )
 {
-    gctBOOL in = gcvFALSE;
     gctINT i;
 
     for (i = 0; i < gcdCOMMAND_QUEUES; i++)
@@ -3413,11 +3450,13 @@ gckCOMMAND_AddressInKernelCommandBuffer(
          && (Address < (Command->queues[i].address + Command->pageSize))
         )
         {
-            in = gcvTRUE;
-            break;
+            *Pointer = (gctUINT8_PTR)Command->queues[i].logical
+                     + (Address - Command->queues[i].address)
+                     ;
+
+            return gcvSTATUS_OK;
         }
     }
 
-    *In = in;
-    return gcvSTATUS_OK;
+    return gcvSTATUS_NOT_FOUND;
 }
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
index 0eafaf6..6864dba 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -27,6 +27,16 @@
 
 #define _GC_OBJ_ZONE            gcvZONE_COMMAND
 
+#ifdef __QNXNTO__
+extern gceSTATUS
+drv_signal_mgr_add(
+    gctUINT32 Pid,
+    gctINT32 Coid,
+    gctINT32 Rcvid,
+    gctUINT64 Signal,
+    gctPOINTER *Handle);
+#endif
+
 /******************************************************************************\
 *********************************** Debugging **********************************
 \******************************************************************************/
@@ -854,19 +864,34 @@ _ScheduleTasks(
                         userTask->size
                         );
 
+                    /* Copy the task data. */
+                    gcmkVERIFY_OK(gckOS_MemCopy(
+                        kernelTask, taskHeader, userTask->size
+                        ));
+
 #ifdef __QNXNTO__
                     if (taskHeader->id == gcvTASK_SIGNAL)
                     {
-                        ((gcsTASK_SIGNAL_PTR)taskHeader)->coid  = TaskTable->coid;
-                        ((gcsTASK_SIGNAL_PTR)taskHeader)->rcvid = TaskTable->rcvid;
+                        gcsTASK_SIGNAL_PTR taskSignal = (gcsTASK_SIGNAL_PTR)kernelTask;
+                        gctPOINTER signal;
+                        gctUINT32 pid;
+
+                        gcmkVERIFY_OK(gckOS_GetProcessID(&pid));
+
+                        taskSignal->coid  = TaskTable->coid;
+                        taskSignal->rcvid = TaskTable->rcvid;
+
+                        gcmkERR_BREAK(drv_signal_mgr_add(
+                            pid,
+                            taskSignal->coid,
+                            taskSignal->rcvid,
+                            gcmPTR_TO_UINT64(taskSignal->signal),
+                            &signal));
+
+                        taskSignal->signal = signal;
                     }
 #endif
 
-                    /* Copy the task data. */
-                    gcmkVERIFY_OK(gckOS_MemCopy(
-                        kernelTask, taskHeader, userTask->size
-                        ));
-
                     /* Advance to the next task. */
                     kernelTask += userTask->size;
                     userTask    = userTask->next;
@@ -974,7 +999,7 @@ _HardwareToKernel(
     }
     else
     {
-        nodePhysical = Node->Virtual.physicalAddress;
+        gcmkSAFECASTPHYSADDRT(nodePhysical, Node->Virtual.physicalAddress);
         bytes = Node->Virtual.bytes;
         logical = &Node->Virtual.kernelVirtual;
     }
@@ -1074,6 +1099,7 @@ _AllocateLinear(
     gctPHYS_ADDR physical;
     gctUINT32 address;
     gctSIZE_T size = Size;
+    gctPHYS_ADDR_T paddr;
 
     do
     {
@@ -1085,7 +1111,9 @@ _AllocateLinear(
             &logical
             ));
 
-        gcmkERR_BREAK(gckOS_GetPhysicalAddress(Command->os, logical, &address));
+        gcmkERR_BREAK(gckOS_GetPhysicalAddress(Command->os, logical, &paddr));
+
+        gcmkSAFECASTPHYSADDRT(address, paddr);
 
         /* Set return values. */
         * Node    = physical;
@@ -3549,15 +3577,16 @@ gckVGCOMMAND_Commit(
                 /* Set the signal to avoid user waiting. */
 #ifdef __QNXNTO__
                 gcmkERR_BREAK(gckOS_UserSignal(
-                    Command->os, Context->signal, Context->rcvid, Context->coid
+                    Command->os,
+                    Context->userSignal,
+                    Context->rcvid,
+                    Context->coid
                     ));
 #else
                 gcmkERR_BREAK(gckOS_UserSignal(
                     Command->os, Context->signal, Context->process
                     ));
-
-#endif /* __QNXNTO__ */
-
+#endif
             }
             else
             {
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
index 021f633..21174f4 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -1558,72 +1558,71 @@ gckKERNEL_QueryProcessDB(
     Type &= gcdDATABASE_TYPE_MASK;
 
     /* Find the database. */
-    if(Type != gcvDB_IDLE)
-    {
-        gcmkONERROR(
-            gckKERNEL_FindDatabase(Kernel, ProcessID, LastProcessID, &database));
-
-        gcmkVERIFY_OK(gckOS_AcquireMutex(Kernel->os, database->counterMutex, gcvINFINITE));
-
-        /* Get pointer to counters. */
-        switch (Type)
-        {
-        case gcvDB_VIDEO_MEMORY:
-            if (vidMemPool != gcvPOOL_UNKNOWN)
-            {
-                gckOS_MemCopy(&Info->counters,
-                              &database->vidMemPool[vidMemPool],
-                              gcmSIZEOF(database->vidMemPool[vidMemPool]));
-            }
-            else
-            {
-                gckOS_MemCopy(&Info->counters,
-                              &database->vidMem,
-                              gcmSIZEOF(database->vidMem));
-            }
-            break;
+    gcmkONERROR(
+        gckKERNEL_FindDatabase(Kernel, ProcessID, LastProcessID, &database));
 
-        case gcvDB_NON_PAGED:
-            gckOS_MemCopy(&Info->counters,
-                                      &database->nonPaged,
-                                      gcmSIZEOF(database->vidMem));
-            break;
 
-        case gcvDB_CONTIGUOUS:
-            gckOS_MemCopy(&Info->counters,
-                                      &database->contiguous,
-                                      gcmSIZEOF(database->vidMem));
-            break;
+    gcmkVERIFY_OK(gckOS_AcquireMutex(Kernel->os, database->counterMutex, gcvINFINITE));
 
-        case gcvDB_MAP_MEMORY:
+    /* Get pointer to counters. */
+    switch (Type)
+    {
+    case gcvDB_VIDEO_MEMORY:
+        if (vidMemPool != gcvPOOL_UNKNOWN)
+        {
             gckOS_MemCopy(&Info->counters,
-                                      &database->mapMemory,
-                                      gcmSIZEOF(database->mapMemory));
-            break;
-
-        case gcvDB_MAP_USER_MEMORY:
+                          &database->vidMemPool[vidMemPool],
+                          gcmSIZEOF(database->vidMemPool[vidMemPool]));
+        }
+        else
+        {
             gckOS_MemCopy(&Info->counters,
-                                      &database->mapUserMemory,
-                                      gcmSIZEOF(database->mapUserMemory));
-            break;
+                          &database->vidMem,
+                          gcmSIZEOF(database->vidMem));
+        }
+        break;
 
-        case gcvDB_COMMAND_BUFFER:
-            gckOS_MemCopy(&Info->counters,
-                                      &database->virtualCommandBuffer,
-                                      gcmSIZEOF(database->virtualCommandBuffer));
-            break;
+    case gcvDB_NON_PAGED:
+        gckOS_MemCopy(&Info->counters,
+                                  &database->nonPaged,
+                                  gcmSIZEOF(database->vidMem));
+        break;
 
-        default:
-            break;
-        }
+    case gcvDB_CONTIGUOUS:
+        gckOS_MemCopy(&Info->counters,
+                                  &database->contiguous,
+                                  gcmSIZEOF(database->vidMem));
+        break;
 
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, database->counterMutex));
-    }
-    else
-    {
+    case gcvDB_IDLE:
         Info->time           = Kernel->db->idleTime;
         Kernel->db->idleTime = 0;
+        break;
+
+    case gcvDB_MAP_MEMORY:
+        gckOS_MemCopy(&Info->counters,
+                                  &database->mapMemory,
+                                  gcmSIZEOF(database->mapMemory));
+        break;
+
+    case gcvDB_MAP_USER_MEMORY:
+        gckOS_MemCopy(&Info->counters,
+                                  &database->mapUserMemory,
+                                  gcmSIZEOF(database->mapUserMemory));
+        break;
+
+    case gcvDB_COMMAND_BUFFER:
+        gckOS_MemCopy(&Info->counters,
+                                  &database->virtualCommandBuffer,
+                                  gcmSIZEOF(database->virtualCommandBuffer));
+        break;
+
+    default:
+        break;
     }
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, database->counterMutex));
+
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
index b2b078e..9393932 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -1285,7 +1285,7 @@ _AppendPrefix(
     item->prefixData = prefixData;
 
     /* Copy argument value. */
-    memcpy(prefixData, Data, gcdPREFIX_SIZE);
+    gcmkMEMCPY(prefixData, Data, gcdPREFIX_SIZE);
 
 #if gcdALIGNBYSIZE
     /* Compute the actual node size. */
@@ -1347,7 +1347,7 @@ _AppendString(
     /* Copy argument value. */
     if (ArgumentSize != 0)
     {
-        memcpy(messageData, Data, ArgumentSize);
+        gcmkMEMCPY(messageData, Data, ArgumentSize);
     }
 
 #if gcdALIGNBYSIZE
@@ -1422,12 +1422,12 @@ _AppendCopy(
     item->messageDataSize = ArgumentSize;
 
     /* Copy the message. */
-    memcpy((gctPOINTER) message, Message, messageLength);
+    gcmkMEMCPY((gctPOINTER) message, Message, messageLength);
 
     /* Copy argument value. */
     if (ArgumentSize != 0)
     {
-        memcpy(messageData, Data, ArgumentSize);
+        gcmkMEMCPY(messageData, Data, ArgumentSize);
     }
 
 #if gcdALIGNBYSIZE
@@ -1505,13 +1505,13 @@ _AppendBuffer(
 #endif
 
     /* Copy prefix data. */
-    memcpy(prefixData, PrefixData, gcdPREFIX_SIZE);
+    gcmkMEMCPY(prefixData, PrefixData, gcdPREFIX_SIZE);
 
     /* Compute the data pointer. */
     data = prefixData + gcdPREFIX_SIZE;
 
     /* Copy argument value. */
-    memcpy(data, Data, DataSize);
+    gcmkMEMCPY(data, Data, DataSize);
 
 #if gcdALIGNBYSIZE
     /* Compute the actual node size. */
@@ -1548,7 +1548,7 @@ _AppendBuffer(
     item->address  = Address;
 
     /* Copy argument value. */
-    memcpy(item + 1, Data, DataSize);
+    gcmkMEMCPY(item + 1, Data, DataSize);
 #endif
 }
 #endif
@@ -1940,6 +1940,7 @@ gckOS_DumpBuffer(
     IN gctBOOL CopyMessage
     )
 {
+    gctPHYS_ADDR_T physical;
     gctUINT32 address                   = 0;
     gcsBUFFERED_OUTPUT_PTR outputBuffer = gcvNULL;
     static gctBOOL userLocked;
@@ -1984,7 +1985,8 @@ gckOS_DumpBuffer(
         /* Get the physical address of the buffer. */
         if (Type != gceDUMP_BUFFER_FROM_USER)
         {
-            gcmkVERIFY_OK(gckOS_GetPhysicalAddress(Os, Buffer, &address));
+            gcmkVERIFY_OK(gckOS_GetPhysicalAddress(Os, Buffer, &physical));
+            gcmkSAFECASTPHYSADDRT(address, physical);
         }
         else
         {
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
index ed539f6..7aa0dfe 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -1494,12 +1494,15 @@ gckEVENT_Signal(
     /* Mark the event as a signal. */
     iface.command            = gcvHAL_SIGNAL;
     iface.u.Signal.signal    = gcmPTR_TO_UINT64(Signal);
+    iface.u.Signal.auxSignal = 0;
+    iface.u.Signal.process   = 0;
+
 #ifdef __QNXNTO__
     iface.u.Signal.coid      = 0;
     iface.u.Signal.rcvid     = 0;
+
+    gcmkONERROR(gckOS_SignalPending(Event->os, Signal));
 #endif
-    iface.u.Signal.auxSignal = 0;
-    iface.u.Signal.process   = 0;
 
     /* Append it to the queue. */
     gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
@@ -2171,7 +2174,7 @@ gckEVENT_Interrupt(
         Data &= ~0x20000000;
 
 #if gcdMULTI_GPU
-        if (Event->kernel->core == gcvCORE_MAJOR)
+        if (CoreId == gcvCORE_3D_0_ID)
 #endif
         {
             /* Get first entry information. */
@@ -2189,6 +2192,20 @@ gckEVENT_Interrupt(
             }
             while (idle != 0x7FFFFFFF);
 
+#if gcdMULTI_GPU
+            /* Make sure FE of another GPU is idle. */
+            do
+            {
+                gcmkVERIFY_OK(gckOS_ReadRegisterByCoreId(
+                    Event->os,
+                    Event->kernel->core,
+                    gcvCORE_3D_1_ID,
+                    0x4,
+                    &idle));
+            }
+            while (idle != 0x7FFFFFFF);
+#endif
+
             /* Start Command Parser. */
             gcmkVERIFY_OK(gckHARDWARE_Execute(
                 Event->kernel->hardware,
@@ -2246,6 +2263,9 @@ gckEVENT_Interrupt(
 #endif
 
 #if gcdINTERRUPT_STATISTIC
+#if gcdMULTI_GPU
+    if (CoreId == gcvCORE_3D_0_ID)
+#endif
     {
         gctINT j = 0;
         gctINT32 oldValue;
@@ -2448,10 +2468,8 @@ gckEVENT_Notify(
 
         if (pending & 0x80000000)
         {
-            gctUINT32 AQAxiStatus = 0;
-            gckOS_ReadRegisterEx(Event->os, Event->kernel->hardware->core, 0xC, &AQAxiStatus);
-
-            gcmkPRINT("GPU[%d]: AXI BUS ERROR, AQAxiStatus=0x%x\n", Event->kernel->hardware->core, AQAxiStatus);
+            gcmkPRINT("[galcore]: AXI BUS ERROR");
+            gckHARDWARE_DumpGPUState(Event->kernel->hardware);
             pending &= 0x7FFFFFFF;
         }
 
@@ -2459,6 +2477,8 @@ gckEVENT_Notify(
         {
             gckHARDWARE_DumpMMUException(Event->kernel->hardware);
 
+            gckHARDWARE_DumpGPUState(Event->kernel->hardware);
+
             pending &= 0xBFFFFFFF;
         }
 
@@ -2882,9 +2902,8 @@ gckEVENT_Notify(
                 {
                     /* Kernel signal. */
                     gcmkERR_BREAK(
-                        gckOS_Signal(Event->os,
-                                     signal,
-                                     gcvTRUE));
+                        gckOS_SignalPulse(Event->os,
+                                          signal));
                 }
                 else
                 {
@@ -3231,7 +3250,7 @@ gceSTATUS
 gckEVENT_Stop(
     IN gckEVENT Event,
     IN gctUINT32 ProcessID,
-    IN gctPHYS_ADDR Handle,
+    IN gctUINT32 Handle,
     IN gctPOINTER Logical,
     IN gctSIGNAL Signal,
     IN OUT gctUINT32 * waitSize
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c
index be0a60e..a43f4a3 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c
index 5716223..4e580ca 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
index 7f545f24..c774ee5 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -307,9 +307,11 @@ OnError:
 }
 
 static gctUINT32
-_SetPage(gctUINT32 PageAddress)
+_SetPage(gctUINT32 PageAddress, gctUINT32 PageAddressExt)
 {
     return PageAddress
+           /* AddressExt */
+           | (PageAddressExt << 4)
            /* writable */
            | (1 << 2)
            /* Ignore exception */
@@ -441,6 +443,7 @@ _FillFlatMapping(
     gctUINT32 sStart = (start & gcdMMU_STLB_64K_MASK) >> gcdMMU_STLB_64K_SHIFT;
     gctUINT32 sEnd = (end & gcdMMU_STLB_64K_MASK) >> gcdMMU_STLB_64K_SHIFT;
     gctBOOL ace = gckHARDWARE_IsFeatureAvailable(Mmu->hardware, gcvFEATURE_ACE);
+    gctPHYS_ADDR_T physical;
 
     /* Grab the mutex. */
     gcmkONERROR(gckOS_AcquireMutex(Mmu->os, Mmu->pageTableMutex, gcvINFINITE));
@@ -489,7 +492,9 @@ _FillFlatMapping(
             gcmkONERROR(gckOS_GetPhysicalAddress(
                 Mmu->os,
                 stlb->logical,
-                &stlb->physBase));
+                &physical));
+
+            gcmkSAFECASTPHYSADDRT(stlb->physBase, physical);
 
             if (stlb->physBase & (gcdMMU_STLB_64K_SIZE - 1))
             {
@@ -532,7 +537,7 @@ _FillFlatMapping(
             while (sStart <= last)
             {
                 gcmkASSERT(!(start & gcdMMU_PAGE_64K_MASK));
-                _WritePageEntry(stlb->logical + sStart, _SetPage(start));
+                _WritePageEntry(stlb->logical + sStart, _SetPage(start, 0));
 #if gcdMMU_TABLE_DUMP
                 gckOS_Print("%s(%d): insert STLB[%d]: %08x\n",
                     __FUNCTION__, __LINE__,
@@ -700,7 +705,8 @@ _SetupDynamicSpace(
     gceSTATUS status;
     gcsDynamicSpaceNode_PTR nodeArray = gcvNULL;
     gctINT i, nodeArraySize = 0;
-    gctUINT32 physical;
+    gctPHYS_ADDR_T physical;
+    gctUINT32 address;
     gctINT numEntries = 0;
     gctUINT32_PTR map;
     gctBOOL acquired = gcvFALSE;
@@ -759,6 +765,8 @@ _SetupDynamicSpace(
                 Mmu->pageTableLogical,
                 &physical));
 
+    gcmkSAFECASTPHYSADDRT(address, physical);
+
     /* Grab the mutex. */
     gcmkONERROR(gckOS_AcquireMutex(Mmu->os, Mmu->pageTableMutex, gcvINFINITE));
     acquired = gcvTRUE;
@@ -768,7 +776,7 @@ _SetupDynamicSpace(
          i < (gctINT)Mmu->dynamicMappingStart + numEntries;
          i++)
     {
-        mtlbEntry = physical
+        mtlbEntry = address
                   /* 4KB page size */
                   | (0 << 2)
                   /* Ignore exception */
@@ -791,7 +799,7 @@ _SetupDynamicSpace(
                 i,
                 _ReadPageEntry(Mmu->mtlbLogical + i));
 #endif
-        physical += gcdMMU_STLB_4K_SIZE;
+        address += gcdMMU_STLB_4K_SIZE;
     }
 
     /* Release the mutex. */
@@ -862,6 +870,7 @@ _Construct(
     gctUINT32 physBase;
     gctUINT32 physSize;
     gctUINT32 gpuAddress;
+    gctPHYS_ADDR_T gpuPhysical;
 
     gcmkHEADER_ARG("Kernel=0x%x MmuSize=%lu", Kernel, MmuSize);
 
@@ -983,7 +992,9 @@ _Construct(
             gckOS_QueryOption(mmu->os, "physSize", &physSize));
 
         gcmkONERROR(
-            gckOS_CPUPhysicalToGPUPhysical(mmu->os, physBase, &gpuAddress));
+            gckOS_CPUPhysicalToGPUPhysical(mmu->os, physBase, &gpuPhysical));
+
+        gcmkSAFECASTPHYSADDRT(gpuAddress, gpuPhysical);
 
         /* Setup [physBase - physSize) flat mapping. */
         gcmkONERROR(_FillFlatMapping(
@@ -1500,6 +1511,9 @@ _AllocatePages(
             {
                 /* Time to move out the trash! */
                 gcmkONERROR(_Collect(Mmu));
+
+                /* We are going to search from start, so reset previous to start. */
+                previous = ~0U;
             }
             else
             {
@@ -1809,7 +1823,7 @@ gckMMU_FreePages(
 gceSTATUS
 gckMMU_SetPage(
     IN gckMMU Mmu,
-    IN gctUINT32 PageAddress,
+    IN gctPHYS_ADDR_T PageAddress,
     IN gctUINT32 *PageEntry
     )
 {
@@ -1819,6 +1833,8 @@ gckMMU_SetPage(
     gckMMU mmu;
     gctUINT32 offset = (gctUINT32)PageEntry - (gctUINT32)Mmu->pageTableLogical;
 #endif
+    gctUINT32 addressExt;
+    gctUINT32 address;
 
     gcmkHEADER_ARG("Mmu=0x%x", Mmu);
 
@@ -1827,13 +1843,18 @@ gckMMU_SetPage(
     gcmkVERIFY_ARGUMENT(PageEntry != gcvNULL);
     gcmkVERIFY_ARGUMENT(!(PageAddress & 0xFFF));
 
+    /* [31:0]. */
+    address    = (gctUINT32)(PageAddress & 0xFFFFFFFF);
+    /* [39:32]. */
+    addressExt = (gctUINT32)((PageAddress >> 32) & 0xFF);
+
     if (Mmu->hardware->mmuVersion == 0)
     {
-        _WritePageEntry(PageEntry, PageAddress);
+        _WritePageEntry(PageEntry, address);
     }
     else
     {
-        _WritePageEntry(PageEntry, _SetPage(PageAddress));
+        _WritePageEntry(PageEntry, _SetPage(address, addressExt));
     }
 
 #if gcdMIRROR_PAGETABLE
@@ -1847,11 +1868,11 @@ gckMMU_SetPage(
 
             if (mmu->hardware->mmuVersion == 0)
             {
-                _WritePageEntry(pageEntry, PageAddress);
+                _WritePageEntry(pageEntry, address);
             }
             else
             {
-                _WritePageEntry(pageEntry, _SetPage(PageAddress));
+                _WritePageEntry(pageEntry, _SetPage(address, addressExt));
             }
         }
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c
index 58c33b1..6da3473 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c
index b060310..afff338 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h
index 9ea3d53..64ed891 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_security.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_security.c
index 54e5ce3..9a45efe 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_security.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_security.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -146,6 +146,10 @@ gckKERNEL_SecurityExecute(
     )
 {
     gceSTATUS status;
+#if defined(LINUX)
+    gctPHYS_ADDR_T physical;
+    gctUINT32 address;
+#endif
     gcsTA_INTERFACE iface;
 
     gcmkHEADER();
@@ -156,8 +160,10 @@ gckKERNEL_SecurityExecute(
     iface.u.Execute.command_buffer_length = Bytes;
 
 #if defined(LINUX)
-    gcmkONERROR(gckOS_GetPhysicalAddress(Kernel->os, Buffer,
-            (gctUINT32 *)&iface.u.Execute.command_buffer));
+    gcmkONERROR(gckOS_GetPhysicalAddress(Kernel->os, Buffer, &physical));
+    gcmkSAFECASTPHYSADDRT(address, physical);
+
+    iface.u.Execute.command_buffer = (gctUINT32 *)address;
 #endif
 
     gcmkONERROR(gckKERNEL_SecurityCallService(Kernel->securityChannel, &iface));
@@ -185,14 +191,19 @@ gckKERNEL_SecurityMapMemory(
 {
     gceSTATUS status;
     gcsTA_INTERFACE iface;
+#if defined(LINUX)
+    gctPHYS_ADDR_T physical;
+    gctUINT32 address;
+#endif
 
     gcmkHEADER();
 
     iface.command = KERNEL_MAP_MEMORY;
 
 #if defined(LINUX)
-    gcmkONERROR(gckOS_GetPhysicalAddress(Kernel->os, PhysicalArray,
-            (gctUINT32 *)&iface.u.MapMemory.physicals));
+    gcmkONERROR(gckOS_GetPhysicalAddress(Kernel->os, PhysicalArray, &physical));
+    gcmkSAFECASTPHYSADDRT(address, physical);
+    iface.u.MapMemory.physicals = (gctUINT32 *)address;
 #endif
 
     iface.u.MapMemory.pageCount = PageCount;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
index eac565c..60d8a13 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -778,6 +778,36 @@ gceSTATUS gckVGKERNEL_Dispatch(
             }
         }
         break;
+    case gcvHAL_READ_REGISTER:
+#if gcdREGISTER_ACCESS_FROM_USER
+        /* Read a register. */
+        gcmkONERROR(gckOS_ReadRegisterEx(
+            Kernel->os,
+            Kernel->core,
+            Interface->u.ReadRegisterData.address,
+            &Interface->u.ReadRegisterData.data));
+#else
+        /* No access from user land to read registers. */
+        Interface->u.ReadRegisterData.data = 0;
+        status = gcvSTATUS_NOT_SUPPORTED;
+#endif
+        break;
+
+    case gcvHAL_WRITE_REGISTER:
+#if gcdREGISTER_ACCESS_FROM_USER
+        /* Write a register. */
+        gcmkONERROR(
+            gckOS_WriteRegisterEx(Kernel->os,
+                                  Kernel->core,
+                                  Interface->u.WriteRegisterData.address,
+                                  Interface->u.WriteRegisterData.data));
+#else
+        /* No access from user land to write registers. */
+        status = gcvSTATUS_NOT_SUPPORTED;
+#endif
+        break;
+
+
     default:
         /* Invalid command. */
         status = gcvSTATUS_INVALID_ARGUMENT;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h
index 8bdeb38..0f487b2 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
index 237b856..383881c 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -1230,7 +1230,8 @@ _NeedVirtualMapping(
 )
 {
     gceSTATUS status;
-    gctUINT32 phys;
+    gctPHYS_ADDR_T phys;
+    gctUINT32 address;
     gctUINT32 end;
     gcePOOL pool;
     gctUINT32 offset;
@@ -1254,23 +1255,26 @@ _NeedVirtualMapping(
         }
         else
 #endif
+        if (!gckHARDWARE_IsFeatureAvailable(Kernel->hardware, gcvFEATURE_MMU))
         {
             /* Convert logical address into a physical address. */
             gcmkONERROR(gckOS_UserLogicalToPhysical(
                         Kernel->os, Node->Virtual.logical, &phys
                         ));
 
+            gcmkSAFECASTPHYSADDRT(address, phys);
+
             gcmkONERROR(gckOS_GetBaseAddress(Kernel->os, &baseAddress));
 
             gcmkASSERT(phys >= baseAddress);
 
             /* Subtract baseAddress to get a GPU address used for programming. */
-            phys -= baseAddress;
+            address -= baseAddress;
 
             /* If part of region is belong to gcvPOOL_VIRTUAL,
             ** whole region has to be mapped. */
             gcmkSAFECASTSIZET(bytes, Node->Virtual.bytes);
-            end = phys + bytes - 1;
+            end = address + bytes - 1;
 
             gcmkONERROR(gckHARDWARE_SplitMemory(
                         Kernel->hardware, end, &pool, &offset
@@ -1278,6 +1282,11 @@ _NeedVirtualMapping(
 
             *NeedMapping = (pool == gcvPOOL_VIRTUAL);
         }
+        else
+        {
+            /* TODO: Check whether physical address in flat mapping. */
+            *NeedMapping = gcvTRUE;
+        }
     }
     else
     {
@@ -1427,8 +1436,9 @@ gckVIDMEM_Lock(
     gctBOOL needMapping = gcvFALSE;
 #endif
     gctUINT32 baseAddress;
-    gctUINT32 physicalAddress;
+    gctUINT64 physicalAddress;
     gcuVIDMEM_NODE_PTR node = Node->node;
+    gctPHYS_ADDR_T physical;
 
     gcmkHEADER_ARG("Node=0x%x", Node);
 
@@ -1492,9 +1502,11 @@ gckVIDMEM_Lock(
         gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(
             Kernel->os,
             *Address,
-            Address
+            &physical
             ));
 
+        gcmkSAFECASTSIZET(*Address, physical);
+
         gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
                       "Locked node 0x%x (%d) @ 0x%08X",
                       node,
@@ -1522,7 +1534,7 @@ gckVIDMEM_Lock(
                             &node->Virtual.logical,
                             &node->Virtual.pageCount));
 
-        gcmkONERROR(gckOS_GetPhysicalAddress(
+        gcmkONERROR(gckOS_UserLogicalToPhysical(
             os,
             node->Virtual.logical,
             &physicalAddress
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
index f4b7d99..44faf43 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -199,9 +199,9 @@ gceCORE;
 #define gcdMAX_GPU_COUNT               3
 #endif
 
-#define gcdMAX_SURF_LAYER              4
+#define gcdMAX_SURF_LAYERS              4
 
-#define gcdMAX_DRAW_BUFFERS            4
+#define gcdMAX_DRAW_BUFFERS            8
 
 /*******************************************************************************
 **
@@ -471,7 +471,7 @@ gceSTATUS
 gckOS_GetPhysicalAddress(
     IN gckOS Os,
     IN gctPOINTER Logical,
-    OUT gctUINT32 * Address
+    OUT gctPHYS_ADDR_T * Address
     );
 
 /* Get the physical address of a corresponding user logical address. */
@@ -479,16 +479,7 @@ gceSTATUS
 gckOS_UserLogicalToPhysical(
     IN gckOS Os,
     IN gctPOINTER Logical,
-    OUT gctUINT32 * Address
-    );
-
-/* Get the physical address of a corresponding logical address. */
-gceSTATUS
-gckOS_GetPhysicalAddressProcess(
-    IN gckOS Os,
-    IN gctPOINTER Logical,
-    IN gctUINT32 ProcessID,
-    OUT gctUINT32 * Address
+    OUT gctUINT64 * Address
     );
 
 /* Map physical memory. */
@@ -513,7 +504,7 @@ gceSTATUS
 gckOS_PhysicalToPhysicalAddress(
     IN gckOS Os,
     IN gctPOINTER Physical,
-    OUT gctUINT32 * PhysicalAddress
+    OUT gctPHYS_ADDR_T * PhysicalAddress
     );
 
 /* Read data from a hardware register. */
@@ -617,13 +608,6 @@ gckOS_UnmapUserLogical(
     IN gctPOINTER Logical
     );
 
-/* Create a new mutex. */
-gceSTATUS
-gckOS_CreateMutex(
-    IN gckOS Os,
-    OUT gctPOINTER * Mutex
-    );
-
 /* Delete a mutex. */
 gceSTATUS
 gckOS_DeleteMutex(
@@ -1154,6 +1138,20 @@ gckOS_WaitSignal(
     IN gctUINT32 Wait
     );
 
+#ifdef __QNXNTO__
+gceSTATUS
+gckOS_SignalPulse(
+    IN gckOS Os,
+    IN gctSIGNAL Signal
+    );
+
+gceSTATUS
+gckOS_SignalPending(
+    IN gckOS Os,
+    IN gctSIGNAL Signal
+    );
+#endif
+
 /* Map a user signal to the kernel space. */
 gceSTATUS
 gckOS_MapSignal(
@@ -1307,7 +1305,7 @@ gckOS_CacheClean(
     gckOS Os,
     gctUINT32 ProcessID,
     gctPHYS_ADDR Handle,
-    gctUINT32 Physical,
+    gctPHYS_ADDR_T Physical,
     gctPOINTER Logical,
     gctSIZE_T Bytes
     );
@@ -1317,7 +1315,7 @@ gckOS_CacheFlush(
     gckOS Os,
     gctUINT32 ProcessID,
     gctPHYS_ADDR Handle,
-    gctUINT32 Physical,
+    gctPHYS_ADDR_T Physical,
     gctPOINTER Logical,
     gctSIZE_T Bytes
     );
@@ -1327,7 +1325,7 @@ gckOS_CacheInvalidate(
     gckOS Os,
     gctUINT32 ProcessID,
     gctPHYS_ADDR Handle,
-    gctUINT32 Physical,
+    gctPHYS_ADDR_T Physical,
     gctPOINTER Logical,
     gctSIZE_T Bytes
     );
@@ -1335,8 +1333,8 @@ gckOS_CacheInvalidate(
 gceSTATUS
 gckOS_CPUPhysicalToGPUPhysical(
     IN gckOS Os,
-    IN gctUINT32 CPUPhysical,
-    IN gctUINT32_PTR GPUPhysical
+    IN gctPHYS_ADDR_T CPUPhysical,
+    IN gctPHYS_ADDR_T * GPUPhysical
     );
 
 gceSTATUS
@@ -2085,7 +2083,9 @@ gckHARDWARE_Link(
     IN gctPOINTER Logical,
     IN gctUINT32 FetchAddress,
     IN gctUINT32 FetchSize,
-    IN OUT gctUINT32 * Bytes
+    IN OUT gctUINT32 * Bytes,
+    OUT gctUINT32 * Low,
+    OUT gctUINT32 * High
     );
 
 /* Add an EVENT command in the command queue. */
@@ -2722,7 +2722,7 @@ gceSTATUS
 gckCOMMAND_AddressInKernelCommandBuffer(
     IN gckCOMMAND Command,
     IN gctUINT32 Address,
-    OUT gctBOOL *In
+    OUT gctPOINTER * Pointer
     );
 
 /******************************************************************************\
@@ -2775,7 +2775,7 @@ gckMMU_FreePages(
 gceSTATUS
 gckMMU_SetPage(
    IN gckMMU Mmu,
-   IN gctUINT32 PageAddress,
+   IN gctPHYS_ADDR_T PageAddress,
    IN gctUINT32 *PageEntry
    );
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
index b798152..fd5688d 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -18,6 +18,7 @@
 *
 *****************************************************************************/
 
+
 #ifndef __gc_hal_base_h_
 #define __gc_hal_base_h_
 
@@ -66,11 +67,37 @@ typedef struct _gcsCONTEXT_MAP *        gcsCONTEXT_MAP_PTR;
 typedef void *                          gcoVG;
 #endif
 
+#if GC355_PROFILER
+typedef struct _gcsPROFILERFUNCData * gcsPROFILERFUNCData_PTR;
+typedef struct _gcsPROFILERFUNCNODE * gcsPROFILERFUNCNODE_PTR;
+#endif
+
 #if gcdSYNC
 typedef struct _gcoFENCE *              gcoFENCE;
 typedef struct _gcsSYNC_CONTEXT *       gcsSYNC_CONTEXT_PTR;
 #endif
 
+/******************************************************************************\
+********************* Share obj lock/unlock macros. ****************************
+\******************************************************************************/
+#define gcmLOCK_SHARE_OBJ(Obj) \
+{ \
+    if(Obj->sharedLock != gcvNULL)\
+    {\
+        (gcoOS_AcquireMutex( \
+                     gcvNULL, Obj->sharedLock, gcvINFINITE));\
+    }\
+}
+
+
+#define gcmUNLOCK_SHARE_OBJ(Obj)\
+{\
+    if(Obj->sharedLock != gcvNULL)\
+    {\
+        (gcoOS_ReleaseMutex(gcvNULL, Obj->sharedLock));\
+    }\
+}
+
 #if defined(ANDROID)
 typedef struct _gcoOS_SymbolsList gcoOS_SymbolsList;
 #endif
@@ -171,6 +198,8 @@ typedef enum _gcePATCH_ID
     gcvPATCH_SUMSUNG_BENCH,
     gcvPATCH_ROCKSTAR_MAXPAYNE,
     gcvPATCH_TITANPACKING,
+    gcvPATCH_OES20SFT,
+    gcvPATCH_OES30SFT,
     gcvPATCH_BASEMARKOSIICN,
     gcvPATCH_FRUITNINJA,
 #if defined(ANDROID)
@@ -505,6 +534,31 @@ typedef struct _gcsCONTAINER
 }
 gcsCONTAINER;
 
+#if GC355_PROFILER
+/*------------------------GC355_PROFILER function node structure--------------*/
+typedef struct _gcsPROFILERFUNCData
+{
+    gctSTRING funcName;
+    gctSTRING Tag;
+    gctUINT   TreeDepth;
+    gctUINT   saveLayerTreeDepth;
+    gctUINT   varTreeDepth;
+    gctUINT64 elapsedTime;
+    gctUINT64 cpuTime;
+    gctUINT64 gpuTime;
+}gcsPROFILERFUNCData;
+
+
+typedef struct _gcsPROFILERFUNCNODE
+{
+    gcsPROFILERFUNCData_PTR data;
+    gcsPROFILERFUNCNODE_PTR pre;
+    gcsPROFILERFUNCNODE_PTR next;
+}gcsPROFILERFUNCNODE;
+/*----------------------------------------------------------------------------*/
+#endif
+
+
 gceSTATUS
 gcsCONTAINER_Construct(
     IN gcsCONTAINER_PTR Container,
@@ -1029,6 +1083,35 @@ gcoHAL_ConfigPowerManagement(
     IN gctBOOL Enable
     );
 
+gceSTATUS
+gcoHAL_AllocateVideoMemory(
+    IN gctUINT Alignment,
+    IN gceSURF_TYPE Type,
+    IN gctUINT32 Flag,
+    IN gcePOOL Pool,
+    IN OUT gctSIZE_T * Bytes,
+    OUT gctUINT32_PTR Node
+    );
+
+gceSTATUS
+gcoHAL_LockVideoMemory(
+    IN gctUINT32 Node,
+    IN gctBOOL Cacheable,
+    OUT gctUINT32 * Physical,
+    OUT gctPOINTER * Logical
+    );
+
+gceSTATUS
+gcoHAL_UnlockVideoMemory(
+    IN gctUINT32 Node,
+    IN gceSURF_TYPE Type
+    );
+
+gceSTATUS
+    gcoHAL_ReleaseVideoMemory(
+    IN gctUINT32 Node
+    );
+
 #if gcdENABLE_3D || gcdENABLE_VG
 /* Query the target capabilities. */
 gceSTATUS
@@ -1309,6 +1392,15 @@ gcoOS_CloseFD(
     IN gctINT FD
     );
 
+/* Scan a file. */
+gceSTATUS
+gcoOS_FscanfI(
+    IN gcoOS Os,
+    IN gctFILE File,
+    IN gctCONST_STRING Format,
+    OUT gctUINT *result
+    );
+
 /* Dup file descriptor to another. */
 gceSTATUS
 gcoOS_DupFD(
@@ -3757,9 +3849,9 @@ gcoOS_Print(
 #   define gcmkPRINT_VERSION()      _gcmPRINT_VERSION(gcmk)
 #   define _gcmPRINT_VERSION(prefix) \
         prefix##TRACE(gcvLEVEL_ERROR, \
-                      "Vivante HAL version %d.%d.%d build %d  %s  %s", \
-                      gcvVERSION_MAJOR, gcvVERSION_MINOR, gcvVERSION_PATCH, \
-                      gcvVERSION_BUILD, gcvVERSION_DATE, gcvVERSION_TIME )
+                      "Vivante HAL version %d.%d.%d build %d", \
+                      gcvVERSION_MAJOR, gcvVERSION_MINOR, \
+                      gcvVERSION_PATCH, gcvVERSION_BUILD)
 #else
 #   define gcmPRINT_VERSION()       do { gcmSTACK_DUMP(); } while (gcvFALSE)
 #   define gcmkPRINT_VERSION()      do { } while (gcvFALSE)
@@ -4536,6 +4628,34 @@ gckOS_DebugStatus2Name(
 
 /*******************************************************************************
 **
+**  gcmkSAFECASTPHYSADDRT
+**
+**      Check whether value of a gctPHYS_ADDR_T variable beyond the capability
+**      of 32bits GPU hardware.
+**
+**  ASSUMPTIONS:
+**
+**
+**
+**  ARGUMENTS:
+**
+**      x   A gctUINT32 variable
+**      y   A gctSIZE_T variable
+*/
+#define gcmkSAFECASTPHYSADDRT(x, y) \
+    do \
+    { \
+    gctUINT32 tmp = (gctUINT32)(y); \
+    if (gcmSIZEOF(gctPHYS_ADDR_T) > gcmSIZEOF(gctUINT32)) \
+    { \
+    gcmkASSERT(tmp <= gcvMAXUINT32); \
+    } \
+    (x) = tmp; \
+    } \
+    while (gcvFALSE)
+
+/*******************************************************************************
+**
 **  gcmVERIFY_LOCK
 **
 **      Verifies whether the surface is locked.
@@ -5476,9 +5596,9 @@ struct _gcoOS_SymbolsList
         UnifiedConst = gcvTRUE; \
         VsConstBase  = gcregSHUniformsRegAddrs; \
         PsConstBase  = gcregSHUniformsRegAddrs; \
+        VsConstMax   = gcmMIN(512, NumConstants - 64); \
+        PsConstMax   = gcmMIN(512, NumConstants - 64); \
         ConstMax     = NumConstants; \
-        VsConstMax   = 256; \
-        PsConstMax   = ConstMax - VsConstMax; \
     } \
     else if (NumConstants == 256) \
     { \
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
index 345b4ea..6940aa98 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -18,6 +18,7 @@
 *
 *****************************************************************************/
 
+
 #ifndef __gc_hal_driver_h_
 #define __gc_hal_driver_h_
 
@@ -284,6 +285,9 @@ typedef struct _gcsHAL_QUERY_CHIP_IDENTITY
 
     /* Product ID */
     gctUINT32                   productID;
+
+    /* Special ECO bits */
+    gceECO_FLAG                 ecoFlags;
 }
 gcsHAL_QUERY_CHIP_IDENTITY;
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h
index d4e4b3e..6a58ea4 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h
index 3f5dfac..efefc0c 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h
index 1f35873..a48d8d7 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -60,7 +60,7 @@ typedef struct _DFBPixmap *  HALNativePixmapType;
 /* Wayland platform. */
 #include <wayland-egl.h>
 
-#define WL_EGL_NUM_BACKBUFFERS 3
+#define WL_EGL_NUM_BACKBUFFERS 2
 
 typedef struct _gcsWL_VIV_BUFFER
 {
@@ -75,7 +75,9 @@ typedef struct _gcsWL_EGL_DISPLAY
    struct wl_viv* wl_viv;
    struct wl_registry *registry;
    struct wl_event_queue    *wl_queue;
+   struct wl_event_queue    *wl_swap_queue;
    gctINT swapInterval;
+   gctINT file;
 } gcsWL_EGL_DISPLAY;
 
 typedef struct _gcsWL_EGL_BUFFER_INFO
@@ -243,15 +245,6 @@ gcoOS_GetDisplayInfoEx(
     );
 
 gceSTATUS
-gcoOS_GetNextDisplayInfoExByIndex(
-    IN gctINT Index,
-    IN HALNativeDisplayType Display,
-    IN HALNativeWindowType Window,
-    IN gctUINT DisplayInfoSize,
-    OUT halDISPLAY_INFO * DisplayInfo
-    );
-
-gceSTATUS
 gcoOS_GetDisplayVirtual(
     IN HALNativeDisplayType Display,
     OUT gctINT * Width,
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h
index 10da3af..8b0f47a79 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -233,6 +233,28 @@ typedef struct _halEvent
 }
 halEvent;
 
+/* Tiling layouts. */
+typedef enum _halTiling
+{
+    HAL_INVALIDTILED = 0x0,         /* Invalid tiling */
+    /* Tiling basic modes enum'ed in power of 2. */
+    HAL_LINEAR       = 0x1,         /* No    tiling. */
+    HAL_TILED        = 0x2,         /* 4x4   tiling. */
+    HAL_SUPERTILED   = 0x4,         /* 64x64 tiling. */
+    HAL_MINORTILED   = 0x8,         /* 2x2   tiling. */
+
+    /* Tiling special layouts. */
+    HAL_TILING_SPLIT_BUFFER = 0x100,
+
+    /* Tiling combination layouts. */
+    HAL_MULTI_TILED      = HAL_TILED
+                         | HAL_TILING_SPLIT_BUFFER,
+
+    HAL_MULTI_SUPERTILED = HAL_SUPERTILED
+                         | HAL_TILING_SPLIT_BUFFER,
+}
+halTiling;
+
 /* VFK_DISPLAY_INFO structure defining information returned by
    vdkGetDisplayInfoEx. */
 typedef struct _halDISPLAY_INFO
@@ -245,6 +267,9 @@ typedef struct _halDISPLAY_INFO
     ** for the specified display.*/
     int                         stride;
 
+    /* The tiling layout of the display. */
+    int                         tiling;
+
     /* The color depth of the display in bits per pixel. */
     int                         bitsPerPixel;
 
@@ -256,13 +281,12 @@ typedef struct _halDISPLAY_INFO
     ** if the address is not known for the specified display. */
     unsigned long               physical;
 
-    int                wrapFB;   /* true if compositor, false otherwise. */
+    /* True if requires buffer wrapping. */
+    int                         wrapFB;
 
-#ifndef __QNXNTO__
-    /* 355_FB_MULTI_BUFFER */
-    int                      multiBuffer;
-    int                      backBufferY;
-#endif
+    /* FB_MULTI_BUFFER */
+    int                         multiBuffer;
+    int                         backBufferY;
 
     /* The color info of the display. */
     unsigned int                alphaLength;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
index 700f7eb..d63951c 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -80,22 +80,18 @@ gcePROGRAM_STAGE_BIT;
 
 gceSTATUS
 gcoHAL_QueryShaderCaps(
-    IN gcoHAL Hal,
-    OUT gctUINT * VertexUniforms,
-    OUT gctUINT * FragmentUniforms,
-    OUT gctUINT * Varyings
+    IN  gcoHAL    Hal,
+    OUT gctUINT * UnifiedUniforms,
+    OUT gctUINT * VertUniforms,
+    OUT gctUINT * FragUniforms,
+    OUT gctUINT * Varyings,
+    OUT gctUINT * ShaderCoreCount,
+    OUT gctUINT * ThreadCount,
+    OUT gctUINT * VertInstructionCount,
+    OUT gctUINT * FragInstructionCount
     );
 
 gceSTATUS
-gcoHAL_QueryShaderCapsEx(
-                         IN gcoHAL Hal,
-                         OUT gctUINT * ShaderCoreCount,
-                         OUT gctUINT * ThreadCount,
-                         OUT gctUINT * VertexInstructionCount,
-                         OUT gctUINT * FragmentInstructionCount
-                         );
-
-gceSTATUS
 gcoHAL_QuerySamplerBase(
                         IN  gcoHAL Hal,
                         OUT gctUINT32 * VertexCount,
@@ -106,10 +102,10 @@ gcoHAL_QuerySamplerBase(
 
 gceSTATUS
 gcoHAL_QueryUniformBase(
-					    IN  gcoHAL Hal,
-					    OUT gctUINT32 * VertexBase,
-					    OUT gctUINT32 * FragmentBase
-					    );
+                        IN  gcoHAL Hal,
+                         OUT gctUINT32 * VertexBase,
+                         OUT gctUINT32 * FragmentBase
+                        );
 
 gceSTATUS
 gcoHAL_QueryTextureCaps(
@@ -446,6 +442,12 @@ gcoSURF_IsFormatRenderableAsRT(
     );
 
 gceSTATUS
+gcoSURF_SetSharedLock(
+    IN gcoSURF Surface,
+    IN gctPOINTER sharedLock
+    );
+
+gceSTATUS
 gcoSURF_GetFence(
     IN gcoSURF Surface
     );
@@ -517,6 +519,11 @@ gcoSURF_3DBlitCopy(
 /******************************************************************************\
 ******************************** gcoINDEX Object *******************************
 \******************************************************************************/
+gceSTATUS
+gcoINDEX_SetSharedLock(
+    IN gcoINDEX Index,
+    IN gctPOINTER sharedLock
+    );
 
 /* Construct a new gcoINDEX object. */
 gceSTATUS
@@ -1231,6 +1238,9 @@ gco3D_DrawInstancedPrimitives(
     IN gctSIZE_T StartIndex,
     IN gctSIZE_T PrimitiveCount,
     IN gctSIZE_T VertexCount,
+    IN gctBOOL SpilitDraw,
+    IN gctSIZE_T SpilitCount,
+    IN gcePRIMITIVE SpilitType,
     IN gctSIZE_T InstanceCount
     );
 
@@ -1260,7 +1270,10 @@ gco3D_DrawIndexedPrimitives(
     IN gcePRIMITIVE Type,
     IN gctSIZE_T BaseVertex,
     IN gctSIZE_T StartIndex,
-    IN gctSIZE_T PrimitiveCount
+    IN gctSIZE_T PrimitiveCount,
+    IN gctBOOL SpilitDraw,
+    IN gctSIZE_T SpilitCount,
+    IN gcePRIMITIVE SpilitType
     );
 
 /* Draw a number of indexed primitives using offsets. */
@@ -2005,6 +2018,12 @@ typedef enum _gceATTRIB_SCHEME
 } gceATTRIB_SCHEME;
 
 gceSTATUS
+gcoSTREAM_SetSharedLock(
+    IN gcoSTREAM Stream,
+    IN gctPOINTER sharedLock
+    );
+
+gceSTATUS
 gcoSTREAM_Construct(
     IN gcoHAL Hal,
     OUT gcoSTREAM * Stream
@@ -2278,13 +2297,16 @@ gcoVERTEXARRAY_Bind_Ex(
     IN gctUINT32 EnableBits,
     IN gcsVERTEXARRAY_PTR VertexArray,
     IN gctUINT First,
-    IN gctSIZE_T Count,
+    IN gctSIZE_T * Count,
     IN gctBOOL DrawArraysInstanced,
     IN gctSIZE_T InstanceCount,
     IN gceINDEX_TYPE IndexType,
     IN gcoINDEX IndexObject,
     IN gctPOINTER IndexMemory,
     IN OUT gcePRIMITIVE * PrimitiveType,
+    IN OUT gctBOOL * SpilitDraw,
+    IN OUT gctSIZE_T * SpilitCount,
+    IN OUT gcePRIMITIVE * SpilitPrimitiveType,
 #if gcdUSE_WCLIP_PATCH
     IN OUT gctUINT * PrimitiveCount,
     IN OUT gctFLOAT * wLimitRms,
@@ -2300,13 +2322,17 @@ gcoVERTEXARRAY_Bind_Ex2(
     IN gctUINT32 EnableBits,
     IN gcsATTRIBUTE_PTR VertexArray,
     IN gctSIZE_T First,
-    IN gctSIZE_T Count,
+    IN gctSIZE_T * Count,
     IN gctBOOL DrawArraysInstanced,
     IN gctSIZE_T InstanceCount,
     IN gceINDEX_TYPE IndexType,
     IN gcoBUFOBJ IndexObject,
     IN gctPOINTER IndexMemory,
+    IN gctBOOL PrimtiveRestart,
     IN OUT gcePRIMITIVE * PrimitiveType,
+    IN OUT gctBOOL * SpilitDraw,
+    IN OUT gctSIZE_T * SpilitCount,
+    IN OUT gcePRIMITIVE * SpilitPrimitiveType,
 #if gcdUSE_WCLIP_PATCH
     IN OUT gctSIZE_T * PrimitiveCount,
     IN OUT gctFLOAT * wLimitRms,
@@ -2323,11 +2349,14 @@ gcoVERTEXARRAY_Bind(
     IN gctUINT32 EnableBits,
     IN gcsVERTEXARRAY_PTR VertexArray,
     IN gctUINT First,
-    IN gctSIZE_T Count,
+    IN gctSIZE_T * Count,
     IN gceINDEX_TYPE IndexType,
     IN gcoINDEX IndexObject,
     IN gctPOINTER IndexMemory,
     IN OUT gcePRIMITIVE * PrimitiveType,
+    IN OUT gctBOOL * SpilitDraw,
+    IN OUT gctSIZE_T * SpilitCount,
+    IN OUT gcePRIMITIVE * SpilitPrimitiveType,
 #if gcdUSE_WCLIP_PATCH
     IN OUT gctUINT * PrimitiveCount,
     IN OUT gctFLOAT * wLimitRms,
@@ -2449,6 +2478,10 @@ typedef enum _gceBUFOBJ_USAGE
     gcvBUFOBJ_USAGE_DYNAMIC_READ,
     gcvBUFOBJ_USAGE_DYNAMIC_COPY,
 
+    /* special patch for optimaize performance,
+    ** no fence and duplicate stream to ensure data correct
+    */
+    gcvBUFOBJ_USAGE_DISABLE_FENCE_DYNAMIC_STREAM = 256
 } gceBUFOBJ_USAGE;
 
 /* Construct a new gcoBUFOBJ object. */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
index 7e98d05..a38b475 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -467,6 +467,7 @@ gcoHAL_QueryPathStorage(
     IN gcoHAL Hal,
 #if GC355_PROFILER
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -480,6 +481,7 @@ gcoHAL_AssociateCompletion(
     IN gcoHAL Hal,
 #if GC355_PROFILER
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -493,6 +495,7 @@ gcoHAL_DeassociateCompletion(
     IN gcoHAL Hal,
 #if GC355_PROFILER
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -506,6 +509,7 @@ gcoHAL_CheckCompletion(
     IN gcoHAL Hal,
 #if GC355_PROFILER
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -519,6 +523,7 @@ gcoHAL_WaitCompletion(
     IN gcoHAL Hal,
 #if GC355_PROFILER
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -533,6 +538,7 @@ gcoHAL_Flush(
 #if GC355_PROFILER
     ,
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth
@@ -545,6 +551,7 @@ gcoHAL_SplitAddress(
     IN gcoHAL Hal,
 #if GC355_PROFILER
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -560,6 +567,7 @@ gcoHAL_CombineAddress(
     IN gcoHAL Hal,
 #if GC355_PROFILER
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -575,6 +583,7 @@ gcoHAL_ScheduleVideoMemory(
     IN gcoHAL Hal,
 #if GC355_PROFILER
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -588,6 +597,7 @@ gcoHAL_FreeVideoMemory(
     IN gcoHAL Hal,
 #if GC355_PROFILER
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -601,6 +611,7 @@ gcoHAL_QueryCommandBuffer(
     IN gcoHAL Hal,
 #if GC355_PROFILER
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -613,6 +624,7 @@ gcoHAL_AllocateLinearVideoMemory(
     IN gcoHAL Hal,
 #if GC355_PROFILER
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -631,6 +643,7 @@ gcoHAL_GetAlignedSurfaceSize(
     IN gcoHAL Hal,
 #if GC355_PROFILER
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -645,6 +658,7 @@ gcoHAL_ReserveTask(
     IN gcoHAL Hal,
 #if GC355_PROFILER
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -666,7 +680,8 @@ gcoHAL_ReserveTask(
 void
 gcoVG_ProfilerEnableDisable(
     IN gcoVG Vg,
-    IN gctUINT enableGetAPITimes,
+    IN gctUINT64 appStartTime,
+    IN gctBOOL enableGetAPITimes,
     IN gctFILE apiTimeFile
     );
 
@@ -677,8 +692,15 @@ gcoVG_ProfilerTreeDepth(
     );
 
 void
+gcoVG_ProfilerTag(
+    IN gcoVG Vg,
+    IN gctSTRING Tag
+    );
+
+void
 gcoVG_ProfilerSetStates(
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT treeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth
@@ -689,6 +711,7 @@ gctBOOL
 gcoVG_IsMaskSupported(
 #if GC355_PROFILER
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -700,6 +723,7 @@ gctBOOL
 gcoVG_IsTargetSupported(
 #if GC355_PROFILER
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -711,6 +735,7 @@ gctBOOL
 gcoVG_IsImageSupported(
 #if GC355_PROFILER
     IN gcoVG Vg,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -721,6 +746,7 @@ gcoVG_IsImageSupported(
 gctUINT8 gcoVG_PackColorComponent(
 #if GC355_PROFILER
     gcoVG Vg,
+    gcsPROFILERFUNCNODE *DList,
     gctUINT TreeDepth,
     gctUINT saveLayerTreeDepth,
     gctUINT varTreeDepth,
@@ -739,6 +765,7 @@ gcoVG_Destroy(
     IN gcoVG Vg
 #if GC355_PROFILER
     ,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth
@@ -749,6 +776,7 @@ gceSTATUS
 gcoVG_SetTarget(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -760,6 +788,7 @@ gceSTATUS
 gcoVG_UnsetTarget(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -771,6 +800,7 @@ gceSTATUS
 gcoVG_SetUserToSurface(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -782,6 +812,7 @@ gceSTATUS
 gcoVG_SetSurfaceToImage(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -793,6 +824,7 @@ gceSTATUS
 gcoVG_EnableMask(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -804,6 +836,7 @@ gceSTATUS
 gcoVG_SetMask(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -815,6 +848,7 @@ gceSTATUS
 gcoVG_UnsetMask(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -827,6 +861,7 @@ gcoVG_FlushMask(
     IN gcoVG Vg
 #if GC355_PROFILER
     ,
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth
@@ -837,6 +872,7 @@ gceSTATUS
 gcoVG_EnableScissor(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -848,6 +884,7 @@ gceSTATUS
 gcoVG_SetScissor(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -860,6 +897,7 @@ gceSTATUS
 gcoVG_EnableColorTransform(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -871,6 +909,7 @@ gceSTATUS
 gcoVG_SetColorTransform(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -882,6 +921,7 @@ gceSTATUS
 gcoVG_SetTileFillColor(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -896,6 +936,7 @@ gceSTATUS
 gcoVG_SetSolidPaint(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -910,6 +951,7 @@ gceSTATUS
 gcoVG_SetLinearPaint(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -923,6 +965,7 @@ gceSTATUS
 gcoVG_SetRadialPaint(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -942,6 +985,7 @@ gceSTATUS
 gcoVG_SetPatternPaint(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -959,6 +1003,7 @@ gceSTATUS
 gcoVG_SetColorRamp(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -971,6 +1016,7 @@ gceSTATUS
 gcoVG_SetPattern(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -986,6 +1032,7 @@ gceSTATUS
 gcoVG_SetImageMode(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -997,6 +1044,7 @@ gceSTATUS
 gcoVG_SetBlendMode(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -1008,6 +1056,7 @@ gceSTATUS
 gcoVG_SetRenderingQuality(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -1019,6 +1068,7 @@ gceSTATUS
 gcoVG_SetFillRule(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -1036,6 +1086,7 @@ gceSTATUS
 gcoVG_Clear(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -1050,6 +1101,7 @@ gceSTATUS
 gcoVG_DrawPath(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -1069,6 +1121,7 @@ gceSTATUS
 gcoVG_DrawImage(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -1091,6 +1144,7 @@ gceSTATUS
 gcoVG_TesselateImage(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -1108,9 +1162,28 @@ gcoVG_TesselateImage(
     );
 
 gceSTATUS
+gcoVG_DrawSurfaceToImage(
+    IN gcoVG Vg,
+#if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
+    IN gctUINT TreeDepth,
+    IN gctUINT saveLayerTreeDepth,
+    IN gctUINT varTreeDepth,
+#endif
+    IN gcoSURF Image,
+    IN const gcsVG_RECT_PTR SrcRectangle,
+    IN const gcsVG_RECT_PTR DstRectangle,
+    IN const gctFLOAT Matrix[9],
+    IN gceIMAGE_FILTER Filter,
+    IN gctBOOL Mask,
+    IN gctBOOL FirstTime
+    );
+
+gceSTATUS
 gcoVG_Blit(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -1127,6 +1200,7 @@ gceSTATUS
 gcoVG_ColorMatrix(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -1147,6 +1221,7 @@ gceSTATUS
 gcoVG_SeparableConvolve(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -1177,6 +1252,7 @@ gceSTATUS
 gcoVG_GaussianBlur(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
@@ -1201,6 +1277,7 @@ gceSTATUS
 gcoVG_EnableDither(
     IN gcoVG Vg,
 #if GC355_PROFILER
+    IN gcsPROFILERFUNCNODE *DList,
     IN gctUINT TreeDepth,
     IN gctUINT saveLayerTreeDepth,
     IN gctUINT varTreeDepth,
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
index d20f007..910a411 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -146,6 +146,7 @@ typedef enum _gceFEATURE
     gcvFEATURE_TEX_COMPRRESSION_SUPERTILED,
     gcvFEATURE_FAST_MSAA,
     gcvFEATURE_BUG_FIXED_INDEXED_TRIANGLE_STRIP,
+    gcvFEATURE_INDEX_FETCH_FIX,
     gcvFEATURE_TEXTURE_TILE_STATUS_READ,
     gcvFEATURE_DEPTH_BIAS_FIX,
     gcvFEATURE_RECT_PRIMITIVE,
@@ -225,6 +226,7 @@ typedef enum _gceFEATURE
 
     gcvFEATURE_HALTI3,
     gcvFEATURE_EEZ,
+    gcvFEATURE_INTEGER_SIGNEXT_FIX,
     gcvFEATURE_INTEGER_PIPE_FIX,
     gcvFEATURE_PSOUTPUT_MAPPING,
     gcvFEATURE_8K_RT_FIX,
@@ -269,6 +271,10 @@ typedef enum _gceFEATURE
     gcvFEATURE_FE_START_VERTEX_SUPPORT,
     gcvFEATURE_RS_DEPTHSTENCIL_NATIVE_SUPPORT,
 
+    gcvFEATURE_HALTI4,
+    gcvFEATURE_MSAA_FRAGMENT_OPERATION,
+    gcvFEATURE_ZERO_ATTRIB_SUPPORT,
+
     /* Insert features above this comment only. */
     gcvFEATURE_COUNT                /* Not a feature. */
 }
@@ -324,7 +330,6 @@ typedef enum _gceFRAMEINFO_OP
     gcvFRAMEINFO_OP_ZERO      = 2,
     gcvFRAMEINFO_OP_GET       = 3,
 
-
     gcvFRAMEINFO_OP_COUNT,
 }
 gceFRAMEINFO_OP;
@@ -1545,6 +1550,23 @@ typedef enum _gceHAL_ARG_VERSION
 gceHAL_ARG_VERSION;
 
 
+typedef enum _gceCMDBUF_TYPE
+{
+    /* Contiguous command buffer. */
+    gcvCMDBUF_CONTIGUOUS,
+    /* Virtual command buffer. */
+    gcvCMDBUF_VIRTUAL,
+    /* Command buffer allocated from reserved memory. */
+    gcvCMDBUF_RESERVED,
+}
+gceCMDBUF_SOURCE;
+
+typedef enum _gceECO_FALG
+{
+    gcvECO_FLAG_MSAA_COHERENCEY = 1 << 0,
+}
+gceECO_FLAG;
+
 /*
 * Bit of a requirment is 1 means requirement is a must, 0 means requirement can
 * be ignored.
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h
index 8428342..a0dee7c 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -120,7 +120,7 @@ struct _gcoCMDBUF
     gcsOBJECT                   object;
 
     /* Commit count. */
-    gctUINT                     count;
+    gctUINT64                   commitCount;
 
     /* Command buffer entry and exit pipes. */
     gcePIPE_SELECT              entryPipe;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
index df35019..ed8a1f1 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
index b93015d..8c3ae37 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -18,6 +18,7 @@
 *
 *****************************************************************************/
 
+
 #ifndef __gc_hal_options_h_
 #define __gc_hal_options_h_
 
@@ -849,7 +850,7 @@
         is be used to debug.
 */
 #ifndef gcdLINK_QUEUE_SIZE
-#   define gcdLINK_QUEUE_SIZE                   5
+#   define gcdLINK_QUEUE_SIZE                   64
 #endif
 
 /*  gcdALPHA_KILL_IN_SHADER
@@ -932,16 +933,15 @@
 /*
     gcdENABLE_RENDER_INTO_WINDOW
 
-        Enable Render-Into-Window (ie, No-Resolve) feature on android.
+        Enable Render-Into-Window (ie, No-Resolve or direct rendering) feature.
         NOTE that even if enabled, it still depends on hardware feature and
-        android application behavior. When hardware feature or application
+        application behavior. When hardware feature or application
         behavior can not support render into window mode, it will fail back
         to normal mode.
-        When Render-Into-Window is finally used, window back buffer of android
-        applications will be allocated matching render target tiling format.
+        On android, if Render-Into-Window is finally used, window back buffer
+        of applications will be allocated matching render target tiling format.
         Otherwise buffer tiling is decided by the above option
         'gcdGPU_LINEAR_BUFFER_ENABLED'.
-        Android only for now.
 */
 #ifndef gcdENABLE_RENDER_INTO_WINDOW
 #   define gcdENABLE_RENDER_INTO_WINDOW         1
@@ -1106,13 +1106,9 @@
 
 #ifndef gcdMOVG
 #   define gcdMOVG                              0
-#if gcdMOVG
-#       define GC355_PROFILER                   1
-#   endif
-#       define gcdENABLE_TS_DOUBLE_BUFFER       1
+#   define gcdENABLE_TS_DOUBLE_BUFFER           1
 #else
 #if gcdMOVG
-#       define GC355_PROFILER                   1
 #       define gcdENABLE_TS_DOUBLE_BUFFER       0
 #else
 #       define gcdENABLE_TS_DOUBLE_BUFFER       1
@@ -1229,7 +1225,7 @@
         Enable third party operation like tpc or not.
 */
 #ifndef gcdENABLE_THIRD_PARTY_OPERATION
-#   define gcdENABLE_THIRD_PARTY_OPERATION      1
+#   define gcdENABLE_THIRD_PARTY_OPERATION      0
 #endif
 
 
@@ -1248,6 +1244,17 @@
 #   define gcdENABLE_VG                         0
 #endif
 
+
+#if gcdENABLE_VG
+#ifdef LINUX
+#       define GC355_PROFILER                   0
+#	else
+#   	define GC355_PROFILER                   0
+#   endif
+#else
+# 	define GC355_PROFILER                       0
+#endif
+
 #ifndef gcdGC355_MEM_PRINT
 #   define gcdGC355_MEM_PRINT                      0
 #else
@@ -1268,4 +1275,15 @@
 #   define gcdRECORD_COMMAND                    0
 #endif
 
+/*
+    gcdALLOC_CMD_FROM_RESERVE
+
+    Provide a way by which location of command buffer can be
+    specified. This is a DEBUG option to limit command buffer
+    to some memory range.
+*/
+#ifndef gcdALLOC_CMD_FROM_RESERVE
+#   define gcdALLOC_CMD_FROM_RESERVE            0
+#endif
+
 #endif /* __gc_hal_options_h_ */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
index d2abf9a..c82f937 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
index 035b76e..5327500 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -1031,6 +1031,12 @@ gco2D_Get2DEngine(
     OUT gco2D * Engine
     );
 
+gceSTATUS
+gco2D_Commit(
+    IN gco2D Engine,
+    IN gctBOOL Stall
+    );
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h
index 745a104..d1194cb 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_security_interface.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_security_interface.h
index cb86d76..6c553c4 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_security_interface.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_security_interface.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h
index 07b8e72..36a683f 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
index 51a686c..7bb2f2b 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -228,6 +228,8 @@ typedef char                    gctCHAR;
 typedef char *                  gctSTRING;
 typedef const char *            gctCONST_STRING;
 
+typedef gctUINT64               gctPHYS_ADDR_T;
+
 typedef struct _gcsCOUNT_STRING
 {
     gctSIZE_T                   Length;
@@ -884,6 +886,8 @@ struct _gckLINKDATA
     gctUINT32                   start;
     gctUINT32                   end;
     gctUINT32                   pid;
+    gctUINT32                   linkLow;
+    gctUINT32                   linkHigh;
 };
 
 typedef struct _gckLINKQUEUE * gckLINKQUEUE;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
index 4f95350..aeb4bcd 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -28,12 +28,8 @@
 
 #define gcvVERSION_PATCH        11
 
-#define gcvVERSION_BUILD     25762
+#define gcvVERSION_BUILD     31013
 
-#define gcvVERSION_STRING    "5.0.11.p4.25762"
-
-#define gcvVERSION_DATE      __DATE__
-
-#define gcvVERSION_TIME      __TIME__
+#define gcvVERSION_STRING    "5.0.11.p6.31013"
 
 #endif /* __gc_hal_version_h_ */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
index 09e8b96..502849f 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -667,6 +667,7 @@ typedef struct _gcsVGCONTEXT
     gctSIGNAL                   signal;
 
 #if defined(__QNXNTO__)
+    gctSIGNAL                   userSignal;
     gctINT32                    coid;
     gctINT32                    rcvid;
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_array.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_array.h
index fa2190f..eae5040 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_array.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_array.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_array.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_array.h
index acdd929..3afca5d 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_array.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_array.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_cma.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_cma.c
index e419558..67b4f8a 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_cma.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_cma.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -325,7 +325,7 @@ _DefaultLogicalToPhysical(
     IN PLINUX_MDL Mdl,
     IN gctPOINTER Logical,
     IN gctUINT32 ProcessID,
-    OUT gctUINT32_PTR Physical
+    OUT gctPHYS_ADDR_T * Physical
     );
 
 extern gceSTATUS
@@ -343,7 +343,7 @@ _CMAPhysical(
     IN gckALLOCATOR Allocator,
     IN PLINUX_MDL Mdl,
     IN gctUINT32 Offset,
-    OUT gctUINT32_PTR Physical
+    OUT gctPHYS_ADDR_T * Physical
     )
 {
     struct mdl_cma_priv *mdl_priv=(struct mdl_cma_priv *)Mdl->priv;
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.c
index 193b5d9..f7e7404 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -663,7 +663,7 @@ _DefaultLogicalToPhysical(
     IN PLINUX_MDL Mdl,
     IN gctPOINTER Logical,
     IN gctUINT32 ProcessID,
-    OUT gctUINT32_PTR Physical
+    OUT gctPHYS_ADDR_T * Physical
     )
 {
     return _ConvertLogical2Physical(
@@ -688,7 +688,7 @@ _DefaultPhysical(
     IN gckALLOCATOR Allocator,
     IN PLINUX_MDL Mdl,
     IN gctUINT32 Offset,
-    OUT gctUINT32_PTR Physical
+    OUT gctPHYS_ADDR_T * Physical
     )
 {
     gcmkASSERT(Mdl->pagedMem && !Mdl->contiguous);
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.h
index f36e1b0..1f0ee27 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -232,7 +232,7 @@ typedef struct _gcsALLOCATOR_OPERATIONS
         IN PLINUX_MDL Mdl,
         IN gctPOINTER Logical,
         IN gctUINT32 ProcessID,
-        OUT gctUINT32_PTR Physical
+        OUT gctPHYS_ADDR_T * Physical
         );
 
     /**************************************************************************
@@ -299,7 +299,7 @@ typedef struct _gcsALLOCATOR_OPERATIONS
         IN gckALLOCATOR Allocator,
         IN PLINUX_MDL Mdl,
         IN gctUINT32 Offset,
-        OUT gctUINT32_PTR Physical
+        OUT gctPHYS_ADDR_T * Physical
         );
 }
 gcsALLOCATOR_OPERATIONS;
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debug.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debug.h
index ef341d2..aec7f2a 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debug.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debug.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c
index de7b96c..c4a5011 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -826,10 +826,6 @@ _ShowCounters(
     _PrintCounter(file, &database->mapMemory, "mapMemory");
 }
 
-gckKERNEL
-_GetValidKernel(
-    gckGALDEVICE Device
-);
 static int vidmem_show(struct seq_file *file, void *unused)
 {
     gceSTATUS status;
@@ -837,10 +833,6 @@ static int vidmem_show(struct seq_file *file, void *unused)
     gckGALDEVICE device = file->private;
 
     gckKERNEL kernel = _GetValidKernel(device);
-    if(kernel == gcvNULL)
-    {
-        return 0;
-    }
 
     /* Find the database. */
     gcmkONERROR(
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h
index 9d17e87..b29363b 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
index ad4080a..67f6f8c 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -30,36 +30,12 @@
 #define DEBUG_FILE          "galcore_trace"
 #define PARENT_FILE         "gpu"
 
+#define gcdDEBUG_FS_WARN    "Experimental debug entry, may be removed in future release, do NOT rely on it!\n"
 
 #ifdef FLAREON
     static struct dove_gpio_irq_handler gc500_handle;
 #endif
 
-gckKERNEL
-_GetValidKernel(
-    gckGALDEVICE Device
-    )
-{
-    if (Device->kernels[gcvCORE_MAJOR])
-    {
-        return Device->kernels[gcvCORE_MAJOR];
-    }
-    else
-    if (Device->kernels[gcvCORE_2D])
-    {
-        return Device->kernels[gcvCORE_2D];
-    }
-    else
-    if (Device->kernels[gcvCORE_VG])
-    {
-        return Device->kernels[gcvCORE_VG];
-    }
-    else
-    {
-        return gcvNULL;
-    }
-}
-
 /******************************************************************************\
 ******************************** Debugfs Support *******************************
 \******************************************************************************/
@@ -323,14 +299,21 @@ _ShowProcesses(
 {
     gcsDATABASE_PTR database;
     gctINT i;
+    static gctUINT64 idleTime = 0;
 
     /* Acquire the database mutex. */
     gcmkVERIFY_OK(
         gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
 
+    if (Kernel->db->idleTime)
+    {
+        /* Record idle time if DB upated. */
+        idleTime = Kernel->db->idleTime;
+        Kernel->db->idleTime = 0;
+    }
+
     /* Idle time since last call */
-    seq_printf(file, "GPU Idle: %llu ns\n",  Kernel->db->idleTime);
-    Kernel->db->idleTime = 0;
+    seq_printf(file, "GPU Idle: %llu ns\n",  idleTime);
 
     /* Walk the databases. */
     for (i = 0; i < gcmCOUNTOF(Kernel->db->db); ++i)
@@ -365,16 +348,59 @@ gc_version_show(struct seq_file *m, void *data)
     return 0 ;
 }
 
-int gc_idle_show(struct seq_file* m, void* data)
+static int
+gc_idle_show(struct seq_file *m, void *data)
 {
     gcsINFO_NODE *node = m->private;
     gckGALDEVICE device = node->device;
     gckKERNEL kernel = _GetValidKernel(device);
-    gcuDATABASE_INFO info;
 
-    gckKERNEL_QueryProcessDB(kernel, 0, gcvFALSE, gcvDB_IDLE, &info);
+    static gctUINT64 idleTime = 0;
 
-    seq_printf(m, "GPU idle time since last query: %llu ns\n", info.time);
+    /* Acquire the database mutex. */
+    gcmkVERIFY_OK(
+        gckOS_AcquireMutex(kernel->os, kernel->db->dbMutex, gcvINFINITE));
+
+    if (kernel->db->idleTime)
+    {
+        /* Record idle time if DB upated. */
+        idleTime = kernel->db->idleTime;
+        kernel->db->idleTime = 0;
+    }
+
+    /* Idle time since last call */
+    seq_printf(m, "GPU Idle: %llu ns\n",  idleTime);
+
+    /* Release the database mutex. */
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(kernel->os, kernel->db->dbMutex));
+
+    return 0 ;
+}
+
+extern void
+_DumpState(
+    IN gckKERNEL Kernel
+    );
+
+static int
+gc_dump_trigger_show(struct seq_file *m, void *data)
+{
+#if gcdENABLE_3D || gcdENABLE_2D
+    gcsINFO_NODE *node = m->private;
+    gckGALDEVICE device = node->device;
+    gckKERNEL kernel = _GetValidKernel(device);
+#endif
+
+    seq_printf(m, gcdDEBUG_FS_WARN);
+
+#if gcdENABLE_3D || gcdENABLE_2D
+    seq_printf(m, "Get dump from /proc/kmsg or /sys/kernel/debug/gc/galcore_trace\n");
+
+    if (kernel->hardware->powerManagement == gcvFALSE)
+    {
+        _DumpState(kernel);
+    }
+#endif
 
     return 0;
 }
@@ -387,6 +413,7 @@ static gcsINFO InfoList[] =
     {"idle", gc_idle_show},
     {"database", gc_db_show},
     {"version", gc_version_show},
+    {"dump_trigger", gc_dump_trigger_show},
 };
 
 static gceSTATUS
@@ -992,6 +1019,9 @@ gckGALDEVICE_Construct(
 
     device->platform = Args->platform;
 
+    /* set up the contiguous memory */
+    device->contiguousSize = ContiguousSize;
+
     gcmkONERROR(_DebugfsInit(device));
 
     if (gckDEBUGFS_CreateNode(
@@ -1115,38 +1145,48 @@ gckGALDEVICE_Construct(
             /* Set up register memory region. */
             if (physical != 0)
             {
-                mem_region = request_mem_region(physical,
-                        device->requestedRegisterMemSizes[i],
-                        "galcore register region");
 
-                if (mem_region == gcvNULL)
+                if ( Args->registerMemMapped )
                 {
-                    gcmkTRACE_ZONE(
-                            gcvLEVEL_ERROR, gcvZONE_DRIVER,
-                            "%s(%d): Failed to claim %lu bytes @ 0x%08X\n",
-                            __FUNCTION__, __LINE__,
-                            physical, device->requestedRegisterMemSizes[i]
-                    );
+                    device->registerBases[i] = Args->registerMemAddress;
+                    device->requestedRegisterMemBases[i] = 0;
 
-                    gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
-                }
+                } else {
 
-                device->registerBases[i] = (gctPOINTER) ioremap_nocache(
-                        physical, device->requestedRegisterMemSizes[i]);
+                    mem_region = request_mem_region(physical,
+                            device->requestedRegisterMemSizes[i],
+                            "galcore register region");
 
-                if (device->registerBases[i] == gcvNULL)
-                {
-                    gcmkTRACE_ZONE(
-                            gcvLEVEL_ERROR, gcvZONE_DRIVER,
-                            "%s(%d): Unable to map %ld bytes @ 0x%08X\n",
-                            __FUNCTION__, __LINE__,
-                            physical, device->requestedRegisterMemSizes[i]
-                    );
+                    if (mem_region == gcvNULL)
+                    {
+                        gcmkTRACE_ZONE(
+                                gcvLEVEL_ERROR, gcvZONE_DRIVER,
+                                "%s(%d): Failed to claim %lu bytes @ 0x%08X\n",
+                                __FUNCTION__, __LINE__,
+                                physical, device->requestedRegisterMemSizes[i]
+                         );
 
                     gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
+                    }
+
+                    device->registerBases[i] = (gctPOINTER) ioremap_nocache(
+                            physical, device->requestedRegisterMemSizes[i]);
+
+                    if (device->registerBases[i] == gcvNULL)
+                    {
+                        gcmkTRACE_ZONE(
+                                gcvLEVEL_ERROR, gcvZONE_DRIVER,
+                                "%s(%d): Unable to map %ld bytes @ 0x%08X\n",
+                                __FUNCTION__, __LINE__,
+                                physical, device->requestedRegisterMemSizes[i]
+                        );
+
+                        gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
+                    }
                 }
 
                 physical += device->requestedRegisterMemSizes[i];
+
             }
         }
     }
@@ -1920,7 +1960,9 @@ gckGALDEVICE_Destroy(
                 if (Device->registerBases[i] != gcvNULL)
                 {
                     /* Unmap register memory. */
-                    iounmap(Device->registerBases[i]);
+                    if (Device->requestedRegisterMemBases[i] != 0)
+                        iounmap(Device->registerBases[i]);
+
                     if (Device->requestedRegisterMemBases[i] != 0)
                     {
                         release_mem_region(Device->requestedRegisterMemBases[i],
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
index 0890015..2b7c9aa 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -131,6 +131,8 @@ typedef struct _gcsDEVICE_CONSTRUCT_ARGS
     gctBOOL             contiguousRequested;
     gcsPLATFORM*        platform;
     gctBOOL             mmu;
+    gctBOOL             registerMemMapped;
+    gctPOINTER             registerMemAddress;
 }
 gcsDEVICE_CONSTRUCT_ARGS;
 
@@ -212,4 +214,30 @@ gceSTATUS gckGALDEVICE_Destroy(
     IN gckGALDEVICE Device
     );
 
+static gcmINLINE gckKERNEL
+_GetValidKernel(
+    gckGALDEVICE Device
+    )
+{
+    if (Device->kernels[gcvCORE_MAJOR])
+    {
+        return Device->kernels[gcvCORE_MAJOR];
+    }
+    else
+    if (Device->kernels[gcvCORE_2D])
+    {
+        return Device->kernels[gcvCORE_2D];
+    }
+    else
+    if (Device->kernels[gcvCORE_VG])
+    {
+        return Device->kernels[gcvCORE_VG];
+    }
+    else
+    {
+        gcmkASSERT(gcvFALSE);
+        return gcvNULL;
+    }
+}
+
 #endif /* __gc_hal_kernel_device_h_ */
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_iommu.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_iommu.c
index 43202f6..3964d0b 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_iommu.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_iommu.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c
index 344f058..f338156 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -265,6 +265,7 @@ gckKERNEL_MapVideoMemoryEx(
     gceSTATUS status;
     gctPOINTER logical    = gcvNULL;
     gctUINT32 baseAddress;
+    gctPHYS_ADDR_T physical;
 
     gcmkHEADER_ARG("Kernel=%p InUserSpace=%d Address=%08x",
                    Kernel, InUserSpace, Address);
@@ -345,9 +346,11 @@ gckKERNEL_MapVideoMemoryEx(
                 gckOS_CPUPhysicalToGPUPhysical(
                     Kernel->os,
                     device->contiguousVidMem->baseAddress - systemBaseAddress,
-                    &baseAddress
+                    &physical
                     ));
 
+            gcmkSAFECASTPHYSADDRT(baseAddress, physical);
+
             gcmkVERIFY_OK(
                 gckHARDWARE_SplitMemory(Kernel->hardware,
                                         baseAddress,
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
index 02847e9..5831996 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -80,6 +80,10 @@
 #endif
 #endif
 
+#ifndef CLASS_NAME
+#   define CLASS_NAME               "graphics_class"
+#endif
+
 #define GetPageCount(size, offset)     ((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION (3,7,0)
@@ -294,7 +298,7 @@ _ConvertLogical2Physical(
     IN gctPOINTER Logical,
     IN gctUINT32 ProcessID,
     IN PLINUX_MDL Mdl,
-    OUT gctUINT32_PTR Physical
+    OUT gctPHYS_ADDR_T * Physical
     );
 
 gctSTRING
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_math.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_math.c
index 326ec28..0aa0ca6 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_math.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_math.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_mutex.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_mutex.h
new file mode 100644
index 0000000..d21859c
--- /dev/null
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_mutex.h
@@ -0,0 +1,55 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+#ifndef _gc_hal_kernel_mutex_h_
+#define _gc_hal_kernel_mutex_h_
+
+#include "gc_hal.h"
+#include <linux/mutex.h>
+
+/* Create a new mutex. */
+#define gckOS_CreateMutex(Os, Mutex)                                \
+({                                                                  \
+    gceSTATUS _status;                                              \
+    gcmkHEADER_ARG("Os=0x%X", Os);                                  \
+                                                                    \
+    /* Validate the arguments. */                                   \
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);                               \
+    gcmkVERIFY_ARGUMENT(Mutex != gcvNULL);                          \
+                                                                    \
+    /* Allocate the mutex structure. */                             \
+    _status = gckOS_Allocate(Os, gcmSIZEOF(struct mutex), Mutex);   \
+                                                                    \
+    if (gcmIS_SUCCESS(_status))                                     \
+    {                                                               \
+        /* Initialize the mutex. */                                 \
+        mutex_init(*(struct mutex **)Mutex);                        \
+    }                                                               \
+                                                                    \
+    /* Return status. */                                            \
+    gcmkFOOTER_ARG("*Mutex=0x%X", *(struct mutex **)Mutex);         \
+    _status;                                                        \
+})
+
+#endif
+
+
+
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
index 2ec98dc..c4e7166 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -34,7 +34,7 @@
 #endif
 #include <linux/delay.h>
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
 #include <linux/anon_inodes.h>
 #endif
 
@@ -351,7 +351,7 @@ _DestroyIntegerId(
 gceSTATUS
 _QueryProcessPageTable(
     IN gctPOINTER Logical,
-    OUT gctUINT32 * Address
+    OUT gctPHYS_ADDR_T * Address
     )
 {
     spinlock_t *lock;
@@ -461,7 +461,7 @@ _HandleOuterCache(
     )
 {
     gceSTATUS status;
-    unsigned long paddr;
+    gctPHYS_ADDR_T paddr;
     gctPOINTER vaddr;
     gctUINT32 offset, bytes, left;
 
@@ -487,7 +487,7 @@ _HandleOuterCache(
 
             bytes = gcmMIN(left, PAGE_SIZE - offset);
 
-            gcmkONERROR(_QueryProcessPageTable(vaddr, (gctUINT32*)&paddr));
+            gcmkONERROR(_QueryProcessPageTable(vaddr, &paddr));
             gcmkONERROR(outer_func(Type, paddr, paddr + bytes));
 
             vaddr = (gctUINT8_PTR)vaddr + bytes;
@@ -534,7 +534,7 @@ _AllowAccess(
 #if gcdMULTI_GPU
     if (Core == gcvCORE_MAJOR)
     {
-        data = readl((gctUINT8 *)Os->device->registerBases[gcvCORE_3D_0_ID] + 0x0);
+        data = readl((gctUINT8 *)Os->device->registerBase3D[gcvCORE_3D_0_ID] + 0x0);
     }
     else
 #endif
@@ -1619,12 +1619,15 @@ gckOS_AllocateNonPagedMemory(
 
     kernel = Os->device->kernels[gcvCORE_MAJOR] != gcvNULL ?
                 Os->device->kernels[gcvCORE_MAJOR] : Os->device->kernels[gcvCORE_2D];
+
+#ifdef CONFLICT_BETWEEN_BASE_AND_PHYS
     if (((Os->device->baseAddress & 0x80000000) != (mdl->dmaHandle & 0x80000000)) &&
           kernel->hardware->mmuVersion == 0)
     {
         mdl->dmaHandle = (mdl->dmaHandle & ~0x80000000)
                        | (Os->device->baseAddress & 0x80000000);
     }
+#endif
 
     mdl->addr = addr;
 
@@ -1787,8 +1790,6 @@ OnError:
         /* Free LINUX_MDL. */
         gcmkVERIFY_OK(_DestroyMdl(mdl));
     }
-    *Physical = gcvNULL;
-    *Bytes = 0;
 
     if (locked)
     {
@@ -2152,6 +2153,126 @@ gceSTATUS gckOS_GetPageSize(
 
 /*******************************************************************************
 **
+**  gckOS_GetPhysicalAddressProcess
+**
+**  Get the physical system address of a corresponding virtual address for a
+**  given process.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to gckOS object.
+**
+**      gctPOINTER Logical
+**          Logical address.
+**
+**      gctUINT32 ProcessID
+**          Process ID.
+**
+**  OUTPUT:
+**
+**      gctUINT32 * Address
+**          Poinetr to a variable that receives the 32-bit physical adress.
+*/
+gceSTATUS
+_GetPhysicalAddressProcess(
+    IN gckOS Os,
+    IN gctPOINTER Logical,
+    IN gctUINT32 ProcessID,
+    OUT gctPHYS_ADDR_T * Address
+    )
+{
+    PLINUX_MDL mdl;
+    gctINT8_PTR base;
+    gckALLOCATOR allocator = gcvNULL;
+    gceSTATUS status = gcvSTATUS_INVALID_ADDRESS;
+
+    gcmkHEADER_ARG("Os=0x%X Logical=0x%X ProcessID=%d", Os, Logical, ProcessID);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Address != gcvNULL);
+
+    MEMORY_LOCK(Os);
+
+    /* First try the contiguous memory pool. */
+    if (Os->device->contiguousMapped)
+    {
+        base = (gctINT8_PTR) Os->device->contiguousBase;
+
+        if (((gctINT8_PTR) Logical >= base)
+        &&  ((gctINT8_PTR) Logical <  base + Os->device->contiguousSize)
+        )
+        {
+            /* Convert logical address into physical. */
+            *Address = Os->device->contiguousVidMem->baseAddress
+                     + (gctINT8_PTR) Logical - base;
+            status   = gcvSTATUS_OK;
+        }
+    }
+    else
+    {
+        /* Try the contiguous memory pool. */
+        mdl = (PLINUX_MDL) Os->device->contiguousPhysical;
+        status = _ConvertLogical2Physical(Os,
+                                          Logical,
+                                          ProcessID,
+                                          mdl,
+                                          Address);
+    }
+
+    if (gcmIS_ERROR(status))
+    {
+        /* Walk all MDLs. */
+        for (mdl = Os->mdlHead; mdl != gcvNULL; mdl = mdl->next)
+        {
+            /* Try this MDL. */
+            allocator = mdl->allocator;
+
+            if (allocator)
+            {
+                status = allocator->ops->LogicalToPhysical(
+                            allocator,
+                            mdl,
+                            Logical,
+                            ProcessID,
+                            Address
+                            );
+            }
+            else
+            {
+                status = _ConvertLogical2Physical(Os,
+                            Logical,
+                            ProcessID,
+                            mdl,
+                            Address);
+            }
+
+            if (gcmIS_SUCCESS(status))
+            {
+                break;
+            }
+        }
+    }
+
+    MEMORY_UNLOCK(Os);
+
+    gcmkONERROR(status);
+
+    /* Success. */
+    gcmkFOOTER_ARG("*Address=0x%08x", *Address);
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
+}
+
+
+
+/*******************************************************************************
+**
 **  gckOS_GetPhysicalAddress
 **
 **  Get the physical system address of a corresponding virtual address.
@@ -2173,7 +2294,7 @@ gceSTATUS
 gckOS_GetPhysicalAddress(
     IN gckOS Os,
     IN gctPOINTER Logical,
-    OUT gctUINT32 * Address
+    OUT gctPHYS_ADDR_T * Address
     )
 {
     gceSTATUS status;
@@ -2195,7 +2316,7 @@ gckOS_GetPhysicalAddress(
 
         /* Route through other function. */
         gcmkONERROR(
-            gckOS_GetPhysicalAddressProcess(Os, Logical, processID, Address));
+            _GetPhysicalAddressProcess(Os, Logical, processID, Address));
     }
 
     gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(Os, *Address, Address));
@@ -2232,7 +2353,7 @@ OnError:
 gceSTATUS gckOS_UserLogicalToPhysical(
     IN gckOS Os,
     IN gctPOINTER Logical,
-    OUT gctUINT32 * Address
+    OUT gctPHYS_ADDR_T * Address
     )
 {
     return gckOS_GetPhysicalAddress(Os, Logical, Address);
@@ -2329,7 +2450,7 @@ _ConvertLogical2Physical(
     IN gctPOINTER Logical,
     IN gctUINT32 ProcessID,
     IN PLINUX_MDL Mdl,
-    OUT gctUINT32_PTR Physical
+    OUT gctPHYS_ADDR_T * Physical
     )
 {
     gctINT8_PTR base, vBase;
@@ -2420,124 +2541,6 @@ _ConvertLogical2Physical(
 
 /*******************************************************************************
 **
-**  gckOS_GetPhysicalAddressProcess
-**
-**  Get the physical system address of a corresponding virtual address for a
-**  given process.
-**
-**  INPUT:
-**
-**      gckOS Os
-**          Pointer to gckOS object.
-**
-**      gctPOINTER Logical
-**          Logical address.
-**
-**      gctUINT32 ProcessID
-**          Process ID.
-**
-**  OUTPUT:
-**
-**      gctUINT32 * Address
-**          Poinetr to a variable that receives the 32-bit physical adress.
-*/
-gceSTATUS
-gckOS_GetPhysicalAddressProcess(
-    IN gckOS Os,
-    IN gctPOINTER Logical,
-    IN gctUINT32 ProcessID,
-    OUT gctUINT32 * Address
-    )
-{
-    PLINUX_MDL mdl;
-    gctINT8_PTR base;
-    gckALLOCATOR allocator = gcvNULL;
-    gceSTATUS status = gcvSTATUS_INVALID_ADDRESS;
-
-    gcmkHEADER_ARG("Os=0x%X Logical=0x%X ProcessID=%d", Os, Logical, ProcessID);
-
-    /* Verify the arguments. */
-    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT(Address != gcvNULL);
-
-    MEMORY_LOCK(Os);
-
-    /* First try the contiguous memory pool. */
-    if (Os->device->contiguousMapped)
-    {
-        base = (gctINT8_PTR) Os->device->contiguousBase;
-
-        if (((gctINT8_PTR) Logical >= base)
-        &&  ((gctINT8_PTR) Logical <  base + Os->device->contiguousSize)
-        )
-        {
-            /* Convert logical address into physical. */
-            *Address = Os->device->contiguousVidMem->baseAddress
-                     + (gctINT8_PTR) Logical - base;
-            status   = gcvSTATUS_OK;
-        }
-    }
-    else
-    {
-        /* Try the contiguous memory pool. */
-        mdl = (PLINUX_MDL) Os->device->contiguousPhysical;
-        status = _ConvertLogical2Physical(Os,
-                                          Logical,
-                                          ProcessID,
-                                          mdl,
-                                          Address);
-    }
-
-    if (gcmIS_ERROR(status))
-    {
-        /* Walk all MDLs. */
-        for (mdl = Os->mdlHead; mdl != gcvNULL; mdl = mdl->next)
-        {
-            /* Try this MDL. */
-            allocator = mdl->allocator;
-
-            if (allocator)
-            {
-                status = allocator->ops->LogicalToPhysical(
-                            allocator,
-                            mdl,
-                            Logical,
-                            ProcessID,
-                            Address
-                            );
-            }
-            else
-            {
-                status = _ConvertLogical2Physical(Os,
-                            Logical,
-                            ProcessID,
-                            mdl,
-                            Address);
-            }
-
-            if (gcmIS_SUCCESS(status))
-            {
-                break;
-            }
-        }
-    }
-
-    MEMORY_UNLOCK(Os);
-
-    gcmkONERROR(status);
-
-    /* Success. */
-    gcmkFOOTER_ARG("*Address=0x%08x", *Address);
-    return gcvSTATUS_OK;
-
-OnError:
-    /* Return the status. */
-    gcmkFOOTER();
-    return status;
-}
-
-/*******************************************************************************
-**
 **  gckOS_MapPhysical
 **
 **  Map a physical address into kernel space.
@@ -2746,52 +2749,6 @@ gckOS_UnmapPhysical(
 
 /*******************************************************************************
 **
-**  gckOS_CreateMutex
-**
-**  Create a new mutex.
-**
-**  INPUT:
-**
-**      gckOS Os
-**          Pointer to an gckOS object.
-**
-**  OUTPUT:
-**
-**      gctPOINTER * Mutex
-**          Pointer to a variable that will hold a pointer to the mutex.
-*/
-gceSTATUS
-gckOS_CreateMutex(
-    IN gckOS Os,
-    OUT gctPOINTER * Mutex
-    )
-{
-    gceSTATUS status;
-
-    gcmkHEADER_ARG("Os=0x%X", Os);
-
-    /* Validate the arguments. */
-    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT(Mutex != gcvNULL);
-
-    /* Allocate the mutex structure. */
-    gcmkONERROR(gckOS_Allocate(Os, gcmSIZEOF(struct mutex), Mutex));
-
-    /* Initialize the mutex. */
-    mutex_init(*Mutex);
-
-    /* Return status. */
-    gcmkFOOTER_ARG("*Mutex=0x%X", *Mutex);
-    return gcvSTATUS_OK;
-
-OnError:
-    /* Return status. */
-    gcmkFOOTER();
-    return status;
-}
-
-/*******************************************************************************
-**
 **  gckOS_DeleteMutex
 **
 **  Delete a mutex.
@@ -3722,7 +3679,6 @@ OnError:
         /* Free the memory. */
         _DestroyMdl(mdl);
     }
-    *Physical = gcvNULL;
 
     /* Return the status. */
     gcmkFOOTER_ARG("Os=0x%X Flag=%x Bytes=%lu", Os, Flag, Bytes);
@@ -4026,7 +3982,7 @@ gckOS_MapPagesEx(
     while (PageCount-- > 0)
     {
         gctUINT i;
-        gctUINT32 phys = ~0;
+        gctPHYS_ADDR_T phys = ~0U;
 
         if (mdl->pagedMem && !mdl->contiguous)
         {
@@ -5045,6 +5001,7 @@ OnError:
 
                         if (!((physical - Os->device->baseAddress) & 0x80000000))
                         {
+                            gctPHYS_ADDR_T gpuPhysical;
                             kfree(pages);
                             pages = gcvNULL;
 
@@ -5057,7 +5014,9 @@ OnError:
                             *Info    = info;
 
                             gcmkVERIFY_OK(
-                                gckOS_CPUPhysicalToGPUPhysical(Os, *Address, Address));
+                                gckOS_CPUPhysicalToGPUPhysical(Os, *Address, &gpuPhysical));
+
+                            gcmkSAFECASTPHYSADDRT(*Address, gpuPhysical);
 
                             gcmkFOOTER_ARG("*Info=0x%X *Address=0x%08x",
                                            *Info, *Address);
@@ -5177,7 +5136,7 @@ OnError:
         /* Fill the page table. */
         for (i = 0; i < pageCount; i++)
         {
-            gctUINT32 phys;
+            gctPHYS_ADDR_T phys;
             gctUINT32_PTR tab = pageTable + i * (PAGE_SIZE/4096);
 
 #if gcdPROCESS_ADDRESS_SPACE
@@ -5796,7 +5755,7 @@ gckOS_CacheClean(
     IN gckOS Os,
     IN gctUINT32 ProcessID,
     IN gctPHYS_ADDR Handle,
-    IN gctUINT32 Physical,
+    IN gctPHYS_ADDR_T Physical,
     IN gctPOINTER Logical,
     IN gctSIZE_T Bytes
     )
@@ -5900,7 +5859,7 @@ gckOS_CacheInvalidate(
     IN gckOS Os,
     IN gctUINT32 ProcessID,
     IN gctPHYS_ADDR Handle,
-    IN gctUINT32 Physical,
+    IN gctPHYS_ADDR_T Physical,
     IN gctPOINTER Logical,
     IN gctSIZE_T Bytes
     )
@@ -6000,7 +5959,7 @@ gckOS_CacheFlush(
     IN gckOS Os,
     IN gctUINT32 ProcessID,
     IN gctPHYS_ADDR Handle,
-    IN gctUINT32 Physical,
+    IN gctPHYS_ADDR_T Physical,
     IN gctPOINTER Logical,
     IN gctSIZE_T Bytes
     )
@@ -8574,7 +8533,7 @@ gckOS_AllocatePageArray(
         {
             if (allocator)
             {
-                gctUINT32 phys_addr;
+                gctPHYS_ADDR_T phys_addr;
                 allocator->ops->Physical(allocator, mdl, offset, &phys_addr);
                 phys = (unsigned long)phys_addr;
             }
@@ -8609,8 +8568,8 @@ OnError:
 gceSTATUS
 gckOS_CPUPhysicalToGPUPhysical(
     IN gckOS Os,
-    IN gctUINT32 CPUPhysical,
-    IN gctUINT32_PTR GPUPhysical
+    IN gctPHYS_ADDR_T CPUPhysical,
+    IN gctPHYS_ADDR_T * GPUPhysical
     )
 {
     gcsPLATFORM * platform;
@@ -8651,7 +8610,7 @@ gceSTATUS
 gckOS_PhysicalToPhysicalAddress(
     IN gckOS Os,
     IN gctPOINTER Physical,
-    OUT gctUINT32 * PhysicalAddress
+    OUT gctPHYS_ADDR_T * PhysicalAddress
     )
 {
     PLINUX_MDL mdl = (PLINUX_MDL)Physical;
@@ -8693,6 +8652,11 @@ gckOS_QueryOption(
 #endif
         return gcvSTATUS_OK;
     }
+    else if (!strcmp(Option, "contiguousSize"))
+    {
+        *Value = device->contiguousSize;
+        return gcvSTATUS_OK;
+    }
 
     return gcvSTATUS_NOT_SUPPORTED;
 }
@@ -8724,7 +8688,7 @@ gckOS_GetFd(
     OUT gctINT *Fd
     )
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
     *Fd = anon_inode_getfd(Name, &fd_fops, Private, O_RDWR);
 
     if (*Fd < 0)
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
index 9d3126d..d774ee9 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_platform.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_platform.h
index 23b7178..eb84c6c 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_platform.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_platform.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -59,6 +59,8 @@ typedef struct _gcsMODULE_PARAMETERS
     gctUINT stuckDump;
     gctUINT showArgs;
     gctUINT gpu3DMinClock;
+    gctBOOL registerMemMapped;
+    gctPOINTER registerMemAddress;
 }
 gcsMODULE_PARAMETERS;
 
@@ -215,8 +217,8 @@ typedef struct _gcsPLATFORM_OPERATIONS
     gceSTATUS
     (*getGPUPhysical)(
         IN gckPLATFORM Platform,
-        IN gctUINT32 CPUPhysical,
-        OUT gctUINT32_PTR GPUPhysical
+        IN gctPHYS_ADDR_T CPUPhysical,
+        OUT gctPHYS_ADDR_T * GPUPhysical
         );
 
     /*******************************************************************************
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_probe.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_probe.c
index 054e32e..06b5c8e 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_probe.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_probe.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -138,7 +138,7 @@ module_param(recovery, uint, 0644);
 MODULE_PARM_DESC(recovery, "Recover GPU from stuck (1: Enable, 0: Disable)");
 
 /* Middle needs about 40KB buffer, Maximal may need more than 200KB buffer. */
-static uint stuckDump = 1;
+static uint stuckDump = 0;
 module_param(stuckDump, uint, 0644);
 MODULE_PARM_DESC(stuckDump, "Level of stuck dump content (1: Minimal, 2: Middle, 3: Maximal)");
 
@@ -152,6 +152,10 @@ static int gpu3DMinClock = 1;
 
 static int contiguousRequested = 0;
 
+
+static gctBOOL registerMemMapped = gcvFALSE;
+static gctPOINTER registerMemAddress = gcvNULL;
+
 static int drv_open(
     struct inode* inode,
     struct file* filp
@@ -199,9 +203,11 @@ _UpdateModuleParam(
     irqLine2D         = Param->irqLine2D      ;
     registerMemBase2D = Param->registerMemBase2D;
     registerMemSize2D = Param->registerMemSize2D;
+#if gcdENABLE_VG
     irqLineVG         = Param->irqLineVG;
     registerMemBaseVG = Param->registerMemBaseVG;
     registerMemSizeVG = Param->registerMemSizeVG;
+#endif
     contiguousSize    = Param->contiguousSize;
     contiguousBase    = Param->contiguousBase;
     bankSize          = Param->bankSize;
@@ -218,6 +224,8 @@ _UpdateModuleParam(
     showArgs          = Param->showArgs;
     contiguousRequested = Param->contiguousRequested;
     gpu3DMinClock     = Param->gpu3DMinClock;
+    registerMemMapped    = Param->registerMemMapped;
+    registerMemAddress    = Param->registerMemAddress;
 }
 
 void
@@ -815,6 +823,8 @@ static int drv_init(void)
         .contiguousRequested = contiguousRequested,
         .platform           = &platform,
         .mmu                = mmu,
+        .registerMemMapped = registerMemMapped,
+        .registerMemAddress = registerMemAddress,
     };
 
     gcmkHEADER();
@@ -904,7 +914,7 @@ static int drv_init(void)
     }
 
     /* Create the device class. */
-    device_class = class_create(THIS_MODULE, "graphics_class");
+    device_class = class_create(THIS_MODULE, CLASS_NAME);
 
     if (IS_ERR(device_class))
     {
@@ -1029,6 +1039,7 @@ static int __devinit gpu_probe(struct platform_device *pdev)
         .stuckDump          = stuckDump,
         .showArgs           = showArgs,
         .gpu3DMinClock      = gpu3DMinClock,
+        .registerMemMapped    = registerMemMapped,
     };
 
     gcmkHEADER();
@@ -1249,6 +1260,7 @@ static struct platform_driver gpu_driver = {
     .resume     = gpu_resume,
 
     .driver     = {
+        .owner = THIS_MODULE,
         .name   = DEVICE_NAME,
 #if defined(CONFIG_PM) && LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 30)
         .pm     = &gpu_pm_ops,
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_security_channel.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_security_channel.c
index e745a6f..e547ac3 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_security_channel.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_security_channel.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -50,7 +50,7 @@ gpu3d_allocate_secure_mem(
     TEEC_Context *context = &teecContext;
     TEEC_SharedMemory *shm = NULL;
     void *handle = NULL;
-    unsigned int phyAddr = 0xFFFFFFFF;
+    gctPHYS_ADDR_T phyAddr;
     gceSTATUS status;
     gctSIZE_T bytes = size;
 
@@ -95,7 +95,7 @@ gpu3d_allocate_secure_mem(
     shm->flags = TEEC_MEM_INPUT;
 
     /* Use TEE Client API to register the underlying memory buffer. */
-    shm->phyAddr = (void *)phyAddr;
+    shm->phyAddr = (void *)(gctUINT32)phyAddr;
 
     result = TEEC_RegisterSharedMemory(
             context,
@@ -156,6 +156,10 @@ static TEEC_Result gpu3d_session_callback(
             TEEC_SharedMemory *shm = NULL;
 
             shm = gpu3d_allocate_secure_mem(channel->os, size);
+            if (shm == NULL)
+            {
+                return TEEC_ERROR_OUT_OF_MEMORY;
+            }
 
             /* use the value to save the pointer in client side */
             operation->params[0].value.a = (uint32_t)shm;
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.c
index 0e5a816..9822669 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.h
index 8a69921..95d63e4 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_sync.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx6q14.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx6q14.c
index 10d7fd3..a46f5aa 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx6q14.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx6q14.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2014 by Vivante Corp.
+*    Copyright (C) 2005 - 2015 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -181,6 +181,10 @@ static int force_contiguous_lowmem_shrink(IN gckKERNEL Kernel)
 	return ret;
 }
 
+extern gckKERNEL
+_GetValidKernel(
+  gckGALDEVICE Device
+  );
 
 gceSTATUS
 _ShrinkMemory(
@@ -195,7 +199,7 @@ _ShrinkMemory(
 
     galDevice = platform_get_drvdata(pdev);
 
-    kernel = galDevice->kernels[gcvCORE_MAJOR];
+    kernel = _GetValidKernel(galDevice);
 
     if (kernel != gcvNULL)
     {
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx6q14.config b/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx6q14.config
index 6575148..afb5119 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx6q14.config
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx6q14.config
@@ -13,3 +13,6 @@ endif
 EXTRA_CFLAGS += -DLINUX_CMA_FSL=1
 ALLOCATOR_ARRAY_H_LOCATION := $(OS_KERNEL_DIR)/allocator/freescale
 CUSTOMER_ALLOCATOR_OBJS := $(ALLOCATOR_ARRAY_H_LOCATION)/gc_hal_kernel_allocator_cma.o
+
+EXTRA_CFLAGS += -DCLASS_NAME=\"gpu_class\"
+
-- 
1.7.5.4

