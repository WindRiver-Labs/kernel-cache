From 85c1952ff22944de8db505bf9476152ad0acb5d4 Mon Sep 17 00:00:00 2001
From: Limeng <Meng.Li@windriver.com>
Date: Thu, 25 Feb 2016 18:21:13 +0800
Subject: [PATCH 1586/1594] driver: media: mxc_vout: backup priv field of
 v4l2_pix_format structure for mxc_vout driver

The commit d52e23813672 ("v4l: Support extending the v4l2_pix_format
structure") use the priv field in v4l2_pix_format as a magic value. But
this filed has already been used by mxc driver to save some private data.
In order to preserve this feature, and modify code to backup priv
of v4l2_pix_format structure before v4l2 core modify it. In mxc driver,
using backup value.  After leaving v4l2 core, restore priv of
v4l2_pix_format structure. In this way, we can leverage some
fsl pre-built binary application to verify some functions of vpu.

Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/media/platform/mxc/output/mxc_vout.c |   30 +++++++++++++++++++++++++-
 1 files changed, 29 insertions(+), 1 deletions(-)

diff --git a/drivers/media/platform/mxc/output/mxc_vout.c b/drivers/media/platform/mxc/output/mxc_vout.c
index 285f9ff..ef4c7b9 100644
--- a/drivers/media/platform/mxc/output/mxc_vout.c
+++ b/drivers/media/platform/mxc/output/mxc_vout.c
@@ -150,6 +150,7 @@ struct mxc_vout_dev {
 static int debug;
 static int vdi_rate_double;
 static int video_nr = 16;
+static unsigned int private_data_backup;
 
 /* Module parameters */
 module_param(video_nr, int, S_IRUGO);
@@ -1054,6 +1055,7 @@ static int mxc_vidioc_g_fmt_vid_out(struct file *file, void *fh,
 	struct mxc_vout_output *vout = fh;
 	struct v4l2_rect rect;
 
+	f->fmt.pix.priv = private_data_backup;
 	f->fmt.pix.width = vout->task.input.width;
 	f->fmt.pix.height = vout->task.input.height;
 	f->fmt.pix.pixelformat = vout->task.input.format;
@@ -1291,6 +1293,8 @@ static int mxc_vout_try_format(struct mxc_vout_output *vout,
 	int ret = 0;
 	struct v4l2_rect rect;
 
+	f->fmt.pix.priv = private_data_backup;
+
 	if ((f->fmt.pix.field != V4L2_FIELD_NONE) &&
 		(IPU_PIX_FMT_TILED_NV12 == vout->task.input.format)) {
 		v4l2_err(vout->vfd->v4l2_dev,
@@ -2081,6 +2085,30 @@ static int mxc_vidioc_streamoff(struct file *file, void *fh,
 	return ret;
 }
 
+static long mxc_video_ioctl(struct file *file, unsigned int cmd,
+			 unsigned long arg)
+{
+	long ret = 0;
+
+	if (cmd == VIDIOC_G_FMT || cmd == VIDIOC_S_FMT) {
+		char buf[_IOC_SIZE(cmd)];
+
+		memset(buf, 0x00, _IOC_SIZE(cmd));
+		if (copy_from_user(buf, (void __user *)arg, _IOC_SIZE(cmd)))
+			return -EINVAL;
+		private_data_backup = ((struct v4l2_format *)buf)->fmt.pix.priv;
+
+		ret = video_ioctl2(file, cmd, arg);
+
+		((struct v4l2_format __user *)arg)->fmt.pix.priv =
+					private_data_backup;
+
+		return ret;
+	} else {
+		return video_ioctl2(file, cmd, arg);
+	}
+}
+
 static const struct v4l2_ioctl_ops mxc_vout_ioctl_ops = {
 	.vidioc_querycap			= mxc_vidioc_querycap,
 	.vidioc_enum_fmt_vid_out		= mxc_vidioc_enum_fmt_vid_out,
@@ -2102,7 +2130,7 @@ static const struct v4l2_ioctl_ops mxc_vout_ioctl_ops = {
 
 static const struct v4l2_file_operations mxc_vout_fops = {
 	.owner		= THIS_MODULE,
-	.unlocked_ioctl	= video_ioctl2,
+	.unlocked_ioctl	= mxc_video_ioctl,
 	.mmap		= mxc_vout_mmap,
 	.open		= mxc_vout_open,
 	.release	= mxc_vout_release,
-- 
1.7.5.4

