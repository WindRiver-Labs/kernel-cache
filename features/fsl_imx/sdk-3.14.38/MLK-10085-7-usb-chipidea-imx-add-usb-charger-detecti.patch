From f723989cff4d28f0b43660ff4b8a5c76c5fcf715 Mon Sep 17 00:00:00 2001
From: Li Jun <b47624@freescale.com>
Date: Fri, 9 Jan 2015 21:58:41 +0800
Subject: [PATCH 1305/1594] MLK-10085-7 usb: chipidea: imx: add usb charger
 detection for imx6

commit da98a621a79b6febf4e072ffb99e16e20b5bc36a from
git://git.freescale.com/imx/linux-2.6-imx.git

The usb controller driver creates usb charger, and notify
the charger connect and disconnect using vbus connect and
disconnect event.

Signed-off-by: Peter Chen <peter.chen@freescale.com>
Signed-off-by: Li Jun <jun.li@freescale.com>
---
 drivers/usb/chipidea/ci_hdrc_imx.c |   74 +++++++++++++++++++++++++++++++++++-
 1 files changed, 72 insertions(+), 2 deletions(-)

diff --git a/drivers/usb/chipidea/ci_hdrc_imx.c b/drivers/usb/chipidea/ci_hdrc_imx.c
index 846ceb9..dd03075 100644
--- a/drivers/usb/chipidea/ci_hdrc_imx.c
+++ b/drivers/usb/chipidea/ci_hdrc_imx.c
@@ -19,6 +19,10 @@
 #include <linux/dma-mapping.h>
 #include <linux/usb/chipidea.h>
 #include <linux/clk.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+#include <linux/power/imx6_usb_charger.h>
 
 #include "ci.h"
 #include "ci_hdrc_imx.h"
@@ -68,6 +72,9 @@ struct ci_hdrc_imx_data {
 	struct imx_usbmisc_data *usbmisc_data;
 	bool supports_runtime_pm;
 	bool in_lpm;
+	bool imx6_usb_charger_detection;
+	struct usb_charger charger;
+	struct regmap *anatop;
 	/* SoC before i.mx6 (except imx23/imx28) needs three clks */
 	bool need_three_clks;
 	struct clk *clk_ipg;
@@ -222,6 +229,37 @@ static void imx_disable_unprepare_clks(struct device *dev)
 	}
 }
 
+static int ci_hdrc_imx_notify_event(struct ci_hdrc *ci, unsigned event)
+{
+	struct device *dev = ci->dev->parent;
+	struct ci_hdrc_imx_data *data = dev_get_drvdata(dev);
+	int ret = 0;
+
+	switch (event) {
+	case CI_HDRC_CONTROLLER_VBUS_EVENT:
+		if (data->usbmisc_data && ci->vbus_active) {
+			if (data->imx6_usb_charger_detection)
+				ret = imx6_usb_vbus_connect(&data->charger);
+			if (!ret && data->charger.psy_desc.type !=
+						POWER_SUPPLY_TYPE_USB)
+				ret = CI_HDRC_NOTIFY_RET_DEFER_EVENT;
+		} else if (data->usbmisc_data && !ci->vbus_active) {
+			if (data->imx6_usb_charger_detection)
+				ret = imx6_usb_vbus_disconnect(&data->charger);
+		}
+		break;
+	case CI_HDRC_CONTROLLER_CHARGER_POST_EVENT:
+		if (!data->imx6_usb_charger_detection)
+			return ret;
+		imx6_usb_charger_detect_post(&data->charger);
+		break;
+	default:
+		dev_dbg(dev, "unknown event\n");
+	}
+
+	return ret;
+}
+
 static int ci_hdrc_imx_probe(struct platform_device *pdev)
 {
 	struct ci_hdrc_imx_data *data;
@@ -229,11 +267,13 @@ static int ci_hdrc_imx_probe(struct platform_device *pdev)
 		.name		= dev_name(&pdev->dev),
 		.capoffset	= DEF_CAPOFFSET,
 		.flags		= CI_HDRC_DISABLE_STREAMING,
+		.notify_event = ci_hdrc_imx_notify_event,
 	};
 	int ret;
 	const struct of_device_id *of_id =
 			of_match_device(ci_hdrc_imx_dt_ids, &pdev->dev);
 	const struct ci_hdrc_imx_platform_flag *imx_platform_flag = of_id->data;
+	struct device_node *np = pdev->dev.of_node;
 
 	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
 	if (!data)
@@ -270,10 +310,35 @@ static int ci_hdrc_imx_probe(struct platform_device *pdev)
 	if (ret)
 		goto err_clk;
 
+	if (of_find_property(np, "imx6-usb-charger-detection", NULL))
+		data->imx6_usb_charger_detection = true;
+
+	if (of_find_property(np, "fsl,anatop", NULL)) {
+		data->anatop = syscon_regmap_lookup_by_phandle(np,
+							"fsl,anatop");
+		if (IS_ERR(data->anatop)) {
+			dev_dbg(&pdev->dev,
+				"failed to find regmap for anatop\n");
+			ret = PTR_ERR(data->anatop);
+			goto err_clk;
+		}
+		if (data->imx6_usb_charger_detection) {
+			data->charger.anatop = data->anatop;
+			data->charger.dev = &pdev->dev;
+			ret = imx6_usb_create_charger(&data->charger,
+						"imx6_usb_charger");
+			if (ret && ret != -ENODEV)
+				goto err_clk;
+			if (!ret)
+				dev_dbg(&pdev->dev,
+					"USB Charger is created\n");
+		}
+	}
+
 	ret = imx_usbmisc_init(data->usbmisc_data);
 	if (ret) {
 		dev_err(&pdev->dev, "usbmisc init failed, ret=%d\n", ret);
-		goto err_clk;
+		goto remove_charger;
 	}
 
 	data->ci_pdev = ci_hdrc_add_device(&pdev->dev,
@@ -284,7 +349,7 @@ static int ci_hdrc_imx_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev,
 			"Can't register ci_hdrc platform device, err=%d\n",
 			ret);
-		goto err_clk;
+		goto remove_charger;
 	}
 
 	ret = imx_usbmisc_init_post(data->usbmisc_data);
@@ -304,6 +369,9 @@ static int ci_hdrc_imx_probe(struct platform_device *pdev)
 
 disable_device:
 	ci_hdrc_remove_device(data->ci_pdev);
+remove_charger:
+	if (data->imx6_usb_charger_detection)
+		imx6_usb_remove_charger(&data->charger);
 err_clk:
 	imx_disable_unprepare_clks(&pdev->dev);
 	return ret;
@@ -320,6 +388,8 @@ static int ci_hdrc_imx_remove(struct platform_device *pdev)
 	}
 	ci_hdrc_remove_device(data->ci_pdev);
 	imx_disable_unprepare_clks(&pdev->dev);
+	if (data->imx6_usb_charger_detection)
+		imx6_usb_remove_charger(&data->charger);
 
 	return 0;
 }
-- 
1.7.5.4

