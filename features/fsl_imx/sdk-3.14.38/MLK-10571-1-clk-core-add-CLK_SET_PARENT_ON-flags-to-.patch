From 0ec2a9f2fb3dec2c4cf79cf5109cc29e40788b29 Mon Sep 17 00:00:00 2001
From: Dong Aisheng <b29396@freescale.com>
Date: Tue, 31 Mar 2015 21:20:26 +0800
Subject: [PATCH 0615/1594] MLK-10571-1 clk: core: add CLK_SET_PARENT_ON flags
 to support clocks require parent on

commit ba5aa5dbc8e8775662499f69531c7a5fab0b5798 from
git://git.freescale.com/imx/linux-2.6-imx.git

On Freescale i.MX7D platform, all clocks operations, including enable/disable,
rate change and re-parent, requires its parent clock on.
Current clock core can not support it well.
This patch introduce a new flag CLK_SET_PARENT_ON to handle this special case
in clock core that enable its parent clock firstly for each operation and disable
it later after operation complete.

The most special case is for set_parent() operation which requires both parent,
old one and new one, to be enabled at the same time during the operation.

Acked-by: Ranjani Vaidyanathan <Ranjani.Vaidyanathan@freescale.com>
Signed-off-by: Dong Aisheng <b29396@freescale.com>
---
 drivers/clk/clk.c            |   67 ++++++++++++++++++++++++++++++++++++-----
 include/linux/clk-provider.h |    5 +++
 2 files changed, 63 insertions(+), 9 deletions(-)

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 26b5eaa..5cfc6db 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -509,6 +509,7 @@ static void clk_unprepare_unused_subtree(struct clk_core *clk)
 static void clk_disable_unused_subtree(struct clk_core *clk)
 {
 	struct clk_core *child;
+	struct clk *parent = NULL;
 	unsigned long flags;
 
 	lockdep_assert_held(&prepare_lock);
@@ -516,6 +517,12 @@ static void clk_disable_unused_subtree(struct clk_core *clk)
 	hlist_for_each_entry(child, &clk->children, child_node)
 		clk_disable_unused_subtree(child);
 
+	if (clk->flags & CLK_SET_PARENT_ON) {
+		parent = clk_get_parent(clk->hw->clk);
+		WARN(!parent, "%s no parent found but has CLK_SET_PARENT_ON claimed\n", clk->name);
+		clk_prepare_enable(parent);
+	}
+
 	flags = clk_enable_lock();
 
 	if (clk->enable_count)
@@ -540,6 +547,8 @@ static void clk_disable_unused_subtree(struct clk_core *clk)
 
 unlock_out:
 	clk_enable_unlock(flags);
+	if (clk->flags & CLK_SET_PARENT_ON)
+		clk_disable_unprepare(parent);
 }
 
 static bool clk_ignore_unused;
@@ -1458,7 +1467,7 @@ static struct clk_core *__clk_set_parent_before(struct clk_core *clk,
 	struct clk_core *old_parent = clk->parent;
 
 	/*
-	 * Migrate prepare state between parents and prevent race with
+	 * 1. Migrate prepare state between parents and prevent race with
 	 * clk_enable().
 	 *
 	 * If the clock is not prepared, then a race with
@@ -1473,12 +1482,20 @@ static struct clk_core *__clk_set_parent_before(struct clk_core *clk,
 	 * hardware and software states.
 	 *
 	 * See also: Comment for clk_set_parent() below.
+	 *
+	 * 2. enable two parents clock for .set_parent() operation if finding
+	 * flag CLK_SET_PARENT_ON
 	 */
-	if (clk->prepare_count) {
+	if (clk->prepare_count || clk->flags & CLK_SET_PARENT_ON) {
 		clk_core_prepare(parent);
 		flags = clk_enable_lock();
 		clk_core_enable(parent);
-		clk_core_enable(clk);
+		if (clk->prepare_count) {
+			clk_core_enable(clk);
+		} else {
+			clk_core_prepare(old_parent);
+			clk_core_enable(old_parent);
+		}
 		clk_enable_unlock(flags);
 	}
 
@@ -1500,12 +1517,21 @@ static void __clk_set_parent_after(struct clk_core *core,
 	 * Finish the migration of prepare state and undo the changes done
 	 * for preventing a race with clk_enable().
 	 */
-	if (core->prepare_count) {
+	if (core->prepare_count || core->flags & CLK_SET_PARENT_ON) {
 		flags = clk_enable_lock();
-		clk_core_disable(core);
 		clk_core_disable(old_parent);
 		clk_enable_unlock(flags);
 		clk_core_unprepare(old_parent);
+		if (core->prepare_count) {
+			flags = clk_enable_lock();
+			clk_core_disable(core);
+			clk_enable_unlock(flags);
+		} else {
+			flags = clk_enable_lock();
+			clk_core_disable(parent);
+			clk_enable_unlock(flags);
+			clk_core_unprepare(parent);
+		}
 	}
 }
 
@@ -1531,12 +1557,21 @@ static int __clk_set_parent(struct clk_core *clk, struct clk_core *parent,
 		clk_reparent(clk, old_parent);
 		clk_enable_unlock(flags);
 
-		if (clk->prepare_count) {
+		if (clk->prepare_count || clk->flags & CLK_SET_PARENT_ON) {
 			flags = clk_enable_lock();
-			clk_core_disable(clk);
 			clk_core_disable(parent);
 			clk_enable_unlock(flags);
 			clk_core_unprepare(parent);
+			if (clk->prepare_count) {
+				flags = clk_enable_lock();
+				clk_core_disable(clk);
+				clk_enable_unlock(flags);
+			} else {
+				flags = clk_enable_lock();
+				clk_core_disable(old_parent);
+				clk_enable_unlock(flags);
+				clk_core_unprepare(old_parent);
+			}
 		}
 		return ret;
 	}
@@ -1752,13 +1787,17 @@ static void clk_change_rate(struct clk_core *clk)
 	unsigned long best_parent_rate = 0;
 	bool skip_set_rate = false;
 	struct clk_core *old_parent;
+	struct clk_core *parent = NULL;
 
 	old_rate = clk->rate;
 
-	if (clk->new_parent)
+	if (clk->new_parent) {
+		parent = clk->new_parent;
 		best_parent_rate = clk->new_parent->rate;
-	else if (clk->parent)
+	} else if (clk->parent) {
+		parent = clk->parent;
 		best_parent_rate = clk->parent->rate;
+	}
 
 	if (clk->new_parent && clk->new_parent != clk->parent) {
 		old_parent = __clk_set_parent_before(clk, clk->new_parent);
@@ -1777,6 +1816,11 @@ static void clk_change_rate(struct clk_core *clk)
 		__clk_set_parent_after(clk, clk->new_parent, old_parent);
 	}
 
+	if (clk->flags & CLK_SET_PARENT_ON && parent) {
+		clk_core_prepare(parent);
+		clk_core_enable(parent);
+	}
+
 	trace_clk_set_rate(clk, clk->new_rate);
 
 	if (!skip_set_rate && clk->ops->set_rate)
@@ -1786,6 +1830,11 @@ static void clk_change_rate(struct clk_core *clk)
 
 	clk->rate = clk_recalc(clk, best_parent_rate);
 
+	if (clk->flags & CLK_SET_PARENT_ON && parent) {
+		clk_core_disable(parent);
+		clk_core_unprepare(parent);
+	}
+
 	if (clk->notifier_count && old_rate != clk->rate)
 		__clk_notify(clk, POST_RATE_CHANGE, old_rate, clk->rate);
 
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index a67cb2a..28a55ae 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -37,6 +37,11 @@
  * clocks through this child mux.
  */
 #define CLK_IS_BASIC_MUX	BIT(9)
+/*
+ * parent clock must be on across any operation including
+ * clock gate/ungate, rate change and re-parent
+ */
+#define CLK_SET_PARENT_ON	BIT(10)
 
 struct clk_hw;
 struct clk_core;
-- 
1.7.5.4

