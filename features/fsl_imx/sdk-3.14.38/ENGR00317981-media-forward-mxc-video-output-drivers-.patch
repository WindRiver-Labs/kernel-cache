From ca9053a6f96c2878adf60f4e7db62127aaba6d8c Mon Sep 17 00:00:00 2001
From: Shawn Guo <shawn.guo@freescale.com>
Date: Fri, 13 Jun 2014 17:16:59 +0800
Subject: [PATCH 0019/1594] ENGR00317981: media: forward mxc video output
 drivers to 3.14 kernel

commit 18f1c3c3143e4688f83ef6927ff491fb314fb415 from
git://git.freescale.com/imx/linux-2.6-imx.git

Forward imx_3.10.y mxc video output drivers to 3.14 kernel.

Signed-off-by: Shawn Guo <shawn.guo@freescale.com>
---
 drivers/media/platform/Kconfig                   |    8 +
 drivers/media/platform/Makefile                  |    2 +
 drivers/media/platform/mxc/output/Kconfig        |   16 +
 drivers/media/platform/mxc/output/Makefile       |    2 +
 drivers/media/platform/mxc/output/mxc_pxp_v4l2.c | 1305 +++++++++++++
 drivers/media/platform/mxc/output/mxc_pxp_v4l2.h |   87 +
 drivers/media/platform/mxc/output/mxc_vout.c     | 2277 ++++++++++++++++++++++
 include/linux/mxc_v4l2.h                         |   27 +
 include/uapi/linux/Kbuild                        |    1 +
 include/uapi/linux/mxc_v4l2.h                    |   56 +
 10 files changed, 3781 insertions(+), 0 deletions(-)
 create mode 100644 drivers/media/platform/mxc/output/Kconfig
 create mode 100644 drivers/media/platform/mxc/output/Makefile
 create mode 100644 drivers/media/platform/mxc/output/mxc_pxp_v4l2.c
 create mode 100644 drivers/media/platform/mxc/output/mxc_pxp_v4l2.h
 create mode 100644 drivers/media/platform/mxc/output/mxc_vout.c
 create mode 100644 include/linux/mxc_v4l2.h
 create mode 100644 include/uapi/linux/mxc_v4l2.h

diff --git a/drivers/media/platform/Kconfig b/drivers/media/platform/Kconfig
index 421f531..cf6dae9 100644
--- a/drivers/media/platform/Kconfig
+++ b/drivers/media/platform/Kconfig
@@ -114,6 +114,14 @@ config VIDEO_S3C_CAMIF
 	  To compile this driver as a module, choose M here: the module
 	  will be called s3c-camif.
 
+config VIDEO_MXC_OUTPUT
+        tristate "MXC Video For Linux Video Output"
+        depends on VIDEO_DEV && ARCH_MXC && FB_MXC
+        select VIDEOBUF_DMA_CONTIG
+        ---help---
+        This is the video4linux2 output driver based on MXC module.
+
+source "drivers/media/platform/mxc/output/Kconfig"
 source "drivers/media/platform/soc_camera/Kconfig"
 source "drivers/media/platform/exynos4-is/Kconfig"
 source "drivers/media/platform/s5p-tv/Kconfig"
diff --git a/drivers/media/platform/Makefile b/drivers/media/platform/Makefile
index 8f85561..3813acc 100644
--- a/drivers/media/platform/Makefile
+++ b/drivers/media/platform/Makefile
@@ -50,4 +50,6 @@ obj-$(CONFIG_VIDEO_AM437X_VPFE)		+= am437x/
 
 obj-$(CONFIG_VIDEO_XILINX)		+= xilinx/
 
+obj-$(CONFIG_VIDEO_MXC_OUTPUT)	+= mxc/output/
+
 ccflags-y += -I$(srctree)/drivers/media/i2c
diff --git a/drivers/media/platform/mxc/output/Kconfig b/drivers/media/platform/mxc/output/Kconfig
new file mode 100644
index 0000000..237f8a8
--- /dev/null
+++ b/drivers/media/platform/mxc/output/Kconfig
@@ -0,0 +1,16 @@
+config VIDEO_MXC_IPU_OUTPUT
+	tristate "IPU v4l2 output support"
+	depends on VIDEO_MXC_OUTPUT && MXC_IPU
+	---help---
+	This is the video4linux2 driver for IPU post processing video output.
+
+config VIDEO_MXC_PXP_V4L2
+        tristate "MXC PxP V4L2 driver"
+        depends on VIDEO_DEV && VIDEO_V4L2
+        select VIDEOBUF_DMA_CONTIG
+        ---help---
+          This is a video4linux driver for the Freescale PxP
+          (Pixel Pipeline). This module supports output overlay of
+          the MXC framebuffer on a video stream.
+
+          To compile this driver as a module, choose M here.
diff --git a/drivers/media/platform/mxc/output/Makefile b/drivers/media/platform/mxc/output/Makefile
new file mode 100644
index 0000000..88f1a9f
--- /dev/null
+++ b/drivers/media/platform/mxc/output/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_VIDEO_MXC_IPU_OUTPUT) += mxc_vout.o
+obj-$(CONFIG_VIDEO_MXC_PXP_V4L2)   += mxc_pxp_v4l2.o
diff --git a/drivers/media/platform/mxc/output/mxc_pxp_v4l2.c b/drivers/media/platform/mxc/output/mxc_pxp_v4l2.c
new file mode 100644
index 0000000..cf5ea96
--- /dev/null
+++ b/drivers/media/platform/mxc/output/mxc_pxp_v4l2.c
@@ -0,0 +1,1305 @@
+/*
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+/*
+ * Based on STMP378X PxP driver
+ * Copyright 2008-2009 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/vmalloc.h>
+#include <linux/videodev2.h>
+#include <linux/dmaengine.h>
+#include <linux/pxp_dma.h>
+#include <linux/delay.h>
+#include <linux/console.h>
+#include <linux/mxcfb.h>
+
+#include <media/videobuf-dma-contig.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-ioctl.h>
+
+#include "mxc_pxp_v4l2.h"
+
+#define PXP_DRIVER_NAME			"pxp-v4l2"
+#define PXP_DRIVER_MAJOR		2
+#define PXP_DRIVER_MINOR		0
+
+#define PXP_DEF_BUFS			2
+#define PXP_MIN_PIX			8
+
+#define V4L2_OUTPUT_TYPE_INTERNAL	4
+
+static int video_nr = -1;	/* -1 ==> auto assign */
+static struct pxp_data_format pxp_s0_formats[] = {
+	{
+		.name = "24-bit RGB",
+		.bpp = 4,
+		.fourcc = V4L2_PIX_FMT_RGB24,
+		.colorspace = V4L2_COLORSPACE_SRGB,
+	}, {
+		.name = "16-bit RGB 5:6:5",
+		.bpp = 2,
+		.fourcc = V4L2_PIX_FMT_RGB565,
+		.colorspace = V4L2_COLORSPACE_SRGB,
+	}, {
+		.name = "16-bit RGB 5:5:5",
+		.bpp = 2,
+		.fourcc = V4L2_PIX_FMT_RGB555,
+		.colorspace = V4L2_COLORSPACE_SRGB,
+	}, {
+		.name = "YUV 4:2:0 Planar",
+		.bpp = 2,
+		.fourcc = V4L2_PIX_FMT_YUV420,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+	}, {
+		.name = "YUV 4:2:2 Planar",
+		.bpp = 2,
+		.fourcc = V4L2_PIX_FMT_YUV422P,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+	}, {
+		.name = "UYVY",
+		.bpp = 2,
+		.fourcc = V4L2_PIX_FMT_UYVY,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+	},
+};
+
+static unsigned int v4l2_fmt_to_pxp_fmt(u32 v4l2_pix_fmt)
+{
+	u32 pxp_fmt = 0;
+
+	if (v4l2_pix_fmt == V4L2_PIX_FMT_RGB24)
+		pxp_fmt = PXP_PIX_FMT_RGB24;
+	else if (v4l2_pix_fmt == V4L2_PIX_FMT_RGB565)
+		pxp_fmt = PXP_PIX_FMT_RGB565;
+	else if (v4l2_pix_fmt == V4L2_PIX_FMT_RGB555)
+		pxp_fmt = PXP_PIX_FMT_RGB555;
+	else if (v4l2_pix_fmt == V4L2_PIX_FMT_RGB555)
+		pxp_fmt = PXP_PIX_FMT_RGB555;
+	else if (v4l2_pix_fmt == V4L2_PIX_FMT_YUV420)
+		pxp_fmt = PXP_PIX_FMT_YUV420P;
+	else if (v4l2_pix_fmt == V4L2_PIX_FMT_YUV422P)
+		pxp_fmt = PXP_PIX_FMT_YUV422P;
+	else if (v4l2_pix_fmt == V4L2_PIX_FMT_UYVY)
+		pxp_fmt = PXP_PIX_FMT_UYVY;
+
+	return pxp_fmt;
+}
+struct v4l2_queryctrl pxp_controls[] = {
+	{
+		.id 		= V4L2_CID_HFLIP,
+		.type 		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name 		= "Horizontal Flip",
+		.minimum 	= 0,
+		.maximum 	= 1,
+		.step 		= 1,
+		.default_value	= 0,
+		.flags		= 0,
+	}, {
+		.id		= V4L2_CID_VFLIP,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name		= "Vertical Flip",
+		.minimum	= 0,
+		.maximum	= 1,
+		.step		= 1,
+		.default_value	= 0,
+		.flags		= 0,
+	}, {
+		.id		= V4L2_CID_PRIVATE_BASE,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Rotation",
+		.minimum	= 0,
+		.maximum	= 270,
+		.step		= 90,
+		.default_value	= 0,
+		.flags		= 0,
+	}, {
+		.id		= V4L2_CID_PRIVATE_BASE + 1,
+		.name		= "Background Color",
+		.minimum	= 0,
+		.maximum	= 0xFFFFFF,
+		.step		= 1,
+		.default_value	= 0,
+		.flags		= 0,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+	}, {
+		.id		= V4L2_CID_PRIVATE_BASE + 2,
+		.name		= "Set S0 Chromakey",
+		.minimum	= -1,
+		.maximum	= 0xFFFFFF,
+		.step		= 1,
+		.default_value	= -1,
+		.flags		= 0,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+	}, {
+		.id		= V4L2_CID_PRIVATE_BASE + 3,
+		.name		= "YUV Colorspace",
+		.minimum	= 0,
+		.maximum	= 1,
+		.step		= 1,
+		.default_value	= 0,
+		.flags		= 0,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+	},
+};
+
+static void free_dma_buf(struct pxps *pxp, struct dma_mem *buf)
+{
+	dma_free_coherent(&pxp->pdev->dev, buf->size, buf->vaddr, buf->paddr);
+	dev_dbg(&pxp->pdev->dev,
+			"free dma size:0x%x, paddr:0x%x\n",
+			buf->size, buf->paddr);
+	memset(buf, 0, sizeof(*buf));
+}
+
+static int alloc_dma_buf(struct pxps *pxp, struct dma_mem *buf)
+{
+
+	buf->vaddr = dma_alloc_coherent(&pxp->pdev->dev, buf->size, &buf->paddr,
+						GFP_DMA | GFP_KERNEL);
+	if (!buf->vaddr) {
+		dev_err(&pxp->pdev->dev,
+			"cannot get dma buf size:0x%x\n", buf->size);
+		return -ENOMEM;
+	}
+	dev_dbg(&pxp->pdev->dev,
+		"alloc dma buf size:0x%x, paddr:0x%x\n", buf->size, buf->paddr);
+	return 0;
+}
+
+/* callback function */
+static void video_dma_done(void *arg)
+{
+	struct pxp_tx_desc *tx_desc = to_tx_desc(arg);
+	struct dma_chan *chan = tx_desc->txd.chan;
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxps *pxp = pxp_chan->client;
+	struct videobuf_buffer *vb;
+
+	dev_dbg(chan->device->dev, "callback cookie %d, active DMA 0x%08x\n",
+			tx_desc->txd.cookie,
+			pxp->active ? sg_dma_address(&pxp->active->sg[0]) : 0);
+
+	spin_lock(&pxp->lock);
+	if (pxp->active) {
+		vb = &pxp->active->vb;
+
+		list_del_init(&vb->queue);
+		vb->state = VIDEOBUF_DONE;
+		do_gettimeofday(&vb->ts);
+		vb->field_count++;
+		wake_up(&vb->done);
+	}
+
+	if (list_empty(&pxp->outq)) {
+		pxp->active = NULL;
+		spin_unlock(&pxp->lock);
+
+		return;
+	}
+
+	pxp->active = list_entry(pxp->outq.next,
+				     struct pxp_buffer, vb.queue);
+	pxp->active->vb.state = VIDEOBUF_ACTIVE;
+	spin_unlock(&pxp->lock);
+}
+
+static int acquire_dma_channel(struct pxps *pxp)
+{
+	dma_cap_mask_t mask;
+	struct dma_chan *chan;
+	struct pxp_channel **pchan = &pxp->pxp_channel[0];
+
+	if (*pchan) {
+		struct videobuf_buffer *vb, *_vb;
+		dma_release_channel(&(*pchan)->dma_chan);
+		*pchan = NULL;
+		pxp->active = NULL;
+		list_for_each_entry_safe(vb, _vb, &pxp->outq, queue) {
+			list_del_init(&vb->queue);
+			vb->state = VIDEOBUF_ERROR;
+			wake_up(&vb->done);
+		}
+	}
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+	dma_cap_set(DMA_PRIVATE, mask);
+	chan = dma_request_channel(mask, NULL, NULL);
+	if (!chan)
+		return -EBUSY;
+
+	*pchan = to_pxp_channel(chan);
+	(*pchan)->client = pxp;
+
+	return 0;
+}
+
+static int _get_fbinfo(struct fb_info **fbi)
+{
+	int i;
+	for (i = 0; i < num_registered_fb; i++) {
+		char *idstr = registered_fb[i]->fix.id;
+		if (strncmp(idstr, "mxs", 3) == 0) {
+			*fbi = registered_fb[i];
+			return 0;
+		}
+	}
+
+	return -ENODEV;
+}
+
+static int pxp_set_fbinfo(struct pxps *pxp)
+{
+	struct v4l2_framebuffer *fb = &pxp->fb;
+	int err;
+
+	err = _get_fbinfo(&pxp->fbi);
+	if (err)
+		return err;
+
+	fb->fmt.width = pxp->fbi->var.xres;
+	fb->fmt.height = pxp->fbi->var.yres;
+	pxp->pxp_conf.out_param.stride = pxp->fbi->var.xres;
+	if (pxp->fbi->var.bits_per_pixel == 16)
+		fb->fmt.pixelformat = V4L2_PIX_FMT_RGB565;
+	else
+		fb->fmt.pixelformat = V4L2_PIX_FMT_RGB24;
+
+	fb->base = (void *)pxp->fbi->fix.smem_start;
+
+	return 0;
+}
+
+static int _get_cur_fb_blank(struct pxps *pxp)
+{
+	struct fb_info *fbi;
+	mm_segment_t old_fs;
+	int err = 0;
+
+	err = _get_fbinfo(&fbi);
+	if (err)
+		return err;
+
+	if (fbi->fbops->fb_ioctl) {
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);
+		err = fbi->fbops->fb_ioctl(fbi, MXCFB_GET_FB_BLANK,
+				(unsigned int)(&pxp->fb_blank));
+		set_fs(old_fs);
+	}
+
+	return err;
+}
+
+static int pxp_show_buf(struct pxps *pxp, unsigned long paddr)
+{
+	struct fb_info *fbi = pxp->fbi;
+	int ret = -EINVAL;
+
+	if (paddr == 0) {
+		dev_err(&pxp->pdev->dev, "Invalid paddr\n");
+		return ret;
+	}
+
+	console_lock();
+	fbi->fix.smem_start = paddr;
+	ret = fb_pan_display(fbi, &fbi->var);
+	console_unlock();
+
+	return ret;
+}
+
+static int set_fb_blank(int blank)
+{
+	struct fb_info *fbi;
+	int err = 0;
+
+	err = _get_fbinfo(&fbi);
+	if (err)
+		return err;
+
+	console_lock();
+	fb_blank(fbi, blank);
+	console_unlock();
+
+	return err;
+}
+
+static int pxp_set_cstate(struct pxps *pxp, struct v4l2_control *vc)
+{
+
+	if (vc->id == V4L2_CID_HFLIP) {
+		pxp->pxp_conf.proc_data.hflip = vc->value;
+	} else if (vc->id == V4L2_CID_VFLIP) {
+		pxp->pxp_conf.proc_data.vflip = vc->value;
+	} else if (vc->id == V4L2_CID_PRIVATE_BASE) {
+		if (vc->value % 90)
+			return -ERANGE;
+		pxp->pxp_conf.proc_data.rotate = vc->value;
+	} else if (vc->id == V4L2_CID_PRIVATE_BASE + 1) {
+		pxp->pxp_conf.proc_data.bgcolor = vc->value;
+	} else if (vc->id == V4L2_CID_PRIVATE_BASE + 2) {
+		pxp->pxp_conf.s0_param.color_key = vc->value;
+	} else if (vc->id == V4L2_CID_PRIVATE_BASE + 3) {
+		pxp->pxp_conf.proc_data.yuv = vc->value;
+	}
+
+	return 0;
+}
+
+static int pxp_get_cstate(struct pxps *pxp, struct v4l2_control *vc)
+{
+	if (vc->id == V4L2_CID_HFLIP)
+		vc->value = pxp->pxp_conf.proc_data.hflip;
+	else if (vc->id == V4L2_CID_VFLIP)
+		vc->value = pxp->pxp_conf.proc_data.vflip;
+	else if (vc->id == V4L2_CID_PRIVATE_BASE)
+		vc->value = pxp->pxp_conf.proc_data.rotate;
+	else if (vc->id == V4L2_CID_PRIVATE_BASE + 1)
+		vc->value = pxp->pxp_conf.proc_data.bgcolor;
+	else if (vc->id == V4L2_CID_PRIVATE_BASE + 2)
+		vc->value = pxp->pxp_conf.s0_param.color_key;
+	else if (vc->id == V4L2_CID_PRIVATE_BASE + 3)
+		vc->value = pxp->pxp_conf.proc_data.yuv;
+
+	return 0;
+}
+
+static int pxp_enumoutput(struct file *file, void *fh,
+			struct v4l2_output *o)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+
+	if ((o->index < 0) || (o->index > 1))
+		return -EINVAL;
+
+	memset(o, 0, sizeof(struct v4l2_output));
+	if (o->index == 0) {
+		strcpy(o->name, "PxP Display Output");
+		pxp->output = 0;
+	} else {
+		strcpy(o->name, "PxP Virtual Output");
+		pxp->output = 1;
+	}
+	o->type = V4L2_OUTPUT_TYPE_INTERNAL;
+	o->std = 0;
+	o->reserved[0] = pxp->outbuf.paddr;
+
+	return 0;
+}
+
+static int pxp_g_output(struct file *file, void *fh,
+			unsigned int *i)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+
+	*i = pxp->output;
+
+	return 0;
+}
+
+static int pxp_s_output(struct file *file, void *fh,
+			unsigned int i)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+	u32 size;
+	int ret, bpp;
+
+	if ((i < 0) || (i > 1))
+		return -EINVAL;
+
+	/* Output buffer is same format as fbdev */
+	if (pxp->fb.fmt.pixelformat == V4L2_PIX_FMT_RGB32  ||
+		pxp->fb.fmt.pixelformat == V4L2_PIX_FMT_YUV32)
+		bpp = 4;
+	else if (pxp->fb.fmt.pixelformat == V4L2_PIX_FMT_RGB24)
+		bpp = 3;
+	else
+		bpp = 2;
+
+	size = pxp->fb.fmt.width * pxp->fb.fmt.height * bpp;
+	if (size > pxp->outbuf.size) {
+		if (pxp->outbuf.vaddr)
+			free_dma_buf(pxp, &pxp->outbuf);
+		pxp->outbuf.size = size;
+		ret = alloc_dma_buf(pxp, &pxp->outbuf);
+		if (ret < 0)
+			return ret;
+	}
+	memset(pxp->outbuf.vaddr, 0x0, pxp->outbuf.size);
+
+	pxp->pxp_conf.out_param.width = pxp->fb.fmt.width;
+	pxp->pxp_conf.out_param.height = pxp->fb.fmt.height;
+	if (pxp->fb.fmt.pixelformat == V4L2_PIX_FMT_RGB32)
+		pxp->pxp_conf.out_param.pixel_fmt = PXP_PIX_FMT_RGB32;
+	else if (pxp->fb.fmt.pixelformat == V4L2_PIX_FMT_RGB24)
+		pxp->pxp_conf.out_param.pixel_fmt = PXP_PIX_FMT_RGB24;
+	else
+		pxp->pxp_conf.out_param.pixel_fmt = PXP_PIX_FMT_RGB565;
+
+	return 0;
+}
+
+static int pxp_enum_fmt_video_output(struct file *file, void *fh,
+				struct v4l2_fmtdesc *fmt)
+{
+	enum v4l2_buf_type type = fmt->type;
+	int index = fmt->index;
+
+	if ((fmt->index < 0) || (fmt->index >= ARRAY_SIZE(pxp_s0_formats)))
+		return -EINVAL;
+
+	memset(fmt, 0, sizeof(struct v4l2_fmtdesc));
+	fmt->index = index;
+	fmt->type = type;
+	fmt->pixelformat = pxp_s0_formats[index].fourcc;
+	strcpy(fmt->description, pxp_s0_formats[index].name);
+
+	return 0;
+}
+
+static int pxp_g_fmt_video_output(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct v4l2_pix_format *pf = &f->fmt.pix;
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+	struct pxp_data_format *fmt = pxp->s0_fmt;
+
+	pf->width = pxp->pxp_conf.s0_param.width;
+	pf->height = pxp->pxp_conf.s0_param.height;
+	pf->pixelformat = fmt->fourcc;
+	pf->field = V4L2_FIELD_NONE;
+	pf->bytesperline = fmt->bpp * pf->width;
+	pf->sizeimage = pf->bytesperline * pf->height;
+	pf->colorspace = fmt->colorspace;
+	pf->priv = 0;
+
+	return 0;
+}
+
+static struct pxp_data_format *pxp_get_format(struct v4l2_format *f)
+{
+	struct pxp_data_format *fmt;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pxp_s0_formats); i++) {
+		fmt = &pxp_s0_formats[i];
+		if (fmt->fourcc == f->fmt.pix.pixelformat)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(pxp_s0_formats))
+		return NULL;
+
+	return &pxp_s0_formats[i];
+}
+
+static int pxp_try_fmt_video_output(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	int w = f->fmt.pix.width;
+	int h = f->fmt.pix.height;
+	struct pxp_data_format *fmt = pxp_get_format(f);
+
+	if (!fmt)
+		return -EINVAL;
+
+	w = min(w, 2040);
+	w = max(w, 8);
+	h = min(h, 2040);
+	h = max(h, 8);
+	f->fmt.pix.field = V4L2_FIELD_NONE;
+	f->fmt.pix.width = w;
+	f->fmt.pix.height = h;
+	f->fmt.pix.pixelformat = fmt->fourcc;
+
+	return 0;
+}
+
+static int pxp_s_fmt_video_output(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+	struct v4l2_pix_format *pf = &f->fmt.pix;
+	int ret;
+
+	ret = acquire_dma_channel(pxp);
+	if (ret < 0)
+		return ret;
+
+	ret = pxp_try_fmt_video_output(file, fh, f);
+	if (ret == 0) {
+		pxp->s0_fmt = pxp_get_format(f);
+		pxp->pxp_conf.s0_param.pixel_fmt =
+			v4l2_fmt_to_pxp_fmt(pxp->s0_fmt->fourcc);
+		pxp->pxp_conf.s0_param.width = pf->width;
+		pxp->pxp_conf.s0_param.height = pf->height;
+	}
+
+
+	return ret;
+}
+
+static int pxp_g_fmt_output_overlay(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+	struct v4l2_window *wf = &f->fmt.win;
+
+	memset(wf, 0, sizeof(struct v4l2_window));
+	wf->chromakey = pxp->s1_chromakey;
+	wf->global_alpha = pxp->global_alpha;
+	wf->field = V4L2_FIELD_NONE;
+	wf->clips = NULL;
+	wf->clipcount = 0;
+	wf->bitmap = NULL;
+	wf->w.left = pxp->pxp_conf.proc_data.srect.left;
+	wf->w.top = pxp->pxp_conf.proc_data.srect.top;
+	wf->w.width = pxp->pxp_conf.proc_data.srect.width;
+	wf->w.height = pxp->pxp_conf.proc_data.srect.height;
+
+	return 0;
+}
+
+static int pxp_try_fmt_output_overlay(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+	struct v4l2_window *wf = &f->fmt.win;
+	struct v4l2_rect srect;
+	u32 s1_chromakey = wf->chromakey;
+	u8 global_alpha = wf->global_alpha;
+
+	memcpy(&srect, &(wf->w), sizeof(struct v4l2_rect));
+
+	pxp_g_fmt_output_overlay(file, fh, f);
+
+	wf->chromakey = s1_chromakey;
+	wf->global_alpha = global_alpha;
+
+	/* Constrain parameters to the input buffer */
+	wf->w.left = srect.left;
+	wf->w.top = srect.top;
+	wf->w.width = min(srect.width,
+			((__s32)pxp->pxp_conf.s0_param.width - wf->w.left));
+	wf->w.height = min(srect.height,
+			((__s32)pxp->pxp_conf.s0_param.height - wf->w.top));
+
+	return 0;
+}
+
+static int pxp_s_fmt_output_overlay(struct file *file, void *fh,
+					struct v4l2_format *f)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+	struct v4l2_window *wf = &f->fmt.win;
+	int ret = pxp_try_fmt_output_overlay(file, fh, f);
+
+	if (ret == 0) {
+		pxp->global_alpha = wf->global_alpha;
+		pxp->s1_chromakey = wf->chromakey;
+		pxp->pxp_conf.proc_data.srect.left = wf->w.left;
+		pxp->pxp_conf.proc_data.srect.top = wf->w.top;
+		pxp->pxp_conf.proc_data.srect.width = wf->w.width;
+		pxp->pxp_conf.proc_data.srect.height = wf->w.height;
+		pxp->pxp_conf.ol_param[0].global_alpha = pxp->global_alpha;
+		pxp->pxp_conf.ol_param[0].color_key = pxp->s1_chromakey;
+		pxp->pxp_conf.ol_param[0].color_key_enable =
+					pxp->s1_chromakey_state;
+	}
+
+	return ret;
+}
+
+static int pxp_reqbufs(struct file *file, void *priv,
+			struct v4l2_requestbuffers *r)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+
+	return videobuf_reqbufs(&pxp->s0_vbq, r);
+}
+
+static int pxp_querybuf(struct file *file, void *priv,
+			struct v4l2_buffer *b)
+{
+	int ret;
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+
+	ret = videobuf_querybuf(&pxp->s0_vbq, b);
+	if (!ret) {
+		struct videobuf_buffer *vb = pxp->s0_vbq.bufs[b->index];
+		if (b->flags & V4L2_BUF_FLAG_MAPPED)
+			b->m.offset = videobuf_to_dma_contig(vb);
+	}
+
+	return ret;
+}
+
+static int pxp_qbuf(struct file *file, void *priv,
+			struct v4l2_buffer *b)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+
+	return videobuf_qbuf(&pxp->s0_vbq, b);
+}
+
+static int pxp_dqbuf(struct file *file, void *priv,
+			struct v4l2_buffer *b)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+
+	return videobuf_dqbuf(&pxp->s0_vbq, b, file->f_flags & O_NONBLOCK);
+}
+
+static int pxp_streamon(struct file *file, void *priv,
+			enum v4l2_buf_type t)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+	int ret = 0;
+
+	if (t != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return -EINVAL;
+
+	_get_cur_fb_blank(pxp);
+	set_fb_blank(FB_BLANK_UNBLANK);
+
+	ret = videobuf_streamon(&pxp->s0_vbq);
+
+	if (!ret && (pxp->output == 0))
+		pxp_show_buf(pxp, pxp->outbuf.paddr);
+
+	return ret;
+}
+
+static int pxp_streamoff(struct file *file, void *priv,
+			enum v4l2_buf_type t)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+	int ret = 0;
+
+	if ((t != V4L2_BUF_TYPE_VIDEO_OUTPUT))
+		return -EINVAL;
+
+	ret = videobuf_streamoff(&pxp->s0_vbq);
+
+	pxp_show_buf(pxp, (unsigned long)pxp->fb.base);
+
+	if (pxp->fb_blank)
+		set_fb_blank(FB_BLANK_POWERDOWN);
+
+	return ret;
+}
+
+static int pxp_buf_setup(struct videobuf_queue *q,
+			unsigned int *count, unsigned *size)
+{
+	struct pxps *pxp = q->priv_data;
+
+	*size = pxp->pxp_conf.s0_param.width *
+		pxp->pxp_conf.s0_param.height * pxp->s0_fmt->bpp;
+
+	if (0 == *count)
+		*count = PXP_DEF_BUFS;
+
+	return 0;
+}
+
+static void pxp_buf_free(struct videobuf_queue *q, struct pxp_buffer *buf)
+{
+	struct videobuf_buffer *vb = &buf->vb;
+
+	BUG_ON(in_interrupt());
+
+	pr_debug("%s (vb=0x%p) 0x%08lx %d\n", __func__,
+		vb, vb->baddr, vb->bsize);
+
+	/*
+	 * This waits until this buffer is out of danger, i.e., until it is no
+	 * longer in STATE_QUEUED or STATE_ACTIVE
+	 */
+	videobuf_waiton(q, vb, 0, 0);
+
+	videobuf_dma_contig_free(q, vb);
+	buf->txd = NULL;
+
+	vb->state = VIDEOBUF_NEEDS_INIT;
+}
+
+static int pxp_buf_prepare(struct videobuf_queue *q,
+			struct videobuf_buffer *vb,
+			enum v4l2_field field)
+{
+	struct pxps *pxp = q->priv_data;
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf;
+	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
+	struct pxp_buffer *buf = container_of(vb, struct pxp_buffer, vb);
+	struct pxp_tx_desc *desc;
+	int ret = 0;
+	int i, length;
+
+	if (!pxp->outbuf.paddr)  {
+		dev_err(&pxp->pdev->dev, "Not allocate memory for "
+			"PxP Out buffer?\n");
+		return -ENOMEM;
+	}
+
+	vb->width = pxp->pxp_conf.s0_param.width;
+	vb->height = pxp->pxp_conf.s0_param.height;
+	vb->size = vb->width * vb->height * pxp->s0_fmt->bpp;
+	vb->field = V4L2_FIELD_NONE;
+	if (vb->state != VIDEOBUF_NEEDS_INIT)
+		pxp_buf_free(q, buf);
+
+	if (vb->state == VIDEOBUF_NEEDS_INIT) {
+		struct pxp_channel *pchan = pxp->pxp_channel[0];
+		struct scatterlist *sg = &buf->sg[0];
+
+		/* This actually (allocates and) maps buffers */
+		ret = videobuf_iolock(q, vb, NULL);
+		if (ret) {
+			pr_err("fail to call videobuf_iolock, ret = %d\n", ret);
+			goto fail;
+		}
+
+		/*
+		 * sg[0] for input(S0)
+		 * Sg[1] for output
+		 */
+		sg_init_table(sg, 3);
+
+		buf->txd = pchan->dma_chan.device->device_prep_slave_sg(
+			&pchan->dma_chan, sg, 3, DMA_FROM_DEVICE,
+			DMA_PREP_INTERRUPT, NULL);
+		if (!buf->txd) {
+			ret = -EIO;
+			goto fail;
+		}
+
+		buf->txd->callback_param	= buf->txd;
+		buf->txd->callback		= video_dma_done;
+
+		desc = to_tx_desc(buf->txd);
+		length = desc->len;
+		for (i = 0; i < length; i++) {
+			if (i == 0) {/* S0 */
+				memcpy(&desc->proc_data, proc_data,
+					sizeof(struct pxp_proc_data));
+				pxp_conf->s0_param.paddr =
+						videobuf_to_dma_contig(vb);
+				memcpy(&desc->layer_param.s0_param,
+					&pxp_conf->s0_param,
+					sizeof(struct pxp_layer_param));
+			} else if (i == 1) { /* Output */
+				/* we should always pass the output
+				 * width and height which is the value
+				 * after been rotated.
+				 */
+				pxp_conf->out_param.width =
+					pxp->fb.fmt.width;
+				pxp_conf->out_param.height =
+					pxp->fb.fmt.height;
+
+				pxp_conf->out_param.paddr = pxp->outbuf.paddr;
+				memcpy(&desc->layer_param.out_param,
+					&pxp_conf->out_param,
+					sizeof(struct pxp_layer_param));
+			} else if (pxp_conf->ol_param[0].combine_enable) {
+				/* Overlay */
+				pxp_conf->ol_param[0].paddr =
+						(dma_addr_t)pxp->fb.base;
+				pxp_conf->ol_param[0].width = pxp->fb.fmt.width;
+				pxp_conf->ol_param[0].height =
+						pxp->fb.fmt.height;
+				pxp_conf->ol_param[0].pixel_fmt =
+						pxp_conf->out_param.pixel_fmt;
+				memcpy(&desc->layer_param.ol_param,
+				       &pxp_conf->ol_param[0],
+				       sizeof(struct pxp_layer_param));
+			}
+
+			desc = desc->next;
+		}
+
+		vb->state = VIDEOBUF_PREPARED;
+	}
+
+	return 0;
+
+fail:
+	pxp_buf_free(q, buf);
+	return ret;
+}
+
+
+static void pxp_buf_queue(struct videobuf_queue *q,
+			struct videobuf_buffer *vb)
+{
+	struct pxps *pxp = q->priv_data;
+	struct pxp_buffer *buf = container_of(vb, struct pxp_buffer, vb);
+	struct dma_async_tx_descriptor *txd = buf->txd;
+	struct pxp_channel *pchan = pxp->pxp_channel[0];
+	dma_cookie_t cookie;
+
+	BUG_ON(!irqs_disabled());
+
+	list_add_tail(&vb->queue, &pxp->outq);
+
+	if (!pxp->active) {
+		pxp->active = buf;
+		vb->state = VIDEOBUF_ACTIVE;
+	} else {
+		vb->state = VIDEOBUF_QUEUED;
+	}
+
+	spin_unlock_irq(&pxp->lock);
+
+	cookie = txd->tx_submit(txd);
+	dev_dbg(&pxp->pdev->dev, "Submitted cookie %d DMA 0x%08x\n",
+				cookie, sg_dma_address(&buf->sg[0]));
+	mdelay(5);
+	/* trigger ePxP */
+	dma_async_issue_pending(&pchan->dma_chan);
+
+	spin_lock_irq(&pxp->lock);
+
+	if (cookie >= 0)
+		return;
+
+	/* Submit error */
+	pr_err("%s: Submit error\n", __func__);
+	vb->state = VIDEOBUF_PREPARED;
+
+	list_del_init(&vb->queue);
+
+	if (pxp->active == buf)
+		pxp->active = NULL;
+}
+
+static void pxp_buf_release(struct videobuf_queue *q,
+			struct videobuf_buffer *vb)
+{
+	struct pxps *pxp = q->priv_data;
+	struct pxp_buffer *buf = container_of(vb, struct pxp_buffer, vb);
+	unsigned long flags;
+
+	spin_lock_irqsave(&pxp->lock, flags);
+	if ((vb->state == VIDEOBUF_ACTIVE || vb->state == VIDEOBUF_QUEUED) &&
+	    !list_empty(&vb->queue)) {
+		vb->state = VIDEOBUF_ERROR;
+
+		list_del_init(&vb->queue);
+		if (pxp->active == buf)
+			pxp->active = NULL;
+	}
+	spin_unlock_irqrestore(&pxp->lock, flags);
+
+	pxp_buf_free(q, buf);
+}
+
+static struct videobuf_queue_ops pxp_vbq_ops = {
+	.buf_setup	= pxp_buf_setup,
+	.buf_prepare	= pxp_buf_prepare,
+	.buf_queue	= pxp_buf_queue,
+	.buf_release	= pxp_buf_release,
+};
+
+static int pxp_querycap(struct file *file, void *fh,
+			struct v4l2_capability *cap)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+
+	memset(cap, 0, sizeof(*cap));
+	strcpy(cap->driver, "pxp");
+	strcpy(cap->card, "pxp");
+	strlcpy(cap->bus_info, dev_name(&pxp->pdev->dev),
+		sizeof(cap->bus_info));
+
+	cap->version = (PXP_DRIVER_MAJOR << 8) + PXP_DRIVER_MINOR;
+
+	cap->capabilities = V4L2_CAP_VIDEO_OUTPUT |
+				V4L2_CAP_VIDEO_OUTPUT_OVERLAY |
+				V4L2_CAP_STREAMING;
+
+	return 0;
+}
+
+static int pxp_g_fbuf(struct file *file, void *priv,
+			struct v4l2_framebuffer *fb)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+
+	memset(fb, 0, sizeof(*fb));
+
+	fb->capability = V4L2_FBUF_CAP_EXTERNOVERLAY |
+			 V4L2_FBUF_CAP_CHROMAKEY |
+			 V4L2_FBUF_CAP_LOCAL_ALPHA |
+			 V4L2_FBUF_CAP_GLOBAL_ALPHA;
+
+	if (pxp->global_alpha_state)
+		fb->flags |= V4L2_FBUF_FLAG_GLOBAL_ALPHA;
+	if (pxp->s1_chromakey_state)
+		fb->flags |= V4L2_FBUF_FLAG_CHROMAKEY;
+
+	return 0;
+}
+
+static int pxp_s_fbuf(struct file *file, void *priv,
+			const struct v4l2_framebuffer *fb)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+
+	pxp->overlay_state =
+		(fb->flags & V4L2_FBUF_FLAG_OVERLAY) != 0;
+	pxp->global_alpha_state =
+		(fb->flags & V4L2_FBUF_FLAG_GLOBAL_ALPHA) != 0;
+	pxp->s1_chromakey_state =
+		(fb->flags & V4L2_FBUF_FLAG_CHROMAKEY) != 0;
+
+	pxp->pxp_conf.ol_param[0].combine_enable = pxp->overlay_state;
+	pxp->pxp_conf.ol_param[0].global_alpha_enable = pxp->global_alpha_state;
+
+	return 0;
+}
+
+static int pxp_g_crop(struct file *file, void *fh,
+			struct v4l2_crop *c)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+
+	if (c->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY)
+		return -EINVAL;
+
+	c->c.left = pxp->pxp_conf.proc_data.drect.left;
+	c->c.top = pxp->pxp_conf.proc_data.drect.top;
+	c->c.width = pxp->pxp_conf.proc_data.drect.width;
+	c->c.height = pxp->pxp_conf.proc_data.drect.height;
+
+	return 0;
+}
+
+static int pxp_s_crop(struct file *file, void *fh,
+			const struct v4l2_crop *c)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+	int l = c->c.left;
+	int t = c->c.top;
+	int w = c->c.width;
+	int h = c->c.height;
+	int fbw = pxp->fb.fmt.width;
+	int fbh = pxp->fb.fmt.height;
+
+	if (c->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY)
+		return -EINVAL;
+
+	/* Constrain parameters to FB limits */
+	w = min(w, fbw);
+	w = max(w, PXP_MIN_PIX);
+	h = min(h, fbh);
+	h = max(h, PXP_MIN_PIX);
+	if ((l + w) > fbw)
+		l = 0;
+	if ((t + h) > fbh)
+		t = 0;
+
+	/* Round up values to PxP pixel block */
+	l = roundup(l, PXP_MIN_PIX);
+	t = roundup(t, PXP_MIN_PIX);
+	w = roundup(w, PXP_MIN_PIX);
+	h = roundup(h, PXP_MIN_PIX);
+
+	pxp->pxp_conf.proc_data.drect.left = l;
+	pxp->pxp_conf.proc_data.drect.top = t;
+	pxp->pxp_conf.proc_data.drect.width = w;
+	pxp->pxp_conf.proc_data.drect.height = h;
+
+	memset(pxp->outbuf.vaddr, 0x0, pxp->outbuf.size);
+
+	return 0;
+}
+
+static int pxp_queryctrl(struct file *file, void *priv,
+			 struct v4l2_queryctrl *qc)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pxp_controls); i++)
+		if (qc->id && qc->id == pxp_controls[i].id) {
+			memcpy(qc, &(pxp_controls[i]), sizeof(*qc));
+			return 0;
+		}
+
+	return -EINVAL;
+}
+
+static int pxp_g_ctrl(struct file *file, void *priv,
+			 struct v4l2_control *vc)
+{
+	int i;
+
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+
+	for (i = 0; i < ARRAY_SIZE(pxp_controls); i++)
+		if (vc->id == pxp_controls[i].id)
+			return pxp_get_cstate(pxp, vc);
+
+	return -EINVAL;
+}
+
+static int pxp_s_ctrl(struct file *file, void *priv,
+			 struct v4l2_control *vc)
+{
+	int i;
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+
+	for (i = 0; i < ARRAY_SIZE(pxp_controls); i++)
+		if (vc->id == pxp_controls[i].id) {
+			if (vc->value < pxp_controls[i].minimum ||
+			    vc->value > pxp_controls[i].maximum)
+				return -ERANGE;
+			return pxp_set_cstate(pxp, vc);
+		}
+
+	memset(pxp->outbuf.vaddr, 0x0, pxp->outbuf.size);
+
+	return -EINVAL;
+}
+
+void pxp_release(struct video_device *vfd)
+{
+	struct pxps *pxp = video_get_drvdata(vfd);
+
+	spin_lock(&pxp->lock);
+	video_device_release(vfd);
+	spin_unlock(&pxp->lock);
+}
+
+static int pxp_open(struct file *file)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+	int ret = 0;
+
+	mutex_lock(&pxp->mutex);
+	pxp->users++;
+
+	if (pxp->users > 1) {
+		pxp->users--;
+		ret = -EBUSY;
+		goto out;
+	}
+out:
+	mutex_unlock(&pxp->mutex);
+	if (ret)
+		return ret;
+
+	ret = pxp_set_fbinfo(pxp);
+	if (ret) {
+		dev_err(&pxp->pdev->dev, "failed to call pxp_set_fbinfo\n");
+		return ret;
+	}
+
+	videobuf_queue_dma_contig_init(&pxp->s0_vbq,
+				&pxp_vbq_ops,
+				&pxp->pdev->dev,
+				&pxp->lock,
+				V4L2_BUF_TYPE_VIDEO_OUTPUT,
+				V4L2_FIELD_NONE,
+				sizeof(struct pxp_buffer),
+				pxp,
+				NULL);
+	dev_dbg(&pxp->pdev->dev, "call pxp_open\n");
+
+	return 0;
+}
+
+static int pxp_close(struct file *file)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+
+	pxp_streamoff(file, NULL, V4L2_BUF_TYPE_VIDEO_OUTPUT);
+	videobuf_stop(&pxp->s0_vbq);
+	videobuf_mmap_free(&pxp->s0_vbq);
+	pxp->active = NULL;
+
+	mutex_lock(&pxp->mutex);
+	pxp->users--;
+	mutex_unlock(&pxp->mutex);
+
+	return 0;
+}
+
+static int pxp_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct pxps *pxp = video_get_drvdata(video_devdata(file));
+	int ret;
+
+	ret = videobuf_mmap_mapper(&pxp->s0_vbq, vma);
+
+	return ret;
+}
+
+static const struct v4l2_file_operations pxp_fops = {
+	.owner		= THIS_MODULE,
+	.open		= pxp_open,
+	.release	= pxp_close,
+	.unlocked_ioctl	= video_ioctl2,
+	.mmap		= pxp_mmap,
+};
+
+static const struct v4l2_ioctl_ops pxp_ioctl_ops = {
+	.vidioc_querycap		= pxp_querycap,
+
+	.vidioc_reqbufs			= pxp_reqbufs,
+	.vidioc_querybuf		= pxp_querybuf,
+	.vidioc_qbuf			= pxp_qbuf,
+	.vidioc_dqbuf			= pxp_dqbuf,
+
+	.vidioc_streamon		= pxp_streamon,
+	.vidioc_streamoff		= pxp_streamoff,
+
+	.vidioc_enum_output		= pxp_enumoutput,
+	.vidioc_g_output		= pxp_g_output,
+	.vidioc_s_output		= pxp_s_output,
+
+	.vidioc_enum_fmt_vid_out	= pxp_enum_fmt_video_output,
+	.vidioc_try_fmt_vid_out		= pxp_try_fmt_video_output,
+	.vidioc_g_fmt_vid_out		= pxp_g_fmt_video_output,
+	.vidioc_s_fmt_vid_out		= pxp_s_fmt_video_output,
+
+	.vidioc_try_fmt_vid_out_overlay	= pxp_try_fmt_output_overlay,
+	.vidioc_g_fmt_vid_out_overlay	= pxp_g_fmt_output_overlay,
+	.vidioc_s_fmt_vid_out_overlay	= pxp_s_fmt_output_overlay,
+
+	.vidioc_g_fbuf			= pxp_g_fbuf,
+	.vidioc_s_fbuf			= pxp_s_fbuf,
+
+	.vidioc_g_crop			= pxp_g_crop,
+	.vidioc_s_crop			= pxp_s_crop,
+
+	.vidioc_queryctrl		= pxp_queryctrl,
+	.vidioc_g_ctrl			= pxp_g_ctrl,
+	.vidioc_s_ctrl			= pxp_s_ctrl,
+};
+
+static const struct video_device pxp_template = {
+	.name				= "PxP",
+	.vfl_type 			= V4L2_CAP_VIDEO_OUTPUT |
+						V4L2_CAP_VIDEO_OVERLAY |
+						V4L2_CAP_STREAMING,
+	.vfl_dir			= VFL_DIR_TX,
+	.fops				= &pxp_fops,
+	.release			= pxp_release,
+	.minor				= -1,
+	.ioctl_ops			= &pxp_ioctl_ops,
+};
+
+static const struct of_device_id imx_pxpv4l2_dt_ids[] = {
+	{ .compatible = "fsl,imx6sl-pxp-v4l2", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx_pxpv4l2_dt_ids);
+
+static int pxp_probe(struct platform_device *pdev)
+{
+	struct pxps *pxp;
+	int err = 0;
+
+	pxp = kzalloc(sizeof(*pxp), GFP_KERNEL);
+	if (!pxp) {
+		dev_err(&pdev->dev, "failed to allocate control object\n");
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	dev_set_drvdata(&pdev->dev, pxp);
+
+	INIT_LIST_HEAD(&pxp->outq);
+	spin_lock_init(&pxp->lock);
+	mutex_init(&pxp->mutex);
+
+	pxp->pdev = pdev;
+
+	pxp->vdev = video_device_alloc();
+	if (!pxp->vdev) {
+		dev_err(&pdev->dev, "video_device_alloc() failed\n");
+		err = -ENOMEM;
+		goto freeirq;
+	}
+
+	memcpy(pxp->vdev, &pxp_template, sizeof(pxp_template));
+	video_set_drvdata(pxp->vdev, pxp);
+
+	err = video_register_device(pxp->vdev, VFL_TYPE_GRABBER, video_nr);
+	if (err) {
+		dev_err(&pdev->dev, "failed to register video device\n");
+		goto freevdev;
+	}
+
+	dev_info(&pdev->dev, "initialized\n");
+
+exit:
+	return err;
+
+freevdev:
+	video_device_release(pxp->vdev);
+
+freeirq:
+	kfree(pxp);
+
+	return err;
+}
+
+static int pxp_remove(struct platform_device *pdev)
+{
+	struct pxps *pxp = platform_get_drvdata(pdev);
+
+	video_unregister_device(pxp->vdev);
+	video_device_release(pxp->vdev);
+
+	free_dma_buf(pxp, &pxp->outbuf);
+
+	kfree(pxp);
+
+	return 0;
+}
+
+static struct platform_driver pxp_driver = {
+	.driver 	= {
+		.name	= PXP_DRIVER_NAME,
+		.of_match_table = of_match_ptr(imx_pxpv4l2_dt_ids),
+	},
+	.probe		= pxp_probe,
+	.remove		= pxp_remove,
+};
+
+module_platform_driver(pxp_driver);
+
+module_param(video_nr, int, 0444);
+MODULE_DESCRIPTION("MXC PxP V4L2 driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/mxc/output/mxc_pxp_v4l2.h b/drivers/media/platform/mxc/output/mxc_pxp_v4l2.h
new file mode 100644
index 0000000..8abb4c1
--- /dev/null
+++ b/drivers/media/platform/mxc/output/mxc_pxp_v4l2.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+/*
+ * Based on STMP378X PxP driver
+ * Copyright 2008-2009 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+#ifndef	_MXC_PXP_V4L2_H
+#define	_MXC_PXP_V4L2_H
+
+#include <linux/dmaengine.h>
+#include <linux/pxp_dma.h>
+
+struct pxp_buffer {
+	/* Must be first! */
+	struct videobuf_buffer vb;
+
+	/* One descriptor per scatterlist (per frame) */
+	struct dma_async_tx_descriptor		*txd;
+
+	struct scatterlist			sg[3];
+};
+
+struct dma_mem {
+	void *vaddr;
+	dma_addr_t paddr;
+	size_t size;
+};
+
+struct pxps {
+	struct platform_device *pdev;
+
+	spinlock_t lock;
+	struct mutex mutex;
+	int users;
+
+	struct video_device *vdev;
+
+	struct videobuf_queue s0_vbq;
+	struct pxp_buffer *active;
+	struct list_head outq;
+	struct pxp_channel	*pxp_channel[1];	/* We need 1 channel */
+	struct pxp_config_data pxp_conf;
+	struct dma_mem outbuf;
+
+	int output;
+
+	/* Current S0 configuration */
+	struct pxp_data_format *s0_fmt;
+
+	struct fb_info *fbi;
+	struct v4l2_framebuffer fb;
+
+	/* Output overlay support */
+	int overlay_state;
+	int global_alpha_state;
+	u8  global_alpha;
+	int s1_chromakey_state;
+	u32 s1_chromakey;
+
+	int fb_blank;
+};
+
+struct pxp_data_format {
+	char *name;
+	unsigned int bpp;
+	u32 fourcc;
+	enum v4l2_colorspace colorspace;
+};
+
+#endif
diff --git a/drivers/media/platform/mxc/output/mxc_vout.c b/drivers/media/platform/mxc/output/mxc_vout.c
new file mode 100644
index 0000000..cf40e9a
--- /dev/null
+++ b/drivers/media/platform/mxc/output/mxc_vout.c
@@ -0,0 +1,2277 @@
+/*
+ * Copyright (C) 2011-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/console.h>
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/ipu-v3.h>
+#include <linux/module.h>
+#include <linux/mxcfb.h>
+#include <linux/mxc_v4l2.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/videodev2.h>
+#include <linux/vmalloc.h>
+
+#include <media/videobuf-dma-contig.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+
+#define UYVY_BLACK	(0x00800080)
+#define RGB_BLACK	(0x0)
+#define UV_BLACK	(0x80)
+#define Y_BLACK		(0x0)
+
+#define MAX_FB_NUM	6
+#define FB_BUFS		3
+#define VDOA_FB_BUFS	(FB_BUFS - 1)
+#define VALID_HEIGHT_1080P	(1080)
+#define FRAME_HEIGHT_1080P	(1088)
+#define FRAME_WIDTH_1080P	(1920)
+#define CHECK_TILED_1080P_DISPLAY(vout)	\
+	((((vout)->task.input.format == IPU_PIX_FMT_TILED_NV12) ||	\
+	       ((vout)->task.input.format == IPU_PIX_FMT_TILED_NV12F)) &&\
+	       ((vout)->task.input.width == FRAME_WIDTH_1080P) &&	\
+	       ((vout)->task.input.height == FRAME_HEIGHT_1080P) &&	\
+	       ((vout)->task.input.crop.w == FRAME_WIDTH_1080P) &&	\
+	       (((vout)->task.input.crop.h == FRAME_HEIGHT_1080P) ||	\
+	       ((vout)->task.input.crop.h == VALID_HEIGHT_1080P)) &&	\
+	       ((vout)->task.output.width == FRAME_WIDTH_1080P) &&	\
+	       ((vout)->task.output.height == VALID_HEIGHT_1080P) &&	\
+	       ((vout)->task.output.crop.w == FRAME_WIDTH_1080P) &&	\
+	       ((vout)->task.output.crop.h == VALID_HEIGHT_1080P))
+#define CHECK_TILED_1080P_STREAM(vout)	\
+	((((vout)->task.input.format == IPU_PIX_FMT_TILED_NV12) ||	\
+	       ((vout)->task.input.format == IPU_PIX_FMT_TILED_NV12F)) &&\
+	       ((vout)->task.input.width == FRAME_WIDTH_1080P) &&	\
+	       ((vout)->task.input.crop.w == FRAME_WIDTH_1080P) &&	\
+	       ((vout)->task.input.height == FRAME_HEIGHT_1080P) &&	\
+	       ((vout)->task.input.crop.h == FRAME_HEIGHT_1080P))
+#define IS_PLANAR_PIXEL_FORMAT(format) \
+	(format == IPU_PIX_FMT_NV12 ||		\
+	    format == IPU_PIX_FMT_YUV420P2 ||	\
+	    format == IPU_PIX_FMT_YUV420P ||	\
+	    format == IPU_PIX_FMT_YVU420P ||	\
+	    format == IPU_PIX_FMT_YUV422P ||	\
+	    format == IPU_PIX_FMT_YVU422P ||	\
+	    format == IPU_PIX_FMT_YUV444P)
+
+#define NSEC_PER_FRAME_30FPS		(33333333)
+
+struct mxc_vout_fb {
+	char *name;
+	int ipu_id;
+	struct v4l2_rect crop_bounds;
+	unsigned int disp_fmt;
+	bool disp_support_csc;
+	bool disp_support_windows;
+};
+
+struct dma_mem {
+	void *vaddr;
+	dma_addr_t paddr;
+	size_t size;
+};
+
+struct mxc_vout_output {
+	int open_cnt;
+	struct fb_info *fbi;
+	unsigned long fb_smem_start;
+	unsigned long fb_smem_len;
+	struct video_device *vfd;
+	struct mutex mutex;
+	struct mutex task_lock;
+	enum v4l2_buf_type type;
+
+	struct videobuf_queue vbq;
+	spinlock_t vbq_lock;
+
+	struct list_head queue_list;
+	struct list_head active_list;
+
+	struct v4l2_rect crop_bounds;
+	unsigned int disp_fmt;
+	struct mxcfb_pos win_pos;
+	bool disp_support_windows;
+	bool disp_support_csc;
+
+	bool fmt_init;
+	bool release;
+	bool linear_bypass_pp;
+	bool vdoa_1080p;
+	bool tiled_bypass_pp;
+	struct v4l2_rect in_rect;
+	struct ipu_task	task;
+	struct ipu_task	vdoa_task;
+	struct dma_mem vdoa_work;
+	struct dma_mem vdoa_output[VDOA_FB_BUFS];
+
+	bool timer_stop;
+	struct hrtimer timer;
+	struct workqueue_struct *v4l_wq;
+	struct work_struct disp_work;
+	unsigned long frame_count;
+	unsigned long vdi_frame_cnt;
+	ktime_t start_ktime;
+
+	int ctrl_rotate;
+	int ctrl_vflip;
+	int ctrl_hflip;
+
+	dma_addr_t disp_bufs[FB_BUFS];
+
+	struct videobuf_buffer *pre1_vb;
+	struct videobuf_buffer *pre2_vb;
+};
+
+struct mxc_vout_dev {
+	struct device	*dev;
+	struct v4l2_device v4l2_dev;
+	struct mxc_vout_output *out[MAX_FB_NUM];
+	int out_num;
+};
+
+/* Driver Configuration macros */
+#define VOUT_NAME		"mxc_vout"
+
+/* Variables configurable through module params*/
+static int debug;
+static int vdi_rate_double;
+static int video_nr = 16;
+
+/* Module parameters */
+module_param(video_nr, int, S_IRUGO);
+MODULE_PARM_DESC(video_nr, "video device numbers");
+module_param(debug, int, 0600);
+MODULE_PARM_DESC(debug, "Debug level (0-1)");
+module_param(vdi_rate_double, int, 0600);
+MODULE_PARM_DESC(vdi_rate_double, "vdi frame rate double on/off");
+
+static const struct v4l2_fmtdesc mxc_formats[] = {
+	{
+		.description = "RGB565",
+		.pixelformat = V4L2_PIX_FMT_RGB565,
+	},
+	{
+		.description = "BGR24",
+		.pixelformat = V4L2_PIX_FMT_BGR24,
+	},
+	{
+		.description = "RGB24",
+		.pixelformat = V4L2_PIX_FMT_RGB24,
+	},
+	{
+		.description = "RGB32",
+		.pixelformat = V4L2_PIX_FMT_RGB32,
+	},
+	{
+		.description = "BGR32",
+		.pixelformat = V4L2_PIX_FMT_BGR32,
+	},
+	{
+		.description = "NV12",
+		.pixelformat = V4L2_PIX_FMT_NV12,
+	},
+	{
+		.description = "UYVY",
+		.pixelformat = V4L2_PIX_FMT_UYVY,
+	},
+	{
+		.description = "YUYV",
+		.pixelformat = V4L2_PIX_FMT_YUYV,
+	},
+	{
+		.description = "YUV422 planar",
+		.pixelformat = V4L2_PIX_FMT_YUV422P,
+	},
+	{
+		.description = "YUV444",
+		.pixelformat = V4L2_PIX_FMT_YUV444,
+	},
+	{
+		.description = "YUV420",
+		.pixelformat = V4L2_PIX_FMT_YUV420,
+	},
+	{
+		.description = "YVU420",
+		.pixelformat = V4L2_PIX_FMT_YVU420,
+	},
+	{
+		.description = "TILED NV12P",
+		.pixelformat = IPU_PIX_FMT_TILED_NV12,
+	},
+	{
+		.description = "TILED NV12F",
+		.pixelformat = IPU_PIX_FMT_TILED_NV12F,
+	},
+	{
+		.description = "YUV444 planar",
+		.pixelformat = IPU_PIX_FMT_YUV444P,
+	},
+};
+
+#define NUM_MXC_VOUT_FORMATS (ARRAY_SIZE(mxc_formats))
+
+#define DEF_INPUT_WIDTH		320
+#define DEF_INPUT_HEIGHT	240
+
+static int mxc_vidioc_streamoff(struct file *file, void *fh,
+					enum v4l2_buf_type i);
+
+static struct mxc_vout_fb g_fb_setting[MAX_FB_NUM];
+static int config_disp_output(struct mxc_vout_output *vout);
+static void release_disp_output(struct mxc_vout_output *vout);
+
+static unsigned int get_frame_size(struct mxc_vout_output *vout)
+{
+	unsigned int size;
+
+	if (IPU_PIX_FMT_TILED_NV12 == vout->task.input.format)
+		size = TILED_NV12_FRAME_SIZE(vout->task.input.width,
+					vout->task.input.height);
+	else if (IPU_PIX_FMT_TILED_NV12F == vout->task.input.format) {
+		size = TILED_NV12_FRAME_SIZE(vout->task.input.width,
+					vout->task.input.height/2);
+		size *= 2;
+	} else
+		size = vout->task.input.width * vout->task.input.height *
+				fmt_to_bpp(vout->task.input.format)/8;
+
+	return size;
+}
+
+static void free_dma_buf(struct mxc_vout_output *vout, struct dma_mem *buf)
+{
+	dma_free_coherent(vout->vbq.dev, buf->size, buf->vaddr, buf->paddr);
+	v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+			"free dma size:0x%x, paddr:0x%x\n",
+			buf->size, buf->paddr);
+	memset(buf, 0, sizeof(*buf));
+}
+
+static int alloc_dma_buf(struct mxc_vout_output *vout, struct dma_mem *buf)
+{
+
+	buf->vaddr = dma_alloc_coherent(vout->vbq.dev, buf->size, &buf->paddr,
+						GFP_DMA | GFP_KERNEL);
+	if (!buf->vaddr) {
+		v4l2_err(vout->vfd->v4l2_dev,
+			"cannot get dma buf size:0x%x\n", buf->size);
+		return -ENOMEM;
+	}
+	v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+		"alloc dma buf size:0x%x, paddr:0x%x\n", buf->size, buf->paddr);
+	return 0;
+}
+
+static ipu_channel_t get_ipu_channel(struct fb_info *fbi)
+{
+	ipu_channel_t ipu_ch = CHAN_NONE;
+	mm_segment_t old_fs;
+
+	if (fbi->fbops->fb_ioctl) {
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);
+		fbi->fbops->fb_ioctl(fbi, MXCFB_GET_FB_IPU_CHAN,
+				(unsigned long)&ipu_ch);
+		set_fs(old_fs);
+	}
+
+	return ipu_ch;
+}
+
+static unsigned int get_ipu_fmt(struct fb_info *fbi)
+{
+	mm_segment_t old_fs;
+	unsigned int fb_fmt;
+
+	if (fbi->fbops->fb_ioctl) {
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);
+		fbi->fbops->fb_ioctl(fbi, MXCFB_GET_DIFMT,
+				(unsigned long)&fb_fmt);
+		set_fs(old_fs);
+	}
+
+	return fb_fmt;
+}
+
+static void update_display_setting(void)
+{
+	int i;
+	struct fb_info *fbi;
+	struct v4l2_rect bg_crop_bounds[2];
+
+	for (i = 0; i < num_registered_fb; i++) {
+		fbi = registered_fb[i];
+
+		memset(&g_fb_setting[i], 0, sizeof(struct mxc_vout_fb));
+
+		if (!strncmp(fbi->fix.id, "DISP3", 5))
+			g_fb_setting[i].ipu_id = 0;
+		else
+			g_fb_setting[i].ipu_id = 1;
+
+		g_fb_setting[i].name = fbi->fix.id;
+		g_fb_setting[i].crop_bounds.left = 0;
+		g_fb_setting[i].crop_bounds.top = 0;
+		g_fb_setting[i].crop_bounds.width = fbi->var.xres;
+		g_fb_setting[i].crop_bounds.height = fbi->var.yres;
+		g_fb_setting[i].disp_fmt = get_ipu_fmt(fbi);
+
+		if (get_ipu_channel(fbi) == MEM_BG_SYNC) {
+			bg_crop_bounds[g_fb_setting[i].ipu_id] =
+				g_fb_setting[i].crop_bounds;
+			g_fb_setting[i].disp_support_csc = true;
+		} else if (get_ipu_channel(fbi) == MEM_FG_SYNC) {
+			g_fb_setting[i].disp_support_csc = true;
+			g_fb_setting[i].disp_support_windows = true;
+		}
+	}
+
+	for (i = 0; i < num_registered_fb; i++) {
+		fbi = registered_fb[i];
+
+		if (get_ipu_channel(fbi) == MEM_FG_SYNC)
+			g_fb_setting[i].crop_bounds =
+				bg_crop_bounds[g_fb_setting[i].ipu_id];
+	}
+}
+
+/* called after g_fb_setting filled by update_display_setting */
+static int update_setting_from_fbi(struct mxc_vout_output *vout,
+			struct fb_info *fbi)
+{
+	int i;
+	bool found = false;
+
+	for (i = 0; i < MAX_FB_NUM; i++) {
+		if (g_fb_setting[i].name) {
+			if (!strcmp(fbi->fix.id, g_fb_setting[i].name)) {
+				vout->crop_bounds = g_fb_setting[i].crop_bounds;
+				vout->disp_fmt = g_fb_setting[i].disp_fmt;
+				vout->disp_support_csc =
+					g_fb_setting[i].disp_support_csc;
+				vout->disp_support_windows =
+					g_fb_setting[i].disp_support_windows;
+				found = true;
+				break;
+			}
+		}
+	}
+
+	if (!found) {
+		v4l2_err(vout->vfd->v4l2_dev, "can not find output\n");
+		return -EINVAL;
+	}
+	strlcpy(vout->vfd->name, fbi->fix.id, sizeof(vout->vfd->name));
+
+	memset(&vout->task, 0, sizeof(struct ipu_task));
+
+	vout->task.input.width = DEF_INPUT_WIDTH;
+	vout->task.input.height = DEF_INPUT_HEIGHT;
+	vout->task.input.crop.pos.x = 0;
+	vout->task.input.crop.pos.y = 0;
+	vout->task.input.crop.w = DEF_INPUT_WIDTH;
+	vout->task.input.crop.h = DEF_INPUT_HEIGHT;
+
+	vout->task.output.width = vout->crop_bounds.width;
+	vout->task.output.height = vout->crop_bounds.height;
+	vout->task.output.crop.pos.x = 0;
+	vout->task.output.crop.pos.y = 0;
+	vout->task.output.crop.w = vout->crop_bounds.width;
+	vout->task.output.crop.h = vout->crop_bounds.height;
+	if (colorspaceofpixel(vout->disp_fmt) == YUV_CS)
+		vout->task.output.format = IPU_PIX_FMT_UYVY;
+	else
+		vout->task.output.format = IPU_PIX_FMT_RGB565;
+
+	return 0;
+}
+
+static inline unsigned long get_jiffies(struct timeval *t)
+{
+	struct timeval cur;
+
+	if (t->tv_usec >= 1000000) {
+		t->tv_sec += t->tv_usec / 1000000;
+		t->tv_usec = t->tv_usec % 1000000;
+	}
+
+	do_gettimeofday(&cur);
+	if ((t->tv_sec < cur.tv_sec)
+	    || ((t->tv_sec == cur.tv_sec) && (t->tv_usec < cur.tv_usec)))
+		return jiffies;
+
+	if (t->tv_usec < cur.tv_usec) {
+		cur.tv_sec = t->tv_sec - cur.tv_sec - 1;
+		cur.tv_usec = t->tv_usec + 1000000 - cur.tv_usec;
+	} else {
+		cur.tv_sec = t->tv_sec - cur.tv_sec;
+		cur.tv_usec = t->tv_usec - cur.tv_usec;
+	}
+
+	return jiffies + timeval_to_jiffies(&cur);
+}
+
+static bool deinterlace_3_field(struct mxc_vout_output *vout)
+{
+	return (vout->task.input.deinterlace.enable &&
+		(vout->task.input.deinterlace.motion != HIGH_MOTION));
+}
+
+static int set_field_fmt(struct mxc_vout_output *vout, enum v4l2_field field)
+{
+	struct ipu_deinterlace *deinterlace = &vout->task.input.deinterlace;
+
+	switch (field) {
+	/* Images are in progressive format, not interlaced */
+	case V4L2_FIELD_NONE:
+	case V4L2_FIELD_ANY:
+		deinterlace->enable = false;
+		deinterlace->field_fmt = 0;
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev, "Progressive frame.\n");
+		break;
+	case V4L2_FIELD_INTERLACED_TB:
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+				"Enable deinterlace TB.\n");
+		deinterlace->enable = true;
+		deinterlace->field_fmt = IPU_DEINTERLACE_FIELD_TOP;
+		break;
+	case V4L2_FIELD_INTERLACED_BT:
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+				"Enable deinterlace BT.\n");
+		deinterlace->enable = true;
+		deinterlace->field_fmt = IPU_DEINTERLACE_FIELD_BOTTOM;
+		break;
+	default:
+		v4l2_err(vout->vfd->v4l2_dev,
+			"field format:%d not supported yet!\n", field);
+		return -EINVAL;
+	}
+
+	if (IPU_PIX_FMT_TILED_NV12F == vout->task.input.format) {
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+				"tiled fmt enable deinterlace.\n");
+		deinterlace->enable = true;
+	}
+
+	if (deinterlace->enable && vdi_rate_double)
+		deinterlace->field_fmt |= IPU_DEINTERLACE_RATE_EN;
+
+	return 0;
+}
+
+static bool is_pp_bypass(struct mxc_vout_output *vout)
+{
+	if ((IPU_PIX_FMT_TILED_NV12 == vout->task.input.format) ||
+		(IPU_PIX_FMT_TILED_NV12F == vout->task.input.format))
+		return false;
+	if ((vout->task.input.width == vout->task.output.width) &&
+		(vout->task.input.height == vout->task.output.height) &&
+		(vout->task.input.crop.w == vout->task.output.crop.w) &&
+		(vout->task.input.crop.h == vout->task.output.crop.h) &&
+		(vout->task.output.rotate < IPU_ROTATE_HORIZ_FLIP) &&
+		!vout->task.input.deinterlace.enable) {
+		if (vout->disp_support_csc)
+			return true;
+		else if (!need_csc(vout->task.input.format, vout->disp_fmt))
+			return true;
+	/*
+	 * input crop show to full output which can show based on
+	 * xres_virtual/yres_virtual
+	 */
+	} else if ((vout->task.input.crop.w == vout->task.output.crop.w) &&
+			(vout->task.output.crop.w == vout->task.output.width) &&
+			(vout->task.input.crop.h == vout->task.output.crop.h) &&
+			(vout->task.output.crop.h ==
+				vout->task.output.height) &&
+			(vout->task.output.rotate < IPU_ROTATE_HORIZ_FLIP) &&
+			!vout->task.input.deinterlace.enable) {
+		if (vout->disp_support_csc)
+			return true;
+		else if (!need_csc(vout->task.input.format, vout->disp_fmt))
+			return true;
+	}
+	return false;
+}
+
+static void setup_buf_timer(struct mxc_vout_output *vout,
+			struct videobuf_buffer *vb)
+{
+	ktime_t expiry_time, now;
+
+	/* if timestamp is 0, then default to 30fps */
+	if ((vb->ts.tv_sec == 0) && (vb->ts.tv_usec == 0))
+		expiry_time = ktime_add_ns(vout->start_ktime,
+				NSEC_PER_FRAME_30FPS * vout->frame_count);
+	else
+		expiry_time = timeval_to_ktime(vb->ts);
+
+	now = hrtimer_cb_get_time(&vout->timer);
+	if ((now.tv64 > expiry_time.tv64)) {
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+				"warning: timer timeout already expired.\n");
+		expiry_time = now;
+	}
+
+	hrtimer_start(&vout->timer, expiry_time, HRTIMER_MODE_ABS);
+
+	v4l2_dbg(1, debug, vout->vfd->v4l2_dev, "timer handler next "
+		"schedule: %lldnsecs\n", expiry_time.tv64);
+}
+
+static int show_buf(struct mxc_vout_output *vout, int idx,
+	struct ipu_pos *ipos)
+{
+	struct fb_info *fbi = vout->fbi;
+	struct fb_var_screeninfo var;
+	int ret;
+	u32 fb_base = 0;
+
+	memcpy(&var, &fbi->var, sizeof(var));
+
+	if (vout->linear_bypass_pp || vout->tiled_bypass_pp) {
+		/*
+		 * crack fb base
+		 * NOTE: should not do other fb operation during v4l2
+		 */
+		console_lock();
+		fb_base = fbi->fix.smem_start;
+		fbi->fix.smem_start = vout->task.output.paddr;
+		fbi->var.yoffset = ipos->y + 1;
+		var.xoffset = ipos->x;
+		var.yoffset = ipos->y;
+		var.vmode |= FB_VMODE_YWRAP;
+		ret = fb_pan_display(fbi, &var);
+		fbi->fix.smem_start = fb_base;
+		console_unlock();
+	} else {
+		console_lock();
+		var.yoffset = idx * fbi->var.yres;
+		var.vmode &= ~FB_VMODE_YWRAP;
+		ret = fb_pan_display(fbi, &var);
+		console_unlock();
+	}
+
+	return ret;
+}
+
+static void disp_work_func(struct work_struct *work)
+{
+	struct mxc_vout_output *vout =
+		container_of(work, struct mxc_vout_output, disp_work);
+	struct videobuf_queue *q = &vout->vbq;
+	struct videobuf_buffer *vb, *vb_next = NULL;
+	unsigned long flags = 0;
+	struct ipu_pos ipos;
+	int ret = 0;
+	u32 in_fmt = 0, in_width = 0, in_height = 0;
+	u32 vdi_cnt = 0;
+	u32 vdi_frame;
+	u32 index = 0;
+	u32 ocrop_h = 0;
+	u32 o_height = 0;
+	u32 tiled_interlaced = 0;
+	bool tiled_fmt = false;
+
+	v4l2_dbg(1, debug, vout->vfd->v4l2_dev, "disp work begin one frame\n");
+
+	spin_lock_irqsave(q->irqlock, flags);
+
+	if (list_empty(&vout->active_list)) {
+		v4l2_warn(vout->vfd->v4l2_dev,
+			"no entry in active_list, should not be here\n");
+		spin_unlock_irqrestore(q->irqlock, flags);
+		return;
+	}
+
+	vb = list_first_entry(&vout->active_list,
+			struct videobuf_buffer, queue);
+	ret = set_field_fmt(vout, vb->field);
+	if (ret < 0) {
+		spin_unlock_irqrestore(q->irqlock, flags);
+		return;
+	}
+	if (deinterlace_3_field(vout)) {
+		if (list_is_singular(&vout->active_list)) {
+			if (list_empty(&vout->queue_list)) {
+				vout->timer_stop = true;
+				spin_unlock_irqrestore(q->irqlock, flags);
+				v4l2_warn(vout->vfd->v4l2_dev,
+					"no enough entry for 3 fields "
+					"deinterlacer\n");
+				return;
+			}
+
+			/*
+			 * We need to use the next vb even if it is
+			 * not on the active list.
+			 */
+			vb_next = list_first_entry(&vout->queue_list,
+					struct videobuf_buffer, queue);
+		} else
+			vb_next = list_first_entry(vout->active_list.next,
+						struct videobuf_buffer, queue);
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+			"cur field_fmt:%d, next field_fmt:%d.\n",
+			vb->field, vb_next->field);
+		/* repeat the last field during field format changing */
+		if ((vb->field != vb_next->field) &&
+			(vb_next->field != V4L2_FIELD_NONE))
+			vb_next = vb;
+	}
+
+	spin_unlock_irqrestore(q->irqlock, flags);
+
+vdi_frame_rate_double:
+	mutex_lock(&vout->task_lock);
+
+	v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+		"v4l2 frame_cnt:%ld, vb_field:%d, fmt:%d\n",
+		vout->frame_count, vb->field,
+		vout->task.input.deinterlace.field_fmt);
+	if (vb->memory == V4L2_MEMORY_USERPTR)
+		vout->task.input.paddr = vb->baddr;
+	else
+		vout->task.input.paddr = videobuf_to_dma_contig(vb);
+
+	if (vout->task.input.deinterlace.field_fmt & IPU_DEINTERLACE_RATE_EN)
+		index = vout->vdi_frame_cnt % FB_BUFS;
+	else
+		index = vout->frame_count % FB_BUFS;
+	if (vout->linear_bypass_pp) {
+		vout->task.output.paddr = vout->task.input.paddr;
+		ipos.x = vout->task.input.crop.pos.x;
+		ipos.y = vout->task.input.crop.pos.y;
+	} else {
+		if (deinterlace_3_field(vout)) {
+			if (vb->memory == V4L2_MEMORY_USERPTR)
+				vout->task.input.paddr_n = vb_next->baddr;
+			else
+				vout->task.input.paddr_n =
+					videobuf_to_dma_contig(vb_next);
+		}
+		vout->task.output.paddr = vout->disp_bufs[index];
+		if (vout->vdoa_1080p) {
+			o_height =  vout->task.output.height;
+			ocrop_h = vout->task.output.crop.h;
+			vout->task.output.height = FRAME_HEIGHT_1080P;
+			vout->task.output.crop.h = FRAME_HEIGHT_1080P;
+		}
+		tiled_fmt =
+			(IPU_PIX_FMT_TILED_NV12 == vout->task.input.format) ||
+			(IPU_PIX_FMT_TILED_NV12F == vout->task.input.format);
+		if (vout->tiled_bypass_pp) {
+			ipos.x = vout->task.input.crop.pos.x;
+			ipos.y = vout->task.input.crop.pos.y;
+		} else if (tiled_fmt) {
+			vout->vdoa_task.input.paddr = vout->task.input.paddr;
+			if (deinterlace_3_field(vout))
+				vout->vdoa_task.input.paddr_n =
+						vout->task.input.paddr_n;
+			vout->vdoa_task.output.paddr = vout->vdoa_work.paddr;
+			ret = ipu_queue_task(&vout->vdoa_task);
+			if (ret < 0) {
+				mutex_unlock(&vout->task_lock);
+				goto err;
+			}
+			vout->task.input.paddr = vout->vdoa_task.output.paddr;
+			in_fmt = vout->task.input.format;
+			in_width = vout->task.input.width;
+			in_height = vout->task.input.height;
+			vout->task.input.format = vout->vdoa_task.output.format;
+			vout->task.input.width = vout->vdoa_task.output.width;
+			vout->task.input.height = vout->vdoa_task.output.height;
+			if (vout->task.input.deinterlace.enable) {
+				tiled_interlaced = 1;
+				vout->task.input.deinterlace.enable = 0;
+			}
+			v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+					"tiled queue task\n");
+		}
+		ret = ipu_queue_task(&vout->task);
+		if ((!vout->tiled_bypass_pp) && tiled_fmt) {
+			vout->task.input.format = in_fmt;
+			vout->task.input.width = in_width;
+			vout->task.input.height = in_height;
+		}
+		if (tiled_interlaced)
+			vout->task.input.deinterlace.enable = 1;
+		if (ret < 0) {
+			mutex_unlock(&vout->task_lock);
+			goto err;
+		}
+		if (vout->vdoa_1080p) {
+			vout->task.output.crop.h = ocrop_h;
+			vout->task.output.height = o_height;
+		}
+	}
+
+	mutex_unlock(&vout->task_lock);
+
+	ret = show_buf(vout, index, &ipos);
+	if (ret < 0)
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+			"show buf with ret %d\n", ret);
+
+	if (vout->task.input.deinterlace.field_fmt & IPU_DEINTERLACE_RATE_EN) {
+		vdi_frame = vout->task.input.deinterlace.field_fmt
+				& IPU_DEINTERLACE_RATE_FRAME1;
+		if (vdi_frame)
+			vout->task.input.deinterlace.field_fmt &=
+			~IPU_DEINTERLACE_RATE_FRAME1;
+		else
+			vout->task.input.deinterlace.field_fmt |=
+			IPU_DEINTERLACE_RATE_FRAME1;
+		vout->vdi_frame_cnt++;
+		vdi_cnt++;
+		if (vdi_cnt < IPU_DEINTERLACE_MAX_FRAME)
+			goto vdi_frame_rate_double;
+	}
+	spin_lock_irqsave(q->irqlock, flags);
+
+	list_del(&vb->queue);
+
+	/*
+	 * The videobuf before the last one has been shown. Set
+	 * VIDEOBUF_DONE state here to avoid tearing issue in ic bypass
+	 * case, which makes sure a buffer being shown will not be
+	 * dequeued to be overwritten. It also brings side-effect that
+	 * the last 2 buffers can not be dequeued correctly, apps need
+	 * to take care of it.
+	 */
+	if (vout->pre2_vb) {
+		vout->pre2_vb->state = VIDEOBUF_DONE;
+		wake_up_interruptible(&vout->pre2_vb->done);
+		vout->pre2_vb = NULL;
+	}
+
+	if (vout->linear_bypass_pp) {
+		vout->pre2_vb = vout->pre1_vb;
+		vout->pre1_vb = vb;
+	} else {
+		if (vout->pre1_vb) {
+			vout->pre1_vb->state = VIDEOBUF_DONE;
+			wake_up_interruptible(&vout->pre1_vb->done);
+			vout->pre1_vb = NULL;
+		}
+		vb->state = VIDEOBUF_DONE;
+		wake_up_interruptible(&vb->done);
+	}
+
+	vout->frame_count++;
+
+	/* pick next queue buf to setup timer */
+	if (list_empty(&vout->queue_list))
+		vout->timer_stop = true;
+	else {
+		vb = list_first_entry(&vout->queue_list,
+				struct videobuf_buffer, queue);
+		setup_buf_timer(vout, vb);
+	}
+
+	spin_unlock_irqrestore(q->irqlock, flags);
+
+	v4l2_dbg(1, debug, vout->vfd->v4l2_dev, "disp work finish one frame\n");
+
+	return;
+err:
+	v4l2_err(vout->vfd->v4l2_dev, "display work fail ret = %d\n", ret);
+	vout->timer_stop = true;
+	vb->state = VIDEOBUF_ERROR;
+	return;
+}
+
+static enum hrtimer_restart mxc_vout_timer_handler(struct hrtimer *timer)
+{
+	struct mxc_vout_output *vout = container_of(timer,
+						    struct mxc_vout_output,
+						    timer);
+	struct videobuf_queue *q = &vout->vbq;
+	struct videobuf_buffer *vb;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(q->irqlock, flags);
+
+	/*
+	 * put first queued entry into active, if previous entry did not
+	 * finish, setup current entry's timer again.
+	 */
+	if (list_empty(&vout->queue_list)) {
+		spin_unlock_irqrestore(q->irqlock, flags);
+		return HRTIMER_NORESTART;
+	}
+
+	/* move videobuf from queued list to active list */
+	vb = list_first_entry(&vout->queue_list,
+			struct videobuf_buffer, queue);
+	list_del(&vb->queue);
+	list_add_tail(&vb->queue, &vout->active_list);
+
+	if (queue_work(vout->v4l_wq, &vout->disp_work) == 0) {
+		v4l2_warn(vout->vfd->v4l2_dev,
+		"disp work was in queue already, queue buf again next time\n");
+		list_del(&vb->queue);
+		list_add(&vb->queue, &vout->queue_list);
+		spin_unlock_irqrestore(q->irqlock, flags);
+		return HRTIMER_NORESTART;
+	}
+
+	vb->state = VIDEOBUF_ACTIVE;
+
+	spin_unlock_irqrestore(q->irqlock, flags);
+
+	return HRTIMER_NORESTART;
+}
+
+/* Video buffer call backs */
+
+/*
+ * Buffer setup function is called by videobuf layer when REQBUF ioctl is
+ * called. This is used to setup buffers and return size and count of
+ * buffers allocated. After the call to this buffer, videobuf layer will
+ * setup buffer queue depending on the size and count of buffers
+ */
+static int mxc_vout_buffer_setup(struct videobuf_queue *q, unsigned int *count,
+			  unsigned int *size)
+{
+	struct mxc_vout_output *vout = q->priv_data;
+	unsigned int frame_size;
+
+	if (!vout)
+		return -EINVAL;
+
+	if (V4L2_BUF_TYPE_VIDEO_OUTPUT != q->type)
+		return -EINVAL;
+
+	frame_size = get_frame_size(vout);
+	*size = PAGE_ALIGN(frame_size);
+
+	return 0;
+}
+
+/*
+ * This function will be called when VIDIOC_QBUF ioctl is called.
+ * It prepare buffers before give out for the display. This function
+ * converts user space virtual address into physical address if userptr memory
+ * exchange mechanism is used.
+ */
+static int mxc_vout_buffer_prepare(struct videobuf_queue *q,
+			    struct videobuf_buffer *vb,
+			    enum v4l2_field field)
+{
+	vb->state = VIDEOBUF_PREPARED;
+	return 0;
+}
+
+/*
+ * Buffer queue funtion will be called from the videobuf layer when _QBUF
+ * ioctl is called. It is used to enqueue buffer, which is ready to be
+ * displayed.
+ * This function is protected by q->irqlock.
+ */
+static void mxc_vout_buffer_queue(struct videobuf_queue *q,
+			  struct videobuf_buffer *vb)
+{
+	struct mxc_vout_output *vout = q->priv_data;
+	struct videobuf_buffer *active_vb;
+
+	list_add_tail(&vb->queue, &vout->queue_list);
+	vb->state = VIDEOBUF_QUEUED;
+
+	if (vout->timer_stop) {
+		if (deinterlace_3_field(vout) &&
+			!list_empty(&vout->active_list)) {
+			active_vb = list_first_entry(&vout->active_list,
+					struct videobuf_buffer, queue);
+			setup_buf_timer(vout, active_vb);
+		} else {
+			setup_buf_timer(vout, vb);
+		}
+		vout->timer_stop = false;
+	}
+}
+
+/*
+ * Buffer release function is called from videobuf layer to release buffer
+ * which are already allocated
+ */
+static void mxc_vout_buffer_release(struct videobuf_queue *q,
+			    struct videobuf_buffer *vb)
+{
+	vb->state = VIDEOBUF_NEEDS_INIT;
+}
+
+static int mxc_vout_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int ret;
+	struct mxc_vout_output *vout = file->private_data;
+
+	if (!vout)
+		return -ENODEV;
+
+	ret = videobuf_mmap_mapper(&vout->vbq, vma);
+	if (ret < 0)
+		v4l2_err(vout->vfd->v4l2_dev,
+				"offset invalid [offset=0x%lx]\n",
+				(vma->vm_pgoff << PAGE_SHIFT));
+
+	return ret;
+}
+
+static int mxc_vout_release(struct file *file)
+{
+	unsigned int ret = 0;
+	struct videobuf_queue *q;
+	struct mxc_vout_output *vout = file->private_data;
+
+	if (!vout)
+		return 0;
+
+	if (--vout->open_cnt == 0) {
+		q = &vout->vbq;
+		if (q->streaming)
+			mxc_vidioc_streamoff(file, vout, vout->type);
+		else {
+			release_disp_output(vout);
+			videobuf_queue_cancel(q);
+		}
+		destroy_workqueue(vout->v4l_wq);
+		ret = videobuf_mmap_free(q);
+	}
+
+	return ret;
+}
+
+static int mxc_vout_open(struct file *file)
+{
+	struct mxc_vout_output *vout = NULL;
+	int ret = 0;
+
+	vout = video_drvdata(file);
+
+	if (vout == NULL)
+		return -ENODEV;
+
+	if (vout->open_cnt++ == 0) {
+		vout->ctrl_rotate = 0;
+		vout->ctrl_vflip = 0;
+		vout->ctrl_hflip = 0;
+		update_display_setting();
+		ret = update_setting_from_fbi(vout, vout->fbi);
+		if (ret < 0)
+			goto err;
+
+		vout->v4l_wq = create_singlethread_workqueue("v4l2q");
+		if (!vout->v4l_wq) {
+			v4l2_err(vout->vfd->v4l2_dev,
+					"Could not create work queue\n");
+			ret = -ENOMEM;
+			goto err;
+		}
+
+		INIT_WORK(&vout->disp_work, disp_work_func);
+
+		INIT_LIST_HEAD(&vout->queue_list);
+		INIT_LIST_HEAD(&vout->active_list);
+
+		vout->fmt_init = false;
+		vout->frame_count = 0;
+		vout->vdi_frame_cnt = 0;
+
+		vout->win_pos.x = 0;
+		vout->win_pos.y = 0;
+		vout->release = true;
+	}
+
+	file->private_data = vout;
+
+err:
+	return ret;
+}
+
+/*
+ * V4L2 ioctls
+ */
+static int mxc_vidioc_querycap(struct file *file, void *fh,
+		struct v4l2_capability *cap)
+{
+	struct mxc_vout_output *vout = fh;
+
+	strlcpy(cap->driver, VOUT_NAME, sizeof(cap->driver));
+	strlcpy(cap->card, vout->vfd->name, sizeof(cap->card));
+	cap->bus_info[0] = '\0';
+	cap->capabilities = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_OUTPUT;
+
+	return 0;
+}
+
+static int mxc_vidioc_enum_fmt_vid_out(struct file *file, void *fh,
+			struct v4l2_fmtdesc *fmt)
+{
+	if (fmt->index >= NUM_MXC_VOUT_FORMATS)
+		return -EINVAL;
+
+	strlcpy(fmt->description, mxc_formats[fmt->index].description,
+			sizeof(fmt->description));
+	fmt->pixelformat = mxc_formats[fmt->index].pixelformat;
+
+	return 0;
+}
+
+static int mxc_vidioc_g_fmt_vid_out(struct file *file, void *fh,
+			struct v4l2_format *f)
+{
+	struct mxc_vout_output *vout = fh;
+	struct v4l2_rect rect;
+
+	f->fmt.pix.width = vout->task.input.width;
+	f->fmt.pix.height = vout->task.input.height;
+	f->fmt.pix.pixelformat = vout->task.input.format;
+	f->fmt.pix.sizeimage = get_frame_size(vout);
+
+	if (f->fmt.pix.priv) {
+		rect.left = vout->task.input.crop.pos.x;
+		rect.top = vout->task.input.crop.pos.y;
+		rect.width = vout->task.input.crop.w;
+		rect.height = vout->task.input.crop.h;
+		if (copy_to_user((void __user *)f->fmt.pix.priv,
+				&rect, sizeof(rect)))
+			return -EFAULT;
+	}
+	v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+			"frame_size:0x%x, pix_fmt:0x%x\n",
+			f->fmt.pix.sizeimage,
+			vout->task.input.format);
+
+	return 0;
+}
+
+static inline int ipu_try_task(struct mxc_vout_output *vout)
+{
+	int ret;
+	struct ipu_task *task = &vout->task;
+
+again:
+	ret = ipu_check_task(task);
+	if (ret != IPU_CHECK_OK) {
+		if (ret > IPU_CHECK_ERR_MIN) {
+			if (ret == IPU_CHECK_ERR_SPLIT_INPUTW_OVER ||
+			    ret == IPU_CHECK_ERR_W_DOWNSIZE_OVER) {
+				task->input.crop.w -= 8;
+				goto again;
+			}
+			if (ret == IPU_CHECK_ERR_SPLIT_INPUTH_OVER ||
+			    ret == IPU_CHECK_ERR_H_DOWNSIZE_OVER) {
+				task->input.crop.h -= 8;
+				goto again;
+			}
+			if (ret == IPU_CHECK_ERR_SPLIT_OUTPUTW_OVER) {
+				if (vout->disp_support_windows) {
+					task->output.width -= 8;
+					task->output.crop.w =
+						task->output.width;
+				} else
+					task->output.crop.w -= 8;
+				goto again;
+			}
+			if (ret == IPU_CHECK_ERR_SPLIT_OUTPUTH_OVER) {
+				if (vout->disp_support_windows) {
+					task->output.height -= 8;
+					task->output.crop.h =
+						task->output.height;
+				} else
+					task->output.crop.h -= 8;
+				goto again;
+			}
+			ret = -EINVAL;
+		}
+	} else
+		ret = 0;
+
+	return ret;
+}
+
+static inline int vdoaipu_try_task(struct mxc_vout_output *vout)
+{
+	int ret;
+	int is_1080p_stream;
+	int in_width, in_height;
+	size_t size;
+	struct ipu_task *ipu_task = &vout->task;
+	struct ipu_crop *icrop = &ipu_task->input.crop;
+	struct ipu_task *vdoa_task = &vout->vdoa_task;
+	u32 deinterlace = 0;
+	u32 in_fmt;
+
+	if (vout->task.input.deinterlace.enable)
+		deinterlace = 1;
+
+	memset(vdoa_task, 0, sizeof(*vdoa_task));
+	vdoa_task->output.format = IPU_PIX_FMT_NV12;
+	memcpy(&vdoa_task->input, &ipu_task->input,
+			sizeof(ipu_task->input));
+	if ((icrop->w % IPU_PIX_FMT_TILED_NV12_MBALIGN) ||
+		(icrop->h % IPU_PIX_FMT_TILED_NV12_MBALIGN)) {
+		vdoa_task->input.crop.w =
+			ALIGN(icrop->w, IPU_PIX_FMT_TILED_NV12_MBALIGN);
+		vdoa_task->input.crop.h =
+			ALIGN(icrop->h, IPU_PIX_FMT_TILED_NV12_MBALIGN);
+	}
+	vdoa_task->output.width = vdoa_task->input.crop.w;
+	vdoa_task->output.height = vdoa_task->input.crop.h;
+	vdoa_task->output.crop.w = vdoa_task->input.crop.w;
+	vdoa_task->output.crop.h = vdoa_task->input.crop.h;
+
+	size = PAGE_ALIGN(vdoa_task->input.crop.w *
+					vdoa_task->input.crop.h *
+					fmt_to_bpp(vdoa_task->output.format)/8);
+	if (size > vout->vdoa_work.size) {
+		if (vout->vdoa_work.vaddr)
+			free_dma_buf(vout, &vout->vdoa_work);
+		vout->vdoa_work.size = size;
+		ret = alloc_dma_buf(vout, &vout->vdoa_work);
+		if (ret < 0)
+			return ret;
+	}
+	ret = ipu_check_task(vdoa_task);
+	if (ret != IPU_CHECK_OK)
+		return -EINVAL;
+
+	is_1080p_stream = CHECK_TILED_1080P_STREAM(vout);
+	if (is_1080p_stream)
+		ipu_task->input.crop.h = VALID_HEIGHT_1080P;
+	in_fmt = ipu_task->input.format;
+	in_width = ipu_task->input.width;
+	in_height = ipu_task->input.height;
+	ipu_task->input.format = vdoa_task->output.format;
+	ipu_task->input.height = vdoa_task->output.height;
+	ipu_task->input.width = vdoa_task->output.width;
+	if (deinterlace)
+		ipu_task->input.deinterlace.enable = 0;
+	ret = ipu_try_task(vout);
+	if (deinterlace)
+		ipu_task->input.deinterlace.enable = 1;
+	ipu_task->input.format = in_fmt;
+	ipu_task->input.width = in_width;
+	ipu_task->input.height = in_height;
+
+	return ret;
+}
+
+static int mxc_vout_try_task(struct mxc_vout_output *vout)
+{
+	int ret = 0;
+	struct ipu_output *output = &vout->task.output;
+	struct ipu_input *input = &vout->task.input;
+	struct ipu_crop *crop = &input->crop;
+	u32 o_height = 0;
+	u32 ocrop_h = 0;
+	bool tiled_fmt = false;
+	bool tiled_need_pp = false;
+
+	vout->vdoa_1080p = CHECK_TILED_1080P_DISPLAY(vout);
+	if (vout->vdoa_1080p) {
+		input->crop.h = FRAME_HEIGHT_1080P;
+		o_height = output->height;
+		ocrop_h = output->crop.h;
+		output->height = FRAME_HEIGHT_1080P;
+		output->crop.h = FRAME_HEIGHT_1080P;
+	}
+
+	if ((IPU_PIX_FMT_TILED_NV12 == input->format) ||
+		(IPU_PIX_FMT_TILED_NV12F == input->format)) {
+		if ((input->width % IPU_PIX_FMT_TILED_NV12_MBALIGN) ||
+			(input->height % IPU_PIX_FMT_TILED_NV12_MBALIGN) ||
+			(crop->pos.x % IPU_PIX_FMT_TILED_NV12_MBALIGN) ||
+			(crop->pos.y % IPU_PIX_FMT_TILED_NV12_MBALIGN)) {
+			v4l2_err(vout->vfd->v4l2_dev,
+				"ERR: tiled fmt needs 16 pixel align.\n");
+			return -EINVAL;
+		}
+		if ((crop->w % IPU_PIX_FMT_TILED_NV12_MBALIGN) ||
+			(crop->h % IPU_PIX_FMT_TILED_NV12_MBALIGN))
+			tiled_need_pp = true;
+	} else {
+		crop->w -= crop->w % 8;
+		crop->h -= crop->h % 8;
+	}
+	/* assume task.output already set by S_CROP */
+	vout->linear_bypass_pp = is_pp_bypass(vout);
+	if (vout->linear_bypass_pp) {
+		v4l2_info(vout->vfd->v4l2_dev, "Bypass IC.\n");
+		output->format = input->format;
+	} else {
+		/* if need CSC, choose IPU-DP or IPU_IC do it */
+		if (vout->disp_support_csc) {
+			if (colorspaceofpixel(input->format) == YUV_CS)
+				output->format = IPU_PIX_FMT_UYVY;
+			else
+				output->format = IPU_PIX_FMT_RGB565;
+		} else {
+			if (colorspaceofpixel(vout->disp_fmt) == YUV_CS)
+				output->format = IPU_PIX_FMT_UYVY;
+			else
+				output->format = IPU_PIX_FMT_RGB565;
+		}
+
+		vout->tiled_bypass_pp = false;
+		if ((IPU_PIX_FMT_TILED_NV12 == input->format) ||
+			(IPU_PIX_FMT_TILED_NV12F == input->format)) {
+			/* check resize/rotate/flip, or csc task */
+			if (!(tiled_need_pp ||
+				(IPU_ROTATE_NONE != output->rotate) ||
+				(input->crop.w != output->crop.w) ||
+				(input->crop.h != output->crop.h) ||
+				(!vout->disp_support_csc &&
+				(colorspaceofpixel(vout->disp_fmt) == RGB_CS)))
+				) {
+				/* IC bypass */
+				output->format = IPU_PIX_FMT_NV12;
+				v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+						"tiled bypass pp\n");
+				vout->tiled_bypass_pp = true;
+			}
+			tiled_fmt = true;
+		}
+
+		if ((!vout->tiled_bypass_pp) && tiled_fmt)
+			ret = vdoaipu_try_task(vout);
+		else
+			ret = ipu_try_task(vout);
+	}
+
+	if (vout->vdoa_1080p) {
+		output->height = o_height;
+		output->crop.h = ocrop_h;
+	}
+
+	v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+			"icrop.w:%u, icrop.h:%u, iw:%u, ih:%u,"
+			"ocrop.w:%u, ocrop.h:%u, ow:%u, oh:%u\n",
+			input->crop.w, input->crop.h,
+			input->width, input->height,
+			output->crop.w, output->crop.h,
+			output->width, output->height);
+	return ret;
+}
+
+static int mxc_vout_try_format(struct mxc_vout_output *vout,
+				struct v4l2_format *f)
+{
+	int ret = 0;
+	struct v4l2_rect rect;
+
+	if ((f->fmt.pix.field != V4L2_FIELD_NONE) &&
+		(IPU_PIX_FMT_TILED_NV12 == vout->task.input.format)) {
+		v4l2_err(vout->vfd->v4l2_dev,
+			"progressive tiled fmt should used V4L2_FIELD_NONE!\n");
+		return -EINVAL;
+	}
+
+	if (f->fmt.pix.priv && copy_from_user(&rect,
+		(void __user *)f->fmt.pix.priv, sizeof(rect)))
+		return -EFAULT;
+
+	vout->task.input.width = f->fmt.pix.width;
+	vout->task.input.height = f->fmt.pix.height;
+	vout->task.input.format = f->fmt.pix.pixelformat;
+
+	ret = set_field_fmt(vout, f->fmt.pix.field);
+	if (ret < 0)
+		return ret;
+
+	if (f->fmt.pix.priv) {
+		vout->task.input.crop.pos.x = rect.left;
+		vout->task.input.crop.pos.y = rect.top;
+		vout->task.input.crop.w = rect.width;
+		vout->task.input.crop.h = rect.height;
+	} else {
+		vout->task.input.crop.pos.x = 0;
+		vout->task.input.crop.pos.y = 0;
+		vout->task.input.crop.w = f->fmt.pix.width;
+		vout->task.input.crop.h = f->fmt.pix.height;
+	}
+	memcpy(&vout->in_rect, &vout->task.input.crop, sizeof(vout->in_rect));
+
+	ret = mxc_vout_try_task(vout);
+	if (!ret) {
+		if (f->fmt.pix.priv) {
+			rect.width = vout->task.input.crop.w;
+			rect.height = vout->task.input.crop.h;
+			if (copy_to_user((void __user *)f->fmt.pix.priv,
+				&rect, sizeof(rect)))
+				ret = -EFAULT;
+		} else {
+			f->fmt.pix.width = vout->task.input.crop.w;
+			f->fmt.pix.height = vout->task.input.crop.h;
+		}
+	}
+
+	return ret;
+}
+
+static bool mxc_vout_need_fb_reconfig(struct mxc_vout_output *vout,
+				      struct mxc_vout_output *pre_vout)
+{
+	if (!vout->vbq.streaming)
+		return false;
+
+	if (vout->tiled_bypass_pp)
+		return true;
+
+	if (vout->linear_bypass_pp != pre_vout->linear_bypass_pp)
+		return true;
+
+	/* cropped output resolution or format are changed */
+	if (vout->task.output.format != pre_vout->task.output.format ||
+	    vout->task.output.crop.w != pre_vout->task.output.crop.w ||
+	    vout->task.output.crop.h != pre_vout->task.output.crop.h)
+		return true;
+
+	/* overlay: window position or resolution are changed */
+	if (vout->disp_support_windows &&
+	    (vout->win_pos.x != pre_vout->win_pos.x ||
+	     vout->win_pos.y != pre_vout->win_pos.y ||
+	     vout->task.output.width  != pre_vout->task.output.width ||
+	     vout->task.output.height != pre_vout->task.output.height))
+		return true;
+
+	/* background: cropped position is changed */
+	if (!vout->disp_support_windows &&
+	    (vout->task.output.crop.pos.x !=
+	     pre_vout->task.output.crop.pos.x ||
+	     vout->task.output.crop.pos.y !=
+	     pre_vout->task.output.crop.pos.y))
+		return true;
+
+	return false;
+}
+
+static int mxc_vidioc_s_fmt_vid_out(struct file *file, void *fh,
+			struct v4l2_format *f)
+{
+	struct mxc_vout_output *vout = fh;
+	int ret = 0;
+
+	if (vout->vbq.streaming)
+		return -EBUSY;
+
+	mutex_lock(&vout->task_lock);
+	ret = mxc_vout_try_format(vout, f);
+	if (ret >= 0)
+		vout->fmt_init = true;
+	mutex_unlock(&vout->task_lock);
+
+	return ret;
+}
+
+static int mxc_vidioc_cropcap(struct file *file, void *fh,
+		struct v4l2_cropcap *cropcap)
+{
+	struct mxc_vout_output *vout = fh;
+
+	if (cropcap->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return -EINVAL;
+
+	cropcap->bounds = vout->crop_bounds;
+	cropcap->defrect = vout->crop_bounds;
+
+	return 0;
+}
+
+static int mxc_vidioc_g_crop(struct file *file, void *fh,
+				struct v4l2_crop *crop)
+{
+	struct mxc_vout_output *vout = fh;
+
+	if (crop->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return -EINVAL;
+
+	if (vout->disp_support_windows) {
+		crop->c.left = vout->win_pos.x;
+		crop->c.top = vout->win_pos.y;
+		crop->c.width = vout->task.output.width;
+		crop->c.height = vout->task.output.height;
+	} else {
+		if (vout->task.output.crop.w && vout->task.output.crop.h) {
+			crop->c.left = vout->task.output.crop.pos.x;
+			crop->c.top = vout->task.output.crop.pos.y;
+			crop->c.width = vout->task.output.crop.w;
+			crop->c.height = vout->task.output.crop.h;
+		} else {
+			crop->c.left = 0;
+			crop->c.top = 0;
+			crop->c.width = vout->task.output.width;
+			crop->c.height = vout->task.output.height;
+		}
+	}
+
+	return 0;
+}
+
+static int mxc_vidioc_s_crop(struct file *file, void *fh,
+				const struct v4l2_crop *crop)
+{
+	struct mxc_vout_output *vout = fh, *pre_vout;
+	struct v4l2_rect *b = &vout->crop_bounds;
+	struct v4l2_crop fix_up_crop;
+	int ret = 0;
+
+	memcpy(&fix_up_crop, crop, sizeof(*crop));
+
+	if (crop->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return -EINVAL;
+
+	if (crop->c.width < 0 || crop->c.height < 0)
+		return -EINVAL;
+
+	if (crop->c.width == 0)
+		fix_up_crop.c.width = b->width - b->left;
+	if (crop->c.height == 0)
+		fix_up_crop.c.height = b->height - b->top;
+
+	if (crop->c.top < b->top)
+		fix_up_crop.c.top = b->top;
+	if (crop->c.top >= b->top + b->height)
+		fix_up_crop.c.top = b->top + b->height - 1;
+	if (crop->c.height > b->top - crop->c.top + b->height)
+		fix_up_crop.c.height =
+			b->top - fix_up_crop.c.top + b->height;
+
+	if (crop->c.left < b->left)
+		fix_up_crop.c.left = b->left;
+	if (crop->c.left >= b->left + b->width)
+		fix_up_crop.c.left = b->left + b->width - 1;
+	if (crop->c.width > b->left - crop->c.left + b->width)
+		fix_up_crop.c.width =
+			b->left - fix_up_crop.c.left + b->width;
+
+	/* stride line limitation */
+	fix_up_crop.c.height -= fix_up_crop.c.height % 8;
+	fix_up_crop.c.width -= fix_up_crop.c.width % 8;
+	if ((fix_up_crop.c.width <= 0) || (fix_up_crop.c.height <= 0) ||
+		((fix_up_crop.c.left + fix_up_crop.c.width) >
+		 (b->left + b->width)) ||
+		((fix_up_crop.c.top + fix_up_crop.c.height) >
+		 (b->top + b->height))) {
+		v4l2_err(vout->vfd->v4l2_dev, "s_crop err: %d, %d, %d, %d",
+			fix_up_crop.c.left, fix_up_crop.c.top,
+			fix_up_crop.c.width, fix_up_crop.c.height);
+		return -EINVAL;
+	}
+
+	/* the same setting, return */
+	if (vout->disp_support_windows) {
+		if ((vout->win_pos.x == fix_up_crop.c.left) &&
+			(vout->win_pos.y == fix_up_crop.c.top) &&
+			(vout->task.output.crop.w == fix_up_crop.c.width) &&
+			(vout->task.output.crop.h == fix_up_crop.c.height))
+			return 0;
+	} else {
+		if ((vout->task.output.crop.pos.x == fix_up_crop.c.left) &&
+			(vout->task.output.crop.pos.y == fix_up_crop.c.top) &&
+			(vout->task.output.crop.w == fix_up_crop.c.width) &&
+			(vout->task.output.crop.h == fix_up_crop.c.height))
+			return 0;
+	}
+
+	pre_vout = vmalloc(sizeof(*pre_vout));
+	if (!pre_vout)
+		return -ENOMEM;
+
+	/* wait current work finish */
+	if (vout->vbq.streaming)
+		flush_workqueue(vout->v4l_wq);
+
+	mutex_lock(&vout->task_lock);
+
+	memcpy(pre_vout, vout, sizeof(*vout));
+
+	if (vout->disp_support_windows) {
+		vout->task.output.crop.pos.x = 0;
+		vout->task.output.crop.pos.y = 0;
+		vout->win_pos.x = fix_up_crop.c.left;
+		vout->win_pos.y = fix_up_crop.c.top;
+		vout->task.output.width = fix_up_crop.c.width;
+		vout->task.output.height = fix_up_crop.c.height;
+	} else {
+		vout->task.output.crop.pos.x = fix_up_crop.c.left;
+		vout->task.output.crop.pos.y = fix_up_crop.c.top;
+	}
+
+	vout->task.output.crop.w = fix_up_crop.c.width;
+	vout->task.output.crop.h = fix_up_crop.c.height;
+
+	/*
+	 * must S_CROP before S_FMT, for fist time S_CROP, will not check
+	 * ipu task, it will check in S_FMT, after S_FMT, S_CROP should
+	 * check ipu task too.
+	 */
+	if (vout->fmt_init) {
+		memcpy(&vout->task.input.crop, &vout->in_rect,
+			sizeof(vout->in_rect));
+		ret = mxc_vout_try_task(vout);
+		if (ret < 0) {
+			v4l2_err(vout->vfd->v4l2_dev,
+					"vout check task failed\n");
+			memcpy(vout, pre_vout, sizeof(*vout));
+			goto done;
+		}
+
+		if (mxc_vout_need_fb_reconfig(vout, pre_vout)) {
+			ret = config_disp_output(vout);
+			if (ret < 0)
+				v4l2_err(vout->vfd->v4l2_dev,
+					"Config display output failed\n");
+		}
+	}
+
+done:
+	vfree(pre_vout);
+	mutex_unlock(&vout->task_lock);
+
+	return ret;
+}
+
+static int mxc_vidioc_queryctrl(struct file *file, void *fh,
+		struct v4l2_queryctrl *ctrl)
+{
+	int ret = 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ROTATE:
+		ret = v4l2_ctrl_query_fill(ctrl, 0, 270, 90, 0);
+		break;
+	case V4L2_CID_VFLIP:
+		ret = v4l2_ctrl_query_fill(ctrl, 0, 1, 1, 0);
+		break;
+	case V4L2_CID_HFLIP:
+		ret = v4l2_ctrl_query_fill(ctrl, 0, 1, 1, 0);
+		break;
+	case V4L2_CID_MXC_MOTION:
+		ret = v4l2_ctrl_query_fill(ctrl, 0, 2, 1, 0);
+		break;
+	default:
+		ctrl->name[0] = '\0';
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static int mxc_vidioc_g_ctrl(struct file *file, void *fh,
+				struct v4l2_control *ctrl)
+{
+	int ret = 0;
+	struct mxc_vout_output *vout = fh;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ROTATE:
+		ctrl->value = vout->ctrl_rotate;
+		break;
+	case V4L2_CID_VFLIP:
+		ctrl->value = vout->ctrl_vflip;
+		break;
+	case V4L2_CID_HFLIP:
+		ctrl->value = vout->ctrl_hflip;
+		break;
+	case V4L2_CID_MXC_MOTION:
+		if (vout->task.input.deinterlace.enable)
+			ctrl->value = vout->task.input.deinterlace.motion;
+		else
+			ctrl->value = 0;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static void setup_task_rotation(struct mxc_vout_output *vout)
+{
+	if (vout->ctrl_rotate == 0) {
+		if (vout->ctrl_vflip && vout->ctrl_hflip)
+			vout->task.output.rotate = IPU_ROTATE_180;
+		else if (vout->ctrl_vflip)
+			vout->task.output.rotate = IPU_ROTATE_VERT_FLIP;
+		else if (vout->ctrl_hflip)
+			vout->task.output.rotate = IPU_ROTATE_HORIZ_FLIP;
+		else
+			vout->task.output.rotate = IPU_ROTATE_NONE;
+	} else if (vout->ctrl_rotate == 90) {
+		if (vout->ctrl_vflip && vout->ctrl_hflip)
+			vout->task.output.rotate = IPU_ROTATE_90_LEFT;
+		else if (vout->ctrl_vflip)
+			vout->task.output.rotate = IPU_ROTATE_90_RIGHT_VFLIP;
+		else if (vout->ctrl_hflip)
+			vout->task.output.rotate = IPU_ROTATE_90_RIGHT_HFLIP;
+		else
+			vout->task.output.rotate = IPU_ROTATE_90_RIGHT;
+	} else if (vout->ctrl_rotate == 180) {
+		if (vout->ctrl_vflip && vout->ctrl_hflip)
+			vout->task.output.rotate = IPU_ROTATE_NONE;
+		else if (vout->ctrl_vflip)
+			vout->task.output.rotate = IPU_ROTATE_HORIZ_FLIP;
+		else if (vout->ctrl_hflip)
+			vout->task.output.rotate = IPU_ROTATE_VERT_FLIP;
+		else
+			vout->task.output.rotate = IPU_ROTATE_180;
+	} else if (vout->ctrl_rotate == 270) {
+		if (vout->ctrl_vflip && vout->ctrl_hflip)
+			vout->task.output.rotate = IPU_ROTATE_90_RIGHT;
+		else if (vout->ctrl_vflip)
+			vout->task.output.rotate = IPU_ROTATE_90_RIGHT_HFLIP;
+		else if (vout->ctrl_hflip)
+			vout->task.output.rotate = IPU_ROTATE_90_RIGHT_VFLIP;
+		else
+			vout->task.output.rotate = IPU_ROTATE_90_LEFT;
+	}
+}
+
+static int mxc_vidioc_s_ctrl(struct file *file, void *fh,
+				struct v4l2_control *ctrl)
+{
+	int ret = 0;
+	struct mxc_vout_output *vout = fh, *pre_vout;
+
+	pre_vout = vmalloc(sizeof(*pre_vout));
+	if (!pre_vout)
+		return -ENOMEM;
+
+	/* wait current work finish */
+	if (vout->vbq.streaming)
+		flush_workqueue(vout->v4l_wq);
+
+	mutex_lock(&vout->task_lock);
+
+	memcpy(pre_vout, vout, sizeof(*vout));
+
+	switch (ctrl->id) {
+	case V4L2_CID_ROTATE:
+	{
+		vout->ctrl_rotate = (ctrl->value/90) * 90;
+		if (vout->ctrl_rotate > 270)
+			vout->ctrl_rotate = 270;
+		setup_task_rotation(vout);
+		break;
+	}
+	case V4L2_CID_VFLIP:
+	{
+		vout->ctrl_vflip = ctrl->value;
+		setup_task_rotation(vout);
+		break;
+	}
+	case V4L2_CID_HFLIP:
+	{
+		vout->ctrl_hflip = ctrl->value;
+		setup_task_rotation(vout);
+		break;
+	}
+	case V4L2_CID_MXC_MOTION:
+	{
+		vout->task.input.deinterlace.motion = ctrl->value;
+		break;
+	}
+	default:
+		ret = -EINVAL;
+		goto done;
+	}
+
+	if (vout->fmt_init) {
+		memcpy(&vout->task.input.crop, &vout->in_rect,
+				sizeof(vout->in_rect));
+		ret = mxc_vout_try_task(vout);
+		if (ret < 0) {
+			v4l2_err(vout->vfd->v4l2_dev,
+					"vout check task failed\n");
+			memcpy(vout, pre_vout, sizeof(*vout));
+			goto done;
+		}
+
+		if (mxc_vout_need_fb_reconfig(vout, pre_vout)) {
+			ret = config_disp_output(vout);
+			if (ret < 0)
+				v4l2_err(vout->vfd->v4l2_dev,
+					"Config display output failed\n");
+		}
+	}
+
+done:
+	vfree(pre_vout);
+	mutex_unlock(&vout->task_lock);
+
+	return ret;
+}
+
+static int mxc_vidioc_reqbufs(struct file *file, void *fh,
+			struct v4l2_requestbuffers *req)
+{
+	int ret = 0;
+	struct mxc_vout_output *vout = fh;
+	struct videobuf_queue *q = &vout->vbq;
+
+	if (req->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return -EINVAL;
+
+	/* should not be here after streaming, videobuf_reqbufs will control */
+	mutex_lock(&vout->task_lock);
+
+	ret = videobuf_reqbufs(q, req);
+
+	mutex_unlock(&vout->task_lock);
+	return ret;
+}
+
+static int mxc_vidioc_querybuf(struct file *file, void *fh,
+			struct v4l2_buffer *b)
+{
+	int ret;
+	struct mxc_vout_output *vout = fh;
+
+	ret = videobuf_querybuf(&vout->vbq, b);
+	if (!ret) {
+		/* return physical address */
+		struct videobuf_buffer *vb = vout->vbq.bufs[b->index];
+		if (b->flags & V4L2_BUF_FLAG_MAPPED)
+			b->m.offset = videobuf_to_dma_contig(vb);
+	}
+
+	return ret;
+}
+
+static int mxc_vidioc_qbuf(struct file *file, void *fh,
+			struct v4l2_buffer *buffer)
+{
+	struct mxc_vout_output *vout = fh;
+
+	return videobuf_qbuf(&vout->vbq, buffer);
+}
+
+static int mxc_vidioc_dqbuf(struct file *file, void *fh, struct v4l2_buffer *b)
+{
+	struct mxc_vout_output *vout = fh;
+
+	if (!vout->vbq.streaming)
+		return -EINVAL;
+
+	if (file->f_flags & O_NONBLOCK)
+		return videobuf_dqbuf(&vout->vbq, (struct v4l2_buffer *)b, 1);
+	else
+		return videobuf_dqbuf(&vout->vbq, (struct v4l2_buffer *)b, 0);
+}
+
+static int set_window_position(struct mxc_vout_output *vout,
+				struct mxcfb_pos *pos)
+{
+	struct fb_info *fbi = vout->fbi;
+	mm_segment_t old_fs;
+	int ret = 0;
+
+	if (vout->disp_support_windows) {
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);
+		ret = fbi->fbops->fb_ioctl(fbi, MXCFB_SET_OVERLAY_POS,
+				(unsigned long)pos);
+		set_fs(old_fs);
+	}
+
+	return ret;
+}
+
+static int config_disp_output(struct mxc_vout_output *vout)
+{
+	struct dma_mem *buf = NULL;
+	struct fb_info *fbi = vout->fbi;
+	struct fb_var_screeninfo var;
+	struct mxcfb_pos pos;
+	int i, fb_num, ret;
+	u32 fb_base;
+	u32 size;
+	u32 display_buf_size;
+	u32 *pixel = NULL;
+	u32 color;
+	int j;
+
+	memcpy(&var, &fbi->var, sizeof(var));
+	fb_base = fbi->fix.smem_start;
+
+	var.xres = vout->task.output.width;
+	var.yres = vout->task.output.height;
+	if (vout->linear_bypass_pp || vout->tiled_bypass_pp) {
+		fb_num = 1;
+		/* input crop */
+		if (vout->task.input.width > vout->task.output.width)
+			var.xres_virtual = vout->task.input.width;
+		else
+			var.xres_virtual = var.xres;
+		if (vout->task.input.height > vout->task.output.height)
+			var.yres_virtual = vout->task.input.height;
+		else
+			var.yres_virtual = var.yres;
+		var.rotate = vout->task.output.rotate;
+		var.vmode |= FB_VMODE_YWRAP;
+	} else {
+		fb_num = FB_BUFS;
+		var.xres_virtual = var.xres;
+		var.yres_virtual = fb_num * var.yres;
+		var.vmode &= ~FB_VMODE_YWRAP;
+	}
+	var.bits_per_pixel = fmt_to_bpp(vout->task.output.format);
+	var.nonstd = vout->task.output.format;
+
+	v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+			"set display fb to %d %d\n",
+			var.xres, var.yres);
+
+	/*
+	 * To setup the overlay fb from scratch without
+	 * the last time overlay fb position or resolution's
+	 * impact, we take the following steps:
+	 * - blank fb
+	 * - set fb position to the starting point
+	 * - reconfigure fb
+	 * - set fb position to a specific point
+	 * - unblank fb
+	 * This procedure applies to non-overlay fbs as well.
+	 */
+	console_lock();
+	fbi->flags |= FBINFO_MISC_USEREVENT;
+	fb_blank(fbi, FB_BLANK_POWERDOWN);
+	fbi->flags &= ~FBINFO_MISC_USEREVENT;
+	console_unlock();
+
+	pos.x = 0;
+	pos.y = 0;
+	ret = set_window_position(vout, &pos);
+	if (ret < 0) {
+		v4l2_err(vout->vfd->v4l2_dev, "failed to set fb position "
+			"to starting point\n");
+		return ret;
+	}
+
+	/* Init display channel through fb API */
+	var.yoffset = 0;
+	var.activate |= FB_ACTIVATE_FORCE;
+	console_lock();
+	fbi->flags |= FBINFO_MISC_USEREVENT;
+	ret = fb_set_var(fbi, &var);
+	fbi->flags &= ~FBINFO_MISC_USEREVENT;
+	console_unlock();
+	if (ret < 0) {
+		v4l2_err(vout->vfd->v4l2_dev,
+				"ERR:%s fb_set_var ret:%d\n", __func__, ret);
+		return ret;
+	}
+
+	ret = set_window_position(vout, &vout->win_pos);
+	if (ret < 0) {
+		v4l2_err(vout->vfd->v4l2_dev, "failed to set fb position\n");
+		return ret;
+	}
+
+	if (vout->linear_bypass_pp || vout->tiled_bypass_pp)
+		display_buf_size = fbi->fix.line_length * fbi->var.yres_virtual;
+	else
+		display_buf_size = fbi->fix.line_length * fbi->var.yres;
+	for (i = 0; i < fb_num; i++)
+		vout->disp_bufs[i] = fbi->fix.smem_start + i * display_buf_size;
+	if (vout->tiled_bypass_pp) {
+		size = PAGE_ALIGN(vout->task.input.crop.w *
+					vout->task.input.crop.h *
+					fmt_to_bpp(vout->task.output.format)/8);
+		if (size > vout->vdoa_output[0].size) {
+			for (i = 0; i < VDOA_FB_BUFS; i++) {
+				buf = &vout->vdoa_output[i];
+				if (buf->vaddr)
+					free_dma_buf(vout, buf);
+				buf->size = size;
+				ret = alloc_dma_buf(vout, buf);
+				if (ret < 0)
+					goto err;
+			}
+		}
+		for (i = fb_num; i < (fb_num + VDOA_FB_BUFS); i++)
+			vout->disp_bufs[i] =
+				vout->vdoa_output[i - fb_num].paddr;
+	}
+	vout->fb_smem_len = fbi->fix.smem_len;
+	vout->fb_smem_start = fbi->fix.smem_start;
+	if (fb_base != fbi->fix.smem_start) {
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+			"realloc fb mem size:0x%x@0x%lx,old paddr @0x%x\n",
+			fbi->fix.smem_len, fbi->fix.smem_start, fb_base);
+	}
+
+	/* fill black when video config changed */
+	color = colorspaceofpixel(vout->task.output.format) == YUV_CS ?
+			UYVY_BLACK : RGB_BLACK;
+	if (IS_PLANAR_PIXEL_FORMAT(vout->task.output.format)) {
+		size = display_buf_size * 8 /
+			fmt_to_bpp(vout->task.output.format);
+		memset(fbi->screen_base, Y_BLACK, size);
+		memset(fbi->screen_base + size, UV_BLACK,
+				display_buf_size - size);
+	} else {
+		pixel = (u32 *)fbi->screen_base;
+		for (i = 0; i < (display_buf_size >> 2); i++)
+			*pixel++ = color;
+	}
+	console_lock();
+	fbi->flags |= FBINFO_MISC_USEREVENT;
+	ret = fb_blank(fbi, FB_BLANK_UNBLANK);
+	fbi->flags &= ~FBINFO_MISC_USEREVENT;
+	console_unlock();
+	vout->release = false;
+
+	return ret;
+err:
+	for (j = i - 1; j >= 0; j--) {
+		buf = &vout->vdoa_output[j];
+		if (buf->vaddr)
+			free_dma_buf(vout, buf);
+	}
+	return ret;
+}
+
+static inline void wait_for_vsync(struct mxc_vout_output *vout)
+{
+	struct fb_info *fbi = vout->fbi;
+	mm_segment_t old_fs;
+
+	if (fbi->fbops->fb_ioctl) {
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);
+		fbi->fbops->fb_ioctl(fbi, MXCFB_WAIT_FOR_VSYNC,
+				(unsigned long)NULL);
+		set_fs(old_fs);
+	}
+
+	return;
+}
+
+static void release_disp_output(struct mxc_vout_output *vout)
+{
+	struct fb_info *fbi = vout->fbi;
+	struct mxcfb_pos pos;
+
+	if (vout->release)
+		return;
+	console_lock();
+	fbi->flags |= FBINFO_MISC_USEREVENT;
+	fb_blank(fbi, FB_BLANK_POWERDOWN);
+	fbi->flags &= ~FBINFO_MISC_USEREVENT;
+	console_unlock();
+
+	/* restore pos to 0,0 avoid fb pan display hang? */
+	pos.x = 0;
+	pos.y = 0;
+	set_window_position(vout, &pos);
+
+	if (get_ipu_channel(fbi) == MEM_BG_SYNC) {
+		console_lock();
+		fbi->fix.smem_start = vout->disp_bufs[0];
+		fbi->flags |= FBINFO_MISC_USEREVENT;
+		fb_blank(fbi, FB_BLANK_UNBLANK);
+		fbi->flags &= ~FBINFO_MISC_USEREVENT;
+		console_unlock();
+
+	}
+
+	vout->release = true;
+}
+
+static int mxc_vidioc_streamon(struct file *file, void *fh,
+				enum v4l2_buf_type i)
+{
+	struct mxc_vout_output *vout = fh;
+	struct videobuf_queue *q = &vout->vbq;
+	int ret;
+
+	if (q->streaming) {
+		v4l2_err(vout->vfd->v4l2_dev,
+				"video output already run\n");
+		ret = -EBUSY;
+		goto done;
+	}
+
+	if (deinterlace_3_field(vout) && list_is_singular(&q->stream)) {
+		v4l2_err(vout->vfd->v4l2_dev,
+			"deinterlacing: need queue 2 frame before streamon\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	ret = config_disp_output(vout);
+	if (ret < 0) {
+		v4l2_err(vout->vfd->v4l2_dev,
+				"Config display output failed\n");
+		goto done;
+	}
+
+	hrtimer_init(&vout->timer, CLOCK_REALTIME, HRTIMER_MODE_ABS);
+	vout->timer.function = mxc_vout_timer_handler;
+	vout->timer_stop = true;
+
+	vout->start_ktime = hrtimer_cb_get_time(&vout->timer);
+
+	vout->pre1_vb = NULL;
+	vout->pre2_vb = NULL;
+
+	ret = videobuf_streamon(q);
+done:
+	return ret;
+}
+
+static int mxc_vidioc_streamoff(struct file *file, void *fh,
+				enum v4l2_buf_type i)
+{
+	struct mxc_vout_output *vout = fh;
+	struct videobuf_queue *q = &vout->vbq;
+	int ret = 0;
+
+	if (q->streaming) {
+		flush_workqueue(vout->v4l_wq);
+
+		hrtimer_cancel(&vout->timer);
+
+		/*
+		 * Wait for 2 vsyncs to make sure
+		 * frames are drained on triple
+		 * buffer.
+		 */
+		wait_for_vsync(vout);
+		wait_for_vsync(vout);
+
+		release_disp_output(vout);
+
+		ret = videobuf_streamoff(&vout->vbq);
+	}
+	INIT_LIST_HEAD(&vout->queue_list);
+	INIT_LIST_HEAD(&vout->active_list);
+
+	return ret;
+}
+
+static const struct v4l2_ioctl_ops mxc_vout_ioctl_ops = {
+	.vidioc_querycap			= mxc_vidioc_querycap,
+	.vidioc_enum_fmt_vid_out		= mxc_vidioc_enum_fmt_vid_out,
+	.vidioc_g_fmt_vid_out			= mxc_vidioc_g_fmt_vid_out,
+	.vidioc_s_fmt_vid_out			= mxc_vidioc_s_fmt_vid_out,
+	.vidioc_cropcap				= mxc_vidioc_cropcap,
+	.vidioc_g_crop				= mxc_vidioc_g_crop,
+	.vidioc_s_crop				= mxc_vidioc_s_crop,
+	.vidioc_queryctrl			= mxc_vidioc_queryctrl,
+	.vidioc_g_ctrl				= mxc_vidioc_g_ctrl,
+	.vidioc_s_ctrl				= mxc_vidioc_s_ctrl,
+	.vidioc_reqbufs				= mxc_vidioc_reqbufs,
+	.vidioc_querybuf			= mxc_vidioc_querybuf,
+	.vidioc_qbuf				= mxc_vidioc_qbuf,
+	.vidioc_dqbuf				= mxc_vidioc_dqbuf,
+	.vidioc_streamon			= mxc_vidioc_streamon,
+	.vidioc_streamoff			= mxc_vidioc_streamoff,
+};
+
+static const struct v4l2_file_operations mxc_vout_fops = {
+	.owner		= THIS_MODULE,
+	.unlocked_ioctl	= video_ioctl2,
+	.mmap		= mxc_vout_mmap,
+	.open		= mxc_vout_open,
+	.release	= mxc_vout_release,
+};
+
+static struct video_device mxc_vout_template = {
+	.name		= "MXC Video Output",
+	.fops           = &mxc_vout_fops,
+	.ioctl_ops	= &mxc_vout_ioctl_ops,
+	.release	= video_device_release,
+};
+
+static struct videobuf_queue_ops mxc_vout_vbq_ops = {
+	.buf_setup = mxc_vout_buffer_setup,
+	.buf_prepare = mxc_vout_buffer_prepare,
+	.buf_release = mxc_vout_buffer_release,
+	.buf_queue = mxc_vout_buffer_queue,
+};
+
+static void mxc_vout_free_output(struct mxc_vout_dev *dev)
+{
+	int i;
+	int j;
+	struct mxc_vout_output *vout;
+	struct video_device *vfd;
+
+	for (i = 0; i < dev->out_num; i++) {
+		vout = dev->out[i];
+		vfd = vout->vfd;
+		if (vout->vdoa_work.vaddr)
+			free_dma_buf(vout, &vout->vdoa_work);
+		for (j = 0; j < VDOA_FB_BUFS; j++) {
+			if (vout->vdoa_output[j].vaddr)
+				free_dma_buf(vout, &vout->vdoa_output[j]);
+		}
+		if (vfd) {
+			if (!video_is_registered(vfd))
+				video_device_release(vfd);
+			else
+				video_unregister_device(vfd);
+		}
+		kfree(vout);
+	}
+}
+
+static int mxc_vout_setup_output(struct mxc_vout_dev *dev)
+{
+	struct videobuf_queue *q;
+	struct fb_info *fbi;
+	struct mxc_vout_output *vout;
+	int i, ret = 0;
+
+	update_display_setting();
+
+	/* all output/overlay based on fb */
+	for (i = 0; i < num_registered_fb; i++) {
+		fbi = registered_fb[i];
+
+		vout = kzalloc(sizeof(struct mxc_vout_output), GFP_KERNEL);
+		if (!vout) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		dev->out[dev->out_num] = vout;
+		dev->out_num++;
+
+		vout->fbi = fbi;
+		vout->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+		vout->vfd = video_device_alloc();
+		if (!vout->vfd) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		*vout->vfd = mxc_vout_template;
+		vout->vfd->dev_debug = debug;
+		vout->vfd->v4l2_dev = &dev->v4l2_dev;
+		vout->vfd->lock = &vout->mutex;
+		vout->vfd->vfl_dir = VFL_DIR_TX;
+
+		mutex_init(&vout->mutex);
+		mutex_init(&vout->task_lock);
+
+		strlcpy(vout->vfd->name, fbi->fix.id, sizeof(vout->vfd->name));
+
+		video_set_drvdata(vout->vfd, vout);
+
+		if (video_register_device(vout->vfd,
+			VFL_TYPE_GRABBER, video_nr + i) < 0) {
+			ret = -ENODEV;
+			break;
+		}
+
+		q = &vout->vbq;
+		q->dev = dev->dev;
+		spin_lock_init(&vout->vbq_lock);
+		videobuf_queue_dma_contig_init(q, &mxc_vout_vbq_ops, q->dev,
+				&vout->vbq_lock, vout->type, V4L2_FIELD_NONE,
+				sizeof(struct videobuf_buffer), vout, NULL);
+
+		v4l2_info(vout->vfd->v4l2_dev, "V4L2 device registered as %s\n",
+				video_device_node_name(vout->vfd));
+
+	}
+
+	return ret;
+}
+
+static int mxc_vout_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct mxc_vout_dev *dev;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	dev->dev = &pdev->dev;
+	dev->dev->dma_mask = kmalloc(sizeof(*dev->dev->dma_mask), GFP_KERNEL);
+	*dev->dev->dma_mask = DMA_BIT_MASK(32);
+	dev->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+
+	ret = v4l2_device_register(dev->dev, &dev->v4l2_dev);
+	if (ret) {
+		dev_err(dev->dev, "v4l2_device_register failed\n");
+		goto free_dev;
+	}
+
+	ret = mxc_vout_setup_output(dev);
+	if (ret < 0)
+		goto rel_vdev;
+
+	return 0;
+
+rel_vdev:
+	mxc_vout_free_output(dev);
+	v4l2_device_unregister(&dev->v4l2_dev);
+free_dev:
+	kfree(dev);
+	return ret;
+}
+
+static int mxc_vout_remove(struct platform_device *pdev)
+{
+	struct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);
+	struct mxc_vout_dev *dev = container_of(v4l2_dev, struct
+			mxc_vout_dev, v4l2_dev);
+
+	mxc_vout_free_output(dev);
+	v4l2_device_unregister(v4l2_dev);
+	kfree(dev);
+	return 0;
+}
+
+static const struct of_device_id mxc_v4l2_dt_ids[] = {
+	{ .compatible = "fsl,mxc_v4l2_output", },
+	{ /* sentinel */ }
+};
+
+static struct platform_driver mxc_vout_driver = {
+	.driver = {
+		.name = "mxc_v4l2_output",
+		.of_match_table = mxc_v4l2_dt_ids,
+	},
+	.probe = mxc_vout_probe,
+	.remove = mxc_vout_remove,
+};
+
+static int __init mxc_vout_init(void)
+{
+	if (platform_driver_register(&mxc_vout_driver) != 0) {
+		printk(KERN_ERR VOUT_NAME ":Could not register Video driver\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void mxc_vout_cleanup(void)
+{
+	platform_driver_unregister(&mxc_vout_driver);
+}
+
+module_init(mxc_vout_init);
+module_exit(mxc_vout_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("V4L2-driver for MXC video output");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/mxc_v4l2.h b/include/linux/mxc_v4l2.h
new file mode 100644
index 0000000..e05bd04
--- /dev/null
+++ b/include/linux/mxc_v4l2.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @file linux/mxc_v4l2.h
+ *
+ * @brief MXC V4L2 private header file
+ *
+ * @ingroup MXC V4L2
+ */
+
+#ifndef __LINUX_MXC_V4L2_H__
+#define __LINUX_MXC_V4L2_H__
+
+#include <uapi/linux/mxc_v4l2.h>
+
+#endif
diff --git a/include/uapi/linux/Kbuild b/include/uapi/linux/Kbuild
index ca1b8aa1..e77dc60 100644
--- a/include/uapi/linux/Kbuild
+++ b/include/uapi/linux/Kbuild
@@ -269,6 +269,7 @@ header-y += msdos_fs.h
 header-y += msg.h
 header-y += mtio.h
 header-y += mxcfb.h
+header-y += mxc_v4l2.h
 header-y += nbd.h
 header-y += ncp_fs.h
 header-y += ncp.h
diff --git a/include/uapi/linux/mxc_v4l2.h b/include/uapi/linux/mxc_v4l2.h
new file mode 100644
index 0000000..49345fe
--- /dev/null
+++ b/include/uapi/linux/mxc_v4l2.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @file uapi/linux/mxc_v4l2.h
+ *
+ * @brief MXC V4L2 private header file
+ *
+ * @ingroup MXC V4L2
+ */
+
+#ifndef __ASM_ARCH_MXC_V4L2_H__
+#define __ASM_ARCH_MXC_V4L2_H__
+
+/*
+ * For IPUv1 and IPUv3, V4L2_CID_MXC_ROT means encoder ioctl ID.
+ * And V4L2_CID_MXC_VF_ROT is viewfinder ioctl ID only for IPUv1 and IPUv3.
+ */
+#define V4L2_CID_MXC_ROT		(V4L2_CID_PRIVATE_BASE + 0)
+#define V4L2_CID_MXC_FLASH		(V4L2_CID_PRIVATE_BASE + 1)
+#define V4L2_CID_MXC_VF_ROT		(V4L2_CID_PRIVATE_BASE + 2)
+#define V4L2_CID_MXC_MOTION		(V4L2_CID_PRIVATE_BASE + 3)
+#define V4L2_CID_MXC_SWITCH_CAM		(V4L2_CID_PRIVATE_BASE + 6)
+
+#define V4L2_MXC_ROTATE_NONE			0
+#define V4L2_MXC_ROTATE_VERT_FLIP		1
+#define V4L2_MXC_ROTATE_HORIZ_FLIP		2
+#define V4L2_MXC_ROTATE_180			3
+#define V4L2_MXC_ROTATE_90_RIGHT		4
+#define V4L2_MXC_ROTATE_90_RIGHT_VFLIP		5
+#define V4L2_MXC_ROTATE_90_RIGHT_HFLIP		6
+#define V4L2_MXC_ROTATE_90_LEFT			7
+
+struct v4l2_mxc_offset {
+	uint32_t u_offset;
+	uint32_t v_offset;
+};
+
+#endif
-- 
1.7.5.4

