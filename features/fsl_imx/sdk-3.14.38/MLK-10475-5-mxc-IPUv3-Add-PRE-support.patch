From 9183aac3fc40286adda8e987c1005c90a483cfd9 Mon Sep 17 00:00:00 2001
From: Liu Ying <Ying.Liu@freescale.com>
Date: Wed, 4 Mar 2015 17:42:17 +0800
Subject: [PATCH 0905/1594] MLK-10475-5 mxc IPUv3: Add PRE support

commit 64398a3c3b2e6c9aa89208f2c3fafa3db6bfc0de from
git://git.freescale.com/imx/linux-2.6-imx.git

This patch adds PRE support.

Signed-off-by: Liu Ying <Ying.Liu@freescale.com>
---
 drivers/mxc/ipu3/Kconfig    |    9 +
 drivers/mxc/ipu3/Makefile   |    1 +
 drivers/mxc/ipu3/pre-regs.h |  492 ++++++++++++++++++++++
 drivers/mxc/ipu3/pre.c      |  957 +++++++++++++++++++++++++++++++++++++++++++
 include/linux/ipu-v3-pre.h  |  137 ++++++
 5 files changed, 1596 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mxc/ipu3/pre-regs.h
 create mode 100644 drivers/mxc/ipu3/pre.c
 create mode 100644 include/linux/ipu-v3-pre.h

diff --git a/drivers/mxc/ipu3/Kconfig b/drivers/mxc/ipu3/Kconfig
index b5e7506..c702efe 100644
--- a/drivers/mxc/ipu3/Kconfig
+++ b/drivers/mxc/ipu3/Kconfig
@@ -10,3 +10,12 @@ config MXC_IPU_V3_PRG
 	  prefetch engine(PRE), snoop the AXI interface for display
 	  refresh requests to memory and modify the request address to
 	  fetch the double buffered row of blocks in OCRAM.
+
+config MXC_IPU_V3_PRE
+	tristate "i.MX IPUv3 prefetch engine"
+	depends on MXC_IPU_V3
+	select MXC_IPU_V3_PRG
+	help
+	  This enables support for the IPUv3 prefetch engine to improve
+	  the system memory performance.  The engine has the capability
+	  to resolve framebuffers in tile pixel format to linear.
diff --git a/drivers/mxc/ipu3/Makefile b/drivers/mxc/ipu3/Makefile
index 0dc4a45..d48f112 100644
--- a/drivers/mxc/ipu3/Makefile
+++ b/drivers/mxc/ipu3/Makefile
@@ -1,6 +1,7 @@
 obj-$(CONFIG_MXC_IPU_V3) = mxc_ipu.o
 
 obj-$(CONFIG_MXC_IPU_V3_PRG) += prg.o
+obj-$(CONFIG_MXC_IPU_V3_PRE) += pre.o
 
 mxc_ipu-objs := ipu_common.o ipu_ic.o ipu_disp.o ipu_capture.o ipu_device.o \
 		ipu_calc_stripes_sizes.o vdoa.o ipu_pixel_clk.o
diff --git a/drivers/mxc/ipu3/pre-regs.h b/drivers/mxc/ipu3/pre-regs.h
new file mode 100644
index 0000000..ee5d424
--- /dev/null
+++ b/drivers/mxc/ipu3/pre-regs.h
@@ -0,0 +1,492 @@
+/*
+ * Freescale PRE Register Definitions
+ *
+ * Copyright 2014-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.6
+ * Template revision: 1.3
+ */
+
+#ifndef __ARCH_ARM___PRE_H
+#define __ARCH_ARM___PRE_H
+
+
+#define HW_PRE_CTRL	(0x00000000)
+#define HW_PRE_CTRL_SET	(0x00000004)
+#define HW_PRE_CTRL_CLR	(0x00000008)
+#define HW_PRE_CTRL_TOG	(0x0000000c)
+
+#define BM_PRE_CTRL_SFTRST 0x80000000
+#define BF_PRE_CTRL_SFTRST(v) \
+	(((v) << 31) & BM_PRE_CTRL_SFTRST)
+#define BM_PRE_CTRL_CLKGATE 0x40000000
+#define BF_PRE_CTRL_CLKGATE(v)  \
+	(((v) << 30) & BM_PRE_CTRL_CLKGATE)
+#define BM_PRE_CTRL_TPR_RESET_SEL 0x20000000
+#define BF_PRE_CTRL_TPR_RESET_SEL(v)  \
+	(((v) << 29) & BM_PRE_CTRL_TPR_RESET_SEL)
+#define BM_PRE_CTRL_EN_REPEAT 0x10000000
+#define BF_PRE_CTRL_EN_REPEAT(v)  \
+	(((v) << 28) & BM_PRE_CTRL_EN_REPEAT)
+#define BP_PRE_CTRL_RSVD2      16
+#define BM_PRE_CTRL_RSVD2 0x0FFF0000
+#define BF_PRE_CTRL_RSVD2(v)  \
+	(((v) << 16) & BM_PRE_CTRL_RSVD2)
+#define BP_PRE_CTRL_RSVD1      12
+#define BM_PRE_CTRL_RSVD1 0x0000F000
+#define BF_PRE_CTRL_RSVD1(v)  \
+	(((v) << 12) & BM_PRE_CTRL_RSVD1)
+#define BM_PRE_CTRL_HANDSHAKE_ABORT_SKIP_EN 0x00000800
+#define BF_PRE_CTRL_HANDSHAKE_ABORT_SKIP_EN(v)  \
+	(((v) << 11) & BM_PRE_CTRL_HANDSHAKE_ABORT_SKIP_EN)
+#define BV_PRE_CTRL_HANDSHAKE_ABORT_SKIP_EN__0 0x0
+#define BV_PRE_CTRL_HANDSHAKE_ABORT_SKIP_EN__1 0x1
+#define BP_PRE_CTRL_HANDSHAKE_LINE_NUM      9
+#define BM_PRE_CTRL_HANDSHAKE_LINE_NUM 0x00000600
+#define BF_PRE_CTRL_HANDSHAKE_LINE_NUM(v)  \
+	(((v) << 9) & BM_PRE_CTRL_HANDSHAKE_LINE_NUM)
+#define BV_PRE_CTRL_HANDSHAKE_LINE_NUM__0 0x0
+#define BV_PRE_CTRL_HANDSHAKE_LINE_NUM__1 0x1
+#define BV_PRE_CTRL_HANDSHAKE_LINE_NUM__2 0x2
+#define BM_PRE_CTRL_HANDSHAKE_EN 0x00000100
+#define BF_PRE_CTRL_HANDSHAKE_EN(v)  \
+	(((v) << 8) & BM_PRE_CTRL_HANDSHAKE_EN)
+#define BV_PRE_CTRL_HANDSHAKE_EN__0 0x0
+#define BV_PRE_CTRL_HANDSHAKE_EN__1 0x1
+#define BM_PRE_CTRL_INTERLACED_FIELD 0x00000080
+#define BF_PRE_CTRL_INTERLACED_FIELD(v)  \
+	(((v) << 7) & BM_PRE_CTRL_INTERLACED_FIELD)
+#define BM_PRE_CTRL_SO 0x00000040
+#define BF_PRE_CTRL_SO(v)  \
+	(((v) << 6) & BM_PRE_CTRL_SO)
+#define BM_PRE_CTRL_VFLIP 0x00000020
+#define BF_PRE_CTRL_VFLIP(v)  \
+	(((v) << 5) & BM_PRE_CTRL_VFLIP)
+#define BM_PRE_CTRL_SDW_UPDATE 0x00000010
+#define BF_PRE_CTRL_SDW_UPDATE(v)  \
+	(((v) << 4) & BM_PRE_CTRL_SDW_UPDATE)
+#define BM_PRE_CTRL_RSVD0 0x00000008
+#define BF_PRE_CTRL_RSVD0(v)  \
+	(((v) << 3) & BM_PRE_CTRL_RSVD0)
+#define BM_PRE_CTRL_BLOCK_16 0x00000004
+#define BF_PRE_CTRL_BLOCK_16(v)  \
+	(((v) << 2) & BM_PRE_CTRL_BLOCK_16)
+#define BV_PRE_CTRL_BLOCK_16__32x4 0x0
+#define BV_PRE_CTRL_BLOCK_16__16x4 0x1
+#define BM_PRE_CTRL_BLOCK_EN 0x00000002
+#define BF_PRE_CTRL_BLOCK_EN(v)  \
+	(((v) << 1) & BM_PRE_CTRL_BLOCK_EN)
+#define BV_PRE_CTRL_BLOCK_EN__0 0x0
+#define BV_PRE_CTRL_BLOCK_EN__1 0x1
+#define BM_PRE_CTRL_ENABLE 0x00000001
+#define BF_PRE_CTRL_ENABLE(v)  \
+	(((v) << 0) & BM_PRE_CTRL_ENABLE)
+
+#define HW_PRE_IRQ_MASK	(0x00000010)
+#define HW_PRE_IRQ_MASK_SET	(0x00000014)
+#define HW_PRE_IRQ_MASK_CLR	(0x00000018)
+#define HW_PRE_IRQ_MASK_TOG	(0x0000001c)
+
+#define BP_PRE_IRQ_MASK_RSVD1      4
+#define BM_PRE_IRQ_MASK_RSVD1 0xFFFFFFF0
+#define BF_PRE_IRQ_MASK_RSVD1(v) \
+	(((v) << 4) & BM_PRE_IRQ_MASK_RSVD1)
+#define BM_PRE_IRQ_MASK_TPR_RD_NUM_BYTES_OVFL_IRQ_EN 0x00000008
+#define BF_PRE_IRQ_MASK_TPR_RD_NUM_BYTES_OVFL_IRQ_EN(v)  \
+	(((v) << 3) & BM_PRE_IRQ_MASK_TPR_RD_NUM_BYTES_OVFL_IRQ_EN)
+#define BM_PRE_IRQ_MASK_HANDSHAKE_ABORT_IRQ_EN 0x00000004
+#define BF_PRE_IRQ_MASK_HANDSHAKE_ABORT_IRQ_EN(v)  \
+	(((v) << 2) & BM_PRE_IRQ_MASK_HANDSHAKE_ABORT_IRQ_EN)
+#define BM_PRE_IRQ_MASK_STORE_IRQ_EN 0x00000002
+#define BF_PRE_IRQ_MASK_STORE_IRQ_EN(v)  \
+	(((v) << 1) & BM_PRE_IRQ_MASK_STORE_IRQ_EN)
+#define BM_PRE_IRQ_MASK_PREFETCH_IRQ_EN 0x00000001
+#define BF_PRE_IRQ_MASK_PREFETCH_IRQ_EN(v)  \
+	(((v) << 0) & BM_PRE_IRQ_MASK_PREFETCH_IRQ_EN)
+
+#define HW_PRE_IRQ	(0x00000020)
+#define HW_PRE_IRQ_SET	(0x00000024)
+#define HW_PRE_IRQ_CLR	(0x00000028)
+#define HW_PRE_IRQ_TOG	(0x0000002c)
+
+#define BP_PRE_IRQ_RSVD1      14
+#define BM_PRE_IRQ_RSVD1 0xFFFFC000
+#define BF_PRE_IRQ_RSVD1(v) \
+	(((v) << 14) & BM_PRE_IRQ_RSVD1)
+#define BP_PRE_IRQ_AXI_ERROR_ID      10
+#define BM_PRE_IRQ_AXI_ERROR_ID 0x00003C00
+#define BF_PRE_IRQ_AXI_ERROR_ID(v)  \
+	(((v) << 10) & BM_PRE_IRQ_AXI_ERROR_ID)
+#define BM_PRE_IRQ_AXI_READ_ERROR 0x00000200
+#define BF_PRE_IRQ_AXI_READ_ERROR(v)  \
+	(((v) << 9) & BM_PRE_IRQ_AXI_READ_ERROR)
+#define BM_PRE_IRQ_AXI_WRITE_ERROR 0x00000100
+#define BF_PRE_IRQ_AXI_WRITE_ERROR(v)  \
+	(((v) << 8) & BM_PRE_IRQ_AXI_WRITE_ERROR)
+#define BP_PRE_IRQ_RSVD0      5
+#define BM_PRE_IRQ_RSVD0 0x000000E0
+#define BF_PRE_IRQ_RSVD0(v)  \
+	(((v) << 5) & BM_PRE_IRQ_RSVD0)
+#define BM_PRE_IRQ_HANDSHAKE_ERROR_IRQ 0x00000010
+#define BF_PRE_IRQ_HANDSHAKE_ERROR_IRQ(v)  \
+	(((v) << 4) & BM_PRE_IRQ_HANDSHAKE_ERROR_IRQ)
+#define BM_PRE_IRQ_TPR_RD_NUM_BYTES_OVFL_IRQ 0x00000008
+#define BF_PRE_IRQ_TPR_RD_NUM_BYTES_OVFL_IRQ(v)  \
+	(((v) << 3) & BM_PRE_IRQ_TPR_RD_NUM_BYTES_OVFL_IRQ)
+#define BM_PRE_IRQ_HANDSHAKE_ABORT_IRQ 0x00000004
+#define BF_PRE_IRQ_HANDSHAKE_ABORT_IRQ(v)  \
+	(((v) << 2) & BM_PRE_IRQ_HANDSHAKE_ABORT_IRQ)
+#define BM_PRE_IRQ_STORE_IRQ 0x00000002
+#define BF_PRE_IRQ_STORE_IRQ(v)  \
+	(((v) << 1) & BM_PRE_IRQ_STORE_IRQ)
+#define BM_PRE_IRQ_PREFETCH_IRQ 0x00000001
+#define BF_PRE_IRQ_PREFETCH_IRQ(v)  \
+	(((v) << 0) & BM_PRE_IRQ_PREFETCH_IRQ)
+
+#define HW_PRE_CUR_BUF	(0x00000030)
+
+#define BP_PRE_CUR_BUF_ADDR      0
+#define BM_PRE_CUR_BUF_ADDR 0xFFFFFFFF
+#define BF_PRE_CUR_BUF_ADDR(v)   (v)
+
+#define HW_PRE_NEXT_BUF	(0x00000040)
+
+#define BP_PRE_NEXT_BUF_ADDR      0
+#define BM_PRE_NEXT_BUF_ADDR 0xFFFFFFFF
+#define BF_PRE_NEXT_BUF_ADDR(v)   (v)
+
+#define HW_PRE_U_BUF_OFFSET	(0x00000050)
+
+#define BP_PRE_U_BUF_OFFSET_RSVD0      25
+#define BM_PRE_U_BUF_OFFSET_RSVD0 0xFE000000
+#define BF_PRE_U_BUF_OFFSET_RSVD0(v) \
+	(((v) << 25) & BM_PRE_U_BUF_OFFSET_RSVD0)
+#define BP_PRE_U_BUF_OFFSET_UBO      0
+#define BM_PRE_U_BUF_OFFSET_UBO 0x01FFFFFF
+#define BF_PRE_U_BUF_OFFSET_UBO(v)  \
+	(((v) << 0) & BM_PRE_U_BUF_OFFSET_UBO)
+
+#define HW_PRE_V_BUF_OFFSET	(0x00000060)
+
+#define BP_PRE_V_BUF_OFFSET_RSVD0      25
+#define BM_PRE_V_BUF_OFFSET_RSVD0 0xFE000000
+#define BF_PRE_V_BUF_OFFSET_RSVD0(v) \
+	(((v) << 25) & BM_PRE_V_BUF_OFFSET_RSVD0)
+#define BP_PRE_V_BUF_OFFSET_VBO      0
+#define BM_PRE_V_BUF_OFFSET_VBO 0x01FFFFFF
+#define BF_PRE_V_BUF_OFFSET_VBO(v)  \
+	(((v) << 0) & BM_PRE_V_BUF_OFFSET_VBO)
+
+#define HW_PRE_TPR_CTRL	(0x00000070)
+#define HW_PRE_TPR_CTRL_SET	(0x00000074)
+#define HW_PRE_TPR_CTRL_CLR	(0x00000078)
+#define HW_PRE_TPR_CTRL_TOG	(0x0000007c)
+
+#define BP_PRE_TPR_CTRL_RSVD      8
+#define BM_PRE_TPR_CTRL_RSVD 0xFFFFFF00
+#define BF_PRE_TPR_CTRL_RSVD(v) \
+	(((v) << 8) & BM_PRE_TPR_CTRL_RSVD)
+#define BP_PRE_TPR_CTRL_TILE_FORMAT      0
+#define BM_PRE_TPR_CTRL_TILE_FORMAT 0x000000FF
+#define BF_PRE_TPR_CTRL_TILE_FORMAT(v)  \
+	(((v) << 0) & BM_PRE_TPR_CTRL_TILE_FORMAT)
+#define BV_PRE_TPR_CTRL_TILE_FORMAT__BYPASS       0x00
+#define BV_PRE_TPR_CTRL_TILE_FORMAT__GPU32_SB_ST  0x10
+#define BV_PRE_TPR_CTRL_TILE_FORMAT__GPU32_SB_SRT 0x50
+#define BV_PRE_TPR_CTRL_TILE_FORMAT__GPU32_ST     0x20
+#define BV_PRE_TPR_CTRL_TILE_FORMAT__GPU32_SRT    0x60
+#define BV_PRE_TPR_CTRL_TILE_FORMAT__GPU32_MST    0xA0
+#define BV_PRE_TPR_CTRL_TILE_FORMAT__GPU32_MSRT   0xE0
+#define BV_PRE_TPR_CTRL_TILE_FORMAT__GPU16_SB_ST  0x11
+#define BV_PRE_TPR_CTRL_TILE_FORMAT__GPU16_SB_SRT 0x51
+#define BV_PRE_TPR_CTRL_TILE_FORMAT__GPU16_ST     0x21
+#define BV_PRE_TPR_CTRL_TILE_FORMAT__GPU16_SRT    0x61
+#define BV_PRE_TPR_CTRL_TILE_FORMAT__GPU16_MST    0xA1
+#define BV_PRE_TPR_CTRL_TILE_FORMAT__GPU16_MSRT   0xE1
+#define BV_PRE_TPR_CTRL_TILE_FORMAT__VPU8_PRO     0x22
+#define BV_PRE_TPR_CTRL_TILE_FORMAT__VPU8_SB_INT  0x13
+
+#define HW_PRE_PREFETCH_ENGINE_CTRL	(0x00000080)
+#define HW_PRE_PREFETCH_ENGINE_CTRL_SET	(0x00000084)
+#define HW_PRE_PREFETCH_ENGINE_CTRL_CLR	(0x00000088)
+#define HW_PRE_PREFETCH_ENGINE_CTRL_TOG	(0x0000008c)
+
+#define BP_PRE_PREFETCH_ENGINE_CTRL_RSVD1      16
+#define BM_PRE_PREFETCH_ENGINE_CTRL_RSVD1 0xFFFF0000
+#define BF_PRE_PREFETCH_ENGINE_CTRL_RSVD1(v) \
+	(((v) << 16) & BM_PRE_PREFETCH_ENGINE_CTRL_RSVD1)
+#define BM_PRE_PREFETCH_ENGINE_CTRL_TPR_COOR_OFFSET_EN 0x00008000
+#define BF_PRE_PREFETCH_ENGINE_CTRL_TPR_COOR_OFFSET_EN(v)  \
+	(((v) << 15) & BM_PRE_PREFETCH_ENGINE_CTRL_TPR_COOR_OFFSET_EN)
+#define BM_PRE_PREFETCH_ENGINE_CTRL_PARTIAL_UV_SWAP 0x00004000
+#define BF_PRE_PREFETCH_ENGINE_CTRL_PARTIAL_UV_SWAP(v)  \
+	(((v) << 14) & BM_PRE_PREFETCH_ENGINE_CTRL_PARTIAL_UV_SWAP)
+#define BM_PRE_PREFETCH_ENGINE_CTRL_CROP_EN 0x00002000
+#define BF_PRE_PREFETCH_ENGINE_CTRL_CROP_EN(v)  \
+	(((v) << 13) & BM_PRE_PREFETCH_ENGINE_CTRL_CROP_EN)
+#define BV_PRE_PREFETCH_ENGINE_CTRL_CROP_EN__0 0x0
+#define BV_PRE_PREFETCH_ENGINE_CTRL_CROP_EN__1 0x1
+#define BM_PRE_PREFETCH_ENGINE_CTRL_FIELD_INVERSE 0x00001000
+#define BF_PRE_PREFETCH_ENGINE_CTRL_FIELD_INVERSE(v)  \
+	(((v) << 12) & BM_PRE_PREFETCH_ENGINE_CTRL_FIELD_INVERSE)
+#define BV_PRE_PREFETCH_ENGINE_CTRL_FIELD_INVERSE__0 0x0
+#define BV_PRE_PREFETCH_ENGINE_CTRL_FIELD_INVERSE__1 0x1
+#define BM_PRE_PREFETCH_ENGINE_CTRL_SHIFT_BYPASS 0x00000800
+#define BF_PRE_PREFETCH_ENGINE_CTRL_SHIFT_BYPASS(v)  \
+	(((v) << 11) & BM_PRE_PREFETCH_ENGINE_CTRL_SHIFT_BYPASS)
+#define BV_PRE_PREFETCH_ENGINE_CTRL_SHIFT_BYPASS__0 0x0
+#define BV_PRE_PREFETCH_ENGINE_CTRL_SHIFT_BYPASS__1 0x1
+#define BP_PRE_PREFETCH_ENGINE_CTRL_INPUT_PIXEL_FORMAT      8
+#define BM_PRE_PREFETCH_ENGINE_CTRL_INPUT_PIXEL_FORMAT 0x00000700
+#define BF_PRE_PREFETCH_ENGINE_CTRL_INPUT_PIXEL_FORMAT(v)  \
+	(((v) << 8) & BM_PRE_PREFETCH_ENGINE_CTRL_INPUT_PIXEL_FORMAT)
+#define BV_PRE_PREFETCH_ENGINE_CTRL_INPUT_PIXEL_FORMAT__0 0x0
+#define BV_PRE_PREFETCH_ENGINE_CTRL_INPUT_PIXEL_FORMAT__1 0x1
+#define BV_PRE_PREFETCH_ENGINE_CTRL_INPUT_PIXEL_FORMAT__2 0x2
+#define BV_PRE_PREFETCH_ENGINE_CTRL_INPUT_PIXEL_FORMAT__3 0x3
+#define BV_PRE_PREFETCH_ENGINE_CTRL_INPUT_PIXEL_FORMAT__4 0x4
+#define BV_PRE_PREFETCH_ENGINE_CTRL_INPUT_PIXEL_FORMAT__5 0x5
+#define BP_PRE_PREFETCH_ENGINE_CTRL_RSVD0      6
+#define BM_PRE_PREFETCH_ENGINE_CTRL_RSVD0 0x000000C0
+#define BF_PRE_PREFETCH_ENGINE_CTRL_RSVD0(v)  \
+	(((v) << 6) & BM_PRE_PREFETCH_ENGINE_CTRL_RSVD0)
+#define BP_PRE_PREFETCH_ENGINE_CTRL_INPUT_ACTIVE_BPP      4
+#define BM_PRE_PREFETCH_ENGINE_CTRL_INPUT_ACTIVE_BPP 0x00000030
+#define BF_PRE_PREFETCH_ENGINE_CTRL_INPUT_ACTIVE_BPP(v)  \
+	(((v) << 4) & BM_PRE_PREFETCH_ENGINE_CTRL_INPUT_ACTIVE_BPP)
+#define BV_PRE_PREFETCH_ENGINE_CTRL_INPUT_ACTIVE_BPP__0 0x0
+#define BV_PRE_PREFETCH_ENGINE_CTRL_INPUT_ACTIVE_BPP__1 0x1
+#define BV_PRE_PREFETCH_ENGINE_CTRL_INPUT_ACTIVE_BPP__2 0x2
+#define BV_PRE_PREFETCH_ENGINE_CTRL_INPUT_ACTIVE_BPP__3 0x3
+#define BP_PRE_PREFETCH_ENGINE_CTRL_RD_NUM_BYTES      1
+#define BM_PRE_PREFETCH_ENGINE_CTRL_RD_NUM_BYTES 0x0000000E
+#define BF_PRE_PREFETCH_ENGINE_CTRL_RD_NUM_BYTES(v)  \
+	(((v) << 1) & BM_PRE_PREFETCH_ENGINE_CTRL_RD_NUM_BYTES)
+#define BV_PRE_PREFETCH_ENGINE_CTRL_RD_NUM_BYTES__8_bytes   0x0
+#define BV_PRE_PREFETCH_ENGINE_CTRL_RD_NUM_BYTES__16_bytes  0x1
+#define BV_PRE_PREFETCH_ENGINE_CTRL_RD_NUM_BYTES__32_bytes  0x2
+#define BV_PRE_PREFETCH_ENGINE_CTRL_RD_NUM_BYTES__64_bytes  0x3
+#define BV_PRE_PREFETCH_ENGINE_CTRL_RD_NUM_BYTES__128_bytes 0x4
+#define BM_PRE_PREFETCH_ENGINE_CTRL_PREFETCH_EN 0x00000001
+#define BF_PRE_PREFETCH_ENGINE_CTRL_PREFETCH_EN(v)  \
+	(((v) << 0) & BM_PRE_PREFETCH_ENGINE_CTRL_PREFETCH_EN)
+#define BV_PRE_PREFETCH_ENGINE_CTRL_PREFETCH_EN__0 0x0
+#define BV_PRE_PREFETCH_ENGINE_CTRL_PREFETCH_EN__1 0x1
+
+#define HW_PRE_PREFETCH_ENGINE_STATUS	(0x00000090)
+
+#define BP_PRE_PREFETCH_ENGINE_STATUS_PREFETCH_BLOCK_Y      16
+#define BM_PRE_PREFETCH_ENGINE_STATUS_PREFETCH_BLOCK_Y 0xFFFF0000
+#define BF_PRE_PREFETCH_ENGINE_STATUS_PREFETCH_BLOCK_Y(v) \
+	(((v) << 16) & BM_PRE_PREFETCH_ENGINE_STATUS_PREFETCH_BLOCK_Y)
+#define BP_PRE_PREFETCH_ENGINE_STATUS_PREFETCH_BLOCK_X      0
+#define BM_PRE_PREFETCH_ENGINE_STATUS_PREFETCH_BLOCK_X 0x0000FFFF
+#define BF_PRE_PREFETCH_ENGINE_STATUS_PREFETCH_BLOCK_X(v)  \
+	(((v) << 0) & BM_PRE_PREFETCH_ENGINE_STATUS_PREFETCH_BLOCK_X)
+
+#define HW_PRE_PREFETCH_ENGINE_INPUT_SIZE	(0x000000a0)
+
+#define BP_PRE_PREFETCH_ENGINE_INPUT_SIZE_INPUT_HEIGHT      16
+#define BM_PRE_PREFETCH_ENGINE_INPUT_SIZE_INPUT_HEIGHT 0xFFFF0000
+#define BF_PRE_PREFETCH_ENGINE_INPUT_SIZE_INPUT_HEIGHT(v) \
+	(((v) << 16) & BM_PRE_PREFETCH_ENGINE_INPUT_SIZE_INPUT_HEIGHT)
+#define BP_PRE_PREFETCH_ENGINE_INPUT_SIZE_INPUT_WIDTH      0
+#define BM_PRE_PREFETCH_ENGINE_INPUT_SIZE_INPUT_WIDTH 0x0000FFFF
+#define BF_PRE_PREFETCH_ENGINE_INPUT_SIZE_INPUT_WIDTH(v)  \
+	(((v) << 0) & BM_PRE_PREFETCH_ENGINE_INPUT_SIZE_INPUT_WIDTH)
+
+#define HW_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_ULC	(0x000000b0)
+
+#define BP_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_ULC_OUTPUT_SIZE_ULC_Y      16
+#define BM_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_ULC_OUTPUT_SIZE_ULC_Y 0xFFFF0000
+#define BF_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_ULC_OUTPUT_SIZE_ULC_Y(v) \
+	(((v) << 16) & BM_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_ULC_OUTPUT_SIZE_ULC_Y)
+#define BP_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_ULC_OUTPUT_SIZE_ULC_X      0
+#define BM_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_ULC_OUTPUT_SIZE_ULC_X 0x0000FFFF
+#define BF_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_ULC_OUTPUT_SIZE_ULC_X(v)  \
+	(((v) << 0) & BM_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_ULC_OUTPUT_SIZE_ULC_X)
+
+#define HW_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_LRC	(0x000000c0)
+
+#define BP_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_LRC_OUTPUT_SIZE_LRC_Y      16
+#define BM_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_LRC_OUTPUT_SIZE_LRC_Y 0xFFFF0000
+#define BF_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_LRC_OUTPUT_SIZE_LRC_Y(v) \
+	(((v) << 16) & BM_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_LRC_OUTPUT_SIZE_LRC_Y)
+#define BP_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_LRC_OUTPUT_SIZE_LRC_X      0
+#define BM_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_LRC_OUTPUT_SIZE_LRC_X 0x0000FFFF
+#define BF_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_LRC_OUTPUT_SIZE_LRC_X(v)  \
+	(((v) << 0) & BM_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_LRC_OUTPUT_SIZE_LRC_X)
+
+#define HW_PRE_PREFETCH_ENGINE_PITCH	(0x000000d0)
+
+#define BP_PRE_PREFETCH_ENGINE_PITCH_INPUT_UV_PITCH      16
+#define BM_PRE_PREFETCH_ENGINE_PITCH_INPUT_UV_PITCH 0xFFFF0000
+#define BF_PRE_PREFETCH_ENGINE_PITCH_INPUT_UV_PITCH(v) \
+	(((v) << 16) & BM_PRE_PREFETCH_ENGINE_PITCH_INPUT_UV_PITCH)
+#define BP_PRE_PREFETCH_ENGINE_PITCH_INPUT_Y_PITCH      0
+#define BM_PRE_PREFETCH_ENGINE_PITCH_INPUT_Y_PITCH 0x0000FFFF
+#define BF_PRE_PREFETCH_ENGINE_PITCH_INPUT_Y_PITCH(v)  \
+	(((v) << 0) & BM_PRE_PREFETCH_ENGINE_PITCH_INPUT_Y_PITCH)
+
+#define HW_PRE_PREFETCH_ENGINE_SHIFT_OFFSET	(0x000000e0)
+#define HW_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_SET	(0x000000e4)
+#define HW_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_CLR	(0x000000e8)
+#define HW_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_TOG	(0x000000ec)
+
+#define BP_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_RSVD0      29
+#define BM_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_RSVD0 0xE0000000
+#define BF_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_RSVD0(v) \
+	(((v) << 29) & BM_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_RSVD0)
+#define BP_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_OFFSET3      24
+#define BM_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_OFFSET3 0x1F000000
+#define BF_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_OFFSET3(v)  \
+	(((v) << 24) & BM_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_OFFSET3)
+#define BP_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_RSVD1      21
+#define BM_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_RSVD1 0x00E00000
+#define BF_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_RSVD1(v)  \
+	(((v) << 21) & BM_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_RSVD1)
+#define BP_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_OFFSET2      16
+#define BM_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_OFFSET2 0x001F0000
+#define BF_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_OFFSET2(v)  \
+	(((v) << 16) & BM_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_OFFSET2)
+#define BP_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_RSVD2      13
+#define BM_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_RSVD2 0x0000E000
+#define BF_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_RSVD2(v)  \
+	(((v) << 13) & BM_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_RSVD2)
+#define BP_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_OFFSET1      8
+#define BM_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_OFFSET1 0x00001F00
+#define BF_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_OFFSET1(v)  \
+	(((v) << 8) & BM_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_OFFSET1)
+#define BP_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_RSVD3      5
+#define BM_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_RSVD3 0x000000E0
+#define BF_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_RSVD3(v)  \
+	(((v) << 5) & BM_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_RSVD3)
+#define BP_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_OFFSET0      0
+#define BM_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_OFFSET0 0x0000001F
+#define BF_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_OFFSET0(v)  \
+	(((v) << 0) & BM_PRE_PREFETCH_ENGINE_SHIFT_OFFSET_OFFSET0)
+
+#define HW_PRE_PREFETCH_ENGINE_SHIFT_WIDTH	(0x000000f0)
+#define HW_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_SET	(0x000000f4)
+#define HW_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_CLR	(0x000000f8)
+#define HW_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_TOG	(0x000000fc)
+
+#define BP_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_RSVD0      16
+#define BM_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_RSVD0 0xFFFF0000
+#define BF_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_RSVD0(v) \
+	(((v) << 16) & BM_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_RSVD0)
+#define BP_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_WIDTH3      12
+#define BM_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_WIDTH3 0x0000F000
+#define BF_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_WIDTH3(v)  \
+	(((v) << 12) & BM_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_WIDTH3)
+#define BP_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_WIDTH2      8
+#define BM_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_WIDTH2 0x00000F00
+#define BF_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_WIDTH2(v)  \
+	(((v) << 8) & BM_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_WIDTH2)
+#define BP_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_WIDTH1      4
+#define BM_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_WIDTH1 0x000000F0
+#define BF_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_WIDTH1(v)  \
+	(((v) << 4) & BM_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_WIDTH1)
+#define BP_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_WIDTH0      0
+#define BM_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_WIDTH0 0x0000000F
+#define BF_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_WIDTH0(v)  \
+	(((v) << 0) & BM_PRE_PREFETCH_ENGINE_SHIFT_WIDTH_WIDTH0)
+
+#define HW_PRE_PREFETCH_ENGINE_INTERLACE_OFFSET	(0x00000100)
+
+#define BP_PRE_PREFETCH_ENGINE_INTERLACE_OFFSET_RSVD0      23
+#define BM_PRE_PREFETCH_ENGINE_INTERLACE_OFFSET_RSVD0 0xFF800000
+#define BF_PRE_PREFETCH_ENGINE_INTERLACE_OFFSET_RSVD0(v) \
+	(((v) << 23) & BM_PRE_PREFETCH_ENGINE_INTERLACE_OFFSET_RSVD0)
+#define BP_PRE_PREFETCH_ENGINE_INTERLACE_OFFSET_INTERLACE_OFFSET      0
+#define BM_PRE_PREFETCH_ENGINE_INTERLACE_OFFSET_INTERLACE_OFFSET 0xFFFFFFFF
+#define BF_PRE_PREFETCH_ENGINE_INTERLACE_OFFSET_INTERLACE_OFFSET(v)  \
+	(((v) << 0) & BM_PRE_PREFETCH_ENGINE_INTERLACE_OFFSET_INTERLACE_OFFSET)
+
+#define HW_PRE_STORE_ENGINE_CTRL	(0x00000110)
+#define HW_PRE_STORE_ENGINE_CTRL_SET	(0x00000114)
+#define HW_PRE_STORE_ENGINE_CTRL_CLR	(0x00000118)
+#define HW_PRE_STORE_ENGINE_CTRL_TOG	(0x0000011c)
+
+#define BP_PRE_STORE_ENGINE_CTRL_RSVD0      6
+#define BM_PRE_STORE_ENGINE_CTRL_RSVD0 0xFFFFFFC0
+#define BF_PRE_STORE_ENGINE_CTRL_RSVD0(v) \
+	(((v) << 6) & BM_PRE_STORE_ENGINE_CTRL_RSVD0)
+#define BP_PRE_STORE_ENGINE_CTRL_OUTPUT_ACTIVE_BPP      4
+#define BM_PRE_STORE_ENGINE_CTRL_OUTPUT_ACTIVE_BPP 0x00000030
+#define BF_PRE_STORE_ENGINE_CTRL_OUTPUT_ACTIVE_BPP(v)  \
+	(((v) << 4) & BM_PRE_STORE_ENGINE_CTRL_OUTPUT_ACTIVE_BPP)
+#define BV_PRE_STORE_ENGINE_CTRL_OUTPUT_ACTIVE_BPP__8_bits  0x0
+#define BV_PRE_STORE_ENGINE_CTRL_OUTPUT_ACTIVE_BPP__16_bits 0x1
+#define BV_PRE_STORE_ENGINE_CTRL_OUTPUT_ACTIVE_BPP__32_bits 0x2
+#define BV_PRE_STORE_ENGINE_CTRL_OUTPUT_ACTIVE_BPP__64_bits 0x3
+#define BP_PRE_STORE_ENGINE_CTRL_WR_NUM_BYTES      1
+#define BM_PRE_STORE_ENGINE_CTRL_WR_NUM_BYTES 0x0000000E
+#define BF_PRE_STORE_ENGINE_CTRL_WR_NUM_BYTES(v)  \
+	(((v) << 1) & BM_PRE_STORE_ENGINE_CTRL_WR_NUM_BYTES)
+#define BV_PRE_STORE_ENGINE_CTRL_WR_NUM_BYTES__8_bytes   0x0
+#define BV_PRE_STORE_ENGINE_CTRL_WR_NUM_BYTES__16_bytes  0x1
+#define BV_PRE_STORE_ENGINE_CTRL_WR_NUM_BYTES__32_bytes  0x2
+#define BV_PRE_STORE_ENGINE_CTRL_WR_NUM_BYTES__64_bytes  0x3
+#define BV_PRE_STORE_ENGINE_CTRL_WR_NUM_BYTES__128_bytes 0x4
+#define BM_PRE_STORE_ENGINE_CTRL_STORE_EN 0x00000001
+#define BF_PRE_STORE_ENGINE_CTRL_STORE_EN(v)  \
+	(((v) << 0) & BM_PRE_STORE_ENGINE_CTRL_STORE_EN)
+#define BV_PRE_STORE_ENGINE_CTRL_STORE_EN__0 0x0
+#define BV_PRE_STORE_ENGINE_CTRL_STORE_EN__1 0x1
+
+#define HW_PRE_STORE_ENGINE_STATUS	(0x00000120)
+
+#define BP_PRE_STORE_ENGINE_STATUS_STORE_BLOCK_Y      16
+#define BM_PRE_STORE_ENGINE_STATUS_STORE_BLOCK_Y 0xFFFF0000
+#define BF_PRE_STORE_ENGINE_STATUS_STORE_BLOCK_Y(v) \
+	(((v) << 16) & BM_PRE_STORE_ENGINE_STATUS_STORE_BLOCK_Y)
+#define BP_PRE_STORE_ENGINE_STATUS_STORE_BLOCK_X      0
+#define BM_PRE_STORE_ENGINE_STATUS_STORE_BLOCK_X 0x0000FFFF
+#define BF_PRE_STORE_ENGINE_STATUS_STORE_BLOCK_X(v)  \
+	(((v) << 0) & BM_PRE_STORE_ENGINE_STATUS_STORE_BLOCK_X)
+
+#define HW_PRE_STORE_ENGINE_SIZE	(0x00000130)
+
+#define BP_PRE_STORE_ENGINE_SIZE_INPUT_TOTAL_HEIGHT      16
+#define BM_PRE_STORE_ENGINE_SIZE_INPUT_TOTAL_HEIGHT 0xFFFF0000
+#define BF_PRE_STORE_ENGINE_SIZE_INPUT_TOTAL_HEIGHT(v) \
+	(((v) << 16) & BM_PRE_STORE_ENGINE_SIZE_INPUT_TOTAL_HEIGHT)
+#define BP_PRE_STORE_ENGINE_SIZE_INPUT_TOTAL_WIDTH      0
+#define BM_PRE_STORE_ENGINE_SIZE_INPUT_TOTAL_WIDTH 0x0000FFFF
+#define BF_PRE_STORE_ENGINE_SIZE_INPUT_TOTAL_WIDTH(v)  \
+	(((v) << 0) & BM_PRE_STORE_ENGINE_SIZE_INPUT_TOTAL_WIDTH)
+
+#define HW_PRE_STORE_ENGINE_PITCH	(0x00000140)
+
+#define BP_PRE_STORE_ENGINE_PITCH_RSVD0      16
+#define BM_PRE_STORE_ENGINE_PITCH_RSVD0 0xFFFF0000
+#define BF_PRE_STORE_ENGINE_PITCH_RSVD0(v) \
+	(((v) << 16) & BM_PRE_STORE_ENGINE_PITCH_RSVD0)
+#define BP_PRE_STORE_ENGINE_PITCH_OUT_PITCH      0
+#define BM_PRE_STORE_ENGINE_PITCH_OUT_PITCH 0x0000FFFF
+#define BF_PRE_STORE_ENGINE_PITCH_OUT_PITCH(v)  \
+	(((v) << 0) & BM_PRE_STORE_ENGINE_PITCH_OUT_PITCH)
+
+#define HW_PRE_STORE_ENGINE_ADDR	(0x00000150)
+
+#define BP_PRE_STORE_ENGINE_ADDR_OUT_BASE_ADDR      0
+#define BM_PRE_STORE_ENGINE_ADDR_OUT_BASE_ADDR 0xFFFFFFFF
+#define BF_PRE_STORE_ENGINE_ADDR_OUT_BASE_ADDR(v)   (v)
+#endif /* __ARCH_ARM___PRE_H */
diff --git a/drivers/mxc/ipu3/pre.c b/drivers/mxc/ipu3/pre.c
new file mode 100644
index 0000000..28ddb09
--- /dev/null
+++ b/drivers/mxc/ipu3/pre.c
@@ -0,0 +1,957 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#include <linux/clk.h>
+#include <linux/genalloc.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ipu-v3.h>
+#include <linux/ipu-v3-pre.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include "pre-regs.h"
+
+struct ipu_pre_data {
+	unsigned int id;
+	struct device *dev;
+	void __iomem *base;
+	struct clk *clk;
+
+	struct mutex mutex;	/* for in_use */
+	spinlock_t lock;	/* for register access */
+
+	struct list_head list;
+
+	struct gen_pool *iram_pool;
+	unsigned long double_buffer_size;
+	unsigned long double_buffer_base;
+	unsigned long double_buffer_paddr;
+
+	bool in_use;
+	bool enabled;
+};
+
+static LIST_HEAD(pre_list);
+static DEFINE_MUTEX(pre_list_lock);
+
+static inline void pre_write(struct ipu_pre_data *pre,
+			u32 value, unsigned int offset)
+{
+	writel(value, pre->base + offset);
+}
+
+static inline u32 pre_read(struct ipu_pre_data *pre, unsigned offset)
+{
+	return readl(pre->base + offset);
+}
+
+static struct ipu_pre_data *get_pre(unsigned int id)
+{
+	struct ipu_pre_data *pre;
+
+	mutex_lock(&pre_list_lock);
+	list_for_each_entry(pre, &pre_list, list) {
+		if (pre->id == id) {
+			mutex_unlock(&pre_list_lock);
+			return pre;
+		}
+	}
+	mutex_unlock(&pre_list_lock);
+
+	return NULL;
+}
+
+int ipu_pre_alloc(int ipu_id, ipu_channel_t channel)
+{
+	struct ipu_pre_data *pre;
+	int i, fixed;
+
+	if (channel == MEM_BG_SYNC) {
+		fixed = ipu_id ? 3 : 0;
+		pre = get_pre(fixed);
+		if (pre) {
+			mutex_lock(&pre->mutex);
+			if (!pre->in_use) {
+				pre->in_use = true;
+				mutex_unlock(&pre->mutex);
+				return pre->id;
+			}
+			mutex_unlock(&pre->mutex);
+		}
+		return pre ? -EBUSY : -ENOENT;
+	}
+
+	for (i = 1; i < 3; i++) {
+		pre = get_pre(i);
+		if (!pre)
+			continue;
+		mutex_lock(&pre->mutex);
+		if (!pre->in_use) {
+			pre->in_use = true;
+			mutex_unlock(&pre->mutex);
+			return pre->id;
+		}
+		mutex_unlock(&pre->mutex);
+	}
+
+	return pre ? -EBUSY : -ENOENT;
+}
+EXPORT_SYMBOL(ipu_pre_alloc);
+
+void ipu_pre_free(unsigned int *id)
+{
+	struct ipu_pre_data *pre;
+
+	pre = get_pre(*id);
+	if (!pre)
+		return;
+
+	mutex_lock(&pre->mutex);
+	pre->in_use = false;
+	mutex_unlock(&pre->mutex);
+
+	*id = -1;
+}
+EXPORT_SYMBOL(ipu_pre_free);
+
+unsigned long ipu_pre_alloc_double_buffer(unsigned int id, unsigned int size)
+{
+	struct ipu_pre_data *pre = get_pre(id);
+
+	if (!pre)
+		return -ENOENT;
+
+	if (!size)
+		return -EINVAL;
+
+	pre->double_buffer_base = gen_pool_alloc(pre->iram_pool, size);
+	if (!pre->double_buffer_base) {
+		dev_err(pre->dev, "double buffer allocate failed\n");
+		return -ENOMEM;
+	}
+	pre->double_buffer_size = size;
+
+	pre->double_buffer_paddr = gen_pool_virt_to_phys(pre->iram_pool,
+							 pre->double_buffer_base);
+
+	return pre->double_buffer_paddr;
+}
+EXPORT_SYMBOL(ipu_pre_alloc_double_buffer);
+
+void ipu_pre_free_double_buffer(unsigned int id)
+{
+	struct ipu_pre_data *pre = get_pre(id);
+
+	if (!pre)
+		return;
+
+	if (pre->double_buffer_base) {
+		gen_pool_free(pre->iram_pool,
+			      pre->double_buffer_base,
+			      pre->double_buffer_size);
+		pre->double_buffer_base  = 0;
+		pre->double_buffer_size  = 0;
+		pre->double_buffer_paddr = 0;
+	}
+}
+EXPORT_SYMBOL(ipu_pre_free_double_buffer);
+
+/* PRE register configurations */
+static int ipu_pre_set_ctrl(unsigned int id,
+			    bool repeat,
+			    bool vflip,
+			    bool handshake_en,
+			    bool hsk_abort_en,
+			    unsigned int hsk_line_num,
+			    bool sdw_update,
+			    unsigned int block_size,
+			    unsigned int interlaced,
+			    unsigned int prefetch_mode)
+{
+	struct ipu_pre_data *pre = get_pre(id);
+	int ret = 0;
+
+	if (!pre)
+		return -EINVAL;
+
+	spin_lock(&pre->lock);
+	pre_write(pre, BF_PRE_CTRL_TPR_RESET_SEL(1), HW_PRE_CTRL_SET);
+
+	if (repeat)
+		pre_write(pre, BF_PRE_CTRL_EN_REPEAT(1), HW_PRE_CTRL_SET);
+	else
+		pre_write(pre, BM_PRE_CTRL_EN_REPEAT, HW_PRE_CTRL_CLR);
+
+	if (vflip)
+		pre_write(pre, BF_PRE_CTRL_VFLIP(1), HW_PRE_CTRL_SET);
+	else
+		pre_write(pre, BM_PRE_CTRL_VFLIP, HW_PRE_CTRL_CLR);
+
+	if (handshake_en) {
+		pre_write(pre, BF_PRE_CTRL_HANDSHAKE_EN(1), HW_PRE_CTRL_SET);
+		if (hsk_abort_en)
+			pre_write(pre, BF_PRE_CTRL_HANDSHAKE_ABORT_SKIP_EN(1),
+				  HW_PRE_CTRL_SET);
+		else
+			pre_write(pre, BM_PRE_CTRL_HANDSHAKE_ABORT_SKIP_EN,
+				  HW_PRE_CTRL_CLR);
+
+		switch (hsk_line_num) {
+		case 0 /* 4 lines */:
+			pre_write(pre, BM_PRE_CTRL_HANDSHAKE_LINE_NUM,
+				  HW_PRE_CTRL_CLR);
+			break;
+		case 1 /* 8 lines */:
+			pre_write(pre, BM_PRE_CTRL_HANDSHAKE_LINE_NUM,
+				  HW_PRE_CTRL_CLR);
+			pre_write(pre, BF_PRE_CTRL_HANDSHAKE_LINE_NUM(1),
+				  HW_PRE_CTRL_SET);
+			break;
+		case 2 /* 16 lines */:
+			pre_write(pre, BM_PRE_CTRL_HANDSHAKE_LINE_NUM,
+				  HW_PRE_CTRL_CLR);
+			pre_write(pre, BF_PRE_CTRL_HANDSHAKE_LINE_NUM(2),
+				  HW_PRE_CTRL_SET);
+			break;
+		default:
+			dev_err(pre->dev, "invalid hanshake line number\n");
+			ret = -EINVAL;
+			goto err;
+		}
+	} else
+		pre_write(pre, BM_PRE_CTRL_HANDSHAKE_EN, HW_PRE_CTRL_CLR);
+
+
+	switch (prefetch_mode) {
+	case 0:
+		pre_write(pre, BM_PRE_CTRL_BLOCK_EN, HW_PRE_CTRL_CLR);
+		break;
+	case 1:
+		pre_write(pre, BF_PRE_CTRL_BLOCK_EN(1), HW_PRE_CTRL_SET);
+		switch (block_size) {
+		case 0:
+			pre_write(pre, BM_PRE_CTRL_BLOCK_16, HW_PRE_CTRL_CLR);
+			break;
+		case 1:
+			pre_write(pre, BF_PRE_CTRL_BLOCK_16(1), HW_PRE_CTRL_SET);
+			break;
+		default:
+			dev_err(pre->dev, "invalid block size for pre\n");
+			ret = -EINVAL;
+			goto err;
+		}
+		break;
+	default:
+		dev_err(pre->dev, "invalid prefech mode for pre\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
+	switch (interlaced) {
+	case 0: /* progressive mode */
+		pre_write(pre, BM_PRE_CTRL_SO, HW_PRE_CTRL_CLR);
+		break;
+	case 2: /* interlaced mode: Pal */
+		pre_write(pre, BF_PRE_CTRL_SO(1), HW_PRE_CTRL_SET);
+		pre_write(pre, BM_PRE_CTRL_INTERLACED_FIELD, HW_PRE_CTRL_CLR);
+		break;
+	case 3: /* interlaced mode: NTSC */
+		pre_write(pre, BF_PRE_CTRL_SO(1), HW_PRE_CTRL_SET);
+		pre_write(pre, BF_PRE_CTRL_INTERLACED_FIELD(1), HW_PRE_CTRL_SET);
+		break;
+	default:
+		dev_err(pre->dev, "invalid interlaced or progressive mode\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if (sdw_update)
+		pre_write(pre, BF_PRE_CTRL_SDW_UPDATE(1), HW_PRE_CTRL_SET);
+	else
+		pre_write(pre, BM_PRE_CTRL_SDW_UPDATE, HW_PRE_CTRL_CLR);
+
+err:
+	spin_unlock(&pre->lock);
+
+	return ret;
+}
+
+static void ipu_pre_irq_mask(struct ipu_pre_data *pre,
+			     unsigned long mask, bool clear)
+{
+	if (clear) {
+		pre_write(pre, mask & 0xf, HW_PRE_IRQ_MASK_CLR);
+		return;
+	}
+	pre_write(pre, mask & 0xf, HW_PRE_IRQ_MASK_SET);
+}
+
+static int ipu_pre_buf_set(unsigned int id, unsigned long cur_buf,
+			   unsigned long next_buf)
+{
+	struct ipu_pre_data *pre = get_pre(id);
+
+	if (!pre)
+		return -EINVAL;
+
+	spin_lock(&pre->lock);
+	pre_write(pre, cur_buf, HW_PRE_CUR_BUF);
+	pre_write(pre, next_buf, HW_PRE_NEXT_BUF);
+	spin_unlock(&pre->lock);
+
+	return 0;
+}
+
+static int ipu_pre_plane_buf_off_set(unsigned int id,
+				     unsigned long sec_buf_off,
+				     unsigned long trd_buf_off)
+{
+	struct ipu_pre_data *pre = get_pre(id);
+
+	if (!pre || sec_buf_off & BM_PRE_U_BUF_OFFSET_RSVD0 ||
+	    trd_buf_off & BM_PRE_V_BUF_OFFSET_RSVD0)
+		return -EINVAL;
+
+	spin_lock(&pre->lock);
+	pre_write(pre, sec_buf_off, HW_PRE_U_BUF_OFFSET);
+	pre_write(pre, trd_buf_off, HW_PRE_V_BUF_OFFSET);
+	spin_unlock(&pre->lock);
+
+	return 0;
+}
+
+static int ipu_pre_tpr_set(unsigned int id, unsigned int tile_fmt)
+{
+	struct ipu_pre_data *pre = get_pre(id);
+	unsigned int tpr_ctrl, fmt;
+
+	if (!pre)
+		return -EINVAL;
+
+	switch (tile_fmt) {
+	case 0x0: /* Bypass */
+		fmt = BF_PRE_TPR_CTRL_TILE_FORMAT(0x0);
+		break;
+	case IPU_PIX_FMT_GPU32_SB_ST:
+		fmt = BF_PRE_TPR_CTRL_TILE_FORMAT(0x10);
+		break;
+	case IPU_PIX_FMT_GPU16_SB_ST:
+		fmt = BF_PRE_TPR_CTRL_TILE_FORMAT(0x11);
+		break;
+	case IPU_PIX_FMT_GPU32_ST:
+		fmt = BF_PRE_TPR_CTRL_TILE_FORMAT(0x20);
+		break;
+	case IPU_PIX_FMT_GPU16_ST:
+		fmt = BF_PRE_TPR_CTRL_TILE_FORMAT(0x21);
+		break;
+	case IPU_PIX_FMT_GPU32_SB_SRT:
+		fmt = BF_PRE_TPR_CTRL_TILE_FORMAT(0x50);
+		break;
+	case IPU_PIX_FMT_GPU16_SB_SRT:
+		fmt = BF_PRE_TPR_CTRL_TILE_FORMAT(0x51);
+		break;
+	case IPU_PIX_FMT_GPU32_SRT:
+		fmt = BF_PRE_TPR_CTRL_TILE_FORMAT(0x60);
+		break;
+	case IPU_PIX_FMT_GPU16_SRT:
+		fmt = BF_PRE_TPR_CTRL_TILE_FORMAT(0x61);
+		break;
+	default:
+		dev_err(pre->dev, "invalid tile fmt for pre\n");
+		return -EINVAL;
+	}
+
+	spin_lock(&pre->lock);
+	tpr_ctrl = pre_read(pre, HW_PRE_TPR_CTRL);
+	tpr_ctrl &= ~BM_PRE_TPR_CTRL_TILE_FORMAT;
+	tpr_ctrl |= fmt;
+	pre_write(pre, tpr_ctrl, HW_PRE_TPR_CTRL);
+	spin_unlock(&pre->lock);
+
+	return 0;
+}
+
+static int ipu_pre_set_shift(int id, unsigned int offset, unsigned int width)
+{
+	struct ipu_pre_data *pre = get_pre(id);
+
+	if (!pre)
+		return -EINVAL;
+
+	spin_lock(&pre->lock);
+	pre_write(pre, offset, HW_PRE_PREFETCH_ENGINE_SHIFT_OFFSET);
+	pre_write(pre, width,  HW_PRE_PREFETCH_ENGINE_SHIFT_WIDTH);
+	spin_unlock(&pre->lock);
+
+	return 0;
+}
+
+static int ipu_pre_prefetch(unsigned int id,
+			    unsigned int read_burst,
+			    unsigned int input_bpp,
+			    unsigned int input_pixel_fmt,
+			    bool shift_bypass,
+			    bool field_inverse,
+			    bool tpr_coor_offset_en,
+			    struct ipu_rect output_size,
+			    unsigned int input_width,
+			    unsigned int input_height,
+			    unsigned int input_active_width,
+			    unsigned int interlaced,
+			    int interlace_offset)
+{
+	unsigned int prefetch_ctrl = 0;
+	unsigned int input_y_pitch = 0, input_uv_pitch = 0;
+	struct ipu_pre_data *pre = get_pre(id);
+
+	if (!pre)
+		return -EINVAL;
+
+	spin_lock(&pre->lock);
+	prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_PREFETCH_EN(1);
+	switch (read_burst) {
+	case 0x0:
+		prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_RD_NUM_BYTES(0x0);
+		break;
+	case 0x1:
+		prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_RD_NUM_BYTES(0x1);
+		break;
+	case 0x2:
+		prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_RD_NUM_BYTES(0x2);
+		break;
+	case 0x3:
+		prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_RD_NUM_BYTES(0x3);
+		break;
+	case 0x4:
+		prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_RD_NUM_BYTES(0x4);
+		break;
+	default:
+		dev_err(pre->dev, "invalid read burst for prefetch engine\n");
+		spin_unlock(&pre->lock);
+		return -EINVAL;
+	}
+
+	switch (input_bpp) {
+	case 8:
+		prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_INPUT_ACTIVE_BPP(0x0);
+		break;
+	case 16:
+		prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_INPUT_ACTIVE_BPP(0x1);
+		break;
+	case 32:
+		prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_INPUT_ACTIVE_BPP(0x2);
+		break;
+	case 64:
+		prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_INPUT_ACTIVE_BPP(0x3);
+		break;
+	default:
+		dev_err(pre->dev, "invalid input bpp for prefetch engine\n");
+		spin_unlock(&pre->lock);
+		return -EINVAL;
+	}
+
+	switch (input_pixel_fmt) {
+	case 0x1: /* tile */
+	case 0x0: /* generic data */
+	case IPU_PIX_FMT_YUYV:
+	case IPU_PIX_FMT_UYVY:
+	case IPU_PIX_FMT_YUV444:
+	case IPU_PIX_FMT_AYUV:
+		prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_INPUT_PIXEL_FORMAT(0x0);
+		input_y_pitch = input_width * (input_bpp >> 3);
+		if (interlaced && input_pixel_fmt != 0x1)
+			input_y_pitch *= 2;
+		break;
+	case IPU_PIX_FMT_YUV444P:
+		prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_INPUT_PIXEL_FORMAT(0x1);
+		input_y_pitch  = input_width;
+		input_uv_pitch = input_width;
+		break;
+	case IPU_PIX_FMT_YUV422P:
+	case IPU_PIX_FMT_YVU422P:
+		prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_INPUT_PIXEL_FORMAT(0x2);
+		input_y_pitch  = input_width;
+		input_uv_pitch = input_width >> 1;
+		break;
+	case IPU_PIX_FMT_YUV420P2:
+	case IPU_PIX_FMT_YUV420P:
+		prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_INPUT_PIXEL_FORMAT(0x3);
+		input_y_pitch  = input_width;
+		input_uv_pitch = input_width >> 1;
+		break;
+	case PRE_PIX_FMT_NV61:
+		prefetch_ctrl |= BM_PRE_PREFETCH_ENGINE_CTRL_PARTIAL_UV_SWAP;
+	case IPU_PIX_FMT_NV16:
+		prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_INPUT_PIXEL_FORMAT(0x4);
+		input_y_pitch  = input_width;
+		input_uv_pitch = input_width;
+		break;
+	case PRE_PIX_FMT_NV21:
+		prefetch_ctrl |= BM_PRE_PREFETCH_ENGINE_CTRL_PARTIAL_UV_SWAP;
+	case IPU_PIX_FMT_NV12:
+		prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_INPUT_PIXEL_FORMAT(0x5);
+		input_y_pitch  = input_width;
+		input_uv_pitch = input_width;
+		break;
+	default:
+		dev_err(pre->dev, "invalid input pixel format for prefetch engine\n");
+		spin_unlock(&pre->lock);
+		return -EINVAL;
+	}
+
+	prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_SHIFT_BYPASS(shift_bypass ? 1 : 0);
+	prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_FIELD_INVERSE(field_inverse ? 1 : 0);
+	prefetch_ctrl |= BF_PRE_PREFETCH_ENGINE_CTRL_TPR_COOR_OFFSET_EN(tpr_coor_offset_en ? 1 : 0);
+
+	pre_write(pre, BF_PRE_PREFETCH_ENGINE_INPUT_SIZE_INPUT_WIDTH(input_active_width) |
+		  BF_PRE_PREFETCH_ENGINE_INPUT_SIZE_INPUT_HEIGHT(input_height),
+		  HW_PRE_PREFETCH_ENGINE_INPUT_SIZE);
+
+	if (tpr_coor_offset_en)
+		pre_write(pre, BF_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_ULC_OUTPUT_SIZE_ULC_X(output_size.left) |
+			     BF_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_ULC_OUTPUT_SIZE_ULC_Y(output_size.top),
+			     HW_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_ULC);
+
+	pre_write(pre, BF_PRE_PREFETCH_ENGINE_PITCH_INPUT_Y_PITCH(input_y_pitch) |
+		     BF_PRE_PREFETCH_ENGINE_PITCH_INPUT_UV_PITCH(input_uv_pitch),
+		     HW_PRE_PREFETCH_ENGINE_PITCH);
+
+	pre_write(pre, BF_PRE_PREFETCH_ENGINE_INTERLACE_OFFSET_INTERLACE_OFFSET(interlace_offset), HW_PRE_PREFETCH_ENGINE_INTERLACE_OFFSET);
+
+	pre_write(pre, prefetch_ctrl, HW_PRE_PREFETCH_ENGINE_CTRL);
+	spin_unlock(&pre->lock);
+
+	return 0;
+}
+
+static int ipu_pre_store(unsigned int id,
+			 bool store_en,
+			 unsigned int write_burst,
+			 unsigned int output_bpp,
+			 /* this means the output
+			  * width by prefetch
+			  */
+			 unsigned int input_width,
+			 unsigned int input_height,
+			 unsigned int out_pitch,
+			 unsigned int output_addr)
+{
+	struct ipu_pre_data *pre = get_pre(id);
+	unsigned int store_ctrl = 0;
+
+	if (!pre)
+		return -EINVAL;
+
+	spin_lock(&pre->lock);
+	store_ctrl |= BF_PRE_STORE_ENGINE_CTRL_STORE_EN(store_en ? 1 : 0);
+
+	if (store_en) {
+		switch (write_burst) {
+		case 0x0:
+			store_ctrl |= BF_PRE_STORE_ENGINE_CTRL_WR_NUM_BYTES(0x0);
+			break;
+		case 0x1:
+			store_ctrl |= BF_PRE_STORE_ENGINE_CTRL_WR_NUM_BYTES(0x1);
+			break;
+		case 0x2:
+			store_ctrl |= BF_PRE_STORE_ENGINE_CTRL_WR_NUM_BYTES(0x2);
+			break;
+		case 0x3:
+			store_ctrl |= BF_PRE_STORE_ENGINE_CTRL_WR_NUM_BYTES(0x3);
+			break;
+		case 0x4:
+			store_ctrl |= BF_PRE_STORE_ENGINE_CTRL_WR_NUM_BYTES(0x4);
+			break;
+		default:
+			dev_err(pre->dev, "invalid write burst value for store engine\n");
+			spin_unlock(&pre->lock);
+			return -EINVAL;
+		}
+
+		switch (output_bpp) {
+		case 8:
+			store_ctrl |= BF_PRE_STORE_ENGINE_CTRL_OUTPUT_ACTIVE_BPP(0x0);
+			break;
+		case 16:
+			store_ctrl |= BF_PRE_STORE_ENGINE_CTRL_OUTPUT_ACTIVE_BPP(0x1);
+			break;
+		case 32:
+			store_ctrl |= BF_PRE_STORE_ENGINE_CTRL_OUTPUT_ACTIVE_BPP(0x2);
+			break;
+		case 64:
+			store_ctrl |= BF_PRE_STORE_ENGINE_CTRL_OUTPUT_ACTIVE_BPP(0x3);
+			break;
+		default:
+			dev_err(pre->dev, "invalid ouput bpp for store engine\n");
+			spin_unlock(&pre->lock);
+			return -EINVAL;
+		}
+
+		pre_write(pre, BF_PRE_STORE_ENGINE_SIZE_INPUT_TOTAL_WIDTH(input_width) |
+			     BF_PRE_STORE_ENGINE_SIZE_INPUT_TOTAL_HEIGHT(input_height),
+			     HW_PRE_STORE_ENGINE_SIZE);
+
+		pre_write(pre, BF_PRE_STORE_ENGINE_PITCH_OUT_PITCH(out_pitch),
+			     HW_PRE_STORE_ENGINE_PITCH);
+
+		pre_write(pre, BF_PRE_STORE_ENGINE_ADDR_OUT_BASE_ADDR(output_addr),
+			     HW_PRE_STORE_ENGINE_ADDR);
+	}
+
+	pre_write(pre, store_ctrl, HW_PRE_STORE_ENGINE_CTRL);
+	spin_unlock(&pre->lock);
+
+	return 0;
+}
+/* End */
+
+static irqreturn_t ipu_pre_irq_handle(int irq, void *dev_id)
+{
+	struct ipu_pre_data *pre = dev_id;
+	unsigned int irq_stat, axi_id = 0;
+
+	spin_lock(&pre->lock);
+	irq_stat = pre_read(pre, HW_PRE_IRQ);
+
+	if (irq_stat & BM_PRE_IRQ_HANDSHAKE_ABORT_IRQ) {
+		dev_warn(pre->dev, "handshake abort\n");
+		pre_write(pre, BM_PRE_IRQ_HANDSHAKE_ABORT_IRQ, HW_PRE_IRQ_CLR);
+	}
+
+	if (irq_stat & BM_PRE_IRQ_TPR_RD_NUM_BYTES_OVFL_IRQ) {
+		dev_warn(pre->dev, "tpr read num bytes overflow\n");
+		pre_write(pre, BM_PRE_IRQ_TPR_RD_NUM_BYTES_OVFL_IRQ,
+				HW_PRE_IRQ_CLR);
+	}
+
+	if (irq_stat & BM_PRE_IRQ_HANDSHAKE_ERROR_IRQ) {
+		dev_warn(pre->dev, "handshake error\n");
+		pre_write(pre, BM_PRE_IRQ_HANDSHAKE_ERROR_IRQ, HW_PRE_IRQ_CLR);
+	}
+
+	axi_id = (irq_stat & BM_PRE_IRQ_AXI_ERROR_ID) >>
+					BP_PRE_IRQ_AXI_ERROR_ID;
+	if (irq_stat & BM_PRE_IRQ_AXI_WRITE_ERROR) {
+		dev_warn(pre->dev, "AXI%d write error\n", axi_id);
+		pre_write(pre, BM_PRE_IRQ_AXI_WRITE_ERROR, HW_PRE_IRQ_CLR);
+	}
+
+	if (irq_stat & BM_PRE_IRQ_AXI_READ_ERROR) {
+		dev_warn(pre->dev, "AXI%d read error\n", axi_id);
+		pre_write(pre, BM_PRE_IRQ_AXI_READ_ERROR, HW_PRE_IRQ_CLR);
+	}
+	spin_unlock(&pre->lock);
+
+	return IRQ_HANDLED;
+}
+
+static void ipu_pre_out_of_reset(unsigned int id)
+{
+	struct ipu_pre_data *pre = get_pre(id);
+
+	if (!pre)
+		return;
+
+	spin_lock(&pre->lock);
+	pre_write(pre, BF_PRE_CTRL_SFTRST(1) | BF_PRE_CTRL_CLKGATE(1),
+		  HW_PRE_CTRL_CLR);
+	spin_unlock(&pre->lock);
+}
+
+int ipu_pre_config(int id, struct ipu_pre_context *config)
+{
+	int ret = 0;
+	struct ipu_pre_data *pre = get_pre(id);
+
+	if (!config || !pre)
+		return -EINVAL;
+
+	config->store_addr = pre->double_buffer_paddr;
+
+	if (!pre->enabled)
+		clk_prepare_enable(pre->clk);
+
+	ipu_pre_out_of_reset(id);
+
+	ret = ipu_pre_plane_buf_off_set(id, config->sec_buf_off,
+					config->trd_buf_off);
+	if (ret < 0)
+		goto out;
+
+	ret = ipu_pre_tpr_set(id, config->tile_fmt);
+	if (ret < 0)
+		goto out;
+
+	ret = ipu_pre_buf_set(id, config->cur_buf, config->next_buf);
+	if (ret < 0)
+		goto out;
+
+	ret = ipu_pre_set_shift(id, config->prefetch_shift_offset,
+				config->prefetch_shift_width);
+	if (ret < 0)
+		goto out;
+
+	ret = ipu_pre_prefetch(id, config->read_burst, config->prefetch_input_bpp,
+			config->prefetch_input_pixel_fmt, config->shift_bypass,
+			config->field_inverse, config->tpr_coor_offset_en,
+			config->prefetch_output_size, config->prefetch_input_width,
+			config->prefetch_input_height,
+			config->prefetch_input_active_width,
+			config->interlaced,
+			config->interlace_offset);
+	if (ret < 0)
+		goto out;
+
+	ret = ipu_pre_store(id, config->store_en,
+			config->write_burst, config->store_output_bpp,
+			config->prefetch_output_size.width, config->prefetch_output_size.height,
+			config->store_pitch,
+			config->store_addr);
+	if (ret < 0)
+		goto out;
+
+	ret = ipu_pre_set_ctrl(id, config->repeat,
+			config->vflip, config->handshake_en,
+			config->hsk_abort_en, config->hsk_line_num,
+			config->sdw_update, config->block_size,
+			config->interlaced, config->prefetch_mode);
+
+	ipu_pre_irq_mask(pre, BM_PRE_IRQ_HANDSHAKE_ABORT_IRQ |
+			      BM_PRE_IRQ_TPR_RD_NUM_BYTES_OVFL_IRQ |
+			      BM_PRE_IRQ_HANDSHAKE_ERROR_IRQ, false);
+out:
+	if (!pre->enabled)
+		clk_disable_unprepare(pre->clk);
+
+	return ret;
+}
+EXPORT_SYMBOL(ipu_pre_config);
+
+int ipu_pre_enable(int id)
+{
+	int ret = 0;
+	struct ipu_pre_data *pre = get_pre(id);
+
+	if (!pre)
+		return -EINVAL;
+
+	if (pre->enabled)
+		return 0;
+
+	clk_prepare_enable(pre->clk);
+
+	/* start the pre engine */
+	spin_lock(&pre->lock);
+	pre_write(pre, BF_PRE_CTRL_ENABLE(1), HW_PRE_CTRL_SET);
+	spin_unlock(&pre->lock);
+
+	pre->enabled = true;
+
+	return ret;
+}
+EXPORT_SYMBOL(ipu_pre_enable);
+
+int ipu_pre_sdw_update(int id)
+{
+	int ret = 0;
+	struct ipu_pre_data *pre = get_pre(id);
+
+	if (!pre)
+		return -EINVAL;
+
+	if (!pre->enabled)
+		clk_prepare_enable(pre->clk);
+
+	/* start the pre engine */
+	spin_lock(&pre->lock);
+	pre_write(pre, BF_PRE_CTRL_SDW_UPDATE(1), HW_PRE_CTRL_SET);
+	spin_unlock(&pre->lock);
+
+	if (!pre->enabled)
+		clk_disable_unprepare(pre->clk);
+
+	return ret;
+}
+EXPORT_SYMBOL(ipu_pre_sdw_update);
+
+void ipu_pre_disable(int id)
+{
+	struct ipu_pre_data *pre = get_pre(id);
+
+	if (!pre)
+		return;
+
+	if (!pre->enabled)
+		return;
+
+	/* stop the pre engine */
+	spin_lock(&pre->lock);
+	pre_write(pre, BF_PRE_CTRL_ENABLE(1), HW_PRE_CTRL_CLR);
+	pre_write(pre, BF_PRE_CTRL_SDW_UPDATE(1), HW_PRE_CTRL_SET);
+	pre_write(pre, BF_PRE_CTRL_SFTRST(1), HW_PRE_CTRL_SET);
+	spin_unlock(&pre->lock);
+
+	clk_disable_unprepare(pre->clk);
+
+	pre->enabled = false;
+}
+EXPORT_SYMBOL(ipu_pre_disable);
+
+int ipu_pre_set_fb_buffer(int id, unsigned long fb_paddr,
+			  unsigned int x_crop,
+			  unsigned int y_crop,
+			  unsigned int sec_buf_off,
+			  unsigned int trd_buf_off)
+{
+	struct ipu_pre_data *pre = get_pre(id);
+
+	if (!pre)
+		return -EINVAL;
+
+	spin_lock(&pre->lock);
+	pre_write(pre, fb_paddr, HW_PRE_NEXT_BUF);
+	pre_write(pre, sec_buf_off, HW_PRE_U_BUF_OFFSET);
+	pre_write(pre, trd_buf_off, HW_PRE_V_BUF_OFFSET);
+	pre_write(pre, BF_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_ULC_OUTPUT_SIZE_ULC_X(x_crop) |
+		       BF_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_ULC_OUTPUT_SIZE_ULC_Y(y_crop),
+		  HW_PRE_PREFETCH_ENGINE_OUTPUT_SIZE_ULC);
+	pre_write(pre, BF_PRE_CTRL_SDW_UPDATE(1), HW_PRE_CTRL_SET);
+	spin_unlock(&pre->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_pre_set_fb_buffer);
+
+static int ipu_pre_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct ipu_pre_data *pre;
+	struct resource *res;
+	int id, irq, err;
+
+	pre = devm_kzalloc(&pdev->dev, sizeof(*pre), GFP_KERNEL);
+	if (!pre)
+		return -ENOMEM;
+	pre->dev = &pdev->dev;
+
+	id = of_alias_get_id(np, "pre");
+	if (id < 0) {
+		dev_err(&pdev->dev, "failed to get PRE id\n");
+		return id;
+	}
+	pre->id = id;
+
+	mutex_init(&pre->mutex);
+	spin_lock_init(&pre->lock);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	pre->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(pre->base))
+		return PTR_ERR(pre->base);
+
+	pre->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(pre->clk)) {
+		dev_err(&pdev->dev, "failed to get the pre clk\n");
+		return PTR_ERR(pre->clk);
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	err = devm_request_irq(&pdev->dev, irq, ipu_pre_irq_handle,
+			       IRQF_TRIGGER_RISING, pdev->name, pre);
+	if (err) {
+		dev_err(&pdev->dev, "failed to request pre irq\n");
+		return err;
+	}
+
+	pre->iram_pool = of_get_named_gen_pool(pdev->dev.of_node, "ocram", 0);
+	if (!pre->iram_pool) {
+		dev_err(&pdev->dev, "no iram exist for pre\n");
+		return -ENOMEM;
+	}
+
+	mutex_lock(&pre_list_lock);
+	list_add_tail(&pre->list, &pre_list);
+	mutex_unlock(&pre_list_lock);
+
+	ipu_pre_alloc_double_buffer(pre->id, IPU_PRE_MAX_WIDTH * 8 * IPU_PRE_MAX_BPP);
+
+	/* PRE GATE ON */
+	clk_prepare_enable(pre->clk);
+	pre_write(pre, BF_PRE_CTRL_SFTRST(1) | BF_PRE_CTRL_CLKGATE(1),
+		  HW_PRE_CTRL_CLR);
+	pre_write(pre, 0xf, HW_PRE_IRQ_MASK);
+	clk_disable_unprepare(pre->clk);
+
+	platform_set_drvdata(pdev, pre);
+
+	dev_info(&pdev->dev, "driver probed\n");
+
+	return 0;
+}
+
+static int ipu_pre_remove(struct platform_device *pdev)
+{
+	struct ipu_pre_data *pre = platform_get_drvdata(pdev);
+
+	if (pre->iram_pool && pre->double_buffer_base) {
+		gen_pool_free(pre->iram_pool,
+			      pre->double_buffer_base,
+			      pre->double_buffer_size);
+	}
+
+	mutex_lock(&pre_list_lock);
+	list_del(&pre->list);
+	mutex_unlock(&pre_list_lock);
+
+	return 0;
+}
+
+static const struct of_device_id imx_ipu_pre_dt_ids[] = {
+	{ .compatible = "fsl,imx6q-pre", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx_ipu_pre_dt_ids);
+
+static struct platform_driver ipu_pre_driver = {
+	.driver = {
+			.name = "imx-pre",
+			.of_match_table = of_match_ptr(imx_ipu_pre_dt_ids),
+		  },
+	.probe  = ipu_pre_probe,
+	.remove = ipu_pre_remove,
+};
+
+static int __init ipu_pre_init(void)
+{
+	return platform_driver_register(&ipu_pre_driver);
+}
+subsys_initcall(ipu_pre_init);
+
+static void __exit ipu_pre_exit(void)
+{
+	platform_driver_unregister(&ipu_pre_driver);
+}
+module_exit(ipu_pre_exit);
+
+MODULE_DESCRIPTION("i.MX PRE driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/ipu-v3-pre.h b/include/linux/ipu-v3-pre.h
new file mode 100644
index 0000000..c3fd1fc
--- /dev/null
+++ b/include/linux/ipu-v3-pre.h
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+#ifndef __LINUX_IPU_V3_PRE_H_
+#define __LINUX_IPU_V3_PRE_H_
+
+#define IPU_PRE_MAX_WIDTH	1920
+#define IPU_PRE_MAX_BPP		4
+
+struct ipu_rect {
+	int left;
+	int top;
+	int width;
+	int height;
+};
+
+struct ipu_pre_context {
+	bool repeat;
+	bool vflip;
+	bool handshake_en;
+	bool hsk_abort_en;
+	unsigned int hsk_line_num;
+	bool sdw_update;
+	unsigned int block_size;
+	unsigned int interlaced;
+	unsigned int prefetch_mode;
+
+	unsigned long cur_buf;
+	unsigned long next_buf;
+
+	unsigned int tile_fmt;
+
+	unsigned int read_burst;
+	unsigned int prefetch_input_bpp;
+	unsigned int prefetch_input_pixel_fmt;
+	unsigned int prefetch_shift_offset;
+	unsigned int prefetch_shift_width;
+	bool shift_bypass;
+	bool field_inverse;
+	bool tpr_coor_offset_en;
+	/* the output of prefetch is
+	 * also the input of store
+	 */
+	struct ipu_rect prefetch_output_size;
+	unsigned int prefetch_input_active_width;
+	unsigned int prefetch_input_width;
+	unsigned int prefetch_input_height;
+	unsigned int store_pitch;
+	int interlace_offset;
+
+	bool store_en;
+	unsigned int write_burst;
+	unsigned int store_output_bpp;
+
+	unsigned int sec_buf_off;
+	unsigned int trd_buf_off;
+
+	/* return for IPU fb caller */
+	unsigned long store_addr;
+};
+
+#ifdef CONFIG_MXC_IPU_V3_PRE
+int ipu_pre_alloc(int ipu_id, ipu_channel_t ipu_ch);
+void ipu_pre_free(unsigned int *id);
+unsigned long ipu_pre_alloc_double_buffer(unsigned int id, unsigned int size);
+void ipu_pre_free_double_buffer(unsigned int id);
+int ipu_pre_config(int id, struct ipu_pre_context *config);
+int ipu_pre_enable(int id);
+void ipu_pre_disable(int id);
+int ipu_pre_set_fb_buffer(int id, unsigned long fb_paddr,
+			  unsigned int x_crop,
+			  unsigned int y_crop,
+			  unsigned int sec_buf_off,
+			  unsigned int trd_buf_off);
+int ipu_pre_sdw_update(int id);
+#else
+int ipu_pre_alloc(int ipu_id, ipu_channel_t channel)
+{
+	return -ENODEV;
+}
+
+void ipu_pre_free(unsigned int *id)
+{
+}
+
+unsigned long ipu_pre_alloc_double_buffer(unsigned int id, unsigned int size)
+{
+	return -ENODEV;
+}
+
+void ipu_pre_free_double_buffer(unsigned int id)
+{
+}
+
+int ipu_pre_config(int id, struct ipu_pre_context *config)
+{
+	return -ENODEV;
+}
+
+int ipu_pre_enable(int id)
+{
+	return -ENODEV;
+}
+
+void ipu_pre_disable(int id)
+{
+	return;
+}
+
+int ipu_pre_set_fb_buffer(int id, unsigned long fb_paddr,
+			  unsigned int x_crop,
+			  unsigned int y_crop,
+			  unsigned int sec_buf_off,
+			  unsigned int trd_buf_off)
+{
+	return -ENODEV;
+}
+int ipu_pre_sdw_update(int id)
+{
+	return -ENODEV;
+}
+#endif
+#endif /* __LINUX_IPU_V3_PRE_H_ */
-- 
1.7.5.4

