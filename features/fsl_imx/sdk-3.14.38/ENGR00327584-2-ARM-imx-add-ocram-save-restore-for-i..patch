From 7b5a96f76e27bbc972e5f6b920c8fc9fa2f70b62 Mon Sep 17 00:00:00 2001
From: Anson Huang <b20788@freescale.com>
Date: Tue, 19 Aug 2014 11:11:53 +0800
Subject: [PATCH 0311/1594] ENGR00327584-2 ARM: imx: add ocram save/restore
 for i.mx6sx

commit 16e5f337d054380a137340585ff5dbd30fe99a38 from
git://git.freescale.com/imx/linux-2.6-imx.git

On i.MX6SX, when mega/fast mix power is off during DSM,
OCRAM data will be lost, so we need to do save/resotre
during DSM enter/exit.

Signed-off-by: Anson Huang <b20788@freescale.com>
---
 arch/arm/mach-imx/common.h  |    1 +
 arch/arm/mach-imx/gpc.c     |    5 +++++
 arch/arm/mach-imx/pm-imx6.c |   27 +++++++++++++++++++++++++++
 3 files changed, 33 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h
index 05bceb9..ecf4545 100644
--- a/arch/arm/mach-imx/common.h
+++ b/arch/arm/mach-imx/common.h
@@ -65,6 +65,7 @@ void imx_set_soc_revision(unsigned int rev);
 unsigned int imx_get_soc_revision(void);
 void imx_init_revision_from_anatop(void);
 struct device *imx_soc_device_init(void);
+unsigned int imx_gpc_is_mf_mix_off(void);
 void imx6_enable_rbc(bool enable);
 void imx_gpc_check_dt(void);
 void imx_gpc_set_arm_power_in_lpm(bool power_off);
diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 4143e0d..9ee0c32 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -57,6 +57,11 @@ static u32 gpc_wake_irqs[IMR_NUM];
 static u32 gpc_saved_imrs[IMR_NUM];
 static u32 bypass;
 
+unsigned int imx_gpc_is_mf_mix_off(void)
+{
+	return readl_relaxed(gpc_base + GPC_PGC_MF_PDN);
+}
+
 void imx_gpc_set_arm_power_up_timing(u32 sw2iso, u32 sw)
 {
 	writel_relaxed((sw2iso << GPC_PGC_SW2ISO_SHIFT) |
diff --git a/arch/arm/mach-imx/pm-imx6.c b/arch/arm/mach-imx/pm-imx6.c
index fb46a50..c7688e3 100644
--- a/arch/arm/mach-imx/pm-imx6.c
+++ b/arch/arm/mach-imx/pm-imx6.c
@@ -14,6 +14,12 @@
 #include <linux/init.h>
 #include <linux/io.h>
 #include <linux/irq.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_fdt.h>
+#include <linux/of_irq.h>
+#include <linux/suspend.h>
 #include <linux/genalloc.h>
 #include <linux/mfd/syscon.h>
 #include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>
@@ -23,6 +29,7 @@
 #include <linux/of_platform.h>
 #include <linux/regmap.h>
 #include <linux/suspend.h>
+#include <linux/slab.h>
 #include <asm/cacheflush.h>
 #include <asm/fncpy.h>
 #include <asm/mach/map.h>
@@ -79,6 +86,9 @@
 unsigned long iram_tlb_base_addr;
 unsigned long iram_tlb_phys_addr;
 
+static unsigned int *ocram_saved_in_ddr;
+static void __iomem *ocram_base;
+static unsigned int ocram_size;
 static void __iomem *ccm_base;
 static void __iomem *suspend_ocram_base;
 static void (*imx6_suspend_in_ocram_fn)(void __iomem *ocram_vbase);
@@ -437,8 +447,14 @@ static int imx6q_pm_enter(suspend_state_t state)
 			imx6_enable_rbc(true);
 		imx_gpc_pre_suspend(true);
 		imx_anatop_pre_suspend();
+		if (cpu_is_imx6sx() && imx_gpc_is_mf_mix_off())
+			memcpy(ocram_saved_in_ddr, ocram_base, ocram_size);
+
 		/* Zzz ... */
 		cpu_suspend(0, imx6q_suspend_finish);
+
+		if (cpu_is_imx6sx() && imx_gpc_is_mf_mix_off())
+			memcpy(ocram_base, ocram_saved_in_ddr, ocram_size);
 		if (cpu_is_imx6q() || cpu_is_imx6dl())
 			imx_smp_prepare();
 		imx_anatop_post_resume();
@@ -746,6 +762,9 @@ void __init imx6sl_pm_init(void)
 
 void __init imx6sx_pm_init(void)
 {
+	struct device_node *np;
+	struct resource res;
+
 	imx6_pm_common_init(&imx6sx_pm_data);
 	if (imx_get_soc_revision() < IMX_CHIP_REVISION_1_2) {
 	/*
@@ -773,4 +792,12 @@ void __init imx6sx_pm_init(void)
 		regmap_update_bits(romcp, ROMC_ROMPATCHCNTL,
 			BM_ROMPATCHCNTL_DIS, ~BM_ROMPATCHCNTL_DIS);
 	}
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,mega-fast-sram");
+	ocram_base = of_iomap(np, 0);
+	WARN_ON(!ocram_base);
+	WARN_ON(of_address_to_resource(np, 0, &res));
+	ocram_size = resource_size(&res);
+	ocram_saved_in_ddr = kzalloc(ocram_size, GFP_KERNEL);
+	WARN_ON(!ocram_saved_in_ddr);
 }
-- 
1.7.5.4

