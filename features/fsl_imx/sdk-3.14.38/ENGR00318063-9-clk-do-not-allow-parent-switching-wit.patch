From f57206df9f12ccd5046d03758b1b1d652233c677 Mon Sep 17 00:00:00 2001
From: Shawn Guo <shawn.guo@freescale.com>
Date: Thu, 5 Jun 2014 16:54:31 +0800
Subject: [PATCH 0614/1594] ENGR00318063-9: clk: do not allow parent switching
 with another mux being child

commit 0d1bcc830349124368b283e52caed73c60964885 from
git://git.freescale.com/imx/linux-2.6-imx.git

When switching parent clock with another basic mux clock being its
child, a glitch might be generated and propagated to downstream clocks
through this child mux.

The patch adds a flag CLK_IS_BASIC_MUX to identify the basic mux clocks,
and prohibit the parent switching when the clock itself is the parent of
any basic mux clock.  With this check, the parent switching of a clock
has to happen before the child mux switches to this clock path.

shawn.guo: cherry-pick commit 8df4202f6a46 from imx_3.10.y

Signed-off-by: Shawn Guo <shawn.guo@freescale.com>
---
 drivers/clk/clk-mux.c        |    2 +-
 drivers/clk/clk.c            |   13 +++++++++++++
 include/linux/clk-provider.h |    6 ++++++
 3 files changed, 20 insertions(+), 1 deletions(-)

diff --git a/drivers/clk/clk-mux.c b/drivers/clk/clk-mux.c
index 69a094c..173084d 100644
--- a/drivers/clk/clk-mux.c
+++ b/drivers/clk/clk-mux.c
@@ -143,7 +143,7 @@ struct clk *clk_register_mux_table(struct device *dev, const char *name,
 		init.ops = &clk_mux_ro_ops;
 	else
 		init.ops = &clk_mux_ops;
-	init.flags = flags | CLK_IS_BASIC;
+	init.flags = flags | CLK_IS_BASIC | CLK_IS_BASIC_MUX;
 	init.parent_names = parent_names;
 	init.num_parents = num_parents;
 
diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 9f9cadd..26b5eaa 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -2065,6 +2065,7 @@ EXPORT_SYMBOL_GPL(clk_has_parent);
 
 static int clk_core_set_parent(struct clk_core *clk, struct clk_core *parent)
 {
+	struct clk_core *child;
 	int ret = 0;
 	int p_index = 0;
 	unsigned long p_rate = 0;
@@ -2090,6 +2091,18 @@ static int clk_core_set_parent(struct clk_core *clk, struct clk_core *parent)
 		goto out;
 	}
 
+	/* check two consecutive basic mux clocks */
+	if (clk->flags & CLK_IS_BASIC_MUX) {
+		hlist_for_each_entry(child, &clk->children, child_node) {
+			if (child->flags & CLK_IS_BASIC_MUX) {
+				pr_err("%s: failed to switch parent of %s due to child mux %s\n",
+					__func__, clk->name, child->name);
+				ret = -EBUSY;
+				goto out;
+			}
+		}
+	}
+
 	/* try finding the new parent index */
 	if (parent) {
 		p_index = clk_fetch_parent_index(clk, parent);
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index df69531..a67cb2a 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -31,6 +31,12 @@
 #define CLK_GET_RATE_NOCACHE	BIT(6) /* do not use the cached clk rate */
 #define CLK_SET_RATE_NO_REPARENT BIT(7) /* don't re-parent on rate change */
 #define CLK_GET_ACCURACY_NOCACHE BIT(8) /* do not use the cached clk accuracy */
+/*
+ * Basic mux clk, can't switch parent while there is another basic mux clk
+ * being its child.  Otherwise, a glitch might be propagated to downstream
+ * clocks through this child mux.
+ */
+#define CLK_IS_BASIC_MUX	BIT(9)
 
 struct clk_hw;
 struct clk_core;
-- 
1.7.5.4

