From 26e10b4a926aabe38e9d872c9358018b8215074f Mon Sep 17 00:00:00 2001
From: Anson Huang <b20788@freescale.com>
Date: Thu, 30 Apr 2015 17:52:32 +0800
Subject: [PATCH 0606/1594] MLK-10788-5 ARM: imx: add busfreq support for
 i.mx7d

commit ff2cd53c50da386bce7335ac1baa07bf38479076 from
git://git.freescale.com/imx/linux-2.6-imx.git

Add busfreq support for i.MX7D, including DDR3 and LPDDR3
boards, below setpoints are supported:

LPDDR3:
HIGH: DRAM CLK = 533MHz;
AUDIO: DRAM CLK = 100MHz;
LOW: DRAM CLK = 24MHz;

DDR3:
HIGH: DRAM CLK = 533MHz;
AUDIO: DRAM CLK = 50MHz;
LOW: DRAM CLK = 24MHz;

Busfreq driver will auto detect DDR type, so no different
operations needed for different DDR type, test cases are
same as previous i.MX6 SoCs.

Signed-off-by: Anson Huang <b20788@freescale.com>
---
 arch/arm/mach-imx/Makefile          |    5 +
 arch/arm/mach-imx/busfreq-imx.c     |  267 ++++++++++++------
 arch/arm/mach-imx/busfreq_ddr3.c    |  173 +++++++++---
 arch/arm/mach-imx/clk-imx7d.c       |    6 +-
 arch/arm/mach-imx/clk.h             |    2 +-
 arch/arm/mach-imx/ddr3_freq_imx7d.S |  532 +++++++++++++++++++++++++++++++++++
 arch/arm/mach-imx/lpddr3_freq_imx.S |  366 ++++++++++++++++++++++++
 arch/arm/mach-imx/mach-imx7d.c      |    1 +
 arch/arm/mach-imx/mx7.h             |    6 +
 arch/arm/mach-imx/pm-imx7.c         |   30 +-
 arch/arm/mach-imx/smp_wfe.S         |  110 +++++++
 arch/arm/mach-imx/suspend-imx7.S    |    3 +-
 12 files changed, 1354 insertions(+), 147 deletions(-)
 create mode 100644 arch/arm/mach-imx/ddr3_freq_imx7d.S
 create mode 100644 arch/arm/mach-imx/lpddr3_freq_imx.S
 create mode 100644 arch/arm/mach-imx/smp_wfe.S

diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile
index c065aa4..4a24bee 100644
--- a/arch/arm/mach-imx/Makefile
+++ b/arch/arm/mach-imx/Makefile
@@ -110,12 +110,17 @@ obj-y += busfreq-imx.o
 AFLAGS_ddr3_freq_imx6.o :=-Wa,-march=armv7-a
 obj-$(CONFIG_SOC_IMX6Q) += ddr3_freq_imx6.o busfreq_ddr3.o
 AFLAGS_lpddr2_freq_imx6.o :=-Wa,-march=armv7-a
+AFLAGS_lpddr3_freq_imx.o :=-Wa,-march=armv7-a
 AFLAGS_imx6sl_lpm_wfi.o :=-Wa,-march=armv7-a
 obj-$(CONFIG_SOC_IMX6SL) += busfreq_lpddr2.o lpddr2_freq_imx6.o imx6sl_lpm_wfi.o
 AFLAGS_lpddr2_freq_imx6sx.o :=-Wa,-march=armv7-a
 AFLAGS_ddr3_freq_imx6sx.o :=-Wa,-march=armv7-a
 AFLAGS_imx6sx_low_power_idle.o :=-Wa,-march=armv7-a
 obj-$(CONFIG_SOC_IMX6SX) += ddr3_freq_imx6sx.o lpddr2_freq_imx6sx.o imx6sx_low_power_idle.o
+AFLAGS_ddr3_freq_imx7d.o :=-Wa,-march=armv7-a
+AFLAGS_smp_wfe.o :=-Wa,-march=armv7-a
+obj-y += smp_wfe.o
+obj-$(CONFIG_SOC_IMX7D) += lpddr3_freq_imx.o ddr3_freq_imx7d.o
 endif
 
 obj-$(CONFIG_SOC_IMX50) += mach-imx50.o
diff --git a/arch/arm/mach-imx/busfreq-imx.c b/arch/arm/mach-imx/busfreq-imx.c
index 1203aae..a26f152 100644
--- a/arch/arm/mach-imx/busfreq-imx.c
+++ b/arch/arm/mach-imx/busfreq-imx.c
@@ -37,8 +37,8 @@
 #include "common.h"
 
 #define LPAPM_CLK		24000000
-#define DDR3_AUDIO_CLK		50000000
-#define LPDDR2_AUDIO_CLK	100000000
+#define LOW_AUDIO_CLK		50000000
+#define HIGH_AUDIO_CLK	100000000
 
 #define	MMDC_MDMISC_DDR_TYPE_DDR3	0
 #define	MMDC_MDMISC_DDR_TYPE_LPDDR2	1
@@ -71,7 +71,8 @@ extern int unsigned long iram_tlb_base_addr;
 extern int init_mmdc_lpddr2_settings(struct platform_device *dev);
 extern int init_mmdc_ddr3_settings_imx6q(struct platform_device *dev);
 extern int init_mmdc_ddr3_settings_imx6sx(struct platform_device *dev);
-extern int update_ddr_freq_imx6q(int ddr_rate);
+extern int init_ddrc_ddr_settings(struct platform_device *dev);
+extern int update_ddr_freq_imx_smp(int ddr_rate);
 extern int update_ddr_freq_imx6sx(int ddr_rate);
 extern int update_lpddr2_freq(int ddr_rate);
 
@@ -107,6 +108,15 @@ static struct clk *m4_clk;
 static struct clk *pll1;
 static struct clk *pll1_bypass;
 static struct clk *pll1_bypass_src;
+static struct clk *dram_root;
+static struct clk *dram_alt_sel;
+static struct clk *dram_alt_root;
+static struct clk *pfd0_392m;
+static struct clk *pfd2_270m;
+static struct clk *pfd1_332m;
+static struct clk *pll_dram;
+static struct clk *ahb_sel_clk;
+static struct clk *axi_clk;
 
 static u32 pll2_org_rate;
 static struct delayed_work low_bus_freq_handler;
@@ -145,6 +155,48 @@ static bool check_m4_sleep(void)
 	return  true;
 }
 
+static void enter_lpm_imx7d(void)
+{
+	if (audio_bus_count) {
+		update_ddr_freq_imx_smp(HIGH_AUDIO_CLK);
+
+		clk_set_parent(dram_alt_sel, pfd0_392m);
+		clk_set_parent(dram_root, dram_alt_root);
+		if (high_bus_freq_mode) {
+			clk_set_parent(axi_sel_clk, osc_clk);
+			clk_set_parent(ahb_sel_clk, osc_clk);
+			clk_set_rate(ahb_clk, LPAPM_CLK);
+		}
+		audio_bus_freq_mode = 1;
+		low_bus_freq_mode = 0;
+		cur_bus_freq_mode = BUS_FREQ_AUDIO;
+	} else {
+		update_ddr_freq_imx_smp(LPAPM_CLK);
+
+		clk_set_parent(dram_alt_sel, osc_clk);
+		clk_set_parent(dram_root, dram_alt_root);
+		if (high_bus_freq_mode) {
+			clk_set_parent(axi_sel_clk, osc_clk);
+			clk_set_parent(ahb_sel_clk, osc_clk);
+			clk_set_rate(ahb_clk, LPAPM_CLK);
+		}
+		low_bus_freq_mode = 1;
+		audio_bus_freq_mode = 0;
+		cur_bus_freq_mode = BUS_FREQ_LOW;
+	}
+}
+
+static void exit_lpm_imx7d(void)
+{
+	clk_set_parent(axi_sel_clk, pfd1_332m);
+	clk_set_rate(ahb_clk, LPAPM_CLK / 2);
+	clk_set_parent(ahb_sel_clk, pfd2_270m);
+
+	update_ddr_freq_imx_smp(ddr_normal_rate);
+
+	clk_set_parent(dram_root, pll_dram);
+}
+
 static void enter_lpm_imx6sx(void)
 {
 	if (imx_src_is_m4_enabled())
@@ -162,9 +214,9 @@ static void enter_lpm_imx6sx(void)
 		/* Need to ensure that PLL2_PFD_400M is kept ON. */
 		clk_prepare_enable(pll2_400);
 		if (ddr_type == MMDC_MDMISC_DDR_TYPE_DDR3)
-			update_ddr_freq_imx6sx(DDR3_AUDIO_CLK);
+			update_ddr_freq_imx6sx(LOW_AUDIO_CLK);
 		else if (ddr_type == MMDC_MDMISC_DDR_TYPE_LPDDR2)
-			update_lpddr2_freq(LPDDR2_AUDIO_CLK);
+			update_lpddr2_freq(HIGH_AUDIO_CLK);
 		imx_clk_set_parent(periph2_clk2_sel, pll3);
 		imx_clk_set_parent(periph2_pre_clk, pll2_400);
 		imx_clk_set_parent(periph2_clk, periph2_pre_clk);
@@ -179,9 +231,9 @@ static void enter_lpm_imx6sx(void)
 		 */
 		if (high_bus_freq_mode) {
 			if (ddr_type == MMDC_MDMISC_DDR_TYPE_DDR3)
-				imx_clk_set_rate(mmdc_clk, DDR3_AUDIO_CLK);
+				imx_clk_set_rate(mmdc_clk, LOW_AUDIO_CLK);
 			else if (ddr_type == MMDC_MDMISC_DDR_TYPE_LPDDR2)
-				imx_clk_set_rate(mmdc_clk, LPDDR2_AUDIO_CLK);
+				imx_clk_set_rate(mmdc_clk, HIGH_AUDIO_CLK);
 		}
 		audio_bus_freq_mode = 1;
 		low_bus_freq_mode = 0;
@@ -261,7 +313,7 @@ static void enter_lpm_imx6sl(void)
 		imx_clk_set_rate(ahb_clk, LPAPM_CLK / 3);
 
 		/* Set up DDR to 100MHz. */
-		update_lpddr2_freq(LPDDR2_AUDIO_CLK);
+		update_lpddr2_freq(HIGH_AUDIO_CLK);
 
 		/* Fix the clock tree in kernel */
 		imx_clk_set_parent(periph2_pre_clk, pll2_200);
@@ -422,12 +474,15 @@ static void exit_lpm_imx6sl(void)
 
 static void reduce_bus_freq(void)
 {
-	clk_prepare_enable(pll3);
+	if (cpu_is_imx6())
+		clk_prepare_enable(pll3);
 	if (audio_bus_count && (low_bus_freq_mode || ultra_low_bus_freq_mode))
 		busfreq_notify(LOW_BUSFREQ_EXIT);
 	else if (!audio_bus_count)
 		busfreq_notify(LOW_BUSFREQ_ENTER);
-	if (cpu_is_imx6sl())
+	if (cpu_is_imx7d())
+		enter_lpm_imx7d();
+	else if (cpu_is_imx6sl())
 		enter_lpm_imx6sl();
 	else if (cpu_is_imx6sx())
 		enter_lpm_imx6sx();
@@ -439,7 +494,7 @@ static void reduce_bus_freq(void)
 		if (audio_bus_count) {
 			/* Need to ensure that PLL2_PFD_400M is kept ON. */
 			clk_prepare_enable(pll2_400);
-			update_ddr_freq_imx6q(DDR3_AUDIO_CLK);
+			update_ddr_freq_imx_smp(LOW_AUDIO_CLK);
 			/* Make sure periph clk's parent also got updated */
 			imx_clk_set_parent(periph_clk2_sel, pll3);
 			imx_clk_set_parent(periph_pre_clk, pll2_200);
@@ -448,7 +503,7 @@ static void reduce_bus_freq(void)
 			low_bus_freq_mode = 0;
 			cur_bus_freq_mode = BUS_FREQ_AUDIO;
 		} else {
-			update_ddr_freq_imx6q(LPAPM_CLK);
+			update_ddr_freq_imx_smp(LPAPM_CLK);
 			/* Make sure periph clk's parent also got updated */
 			imx_clk_set_parent(periph_clk2_sel, osc_clk);
 			/* Set periph_clk parent to OSC via periph_clk2_sel */
@@ -460,7 +515,8 @@ static void reduce_bus_freq(void)
 			cur_bus_freq_mode = BUS_FREQ_LOW;
 		}
 	}
-	clk_disable_unprepare(pll3);
+	if (cpu_is_imx6())
+		clk_disable_unprepare(pll3);
 
 	med_bus_freq_mode = 0;
 	high_bus_freq_mode = 0;
@@ -547,15 +603,19 @@ static int set_high_bus_freq(int high_bus_freq)
 	if (low_bus_freq_mode || ultra_low_bus_freq_mode)
 		busfreq_notify(LOW_BUSFREQ_EXIT);
 
-	clk_prepare_enable(pll3);
-	if (cpu_is_imx6sl())
+	if (cpu_is_imx6())
+		clk_prepare_enable(pll3);
+
+	if (cpu_is_imx7d())
+		exit_lpm_imx7d();
+	else if (cpu_is_imx6sl())
 		exit_lpm_imx6sl();
 	else if (cpu_is_imx6sx())
 		exit_lpm_imx6sx();
 	else {
 		if (high_bus_freq) {
 			clk_prepare_enable(pll2_400);
-			update_ddr_freq_imx6q(ddr_normal_rate);
+			update_ddr_freq_imx_smp(ddr_normal_rate);
 			/* Make sure periph clk's parent also got updated */
 			imx_clk_set_parent(periph_clk2_sel, pll3);
 			imx_clk_set_parent(periph_pre_clk, periph_clk_parent);
@@ -567,7 +627,7 @@ static int set_high_bus_freq(int high_bus_freq)
 			}
 			clk_disable_unprepare(pll2_400);
 		} else {
-			update_ddr_freq_imx6q(ddr_med_rate);
+			update_ddr_freq_imx_smp(ddr_med_rate);
 			/* Make sure periph clk's parent also got updated */
 			imx_clk_set_parent(periph_clk2_sel, pll3);
 			imx_clk_set_parent(periph_pre_clk, pll2_400);
@@ -583,7 +643,8 @@ static int set_high_bus_freq(int high_bus_freq)
 	audio_bus_freq_mode = 0;
 	cur_bus_freq_mode = BUS_FREQ_HIGH;
 
-	clk_disable_unprepare(pll3);
+	if (cpu_is_imx6())
+		clk_disable_unprepare(pll3);
 	if (high_bus_freq_mode)
 		dev_dbg(busfreq_dev, "Bus freq set to high mode. Count:\
 			high %d, med %d, audio %d\n",
@@ -756,14 +817,14 @@ const static char *ddr_freq_iram_match[] __initconst = {
 	NULL
 };
 
-static int __init imx6_dt_find_ddr_sram(unsigned long node,
+static int __init imx_dt_find_ddr_sram(unsigned long node,
 		const char *uname, int depth, void *data)
 {
 	unsigned long ddr_iram_addr;
-	__be32 *prop;
+	const __be32 *prop;
 
 	if (of_flat_dt_match(node, ddr_freq_iram_match)) {
-		unsigned long len;
+		int len;
 		prop = of_get_flat_dt_prop(node, "reg", &len);
 		if (prop == NULL || len != (sizeof(unsigned long) * 2))
 			return EINVAL;
@@ -778,14 +839,13 @@ static int __init imx6_dt_find_ddr_sram(unsigned long node,
 	return 0;
 }
 
-void __init imx6_busfreq_map_io(void)
+void __init imx_busfreq_map_io(void)
 {
 	/*
 	 * Get the address of IRAM to be used by the ddr frequency
 	 * change code from the device tree.
 	 */
-	WARN_ON(of_scan_flat_dt(imx6_dt_find_ddr_sram, NULL));
-
+	WARN_ON(of_scan_flat_dt(imx_dt_find_ddr_sram, NULL));
 	if (ddr_freq_change_iram_phys) {
 		ddr_freq_change_iram_base = IMX_IO_P2V(ddr_freq_change_iram_phys);
 		if ((iram_tlb_phys_addr & 0xFFF00000) != (ddr_freq_change_iram_phys & 0xFFF00000)) {
@@ -900,74 +960,76 @@ static int busfreq_probe(struct platform_device *pdev)
 	if (!ddr_freq_change_iram_base)
 		return ENOMEM;
 
-	pll2_400 = devm_clk_get(&pdev->dev, "pll2_pfd2_396m");
-	if (IS_ERR(pll2_400)) {
-		dev_err(busfreq_dev, "%s: failed to get pll2_pfd2_396m\n",
-		__func__);
-		return PTR_ERR(pll2_400);
-	}
-
-	pll2_200 = devm_clk_get(&pdev->dev, "pll2_198m");
-	if (IS_ERR(pll2_200)) {
-		dev_err(busfreq_dev, "%s: failed to get pll2_198m\n",
+	if (cpu_is_imx6()) {
+		pll2_400 = devm_clk_get(&pdev->dev, "pll2_pfd2_396m");
+		if (IS_ERR(pll2_400)) {
+			dev_err(busfreq_dev, "%s: failed to get pll2_pfd2_396m\n",
 			__func__);
-		return PTR_ERR(pll2_200);
-	}
+			return PTR_ERR(pll2_400);
+		}
 
-	pll2_bus = devm_clk_get(&pdev->dev, "pll2_bus");
-	if (IS_ERR(pll2_bus)) {
-		dev_err(busfreq_dev, "%s: failed to get pll2_bus\n",
-			__func__);
-		return PTR_ERR(pll2_bus);
-	}
+		pll2_200 = devm_clk_get(&pdev->dev, "pll2_198m");
+		if (IS_ERR(pll2_200)) {
+			dev_err(busfreq_dev, "%s: failed to get pll2_198m\n",
+				__func__);
+			return PTR_ERR(pll2_200);
+		}
 
-	cpu_clk = devm_clk_get(&pdev->dev, "arm");
-	if (IS_ERR(cpu_clk)) {
-		dev_err(busfreq_dev, "%s: failed to get cpu_clk\n",
-			__func__);
-		return PTR_ERR(cpu_clk);
-	}
+		pll2_bus = devm_clk_get(&pdev->dev, "pll2_bus");
+		if (IS_ERR(pll2_bus)) {
+			dev_err(busfreq_dev, "%s: failed to get pll2_bus\n",
+				__func__);
+			return PTR_ERR(pll2_bus);
+		}
 
-	pll3 = devm_clk_get(&pdev->dev, "pll3_usb_otg");
-	if (IS_ERR(pll3)) {
-		dev_err(busfreq_dev, "%s: failed to get pll3_usb_otg\n",
-			__func__);
-		return PTR_ERR(pll3);
-	}
+		cpu_clk = devm_clk_get(&pdev->dev, "arm");
+		if (IS_ERR(cpu_clk)) {
+			dev_err(busfreq_dev, "%s: failed to get cpu_clk\n",
+				__func__);
+			return PTR_ERR(cpu_clk);
+		}
 
-	periph_clk = devm_clk_get(&pdev->dev, "periph");
-	if (IS_ERR(periph_clk)) {
-		dev_err(busfreq_dev, "%s: failed to get periph\n",
-			__func__);
-		return PTR_ERR(periph_clk);
-	}
+		pll3 = devm_clk_get(&pdev->dev, "pll3_usb_otg");
+		if (IS_ERR(pll3)) {
+			dev_err(busfreq_dev, "%s: failed to get pll3_usb_otg\n",
+				__func__);
+			return PTR_ERR(pll3);
+		}
 
-	periph_pre_clk = devm_clk_get(&pdev->dev, "periph_pre");
-	if (IS_ERR(periph_pre_clk)) {
-		dev_err(busfreq_dev, "%s: failed to get periph_pre\n",
-			__func__);
-		return PTR_ERR(periph_pre_clk);
-	}
+		periph_clk = devm_clk_get(&pdev->dev, "periph");
+		if (IS_ERR(periph_clk)) {
+			dev_err(busfreq_dev, "%s: failed to get periph\n",
+				__func__);
+			return PTR_ERR(periph_clk);
+		}
 
-	periph_clk2 = devm_clk_get(&pdev->dev, "periph_clk2");
-	if (IS_ERR(periph_clk2)) {
-		dev_err(busfreq_dev, "%s: failed to get periph_clk2\n",
-			__func__);
-		return PTR_ERR(periph_clk2);
-	}
+		periph_pre_clk = devm_clk_get(&pdev->dev, "periph_pre");
+		if (IS_ERR(periph_pre_clk)) {
+			dev_err(busfreq_dev, "%s: failed to get periph_pre\n",
+				__func__);
+			return PTR_ERR(periph_pre_clk);
+		}
 
-	periph_clk2_sel = devm_clk_get(&pdev->dev, "periph_clk2_sel");
-	if (IS_ERR(periph_clk2_sel)) {
-		dev_err(busfreq_dev, "%s: failed to get periph_clk2_sel\n",
-			__func__);
-		return PTR_ERR(periph_clk2_sel);
-	}
+		periph_clk2 = devm_clk_get(&pdev->dev, "periph_clk2");
+		if (IS_ERR(periph_clk2)) {
+			dev_err(busfreq_dev, "%s: failed to get periph_clk2\n",
+				__func__);
+			return PTR_ERR(periph_clk2);
+		}
 
-	osc_clk = devm_clk_get(&pdev->dev, "osc");
-	if (IS_ERR(osc_clk)) {
-		dev_err(busfreq_dev, "%s: failed to get osc_clk\n",
-			__func__);
-		return PTR_ERR(osc_clk);
+		periph_clk2_sel = devm_clk_get(&pdev->dev, "periph_clk2_sel");
+		if (IS_ERR(periph_clk2_sel)) {
+			dev_err(busfreq_dev, "%s: failed to get periph_clk2_sel\n",
+				__func__);
+			return PTR_ERR(periph_clk2_sel);
+		}
+
+		osc_clk = devm_clk_get(&pdev->dev, "osc");
+		if (IS_ERR(osc_clk)) {
+			dev_err(busfreq_dev, "%s: failed to get osc_clk\n",
+				__func__);
+			return PTR_ERR(osc_clk);
+		}
 	}
 
 	if (cpu_is_imx6dl()) {
@@ -1121,6 +1183,31 @@ static int busfreq_probe(struct platform_device *pdev)
 		}
 	}
 
+	if (cpu_is_imx7d()) {
+		osc_clk = devm_clk_get(&pdev->dev, "osc");
+		axi_sel_clk = devm_clk_get(&pdev->dev, "axi_sel");
+		ahb_sel_clk = devm_clk_get(&pdev->dev, "ahb_sel");
+		pfd0_392m = devm_clk_get(&pdev->dev, "pfd0_392m");
+		dram_root = devm_clk_get(&pdev->dev, "dram_root");
+		dram_alt_sel = devm_clk_get(&pdev->dev, "dram_alt_sel");
+		pll_dram = devm_clk_get(&pdev->dev, "pll_dram");
+		dram_alt_root = devm_clk_get(&pdev->dev, "dram_alt_root");
+		pfd1_332m = devm_clk_get(&pdev->dev, "pfd1_332m");
+		pfd2_270m = devm_clk_get(&pdev->dev, "pfd2_270m");
+		ahb_clk = devm_clk_get(&pdev->dev, "ahb");
+		axi_clk = devm_clk_get(&pdev->dev, "axi");
+		if (IS_ERR(osc_clk) || IS_ERR(axi_sel_clk) || IS_ERR(ahb_clk)
+			|| IS_ERR(pfd0_392m) || IS_ERR(dram_root)
+			|| IS_ERR(dram_alt_sel) || IS_ERR(pll_dram)
+			|| IS_ERR(dram_alt_root) || IS_ERR(pfd1_332m)
+			|| IS_ERR(ahb_clk) || IS_ERR(axi_clk)
+			|| IS_ERR(pfd2_270m)) {
+			dev_err(busfreq_dev,
+				"%s: failed to get busfreq clk\n", __func__);
+			return -EINVAL;
+		}
+	}
+
 	err = sysfs_create_file(&busfreq_dev->kobj, &dev_attr_enable.attr);
 	if (err) {
 		dev_err(busfreq_dev,
@@ -1175,7 +1262,9 @@ static int busfreq_probe(struct platform_device *pdev)
 			(ddr_freq_change_iram_phys  & 0xFFF00000) | TT_ATTRIB_NON_CACHEABLE_1M;
 	}
 
-	if (cpu_is_imx6sl()) {
+	if (cpu_is_imx7d()) {
+		err = init_ddrc_ddr_settings(pdev);
+	} else if (cpu_is_imx6sl()) {
 		err = init_mmdc_lpddr2_settings(pdev);
 	} else if (cpu_is_imx6sx()) {
 		ddr_type = imx_mmdc_get_ddr_type();
@@ -1193,22 +1282,22 @@ static int busfreq_probe(struct platform_device *pdev)
 	}
 
 	if (err) {
-		dev_err(busfreq_dev, "Busfreq init of MMDC failed\n");
+		dev_err(busfreq_dev, "Busfreq init of ddr controller failed\n");
 		return err;
 	}
 	return 0;
 }
 
-static const struct of_device_id imx6_busfreq_ids[] = {
-	{ .compatible = "fsl,imx6_busfreq", },
+static const struct of_device_id imx_busfreq_ids[] = {
+	{ .compatible = "fsl,imx_busfreq", },
 	{ /* sentinel */ }
 };
 
 static struct platform_driver busfreq_driver = {
 	.driver = {
-		.name = "imx6_busfreq",
+		.name = "imx_busfreq",
 		.owner  = THIS_MODULE,
-		.of_match_table = imx6_busfreq_ids,
+		.of_match_table = imx_busfreq_ids,
 		},
 	.probe = busfreq_probe,
 };
diff --git a/arch/arm/mach-imx/busfreq_ddr3.c b/arch/arm/mach-imx/busfreq_ddr3.c
index 8153696..ef149d4 100644
--- a/arch/arm/mach-imx/busfreq_ddr3.c
+++ b/arch/arm/mach-imx/busfreq_ddr3.c
@@ -24,7 +24,7 @@
 #include <asm/mach/map.h>
 #include <asm/mach-types.h>
 #include <asm/tlb.h>
-#include <linux/busfreq-imx6.h>
+#include <linux/busfreq-imx.h>
 #include <linux/clk.h>
 #include <linux/clockchips.h>
 #include <linux/cpumask.h>
@@ -44,7 +44,7 @@
 #include <linux/slab.h>
 
 #include "hardware.h"
-
+#include "common.h"
 
 /*
  * This structure is for passing necessary data for low level ocram
@@ -84,6 +84,11 @@ extern void imx6sx_ddr3_freq_change(struct imx6_busfreq_info *busfreq_info);
 void (*mx6_change_ddr_freq)(u32 freq, void *ddr_settings,
 	bool dll_mode, void *iomux_offsets) = NULL;
 
+#define SMP_WFE_CODE_SIZE	0x400
+void (*imx7d_change_ddr_freq)(u32 freq) = NULL;
+extern void imx7d_ddr3_freq_change(u32 freq);
+extern void imx_lpddr3_freq_change(u32 freq);
+
 extern unsigned int ddr_med_rate;
 extern unsigned int ddr_normal_rate;
 extern int low_bus_freq_mode;
@@ -104,12 +109,14 @@ extern unsigned long imx6sx_ddr3_freq_change_start asm("imx6sx_ddr3_freq_change_
 extern unsigned long imx6sx_ddr3_freq_change_end asm("imx6sx_ddr3_freq_change_end");
 #ifdef CONFIG_SMP
 static unsigned long wfe_freq_change_iram_base;
-u32 *wait_for_ddr_freq_update;
+volatile u32 *wait_for_ddr_freq_update;
 static unsigned int online_cpus;
 static u32 *irqs_used;
 
 void (*wfe_change_ddr_freq)(u32 cpuid, u32 *ddr_freq_change_done);
+void (*imx7_wfe_change_ddr_freq)(u32 cpuid, u32 ocram_base);
 extern void wfe_ddr3_freq_change(u32 cpuid, u32 *ddr_freq_change_done);
+extern void imx7_smp_wfe(u32 cpuid, u32 ocram_base);
 extern unsigned long wfe_ddr3_freq_change_start asm("wfe_ddr3_freq_change_start");
 extern unsigned long wfe_ddr3_freq_change_end asm("wfe_ddr3_freq_change_end");
 extern void __iomem *imx_scu_base;
@@ -221,7 +228,7 @@ int can_change_ddr_freq(void)
  * the rest of the cores have to remain in WFE
  * state until the frequency is changed.
  */
-irqreturn_t wait_in_wfe_irq(int irq, void *dev_id)
+static irqreturn_t wait_in_wfe_irq(int irq, void *dev_id)
 {
 	u32 me;
 
@@ -230,7 +237,12 @@ irqreturn_t wait_in_wfe_irq(int irq, void *dev_id)
 		clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER,
 				   &me);
 #endif
-	wfe_change_ddr_freq(0xff << (me * 8), (u32 *)&iram_iomux_settings[0][1]);
+	if (cpu_is_imx7d())
+		imx7_wfe_change_ddr_freq(0x8 * me,
+			(u32)ddr_freq_change_iram_base);
+	else
+		wfe_change_ddr_freq(0xff << (me * 8),
+			(u32 *)&iram_iomux_settings[0][1]);
 
 #ifdef CONFIG_LOCAL_TIMERS
 		clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_EXIT,
@@ -287,7 +299,7 @@ int update_ddr_freq_imx6sx(int ddr_rate)
 }
 
 /* change the DDR frequency. */
-int update_ddr_freq_imx6q(int ddr_rate)
+int update_ddr_freq_imx_smp(int ddr_rate)
 {
 	int i, j;
 	bool dll_off = false;
@@ -307,31 +319,33 @@ int update_ddr_freq_imx6q(int ddr_rate)
 
 	printk(KERN_DEBUG "\nBus freq set to %d start...\n", ddr_rate);
 
-	if ((mode == BUS_FREQ_LOW) || (mode == BUS_FREQ_AUDIO))
-		dll_off = true;
-
-	iram_ddr_settings[0][0] = ddr_settings_size;
-	iram_iomux_settings[0][0] = iomux_settings_size;
-	if (ddr_rate == ddr_med_rate && cpu_is_imx6q()) {
-		for (i = 0; i < ARRAY_SIZE(ddr3_dll_mx6q); i++) {
-			iram_ddr_settings[i + 1][0] =
-					normal_mmdc_settings[i][0];
-			iram_ddr_settings[i + 1][1] =
-					normal_mmdc_settings[i][1];
-		}
-		for (j = 0, i = ARRAY_SIZE(ddr3_dll_mx6q);
-			i < iram_ddr_settings[0][0]; j++, i++) {
-			iram_ddr_settings[i + 1][0] =
-					ddr3_400[j][0];
-			iram_ddr_settings[i + 1][1] =
-					ddr3_400[j][1];
-		}
-	} else if (ddr_rate == ddr_normal_rate) {
-		for (i = 0; i < iram_ddr_settings[0][0]; i++) {
-			iram_ddr_settings[i + 1][0] =
-					normal_mmdc_settings[i][0];
-			iram_ddr_settings[i + 1][1] =
-					normal_mmdc_settings[i][1];
+	if (cpu_is_imx6()) {
+		if ((mode == BUS_FREQ_LOW) || (mode == BUS_FREQ_AUDIO))
+			dll_off = true;
+
+		iram_ddr_settings[0][0] = ddr_settings_size;
+		iram_iomux_settings[0][0] = iomux_settings_size;
+		if (ddr_rate == ddr_med_rate && cpu_is_imx6q()) {
+			for (i = 0; i < ARRAY_SIZE(ddr3_dll_mx6q); i++) {
+				iram_ddr_settings[i + 1][0] =
+						normal_mmdc_settings[i][0];
+				iram_ddr_settings[i + 1][1] =
+						normal_mmdc_settings[i][1];
+			}
+			for (j = 0, i = ARRAY_SIZE(ddr3_dll_mx6q);
+				i < iram_ddr_settings[0][0]; j++, i++) {
+				iram_ddr_settings[i + 1][0] =
+						ddr3_400[j][0];
+				iram_ddr_settings[i + 1][1] =
+						ddr3_400[j][1];
+			}
+		} else if (ddr_rate == ddr_normal_rate) {
+			for (i = 0; i < iram_ddr_settings[0][0]; i++) {
+				iram_ddr_settings[i + 1][0] =
+						normal_mmdc_settings[i][0];
+				iram_ddr_settings[i + 1][1] =
+						normal_mmdc_settings[i][1];
+			}
 		}
 	}
 
@@ -344,8 +358,12 @@ int update_ddr_freq_imx6q(int ddr_rate)
 	/* Make sure all the online cores are active */
 	while (1) {
 		bool not_exited_busfreq = false;
+		u32 reg;
 		for_each_online_cpu(cpu) {
-			u32 reg = __raw_readl(imx_scu_base + 0x08);
+			if (cpu_is_imx6())
+				reg = __raw_readl(imx_scu_base + 0x08);
+			else
+				reg = *(wait_for_ddr_freq_update + 1);
 			if (reg & (0x02 << (cpu * 8)))
 				not_exited_busfreq = true;
 		}
@@ -356,8 +374,10 @@ int update_ddr_freq_imx6q(int ddr_rate)
 	wmb();
 	*wait_for_ddr_freq_update = 1;
 	dsb();
-
-	online_cpus = readl_relaxed(imx_scu_base + 0x08);
+	if (cpu_is_imx6())
+		online_cpus = readl_relaxed(imx_scu_base + 0x08);
+	else
+		online_cpus = *(wait_for_ddr_freq_update + 1);
 	for_each_online_cpu(cpu) {
 		*((char *)(&online_cpus) + (u8)cpu) = 0x02;
 		if (cpu != me) {
@@ -369,7 +389,11 @@ int update_ddr_freq_imx6q(int ddr_rate)
 	}
 	/* Wait for the other active CPUs to idle */
 	while (1) {
-		u32 reg = readl_relaxed(imx_scu_base + 0x08);
+		u32 reg;
+		if (cpu_is_imx6())
+			reg = readl_relaxed(imx_scu_base + 0x08);
+		else
+			reg = *(wait_for_ddr_freq_update + 1);
 		reg |= (0x02 << (me * 8));
 		if (reg == online_cpus)
 			break;
@@ -378,12 +402,18 @@ int update_ddr_freq_imx6q(int ddr_rate)
 
 	/* Ensure iram_tlb_phys_addr is flushed to DDR. */
 	__cpuc_flush_dcache_area(&iram_tlb_phys_addr, sizeof(iram_tlb_phys_addr));
-	outer_clean_range(virt_to_phys(&iram_tlb_phys_addr), virt_to_phys(&iram_tlb_phys_addr + 1));
+	if (cpu_is_imx6())
+		outer_clean_range(virt_to_phys(&iram_tlb_phys_addr),
+			virt_to_phys(&iram_tlb_phys_addr + 1));
 
 	ttbr1 = save_ttbr1();
 	/* Now we can change the DDR frequency. */
-	mx6_change_ddr_freq(ddr_rate, iram_ddr_settings,
-		dll_off, iram_iomux_settings);
+	if (cpu_is_imx6())
+		mx6_change_ddr_freq(ddr_rate, iram_ddr_settings,
+			dll_off, iram_iomux_settings);
+	else
+		imx7d_change_ddr_freq(ddr_rate);
+
 	restore_ttbr1(ttbr1);
 	curr_ddr_rate = ddr_rate;
 
@@ -652,3 +682,70 @@ int init_mmdc_ddr3_settings_imx6q(struct platform_device *busfreq_pdev)
 
 	return 0;
 }
+
+int init_ddrc_ddr_settings(struct platform_device *busfreq_pdev)
+{
+	int ddr_type = imx_ddrc_get_ddr_type();
+#ifdef CONFIG_SMP
+	struct device_node *node;
+	u32 cpu;
+	struct device *dev = &busfreq_pdev->dev;
+	int err;
+	node = of_find_compatible_node(NULL, NULL, "arm,cortex-a7-gic");
+	if (!node) {
+		printk(KERN_ERR "failed to find imx7d-a7-gic device tree data!\n");
+		return -EINVAL;
+	}
+	gic_dist_base = of_iomap(node, 0);
+	WARN(!gic_dist_base, "unable to map gic dist registers\n");
+
+	irqs_used = devm_kzalloc(dev, sizeof(u32) * num_present_cpus(),
+					GFP_KERNEL);
+	for_each_online_cpu(cpu) {
+		int irq;
+
+		/*
+		 * set up a reserved interrupt to get all
+		 * the active cores into a WFE state
+		 * before changing the DDR frequency.
+		 */
+		irq = platform_get_irq(busfreq_pdev, cpu);
+		err = request_irq(irq, wait_in_wfe_irq,
+			IRQF_PERCPU, "ddrc", NULL);
+		if (err) {
+			dev_err(dev,
+				"Busfreq:request_irq failed %d, err = %d\n",
+				irq, err);
+			return err;
+		}
+		err = irq_set_affinity(irq, cpumask_of(cpu));
+		if (err) {
+			dev_err(dev,
+				"Busfreq: Cannot set irq affinity irq=%d,\n",
+				irq);
+			return err;
+		}
+		irqs_used[cpu] = irq;
+	}
+	/* Store the variable used to communicate between cores */
+	wait_for_ddr_freq_update = (u32 *)ddr_freq_change_iram_base;
+	imx7_wfe_change_ddr_freq = (void *)fncpy(
+		(void *)ddr_freq_change_iram_base + 0x8,
+		&imx7_smp_wfe, SMP_WFE_CODE_SIZE - 0x8);
+#endif
+	if (ddr_type == IMX_DDR_TYPE_DDR3)
+		imx7d_change_ddr_freq = (void *)fncpy(
+			(void *)ddr_freq_change_iram_base + SMP_WFE_CODE_SIZE,
+			&imx7d_ddr3_freq_change,
+			MX7_BUSFREQ_OCRAM_SIZE - SMP_WFE_CODE_SIZE);
+	else if (ddr_type == IMX_DDR_TYPE_LPDDR3)
+		imx7d_change_ddr_freq = (void *)fncpy(
+				(void *)ddr_freq_change_iram_base +
+				SMP_WFE_CODE_SIZE,
+				&imx_lpddr3_freq_change,
+				MX7_BUSFREQ_OCRAM_SIZE - SMP_WFE_CODE_SIZE);
+
+	curr_ddr_rate = ddr_normal_rate;
+
+	return 0;
+}
diff --git a/arch/arm/mach-imx/clk-imx7d.c b/arch/arm/mach-imx/clk-imx7d.c
index ffc458f..8fcb987 100644
--- a/arch/arm/mach-imx/clk-imx7d.c
+++ b/arch/arm/mach-imx/clk-imx7d.c
@@ -66,7 +66,7 @@ static const char *dram_phym_sel[] = { "pll_dram_main_clk",
 	"dram_phym_alt_clk", };
 
 static const char *dram_sel[] = { "pll_dram_main_clk",
-	"dram_alt_clk", };
+	"dram_alt_root_clk", };
 
 static const char *dram_phym_alt_sel[] = { "osc", "pll_dram_533m_clk",
 	"pll_sys_main_clk", "pll_enet_500m_clk",
@@ -710,11 +710,11 @@ static void __init imx7d_clocks_init(struct device_node *ccm_node)
 	clks[IMX7D_ARM_A7_ROOT_DIV] = imx_clk_divider_flags("arm_a7_div", "arm_a7_cg", base + 0x8000, 0, 3, CLK_SET_RATE_PARENT | CLK_SET_PARENT_ON);
 	clks[IMX7D_ARM_M4_ROOT_DIV] = imx_clk_divider2("arm_m4_div", "arm_m4_cg", base + 0x8080, 0, 3);
 	clks[IMX7D_ARM_M0_ROOT_DIV] = imx_clk_divider2("arm_m0_div", "arm_m0_cg", base + 0x8100, 0, 3);
-	clks[IMX7D_MAIN_AXI_ROOT_DIV] = imx_clk_divider2("axi_post_div", "axi_pre_div", base + 0x8800, 0, 6);
+	clks[IMX7D_MAIN_AXI_ROOT_DIV] = imx_clk_divider_flags("axi_post_div", "axi_pre_div", base + 0x8800, 0, 6, CLK_SET_PARENT_ON);
 	clks[IMX7D_DISP_AXI_ROOT_DIV] = imx_clk_divider2("disp_axi_post_div", "disp_axi_pre_div", base + 0x8880, 0, 6);
 	clks[IMX7D_ENET_AXI_ROOT_DIV] = imx_clk_divider2("enet_axi_post_div", "enet_axi_pre_div", base + 0x8900, 0, 6);
 	clks[IMX7D_NAND_USDHC_BUS_ROOT_DIV] = imx_clk_divider2("nand_usdhc_post_div", "nand_usdhc_pre_div", base + 0x8980, 0, 6);
-	clks[IMX7D_AHB_CHANNEL_ROOT_DIV] = imx_clk_divider2("ahb_post_div", "ahb_pre_div", base + 0x9000, 0, 6);
+	clks[IMX7D_AHB_CHANNEL_ROOT_DIV] = imx_clk_divider_flags("ahb_post_div", "ahb_pre_div", base + 0x9000, 0, 6, CLK_SET_PARENT_ON);
 	clks[IMX7D_DRAM_ROOT_DIV] = imx_clk_divider2("dram_post_div", "dram_cg", base + 0x9880, 0, 3);
 	clks[IMX7D_DRAM_PHYM_ALT_ROOT_DIV] = imx_clk_divider2("dram_phym_alt_post_div", "dram_phym_alt_pre_div", base + 0xa000, 0, 3);
 	clks[IMX7D_DRAM_ALT_ROOT_DIV] = imx_clk_divider2("dram_alt_post_div", "dram_alt_pre_div", base + 0xa080, 0, 3);
diff --git a/arch/arm/mach-imx/clk.h b/arch/arm/mach-imx/clk.h
index 3109ab1..d28fcb8 100644
--- a/arch/arm/mach-imx/clk.h
+++ b/arch/arm/mach-imx/clk.h
@@ -231,7 +231,7 @@ static inline struct clk *imx_clk_mux2(const char *name, void __iomem *reg,
 		u8 shift, u8 width, const char **parents, int num_parents)
 {
 	return clk_register_mux(NULL, name, parents, num_parents,
-			CLK_SET_RATE_NO_REPARENT | CLK_SET_PARENT_GATE | CLK_SET_PARENT_ON,
+			CLK_SET_RATE_NO_REPARENT | CLK_SET_PARENT_ON,
 			reg, shift, width, 0, &imx_ccm_lock);
 }
 
diff --git a/arch/arm/mach-imx/ddr3_freq_imx7d.S b/arch/arm/mach-imx/ddr3_freq_imx7d.S
new file mode 100644
index 0000000..ab82047
--- /dev/null
+++ b/arch/arm/mach-imx/ddr3_freq_imx7d.S
@@ -0,0 +1,532 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/linkage.h>
+#include "hardware.h"
+
+#define DDRC_MSTR		0x0
+#define DDRC_STAT		0x4
+#define DDRC_MRCTRL0		0x10
+#define DDRC_MRCTRL1		0x14
+#define DDRC_MRSTAT		0x18
+#define DDRC_PWRCTL		0x30
+#define DDRC_RFSHCTL3		0x60
+#define DDRC_DBG1		0x304
+#define DDRC_SWCTL		0x320
+#define DDRC_SWSTAT		0x324
+#define DDRC_PSTAT		0x3fc
+#define DDRC_PCTRL_0		0x490
+#define DDRC_ZQCTL0		0x180
+#define DDRC_DFIMISC		0x1b0
+#define DDRC_DBGCAM		0x308
+#define DDRPHY_LP_CON0		0x18
+#define IOMUXC_GPR8		0x20
+#define DDRPHY_MDLL_CON0	0xb0
+#define DDRPHY_MDLL_CON1	0xb4
+#define DDRPHY_OFFSETD_CON0	0x50
+#define DDRPHY_OFFSETR_CON0	0x20
+#define DDRPHY_OFFSETR_CON1	0x24
+#define DDRPHY_OFFSETR_CON2	0x28
+#define DDRPHY_OFFSETW_CON0	0x30
+#define DDRPHY_OFFSETW_CON1	0x34
+#define DDRPHY_OFFSETW_CON2	0x38
+#define DDRPHY_CA_DSKEW_CON0	0x7c
+#define DDRPHY_CA_DSKEW_CON1	0x80
+#define DDRPHY_CA_DSKEW_CON2	0x84
+
+	.align 3
+
+	.macro	switch_to_below_100m
+
+	ldr	r7, =0x2
+	str	r7, [r4, #DDRC_DBG1]
+
+	ldr	r6, =0x36000000
+1:
+	ldr	r7, [r4, #DDRC_DBGCAM]
+	and	r7, r7, r6
+	cmp	r7, r6
+	bne	1b
+
+	ldr	r6, =0x1
+2:
+	ldr	r7, [r4, #DDRC_MRSTAT]
+	and	r7, r7, r6
+	cmp	r7, r6
+	beq	2b
+
+	ldr	r7, =0x10f0
+	str	r7, [r4, #DDRC_MRCTRL0]
+	ldr	r7, =0x0
+	str	r7, [r4, #DDRC_MRCTRL1]
+	ldr	r7, =0x800010f0
+	str	r7, [r4, #DDRC_MRCTRL0]
+
+	ldr	r6, =0x1
+3:
+	ldr	r7, [r4, #DDRC_MRSTAT]
+	and	r7, r7, r6
+	cmp	r7, r6
+	beq	3b
+
+	ldr	r7, =0x20f0
+	str	r7, [r4, #DDRC_MRCTRL0]
+	ldr	r7, =0x8
+	str	r7, [r4, #DDRC_MRCTRL1]
+	ldr	r7, =0x800020f0
+	str	r7, [r4, #DDRC_MRCTRL0]
+
+	ldr	r6, =0x1
+4:
+	ldr	r7, [r4, #DDRC_MRSTAT]
+	and	r7, r7, r6
+	cmp	r7, r6
+	beq	4b
+
+	ldr	r7, =0x10f0
+	str	r7, [r4, #DDRC_MRCTRL0]
+	ldr	r7, =0x1
+	str	r7, [r4, #DDRC_MRCTRL1]
+	ldr	r7, =0x800010f0
+	str	r7, [r4, #DDRC_MRCTRL0]
+
+	ldr	r7, =0x20
+	str	r7, [r4, #DDRC_PWRCTL]
+
+	ldr	r6, =0x23
+5:
+	ldr	r7, [r4, #DDRC_STAT]
+	and	r7, r7, r6
+	cmp	r7, r6
+	bne	5b
+
+	ldr	r7, =0x0
+	str	r7, [r4, #DDRC_SWCTL]
+
+	ldr	r7, =0x03048001
+	str	r7, [r4, #DDRC_MSTR]
+
+	ldr	r7, =0x1
+	str	r7, [r4, #DDRC_SWCTL]
+
+	ldr	r6, =0x1
+6:
+	ldr	r7, [r4, #DDRC_SWSTAT]
+	and	r7, r7, r6
+	cmp	r7, r6
+	bne	6b
+
+	ldr	r7, =0x10010100
+	str	r7, [r5, #0x4]
+
+	ldr	r6, =24000000
+	cmp	r0, r6
+	bne	7f
+
+	/* dram alt sel set to OSC */
+	ldr	r7, =0x10000000
+	ldr	r8, =0xa080
+	str	r7, [r2, r8]
+	/* dram root set to from dram alt, div by 1 */
+	ldr	r7, =0x11000000
+	ldr	r8, =0x9880
+	str	r7, [r2, r8]
+	b	8f
+7:
+	/* dram alt sel set to pfd0_392m */
+	ldr	r7, =0x15000000
+	ldr	r8, =0xa080
+	str	r7, [r2, r8]
+	/* dram root set to from dram alt, div by 4 */
+	ldr	r7, =0x11000003
+	ldr	r8, =0x9880
+	str	r7, [r2, r8]
+8:
+	ldr	r7, =0x202ffd0
+	str	r7, [r5, #DDRPHY_MDLL_CON0]
+
+	ldr	r7, =0x1000007f
+	str	r7, [r5, #DDRPHY_OFFSETD_CON0]
+
+	ldr	r7, =0x7f7f7f7f
+	str	r7, [r5, #DDRPHY_OFFSETR_CON0]
+	str	r7, [r5, #DDRPHY_OFFSETR_CON1]
+	ldr	r7, =0x7f
+	str	r7, [r5, #DDRPHY_OFFSETR_CON2]
+
+	ldr	r7, =0x7f7f7f7f
+	str	r7, [r5, #DDRPHY_OFFSETW_CON0]
+	str	r7, [r5, #DDRPHY_OFFSETW_CON1]
+	ldr	r7, =0x7f
+	str	r7, [r5, #DDRPHY_OFFSETW_CON2]
+
+	ldr	r7, =0x0
+	str	r7, [r5, #DDRPHY_CA_DSKEW_CON0]
+	str	r7, [r5, #DDRPHY_CA_DSKEW_CON1]
+	str	r7, [r5, #DDRPHY_CA_DSKEW_CON2]
+
+	ldr	r7, =0x1100007f
+	str	r7, [r5, #DDRPHY_OFFSETD_CON0]
+	ldr	r7, =0x1000007f
+	str	r7, [r5, #DDRPHY_OFFSETD_CON0]
+
+	ldr	r7, =0x0
+	str	r7, [r4, #DDRC_PWRCTL]
+
+	ldr	r6, =0x1
+9:
+	ldr	r7, [r4, #DDRC_MRSTAT]
+	and	r7, r7, r6
+	cmp	r7, r6
+	beq	9b
+
+	ldr	r7, =0xf0
+	str	r7, [r4, #DDRC_MRCTRL0]
+	ldr	r7, =0x820
+	str	r7, [r4, #DDRC_MRCTRL1]
+	ldr	r7, =0x800000f0
+	str	r7, [r4, #DDRC_MRCTRL0]
+
+	ldr	r6, =0x1
+10:
+	ldr	r7, [r4, #DDRC_MRSTAT]
+	and	r7, r7, r6
+	cmp	r7, r6
+	beq	10b
+
+	ldr	r7, =0x800020
+	str	r7, [r4, #DDRC_ZQCTL0]
+
+	ldr	r7, =0x0
+	str	r7, [r4, #DDRC_DBG1]
+
+	.endm
+
+	.macro	switch_to_533m
+
+	ldr	r7, =0x2
+	str	r7, [r4, #DDRC_DBG1]
+
+	ldr	r7, =0x78
+	str	r7, [r3, #IOMUXC_GPR8]
+	orr	r7, r7, #0x100
+	str	r7, [r3, #IOMUXC_GPR8]
+
+	ldr	r6, =0x30000000
+11:
+	ldr	r7, [r4, #DDRC_DBGCAM]
+	and	r7, r7, r6
+	cmp	r7, r6
+	bne	11b
+
+	ldr	r6, =0x1
+12:
+	ldr	r7, [r4, #DDRC_MRSTAT]
+	and	r7, r7, r6
+	cmp	r7, r6
+	beq	12b
+
+	ldr	r7, =0x10f0
+	str	r7, [r4, #DDRC_MRCTRL0]
+	ldr	r7, =0x1
+	str	r7, [r4, #DDRC_MRCTRL1]
+	ldr	r7, =0x800010f0
+	str	r7, [r4, #DDRC_MRCTRL0]
+
+	ldr	r7, =0x20
+	str	r7, [r4, #DDRC_PWRCTL]
+
+	ldr	r6, =0x23
+13:
+	ldr	r7, [r4, #DDRC_STAT]
+	and	r7, r7, r6
+	cmp	r7, r6
+	bne	13b
+
+	ldr	r7, =0x03040001
+	str	r7, [r4, #DDRC_MSTR]
+
+	ldr	r7, =0x40800020
+	str	r7, [r4, #DDRC_ZQCTL0]
+
+
+	ldr	r7, =0x10210100
+	str	r7, [r5, #0x4]
+
+	/* dram root set to from dram main, div by 2 */
+	ldr	r7, =0x10000001
+	ldr	r8, =0x9880
+	str	r7, [r2, r8]
+
+	ldr	r7, =0x02020070
+	str	r7, [r5, #DDRPHY_MDLL_CON0]
+
+	ldr	r7, =0x10000008
+	str	r7, [r5, #DDRPHY_OFFSETD_CON0]
+
+	ldr	r7, =0x08080808
+	str	r7, [r5, #DDRPHY_OFFSETR_CON0]
+	str	r7, [r5, #DDRPHY_OFFSETR_CON1]
+	ldr	r7, =0x8
+	str	r7, [r5, #DDRPHY_OFFSETR_CON2]
+
+	ldr	r7, =0x08080808
+	str	r7, [r5, #DDRPHY_OFFSETW_CON0]
+	str	r7, [r5, #DDRPHY_OFFSETW_CON1]
+	ldr	r7, =0x8
+	str	r7, [r5, #DDRPHY_OFFSETW_CON2]
+
+	ldr	r7, =0x0
+	str	r7, [r5, #DDRPHY_CA_DSKEW_CON0]
+	str	r7, [r5, #DDRPHY_CA_DSKEW_CON1]
+	str	r7, [r5, #DDRPHY_CA_DSKEW_CON2]
+
+	ldr	r7, =0x11000008
+	str	r7, [r5, #DDRPHY_OFFSETD_CON0]
+	ldr	r7, =0x10000008
+	str	r7, [r5, #DDRPHY_OFFSETD_CON0]
+
+	ldr	r6, =0x4
+14:
+	ldr	r7, [r5, #DDRPHY_MDLL_CON1]
+	and	r7, r7, r6
+	cmp	r7, r6
+	bne	14b
+
+	ldr	r7, =0x1
+	str	r7, [r4, #DDRC_RFSHCTL3]
+	ldr	r7, =0x3
+	str	r7, [r4, #DDRC_RFSHCTL3]
+
+	ldr	r7, =0x0
+	str	r7, [r4, #DDRC_PWRCTL]
+
+	ldr	r6, =0x1
+15:
+	ldr	r7, [r4, #DDRC_MRSTAT]
+	and	r7, r7, r6
+	cmp	r7, r6
+	beq	15b
+
+	ldr	r7, =0x10f0
+	str	r7, [r4, #DDRC_MRCTRL0]
+	ldr	r7, =0x0
+	str	r7, [r4, #DDRC_MRCTRL1]
+	ldr	r7, =0x800010f0
+	str	r7, [r4, #DDRC_MRCTRL0]
+
+	ldr	r6, =0x1
+16:
+	ldr	r7, [r4, #DDRC_MRSTAT]
+	and	r7, r7, r6
+	cmp	r7, r6
+	beq	16b
+
+	ldr	r7, =0xf0
+	str	r7, [r4, #DDRC_MRCTRL0]
+	ldr	r7, =0x930
+	str	r7, [r4, #DDRC_MRCTRL1]
+	ldr	r7, =0x800000f0
+	str	r7, [r4, #DDRC_MRCTRL0]
+
+	ldr	r7, =0x0
+	str	r7, [r4, #DDRC_RFSHCTL3]
+	ldr	r7, =0x2
+	str	r7, [r4, #DDRC_RFSHCTL3]
+
+	ldr	r6, =0x1
+17:
+	ldr	r7, [r4, #DDRC_MRSTAT]
+	and	r7, r7, r6
+	cmp	r7, r6
+	beq	17b
+
+	ldr	r7, =0xf0
+	str	r7, [r4, #DDRC_MRCTRL0]
+	ldr	r7, =0x930
+	str	r7, [r4, #DDRC_MRCTRL1]
+	ldr	r7, =0x800000f0
+	str	r7, [r4, #DDRC_MRCTRL0]
+
+	ldr	r6, =0x1
+18:
+	ldr	r7, [r4, #DDRC_MRSTAT]
+	and	r7, r7, r6
+	cmp	r7, r6
+	beq	18b
+
+	ldr	r7, =0x20f0
+	str	r7, [r4, #DDRC_MRCTRL0]
+	ldr	r7, =0x408
+	str	r7, [r4, #DDRC_MRCTRL1]
+	ldr	r7, =0x800020f0
+	str	r7, [r4, #DDRC_MRCTRL0]
+
+	ldr	r6, =0x1
+19:
+	ldr	r7, [r4, #DDRC_MRSTAT]
+	and	r7, r7, r6
+	cmp	r7, r6
+	beq	19b
+
+	ldr	r7, =0x10f0
+	str	r7, [r4, #DDRC_MRCTRL0]
+	ldr	r7, =0x4
+	str	r7, [r4, #DDRC_MRCTRL1]
+	ldr	r7, =0x800010f0
+	str	r7, [r4, #DDRC_MRCTRL0]
+
+	ldr	r7, =0x0
+	str	r7, [r4, #DDRC_DBG1]
+
+	.endm
+
+ENTRY(imx7d_ddr3_freq_change)
+	push	{r2 - r8}
+
+	/*
+	 * To ensure no page table walks occur in DDR, we
+	 * have a another page table stored in IRAM that only
+	 * contains entries pointing to IRAM, AIPS1 and AIPS2.
+	 * We need to set the TTBR1 to the new IRAM TLB.
+	 * Do the following steps:
+	 * 1. Flush the Branch Target Address Cache (BTAC)
+	 * 2. Set TTBR1 to point to IRAM page table.
+	 * 3. Disable page table walks in TTBR0 (PD0 = 1)
+	 * 4. Set TTBR0.N=1, implying 0-2G is translated by TTBR0
+	 *     and 2-4G is translated by TTBR1.
+	 */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c8, c3, 0
+
+	ldr	r6, =iram_tlb_phys_addr
+	ldr	r7, [r6]
+
+	/* Disable Branch Prediction, Z bit in SCTLR. */
+	mrc	p15, 0, r6, c1, c0, 0
+	bic	r6, r6, #0x800
+	mcr	p15, 0, r6, c1, c0, 0
+
+	/* Flush the Branch Target Address Cache (BTAC) */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c7, c1, 6
+
+	dsb
+	isb
+	/* Store the IRAM table in TTBR1 */
+	mcr	p15, 0, r7, c2, c0, 1
+
+	/* Read TTBCR and set PD0=1, N = 1 */
+	mrc	p15, 0, r6, c2, c0, 2
+	orr	r6, r6, #0x11
+	mcr	p15, 0, r6, c2, c0, 2
+
+	dsb
+	isb
+
+	/* flush the TLB */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c8, c3, 0
+
+	dsb
+	isb
+
+	ldr	r2, =IMX_IO_P2V(MX7D_CCM_BASE_ADDR)
+	ldr	r3, =IMX_IO_P2V(MX7D_IOMUXC_GPR_BASE_ADDR)
+	ldr	r4, =IMX_IO_P2V(MX7D_DDRC_BASE_ADDR)
+	ldr	r5, =IMX_IO_P2V(MX7D_DDRC_PHY_BASE_ADDR)
+
+	ldr	r6, =100000000
+	cmp	r0, r6
+	bgt	set_to_533m
+
+set_to_below_100m:
+	switch_to_below_100m
+	b	done
+
+set_to_533m:
+	switch_to_533m
+	b	done
+
+done:
+	/* Enable L1 data cache. */
+	mrc	p15, 0, r6, c1, c0, 0
+	orr	r6, r6, #0x4
+	mcr	p15, 0, r6, c1, c0, 0
+
+	/* Restore the TTBCR */
+	dsb
+	isb
+
+	/* Read TTBCR and set PD0=0, N = 0 */
+	mrc	p15, 0, r6, c2, c0, 2
+	bic	r6, r6, #0x11
+	mcr	p15, 0, r6, c2, c0, 2
+	dsb
+	isb
+
+	/* flush the TLB */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c8, c3, 0
+
+	dsb
+	isb
+
+	/* Enable Branch Prediction, Z bit in SCTLR. */
+	mrc	p15, 0, r6, c1, c0, 0
+	orr	r6, r6, #0x800
+	mcr	p15, 0, r6, c1, c0, 0
+
+	/* Flush the Branch Target Address Cache (BTAC) */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c7, c1, 6
+
+	dsb
+	isb
+
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	/* Restore registers */
+	pop	{r2 - r8}
+	mov	pc, lr
+	.ltorg
+ENDPROC(imx7d_ddr3_freq_change)
diff --git a/arch/arm/mach-imx/lpddr3_freq_imx.S b/arch/arm/mach-imx/lpddr3_freq_imx.S
new file mode 100644
index 0000000..0ced151
--- /dev/null
+++ b/arch/arm/mach-imx/lpddr3_freq_imx.S
@@ -0,0 +1,366 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/linkage.h>
+#include "hardware.h"
+
+#define DDRC_STAT		0x4
+#define DDRC_PWRCTL		0x30
+#define DDRC_DBG1		0x304
+#define DDRC_PSTAT		0x3fc
+#define DDRC_PCTRL_0		0x490
+#define DDRC_DFIMISC		0x1b0
+#defien DDRC_DBGCAM		0x308
+#define DDRC_SWCTL		0x320
+#define DDRC_SWSTAT		0x324
+#define DDRPHY_LP_CON0		0x18
+#define IOMUXC_GPR8		0x20
+#define DDRPHY_PHY_CON1		0x4
+#define DDRPHY_MDLL_CON0	0xb0
+#define DDRPHY_MDLL_CON1	0xb4
+#define DDRPHY_OFFSETD_CON0	0x50
+#define DDRPHY_OFFSETR_CON0	0x20
+#define DDRPHY_OFFSETR_CON1	0x24
+#define DDRPHY_OFFSETR_CON2	0x28
+#define DDRPHY_OFFSETW_CON0	0x30
+#define DDRPHY_OFFSETW_CON1	0x34
+#define DDRPHY_OFFSETW_CON2	0x38
+#define DDRPHY_CA_DSKEW_CON0	0x7c
+#define DDRPHY_CA_DSKEW_CON1	0x80
+#define DDRPHY_CA_DSKEW_CON2	0x84
+
+	.align 3
+
+	.macro	ddrc_prepare
+
+	/* disable port */
+	ldr	r7, =0x0
+	str	r7, [r4, #DDRC_PCTRL_0]
+
+	/* wait port busy done */
+	ldr	r6, =0x10001
+1:
+	ldr	r7, [r4, #DDRC_PSTAT]
+	and	r7, r7, r6
+	cmp	r7, #0
+	bne	1b
+
+	ldr	r7, =0x20
+	str	r7, [r4, #DDRC_PWRCTL]
+
+	ldr	r6, =0x23
+2:
+	ldr	r7, [r4, #DDRC_STAT]
+	and	r7, r7, r6
+	cmp	r7, r6
+	bne	2b
+
+	ldr	r7, =0x1
+	str	r7, [r4, #DDRC_DBG1]
+
+	ldr	r6, =0x30000000
+	ldr	r8, =0x300
+	orr	r8, r8, #0x8
+3:
+	ldr	r7, [r4, r8]
+	and	r7, r7, r6
+	cmp	r7, r6
+	bne	3b
+
+	ldr	r7, =0x0
+	str	r7, [r4, #DDRC_SWCTL]
+
+	ldr	r7, =0x0
+	str	r7, [r4, #DDRC_DFIMISC]
+
+	ldr	r7, =0x1
+	str	r7, [r4, #DDRC_SWCTL]
+
+	ldr	r6, =0x1
+4:
+	ldr	r7, [r4, #DDRC_SWSTAT]
+	and	r7, r7, r6
+	cmp	r7, r6
+	bne	4b
+
+	.endm
+
+	.macro	ddrc_done
+
+	ldr	r7, =0x0
+	str	r7, [r4, #DDRC_PWRCTL]
+
+	ldr	r6, =0x3
+5:
+	ldr	r7, [r4, #DDRC_STAT]
+	and	r7, r7, r6
+	cmp	r7, r6
+	beq	5b
+
+	ldr	r7, =0x0
+	str	r7, [r4, #DDRC_DBG1]
+
+	ldr	r7, =0x1
+	str	r7, [r4, #DDRC_PCTRL_0]
+
+	.endm
+
+	.macro	switch_to_below_100m
+
+	ldr	r7, =0x10010100
+	str	r7, [r5, #DDRPHY_PHY_CON1]
+
+	ldr	r6, =24000000
+	cmp	r0, r6
+	bne	6f
+
+	/* dram alt sel set to OSC */
+	ldr	r7, =0x10000000
+	ldr	r8, =0xa080
+	str	r7, [r2, r8]
+	/* dram root set to from dram alt, div by 1 */
+	ldr	r7, =0x11000000
+	ldr	r8, =0x9880
+	str	r7, [r2, r8]
+	b	7f
+
+6:
+	/* dram alt sel set to pfd0_392m */
+	ldr	r7, =0x15000000
+	ldr	r8, =0xa080
+	str	r7, [r2, r8]
+	/* dram root set to from dram alt, div by 4 */
+	ldr	r7, =0x11000003
+	ldr	r8, =0x9880
+	str	r7, [r2, r8]
+7:
+	ldr	r7, =0x202ffd0
+	str	r7, [r5, #DDRPHY_MDLL_CON0]
+
+	ldr	r7, =0x7f
+	str	r7, [r5, #DDRPHY_OFFSETD_CON0]
+
+	ldr	r7, =0x7f7f7f7f
+	str	r7, [r5, #DDRPHY_OFFSETR_CON0]
+	str	r7, [r5, #DDRPHY_OFFSETR_CON1]
+	ldr	r7, =0x7f
+	str	r7, [r5, #DDRPHY_OFFSETR_CON2]
+
+	ldr	r7, =0x7f7f7f7f
+	str	r7, [r5, #DDRPHY_OFFSETW_CON0]
+	str	r7, [r5, #DDRPHY_OFFSETW_CON1]
+	ldr	r7, =0x7f
+	str	r7, [r5, #DDRPHY_OFFSETW_CON2]
+
+	ldr	r7, =0x0
+	str	r7, [r5, #DDRPHY_CA_DSKEW_CON0]
+	str	r7, [r5, #DDRPHY_CA_DSKEW_CON1]
+	str	r7, [r5, #DDRPHY_CA_DSKEW_CON2]
+
+	ldr	r7, =0x100007f
+	str	r7, [r5, #DDRPHY_OFFSETD_CON0]
+	ldr	r7, =0x7f
+	str	r7, [r5, #DDRPHY_OFFSETD_CON0]
+
+	.endm
+
+	.macro	switch_to_533m
+
+	ldr	r7, =0x10210100
+	str	r7, [r5, #DDRPHY_PHY_CON1]
+
+	/* dram root set to from dram main, div by 2 */
+	ldr	r7, =0x10000001
+	ldr	r8, =0x9880
+	str	r7, [r2, r8]
+
+	ldr	r7, =0x02020070
+	str	r7, [r5, #DDRPHY_MDLL_CON0]
+
+	ldr	r7, =0x10000008
+	str	r7, [r5, #DDRPHY_OFFSETD_CON0]
+
+	ldr	r7, =0x08080808
+	str	r7, [r5, #DDRPHY_OFFSETR_CON0]
+	str	r7, [r5, #DDRPHY_OFFSETR_CON1]
+	ldr	r7, =0x8
+	str	r7, [r5, #DDRPHY_OFFSETR_CON2]
+
+	ldr	r7, =0x08080808
+	str	r7, [r5, #DDRPHY_OFFSETW_CON0]
+	str	r7, [r5, #DDRPHY_OFFSETW_CON1]
+	ldr	r7, =0x8
+	str	r7, [r5, #DDRPHY_OFFSETW_CON2]
+
+	ldr	r7, =0x08080808
+	str	r7, [r5, #DDRPHY_CA_DSKEW_CON0]
+	str	r7, [r5, #DDRPHY_CA_DSKEW_CON1]
+	ldr	r7, =0x0808
+	str	r7, [r5, #DDRPHY_CA_DSKEW_CON2]
+
+	ldr	r7, =0x11000008
+	str	r7, [r5, #DDRPHY_OFFSETD_CON0]
+	ldr	r7, =0x10000008
+	str	r7, [r5, #DDRPHY_OFFSETD_CON0]
+
+	ldr	r6, =0x4
+8:
+	ldr	r7, [r5, #DDRPHY_MDLL_CON1]
+	and	r7, r7, r6
+	cmp	r7, r6
+	bne	8b
+
+	.endm
+
+ENTRY(imx_lpddr3_freq_change)
+	push	{r2 - r8}
+
+	/*
+	 * To ensure no page table walks occur in DDR, we
+	 * have a another page table stored in IRAM that only
+	 * contains entries pointing to IRAM, AIPS1 and AIPS2.
+	 * We need to set the TTBR1 to the new IRAM TLB.
+	 * Do the following steps:
+	 * 1. Flush the Branch Target Address Cache (BTAC)
+	 * 2. Set TTBR1 to point to IRAM page table.
+	 * 3. Disable page table walks in TTBR0 (PD0 = 1)
+	 * 4. Set TTBR0.N=1, implying 0-2G is translated by TTBR0
+	 *     and 2-4G is translated by TTBR1.
+	 */
+
+	ldr	r6, =iram_tlb_phys_addr
+	ldr	r7, [r6]
+
+	/* Flush the Branch Target Address Cache (BTAC) */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c7, c1, 6
+
+	/* Disable Branch Prediction, Z bit in SCTLR. */
+	mrc	p15, 0, r6, c1, c0, 0
+	bic	r6, r6, #0x800
+	mcr	p15, 0, r6, c1, c0, 0
+
+	dsb
+	isb
+	/* Store the IRAM table in TTBR1 */
+	mcr	p15, 0, r7, c2, c0, 1
+
+	/* Read TTBCR and set PD0=1, N = 1 */
+	mrc	p15, 0, r6, c2, c0, 2
+	orr	r6, r6, #0x11
+	mcr	p15, 0, r6, c2, c0, 2
+
+	dsb
+	isb
+
+	/* flush the TLB */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c8, c3, 0
+
+	/* Disable L1 data cache. */
+	mrc	p15, 0, r6, c1, c0, 0
+	bic	r6, r6, #0x4
+	mcr	p15, 0, r6, c1, c0, 0
+
+	dsb
+	isb
+
+	ldr	r2, =IMX_IO_P2V(MX7D_CCM_BASE_ADDR)
+	ldr	r3, =IMX_IO_P2V(MX7D_IOMUXC_GPR_BASE_ADDR)
+	ldr	r4, =IMX_IO_P2V(MX7D_DDRC_BASE_ADDR)
+	ldr	r5, =IMX_IO_P2V(MX7D_DDRC_PHY_BASE_ADDR)
+
+	ddrc_prepare
+
+	ldr	r6, =100000000
+	cmp	r0, r6
+	bgt	set_to_533m
+
+set_to_below_100m:
+	switch_to_below_100m
+	b	done
+
+set_to_533m:
+	switch_to_533m
+	b	done
+
+done:
+	ddrc_done
+
+	/* Enable L1 data cache. */
+	mrc	p15, 0, r6, c1, c0, 0
+	orr	r6, r6, #0x4
+	mcr	p15, 0, r6, c1, c0, 0
+
+	/* Restore the TTBCR */
+	dsb
+	isb
+
+	/* Read TTBCR and set PD0=0, N = 0 */
+	mrc	p15, 0, r6, c2, c0, 2
+	bic	r6, r6, #0x11
+	mcr	p15, 0, r6, c2, c0, 2
+	dsb
+	isb
+
+	/* flush the TLB */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c8, c3, 0
+
+	dsb
+	isb
+
+	/* Enable Branch Prediction, Z bit in SCTLR. */
+	mrc	p15, 0, r6, c1, c0, 0
+	orr	r6, r6, #0x800
+	mcr	p15, 0, r6, c1, c0, 0
+
+	/* Flush the Branch Target Address Cache (BTAC) */
+	ldr	r6, =0x0
+	mcr	p15, 0, r6, c7, c1, 6
+
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	/* Restore registers */
+	pop	{r2 - r8}
+	mov	pc, lr
+ENDPROC(imx_lpddr3_freq_change)
diff --git a/arch/arm/mach-imx/mach-imx7d.c b/arch/arm/mach-imx/mach-imx7d.c
index ecf6266..a6dfcec 100644
--- a/arch/arm/mach-imx/mach-imx7d.c
+++ b/arch/arm/mach-imx/mach-imx7d.c
@@ -103,6 +103,7 @@ static void __init imx7d_map_io(void)
 {
 	debug_ll_io_init();
 	imx7_pm_map_io();
+	imx_busfreq_map_io();
 }
 
 DT_MACHINE_START(IMX7D, "Freescale i.MX7 Dual (Device Tree)")
diff --git a/arch/arm/mach-imx/mx7.h b/arch/arm/mach-imx/mx7.h
index 1fc69f4..2f387e0 100644
--- a/arch/arm/mach-imx/mx7.h
+++ b/arch/arm/mach-imx/mx7.h
@@ -39,4 +39,10 @@
 
 #define TT_ATTRIB_NON_CACHEABLE_1M	0x802
 #define MX7_IRAM_TLB_SIZE		0x4000
+#define MX7_SUSPEND_OCRAM_SIZE		0x1000
+#define MX7_CPUIDLE_OCRAM_ADDR_OFFSET	0x1000
+#define MX7_CPUIDLE_OCRAM_SIZE		0x1000
+#define MX7_BUSFREQ_OCRAM_ADDR_OFFSET	0x2000
+#define MX7_BUSFREQ_OCRAM_SIZE		0x1000
+
 #endif
diff --git a/arch/arm/mach-imx/pm-imx7.c b/arch/arm/mach-imx/pm-imx7.c
index fecee66..cafe64f 100644
--- a/arch/arm/mach-imx/pm-imx7.c
+++ b/arch/arm/mach-imx/pm-imx7.c
@@ -58,8 +58,8 @@
 #define UART_UBRC	0xac
 #define UART_UTS	0xb4
 
-unsigned long imx7_iram_tlb_base_addr;
-unsigned long imx7_iram_tlb_phys_addr;
+extern unsigned long iram_tlb_base_addr;
+extern unsigned long iram_tlb_phys_addr;
 
 static unsigned int *ocram_saved_in_ddr;
 static void __iomem *ocram_base;
@@ -312,7 +312,7 @@ static int imx7_pm_enter(suspend_state_t state)
 {
 	unsigned int console_saved_reg[10] = {0};
 
-	if (!imx7_iram_tlb_base_addr) {
+	if (!iram_tlb_base_addr) {
 		pr_warn("No IRAM/OCRAM memory allocated for suspend/resume \
 			 code. Please ensure device tree has an entry for \
 			 fsl,lpm-sram.\n");
@@ -388,8 +388,8 @@ static int __init imx7_dt_find_lpsram(unsigned long node, const char *uname,
 		/* We need to create a 1M page table entry. */
 		iram_tlb_io_desc.virtual = IMX_IO_P2V(lpram_addr & 0xFFF00000);
 		iram_tlb_io_desc.pfn = __phys_to_pfn(lpram_addr & 0xFFF00000);
-		imx7_iram_tlb_phys_addr = lpram_addr;
-		imx7_iram_tlb_base_addr = IMX_IO_P2V(lpram_addr);
+		iram_tlb_phys_addr = lpram_addr;
+		iram_tlb_base_addr = IMX_IO_P2V(lpram_addr);
 		iotable_init(&iram_tlb_io_desc, 1);
 	}
 
@@ -408,13 +408,13 @@ void __init imx7_pm_map_io(void)
 	WARN_ON(of_scan_flat_dt(imx7_dt_find_lpsram, NULL));
 
 	/* Return if no IRAM space is allocated for suspend/resume code. */
-	if (!imx7_iram_tlb_base_addr) {
+	if (!iram_tlb_base_addr) {
 		pr_warn("No valid ocram avaiable for suspend/resume!\n");
 		return;
 	}
 
 	/* Set all entries to 0. */
-	memset((void *)imx7_iram_tlb_base_addr, 0, MX7_IRAM_TLB_SIZE);
+	memset((void *)iram_tlb_base_addr, 0, MX7_IRAM_TLB_SIZE);
 
 	/*
 	 * Make sure the IRAM virtual address has a mapping in the IRAM
@@ -424,9 +424,9 @@ void __init imx7_pm_map_io(void)
 	 * address in the page table as only these bits are required
 	 * for 1M mapping.
 	 */
-	j = ((imx7_iram_tlb_base_addr >> 20) << 2) / 4;
-	*((unsigned long *)imx7_iram_tlb_base_addr + j) =
-		(imx7_iram_tlb_phys_addr & 0xFFF00000) | TT_ATTRIB_NON_CACHEABLE_1M;
+	j = ((iram_tlb_base_addr >> 20) << 2) / 4;
+	*((unsigned long *)iram_tlb_base_addr + j) =
+		(iram_tlb_phys_addr & 0xFFF00000) | TT_ATTRIB_NON_CACHEABLE_1M;
 
 	/*
 	 * Make sure the AIPS1 virtual address has a mapping in the
@@ -434,7 +434,7 @@ void __init imx7_pm_map_io(void)
 	 */
 	for (i = 0; i < 4; i++) {
 		j = ((IMX_IO_P2V(MX7D_AIPS1_BASE_ADDR + i * 0x100000) >> 20) << 2) / 4;
-		*((unsigned long *)imx7_iram_tlb_base_addr + j) =
+		*((unsigned long *)iram_tlb_base_addr + j) =
 			((MX7D_AIPS1_BASE_ADDR + i * 0x100000) & 0xFFF00000) |
 			TT_ATTRIB_NON_CACHEABLE_1M;
 	}
@@ -445,7 +445,7 @@ void __init imx7_pm_map_io(void)
 	 */
 	for (i = 0; i < 4; i++) {
 		j = ((IMX_IO_P2V(MX7D_AIPS2_BASE_ADDR + i * 0x100000) >> 20) << 2) / 4;
-		*((unsigned long *)imx7_iram_tlb_base_addr + j) =
+		*((unsigned long *)iram_tlb_base_addr + j) =
 			((MX7D_AIPS2_BASE_ADDR + i * 0x100000) & 0xFFF00000) |
 			TT_ATTRIB_NON_CACHEABLE_1M;
 	}
@@ -456,7 +456,7 @@ void __init imx7_pm_map_io(void)
 	 */
 	for (i = 0; i < 4; i++) {
 		j = ((IMX_IO_P2V(MX7D_AIPS3_BASE_ADDR + i * 0x100000) >> 20) << 2) / 4;
-		*((unsigned long *)imx7_iram_tlb_base_addr + j) =
+		*((unsigned long *)iram_tlb_base_addr + j) =
 			((MX7D_AIPS3_BASE_ADDR + i * 0x100000) & 0xFFF00000) |
 			TT_ATTRIB_NON_CACHEABLE_1M;
 	}
@@ -484,7 +484,7 @@ static int __init imx7_suspend_init(const struct imx7_pm_socdata *socdata)
 	 * pm_info.
 	 *
 	 */
-	iram_paddr = imx7_iram_tlb_phys_addr + MX7_SUSPEND_IRAM_ADDR_OFFSET;
+	iram_paddr = iram_tlb_phys_addr + MX7_SUSPEND_IRAM_ADDR_OFFSET;
 
 	/* Make sure iram_paddr is 8 byte aligned. */
 	if ((uintptr_t)(iram_paddr) & (FNCPY_ALIGN - 1))
@@ -608,7 +608,7 @@ void __init imx7d_pm_init(void)
 	else if (imx_ddrc_get_ddr_type() == IMX_DDR_TYPE_DDR3)
 		imx7_pm_common_init(&imx7d_pm_data_ddr3);
 
-	np = of_find_compatible_node(NULL, NULL, "mmio-sram");
+	np = of_find_compatible_node(NULL, NULL, "fsl,mega-fast-sram");
 	ocram_base = of_iomap(np, 0);
 	WARN_ON(!ocram_base);
 	WARN_ON(of_address_to_resource(np, 0, &res));
diff --git a/arch/arm/mach-imx/smp_wfe.S b/arch/arm/mach-imx/smp_wfe.S
new file mode 100644
index 0000000..08894bb
--- /dev/null
+++ b/arch/arm/mach-imx/smp_wfe.S
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/linkage.h>
+#include <asm/smp_scu.h>
+#include "hardware.h"
+
+	.macro	disable_l1_dcache
+
+	/*
+	 * Flush all data from the L1 data cache before disabling
+	 * SCTLR.C bit.
+	 */
+	push	{r0 - r10, lr}
+	ldr	r7, =v7_flush_dcache_all
+	mov	lr, pc
+	mov	pc, r7
+	pop	{r0 - r10, lr}
+
+	/* disable d-cache */
+	mrc	p15, 0, r7, c1, c0, 0
+	bic	r7, r7, #(1 << 2)
+	mcr	p15, 0, r7, c1, c0, 0
+	dsb
+	isb
+
+	push	{r0 - r10, lr}
+	ldr	r7, =v7_flush_dcache_all
+	mov	lr, pc
+	mov	pc, r7
+	pop	{r0 - r10, lr}
+
+	.endm
+
+#ifdef CONFIG_SMP
+	.align 3
+
+ENTRY(imx7_smp_wfe)
+	push	{r4 - r11, lr}
+
+	dsb
+	isb
+
+	disable_l1_dcache
+
+	isb
+
+	/* Turn off SMP bit. */
+	mrc	p15, 0, r8, c1, c0, 1
+	bic	r8, r8, #0x40
+	mcr	p15, 0, r8, c1, c0, 1
+
+	isb
+	/* Set flag of entering WFE. */
+	mov	r7, #0xff
+	lsl	r7, r7, r0
+	mov	r6, #SCU_PM_DORMANT
+	lsl	r6, r6, r0
+	ldr	r8, [r1, #0x4]
+	bic	r8, r8, r7
+	orr	r6, r6, r8
+	str	r6, [r1, #0x4]
+
+go_back_wfe:
+	wfe
+
+	/* Offset 0x0 stores busfeq done flag */
+	ldr	r6, [r1]
+	cmp	r6, #1
+	beq	go_back_wfe
+
+	/* Turn ON SMP bit. */
+	mrc	p15, 0, r8, c1, c0, 1
+	orr	r8, r8, #0x40
+	mcr	p15, 0, r8, c1, c0, 1
+
+	isb
+	/* Enable L1 data cache. */
+	mrc	p15, 0, r8, c1, c0, 0
+	orr	r8, r8, #0x4
+	mcr	p15, 0, r8, c1, c0, 0
+	isb
+
+	/* Set flag of exiting WFE. */
+	mov	r7, #0xff
+	lsl	r7, r7, r0
+	mov	r6, #SCU_PM_NORMAL
+	lsl	r6, r6, r0
+	ldr	r8, [r1, #0x4]
+	bic	r8, r8, r7
+	orr	r6, r6, r8
+	str	r6, [r1, #0x4]
+
+	/* Pop all saved registers. */
+	pop	{r4 - r11, lr}
+	mov	pc, lr
+	.ltorg
+ENDPROC(imx7_smp_wfe)
+#endif
diff --git a/arch/arm/mach-imx/suspend-imx7.S b/arch/arm/mach-imx/suspend-imx7.S
index cb5a1b4..37dfb39 100644
--- a/arch/arm/mach-imx/suspend-imx7.S
+++ b/arch/arm/mach-imx/suspend-imx7.S
@@ -102,7 +102,7 @@
 	ldr	r6, =0x0
 	mcr	p15, 0, r6, c7, c1, 6
 
-	ldr	r6, =imx7_iram_tlb_phys_addr
+	ldr	r6, =iram_tlb_phys_addr
 	ldr	r6, [r6]
 	dsb
 	isb
@@ -283,6 +283,7 @@
 	orr	r7, r7, #0x1
 	str	r7, [r11, r6]
 	/* turn off ddr power */
+	ldr	r11, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]
 	ldr	r7, =(0x1 << 29)
 	str	r7, [r11, #ANADIG_SNVS_MISC_CTRL]
 
-- 
1.7.5.4

