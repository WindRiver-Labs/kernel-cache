From cfe304c7f2da637f54aeab8aa7d2b45f44763438 Mon Sep 17 00:00:00 2001
From: Limeng <Meng.Li@windriver.com>
Date: Tue, 29 Mar 2016 09:42:10 +0800
Subject: [PATCH] driver: dma: imx-sdma: fix a rt kernel crash issue when play
 audio with HDMI interface

When play audio with HDMI interface, imx-sdam is used. Call function
sdma_load_context() to config sdma channel, in this function, we use
the field channel_0_lock of struct sdma_engine to protect critical
region. In critical region, we call sdma_run_channel0() to enable
sdma channel 0. In sdma_run_channel0(), we intend to enable sdma
channel 0 and then use poll loop to check interrupt status of channel
0. But after enable channel 0, interrupt comes immediately, interrupt
handler is called right away. In interrupt handler, channel 0
interrupt is not processed, interrupt status bit of channel 0 is not
cleared. So interrupt occur continuously, and result in other threads
are not able to achieve opportunity to run, finally, cause kernel
crash.
Detail core trace as below:
INFO: rcu_preempt self-detected stall on CPU
        0: (2100 ticks this GP) idle=1db/140000000000001/0 softirq=0/0 fqs=0
         (t=2100 jiffies g=8724 c=8723 q=2084)
rcu_preempt kthread starved for 2100 jiffies!
Task dump for CPU 0:
irq/284-sdma    R running      0    73      2 0x00000000
[<80019f9c>] (unwind_backtrace) from [<80013adc>] (show_stack+0x20/0x24)
[<80013adc>] (show_stack) from [<800632cc>] (sched_show_task+0xcc/0xec)
[<800632cc>] (sched_show_task) from [<80066ed4>] (dump_cpu_task+0x3c/0x50)
[<80066ed4>] (dump_cpu_task) from [<8008b4b4>] (rcu_dump_cpu_stacks+0x80/0xa4)
[<8008b4b4>] (rcu_dump_cpu_stacks) from [<8008fc4c>] (rcu_check_callbacks+0x314/0x8d8)
[<8008fc4c>] (rcu_check_callbacks) from [<80094f18>] (update_process_times+0x44/0x6c)
[<80094f18>] (update_process_times) from [<800a62a8>] (tick_sched_timer+0x2c4/0x338)
[<800a62a8>] (tick_sched_timer) from [<80095f34>] (__run_hrtimer+0x1d0/0x338)
[<80095f34>] (__run_hrtimer) from [<80096c24>] (hrtimer_interrupt+0x128/0x364)
[<80096c24>] (hrtimer_interrupt) from [<80017c8c>] (twd_handler+0x3c/0x48)
[<80017c8c>] (twd_handler) from [<80085f48>] (handle_percpu_devid_irq+0x104/0x1ec)
[<80085f48>] (handle_percpu_devid_irq) from [<80081448>] (generic_handle_irq+0x30/0x40)
[<80081448>] (generic_handle_irq) from [<80081798>] (__handle_domain_irq+0xb0/0xf0)
[<80081798>] (__handle_domain_irq) from [<80009458>] (gic_handle_irq+0x4c/0x6c)
[<80009458>] (gic_handle_irq) from [<80014640>] (__irq_svc+0x40/0x88)
Exception stack(0xa8c19e98 to 0xa8c19ee0)
9e80:                                                       3e6f00df 843e1160
9ea0: d06d4751 494b0a25 28d36a9c 00000000 ab5fb190 80ca6190 2a955000 00003517
9ec0: 8008320c a8c19f1c a8c19ec8 a8c19ee0 803bb870 8047f1e0 200f0113 ffffffff
[<80014640>] (__irq_svc) from [<8047f1e0>] (add_interrupt_randomness+0xd8/0x190)
[<8047f1e0>] (add_interrupt_randomness) from [<8008320c>] (irq_thread+0x1a0/0x220)
[<8008320c>] (irq_thread) from [<80056ac8>] (kthread+0xec/0x100)
[<80056ac8>] (kthread) from [<8000f4e8>] (ret_from_fork+0x14/0x2c)

Therefore, we add spinlock channel_0_lock in interrupt handler to
make sure that it will not run until channel 0 configuration is over in
sdma_load_context().

Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/dma/imx-sdma.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/drivers/dma/imx-sdma.c b/drivers/dma/imx-sdma.c
index caf1bc3..985bfdc 100644
--- a/drivers/dma/imx-sdma.c
+++ b/drivers/dma/imx-sdma.c
@@ -755,10 +755,12 @@ static irqreturn_t sdma_int_handler(int irq, void *dev_id)
 	struct sdma_engine *sdma = dev_id;
 	unsigned long stat, flags;
 
+	spin_lock_irqsave(&sdma->channel_0_lock, flags);
 	stat = readl_relaxed(sdma->regs + SDMA_H_INTR);
 	/* not interested in channel 0 interrupts */
 	stat &= ~1;
 	writel_relaxed(stat, sdma->regs + SDMA_H_INTR);
+	spin_unlock_irqrestore(&sdma->channel_0_lock, flags);
 
 	while (stat) {
 		int channel = fls(stat) - 1;
-- 
1.7.5.4

