From aa02506f945ff89c8d089b046d91307ac7939383 Mon Sep 17 00:00:00 2001
From: Anson Huang <b20788@freescale.com>
Date: Fri, 16 Jan 2015 21:16:35 +0800
Subject: [PATCH 0413/1594] MLK-10106 thermal: imx: correct clk enable and
 thermal sensor init sequence

commit b8a87778acfdc57089e34337f1880b6b3e269f32 from
git://git.freescale.com/imx/linux-2.6-imx.git

thermal sensor's irq init should be done after clk enabled, also,
the low alarm value should be set correctly before clearing its
irq status.

Signed-off-by: Anson Huang <b20788@freescale.com>
Signed-off-by: Bai Ping <b51503@freescale.com>
---
 drivers/thermal/imx_thermal.c |   69 +++++++++++++++++++---------------------
 1 files changed, 33 insertions(+), 36 deletions(-)

diff --git a/drivers/thermal/imx_thermal.c b/drivers/thermal/imx_thermal.c
index a425729..ea0ccce 100644
--- a/drivers/thermal/imx_thermal.c
+++ b/drivers/thermal/imx_thermal.c
@@ -538,30 +538,45 @@ static int imx_thermal_probe(struct platform_device *pdev)
 
 	data->socdata = of_id->data;
 
+	data->thermal_clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(data->thermal_clk)) {
+		ret = PTR_ERR(data->thermal_clk);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev,
+				"failed to get thermal clk: %d\n", ret);
+		return ret;
+	}
+
+	/*
+	 * Thermal sensor needs clk on to get correct value, normally
+	 * we should enable its clk before taking measurement and disable
+	 * clk after measurement is done, but if alarm function is enabled,
+	 * hardware will auto measure the temperature periodically, so we
+	 * need to keep the clk always on for alarm function.
+	 */
+	ret = clk_prepare_enable(data->thermal_clk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable thermal clk: %d\n", ret);
+		return ret;
+	}
+
 	/* make sure the IRQ flag is clear before enabling irq on i.MX6SX */
+	regmap_write(map, MISC1 + REG_CLR, MISC1_IRQ_TEMPHIGH);
 	if (data->socdata->version == TEMPMON_IMX6SX) {
-		regmap_write(map, MISC1 + REG_CLR, MISC1_IRQ_TEMPHIGH |
-			MISC1_IRQ_TEMPLOW | MISC1_IRQ_TEMPPANIC);
 		/*
 		 * reset value of LOW ALARM is incorrect, set it to lowest
 		 * value to avoid false trigger of low alarm.
 		 */
 		regmap_write(map, TEMPSENSE2 + REG_SET,
 			TEMPSENSE2_LOW_VALUE_MASK);
+		regmap_write(map, MISC1 + REG_CLR, MISC1_IRQ_TEMPHIGH |
+			MISC1_IRQ_TEMPLOW | MISC1_IRQ_TEMPPANIC);
 	}
 
 	data->irq = platform_get_irq(pdev, 0);
 	if (data->irq < 0)
 		return data->irq;
 
-	ret = devm_request_threaded_irq(&pdev->dev, data->irq,
-			imx_thermal_alarm_irq, imx_thermal_alarm_irq_thread,
-			0, "imx_thermal", data);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "failed to request alarm irq: %d\n", ret);
-		return ret;
-	}
-
 	platform_set_drvdata(pdev, data);
 
 	ret = imx_get_sensor_data(pdev);
@@ -595,32 +610,6 @@ static int imx_thermal_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	data->thermal_clk = devm_clk_get(&pdev->dev, NULL);
-	if (IS_ERR(data->thermal_clk)) {
-		ret = PTR_ERR(data->thermal_clk);
-		if (ret != -EPROBE_DEFER)
-			dev_err(&pdev->dev,
-				"failed to get thermal clk: %d\n", ret);
-		cpufreq_cooling_unregister(data->cdev[0]);
-		devfreq_cooling_unregister(data->cdev[1]);
-		return ret;
-	}
-
-	/*
-	 * Thermal sensor needs clk on to get correct value, normally
-	 * we should enable its clk before taking measurement and disable
-	 * clk after measurement is done, but if alarm function is enabled,
-	 * hardware will auto measure the temperature periodically, so we
-	 * need to keep the clk always on for alarm function.
-	 */
-	ret = clk_prepare_enable(data->thermal_clk);
-	if (ret) {
-		dev_err(&pdev->dev, "failed to enable thermal clk: %d\n", ret);
-		cpufreq_cooling_unregister(data->cdev[0]);
-		devfreq_cooling_unregister(data->cdev[1]);
-		return ret;
-	}
-
 	data->tz = thermal_zone_device_register("imx_thermal_zone",
 						IMX_TRIP_NUM,
 						(1 << IMX_TRIP_NUM) - 1, data,
@@ -649,6 +638,14 @@ static int imx_thermal_probe(struct platform_device *pdev)
 	regmap_write(map, TEMPSENSE0 + REG_CLR, TEMPSENSE0_POWER_DOWN);
 	regmap_write(map, TEMPSENSE0 + REG_SET, TEMPSENSE0_MEASURE_TEMP);
 
+	ret = devm_request_threaded_irq(&pdev->dev, data->irq,
+			imx_thermal_alarm_irq, imx_thermal_alarm_irq_thread,
+			0, "imx_thermal", data);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to request alarm irq: %d\n", ret);
+		return ret;
+	}
+
 	data->irq_enabled = true;
 	data->mode = THERMAL_DEVICE_ENABLED;
 	/* register the busfreq notifier called in low bus freq */
-- 
1.7.5.4

