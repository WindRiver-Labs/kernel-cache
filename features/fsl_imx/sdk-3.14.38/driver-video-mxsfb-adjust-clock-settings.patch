From 756a9efae05a30ded32da3b49c9e160f65d34a61 Mon Sep 17 00:00:00 2001
From: Limeng <Meng.Li@windriver.com>
Date: Thu, 11 Feb 2016 21:48:12 +0800
Subject: [PATCH 1583/1594] driver: video: mxsfb: adjust clock settings

The lcdif controller registers should be accessed when the clock is
enabled, otherwise the bus will be hang. So the clock enable/disable
logic should be adjusted concequently.

Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/video/fbdev/mxsfb.c |   75 +++++++++++++++++++++++++++----------------
 1 files changed, 47 insertions(+), 28 deletions(-)

diff --git a/drivers/video/fbdev/mxsfb.c b/drivers/video/fbdev/mxsfb.c
index 06028fb..9d84e07 100644
--- a/drivers/video/fbdev/mxsfb.c
+++ b/drivers/video/fbdev/mxsfb.c
@@ -203,6 +203,8 @@ struct mxsfb_info {
 	struct clk *clk;
 	struct clk *clk_axi;
 	struct clk *clk_disp_axi;
+	bool clk_pix_enabled;
+	bool clk_axi_enabled;
 	bool clk_disp_axi_enabled;
 	void __iomem *base;	/* registers */
 	u32 sync;		/* record display timing polarities */
@@ -463,14 +465,36 @@ static int mxsfb_check_var(struct fb_var_screeninfo *var,
 
 static inline void mxsfb_enable_axi_clk(struct mxsfb_info *host)
 {
-	if (host->clk_axi)
+	if (!host->clk_axi_enabled && (host->clk_axi != NULL)) {
 		clk_prepare_enable(host->clk_axi);
+		host->clk_axi_enabled = true;
+	}
 }
 
 static inline void mxsfb_disable_axi_clk(struct mxsfb_info *host)
 {
-	if (host->clk_axi)
+	if (host->clk_axi_enabled && (host->clk_axi != NULL)) {
 		clk_disable_unprepare(host->clk_axi);
+		host->clk_axi_enabled = false;
+	}
+}
+
+/* enable lcdif pix clock */
+static inline void clk_enable_pix(struct mxsfb_info *host)
+{
+	if (!host->clk_pix_enabled && (host->clk != NULL)) {
+		clk_prepare_enable(host->clk);
+		host->clk_pix_enabled = true;
+	}
+}
+
+/* disable lcdif pix clock */
+static inline void clk_disable_pix(struct mxsfb_info *host)
+{
+	if (host->clk_pix_enabled && (host->clk != NULL)) {
+		clk_disable_unprepare(host->clk);
+		host->clk_pix_enabled = false;
+	}
 }
 
 static void mxsfb_enable_controller(struct fb_info *fb_info)
@@ -500,12 +524,14 @@ static void mxsfb_enable_controller(struct fb_info *fb_info)
 		}
 	}
 
-	if (host->clk_disp_axi)
-		clk_prepare_enable(host->clk_disp_axi);
+	pm_runtime_get_sync(&host->pdev->dev);
+	mxsfb_enable_axi_clk(host);
+	clk_enable_disp_axi(host);
+
 	/* the pixel clock should be disabled before
 	 * trying to set its clock rate successfully.
 	 */
-	clk_disable_unprepare(host->clk);
+	clk_disable_pix(host);
 	ret = clk_set_rate(host->clk,
 			 PICOS2KHZ(fb_info->var.pixclock) * 1000U);
 	if (ret) {
@@ -521,11 +547,7 @@ static void mxsfb_enable_controller(struct fb_info *fb_info)
 		}
 		return;
 	}
-	clk_prepare_enable(host->clk);
-
-	pm_runtime_get_sync(&host->pdev->dev);
-	mxsfb_enable_axi_clk(host);
-	clk_enable_disp_axi(host);
+	clk_enable_pix(host);
 
 	/* Clean soft reset and clock gate bit if it was enabled  */
 	writel(CTRL_SFTRST | CTRL_CLKGATE, host->base + LCDC_CTRL + REG_CLR);
@@ -573,6 +595,8 @@ static void mxsfb_disable_controller(struct fb_info *fb_info)
 		host->dispdrv->drv->disable(host->dispdrv, fb_info);
 
 	clk_enable_disp_axi(host);
+	mxsfb_enable_axi_clk(host);
+	clk_enable_pix(host);
 	/*
 	 * Even if we disable the controller here, it will still continue
 	 * until its FIFOs are running out of data
@@ -593,10 +617,8 @@ static void mxsfb_disable_controller(struct fb_info *fb_info)
 	writel(reg & ~VDCTRL4_SYNC_SIGNALS_ON, host->base + LCDC_VDCTRL4);
 
 	mxsfb_disable_axi_clk(host);
-
-	clk_disable_unprepare(host->clk);
-	if (host->clk_disp_axi)
-		clk_disable_unprepare(host->clk_disp_axi);
+	clk_disable_pix(host);
+	clk_disable_disp_axi(host);
 
 	pm_runtime_put_sync_suspend(&host->pdev->dev);
 
@@ -630,7 +652,7 @@ static int mxsfb_set_par(struct fb_info *fb_info)
 
 	mxsfb_enable_axi_clk(host);
 	clk_enable_disp_axi(host);
-	clk_prepare_enable(host->clk);
+	clk_enable_pix(host);
 
 	sema_init(&host->flip_sem, 1);
 
@@ -744,8 +766,6 @@ static int mxsfb_set_par(struct fb_info *fb_info)
 			fb_info->fix.line_length * fb_info->var.yoffset,
 			host->base + host->devdata->next_buf);
 
-	mxsfb_disable_axi_clk(host);
-
 	if (reenable)
 		mxsfb_enable_controller(fb_info);
 
@@ -850,7 +870,6 @@ static int mxsfb_blank(int blank, struct fb_info *fb_info)
 		if (host->enabled)
 			mxsfb_disable_controller(fb_info);
 
-		clk_disable_disp_axi(host);
 		break;
 
 	case FB_BLANK_UNBLANK:
@@ -885,8 +904,9 @@ static int mxsfb_pan_display(struct fb_var_screeninfo *var,
 		return -EINVAL;
 	}
 
+	mxsfb_enable_axi_clk(host);
 	clk_enable_disp_axi(host);
-	clk_prepare_enable(host->clk);
+	clk_enable_pix(host);
 
 	offset = fb_info->fix.line_length * var->yoffset;
 
@@ -895,8 +915,6 @@ static int mxsfb_pan_display(struct fb_var_screeninfo *var,
 		return -ETIMEDOUT;
 	}
 
-	mxsfb_enable_axi_clk(host);
-
 	/* update on next VSYNC */
 	writel(fb_info->fix.smem_start + offset,
 			host->base + host->devdata->next_buf);
@@ -969,7 +987,7 @@ static int mxsfb_restore_mode(struct mxsfb_info *host)
 	 * when the pixel clock is enabled, otherwise
 	 * the bus will be hang.
 	 */
-	clk_prepare_enable(host->clk);
+	clk_enable_pix(host);
 
 	/* Only restore the mode when the controller is running */
 	ctrl = readl(host->base + LCDC_CTRL);
@@ -1369,7 +1387,7 @@ static int mxsfb_probe(struct platform_device *pdev)
 
 	host->devdata = &mxsfb_devdata[pdev->id_entry->driver_data];
 
-	host->clk = devm_clk_get(&host->pdev->dev, NULL);
+	host->clk = devm_clk_get(&host->pdev->dev, "pix");
 	if (IS_ERR(host->clk)) {
 		host->clk = NULL;
 		ret = PTR_ERR(host->clk);
@@ -1377,12 +1395,11 @@ static int mxsfb_probe(struct platform_device *pdev)
 	}
 
 	host->clk_axi = devm_clk_get(&host->pdev->dev, "axi");
-	if (IS_ERR(host->clk_axi))
+	if (IS_ERR(host->clk_axi)) {
 		host->clk_axi = NULL;
-
-	host->clk_disp_axi = devm_clk_get(&host->pdev->dev, "disp_axi");
-	if (IS_ERR(host->clk_disp_axi))
-		host->clk_disp_axi = NULL;
+		ret = PTR_ERR(host->clk_axi);
+		goto fb_release;
+	}
 
 	host->clk_disp_axi = devm_clk_get(&host->pdev->dev, "disp_axi");
 	if (IS_ERR(host->clk_disp_axi)) {
@@ -1422,6 +1439,8 @@ static int mxsfb_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, fb_info);
 
+	mxsfb_enable_axi_clk(host);
+
 	if (!host->enabled) {
 		writel(0, host->base + LCDC_CTRL);
 		mxsfb_set_par(fb_info);
-- 
1.7.5.4

