From de1e1fcc0705db62c02b80098605bcb7dc50cd51 Mon Sep 17 00:00:00 2001
From: Robin Gong <b38343@freescale.com>
Date: Mon, 15 Sep 2014 13:36:30 +0800
Subject: [PATCH 0307/1594] ENGR00331450-5 ARM: imx: gpc: support PU bypass
 case

commit a710051b5cdacdca754212da2aef910e130bfeb5 from
git://git.freescale.com/imx/linux-2.6-imx.git

Current anatop regulator driver will force vddsoc->sel = 0 if vddsoc
bypassed in u-boot. That also make sel of vddpu = 0 because vddpu
track the same value with vddsoc. So we bypass vddpu firstly to flow
anatop driver rule.
Another thing is consider there is no vddpu regulator in i.mx6sx, we
need take care of this case in gpc driver.

Signed-off-by: Robin Gong <b38343@freescale.com>
---
 arch/arm/mach-imx/gpc.c |   20 +++++++++++++++-----
 1 files changed, 15 insertions(+), 5 deletions(-)

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 78b6fd0..cc6bad9 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2013 Freescale Semiconductor, Inc.
+ * Copyright 2011-2014 Freescale Semiconductor, Inc.
  * Copyright 2011 Linaro Ltd.
  *
  * The code contained herein is licensed under the GNU General Public
@@ -53,6 +53,7 @@ struct pu_domain {
 static void __iomem *gpc_base;
 static u32 gpc_wake_irqs[IMR_NUM];
 static u32 gpc_saved_imrs[IMR_NUM];
+static u32 bypass;
 
 void imx_gpc_set_arm_power_up_timing(u32 sw2iso, u32 sw)
 {
@@ -438,13 +439,22 @@ static int imx_gpc_probe(struct platform_device *pdev)
 	if (!of_property_read_bool(pdev->dev.of_node, "#power-domain-cells"))
 		return 0;
 
+	of_property_read_u32(pdev->dev.of_node, "fsl,ldo-bypass", &bypass);
 	pu_reg = devm_regulator_get_optional(&pdev->dev, "pu");
 	if (PTR_ERR(pu_reg) == -ENODEV)
 		pu_reg = NULL;
-	if (IS_ERR(pu_reg)) {
-		ret = PTR_ERR(pu_reg);
-		dev_err(&pdev->dev, "failed to get pu regulator: %d\n", ret);
-		return ret;
+	if (!IS_ERR(pu_reg)) {
+		/* The regulator is initially enabled */
+		ret = regulator_enable(pu_reg);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "failed to enable pu regulator: %d\n", ret);
+			return ret;
+		}
+		/* We only bypass pu since arm and soc has been set in u-boot */
+		if (bypass)
+			regulator_allow_bypass(pu_reg, true);
+	} else {
+		pu_reg = NULL;
 	}
 
 	return imx_gpc_genpd_init(&pdev->dev, pu_reg);
-- 
1.7.5.4

