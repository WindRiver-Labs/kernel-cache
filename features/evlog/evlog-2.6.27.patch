From 8aadb4b673b7632ba6ae1bcda86d7d5e90a91a37 Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Mon, 25 Aug 2008 16:52:41 +0800
Subject: [PATCH] evlog for 2.6.27

core code for event log. 

Integrated-by: Yongli he   <yongli.he@windriver.com>
Signed-off-by: MacDonald, Joe <Joe.MacDonald@windriver.com>

---
 include/linux/evlog.h |  136 +++++++++++++
 init/Kconfig          |   13 ++
 kernel/Makefile       |    1 +
 kernel/evlapi.c       |  443 +++++++++++++++++++++++++++++++++++++++++
 kernel/evlbuf.c       |  523 +++++++++++++++++++++++++++++++++++++++++++++++++
 kernel/printk.c       |   13 ++
 6 files changed, 1129 insertions(+), 0 deletions(-)
 create mode 100644 include/linux/evlog.h
 create mode 100644 kernel/evlapi.c
 create mode 100644 kernel/evlbuf.c

diff --git a/include/linux/evlog.h b/include/linux/evlog.h
new file mode 100644
index 0000000..75c3644
--- /dev/null
+++ b/include/linux/evlog.h
@@ -0,0 +1,136 @@
+/*
+ * Linux Event Logging
+ * Copyright (C) International Business Machines Corp., 2001
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *  Please send e-mail to kenistoj@users.sourceforge.net if you have
+ *  questions or comments.
+ *
+ *  Project Website:  http://evlog.sourceforge.net/
+ */
+
+#ifndef _LINUX_EVLOG_H
+#define _LINUX_EVLOG_H
+
+#include <stdarg.h>
+#include <linux/types.h>
+#include <asm/types.h>
+
+/* Values for log_flags member */
+#define EVL_TRUNCATE		0x1
+#define EVL_KERNEL_EVENT	0x2
+#define EVL_INITIAL_BOOT_EVENT	0x4
+#define EVL_KERNTIME_LOCAL	0x8
+#define EVL_INTERRUPT		0x10	/* Logged from interrupt context */
+#define EVL_PRINTK		0x20	/* Strip leading <n> when formatting */
+#define EVL_EVTYCRC		0x40	/* Daemon will set event type = CRC */
+					/* of format string. */
+
+/* Formats for optional portion of record. */
+#define EVL_NODATA    0
+#define EVL_BINARY    1
+#define EVL_STRING    2
+#define EVL_PRINTF    3
+
+/* Maximum length of variable portion of record */
+#define EVL_ENTRY_MAXLEN (8 * 1024)
+
+/* Facility (e.g., driver) names are truncated to 15+null. */
+#define FACILITY_MAXLEN 16
+
+/* struct kern_log_entry - kernel record header */
+struct kern_log_entry {
+	__u16	log_kmagic;	/* always LOGREC_KMAGIC */
+	__u16	log_kversion;	/* which version of this struct? */
+	__u16	log_size;	/* # bytes in variable part of record */
+	__s8	log_format;	/* BINARY, STRING, PRINTF, NODATA */
+	__s8	log_severity;	/* DEBUG, INFO, NOTICE, WARN, etc. */
+	__s32	log_event_type;	/* facility-specific event ID */
+	__u32	log_flags;	/* EVL_TRUNCATE, etc. */
+	__s32	log_processor;	/* CPU ID */
+	time_t	log_time_sec;
+	__s32	log_time_nsec;
+	uid_t	log_uid;	/* event context... */
+	gid_t	log_gid;
+	pid_t	log_pid;
+	pid_t	log_pgrp;
+	char	log_facility[FACILITY_MAXLEN];	/* e.g., driver name */
+};
+
+#define LOGREC_KMAGIC	0x7af8
+#define LOGREC_KVERSION	3
+
+/* Reserved Event Types */
+#define EVL_BUFFER_OVERRUN	0x6
+
+#ifdef __KERNEL__
+/*
+ * severities, AKA priorities
+ */
+#define LOG_EMERG   0   /* system is unusable */
+#define LOG_ALERT   1   /* action must be taken immediately */
+#define LOG_CRIT    2   /* critical conditions */
+#define LOG_ERR     3   /* error conditions */
+#define LOG_WARNING 4   /* warning conditions */
+#define LOG_NOTICE  5   /* normal but significant condition */
+#define LOG_INFO    6   /* informational */
+#define LOG_DEBUG   7   /* debug-level messages */
+
+/*
+ * A buffer to pack with data, one value at a time.  By convention, b_tail
+ * reflects the total amount you've attempted to add, and so may be past b_end.
+ */
+struct evl_recbuf {
+	char *b_buf;	/* start of buffer */
+	char *b_tail;	/* add next data here */
+	char *b_end;	/* b_buf + buffer size */
+	char *b_argsz;	/* points to argsz word in EVL_PRINTF-format record */
+	char *b_zapped_nl;	/* where terminating newline was */
+};
+
+#ifdef CONFIG_EVLOG
+extern int evl_write(const char *facility, int event_type,
+	int severity, const void *buf, size_t len, uint flags, int format);
+extern int evl_printk(const char *facility, int event_type, int sev,
+	const char *fmt, ...);
+extern int evl_vprintk(const char *facility, int event_type, int sev,
+	const char *fmt, va_list args);
+
+/* Functions for hand-constructing event records */
+extern void evl_init_recbuf(struct evl_recbuf *b, char *buf, size_t size);
+extern void evl_put(struct evl_recbuf *b, const void *data, size_t datasz);
+extern void evl_puts(struct evl_recbuf *b, const char *s, int null);
+extern void evl_zap_newline(struct evl_recbuf *b);
+extern void evl_unzap_newline(struct evl_recbuf *b);
+extern void evl_end_fmt(struct evl_recbuf *b);
+extern void evl_pack_args(struct evl_recbuf *b, const char *fmt, va_list args);
+extern void evl_end_args(struct evl_recbuf *b);
+extern size_t evl_datasz(struct evl_recbuf *b, uint *flags);
+#else	/* ! CONFIG_EVLOG */
+static inline int evl_write(const char *facility, int event_type,
+	int severity, const void *buf, size_t len, uint flags, int format)
+	{ return -ENOSYS; }
+static inline int evl_printk(const char *facility, int event_type, int sev,
+	const char *fmt, ...)
+	{ return -ENOSYS; }
+static inline int evl_vprintk(const char *facility, int event_type, int sev,
+	const char *fmt, va_list args)
+	{ return -ENOSYS; }
+#endif	/* CONFIG_EVLOG */
+
+#endif	/* __KERNEL__ */
+
+#endif	/* _LINUX_EVLOG_H */
diff --git a/init/Kconfig b/init/Kconfig
index dcd70e1..49b4995 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -238,6 +238,19 @@ config AUDIT_TREE
 	def_bool y
 	depends on AUDITSYSCALL && INOTIFY
 
+config EVLOG
+	bool "Event logging support"
+	---help---
+	  This enables support for event logging based upon the draft
+	  POSIX 1003.25 standard.  Enabling this feature does not
+	  affect the operation of the klog/syslog package in any way.
+	  In order to fully utilize this feature, user must also install
+	  the companion evlog package in user-space.
+
+	  For more information see http://evlog.sourceforge.net
+
+	  If you don't know what to do here, say N.
+
 config IKCONFIG
 	tristate "Kernel .config support"
 	---help---
diff --git a/kernel/Makefile b/kernel/Makefile
index 9b8118f..c97f2fb 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -67,6 +67,7 @@ obj-$(CONFIG_PID_NS) += pid_namespace.o
 obj-$(CONFIG_IKCONFIG) += configs.o
 obj-$(CONFIG_RESOURCE_COUNTERS) += res_counter.o
 obj-$(CONFIG_STOP_MACHINE) += stop_machine.o
+obj-$(CONFIG_EVLOG) += evlbuf.o evlapi.o
 obj-$(CONFIG_KPROBES_SANITY_TEST) += test_kprobes.o
 obj-$(CONFIG_AUDIT) += audit.o auditfilter.o
 obj-$(CONFIG_AUDITSYSCALL) += auditsc.o
diff --git a/kernel/evlapi.c b/kernel/evlapi.c
new file mode 100644
index 0000000..3ef81d9
--- /dev/null
+++ b/kernel/evlapi.c
@@ -0,0 +1,443 @@
+/*
+ * Linux Event Logging
+ * Copyright (C) International Business Machines Corp., 2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *  Please send e-mail to kenistoj@users.sourceforge.net if you have
+ *  questions or comments.
+ *
+ *  Project Website:  http://evlog.sourceforge.net/
+ */
+
+#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/stddef.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <linux/evlog.h>
+
+extern void evl_mk_rechdr(struct kern_log_entry *hdr,
+	const char *facility, int event_type, int severity, size_t size,
+	uint flags, int format);
+extern int evl_writeh(struct kern_log_entry *hdr, const char *vardata);
+
+/**
+ * evl_write() - write header + optional buffer to event handler
+ *
+ * @buf: optional variable-length data
+ * other args as per evl_mk_rechdr()
+ */
+int
+evl_write(const char *facility, int event_type, int severity, const void *buf,
+	size_t size, uint flags, int format)
+{
+	struct kern_log_entry hdr;
+
+	evl_mk_rechdr(&hdr, facility, event_type, severity, size, flags,
+		format);
+	return evl_writeh(&hdr, buf);
+}
+
+void
+evl_init_recbuf(struct evl_recbuf *b, char *buf, size_t size)
+{
+	b->b_buf = buf;
+	b->b_tail = buf;
+	b->b_end = buf + size;
+	b->b_zapped_nl = NULL;
+	b->b_argsz = NULL;
+}
+
+/**
+ * evl_put() - Append data to buffer; handle overflow.
+ * @b - describes buffer; updated to reflect data appended
+ * @data - data to append
+ * @datasz - data length in bytes
+ */
+void
+evl_put(struct evl_recbuf *b, const void *data, size_t datasz)
+{
+	ptrdiff_t room = b->b_end - b->b_tail;
+	if (room > 0) {
+		(void) memcpy(b->b_tail, data, min(datasz, (size_t)room));
+	}
+	b->b_tail += datasz;
+}
+
+/**
+ * evl_puts() - Append string to buffer; handle overflow.
+ * Append a string to the buffer.  If null == 1, we include the terminating
+ * null.  If the string extends over the end of the buffer, terminate the
+ * buffer with a null.
+ *
+ * @b - describes buffer; updated to reflect data appended
+ * @s - null-terminated string
+ * @null - 1 if we append the terminating null, 0 otherwise
+ */
+void
+evl_puts(struct evl_recbuf *b, const char *s, int null)
+{
+	char *old_tail = b->b_tail;
+	evl_put(b, s, strlen(s) + null);
+	if (b->b_tail > b->b_end && old_tail < b->b_end) {
+		*(b->b_end - 1) = '\0';
+	}
+}
+
+/**
+ * evl_zap_newline() - Delete newline at end of format string.
+ * Called after the format string has been copied into b.
+ * If the format ends in a newline, remove it.  We remove the
+ * terminating newline to increase flexibility when formatting
+ * the record for viewing.
+ */
+void
+evl_zap_newline(struct evl_recbuf *b)
+{
+	char *nl = b->b_tail - 2;
+	if (b->b_buf <= nl && nl < b->b_end && *nl == '\n') {
+		*nl = '\0';
+		b->b_tail--;
+		b->b_zapped_nl = nl;
+	}
+}
+
+/**
+ * evl_unzap_newline() - Replace previously zapped newline.
+ * NOTE: Replacing the newline (and advancing the terminating null)
+ * renders useless the contents of the record beyond the format string.
+ */
+void
+evl_unzap_newline(struct evl_recbuf *b)
+{
+	if (b->b_zapped_nl) {
+		b->b_zapped_nl[0] = '\n';
+		b->b_zapped_nl[1] = '\0';
+	}
+}
+
+/**
+ * evl_end_fmt() - Make and remember room for argsz word in EVL_PRINTF rec.
+ * Called after the format string has been copied in, but before the args.
+ * Store zero for now; evl_end_args() will store the actual size later.
+ */
+void
+evl_end_fmt(struct evl_recbuf *b)
+{
+	int argsz = 0;
+	b->b_argsz = b->b_tail;
+	evl_put(b, &argsz, sizeof(int));
+}
+
+/**
+ * evl_end_args() - For EVL_PRINTF record, store the argsz.
+ * Called after the args have been copied in.
+ */
+void
+evl_end_args(struct evl_recbuf *b)
+{
+	char *args;
+	int argsz;
+
+	if (! b->b_argsz) {
+		/* Nobody called evl_end_fmt(). */
+		return;
+	}
+	args = b->b_argsz + sizeof(int);
+	if (args > b->b_end) {
+		/* VERY long format string: even argsz is off end of record. */
+		return;
+	}
+	argsz = (int) (b->b_tail - args);
+	memcpy(b->b_argsz, &argsz, sizeof(int));
+}
+
+size_t
+evl_datasz(struct evl_recbuf *b, uint *flags)
+{
+	if (b->b_tail > b->b_end) {
+		*flags |= EVL_TRUNCATE;
+		return (size_t) (b->b_end - b->b_buf);
+	} else {
+		return (size_t) (b->b_tail - b->b_buf);
+	}
+}
+
+static inline void
+skip_atoi(const char **s)
+{
+	while (isdigit(**s)) {
+		(*s)++;
+	}
+}
+
+/**
+ * parse_printf_fmt() - Parse printf/printk conversion spec.
+ * fmt points to the '%' in a printk conversion specification.  Advance
+ * fmt past any flags, width and/or precision specifiers, and qualifiers
+ * such as 'l' and 'L'.  Return a pointer to the conversion character.
+ * Stores the qualifier character (or -1, if there is none) at *pqualifier.
+ * *wp is set to flags indicating whether the width and/or precision are '*'.
+ * For example, given
+ *      %*.2lx
+ * *pqualifier is set to 'l', *wp is set to 0x1, and a pointer to the 'x'
+ * is returned.
+ *
+ * Note: This function is derived from vsnprintf() (see lib/vsprintf.c),
+ * and should be kept in sync with that function.
+ *
+ * @fmt - points to '%' in conversion spec
+ * @pqualifier - *pqualifier is set to conversion spec's qualifier, or -1.
+ * @wp - Bits in *wp are set if the width or/and precision are '*'.
+ */
+const char *
+parse_printf_fmt(const char *fmt, int *pqualifier, int *wp)
+{
+	int qualifier = -1;
+	*wp = 0;
+
+	/* process flags */
+	repeat:
+		++fmt;          /* this also skips first '%' */
+		switch (*fmt) {
+			case '-':
+			case '+':
+			case ' ':
+			case '#':
+			case '0':
+				goto repeat;
+		}
+
+	/* get field width */
+	if (isdigit(*fmt))
+		skip_atoi(&fmt);
+	else if (*fmt == '*') {
+		++fmt;
+		/* it's the next argument */
+		*wp |= 0x1;
+	}
+
+	/* get the precision */
+	if (*fmt == '.') {
+		++fmt;
+		if (isdigit(*fmt))
+			skip_atoi(&fmt);
+		else if (*fmt == '*') {
+			++fmt;
+			/* it's the next argument */
+			*wp |= 0x2;
+		}
+	}
+
+	/* get the conversion qualifier */
+	if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
+	    *fmt == 'Z' || *fmt == 'z') {
+		qualifier = *fmt;
+		++fmt;
+		if (qualifier == 'l' && *fmt == 'l') {
+			qualifier = 'L';
+			++fmt;
+		}
+	}
+
+	*pqualifier = qualifier;
+	return fmt;
+}
+
+/**
+ * evl_pack_args() - Pack args into buffer, guided by format string.
+ * b describes a buffer.  fmt and args are as passed to vsnprintf().  Using
+ * fmt as a guide, copy the args into b's buffer.
+ *
+ * @b - describes buffer; updated to reflect data added
+ * @fmt - printf/printk-style format string
+ * @args - values to be packed into buffer
+ */
+void
+evl_pack_args(struct evl_recbuf *b, const char *fmt, va_list args)
+{
+#define COPYARG(type) \
+    do { type v=va_arg(args,type); evl_put(b,&v,sizeof(v)); } while(0)
+
+	const char *s;
+	int qualifier;
+
+	for (; *fmt ; ++fmt) {
+		int wp = 0x0;
+		if (*fmt != '%') {
+			continue;
+		}
+
+		fmt = parse_printf_fmt(fmt, &qualifier, &wp);
+		if (wp & 0x1) {
+			/* width is '*' (next arg) */
+			COPYARG(int);
+		}
+		if (wp & 0x2) {
+			/* ditto precision */
+			COPYARG(int);
+		}
+
+		switch (*fmt) {
+			case 'c':
+				COPYARG(int);
+				continue;
+
+			case 's':
+				s = va_arg(args, char *);
+				evl_puts(b, s, 1);
+				continue;
+
+			case 'p':
+				COPYARG(void*);
+				continue;
+
+			case 'n':
+				/* Skip over the %n arg. */
+				if (qualifier == 'l') {
+					(void) va_arg(args, long *);
+				} else if (qualifier == 'Z' || qualifier == 'z') {
+					(void) va_arg(args, size_t *);
+				} else {
+					(void) va_arg(args, int *);
+				}
+				continue;
+
+			case '%':
+				continue;
+
+				/* integer number formats - handle outside switch */
+			case 'o':
+			case 'X':
+			case 'x':
+			case 'd':
+			case 'i':
+			case 'u':
+				break;
+
+			default:
+				/* Bogus conversion.  Pass thru unchanged. */
+				if (*fmt == '\0')
+					--fmt;
+				continue;
+		}
+		if (qualifier == 'L') {
+			COPYARG(long long);
+		} else if (qualifier == 'l') {
+			COPYARG(long);
+		} else if (qualifier == 'Z' || qualifier == 'z') {
+			COPYARG(size_t);
+		} else if (qualifier == 'h') {
+			COPYARG(int);
+		} else {
+			COPYARG(int);
+		}
+	}
+}
+
+/*
+ * Scratch buffer for constructing event records.  This is static because
+ * (1) we want events to be logged even in low-memory situations; and
+ * (2) the buffer is too big to be an auto variable.
+ */
+spinlock_t evl_msgbuf_lock = SPIN_LOCK_UNLOCKED;
+char evl_msgbuf[EVL_ENTRY_MAXLEN];
+
+/**
+ * evl_send_printf() - Format and log a PRINTF-format message.
+ * Create and log a PRINTF-format event record whose contents are:
+ *	format string
+ *	int containing args size
+ *	args
+ * @hdr - pre-constructed record header, which we adjust as needed
+ * @fmt - format string
+ * @args - arg list
+ */
+static int
+evl_send_printf(struct kern_log_entry *hdr, const char *fmt, va_list args)
+{
+	int ret;
+	struct evl_recbuf b;
+	unsigned long iflags;
+
+	spin_lock_irqsave(&evl_msgbuf_lock, iflags);
+	evl_init_recbuf(&b, evl_msgbuf, EVL_ENTRY_MAXLEN);
+	evl_puts(&b, fmt, 1);
+	evl_zap_newline(&b);
+	evl_end_fmt(&b);
+	evl_pack_args(&b, fmt, args);
+	evl_end_args(&b);
+
+	hdr->log_size = evl_datasz(&b, &hdr->log_flags);
+
+	ret = evl_writeh(hdr, b.b_buf);
+	spin_unlock_irqrestore(&evl_msgbuf_lock, iflags);
+	return ret;
+}
+
+/**
+ * evl_vprintk() - Format and log a PRINTF-format record.
+ * @fmt - format string
+ * @args - arg list
+ * other args as per evl_mk_rechdr().  If event_type == 0, set flag to
+ *	request that recipient set event type.
+ */
+int
+evl_vprintk(const char *facility, int event_type, int severity,
+	const char *fmt, va_list args)
+{
+	struct kern_log_entry hdr;
+	uint flags = 0;
+	if (event_type == 0) {
+		flags |= EVL_EVTYCRC;
+	}
+	evl_mk_rechdr(&hdr, facility, event_type, severity, 1 /*size TBD*/,
+		flags, EVL_PRINTF);
+
+	return evl_send_printf(&hdr, fmt, args);
+}
+
+/**
+ * evl_printk() - Format and log a PRINTF-format record.
+ * @fmt - format string
+ * other args as per evl_mk_rechdr()
+ */
+int
+evl_printk(const char *facility, int event_type, int severity,
+	const char *fmt, ...)
+{
+	va_list args;
+	int ret;
+	va_start(args, fmt);
+	ret = evl_vprintk(facility, event_type, severity, fmt, args);
+	va_end(args);
+	return ret;
+}
+
+EXPORT_SYMBOL(evl_write);
+EXPORT_SYMBOL(evl_printk);
+EXPORT_SYMBOL(evl_vprintk);
+
+EXPORT_SYMBOL(evl_init_recbuf);
+EXPORT_SYMBOL(evl_put);
+EXPORT_SYMBOL(evl_puts);
+EXPORT_SYMBOL(evl_zap_newline);
+EXPORT_SYMBOL(evl_unzap_newline);
+EXPORT_SYMBOL(evl_end_fmt);
+EXPORT_SYMBOL(evl_end_args);
+EXPORT_SYMBOL(evl_datasz);
diff --git a/kernel/evlbuf.c b/kernel/evlbuf.c
new file mode 100644
index 0000000..4507298
--- /dev/null
+++ b/kernel/evlbuf.c
@@ -0,0 +1,523 @@
+/*
+ * Linux Event Logging
+ * Copyright (C) International Business Machines Corp., 2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *  Please send e-mail to kenistoj@users.sourceforge.net if you have
+ *  questions or comments.
+ *
+ *  Project Website:  http://evlog.sourceforge.net/
+ */
+
+#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/stddef.h>
+#include <linux/spinlock.h>
+#include <linux/time.h>
+#include <linux/smp.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <asm/uaccess.h>
+#include <asm/semaphore.h>
+#include <linux/module.h>
+#include <linux/ctype.h>
+#include <linux/evlog.h>
+
+#define REC_HDR_SIZE sizeof(struct kern_log_entry)
+
+extern struct timezone sys_tz;
+
+/* Use same buffer size as printk's, but at least 2x the max rec length. */
+#define EVL_BUF_SIZE (1 << CONFIG_LOG_BUF_SHIFT)
+#if (EVL_BUF_SIZE < 2*EVL_ENTRY_MAXLEN)
+#undef EVL_BUF_SIZE
+#define EVL_BUF_SIZE (2*EVL_ENTRY_MAXLEN)
+#endif
+
+/*
+ * After buffer overflows, require at most this much free space before
+ * logging events again.
+ */
+#define EVL_BUF_DRAINAGE (16*1024U)
+
+/*
+ * This data structure describes the circular buffer that is written into
+ * by evl_writeh() and drained by evl_kbufread().
+ *
+ * bf_buf, bf_len, and bf_end are the start, length, and end of the buffer,
+ * and in the current implementation these remain constant.
+ *
+ * bf_tail advances as event records are logged to the buffer, and bf_head
+ * advances as records are drained from the buffer.  bf_dropped maintains
+ * a count of records that have been dropped due to buffer overrun.
+ * By convention:
+ * - (bf_head == bf_tail) indicates an empty buffer.
+ * - bf_head can take any value from bf_buf through bf_end.
+ * - bf_tail starts out equal to bf_buf, but once the first record is written
+ *	to the buffer, bf_tail never equals bf_buf.  It can equal bf_end.
+ *
+ * It is possible for one task to be draining the buffer while another
+ * is writing to it.  Only evl_kbufread() advances bf_head, and only
+ * copy_rec_to_cbuf() advances bf_tail.  Each advances its respective
+ * pointer only after completing its operation.
+ */
+struct cbuf {
+	char		*bf_buf;	/* base buffer address */
+	unsigned int	bf_len;		/* buffer length */
+	unsigned int	bf_dropped;	/* (internal) dropped count */
+	char		*bf_head;	/* head-pointer for circ. buf */
+	char		*bf_tail;	/* tail-pointer for circ. buf */
+	char		*bf_end;	/* end buffer address */
+};
+
+static char evl_buffer[EVL_BUF_SIZE + sizeof(long)];
+
+static struct cbuf ebuf = {
+	evl_buffer,
+	EVL_BUF_SIZE,
+	0,
+	evl_buffer,
+	evl_buffer,
+	evl_buffer + EVL_BUF_SIZE
+};
+
+/*
+ * evl_read_sem serializes reads of the evlog buffer into user space (although
+ * only the logging daemon should be running evl_kbufread()).
+ *
+ * evl_readq allows the reader to sleep until there's at least one record in
+ * the buffer to read.
+ *
+ * ebuf_lock serializes writes to the evlog buffer.
+ */
+static DECLARE_MUTEX(evl_read_sem);
+static DECLARE_WAIT_QUEUE_HEAD(evl_readq);
+static spinlock_t ebuf_lock = SPIN_LOCK_UNLOCKED;
+
+/*
+ * A region of the evlog circular buffer, possibly split into 2 chunks
+ * due to wraparound.
+ */
+struct cbregion {
+	char	*rg_head;
+	char	*rg_tail;
+	size_t	rg_chunk1;
+	size_t	rg_chunk2;
+};
+
+/**
+ * set_region() - Establish region to be written to or read from.
+ * Caller wants to write to or read from an nbytes-byte region (of the
+ * evlog circular buffer) starting at head.  Figure out whether the
+ * region needs to be 1 chunk (typical) or 2 (due to wraparound),
+ * and populate the region struct accordingly.
+ *
+ * @rg: region struct to be populated
+ * @head: beginning of region to be read/written.  If this is beyond the
+ *	end of the buffer, wrap it around to the beginning.
+ * @nbytes: size of region
+ */
+static void
+set_region(struct cbregion *rg, char *head, size_t nbytes)
+{
+	if (head >= ebuf.bf_end) {
+		head -= ebuf.bf_len;
+	}
+	rg->rg_head = head;
+	rg->rg_tail = head + nbytes;
+	if (rg->rg_tail > ebuf.bf_end) {
+		rg->rg_chunk1 = ebuf.bf_end - head;
+		rg->rg_chunk2 = nbytes - rg->rg_chunk1;
+		rg->rg_tail = ebuf.bf_buf + rg->rg_chunk2;
+	} else {
+		rg->rg_chunk1 = nbytes;
+		rg->rg_chunk2 = 0;
+	}
+}
+
+static void
+copy_from_cbuf(const struct cbregion *rg, char *dest)
+{
+	memcpy(dest, rg->rg_head, rg->rg_chunk1);
+	if (rg->rg_chunk2 != 0) {
+		memcpy(dest + rg->rg_chunk1, ebuf.bf_buf, rg->rg_chunk2);
+	}
+}
+
+static int
+copy_cbuf_to_user(const struct cbregion *rg, char *ubuf)
+{
+	int status;
+	status = copy_to_user(ubuf, rg->rg_head, rg->rg_chunk1);
+	if (rg->rg_chunk2 != 0 && status == 0) {
+		status = copy_to_user(ubuf + rg->rg_chunk1, ebuf.bf_buf,
+			rg->rg_chunk2);
+	}
+	return status;
+}
+
+static void
+copy_to_cbuf(const struct cbregion *rg, const char *src)
+{
+	memcpy(rg->rg_head, src, rg->rg_chunk1);
+	if (rg->rg_chunk2 != 0) {
+		memcpy(ebuf.bf_buf, src + rg->rg_chunk1, rg->rg_chunk2);
+	}
+}
+
+/**
+ * copy_rec_to_cbuf() - Log event (hdr + vardata) to buffer.
+ * Caller has verified that there's enough room.
+ */
+static void
+copy_rec_to_cbuf(const struct kern_log_entry *hdr, const char *vardata)
+{
+	struct cbregion rg;
+	char *tail = ebuf.bf_tail;
+
+	set_region(&rg, tail, REC_HDR_SIZE);
+	copy_to_cbuf(&rg, (const char*) hdr);
+
+	if (hdr->log_size != 0) {
+		set_region(&rg, tail + REC_HDR_SIZE, hdr->log_size);
+		copy_to_cbuf(&rg, vardata);
+	}
+
+	ebuf.bf_tail = rg.rg_tail;
+}
+
+/**
+ * evl_mk_rechdr() - Populate evlog record header.
+ * @facility: facility name (e.g., "kern", driver name)
+ * @event_type: event type (event ID assigned by programmer; may also be
+ *	computed by recipient -- e.g., CRC of format string)
+ * @severity: severity level (e.g., LOG_INFO)
+ * @size: length, in bytes, of variable data
+ * @flags: event flags (e.g., EVL_TRUNCATE, EVL_EVTYCRC)
+ * @format: format of variable data (e.g., EVL_STRING)
+ */
+void
+evl_mk_rechdr(struct kern_log_entry *rec_hdr,
+		const char *facility,
+		int	event_type,
+		int	severity,
+		size_t	size,
+		uint	flags,
+		int	format)
+{
+	struct timespec ts;
+
+	flags |= EVL_KERNEL_EVENT;
+	if (in_interrupt()) {
+		flags |= EVL_INTERRUPT;
+	}
+
+	rec_hdr->log_kmagic		=  LOGREC_KMAGIC;
+	rec_hdr->log_kversion		=  LOGREC_KVERSION;
+	rec_hdr->log_size		=  (__u16) size;
+	rec_hdr->log_format		=  (__s8) format;
+	rec_hdr->log_event_type		=  (__s32) event_type;
+	rec_hdr->log_severity		=  (__s8) severity;
+	rec_hdr->log_uid		=  current->uid;
+	rec_hdr->log_gid		=  current->gid;
+	rec_hdr->log_pid		=  current->pid;
+	rec_hdr->log_pgrp		=  process_group(current);
+	rec_hdr->log_flags		=  (__u32) flags;
+	rec_hdr->log_processor		=  (__s32) smp_processor_id();
+
+	strlcpy(rec_hdr->log_facility, facility, FACILITY_MAXLEN);
+
+	if (get_seconds() == 0) {
+		rec_hdr->log_flags |= EVL_INITIAL_BOOT_EVENT;
+	} else {
+#if defined(__i386__)
+		if (sys_tz.tz_minuteswest == 0) {
+			/* localtime */
+			rec_hdr->log_flags |= EVL_KERNTIME_LOCAL;
+		}
+#endif
+	}
+	ts = CURRENT_TIME;
+	rec_hdr->log_time_sec = (time_t) ts.tv_sec;
+	rec_hdr->log_time_nsec = (__s32) ts.tv_nsec;
+}
+
+/**
+ * normalize_header() - Fix up rec header, handling overflow, null vardata, etc.
+ * In case of sloppiness on the part of the caller, we clean it up rather
+ * than failing, since the caller is unlikely to handle failure.
+ */
+static void
+normalize_header(struct kern_log_entry *hdr, const void *vardata)
+{
+	if (hdr->log_severity < 0 || hdr->log_severity > LOG_DEBUG) {
+		hdr->log_severity = LOG_WARNING;
+	}
+	if (vardata == NULL
+	    || hdr->log_size == 0
+	    || hdr->log_format == EVL_NODATA) {
+		hdr->log_size = 0;
+		hdr->log_format = EVL_NODATA;
+	}
+	if (hdr->log_size > EVL_ENTRY_MAXLEN) {
+		hdr->log_size = EVL_ENTRY_MAXLEN;
+		hdr->log_flags |= EVL_TRUNCATE;
+	}
+}
+
+/**
+ * log_dropped_recs_event() - Log message about previously dropped records.
+ * The evlog circular buffer had been full and caused later records to be
+ * dropped.  Now the buffer has some free space again.  Log an event reporting
+ * the number of records dropped.  Caller has verified that there's at least
+ * enough room for this event record.
+ */
+static void
+log_dropped_recs_event(void)
+{
+#define DROP_MSG_SIZE 80
+	char sbuf[DROP_MSG_SIZE];
+	struct kern_log_entry drechdr;
+
+	snprintf(sbuf, DROP_MSG_SIZE,
+		"%d event records dropped due to EVL buffer overflow.",
+		ebuf.bf_dropped);
+	ebuf.bf_dropped = 0;
+	evl_mk_rechdr(&drechdr, "kern", EVL_BUFFER_OVERRUN, LOG_INFO,
+		strlen(sbuf) + 1, 0, EVL_STRING);
+	copy_rec_to_cbuf(&drechdr, sbuf);
+}
+
+/**
+ * evl_check_buf() - Check for space in evlog buffer.
+ * If buffer free space is sufficient to log the indicated record,
+ * return 0.  If not, return -1.
+ *
+ * Once the buffer becomes full and one or more messages are discarded,
+ * a significant portion of the buffer must be drained before we permit
+ * messages to be buffered again.  We count the number of discards
+ * in the meantime and report them when we resume logging events.
+ * If we resumed logging with a nearly full buffer, then there could
+ * be a thrashing of stops and starts, making the discarded-message
+ * reporting annoying.
+ *
+ * @hdr: The header of the record caller intends to log.
+ */
+static int
+evl_check_buf(const struct kern_log_entry *hdr)
+{
+	char *head, *tail;
+	size_t water_mark, avail, recsize;
+
+	recsize = REC_HDR_SIZE + hdr->log_size;
+	head    = ebuf.bf_head;
+	tail	= ebuf.bf_tail;
+	avail   = (head <= tail) ?
+		  (ebuf.bf_len - (tail - head)) :
+		  (head - tail);
+
+	if (ebuf.bf_dropped != 0) {
+		/*
+		 * Still recovering from buffer overflow.
+		 * Apply the low water mark.
+		 */
+		water_mark = min(EVL_BUF_DRAINAGE, ebuf.bf_len / 2);
+		/*
+		 * Just in case recsize is huge and/or somebody cranks the
+		 * buffer size and/or EVL_BUF_DRAINAGE way down, make
+		 * sure we have room for this record AND the "records dropped"
+		 * message.
+		 */
+		water_mark = max(water_mark,
+			recsize + REC_HDR_SIZE + DROP_MSG_SIZE);
+	} else {
+		/* +1 because bf_tail must never catch up with bf_head. */
+		water_mark = recsize + 1;
+	}
+
+	if (avail < water_mark) {
+		return -1;
+	}
+
+	/* There's enough free buffer space.  Return success. */
+	if (ebuf.bf_dropped != 0) {
+		log_dropped_recs_event();
+	}
+	return 0;
+}
+
+/**
+ * evl_kbufread() - Copy records from evlog circular buffer into user space.
+ * If successful, returns the number of bytes copied; else returns a
+ * negative error code.
+ *
+ * @retbuf: pointer to the buffer to be filled with the event records
+ * @bufsize: length, in bytes, of retbuf
+ */
+int
+evl_kbufread(char *retbuf, size_t bufsize)
+{
+	char *rec;
+	size_t rec_size;
+	int error = 0;
+	int retbuflen = 0;
+	char *tail, *buf = retbuf;
+
+	if (bufsize < REC_HDR_SIZE) {
+		return -EINVAL;
+	}
+
+	if (ebuf.bf_head == ebuf.bf_tail && ebuf.bf_dropped != 0) {
+		/*
+		 * Probable scenario:
+		 * 1. Somebody logged a huge burst of events and overflowed
+		 * the buffer.  At this point, there was no room for the
+		 * "records dropped" message.
+		 * 2. evlogd drained the buffer, and is now back for more.
+		 */
+		unsigned long iflags;
+		spin_lock_irqsave(&ebuf_lock, iflags);
+		log_dropped_recs_event();
+		spin_unlock_irqrestore(&ebuf_lock, iflags);
+	}
+
+	/*
+	 * We expect that only the logging daemon will be running here,
+	 * but serialize access just in case.
+	 */
+	error = down_interruptible(&evl_read_sem);
+	if (error == -EINTR) {
+		return -EINTR;
+	}
+	/* Go to sleep if the buffer is empty.  */
+	error = wait_event_interruptible(evl_readq,
+		(ebuf.bf_head != ebuf.bf_tail));
+	if (error) {
+		up(&evl_read_sem);
+		return error;
+	}
+	/*
+	 * Assemble message(s) into the user buffer, as many as will
+	 * fit.  On running out of space in the buffer, try to copy
+	 * the header for the overflowing message.  This means that
+	 * there will always be at least a header returned.  The caller
+	 * must compare the numbers of bytes returned (remaining) with
+	 * the length of the message to see if the entire message is
+	 * present.  A subsequent read will get the entire message,
+	 * including the header (again).
+	 *
+	 * For simplicity, take a snapshot of bf_tail, and don't read
+	 * past that even if evl_writeh() pours in more records while
+	 * we're draining.  We'll get those new records next time around.
+	 */
+	tail = ebuf.bf_tail;
+	rec = ebuf.bf_head;
+	if (rec == tail) {
+		/* Should not happen. Buffer must have at least one record. */
+		error = -EFAULT;
+		goto out;
+	}
+
+	do {
+		struct cbregion rg;
+		__u16 vardata_size;	/* type must match rec.log_size */
+
+		if (bufsize < REC_HDR_SIZE) {
+			break;
+		}
+
+		/*
+		 * Extract log_size from header, which could be split due to
+		 * wraparound, or misaligned.
+		 */
+		set_region(&rg, rec+offsetof(struct kern_log_entry, log_size),
+			sizeof(vardata_size));
+		copy_from_cbuf(&rg, (char*) &vardata_size);
+		rec_size = REC_HDR_SIZE + vardata_size;
+
+		if (bufsize < rec_size) {
+			/*
+			 * Copyout only the header 'cause user buffer can't
+			 * hold full record.
+			 */
+			set_region(&rg, rec, REC_HDR_SIZE);
+			error = copy_cbuf_to_user(&rg, buf);
+			if (error) {
+				error = -EFAULT;
+				break;
+			}
+			bufsize -= REC_HDR_SIZE;
+			retbuflen += REC_HDR_SIZE;
+			break;
+		}
+		set_region(&rg, rec, rec_size);
+		error = copy_cbuf_to_user(&rg, buf);
+		if (error) {
+			error = -EFAULT;
+			break;
+		}
+		rec = rg.rg_tail;
+		buf += rec_size;
+		bufsize -= rec_size;
+		retbuflen += rec_size;
+	} while (rec != tail);
+
+	if (error == 0) {
+		ebuf.bf_head = rec;
+		error = retbuflen;
+	}
+
+out:
+	up(&evl_read_sem);
+	return(error);
+}
+
+/**
+ * evl_writeh() - Log event, given a pre-constructed header.
+ * Returns 0 on success, or a negative error code otherwise.
+ * For caller's convenience, we normalize the header as needed.
+ */
+int
+evl_writeh(struct kern_log_entry *hdr, const char *vardata)
+{
+	char *oldtail = ebuf.bf_tail;
+	unsigned long iflags;	/* for spin_lock_irqsave() */
+
+	normalize_header(hdr, vardata);
+
+	spin_lock_irqsave(&ebuf_lock, iflags);
+	if (evl_check_buf(hdr) < 0) {
+		ebuf.bf_dropped++;
+		spin_unlock_irqrestore(&ebuf_lock, iflags);
+		return -ENOSPC;
+	}
+
+	copy_rec_to_cbuf(hdr, vardata);
+	/*
+	 * If the variable portion is a truncated string, make sure it
+	 * ends with a null character.
+	 */
+	if ((hdr->log_flags & EVL_TRUNCATE) && hdr->log_format == EVL_STRING) {
+		*(ebuf.bf_tail - 1) = '\0';
+	}
+
+	if ((ebuf.bf_head == oldtail) &&
+	    (ebuf.bf_head != ebuf.bf_tail)) {
+		wake_up_interruptible(&evl_readq);
+	}
+	spin_unlock_irqrestore(&ebuf_lock, iflags);
+	return 0;
+}
diff --git a/kernel/printk.c b/kernel/printk.c
index aaeef5c..d1a41be 100644
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -135,6 +135,10 @@ static int preferred_console = -1;
 int console_set_on_cmdline;
 EXPORT_SYMBOL(console_set_on_cmdline);
 
+#ifdef CONFIG_EVLOG
+extern int evl_kbufread(char *, size_t);
+#endif
+
 /* Flag: console code may call schedule() */
 static int console_may_schedule;
 
@@ -294,6 +298,7 @@ int log_buf_copy(char *dest, int idx, int len)
  *	8 -- Set level of messages printed to console
  *	9 -- Return number of unread characters in the log buffer
  *     10 -- Return size of the log buffer
+ *     20 -- Read from event logging buffer
  */
 int do_syslog(int type, char __user *buf, int len)
 {
@@ -422,6 +427,14 @@ int do_syslog(int type, char __user *buf, int len)
 	case 10:	/* Size of the log buffer */
 		error = log_buf_len;
 		break;
+	case 20:
+#ifdef CONFIG_EVLOG
+		if (!access_ok(VERIFY_WRITE, buf, len)) return -EFAULT;
+		error = evl_kbufread(buf, len);
+#else
+		error = -EIO;
+#endif
+		break;
 	default:
 		error = -EINVAL;
 		break;
-- 
1.5.5.1

