From c04f9563ba3b83a9ed34e63be508ae772ee02f88 Mon Sep 17 00:00:00 2001
From: Greg Moffatt <greg.moffatt@windriver.com>
Date: Mon, 3 May 2010 12:36:04 -0700
Subject: [PATCH] evlog: add evlog support

Evlog provides an open-source, platform-independent Event Logging facility
for the Linux Operating system and Linux applications, which offers
capabilities and features comparable to Event and Error Logging
facilities found in Enterprise-class, UNIX-based operating systems.

The evlog feature originates from the patchset "kernel-2.6.4-patch.tar.gz"
found on http://evlog.sourceforce.net/ which has been merged into the
Wind River kernel.

Integrated-by: Greg Moffatt <greg.moffatt@windriver.com>
---
 drivers/scsi/sd.h          |   11 +-
 include/linux/device.h     |   17 ++
 include/linux/evl_log.h    |  120 ++++++++++
 include/linux/evlog.h      |  136 ++++++++++++
 include/linux/syslog.h     |    2 +
 include/scsi/scsi_device.h |    9 +-
 init/Kconfig               |   13 +
 kernel/Makefile            |    1 +
 kernel/evlapi.c            |  442 +++++++++++++++++++++++++++++++++++++
 kernel/evlbuf.c            |  523 ++++++++++++++++++++++++++++++++++++++++++++
 kernel/evlposix.c          |  400 +++++++++++++++++++++++++++++++++
 kernel/printk.c            |   12 +
 12 files changed, 1679 insertions(+), 7 deletions(-)
 create mode 100644 include/linux/evl_log.h
 create mode 100644 include/linux/evlog.h
 create mode 100644 kernel/evlapi.c
 create mode 100644 kernel/evlbuf.c
 create mode 100644 kernel/evlposix.c

diff --git a/drivers/scsi/sd.h b/drivers/scsi/sd.h
index 43d3caf..b9fab43 100644
--- a/drivers/scsi/sd.h
+++ b/drivers/scsi/sd.h
@@ -71,10 +71,13 @@ static inline struct scsi_disk *scsi_disk(struct gendisk *disk)
 }
 
 #define sd_printk(prefix, sdsk, fmt, a...)				\
-        (sdsk)->disk ?							\
-	sdev_printk(prefix, (sdsk)->device, "[%s] " fmt,		\
-		    (sdsk)->disk->disk_name, ##a) :			\
-	sdev_printk(prefix, (sdsk)->device, fmt, ##a)
+     do{								\
+        if((sdsk)->disk)					        \
+	  sdev_printk(prefix, (sdsk)->device, "[%s] " fmt,		\
+		     (sdsk)->disk->disk_name, ##a);			\
+        else                                                            \
+	  sdev_printk(prefix, (sdsk)->device, fmt, ##a);                \
+     }while(0)
 
 /*
  * A DIF-capable target device can be formatted with different
diff --git a/include/linux/device.h b/include/linux/device.h
index 1821928..8ca068e 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -624,9 +624,26 @@ extern void sysdev_shutdown(void);
 
 /* debugging and troubleshooting/diagnostic helpers. */
 extern const char *dev_driver_string(const struct device *dev);
+#ifdef CONFIG_EVLOG
+#include <linux/evlog.h>
+static inline const char *dev_bus_name(const struct device *dev)
+{
+	if (!dev || !(dev->bus) || (!dev->bus->name))
+		return "NULL";
+	else
+		return dev->bus->name;
+}
+#define dev_printk(level, dev, format, arg...)  \
+	do { \
+		printk(level "%s %s: " format , dev_driver_string(dev) , dev_bus_name(dev) , ## arg); \
+		evl_printk(dev_driver_string(dev) , 0, (level[1]-'0') , \
+		"%s %s: " format , dev_driver_string(dev) , dev_bus_name(dev) , ## arg); \
+	} while (0)
+#else
 #define dev_printk(level, dev, format, arg...)	\
 	printk(level "%s %s: " format , dev_driver_string(dev) , \
 	       dev_name(dev) , ## arg)
+#endif
 
 #define dev_emerg(dev, format, arg...)		\
 	dev_printk(KERN_EMERG , dev , format , ## arg)
diff --git a/include/linux/evl_log.h b/include/linux/evl_log.h
new file mode 100644
index 0000000..0e38a64
--- /dev/null
+++ b/include/linux/evl_log.h
@@ -0,0 +1,120 @@
+/*
+ * Linux Event Logging
+ * Copyright (C) International Business Machines Corp., 2001
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *  Please send e-mail to kenistoj@users.sourceforge.net if you have
+ *  questions or comments.
+ *
+ *  Project Website:  http://evlog.sourceforge.net/
+ */
+#ifndef _LINUX_EVL_LOG_H
+#define _LINUX_EVL_LOG_H
+
+#include <linux/evlog.h>
+
+/*
+ * This header provides the declarations and definitions for the "legacy"
+ * functions defined in early releases of Event Logging.  Consider using
+ * the newer functions declared in evlog.h -- e.g., evl_write(), evl_printk(),
+ * evl_vprintk().
+ */
+
+/*
+ * In the current implementation, the header for kernel events contains
+ * the facility name, not the facility code.  The conversion to facility code
+ * happens in evlogd.  The legacy functions evl_gen_facility_code() and
+ * evl_register_facility() still provide a "posix_log_facility_t" that the
+ * caller can pass to the other functions (i.e., a kmalloc-ed copy of
+ * the facility name).  However, evl_register_facility() no longer logs a
+ * "register facility" event.  To register a facility, just use the command
+ * "evlfacility -a facname [-k]".
+ */
+typedef const char *posix_log_facility_t;
+typedef int posix_log_severity_t;
+
+#define POSIX_LOG_TRUNCATE	EVL_TRUNCATE
+
+#define POSIX_LOG_NODATA	EVL_NODATA
+#define POSIX_LOG_BINARY	EVL_BINARY
+#define POSIX_LOG_STRING	EVL_STRING
+#define POSIX_LOG_PRINTF	EVL_PRINTF
+
+#define POSIX_LOG_ENTRY_MAXLEN	EVL_ENTRY_MAXLEN
+
+#define POSIX_LOG_MEMSTR_MAXLEN	128
+
+#define LOG_KERN "kern"
+
+#ifdef CONFIG_EVLOG
+/* Various kernel implementations provide some or all of these functions. */
+extern int evl_writek(posix_log_facility_t facility, int event_type,
+		posix_log_severity_t severity, unsigned int flags, ...);
+
+extern int evl_vwritek(posix_log_facility_t facility, int event_type,
+		posix_log_severity_t severity, unsigned int flags,va_list args);
+
+extern int posix_log_printf(posix_log_facility_t facility, int event_type,
+		posix_log_severity_t severity, unsigned int flags,
+		const char *fmt, ...);
+
+extern int posix_log_vprintf(posix_log_facility_t facility, int event_type,
+		posix_log_severity_t severity, unsigned int flags,
+		const char *fmt, va_list args);
+
+extern int posix_log_write(posix_log_facility_t facility, int event_type,
+		posix_log_severity_t severity, const void *buf,
+		size_t len, int format, unsigned int flags);
+
+extern int evl_gen_facility_code(const char *fname,
+		posix_log_facility_t *fcode);
+
+extern int evl_register_facility(const char *fname,
+		posix_log_facility_t *fcode);
+#else	/* ! CONFIG_EVLOG */
+inline int evl_writek(posix_log_facility_t facility, int event_type,
+		posix_log_severity_t severity, unsigned int flags, ...)
+		{ return -ENOSYS; }
+
+inline int evl_vwritek(posix_log_facility_t facility, int event_type,
+		posix_log_severity_t severity, unsigned int flags,va_list args)
+		{ return -ENOSYS; }
+
+inline int posix_log_printf(posix_log_facility_t facility, int event_type,
+		posix_log_severity_t severity, unsigned int flags,
+		const char *fmt, ...)
+		{ return -ENOSYS; }
+
+inline int posix_log_vprintf(posix_log_facility_t facility, int event_type,
+		posix_log_severity_t severity, unsigned int flags,
+		const char *fmt, va_list args)
+		{ return -ENOSYS; }
+
+inline int posix_log_write(posix_log_facility_t facility, int event_type,
+		posix_log_severity_t severity, const void *buf,
+		size_t len, int format, unsigned int flags)
+		{ return -ENOSYS; }
+
+inline int evl_gen_facility_code(const char *fname,
+		posix_log_facility_t *fcode)
+		{ return -ENOSYS; }
+
+inline int evl_register_facility(const char *fname,
+		posix_log_facility_t *fcode)
+		{ return -ENOSYS; }
+#endif	/* CONFIG_EVLOG */
+
+#endif	/* _LINUX_EVL_LOG_H */
diff --git a/include/linux/evlog.h b/include/linux/evlog.h
new file mode 100644
index 0000000..75c3644
--- /dev/null
+++ b/include/linux/evlog.h
@@ -0,0 +1,136 @@
+/*
+ * Linux Event Logging
+ * Copyright (C) International Business Machines Corp., 2001
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *  Please send e-mail to kenistoj@users.sourceforge.net if you have
+ *  questions or comments.
+ *
+ *  Project Website:  http://evlog.sourceforge.net/
+ */
+
+#ifndef _LINUX_EVLOG_H
+#define _LINUX_EVLOG_H
+
+#include <stdarg.h>
+#include <linux/types.h>
+#include <asm/types.h>
+
+/* Values for log_flags member */
+#define EVL_TRUNCATE		0x1
+#define EVL_KERNEL_EVENT	0x2
+#define EVL_INITIAL_BOOT_EVENT	0x4
+#define EVL_KERNTIME_LOCAL	0x8
+#define EVL_INTERRUPT		0x10	/* Logged from interrupt context */
+#define EVL_PRINTK		0x20	/* Strip leading <n> when formatting */
+#define EVL_EVTYCRC		0x40	/* Daemon will set event type = CRC */
+					/* of format string. */
+
+/* Formats for optional portion of record. */
+#define EVL_NODATA    0
+#define EVL_BINARY    1
+#define EVL_STRING    2
+#define EVL_PRINTF    3
+
+/* Maximum length of variable portion of record */
+#define EVL_ENTRY_MAXLEN (8 * 1024)
+
+/* Facility (e.g., driver) names are truncated to 15+null. */
+#define FACILITY_MAXLEN 16
+
+/* struct kern_log_entry - kernel record header */
+struct kern_log_entry {
+	__u16	log_kmagic;	/* always LOGREC_KMAGIC */
+	__u16	log_kversion;	/* which version of this struct? */
+	__u16	log_size;	/* # bytes in variable part of record */
+	__s8	log_format;	/* BINARY, STRING, PRINTF, NODATA */
+	__s8	log_severity;	/* DEBUG, INFO, NOTICE, WARN, etc. */
+	__s32	log_event_type;	/* facility-specific event ID */
+	__u32	log_flags;	/* EVL_TRUNCATE, etc. */
+	__s32	log_processor;	/* CPU ID */
+	time_t	log_time_sec;
+	__s32	log_time_nsec;
+	uid_t	log_uid;	/* event context... */
+	gid_t	log_gid;
+	pid_t	log_pid;
+	pid_t	log_pgrp;
+	char	log_facility[FACILITY_MAXLEN];	/* e.g., driver name */
+};
+
+#define LOGREC_KMAGIC	0x7af8
+#define LOGREC_KVERSION	3
+
+/* Reserved Event Types */
+#define EVL_BUFFER_OVERRUN	0x6
+
+#ifdef __KERNEL__
+/*
+ * severities, AKA priorities
+ */
+#define LOG_EMERG   0   /* system is unusable */
+#define LOG_ALERT   1   /* action must be taken immediately */
+#define LOG_CRIT    2   /* critical conditions */
+#define LOG_ERR     3   /* error conditions */
+#define LOG_WARNING 4   /* warning conditions */
+#define LOG_NOTICE  5   /* normal but significant condition */
+#define LOG_INFO    6   /* informational */
+#define LOG_DEBUG   7   /* debug-level messages */
+
+/*
+ * A buffer to pack with data, one value at a time.  By convention, b_tail
+ * reflects the total amount you've attempted to add, and so may be past b_end.
+ */
+struct evl_recbuf {
+	char *b_buf;	/* start of buffer */
+	char *b_tail;	/* add next data here */
+	char *b_end;	/* b_buf + buffer size */
+	char *b_argsz;	/* points to argsz word in EVL_PRINTF-format record */
+	char *b_zapped_nl;	/* where terminating newline was */
+};
+
+#ifdef CONFIG_EVLOG
+extern int evl_write(const char *facility, int event_type,
+	int severity, const void *buf, size_t len, uint flags, int format);
+extern int evl_printk(const char *facility, int event_type, int sev,
+	const char *fmt, ...);
+extern int evl_vprintk(const char *facility, int event_type, int sev,
+	const char *fmt, va_list args);
+
+/* Functions for hand-constructing event records */
+extern void evl_init_recbuf(struct evl_recbuf *b, char *buf, size_t size);
+extern void evl_put(struct evl_recbuf *b, const void *data, size_t datasz);
+extern void evl_puts(struct evl_recbuf *b, const char *s, int null);
+extern void evl_zap_newline(struct evl_recbuf *b);
+extern void evl_unzap_newline(struct evl_recbuf *b);
+extern void evl_end_fmt(struct evl_recbuf *b);
+extern void evl_pack_args(struct evl_recbuf *b, const char *fmt, va_list args);
+extern void evl_end_args(struct evl_recbuf *b);
+extern size_t evl_datasz(struct evl_recbuf *b, uint *flags);
+#else	/* ! CONFIG_EVLOG */
+static inline int evl_write(const char *facility, int event_type,
+	int severity, const void *buf, size_t len, uint flags, int format)
+	{ return -ENOSYS; }
+static inline int evl_printk(const char *facility, int event_type, int sev,
+	const char *fmt, ...)
+	{ return -ENOSYS; }
+static inline int evl_vprintk(const char *facility, int event_type, int sev,
+	const char *fmt, va_list args)
+	{ return -ENOSYS; }
+#endif	/* CONFIG_EVLOG */
+
+#endif	/* __KERNEL__ */
+
+#endif	/* _LINUX_EVLOG_H */
diff --git a/include/linux/syslog.h b/include/linux/syslog.h
index 3891139..d95b28c 100644
--- a/include/linux/syslog.h
+++ b/include/linux/syslog.h
@@ -43,6 +43,8 @@
 #define SYSLOG_ACTION_SIZE_UNREAD    9
 /* Return size of the log buffer */
 #define SYSLOG_ACTION_SIZE_BUFFER   10
+/* Read from the event logging buffer */
+#define SYSLOG_ACTION_READ_EVL_BUFF 20
 
 #define SYSLOG_FROM_CALL 0
 #define SYSLOG_FROM_FILE 1
diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h
index d80b6db..f041614 100644
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@ -213,10 +213,13 @@ struct scsi_dh_data {
 	dev_printk(prefix, &(sdev)->sdev_gendev, fmt, ##a)
 
 #define scmd_printk(prefix, scmd, fmt, a...)				\
-        (scmd)->request->rq_disk ?					\
+    do{          							\
+        if((scmd)->request->rq_disk)					\
 	sdev_printk(prefix, (scmd)->device, "[%s] " fmt,		\
-		    (scmd)->request->rq_disk->disk_name, ##a) :		\
-	sdev_printk(prefix, (scmd)->device, fmt, ##a)
+		    (scmd)->request->rq_disk->disk_name, ##a); 		\
+        else								\
+	  sdev_printk(prefix, (scmd)->device, fmt, ##a); 		\
+    }while(0)
 
 enum scsi_target_state {
 	STARGET_CREATED = 1,
diff --git a/init/Kconfig b/init/Kconfig
index 183eb08..eaadcfe 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -320,6 +320,19 @@ config AUDIT_TREE
 	depends on AUDITSYSCALL
 	select INOTIFY
 
+config EVLOG
+	bool "Event logging support"
+	---help---
+	  This enables support for event logging based upon the draft
+	  POSIX 1003.25 standard.  Enabling this feature does not
+	  affect the operation of the klog/syslog package in any way.
+	  In order to fully utilize this feature, user must also install
+	  the companion evlog package in user-space.
+
+	  For more information see http://evlog.sourceforge.net
+
+	  If you don't know what to do here, say N.
+
 menu "RCU Subsystem"
 
 choice
diff --git a/kernel/Makefile b/kernel/Makefile
index c359729..8be4c85 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -69,6 +69,7 @@ obj-$(CONFIG_PID_NS) += pid_namespace.o
 obj-$(CONFIG_IKCONFIG) += configs.o
 obj-$(CONFIG_RESOURCE_COUNTERS) += res_counter.o
 obj-$(CONFIG_STOP_MACHINE) += stop_machine.o
+obj-$(CONFIG_EVLOG) += evlbuf.o evlapi.o evlposix.o
 obj-$(CONFIG_KPROBES_SANITY_TEST) += test_kprobes.o
 obj-$(CONFIG_AUDIT) += audit.o auditfilter.o audit_watch.o
 obj-$(CONFIG_AUDITSYSCALL) += auditsc.o
diff --git a/kernel/evlapi.c b/kernel/evlapi.c
new file mode 100644
index 0000000..cfc5e3f
--- /dev/null
+++ b/kernel/evlapi.c
@@ -0,0 +1,442 @@
+/*
+ * Linux Event Logging
+ * Copyright (C) International Business Machines Corp., 2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *  Please send e-mail to kenistoj@users.sourceforge.net if you have
+ *  questions or comments.
+ *
+ *  Project Website:  http://evlog.sourceforge.net/
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/stddef.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <linux/evlog.h>
+
+extern void evl_mk_rechdr(struct kern_log_entry *hdr,
+	const char *facility, int event_type, int severity, size_t size,
+	uint flags, int format);
+extern int evl_writeh(struct kern_log_entry *hdr, const char *vardata);
+
+/**
+ * evl_write() - write header + optional buffer to event handler
+ *
+ * @buf: optional variable-length data
+ * other args as per evl_mk_rechdr()
+ */
+int
+evl_write(const char *facility, int event_type, int severity, const void *buf,
+	size_t size, uint flags, int format)
+{
+	struct kern_log_entry hdr;
+
+	evl_mk_rechdr(&hdr, facility, event_type, severity, size, flags,
+		format);
+	return evl_writeh(&hdr, buf);
+}
+
+void
+evl_init_recbuf(struct evl_recbuf *b, char *buf, size_t size)
+{
+	b->b_buf = buf;
+	b->b_tail = buf;
+	b->b_end = buf + size;
+	b->b_zapped_nl = NULL;
+	b->b_argsz = NULL;
+}
+
+/**
+ * evl_put() - Append data to buffer; handle overflow.
+ * @b - describes buffer; updated to reflect data appended
+ * @data - data to append
+ * @datasz - data length in bytes
+ */
+void
+evl_put(struct evl_recbuf *b, const void *data, size_t datasz)
+{
+	ptrdiff_t room = b->b_end - b->b_tail;
+	if (room > 0) {
+		(void) memcpy(b->b_tail, data, min(datasz, (size_t)room));
+	}
+	b->b_tail += datasz;
+}
+
+/**
+ * evl_puts() - Append string to buffer; handle overflow.
+ * Append a string to the buffer.  If null == 1, we include the terminating
+ * null.  If the string extends over the end of the buffer, terminate the
+ * buffer with a null.
+ *
+ * @b - describes buffer; updated to reflect data appended
+ * @s - null-terminated string
+ * @null - 1 if we append the terminating null, 0 otherwise
+ */
+void
+evl_puts(struct evl_recbuf *b, const char *s, int null)
+{
+	char *old_tail = b->b_tail;
+	evl_put(b, s, strlen(s) + null);
+	if (b->b_tail > b->b_end && old_tail < b->b_end) {
+		*(b->b_end - 1) = '\0';
+	}
+}
+
+/**
+ * evl_zap_newline() - Delete newline at end of format string.
+ * Called after the format string has been copied into b.
+ * If the format ends in a newline, remove it.  We remove the
+ * terminating newline to increase flexibility when formatting
+ * the record for viewing.
+ */
+void
+evl_zap_newline(struct evl_recbuf *b)
+{
+	char *nl = b->b_tail - 2;
+	if (b->b_buf <= nl && nl < b->b_end && *nl == '\n') {
+		*nl = '\0';
+		b->b_tail--;
+		b->b_zapped_nl = nl;
+	}
+}
+
+/**
+ * evl_unzap_newline() - Replace previously zapped newline.
+ * NOTE: Replacing the newline (and advancing the terminating null)
+ * renders useless the contents of the record beyond the format string.
+ */
+void
+evl_unzap_newline(struct evl_recbuf *b)
+{
+	if (b->b_zapped_nl) {
+		b->b_zapped_nl[0] = '\n';
+		b->b_zapped_nl[1] = '\0';
+	}
+}
+
+/**
+ * evl_end_fmt() - Make and remember room for argsz word in EVL_PRINTF rec.
+ * Called after the format string has been copied in, but before the args.
+ * Store zero for now; evl_end_args() will store the actual size later.
+ */
+void
+evl_end_fmt(struct evl_recbuf *b)
+{
+	int argsz = 0;
+	b->b_argsz = b->b_tail;
+	evl_put(b, &argsz, sizeof(int));
+}
+
+/**
+ * evl_end_args() - For EVL_PRINTF record, store the argsz.
+ * Called after the args have been copied in.
+ */
+void
+evl_end_args(struct evl_recbuf *b)
+{
+	char *args;
+	int argsz;
+
+	if (! b->b_argsz) {
+		/* Nobody called evl_end_fmt(). */
+		return;
+	}
+	args = b->b_argsz + sizeof(int);
+	if (args > b->b_end) {
+		/* VERY long format string: even argsz is off end of record. */
+		return;
+	}
+	argsz = (int) (b->b_tail - args);
+	memcpy(b->b_argsz, &argsz, sizeof(int));
+}
+
+size_t
+evl_datasz(struct evl_recbuf *b, uint *flags)
+{
+	if (b->b_tail > b->b_end) {
+		*flags |= EVL_TRUNCATE;
+		return (size_t) (b->b_end - b->b_buf);
+	} else {
+		return (size_t) (b->b_tail - b->b_buf);
+	}
+}
+
+static inline void
+skip_atoi(const char **s)
+{
+	while (isdigit(**s)) {
+		(*s)++;
+	}
+}
+
+/**
+ * parse_printf_fmt() - Parse printf/printk conversion spec.
+ * fmt points to the '%' in a printk conversion specification.  Advance
+ * fmt past any flags, width and/or precision specifiers, and qualifiers
+ * such as 'l' and 'L'.  Return a pointer to the conversion character.
+ * Stores the qualifier character (or -1, if there is none) at *pqualifier.
+ * *wp is set to flags indicating whether the width and/or precision are '*'.
+ * For example, given
+ *      %*.2lx
+ * *pqualifier is set to 'l', *wp is set to 0x1, and a pointer to the 'x'
+ * is returned.
+ *
+ * Note: This function is derived from vsnprintf() (see lib/vsprintf.c),
+ * and should be kept in sync with that function.
+ *
+ * @fmt - points to '%' in conversion spec
+ * @pqualifier - *pqualifier is set to conversion spec's qualifier, or -1.
+ * @wp - Bits in *wp are set if the width or/and precision are '*'.
+ */
+const char *
+parse_printf_fmt(const char *fmt, int *pqualifier, int *wp)
+{
+	int qualifier = -1;
+	*wp = 0;
+
+	/* process flags */
+	repeat:
+		++fmt;          /* this also skips first '%' */
+		switch (*fmt) {
+			case '-':
+			case '+':
+			case ' ':
+			case '#':
+			case '0':
+				goto repeat;
+		}
+
+	/* get field width */
+	if (isdigit(*fmt))
+		skip_atoi(&fmt);
+	else if (*fmt == '*') {
+		++fmt;
+		/* it's the next argument */
+		*wp |= 0x1;
+	}
+
+	/* get the precision */
+	if (*fmt == '.') {
+		++fmt;
+		if (isdigit(*fmt))
+			skip_atoi(&fmt);
+		else if (*fmt == '*') {
+			++fmt;
+			/* it's the next argument */
+			*wp |= 0x2;
+		}
+	}
+
+	/* get the conversion qualifier */
+	if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
+	    *fmt == 'Z' || *fmt == 'z') {
+		qualifier = *fmt;
+		++fmt;
+		if (qualifier == 'l' && *fmt == 'l') {
+			qualifier = 'L';
+			++fmt;
+		}
+	}
+
+	*pqualifier = qualifier;
+	return fmt;
+}
+
+/**
+ * evl_pack_args() - Pack args into buffer, guided by format string.
+ * b describes a buffer.  fmt and args are as passed to vsnprintf().  Using
+ * fmt as a guide, copy the args into b's buffer.
+ *
+ * @b - describes buffer; updated to reflect data added
+ * @fmt - printf/printk-style format string
+ * @args - values to be packed into buffer
+ */
+void
+evl_pack_args(struct evl_recbuf *b, const char *fmt, va_list args)
+{
+#define COPYARG(type) \
+    do { type v=va_arg(args,type); evl_put(b,&v,sizeof(v)); } while(0)
+
+	const char *s;
+	int qualifier;
+
+	for (; *fmt ; ++fmt) {
+		int wp = 0x0;
+		if (*fmt != '%') {
+			continue;
+		}
+
+		fmt = parse_printf_fmt(fmt, &qualifier, &wp);
+		if (wp & 0x1) {
+			/* width is '*' (next arg) */
+			COPYARG(int);
+		}
+		if (wp & 0x2) {
+			/* ditto precision */
+			COPYARG(int);
+		}
+
+		switch (*fmt) {
+			case 'c':
+				COPYARG(int);
+				continue;
+
+			case 's':
+				s = va_arg(args, char *);
+				evl_puts(b, s, 1);
+				continue;
+
+			case 'p':
+				COPYARG(void*);
+				continue;
+
+			case 'n':
+				/* Skip over the %n arg. */
+				if (qualifier == 'l') {
+					(void) va_arg(args, long *);
+				} else if (qualifier == 'Z' || qualifier == 'z') {
+					(void) va_arg(args, size_t *);
+				} else {
+					(void) va_arg(args, int *);
+				}
+				continue;
+
+			case '%':
+				continue;
+
+				/* integer number formats - handle outside switch */
+			case 'o':
+			case 'X':
+			case 'x':
+			case 'd':
+			case 'i':
+			case 'u':
+				break;
+
+			default:
+				/* Bogus conversion.  Pass thru unchanged. */
+				if (*fmt == '\0')
+					--fmt;
+				continue;
+		}
+		if (qualifier == 'L') {
+			COPYARG(long long);
+		} else if (qualifier == 'l') {
+			COPYARG(long);
+		} else if (qualifier == 'Z' || qualifier == 'z') {
+			COPYARG(size_t);
+		} else if (qualifier == 'h') {
+			COPYARG(int);
+		} else {
+			COPYARG(int);
+		}
+	}
+}
+
+/*
+ * Scratch buffer for constructing event records.  This is static because
+ * (1) we want events to be logged even in low-memory situations; and
+ * (2) the buffer is too big to be an auto variable.
+ */
+spinlock_t evl_msgbuf_lock = SPIN_LOCK_UNLOCKED;
+char evl_msgbuf[EVL_ENTRY_MAXLEN];
+
+/**
+ * evl_send_printf() - Format and log a PRINTF-format message.
+ * Create and log a PRINTF-format event record whose contents are:
+ *	format string
+ *	int containing args size
+ *	args
+ * @hdr - pre-constructed record header, which we adjust as needed
+ * @fmt - format string
+ * @args - arg list
+ */
+static int
+evl_send_printf(struct kern_log_entry *hdr, const char *fmt, va_list args)
+{
+	int ret;
+	struct evl_recbuf b;
+	unsigned long iflags;
+
+	spin_lock_irqsave(&evl_msgbuf_lock, iflags);
+	evl_init_recbuf(&b, evl_msgbuf, EVL_ENTRY_MAXLEN);
+	evl_puts(&b, fmt, 1);
+	evl_zap_newline(&b);
+	evl_end_fmt(&b);
+	evl_pack_args(&b, fmt, args);
+	evl_end_args(&b);
+
+	hdr->log_size = evl_datasz(&b, &hdr->log_flags);
+
+	ret = evl_writeh(hdr, b.b_buf);
+	spin_unlock_irqrestore(&evl_msgbuf_lock, iflags);
+	return ret;
+}
+
+/**
+ * evl_vprintk() - Format and log a PRINTF-format record.
+ * @fmt - format string
+ * @args - arg list
+ * other args as per evl_mk_rechdr().  If event_type == 0, set flag to
+ *	request that recipient set event type.
+ */
+int
+evl_vprintk(const char *facility, int event_type, int severity,
+	const char *fmt, va_list args)
+{
+	struct kern_log_entry hdr;
+	uint flags = 0;
+	if (event_type == 0) {
+		flags |= EVL_EVTYCRC;
+	}
+	evl_mk_rechdr(&hdr, facility, event_type, severity, 1 /*size TBD*/,
+		flags, EVL_PRINTF);
+
+	return evl_send_printf(&hdr, fmt, args);
+}
+
+/**
+ * evl_printk() - Format and log a PRINTF-format record.
+ * @fmt - format string
+ * other args as per evl_mk_rechdr()
+ */
+int
+evl_printk(const char *facility, int event_type, int severity,
+	const char *fmt, ...)
+{
+	va_list args;
+	int ret;
+	va_start(args, fmt);
+	ret = evl_vprintk(facility, event_type, severity, fmt, args);
+	va_end(args);
+	return ret;
+}
+
+EXPORT_SYMBOL(evl_write);
+EXPORT_SYMBOL(evl_printk);
+EXPORT_SYMBOL(evl_vprintk);
+
+EXPORT_SYMBOL(evl_init_recbuf);
+EXPORT_SYMBOL(evl_put);
+EXPORT_SYMBOL(evl_puts);
+EXPORT_SYMBOL(evl_zap_newline);
+EXPORT_SYMBOL(evl_unzap_newline);
+EXPORT_SYMBOL(evl_end_fmt);
+EXPORT_SYMBOL(evl_end_args);
+EXPORT_SYMBOL(evl_datasz);
diff --git a/kernel/evlbuf.c b/kernel/evlbuf.c
new file mode 100644
index 0000000..26874dc
--- /dev/null
+++ b/kernel/evlbuf.c
@@ -0,0 +1,523 @@
+/*
+ * Linux Event Logging
+ * Copyright (C) International Business Machines Corp., 2003
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *  Please send e-mail to kenistoj@users.sourceforge.net if you have
+ *  questions or comments.
+ *
+ *  Project Website:  http://evlog.sourceforge.net/
+ */
+
+#include <linux/kernel.h>
+#include <linux/stddef.h>
+#include <linux/spinlock.h>
+#include <linux/time.h>
+#include <linux/smp.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <asm/uaccess.h>
+#include <linux/semaphore.h>
+#include <linux/module.h>
+#include <linux/ctype.h>
+#include <linux/evlog.h>
+#include <linux/sched.h>
+
+#define REC_HDR_SIZE sizeof(struct kern_log_entry)
+
+extern struct timezone sys_tz;
+
+/* Use same buffer size as printk's, but at least 2x the max rec length. */
+#define EVL_BUF_SIZE (1 << CONFIG_LOG_BUF_SHIFT)
+#if (EVL_BUF_SIZE < 2*EVL_ENTRY_MAXLEN)
+#undef EVL_BUF_SIZE
+#define EVL_BUF_SIZE (2*EVL_ENTRY_MAXLEN)
+#endif
+
+/*
+ * After buffer overflows, require at most this much free space before
+ * logging events again.
+ */
+#define EVL_BUF_DRAINAGE (16*1024U)
+
+/*
+ * This data structure describes the circular buffer that is written into
+ * by evl_writeh() and drained by evl_kbufread().
+ *
+ * bf_buf, bf_len, and bf_end are the start, length, and end of the buffer,
+ * and in the current implementation these remain constant.
+ *
+ * bf_tail advances as event records are logged to the buffer, and bf_head
+ * advances as records are drained from the buffer.  bf_dropped maintains
+ * a count of records that have been dropped due to buffer overrun.
+ * By convention:
+ * - (bf_head == bf_tail) indicates an empty buffer.
+ * - bf_head can take any value from bf_buf through bf_end.
+ * - bf_tail starts out equal to bf_buf, but once the first record is written
+ *	to the buffer, bf_tail never equals bf_buf.  It can equal bf_end.
+ *
+ * It is possible for one task to be draining the buffer while another
+ * is writing to it.  Only evl_kbufread() advances bf_head, and only
+ * copy_rec_to_cbuf() advances bf_tail.  Each advances its respective
+ * pointer only after completing its operation.
+ */
+struct cbuf {
+	char		*bf_buf;	/* base buffer address */
+	unsigned int	bf_len;		/* buffer length */
+	unsigned int	bf_dropped;	/* (internal) dropped count */
+	char		*bf_head;	/* head-pointer for circ. buf */
+	char		*bf_tail;	/* tail-pointer for circ. buf */
+	char		*bf_end;	/* end buffer address */
+};
+
+static char evl_buffer[EVL_BUF_SIZE + sizeof(long)];
+
+static struct cbuf ebuf = {
+	evl_buffer,
+	EVL_BUF_SIZE,
+	0,
+	evl_buffer,
+	evl_buffer,
+	evl_buffer + EVL_BUF_SIZE
+};
+
+/*
+ * evl_read_sem serializes reads of the evlog buffer into user space (although
+ * only the logging daemon should be running evl_kbufread()).
+ *
+ * evl_readq allows the reader to sleep until there's at least one record in
+ * the buffer to read.
+ *
+ * ebuf_lock serializes writes to the evlog buffer.
+ */
+static DECLARE_MUTEX(evl_read_sem);
+static DECLARE_WAIT_QUEUE_HEAD(evl_readq);
+static spinlock_t ebuf_lock = SPIN_LOCK_UNLOCKED;
+
+/*
+ * A region of the evlog circular buffer, possibly split into 2 chunks
+ * due to wraparound.
+ */
+struct cbregion {
+	char	*rg_head;
+	char	*rg_tail;
+	size_t	rg_chunk1;
+	size_t	rg_chunk2;
+};
+
+/**
+ * set_region() - Establish region to be written to or read from.
+ * Caller wants to write to or read from an nbytes-byte region (of the
+ * evlog circular buffer) starting at head.  Figure out whether the
+ * region needs to be 1 chunk (typical) or 2 (due to wraparound),
+ * and populate the region struct accordingly.
+ *
+ * @rg: region struct to be populated
+ * @head: beginning of region to be read/written.  If this is beyond the
+ *	end of the buffer, wrap it around to the beginning.
+ * @nbytes: size of region
+ */
+static void
+set_region(struct cbregion *rg, char *head, size_t nbytes)
+{
+	if (head >= ebuf.bf_end) {
+		head -= ebuf.bf_len;
+	}
+	rg->rg_head = head;
+	rg->rg_tail = head + nbytes;
+	if (rg->rg_tail > ebuf.bf_end) {
+		rg->rg_chunk1 = ebuf.bf_end - head;
+		rg->rg_chunk2 = nbytes - rg->rg_chunk1;
+		rg->rg_tail = ebuf.bf_buf + rg->rg_chunk2;
+	} else {
+		rg->rg_chunk1 = nbytes;
+		rg->rg_chunk2 = 0;
+	}
+}
+
+static void
+copy_from_cbuf(const struct cbregion *rg, char *dest)
+{
+	memcpy(dest, rg->rg_head, rg->rg_chunk1);
+	if (rg->rg_chunk2 != 0) {
+		memcpy(dest + rg->rg_chunk1, ebuf.bf_buf, rg->rg_chunk2);
+	}
+}
+
+static int
+copy_cbuf_to_user(const struct cbregion *rg, char *ubuf)
+{
+	int status;
+	status = copy_to_user(ubuf, rg->rg_head, rg->rg_chunk1);
+	if (rg->rg_chunk2 != 0 && status == 0) {
+		status = copy_to_user(ubuf + rg->rg_chunk1, ebuf.bf_buf,
+			rg->rg_chunk2);
+	}
+	return status;
+}
+
+static void
+copy_to_cbuf(const struct cbregion *rg, const char *src)
+{
+	memcpy(rg->rg_head, src, rg->rg_chunk1);
+	if (rg->rg_chunk2 != 0) {
+		memcpy(ebuf.bf_buf, src + rg->rg_chunk1, rg->rg_chunk2);
+	}
+}
+
+/**
+ * copy_rec_to_cbuf() - Log event (hdr + vardata) to buffer.
+ * Caller has verified that there's enough room.
+ */
+static void
+copy_rec_to_cbuf(const struct kern_log_entry *hdr, const char *vardata)
+{
+	struct cbregion rg;
+	char *tail = ebuf.bf_tail;
+
+	set_region(&rg, tail, REC_HDR_SIZE);
+	copy_to_cbuf(&rg, (const char*) hdr);
+
+	if (hdr->log_size != 0) {
+		set_region(&rg, tail + REC_HDR_SIZE, hdr->log_size);
+		copy_to_cbuf(&rg, vardata);
+	}
+
+	ebuf.bf_tail = rg.rg_tail;
+}
+
+/**
+ * evl_mk_rechdr() - Populate evlog record header.
+ * @facility: facility name (e.g., "kern", driver name)
+ * @event_type: event type (event ID assigned by programmer; may also be
+ *	computed by recipient -- e.g., CRC of format string)
+ * @severity: severity level (e.g., LOG_INFO)
+ * @size: length, in bytes, of variable data
+ * @flags: event flags (e.g., EVL_TRUNCATE, EVL_EVTYCRC)
+ * @format: format of variable data (e.g., EVL_STRING)
+ */
+void
+evl_mk_rechdr(struct kern_log_entry *rec_hdr,
+		const char *facility,
+		int	event_type,
+		int	severity,
+		size_t	size,
+		uint	flags,
+		int	format)
+{
+	struct timespec ts;
+
+	flags |= EVL_KERNEL_EVENT;
+	if (in_interrupt()) {
+		flags |= EVL_INTERRUPT;
+	}
+
+	rec_hdr->log_kmagic		=  LOGREC_KMAGIC;
+	rec_hdr->log_kversion		=  LOGREC_KVERSION;
+	rec_hdr->log_size		=  (__u16) size;
+	rec_hdr->log_format		=  (__s8) format;
+	rec_hdr->log_event_type		=  (__s32) event_type;
+	rec_hdr->log_severity		=  (__s8) severity;
+	rec_hdr->log_uid		=  current_uid();
+	rec_hdr->log_gid		=  current_gid();
+	rec_hdr->log_pid		=  current->pid;
+	rec_hdr->log_pgrp		=  task_pgrp_nr(current);
+	rec_hdr->log_flags		=  (__u32) flags;
+	rec_hdr->log_processor		=  (__s32) get_cpu(); put_cpu();
+
+	strlcpy(rec_hdr->log_facility, facility, FACILITY_MAXLEN);
+
+	if (get_seconds() == 0) {
+		rec_hdr->log_flags |= EVL_INITIAL_BOOT_EVENT;
+	} else {
+#if defined(__i386__)
+		if (sys_tz.tz_minuteswest == 0) {
+			/* localtime */
+			rec_hdr->log_flags |= EVL_KERNTIME_LOCAL;
+		}
+#endif
+	}
+	ts = CURRENT_TIME;
+	rec_hdr->log_time_sec = (time_t) ts.tv_sec;
+	rec_hdr->log_time_nsec = (__s32) ts.tv_nsec;
+}
+
+/**
+ * normalize_header() - Fix up rec header, handling overflow, null vardata, etc.
+ * In case of sloppiness on the part of the caller, we clean it up rather
+ * than failing, since the caller is unlikely to handle failure.
+ */
+static void
+normalize_header(struct kern_log_entry *hdr, const void *vardata)
+{
+	if (hdr->log_severity < 0 || hdr->log_severity > LOG_DEBUG) {
+		hdr->log_severity = LOG_WARNING;
+	}
+	if (vardata == NULL
+	    || hdr->log_size == 0
+	    || hdr->log_format == EVL_NODATA) {
+		hdr->log_size = 0;
+		hdr->log_format = EVL_NODATA;
+	}
+	if (hdr->log_size > EVL_ENTRY_MAXLEN) {
+		hdr->log_size = EVL_ENTRY_MAXLEN;
+		hdr->log_flags |= EVL_TRUNCATE;
+	}
+}
+
+/**
+ * log_dropped_recs_event() - Log message about previously dropped records.
+ * The evlog circular buffer had been full and caused later records to be
+ * dropped.  Now the buffer has some free space again.  Log an event reporting
+ * the number of records dropped.  Caller has verified that there's at least
+ * enough room for this event record.
+ */
+static void
+log_dropped_recs_event(void)
+{
+#define DROP_MSG_SIZE 80
+	char sbuf[DROP_MSG_SIZE];
+	struct kern_log_entry drechdr;
+
+	snprintf(sbuf, DROP_MSG_SIZE,
+		"%d event records dropped due to EVL buffer overflow.",
+		ebuf.bf_dropped);
+	ebuf.bf_dropped = 0;
+	evl_mk_rechdr(&drechdr, "kern", EVL_BUFFER_OVERRUN, LOG_INFO,
+		strlen(sbuf) + 1, 0, EVL_STRING);
+	copy_rec_to_cbuf(&drechdr, sbuf);
+}
+
+/**
+ * evl_check_buf() - Check for space in evlog buffer.
+ * If buffer free space is sufficient to log the indicated record,
+ * return 0.  If not, return -1.
+ *
+ * Once the buffer becomes full and one or more messages are discarded,
+ * a significant portion of the buffer must be drained before we permit
+ * messages to be buffered again.  We count the number of discards
+ * in the meantime and report them when we resume logging events.
+ * If we resumed logging with a nearly full buffer, then there could
+ * be a thrashing of stops and starts, making the discarded-message
+ * reporting annoying.
+ *
+ * @hdr: The header of the record caller intends to log.
+ */
+static int
+evl_check_buf(const struct kern_log_entry *hdr)
+{
+	char *head, *tail;
+	size_t water_mark, avail, recsize;
+
+	recsize = REC_HDR_SIZE + hdr->log_size;
+	head    = ebuf.bf_head;
+	tail	= ebuf.bf_tail;
+	avail   = (head <= tail) ?
+		  (ebuf.bf_len - (tail - head)) :
+		  (head - tail);
+
+	if (ebuf.bf_dropped != 0) {
+		/*
+		 * Still recovering from buffer overflow.
+		 * Apply the low water mark.
+		 */
+		water_mark = min(EVL_BUF_DRAINAGE, ebuf.bf_len / 2);
+		/*
+		 * Just in case recsize is huge and/or somebody cranks the
+		 * buffer size and/or EVL_BUF_DRAINAGE way down, make
+		 * sure we have room for this record AND the "records dropped"
+		 * message.
+		 */
+		water_mark = max(water_mark,
+			recsize + REC_HDR_SIZE + DROP_MSG_SIZE);
+	} else {
+		/* +1 because bf_tail must never catch up with bf_head. */
+		water_mark = recsize + 1;
+	}
+
+	if (avail < water_mark) {
+		return -1;
+	}
+
+	/* There's enough free buffer space.  Return success. */
+	if (ebuf.bf_dropped != 0) {
+		log_dropped_recs_event();
+	}
+	return 0;
+}
+
+/**
+ * evl_kbufread() - Copy records from evlog circular buffer into user space.
+ * If successful, returns the number of bytes copied; else returns a
+ * negative error code.
+ *
+ * @retbuf: pointer to the buffer to be filled with the event records
+ * @bufsize: length, in bytes, of retbuf
+ */
+int
+evl_kbufread(char *retbuf, size_t bufsize)
+{
+	char *rec;
+	size_t rec_size;
+	int error = 0;
+	int retbuflen = 0;
+	char *tail, *buf = retbuf;
+
+	if (bufsize < REC_HDR_SIZE) {
+		return -EINVAL;
+	}
+
+	if (ebuf.bf_head == ebuf.bf_tail && ebuf.bf_dropped != 0) {
+		/*
+		 * Probable scenario:
+		 * 1. Somebody logged a huge burst of events and overflowed
+		 * the buffer.  At this point, there was no room for the
+		 * "records dropped" message.
+		 * 2. evlogd drained the buffer, and is now back for more.
+		 */
+		unsigned long iflags;
+		spin_lock_irqsave(&ebuf_lock, iflags);
+		log_dropped_recs_event();
+		spin_unlock_irqrestore(&ebuf_lock, iflags);
+	}
+
+	/*
+	 * We expect that only the logging daemon will be running here,
+	 * but serialize access just in case.
+	 */
+	error = down_interruptible(&evl_read_sem);
+	if (error == -EINTR) {
+		return -EINTR;
+	}
+	/* Go to sleep if the buffer is empty.  */
+	error = wait_event_interruptible(evl_readq,
+		(ebuf.bf_head != ebuf.bf_tail));
+	if (error) {
+		up(&evl_read_sem);
+		return error;
+	}
+	/*
+	 * Assemble message(s) into the user buffer, as many as will
+	 * fit.  On running out of space in the buffer, try to copy
+	 * the header for the overflowing message.  This means that
+	 * there will always be at least a header returned.  The caller
+	 * must compare the numbers of bytes returned (remaining) with
+	 * the length of the message to see if the entire message is
+	 * present.  A subsequent read will get the entire message,
+	 * including the header (again).
+	 *
+	 * For simplicity, take a snapshot of bf_tail, and don't read
+	 * past that even if evl_writeh() pours in more records while
+	 * we're draining.  We'll get those new records next time around.
+	 */
+	tail = ebuf.bf_tail;
+	rec = ebuf.bf_head;
+	if (rec == tail) {
+		/* Should not happen. Buffer must have at least one record. */
+		error = -EFAULT;
+		goto out;
+	}
+
+	do {
+		struct cbregion rg;
+		__u16 vardata_size;	/* type must match rec.log_size */
+
+		if (bufsize < REC_HDR_SIZE) {
+			break;
+		}
+
+		/*
+		 * Extract log_size from header, which could be split due to
+		 * wraparound, or misaligned.
+		 */
+		set_region(&rg, rec+offsetof(struct kern_log_entry, log_size),
+			sizeof(vardata_size));
+		copy_from_cbuf(&rg, (char*) &vardata_size);
+		rec_size = REC_HDR_SIZE + vardata_size;
+
+		if (bufsize < rec_size) {
+			/*
+			 * Copyout only the header 'cause user buffer can't
+			 * hold full record.
+			 */
+			set_region(&rg, rec, REC_HDR_SIZE);
+			error = copy_cbuf_to_user(&rg, buf);
+			if (error) {
+				error = -EFAULT;
+				break;
+			}
+			bufsize -= REC_HDR_SIZE;
+			retbuflen += REC_HDR_SIZE;
+			break;
+		}
+		set_region(&rg, rec, rec_size);
+		error = copy_cbuf_to_user(&rg, buf);
+		if (error) {
+			error = -EFAULT;
+			break;
+		}
+		rec = rg.rg_tail;
+		buf += rec_size;
+		bufsize -= rec_size;
+		retbuflen += rec_size;
+	} while (rec != tail);
+
+	if (error == 0) {
+		ebuf.bf_head = rec;
+		error = retbuflen;
+	}
+
+out:
+	up(&evl_read_sem);
+	return(error);
+}
+
+/**
+ * evl_writeh() - Log event, given a pre-constructed header.
+ * Returns 0 on success, or a negative error code otherwise.
+ * For caller's convenience, we normalize the header as needed.
+ */
+int
+evl_writeh(struct kern_log_entry *hdr, const char *vardata)
+{
+	char *oldtail = ebuf.bf_tail;
+	unsigned long iflags;	/* for spin_lock_irqsave() */
+
+	normalize_header(hdr, vardata);
+
+	spin_lock_irqsave(&ebuf_lock, iflags);
+	if (evl_check_buf(hdr) < 0) {
+		ebuf.bf_dropped++;
+		spin_unlock_irqrestore(&ebuf_lock, iflags);
+		return -ENOSPC;
+	}
+
+	copy_rec_to_cbuf(hdr, vardata);
+	/*
+	 * If the variable portion is a truncated string, make sure it
+	 * ends with a null character.
+	 */
+	if ((hdr->log_flags & EVL_TRUNCATE) && hdr->log_format == EVL_STRING) {
+		*(ebuf.bf_tail - 1) = '\0';
+	}
+
+	if ((ebuf.bf_head == oldtail) &&
+	    (ebuf.bf_head != ebuf.bf_tail)) {
+		wake_up_interruptible(&evl_readq);
+	}
+	spin_unlock_irqrestore(&ebuf_lock, iflags);
+	return 0;
+}
diff --git a/kernel/evlposix.c b/kernel/evlposix.c
new file mode 100644
index 0000000..e60c6bb
--- /dev/null
+++ b/kernel/evlposix.c
@@ -0,0 +1,400 @@
+/*
+ * Linux Event Logging
+ * Copyright (C) International Business Machines Corp., 2001
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *  Please send e-mail to kenistoj@users.sourceforge.net if you have
+ *  questions or comments.
+ *
+ *  Project Website:  http://evlog.sourceforge.net/
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/evl_log.h>
+
+/*
+ * This file implements the "legacy" functions defined in early releases of
+ * Event Logging.  Consider using the newer functions declared in evlog.h --
+ * e.g., evl_write(), evl_printk(), evl_vprintk().
+ */
+
+extern spinlock_t evl_msgbuf_lock;
+extern char evl_msgbuf[];
+
+enum base_type {
+	TY_NONE,
+	TY_CHAR,
+	TY_UCHAR,
+	TY_SHORT,
+	TY_USHORT,
+	TY_INT,
+	TY_UINT,
+	TY_LONG,
+	TY_ULONG,
+	TY_LONGLONG,
+	TY_ULONGLONG,
+	TY_STRING,
+	TY_ADDRESS
+};
+
+static struct type_info {
+	size_t	ti_size;
+	char	*ti_name;
+} type_info[] = {
+	{0,			"none"},
+	{sizeof(char),		"char"},
+	{sizeof(unsigned char),	"uchar"},
+	{sizeof(short),		"short"},
+	{sizeof(unsigned short),"ushort"},
+	{sizeof(int),		"int"},
+	{sizeof(unsigned int),	"uint"},
+	{sizeof(long),		"long"},
+	{sizeof(unsigned long),	"ulong"},
+	{sizeof(long long),	"longlong"},
+	{sizeof(unsigned long long),	"ulonglong"},
+	{0,			"string"},
+	{sizeof(void*),		"address"},
+	{0,			NULL}
+};
+
+struct att_type_info {
+	enum base_type	at_type;    /* TY_INT for "int", "int[]", or "2*int" */
+	int		at_nelements;	/* 5 for "5*int */
+	int		at_array;	/* 1 (true) for "int[]" */
+};
+
+static enum base_type
+get_type_by_name(const char *name)
+{
+	enum base_type i;
+	for (i = TY_NONE+1; type_info[i].ti_name; i++) {
+		if (!strcmp(name, type_info[i].ti_name)) {
+			return i;
+		}
+	}
+	return TY_NONE;
+}
+
+/*
+ * att_type should be a type spec such as "int", "int[]", or "5*int".  Parse it
+ * and fill in *ti accordingly.	 Returns 0 on success, -1 on failure.
+ */
+static int
+parse_att_type(const char *att_type, struct att_type_info *ti)
+{
+	const char *s, *left_bracket;
+	const char *type_name;
+#define MAX_TYPE_NAME_LEN 20
+	char name_buf[MAX_TYPE_NAME_LEN+1];
+
+	if (isdigit(att_type[0])) {
+		/* "5*int" */
+		ti->at_nelements =
+			(int) simple_strtoul(att_type, (char**) &s, 10);
+		if (*s != '*') {
+			return -1;
+		}
+		type_name = s+1;
+		ti->at_array = 0;
+	} else if ((left_bracket = strchr(att_type, '[')) != NULL) {
+		/* int[] */
+		size_t name_len;
+		ti->at_array = 1;
+		ti->at_nelements = 0;
+		if (0 != strcmp(left_bracket, "[]")) {
+			return -1;
+		}
+		/* Copy the name to name_buf and point type_name at it. */
+		type_name = name_buf;
+		name_len = left_bracket - att_type;
+		if (name_len == 0 || name_len > MAX_TYPE_NAME_LEN) {
+			return -1;
+		}
+		(void) memcpy(name_buf, att_type, name_len);
+		name_buf[name_len] = '\0';
+	} else {
+		/* "int" */
+		type_name = att_type;
+		ti->at_array = 0;
+		ti->at_nelements = 1;
+	}
+	ti->at_type = get_type_by_name(type_name);
+	return (ti->at_type == TY_NONE ? -1 : 0);
+}
+
+/*
+ * COPYARGS copies n args of type lt (little type) from the stack into
+ * buffer b.  bt (big type) is the type of the arg as it appears on the stack.
+ */
+#define COPYARGS(lt,bt) \
+{ \
+	while(n-- > 0) { \
+		lt v=(lt)va_arg(args,bt); \
+		evl_put(b, &v, sizeof(lt)); \
+	} \
+}
+
+#ifdef CONFIG_ARCH_S390X
+#define INTARG long
+#else
+#define INTARG int
+#endif
+
+/**
+ * pack_typed_args() - Does most of the work of evl_writek.
+ */
+static int
+pack_typed_args(struct evl_recbuf *b, va_list args)
+{
+	char *att_type;
+
+	while ((att_type = va_arg(args, char*)) &&
+	    (0 != strcmp(att_type, "endofdata"))) {
+		struct att_type_info ti;
+		if (parse_att_type(att_type, &ti) == -1) {
+			return -EINVAL;
+		}
+		if (ti.at_array) {
+			char *array;
+			size_t size = type_info[ti.at_type].ti_size;
+			int n;
+
+			/* Next arg is the array size. */
+			n = va_arg(args, INTARG);
+			/* Next arg is the array address. */
+			array = (char*) va_arg(args, void*);
+
+			switch (ti.at_type) {
+			case TY_STRING:
+			    {
+				/* array points to an array of char* */
+				char **sarray = (char**)array;
+				int i;
+				for (i = 0; i < n; i++) {
+					evl_puts(b, sarray[i], 1);
+				}
+				break;
+			    }
+			default:
+				evl_put(b, array, n*size);
+				break;
+			}
+		} else {
+			/*
+			 * One or more args of the same type.
+			 */
+			int n = ti.at_nelements;
+			switch (ti.at_type) {
+			case TY_CHAR:
+			case TY_UCHAR:
+				COPYARGS(char, INTARG)
+				break;
+			case TY_SHORT:
+			case TY_USHORT:
+				COPYARGS(short, INTARG)
+				break;
+			case TY_INT:
+			case TY_UINT:
+				COPYARGS(int, INTARG)
+				break;
+			case TY_LONG:
+			case TY_ULONG:
+				COPYARGS(long, long)
+				break;
+			case TY_LONGLONG:
+			case TY_ULONGLONG:
+				COPYARGS(long long, long long)
+				break;
+			case TY_ADDRESS:
+				COPYARGS(void*, void*)
+				break;
+			case TY_STRING:
+			    {
+				char *s;
+				while (n-- > 0) {
+					s = (char *) va_arg(args, char*);
+					evl_puts(b, s, 1);
+				}
+				break;
+			    }
+			default:
+				break;
+			} /* end of switch */
+		} /* not array */
+	} /* next att_type */
+
+	return 0;
+}
+
+/*
+ * These functions are used for logging events with log_format of
+ * EVL_BINARY.  See event logging specification at
+ * http://evlog.sourceforge.net/linuxEvlog.html
+ * for details.
+ */
+int evl_writek(posix_log_facility_t facility, int event_type,
+	posix_log_severity_t severity, unsigned int flags, ...)
+{
+	va_list args;
+	int ret = 0;
+
+	va_start(args, flags);
+	ret = evl_vwritek(facility, event_type, severity, flags, args);
+	va_end(args);
+
+	return ret;
+}
+
+int evl_vwritek(posix_log_facility_t facility, int event_type,
+	posix_log_severity_t severity, unsigned int flags, va_list args)
+{
+	unsigned long iflags;
+	struct evl_recbuf b;
+	int ret;
+	size_t reclen;
+
+	spin_lock_irqsave(&evl_msgbuf_lock, iflags);
+	evl_init_recbuf(&b, evl_msgbuf, EVL_ENTRY_MAXLEN);
+	ret = pack_typed_args(&b, args);
+	if (ret == 0) {
+		reclen = evl_datasz(&b, &flags);
+		ret = evl_write(facility, event_type, severity,
+			b.b_buf, reclen, flags, EVL_BINARY);
+	}
+	spin_unlock_irqrestore(&evl_msgbuf_lock, iflags);
+	return ret;
+}
+
+/*
+ * These functions are used for logging events with log_format of
+ * EVL_STRING.  See event logging specification at
+ * http://evlog.sourceforge.net/linuxEvlog.html
+ * for details.
+ */
+int posix_log_printf(posix_log_facility_t facility, int event_type,
+	posix_log_severity_t severity, unsigned int flags, const char *fmt, ...)
+{
+	int ret = 0;
+	va_list args;
+
+	if (!fmt) {
+		return evl_write(facility, event_type, severity, NULL, 0,
+			flags, EVL_NODATA);
+	}
+
+	va_start(args, fmt);
+	ret = posix_log_vprintf(facility, event_type, severity, flags, fmt,
+		args);
+	va_end(args);
+	return ret;
+}
+
+int posix_log_vprintf(posix_log_facility_t facility, int event_type,
+	posix_log_severity_t severity, unsigned int flags, const char *fmt,
+	va_list args)
+{
+	size_t recsize;
+	int ret;
+	unsigned long iflags;
+
+	if (!fmt) {
+		return evl_write(facility, event_type, severity, NULL, 0,
+			flags, EVL_NODATA);
+	}
+
+	spin_lock_irqsave(&evl_msgbuf_lock, iflags);
+	recsize = 1 + vsnprintf(evl_msgbuf, EVL_ENTRY_MAXLEN, fmt, args);
+	if (recsize > EVL_ENTRY_MAXLEN) {
+		recsize = EVL_ENTRY_MAXLEN;
+		flags |= EVL_TRUNCATE;
+	}
+	ret = evl_write(facility, event_type, severity, evl_msgbuf, recsize,
+		flags, EVL_STRING);
+	spin_unlock_irqrestore(&evl_msgbuf_lock, iflags);
+	return ret;
+}
+
+/*
+ * This is the standard POSIX function for writing events to the event log.
+ * See event logging specification at:
+ * http://evlog.sourceforge.net/linuxEvlog.html
+ */
+int posix_log_write(posix_log_facility_t facility, int event_type,
+	posix_log_severity_t severity, const void *buf,
+	size_t recsize, int format, unsigned int flags)
+{
+	if (!buf || recsize == 0 || format == EVL_NODATA) {
+		buf = NULL;
+		recsize = 0;
+		format = EVL_NODATA;
+	}
+	if (format == EVL_STRING && strlen((const char*)buf) != recsize-1) {
+		return -EBADMSG;
+	}
+
+	return evl_write(facility, event_type, severity, buf, recsize, flags,
+		format);
+}
+
+/**
+ * evl_gen_facility_code() - Generate facility "code" from facility name
+ * The code is just a strdup of the name.
+ */
+int evl_gen_facility_code(const char *fname, posix_log_facility_t *fcode)
+{
+	size_t name_len;
+	char *s;
+
+	if (!fname || !fcode) {
+		return -EINVAL;
+	}
+
+	name_len = strlen(fname);
+	if (name_len == 0 || name_len >= POSIX_LOG_MEMSTR_MAXLEN) {
+		return -EINVAL;
+	}
+
+	s = kmalloc(name_len+1, GFP_KERNEL);
+	if (!s) {
+		return -ENOMEM;
+	}
+	(void) strcpy(s, fname);
+	*fcode = s;
+	return 0;
+}
+
+/**
+ * evl_register_facility() - Generate "code" from name; pretend to register
+ * We no longer register the facility from the kernel.
+ */
+int evl_register_facility(const char *fname, posix_log_facility_t *fcode)
+{
+	return evl_gen_facility_code(fname, fcode);
+}
+
+EXPORT_SYMBOL(evl_writek);
+EXPORT_SYMBOL(evl_vwritek);
+EXPORT_SYMBOL(posix_log_write);
+EXPORT_SYMBOL(posix_log_printf);
+EXPORT_SYMBOL(posix_log_vprintf);
+EXPORT_SYMBOL(evl_gen_facility_code);
+EXPORT_SYMBOL(evl_register_facility);
diff --git a/kernel/printk.c b/kernel/printk.c
index 4c912cf..cda2038 100644
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -198,6 +198,10 @@ static int preferred_console = -1;
 int console_set_on_cmdline;
 EXPORT_SYMBOL(console_set_on_cmdline);
 
+#ifdef CONFIG_EVLOG
+extern int evl_kbufread(char *, size_t);
+#endif
+
 /* Flag: console code may call schedule() */
 static int console_may_schedule;
 
@@ -463,6 +467,14 @@ int do_syslog(int type, char __user *buf, int len, bool from_file)
 	case SYSLOG_ACTION_SIZE_BUFFER:
 		error = log_buf_len;
 		break;
+	case SYSLOG_ACTION_READ_EVL_BUFF:
+#ifdef CONFIG_EVLOG
+		if (!access_ok(VERIFY_WRITE, buf, len)) return -EFAULT;
+		error = evl_kbufread(buf, len);
+#else
+		error = -EIO;
+#endif
+		break;
 	default:
 		error = -EINVAL;
 		break;
-- 
1.6.5.2

