From 11df925653939d80b6838a2468c55305a07c8b25 Mon Sep 17 00:00:00 2001
From: Frederic Weisbecker <fweisbec@gmail.com>
Date: Tue, 18 Mar 2014 22:54:04 +0100
Subject: [PATCH] nohz: Use IPI implicit full barrier against rq->nr_running
 r/w

commit 3882ec643997757824cd5f25180cd8a787b9dbe1 upstream.

A full dynticks CPU is allowed to stop its tick when a single task runs.
Meanwhile when a new task gets enqueued, the CPU must be notified so that
it can restart its tick to maintain local fairness and other accounting
details.

This notification is performed by way of an IPI. Then when the target
receives the IPI, we expect it to see the new value of rq->nr_running.

Hence the following ordering scenario:

   CPU 0                   CPU 1

   write rq->running       get IPI
   smp_wmb()               smp_rmb()
   send IPI                read rq->nr_running

But Paul Mckenney says that nowadays IPIs imply a full barrier on
all architectures. So we can safely remove this pair and rely on the
implicit barriers that come along IPI send/receive. Lets
just comment on this new assumption.

Acked-by: Peter Zijlstra <peterz@infradead.org>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Ingo Molnar <mingo@kernel.org>
Cc: Kevin Hilman <khilman@linaro.org>
Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Thomas Gleixner <tglx@linutronix.de>
Cc: Viresh Kumar <viresh.kumar@linaro.org>
Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 0dcaa2401c27..74a0f1d048b0 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -724,11 +724,10 @@ bool sched_can_stop_tick(void)
 
 	rq = this_rq();
 
-	/* Make sure rq->nr_running update is visible after the IPI */
-	smp_rmb();
-
 	/*
-	 * More than one running task need preemption
+	 * More than one running task need preemption.
+	 * nr_running update is assumed to be visible
+	 * after IPI is sent from wakers.
 	 *
 	 * NOTE, RT: if ksoftirqd is awake, subtract it.
 	 */
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
index c391761ad542..1b0d0bd6531b 100644
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -1081,8 +1081,14 @@ static inline void add_nr_running(struct rq *rq, unsigned count)
 #ifdef CONFIG_NO_HZ_FULL
 	if (prev_nr < 2 && rq->nr_running >= 2) {
 		if (tick_nohz_full_cpu(rq->cpu)) {
-			/* Order rq->nr_running write against the IPI */
-			smp_wmb();
+			/*
+			 * Tick is needed if more than one task runs on a CPU.
+			 * Send the target an IPI to kick it out of nohz mode.
+			 *
+			 * We assume that IPI implies full memory barrier and the
+			 * new value of rq->nr_running is visible on reception
+			 * from the target.
+			 */
 			tick_nohz_full_kick_cpu(rq->cpu);
 		}
        }
-- 
2.4.3

