From ee75690b2fc3f13b92973fad159565582776b784 Mon Sep 17 00:00:00 2001
From: Nam Ninh <nam.ninh@windriver.com>
Date: Fri, 6 Jun 2014 11:11:21 -0400
Subject: [PATCH] trace: Add fmt checking in find_next_mod_format

The kernel generates this calltrace when this trace cmd is run:
trace-cmd record -p function_graph -e irq_handler_entry -l do_IRQ sleep 10

BUG: unable to handle kernel NULL pointer dereference at (null)
IP: [<ffffffff810e5562>] t_show+0x22/0xe0
PGD 34f000067 PUD 352b65067 PMD 0
Oops: 0000 [#1] PREEMPT SMP
<snip>
Call Trace:
 [<ffffffff81180500>] seq_read+0x240/0x3d0
 [<ffffffff8115d3f8>] vfs_read+0x98/0x150
 [<ffffffff8115dde9>] SyS_read+0x49/0xa0
 [<ffffffff810c22f6>] ? __audit_syscall_exit+0x236/0x2e0
 [<ffffffff8197d906>] system_call_fastpath+0x1a/0x1f

When we run the command, debug information shows find_next_mod_format returns
either NULL right after searching the module list or the pointer to
mod_fmt->fmt at the end. It's fine to return NULL to indicate we cannot find
any fmt. The problem is mod_fmt->fmt is not checked before
its pointer is returned. In this case, mod_fmt->fmt points to NULL, but we
still return &mod_fmt. The higher up caller thinks this is the pointer to a
found fmt record and tries to access it, so it triggers the calltrace.

Signed-off-by: Nam Ninh <nam.ninh@windriver.com>
---
 kernel/trace/trace_printk.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/kernel/trace/trace_printk.c b/kernel/trace/trace_printk.c
index 2900817..16fa4af 100644
--- a/kernel/trace/trace_printk.c
+++ b/kernel/trace/trace_printk.c
@@ -151,6 +151,9 @@ find_next_mod_format(int start_index, void *v, const char **fmt, loff_t *pos)
 
 	mod_fmt = container_of(mod_fmt->list.next, typeof(*mod_fmt), list);
 
+	if (mod_fmt->fmt == NULL)
+		return NULL;
+
 	return &mod_fmt->fmt;
 }
 
-- 
1.8.2.3

