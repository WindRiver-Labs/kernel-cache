From 36970bb91d89618d3495babf44b934e9c9db6bbc Mon Sep 17 00:00:00 2001
From: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
Date: Thu, 30 Jan 2014 15:49:29 -0800
Subject: [PATCH] rcutorture: Privatize fullstop

commit 36970bb91d89618d3495babf44b934e9c9db6bbc upstream.

This commit introduces the torture_must_stop() function in order to
keep use of the fullstop variable local to kernel/torture.c.  There
is also a torture_must_stop_irq() counterpart for use from RCU callbacks,
timeout handlers, and the like.

Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Reviewed-by: Josh Triplett <josh@joshtriplett.org>

diff --git a/include/linux/torture.h b/include/linux/torture.h
index 742d8a4..0259db3 100644
--- a/include/linux/torture.h
+++ b/include/linux/torture.h
@@ -41,12 +41,6 @@
 	module_param(name, type, 0444); \
 	MODULE_PARM_DESC(name, msg);
 
-/* Mediate rmmod and system shutdown.  Concurrent rmmod & shutdown illegal! */
-#define FULLSTOP_DONTSTOP 0	/* Normal operation. */
-#define FULLSTOP_SHUTDOWN 1	/* System shutdown with rcutorture running. */
-#define FULLSTOP_RMMOD    2	/* Normal rmmod of rcutorture. */
-extern int fullstop;
-
 #define TORTURE_FLAG "-torture:"
 #define TOROUT_STRING(s) \
 	pr_alert("%s" TORTURE_FLAG s "\n", torture_type)
@@ -85,5 +79,7 @@ void torture_shutdown_absorb(const char *title);
 void torture_init_begin(char *ttype, bool v);
 void torture_init_end(void);
 bool torture_cleanup(void);
+bool torture_must_stop(void);
+bool torture_must_stop_irq(void);
 
 #endif /* __LINUX_TORTURE_H */
diff --git a/kernel/rcu/rcutorture.c b/kernel/rcu/rcutorture.c
index 2560e93..9357c88 100644
--- a/kernel/rcu/rcutorture.c
+++ b/kernel/rcu/rcutorture.c
@@ -304,7 +304,7 @@ rcu_torture_cb(struct rcu_head *p)
 	int i;
 	struct rcu_torture *rp = container_of(p, struct rcu_torture, rtort_rcu);
 
-	if (fullstop != FULLSTOP_DONTSTOP) {
+	if (torture_must_stop_irq()) {
 		/* Test is ending, just drop callbacks on the floor. */
 		/* The next initialization will pick up the pieces. */
 		return;
@@ -572,8 +572,7 @@ static int rcu_torture_boost(void *arg)
 		while (ULONG_CMP_LT(jiffies, oldstarttime)) {
 			schedule_timeout_interruptible(oldstarttime - jiffies);
 			rcu_stutter_wait("rcu_torture_boost");
-			if (kthread_should_stop() ||
-			    fullstop != FULLSTOP_DONTSTOP)
+			if (torture_must_stop())
 				goto checkwait;
 		}
 
@@ -595,8 +594,7 @@ static int rcu_torture_boost(void *arg)
 			}
 			cond_resched();
 			rcu_stutter_wait("rcu_torture_boost");
-			if (kthread_should_stop() ||
-			    fullstop != FULLSTOP_DONTSTOP)
+			if (torture_must_stop())
 				goto checkwait;
 		}
 
@@ -621,7 +619,7 @@ static int rcu_torture_boost(void *arg)
 
 		/* Go do the stutter. */
 checkwait:	rcu_stutter_wait("rcu_torture_boost");
-	} while (!kthread_should_stop() && fullstop  == FULLSTOP_DONTSTOP);
+	} while (!torture_must_stop());
 
 	/* Clean up and exit. */
 	VERBOSE_TOROUT_STRING("rcu_torture_boost task stopping");
@@ -659,7 +657,7 @@ rcu_torture_fqs(void *arg)
 			fqs_burst_remaining -= fqs_holdoff;
 		}
 		rcu_stutter_wait("rcu_torture_fqs");
-	} while (!kthread_should_stop() && fullstop == FULLSTOP_DONTSTOP);
+	} while (!torture_must_stop());
 	VERBOSE_TOROUT_STRING("rcu_torture_fqs task stopping");
 	torture_shutdown_absorb("rcu_torture_fqs");
 	while (!kthread_should_stop())
@@ -731,7 +729,7 @@ rcu_torture_writer(void *arg)
 		}
 		rcutorture_record_progress(++rcu_torture_current_version);
 		rcu_stutter_wait("rcu_torture_writer");
-	} while (!kthread_should_stop() && fullstop == FULLSTOP_DONTSTOP);
+	} while (!torture_must_stop());
 	VERBOSE_TOROUT_STRING("rcu_torture_writer task stopping");
 	torture_shutdown_absorb("rcu_torture_writer");
 	while (!kthread_should_stop())
@@ -768,7 +766,7 @@ rcu_torture_fakewriter(void *arg)
 			cur_ops->exp_sync();
 		}
 		rcu_stutter_wait("rcu_torture_fakewriter");
-	} while (!kthread_should_stop() && fullstop == FULLSTOP_DONTSTOP);
+	} while (!torture_must_stop());
 
 	VERBOSE_TOROUT_STRING("rcu_torture_fakewriter task stopping");
 	torture_shutdown_absorb("rcu_torture_fakewriter");
@@ -913,7 +911,7 @@ rcu_torture_reader(void *arg)
 		cur_ops->readunlock(idx);
 		schedule();
 		rcu_stutter_wait("rcu_torture_reader");
-	} while (!kthread_should_stop() && fullstop == FULLSTOP_DONTSTOP);
+	} while (!torture_must_stop());
 	VERBOSE_TOROUT_STRING("rcu_torture_reader task stopping");
 	torture_shutdown_absorb("rcu_torture_reader");
 	if (irqreader && cur_ops->irq_capable)
@@ -1022,9 +1020,6 @@ rcu_torture_stats_print(void)
 /*
  * Periodically prints torture statistics, if periodic statistics printing
  * was specified via the stat_interval module parameter.
- *
- * No need to worry about fullstop here, since this one doesn't reference
- * volatile state or register callbacks.
  */
 static int
 rcu_torture_stats(void *arg)
@@ -1034,7 +1029,7 @@ rcu_torture_stats(void *arg)
 		schedule_timeout_interruptible(stat_interval * HZ);
 		rcu_torture_stats_print();
 		torture_shutdown_absorb("rcu_torture_stats");
-	} while (!kthread_should_stop());
+	} while (!torture_must_stop());
 	VERBOSE_TOROUT_STRING("rcu_torture_stats task stopping");
 	return 0;
 }
@@ -1241,16 +1236,15 @@ static int rcu_torture_barrier_cbs(void *arg)
 		wait_event(barrier_cbs_wq[myid],
 			   (newphase =
 			    ACCESS_ONCE(barrier_phase)) != lastphase ||
-			   kthread_should_stop() ||
-			   fullstop != FULLSTOP_DONTSTOP);
+			   torture_must_stop());
 		lastphase = newphase;
 		smp_mb(); /* ensure barrier_phase load before ->call(). */
-		if (kthread_should_stop() || fullstop != FULLSTOP_DONTSTOP)
+		if (torture_must_stop())
 			break;
 		cur_ops->call(&rcu, rcu_torture_barrier_cbf);
 		if (atomic_dec_and_test(&barrier_cbs_count))
 			wake_up(&barrier_wq);
-	} while (!kthread_should_stop() && fullstop == FULLSTOP_DONTSTOP);
+	} while (!torture_must_stop());
 	VERBOSE_TOROUT_STRING("rcu_torture_barrier_cbs task stopping");
 	torture_shutdown_absorb("rcu_torture_barrier_cbs");
 	while (!kthread_should_stop())
@@ -1275,9 +1269,8 @@ static int rcu_torture_barrier(void *arg)
 			wake_up(&barrier_cbs_wq[i]);
 		wait_event(barrier_wq,
 			   atomic_read(&barrier_cbs_count) == 0 ||
-			   kthread_should_stop() ||
-			   fullstop != FULLSTOP_DONTSTOP);
-		if (kthread_should_stop() || fullstop != FULLSTOP_DONTSTOP)
+			   torture_must_stop());
+		if (torture_must_stop())
 			break;
 		n_barrier_attempts++;
 		cur_ops->cb_barrier(); /* Implies smp_mb() for wait_event(). */
@@ -1287,7 +1280,7 @@ static int rcu_torture_barrier(void *arg)
 		}
 		n_barrier_successes++;
 		schedule_timeout_interruptible(HZ / 10);
-	} while (!kthread_should_stop() && fullstop == FULLSTOP_DONTSTOP);
+	} while (!torture_must_stop());
 	VERBOSE_TOROUT_STRING("rcu_torture_barrier task stopping");
 	torture_shutdown_absorb("rcu_torture_barrier");
 	while (!kthread_should_stop())
@@ -1585,7 +1578,6 @@ rcu_torture_init(void)
 	else
 		nrealreaders = 2 * num_online_cpus();
 	rcu_torture_print_module_parms(cur_ops, "Start of test");
-	fullstop = FULLSTOP_DONTSTOP;
 
 	/* Set up the freelist. */
 
diff --git a/kernel/torture.c b/kernel/torture.c
index b02fa27..ed360cf 100644
--- a/kernel/torture.c
+++ b/kernel/torture.c
@@ -52,8 +52,11 @@ MODULE_AUTHOR("Paul E. McKenney <paulmck@us.ibm.com>");
 static char *torture_type;
 static bool verbose;
 
-int fullstop = FULLSTOP_RMMOD;
-EXPORT_SYMBOL_GPL(fullstop);
+/* Mediate rmmod and system shutdown.  Concurrent rmmod & shutdown illegal! */
+#define FULLSTOP_DONTSTOP 0	/* Normal operation. */
+#define FULLSTOP_SHUTDOWN 1	/* System shutdown with torture running. */
+#define FULLSTOP_RMMOD    2	/* Normal rmmod of torture. */
+static int fullstop = FULLSTOP_RMMOD;
 static DEFINE_MUTEX(fullstop_mutex);
 
 #ifdef CONFIG_HOTPLUG_CPU
@@ -458,6 +461,7 @@ void __init torture_init_begin(char *ttype, bool v)
 	mutex_lock(&fullstop_mutex);
 	torture_type = ttype;
 	verbose = v;
+	fullstop = FULLSTOP_DONTSTOP;
 
 }
 EXPORT_SYMBOL_GPL(torture_init_begin);
@@ -498,3 +502,22 @@ bool torture_cleanup(void)
 	return false;
 }
 EXPORT_SYMBOL_GPL(torture_cleanup);
+
+/*
+ * Is it time for the current torture test to stop?
+ */
+bool torture_must_stop(void)
+{
+	return torture_must_stop_irq() || kthread_should_stop();
+}
+EXPORT_SYMBOL_GPL(torture_must_stop);
+
+/*
+ * Is it time for the current torture test to stop?  This is the irq-safe
+ * version, hence no check for kthread_should_stop().
+ */
+bool torture_must_stop_irq(void)
+{
+	return fullstop != FULLSTOP_DONTSTOP;
+}
+EXPORT_SYMBOL_GPL(torture_must_stop_irq);
-- 
1.8.2.3

