From b53b1bed5dda503311782203d8194001fb12b9a6 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Thu, 16 May 2013 10:56:58 -0400
Subject: [PATCH] cputime: take irq lock in task_gtime and fetch_task_cputime

Both fetch_task_cputime and task_gtime run in HARDIRQ-ON-W
state (from kernel threads).  So they need to be doing
irqsave locking, to prevent lockdep splats like this (the
fetch_task_cputime instance is shown here):

=================================
[ INFO: inconsistent lock state ]
3.4.34-ovp1-rt40-WR5.0.1.0_preempt-rt+ #42 Not tainted
---------------------------------
inconsistent {IN-HARDIRQ-W} -> {HARDIRQ-ON-W} usage.
cryptomgr_test/84 [HC0[0]:SC0[0]:HE1:SE1] takes:
 (&p->vtime_lock){?.....}, at: [<ffffffff810a04b1>] fetch_task_cputime+0x51/0xf0
{IN-HARDIRQ-W} state was registered at:
  [<ffffffff810baeaf>] __lock_acquire+0x72f/0x1d60
  [<ffffffff810bca3f>] lock_acquire+0x9f/0xd0
  [<ffffffff816d0526>] _raw_spin_lock+0x36/0x50
  [<ffffffff810a0aa2>] vtime_account_irq_exit+0x32/0x70
  [<ffffffff8107607a>] irq_exit+0x1a/0xc0
  [<ffffffff8103b9ce>] do_IRQ+0x5e/0xd0
  [<ffffffff816d0b6c>] ret_from_intr+0x0/0x13
  [<ffffffff81059d56>] ioapic_read_entry+0x46/0x60
  [<ffffffff81059dce>] save_ioapic_entries+0x5e/0xb0
  [<ffffffff819d2920>] enable_IR_x2apic+0x34/0x202
  [<ffffffff819d48b3>] default_setup_apic_routing+0x12/0x78
  [<ffffffff819d07a7>] native_smp_prepare_cpus+0x39f/0x3e6
  [<ffffffff819c39d5>] kernel_init+0x5f/0x1c7
  [<ffffffff816d29d4>] kernel_thread_helper+0x4/0x10
irq event stamp: 37
hardirqs last  enabled at (37): [<ffffffff816d0845>] _raw_spin_unlock_irqrestore+0x65/0x80
hardirqs last disabled at (36): [<ffffffff816d0617>] _raw_spin_lock_irqsave+0x17/0x60
softirqs last  enabled at (0): [<ffffffff8106c5a2>] copy_process.part.41+0x552/0x1480
softirqs last disabled at (0): [<          (null)>]           (null)

other info that might help us debug this:
 Possible unsafe locking scenario:

       CPU0
       ----
  lock(&p->vtime_lock);
  <Interrupt>
    lock(&p->vtime_lock);

 *** DEADLOCK ***

1 lock held by cryptomgr_test/84:
 #0:  (&sighand->siglock){+.+...}, at: [<ffffffff810ccc15>] acct_collect+0xb5/0x1d0

stack backtrace:
Pid: 84, comm: cryptomgr_test Not tainted 3.4.34-ovp1-rt40-WR5.0.1.0_preempt-rt+ #42
Call Trace:
 [<ffffffff816c5b9e>] print_usage_bug.part.36+0x26b/0x27a
 [<ffffffff81047c1a>] ? save_stack_trace+0x2a/0x50
 [<ffffffff810b7f30>] ? print_shortest_lock_dependencies+0x1c0/0x1c0
 [<ffffffff810b8d15>] mark_lock+0x285/0x610
 [<ffffffff810bae1f>] __lock_acquire+0x69f/0x1d60
 [<ffffffff810bab4d>] ? __lock_acquire+0x3cd/0x1d60
 [<ffffffff8109bc51>] ? get_parent_ip+0x11/0x50
 [<ffffffff810bca3f>] lock_acquire+0x9f/0xd0
 [<ffffffff810a04b1>] ? fetch_task_cputime+0x51/0xf0
 [<ffffffff816cfa10>] ? rt_spin_lock_slowlock+0x300/0x3a0
 [<ffffffff816d0526>] _raw_spin_lock+0x36/0x50
 [<ffffffff810a04b1>] ? fetch_task_cputime+0x51/0xf0
 [<ffffffff810a04b1>] fetch_task_cputime+0x51/0xf0
 [<ffffffff810a0ec0>] task_cputime+0x30/0x60
 [<ffffffff816cff2a>] ? rt_spin_lock+0x4a/0x60
 [<ffffffff810ccc9d>] acct_collect+0x13d/0x1d0
 [<ffffffff81073403>] do_exit+0x673/0x9a0
 [<ffffffff8109bedc>] ? migrate_enable+0x6c/0x140
 [<ffffffff8112c0e9>] ? unlock_slab_and_free_delayed.isra.44+0x99/0xf0
 [<ffffffff81321280>] ? cryptomgr_probe+0xf0/0xf0
 [<ffffffff810c74e9>] __module_put_and_exit+0x19/0x20
 [<ffffffff81321280>] ? cryptomgr_probe+0xf0/0xf0
 [<ffffffff813212a4>] cryptomgr_test+0x24/0x30
 [<ffffffff8109061f>] kthread+0xdf/0xf0
 [<ffffffff816d0896>] ? _raw_spin_unlock_irq+0x36/0x60
 [<ffffffff8109a2b8>] ? finish_task_switch+0x88/0x130
 [<ffffffff8109a27b>] ? finish_task_switch+0x4b/0x130
 [<ffffffff816d29d4>] kernel_thread_helper+0x4/0x10
 [<ffffffff8109a2b8>] ? finish_task_switch+0x88/0x130
 [<ffffffff816d0c1d>] ? retint_restore_args+0xe/0xe
 [<ffffffff81090540>] ? __init_kthread_worker+0xa0/0xa0
 [<ffffffff816d29d0>] ? gs_change+0xb/0xb

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/kernel/sched/cputime.c b/kernel/sched/cputime.c
index 3a23ce0..2ec5d0c 100644
--- a/kernel/sched/cputime.c
+++ b/kernel/sched/cputime.c
@@ -780,15 +780,16 @@ void vtime_init_idle(struct task_struct *t)
 cputime_t task_gtime(struct task_struct *t)
 {
 	cputime_t gtime;
+	unsigned long flags;
 
 	{
-		raw_spin_lock(&t->vtime_lock);
+		raw_spin_lock_irqsave(&t->vtime_lock, flags);
 
 		gtime = t->gtime;
 		if (t->flags & PF_VCPU)
 			gtime += vtime_delta(t);
 
-		raw_spin_unlock(&t->vtime_lock);
+		raw_spin_unlock_irqrestore(&t->vtime_lock, flags);
 	}
 
 	return gtime;
@@ -808,10 +809,12 @@ fetch_task_cputime(struct task_struct *t,
 	unsigned long long delta;
 
 	{
+		unsigned long flags;
+
 		*udelta = 0;
 		*sdelta = 0;
 
-		raw_spin_lock(&t->vtime_lock);
+		raw_spin_lock_irqsave(&t->vtime_lock, flags);
 
 		if (u_dst)
 			*u_dst = *u_src;
@@ -836,7 +839,7 @@ fetch_task_cputime(struct task_struct *t,
 				*sdelta = delta;
 		}
 done:
-		raw_spin_unlock(&t->vtime_lock);
+		raw_spin_unlock_irqrestore(&t->vtime_lock, flags);
 	}
 }
 
-- 
1.8.3.1

