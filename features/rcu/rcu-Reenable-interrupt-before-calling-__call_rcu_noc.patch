From 33dd8b8ea99829254e5595f384d4b755942bba4e Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Fri, 1 Mar 2013 14:26:15 -0800
Subject: [PATCH] rcu: Reenable interrupt before calling __call_rcu_nocb

__call_rcu_nocb calls wake_up to wake up RCU kthreads, wake_up can't
be called in IRQ disabled context, otherwise the kernel suffers from
below BUG calltrace:

BUG: sleeping function called from invalid context at linux/kernel/rtmutex.c:658
in_atomic(): 0, irqs_disabled(): 1, pid: 83, name: irq/41-eth0
Pid: 83, comm: irq/41-eth0 Not tainted 3.4.28-rt40-WR5.0.1.0_preempt-rt #1
Call Trace:
 [<ffffffff8206ed5f>] __might_sleep+0xdf/0x110
 [<ffffffff826f8734>] rt_spin_lock+0x24/0x50
 [<ffffffff820721e6>] __wake_up+0x36/0x70
 [<ffffffff820c4b28>] __call_rcu_nocb_enqueue+0xb8/0xd0
 [<ffffffff820c5684>] __call_rcu+0x144/0x2a0
 [<ffffffff826fcb00>] ? sub_preempt_count+0x70/0xe0
 [<ffffffff820c582d>] call_rcu+0x1d/0x20
 [<ffffffff82158328>] put_object+0x38/0x60
 [<ffffffff8215851d>] delete_object_full+0x2d/0x40
 [<ffffffff826d6496>] kmemleak_free+0x26/0x50
 [<ffffffff8214cec8>] kfree+0x1a8/0x320
 [<ffffffff825da513>] ? __netif_receive_skb+0x5a3/0x6a0
 [<ffffffff825cde78>] skb_release_data+0xf8/0x100
 [<ffffffff825cde9e>] __kfree_skb+0x1e/0xa0
 [<ffffffff825ce04a>] kfree_skb+0x4a/0xf0
 [<ffffffff825da513>] __netif_receive_skb+0x5a3/0x6a0
 [<ffffffff825da81a>] netif_receive_skb+0x4a/0x140
 [<ffffffff825db08e>] ? dev_gro_receive+0x26e/0x2e0
 [<ffffffff825db830>] napi_skb_finish+0x50/0x70
 [<ffffffff825db945>] napi_gro_receive+0xf5/0x140
 [<ffffffff824e3b0b>] e1000_receive_skb+0x5b/0x70
 [<ffffffff824e3d5b>] e1000_clean_rx_irq+0x23b/0x3d0
 [<ffffffff824e69b2>] e1000_clean+0x72/0x2b0
 [<ffffffff825dabf5>] net_rx_action+0x155/0x380
 [<ffffffff826fcb39>] ? sub_preempt_count+0xa9/0xe0
 [<ffffffff8204254f>] __do_softirq_common+0xdf/0x2d0
 [<ffffffff820bff50>] ? irq_thread_fn+0x50/0x50
 [<ffffffff82043710>] __do_softirq+0x10/0x20
 [<ffffffff8204386d>] local_bh_enable+0x14d/0x170
 [<ffffffff820bff96>] irq_forced_thread_fn+0x46/0x80
 [<ffffffff820bfca7>] irq_thread+0x127/0x1c0
 [<ffffffff820bfe30>] ? irq_finalize_oneshot.part.32+0xf0/0xf0
 [<ffffffff820bfb80>] ? wake_threads_waitq+0x50/0x50
 [<ffffffff82060bab>] kthread+0xdb/0xe0
 [<ffffffff82701b54>] kernel_thread_helper+0x4/0x10
 [<ffffffff8206dc1b>] ? finish_task_switch+0x5b/0xd0
 [<ffffffff826f8afc>] ? _raw_spin_unlock_irq+0x1c/0x40
 [<ffffffff826f8f4a>] ? retint_restore_args+0xe/0xe
 [<ffffffff82060ad0>] ? __init_kthread_worker+0x60/0x60
 [<ffffffff82701b50>] ? gs_change+0xb/0xb

So, reenable interrupt before calling __call_rcu_nocb.

Signed-off-by: Yang Shi <yang.shi@windriver.com>

diff --git a/kernel/rcutree.c b/kernel/rcutree.c
index 6cc4528..49dcd63 100644
--- a/kernel/rcutree.c
+++ b/kernel/rcutree.c
@@ -2165,10 +2165,10 @@ __call_rcu(struct rcu_head *head, void (*func)(struct rcu_head *rcu),
 
 		if (cpu != -1)
 			rdp = per_cpu_ptr(rsp->rda, cpu);
-		offline = !__call_rcu_nocb(rdp, head, lazy);
-		WARN_ON_ONCE(offline);
 		/* _call_rcu() is illegal on offline CPU; leak the callback. */
 		local_irq_restore(flags);
+		offline = !__call_rcu_nocb(rdp, head, lazy);
+		WARN_ON_ONCE(offline);
 		return;
 	}
 	ACCESS_ONCE(rdp->qlen)++;
-- 
1.7.5.4

