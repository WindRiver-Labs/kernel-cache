From 4b4bc0b094912962bd92721477093ce0539839f6 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Mon, 17 Dec 2012 19:27:17 -0500
Subject: [PATCH] rcu: use interruptible wait in nocb thread to avoid CPU load

Currently the rcu no callback thread uses wait_event() in
the non-polled mode while waiting for callback work.  But
if none are pending, then this thread will be shown in D
state and contribute to the reported CPU load.

Switch it to an interruptible wait so that we don't get a
reported cpu load of 2 or 3 times the number of isolated
cores (one load point for each thread flavour).

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: Yang Shi <yang.shi@windriver.com>

diff --git a/kernel/rcutree_plugin.h b/kernel/rcutree_plugin.h
index 46c5e8e..d288fc0 100644
--- a/kernel/rcutree_plugin.h
+++ b/kernel/rcutree_plugin.h
@@ -2375,7 +2375,7 @@ static int rcu_nocb_kthread(void *arg)
 	for (;;) {
 		/* If not polling, wait for next batch of callbacks. */
 		if (!rcu_nocb_poll)
-			wait_event(rdp->nocb_wq, rdp->nocb_head);
+			wait_event_interruptible(rdp->nocb_wq, rdp->nocb_head);
 		list = ACCESS_ONCE(rdp->nocb_head);
 		if (!list) {
 			schedule_timeout_interruptible(1);
-- 
1.7.5.4

