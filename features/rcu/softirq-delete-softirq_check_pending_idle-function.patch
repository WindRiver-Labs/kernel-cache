From 98a7dcd857872559cc32c82b5a1becc9e68e5c95 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Tue, 21 May 2013 17:19:54 -0400
Subject: [PATCH] softirq: delete softirq_check_pending_idle function

This is now orphaned code, given that we've taken on a
3.8.x style commit earlier.

Delete the code so that we can clean up the one remaining
NO_HZ pending message to actually print the softirq and not\
just a meaningless number.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index e9828c3..9be01fb 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -467,8 +467,6 @@ extern void __raise_softirq_irqoff(unsigned int nr);
 extern void raise_softirq_irqoff(unsigned int nr);
 extern void raise_softirq(unsigned int nr);
 
-extern void softirq_check_pending_idle(void);
-
 /* This is the worklist that queues up per-cpu softirq work.
  *
  * send_remote_sendirq() adds work to these lists, and
diff --git a/kernel/softirq.c b/kernel/softirq.c
index a573c7b..c4c7ecb 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -109,67 +109,6 @@ static inline void softirq_clr_runner(unsigned int sirq)
 
 	sr->runner[sirq] = NULL;
 }
-
-/*
- * On preempt-rt a softirq running context might be blocked on a
- * lock. There might be no other runnable task on this CPU because the
- * lock owner runs on some other CPU. So we have to go into idle with
- * the pending bit set. Therefor we need to check this otherwise we
- * warn about false positives which confuses users and defeats the
- * whole purpose of this test.
- *
- * This code is called with interrupts disabled.
- */
-void softirq_check_pending_idle(void)
-{
-	static int rate_limit;
-	struct softirq_runner *sr = &__get_cpu_var(softirq_runners);
-	u32 warnpending = local_softirq_pending();
-	int i;
-
-	if (rate_limit >= 10)
-		return;
-
-	for (i = 0; i < NR_SOFTIRQS; i++) {
-		struct task_struct *tsk = sr->runner[i];
-
-		/*
-		 * The wakeup code in rtmutex.c wakes up the task
-		 * _before_ it sets pi_blocked_on to NULL under
-		 * tsk->pi_lock. So we need to check for both: state
-		 * and pi_blocked_on.
-		 */
-		if (tsk) {
-			raw_spin_lock(&tsk->pi_lock);
-			if (tsk->pi_blocked_on || tsk->state == TASK_RUNNING) {
-				/* Clear all bits pending in that task */
-				warnpending &= ~(tsk->softirqs_raised);
-				warnpending &= ~(1 << i);
-			}
-			raw_spin_unlock(&tsk->pi_lock);
-		}
-	}
-
-	if (warnpending) {
-		printk(KERN_ERR "NOHZ: local_softirq_pending %02x\n",
-		       warnpending);
-		rate_limit++;
-	}
-}
-# else
-/*
- * On !PREEMPT_RT we just printk rate limited:
- */
-void softirq_check_pending_idle(void)
-{
-	static int rate_limit;
-
-	if (rate_limit < 10) {
-		printk(KERN_ERR "NOHZ: local_softirq_pending %02x\n",
-		       local_softirq_pending());
-		rate_limit++;
-	}
-}
 # endif
 
 #else /* !NO_HZ */
-- 
1.8.3.1

