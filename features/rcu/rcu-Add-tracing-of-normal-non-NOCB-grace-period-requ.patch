From 79c15dc338abd7a7ef1fff3b3cabc3020fc4470d Mon Sep 17 00:00:00 2001
From: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
Date: Fri, 9 Aug 2013 16:02:09 -0700
Subject: [PATCH] rcu: Add tracing of normal (non-NOCB) grace-period requests

commit bb311eccbdab974639263060b8452bf304af0b0c upstream.

This commit adds tracing to the normal grace-period request points.
These are rcu_gp_cleanup(), which checks for the need for another
grace period at the end of the previous grace period, and
rcu_start_gp_advanced(), which restarts RCU's state machine after
an idle period.  These trace events are intended to help track down
bugs where RCU remains idle despite there being work for it to do.

Reported-by: Clark Williams <williams@redhat.com>
Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/trace/events/rcu.h b/include/trace/events/rcu.h
index 60077e12093c..98466c618ebc 100644
--- a/include/trace/events/rcu.h
+++ b/include/trace/events/rcu.h
@@ -45,6 +45,7 @@ TRACE_EVENT(rcu_utilization,
  *
  *	"AccReadyCB": CPU acclerates new callbacks to RCU_NEXT_READY_TAIL.
  *	"AccWaitCB": CPU accelerates new callbacks to RCU_WAIT_TAIL.
+ *	"newreq": Request a new grace period.
  *	"start": Start a grace period.
  *	"cpustart": CPU first notices a grace-period start.
  *	"cpuqs": CPU passes through a quiescent state.
diff --git a/kernel/rcutree.c b/kernel/rcutree.c
index 1f7258a1b325..94dba3c1a50c 100644
--- a/kernel/rcutree.c
+++ b/kernel/rcutree.c
@@ -1506,8 +1506,12 @@ static void rcu_gp_cleanup(struct rcu_state *rsp)
 	rsp->fqs_state = RCU_GP_IDLE;
 	rdp = this_cpu_ptr(rsp->rda);
 	rcu_advance_cbs(rsp, rnp, rdp);  /* Reduce false positives below. */
-	if (cpu_needs_another_gp(rsp, rdp))
+	if (cpu_needs_another_gp(rsp, rdp)) {
 		rsp->gp_flags = RCU_GP_FLAG_INIT;
+		trace_rcu_grace_period(rsp->name,
+				       ACCESS_ONCE(rsp->gpnum),
+				       TPS("newreq"));
+	}
 	raw_spin_unlock_irq(&rnp->lock);
 }
 
@@ -1631,6 +1635,8 @@ rcu_start_gp_advanced(struct rcu_state *rsp, struct rcu_node *rnp,
 		return;
 	}
 	rsp->gp_flags = RCU_GP_FLAG_INIT;
+	trace_rcu_grace_period(rsp->name, ACCESS_ONCE(rsp->gpnum),
+			       TPS("newreq"));
 
 	/*
 	 * We can't do wakeups while holding the rnp->lock, as that
-- 
1.9.0

