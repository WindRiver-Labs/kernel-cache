From 05da1d798546096cf43c06ef5987d41b4ceb02d2 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Fri, 12 Jul 2013 14:38:03 -0400
Subject: [PATCH] hrtimer: align code to match upstream 3.4.x-RT

A merge as of 3.4.34-stable caused an interesting conflict
in hrtimer.c -- see https://lkml.org/lkml/2013/3/19/369

Here we align the local copy to be in keeping with the
externally published conflict resolution, and that which
is in v3.4.52-rt67.

The local resolution was largely equivalent, but avoided
the questionable approach of putting preprocessor directives
in the middle of an "if(...)" statement arguments.  Yes, that
does come from the upstream RT.

There was one possibly significant difference -- the upstream
RT explicitly assigned a -ETIME return value, while the local
resolution kept whatever return value came from the original
timer delete call.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/kernel/hrtimer.c b/kernel/hrtimer.c
index 4b3d1f6..2bf9d4f 100644
--- a/kernel/hrtimer.c
+++ b/kernel/hrtimer.c
@@ -1036,26 +1036,17 @@ int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
 	 */
 	if (leftmost && new_base->cpu_base == &__get_cpu_var(hrtimer_bases)
 		&& hrtimer_enqueue_reprogram(timer, new_base)) {
-		if (wakeup) {
+
+		if (wakeup
 #ifdef CONFIG_PREEMPT_RT_BASE
-			/*
-			 * Move softirq based timers away from the rbtree in
-			 * case it expired already. Otherwise we would have a
-			 * stale base->first entry until the softirq runs.
-			 */
-			if (!hrtimer_rt_defer(timer)) {
-				/*
-				 * In case we failed to reprogram the timer (mostly
-				 * because out current timer is already elapsed),
-				 * remove it again and report a failure. This avoids
-				 * stale base->first entries.
-				 */
-				debug_deactivate(timer);
-				__remove_hrtimer(timer, new_base,
-					timer->state & HRTIMER_STATE_CALLBACK, 0);
-				goto etime;
-			}
+		    /*
+		     * Move softirq based timers away from the rbtree in
+		     * case it expired already. Otherwise we would have a
+		     * stale base->first entry until the softirq runs.
+		     */
+		    && hrtimer_rt_defer(timer)
 #endif
+			) {
 			/*
 			 * We need to drop cpu_base->lock to avoid a
 			 * lock ordering issue vs. rq->lock.
@@ -1064,14 +1055,20 @@ int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
 			raise_softirq_irqoff(HRTIMER_SOFTIRQ);
 			local_irq_restore(flags);
 			return ret;
-		} else {
-			__raise_softirq_irqoff(HRTIMER_SOFTIRQ);
 		}
+
+		/*
+		 * In case we failed to reprogram the timer (mostly
+		 * because out current timer is already elapsed),
+		 * remove it again and report a failure. This avoids
+		 * stale base->first entries.
+		 */
+		debug_deactivate(timer);
+		__remove_hrtimer(timer, new_base,
+				 timer->state & HRTIMER_STATE_CALLBACK, 0);
+		ret = -ETIME;
 	}
 
-#ifdef CONFIG_PREEMPT_RT_BASE
-etime:
-#endif
 	unlock_hrtimer_base(timer, &flags);
 
 	return ret;
-- 
1.8.3.1

