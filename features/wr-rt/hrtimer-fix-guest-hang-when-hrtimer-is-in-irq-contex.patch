From f2e98632d7105f3b1b311ce4ffb1b4752a5b0ee5 Mon Sep 17 00:00:00 2001
From: Nam Ninh <nam.ninh@windriver.com>
Date: Tue, 5 Nov 2013 15:16:28 -0500
Subject: [PATCH] hrtimer: fix guest hang when hrtimer is in irq context

When the lapic hrtimer is in irq context, we have seen guests
hang during bootup. The problem is that __hrtimer_start_range_ns is
supposed to start/restart the timer on the current CPU after it
switches the timer base from the previous CPU to the new base on
the current CPU.   Originally preempt-rt had the following change
present "hrtimer-Don-t-call-the-timer-handler-from-hrtimer_st.patch"
but it only start/restart the timer in softirq mode and breaks irqsafe.

In addition to dropping the above patch from the preempt-rt series,
we fix several problems present in the main rt hrtimer patch
("hrtimer-fixup-hrtimer-callback-changes-for-preempt-r.patch") that
were masked by the dropped patch:

1) use new_base and not base after calling switch_hrtimer_base()
   since base is no longer valid.

2) if we are not doing the defer and running __run_hrtimer() now,
   then unlock and return once done; we don't need to run the
   softirq case when it was done in hard irq context.

3) the timer will be restarted from the previous time of the timer base
   base->get_time(). Since we just switched to the new base, we now use
   new_base->get_time() for the current time for the new timer to restart
   with.

Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/kernel/hrtimer.c b/kernel/hrtimer.c
index 285ecdc..9f4887f 100644
--- a/kernel/hrtimer.c
+++ b/kernel/hrtimer.c
@@ -1055,15 +1055,18 @@ again:
 			 * stale base->first entry until the softirq runs.
 			 */
 			if (!hrtimer_rt_defer(timer)) {
-				ktime_t now = ktime_get();
+				ktime_t now = new_base->get_time();
 
 				__run_hrtimer(timer, &now);
 				/*
 				 * __run_hrtimer might have requeued timer and
-				 * it could be base->first again.
+				 * it could be new_base->first again.
 				 */
-				if (&timer->node == base->active.next)
+				if (&timer->node == new_base->active.next)
 					goto again;
+
+				unlock_hrtimer_base(timer, &flags);
+				return ret;
 			}
 #else
 		if (hrtimer_enqueue_reprogram(timer, new_base)) {
@@ -1073,7 +1076,7 @@ again:
 				 * We need to drop cpu_base->lock to avoid a
 				 * lock ordering issue vs. rq->lock.
 				 */
-				raw_spin_unlock(&base->cpu_base->lock);
+				raw_spin_unlock(&new_base->cpu_base->lock);
 				raise_softirq_irqoff(HRTIMER_SOFTIRQ);
 				local_irq_restore(flags);
 				return ret;
-- 
1.8.4.1

