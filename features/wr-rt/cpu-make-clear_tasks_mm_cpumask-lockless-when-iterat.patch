From 9c182df26eced315edfb65792c9f1b77cc1f5b7a Mon Sep 17 00:00:00 2001
From: Yong Zhang <yong.zhang@windriver.com>
Date: Tue, 10 Mar 2015 15:00:52 +0800
Subject: [PATCH] cpu: make clear_tasks_mm_cpumask() lockless when iterating
 each thread

Because the caller of the function is running offline and
in atomic context, it's not possible to acquire task lock.

It's confirmed that getting rid of the lock is safe due to
the same reason as above. The reader of mm_cpumask() will
not mess up.

There are three kinds of callers of mm_cpumask():
1) switch_mm(); this will not mess up with
   clear_tasks_mm_cpumask() because the two will not run at
   the same time.
2) tlb flush; this will not be affected by
   clear_tasks_mm_cpumask() because clear_tasks_mm_cpumask()
   is called when cpu is offline and the mechanism behind
   tlb flush (which is on_each_cpu) will exclude the
   offlined cpu.
3) Other that check if the current cpu is in mm_cpumask(),
   this doesn't matter because this only happens on the current
   cpu but clear_tasks_mm_cpumask() is called after everything is
   done.

Signed-off-by: Yong Zhang <yong.zhang@windriver.com>
Signed-off-by: Hongbo Zhong <hongbo.zhong@windriver.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 kernel/cpu.c |   20 +++++++-------------
 1 files changed, 7 insertions(+), 13 deletions(-)

diff --git a/kernel/cpu.c b/kernel/cpu.c
index 285e18b..dce40d8 100644
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@ -496,6 +496,7 @@ EXPORT_SYMBOL(unregister_cpu_notifier);
 void clear_tasks_mm_cpumask(int cpu)
 {
 	struct task_struct *p;
+	struct task_struct *t;
 
 	/*
 	 * This function is called after the cpu is taken down and marked
@@ -506,19 +507,12 @@ void clear_tasks_mm_cpumask(int cpu)
 	 */
 	WARN_ON(cpu_online(cpu));
 	rcu_read_lock();
-	for_each_process(p) {
-		struct task_struct *t;
-
-		/*
-		 * Main thread might exit, but other threads may still have
-		 * a valid mm. Find one.
-		 */
-		t = find_lock_task_mm(p);
-		if (!t)
-			continue;
-		cpumask_clear_cpu(cpu, mm_cpumask(t->mm));
-		task_unlock(t);
-	}
+	do_each_thread(p, t) {
+		if (likely(t->mm)) {
+			cpumask_clear_cpu(cpu, mm_cpumask(t->mm));
+			break;
+		}
+	} while_each_thread(p, t);
 	rcu_read_unlock();
 }
 
-- 
1.7.5.4

