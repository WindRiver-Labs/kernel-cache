From 3e6c1faca8a48719d66df5583d5b67f0d285ccb8 Mon Sep 17 00:00:00 2001
From: Nam Ninh <nam.ninh@windriver.com>
Date: Thu, 8 May 2014 12:20:19 -0400
Subject: [PATCH] hrtimer: fix guest hang when lapic timer is in irq context

When the lapic hrtimer is in irq context, we have seen guests hang
during bootup. The problem is that __hrtimer_start_range_ns is
supposed to start/restart the timer on the current CPU after it
switches the timer base from the previous CPU to the new base on
the current CPU. However, currently hrtimer_enqueue_reprogram that
reprograms the clock event device returns -ETIME when the event is
in the past. The return of -ETIME triggers the timer to be removed
in __hrtimer_start_range_ns for the irq mode, which is supposed
to be restarted.

Signed-off-by: Nam Ninh <nam.ninh@windriver.com>
---

diff --git a/kernel/hrtimer.c b/kernel/hrtimer.c
index ea8e31e..f313367 100644
--- a/kernel/hrtimer.c
+++ b/kernel/hrtimer.c
@@ -654,12 +654,12 @@ static inline int hrtimer_enqueue_reprogram(struct hrtimer *timer,
 {
 	if (!(base->cpu_base->hres_active && hrtimer_reprogram(timer, base)))
 		return 0;
-	if (!wakeup)
-		return -ETIME;
 #ifdef CONFIG_PREEMPT_RT_BASE
 	if (!hrtimer_rt_defer(timer))
-		return -ETIME;
+		return 1;
 #endif
+	if (!wakeup)
+		return -ETIME;
 	return 1;
 }
 
@@ -1046,12 +1046,12 @@ int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
 {
 	struct hrtimer_clock_base *base, *new_base;
 	unsigned long flags;
-	int ret, leftmost;
+	int ret, leftmost;
 
 	base = lock_hrtimer_base(timer, &flags);
 
 	/* Remove an active timer from the queue: */
-	ret = remove_hrtimer(timer, base);
+	ret = remove_hrtimer(timer, base);
 
 	/* Switch the timer base, if necessary: */
 	new_base = switch_hrtimer_base(timer, base, mode & HRTIMER_MODE_PINNED);
@@ -1094,6 +1094,9 @@ int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
 	 * XXX send_remote_softirq() ?
 	 */
 	if (leftmost && new_base->cpu_base == &__get_cpu_var(hrtimer_bases)) {
+#ifdef CONFIG_PREEMPT_RT_BASE
+again:
+#endif
 		ret = hrtimer_enqueue_reprogram(timer, new_base, wakeup);
 		if (ret < 0) {
 			/*
@@ -1106,6 +1109,22 @@ int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
 			__remove_hrtimer(timer, new_base,
 				timer->state & HRTIMER_STATE_CALLBACK, 0);
 		} else if (ret > 0) {
+#ifdef CONFIG_PREEMPT_RT_BASE
+			if (!hrtimer_rt_defer(timer)) {
+				ktime_t now = new_base->get_time();
+
+				__run_hrtimer(timer, &now);
+				/*
+				 * __run_hrtimer might have requeued timer and
+				 * it could be new_base->first again.
+				 */
+				if (&timer->node == new_base->active.next)
+					goto again;
+
+				unlock_hrtimer_base(timer, &flags);
+				return 0;
+			}
+#endif
 			/*
 			 * We need to drop cpu_base->lock to avoid a
 			 * lock ordering issue vs. rq->lock.
-- 
1.8.3.2
