From 4d7f6ad849e8607056c268ea73520e2866cb15a9 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Tue, 22 Apr 2014 14:57:35 -0400
Subject: [PATCH] rt: don't have the throttling message be implicitly one-shot.

If a rogue RT process eats more of its allocated time than it should,
the throttling message is emitted.  However it is currently a one-shot
message, and yet there is nothing indicating that it is one shot.

Meaning that Joe User could see the message, and then adjust his
system configuration, and falsely conclude that he'd "fixed" the
issue since he no longer sees the message.  When in reality, a
reboot is currently required in order to re-enable it.

Rather than have it as one-shot, we ratelimit it to once per 10s.
And we add the ability for the end user to disable and re-enable
the messages without having to go through a reboot.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/sched/sysctl.h b/include/linux/sched/sysctl.h
index bf8086b2506e..cdeb1e634022 100644
--- a/include/linux/sched/sysctl.h
+++ b/include/linux/sched/sysctl.h
@@ -83,6 +83,8 @@ static inline unsigned int get_sysctl_timer_migration(void)
 extern unsigned int sysctl_sched_rt_period;
 extern int sysctl_sched_rt_runtime;
 
+extern int sched_rt_throttle_warn;
+
 #ifdef CONFIG_CFS_BANDWIDTH
 extern unsigned int sysctl_sched_cfs_bandwidth_slice;
 #endif
diff --git a/kernel/sched/rt.c b/kernel/sched/rt.c
index 3a829804cf2e..3708e20fd42a 100644
--- a/kernel/sched/rt.c
+++ b/kernel/sched/rt.c
@@ -8,6 +8,7 @@
 #include <linux/slab.h>
 
 int sched_rr_timeslice = RR_TIMESLICE;
+int sched_rt_throttle_warn = 1;
 
 static int do_sched_rt_period_timer(struct rt_bandwidth *rt_b, int overrun);
 
@@ -886,13 +887,17 @@ static int sched_rt_runtime_exceeded(struct rt_rq *rt_rq)
 		 * but accrue some time due to boosting.
 		 */
 		if (likely(rt_b->rt_runtime)) {
-			static bool once = false;
 
 			rt_rq->rt_throttled = 1;
 
-			if (!once) {
-				once = true;
-				printk_deferred("sched: RT throttling activated\n");
+			if (sched_rt_throttle_warn) {
+				static unsigned long last = INITIAL_JIFFIES;
+
+				if (time_after(jiffies, last + 10*HZ)) {
+					printk_deferred("sched: RT throttling activated\n");
+					last = jiffies;
+				}
+
 			}
 		} else {
 			/*
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 9469f4c61a30..3013b4121d80 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -414,6 +414,15 @@ static struct ctl_table kern_table[] = {
 		.proc_handler	= sched_rt_handler,
 	},
 	{
+		.procname	= "sched_rt_throttle_warn",
+		.data		= &sched_rt_throttle_warn,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &zero,
+		.extra2		= &one,
+	},
+	{
 		.procname	= "sched_rr_timeslice_ms",
 		.data		= &sched_rr_timeslice,
 		.maxlen		= sizeof(int),
-- 
2.0.1

