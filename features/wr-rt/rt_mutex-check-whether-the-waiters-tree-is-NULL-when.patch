From c050c412f249b2425aff8e1a8a86e4d894bce5f6 Mon Sep 17 00:00:00 2001
From: Jianchuan Wang <jianchuan.wang@windriver.com>
Date: Fri, 24 Oct 2014 13:56:42 +0800
Subject: [PATCH] rt_mutex: check whether the waiters-tree is NULL when
 removing the waiter of lock

rt_mutex will remove a lock waiter in rt_mutex_slowlock after calling read_lock twice,
if there were not waiters in this lock, It will cause a kernel panic:

BUG: unable to handle kernel NULL pointer dereference at 0000000000000038
IP: [<ffffffff810ad1f6>] remove_waiter+0x16/0x160
PGD 0
Oops: 0000 [#1] PREEMPT SMP
Modules linked in:
CPU: 0 PID: 0 Comm: swapper/0 Tainted: G        W    3.14.19-rt9-WR7.0.0.0_preempt-rt #2
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.7.5-0-ge51488c-20140602_164612-nilsson.home.kraxel.org 04/01/2014
task: ffffffff81e19580 ti: ffffffff81e00000 task.ti: ffffffff81e00000
RIP: 0010:[<ffffffff810ad1f6>]  [<ffffffff810ad1f6>] remove_waiter+0x16/0x160
RSP: 0000:ffffffff81e03e20  EFLAGS: 00000286
RAX: 00000000ffffffdd RBX: ffffffff81e8ff00 RCX: ffffffff81e19580
RDX: 0000000000000002 RSI: ffffffff81e03e80 RDI: ffffffff81e8ff00
RBP: ffffffff81e03e48 R08: ffffffff81e19580 R09: ffffffff81e8ff48
R10: ffffffff81e19581 R11: ffffffff81e195a8 R12: ffffffff81e03e80
R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
FS:  0000000000000000(0000) GS:ffff880017c00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
CR2: 0000000000000038 CR3: 0000000001e14000 CR4: 00000000000006b0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 0000000000000000 DR7: 0000000000000000
Stack:
 ffffffff81e8ff00 ffffffff81e03e80 0000000000000000 0000000000000000
 0000000000000002 ffffffff81e03ef0 ffffffff81856067 ffffffdd00000000
 000000000000000e 0000000000000000 0000000000000002 0000000000000282
Call Trace:
 [<ffffffff81856067>] rt_mutex_slowlock+0x187/0x220
 [<ffffffff810adce0>] ? rt_down_read+0x10/0x20
 [<ffffffff813b42b0>] ? AA_rsem+0x20/0x20
 [<ffffffff81856154>] rt_mutex_lock+0x54/0x60
 [<ffffffff810adcc7>] __rt_down_read+0x37/0x40
 [<ffffffff810adce0>] ? rt_down_read+0x10/0x20
 [<ffffffff810adce0>] rt_down_read+0x10/0x20
 [<ffffffff813b42cc>] rsem_AA1+0x1c/0x20
 [<ffffffff81851350>] dotest+0x3d/0x820
 [<ffffffff813b9638>] locking_selftest+0x6f8/0x10a0
 [<ffffffff81f17c36>] start_kernel+0x2bc/0x401
 [<ffffffff81f17495>] x86_64_start_reservations+0x2a/0x2c
 [<ffffffff81f1758e>] x86_64_start_kernel+0xf7/0xfa
Code: fd ff eb b3 90 b8 01 00 00 00 eb ad 66 0f 1f 84 00 00 00 00 00 e8 db 30
7b 00 55 48 89 e5 41 57 41 56 41 55 41 54 53 4c 8b 7f 40 <49> 3b 7f 38 0f 85
20 01 00 00 4c 8b 67 48 48 89 fb 49 89 f5 65
RIP  [<ffffffff810ad1f6>] remove_waiter+0x16/0x160
 RSP <ffffffff81e03e20>
CR2: 0000000000000038
---[ end trace 0000000000000003 ]---
Kernel panic - not syncing: Attempted to kill the idle task!

To fix this error, we can check if there are any waiters, and set the
return code to avoid removing the waiter of the lock.

Signed-off-by: Jianchuan Wang <jianchuan.wang@windriver.com>
---
 kernel/locking/rtmutex.c |    9 ++++++++-
 1 files changed, 8 insertions(+), 1 deletions(-)

diff --git a/kernel/locking/rtmutex.c b/kernel/locking/rtmutex.c
index 6c40660..7ed07e9 100644
--- a/kernel/locking/rtmutex.c
+++ b/kernel/locking/rtmutex.c
@@ -1433,8 +1433,15 @@ rt_mutex_slowlock(struct rt_mutex *lock, int state,
 
 	ret = task_blocks_on_rt_mutex(lock, &waiter, current, detect_deadlock);
 
-	if (likely(!ret))
+	if (likely(!ret)) {
 		ret = __rt_mutex_slowlock(lock, state, timeout, &waiter, ww_ctx);
+	} else if (!rt_mutex_has_waiters(lock)) {
+		/*
+		 * Reset the return value. We might have
+		 * returned with -EDEADLK if there are no waiters.
+		 */
+		ret = 0;
+	}
 
 	set_current_state(TASK_RUNNING);
 
-- 
1.7.5.4

