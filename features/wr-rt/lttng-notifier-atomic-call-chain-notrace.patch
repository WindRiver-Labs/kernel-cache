From 5503f6156dc94ed9d79ef20d2373b87daa5665b0 Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Fri, 11 Jan 2013 14:10:07 +0800
Subject: [PATCH] lttng: notifier-atomic-call-chain-notrace

We have the below patch /commit in current lttng patch set:

[
commit 68171d2d8f1180e512c14c5501505c7b7a3e86d5
Author: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date:   Wed May 18 18:42:24 2011 -0400

    notifier-atomic-call-chain-notrace

    notifier atomic call chain notrace

    Being able to use the atomic notifier from cpu idle entry to ensure the tracer
    flush the last events in the current subbuffer requires the rcu read-side to be
    marked "notrace".

    Also apply to the the die notifier.

    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Reviewed-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Reviewed-by: Masami Hiramatsu <mhiramat@redhat.com>
    CC: Jason Baron <jbaron@redhat.com>
    CC: mingo@elte.hu
]

The above change / commit changed calls to
rcu_read_lock/rcu_read_unlock in __atomic_notifier_call_chain. The
change doesn't suitable for preempt RT kernel. It will cause kernel
call trace on preempt RT kernel like:

    .../kernel/rtmutex.c:646
    in_atomic(): 1, irqs_disabled(): 0, pid: 800, name: ip
    Pid: 800, comm: ip Not tainted 3.4.16-rt17-preempt-rt #1
    Call Trace:
     [<ffffffff8105f9dd>] __might_sleep+0xcd/0xf0
     [<ffffffff8170f765>] rt_spin_lock+0x25/0x50
     [<ffffffffa0018ebc>] cfg80211_mlme_unregister_socket+0x4c/0x120
     [cfg80211]
     [<ffffffffa000e43c>] nl80211_netlink_notify+0x8c/0xe0 [cfg80211]
     [<ffffffff8171386a>] notifier_call_chain+0x5a/0x80
     [<ffffffff817138bf>] __atomic_notifier_call_chain+0x2f/0x60
     [<ffffffff81713906>] atomic_notifier_call_chain+0x16/0x20
     [<ffffffff8162259a>] netlink_release+0x25a/0x290
     [<ffffffff815e63b9>] sock_release+0x29/0x90
     [<ffffffff815e6787>] sock_close+0x17/0x30
     [<ffffffff811277b8>] fput+0xf8/0x270
     [<ffffffff811238d9>] filp_close+0x69/0x90
     [<ffffffff81030a4a>] put_files_struct+0xba/0x130
     [<ffffffff81031ed0>] exit_files+0x60/0x80
     [<ffffffff810323e5>] do_exit+0x165/0x920
     [<ffffffff81125963>] ? vfs_write+0x133/0x170
     [<ffffffff81032f1e>] do_group_exit+0x4e/0xc0
     [<ffffffff81032fa7>] sys_exit_group+0x17/0x20
     [<ffffffff817174d2>] system_call_fastpath+0x16/0x1b

So the lttng patch(notifier-atomic-call-chain-notrace) need be
tweaked for preempt RT kernel, to accomplish the 'no-trace' goal
for atomic-call-chain, as well as follow high level design of
rcu_read_lock / rcu_read_unlock in preempt RT kernel.

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 include/linux/rcupdate.h |   10 ++++++++++
 kernel/notifier.c        |    4 ++--
 2 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/include/linux/rcupdate.h b/include/linux/rcupdate.h
index 34361fa..db53895 100644
--- a/include/linux/rcupdate.h
+++ b/include/linux/rcupdate.h
@@ -815,6 +815,16 @@ static inline void rcu_read_lock_sched(void)
 			   "rcu_read_lock_sched() used illegally while idle");
 }
 
+static inline notrace void rcu_read_lock_notrace(void)
+{
+	rcu_read_lock();
+}
+
+static inline notrace void rcu_read_unlock_notrace(void)
+{
+	rcu_read_unlock();
+}
+
 /* Used by lockdep and tracing: cannot be traced, cannot call lockdep. */
 static inline notrace void rcu_read_lock_sched_notrace(void)
 {
diff --git a/kernel/notifier.c b/kernel/notifier.c
index 6559fbb..d7ebe3b 100644
--- a/kernel/notifier.c
+++ b/kernel/notifier.c
@@ -179,9 +179,9 @@ int __kprobes __atomic_notifier_call_chain(struct atomic_notifier_head *nh,
 {
 	int ret;
 
-	rcu_read_lock_sched_notrace();
+	rcu_read_lock_notrace();
 	ret = notifier_call_chain(&nh->head, val, v, nr_to_call, nr_calls);
-	rcu_read_unlock_sched_notrace();
+	rcu_read_unlock_notrace();
 	return ret;
 }
 EXPORT_SYMBOL_GPL(__atomic_notifier_call_chain);
-- 
1.7.9.7

