From 340ab9a77281d2f603fb593e7a951c34654e8500 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Wed, 4 Feb 2015 12:29:05 -0500
Subject: [PATCH] drivers/scsi: convert isci contoller lock to raw

The following was observed on Canoe Pass platform:

[ 13.041656] BUG: sleeping function called from invalid context at /kernel/locking/rtmutex.c:905
[ 13.041658] in_atomic(): 0, irqs_disabled(): 1, pid: 1234, name: S39alsa-state
[ 13.041662] CPU: 38 PID: 1234 Comm: S39alsa-state Not tainted 3.14.28-rt22-WR7.0.0.0_ovp #2
[ 13.041664] Hardware name: Intel Corporation S2600CP/S2600CP, BIOS SE5C600.86B.02.01.0002.082220131453 08/22/2013
[ 13.041669] ffff880fab500000 ffff880fa4eff8c8 ffffffff81a2d273 0000000000000000
[ 13.041671] ffff880fa4eff8e0 ffffffff8107f023 ffff880faac23dc0 ffff880fa4eff8f8
[ 13.041673] ffffffff81a33cc0 ffff880faa9403c0 ffff880fa4eff948 ffffffff815de891
[ 13.041674] Call Trace:
[ 13.041683] [<ffffffff81a2d273>] dump_stack+0x4e/0x7a
[ 13.041692] [<ffffffff8107f023>] __might_sleep+0xe3/0x160
[ 13.041696] [<ffffffff81a33cc0>] rt_spin_lock+0x20/0x50
[ 13.041702] [<ffffffff815de891>] isci_task_execute_task+0x171/0x2f0
[ 13.041707] [<ffffffff815cfecb>] sas_ata_qc_issue+0x25b/0x2a0
[ 13.041712] [<ffffffff81606363>] ata_qc_issue+0x1f3/0x370
[...]

and gdb shows:

(gdb) list * isci_task_execute_task+0x171
0xffffffff815ddfb1 is in isci_task_execute_task (drivers/scsi/isci/task.c:138).
133             dev_dbg(&ihost->pdev->dev, "%s: num=%d\n", __func__, num);
134
135             for_each_sas_task(num, task) {
136                     enum sci_status status = SCI_FAILURE;
137
138                     spin_lock_irqsave(&ihost->scic_lock, flags);    <-----
139                     idev = isci_lookup_device(task->dev);
140                     io_ready = isci_device_io_ready(idev, task);
141                     tag = isci_alloc_tag(ihost);
142                     spin_unlock_irqrestore(&ihost->scic_lock, flags);
(gdb)

Since interrupts are clearly off, and the lock appears to be primarily
used around short lived chipset register frobbing, we convert the lock
to raw lock

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 609dafd661d1..bf5439f8603f 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -207,12 +207,12 @@ static bool sci_controller_isr(struct isci_host *ihost)
 	 * another interrupt pending the clearing of the interrupt
 	 * source we get the next interrupt message.
 	 */
-	spin_lock(&ihost->scic_lock);
+	raw_spin_lock(&ihost->scic_lock);
 	if (test_bit(IHOST_IRQ_ENABLED, &ihost->flags)) {
 		writel(0xFF000000, &ihost->smu_registers->interrupt_mask);
 		writel(0, &ihost->smu_registers->interrupt_mask);
 	}
-	spin_unlock(&ihost->scic_lock);
+	raw_spin_unlock(&ihost->scic_lock);
 
 	return false;
 }
@@ -615,9 +615,9 @@ irqreturn_t isci_intx_isr(int vec, void *data)
 		tasklet_schedule(&ihost->completion_tasklet);
 		ret = IRQ_HANDLED;
 	} else if (sci_controller_error_isr(ihost)) {
-		spin_lock(&ihost->scic_lock);
+		raw_spin_lock(&ihost->scic_lock);
 		sci_controller_error_handler(ihost);
-		spin_unlock(&ihost->scic_lock);
+		raw_spin_unlock(&ihost->scic_lock);
 		ret = IRQ_HANDLED;
 	}
 
@@ -965,7 +965,7 @@ static void phy_startup_timeout(unsigned long data)
 	unsigned long flags;
 	enum sci_status status;
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	if (tmr->cancel)
 		goto done;
@@ -977,7 +977,7 @@ static void phy_startup_timeout(unsigned long data)
 	} while (status != SCI_SUCCESS);
 
 done:
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
 static u16 isci_tci_active(struct isci_host *ihost)
@@ -1051,10 +1051,10 @@ void isci_host_start(struct Scsi_Host *shost)
 
 	set_bit(IHOST_START_PENDING, &ihost->flags);
 
-	spin_lock_irq(&ihost->scic_lock);
+	raw_spin_lock_irq(&ihost->scic_lock);
 	sci_controller_start(ihost, tmo);
 	sci_controller_enable_interrupts(ihost);
-	spin_unlock_irq(&ihost->scic_lock);
+	raw_spin_unlock_irq(&ihost->scic_lock);
 }
 
 static void isci_host_stop_complete(struct isci_host *ihost)
@@ -1118,9 +1118,9 @@ void isci_host_completion_routine(unsigned long data)
 	struct isci_host *ihost = (struct isci_host *)data;
 	u16 active;
 
-	spin_lock_irq(&ihost->scic_lock);
+	raw_spin_lock_irq(&ihost->scic_lock);
 	sci_controller_completion_handler(ihost);
-	spin_unlock_irq(&ihost->scic_lock);
+	raw_spin_unlock_irq(&ihost->scic_lock);
 
 	/*
 	 * we subtract SCI_MAX_PORTS to account for the number of dummy TCs
@@ -1248,9 +1248,9 @@ void isci_host_deinit(struct isci_host *ihost)
 
 	set_bit(IHOST_STOP_PENDING, &ihost->flags);
 
-	spin_lock_irq(&ihost->scic_lock);
+	raw_spin_lock_irq(&ihost->scic_lock);
 	sci_controller_stop(ihost, SCIC_CONTROLLER_STOP_TIMEOUT);
-	spin_unlock_irq(&ihost->scic_lock);
+	raw_spin_unlock_irq(&ihost->scic_lock);
 
 	wait_for_stop(ihost);
 
@@ -1266,9 +1266,9 @@ void isci_host_deinit(struct isci_host *ihost)
 	 */
 	writel(0, &ihost->scu_registers->peg0.sgpio.interface_control);
 
-	spin_lock_irq(&ihost->scic_lock);
+	raw_spin_lock_irq(&ihost->scic_lock);
 	sci_controller_reset(ihost);
-	spin_unlock_irq(&ihost->scic_lock);
+	raw_spin_unlock_irq(&ihost->scic_lock);
 
 	/* Cancel any/all outstanding port timers */
 	for (i = 0; i < ihost->logical_port_entries; i++) {
@@ -1599,7 +1599,7 @@ static void controller_timeout(unsigned long data)
 	struct sci_base_state_machine *sm = &ihost->sm;
 	unsigned long flags;
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	if (tmr->cancel)
 		goto done;
@@ -1616,7 +1616,7 @@ static void controller_timeout(unsigned long data)
 			__func__);
 
 done:
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
 static enum sci_status sci_controller_construct(struct isci_host *ihost,
@@ -1745,7 +1745,7 @@ static void power_control_timeout(unsigned long data)
 	unsigned long flags;
 	u8 i;
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	if (tmr->cancel)
 		goto done;
@@ -1808,7 +1808,7 @@ static void power_control_timeout(unsigned long data)
 	ihost->power_control.timer_started = true;
 
 done:
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
 void sci_controller_power_control_queue_insert(struct isci_host *ihost,
@@ -2343,9 +2343,9 @@ int isci_host_init(struct isci_host *ihost)
 	int i, err;
 	enum sci_status status;
 
-	spin_lock_irq(&ihost->scic_lock);
+	raw_spin_lock_irq(&ihost->scic_lock);
 	status = sci_controller_construct(ihost, scu_base(ihost), smu_base(ihost));
-	spin_unlock_irq(&ihost->scic_lock);
+	raw_spin_unlock_irq(&ihost->scic_lock);
 	if (status != SCI_SUCCESS) {
 		dev_err(&ihost->pdev->dev,
 			"%s: sci_controller_construct failed - status = %x\n",
@@ -2354,9 +2354,9 @@ int isci_host_init(struct isci_host *ihost)
 		return -ENODEV;
 	}
 
-	spin_lock_irq(&ihost->scic_lock);
+	raw_spin_lock_irq(&ihost->scic_lock);
 	status = sci_controller_initialize(ihost);
-	spin_unlock_irq(&ihost->scic_lock);
+	raw_spin_unlock_irq(&ihost->scic_lock);
 	if (status != SCI_SUCCESS) {
 		dev_warn(&ihost->pdev->dev,
 			 "%s: sci_controller_initialize failed -"
diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 22a9bb1abae1..9e2939910c1d 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -204,7 +204,7 @@ struct isci_host {
 	unsigned long flags;
 	wait_queue_head_t eventq;
 	struct tasklet_struct completion_tasklet;
-	spinlock_t scic_lock;
+	raw_spinlock_t scic_lock;
 	struct isci_request *reqs[SCI_MAX_IO_REQUESTS];
 	struct isci_remote_device devices[SCI_MAX_REMOTE_DEVICES];
 };
diff --git a/drivers/scsi/isci/init.c b/drivers/scsi/isci/init.c
index d25d0d859f05..7ca8fed258dd 100644
--- a/drivers/scsi/isci/init.c
+++ b/drivers/scsi/isci/init.c
@@ -525,7 +525,7 @@ static struct isci_host *isci_host_alloc(struct pci_dev *pdev, int id)
 
 	ihost->pdev = pdev;
 	ihost->id = id;
-	spin_lock_init(&ihost->scic_lock);
+	raw_spin_lock_init(&ihost->scic_lock);
 	init_waitqueue_head(&ihost->eventq);
 	ihost->sas_ha.dev = &ihost->pdev->dev;
 	ihost->sas_ha.lldd_ha = ihost;
diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index cb87b2ef7c92..5d567165f65a 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -322,7 +322,7 @@ static void phy_sata_timeout(unsigned long data)
 	struct isci_host *ihost = iphy->owning_port->owning_controller;
 	unsigned long flags;
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	if (tmr->cancel)
 		goto done;
@@ -335,7 +335,7 @@ static void phy_sata_timeout(unsigned long data)
 
 	sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 done:
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
 /**
@@ -1443,18 +1443,18 @@ int isci_phy_control(struct asd_sas_phy *sas_phy,
 
 	switch (func) {
 	case PHY_FUNC_DISABLE:
-		spin_lock_irqsave(&ihost->scic_lock, flags);
+		raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 		scu_link_layer_start_oob(iphy);
 		sci_phy_stop(iphy);
-		spin_unlock_irqrestore(&ihost->scic_lock, flags);
+		raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		break;
 
 	case PHY_FUNC_LINK_RESET:
-		spin_lock_irqsave(&ihost->scic_lock, flags);
+		raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 		scu_link_layer_start_oob(iphy);
 		sci_phy_stop(iphy);
 		sci_phy_start(iphy);
-		spin_unlock_irqrestore(&ihost->scic_lock, flags);
+		raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		break;
 
 	case PHY_FUNC_HARD_RESET:
diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 13098b09a824..4e0a5bc27e9f 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -777,7 +777,7 @@ static void port_timeout(unsigned long data)
 	unsigned long flags;
 	u32 current_state;
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	if (tmr->cancel)
 		goto done;
@@ -811,7 +811,7 @@ static void port_timeout(unsigned long data)
 	}
 
 done:
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
 /* --------------------------------------------------------------------------- */
@@ -1655,13 +1655,13 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 	dev_dbg(&ihost->pdev->dev, "%s: iport = %p\n",
 		__func__, iport);
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 	set_bit(IPORT_RESET_PENDING, &iport->state);
 
 	#define ISCI_PORT_RESET_TIMEOUT SCIC_SDS_SIGNATURE_FIS_TIMEOUT
 	status = sci_port_hard_reset(iport, ISCI_PORT_RESET_TIMEOUT);
 
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	if (status == SCI_SUCCESS) {
 		wait_port_reset(ihost, iport);
@@ -1699,9 +1699,9 @@ int isci_ata_check_ready(struct domain_device *dev)
 	unsigned long flags;
 	int rc = 0;
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 	idev = isci_lookup_device(dev);
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	if (!idev)
 		goto out;
@@ -1729,12 +1729,12 @@ void isci_port_deformed(struct asd_sas_phy *phy)
 	if (!iport)
 		return;
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 	for (i = 0; i < SCI_MAX_PHYS; i++) {
 		if (iport->active_phy_mask & 1 << i)
 			break;
 	}
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	if (i >= SCI_MAX_PHYS)
 		dev_dbg(&ihost->pdev->dev, "%s: port: %ld\n",
@@ -1755,13 +1755,13 @@ void isci_port_formed(struct asd_sas_phy *phy)
 	 */
 	wait_for_start(ihost);
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 	for (i = 0; i < SCI_MAX_PORTS; i++) {
 		iport = &ihost->ports[i];
 		if (iport->active_phy_mask & 1 << iphy->phy_index)
 			break;
 	}
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	if (i >= SCI_MAX_PORTS)
 		iport = NULL;
diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index ac879745ef80..8d0a56e10b49 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -331,7 +331,7 @@ static void mpc_agent_timeout(unsigned long data)
 	port_agent = container_of(tmr, typeof(*port_agent), timer);
 	ihost = container_of(port_agent, typeof(*ihost), port_agent);
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	if (tmr->cancel)
 		goto done;
@@ -352,7 +352,7 @@ static void mpc_agent_timeout(unsigned long data)
 	}
 
 done:
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
 static void sci_mpc_agent_link_up(struct isci_host *ihost,
@@ -666,7 +666,7 @@ static void apc_agent_timeout(unsigned long data)
 	port_agent = container_of(tmr, typeof(*port_agent), timer);
 	ihost = container_of(port_agent, typeof(*ihost), port_agent);
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	if (tmr->cancel)
 		goto done;
@@ -690,7 +690,7 @@ static void apc_agent_timeout(unsigned long data)
 		sci_controller_transition_to_ready(ihost, SCI_SUCCESS);
 
 done:
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
 /*
diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 96a26f454673..f9616a69e83e 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -159,10 +159,10 @@ static bool isci_check_reqterm(
 	unsigned long flags;
 	bool res;
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 	res = isci_compare_suspendcount(idev, localcount)
 		&& !test_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags);
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	return res;
 }
@@ -175,10 +175,10 @@ static bool isci_check_devempty(
 	unsigned long flags;
 	bool res;
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 	res = isci_compare_suspendcount(idev, localcount)
 		&& idev->started_request_count == 0;
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	return res;
 }
@@ -192,12 +192,12 @@ enum sci_status isci_remote_device_terminate_requests(
 	unsigned long flags;
 	u32 rnc_suspend_count;
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	if (isci_get_device(idev) == NULL) {
 		dev_dbg(&ihost->pdev->dev, "%s: failed isci_get_device(idev=%p)\n",
 			__func__, idev);
-		spin_unlock_irqrestore(&ihost->scic_lock, flags);
+		raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		status = SCI_FAILURE;
 	} else {
 		/* If already suspended, don't wait for another suspension. */
@@ -218,7 +218,7 @@ enum sci_status isci_remote_device_terminate_requests(
 			/* Terminate a specific TC. */
 			set_bit(IREQ_NO_AUTO_FREE_TAG, &ireq->flags);
 			sci_remote_device_terminate_req(ihost, idev, 0, ireq);
-			spin_unlock_irqrestore(&ihost->scic_lock, flags);
+			raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 			if (!wait_event_timeout(ihost->eventq,
 						isci_check_reqterm(ihost, idev, ireq,
 								   rnc_suspend_count),
@@ -243,15 +243,15 @@ enum sci_status isci_remote_device_terminate_requests(
 					 idev->rnc.destination_state,
 					 ireq, ireq->flags);
 			}
-			spin_lock_irqsave(&ihost->scic_lock, flags);
+			raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 			clear_bit(IREQ_NO_AUTO_FREE_TAG, &ireq->flags);
 			if (!test_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags))
 				isci_free_tag(ihost, ireq->io_tag);
-			spin_unlock_irqrestore(&ihost->scic_lock, flags);
+			raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		} else {
 			/* Terminate all TCs. */
 			sci_remote_device_terminate_requests(idev);
-			spin_unlock_irqrestore(&ihost->scic_lock, flags);
+			raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 			if (!wait_event_timeout(ihost->eventq,
 						isci_check_devempty(ihost, idev,
 								    rnc_suspend_count),
@@ -1375,11 +1375,11 @@ static bool isci_remote_device_test_resume_done(
 	unsigned long flags;
 	bool done;
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 	done = !test_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags)
 		|| test_bit(IDEV_STOP_PENDING, &idev->flags)
 		|| sci_remote_node_context_is_being_destroyed(&idev->rnc);
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	return done;
 }
@@ -1413,7 +1413,7 @@ enum sci_status isci_remote_device_resume_from_abort(
 	enum sci_status status = SCI_SUCCESS;
 	int destroyed;
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 	/* Preserve any current resume callbacks, for instance from other
 	 * resumptions.
 	 */
@@ -1426,7 +1426,7 @@ enum sci_status isci_remote_device_resume_from_abort(
 		status = sci_remote_device_resume(
 			idev, isci_remote_device_resume_from_abort_complete,
 			idev);
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 	if (!destroyed && (status == SCI_SUCCESS))
 		isci_remote_device_wait_for_resume_from_abort(ihost, idev);
 	else
@@ -1562,13 +1562,13 @@ enum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_rem
 	dev_dbg(&ihost->pdev->dev,
 		"%s: isci_device = %p\n", __func__, idev);
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 	idev->domain_dev->lldd_dev = NULL; /* disable new lookups */
 	set_bit(IDEV_GONE, &idev->flags);
 
 	set_bit(IDEV_STOP_PENDING, &idev->flags);
 	status = sci_remote_device_stop(idev, 50);
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	/* Wait for the stop complete callback. */
 	if (WARN_ONCE(status != SCI_SUCCESS, "failed to stop device\n"))
@@ -1630,7 +1630,7 @@ int isci_remote_device_found(struct domain_device *dev)
 	kref_init(&isci_device->kref);
 	INIT_LIST_HEAD(&isci_device->node);
 
-	spin_lock_irq(&isci_host->scic_lock);
+	raw_spin_lock_irq(&isci_host->scic_lock);
 	isci_device->domain_dev = dev;
 	isci_device->isci_port = isci_port;
 	list_add_tail(&isci_device->node, &isci_port->remote_dev_list);
@@ -1647,7 +1647,7 @@ int isci_remote_device_found(struct domain_device *dev)
 		dev->lldd_dev = isci_device;
 	} else
 		isci_put_device(isci_device);
-	spin_unlock_irq(&isci_host->scic_lock);
+	raw_spin_unlock_irq(&isci_host->scic_lock);
 
 	/* wait for the device ready callback. */
 	wait_for_device_start(isci_host, isci_device);
@@ -1664,10 +1664,10 @@ enum sci_status isci_remote_device_suspend_terminate(
 	enum sci_status status;
 
 	/* Put the device into suspension. */
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 	set_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags);
 	sci_remote_device_suspend(idev, SCI_SW_SUSPEND_LINKHANG_DETECT);
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	/* Terminate and wait for the completions. */
 	status = isci_remote_device_terminate_requests(ihost, idev, ireq);
@@ -1700,9 +1700,9 @@ enum sci_status isci_remote_device_reset_complete(
 	unsigned long flags;
 	enum sci_status status;
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 	status = sci_remote_device_reset_complete(idev);
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	return status;
 }
diff --git a/drivers/scsi/isci/request.c b/drivers/scsi/isci/request.c
index 99d2930b18c8..014068f7b96a 100644
--- a/drivers/scsi/isci/request.c
+++ b/drivers/scsi/isci/request.c
@@ -3462,7 +3462,7 @@ int isci_request_execute(struct isci_host *ihost, struct isci_remote_device *ide
 		return status;
 	}
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	if (test_bit(IDEV_IO_NCQERROR, &idev->flags)) {
 
@@ -3491,7 +3491,7 @@ int isci_request_execute(struct isci_host *ihost, struct isci_remote_device *ide
 		dev_dbg(&ihost->pdev->dev,
 			 "%s: failed request start (0x%x)\n",
 			 __func__, status);
-		spin_unlock_irqrestore(&ihost->scic_lock, flags);
+		raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		return status;
 	}
 	/* Either I/O started OK, or the core has signaled that
@@ -3504,7 +3504,7 @@ int isci_request_execute(struct isci_host *ihost, struct isci_remote_device *ide
 		 */
 		set_bit(IREQ_TERMINATED, &ireq->flags);
 	}
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	if (status ==
 	    SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED) {
diff --git a/drivers/scsi/isci/task.c b/drivers/scsi/isci/task.c
index 5d6fda72d659..543183fe539e 100644
--- a/drivers/scsi/isci/task.c
+++ b/drivers/scsi/isci/task.c
@@ -135,11 +135,11 @@ int isci_task_execute_task(struct sas_task *task, int num, gfp_t gfp_flags)
 	for_each_sas_task(num, task) {
 		enum sci_status status = SCI_FAILURE;
 
-		spin_lock_irqsave(&ihost->scic_lock, flags);
+		raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 		idev = isci_lookup_device(task->dev);
 		io_ready = isci_device_io_ready(idev, task);
 		tag = isci_alloc_tag(ihost);
-		spin_unlock_irqrestore(&ihost->scic_lock, flags);
+		raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 		dev_dbg(&ihost->pdev->dev,
 			"task: %p, num: %d dev: %p idev: %p:%#lx cmd = %p\n",
@@ -206,12 +206,12 @@ int isci_task_execute_task(struct sas_task *task, int num, gfp_t gfp_flags)
 			}
 		}
 		if (status != SCI_SUCCESS && tag != SCI_CONTROLLER_INVALID_IO_TAG) {
-			spin_lock_irqsave(&ihost->scic_lock, flags);
+			raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 			/* command never hit the device, so just free
 			 * the tci and skip the sequence increment
 			 */
 			isci_tci_free(ihost, ISCI_TAG_TCI(tag));
-			spin_unlock_irqrestore(&ihost->scic_lock, flags);
+			raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		}
 		isci_put_device(idev);
 	}
@@ -272,9 +272,9 @@ static int isci_task_execute_tmf(struct isci_host *ihost,
 	unsigned long timeleft;
 	u16 tag;
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 	tag = isci_alloc_tag(ihost);
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	if (tag == SCI_CONTROLLER_INVALID_IO_TAG)
 		return ret;
@@ -303,7 +303,7 @@ static int isci_task_execute_tmf(struct isci_host *ihost,
 	if (!ireq)
 		goto err_tci;
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	/* start the TMF io. */
 	status = sci_controller_start_task(ihost, idev, ireq);
@@ -314,10 +314,10 @@ static int isci_task_execute_tmf(struct isci_host *ihost,
 			 __func__,
 			 status,
 			 ireq);
-		spin_unlock_irqrestore(&ihost->scic_lock, flags);
+		raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		goto err_tci;
 	}
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	/* The RNC must be unsuspended before the TMF can get a response. */
 	isci_remote_device_resume_from_abort(ihost, idev);
@@ -354,9 +354,9 @@ static int isci_task_execute_tmf(struct isci_host *ihost,
 	return ret;
 
  err_tci:
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 	isci_tci_free(ihost, ISCI_TAG_TCI(tag));
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	return ret;
 }
@@ -423,9 +423,9 @@ int isci_task_lu_reset(struct domain_device *dev, u8 *lun)
 	unsigned long flags;
 	int ret = TMF_RESP_FUNC_COMPLETE;
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 	idev = isci_get_device(dev->lldd_dev);
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	dev_dbg(&ihost->pdev->dev,
 		"%s: domain_device=%p, isci_host=%p; isci_device=%p\n",
@@ -498,7 +498,7 @@ int isci_task_abort_task(struct sas_task *task)
 	 * in the device, because tasks driving resets may land here
 	 * after completion in the core.
 	 */
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 	spin_lock(&task->task_state_lock);
 
 	old_request = task->lldd_task;
@@ -512,7 +512,7 @@ int isci_task_abort_task(struct sas_task *task)
 					       &old_request->flags);
 	}
 	spin_unlock(&task->task_state_lock);
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	dev_warn(&ihost->pdev->dev,
 		 "%s: dev = %p (%s%s), task = %p, old_request == %p\n",
@@ -560,14 +560,14 @@ int isci_task_abort_task(struct sas_task *task)
 		ret = TMF_RESP_FUNC_FAILED;
 		goto out;
 	}
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	if (task->task_proto == SAS_PROTOCOL_SMP ||
 	    sas_protocol_ata(task->task_proto) ||
 	    target_done_already ||
 	    test_bit(IDEV_GONE, &idev->flags)) {
 
-		spin_unlock_irqrestore(&ihost->scic_lock, flags);
+		raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 		/* No task to send, so explicitly resume the device here */
 		isci_remote_device_resume_from_abort(ihost, idev);
@@ -599,7 +599,7 @@ int isci_task_abort_task(struct sas_task *task)
 		isci_task_build_abort_task_tmf(&tmf, isci_tmf_ssp_task_abort,
 					       old_request);
 
-		spin_unlock_irqrestore(&ihost->scic_lock, flags);
+		raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 		/* Send the task management request. */
 		#define ISCI_ABORT_TASK_TIMEOUT_MS 500 /* 1/2 second timeout */
@@ -793,9 +793,9 @@ int isci_task_I_T_nexus_reset(struct domain_device *dev)
 	unsigned long flags;
 	int ret;
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	raw_spin_lock_irqsave(&ihost->scic_lock, flags);
 	idev = isci_get_device(dev->lldd_dev);
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	raw_spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	if (!idev) {
 		/* XXX: need to cleanup any ireqs targeting this
-- 
2.2.1

