From dc853fa22080e20b3ab9237d7eb8ec539f70ae20 Mon Sep 17 00:00:00 2001
From: Pengyu Ma <pengyu.ma@windriver.com>
Date: Mon, 23 Nov 2015 17:18:02 +0800
Subject: [PATCH] drm/i915: replace local_irq_disable with local locks

RT triggers the following:

Call Trace:
 [<ffffffff81a46070>] dump_stack+0x4a/0x61
 [<ffffffff8107c557>] ___might_sleep+0xe7/0x170
 [<ffffffff81a4cff4>] rt_spin_lock+0x24/0x60
 [<ffffffff8153e6d1>] drm_vblank_get+0x51/0xe0
 [<ffffffff8153e810>] drm_crtc_vblank_get+0x20/0x30
 [<ffffffffa018d9c8>] intel_pipe_update_start+0x108/0x2c0 [i915]
 [<ffffffff81095ff0>] ? wake_atomic_t_function+0x60/0x60
 [<ffffffffa0169a0f>] intel_begin_crtc_commit+0x9f/0xd0 [i915]
 [<ffffffff815327fb>] drm_atomic_helper_commit_planes_on_crtc+0x5b/0x280
 [<ffffffffa0178876>] intel_atomic_commit+0x226/0x1430 [i915]
 [<ffffffff81559e22>] ? drm_atomic_check_only+0x232/0x5b0
 [<ffffffff81559121>] ? drm_atomic_get_crtc_state+0x71/0xc0
 [<ffffffff8155a1d7>] drm_atomic_commit+0x37/0x60
 [<ffffffff815335bd>] drm_atomic_helper_plane_set_property+0x8d/0xd0
 [<ffffffff81a4bbb9>] ? __ww_mutex_lock+0x39/0x40
 [<ffffffff81547a5d>] drm_mode_plane_set_obj_prop+0x2d/0x90

The function call flow:

intel_pipe_update_start:
1, local_irq_disable;
2, call drm_crtc_vblank_get, in this funtion:
    1)spin_lock_irqsave;
     ... do something;
    2) spin_lock_irqrestore;
3, update crtc structure and do something;
4, local_irq_enable;

local_lock_irq will protect step 3.

Function intel_pipe_update_start does local_irq_disable() before
drm_vblank_get which calls spin_lock_irqsave().
As spinlocks are sleepable on rt, it shouldn't be called when interrupt
disabled.
Use local_irq_lock to make preemption possible.

Signed-off-by: Pengyu Ma <pengyu.ma@windriver.com>

diff --git a/drivers/gpu/drm/i915/intel_sprite.c b/drivers/gpu/drm/i915/intel_sprite.c
index a4c0a04b5044..a00e660efc47 100644
--- a/drivers/gpu/drm/i915/intel_sprite.c
+++ b/drivers/gpu/drm/i915/intel_sprite.c
@@ -37,6 +37,9 @@
 #include "intel_drv.h"
 #include <drm/i915_drm.h>
 #include "i915_drv.h"
+#include <linux/locallock.h>
+
+static DEFINE_LOCAL_IRQ_LOCK(intel_crtc_lock);
 
 static bool
 format_is_yuv(uint32_t format)
@@ -61,6 +64,7 @@ static int usecs_to_scanlines(const struct drm_display_mode *mode, int usecs)
 	return DIV_ROUND_UP(usecs * mode->crtc_clock, 1000 * mode->crtc_htotal);
 }
 
+
 /**
  * intel_pipe_update_start() - start update of a set of display registers
  * @crtc: the crtc of which the registers are going to be updated
@@ -101,7 +105,7 @@ bool intel_pipe_update_start(struct intel_crtc *crtc, uint32_t *start_vbl_count)
 	if (WARN_ON(drm_crtc_vblank_get(&crtc->base)))
 		return false;
 
-	local_irq_disable();
+	local_lock_irq(intel_crtc_lock);
 
 	trace_i915_pipe_update_start(crtc, min, max);
 
@@ -123,11 +127,11 @@ bool intel_pipe_update_start(struct intel_crtc *crtc, uint32_t *start_vbl_count)
 			break;
 		}
 
-		local_irq_enable();
+		local_unlock_irq(intel_crtc_lock);
 
 		timeout = schedule_timeout(timeout);
 
-		local_irq_disable();
+		local_lock_irq(intel_crtc_lock);
 	}
 
 	finish_wait(wq, &wait);
@@ -158,7 +162,7 @@ void intel_pipe_update_end(struct intel_crtc *crtc, u32 start_vbl_count)
 
 	trace_i915_pipe_update_end(crtc, end_vbl_count);
 
-	local_irq_enable();
+	local_unlock_irq(intel_crtc_lock);
 
 	if (start_vbl_count != end_vbl_count)
 		DRM_ERROR("Atomic update failure on pipe %c (start=%u end=%u)\n",
-- 
2.5.0

