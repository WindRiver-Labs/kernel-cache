From 779aadde94f0cdd71e41f75a8d9aa311c4846fd2 Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Mon, 26 Nov 2012 19:44:34 +0800
Subject: [PATCH] rt: cfg80211: fix call trace of cfg80211 on -rt kernel

.../kernel/rtmutex.c:646
in_atomic(): 1, irqs_disabled(): 0, pid: 800, name: ip
Pid: 800, comm: ip Not tainted 3.4.16-rt17-preempt-rt #1
Call Trace:
 [<ffffffff8105f9dd>] __might_sleep+0xcd/0xf0
 [<ffffffff8170f765>] rt_spin_lock+0x25/0x50
 [<ffffffffa0018ebc>] cfg80211_mlme_unregister_socket+0x4c/0x120
 [cfg80211]
 [<ffffffffa000e43c>] nl80211_netlink_notify+0x8c/0xe0 [cfg80211]
 [<ffffffff8171386a>] notifier_call_chain+0x5a/0x80
 [<ffffffff817138bf>] __atomic_notifier_call_chain+0x2f/0x60
 [<ffffffff81713906>] atomic_notifier_call_chain+0x16/0x20
 [<ffffffff8162259a>] netlink_release+0x25a/0x290
 [<ffffffff815e63b9>] sock_release+0x29/0x90
 [<ffffffff815e6787>] sock_close+0x17/0x30
 [<ffffffff811277b8>] fput+0xf8/0x270
 [<ffffffff811238d9>] filp_close+0x69/0x90
 [<ffffffff81030a4a>] put_files_struct+0xba/0x130
 [<ffffffff81031ed0>] exit_files+0x60/0x80
 [<ffffffff810323e5>] do_exit+0x165/0x920
 [<ffffffff81125963>] ? vfs_write+0x133/0x170
 [<ffffffff81032f1e>] do_group_exit+0x4e/0xc0
 [<ffffffff81032fa7>] sys_exit_group+0x17/0x20
 [<ffffffff817174d2>] system_call_fastpath+0x16/0x1b

We can see that the lock being invoked on a atomic path, that is the
origin of the call trace. To make the semantic consistence and fix the
call trace, convert the original spinlock_* to raw_spinlock_*.

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 include/net/cfg80211.h |    2 +-
 net/wireless/core.c    |    2 +-
 net/wireless/mlme.c    |   16 ++++++++--------
 3 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index 83d800c..7c765b8 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -2263,7 +2263,7 @@ struct wireless_dev {
 	struct net_device *netdev;
 
 	struct list_head mgmt_registrations;
-	spinlock_t mgmt_registrations_lock;
+	raw_spinlock_t mgmt_registrations_lock;
 
 	struct mutex mtx;
 
diff --git a/net/wireless/core.c b/net/wireless/core.c
index bb5302d..c917c09 100644
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -808,7 +808,7 @@ static int cfg80211_netdev_notifier_call(struct notifier_block * nb,
 		INIT_LIST_HEAD(&wdev->event_list);
 		spin_lock_init(&wdev->event_lock);
 		INIT_LIST_HEAD(&wdev->mgmt_registrations);
-		spin_lock_init(&wdev->mgmt_registrations_lock);
+		raw_spin_lock_init(&wdev->mgmt_registrations_lock);
 
 		mutex_lock(&rdev->devlist_mtx);
 		list_add_rcu(&wdev->list, &rdev->netdev_list);
diff --git a/net/wireless/mlme.c b/net/wireless/mlme.c
index f5a7ac3..6ae6a6c 100644
--- a/net/wireless/mlme.c
+++ b/net/wireless/mlme.c
@@ -635,7 +635,7 @@ int cfg80211_mlme_register_mgmt(struct wireless_dev *wdev, u32 snd_pid,
 	if (!nreg)
 		return -ENOMEM;
 
-	spin_lock_bh(&wdev->mgmt_registrations_lock);
+	raw_spin_lock_bh(&wdev->mgmt_registrations_lock);
 
 	list_for_each_entry(reg, &wdev->mgmt_registrations, list) {
 		int mlen = min(match_len, reg->match_len);
@@ -665,7 +665,7 @@ int cfg80211_mlme_register_mgmt(struct wireless_dev *wdev, u32 snd_pid,
 					       frame_type, true);
 
  out:
-	spin_unlock_bh(&wdev->mgmt_registrations_lock);
+	raw_spin_unlock_bh(&wdev->mgmt_registrations_lock);
 
 	return err;
 }
@@ -676,7 +676,7 @@ void cfg80211_mlme_unregister_socket(struct wireless_dev *wdev, u32 nlpid)
 	struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
 	struct cfg80211_mgmt_registration *reg, *tmp;
 
-	spin_lock_bh(&wdev->mgmt_registrations_lock);
+	raw_spin_lock_bh(&wdev->mgmt_registrations_lock);
 
 	list_for_each_entry_safe(reg, tmp, &wdev->mgmt_registrations, list) {
 		if (reg->nlpid != nlpid)
@@ -693,7 +693,7 @@ void cfg80211_mlme_unregister_socket(struct wireless_dev *wdev, u32 nlpid)
 		kfree(reg);
 	}
 
-	spin_unlock_bh(&wdev->mgmt_registrations_lock);
+	raw_spin_unlock_bh(&wdev->mgmt_registrations_lock);
 
 	if (nlpid == wdev->ap_unexpected_nlpid)
 		wdev->ap_unexpected_nlpid = 0;
@@ -703,14 +703,14 @@ void cfg80211_mlme_purge_registrations(struct wireless_dev *wdev)
 {
 	struct cfg80211_mgmt_registration *reg, *tmp;
 
-	spin_lock_bh(&wdev->mgmt_registrations_lock);
+	raw_spin_lock_bh(&wdev->mgmt_registrations_lock);
 
 	list_for_each_entry_safe(reg, tmp, &wdev->mgmt_registrations, list) {
 		list_del(&reg->list);
 		kfree(reg);
 	}
 
-	spin_unlock_bh(&wdev->mgmt_registrations_lock);
+	raw_spin_unlock_bh(&wdev->mgmt_registrations_lock);
 }
 
 int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,
@@ -839,7 +839,7 @@ bool cfg80211_rx_mgmt(struct net_device *dev, int freq, int sig_mbm,
 	data = buf + ieee80211_hdrlen(mgmt->frame_control);
 	data_len = len - ieee80211_hdrlen(mgmt->frame_control);
 
-	spin_lock_bh(&wdev->mgmt_registrations_lock);
+	raw_spin_lock_bh(&wdev->mgmt_registrations_lock);
 
 	list_for_each_entry(reg, &wdev->mgmt_registrations, list) {
 		if (reg->frame_type != ftype)
@@ -863,7 +863,7 @@ bool cfg80211_rx_mgmt(struct net_device *dev, int freq, int sig_mbm,
 		break;
 	}
 
-	spin_unlock_bh(&wdev->mgmt_registrations_lock);
+	raw_spin_unlock_bh(&wdev->mgmt_registrations_lock);
 
 	return result;
 }
-- 
1.7.9.7

