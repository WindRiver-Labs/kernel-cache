From 3eacc19eea38fd0c839a76e6a11cd86568131fb6 Mon Sep 17 00:00:00 2001
From: Chris Friesen <chris.friesen@windriver.com>
Date: Tue, 24 Nov 2015 16:27:28 -0500
Subject: [PATCH] affine compute kernel threads to cpu 0

This is a kernel enhancement to configure the cpu affinity of kernel
threads via kernel boot option kthread_cpus=<cpulist>. The compute
kickstart file and compute-huge.sh scripts are modified to update
grub with the new option. The affine-platform.sh script is modified
not to affine kernel threads since the kernel option already does this.

With kthread_cpus specified, the cpumask is immediately applied upon
thread launch. This does not affect kernel threads that specify cpu
and node.

Note: this is based off of Christoph Lameter's patch at
https://lwn.net/Articles/565932/ with the only difference being
the kernel parameter changed from kthread to kthread_cpus.

Signed-off-by: Christoph Lameter <cl@linux.com>
Signed-off-by: Chris Friesen <chris.friesen@windriver.com>
[VT: The existing "isolcpus"
 kernel bootarg, cgroup/cpuset, and taskset might provide the some
 way to have cpu isolation.  However none of them satisfies the requirements.
 Replacing spaces with tabs. Combine two calls of set_cpus_allowed_ptr()
 in kernel_init_freeable() in init/main.c into one.  Performed tests]
Signed-off-by: Vu Tran <vu.tran@windriver.com>

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index caaa20b8f365..38b7caedca1d 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -1364,6 +1364,16 @@ bytes respectively. Such letter suffixes can also be entirely omitted.
 	kstack=N	[X86] Print N words from the kernel stack
 			in oops dumps.
 
+	kthread_cpus=	[KNL, SMP] Only run kernel threads on the specified
+			list of processors. The kernel will start threads
+			on the indicated processors only (unless there
+			are specific reasons to run a thread with
+			different affinities). This can be used to make
+			init start on certain processors and also to
+			control where kmod and other user space threads
+			are being spawned. Allows to keep kernel threads
+			away from certain cores unless absoluteluy necessary.
+
 	kvm.ignore_msrs=[KVM] Ignore guest accesses to unhandled MSRs.
 			Default is 0 (don't ignore, but inject #GP)
 
diff --git a/include/linux/cpumask.h b/include/linux/cpumask.h
index d08e4d2a9b92..6835e7394e15 100644
--- a/include/linux/cpumask.h
+++ b/include/linux/cpumask.h
@@ -44,6 +44,7 @@ extern int nr_cpu_ids;
  *     cpu_present_mask - has bit 'cpu' set iff cpu is populated
  *     cpu_online_mask  - has bit 'cpu' set iff cpu available to scheduler
  *     cpu_active_mask  - has bit 'cpu' set iff cpu available to migration
+ *     cpu_kthread_mask - has bit 'cpu' set iff general kernel threads allowed
  *
  *  If !CONFIG_HOTPLUG_CPU, present == possible, and active == online.
  *
@@ -80,6 +81,7 @@ extern const struct cpumask *const cpu_possible_mask;
 extern const struct cpumask *const cpu_online_mask;
 extern const struct cpumask *const cpu_present_mask;
 extern const struct cpumask *const cpu_active_mask;
+extern const struct cpumask *const cpu_kthread_mask;
 
 #if NR_CPUS > 1
 #define num_online_cpus()	cpumask_weight(cpu_online_mask)
diff --git a/init/main.c b/init/main.c
index 3e6a8b025d68..d1e6b2756668 100644
--- a/init/main.c
+++ b/init/main.c
@@ -872,10 +872,6 @@ static noinline void __init kernel_init_freeable(void)
 	 * init can allocate pages on any node
 	 */
 	set_mems_allowed(node_states[N_MEMORY]);
-	/*
-	 * init can run on any cpu.
-	 */
-	set_cpus_allowed_ptr(current, cpu_all_mask);
 
 	cad_pid = task_pid(current);
 
@@ -889,6 +885,8 @@ static noinline void __init kernel_init_freeable(void)
 
 	do_basic_setup();
 
+	set_cpus_allowed_ptr(current, cpu_kthread_mask);
+
 	/* Use /dev/console to infer if the rootfs is setup properly */
 	if (sys_newlstat((char __user *) "/dev/console", (struct stat __user *) &console_stat)
 			|| !S_ISCHR(console_stat.st_mode)) {
diff --git a/kernel/cpu.c b/kernel/cpu.c
index e4dd0bc388bd..ed640b3d61ff 100644
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@ -1008,6 +1008,19 @@ static DECLARE_BITMAP(cpu_active_bits, CONFIG_NR_CPUS) __read_mostly;
 const struct cpumask *const cpu_active_mask = to_cpumask(cpu_active_bits);
 EXPORT_SYMBOL(cpu_active_mask);
 
+static DECLARE_BITMAP(cpu_kthread_bits, CONFIG_NR_CPUS) __read_mostly
+	= CPU_BITS_ALL;
+const struct cpumask *const cpu_kthread_mask = to_cpumask(cpu_kthread_bits);
+EXPORT_SYMBOL(cpu_kthread_mask);
+
+static int __init kthread_setup(char *str)
+{
+	cpulist_parse(str, (struct cpumask *)&cpu_kthread_bits);
+	return 1;
+}
+__setup("kthread_cpus=", kthread_setup);
+
+
 void set_cpu_possible(unsigned int cpu, bool possible)
 {
 	if (possible)
diff --git a/kernel/kmod.c b/kernel/kmod.c
index 8241906c4b61..8e10628f546b 100644
--- a/kernel/kmod.c
+++ b/kernel/kmod.c
@@ -206,8 +206,8 @@ static int ____call_usermodehelper(void *data)
 	flush_signal_handlers(current, 1);
 	spin_unlock_irq(&current->sighand->siglock);
 
-	/* We can run anywhere, unlike our parent keventd(). */
-	set_cpus_allowed_ptr(current, cpu_all_mask);
+	/* We can run only where init is allowed to run. */
+	set_cpus_allowed_ptr(current, cpu_kthread_mask);
 
 	/*
 	 * Our parent is keventd, which runs with elevated scheduling priority.
diff --git a/kernel/kthread.c b/kernel/kthread.c
index 760e86df8c20..5a8af1ffbf30 100644
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -282,7 +282,7 @@ struct task_struct *kthread_create_on_node(int (*threadfn)(void *data),
 		 * The kernel thread should not inherit these properties.
 		 */
 		sched_setscheduler_nocheck(create.result, SCHED_NORMAL, &param);
-		set_cpus_allowed_ptr(create.result, cpu_all_mask);
+		set_cpus_allowed_ptr(create.result, cpu_kthread_mask);
 	}
 	return create.result;
 }
@@ -450,7 +450,7 @@ int kthreadd(void *unused)
 	/* Setup a clean context for our children to inherit. */
 	set_task_comm(tsk, "kthreadd");
 	ignore_signals(tsk);
-	set_cpus_allowed_ptr(tsk, cpu_all_mask);
+	set_cpus_allowed_ptr(tsk, cpu_kthread_mask);
 	set_mems_allowed(node_states[N_MEMORY]);
 
 	current->flags |= PF_NOFREEZE;
-- 
2.1.4

