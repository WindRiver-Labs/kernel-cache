From 9b420ca79c83e4d86646943b0fd5bbd6396745dd Mon Sep 17 00:00:00 2001
From: "yadi.hu@windriver.com" <yadi.hu@windriver.com>
Date: Fri, 5 Jun 2015 12:43:55 +0800
Subject: [PATCH] tty:fix a recursive locking

Use buffer lock instead of output_lock

Signed-off-by: Hu <yadi.hu@windriver.com>
---
 drivers/tty/n_tty.c      |    4 ----
 drivers/tty/tty_buffer.c |    5 +++++
 2 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c
index 6cfe401..6c7fe90 100644
--- a/drivers/tty/n_tty.c
+++ b/drivers/tty/n_tty.c
@@ -2066,12 +2066,8 @@ static ssize_t n_tty_write(struct tty_struct *tty, struct file *file,
 			if (tty->ops->flush_chars)
 				tty->ops->flush_chars(tty);
 		} else {
-			struct n_tty_data *ldata = tty->disc_data;
-
 			while (nr > 0) {
-				mutex_lock(&ldata->output_lock);
 				c = tty->ops->write(tty, b, nr);
-				mutex_unlock(&ldata->output_lock);
 				if (c < 0) {
 					retval = c;
 					goto break_out;
diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c
index 59c7366..2e80fd7 100644
--- a/drivers/tty/tty_buffer.c
+++ b/drivers/tty/tty_buffer.c
@@ -268,6 +268,10 @@ int tty_insert_flip_string_fixed_flag(struct tty_port *port,
 		int goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE);
 		int space = tty_buffer_request_room(port, goal);
 		struct tty_buffer *tb = port->buf.tail;
+		unsigned long flags;
+		struct tty_bufhead *bufhead = &port->buf;
+        	spin_lock_irqsave(&bufhead->lock, flags);
+
 		/* If there is no space then tb may be NULL */
 		if (unlikely(space == 0)) {
 			break;
@@ -277,6 +281,7 @@ int tty_insert_flip_string_fixed_flag(struct tty_port *port,
 		tb->used += space;
 		copied += space;
 		chars += space;
+		spin_unlock_irqrestore(&bufhead->lock, flags);
 		/* There is a small chance that we need to split the data over
 		   several buffers. If this is the case we must loop */
 	} while (unlikely(size > copied));
-- 
1.7.5.4

