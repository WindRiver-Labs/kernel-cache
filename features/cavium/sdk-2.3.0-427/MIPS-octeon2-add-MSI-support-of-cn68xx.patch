From df2749b1c6f7331b8f987f00025d7526da11663d Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 5 Sep 2012 16:09:28 +0800
Subject: [PATCH 17/27] MIPS: octeon2: add MSI support of cn68xx

Based on SDK 2.3.0-427

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/pci/msi-octeon.c |  140 +++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 139 insertions(+), 1 deletion(-)

diff --git a/arch/mips/pci/msi-octeon.c b/arch/mips/pci/msi-octeon.c
index d37be36..f1ffe0c 100644
--- a/arch/mips/pci/msi-octeon.c
+++ b/arch/mips/pci/msi-octeon.c
@@ -17,6 +17,8 @@
 #include <asm/octeon/cvmx-npei-defs.h>
 #include <asm/octeon/cvmx-pexp-defs.h>
 #include <asm/octeon/pci-octeon.h>
+#include <asm/octeon/cvmx-ciu2-defs.h>
+#include <asm/octeon/cvmx-sli-defs.h>
 
 /*
  * Each bit in msi_free_irq_bitmask represents a MSI interrupt that is
@@ -161,6 +163,12 @@ msi_irq_allocated:
 		msg.address_lo = (0 + CVMX_NPEI_PCIE_MSI_RCV) & 0xffffffff;
 		msg.address_hi = (0 + CVMX_NPEI_PCIE_MSI_RCV) >> 32;
 		break;
+        case OCTEON_DMA_BAR_TYPE_PCIE2:
+                /* When using PCIe2, Bar 0 is based at 0 */
+                msg.address_lo = (0 + CVMX_SLI_PCIE_MSI_RCV) & 0xffffffff;
+                msg.address_hi = (0 + CVMX_SLI_PCIE_MSI_RCV) >> 32;
+                break;
+
 	default:
 		panic("arch_setup_msi_irq: Invalid octeon_dma_bar_type");
 	}
@@ -356,6 +364,123 @@ OCTEON_MSI_INT_HANDLER_X(1);
 OCTEON_MSI_INT_HANDLER_X(2);
 OCTEON_MSI_INT_HANDLER_X(3);
 
+extern int octeon_coreid_for_cpu(int cpu);
+
+static void octeon_msi_ciu2_enable_on_cpu(struct irq_data *data, int cpu)
+{
+	int core;
+	int msi = data->irq - OCTEON_IRQ_MSI_BIT0;
+	union cvmx_ciu2_msi_selx sel;
+
+	core = octeon_coreid_for_cpu(cpu);
+
+	sel.u64 = 0;
+	sel.s.pp_num = core;
+	sel.s.ip_num = 2; /* IP4 */
+	sel.s.en = 1;
+	cvmx_write_csr(CVMX_CIU2_MSI_SELX(msi), sel.u64);
+}
+
+static void octeon_msi_ciu2_enable(struct irq_data *data)
+{
+	int cpu;
+
+#ifdef CONFIG_SMP
+	cpu = cpumask_first(data->affinity);
+#else
+	cpu = 0;
+#endif
+	octeon_msi_ciu2_enable_on_cpu(data, cpu);
+}
+
+static void octeon_msi_ciu2_disable(struct irq_data *data)
+{
+	int msi = data->irq - OCTEON_IRQ_MSI_BIT0;
+	union cvmx_ciu2_msi_selx sel;
+
+	sel.u64 = cvmx_read_csr(CVMX_CIU2_MSI_SELX(msi));
+	cvmx_write_csr(CVMX_CIU2_MSI_SELX(msi), 0);
+	cvmx_read_csr(CVMX_CIU2_ACK_PPX_IP4(sel.s.pp_num));
+}
+
+static void octeon_msi_ciu2_ack(struct irq_data *data)
+{
+	int msi = data->irq - OCTEON_IRQ_MSI_BIT0;
+	int core = cvmx_get_core_num();
+
+	cvmx_write_csr(CVMX_CIU2_MSI_RCVX(msi), 0);
+	cvmx_read_csr(CVMX_CIU2_ACK_PPX_IP4(core));
+}
+
+#ifdef CONFIG_SMP
+static int octeon_msi_ciu2_set_affinity(struct irq_data *data,
+					const struct cpumask *dest, bool force)
+{
+	int cpu = cpumask_first(dest);
+
+	/*
+	 * For CIU2-MSI, we will allow only single CPU affinity.
+	 * This .
+	 */
+	if (cpumask_weight(dest) != 1)
+		return -EINVAL;
+
+	if (irqd_irq_disabled(data))
+		return 0;
+
+	octeon_msi_ciu2_enable_on_cpu(data, cpu);
+
+	return 0;
+}
+#endif
+
+static struct irq_chip octeon_msi_chip_ciu2 = {
+	.name = "CIU2-MSI",
+	.irq_enable = octeon_msi_ciu2_enable,
+	.irq_disable = octeon_msi_ciu2_disable,
+	.irq_ack = octeon_msi_ciu2_ack,
+	.irq_mask = octeon_msi_ciu2_disable,
+	.irq_unmask = octeon_msi_ciu2_enable,
+#ifdef CONFIG_SMP
+	.irq_set_affinity = octeon_msi_ciu2_set_affinity,
+#endif
+};
+
+static void octeon_msi_ip4(void)
+{
+	union cvmx_ciu2_msired_ppx_ip4 msired;
+	int core = cvmx_get_core_num();
+
+	msired.u64 = cvmx_read_csr(CVMX_CIU2_MSIRED_PPX_IP4(core));
+
+	if (msired.s.intr)
+		do_IRQ(msired.s.msi_num + OCTEON_IRQ_MSI_BIT0);
+	else
+		spurious_interrupt();
+}
+
+int __init octeon_msi_68XX_init(void)
+{
+	int i;
+
+	/* Disable legacy handling. */
+	cvmx_write_csr(CVMX_PEXP_SLI_MSI_ENB0, 0);
+	cvmx_write_csr(CVMX_PEXP_SLI_MSI_ENB1, 0);
+	cvmx_write_csr(CVMX_PEXP_SLI_MSI_ENB2, 0);
+	cvmx_write_csr(CVMX_PEXP_SLI_MSI_ENB3, 0);
+
+	/* Disable CIU2_MSI */
+	for (i = 0; i < 256; i++)
+		cvmx_write_csr(CVMX_CIU2_MSI_SELX(i), 0);
+
+	for (i = OCTEON_IRQ_MSI_BIT0; i <= OCTEON_IRQ_MSI_LAST; i++)
+		irq_set_chip_and_handler(i, &octeon_msi_chip_ciu2, handle_edge_irq);
+
+	octeon_irq_set_ip4_handler(octeon_msi_ip4);
+
+	return 0;
+}
+
 /*
  * Initializes the MSI interrupt handling code
  */
@@ -364,7 +489,20 @@ int __init octeon_msi_initialize(void)
 	int irq;
 	struct irq_chip *msi;
 
-	if (octeon_dma_bar_type == OCTEON_DMA_BAR_TYPE_PCIE) {
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX) && !OCTEON_IS_MODEL(OCTEON_CN68XX_PASS1_X))
+		return octeon_msi_68XX_init();
+
+	if (octeon_dma_bar_type == OCTEON_DMA_BAR_TYPE_PCIE2) {
+                msi_rcv_reg[0] = CVMX_PEXP_SLI_MSI_RCV0;
+                msi_rcv_reg[1] = CVMX_PEXP_SLI_MSI_RCV1;
+                msi_rcv_reg[2] = CVMX_PEXP_SLI_MSI_RCV2;
+                msi_rcv_reg[3] = CVMX_PEXP_SLI_MSI_RCV3;
+                mis_ena_reg[0] = CVMX_PEXP_SLI_MSI_ENB0;
+                mis_ena_reg[1] = CVMX_PEXP_SLI_MSI_ENB1;
+                mis_ena_reg[2] = CVMX_PEXP_SLI_MSI_ENB2;
+                mis_ena_reg[3] = CVMX_PEXP_SLI_MSI_ENB3;
+                msi = &octeon_irq_chip_msi_pcie;
+	} else if (octeon_dma_bar_type == OCTEON_DMA_BAR_TYPE_PCIE) {
 		msi_rcv_reg[0] = CVMX_PEXP_NPEI_MSI_RCV0;
 		msi_rcv_reg[1] = CVMX_PEXP_NPEI_MSI_RCV1;
 		msi_rcv_reg[2] = CVMX_PEXP_NPEI_MSI_RCV2;
-- 
1.7.9.7

