From eeaca11f25775c1bb85e129f9b0e38a0136d6be9 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 5 Sep 2012 11:54:39 +0800
Subject: [PATCH 04/27] simpleExec: add cvmx qlm module

Based on SDK 2.3.0-427

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-qlm.c |  266 ++++++++++++++++++++++++++
 arch/mips/include/asm/octeon/cvmx-qlm.h      |   74 +++++++
 2 files changed, 340 insertions(+)
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-qlm.c
 create mode 100644 arch/mips/include/asm/octeon/cvmx-qlm.h

diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
new file mode 100644
index 0000000..fd3f3e7
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -0,0 +1,266 @@
+/***********************license start***************
+ * Copyright (c) 2011  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-bootmem.h>
+#include <asm/octeon/cvmx-helper-jtag.h>
+#include <asm/octeon/cvmx-qlm.h>
+#include <asm/octeon/cvmx-gmxx-defs.h>
+#include <asm/octeon/cvmx-sriox-defs.h>
+#include <asm/octeon/cvmx-sriomaintx-defs.h>
+#include <asm/octeon/cvmx-pciercx-defs.h>
+
+/**
+ * The JTAG chain for CN52XX and CN56XX is 4 * 268 bits long, or 1072.
+ * CN5XXX full chain shift is:
+ *     new data => lane 3 => lane 2 => lane 1 => lane 0 => data out
+ * The JTAG chain for CN63XX is 4 * 300 bits long, or 1200.
+ * The JTAG chain for CN68XX is 4 * 304 bits long, or 1216.
+ * The JTAG chain for CN66XX/CN61XX/CNF71XX is 4 * 304 bits long, or 1216.
+ * CN6XXX full chain shift is:
+ *     new data => lane 0 => lane 1 => lane 2 => lane 3 => data out
+ * Shift LSB first, get LSB out
+ */
+extern const __cvmx_qlm_jtag_field_t __cvmx_qlm_jtag_field_cn52xx[];
+extern const __cvmx_qlm_jtag_field_t __cvmx_qlm_jtag_field_cn56xx[];
+extern const __cvmx_qlm_jtag_field_t __cvmx_qlm_jtag_field_cn63xx[];
+extern const __cvmx_qlm_jtag_field_t __cvmx_qlm_jtag_field_cn66xx[];
+extern const __cvmx_qlm_jtag_field_t __cvmx_qlm_jtag_field_cn68xx[];
+
+#define CVMX_QLM_JTAG_UINT32 40
+
+extern void octeon_remote_read_mem(void *buffer, uint64_t physical_address,
+					int length);
+extern void octeon_remote_write_mem(uint64_t physical_address,
+					const void *buffer, int length);
+uint32_t __cvmx_qlm_jtag_xor_ref[5][CVMX_QLM_JTAG_UINT32];
+
+
+/**
+ * Return the number of QLMs supported by the chip
+ *
+ * @return  Number of QLMs
+ */
+int cvmx_qlm_get_num(void)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		return 5;
+	else if (OCTEON_IS_MODEL(OCTEON_CN66XX))
+		return 3;
+	else if (OCTEON_IS_MODEL(OCTEON_CN63XX))
+		return 3;
+	else if (OCTEON_IS_MODEL(OCTEON_CN61XX))
+		return 3;
+	else if (OCTEON_IS_MODEL(OCTEON_CN56XX))
+		return 4;
+	else if (OCTEON_IS_MODEL(OCTEON_CN52XX))
+		return 2;
+
+	return 0;
+}
+
+/**
+ * Return the qlm number based on the interface
+ *
+ * @param interface  Interface to look up
+ */
+int cvmx_qlm_interface(int interface)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN61XX)) {
+		return (interface == 0) ? 2 : 0;
+	}
+	else if (OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)) {
+		return 2 - interface;
+	}
+	else {
+		/* Must be cn68XX */
+		switch (interface) {
+			case 1:
+				return 0;
+			default:
+				return interface;
+		}
+	}
+}
+
+/**
+ * Return number of lanes for a given qlm
+ *
+ * @return  Number of lanes
+ */
+int cvmx_qlm_get_lanes(int qlm)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN61XX) && qlm == 1)
+		return 2;
+
+	return 4;
+}
+
+/*
+ * Read QLM and return status based on CN66XX.
+ * @return  Return 1 if QLM is SGMII
+ *                 2 if QLM is XAUI
+ *                 3 if QLM is PCIe gen2 / gen1
+ *                 4 if QLM is SRIO 1x4 short / long
+ *                 5 if QLM is SRIO 2x2 short / long
+ *                 6 if QLM is SRIO 4x1 short / long
+ *                 7 if QLM is PCIe 1x2 gen2 / gen1
+ *                 8 if QLM is PCIe 2x1 gen2 / gen1
+ *                 9 if QLM is ILK
+ *                 10 if QLM is RXAUI
+ *                 -1 otherwise
+ */
+int cvmx_qlm_get_status(int qlm)
+{
+	cvmx_mio_qlmx_cfg_t qlmx_cfg;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		qlmx_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(qlm));
+		/* QLM is disabled when QLM SPD is 15. */
+		if (qlmx_cfg.s.qlm_spd == 15)
+			return -1;
+
+		switch (qlmx_cfg.s.qlm_cfg) {
+			case 0:			/* PCIE */
+				return 3;
+			case 1:			/* ILK */
+				return 9;
+			case 2:			/* SGMII */
+				return 1;
+			case 3:			/* XAUI */
+				return 2;
+			case 7:			/* RXAUI */
+				return 10;
+			default:
+				return -1;
+		}
+	}
+	else if (OCTEON_IS_MODEL(OCTEON_CN66XX)) {
+		qlmx_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(qlm));
+		/* QLM is disabled when QLM SPD is 15. */
+		if (qlmx_cfg.s.qlm_spd == 15)
+			return -1;
+
+		switch (qlmx_cfg.s.qlm_cfg) {
+			case 0x9:			/* SGMII */
+				return 1;
+			case 0xb:			/* XAUI */
+				return 2;
+			case 0x0:			/* PCIE gen2 */
+			case 0x8:			/* PCIE gen2 (alias) */
+			case 0x2:			/* PCIE gen1 */
+			case 0xa:			/* PCIE gen1 (alias) */
+				return 3;
+			case 0x1:			/* SRIO 1x4 short */
+			case 0x3:			/* SRIO 1x4 long */
+				return 4;
+			case 0x4:			/* SRIO 2x2 short */
+			case 0x6:			/* SRIO 2x2 long */
+				return 5;
+			case 0x5:			/* SRIO 4x1 short */
+			case 0x7:			/* SRIO 4x1 long */
+				if (!OCTEON_IS_MODEL(OCTEON_CN66XX_PASS1_0))
+					return 6;
+			default:
+				return -1;
+		}
+	}
+	else if (OCTEON_IS_MODEL(OCTEON_CN63XX)) {
+		cvmx_sriox_status_reg_t status_reg;
+		/* For now skip qlm2 */
+		if (qlm == 2) {
+			union cvmx_gmxx_inf_mode inf_mode;
+			inf_mode.u64 = cvmx_read_csr(CVMX_GMXX_INF_MODE(0));
+			if (inf_mode.s.speed == 15)
+				return -1;
+			else if (inf_mode.s.mode == 0)
+				return 1;
+			else
+				return 2;
+		}
+		status_reg.u64 = cvmx_read_csr(CVMX_SRIOX_STATUS_REG(qlm));
+		if (status_reg.s.srio)
+			return 4;
+		else
+			return 3;
+	}
+	else if (OCTEON_IS_MODEL(OCTEON_CN61XX)) {
+		qlmx_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(qlm));
+		/* QLM is disabled when QLM SPD is 15. */
+		if (qlmx_cfg.s.qlm_spd == 15)
+			return -1;
+
+		switch (qlm) {
+			case 0:
+				switch (qlmx_cfg.s.qlm_cfg) {
+					case 0:	/* PCIe 1x4 gen2 / gen1 */
+						return 3;
+					case 2:	/* SGMII */
+						return 1;
+					case 3:	/* XAUI */
+						return 2;
+					default:
+						return -1;
+				}
+				break;
+			case 1:
+				switch (qlmx_cfg.s.qlm_cfg) {
+					case 0:	/* PCIe 1x2 gen2 / gen1 */
+						return 7;
+					case 1:	/* PCIe 2x1 gen2 / gen1 */
+						return 8;
+					default:
+						return -1;
+				}
+				break;
+			case 2:
+				switch (qlmx_cfg.s.qlm_cfg) {
+					case 2:	/* SGMII */
+						return 1;
+					case 3:	/* XAUI */
+						return 2;
+					default:
+						return -1;
+				}
+				break;
+		}
+	}
+	return -1;
+}
diff --git a/arch/mips/include/asm/octeon/cvmx-qlm.h b/arch/mips/include/asm/octeon/cvmx-qlm.h
new file mode 100644
index 0000000..2576c23
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-qlm.h
@@ -0,0 +1,74 @@
+/***********************license start***************
+ * Copyright (c) 2011  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+#ifndef __CVMX_QLM_H__
+#define __CVMX_QLM_H__
+
+#include "cvmx.h"
+
+typedef struct
+{
+    const char *name;
+    int stop_bit;
+    int start_bit;
+} __cvmx_qlm_jtag_field_t;
+
+extern int cvmx_qlm_get_num(void);
+
+extern int cvmx_qlm_interface(int interface);
+
+extern int cvmx_qlm_get_lanes(int qlm);
+
+extern const __cvmx_qlm_jtag_field_t *cvmx_qlm_jtag_get_field(void);
+
+extern int cvmx_qlm_jtag_get_length(void);
+
+extern void cvmx_qlm_init(void);
+
+extern uint64_t cvmx_qlm_jtag_get(int qlm, int lane, const char *name);
+
+extern void cvmx_qlm_jtag_set(int qlm, int lane, const char *name, uint64_t value);
+
+extern void __cvmx_qlm_speed_tweak(void);
+
+extern void __cvmx_qlm_pcie_idle_dac_tweak(void);
+
+extern int cvmx_qlm_get_status(int qlm);
+
+#endif
-- 
1.7.9.7

