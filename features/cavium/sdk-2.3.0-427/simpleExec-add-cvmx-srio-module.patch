From 1dd99baf6764ce328fee026b962856c975bc72f0 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 5 Sep 2012 11:56:13 +0800
Subject: [PATCH 05/27] simpleExec: add cvmx srio module

Based on SDK 2.3.0-427

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-srio.c | 1053 +++++++++++++++++++++++++
 arch/mips/include/asm/octeon/cvmx-srio.h      |  189 +++++
 2 files changed, 1242 insertions(+)
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-srio.c
 create mode 100644 arch/mips/include/asm/octeon/cvmx-srio.h

diff --git a/arch/mips/cavium-octeon/executive/cvmx-srio.c b/arch/mips/cavium-octeon/executive/cvmx-srio.c
new file mode 100644
index 0000000..09da680
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-srio.c
@@ -0,0 +1,1053 @@
+/***********************license start***************
+ * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-srio.h>
+#include <asm/octeon/cvmx-clock.h>
+#include <asm/octeon/cvmx-sriox-defs.h>
+#include <asm/octeon/cvmx-sriomaintx-defs.h>
+#include <asm/octeon/cvmx-sli-defs.h>
+#include <asm/octeon/cvmx-dpi-defs.h>
+#include <asm/octeon/cvmx-pexp-defs.h>
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-qlm.h>
+
+#define CVMX_SRIO_CONFIG_TIMEOUT        10000
+#define CVMX_SRIO_DOORBELL_TIMEOUT      10000
+#define CVMX_SRIO_CONFIG_PRIORITY       0
+#define ULL unsigned long long
+
+typedef union
+{
+	uint64_t u64;
+	struct
+	{
+		uint64_t upper:2;		/* Normally 2 for XKPHYS */
+		uint64_t reserved_49_61:13;	/* Must be zero */
+		uint64_t io:1;			/* 1 for IO space access */
+		uint64_t did:5;			/* DID = 3 */
+		uint64_t subdid:3;		/* SubDID = 3-6 */
+		uint64_t reserved_36_39:4;	/* Must be zero */
+		uint64_t se:2;			/* SubDID extender */
+		uint64_t reserved_32_33:2;	/* Must be zero */
+		uint64_t hopcount:8;	/* Hopcount */
+		uint64_t address:24;	/* Mem address */
+	} config;
+	struct
+	{
+		uint64_t upper:2;		/* Normally 2 for XKPHYS */
+		uint64_t reserved_49_61:13;	/* Must be zero */
+		uint64_t io:1;			/* 1 for IO space access */
+		uint64_t did:5;			/* DID = 3 */
+		uint64_t subdid:3;		/* SubDID = 3-6 */
+		uint64_t reserved_36_39:4;	/* Must be zero */
+		uint64_t se:2;			/* SubDID extender */
+		uint64_t address:34;	/* Mem address */
+	} mem;
+} cvmx_sli_address_t;
+
+typedef struct
+{
+	cvmx_srio_initialize_flags_t flags;
+	int32_t subidx_ref_count[16];
+	int32_t s2m_ref_count[16];
+} __cvmx_srio_state_t;
+
+static CVMX_SHARED __cvmx_srio_state_t __cvmx_srio_state[4];
+
+static int __cvmx_srio_local_read32(int srio_port, uint32_t offset,
+									uint32_t * result)
+{
+	union cvmx_sriox_maint_op maint_op;
+	union cvmx_sriox_maint_rd_data maint_rd_data;
+	maint_op.u64 = 0;
+	maint_op.s.op = 0;			/* Read */
+	maint_op.s.addr = offset;
+
+	if (CVMX_WAIT_FOR_FIELD64
+		(CVMX_SRIOX_MAINT_OP(srio_port), union cvmx_sriox_maint_op, pending, ==,
+		 0, CVMX_SRIO_CONFIG_TIMEOUT)) {
+		cvmx_dprintf("SRIO%d: Pending bit stuck before config read\n",
+					 srio_port);
+		return -1;
+	}
+
+	/* Issue the read to the hardware */
+	cvmx_write_csr(CVMX_SRIOX_MAINT_OP(srio_port), maint_op.u64);
+
+	/* Wait for the hardware to complete the operation */
+	if (CVMX_WAIT_FOR_FIELD64
+		(CVMX_SRIOX_MAINT_OP(srio_port), union cvmx_sriox_maint_op, pending, ==,
+		 0, CVMX_SRIO_CONFIG_TIMEOUT)) {
+		cvmx_dprintf("SRIO%d: Config read timeout\n", srio_port);
+		return -1;
+	}
+
+	/* Display and error and return if the operation failed to issue */
+	maint_op.u64 = cvmx_read_csr(CVMX_SRIOX_MAINT_OP(srio_port));
+	if (maint_op.s.fail) {
+		cvmx_dprintf("SRIO%d: Config read addressing error (offset=0x%x)\n",
+					 srio_port, (unsigned int) offset);
+		return -1;
+	}
+
+	/* Wait for the read data to become valid */
+	if (CVMX_WAIT_FOR_FIELD64
+		(CVMX_SRIOX_MAINT_RD_DATA(srio_port), union cvmx_sriox_maint_rd_data,
+		 valid, ==, 1, CVMX_SRIO_CONFIG_TIMEOUT)) {
+		cvmx_dprintf("SRIO%d: Config read data timeout\n", srio_port);
+		return -1;
+	}
+
+	/* Get the read data */
+	maint_rd_data.u64 = cvmx_read_csr(CVMX_SRIOX_MAINT_RD_DATA(srio_port));
+	*result = maint_rd_data.s.rd_data;
+	return 0;
+}
+
+
+/**
+ * @INTERNAL
+ * Write 32bits to a local port
+ * @param srio_port SRIO port the device is on
+ * @param offset    Offset in config space. This must be a multiple of 32 bits.
+ * @param data      Data to write.
+ *
+ * @return Zero on success, negative on failure.
+ */
+static int __cvmx_srio_local_write32(int srio_port, uint32_t offset,
+					 uint32_t data)
+{
+	union cvmx_sriox_maint_op maint_op;
+	maint_op.u64 = 0;
+	maint_op.s.wr_data = data;
+	maint_op.s.op = 1;			/* Write */
+	maint_op.s.addr = offset;
+
+	/* Make sure SRIO isn't already busy */
+	if (CVMX_WAIT_FOR_FIELD64
+		(CVMX_SRIOX_MAINT_OP(srio_port), union cvmx_sriox_maint_op, pending, ==,
+		 0, CVMX_SRIO_CONFIG_TIMEOUT)) {
+		cvmx_dprintf("SRIO%d: Pending bit stuck before config write\n",
+					 srio_port);
+		return -1;
+	}
+
+	/* Issue the write to the hardware */
+	cvmx_write_csr(CVMX_SRIOX_MAINT_OP(srio_port), maint_op.u64);
+
+	/* Wait for the hardware to complete the operation */
+	if (CVMX_WAIT_FOR_FIELD64
+		(CVMX_SRIOX_MAINT_OP(srio_port), union cvmx_sriox_maint_op, pending, ==,
+		 0, CVMX_SRIO_CONFIG_TIMEOUT)) {
+		cvmx_dprintf("SRIO%d: Config write timeout\n", srio_port);
+		return -1;
+	}
+
+	/* Display and error and return if the operation failed to issue */
+	maint_op.u64 = cvmx_read_csr(CVMX_SRIOX_MAINT_OP(srio_port));
+	if (maint_op.s.fail) {
+		cvmx_dprintf("SRIO%d: Config write addressing error (offset=0x%x)\n",
+					 srio_port, (unsigned int) offset);
+		return -1;
+	}
+	return 0;
+}
+
+
+/**
+ * Reset SRIO to link partner
+ *
+ * @param srio_port  SRIO port to initialize
+ *
+ * @return Zero on success
+ */
+int cvmx_srio_link_rst(int srio_port)
+{
+	cvmx_sriomaintx_port_0_link_resp_t link_resp;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X))
+		return -1;
+
+	/* Generate a symbol reset to the link partner by writing 0x3. */
+	if (cvmx_srio_config_write32(srio_port, 0, -1, 0, 0,
+								 CVMX_SRIOMAINTX_PORT_0_LINK_REQ(srio_port),
+								 3))
+		return -1;
+
+	if (cvmx_srio_config_read32(srio_port, 0, -1, 0, 0,
+								CVMX_SRIOMAINTX_PORT_0_LINK_RESP(srio_port),
+								&link_resp.u32))
+		return -1;
+
+	/* Poll until link partner has received the reset. */
+	while (link_resp.s.valid == 0) {
+		//cvmx_dprintf("Waiting for Link Response\n");
+		if (cvmx_srio_config_read32(srio_port, 0, -1, 0, 0,
+									CVMX_SRIOMAINTX_PORT_0_LINK_RESP
+									(srio_port), &link_resp.u32))
+			return -1;
+	}
+
+	/* Valid response, Asserting MAC reset */
+	cvmx_write_csr(CVMX_CIU_SOFT_PRST, 0x1);
+
+	cvmx_wait(10);
+
+	/* De-asserting MAC Reset */
+	cvmx_write_csr(CVMX_CIU_SOFT_PRST, 0x0);
+
+	return 0;
+}
+
+/**
+ * Initialize a SRIO port for use.
+ *
+ * @param srio_port SRIO port to initialize
+ * @param flags     Optional flags
+ *
+ * @return Zero on success
+ */
+int cvmx_srio_initialize(int srio_port, cvmx_srio_initialize_flags_t flags)
+{
+	cvmx_sriomaintx_port_lt_ctl_t port_lt_ctl;
+	cvmx_sriomaintx_port_rt_ctl_t port_rt_ctl;
+	cvmx_sriomaintx_port_0_ctl_t port_0_ctl;
+	cvmx_sriomaintx_core_enables_t core_enables;
+	cvmx_sriomaintx_port_gen_ctl_t port_gen_ctl;
+	cvmx_sriox_status_reg_t sriox_status_reg;
+	union cvmx_mio_rst_ctlx mio_rst_ctl;
+	union cvmx_sriox_imsg_vport_thr sriox_imsg_vport_thr;
+	union cvmx_dpi_sli_prtx_cfg prt_cfg;
+	union cvmx_sli_s2m_portx_ctl sli_s2m_portx_ctl;
+	union cvmx_sli_mem_access_ctl sli_mem_access_ctl;
+	cvmx_sriomaintx_port_0_ctl2_t port_0_ctl2;
+
+	sriox_status_reg.u64 = cvmx_read_csr(CVMX_SRIOX_STATUS_REG(srio_port));
+	if (OCTEON_IS_MODEL(OCTEON_CN66XX)) {
+		/* All SRIO ports are connected to QLM0 */
+		int status = cvmx_qlm_get_status(0);
+		if (status < 4 || status > 6) {
+			cvmx_dprintf
+				("SRIO%d: Initialization called on a port not in SRIO mode\n",
+				 srio_port);
+			return -1;
+		}
+	}
+	else if (!sriox_status_reg.s.srio) {
+		cvmx_dprintf
+			("SRIO%d: Initialization called on a port not in SRIO mode\n",
+			 srio_port);
+		return -1;
+	}
+
+	__cvmx_srio_state[srio_port].flags = flags;
+
+	/* CN63XX Pass 1.0 errata G-14395 requires the QLM De-emphasis be
+	   programmed */
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_0)) {
+		if (srio_port) {
+			union cvmx_ciu_qlm1 ciu_qlm;
+			ciu_qlm.u64 = cvmx_read_csr(CVMX_CIU_QLM1);
+			ciu_qlm.s.txbypass = 1;
+			ciu_qlm.s.txdeemph = 5;
+			ciu_qlm.s.txmargin = 0x17;
+			cvmx_write_csr(CVMX_CIU_QLM1, ciu_qlm.u64);
+		}
+		else {
+			union cvmx_ciu_qlm0 ciu_qlm;
+			ciu_qlm.u64 = cvmx_read_csr(CVMX_CIU_QLM0);
+			ciu_qlm.s.txbypass = 1;
+			ciu_qlm.s.txdeemph = 5;
+			ciu_qlm.s.txmargin = 0x17;
+			cvmx_write_csr(CVMX_CIU_QLM0, ciu_qlm.u64);
+		}
+	}
+
+	/* Don't receive or drive reset signals for the SRIO QLM */
+	if (OCTEON_IS_MODEL(OCTEON_CN66XX)) {
+		/* The reset signals are available only for srio_port == 0. */
+		if (srio_port == 0
+			|| (OCTEON_IS_MODEL(OCTEON_CN66XX_PASS1_2) && srio_port == 1)) {
+			union cvmx_mio_rst_cntlx mio_rst_cntl;
+			mio_rst_cntl.u64 = cvmx_read_csr(CVMX_MIO_RST_CNTLX(srio_port));
+			mio_rst_cntl.s.rst_drv = 0;
+			mio_rst_cntl.s.rst_rcv = 0;
+			mio_rst_cntl.s.rst_chip = 0;
+			cvmx_write_csr(CVMX_MIO_RST_CNTLX(srio_port), mio_rst_cntl.u64);
+		}
+		/* MIO_RST_CNTL2<prtmode> is initialized to 0 on cold reset */
+		mio_rst_ctl.u64 = cvmx_read_csr(CVMX_MIO_RST_CNTLX(srio_port));
+	}
+	else {
+		mio_rst_ctl.u64 = cvmx_read_csr(CVMX_MIO_RST_CTLX(srio_port));
+		mio_rst_ctl.s.rst_drv = 0;
+		mio_rst_ctl.s.rst_rcv = 0;
+		mio_rst_ctl.s.rst_chip = 0;
+		cvmx_write_csr(CVMX_MIO_RST_CTLX(srio_port), mio_rst_ctl.u64);
+
+		mio_rst_ctl.u64 = cvmx_read_csr(CVMX_MIO_RST_CTLX(srio_port));
+	}
+
+	cvmx_dprintf("SRIO%d: Port in %s mode\n", srio_port,
+				 (mio_rst_ctl.s.prtmode) ? "host" : "endpoint");
+
+	/* Bring the port out of reset if necessary */
+	switch (srio_port) {
+		case 0:
+			{
+				union cvmx_ciu_soft_prst prst;
+				prst.u64 = cvmx_read_csr(CVMX_CIU_SOFT_PRST);
+				if (prst.s.soft_prst) {
+					prst.s.soft_prst = 0;
+					cvmx_write_csr(CVMX_CIU_SOFT_PRST, prst.u64);
+					/* Wait up to 250ms for the port to come out of reset */
+					if (CVMX_WAIT_FOR_FIELD64
+						(CVMX_SRIOX_STATUS_REG(srio_port),
+						 cvmx_sriox_status_reg_t, access, ==, 1, 250000))
+						return -1;
+				}
+				break;
+			}
+		case 1:
+			{
+				union cvmx_ciu_soft_prst1 prst;
+				prst.u64 = cvmx_read_csr(CVMX_CIU_SOFT_PRST1);
+				if (prst.s.soft_prst) {
+					prst.s.soft_prst = 0;
+					cvmx_write_csr(CVMX_CIU_SOFT_PRST1, prst.u64);
+					/* Wait up to 250ms for the port to come out of reset */
+					if (CVMX_WAIT_FOR_FIELD64
+						(CVMX_SRIOX_STATUS_REG(srio_port),
+						 cvmx_sriox_status_reg_t, access, ==, 1, 250000))
+						return -1;
+				}
+				break;
+			}
+		case 2:
+			{
+				union cvmx_ciu_soft_prst2 prst;
+				prst.u64 = cvmx_read_csr(CVMX_CIU_SOFT_PRST2);
+				if (prst.s.soft_prst) {
+					prst.s.soft_prst = 0;
+					cvmx_write_csr(CVMX_CIU_SOFT_PRST2, prst.u64);
+					/* Wait up to 250ms for the port to come out of reset */
+					if (CVMX_WAIT_FOR_FIELD64
+						(CVMX_SRIOX_STATUS_REG(srio_port),
+						 cvmx_sriox_status_reg_t, access, ==, 1, 250000))
+						return -1;
+				}
+				break;
+			}
+	}
+
+	/* Disable the link while we make changes */
+	if (__cvmx_srio_local_read32
+		(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL(srio_port), &port_0_ctl.u32))
+		return -1;
+	port_0_ctl.s.o_enable = 0;
+	port_0_ctl.s.i_enable = 0;
+	port_0_ctl.s.prt_lock = 1;
+	port_0_ctl.s.disable = 0;
+	if (__cvmx_srio_local_write32
+		(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL(srio_port), port_0_ctl.u32))
+		return -1;
+
+	/* CN63XX Pass 2.0 and 2.1 errata G-15273 requires the QLM De-emphasis be
+	   programmed when using a 156.25Mhz ref clock */
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_0) ||
+		OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_1)) {
+		union cvmx_mio_rst_boot mio_rst_boot;
+		union cvmx_sriomaintx_lane_x_status_0 lane_x_status;
+
+		/* Read the QLM config and speed pins */
+		mio_rst_boot.u64 = cvmx_read_csr(CVMX_MIO_RST_BOOT);
+		if (__cvmx_srio_local_read32
+			(srio_port, CVMX_SRIOMAINTX_LANE_X_STATUS_0(0, srio_port),
+			 &lane_x_status.u32))
+			return -1;
+
+		if (srio_port) {
+			union cvmx_ciu_qlm1 ciu_qlm;
+			ciu_qlm.u64 = cvmx_read_csr(CVMX_CIU_QLM1);
+			switch (mio_rst_boot.cn63xx.qlm1_spd) {
+				case 0x4:		/* 1.25 Gbaud, 156.25MHz */
+					ciu_qlm.s.txbypass = 1;
+					ciu_qlm.s.txdeemph = 0x0;
+					ciu_qlm.s.txmargin = (lane_x_status.s.rx_type == 0) ? 0x11 : 0x1c;	/* short or med/long */
+					break;
+				case 0xb:		/* 5.0 Gbaud, 156.25MHz */
+					ciu_qlm.s.txbypass = 1;
+					ciu_qlm.s.txdeemph = (lane_x_status.s.rx_type == 0) ? 0xa : 0xf;	/* short or med/long */
+					ciu_qlm.s.txmargin = (lane_x_status.s.rx_type == 0) ? 0xf : 0x1a;	/* short or med/long */
+					break;
+			}
+			cvmx_write_csr(CVMX_CIU_QLM1, ciu_qlm.u64);
+		}
+		else {
+			union cvmx_ciu_qlm0 ciu_qlm;
+			ciu_qlm.u64 = cvmx_read_csr(CVMX_CIU_QLM0);
+			switch (mio_rst_boot.cn63xx.qlm0_spd) {
+				case 0x4:		/* 1.25 Gbaud, 156.25MHz */
+					ciu_qlm.s.txbypass = 1;
+					ciu_qlm.s.txdeemph = 0x0;
+					ciu_qlm.s.txmargin = (lane_x_status.s.rx_type == 0) ? 0x11 : 0x1c;	/* short or med/long */
+					break;
+				case 0xb:		/* 5.0 Gbaud, 156.25MHz */
+					ciu_qlm.s.txbypass = 1;
+					ciu_qlm.s.txdeemph = (lane_x_status.s.rx_type == 0) ? 0xa : 0xf;	/* short or med/long */
+					ciu_qlm.s.txmargin = (lane_x_status.s.rx_type == 0) ? 0xf : 0x1a;	/* short or med/long */
+					break;
+			}
+			cvmx_write_csr(CVMX_CIU_QLM0, ciu_qlm.u64);
+		}
+	}
+
+	/* Errata SRIO-14485: Link speed is reported incorrectly in CN63XX
+	   pass 1.x */
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X)) {
+		union cvmx_sriomaintx_port_0_ctl2 port_0_ctl2;
+		if (__cvmx_srio_local_read32
+			(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL2(srio_port),
+			 &port_0_ctl2.u32))
+			return -1;
+		if (port_0_ctl2.s.enb_500g) {
+			port_0_ctl2.u32 = 0;
+			port_0_ctl2.s.enb_625g = 1;
+		}
+		else if (port_0_ctl2.s.enb_312g) {
+			port_0_ctl2.u32 = 0;
+			port_0_ctl2.s.enb_500g = 1;
+		}
+		else if (port_0_ctl2.s.enb_250g) {
+			port_0_ctl2.u32 = 0;
+			port_0_ctl2.s.enb_312g = 1;
+		}
+		else if (port_0_ctl2.s.enb_125g) {
+			port_0_ctl2.u32 = 0;
+			port_0_ctl2.s.enb_250g = 1;
+		}
+		else {
+			port_0_ctl2.u32 = 0;
+			port_0_ctl2.s.enb_125g = 1;
+		}
+		if (__cvmx_srio_local_write32
+			(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL2(srio_port),
+			 port_0_ctl2.u32))
+			return -1;
+	}
+
+	/* Errata SRIO-15351: Turn off SRIOMAINTX_MAC_CTRL[TYPE_MRG] as it may
+	   cause packet ACCEPT to be lost */
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_0)
+		|| OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_1)) {
+		union cvmx_sriomaintx_mac_ctrl mac_ctrl;
+		if (__cvmx_srio_local_read32
+			(srio_port, CVMX_SRIOMAINTX_MAC_CTRL(srio_port), &mac_ctrl.u32))
+			return -1;
+		mac_ctrl.s.type_mrg = 0;
+		if (__cvmx_srio_local_write32
+			(srio_port, CVMX_SRIOMAINTX_MAC_CTRL(srio_port), mac_ctrl.u32))
+			return -1;
+	}
+
+	/* Set the link layer timeout to 1ms. The default is too high and causes
+	   core bus errors */
+	if (__cvmx_srio_local_read32
+		(srio_port, CVMX_SRIOMAINTX_PORT_LT_CTL(srio_port), &port_lt_ctl.u32))
+		return -1;
+	port_lt_ctl.s.timeout = 1000000 / 200;	/* 1ms = 1000000ns / 200ns */
+	if (__cvmx_srio_local_write32
+		(srio_port, CVMX_SRIOMAINTX_PORT_LT_CTL(srio_port), port_lt_ctl.u32))
+		return -1;
+
+	/* Set the logical layer timeout to 100ms. The default is too high and causes
+	   core bus errors */
+	if (__cvmx_srio_local_read32
+		(srio_port, CVMX_SRIOMAINTX_PORT_RT_CTL(srio_port), &port_rt_ctl.u32))
+		return -1;
+	port_rt_ctl.s.timeout = 100000000 / 200;	/* 100ms = 100000000ns / 200ns */
+	if (__cvmx_srio_local_write32
+		(srio_port, CVMX_SRIOMAINTX_PORT_RT_CTL(srio_port), port_rt_ctl.u32))
+		return -1;
+
+	/* Allow memory and doorbells. Messaging is enabled later */
+	if (__cvmx_srio_local_read32
+		(srio_port, CVMX_SRIOMAINTX_CORE_ENABLES(srio_port),
+		 &core_enables.u32))
+		return -1;
+	core_enables.s.doorbell = 1;
+	core_enables.s.memory = 1;
+	if (__cvmx_srio_local_write32
+		(srio_port, CVMX_SRIOMAINTX_CORE_ENABLES(srio_port),
+		 core_enables.u32))
+		return -1;
+
+	/* Allow us to master transactions */
+	if (__cvmx_srio_local_read32
+		(srio_port, CVMX_SRIOMAINTX_PORT_GEN_CTL(srio_port),
+		 &port_gen_ctl.u32))
+		return -1;
+	port_gen_ctl.s.menable = 1;
+	if (__cvmx_srio_local_write32
+		(srio_port, CVMX_SRIOMAINTX_PORT_GEN_CTL(srio_port),
+		 port_gen_ctl.u32))
+		return -1;
+
+	/* Set the MRRS and MPS for optimal SRIO performance */
+	prt_cfg.u64 = cvmx_read_csr(CVMX_DPI_SLI_PRTX_CFG(srio_port));
+	prt_cfg.s.mps = 1;
+	prt_cfg.s.mrrs = 1;
+	prt_cfg.s.molr = 32;
+	if (OCTEON_IS_MODEL(OCTEON_CN66XX))
+		prt_cfg.s.molr =
+			((prt_cfg.s.qlm_cfg == 1
+			  || prt_cfg.s.qlm_cfg == 3) ? 8 : (prt_cfg.s.qlm_cfg == 4
+												|| prt_cfg.s.qlm_cfg ==
+												6) ? 16 : 32);
+	cvmx_write_csr(CVMX_DPI_SLI_PRTX_CFG(srio_port), prt_cfg.u64);
+
+	sli_s2m_portx_ctl.u64 =
+		cvmx_read_csr(CVMX_PEXP_SLI_S2M_PORTX_CTL(srio_port));
+	sli_s2m_portx_ctl.s.mrrs = 1;
+	cvmx_write_csr(CVMX_PEXP_SLI_S2M_PORTX_CTL(srio_port),
+				   sli_s2m_portx_ctl.u64);
+
+	/* Setup RX messaging thresholds */
+	sriox_imsg_vport_thr.u64 =
+		cvmx_read_csr(CVMX_SRIOX_IMSG_VPORT_THR(srio_port));
+	if (OCTEON_IS_MODEL(OCTEON_CN66XX))
+		sriox_imsg_vport_thr.s.max_tot =
+			((prt_cfg.s.qlm_cfg == 1 || prt_cfg.s.qlm_cfg == 3) ? 44 : 46);
+	else
+		sriox_imsg_vport_thr.s.max_tot = 48;
+	sriox_imsg_vport_thr.s.max_s1 = 24;
+	sriox_imsg_vport_thr.s.max_s0 = 24;
+	sriox_imsg_vport_thr.s.sp_vport = 1;
+	sriox_imsg_vport_thr.s.buf_thr = 4;
+	sriox_imsg_vport_thr.s.max_p1 = 12;
+	sriox_imsg_vport_thr.s.max_p0 = 12;
+	cvmx_write_csr(CVMX_SRIOX_IMSG_VPORT_THR(srio_port),
+				   sriox_imsg_vport_thr.u64);
+
+	/* Setup RX messaging thresholds for other virtual ports. */
+	if (OCTEON_IS_MODEL(OCTEON_CN66XX)) {
+		union cvmx_sriox_imsg_vport_thr2 sriox_imsg_vport_thr2;
+		sriox_imsg_vport_thr2.u64 =
+			cvmx_read_csr(CVMX_SRIOX_IMSG_VPORT_THR2(srio_port));
+		sriox_imsg_vport_thr2.s.max_s2 = 24;
+		sriox_imsg_vport_thr2.s.max_s3 = 24;
+		cvmx_write_csr(CVMX_SRIOX_IMSG_VPORT_THR2(srio_port),
+					   sriox_imsg_vport_thr2.u64);
+	}
+
+	/* Errata SRIO-X: SRIO error behavior may not be optimal in CN63XX pass 1.x */
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X)) {
+		union cvmx_sriox_tx_ctrl sriox_tx_ctrl;
+		sriox_tx_ctrl.u64 = cvmx_read_csr(CVMX_SRIOX_TX_CTRL(srio_port));
+		sriox_tx_ctrl.s.tag_th2 = 2;
+		sriox_tx_ctrl.s.tag_th1 = 3;
+		sriox_tx_ctrl.s.tag_th0 = 4;
+		cvmx_write_csr(CVMX_SRIOX_TX_CTRL(srio_port), sriox_tx_ctrl.u64);
+	}
+
+	/* Errata SLI-15954: SLI relaxed order issues */
+	if (OCTEON_IS_MODEL(OCTEON_CN66XX_PASS1_X)) {
+		union cvmx_sli_ctl_portx sli_ctl_portx;
+		sli_ctl_portx.u64 = cvmx_read_csr(CVMX_PEXP_SLI_CTL_PORTX(srio_port));
+		sli_ctl_portx.s.ptlp_ro = 1;	/* Set to same value for all MACs. */
+		sli_ctl_portx.s.ctlp_ro = 1;	/* Set to same value for all MACs. */
+		sli_ctl_portx.s.wait_com = 0;	/* So that no inbound stores wait for a commit */
+		sli_ctl_portx.s.waitl_com = 0;
+		cvmx_write_csr(CVMX_PEXP_SLI_CTL_PORTX(srio_port), sli_ctl_portx.u64);
+	}
+
+	if (!OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X)) {
+		/* Clear the ACK state */
+		if (__cvmx_srio_local_write32
+			(srio_port, CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID(srio_port), 0))
+			return -1;
+	}
+
+	/* Bring the link down, then up, by writing to the SRIO port's
+	   PORT_0_CTL2 CSR. */
+	if (__cvmx_srio_local_read32
+		(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL2(srio_port), &port_0_ctl2.u32))
+		return -1;
+	if (__cvmx_srio_local_write32
+		(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL2(srio_port), port_0_ctl2.u32))
+		return -1;
+
+	/* Clear any pending interrupts */
+	cvmx_write_csr(CVMX_SRIOX_INT_REG(srio_port),
+				   cvmx_read_csr(CVMX_SRIOX_INT_REG(srio_port)));
+
+	/* Finally enable the link */
+	if (__cvmx_srio_local_read32
+		(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL(srio_port), &port_0_ctl.u32))
+		return -1;
+	port_0_ctl.s.o_enable = 1;
+	port_0_ctl.s.i_enable = 1;
+	port_0_ctl.s.disable = 0;
+	port_0_ctl.s.prt_lock = 0;
+	if (__cvmx_srio_local_write32
+		(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL(srio_port), port_0_ctl.u32))
+		return -1;
+
+	/* Store merge control (SLI_MEM_ACCESS_CTL[TIMER,MAX_WORD]) */
+	sli_mem_access_ctl.u64 = cvmx_read_csr(CVMX_PEXP_SLI_MEM_ACCESS_CTL);
+	sli_mem_access_ctl.s.max_word = 0;	/* Allow 16 words to combine */
+	sli_mem_access_ctl.s.timer = 127;	/* Wait up to 127 cycles for more data */
+	cvmx_write_csr(CVMX_PEXP_SLI_MEM_ACCESS_CTL, sli_mem_access_ctl.u64);
+
+	return 0;
+}
+
+/**
+ * Receive a packet from the Soft Packet FIFO (SPF).
+ *
+ * @param srio_port SRIO port to read the packet from.
+ * @param buffer    Buffer to receive the packet.
+ * @param buffer_length
+ *                  Length of the buffer in bytes.
+ *
+ * @return Returns the length of the packet read. Negative on failure.
+ *         Zero if no packets are available.
+ */
+int cvmx_srio_receive_spf(int srio_port, void *buffer, int buffer_length)
+{
+	uint32_t *ptr = (uint32_t *) buffer;
+	cvmx_sriomaintx_ir_sp_rx_stat_t sriomaintx_ir_sp_rx_stat;
+
+	/* Read the SFP status */
+	if (__cvmx_srio_local_read32
+		(srio_port, CVMX_SRIOMAINTX_IR_SP_RX_STAT(srio_port),
+		 &sriomaintx_ir_sp_rx_stat.u32))
+		return -1;
+
+	/* Return zero if there isn't a packet available */
+	if (sriomaintx_ir_sp_rx_stat.s.buffers < 1)
+		return 0;
+
+	if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+		cvmx_dprintf("SRIO%d: Soft packet FIFO received %d bytes", srio_port,
+					 sriomaintx_ir_sp_rx_stat.s.octets);
+
+	/* Return error if the packet is larger than our buffer */
+	if (sriomaintx_ir_sp_rx_stat.s.octets > buffer_length)
+		return -1;
+
+	/* Read out the packet four bytes at a time */
+	buffer_length = sriomaintx_ir_sp_rx_stat.s.octets;
+	while (buffer_length > 0) {
+		__cvmx_srio_local_read32(srio_port,
+								 CVMX_SRIOMAINTX_IR_SP_RX_DATA(srio_port),
+								 ptr);
+		if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+			cvmx_dprintf(" %08x", (unsigned int) *ptr);
+		ptr++;
+		buffer_length -= 4;
+	}
+
+	if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+		cvmx_dprintf("\n");
+
+	/* Return the number of bytes in the buffer */
+	return sriomaintx_ir_sp_rx_stat.s.octets;
+}
+
+/**
+ * Read 32bits from a Device's config space
+ *
+ * @param srio_port SRIO port the device is on
+ * @param srcid_index
+ *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary
+ * @param destid    RapidIO device ID, or -1 for the local Octeon.
+ * @param is16bit   Non zero if the transactions should use 16bit device IDs. Zero
+ *                  if transactions should use 8bit device IDs.
+ * @param hopcount  Number of hops to the remote device. Use 0 for the local Octeon.
+ * @param offset    Offset in config space. This must be a multiple of 32 bits.
+ * @param result    Result of the read. This will be unmodified on failure.
+ *
+ * @return Zero on success, negative on failure.
+ */
+int cvmx_srio_config_read32(int srio_port, int srcid_index, int destid,
+				int is16bit, uint8_t hopcount, uint32_t offset,
+				uint32_t * result)
+{
+	if (destid == -1) {
+		int status = __cvmx_srio_local_read32(srio_port, offset, result);
+
+		if ((status == 0)
+			&& (__cvmx_srio_state[srio_port].
+				flags & CVMX_SRIO_INITIALIZE_DEBUG))
+			cvmx_dprintf("SRIO%d: Local read [0x%06x] <= 0x%08x\n", srio_port,
+						 (unsigned int) offset, (unsigned int) *result);
+
+		return status;
+	}
+	else {
+		if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X)) {
+			int return_code;
+			uint32_t pkt = 0;
+			uint32_t sourceid;
+			uint64_t stop_cycle;
+			char rx_buffer[64];
+
+			/* Tell the user */
+			if (__cvmx_srio_state[srio_port].
+				flags & CVMX_SRIO_INITIALIZE_DEBUG)
+				cvmx_dprintf
+					("SRIO%d: Remote read [id=0x%04x hop=%3d offset=0x%06x] <= ",
+					 srio_port, destid, hopcount, (unsigned int) offset);
+
+			/* Read the proper source ID */
+			if (srcid_index)
+				__cvmx_srio_local_read32(srio_port,
+										 CVMX_SRIOMAINTX_SEC_DEV_ID
+										 (srio_port), &sourceid);
+			else
+				__cvmx_srio_local_read32(srio_port,
+										 CVMX_SRIOMAINTX_PRI_DEV_ID
+										 (srio_port), &sourceid);
+
+			if (is16bit) {
+				/* Use the 16bit source ID */
+				sourceid &= 0xffff;
+
+				/* MAINT Reads are 11 bytes */
+				__cvmx_srio_local_write32(srio_port,
+										  CVMX_SRIOMAINTX_IR_SP_TX_CTRL
+										  (srio_port), 11 << 16);
+
+				pkt |= CVMX_SRIO_CONFIG_PRIORITY << 30;	/* priority [31:30] */
+				pkt |= 1 << 28;	/* tt       [29:28] */
+				pkt |= 0x8 << 24;	/* ftype    [27:24] */
+				pkt |= destid << 8;	/* destID   [23:8] */
+				pkt |= sourceid >> 8;	/* sourceID [7:0] */
+				__cvmx_srio_local_write32(srio_port,
+										  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+										  (srio_port), pkt);
+				pkt = 0;
+				pkt |= sourceid << 24;	/* sourceID [31:24] */
+				pkt |= 0 << 20;	/* transaction [23:20] */
+				pkt |= 8 << 16;	/* rdsize [19:16] */
+				pkt |= 0xc0 << 8;	/* srcTID [15:8] */
+				pkt |= hopcount;	/* hopcount [7:0] */
+				__cvmx_srio_local_write32(srio_port,
+										  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+										  (srio_port), pkt);
+				pkt = 0;
+				pkt |= offset << 8;	/* offset [31:11, wdptr[10], reserved[9:8] */
+				__cvmx_srio_local_write32(srio_port,
+										  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+										  (srio_port), pkt);
+			}
+			else {
+				/* Use the 8bit source ID */
+				sourceid = (sourceid >> 16) & 0xff;
+
+				/* MAINT Reads are 9 bytes */
+				__cvmx_srio_local_write32(srio_port,
+										  CVMX_SRIOMAINTX_IR_SP_TX_CTRL
+										  (srio_port), 9 << 16);
+
+				pkt |= CVMX_SRIO_CONFIG_PRIORITY << 30;	/* priority [31:30] */
+				pkt |= 0 << 28;	/* tt       [29:28] */
+				pkt |= 0x8 << 24;	/* ftype    [27:24] */
+				pkt |= destid << 16;	/* destID   [23:16] */
+				pkt |= sourceid << 8;	/* sourceID [15:8] */
+				pkt |= 0 << 4;	/* transaction [7:4] */
+				pkt |= 8 << 0;	/* rdsize [3:0] */
+				__cvmx_srio_local_write32(srio_port,
+										  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+										  (srio_port), pkt);
+				pkt = 0;
+				pkt |= 0xc0 << 24;	/* srcTID [31:24] */
+				pkt |= hopcount << 16;	/* hopcount [23:16] */
+				pkt |= offset >> 8;	/* offset [15:0] */
+				__cvmx_srio_local_write32(srio_port,
+										  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+										  (srio_port), pkt);
+				pkt = 0;
+				pkt |= offset << 24;	/* offset [31:27, wdptr[26], reserved[25:24] */
+				__cvmx_srio_local_write32(srio_port,
+										  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+										  (srio_port), pkt);
+			}
+
+			stop_cycle =
+				cvmx_clock_get_rate(CVMX_CLOCK_CORE) / 10 +
+				cvmx_clock_get_count(CVMX_CLOCK_CORE);
+			do {
+				return_code =
+					cvmx_srio_receive_spf(srio_port, rx_buffer,
+										  sizeof(rx_buffer));
+				if ((return_code == 0)
+					&& (cvmx_clock_get_count(CVMX_CLOCK_CORE) > stop_cycle)) {
+					if (__cvmx_srio_state[srio_port].
+						flags & CVMX_SRIO_INITIALIZE_DEBUG)
+						cvmx_dprintf("timeout\n");
+					return_code = -1;
+				}
+			} while (return_code == 0);
+
+			if (return_code == ((is16bit) ? 23 : 19)) {
+				if (is16bit) {
+					if (offset & 4)
+						*result = *(uint32_t *) (rx_buffer + 15);
+					else
+						*result = *(uint32_t *) (rx_buffer + 11);
+				}
+				else {
+					if (offset & 4)
+						*result = *(uint32_t *) (rx_buffer + 13);
+					else
+						*result = *(uint32_t *) (rx_buffer + 9);
+				}
+				if (__cvmx_srio_state[srio_port].
+					flags & CVMX_SRIO_INITIALIZE_DEBUG)
+					cvmx_dprintf("0x%08x\n", (unsigned int) *result);
+				return_code = 0;
+			}
+			else {
+				*result = 0xffffffff;
+				return_code = -1;
+			}
+
+			return return_code;
+		}
+		else {
+			return -1;
+		}
+	}
+}
+
+
+/**
+ * Write 32bits to a Device's config space
+ *
+ * @param srio_port SRIO port the device is on
+ * @param srcid_index
+ *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary
+ * @param destid    RapidIO device ID, or -1 for the local Octeon.
+ * @param is16bit   Non zero if the transactions should use 16bit device IDs. Zero
+ *                  if transactions should use 8bit device IDs.
+ * @param hopcount  Number of hops to the remote device. Use 0 for the local Octeon.
+ * @param offset    Offset in config space. This must be a multiple of 32 bits.
+ * @param data      Data to write.
+ *
+ * @return Zero on success, negative on failure.
+ */
+int cvmx_srio_config_write32(int srio_port, int srcid_index, int destid,
+							 int is16bit, uint8_t hopcount, uint32_t offset,
+							 uint32_t data)
+{
+	if (destid == -1) {
+		if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+			cvmx_dprintf("SRIO%d: Local write[0x%06x] => 0x%08x\n", srio_port,
+						 (unsigned int) offset, (unsigned int) data);
+
+		return __cvmx_srio_local_write32(srio_port, offset, data);
+	}
+	else {
+		if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X)) {
+			int return_code;
+			uint32_t pkt = 0;
+			uint32_t sourceid;
+			uint64_t stop_cycle;
+			char rx_buffer[64];
+
+			/* Tell the user */
+			if (__cvmx_srio_state[srio_port].
+				flags & CVMX_SRIO_INITIALIZE_DEBUG)
+				cvmx_dprintf
+					("SRIO%d: Remote write[id=0x%04x hop=%3d offset=0x%06x] => 0x%08x\n",
+					 srio_port, destid, hopcount, (unsigned int) offset,
+					 (unsigned int) data);
+
+			/* Read the proper source ID */
+			if (srcid_index)
+				__cvmx_srio_local_read32(srio_port,
+										 CVMX_SRIOMAINTX_SEC_DEV_ID
+										 (srio_port), &sourceid);
+			else
+				__cvmx_srio_local_read32(srio_port,
+										 CVMX_SRIOMAINTX_PRI_DEV_ID
+										 (srio_port), &sourceid);
+
+			if (is16bit) {
+				/* Use the 16bit source ID */
+				sourceid &= 0xffff;
+
+				/* MAINT Writes are 19 bytes */
+				__cvmx_srio_local_write32(srio_port,
+										  CVMX_SRIOMAINTX_IR_SP_TX_CTRL
+										  (srio_port), 19 << 16);
+
+				pkt |= CVMX_SRIO_CONFIG_PRIORITY << 30;	/* priority [31:30] */
+				pkt |= 1 << 28;	/* tt       [29:28] */
+				pkt |= 0x8 << 24;	/* ftype    [27:24] */
+				pkt |= destid << 8;	/* destID   [23:8] */
+				pkt |= sourceid >> 8;	/* sourceID [7:0] */
+				__cvmx_srio_local_write32(srio_port,
+										  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+										  (srio_port), pkt);
+				pkt = 0;
+				pkt |= sourceid << 24;	/* sourceID [31:24] */
+				pkt |= 1 << 20;	/* transaction [23:20] */
+				pkt |= 8 << 16;	/* wrsize [19:16] */
+				pkt |= 0xc0 << 8;	/* srcTID [15:8] */
+				pkt |= hopcount;	/* hopcount [7:0] */
+				__cvmx_srio_local_write32(srio_port,
+										  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+										  (srio_port), pkt);
+				pkt = 0;
+				pkt |= offset << 8;	/* offset [31:11, wdptr[10], reserved[9:8] */
+				if ((offset & 4) == 0)
+					pkt |= 0xff & (data >> 24);	/* data [7:0] */
+				__cvmx_srio_local_write32(srio_port,
+										  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+										  (srio_port), pkt);
+				if (offset & 4) {
+					pkt = 0xff & (data >> 24);
+					__cvmx_srio_local_write32(srio_port,
+											  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+											  (srio_port), pkt);
+					pkt = data << 8;
+					__cvmx_srio_local_write32(srio_port,
+											  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+											  (srio_port), pkt);
+				}
+				else {
+					pkt = data << 8;
+					__cvmx_srio_local_write32(srio_port,
+											  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+											  (srio_port), pkt);
+					__cvmx_srio_local_write32(srio_port,
+											  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+											  (srio_port), 0);
+				}
+			}
+			else {
+				/* Use the 8bit source ID */
+				sourceid = (sourceid >> 16) & 0xff;
+
+				/* MAINT Writes are 17 bytes */
+				__cvmx_srio_local_write32(srio_port,
+										  CVMX_SRIOMAINTX_IR_SP_TX_CTRL
+										  (srio_port), 17 << 16);
+
+				pkt |= CVMX_SRIO_CONFIG_PRIORITY << 30;	/* priority [31:30] */
+				pkt |= 0 << 28;	/* tt       [29:28] */
+				pkt |= 0x8 << 24;	/* ftype    [27:24] */
+				pkt |= destid << 16;	/* destID   [23:16] */
+				pkt |= sourceid << 8;	/* sourceID [15:8] */
+				pkt |= 1 << 4;	/* transaction [7:4] */
+				pkt |= 8 << 0;	/* wrsize [3:0] */
+				__cvmx_srio_local_write32(srio_port,
+										  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+										  (srio_port), pkt);
+				pkt = 0;
+				pkt |= 0xc0 << 24;	/* srcTID [31:24] */
+				pkt |= hopcount << 16;	/* hopcount [23:16] */
+				pkt |= offset >> 8;	/* offset [15:0] */
+				__cvmx_srio_local_write32(srio_port,
+										  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+										  (srio_port), pkt);
+				pkt = 0;
+				pkt |= offset << 24;	/* offset [31:27, wdptr[26], reserved[25:24] */
+				if (offset & 4) {
+					__cvmx_srio_local_write32(srio_port,
+											  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+											  (srio_port), pkt);
+					pkt = data >> 8;
+					__cvmx_srio_local_write32(srio_port,
+											  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+											  (srio_port), pkt);
+					pkt = data << 24;
+					__cvmx_srio_local_write32(srio_port,
+											  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+											  (srio_port), pkt);
+				}
+				else {
+					pkt |= data >> 8;	/* data [23:0] */
+					__cvmx_srio_local_write32(srio_port,
+											  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+											  (srio_port), pkt);
+					pkt = data << 24;	/* data [31:24] */
+					__cvmx_srio_local_write32(srio_port,
+											  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+											  (srio_port), pkt);
+					__cvmx_srio_local_write32(srio_port,
+											  CVMX_SRIOMAINTX_IR_SP_TX_DATA
+											  (srio_port), 0);
+				}
+			}
+
+			stop_cycle =
+				cvmx_clock_get_rate(CVMX_CLOCK_CORE) / 10 +
+				cvmx_clock_get_count(CVMX_CLOCK_CORE);
+			do {
+				return_code =
+					cvmx_srio_receive_spf(srio_port, rx_buffer,
+										  sizeof(rx_buffer));
+				if ((return_code == 0)
+					&& (cvmx_clock_get_count(CVMX_CLOCK_CORE) > stop_cycle)) {
+					if (__cvmx_srio_state[srio_port].
+						flags & CVMX_SRIO_INITIALIZE_DEBUG)
+						cvmx_dprintf("timeout\n");
+					return_code = -1;
+				}
+			} while (return_code == 0);
+
+			if (return_code == ((is16bit) ? 15 : 11))
+				return_code = 0;
+			else {
+				cvmx_dprintf("SRIO%d: Remote write failed\n", srio_port);
+				return_code = -1;
+			}
+
+			return return_code;
+		}
+		else {
+			return -1;
+		}
+	}
+}
diff --git a/arch/mips/include/asm/octeon/cvmx-srio.h b/arch/mips/include/asm/octeon/cvmx-srio.h
new file mode 100644
index 0000000..1a70d54
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-srio.h
@@ -0,0 +1,189 @@
+/***********************license start***************
+ * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+#ifndef __CVMX_SRIO_H__
+#define __CVMX_SRIO_H__
+
+typedef enum
+{
+	CVMX_SRIO_WRITE_MODE_NWRITE = 0,
+	CVMX_SRIO_WRITE_MODE_NWRITE_RESP = 1,
+
+	CVMX_SRIO_WRITE_MODE_AUTO = 2,
+	CVMX_SRIO_WRITE_MODE_AUTO_RESP = 3,
+	CVMX_SRIO_WRITE_MODE_MAINTENANCE = 6,
+
+	CVMX_SRIO_WRITE_MODE_PORT = 7
+} cvmx_srio_write_mode_t;
+
+typedef enum
+{
+	CVMX_SRIO_READ_MODE_NORMAL = 0,
+	CVMX_SRIO_READ_MODE_ATOMIC_SET = 2,
+	CVMX_SRIO_READ_MODE_ATOMIC_CLEAR = 3,
+
+	CVMX_SRIO_READ_MODE_ATOMIC_INCREMENT = 4,
+
+	CVMX_SRIO_READ_MODE_ATOMIC_DECREMENT = 5,
+
+	CVMX_SRIO_READ_MODE_MAINTENANCE = 6
+} cvmx_srio_read_mode_t;
+
+typedef enum
+{
+	CVMX_SRIO_INITIALIZE_DEBUG = 1,
+} cvmx_srio_initialize_flags_t;
+
+typedef enum
+{
+	CVMX_SRIO_DOORBELL_DONE,
+	CVMX_SRIO_DOORBELL_NONE,
+	CVMX_SRIO_DOORBELL_BUSY,
+	CVMX_SRIO_DOORBELL_RETRY,
+
+	CVMX_SRIO_DOORBELL_ERROR,
+
+	CVMX_SRIO_DOORBELL_TMOUT
+} cvmx_srio_doorbell_status_t;
+
+typedef struct
+{
+	union
+	{
+		uint64_t u64;
+		struct
+		{
+			uint64_t prio:2;
+			uint64_t tt:1;
+			uint64_t dis:1;
+			uint64_t ssize:4;
+			uint64_t sid:16;
+			uint64_t xmbox:4;
+			uint64_t mbox:2;
+			uint64_t letter:2;
+			uint64_t seq:32;
+		} s;
+	} word0;
+	union
+	{
+		uint64_t u64;
+		struct
+		{
+			uint64_t r:1;
+			uint64_t reserved_62_58:5;
+			uint64_t pm:2;
+			uint64_t reserved_55:1;
+			uint64_t sl:7;
+			uint64_t reserved_47_46:2;
+			uint64_t nqos:1;
+			uint64_t ngrp:1;
+			uint64_t ntt:1;
+			uint64_t ntag:1;
+			uint64_t qos:3;
+			uint64_t grp:4;
+			uint64_t rs:1;
+			uint64_t tt:2;
+			uint64_t tag:32;
+		} s;
+	} word1;
+} cvmx_srio_rx_message_header_t;
+
+typedef union
+{
+	uint64_t u64;
+	struct
+	{
+		uint64_t prio:2;
+		uint64_t tt:1;
+		uint64_t sis:1;
+		uint64_t ssize:4;
+		uint64_t did:16;
+		uint64_t xmbox:4;
+		uint64_t mbox:2;
+		uint64_t letter:2;
+		uint64_t reserved_31_2:30;
+		uint64_t lns:1;
+		uint64_t intr:1;
+	} s;
+} cvmx_srio_tx_message_header_t;
+
+int cvmx_srio_link_rst(int srio_port);
+
+int cvmx_srio_initialize(int srio_port, cvmx_srio_initialize_flags_t flags);
+
+int cvmx_srio_config_read32(int srio_port, int srcid_index, int destid,
+				int is16bit, uint8_t hopcount,
+				uint32_t offset, uint32_t * result);
+
+int cvmx_srio_config_write32(int srio_port, int srcid_index, int destid,
+				 int is16bit, uint8_t hopcount,
+				 uint32_t offset, uint32_t data);
+
+int cvmx_srio_send_doorbell(int srio_port, int srcid_index, int destid,
+				int is16bit, int priority, uint16_t data);
+
+cvmx_srio_doorbell_status_t cvmx_srio_send_doorbell_status(int srio_port);
+
+cvmx_srio_doorbell_status_t cvmx_srio_receive_doorbell(int srio_port,
+						   int *destid_index,
+						   uint32_t *
+						   sequence_num,
+						   int *srcid,
+						   int *priority,
+						   int *is16bit,
+						   uint16_t * data);
+
+int cvmx_srio_receive_spf(int srio_port, void *buffer, int buffer_length);
+
+uint64_t cvmx_srio_physical_map(int srio_port,
+				cvmx_srio_write_mode_t write_op,
+				int write_priority,
+				cvmx_srio_read_mode_t read_op,
+				int read_priority, int srcid_index,
+				int destid, int is16bit, uint64_t base,
+				uint64_t size);
+
+int cvmx_srio_physical_unmap(uint64_t physical_address, uint64_t size);
+
+#ifdef CVMX_ENABLE_PKO_FUNCTIONS
+int cvmx_srio_omsg_desc(uint64_t port, union cvmx_buf_ptr * buf_ptr,
+			cvmx_srio_tx_message_header_t * desc_ptr);
+#endif
+
+#endif
-- 
1.7.9.7

