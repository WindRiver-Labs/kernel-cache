From 456e4cdaa684d7f1d4af5b7fa8b4c9648d60505a Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 5 Sep 2012 12:03:49 +0800
Subject: [PATCH 08/27] simpleExec: add the cn63xx and cn68xx support

Based on SDK 2.3.0-427

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/executive/Makefile         |    5 +-
 .../cavium-octeon/executive/cvmx-helper-board.c    | 1083 +++++++++++---------
 .../cavium-octeon/executive/cvmx-helper-loop.c     |    3 +
 .../mips/cavium-octeon/executive/cvmx-helper-npi.c |   79 +-
 .../cavium-octeon/executive/cvmx-helper-rgmii.c    |    4 +
 .../cavium-octeon/executive/cvmx-helper-sgmii.c    |    4 +
 .../mips/cavium-octeon/executive/cvmx-helper-spi.c |    4 +
 .../cavium-octeon/executive/cvmx-helper-util.c     |  244 ++++-
 .../cavium-octeon/executive/cvmx-helper-xaui.c     |    4 +
 arch/mips/cavium-octeon/executive/cvmx-helper.c    |  373 ++++++-
 arch/mips/cavium-octeon/executive/cvmx-pko.c       |  514 +++++++++-
 11 files changed, 1690 insertions(+), 627 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/Makefile b/arch/mips/cavium-octeon/executive/Makefile
index b6d6e84..fcfdf41 100644
--- a/arch/mips/cavium-octeon/executive/Makefile
+++ b/arch/mips/cavium-octeon/executive/Makefile
@@ -10,10 +10,11 @@
 #
 
 obj-y += cvmx-bootmem.o cvmx-l2c.o cvmx-sysinfo.o octeon-model.o
-obj-y += cvmx-pko.o cvmx-spi.o cvmx-cmd-queue.o \
+obj-y += cvmx-pko.o cvmx-qlm.o cvmx-clock.o cvmx-spi.o cvmx-cmd-queue.o \
 	cvmx-helper-board.o cvmx-helper.o cvmx-helper-xaui.o \
 	cvmx-helper-rgmii.o cvmx-helper-sgmii.o cvmx-helper-npi.o \
 	cvmx-helper-loop.o cvmx-helper-spi.o cvmx-helper-util.o \
-	cvmx-interrupt-decodes.o cvmx-interrupt-rsl.o
+	cvmx-helper-srio.o cvmx-srio.o	\
+	cvmx-interrupt-decodes.o cvmx-interrupt-rsl.o cvmx-helper-cfg.o
 
 obj-y += cvmx-helper-errata.o cvmx-helper-jtag.o
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
index fd20153..3d29407 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
@@ -1,60 +1,54 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Copyright (c) 2003-2011  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
  *
- * Contact: support@caviumnetworks.com
- * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
  *
- * This file is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License, Version 2, as
- * published by the Free Software Foundation.
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
  *
- * This file is distributed in the hope that it will be useful, but
- * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
- * NONINFRINGEMENT.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this file; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
- * or visit http://www.gnu.org/licenses/.
- *
- * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
- ***********************license end**************************************/
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
 
-/*
- *
- * Helper functions to abstract board specific data about
- * network ports from the rest of the cvmx-helper files.
- */
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
 
-#include <asm/octeon/octeon.h>
-#include <asm/octeon/cvmx-bootinfo.h>
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
 
-#include <asm/octeon/cvmx-config.h>
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
 
+#include <linux/module.h>
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-bootinfo.h>
+#include <asm/octeon/cvmx-smix-defs.h>
+#include <asm/octeon/cvmx-gmxx-defs.h>
+#include <asm/octeon/cvmx-asxx-defs.h>
 #include <asm/octeon/cvmx-mdio.h>
-
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-helper-util.h>
 #include <asm/octeon/cvmx-helper-board.h>
 
-#include <asm/octeon/cvmx-gmxx-defs.h>
-#include <asm/octeon/cvmx-asxx-defs.h>
-
-/**
- * cvmx_override_board_link_get(int ipd_port) is a function
- * pointer. It is meant to allow customization of the process of
- * talking to a PHY to determine link speed. It is called every
- * time a PHY must be polled for link status. Users should set
- * this pointer to a function before calling any cvmx-helper
- * operations.
- */
-cvmx_helper_link_info_t(*cvmx_override_board_link_get) (int ipd_port) =
-    NULL;
+CVMX_SHARED cvmx_helper_link_info_t(*cvmx_override_board_link_get) (int ipd_port) = NULL;
 
 /**
  * Return the MII PHY address associated with the given IPD
@@ -68,130 +62,332 @@ cvmx_helper_link_info_t(*cvmx_override_board_link_get) (int ipd_port) =
  * fact that every Octeon board receives a unique board type
  * enumeration from the bootloader.
  *
- * @ipd_port: Octeon IPD port to get the MII address for.
+ * @param ipd_port Octeon IPD port to get the MII address for.
  *
- * Returns MII PHY address and bus number or -1.
+ * @return MII PHY address and bus number or -1.
  */
 int cvmx_helper_board_get_mii_address(int ipd_port)
 {
-	switch (cvmx_sysinfo_get()->board_type) {
-	case CVMX_BOARD_TYPE_SIM:
-		/* Simulator doesn't have MII */
-		return -1;
-	case CVMX_BOARD_TYPE_EBT3000:
-	case CVMX_BOARD_TYPE_EBT5800:
-	case CVMX_BOARD_TYPE_THUNDER:
-	case CVMX_BOARD_TYPE_NICPRO2:
-		/* Interface 0 is SPI4, interface 1 is RGMII */
-		if ((ipd_port >= 16) && (ipd_port < 20))
-			return ipd_port - 16;
-		else
-			return -1;
-	case CVMX_BOARD_TYPE_KODAMA:
-	case CVMX_BOARD_TYPE_EBH3100:
-	case CVMX_BOARD_TYPE_HIKARI:
-	case CVMX_BOARD_TYPE_CN3010_EVB_HS5:
-	case CVMX_BOARD_TYPE_CN3005_EVB_HS5:
-	case CVMX_BOARD_TYPE_CN3020_EVB_HS5:
-		/*
-		 * Port 0 is WAN connected to a PHY, Port 1 is GMII
-		 * connected to a switch
-		 */
-		if (ipd_port == 0)
-			return 4;
-		else if (ipd_port == 1)
-			return 9;
-		else
-			return -1;
-	case CVMX_BOARD_TYPE_NAC38:
-		/* Board has 8 RGMII ports PHYs are 0-7 */
-		if ((ipd_port >= 0) && (ipd_port < 4))
-			return ipd_port;
-		else if ((ipd_port >= 16) && (ipd_port < 20))
-			return ipd_port - 16 + 4;
-		else
-			return -1;
-	case CVMX_BOARD_TYPE_EBH3000:
-		/* Board has dual SPI4 and no PHYs */
+	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM)
 		return -1;
-	case CVMX_BOARD_TYPE_EBH5200:
-	case CVMX_BOARD_TYPE_EBH5201:
-	case CVMX_BOARD_TYPE_EBT5200:
-		/* Board has 2 management ports */
-		if ((ipd_port >= CVMX_HELPER_BOARD_MGMT_IPD_PORT) &&
-		    (ipd_port < (CVMX_HELPER_BOARD_MGMT_IPD_PORT + 2)))
-			return ipd_port - CVMX_HELPER_BOARD_MGMT_IPD_PORT;
-		/*
-		 * Board has 4 SGMII ports. The PHYs start right after the MII
-		 * ports MII0 = 0, MII1 = 1, SGMII = 2-5.
-		 */
-		if ((ipd_port >= 0) && (ipd_port < 4))
-			return ipd_port + 2;
-		else
-			return -1;
-	case CVMX_BOARD_TYPE_EBH5600:
-	case CVMX_BOARD_TYPE_EBH5601:
-	case CVMX_BOARD_TYPE_EBH5610:
-		/* Board has 1 management port */
-		if (ipd_port == CVMX_HELPER_BOARD_MGMT_IPD_PORT)
-			return 0;
-		/*
-		 * Board has 8 SGMII ports. 4 connect out, two connect
-		 * to a switch, and 2 loop to each other
-		 */
-		if ((ipd_port >= 0) && (ipd_port < 4))
-			return ipd_port + 1;
-		else
-			return -1;
-	case CVMX_BOARD_TYPE_CUST_NB5:
-		if (ipd_port == 2)
-			return 4;
-		else
-			return -1;
-	case CVMX_BOARD_TYPE_NIC_XLE_4G:
-		/* Board has 4 SGMII ports. connected QLM3(interface 1) */
-		if ((ipd_port >= 16) && (ipd_port < 20))
-			return ipd_port - 16 + 1;
-		else
+	switch (cvmx_sysinfo_get()->board_type) {
+		case CVMX_BOARD_TYPE_SIM:
+			/* Simulator doesn't have MII */
 			return -1;
-	case CVMX_BOARD_TYPE_NIC_XLE_10G:
-	case CVMX_BOARD_TYPE_NIC10E:
-		return -1;
-	case CVMX_BOARD_TYPE_NIC4E:
-		if (ipd_port >= 0 && ipd_port <= 3)
-			return (ipd_port + 0x1f) & 0x1f;
-		else
+		case CVMX_BOARD_TYPE_EBT3000:
+		case CVMX_BOARD_TYPE_EBT5800:
+		case CVMX_BOARD_TYPE_THUNDER:
+		case CVMX_BOARD_TYPE_NICPRO2:
+			/* Interface 0 is SPI4, interface 1 is RGMII */
+			if ((ipd_port >= 16) && (ipd_port < 20))
+				return ipd_port - 16;
+			else
+				return -1;
+		case CVMX_BOARD_TYPE_LANAI2_A:
+			if (ipd_port == 0)
+				return 0;
+			else
+				return -1;
+		case CVMX_BOARD_TYPE_LANAI2_U:
+		case CVMX_BOARD_TYPE_LANAI2_G:
+			if (ipd_port == 0)
+				return 0x1c;
+			else
+				return -1;
+		case CVMX_BOARD_TYPE_KODAMA:
+		case CVMX_BOARD_TYPE_EBH3100:
+		case CVMX_BOARD_TYPE_HIKARI:
+		case CVMX_BOARD_TYPE_CN3010_EVB_HS5:
+		case CVMX_BOARD_TYPE_CN3005_EVB_HS5:
+		case CVMX_BOARD_TYPE_CN3020_EVB_HS5:
+			/* Port 0 is WAN connected to a PHY, Port 1 is GMII connected to a
+			   switch */
+			if (ipd_port == 0)
+				return 4;
+			else if (ipd_port == 1)
+				return 9;
+			else
+				return -1;
+		case CVMX_BOARD_TYPE_EBH3000:
+			/* Board has dual SPI4 and no PHYs */
 			return -1;
-	case CVMX_BOARD_TYPE_NIC2E:
-		if (ipd_port >= 0 && ipd_port <= 1)
-			return ipd_port + 1;
-		else
+		case CVMX_BOARD_TYPE_EBT5810:
+			/* Board has 10g PHYs hooked up to the MII controller on the
+			 ** IXF18201 MAC.  The 10G PHYS use clause 45 MDIO which the CN58XX
+			 ** does not support. All MII accesses go through the IXF part. */
 			return -1;
-	case CVMX_BOARD_TYPE_BBGW_REF:
-		/*
-		 * No PHYs are connected to Octeon, everything is
-		 * through switch.
-		 */
-		return -1;
+		case CVMX_BOARD_TYPE_EBH5200:
+		case CVMX_BOARD_TYPE_EBH5201:
+		case CVMX_BOARD_TYPE_EBT5200:
+			/* Board has 2 management ports */
+			if ((ipd_port >= CVMX_HELPER_BOARD_MGMT_IPD_PORT)
+				&& (ipd_port < (CVMX_HELPER_BOARD_MGMT_IPD_PORT + 2)))
+				return ipd_port - CVMX_HELPER_BOARD_MGMT_IPD_PORT;
+			/* Board has 4 SGMII ports. The PHYs start right after the MII
+			   ports MII0 = 0, MII1 = 1, SGMII = 2-5 */
+			if ((ipd_port >= 0) && (ipd_port < 4))
+				return ipd_port + 2;
+			else
+				return -1;
+		case CVMX_BOARD_TYPE_EBH5600:
+		case CVMX_BOARD_TYPE_EBH5601:
+		case CVMX_BOARD_TYPE_EBH5610:
+			/* Board has 1 management port */
+			if (ipd_port == CVMX_HELPER_BOARD_MGMT_IPD_PORT)
+				return 0;
+			/* Board has 8 SGMII ports. 4 connect out, two connect to a switch,
+			   and 2 loop to each other */
+			if ((ipd_port >= 0) && (ipd_port < 4))
+				return ipd_port + 1;
+			else
+				return -1;
 
-	case CVMX_BOARD_TYPE_CUST_WSX16:
-		if (ipd_port >= 0 && ipd_port <= 3)
-			return ipd_port;
-		else if (ipd_port >= 16 && ipd_port <= 19)
-			return ipd_port - 16 + 4;
-		else
+		case CVMX_BOARD_TYPE_EBB6300:
+			/* Board has 2 management ports */
+			if ((ipd_port >= CVMX_HELPER_BOARD_MGMT_IPD_PORT)
+				&& (ipd_port < (CVMX_HELPER_BOARD_MGMT_IPD_PORT + 2)))
+				return ipd_port - CVMX_HELPER_BOARD_MGMT_IPD_PORT + 4;
+			if ((ipd_port >= 0) && (ipd_port < 4))
+				return ipd_port + 1 + (1 << 8);
+			else
+				return -1;
+		case CVMX_BOARD_TYPE_EBB6800:
+			/* Board has 1 management ports */
+			if (ipd_port == CVMX_HELPER_BOARD_MGMT_IPD_PORT)
+				return 6;
+			if (ipd_port >= 0x800 && ipd_port < 0x900)	/* QLM 0 */
+				return 0x101 + ((ipd_port >> 4) & 3);	/* SMI 1 */
+			if (ipd_port >= 0xa00 && ipd_port < 0xb00)	/* QLM 2 */
+				return 0x201 + ((ipd_port >> 4) & 3);	/* SMI 2 */
+			if (ipd_port >= 0xb00 && ipd_port < 0xc00)	/* QLM 3 */
+				return 0x301 + ((ipd_port >> 4) & 3);	/* SMI 3 */
+			if (ipd_port >= 0xc00 && ipd_port < 0xd00)	/* QLM 4 */
+				return 0x001 + ((ipd_port >> 4) & 3);	/* SMI 0 */
 			return -1;
+		case CVMX_BOARD_TYPE_EP6300C:
+			if (ipd_port == CVMX_HELPER_BOARD_MGMT_IPD_PORT)
+				return 0x01;
+			if (ipd_port == CVMX_HELPER_BOARD_MGMT_IPD_PORT + 1)
+				return 0x02;
+#ifdef CVMX_ENABLE_PKO_FUNCTIONS
+			{
+				int interface = cvmx_helper_get_interface_num(ipd_port);
+				int mode = cvmx_helper_interface_get_mode(interface);
+				if (mode == CVMX_HELPER_INTERFACE_MODE_XAUI)
+					return ipd_port;
+				else if ((ipd_port >= 0) && (ipd_port < 4))
+					return ipd_port + 3;
+				else
+					return -1;
+			}
+#endif
+			break;
+		case CVMX_BOARD_TYPE_CUST_NB5:
+			if (ipd_port == 2)
+				return 4;
+			else
+				return -1;
+		case CVMX_BOARD_TYPE_NIC_XLE_4G:
+			/* Board has 4 SGMII ports. connected QLM3(interface 1) */
+			if ((ipd_port >= 16) && (ipd_port < 20))
+				return ipd_port - 16 + 1;
+			else
+				return -1;
+		case CVMX_BOARD_TYPE_NIC_XLE_10G:
+		case CVMX_BOARD_TYPE_NIC10E:
+			return -1;			/* We don't use clause 45 MDIO for anything */
+		case CVMX_BOARD_TYPE_NIC4E:
+			if (ipd_port >= 0 && ipd_port <= 3)
+				return (ipd_port + 0x1f) & 0x1f;
+			else
+				return -1;
+		case CVMX_BOARD_TYPE_NIC2E:
+			if (ipd_port >= 0 && ipd_port <= 1)
+				return (ipd_port + 1);
+			else
+				return -1;
+		case CVMX_BOARD_TYPE_REDWING:
+			return -1;			/* No PHYs connected to Octeon */
+		case CVMX_BOARD_TYPE_BBGW_REF:
+			return -1;			/* No PHYs are connected to Octeon, everything is through switch */
+		case CVMX_BOARD_TYPE_CUST_WSX16:
+			if (ipd_port >= 0 && ipd_port <= 3)
+				return ipd_port;
+			else if (ipd_port >= 16 && ipd_port <= 19)
+				return ipd_port - 16 + 4;
+			else
+				return -1;
 	}
 
 	/* Some unknown board. Somebody forgot to update this function... */
-	cvmx_dprintf
-	    ("cvmx_helper_board_get_mii_address: Unknown board type %d\n",
-	     cvmx_sysinfo_get()->board_type);
+	cvmx_dprintf("%s: Unknown board type %d\n",
+				 __FUNCTION__, cvmx_sysinfo_get()->board_type);
+	return -1;
+}
+EXPORT_SYMBOL(cvmx_helper_board_get_mii_address);
+
+/**
+ * @INTERNAL
+ * Get link state of marvell PHY
+ */
+static cvmx_helper_link_info_t __get_marvell_phy_link_state(int phy_addr)
+{
+	cvmx_helper_link_info_t result;
+	int phy_status;
+
+	result.u64 = 0;
+	/*All the speed information can be read from register 17 in one go. */
+	phy_status = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, 17);
+
+	/* If the resolve bit 11 isn't set, see if autoneg is turned off
+	   (bit 12, reg 0). The resolve bit doesn't get set properly when
+	   autoneg is off, so force it */
+	if ((phy_status & (1 << 11)) == 0) {
+		int auto_status = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, 0);
+		if ((auto_status & (1 << 12)) == 0)
+			phy_status |= 1 << 11;
+	}
+
+	/* Only return a link if the PHY has finished auto negotiation
+	   and set the resolved bit (bit 11) */
+	if (phy_status & (1 << 11)) {
+		result.s.link_up = 1;
+		result.s.full_duplex = ((phy_status >> 13) & 1);
+		switch ((phy_status >> 14) & 3) {
+			case 0:			/* 10 Mbps */
+				result.s.speed = 10;
+				break;
+			case 1:			/* 100 Mbps */
+				result.s.speed = 100;
+				break;
+			case 2:			/* 1 Gbps */
+				result.s.speed = 1000;
+				break;
+			case 3:			/* Illegal */
+				result.u64 = 0;
+				break;
+		}
+	}
+	return result;
+}
+
+/**
+ * @INTERNAL
+ * Get link state of broadcom PHY
+ */
+static cvmx_helper_link_info_t __get_broadcom_phy_link_state(int phy_addr)
+{
+	cvmx_helper_link_info_t result;
+	int phy_status;
+
+	result.u64 = 0;
+	/* Below we are going to read SMI/MDIO register 0x19 which works
+	   on Broadcom parts */
+	phy_status = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, 0x19);
+	switch ((phy_status >> 8) & 0x7) {
+		case 0:
+			result.u64 = 0;
+			break;
+		case 1:
+			result.s.link_up = 1;
+			result.s.full_duplex = 0;
+			result.s.speed = 10;
+			break;
+		case 2:
+			result.s.link_up = 1;
+			result.s.full_duplex = 1;
+			result.s.speed = 10;
+			break;
+		case 3:
+			result.s.link_up = 1;
+			result.s.full_duplex = 0;
+			result.s.speed = 100;
+			break;
+		case 4:
+			result.s.link_up = 1;
+			result.s.full_duplex = 1;
+			result.s.speed = 100;
+			break;
+		case 5:
+			result.s.link_up = 1;
+			result.s.full_duplex = 1;
+			result.s.speed = 100;
+			break;
+		case 6:
+			result.s.link_up = 1;
+			result.s.full_duplex = 0;
+			result.s.speed = 1000;
+			break;
+		case 7:
+			result.s.link_up = 1;
+			result.s.full_duplex = 1;
+			result.s.speed = 1000;
+			break;
+	}
+	return result;
+}
+
+
+/**
+ * @INTERNAL
+ * Get link state using inband status
+ */
+static cvmx_helper_link_info_t __get_inband_link_state(int ipd_port)
+{
+	cvmx_helper_link_info_t result;
+	union cvmx_gmxx_rxx_rx_inbnd inband_status;
+	int interface = cvmx_helper_get_interface_num(ipd_port);
+	int index = cvmx_helper_get_interface_index_num(ipd_port);
+
+	result.u64 = 0;
+	inband_status.u64 =
+		cvmx_read_csr(CVMX_GMXX_RXX_RX_INBND(index, interface));
+	result.s.link_up = inband_status.s.status;
+	result.s.full_duplex = inband_status.s.duplex;
+	switch (inband_status.s.speed) {
+		case 0:				/* 10 Mbps */
+			result.s.speed = 10;
+			break;
+		case 1:				/* 100 Mbps */
+			result.s.speed = 100;
+			break;
+		case 2:				/* 1 Gbps */
+			result.s.speed = 1000;
+			break;
+		case 3:				/* Illegal */
+			result.u64 = 0;
+			break;
+	}
+	return result;
+}
+
+/**
+ * @INTERNAL
+ * Switch MDIO mux to the specified port.
+ */
+int __switch_mdio_mux(int ipd_port)
+{
+	/* This method is board specific and doesn't use the device tree
+	   information as SE doesn't implement MDIO MUX abstration */
+	switch (cvmx_sysinfo_get()->board_type) {
+		default:
+			{
+				cvmx_dprintf
+					("ERROR : unexpected mdio switch for board=%08x\n",
+					 cvmx_sysinfo_get()->board_type);
+				return -1;
+			}
+	}
+	/* should never get here */
 	return -1;
 }
 
+
 /**
- * This function is the board specific method of determining an
+ * @INTERNAL
+ * This function invokes  __cvmx_helper_board_link_get_from_dt when device tree
+ * info is available. When the device tree information is not available then
+ * this function is the board specific method of determining an
  * ethernet ports link speed. Most Octeon boards have Marvell PHYs
  * and are handled by the fall through case. This function must be
  * updated for boards that don't have the normal Marvell PHYs.
@@ -202,10 +398,10 @@ int cvmx_helper_board_get_mii_address(int ipd_port)
  * fact that every Octeon board receives a unique board type
  * enumeration from the bootloader.
  *
- * @ipd_port: IPD input port associated with the port we want to get link
+ * @param ipd_port IPD input port associated with the port we want to get link
  *                 status for.
  *
- * Returns The ports link status. If the link isn't fully resolved, this must
+ * @return The ports link status. If the link isn't fully resolved, this must
  *         return zero.
  */
 cvmx_helper_link_info_t __cvmx_helper_board_link_get(int ipd_port)
@@ -221,196 +417,113 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get(int ipd_port)
 	/* Unless we fix it later, all links are defaulted to down */
 	result.u64 = 0;
 
-	/*
-	 * This switch statement should handle all ports that either don't use
-	 * Marvell PHYS, or don't support in-band status.
-	 */
+	/* This switch statement should handle all ports that either don't use
+	   Marvell PHYS, or don't support in-band status */
 	switch (cvmx_sysinfo_get()->board_type) {
-	case CVMX_BOARD_TYPE_SIM:
-		/* The simulator gives you a simulated 1Gbps full duplex link */
-		result.s.link_up = 1;
-		result.s.full_duplex = 1;
-		result.s.speed = 1000;
-		return result;
-	case CVMX_BOARD_TYPE_EBH3100:
-	case CVMX_BOARD_TYPE_CN3010_EVB_HS5:
-	case CVMX_BOARD_TYPE_CN3005_EVB_HS5:
-	case CVMX_BOARD_TYPE_CN3020_EVB_HS5:
-		/* Port 1 on these boards is always Gigabit */
-		if (ipd_port == 1) {
-			result.s.link_up = 1;
-			result.s.full_duplex = 1;
-			result.s.speed = 1000;
-			return result;
-		}
-		/* Fall through to the generic code below */
-		break;
-	case CVMX_BOARD_TYPE_CUST_NB5:
-		/* Port 1 on these boards is always Gigabit */
-		if (ipd_port == 1) {
+		case CVMX_BOARD_TYPE_SIM:
+			/* The simulator gives you a simulated 1Gbps full duplex link */
 			result.s.link_up = 1;
 			result.s.full_duplex = 1;
 			result.s.speed = 1000;
 			return result;
-		} else		/* The other port uses a broadcom PHY */
-			is_broadcom_phy = 1;
-		break;
-	case CVMX_BOARD_TYPE_BBGW_REF:
-		/* Port 1 on these boards is always Gigabit */
-		if (ipd_port == 2) {
-			/* Port 2 is not hooked up */
-			result.u64 = 0;
-			return result;
-		} else {
-			/* Ports 0 and 1 connect to the switch */
-			result.s.link_up = 1;
-			result.s.full_duplex = 1;
-			result.s.speed = 1000;
-			return result;
-		}
-		break;
-	}
-
-	phy_addr = cvmx_helper_board_get_mii_address(ipd_port);
-	if (phy_addr != -1) {
-		if (is_broadcom_phy) {
-			/*
-			 * Below we are going to read SMI/MDIO
-			 * register 0x19 which works on Broadcom
-			 * parts
-			 */
-			int phy_status =
-			    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-					   0x19);
-			switch ((phy_status >> 8) & 0x7) {
-			case 0:
-				result.u64 = 0;
-				break;
-			case 1:
-				result.s.link_up = 1;
-				result.s.full_duplex = 0;
-				result.s.speed = 10;
-				break;
-			case 2:
-				result.s.link_up = 1;
-				result.s.full_duplex = 1;
-				result.s.speed = 10;
-				break;
-			case 3:
-				result.s.link_up = 1;
-				result.s.full_duplex = 0;
-				result.s.speed = 100;
-				break;
-			case 4:
-				result.s.link_up = 1;
-				result.s.full_duplex = 1;
-				result.s.speed = 100;
-				break;
-			case 5:
+		case CVMX_BOARD_TYPE_LANAI2_A:
+		case CVMX_BOARD_TYPE_LANAI2_U:
+		case CVMX_BOARD_TYPE_LANAI2_G:
+			break;
+		case CVMX_BOARD_TYPE_EBH3100:
+		case CVMX_BOARD_TYPE_CN3010_EVB_HS5:
+		case CVMX_BOARD_TYPE_CN3005_EVB_HS5:
+		case CVMX_BOARD_TYPE_CN3020_EVB_HS5:
+			/* Port 1 on these boards is always Gigabit */
+			if (ipd_port == 1) {
 				result.s.link_up = 1;
 				result.s.full_duplex = 1;
-				result.s.speed = 100;
-				break;
-			case 6:
-				result.s.link_up = 1;
-				result.s.full_duplex = 0;
 				result.s.speed = 1000;
-				break;
-			case 7:
+				return result;
+			}
+			/* Fall through to the generic code below */
+			break;
+		case CVMX_BOARD_TYPE_EBH5600:
+		case CVMX_BOARD_TYPE_EBH5601:
+		case CVMX_BOARD_TYPE_EBH5610:
+			/* Board has 1 management ports */
+			if (ipd_port == CVMX_HELPER_BOARD_MGMT_IPD_PORT)
+				is_broadcom_phy = 1;
+			break;
+		case CVMX_BOARD_TYPE_EBH5200:
+		case CVMX_BOARD_TYPE_EBH5201:
+		case CVMX_BOARD_TYPE_EBT5200:
+			/* Board has 2 management ports */
+			if ((ipd_port >= CVMX_HELPER_BOARD_MGMT_IPD_PORT)
+				&& (ipd_port < (CVMX_HELPER_BOARD_MGMT_IPD_PORT + 2)))
+				is_broadcom_phy = 1;
+			break;
+		case CVMX_BOARD_TYPE_EBB6100:
+		case CVMX_BOARD_TYPE_EBB6300:	/* Only for MII mode, with PHY addresses 0/1. Default is RGMII */
+		case CVMX_BOARD_TYPE_EBB6600:	/* Only for MII mode, with PHY addresses 0/1. Default is RGMII */
+			if ((ipd_port >= CVMX_HELPER_BOARD_MGMT_IPD_PORT)
+				&& (ipd_port < (CVMX_HELPER_BOARD_MGMT_IPD_PORT + 2))
+				&& cvmx_helper_board_get_mii_address(ipd_port) >= 0
+				&& cvmx_helper_board_get_mii_address(ipd_port) <= 1)
+				is_broadcom_phy = 1;
+			break;
+		case CVMX_BOARD_TYPE_EP6300C:
+			is_broadcom_phy = 1;
+			break;
+		case CVMX_BOARD_TYPE_CUST_NB5:
+			/* Port 1 on these boards is always Gigabit */
+			if (ipd_port == 1) {
 				result.s.link_up = 1;
 				result.s.full_duplex = 1;
 				result.s.speed = 1000;
-				break;
+				return result;
 			}
-		} else {
-			/*
-			 * This code assumes we are using a Marvell
-			 * Gigabit PHY. All the speed information can
-			 * be read from register 17 in one
-			 * go. Somebody using a different PHY will
-			 * need to handle it above in the board
-			 * specific area.
-			 */
-			int phy_status =
-			    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, 17);
-
-			/*
-			 * If the resolve bit 11 isn't set, see if
-			 * autoneg is turned off (bit 12, reg 0). The
-			 * resolve bit doesn't get set properly when
-			 * autoneg is off, so force it.
-			 */
-			if ((phy_status & (1 << 11)) == 0) {
-				int auto_status =
-				    cvmx_mdio_read(phy_addr >> 8,
-						   phy_addr & 0xff, 0);
-				if ((auto_status & (1 << 12)) == 0)
-					phy_status |= 1 << 11;
+			else				/* The other port uses a broadcom PHY */
+				is_broadcom_phy = 1;
+			break;
+		case CVMX_BOARD_TYPE_BBGW_REF:
+			/* Port 1 on these boards is always Gigabit */
+			if (ipd_port == 2) {
+				/* Port 2 is not hooked up */
+				result.u64 = 0;
+				return result;
 			}
-
-			/*
-			 * Only return a link if the PHY has finished
-			 * auto negotiation and set the resolved bit
-			 * (bit 11)
-			 */
-			if (phy_status & (1 << 11)) {
+			else {
+				/* Ports 0 and 1 connect to the switch */
 				result.s.link_up = 1;
-				result.s.full_duplex = ((phy_status >> 13) & 1);
-				switch ((phy_status >> 14) & 3) {
-				case 0:	/* 10 Mbps */
-					result.s.speed = 10;
-					break;
-				case 1:	/* 100 Mbps */
-					result.s.speed = 100;
-					break;
-				case 2:	/* 1 Gbps */
-					result.s.speed = 1000;
-					break;
-				case 3:	/* Illegal */
-					result.u64 = 0;
-					break;
-				}
+				result.s.full_duplex = 1;
+				result.s.speed = 1000;
+				return result;
 			}
-		}
-	} else if (OCTEON_IS_MODEL(OCTEON_CN3XXX)
-		   || OCTEON_IS_MODEL(OCTEON_CN58XX)
-		   || OCTEON_IS_MODEL(OCTEON_CN50XX)) {
-		/*
-		 * We don't have a PHY address, so attempt to use
-		 * in-band status. It is really important that boards
-		 * not supporting in-band status never get
-		 * here. Reading broken in-band status tends to do bad
-		 * things
-		 */
-		union cvmx_gmxx_rxx_rx_inbnd inband_status;
-		int interface = cvmx_helper_get_interface_num(ipd_port);
-		int index = cvmx_helper_get_interface_index_num(ipd_port);
-		inband_status.u64 =
-		    cvmx_read_csr(CVMX_GMXX_RXX_RX_INBND(index, interface));
-
-		result.s.link_up = inband_status.s.status;
-		result.s.full_duplex = inband_status.s.duplex;
-		switch (inband_status.s.speed) {
-		case 0:	/* 10 Mbps */
-			result.s.speed = 10;
-			break;
-		case 1:	/* 100 Mbps */
-			result.s.speed = 100;
-			break;
-		case 2:	/* 1 Gbps */
-			result.s.speed = 1000;
-			break;
-		case 3:	/* Illegal */
-			result.u64 = 0;
+		case CVMX_BOARD_TYPE_NIC4E:
+		case CVMX_BOARD_TYPE_NIC2E:
+			is_broadcom_phy = 1;
 			break;
+	}
+
+	phy_addr = cvmx_helper_board_get_mii_address(ipd_port);
+	//cvmx_dprintf("ipd_port=%d phy_addr=%d broadcom=%d\n",
+	//             ipd_port, phy_addr, is_broadcom_phy);
+	if (phy_addr != -1) {
+		if (is_broadcom_phy) {
+			result = __get_broadcom_phy_link_state(phy_addr);
+		}
+		else {
+			/* This code assumes we are using a Marvell Gigabit PHY. */
+			result = __get_marvell_phy_link_state(phy_addr);
 		}
-	} else {
-		/*
-		 * We don't have a PHY address and we don't have
-		 * in-band status. There is no way to determine the
-		 * link speed. Return down assuming this port isn't
-		 * wired
-		 */
+	}
+	else if (OCTEON_IS_MODEL(OCTEON_CN3XXX) || OCTEON_IS_MODEL(OCTEON_CN58XX)
+			 || OCTEON_IS_MODEL(OCTEON_CN50XX)) {
+		/* We don't have a PHY address, so attempt to use in-band status. It is
+		   really important that boards not supporting in-band status never get
+		   here. Reading broken in-band status tends to do bad things */
+		result = __get_inband_link_state(ipd_port);
+	}
+	else {
+		/* We don't have a PHY address and we don't have in-band status. There
+		   is no way to determine the link speed. Return down assuming this
+		   port isn't wired */
 		result.u64 = 0;
 	}
 
@@ -421,47 +534,48 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get(int ipd_port)
 	return result;
 }
 
+
 /**
  * This function as a board specific method of changing the PHY
- * speed, duplex, and auto-negotiation. This programs the PHY and
+ * speed, duplex, and autonegotiation. This programs the PHY and
  * not Octeon. This can be used to force Octeon's links to
  * specific settings.
  *
- * @phy_addr:  The address of the PHY to program
- * @enable_autoneg:
- *                  Non zero if you want to enable auto-negotiation.
- * @link_info: Link speed to program. If the speed is zero and auto-negotiation
+ * @param phy_addr  The address of the PHY to program
+ * @param link_flags
+ *                  Flags to control autonegotiation.  Bit 0 is autonegotiation
+ *                  enable/disable to maintain backward compatibility.
+ * @param link_info Link speed to program. If the speed is zero and autonegotiation
  *                  is enabled, all possible negotiation speeds are advertised.
  *
- * Returns Zero on success, negative on failure
+ * @return Zero on success, negative on failure
  */
 int cvmx_helper_board_link_set_phy(int phy_addr,
-				   cvmx_helper_board_set_phy_link_flags_types_t
-				   link_flags,
-				   cvmx_helper_link_info_t link_info)
+								   cvmx_helper_board_set_phy_link_flags_types_t
+								   link_flags,
+								   cvmx_helper_link_info_t link_info)
 {
 
 	/* Set the flow control settings based on link_flags */
 	if ((link_flags & set_phy_link_flags_flow_control_mask) !=
-	    set_phy_link_flags_flow_control_dont_touch) {
+		set_phy_link_flags_flow_control_dont_touch) {
 		cvmx_mdio_phy_reg_autoneg_adver_t reg_autoneg_adver;
 		reg_autoneg_adver.u16 =
-		    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-				   CVMX_MDIO_PHY_REG_AUTONEG_ADVER);
+			cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
+						   CVMX_MDIO_PHY_REG_AUTONEG_ADVER);
 		reg_autoneg_adver.s.asymmetric_pause =
-		    (link_flags & set_phy_link_flags_flow_control_mask) ==
-		    set_phy_link_flags_flow_control_enable;
+			(link_flags & set_phy_link_flags_flow_control_mask) ==
+			set_phy_link_flags_flow_control_enable;
 		reg_autoneg_adver.s.pause =
-		    (link_flags & set_phy_link_flags_flow_control_mask) ==
-		    set_phy_link_flags_flow_control_enable;
+			(link_flags & set_phy_link_flags_flow_control_mask) ==
+			set_phy_link_flags_flow_control_enable;
 		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
-				CVMX_MDIO_PHY_REG_AUTONEG_ADVER,
-				reg_autoneg_adver.u16);
+						CVMX_MDIO_PHY_REG_AUTONEG_ADVER,
+						reg_autoneg_adver.u16);
 	}
 
 	/* If speed isn't set and autoneg is on advertise all supported modes */
-	if ((link_flags & set_phy_link_flags_autoneg)
-	    && (link_info.s.speed == 0)) {
+	if ((link_flags & set_phy_link_flags_autoneg) && (link_info.s.speed == 0)) {
 		cvmx_mdio_phy_reg_control_t reg_control;
 		cvmx_mdio_phy_reg_status_t reg_status;
 		cvmx_mdio_phy_reg_autoneg_adver_t reg_autoneg_adver;
@@ -469,58 +583,59 @@ int cvmx_helper_board_link_set_phy(int phy_addr,
 		cvmx_mdio_phy_reg_control_1000_t reg_control_1000;
 
 		reg_status.u16 =
-		    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-				   CVMX_MDIO_PHY_REG_STATUS);
+			cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
+						   CVMX_MDIO_PHY_REG_STATUS);
 		reg_autoneg_adver.u16 =
-		    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-				   CVMX_MDIO_PHY_REG_AUTONEG_ADVER);
+			cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
+						   CVMX_MDIO_PHY_REG_AUTONEG_ADVER);
 		reg_autoneg_adver.s.advert_100base_t4 =
-		    reg_status.s.capable_100base_t4;
+			reg_status.s.capable_100base_t4;
 		reg_autoneg_adver.s.advert_10base_tx_full =
-		    reg_status.s.capable_10_full;
+			reg_status.s.capable_10_full;
 		reg_autoneg_adver.s.advert_10base_tx_half =
-		    reg_status.s.capable_10_half;
+			reg_status.s.capable_10_half;
 		reg_autoneg_adver.s.advert_100base_tx_full =
-		    reg_status.s.capable_100base_x_full;
+			reg_status.s.capable_100base_x_full;
 		reg_autoneg_adver.s.advert_100base_tx_half =
-		    reg_status.s.capable_100base_x_half;
+			reg_status.s.capable_100base_x_half;
 		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
-				CVMX_MDIO_PHY_REG_AUTONEG_ADVER,
-				reg_autoneg_adver.u16);
+						CVMX_MDIO_PHY_REG_AUTONEG_ADVER,
+						reg_autoneg_adver.u16);
 		if (reg_status.s.capable_extended_status) {
 			reg_extended_status.u16 =
-			    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-					   CVMX_MDIO_PHY_REG_EXTENDED_STATUS);
+				cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
+							   CVMX_MDIO_PHY_REG_EXTENDED_STATUS);
 			reg_control_1000.u16 =
-			    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-					   CVMX_MDIO_PHY_REG_CONTROL_1000);
+				cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
+							   CVMX_MDIO_PHY_REG_CONTROL_1000);
 			reg_control_1000.s.advert_1000base_t_full =
-			    reg_extended_status.s.capable_1000base_t_full;
+				reg_extended_status.s.capable_1000base_t_full;
 			reg_control_1000.s.advert_1000base_t_half =
-			    reg_extended_status.s.capable_1000base_t_half;
+				reg_extended_status.s.capable_1000base_t_half;
 			cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
-					CVMX_MDIO_PHY_REG_CONTROL_1000,
-					reg_control_1000.u16);
+							CVMX_MDIO_PHY_REG_CONTROL_1000,
+							reg_control_1000.u16);
 		}
 		reg_control.u16 =
-		    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-				   CVMX_MDIO_PHY_REG_CONTROL);
+			cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
+						   CVMX_MDIO_PHY_REG_CONTROL);
 		reg_control.s.autoneg_enable = 1;
 		reg_control.s.restart_autoneg = 1;
 		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
-				CVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);
-	} else if ((link_flags & set_phy_link_flags_autoneg)) {
+						CVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);
+	}
+	else if ((link_flags & set_phy_link_flags_autoneg)) {
 		cvmx_mdio_phy_reg_control_t reg_control;
 		cvmx_mdio_phy_reg_status_t reg_status;
 		cvmx_mdio_phy_reg_autoneg_adver_t reg_autoneg_adver;
 		cvmx_mdio_phy_reg_control_1000_t reg_control_1000;
 
 		reg_status.u16 =
-		    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-				   CVMX_MDIO_PHY_REG_STATUS);
+			cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
+						   CVMX_MDIO_PHY_REG_STATUS);
 		reg_autoneg_adver.u16 =
-		    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-				   CVMX_MDIO_PHY_REG_AUTONEG_ADVER);
+			cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
+						   CVMX_MDIO_PHY_REG_AUTONEG_ADVER);
 		reg_autoneg_adver.s.advert_100base_t4 = 0;
 		reg_autoneg_adver.s.advert_10base_tx_full = 0;
 		reg_autoneg_adver.s.advert_10base_tx_half = 0;
@@ -528,70 +643,75 @@ int cvmx_helper_board_link_set_phy(int phy_addr,
 		reg_autoneg_adver.s.advert_100base_tx_half = 0;
 		if (reg_status.s.capable_extended_status) {
 			reg_control_1000.u16 =
-			    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-					   CVMX_MDIO_PHY_REG_CONTROL_1000);
+				cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
+							   CVMX_MDIO_PHY_REG_CONTROL_1000);
 			reg_control_1000.s.advert_1000base_t_full = 0;
 			reg_control_1000.s.advert_1000base_t_half = 0;
 		}
 		switch (link_info.s.speed) {
-		case 10:
-			reg_autoneg_adver.s.advert_10base_tx_full =
-			    link_info.s.full_duplex;
-			reg_autoneg_adver.s.advert_10base_tx_half =
-			    !link_info.s.full_duplex;
-			break;
-		case 100:
-			reg_autoneg_adver.s.advert_100base_tx_full =
-			    link_info.s.full_duplex;
-			reg_autoneg_adver.s.advert_100base_tx_half =
-			    !link_info.s.full_duplex;
-			break;
-		case 1000:
-			reg_control_1000.s.advert_1000base_t_full =
-			    link_info.s.full_duplex;
-			reg_control_1000.s.advert_1000base_t_half =
-			    !link_info.s.full_duplex;
-			break;
+			case 10:
+				reg_autoneg_adver.s.advert_10base_tx_full =
+					link_info.s.full_duplex;
+				reg_autoneg_adver.s.advert_10base_tx_half =
+					!link_info.s.full_duplex;
+				break;
+			case 100:
+				reg_autoneg_adver.s.advert_100base_tx_full =
+					link_info.s.full_duplex;
+				reg_autoneg_adver.s.advert_100base_tx_half =
+					!link_info.s.full_duplex;
+				break;
+			case 1000:
+				reg_control_1000.s.advert_1000base_t_full =
+					link_info.s.full_duplex;
+				reg_control_1000.s.advert_1000base_t_half =
+					!link_info.s.full_duplex;
+				break;
 		}
 		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
-				CVMX_MDIO_PHY_REG_AUTONEG_ADVER,
-				reg_autoneg_adver.u16);
+						CVMX_MDIO_PHY_REG_AUTONEG_ADVER,
+						reg_autoneg_adver.u16);
 		if (reg_status.s.capable_extended_status)
 			cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
-					CVMX_MDIO_PHY_REG_CONTROL_1000,
-					reg_control_1000.u16);
+							CVMX_MDIO_PHY_REG_CONTROL_1000,
+							reg_control_1000.u16);
 		reg_control.u16 =
-		    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-				   CVMX_MDIO_PHY_REG_CONTROL);
+			cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
+						   CVMX_MDIO_PHY_REG_CONTROL);
 		reg_control.s.autoneg_enable = 1;
 		reg_control.s.restart_autoneg = 1;
 		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
-				CVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);
-	} else {
+						CVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);
+	}
+	else {
 		cvmx_mdio_phy_reg_control_t reg_control;
 		reg_control.u16 =
-		    cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
-				   CVMX_MDIO_PHY_REG_CONTROL);
+			cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
+						   CVMX_MDIO_PHY_REG_CONTROL);
 		reg_control.s.autoneg_enable = 0;
 		reg_control.s.restart_autoneg = 1;
 		reg_control.s.duplex = link_info.s.full_duplex;
 		if (link_info.s.speed == 1000) {
 			reg_control.s.speed_msb = 1;
 			reg_control.s.speed_lsb = 0;
-		} else if (link_info.s.speed == 100) {
+		}
+		else if (link_info.s.speed == 100) {
 			reg_control.s.speed_msb = 0;
 			reg_control.s.speed_lsb = 1;
-		} else if (link_info.s.speed == 10) {
+		}
+		else if (link_info.s.speed == 10) {
 			reg_control.s.speed_msb = 0;
 			reg_control.s.speed_lsb = 0;
 		}
 		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
-				CVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);
+						CVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);
 	}
 	return 0;
 }
 
+
 /**
+ * @INTERNAL
  * This function is called by cvmx_helper_interface_probe() after it
  * determines the number of ports Octeon can support on a specific
  * interface. This function is the per board location to override
@@ -599,53 +719,76 @@ int cvmx_helper_board_link_set_phy(int phy_addr,
  * support and should return the number of actual ports on the
  * board.
  *
- * This function must be modifed for every new Octeon board.
+ * This function must be modified for every new Octeon board.
  * Internally it uses switch statements based on the cvmx_sysinfo
- * data to determine board types and revisions. It relys on the
+ * data to determine board types and revisions. It relies on the
  * fact that every Octeon board receives a unique board type
  * enumeration from the bootloader.
  *
- * @interface: Interface to probe
- * @supported_ports:
+ * @param interface Interface to probe
+ * @param supported_ports
  *                  Number of ports Octeon supports.
  *
- * Returns Number of ports the actual board supports. Many times this will
+ * @return Number of ports the actual board supports. Many times this will
  *         simple be "support_ports".
  */
 int __cvmx_helper_board_interface_probe(int interface, int supported_ports)
 {
 	switch (cvmx_sysinfo_get()->board_type) {
-	case CVMX_BOARD_TYPE_CN3005_EVB_HS5:
-		if (interface == 0)
-			return 2;
-		break;
-	case CVMX_BOARD_TYPE_BBGW_REF:
-		if (interface == 0)
-			return 2;
-		break;
-	case CVMX_BOARD_TYPE_NIC_XLE_4G:
-		if (interface == 0)
-			return 0;
-		break;
-		/* The 2nd interface on the EBH5600 is connected to the Marvel switch,
-		   which we don't support. Disable ports connected to it */
-	case CVMX_BOARD_TYPE_EBH5600:
-		if (interface == 1)
-			return 0;
-		break;
+		case CVMX_BOARD_TYPE_CN3005_EVB_HS5:
+		case CVMX_BOARD_TYPE_LANAI2_A:
+		case CVMX_BOARD_TYPE_LANAI2_U:
+		case CVMX_BOARD_TYPE_LANAI2_G:
+			if (interface == 0)
+				return 2;
+			break;
+		case CVMX_BOARD_TYPE_BBGW_REF:
+			if (interface == 0)
+				return 2;
+			break;
+		case CVMX_BOARD_TYPE_NIC_XLE_4G:
+			if (interface == 0)
+				return 0;
+			break;
+			/* The 2nd interface on the EBH5600 is connected to the Marvel switch,
+			   which we don't support. Disable ports connected to it */
+		case CVMX_BOARD_TYPE_EBH5600:
+			if (interface == 1)
+				return 0;
+			break;
+		case CVMX_BOARD_TYPE_EBB5600:
+#ifdef CVMX_ENABLE_PKO_FUNCTIONS
+			if (cvmx_helper_interface_get_mode(interface) ==
+				CVMX_HELPER_INTERFACE_MODE_PICMG)
+				return 0;
+#endif
+			break;
+		case CVMX_BOARD_TYPE_EBT5810:
+			return 1;			/* Two ports on each SPI: 1 hooked to MAC, 1 loopback
+								 ** Loopback disabled by default. */
+		case CVMX_BOARD_TYPE_NIC2E:
+			if (interface == 0)
+				return 2;
 	}
+#ifdef CVMX_BUILD_FOR_UBOOT
+	if (CVMX_HELPER_INTERFACE_MODE_SPI ==
+		cvmx_helper_interface_get_mode(interface) && getenv("disable_spi"))
+		return 0;
+#endif
 	return supported_ports;
 }
 
+
 /**
+ * @INTERNAL
  * Enable packet input/output from the hardware. This function is
  * called after by cvmx_helper_packet_hardware_enable() to
  * perform board specific initialization. For most boards
  * nothing is needed.
  *
- * @interface: Interface to enable
+ * @param interface Interface to enable
  *
- * Returns Zero on success, negative on failure
+ * @return Zero on success, negative on failure
  */
 int __cvmx_helper_board_hardware_enable(int interface)
 {
@@ -654,58 +797,72 @@ int __cvmx_helper_board_hardware_enable(int interface)
 			/* Different config for switch port */
 			cvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(1, interface), 0);
 			cvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(1, interface), 0);
-			/*
-			 * Boards with gigabit WAN ports need a
-			 * different setting that is compatible with
-			 * 100 Mbit settings
-			 */
-			cvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(0, interface),
-				       0xc);
-			cvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(0, interface),
-				       0xc);
+			/* Boards with gigabit WAN ports need a different setting that is
+			   compatible with 100 Mbit settings */
+			cvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(0, interface), 0xc);
+			cvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(0, interface), 0xc);
 		}
-	} else if (cvmx_sysinfo_get()->board_type ==
-		   CVMX_BOARD_TYPE_CN3010_EVB_HS5) {
-		/*
-		 * Broadcom PHYs require differnet ASX
-		 * clocks. Unfortunately many boards don't define a
-		 * new board Id and simply mangle the
-		 * CN3010_EVB_HS5
-		 */
+	}
+	else if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_LANAI2_U) {
 		if (interface == 0) {
-			/*
-			 * Some boards use a hacked up bootloader that
-			 * identifies them as CN3010_EVB_HS5
-			 * evaluation boards.  This leads to all kinds
-			 * of configuration problems.  Detect one
-			 * case, and print warning, while trying to do
-			 * the right thing.
+			cvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(0, interface), 16);
+			cvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(0, interface), 16);
+		}
+	}
+	else if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_CN3010_EVB_HS5) {
+		/* Broadcom PHYs require different ASX clocks. Unfortunately
+		   many customer don't define a new board Id and simply
+		   mangle the CN3010_EVB_HS5 */
+		if (interface == 0) {
+			/* Some customers boards use a hacked up bootloader that identifies them as
+			 ** CN3010_EVB_HS5 evaluation boards.  This leads to all kinds of configuration
+			 ** problems.  Detect one case, and print warning, while trying to do the right thing.
 			 */
 			int phy_addr = cvmx_helper_board_get_mii_address(0);
 			if (phy_addr != -1) {
 				int phy_identifier =
-				    cvmx_mdio_read(phy_addr >> 8,
-						   phy_addr & 0xff, 0x2);
+					cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, 0x2);
 				/* Is it a Broadcom PHY? */
 				if (phy_identifier == 0x0143) {
 					cvmx_dprintf("\n");
 					cvmx_dprintf("ERROR:\n");
 					cvmx_dprintf
-					    ("ERROR: Board type is CVMX_BOARD_TYPE_CN3010_EVB_HS5, but Broadcom PHY found.\n");
+						("ERROR: Board type is CVMX_BOARD_TYPE_CN3010_EVB_HS5, but Broadcom PHY found.\n");
 					cvmx_dprintf
-					    ("ERROR: The board type is mis-configured, and software malfunctions are likely.\n");
+						("ERROR: The board type is mis-configured, and software malfunctions are likely.\n");
 					cvmx_dprintf
-					    ("ERROR: All boards require a unique board type to identify them.\n");
+						("ERROR: All boards require a unique board type to identify them.\n");
 					cvmx_dprintf("ERROR:\n");
 					cvmx_dprintf("\n");
 					cvmx_wait(1000000000);
-					cvmx_write_csr(CVMX_ASXX_RX_CLK_SETX
-						       (0, interface), 5);
-					cvmx_write_csr(CVMX_ASXX_TX_CLK_SETX
-						       (0, interface), 5);
+					cvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(0, interface), 5);
+					cvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(0, interface), 5);
 				}
 			}
 		}
 	}
 	return 0;
 }
+
+/**
+ * @INTERNAL
+ * Adjusts the number of available USB ports on Octeon based on board
+ * specifics.
+ *
+ * @param supported_ports expected number of ports based on chip type;
+ *
+ *
+ * @return number of available usb ports, based on board specifics.
+ *         Return value is supported_ports if function does not
+ *         override.
+ */
+int __cvmx_helper_board_usb_get_num_ports(int supported_ports)
+{
+	switch (cvmx_sysinfo_get()->board_type) {
+		case CVMX_BOARD_TYPE_NIC_XLE_4G:
+		case CVMX_BOARD_TYPE_NIC2E:
+			return 0;
+	}
+
+	return supported_ports;
+}
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-loop.c b/arch/mips/cavium-octeon/executive/cvmx-helper-loop.c
index bfbd461..23f2914 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-loop.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-loop.c
@@ -36,6 +36,7 @@
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-pip-defs.h>
 
+#ifdef CVMX_ENABLE_PKO_FUNCTIONS
 /**
  * Probe a LOOP interface and determine the number of ports
  * connected to it. The LOOP interface should still be down
@@ -83,3 +84,5 @@ int __cvmx_helper_loop_enable(int interface)
 	/* Do nothing. */
 	return 0;
 }
+
+#endif
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c b/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
index cc94cfa..e0efa8d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
@@ -25,17 +25,14 @@
  * Contact Cavium Networks for more information
  ***********************license end**************************************/
 
-/*
- * Functions for NPI initialization, configuration,
- * and monitoring.
- */
 #include <asm/octeon/octeon.h>
-
 #include <asm/octeon/cvmx-config.h>
-
 #include <asm/octeon/cvmx-helper.h>
-
 #include <asm/octeon/cvmx-pip-defs.h>
+#include <asm/octeon/cvmx-sli-defs.h>
+#include <asm/octeon/cvmx-pexp-defs.h>
+#include <asm/octeon/cvmx-pko.h>
+
 
 /**
  * Probe a NPI interface and determine the number of ports
@@ -49,28 +46,14 @@
 int __cvmx_helper_npi_probe(int interface)
 {
 #if CVMX_PKO_QUEUES_PER_PORT_PCI > 0
-	if (OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX))
-		return 4;
-	else if (OCTEON_IS_MODEL(OCTEON_CN56XX)
-		 && !OCTEON_IS_MODEL(OCTEON_CN56XX_PASS1_X))
-		/* The packet engines didn't exist before pass 2 */
-		return 4;
-	else if (OCTEON_IS_MODEL(OCTEON_CN52XX)
-		 && !OCTEON_IS_MODEL(OCTEON_CN52XX_PASS1_X))
-		/* The packet engines didn't exist before pass 2 */
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		return 32;
+	else if (!(OCTEON_IS_MODEL(OCTEON_CN52XX_PASS1_X)
+		|| OCTEON_IS_MODEL(OCTEON_CN56XX_PASS1_X)
+		|| OCTEON_IS_MODEL(OCTEON_CN31XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN50XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN30XX)))
 		return 4;
-#if 0
-	/*
-	 * Technically CN30XX, CN31XX, and CN50XX contain packet
-	 * engines, but nobody ever uses them. Since this is the case,
-	 * we disable them here.
-	 */
-	else if (OCTEON_IS_MODEL(OCTEON_CN31XX)
-		 || OCTEON_IS_MODEL(OCTEON_CN50XX))
-		return 2;
-	else if (OCTEON_IS_MODEL(OCTEON_CN30XX))
-		return 1;
-#endif
 #endif
 	return 0;
 }
@@ -86,28 +69,50 @@ int __cvmx_helper_npi_probe(int interface)
  */
 int __cvmx_helper_npi_enable(int interface)
 {
+	int num_ports = cvmx_helper_ports_on_interface(interface);
+
 	/*
 	 * On CN50XX, CN52XX, and CN56XX we need to disable length
 	 * checking so packet < 64 bytes and jumbo frames don't get
 	 * errors.
 	 */
-	if (!OCTEON_IS_MODEL(OCTEON_CN3XXX) &&
-	    !OCTEON_IS_MODEL(OCTEON_CN58XX)) {
-		int num_ports = cvmx_helper_ports_on_interface(interface);
+	if (!OCTEON_IS_MODEL(OCTEON_CN3XXX) && !OCTEON_IS_MODEL(OCTEON_CN58XX)) {
 		int port;
 		for (port = 0; port < num_ports; port++) {
 			union cvmx_pip_prt_cfgx port_cfg;
-			int ipd_port =
-			    cvmx_helper_get_ipd_port(interface, port);
-			port_cfg.u64 =
-			    cvmx_read_csr(CVMX_PIP_PRT_CFGX(ipd_port));
+			int ipd_port = (OCTEON_IS_MODEL(OCTEON_CN68XX)) ?
+				cvmx_helper_get_pknd(interface, port) :
+				cvmx_helper_get_ipd_port(interface, port);
+			port_cfg.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(ipd_port));
+			port_cfg.s.lenerr_en = 0;
 			port_cfg.s.maxerr_en = 0;
 			port_cfg.s.minerr_en = 0;
-			cvmx_write_csr(CVMX_PIP_PRT_CFGX(ipd_port),
-				       port_cfg.u64);
+			cvmx_write_csr(CVMX_PIP_PRT_CFGX(ipd_port), port_cfg.u64);
+
+			if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+				/*
+				 * Set up pknd and bpid
+				 */
+				union cvmx_sli_portx_pkind config;
+				config.u64 = cvmx_read_csr(CVMX_PEXP_SLI_PORTX_PKIND(port));
+				config.s.bpkind = cvmx_helper_get_bpid(interface, port);
+				config.s.pkind = cvmx_helper_get_pknd(interface, port);
+				cvmx_write_csr(CVMX_PEXP_SLI_PORTX_PKIND(port), config.u64);
+			}
 		}
 	}
 
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		/*
+		 * Set up pko pipes.
+		 */
+		union cvmx_sli_tx_pipe config;
+		config.u64 = cvmx_read_csr(CVMX_PEXP_SLI_TX_PIPE);
+		config.s.base = __cvmx_pko_get_pipe(interface, 0);
+		config.s.nump = num_ports;
+		cvmx_write_csr(CVMX_PEXP_SLI_TX_PIPE, config.u64);
+	}
+
 	/* Enables are controlled by the remote host, so nothing to do here */
 	return 0;
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-rgmii.c b/arch/mips/cavium-octeon/executive/cvmx-helper-rgmii.c
index 82b2184..dbe7e23 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-rgmii.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-rgmii.c
@@ -44,6 +44,8 @@
 #include <asm/octeon/cvmx-asxx-defs.h>
 #include <asm/octeon/cvmx-dbg-defs.h>
 
+#ifdef CVMX_ENABLE_PKO_FUNCTIONS
+
 void __cvmx_interrupt_gmxx_enable(int interface);
 void __cvmx_interrupt_asxx_enable(int block);
 
@@ -524,3 +526,5 @@ int __cvmx_helper_rgmii_configure_loopback(int ipd_port, int enable_internal,
 	cvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), gmx_cfg.u64);
 	return 0;
 }
+
+#endif
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c b/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
index 0c0bf5d..9771449 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
@@ -41,6 +41,8 @@
 #include <asm/octeon/cvmx-gmxx-defs.h>
 #include <asm/octeon/cvmx-pcsx-defs.h>
 
+#ifdef CVMX_ENABLE_PKO_FUNCTIONS
+
 void __cvmx_interrupt_gmxx_enable(int interface);
 void __cvmx_interrupt_pcsx_intx_en_reg_enable(int index, int block);
 void __cvmx_interrupt_pcsxx_int_en_reg_enable(int index);
@@ -552,3 +554,5 @@ int __cvmx_helper_sgmii_configure_loopback(int ipd_port, int enable_internal,
 	__cvmx_helper_sgmii_hardware_init_link(interface, index);
 	return 0;
 }
+
+#endif
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-spi.c b/arch/mips/cavium-octeon/executive/cvmx-helper-spi.c
index 2830e4b..b55f55a 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-spi.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-spi.c
@@ -42,6 +42,8 @@ void __cvmx_interrupt_stxx_int_msk_enable(int index);
 #include <asm/octeon/cvmx-pip-defs.h>
 #include <asm/octeon/cvmx-pko-defs.h>
 
+#ifdef CVMX_ENABLE_PKO_FUNCTIONS
+
 /*
  * CVMX_HELPER_SPI_TIMEOUT is used to determine how long the SPI
  * initialization routines wait for SPI training. You can override the
@@ -203,3 +205,5 @@ int __cvmx_helper_spi_link_set(int ipd_port, cvmx_helper_link_info_t link_info)
 	   info */
 	return 0;
 }
+
+#endif
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
index 116dea1..2821951 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
@@ -29,22 +29,34 @@
  * Small helper utilities.
  */
 #include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
 
 #include <asm/octeon/octeon.h>
-
 #include <asm/octeon/cvmx-config.h>
-
 #include <asm/octeon/cvmx-fpa.h>
 #include <asm/octeon/cvmx-pip.h>
 #include <asm/octeon/cvmx-pko.h>
 #include <asm/octeon/cvmx-ipd.h>
 #include <asm/octeon/cvmx-spi.h>
-
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-helper-util.h>
-
 #include <asm/octeon/cvmx-ipd-defs.h>
 
+struct cvmx_iface
+{
+	int cvif_ipd_nports;
+	int cvif_has_fcs;			/* PKO fcs for this interface. */
+	enum cvmx_pko_padding cvif_padding;
+	cvmx_helper_link_info_t *cvif_ipd_port_link_info;
+};
+
+/*
+ * This has to be static as u-boot expects to probe an interface and
+ * gets the number of its ports.
+ */
+static CVMX_SHARED struct cvmx_iface cvmx_interfaces[CVMX_HELPER_MAX_IFACE];
+
 /**
  * Convert a interface mode into a human readable string
  *
@@ -56,26 +68,30 @@ const char *cvmx_helper_interface_mode_to_string(cvmx_helper_interface_mode_t
 						 mode)
 {
 	switch (mode) {
-	case CVMX_HELPER_INTERFACE_MODE_DISABLED:
-		return "DISABLED";
-	case CVMX_HELPER_INTERFACE_MODE_RGMII:
-		return "RGMII";
-	case CVMX_HELPER_INTERFACE_MODE_GMII:
-		return "GMII";
-	case CVMX_HELPER_INTERFACE_MODE_SPI:
-		return "SPI";
-	case CVMX_HELPER_INTERFACE_MODE_PCIE:
-		return "PCIE";
-	case CVMX_HELPER_INTERFACE_MODE_XAUI:
-		return "XAUI";
-	case CVMX_HELPER_INTERFACE_MODE_SGMII:
-		return "SGMII";
-	case CVMX_HELPER_INTERFACE_MODE_PICMG:
-		return "PICMG";
-	case CVMX_HELPER_INTERFACE_MODE_NPI:
-		return "NPI";
-	case CVMX_HELPER_INTERFACE_MODE_LOOP:
-		return "LOOP";
+		case CVMX_HELPER_INTERFACE_MODE_DISABLED:
+			return "DISABLED";
+		case CVMX_HELPER_INTERFACE_MODE_RGMII:
+			return "RGMII";
+		case CVMX_HELPER_INTERFACE_MODE_GMII:
+			return "GMII";
+		case CVMX_HELPER_INTERFACE_MODE_SPI:
+			return "SPI";
+		case CVMX_HELPER_INTERFACE_MODE_PCIE:
+			return "PCIE";
+		case CVMX_HELPER_INTERFACE_MODE_XAUI:
+			return "XAUI";
+		case CVMX_HELPER_INTERFACE_MODE_RXAUI:
+			return "RXAUI";
+		case CVMX_HELPER_INTERFACE_MODE_SGMII:
+			return "SGMII";
+		case CVMX_HELPER_INTERFACE_MODE_PICMG:
+			return "PICMG";
+		case CVMX_HELPER_INTERFACE_MODE_NPI:
+			return "NPI";
+		case CVMX_HELPER_INTERFACE_MODE_LOOP:
+			return "LOOP";
+		case CVMX_HELPER_INTERFACE_MODE_SRIO:
+			return "SRIO";
 	}
 	return "UNKNOWN";
 }
@@ -361,6 +377,152 @@ int __cvmx_helper_setup_gmx(int interface, int num_ports)
 	return 0;
 }
 
+int __cvmx_helper_get_num_ipd_ports(int interface)
+{
+	struct cvmx_iface *piface;
+
+	if (interface >= cvmx_helper_get_number_of_interfaces())
+		return -1;
+
+	piface = &cvmx_interfaces[interface];
+	return piface->cvif_ipd_nports;
+}
+
+enum cvmx_pko_padding __cvmx_helper_get_pko_padding(int interface)
+{
+	struct cvmx_iface *piface;
+
+	if (interface >= cvmx_helper_get_number_of_interfaces())
+		return CVMX_PKO_PADDING_NONE;
+
+	piface = &cvmx_interfaces[interface];
+	return piface->cvif_padding;
+}
+
+int __cvmx_helper_init_interface(int interface, int num_ipd_ports,
+				 int has_fcs, enum cvmx_pko_padding pad)
+{
+	struct cvmx_iface *piface;
+	int sz;
+
+	if (interface >= cvmx_helper_get_number_of_interfaces())
+		return -1;
+
+	piface = &cvmx_interfaces[interface];
+	piface->cvif_ipd_nports = num_ipd_ports;
+	piface->cvif_padding = pad;
+
+	piface->cvif_has_fcs = has_fcs;
+
+	/*
+	 * allocate the per-ipd_port link_info structure
+	 */
+	sz = piface->cvif_ipd_nports * sizeof(cvmx_helper_link_info_t);
+	if (sz == 0)
+		sz = sizeof(cvmx_helper_link_info_t);
+
+	piface->cvif_ipd_port_link_info =
+		(cvmx_helper_link_info_t *) kmalloc(sz, GFP_KERNEL);
+
+	if (ZERO_OR_NULL_PTR(piface->cvif_ipd_port_link_info))
+		panic("Cannot allocate memory in __cvmx_helper_init_interface.");
+
+	if (!piface->cvif_ipd_port_link_info)
+		return -1;
+
+	/* Initialize 'em */  {
+		int i;
+		cvmx_helper_link_info_t *p;
+		p = piface->cvif_ipd_port_link_info;
+
+		for (i = 0; i < piface->cvif_ipd_nports; i++) {
+			(*p).u64 = 0;
+			p++;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Shut down the interfaces; free the resources.
+ * @INTERNAL
+ */
+void __cvmx_helper_shutdown_interfaces(void)
+{
+	int i;
+	int nifaces;				/* number of interfaces */
+	struct cvmx_iface *piface;
+
+	nifaces = cvmx_helper_get_number_of_interfaces();
+	for (i = 0; i < nifaces; i++) {
+		piface = cvmx_interfaces + i;
+		if (piface->cvif_ipd_port_link_info)
+			kfree(piface->cvif_ipd_port_link_info);
+			piface->cvif_ipd_port_link_info = 0;
+	}
+}
+
+int __cvmx_helper_set_link_info(int interface, int port,
+								cvmx_helper_link_info_t link_info)
+{
+	struct cvmx_iface *piface;
+
+	if (interface >= cvmx_helper_get_number_of_interfaces())
+		return -1;
+
+	piface = &cvmx_interfaces[interface];
+
+	if (piface->cvif_ipd_port_link_info) {
+		piface->cvif_ipd_port_link_info[port] = link_info;
+		return 0;
+	}
+
+	return -1;
+}
+
+cvmx_helper_link_info_t __cvmx_helper_get_link_info(int interface, int port)
+{
+	struct cvmx_iface *piface;
+	cvmx_helper_link_info_t err;
+
+	err.u64 = 0;
+
+	if (interface >= cvmx_helper_get_number_of_interfaces())
+		return err;
+	piface = &cvmx_interfaces[interface];
+
+	if (piface->cvif_ipd_port_link_info)
+		return piface->cvif_ipd_port_link_info[port];
+
+	return err;
+}
+
+int __cvmx_helper_get_has_fcs(int interface)
+{
+	return cvmx_interfaces[interface].cvif_has_fcs;
+}
+
+int cvmx_helper_get_pknd(int interface, int port)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_PKND))
+		return __cvmx_helper_cfg_pknd(interface, port);
+
+	return CVMX_INVALID_PKND;
+}
+
+int cvmx_helper_get_bpid(int interface, int port)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_PKND))
+		return __cvmx_helper_cfg_bpid(interface, port);
+
+	return CVMX_INVALID_BPID;
+}
+
+int cvmx_helper_get_pko_port(int interface, int port)
+{
+	return cvmx_pko_get_base_pko_port(interface, port);
+}
 /**
  * Returns the IPD/PKO port number for a port on the given
  * interface.
@@ -373,14 +535,20 @@ int __cvmx_helper_setup_gmx(int interface, int num_ports)
 int cvmx_helper_get_ipd_port(int interface, int port)
 {
 	switch (interface) {
-	case 0:
-		return port;
-	case 1:
-		return port + 16;
-	case 2:
-		return port + 32;
-	case 3:
-		return port + 36;
+		case 0:
+			return port;
+		case 1:
+			return port + 16;
+		case 2:
+			return port + 32;
+		case 3:
+			return port + 36;
+		case 4:
+			return port + 40;
+		case 5:
+			return port + 42;
+		case 6:
+			return port + 44;
 	}
 	return -1;
 }
@@ -402,6 +570,12 @@ int cvmx_helper_get_interface_num(int ipd_port)
 		return 2;
 	else if (ipd_port < 40)
 		return 3;
+	else if (ipd_port < 42)
+		return 4;
+	else if (ipd_port < 44)
+		return 5;
+	else if (ipd_port < 46)
+		return 6;
 	else
 		cvmx_dprintf("cvmx_helper_get_interface_num: Illegal IPD "
 			     "port number\n");
@@ -421,10 +595,12 @@ int cvmx_helper_get_interface_index_num(int ipd_port)
 {
 	if (ipd_port < 32)
 		return ipd_port & 15;
-	else if (ipd_port < 36)
-		return ipd_port & 3;
 	else if (ipd_port < 40)
 		return ipd_port & 3;
+	else if (ipd_port < 44)
+		return ipd_port & 1;
+	else if (ipd_port < 46)
+		return ipd_port & 1;
 	else
 		cvmx_dprintf("cvmx_helper_get_interface_index_num: "
 			     "Illegal IPD port number\n");
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c b/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c
index 1723248e..079236c 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c
@@ -41,6 +41,8 @@
 #include <asm/octeon/cvmx-gmxx-defs.h>
 #include <asm/octeon/cvmx-pcsxx-defs.h>
 
+#ifdef CVMX_ENABLE_PKO_FUNCTIONS
+
 void __cvmx_interrupt_gmxx_enable(int interface);
 void __cvmx_interrupt_pcsx_intx_en_reg_enable(int index, int block);
 void __cvmx_interrupt_pcsxx_int_en_reg_enable(int index);
@@ -352,3 +354,5 @@ extern int __cvmx_helper_xaui_configure_loopback(int ipd_port,
 	/* Take the link through a reset */
 	return __cvmx_helper_xaui_enable(interface);
 }
+
+#endif
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper.c b/arch/mips/cavium-octeon/executive/cvmx-helper.c
index fa49638..1d1ac25 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper.c
@@ -45,6 +45,9 @@
 #include <asm/octeon/cvmx-pip-defs.h>
 #include <asm/octeon/cvmx-smix-defs.h>
 #include <asm/octeon/cvmx-asxx-defs.h>
+#include <asm/octeon/cvmx-sriox-defs.h>
+
+#ifdef CVMX_ENABLE_PKO_FUNCTIONS
 
 /**
  * cvmx_override_pko_queue_priority(int ipd_port, uint64_t
@@ -53,8 +56,8 @@
  * number. Users should set this pointer to a function before
  * calling any cvmx-helper operations.
  */
-void (*cvmx_override_pko_queue_priority) (int pko_port,
-					  uint64_t priorities[16]);
+CVMX_SHARED void (*cvmx_override_pko_queue_priority) (int pko_port,
+			  uint64_t *priorities) = NULL;
 
 /**
  * cvmx_override_ipd_port_setup(int ipd_port) is a function
@@ -64,7 +67,7 @@ void (*cvmx_override_pko_queue_priority) (int pko_port,
  * before IPD is enabled. Users should set this pointer to a
  * function before calling any cvmx-helper operations.
  */
-void (*cvmx_override_ipd_port_setup) (int ipd_port);
+CVMX_SHARED void (*cvmx_override_ipd_port_setup) (int ipd_port) = NULL;
 
 /* Port count per interface */
 static int interface_port_count[4] = { 0, 0, 0, 0 };
@@ -83,7 +86,16 @@ static cvmx_helper_link_info_t
  */
 int cvmx_helper_get_number_of_interfaces(void)
 {
-	if (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN52XX))
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		return 9;
+	else if (OCTEON_IS_MODEL(OCTEON_CN66XX))
+		if (OCTEON_IS_MODEL(OCTEON_CN66XX_PASS1_0))
+			return 7;
+		else
+			return 8;
+	else if (OCTEON_IS_MODEL(OCTEON_CN63XX))
+		return 6;
+	else if (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN61XX))
 		return 4;
 	else
 		return 3;
@@ -116,17 +128,167 @@ int cvmx_helper_ports_on_interface(int interface)
 cvmx_helper_interface_mode_t cvmx_helper_interface_get_mode(int interface)
 {
 	union cvmx_gmxx_inf_mode mode;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		cvmx_mio_qlmx_cfg_t qlm_cfg;
+		switch (interface) {
+			case 0:
+				qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(0));
+				/* QLM is disabled when QLM SPD is 15. */
+				if (qlm_cfg.s.qlm_spd == 15)
+					return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+				if (qlm_cfg.s.qlm_cfg == 7)
+					return CVMX_HELPER_INTERFACE_MODE_RXAUI;
+				else if (qlm_cfg.s.qlm_cfg == 2)
+					return CVMX_HELPER_INTERFACE_MODE_SGMII;
+				else if (qlm_cfg.s.qlm_cfg == 3)
+					return CVMX_HELPER_INTERFACE_MODE_XAUI;
+				else
+					return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+				break;
+			case 1:
+				qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(0));
+				/* QLM is disabled when QLM SPD is 15. */
+				if (qlm_cfg.s.qlm_spd == 15)
+					return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+				if (qlm_cfg.s.qlm_cfg == 7)
+					return CVMX_HELPER_INTERFACE_MODE_RXAUI;
+				else
+					return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+				break;
+			case 2:
+			case 3:
+			case 4:
+				qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(interface));
+				/* QLM is disabled when QLM SPD is 15. */
+				if (qlm_cfg.s.qlm_spd == 15)
+					return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+				if (qlm_cfg.s.qlm_cfg == 2)
+					return CVMX_HELPER_INTERFACE_MODE_SGMII;
+				else if (qlm_cfg.s.qlm_cfg == 3)
+					return CVMX_HELPER_INTERFACE_MODE_XAUI;
+				else
+					return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+				break;
+			case 5:
+			case 6:
+				qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(interface - 4));
+				/* QLM is disabled when QLM SPD is 15. */
+				if (qlm_cfg.s.qlm_spd == 15)
+					return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+				if (qlm_cfg.s.qlm_cfg != 1)
+					return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+				#ifdef ILK
+				else
+					return CVMX_HELPER_INTERFACE_MODE_ILK;
+				#endif
+				break;
+			case 7:
+				qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(3));
+				/* QLM is disabled when QLM SPD is 15. */
+				if (qlm_cfg.s.qlm_spd == 15)
+					return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+				else if (qlm_cfg.s.qlm_cfg != 0) {
+					qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(1));
+					if (qlm_cfg.s.qlm_cfg != 0)
+						return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+				}
+				return CVMX_HELPER_INTERFACE_MODE_NPI;
+				break;
+			case 8:
+				return CVMX_HELPER_INTERFACE_MODE_LOOP;
+				break;
+			default:
+				return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+				break;
+		}
+	}
+
 	if (interface == 2)
 		return CVMX_HELPER_INTERFACE_MODE_NPI;
 
 	if (interface == 3) {
 		if (OCTEON_IS_MODEL(OCTEON_CN56XX)
-		    || OCTEON_IS_MODEL(OCTEON_CN52XX))
+		    || OCTEON_IS_MODEL(OCTEON_CN52XX)
+		    || OCTEON_IS_MODEL(OCTEON_CN6XXX))
 			return CVMX_HELPER_INTERFACE_MODE_LOOP;
 		else
 			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
 	}
 
+	/* Only present in CN63XX & CN66XX Octeon model */
+	if ((OCTEON_IS_MODEL(OCTEON_CN63XX) && (interface == 4 || interface == 5))
+		|| (OCTEON_IS_MODEL(OCTEON_CN66XX) && interface >= 4
+		&& interface <= 7)) {
+		cvmx_sriox_status_reg_t sriox_status_reg;
+
+		/* cn66xx pass1.0 has only 2 SRIO interfaces. */
+		if ((interface == 5 || interface == 7)
+			&& OCTEON_IS_MODEL(OCTEON_CN66XX_PASS1_0))
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+		sriox_status_reg.u64 =
+			cvmx_read_csr(CVMX_SRIOX_STATUS_REG(interface - 4));
+		if (!sriox_status_reg.s.srio)
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+		else
+			return CVMX_HELPER_INTERFACE_MODE_SRIO;
+	}
+
+	/* Interface 5 always disabled in CN66XX */
+	if (OCTEON_IS_MODEL(OCTEON_CN66XX)) {
+		cvmx_mio_qlmx_cfg_t mio_qlm_cfg;
+
+		/* QLM2 is SGMII0 and QLM1 is SGMII1 */
+		if (interface == 0)
+			mio_qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(2));
+		else if (interface == 1)
+			mio_qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(1));
+		else
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+		if (mio_qlm_cfg.s.qlm_spd == 15)
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+		if (mio_qlm_cfg.s.qlm_cfg == 9)
+			return CVMX_HELPER_INTERFACE_MODE_SGMII;
+		else if (mio_qlm_cfg.s.qlm_cfg == 11)
+			return CVMX_HELPER_INTERFACE_MODE_XAUI;
+		else
+			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+	}
+	else if (OCTEON_IS_MODEL(OCTEON_CN61XX)) {
+		cvmx_mio_qlmx_cfg_t qlm_cfg;
+
+		if (interface == 0) {
+			qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(2));
+			if (qlm_cfg.s.qlm_cfg == 2)
+				return CVMX_HELPER_INTERFACE_MODE_SGMII;
+			else if (qlm_cfg.s.qlm_cfg == 3)
+				return CVMX_HELPER_INTERFACE_MODE_XAUI;
+			else
+				return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+		}
+		else if (interface == 1) {
+			/* If QLM 1 is PEV0/PEM1 mode, them QLM0 cannot be SGMII/XAUI */
+			qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(1));
+			if (qlm_cfg.s.qlm_cfg == 1)
+				return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+
+			qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(0));
+			if (qlm_cfg.s.qlm_cfg == 2)
+				return CVMX_HELPER_INTERFACE_MODE_SGMII;
+			else if (qlm_cfg.s.qlm_cfg == 3)
+				return CVMX_HELPER_INTERFACE_MODE_XAUI;
+			else
+				return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+		}
+	}
+
 	if (interface == 0
 	    && cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_CN3005_EVB_HS5
 	    && cvmx_sysinfo_get()->board_rev_major == 1) {
@@ -147,23 +309,31 @@ cvmx_helper_interface_mode_t cvmx_helper_interface_get_mode(int interface)
 	if ((interface == 1)
 	    && (OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN30XX)
 		|| OCTEON_IS_MODEL(OCTEON_CN50XX)
-		|| OCTEON_IS_MODEL(OCTEON_CN52XX)))
+		|| OCTEON_IS_MODEL(OCTEON_CN52XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN63XX)))
 		return CVMX_HELPER_INTERFACE_MODE_DISABLED;
 
 	mode.u64 = cvmx_read_csr(CVMX_GMXX_INF_MODE(interface));
 
 	if (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN52XX)) {
 		switch (mode.cn56xx.mode) {
-		case 0:
-			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
-		case 1:
-			return CVMX_HELPER_INTERFACE_MODE_XAUI;
-		case 2:
-			return CVMX_HELPER_INTERFACE_MODE_SGMII;
-		case 3:
-			return CVMX_HELPER_INTERFACE_MODE_PICMG;
-		default:
-			return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+			case 0:
+				return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+			case 1:
+				return CVMX_HELPER_INTERFACE_MODE_XAUI;
+			case 2:
+				return CVMX_HELPER_INTERFACE_MODE_SGMII;
+			case 3:
+				return CVMX_HELPER_INTERFACE_MODE_PICMG;
+			default:
+				return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+		}
+	} else if (OCTEON_IS_MODEL(OCTEON_CN63XX)) {
+		switch(mode.cn63xx.mode)
+		{
+			case 0: return CVMX_HELPER_INTERFACE_MODE_SGMII;
+			case 1: return CVMX_HELPER_INTERFACE_MODE_XAUI;
+			default: return CVMX_HELPER_INTERFACE_MODE_DISABLED;
 		}
 	} else {
 		if (!mode.s.en)
@@ -234,6 +404,46 @@ static int __cvmx_helper_port_setup_ipd(int ipd_port)
 }
 
 /**
+ * Enable or disable FCS stripping for all the ports on an interface.
+ *
+ * @param interface
+ * @param nports number of ports
+ * @param has_fcs 0 for disable and !0 for enable
+ */
+static int cvmx_helper_fcs_op(int interface, int nports, int has_fcs)
+{
+	uint64_t port_bit;
+	int index;
+	int pknd;
+	union cvmx_pip_sub_pkind_fcsx pkind_fcsx;
+	union cvmx_pip_prt_cfgx port_cfg;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_PKND))
+		return 0;
+
+	port_bit = 0;
+	for (index = 0; index < nports; index++)
+		port_bit |= ((uint64_t) 1 << cvmx_helper_get_pknd(interface, index));
+
+	pkind_fcsx.u64 = cvmx_read_csr(CVMX_PIP_SUB_PKIND_FCSX(0));
+	if (has_fcs)
+		pkind_fcsx.s.port_bit |= port_bit;
+	else
+		pkind_fcsx.s.port_bit &= ~port_bit;
+	cvmx_write_csr(CVMX_PIP_SUB_PKIND_FCSX(0), pkind_fcsx.u64);
+
+	for (pknd = 0; pknd < 64; pknd++) {
+		if ((1ull << pknd) & port_bit) {
+			port_cfg.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(pknd));
+			port_cfg.s.crc_en = (has_fcs) ? 1 : 0;
+			cvmx_write_csr(CVMX_PIP_PRT_CFGX(pknd), port_cfg.u64);
+		}
+	}
+
+	return 0;
+}
+
+/**
  * This function sets the interface_port_count[interface] correctly,
  * without modifying any hardware configuration.  Hardware setup of
  * the ports will be performed later.
@@ -252,6 +462,7 @@ int cvmx_helper_interface_enumerate(int interface)
 		break;
 		/* XAUI is a single high speed port */
 	case CVMX_HELPER_INTERFACE_MODE_XAUI:
+	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 		interface_port_count[interface] =
 		    __cvmx_helper_xaui_enumerate(interface);
 		break;
@@ -294,6 +505,10 @@ int cvmx_helper_interface_enumerate(int interface)
 		interface_port_count[interface] =
 		    __cvmx_helper_loop_enumerate(interface);
 		break;
+
+        case CVMX_HELPER_INTERFACE_MODE_SRIO:
+		interface_port_count[interface] =
+			__cvmx_helper_srio_enumerate(interface);
 	}
 
 	interface_port_count[interface] =
@@ -320,6 +535,13 @@ int cvmx_helper_interface_enumerate(int interface)
  */
 int cvmx_helper_interface_probe(int interface)
 {
+	int nports;
+	int has_fcs;
+	enum cvmx_pko_padding padding = CVMX_PKO_PADDING_NONE;
+
+	nports = -1;
+	has_fcs = 0;
+
 	cvmx_helper_interface_enumerate(interface);
 	/* At this stage in the game we don't want packets to be moving yet.
 	   The following probe calls should perform hardware setup
@@ -328,10 +550,14 @@ int cvmx_helper_interface_probe(int interface)
 		/* These types don't support ports to IPD/PKO */
 	case CVMX_HELPER_INTERFACE_MODE_DISABLED:
 	case CVMX_HELPER_INTERFACE_MODE_PCIE:
+		nports = 0;
 		break;
 		/* XAUI is a single high speed port */
 	case CVMX_HELPER_INTERFACE_MODE_XAUI:
-		__cvmx_helper_xaui_probe(interface);
+	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
+		nports = __cvmx_helper_xaui_probe(interface);
+		has_fcs = 1;
+		padding = CVMX_PKO_PADDING_60;
 		break;
 		/*
 		 * RGMII/GMII/MII are all treated about the same. Most
@@ -339,36 +565,55 @@ int cvmx_helper_interface_probe(int interface)
 		 */
 	case CVMX_HELPER_INTERFACE_MODE_RGMII:
 	case CVMX_HELPER_INTERFACE_MODE_GMII:
-		__cvmx_helper_rgmii_probe(interface);
+		nports = __cvmx_helper_rgmii_probe(interface);
+		padding = CVMX_PKO_PADDING_60;
 		break;
 		/*
 		 * SPI4 can have 1-16 ports depending on the device at
 		 * the other end.
 		 */
 	case CVMX_HELPER_INTERFACE_MODE_SPI:
-		__cvmx_helper_spi_probe(interface);
+		nports = __cvmx_helper_spi_probe(interface);
+		padding = CVMX_PKO_PADDING_60;
 		break;
 		/*
 		 * SGMII can have 1-4 ports depending on how many are
 		 * hooked up.
 		 */
 	case CVMX_HELPER_INTERFACE_MODE_SGMII:
+		padding = CVMX_PKO_PADDING_60;
 	case CVMX_HELPER_INTERFACE_MODE_PICMG:
-		__cvmx_helper_sgmii_probe(interface);
+		nports = __cvmx_helper_sgmii_probe(interface);
+		has_fcs = 1;
 		break;
 		/* PCI target Network Packet Interface */
 	case CVMX_HELPER_INTERFACE_MODE_NPI:
-		__cvmx_helper_npi_probe(interface);
+		nports = __cvmx_helper_npi_probe(interface);
 		break;
 		/*
 		 * Special loopback only ports. These are not the same
 		 * as other ports in loopback mode.
 		 */
 	case CVMX_HELPER_INTERFACE_MODE_LOOP:
-		__cvmx_helper_loop_probe(interface);
+		nports = __cvmx_helper_loop_probe(interface);
+		break;
+
+        /* SRIO has 2^N ports, where N is number of interfaces */
+	case CVMX_HELPER_INTERFACE_MODE_SRIO:
+		nports = __cvmx_helper_srio_probe(interface);
 		break;
 	}
 
+	if (nports == -1)
+		return -1;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_PKND))
+		has_fcs = 0;
+
+	nports = __cvmx_helper_board_interface_probe(interface, nports);
+	__cvmx_helper_init_interface(interface, nports, has_fcs, padding);
+	cvmx_helper_fcs_op(interface, nports, has_fcs);
+
 	/* Make sure all global variables propagate to other cores */
 	CVMX_SYNCWS;
 
@@ -442,8 +687,9 @@ static int __cvmx_helper_interface_setup_pko(int interface)
 	 * the second half.  With per-core PKO queues (PKO lockless
 	 * operation) all queues have the same priority.
 	 */
-	uint64_t priorities[16] =
-	    { 8, 7, 6, 5, 4, 3, 2, 1, 8, 7, 6, 5, 4, 3, 2, 1 };
+	//uint64_t priorities[16] =
+	 //   { 8, 7, 6, 5, 4, 3, 2, 1, 8, 7, 6, 5, 4, 3, 2, 1 };
+	uint64_t priorities[16] = {[0 ... 15] = 8};
 
 	/*
 	 * Setup the IPD/PIP and PKO for the ports discovered
@@ -452,6 +698,7 @@ static int __cvmx_helper_interface_setup_pko(int interface)
 	 */
 	int ipd_port = cvmx_helper_get_ipd_port(interface, 0);
 	int num_ports = interface_port_count[interface];
+	printk("<0> %s: Interface %d, ipd_port %d\n", __FUNCTION__, interface, ipd_port);
 	while (num_ports--) {
 		/*
 		 * Give the user a chance to override the per queue
@@ -461,8 +708,7 @@ static int __cvmx_helper_interface_setup_pko(int interface)
 			cvmx_override_pko_queue_priority(ipd_port, priorities);
 
 		cvmx_pko_config_port(ipd_port,
-				     cvmx_pko_get_base_queue_per_core(ipd_port,
-								      0),
+				     cvmx_pko_get_base_queue_per_core(ipd_port, 0),
 				     cvmx_pko_get_num_queues(ipd_port),
 				     priorities);
 		ipd_port++;
@@ -506,9 +752,11 @@ static int __cvmx_helper_global_setup_backpressure(void)
 		switch (cvmx_helper_interface_get_mode(interface)) {
 		case CVMX_HELPER_INTERFACE_MODE_DISABLED:
 		case CVMX_HELPER_INTERFACE_MODE_PCIE:
+		case CVMX_HELPER_INTERFACE_MODE_SRIO:
 		case CVMX_HELPER_INTERFACE_MODE_NPI:
 		case CVMX_HELPER_INTERFACE_MODE_LOOP:
 		case CVMX_HELPER_INTERFACE_MODE_XAUI:
+		case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 			break;
 		case CVMX_HELPER_INTERFACE_MODE_RGMII:
 		case CVMX_HELPER_INTERFACE_MODE_GMII:
@@ -546,6 +794,7 @@ static int __cvmx_helper_packet_hardware_enable(int interface)
 		break;
 		/* XAUI is a single high speed port */
 	case CVMX_HELPER_INTERFACE_MODE_XAUI:
+	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 		result = __cvmx_helper_xaui_enable(interface);
 		break;
 		/*
@@ -579,6 +828,9 @@ static int __cvmx_helper_packet_hardware_enable(int interface)
 		 * Special loopback only ports. These are not the same
 		 * as other ports in loopback mode
 		 */
+	case CVMX_HELPER_INTERFACE_MODE_SRIO:
+		result = __cvmx_helper_srio_enable(interface);
+		break;
 	case CVMX_HELPER_INTERFACE_MODE_LOOP:
 		result = __cvmx_helper_loop_enable(interface);
 		break;
@@ -855,10 +1107,19 @@ int cvmx_helper_initialize_packet_io_global(void)
 	 * to the cores. This avoids conditions where IO blocks might
 	 * be starved under very high L2 loads.
 	 */
-	l2c_cfg.u64 = cvmx_read_csr(CVMX_L2C_CFG);
-	l2c_cfg.s.lrf_arb_mode = 0;
-	l2c_cfg.s.rfb_arb_mode = 0;
-	cvmx_write_csr(CVMX_L2C_CFG, l2c_cfg.u64);
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX)) {
+		union cvmx_l2c_ctl l2c_ctl;
+		l2c_ctl.u64 = cvmx_read_csr(CVMX_L2C_CTL);
+		l2c_ctl.s.rsp_arb_mode = 1;
+		l2c_ctl.s.xmc_arb_mode = 0;
+		cvmx_write_csr(CVMX_L2C_CTL, l2c_ctl.u64);
+	}
+	else {
+		l2c_cfg.u64 = cvmx_read_csr(CVMX_L2C_CFG);
+		l2c_cfg.s.lrf_arb_mode = 0;
+		l2c_cfg.s.rfb_arb_mode = 0;
+		cvmx_write_csr(CVMX_L2C_CFG, l2c_cfg.u64);
+	}
 
 	/* Make sure SMI/MDIO is enabled so we can query PHYs */
 	smix_en.u64 = cvmx_read_csr(CVMX_SMIX_EN(0));
@@ -867,29 +1128,45 @@ int cvmx_helper_initialize_packet_io_global(void)
 		cvmx_write_csr(CVMX_SMIX_EN(0), smix_en.u64);
 	}
 
-	/* Newer chips actually have two SMI/MDIO interfaces */
-	if (!OCTEON_IS_MODEL(OCTEON_CN3XXX) &&
-	    !OCTEON_IS_MODEL(OCTEON_CN58XX) &&
-	    !OCTEON_IS_MODEL(OCTEON_CN50XX)) {
-		smix_en.u64 = cvmx_read_csr(CVMX_SMIX_EN(1));
-		if (!smix_en.s.en) {
-			smix_en.s.en = 1;
-			cvmx_write_csr(CVMX_SMIX_EN(1), smix_en.u64);
+	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
+		int smi_inf = 1;
+		int i;
+
+		/* Newer chips have more than one SMI/MDIO interface */
+		if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+			smi_inf = 4;
+		else if (!OCTEON_IS_MODEL(OCTEON_CN3XXX)
+				 && !OCTEON_IS_MODEL(OCTEON_CN58XX)
+				 && !OCTEON_IS_MODEL(OCTEON_CN50XX))
+			smi_inf = 2;
+
+		for (i = 0; i < smi_inf; i++) {
+			/* Make sure SMI/MDIO is enabled so we can query PHYs */
+			smix_en.u64 = cvmx_read_csr(CVMX_SMIX_EN(i));
+			if (!smix_en.s.en) {
+				smix_en.s.en = 1;
+				cvmx_write_csr(CVMX_SMIX_EN(i), smix_en.u64);
+			}
 		}
 	}
 
+	__cvmx_helper_cfg_init();
+
+	for (interface = 0; interface < num_interfaces; interface++)
+		result |= cvmx_helper_interface_probe(interface);
+
 	cvmx_pko_initialize_global();
+
 	for (interface = 0; interface < num_interfaces; interface++) {
-		result |= cvmx_helper_interface_probe(interface);
 		if (cvmx_helper_ports_on_interface(interface) > 0)
 			cvmx_dprintf("Interface %d has %d ports (%s)\n",
 				     interface,
 				     cvmx_helper_ports_on_interface(interface),
 				     cvmx_helper_interface_mode_to_string
-				     (cvmx_helper_interface_get_mode
-				      (interface)));
+				     (cvmx_helper_interface_get_mode(interface)));
 		result |= __cvmx_helper_interface_setup_ipd(interface);
-		result |= __cvmx_helper_interface_setup_pko(interface);
+		if (!OCTEON_IS_MODEL(OCTEON_CN68XX))
+			result |= __cvmx_helper_interface_setup_pko(interface);
 	}
 
 	result |= __cvmx_helper_global_setup_ipd();
@@ -977,6 +1254,7 @@ cvmx_helper_link_info_t cvmx_helper_link_get(int ipd_port)
 		/* Network links are not supported */
 		break;
 	case CVMX_HELPER_INTERFACE_MODE_XAUI:
+	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 		result = __cvmx_helper_xaui_link_get(ipd_port);
 		break;
 	case CVMX_HELPER_INTERFACE_MODE_GMII:
@@ -998,6 +1276,9 @@ cvmx_helper_link_info_t cvmx_helper_link_get(int ipd_port)
 	case CVMX_HELPER_INTERFACE_MODE_PICMG:
 		result = __cvmx_helper_sgmii_link_get(ipd_port);
 		break;
+	case CVMX_HELPER_INTERFACE_MODE_SRIO:
+		result = __cvmx_helper_srio_link_get(ipd_port);
+		break;
 	case CVMX_HELPER_INTERFACE_MODE_NPI:
 	case CVMX_HELPER_INTERFACE_MODE_LOOP:
 		/* Network links are not supported */
@@ -1032,6 +1313,7 @@ int cvmx_helper_link_set(int ipd_port, cvmx_helper_link_info_t link_info)
 	case CVMX_HELPER_INTERFACE_MODE_PCIE:
 		break;
 	case CVMX_HELPER_INTERFACE_MODE_XAUI:
+	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 		result = __cvmx_helper_xaui_link_set(ipd_port, link_info);
 		break;
 		/*
@@ -1049,6 +1331,9 @@ int cvmx_helper_link_set(int ipd_port, cvmx_helper_link_info_t link_info)
 	case CVMX_HELPER_INTERFACE_MODE_PICMG:
 		result = __cvmx_helper_sgmii_link_set(ipd_port, link_info);
 		break;
+	case CVMX_HELPER_INTERFACE_MODE_SRIO:
+		result = __cvmx_helper_srio_link_set(ipd_port, link_info);
+		break;
 	case CVMX_HELPER_INTERFACE_MODE_NPI:
 	case CVMX_HELPER_INTERFACE_MODE_LOOP:
 		break;
@@ -1087,11 +1372,13 @@ int cvmx_helper_configure_loopback(int ipd_port, int enable_internal,
 	switch (cvmx_helper_interface_get_mode(interface)) {
 	case CVMX_HELPER_INTERFACE_MODE_DISABLED:
 	case CVMX_HELPER_INTERFACE_MODE_PCIE:
+	case CVMX_HELPER_INTERFACE_MODE_SRIO:
 	case CVMX_HELPER_INTERFACE_MODE_SPI:
 	case CVMX_HELPER_INTERFACE_MODE_NPI:
 	case CVMX_HELPER_INTERFACE_MODE_LOOP:
 		break;
 	case CVMX_HELPER_INTERFACE_MODE_XAUI:
+	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 		result =
 		    __cvmx_helper_xaui_configure_loopback(ipd_port,
 							  enable_internal,
@@ -1114,3 +1401,5 @@ int cvmx_helper_configure_loopback(int ipd_port, int enable_internal,
 	}
 	return result;
 }
+
+#endif
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko.c b/arch/mips/cavium-octeon/executive/cvmx-pko.c
index f557084..3833802 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko.c
@@ -25,20 +25,370 @@
  * Contact Cavium Networks for more information
  ***********************license end**************************************/
 
-/*
- * Support library for the hardware Packet Output unit.
- */
-
 #include <asm/octeon/octeon.h>
-
 #include <asm/octeon/cvmx-config.h>
 #include <asm/octeon/cvmx-pko.h>
 #include <asm/octeon/cvmx-helper.h>
 
+#define CVMX_PKO_NQ_PER_PORT_MAX	32
+
+#ifdef CVMX_ENABLE_PKO_FUNCTIONS
 /**
  * Internal state of packet output
  */
 
+#define CVMX_PKO_FOR_EACH_PORT_BEGIN	do { 					\
+	int XIT_pko_port;							\
+	for (XIT_pko_port = 0; XIT_pko_port < CVMX_HELPER_CFG_MAX_PKO_PORT;	\
+	    XIT_pko_port++)							\
+	{									\
+		if (__cvmx_helper_cfg_pko_queue_base(XIT_pko_port) !=		\
+	            CVMX_HELPER_CFG_INVALID_VALUE)
+
+#define CVMX_PKO_FOR_EACH_PORT_END	} /* for */			\
+					} while (0)
+
+/*
+ * @INTERNAL
+ *
+ * Get INT for a port
+ *
+ * @param interface
+ * @param index
+ * @return the INT value on success and -1 on error
+ */
+static int __cvmx_pko_int(int interface, int index)
+{
+	cvmx_helper_cfg_assert(interface < CVMX_HELPER_CFG_MAX_IFACE);
+	cvmx_helper_cfg_assert(index >= 0);
+
+	switch (interface) {
+		case 0:
+			cvmx_helper_cfg_assert(index < 4);
+			return index;
+			break;
+		case 1:
+			cvmx_helper_cfg_assert(index == 0);
+			return 4;
+			break;
+		case 2:
+			cvmx_helper_cfg_assert(index < 4);
+			return index + 8;
+			break;
+		case 3:
+			cvmx_helper_cfg_assert(index < 4);
+			return index + 0xC;
+			break;
+		case 4:
+			cvmx_helper_cfg_assert(index < 4);
+			return index + 0x10;
+			break;
+		case 5:
+			cvmx_helper_cfg_assert(index < 256);
+			return 0x1C;
+			break;
+		case 6:
+			cvmx_helper_cfg_assert(index < 256);
+			return 0x1D;
+			break;
+		case 7:
+			cvmx_helper_cfg_assert(index < 32);
+			return 0x1E;
+			break;
+		case 8:
+			cvmx_helper_cfg_assert(index < 8);
+			return 0x1F;
+			break;
+	}
+
+	return -1;
+}
+
+int cvmx_pko_get_base_pko_port(int interface, int index)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_PKND))
+		return __cvmx_helper_cfg_pko_port_base(interface, index);
+	else
+		return cvmx_helper_get_ipd_port(interface, index);
+}
+
+/*
+ * Setup one-to-one mapping between PKO iport and eport.
+ * @INTERNAL
+ */
+static void __cvmx_pko_port_map_o68(void)
+{
+	int i;
+	int interface, index;
+	cvmx_helper_interface_mode_t mode;
+	union cvmx_pko_mem_iport_ptrs config;
+
+	/*
+	 * Initialize every iport with the invalid eid.
+	 */
+#define CVMX_O68_PKO_INVALID_EID	31
+	config.u64 = 0;
+	config.s.eid = CVMX_O68_PKO_INVALID_EID;
+	for (i = 0; i < CVMX_HELPER_CFG_MAX_PKO_PORT; i++) {
+		config.s.ipid = i;
+		cvmx_write_csr(CVMX_PKO_MEM_IPORT_PTRS, config.u64);
+	}
+
+	/*
+	 * Set up PKO_MEM_IPORT_PTRS
+	 */
+	CVMX_PKO_FOR_EACH_PORT_BEGIN {
+		interface = __cvmx_helper_cfg_pko_port_interface(XIT_pko_port);
+		index = __cvmx_helper_cfg_pko_port_index(XIT_pko_port);
+		mode = cvmx_helper_interface_get_mode(interface);
+
+		if (mode == CVMX_HELPER_INTERFACE_MODE_DISABLED)
+			continue;
+
+		config.s.ipid = XIT_pko_port;
+		config.s.qos_mask = 0xff;
+		config.s.crc = __cvmx_helper_get_has_fcs(interface);
+		config.s.min_pkt = __cvmx_helper_get_pko_padding(interface);
+		config.s.intr = __cvmx_pko_int(interface, index);
+		config.s.eid = __cvmx_helper_cfg_pko_port_eid(XIT_pko_port);
+		config.s.pipe = (mode == CVMX_HELPER_INTERFACE_MODE_LOOP) ? index :
+			XIT_pko_port;
+		cvmx_write_csr(CVMX_PKO_MEM_IPORT_PTRS, config.u64);
+	}
+	CVMX_PKO_FOR_EACH_PORT_END;
+}
+
+/*
+ * Configure queues for an internal port.
+ * @INTERNAL
+ * @param pko_port PKO internal port number
+ * Note: o68 only
+ */
+static void __cvmx_pko_iport_config(int pko_port)
+{
+	int queue, base_queue, num_queues;
+	int static_priority_base;
+	int static_priority_end;
+	union cvmx_pko_mem_iqueue_ptrs config;
+	uint64_t *buf_ptr = NULL;
+	uint64_t priorities[CVMX_PKO_NQ_PER_PORT_MAX] = {
+		[0 ... CVMX_PKO_NQ_PER_PORT_MAX - 1] = 8
+	};
+
+	static_priority_base = -1;
+	static_priority_end = -1;
+	base_queue = __cvmx_helper_cfg_pko_queue_base(pko_port);
+	num_queues = __cvmx_helper_cfg_pko_queue_num(pko_port);
+
+	/*
+	 * Give the user a chance to override the per queue priorities.
+	 */
+	if (cvmx_override_pko_queue_priority)
+		cvmx_override_pko_queue_priority(pko_port, &priorities[0]);
+
+	/*
+	 * static queue priority validation
+	 */
+	for (queue = 0; queue < num_queues; queue++) {
+		if (static_priority_base == -1 &&
+			priorities[queue] == CVMX_PKO_QUEUE_STATIC_PRIORITY)
+			static_priority_base = queue;
+
+		if (static_priority_base != -1 &&
+			static_priority_end == -1 &&
+			priorities[queue] != CVMX_PKO_QUEUE_STATIC_PRIORITY && queue)
+			static_priority_end = queue - 1;
+		else if (static_priority_base != -1 &&
+				 static_priority_end == -1 && queue == num_queues - 1)
+			static_priority_end = queue;	/* all queues are static priority */
+
+		/*
+		 * Check to make sure all static priority queues are contiguous.
+		 * Also catches some cases of static priorites not starting from
+		 * queue 0.
+		 */
+		if (static_priority_end != -1 &&
+			(int) queue > static_priority_end &&
+			priorities[queue] == CVMX_PKO_QUEUE_STATIC_PRIORITY) {
+			cvmx_dprintf("ERROR: __cvmx_pko_iport_config: Static priority "
+						 "queues aren't contiguous or don't start at base queue. "
+						 "q: %d, eq: %d\n", (int) queue, static_priority_end);
+		}
+		if (static_priority_base > 0) {
+			cvmx_dprintf("ERROR: __cvmx_pko_iport_config: Static priority "
+						 "queues don't start at base queue. sq: %d\n",
+						 static_priority_base);
+		}
+	}
+
+	/*
+	 * main loop to set the fields of CVMX_PKO_MEM_IQUEUE_PTRS for
+	 * each queue
+	 */
+	for (queue = 0; queue < num_queues; queue++) {
+		config.u64 = 0;
+		config.s.index = queue;
+		config.s.qid = base_queue + queue;
+		config.s.ipid = pko_port;
+		config.s.tail = (queue == (num_queues - 1));
+		config.s.s_tail = (queue == static_priority_end);
+		config.s.static_p = (static_priority_base >= 0);
+		config.s.static_q = (queue <= static_priority_end);
+
+		/*
+		 * Convert the priority into an enable bit field.
+		 * Try to space the bits out evenly so the packet
+		 * don't get grouped up.
+		 */
+		switch ((int) priorities[queue]) {
+			case 0:
+				config.s.qos_mask = 0x00;
+				break;
+			case 1:
+				config.s.qos_mask = 0x01;
+				break;
+			case 2:
+				config.s.qos_mask = 0x11;
+				break;
+			case 3:
+				config.s.qos_mask = 0x49;
+				break;
+			case 4:
+				config.s.qos_mask = 0x55;
+				break;
+			case 5:
+				config.s.qos_mask = 0x57;
+				break;
+			case 6:
+				config.s.qos_mask = 0x77;
+				break;
+			case 7:
+				config.s.qos_mask = 0x7f;
+				break;
+			case 8:
+				config.s.qos_mask = 0xff;
+				break;
+			case CVMX_PKO_QUEUE_STATIC_PRIORITY:
+				config.s.qos_mask = 0xff;
+				break;
+			default:
+				cvmx_dprintf("ERROR: __cvmx_pko_iport_config: "
+							 "Invalid priority %llu\n",
+							 (unsigned long long) priorities[queue]);
+				config.s.qos_mask = 0xff;
+				break;
+		}
+
+		/*
+		 * The command queues
+		 */
+		{
+			cvmx_cmd_queue_result_t cmd_res;
+
+			cmd_res =
+				cvmx_cmd_queue_initialize(CVMX_CMD_QUEUE_PKO
+										  (base_queue + queue),
+										  CVMX_PKO_MAX_QUEUE_DEPTH,
+										  CVMX_FPA_OUTPUT_BUFFER_POOL,
+										  (CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE -
+										   CVMX_PKO_COMMAND_BUFFER_SIZE_ADJUST
+										   * 8));
+
+			if (cmd_res != CVMX_CMD_QUEUE_SUCCESS) {
+				switch (cmd_res) {
+					case CVMX_CMD_QUEUE_NO_MEMORY:
+						cvmx_dprintf
+							("ERROR: __cvmx_pko_iport_config: Unable to allocate output buffer.");
+						break;
+					case CVMX_CMD_QUEUE_ALREADY_SETUP:
+						cvmx_dprintf
+							("ERROR: __cvmx_pko_iport_config: Port already setup");
+						break;
+					case CVMX_CMD_QUEUE_INVALID_PARAM:
+					default:
+						cvmx_dprintf
+							("ERROR: __cvmx_pko_iport_config: Command queue initialization failed.");
+						break;
+				}
+				cvmx_dprintf
+					(" pko_port%d base_queue%d num_queues%d queue%d.\n",
+					 pko_port, base_queue, num_queues, queue);
+			}
+
+			buf_ptr =
+				(uint64_t *)
+				cvmx_cmd_queue_buffer(CVMX_CMD_QUEUE_PKO(base_queue + queue));
+			config.s.buf_ptr = cvmx_ptr_to_phys(buf_ptr) >> 7;
+		}
+
+		CVMX_SYNCWS;
+		cvmx_write_csr(CVMX_PKO_MEM_IQUEUE_PTRS, config.u64);
+	}
+}
+
+static void __cvmx_pko_queue_alloc_o68(void)
+{
+	CVMX_PKO_FOR_EACH_PORT_BEGIN {
+		__cvmx_pko_iport_config(XIT_pko_port);
+	} CVMX_PKO_FOR_EACH_PORT_END;
+}
+
+static int __cvmx_pko_memory_per_engine_o68(int engine)
+{
+	/* CN68XX has 40KB to devide between the engines in 2KB chunks */
+	int max_engine;
+	int size_per_engine;
+	int size;
+
+	max_engine = __cvmx_helper_cfg_pko_max_engine();
+	size_per_engine = 40 / 2 / max_engine;
+
+	if (engine >= max_engine) {
+		/* Unused engines get no space */
+		size = 0;
+	}
+	else if (engine == max_engine - 1) {
+		/* The last engine gets all the space lost by rounding. This means
+		   the ILK gets the most space */
+		size = 40 / 2 - engine * size_per_engine;
+	}
+	else {
+		/* All other engines get the same space */
+		size = size_per_engine;
+	}
+
+	return size;
+}
+
+int __cvmx_pko_get_pipe(int interface, int index)
+{
+	/*
+	 * the loopback ports do not have pipes
+	 */
+	if (cvmx_helper_interface_get_mode(interface) ==
+		CVMX_HELPER_INTERFACE_MODE_LOOP)
+		return -1;
+	/*
+	 * We use pko_port as the pipe. See __cvmx_pko_port_map_o68().
+	 */
+	return cvmx_helper_get_pko_port(interface, index);
+}
+
+static void __cvmx_pko_chip_init(void)
+{
+	int i;
+	uint64_t priority = 8;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		__cvmx_pko_port_map_o68();
+		__cvmx_pko_queue_alloc_o68();
+	}
+	else
+		for (i = 0; i < CVMX_PKO_MAX_OUTPUT_QUEUES; i++)
+			cvmx_pko_config_port(CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID, i, 1,
+					     &priority);
+}
+
 /**
  * Call before any other calls to initialize the packet
  * output system.  This does chip global config, and should only be
@@ -47,9 +397,8 @@
 
 void cvmx_pko_initialize_global(void)
 {
-	int i;
-	uint64_t priority = 8;
 	union cvmx_pko_reg_cmd_buf config;
+	int i;
 
 	/*
 	 * Set the size of the PKO command buffers to an odd number of
@@ -62,9 +411,8 @@ void cvmx_pko_initialize_global(void)
 
 	cvmx_write_csr(CVMX_PKO_REG_CMD_BUF, config.u64);
 
-	for (i = 0; i < CVMX_PKO_MAX_OUTPUT_QUEUES; i++)
-		cvmx_pko_config_port(CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID, i, 1,
-				     &priority);
+	/* chip-specific setup */
+	__cvmx_pko_chip_init();
 
 	/*
 	 * If we aren't using all of the queues optimize PKO's
@@ -72,23 +420,60 @@ void cvmx_pko_initialize_global(void)
 	 */
 	if (OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)
 	    || OCTEON_IS_MODEL(OCTEON_CN56XX)
-	    || OCTEON_IS_MODEL(OCTEON_CN52XX)) {
+	    || OCTEON_IS_MODEL(OCTEON_CN52XX)
+	    || OCTEON_IS_MODEL(OCTEON_CN6XXX)) {
+
 		int num_interfaces = cvmx_helper_get_number_of_interfaces();
 		int last_port =
-		    cvmx_helper_get_last_ipd_port(num_interfaces - 1);
+			    cvmx_helper_get_last_ipd_port(num_interfaces - 1);
+
 		int max_queues =
-		    cvmx_pko_get_base_queue(last_port) +
-		    cvmx_pko_get_num_queues(last_port);
+			    cvmx_pko_get_base_queue(last_port) +
+			    cvmx_pko_get_num_queues(last_port);
+
 		if (OCTEON_IS_MODEL(OCTEON_CN38XX)) {
 			if (max_queues <= 32)
 				cvmx_write_csr(CVMX_PKO_REG_QUEUE_MODE, 2);
 			else if (max_queues <= 64)
 				cvmx_write_csr(CVMX_PKO_REG_QUEUE_MODE, 1);
 		} else {
-			if (max_queues <= 64)
+			if (OCTEON_IS_MODEL(OCTEON_CN68XX) && max_queues <= 32)
+				cvmx_write_csr(CVMX_PKO_REG_QUEUE_MODE, 3);
+			else if (max_queues <= 64)
 				cvmx_write_csr(CVMX_PKO_REG_QUEUE_MODE, 2);
 			else if (max_queues <= 128)
 				cvmx_write_csr(CVMX_PKO_REG_QUEUE_MODE, 1);
+			else
+				cvmx_write_csr(CVMX_PKO_REG_QUEUE_MODE, 0);
+			if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+				for (i = 0; i < 2; i++) {
+					union cvmx_pko_reg_engine_storagex engine_storage;
+
+#define PKO_ASSIGN_ENGINE_STORAGE(index)                        \
+        engine_storage.s.engine##index =                        \
+            __cvmx_pko_memory_per_engine_o68(16 * i + (index))
+					engine_storage.u64 = 0;
+					PKO_ASSIGN_ENGINE_STORAGE(0);
+					PKO_ASSIGN_ENGINE_STORAGE(1);
+					PKO_ASSIGN_ENGINE_STORAGE(2);
+					PKO_ASSIGN_ENGINE_STORAGE(3);
+					PKO_ASSIGN_ENGINE_STORAGE(4);
+					PKO_ASSIGN_ENGINE_STORAGE(5);
+					PKO_ASSIGN_ENGINE_STORAGE(6);
+					PKO_ASSIGN_ENGINE_STORAGE(7);
+					PKO_ASSIGN_ENGINE_STORAGE(8);
+					PKO_ASSIGN_ENGINE_STORAGE(9);
+					PKO_ASSIGN_ENGINE_STORAGE(10);
+					PKO_ASSIGN_ENGINE_STORAGE(11);
+					PKO_ASSIGN_ENGINE_STORAGE(12);
+					PKO_ASSIGN_ENGINE_STORAGE(13);
+					PKO_ASSIGN_ENGINE_STORAGE(14);
+					PKO_ASSIGN_ENGINE_STORAGE(15);
+					cvmx_write_csr(CVMX_PKO_REG_ENGINE_STORAGEX(i),
+								   engine_storage.u64);
+				}
+			}
+
 		}
 	}
 }
@@ -163,22 +548,33 @@ void cvmx_pko_shutdown(void)
 
 	cvmx_pko_disable();
 
-	for (queue = 0; queue < CVMX_PKO_MAX_OUTPUT_QUEUES; queue++) {
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		union cvmx_pko_mem_iqueue_ptrs config;
 		config.u64 = 0;
-		config.s.tail = 1;
-		config.s.index = 0;
-		config.s.port = CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID;
-		config.s.queue = queue & 0x7f;
-		config.s.qos_mask = 0;
-		config.s.buf_ptr = 0;
-		if (!OCTEON_IS_MODEL(OCTEON_CN3XXX)) {
-			union cvmx_pko_reg_queue_ptrs1 config1;
-			config1.u64 = 0;
-			config1.s.qid7 = queue >> 7;
-			cvmx_write_csr(CVMX_PKO_REG_QUEUE_PTRS1, config1.u64);
+		for (queue = 0; queue < CVMX_PKO_MAX_OUTPUT_QUEUES; queue++) {
+			config.s.qid = queue;
+			cvmx_write_csr(CVMX_PKO_MEM_IQUEUE_PTRS, config.u64);
+			cvmx_cmd_queue_shutdown(CVMX_CMD_QUEUE_PKO(queue));
+		}
+	}
+	else {
+		for (queue = 0; queue < CVMX_PKO_MAX_OUTPUT_QUEUES; queue++) {
+			config.u64 = 0;
+			config.s.tail = 1;
+			config.s.index = 0;
+			config.s.port = CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID;
+			config.s.queue = queue & 0x7f;
+			config.s.qos_mask = 0;
+			config.s.buf_ptr = 0;
+			if (!OCTEON_IS_MODEL(OCTEON_CN3XXX)) {
+				union cvmx_pko_reg_queue_ptrs1 config1;
+				config1.u64 = 0;
+				config1.s.qid7 = queue >> 7;
+				cvmx_write_csr(CVMX_PKO_REG_QUEUE_PTRS1, config1.u64);
+			}
+			cvmx_write_csr(CVMX_PKO_MEM_QUEUE_PTRS, config.u64);
+			cvmx_cmd_queue_shutdown(CVMX_CMD_QUEUE_PKO(queue));
 		}
-		cvmx_write_csr(CVMX_PKO_MEM_QUEUE_PTRS, config.u64);
-		cvmx_cmd_queue_shutdown(CVMX_CMD_QUEUE_PKO(queue));
 	}
 	__cvmx_pko_reset();
 }
@@ -211,10 +607,19 @@ cvmx_pko_status_t cvmx_pko_config_port(uint64_t port, uint64_t base_queue,
 	int static_priority_base = -1;
 	int static_priority_end = -1;
 
+	extern void dump_stack(void);
+
+	printk("<0> %s: ipd_port[%lld], base_queue = %lld, num_queue = %lld\n", __FUNCTION__, port,
+                base_queue, num_queues);
+
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		return CVMX_PKO_SUCCESS;
+
 	if ((port >= CVMX_PKO_NUM_OUTPUT_PORTS)
 	    && (port != CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID)) {
 		cvmx_dprintf("ERROR: cvmx_pko_config_port: Invalid port %llu\n",
 			     (unsigned long long)port);
+		dump_stack();
 		return CVMX_PKO_INVALID_PORT;
 	}
 
@@ -273,11 +678,6 @@ cvmx_pko_status_t cvmx_pko_config_port(uint64_t port, uint64_t base_queue,
 				static_priority_base);
 			return CVMX_PKO_INVALID_PRIORITY;
 		}
-#if 0
-		cvmx_dprintf("Port %d: Static priority queue base: %d, "
-			     "end: %d\n", port,
-			static_priority_base, static_priority_end);
-#endif
 	}
 	/*
 	 * At this point, static_priority_base and static_priority_end
@@ -413,23 +813,37 @@ cvmx_pko_status_t cvmx_pko_config_port(uint64_t port, uint64_t base_queue,
  */
 void cvmx_pko_show_queue_map()
 {
-	int core, port;
-	int pko_output_ports = 36;
-
-	cvmx_dprintf("port");
-	for (port = 0; port < pko_output_ports; port++)
-		cvmx_dprintf("%3d ", port);
-	cvmx_dprintf("\n");
-
-	for (core = 0; core < CVMX_MAX_CORES; core++) {
-		cvmx_dprintf("\n%2d: ", core);
-		for (port = 0; port < pko_output_ports; port++) {
-			cvmx_dprintf("%3d ",
-				     cvmx_pko_get_base_queue_per_core(port,
-								      core));
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		CVMX_PKO_FOR_EACH_PORT_BEGIN {
+			cvmx_dprintf
+				("pko_port %d (interface%d index%d) has %d queues (queue base = %d)\n",
+				 XIT_pko_port,
+				 __cvmx_helper_cfg_pko_port_interface(XIT_pko_port),
+				 __cvmx_helper_cfg_pko_port_index(XIT_pko_port),
+				 __cvmx_helper_cfg_pko_queue_num(XIT_pko_port),
+				 __cvmx_helper_cfg_pko_queue_base(XIT_pko_port));
 		}
+		CVMX_PKO_FOR_EACH_PORT_END;
+	}
+	else {
+		int core, port;
+		int pko_output_ports = 36;
+
+		cvmx_dprintf("port");
+		for (port = 0; port < pko_output_ports; port++)
+			cvmx_dprintf("%3d ", port);
+		cvmx_dprintf("\n");
+
+		for (core = 0; core < CVMX_MAX_CORES; core++) {
+			cvmx_dprintf("\n%2d: ", core);
+			for (port = 0; port < pko_output_ports; port++) {
+				cvmx_dprintf("%3d ",
+					     cvmx_pko_get_base_queue_per_core(port,
+									      core));
+			}
+		}
+		cvmx_dprintf("\n");
 	}
-	cvmx_dprintf("\n");
 }
 #endif
 
@@ -504,3 +918,5 @@ int cvmx_pko_rate_limit_bits(int port, uint64_t bits_s, int burst)
 	cvmx_write_csr(CVMX_PKO_MEM_PORT_RATE1, pko_mem_port_rate1.u64);
 	return 0;
 }
+
+#endif
-- 
1.7.9.7

