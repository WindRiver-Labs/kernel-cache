From a6a4d02eeb99eca6ed259a040f7e658558a62faf Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 24 Aug 2012 18:10:53 +0800
Subject: [PATCH 23/27] Replace slower references to thread pointer

With this optimization, the kernel can dynamically replace slower
references to the thread pointer with fast accesses. This involves
replacing userspace instructions at runtime, so it may not work with
all programs. If you use an older compiler that does not provide the
ability to support FAST_ACCESS_TO_THREAD_POINTER, this option may
allow you to receive most of the benefit of direct access to the
thread pointer. It may also cause programs to fail.

Instruction replacement is disabled on boot. It can be controlled by
writing a mode to /sys/module/traps/parameters/thread_pointer_mode.
The supported modes are:

0 - Use the normal kernel emulation without any changes.
1 - Replace emulated instructions with direct accesses to the
    thread register.
2 - Replace emulated instructions and log the replacement PC.
3 - Replace emulated instructions with break instructions.
    This will cause programs to fail, but makes it easy to
    stop gdb on the instruction.

Based on SDK 2.3.0-427

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/Kconfig |   27 ++++++++++++++++
 arch/mips/kernel/traps.c        |   66 +++++++++++++++++++++++++++++++++++++--
 2 files changed, 91 insertions(+), 2 deletions(-)

diff --git a/arch/mips/cavium-octeon/Kconfig b/arch/mips/cavium-octeon/Kconfig
index f9e275a..929018e 100644
--- a/arch/mips/cavium-octeon/Kconfig
+++ b/arch/mips/cavium-octeon/Kconfig
@@ -41,6 +41,33 @@ config CAVIUM_OCTEON_CVMSEG_SIZE
 	  legally range is from zero to 54 cache blocks (i.e. CVMSEG LM is
 	  between zero and 6192 bytes).
 
+config REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
+        bool "Support dynamically replacing emulated thread pointer accesses"
+        depends on FAST_ACCESS_TO_THREAD_POINTER
+        default "y"
+        help
+          When this option is set, the kernel can dynamically replace
+          slower references to the thread pointer with fast
+          accesses. This involves replacing userspace instructions at
+          runtime, so it may not work with all programs. If you use an
+          older compiler that does not provide the ability to support
+          FAST_ACCESS_TO_THREAD_POINTER, this option may allow you to
+          receive most of the benefit of direct access to the thread
+          pointer. It may also cause programs to fail.
+
+          Instruction replacement is disabled on boot. It can be
+          controlled by writing a mode to
+          /sys/module/traps/parameters/thread_pointer_mode.  The
+          supported modes are:
+
+          0 - Use the normal kernel emulation without any changes.
+          1 - Replace emulated instructions with direct accesses to the thread
+                register.
+          2 - Replace emulated instructions and log the replacement PC.
+          3 - Replace emulated instructions with break instructions. This will
+                cause programs to fail, but makes it easy to stop gdb on the
+                instruction.
+
 config CAVIUM_OCTEON_LOCK_L2
 	bool "Lock often used kernel code in the L2"
 	default "y"
diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index bfe05b0..9929643 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -99,6 +99,17 @@ void (*board_ejtag_handler_setup)(void);
 void (*board_bind_eic_interrupt)(int irq, int regset);
 void (*board_ebase_setup)(void);
 
+#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
+/*	0 - Use the normal kernel emulation without any changes.
+	1 - Replace emulated instructions with direct accesses to the thread
+		register.
+	2 - Replace emulated instructions and log the replacement PC.
+	3 - Replace emulated instructions with break instructions. This will
+		cause programs to fail, but makes it easy to stop gdb on the
+		instruction. */
+static int thread_pointer_mode = 0;
+module_param(thread_pointer_mode, int, 0644);
+#endif
 
 static void show_raw_backtrace(unsigned long reg29)
 {
@@ -867,6 +878,53 @@ out_sigsegv:
 	force_sig(SIGSEGV, current);
 }
 
+static void __handle_thread_pointer_mode(struct pt_regs *regs, unsigned int opcode, unsigned int __user *epc)
+{
+#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
+	if ((opcode & OPCODE) == SPEC3 && (opcode & FUNC) == RDHWR) {
+		int rd = (opcode & RD) >> 11;
+		int rt = (opcode & RT) >> 16;
+		switch (rd) {
+		case 29:
+			if (thread_pointer_mode) {
+				/* move [rt], k0 */
+				unsigned int new_instruction
+					= 0x00000025 | (26 << 21) | (rt << 11);
+				if (thread_pointer_mode == 3)
+					/* break */
+					new_instruction = 0x0000000d;
+				if (access_process_vm(current,
+					    (unsigned long)epc,
+					    &new_instruction,
+					    sizeof(new_instruction), 1)
+				    != sizeof(new_instruction))
+					printk(KERN_ERR \
+			"Failed to replaced emulated RDHWR at PC=%p\n", epc);
+				if (thread_pointer_mode == 2)
+					printk(KERN_INFO \
+			"Replaced emulated RDHWR at PC=%p with \"move $%d, k0\"\n"
+					, epc, rt);
+				else if (thread_pointer_mode == 3)
+					printk(KERN_INFO \
+			"Replaced emulated RDHWR at PC=%p with \"break\"\n", epc);
+			}
+			break;
+		}
+
+	} else if (opcode == (0x00000025 | (26 << 21) | (3 << 11))) {
+		/*
+		 * Its a 'move v1, k0' instruction.
+		 * We need to flush the icache, not emulate an
+		 * instruction. The EPC is wrong, so we need to put it
+		 * back to the old instruction.
+		 */
+		/*printk(KERN_INFO "Already replaced emulated RDHWR at PC=%p\n", epc); */
+		regs->cp0_epc = (unsigned long)epc;
+		flush_cache_sigtramp((unsigned long)epc);
+	}
+#endif
+}
+
 asmlinkage void do_tr(struct pt_regs *regs)
 {
 	unsigned int opcode, tcode = 0;
@@ -907,8 +965,10 @@ asmlinkage void do_ri(struct pt_regs *regs)
 	if (!cpu_has_llsc && status < 0)
 		status = simulate_llsc(regs, opcode);
 
-	if (status < 0)
+	if (status < 0) {
+		__handle_thread_pointer_mode(regs, opcode, epc);
 		status = simulate_rdhwr(regs, opcode);
+	}
 
 	if (status < 0)
 		status = simulate_sync(regs, opcode);
@@ -1017,8 +1077,10 @@ asmlinkage void do_cpu(struct pt_regs *regs)
 		if (!cpu_has_llsc && status < 0)
 			status = simulate_llsc(regs, opcode);
 
-		if (status < 0)
+		if (status < 0) {
+			__handle_thread_pointer_mode(regs, opcode, epc);
 			status = simulate_rdhwr(regs, opcode);
+		}
 
 		if (status < 0)
 			status = SIGILL;
-- 
1.7.9.7

