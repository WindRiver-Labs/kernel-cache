From b2c46a4e6a855fc88d0fa8f0640d638c3adab7f5 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Thu, 30 Aug 2012 17:44:50 +0800
Subject: [PATCH 24/27] update l2c cache lock function

Based on SDK 2.3.0-427

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-bootmem.c |   18 +
 arch/mips/cavium-octeon/executive/cvmx-l2c.c     |  864 ++++++++++++++--------
 arch/mips/cavium-octeon/setup.c                  |   83 ++-
 arch/mips/include/asm/octeon/cvmx-bootmem.h      |    8 +
 arch/mips/include/asm/octeon/cvmx-l2c.h          |    8 +
 arch/mips/include/asm/octeon/octeon-model.h      |   15 +-
 arch/mips/kernel/setup.c                         |   27 +-
 7 files changed, 721 insertions(+), 302 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-bootmem.c b/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
index fdf5f19..768ee18 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
@@ -518,6 +518,24 @@ bootmem_free_done:
 
 }
 
+uint64_t cvmx_bootmem_phy_available_mem(uint64_t min_block_size)
+{
+	uint64_t addr;
+	uint64_t available_mem = 0;
+
+	cvmx_bootmem_lock();
+	addr = cvmx_bootmem_desc->head_addr;
+	while (addr)
+	{
+		if (cvmx_bootmem_phy_get_size(addr) >= min_block_size)
+			available_mem += cvmx_bootmem_phy_get_size(addr);
+		addr = cvmx_bootmem_phy_get_next(addr);
+	}
+	cvmx_bootmem_unlock();
+
+	return(available_mem);
+}
+
 struct cvmx_bootmem_named_block_desc *
 	cvmx_bootmem_phy_named_block_find(char *name, uint32_t flags)
 {
diff --git a/arch/mips/cavium-octeon/executive/cvmx-l2c.c b/arch/mips/cavium-octeon/executive/cvmx-l2c.c
index d38246e..24594cd 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-l2c.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-l2c.c
@@ -1,35 +1,42 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
  *
- * Contact: support@caviumnetworks.com
- * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2010 Cavium Networks
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
  *
- * This file is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License, Version 2, as
- * published by the Free Software Foundation.
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
  *
- * This file is distributed in the hope that it will be useful, but
- * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
- * NONINFRINGEMENT.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this file; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
- * or visit http://www.gnu.org/licenses/.
- *
- * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
  ***********************license end**************************************/
 
-/*
- * Implementation of the Level 2 Cache (L2C) control,
- * measurement, and debugging facilities.
- */
-
 #include <asm/octeon/cvmx.h>
 #include <asm/octeon/cvmx-l2c.h>
 #include <asm/octeon/cvmx-spinlock.h>
@@ -42,7 +49,7 @@
  * if multiple applications or operating systems are running, then it
  * is up to the user program to coordinate between them.
  */
-cvmx_spinlock_t cvmx_l2c_spinlock;
+CVMX_SHARED cvmx_spinlock_t cvmx_l2c_spinlock;
 
 int cvmx_l2c_get_core_way_partition(uint32_t core)
 {
@@ -52,8 +59,8 @@ int cvmx_l2c_get_core_way_partition(uint32_t core)
 	if (core >= cvmx_octeon_num_cores())
 		return -1;
 
-	if (OCTEON_IS_MODEL(OCTEON_CN63XX))
-		return cvmx_read_csr(CVMX_L2C_WPAR_PPX(core)) & 0xffff;
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX))
+		return (cvmx_read_csr(CVMX_L2C_WPAR_PPX(core)) & 0xffff);
 
 	/*
 	 * Use the lower two bits of the coreNumber to determine the
@@ -67,14 +74,14 @@ int cvmx_l2c_get_core_way_partition(uint32_t core)
 	 */
 
 	switch (core & 0xC) {
-	case 0x0:
-		return (cvmx_read_csr(CVMX_L2C_SPAR0) & (0xFF << field)) >> field;
-	case 0x4:
-		return (cvmx_read_csr(CVMX_L2C_SPAR1) & (0xFF << field)) >> field;
-	case 0x8:
-		return (cvmx_read_csr(CVMX_L2C_SPAR2) & (0xFF << field)) >> field;
-	case 0xC:
-		return (cvmx_read_csr(CVMX_L2C_SPAR3) & (0xFF << field)) >> field;
+		case 0x0:
+			return (cvmx_read_csr(CVMX_L2C_SPAR0) & (0xFF << field)) >> field;
+		case 0x4:
+			return (cvmx_read_csr(CVMX_L2C_SPAR1) & (0xFF << field)) >> field;
+		case 0x8:
+			return (cvmx_read_csr(CVMX_L2C_SPAR2) & (0xFF << field)) >> field;
+		case 0xC:
+			return (cvmx_read_csr(CVMX_L2C_SPAR3) & (0xFF << field)) >> field;
 	}
 	return 0;
 }
@@ -89,14 +96,15 @@ int cvmx_l2c_set_core_way_partition(uint32_t core, uint32_t mask)
 	mask &= valid_mask;
 
 	/* A UMSK setting which blocks all L2C Ways is an error on some chips */
-	if (mask == valid_mask && !OCTEON_IS_MODEL(OCTEON_CN63XX))
+	if (mask == valid_mask
+		&& (OCTEON_IS_MODEL(OCTEON_CN3XXX) || OCTEON_IS_MODEL(OCTEON_CN5XXX)))
 		return -1;
 
 	/* Validate the core number */
 	if (core >= cvmx_octeon_num_cores())
 		return -1;
 
-	if (OCTEON_IS_MODEL(OCTEON_CN63XX)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX)) {
 		cvmx_write_csr(CVMX_L2C_WPAR_PPX(core), mask);
 		return 0;
 	}
@@ -113,26 +121,26 @@ int cvmx_l2c_set_core_way_partition(uint32_t core, uint32_t mask)
 	 *
 	 */
 	switch (core & 0xC) {
-	case 0x0:
-		cvmx_write_csr(CVMX_L2C_SPAR0,
-			       (cvmx_read_csr(CVMX_L2C_SPAR0) & ~(0xFF << field)) |
-			       mask << field);
-		break;
-	case 0x4:
-		cvmx_write_csr(CVMX_L2C_SPAR1,
-			       (cvmx_read_csr(CVMX_L2C_SPAR1) & ~(0xFF << field)) |
-			       mask << field);
-		break;
-	case 0x8:
-		cvmx_write_csr(CVMX_L2C_SPAR2,
-			       (cvmx_read_csr(CVMX_L2C_SPAR2) & ~(0xFF << field)) |
-			       mask << field);
-		break;
-	case 0xC:
-		cvmx_write_csr(CVMX_L2C_SPAR3,
-			       (cvmx_read_csr(CVMX_L2C_SPAR3) & ~(0xFF << field)) |
-			       mask << field);
-		break;
+		case 0x0:
+			cvmx_write_csr(CVMX_L2C_SPAR0,
+						   (cvmx_read_csr(CVMX_L2C_SPAR0) & ~(0xFF << field))
+						   | mask << field);
+			break;
+		case 0x4:
+			cvmx_write_csr(CVMX_L2C_SPAR1,
+						   (cvmx_read_csr(CVMX_L2C_SPAR1) & ~(0xFF << field))
+						   | mask << field);
+			break;
+		case 0x8:
+			cvmx_write_csr(CVMX_L2C_SPAR2,
+						   (cvmx_read_csr(CVMX_L2C_SPAR2) & ~(0xFF << field))
+						   | mask << field);
+			break;
+		case 0xC:
+			cvmx_write_csr(CVMX_L2C_SPAR3,
+						   (cvmx_read_csr(CVMX_L2C_SPAR3) & ~(0xFF << field))
+						   | mask << field);
+			break;
 	}
 	return 0;
 }
@@ -145,27 +153,52 @@ int cvmx_l2c_set_hw_way_partition(uint32_t mask)
 	mask &= valid_mask;
 
 	/* A UMSK setting which blocks all L2C Ways is an error on some chips */
-	if (mask == valid_mask  && !OCTEON_IS_MODEL(OCTEON_CN63XX))
+	if (mask == valid_mask
+		&& (OCTEON_IS_MODEL(OCTEON_CN3XXX) || OCTEON_IS_MODEL(OCTEON_CN5XXX)))
 		return -1;
 
-	if (OCTEON_IS_MODEL(OCTEON_CN63XX))
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX))
 		cvmx_write_csr(CVMX_L2C_WPAR_IOBX(0), mask);
 	else
 		cvmx_write_csr(CVMX_L2C_SPAR4,
-			       (cvmx_read_csr(CVMX_L2C_SPAR4) & ~0xFF) | mask);
+					   (cvmx_read_csr(CVMX_L2C_SPAR4) & ~0xFF) | mask);
 	return 0;
 }
 
 int cvmx_l2c_get_hw_way_partition(void)
 {
-	if (OCTEON_IS_MODEL(OCTEON_CN63XX))
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX))
 		return cvmx_read_csr(CVMX_L2C_WPAR_IOBX(0)) & 0xffff;
 	else
 		return cvmx_read_csr(CVMX_L2C_SPAR4) & (0xFF);
 }
 
+int cvmx_l2c_set_hw_way_partition2(uint32_t mask)
+{
+	uint32_t valid_mask;
+
+	if (!OCTEON_IS_MODEL(OCTEON_CN68XX))
+		return -1;
+
+	valid_mask = (0x1 << cvmx_l2c_get_num_assoc()) - 1;
+	mask &= valid_mask;
+	cvmx_write_csr(CVMX_L2C_WPAR_IOBX(1), mask);
+	return 0;
+}
+
+int cvmx_l2c_get_hw_way_partition2(void)
+{
+	if (!OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		cvmx_dprintf("only one IOB on this chip");
+		return -1;
+	}
+	return cvmx_read_csr(CVMX_L2C_WPAR_IOBX(1)) & 0xffff;
+}
+
+
+
 void cvmx_l2c_config_perf(uint32_t counter, enum cvmx_l2c_event event,
-			  uint32_t clear_on_read)
+						  uint32_t clear_on_read)
 {
 	if (OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN3XXX)) {
 		union cvmx_l2c_pfctl pfctl;
@@ -173,105 +206,110 @@ void cvmx_l2c_config_perf(uint32_t counter, enum cvmx_l2c_event event,
 		pfctl.u64 = cvmx_read_csr(CVMX_L2C_PFCTL);
 
 		switch (counter) {
-		case 0:
-			pfctl.s.cnt0sel = event;
-			pfctl.s.cnt0ena = 1;
-			pfctl.s.cnt0rdclr = clear_on_read;
-			break;
-		case 1:
-			pfctl.s.cnt1sel = event;
-			pfctl.s.cnt1ena = 1;
-			pfctl.s.cnt1rdclr = clear_on_read;
-			break;
-		case 2:
-			pfctl.s.cnt2sel = event;
-			pfctl.s.cnt2ena = 1;
-			pfctl.s.cnt2rdclr = clear_on_read;
-			break;
-		case 3:
-		default:
-			pfctl.s.cnt3sel = event;
-			pfctl.s.cnt3ena = 1;
-			pfctl.s.cnt3rdclr = clear_on_read;
-			break;
+			case 0:
+				pfctl.s.cnt0sel = event;
+				pfctl.s.cnt0ena = 1;
+				pfctl.s.cnt0rdclr = clear_on_read;
+				break;
+			case 1:
+				pfctl.s.cnt1sel = event;
+				pfctl.s.cnt1ena = 1;
+				pfctl.s.cnt1rdclr = clear_on_read;
+				break;
+			case 2:
+				pfctl.s.cnt2sel = event;
+				pfctl.s.cnt2ena = 1;
+				pfctl.s.cnt2rdclr = clear_on_read;
+				break;
+			case 3:
+			default:
+				pfctl.s.cnt3sel = event;
+				pfctl.s.cnt3ena = 1;
+				pfctl.s.cnt3rdclr = clear_on_read;
+				break;
 		}
 
 		cvmx_write_csr(CVMX_L2C_PFCTL, pfctl.u64);
-	} else {
+	}
+	else {
 		union cvmx_l2c_tadx_prf l2c_tadx_prf;
 		int tad;
 
 		cvmx_dprintf("L2C performance counter events are different for this chip, mapping 'event' to cvmx_l2c_tad_event_t\n");
-		if (clear_on_read)
+
+		if(clear_on_read)
 			cvmx_dprintf("L2C counters don't support clear on read for this chip\n");
 
 		l2c_tadx_prf.u64 = cvmx_read_csr(CVMX_L2C_TADX_PRF(0));
 
 		switch (counter) {
-		case 0:
-			l2c_tadx_prf.s.cnt0sel = event;
-			break;
-		case 1:
-			l2c_tadx_prf.s.cnt1sel = event;
-			break;
-		case 2:
-			l2c_tadx_prf.s.cnt2sel = event;
-			break;
-		default:
-		case 3:
-			l2c_tadx_prf.s.cnt3sel = event;
-			break;
+			case 0:
+				l2c_tadx_prf.s.cnt0sel = event;
+				break;
+			case 1:
+				l2c_tadx_prf.s.cnt1sel = event;
+				break;
+			case 2:
+				l2c_tadx_prf.s.cnt2sel = event;
+				break;
+			default:
+			case 3:
+				l2c_tadx_prf.s.cnt3sel = event;
+				break;
 		}
 		for (tad = 0; tad < CVMX_L2C_TADS; tad++)
-			cvmx_write_csr(CVMX_L2C_TADX_PRF(tad),
-				       l2c_tadx_prf.u64);
+			cvmx_write_csr(CVMX_L2C_TADX_PRF(tad), l2c_tadx_prf.u64);
 	}
 }
 
 uint64_t cvmx_l2c_read_perf(uint32_t counter)
 {
 	switch (counter) {
-	case 0:
-		if (OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN3XXX))
-			return cvmx_read_csr(CVMX_L2C_PFC0);
-		else {
-			uint64_t counter = 0;
-			int tad;
-			for (tad = 0; tad < CVMX_L2C_TADS; tad++)
-				counter += cvmx_read_csr(CVMX_L2C_TADX_PFC0(tad));
-			return counter;
-		}
-	case 1:
-		if (OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN3XXX))
-			return cvmx_read_csr(CVMX_L2C_PFC1);
-		else {
-			uint64_t counter = 0;
-			int tad;
-			for (tad = 0; tad < CVMX_L2C_TADS; tad++)
-				counter += cvmx_read_csr(CVMX_L2C_TADX_PFC1(tad));
-			return counter;
-		}
-	case 2:
-		if (OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN3XXX))
-			return cvmx_read_csr(CVMX_L2C_PFC2);
-		else {
-			uint64_t counter = 0;
-			int tad;
-			for (tad = 0; tad < CVMX_L2C_TADS; tad++)
-				counter += cvmx_read_csr(CVMX_L2C_TADX_PFC2(tad));
-			return counter;
-		}
-	case 3:
-	default:
-		if (OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN3XXX))
-			return cvmx_read_csr(CVMX_L2C_PFC3);
-		else {
-			uint64_t counter = 0;
-			int tad;
-			for (tad = 0; tad < CVMX_L2C_TADS; tad++)
-				counter += cvmx_read_csr(CVMX_L2C_TADX_PFC3(tad));
-			return counter;
-		}
+		case 0:
+			if (OCTEON_IS_MODEL(OCTEON_CN5XXX)
+				|| OCTEON_IS_MODEL(OCTEON_CN3XXX))
+				return cvmx_read_csr(CVMX_L2C_PFC0);
+			else {
+				uint64_t counter = 0;
+				int tad;
+				for (tad = 0; tad < CVMX_L2C_TADS; tad++)
+					counter += cvmx_read_csr(CVMX_L2C_TADX_PFC0(tad));
+				return counter;
+			}
+		case 1:
+			if (OCTEON_IS_MODEL(OCTEON_CN5XXX)
+				|| OCTEON_IS_MODEL(OCTEON_CN3XXX))
+				return cvmx_read_csr(CVMX_L2C_PFC1);
+			else {
+				uint64_t counter = 0;
+				int tad;
+				for (tad = 0; tad < CVMX_L2C_TADS; tad++)
+					counter += cvmx_read_csr(CVMX_L2C_TADX_PFC1(tad));
+				return counter;
+			}
+		case 2:
+			if (OCTEON_IS_MODEL(OCTEON_CN5XXX)
+				|| OCTEON_IS_MODEL(OCTEON_CN3XXX))
+				return cvmx_read_csr(CVMX_L2C_PFC2);
+			else {
+				uint64_t counter = 0;
+				int tad;
+				for (tad = 0; tad < CVMX_L2C_TADS; tad++)
+					counter += cvmx_read_csr(CVMX_L2C_TADX_PFC2(tad));
+				return counter;
+			}
+		case 3:
+		default:
+			if (OCTEON_IS_MODEL(OCTEON_CN5XXX)
+				|| OCTEON_IS_MODEL(OCTEON_CN3XXX))
+				return cvmx_read_csr(CVMX_L2C_PFC3);
+			else {
+				uint64_t counter = 0;
+				int tad;
+				for (tad = 0; tad < CVMX_L2C_TADS; tad++)
+					counter += cvmx_read_csr(CVMX_L2C_TADX_PFC3(tad));
+				return counter;
+			}
 	}
 }
 
@@ -279,8 +317,8 @@ uint64_t cvmx_l2c_read_perf(uint32_t counter)
  * @INTERNAL
  * Helper function use to fault in cache lines for L2 cache locking
  *
- * @addr:   Address of base of memory region to read into L2 cache
- * @len:    Length (in bytes) of region to fault in
+ * @param addr   Address of base of memory region to read into L2 cache
+ * @param len    Length (in bytes) of region to fault in
  */
 static void fault_in(uint64_t addr, int len)
 {
@@ -292,7 +330,7 @@ static void fault_in(uint64_t addr, int len)
 	 */
 	len += addr & CVMX_CACHE_LINE_MASK;
 	addr &= ~CVMX_CACHE_LINE_MASK;
-	ptr = (volatile char *)cvmx_phys_to_ptr(addr);
+	ptr = (volatile char *) cvmx_phys_to_ptr(addr);
 	/*
 	 * Invalidate L1 cache to make sure all loads result in data
 	 * being in L2.
@@ -307,39 +345,57 @@ static void fault_in(uint64_t addr, int len)
 
 int cvmx_l2c_lock_line(uint64_t addr)
 {
-	if (OCTEON_IS_MODEL(OCTEON_CN63XX)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX)) {
 		int shift = CVMX_L2C_TAG_ADDR_ALIAS_SHIFT;
 		uint64_t assoc = cvmx_l2c_get_num_assoc();
-		uint64_t tag = addr >> shift;
-		uint64_t index = CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS, cvmx_l2c_address_to_index(addr) << CVMX_L2C_IDX_ADDR_SHIFT);
+		uint32_t tag = cvmx_l2c_v2_address_to_tag(addr);
+		uint64_t indext =
+			cvmx_l2c_address_to_index(addr) << CVMX_L2C_IDX_ADDR_SHIFT;
+		uint64_t index = CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS, indext);
 		uint64_t way;
+		uint32_t tad;
 		union cvmx_l2c_tadx_tag l2c_tadx_tag;
 
-		CVMX_CACHE_LCKL2(CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS, addr), 0);
+		if (tag == 0xFFFFFFFF) {
+			cvmx_dprintf("ERROR: cvmx_l2c_lock_line: addr 0x%llx in LMC hole."
+						 "\n", (unsigned long long) addr);
+			return -1;
+		}
+
+		tad = cvmx_l2c_address_to_tad(addr);
 
+		/* cvmx_dprintf("shift=%d index=%lx tag=%x\n",shift, index, tag); */
+		CVMX_CACHE_LCKL2(CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS, addr), 0);
+		CVMX_SYNCW;
 		/* Make sure we were able to lock the line */
 		for (way = 0; way < assoc; way++) {
-			CVMX_CACHE_LTGL2I(index | (way << shift), 0);
+			uint64_t caddr = index | (way << shift);
+			CVMX_CACHE_LTGL2I(caddr, 0);
 			/* make sure CVMX_L2C_TADX_TAG is updated */
 			CVMX_SYNC;
-			l2c_tadx_tag.u64 = cvmx_read_csr(CVMX_L2C_TADX_TAG(0));
+			l2c_tadx_tag.u64 = cvmx_read_csr(CVMX_L2C_TADX_TAG(tad));
 			if (l2c_tadx_tag.s.valid && l2c_tadx_tag.s.tag == tag)
 				break;
+			/* cvmx_printf("caddr=%lx tad=%d tagu64=%lx valid=%x tag=%x \n", caddr,
+			   tad, l2c_tadx_tag.u64, l2c_tadx_tag.s.valid, l2c_tadx_tag.s.tag); */
 		}
 
 		/* Check if a valid line is found */
 		if (way >= assoc) {
-			/* cvmx_dprintf("ERROR: cvmx_l2c_lock_line: line not found for locking at 0x%llx address\n", (unsigned long long)addr); */
+			/* cvmx_dprintf("ERROR: cvmx_l2c_lock_line: line not found for locking at"
+			   " 0x%llx address\n", (unsigned long long)addr); */
 			return -1;
 		}
 
 		/* Check if lock bit is not set */
 		if (!l2c_tadx_tag.s.lock) {
-			/* cvmx_dprintf("ERROR: cvmx_l2c_lock_line: Not able to lock at 0x%llx address\n", (unsigned long long)addr); */
+			/* cvmx_dprintf("ERROR: cvmx_l2c_lock_line: Not able to lock at "
+			   "0x%llx address\n", (unsigned long long)addr); */
 			return -1;
 		}
-		return way;
-	} else {
+		return 0;
+	}
+	else {
 		int retval = 0;
 		union cvmx_l2c_dbg l2cdbg;
 		union cvmx_l2c_lckbase lckbase;
@@ -366,15 +422,19 @@ int cvmx_l2c_lock_line(uint64_t addr)
 		cvmx_write_csr(CVMX_L2C_DBG, l2cdbg.u64);
 		cvmx_read_csr(CVMX_L2C_DBG);
 
-		lckoff.s.lck_offset = 0; /* Only lock 1 line at a time */
+		lckoff.s.lck_offset = 0;	/* Only lock 1 line at a time */
 		cvmx_write_csr(CVMX_L2C_LCKOFF, lckoff.u64);
 		cvmx_read_csr(CVMX_L2C_LCKOFF);
 
-		if (((union cvmx_l2c_cfg)(cvmx_read_csr(CVMX_L2C_CFG))).s.idxalias) {
-			int alias_shift = CVMX_L2C_IDX_ADDR_SHIFT + 2 * CVMX_L2_SET_BITS - 1;
-			uint64_t addr_tmp = addr ^ (addr & ((1 << alias_shift) - 1)) >> CVMX_L2_SET_BITS;
+		if (((union cvmx_l2c_cfg) (cvmx_read_csr(CVMX_L2C_CFG))).s.idxalias) {
+			int alias_shift =
+				CVMX_L2C_IDX_ADDR_SHIFT + 2 * cvmx_l2c_get_set_bits() - 1;
+			uint64_t addr_tmp =
+				addr ^ (addr & ((1 << alias_shift) - 1)) >>
+				cvmx_l2c_get_set_bits();
 			lckbase.s.lck_base = addr_tmp >> 7;
-		} else {
+		}
+		else {
 			lckbase.s.lck_base = addr >> 7;
 		}
 
@@ -396,7 +456,7 @@ int cvmx_l2c_lock_line(uint64_t addr)
 
 		l2t_err.u64 = cvmx_read_csr(CVMX_L2T_ERR);
 		if (l2t_err.s.lckerr || l2t_err.s.lckerr2)
-			retval = 1;  /* We were unable to lock the line */
+			retval = 1;			/* We were unable to lock the line */
 
 		cvmx_spinlock_unlock(&cvmx_l2c_spinlock);
 		return retval;
@@ -413,7 +473,8 @@ int cvmx_l2c_lock_mem_region(uint64_t start, uint64_t len)
 	len = (len + CVMX_CACHE_LINE_MASK) & ~CVMX_CACHE_LINE_MASK;
 
 	while (len) {
-		retval += cvmx_l2c_lock_line(start);
+		if (cvmx_l2c_lock_line(start) != 0)
+			retval--;
 		start += CVMX_CACHE_LINE_SIZE;
 		len -= CVMX_CACHE_LINE_SIZE;
 	}
@@ -428,7 +489,7 @@ void cvmx_l2c_flush(void)
 	n_set = cvmx_l2c_get_num_sets();
 	n_assoc = cvmx_l2c_get_num_assoc();
 
-	if (OCTEON_IS_MODEL(OCTEON_CN6XXX)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX)) {
 		uint64_t address;
 		/* These may look like constants, but they aren't... */
 		int assoc_shift = CVMX_L2C_TAG_ADDR_ALIAS_SHIFT;
@@ -436,44 +497,50 @@ void cvmx_l2c_flush(void)
 		for (set = 0; set < n_set; set++) {
 			for (assoc = 0; assoc < n_assoc; assoc++) {
 				address = CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS,
-						       (assoc << assoc_shift) |	(set << set_shift));
+									   (assoc << assoc_shift) | (set <<
+																 set_shift));
 				CVMX_CACHE_WBIL2I(address, 0);
 			}
 		}
-	} else {
+	}
+	else {
 		for (set = 0; set < n_set; set++)
 			for (assoc = 0; assoc < n_assoc; assoc++)
 				cvmx_l2c_flush_line(assoc, set);
 	}
 }
 
-
 int cvmx_l2c_unlock_line(uint64_t address)
 {
+	uint32_t tad = cvmx_l2c_address_to_tad(address);
 
-	if (OCTEON_IS_MODEL(OCTEON_CN63XX)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX)) {
 		int assoc;
 		union cvmx_l2c_tag tag;
 		uint32_t tag_addr;
 		uint32_t index = cvmx_l2c_address_to_index(address);
 
-		tag_addr = ((address >> CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) & ((1 << CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) - 1));
+		tag_addr =
+			((address >> CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) &
+			 ((1 << CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) - 1));
 
 		/*
-		 * For 63XX, we can flush a line by using the physical
+		 * For OcteonII, we can flush a line by using the physical
 		 * address directly, so finding the cache line used by
 		 * the address is only required to provide the proper
 		 * return value for the function.
 		 */
-		for (assoc = 0; assoc < CVMX_L2_ASSOC; assoc++) {
-			tag = cvmx_l2c_get_tag(assoc, index);
+		for (assoc = 0; assoc < cvmx_l2c_get_num_assoc(); assoc++) {
+			tag = cvmx_l2c_get_tag_v2(assoc, index, tad);
 
 			if (tag.s.V && (tag.s.addr == tag_addr)) {
-				CVMX_CACHE_WBIL2(CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS, address), 0);
+				CVMX_CACHE_WBIL2(CVMX_ADD_SEG
+								 (CVMX_MIPS_SPACE_XKPHYS, address), 0);
 				return tag.s.L;
 			}
 		}
-	} else {
+	}
+	else {
 		int assoc;
 		union cvmx_l2c_tag tag;
 		uint32_t tag_addr;
@@ -481,9 +548,11 @@ int cvmx_l2c_unlock_line(uint64_t address)
 		uint32_t index = cvmx_l2c_address_to_index(address);
 
 		/* Compute portion of address that is stored in tag */
-		tag_addr = ((address >> CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) & ((1 << CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) - 1));
-		for (assoc = 0; assoc < CVMX_L2_ASSOC; assoc++) {
-			tag = cvmx_l2c_get_tag(assoc, index);
+		tag_addr =
+			((address >> CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) &
+			 ((1 << CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) - 1));
+		for (assoc = 0; assoc < cvmx_l2c_get_num_assoc(); assoc++) {
+			tag = cvmx_l2c_get_tag_v2(assoc, index, tad);
 
 			if (tag.s.V && (tag.s.addr == tag_addr)) {
 				cvmx_l2c_flush_line(assoc, index);
@@ -514,47 +583,53 @@ int cvmx_l2c_unlock_mem_region(uint64_t start, uint64_t len)
  * Internal l2c tag types.  These are converted to a generic structure
  * that can be used on all chips.
  */
-union __cvmx_l2c_tag {
+union __cvmx_l2c_tag
+{
 	uint64_t u64;
-	struct cvmx_l2c_tag_cn50xx {
+	struct cvmx_l2c_tag_cn50xx
+	{
 		uint64_t reserved:40;
-		uint64_t V:1;		/* Line valid */
-		uint64_t D:1;		/* Line dirty */
-		uint64_t L:1;		/* Line locked */
-		uint64_t U:1;		/* Use, LRU eviction */
-		uint64_t addr:20;	/* Phys mem addr (33..14) */
+		uint64_t V:1;			/* Line valid */
+		uint64_t D:1;			/* Line dirty */
+		uint64_t L:1;			/* Line locked */
+		uint64_t U:1;			/* Use, LRU eviction */
+		uint64_t addr:20;		/* Phys mem addr (33..14) */
 	} cn50xx;
-	struct cvmx_l2c_tag_cn30xx {
+	struct cvmx_l2c_tag_cn30xx
+	{
 		uint64_t reserved:41;
-		uint64_t V:1;		/* Line valid */
-		uint64_t D:1;		/* Line dirty */
-		uint64_t L:1;		/* Line locked */
-		uint64_t U:1;		/* Use, LRU eviction */
-		uint64_t addr:19;	/* Phys mem addr (33..15) */
+		uint64_t V:1;			/* Line valid */
+		uint64_t D:1;			/* Line dirty */
+		uint64_t L:1;			/* Line locked */
+		uint64_t U:1;			/* Use, LRU eviction */
+		uint64_t addr:19;		/* Phys mem addr (33..15) */
 	} cn30xx;
-	struct cvmx_l2c_tag_cn31xx {
+	struct cvmx_l2c_tag_cn31xx
+	{
 		uint64_t reserved:42;
-		uint64_t V:1;		/* Line valid */
-		uint64_t D:1;		/* Line dirty */
-		uint64_t L:1;		/* Line locked */
-		uint64_t U:1;		/* Use, LRU eviction */
-		uint64_t addr:18;	/* Phys mem addr (33..16) */
+		uint64_t V:1;			/* Line valid */
+		uint64_t D:1;			/* Line dirty */
+		uint64_t L:1;			/* Line locked */
+		uint64_t U:1;			/* Use, LRU eviction */
+		uint64_t addr:18;		/* Phys mem addr (33..16) */
 	} cn31xx;
-	struct cvmx_l2c_tag_cn38xx {
+	struct cvmx_l2c_tag_cn38xx
+	{
 		uint64_t reserved:43;
-		uint64_t V:1;		/* Line valid */
-		uint64_t D:1;		/* Line dirty */
-		uint64_t L:1;		/* Line locked */
-		uint64_t U:1;		/* Use, LRU eviction */
-		uint64_t addr:17;	/* Phys mem addr (33..17) */
+		uint64_t V:1;			/* Line valid */
+		uint64_t D:1;			/* Line dirty */
+		uint64_t L:1;			/* Line locked */
+		uint64_t U:1;			/* Use, LRU eviction */
+		uint64_t addr:17;		/* Phys mem addr (33..17) */
 	} cn38xx;
-	struct cvmx_l2c_tag_cn58xx {
+	struct cvmx_l2c_tag_cn58xx
+	{
 		uint64_t reserved:44;
-		uint64_t V:1;		/* Line valid */
-		uint64_t D:1;		/* Line dirty */
-		uint64_t L:1;		/* Line locked */
-		uint64_t U:1;		/* Use, LRU eviction */
-		uint64_t addr:16;	/* Phys mem addr (33..18) */
+		uint64_t V:1;			/* Line valid */
+		uint64_t D:1;			/* Line dirty */
+		uint64_t L:1;			/* Line locked */
+		uint64_t U:1;			/* Use, LRU eviction */
+		uint64_t addr:16;		/* Phys mem addr (33..18) */
 	} cn58xx;
 	struct cvmx_l2c_tag_cn58xx cn56xx;	/* 2048 sets */
 	struct cvmx_l2c_tag_cn31xx cn52xx;	/* 512 sets */
@@ -567,17 +642,18 @@ union __cvmx_l2c_tag {
  * the 'debug core' for the L2.  This code must only be executed by
  * 1 core at a time.
  *
- * @assoc:  Association (way) of the tag to dump
- * @index:  Index of the cacheline
+ * @param assoc  Association (way) of the tag to dump
+ * @param index  Index of the cacheline
  *
- * Returns The Octeon model specific tag structure.  This is
+ * @return The Octeon model specific tag structure.  This is
  *         translated by a wrapper function to a generic form that is
  *         easier for applications to use.
  */
 static union __cvmx_l2c_tag __read_l2_tag(uint64_t assoc, uint64_t index)
 {
 
-	uint64_t debug_tag_addr = CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS, (index << 7) + 96);
+	uint64_t debug_tag_addr =
+		CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS, (index << 7) + 96);
 	uint64_t core = cvmx_get_core_num();
 	union __cvmx_l2c_tag tag_val;
 	uint64_t dbg_addr = CVMX_L2C_DBG;
@@ -633,25 +709,128 @@ static union __cvmx_l2c_tag __read_l2_tag(uint64_t assoc, uint64_t index)
 }
 
 
+union cvmx_l2c_tag cvmx_l2c_get_tag_v2(uint32_t association, uint32_t index,
+									   uint32_t tad)
+{
+	union cvmx_l2c_tag tag;
+	tag.u64 = 0;
+
+	if ((int) association >= cvmx_l2c_get_num_assoc()) {
+		cvmx_dprintf("ERROR: cvmx_l2c_get_tag association out of range\n");
+		return tag;
+	}
+	if ((int) index >= cvmx_l2c_get_num_sets()) {
+		cvmx_dprintf
+			("ERROR: cvmx_l2c_get_tag index out of range (arg: %d, max: %d)\n",
+			 (int) index, cvmx_l2c_get_num_sets());
+		return tag;
+	}
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX)) {
+		union cvmx_l2c_tadx_tag l2c_tadx_tag;
+		uint64_t address = CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS,
+										(association <<
+										 CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) |
+										(index << CVMX_L2C_IDX_ADDR_SHIFT));
+		/*
+		 * Use L2 cache Index load tag cache instruction, as
+		 * hardware loads the virtual tag for the L2 cache
+		 * block with the contents of L2C_TAD0_TAG
+		 * register.
+		 */
+		if (tad > CVMX_L2C_TADS) {
+			cvmx_dprintf("ERROR: cvmx_l2c_get_tag_v2: TAD#%d out of range\n",
+						 (unsigned int) tad);
+			return tag;
+		}
+		CVMX_CACHE_LTGL2I(address, 0);
+		CVMX_SYNC;				/* make sure CVMX_L2C_TADX_TAG is updated */
+		l2c_tadx_tag.u64 = cvmx_read_csr(CVMX_L2C_TADX_TAG(tad));
+
+		tag.s.V = l2c_tadx_tag.s.valid;
+		tag.s.D = l2c_tadx_tag.s.dirty;
+		tag.s.L = l2c_tadx_tag.s.lock;
+		tag.s.U = l2c_tadx_tag.s.use;
+		tag.s.addr = l2c_tadx_tag.s.tag;
+	}
+	else {
+		union __cvmx_l2c_tag tmp_tag;
+		/* __read_l2_tag is intended for internal use only */
+		tmp_tag = __read_l2_tag(association, index);
+
+		/*
+		 * Convert all tag structure types to generic version,
+		 * as it can represent all models.
+		 */
+		if (OCTEON_IS_MODEL(OCTEON_CN58XX) || OCTEON_IS_MODEL(OCTEON_CN56XX)) {
+			tag.s.V = tmp_tag.cn58xx.V;
+			tag.s.D = tmp_tag.cn58xx.D;
+			tag.s.L = tmp_tag.cn58xx.L;
+			tag.s.U = tmp_tag.cn58xx.U;
+			tag.s.addr = tmp_tag.cn58xx.addr;
+		}
+		else if (OCTEON_IS_MODEL(OCTEON_CN38XX)) {
+			tag.s.V = tmp_tag.cn38xx.V;
+			tag.s.D = tmp_tag.cn38xx.D;
+			tag.s.L = tmp_tag.cn38xx.L;
+			tag.s.U = tmp_tag.cn38xx.U;
+			tag.s.addr = tmp_tag.cn38xx.addr;
+		}
+		else if (OCTEON_IS_MODEL(OCTEON_CN31XX)
+				 || OCTEON_IS_MODEL(OCTEON_CN52XX)) {
+			tag.s.V = tmp_tag.cn31xx.V;
+			tag.s.D = tmp_tag.cn31xx.D;
+			tag.s.L = tmp_tag.cn31xx.L;
+			tag.s.U = tmp_tag.cn31xx.U;
+			tag.s.addr = tmp_tag.cn31xx.addr;
+		}
+		else if (OCTEON_IS_MODEL(OCTEON_CN30XX)) {
+			tag.s.V = tmp_tag.cn30xx.V;
+			tag.s.D = tmp_tag.cn30xx.D;
+			tag.s.L = tmp_tag.cn30xx.L;
+			tag.s.U = tmp_tag.cn30xx.U;
+			tag.s.addr = tmp_tag.cn30xx.addr;
+		}
+		else if (OCTEON_IS_MODEL(OCTEON_CN50XX)) {
+			tag.s.V = tmp_tag.cn50xx.V;
+			tag.s.D = tmp_tag.cn50xx.D;
+			tag.s.L = tmp_tag.cn50xx.L;
+			tag.s.U = tmp_tag.cn50xx.U;
+			tag.s.addr = tmp_tag.cn50xx.addr;
+		}
+		else {
+			cvmx_dprintf("Unsupported OCTEON Model in %s\n", __func__);
+		}
+	}
+	return tag;
+}
+
 union cvmx_l2c_tag cvmx_l2c_get_tag(uint32_t association, uint32_t index)
 {
 	union cvmx_l2c_tag tag;
 	tag.u64 = 0;
 
-	if ((int)association >= cvmx_l2c_get_num_assoc()) {
+	if ((int) association >= cvmx_l2c_get_num_assoc()) {
 		cvmx_dprintf("ERROR: cvmx_l2c_get_tag association out of range\n");
 		return tag;
 	}
-	if ((int)index >= cvmx_l2c_get_num_sets()) {
-		cvmx_dprintf("ERROR: cvmx_l2c_get_tag index out of range (arg: %d, max: %d)\n",
-			     (int)index, cvmx_l2c_get_num_sets());
+	if ((int) index >= cvmx_l2c_get_num_sets()) {
+		cvmx_dprintf
+			("ERROR: cvmx_l2c_get_tag index out of range (arg: %d, max: %d)\n",
+			 (int) index, cvmx_l2c_get_num_sets());
 		return tag;
 	}
-	if (OCTEON_IS_MODEL(OCTEON_CN63XX)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX)) {
 		union cvmx_l2c_tadx_tag l2c_tadx_tag;
 		uint64_t address = CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS,
-						(association << CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) |
-						(index << CVMX_L2C_IDX_ADDR_SHIFT));
+										(association <<
+										 CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) |
+										(index << CVMX_L2C_IDX_ADDR_SHIFT));
+		if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+			cvmx_dprintf
+				("ERROR: Cannot use %s on OCTEON CN68XX, use cvmx_l2c_get_tag_v2 instead!\n",
+				 __func__);
+			return tag;
+		}
 		/*
 		 * Use L2 cache Index load tag cache instruction, as
 		 * hardware loads the virtual tag for the L2 cache
@@ -659,15 +838,16 @@ union cvmx_l2c_tag cvmx_l2c_get_tag(uint32_t association, uint32_t index)
 		 * register.
 		 */
 		CVMX_CACHE_LTGL2I(address, 0);
-		CVMX_SYNC;   /* make sure CVMX_L2C_TADX_TAG is updated */
+		CVMX_SYNC;				/* make sure CVMX_L2C_TADX_TAG is updated */
 		l2c_tadx_tag.u64 = cvmx_read_csr(CVMX_L2C_TADX_TAG(0));
 
-		tag.s.V     = l2c_tadx_tag.s.valid;
-		tag.s.D     = l2c_tadx_tag.s.dirty;
-		tag.s.L     = l2c_tadx_tag.s.lock;
-		tag.s.U     = l2c_tadx_tag.s.use;
-		tag.s.addr  = l2c_tadx_tag.s.tag;
-	} else {
+		tag.s.V = l2c_tadx_tag.s.valid;
+		tag.s.D = l2c_tadx_tag.s.dirty;
+		tag.s.L = l2c_tadx_tag.s.lock;
+		tag.s.U = l2c_tadx_tag.s.use;
+		tag.s.addr = l2c_tadx_tag.s.tag;
+	}
+	else {
 		union __cvmx_l2c_tag tmp_tag;
 		/* __read_l2_tag is intended for internal use only */
 		tmp_tag = __read_l2_tag(association, index);
@@ -677,64 +857,120 @@ union cvmx_l2c_tag cvmx_l2c_get_tag(uint32_t association, uint32_t index)
 		 * as it can represent all models.
 		 */
 		if (OCTEON_IS_MODEL(OCTEON_CN58XX) || OCTEON_IS_MODEL(OCTEON_CN56XX)) {
-			tag.s.V    = tmp_tag.cn58xx.V;
-			tag.s.D    = tmp_tag.cn58xx.D;
-			tag.s.L    = tmp_tag.cn58xx.L;
-			tag.s.U    = tmp_tag.cn58xx.U;
+			tag.s.V = tmp_tag.cn58xx.V;
+			tag.s.D = tmp_tag.cn58xx.D;
+			tag.s.L = tmp_tag.cn58xx.L;
+			tag.s.U = tmp_tag.cn58xx.U;
 			tag.s.addr = tmp_tag.cn58xx.addr;
-		} else if (OCTEON_IS_MODEL(OCTEON_CN38XX)) {
-			tag.s.V    = tmp_tag.cn38xx.V;
-			tag.s.D    = tmp_tag.cn38xx.D;
-			tag.s.L    = tmp_tag.cn38xx.L;
-			tag.s.U    = tmp_tag.cn38xx.U;
+		}
+		else if (OCTEON_IS_MODEL(OCTEON_CN38XX)) {
+			tag.s.V = tmp_tag.cn38xx.V;
+			tag.s.D = tmp_tag.cn38xx.D;
+			tag.s.L = tmp_tag.cn38xx.L;
+			tag.s.U = tmp_tag.cn38xx.U;
 			tag.s.addr = tmp_tag.cn38xx.addr;
-		} else if (OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN52XX)) {
-			tag.s.V    = tmp_tag.cn31xx.V;
-			tag.s.D    = tmp_tag.cn31xx.D;
-			tag.s.L    = tmp_tag.cn31xx.L;
-			tag.s.U    = tmp_tag.cn31xx.U;
+		}
+		else if (OCTEON_IS_MODEL(OCTEON_CN31XX)
+				 || OCTEON_IS_MODEL(OCTEON_CN52XX)) {
+			tag.s.V = tmp_tag.cn31xx.V;
+			tag.s.D = tmp_tag.cn31xx.D;
+			tag.s.L = tmp_tag.cn31xx.L;
+			tag.s.U = tmp_tag.cn31xx.U;
 			tag.s.addr = tmp_tag.cn31xx.addr;
-		} else if (OCTEON_IS_MODEL(OCTEON_CN30XX)) {
-			tag.s.V    = tmp_tag.cn30xx.V;
-			tag.s.D    = tmp_tag.cn30xx.D;
-			tag.s.L    = tmp_tag.cn30xx.L;
-			tag.s.U    = tmp_tag.cn30xx.U;
+		}
+		else if (OCTEON_IS_MODEL(OCTEON_CN30XX)) {
+			tag.s.V = tmp_tag.cn30xx.V;
+			tag.s.D = tmp_tag.cn30xx.D;
+			tag.s.L = tmp_tag.cn30xx.L;
+			tag.s.U = tmp_tag.cn30xx.U;
 			tag.s.addr = tmp_tag.cn30xx.addr;
-		} else if (OCTEON_IS_MODEL(OCTEON_CN50XX)) {
-			tag.s.V    = tmp_tag.cn50xx.V;
-			tag.s.D    = tmp_tag.cn50xx.D;
-			tag.s.L    = tmp_tag.cn50xx.L;
-			tag.s.U    = tmp_tag.cn50xx.U;
+		}
+		else if (OCTEON_IS_MODEL(OCTEON_CN50XX)) {
+			tag.s.V = tmp_tag.cn50xx.V;
+			tag.s.D = tmp_tag.cn50xx.D;
+			tag.s.L = tmp_tag.cn50xx.L;
+			tag.s.U = tmp_tag.cn50xx.U;
 			tag.s.addr = tmp_tag.cn50xx.addr;
-		} else {
+		}
+		else {
 			cvmx_dprintf("Unsupported OCTEON Model in %s\n", __func__);
 		}
 	}
 	return tag;
 }
 
+int cvmx_l2c_address_to_tad(uint64_t addr)
+{
+	uint32_t tad;
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		union cvmx_l2c_ctl l2c_ctl;
+		l2c_ctl.u64 = cvmx_read_csr(CVMX_L2C_CTL);
+		if (!l2c_ctl.s.disidxalias) {
+			tad = ((addr >> 7) ^ (addr >> 12) ^ (addr >> 18)) & 3;
+		}
+		else {
+			tad = (addr >> 7) & 3;
+		}
+	}
+	else {
+		tad = 0;
+	}
+	return tad;
+}
+
+uint32_t cvmx_l2c_v2_address_to_tag(uint64_t addr)
+{
+#define DR0_END   ( (256 * 1024 * 1024) -1)
+#define DR1_START (512 * 1024 * 1024)
+#define L2_HOLE   (256 * 1024 * 1024)
+
+	if ((addr > DR0_END) && (addr < DR1_START))
+		return (uint32_t) (-1);
+	if (addr > DR1_START)
+		addr = addr - L2_HOLE;
+	addr = addr & 0x7FFFFFFFFULL;
+	return (uint32_t) (addr >> CVMX_L2C_TAG_ADDR_ALIAS_SHIFT);
+}
+
 uint32_t cvmx_l2c_address_to_index(uint64_t addr)
 {
 	uint64_t idx = addr >> CVMX_L2C_IDX_ADDR_SHIFT;
 	int indxalias = 0;
 
-	if (OCTEON_IS_MODEL(OCTEON_CN6XXX)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX)) {
 		union cvmx_l2c_ctl l2c_ctl;
 		l2c_ctl.u64 = cvmx_read_csr(CVMX_L2C_CTL);
 		indxalias = !l2c_ctl.s.disidxalias;
-	} else {
+	}
+	else {
 		union cvmx_l2c_cfg l2c_cfg;
 		l2c_cfg.u64 = cvmx_read_csr(CVMX_L2C_CFG);
 		indxalias = l2c_cfg.s.idxalias;
 	}
 
 	if (indxalias) {
-		if (OCTEON_IS_MODEL(OCTEON_CN63XX)) {
-			uint32_t a_14_12 = (idx / (CVMX_L2C_MEMBANK_SELECT_SIZE/(1<<CVMX_L2C_IDX_ADDR_SHIFT))) & 0x7;
+		if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+			uint32_t a_14_12 =
+				(idx /
+				 (CVMX_L2C_MEMBANK_SELECT_SIZE /
+				  (1 << CVMX_L2C_IDX_ADDR_SHIFT))) & 0x7;
+			idx ^= (idx / cvmx_l2c_get_num_sets()) & 0x3ff;
+			idx ^= a_14_12 & 0x3;
+			idx ^= a_14_12 << 2;
+		}
+		else if (OCTEON_IS_MODEL(OCTEON_CN6XXX)
+				 || OCTEON_IS_MODEL(OCTEON_CNF7XXX)) {
+			uint32_t a_14_12 =
+				(idx /
+				 (CVMX_L2C_MEMBANK_SELECT_SIZE /
+				  (1 << CVMX_L2C_IDX_ADDR_SHIFT))) & 0x7;
 			idx ^= idx / cvmx_l2c_get_num_sets();
 			idx ^= a_14_12;
-		} else {
-			idx ^= ((addr & CVMX_L2C_ALIAS_MASK) >> CVMX_L2C_TAG_ADDR_ALIAS_SHIFT);
+		}
+		else {
+			idx ^=
+				((addr & CVMX_L2C_ALIAS_MASK) >>
+				 CVMX_L2C_TAG_ADDR_ALIAS_SHIFT);
 		}
 	}
 	idx &= CVMX_L2C_IDX_MASK;
@@ -749,24 +985,28 @@ int cvmx_l2c_get_cache_size_bytes(void)
 
 /**
  * Return log base 2 of the number of sets in the L2 cache
- * Returns
+ * @return
  */
 int cvmx_l2c_get_set_bits(void)
 {
 	int l2_set_bits;
-	if (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN58XX))
-		l2_set_bits = 11;	/* 2048 sets */
-	else if (OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN63XX))
-		l2_set_bits = 10;	/* 1024 sets */
-	else if (OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN52XX))
-		l2_set_bits = 9;	/* 512 sets */
+	if (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN68XX))
+		l2_set_bits = 11;		/* 2048 sets */
+	else if (OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN63XX)
+			 || OCTEON_IS_MODEL(OCTEON_CN66XX))
+		l2_set_bits = 10;		/* 1024 sets */
+	else if (OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN52XX)
+			 || OCTEON_IS_MODEL(OCTEON_CN61XX)
+			 || OCTEON_IS_MODEL(OCTEON_CNF71XX))
+		l2_set_bits = 9;		/* 512 sets */
 	else if (OCTEON_IS_MODEL(OCTEON_CN30XX))
-		l2_set_bits = 8;	/* 256 sets */
+		l2_set_bits = 8;		/* 256 sets */
 	else if (OCTEON_IS_MODEL(OCTEON_CN50XX))
-		l2_set_bits = 7;	/* 128 sets */
+		l2_set_bits = 7;		/* 128 sets */
 	else {
 		cvmx_dprintf("Unsupported OCTEON Model in %s\n", __func__);
-		l2_set_bits = 11;	/* 2048 sets */
+		l2_set_bits = 11;		/* 2048 sets */
 	}
 	return l2_set_bits;
 }
@@ -782,15 +1022,14 @@ int cvmx_l2c_get_num_assoc(void)
 {
 	int l2_assoc;
 	if (OCTEON_IS_MODEL(OCTEON_CN56XX) ||
-	    OCTEON_IS_MODEL(OCTEON_CN52XX) ||
-	    OCTEON_IS_MODEL(OCTEON_CN58XX) ||
-	    OCTEON_IS_MODEL(OCTEON_CN50XX) ||
-	    OCTEON_IS_MODEL(OCTEON_CN38XX))
+		OCTEON_IS_MODEL(OCTEON_CN52XX) ||
+		OCTEON_IS_MODEL(OCTEON_CN58XX) ||
+		OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN38XX))
 		l2_assoc = 8;
-	else if (OCTEON_IS_MODEL(OCTEON_CN63XX))
+	else if (OCTEON_IS_MODEL(OCTEON_CN6XXX)
+			 || OCTEON_IS_MODEL(OCTEON_CNF7XXX))
 		l2_assoc = 16;
-	else if (OCTEON_IS_MODEL(OCTEON_CN31XX) ||
-		 OCTEON_IS_MODEL(OCTEON_CN30XX))
+	else if (OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN30XX))
 		l2_assoc = 4;
 	else {
 		cvmx_dprintf("Unsupported OCTEON Model in %s\n", __func__);
@@ -798,7 +1037,7 @@ int cvmx_l2c_get_num_assoc(void)
 	}
 
 	/* Check to see if part of the cache is disabled */
-	if (OCTEON_IS_MODEL(OCTEON_CN63XX)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX)) {
 		union cvmx_mio_fus_dat3 mio_fus_dat3;
 
 		mio_fus_dat3.u64 = cvmx_read_csr(CVMX_MIO_FUS_DAT3);
@@ -815,13 +1054,14 @@ int cvmx_l2c_get_num_assoc(void)
 		 * 1 1 4-way 512KB cache
 		 */
 
-		if (mio_fus_dat3.s.l2c_crip == 3)
+		if (mio_fus_dat3.cn63xx.l2c_crip == 3)
 			l2_assoc = 4;
-		else if (mio_fus_dat3.s.l2c_crip == 2)
+		else if (mio_fus_dat3.cn63xx.l2c_crip == 2)
 			l2_assoc = 8;
-		else if (mio_fus_dat3.s.l2c_crip == 1)
+		else if (mio_fus_dat3.cn63xx.l2c_crip == 1)
 			l2_assoc = 12;
-	} else {
+	}
+	else {
 		union cvmx_l2d_fus3 val;
 		val.u64 = cvmx_read_csr(CVMX_L2D_FUS3);
 		/*
@@ -842,24 +1082,25 @@ int cvmx_l2c_get_num_assoc(void)
  * This should only be called from one core at a time, as this routine
  * sets the core to the 'debug' core in order to flush the line.
  *
- * @assoc:  Association (or way) to flush
- * @index:  Index to flush
+ * @param assoc  Association (or way) to flush
+ * @param index  Index to flush
  */
 void cvmx_l2c_flush_line(uint32_t assoc, uint32_t index)
 {
 	/* Check the range of the index. */
-	if (index > (uint32_t)cvmx_l2c_get_num_sets()) {
+	if (index > (uint32_t) cvmx_l2c_get_num_sets()) {
 		cvmx_dprintf("ERROR: cvmx_l2c_flush_line index out of range.\n");
 		return;
 	}
 
 	/* Check the range of association. */
-	if (assoc > (uint32_t)cvmx_l2c_get_num_assoc()) {
-		cvmx_dprintf("ERROR: cvmx_l2c_flush_line association out of range.\n");
+	if (assoc > (uint32_t) cvmx_l2c_get_num_assoc()) {
+		cvmx_dprintf
+			("ERROR: cvmx_l2c_flush_line association out of range.\n");
 		return;
 	}
 
-	if (OCTEON_IS_MODEL(OCTEON_CN63XX)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX)) {
 		uint64_t address;
 		/* Create the address based on index and association.
 		 * Bits<20:17> select the way of the cache block involved in
@@ -867,10 +1108,11 @@ void cvmx_l2c_flush_line(uint32_t assoc, uint32_t index)
 		 * Bits<16:7> of the effect address select the index
 		 */
 		address = CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS,
-				(assoc << CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) |
-				(index << CVMX_L2C_IDX_ADDR_SHIFT));
+							   (assoc << CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) |
+							   (index << CVMX_L2C_IDX_ADDR_SHIFT));
 		CVMX_CACHE_WBIL2I(address, 0);
-	} else {
+	}
+	else {
 		union cvmx_l2c_dbg l2cdbg;
 
 		l2cdbg.u64 = 0;
@@ -889,8 +1131,7 @@ void cvmx_l2c_flush_line(uint32_t assoc, uint32_t index)
 		cvmx_read_csr(CVMX_L2C_DBG);
 
 		CVMX_PREPARE_FOR_STORE(CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS,
-						    index * CVMX_CACHE_LINE_SIZE),
-				       0);
+											index * CVMX_CACHE_LINE_SIZE), 0);
 		/* Exit debug mode */
 		CVMX_SYNC;
 		cvmx_write_csr(CVMX_L2C_DBG, 0);
@@ -898,3 +1139,48 @@ void cvmx_l2c_flush_line(uint32_t assoc, uint32_t index)
 		cvmx_spinlock_unlock(&cvmx_l2c_spinlock);
 	}
 }
+
+/**
+ * Initialize the BIG address in L2C+DRAM to generate proper error
+ * on reading/writing to an non-existant memory location.
+ *
+ * @param mem_size  Amount of DRAM configured in MB.
+ * @param mode      Allow/Disallow reporting errors L2C_INT_SUM[BIGRD,BIGWR].
+ */
+void cvmx_l2c_set_big_size(uint64_t mem_size, int mode)
+{
+	if ((OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX))
+		&& !OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X)) {
+		union cvmx_l2c_big_ctl big_ctl;
+		int bits = 0, zero_bits = 0;
+		uint64_t mem;
+
+		if (mem_size > (CVMX_L2C_MAX_MEMSZ_ALLOWED * 1024)) {
+			cvmx_dprintf
+				("WARNING: Invalid memory size(%lld) requested, should be <= %lld\n",
+				 (unsigned long long) mem_size,
+				 (unsigned long long) CVMX_L2C_MAX_MEMSZ_ALLOWED * 1024);
+			mem_size = CVMX_L2C_MAX_MEMSZ_ALLOWED * 1024;
+		}
+
+		mem = mem_size;
+		while (mem) {
+			if ((mem & 1) == 0)
+				zero_bits++;
+			bits++;
+			mem >>= 1;
+		}
+
+		if ((bits - zero_bits) != 1 || (bits - 9) <= 0) {
+			cvmx_dprintf
+				("ERROR: Invalid DRAM size (%lld) requested, refer to L2C_BIG_CTL[maxdram] for valid options.\n",
+				 (unsigned long long) mem_size);
+			return;
+		}
+
+		big_ctl.u64 = 0;
+		big_ctl.s.maxdram = bits - 9;
+		big_ctl.s.disable = mode;
+		cvmx_write_csr(CVMX_L2C_BIG_CTL, big_ctl.u64);
+	}
+}
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 8209a61..e3c30b6 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -424,6 +424,7 @@ void __init prom_init(void)
 	struct cvmx_sysinfo *sysinfo;
 	int i;
 	int argc;
+	int is_octeon2;
 #ifdef CONFIG_CAVIUM_RESERVE32
 	int64_t addr = -1;
 #endif
@@ -508,8 +509,12 @@ void __init prom_init(void)
 #endif
 
 #ifdef CONFIG_CAVIUM_OCTEON_LOCK_L2
-	if (cvmx_read_csr(CVMX_L2D_FUS3) & (3ull << 34)) {
-		pr_info("Skipping L2 locking due to reduced L2 cache size\n");
+       is_octeon2 = (current_cpu_type() == CPU_CAVIUM_OCTEON2);
+
+       if ((is_octeon2 && (cvmx_read_csr(CVMX_MIO_FUS_DAT3) & (3ull << 32)))
+           || (!is_octeon2 && (cvmx_read_csr(CVMX_L2D_FUS3) & (3ull << 34)))) {
+		//pr_info("Skipping L2 locking due to reduced L2 cache size\n");
+		printk("<0>Skipping L2 locking due to reduced L2 cache size\n");
 	} else {
 		uint32_t ebase = read_c0_ebase() & 0x3ffff000;
 #ifdef CONFIG_CAVIUM_OCTEON_LOCK_L2_TLB
@@ -526,7 +531,7 @@ void __init prom_init(void)
 #endif
 #ifdef CONFIG_CAVIUM_OCTEON_LOCK_L2_INTERRUPT
 		cvmx_l2c_lock_mem_region(__pa_symbol(handle_int), 0x100);
-		cvmx_l2c_lock_mem_region(__pa_symbol(plat_irq_dispatch), 0x80);
+		cvmx_l2c_lock_mem_region(__pa_symbol(plat_irq_dispatch), 0x180);
 #endif
 #ifdef CONFIG_CAVIUM_OCTEON_LOCK_L2_MEMCPY
 		cvmx_l2c_lock_mem_region(__pa_symbol(memcpy), 0x480);
@@ -643,6 +648,68 @@ static __init void memory_exclude_page(u64 addr, u64 *mem, u64 *size)
 	}
 }
 
+extern uint64_t cvmx_bootmem_phy_available_mem(uint64_t min_block_size);
+
+void cleanup_phy_mem(void)
+{
+        /* Ensure all memory is cleaned up.
+         * Assume nothing has been put before the kernel
+         * and assume that the kernel lands in the DDR0 region
+         */
+        uint64_t freemem;
+        struct cvmx_sysinfo *sysinfo;
+        uint64_t memory;
+        uint64_t kernel_size;
+        uint64_t curr_addr;
+
+        /* get the amount of DRAM on the board */
+        sysinfo = cvmx_sysinfo_get();
+        memory = sysinfo->system_dram_size;
+
+        /* do a few calculations */
+        kernel_size = (uint64_t)__bss_stop - (uint64_t)_text;
+        freemem = cvmx_bootmem_phy_available_mem(0x100000);
+
+        if (freemem > OCTEON_DDR0_SIZE) {
+                /* we have enough memory to continue = no need to
+                 * continue free'ing
+                 */
+                printk("<0>The size of free memory is 0x%llx\n", freemem);
+                printk("<0>...no need to free any memory\n");
+                return;
+        }
+
+        /* calculate the current address which is the next address after
+         * the end of the kernel, on a boundary of 0x100000 (1MB)
+         * the shift needs to match the value used in plat_mem_setup()
+         */
+        curr_addr = (uint64_t)__bss_stop;
+        curr_addr &= 0x7fffffffULL;
+        curr_addr = curr_addr >> 20;
+        curr_addr += 1;
+        curr_addr = curr_addr << 20;
+
+        memory -= kernel_size;
+
+        if (memory <= (OCTEON_DDR0_SIZE - curr_addr)) {
+                __cvmx_bootmem_phy_free(curr_addr, memory, 0);
+        } else {
+                __cvmx_bootmem_phy_free(curr_addr,
+                        OCTEON_DDR0_SIZE - curr_addr, 0);
+
+                memory -= (OCTEON_DDR0_SIZE);
+
+                if (memory > OCTEON_DDR1_SIZE) {
+                        __cvmx_bootmem_phy_free(OCTEON_DDR1_BASE,
+                                OCTEON_DDR1_SIZE, 0);
+                        __cvmx_bootmem_phy_free(OCTEON_DDR2_BASE,
+                                memory - OCTEON_DDR1_SIZE, 0);
+                } else {
+                        __cvmx_bootmem_phy_free(OCTEON_DDR1_BASE, memory, 0);
+                }
+        }
+}
+
 void __init plat_mem_setup(void)
 {
 	uint64_t mem_alloc_size;
@@ -651,6 +718,16 @@ void __init plat_mem_setup(void)
 
 	total = 0;
 
+        cleanup_phy_mem();
+
+        /* First add the init memory we will be returning.  */
+        memory = __pa_symbol(&__init_begin) & PAGE_MASK;
+        mem_alloc_size = (__pa_symbol(&__init_end) & PAGE_MASK) - memory;
+        if (mem_alloc_size > 0) {
+                add_memory_region(memory, mem_alloc_size, BOOT_MEM_INIT_RAM);
+                total += mem_alloc_size;
+        }
+
 	/*
 	 * The Mips memory init uses the first memory location for
 	 * some memory vectors. When SPARSEMEM is in use, it doesn't
diff --git a/arch/mips/include/asm/octeon/cvmx-bootmem.h b/arch/mips/include/asm/octeon/cvmx-bootmem.h
index 877845b..c9d8119 100644
--- a/arch/mips/include/asm/octeon/cvmx-bootmem.h
+++ b/arch/mips/include/asm/octeon/cvmx-bootmem.h
@@ -48,6 +48,14 @@
 /* Don't do any locking. */
 #define CVMX_BOOTMEM_FLAG_NO_LOCKING   (1 << 1)
 
+/* Real physical addresses of memory regions */
+#define OCTEON_DDR0_BASE    (0x0ULL)
+#define OCTEON_DDR0_SIZE    (0x010000000ULL)
+#define OCTEON_DDR1_BASE    ((OCTEON_IS_MODEL(OCTEON_CN6XXX)) ? 0x20000000ULL : 0x410000000ULL)
+#define OCTEON_DDR1_SIZE    (0x010000000ULL)
+#define OCTEON_DDR2_BASE    ((OCTEON_IS_MODEL(OCTEON_CN6XXX)) ? 0x30000000ULL : 0x20000000ULL)
+#define OCTEON_DDR2_SIZE    ((OCTEON_IS_MODEL(OCTEON_CN6XXX)) ? 0x7d0000000ULL : 0x3e0000000ULL)
+
 /* First bytes of each free physical block of memory contain this structure,
  * which is used to maintain the free memory list.  Since the bootloader is
  * only 32 bits, there is a union providing 64 and 32 bit versions.  The
diff --git a/arch/mips/include/asm/octeon/cvmx-l2c.h b/arch/mips/include/asm/octeon/cvmx-l2c.h
index 2c8ff9e..c9750ab 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2c.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2c.h
@@ -50,6 +50,9 @@
 #define CVMX_L2C_VRT_MAX_VIRTID_ALLOWED ((OCTEON_IS_MODEL(OCTEON_CN63XX)) ? 64 : 0)
 #define CVMX_L2C_VRT_MAX_MEMSZ_ALLOWED ((OCTEON_IS_MODEL(OCTEON_CN63XX)) ? 32 : 0)
 
+#define CVMX_L2C_MAX_MEMSZ_ALLOWED ((OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX)) ? 32 : 0)
+
+
 union cvmx_l2c_tag {
 	uint64_t u64;
 	struct {
@@ -357,4 +360,9 @@ int cvmx_l2c_get_num_assoc(void);
  */
 void cvmx_l2c_flush_line(uint32_t assoc, uint32_t index);
 
+uint32_t cvmx_l2c_v2_address_to_tag(uint64_t addr);
+int cvmx_l2c_address_to_tad(uint64_t addr);
+union cvmx_l2c_tag cvmx_l2c_get_tag_v2(uint32_t association, uint32_t index,
+					   uint32_t tad);
+
 #endif /* __CVMX_L2C_H__ */
diff --git a/arch/mips/include/asm/octeon/octeon-model.h b/arch/mips/include/asm/octeon/octeon-model.h
index 4e338a4..0c572ca 100644
--- a/arch/mips/include/asm/octeon/octeon-model.h
+++ b/arch/mips/include/asm/octeon/octeon-model.h
@@ -61,6 +61,16 @@
 #define OM_MATCH_5XXX_FAMILY_MODELS     0x20000000
 /* Match all cn6XXX Octeon models. */
 #define OM_MATCH_6XXX_FAMILY_MODELS     0x40000000
+#define OM_MATCH_F7XXX_FAMILY_MODELS    0x80000000 /* Match all cnf7XXX Octeon models. */
+#define OM_MATCH_F7XXX_FAMILY_MODELS    0x80000000 /* Match all cnf7XXX Octeon models. */
+
+/*
+ * CNF7XXX models with new revision encoding
+ */
+#define OCTEON_CNF71XX_PASS1_0  0x000d9400
+
+#define OCTEON_CNF71XX          (OCTEON_CNF71XX_PASS1_0 | OM_IGNORE_REVISION)
+#define OCTEON_CNF71XX_PASS1_X  (OCTEON_CNF71XX_PASS1_0 | OM_IGNORE_MINOR_REVISION)
 
 /*
  * CN6XXX models with new revision encoding
@@ -207,6 +217,7 @@
 #define OCTEON_CN3XXX           (OCTEON_CN58XX_PASS1_0 | OM_MATCH_PREVIOUS_MODELS | OM_IGNORE_REVISION)
 #define OCTEON_CN5XXX           (OCTEON_CN58XX_PASS1_0 | OM_MATCH_5XXX_FAMILY_MODELS)
 #define OCTEON_CN6XXX           (OCTEON_CN63XX_PASS1_0 | OM_MATCH_6XXX_FAMILY_MODELS)
+#define OCTEON_CNF7XXX          (OCTEON_CNF71XX_PASS1_0 | OM_MATCH_F7XXX_FAMILY_MODELS)
 
 /* The revision byte (low byte) has two different encodings.
  * CN3XXX:
@@ -274,7 +285,9 @@ static inline uint64_t cvmx_read_csr(uint64_t csr_addr);
 		((((arg_model) & (OM_MATCH_5XXX_FAMILY_MODELS)) == OM_MATCH_5XXX_FAMILY_MODELS) \
 			&& ((chip_model) >= OCTEON_CN58XX_PASS1_0) && ((chip_model) < OCTEON_CN63XX_PASS1_0)) || \
 		((((arg_model) & (OM_MATCH_6XXX_FAMILY_MODELS)) == OM_MATCH_6XXX_FAMILY_MODELS) \
-			&& ((chip_model) >= OCTEON_CN63XX_PASS1_0)) ||	\
+			&& ((chip_model) >= OCTEON_CN63XX_PASS1_0) && ((chip_model) < OCTEON_CNF71XX_PASS1_0)) || \
+		((((arg_model) & (OM_MATCH_F7XXX_FAMILY_MODELS)) == OM_MATCH_F7XXX_FAMILY_MODELS) \
+			&& ((chip_model) >= OCTEON_CNF71XX_PASS1_0)) || \
 		((((arg_model) & (OM_MATCH_PREVIOUS_MODELS)) == OM_MATCH_PREVIOUS_MODELS) \
 			&& (((chip_model) & OCTEON_58XX_MODEL_MASK) < ((arg_model) & OCTEON_58XX_MODEL_MASK))) \
 		)))
diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index c504b21..f5453b7 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -283,8 +283,14 @@ static void __init bootmem_init(void)
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
 		unsigned long start, end;
 
-		if (boot_mem_map.map[i].type != BOOT_MEM_RAM)
-			continue;
+		switch (boot_mem_map.map[i].type) {
+			case BOOT_MEM_RAM:
+			case BOOT_MEM_INIT_RAM:
+				break;
+			default:
+				/* Not usable memory */
+				continue;
+		}
 
 		start = PFN_UP(boot_mem_map.map[i].addr);
 		end = PFN_DOWN(boot_mem_map.map[i].addr
@@ -386,12 +392,14 @@ static void __init bootmem_init(void)
 		 * We are rounding up the start address of usable memory
 		 * and at the end of the usable range downwards.
 		 */
-		if (start >= max_low_pfn)
-			continue;
-		if (start < reserved_end)
-			start = reserved_end;
-		if (end > max_low_pfn)
-			end = max_low_pfn;
+		if (boot_mem_map.map[i].type == BOOT_MEM_RAM) {
+			if (start >= max_low_pfn)
+				continue;
+			if (start < reserved_end)
+				start = reserved_end;
+			if (end > max_low_pfn)
+				end = max_low_pfn;
+		}
 
 		/*
 		 * ... finally, is the area going away?
@@ -401,7 +409,8 @@ static void __init bootmem_init(void)
 		size = end - start;
 
 		/* Register lowmem ranges */
-		free_bootmem(PFN_PHYS(start), size << PAGE_SHIFT);
+		if (boot_mem_map.map[i].type == BOOT_MEM_RAM)
+			free_bootmem(PFN_PHYS(start), size << PAGE_SHIFT);
 		memory_present(0, start, end);
 	}
 
-- 
1.7.9.7

