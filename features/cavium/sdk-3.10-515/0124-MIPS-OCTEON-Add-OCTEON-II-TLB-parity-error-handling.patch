From 6190c579d9352cc5d1b8890b34a7ad6c5596276a Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Thu, 20 Dec 2012 16:15:26 -0800
Subject: [PATCH 124/382] MIPS/OCTEON: Add OCTEON II TLB parity error handling

Based on SDK octeon3_3.10.

Add definitions of OCTEON II CvmMemCtl bits and enable TLB parity checks.
Add octeon2_mcheck_handler for TLB parity errors.
  We need to temporarily disable TLB Parity checks early in the handler
  so we don't get into an endless loop.
Add handling of TLB parity errors into EDAC driver.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/cavium-octeon/setup.c       |    4 +++
 arch/mips/include/asm/octeon/octeon.h |   21 +++++++++++++++-
 arch/mips/kernel/genex.S              |   14 ++++++++++-
 arch/mips/mm/c-octeon.c               |   41 +++++++++++++++++++++++++++++++++
 drivers/edac/octeon_edac-pc.c         |    8 +++++-
 5 files changed, 84 insertions(+), 4 deletions(-)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index ef08f99..73ce877 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -485,6 +485,10 @@ void octeon_user_io_init(void)
 	 * mode. */
 	cvmmemctl.s.cvmsegenau = 0;
 
+	/* Enable TLB parity error reporting on OCTEON II */
+	if (OCTEON_IS_OCTEON2())
+		cvmmemctl.s.tlbperrena = 1;
+
 	write_c0_cvmmemctl(cvmmemctl.u64);
 
 	/* Setup of CVMSEG is done in kernel-entry-init.h */
diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index f25eff0..4add0dc 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -184,7 +184,19 @@ union octeon_cvmemctl {
 		/* RO 1 = BIST fail, 0 = BIST pass */
 		uint64_t wbfbist:1;
 		/* Reserved */
-		uint64_t reserved:17;
+		uint64_t reserved:13;
+		/* When set, TLB parity errors can occur. */
+		uint64_t tlbperrena:1;
+		/* OCTEON II - When set, CVMSET LM parity errors are enabled. */
+		uint64_t lmemperrena:1;
+		/* OCTEON II - If set, NUDGE/WRITEBACK_INVALIDATE,
+		 * NUDGE_WB, EVICT_SOON, LC, CONT_WRITE_BACK,
+		 * PREPARE_FOR_STORE and PREPARE_FOR_STORE_THROUGH
+		 * prefetch operations become NOPs. */
+		uint64_t disstpref:1;
+		/* OCTEON II - If set, NORMAL and NOTL2 prefetch
+		 * operations become NOPs. */
+		uint64_t disldpref:1;
 		/* OCTEON II - TLB replacement policy: 0 = bitmask LRU; 1 = NLU.
 		 * This field selects between the TLB replacement policies:
 		 * bitmask LRU or NLU. Bitmask LRU maintains a mask of
@@ -306,7 +318,11 @@ union octeon_cvmemctl {
 		uint64_t didtto2:1;
 		uint64_t pausetime:3;
 		uint64_t tlbnlu:1;
-		uint64_t reserved:17;
+		uint64_t disldpref:1;
+		uint64_t disstpref:1;
+		uint64_t lmemperrena:1;
+		uint64_t tlbperrena:1;
+		uint64_t reserved:13;
 		uint64_t wbfbist:1;
 		uint64_t ptgbist:1;
 		uint64_t dcmbist:1;
@@ -409,6 +425,7 @@ int unregister_co_cache_error_notifier(struct notifier_block *nb);
 #define CO_CACHE_ERROR_RECOVERABLE 0
 #define CO_CACHE_ERROR_UNRECOVERABLE 1
 #define CO_CACHE_ERROR_WB_PARITY 2
+#define CO_CACHE_ERROR_TLB_PARITY 3
 
 extern unsigned long long cache_err_dcache[NR_CPUS];
 
diff --git a/arch/mips/kernel/genex.S b/arch/mips/kernel/genex.S
index f19e3f4..e760c01 100644
--- a/arch/mips/kernel/genex.S
+++ b/arch/mips/kernel/genex.S
@@ -396,6 +396,18 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	TRACE_IRQS_OFF
 	.endm
 
+	.macro	__build_clear_mce
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	/* Disable TLB Parity checks. */
+	dmfc0	t0, $11, 7
+	dli	t1, (1 << 44)
+	or	t0, t0, t1
+	xor	t0, t0, t1
+	dmtc0	t0, $11, 7
+#endif
+	__build_clear_cli
+	.endm
+
 	.macro	__build_clear_fpe
 	.set	push
 	/* gas fails to assemble cfc1 for some archs (octeon).*/ \
@@ -478,7 +490,7 @@ NESTED(nmi_handler, PT_SIZE, sp)
 #else
 	BUILD_HANDLER watch watch sti verbose		/* #23 */
 #endif
-	BUILD_HANDLER mcheck mcheck cli verbose		/* #24 */
+	BUILD_HANDLER mcheck mcheck mce verbose		/* #24 */
 	BUILD_HANDLER mt mt sti silent			/* #25 */
 	BUILD_HANDLER dsp dsp sti silent		/* #26 */
 	BUILD_HANDLER reserved reserved sti verbose	/* others */
diff --git a/arch/mips/mm/c-octeon.c b/arch/mips/mm/c-octeon.c
index 7165aca..711a3b9 100644
--- a/arch/mips/mm/c-octeon.c
+++ b/arch/mips/mm/c-octeon.c
@@ -209,6 +209,46 @@ static int octeon2_be_handler(struct pt_regs *regs, int is_fixup)
 		return MIPS_BE_FATAL;
 }
 
+/*
+ * Octeon specific MachineCheck handler, as TLB parity errors
+ * trigger MachineCheck errors.
+ */
+static int octeon2_mcheck_handler(struct pt_regs *regs)
+{
+	u64 dcache_err;
+	u64 tlbperr_mask = 1ULL << 5;
+	dcache_err = read_octeon_c0_dcacheerr();
+	if (dcache_err & tlbperr_mask) {
+		int rv;
+		union octeon_cvmemctl cvmmemctl;
+
+		/* Clear the indicator */
+		write_octeon_c0_dcacheerr(tlbperr_mask);
+		/*
+		 * Blow everything away to (hopefully) write good
+		 * parity to all TLB entries
+		 */
+		local_flush_tlb_all();
+		/* Reenable TLB parity error reporting. */
+		cvmmemctl.u64 = read_c0_cvmmemctl();
+		cvmmemctl.s.tlbperrena = 1;
+		write_c0_cvmmemctl(cvmmemctl.u64);
+
+		rv = raw_notifier_call_chain(&co_cache_error_chain,
+					     CO_CACHE_ERROR_TLB_PARITY,
+					     NULL);
+		if ((rv & ~NOTIFY_STOP_MASK) != NOTIFY_OK) {
+			unsigned int coreid = cvmx_get_core_num();
+
+			pr_err("Core%u: TLB parity error:\n", coreid);
+			return MIPS_MC_FATAL;
+		}
+
+		return MIPS_MC_DISCARD;
+	}
+	return MIPS_MC_NOT_HANDLED;
+}
+
 /**
  * Probe Octeon's caches
  *
@@ -257,6 +297,7 @@ static void __cpuinit probe_octeon(void)
 		c->options |= MIPS_CPU_PREFETCH;
 
 		board_be_handler = octeon2_be_handler;
+		board_mcheck_handler = octeon2_mcheck_handler;
 		break;
 
 	case CPU_CAVIUM_OCTEON3:
diff --git a/drivers/edac/octeon_edac-pc.c b/drivers/edac/octeon_edac-pc.c
index 6706523..65bb001 100644
--- a/drivers/edac/octeon_edac-pc.c
+++ b/drivers/edac/octeon_edac-pc.c
@@ -56,6 +56,12 @@ static int  co_cache_error_event(struct notifier_block *this,
 				   core, cpu);
 		edac_device_handle_ue(p->ed, cpu, 2, "write-buffer");
 		return NOTIFY_STOP;
+	case CO_CACHE_ERROR_TLB_PARITY:
+		edac_device_printk(p->ed, KERN_ERR,
+				   "TLB parity error: core %d/cpu %d\n",
+				   core, cpu);
+		edac_device_handle_ue(p->ed, cpu, 3, "TLB-parity");
+		return NOTIFY_STOP;
 	default:
 		WARN(1, "Unknown event: %lu\n", event);
 		return NOTIFY_BAD;
@@ -100,7 +106,7 @@ static int co_cache_error_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, p);
 
 	p->ed = edac_device_alloc_ctl_info(0, "cpu", num_possible_cpus(),
-					   "cache", 3, 0, NULL, 0,
+					   "cache", 4, 0, NULL, 0,
 					   edac_device_alloc_index());
 	if (!p->ed)
 		goto err;
-- 
1.7.0.4

