From 6b135141185facd13cf95904a17912f66b0db1d2 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 18 Oct 2013 12:07:18 -0700
Subject: [PATCH 306/382] MIPS: KVM-VZ updates.

Based on SDK octeon3_3.10.

Fix bugs found bringing up KVM on real hardware.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/kvm_mips_vz.h |   39 ++++++++++++++++++++
 arch/mips/include/asm/stackframe.h  |    9 +++++
 arch/mips/kernel/asm-offsets.c      |    2 +
 arch/mips/kvm/kvm_mipsvz.c          |   67 +++++++++++------------------------
 4 files changed, 71 insertions(+), 46 deletions(-)

diff --git a/arch/mips/include/asm/kvm_mips_vz.h b/arch/mips/include/asm/kvm_mips_vz.h
index dfc6951..729d941 100644
--- a/arch/mips/include/asm/kvm_mips_vz.h
+++ b/arch/mips/include/asm/kvm_mips_vz.h
@@ -18,6 +18,45 @@ struct kvm_mips_vz {
 	unsigned int asid[NR_CPUS];	/* Per CPU ASIDs for pgd. */
 };
 
+struct kvm_mips_vcpu_vz {
+	struct kvm_vcpu *vcpu;
+	u64 c0_entrylo0;
+	u64 c0_entrylo1;
+	u64 c0_context;
+	u64 c0_userlocal;
+	u64 c0_badvaddr;
+	u64 c0_entryhi;
+	u64 c0_ebase;
+	u64 c0_xcontext;
+	u64 c0_kscratch[6];
+	u32 c0_pagemask;
+	u32 c0_pagegrain;
+	u32 c0_wired;
+	u32 c0_hwrena;
+	u32 c0_compare;
+	u32 c0_status;
+	u32 c0_cause;
+	u32 c0_index;
+
+	u32 c0_count; /* Not settable, value at last exit. */
+	u32 c0_count_offset;
+
+	int tlb_size;
+	struct mipsvz_kvm_tlb_entry *tlb_state;
+
+	u32 last_exit_insn;
+	/* Saved  mips_kvm_rootsp[] value when we are off the CPU. */
+	unsigned long rootsp;
+
+	/* Protected by kvm_arch.irq_chip_lock, the value of Guestctl2[VIP] */
+	u8 injected_ipx;
+
+	struct hrtimer compare_timer;
+	ktime_t compare_timer_read;
+
+	bool have_counter_state;
+};
+
 bool mipsvz_page_fault(struct pt_regs *regs, unsigned long write,
 		       unsigned long address);
 
diff --git a/arch/mips/include/asm/stackframe.h b/arch/mips/include/asm/stackframe.h
index 8d3f71d..f85c85d 100644
--- a/arch/mips/include/asm/stackframe.h
+++ b/arch/mips/include/asm/stackframe.h
@@ -578,8 +578,17 @@
 		lw	v1, THREAD_GUEST_ASID(v0)
 		dmtc0	v1, CP0_ENTRYHI
 		LONG_L	v1, THREAD_VCPU(v0)
+		LONG_L	v0, KVM_VCPU_ARCH_IMPL(v1)
 		LONG_L	v1, KVM_VCPU_KVM(v1)
+
 		LONG_L	v1, KVM_ARCH_IMPL(v1)
+
+		/* Inject any interrupts that may have been requested. */
+		lbu	v0, KVM_MIPS_VCPU_VZ_INJECTED_IPX(v0)
+		mfc0	k1, CP0_GUESTCTL2
+		ins	k1, v0, 8, 8
+		mtc0	k1, CP0_GUESTCTL2
+
 		.set	noreorder
 		jal	tlbmiss_handler_setup_pgd_array
 		 LONG_L	a0, KVM_MIPS_VZ_PGD(v1)
diff --git a/arch/mips/kernel/asm-offsets.c b/arch/mips/kernel/asm-offsets.c
index 985e5ce..d571acd 100644
--- a/arch/mips/kernel/asm-offsets.c
+++ b/arch/mips/kernel/asm-offsets.c
@@ -411,6 +411,8 @@ void output_kvm_defines(void)
 	OFFSET(KVM_MIPS_VCPU_TE_GUEST_KERNEL_ASID, kvm_mips_vcpu_te, guest_kernel_asid);
 	OFFSET(KVM_MIPS_VCPU_TE_GUEST_USER_ASID, kvm_mips_vcpu_te, guest_user_asid);
 
+	OFFSET(KVM_MIPS_VCPU_VZ_INJECTED_IPX, kvm_mips_vcpu_vz, injected_ipx);
+
 	OFFSET(COP0_TLB_HI, mips_coproc, reg[MIPS_CP0_TLB_HI][0]);
 	OFFSET(COP0_STATUS, mips_coproc, reg[MIPS_CP0_STATUS][0]);
 	BLANK();
diff --git a/arch/mips/kvm/kvm_mipsvz.c b/arch/mips/kvm/kvm_mipsvz.c
index 85af3cc..16bacee 100644
--- a/arch/mips/kvm/kvm_mipsvz.c
+++ b/arch/mips/kvm/kvm_mipsvz.c
@@ -45,44 +45,6 @@ struct mipsvz_kvm_tlb_entry {
 	u32 pagemask;
 };
 
-struct kvm_mips_vcpu_vz {
-	struct kvm_vcpu *vcpu;
-	u64 c0_entrylo0;
-	u64 c0_entrylo1;
-	u64 c0_context;
-	u64 c0_userlocal;
-	u64 c0_badvaddr;
-	u64 c0_entryhi;
-	u64 c0_ebase;
-	u64 c0_xcontext;
-	u64 c0_kscratch[6];
-	u32 c0_pagemask;
-	u32 c0_pagegrain;
-	u32 c0_wired;
-	u32 c0_hwrena;
-	u32 c0_compare;
-	u32 c0_status;
-	u32 c0_cause;
-	u32 c0_index;
-
-	u32 c0_count; /* Not settable, value at last exit. */
-	u32 c0_count_offset;
-
-	int tlb_size;
-	struct mipsvz_kvm_tlb_entry *tlb_state;
-
-	u32 last_exit_insn;
-	/* Saved  mips_kvm_rootsp[] value when we are off the CPU. */
-	unsigned long rootsp;
-
-	/* Protected by kvm_arch.irq_chip_lock, the value of Guestctl2[VIP] */
-	u8 injected_ipx;
-
-	struct hrtimer compare_timer;
-	ktime_t compare_timer_read;
-
-	bool have_counter_state;
-};
 
 static bool mipsvz_count_expired(u32 old_count, u32 new_count, u32 compare)
 {
@@ -381,7 +343,7 @@ int mipsvz_arch_hardware_enable(void *garbage)
 	cmv_count = read_c0_cvmcount();
 	local_irq_restore(flags);
 
-	mipsvz_cp0_count_offset[cpu] = ((u32)cmv_count) - count;
+	mipsvz_cp0_count_offset[cpu] = 0; /*((u32)cmv_count) - count;*/
 
 	return 0;
 }
@@ -607,7 +569,6 @@ static void mipsvz_assert_irqs(struct kvm *kvm, u32 effected_cpus)
 			gc2 = (gc2 & ~0xff00) | (((u32)vcpu_vz->injected_ipx) << 8);
 			write_c0_guestctl2(gc2);
 		} else {
-			kvm_make_request(KVM_REQ_EVENT, vcpu);
 			kvm_vcpu_kick(vcpu);
 		}
 	}
@@ -912,7 +873,8 @@ static void mipsvz_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
 	if (test_tsk_thread_flag(current, TIF_GUESTMODE))
 		mips_kvm_rootsp[vcpu->cpu] = vcpu_vz->rootsp;
 
-	write_c0_gtoffset(mipsvz_cp0_count_offset[cpu] + vcpu_vz->c0_count_offset);
+	/* write_c0_gtoffset(mipsvz_cp0_count_offset[cpu] + vcpu_vz->c0_count_offset); */
+	write_c0_gtoffset(0);
 
 	local_irq_save(flags);
 
@@ -1392,11 +1354,16 @@ static int mipsvz_vcpu_run(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)
 
 	lose_fpu(1);
 
+	kvm_debug("mipsvz_vcpu_run enter epc: %016lx\n", vcpu->arch.epc);
+
 	WARN(irqs_disabled(), "IRQs should be on here.");
 	local_irq_disable();
 	kvm_run->exit_reason = KVM_EXIT_UNKNOWN;
 	cpu = raw_smp_processor_id();
 
+	srcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);
+	kvm_guest_enter();
+
 	/*
 	 * Make sure the Root guest and host contexts are in the same
 	 * ASID generation
@@ -1426,11 +1393,16 @@ static int mipsvz_vcpu_run(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)
 		disable_fpu();
 	}
 
+	kvm_guest_exit();
+
 	local_irq_enable();
 
+	vcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);
+
 	if (signal_pending(current) && kvm_run->exit_reason == KVM_EXIT_INTR)
 		ret = -EINTR;
 
+	kvm_debug("mipsvz_vcpu_run exit epc: %016lx\n", vcpu->arch.epc);
 	return ret;
 }
 #if 0
@@ -1475,11 +1447,10 @@ static int mipsvz_vcpu_runnable(struct kvm_vcpu *vcpu)
 	struct kvm *kvm = vcpu->kvm;
 	struct kvm_mips_vz *kvm_mips_vz = kvm->arch.impl;
 	u8 injected_ipx;
-
-	kvm_debug("kvm_arch_vcpu_runnable\n");
+	int r = 0;
 
 	if (!kvm_mips_vz->irq_chip)
-		return 0;
+		goto out;
 
 	irqchip_regs = page_address(kvm_mips_vz->irq_chip);
 
@@ -1487,7 +1458,10 @@ static int mipsvz_vcpu_runnable(struct kvm_vcpu *vcpu)
 	injected_ipx = vcpu_vz->injected_ipx;
 	spin_unlock_irqrestore(&kvm_mips_vz->irq_chip_lock, flags);
 
-	return injected_ipx != 0;
+	r =  injected_ipx != 0;
+out:
+	kvm_debug("kvm_arch_vcpu_runnable: %d\n", r);
+	return r;
 }
 
 static void mipsvz_hypercall_exit_vm(struct pt_regs *regs)
@@ -1694,7 +1668,7 @@ static void mipsvz_handle_gpsi_mtc0(struct pt_regs *regs,
 		val = regs->regs[insn.c0m_format.rt];
 		offset = val - read_gc0_count();
 		vcpu_vz->c0_count_offset += offset;
-		write_c0_gtoffset(mipsvz_cp0_count_offset[vcpu->cpu] + vcpu_vz->c0_count_offset);
+		/* write_c0_gtoffset(mipsvz_cp0_count_offset[vcpu->cpu] + vcpu_vz->c0_count_offset); */
 		break;
 	default:
 		goto bad_reg;
@@ -1818,6 +1792,7 @@ static const mipsvz_hypervisor_handler_t mipsvz_hypervisor_handlers[] = {
 	mipsvz_default_ex,	/* 30 - Reserved */
 	mipsvz_default_ex,	/* 31 - Reserved */
 };
+
 /*
  * Hypervisor Exception handler, called with interrupts disabled.
  */
-- 
1.7.0.4

