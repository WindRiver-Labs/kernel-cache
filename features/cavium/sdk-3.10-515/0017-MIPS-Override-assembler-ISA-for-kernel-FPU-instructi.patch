From 4201d1d02c8a64a749bb465acc1a9736dc71300e Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Mon, 28 Jan 2013 14:33:16 -0800
Subject: [PATCH 017/382] MIPS: Override assembler ISA for kernel FPU instructions.

Based on SDK octeon3_3.10.

Some versions of the assembler will not assemble CFC1 for OCTEON, so
override the ISA for these.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/kernel/branch.c   |    6 +++++-
 arch/mips/kernel/ptrace.c   |   24 ++++++++++++++++++++----
 arch/mips/kernel/ptrace32.c |   12 ++++++++++--
 arch/mips/math-emu/cp1emu.c |    6 +++++-
 4 files changed, 40 insertions(+), 8 deletions(-)

diff --git a/arch/mips/kernel/branch.c b/arch/mips/kernel/branch.c
index 46c2ad0..44118d3 100644
--- a/arch/mips/kernel/branch.c
+++ b/arch/mips/kernel/branch.c
@@ -366,7 +366,11 @@ int __compute_return_epc_for_insn(struct pt_regs *regs,
 	case cop1_op:
 		preempt_disable();
 		if (is_fpu_owner())
-			asm volatile("cfc1\t%0,$31" : "=r" (fcr31));
+			asm volatile(
+				".set push\n"
+				"\t.set mips1\n"
+				"\tcfc1\t%0,$31\n"
+				"\t.set pop" : "=r" (fcr31));
 		else
 			fcr31 = current->thread.fpu.fcr31;
 		preempt_enable();
diff --git a/arch/mips/kernel/ptrace.c b/arch/mips/kernel/ptrace.c
index 9c6299c..fbf70f0 100644
--- a/arch/mips/kernel/ptrace.c
+++ b/arch/mips/kernel/ptrace.c
@@ -129,13 +129,21 @@ int ptrace_getfpregs(struct task_struct *child, __u32 __user *data)
 			unsigned int vpflags = dvpe();
 			flags = read_c0_status();
 			__enable_fpu();
-			__asm__ __volatile__("cfc1\t%0,$0" : "=r" (tmp));
+			__asm__ __volatile__(
+				".set push\n"
+				"\t.set mips1\n"
+				"\tcfc1\t%0,$0\n"
+				"\t.set pop" : "=r" (tmp));
 			write_c0_status(flags);
 			evpe(vpflags);
 		} else {
 			flags = read_c0_status();
 			__enable_fpu();
-			__asm__ __volatile__("cfc1\t%0,$0" : "=r" (tmp));
+			__asm__ __volatile__(
+				".set push\n"
+				"\t.set mips1\n"
+				"\tcfc1\t%0,$0\n"
+				"\t.set pop" : "=r" (tmp));
 			write_c0_status(flags);
 		}
 	} else {
@@ -348,13 +356,21 @@ long arch_ptrace(struct task_struct *child, long request,
 				unsigned int vpflags = dvpe();
 				flags = read_c0_status();
 				__enable_fpu();
-				__asm__ __volatile__("cfc1\t%0,$0": "=r" (tmp));
+				__asm__ __volatile__(
+					".set push\n"
+					"\t.set mips1\n"
+					"\tcfc1\t%0,$0\n"
+					"\t.set pop" : "=r" (tmp));
 				write_c0_status(flags);
 				evpe(vpflags);
 			} else {
 				flags = read_c0_status();
 				__enable_fpu();
-				__asm__ __volatile__("cfc1\t%0,$0": "=r" (tmp));
+				__asm__ __volatile__(
+					".set push\n"
+					"\t.set mips1\n"
+					"\tcfc1\t%0,$0\n"
+					"\t.set pop" : "=r" (tmp));
 				write_c0_status(flags);
 			}
 #ifdef CONFIG_MIPS_MT_SMTC
diff --git a/arch/mips/kernel/ptrace32.c b/arch/mips/kernel/ptrace32.c
index 9486055..d240ef9 100644
--- a/arch/mips/kernel/ptrace32.c
+++ b/arch/mips/kernel/ptrace32.c
@@ -148,13 +148,21 @@ long compat_arch_ptrace(struct task_struct *child, compat_long_t request,
 				unsigned int vpflags = dvpe();
 				flags = read_c0_status();
 				__enable_fpu();
-				__asm__ __volatile__("cfc1\t%0,$0": "=r" (tmp));
+				__asm__ __volatile__(
+					".set push\n"
+					"\t.set mips1\n"
+					"\tcfc1\t%0,$0\n"
+					"\t.set pop" : "=r" (tmp));
 				write_c0_status(flags);
 				evpe(vpflags);
 			} else {
 				flags = read_c0_status();
 				__enable_fpu();
-				__asm__ __volatile__("cfc1\t%0,$0": "=r" (tmp));
+				__asm__ __volatile__(
+					".set push\n"
+					"\t.set mips1\n"
+					"\tcfc1\t%0,$0\n"
+					"\t.set pop" : "=r" (tmp));
 				write_c0_status(flags);
 			}
 #ifdef CONFIG_MIPS_MT_SMTC
diff --git a/arch/mips/math-emu/cp1emu.c b/arch/mips/math-emu/cp1emu.c
index f037719..b71eb46 100644
--- a/arch/mips/math-emu/cp1emu.c
+++ b/arch/mips/math-emu/cp1emu.c
@@ -807,7 +807,11 @@ static int isBranchInstr(struct pt_regs *regs, struct mm_decoded_insn dec_insn,
 		if (insn.i_format.rs == bc_op) {
 			preempt_disable();
 			if (is_fpu_owner())
-				asm volatile("cfc1\t%0,$31" : "=r" (fcr31));
+				asm volatile(
+					     ".set push\n"
+					     "	.set mips1\n"
+					     "	cfc1	%0,$31\n"
+					     "	.set pop" : "=r" (fcr31));
 			else
 				fcr31 = current->thread.fpu.fcr31;
 			preempt_enable();
-- 
1.7.0.4

