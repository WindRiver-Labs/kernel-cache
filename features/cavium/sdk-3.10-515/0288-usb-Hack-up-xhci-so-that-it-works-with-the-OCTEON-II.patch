From 2cf265224d84b130704d8679e19b0edac90cf5b4 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Mon, 7 Oct 2013 13:32:32 -0700
Subject: [PATCH 288/382] usb: Hack up xhci, so that it works with the OCTEON III xHCI controller.

Based on SDK octeon3_3.10.

Work in progress, we will keep cleaning this up.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/usb/dwc3/core.c        |   79 +++++++----------
 drivers/usb/host/Kconfig       |    6 ++
 drivers/usb/host/Makefile      |    1 +
 drivers/usb/host/xhci-octeon.c |  196 ++++++++++++++++++++++++++++++++++++++++
 drivers/usb/host/xhci.c        |    2 +-
 5 files changed, 237 insertions(+), 47 deletions(-)
 create mode 100644 drivers/usb/host/xhci-octeon.c

diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index 358375e..0e9c373 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -63,6 +63,8 @@
 static char *maximum_speed = "super";
 module_param(maximum_speed, charp, 0);
 MODULE_PARM_DESC(maximum_speed, "Maximum supported speed.");
+extern void octeon3_usb_phy_reset(int index);
+static u64 xhci_octeon_dma_mask = DMA_BIT_MASK(64);
 
 /* -------------------------------------------------------------------------- */
 
@@ -83,6 +85,7 @@ void dwc3_set_mode(struct dwc3 *dwc, u32 mode)
 static void dwc3_core_soft_reset(struct dwc3 *dwc)
 {
 	u32		reg;
+	int 		index;
 
 	/* Before Resetting PHY, put Core in Reset */
 	reg = dwc3_readl(dwc->regs, DWC3_GCTL);
@@ -99,8 +102,10 @@ static void dwc3_core_soft_reset(struct dwc3 *dwc)
 	reg |= DWC3_GUSB2PHYCFG_PHYSOFTRST;
 	dwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);
 
-	usb_phy_init(dwc->usb2_phy);
-	usb_phy_init(dwc->usb3_phy);
+	index = (((uint64_t)(dwc->regs) & 0x10000000000ull) ? 1:0);
+	octeon3_usb_phy_reset(index);
+	//usb_phy_init(dwc->usb2_phy);
+	//usb_phy_init(dwc->usb3_phy);
 	mdelay(100);
 
 	/* Clear USB3 PHY reset */
@@ -359,8 +364,8 @@ err0:
 
 static void dwc3_core_exit(struct dwc3 *dwc)
 {
-	usb_phy_shutdown(dwc->usb2_phy);
-	usb_phy_shutdown(dwc->usb3_phy);
+	//usb_phy_shutdown(dwc->usb2_phy);
+	//usb_phy_shutdown(dwc->usb3_phy);
 }
 
 #define DWC3_ALIGN_MASK		(16 - 1)
@@ -429,43 +434,25 @@ static int dwc3_probe(struct platform_device *pdev)
 	if (node) {
 		dwc->usb2_phy = devm_usb_get_phy_by_phandle(dev, "usb-phy", 0);
 		dwc->usb3_phy = devm_usb_get_phy_by_phandle(dev, "usb-phy", 1);
-	} else {
-		dwc->usb2_phy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);
-		dwc->usb3_phy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB3);
-	}
-
-	if (IS_ERR(dwc->usb2_phy)) {
-		ret = PTR_ERR(dwc->usb2_phy);
-
-		/*
-		 * if -ENXIO is returned, it means PHY layer wasn't
-		 * enabled, so it makes no sense to return -EPROBE_DEFER
-		 * in that case, since no PHY driver will ever probe.
-		 */
-		if (ret == -ENXIO)
-			return ret;
-
-		dev_err(dev, "no usb2 phy configured\n");
-		return -EPROBE_DEFER;
+		if (of_property_read_bool(node, "usb-phy")) {
+			dwc->usb2_phy = devm_usb_get_phy_by_phandle(dev,"usb-phy", 0);
+			if (IS_ERR(dwc->usb2_phy))
+				return PTR_ERR(dwc->usb2_phy);
+			dwc->usb3_phy = devm_usb_get_phy_by_phandle(dev, "usb-phy", 1);
+			if (IS_ERR(dwc->usb3_phy))
+				return PTR_ERR(dwc->usb3_phy);
+		}
+		else {
+			dwc->usb2_phy = NULL;
+			dwc->usb3_phy = NULL;
+		}
 	}
-
-	if (IS_ERR(dwc->usb3_phy)) {
-		ret = PTR_ERR(dwc->usb3_phy);
-
-		/*
-		 * if -ENXIO is returned, it means PHY layer wasn't
-		 * enabled, so it makes no sense to return -EPROBE_DEFER
-		 * in that case, since no PHY driver will ever probe.
-		 */
-		if (ret == -ENXIO)
-			return ret;
-
-		dev_err(dev, "no usb3 phy configured\n");
-		return -EPROBE_DEFER;
+	else {
+			dwc->usb2_phy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);
+			dwc->usb3_phy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB3);
 	}
-
-	usb_phy_set_suspend(dwc->usb2_phy, 0);
-	usb_phy_set_suspend(dwc->usb3_phy, 0);
+	//usb_phy_set_suspend(dwc->usb2_phy, 0);
+	//usb_phy_set_suspend(dwc->usb3_phy, 0);
 
 	spin_lock_init(&dwc->lock);
 	platform_set_drvdata(pdev, dwc);
@@ -474,7 +461,7 @@ static int dwc3_probe(struct platform_device *pdev)
 	dwc->regs_size	= resource_size(res);
 	dwc->dev	= dev;
 
-	dev->dma_mask	= dev->parent->dma_mask;
+	dev->dma_mask	= &xhci_octeon_dma_mask;
 	dev->dma_parms	= dev->parent->dma_parms;
 	dma_set_coherent_mask(dev, dev->parent->coherent_dma_mask);
 
@@ -603,8 +590,8 @@ static int dwc3_remove(struct platform_device *pdev)
 {
 	struct dwc3	*dwc = platform_get_drvdata(pdev);
 
-	usb_phy_set_suspend(dwc->usb2_phy, 1);
-	usb_phy_set_suspend(dwc->usb3_phy, 1);
+	//usb_phy_set_suspend(dwc->usb2_phy, 1);
+	//usb_phy_set_suspend(dwc->usb3_phy, 1);
 
 	pm_runtime_put(&pdev->dev);
 	pm_runtime_disable(&pdev->dev);
@@ -700,8 +687,8 @@ static int dwc3_suspend(struct device *dev)
 	dwc->gctl = dwc3_readl(dwc->regs, DWC3_GCTL);
 	spin_unlock_irqrestore(&dwc->lock, flags);
 
-	usb_phy_shutdown(dwc->usb3_phy);
-	usb_phy_shutdown(dwc->usb2_phy);
+	//usb_phy_shutdown(dwc->usb3_phy);
+	//usb_phy_shutdown(dwc->usb2_phy);
 
 	return 0;
 }
@@ -711,8 +698,8 @@ static int dwc3_resume(struct device *dev)
 	struct dwc3	*dwc = dev_get_drvdata(dev);
 	unsigned long	flags;
 
-	usb_phy_init(dwc->usb3_phy);
-	usb_phy_init(dwc->usb2_phy);
+	//usb_phy_init(dwc->usb3_phy);
+	//usb_phy_init(dwc->usb2_phy);
 	msleep(100);
 
 	spin_lock_irqsave(&dwc->lock, flags);
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 1c4b609..c9b0d5e 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -25,6 +25,12 @@ config USB_XHCI_HCD
 	  To compile this driver as a module, choose M here: the
 	  module will be called xhci-hcd.
 
+
+config USB_XHCI_HCD_OCTEON
+	tristate
+	depends on USB_XHCI_HCD && CAVIUM_OCTEON_SOC
+	default y
+
 if USB_XHCI_HCD
 
 config USB_XHCI_PLATFORM
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index b35871a..4ccd6a2 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -51,5 +51,6 @@ obj-$(CONFIG_USB_IMX21_HCD)	+= imx21-hcd.o
 obj-$(CONFIG_USB_FSL_MPH_DR_OF)	+= fsl-mph-dr-of.o
 obj-$(CONFIG_USB_OCTEON_HCD)	+= octeon-hcd.o
 obj-$(CONFIG_USB_OCTEON2_COMMON) += octeon2-common.o
+obj-$(CONFIG_USB_XHCI_HCD_OCTEON) += xhci-octeon.o
 obj-$(CONFIG_USB_HCD_BCMA)	+= bcma-hcd.o
 obj-$(CONFIG_USB_HCD_SSB)	+= ssb-hcd.o
diff --git a/drivers/usb/host/xhci-octeon.c b/drivers/usb/host/xhci-octeon.c
new file mode 100644
index 0000000..e35e9fb
--- /dev/null
+++ b/drivers/usb/host/xhci-octeon.c
@@ -0,0 +1,196 @@
+/*
+ * XHCI HCD glue for Cavium Octeon III SOCs.
+ *
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2010 Cavium Networks
+ *
+ */
+
+
+#include <linux/platform_device.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-usbdrdx-defs.h>
+
+/* Common clock init code.  */
+void octeon3_usb_clocks_start(int node);
+void octeon3_usb_clocks_stop(int node);
+void octeon3_usb_set_endian_mode(int node);
+
+static int __init xhci_octeon_init(void)
+{
+	octeon3_usb_clocks_start(0);
+	octeon3_usb_clocks_start(1);
+	octeon3_usb_set_endian_mode(0);
+	octeon3_usb_set_endian_mode(1);
+	return 0;
+}
+
+static void __exit xhci_octeon_exit(void)
+{
+	octeon3_usb_clocks_stop(0);
+	octeon3_usb_clocks_stop(1);
+}
+
+arch_initcall(xhci_octeon_init);
+module_exit(xhci_octeon_exit);
+
+
+static DEFINE_MUTEX(octeon3_usb1_clocks_mutex);
+static DEFINE_MUTEX(octeon3_usb2_clocks_mutex);
+static int octeon3_usb1_clock_start_cnt;
+static int octeon3_usb2_clock_start_cnt;
+
+void octeon3_usb_clocks_start(int index)
+{
+	u64 div;
+	union cvmx_usbdrdx_uctl_ctl uctl_ctl;
+	int ref_clk_sel = 2; //to_do, get from device tree
+
+	if (index == 0) {
+		mutex_lock(&octeon3_usb1_clocks_mutex);
+		octeon3_usb1_clock_start_cnt++;
+		if (octeon3_usb1_clock_start_cnt != 1)
+			goto exit;
+	}
+	else {
+		mutex_lock(&octeon3_usb2_clocks_mutex);
+		octeon3_usb2_clock_start_cnt++;
+		if (octeon3_usb2_clock_start_cnt != 1)
+			goto exit;
+	}
+	printk("Initializing USB clocks !!!!!!\n");
+	/*
+	* Step 1: Wait for voltages stable.  That surely happened
+	* before starting the kernel.
+	* Ensure the reference clock is up and stable ??
+	*/
+
+	/* Step 2: Wait for IOI reset to deassert  ?? */
+
+	/* Step 3: program over current indication if desired, later */
+
+	/* Step 3: program the port power control feature if desired, later */
+
+	/* Step 4: Assert all resets */
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.s.uphy_rst = 1;
+	uctl_ctl.s.uahc_rst = 1;
+	uctl_ctl.s.uctl_rst = 1;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+
+	/* Step 5a: Reset the clock dividers */
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.s.h_clkdiv_rst = 1;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+
+	/* 5b */
+	/* Step 5b: Select controller clock frequency */
+	div = 2; //vinita_to_to uncomment later
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.s.h_clkdiv_sel = div;
+	uctl_ctl.s.h_clk_en = 1;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	if(div != uctl_ctl.s.h_clkdiv_sel || !uctl_ctl.s.h_clk_en) {
+		printk("ERROR: usb controller clock init\n");
+			goto exit;
+	}
+
+	/* Step 5c: Deassert the controller clock divider reset */
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.s.h_clkdiv_rst = 0;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+
+	/* Step ??*/
+	cvmx_wait(2000);
+
+	/* Step 6a-6d & 7: Reference clock configuration */
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.s.ssc_en =0;
+	uctl_ctl.s.ref_ssp_en = 1;
+	uctl_ctl.s.ref_clk_sel = ref_clk_sel;
+	uctl_ctl.s.ref_clk_fsel = 0x07;
+	uctl_ctl.s.ref_clk_div2 = 0;
+	uctl_ctl.s.mpll_multiplier = 0x19;
+	uctl_ctl.s.ss_power_en = 1;
+	uctl_ctl.s.hs_power_en = 1;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+
+	/* Step 9 */
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.s.uctl_rst = 0;
+	uctl_ctl.s.uahc_rst = 0;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+
+	/* Step 8*/
+	cvmx_wait(10);
+
+	/* Step 10*/
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.s.csclk_en = 1;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+
+	/*Step 11*/
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	printk("Enabling host mode\n");
+	uctl_ctl.s.drd_mode = 0;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+
+	octeon_error_tree_enable(CVMX_ERROR_GROUP_USB, -1);//to_do separate for both usb
+exit:
+	if (index == 0)
+		mutex_unlock(&octeon3_usb1_clocks_mutex);
+	else
+		mutex_unlock(&octeon3_usb2_clocks_mutex);
+
+}
+EXPORT_SYMBOL(octeon3_usb_clocks_start);
+
+void octeon3_usb_clocks_stop(int index)
+{
+	if (index == 0) {
+		mutex_lock(&octeon3_usb1_clocks_mutex);
+		octeon3_usb1_clock_start_cnt--;
+		if (octeon3_usb1_clock_start_cnt == 0)
+			octeon_error_tree_disable(CVMX_ERROR_GROUP_USB, -1);//to_do separate for both usb
+		mutex_unlock(&octeon3_usb1_clocks_mutex);
+	} else {
+		mutex_lock(&octeon3_usb2_clocks_mutex);
+		octeon3_usb2_clock_start_cnt--;
+		if (octeon3_usb2_clock_start_cnt == 0 )
+			octeon_error_tree_disable(CVMX_ERROR_GROUP_USB, -1);//to_do separate for both usb
+		mutex_unlock(&octeon3_usb1_clocks_mutex);
+	}
+}
+EXPORT_SYMBOL(octeon3_usb_clocks_stop);
+
+void octeon3_usb_set_endian_mode(int index)
+{
+	union cvmx_usbdrdx_uctl_shim_cfg shim_cfg;
+	shim_cfg.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_SHIM_CFG(index));
+	shim_cfg.s.dma_endian_mode = 1;
+	shim_cfg.s.csr_endian_mode = 1; //to_do, check for little big endian
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_SHIM_CFG(index), shim_cfg.u64);
+}
+EXPORT_SYMBOL(octeon3_usb_set_endian_mode);
+
+void octeon3_usb_phy_reset(int index)
+{
+	union cvmx_usbdrdx_uctl_ctl uctl_ctl;
+
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.s.uphy_rst = 0;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
+}
+EXPORT_SYMBOL(octeon3_usb_phy_reset);
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 83f0b5a..5173c44 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -189,7 +189,7 @@ int xhci_reset(struct xhci_hcd *xhci)
 	return ret;
 }
 
-#ifdef CONFIG_PCI
+#ifdef CONFIG_DWC3_PCI
 static int xhci_free_msi(struct xhci_hcd *xhci)
 {
 	int i;
-- 
1.7.0.4

