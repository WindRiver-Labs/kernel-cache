From f0db2599ae90162621b3c7f51e6696ec1c2770d7 Mon Sep 17 00:00:00 2001
From: Peter Swain <peter.swain@cavium.com>
Date: Wed, 6 Nov 2013 11:00:01 -0800
Subject: [PATCH 336/382] MIPS: octeon3 power throttle support

Based on SDK octeon3_3.10.

Rework octeon's power-throttle to use smp_call_function,
avoiding a race on octeon3 because the cross-core COP0
access is not atomic.

Now even octeon2 uses smp_call_function() so each core accesses
own COP0 registers. It's just cleaner.

The alternate cross-core access will still be done if target cpu
is "offline", which could mean it's running a different kernel
or standalone code. Coordinating exclusive use of the _ADR/_DAT
pathway between different OS's is not yet explored.
But this change eliminates the only contribution Linux makes to
such races.
Until SE/Linux interwork here is explored, access to "offline"
cores' pow_throttle is disabled.

Also adds read-only /sys/devices/system/cpu/cpu*/power_throttle/state
to display the other pow_throttle parameters.
Probably should split this into separate single-valued attributes,
r/w where possible, so can set (eg) throttle period.

Eliminated a possible? divide-by-zero.
Dropped dead mutex.
Explicitly inc'd byteorder.h, as _XXX_ENDIAN_BITFIELD used.

bug#8603
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/cavium-octeon/octeon-power-throttle.c |  155 ++++++++++++++++++-----
 1 files changed, 126 insertions(+), 29 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-power-throttle.c b/arch/mips/cavium-octeon/octeon-power-throttle.c
index 0759c81..0bf895d 100644
--- a/arch/mips/cavium-octeon/octeon-power-throttle.c
+++ b/arch/mips/cavium-octeon/octeon-power-throttle.c
@@ -22,6 +22,7 @@
 #include <linux/smp.h>
 #include <linux/cpu.h>
 
+#include <asm/byteorder.h>
 #include <asm/octeon/octeon.h>
 
 union octeon_power_throttle_bits {
@@ -55,34 +56,99 @@ union octeon_power_throttle_bits {
 	} s;
 };
 
+/* where possible, ask target CPU to access own registers ... */
+static inline void read_my_power_throttle(void *info)
+{
+	*(u64*)info = __read_64bit_c0_register($11, 6);
+}
+
+static inline void write_my_power_throttle(void *info)
+{
+	__write_64bit_c0_register($11, 6, *(u64*)info);
+}
+
 /*
- * Given a CPU, calculate its PowThrottle register's L2C_COP0_MAP CSR
- * address.
+ * Read/Write POW_THROTTLE.
+ * Use IPI to owning cpu if possible (always).
+ *
+ * Includes tested, unused code for cross-core access
+ * (by CVMX_L2C_COP0_ADR/CVMX_L2C_COP0_DAT on cn7xxx,
+ * or CVMX_L2C_COP0_MAP on older octeons), 
+ * but not needed unless for low-power init (when other cpu may be disabled)
+ * or broadcast (cpu < 0).
  */
-static u64 octeon_power_throttle_csr_addr(int cpu)
+static void octeon_power_throttle_csr_op(int cpu,
+	union octeon_power_throttle_bits *r, bool write)
 {
-	u64 csr_addr, reg_num, reg_reg, reg_sel;
-	int ppid = octeon_coreid_for_cpu(cpu);
-
-	/* register 11 select 6 */
-	reg_reg = 11;
-	reg_sel = 6;
-	reg_num = (ppid << 8) + (reg_reg << 3) + reg_sel;
-	csr_addr = CVMX_L2C_COP0_MAPX(0) + ((reg_num) << 3);
-	return csr_addr;
+	bool use_ipi;
+
+	get_online_cpus();
+
+	use_ipi = (cpu >= 0 && cpu_online(cpu));
+
+	if (use_ipi) {
+		smp_call_function_single(cpu, 
+			(write ? write_my_power_throttle
+			       : read_my_power_throttle),
+			r, 1);
+	} else if (OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+		cvmx_l2c_cop0_adr_t adr = { .u64 = 0, };
+
+		adr.s.ppid = (cpu < 0) ? -1 : octeon_coreid_for_cpu(cpu);
+		adr.s.root = 1;
+		/* pow_throttle: register 11 select 6 */
+		adr.s.rd = 11;
+		adr.s.sel = 6;
+
+		/*
+		 * Race Alert: clash with other _ADR/_DAT users possible here,
+		 * which is why the ipi method is preferred ...
+		 */
+		cvmx_write_csr(CVMX_L2C_COP0_ADR, adr.u64);
+
+		if (write)
+			cvmx_write_csr(CVMX_L2C_COP0_DAT, r->raw);
+		else
+			r->raw = cvmx_read_csr(CVMX_L2C_COP0_DAT);
+
+		WARN(0x2bad2bad2bad2bad == r->raw,
+			"CVMX_L2C_COP0_DAT bad read cpu=%d\n", cpu);
+	} else {
+		int ppid = (cpu < 0) ? -1 : octeon_coreid_for_cpu(cpu);
+		/* pow_throttle: register 11 select 6 */
+		u64 reg_reg = 11;
+		u64 reg_sel = 6;
+		u64 reg_num = ((ppid & 0x3f) << 8)
+			| ((reg_reg & 0x1f) << 3)
+			| (reg_sel & 0x7);
+
+		/* no race on older octeons ... */
+		u64 csr_addr = CVMX_L2C_COP0_MAPX(reg_num);
+
+		if (write)
+			cvmx_write_csr(csr_addr, r->raw);
+		else
+			r->raw = cvmx_read_csr(csr_addr);
+	}
+	put_online_cpus();
 }
 
-static void octeon_power_throttle_init_cpu(unsigned int cpu)
+/*
+ * Throttle given CPU's power (or all, if cpu < 0)
+ */
+static void octeon_power_throttle_init_cpu(int cpu)
 {
-	u64 csr_addr;
 	union octeon_power_throttle_bits r;
+	octeon_power_throttle_csr_op(cpu, &r, false);
 
-	csr_addr = octeon_power_throttle_csr_addr(cpu);
-	r.raw = cvmx_read_csr(csr_addr);
+	r.s.ovrrd = 0;		/* MBZ */
+	r.s.distag = 0;		/* MBZ */
+	r.s.period = 2;		/* 256 cycles */
 	r.s.minthr = 0;
 	r.s.maxthr = 0xff;
-	r.s.period = 2;		/* 256 cycles */
-	cvmx_write_csr(csr_addr, r.raw);
+	r.s.powlim = 0xff;	/* start full speed */
+
+	octeon_power_throttle_csr_op(cpu, &r, true);
 }
 
 /*
@@ -90,18 +156,21 @@ static void octeon_power_throttle_init_cpu(unsigned int cpu)
  */
 static int octeon_power_throttle_get_powlim(unsigned int cpu)
 {
-	u64 t, rv, csr_addr;
+	int t, rv;
 	union octeon_power_throttle_bits r;
 
-	csr_addr = octeon_power_throttle_csr_addr(cpu);
-	r.raw = cvmx_read_csr(csr_addr);
+	octeon_power_throttle_csr_op(cpu, &r, false);
 	t = r.s.maxpow;
 	if (!OCTEON_IS_MODEL(OCTEON_CN63XX)) {
 		if (t < r.s.hrmpowadj)
 			return -EINVAL;
 		t -= r.s.hrmpowadj;
 	}
-	rv = (r.s.powlim * 100) / t;
+	if (t > 0)
+		rv = (r.s.powlim * 100) / t;
+	else
+		rv = 100;
+
 	return rv > 100 ? 100 : rv;
 }
 
@@ -110,14 +179,13 @@ static int octeon_power_throttle_get_powlim(unsigned int cpu)
  */
 static u64 octeon_power_throttle_set_powlim(int cpu, unsigned long percentage)
 {
-	u64 t, csr_addr;
+	u64 t;
 	union octeon_power_throttle_bits r;
 
 	if (percentage > 100)
 		return -EINVAL;
 
-	csr_addr = octeon_power_throttle_csr_addr(cpu);
-	r.raw = cvmx_read_csr(csr_addr);
+	octeon_power_throttle_csr_op(cpu, &r, false);
 	t = r.s.maxpow;
 	if (!OCTEON_IS_MODEL(OCTEON_CN63XX)) {
 		if (t < r.s.hrmpowadj)
@@ -125,10 +193,37 @@ static u64 octeon_power_throttle_set_powlim(int cpu, unsigned long percentage)
 		t -= r.s.hrmpowadj;
 	}
 	r.s.powlim = percentage > 0 ? percentage * t / 100 : 0;
-	cvmx_write_csr(csr_addr, r.raw);
+	r.s.ovrrd = 0;		/* MBZ */
+	r.s.distag = 0;		/* MBZ */
+	octeon_power_throttle_csr_op(cpu, &r, true);
+
 	return 0;
 }
 
+static ssize_t octeon_power_throttle_show_state(
+	struct device *dev,
+	struct device_attribute *attr,
+	char *buf)
+{
+	unsigned int cpu = dev->id;
+	bool online;
+	union octeon_power_throttle_bits r;
+
+	get_online_cpus();
+	online = cpu_online(cpu);
+	if (online)
+		octeon_power_throttle_csr_op(cpu, &r, false);
+	put_online_cpus();
+
+	if (!cpu_online(cpu))
+		return 0;
+
+	return sprintf(buf, "maxpow=%d powe=%d thrott=%d hrmpowadj=%d "
+			    "period=%d powlim=%d max=%d min=%d\n",
+			    r.s.maxpow, r.s.powe, r.s.thrott, r.s.hrmpowadj,
+			    r.s.period, r.s.powlim, r.s.maxthr, r.s.minthr);
+}
+
 static ssize_t octeon_power_throttle_show_percentage(
 	struct device *dev,
 	struct device_attribute *attr,
@@ -174,8 +269,13 @@ static DEVICE_ATTR(percentage, S_IRUGO | S_IWUSR,
 		   octeon_power_throttle_show_percentage,
 		   octeon_power_throttle_store_percentage);
 
+static DEVICE_ATTR(state, S_IRUGO,
+		   octeon_power_throttle_show_state,
+		   NULL);
+
 static struct attribute *octeon_power_throttle_attrs[] = {
 	&dev_attr_percentage.attr,
+	&dev_attr_state.attr,
 	NULL
 };
 
@@ -184,9 +284,6 @@ static struct attribute_group octeon_power_throttle_attr_group = {
 	.name	= "power_throttle"
 };
 
-/* Mutex protecting device creation against CPU hotplug: */
-static DEFINE_MUTEX(octeon_power_throttle_lock);
-
 static __cpuinit int octeon_power_throttle_add_dev(struct device *dev)
 {
 	return sysfs_create_group(&dev->kobj,
-- 
1.7.0.4

