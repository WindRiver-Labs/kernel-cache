From 04c2f6c733ec6b05d2872be1b5efe85c23611104 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Tue, 22 Oct 2013 15:25:22 -0700
Subject: [PATCH 312/382] MIPS kvm: Fix errors in kvm_mipsvz.

Based on SDK octeon3_3.10.

o Save and restore EPC and ErrorEPC on context switches.

o Update tlbsize when it is changed.

o Handle guest register $26,2 (ErrCtl).

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/kvm_mips_vz.h |    2 +
 arch/mips/kvm/kvm_mipsvz.c          |   56 ++++++++++++++++++++++++++---------
 2 files changed, 44 insertions(+), 14 deletions(-)

diff --git a/arch/mips/include/asm/kvm_mips_vz.h b/arch/mips/include/asm/kvm_mips_vz.h
index 729d941..09eed7e 100644
--- a/arch/mips/include/asm/kvm_mips_vz.h
+++ b/arch/mips/include/asm/kvm_mips_vz.h
@@ -26,8 +26,10 @@ struct kvm_mips_vcpu_vz {
 	u64 c0_userlocal;
 	u64 c0_badvaddr;
 	u64 c0_entryhi;
+	u64 c0_epc;
 	u64 c0_ebase;
 	u64 c0_xcontext;
+	u64 c0_errorepc;
 	u64 c0_kscratch[6];
 	u32 c0_pagemask;
 	u32 c0_pagegrain;
diff --git a/arch/mips/kvm/kvm_mipsvz.c b/arch/mips/kvm/kvm_mipsvz.c
index 16bacee..4cc5a37 100644
--- a/arch/mips/kvm/kvm_mipsvz.c
+++ b/arch/mips/kvm/kvm_mipsvz.c
@@ -73,6 +73,8 @@ static void mipsvz_install_guest_cp0(struct kvm_mips_vcpu_vz *vcpu_vz)
 	write_gc0_compare(vcpu_vz->c0_compare);
 	write_gc0_cause(vcpu_vz->c0_cause);
 	write_gc0_status(vcpu_vz->c0_status);
+	write_gc0_epc(vcpu_vz->c0_epc);
+	write_gc0_errorepc(vcpu_vz->c0_errorepc);
 	write_gc0_ebase(vcpu_vz->c0_ebase);
 	write_gc0_xcontext(vcpu_vz->c0_xcontext);
 
@@ -129,6 +131,8 @@ static void mipsvz_readout_guest_cp0(struct kvm_mips_vcpu_vz *vcpu_vz)
 	vcpu_vz->c0_count = read_gc0_count();
 
 	vcpu_vz->c0_cause = read_gc0_cause();
+	vcpu_vz->c0_epc = read_gc0_epc();
+	vcpu_vz->c0_errorepc = read_gc0_errorepc();
 	vcpu_vz->c0_ebase = read_gc0_ebase();
 	vcpu_vz->c0_xcontext = read_gc0_xcontext();
 	if (!vcpu_vz->have_counter_state)
@@ -807,7 +811,6 @@ static void mipsvz_vcpu_put(struct kvm_vcpu *vcpu)
 	unsigned long flags;
 	int i;
 	u64 memctl2, vmconfig;
-	unsigned long old_ctx;
 	int mmu_sizem1;
 
 	mipsvz_readout_guest_cp0(vcpu_vz);
@@ -834,19 +837,8 @@ static void mipsvz_vcpu_put(struct kvm_vcpu *vcpu)
 	vmconfig |= mmu_sizem1;		/* Root size TLBM1 */
 	__write_64bit_c0_register($16, 7, vmconfig);
 
-/* Copied from tlb-r4k.c */
-#define UNIQUE_ENTRYHI(idx) (CKSEG0 + ((idx) << (PAGE_SHIFT + 1)))
-	old_ctx = read_c0_entryhi();
-	write_c0_entrylo0(0);
-	write_c0_entrylo1(0);
-	for (i = 0; i < vcpu_vz->tlb_size; i++) {
-		write_c0_index(mmu_sizem1 - i);
-		write_c0_entryhi(UNIQUE_ENTRYHI(mmu_sizem1 - i));
-		mtc0_tlbw_hazard();
-		tlb_write_indexed();
-	}
-	tlbw_use_hazard();
-	write_c0_entryhi(old_ctx);
+	current_cpu_data.tlbsize = mmu_sizem1 + 1;
+	local_flush_tlb_all();
 
 	memctl2 &= ~(1ull << 17); /* INHIBITTS */
 	__write_64bit_c0_register($16, 6, memctl2);
@@ -868,6 +860,7 @@ static void mipsvz_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
 	u32 t32;
 	u64 cp_val, t64;
 	int mmu_size;
+	int mmu_sizem1;
 
 	vcpu->cpu = cpu;
 	if (test_tsk_thread_flag(current, TIF_GUESTMODE))
@@ -904,6 +897,9 @@ static void mipsvz_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
 	cp_val |= mmu_size - vcpu_vz->tlb_size - 1;	/* Root size TLBM1 */
 	__write_64bit_c0_register($16, 7, cp_val);
 
+	mmu_sizem1 = cp_val & 0xff;
+	current_cpu_data.tlbsize = mmu_sizem1 + 1;
+
 	cp_val = __read_64bit_c0_register($16, 6); /* 16, 6: CvmMemCtl2 */
 	cp_val |= (1ull << 17); /* INHIBITTS */
 	__write_64bit_c0_register($16, 6, cp_val);
@@ -1718,6 +1714,34 @@ bad_reg:
 
 }
 
+static void mipsvz_handle_gpsi_dmfc0(struct pt_regs *regs,
+				     union mips_instruction insn)
+{
+	/* Move past the DMFC0 insn */
+	if (mipsvz_compute_return_epc(regs)) {
+		kvm_err("Error: Bad EPC on DMFC0 GPSI\n");
+		mipsvz_exit_vm(regs, KVM_EXIT_INTERNAL_ERROR);
+	}
+
+	switch (insn.c0m_format.rd) {
+	case 26:
+		if (insn.c0m_format.sel != 2)
+			goto bad_reg;
+		/* ErrCtl */
+		regs->regs[insn.c0m_format.rt] = 0;
+		break;
+	default:
+		goto bad_reg;
+	}
+	return;
+
+bad_reg:
+	kvm_err("Error: Bad Reg($%d,%d) on DMTC0 GPSI\n",
+		insn.c0m_format.rd, insn.c0m_format.sel);
+	mipsvz_exit_vm(regs, KVM_EXIT_INTERNAL_ERROR);
+
+}
+
 static void mipsvz_gpsi(struct pt_regs *regs)
 {
 	union mips_instruction insn;
@@ -1738,6 +1762,10 @@ static void mipsvz_gpsi(struct pt_regs *regs)
 		 insn.c0m_format.func == mfc_op &&
 		 insn.c0m_format.code == 0)
 		mipsvz_handle_gpsi_mfc0(regs, insn);
+	else if (insn.c0m_format.opcode == cop0_op &&
+		 insn.c0m_format.func == dmfc_op &&
+		 insn.c0m_format.code == 0)
+		mipsvz_handle_gpsi_dmfc0(regs, insn);
 	else {
 		kvm_err("Error: GPSI not on CACHE, WAIT, MFC0 or MTC0: %08x\n",
 			insn.word);
-- 
1.7.0.4

