From f4a3fbf3cdda90fb26a00f6b222825ddc72f7628 Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Tue, 6 Aug 2013 15:08:35 -0700
Subject: [PATCH 184/382] MIPS: OCTEON: Fix L1 dacache parity for OCTEON3

Based on SDK octeon3_3.10.

Use COP0_ERRCTL for L1 Dcache parity and TLB parity checks for OCTEON3.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/cavium-octeon/setup.c  |   13 ++++-
 arch/mips/include/asm/mipsregs.h |    4 ++
 arch/mips/mm/c-octeon.c          |   89 +++++++++++++++++++++++++++++++++++--
 arch/mips/mm/cex-oct.S           |   37 ++++++++++++++++
 drivers/edac/octeon_edac-pc.c    |    9 +++-
 5 files changed, 142 insertions(+), 10 deletions(-)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 6bb8a72..a2392ae 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -290,7 +290,10 @@ void octeon_check_cpu_bist(void)
 		pr_err("Core%d BIST Failure: CacheErr(icache) = 0x%llx\n",
 		       coreid, bist_val);
 
-	bist_val = read_octeon_c0_dcacheerr();
+	if (current_cpu_type() == CPU_CAVIUM_OCTEON3)
+		bist_val = read_octeon_c0_errctl();
+	else
+		bist_val = read_octeon_c0_dcacheerr();
 	if (bist_val & 1)
 		pr_err("Core%d L1 Dcache parity error: "
 		       "CacheErr(dcache) = 0x%llx\n",
@@ -302,7 +305,10 @@ void octeon_check_cpu_bist(void)
 		pr_err("Core%d BIST Failure: COP0_CVM_MEM_CTL = 0x%llx\n",
 		       coreid, bist_val);
 
-	write_octeon_c0_dcacheerr(0);
+	if (current_cpu_type() == CPU_CAVIUM_OCTEON3)
+		write_octeon_c0_errctl(1);
+	else
+		write_octeon_c0_dcacheerr(0);
 }
 
 /**
@@ -494,7 +500,8 @@ void octeon_user_io_init(void)
 	cvmmemctl.s.cvmsegenau = 0;
 
 	/* Enable TLB parity error reporting on OCTEON II */
-	if (current_cpu_type() == CPU_CAVIUM_OCTEON2)
+	if (current_cpu_type() == CPU_CAVIUM_OCTEON2 ||
+	    current_cpu_type() == CPU_CAVIUM_OCTEON3)
 		cvmmemctl.s.tlbperrena = 1;
 
 	write_c0_cvmmemctl(cvmmemctl.u64);
diff --git a/arch/mips/include/asm/mipsregs.h b/arch/mips/include/asm/mipsregs.h
index 9a5fae6..0a1fcf6 100644
--- a/arch/mips/include/asm/mipsregs.h
+++ b/arch/mips/include/asm/mipsregs.h
@@ -68,6 +68,7 @@
 #define CP0_DEPC $24
 #define CP0_PERFORMANCE $25
 #define CP0_ECC $26
+#define CP0_ERRCTL $26
 #define CP0_CACHEERR $27
 #define CP0_TAGLO $28
 #define CP0_TAGHI $29
@@ -1130,6 +1131,9 @@ do {									\
 #define read_octeon_c0_dcacheerr()	__read_64bit_c0_register($27, 1)
 #define write_octeon_c0_dcacheerr(val)	__write_64bit_c0_register($27, 1, val)
 
+#define read_octeon_c0_errctl()		__read_64bit_c0_register($26, 0)
+#define write_octeon_c0_errctl(val)	__write_64bit_c0_register($26, 0, val)
+
 /* BMIPS3300 */
 #define read_c0_brcm_config_0()		__read_32bit_c0_register($22, 0)
 #define write_c0_brcm_config_0(val)	__write_32bit_c0_register($22, 0, val)
diff --git a/arch/mips/mm/c-octeon.c b/arch/mips/mm/c-octeon.c
index fb351e8..66c7d7c 100644
--- a/arch/mips/mm/c-octeon.c
+++ b/arch/mips/mm/c-octeon.c
@@ -250,6 +250,77 @@ static int octeon2_mcheck_handler(struct pt_regs *regs)
 	return MIPS_MC_NOT_HANDLED;
 }
 
+/*
+ * Octeon3 specific bus error handler, as write buffer parity errors
+ * trigger bus errors.  These are fatal since the copy in the write buffer
+ * is the only copy of the data.
+ */
+static int octeon3_be_handler(struct pt_regs *regs, int is_fixup)
+{
+	u64 dcache_err;
+	u64 wbfperr_mask = 1ULL << 9;
+
+	dcache_err = read_octeon_c0_errctl();
+	if (dcache_err & wbfperr_mask) {
+		int rv = raw_notifier_call_chain(&co_cache_error_chain,
+						 CO_CACHE_ERROR_WB_PARITY,
+						 NULL);
+		if ((rv & ~NOTIFY_STOP_MASK) != NOTIFY_OK) {
+			unsigned int coreid = cvmx_get_core_num();
+
+			pr_err("Core%u: Write buffer parity error:\n", coreid);
+			pr_err("CacheErr (Dcache) == %llx\n", dcache_err);
+		}
+
+		write_octeon_c0_errctl(wbfperr_mask);
+		return MIPS_BE_FATAL;
+	}
+	if (is_fixup)
+		return MIPS_BE_FIXUP;
+	else
+		return MIPS_BE_FATAL;
+}
+
+/*
+ * Octeon3 specific MachineCheck handler, as TLB parity errors
+ * trigger MachineCheck errors.
+ */
+static int octeon3_mcheck_handler(struct pt_regs *regs)
+{
+	u64 dcache_err;
+	u64 tlbperr_mask = 1ULL << 14;
+	dcache_err = read_octeon_c0_errctl();
+	if (dcache_err & tlbperr_mask) {
+		int rv;
+		union octeon_cvmemctl cvmmemctl;
+
+		/* Clear the indicator */
+		write_octeon_c0_errctl(tlbperr_mask);
+		/*
+		 * Blow everything away to (hopefully) write good
+		 * parity to all TLB entries
+		 */
+		local_flush_tlb_all();
+		/* Reenable TLB parity error reporting. */
+		cvmmemctl.u64 = read_c0_cvmmemctl();
+		cvmmemctl.s.tlbperrena = 1;
+		write_c0_cvmmemctl(cvmmemctl.u64);
+
+		rv = raw_notifier_call_chain(&co_cache_error_chain,
+					     CO_CACHE_ERROR_TLB_PARITY,
+					     NULL);
+		if ((rv & ~NOTIFY_STOP_MASK) != NOTIFY_OK) {
+			unsigned int coreid = cvmx_get_core_num();
+
+			pr_err("Core%u: TLB parity error:\n", coreid);
+			return MIPS_MC_FATAL;
+		}
+
+		return MIPS_MC_DISCARD;
+	}
+	return MIPS_MC_NOT_HANDLED;
+}
+
 /**
  * Probe Octeon's caches
  *
@@ -315,8 +386,8 @@ static void __cpuinit probe_octeon(void)
 		dcache_size = c->dcache.sets * c->dcache.ways * c->dcache.linesz;
 		c->options |= MIPS_CPU_PREFETCH;
 
-		board_be_handler = octeon2_be_handler;
-		board_mcheck_handler = octeon2_mcheck_handler;
+		board_be_handler = octeon3_be_handler;
+		board_mcheck_handler = octeon3_mcheck_handler;
 		break;
 
 	default:
@@ -362,8 +433,13 @@ static void __cpuinit probe_octeon(void)
 
 static void  __cpuinit octeon_cache_error_setup(void)
 {
-	extern char except_vec2_octeon;
-	set_handler(0x100, &except_vec2_octeon, 0x80);
+	if (current_cpu_type() == CPU_CAVIUM_OCTEON3) {
+		extern char except_vec2_octeon3;
+		set_handler(0x100, &except_vec2_octeon3, 0x80);
+	} else {
+		extern char except_vec2_octeon;
+		set_handler(0x100, &except_vec2_octeon, 0x80);
+	}
 }
 
 /**
@@ -422,7 +498,10 @@ static void co_cache_error_call_notifiers(unsigned long val)
 			dcache_err = cache_err_dcache[coreid];
 			cache_err_dcache[coreid] = 0;
 		} else {
-			dcache_err = read_octeon_c0_dcacheerr();
+			if (current_cpu_type() == CPU_CAVIUM_OCTEON3)
+				dcache_err = read_octeon_c0_errctl();
+			else
+				dcache_err = read_octeon_c0_dcacheerr();
 		}
 
 		pr_err("Core%lu: Cache error exception:\n", coreid);
diff --git a/arch/mips/mm/cex-oct.S b/arch/mips/mm/cex-oct.S
index 9029092..847b101 100644
--- a/arch/mips/mm/cex-oct.S
+++ b/arch/mips/mm/cex-oct.S
@@ -51,6 +51,43 @@
 	.set	pop
 	END(except_vec2_octeon)
 
+  /* Handle cache error for OCTEON3. */
+	LEAF(except_vec2_octeon3)
+
+	.set	push
+	.set	mips64r2
+	.set	noreorder
+	.set	noat
+
+
+	/* due to an errata we need to read the COP0 CacheErr (Dcache)
+	 * before any cache/DRAM access	 */
+
+	rdhwr	k0, $0	      /* get core_id */
+	PTR_LA	k1, cache_err_dcache
+	sll	k0, k0, 3
+	PTR_ADDU k1, k0, k1    /* k1 = &cache_err_dcache[core_id] */
+
+	dmfc0	k0, CP0_ERRCTL
+	sd	k0, (k1)
+	andi	k0, 1		/* Write 1 to clear Dcache parity error */
+	dmtc0	k0, CP0_ERRCTL
+
+	/* check whether this is a nested exception */
+	mfc0	k1, CP0_STATUS
+	andi	k1, k1, ST0_EXL
+	beqz	k1, 2f
+	 nop
+	j	cache_parity_error_octeon_non_recoverable
+	 nop
+
+	/* exception is recoverable */
+2:	j	handle_cache_err
+	 nop
+
+	.set	pop
+	END(except_vec2_octeon3)
+
  /* We need to jump to handle_cache_err so that the previous handler
   * can fit within 0x80 bytes. We also move from 0xFFFFFFFFAXXXXXXX
   * space (uncached) to the 0xFFFFFFFF8XXXXXXX space (cached).	*/
diff --git a/drivers/edac/octeon_edac-pc.c b/drivers/edac/octeon_edac-pc.c
index 4f0ac09..416b4a9 100644
--- a/drivers/edac/octeon_edac-pc.c
+++ b/drivers/edac/octeon_edac-pc.c
@@ -48,7 +48,10 @@ static int  co_cache_error_event(struct notifier_block *this,
 		cache_err_dcache[core] = 0;
 		break;
 	case CO_CACHE_ERROR_RECOVERABLE:
-		dcache_err = read_octeon_c0_dcacheerr();
+		if (current_cpu_type() == CPU_CAVIUM_OCTEON3)
+			dcache_err = read_octeon_c0_errctl();
+		else
+			dcache_err = read_octeon_c0_dcacheerr();
 		break;
 	case CO_CACHE_ERROR_WB_PARITY:
 		edac_device_printk(p->ed, KERN_ERR,
@@ -86,7 +89,9 @@ static int  co_cache_error_event(struct notifier_block *this,
 			edac_device_handle_ce(p->ed, cpu, 0, "dcache");
 
 		/* Clear the error indication */
-		if (current_cpu_type() == CPU_CAVIUM_OCTEON2)
+		if (current_cpu_type() == CPU_CAVIUM_OCTEON3)
+			write_octeon_c0_errctl(1);
+		else if (current_cpu_type() == CPU_CAVIUM_OCTEON2)
 			write_octeon_c0_dcacheerr(1);
 		else
 			write_octeon_c0_dcacheerr(0);
-- 
1.7.0.4

