From f1322faf09a2d32f3bfb040b66293cac2f4c6478 Mon Sep 17 00:00:00 2001
From: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Date: Thu, 13 Jun 2013 19:31:05 -0700
Subject: [PATCH 120/382] MIPS: Octeon: adopt hotplug code to new struct cvmx_coremask

Based on SDK octeon3_3.10.

This is just a quick fix for compile errors, not really a solution
for supporting beyond 32 cores, yet.
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/cavium-octeon/smp.c |   31 ++++++++++++++++++++-----------
 1 files changed, 20 insertions(+), 11 deletions(-)

diff --git a/arch/mips/cavium-octeon/smp.c b/arch/mips/cavium-octeon/smp.c
index 8c35621..9ae005c 100644
--- a/arch/mips/cavium-octeon/smp.c
+++ b/arch/mips/cavium-octeon/smp.c
@@ -374,7 +374,7 @@ static int octeon_cpu_disable(void)
 static void octeon_cpu_die(unsigned int cpu)
 {
 	int coreid = cpu_logical_map(cpu);
-	uint32_t mask, new_mask;
+	uint32_t new_mask ;	/* FIXME: extend beyond 32 cores */
 	const struct cvmx_bootmem_named_block_desc *block_desc;
 
 	while (per_cpu(cpu_state, cpu) != CPU_DEAD)
@@ -384,9 +384,9 @@ static void octeon_cpu_die(unsigned int cpu)
 	 * This is a bit complicated strategics of getting/settig available
 	 * cores mask, copied from bootloader
 	 */
-
-	mask = 1 << coreid;
-	octeon_hotplug_global_ptr->avail_coremask |= mask;
+	cvmx_coremask_set_core( 
+		&octeon_hotplug_global_ptr->avail_coremask,
+		coreid );
 
 	/* LINUX_APP_BOOT_BLOCK is initialized in bootoct binary */
 	block_desc = cvmx_bootmem_find_named_block(LINUX_APP_BOOT_BLOCK_NAME);
@@ -396,16 +396,19 @@ static void octeon_cpu_die(unsigned int cpu)
 
 		labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
 
-		labi->avail_coremask |= mask;
+		labi->avail_coremask |= (1 << coreid);
 		new_mask = labi->avail_coremask;
 	} else {		       /* alternative, already initialized */
-		new_mask = octeon_hotplug_global_ptr->avail_coremask;
+		new_mask  = cvmx_coremask_get32( 
+				&octeon_hotplug_global_ptr->avail_coremask);
 	}
 
 	mb();
 
+	/* FIXME: will only show up to 32 cores */
 	pr_info("Reset core %d. Available Coremask = 0x%x\n",
 		coreid, new_mask);
+	/* FIXME: handle cores over 31 */
 	cvmx_write_csr(CVMX_CIU_NMI, 1 << coreid);
 }
 
@@ -439,21 +442,27 @@ static int octeon_update_boot_vector(unsigned int cpu)
 		labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
 
 		avail_coremask = labi->avail_coremask;
+		if (!(avail_coremask & (1<<coreid)))
+			return -1;
 		labi->avail_coremask &= ~(1 << coreid);
 	} else {		       /* alternative, already initialized */
-		avail_coremask = octeon_hotplug_global_ptr->avail_coremask;
-		if (!(avail_coremask & (1<<coreid)))
+		if ( ! cvmx_coremask_is_core_set(
+			&octeon_hotplug_global_ptr->avail_coremask, coreid ))
 			return -1;
+		/* This core is no longer available */
+		cvmx_coremask_clear_core(
+			& octeon_hotplug_global_ptr->avail_coremask,
+			coreid );
 	}
-	/* This core is no longer available */
-	octeon_hotplug_global_ptr->avail_coremask &= ~(1<<coreid);
 
+	/* FIXME: extend beyond 32 cores */
 	boot_vect[coreid].app_start_func_addr = octeon_hotplug_entry_addr;
 	boot_vect[coreid].code_addr = octeon_bootloader_entry_addr;
 
 	mb();
 
-	cvmx_write_csr(CVMX_CIU_NMI, (1 << coreid) & avail_coremask);
+	/* FIXME: extend beyond 32 cores */
+	cvmx_write_csr(CVMX_CIU_NMI, (1 << coreid));
 
 	return 0;
 }
-- 
1.7.0.4

