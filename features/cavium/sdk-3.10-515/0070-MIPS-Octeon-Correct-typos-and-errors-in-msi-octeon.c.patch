From c50c0b4b305798eb93f9b65fd7fd12e64f66c17d Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 6 Apr 2012 15:38:05 -0700
Subject: [PATCH 070/382] MIPS: Octeon: Correct typos and errors in msi-octeon.c

Based on SDK octeon3_3.10.

s/iqr/irq/

Add missing scatter mapping to many functions.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/pci/msi-octeon.c |   32 +++++++++++++++++++-------------
 1 files changed, 19 insertions(+), 13 deletions(-)

diff --git a/arch/mips/pci/msi-octeon.c b/arch/mips/pci/msi-octeon.c
index da7853d..93e61e9 100644
--- a/arch/mips/pci/msi-octeon.c
+++ b/arch/mips/pci/msi-octeon.c
@@ -145,6 +145,7 @@ msi_irq_allocated:
 
 	/* MSI interrupts start at logical IRQ OCTEON_IRQ_MSI_BIT0 */
 	irq += index*64;
+	msg.data = irq;
 	irq += OCTEON_IRQ_MSI_BIT0;
 
 	switch (octeon_dma_bar_type) {
@@ -153,6 +154,7 @@ msi_irq_allocated:
 		msg.address_lo =
 			((128ul << 20) + CVMX_PCI_MSI_RCV) & 0xffffffff;
 		msg.address_hi = ((128ul << 20) + CVMX_PCI_MSI_RCV) >> 32;
+		break;
 	case OCTEON_DMA_BAR_TYPE_BIG:
 		/* When using big bar, Bar 0 is based at 0 */
 		msg.address_lo = (0 + CVMX_PCI_MSI_RCV) & 0xffffffff;
@@ -172,7 +174,6 @@ msi_irq_allocated:
 	default:
 		panic("arch_setup_msi_irq: Invalid octeon_dma_bar_type");
 	}
-	msg.data = irq - OCTEON_IRQ_MSI_BIT0;
 
 	/* Update the number of IRQs the device has available to it */
 	control &= ~PCI_MSI_FLAGS_QSIZE;
@@ -267,14 +268,14 @@ static u64 msi_rcv_reg[4];
 static u64 mis_ena_reg[4];
 
 static int (*octeon_irq_msi_to_irq)(int);
-static int (*octeon_irq_iqr_to_msi)(int);
+static int (*octeon_irq_irq_to_msi)(int);
 
 static int octeon_irq_msi_to_irq_linear(int msi)
 {
 	return msi + OCTEON_IRQ_MSI_BIT0;
 }
 
-static int octeon_irq_iqr_to_msi_linear(int irq)
+static int octeon_irq_irq_to_msi_linear(int irq)
 {
 	return irq - OCTEON_IRQ_MSI_BIT0;
 }
@@ -284,7 +285,7 @@ static int octeon_irq_msi_to_irq_scatter(int msi)
 	return (((msi >> 6) & 0x3) | ((msi << 2) & 0xfc)) + OCTEON_IRQ_MSI_BIT0;
 }
 
-static int octeon_irq_iqr_to_msi_scatter(int irq)
+static int octeon_irq_irq_to_msi_scatter(int irq)
 {
 	int t = irq - OCTEON_IRQ_MSI_BIT0;
 	return ((t << 6) & 0xc0) | ((t >> 2) & 0x3f);
@@ -300,7 +301,7 @@ static int octeon_irq_msi_set_affinity_pcie(struct irq_data *data,
 					    const struct cpumask *dest,
 					    bool force)
 {
-	int msi = octeon_irq_iqr_to_msi(data->irq);
+	int msi = octeon_irq_irq_to_msi(data->irq);
 	int index = msi >> 6;
 	int bit;
 	int r;
@@ -327,7 +328,7 @@ static int octeon_irq_msi_set_affinity_pci(struct irq_data *data,
 					   const struct cpumask *dest,
 					   bool force)
 {
-	int msi = octeon_irq_iqr_to_msi(data->irq);
+	int msi = octeon_irq_irq_to_msi(data->irq);
 	int index = msi >> 4;
 	int bit;
 	int r;
@@ -354,7 +355,7 @@ static void octeon_irq_msi_enable_pcie(struct irq_data *data)
 {
 	u64 en;
 	unsigned long flags;
-	int msi_number = data->irq - OCTEON_IRQ_MSI_BIT0;
+	int msi_number = octeon_irq_irq_to_msi(data->irq);
 	int irq_index = msi_number >> 6;
 	int irq_bit = msi_number & 0x3f;
 
@@ -370,7 +371,7 @@ static void octeon_irq_msi_disable_pcie(struct irq_data *data)
 {
 	u64 en;
 	unsigned long flags;
-	int msi_number = data->irq - OCTEON_IRQ_MSI_BIT0;
+	int msi_number = octeon_irq_irq_to_msi(data->irq);
 	int irq_index = msi_number >> 6;
 	int irq_bit = msi_number & 0x3f;
 
@@ -431,7 +432,8 @@ static irqreturn_t __octeon_msi_do_interrupt(int index, u64 msi_bits)
 		/* Acknowledge it first. */
 		cvmx_write_csr(msi_rcv_reg[index], 1ull << bit);
 
-		irq = bit + OCTEON_IRQ_MSI_BIT0 + 64 * index;
+		irq = octeon_irq_msi_to_irq(bit + 64 * index);
+
 		do_IRQ(irq);
 		return IRQ_HANDLED;
 	}
@@ -453,6 +455,7 @@ OCTEON_MSI_INT_HANDLER_X(1);
 OCTEON_MSI_INT_HANDLER_X(2);
 OCTEON_MSI_INT_HANDLER_X(3);
 
+#if 0
 static void octeon_msi_ciu2_enable_on_cpu(unsigned int irq, int cpu)
 {
 	int core;
@@ -572,7 +575,7 @@ static struct notifier_block octeon_msi_cpu_notifier = {
 	.notifier_call = octeon_msi_cpu_callback,
 };
 
-int __init octeon_msi_68XX_init(void)
+static int __init octeon_msi_68XX_init(void)
 {
 	int i;
 	int cpu;
@@ -607,6 +610,7 @@ int __init octeon_msi_68XX_init(void)
 	msi_irq_size = 256;
 	return 0;
 }
+#endif /* 0 */
 
 /*
  * Initializes the MSI interrupt handling code
@@ -617,8 +621,10 @@ int __init octeon_msi_initialize(void)
 	struct irq_chip *msi;
 	u64 msi_map_reg;
 
+#if 0
 	if (OCTEON_IS_MODEL(OCTEON_CN68XX) && !OCTEON_IS_MODEL(OCTEON_CN68XX_PASS1_X))
 		return octeon_msi_68XX_init();
+#endif
 
 	if (octeon_dma_bar_type == OCTEON_DMA_BAR_TYPE_PCIE2) {
 		msi_rcv_reg[0] = CVMX_PEXP_SLI_MSI_RCV0;
@@ -631,7 +637,7 @@ int __init octeon_msi_initialize(void)
 		mis_ena_reg[3] = CVMX_PEXP_SLI_MSI_ENB3;
 		msi = &octeon_irq_chip_msi_pcie;
 		octeon_irq_msi_to_irq = octeon_irq_msi_to_irq_scatter;
-		octeon_irq_iqr_to_msi = octeon_irq_iqr_to_msi_scatter;
+		octeon_irq_irq_to_msi = octeon_irq_irq_to_msi_scatter;
 		msi_map_reg = CVMX_PEXP_SLI_MSI_WR_MAP;
 	} else if (octeon_dma_bar_type == OCTEON_DMA_BAR_TYPE_PCIE) {
 		msi_rcv_reg[0] = CVMX_PEXP_NPEI_MSI_RCV0;
@@ -644,7 +650,7 @@ int __init octeon_msi_initialize(void)
 		mis_ena_reg[3] = CVMX_PEXP_NPEI_MSI_ENB3;
 		msi = &octeon_irq_chip_msi_pcie;
 		octeon_irq_msi_to_irq = octeon_irq_msi_to_irq_scatter;
-		octeon_irq_iqr_to_msi = octeon_irq_iqr_to_msi_scatter;
+		octeon_irq_irq_to_msi = octeon_irq_irq_to_msi_scatter;
 		msi_map_reg = CVMX_PEXP_NPEI_MSI_WR_MAP;
 	} else {
 		msi_rcv_reg[0] = CVMX_NPI_NPI_MSI_RCV;
@@ -658,7 +664,7 @@ int __init octeon_msi_initialize(void)
 		mis_ena_reg[3] = INVALID_GENERATE_ADE;
 		msi = &octeon_irq_chip_msi_pci;
 		octeon_irq_msi_to_irq = octeon_irq_msi_to_irq_linear;
-		octeon_irq_iqr_to_msi = octeon_irq_iqr_to_msi_linear;
+		octeon_irq_irq_to_msi = octeon_irq_irq_to_msi_linear;
 		msi_map_reg = 0;
 	}
 
-- 
1.7.0.4

