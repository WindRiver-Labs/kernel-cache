From 4242e212be77e4850ee2813e6bd18cbccd82d225 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Wed, 22 Jan 2014 18:25:56 -0800
Subject: [PATCH 382/382] usb: xhci-octeon: Update power control.

Based on SDK octeon3_3.10.

Route power control signals to the appropiate GPIO pins.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/usb/host/xhci-octeon.c |   64 ++++++++++++++++++++++++++++++++++++++-
 1 files changed, 62 insertions(+), 2 deletions(-)

diff --git a/drivers/usb/host/xhci-octeon.c b/drivers/usb/host/xhci-octeon.c
index e65f60c..f8f4a4f 100644
--- a/drivers/usb/host/xhci-octeon.c
+++ b/drivers/usb/host/xhci-octeon.c
@@ -19,6 +19,7 @@
 #include <linux/of.h>
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-usbdrdx-defs.h>
+#include <asm/octeon/cvmx-gpio-defs.h>
 
 #define OCTEON_USB3_MIN_H_CLK_RATE	(150000000)
 #define OCTEON_USB3_MAX_H_CLK_RATE	(300000000)
@@ -31,6 +32,55 @@ static int octeon3_usb2_clock_start_cnt;
 static uint8_t clk_div[OCTEON_USB3_NUM_CLK_DEV_SEL] = {1, 2, 4, 6, 8,
 							16, 24, 32};
 
+static int octeon3_usb_config_power(struct platform_device *pdev, int index)
+{
+	union cvmx_usbdrdx_uctl_host_cfg uctl_host_cfg;
+	union cvmx_gpio_bit_cfgx gpio_bit;
+	uint32_t gpio_pwr[3];
+	int power_active_low;
+	int gpio;
+	int len;
+
+	if (of_find_property(pdev->dev.of_node, "power", &len) != NULL) {
+		if (len == 12) {
+			of_property_read_u32_array(pdev->dev.of_node, "power", gpio_pwr, 3);
+			power_active_low = gpio_pwr[2] & 0x01;
+			gpio = gpio_pwr[1];
+		} else if (len == 8) {
+			of_property_read_u32_array(pdev->dev.of_node, "power", gpio_pwr, 2);
+			power_active_low = 0;
+			gpio = gpio_pwr[1];
+		} else {
+			pr_err("Invalid power GPIO device tree entry\n");
+			return -1;
+		}
+		if (gpio <= 15) {
+			gpio_bit.u64 = cvmx_read_csr(CVMX_GPIO_BIT_CFGX(gpio));
+			gpio_bit.s.tx_oe = 1;
+			gpio_bit.cn70xx.output_sel = (index == 0 ? 0x14 : 0x19);
+			cvmx_write_csr(CVMX_GPIO_BIT_CFGX(gpio), gpio_bit.u64);
+		} else {
+			gpio_bit.u64 = cvmx_read_csr(CVMX_GPIO_XBIT_CFGX(gpio));
+			gpio_bit.s.tx_oe = 1;
+			gpio_bit.cn70xx.output_sel = (index == 0 ? 0x14 : 0x19);
+			cvmx_write_csr(CVMX_GPIO_XBIT_CFGX(gpio), gpio_bit.u64);
+		}
+		/* Enable XHCI power control and set if active high or low */
+		uctl_host_cfg.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_HOST_CFG(index));
+		uctl_host_cfg.s.ppc_en = 1;
+		uctl_host_cfg.s.ppc_active_high_en = !power_active_low;
+		cvmx_write_csr(CVMX_USBDRDX_UCTL_HOST_CFG(index), uctl_host_cfg.u64);
+	} else {
+		pr_err("No power GPIO device tree entry\n");
+		/* Disable XHCI power control and set if active high*/
+		uctl_host_cfg.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_HOST_CFG(index));
+		uctl_host_cfg.s.ppc_en = 0;
+		uctl_host_cfg.s.ppc_active_high_en = 0;
+		cvmx_write_csr(CVMX_USBDRDX_UCTL_HOST_CFG(index), uctl_host_cfg.u64);
+	}
+	return 0;
+}
+
 static void octeon3_usb_clocks_start(struct platform_device *pdev, int index)
 {
 	u32 clock_rate = 100000000;
@@ -183,13 +233,23 @@ static void octeon3_usb_clocks_start(struct platform_device *pdev, int index)
 	uctl_ctl.s.hs_power_en = 1;
 	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
 
-	/* Step 9 */
+	/* Step 9a */
 	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
 	uctl_ctl.s.uctl_rst = 0;
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
+
+	/* Configure power */
+	if (octeon3_usb_config_power(pdev, index)) {
+		pr_err("Error configuring power for USB%d\n", index);
+		goto exit;
+	}
+
+	/* Step 9b */
+	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
 	uctl_ctl.s.uahc_rst = 0;
 	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
 
-	/* Step 8*/
+	/* Step 9c*/
 	cvmx_wait(10);
 
 	/* Step 10*/
-- 
1.7.0.4

