From 8457bd69bdcc2140daa0ef30681a1a252f6b0a95 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Thu, 17 Jan 2013 15:11:43 -0800
Subject: [PATCH 142/382] MIPS: OCTEON: Add support for CONFIG_CAVIUM_GDB

Based on SDK octeon3_3.10.

The Cavium, Inc. Simple Executive debugger.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/Kconfig.debug                    |    9 ++++
 arch/mips/cavium-octeon/executive/Makefile |    1 +
 arch/mips/cavium-octeon/serial.c           |   64 +++++++++++++++++++++++++++-
 arch/mips/cavium-octeon/setup.c            |   16 ++-----
 arch/mips/include/asm/octeon/octeon.h      |    2 +
 5 files changed, 80 insertions(+), 12 deletions(-)

diff --git a/arch/mips/Kconfig.debug b/arch/mips/Kconfig.debug
index 5a43aa0..e8243bd 100644
--- a/arch/mips/Kconfig.debug
+++ b/arch/mips/Kconfig.debug
@@ -93,6 +93,15 @@ config SB1XXX_CORELIS
 	  Select compile flags that produce code that can be processed by the
 	  Corelis mksym utility and UDB Emulator.
 
+config CAVIUM_GDB
+	bool "Remote GDB debugging using the Cavium Inc. Multicore GDB"
+	depends on DEBUG_KERNEL && CPU_CAVIUM_OCTEON && !KGDB
+	select DEBUG_INFO
+	help
+	  If you say Y here, it will be possible to remotely debug the MIPS
+	  kernel using the Cavium Inc. GDB with extended SMP support.
+	  This is only useful for kernel hackers. If unsure, say N.
+
 config RUNTIME_DEBUG
 	bool "Enable run-time debugging"
 	depends on DEBUG_KERNEL
diff --git a/arch/mips/cavium-octeon/executive/Makefile b/arch/mips/cavium-octeon/executive/Makefile
index 8e0594d..a66edba 100644
--- a/arch/mips/cavium-octeon/executive/Makefile
+++ b/arch/mips/cavium-octeon/executive/Makefile
@@ -27,3 +27,4 @@ obj-y += cvmx-pcie.o
 obj-$(CONFIG_USB_OCTEON_HCD)		+= cvmx-usb.o
 obj-$(CONFIG_CAVIUM_OCTEON_NAND)	+= cvmx-nand.o
 obj-$(CONFIG_CAVIUM_OCTEON_ERROR_TREE)	+= cvmx-error-trees.o
+obj-$(CONFIG_CAVIUM_GDB)		+= cvmx-debug.o cvmx-core.o cvmx-debug-handler.o cvmx-debug-uart.o cvmx-debug-remote.o
diff --git a/arch/mips/cavium-octeon/serial.c b/arch/mips/cavium-octeon/serial.c
index f393f65..26e80df 100644
--- a/arch/mips/cavium-octeon/serial.c
+++ b/arch/mips/cavium-octeon/serial.c
@@ -19,7 +19,69 @@
 
 #include <asm/octeon/octeon.h>
 
-#define DEBUG_UART 1
+
+#ifdef CONFIG_CAVIUM_GDB
+
+static irqreturn_t interrupt_debug_char(int cpl, void *dev_id)
+{
+	unsigned long lsrval;
+	unsigned long tmp;
+
+	lsrval = cvmx_read_csr(CVMX_MIO_UARTX_LSR(OCTEON_DEBUG_UART));
+	if (lsrval & 1) {
+#ifdef CONFIG_KGDB
+		/*
+		 * The Cavium EJTAG bootmonitor stub is not compatible
+		 * with KGDB.  We should never get here.
+		 */
+#error Illegal to use both CONFIG_KGDB and CONFIG_CAVIUM_GDB
+#endif
+		/*
+		 * Pulse MCD0 signal on Ctrl-C to stop all the
+		 * cores. Also set the MCD0 to be not masked by this
+		 * core so we know the signal is received by
+		 * someone.
+		 */
+		octeon_write_lcd("brk");
+		asm volatile ("dmfc0 %0, $22\n\t"
+			      "ori   %0, %0, 0x10\n\t"
+			      "dmtc0 %0, $22" : "=r" (tmp));
+		octeon_write_lcd("");
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+
+/* Enable uart1 interrupts for debugger Control-C processing */
+
+static int octeon_setup_debug_uart(void)
+{
+	unsigned int hwirq;
+	int irq;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		hwirq = (3 << 6) + 36 + OCTEON_DEBUG_UART;
+	else
+		hwirq = 34 + OCTEON_DEBUG_UART;
+
+	irq = irq_create_mapping(NULL, hwirq);
+	if (!irq)
+		return -EINVAL;
+
+
+	if (request_irq(irq, interrupt_debug_char,
+			0, "cvmx-debug", interrupt_debug_char)) {
+		panic("request_irq(%d) failed.", irq);
+	}
+	cvmx_write_csr(CVMX_MIO_UARTX_IER(OCTEON_DEBUG_UART),
+		       cvmx_read_csr(CVMX_MIO_UARTX_IER(OCTEON_DEBUG_UART)) | 1);
+	return 0;
+}
+/* Install this as early as possible to be able to debug the boot
+   sequence.  */
+core_initcall(octeon_setup_debug_uart);
+#endif	/* CONFIG_CAVIUM_GDB */
+
 
 unsigned int octeon_serial_in(struct uart_port *up, int offset)
 {
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index e6134db..05e2bdb 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -44,6 +44,7 @@
 #include <asm/octeon/cvmx-mio-defs.h>
 
 #include <asm/octeon/cvmx-qlm.h>
+#include <asm/octeon/cvmx-debug.h>
 
 extern struct plat_smp_ops octeon_smp_ops;
 
@@ -777,17 +778,6 @@ void __init prom_init(void)
 	octeon_write_lcd("Linux");
 #endif
 
-#ifdef CONFIG_CAVIUM_GDB
-	/*
-	 * When debugging the linux kernel, force the cores to enter
-	 * the debug exception handler to break in.
-	 */
-	if (octeon_get_boot_debug_flag()) {
-		cvmx_write_csr(CVMX_CIU_DINT, 1 << cvmx_get_core_num());
-		cvmx_read_csr(CVMX_CIU_DINT);
-	}
-#endif
-
 	octeon_setup_delays();
 
 	/*
@@ -922,6 +912,10 @@ append_arg:
 	if (labi->labi_signature == LABI_SIGNATURE)
 		octeon_bootloader_entry_addr = labi->InitTLBStart_addr;
 
+#ifdef CONFIG_CAVIUM_GDB
+	cvmx_debug_init ();
+#endif
+
 #ifdef	SDK_VERSION
 	pr_info("Cavium Inc. SDK-" SDK_VERSION "\n");
 #endif
diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index 787e3e6..8ae4ad0 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -400,6 +400,8 @@ int octeon_request_ipi_handler(octeon_message_fn_t fn);
 void octeon_send_ipi_single(int cpu, unsigned int action);
 void octeon_release_ipi_handler(int action);
 
+#define OCTEON_DEBUG_UART 1
+
 #if IS_ENABLED(CONFIG_CAVIUM_OCTEON_ERROR_TREE)
 int octeon_error_tree_enable(enum cvmx_error_groups group, int unit);
 int octeon_error_tree_disable(enum cvmx_error_groups group, int unit);
-- 
1.7.0.4

