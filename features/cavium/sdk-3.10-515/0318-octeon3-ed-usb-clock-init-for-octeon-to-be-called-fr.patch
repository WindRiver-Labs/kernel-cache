From 412679fe08f60466c1669571c61db94f5724388e Mon Sep 17 00:00:00 2001
From: Vinita Gupta <vgupta@caviumnetworks.com>
Date: Fri, 25 Oct 2013 11:33:56 -0700
Subject: [PATCH 318/382] octeon3: ed usb clock init for octeon to be called from dwc3 driver

Based on SDK octeon3_3.10.

ed usb clock init for octeon to be called from dwc3 driver.

Signed-off-by: Vinita Gupta <vgupta@caviumnetworks.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/cavium-octeon/octeon-platform.c |    3 +-
 drivers/usb/dwc3/core.c                   |   52 ++++++--
 drivers/usb/host/xhci-octeon.c            |  202 ++++++++++++++++++++++-------
 3 files changed, 199 insertions(+), 58 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-platform.c b/arch/mips/cavium-octeon/octeon-platform.c
index 1fd6ad6..e973d90 100644
--- a/arch/mips/cavium-octeon/octeon-platform.c
+++ b/arch/mips/cavium-octeon/octeon-platform.c
@@ -1,4 +1,4 @@
-/*
+ /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
@@ -73,6 +73,7 @@ static struct of_device_id __initdata octeon_ids[] = {
 	{ .compatible = "cavium,octeon-3860-bootbus", },
 	{ .compatible = "cavium,mdio-mux", },
 	{ .compatible = "gpio-leds", },
+	{ .compatible = "cavium,octeon-7130-usb-uctl", },
 	{},
 };
 
diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index 0e9c373..563dd97 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -64,6 +64,8 @@ static char *maximum_speed = "super";
 module_param(maximum_speed, charp, 0);
 MODULE_PARM_DESC(maximum_speed, "Maximum supported speed.");
 extern void octeon3_usb_phy_reset(int index);
+extern int xhci_octeon_start(struct paltform_device *pdev);
+extern int xhci_octeon_stop(struct paltform_device *pdev);
 static u64 xhci_octeon_dma_mask = DMA_BIT_MASK(64);
 
 /* -------------------------------------------------------------------------- */
@@ -103,9 +105,12 @@ static void dwc3_core_soft_reset(struct dwc3 *dwc)
 	dwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);
 
 	index = (((uint64_t)(dwc->regs) & 0x10000000000ull) ? 1:0);
+#ifdef CONFIG_USB_XHCI_HCD_OCTEON
 	octeon3_usb_phy_reset(index);
-	//usb_phy_init(dwc->usb2_phy);
-	//usb_phy_init(dwc->usb3_phy);
+#else
+	usb_phy_init(dwc->usb2_phy);
+	usb_phy_init(dwc->usb3_phy);
+#endif
 	mdelay(100);
 
 	/* Clear USB3 PHY reset */
@@ -364,8 +369,10 @@ err0:
 
 static void dwc3_core_exit(struct dwc3 *dwc)
 {
-	//usb_phy_shutdown(dwc->usb2_phy);
-	//usb_phy_shutdown(dwc->usb3_phy);
+#ifndef CONFIG_USB_XHCI_HCD_OCTEON
+	usb_phy_shutdown(dwc->usb2_phy);
+	usb_phy_shutdown(dwc->usb3_phy);
+#endif
 }
 
 #define DWC3_ALIGN_MASK		(16 - 1)
@@ -384,6 +391,12 @@ static int dwc3_probe(struct platform_device *pdev)
 
 	u8			mode;
 
+#ifdef CONFIG_USB_XHCI_HCD_OCTEON
+	ret = xhci_octeon_start(pdev);
+	if (ret)
+		return ret;
+#endif
+
 	mem = devm_kzalloc(dev, sizeof(*dwc) + DWC3_ALIGN_MASK, GFP_KERNEL);
 	if (!mem) {
 		dev_err(dev, "not enough memory\n");
@@ -451,8 +464,10 @@ static int dwc3_probe(struct platform_device *pdev)
 			dwc->usb2_phy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);
 			dwc->usb3_phy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB3);
 	}
-	//usb_phy_set_suspend(dwc->usb2_phy, 0);
-	//usb_phy_set_suspend(dwc->usb3_phy, 0);
+#ifndef CONFIG_USB_XHCI_HCD_OCTEON
+	usb_phy_set_suspend(dwc->usb2_phy, 0);
+	usb_phy_set_suspend(dwc->usb3_phy, 0);
+#endif
 
 	spin_lock_init(&dwc->lock);
 	platform_set_drvdata(pdev, dwc);
@@ -461,7 +476,11 @@ static int dwc3_probe(struct platform_device *pdev)
 	dwc->regs_size	= resource_size(res);
 	dwc->dev	= dev;
 
+#ifdef CONFIG_USB_XHCI_HCD_OCTEON
 	dev->dma_mask	= &xhci_octeon_dma_mask;
+#else
+	dev->dma_mask	= dev->parent->dma_mask;
+#endif
 	dev->dma_parms	= dev->parent->dma_parms;
 	dma_set_coherent_mask(dev, dev->parent->coherent_dma_mask);
 
@@ -590,8 +609,10 @@ static int dwc3_remove(struct platform_device *pdev)
 {
 	struct dwc3	*dwc = platform_get_drvdata(pdev);
 
-	//usb_phy_set_suspend(dwc->usb2_phy, 1);
-	//usb_phy_set_suspend(dwc->usb3_phy, 1);
+#ifndef CONFIG_USB_XHCI_HCD_OCTEON
+	usb_phy_set_suspend(dwc->usb2_phy, 1);
+	usb_phy_set_suspend(dwc->usb3_phy, 1);
+#endif
 
 	pm_runtime_put(&pdev->dev);
 	pm_runtime_disable(&pdev->dev);
@@ -618,6 +639,9 @@ static int dwc3_remove(struct platform_device *pdev)
 	dwc3_free_event_buffers(dwc);
 	dwc3_core_exit(dwc);
 
+#ifdef CONFIG_USB_XHCI_HCD_OCTEON
+	xhci_octeon_stop(pdev);
+#endif
 	return 0;
 }
 
@@ -687,8 +711,10 @@ static int dwc3_suspend(struct device *dev)
 	dwc->gctl = dwc3_readl(dwc->regs, DWC3_GCTL);
 	spin_unlock_irqrestore(&dwc->lock, flags);
 
-	//usb_phy_shutdown(dwc->usb3_phy);
-	//usb_phy_shutdown(dwc->usb2_phy);
+#ifndef CONFIG_USB_XHCI_HCD_OCTEON
+	usb_phy_shutdown(dwc->usb3_phy);
+	usb_phy_shutdown(dwc->usb2_phy);
+#endif
 
 	return 0;
 }
@@ -698,8 +724,10 @@ static int dwc3_resume(struct device *dev)
 	struct dwc3	*dwc = dev_get_drvdata(dev);
 	unsigned long	flags;
 
-	//usb_phy_init(dwc->usb3_phy);
-	//usb_phy_init(dwc->usb2_phy);
+#ifndef CONFIG_USB_XHCI_HCD_OCTEON
+	usb_phy_init(dwc->usb3_phy);
+	usb_phy_init(dwc->usb2_phy);
+#endif
 	msleep(100);
 
 	spin_lock_irqsave(&dwc->lock, flags);
diff --git a/drivers/usb/host/xhci-octeon.c b/drivers/usb/host/xhci-octeon.c
index 4b592eb..9180ffe 100644
--- a/drivers/usb/host/xhci-octeon.c
+++ b/drivers/usb/host/xhci-octeon.c
@@ -10,7 +10,6 @@
  *
  */
 
-
 #include <linux/platform_device.h>
 #include <linux/device.h>
 #include <linux/module.h>
@@ -18,58 +17,95 @@
 #include <linux/mutex.h>
 #include <linux/delay.h>
 #include <linux/of.h>
-
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-usbdrdx-defs.h>
 
-/* Common clock init code.  */
-void octeon3_usb_clocks_start(int node);
-void octeon3_usb_clocks_stop(int node);
-void octeon3_usb_set_endian_mode(int node);
-
-static int __init xhci_octeon_init(void)
-{
-	octeon3_usb_clocks_start(0);
-	octeon3_usb_clocks_start(1);
-	octeon3_usb_set_endian_mode(0);
-	octeon3_usb_set_endian_mode(1);
-	return 0;
-}
-
-static void __exit xhci_octeon_exit(void)
-{
-	octeon3_usb_clocks_stop(0);
-	octeon3_usb_clocks_stop(1);
-}
-
-arch_initcall(xhci_octeon_init);
-module_exit(xhci_octeon_exit);
-
+#define OCTEON_USB3_MIN_H_CLK_RATE	(150000000)
+#define OCTEON_USB3_MAX_H_CLK_RATE	(300000000)
+#define OCTEON_USB3_NUM_CLK_DEV_SEL	(8)
 
 static DEFINE_MUTEX(octeon3_usb1_clocks_mutex);
 static DEFINE_MUTEX(octeon3_usb2_clocks_mutex);
 static int octeon3_usb1_clock_start_cnt;
 static int octeon3_usb2_clock_start_cnt;
+static uint8_t clk_div[OCTEON_USB3_NUM_CLK_DEV_SEL] = {1, 2, 4, 6, 8,
+							16, 24, 32};
 
-void octeon3_usb_clocks_start(int index)
+static void octeon3_usb_clocks_start(struct platform_device *pdev, int index)
 {
-	u64 div;
+	u32 clock_rate = 100000000;
 	union cvmx_usbdrdx_uctl_ctl uctl_ctl;
-	int ref_clk_sel = 2; //to_do, get from device tree
+	int ref_clk_sel = 2;
+	u64 div;
+	int mpll_mul;
+	int i;
+	uint64_t h_clk_rate;
 
 	if (index == 0) {
 		mutex_lock(&octeon3_usb1_clocks_mutex);
 		octeon3_usb1_clock_start_cnt++;
 		if (octeon3_usb1_clock_start_cnt != 1)
 			goto exit;
-	}
-	else {
+	} else {
 		mutex_lock(&octeon3_usb2_clocks_mutex);
 		octeon3_usb2_clock_start_cnt++;
 		if (octeon3_usb2_clock_start_cnt != 1)
 			goto exit;
 	}
-	printk("Initializing USB clocks !!!!!!\n");
+	if (pdev->dev.of_node) {
+		const char *ss_clock_type;
+		const char *hs_clock_type;
+
+		i = of_property_read_u32(pdev->dev.of_node,
+					 "refclk-frequency", &clock_rate);
+		if (i) {
+			pr_err("No UCTL \"refclk-frequency\"\n");
+			goto exit;
+		}
+		i = of_property_read_string(pdev->dev.of_node,
+					    "refclk-type-ss", &ss_clock_type);
+		if (i) {
+			pr_err("No UCTL \"refclk-type-ss\"\n");
+			goto exit;
+		}
+		i = of_property_read_string(pdev->dev.of_node,
+					    "refclk-type-hs", &hs_clock_type);
+		if (i) {
+			pr_err("No UCTL \"refclk-type-hs\"\n");
+			goto exit;
+		}
+		if (strcmp("dlmc_ref_clk0", ss_clock_type) == 0) {
+			if (strcmp(hs_clock_type, "dlmc_ref_clk0") == 0)
+				ref_clk_sel = 0;
+			else if (strcmp(hs_clock_type, "pll_ref_clk") == 0)
+				ref_clk_sel = 2;
+			else
+				pr_err("Invalid HS clock type %s, using  pll_ref_clk instead\n",
+				       hs_clock_type);
+		} else if (strcmp(ss_clock_type, "dlmc_ref_clk1") == 0) {
+			if (strcmp(hs_clock_type, "dlmc_ref_clk1") == 0)
+				ref_clk_sel = 1;
+			else if (strcmp(hs_clock_type, "pll_ref_clk") == 0)
+				ref_clk_sel = 3;
+			else {
+				pr_err("Invalid HS clock type %s, using  pll_ref_clk instead\n",
+				       hs_clock_type);
+				ref_clk_sel = 3;
+			}
+		} else
+			pr_err("Invalid SS clock type %s, using  dlmc_ref_clk0 instead\n",
+			       ss_clock_type);
+
+		if ((ref_clk_sel == 0 || ref_clk_sel == 1) &&
+				  (clock_rate != 100000000))
+			pr_err("Invalid UCTL clock rate of %u, using 100000000 instead\n",
+			       clock_rate);
+
+	} else {
+		pr_err("No USB UCTL device node\n");
+		goto exit;
+	}
+
 	/*
 	* Step 1: Wait for voltages stable.  That surely happened
 	* before starting the kernel.
@@ -87,22 +123,27 @@ void octeon3_usb_clocks_start(int index)
 	uctl_ctl.s.uphy_rst = 1;
 	uctl_ctl.s.uahc_rst = 1;
 	uctl_ctl.s.uctl_rst = 1;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
 
 	/* Step 5a: Reset the clock dividers */
 	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
 	uctl_ctl.s.h_clkdiv_rst = 1;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
 
 	/* 5b */
 	/* Step 5b: Select controller clock frequency */
-	div = 2; //vinita_to_to uncomment later
+	for (div = 0; div < OCTEON_USB3_NUM_CLK_DEV_SEL; div++) {
+		h_clk_rate = octeon_get_io_clock_rate() / clk_div[div];
+		if (h_clk_rate <= OCTEON_USB3_MAX_H_CLK_RATE &&
+				 h_clk_rate >= OCTEON_USB3_MIN_H_CLK_RATE)
+			break;
+	}
 	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
 	uctl_ctl.s.h_clkdiv_sel = div;
 	uctl_ctl.s.h_clk_en = 1;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
 	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
-	if(div != uctl_ctl.s.h_clkdiv_sel || !uctl_ctl.s.h_clk_en) {
+	if ((div != uctl_ctl.s.h_clkdiv_sel) || (!uctl_ctl.s.h_clk_en)) {
 		printk("ERROR: usb controller clock init\n");
 			goto exit;
 	}
@@ -110,7 +151,7 @@ void octeon3_usb_clocks_start(int index)
 	/* Step 5c: Deassert the controller clock divider reset */
 	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
 	uctl_ctl.s.h_clkdiv_rst = 0;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
 
 	/* Step ??*/
 	cvmx_wait(2000);
@@ -122,16 +163,31 @@ void octeon3_usb_clocks_start(int index)
 	uctl_ctl.s.ref_clk_sel = ref_clk_sel;
 	uctl_ctl.s.ref_clk_fsel = 0x07;
 	uctl_ctl.s.ref_clk_div2 = 0;
-	uctl_ctl.s.mpll_multiplier = 0x19;
+	switch (clock_rate) {
+	default:
+		pr_err("Invalid UCTL ref_clk %u, using 100000000 instead\n",
+		       clock_rate);
+		/* Fall through */
+	case 100000000:
+		mpll_mul = 0x19;
+		break;
+	case 50000000:
+		mpll_mul = 0x32;
+		break;
+	case 125000000:
+		mpll_mul = 0x28;
+		break;
+	}
+	uctl_ctl.s.mpll_multiplier = mpll_mul;
 	uctl_ctl.s.ss_power_en = 1;
 	uctl_ctl.s.hs_power_en = 1;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
 
 	/* Step 9 */
 	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
 	uctl_ctl.s.uctl_rst = 0;
 	uctl_ctl.s.uahc_rst = 0;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
 
 	/* Step 8*/
 	cvmx_wait(10);
@@ -139,13 +195,12 @@ void octeon3_usb_clocks_start(int index)
 	/* Step 10*/
 	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
 	uctl_ctl.s.csclk_en = 1;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
 
 	/*Step 11*/
 	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
-	printk("Enabling host mode\n");
 	uctl_ctl.s.drd_mode = 0;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index),uctl_ctl.u64);
+	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
 
 	octeon_error_tree_enable(CVMX_ERROR_GROUP_USB, -1);//to_do separate for both usb
 exit:
@@ -155,9 +210,8 @@ exit:
 		mutex_unlock(&octeon3_usb2_clocks_mutex);
 
 }
-EXPORT_SYMBOL(octeon3_usb_clocks_start);
 
-void octeon3_usb_clocks_stop(int index)
+static void octeon3_usb_clocks_stop(int index)
 {
 	if (index == 0) {
 		mutex_lock(&octeon3_usb1_clocks_mutex);
@@ -199,3 +253,61 @@ void octeon3_usb_phy_reset(int index)
 	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
 }
 EXPORT_SYMBOL(octeon3_usb_phy_reset);
+
+int xhci_octeon_start(struct platform_device *pdev)
+{
+	struct resource *res_mem;
+	int host_ctrl;
+	struct platform_device *pr_pdev;
+
+	pr_pdev = container_of(pdev->dev.parent, struct platform_device, dev);
+	res_mem = platform_get_resource(pr_pdev, IORESOURCE_MEM, 0);
+	if (res_mem == NULL) {
+		dev_err(&pr_pdev->dev, "found no memory resource\n");
+		return -ENXIO;
+	}
+	switch (res_mem->start) {
+	case 0x1180068000000:
+		host_ctrl = 0;
+		break;
+	case 0x1180069000000:
+		host_ctrl = 1;
+		break;
+	default:
+		dev_err(&pdev->dev, "incorrect memory resource address\n");
+		return -ENXIO;
+	}
+	octeon3_usb_clocks_start(pr_pdev, host_ctrl);
+	octeon3_usb_set_endian_mode(host_ctrl);
+	dev_info(&pr_pdev->dev, "clocks initialized!!!!!!\n");
+	return 0;
+}
+
+int xhci_octeon_stop(struct platform_device *pdev)
+{
+	struct resource *res_mem;
+	int host_ctrl;
+	struct platform_device *pr_pdev;
+
+	pr_pdev = container_of(pdev->dev.parent, struct platform_device, dev);
+
+	res_mem = platform_get_resource(pr_pdev, IORESOURCE_MEM, 0);
+	if (res_mem == NULL) {
+		dev_err(&pr_pdev->dev, "found no memory resource\n");
+		return -ENXIO;
+	}
+	switch (res_mem->start) {
+	case 0x1180068000000:
+		host_ctrl = 0;
+		break;
+	case 0x1180069000000:
+		host_ctrl = 1;
+		break;
+	default:
+		dev_err(&pdev->dev, "incorrect memory resource address\n");
+		return -ENXIO;
+	}
+	octeon3_usb_clocks_stop(host_ctrl);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
-- 
1.7.0.4

