From c658bd8e8db3bba330fdca2802065100975e3b8a Mon Sep 17 00:00:00 2001
From: Peter Swain <peter.swain@cavium.com>
Date: Tue, 29 Oct 2013 19:28:47 -0700
Subject: [PATCH 325/382] MIPS: OCTEON: hw_status tree, remove sleep-holding-rwlock issues

Based on SDK octeon3_3.10.

hw_status scans are done holding rwlock, so move outside outside
the lock some WARN()s & kmalloc()s which could cause hang.
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/cavium-octeon/octeon-hw-status.c |  112 +++++++++++++++++++---------
 1 files changed, 76 insertions(+), 36 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-hw-status.c b/arch/mips/cavium-octeon/octeon-hw-status.c
index 1b9e5dc..23db696 100644
--- a/arch/mips/cavium-octeon/octeon-hw-status.c
+++ b/arch/mips/cavium-octeon/octeon-hw-status.c
@@ -100,6 +100,7 @@ static int visit_leaves(struct octeon_hw_status_node *s, bool visit_sibs,
 struct find_node_cb_data {
 	struct octeon_hw_status_node *r;
 	struct octeon_hw_status_reg *sr;
+	bool warn;
 };
 
 static int find_node_cb(struct octeon_hw_status_node *n, void *arg)
@@ -118,23 +119,26 @@ static int find_node_cb(struct octeon_hw_status_node *n, void *arg)
 	}
 	return 0;
 found:
-	WARN((n->child != NULL) != sr->has_child || n->ack_w1c != sr->ack_w1c,
-	     "Mismatched properties %p, %d, %d, %d",
-	     n->child, sr->has_child, n->ack_w1c, sr->ack_w1c);
 	d->r = n;
+	d->warn = ((n->child != NULL) != sr->has_child || n->ack_w1c != sr->ack_w1c);
 	return 1;
 }
 
 static struct octeon_hw_status_node *find_node(struct octeon_hw_status_node *r,
-					       struct octeon_hw_status_reg *sr)
+					       struct octeon_hw_status_reg *sr,
+					       struct find_node_cb_data *np)
 {
-	struct find_node_cb_data d;
-	d.r = NULL;
-	d.sr = sr;
+	struct find_node_cb_data d = { .warn  = false, };
 
-	visit_leaves(r, true, find_node_cb, &d);
+	if (!np)
+		np = &d;
 
-	return d.r;
+	np->r = NULL;
+	np->sr = sr;
+
+	visit_leaves(r, true, find_node_cb, np);
+
+	return np->r;
 }
 
 struct irq_cb_data {
@@ -189,14 +193,19 @@ static irqreturn_t octeon_hw_status_irq(int irq, void *dev)
 }
 
 static struct octeon_hw_status_node *find_child(struct octeon_hw_status_node *r,
-						struct octeon_hw_status_reg *sr)
+						struct octeon_hw_status_reg *sr,
+						struct find_node_cb_data  *np)
 {
 	struct octeon_hw_status_node *cw = r->child;
 	struct find_node_cb_data cbd;
-	cbd.r = NULL;
-	cbd.sr = sr;
+
+	if (!np)
+		np = &cbd;
+	np->r = NULL;
+	np->sr = sr;
+	np->warn = false;
 	while (cw) {
-		if (find_node_cb(cw, &cbd))
+		if (find_node_cb(cw, np))
 			break;
 		cw = cw->next;
 	}
@@ -209,25 +218,34 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 	struct octeon_hw_status_node *root;
 	struct octeon_hw_status_node *n;
 	struct octeon_hw_status_node *w;
+	struct octeon_hw_status_node *new_root;
+	struct octeon_hw_status_node *new_child;
+	struct find_node_cb_data match = { .warn = false, };
 	bool root_created = false;
 	int rv = 0;
+	int oflow;
 
 	if (!chain->reg_is_hwint)
 		return -EINVAL;
 
+	/* may need 0..2 nodes, grab before locking */
+	new_root = kzalloc(sizeof(struct octeon_hw_status_node), GFP_KERNEL);
+	new_child = kzalloc(sizeof(struct octeon_hw_status_node), GFP_KERNEL);
+
 	write_lock(&octeon_hw_status_lock);
+
 	/* Find the root */
 	root = octeon_hw_status_roots;
 	while (root && root->hwint != chain->reg)
 		root = root->next;
 
 	if (!root) {
-		root = kzalloc(sizeof(struct octeon_hw_status_node),
-			       GFP_KERNEL);
-		if (!root) {
+		if (!new_root) {
 			rv = -ENOMEM;
-			goto out;
+			goto unlock;
 		}
+		root = new_root;
+		new_root = NULL;
 		root->hwint = chain->reg;
 		root->is_hwint = 1;
 		root->ack_w1c = chain->ack_w1c;
@@ -235,17 +253,18 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 		octeon_hw_status_roots = root;
 		root_created = true;
 	}
+
 	w = root;
 	while (chain->has_child) {
 		chain++;
-		n = find_child(w, chain);
+		n = find_child(w, chain, &match);
 		if (!n) {
-			n = kzalloc(sizeof(struct octeon_hw_status_node),
-				    GFP_KERNEL);
-			if (!n) {
+			if (!new_child) {
 				rv = -ENOMEM;
-				goto out;
+				goto unlock;
 			}
+			n = new_child;
+			new_child = NULL;
 			n->is_hwint = chain->reg_is_hwint;
 			n->ack_w1c = chain->ack_w1c;
 			if (n->is_hwint) {
@@ -262,15 +281,21 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 		w = n;
 	}
 	w->users++;
-	WARN(w->users == 0, "Reference count overflowed!");
+	oflow = !w->users;
 
 	write_unlock(&octeon_hw_status_lock);
 
+	WARN(oflow, "Reference count overflowed!");
+	WARN(match.warn, "Mismatched properties %p, %d, %d, %d",
+	     match.r->child, match.sr->has_child, match.r->ack_w1c, match.sr->ack_w1c);
+
 	if (root_created) {
 		/* register an interrupt handler */
 		root->irq = irq_create_mapping(NULL, root->hwint);
-		if (!root->irq)
-			return -ENXIO;
+		if (!root->irq) {
+			rv = -ENXIO;
+			goto bye;
+		}
 
 		rv = request_threaded_irq(root->irq, NULL, octeon_hw_status_irq,
 					  IRQF_ONESHOT, "octeon-hw-status", root);
@@ -281,10 +306,16 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 	ohsd.bit = w->bit;
 	raw_notifier_call_chain(&octeon_hw_status_notifiers,
 				OCTEON_HW_STATUS_SOURCE_ADDED, &ohsd);
-	return 0;
-out:
-	write_unlock(&octeon_hw_status_lock);
+	rv = 0;
+bye:
+	if (new_root)
+		kfree(new_root);
+	if (new_child)
+		kfree(new_child);
 	return rv;
+unlock:
+	write_unlock(&octeon_hw_status_lock);
+	goto bye;
 }
 EXPORT_SYMBOL(octeon_hw_status_add_source);
 
@@ -319,12 +350,9 @@ static bool dispose_of_node(struct octeon_hw_status_node *n)
 					free_irq(n->irq, n);
 				}
 				kfree(n);
-				if (rv)
-					return rv;
-				break;
-			} else {
-				pw = &(*pw)->next;
+				return rv;
 			}
+			pw = &(*pw)->next;
 		}
 		/* Stop at the root or if there are more children. */
 		if (!parent || parent->child)
@@ -339,10 +367,11 @@ int octeon_hw_status_remove_source(struct octeon_hw_status_reg *leaf)
 	int rv = 0;
 	bool already_unlocked = false;
 	struct octeon_hw_status_node *n;
+	struct find_node_cb_data d = { .warn  = false, };
 
 	write_lock(&octeon_hw_status_lock);
 
-	n = find_node(octeon_hw_status_roots, leaf);
+	n = find_node(octeon_hw_status_roots, leaf, &d);
 	if (!n) {
 		rv = -ENODEV;
 		goto out;
@@ -354,6 +383,10 @@ int octeon_hw_status_remove_source(struct octeon_hw_status_reg *leaf)
 out:
 	if (!already_unlocked)
 		write_unlock(&octeon_hw_status_lock);
+
+	WARN(d.warn, "Mismatched properties %p, %d, %d, %d",
+	     d.r->child, d.sr->has_child, d.r->ack_w1c, d.sr->ack_w1c);
+
 	return rv;
 }
 EXPORT_SYMBOL(octeon_hw_status_remove_source);
@@ -364,6 +397,7 @@ struct enable_cb_data {
 	u64 requested_mask;
 	u64 mask_reg;
 	u64 valid_mask;
+	u64 warn_mask;
 };
 
 static int enable_cb(struct octeon_hw_status_node *n, void *arg)
@@ -372,8 +406,8 @@ static int enable_cb(struct octeon_hw_status_node *n, void *arg)
 
 	if (n->reg == d->reg && (d->requested_mask & (1ul << n->bit))) {
 		d->valid_mask |= (1ul << n->bit);
-		WARN(d->mask_reg && d->mask_reg != n->mask_reg,
-		     "mask reg mismatch %llu", n->reg);
+		if (d->mask_reg && d->mask_reg != n->mask_reg)
+			d->warn_mask |= (d->mask_reg ^ n->mask_reg);
 		d->mask_reg = n->mask_reg;
 	}
 	return 0;
@@ -398,6 +432,9 @@ int octeon_hw_status_enable(u64 reg, u64 bit_mask)
 	}
 
 	read_unlock(&octeon_hw_status_lock);
+
+	WARN(cbd.warn_mask, "mask reg mismatch %llu %llu", cbd.reg, cbd.warn_mask);
+
 	return 0;
 }
 EXPORT_SYMBOL(octeon_hw_status_enable);
@@ -421,6 +458,9 @@ int octeon_hw_status_disable(u64 reg, u64 bit_mask)
 	}
 
 	read_unlock(&octeon_hw_status_lock);
+
+	WARN(cbd.warn_mask, "mask reg mismatch %llu %llu", cbd.reg, cbd.warn_mask);
+
 	return 0;
 }
 EXPORT_SYMBOL(octeon_hw_status_disable);
-- 
1.7.0.4

