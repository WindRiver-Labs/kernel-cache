From d2558a48542da419af80f76265b2680b00dff284 Mon Sep 17 00:00:00 2001
From: Peter Swain <peter.swain@cavium.com>
Date: Mon, 11 Nov 2013 14:21:15 -0800
Subject: [PATCH 356/382] Revert "MIPS: OCTEON: hw_status tree, remove sleep-holding-rwlock issues"

Based on SDK octeon3_3.10.

This reverts commit ae75eac54673f5a15460e411a72dfd7b50cc3c7e,
which introduced some other problems.

I'll clean up the sleep-holding-rwlock issues again, in a cleaner
set of commits, verifying functionality with a new debugfs walker.
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/cavium-octeon/octeon-hw-status.c |  178 +++++++---------------------
 1 files changed, 44 insertions(+), 134 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-hw-status.c b/arch/mips/cavium-octeon/octeon-hw-status.c
index 1632e9d..1b9e5dc 100644
--- a/arch/mips/cavium-octeon/octeon-hw-status.c
+++ b/arch/mips/cavium-octeon/octeon-hw-status.c
@@ -11,13 +11,10 @@
 #include <linux/notifier.h>
 #include <linux/export.h>
 #include <linux/slab.h>
-#include <linux/moduleparam.h>
 
 #include <asm/octeon/octeon-hw-status.h>
 #include <asm/octeon/octeon.h>
 
-#define DRV_NAME "octeon-hw-status"
-
 static RAW_NOTIFIER_HEAD(octeon_hw_status_notifiers);
 
 int octeon_hw_status_notifier_register(struct notifier_block *nb)
@@ -32,10 +29,6 @@ int octeon_hw_status_notifier_unregister(struct notifier_block *nb)
 }
 EXPORT_SYMBOL(octeon_hw_status_notifier_unregister);
 
-enum { ref_max_users = 0xff, };
-static bool count_debug;
-module_param(count_debug, bool, 0644);
-
 struct octeon_hw_status_node {
 	struct octeon_hw_status_node *next; /* Child list */
 	struct octeon_hw_status_node *child;
@@ -107,7 +100,6 @@ static int visit_leaves(struct octeon_hw_status_node *s, bool visit_sibs,
 struct find_node_cb_data {
 	struct octeon_hw_status_node *r;
 	struct octeon_hw_status_reg *sr;
-	bool warn;
 };
 
 static int find_node_cb(struct octeon_hw_status_node *n, void *arg)
@@ -126,26 +118,23 @@ static int find_node_cb(struct octeon_hw_status_node *n, void *arg)
 	}
 	return 0;
 found:
+	WARN((n->child != NULL) != sr->has_child || n->ack_w1c != sr->ack_w1c,
+	     "Mismatched properties %p, %d, %d, %d",
+	     n->child, sr->has_child, n->ack_w1c, sr->ack_w1c);
 	d->r = n;
-	d->warn = ((n->child != NULL) != sr->has_child || n->ack_w1c != sr->ack_w1c);
 	return 1;
 }
 
 static struct octeon_hw_status_node *find_node(struct octeon_hw_status_node *r,
-					       struct octeon_hw_status_reg *sr,
-					       struct find_node_cb_data *np)
+					       struct octeon_hw_status_reg *sr)
 {
-	struct find_node_cb_data d = { .warn  = false, };
-
-	if (!np)
-		np = &d;
-
-	np->r = NULL;
-	np->sr = sr;
+	struct find_node_cb_data d;
+	d.r = NULL;
+	d.sr = sr;
 
-	visit_leaves(r, true, find_node_cb, np);
+	visit_leaves(r, true, find_node_cb, &d);
 
-	return np->r;
+	return d.r;
 }
 
 struct irq_cb_data {
@@ -200,19 +189,14 @@ static irqreturn_t octeon_hw_status_irq(int irq, void *dev)
 }
 
 static struct octeon_hw_status_node *find_child(struct octeon_hw_status_node *r,
-						struct octeon_hw_status_reg *sr,
-						struct find_node_cb_data  *np)
+						struct octeon_hw_status_reg *sr)
 {
 	struct octeon_hw_status_node *cw = r->child;
 	struct find_node_cb_data cbd;
-
-	if (!np)
-		np = &cbd;
-	np->r = NULL;
-	np->sr = sr;
-	np->warn = false;
+	cbd.r = NULL;
+	cbd.sr = sr;
 	while (cw) {
-		if (find_node_cb(cw, np))
+		if (find_node_cb(cw, &cbd))
 			break;
 		cw = cw->next;
 	}
@@ -223,37 +207,27 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 {
 	struct octeon_hw_status_data ohsd;
 	struct octeon_hw_status_node *root;
+	struct octeon_hw_status_node *n;
 	struct octeon_hw_status_node *w;
-	struct octeon_hw_status_node *new_root;
-	struct octeon_hw_status_node *new_child;
-	struct find_node_cb_data match = { .warn = false, };
-	bool oflow = false;
 	bool root_created = false;
-	bool created = false;
-	int siblings = 0;
 	int rv = 0;
 
 	if (!chain->reg_is_hwint)
 		return -EINVAL;
 
-	/* may need 0..2 nodes, grab before locking */
-	new_root = kzalloc(sizeof(struct octeon_hw_status_node), GFP_KERNEL);
-	new_child = kzalloc(sizeof(struct octeon_hw_status_node), GFP_KERNEL);
-
 	write_lock(&octeon_hw_status_lock);
-
 	/* Find the root */
 	root = octeon_hw_status_roots;
 	while (root && root->hwint != chain->reg)
 		root = root->next;
 
 	if (!root) {
-		if (!new_root) {
+		root = kzalloc(sizeof(struct octeon_hw_status_node),
+			       GFP_KERNEL);
+		if (!root) {
 			rv = -ENOMEM;
-			goto unlock;
+			goto out;
 		}
-		root = new_root;
-		new_root = NULL;
 		root->hwint = chain->reg;
 		root->is_hwint = 1;
 		root->ack_w1c = chain->ack_w1c;
@@ -261,23 +235,19 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 		octeon_hw_status_roots = root;
 		root_created = true;
 	}
-
 	w = root;
 	while (chain->has_child) {
-		struct octeon_hw_status_node *n;
 		chain++;
-		n = find_child(w, chain, &match);
+		n = find_child(w, chain);
 		if (!n) {
-			if (!new_child) {
+			n = kzalloc(sizeof(struct octeon_hw_status_node),
+				    GFP_KERNEL);
+			if (!n) {
 				rv = -ENOMEM;
-				goto unlock;
+				goto out;
 			}
-			n = new_child;
-			new_child = NULL;
-			match.r = n;
 			n->is_hwint = chain->reg_is_hwint;
 			n->ack_w1c = chain->ack_w1c;
-			n->users = 1;
 			if (n->is_hwint) {
 				n->hwint = chain->reg;
 			} else {
@@ -285,69 +255,36 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 				n->mask_reg = chain->mask_reg;
 				n->bit = chain->bit;
 			}
-
-			/* attach to parent */
-			n->parent = w;
 			n->next = w->child;
 			w->child = n;
-			chain->has_child = 1;
-
-			/* parent ref-count */
-			oflow = (w->users == ref_max_users);
-			if (!oflow)
-				w->users++;
-			siblings = w->users;
-			created = true;
-			break;
+			n->parent = w;
 		}
 		w = n;
 	}
+	w->users++;
+	WARN(w->users == 0, "Reference count overflowed!");
 
 	write_unlock(&octeon_hw_status_lock);
 
-	if (count_debug) {
-		if (root_created)
-			printk(DRV_NAME " %llx/%llx:%d created root\n",
-				chain->reg, chain->mask_reg, chain->bit);
-		printk(DRV_NAME " %llx/%llx:%d refcount %s%d\n",
-			match.r->reg, match.r->mask_reg, match.r->bit,
-			created ? "++" : "", siblings);
-	}
-	WARN(oflow, DRV_NAME " Reference count overflowed!\n");
-	WARN(match.warn, DRV_NAME " Mismatched properties %p, %d, %d, %d\n",
-		 match.r->child, match.sr->has_child,
-		 match.r->ack_w1c, match.sr->ack_w1c);
-
 	if (root_created) {
 		/* register an interrupt handler */
 		root->irq = irq_create_mapping(NULL, root->hwint);
-		if (!root->irq) {
-			rv = -ENXIO;
-			goto bye;
-		}
+		if (!root->irq)
+			return -ENXIO;
 
 		rv = request_threaded_irq(root->irq, NULL, octeon_hw_status_irq,
-				          IRQF_ONESHOT, DRV_NAME, root);
-		WARN(rv, DRV_NAME " request_threaded_irq failed: %d\n", rv);
+					  IRQF_ONESHOT, "octeon-hw-status", root);
+		WARN(rv, "request_threaded_irq failed: %d", rv);
 	}
 
 	ohsd.reg = w->reg;
 	ohsd.bit = w->bit;
 	raw_notifier_call_chain(&octeon_hw_status_notifiers,
 				OCTEON_HW_STATUS_SOURCE_ADDED, &ohsd);
-	rv = 0;
-bye:
-	if (new_root)
-		kfree(new_root);
-	if (new_child)
-		kfree(new_child);
-	if (rv && count_debug)
-		printk(DRV_NAME " %llx/%llx:%d err %d\n",
-			chain->reg, chain->mask_reg, chain->bit, rv);
-	return rv;
-unlock:
+	return 0;
+out:
 	write_unlock(&octeon_hw_status_lock);
-	goto bye;
+	return rv;
 }
 EXPORT_SYMBOL(octeon_hw_status_add_source);
 
@@ -382,9 +319,12 @@ static bool dispose_of_node(struct octeon_hw_status_node *n)
 					free_irq(n->irq, n);
 				}
 				kfree(n);
-				return rv;
+				if (rv)
+					return rv;
+				break;
+			} else {
+				pw = &(*pw)->next;
 			}
-			pw = &(*pw)->next;
 		}
 		/* Stop at the root or if there are more children. */
 		if (!parent || parent->child)
@@ -399,42 +339,21 @@ int octeon_hw_status_remove_source(struct octeon_hw_status_reg *leaf)
 	int rv = 0;
 	bool already_unlocked = false;
 	struct octeon_hw_status_node *n;
-	struct find_node_cb_data d = { .warn  = false, };
-	bool oflow = false;
-	bool gone = false;
 
 	write_lock(&octeon_hw_status_lock);
 
-	n = find_node(octeon_hw_status_roots, leaf, &d);
+	n = find_node(octeon_hw_status_roots, leaf);
 	if (!n) {
 		rv = -ENODEV;
 		goto out;
 	}
 
-	/* Can't Happen: count overflowed, so decrement unsafe */
-	oflow = (n->users == ref_max_users);
-	if (!oflow) {
-		n->users--;
-		if (n->users == 0) {
-			gone = true;
-			/* should clear parent->has_child if was last, free parent */
-			already_unlocked = dispose_of_node(n);
-		}
-	}
+	n->users--;
+	if (n->users == 0)
+		already_unlocked = dispose_of_node(n);
 out:
 	if (!already_unlocked)
 		write_unlock(&octeon_hw_status_lock);
-
-	WARN(d.warn, DRV_NAME " Mismatched properties %p, %d, %d, %d\n",
-	     d.r->child, d.sr->has_child, d.r->ack_w1c, d.sr->ack_w1c);
-
-	if (count_debug && gone)
-		printk(DRV_NAME " %llx:%d gone\n",
-			d.r->reg, d.r->bit);
-	else if (count_debug)
-		printk(DRV_NAME " %llx:%d refcount --%d@%p\n",
-			d.r->reg, d.r->bit, n->users, n);
-
 	return rv;
 }
 EXPORT_SYMBOL(octeon_hw_status_remove_source);
@@ -445,7 +364,6 @@ struct enable_cb_data {
 	u64 requested_mask;
 	u64 mask_reg;
 	u64 valid_mask;
-	u64 warn_mask;
 };
 
 static int enable_cb(struct octeon_hw_status_node *n, void *arg)
@@ -454,8 +372,8 @@ static int enable_cb(struct octeon_hw_status_node *n, void *arg)
 
 	if (n->reg == d->reg && (d->requested_mask & (1ul << n->bit))) {
 		d->valid_mask |= (1ul << n->bit);
-		if (d->mask_reg && d->mask_reg != n->mask_reg)
-			d->warn_mask |= (d->mask_reg ^ n->mask_reg);
+		WARN(d->mask_reg && d->mask_reg != n->mask_reg,
+		     "mask reg mismatch %llu", n->reg);
 		d->mask_reg = n->mask_reg;
 	}
 	return 0;
@@ -480,10 +398,6 @@ int octeon_hw_status_enable(u64 reg, u64 bit_mask)
 	}
 
 	read_unlock(&octeon_hw_status_lock);
-
-	WARN(cbd.warn_mask, DRV_NAME " mask reg mismatch %llu %llu\n",
-		cbd.reg, cbd.warn_mask);
-
 	return 0;
 }
 EXPORT_SYMBOL(octeon_hw_status_enable);
@@ -507,10 +421,6 @@ int octeon_hw_status_disable(u64 reg, u64 bit_mask)
 	}
 
 	read_unlock(&octeon_hw_status_lock);
-
-	WARN(cbd.warn_mask, DRV_NAME " mask reg mismatch %llu %llu\n",
-		cbd.reg, cbd.warn_mask);
-
 	return 0;
 }
 EXPORT_SYMBOL(octeon_hw_status_disable);
-- 
1.7.0.4

