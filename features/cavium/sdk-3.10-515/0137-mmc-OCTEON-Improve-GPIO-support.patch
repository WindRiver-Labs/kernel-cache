From 2efdd7d2baa4f24566e844391f01fa068ea3d3fb Mon Sep 17 00:00:00 2001
From: Aaron Williams <aaron.williams@cavium.com>
Date: Thu, 10 Jan 2013 16:22:24 -0800
Subject: [PATCH 137/382] mmc: OCTEON: Improve GPIO support.

Based on SDK octeon3_3.10.

Warnings were being displayed if any of the GPIO controls for
card detect, write protect or power were defined because the
GPIO lines were not requested before use.

This change requests the GPIO lines before use and frees them
when the card is removed.

Fixed pr_err warnings and replaced pr_err with dev_err
Fixed cleanup of GPIO code

Signed-off-by: Aaron Williams <aaron.williams@cavium.com>
Signed-off-by: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mmc/host/octeon_mmc.c |   69 +++++++++++++++++++++++++++++++++++-----
 1 files changed, 60 insertions(+), 9 deletions(-)

diff --git a/drivers/mmc/host/octeon_mmc.c b/drivers/mmc/host/octeon_mmc.c
index fd1bbef..ba7753b 100644
--- a/drivers/mmc/host/octeon_mmc.c
+++ b/drivers/mmc/host/octeon_mmc.c
@@ -27,6 +27,7 @@
 #include <linux/mmc/host.h>
 #include <linux/mmc/mmc.h>
 #include <linux/mmc/sd.h>
+#include <net/irda/parameters.h>
 
 #include <asm/byteorder.h>
 #include <asm/octeon/octeon.h>
@@ -283,7 +284,8 @@ static irqreturn_t octeon_mmc_dma_interrupt(int irq, void *dev_id)
 	cvmx_write_csr(host->ndf_base + OCT_MIO_NDF_DMA_INT, 1);
 
 	if (!host->current_req || !host->current_req->data) {
-		pr_err("ERROR: no current_req for octeon_mmc_dma_interrupt\n");
+		dev_err(&host->pdev->dev,
+			"ERROR: no current_req for octeon_mmc_dma_interrupt\n");
 		goto out;
 	}
 
@@ -427,7 +429,8 @@ static void octeon_mmc_dma_request(struct mmc_host *mmc,
 	cmd = mrq->cmd;
 	if (mrq->data == NULL || mrq->data->sg == NULL || !mrq->data->sg_len ||
 	    mrq->stop == NULL || mrq->stop->opcode != MMC_STOP_TRANSMISSION) {
-		pr_err("Error: octeon_mmc_dma_request no data\n");
+		dev_err(&mmc->card->dev,
+			"Error: octeon_mmc_dma_request no data\n");
 		cmd->error = -EINVAL;
 		if (mrq->done)
 			mrq->done(mrq);
@@ -666,11 +669,11 @@ static void octeon_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 		octeon_mmc_reset_bus(slot, 1);
 		if (slot->power_gpio >= 0)
 			gpio_set_value_cansleep(slot->power_gpio,
-						slot->power_gpio_active_low ? 1 : 0);
+						slot->power_gpio_active_low);
 	} else {
 		if (slot->power_gpio >= 0)
 			gpio_set_value_cansleep(slot->power_gpio,
-						slot->power_gpio_active_low ? 0 : 1);
+						!slot->power_gpio_active_low);
 	}
 
 	switch (ios->bus_width) {
@@ -840,14 +843,44 @@ static int __init octeon_init_slot(struct octeon_mmc_host *host, int id,
 	slot->cd_gpio_active_low = cd_low;
 	slot->power_gpio_active_low = power_low;
 
-	if (slot->ro_gpio >= 0)
+	if (slot->ro_gpio >= 0) {
+		ret = gpio_request(slot->ro_gpio, "mmc_ro");
+		if (ret) {
+			dev_err(&host->pdev->dev,
+				"Could not request mmc_ro GPIO %d\n",
+				slot->ro_gpio);
+			return ret;
+		}
 		gpio_direction_input(slot->ro_gpio);
-	if (slot->cd_gpio >= 0)
+	}
+	if (slot->cd_gpio >= 0) {
+		ret = gpio_request(slot->cd_gpio, "mmc_card_detect");
+		if (ret) {
+			if (slot->ro_gpio >= 0)
+				gpio_free(slot->ro_gpio);
+			dev_err(&host->pdev->dev, "Could not request mmc_card_detect GPIO %d\n",
+				slot->cd_gpio);
+			return ret;
+		}
 		gpio_direction_input(slot->cd_gpio);
-	if (slot->power_gpio >= 0)
+	}
+	if (slot->power_gpio >= 0) {
+		ret = gpio_request(slot->power_gpio, "mmc_power");
+		if (ret) {
+			dev_err(&host->pdev->dev,
+				"Could not request mmc_power GPIO %d\n",
+				slot->power_gpio);
+			if (slot->ro_gpio >= 0)
+				gpio_free(slot->ro_gpio);
+			if (slot->cd_gpio)
+				gpio_free(slot->cd_gpio);
+			return ret;
+		}
+		pr_debug("%s: Shutting off power to slot %d via gpio %d\n",
+			 DRV_NAME, slot->bus_id, slot->power_gpio);
 		gpio_direction_output(slot->power_gpio,
-				      slot->power_gpio_active_low ? 1 : 0);
-
+				      slot->power_gpio_active_low);
+	}
 	/*
 	 * Set up host parameters.
 	 */
@@ -1046,6 +1079,7 @@ static int octeon_mmc_remove(struct platform_device *pdev)
 	struct octeon_mmc_host *host = platform_get_drvdata(pdev);
 
 	if (host) {
+		int i;
 		/* Reset bus_id */
 		ndf_dma_cfg.u64 = cvmx_read_csr(host->ndf_base + OCT_MIO_NDF_DMA_CFG);
 		ndf_dma_cfg.s.en = 0;
@@ -1056,6 +1090,23 @@ static int octeon_mmc_remove(struct platform_device *pdev)
 		ndf_dma_int.u64 = 0;
 		cvmx_write_csr(host->ndf_base + OCT_MIO_NDF_DMA_INT,
 			       ndf_dma_int.u64);
+
+		for (i = 0; i < OCTEON_MAX_MMC; i++) {
+			struct octeon_mmc_slot *slot;
+			slot = host->slot[i];
+			if (!slot)
+				continue;
+			/* Free the GPIOs */
+			if (slot->ro_gpio >= 0)
+				gpio_free(slot->ro_gpio);
+			if (slot->cd_gpio >= 0)
+				gpio_free(slot->cd_gpio);
+			if (slot->power_gpio >= 0) {
+				gpio_set_value_cansleep(slot->power_gpio,
+							slot->power_gpio_active_low);
+				gpio_free(slot->power_gpio);
+			}
+		}
 	}
 
 	platform_set_drvdata(pdev, NULL);
-- 
1.7.0.4

