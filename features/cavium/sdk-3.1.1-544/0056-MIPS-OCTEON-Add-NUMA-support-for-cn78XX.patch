From 813cd5f4c18f1d10408e4ca355ff120fa3f1a86c Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 13 Feb 2015 14:25:47 +0530
Subject: [PATCH 056/132] MIPS: OCTEON: Add NUMA support for cn78XX

Commit dc0de45cb0ae53ee28c5a94cdd735cdbe787f0ff from
git://git.yoctoproject.org/linux-yocto-3.14

Create machine specific bootmem initialization, and add topology
functions.  This gets it to boot, but more changes needed to be able
to use devices on node-1.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Abhishek Paliwal <abhishek.paliwal@aricent.com>
[Original patch taken from OCTEON-SDK 3.1.1-544.]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/Kconfig                                  |   2 +
 arch/mips/cavium-octeon/Makefile                   |   1 +
 arch/mips/cavium-octeon/octeon-numa.c              | 102 +++++++++++++++++++++
 arch/mips/cavium-octeon/setup.c                    | 100 ++++++++++++++++++++
 .../include/asm/mach-cavium-octeon/mach_bootmem.h  |   8 ++
 arch/mips/include/asm/mach-cavium-octeon/mmzone.h  |  21 +++++
 .../mips/include/asm/mach-cavium-octeon/topology.h |  42 +++++++++
 7 files changed, 276 insertions(+)
 create mode 100644 arch/mips/cavium-octeon/octeon-numa.c
 create mode 100644 arch/mips/include/asm/mach-cavium-octeon/mach_bootmem.h
 create mode 100644 arch/mips/include/asm/mach-cavium-octeon/mmzone.h
 create mode 100644 arch/mips/include/asm/mach-cavium-octeon/topology.h

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 23b6517..778ee0e 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -832,6 +832,7 @@ config CAVIUM_OCTEON_SOC
 	select ARCH_REQUIRE_GPIOLIB
 	select NR_CPUS_DEFAULT_64
 	select MIPS_NR_CPU_NR_MAP_1024
+	select SYS_SUPPORTS_NUMA
 	select LIBFDT
 	select USE_OF
 	select ARCH_SPARSEMEM_ENABLE
@@ -2426,6 +2427,7 @@ config SYS_SUPPORTS_NUMA
 
 config NODES_SHIFT
 	int
+	default "1" if CAVIUM_OCTEON_SOC
 	default "6"
 	depends on NEED_MULTIPLE_NODES
 
diff --git a/arch/mips/cavium-octeon/Makefile b/arch/mips/cavium-octeon/Makefile
index 87018b5..6ef247e 100644
--- a/arch/mips/cavium-octeon/Makefile
+++ b/arch/mips/cavium-octeon/Makefile
@@ -21,6 +21,7 @@ obj-y += crypto/
 
 obj-$(CONFIG_MTD)		      += flash_setup.o
 obj-$(CONFIG_SMP)		      += smp.o
+obj-$(CONFIG_NUMA)                      += octeon-numa.o
 obj-$(CONFIG_OCTEON_ILM)	      += oct_ilm.o
 obj-$(CONFIG_SYSFS)                   += octeon-power-throttle.o
 obj-$(CONFIG_SYSFS)                   += cacheinfo.o
diff --git a/arch/mips/cavium-octeon/octeon-numa.c b/arch/mips/cavium-octeon/octeon-numa.c
new file mode 100644
index 0000000..d32960a
--- /dev/null
+++ b/arch/mips/cavium-octeon/octeon-numa.c
@@ -0,0 +1,102 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2014 Cavium, Inc.
+ */
+
+#include <linux/init.h>
+#include <linux/topology.h>
+#include <linux/mm.h>
+#include <linux/nodemask.h>
+#include <linux/bootmem.h>
+#include <linux/swap.h>
+
+#include <asm/sections.h>
+
+#include <asm/pgalloc.h>
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-coremask.h>
+
+
+void octeon_setup_numa(void)
+{
+	int id;
+	int node;
+	struct cpumask *mask;
+	const int coreid = cvmx_get_core_num();
+	struct cvmx_sysinfo *sysinfo = cvmx_sysinfo_get();
+
+	for (id = 0; id < CONFIG_MIPS_NR_CPU_NR_MAP; id++) {
+		if (cvmx_coremask_is_core_set(&sysinfo->core_mask, id)) {
+			node = (id >> 7) & 7;
+			node_set_online(node);
+			node_set_state(node, N_POSSIBLE);
+		}
+	}
+	node = (coreid >> 7) & 7;
+	mask = cpumask_of_node(node);
+	/* The boot CPU will be CPU 0 */
+	cpu_set(0, *mask);
+}
+
+void octeon_numa_cpu_online(void)
+{
+	int node;
+	struct cpumask *mask;
+	const int coreid = cvmx_get_core_num();
+
+	node = (coreid >> 7) & 7;
+	mask = cpumask_of_node(node);
+	cpu_set(smp_processor_id(), *mask);
+}
+
+void __init paging_init(void)
+{
+	unsigned long max_zone_pfns[MAX_NR_ZONES] = {0,};
+	unsigned node;
+
+	pagetable_init();
+
+#ifdef CONFIG_ZONE_DMA
+	max_zone_pfns[ZONE_DMA] = MAX_DMA_PFN;
+#endif
+#ifdef CONFIG_ZONE_DMA32
+	max_zone_pfns[ZONE_DMA32] = MAX_DMA32_PFN;
+#endif
+	for_each_online_node(node) {
+		unsigned long start_pfn, end_pfn;
+
+		get_pfn_range_for_nid(node, &start_pfn, &end_pfn);
+
+		if (end_pfn > max_low_pfn)
+			max_low_pfn = end_pfn;
+	}
+	max_zone_pfns[ZONE_NORMAL] = max_low_pfn;
+
+	free_area_init_nodes(max_zone_pfns);
+}
+
+void setup_zero_pages(void);
+
+void __init mem_init(void)
+{
+	unsigned long codesize, datasize, initsize, tmp;
+
+	free_all_bootmem();
+	setup_zero_pages();	/* This comes from node 0 */
+
+	codesize =  (unsigned long) &_etext - (unsigned long) &_text;
+	datasize =  (unsigned long) &_edata - (unsigned long) &_etext;
+	initsize =  (unsigned long) &__init_end - (unsigned long) &__init_begin;
+
+	tmp = nr_free_pages();
+	pr_info("Memory: %luk/%luk available (%ldk kernel code, %ldk reserved, %ldk data, %ldk init)\n",
+	       tmp << (PAGE_SHIFT-10),
+	       totalram_pages << (PAGE_SHIFT-10),
+	       codesize >> 10,
+	       (totalram_pages - tmp) << (PAGE_SHIFT-10),
+	       datasize >> 10,
+	       initsize >> 10);
+}
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index c010645..a171957 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -29,6 +29,11 @@
 #include <linux/libfdt.h>
 #include <linux/kexec.h>
 
+#include <linux/bootmem.h>
+#include <linux/memblock.h>
+
+#include <mmzone.h>
+
 #include <asm/processor.h>
 #include <asm/reboot.h>
 #include <asm/smp-ops.h>
@@ -909,6 +914,7 @@ void __init prom_init(void)
 #endif
 
 	octeon_user_io_init();
+	octeon_setup_numa();
 	octeon_setup_smp();
 
 #ifdef CONFIG_CAVIUM_GDB
@@ -1172,6 +1178,100 @@ void __init plat_mem_setup(void)
 		panic("Unable to allocate memory from cvmx_bootmem_phy_alloc");
 }
 
+struct node_data __node_data[4];
+EXPORT_SYMBOL(__node_data);
+
+void __init mach_bootmem_init(void)
+{
+	int i;
+	int node;
+
+	min_low_pfn = ~0UL;
+	max_low_pfn = 0;
+
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		unsigned long start, end;
+		struct node_data *nd;
+		bool is_usable;
+
+		switch (boot_mem_map.map[i].type) {
+		case BOOT_MEM_RAM:
+			is_usable = true;
+			break;
+		case BOOT_MEM_KERNEL:
+		case BOOT_MEM_INIT_RAM:
+			is_usable = false;
+			break;
+		default:
+			/* Not usable memory */
+			continue;
+		}
+		start = PFN_UP(boot_mem_map.map[i].addr);
+		end = PFN_DOWN(boot_mem_map.map[i].addr
+				+ boot_mem_map.map[i].size);
+		node = pa_to_nid(boot_mem_map.map[i].addr);
+		nd = __node_data + node;
+
+		if (max_low_pfn < end)
+			max_low_pfn = end;
+		if (min_low_pfn > start)
+			min_low_pfn = start;
+
+		memblock_add_node(PFN_PHYS(start), PFN_PHYS(end - start), node);
+
+		if (nd->endpfn == 0) {
+			nd->startpfn = start;
+			nd->endpfn = end;
+		} else {
+			if (nd->startpfn > start)
+				nd->startpfn = start;
+			if (nd->endpfn < end)
+				nd->endpfn = end;
+		}
+		if (is_usable && (nd->startmempfn == 0 || start < nd->startmempfn))
+			nd->startmempfn = start;
+	}
+	totalram_pages = 0;
+
+	for_each_online_node(node) {
+		unsigned long bootmap_size;
+		struct node_data *nd = __node_data + node;
+		if (nd->endpfn == 0)
+			continue;
+		NODE_DATA(node)->bdata = &bootmem_node_data[node];
+		bootmap_size = init_bootmem_node(NODE_DATA(node), nd->startmempfn, nd->startpfn,  nd->endpfn);
+
+		for (i = 0; i < boot_mem_map.nr_map; i++) {
+			int map_nid;
+			bool is_init;
+
+			switch (boot_mem_map.map[i].type) {
+			case BOOT_MEM_RAM:
+				is_init = false;
+				break;
+			case BOOT_MEM_INIT_RAM:
+				is_init = true;
+				break;
+			default:
+				/* Not usable memory */
+				continue;
+			}
+			map_nid = pa_to_nid(boot_mem_map.map[i].addr);
+			if (map_nid != node)
+				continue;
+			memory_present(node,
+				       PFN_DOWN(boot_mem_map.map[i].addr),
+				       PFN_UP(boot_mem_map.map[i].addr + boot_mem_map.map[i].size));
+			if (!is_init) {
+				totalram_pages += PFN_DOWN(boot_mem_map.map[i].size);
+				memblock_add_node(boot_mem_map.map[i].addr, boot_mem_map.map[i].size, node);
+				free_bootmem_node(NODE_DATA(node), boot_mem_map.map[i].addr, boot_mem_map.map[i].size);
+			}
+		}
+		reserve_bootmem(PFN_PHYS(nd->startmempfn), bootmap_size, BOOTMEM_DEFAULT);
+	}
+}
+
 /*
  * Emit one character to the boot UART.	 Exported for use by the
  * watchdog timer.
diff --git a/arch/mips/include/asm/mach-cavium-octeon/mach_bootmem.h b/arch/mips/include/asm/mach-cavium-octeon/mach_bootmem.h
new file mode 100644
index 0000000..3d8d1de
--- /dev/null
+++ b/arch/mips/include/asm/mach-cavium-octeon/mach_bootmem.h
@@ -0,0 +1,8 @@
+#ifndef _ASM_MACH_CAVIUM_OCTEON_MACH_BOOTMEM_H
+#define _ASM_MACH_CAVIUM_OCTEON_MACH_BOOTMEM_H
+
+void mach_bootmem_init(void);
+
+#define mach_bootmem_init mach_bootmem_init
+
+#endif /* _ASM_MACH_CAVIUM_OCTEON_MACH_BOOTMEM_H */
diff --git a/arch/mips/include/asm/mach-cavium-octeon/mmzone.h b/arch/mips/include/asm/mach-cavium-octeon/mmzone.h
new file mode 100644
index 0000000..c612a74
--- /dev/null
+++ b/arch/mips/include/asm/mach-cavium-octeon/mmzone.h
@@ -0,0 +1,21 @@
+#ifndef _ASM_MACH_CAVIUM_OCTEON_MMZONE_H
+#define _ASM_MACH_CAVIUM_OCTEON_MMZONE_H
+
+struct node_data {
+#ifdef CONFIG_NUMA
+	struct pglist_data pglist;
+	struct cpumask cpumask_on_node;
+#endif
+	unsigned long startmempfn;
+	unsigned long startpfn;
+	unsigned long endpfn;
+};
+
+extern struct node_data __node_data[];
+
+#ifdef CONFIG_NUMA
+#define NODE_DATA(n)		(&__node_data[(n)].pglist)
+#endif
+
+#endif /* _ASM_MACH_CAVIUM_OCTEON_MMZONE_H */
+
diff --git a/arch/mips/include/asm/mach-cavium-octeon/topology.h b/arch/mips/include/asm/mach-cavium-octeon/topology.h
new file mode 100644
index 0000000..76a8c2a
--- /dev/null
+++ b/arch/mips/include/asm/mach-cavium-octeon/topology.h
@@ -0,0 +1,42 @@
+#ifndef _ASM_MACH_CAVIUM_OCTEON_TOPOLOGY_H
+#define _ASM_MACH_CAVIUM_OCTEON_TOPOLOGY_H
+
+#ifdef CONFIG_NUMA
+
+static inline int cpu_to_node(int cpu)
+{
+	return (cpu_logical_map(cpu) >> 7) & 7;
+}
+
+static inline struct cpumask *cpumask_of_node(int node)
+{
+	if (node == -1)
+		return cpu_all_mask;
+	return &__node_data[node].cpumask_on_node;
+}
+
+static inline int parent_node(int node)
+{
+	return node;
+}
+
+struct pci_bus;
+static inline int pcibus_to_node(struct pci_bus *bus)
+{
+	return 0;
+}
+
+static inline struct cpumask *cpumask_of_pcibus(struct pci_bus *bus)
+{
+	return cpumask_of_node(pcibus_to_node(bus));
+}
+#endif /* CONFIG_NUMA */
+
+static inline int pa_to_nid(u64 pa)
+{
+	return (pa >> 40) & 7;
+}
+
+#include <asm-generic/topology.h>
+
+#endif /* _ASM_MACH_CAVIUM_OCTEON_TOPOLOGY_H */
-- 
1.9.1

