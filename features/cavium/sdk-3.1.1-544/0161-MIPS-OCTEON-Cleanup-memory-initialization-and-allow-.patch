From df0eaa74b011616dc76cb9b99dbcb800eae7566a Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Tue, 30 Sep 2014 11:00:21 -0700
Subject: [PATCH 161/202] MIPS: OCTEON: Cleanup memory initialization and allow
 for more than 32GB.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.1-544]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/mips/cavium-octeon/setup.c | 51 +++++++++++++++++++----------------------
 1 file changed, 24 insertions(+), 27 deletions(-)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 8026052..4a91842 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -54,8 +54,7 @@
 
 #define SDK_VERSION "3.1.1"
 
-static unsigned long long MAX_MEMORY = 512ull << 20;
-static const unsigned long MIN_MEM_32 = 256 << 20;
+static u64 max_memory = 512ull << 20;
 
 /*
  * modified in hernel-entry-init.h, must have an initial value to keep
@@ -757,13 +756,13 @@ void __init prom_init(void)
 
 	/* Default to 64MB in the simulator to speed things up */
 	if (octeon_is_simulation())
-		MAX_MEMORY = 64ull << 20;
+		max_memory = 64ull << 20;
 
 	arg = strstr(arcs_cmdline, "mem=");
 	if (arg) {
-		MAX_MEMORY = memparse(arg + 4, &p);
-		if (MAX_MEMORY == 0)
-			MAX_MEMORY = 32ull << 30;
+		max_memory = memparse(arg + 4, &p);
+		if (max_memory == 0)
+			max_memory = 2ull << 49;
 		if (*p == '@')
 			RESERVE_LOW_MEM = memparse(p + 1, &p);
 	}
@@ -793,9 +792,9 @@ void __init prom_init(void)
 				pr_err("Named Block[%d] = \"%s\"\n", j, named_memory_blocks[j]);
 		} else if ((strncmp(arg, "MEM=", 4) == 0) ||
 		    (strncmp(arg, "mem=", 4) == 0)) {
-			MAX_MEMORY = memparse(arg + 4, &p);
-			if (MAX_MEMORY == 0)
-				MAX_MEMORY = 32ull << 30;
+			max_memory = memparse(arg + 4, &p);
+			if (max_memory == 0)
+				max_memory = 2ull << 49;
 			if (*p == '@')
 				RESERVE_LOW_MEM = memparse(p + 1, &p);
 		} else if (strncmp(arg, "rd_name=", 8) == 0) {
@@ -955,11 +954,13 @@ static __init void memory_exclude_page(u64 addr, u64 *mem, u64 *size)
 
 void __init plat_mem_setup(void)
 {
-	uint64_t mem_alloc_size;
-	uint64_t total = 0;
-	int64_t memory;
-	uint64_t limit_max, limit_min;
+	u64 mem_alloc_size = 4 << 20;
+	u64 mem_32_size;
+	u64 total = 0;
+	s64 memory;
+	u64 limit_max, limit_min;
 	const struct cvmx_bootmem_named_block_desc *named_block;
+	u64 system_limit = cvmx_bootmem_available_mem(mem_alloc_size);
 
 #ifdef CONFIG_BLK_DEV_INITRD
 	if (rd_name[0]) {
@@ -1001,24 +1002,20 @@ void __init plat_mem_setup(void)
 		goto mem_alloc_done;
 	}
 
-	/*
-	 * The Mips memory init uses the first memory location for
-	 * some memory vectors. When SPARSEMEM is in use, it doesn't
-	 * verify that the size is big enough for the final
-	 * vectors. Making the smallest chuck 4MB seems to be enough
-	 * to consistently work.
-	 */
-	mem_alloc_size = 4 << 20;
-	if (mem_alloc_size > MAX_MEMORY)
-		mem_alloc_size = MAX_MEMORY;
+	if (mem_alloc_size > max_memory)
+		mem_alloc_size = max_memory;
+
+	if (system_limit > max_memory)
+		system_limit = max_memory;
+	/* Try to get 256MB (or more) of 32-bit memory */
+	mem_32_size = system_limit <= (16ull * (2 << 30)) ? 256 * (1 << 20) : 512 * (1 << 20);
 
 	cvmx_bootmem_lock();
 	limit_max = 0xffffffffull;
 	limit_min = 0;
-	while ((boot_mem_map.nr_map < BOOT_MEM_MAP_MAX)
-		&& (total < MAX_MEMORY)) {
-		/* Try to get 256MB of 32-bit memory */
-		if (total >= 256 * (1<<20))
+	while ((boot_mem_map.nr_map < BOOT_MEM_MAP_MAX) && (total < max_memory)) {
+
+		if (total >= mem_32_size)
 			limit_max = ~0ull;		/* unlimitted */
 
 		memory = cvmx_bootmem_phy_alloc(mem_alloc_size,
-- 
1.8.2.1

