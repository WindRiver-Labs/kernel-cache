From 4745d91de71974aa49c12cf04f025a1d79259085 Mon Sep 17 00:00:00 2001
From: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Date: Fri, 13 Feb 2015 14:23:35 +0530
Subject: [PATCH 072/148] MIPS: Octeon: Revise memory allocation from
 bootloader

Commit caedb8a313b125d51b3d12135a71f44a0d563583 from
git://git.yoctoproject.org/linux-yocto-3.14

The heneric MIPS memory initialization does not allow free memory preceding
the kernel image itself, make sure all memory that is allocated from firmware
follows the kernel image. Cleanup the firmware memory allocation code for
clarity.

Signed-off-by: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Signed-off-by: Abhishek Paliwal <abhishek.paliwal@aricent.com>
---
 arch/mips/cavium-octeon/setup.c | 58 ++++++++++++++++++++---------------------
 1 file changed, 29 insertions(+), 29 deletions(-)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 55fbd3e..7c25d52 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -40,7 +40,6 @@
 #include <asm/perf_event.h>
 
 #include <asm/octeon/octeon.h>
-#include <asm/octeon/octeon-boot-info.h>
 #include <asm/octeon/pci-octeon.h>
 #include <asm/octeon/cvmx-mio-defs.h>
 #include <asm/octeon/cvmx-rst-defs.h>
@@ -367,16 +366,6 @@ int octeon_get_boot_uart(void)
 }
 
 /**
- * Get the coremask Linux was booted on.
- *
- * Returns Core mask
- */
-int octeon_get_boot_coremask(void)
-{
-	return octeon_boot_desc_ptr->core_mask;
-}
-
-/**
  * Check the hardware BIST results for a CPU
  */
 void octeon_check_cpu_bist(void)
@@ -397,8 +386,7 @@ void octeon_check_cpu_bist(void)
 	else
 		bist_val = read_octeon_c0_dcacheerr();
 	if (bist_val & 1)
-		pr_err("Core%d L1 Dcache parity error: "
-		       "CacheErr(dcache) = 0x%llx\n",
+		pr_err("Core%d L1 Dcache parity error: CacheErr(dcache) = 0x%llx\n",
 		       coreid, bist_val);
 
 	mask = 0xfc00000000000000ull;
@@ -803,7 +791,6 @@ void __init prom_init(void)
 		cvmx_write_csr(CVMX_LED_UDD_DATX(1), 0);
 		cvmx_write_csr(CVMX_LED_EN, 1);
 	}
-#ifdef CONFIG_CAVIUM_RESERVE32
 	/*
 	 * We need to temporarily allocate all memory in the reserve32
 	 * region. This makes sure the kernel doesn't allocate this
@@ -814,13 +801,18 @@ void __init prom_init(void)
 	 * Allocate memory for RESERVED32 aligned on 2MB boundary. This
 	 * is in case we later use hugetlb entries with it.
 	 */
-	addr = cvmx_bootmem_phy_named_block_alloc(CONFIG_CAVIUM_RESERVE32 << 20,
+#ifdef CONFIG_CAVIUM_RESERVE32
+	if (CONFIG_CAVIUM_RESERVE32 > 0) {
+		int64_t addr = -1;
+		addr = cvmx_bootmem_phy_named_block_alloc(
+						CONFIG_CAVIUM_RESERVE32 << 20,
 						0, 0, 2 << 20,
 						"CAVIUM_RESERVE32", 0);
-	if (addr < 0)
-		pr_err("Failed to allocate CAVIUM_RESERVE32 memory area\n");
-	else
-		octeon_reserve32_memory = addr;
+		if (addr < 0)
+			pr_err("Failed to allocate CAVIUM_RESERVE32 memory area\n");
+		else
+			octeon_reserve32_memory = addr;
+	}
 #endif
 	octeon_check_cpu_bist();
 
@@ -885,8 +877,7 @@ void __init prom_init(void)
 		} else if (strcmp(arg, "ecc_verbose") == 0) {
 #ifdef CONFIG_CAVIUM_REPORT_SINGLE_BIT_ECC
 			__cvmx_interrupt_ecc_report_single_bit_errors = 1;
-			pr_notice("Reporting of single bit ECC errors is "
-				  "turned on\n");
+			pr_notice("Reporting of single bit ECC errors is turned on\n");
 #endif
 #ifdef CONFIG_KEXEC
 		} else if (strncmp(arg, "crashkernel=", 12) == 0) {
@@ -1056,8 +1047,11 @@ static __init void memory_exclude_page(u64 addr, u64 *mem, u64 *size)
 
 void __init plat_mem_setup(void)
 {
-	uint64_t mem_alloc_size;
-	uint64_t total;
+	u64 mem_alloc_size = 4 << 20;
+	u64 mem_32_size;
+	u64 total = 0;
+	u64 limit_max, limit_min;
+	u64 system_limit = cvmx_bootmem_available_mem(mem_alloc_size);
 	uint64_t crashk_end;
 #ifndef CONFIG_CRASH_DUMP
 	int64_t memory;
@@ -1090,18 +1084,25 @@ void __init plat_mem_setup(void)
 		crashk_end = crashk_base + crashk_size;
 	}
 #endif
+
+	/* Try to get 256MB (or more) of 32-bit memory */
+	mem_32_size = system_limit <= (16ull * (2 << 30)) ? 256 * (1 << 20) : 512 * (1 << 20);
+
 	/*
 	 * When allocating memory, we want incrementing addresses from
 	 * bootmem_alloc so the code in add_memory_region can merge
 	 * regions next to each other.
 	 */
 	cvmx_bootmem_lock();
+	limit_max = 0xffffffffull;
+	limit_min = 0;
 	while ((boot_mem_map.nr_map < BOOT_MEM_MAP_MAX)
 		&& (total < MAX_MEMORY)) {
-		memory = cvmx_bootmem_phy_alloc(mem_alloc_size,
-						__pa_symbol(&__init_end), -1,
-						0x100000,
-						CVMX_BOOTMEM_FLAG_NO_LOCKING);
+			if (total >= mem_32_size)
+				limit_max = ~0ull;              /* unlimitted */
+			memory = cvmx_bootmem_phy_alloc(mem_alloc_size,
+				limit_min, limit_max, 0x100000,
+				CVMX_BOOTMEM_FLAG_NO_LOCKING);
 		if (memory >= 0) {
 			u64 size = mem_alloc_size;
 #ifdef CONFIG_KEXEC
@@ -1192,8 +1193,7 @@ void __init plat_mem_setup(void)
 #endif /* CONFIG_CAVIUM_RESERVE32 */
 
 	if (total == 0)
-		panic("Unable to allocate memory from "
-		      "cvmx_bootmem_phy_alloc");
+		panic("Unable to allocate memory from cvmx_bootmem_phy_alloc");
 }
 
 /*
-- 
1.8.2.1

