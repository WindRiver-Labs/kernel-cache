From 6b8c0fbdafa34fd1e91591f715b822679b81ea2f Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 13 Feb 2015 15:31:04 +0530
Subject: [PATCH 097/132] MIPS: OCTEON: Populate kernel memory from
 cvmx_bootmem named blocks.

Commit 7beb27929d85e9496606d778f4f6917e022bc202 from
git://git.yoctoproject.org/linux-yocto-3.14

Command line syntax is:

  mem=block:block_name1,block_name2,...

A maximum of 4 blocks are currently supported
Get rid of Kexec garbage.

MIPS/OCTEON: Initialize QLM JTAG.

MIPS: OCTEON: Export octeon_bootbus_sem.
Export the symbol so that eMMC driver can be built as module.

MIPS: OCTEON: Print warning message if OCTEON II kernel run on earlier chips.
If the kernel is configured with CONFIG_CAVIUM_OCTEON2, it will
contain machine instructions that cause ReservedInstruction exceptions
on earlier chips.  Print a nice warning message rather than crashing.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
Signed-off-by: Abhishek Paliwal <abhishek.paliwal@aricent.com>
[Original patch taken from OCTEON-SDK 3.1.1-544.]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/cavium-octeon/setup.c | 204 ++++++----------------------------------
 1 file changed, 30 insertions(+), 174 deletions(-)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 3bf4e85..69d943b 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -50,12 +50,11 @@
 #include <asm/octeon/cvmx-mio-defs.h>
 #include <asm/octeon/cvmx-rst-defs.h>
 #include <asm/octeon/cvmx-sso-defs.h>
+#include <asm/octeon/cvmx-qlm.h>
 #include <asm/octeon/cvmx-debug.h>
 
 #define SDK_VERSION "3.1.1"
 
-extern struct plat_smp_ops octeon_smp_ops;
-
 static u64 max_memory = 512ull << 20;
 
 DEFINE_SEMAPHORE(octeon_bootbus_sem);
@@ -88,63 +87,12 @@ static void octeon_kexec_smp_down(void *ignored)
 		cpu_relax();
 
 	asm volatile (
-	"	sync						\n"
-	"	synci	($0)					\n");
-
+	"       sync\n"
+	"       synci   ($0)\n");
 	relocated_kexec_smp_wait(NULL);
 }
 #endif
 
-#define OCTEON_DDR0_BASE    (0x0ULL)
-#define OCTEON_DDR0_SIZE    (0x010000000ULL)
-#define OCTEON_DDR1_BASE    (0x410000000ULL)
-#define OCTEON_DDR1_SIZE    (0x010000000ULL)
-#define OCTEON_DDR2_BASE    (0x020000000ULL)
-#define OCTEON_DDR2_SIZE    (0x3e0000000ULL)
-#define OCTEON_MAX_PHY_MEM_SIZE (16*1024*1024*1024ULL)
-
-static struct kimage *kimage_ptr;
-
-static void kexec_bootmem_init(uint64_t mem_size, uint32_t low_reserved_bytes)
-{
-	int64_t addr;
-	struct cvmx_bootmem_desc *bootmem_desc;
-
-	bootmem_desc = cvmx_bootmem_get_desc();
-
-	if (mem_size > OCTEON_MAX_PHY_MEM_SIZE) {
-		mem_size = OCTEON_MAX_PHY_MEM_SIZE;
-		pr_err("Error: requested memory too large,"
-		       "truncating to maximum size\n");
-	}
-
-	bootmem_desc->major_version = CVMX_BOOTMEM_DESC_MAJ_VER;
-	bootmem_desc->minor_version = CVMX_BOOTMEM_DESC_MIN_VER;
-
-	addr = (OCTEON_DDR0_BASE + RESERVE_LOW_MEM + low_reserved_bytes);
-	bootmem_desc->head_addr = 0;
-
-	if (mem_size <= OCTEON_DDR0_SIZE) {
-		__cvmx_bootmem_phy_free(addr,
-				mem_size - RESERVE_LOW_MEM -
-				low_reserved_bytes, 0);
-		return;
-	}
-
-	__cvmx_bootmem_phy_free(addr,
-			OCTEON_DDR0_SIZE - RESERVE_LOW_MEM -
-			low_reserved_bytes, 0);
-
-	mem_size -= OCTEON_DDR0_SIZE;
-
-	if (mem_size > OCTEON_DDR1_SIZE) {
-		__cvmx_bootmem_phy_free(OCTEON_DDR1_BASE, OCTEON_DDR1_SIZE, 0);
-		__cvmx_bootmem_phy_free(OCTEON_DDR2_BASE,
-				mem_size - OCTEON_DDR1_SIZE, 0);
-	} else
-		__cvmx_bootmem_phy_free(OCTEON_DDR1_BASE, mem_size, 0);
-}
-
 static int octeon_kexec_prepare(struct kimage *image)
 {
 	int i;
@@ -176,72 +124,23 @@ static int octeon_kexec_prepare(struct kimage *image)
 		}
 	}
 
-	/*
-	 * Information about segments will be needed during pre-boot memory
-	 * initialization.
-	 */
-	kimage_ptr = image;
 	return 0;
 }
 
 static void octeon_generic_shutdown(void)
 {
-	int i;
 #ifdef CONFIG_SMP
 	int cpu;
-#endif
-	struct cvmx_bootmem_desc *bootmem_desc;
-	void *named_block_array_ptr;
-
-	bootmem_desc = cvmx_bootmem_get_desc();
-	named_block_array_ptr =
-		cvmx_phys_to_ptr(bootmem_desc->named_block_array_addr);
-
-#ifdef CONFIG_SMP
+	secondary_kexec_args[2] = 0UL; /* running on secondary cpu */
+	secondary_kexec_args[3] = (unsigned long)octeon_boot_desc_ptr;
 	/* disable watchdogs */
 	for_each_online_cpu(cpu)
 		cvmx_write_csr(CVMX_CIU_WDOGX(cpu_logical_map(cpu)), 0);
 #else
 	cvmx_write_csr(CVMX_CIU_WDOGX(cvmx_get_core_num()), 0);
 #endif
-	if (kimage_ptr != kexec_crash_image) {
-		memset(named_block_array_ptr,
-			0x0,
-			CVMX_BOOTMEM_NUM_NAMED_BLOCKS *
-			sizeof(struct cvmx_bootmem_named_block_desc));
-		/*
-		 * Mark all memory (except low 0x100000 bytes) as free.
-		 * It is the same thing that bootloader does.
-		 */
-		kexec_bootmem_init(octeon_bootinfo->dram_size*1024ULL*1024ULL,
-				0x100000);
-		/*
-		 * Allocate all segments to avoid their corruption during boot.
-		 */
-		for (i = 0; i < kimage_ptr->nr_segments; i++)
-			cvmx_bootmem_alloc_address(
-				kimage_ptr->segment[i].memsz + 2*PAGE_SIZE,
-				kimage_ptr->segment[i].mem - PAGE_SIZE,
-				PAGE_SIZE);
-	} else {
-		/*
-		 * Do not mark all memory as free. Free only named sections
-		 * leaving the rest of memory unchanged.
-		 */
-		struct cvmx_bootmem_named_block_desc *ptr =
-			(struct cvmx_bootmem_named_block_desc *)
-			named_block_array_ptr;
-
-		for (i = 0; i < bootmem_desc->named_block_num_blocks; i++)
-			if (ptr[i].size)
-				cvmx_bootmem_free_named(ptr[i].name);
-	}
 	kexec_args[2] = 1UL; /* running on octeon_main_processor */
 	kexec_args[3] = (unsigned long)octeon_boot_desc_ptr;
-#ifdef CONFIG_SMP
-	secondary_kexec_args[2] = 0UL; /* running on secondary cpu */
-	secondary_kexec_args[3] = (unsigned long)octeon_boot_desc_ptr;
-#endif
 }
 
 static void octeon_shutdown(void)
@@ -266,7 +165,7 @@ static void octeon_crash_shutdown(struct pt_regs *regs)
 #endif /* CONFIG_KEXEC */
 
 #ifndef CONFIG_CAVIUM_RESERVE32
-#define  CONFIG_CAVIUM_RESERVE32        0ULL
+#define         CONFIG_CAVIUM_RESERVE32        0ULL
 #endif
 
 uint64_t octeon_reserve32_memory;
@@ -437,8 +336,8 @@ static void octeon_restart(char *command)
 static void octeon_kill_core(void *arg)
 {
 	if (octeon_is_simulation()) {
-			/* The simulator needs the watchdog to stop for dead cores */
-			cvmx_write_csr(CVMX_CIU_WDOGX(cvmx_get_core_num()), 0);
+		/* The simulator needs the watchdog to stop for dead cores */
+		cvmx_write_csr(CVMX_CIU_WDOGX(cvmx_get_core_num()), 0);
 		/* A break instruction causes the simulator stop a core */
 		asm volatile ("break" ::: "memory");
 	}
@@ -560,6 +459,7 @@ void octeon_user_io_init(void)
 	 * between 1x and 2x this interval. For example, with
 	 * DIDTTO=3, expiration interval is between 16K and 32K. */
 	cvmmemctl.s.didtto = 0;
+	cvmmemctl.s.didtto2 = 0;
 	/* R/W If set, the (mem) CSR clock never turns off. */
 	cvmmemctl.s.csrckalwys = 0;
 	/* R/W If set, mclk never turns off. */
@@ -685,8 +585,7 @@ void __init prom_init(void)
 	 * $a3, this is available as fw_arg3.
 	 */
 	octeon_boot_desc_ptr = (struct octeon_boot_descriptor *)fw_arg3;
-	octeon_bootinfo =
-		cvmx_phys_to_ptr(octeon_boot_desc_ptr->cvmx_desc_vaddr);
+	octeon_bootinfo = phys_to_virt(octeon_boot_desc_ptr->cvmx_desc_vaddr);
 	cvmx_bootmem_init(octeon_bootinfo->phy_mem_desc_addr);
 
 	sysinfo = cvmx_sysinfo_get();
@@ -811,9 +710,9 @@ void __init prom_init(void)
 	if (CONFIG_CAVIUM_RESERVE32 > 0) {
 		int64_t addr = -1;
 		addr = cvmx_bootmem_phy_named_block_alloc(
-						CONFIG_CAVIUM_RESERVE32 << 20,
-						0, 0, 2 << 20,
-						"CAVIUM_RESERVE32", 0);
+			CONFIG_CAVIUM_RESERVE32 << 20,
+			0, 0, 2 << 20,
+			"CAVIUM_RESERVE32", 0);
 		if (addr < 0)
 			pr_err("Failed to allocate CAVIUM_RESERVE32 memory area\n");
 		else
@@ -859,7 +758,7 @@ void __init prom_init(void)
 	arcs_cmdline[0] = 0;
 	argc = octeon_boot_desc_ptr->argc;
 	for (i = 0; i < argc; i++) {
-		const char *arg =phys_to_virt(octeon_boot_desc_ptr->argv[i]);
+		const char *arg = phys_to_virt(octeon_boot_desc_ptr->argv[i]);
 		if (strncmp(arg, "mem=block:", 10) == 0) {
 			const char *pos = arg + 10;
 			int j;
@@ -879,7 +778,7 @@ void __init prom_init(void)
 			}
 			for (j = 0; j < ARRAY_SIZE(named_memory_blocks); j++)
 				pr_err("Named Block[%d] = \"%s\"\n", j, named_memory_blocks[j]);
-		}else if ((strncmp(arg, "MEM=", 4) == 0) ||
+		} else if ((strncmp(arg, "MEM=", 4) == 0) ||
 		    (strncmp(arg, "mem=", 4) == 0)) {
 			max_memory = memparse(arg + 4, &p);
 			if (max_memory == 0)
@@ -892,8 +791,7 @@ void __init prom_init(void)
 			goto append_arg;
 		} else {
 append_arg:
-			if (strlen(arcs_cmdline) + strlen(arg) + 1 <
-				sizeof(arcs_cmdline) - 1) {
+			if (strlen(arcs_cmdline) + strlen(arg) + 1 < sizeof(arcs_cmdline) - 1) {
 				strcat(arcs_cmdline, " ");
 				strcat(arcs_cmdline, arg);
 			}
@@ -1042,8 +940,8 @@ void __init plat_mem_setup(void)
 	u64 total = 0;
 	s64 memory;
 	u64 limit_max, limit_min;
-	u64 system_limit = cvmx_bootmem_available_mem(mem_alloc_size);
 	const struct cvmx_bootmem_named_block_desc *named_block;
+	u64 system_limit = cvmx_bootmem_available_mem(mem_alloc_size);
 
 #ifdef CONFIG_BLK_DEV_INITRD
 	if (rd_name[0]) {
@@ -1116,11 +1014,6 @@ void __init plat_mem_setup(void)
 	/* Try to get 256MB (or more) of 32-bit memory */
 	mem_32_size = system_limit <= (16ull * (2 << 30)) ? 256 * (1 << 20) : 512 * (1 << 20);
 
-	/*
-	 * When allocating memory, we want incrementing addresses from
-	 * bootmem_alloc so the code in add_memory_region can merge
-	 * regions next to each other.
-	 */
 	cvmx_bootmem_lock();
 	limit_max = 0xffffffffull;
 	limit_min = 0;
@@ -1132,14 +1025,10 @@ void __init plat_mem_setup(void)
 				CVMX_BOOTMEM_FLAG_NO_LOCKING);
 		if (memory >= 0) {
 			u64 size = mem_alloc_size;
-#ifdef CONFIG_KEXEC
-			uint64_t end;
-#endif
-
 			/*
-			 * exclude a page at the beginning and end of
-			 * the 256MB PCIe 'hole' so the kernel will not
-			 * try to allocate multi-page buffers that
+			 * This function automatically merges address
+			 * regions next to each other if they are
+			 * received in incrementing order.
 			 * span the discontinuity.
 			 */
 			memory_exclude_page(CVMX_PCIE_BAR1_PHYS_BASE,
@@ -1147,56 +1036,20 @@ void __init plat_mem_setup(void)
 			memory_exclude_page(CVMX_PCIE_BAR1_PHYS_BASE +
 					    CVMX_PCIE_BAR1_PHYS_SIZE,
 					    &memory, &size);
-#ifdef CONFIG_KEXEC
-			end = memory + mem_alloc_size;
 
 			/*
 			 * This function automatically merges address regions
 			 * next to each other if they are received in
 			 * incrementing order
 			 */
-			if (memory < crashk_base && end >  crashk_end) {
-				/* region is fully in */
-				add_memory_region(memory,
-						  crashk_base - memory,
-						  BOOT_MEM_RAM);
-				total += crashk_base - memory;
-				add_memory_region(crashk_end,
-						  end - crashk_end,
-						  BOOT_MEM_RAM);
-				total += end - crashk_end;
-				continue;
-			}
-
-			if (memory >= crashk_base && end <= crashk_end)
-				/*
-				 * Entire memory region is within the new
-				 *  kernel's memory, ignore it.
-				 */
-				continue;
-
-			if (memory > crashk_base && memory < crashk_end &&
-			    end > crashk_end) {
-				/*
-				 * Overlap with the beginning of the region,
-				 * reserve the beginning.
-				  */
-				mem_alloc_size -= crashk_end - memory;
-				memory = crashk_end;
-			} else if (memory < crashk_base && end > crashk_base &&
-				   end < crashk_end)
-				/*
-				 * Overlap with the beginning of the region,
-				 * chop of end.
-				 */
-				mem_alloc_size -= end - crashk_base;
-#endif
-			add_memory_region(memory, mem_alloc_size, BOOT_MEM_RAM);
+		if (size)
+			add_memory_region(memory, size, BOOT_MEM_RAM);
 			total += mem_alloc_size;
-			/* Recovering mem_alloc_size */
-			mem_alloc_size = 4 << 20;
 		} else {
-			break;
+			if (limit_max < ~0ull)
+				limit_max = ~0ull;              /* unlimitted */
+			else
+				break;
 		}
 	}
 	cvmx_bootmem_unlock();
@@ -1212,7 +1065,10 @@ mem_alloc_done:
 		cvmx_bootmem_free_named("CAVIUM_RESERVE32");
 
 	if (total == 0)
-		panic("Unable to allocate memory from cvmx_bootmem_phy_alloc");
+		panic("Unable to allocate memory from cvmx_bootmem_phy_alloc\n");
+
+	/* Initialize QLM and also apply any erratas */
+	cvmx_qlm_init();
 }
 
 struct node_data __node_data[4];
-- 
1.9.1

