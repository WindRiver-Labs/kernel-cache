From 5a4e6a27515ee5ba1347f9b81707e670c21015d2 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 13 Feb 2015 15:29:53 +0530
Subject: [PATCH 123/148] MIPS: OCTEON: Add ability to used an initrd from a
 named memory block.

Commit 96cbe13a73517db1dbe9b0412e43eae55e85a86a from
git://git.yoctoproject.org/linux-yocto-3.14

If 'rd_name=xxx' is passed to the kernel, the named block with name
'xxx' is used for the initrd.

Remove obsolete crashkernel= argument handling
 Cleanup RESERVE32 memory allocation
Re-apply user-level direct physical memory and I/O access configuration

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Signed-off-by: Abhishek Paliwal <abhishek.paliwal@aricent.com>
---
 arch/mips/cavium-octeon/Kconfig  |  3 --
 arch/mips/cavium-octeon/setup.c  | 76 +++++++++++++++++++++++-----------------
 arch/mips/include/asm/bootinfo.h |  1 +
 arch/mips/kernel/setup.c         | 22 +++++++++---
 4 files changed, 62 insertions(+), 40 deletions(-)

diff --git a/arch/mips/cavium-octeon/Kconfig b/arch/mips/cavium-octeon/Kconfig
index d197fa8..f8bd10b 100644
--- a/arch/mips/cavium-octeon/Kconfig
+++ b/arch/mips/cavium-octeon/Kconfig
@@ -253,7 +253,4 @@ config OCTEON_ERROR_INJECTOR
 	  Used to test hardware error reporting.  Should never be used
 	  in a normal running system.
 
-# To be enabled later
-# source "arch/mips/cavium-octeon/executive/Kconfig"
-
 endif #CAVIUM_OCTEON_SOC
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index e5cae27..3eeca54 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -28,6 +28,7 @@
 #include <linux/of_fdt.h>
 #include <linux/libfdt.h>
 #include <linux/kexec.h>
+#include <linux/initrd.h>
 
 #include <linux/bootmem.h>
 #include <linux/memblock.h>
@@ -269,17 +270,14 @@ static void octeon_crash_shutdown(struct pt_regs *regs)
 uint64_t octeon_reserve32_memory;
 EXPORT_SYMBOL(octeon_reserve32_memory);
 
-#ifdef CONFIG_KEXEC
-/* crashkernel cmdline parameter is parsed _after_ memory setup
- * we also parse it here (workaround for EHB5200) */
-static uint64_t crashk_size, crashk_base;
-#endif
-
 static int octeon_uart;
 
 extern asmlinkage void handle_int(void);
 extern asmlinkage void plat_irq_dispatch(void);
 
+/* If an initrd named block is specified, its name goes here. */
+static char __initdata rd_name[64];
+
 /* Up to four blocks may be specified. */
 static char __initdata named_memory_blocks[4][CVMX_BOOTMEM_NAME_LEN];
 
@@ -437,10 +435,12 @@ static void octeon_restart(char *command)
  */
 static void octeon_kill_core(void *arg)
 {
-	if (octeon_is_simulation())
+	if (octeon_is_simulation()) {
+			/* The simulator needs the watchdog to stop for dead cores */
+			cvmx_write_csr(CVMX_CIU_WDOGX(cvmx_get_core_num()), 0);
 		/* A break instruction causes the simulator stop a core */
 		asm volatile ("break" ::: "memory");
-
+	}
 	local_irq_disable();
 	/* Disable watchdog on this core. */
 	cvmx_write_csr(CVMX_CIU_WDOGX(cvmx_get_core_num()), 0);
@@ -531,16 +531,22 @@ void octeon_user_io_init(void)
 
 	/* R/W If set (and UX set), user-level loads/stores can use
 	 * XKPHYS addresses with VA<48>==0 */
+#ifdef CONFIG_CAVIUM_OCTEON_USER_MEM
+	cvmmemctl.s.xkmemenau = 1;
+#else
 	cvmmemctl.s.xkmemenau = 0;
-
+#endif
 	/* R/W If set (and SX set), supervisor-level loads/stores can
 	 * use XKPHYS addresses with VA<48>==1 */
 	cvmmemctl.s.xkioenas = 0;
 
 	/* R/W If set (and UX set), user-level loads/stores can use
 	 * XKPHYS addresses with VA<48>==1 */
+#ifdef CONFIG_CAVIUM_OCTEON_USER_IO
+	cvmmemctl.s.xkioenau = 1;
+#else
 	cvmmemctl.s.xkioenau = 0;
-
+#endif
 	/* R/W If set, all stores act as SYNCW (NOMERGE must be set
 	 * when this is set) RW, reset to 0. */
 	cvmmemctl.s.allsyncw = 0;
@@ -798,7 +804,7 @@ void __init prom_init(void)
 	 * bootloader. Later, after the memory allocations are
 	 * complete, the reserve32 will be freed.
 	 *
-	 * Allocate memory for RESERVED32 aligned on 2MB boundary. This
+	 * Allocate memory for RESERVE32 aligned on 2MB boundary. This
 	 * is in case we later use hugetlb entries with it.
 	 */
 	if (CONFIG_CAVIUM_RESERVE32 > 0) {
@@ -879,31 +885,25 @@ void __init prom_init(void)
 				max_memory = 2ull << 49;
 			if (*p == '@')
 				RESERVE_LOW_MEM = memparse(p + 1, &p);
+		} else if (strncmp(arg, "rd_name=", 8) == 0) {
+			strncpy(rd_name, arg + 8, sizeof(rd_name));
+			rd_name[sizeof(rd_name) - 1] = 0;
+			goto append_arg;
 		} else if (strcmp(arg, "ecc_verbose") == 0) {
 #ifdef CONFIG_CAVIUM_REPORT_SINGLE_BIT_ECC
 			__cvmx_interrupt_ecc_report_single_bit_errors = 1;
 			pr_notice("Reporting of single bit ECC errors is turned on\n");
 #endif
-#ifdef CONFIG_KEXEC
-		} else if (strncmp(arg, "crashkernel=", 12) == 0) {
-			crashk_size = memparse(arg+12, &p);
-			if (*p == '@')
-				crashk_base = memparse(p+1, &p);
-			strcat(arcs_cmdline, " ");
-			strcat(arcs_cmdline, arg);
-			/*
-			 * To do: switch parsing to new style, something like:
-			 * parse_crashkernel(arg, sysinfo->system_dram_size,
-			 *		  &crashk_size, &crashk_base);
-			 */
-#endif
-		} else if (strlen(arcs_cmdline) + strlen(arg) + 1 <
-			   sizeof(arcs_cmdline) - 1) {
-			strcat(arcs_cmdline, " ");
-			strcat(arcs_cmdline, arg);
+			goto append_arg;
+		} else {
+append_arg:
+			if (strlen(arcs_cmdline) + strlen(arg) + 1 <
+				sizeof(arcs_cmdline) - 1) {
+				strcat(arcs_cmdline, " ");
+				strcat(arcs_cmdline, arg);
+			}
 		}
 	}
-
 	if (strstr(arcs_cmdline, "console=pci"))
 		octeon_pci_console_init(strstr(arcs_cmdline, "console=pci") + 8);
 
@@ -1047,11 +1047,23 @@ void __init plat_mem_setup(void)
 	s64 memory;
 	u64 limit_max, limit_min;
 	u64 system_limit = cvmx_bootmem_available_mem(mem_alloc_size);
-	uint64_t crashk_end;
 	const struct cvmx_bootmem_named_block_desc *named_block;
 
-	total = 0;
-	crashk_end = 0;
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (rd_name[0]) {
+		const struct cvmx_bootmem_named_block_desc *initrd_block;
+
+		initrd_block = cvmx_bootmem_find_named_block(rd_name);
+		if (initrd_block != NULL) {
+			initrd_start = initrd_block->base_addr + PAGE_OFFSET;
+			initrd_end = initrd_start + initrd_block->size;
+			add_memory_region(initrd_block->base_addr, initrd_block->size,
+					BOOT_MEM_INIT_RAM);
+			initrd_in_reserved = 1;
+			total += initrd_block->size;
+		}
+	}
+#endif
         if (named_memory_blocks[0][0]) {
                 phys_t kernel_begin, kernel_end;
                 phys_t block_begin, block_size;
diff --git a/arch/mips/include/asm/bootinfo.h b/arch/mips/include/asm/bootinfo.h
index 7808a50..42f881f 100644
--- a/arch/mips/include/asm/bootinfo.h
+++ b/arch/mips/include/asm/bootinfo.h
@@ -103,6 +103,7 @@ struct boot_mem_map {
 };
 
 extern struct boot_mem_map boot_mem_map;
+extern bool initrd_in_reserved;
 
 extern void add_memory_region(phys_t start, phys_t size, long type);
 extern void detect_memory_region(phys_t start, phys_t sz_min,  phys_t sz_max);
diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index fee7d88..e7660a9 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -63,6 +63,7 @@ unsigned long mips_machtype __read_mostly = MACH_UNKNOWN;
 EXPORT_SYMBOL(mips_machtype);
 
 struct boot_mem_map boot_mem_map;
+bool initrd_in_reserved;
 
 static char __initdata command_line[COMMAND_LINE_SIZE];
 char __initdata arcs_cmdline[COMMAND_LINE_SIZE];
@@ -316,8 +317,13 @@ static void __init bootmem_init(void)
 	 * as our memory range starting point. Once bootmem is inited we
 	 * will reserve the area used for the initrd.
 	 */
-	init_initrd();
-	reserved_end = (unsigned long) PFN_UP(__pa_symbol(&_end));
+	if (initrd_in_reserved) {
+		init_initrd();
+		reserved_end = PFN_UP(__pa_symbol(&_end));
+	} else {
+		reserved_end = max_t(unsigned long, init_initrd(),
+				     PFN_UP(__pa_symbol(&_end)));
+	}
 
 	/*
 	 * max_low_pfn is not a number of pages. The number of pages
@@ -332,8 +338,14 @@ static void __init bootmem_init(void)
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
 		unsigned long start, end;
 
-		if (boot_mem_map.map[i].type != BOOT_MEM_RAM)
+		switch (boot_mem_map.map[i].type) {
+		case BOOT_MEM_RAM:
+		case BOOT_MEM_INIT_RAM:
+			break;
+		default:
+			/* Not usable memory */
 			continue;
+		}
 
 		start = PFN_UP(boot_mem_map.map[i].addr);
 		end = PFN_DOWN(boot_mem_map.map[i].addr
@@ -609,7 +621,6 @@ static void __init request_crashkernel(struct resource *res)
 			(unsigned long)(crashk_res.start  >> 20));
 }
 #else /* !defined(CONFIG_KEXEC)		*/
-
 static void __init request_crashkernel(struct resource *res)
 {
 }
@@ -731,6 +742,7 @@ static void __init resource_init(void)
 		case BOOT_MEM_RAM:
 		case BOOT_MEM_INIT_RAM:
 		case BOOT_MEM_ROM_DATA:
+		case BOOT_MEM_KERNEL:
 			/* Try to merge on next piece, they are sorted. */
 			while (i + 1 < boot_mem_map.nr_map &&
 			    boot_mem_map.map[i + 1].addr == end + 1) {
@@ -747,7 +759,7 @@ static void __init resource_init(void)
 				default:
 					goto no_merge;
 				}
-		}
+			}
 no_merge:
 			res->name = "System RAM";
 			break;
-- 
1.8.2.1

