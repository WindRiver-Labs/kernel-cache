From 98d0d7955072c2f884ca81d0364750aeccc46004 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 13 Feb 2015 14:54:31 +0530
Subject: [PATCH 074/132] RapidIO: Add interface to memory map rapidio device
 memory.

Commit a487216738166f2a828e72be31af6f9161c3eb33 from
git://git.yoctoproject.org/linux-yocto-3.14

The rapidio system needs a standard interface to allow drivers access
to memory mapped addresses on devices. Add a map/unamp calls to
create kernel pointers for accessing this remote memory.

Add driver Serial Rapid I/O (sRIO)hardware

RapidIO: Driver for CN6XXX, Use DMA for large memory
transfers, Initialize the spin lock.

RapidIO: Set the MTU correctly and pad small packets to 64 bytes,
Added little endian support, Check skb headroom before
pushing data.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Chad Reese <kreese@caviumnetworks.com>
Signed-off-by: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Signed-off-by: Carlos Munoz <carlos.munoz@caviumnetworks.com>
Signed-off-by: Abhishek Paliwal <abhishek.paliwal@aricent.com>
[Original patch taken from OCTEON-SDK 3.1.1-544.]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/ethernet/octeon/Makefile        |  12 +-
 drivers/net/ethernet/octeon/ethernet-srio.c | 282 ++++++++++++++++++++++++++++
 drivers/rapidio/devices/Kconfig             |   8 +
 drivers/rapidio/devices/Makefile            |   1 +
 drivers/rapidio/devices/cn6xxx.c            | 277 +++++++++++++++++++++++++++
 drivers/rapidio/rio-sysfs.c                 | 101 ++++++++++
 drivers/rapidio/rio.c                       |  45 +++++
 include/linux/rio.h                         |   7 +
 include/linux/rio_drv.h                     |   3 +
 9 files changed, 731 insertions(+), 5 deletions(-)
 create mode 100644 drivers/net/ethernet/octeon/ethernet-srio.c
 create mode 100644 drivers/rapidio/devices/cn6xxx.c

diff --git a/drivers/net/ethernet/octeon/Makefile b/drivers/net/ethernet/octeon/Makefile
index df1bb419..215c0d9 100644
--- a/drivers/net/ethernet/octeon/Makefile
+++ b/drivers/net/ethernet/octeon/Makefile
@@ -1,13 +1,13 @@
 #
 # Makefile for the Cavium network device drivers.
 #
-
-obj-$(CONFIG_OCTEON3_ETHERNET)          += octeon3-ethernet.o
+obj-$(CONFIG_OCTEON_BGX_PORT)		+= octeon-bgx-port.o
+obj-$(CONFIG_OCTEON_BGX_NEXUS)		+= octeon-bgx-nexus.o
+obj-$(CONFIG_OCTEON3_ETHERNET)		+= octeon3-ethernet.o
 obj-$(CONFIG_OCTEON_MGMT_ETHERNET)	+= octeon_mgmt.o
-obj-$(CONFIG_OCTEON_POW_ONLY_ETHERNET)  += octeon-pow-ethernet.o
+obj-$(CONFIG_OCTEON_POW_ONLY_ETHERNET)	+= octeon-pow-ethernet.o
 obj-$(CONFIG_OCTEON_ETHERNET) +=  octeon-ethernet.o
 obj-$(CONFIG_OCTEON_ETHERNET_MEM) += ethernet-mem.o
-obj-$(CONFIG_OCTEON_ETHERNET_MEM) += ethernet-mem.o
 obj-$(CONFIG_OCTEON_ETHERNET_COMMON) += octeon_common.o
 
 octeon-ethernet-objs := ethernet.o
@@ -17,5 +17,7 @@ octeon-ethernet-objs += ethernet-rx.o
 octeon-ethernet-objs += ethernet-sgmii.o
 octeon-ethernet-objs += ethernet-spi.o
 octeon-ethernet-objs += ethernet-tx.o
-
+ifdef CONFIG_RAPIDIO
+octeon-ethernet-objs += ethernet-srio.o
+endif
 
diff --git a/drivers/net/ethernet/octeon/ethernet-srio.c b/drivers/net/ethernet/octeon/ethernet-srio.c
new file mode 100644
index 0000000..52000c1
--- /dev/null
+++ b/drivers/net/ethernet/octeon/ethernet-srio.c
@@ -0,0 +1,282 @@
+/*************************************************************************
+ *
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2010 - 2012 Cavium, Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium, Inc. for more information
+ *************************************************************************/
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <net/dst.h>
+#include <net/sock.h>
+#include <linux/rio.h>
+#include <linux/rio_drv.h>
+#include <linux/rio_ids.h>
+#include <linux/if_vlan.h>
+
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-srio.h>
+#include <asm/octeon/cvmx-pip-defs.h>
+#include <asm/octeon/cvmx-sriox-defs.h>
+#include <asm/octeon/cvmx-sriomaintx-defs.h>
+
+#include "ethernet-defines.h"
+#include "octeon-ethernet.h"
+
+/* SRIO packets' length must be a multiple of 8 */
+#define SRIO_PAD		8
+
+/* SRIO header length */
+#define SRIO_HDR_LEN		8
+
+struct net_device_stats *cvm_oct_srio_get_stats(struct net_device *dev)
+{
+	return &dev->stats;
+}
+
+int cvm_oct_srio_set_mac_address(struct net_device *dev, void *addr)
+{
+	/* FIXME: Should this be allowed? Should it change our device ID? */
+	memcpy(dev->dev_addr, addr + 2, 6);
+	return 0;
+}
+
+int cvm_oct_srio_change_mtu(struct net_device *dev, int new_mtu)
+{
+	union cvmx_pip_frm_len_chkx pip_frm_len_chkx;
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	int vlan_bytes = VLAN_HLEN;
+#else
+	int vlan_bytes = 0;
+#endif
+	unsigned int max_mtu;
+
+	/*
+	 * Limit the MTU to make sure the ethernet packets are between
+	 * 68 bytes and 4096. The MTU does not include the following:
+	 *	SRIO header
+	 *	Ethernet header
+	 *	VLAN tags (optional)
+	 *	SRIO padding
+	 *	FCS
+	 *
+	 * Note: we could use "SRIO_PAD - 1" in this calculation, but that would
+	 * make the MTU and odd number, which doesn't look right to me.
+	 */
+	max_mtu = RIO_MAX_MSG_SIZE - SRIO_HDR_LEN - ETH_HLEN - vlan_bytes - 
+		SRIO_PAD - ETH_FCS_LEN;
+	if ((new_mtu < 68) || (new_mtu > max_mtu)) {
+		netdev_warn(dev, "MTU must be between %d and %d.\n",
+			    68, max_mtu);
+		return -EINVAL;
+	}
+	dev->mtu = new_mtu;
+
+	/* set up pip. other interfaces prefer to disable the pip check. */
+	pip_frm_len_chkx.u64 = cvmx_read_csr(CVMX_PIP_FRM_LEN_CHKX(0));
+	pip_frm_len_chkx.s.maxlen = (new_mtu + 256) & ~0xff;
+	cvmx_write_csr(CVMX_PIP_FRM_LEN_CHKX(0), pip_frm_len_chkx.u64);
+
+	return 0;
+}
+
+int cvm_oct_xmit_srio(struct sk_buff *skb, struct net_device *dev)
+{
+	struct octeon_ethernet *priv = netdev_priv(dev);
+	union cvmx_srio_tx_message_header tx_header;
+	u64 dest_mac;
+
+	if (unlikely(skb->len > 4096)) {
+		dev_kfree_skb(skb);
+		netdev_dbg(dev, "TX packet larger than 4096 bytes. Dropped.\n");
+		return 0;
+	}
+
+	/*
+	 * Since we are emulating ethernet over srio, small packets must be
+	 * padded or the receiver will discard them for being too short.
+	 */
+	if (unlikely(skb->len < 64)) {
+		if (likely(skb_tailroom(skb) >= 64 - skb->len)) {
+			skb_put(skb, 64 - skb->len);
+		}
+	}
+
+	/* srio message length needs to be a multiple of 8 */
+	if (skb->len & (SRIO_PAD - 1)) {
+		if (likely(skb_tailroom(skb) > SRIO_PAD - 1))
+			skb_put(skb, SRIO_PAD - (skb->len & (SRIO_PAD - 1)));
+	}
+
+	tx_header.u64 = priv->srio_tx_header;
+	/* Use the socket priority if it is available */
+	if (skb->sk) {
+		if (skb->sk->sk_priority < 0)
+			tx_header.s.prio = 0;
+		else if (skb->sk->sk_priority > 3)
+			tx_header.s.prio = 3;
+		else
+			tx_header.s.prio = skb->sk->sk_priority;
+	}
+
+	/* Extract the destination MAC address from the packet */
+	dest_mac = cpu_to_be64(*(u64 *)skb->data >> 16);
+
+	/* If this is a broadcast/multicast we must manually send to everyone */
+	if (dest_mac>>40) {
+		struct list_head *pos;
+		struct sk_buff *new_skb;
+
+		list_for_each(pos, &priv->srio_bcast) {
+			struct octeon_ethernet_srio_bcast_target *t;
+
+			t = container_of(pos, struct octeon_ethernet_srio_bcast_target, list);
+			/* Create a new SKB since each packet will have different data */
+			if (skb_headroom(skb) < 8) {
+				new_skb = skb_realloc_headroom(skb,
+					8 - skb_headroom(skb));
+			}
+			else
+				new_skb = skb_copy(skb, GFP_ATOMIC);
+
+			if (new_skb) {
+				tx_header.s.did = t->destid;
+				*(u64 *)__skb_push(new_skb, 8) = cpu_to_be64(tx_header.u64);
+				cvm_oct_xmit(new_skb, dev);
+			} else {
+				netdev_dbg(dev, "SKB allocation failed\n");
+				break;
+			}
+		}
+
+		dev->stats.tx_packets++;
+		dev->stats.tx_bytes += skb->len;
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	} else {
+		/* Use the low two bytes of the destination MAC as the SRIO
+		 * destination */
+		/* tx_header.s.did = *(u16 *)(skb->data + 4); */
+		tx_header.s.did = *(u8 *)(skb->data + 5);
+		if (unlikely(skb_headroom(skb) < 8)) {
+			int	nhead = 8 - skb_headroom(skb);
+
+			if (pskb_expand_head(skb, nhead, 0, GFP_ATOMIC)) {
+				netdev_dbg(dev,
+					   "SKB didn't have room for SRIO "
+					   "header and allocation failed\n");
+				return NETDEV_TX_OK;
+			}
+		}
+
+		dev->stats.tx_packets++;
+		dev->stats.tx_bytes += skb->len;
+		*(u64 *)__skb_push(skb, 8) = cpu_to_be64(tx_header.u64);
+		return cvm_oct_xmit(skb, dev);
+	}
+}
+
+int cvm_oct_srio_init(struct net_device *dev)
+{
+	struct octeon_ethernet *priv = netdev_priv(dev);
+	int srio_port = (priv->ipd_port - 40) >> 1;
+	union cvmx_sriox_status_reg srio_status_reg;
+
+	dev->features |= NETIF_F_LLTX; /* We do our own locking, Linux doesn't need to */
+
+	SET_ETHTOOL_OPS(dev, &cvm_oct_ethtool_ops);
+
+	/* Make sure register access is allowed */
+	srio_status_reg.u64 = cvmx_read_csr(CVMX_SRIOX_STATUS_REG(srio_port));
+	if (!srio_status_reg.s.access)
+		return 0;
+
+	netif_carrier_on(dev);
+
+	dev->netdev_ops->ndo_change_mtu(dev, dev->mtu);
+
+	return 0;
+}
+
+int cvm_oct_srio_open(struct net_device *dev)
+{
+	struct octeon_ethernet *priv = netdev_priv(dev);
+	int srio_port = (priv->ipd_port - 40) >> 1;
+	struct rio_dev *rdev;
+	struct sockaddr sa;
+	u32 devid;
+
+	cvmx_srio_config_read32(srio_port, 0, -1, 1, 0, CVMX_SRIOMAINTX_PRI_DEV_ID(srio_port), &devid);
+
+	sa.sa_data[0] = 0;
+	sa.sa_data[1] = 0;
+	sa.sa_data[2] = 0;
+	sa.sa_data[3] = 0;
+	if (devid >> 16) {
+		sa.sa_data[4] = 0;
+		sa.sa_data[5] = (devid >> 16) & 0xff;
+	} else {
+		sa.sa_data[4] = (devid >> 8) & 0xff;
+		sa.sa_data[5] = devid & 0xff;
+	}
+
+	dev->netdev_ops->ndo_set_mac_address(dev, &sa);
+
+	rdev = NULL;
+	for (;;) {
+		struct octeon_ethernet_srio_bcast_target *target;
+		rdev = rio_get_device(RIO_ANY_ID, RIO_ANY_ID, rdev);
+		if (!rdev)
+			break;
+		/* Skip devices not on my rio port */
+		if (rdev->net->hport->id != srio_port)
+			continue;
+		/* Skip switches */
+		if (rdev->destid == 0xffff)
+			continue;
+		target = kmalloc(sizeof(*target), GFP_KERNEL);
+		if (!target) {
+			WARN(1, "No memory");
+			return -ENOMEM;
+		}
+		target->destid = rdev->destid;
+		list_add(&target->list, &priv->srio_bcast);
+	}
+	return 0;
+}
+
+int cvm_oct_srio_stop(struct net_device *dev)
+{
+	struct octeon_ethernet *priv = netdev_priv(dev);
+	struct list_head *pos;
+	struct list_head *n;
+
+	list_for_each_safe(pos, n, &priv->srio_bcast) {
+		struct octeon_ethernet_srio_bcast_target *t;
+		list_del(pos);
+		t = container_of(pos, struct octeon_ethernet_srio_bcast_target,
+				 list);
+		kfree(t);
+	}
+	return 0;
+}
diff --git a/drivers/rapidio/devices/Kconfig b/drivers/rapidio/devices/Kconfig
index c4cb087..dcc815d 100644
--- a/drivers/rapidio/devices/Kconfig
+++ b/drivers/rapidio/devices/Kconfig
@@ -8,3 +8,11 @@ config RAPIDIO_TSI721
 	default "n"
 	---help---
 	  Include support for IDT Tsi721 PCI Express Serial RapidIO controller.
+
+config RAPIDIO_CN6XXX
+	tristate "Cavium Networks CN6XXX processors"
+	depends on RAPIDIO
+	---help---
+	  Includes support for Cavium Networks CN6XXX family of serial RapidIO
+	  devices.
+
diff --git a/drivers/rapidio/devices/Makefile b/drivers/rapidio/devices/Makefile
index 9432c49..565ebfb 100644
--- a/drivers/rapidio/devices/Makefile
+++ b/drivers/rapidio/devices/Makefile
@@ -5,3 +5,4 @@
 obj-$(CONFIG_RAPIDIO_TSI721)	+= tsi721_mport.o
 tsi721_mport-y			:= tsi721.o
 tsi721_mport-$(CONFIG_RAPIDIO_DMA_ENGINE) += tsi721_dma.o
+obj-$(CONFIG_RAPIDIO_CN6XXX)    += cn6xxx.o
diff --git a/drivers/rapidio/devices/cn6xxx.c b/drivers/rapidio/devices/cn6xxx.c
new file mode 100644
index 0000000..b1ed3bb
--- /dev/null
+++ b/drivers/rapidio/devices/cn6xxx.c
@@ -0,0 +1,277 @@
+/*
+ * Cavium Inc. CN6XXX support over SRIO
+ *
+ * Copyright 2010 Cavium, Inc.  Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/rio.h>
+#include <linux/rio_drv.h>
+#include <linux/rio_ids.h>
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-sli-defs.h>
+#include <asm/octeon/cvmx-sriomaintx-defs.h>
+
+/* The defines below control the SRIO memory address map configured
+    on CN6XXX. All possible regions are packed together in desending
+    size. This way all alignments are honored */
+#define BAR1_ADDRESS    0ull
+#define BAR1_SHIFT      7 /* 128MB */
+#define BAR1_SIZE       (1ull<<(20 + BAR1_SHIFT))
+#define MAINT_ADDRESS   (BAR1_ADDRESS + BAR1_SIZE)
+#define MAINT_SIZE      (1ull<<24)
+#define BAR0_ADDRESS    (MAINT_ADDRESS + MAINT_SIZE)
+#define BAR0_SIZE       16384ull
+#define BAR2_ADDRESS    (1ull<<41)
+#define BAR2_SIZE       (1ull<<41)
+
+static uint64_t c6xxx_read_bar0(struct rio_dev *dev, int offset)
+{
+	uint64_t result;
+	void *bar0 = rio_map_memory(dev, BAR0_ADDRESS, BAR0_SIZE);
+	if (!bar0) {
+		dev_err(&dev->dev, "Failed to map BAR0\n");
+		return 0;
+	}
+	result = *(uint64_t *)(bar0 + offset);
+	rio_unmap_memory(dev, BAR0_ADDRESS, BAR0_SIZE, bar0);
+	return result;
+}
+
+static void cn6xxx_doorbell(struct rio_mport *mport, void *dev_id, u16 src,
+	u16 dst, u16 info)
+{
+	struct rio_dev *dev = (struct rio_dev *)dev_id;
+	dev_info(&dev->dev, "Received doorbell %d\n", info);
+}
+
+static int cn6xxx_probe(struct rio_dev *dev, const struct rio_device_id *id)
+{
+	u32 data;
+	union cvmx_sriomaintx_m2s_bar2_start sriomaintx_m2s_bar2_start;
+	union cvmx_sriomaintx_lcs_ba0 sriomaintx_lcs_ba0;
+	union cvmx_sriomaintx_lcs_ba1 sriomaintx_lcs_ba1;
+	union cvmx_sriomaintx_m2s_bar1_start0 sriomaintx_m2s_bar1_start0;
+	union cvmx_sriomaintx_m2s_bar1_start1 sriomaintx_m2s_bar1_start1;
+	union cvmx_sriomaintx_m2s_bar0_start0 sriomaintx_m2s_bar0_start0;
+	union cvmx_sriomaintx_m2s_bar0_start1 sriomaintx_m2s_bar0_start1;
+	union cvmx_sriomaintx_core_enables sriomaintx_core_enables;
+	union cvmx_sriomaintx_port_gen_ctl sriomaintx_port_gen_ctl;
+	union cvmx_sriomaintx_port_0_ctl sriomaintx_port_0_ctl;
+	const char *state;
+	int index;
+
+	if (rio_read_config_32(dev, CVMX_SRIOMAINTX_IR_PI_PHY_STAT(0), &data))
+		return -1;
+	switch (data & 0x3ff) {
+	case 0x0:
+		state = "Silent";
+		break;
+	case 0x2:
+		state = "Seek";
+		break;
+	case 0x4:
+		state = "Discovery";
+		break;
+	case 0x8:
+		state = "1x Mode Lane 0";
+		break;
+	case 0x10:
+		state = "1x Mode Lane 1";
+		break;
+	case 0x20:
+		state = "1x Mode Lane 2";
+		break;
+	case 0x40:
+		state = "1x Recovery";
+		break;
+	case 0x80:
+		state = "2x Mode";
+		break;
+	case 0x100:
+		state = "2x Recovery";
+		break;
+	case 0x200:
+		state = "4x Mode";
+		break;
+	default:
+		state = "Reserved";
+		break;
+	}
+	dev_info(&dev->dev, "Link state: %s\n", state);
+
+	/* Setup BAR2 */
+	sriomaintx_m2s_bar2_start.u32 = 0;
+	sriomaintx_m2s_bar2_start.s.addr64 = BAR2_ADDRESS >> 48;
+	sriomaintx_m2s_bar2_start.s.addr48 = BAR2_ADDRESS >> 41;
+	sriomaintx_m2s_bar2_start.s.esx = 0;
+	sriomaintx_m2s_bar2_start.s.cax = 0;
+	sriomaintx_m2s_bar2_start.s.addr66 = 0; /* BAR2_ADDRESS >> 64; */
+	sriomaintx_m2s_bar2_start.s.enable = 1;
+	if (rio_write_config_32(dev, CVMX_SRIOMAINTX_M2S_BAR2_START(0),
+		sriomaintx_m2s_bar2_start.u32))
+		return -1;
+	dev_info(&dev->dev, "BAR2 0x%016llx - 0x%016llx\n", BAR2_ADDRESS,
+		BAR2_ADDRESS + BAR2_SIZE - 1);
+
+	/* Setup Maintinance */
+	sriomaintx_lcs_ba0.u32 = 0;
+	sriomaintx_lcs_ba0.s.lcsba = MAINT_ADDRESS >> 35;
+	sriomaintx_lcs_ba1.u32 = 0;
+	sriomaintx_lcs_ba1.s.lcsba = (MAINT_ADDRESS >> 24) & 0x7ff;
+	if (rio_write_config_32(dev, CVMX_SRIOMAINTX_LCS_BA0(0),
+		sriomaintx_lcs_ba0.u32))
+		return -1;
+	if (rio_write_config_32(dev, CVMX_SRIOMAINTX_LCS_BA1(0),
+		sriomaintx_lcs_ba1.u32))
+		return -1;
+	dev_info(&dev->dev, "Maintenance 0x%016llx - 0x%016llx\n",
+		MAINT_ADDRESS, MAINT_ADDRESS + MAINT_SIZE - 1);
+
+	/* Setup BAR1 */
+	sriomaintx_m2s_bar1_start0.u32 = 0;
+	sriomaintx_m2s_bar1_start0.s.addr64 = BAR1_ADDRESS >> 48;
+	sriomaintx_m2s_bar1_start0.s.addr48 = BAR1_ADDRESS >> 32;
+	sriomaintx_m2s_bar1_start1.u32 = 0;
+	sriomaintx_m2s_bar1_start1.s.addr32 = (BAR1_ADDRESS >> 20) & 0xfff;
+	sriomaintx_m2s_bar1_start1.s.barsize = BAR1_SHIFT;
+	sriomaintx_m2s_bar1_start1.s.addr66 = 0; /* BAR1_ADDRESS >> 64; */
+	sriomaintx_m2s_bar1_start1.s.enable = 1;
+	if (rio_write_config_32(dev, CVMX_SRIOMAINTX_M2S_BAR1_START0(0),
+		sriomaintx_m2s_bar1_start0.u32))
+		return -1;
+	if (rio_write_config_32(dev, CVMX_SRIOMAINTX_M2S_BAR1_START1(0),
+		sriomaintx_m2s_bar1_start1.u32))
+		return -1;
+	dev_info(&dev->dev, "BAR1 0x%016llx - 0x%016llx\n", BAR1_ADDRESS,
+		BAR1_ADDRESS + BAR1_SIZE - 1);
+
+	/* Setup BAR0 */
+	sriomaintx_m2s_bar0_start0.u32 = 0;
+	sriomaintx_m2s_bar0_start0.s.addr64 = BAR0_ADDRESS >> 48;
+	sriomaintx_m2s_bar0_start0.s.addr48 = BAR0_ADDRESS >> 32;
+	sriomaintx_m2s_bar0_start1.u32 = 0;
+	sriomaintx_m2s_bar0_start1.s.addr32 = (BAR0_ADDRESS >> 14) & 0x3ffff;
+	sriomaintx_m2s_bar0_start1.s.addr66 = 0; /* BAR0_ADDRESS >> 64; */
+	sriomaintx_m2s_bar0_start1.s.enable = 1;
+	if (rio_write_config_32(dev, CVMX_SRIOMAINTX_M2S_BAR0_START0(0),
+		sriomaintx_m2s_bar0_start0.u32))
+		return -1;
+	if (rio_write_config_32(dev, CVMX_SRIOMAINTX_M2S_BAR0_START1(0),
+		sriomaintx_m2s_bar0_start1.u32))
+		return -1;
+	dev_info(&dev->dev, "BAR0 0x%016llx - 0x%016llx\n", BAR0_ADDRESS,
+		BAR0_ADDRESS + BAR0_SIZE - 1);
+
+	/* Set enables */
+	sriomaintx_core_enables.u32 = 0;
+	sriomaintx_core_enables.s.imsg1 = 1;
+	sriomaintx_core_enables.s.imsg0 = 1;
+	sriomaintx_core_enables.s.doorbell = 1;
+	sriomaintx_core_enables.s.memory = 1;
+	if (rio_write_config_32(dev, CVMX_SRIOMAINTX_CORE_ENABLES(0),
+		sriomaintx_core_enables.u32))
+		return -1;
+
+	/* Enable transaction mastering */
+	if (rio_read_config_32(dev, CVMX_SRIOMAINTX_PORT_GEN_CTL(0),
+		&sriomaintx_port_gen_ctl.u32))
+		return -1;
+	sriomaintx_port_gen_ctl.s.menable = 1;
+	if (rio_write_config_32(dev, CVMX_SRIOMAINTX_PORT_GEN_CTL(0),
+		sriomaintx_port_gen_ctl.u32))
+		return -1;
+
+	/* Set link I/O enabled */
+	if (rio_read_config_32(dev, CVMX_SRIOMAINTX_PORT_0_CTL(0),
+		&sriomaintx_port_0_ctl.u32))
+		return -1;
+	sriomaintx_port_0_ctl.s.o_enable = 1;
+	sriomaintx_port_0_ctl.s.i_enable = 1;
+	if (rio_write_config_32(dev, CVMX_SRIOMAINTX_PORT_0_CTL(0),
+		sriomaintx_port_0_ctl.u32))
+		return -1;
+
+	if (rio_request_inb_dbell(dev->net->hport, dev, 0, 1,
+		cn6xxx_doorbell)) {
+		dev_err(&dev->dev, "Register for incomming doorbells failed\n");
+		return -1;
+	}
+
+	for (index = 0; index < 16; index++) {
+		union cvmx_sriomaintx_bar1_idxx sriomaintx_bar1_idxx;
+		sriomaintx_bar1_idxx.u32 = 0;
+		sriomaintx_bar1_idxx.s.la = index;
+		sriomaintx_bar1_idxx.s.enable = 1;
+		if (rio_write_config_32(dev, CVMX_SRIOMAINTX_BAR1_IDXX(index, 0),
+			sriomaintx_bar1_idxx.u32))
+			return -1;
+	}
+	dev_info(&dev->dev, "SLI_MAC_CREDIT_CNT = 0x%llx\n", c6xxx_read_bar0(dev, CVMX_SLI_MAC_CREDIT_CNT));
+
+	if (rio_send_doorbell(dev, 0))
+		dev_err(&dev->dev, "Sending doorbell failed\n");
+
+	if (rio_send_doorbell(dev, 1))
+		dev_err(&dev->dev, "Sending doorbell failed\n");
+
+	return 0;
+}
+
+static void cn6xxx_remove(struct rio_dev *dev)
+{
+	dev_info(&dev->dev, "Removed\n");
+	rio_release_inb_dbell(dev->net->hport, 0, 1);
+}
+
+static int cn6xxx_suspend(struct rio_dev *dev, u32 state)
+{
+	return 0; /* Do nothing */
+}
+
+static int cn6xxx_resume(struct rio_dev *dev)
+{
+	return 0; /* Do nothing */
+}
+
+static int cn6xxx_enable_wake(struct rio_dev *dev, u32 state, int enable)
+{
+	return 0; /* Do nothing */
+}
+
+static const struct rio_device_id cn6xxx_id_table[] = {
+	{.did = 0x0090, .vid = 0x008c, .asm_did = 0x0000, .asm_vid = 0x008c },
+	{.did = 0x0092, .vid = 0x008c, .asm_did = 0x0000, .asm_vid = 0x008c },
+	{.did = 0,}
+};
+
+static struct rio_driver cn6xxx_driver = {
+	.name = "CN6XXX",
+	.id_table = cn6xxx_id_table,
+	.probe = cn6xxx_probe,
+	.remove = cn6xxx_remove,
+	.suspend = cn6xxx_suspend,
+	.resume = cn6xxx_resume,
+	.enable_wake = cn6xxx_enable_wake,
+};
+
+static int __init m_load(void)
+{
+	return rio_register_driver(&cn6xxx_driver);
+}
+
+static void __exit m_unload(void)
+{
+	rio_unregister_driver(&cn6xxx_driver);
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cavium Inc. <support@cavium.com>");
+MODULE_DESCRIPTION("Cavium Inc. CN6XXX support over SRIO.");
+module_init(m_load);
+module_exit(m_unload);
diff --git a/drivers/rapidio/rio-sysfs.c b/drivers/rapidio/rio-sysfs.c
index cdb005c..d1ea300 100644
--- a/drivers/rapidio/rio-sysfs.c
+++ b/drivers/rapidio/rio-sysfs.c
@@ -18,6 +18,12 @@
 
 #include "rio.h"
 
+#ifdef CONFIG_CAVIUM_OCTEON_RAPIDIO
+#include <asm/io.h>
+int octeon_rio_dma_mem(struct rio_dev *rdev, uint64_t local_addr,
+		       uint64_t remote_addr, int size, int is_outbound);
+#endif
+
 /* Sysfs support */
 #define rio_config_attr(field, format_string)					\
 static ssize_t								\
@@ -261,6 +267,70 @@ static struct bin_attribute rio_config_attr = {
 	.write = rio_write_config,
 };
 
+static ssize_t
+rio_read_memory(struct file *_, struct kobject *kobj,
+		struct bin_attribute *bin_attr,
+		char *buf, loff_t off, size_t count)
+{
+	struct rio_dev *dev =
+		to_rio_dev(container_of(kobj, struct device, kobj));
+	void *map;
+
+	if (off >= bin_attr->size)
+		return 0;
+	if (off + count > bin_attr->size)
+		count = bin_attr->size - off;
+
+#ifdef CONFIG_CAVIUM_OCTEON_RAPIDIO
+	if (count > 8) {
+		if (octeon_rio_dma_mem(dev, virt_to_phys(buf), off, count, 0))
+			return 0;
+		else
+			return count;
+	}
+#endif
+	map = rio_map_memory(dev, off, count);
+	if (!map) {
+		dev_err(&dev->dev, "Unable to map RapidIO device resource\n");
+		return 0;
+	}
+	memcpy(buf, map, count);
+	rio_unmap_memory(dev, off, count, map);
+	return count;
+}
+
+static ssize_t
+rio_write_memory(struct file *_, struct kobject *kobj,
+		 struct bin_attribute *bin_attr,
+		 char *buf, loff_t off, size_t count)
+{
+	struct rio_dev *dev =
+		to_rio_dev(container_of(kobj, struct device, kobj));
+	void *map;
+
+	if (off >= bin_attr->size)
+		return 0;
+	if (off + count > bin_attr->size)
+		count = bin_attr->size - off;
+
+#ifdef CONFIG_CAVIUM_OCTEON_RAPIDIO
+	if (count > 8) {
+		if (octeon_rio_dma_mem(dev, virt_to_phys(buf), off, count, 1))
+			return 0;
+		else
+			return count;
+	}
+#endif
+	map = rio_map_memory(dev, off, count);
+	if (!map) {
+		dev_err(&dev->dev, "Unable to map RapidIO device resource\n");
+		return 0;
+	}
+	memcpy(map, buf, count);
+	rio_unmap_memory(dev, off, count, map);
+	return count;
+}
+
 /**
  * rio_create_sysfs_dev_files - create RIO specific sysfs files
  * @rdev: device whose entries should be created
@@ -271,6 +341,7 @@ int rio_create_sysfs_dev_files(struct rio_dev *rdev)
 {
 	int err = 0;
 
+
 	err = device_create_bin_file(&rdev->dev, &rio_config_attr);
 
 	if (!err && (rdev->pef & RIO_PEF_SWITCH)) {
@@ -283,6 +354,29 @@ int rio_create_sysfs_dev_files(struct rio_dev *rdev)
 		pr_warning("RIO: Failed to create attribute file(s) for %s\n",
 			   rio_name(rdev));
 
+	rdev->memory.attr.name = "memory";
+	rdev->memory.attr.mode = S_IRUGO | S_IWUSR;
+	rdev->memory.read = rio_read_memory;
+	rdev->memory.write = rio_write_memory;
+	rdev->memory.private = NULL;
+
+	/* Prefer 50 bit addressing as it fits in kernel variables on a 64 bit
+		machine. Support for addressing 66 bits will need to be
+		revisited if anyone actually uses it */
+	if (rdev->pef & RIO_PEF_ADDR_50)
+		rdev->memory.size = (sizeof(rdev->memory.size) == 4) ? 1<<31 : 1ul << 50;
+	else if (rdev->pef & RIO_PEF_ADDR_66)
+		rdev->memory.size = (sizeof(rdev->memory.size) == 4) ? 1<<31 : 1ul << 63;
+	else if (rdev->pef & RIO_PEF_ADDR_34)
+		rdev->memory.size = (sizeof(rdev->memory.size) == 4) ? 1<<31 : 1ul << 34;
+	else
+		rdev->memory.size = 0;
+
+	if (rdev->memory.size) {
+		err = sysfs_create_bin_file(&rdev->dev.kobj, &rdev->memory);
+		if (err)
+			rdev->memory.size = 0;
+	}
 	return err;
 }
 
@@ -294,6 +388,13 @@ int rio_create_sysfs_dev_files(struct rio_dev *rdev)
  */
 void rio_remove_sysfs_dev_files(struct rio_dev *rdev)
 {
+	sysfs_remove_bin_file(&rdev->dev.kobj, &rio_config_attr);
+
+	if (rdev->memory.size) {
+		sysfs_remove_bin_file(&rdev->dev.kobj, &rdev->memory);
+		rdev->memory.size = 0;
+	}
+
 	device_remove_bin_file(&rdev->dev, &rio_config_attr);
 	if (rdev->pef & RIO_PEF_SWITCH) {
 		device_remove_file(&rdev->dev, &dev_attr_routes);
diff --git a/drivers/rapidio/rio.c b/drivers/rapidio/rio.c
index d7b87c6..b6924ca 100644
--- a/drivers/rapidio/rio.c
+++ b/drivers/rapidio/rio.c
@@ -483,6 +483,51 @@ void rio_unmap_inb_region(struct rio_mport *mport, dma_addr_t lstart)
 EXPORT_SYMBOL_GPL(rio_unmap_inb_region);
 
 /**
+ * rio_map_memory - Map a RIO memory address to a kernel pointer.
+ * @rdev: RapidIO device the map is for
+ * @offset: RapidIO memory address offset into the device
+ * @length: Length of the mapped range
+ *
+ * Returns a kernel pointer to a memory mapped interface for a remote RapidIO
+ * device.
+ */
+void *rio_map_memory(struct rio_dev *rdev,
+		     u64 offset, u64 length)
+{
+	phys_addr_t physical;
+	struct rio_mport *mport = rdev->net->hport;
+
+	if (!mport->ops->map)
+		return NULL;
+	physical = mport->ops->map(mport, rdev, offset, length);
+	if (physical)
+		return phys_to_virt(physical);
+	else
+		return NULL;
+}
+EXPORT_SYMBOL_GPL(rio_map_memory);
+
+/**
+ * rio_unmap_memory - Unmap a RIO device mapped using rio_map_memory().
+ * @rdev: RapidIO device the resource is for
+ * @offset: RapidIO memory address offset of the map
+ * @length: Length of the mapped range
+ * @map: Kernel virtual address the resource was mapped at
+ */
+void rio_unmap_memory(struct rio_dev *rdev,
+		      u64 offset, u64 length, void *map)
+{
+	phys_addr_t physical;
+	struct rio_mport *mport = rdev->net->hport;
+
+	if (!mport->ops->map)
+		return;
+	physical = virt_to_phys(map);
+	mport->ops->unmap(mport, rdev, offset, length, physical);
+}
+EXPORT_SYMBOL_GPL(rio_unmap_memory);
+
+/**
  * rio_mport_get_physefb - Helper function that returns register offset
  *                      for Physical Layer Extended Features Block.
  * @port: Master port to issue transaction
diff --git a/include/linux/rio.h b/include/linux/rio.h
index 6bda06f..3c7b669 100644
--- a/include/linux/rio.h
+++ b/include/linux/rio.h
@@ -191,6 +191,7 @@ struct rio_dev {
 	struct device dev;	/* LDM device structure */
 	struct resource riores[RIO_MAX_DEV_RESOURCES];
 	int (*pwcback) (struct rio_dev *rdev, union rio_pw_msg *msg, int step);
+	struct bin_attribute memory;    /* Sysfs file for memory access */
 	u16 destid;
 	u8 hopcount;
 	struct rio_dev *prev;
@@ -333,6 +334,8 @@ struct rio_net {
  * @get_inb_message: Callback to get a message from an inbound mailbox queue.
  * @map_inb: Callback to map RapidIO address region into local memory space.
  * @unmap_inb: Callback to unmap RapidIO address region mapped with map_inb().
+ * @map: Callback to map a remote device's memory range to the local system.
+ * @unmap: Callback to unmap a previously mapped range.
  */
 struct rio_ops {
 	int (*lcread) (struct rio_mport *mport, int index, u32 offset, int len,
@@ -358,6 +361,10 @@ struct rio_ops {
 	int (*map_inb)(struct rio_mport *mport, dma_addr_t lstart,
 			u64 rstart, u32 size, u32 flags);
 	void (*unmap_inb)(struct rio_mport *mport, dma_addr_t lstart);
+	phys_addr_t (*map)(struct rio_mport *mport, struct rio_dev *rdev,
+			u64 offset, u64 length);
+	void (*unmap)(struct rio_mport *mport, struct rio_dev *rdev,
+			u64 offset, u64 length, phys_addr_t map);
 };
 
 #define RIO_RESOURCE_MEM	0x00000100
diff --git a/include/linux/rio_drv.h b/include/linux/rio_drv.h
index 9fc2f21..3db1f86 100644
--- a/include/linux/rio_drv.h
+++ b/include/linux/rio_drv.h
@@ -365,6 +365,9 @@ void rio_release_regions(struct rio_dev *);
 int rio_request_region(struct rio_dev *, int, char *);
 void rio_release_region(struct rio_dev *, int);
 
+void *rio_map_memory(struct rio_dev *rdev, u64 offset, u64 length);
+void rio_unmap_memory(struct rio_dev *rdev, u64 offset, u64 length, void *map);
+
 /* Memory mapping functions */
 extern int rio_map_inb_region(struct rio_mport *mport, dma_addr_t local,
 			u64 rbase, u32 size, u32 rflags);
-- 
1.9.1

