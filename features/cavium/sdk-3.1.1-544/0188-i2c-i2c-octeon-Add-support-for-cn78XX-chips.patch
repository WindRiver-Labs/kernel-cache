From 762aedd47da61e4313566d90a6273b1f6d564300 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Wed, 15 Oct 2014 15:36:24 -0700
Subject: [PATCH 188/202] i2c: i2c-octeon: Add support for cn78XX chips.

cn78XX has a different interrupt architecture, so we have to manage the
interrupts a little differently.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.1-544]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/i2c/busses/i2c-octeon.c | 172 +++++++++++++++++++++++++++++++++++-----
 1 file changed, 151 insertions(+), 21 deletions(-)

diff --git a/drivers/i2c/busses/i2c-octeon.c b/drivers/i2c/busses/i2c-octeon.c
index a5c8da3..479979e 100644
--- a/drivers/i2c/busses/i2c-octeon.c
+++ b/drivers/i2c/busses/i2c-octeon.c
@@ -13,6 +13,7 @@
 
 #include <linux/platform_device.h>
 #include <linux/interrupt.h>
+#include <linux/atomic.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/delay.h>
@@ -75,6 +76,7 @@ struct octeon_i2c {
 	wait_queue_head_t queue;
 	struct i2c_adapter adap;
 	int irq;
+	int hlc_irq;		/* For cn7890 only */
 	u32 twsi_freq;
 	int sys_freq;
 	void __iomem *twsi_base;
@@ -82,6 +84,12 @@ struct octeon_i2c {
 	int broken_irq_mode;
 	bool octeon_i2c_hlc_enabled;
 	int cvmx_channel;
+	void (*int_en)(struct octeon_i2c *);
+	void (*int_dis)(struct octeon_i2c *);
+	void (*hlc_int_en)(struct octeon_i2c *);
+	void (*hlc_int_dis)(struct octeon_i2c *);
+	atomic_t int_en_cnt;
+	atomic_t hlc_int_en_cnt;
 };
 
 /**
@@ -137,7 +145,7 @@ static void octeon_i2c_write_int(struct octeon_i2c *i2c, u64 data)
 }
 
 /**
- * octeon_i2c_int_enable - enable the TS interrupt.
+ * octeon_i2c_int_enable - enable the CORE interrupt.
  * @i2c: The struct octeon_i2c.
  *
  * The interrupt will be asserted when there is non-STAT_IDLE state in
@@ -149,7 +157,7 @@ static void octeon_i2c_int_enable(struct octeon_i2c *i2c)
 }
 
 /**
- * octeon_i2c_int_disable - disable the TS interrupt.
+ * octeon_i2c_int_disable - disable the CORE interrupt.
  * @i2c: The struct octeon_i2c.
  */
 static void octeon_i2c_int_disable(struct octeon_i2c *i2c)
@@ -158,6 +166,64 @@ static void octeon_i2c_int_disable(struct octeon_i2c *i2c)
 }
 
 /**
+ * octeon_i2c_int_enable78 - enable the CORE interrupt.
+ * @i2c: The struct octeon_i2c.
+ *
+ * The interrupt will be asserted when there is non-STAT_IDLE state in
+ * the SW_TWSI_EOP_TWSI_STAT register.
+ */
+static void octeon_i2c_int_enable78(struct octeon_i2c *i2c)
+{
+	atomic_inc_return(&i2c->int_en_cnt);
+	enable_irq(i2c->irq);
+}
+
+/**
+ * octeon_i2c_int_disable78 - disable the CORE interrupt.
+ * @i2c: The struct octeon_i2c.
+ */
+static void octeon_i2c_int_disable78(struct octeon_i2c *i2c)
+{
+	/*
+	 * The interrupt can be disabled in two places, but we only
+	 * want to make the disable_irq_nosync() call once, so keep
+	 * track with the atomic variable.
+	 */
+	int c = atomic_dec_if_positive(&i2c->int_en_cnt);
+	if (c >= 0)
+		disable_irq_nosync(i2c->irq);
+}
+
+/**
+ * octeon_i2c_hlc_int_enable78 - enable the ST interrupt.
+ * @i2c: The struct octeon_i2c.
+ *
+ * The interrupt will be asserted when there is non-STAT_IDLE state in
+ * the SW_TWSI_EOP_TWSI_STAT register.
+ */
+static void octeon_i2c_hlc_int_enable78(struct octeon_i2c *i2c)
+{
+	atomic_inc_return(&i2c->hlc_int_en_cnt);
+	enable_irq(i2c->hlc_irq);
+}
+
+/**
+ * octeon_i2c_hlc_int_disable78 - disable the ST interrupt.
+ * @i2c: The struct octeon_i2c.
+ */
+static void octeon_i2c_hlc_int_disable78(struct octeon_i2c *i2c)
+{
+	/*
+	 * The interrupt can be disabled in two places, but we only
+	 * want to make the disable_irq_nosync() call once, so keep
+	 * track with the atomic variable.
+	 */
+	int c = atomic_dec_if_positive(&i2c->hlc_int_en_cnt);
+	if (c >= 0)
+		disable_irq_nosync(i2c->hlc_irq);
+}
+
+/**
  * octeon_i2c_unblock - unblock the bus.
  * @i2c: The struct octeon_i2c.
  *
@@ -192,7 +258,22 @@ static irqreturn_t octeon_i2c_isr(int irq, void *dev_id)
 {
 	struct octeon_i2c *i2c = dev_id;
 
-	octeon_i2c_int_disable(i2c);
+	i2c->int_dis(i2c);
+	wake_up(&i2c->queue);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * octeon_hlc_i2c_isr78 - the interrupt service routine.
+ * @int: The irq, unused.
+ * @dev_id: Our struct octeon_i2c.
+ */
+static irqreturn_t octeon_i2c_hlc_isr78(int irq, void *dev_id)
+{
+	struct octeon_i2c *i2c = dev_id;
+
+	i2c->hlc_int_dis(i2c);
 	wake_up(&i2c->queue);
 
 	return IRQ_HANDLED;
@@ -228,13 +309,13 @@ static int octeon_i2c_wait(struct octeon_i2c *i2c)
 		return octeon_i2c_test_iflg(i2c) ? 0 : -ETIMEDOUT;
 	}
 
-	octeon_i2c_int_enable(i2c);
+	i2c->int_en(i2c);
 
 	result = wait_event_timeout(i2c->queue,
 					octeon_i2c_test_iflg(i2c),
 					i2c->adap.timeout);
 
-	octeon_i2c_int_disable(i2c);
+	i2c->int_dis(i2c);
 
 
 	if (result <= 0 && octeon_i2c_test_iflg(i2c)) {
@@ -511,13 +592,13 @@ static int octeon_i2c_hlc_wait(struct octeon_i2c *i2c)
 		return octeon_i2c_hlc_test_ready(i2c) ? 0 : -ETIMEDOUT;
 	}
 
-	octeon_i2c_hlc_int_enable(i2c);
+	i2c->hlc_int_en(i2c);
 
 	result = wait_event_interruptible_timeout(i2c->queue,
 						  octeon_i2c_hlc_test_ready(i2c),
 						  i2c->adap.timeout);
-
-	octeon_i2c_int_disable(i2c);
+	i2c->hlc_int_dis(i2c);
+	octeon_i2c_hlc_int_clear(i2c);
 
 
 	if (result <= 0 && octeon_i2c_hlc_test_ready(i2c)) {
@@ -918,14 +999,28 @@ EXPORT_SYMBOL(octeon_i2c_cvmx2i2c);
 
 static int octeon_i2c_probe(struct platform_device *pdev)
 {
-	int irq, result = 0;
+	int irq, hlc_irq = 0, result = 0;
 	struct octeon_i2c *i2c;
 	struct resource *res_mem;
+	struct device_node *node = pdev->dev.of_node;
+	bool cn78xx_style;
+
+	cn78xx_style = of_device_is_compatible(node, "cavium,octeon-7890-twsi");
 
-	/* All adaptors have an irq.  */
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0)
-		return irq;
+	if (cn78xx_style) {
+		hlc_irq = platform_get_irq(pdev, 0);
+		if (hlc_irq < 0)
+			return hlc_irq;
+
+		irq = platform_get_irq(pdev, 2);
+		if (irq < 0)
+			return irq;
+	} else {
+		/* All adaptors have an irq.  */
+		irq = platform_get_irq(pdev, 0);
+		if (irq < 0)
+			return irq;
+	}
 
 	i2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);
 	if (!i2c) {
@@ -949,9 +1044,9 @@ static int octeon_i2c_probe(struct platform_device *pdev)
 	 * "clock-frequency".  Try the official one first and then
 	 * fall back if it doesn't exist.
 	 */
-	if (of_property_read_u32(pdev->dev.of_node,
+	if (of_property_read_u32(node,
 				 "clock-frequency", &i2c->twsi_freq) &&
-	    of_property_read_u32(pdev->dev.of_node,
+	    of_property_read_u32(node,
 				 "clock-rate", &i2c->twsi_freq)) {
 		dev_err(i2c->dev,
 			"no I2C 'clock-rate' or 'clock-frequency' property\n");
@@ -983,11 +1078,43 @@ static int octeon_i2c_probe(struct platform_device *pdev)
 
 	i2c->irq = irq;
 
-	result = devm_request_irq(&pdev->dev, i2c->irq,
-				  octeon_i2c_isr, 0, DRV_NAME, i2c);
-	if (result < 0) {
-		dev_err(i2c->dev, "failed to attach interrupt\n");
-		goto out;
+	if (cn78xx_style) {
+		i2c->hlc_irq = hlc_irq;
+
+		i2c->int_en = octeon_i2c_int_enable78;
+		i2c->int_dis = octeon_i2c_int_disable78;
+		i2c->hlc_int_en = octeon_i2c_hlc_int_enable78;
+		i2c->hlc_int_dis = octeon_i2c_hlc_int_disable78;
+
+		irq_set_status_flags(i2c->irq, IRQ_NOAUTOEN);
+		irq_set_status_flags(i2c->hlc_irq, IRQ_NOAUTOEN);
+
+		result = devm_request_irq(&pdev->dev, i2c->irq,
+					  octeon_i2c_isr, 0, DRV_NAME, i2c);
+
+		if (result < 0) {
+			dev_err(i2c->dev, "failed to attach interrupt\n");
+			goto out;
+		}
+		result = devm_request_irq(&pdev->dev, i2c->hlc_irq,
+					  octeon_i2c_hlc_isr78, 0, DRV_NAME, i2c);
+
+		if (result < 0) {
+			dev_err(i2c->dev, "failed to attach interrupt\n");
+			goto out;
+		}
+	} else {
+		i2c->int_en = octeon_i2c_int_enable;
+		i2c->int_dis = octeon_i2c_int_disable;
+		i2c->hlc_int_en = octeon_i2c_hlc_int_enable;
+		i2c->hlc_int_dis = octeon_i2c_int_disable;
+
+		result = devm_request_irq(&pdev->dev, i2c->irq,
+					  octeon_i2c_isr, 0, DRV_NAME, i2c);
+		if (result < 0) {
+			dev_err(i2c->dev, "failed to attach interrupt\n");
+			goto out;
+		}
 	}
 
 	result = octeon_i2c_initlowlevel(i2c);
@@ -1005,7 +1132,7 @@ static int octeon_i2c_probe(struct platform_device *pdev)
 	i2c->adap = octeon_i2c_ops;
 	i2c->adap.timeout = msecs_to_jiffies(50);
 	i2c->adap.dev.parent = &pdev->dev;
-	i2c->adap.dev.of_node = pdev->dev.of_node;
+	i2c->adap.dev.of_node = node;
 	i2c_set_adapdata(&i2c->adap, i2c);
 	platform_set_drvdata(pdev, i2c);
 
@@ -1039,6 +1166,9 @@ static struct of_device_id octeon_i2c_match[] = {
 	{
 		.compatible = "cavium,octeon-3860-twsi",
 	},
+	{
+		.compatible = "cavium,octeon-7890-twsi",
+	},
 	{},
 };
 MODULE_DEVICE_TABLE(of, octeon_i2c_match);
-- 
1.8.2.1

