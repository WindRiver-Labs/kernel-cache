From f840db5e1f6b5be629c9f8cb0860a5e63c0bcf49 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 13 Feb 2015 14:26:22 +0530
Subject: [PATCH 057/132] MIPS: OCTEON: Cleanup memory initialization and allow
 for more than 32GB

Commit c68c59ff665b1b8e1a555305144441446d0c5a24 from
git://git.yoctoproject.org/linux-yocto-3.14

Don't add kernel image when adding memory from named blocks.
... otherwise the kernel image is clobbered.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Abhishek Paliwal <abhishek.paliwal@aricent.com>
[Original patch taken from OCTEON-SDK 3.1.1-544.]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/cavium-octeon/setup.c | 144 +++++++++++++++++++++++++---------------
 1 file changed, 91 insertions(+), 53 deletions(-)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index a171957..1b0ee0f 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -58,7 +58,7 @@ extern struct plat_smp_ops octeon_smp_ops;
 extern void pci_console_init(const char *arg);
 #endif
 
-static unsigned long long MAX_MEMORY = 512ull << 20;
+static u64 max_memory = 512ull << 20;
 
 DEFINE_SEMAPHORE(octeon_bootbus_sem);
 EXPORT_SYMBOL(octeon_bootbus_sem);
@@ -268,9 +268,11 @@ static void octeon_crash_shutdown(struct pt_regs *regs)
 #endif /* CONFIG_KEXEC */
 
 #ifdef CONFIG_CAVIUM_RESERVE32
+#define  CONFIG_CAVIUM_RESERVE32        0ULL
+#endif
+
 uint64_t octeon_reserve32_memory;
 EXPORT_SYMBOL(octeon_reserve32_memory);
-#endif
 
 #ifdef CONFIG_KEXEC
 /* crashkernel cmdline parameter is parsed _after_ memory setup
@@ -282,6 +284,9 @@ static int octeon_uart;
 
 extern asmlinkage void handle_int(void);
 
+/* Up to four blocks may be specified. */
+static char __initdata named_memory_blocks[4][CVMX_BOOTMEM_NAME_LEN];
+
 /**
  * Return non zero if we are currently running in the Octeon simulator
  *
@@ -846,13 +851,13 @@ void __init prom_init(void)
 
 	/* Default to 64MB in the simulator to speed things up */
 	if (octeon_is_simulation())
-		MAX_MEMORY = 64ull << 20;
+		max_memory = 64ull << 20;
 
 	arg = strstr(arcs_cmdline, "mem=");
 	if (arg) {
-		MAX_MEMORY = memparse(arg + 4, &p);
-		if (MAX_MEMORY == 0)
-			MAX_MEMORY = 32ull << 30;
+		max_memory = memparse(arg + 4, &p);
+		if (max_memory == 0)
+			max_memory = 2ull << 49;
 		if (*p == '@')
 			RESERVE_LOW_MEM = memparse(p + 1, &p);
 	}
@@ -860,13 +865,31 @@ void __init prom_init(void)
 	arcs_cmdline[0] = 0;
 	argc = octeon_boot_desc_ptr->argc;
 	for (i = 0; i < argc; i++) {
-		const char *arg =
-			cvmx_phys_to_ptr(octeon_boot_desc_ptr->argv[i]);
-		if ((strncmp(arg, "MEM=", 4) == 0) ||
+		const char *arg =phys_to_virt(octeon_boot_desc_ptr->argv[i]);
+		if (strncmp(arg, "mem=block:", 10) == 0) {
+			const char *pos = arg + 10;
+			int j;
+
+			for (j = 0; pos[0] && j < ARRAY_SIZE(named_memory_blocks); j++) {
+				int len;
+				char *comma = strchr(pos, ',');
+				if (comma)
+					len = comma - pos;
+				else
+					len = max(strlen(pos), ARRAY_SIZE(named_memory_blocks[0]));
+				strncpy(named_memory_blocks[j], pos, len);
+				if (comma)
+					pos = comma + 1;
+				else
+					break;
+			}
+			for (j = 0; j < ARRAY_SIZE(named_memory_blocks); j++)
+				pr_err("Named Block[%d] = \"%s\"\n", j, named_memory_blocks[j]);
+		}else if ((strncmp(arg, "MEM=", 4) == 0) ||
 		    (strncmp(arg, "mem=", 4) == 0)) {
-			MAX_MEMORY = memparse(arg + 4, &p);
-			if (MAX_MEMORY == 0)
-				MAX_MEMORY = 32ull << 30;
+			max_memory = memparse(arg + 4, &p);
+			if (max_memory == 0)
+				max_memory = 2ull << 49;
 			if (*p == '@')
 				RESERVE_LOW_MEM = memparse(p + 1, &p);
 #ifdef CONFIG_KEXEC
@@ -1010,7 +1033,6 @@ late_initcall(octeon_setup_mipspmu_notifiers);
 #endif
 
 /* Exclude a single page from the regions obtained in plat_mem_setup. */
-#ifndef CONFIG_CRASH_DUMP
 static __init void memory_exclude_page(u64 addr, u64 *mem, u64 *size)
 {
 	if (addr > *mem && addr < *mem + *size) {
@@ -1025,47 +1047,72 @@ static __init void memory_exclude_page(u64 addr, u64 *mem, u64 *size)
 		*size -= PAGE_SIZE;
 	}
 }
-#endif /* CONFIG_CRASH_DUMP */
 
 void __init plat_mem_setup(void)
 {
 	u64 mem_alloc_size = 4 << 20;
 	u64 mem_32_size;
 	u64 total = 0;
+	s64 memory;
 	u64 limit_max, limit_min;
 	u64 system_limit = cvmx_bootmem_available_mem(mem_alloc_size);
 	uint64_t crashk_end;
-#ifndef CONFIG_CRASH_DUMP
-	int64_t memory;
-	uint64_t kernel_start;
-	uint64_t kernel_size;
-#endif
+	const struct cvmx_bootmem_named_block_desc *named_block;
 
 	total = 0;
 	crashk_end = 0;
-
-	/*
-	 * The Mips memory init uses the first memory location for
-	 * some memory vectors. When SPARSEMEM is in use, it doesn't
-	 * verify that the size is big enough for the final
-	 * vectors. Making the smallest chuck 4MB seems to be enough
-	 * to consistently work.
-	 */
-	mem_alloc_size = 4 << 20;
-	if (mem_alloc_size > MAX_MEMORY)
-		mem_alloc_size = MAX_MEMORY;
-
-/* Crashkernel ignores bootmem list. It relies on mem=X@Y option */
-#ifdef CONFIG_CRASH_DUMP
-	add_memory_region(RESERVE_LOW_MEM, MAX_MEMORY, BOOT_MEM_RAM);
-	total += MAX_MEMORY;
-#else
-#ifdef CONFIG_KEXEC
-	if (crashk_size > 0) {
-		add_memory_region(crashk_base, crashk_size, BOOT_MEM_RAM);
-		crashk_end = crashk_base + crashk_size;
+        if (named_memory_blocks[0][0]) {
+                phys_addr_t kernel_begin, kernel_end;
+                phys_addr_t block_begin, block_size;
+                /* Memory from named blocks only */
+                int i;
+
+                kernel_begin = PFN_DOWN(__pa_symbol(&_text)) << PAGE_SHIFT;
+                kernel_end = PFN_UP(__pa_symbol(&_end)) << PAGE_SHIFT;
+
+                for (i = 0;
+                     named_memory_blocks[i][0] && i < ARRAY_SIZE(named_memory_blocks);
+                     i++) {
+                        named_block = cvmx_bootmem_find_named_block(named_memory_blocks[i]);
+                        if (!named_block) {
+                                pr_err("Error: Couldn't find cvmx_bootmem block \"%s\"",
+                                       named_memory_blocks[i]);
+                                return;
+                        }
+                        pr_info("Adding memory from \"%s\": %016lx @ %016lx\n",
+                                named_memory_blocks[i],
+                                (unsigned long)named_block->size,
+                                (unsigned long)named_block->base_addr);
+
+                        block_begin = named_block->base_addr;
+                        block_size = named_block->size;
+                        if (kernel_begin <= block_begin && kernel_end >= block_begin + block_size)
+                                continue;
+
+                        if (kernel_begin > block_begin && kernel_begin < block_begin + block_size) {
+                                u64 sz = kernel_begin - named_block->base_addr;
+                                add_memory_region(named_block->base_addr, sz, BOOT_MEM_RAM);
+                                total += sz;
+                                if (block_begin + block_size <= kernel_end)
+                                        continue;
+                                block_size = block_begin + block_size - kernel_end;
+                                block_begin = kernel_end;
+                        }
+                        if (kernel_end > block_begin && kernel_end < block_begin + block_size) {
+                                block_size = block_begin + block_size - kernel_end;
+                                block_begin = kernel_end;
+                        }
+                        add_memory_region(block_begin, block_size, BOOT_MEM_RAM);
+                        total += block_size;
+                }
+                goto mem_alloc_done;
 	}
-#endif
+
+        if (mem_alloc_size > max_memory)
+                mem_alloc_size = max_memory;
+
+        if (system_limit > max_memory)
+                system_limit = max_memory;
 
 	/* Try to get 256MB (or more) of 32-bit memory */
 	mem_32_size = system_limit <= (16ull * (2 << 30)) ? 256 * (1 << 20) : 512 * (1 << 20);
@@ -1078,8 +1125,7 @@ void __init plat_mem_setup(void)
 	cvmx_bootmem_lock();
 	limit_max = 0xffffffffull;
 	limit_min = 0;
-	while ((boot_mem_map.nr_map < BOOT_MEM_MAP_MAX)
-		&& (total < MAX_MEMORY)) {
+	while ((boot_mem_map.nr_map < BOOT_MEM_MAP_MAX)	&& (total < max_memory)) {
 			if (total >= mem_32_size)
 				limit_max = ~0ull;              /* unlimitted */
 			memory = cvmx_bootmem_phy_alloc(mem_alloc_size,
@@ -1155,16 +1201,9 @@ void __init plat_mem_setup(void)
 		}
 	}
 	cvmx_bootmem_unlock();
-	/* Add the memory region for the kernel. */
-	kernel_start = (unsigned long) _text;
-	kernel_size = _end - _text;
 
-	/* Adjust for physical offset. */
-	kernel_start &= ~0xffffffff80000000ULL;
-	add_memory_region(kernel_start, kernel_size, BOOT_MEM_RAM);
-#endif /* CONFIG_CRASH_DUMP */
-
-#ifdef CONFIG_CAVIUM_RESERVE32
+mem_alloc_done:
+	
 	/*
 	 * Now that we've allocated the kernel memory it is safe to
 	 * free the reserved region. We free it here so that builtin
@@ -1172,7 +1211,6 @@ void __init plat_mem_setup(void)
 	 */
 	if (octeon_reserve32_memory)
 		cvmx_bootmem_free_named("CAVIUM_RESERVE32");
-#endif /* CONFIG_CAVIUM_RESERVE32 */
 
 	if (total == 0)
 		panic("Unable to allocate memory from cvmx_bootmem_phy_alloc");
-- 
1.9.1

