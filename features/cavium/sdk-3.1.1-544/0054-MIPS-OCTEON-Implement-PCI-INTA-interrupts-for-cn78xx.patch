From cd97f80d7ec3f41519221f0601967838fc522747 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 13 Feb 2015 14:03:49 +0530
Subject: [PATCH 054/148] MIPS: OCTEON: Implement PCI INTA interrupts for
 cn78xx

Commit 3a076602756883f312a5bb0c4eee0175b92f537b from
git://git.yoctoproject.org/linux-yocto-3.14

Fix io_resource end value
Their are only 2 bits for pcie port, for 4 ports the pcie ports are 0..3.
Also fixed io_map_base, it is same for all PCIe interfaces.

Fix routing of cn78XX PCIe intA  interrupts.

Fix IO resources start address and array size of pcie devices and
reduce the size of IO resources.
Fixed io_resource start address for each PCIe port and also the
total ioport_resources size.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
Signed-off-by: Abhishek Paliwal <abhishek.paliwal@aricent.com>
---
 arch/mips/pci/pcie-octeon.c | 144 +++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 136 insertions(+), 8 deletions(-)

diff --git a/arch/mips/pci/pcie-octeon.c b/arch/mips/pci/pcie-octeon.c
index 04c955c..44871c6 100644
--- a/arch/mips/pci/pcie-octeon.c
+++ b/arch/mips/pci/pcie-octeon.c
@@ -44,6 +44,132 @@ struct octeon_pcie_interface {
 	int pem;
 };
 
+struct pcie_17400_chip_data {
+	int node;
+	int pem;
+	int pin;
+	int parent_irq;
+	int irq;
+	unsigned int intsn;
+};
+
+static void pcie_17400_enable(struct irq_data *data)
+{
+	struct pcie_17400_chip_data *cd = irq_data_get_irq_chip_data(data);
+	enable_irq(cd->parent_irq);
+}
+
+static void pcie_17400_disable(struct irq_data *data)
+{
+	struct pcie_17400_chip_data *cd = irq_data_get_irq_chip_data(data);
+	disable_irq(cd->parent_irq);
+}
+
+static int pcie_17400_set_affinity(struct irq_data *data,
+				const struct cpumask *dest, bool force)
+{
+	struct pcie_17400_chip_data *cd = irq_data_get_irq_chip_data(data);
+	return irq_set_affinity(cd->parent_irq, dest);
+}
+
+static struct irq_chip pcie_17400_chip = {
+	.name = "PCI-WAR",
+	.irq_enable = pcie_17400_enable,
+	.irq_disable = pcie_17400_disable,
+#ifdef CONFIG_SMP
+	.irq_set_affinity = pcie_17400_set_affinity,
+#endif
+};
+
+static int pcie_17400_irqs[4][4];
+
+static irqreturn_t pcie_17400_handler(int irq, void *data)
+{
+	u64 int_sum;
+	struct pcie_17400_chip_data *cd = data;
+
+	generic_handle_irq(cd->irq);
+
+	int_sum = cvmx_read_csr_node(cd->node, CVMX_PEMX_INT_SUM(cd->pem));
+	if (int_sum & (1ull << (60 + cd->pin))) {
+		/* retrigger the irq */
+		u64 w1s = CVMX_CIU3_ISCX_W1S(cd->intsn);
+		cvmx_write_csr_node(cd->node, w1s, 1);
+		cvmx_read_csr_node(cd->node, w1s);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int __init octeon_pcie78xx_pcibios_map_irq(const struct pci_dev *dev,
+						u8 slot, u8 pin)
+{
+	struct pci_controller *c;
+	struct octeon_pcie_interface *pcie;
+	unsigned int intsn;
+	struct irq_domain *d;
+	struct pcie_17400_chip_data *cd = NULL;
+	int irq;
+	int rv;
+	/*
+	 * Iterate all the way up the device chain and find
+	 * the root bus.
+	 */
+	while (dev->bus && dev->bus->parent)
+		dev = to_pci_dev(dev->bus->bridge);
+
+	c = dev->bus->sysdata;
+	pcie = container_of(c, struct octeon_pcie_interface, controller);
+
+	pin--; /* Adjust from 1 based to 0 based pinA */
+
+	intsn = 0xc003c + pin + (0x1000 * pcie->pem);
+
+	d = octeon_irq_get_block_domain(pcie->node, intsn >> 12);
+
+	irq = irq_create_mapping(d, intsn);
+
+	if (!OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+		return irq;
+
+	if (pcie_17400_irqs[pin][pcie->pem])
+		return pcie_17400_irqs[pin][pcie->pem];
+
+	/* Else use the PCIE-17400 WAR */
+	cd = kzalloc_node(sizeof(*cd), GFP_KERNEL, pcie->node);
+	if (!cd)
+		return -ENOMEM;
+	cd->node = pcie->node;
+	cd->pem = pcie->pem;
+	cd->pin = pin;
+	cd->parent_irq = irq;
+	cd->intsn = intsn;
+
+	cd->irq = irq_alloc_descs(-1, 1, 1, pcie->node);
+	if (WARN(cd->irq < 0, "Unable to find a free irq\n")) {
+		rv = -ENOSPC;
+		goto err;
+	}
+
+	irqd_set_trigger_type(irq_get_irq_data(irq), IRQ_TYPE_EDGE_RISING);
+
+	irq_set_status_flags(irq, IRQ_NOAUTOEN);
+	rv = request_irq(irq, pcie_17400_handler, 0, "inta-war", cd);
+	if (WARN(rv, "request_irq failed.\n"))
+		goto err;
+
+	irq_set_chip_and_handler(cd->irq, &pcie_17400_chip, handle_simple_irq);
+	irq_set_chip_data(cd->irq, cd);
+	pcie_17400_irqs[pin][pcie->pem] = cd->irq;
+
+	return cd->irq;
+
+err:
+	kfree(cd);
+	return rv;
+}
+
+
 /**
  * Map a PCI device to the appropriate interrupt line
  *
@@ -55,7 +181,7 @@ struct octeon_pcie_interface {
  *		 as it goes through each bridge.
  * Returns Interrupt number for the device
  */
-int __init octeon_pcie_pcibios_map_irq(const struct pci_dev *dev,
+static int __init octeon_pcie_pcibios_map_irq(const struct pci_dev *dev,
 				       u8 slot, u8 pin)
 {
 	/*
@@ -439,7 +565,10 @@ static int __init octeon_pcie_setup(void)
 		return 0;
 
 	/* Point pcibios_map_irq() to the PCIe version of it */
-	octeon_pcibios_map_irq = octeon_pcie_pcibios_map_irq;
+	if (octeon_has_feature(OCTEON_FEATURE_CIU3))
+		octeon_pcibios_map_irq = octeon_pcie78xx_pcibios_map_irq;
+	else
+		octeon_pcibios_map_irq = octeon_pcie_pcibios_map_irq;
 
 	/*
 	 * PCIe I/O range. It is based on port 0 but includes up until
@@ -448,8 +577,8 @@ static int __init octeon_pcie_setup(void)
 	set_io_port_base(CVMX_ADD_IO_SEG(cvmx_pcie_get_io_base_address(0)));
 	ioport_resource.start = 0;
 	ioport_resource.end =
-		cvmx_pcie_get_io_base_address(CVMX_PCIE_PORTS) -
-		cvmx_pcie_get_io_base_address(0) + cvmx_pcie_get_io_size(1) - 1;
+		cvmx_pcie_get_io_base_address(CVMX_PCIE_PORTS-1) -
+		cvmx_pcie_get_io_base_address(0) + (1ull << 34) - 1;
 
 	/*
 	 * Create a dummy PCIe controller to swallow up bus 0. IDT bridges
@@ -528,7 +657,7 @@ static int __init octeon_pcie_setup(void)
 				 * based on first slot's value so that both the routines will
 				 * work properly.
 				 */
-				octeon_pcie[port].controller.io_map_base = CVMX_ADD_IO_SEG(cvmx_pcie_get_io_base_address(port));
+				octeon_pcie[port].controller.io_map_base = CVMX_ADD_IO_SEG(cvmx_pcie_get_io_base_address(0));
 				/*
 				 * To keep things similar to PCI, we start
 				 * device addresses at the same place as PCI
@@ -551,10 +680,9 @@ static int __init octeon_pcie_setup(void)
 					octeon_pcie[port].io.end = cvmx_pcie_get_io_size(port) - 1;
 				} else {
 					octeon_pcie[port].controller.io_offset =
-						cvmx_pcie_get_io_base_address(port) - cvmx_pcie_get_io_base_address(port - 1);
 					octeon_pcie[port].io.start =
-						cvmx_pcie_get_io_base_address(port) - cvmx_pcie_get_io_base_address(port - 1);
-					octeon_pcie[port].io.end = octeon_pcie[port].io.start + cvmx_pcie_get_io_size(port) - 1;
+						(cvmx_pcie_get_io_base_address(port) & ((1ull << 34) - 1)) + (1ull << 20);
+					octeon_pcie[port].io.end = octeon_pcie[port].io.start + (1ull << 20);
 				}
 				msleep(100); /* Some devices need extra time */
 				octeon_pcie[port].controller.index = port;
-- 
1.8.2.1

