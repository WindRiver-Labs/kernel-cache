From 0ea8a1b632e38f3c5d25de9851971c5e343c0b75 Mon Sep 17 00:00:00 2001
From: Quanyang Wang <quanyang.wang@windriver.com>
Date: Wed, 19 Nov 2014 12:23:17 -0800
Subject: [PATCH 147/148] MIPS: trace: Fix syscall number is overwritten

When running syscall trace, kernel panic as follow:
CPU 25 Unable to handle kernel paging request at virtual address 000000033c72aa38, epc == ffffffff80268b5c, ra == ffffffff8013da0c
Oops[#1]:
CPU: 25 PID: 24726 Comm: trace-cmd Tainted: G        WC O 3.14.22-rt9-WR7.0.0.0_preempt-rt #2
task: 80000003c789c380 ti: 80000000e3610000 task.ti: 80000000e3610000
$ 0   : 0000000000000000 ffffffff801392a8 000000033c72aa30 0000000000000001
$ 4   : ffffffff8161e470 80000000e3613e50 0000000077620000 0000000000000008
$ 8   : 0000000000000010 0000000000000000 80000000e3613d80 80000000ef02e700
$12   : 80000000e3613e48 80000000ef02e720 ffffffff8013eaa0 80000000e3742f18
$16   : 0000000077620000 80000000e3613e50 ffffffff8161e470 000000000046d1f8
$20   : 000000007f96fdc7 0000000077641490 000000007f96fdff 000000007f96f448
$24   : 0000000003bf0000 ffffffff80514080
$28   : 80000000e3610000 80000000e3613dd0 80000000e3613dd0 ffffffff8013da0c
Hi    : 0000000000000001
Lo    : 0000000000000000
epc   : ffffffff80268b5c ftrace_syscall_exit+0x4c/0x268
    Tainted: G        WC O
ra    : ffffffff8013da0c syscall_trace_leave+0x12c/0x1f0

In function trace_a_syscall, v0 stores the result of the syscall routine,
and it overwrites pt_regs's regs[2] which storing the syscall number. The
function ftrace_syscall_exit use pt_regs's regs[2] as syscall number,
but syscall number is wrong, and cause above panic.

Before the syscall number is overwritten by v0, save it to the register a1
used for ftrace_syscall_exit.

Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/include/asm/ptrace.h | 2 +-
 arch/mips/kernel/ptrace.c      | 4 ++--
 arch/mips/kernel/scall64-64.S  | 3 ++-
 arch/mips/kernel/scall64-n32.S | 3 ++-
 arch/mips/kernel/scall64-o32.S | 3 ++-
 kernel/trace/trace_syscalls.c  | 3 ++-
 6 files changed, 11 insertions(+), 7 deletions(-)

diff --git a/arch/mips/include/asm/ptrace.h b/arch/mips/include/asm/ptrace.h
index b80b572..aaf9796 100644
--- a/arch/mips/include/asm/ptrace.h
+++ b/arch/mips/include/asm/ptrace.h
@@ -83,7 +83,7 @@ static inline long regs_return_value(struct pt_regs *regs)
 #define profile_pc(regs) instruction_pointer(regs)
 
 extern asmlinkage void syscall_trace_enter(struct pt_regs *regs);
-extern asmlinkage void syscall_trace_leave(struct pt_regs *regs);
+extern asmlinkage void syscall_trace_leave(struct pt_regs *regs, long syscall);
 
 extern void die(const char *, struct pt_regs *) __noreturn;
 
diff --git a/arch/mips/kernel/ptrace.c b/arch/mips/kernel/ptrace.c
index 3e99585..3cdaa48 100644
--- a/arch/mips/kernel/ptrace.c
+++ b/arch/mips/kernel/ptrace.c
@@ -936,7 +936,7 @@ asmlinkage void syscall_trace_enter(struct pt_regs *regs)
  * Notification of system call entry/exit
  * - triggered by current->work.syscall_trace
  */
-asmlinkage void syscall_trace_leave(struct pt_regs *regs)
+asmlinkage void syscall_trace_leave(struct pt_regs *regs, long syscall)
 {
         /*
 	 * We may come here right after calling schedule_user()
@@ -948,7 +948,7 @@ asmlinkage void syscall_trace_leave(struct pt_regs *regs)
 	audit_syscall_exit(regs);
 
 	if (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))
-		trace_sys_exit(regs, regs->regs[2]);
+		trace_sys_exit(regs, syscall);
 
 	if (test_thread_flag(TIF_SYSCALL_TRACE))
 		tracehook_report_syscall_exit(regs, 0);
diff --git a/arch/mips/kernel/scall64-64.S b/arch/mips/kernel/scall64-64.S
index b56e254..80d3a76 100644
--- a/arch/mips/kernel/scall64-64.S
+++ b/arch/mips/kernel/scall64-64.S
@@ -100,7 +100,8 @@ syscall_trace_entry:
 	ld	t1, PT_R2(sp)		# syscall number
 	dnegu	v0			# error
 	sd	t1, PT_R0(sp)		# save it for syscall restarting
-1:	sd	v0, PT_R2(sp)		# result
+1:	ld      a1, PT_R2(sp)
+	sd	v0, PT_R2(sp)		# result
 
 	j	syscall_exit
 
diff --git a/arch/mips/kernel/scall64-n32.S b/arch/mips/kernel/scall64-n32.S
index 1037bb5..6beb28c 100644
--- a/arch/mips/kernel/scall64-n32.S
+++ b/arch/mips/kernel/scall64-n32.S
@@ -92,7 +92,8 @@ n32_syscall_trace_entry:
 	ld	t1, PT_R2(sp)		# syscall number
 	dnegu	v0			# error
 	sd	t1, PT_R0(sp)		# save it for syscall restarting
-1:	sd	v0, PT_R2(sp)		# result
+1:	ld      a1, PT_R2(sp)
+	sd	v0, PT_R2(sp)		# result
 
 	j	syscall_exit
 
diff --git a/arch/mips/kernel/scall64-o32.S b/arch/mips/kernel/scall64-o32.S
index 6788727d..01a61ee 100644
--- a/arch/mips/kernel/scall64-o32.S
+++ b/arch/mips/kernel/scall64-o32.S
@@ -134,7 +134,8 @@ trace_a_syscall:
 	ld	t1, PT_R2(sp)		# syscall number
 	dnegu	v0			# error
 	sd	t1, PT_R0(sp)		# save it for syscall restarting
-1:	sd	v0, PT_R2(sp)		# result
+1:	ld	a1, PT_R2(sp)
+	sd	v0, PT_R2(sp)		# result
 
 	j	syscall_exit
 
diff --git a/kernel/trace/trace_syscalls.c b/kernel/trace/trace_syscalls.c
index 7e3cd7a..07f9720 100644
--- a/kernel/trace/trace_syscalls.c
+++ b/kernel/trace/trace_syscalls.c
@@ -359,7 +359,8 @@ static void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)
 	int pc;
 	int syscall_nr;
 
-	syscall_nr = trace_get_syscall_nr(current, regs);
+/*	syscall_nr = trace_get_syscall_nr(current, regs);*/
+	syscall_nr = ret;
 	if (syscall_nr < 0 || syscall_nr >= NR_syscalls)
 		return;
 
-- 
1.8.2.1

