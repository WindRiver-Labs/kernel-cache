From da0cd754388b7c14b786e6c0b7bc8955b92cb90d Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Tue, 12 Aug 2014 16:40:04 -0700
Subject: [PATCH 123/202] watchdog: octeon-wdt: Remove bootloader dependencies.

Make sure the universal NMI exception handler is installed, and then
use it to manage NMI conditions.  Hooks for HOTPLUG_CPU and other
things are now independent, and can be removed from this watchdog
code.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.1-544]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/watchdog/Kconfig           |   2 -
 drivers/watchdog/octeon-wdt-main.c | 179 ++++++++-----------------------------
 drivers/watchdog/octeon-wdt-nmi.S  |   7 +-
 3 files changed, 39 insertions(+), 149 deletions(-)

diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 86b85d5..178a066 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -1082,9 +1082,7 @@ config TXX9_WDT
 config OCTEON_WDT
 	tristate "Cavium OCTEON SOC family Watchdog Timer"
 	depends on CAVIUM_OCTEON_SOC
-	depends on CPU_BIG_ENDIAN || !HOTPLUG_CPU
 	default y
-	select EXPORT_UASM if OCTEON_WDT = m
 	help
 	  Hardware driver for OCTEON's on chip watchdog timer.
 	  Enables the watchdog for all cores running Linux. It
diff --git a/drivers/watchdog/octeon-wdt-main.c b/drivers/watchdog/octeon-wdt-main.c
index d829854..03fbf75 100644
--- a/drivers/watchdog/octeon-wdt-main.c
+++ b/drivers/watchdog/octeon-wdt-main.c
@@ -72,6 +72,7 @@
 #include <asm/uasm.h>
 
 #include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-boot-vector.h>
 #include <asm/octeon/cvmx-ciu2-defs.h>
 
 /* Watchdog interrupt major block number (8 MSBs of intsn) */
@@ -116,125 +117,10 @@ MODULE_PARM_DESC(disable,
 
 static unsigned long octeon_wdt_is_open;
 static char expect_close;
-
-static u32 __initdata nmi_stage1_insns[64];
-/* We need one branch and therefore one relocation per target label. */
-static struct uasm_label __initdata labels[5];
-static struct uasm_reloc __initdata relocs[5];
-
-enum lable_id {
-	label_enter_bootloader = 1
-};
-
-/* Some CP0 registers */
-#define K0		26
-#define C0_CVMMEMCTL 11, 7
-#define C0_STATUS 12, 0
-#define C0_EBASE 15, 1
-#define C0_DESAVE 31, 0
+static void **octeon_wdt_bootvector;
 
 void octeon_wdt_nmi_stage2(void);
 
-static void __init octeon_wdt_build_stage1(void)
-{
-	int i;
-	int len;
-	u32 *p = nmi_stage1_insns;
-#ifdef CONFIG_SMP
-	struct uasm_label *l = labels;
-	struct uasm_reloc *r = relocs;
-	bool is_ciu2 = OCTEON_IS_MODEL(OCTEON_CN68XX);
-#endif
-
-	/*
-	 * For the next few instructions running the debugger may
-	 * cause corruption of k0 in the saved registers. Since we're
-	 * about to crash, nobody probably cares.
-	 *
-	 * Save K0 into the debug scratch register
-	 */
-	uasm_i_dmtc0(&p, K0, C0_DESAVE);
-
-	uasm_i_mfc0(&p, K0, C0_STATUS);
-	/* Force 64-bit addressing enabled */
-	uasm_i_ori(&p, K0, K0, ST0_UX | ST0_SX | ST0_KX);
-	uasm_i_mtc0(&p, K0, C0_STATUS);
-
-#ifdef CONFIG_SMP
-	/*
-	 * If octeon_bootloader_entry_addr is set, we can transfer
-	 * control to the bootloader if it is not a watchdog related
-	 * NMI.
-	 */
-	if (octeon_bootloader_entry_addr) {
-		uasm_il_bbit0(&p, &r, K0, ilog2(ST0_NMI),
-			      label_enter_bootloader);
-		uasm_i_mfc0(&p, K0, C0_EBASE);
-		/* Coreid number in K0 */
-		uasm_i_andi(&p, K0, K0, is_ciu2 ? 0x1f : 0xf);
-		/* 8 * coreid in bits 16-31 */
-		uasm_i_dsll_safe(&p, K0, K0, 3 + 16);
-		uasm_i_ori(&p, K0, K0, 0x8001);
-		uasm_i_dsll_safe(&p, K0, K0, 16);
-		if (is_ciu2) {
-			uasm_i_ori(&p, K0, K0, 0x0701);
-			uasm_i_dsll_safe(&p, K0, K0, 16);
-			uasm_i_ori(&p, K0, K0, 0x0010);
-			uasm_i_drotr_safe(&p, K0, K0, 48);
-			/*
-			 * Should result in: 0x8001,0701,0010,8*coreid which is
-			 * CVMX_CIU2_WDOGX(coreid)
-			 */
-			uasm_i_ld(&p, K0, 0, K0);
-		} else {
-			uasm_i_ori(&p, K0, K0, 0x0700);
-			uasm_i_drotr_safe(&p, K0, K0, 32);
-			/*
-			 * Should result in: 0x8001,0700,0000,8*coreid which is
-			 * CVMX_CIU_WDOGX(coreid) - 0x0500
-			 *
-			 * Now ld K0, CVMX_CIU_WDOGX(coreid)
-			 */
-			uasm_i_ld(&p, K0, 0x500, K0);
-		}
-		/*
-		 * If bit one set handle the NMI as a watchdog event.
-		 * otherwise transfer control to bootloader.
-		 */
-		uasm_il_bbit0(&p, &r, K0, 1, label_enter_bootloader);
-		uasm_i_nop(&p);
-	}
-#endif
-
-	/* Load the address of the second stage handler */
-	UASM_i_LA(&p, K0, (long)octeon_wdt_nmi_stage2);
-	uasm_i_jr(&p, K0);
-	uasm_i_dmfc0(&p, K0, C0_DESAVE);
-
-#ifdef CONFIG_SMP
-	if (octeon_bootloader_entry_addr) {
-		uasm_build_label(&l, p, label_enter_bootloader);
-		/* Jump to the bootloader and restore K0 */
-		UASM_i_LA(&p, K0, (long)octeon_bootloader_entry_addr);
-		uasm_i_jr(&p, K0);
-		uasm_i_dmfc0(&p, K0, C0_DESAVE);
-	}
-#endif
-	uasm_resolve_relocs(relocs, labels);
-
-	len = (int)(p - nmi_stage1_insns);
-	pr_debug("Synthesized NMI stage 1 handler (%d instructions)\n", len);
-
-	pr_debug("\t.set push\n");
-	pr_debug("\t.set noreorder\n");
-	for (i = 0; i < len; i++)
-		pr_debug("\t.word 0x%08x\n", nmi_stage1_insns[i]);
-	pr_debug("\t.set pop\n");
-
-	if (len > 32)
-		panic("NMI stage 1 handler exceeds 32 instructions, was %d\n", len);
-}
-
 static int cpu2core(int cpu)
 {
 #ifdef CONFIG_SMP
@@ -406,18 +292,38 @@ void octeon_wdt_nmi_stage3(u64 reg[32])
 	octeon_wdt_write_string("*** Chip soft reset soon ***\r\n");
 }
 
+static int octeon_wdt_cpu_to_irq(int cpu)
+{
+	unsigned int coreid;
+	int node;
+	int irq;
+
+	coreid = cpu2core(cpu);
+	node = cpu_to_node(cpu);
+
+	if (octeon_has_feature(OCTEON_FEATURE_CIU3)) {
+		struct irq_domain *domain;
+		int hwirq;
+		domain = octeon_irq_get_block_domain(node,
+						     WD_BLOCK_NUMBER);
+		hwirq = WD_BLOCK_NUMBER << 12 | 0x200 | coreid;
+		irq = irq_find_mapping(domain, hwirq);
+	} else {
+		irq = OCTEON_IRQ_WDOG0 + coreid;
+	}
+	return irq;
+
+}
+
 static void octeon_wdt_disable_interrupt(int cpu)
 {
 	unsigned int core;
-	unsigned int irq;
 	int node;
 	union cvmx_ciu_wdogx ciu_wdog;
 
 	core = cpu2core(cpu);
 	node = cpu_to_node(cpu);
 
-	irq = OCTEON_IRQ_WDOG0 + core;
-
 	/* Poke the watchdog to clear out its state */
 	cvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(core), 1);
 
@@ -425,7 +331,7 @@ static void octeon_wdt_disable_interrupt(int cpu)
 	ciu_wdog.u64 = 0;
 	cvmx_write_csr_node(node, CVMX_CIU_WDOGX(core), ciu_wdog.u64);
 
-	free_irq(irq, octeon_wdt_poke_irq);
+	free_irq(octeon_wdt_cpu_to_irq(cpu), octeon_wdt_poke_irq);
 }
 
 static void octeon_wdt_setup_interrupt(int cpu)
@@ -440,6 +346,8 @@ static void octeon_wdt_setup_interrupt(int cpu)
 	core = cpu2core(cpu);
 	node = cpu_to_node(cpu);
 
+	octeon_wdt_bootvector[core] = octeon_wdt_nmi_stage2;
+
 	/* Disable it before doing anything with the interrupts. */
 	ciu_wdog.u64 = 0;
 	cvmx_write_csr_node(node, CVMX_CIU_WDOGX(core), ciu_wdog.u64);
@@ -505,9 +413,6 @@ static void octeon_wdt_ping(void)
 	int cpu;
 	int coreid;
 	int node;
-	int irq;
-	struct irq_domain *domain;
-	int hwirq;
 
 	if (disable)
 		return;
@@ -520,14 +425,7 @@ static void octeon_wdt_ping(void)
 		if ((countdown_reset || !do_coundown) &&
 		    !cpumask_test_cpu(cpu, &irq_enabled_cpus)) {
 			/* We have to enable the irq */
-			if (octeon_has_feature(OCTEON_FEATURE_CIU3)) {
-				domain = octeon_irq_get_block_domain(node,
-						               WD_BLOCK_NUMBER);
-				hwirq = WD_BLOCK_NUMBER << 12 | 0x200 | coreid;
-				irq = irq_find_mapping(domain, hwirq);
-			} else
-				irq = OCTEON_IRQ_WDOG0 + coreid;
-			enable_irq(irq);
+			enable_irq(octeon_wdt_cpu_to_irq(cpu));
 			cpumask_set_cpu(cpu, &irq_enabled_cpus);
 		}
 	}
@@ -744,10 +642,14 @@ static struct notifier_block octeon_wdt_cpu_notifier = {
  */
 static int __init octeon_wdt_init(void)
 {
-	int i;
 	int ret;
 	int cpu;
-	u64 *ptr;
+
+	octeon_wdt_bootvector = cvmx_boot_vector_get();
+	if (!octeon_wdt_bootvector) {
+		pr_err("Error: Cannot allocate boot vector.\n");
+		return -ENOMEM;
+	}
 
 	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
 		counter_shift = 9;
@@ -788,17 +690,6 @@ static int __init octeon_wdt_init(void)
 		return 0;
 	}
 
-	/* Build the NMI handler ... */
-	octeon_wdt_build_stage1();
-
-	/* ... and install it. */
-	ptr = (u64 *) nmi_stage1_insns;
-	for (i = 0; i < 16; i++) {
-		cvmx_write_csr(CVMX_MIO_BOOT_LOC_ADR, i * 8);
-		cvmx_write_csr(CVMX_MIO_BOOT_LOC_DAT, ptr[i]);
-	}
-	cvmx_write_csr(CVMX_MIO_BOOT_LOC_CFGX(0), 0x81fc0000);
-
 	cpumask_clear(&irq_enabled_cpus);
 
 	for_each_online_cpu(cpu)
diff --git a/drivers/watchdog/octeon-wdt-nmi.S b/drivers/watchdog/octeon-wdt-nmi.S
index b42c2c9..38e6f40 100644
--- a/drivers/watchdog/octeon-wdt-nmi.S
+++ b/drivers/watchdog/octeon-wdt-nmi.S
@@ -19,8 +19,6 @@
 	.set 	noat
 	/* Clear Dcache so cvmseg works right. */
 	cache	1,0($0)
-	/* Save K0 into the debug scratch register */
-	dmtc0	k0, $31
 	/* Use K0 to do a read/modify/write of CVMMEMCTL */
 	dmfc0	k0, $11, 7
 	/* Clear out the size of CVMSEG	*/
@@ -29,7 +27,10 @@
 	ori	k0, k0, 0x1c0 | 54
 	/* Store the CVMMEMCTL value */
 	dmtc0	k0, $11, 7
-	/* Restore K0 from the debug scratch register */
+	/*
+	 * Restore K0 from the debug scratch register, it was saved in
+	 * the boot-vector code.
+	 */
 	dmfc0	k0, $31
 
 	/*
-- 
1.8.2.1

