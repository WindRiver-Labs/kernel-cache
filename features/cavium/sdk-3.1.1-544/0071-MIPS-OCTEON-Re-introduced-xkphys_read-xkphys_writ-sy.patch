From c6fa5440f943a0060d3441aa95a01c2fa8f8b975 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 13 Feb 2015 14:46:33 +0530
Subject: [PATCH 071/132] MIPS: OCTEON: Re-introduced xkphys_read, xkphys_writ
 sysmips(2) calls

Commit ccbe17219924356d43ad0cb66d7834f8dcf392fc from
git://git.yoctoproject.org/linux-yocto-3.14

MIPS: Fix warning spew on CONFIG_PREEMPT_DEBUG and ptrace watch register use.
We were getting messages like:
BUG: using smp_processor_id() in preemptible [00000000] code: gdb/1579
caller is ptrace_get_watch_regs+0x80/0x1d8
Call Trace:
[<ffffffff805280cc>] dump_stack+0x8/0x34
[<ffffffff8036f78c>] debug_smp_processor_id+0xdc/0xf0
[<ffffffff8012c6c0>] ptrace_get_watch_regs+0x80/0x1d8
[<ffffffff8012ccd8>] arch_ptrace+0x260/0x4e0
[<ffffffff8015c7e0>] SyS_ptrace+0xe0/0x148
[<ffffffff80132164>] handle_sys64+0x44/0x68
Solution: Access current_cpu_data only within
preempt_disable()/preempt_enable() blocks.
Also add checking for return values from __{get,put}_user();

OCTEON: Per process XKPHYS support
Define prepare_arch_switch() to OCTEON Specific switch function when
per process XKPHYS support is configured.

MIPS: OCTEON: Per-process XKPHYS access.
Trace access to XKPHYS from userspace for all processes.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
Signed-off-by: Abhishek Paliwal <abhishek.paliwal@aricent.com>
[Original patch taken from OCTEON-SDK 3.1.1-544.]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/processor.h    |   5 ++
 arch/mips/include/asm/thread_info.h  |   2 +
 arch/mips/include/uapi/asm/sysmips.h |   2 +
 arch/mips/kernel/ptrace.c            | 148 +++++++++++++++++++++++++++++------
 arch/mips/kernel/syscall.c           |  13 +++
 5 files changed, 147 insertions(+), 23 deletions(-)

diff --git a/arch/mips/include/asm/processor.h b/arch/mips/include/asm/processor.h
index 9b3b48e..9b73bf2 100644
--- a/arch/mips/include/asm/processor.h
+++ b/arch/mips/include/asm/processor.h
@@ -395,6 +395,11 @@ unsigned long get_wchan(struct task_struct *p);
 
 #endif
 
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) || defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+#define prepare_arch_switch(next)  octeon_prepare_arch_switch(next)
+extern void octeon_prepare_arch_switch(struct task_struct *next);
+#endif
+
 /*
  * Functions & macros implementing the PR_GET_FP_MODE & PR_SET_FP_MODE options
  * to the prctl syscall.
diff --git a/arch/mips/include/asm/thread_info.h b/arch/mips/include/asm/thread_info.h
index dd55cd7..28f1b8e 100644
--- a/arch/mips/include/asm/thread_info.h
+++ b/arch/mips/include/asm/thread_info.h
@@ -133,6 +133,8 @@ static inline struct thread_info *current_thread_info(void)
 #define _TIF_FPUBOUND		(1<<TIF_FPUBOUND)
 #define _TIF_LOAD_WATCH		(1<<TIF_LOAD_WATCH)
 #define _TIF_32BIT_FPREGS	(1<<TIF_32BIT_FPREGS)
+#define _TIF_XKPHYS_MEM_EN     (1<<TIF_XKPHYS_MEM_EN)
+#define _TIF_XKPHYS_IO_EN      (1<<TIF_XKPHYS_IO_EN)
 #define _TIF_HYBRID_FPREGS	(1<<TIF_HYBRID_FPREGS)
 #define _TIF_USEDMSA		(1<<TIF_USEDMSA)
 #define _TIF_MSA_CTX_LIVE	(1<<TIF_MSA_CTX_LIVE)
diff --git a/arch/mips/include/uapi/asm/sysmips.h b/arch/mips/include/uapi/asm/sysmips.h
index ae637e9..653394d 100644
--- a/arch/mips/include/uapi/asm/sysmips.h
+++ b/arch/mips/include/uapi/asm/sysmips.h
@@ -21,5 +21,7 @@
 #define MIPS_FIXADE		   7	/* control address error fixing	 */
 #define MIPS_RDNVRAM		  10	/* read NVRAM */
 #define MIPS_ATOMIC_SET		2001	/* atomically set variable	 */
+#define MIPS_CAVIUM_XKPHYS_READ  2010   /* XKPHYS */
+#define MIPS_CAVIUM_XKPHYS_WRITE 2011   /* XKPHYS */
 
 #endif /* _ASM_SYSMIPS_H */
diff --git a/arch/mips/kernel/ptrace.c b/arch/mips/kernel/ptrace.c
index e933a30..382d859 100644
--- a/arch/mips/kernel/ptrace.c
+++ b/arch/mips/kernel/ptrace.c
@@ -47,6 +47,10 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/syscalls.h>
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+#include <asm/octeon/octeon.h>
+#endif
+
 static void init_fp_ctx(struct task_struct *target)
 {
 	/* If FP has been used then the target already has context */
@@ -188,12 +192,14 @@ int ptrace_get_watch_regs(struct task_struct *child,
 			  struct pt_watch_regs __user *addr)
 {
 	enum pt_watch_style style;
-	int i;
+	unsigned int num_valid;
+	u16 watch_reg_masks[NUM_WATCH_REGS];
+	int i, rv;
 
-	if (!cpu_has_watch || boot_cpu_data.watch_reg_use_cnt == 0)
+	if (!cpu_has_watch)
 		return -EIO;
 	if (!access_ok(VERIFY_WRITE, addr, sizeof(struct pt_watch_regs)))
-		return -EIO;
+		return -EFAULT;
 
 #ifdef CONFIG_32BIT
 	style = pt_watch_style_mips32;
@@ -203,41 +209,77 @@ int ptrace_get_watch_regs(struct task_struct *child,
 #define WATCH_STYLE mips64
 #endif
 
-	__put_user(style, &addr->style);
-	__put_user(boot_cpu_data.watch_reg_use_cnt,
-		   &addr->WATCH_STYLE.num_valid);
-	for (i = 0; i < boot_cpu_data.watch_reg_use_cnt; i++) {
-		__put_user(child->thread.watch.mips3264.watchlo[i],
-			   &addr->WATCH_STYLE.watchlo[i]);
-		__put_user(child->thread.watch.mips3264.watchhi[i] & 0xfff,
-			   &addr->WATCH_STYLE.watchhi[i]);
-		__put_user(boot_cpu_data.watch_reg_masks[i],
-			   &addr->WATCH_STYLE.watch_masks[i]);
+	preempt_disable();
+	num_valid = current_cpu_data.watch_reg_use_cnt;
+	memcpy(watch_reg_masks, current_cpu_data.watch_reg_masks,
+	       sizeof(watch_reg_masks));
+	preempt_enable();
+
+	if (num_valid == 0)
+		return -EIO;
+
+	rv = __put_user(style, &addr->style);
+	if (rv)
+		goto out;
+	rv = __put_user(num_valid, &addr->WATCH_STYLE.num_valid);
+	if (rv)
+		goto out;
+	for (i = 0; i < num_valid; i++) {
+		rv = __put_user(child->thread.watch.mips3264.watchlo[i],
+				&addr->WATCH_STYLE.watchlo[i]);
+		if (rv)
+			goto out;
+		rv = __put_user(child->thread.watch.mips3264.watchhi[i] & 0xfff,
+				&addr->WATCH_STYLE.watchhi[i]);
+		if (rv)
+			goto out;
+		rv = __put_user(watch_reg_masks[i],
+				&addr->WATCH_STYLE.watch_masks[i]);
+		if (rv)
+			goto out;
 	}
 	for (; i < 8; i++) {
-		__put_user(0, &addr->WATCH_STYLE.watchlo[i]);
-		__put_user(0, &addr->WATCH_STYLE.watchhi[i]);
-		__put_user(0, &addr->WATCH_STYLE.watch_masks[i]);
+		rv = __put_user(0, &addr->WATCH_STYLE.watchlo[i]);
+		if (rv)
+			goto out;
+		rv = __put_user(0, &addr->WATCH_STYLE.watchhi[i]);
+		if (rv)
+			goto out;
+		rv = __put_user(0, &addr->WATCH_STYLE.watch_masks[i]);
+		if (rv)
+			goto out;
 	}
 
-	return 0;
+out:
+	return rv;
 }
 
 int ptrace_set_watch_regs(struct task_struct *child,
 			  struct pt_watch_regs __user *addr)
 {
-	int i;
+	int i, rv;
+	unsigned int num_valid;
 	int watch_active = 0;
 	unsigned long lt[NUM_WATCH_REGS];
 	u16 ht[NUM_WATCH_REGS];
 
-	if (!cpu_has_watch || boot_cpu_data.watch_reg_use_cnt == 0)
+	if (!cpu_has_watch)
 		return -EIO;
 	if (!access_ok(VERIFY_READ, addr, sizeof(struct pt_watch_regs)))
+		return -EFAULT;
+
+	preempt_disable();
+	num_valid = current_cpu_data.watch_reg_use_cnt;
+	preempt_enable();
+
+	if (num_valid == 0)
 		return -EIO;
+
 	/* Check the values. */
-	for (i = 0; i < boot_cpu_data.watch_reg_use_cnt; i++) {
-		__get_user(lt[i], &addr->WATCH_STYLE.watchlo[i]);
+	for (i = 0; i < num_valid; i++) {
+		rv = __get_user(lt[i], &addr->WATCH_STYLE.watchlo[i]);
+		if (rv)
+			return rv;
 #ifdef CONFIG_32BIT
 		if (lt[i] & __UA_LIMIT)
 			return -EINVAL;
@@ -250,12 +292,14 @@ int ptrace_set_watch_regs(struct task_struct *child,
 				return -EINVAL;
 		}
 #endif
-		__get_user(ht[i], &addr->WATCH_STYLE.watchhi[i]);
+		rv = __get_user(ht[i], &addr->WATCH_STYLE.watchhi[i]);
+		if (rv)
+			return rv;
 		if (ht[i] & ~0xff8)
 			return -EINVAL;
 	}
 	/* Install them. */
-	for (i = 0; i < boot_cpu_data.watch_reg_use_cnt; i++) {
+	for (i = 0; i < num_valid; i++) {
 		if (lt[i] & 7)
 			watch_active = 1;
 		child->thread.watch.mips3264.watchlo[i] = lt[i];
@@ -577,6 +621,64 @@ long arch_ptrace(struct task_struct *child, long request,
 	/* when I and D space are separate, these will need to be fixed. */
 	case PTRACE_PEEKTEXT: /* read word at location addr. */
 	case PTRACE_PEEKDATA:
+		ret = -EIO;
+#if defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS) || defined(CONFIG_CAVIUM_OCTEON_USER_IO)
+		/* check whether its a XKPHYS IO addr (we only allow the
+		   0x80xx.. alias) */
+		if (((unsigned long)addr >> 48) == 0x8001) {
+#ifdef CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS
+			struct task_struct *group_leader;
+
+			group_leader = child->group_leader;
+			if (!test_tsk_thread_flag(group_leader, TIF_XKPHYS_IO_EN))
+				break;
+#endif
+			ret = put_user(*(unsigned long *)addr,
+					(unsigned long __user *) data);
+			break;
+		}
+#endif /* !defined(CONFIG_CAVIUM_OCTEON_USER_IO_DISABLED) */
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) || defined(CONFIG_CAVIUM_OCTEON_USER_MEM)
+		/* check whether its a XKPHYS MEM addr */
+		if (((unsigned long)addr >> 48) == 0x8000) {
+			unsigned long tmp;
+#ifdef CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS
+			struct task_struct *group_leader;
+
+			group_leader = child->group_leader;
+			if (!test_tsk_thread_flag(group_leader, TIF_XKPHYS_MEM_EN))
+				break;
+#endif
+			ret = -EIO;
+			/* ensure that task is 64 bit */
+			if (test_tsk_thread_flag(child, TIF_32BIT_ADDR))
+				break;
+
+			/* extract phy addr from XKPHYS alias */
+			tmp = (unsigned long)addr - 0x8000000000000000ull;
+
+			/* check for boot-bus addr range */
+			if ((tmp >= 0x10000000) && (tmp < 0x20000000))
+				break;
+
+			/* this is for the dram_size comparison below */
+			if (current_cpu_type() == CPU_CAVIUM_OCTEON2) {
+				/* subtract 256MB hole for dram_size comparison */
+				if (tmp >= 0x20000000ull)
+					tmp -= 0x10000000ull;
+			} else {
+				if ((tmp >= 0x410000000ull) && (tmp < 0x420000000ull))
+					tmp -= 0x400000000ull;
+			}
+
+			/* verify that "addr" is within installed dram */
+			if (tmp <= ((octeon_bootinfo->dram_size << 20) - sizeof(tmp)))
+				ret = put_user(*(unsigned long *)addr, (unsigned long __user *) data);
+
+			break;
+		}
+#endif /* !defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) */
+
 		ret = generic_ptrace_peekdata(child, addr, data);
 		break;
 
diff --git a/arch/mips/kernel/syscall.c b/arch/mips/kernel/syscall.c
index dfe3dc8..43ceda2 100644
--- a/arch/mips/kernel/syscall.c
+++ b/arch/mips/kernel/syscall.c
@@ -39,6 +39,11 @@
 #include <asm/uaccess.h>
 #include <asm/switch_to.h>
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+extern int xkphys_usermem_read(long);
+extern int xkphys_usermem_write(long, int);
+#endif
+
 /*
  * For historic reasons the pipe(2) syscall on MIPS has an unusual calling
  * convention.	It returns results in registers $v0 / $v1 which means there
@@ -225,6 +230,14 @@ SYSCALL_DEFINE3(sysmips, long, cmd, long, arg1, long, arg2)
 	case FLUSH_CACHE:
 		__flush_cache_all();
 		return 0;
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	case MIPS_CAVIUM_XKPHYS_READ:
+		return xkphys_usermem_read(arg1);
+
+	case MIPS_CAVIUM_XKPHYS_WRITE:
+		return xkphys_usermem_write(arg1, arg2);
+#endif
+
 	}
 
 	return -EINVAL;
-- 
1.9.1

