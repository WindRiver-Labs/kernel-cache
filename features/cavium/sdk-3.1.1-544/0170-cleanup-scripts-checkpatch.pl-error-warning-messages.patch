From f982c3a53036b92dbce53db04b4b5a6700c1c6ec Mon Sep 17 00:00:00 2001
From: Emil <egoranov@caviumnetworks.com>
Date: Wed, 11 Jun 2014 15:15:40 -0700
Subject: [PATCH 170/202] cleanup scripts/checkpatch.pl error/warning messages

Signed-off-by: Emil <egoranov@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.1-544]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-nand.c | 236 ++++++++++++++++++++--------------
 1 file changed, 143 insertions(+), 93 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-nand.c b/arch/mips/cavium-octeon/octeon-nand.c
index ed1c001..3fd9233 100644
--- a/arch/mips/cavium-octeon/octeon-nand.c
+++ b/arch/mips/cavium-octeon/octeon-nand.c
@@ -9,6 +9,13 @@
  * Copyright (C) 2008 - 2012 Cavium, Inc.
  */
 
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-nand.h>
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-bch.h>
+#include <asm/octeon/cvmx-bch-defs.h>
+#include <linux/ctype.h>
+
 #include <linux/module.h>
 #include <linux/device.h>
 #include <linux/semaphore.h>
@@ -22,12 +29,6 @@
 #include <linux/slab.h>
 #include <net/irda/parameters.h>
 
-#include <asm/octeon/cvmx.h>
-#include <asm/octeon/cvmx-nand.h>
-#include <asm/octeon/octeon.h>
-#include <asm/octeon/cvmx-bch.h>
-#include <asm/octeon/cvmx-bch-defs.h>
-#include <linux/ctype.h>
 
 #define DRIVER_NAME "octeon-nand"
 
@@ -42,7 +43,7 @@
 
 #define MAX_NAND_NAME_LEN       20
 
-static const char *part_probes[] = { "cmdlinepart", NULL };
+static const char * const part_probes[] = { "cmdlinepart", NULL };
 
 #define DEV_DBG(_level, _dev, _format, _arg...)	do {			\
 	if (unlikely(debug & (_level)))					\
@@ -58,7 +59,7 @@ struct octeon_nand {
 	struct mtd_info mtd;
 	struct nand_chip nand;
 	/* Temporary location to store read data, must be 64 bit aligned */
-	uint8_t data[NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE] __attribute__((__aligned__(8)));
+	uint8_t data[NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE] __aligned(8);
 	uint8_t status;
 	int use_status;
 	int data_len;		/* Number of byte in the data buffer */
@@ -103,6 +104,7 @@ static struct octeon_nand *octeon_nand_open_mtd[8];
 static int octeon_nand_bch_correct(struct mtd_info *mtd, u_char *dat,
 				   u_char *read_ecc, u_char *isnull);
 
+
 /*
  * Read a single byte from the temporary buffer. Used after READID
  * to get the NAND information.
@@ -168,7 +170,7 @@ static void octeon_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf,
 		memset(priv->data + priv->data_len, 0xff,
 			sizeof(priv->data) - priv->data_len);
 	} else {
-		printk("Not enough data to write %d bytes\n", len);
+		dev_err(priv->dev, "Not enough data to write %d bytes\n", len);
 	}
 }
 
@@ -233,7 +235,8 @@ static int octeon_nand_hw_bch_read_page(struct mtd_info *mtd,
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
 		int stat;
 
-		DEV_DBG(DEBUG_READ, priv->dev, "Correcting block offset %ld, ecc offset %d\n",
+		DEV_DBG(DEBUG_READ, priv->dev,
+			"Correcting block offset %ld, ecc offset %d\n",
 			p - buf, i);
 
 		stat = chip->ecc.correct(mtd, p, &ecc_code[i], NULL);
@@ -262,16 +265,22 @@ static int octeon_nand_hw_bch_write_page(struct mtd_info *mtd,
 
 	DEV_DBG(DEBUG_WRITE, priv->dev, "%s(%p, %p, %p, %d)\n", __func__, mtd,
 		chip, buf, oob_required);
+	for (i = 0; i < chip->ecc.total; i++)
+		ecc_calc[i] = 0xFF;
 
 	/* Hardware ECC calculation */
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
 		int ret;
+
 		ret = chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+
 		if (ret < 0)
-			DEV_DBG(DEBUG_WRITE, priv->dev, "=== chip->ecc.calculate(mtd, p=%p, &ecc_calc[i]) returned %d\n", p, ret);
+			DEV_DBG(DEBUG_WRITE, priv->dev,
+				"calculate(mtd, p, &ecc_calc[i]) returned %d\n",
+				ret);
 
-		DEV_DBG(DEBUG_WRITE, priv->dev, "block offset %ld, ecc offset %d\n",
-			p - buf, i);
+		DEV_DBG(DEBUG_WRITE, priv->dev,
+			"block offset %ld, ecc offset %d\n", p - buf, i);
 	}
 
 	for (i = 0; i < chip->ecc.total; i++)
@@ -385,6 +394,7 @@ static void octeon_nand_cmdfunc(struct mtd_info *mtd, unsigned command,
 
 	down(&octeon_bootbus_sem);
 	priv->use_status = 0;
+
 	switch (command) {
 	case NAND_CMD_READID:
 		DEV_DBG(DEBUG_CONTROL, priv->dev, "READID\n");
@@ -412,7 +422,8 @@ static void octeon_nand_cmdfunc(struct mtd_info *mtd, unsigned command,
 		 */
 		priv->data_len = cvmx_nand_page_read(priv->selected_chip,
 					(page_addr << nand->page_shift) +
-					(1 << nand->page_shift) - priv->data_index,
+					(1 << nand->page_shift) -
+					priv->data_index,
 					virt_to_phys(priv->data),
 					mtd->oobsize + priv->data_index);
 		if (priv->data_len < mtd->oobsize + priv->data_index) {
@@ -458,6 +469,7 @@ static void octeon_nand_cmdfunc(struct mtd_info *mtd, unsigned command,
 		DEV_DBG(DEBUG_CONTROL, priv->dev, "STATUS\n");
 		priv->status = cvmx_nand_get_status(priv->selected_chip);
 		priv->use_status = 1;
+
 		break;
 
 	case NAND_CMD_SEQIN:
@@ -520,25 +532,28 @@ static void octeon_nand_cmdfunc(struct mtd_info *mtd, unsigned command,
  * Return 0 on success or -1 on failure
  */
 static int octeon_nand_bch_calculate_ecc_internal(struct octeon_nand *priv,
-						  const unsigned char *buf,
-						  unsigned char *code)
+						  const uint8_t *buf,
+						  uint8_t *code)
 {
 	struct nand_chip *nand_chip = &priv->nand;
-	volatile static cvmx_bch_response_t response;
+	static volatile cvmx_bch_response_t response;
 	int rc;
 	int i;
-	void *ecc_ptr;
-	uint8_t ecc_buffer[nand_chip->ecc.bytes] __attribute__((__aligned__(8)));
+	static uint8_t *ecc_buffer;
 
-	if ((ulong)code % 8) {
-		ecc_ptr = ecc_buffer;
-	} else
-		ecc_ptr = code;
+	if (!ecc_buffer)
+		ecc_buffer = kmalloc(1024, GFP_KERNEL);
+	if ((ulong)buf % 8)
+		dev_err(priv->dev, "ECC buffer not aligned!");
+
+	memset(ecc_buffer, 0, nand_chip->ecc.bytes);
 
 	response.u16 = 0;
 
-	rc = cvmx_bch_encode(buf, nand_chip->ecc.size, nand_chip->ecc.strength,
-			     ecc_ptr, &response);
+
+	rc = cvmx_bch_encode((void *)buf, nand_chip->ecc.size,
+			     nand_chip->ecc.strength,
+			     (void *)ecc_buffer, &response);
 
 	if (rc) {
 		dev_err(priv->dev, "octeon_bch_encode failed\n");
@@ -548,8 +563,9 @@ static int octeon_nand_bch_calculate_ecc_internal(struct octeon_nand *priv,
 	udelay(10);
 
 	if (!response.s.done) {
-		DEV_DBG(DEBUG_ALL, priv->dev, "octeon_bch_encode timed out, response done: %d, \
-			 uncorrectable: %d, num_errors: %d, erased: %d\n",
+		DEV_DBG(DEBUG_ALL, priv->dev,
+			"octeon_bch_encode timed out, response done: %d, "
+			 "uncorrectable: %d, num_errors: %d, erased: %d\n",
 			response.s.done, response.s.uncorrectable,
 			response.s.num_errors, response.s.erased);
 		cvmx_bch_shutdown();
@@ -557,9 +573,7 @@ static int octeon_nand_bch_calculate_ecc_internal(struct octeon_nand *priv,
 		return -1;
 	}
 
-	if ((ulong)code % 8) {
-		memcpy(code, ecc_buffer, nand_chip->ecc.bytes);
-	}
+	memcpy(code, ecc_buffer, nand_chip->ecc.bytes);
 
 	for (i = 0; i < nand_chip->ecc.bytes; i++)
 		code[i] ^= priv->eccmask[i];
@@ -575,11 +589,15 @@ static int octeon_nand_bch_calculate_ecc_internal(struct octeon_nand *priv,
  * ecc_code:   buffer for ECC
  */
 static int octeon_nand_bch_calculate(struct mtd_info *mtd,
-		const u_char *dat, unsigned char *ecc_code)
+		const uint8_t *dat, uint8_t *ecc_code)
 {
+	int ret;
 	struct octeon_nand *priv = container_of(mtd, struct octeon_nand, mtd);
 
-	return octeon_nand_bch_calculate_ecc_internal(priv, dat, ecc_code);
+	ret = octeon_nand_bch_calculate_ecc_internal(
+					priv, (void *)dat, (void *)ecc_code);
+
+	return ret;
 }
 
 
@@ -598,26 +616,27 @@ static int octeon_nand_bch_correct(struct mtd_info *mtd, u_char *dat,
 {
 	struct octeon_nand *priv = container_of(mtd, struct octeon_nand, mtd);
 	struct nand_chip *nand_chip = &priv->nand;
-	volatile static cvmx_bch_response_t response;
+	static volatile cvmx_bch_response_t response;
 	int rc;
 	int i = nand_chip->ecc.size + nand_chip->ecc.bytes;
-	static uint8_t *data_buffer = NULL;
-	static int buffer_size = 0;
+	static uint8_t *data_buffer;
+	static int buffer_size;
 	int max_time = 100;
 
 	if (i > buffer_size) {
-		if (data_buffer)
-			kfree(data_buffer);
+		kfree(data_buffer);
 		data_buffer = kmalloc(i, GFP_KERNEL);
 		if (!data_buffer) {
-			dev_err(priv->dev, "%s: Could not allocate %d bytes for buffer\n",
+			dev_err(priv->dev,
+				"%s: Could not allocate %d bytes for buffer\n",
 				__func__, i);
 			goto error;
 		}
 	}
 
 	memcpy(data_buffer, dat, nand_chip->ecc.size);
-	memcpy(data_buffer + nand_chip->ecc.size, read_ecc, nand_chip->ecc.bytes);
+	memcpy(data_buffer + nand_chip->ecc.size, read_ecc,
+							nand_chip->ecc.bytes);
 
 	for (i = 0; i < nand_chip->ecc.bytes; i++)
 		data_buffer[nand_chip->ecc.size + i] ^= priv->eccmask[i];
@@ -774,9 +793,10 @@ static int octeon_read_extended_parameters(struct octeon_nand *priv)
 
 	down(&octeon_bootbus_sem);
 	if (cvmx_nand_read_param_page(priv->selected_chip,
-				      cvmx_ptr_to_phys(priv->data), 1024) != 1024) {
-		dev_err(priv->dev, "Could not read extended parameters from NAND chip %d\n",
-		       priv->selected_chip);
+			      cvmx_ptr_to_phys(priv->data), 1024) != 1024) {
+		dev_err(priv->dev,
+			"Could not read extended parameters from NAND chip %d\n",
+			priv->selected_chip);
 		up(&octeon_bootbus_sem);
 		return -1;
 	}
@@ -792,13 +812,13 @@ static int octeon_read_extended_parameters(struct octeon_nand *priv)
 			continue;
 
 		if (octeon_onfi_crc16(ONFI_CRC_BASE,
-				      (uint8_t *)hdr->sig, size - 2) == le16_to_cpu(hdr->crc))
+			(uint8_t *)hdr->sig, size - 2) == le16_to_cpu(hdr->crc))
 			break;
 		hdr = calc_next_ext_page(hdr, &offset);
 	} while (hdr);
 
-	DEV_DBG(DEBUG_ALL, priv->dev, "Found valid extended parameter page at offset %d\n",
-		offset);
+	DEV_DBG(DEBUG_ALL, priv->dev,
+		"Found valid extended parameter page at offset %d\n", offset);
 
 	/* Since the types are always in order then section type 2 for
 	 * extended ECC information must be within the first two entries.
@@ -808,7 +828,8 @@ static int octeon_read_extended_parameters(struct octeon_nand *priv)
 		if (hdr->section_types[i].type == NAND_EXTENDED_ECC)
 			break;
 		if (hdr->section_types[i].type == NAND_EXTENDED_UNUSED) {
-			dev_err(priv->dev, "%s: No ECC section found\n", __func__);
+			dev_err(priv->dev,
+				"%s: No ECC section found\n", __func__);
 			return 0;
 		}
 
@@ -818,16 +839,18 @@ static int octeon_read_extended_parameters(struct octeon_nand *priv)
 	ecc_info = (struct nand_extended_ecc_info *)
 					(((uint8_t *)(hdr + 1)) + offset);
 
-	DEV_DBG(DEBUG_ALL, priv->dev, "Found extended ecc header at offset %d in header\n", offset);
+	DEV_DBG(DEBUG_ALL, priv->dev,
+		"Found extended ecc header at offset %d in header\n", offset);
 	priv->nand.ecc.strength = ecc_info->ecc_bits;
 	priv->nand.ecc.size = 1 << ecc_info->ecc_size;
 	if (priv->nand.ecc.strength < 0 || priv->nand.ecc.size > 2048) {
-		DEV_DBG(DEBUG_ALL, priv->dev, "NAND ecc size of %d or strength %d not supported\n",
-		       ecc_info->ecc_bits, priv->nand.ecc.size);
+		DEV_DBG(DEBUG_ALL, priv->dev,
+			"NAND ecc size of %d or strength %d not supported\n",
+			ecc_info->ecc_bits, priv->nand.ecc.size);
 		return -1;
 	}
-	DEV_DBG(DEBUG_ALL, priv->dev, "%s: ecc strength: %d, ecc size: %d\n", __func__,
-	      priv->nand.ecc.strength, priv->nand.ecc.size);
+	DEV_DBG(DEBUG_ALL, priv->dev, "%s: ecc strength: %d, ecc size: %d\n",
+		__func__, priv->nand.ecc.strength, priv->nand.ecc.size);
 
 	return 0;
 }
@@ -861,15 +884,18 @@ static int octeon_nand_scan_onfi(struct octeon_nand *priv)
 	if (cvmx_nand_read_param_page(priv->selected_chip,
 				      cvmx_ptr_to_phys(priv->data),
 				      256 * 3) < 256 * 3) {
-		DEV_DBG(DEBUG_ALL, priv->dev, "%s: Error reading ONFI parameter data for chip %d\n",
+		DEV_DBG(DEBUG_ALL, priv->dev,
+			"%s: Error reading ONFI parameter data for chip %d\n",
 		       __func__, priv->selected_chip);
 		goto out;
 	}
 
 	onfi_params =
-		cvmx_nand_onfi_process((cvmx_nand_onfi_param_page_t *)priv->data);
+		cvmx_nand_onfi_process(
+			(cvmx_nand_onfi_param_page_t *)priv->data);
 	if (!onfi_params) {
-		DEV_DBG(DEBUG_ALL, priv->dev, "%s: Invalid ONFI parameter data for chip %d\n",
+		DEV_DBG(DEBUG_ALL, priv->dev,
+			"%s: Invalid ONFI parameter data for chip %d\n",
 			__func__, priv->selected_chip);
 		goto out;
 	}
@@ -880,8 +906,10 @@ static int octeon_nand_scan_onfi(struct octeon_nand *priv)
 	       sizeof(struct nand_onfi_params));
 
 	priv->nand.onfi_version =
-		revision_decode[fls(le16_to_cpu(priv->nand.onfi_params.revision))];
-	DEV_DBG(DEBUG_ALL, priv->dev, "ONFI revision %d\n", priv->nand.onfi_version);
+		revision_decode[
+			fls(le16_to_cpu(priv->nand.onfi_params.revision))];
+	DEV_DBG(DEBUG_ALL, priv->dev,
+		"ONFI revision %d\n", priv->nand.onfi_version);
 
 	priv->nand.page_shift =
 		fls(le32_to_cpu(priv->nand.onfi_params.byte_per_page)) - 1;
@@ -899,10 +927,12 @@ static int octeon_nand_scan_onfi(struct octeon_nand *priv)
 		priv->nand.ecc.bytes = 3;
 		priv->nand.ecc.size = 256;
 		priv->nand.ecc.strength = 1;
-		DEV_DBG(DEBUG_ALL, priv->dev, "NAND chip %d using single bit ECC\n",
+		DEV_DBG(DEBUG_ALL, priv->dev,
+			"NAND chip %d using single bit ECC\n",
 		      priv->selected_chip);
 	} else if (octeon_has_feature(OCTEON_FEATURE_BCH)) {
-		DEV_DBG(DEBUG_ALL, priv->dev, "Using hardware ECC syndrome support\n");
+		DEV_DBG(DEBUG_ALL, priv->dev,
+			"Using hardware ECC syndrome support\n");
 		priv->nand.ecc.mode = NAND_ECC_HW_SYNDROME;
 		priv->nand.ecc.strength = priv->nand.onfi_params.ecc_bits;
 		priv->nand.ecc.read_page = octeon_nand_hw_bch_read_page;
@@ -934,29 +964,42 @@ static int octeon_nand_scan_onfi(struct octeon_nand *priv)
 		 * per above ecc_lvls {4,8, 16...64} are
 		 */
 		int ecc_bytes[] = {8, 15, 30, 45, 60, 75, 90, 105, 113, 120};
-		int ecc_totalbytes[] = {32, 60, 120, 180, 240, 300, 360, 420, 452, 480};
+		int ecc_totalbytes[] = {
+			32, 60, 120, 180, 240, 300, 360, 420, 452, 480};
 		/* first set the desired ecc_level to match ecc_lvls[] */
 		int index = /* 0..9 */
 			(priv->nand.ecc.strength >= 64) ? 9/*64*/ :
-			(priv->nand.ecc.strength > 56 && priv->nand.ecc.strength <= 60) ? 8/*60*/ :
-			(priv->nand.ecc.strength > 48 && priv->nand.ecc.strength <= 56) ? 7/*56*/ :
-			(priv->nand.ecc.strength > 40 && priv->nand.ecc.strength <= 48) ? 6/*48*/ :
-			(priv->nand.ecc.strength > 32 && priv->nand.ecc.strength <= 40) ? 5/*40*/ :
-			(priv->nand.ecc.strength > 48 && priv->nand.ecc.strength <= 32) ? 4/*32*/ :
-			(priv->nand.ecc.strength > 16 && priv->nand.ecc.strength <= 24) ? 3/*24*/ :
-			(priv->nand.ecc.strength >  8 && priv->nand.ecc.strength <= 16) ? 2/*16*/ :
-			(priv->nand.ecc.strength >  4 && priv->nand.ecc.strength <=  8) ? 1/*8*/ :
-			(priv->nand.ecc.strength >  1 && priv->nand.ecc.strength <=  4) ? 0/*4*/: 0;
+			(priv->nand.ecc.strength > 56 &&
+				priv->nand.ecc.strength <= 60) ? 8/*60*/ :
+			(priv->nand.ecc.strength > 48 &&
+				priv->nand.ecc.strength <= 56) ? 7/*56*/ :
+			(priv->nand.ecc.strength > 40 &&
+				priv->nand.ecc.strength <= 48) ? 6/*48*/ :
+			(priv->nand.ecc.strength > 32 &&
+				priv->nand.ecc.strength <= 40) ? 5/*40*/ :
+			(priv->nand.ecc.strength > 48 &&
+				priv->nand.ecc.strength <= 32) ? 4/*32*/ :
+			(priv->nand.ecc.strength > 16 &&
+				priv->nand.ecc.strength <= 24) ? 3/*24*/ :
+			(priv->nand.ecc.strength >  8 &&
+				priv->nand.ecc.strength <= 16) ? 2/*16*/ :
+			(priv->nand.ecc.strength >  4 &&
+				priv->nand.ecc.strength <=  8) ? 1/*8*/ :
+			(priv->nand.ecc.strength >  1 &&
+				priv->nand.ecc.strength <=  4) ? 0/*4*/: 0;
 		/*
-		 * ..then check if there is enough space in OOB to store ECC bytes
-		 * and eventualy (if not) change ecc.strenght the the best possible value
+		 * ..then check if there is enough space in OOB to store
+		 * ECC bytes and eventualy (if not) change ecc.strenght
+		 * the the best possible value
 		 */
-		if (ecc_totalbytes[index] <= cvmx_nand_get_oob_size(priv->selected_chip) - 2) {
+		if (ecc_totalbytes[index] <=
+			cvmx_nand_get_oob_size(priv->selected_chip) - 2) {
 			priv->nand.ecc.strength = ecc_lvls[index];
 			priv->nand.ecc.bytes = ecc_bytes[index];
 		} else {
 			int i = 9;
-			while (ecc_totalbytes[i] > cvmx_nand_get_oob_size(priv->selected_chip))
+			while (ecc_totalbytes[i] >
+				cvmx_nand_get_oob_size(priv->selected_chip))
 				i--;
 			priv->nand.ecc.strength = ecc_lvls[i];
 			priv->nand.ecc.bytes = ecc_bytes[i];
@@ -984,11 +1027,14 @@ static int octeon_nand_scan_onfi(struct octeon_nand *priv)
 		 */
 		priv->nand.ecc.bytes = ((15 * priv->nand.ecc.strength) + 7) / 8;
 
-		priv->nand.ecc.steps = (1 << priv->nand.page_shift) / priv->nand.ecc.size;
+		priv->nand.ecc.steps = (1 << priv->nand.page_shift) /
+							priv->nand.ecc.size;
 		priv->nand.ecc.calculate = octeon_nand_bch_calculate;
 		priv->nand.ecc.correct = octeon_nand_bch_correct;
 		priv->nand.ecc.hwctl = octeon_nand_bch_hwctl;
-		DEV_DBG(DEBUG_INIT, priv->dev, "NAND chip %d using hw_bch ECC for %d bits of correction per %d byte block.  ECC size is %d bytes\n",
+		DEV_DBG(DEBUG_INIT, priv->dev,
+			"NAND chip %d using hw_bch ECC for %d bits of "
+			"correction per %d byte block.  ECC size is %d bytes\n",
 		      priv->selected_chip,
 		      priv->nand.ecc.strength,
 		      priv->nand.ecc.size,
@@ -1001,7 +1047,9 @@ static int octeon_nand_scan_onfi(struct octeon_nand *priv)
 			 * page.
 			 */
 			if (octeon_read_extended_parameters(priv)) {
-				DEV_DBG(DEBUG_INIT, priv->dev, "%s: Error reading ONFI extended parameter data for chip %d\n",
+				DEV_DBG(DEBUG_INIT, priv->dev,
+					"%s: Error reading ONFI extended "
+					"parameter data for chip %d\n",
 				       __func__, priv->selected_chip);
 				return -1;
 			}
@@ -1018,10 +1066,13 @@ static int octeon_nand_scan_onfi(struct octeon_nand *priv)
 		 * total of 52 bits.  Rounding up this is 7
 		 * bytes.
 		 */
-		priv->nand.ecc.bytes = (((fls(priv->nand.ecc.size) - 1 + 3 + 1) *
-				    priv->nand.ecc.strength) + 7) / 8;
-		priv->nand.ecc.steps = (1 << priv->nand.page_shift) / priv->nand.ecc.size;
-		DEV_DBG(DEBUG_INIT, priv->dev, "NAND chip %d using soft_bch ECC for %d bits of correction per %d byte block.  ECC size is %d bytes\n",
+		priv->nand.ecc.bytes = (((fls(priv->nand.ecc.size) - 1 + 3 + 1)
+					* priv->nand.ecc.strength) + 7) / 8;
+		priv->nand.ecc.steps = (1 << priv->nand.page_shift) /
+							priv->nand.ecc.size;
+		DEV_DBG(DEBUG_INIT, priv->dev,
+			"NAND chip %d using soft_bch ECC for %d bits of "
+			"correction per %d byte block.  ECC size is %d bytes\n",
 		      priv->selected_chip,
 		      priv->nand.ecc.strength,
 		      priv->nand.ecc.size,
@@ -1065,9 +1116,9 @@ static int octeon_nand_calc_ecc_layout(struct octeon_nand *priv)
 	layout->eccbytes = chip->ecc.steps * chip->ecc.bytes;
 	/* Reserve 2 bytes for bad block marker */
 	if (layout->eccbytes + 2 > oobsize) {
-		DEV_DBG(DEBUG_INIT, priv->dev, "no suitable oob scheme available "
-		       "for oobsize %d eccbytes %u\n", oobsize,
-		       layout->eccbytes);
+		DEV_DBG(DEBUG_INIT, priv->dev,
+		"no suitable oob scheme available for oobsize %d eccbytes %u\n",
+		oobsize, layout->eccbytes);
 		goto fail;
 	}
 	/* put ecc bytes at oob tail */
@@ -1079,10 +1130,10 @@ static int octeon_nand_calc_ecc_layout(struct octeon_nand *priv)
 	chip->ecc.layout = layout;
 	priv->ecclayout = layout;
 
-	DEV_DBG(DEBUG_INIT, priv->dev, "  layout eccbytes: %d, free offset: %d, free length: %d\n",
-	      layout->eccbytes, layout->oobfree[0].offset,
-	      layout->oobfree[0].length);
-
+	DEV_DBG(DEBUG_INIT, priv->dev,
+		"  layout eccbytes: %d, free offset: %d, free length: %d\n",
+		layout->eccbytes, layout->oobfree[0].offset,
+		layout->oobfree[0].length);
 
 	return 0;
 
@@ -1134,9 +1185,10 @@ static int octeon_nand_hw_bch_init(struct octeon_nand *priv)
 	memset(priv->eccmask, 0, eccbytes);
 	memset(erased_ecc, 0, eccbytes);
 
-	if (octeon_nand_bch_calculate_ecc_internal(priv, erased_page, erased_ecc)) {
+	if (octeon_nand_bch_calculate_ecc_internal(
+		priv, erased_page, erased_ecc))
 		goto fail;
-	}
+
 	kfree(erased_page);
 
 	for (i = 0; i < eccbytes; i++)
@@ -1145,13 +1197,11 @@ static int octeon_nand_hw_bch_init(struct octeon_nand *priv)
 	return 0;
 
 fail:
-	if (priv->eccmask) {
-		kfree(priv->eccmask);
+	if (priv->eccmask)
 		priv->eccmask = NULL;
-	}
+	kfree(priv->eccmask);
 
-	if (erased_page)
-		kfree(erased_page);
+	kfree(erased_page);
 
 	if (rc)
 		cvmx_bch_shutdown();
-- 
1.8.2.1

