From 2b38d1c04bf3319fcdb79d8a868da6c39657aa9f Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Thu, 25 Sep 2014 10:20:02 -0700
Subject: [PATCH 154/202] MIPS: OCTEON: Add NUMA support for cn78XX

Create machine specific bootmem initialization, and add topology
functions.  This gets it to boot, but more changes needed to be able
to use devices on node-1.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.1-544]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/mips/Kconfig                                  |   2 +
 arch/mips/cavium-octeon/Makefile                   |   1 +
 arch/mips/cavium-octeon/octeon-numa.c              | 105 +++++++++++++++++++
 arch/mips/cavium-octeon/setup.c                    | 113 ++++++++++++++++++---
 arch/mips/cavium-octeon/smp.c                      |   1 +
 .../include/asm/mach-cavium-octeon/mach_bootmem.h  |   8 ++
 arch/mips/include/asm/mach-cavium-octeon/mmzone.h  |  20 ++++
 .../mips/include/asm/mach-cavium-octeon/topology.h |  42 ++++++++
 arch/mips/include/asm/octeon/octeon.h              |   7 ++
 9 files changed, 287 insertions(+), 12 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/octeon-numa.c
 create mode 100644 arch/mips/include/asm/mach-cavium-octeon/mach_bootmem.h
 create mode 100644 arch/mips/include/asm/mach-cavium-octeon/mmzone.h
 create mode 100644 arch/mips/include/asm/mach-cavium-octeon/topology.h

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 99fa489..97409d9 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -768,6 +768,7 @@ config CAVIUM_OCTEON_SOC
 	select SYS_SUPPORTS_SMP
 	select NR_CPUS_DEFAULT_64
 	select MIPS_NR_CPU_NR_MAP_1024
+	select SYS_SUPPORTS_NUMA
 	help
 	  This option supports all of the Octeon SoCs and reference
 	  boards from Cavium, Inc. The Cavium Octeon processor is a
@@ -2215,6 +2216,7 @@ config SYS_SUPPORTS_NUMA
 
 config NODES_SHIFT
 	int
+	default "1" if CAVIUM_OCTEON_SOC
 	default "6"
 	depends on NEED_MULTIPLE_NODES
 
diff --git a/arch/mips/cavium-octeon/Makefile b/arch/mips/cavium-octeon/Makefile
index e2ff044f..c29f2d5 100644
--- a/arch/mips/cavium-octeon/Makefile
+++ b/arch/mips/cavium-octeon/Makefile
@@ -21,6 +21,7 @@ obj-y += octeon-memcpy.o
 obj-y += executive/
 
 obj-$(CONFIG_SMP)			+= smp.o
+obj-$(CONFIG_NUMA)			+= octeon-numa.o
 obj-$(CONFIG_SYSFS)			+= octeon-power-throttle.o
 obj-$(CONFIG_SYSFS)                     += cacheinfo.o
 obj-$(CONFIG_MTD)			+= flash_setup.o
diff --git a/arch/mips/cavium-octeon/octeon-numa.c b/arch/mips/cavium-octeon/octeon-numa.c
new file mode 100644
index 0000000..beb151c
--- /dev/null
+++ b/arch/mips/cavium-octeon/octeon-numa.c
@@ -0,0 +1,105 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2014 Cavium, Inc.
+ */
+
+#include <linux/init.h>
+#include <linux/topology.h>
+#include <linux/mm.h>
+#include <linux/nodemask.h>
+#include <linux/bootmem.h>
+#include <linux/swap.h>
+
+#include <asm/sections.h>
+
+#include <asm/pgalloc.h>
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-coremask.h>
+
+
+void octeon_setup_numa(void)
+{
+	int id;
+	int node;
+	struct cpumask *mask;
+	const int coreid = cvmx_get_core_num();
+	struct cvmx_sysinfo *sysinfo = cvmx_sysinfo_get();
+
+	for (id = 0; id < CONFIG_MIPS_NR_CPU_NR_MAP; id++) {
+		if (cvmx_coremask_is_core_set(&sysinfo->core_mask, id)) {
+			node = (id >> 7) & 7;
+			node_set_online(node);
+			node_set_state(node, N_POSSIBLE);
+		}
+	}
+	node = (coreid >> 7) & 7;
+	mask = cpumask_of_node(node);
+	/* The boot CPU will be CPU 0 */
+	cpu_set(0, *mask);
+}
+
+void octeon_numa_cpu_online(void)
+{
+	int node;
+	struct cpumask *mask;
+	const int coreid = cvmx_get_core_num();
+
+	node = (coreid >> 7) & 7;
+	mask = cpumask_of_node(node);
+	cpu_set(smp_processor_id(), *mask);
+}
+
+void __init paging_init(void)
+{
+	unsigned long max_zone_pfns[MAX_NR_ZONES] = {0,};
+	unsigned node;
+
+	pagetable_init();
+
+#ifdef CONFIG_ZONE_DMA
+	max_zone_pfns[ZONE_DMA] = MAX_DMA_PFN;
+#endif
+#ifdef CONFIG_ZONE_DMA32
+	max_zone_pfns[ZONE_DMA32] = MAX_DMA32_PFN;
+#endif
+	for_each_online_node(node) {
+		unsigned long start_pfn, end_pfn;
+
+		get_pfn_range_for_nid(node, &start_pfn, &end_pfn);
+
+		if (end_pfn > max_low_pfn)
+			max_low_pfn = end_pfn;
+	}
+	max_zone_pfns[ZONE_NORMAL] = max_low_pfn;
+
+	free_area_init_nodes(max_zone_pfns);
+}
+
+void setup_zero_pages(void);
+
+void __init mem_init(void)
+{
+	unsigned long codesize, datasize, initsize, tmp;
+	int node;
+
+	for_each_online_node(node) {
+		totalram_pages += free_all_bootmem_node(NODE_DATA(node));
+	}
+	setup_zero_pages();	/* This comes from node 0 */
+
+	codesize =  (unsigned long) &_etext - (unsigned long) &_text;
+	datasize =  (unsigned long) &_edata - (unsigned long) &_etext;
+	initsize =  (unsigned long) &__init_end - (unsigned long) &__init_begin;
+
+	tmp = nr_free_pages();
+	pr_info("Memory: %luk/%luk available (%ldk kernel code, %ldk reserved, %ldk data, %ldk init)\n",
+	       tmp << (PAGE_SHIFT-10),
+	       num_physpages << (PAGE_SHIFT-10),
+	       codesize >> 10,
+	       (num_physpages - tmp) << (PAGE_SHIFT-10),
+	       datasize >> 10,
+	       initsize >> 10);
+}
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index c222ad2..3bdcf97 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -29,6 +29,11 @@
 #include <linux/kexec.h>
 #include <linux/initrd.h>
 
+#include <linux/bootmem.h>
+#include <linux/memblock.h>
+
+#include <mmzone.h>
+
 #include <asm/processor.h>
 #include <asm/reboot.h>
 #include <asm/smp-ops.h>
@@ -836,6 +841,7 @@ append_arg:
 #endif
 
 	octeon_user_io_init();
+	octeon_setup_numa();
 	octeon_setup_smp();
 
 #ifdef CONFIG_CAVIUM_GDB
@@ -1009,17 +1015,8 @@ void __init plat_mem_setup(void)
 	cvmx_bootmem_lock();
 	while ((boot_mem_map.nr_map < BOOT_MEM_MAP_MAX)
 		&& (total < MAX_MEMORY)) {
-#if defined(CONFIG_64BIT) || defined(CONFIG_64BIT_PHYS_ADDR)
-		if (total < MIN_MEM_32)
-			limit_max = (1ull << 32)-1;	/* 4GBytes */
-		else
-			limit_max = ~0ull;		/* unlimitted */
-#elif defined(CONFIG_HIGHMEM)
-		limit_max = (1ull << 31) - 1;	/* 4GBytes */
-#else
-		limit_max = (1ull << 29) - 1;	/* 512MBytes */
-#endif
-		limit_min = __pa_symbol(&__init_end);
+		limit_max = ~0ull;		/* unlimitted */
+		limit_min = 0;
 
 		memory = cvmx_bootmem_phy_alloc(mem_alloc_size,
 				limit_min, limit_max, 0x100000,
@@ -1027,7 +1024,6 @@ void __init plat_mem_setup(void)
 
 		if (memory >= 0) {
 			u64 size = mem_alloc_size;
-
 			/*
 			 * This function automatically merges address
 			 * regions next to each other if they are
@@ -1071,6 +1067,99 @@ mem_alloc_done:
 	cvmx_qlm_init();
 }
 
+struct node_data __node_data[4];
+
+void __init mach_bootmem_init(void)
+{
+	int i;
+	int node;
+
+	min_low_pfn = ~0UL;
+	max_low_pfn = 0;
+
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		unsigned long start, end;
+		struct node_data *nd;
+		bool is_usable;
+
+		switch (boot_mem_map.map[i].type) {
+		case BOOT_MEM_RAM:
+			is_usable = true;
+			break;
+		case BOOT_MEM_KERNEL:
+		case BOOT_MEM_INIT_RAM:
+			is_usable = false;
+			break;
+		default:
+			/* Not usable memory */
+			continue;
+		}
+		start = PFN_UP(boot_mem_map.map[i].addr);
+		end = PFN_DOWN(boot_mem_map.map[i].addr
+				+ boot_mem_map.map[i].size);
+		node = pa_to_nid(boot_mem_map.map[i].addr);
+		nd = __node_data + node;
+
+		if (max_low_pfn < end)
+			max_low_pfn = end;
+		if (min_low_pfn > start)
+			min_low_pfn = start;
+
+		memblock_add_node(PFN_PHYS(start), PFN_PHYS(end - start), node);
+
+		if (nd->endpfn == 0) {
+			nd->startpfn = start;
+			nd->endpfn = end;
+		} else {
+			if (nd->startpfn > start)
+				nd->startpfn = start;
+			if (nd->endpfn < end)
+				nd->endpfn = end;
+		}
+		if (is_usable && (nd->startmempfn == 0 || start < nd->startmempfn))
+			nd->startmempfn = start;
+	}
+	num_physpages = 0;
+
+	for_each_online_node(node) {
+		unsigned long bootmap_size;
+		struct node_data *nd = __node_data + node;
+		if (nd->endpfn == 0)
+			continue;
+		NODE_DATA(node)->bdata = &bootmem_node_data[node];
+		bootmap_size = init_bootmem_node(NODE_DATA(node), nd->startmempfn, nd->startpfn,  nd->endpfn);
+
+		for (i = 0; i < boot_mem_map.nr_map; i++) {
+			int map_nid;
+			bool is_init;
+
+			switch (boot_mem_map.map[i].type) {
+			case BOOT_MEM_RAM:
+				is_init = false;
+				break;
+			case BOOT_MEM_INIT_RAM:
+				is_init = true;
+				break;
+			default:
+				/* Not usable memory */
+				continue;
+			}
+			map_nid = pa_to_nid(boot_mem_map.map[i].addr);
+			if (map_nid != node)
+				continue;
+			memory_present(node,
+				       PFN_DOWN(boot_mem_map.map[i].addr),
+				       PFN_UP(boot_mem_map.map[i].addr + boot_mem_map.map[i].size));
+			if (!is_init) {
+				num_physpages += PFN_DOWN(boot_mem_map.map[i].size);
+				memblock_add_node(boot_mem_map.map[i].addr, boot_mem_map.map[i].size, node);
+				free_bootmem_node(NODE_DATA(node), boot_mem_map.map[i].addr, boot_mem_map.map[i].size);
+			}
+		}
+		reserve_bootmem(PFN_PHYS(nd->startmempfn), bootmap_size, BOOTMEM_DEFAULT);
+	}
+}
+
 /*
  * Emit one character to the boot UART.	 Exported for use by the
  * watchdog timer.
diff --git a/arch/mips/cavium-octeon/smp.c b/arch/mips/cavium-octeon/smp.c
index d620ab4..b58c83f 100644
--- a/arch/mips/cavium-octeon/smp.c
+++ b/arch/mips/cavium-octeon/smp.c
@@ -313,6 +313,7 @@ static void octeon_smp_finish(void)
 	octeon_user_io_init();
 	per_cpu(cpu_state, smp_processor_id()) = CPU_ONLINE;
 	mb();
+	octeon_numa_cpu_online();
 
 	/* to generate the first CPU timer interrupt */
 	write_c0_compare(read_c0_count() + mips_hpt_frequency / HZ);
diff --git a/arch/mips/include/asm/mach-cavium-octeon/mach_bootmem.h b/arch/mips/include/asm/mach-cavium-octeon/mach_bootmem.h
new file mode 100644
index 0000000..3d8d1de
--- /dev/null
+++ b/arch/mips/include/asm/mach-cavium-octeon/mach_bootmem.h
@@ -0,0 +1,8 @@
+#ifndef _ASM_MACH_CAVIUM_OCTEON_MACH_BOOTMEM_H
+#define _ASM_MACH_CAVIUM_OCTEON_MACH_BOOTMEM_H
+
+void mach_bootmem_init(void);
+
+#define mach_bootmem_init mach_bootmem_init
+
+#endif /* _ASM_MACH_CAVIUM_OCTEON_MACH_BOOTMEM_H */
diff --git a/arch/mips/include/asm/mach-cavium-octeon/mmzone.h b/arch/mips/include/asm/mach-cavium-octeon/mmzone.h
new file mode 100644
index 0000000..547098c
--- /dev/null
+++ b/arch/mips/include/asm/mach-cavium-octeon/mmzone.h
@@ -0,0 +1,20 @@
+#ifndef _ASM_MACH_CAVIUM_OCTEON_MMZONE_H
+#define _ASM_MACH_CAVIUM_OCTEON_MMZONE_H
+
+struct node_data {
+#ifdef CONFIG_NUMA
+	struct pglist_data pglist;
+	struct cpumask cpumask_on_node;
+#endif
+	unsigned long startmempfn;
+	unsigned long startpfn;
+	unsigned long endpfn;
+};
+
+extern struct node_data __node_data[];
+
+#ifdef CONFIG_NUMA
+#define NODE_DATA(n)		(&__node_data[(n)].pglist)
+#endif
+
+#endif /* _ASM_MACH_CAVIUM_OCTEON_MMZONE_H */
diff --git a/arch/mips/include/asm/mach-cavium-octeon/topology.h b/arch/mips/include/asm/mach-cavium-octeon/topology.h
new file mode 100644
index 0000000..76a8c2a
--- /dev/null
+++ b/arch/mips/include/asm/mach-cavium-octeon/topology.h
@@ -0,0 +1,42 @@
+#ifndef _ASM_MACH_CAVIUM_OCTEON_TOPOLOGY_H
+#define _ASM_MACH_CAVIUM_OCTEON_TOPOLOGY_H
+
+#ifdef CONFIG_NUMA
+
+static inline int cpu_to_node(int cpu)
+{
+	return (cpu_logical_map(cpu) >> 7) & 7;
+}
+
+static inline struct cpumask *cpumask_of_node(int node)
+{
+	if (node == -1)
+		return cpu_all_mask;
+	return &__node_data[node].cpumask_on_node;
+}
+
+static inline int parent_node(int node)
+{
+	return node;
+}
+
+struct pci_bus;
+static inline int pcibus_to_node(struct pci_bus *bus)
+{
+	return 0;
+}
+
+static inline struct cpumask *cpumask_of_pcibus(struct pci_bus *bus)
+{
+	return cpumask_of_node(pcibus_to_node(bus));
+}
+#endif /* CONFIG_NUMA */
+
+static inline int pa_to_nid(u64 pa)
+{
+	return (pa >> 40) & 7;
+}
+
+#include <asm-generic/topology.h>
+
+#endif /* _ASM_MACH_CAVIUM_OCTEON_TOPOLOGY_H */
diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index 546c329..cd51ec2 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -469,6 +469,13 @@ void octeon_setup_smp(void);
 #else
 static inline void octeon_setup_smp(void) {}
 #endif
+#ifdef CONFIG_NUMA
+void octeon_setup_numa(void);
+void octeon_numa_cpu_online(void);
+#else
+static inline void octeon_setup_numa(void) {}
+static inline void octeon_numa_cpu_online(void) {}
+#endif
 
 extern struct semaphore octeon_bootbus_sem;
 
-- 
1.8.2.1

